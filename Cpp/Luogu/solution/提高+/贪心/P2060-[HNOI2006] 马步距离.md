# [HNOI2006] 马步距离

## 题目描述

在国际象棋和中国象棋中，马的移动规则相同，都是走“日”字，我们将这种移动方式称为马步移动。

如下图所示，从标号为 $0$ 的点出发，可以经过一步马步移动达到标号为 $1$ 的点，经过两步马步移动达到标号为 $2$ 的点。

![](https://cdn.luogu.com.cn/upload/pic/15477.png)

任给平面上的两点 $p$ 和 $s$，它们的坐标分别为 $(x_p,y_p)$ 和 $(x_s,y_s)$，从 $(x,y)$ 出发经过一步马步移动可以达到 $(x+1,y+2)$，$(x+2,y+1)$，$(x+1,y-2)$，$(x+2,y-1)$，$(x-1,y+2)$，$(x-2,y+1)$，$(x-1,y-2)$、$(x-2,y-1)$。

假设棋盘充分大，并且坐标可以为负数。现在请你求出从点 $p$ 到点 $s$ 至少需要经过多少次马步移动？

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $1 \leq x_p,y_p,x_s,y_s \leq 10^7$。

## 样例 #1

### 输入

```
1 2 7 9```

### 输出

```
5```

# 题解

## 作者：Ice_Kissღ (赞：65)

### 简单数学递推，来康康呀
（ 不小心把图片弄挂了，才发现，又补了上来  $QWQ$ 。）


```cpp
#include<bits/stdc++.h>
using namespace std;
int go(int x,int y)
{
    if (x == 1 && y == 0) { return 3; }
    if (x == 2 && y == 2) { return 4; }
    if(y<=x-y)
    {
    	if(x%2==0) { return x/2+(x/2-y)%2; }
        if(x%2==1) { return (x+1)/2+((x+1)/2-y+1)%2; }
    }
    if(y>x-y) { return go(x+1,y-1); }
}
int main()
{
    int x1,x2,y1,y2;
    cin>>x1>>y1>>x2>>y2;
    int a,b;
    a=max(abs(x1-x2),abs(y1-y2));
    b=min(abs(x1-x2),abs(y1-y2));
    cout<<go(a,b);
    return 0;
}
```
那话不多说，我们开始吧 $QWQ$ !

[题目传送门](https://www.luogu.com.cn/problem/P2060)

## 1.输入处理

* 首先，题目可以理解为平面直角坐标系上任意一点到另一点走日字

最少需要的次数。哎呀，好像有点麻烦，怎么办呢？

+ 其实可以这样，我们取两点横纵坐标之差的**绝对值**


**则直接将原题转化为：**

**平面直角坐标系中$(0,0)$到第一象限上任意一点走日字最少需要的次数**。

不过在这里，我特别让那个任意点的横坐标大于纵坐标。

至于为什么要这样做，之后会讲到。

详细代码：

```cpp
    int x1,x2,y1,y2;
    cin>>x1>>y1>>x2>>y2;
    int a,b;
    a=max(abs(x1-x2),abs(y1-y2));//a为任意点的横坐标
    b=min(abs(x1-x2),abs(y1-y2));//b为任意点的纵坐标
```

## 2.核心递推
+ 首先，为了方便大家理解，我将一部分的图画下：

（注：$s3$ 与 $s4$ 共同包含直线 $x=y$,也就是图中白线)

![](https://cdn.luogu.com.cn/upload/image_hosting/ivtsfyul.png)

看仔细了，你是否发现了什么！


是不是发现：马从 $(0,0)$ 出发，走 $i$ 步能到达的点恰好可被分为**三个区域！**

**一部分与坐标轴平行（两个区域，每个区域 $4$ 层）；**

**一部分不与坐标轴平行（为 $3$ 层）不过有特殊点要额外判断。**

### 帮助理解(以 $6$ 为例）：
![](https://cdn.luogu.com.cn/upload/image_hosting/0772vte3.png)

不错不错，可是有三部分窝还是觉得多了，再少点吧 $QAQ$。

所以我特意令 $a$(横坐标) $>$ $b$(横坐标)（易知交换 $ab$ 不改变次数大小)。


则此时我们要讨论的只有两个区间了，也就是 $s1$ 和 $s3$ (见图 $1$ )。

范围缩小了，我们再继续看，会发现一个有趣的事情：


 + **$s1$ 与 $s3$ 被一条一次函数分开，这个一次函数的表达式为    $y= \dfrac{x}{2}$   线上的整点恰为次数的递增！！！**

例：（ $2$ , $1$ ) — $1$, ( $4$ , $2$ ) — $2$, ( $6$ , $3$ ) — 3, ( $x$ , $\dfrac{x}{2}$ ) — $\dfrac{x}{2}$。

那**突破点**也找到了，再分类讨论即可：
```cpp
    if (x == 1 && y == 0) { return 3; }
    if (x == 2 && y == 2) { return 4; }//之前说的特殊情况 。
    if(y<=x-y)//也就是在s1内，通过y<=x/2变换得； 
    {//容易自推出以下两情况 。
    	if(x%2==0) { return x/2+(x/2-y)%2; } 
        if(x%2==1) { return (x+1)/2+((x+1)/2-y+1)%2; }
    }
    if(y>x-y) { return go(x+1,y-1); }
    //也就是在s3内，通过y>x/2变换得。
    //此时我们会发现一个有趣的事情：这个区间内任意一点的值都与它右下角的点相等（见图）；
    //那我们只要不断递推，等到此点落于s1中即可 。
    
```

 最后，完结撒花 $QWQ$ 。

悄悄话：喜欢的话记得点个赞哟 ღღღ 。
























---

## 作者：hulean (赞：36)

### 本题做法：大范围贪心，小范围打表

![404](https://cdn.luogu.com.cn/upload/pic/62661.png)

黄色区域所表示的就是本题索要用的表

```cpp
int biao[5][5]={{0,3,2,3,2},
				{3,2,1,2,3},
				{2,1,4,3,2},
				{3,2,3,2,3},
				{2,3,2,3,4}};
```

- 贪心做法

```cpp
int x=abs(sx-tx);//用x表示终点横坐标与起点横坐标之差
int y=abs(sy-ty);//用y表示终点纵坐标与起点纵坐标之差
while(x>4||y>4)//如果距离大于4，那么继续贪心
{
	if(x<0)x=-x;//距离不能是负数，要转成正数
	if(y<0)y=-y;
	if(x<y)swap(x,y);//交换
	x-=2;y-=1;//有了上面的交换，这里就可以直接这样写了
	ans++;//步数+1
}
```

最后答案就是``ans+biao[x][y]``


## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans;
int sx,sy,tx,ty;
int biao[5][5]={{0,3,2,3,2},
				{3,2,1,2,3},
				{2,1,4,3,2},
				{3,2,3,2,3},
				{2,3,2,3,4}};
int main()
{
	scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
	int x=abs(sx-tx);
	int y=abs(sy-ty);
	while(x>4||y>4)
	{
		if(x<0)x=-x;
		if(y<0)y=-y;
		if(x<y)swap(x,y);
		x-=2;y-=1;
		ans++;
	}
	printf("%d\n",ans+biao[x][y]);
	return 0;
}
```

---

## 作者：wzmzmhk (赞：9)


- [题目传送门](https://www.luogu.com.cn/problem/P2060)
- [博客食用更佳](https://www.luogu.com.cn/blog/wzmzmhk/solution-p2060#)


------------
## 主要思路： 贪心转换 + 简单打表 / BFS。

先看一个可行的例子：

```2 2 6 6```，把图画出来就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/6x40o2we.png)

如果每一个样例都这样去做，**很显然会超时。**

- **贪心转换**：
1. 为了保证程序的效率，我们可以把当前状态转换为起始点为原点的状态，如上图，转换后起始点在 （0,0），目标点在 （4,5）。
1. 对于每一个大于 4 的目标点，我们可以将其不断逼近原点，如上图中把目标点变为第二步的位置，同时建立一个变量 $ans$，每逼近一次就```ans++```，最后的结果加上 $ans$ 即可。

代码如下：
```cpp
    cin >> xp >> yp >> xs >> ys;
    int xx = abs(xp - xs);
    int yy = abs(yp - ys);
    while (xx >= 4 || yy >= 4)
    {
        if (xx > yy) {
            xx -= 2;
            yy -= 1;
        }
        else {
            xx -= 1;
            yy -= 2;
        }
        ans++;
        xx = abs(xx);
        yy = abs(yy);
    }
```

- 打表 / BFS
1. 通过贪心转换后，目标图已经成为了一个 4*4 的图，接下来就可以用BFS来求解。
2. 不想写 BFS 的也可以直接打表，对于 4*4 的图打表应该不难吧。

BFS 代码：
```cpp
struct coord {
    int x, y;
    int sum = 0;
};
queue<coord> q;
map<int, map<int, bool>> m;//这里的m就相当于一个二维数组，用来打标记，但是下标可以为负数
int dx[8] = { -2,-1,1,2,-2,-1,1,2 };
int dy[8] = { 1,2,2,1,-1,-2,-2,-1 };
coord l;
    l.x = 0, l.y = 0;
    q.push(l);
    while (!q.empty()) {
        int x = q.front().x, y = q.front().y, sum = q.front().sum;
        if (x == xx && y == yy) {
            cout << ans + sum;
            return 0;
        }
        q.pop();
        for (int i = 0; i < 8; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (m[nx][ny] == false) {
                m[nx][ny] = true;
                coord l;
                l.x = nx, l.y = ny, l.sum = sum + 1;
                q.push(l);
                m[nx][ny] = true;
            }
        }
    }
```
打表数组：
```cpp
int biao[4][4] = { {0,3,2,3},
                   {3,2,1,2},
                   {2,1,4,3},
                   {3,2,3,2}, };
```


---

## 作者：子归 (赞：7)

# 针对另一个题解的说明。  
代码另一个题解已经很详细了，但还是理解了很久，于是乎解释一下。
### 1. 相对位置
首先是关于相对位置，就好比说是两个向量，如A（0,0）与B（3,3），向量AB就是（3-0,3-0）=（3,3），假设另外两个点为C（2,2），D（5,5）,那么向量CD就是（5-2,5-2）=（3,3）。所以从C到D就是从A到B所需的步数。
### 2.贪心
题解中的马始终在左下角，所以交换的条件就是根据马是不是在左下角而有的，因为每一次都会翻转方阵，所以我们就尽量让棋子往右上角靠，所以如果横纵标相差大的话，就要让纵坐标加的尽量大，这样才能最接近。如果我们想用其他的角，应该也是可以的，不明白的可以去手动操做一下。  
### 3.输出
![](https://i.loli.net/2019/03/26/5c9a330b6266f.png)
这是题解的输出，因为有相对位置的存在，用两横纵标之差，其实就是一个点到零点的距离，如果学过向量就可以知道，乘上一个11是因为打的是一个11*6的表格，就直接到了从原点到（xs-xp,ys-yp）那个点的纵坐标，在加上横坐标和之前的ans就是应有的步数。
### 4.ans
ans就是从坐标原点到初始点的步数/每翻转一次就相当于一次马。
### 5.表
打表可以直接用广搜，11*6够用，是因为每一次翻转都在缩小着范围。
### 大体上就是这个样子，若有不懂的还可以在深入理解一下，Thanks♪(･ω･)ﾉ。

---

## 作者：_Imaginary_ (赞：3)

首先，让我们先试一下这个极端数据：
```
10000000 10000000 1 1
```
假设正方向分别向左、向上，发现这匹马一直会往右下走。

多试几次，我们可以发现马在数据较大时一开始总是朝着一个方向走。

![](https://cdn.luogu.com.cn/upload/image_hosting/ffkn9q2n.png)

好，所以我们可以从这里入手，看看走到什么时候不能继续这样贪心。

![](https://cdn.luogu.com.cn/upload/image_hosting/y0znien3.png)

显然，这里走橙色的线比黑色的先要更优。

再多举几个例子试试，发现最保险的范围是 $4\times4$。

即：当此时马和终点的距离横纵坐标都小于 $4$ 时不能继续贪心。

综上，总体思路是:**大范围贪心，小范围打表。**

具体这张表怎么打可以看看程序中的 extra 表格。（这里只画了四象限表格，因为我有了特殊的~~优化~~处理。）

下面来说一说这是什么处理吧：

对于目标在任何一个象限，我们都能通过将其翻折、对称等手段，全部改成由第二象限指向第四象限。此时，即使为了保险，我们也只需要往外扩展 `5x5` 的格子。

## CODE
```c++
#include<bits/stdc++.h>
using namespace std;
int extra[5][5]={	0,3,2,3,2,
					3,2,1,2,3,
					2,1,4,3,2,
					3,2,3,2,3,
					2,3,2,3,4};
int sx,sy,tx,ty;
int cnt=0;
int main()
{
	scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
	int xx=abs(sx-tx),yy=abs(sy-ty);
	while(xx>4||yy>4)
	{
		xx=abs(xx);
		yy=abs(yy);
		if(xx<yy) xx--,yy-=2;
		else xx-=2,yy--;
		cnt++;
		
	}
	printf("%d",cnt+extra[xx][yy]);
	return 0;
}

```

---

## 作者：zsaskk (赞：3)

~~这个题居然没有直接给公式的？？~~


明显，对于最优情况，我们一直向目标方向跳就可以了，这样一定不会浪费步数。
也就是说;
```
2*x+y=a;
2*y+x=b;
---》
x+y=（a+b）/3
```
可以找一个棋盘手推一下！

x可以理解为横向跳两格的次数，y为纵向条2格的次数，a是水平方向上要走的距离，b是竖直方向上要走的距离。

**但是，我们发现：x，y居然可能解出负数！**

**而且，（x+y）%3可能不为0！**

对于这些情况，我们考虑先跳到最近的满足最优情况的位置，再跳向答案。

1.对于x,y解出负数，有max(x,y)>2 min(x,y)。所以最优情况是一直在距离较远的轴上跳2，直到跳到较近的轴上差1（0也可以）。

然后，我们用暴力广搜推出通项公式。

2.对于(x+y)%3!=0，同样跳到最近位置，再修正一下。
只能是在某个轴上跳1或者2，可以手推，亦可暴力。

ps：考试时对拍AC，（1,0），（0,0），（2,0）没特判，WA--》60。原因是，通项求得答案比实际答案大。准确来说，他们一次都没跳出最优情况，却凭空被加上了常数。


```
#include<bits/stdc++.h>
#define reg register
#define int long long
using namespace std;
inline int chk_digit(char c) { return c>='0'&&c<='9'?1:0; }
inline int read(){
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) { x=x*10+c-'0',c=getchar(); }
	return x*f;
}
int t,ans,dx[9]={0,1,1,-1,-1,2,2,-2,-2},dy[9]={0,2,-2,2,-2,1,-1,1,-1};
inline int mymax(int x,int y) { return x>=y?x:y; }
inline int mymin(int x,int y) { return x>=y?y:x; }
queue<pair<int,int> > q;
map<pair<int,int>,int> dep;
inline void bfs(int ex,int ey){
	while(q.size()) q.pop();
	pair<int,int> tmp;tmp.first=0,tmp.second=0;
	q.push(tmp);dep[tmp]=0;
	while(q.size()){
		pair<int,int> now=q.front();q.pop();
		int x=now.first,y=now.second;
		for(reg int k=1;k<=8;++k){
			int xx=x+dx[k],yy=y+dy[k];
			if(xx==ex&&yy==ey) { ans=dep[now]+1;return; }
			if(xx>=mymax(0,ex)+10||yy>=mymax(0,ey)+10||xx<mymin(ex,0)-10||yy<mymin(0,ey)-10) {  continue;}
			pair<int,int> tmp;
			tmp.first=xx,tmp.second=yy;if(dep[tmp]){  continue;}dep[tmp]=dep[now]+1;
			q.push(tmp);
		}
	}
}
main(){
	t=1;
	while(t--) {
		int xx=read(),xx1=read(),xx2=read(),xx3=read();
		int x=xx-xx2,y=xx1-xx3;
		if(abs(x)<=20&&abs(y)<=20) {
			ans=(1ll<<62);dep.clear();
			bfs(x,y),printf("%lld\n",ans);continue;
		}
		int ans=0;
		if(2*mymin(abs(x),abs(y))>=mymax(abs(x),abs(y))){
			if((abs(x)+abs(y))%3==0){
				ans=(abs(x)+abs(y))/3;
			}
			if((abs(x)+abs(y))%3==1){
				ans=(abs(x)+abs(y))/3+1;
			}
			if((abs(x)+abs(y))%3==2){
				ans=2+(abs(x)+abs(y))/3;
			}
			printf("%lld\n",ans);continue;
		}
		else{
			if(mymin(abs(x),abs(y))!=0);
			ans+=mymin(abs(x),abs(y))-1;int tmp=ans;
			int tmp1=mymax(abs(x),abs(y))-2*tmp;
			if(tmp1%4==2) ans+=tmp1/2;
			if(tmp1%4==1) ans+=(tmp1/4+1)*2;
			if(tmp1%4==3) ans+=(tmp1/4+1)*2;
			if(tmp1%4==0) ans+=(tmp1/4)*2+1;
		}
		printf("%lld\n",ans);
	}
}
```


---

## 作者：konjacq (赞：3)

满篇的Judging/Waiting我也是醉了

这道题先看30%的数据（我们老师给的题），范围是

30%:|xp-xs|<=10,|yp-ys|<=5
100%:xp,yp,xs,ys<=10000000

所以可以打表。

接着想优化：将整个坐标系对称之后，两个点的相对位置不变，所以可以让马在左下角，往右上角走。这样打表只打$11*6$的范围就可以了。

接着想剩下的70%，在距离目标较远的时候可以贪心，接近了就不容易贪心了，于是可以接着打表。
```cpp
inline double len(int x,int y) {return sqrt((x-xs)*(x-xs)+(y-ys)*(y-ys));}

if (len(xp+1,yp+2)<len(xp+2,yp+1)) {xp+=1; yp+=2;}
```

我第一次就是贪心时用了上面那段代码，于是WA了两个点。

```cpp
#include <cmath>
#include <cstdio>
using namespace std;

int xp,yp,xs,ys,ans,m[100]={0,3,2,3,2,3,4,5,4,5,6,3,2,1,2,3,4,3,4,5,6,5,2,1,4,3,2,3,4,5,4,5,6,3,2,3,2,3,4,3,4,5,6,5,2,3,2,3,4,3,4,5,4,5,6,3,4,3,4,3,4,5,4,5,6,5};

inline void swap(int &a,int &b) {int c=a; a=b; b=c;}

int main()
{
	scanf ("%d%d%d%d",&xp,&yp,&xs,&ys);
	if (xp>xs) swap(xp,xs);
	if (yp>ys) swap(yp,ys);//确保马在左下角
	if (xs-xp<6&&ys-yp<11) printf ("%d",m[(xs-xp)*11+ys-yp]);//如果可以直接贪心
	else while (1)
	{
		if (xp>xs) swap(xp,xs);
		if (yp>ys) swap(yp,ys);//确保马在左下角
		if (xs-xp<6&&ys-yp<11)//如果接近了
		{
			printf ("%d",ans+m[(xs-xp)*11+ys-yp]);
			return 0;
		}
		if (xp-xs>yp-ys) {xp+=1; yp+=2;}
		else {xp+=2; yp+=1;}//贪心
		++ans;
	}
	return 0;
}
```

---

## 作者：Vector_Mingfan (赞：2)

信息课时间 + 昨晚干完——题记

------------
思路：
这道题的范围。。。额，还比较大吧，那纯bfs是不能解决的。

然后机智的我们发现其实可以贪心，如果距离过大，走法就很单一，就会一直往终点靠近，那么我们就可以把大范围马上转化为小范围的bfs。那这道题就AC了。

代码如下：

```
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
const int MAXX = 100005;
const int MAXN = 105;
const int INF = 64;

struct node {
    int x,y;
} vc[MAXX];
int f[MAXN][MAXN];
bool vis[MAXN][MAXN];
int dx[8] = {1 , 2 , 1 , 2 , -1 , -2 , -1 , -2};
int dy[8] = {2 , 1 , -2 , -1 , 2 , 1 , -2 , -1};
int xp , yp , xs , ys , x , y , Ans;

int bfs(int xx , int yy) {
    memset(f , INF , sizeof f);
    int h = 1 , t = 1;
    vc[1].x = 0;
	vc[1].y = 0;
	f[0][0] = 0;
	vis[0][0] = 1;
    while(h <= t) {
        node tno = vc[h];
        int nx = vc[h].x ;
        int ny = vc[h].y ;
        for (int i=0; i<8; i++ ) {
            tno.x = vc[h].x + dx[i];
            tno.y = vc[h].y + dy[i];

            if(f[tno.x][tno.y] > f[nx][ny] + 1) {
                f[tno.x][tno.y] = f[nx][ny] + 1;
                if(!vis[tno.x][tno.y]) {
                    vis[tno.x][tno.y] = 1;
                    t++ ;
                    vc[t] = tno;
                    if(tno.x == xx && tno.y == yy) return f[xx][yy];
                }
            }
        }
        h++ ;
        vis[nx][ny] = 0;
    }
}
int main() {
    scanf("%d %d %d %d",&xp,&yp,&xs,&ys);
    x = abs(xp - xs);
	y = abs(yp - ys);
    while (x >= 10 || y >= 10) {
        if(x > y) {
        	x -= 2;
        	y -= 1;
		}
        else {
        	x -= 1;
        	y -= 2;
		}
        Ans++ ;
        x = abs(x);
		y = abs(y);
    }
    printf("%d",Ans + bfs(x , y));
}
```
看了一些大佬的题解，自愧不如。

求管理给过qwq

---

## 作者：zjwwjhy (赞：2)

# 首先
### 由以下表格我们可以得到一定的规律
|坐标之差|最小步数|坐标之差|最小步数|
| -----------: | -----------: | -----------: | -----------: |
|1|2|10|8|
|2|4|11|8|
|3|2|12|8|
|4|4|13|10|
|5|4|14|10|
|6|4|15|10|
|7|6|16|12|
|8|6|17|12|
|9|6|18|12|

**除了2其他都是（坐标之差+2）/3*2 [ 向上取整 ]**

**然而2我们只需特判一下就好了**

**然后我们又可以证明任何数据经过贪心后坐标之差都会相等**（因为~~我不会证~~很简单，所以自己证，~~（反正你们只要知道这样子能过就好了o(*￣︶￣*)o）~~）

以下是代码(～￣▽￣)～
```
#include<bits/stdc++.h>
using namespace std;
int x,y,xx,yy,ans;
int main(){
	cin>>x>>y>>xx>>yy;
	int tx=abs(x-xx),ty=abs(y-yy);
	while(1){
		if(tx*2<ty) ty-=2,tx+=1,ans+=1;
		if(ty*2<tx) tx-=2,ty+=1,ans+=1;
		if(tx<ty) tx-=1,ty-=2,ans+=1;
		if(ty<tx) ty-=1,tx-=2,ans+=1;
		if(ty==tx){
			if(ty!=2) ans+=(ty+2)/3*2;
			else ans+=4;
			cout<<ans<<endl;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：Soledad_S (赞：2)

因为棋盘没有边界，爆搜肯定是GG的。因此考虑贪心，又因为小范围内贪心不能保证正确性，又考虑BFS，~~所以又一道蓝题被切掉了。~~

我跟楼上dalao基本思路一样，只不过把打表换成了宽搜，更容易理解些，在贪心过程中。我们保证x1<x2&&y1<y2。

有个小细节，贪心后的坐标可能是负数或特别大，所以我用了map来存储。

```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<map>
#define y1 I_AK_IOI_y1
#define y2 I_AK_IOI_y2//请无视这两行 
using namespace std;
inline int read() {
    char ch;
    int bj=1;
    while(!isdigit(ch=getchar()))
        if(ch=='-')bj=-1;
    int res=ch-'0';
    while(isdigit(ch=getchar()))
        res=(res<<1)+(res<<3)+ch-'0';
    return res*bj;
}
int x1,x2,y1,y2,ans;
int dx[8]= {2,2,1,-1,-2,-2,1,-1},dy[8]= {1,-1,2,2,1,-1,-2,-2};
map<pair<int,int>,bool>vst;
map<pair<int,int>,int>d;
queue<pair<int,int> >q;
inline void BFS() {//基本操作 
    while(!q.empty())q.pop();
    q.push(make_pair(x1,y1));
    d[make_pair(x1,y1)]=0;
    while(!q.empty()) {
        pair<int,int>tmp=q.front();
        for(int i=0; i<8; i++) {
            int tx=tmp.first+dx[i],ty=tmp.second+dy[i];
            if(vst[make_pair(tx,ty)]==0) {
                vst[make_pair(tx,ty)]=1;
                d[make_pair(tx,ty)]=d[make_pair(tmp.first,tmp.second)]+1;
                if(tx==x2&&ty==y2) {
                    printf("%d\n",d[make_pair(tx,ty)]+ans);
                    return;
                }
                q.push(make_pair(tx,ty));
            }
        }
        q.pop();
    }
}
inline void update() {//根据对称性可证明其正确 
    if(x1>x2)swap(x1,x2);
    if(y1>y2)swap(y1,y2);
}
int main() {
    x1=read();
    y1=read();
    x2=read();
    y2=read();
    update();
    while(abs(x1-x2)>=50||abs(y1-y2)>=50) {//为什么是50呢，因为这个范围内BFS不会太慢且不影响答案 
        update();
        if (x1-x2>y1-y2) {
            x1++;
            y1+=2;
        } else {
            x1+=2;    //贪心
            y1++;
        }
        ans++;
    }
    BFS();
    return 0;
}
```


---


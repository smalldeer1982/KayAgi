# 地砖铺设

## 题目描述

在游戏厅大赚了一笔的小 Z 终于赢到了他想要的家具。乘此机会，他想把自己的房间好好整理一下。

在百货公司，可以买到各种各样正方形的地砖，为了美观起见，小 Z 不希望同样颜色的正方形地砖相邻。所以他找到了小 C 来帮忙解决这件事情。

小 C 很快解决了这个任务。然而，出于某种强迫症，她希望在地上按照长宽划分成网格后，逐行逐列每一块的颜色组成的序列的字典序最小。她希望你帮忙验证一下她的方案。


## 说明/提示

对于 $50\%$ 的数据，保证 $N,M \leq 5$。

对于 $100\%$ 的数据，保证 $1 \leq N,M \leq 100$。


## 样例 #1

### 输入

```
4 3```

### 输出

```
AAA
AAA
AAA
BCB```

# 题解

## 作者：芜湖起飞 (赞：9)

[更好体验（大概](https://www.cnblogs.com/Sheffield/p/13339018.html)

看完题第一反应：我明白了（并没有![](https://img2020.cnblogs.com/blog/2101499/202007/2101499-20200719111537149-970043869.jpg)

~~错误思路~~：能放颜色的放下去，然后尽量拓展，然后做下一个点,纯模拟

-----
快乐敲完，样例一输，过了

网站一交，WA了
![](https://img2020.cnblogs.com/blog/2101499/202007/2101499-20200719110059256-223202424.jpg)

努力想了想

在$N<M$的时候这种贪心并不正确
> 例：
> $N=3,M=5$时

> 错误解法答案：
> 
> AAABB
> 
> AAABB
> 
> AAACA

> 正解：
> 
> AAABA
> 
> AAACB
> 
> AAABA
> 

所以要改变思路，将原来的“**能拓展就拓展**”改为“**判断下一个点能不能放比当前小的颜色，若不能则继续拓展，反之退出拓展**”

来看代码——
```
//:D
#include<bits/stdc++.h>
using namespace std;
const int dx[4] = {-1, 1, 0, 0}, dy[4]={0, 0, 1, -1};

int n, m;
int a[505][505];

bool dif(int k, int x, int y) {//点(x, y)能否放入颜色k 
	if (x > n || y > m) return 0;//越界 
	for (int i = 0; i < 4; i++) {
		int nx = x + dx[i], ny = y + dy[i];
		if (a[nx][ny] == k) return 0;//点(x,y)四周有跟颜色k相同的 
	}
	return 1;
}

bool judge(int k, int x, int y) {
	int nx = x, ny = y;//这块瓷砖初始位置在(x,y)，最后右下角会在(x+nx-1,y+ny-1)，看下面代码理解就好了qwq 
	bool f = 0;//是否成功拓展 
	for (int i = 1; i <= n ; i++)
		if (a[nx][y] == -1 && a[x][ny] == -1 &&//没填色..
			dif(k, nx, y)  && dif(k, x, ny)) {//..并且颜色k可以填在(nx,y)与(x,ny)这两个点 
			int s = -1;
			for (int j = 0; j < k; j++)//枚举每一个小于k的颜色 
				if (dif(j, x, ny)) {//如果(x,ny)可以填这个颜色 
					s = j;//打个标记 
					break;
				}
			if (s != -1)break;//右边能填更优的颜色，停止拓展 
			f = 1;//上面没break说明已经成功拓展了
			nx++, ny++;//做下一个 
		}
		else break;
	for (int i = x; i < nx; i++)
		for (int j = y; j < ny; j++)
			a[i][j] = k;//全部染成这个颜色 
	return f;
}

int main(){
	memset(a,-1,sizeof(a));//a数组值0表示A，1表示B，以此类推，-1表示还没有颜色
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)//枚举每一个点 
			if (a[i][j] == -1)//如果还妹填色 
				for (int k=0 ; k<=25; k++)//枚举要填的颜色 
					if (judge(k, i, j)) break;//judge == 1说明填好了，break去做下一个没填色的点 

	//愉快输出—— 
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++)
			printf("%c", (char)'A' + a[i][j]);
		printf("\n");
	}
	return 0;
}
```

后记：

码风垃圾多多包涵

另外，这道题的答案只会用到ABCD四种颜色，大概是四色定理

完结撒花![](https://img2020.cnblogs.com/blog/2101499/202007/2101499-20200719113145960-1499003513.jpg)

---

## 作者：BitByBit (赞：6)

# 题意
输入一个房间的长和宽，用任意大小的正方形地砖去铺，要求相邻地砖颜色不能相同，求字典序最小的铺法。
# 分析
不难想到这是个贪心，枚举每个点，如果没填过就填字典序最小的地砖，并向后扩展，遇到： 
* 当前位置越界；
* 当前位置可以填字典序更小的地砖；  
* 当前位置不能填当前颜色的地砖；
* 当前位置已经填过了；
  
就退出扩展。最后得到的一定是字典序最小的填法。

由四色定理可得最多只需要 ABCD 四种颜色。
# 程序实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=110;
ll n,m,i,j,k,l,p,q,x,y;
ll a[N][N];
const ll dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
ll check(ll x,ll y,ll z)//判断(x,y)上能不能填z
{
	for(ll i=0;i<=3;i++)
	{
		ll xx=x+dx[i],yy=y+dy[i];
		if(xx<1||xx>n||yy<1||yy>m)continue;
		if(a[xx][yy]==z)return 0;
	}
	return 1;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
		{
			if(a[i][j])continue;//填过了就跳过
			for(k=1;k<=4;k++)//枚举颜色
			{
				if(!check(i,j,k))continue;//不能填就跳过
				for(l=1;l<=200;l++)//枚举边长
				{
					x=i+l-1;y=j+l-1;//地砖右下角的坐标
					if(x>n||y>m||a[i][y]||a[x][j]||!check(i,y,k)||!check(x,j,k))break;
                    //不符合以上条件就退出扩展
					bool flag=0;
					for(p=1;p<=k-1;p++)
						if(check(i,y,p))
						{
							flag=1;
							break;
						}//可以填字典序更小的颜色就退出扩展
					if(flag)break;
				}
				for(p=i;p<=x-1;p++)
					for(q=j;q<=y-1;q++)
						a[p][q]=k;//铺地砖
				break;
			}
		}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
			putchar(a[i][j]+64);
		printf("\n");
	}
}
```

---

## 作者：MloVtry (赞：5)

贪心
虽然第一眼上去是卧了个槽这玩意怎么贪，但她确实是贪心

首先我们可以根据字典序最小来考虑，先放一大块A，然后处理一下边界切开，再放A

这时候我们可以发现情况分为两种

1：
n>=m  这时候可以在后边插入一列bcbcbc来分开，再放A

2：
n<m 这时候可以在下面放一块B，再cbcbc分开，放A

然后就开始各种乱搞

不过搞来搞去总是挂.....

这时候我们不妨换一种思路（上一种是错的）

逐个节点去考虑

对于一个未确定颜色的节点，我可以根据其相连节点，判断出ta的最小可行yanse（记为c）

然后，我们试图去扩大这个矩形

0 0  0
00  0
000   （大概就是这样）

如果可以扩展，我就尽量扩展，直至无法扩展（1.点被占用 2.达到边境  3.无法涂成这个颜色）

我们不妨假定这个点是最小的未确定颜色点，即去掉回车排成一串后，位于它之前

的节点都选好了颜色，那么我们无疑是要让它尽可能小的

而这时，我们可以认为它的颜色是确定的，这时我们考虑它的下一个点，也就是右侧节点：如果这个节点所能选择的最优颜色（不考虑左侧这个我们正在操♂作的点）和我们正在操♂作的点颜色相同，那么假定不把他们并在一起，则这个节点的选择一定会变得更劣（因为这个颜色也不能选了）

所以这样贪心是最优的

代码
    
    
    
    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
int map[110][110];
int get_c(int x,int y)
{
    int use=0;
    if(map[x-1][y]) use|=(1<<map[x-1][y]);
    if(map[x][y-1]) use|=(1<<map[x][y-1]);
    if(map[x][y+1]) use|=(1<<map[x][y+1]);
    int col;
    for(int i=1;;i++)
    {
        if(!(use&(1<<i)))
        {
            col=i;break;
        }
    }
    return col;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int x=1;x<=n;++x)
    for(int y=1;y<=m;++y)
    {
        if(map[x][y]) continue;
        int i=x+1,j=y+1;
        int mc=get_c(x,y);
        while("MloVtry is Handsome")
        {
            if(map[x][j]) break;
            if(map[i][y]) break;
            if(i>n||j>m) break;
            int tc=get_c(x,j);
            if(tc!=mc) break;
            i++,j++; 
        }
        i--;j--;
        for(int a=x;a<=i;++a)
        for(int b=y;b<=j;++b)
        map[a][b]=mc;
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            putchar(map[i][j]+'A'-1);
        }
        putchar('\n');
    }
    return 0;
}

```

---

## 作者：Ehuo_ovo (赞：3)

# [原题链接](https://www.luogu.com.cn/problem/P2102)

### 一道很有意思的贪心题

观察数据规模 $ 1≤N,M≤100$，可知本题不需要什么高深的算法，模拟即可。


#### 我的解法：

从左上到右下依次遍历每个点，先找到目前没有被涂色的点，然后对这个点执行 $work$ 函数判断：

> _**这个点在进行拓展后是否为字典序最小解。**_

然后是判断是否拓展，正方形的拓展即每次判断点 $[x+i,y]$ 和 $[x,y+i]$，如果这两个点**没被染过色且四周没有相同颜色的点**，便可以执行拓展。

但在拓展后仍需判断此次操作是否符合最小字典序，由于字典序优先判断行，所以只需判断点 $[x,y+i]$ **是否有更小的解法**即可。

以及，根据四色原理，每张图最多只需要**四种颜色**即可。

------------


#### 以下为我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int short 

int n,m;
int a[105][105];

bool check(int col,int x,int y){
	if(x>n||y>m||a[x-1][y]==col||a[x+1][y]==col||a[x][y-1]==col||a[x][y+1]==col) return 0;
	return 1;
}

bool work(int col,int x,int y){
	int nx=x,ny=y;
	int f=0;
	for(register int i(1);i<=n;++i){
		if(!a[nx][y]&&!a[x][ny]&&check(col,nx,y)&&check(col,x,ny)){
			int f2=0;
			for(register int j(1);j<col;++j){
				if(check(j,x,ny)){
					f2=1;break;
				}
			}
			if(f2==1) break;
			f=1;
			++nx,++ny;
		}
		if(f==0) return 0;
	}
	for(register int i(x);i<nx;++i){
		for(register int j(y);j<ny;++j){
			a[i][j]=col;
		}
	}
	return 1;
}


signed main(){
	cin>>n>>m;
	for(register int i(1);i<=n;++i){
		for(register int j(1);j<=m;++j){
			if(a[i][j]) continue;
			for(register int k=1;k<=4;k++){
				if(work(k,i,j)) break;
			} 
		}
	}
	for(register int i(1);i<=n;++i){
		for(register int j(1);j<=m;++j){
			putchar(a[i][j]-1+'A');
		}putchar('\n');
	}
} 
```

------------

### 希望对你有所帮助！

---

## 作者：Loser_Syx (赞：3)

## 思路

不得不说这是个好题。

首先考虑一下贪心策略，我们就当前而言，枚举 $(i,j)$ 为左上方顶点，然后再拓展出一个最大的正方形，依次填充。

但是这样子的贪心是错误的，原因是因为在 $a_{i,j}$ 虽然填充到了一个颜色，同时能扩充到 $a_{i,j+1}$ 处，**但是**此时 $a_{i,j+1}$ 处可以填一个比 $a_{i,j}$ 字典序小的一个字符，那么此时就不该扩充。

于是，我们仅需对于枚举的每一个点，算一算它最多能扩充到哪里，且被扩充的地方是否会存在一种更优秀的方案替代其。

注意：在判断是否不需要扩充时，**只要**判断右上角 $j$ 坐标 $+1$ 是否可以填充，因为其他的对答案字典序无影响。

```cpp
#include <iostream>
using namespace std;
typedef long long ll;
int a[1010][1010];
int n, m;
int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
bool pd(int x, int y, int z) {
	auto in = [&](int _1, int _2, int _3) -> bool{
		for (int i = 0; i < 4; ++i) {
			int _x = dir[i][0] + _1, _y = dir[i][1] + _2;
			if (a[_x][_y] == _3) return 0;
		}
		return 1;
	};
	int ans = 0;
	int x_x = x, y_y = y;
	while (x_x <= n && y_y <= m) {
		if (a[x_x][y] == 0 && a[x][y_y] == 0 && in(x_x, y, z) && in(x, y_y, z)) {
			bool can = 0;
			for (int i = 1; i < z; ++i) {
				if (in(x, y_y, i)) {
					can = 1;
					break;
				}
			}
			if (can) break;
			x_x++;
			y_y++;
			ans++;
		} else {
			break;
		}
	}
	if (!ans) return 0;
	for (int i = 1; i <= ans; ++i) {
		for (int j = 1; j <= ans; ++j) {
			a[i + x - 1][y + j - 1] = z;
		}
	}
	return 1;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			if (a[i][j] == 0) {
				for (int k = 1; ; ++k) {
					if (pd(i, j, k)) break;
				}
			}
		}
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			putchar(a[i][j] + 'A' - 1);
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：路人丙 (赞：3)

这道题标准应该是n^3的  
但理论来说n,m范围是可以小于等于5000的.......  
发一个O(n^2)的做法吧   
具体过程见代码
```cpp



#include<bits/stdc++.h>
using namespace std;
int n,m;
char rk[30];
int vala[500001]={0};
//每列最下端的值
int limb[500001]={0};
//每列最下端的位置
int len[500001]={0};
//当前行各个位置相同的字母的长度
inline int get_least(int a,int b)
{
//通过和当前点左边,右边,上边的点比较,贪心得到该点的最小值
    bool boo[30]={0};
    if(limb[a]!=0)
    {
        boo[vala[a]]=true;
    }
    if(limb[a-1]>=b)
    {
        boo[vala[a-1]]=true;
    }
    if(limb[a+1]>=b)
    {
        boo[vala[a+1]]=true;
    }
    for(int i=1;i<=30;i++)
    {
        if(!boo[i])return i;
    }
}

inline void print_ans(int a)
{
    cout<<rk[a];
}

int main()
{
    for(int i=1;i<=26;i++)
    {
        rk[i]=char('A'+i-1);
    }
    //先处理一下
    cin>>n>>m;
    for(int j=1;j<=n;j++)
    {
        for(int i=1;i<=m;i++)
        {
            if(limb[i]>=j)
            {
                print_ans(vala[i]);
                len[i]=0;
                continue;
                //如果这个点已经被铺了就直接输出
            }
            int tlim=n-j+1;
            //防止超出n的范围
            int tv=get_least(i,j);
            if(len[i-1]==0||vala[i-1]!=tv)
            {
                len[i]=1;
                //和前面的不一样len设为1
            }
            else
            {
                len[i]=len[i-1]+1;
                //维护
            }
            if(len[i]==tlim)
            {
                limb[i]=n;
                //到最下端
            }
            vala[i]=tv;
            print_ans(tv);
        }
        for(int i=m;i>=1;i--)
        {
        //从后往前再来一遍,维护len的值
            if(len[i]==0)
            {
                if(limb[i]==0)limb[i]=1;
                continue;
            }
            else
            {
                if(vala[i]==vala[i+1])len[i]=max(len[i+1],len[i]);
                if(limb[i]<j)limb[i]+=len[i];
            }
        }
        cout<<endl;
    }
}

```

---

## 作者：lamboo (赞：2)

呃···不知道为何这道题是蓝的，我感觉完全没有这个难度。本题并没有考什么非常高深的算法，只是纯粹的贪心模拟。

方法一：先在当前位置放入当前位置可以放入的最优值（暴力枚举实现），再尽量扩展，直到不能扩展为止。

当我们打完代码，轻松通过样例，提交上去之后，发现WA了。很不幸，这个方法是错误的。当n<m的时候就会WA

例如，n=5,m=7

方法一输出

AAAAABB

AAAAABB

AAAAACC

AAAAACC

AAAAABA

正解

AAAAABA

AAAAACB

AAAAABA

AAAAACB

AAAAABA

问题出在哪呢？我们发现，在第一行最后，我们输出的是B，但答案是A。这是因为，我们的方法一在不断地扩展B，但是当我们扩展好一个B时，发现接下来一个
已经可以放A了，但是我们还在放B，导致了错误。我们可以对方法一进行改进。

方法二：先在当前位置放入当前位置可以放入的最优值（暴力枚举实现），再尽量扩展，直到不能扩展为止。**因为要使得字典序最小，在扩展的同时，判断下一个扩展的位置能否放入更优的，如果能，就退出扩展。**

显然，如果(x,y1)(x1,y)均可以被扩展，则以(x1,y1)为左上角，(x,y)为右下角的正方形均可被扩展

代码实现完全考察基本功，具体见注释。

------------
完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[502][502];
int n,m,x,y;
bool same(char k,int x,int y)  //判断(x,y)是否可以放入k
{
	if (x>n||y>m) return false;  //判断有没有越界
	if (a[x-1][y]==k&&a[x-1][y]) return false;
	if (a[x+1][y]==k&&a[x+1][y]) return false;
	if (a[x][y-1]==k&&a[x][y-1]) return false;
	if (a[x][y+1]==k&&a[x][y+1]) return false;  //判断有没有与四周相同的
	return true;
}
int pd(char k,int x1,int y1)  //x1,y1表示扩展正方形的左上角坐标
{
	x=x1;
	y=y1;  //x,y表示无法扩展到的行标和列标
	int flag=0;  //flag表示扩展是否成功
	for (int i=1;i<=n;i++)
	    if (!a[x][y1]&&!a[x1][y]&&same(k,x,y1)&&same(k,x1,y))  
          //判断当前位置有没有被放过并且有没有与周围相同
	    {
	    	char min1=0;
	    	for (char ch='A';ch<k;ch++)  //判断右侧位置能否更小
	    	    if (same(ch,x1,y)) 
	    	    {
	    	    	min1=ch;
	    	    	break;
				}
			if (min1) break;  //如果发现右侧可以放更小的，就退出扩展
	    	flag=1;
            x++;y++;  //往下扩展
		}
		else break;
	for (int i=x1;i<x;i++)  //因为x,y表示无法扩展，所以取小于号
	    for (int j=y1;j<y;j++) a[i][j]=k;  //赋值，扩展
	return flag;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	    for (int j=1;j<=m;j++)
	        if (!a[i][j])
	            for (char k='A';k<='Z';k++)  //从小到大枚举当前位置可以放的最小值 
	            {
	            	int x=pd(k,i,j);
	            	if (x) break;  //如果成功放入，说明当前位置已经放入了最优值，退出
				}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		    printf("%c",a[i][j]);
		printf("\n");
	} //愉快输出
	return 0;
}
```
------------
本蒟蒻发现貌似所有的答案均可以用ABCD表示？？？由于本蒟蒻数学不好，各位大佬有兴趣可以证明一下。

---

## 作者：Tzs_yousa (赞：1)

## 模拟贪心
很简单，只需要在当前位置放入当前位置可以放入的字典序最小的，再往后扩展。

如果在某个位置已经放入最优解，那就可以直接跳出，因为不可能再有更优的。

而与大多数人的错误思路所不同的就是对小于当前位置的几个字符枚举一下即可。
```cpp
for (int j = 1; j < k; j++) //对比当前字符小的进行计算 
   if (check(j, a, y)) 
   {
	minn = j;
	break;
   }
```
最后暴力赋值，具体看代码（个人觉得码风好看很好理解）。
```cpp
#include <bits/stdc++.h>
#define int long long
const int MAXN = 501;
using namespace std;
int n, m, G[MAXN][MAXN];
bool check(int k, int x, int y) 
{ 
	if(x > n || y > m) return false;
	if (G[x - 1][y] == k && G[x - 1][y]) return false;
	if (G[x + 1][y] == k && G[x + 1][y]) return false;
	if (G[x][y - 1] == k && G[x][y - 1]) return false;
	if (G[x][y + 1] == k && G[x][y + 1]) return false;//对相邻每个位置都判断一下，当全部满足时才能返回true 
	return true;
}
bool solve(int k, int a, int b)
{
	int x = a, y = b;
	bool fl = false; 
	for (int i = 1; i <= n; i++)
	    if (!G[x][b] && !G[a][y] && check(k, x, b) && check(k, a, y))//判断有没有放过且不重复  
	    {
			int minn = 0;
	    	for (int j = 1; j < k; j++) //对比当前字符小的进行计算 
	    	    if (check(j, a, y)) 
	    	    {
	    	    	minn = j;
	    	    	break;
				}
			if (minn) break; 
	    	fl = true;
            x++, y++;
		}
		else break;
	for (int i = a; i < x; i++)//赋值 
	    for (int j = b; j < y; j++) G[i][j] = k; 
	return fl;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
		{
			if(!G[i][j])// 还没有处理最优值 
			{
				for (int k = 1; k <= 26; k++)//二十六个英文字母，注意从一开始，因为第20行我初始化是0，所以如果从零开始那就挂了，最后输出再减个一就行 
	            {
	            	if (solve(k, i, j)) break;//如果以及放入退出即可  
				}
			}
		}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
			cout << char(G[i][j] + 'A' - 1); // 记得减个1 
		cout << endl;
	}
	return 0;
}
```
完结撒花！

---

## 作者：aeiouaoeiu (赞：0)

从上往下枚举每一行，对于每一行从左往右枚举，我们显然希望当前这一位在不破坏已经填好的字母的同时达到最小。

设在考虑到已经填好的字母时，这个点能取的最小字母为 $c$，则首先这个点一定能取到 $c$。

考虑往右拓展这个块，当遇到不能再往右拓展的情况（碰到边界或者已经填好的字母，碰到相邻字母中已经有 $c$ 的点）时，显然需要停止拓展；如果碰到一个点，这个点能取的字母小于 $c$，显然这时也应该停止拓展。

直接模拟整个流程即可，时间复杂度 $\mathcal{O}(nm)$。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define mp make_pair 
#define pob pop_back
using namespace std;
typedef long long ll;
const ll maxn=107,ee=1e18,p=1e9+7;
ll n,m,a[maxn][maxn],vis[10];
void fil(ll i,ll s,ll k,ll c){
    if(c==ee) c=0;
    for(int x=i;x<=i+k-1;x++)for(int y=s;y<=s+k-1;y++) a[x][y]=c;
}
int main(void){
    //freopen("data.in","r",stdin); 
    //freopen("data.out","w",stdout);
    ios::sync_with_stdio(0),cin.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)for(ll j=1,k=0,c=ee,s=0,cur;j<=m;j++){
        if(a[i][j]){fil(i,s,k,c); k=0,c=ee,s=0; continue;}
        vis[1]=vis[2]=vis[3]=vis[4]=0;
        vis[a[i][j-1]]++,vis[a[i-1][j]]++,vis[a[i][j+1]]++;
        if(!vis[1]) cur=1; else if(!vis[2]) cur=2; else if(!vis[3]) cur=3; else cur=4;
        if(cur<c||a[i-1][j]==c) fil(i,s,k,c),s=j,k=1,c=cur;
        else k++;
        if(j==m||i+k-1==n) fil(i,s,k,c),k=0,c=ee,s=0;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) cout<<char(a[i][j]-1+'A'); cout<<"\n";
    }
    return 0;
}
```

---


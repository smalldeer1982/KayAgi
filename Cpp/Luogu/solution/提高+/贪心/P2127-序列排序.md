# 序列排序

## 题目描述

小C有一个N个数的整数序列，这个序列的中的数两两不同。小C每次可以交换序列中的任意两个数，代价为这两个数之和。小C希望将整个序列升序排序，问小C需要的最小代价是多少？


## 说明/提示

数据范围：

对于30%的数据，1<=N<=10；

对于全部的数据，1<=N<=100000，输入数据中的其他整数均为正整数且不超过 $10^9$。


## 样例 #1

### 输入

```
6
8 4 5 3 2 7```

### 输出

```
34```

# 题解

## 作者：Manjusaka丶梦寒 (赞：13)

感觉可能自己的想法比较简单一点吧...

![](https://img2018.cnblogs.com/blog/1376345/201810/1376345-20181012074018226-85279736.jpg)

看这个图中的的点如果形成一个环，贪心的考虑，要想花费最少，那么我们一定要多次利用最小那个点。

图中来看就是2和6交换，然后2和4交换，然后就交换完了。

然而还有一种换法就是，这个环中最小的点和序列中最小的点先交换，然后在进行环内的操作(就是说先2和1交换...)。

所以对于每个点dfs找到环，然后判断两种方法哪种更优，统计答案。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
#define LL long long
#define inf 2147483647
LL n,a[100006],b[100006],MIN,pos[100006],siz,sum,minn;
bool vis[100006];
LL ans;
void dfs(int x)
{
    if(vis[x])return ;
    sum+=a[x];    //记录环内每个点的总和 
    siz++;        //环内有多少个点 
    MIN=min(MIN,a[x]);    //环内最小值 
    vis[x]=1;    //打上标记 
    dfs(pos[x]);    //下一个点 
}
int main()
{
    scanf("%d",&n);
    minn=MIN=inf;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        b[i]=a[i];
        minn=min(minn,a[i]);    //记录序列最小值 
    }
    sort(b+1,b+1+n);    //排序 
    for(int i=1;i<=n;i++)
        pos[i]=lower_bound(b+1,b+1+n,a[i])-b;    //记录排序后的位置 
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            dfs(i);
            ans+=min(sum+MIN+minn*(siz+1),sum+MIN*(siz-2));
/*
        方法一：交换序列最小值和环内最小值 + 序列最小值 * 环内点数 
        方法二：环内最小值*环内点数。 
*/ 
            siz=0; sum=0; MIN=inf;
        }
    }
    printf("%lld",ans);
}
```

---

## 作者：pandaSTT (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P2127)

[更好的阅读体验？](https://www.luogu.com.cn/blog/cathyqwq/p2127-xu-lie-pai-xu-ti-xie)

## 前置知识

**并查集**

建议先完成[这道题](https://www.luogu.com.cn/problem/P3367)

## 分析

首先构造一组数据：

	3
    2 3 1
    
我们发现如果想让整个序列升序排序，需要将当前 1 移动至当前 2 的位置，将当前 2 移动至当前 3 的位置，而当前 3 的位置需要移动至当前 1 的位置，也就是说，**这些移动构成了一个环！**

因此我们可以用并查集维护这样一个环，而最小代价则是处理每个环的最小代价之和。

对于每个环，我们需要维护 4 个值：

>1. 这个环的根节点
>2. 这个环中的最小值
>3. 这个环的权值之和
>4. 这个环的节点数量

对于每个环的最小代价，我们需要讨论两种情况：

### 1. 运用环内最小值进行交换

用 **环内最小值**交换**节点数量减一**次，再加上**除这个环中的最小值之外其余节点的权值之和**，就是这个环运用环内最小值进行交换的代价。

#### 具体表示

	(people[i]-1)*minn[i]+sum[i]-minn[i]
    
### 2. 运用环外最小值进行交换

首先将环内最小值与环外最小值进行交换，再用 **环外最小值**交换**节点数量减一**次，再加上**除这个环中的最小值之外其余节点的权值之和**，最后将环内最小值与环外最小值进行交换回来，就是这个环运用环外最小值进行交换的代价。

#### 具体表示

	(people[i]-1)*mina+sum[i]-minn[i]+2*(mina+minn[i])

## 代码

```cpp
  #include<bits/stdc++.h>
  #define int long long
  using namespace std;
  inline char gc(){
      static char buf[1000010],*p1=buf,*p2=buf;
      return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000010,stdin),p1==p2)?EOF:*p1++;
  }
  inline int read(){
      register int x=0,f=0;
      static char s=gc();
      while(s<'0'||s>'9')f|=s=='-',s=gc();
      while(s>='0'&&s<='9'){
          x=(x<<3)+(x<<1)+(s^48);s=gc();
      }return f?-x:x;
  }
  inline void write(register int x){
      if(x<0)putchar('-'),x=-x;
      if(x>9)write(x/10);putchar(x%10^48);
  }
  int n,sum[1000005],minn[1000005],ans,father[1000005],people[1000005],mina=INT_MAX;
  struct nobe{
      int id,val;
      friend bool operator<(nobe x,nobe y){
          return x.val<y.val;
      }
  }a[1000005];
  int findset(int x){
      if(father[x]==x){
          return x;
      }
      return father[x]=findset(father[x]);
  }//并查集寻找根节点操作
  signed main(){
      n=read();
      for(int i=1;i<=n;i++){
          a[i].val=read();
          father[i]=a[i].id=i;//这个环的根节点
          minn[i]=sum[i]=a[i].val;//这个环中的最小值，这个环的权值之和
          people[i]=1;//这个环的节点数量
          mina=min(mina,a[i].val);//环外最小值
      }
      sort(a+1,a+n+1);
      for(int i=1;i<=n;i++){
          if(a[i].id!=i){//若要构成环
              int x=findset(a[i].id),y=findset(i);
              if(x!=y){
                  father[x]=y;
                  sum[y]+=sum[x];
                  people[y]+=people[x];
                  minn[y]=min(minn[y],minn[x]);//并查集合并操作
              }
          }
      }
      for(int i=1;i<=n;i++){
          if(father[i]==i){
              ans+=min((people[i]-1)*mina+sum[i]-minn[i]+2*(mina+minn[i]),(people[i]-1)*minn[i]+sum[i]-minn[i]);
          }//求每个环的最小代价
      }
      write(ans);
      return 0;
  }
```


## 总结



|分析 |   难度 |
| :-----------: | -----------: |
| **思维难度** | **紫** |
| **代码难度** | **绿** |
| **算法难度** | **橙** |
| **分析难度** | **蓝** |
| **综合评估** | **蓝** |

## 题外话

这道题作为我们模拟赛的 T2，在比赛中竟然没有人 AC ，这是多么恐怖！

这道题主要考察题目转化，代码实现与知识点考察并不难，偏向国外的思维题类型，而不像国内某些只会出数据结构。 ~~(我没有针对 Ynoi)~~

只要思维偏难，考试时就没人做对，可见我们的思维漏洞与国外的 OIer 还差距很远，我们更应该加强锻炼自己的思维，才能真正进步成一个好的 OIer!

---

## 作者：tcswuzb (赞：8)

首先应该画圈 比如下面这张图

![yong](https://i.loli.net/2018/10/05/5bb72ee959f7e.png)

很显然各个圈是相对独立的 这样就分解成了若干子问题

一个贪心的思路就是 : 利用圈中最小的元素使各个元素复位

假设圈中元素为wi,圈内的元素n 

那么最小成本就是 ∑wi + ( n - 2 )×min( wi )

但是存在这样一种情况 

那就是全局最小元素替换了当前圈内最小元素 再进行复位 然后再替换

虽然增加了两次替换的代价 但是依然是更优的

第二种情况 假设圈外的元素也就是全局最小元素x

借助元素增加的成本为2×( min( wi ) + x) 

由于进行了(n-1)次复位操作 节约的成本就是( n - 1 )×( min ( wi ) - x)

那么该部分总成本就是 ∑wi + ( n - 2 )×min( wi ) + 2×( min( wi ) + x) - ( n - 1 )×( min ( wi ) - x) = ∑wi + min( wi ) + ( n - 1) × x

所以 我们需要将两者比较取min 

具体的操作 先排序 然后找到每一个元素应该去的位置 

在画圈时 同时统计和以及最小的元素 最后套公式即可

时间复杂度 O(nlogn + n)

# CODE:

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define IL inline
#define int long long
#define N 500008
#define M 1008611
#define inf 0x7fffffff
#define R register
using namespace std;
template<typename T>IL void read(T &A)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-') f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    A=f ? x:-x;
}
int n,tot,minx=inf;

struct Node{
    int val,id,rak;
}e[N];
IL bool cmp1(Node A,Node B){return A.val < B.val;}
IL bool cmp2(Node A,Node B){return A.id < B.id;}

int num[N],res[N],rax[N];
int tre[N];
bool vis[N];
IL void add(int num,int x)
{
    while(x<=n)
    {
        tre[x]+=num;
        x+=(x&-x);
    }
}
IL int qury(int x)
{
    int ans=0;
    while(x)
    {
        ans+=tre[x];
        x-=(x&-x);
    }
    return ans;
}
signed main()
{
//	freopen("relive.in","r",stdin);
//	freopen("relive.out","w",stdout);
    read(n);
    for(R int i=1;i<=n;++i) read(num[i]),minx=min(minx,num[i]);
    for(R int i=1;i<=n;++i) res[i]=num[i];
    sort(res+1,res+n+1);
    sum=0;
    for(R int i=1;i<=n;++i) e[i].val=num[i],e[i].id=i;
    sort(e+1,e+n+1,cmp1);
    for(R int i=1;i<=n;++i) e[i].rak=i;
    sort(e+1,e+n+1,cmp2);
    for(R int i=1;i<=n;++i)
    {
        if(vis[i]) continue;
        int cur=i,minn=inf,sux=0,ank=0;
        while(1)
        {
            if(vis[cur]) break;
            vis[cur]=1;
            ank++;
            sux+=e[cur].val;
            minn=min(minn,e[cur].val);
            cur=e[cur].rak;
        }
        sum+=min(sux+minn*(ank-2),sux+minn+minx*(ank+1));
    }
    printf("%lld\n",sum);
    /*---求解第三问---*/
    return (2333==2333333);
}
```
# _NOIP 2018 RP++_

---

## 作者：machuangkun (赞：6)

# Solution 

### 思路

首先读题，发现“小C希望将整个序列升序排序”，我们可以想到排

序交换的过程只与数的**相对大小**，与数的绝对大小无关。


但合并所需代价与数的绝对大小有关，结合数据范围“输入数据中

的其他整数均为正整数且不超过$10^9$”，所以我们可以考虑到离散化。


然后我们考虑**排序**之后的序列与离散化之后的原数列的关系，

**1**  原数组  $8 4 5 3 2 7$

**2**  排序后  $2 3 4 5 7 8 $


**原数组中** $8$应该换到第六位$7$的位置，$7$应该换到第五位$2$的位

置，$2$应该换到第一位8的位置 。。。

$8--> 7--> 2--> 8 $ 我们发现~~它是一个**环**~~，再环内我们

只需互相交换就能得到有序序列

那么关于这道题，我只需找到所有的环，在环内统计答案。

关于找环，我们可以借助离散化后的数组

**3** 原数组离散化后数组为 a = {
6 3 4 2 1 5 }

**4** 离散化排序后数组为 b = {
1 2 3 4 5 6 }

$6 3 4 2 1 5$

$1 2 3 4 5 6$

a序列中  1应该放在6的位置 ，2应该放在3的位置， 3应该放到4

的位置，4应该放到2的位置，5应该放到1的位置，6应该放到5的位

置， **重点** ：此时看a，b数组的关系 ，我们map[b[i]]=a[i],就可以表示

环内的关系

把数字离散化后环变成了$6-->5-->1-->6$

那么问题就变成了环内答案怎么统计？？？

### 解决方法

在一个环内，设环的大小为$tot$，环内任意一个元素，只需交换

$(tot-1)$次即可。~~手模一下~~

**举个栗子**

4 1 3  

我们用1与其他元素交换

$1.$  1与3交换 代价 $1+3$

4 3 1

$2.$  1与4交换 代价 $1+4$

1 3 4

总代价 $1+3+1+4 =1+1+3+4=1+sum$

~~巧合？？？~~ 

设要交换的元素为x，则$x$使用了$(tot-1)$次，被交换的元素有

$(tot-1)$个，交换代价为 $(tot-1)*x+sum-x=(tot-2)*x+sum$,所以

如果我们使x最小，那么交换所需代价就最小

**但是**，有一个小问题，如果环外有一个非常小的元素，我们是

不是可已用环外非常小的数来换环内的数

**举个栗子**

999 799 899（环内元素） 


$x$ $(x<799)$（环外元素）


1.用x 换 799 代价 $x+799$


999 x $899$


2.用$x$换899 代价 $x+899$

999 899 $x$


3.用$x$换999 代价 $x+999$


$x$ 899 999


4.用$x$换回799  代价  $x+799$


总代价 $4*x+sum+799$


那么设现在环内第一次替换的元素为$y$，用环外元素替换代价为 $(tot+1)*x+sum+y$


**结论**


1 我们可以用环内最小元素x替换时序列有序，代价$(tot-2)*x+sum$


2 我们可以用环外最小值x第一次替换环内最小值y使序列有序，代价$(tot+1)*x+sum+y$


两种方案取$min$即可


**具体细节我会在代码中说明**

代码
```cpp
#include<cstdio>
#include<algorithm>
#define maxn 100005
#define re register
#define int long long
using namespace std;

inline int read(){
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		s=(s<<3)+(s<<1)+ch-'0';
		ch=getchar();
	}
	return s*f;
}

int min(int x,int y){
	return x>y?y:x;
}

int n,res,minn=1000000005,huanmin,sum,ans,tot;

struct L{
	int v,id;
	friend bool operator < (L x,L y){
		return x.v<y.v;
	}
} a[maxn];

int rank[maxn],val[maxn],vis[maxn];

signed main()
{
	n=read();
	for(re int i=1;i<=n;++i){
		a[i].v=read();
		a[i].id=i;
		val[i]=a[i].v;
		minn=min(minn,a[i].v);//记录全局最小值
	}
	sort(a+1,a+1+n);
	for(re int i=1;i<=n;++i){
		rank[a[i].id]=i;//离散化过程
	}
	for(re int i=1;i<=n;++i){
		if(vis[i]) continue;
		res=i;
		huanmin=1000000005;//记录环内最小值
		tot=0;sum=0;
		while(!vis[res]){//
			++tot;//环内点的个数
			huanmin=min(huanmin,val[res]);
			vis[res]=1;
			sum+=val[res];
			res=rank[res];	
		}
		ans+=min((tot+1)*minn+sum+huanmin,(tot-2)*huanmin+sum);//两种方案
	}
	printf("%lld\n",ans);
	return 0;
}

```




---

## 作者：QCurium (赞：5)

[原题链接](https://www.luogu.com.cn/problem/P2127)

[视频讲解（顺便点个赞吧](https://www.bilibili.com/video/BV17p4y1A7KA/)

## 题意

输入一个数列，经过若干轮交换，使数列变成升序，交换代价为交换的两个数的和。

## 题目分析

首先，我看了眼标签，有离散化，就~~无脑~~打了个离散化。离散后样例如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/1r4i4b4z.png)

看完后，我在里面找到了一个现象，这里面有若干个环一样的结构，比如：下标为 $1$ 的数指向了 $6$，下标为 $6$ 的数指向了 $5$，下标为 $5$ 的数指向了 $1$。显然，这是一个环。

而我们发现，只要让所有环中的数变成升序的，整个序列就变成了升序的。这么看来，我们只需要将环中的每个数加上环中最小的数（除了最小的数自己），就是最小方案数。

但是这样写只会有十分。

![](https://cdn.luogu.com.cn/upload/image_hosting/az3lcm9m.png)

这是怎么回事呢？

我们来看一下这组样例，`1,100000,10,100,1000,10000`。在这个样例中，环是后五个数组成的，但是交换这里面的五个数并不是最优方案，我们可以将 $1$ 和 $10$ 交换，让 $1$ 在环里，等交换完后再交换 $1$ 和 $10$，这样才是最优方案。

所以我们可以两种方案都算，再取最小值就可以了。

## Code

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define pdd pair<double,double>
#define int long long
#define base 200807
#define mod 212370440130137903
using namespace std;
const int N=1e5+5;
int n,tot=0,ans=0,mn=1e9+5,mnz=1e9+5,cnt=1;
int a[N],t[N],node[N];
bool bj[N]={0};
int panduan(){
	tot=0;
	for(int i=cnt;i<=n;i++){
		if(a[i]==i)
			continue;
		tot++;
		node[tot]=a[i];
		bj[i]=1;
		break;
	}
	if(tot==0)
		return 0;
	while(1){
		tot++;
		node[tot]=a[node[tot-1]];
		bj[node[tot-1]]=1;
		if(node[tot]==node[1]){
			tot--;
			break;
		}
	}
	return tot;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		t[i]=a[i];
		mnz=min(mnz,a[i]);
	}
	sort(t+1,t+n+1);
	int m=unique(t+1,t+n+1)-t-1;
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(t+1,t+m+1,a[i])-t;
	while(panduan()){
		for(int i=1;i<=n;i++){
			if(!bj[i])//记录第一个没修改的数的坐标
				break;
			else
				cnt++;
		}
		int ans1=0,ans2=0;
		for(int i=1;i<=tot;i++)
			mn=min(mn,t[node[i]]);
		ans1+=(mnz+mn)*2;
		for(int i=1;i<=tot;i++){
			if(t[node[i]]!=mn){
				ans2+=mn+t[node[i]];
				ans1+=mnz+t[node[i]];
			}
			a[node[i]]=node[i];
		}
		tot=0;
		ans+=min(ans1,ans2);
		mn=1e9+5;
	}
	cout<<ans;
	return 0;
}

```

[AC记录](https://www.luogu.com.cn/record/124572214)

鸣谢 @一只绝帆 发现时间复杂度错误。

错误均已修正。

---

## 作者：Right (赞：4)

其实这就是一道有技巧的贪心+模拟题

对于这道题，通过观察，不难发现：

著作权归作者所有。

序列中的数可以分成几组，依次交换后可以构成一个环。那么我们在进行交换的时候

既可以用环中最小的那个数进行逆序交换；

Eg：8,2,7 =》8,7,2 =》2,7,8

也可以用所有数中最小的数先和环中的一个数交换，再用最小数做逆序交换

代码如下：




    
    
```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int n;
long long cost=0; >>为最后花费的最小代价
struct stu{
    int num; >>记录排序前的位置
    long long v; >>以及它的大小
}a[100008];
bool vis[100008]; >>判断这个数是否已经在前面的环中更换过了 - - wheather be visited
bool cmp(stu x,stu y)
{    return x.v<y.v;    } >>快排所打
inline long long read() >>读入而已，可忽略
{
    long long x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9')
    {
        x=(x<<3)+(x<<1)+ch-48;
        ch=getchar();
    }
    return x;
} 
int main() >>正文
{
    int i,j;  scanf("%d",&n);
    for (i=1; i<=n; ++i)
    {
        a[i].v=read(); >>读入大小
        a[i].num=i; >>记录下标
    }
    sort(a+1,a+n+1,cmp); >>排序后下标即为该数所要到的位置
    for (i=1; i<=n; ++i)
    {
        if (!vis[i]) >>这个数如果没有在前面的环中更换过
        {
            int x=i;
            long long tot=0,sum=0,mins=0x3f7f7f7f7f7f7f;
            while (!vis[x])  >>不断逆序更换，但记录环中最小数，答案基础为环中所有数的和
            {
                vis[x]=1;
                sum+=a[x].v;
                if (mins>a[x].v)
                  mins=a[x].v;
                tot++; >>记录环中有几个数
                x=a[x].num;  >>下一个下标
            }
            long long a1=sum+(tot-2)*mins; >>总答案为答案基础+最小数与其他数互换累计的和
            long long a2=sum+a[1].v*(tot+1)+mins; >>或者用所有数中最小的辅助交换
            if (a1<a2) cost+=a1;   else cost+=a2;  >>当然cost也要选二者中小的
        }
    }
    printf("%lld",cost); 输出而已
}
```

---

## 作者：5k_sync_closer (赞：3)

~~你们代码都好长啊.jpg~~
# 题意
给定无相等元素的 $\{a_n\}$，交换 $a_x,a_y$ 的代价为 $a_x+a_y$，求将 $\{a_n\}$ 升序排序的最小代价。
# 思路
注意到 $\{a_n\}$ 中不存在相等元素，即可以确定 $a_i$ 排序后的位置。

我们记 $p_i$ 为 $a_i$ 排序后的位置，可以用离散化求出 $\{p_n\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jtk1mgg9.png)

容易发现，如果 $i$ 向 $p_i$ 连有向边，可以形成若干个环。（图为样例）

一个比较显然的贪心：选出每个环中的最小值，与其他点依次交换。

若某个环的点数为 $r$，点权和为 $s$，最小值为 $m$，则此环总代价为 $s+m(r-2)$。

注意到可以先将环中最小值与全局最小值交换，再与其他点依次交换，最后把全局最小值与环中最小值换回来。

若全局最小值为 $M$，则此环总代价为 $s+m+M(r+1)$。

取两种方案的最小值，答案为 $\sum\min\{s+m(r-2),s+m+M(r+1)\}$。
# 代码
```cpp
#include <cstdio>
#include <algorithm>
#define F for(int i = 0;i < n;++i)
using namespace std;
int n, m, M = 1e9, a[100050], f[100050], p[100050];long long r, s, q;bool v[100050];
void D(int x) {if(v[x]) return;v[x] = 1;++r;s += a[x];m = min(m, a[x]);D(p[x]);}
int main()
{
    scanf("%d", &n);F scanf("%d", a + i), M = min(M, f[i] = a[i]);
    sort(f, f + n);F p[i] = lower_bound(f, f + n, a[i]) - f;F if(!v[i])
    r = s = 0, m = 1e9, D(i), q += s + min(m * (r - 2), m + M * (r + 1));
    return printf("%lld", q), 0;
}
```


---

## 作者：yf最qhhh (赞：2)

~~学校模拟赛的题。。。。。。发现洛谷上也有，就来水题解了。~~

这道题肯定不能暴力啊，9次方。

这道题的方法很多，我一开始想到的是树状数组，但 WA+TLE 了，代码如下：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll C[500005],n,A,m,a,b;
string s;
ll lowbit(ll x){
	return x&(-x);
}
void qwe(ll i,ll A){
	for(int j=i;j<=n;j+=lowbit(j)){
		C[j]+=A;
	}
}
ll getsum(ll x){
	ll sum=0;
	for(int i=x;i>0;i-=lowbit(i)){
		sum+=C[i];
	}
	return sum;
}
int main(){
	ll ans=0;
	while(true){
		ans=0;
		scanf("%lld",&n);
		if(n==0)return 0;
		memset(C,0,sizeof(C));
		for(int i=1;i<=n;i++){
			scanf("%lld",&A);
			qwe(i,1);
			ans=ans+getsum(n)-getsum(A);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
后来尝试了一下离散化，发现树状数组不行（也有可能可以，但我做不出来）。

后来想到了归并排序，但只适用于[这道题](https://www.luogu.com.cn/problem/P1327)
，最后才想到了 DFS 。（但是由于我没保存代码，所以就说说大概思路吧）

离散化是必须的，毕竟数据太大了，lower_bound 一下嘛（不会用当我没说）。然后就是如果形成一个类似环的形状，那么我们就要利用环中最小的那个数，这个环中最小的数和序列中最小的数先交换，然后再在环内交换。

DFS 来进行模拟，并判断哪一种最小就记录然后累加到最终的结果就行了。


---

## 作者：zhaiyufeng (赞：1)

## 题意
给定序列，交换任意两个位置使得序列为升序，每次代价为两数之和，求最小代价。
## 分析
显然，不难发现将序列内元素离散化后以 $i$ 为起点，$a_{i}$ 为终点建边可构成若干个环，我们只需要分别对这些环进行处理。
### 两种方式
1. 环内元素互相交换，记 $sum$ 为环内元素大小总和，$minn$ 为环内元素最小值，$cnt$ 为环内元素数量，易得此环对答案贡献为 $sum+minn\times(cnt-2)$。
1. 如果当前环内元素过大，可以用环外最小的元素辅助交换，记 $k$ 为最小元素（其它变量意义同上），则这种操作贡献为 $sum+k\times(cnt+1)+minn$。

最后每个环答案统计为两种方式的最优。

至于找环我们就使用简单的 dfs 即可。

## 代码

码风较丑勿喷。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,minn,sum,cnt,m1,m2,k=INT_MAX;
bool vis[100010];
struct node{
	int p,num;
};
node a[100010],b[100010];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
bool cmp(node x,node y){
	return x.num<y.num;
}
void dfs(int x){
	vis[x]=1;
	minn=min(minn,b[x].num);
	sum+=b[x].num;
	cnt++;
	if(!vis[b[x].p]) dfs(b[x].p);
}
signed main(){
	n=read();
	for(int i=1; i<=n; i++){
		a[i].num=read();
		k=min(k,a[i].num);
		a[i].p=i;
		vis[i]=0;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1; i<=n; i++){
		b[a[i].p].p=i;
		b[a[i].p].num=a[i].num;
	}//离散化
	for(int i=1; i<=n; i++){
		if(!vis[i]){
			sum=0,cnt=0,minn=INT_MAX;
			dfs(i);//找环
			m1=sum+minn*(cnt-2);
			m2=sum+k*(cnt+1)+minn;
			ans+=min(m1,m2);//统计答案
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：xxseven (赞：1)

第一次独立速切这种思维题，写篇题解纪念一下。

题目给的交换操作限制很松，考虑图论建模。

我们把数列中每个位置看作点，每个点向它排序后的目标位置连边。

显然，这样连边之后，所有点的入度和出度都恰好为 $1$，也即图为一大堆环。

考虑一个环内怎么交换。显然让环内最小值围着环转一圈交换相邻数就好了，设环内有 $n$ 个点，最小值为 $x$，总和为 $s$，那么代价为 $(s-x)+(n-1)\times x$。

注意到我们其实还可以先把全局最小跟环内最小交换之后再跳。记全局最小值为 $y$，那么代价就是 $(s-x)+(n-1)\times x +2\times (x+y)$，两种情况取 $\min$ 即可。

瓶颈在于求出边，也就是离散化，时间复杂度 $O(n\log n)$。


```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e5+6;
int n,mn=1e18,a[N],b[N],c[N];
int ans,vis[N],cnt,sum,now;
void dfs(int x){
	if(vis[x]) return;
	vis[x]=1; 
	cnt++; now=min(now,a[x]); sum+=a[x];
	dfs(b[x]);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i],c[i]=a[i];
	sort(c+1,c+n+1); mn=c[1];
	for(int i=1;i<=n;++i) b[i]=lower_bound(c+1,c+n+1,a[i])-c;
	for(int i=1;i<=n;++i){
		if(!vis[i]) {
			cnt=sum=0,now=1e18,dfs(i);
			cnt--;
			ans+=(sum-now)+min(cnt*now,cnt*mn+2*(mn+now));
		}
	}
	cout<<ans;
	return 0;
}

```

希望这篇题解能够帮到你！

---

## 作者：ncwzdlsd (赞：1)

贪心。

由于序列中不存在相等元素，可以求出每个数在排序完成后的序列位置 $p$。

非常巧妙的是，把 $i$ 与 $b_i$ 连边，可以发现序列上形成了多个环。可以想到，让每个环中最小的元素与环中其他元素交换所需花费最少。

还有一种情况，我们可以先把每个环的最小值与全局最小值交换一下，让这个全局最小值和每个环中值交换，最后再把全局最小值换出来。

我们假设某个环的权值和为 $s$，点数为 $cnt$，环内最小值为 $v$，全局最小值为 $V$，则答案为 $\min(\sum s+v(cnt-2),\sum s+v+V(cnt+1))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e5+5;
bool vis[maxn];
struct node{int v,id;}a[maxn];

bool cmp(node a,node b){return a.v<b.v;}

signed main()
{
	int N;cin>>N;
	int V=INT_MAX;
	for(int i=1;i<=N;i++) cin>>a[i].v,a[i].id=i,V=min(V,a[i].v);
	sort(a+1,a+N+1,cmp);
	int ans=0;
	for(int i=1;i<=N;i++)
	{
		if(!vis[i])
		{
			int cnt=0,s=0,v=INT_MAX,x=i;
			while(!vis[x])
				s+=a[x].v,vis[x]=1,cnt++,v=min(v,a[x].v),x=a[x].id;
			ans+=min(s+v*(cnt-2),s+v+V*(cnt+1));
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：WeLikeStudying (赞：0)

**[水题 1](https://www.luogu.com.cn/problem/AT2831)**
- 一个常见结论，（对于一个排列）交换两个数，它的逆序对改变，所以[代码](https://www.luogu.com.cn/paste/su0zwic1)。
- 所以显然如果可行可行方案只有一种，用最小交换次数交换得到升序排列。
- 最小交换次数是什么呢，我们可以用置换来考虑，你会发现对于每个数字，把它与它目标位置的数交换，都会将一个大环分成两个小环，而我们的目标是生成 $n$ 个环，所以，最小交换次数恰好是 $n$ 减去环的个数，利用势能分析，我们证明了这一点，而且给出方案的自由度较高，[代码](https://www.luogu.com.cn/paste/oowaf1pq)。
- 接下来咱们解决一个加强版的问题：给定一个可重数列，用最小步数换到另一个可重数列。
- 首先任意给两个数列标号为一种合法的排列，我们得到了一种较优的可行解，但并不是最优解。
- 现在我们的目标是：任意交换两个相同的数，让置换环个数最多。
- 然后现在的问题就在于：它可做吗？

**[水题 2](https://www.luogu.com.cn/problem/CF1672F1)**
- 接下来咱们要解决的这个问题也是很有趣的，最大化最小交换次数。
- 考虑置换环的下界，设 $k$ 为出现最多数的次数，那么置换环绝对不可能低于它，否则容易让置换环直接变多。
- 那么考虑构造出一种情况，让置换环不可能变得更少，只需要让少的都配上多的就好了，[代码](https://www.luogu.com.cn/paste/nnp5zvxo)。
- [类题](https://www.luogu.com.cn/problem/CF1672F2)，问题转化为判断是否存在恰好 $k$（最大数字个数）个不相交，内部数字不同的置换环。
- 然后这个怎么判断呢，可以搜索暴力拆环（因为如果是正解，置换环的个数不会随着对应关系变而改变），自己实践以下发现容易走到 $\rho$ 形路径导致复杂度被卡到 $O(n^2)$。
- 然后发现图具有的特殊性质：这个图具有欧拉回路，然后回忆[算法](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/ou-la-hui-lu)，发现欧拉回路恰好有这样的情况。
- 然后利用反证法可以说明如果合法所有的环都包含数字最大的点，两者结合可以得到判定：首先得到达所有点，然后除了最多次数的点不存在环即可，[代码](https://www.luogu.com.cn/paste/yimhtjav)。

**[水题 3](https://www.luogu.com.cn/problem/P2127)**
- 这题是怎么回事呢？
- 每个东西交换的权重不一样了，而且你调节权重还有相当高的自由度。
- 一种情况是在环内对吧，那么就从环内最小的过来，顺次把它消掉，这种方法可以过样例但是会被：$1,200,300,400,500,10$ 卡：程序会输出 $930$ 但实际是 $925$，对应的交换是 $(1,10),(1,500),(1,400),(1,300),(1,200),(1,10)$。
- 因此你就发现可以把全局最小值换过来做苦活累活，因此这题的算法也就确定了，[代码](https://www.luogu.com.cn/paste/d72cyr5i)。

---

## 作者：xiaoyang111 (赞：0)

## 前言

[题面。](https://www.luogu.com.cn/problem/P2127)

[专栏观看可能更好。](https://www.luogu.com.cn/article/kmnkdrez)

## 题解

### 思路

既然从序列这个地方下不去手，就直接从图论上面下手，因为这些数是希望回到自己的位置上面的，就直接拿现在这个点和要到的目标点连一条有向边，就很像图。

拿样例 `8 4 5 3 2 7` 解释，画成图就是这样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/9bph3rkx.png)

可以看到形成了很多的环，我们先考虑处理一个环。

拿大一点的那个环举例，最优的方法肯定是让数大的点交换的次数尽量少一点，让最少的点去一个个复原他们，就有了下面思路。

从最小点开始，随着另一个点到这个点的方向反着爬回去，让这个点复原，最小的点到了新的位置，按照上面的方法继续复原其他的点，直到回到自己的点。模拟最大的环就是这样的。

先把 `2` 和 `7` 交换，把 `7` 还原。

然后再把 `2` 和 `8` 交换，把 `8` 还原。代价最优。

整理一下，对于每个环，点的个数是 $a$，最小的点的数是 $b$，总和是 $sm$，那么这个环要还原的最小代价为 $sm + b \times (a - 2)$。

然后你按照这个思路写代码，发现样例都过不了对吧，说明还没想完，还有一种情况。

对于两个环，可以把这两个环合并起来，就是把两个环的任一点给交换，在重新把图改一下，两个环就绞在一起了。就像下面这个图。由于横着的图边都重起来了，所以我给改了一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/amw6grkl.png)

因为进行了交换操作，所以代价要加上这两个数的和，且要保证这两个点都分别是两个环内数最小的点，使增加的代价尽可能的小。

然后我们惊奇的发现，这个环还是可以像上面那样用最小代价算出来，而且代价变小了。

为什么代价会变小，是因为最小点较大的环的最小值变小了，交换的代价也就变小了。

当然也有时候不交换是更优的，就比如只有一个点和另一个环，交换并不是最有的选择。

其实每一次只需要和编号最小的那一个环合并，因为和其他的环合并有点不好写代码。

### 实现

连边的时候结构体排序就可以了。

其实图是没啥用的，因为我们算的是环，相当于连通块，可以直接用并查集维护，还方便些。

并查集我们维护三个东西，分别是连通块内点的个数，连通块内所有数的和，连通块内最小的数，用来算是否要合并。

最后统计答案的时候直接遍历每个环把代价加上就可以了。

代码。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#define int long long
using namespace std;
const int N=1e5+5;
struct iakioi{
	int a,id;
}a[N];
int num[N],f[N],s[N],sm[N];
int n;
int find(int x){
	return f[x]==x ? x : f[x]=find(f[x]);
}
signed main(){
	cin >> n;
	int mn=0x3f3f3f3f,idx=-1;
	for (int i=0;i<n;++i){
		scanf("%lld",&a[i].a);
		num[i]=a[i].a;
		a[i].id=i;
		if (num[i]<mn){
			idx=i;
			mn=num[i];
		}
	}
	sort(a,a+n,[](const iakioi &a,const iakioi &b){
		return a.a<b.a;
	});
	for (int i=0;i<n;++i){
		f[i]=i;
	}
	for (int i=0;i<n;++i){//找出环 
		if (num[find(i)]<num[find(a[i].id)]){//往小的合并 
			f[find(a[i].id)]=find(i);
		}else{
			f[find(i)]=find(a[i].id);
		}
	}
	for (int i=0;i<n;++i){
		++s[find(i)];//对应连通块的数的个数 
		sm[find(i)]+=num[i];//连通块数的个数 
	}
	int t1,t2,t3;
	int ans=0;
	for (int i=0;i<n;++i){
		if (f[i]==i && i!=idx){
			t1=sm[i]+num[i]*(s[i]-2);//分开 
			t2=sm[idx]+num[idx]*(s[idx]-2);//分开 
			t3=sm[i]+sm[idx]+num[idx]*(s[i]+s[idx]-2);//合并 
			if (t1+t2>t3+num[i]+num[idx]){
				sm[idx]+=sm[i];
				s[idx]+=s[i];
				f[i]=idx;
				ans+=num[i]+num[idx];//合并 
			}
		}
	}
	for (int i=0;i<n;++i){
		if (f[i]==i){
			ans+=sm[i]+num[i]*(s[i]-2);
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：Unnamed114514 (赞：0)

对于本题，数据为 $a_i\le 10^9$，显然需要离散化。对于离散化后的数组，我们可以设 $a_i$ 表示原数组的值，$b_i$ 表示离散化后的值，$c_i$ 表示目标排序的位置。由此我们可以把 $b_i$ 和 $c_i$ 之间用链表连接，表示他们之间应该产生交换关系。然后，我们就可以对于每个环分别求解。设 $mii\gets\min{a_i}$，$mi$ 表示当前环的最小值，$sum$ 表示环内所有数的和，$num$ 表示环内数的个数。则一共有 $2$ 种：对于第一种，我们可以在这个环内交换，即用 $mi$ 与其它的数交换一次，答案为 $sum+(num-2)\times mi$；或者把环外的最小值与环内的换一下，执行完所有操作后，我们再还回去，答案即为 $(sum-mi+mii)+(num-2)\times mii+2\times(mi+mii)$。

对于每个环，用链表维护即可，遍历复杂度为 $O(n)$。总的来看，瓶颈在离散化，时间复杂度为 $O(n\log n)$。
### AC Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e6+5;
struct node{
	int a,b,c;
}f[maxn];
int n,mii=1e18,ans;
bool vis[maxn];
inline bool cmp1(node a,node b){
	return a.a<b.a;
}
inline bool cmp2(node a,node b){
	return a.b<b.b;
}
inline int read(){
    int res=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9'){
        res=(res<<1)+(res<<3)+(ch^'0');
        ch=getchar();
    }
    return res;
}
signed main(){
    n=read();
	for(int i=1;i<=n;++i)
		f[i]=node({read(),i}),mii=min(mii,f[i].a);
	stable_sort(f+1,f+n+1,cmp1);
	for(int i=1;i<=n;++i)
		f[i].c=i;
	stable_sort(f+1,f+n+1,cmp2);//离散化
	for(int i=1;i<=n;++i)
		if(!vis[i]){
			int sum=f[i].a,mi=f[i].a,x=f[i].c,num=1;
			while(x!=i){
				vis[x]=1;
				sum+=f[x].a;
				mi=min(mi,f[x].a);
				x=f[x].c;
				++num;
			}//做一个链
			ans+=min(sum+(num-2)*mi,(sum-mi+mii)+(num-2)*mii+2*(mi+mii));//公式
		}
	printf("%lld\n",ans);
	return 0;
}
```

---


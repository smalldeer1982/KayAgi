# [HAOI2008] 糖果传递

## 题目描述

有 $n$ 个小朋友坐成一圈，每人有 $a_i$ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $1$。


## 说明/提示

对于 $100\%$ 的数据 $1 \leq n\le 10^6$，$1 \leq a _ i \leq 1.5 \times 10 ^ 9$。


## 样例 #1

### 输入

```
4
1
2
5
4```

### 输出

```
4```

# 题解

## 作者：wyhwyh (赞：165)

UPD on 2020.4.1:
感谢 `OItby` 神仙指出错误，已更正。欢迎别的神仙来指教 & 吊打本萌新![](https://cdn.luogu.com.cn/upload/pic/55149.png)

首先我们要用到一些[均分纸牌](https://www.luogu.org/problemnew/show/P1031)的思想(已经理解这种思想的大佬请跳过):

设$A_i$表示第$i$个小朋友原有的糖果数量,

设$ave$表示所有小朋友糖果数量的平均数,

$X_i$表示第$i$个小朋友向左传的糖果数量。即：

>①如果$X_i>0:\quad$ 第$i$个小朋友向左传$X_i$个糖果；

>②否则如果$X_i<0:\quad$ 第$i$个小朋友向左传$|X_i|$个糖果。

所以该题的代码为：

**Code：**

```cpp

#include<cstdio>
int a[101];
int n,x,s;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&a[i]);
        x+=a[i];
    }
    x/=n;
    for(int i=1;i<n;++i)
    {
        a[i]-=x;
        if(a[i]!=0)
        {
            ++s;
            a[i+1]+=a[i];
        }
    }
    printf("%d",s);
    return 0;
}

```

好现在让我们回到原题[糖果传递](https://www.luogu.org/problemnew/show/P2512)上来。

看看刚刚设的什么：

设$A_i$表示第$i$个小朋友原有的糖果数量,

$ave$表示所有小朋友糖果数量的平均数,

$X_i$表示第$i$个小朋友向左传的糖果数量。

则由题可得方程：
$$
A_1+X_2-X_1=ave
$$
$$
A_2+X_3-X_2=ave
$$
$$
···
$$
$$
A_n+X_1-X_n=ave
$$
即：

>$$A_i+X_{i+1}-X_i=ave(1\le i<n)$$

>$$A_n+X_1-X_n=ave(i=n)$$

变形得：
$$
X_2=ave+X_1-A_1
$$
$$
X_3=ave+X_2-A_2=ave+(ave+X_1-A_1)-A_2=2ave-A_1-A_2+X_1
$$
$$
···
$$
$$
X_1=ave+X_n-A_n=n·ave-A_1-A_2-…-A_n+X_1
$$

这时我们设:
$$
C_1=A_1-ave
$$
$$
C_2=A_1+A_2-ave
$$
$$
···
$$
$$
C_n=A_1+A_2+…+A_n-n·ave
$$

即设：
>$$C_i=\sum_{j=1}^iA_j-i·ave(1\le i\le n)$$

则有:
$$
X_2=X_1-C_1
$$
$$
X_3=X_1-C_2
$$
$$
···
$$
$$
X_n=X_1-C_n
$$

即：
>$$X_i=X_1-C_i$$

这时我们返回来看所求,要求传递价值最小，

这就是说，要求最小化 
$$
|X_1|+|X_2|+···+|X_n|
$$
而该式等于
$$
|X_1-C_1|+|X_1-C_2|+···+|X_1-C_n|
$$

即求:
>$$MIN \{ \sum_{i=1}^nX_i \}=MIN \{ \sum_{i=1}^nX_1-C_i \}$$

这样就好办了，$C_i$是已知（额，至少是可以预处理出来）的，要想最小化上式，我们把$C_i$看成数轴上的一个个点，现在问题就转化成了找出一个点$X_1$，使得她到各个$C_i$上的点的距离和最小。

>而这个点就是这$n$个点的中位数，后面有证明qwq

那么求出了$X_1$之后，根据
$$
X_2=X_1-C_1
$$
$$
X_3=X_1-C_2
$$
$$
···
$$
$$
X_n=X_1-C_n
$$

这一坨柿子，我们可以求出$X_2,X_3…X_n$,然后就可以偷税的得到所求的：

最小化 
$$
|X_1|+|X_2|+···+|X_n|
$$

啦233~~~

代码好丑，大家别嫌弃qwq：

**Code：**
```cpp

#include<bits/stdc++.h>
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
#define inline il

typedef long long ll;
typedef long double ld;

const int inf = 0x7fffffff;
const int N = 1e6+1;

ll n;
ll a[N],c[N];
ll ave,ans,mid;

using namespace std;

int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]),ave+=a[i];
	ave/=n;
	for(int i=1;i<=n;++i)
		c[i]=c[i-1]+ave-a[i-1];
	sort(c+1,c+n+1);
	mid=c[(n+1)/2];
	for(int i=1;i<=n;++i)
		ans+=abs(mid-c[i]);
	printf("%lld",ans);
	return 0;
}

```

### 附：数学证明

在数轴上有$n$个点，找出一个点$x$，使得她到各个点的距离和最小。

求证：该点表示的数就是这$n$个数的中位数。

如果我们把数轴上的点两两配对，最大的配最小的，次大的配次小的……

则到每组点最近的距离的点在这两个点中间，那么

![](https://i.loli.net/2019/05/19/5ce158a06dc0e30795.jpg)

如果有奇数个点，那么显然中间那个点便为所求。

**∴**该点表示的数是这$n$个数的中位数得证。

### 注：

有一些柿子在文中以不同的形式重复出现，主要是为了同时满足大佬和蒟蒻的需要。一些前面写了‘即…’并用
>这个东西

框起来的一般是适合大佬的较严（bian）格（tai）数学写法，而其他的则是简明易懂的正常的、不变态的写法。


---

## 作者：岸芷汀兰 (赞：63)

###作者：岸芷汀兰
#一、题目
[洛谷原题](https://www.luogu.org/problemnew/show/P2512)
#二、思路
**环形均分纸牌。**

没做过的可以做做[这道题](https://www.luogu.org/problemnew/show/P1031)

一般的均分纸牌问题就相当于在第N个人与第1个人之间把环断开，此时这N个人站成一行，其持有的纸牌数、前缀和分别是： 

>A[1]   S[1]

>A[2]   S[2]

>…

>A[N]   S[N]

如果在第K个人之后把环断开站成一行，这N个人持有的纸牌数、前缀和分别是：

>A[k+1]   S[k+1]-S[k]

>A[k+1]   S[k+2]-S[k]

>…

>A[N]   S[N]-S[k]

>A[1]   S[1]+S[N]-S[k]

>…

>A[k]   S[k]+S[N]-S[k]

所以，所需最小花费为：$$\sum_{i=1}^{N}|S[i]-S[k]|$$

当K取何值时上式最小？这就是“货仓选址”问题。所以我们将S数组从小到大排序，取中位数作为S[k]就是最优解。

###三、代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>

using namespace std;
inline long long read(void)
{
    long long x=0;int f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return f*x;
}

const int maxn=1000005;

long long n,a[maxn],sum[maxn],ave,ans;

int main()
{
    n=read();
    for(register int i=1;i<=n;i++){
        a[i]=read();ave+=a[i];
    }
    ave/=n;
    for(register int i=1;i<=n;i++)a[i]-=ave;
    for(register int i=1;i<=n;i++)sum[i]=sum[i-1]+a[i];
    sort(sum+1,sum+n+1);
    long long t=sum[(n+1)>>1];
    for(register int i=1;i<=n;i++)ans+=abs(t-sum[i]);
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：LiRewriter (赞：30)

~~我觉得楼下大佬抄hzwer不太好吧~~

~~虽说我大概是抄进阶指南~~

首先这道题是一个模型，我们称之为环形均分纸牌。显然这个模型是出自luogu1031那道均分纸牌，没有过的可以先过一下。

先来看不是环形的情况。

假设总和为$T$，有$M$张纸牌。设$ave = \dfrac{T}{M}$。对于第i个人来说，如果$C[i] < ave$他拿的应该是$C[i] + ave$张，后一个拿$C[i + 1] - ave + C[i]$，否则，他拿$C[i] - ave$张，而后一个拿$C[i + 1] + C[i] - ave$张。

但是这样并不方便维护，我们考虑整体和隔离的思想。将前i个看做一个整体，显然前i个内部的均分是不会改变其整体结构的，因而对于该体系来说，想要达到平均数结构，就必须与下一个体系交换足够的纸牌，而交换数量就是$|G[i] - i \cdot ive|$，其中$G[i]$是前缀和。然后就可以推出一个结论：$d = \sum ^M _{i = 1} |i \cdot ave - G[i]|$，也就是将每次体系更新的贡献加起来。

如果让每个人的数量都减去$ave$，结果就可以经过简单的数学推导进一步化简：$d = \sum ^M _{i = 1} |S[i]|$，其中$S[i]$是新数组的前缀和。这就是均分纸牌问题的通用公式。

现在考虑一种变形：如果这里的纸牌是环形的呢？

对于环形问题，首先考虑切开。假定我们切开的东西是$A[k + 1], A[k + 2], ..., A[M], A[1], ..., A[k]$，那么其前缀和也会有所变化，即$S[k + 1] - S[k], S[k + 2] - S[k], ..., S[M] - S[k], .S[1] + S[M] - S[k], ..., S[M]$

由于均分之后，$S[M] = 0$恒成立，所以前缀和的变化仅仅是减去$S[k]$。那么，我们要求的就是哪个取值上最短，换言之，求什么时候$\sum^M_{i = 1} |S[i] - S[k]|$取到最小。

因而，这里我们要求的东西是$\sum^M_{i = 1} |S[i] - S[k]|$的最小值。答案是在中位数处取到，原因各位可以想象将$S[i]$投影到一个坐标平面内。然后我们用一条线去扫，点到线的距离之和就是上面的式子的最小值。从中位数的位置变化到靠下的位置或是靠上的位置，都会使某一部分点的距离增大。所以这里转化为求中位数，也就是求第$\dfrac{n + 1}{2}$大元素，由于$N \leq 10^6$所以不建议排序（虽然也能用）。我们可以用STL的kth_elements()函数O(n)求出k大。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long long LL;

LL sum[1000003], S; 

inline void read(LL &x) {
	x = 0; char c = getchar();
	while(!isdigit(c)) c = getchar();
	while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
}
int main() {
	LL n, ans = 0;
	read(n);
	for(int i = 1; i <= n; ++i) read(sum[i]), S += sum[i];
	LL ave = S / n;
	for(int i = 1; i <= n; ++i) sum[i] -= ave;
	for(int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + sum[i];
	int m = (n + 1) / 2;
	nth_element(sum + 1, sum + m, sum + n + 1);
	for(int i = 1; i <= n; ++i) ans += abs(sum[i] - sum[m]);
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：D愚者 (赞：25)

### - 前言：
1. 看到这题，首先想到费用流，然后....~~妥妥的MLE~~
![](https://cdn.luogu.com.cn/upload/pic/58671.png)
------------

30分Code：
------------

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
long long n,sum,cnt=-1,mincost;
long long x[1000100],st[1000100],dis[1000100],vis[1000100],pre[1000100],last[1000100],flow[1000100];
struct edge{
    long long to,next,val,flow;
}e[10001000];
void add(long long u,long long v,long long flow,long long val){
    e[++cnt].to=v;
    e[cnt].flow=flow;
    e[cnt].val=val;
    e[cnt].next=st[u];
    st[u]=cnt;
}
void Add(long long u,long long v,long long flow,long long val){
    add(u,v,flow,val);
    add(v,u,0,-val);
}
bool spfa(long long s,long long t){
    queue<int> q;
    for(long long i=1;i<=n+1;i++)
        dis[i]=2147483647;
    q.push(s);
    vis[s]=true;
    pre[s]=0;
    pre[t]=-1;
    dis[s]=0;
    flow[s]=2147483647;
    while(!q.empty()){
        long long u=q.front();
        q.pop();
        vis[u]=false;
        for(long long i=st[u];i!=-1;i=e[i].next){
            long long v=e[i].to;
            if(e[i].flow>0&&e[i].val+dis[u]<dis[v]){
                dis[v]=dis[u]+e[i].val;
                pre[v]=u;
                last[v]=i;
                flow[v]=min(flow[u],e[i].flow);
                if(!vis[v]){
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    return pre[t]!=-1;
}
void dinic(long long s,long long t){
    while(spfa(s,t)){
        long long now=t;
        mincost+=flow[t]*dis[t];
        while(now!=s){
            e[last[now]].flow-=flow[t];
            e[last[now]^1].flow+=flow[t];
            now=pre[now];
        }
    }
}
int main(){
    memset(st,-1,sizeof(st));
    scanf("%lld",&n);
    long long s=0,t=n+1;
    for(long long i=1;i<=n;i++){
        scanf("%lld",&x[i]);
        sum+=x[i];
    }
    sum/=n;
    for(long long i=1;i<=n;i++)
        x[i]-=sum;
    for(long long i=1;i<=n;i++){
        if(x[i]>0)
            Add(s,i,x[i],0);
        if(x[i]<0)
            Add(i,t,-x[i],0);
    }
    for(long long i=1;i<=n;i++){
        if(i!=1)
            Add(i,i-1,2147483647,1);
        if(i!=n)
            Add(i,i+1,2147483647,1);
    }
    Add(1,n,2147483647,1);
    Add(n,1,2147483647,1);
    dinic(s,t);
    printf("%lld",mincost);
    return 0;
}
```
------------
### - 正解：
------------
- 首先，最终每个小朋友的糖果数量可以计算出来，等于糖果总数除以n，假设C1=A1减去最终每个小朋友的糖果数量，设Xi表示第i个小朋友给了第i-1个小朋友Xi颗糖果，
- 我们希望Xi的绝对值之和尽量小，即|X1| + |X1-C1| + |X1-C2| + ……+ |X1-Cn-1|要尽量小。注意到|X1-Ci|的几何意义是数轴上的点X1到Ci的距离，所以问题变成了：给定数轴上的n个点，找出一个到他们的距离之和尽量小的点，而这个点就是这些数中的中位数，~~证明应该都懂~~。
------------
Code：
------------
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long a[1000100],x[1000100];//注意数据范围
long long mid,ans,n,sum;
int absolute(int x){//手打abs
	if(x<0)
		return -x;
	return x;
}
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sum+=a[i];
	}
	sum/=n;//求最终每个小朋友的糖果数量可以计算出来
	for(long long i=1;i<=n;i++)
		x[i]=x[i-1]-a[i]+sum;
	sort(x+1,x+1+n);
	mid=x[(n+1)/2];//中位数
	for(long long i=1;i<=n;i++)
		ans+=absolute(x[i]-mid);//求最小代价
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：linghaoran (赞：16)

小朋友可以向任意一边传递糖果，不好模拟，于是我们规定，他们仅能向右边传递。

定义 **n** 为小朋友人数，**p** 为平分所用的代价，**c[i]** 为每个小朋友现有的糖果数目，**t** 为目标数目，**s[i]** 为每个小朋友需要传递的数目，故得：


    	s[i] = c[i]+s[i-1]-t
    	 特殊地，s[0] = c[0]+s[n-1]-t
  	 	传递到i-1时传递必然结束，此时可以看作在i与i-1之间切开，形成一条线。
 		 p为所有|s[i]|之和。

如果从k左端断开，此时p为**从k开始传递糖果的代价**，特别地，s[k] = c[k]-t。因为这是环，所以每一个人都可能为k，所以我们要求的，就是k个p中最小的一个p。

令k=i，此时s[i]=c[i]-t，s[i+1]=c[i+1]+s[i]-t，s[i+2]=c[i+2]+s[i+1]-t;
令k=i+1，此时s[i+1]=c[i+1]-t，s[i+2]=c[i+2]+s[i+1]-t;

### 我们可以看到，对k取不同的值，得到的s[i]之差等于s[k]。所以，最终p为所有|s[i]-s[k]|之和的最小值。

我们可以把所有s[i]标在一条数轴上，就变成了在数轴上的点中找一个点，使它到其他点的距离之和最小。（|a-b|的几何意义是a到b的距离）

当这个点在最中间两个点中间时（或一个点），距离最小，且为两边对应的点距离之和

以下是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,t,mid,c[1000005],s[1000005]; 
int main(){
	scanf("%lld",&n);
	for(int i = 0;i < n;i++){
		scanf("%lld",&c[i]);
		t += c[i];
	}
	t /= n;
	s[0] = c[0]-t;
	for(int i = 1;i < n;i++)
		s[i] = c[i]+s[i-1]-t;
	sort(s,s+n);
	for(int i = 0;i < n/2;i++)
		p += s[n-1-i]-s[i];
	printf("%lld",p);
	return 0;
}
```



---

## 作者：ljk123 (赞：13)

# 糖果传递题解

我们不妨设第n个人给第一个人的糖果数为x1,第一个人给第二个人的为x2,第二个给第三个的为x3，......,第n-1个人给第n个人的为xn,则：

答案为$|x_{1}|+|x_{2}|+|x_{3}|+......+|x_{n}|$

且满足条件：

$a_{i}+x_{i}-x_{i+1}=average$,

则：$x_{i+1}=a_{i}-average+x_{i}$

$x_{2}=a_{1}-ave+x_{1};$

$x_{3}=a_{2}-ave+x_{2}=(a_{1}-ave)+(a_{2}-ave)+x_{1}$

$x_{4}=a_{3}-ave+x_{3}=(a_{1}-ave)+(a_{2}-ave)+(a_{3}-ave)+x_{1}$

......

$x_{n}=(a_{1}-ave)+......+(a_{n}-1-ave)+x_{1};$

设$c_{n}=\sum _{i=1}^{n}ave-a_{i}$

答案为：$|x_{1}|+|x_{1}+c_{1}|+......+|x_{1}+c_{n}-1|$

据初中知识可知：我们必选中位数。

下面是代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1000006;
ll n,a[N],ave,c[N],sum=0,ans=0;
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
int main(){
    n=read();
    for(int i=1;i<=n;++i) a[i]=read(),sum+=a[i];
    ave=sum/n,c[0]=0;
    for(int i=1;i<=n;++i) c[i]=c[i-1]-a[i]+ave;
    sort(c,c+n),ave=c[n/2];
    for(int i=0;i<n;++i) ans+=abs((ave-c[i]));
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：zylll (赞：8)

思路：看一眼题目是环形均分纸牌。

我们设$X_i$表示第$i$个人给第$i-1$个人的糖果数。

则最终答案为：


$$ans=\sum_{i=1}^n abs(X[i])$$

特殊的是：$X_1$表示第$1$个人给第$n$个人的糖果数。

设：
$$s=(\sum_{i=1}^n a[i] )/n$$

目标状态下，则：

$i=1$时，$s=a_1-X_1+X_2$

$i=2$时，$s=a_2-X_2+X_3$

$i=3$时，$s=a_3-X_3+X_4$

$......$

$i=n$时，$s=a_n-X_n+X_{n-1}$

化成另一种形式：

$X_2=s-a_1+X_1$

$X_3=s-a_2+X_2$

$X_4=s-a_3+X_3$

$......$

$X_n=s-a_{n-1}+X_{n-1}$

我们使$C_i=a_i-s$，则上面形式可以得到简化，即为：


$X_2=X_1-C_1$

$X_3=X_2-C_2$

$X_4=X_3-C_3$

$......$

$X_n=X_{n-1}-C_{n-1}$

把上面式子中的$C$数组展开，显然发现有关$C$数组运算可以使用前缀和处理。

由此，答案转化成了：

$$ans=\sum_{i=1}^n abs(X_1-C_i)$$

显然:

$$ X_1∈C[i],i∈[1,n] $$

我们希望答案最小，转化为数学意义，则最终问题即为，在一个数轴上选出一个点，使得这个点到其他点的距离和最小，则这个点为所有数字中的中位数，证明在此不多赘述。

代码：

```c
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
typedef long long ll;
static const int MAXN=1000050;
using namespace std;
ll n,sum,s,ans,c[MAXN],a[MAXN];
inline ll read(){
    ll x=0;bool sign=false;
    char alpha=0;
    while(!isdigit(alpha)) sign|=alpha=='-',alpha=getchar();
    while(isdigit(alpha)) x=(x<<1)+(x<<3)+(alpha^48),alpha=getchar();
    return sign?-x:x;
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        sum+=a[i];
    }
    s=sum/n;
    for(int i=1;i<=n;i++){
        c[i]=c[i-1]+a[i]-s;
    }
    sort(c+1,c+n+1);
    for(int i=1;i<=n;i++) ans+=abs(c[i]-c[(n>>1)+1]);
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：_zjz (赞：7)

## 题目描述:
有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。



------------
## 解:

最终的局面是每个小朋友的糖果数量相同,即为平均数(ave);

设标号为i的小朋友初始有ai个糖果.

xi表示第i个小朋友给第i-1个小朋友xi个糖果
(x1给xn糖果)

容易发现ans=|x1|+|x2|+|x3|......+|xn|;

对于第1个小朋友
易列出a1-x1+x2=ave

依次类推:

#### 易得:
x1=x1-0;

X2=ave-A1+X1=X1-C1 (C1=A1-ave)

X3=2ave-A1-A2+X1+X2=X1-C2 (C2=A1+A2-X2-2ave)

X4=3ave-A1-A2-A3+X1+X2+X3=X1-C3 

(C3=A1+A2+A3-X2-X3-3ave)

其中ci可在O(n)时间内预处理出来.
........

ans=|x1|+|x1-c1|+.....|x1-cn-1|.

几何意义即为x1距0,c1,.....cn-1距离和最小

x1取中位数即可。

#### 为什么x1取中位数最小?

当在中位数偏右的位置,向左移的时候左边的点距该点
距离减少d，贡献为左边的点个数*d,

右边的增加右边的点个数*d.左边同理

发现只有在中间的时候达到最小........


### 详见代码:

```
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cctype>

typedef long long ll;
using namespace std;

const int N=1000001;
ll a[N],s[N];

inline ll read()
{
	ll X=0,w=0;char ch=0;
	while(!isdigit(ch))
	{
		w|=ch=='-';ch=getchar();
	}
	while(isdigit(ch))
	{
		X=X*10+ch-'0';ch=getchar();
	}
	return w?-X:X;
}

int main()
{
//	freopen("candy.in","r",stdin);
//	freopen("candy.out","w",stdout);
	ll n,sum=0;
	n=read();
	for(int i=1;i<=n;i++)
	{
	   a[i]=read();
	   sum+=a[i];
	}
	int x=sum/n;
	for(int i=2;i<=n;i++)
	s[i]=s[i-1]+x-a[i];//求ci
	sort(s+1,s+n+1);
	ll k=s[(n+1)/2];//取中位数
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		 ans+=abs(k-s[i]);//计算答案
	}
	cout<<ans;
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：Palace (赞：4)

[走你](https://www.luogu.org/problemnew/show/P2512)

## 思路：

这是个环形的[均分纸牌](https://www.luogu.org/problemnew/show/P1031)。

在这里记录一下zhw的**数学**做法。

我们设$X_i$表示第$i$个人需要给第$i-1$个人的糖果，设最后每人手中都有$ave$块糖，则$ans=\sum_{i=1}^n|X_i|$，那么：

$a_i-X_i+X_{i+1}=ave$

那么，

$a_1-X_1+X_2=ave$ $=>$ $X_2=ave-a_1+X_1$

令$C_1=a_1-ave$

那么，

$X_2=X_1-C_1$

还有，

$a_2-X_2+X_3=ave-a$ $=>$ $X_3=ave+X_2-a_2$ $=>X_3=2×ave-a_1-a_2+X_1$ $=>$ $X_1-C_2$

...

我们发现$C_i=sum_i-ave×i$，我们就得到了求$C_i$的方法，而对于$X_i=X_1-C_{i-1}$。

所以$ans=\sum_{i=1}^n|X_i|=|X_1-0|+|X_2-C_1|+...+|X_n-C_{n-1}|$

根据数学知识，这个式子表示$X_1$到数轴上$C_0$ 到 $C_{n-1}$的点的距离之和，所以$X_1$取中位数时，$ans$最小。

## 代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>

#define N 1000010
#define LL long long

using namespace std;

LL n, ave, ans;
LL a[N], c[N], x[N], cc[N], s[N];

int main() {
	
	scanf( "%lld", &n );
	for( LL i = 1; i <= n; ++i ) {
		scanf( "%lld", &a[i] );
		s[i] = s[i - 1] + a[i];
	}
	
	ave = s[n] / n;
	for( LL i = 1; i <= n - 1; ++i ) {
		c[i] = s[i] - ( ave * i );
		cc[i] = c[i];
	} 
	sort( cc + 1, cc + 1 + n - 1 );

	x[1] = cc[( n + 1 ) >> 1];
	for( LL i = 2; i <= n; ++i )
		x[i] = abs( x[1] - c[i - 1] );
	x[1] = abs( x[1] );
	for( LL i = 1; i <= n; ++i )
		ans += x[i];
	printf( "%lld\n", ans );
	return 0;
} 
```

---

## 作者：Infiltrator (赞：2)

现说点别的(雾  
与本题解法有关
# 仓库选址
>描述  
在一条数轴上有N家商店，它们的坐标分别为 A[1]-A[N]。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。  
输入格式  
第一行一个整数N，第二行N个整数A[1]-A[N]。  
输出格式  
一个整数，表示距离之和的最小值。  
样例输入  
4  
6 2 9 1  
样例输出  
12  
数据范围与约定  
对于100%的数据: N<=100000, A[i]<=1000000
 
这道题的答案其实就是所有点距离的中位数  
我们来证明一下  
假设我们所有点中距离中位数的点是k  
那么答案就是$\sum_{i=1}^n(a[i]-a[k])$  
假设有另外一个点比它更优，这个点为q  
那么我们一定可以通过平移点k来得到点q  
假如我们平移U点，U点左边有left个点，右边有right个点,那么右移后新的答案会加left乘平移距离，减right乘平移距离，左移后新的答案会加right乘平移距离，减left乘平移距离
若需将k左移则必定有left>right那么必定k点比q点更优，右移同理    
综上，答案就是所有点距离的中位数   

# 本题其实就是环形均分纸牌
>题目描述
有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。  
输入格式  
小朋友个数n 下面n行 ai  
输出格式  
求使所有人获得均等糖果的最小代价。  
输入输出样例  
输入  
4  
1  
2  
5  
4  
输出  
4    

我们考虑环形均分纸牌可以进行破环成链，那么一个环就有环上点个数种情况(可以从任意点断开)  
用a表示减去平均数之后的纸牌数量，s表示对a的前缀和  
假设从k处断开，那么这个环就断成了一条链  
…………………………  
a[k+1] s[k+1]-s[k]   
a[k+2] s[k+2]-s[k]  
…………………………  
a[n]  s[n]-s[k]  
a[1]  s[1]+s[n]-s[k]  
…………………………  
a[k]  s[k]+s[n]-s[k]  
因为此处a数组已经减去平均数了，所以s[n]=0  
也就是说，答案是$\sum_{i=1}^n(s[i]-s[k])$  
此时我们只要找到最小的k就可以了，我们发现现在的情况和前面提到的货仓选址问题一模一样  
所以k就是s数组的中位数  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define ll long long
ll n;
ll a[5000050],s[5000050];
ll abss(ll x)
{
    if(x>0)return x;
    else return -x;
}
int main()
{
    scanf("%d",&n);
    ll pjs=0;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),pjs+=a[i];
    pjs/=n;
    for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i]-pjs;
    sort(s+1,s+n+1);
    int k=n/2;
    ll answer=0;
    for(int i=1;i<=n;i++)answer+=abss(s[i]-s[k]);
    printf("%lld",answer);
    return 0;
}
```

---

## 作者：C20203030 (赞：2)


## 一、题目

[点此看题](https://www.luogu.org/problem/P2512)

## 二、解法

设$x_i$为$i$号给$i-1$号$x_i$颗糖果（如果为负则方向相反），让后我们可以列出下面的式子：

$a_1-x_1+x_2=ave$

$\dots \dots$

$a_i-x_i+x_{i+1}=ave$

发现有$n-1$个方程，$n$个未知数，可以解出关系式（定义$c[i]=\sum_{j=1}^{i} a[j]-ave$）：

$x_i=x_1-c[i-1]$

我们的答案就是$|x_1|+|x_1-c[1]|+...+|x_1-c[n-1]|$

可以发现这就是个小学的邮局问题，取$c$的中位数即可。（说中位数可能有点不严谨，详细操作看代码吧）


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define int long long
const int MAXN = 1000005;
int read()
{
	int x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
int n,ave,ans,a[MAXN],s[MAXN];
int _abs(int x)
{
	return x>0?x:-x;
}
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		ave+=a[i];
	}
	ave/=n;
	for(int i=1;i<n;i++)
		s[i]=s[i-1]+a[i]-ave;
	sort(s+1,s+n);
	int x1=s[(n+1)/2],val=_abs(x1);
	for(int i=1;i<n;i++)
		ans+=_abs(x1-s[i]);
	n--;
	if(n%2==0) val=min(_abs(s[n/2]),_abs(s[n/2+1]));
	printf("%lld\n",ans+val);
}
```


---

## 作者：厂长 (赞：1)


我们现在设A为平均数，设f[i]表示第i个要给i-1个多少个糖果，f[1]代表第1个要给第n个多少个，有f[i+1]=f[i]+A-a[i] ,有f[i+1]-f[i]=A-a[i]

我们设w[i]=A-a[i-1] 有f[i+1]-f[i]=w[i+1] 可得有:

f[n]-f[n-1]=w[n]; .........(n-1)

f[n-1]-f[n-2]=w[n-1]; .......(n-2)

f[n-2]-f[n-3]=w[n-2]; ........(n-3)

... ... ...

f[2]-f[1]=w[2];  .........(1)

我们把前i个等式相加，可以得到f[i]-f[1]=s[i]; s[i]=sigma(w[j]|j<=i,w[1]=0)

f[i]=s[i]+f[1];

而ans=sigma(f[i]);

说以我们要找到一个f[1]使sigma(s[i]+f[1])最小，明显f[1]就等于s[i]中位数的相反数

就是求出中位数然后再加

~~零点分段还记得吧~~

![](https://i.loli.net/2019/03/26/5c99f1d501587.png)

这是求中位数的函数。。。

abs求绝对值；
```c
#include<bits/stdc++.h>
using namespace std;
long long n;
long long a[999999],b[999999];
long long tot,eve,x,y;
bool cmp(int a,int b){
	return a<b;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		tot+=a[i];
	}
	eve=tot/n;
	for(int i=1;i<=n;i++){
		a[i]-=eve;
	}
	for(int i=1;i<=n;i++){
		a[i]=a[i-1]+a[i];
	}
	sort(b+1,b+n+1,cmp);
	y=(n+1)/2;
	nth_element(a+1,a+y,a+n+1);
	for(int i=1;i<=n;i++){
		x+=abs(a[i]-a[y]);
	}
	cout<<x;
}
/*无bug；
  能AC；
 不超时；
 不暴0；*/

```
祝你好运；

---

## 作者：Sym_Je (赞：1)

         这是一类经典的贪心问题   
  1.最初级的，均分纸牌    
   [ P1031 均分纸牌](https://www.luogu.org/problemnew/show/P1031)   
   
   
   这道题也就是贪心咯，这道题直接先算出平均值，然后把所有数分别减平均值，求出他们比平均值多的，或少了多少。    
   然后因为他只能从左向右中间的只与两边有关系，所以贪心的转移，少了多少或多了多少就直接往右边转移就ok咯。        
   
   ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[110];
int main(){int k=0;int step=0;
	int n;cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];k=k+a[i];
	}
	k=k/n;
	for(int i=1;i<=n;i++){
		a[i]=a[i]-k;
	}int i=1,j=n;
	while(a[i]==0&&i<n){
		i++;
	}
	while(a[j]==0&&j>1){
		j--;
	}
	while(i<j){
		a[i+1]+=a[i];
		a[i]=0;
		++step;
		++i;
		while(a[i]==0&&i<j)i++;
	}
	cout<<step;
	return 0;
}
```     

再进阶就是把它变为一个环，使之首尾相连，可以互相影响。    


就是这个题 [P2512 [HAOI2008]糖果传递](https://www.luogu.org/problemnew/show/P2512)。    

ok 我们先推一下，我们设第i个点向i-1个点xi个（可为负数），我们就可以发现      
ans=∑|xi|    

我们和刚才一样先算出来平均值c，因为最后都要变为c嘛，输入的值为ai，  
c=x（i+1）-xi+ai;    
我们保留x1为未知数，因为我么不可能消掉所以未知数  
我们设pi=ai-c   
x（i+1）=c+xi-ai=xi-pi;    
xi=x（i-1）-pi;   
我们发现xi=x1-∑pi （i<n）    
所以我们维护出前缀和就ok咯   。
我们可以发现当x1取中位数时和最小。   


```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;

long long a[1200403];
long long s[1200403];
long long n;
long long sum;

inline long long read()
{
	long long date=0,f=1;
	char c=getchar();
	while('0'>c||c>'9')
	{
		if(c=='-')
		f=-1;
		c=getchar();
	}
	while('0'<=c&&c<='9')
	{
		date=date*10+c-'0';
		c=getchar();
	}
	return date*f;
}

int main()
{
	n=read();
	for(long long i=1;i<=n;i++)
	{
		a[i]=read();
		sum+=a[i];
	}
	sum/=n;
	for(long long i=1;i<n;i++)
	{
		a[i]-=sum;
		s[i]=s[i-1]+a[i];
	}
	sort(s,s+n);
	sum=0;
	for(long long i=0;i<n;i++)
	sum+=abs(s[n/2]-s[i]);
	printf("%lld",sum);
	return 0;
}
```








---


# [ZJOI2006] 超级麻将

## 题目描述

很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：

普通麻将有砣、索、万三种类型的牌，每种牌有1~9个数字，其中相同的牌每个有四张，例如1砣~9砣，1索~9索，1万~9万各有4张，所以共36\*3=108张牌。胡牌时每人有14张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。

 ![](https://cdn.luogu.com.cn/upload/pic/1709.png) 

要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。

所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是1~100，而每种数字的牌各有100张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！

刺激归刺激，但是拿多了怎么胡牌呢？

超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。

作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。


## 样例 #1

### 输入

```
3
2 4 0 0 0 0 0 …… 0（一共98个0）
2 4 2 0 0 0 0 …… 0（一共97个0）
2 3 2 0 0 0 0 …… 0（一共97个0）```

### 输出

```
Yes
Yes
No```

# 题解

## 作者：Night_Aurora (赞：13)

这道题我们考虑到单调将(就是单独的一对)有点麻烦

于是可以每局先枚举这一对是什么面值，在判断剩下牌是不是都是出(就是句话)

我们可以考虑面值

DPC[n][ll][l]表示现在面值为n的牌都出完了，且以前一位为开始的三连出了ll个

以这一位为开始的三连出了l个,是否可行

很明显边界是DP[0][0][0]=1，终点是DP[N][0][0]

但是状态有点多，考虑优化一下状态

考虑到同一开头的三连，超过2张其实没有意义，比如说出3个三连张相当于出三个大对(3张一样的牌)

以及4个三连相当于三个牌分别出一个大对，并且出一个三连

所以我们发现DP方程里的ll和l只需要是0,1,2就行了，而且没必要保证这个面值牌全出完，只要剩下牌数可以是3x+4y这样就行

所以我们就列出了状态数900，转移复杂度3的DP方程

再加上最开始枚举一对，复杂度是O(N\*90000)

总之还是特别低的，用时36ms，是至今这道题最快最不占用内存的AC代码，比大部分前人代码快几十倍






```cpp
#include <stdio.h>
#include <string.h>
bool DPC[110][3][3];
int N;
int CN[110];
bool Mod[110];
void Input()
{
    int wi;
    for(wi=1;wi<=100;++wi)
        scanf("%d",CN+wi);
    int ma,mb;
    for(ma=0;ma*3<=100;++ma)
        for(mb=0;mb*4+ma*3<=100;++mb)
            Mod[ma*3+mb*4]=1;
}
bool DPA()
{
    int win,wia,wib,wnn;
    memset(DPC,0,sizeof(DPC));
    DPC[0][0][0]=1;
    for(win=0;win<100;++win)
        for(wia=0;wia<3;++wia)
            for(wib=0;wib<3;++wib)
                if(DPC[win][wia][wib])
                    for(wnn=0;wnn<3&&wnn<=CN[win+1]-wia-wib;++wnn)
                        if(Mod[CN[win+1]-wia-wib-wnn])
                            DPC[win+1][wib][wnn]=1;
    return DPC[100][0][0];
}
void ACA()
{
    int wi;
    for(wi=1;wi<=100;++wi)
        if(CN[wi]>1)
        {
            CN[wi]-=2;
            if(DPA())
            {
                printf("Yes\n");
                return;
            }
            CN[wi]+=2;
        }
    printf("No\n");
}
int T;
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        Input();
        ACA();
    }
    return 0;
}
顺便吐槽一句...交题要养好手动选择语言的习惯...
```

---

## 作者：NaVi_Awson (赞：8)

博客也有详细的介绍，欢迎来踩：[菜鸡NaVi\_Awson的博客](http://www.cnblogs.com/NaVi-Awson/p/7257368.html)

这道题题解很多都是用贪心+Hash搜索做的，其实DP也可以解决这道题。

我们考虑选取麻将的先后是不互相影响的。且怎么选当前牌只会影响其相邻的几张牌，我们将这些影响的状态放入方程中，保证无后效性。

令：f[i][j][k][0/1]表示“择第i号牌时，第i-1号牌选j张，第i号牌选k张，之前选的所有牌是否（0/1）选择了将（对子）”是否可行。

于是就有转移方程：

1.考虑选这i号牌做将（对子）：if (k>1) f[i][j][k][1]|=f[i][j][k-2][0];

2.考虑i号牌碰（三张相同）：if (k>2) f[i][j][k][1]|=f[i][j][k-3][1],f[i][j][k][0]|=f[i][j][k-3][0];
3.考虑i号拍杠（四张相同）：if (k>3) f[i][j][k][1]|=f[i][j][k-4][1],f[i][j][k][0]|=f[i][j][k-4][0];
4.考虑i-2,i-1,i三张牌吃（三个连续数字）：if (j>=k&&a[i-2]>=k) f[i][j][k][0]|=f[i-1][a[i-2]-k][j-k][0],f[i][j][k][1]|=f[i-1][a[i-2]-k][j-k][1];
最后结果为f[100][a[99]][a[100]][1]。

附的代码有个玄学的写法：当i==1时，a[i-2]越界？我也不知道它访问到哪去了...




```cpp
#include<set>
#include<map>
#include<ctime>
#include<cmath>
#include<queue>
#include<stack>
#include<cstdio>
#include<string>
#include<vector>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#define LL long long
#define RE register
#define IL inline
using namespace std;
int n,a[105];
bool f[105][105][105][2];
int main()
{
    scanf("%d",&n);
    while (n--)
    {
        memset(f,0,sizeof(f));
        for (RE int i=1;i<=100;i++) scanf("%d",&a[i]);
        f[0][0][0][0]=1;
        for (RE int i=1;i<=100;i++)
            for (RE int j=0;j<=a[i-1];j++)
                for (RE int k=0;k<=a[i];k++)
                {
                    if (k>1) f[i][j][k][1]|=f[i][j][k-2][0];
                    if (k>2) f[i][j][k][1]|=f[i][j][k-3][1],f[i][j][k][0]|=f[i][j][k-3][0];
                    if (k>3) f[i][j][k][1]|=f[i][j][k-4][1],f[i][j][k][0]|=f[i][j][k-4][0];
                    if (j>=k&&a[i-2]>=k) f[i][j][k][0]|=f[i-1][a[i-2]-k][j-k][0],f[i][j][k][1]|=f[i-1][a[i-2]-k][j-k][1];
                }
        printf(f[100][a[99]][a[100]][1] ? "Yes\n":"No\n");
    }
    return 0;
}
```

---

## 作者：一只书虫仔 (赞：5)

#### Description

> 玩 $n$ 次麻将，每一次麻将有点数为 $1 \sim 100$ 的牌，点数为 $i$ 的牌有 $a_i$ 个，可以出的牌型有：
> - 对子：两张一样的牌；
> - 顺子：三张点数为连续自然数的牌；
> - 刻子：三张或四张一样的牌。
> 
> 这一次麻将能胡牌当且仅当去掉一个对子之后都能用顺子和刻子出掉，球队与每一次麻将是否能胡牌。

~~虽然我没打过麻将但我也知道这个规则在扯淡~~

#### Solution

定义 $f_{i,j,k,0/1}$ 为点数为 $i$，点数为 $i-1$ 的有 $j$ 张牌，点数为 $i$ 的有 $k$ 张牌，是否有对子，能否把 $1 \sim i$ 出完，为一个 bool 数组。

分别考虑每一种牌型（注意顺序）：

- 对子：$f_{i,j,k,1}=f_{i,j,k-2,0}$；
- 刻子：
	- $f_{i,j,k,0}=f_{i,j,k-3,0} \lor f_{i,j,k-4,0}$；
    - $f_{i,j,k,1}=f_{i,j,k-3,1} \lor f_{i,j,k-4,1}$；
- 顺子（对于 $f_{i,j,k,0/1}$ 可以考虑出 $k$ 个顺子）：
	- $f_{i,j,k,0}=f_{i-1,a_{i-2}-k,j-k,0}$；
    - $f_{i,j,k,1}=f_{i-1,a_{i-2}-k,j-k,1}$
    
最后判断 $f_{100,a_{99},a_{100},1}$ 即可。

---

## 作者：eternal (赞：5)

首先，我们可以用一点贪心的思想，如果能够凑成顺子就凑出，接下来就是4，3，2个相同的，这样去搜索，但是会T

所以我们需要一个Hash来维护，同时先预处理一部分，这样就能K过去了

```cpp
#include <bits/stdc++.h>
#define rep( i , l , r ) for( int i = (l) ; i <= (r) ; ++i )
#define per( i , r , l ) for( int i = (r) ; i >= (l) ; --i )
#define erep( i , u ) for( int i = head[(u)] ; ~i ; i = e[i].nxt )
using namespace std;
const int maxn = 100 + 5;
typedef unsigned long long ull;
inline ull _read(){
    register ull x = 0 , f = 1;
    register char ch = getchar();
    while( !isdigit(ch) ){ if( ch == '-' ) f = -1 ; ch = getchar(); }
    while( isdigit(ch) ){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
set<ull> s;
ull base[maxn] , a[maxn] , sum;
const ull seed = 13111ull;
bool dfs( int k , bool tw , ull status ){
    if( s.find(status) != s.end() ) return 0;
    s.insert(status);
    while( !a[k] && k <= 100 ) ++k;
    if( k > 100 ) return tw;
    if( a[k] && a[k + 1] && a[k + 2] && k <= 98 ){
        --a[k] , --a[k + 1] , --a[k + 2];
        if( dfs( k , tw , status - base[k] - base[k + 1] - base[k + 2]) ) return 1;
        ++a[k] , ++a[k + 1] , ++a[k + 2];
    }
    if( a[k] >= 4 ) { a[k] -= 4; if( dfs( k , tw , status - 4 * base[k] ) ) return 1; a[k] += 4; }
    if( a[k] >= 3 ) { a[k] -= 3; if( dfs( k , tw , status - 3 * base[k] ) ) return 1; a[k] += 3; }
    if( a[k] >= 2 && !tw ) { a[k] -= 2; if( dfs( k , 1 , status - 2 * base[k] - base[100] ) ) return 1 ; a[k] += 2; }
    return 0;
}
int main(){
    int T = 0;
    base[1] = 1ull; rep( i , 2 , 100 ) base[i] = base[i - 1] * seed;
    scanf("%d" , &T);
    while( T-- ){
        sum = 0; s.clear();
        rep( i , 1 , 100 ) a[i] = _read() , sum += base[i] * a[i];
        if( dfs( 1 , 0 , sum ) ) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

---

## 作者：CmsMartin (赞：2)

## 思路

定义 $f_{i,j,k,0/1}$ 表示现在点数为 $i$，点数为 $i - 1$ 的牌出了 $j$ 张，点数为 $i - 2$ 的牌出了 $k$ 张，是否出过对子的情况下能否打完。

### Case1 出对子
$f_{i,j,k,1} = f_{i,j,k,1}\lor f_{i,j,k-1,0}$

### Case2 出刻子：

$f_{i,j,k,1} = f_{i,j,k,1}\lor f_{i,j,k-3,1}$

$f_{i,j,k,0} = f_{i,j,k,0}\lor f_{i,j,k-3,0}$

$f_{i,j,k,1} = f_{i,j,k,1}\lor f_{i,j,k-4,1}$

$f_{i,j,k,0} = f_{i,j,k,0}\lor f_{i,j,k-4,0}$

### Case3 出顺子

对于 $f_{i,j,k,0}$ 可以考虑出 $k$ 个顺子：

$f_{i,j,k,1} = f_{i,j,k,1}\lor f_{i-1,a_{i-2}-k,j-k,1}$

$f_{i,j,k,0} = f_{i,j,k,0}\lor f_{i-1,a_{i-2}-k,j-k,0}$

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, A[110];
bool Dp[110][110][110][2];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> N;
    while (N--) {
        memset(Dp, 0, sizeof Dp);
        for (int i = 1; i <= 100; i++) cin >> A[i];
        Dp[0][0][0][0] = true;
        for (int i = 1; i <= 100; i++) {
            for (int j = 0; j <= A[i - 1]; j++) {
                for (int k = 0; k <= A[i]; k++) {
                    if (k > 1) Dp[i][j][k][1] |= Dp[i][j][k - 2][0];
                    if (k > 2) {
                        Dp[i][j][k][1] |= Dp[i][j][k - 3][1];
                        Dp[i][j][k][0] |= Dp[i][j][k - 3][0];
                    }
                    if (k > 3) {
                        Dp[i][j][k][1] |= Dp[i][j][k - 4][1];
                        Dp[i][j][k][0] |= Dp[i][j][k - 4][0];
                    }
                    if (j >= k && A[i - 2] >= k) {
                        Dp[i][j][k][0] |= Dp[i - 1][A[i - 2] - k][j - k][0];
                        Dp[i][j][k][1] |= Dp[i - 1][A[i - 2] - k][j - k][1];
                    }
                }
            }
        }
        cout << Dp[100][A[99]][A[100]][1] << endl;
    }

    return 0;
}
```

---

## 作者：lefthand166 (赞：1)

# 超级麻将
## 题解。
注：时间复杂度 $O(n^3)$，空间复杂度 $O(n)$。

翻阅题解没有该做法，实现了空间最小化和复杂度的大大优化。空间复杂度可以实现 $O(1)$，时间复杂度也可以实现 $O(n^2)$，这里就不过度优化了，代码贴在[这](https://www.luogu.com.cn/record/188969853)了。

### 第一步，对“将”进行处理。

首先，可以先对“将”进行枚举，然后删除这两张牌后对整个序列进行查找一种可以一句话一句话删掉的方法。  

### 第二步，构造 dp 方程。

于是，我们可以考虑 dp，设 $f[i][j][k]$，表示到第 $i$ 个数字，这个数字有 $j$ 个，前一个数字还剩下 $k$ 个，是否可以完全删去。  

- **后效性检测**：对于一个位置 $i$，这个位置往前凑出顺子最长为  $3$ ，因此这个位置后方的元素无法访问到 $i-2$ 的元素，因此不保存的元素一定为 $0$，满足无后效性。

### 第三步，状态转移。
设 $l$ 是到 $i - 2$ 结束顺子的个数。

- 前面的必须全部删完，所以此时的状态转移方程为：

~~~cpp
f[i][j - l][k - l]/*([0])*/ |= f[i - 1][k][l]
~~~

- 如果是竖向删除，则为：

~~~cpp
f[i][j][k] |= (f[i][j + 4][k] | f[i][j + 3][k])
~~~

### 第四步，复杂度优化。

很多题解到这就分道扬镳了，可是此时的时间复杂度依然是 $O(n^6)$，常数也很大，所以我们可以考虑继续优化。  

下面是我磨出来的各个数字不断地删除 $3$ 和 $4$ 的数字（`*` 表示可以由 $3$，$4$ 相加得出）：
~~~
1   -> 1
2   -> 2 
3   -> 0，3                  *
4   -> 0，1，4               *
5   -> 1，2，5
6   -> 0，2，3，6            *
7   -> 0，1，3，4，7         *
8   -> 0，1，2，4，5，8      *
9   -> 0，1，2，3，5，6，9   *
……
~~~
发现规律没有，$6$ 以后的数字 $n$ 均能够有办法使其变成 $n - 6$ 以下的所有数字。  

因此，对于一个顺子，如果它是 $3$ 组及以上重复的，我们总能够把他竖向删除最终成为一个重复顺子个数小于等于 $2$ 的，我称这个顺子是必要的顺子。所以一个点最多仅会有 $6$ 个必要的顺子经过。  

所以我们 dp 删除必要的顺子，提前将数量进行压缩，将我们的状态进行修改，第二、三维度最大只有 $6$，这样对于每个点枚举量也只有 $7\times7\times7$。  

到这，枚举序列数时间复杂度为 $O(n)$，枚举将的为 $O(n)$，对于每个点 $O(n)$，所以总时间复杂度为 $O(n^3)$。

## 代码。
注：使用了滚动数组，$57ms$，进一步优化见 [此](https://www.luogu.com.cn/record/188965542) （$37ms$）。

~~~cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110;
int a[110];
bool mak[13][7];
bool f[2][7][7];
int main(){
    ios::sync_with_stdio(0);
    int n;
    cin >> n;
    for (int i = 0; i <= 11; i++) {
        if (i >= 5) memset(mak[i], 1, sizeof mak[i]);
        else memset(mak[i], 0, sizeof mak[i]);
    }
    // mak[i][j]，表示i能够拆成什么数字，12及以上的数字全部换为12再转化
    mak[0][0] = 1;
    mak[1][1] = 1;
    mak[2][2] = 1;
    mak[3][0] = mak[3][3] = 1;
    mak[4][0] = mak[4][1] = mak[4][4] = 1;
    mak[5][0] = mak[5][3] = mak[5][4] = 0;
    mak[6][1] = mak[6][4] = mak[6][5] = 0;
    mak[7][2] = mak[7][5] = mak[7][6] = 0;
    mak[8][3] = mak[8][6] = 0;
    mak[9][4] = 0;
    mak[10][5] = 0;
    mak[11][6] = 0;
    memset(mak[12], 1, sizeof mak[12]);
    while (n--) {
        for (int j = 1; j <= 100; j++) cin >> a[j];
        bool ok = 0;
        for (int j = 1; j <= 100; j++) {
            if (a[j] < 2) continue;
            memset(f[0], 0, sizeof f[0]);
            f[0][0][0] = 1;
            for (int i = 1; i <= 100; i++) {
                memset(f[i & 1], 0, sizeof f[i & 1]);
                if (i == j) a[i] -= 2;
                for (int j = 0; j <= 6; j++) {     //这个区间的原个数
                    if (!mak[min(12, a[i])][j]) continue;
                    for (int k = 0; k <= j; k++)  // 前一个一定得小于这一个不然以后删不完
                        for (int l = 0; l <= k; l++) // 同上理
                            f[i & 1][j - l][k - l] |= f[(i - 1) & 1][k][l];
                }
                if (i == j) a[i] += 2;
            }
            // 0是100 & 1
            if (f[0][0][0]) {
                ok = 1;
                break;
            }
        }
        if (ok) printf("Yes\n");
        else printf("No\n");
    }
}
~~~

---

## 作者：EricWan (赞：1)

看一眼~题解~数据范围，可以想到这题是个 DP，思考如何设定状态。

首先，我们可以知道如果一种牌数量大于 $5$ 或等于 $0$ 或等于 $3$ 或等于 $4$，可以通过出刻子直接解决。

设定状态时肯定需要留一维给当前元素编号（假设为 $i$）。假设以当前元素为结尾的拖拉机已经出完了，我们就可以不用考虑面值小于 $i-1$ 的牌了。然而面值为 $i$ 和 $i-1$ 的牌可能会参与以 $i+1$ 结尾的拖拉机，因此考虑留两维状态给 $i-1$ 剩下的数量和 $i$ 剩下的数量。最后记得留一个 $0/1$ 给对子。

根据上面的推理，我们已经可以设置出状态：$dp_{i,j,k,0/1}$。代表前 $i-2$ 全部用完，$i-1$ 剩 $j$ 个，$i$ 剩 $k$，无/有对子是否可以被达到。

考虑到同一个位置放三个拖拉机相当于放三个刻子，因此转移时只需要枚举到底放 $0/1/2$ 个拖拉机。

具体转移方程和循环方法见代码和注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool possible(int x) {
	return x == 0 ||x == 3 || x == 4 || x > 5;
}
bool impossible(int x) {
	return !possible(x);
}
int T, n, a[105], dp[105][105][105][2];
signed main() {
	cin >> T;
	n = 100;
	while (T--) {
		memset(dp, 0, sizeof(dp));
		for (int i = 1; i <= n; i++) cin >> a[i];
		dp[2][a[1]][a[2]][0] = 1; // 前两个什么都不管
		if (a[1] >= 2) dp[2][a[1] - 2][a[2]][1] = 1; // 对子是 1
		if (a[2] >= 2) dp[2][a[1]][a[2] - 2][1] = 1; // 对子是 2
		for (int i = 3; i <= n; i++) { // 拖拉机的结束位置
			for (int ai = max(a[i] - 2, 0); ai <= a[i]; ai++) { // 出完以 i 结尾的拖拉机后 i 的数量
				for (int ai_2 = 0; ai_2 <= a[i - 2]; ai_2++) { // 出以 i 结尾的拖拉机前 i-2 的数量
					for (int ai_1 = 0; ai_1 <= a[i - 1]; ai_1++) { // 出以 i 结尾的拖拉机前 i-1 的数量
						int n2 = ai_2 - a[i] + ai; // 出完以 i 结尾的拖拉机后 i-2 的数量
						int n1 = ai_1 - a[i] + ai; // 出完以 i 结尾的拖拉机后 i-1 的数量
						if (impossible(n2) || n1 < 0) continue; // 出完以 i 结尾的拖拉机后 i-2 无法通过只出刻子出完或 i-1 数量不够或 i-2 数量不够，不合法
						dp[i][n1][ai][0] |= dp[i - 1][ai_2][ai_1][0]; // 没有对子
						dp[i][n1][ai][1] |= dp[i - 1][ai_2][ai_1][1]; // 有对子
						if (ai >= 2) dp[i][n1][ai - 2][1] |= dp[i - 1][ai_2][ai_1][0]; // 可以出 i 对子
					}
				}
			}
		}
		int ans = 0;
		for (int i = 0; i <= 100; i++)
			for (int j = 0; j <= 100; j++)
				ans |= dp[n][i][j][1] & possible(i) & possible(j); // 可以达到且有对子且剩下的可以通过刻子出完的状态
		cout << (ans ? "Yes" : "No") << endl;
	}
	return 0;
}
```

---

## 作者：dengjunhaodejia09 (赞：1)

[P2593 [ZJOI2006] 超级麻将](https://www.luogu.com.cn/problem/P2593)

这是一道在当年应该比较难的题目，但随着算力的进步已经可以让相对暴力的做法过去了。

观察题目，发现 $n$ 和牌的个数都在 $100$ 以内，很小，其次我们发现一个性质，对于一个数他对与他中间隔两个数及以上的数不会因为他的减少而使得与他中间隔两个数及以上的数，所以在枚举到这个当前点时要是之前与他中间隔两个数的点清零。

所以 dp 状态就出来了：

$dp_{i,j,k,0}$ 表示当前转移完了第 $i$ 个点，此时第 $i-1$ 个位置还有j张牌，第 $i$ 个位置有 $k$ 张牌，且暂时没有两张相同的牌。这是一个 ``bool`` 类型的，为 $1$ 则这种情况成立，为 $0$ 则不成立。

$dp_{i,j,k,1}$ 与上一个差不多，只是他已有两张相同的牌。

而转移也很好写，我们考虑用当前状态推未知状态。

但是我们要保证 $j$ 要清空，也就是上面思路中的隔了两个数的对下一个状态并没有价值，若 $j$ 是第 $a$ 个位置剩下的数，此时用第 $a$ 与 $a+1$ 位置上的数推出 $a+2$ 后要推 $a+3$，此时 $a+3$ 与 $a$ 中间隔两个数所以 $a$ 可以省略。

经过上面的解释你应该已经会了转移，如果还不会就看代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
bool dp[105][105][105][2];
int a[105];
int main(){
	int n;
	cin>>n;
	while(n--){
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=100;i++){
			cin>>a[i];
		}
		dp[2][a[1]][a[2]][0]=1;
		for(int i=2;i<=100;i++){
			for(int j=100;j>=0;j--){
				for(int k=100;k>=0;k--){
					for(int id=0;id<=1;id++){
						if(id==0 && dp[i][j][k][id]){
							if(j>=2){
								dp[i][j-2][k][1]=1;
							}
							if(k>=2){
								dp[i][j][k-2][1]=1;
							}
						}
						if(dp[i][j][k][id]){
//							cout<<i<<' '<<j<<' '<<k<<endl; 
							if(j>=3){
								dp[i][j-3][k][id]=1;
							}
							if(j>=4){
								dp[i][j-4][k][id]=1;
							}
							if(k>=3){
								dp[i][j][k-3][id]=1;
							}
							if(k>=4){
								dp[i][j][k-4][id]=1;
							}
							if(k<j){
								continue;
							}
							if(a[i+1]<j){
								continue;
							}
							dp[i+1][k-j][a[i+1]-j][id]=1;
						}
					}
					
				}
			}
		}
		if(dp[100][0][0][1]){
			cout<<"Yes\n";
		}else{
			cout<<"No\n";
		}
	} 
	return 0;
}
```

---


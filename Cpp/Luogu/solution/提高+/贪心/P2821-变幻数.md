# 变幻数

## 题目描述

给定一个十进制正整数 $n$，它的递归变幻数定义如下：

- 如果 $n$ 的位数多于 $1$ 位（忽略前置的 $0$），将 $n$ 的各个位上的数相乘，乘积为 $m$。称 $m$ 为 $n$ 的子变幻数，$n$ 称为 $m$ 的父变幻数。求一个数的变幻数等于求其子变幻数。即求 $n$ 的变幻数等于求 $m$ 的变幻数。

- 如果 $n$ 的位数只有一位，$n$ 的变幻数即为它本身。 如求 $679$ 的变幻数过程为：$679 \to 378(6 \times 7 \times 9) \to 168(3 \times 7 \times 8) \to 48(1 \times 6 \times 8) \to 32(4 \times 8) \to 6(2 \times 3)$，所以 $679$ 的变幻数为 $2$。

现在的问题是给定一个子变幻数 $k$，问 $k$ 的父变幻数最小是多少？ 如：$k=18$，则 $k$ 的父变幻数可以是 $29$，也可以是 $92$。但最小为 $29$。


## 样例 #1

### 输入

```
48```

### 输出

```
68```

# 题解

## 作者：黃粱一夢 (赞：10)

这道题很明显可以贪心。

题目告诉我们，子变幻数就是父变幻数各个位的乘积。也就是说，把子变幻数分解成若干个大于0小于等于10的数，且这些数的乘积等于子变幻数，那么这些数的任意一种排列都是父变幻数。

所以，我们可以暴力高精把子变幻数除2~9。除到最后，如果发现剩下一个位数大于一位的数（也就是存在大于10的质因子），那么就是不存在父变幻数。

因为要输出最小结果，所以我们要尽量使分解出的数少，也就是从9开始除，一直除到2这样就可以保证位数最少，再按照从小往大的顺序排即是答案。

还有两个注意的地方：
1. 输入时的前导0，个人觉得没什么影响，可以无视
2. 位数为1的时候答案就是自身（题目好像没说清楚）

下面是代码

```cpp
#include<cstdio>
const int N=1005; 
int s[N],len,ans[N],num,a[N]; 
char ch;
int main(){
	int i=9,j;
	do{
		ch=getchar();
		if(ch>='0'&&ch<='9')s[++len]=ch-'0';
	}while(ch!='\n');//读入
	while(i>=2){//高精除法
		int res=0;
		for(j=1;j<=len;j++){
			res=res*10+s[j];
			a[j]=res/i;res%=i;
		}
		if(!res){
			int now=1;
			ans[++num]=i;//i可以被整除，计入答案 
			while(a[now]==0)now++;
			for(j=now;j<=len;j++)
				s[j-now+1]=a[j];
			len=len-now+1;
		}
		else i--;
	}
	if(len>1){//有大于10的质因子，所以不存在父变换数 
		printf("There is no such number!\n");
		return 0;
	}
	else for(i=num;i>=1;i--)
	//因为保存时是从大往小存，所以输出时要逆序输出 
		printf("%d",ans[i]);
	return printf("\n"),0;
}
```

---

## 作者：Erinyes (赞：4)

## Part 1 ：题目分析
这道题非常像一道数学的材料阅读题，实际上也可以按照材料阅读的方式来思考。

首先，根据变幻数的定义，如果给出的子变幻数存在父变幻数，那么它肯定能分解为几个 $1\sim9$ 的数相乘。所以，只要给出的子变幻数有大于 $9$ 的质因数，就一定没有父变幻数。

由于题目要求的是最小的父变幻数，所以生成的父变幻数一定要是位数最小的，然后再把每一位的数字从小到大组合，形成最小的父变幻数。

根据以上推论，很容易就可以想到这道题的解法。
## Part 2 ：运算
首先要把给出的子变幻数分解为几个 $1\sim9$ 的数相乘。

由于要保证位数最少，所以每一轮分解就要尽可能分解出大的数，所以枚举分解的数时要从大到小。
```cpp
void work(int n){
	for(int i=9;i>=2;i--){ //从大到小枚举因数
		if(n%i==0){ //能整除 
			t[++cnt]=i; //用一个t数组记录因数 
			work(n/i); //递归 
			return; //这里不同于dfs，只要找到了可以整除的数，就不用继续枚举了，所以要return 
		}
	}
}
```
接下来就要判断这个数是否有父变幻数，同 Part 1 部分的论述，如果剩下了一个不能被 $2\sim9$ 整除，且大于 $9$ 的数，那么它就没有父变幻数。
```cpp
if(n>9) flag=1; //用flag标记 
```
将前面这些全部做完后，剩下的就很简单了。

由于现在已经确保了位数最少，所以只需要将每一位上的数从小到大排序就可以了。
```cpp
sort(t+1,t+cnt+1); //cnt就是刚才分解时用来当作下标累加器的变量，在这里就相当于位数
```
最后再按顺序输出就可以了。
```cpp
for(int i=1;i<=cnt;i++) printf("%d",t[i]); //不能输出空格
```
## Part 3 ：高精度
由于题目给出的子变幻数**位数**在 $1000$ 以内，所以很明显需要高精度。

下面是重载运算符形式的高精度代码，在这里不做多的解释。
```cpp
string operator * (string a1,string b1){ //高精度乘高精度
    int a[20000]={},b[20000]={},c[50000]={},lena=a1.length(),lenb=b1.length(),lenc,i,j,x;
    string result;
    for(int i=0;i<=lena-1;i++) a[lena-i]=a1[i]-'0';
    for(int i=0;i<=lenb-1;i++) b[lenb-i]=b1[i]-'0';
    for(int i=1;i<=lena;i++){
        x=0;
        for(j=1;j<=lenb;j++){
            c[i+j-1]=a[i]*b[j]+x+c[i+j-1];
            x=c[i+j-1]/10;
            c[i+j-1]%=10;
        }
        c[i+lenb]=x;
    }
	lenc=lena+lenb;
	while(c[lenc]==0&&lenc>1) lenc--;
    for(int i=lenc;i>=1;i--) result+=c[i]+'0';
    return result;
}
string operator / (string a1,int b){ //高精度除单精度
    int a[20000],c[20000],lena=a1.length(),i,x=0,lenc;
    string result;
  	for(int i=0;i<=lena-1;i++) a[i+1]=a1[i]-'0';
    for(int i=1;i<=lena;i++){
        c[i]=(x*10+a[i])/b;
        x=(x*10+a[i])%b;
    }
    lenc=1;
    while(c[lenc]==0&&lenc<lena) lenc++;
    for(int i=lenc;i<=lena;i++) result+=c[i]+'0';
    return result;
}
```
有了这个好东西，我们就只用把 ```int``` 改成 ```string``` 就行了。

但在我调试时，高精度比较大小部分一直出问题，所以在判断有无父变幻数时我换了一种判断位数的方法。
```cpp
//这里的n是string类型
if(n.size()>1) flag=1; //和"if(n>9)"的作用是一样的
```
还有一点，由于本人太弱了，高精度取余不会写，所以只好想了另一种方法来代替取余。
```cpp
if((n/i)*i==n) //注意"n/i"必须打括号，否则编译器会直接将"/i*i"忽略
```

## Part 4 ：代码
```cpp
#include<bits/stdc++.h>
#define maxn 10000005
using namespace std;
string operator * (string a1,string b1){
    int a[20000]={},b[20000]={},c[50000]={},lena=a1.length(),lenb=b1.length(),lenc,i,j,x;
    string result;
    for(int i=0;i<=lena-1;i++) a[lena-i]=a1[i]-'0';
    for(int i=0;i<=lenb-1;i++) b[lenb-i]=b1[i]-'0';
    for(int i=1;i<=lena;i++){
        x=0;
        for(j=1;j<=lenb;j++){
            c[i+j-1]=a[i]*b[j]+x+c[i+j-1];
            x=c[i+j-1]/10;
            c[i+j-1]%=10;
        }
        c[i+lenb]=x;
    }
	lenc=lena+lenb;
	while(c[lenc]==0&&lenc>1) lenc--;
    for(int i=lenc;i>=1;i--) result+=c[i]+'0';
    return result;
}
string operator / (string a1,int b){
    int a[20000],c[20000],lena=a1.length(),i,x=0,lenc;
    string result;
  	for(int i=0;i<=lena-1;i++) a[i+1]=a1[i]-'0';
    for(int i=1;i<=lena;i++){
        c[i]=(x*10+a[i])/b;
        x=(x*10+a[i])%b;
    }
    lenc=1;
    while(c[lenc]==0&&lenc<lena) lenc++;
    for(int i=lenc;i<=lena;i++) result+=c[i]+'0';
    return result;
}
string n;
int flag,cnt;
int t[maxn];
string num[10]={"0","1","2","3","4","5","6","7","8","9"};
void work(string n){
	for(int i=9;i>=2;i--){ //从大到小枚举因数
		if((n/i)*num[i]==n){ //能整除 
			t[++cnt]=i; //用一个t数组记录因数 
			work(n/i); //递归 
			return; //这里不同于dfs，只要找到了可以整除的数，就不用继续枚举了，所以要return 
		}
	}
	if(n.size()>1) flag=1; //用flag标记 
}
signed main(){
	cin>>n;
	work(n);
	if(flag==1){
		printf("There is no such number!");
		return 0; //直接结束程序 
	}
	sort(t+1,t+cnt+1); //从小到大排序 
	for(int i=1;i<=cnt;i++) printf("%d",t[i]); //不能输出空格 
	return 0;
}
```


---

## 作者：junyu33 (赞：1)

**既然有高精，怎么能没有python呢？**

```python
n=input()
n=int(n)
if n<10:print(n) #特判
else:
   i=9
   flg=0
   st=''
   while 1:
      if n==1: break
      if i==1:
         flg=1 
         print("There is no such number!") 
         break
      if n%i==0:
         st+=str(i)
         n//=i #这里一定要用整除，不然n的类型会变成double，从而导致精度炸掉
      else: i-=1
   if flg==0: print(st[::-1]) #倒序
```


---

## 作者：kradcigam (赞：1)

# 前言

这道题还真是一道好题。

# 正文

## 分析

首先，我们想一想，一个子变幻数要满足什么条件。

**有最大质因子不能超过 $9$ 中的。**

然后，发现 $k$ 的父变幻数最小就 $k$ 从 $9$ 到 $2$ 去分解 $k$，然后存起来，最后再反着输出。

为什么？

1. 为了 $k$ 的父变幻数最小，我们第 $1$ 个要保证位数尽量的少。

2. 在位数尽量少的前提下，我们要让数尽量小、

```cpp
#include <bits/stdc++.h>
using namespace std;
int x=9,a[1010],len,l=1;
vector<int>v;
int main(){
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar());
	for(;isdigit(ch);ch=getchar())a[++len]=ch-'0';//读入
	while(x>=2){
		int y=0;
		for(int i=1;i<=len;i++){
			y=y*10+a[i];
			y%=x;
		}
		if(y)x--;//如果不能整除
		else{
			v.push_back(x);//存入
			for(int i=1;i<=len;i++){
				y=y*10+a[i];
				a[i]=y/x;y%=x;//除
			}if(a[l]==0)l++;
		}
	}if(len!=l)puts("There is no such number!");
	else for(int i=v.size()-1;i>=0;i--)cout<<v[i];//反着输出
	return 0;
}
```

# 后记

如果有问题，大家可以在评论区写下来，让这篇题解更加完善。

---

## 作者：hgoicjl (赞：1)

广告:[我的博客](https://www.luogu.org/blog/cmine/)

### 题意
一个数把所有位上的数相乘所得到的的数叫做这个数的变幻数

已知变幻数$(len<1000)$，求最小的原数

### 算法
高精度 贪心


### 解题思路
要求原数$k$最小，首先考虑$len$最小，其次考虑高位上的数字最小

根据题意，若有满足的原数$k$，我们可以写出$k=2^{n_1}*3^{n_2}*...*9^{n_8}$，其中$n_1,n_2...n_8\in N_+$

通过循环，我们可以依此分解$k$

最后通过一个桶来统计$n_1,n_2...n_8$

从小到大依次输出即可

---
```
#include<bits/stdc++.h>
using namespace std;
const int L = 10000;
string a;
int n[10];
string div(string a, int b)//高精度对单精度的除法
{
    string r, ans;
    int d = 0;
    if (a == "0") return a;
    for (int i = 0; i < a.size(); i++)
    {
        r += (d * 10 + a[i] - '0') / b + '0';
        d = (d * 10  + (a[i] - '0')) % b;
    }
    int p = 0;
    for (int i = 0; i < r.size(); i++)
        if (r[i] != '0')
        {
            p = i;
            break;
        }
    return r.substr(p);
}
int mod(string a, int b)//高精度对单精度求余
{
    int d = 0;
    for (int i = 0; i < a.size(); i++) 
        d = (d * 10 + (a[i] - '0')) % b;
    return d;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    memset(n,0,sizeof(n));
    cin>>a;
    if(a=="1")//可能有用(我也不知道
    {
        cout<<1<<endl;
        return 0;
    }
    while(a!="1")
    {
        int i;
        for(i=9;i>=2;i--)//贪心，满足len最小
        {
            if(mod(a,i)==0)
            {
                n[i]++;
                a=div(a,i);
                break;
            }
        }
        if(i==1)//没有2~9是它的因子，即不存在原数
        {
            cout<<"There is no such number!";
            return 0;
        }
    }
    for(int i=2;i<=9;i++)//输出
    {
        while(n[i])
        {
            n[i]--;
            cout<<i;
        }
    }
    cout<<endl;
    return 0;
}
```

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 思路
鉴于我经常做材料阅读题，于是从材料入手。

应为变换数是由一个数各个数位乘积的值。

所以这个数不应含有 $\ge 10$ 的**质因数**。

其次为了最小，数中不应含有 $1$ 且 $2 \times 2 \times 2$ 应用 $8$ 而不是 $222$ 且数码应从小往大排。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int a[10],n;
char ch;
bool mod(string &s,int x){
	int b=0,c=0,d=0,e=0;
	string s1="";
	for(int i=0;i<s.size();i++){
		b*=10;
		b+=s[i]-'0';
		char k=b/x+'0';
		if(k!=0)s1+=k;
		b%=x;
	}
	if(b%x==0){
		s=s1;
		return 1;
	}
	return 0;
}//高精除
int main(){
	cin>>s;
	for(int i=9;i>=2;i--){
		while(mod(s,i))a[i]++;//因数从大到小
	}
    int cnt=s.size();
	for(int i=0;s[i]=='0';i++)cnt--;
	if(cnt!=1){//如果位数大于1，即有>10的质因数
		cout<<"There is no such number!";
		return 0;
	}
	for(int i=2;i<=9;i++){
		for(int j=1;j<=a[i];j++){
			cout<<i;
		}
	}//从小往大
}
```

---

## 作者：programmer330 (赞：0)

## 题解：P2821 变幻数

### 题意复述

给定一个十进制正整数 $n$，它的递归变幻数定义如下：

- 如果 $n$ 的位数多于 $1$ 位（忽略前置的 $0$），将 $n$ 的各个位上的数相乘，乘积为 $m$。称 $m$ 为 $n$ 的子变幻数，$n$ 称为 $m$ 的父变幻数。求一个数的变幻数等于求其子变幻数。即求 $n$ 的变幻数等于求 $m$ 的变幻数。

- 如果 $n$ 的位数只有一位，$n$ 的变幻数即为它本身。 如求 $679$ 的变幻数过程为：$679 \to 378(6 \times 7 \times 9) \to 168(3 \times 7 \times 8) \to 48(1 \times 6 \times 8) \to 32(4 \times 8)\to 6(2 \times 3)$，所以 $679$ 的变幻数为 $2$。

现在的问题是给定一个子变幻数 $k$，问 $k$ 的父变幻数最小是多少？ 如：$k=18$，则 $k$ 的父变幻数可以是 $29$，也可以是 $92$。但最小为 $29$。

### 思路分析

本题使用**贪心**解决。

对子变换数 $k$ 分解质因数，如果分解结果中有大于 $9$ 的数，就说明 $k$ 没有父变换数。

既然需要父变换数小，就要尽量使父变换数的位数尽量少，换句话说就是要将 $k$ 分解为较少的数。在保证 $k$ 有父变换数的情况下，从 $9$ 开始除（一直除到除不尽），一直到 $2$ 为止。

输出时注意从小到大输出。

最后加上**高精**即可，代码不放了。

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

称一个正整数 $n$ 的子变幻数为：$n$ 的各位数相乘的结果，记其为 $m$，则称 $n$ 为 $m$ 的父变幻数，现给定 $m$，求最小的 $n$。

### 2. 思路

贪心。

首先，如果一个数要尽可能小，它的位数也要小，而其各位数相乘的结果是一定的，这就要求各位数尽可能大。

所以我们对 $m$ 不断从 $9$ 开始试除，如果能整除就除，并且把 $9$（或者其他的数）存到一个栈里。

现在又有一个问题：为什么要存到栈里？

如果一个数各位数都确定了，那肯定是小的排在前面更小。

但是我们是从最大的 $9$ 开始除的，应该最后输出。

然后我们联想到栈先进后出的特点，于是把它存进一个栈里。

最后我们判断一下 $m$ 有没有大于 $10$ 的质因数，如果有，就输出 `There is no such number!`。

最后给所有运算套上高精就行了。

---

## 作者：happybob (赞：0)

## 题意

给定一个数 $x$，若 $x < 10$，则 $ans = x$，否则找到一个最小整数 $p$ 满足 $p$ 的各位之乘积 $=x$。若无解输出 `There is no such number!`。

## 解法

显然可以贪心，因为 $x$ 是各位乘积，所以其每个因数显然 $< 10$，因为要 $p$ 最小，则每个因数尽量大，从 $9$ 枚举到 $2$ 即可。

虽然我平时用 C++，但是这个题需要高精 ~~（现在这年头谁还会高精）~~，所以我用 Python 过了。

代码：

```python
a = int(input())
if a < 10:
    print(a)
else:
    p = []
    for i in range(1, 9):
        x = 10 - i
        while a % x == 0:
            p.append(x)
            a = a // x
    if a != 1:
        print("There is no such number!")
    else:
        p.reverse()
        for i in p:
            print(i, end = "")

```


---

## 作者：丧黑福造 (赞：0)

### update：2021/9/8 改了latex的空格问题。

* 算法：高精度 + 一点贪心。

* 分析：

由于子变幻数是父变幻数各个数位的乘积，不难想到分解子变幻数（注意并不是质因数分解，而是个位数分解。也正是如此我们只能逆序（从大到小）枚举个位数）。

因为求父变幻数的最小值，所以将分解后的数逆序输出（此时数字便是从小到大）。

由子变幻数只能包含 $2-9$ 作为因子的条件易得当子变幻数含有 $>9$ 的质数时无解。

 $code$ ：

```cpp
#include <stdio.h>
const int N = 1005;
int c[N], ans[N], len, t;
main() {
	char ch;
	do { 
		ch = getchar();
		if (ch >= '0' && ch <= '9') c[++ len] = ch - '0';
	} while (ch != '\n');//读入
	int i = 9;
	while (i >= 2) {//逆序枚举
		int x = 0;
		for (register int j = 1; j <= len; j ++) {
			x = x * 10 + c[j];
			x %= i;
		}
		if (x) i --;//当前i不是子变幻数的因子
		else {//当前i是子变幻数的因子
			ans[++ t] = i;//将因子i存入答案数组
			for (register int j = 1; j <= len; j ++) {//高精度除法
				x = x * 10 + c[j];
				c[j] = x / i; x %= i; 
			}
		}
	}
	for (register int i = 1; i < len; i ++) if (c[i]) {puts ("There is no such number!"); return 0;}//若除了个位上的1外其他数位上不为0，则无解
	while (t) printf ("%d", ans[t --]);//逆序输出
	return 0;
} 
```

---


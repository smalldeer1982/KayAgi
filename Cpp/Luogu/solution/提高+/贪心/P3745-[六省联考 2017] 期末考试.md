# [六省联考 2017] 期末考试

## 题目描述

有 $n$ 位同学，每位同学都参加了全部的 $m$ 门课程的期末考试，都在焦急的等待成绩的公布。

第 $i$ 位同学希望在第 $t_i$ 天或之前得知**所有**课程的成绩。如果在第 $t_i$ 天，有至少一门课程的成绩没有公布，他就会等待最后公布成绩的课程公布成绩，每等待一天就会产生 $C$ 不愉快度。

对于第 $i$ 门课程，按照原本的计划，会在第 $b_i$ 天公布成绩。

有如下两种操作可以调整公布成绩的时间:
1. 将负责课程 $X$ 的部分老师调整到课程 $Y$，调整之后公布课程 $X$ 成绩的时间推迟一天，公布课程 $Y$ 成绩的时间提前一天；每次操作产生 $A$ 不愉快度。
2. 增加一部分老师负责学科 $Z$，这将导致学科 $Z$ 的出成绩时间提前一天；每次操作产生 $B$ 不愉快度。

上面两种操作中的参数 $X, Y, Z$ 均可任意指定，每种操作均可以执行多次，每次执行时都可以重新指定参数。

现在希望你通过合理的操作，使得最后总的不愉快度之和最小，输出最小的不愉快度之和即可。

## 说明/提示

### 样例解释 1

由于调整操作产生的不愉快度太大，所以在本例中最好的方案是不进行调整；全部的 $5$ 门课程中，最慢的在第 $3$ 天出成绩；  
同学 $1$ 希望在第 $5$ 天或之前出成绩，所以不会产生不愉快度；  
同学 $2$ 希望在第 $1$ 天或之前出成绩，产生的不愉快度为 $(3 - 1) \times 2 = 4$；  
同学 $3$ 希望在第 $2$ 天或之前出成绩，产生的不愉快度为 $(3 - 2) \times 2 = 2$；  
同学 $4$ 希望在第 $3$ 天或之前出成绩，所以不会产生不愉快度；  
不愉快度之和为 $4 + 2 = 6$。

### 数据范围

| Case # | $n, m, t_i, b_i$ | $A, B, C$ |
|:-:|:-:|:-:|
| 1, 2 | $1 \leq n, m, t_i, b_i \leq 2000$ | $A = 10^9; B = 10^9; 0 \leq C \leq 10^2$ |
| 3, 4 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq A; C \leq 10^2; B = 10^9$ |
| 5, 6, 7, 8 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq B \leq A \leq 10^2; 0 \leq C \leq 10^2$ |
| 9 - 12 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq A, B, C \leq 10^2$ |
| 13, 14 | $1 \leq n, m, t_i, b_i \leq 10^5$ | $0 \leq A, B \leq 10^5; C = 10^{16}$ |
| 15 - 20 | $1 \leq n, m, t_i, b_i \leq 10^5$ | $0 \leq A, B, C \leq 10^5$ |

## 样例 #1

### 输入

```
100 100 2
4 5
5 1 2 3
1 1 2 3 3```

### 输出

```
6```

## 样例 #2

### 输入

```
3 5 4
5 6
1 1 4 7 8
2 3 3 1 8 2```

### 输出

```
33```

# 题解

## 作者：泅荼 (赞：62)

看了看楼下题解好多都是三分大佬+一堆函数的分析qwq

注意到本题有一个特点，学生的不愉快度只与最晚公布成绩的时间有关

看看题目数据范围，ti,bi<=10^5

所以很自然地想到一种思路

## 枚举最晚公布成绩的时间

假设我们当前枚举的最晚公布时间为t,那么我们显然要把所以大于t的课程公布时间调为t即可。

此时根据A与B的关系分类讨论:

若A>B 显然将大于t的课程全部使用操作2调为t更优

若A<B 显然能使用操作1则使用，当不能使用（公布时间小于t的课程全部因操作1导致公布时间推迟到t）时，只能将剩下大于t的课程使用操作2处理

A=B随意

对于C，因为最晚公布时间为t，统计一下对不愉快度的贡献即可

具体实现用3个前缀和，对所有情况取min

时间复杂度O（max(bi)）  ~~我是直接从10^5开始枚举的~~

这种做法不开unsigned long long 居然会挂两个点qwq

```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N=100000+5;
typedef unsigned long long ll;
const ll inf=100000000000000000ll;
ll bac[N],bac2[N],ti[N],bi[N],A,B,C,n,m;
int main(){
	scanf("%lld%lld%lld",&A,&B,&C);
	scanf("%lld%lld",&n,&m);
	ll sum1=0,t1=0,sum2=0,t2=0,sum3=0,t3=0;
	for(int i=1;i<=n;i++)
	scanf("%lld",&ti[i]),bac2[ti[i]]++,sum3+=ti[i],t3++;
	for(int i=1;i<=m;i++)
	scanf("%lld",&bi[i]),bac[bi[i]]++,sum2+=bi[i],t2++;
	ll ans=inf;
	for(ll i=100000;i>=1;i--){
		sum1+=i*bac[i],t1+=bac[i];
		sum2-=i*bac[i],t2-=bac[i];
		sum3-=i*bac2[i],t3-=bac2[i];
		if(!sum1)continue;
		ll tep=0;
		if(A<B){
			ll LQ1=sum1-t1*i,LQ2=t2*i-sum2;
			tep+=min(LQ1,LQ2)*A;
			LQ1-=min(LQ1,LQ2);
			if(LQ1)tep+=LQ1*B;
		}
		else {
			ll LQ1=sum1-t1*i;
			tep+=LQ1*B;
		} 
		tep+=(t3*i-sum3)*C;
		ans=min(ans,tep);
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：wjyyy (赞：25)

稍微分析了一下三分的正确性，并用三分+前缀和的方式把$O(m\log m)$优化到了$O(m+\log m)$，表示瓶颈在于输入……

**[博客传送门](https://www.wjyyy.top/2818.html)**


## 题解：

首先分析一下本题的模型。可以想象成一个木桶效应，即“**短板**”的来源。

![img](http://www.wjyyy.top/wp-content/uploads/2018/12/201812091729.png)

如图，即使最快改完卷子的课程用时为$0$，它也需要等待最慢改完卷子的课程。因此在改卷的人力定下来之后，**全部课程**改卷结束的时间是**唯一**的。既然不愉快度是由人力决定的，人力的改变也决定了完成的时间。

因此我们尝试确定一个结束时间，这样再贪心地分配人力，就可以求出以这个时间结束的最小不愉快度。

![img](http://www.wjyyy.top/wp-content/uploads/2018/12/201812091902.png)

虚线此时是**要求改完卷子的时间**，那么在虚线右边的时间就需要通过调度老师或者增加老师来弥补。首先判断是否有$A\le B$，如果是，则虚线左边的空隙都可以拿来填补虚线右边的时间条，剩下的（若$A>B$，则剩下的就还是原来那么多）需要拿$B\times$天数来弥补。再根据学生的需要，把虚线左边的橙色线条到虚线的距离和都统计出来，乘上$C$，就是我们把结束时间定在虚线位置的不愉快度。

![img](http://www.wjyyy.top/wp-content/uploads/2018/12/201812091911.png)

我们知道了这些，实际上就可以做这个题了，用两部分前缀和预处理一下，这个时间就可以从$max\{b_i\}$向前枚举了。不过害怕前缀和出问题的话，可以想想三分，此时要证不愉快度是单峰的。~~三分好像不比前缀和好写到哪去。~~

假设我们现在有最优解$x=t$，那么对于$x+a(a>0)$来说，一定有$ans_{x+a}>ans_x$。

理由是随着改卷结束时间（虚线）的增加，出现在虚线以左的橙线会在个数和距离上都不断增加，尽管由$A,B$产生的不愉快度会减小，但只是杯水车薪，况且这个减小的幅度也会越来越小，最后趋近于$0$。可能会有人担心这个不愉快度减小得比$C$部分增加得快，如果存在某解比最优解更优，它一定与最优解相邻，既然相邻就会一定被三分过程更新到。

对于$x-a$同理，$A,B$产生贡献增加的幅度会越来越大，而$C$产生的贡献幅度会越来越小。因此三分的正确性可以保证。

那么我们就有了$O(m\log b_i)$的优秀三分解法。再在三分内部使用前缀和，就可以做到$O(m+\log b_i)$了~~好神经啊~~。

注意要特判$C_i=10^{16}$的情况，这种情况就算全部补充老师也比让学生不满意优，因此直接贪心决策怎样调度老师。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#define ll long long
#define N 100005
ll read()
{
    ll x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
ll b[N],sum[N];//有多少人期望在第i天之前出成绩
ll sum1[N];//前面人的天数之和
ll Sum[N],Sum1[N];//这里维护的是出成绩时间前缀和
ll x,y,z,n,m;
ll f[N];//记忆化在第i天出成绩的代价（减小三分常数）
ll calc(int u)//要求在第u天出成绩
{
    if(f[u]!=-1)
        return f[u];
    f[u]=0;
    ll r=0,t=0;//r表示有多少余力 t表示还需要多少
    r=Sum[u]*u-Sum1[u];
    t=Sum1[N-1]-Sum1[u]-(Sum[N-1]-Sum[u])*u;
    //↑O(1) ↓O(m)
    /*for(int i=1;i<=m;++i)
        if(b[i]>u)
            t+=b[i]-u;
        else
            r+=u-b[i];
    */
    //首先要填满 贪心看是调度便宜还是直接加便宜
    if(x<y)
    {
        ll tmp=r<t?r:t;
        f[u]+=tmp*x;
        t-=tmp;
    }
    f[u]+=t*y;
    f[u]+=(sum[u]*u-sum1[u])*z;
    return f[u];
}
int main()
{
    memset(f,-1,sizeof(f));
    x=read();y=read();z=read();n=read();m=read();
    int u,mn=N;
    for(int i=1;i<=n;++i)
    {
        u=read();
        ++sum[u];
        mn=mn<u?mn:u;
    }
    for(int i=1;i<N;++i)
    {
        sum1[i]=sum1[i-1]+sum[i]*i;
        sum[i]+=sum[i-1];
    }
    for(int i=1;i<=m;++i)
    {
        b[i]=read();
        ++Sum[b[i]];
    }
    for(int i=1;i<N;++i)
    {
        Sum1[i]=Sum1[i-1]+Sum[i]*i;
        Sum[i]+=Sum[i-1];
    }
    int l=0,r=N-1,mid;
    if(z==10000000000000000)
        r=mn;
    while(l<r)
    {
        mid=(l+r)>>1;
        ll y_=calc(mid),y__=calc(mid+1);
        if(y_==y__)
        {
            printf("%lld\n",y_);
            return 0;
        }
        else if(y_>y__)
            l=mid+1;
        else
            r=mid;
    }
    printf("%lld\n",calc(l));
    return 0;
}

```

---

## 作者：Soulist (赞：12)

一道比较清真友好的贪心+枚举题qwq

可以发现答案之和公布时间最晚的学科有关，假设其公布时间为$k$，那么答案为：

$$\sum \max( 0, k-b_i)*\rm C$$

但是由于存在两个操作，所以最晚公布的学科的时间是可以被修改的，我们考虑枚举这个最晚公布的学科的时间。

对于一个固定的$k$，有所有人等待的时间便是一个定值，于是接下来的工作就是如何在消费最小的情况下将所有学科的公布时间改为$k$

对于$\rm A>B$的情况，显然最优的方法是全部选$\rm B$操作，于是我们只需要统计一下对于某一个$k$，比$k$大的数与$k$的差值之和，这个可以比较简单的利用前缀和解决

对于$\rm A < B$的情况，我们显然要尽量用操作$1$，不能用的时候再用$2.$，可以考虑操作$1$可以被使用的次数，可以发现是比$k$小的数与$k$的差之和，同样可以一个前缀和带走，对于剩下的，全部选$2.$即可

然后就没了...（大雾

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define drep( i, s, t ) for( register int i = t; i >= s; -- i )
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 1e5 + 5 ; 
int A, B, C, n, m, Max, t[N], b[N], Sum[N], Pre[N], Nxt[N], Sz[N], Rev[N], Siz[N] ; 
int Ans ; 
signed main()
{
	A = gi(), B = gi(), C = gi(), n = gi(), m = gi() ; 
	rep( i, 1, n ) t[i] = gi(), Max = max( Max, t[i] ), ++ Siz[t[i]] ;
	rep( i, 1, m ) b[i] = gi(), Max = max( Max, b[i] ), ++ Sz[b[i]], ++ Rev[b[i]] ;
	sort( t + 1, t + n + 1 ), sort( b + 1, b + n + 1 ) ;
	rep( i, 1, Max ) Siz[i] += Siz[i - 1], Sum[i] = Sum[i - 1] + Siz[i - 1] ; 
	rep( i, 1, Max ) Pre[i] = Pre[i - 1] + Sz[i - 1], Sz[i] += Sz[i - 1] ;
	drep( i, 1, Max ) Nxt[i] = Nxt[i + 1] + Rev[i + 1], Rev[i] += Rev[i + 1] ;
	rep( i, 1, Max ) {
		int rAns = C * Sum[i] ;
		if( rAns > Ans && Ans ) break ; 
		if( A < B ) rAns += min( Pre[i], Nxt[i] ) * A, Nxt[i] -= Pre[i], rAns += max( 0ll, Nxt[i] ) * B ; 
		else rAns += Nxt[i] * B ;
		if( !Ans || rAns < Ans ) Ans = rAns ; 
	}
	printf("%lld\n", Ans ) ;
	return 0 ;
}
```

---

## 作者：年华天地 (赞：10)

我是从分治来的，一看题觉得是二分答案，想想觉得可以二分时间，但写的时候就假了，翻题解发现可以枚举时间，额...

我来讲一讲具体怎么枚举吧，首先我们发现一个特点，如果最晚出成绩的时间一定，那么我们一定可以求出这时的最小不愉快度，怎么求呢？我们先算出学生等待的时间 $\times$C，就得出了学生对答案的贡献，然后我们算出有多少成绩出来的时间大于了当前的时间，算出需要弥补的时间，我们有两种方法弥补时间，一是用A操作，用前面多出来的时间来弥补后面的时间，二是用B操作直接弥补后面的时间。

那么怎么算出学生等待的时间呢？可以用前缀和，我们假设t1为学生等待时间小于i的最大值
```
tmp+=(i*t1-suma[t1])*C;//前面需要等待的代价
```

怎么算后面需要弥补的时间与前面多出的时间呢？也可以用前缀和，我们假设t2为成绩公布时间小于等于i的最大值
```
s1=sumt[m]-sumt[t2]-i*(m-t2);//后面需要的时间 
s2=i*t2-sumt[t2];//前面多余的时间
```
那么最后一个问题，我们怎么算出t1,t2呢？
我们可以先对时间排序，二分查找，也可以拍完序后一次枚举。
```
for (ll i=t[m];i>=a[1];i--)
{
	while(a[t1]>=i)t1--;//t1为学生等待时间小于i的最大值 
	while(t[t2]>i)t2--;//t2为成绩公布时间小于等于i的最大值
}
```
为什么可以这样写while循环呢？因为t,a数组都是单调的，当i变大时，我们不需要从头开始遍历，只需从上一次的位置开始遍历就可以了。

完整代码

```
#include<cstdio>
#include<algorithm>
#include<iostream>
#define ll long long
#define ull unsigned long long
using namespace std;
const int maxn=2e5;
ll n,m,t[maxn],A,B,C,a[maxn],l,r,suma[maxn],sumt[maxn],t1,t2;
unsigned long long ans=1e17,s1,s2,tmp; 
int main()
{
	scanf("%lld%lld%lld",&A,&B,&C);
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for (int i=1;i<=m;i++)scanf("%lld",&t[i]);
	sort(t+1,t+m+1);
	sort(a+1,a+n+1);
	for (int i=1;i<=n;i++)suma[i]=suma[i-1]+a[i];
	for (int i=1;i<=m;i++)sumt[i]=sumt[i-1]+t[i];
	t1=n,t2=m;
	for (ll i=t[m];i>=a[1];i--)
	{
		tmp=0;
		while(a[t1]>=i)t1--;//t1为学生等待时间小于i的最大值 
		while(t[t2]>i)t2--;//t2为成绩公布时间小于等于i的最大值 
		tmp+=(i*t1-suma[t1])*C;//前面需要等待的代价 
		s1=sumt[m]-sumt[t2]-i*(m-t2);//后面需要的时间 
		s2=i*t2-sumt[t2];//前面多余的时间 
		if (B<=A)tmp+=s1*B;
		else
			if (s2>s1)tmp+=s1*A;//全用A操作，用前面的补 
			else tmp+=s2*A+(s1-s2)*B;//能用A的用A，不能的用B 
		ans=min(ans,tmp);
	}
	printf("%llu",ans);
	return 0;
}
```




---

## 作者：s_a_b_e_r (赞：8)

###递推

//看到很多三分的，就忍不住加上一个枚举的

这个题数据范围<=10^5;不是很大(相加就是long long了)所以可以从最小的学生的不满意度开始枚举；

一直到最后一个老师判完卷子（讨厌考试）

老师不满意度是一条单调上升的曲线；学生则是下降；

那门合成两条线一定是一条二次函数的并属于0到正无穷的曲线；

那就可以构造出来一个a数组代表每一个函数（老师&学生）增长的情况（其实是导数......）

即每往后拖延一天，学生不满意度就在这一天只前的全加单位一；如果用exam[i]表示在时间i有x个人的话，那这一天增长的不满意为

sum(k=0;i<i;i+=1)exam[k];即exam的前缀和

对于老师也一样；然后按A,B贪心；B<A直接选2；B>A就有需求和提供的关系了；

最后就是特判C了（不然会出现负数的wa）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define mann 150000
long long D(){
     long long k=5;
     for(int i=1;i<=30;i++)k*=10;
     return k;
}
using namespace std;
long long ans=D();
long long C,A,B,n,m;
struct SABER{
long long q,h,c;//q为老师前缀和，h为老师后缀和，c为学生的前缀和
}a[mann];
long long student[mann],exam[mann];
long long q,maxa,maxb,mina=mann;
long long need,rest,CC;
long long pd(long long k1,long long k2,long long k3){
       if(A<B){
       if(k1==k2){return k3*C+k1*A;}
       if(k1>k2){return k3*C+k2*A+(k1-k2)*B;}
       else{return A*k1+C*k3;}
       }
       else {return k1*B+k3*C;}
}
int main(){
    cin>>A>>B>>C>>n>>m;
    for(int i=1;i<=n;i++){cin>>q;student[q]++;maxa=max(maxa,q);mina=min(mina,q);}
    for(int i=1;i<=m;i++){cin>>q;exam[q]++;maxb=max(maxb,q);}
    for(int i=1;i<=maxa;i++){a[i].c=a[i-1].c+student[i];}
    for(int i=1;i<=maxb;i++)a[i].q=a[i-1].q+exam[i];
    for(int i=maxb;i>=mina;i--){a[i].h=a[i+1].h+exam[i];need+=a[i].h;}
    for(int i=1;i<mina;i++){rest+=a[i].q;}
    for(int i=mina;i<=maxb;i++){
      need-=a[i].h;
      ans=min(ans,pd(need,rest,CC));
      rest+=a[i].q;
      CC+=a[i].c;
      if(C>1e7+1)i=mann;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：11D_Beyonder (赞：5)

## 分析  
设经过操作后所有成绩全部公布的时间为 $x$，所获得的不愉快度为 $f(x)$。    
当 $x$ 很小，那么大部分同学都能在其能忍受的时间 $t_i$ 内知晓成绩，但是由于 $x$ 很小，$b_i>x$ 的情况是很多的，为了使所有科目的成绩都在时间 $x$ 内出来，就需要将大于 $x$ 的 $b_i$ 减小，那么就会因为多次修改 $b_i$ 获得较多的不愉快度，因此 $f(x)$ 是比较大的；当 $x$ 很大，虽然不用怎么修改 $b_i$，但是 $x$ 会超出大部分同学的时限 $t_i$，因此 $f(x)$ 也是比较大的。  
根据以上分析，$f(x)$ 应当是一个下凸的单峰函数，可以用三分法找到极小值点。  
接下来分析如何计算 $f(x)$的值。假设强制所有成绩全部公布的时间为 $x$，将 $f(x)$ 分为两部分，等待成绩公布获得的不愉快度，以及修改 $b_i$ 使得对于任意 $b_i$ 有 $b_i\le x$ 所获得的不愉快度。等待成绩公布获得的不愉快度可以直接简单累加，```res+=C*(x-t[i])```。接下来讨论修改 $b_i$ 使得对于任意 $b_i$ 有 $b_i\le x$ 所获得的不愉快度。若 $A>B$ 显然将成绩公布时间大于 $x$ 的课程全部使用操作 $2$ 调整为 $x$ 更优；若 $A<B$ 显然要尽量使用操作 $1$，当公布时间小于 $x$ 的课程全部因操作 $1$ 导致公布时间推迟到 $x$ 时，将剩下公布时间大于 $x$ 的课程使用操作 $2$ 处理。按照以上为规则，即可在 $O(n+m)$ 内得到 $f(x)$。   
## 代码  
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define ll long long
#define N 100003
using namespace std;
int t[N],b[N];
int n,m;
ll A,B,C;
ll f(int x)//出成绩的时间为x
{
	int i;
	ll res=0;
	for(i=1;i<=n;i++)
	{
		if(x>t[i])//到截止日期还没出成绩
		{
			res+=C*(x-t[i]);
		}
	}
	//计算更改截止日期的代价
	if(A<B)
	{
		ll extra,need;
		extra=need=0;
		for(i=1;i<=m;i++)
		{
			if(b[i]<x) extra+=x-b[i];
			else if(b[i]>x) need+=b[i]-x;
		}
		//多余的天数为extra，可以用来弥补超过x的天数need
		/*
			当公布时间小于x的课程全部因操作1导致公布时间推迟到x时
			将剩下公布时间大于x的课程使用操作2处理
		*/
		if(extra>need) res+=A*need;
		else res+=A*extra+(need-extra)*B;
	}
	else//全部使用操作2
	{
		for(i=1;i<=m;i++)
		{
			if(b[i]>x)
			{
				res+=B*(b[i]-x);
			}
		}
	}
	return res;//获得f(x)
}
int main()
{
	cin>>A>>B>>C;
	cin>>n>>m;
	int i;
	for(i=1;i<=n;i++) scanf("%d",t+i);
	for(i=1;i<=m;i++) scanf("%d",b+i);
	int ans;
	/*
		特判
		当C很大，就要让x=min{t[i]}
		不能让任何一个同学等一天
		否则代价巨大
		也不能让x<min{t[i]}
		否则修改b[i]的代价也会变大
	*/
	if(C==10000000000000000)
	{
		ans=0x3f3f3f3f;
		for(i=1;i<=n;i++) ans=min(ans,t[i]);
	}
	else//三分
	{
		int l,r;
		l=r=1;
		for(i=1;i<=n;i++) r=max(r,t[i]);
		while(r-l>=10)//预留的区间为10
		{
			int lmid=l+(r-l)/3;
			int rmid=r-(r-l)/3;
			if(f(lmid)>f(rmid))
			{
				ans=l;
				l=lmid+1;
			}
			else r=rmid-1;
		}
		while(l<=r)
		{
			if(f(l)<f(ans)) ans=l;
			l++;
		}
	}
	cout<<f(ans)<<endl;//输出
	return 0;
}
```

---

## 作者：zj余能 (赞：5)

这道题一开始做，并不能想到什么算法；但仔细读题后发现，

如果给定一个结束时间，无论是计算学生的不愉快度还是还是

修改老师，都与其是哪个学生或调动那门课无关；

再看：如果给定的时间越迟，学生的不愉快度就愈大；

而修改老师的不愉快度就愈小；由此发现两者的不愉快度之和，

是一个凸函数，必存在一个时间点使得不愉快度取得极小值。

于是：

##三分

由学生们期望时间的上下界开始三分，每次调用sigma函数来

求得修改老师的最小不愉快度；而在求sigma时应用贪心思想：

用rest表示所有课程能提前的天数，need表示需要推迟的天数；

如果A的费用比B的费用还要大，那么用B一定比A划算，

则答案为B\*need；

如果A的费用比B的费用小，那么如果存在某课程时间比给定

时间迟，那将其提前没有负面影响，则此时用A比用B更优，

否则用没有负面影响的B更优了，即A\*rest+B\*(need-rest)；



```cpp
%:pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long
using namespace std;
const ll INF=pow(2,62),MAXN=1e5+10;

ll n,m,A,B,C,l=INF,r=-INF;
ll t[MAXN],b[MAXN];


inline ll sigma(ll tm){ //用于求出在tm时间下，老师们的不愉快度 
    ll rest=0,need=0;
    for (ll i=1;i<=m;++i) 
        if (b[i]<=tm) rest+=tm-b[i];//加上可以被推迟的天数 
                 else need+=b[i]-tm;//加上需要被提前的天数 
    if (A<B){ //假如存在A比B要省，则先尽可能的用A 
        if (need<=rest) return A*need;//全部可以用A解决 
        return A*rest+B*(need-rest);  //或A解决一部分后用B 
    }
    return B*need;//如果B比A更省，那就没有用A的必要了 
}


int main(){
    scanf("%lld%lld%lld",&A,&B,&C);
    scanf("%lld%lld",&n,&m);
    for (ll i=1;i<=n;++i){
        scanf("%lld",&t[i]);
        if (l>t[i])l=t[i];if (r<t[i])r=t[i];
            //找出要三分的l，r区间 
    }
    for (ll i=1;i<=m;++i)
        scanf("%lld",&b[i]);

    while (r-l>8){ //三分缩小正解存在的区间 
        ll m1=l+(r-l)/3,m2=l+(r-l)/3*2;
        ll r1=sigma(m1),r2=sigma(m2);
            //先求出在该时间下，老师的不愉快度 
        for (ll i=1;i<=n;++i) //求出m1点 
        if (m1>t[i]){
                if (C==1e16) {r1=INF;break;} //这里特判，防止longlong爆 
                        else  r1+=C*(m1-t[i]);//加上学生的不愉快度 
        }
        for (ll i=1;i<=n;++i) //求出m2点 
        if (m2>t[i]){            
                if (C==1e16) {r2=INF;break;}
                        else  r2+=C*(m2-t[i]);
        }
        if (r1<=r2) r=m2;
               else l=m1;
    }
    ll res=INF;
    for (ll i=l;i<=r;++i){ //在缩小后的范围内找 
        ll res1=sigma(i);
        for (ll j=1;j<=n;++j) //与上面同理 
            if (i>t[j])
                if (C==1e16) {res1=INF;break;}
                        else  res1+=C*(i-t[j]);
        if (res1<res)res=res1;
    }
    cout <<res<<endl;
    return 0;
} 
```

---

## 作者：Viston (赞：3)

这道题今天模拟赛考了啊.....纪念一下.....来写个题解。    



### 首先我们要明白.....这道题的T和S那么小是有原因的。    
于是我在推了许久后发现了似乎可以枚举第几天公布成绩，通过前缀和和数学计算＋二分查找天数在学生中的位置，然后$O(1)$数学计算。    
然后一个$O(NlogN)$，并且不太美观的代码出来了.......    

```
#include<bits/stdc++.h>
#define reg register
using namespace std;
long long a,b,c,d,e,f[200002],g[200002],h,maxx,maxn,m[200002],n[200002];
unsigned long long ans=1e17;
inline long long read(){
    reg long long X=0;reg char ch=getchar();
    while(isspace(ch)) ch=getchar();
    while(isdigit(ch)) X=X*10+(ch^48),ch=getchar();
    return X;
}
int main(){
    a=read(),b=read(),c=read();
    d=read(),e=read();
    for(reg long long i=1;i<=d;++i) maxx=max(f[i]=read(),maxx);
    for(reg long long i=1;i<=e;++i) maxn=max(g[i]=read(),maxn);
    sort(f+1,f+d+1);sort(g+1,g+e+1);
    for(reg long long i=1;i<=e;++i) m[i]=g[i]+m[i-1];
    for(reg long long i=1;i<=d;++i) n[i]=f[i]+n[i-1];    //前缀和
    for(reg long long i=max(maxx,maxn);i>=1;i--){
        unsigned long long tot=0;
        int wz=lower_bound(g+1,g+e+1,i+1)-g;       //二分
        if(b<=a) tot+=((m[e]-m[wz-1]-i*(e-wz+1))*b);
        else tot+=min(((i*(wz-1))-m[wz-1]),m[e]-m[wz-1]-i*(e-wz+1))*a+((m[e]-m[wz-1]-i*(e-wz+1)-min(((i*(wz-1))-m[wz-1]),m[e]-m[wz-1]-i*(e-wz+1)))*b);
        int wz2=lower_bound(f+1,f+d+1,i)-f;
        tot+=((wz2-1)*i-n[wz2-1])*c;
        ans=min(ans,tot);
    }
    cout<<ans;
}

```

---

## 作者：zcysky (赞：2)

观察到函数具有单峰的性质，那么三分一下即可。

计算出不满意度进行比较，调整三分的端点。

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
typedef long long ll;
int n,m,r,t[N],b[N];
ll a,B,c,ans;
ll calc(int p){
    ll x=0,y=0;
    for(int i=1;i<=m;i++)if(b[i]<p)x+=p-b[i];else y+=b[i]-p;
    return a<B?min(x,y)*a+(y-min(x,y))*B:y*B;
}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    cin>>a>>B>>c>>n>>m;
    for(int i=1;i<=n;i++)t[i]=read();
    for(int i=1;i<=m;i++)b[i]=read();
    sort(b+1,b+m+1);sort(t+1,t+n+1);
    if(c>=1e16)ans=calc(t[1]);
    else{
        ans=1e16;int l=1,r=N;
        while(r-l>5){
            int mid1=l+(r-l)/3,mid2=r-(r-l)/3;
            ll c1=calc(mid1),c2=calc(mid2);
            for(int i=1;i<=n;i++)if(t[i]<mid1)c1+=c*(mid1-t[i]);
            for(int i=1;i<=n;i++)if(t[i]<mid2)c2+=c*(mid2-t[i]);
            if (c1<=c2)r=mid2;else l=mid1;
        }
        for(int i=l;i<=r;i++){
            ll x=calc(i);
            for(int j=1;j<=n;j++)if(t[j]<i)x+=c*(i-t[j]);
            ans=min(ans,x);
        }
    }
    cout<<ans<<endl;
}
```

---

## 作者：zhaimingshuzms (赞：2)

#这题时间复杂度nlogn

先看题目，学生的不满意度与顺序无关，所以先对学生排序，老师调度的不满意度也与顺序无关，所以对批完卷子时间再排序，

然后枚举需要的批完所有卷子的时间，再用两个二分查找和前缀和、后缀和搞一搞，得出ex，再与ans比较取最小值

##################################################################

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
unsigned long long  A,B,C,n,m,i,maxt,lol,lol2,ex,ans=1e19,mid,need,have,l,r,t[100001],e[100001],st[100001],se[100001];
int main()
{
    scanf("%lld%lld%lld%lld%lld",&A,&B,&C,&n,&m);
    for (i=1; i<=n; i++) scanf("%lld",&e[i]);
    for (i=1; i<=m; i++) {scanf("%lld",&t[i]); maxt=max(maxt,t[i]);}
    sort(e+1,e+n+1); sort(t+1,t+m+1);
    for (i=1; i<=n; i++) se[i]=se[i-1]+e[i];
    for (i=m; i>=1; i--) st[i]=st[i+1]+t[i];
    for (i=1; i<=maxt; i++)
    {
        lol=0; lol2=0; ex=0;
           for (l=1,r=n,mid=(l+r)>>1;l<=r;mid=(l+r)>>1) if (e[mid]<i) {l=mid+1; lol=mid;} else r=mid-1;
        if (lol>0) ex=(lol*i-se[lol])*C;
        for (l=1,r=m,mid=(l+r)>>1;l<=r;mid=(l+r)>>1) if (t[mid]>i) {r=mid-1; lol2=mid;} else l=mid+1;
        if (lol2>0)
        {
            need=st[lol2]-(m-lol2+1)*i;
            if (A>=B) ex+=need*B;
            else 
            {
                have=(lol2-1)*i-(st[1]-st[lol2]);
                ex+=have>=need?need*A:have*A+(need-have)*B;
            }
        }
        ans=min(ans,ex);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：zzw4257 (赞：1)

### 题意

>给定$n$个数$\{T_i\}$和$m$个数$\{B_i\}$,一些操作和其贡献如下
>
>- 对$\forall x\neq y$,使得$B_x=B'_x+1,B_y=B'_y-1$,付出$A$,可操作任意多次
>- 对$\forall x$使得$B_x=B'_x-1$,付出$B$,可操作任意多次
>- 也可以选择不再操作,对$B$中最大元素$B_{mx}$付出$C\displaystyle{\sum_{i=1}^n\max\{0,B_{mx}-T_i\}}$

### Solution

贪心做法来自[博客](https://www.luogu.com.cn/blog/Shallowsing/ti-xie-p3745-liu-xing-lian-kao-2017-ji-mo-kao-shi-post)

这种明显很奇特杂乱的要求我们需要走一步看一步

问题可以看做一损俱损的杀招(一个变小一个变小)/完全无伤的完美招数(只是缩小距离)/一个变动不定的界限就是我们最终要把$B_{mx}$停在什么位置三者的带权均衡

首先从特殊数据得到启示

```C=1e16```其实表示我们必须刚好用两种杀招向前挪到$T_{mi}$定线前是一个贪心问题，因此我们发现那条线很重要

在贪心策略以及```B≤A```的数据可以发现在$B\leq A$时候俱损的招可以被替代，否则必须用才用(考前的变后造成损失最小)

策略定下来了，枚举$B_{mx}$把所有大于等于这条线的降下来，然后根据$A,B$的大小情况选择要不要先尽量用$A$

---

## 作者：俾斯麦 (赞：1)

# 题解—[六省联考]期末考试（模拟+递推）

题目传送门：[P3745 [六省联考2017]期末考试](https://www.luogu.com.cn/problem/P3745)

**in.1**

100 100 2

4 5

5 1 2 3

1 1 2 3 3


**out.1**

6

**数据范围与约定** 

![](https://cdn.luogu.com.cn/upload/pic/5212.png)


## 思路

**一些性质**

 1.由题意得，其实影响最后答案的科目一定是排在最后面的科目。
 
 2.如果我们将最后同一时刻上的科目往前移动，而没有移动在这一时刻上的所有科目，那么这之前的移动是无效的。
 
 3.当不考虑特殊条件时，如果 A < B 那么优先选 A 操作，再选 B。否则全部选 B 操作即可。
 
**思考**
  
 如果我们枚举时刻 i ，考虑将所有在时刻 i 之后的课程提到 i 时刻来，那么对于时刻 i 而言，这一定是当前时刻的最优解。
 
 发现数据很大，所以我们要预处理出将所有在时刻 i 之后的科目提到 i 时刻后，学生的不满意度 和 提前操作的不满意度 。
 
 由于 A 操作的次数在每个时刻 i 是有限的（不能把科目延迟到 i 之后），我们也要预处理出来。

**主要分为两部分：**

1.预处理出我们需要的数组。

2.O(n)枚举时间，取最小答案即可（包括一些特判）

**处理：**

1.我们用2个桶 t[ ] 和 d[ ] 分别记录在 i 时刻学生的**时间上限为i的数量**和**结束科目的数量**

 顺便记录一下最后一科的时间，作为枚举边界。

```cpp
for( int i = 1 ; i <= N ; ++i )m1 = (int)read() , t[ m1 ]++ ;
for( int i = 1 ; i <= M ; ++i )m1 = (int)read() , las = max( (ll)m1 , las ) , d[ m1 ]++ ;
```


 然后我们枚举时刻 i ，直接预处理出上述三个需要的数组。记录方法为先累加贡献值，再累加个数，自己想想其实很简单的。复杂度 O（n）。
 

```cpp
ll tot = 0 , val = 0 ;//∑C 
if( flag != 3 )
	for( int i = 1 ; i <= las ; ++i )
		val += tot*C , tot += t[ i ] , c[ i ] = val ;
tot = 0 , val = 0 ;
for( int i = 1 ; i <= las ; ++i )//A的上限 
	val += tot , tot += d[ i ] , used[ i ] = val ;
tot = 0 , val = 0 ;
for( int i = las ; i >= 1 ; --i )//需要提前的次数
	val += tot , tot += d[ i ] , cha[ i ] = val ;
```


2.预处理完成之后，我们枚举时间，求出**学生的不满意度和提前操作的不满意度**之和即可。

特殊点处理： 

1 2 点不能使用 A，B ，直接输出 c[ las ]

3 4 点不能使用 B ， 全部使用 A ， A不够直接 break

13 14 点不能预处理 C , 也不能使用 C ， 直接求出提前到最早时间要求处的答案即可。

**时间复杂度**
 
 综上所述，预处理和递推模拟都是严格 O(n)，而且**数据分治**，复杂度已经优化，在**数据更新**后20个点只跑了134ms，比大部分**数据更新前**的人都跑的快。
 
 ![](https://images.cnblogs.com/cnblogs_com/ssw02/1414861/o_sssss.PNG)

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define ll long long
const int MAXN = 100005 ;
inline ll read(){
	ll s=0 ; char g=getchar() ; while(g>'9'||g<'0')g=getchar() ;
	while(g>='0'&&g<='9')s=s*10+g-'0',g=getchar() ; return s ;
}
ll t[ MAXN ] , d[ MAXN ] , used[ MAXN ] , cha[ MAXN ] , c[ MAXN ] ;
ll A , B , C , N , M , ans , las ;//las记录最后一科出来的时间 
int  flag = 0 , flag2 = 0 ;
int check(){
    if( A < B )flag2 = 1 ;
	if( A == 1e9 && B == 1e9 )return 1 ;
	if( A != 1e9 && B == 1e9 )return 2 ;
	if( C == 1e16 )return 3 ;
	return 0 ;
} 
void  prepare(){
	ll tot = 0 , val = 0 ;//∑C 
	if( flag != 3 )
	    for( int i = 1 ; i <= las ; ++i )
		    val += tot*C , tot += t[ i ] , c[ i ] = val ;
	tot = 0 , val = 0 ;
	for( int i = 1 ; i <= las ; ++i )//A的上限 
	    val += tot , tot += d[ i ] , used[ i ] = val ;
	tot = 0 , val = 0 ;
	for( int i = las ; i >= 1 ; --i )
	    val += tot , tot += d[ i ] , cha[ i ] = val ;
}
void work(){
	ll now ; ans = c[ las ] ;
	for( int i = las ; i >= 1 ; --i ){
		now = c[ i ] ;
		if( flag2 ){//优先用A 
			if( used[ i ] >= cha[ i ] )now += cha[ i ]*A ;
			else now += used[ i ]*A + ( cha[ i ] - used[ i ] )*B ;
		}
		else
			now += cha[ i ]*B ;
		ans = min( ans , now ) ;
	}
	cout<<ans ;
}
void work2(){//仅使用 A C
	ll now ; ans = c[ las ] ;
	for( int i = las ; i >= 1 ; --i ){
		now = c[ i ] ;
		if( used[ i ] >= cha[ i ] )now += cha[ i ]*A ;
		else break ;
		ans = min( ans , now ) ;
	}
	cout<<ans ;
}
void work3(){//仅使用 A B 
	ans = 0LL ; //上限1e10
	ll fir = 0LL ; 
	for( int i = 1 ; i <= las ; ++i )if( t[ i ] ){ fir = i ; break ; }
	if( flag2 ){//优先用A 
			if( used[ fir ] >= cha[ fir ] )ans += cha[ fir ]*A ;
			else ans += used[ fir ]*A + ( cha[ fir ] - used[ fir ] )*B ;
		}
	else
		ans += cha[ fir ]*B ;
	cout<<ans ;
}
int main(){
	freopen("exam.in","r",stdin);
	freopen("exam.out","w",stdout);
	A = read() , B = read() , C = read() , N = read() , M = read() ;
	int m1 , m2 ;
	for( int i = 1 ; i <= N ; ++i )m1 = (int)read() , t[ m1 ]++ ;
	for( int i = 1 ; i <= M ; ++i )m1 = (int)read() , las = max( (ll)m1 , las ) , d[ m1 ]++ ;
	flag = check() ;
	prepare() ;
	if( flag == 1 ){cout<<c[ las ] ; return 0 ; }
	if( flag == 2 ){ work2() ; return 0 ; }
	if( flag == 3 ){ work3() ; return 0 ; }
	work() ; 
	return 0 ;
}
```

###如有不足，请大佬指出

---

## 作者：HiJ1m (赞：0)

**第二个题解，说一个三分的解法。**学习于CSDN的博主Ripped

不愉快度和时间是一个下凸函数(导函数递增)，于是可以用三分法缩小枚举的范围。

之后枚举出时间求出最小的不愉快度即可。

细节说明见代码注释↓↓





    
    
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define INF 9223372036854775807ll   //最大值
using namespace std;
unsigned long long A,B,C,Y1,Y2,ans;
int N,M,t[100017],b[100017];
unsigned long long l=INF,r,x1,x2;
unsigned long long calc1(int x)      //calc1这个函数计算出通过A.B操作把时间调到X的不愉快度 
{
    unsigned long long below=0,above=0;
    for(int i=1;i<=M;i++)
    {
        if(b[i]>=x)above+=b[i]-x;
        else below+=x-b[i];    
    }
    if(B>A)
    {
        if(below>=above)return (unsigned long long)above*A;
        else return (unsigned long long)below*A+(above-below)*B;      //A<B优先用A填补，再用B
    }
    else return (unsigned long long)above*B;    //B＜A 直接全部使用B
}
unsigned long long calc2(int x)        //这个函数算出学生们的不愉快度总和
{
    unsigned long long sum=0;
    for(int i=1;i<=N;i++)
    {    
        if(t[i]<x)sum+=(x-t[i])*C;
    }
    return sum;
}
int main()
{
    cin>>A>>B>>C>>N>>M;
    for(int i=1;i<=N;i++)
    {
        scanf("%d",&t[i]);
        l=min(l,(unsigned long long)t[i]);
        r=max(r,(unsigned long long)t[i]);           //存l,r
    }
    for(int i=1;i<=M;i++)scanf("%d",&b[i]);
    if(C==1e16){printf("%lld\n",calc1(l));return 0;}           //这里是个特判：由于题里面有两个点是C=1E16的，这种情况就是要使学生的不愉快度总和为0才能达到最优解，所以直接输出clac1(最前时间)
        while(r-l>5)                //三分缩小范围↓(三分法模板见洛谷P3382)
    {
        x1=(r-l)/3+l;
        x2=(r-l)/3*2+l;
        Y1=calc1(x1)+calc2(x1);
        Y2=calc1(x2)+calc2(x2);
        if(Y1>Y2)l=x1;
        else r=x2;
    }
    ans=calc1(l)+calc2(l);
    for(int i=l+1;i<=r;i++)                        //在上面求出的范围内枚举时间  求出最小值即可
        ans=min(calc1(i)+calc2(i),ans);
    printf("%lld\n",ans);
    system("pause");
    return 0;              //The End
}
```

---


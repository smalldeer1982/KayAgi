# [CQOI2013] 新Nim游戏

## 题目描述

传统的 Nim 游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。

本题的游戏稍微有些不同：在第一个回合中，双方可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。从第二个回合（又轮到第一个游戏者）开始，规则和 Nim 游戏一样。

如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq k \leq 100$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
6
5 5 6 6 5 5```

### 输出

```
21```

# 题解

## 作者：宁_缺 (赞：32)

貌似题解区的某几位dalao太巨了，寥寥几笔就写完了题解，然而我觉得那几篇实在太简略了些，于是便写了这篇题解

## [$\color{black}\text{原题链接}$](https://www.luogu.com.cn/problem/P4301)

~~相信你们都做过nim游戏的模板，知道先手的必胜/败条件~~

那么，本题中，先手要胜利，则必须让后手无论拿掉哪几堆都弄不出异或和为0的情况。显然，这要用到线性基。

在插入线性基时，如果没成功插入，即最后x=0，那么意味着会出现异或和为0的情况，这时就要把x取走。显然，~~聪明的~~先手一定必胜，所以这题输出-1是不可能得分的了，我们只用考虑如何让取走的数量最小。

这时我们就要用到贪心思想：从大到小来试，能插入就插入，不能则取走。

那为啥这样结果最小呢？

粗略的证明一下，因为异或是**不进位**加法，那么，如果不是从大到小，假设a^b^…=x(a≤b≤...≤x)，由于中途没有进位，因此，**a^b^…≤a+b+...**,所以显然取走x比取走那几堆更优。

如果并不是a≤b≤...≤x呢？排个序呗。

~~于是就大致的说明了为毛要这样贪心了。~~

**但显然这样是不严谨的。因此想看严谨的证明还请去看[Jaihk662大佬的文章](https://blog.csdn.net/Jaihk662/article/details/75050313)。**

代码如下：
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
#define LL long long
int n,a[101],d[31];LL ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	std::sort(a+1,a+n+1);
	for(int x=a[n];n;--n,x=a[n]){
		for(int j=30;j>=0;--j)
			if((x>>j)&1)
				if(d[j])x^=d[j];
				else{d[j]=x;break;}
		if(!x)ans+=a[n];
	}
	return printf("%lld\n",ans)*0;
}
```
_谢君曾共霜雪 不辞生死长约_

---

## 作者：龙神哈迪斯 (赞：20)

Sol
===

看就只有一篇题解，~~而且对结论证明的比较草率~~，那我就发篇题解吧

[更多优美体验戳我](https://blog.csdn.net/Zctoylm/article/details/79829686)

题目大意
---

第一轮为自定义游戏，取走若干堆石子，第二轮开始为Nim的游戏
(所以一定要审清楚题目)

题解
---
想必大家都知道Nim的游戏吧，如果不清楚结论的话，笔者顺便把Nim的游戏的结论也讲一下吧，方便大家把Nim的游戏也切掉

若干堆石子，每堆石子有若干颗石子，请问什么情况是先手必胜？
(~~貌似这个跟数学和博弈没什么关系~~)

如果初始状态下每堆石子数异或起来不为0的话，则先手必胜，反之后者必胜

证明如下:
首先我们将每堆石子数换算为二进制，位数$i$上为1我们则可以取走其${2}^{i}$个石子

1.若石子数异或和不为0，那么考虑如果先手能通过取石子数使石子数异或和为0的话，那么接下来要不就还存在石子数，要不就没有了，在没有的情况下先手获胜

2.若接下来还存在石子数，必定就还有位数上有1，又因为不能不取，所以在该堆取走若干颗石子后必将导致局面变为每堆石子数异或和不为0

3.接下来又变为第1步，继续考虑先手是否存在方案将石子数异或和为0，有一种简单想法，假设现在我们找到了在全局石堆上有一堆的石子位有最高位为1(就是别的石子堆没有这一位)，我们将最高位取走1后，考虑次高位，此时可能有别的石堆这一位上有1了，那么如果不算此位的话，可能其余位异或起来不为0，那么就从之前那一位上借来一个1使得该位异或起来为1，之后位数照然

4.第3方案是一定存在的，也就是一定存在该方案，因为此时局面异或起来是不为0的！你一定存在方案把它变为异或为0，就是按位取1就好了(不存在一个1的局面都不取的情况，因为那样局面就会是一定为0的)

5.综上，在Nim的游戏中若石子数异或和不为0则先手必胜

然后不就变得很简单了？(讲了这么就还没讲到重点)

Q:对于异或和？想到了什么

A:报告！线性基

在本题中，不能给后手任何让石子数异或为0的机会，所以在插入前先询问该数是否会让石子异或和变为0，若会，则把这堆棋子给拿掉，否则加入线性基里，这样后手无论如何都不能让石子异或和变为0了！(因为线性基里无论怎么搞异或和都不为0[若想观察更多优美性质戳我](https://blog.csdn.net/qaq__qaq/article/details/53812883))，然后先手就必胜了

值得吐嘈的是，先手一定会必胜，所以`puts("-1")`期望得分0

然后求最小值？Sort一遍就好了，按照权值从大到小排序，其实也是贪心的思想(若此处不懂，推荐一道好题[[BeiJing2011]元素](https://www.lydsy.com/JudgeOnline/problem.php?id=2460)，方便理解)

上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long
const int _=500;
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
int K,a[_];
bool cmp(int A,int B){return A>B;}
struct LB
{
	ll a[65],b[65];
	LB ()
		{
			memset(a,0,sizeof(a));
			memset(b,0,sizeof(b));
		}
	void Insert(ll x)
		{
			for(int i=60;i>=0;--i)
			{
				if(x&(1<<i))
				{
					if(!a[i])
					{a[i]=x;break;}
					x^=a[i];
				}
			}
		}
	bool Find(ll x)
		{
			for(int i=60;i>=0;--i)
			{
				if(x&(1<<i))
				{
					if(!a[i])
						break;
					x^=a[i];
				}
			}
			return x>0;
		}
};
int main()
{
	K=read();
	for(int i=1;i<=K;++i)
		a[i]=read();
	sort(a+1,a+1+K,cmp);
	ll ans=0;LB S;
	for(int i=1;i<=K;++i)
	{
		if(S.Find(a[i]))
			S.Insert(a[i]);
		else ans+=a[i];
	}
	cout<<ans<<endl;
	return 0;
}

```


---

## 作者：cmd2001 (赞：16)

线性基裸题

考虑什么情况下对手获胜:也就是他能在剩下的堆中构造出一个xor和为0的子集。

所以我们不能让他构造成功，也就是不能让线性基插满或存在某个值无法插入。

于是我们贪心从大数向小数考虑，如果这个数能被插入线性基则插入，否则我们必须一开始就把他拿走......

关于贪心的正确性?如果线性基内某个位置既能被小数占据，也能被大数占据，而我们放入的是大数。这保证我们的答案相对于插入小数的方案不劣的。

最后上代码:

```cpp
#include<cstdio>
#include<algorithm>
#include<functional>
const int maxn=1e2+1e1,maxl=32;

int in[maxn],n;
long long sum;

struct LinearBase {
    int dat[maxn];
    inline bool insert(int x) {
        for(int i=31;~i;i--)
            if( x & ( 1 << i ) ) {
                if( !dat[i] ) {
                    dat[i] = x;
                    return 1;
                } else x ^= dat[i];
            }
        return 0;
    }
}lb;

int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",in+i);
    std::sort(in+1,in+1+n,std::greater<int>());
    for(int i=1;i<=n;i++) if( !lb.insert(in[i]) ) sum += in[i];
    printf("%lld\n",sum);
    return 0;
}
```

我可是蒻省蒻校最蒻的蒟蒻......

---

## 作者：FxorG (赞：3)

## $ \text{Solution:}$

首先，nim游戏必败态为: $a_1 \ xor \ a_2 \ xor \ ...\ xor\ a_n=0$.

那么，只要我们异或出来的数为0了，说明我们必须加上它。

即 $ a_1 \ xor \ a_2 \ xor \ ... \ xor \ a_i=0$.

我们可以转变在第一回合取走 $a_i$，使得这样：

$ a_1 \ xor a_2 \ xor \ ... \ xor \ a_{i-1}=a_i$.

现在先手必胜了。

通过前面的推断，我们可以判断出我们需要一个查看当前这一个数去异或前面的数是否为0，也就是需要线性基维护。

那么如何让火柴总数尽可能少呢。

我们来看这个东西：

$ a_1 \ xor a_2 \ xor \ ... \ xor \ a_{i-1}=a_i$.

因为 xor 是不进位加法，我们可以得到

$ a_1 \ + a_2 \ + \ ... \ + \ a_{i-1} \ge a_i$.

但是又因为它们 xor 出来是等价的，这提醒我们从大到小排序再去做线性基即可。

## $\text{Code:}$

```cpp
#include <bits/stdc++.h>

#define N 102
#define ll long long

using namespace std;

int n,a[N],d[N];
ll ans;

bool cmp(int x,int y) {
	return x>y;
} 

signed main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+1+n,cmp); 
	for(int i=1;i<=n;i++) {
		int x=a[i];
		for(int j=30;j>=0;j--) {
			if((x>>j)&1) {
				if(d[j]) x^=d[j];
				else {
					d[j]=x; break;
				}
			}
		}
		if(!x) ans+=a[i];
	}
	printf("%lld",!ans?-1:ans);
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：2)

~~如果不是知道这题是线性基还真做不出来~~       

首先题意很明显，游戏为两轮特殊操作加 nim 游戏。          

nim 游戏我们知道怎么搞，就是把所有数按位异或起来看是不是 0 即可。     
首先我们的 A 肯定有必胜策略，这很简单，拿完 $n - 1$ 堆，然后第二轮让 B 空爆，第三轮取走完事。          

接着我们就是考虑怎么少取，首先我们第二轮肯定要踢给 B 一个集合，这个集合的子集无论怎么异或都不能为 0 ，所以说我们线性基维护，如果这个数不可以直接插入，那么我们肯定就不能选择这个数，因为线性基里面的数任意按位异或起来都不能为 0 ，我们可以用这种方式来判断当前的数能不能插入。       

接着由于要留下最多的柴，我们排个序倒着插入即可。         

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 105,LOG = 31;
int n,A[Len];
long long sum;
struct LinearBasis
{
	int a[LOG + 5];
	int tot;
	inline bool insert(int t)
	{
		for(int i = LOG ; i >= 0 ; i --)
		{
			if(!t) return false;
			if(!(t >> i & 1)) continue;
			if(a[i]) t ^= a[i];
			else {a[i] = t;return true;}
		}
		return false;
	}
}Basis;
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d",&A[i]);
		sum += A[i];
	}
	sort(A + 1 , A + 1 + n);
	for(int i = n ; i >= 1 ; i --) sum -= A[i] * Basis.insert(A[i]); 
	printf("%lld\n",sum);
	return 0;
}
```

---

## 作者：Durancer (赞：2)

#### 前言

考察线性基的性质，模板以及博弈论 $Nim$ 游戏的先手必赢和必输条件判定

#### 思路

首先，通过简单的了解博弈论可以知道一个定理，假设有 $k $ 堆石子，那么判定先手必胜的条件为 $a_1 \oplus a_2 \oplus…\oplus a_k \neq 0$

看这个题，经过前两轮的操作以后，就可以用上面的定理进行判定。那么如何来操作前两轮的数呢，考虑运用线性基

线性基有一个性质

>线性基没有异或和为 0 的子集。

那么可以得到，只要成功插入线性基中的一堆，可以不用被拿掉，那么反之，如果插入失败了，即到最后 $x=0$ 了那么这个时候就会出现异或和等于 $0$ 的情况，那么久必须要把这一堆拿出来

要找的是最小的拿出方案数，那么从大到小排序，先把大的插入进去，找小的即可

因为有了前两轮的铺垫，再加上~~先手特别的聪明~~，所以不会出现输的情况，一开始把可能会导致输的火柴堆都拿出来就好了

#### 代码

```
/*
	思路：首先根据博弈论的出来的结论：只要a1^a2^a3^……^ak！=0先手必赢
	那么可以根据这个运用线性基考虑插入
	如果插入失败，即最后x=0，那么会存在异或和等于0的情况，要删去 
*/
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long 
using namespace std;
const int N=1e2+9;
int pik[N];
int p[N];
int ans,k;
void linear_basis(int x,int poi)
{
	for(int i=32;i>=0;i--)
	{
		if(!(x>>i)) continue;
		if(!p[i])
		{
			p[i]=x;
			return;
		}
		x^=p[i];
	}
	if(x==0) ans+=pik[poi];
}
signed main()
{
	scanf("%lld",&k);
	for(int i=1;i<=k;i++)
		scanf("%lld",&pik[i]);
	sort(pik+1,pik+1+k);
	for(int i=k;i>=1;i--)
		linear_basis(pik[i],i);
	printf("%lld\n",ans); 
} 
```


---

## 作者：KaguyaH (赞：1)

[**题面传送门**](https://www.luogu.com.cn/problem/P4301)

# 题目分析

由 Nim 游戏的性质，我们发现，如果我们取完火柴后剩下的火柴堆集合中没有任何一个子集的异或和为 $0$，那么后手无论拿走哪集堆，剩余的异或和都不为 $0$，我们就必胜了。

于是，我们维护一个线性基，每次插入失败就更新答案。

那我们按照什么顺序插入呢？

介绍一种极其抽象的想法：我们抽象一点，直观感受一下，把火柴堆看成是边（可能是多条），然后异或和为 $0$ 的边连成环，但我们又不能要环，所以就是求最大生成树。然后我们使用 Kruskal 算法中对边大小排序这个思想，尽量向线性基内部插入大数，然后每次插入失败更新答案即可。

# Code

```cpp
# define _CRT_SECURE_NO_WARNINGS
# include <cstdio>
# include <queue>
using std::priority_queue;

typedef signed int D;
typedef short unsigned int HU;
typedef long unsigned int LU;
typedef long long unsigned int LLU;
enum Max { K = 100, MA = (const LU)1e9, LogMA = 30 };

class Basis {
	LU basis[LogMA];
public:
	Basis() {
		for (register HU i(0); i < LogMA; ++i) basis[i] = 0;
	}
	inline const bool insert(LU x) {
		for (register HU i(LogMA - 1); i < LogMA and x; --i) {
			if (x bitand 1 << i) {
				if (not basis[i]) {
					basis[i] = x;
					return true;
				}
				x xor_eq basis[i];
			}
		}
		return false;
	}
};

HU k;
priority_queue<LU> a;
Basis b;
LLU ans(0);

signed int main() {
	D t;
	t = scanf("%hu", &k);
	for (register HU i(0); i < k; ++i) {
		LU a_i;
		t = scanf("%lu", &a_i);
		a.push(a_i);
	}
	while (not a.empty()) {
		if (not b.insert(a.top())) ans += a.top();
		a.pop();
	}
	printf("%llu\n", ans);
	return 0;
}
```

---

## 作者：chenzida (赞：1)

## 题目大意：

[这道题原本的描述本来就没有废话](https://www.luogu.com.cn/problem/P4301)

## 思路解析：

这是我写的第一道线性基的题，那我就讲的详细一点吧。

### 首先，什么是线性基：

线性基是一个数的集合，任意一个序列都有至少提个线性基。

有一组数 $a_1,a_2...a_n$ 和线性基 $d_1,d_2...,d_m$，$d_i$ 表示**最高位 $1$ 在第 $i$ 位的数**。

### 线性基的作用

由于线性基值域与原数列值域相同的特点，可以用它来维护异或和。

### 线性基的性质

线性基有一下三大性质：

$1.$ 原序列里面的任意一个数都可以由线性基里面的一些数异或得到。

$2.$ 线性基里面的任意一些数异或起来都不能得到 $0$。

$3.$ 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的。

### 线性基的插入

看代码

```cpp
bool add(ll x)
{
	for(int i=30;i>=0;i--)
	{
		if((x>>i)&1)
		{
			if(d[i]) x^=d[i];
			else
			{
				d[i]=x;
				return 1;
			}
		}
	}
	return 0;
}
```

这样这个 $d$ 数组的性质就是若 $d[i]$ 不为 $0$，则 $(d[i])_2$ 的第 $d[i]$ 的第 $i+1$ 位为 $1$，并且没有更高位为 $1$ 了。

### 性质1的证明

如果有了前面讲的，设原数列有一个数 $x$，我们尝试用它来构造线性基，这样就会有两种可能。

$1.$ 不能成功插入线性基。

$2.$ 可以成功插入线性基。

接下来分两类讨论性质 $1$ 的证明

#### 不能成功插入线性基

如果是不能成功插入的话，那么一定是与性质 $2$ 相悖，所以就可以显然得出这个式子：
$$x\ xor\ d[a]\ xor\ d[b]\ xor\  ...=0$$
则可以推出
$$d[a]\ xor\ d[b]\ xor\ ...=x$$
所以如果 $x$ 不能插入线性基，一定是前面以及有一些数的异或和为 $x$。满足性质 $1$。

#### 能够成功插入线性基

假设这个数插入到了第 $i$ 个位置，则可以得出
$$x\ xor\ d[a]\ xor\ d[b]\ xor...=d[i]$$
能推出
$$d[i]\ xor\ d[a]\ xor\ d[b]\ xor...=x$$
所以这种情况也能满足性质 $1$。

所以性质 $1$ 得证。


### 性质2的证明

证法显然，但是还是说一下吧。

反证法：假设 $d[a]\ xor\ d[b]\ xor...\ d[i]=0$(假设 $d[i]$ 比 $d[a]$ 等晚入线性基)
则可以推出 $d[a]\ xor\ d[b]\ xor...=d[i]$，而这样根据入线性基方案，$d[i]$不可能入线性基，所以假设不成立，所以性质2得证。

### 性质3的证明

还是分类讨论

#### 如果序列中所有元素都被插入线性基中

由于所有元素都要入线性基，故不管用什么顺序都是一样的，所以就能保证最优性，即满足性质3.

#### 如果有元素没有被插入线性基中

设这个元素为 $x$，则一定满足一个 $d[a]\ xor\ d[b]\ xor\ d[c]=x$ 的式子，则我们改变一些顺序。（由于 $a,b,c$ 都是对称的，则只用考虑 $c$ 即可）

我们可以得到这个式子
$$d[a]\ xor\ d[b]\ xor\ x=d[c]$$
所以 $d[c]$ 就无法插入线性基了，所以总数还是一样的，所以改变顺序并不会改变插入数量，所以数量是一定的。性质3得证。

所以线性基就结束了，下面就要用这个知识点来做一道模板题了。

这道题怎么做呢？这道题和 $Nim$ 游戏很像，唯一的区别就是第一次和第二次可以随便取。所以我们只要解决这唯一的不同点也就解决这个问题了。

这道题要让取完之后无论怎么拿都不会出现异或和为 0 的情况，所以我们正好可以用线性基来维护，但是我们的入线性基的顺序是什么呢？

这里有个贪心，那就是说 $a\ xor\ b\ xor\ c...\leq a+b+c+...$，这个的证法显然我就不说了。

所以我们根据这个贪心，可以确定是要从大到小的顺序依次考虑入线性基，所以我们一开始就要排个序。

根据题意，如果入线性基成功，那就没有事了，但是如果失败就要统计上 $ans$ ，所以单独写一个入线性基 $add$ 的时候要定义的是 $bool$ 类型的函数，以便判断入线性基是否成功。

最后再考虑 $-1$ 的事情，可以构造出一种情况，无论如何先手也不会输，那就是取得只剩 1 堆，之后先手就直接去完这剩下的一堆即可，所以是不可能输出 $-1$ 的。

最后可以写出如下代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int NR=105;
int a[NR];
int d[NR];
ll ans;
bool add(ll x)
{
	for(int i=30;i>=0;i--)
	{
		if((x>>i)&1)
		{
			if(d[i]) x^=d[i];
			else
			{
				d[i]=x;
				return 1;
			}
		}
	}
	return 0;
}
bool cmp(int x,int y)
{
	return x>y;
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	int n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		bool flag=add(a[i]);
		if(!flag) ans+=a[i];
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Macarons (赞：1)

有点出乎意料的简单啊。。。

讲下我的思路。关于Nim博弈游戏有这样一个结论：a1^a2^...^an!=0，那么先手必胜，反之如果等于0，先手必败

有这样一个结论后，我们来从先手的角度看看。

如果我是先手，我一定不会给后手把剩余集合异或值改成0的机会（因为后手拿掉一些元素后可能把剩余集合的异或变成0，形成先手必败的局面）

所以，本题的思路就在这里了，，，取一个集合，使得剩下的集合无论怎么取，最终的异或值都是非0。

把能加进线性基的元素叫基元，不能加进去的叫外基元

现在你只要尽可能把大的数塞到基元里面），

而最终的答案就是剩下的外基元总和，，

因为对于后手而言，你留给他的是一个线性基集合，请问，你要怎么从线性基集合里面取一些数出来不能取完，而又保证剩下的所有元素异或为0？？？？）

至于那个题目中那个-1.。。我有点没搞清什么情况。。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int d[31];
ll ans=0;
const int mod=10086;
inline int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}
void insert(int px){
    int x=px;
    for(int i=30;i>=0;i--){
        if(!((1<<i)&x))continue;
        if(!d[i]){
            d[i]=x;
            break;
        }
        x^=d[i];
        if(x==0){
            ans+=px;
            break;
        }
    }
}
int a[101];
int main()
{
    int k=read();
    for(int i=1;i<=k;i++)
    {
        a[i]=read();
    }
    sort(a+1,a+1+k);
    for(int i=k;i>=1;i--)
    {
        insert(a[i]);
    }
    cout<<ans<<endl;
    return 0;
}

```


---

## 作者：smoothset (赞：0)

[使用CSDN食用效果更佳](https://blog.csdn.net/qq_43537070/article/details/106098868)
### 题意
给定$n$堆石子，两个人可以各取走任意堆石子，但不能取完，可以不取。接下来和$Nim$游戏规则一样，询问是否有先手必胜策略。
### 思路
关于一般$Nim$博弈游戏有这样一个结论：$a_1\oplus a_2\oplus ... \oplus a_n!=0$，那么先手必胜，反之如果等于0，先手必败
我们从先手的角度看：
**如果我是先手，我一定不会给后手把剩余集合异或值改成$0$的机会（因为后手拿掉一些元素后可能把剩余集合的异或变成$0$，形成先手必败的局面）**
有了这样的想法以后，我们就可以按照这个思想开始考虑做法了。
### 做法：
**因为要最小的可能值，所以我们先贪心按照从大到小排序，然后判断每一堆插入线性基后是否异或值为$0$，是就加到$ans$里面，不是就插入到线性基中。**
附上代码，简单易懂！
### 代码
```cpp
#include <cctype>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define ph puts("")
typedef long long ll;
template <class T>
void rd(T &x)
{
    x = 0;
    int f = 1;
    char c = getchar();
    while (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}
    while (isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
    x *= f;
}
template <class T>
void pt(T x)
{
    if (x < 0)
        putchar('-'), x = (~x) + 1;
    if (x > 9)
        pt(x / 10);
    putchar(x % 10 ^ 48);
}
const int N = 105;
int n, a[N], p[35];
void add(int x)
{
    for (int i = 30; ~i; i--)
        if (x & (1 << i))
        {
            if (!p[i])
            {
                p[i] = x;
                break;
            }
            x ^= p[i];
        }
    return;
}
int query(int x)
{
    for (int i = 30; ~i; i--)
        if (x & (1 << i))
            x ^= p[i];
    return x;
}
ll ans;
int main() 
{
    rd(n);
    for (int i = 1; i <= n; i++)
        rd(a[i]);
    sort(a + 1, a + n + 1);
    for (int i = n; i; i--)
        if (!query(a[i]))
            ans += a[i];
        else
            add(a[i]);
    pt(ans);
    return 0;
}
```
### end!

---

## 作者：Leap_Frog (赞：0)

# P4301[CQOI2013]新Nim游戏（题解）

这道题楼上与楼下的思路已经讲得很清楚了，我就是来贴一个史上最短代码QwQ。

具体看代码注释。（因为这道题与[P4570](https://www.luogu.org/problem/P4570)太像了）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;	//代码开始
const int N=100,Q=63;	//N表示数字个数范围
int n,ans=0,a[Q+5],t[N+5];	//t表示数字，a表示线性基
inline char cmp(int x,int y) {return x>y;}	//这个cmp刚开始忘记写了，导致全WA
inline char add(int x) {for(int i=Q;i>=0;i--) if(x&(1<<i)) {if(!a[i]) return a[i]=x,1;x^=a[i];}return 0;}	//线性基的插入和查找可以写在一起
signed main()
{
	scanf("%lld",&n),memset(a,0,sizeof(a));		//读入并初始化线性基
	for(int i=1;i<=n;i++) scanf("%lld",&t[i]);	//读入数据
	sort(t+1,t+n+1,cmp);	//排序，刚开始排错方向了
	for(int i=1;i<=n;i++) if(!add(t[i])) ans+=t[i];		//一个个插入线性基
	return printf("%lld\n",ans),0;		//输出答案并完美地结束
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[洛谷链接](https://www.luogu.org/problem/P4301)。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[BZOJ链接](https://www.lydsy.com/JudgeOnline/problem.php?id=3105)。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，先手肯定是有必胜策略的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（留一堆石子不取，其他的全部取完，然后后手就奈何不了了~~木哈哈哈哈哈~~）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，这或许不是最优方案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析题目要求，我们其实就是要给后手一个必败状态。也就是说，后手得到的状态要么没有后继状态，要么后继状态全是必胜态。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者，就相当于只留一堆石子；后者，就相当于后手得到的石子堆集合中没有任何一个子集的异或和为$0$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个数，我们把它转成一个二进制，比如$(5) _ {10}=(101) _ 2$。我们把它看做一个向量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在再来看一下对于后者得到的集合的限制，可以被描述为：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设后手得到的石子堆的数量为$m$，第$i$堆石子的数量为$a_i$，$\vec{p}$为一个随机$01$向量，$\sum_{i=1}^mp_i\not=0$。则——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle\left(\bigoplus_{i=1}^m p_i\times a_i\right)\ !=0$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你会想到什么呢？  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle\left(\sum_{i=1}^mq_i\vec{a_i} \right)!=0$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（$q$为一个随机向量，$\sum_{i=1}^mq_i\not=0$）  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线性无关的向量组！  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，给后手的石子堆的限制就是石子堆的必须在$\mod 2$的意义下线性无关（在$\mod2$的意义下，系数相当于取$0$或者$1$，异或相当于向量的加法）。那么后手得到的，就是原石子堆的一个极大线性无关组。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个怎么求？排序之后线性基上面贪心即可，如果当前的石子堆不能由线性基中的向量组合在一起，就把答案加上它并插入线性基。  
# 代码
```cpp
#include <cstdio>
#include <algorithm>

typedef long long LL;

const int MAXN = 105, MAXLOG = 35;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

int P[MAXLOG];
int a[MAXN];
int N;

void insert( int x )
{
	for( int i = 30 ; ~ i ; i -- )
	{
		if( x & ( 1 << i ) )
		{
			if( ! P[i] ) 
			{
				P[i] = x;
				return;
			}
			x ^= P[i];
		}
	}
}

bool chk( int x )
{
	for( int i = 30 ; ~ i ; i -- )
	{
		if( x & ( 1 << i ) )
		{
			x ^= P[i];
		}
	}
	return ! x;
}

int main()
{
	LL S = 0;
	read( N );
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( a[i] );
		S += a[i];
	}
	std :: sort( a + 1, a + 1 + N );
	LL res = 0;
	for( int i = N ; i >= 1 ; i -- )
	{
		if( ! chk( a[i] ) ) 
			res += a[i], insert( a[i] );
	}
	write( S - res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：溪水瑶 (赞：0)

显然第一步取走后留给对手的序列必须不存在子序列异或和为0。

数列的线性基就是最大的值域不含0的子序列，所以取走剩下的就可以了。

从大到小插入线性基，未插入的计入答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200],b[200],c[200];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)c[i]=a[i];
	long long ans=0;
	for(int i=n;i>=1;i--){
		for(int j=30;j>=0;j--)if(a[i]&(1<<j)){
			if(!b[j]){
				b[j]=a[i];
				break;
			}
			else a[i]^=b[j];
		}
		if(!a[i])ans+=c[i];
	}
	printf("%lld",ans);
	return 0;
}
```


---


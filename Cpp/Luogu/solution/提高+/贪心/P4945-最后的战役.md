# 最后的战役

## 题目背景

NOIP2018原创模拟题T5

NOIP2018原创模拟赛DAY2 T1

NOIP T1+ or T2-  难度

题目背景改编自小说《哈利波特与死亡圣器》

## 题目描述

**最后的战役打响了。**

哈利被宣告“死亡”，伏地魔带着他的部下准备进攻霍格沃茨。但是霍格沃茨有古老的魔法保护，他们必须先摧毁这些保护。魔法保护一共有$n$层，每一层保护有两个参数：$k,p$。其中k表示魔法的类型，p表示能量的大小。

伏地魔每秒都会穿过一层保护，他在第 $i$ 秒（到达了第 $i$ 层）他有以下选择：  


1.收集 $[1,i]$ 层魔法中魔法类型为 $x_i$ 的魔法能量

2.收集 $[1,i]$ 层中魔法能量最大那层的魔法能量

3.使用加倍魔法

对于上面三个选择，他每秒可以可以选择一个，并可能获得能量，对于不同的选择，获得的能量也不同：

对于1.获得$[1,i]$层中**所有魔法类型为$x_i$的**魔法能量（请结合样例1理解）

对于2.获得$[1,i]$中魔法能量最大的那一层的魔法能量

对于3.这一秒总共收集的能量不变（也就是这一秒不收集新的能量），但是下一秒获得的能量翻倍。**但是他不能连续使用加倍魔法**，而且他最多只能使用$m$次，**对于每一层的能量他都可以重复获取**

只有他通过了这$n$层保护，并获得了最大的魔法能量才有可能彻底摧毁霍格沃茨的魔法防御，可是巫师又是不擅长计算的。

于是，伏地魔找到了你，而你，作为精通计算机技术的麻瓜程序员，现在需要做的就是设计一个程序帮助伏地魔计算出他可以获得的最大的魔法能量的值。

最终的决战已经展开，魔法界的历史又翻过了一页……

## 说明/提示

**样例一解释：**

第一秒最多可以获得2经验值，第二秒最多可以获得3经验值，**因为第三秒可以收集魔法类型为1的能量，所以最多可以获得4能量值**，第四秒最多可以获得8经验值，所以选择在第三秒使用加倍魔法，共可以获得：$2+3+0+2*8=21$能量值

**数据范围：**

30%数据满足：$n<=100,m<=10$

50%数据满足：$n<=5,000,m<=20$

70%数据满足：$n,m<=2\times 10^4,m<=200$

100%数据满足：$n<=5\times 10^4,m<=500,0<p_i<=10^4,0<k_i<=10^9,0<x_i<=10^9$

**特殊约定：**

30%数据满足$m=0$

## 样例 #1

### 输入

```
4 1
1 2
2 3
1 2
3 8
3 2 1 3```

### 输出

```
21```

## 样例 #2

### 输入

```
8 3
1 2
2 5
3 2
2 3
1 4
1 6
2 2
3 3
1 3 2 1 4 5 2 1```

### 输出

```
57```

## 样例 #3

### 输入

```
10 3
9 9
8 8
5 7
6 6
5 5
5 5
3 3
2 2
1 1
9 9
1 2 3 5 5 5 6 7 8 9```

### 输出

```
124```

# 题解

## 作者：Math_rad_round (赞：11)

update: 修正代码错误


------------


**本题有两种不同做法，复杂度也不同。**

这道题明显在某秒取第 $ 1 $ 种还是第    $2 $ 种收集对其他秒没有影响，所以如果在某一秒要收集，那直接取能量最高的一种收集就可以。

操作 $1$ 可以先把 $k,p$ 离线记录下来，用离散化或者 $map $ 计算到这一层某种类型的收集量。操作 $2$ 很好处理。这样我们就可以设 $y[i]$ 为第 $i$ 秒收集时获得的能量。

这样我们把题目简化到只需处理第 $3$ 种操作，对于第三种操作，有两种解法。

### 方案一：DP

很容易想到，设 $f[i][j]$为第 $i$ 秒用了 $j$ 加倍收集的最大能量值。转移方程就是。

$$f[i][j]=\max(f[i-1][j]+y[i],f[i-2][j-1]+y[i]*2)$$

前一个是正常收集，后一个是翻倍。

时间复杂度和空间复杂度都是 $O(nm)$ ，这道题里如果极限数据可以爆 $int$，开 $longlong $就快要用完空间了，那有什么其他方法吗？

### 方案二：转化+贪心

这道题的题解中，有一个人睿智的提出了一种贪心方法：

如果一次加倍都不用，答案明显是 $\sum_{i=1}^{n}y[i]$ 所有数的和。

而在 $a$ 位置用加倍相当于损失了 $y[a]$ 但增加了 $y[a+1]$。

所以我们可以设 $t[i]$ 为 $y[i+1]-y[i]$ ，也就是 $i$ 位置用翻倍的贡献，但因为不能连用翻倍魔法，问题转化为：

**$n-1$ 个数 $t[i]$，最多取 $m$ 个不相邻的数，求所取数最大值。**

很可惜的是这位同学的贪心方法错误，这道题现在类似于 _[P1484](https://www.luogu.com.cn/problem/P1484)_ 正确方法是把这些数丢进优先队列，取出一个数时，将 **两边的数-这个数** 丢回队列。这样取出这个数等于放弃原来的数而取相邻的两个。详细解法见 _P1484_ 的题解区 _[链接](https://www.luogu.com.cn/blog/zhouzhuo/solution-p1484)_ 。

时间复杂度 $O((n+m)log\ n)$。空间则只有 $O(n)$  。                                                                                                                     

### 代码

**DP:**
```cpp
#include<iostream>
#include<map>
using namespace std;

long long f[50002][501];
long long y[50002];
long long a1[50002];
long long a2[50002];
map<int,long long> u;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a1[i]>>a2[i];
		y[i]=max(y[i-1],a2[i]);
	}	
	for(int i=1;i<=n;i++){
		int k;cin>>k;
		u[a1[i]]+=a2[i];
		y[i]=max(y[i],u[k]);
	}
	f[1][0]=y[1];
	for(int i=2;i<=n;i++){
		f[i][0]=f[i-1][0]+y[i];
		for(int j=1;j<=m;j++){
			f[i][j]=max(f[i-1][j]+y[i],f[i-2][j-1]+y[i]*2);
		}
	}
	long long ans=0;
	for(int i=0;i<=m;i++){
		ans=max(ans,f[n][i]);//不一定把m次用完
	}
	cout<<ans;
	return 0;
}
```


**转化贪心：**

```cpp
#include<iostream>
#include<map>
#include<queue>
using namespace std;
struct dui{
	int s,t;
};
bool operator < (dui a,dui b){
	return a.s<b.s;
}
priority_queue<dui> d;
long long y[50002];
long long a1[50002];
long long a2[50002];
long long t[50002];
bool q[50002];
int fr[50002],be[50002],no[50002];
map<int,long long> u;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a1[i]>>a2[i];
		y[i]=max(y[i-1],a2[i]);
	}	
	for(int i=1;i<=n;i++){
		int k;cin>>k;
		u[a1[i]]+=a2[i];
		y[i]=max(y[i],u[k]);
	}
	long long ans=y[1];
	for(int i=1;i<n;i++){
		ans+=y[i+1];//累加本来就有的
		t[i]=y[i+1]-y[i];
		fr[i]=i-1;be[i]=i+1;no[i]=t[i];
		d.push(dui{t[i],i});
	}
	no[0]=no[n]=0;be[n]=n;
	for(int i=0;i<m;i++){
		dui o=d.top();d.pop();int h=o.t;
		if(o.s<=0)break;//如果收益是负数自然就不需要用了
		if(q[h]==1){
			m++;continue;
		}
		q[fr[h]]=1;q[be[h]]=1;
		no[h]=no[fr[h]]+no[be[h]]-o.s;
		d.push(dui{no[h],h});
		fr[h]=fr[fr[h]];be[h]=be[be[h]];
		ans+=o.s;
	}
	cout<<ans;
	return 0;
}
```





---

## 作者：communist (赞：8)

发现看不懂出题人的题解（我好菜啊）

自己写一篇其他方法

比较简单的$DP$思路

### 状态定义：

前两个转移很好处理，第三个好像就不好办了

不妨暴力定义进状态里

设$dp[i][j]$表示前$i$秒用了$j$次第三种转移的最大能量和

### 转移：

三种转移

$(i'<i)$

$1,dp[i][j]=max(dp[i][j],dp[i-1][j]+max\left\{p[i']\right\})$

$2,dp[i][j]=max(dp[i][j],dp[i-1][j]+\sum_{k[i']=k[i]}p[i'])$

$3,dp[i][j]=max(dp[i][j],dp[i-2][j-1]+2*max(max\left\{p[i]\right\},\sum_{k[i']=k[i]}p[i']))$

考虑搞出来这两个东西

$1,max\left\{p[i']\right\}$

前缀最大值即可$O(1)$

$2,\sum_{k[i']=k[i]}p[i']$

我写的离散化然后每次用就是$O(1)$

$map$也可以，但是用$map$的话，切记，对于相同的$i$，上式的值是相同的，不要放到枚举$j$的内层循环了

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=50010;
int dp[maxn][510],n,m,k[maxn],p[maxn],x[maxn],mp[2*maxn],maxa,cnt,sum[2*maxn];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&k[i],&p[i]);
        mp[++cnt]=k[i];
    }
    for(int i=1;i<=n;i++)
        scanf("%d",&x[i]),mp[++cnt]=x[i];
    sort(mp+1,mp+cnt+1);
    cnt=unique(mp+1,mp+cnt+1)-mp-1;
    for(int i=1;i<=n;i++)
    {
        k[i]=lower_bound(mp+1,mp+cnt+1,k[i])-mp;
        x[i]=lower_bound(mp+1,mp+cnt+1,x[i])-mp;
    }
    for(int i=1;i<=n;i++)
    {
        maxa=max(maxa,p[i]),sum[k[i]]+=p[i];
        int tmp=max(maxa,sum[x[i]]);
        for(int j=0;j<=min(i,m);j++)
        {
            if(i>1&&j)
                dp[i][j]=max(dp[i][j],dp[i-2][j-1]+2*tmp);
            dp[i][j]=max(dp[i][j],dp[i-1][j]+tmp);
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++)
        ans=max(ans,dp[n][i]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Nemlit (赞：5)

听说本题正解是DP，但是貌似有别的做法。

这道题需要实现三个操作：

1.收集 $[1,i]$ 层魔法中魔法类型为 $x_i$的魔法能量

2.收集 $[1,i]$ 层中魔法能量最大那层的魔法能量

3.使用加倍魔法

第一个操作需要查找所有$x_i$类型的魔法，那么我们可以用一个数组记下来。但是我们发现$x_i$到了$10^9$级别，直接用数组空间显然会炸。但是我们也可以发现$n$非常小，所以我们考虑离散化，用$map$或排序去重均可。

第二个操作比较简单，只需要每一次新枚举一个元素就更新最大值即可

那么问题来了，第三个操作怎么办呢？显然我们可以用$DP$来实现，不过这样时间消耗至少是$O(nm)$，那有没有什么更快的方法呢？

我们可以用贪心来实现。

但是我们怎么贪心呢？

按照常规的思路，我们可以求出所有的值之后按照从小到大的顺序，再在最大的前面翻倍。但是这样是不是对的呢？？

我们来看一组反例：假设我们求出的答案为$1$ $7$ $9$，我们可以用一次翻倍，按照刚刚的贪心思路，我们要在$9$的前面翻倍，所以求出的答案是$1+9*2=19$，但是如果从$7$前面翻倍，那么答案就是$2*7+9=23$，所以刚刚的贪心是错误的

那么要怎么办呢？我们来分析一下式子。

如果用数学式子表示答案的话，那么不加操作$3$答案为$Ans=∑(ans[i])$，那如果我们在$j$处用操作$3$呢？$Ans=∑(ans[i])-a[j-1]+a[j]$，不难发现，我们用一次操作$3$，我们的收益为$ans[j]-ans[j-1]$，所以我们按照该项与前一项的差值进行排序，贪心即可。不算排序的话复杂度为$O(n)$

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline
#define inf 1234567890
il int read()
{
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
#define maxn 50005
#define maxm 505
struct wall
{
    int k,p,x;
}e[maxn];
struct lsh
{
    int num,map,pax;
}a[maxn<<1];
struct getans
{
    int data,num;
}d[maxn];
int n,m,ans[maxn],col,cnt,vis[maxn],Ans,V[maxn],maxx;
il bool cmp(lsh a,lsh b)
{
    return a.map<b.map;
}
il bool cmp1(getans a,getans b)
{
    return a.data>b.data;
}
int main()
{
    n=read(),m=read();
    for(re int i=1;i<=n;++i)
    {
        a[++cnt].map=read(),e[i].p=read(),a[cnt].num=i,a[cnt].pax=0;
    }
    for(re int i=1;i<=n;++i)
    {
        a[++cnt].map=read(),a[cnt].num=i,a[cnt].pax=1;
    }//离散化，把所有的x值存入map中
    sort(a+1,a+cnt+1,cmp);
    for(re int i=1;i<=cnt;++i)
    {
        if(a[i].map!=a[i-1].map)
        {
            ++col;
        }
        (!a[i].pax?e[a[i].num].k:e[a[i].num].x)=col;
    }//去重
    Ans=ans[1]=maxx=vis[e[1].k]=e[1].p;//这里要注意，第一个点显然不能被加倍，所以我们要特判一下
    for(re int i=2;i<=n;++i)
    {
        maxx=max(maxx,e[i].p);//操作2实现
        vis[e[i].k]+=e[i].p;//操作1实现
        ans[i]=max(maxx,vis[e[i].x]);//求出答案，两种方案的较优值
        Ans+=ans[i];//先算出所有ans的和
        d[i].data=ans[i]-ans[i-1],d[i].num=i;//算出差值
    }
    sort(d+1,d+n+1,cmp1);
    for(re int i=1,j=1;j<=m&&i<=n;++i)
    {
        if(d[i].data<=0) break;//因为差值排好了序，所以如果一个点与前面一项的差值小于0，则肯定会带来“负面影响”，所以直接break
        if(!V[d[i].num]&&!V[d[i].num-1])
        {
            Ans+=d[i].data;
            V[d[i].num]=V[d[i].num-1]=1;//这里注意前后两项都要标记
            ++j;
        }
    }
    printf("%d",Ans);
    return 0;
}
```

---

## 作者：Voldermod (赞：4)

考察知识：map，动态规划

算法难度：XXX+ 实现难度：XXX

这道题**有些贪心并不是完美解法**，但是数据为随机生成的，所以得分概率非常大。

Hack数据：

4 2  
1 1  
2 3  
3 6  
4 8  
1 2 3 4

标程输出：22 贪心输出：21

---

分析：

首先，我们要解决操作2，如果暴力枚举时间复杂度为$O(n^2)$。

其实吧，我们直接用map优化就可以了，时间复杂度$O(nlogn)$：

```cpp
    for(int i=1;i<=n;i++) P[i]=max(P[i-1],p[i]);//求最大值
    for(int i=1;i<=n;i++){
    	mp[k[i]]+=p[i];//在这里求和
        P[i]=max(mp[x[i]],P[i]);
    }
```

在处理了伏地魔在$[1,n]$每一步可以获得的最大魔法能量之后（记为$P[i]$，记$\sum P_i$为SUM），我们就可以采取动态规划了：

定义$f(i,j)$：表示在$[1,i]$ 秒中在$i$秒使用了魔法，且有$j$ 个时间段使用了魔法，可以得到的最大能量值

边界：$f(i,1)=SUM-P[i]+P[i+1]$

状态转移：$f(i,j)=max\left \{ f(k,j-1)-P[i]+P[i+1] \right \}\,\,\,\, 0<k<i-1$

状态转移方程的实现还是要稍微处理一下，直接实现会超时：
```cpp
    for(int i=1;i<=n;i++)//处理边界
        f[i][1]=SUM-P[i]+P[i+1],
        ans=max(ans,f[i][1]);
    for(int j=2;j<=m;j++){
        for(int k=1;k<=n;k++) T[k]=max(T[k-1],f[k][j-1]);//预处理
        for(int i=2*j-1;i<=n;i++)
            f[i][j]=T[i-2]-P[i]+P[i+1],
            ans=max(ans,f[i][j]);
    }
```
好了，这道题我们就做出来了，理论时间复杂度：，但是时间效率不是很高，面对最大数据需要近900ms。

---

原文：[【洛谷】NOIP2018原创模拟赛DAY2题解](https://blog.csdn.net/Hi_KER/article/details/82820861 )

---

## 作者：HiJ1m (赞：3)

提供一种空间上的小优化，可以省一维数组，

100MB->1MB

f[i][j][k]表示 到第i个 用了j次魔法 k是0或1表示上次是否使用魔法

这样的话空间是2NM

由于第i个只能从第i-1个更新 所以i那一维可以改成滚动数组 √

核心状态转移方程
（val是当前 操作1和操作2的 最大值 在计算过程中累加即可         P.S.所有的魔法种类要先离散化）

```cpp
f[i][j][0]=f[i^1][j][0]+val
f[i][j][0]=f[i^1][j][1]+val*2
f[i][j+1][1]=f[i^1][j][0]
```



---

## 作者：NightTide (赞：2)

## PART 0：前排警告
**这篇题解并没有讲解思路，而是和大家分享一下我的两个错误，这两个错误都比较难以发现，并且对答案有很大的影响。**

如果大家想要看解题思路，我推荐大家去看[这篇题解](https://www.luogu.com.cn/blog/math-rad-round/p4945-zui-hou-di-zhan-yi-ti-xie)，这位大佬讲得比较详细，而且有两种方法，一种是 DP，还有一种是贪心。像我这种蒟蒻只能冒着爆空间的风险去写 DP（~~而且还错了~~）。

## PART 1：错误的写法
### 错误一（样例都过不了的那种）
对于选择 $1$ 的计算，应该有很多人放在了读入护罩的数据哪里，但其实这是错的，应该在后面读入 $x$ 的时候再计算。为什么呢？仔细看题目：

**对于1.获得 $[1,i]$ 层中所有魔法类型为 $x_i$ 的魔法能量**

所获得的是前 $i$ 层的能量，因此，第一层只能获得第一层的种类为 $x_1$ 能量,而后面出现的该类型的能量则是不能算入的。如果在开始的时候就算好了的话，就会算上 $i$ 层以后的该类型的能量，那么所得出来的能量和势必会更大，因此答案也很有可能变大。下面是错误的代码和正确的代码的比较，大家看一下：

这是错误的。
```cpp
for(int i=1;i<=n;i++){
	scanf("%lld%lld",&s[i].k,&s[i].p);
	maxs[i]=max(maxs[i-1],s[i].p);
	sum[s[i].k]+=s[i].p;//这里
}
for(int i=1,k;i<=n;i++){
	scanf("%d",&k);
	maxs[i]=max(maxs[i],sum[k]);
}
```
这是正确的。
```cpp
for(int i=1;i<=n;i++){
	scanf("%lld%lld",&s[i].k,&s[i].p);
	maxs[i]=max(maxs[i-1],s[i].p);
}
for(int i=1,k;i<=n;i++){
	scanf("%d",&k);
	sum[s[i].k]+=s[i].p;//现在它在这里
	maxs[i]=max(maxs[i],sum[k]);
}
```
### 错误2（有 70pts 估计是因为数据太弱了）
最后一段的 DP，有很多人也许不会给 $[1][0]$ 的答案特意赋值，直接放到循环里，就像下面这样：

把这段代码：
```cpp
dp[1][0]=maxs[1];
for(int i=2;i<=n;i++){
	dp[i][0]=dp[i-1][0]+maxs[i];
		-----这里未完待续-----
	}
}
```
换成这段：
```cpp
for(int i=1;i<=n;i++){
	dp[i][0]=dp[i-1][0]+maxs[i];
		-----这里未完待续-----
	}
}
```
放在平常，这肯定是没有任何问题的，因为 $dp[0][0]$ 的值就是 $0$,加上 $maxs[1]$ 其实就相当于把 $maxs[1]$ 的值赋给了 $dp[0][1]$，仅仅看这一段问题确实是没有问题的，但是再加上下面一段的代码后，就会出很大的问题了。

```cpp
for(int j=1;j<=m;j++){
	dp[i][j]=max(dp[i-1][j]+maxs[i],dp[i-2][j-1]+maxs[i]*2);
}
```
这是 DP 的状态转移方程的实现，我们看到后面调用了 $dp[i-2][j-1]$，如果 $i$ 从 $1$ 开始的话，那么就会调用到 $dp[-1][0]$，很明显，这里会有运行错误（~~但是我只是 WA，而且有 70 分，应该是我福大命大~~），因此，上面的改法是行不通的。上面有代码，但是为了好对比，我还是把代码在放一下吧。

错误代码：
```cpp
for(int i=1;i<=n;i++){
	dp[i][0]=dp[i-1][0]+maxs[i];
	for(int j=1;j<=m;j++){
		dp[i][j]=max(dp[i-1][j]+maxs[i],dp[i-2][j-1]+maxs[i]*2);
	}
}
```
正确代码：
```cpp
dp[1][0]=maxs[1];
for(int i=2;i<=n;i++){
	dp[i][0]=dp[i-1][0]+maxs[i];
	for(int j=1;j<=m;j++){
		dp[i][j]=max(dp[i-1][j]+maxs[i],dp[i-2][j-1]+maxs[i]*2);
	}
}
```
## PART 2：完整 AC 代码
上面是两个比较容易忽略的错误，接下来给大家看 AC 代码，上面讲的错误点都标在里面了，大家可以对照着看一下。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct shield{
	long long k;
	long long p;
};

shield s[50010];
long long maxs[50010],dp[50010][510],ans;
long long n,m;
map<int,long long> sum;

int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&s[i].k,&s[i].p);
		maxs[i]=max(maxs[i-1],s[i].p);
	}
	for(int i=1,k;i<=n;i++){
		scanf("%d",&k);
		sum[s[i].k]+=s[i].p;//错点1
		maxs[i]=max(maxs[i],sum[k]);
	}
	dp[1][0]=maxs[1];//错点2
	for(int i=2;i<=n;i++){
		dp[i][0]=dp[i-1][0]+maxs[i];
		for(int j=1;j<=m;j++){
			dp[i][j]=max(dp[i-1][j]+maxs[i],dp[i-2][j-1]+maxs[i]*2);
		}
	}
	for(int i=0;i<=m;i++){
		ans=max(ans,dp[n][i]);
	}
	printf("%lld\n",ans);
	
	return 0;
}
```
广告推销：安利一下我的[个人博客](https://www.luogu.com.cn/blog/Michaela-chr/)，大佬自动略过，不喜勿喷

---

## 作者：King丨帝御威 (赞：1)

这道题目，第一眼，看数据范围，然后发现数据范围太大了，足有1e9,数组都开不下的有没有！？！那么，自然而然的就想到要离散化，想出的离散化，那么30分的思路就有了吧，建议用结构体存储变量，离散化之后枚举第i层然后记录当前种类含有的能量值，然后记录最大值，每次加两者中的最大值，不考虑加倍魔法的情况，于是，便有了下面的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 50001
using namespace std;
inline int qread()      //快读,可以不用。
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) num=num*10+c-'0';
    return num*f;
}
struct node
{
    int k,p;
}e[maxn];                  //k表示种类，p为能量。
int n,ans,num,maxx=-1,m,b[maxn],s[maxn],mf[maxn];
int main()
{
    n=qread(),m=qread();
    for(int i=1;i<=n;++i)     
    {
        e[i].k=qread(),e[i].p=qread();
        b[++num]=e[i].k;
    }
    for(int i=1;i<=n;++i) 
    {
        s[i]=qread();
        b[++num]=s[i];
    }
    sort(b+1,b+num+1);
    int len=unique(b+1,b+num+1)-b-1;   
    for(int i=1;i<=n;++i)          
    {
        e[i].k=lower_bound(b+1,b+1+len,e[i].k)-b;
        s[i]=lower_bound(b+1,b+1+len,s[i])-b;  //以上为离散化！
    }
    for(int i=1;i<=n;++i)
    {
        mf[e[i].k]+=e[i].p;
        maxx=max(maxx,e[i].p);
        ans+=max(mf[s[i]],maxx);   //记录ans即可。
    }
    cout<<ans<<'\n';
    return 0;
}
```

大家在看正解思路之前，务必先完全看懂30分思路和代码！！！

有了上面的30分思路后，我们就只需要再考虑用加倍魔法的情况，那么用f[i][j]表示到了第i层，已经用了j次魔法获得的最大能量值，然后用zrj表示上述30分做法中的最大值，然后就有：

### f[i][j]=max(f[i][j],f[i-1][j]+zrj);

这是第i次没有使用加倍魔法时的转移方程，然后使用了的话，就是……

### f[i][j]=max(f[i][j],f[i-2][j-1]+2*zrj);
然后就有了正解代码(QwQ)：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 50001
using namespace std;
inline int qread()
{
    char c=getchar();int num=0,f=1;
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) num=num*10+c-'0';
    return num*f;
}
struct node
{
    int k,p;
}e[maxn];
int n,num,maxx=-1,m,b[maxn<<1],zrj,s[maxn],mf[maxn],f[maxn][501];
int main()
{
    n=qread(),m=qread();
    for(int i=1;i<=n;++i)
    {
        e[i].k=qread(),e[i].p=qread();
        b[++num]=e[i].k;
    }
    for(int i=1;i<=n;++i) 
    {
        s[i]=qread();
        b[++num]=s[i];
    }
    sort(b+1,b+num+1);
    int len=unique(b+1,b+num+1)-b-1;
    for(int i=1;i<=n;++i)
    {
        e[i].k=lower_bound(b+1,b+1+len,e[i].k)-b;
        s[i]=lower_bound(b+1,b+1+len,s[i])-b;
    }
    for(int i=1;i<=n;++i)
    {
        mf[e[i].k]+=e[i].p;
        maxx=max(maxx,e[i].p);
        zrj=max(mf[s[i]],maxx);
        for(int j=0;j<=m;++j)
        {
            f[i][j]=max(f[i][j],f[i-1][j]+zrj);
            if(j>=1&&i>=2) f[i][j]=max(f[i][j],f[i-2][j-1]+2*zrj);
        }
    }
    cout<<f[n][m]<<'\n';
    return 0;
}
```

希望这篇题解对大家能有所帮助！！

---

## 作者：nao_nao (赞：0)

此题就是一道动态规划题，其他题解讲的非常好了。

核心代码如下：
```cpp
int tmp = max(maxn,vis[x[i]]);
		
for(int j = 0;j <= min(m,i);j ++){
	dp[i][j] = max(dp[i][j],dp[i-1][j]+tmp);
	if(i > 1 && j) dp[i][j] = max(dp[i][j],dp[i-2][j-1]+tmp*2);
}
```

## 15分刷屏的同学看过来！

由于此题中 x 数组与 k 数组并不能完全对应上，因此在离散化的时候要把 x 和 k 一起离散化。否则的话如果有 x 中元素不属于 k ，则在取此元素离散化之后的值的话会出现问题。

我的离散化：

```cpp
for(int i = 1;i <= n;i ++){
	scanf("%d %d",&k[i],&p[i]);
	que[++cnt] = k[i];
}
		
for(int i = 1;i <= n;i ++){
	scanf("%d",&arr[i]);
	que[++cnt] = arr[i];	
}
sort(que+1,que+1+cnt);
len = unique(que+1,que+cnt+1)-que-1;
for(int i = 1;i <= n;i ++){
	s[i] = lower_bound(que + 1, que + len + 1, k[i]) - que;
	x[i] = lower_bound(que + 1, que + len + 1,arr[i]) - que;
}
```

其中 que 数组的长度不是 n ，而应该是 2n 。

#### 改完离散化却得了70分的同学看过来：
 
因为 que 数组大小为 2n，所以他需要开到$1e5$，而不是$5e4$。



---

## 作者：risingstar (赞：0)

这题dp思路还是比较简单的，蒟蒻的dp转移方程和其它人差不多，这里就不说了。但由于一开始蒟蒻没看清楚数据范围，写完了一提交发现只有75分，5个点RE。一看数据范围$10^9$，才发现此题需要离散化。

然而蒟蒻不会C++，用不了离散化，也用不了map,之前也没遇到要离散化的题,思考此题时一开始也没想到用排序、去重、二分的方法解决。于是就灵机一动使
用了最近刚学的01trie 来进行了一波伪map。虽然01trie的空间消耗也比较大，但还是能没有多大问题跑完此题。

AC代码如下：
```
#include<stdio.h> 
#define fa(x) x>>1
#define max(x,y) x>y?x:y
#define min(x,y) x<y?x:y
struct T{
	int ch[2];
	int val;
};
struct T t[1000010];
int tot,head;
int dp[50010][510];
int k[50010],p[50010],x[50010];
int map1[50010],map2[50010],sum[50010];
int qu[100001];
void update(int i)//更新二叉堆
{
	int f=fa(i);
	if(f>=1&&qu[f]<qu[i]){
		int temp=qu[i];
		qu[i]=qu[f];
		qu[f]=temp;
		update(f);
	}
}
int insert(int x) //建立01trie，并返回叶子节点val值
{
	int u=0,v;
	for(int i=31;i>=0;i--){
		v=(x>>i)&1;
		if(!t[u].ch[v]){
			t[u].ch[v]=++head;
		}
		u=t[u].ch[v];
	}
	if(!t[u].val)t[u].val=++tot;
	return t[u].val;
} 
int query(int x)//查询叶子节点val值
{
	int u=0,v;
	for(int i=31;i>=0;i--){
		v=(x>>i)&1;
		u=t[u].ch[v];
	}
	return t[u].val;
}
int main()
{
	int n,m,ma,tot1;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&k[i],&p[i]);
		map1[i]=insert(k[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&x[i]);
		map2[i]=query(x[i]);
	} 
	for(int i=1;i<=n;i++){
		qu[++tot1]=p[i];
		update(tot1);
		sum[map1[i]]+=p[i];
		ma=max(qu[1],sum[map2[i]]);
		int mi=min(i,m);
		for(int j=0;j<=mi;j++){
			dp[i][j]=dp[i-1][j]+ma;
			if(i>=2&&j>=1)dp[i][j]=max(dp[i][j],dp[i-2][j-1]+2*ma);
		}
	}
	printf("%d",dp[n][m]);
}
```

---


# 「Wdoi-1」托卡马克

## 题目背景

今天的旧地狱依然核平，没有丝毫的波澜。

## 题目描述

阿空在一次实验中意外失控，导致炽热的托卡马克上出现了 $n$ 处破损，为了防止八咫乌的力量彻底释放影响地面世界，觉决定修复托卡马克。

阿空的托卡马克可抽象地理解为一条直线，以阿空为原点，这些破损位置的坐标分别为 $x_1,x_2,\ldots ,x_n$。

- 觉不希望消耗太多力量，所以她只会在这 $n$ 处破损中选择 $m$ 处进行修复。

- 为了防止破损处发生泄漏，觉会在选择的 $m$ 处破损间**两两连接**一条通道。

- 一条连接 $x_i$ 与 $x_j$ 处的通道的费用为 $\left\vert x_i - x_j \right\vert$，即两点间的直线距离，而一个方案的总花费被定义为所有通道的费用之和。

觉当然知道有很多修复 $m$ 处破损的方案，但她现在只想知道：在所有合法方案中，总花费为**严格**第 $k$ 大的方案是什么。

严格第 $k$ 大即不存在并列情况的第 $k$ 大方案。

由于觉拥有读心的能力，你只需要输出该方案的总花费即可。

若不存在符合要求的方案，输出 `-1`。

## 说明/提示

**【样例解释】**

- 对于样例一，共有 $6$ 种方案，分别为：

   - $(26,1)$，总费用 $25$。

   - $(26,21)$，总费用 $5$。

   - $(26,8)$，总费用 $18$。

   - $(1,21)$，总费用 $20$。

   - $(1,8)$，总费用 $7$。

   - $(21,8)$，总费用 $13$。

    显然，严格第二大的花费是 $20$。

- 对于样例二，共有 $1$ 种方案，分别为：

    - $(1,5)$，总费用 $4$。

    显然，不存在严格第二大的花费，答案为 `-1`。

----------------

**【数据范围】**

**本题采用捆绑测试。**

- 对于 $100\%$ 的数据：$1 \le n,m \le 3 \times 10 ^ 5$，$1 \le k \le 2$，$0 \le \left\vert x_i \right\vert \le 10 ^ 8$，$2 \mid m$，$m \le n$。

- **详细的数据范围：**

    Subtask 编号 | $n \le$ |  特殊性质 | 分值
    :-: | :-: |  :-: | :-: 
   $1$ | $20$ | $m \le 4$ |  $16$  
   $2$ | $35$ | $1 \le x_i \le 7$ 且 $k = 1$ | $9$
   $3$ | $35$ | $1 \le x_i \le 7$ | $9$
   $4$ | $100$ | $k = 1$ | $16$
   $5$ | $100$ | 无 | $16$
   $6$ | $3 \times 10 ^ 5$ |  $k = 1$ | $17$
   $7$ | $3 \times 10 ^ 5$ |  无 | $17$

## 样例 #1

### 输入

```
4 2 2
26 1 21 8 ```

### 输出

```
20```

## 样例 #2

### 输入

```
2 2 2
1 5```

### 输出

```
-1```

# 题解

## 作者：Mophie (赞：13)

首先这道题真的很毒瘤，很毒瘤……我在考试时WA了33次（~~悲壮啊~~）

这道题需要考虑的细节挺多，我认为是一道绿题到蓝题的难度吧。

接下来，就来看看我的心路历程吧。。。（下面题解用词不当请见谅）

$$Start$$

## Part1:看到这道题时的想法

这道题问的是总花费最大和第二大（我一开始看到k大有点慌……结果k<=2)

那奔着从简单到难的想法，先开始考虑最大值。

首先，抓住一个关键词：**2|m**

这说明我只能够取偶数条路

那现在，就拿m=6举个栗子：

设端点为1~6，则我们可以得到：

所有距离=（1，2）+（1，3）+（1，4）+（1，5）+（1，6）+（2，3）+（2，4）+（2，5）+（2，6）+（3，4）+（3，5）+（3，6）+（4，5）+（4，6）+（5，6）=（（1，2）+（2，6））+（（1，3）+（3，6））+（（1，4）+（4，6））+（（1，5）+（5，6））+（1，6）+（（2，3）+（3，5））+（（2，4）+（4，5））+（2，5）+（3，4）=5（1，6）+3（2，5）+（3，4）

然后我们会吃惊的发现，竟然系数是等差数列！还是奇数等差数列!

**这适不适用于所有情况呢？**

其实这十分好想，比如说有（1，6),我就要一边的端点是1，一边的端点6，而刚好端点不同可以一一配对，而且也恰好将每条含有1或6的边全部用完，都可以配成$m-1$个对，所以不需再考虑1，6，只需考虑2，3，4，5，以此类推。

所以我们得到了这个看起来很漂亮的式子。既然得到了这个柿子，那有什么用呢？

**其实得到了这个柿子，$k=1$就已经做完了。**

为什么呢？

其实十分简单。你思考一下，就会很轻松的发现：

**肯定从两端开始选喽**

因为选两端的话，可以（1，m）,（2，m-1）……都取到最大值

这还是十分明显的。

成功拿到42分！

很好，目前为止一切顺利

（~~来吧，给自己鼓鼓掌吧~~）

## Part2.推第二大

~~毒瘤开始~~

前面我相信大部分人都打出来了

但关键问题在于——第二大肿么推？

**其实很简单——把最靠中间的往中间移一格即可。**

那问题来了——Why？

首先，动他们两边的就必须要动最中间的。

那最中间的至少要往中间移一格，那么中间的和这个方案一样，**两边的减小了**，所以成立。

那么-1呢？

他说了没有可能，那么就是当k=2时且m=n嘛。

你自信的交了上去，看见一只只绿鸟亮起十分激动。

结果冒出了零星的几点红色——42

~~捆绑测试最烦了~~

你脑子里可能会闪过的一个想法——是不是数据有点问题？

我一开始也是这么想的，但看已经有5个大佬AC，就知道没问题。

我再度审视自己的证明过程，后来举了几个例子后就知道了。

### Wrong 1:谁告诉你只有m=n，k=2时才是-1？

我仔细的再看了这个题面，把视线聚焦在了两个字：

#### 严格

第二大，严格，我仿佛知道了什么：要是全是第一大，会怎样？

那怎么才会做到呢？

全部相等不就好了？

所以这个地方需要特判，特判这个情况。

你一边骂骂咧咧的说数据恶心，出这么多-1，一边又交了上去——

哎，几只红鸟变绿了，但依然是42……

我今天就跟42过不去了……

**加油吧，继续努力……**

### Wrong 2:貌似$k=2$的过程有点毛病……

再认认真真的看来一遍我的证明。

突然想到了什么——

万一我两个选的数一样肿么办？

举了个例子发现——那就继续往前选呗

哎，对哎，于是我立马付出了行动。

1分钟敲好了代码

满怀期待的看着评测结果

结果Subtesk1&2全过，你在想：哎，总算过了……

结果……

![我太难了](https://cdn.luogu.com.cn/upload/image_hosting/gc19hsoy.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

58……

至少也说的过去了嘛……

是，吗……

**满怀绝望也要加油啊！**

**Wrong 3:Wrong 2的延伸**

结果你突然灵机一动，想到一个奇怪的数据：
```
8 6 2

5 6 6 6 6 6 7 8
```
结果发现最终的答案是错误的。

Wrong answer:9

correct answer:5（自行手推）

然后你才发现——万一到对面时依然相同，那我这个数又不能换到对面去。

那肿么办呢？

只要把从中间往外延伸第一个跳出这个的，然后变为和那个数相同的不就好了？

比如说，在这个样例中就是把7换成6或者5换成6就好了。

公式自己推问题应该不大，下面注释里也写了。

那接下来看代码，好好理解一下这道好题吧。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
inline long long read()
{
	long long sum=0,naga=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')naga=-1;ch=getchar();}
	while(ch<='9'&&ch>='0')sum=sum*10+ch-'0',ch=getchar();
	return sum*naga;
}//快读 
long long n,m,k,taxi,a[300009];
int main()
{
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sort(a+1,a+n+1);//排序后从两端收缩 
	if((m==n||a[1]==a[n])&&k==2)
	{
		cout<<-1<<endl;
		return 0;
	}
	long long now=1,cnt=m-1,ans=0;//now记录到第几个点，cnt记录要乘的数，ans统计答案 
	while(cnt>0)//乘积大于零就不断加上去 
	{
		ans+=(a[n-now+1]-a[now])*cnt;
		cnt-=2,now++;
	}
	long long l=m/2,r=n-m/2+1;
	if(k==1)cout<<ans<<endl;//最大值 
	else
	{
		long long r1=r,l1=l,L=0,R=0;
		while(a[r1]==a[r]&&r1>1)r1--;//找最靠左的与右边相同的 
		while(a[l1]==a[l]&&l1<n)l1++;//同上 
		if(r1<=l)L=(2*(l-r1)+1)*(a[l]-a[r1]);//减去失去了的差值和他会做的贡献 
		else L=a[l1]-a[l];//否则就当是中间的直接减掉 
		if(l1>=r)R=(2*(l1-r)+1)*(a[l1]-a[r]); 
		else R=a[r]-a[r1];//同上 
		ans=max(ans-L,ans-R);//最大是ans,那么第二大就是两种方法的最大值 
		cout<<ans<<endl;
	}
	return 0;//完美，收工 
}
```
#### 最后，再小声BB一句：

我好像是跑的最快的哎（应该是加了快读的缘故……）

---

## 作者：xcxc82 (赞：5)

# P6524 「Wdoi-1」托卡马克 题解


先前排声明一下,蒟蒻刚学OI没多久,而且是自学的,所以写的可能比较~~sb+累赘+表达不清楚~~

大致思路和上面那位dalao的差不多,有个错误也是看了上面那位dalao的题解才发现的qwq

## **大致题意**

在**n**个点中选**m**个点进行**两两相连**,两个点相连所产生的费用为两点距离之差的绝对值
求**严格第k大费用值(即不存在并列情况的第 k 大方案）**

## 思路
先来看一下这个数据范围,**k<=2**

也就是说只有**第一大**和**第二大**两种可能

先来看一下k=1的时候的情况:
# k=1

我们假设a1~a8是递增的,且n=8,m=6,k=1

![](https://cdn.luogu.com.cn/upload/image_hosting/8kfaz7oq.png)

先假设我们选取了$a_1$,$a_2$,$a_{3}$,$a_{6}$,$a_{7}$,$a_{8}$这几个数

总费用值=$\sum\limits_{i=1,j=i+1}^{n-1,n}a_j-a_i$ 

通过观察可以发现有些值是可以进行拼接的

如$a_1$~$a_8$=$a_1$~$a_3$+$a_3$~$a_8$=$a_1$~$a_6$+$a_6$~$a_8$=...

![](https://cdn.luogu.com.cn/upload/image_hosting/d2lcgwxn.png)

我们可以把这个拼接看成是在这一段的**哪个位置断开**

这样一轮下来就相当于把开头为1和结尾为8的所有段数全部加完了 这样我们就不用再考虑1和8了
可以将图简化成下面这个样子

![](https://cdn.luogu.com.cn/upload/image_hosting/7xhv1f3q.png)

(如图)

同样
$a_2$~$a_7$这段也一样,以此类推,直到缩小到不能再缩的时候停下就可以了

(大致过程)
![](https://cdn.luogu.com.cn/upload/image_hosting/chk50fh5.png)

根据断点数量的规律


不难推出费用值=$\sum\limits_{i=1}^\frac{m}{2}(m-2(i-1)-1)*(a_{n-i+1}*a_i)$

把$(m-2(i-1)-1)*(a_{n-i+1}*a_i)$看成一个**组**


根据贪心原则

当k=1时

每次只需要分别取原数列排序后**最大和最小的两个值形成的组**,即可

如图(n=8,m=6)

![](https://cdn.luogu.com.cn/upload/image_hosting/ycwc66og.png)


这样k=1的情况就做完了

下面来看k=2的情况

# k=2

也就是次大的费用值

根据前面那个式子

很明显可以看出,如果要得到次小费用值,就要取改变最靠近中间的那个点

![](https://cdn.luogu.com.cn/upload/image_hosting/i0frh7yc.png)
(左右两种方向)


但从图中的数据明显可以看出,当中间的所有值和最靠近中间的那个值相等时,是无法改变总数值的

因此在最靠中间的那个值无法对总数值进行改变时

就只能去考虑改变第二靠近中间的值了,以此类推

如果不管怎么移动都无法改变总数值

即各项均相等或n==m时

输出-1

贴上丑陋不堪的代码和大致流程图
![](https://cdn.luogu.com.cn/upload/image_hosting/7h357q80.png)



```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[300010],ans,ansL,ansR;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1); 
	for(int i=1;i<=m/2;i++){
		ans+=(m-2(i-1)-1)*(a[n-i+1]-a[i]);//求第1大和
	}
	
	if(k==1) cout<<ans;
	else{
		if(n==m||a[1]==a[n]){
			cout<<-1;
			return 0;
		}
		for(int i=m/2+1;i<=n-m/2;i++){
			
			if(a[i]!=a[m/2]){
				ansL=a[i]-a[m/2];
				break;
			}
			
			if(i==n-m/2){
				
				for (int j=m/2-1;j>=1;j--) {
                    if (a[j]!=a[m/2]){	
                    	ansL=(m-2*j+1)*(a[m/2]-a[j]);//算差值
                    	break;
					}
                }
			}
		}
		
		for(int i=n-m/2;i>=m/2+1;i--){

			if(a[i]!=a[n-m/2+1]){
				ansR=a[n-m/2+1]-a[i];
				break;
			}
			if(i==m/2+1){
				
				for(int j=m/2+2;j<=n;j++){
					if (a[j]!=a[n-m/2+1]){
						
                    	ansR=(2*(j-n)+m-1)*(a[j]-a[n-m/2+1]);//化简了一下 
                    	break;
					}
				}
			}
		}
		cout<<max(ans-ansL,ans-ansR);
	}
}
```






---

## 作者：chenxinyang2006 (赞：3)

遥想当年我因为这题 std 锅了就没交题解，然后一直没去管它，为啥会有这么不负责任的出题人啊，自裁，请（无慈悲）。

考虑如何由一个状态 $S$，将一个 $x$  移动，使得答案更大。
  
因为将 $x_i$ 移动到 $x_j$，实际上可以认为是进行多次 $x_k$ 移动到 $x_{k+1}$ 的操作，或者是多次 $x_{k+1}$ 移动到 $x_k$。
  
将 $x_i$ 移动到 $x_{i+1}$ 改变的答案 $\delta = (x_{i+1} - x_i) \times (left - right)$，$left$ 表示在 $x_i$ 左边（包括 $x_i$） 有多少个选择的数，$right$ 表示在 $x_{i+1}$ 右边（包括 $x_{i+1}$） 有多少个选择的数。
  
（此处我们不认为 $x_i = x_{i+1}$ 时这样移动一次是操作）。
  
那么对于前 $\dfrac{m}{2}$ 个数，这个值是 $< 0$ 的，对于后 $\dfrac{m}{2}$ 个数，这个值是 $>0$ 的。
  
而对于后 $\dfrac{m}{2}$ 个数的任意一个，你将其不断向右边移后，$left$ 会不断增大，$right$ 不断减小，$\delta > 0$  始终成立。
  
也就是对于一个状态，我们去掉 $x_i$，加入 $x_j$，答案必定增加，其中 $j > i$，其中 $i$ 是当前状态的后 $\dfrac{m}{2}$ 个。
  
前 $\dfrac{m}{2}$ 个也是同理，去掉 $x_i$，加入 $x_j$，答案必定增加，其中 $j < i$，$i$ 是当前状态的前 $\dfrac{m}{2}$ 个。
  
于是 $k=1$ 的结论就很显然了：因为前 $\dfrac{m}{2}$ 和后 $\dfrac{m}{2}$ 个是某种意义上独立的，一定选最左边 $\dfrac{m}{2}$ 个，最右边 $\dfrac{m}{2}$ 个。
  
而对于所有状态，我们都可以通过若干次去掉 $x_i$，加入 $x_j$ 的操作来不断增大答案，从而得到最优解。
  
现在我们由最优解倒退反向操作，就能够减小答案。
  
因为求的是 $k=2$，所以一定只需要反向操作一次，设你反向操作多次得到贡献 $x$，一次得到贡献 $y$，根据定义有 $x < y$，因为 $y < ans$，所以 $x$ 一定不能作为次小值。
  
接下来我们就是要从最优状态进行一次反向操作得到最大的答案。
  
因为只进行一次反向操作，所以这次操作一定是从前 $\dfrac{m}{2}$ 个或后 $\dfrac{m}{2}$ 个移动一个到中间区域。
  
那么前 $\dfrac{m}{2}$ 个和后 $\dfrac{m}{2}$ 个又独立了，所以只看前面的情况。
  
设我们要从 $x_i$ 移动到 $x_j$，有结论：$x_j$ 一定是 $x_i$ 右边第一个与 $x_j$ 不同的数。
  
这个实际上非常显然，因为你遇到第一个有效移动后停下，显然是比继续往右移动改变的 $\delta$ 更小的。
  
你再思考一下，就会发现其实只有两种可能最优的方案，一个是 $i = \dfrac{m}{2}$，一个是 $j = \dfrac{m}{2} + 1$，证明如下：
  
假设你现在选了 $x_p,x_q$，其中 $p \neq \dfrac{m}{2},q \neq \dfrac{m}{2} + 1$。
  
那么如果 $x_q = x_{\frac{m}{2} + 1}$，那么选 $q$ 和选 $\dfrac{m}{2} + 1$ 等价。
  
如果 $x_p = x_{\frac{m}{2}}$，那么选 $p$ 和选 $\dfrac{m}{2} $ 等价。
  
如果都不成立，那么 $x_p < x_{\frac{m}{2}},x_{\frac{m}{2} + 1} < x_q$，你把 $q$ 换成 $\dfrac{m}{2} + 1$ 显然是可以并且更优的。
  
最后放一下刚写的 std：

```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
int n,m,k;
int x[300005];
int tag[300005];

ll get(){
	ll tmp = 0,res = 0,tot = 0;
	for(int i = 1;i <= n;i++){
		if(!tag[i]) continue;
		res += tot * x[i] - tmp;
		tmp += x[i];
		tot++;
	}
	return res;
}

ll max(ll a,ll b){
	if(a > b) return a;
	return b;
}

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i <= n;i++) scanf("%d",&x[i]);
	sort(x + 1,x + n + 1);
	for(int i = 1;i <= m / 2;i++) tag[i] = 1;
	for(int i = 1;i <= m / 2;i++) tag[n - i + 1] = 1;
	ll ans = get(),se = -1;
	if(k == 1){
		printf("%lld\n",ans);
		return 0;
	}
	if(m == n){
		printf("-1\n");
		return 0;
	}
	int j = m / 2 + 1;
	while(x[m / 2] == x[j] && j + 1 < n - m / 2 + 1) j++;
	if(x[m / 2] != x[j] && j < n - m / 2 + 1){
		tag[m / 2] = 0;tag[j] = 1;
		se = max(se,get());
		tag[m / 2] = 1;tag[j] = 0;
	}
	j = m / 2;
	while(x[m / 2 + 1] == x[j] && j - 1 >= 1) j--;
	if(x[m / 2 + 1] != x[j] && j >= 1){
		tag[m / 2 + 1] = 1;tag[j] = 0;
		se = max(se,get());
		tag[m / 2 + 1] = 0;tag[j] = 1;
	}
	j = n - m / 2;
	while(x[n - m / 2 + 1] == x[j] && j - 1 > m / 2) j--;
	if(x[n - m / 2 + 1] != x[j] && j > m / 2){
		tag[n - m / 2 + 1] = 0;tag[j] = 1;
		se = max(se,get());
		tag[n - m / 2 + 1] = 1;tag[j] = 0;
	}
	j = n - m / 2 + 1;
	while(x[n - m / 2] == x[j] && j + 1 <= n) j++;
	if(x[n - m / 2] != x[j] && j <= n){
		tag[n - m / 2] = 1;tag[j] = 0;
		se = max(se,get());
		tag[n - m / 2] = 0;tag[j] = 1;
	}
	printf("%lld\n",se);
	return 0;
}
```


---

## 作者：ForgetOIDuck (赞：1)

### 思路：
一开始看到第 $k$ 大，懵了想开摆。后来发现 $1\le k\le 2$。

好。我可是分讨全皮肤。

- $k = 1:$

  $x$ 先从小到大排序。
  
  假设我们选的分别是 $x_{p_1}, x_{p_2}, \cdots, x_{p_m}$。

  总和就为 $\sum_{i=1}^{m}\sum_{j=i+1}^m d(p_i,p_j)$

  （这里为了方便，设 $d(p_i,p_j)=|x_{p_i}-x_{p_j}|$）

  发现以 $p_1$ 开头，以 $p_m$ 结尾的所有通道长度全部加起来刚好是 $(m-1)\times d(1,m)$。
  
  既然系数确定，那就使 $d(1,m)$ 最大，也就是 $p_1=1,p_m=n$。
  
  剩下就变成 $2$ 到 $m-1$ 之间的子问题。

  根据上面的推理可得 $p_2=2,p_{m-1}=n-1$。以此类推。

  所以最优方案就是选择最左边的 $\dfrac{m}{2}$ 个和最右边的 $\dfrac{m}{2}$ 个。
  
  答案中 $d(i, m-i+1)$ 的系数为 $m - 2 \times i + 1$。
  
  题目中有条件 $2|m$，不用担心中间出现单独的。

- $k=2:$

  既然是严格次大，那就说明所有 $x_{p_i}$ 中只有一个的 $x$ 值在 $k=1$ 时最优方案的基础上发生了改变。

  易证左右两个部分只会改变一个部分。所以我们先只考虑左边，以下图为例：

  ![](https://cdn.luogu.com.cn/upload/image_hosting/9ery7lr7.png)

  
  ```
  6 4 2
  1 2 2 10 10 10
  ```

  $k=1$ 时最优选法如上图三角所示。

  对于左半部分现在我们有两种只改变一个 $x$ 值的方法：

  1. 将最右边的 $x_{p_{\frac{m}{2}}}$往右移，直到碰到一个不一样的 $x_{p0}$，如图：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/uh55aook.png)

  减少的贡献是 $x_{p0} - x_{p_{\frac{m}{2}}}$。

  要注意 $p0$ 不能跑到右边那些已经被占用的位置。否则此方案无解。
  
  2. 将从右到左第一个与最右边不一样的 $x_q$ 往右移一位，同时推着在它右边所有往右移一位，如图：
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/2w1j7mbp.png)
  
  减少的贡献是 $(x_{q+1}-x_q)\times(m-2\times q+1)$。   

  要注意 $q>0$；$x_{p_{\frac{m}{2}}}$ 需要等于 $x_{p_{\frac{m}{2}}+1}$ 不然整个移动的话最右边又会产生贡献，就不是次大值了。

  而且整个移完之后不能超过右边区间。
  
  不满足以上三个条件则此方案无解。

  右边同理。

  所有方案取最大值。


### AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, m, k, x[1000002], ans;
signed main() {
	cin >> n >> m >> k;
	if (n == m && k == 2) return puts("-1"), 0;
	for (ll i = 1; i <= n; i ++ ) cin >> x[i];
	sort(x + 1, x + n + 1);
	for (ll i = 1; i * 2 <= m; i ++ ) ans += (x[n - i + 1] - x[i]) * (m - 2 * i + 1); //k = 1
	if (k == 1) return cout << ans, 0;
	ll l = m / 2, r = n - l + 1, saml = l, samr = l, ans1, ans2, t1, t2; // 左半边部分
	while (samr <= n && x[samr] == x[l]) samr ++; samr --;
	while (saml >= 1 && x[saml] == x[l]) saml --; saml ++;
	//[saml, samr]包含左半边最右一个x[l]，且全部相等
	t1 = (samr + 1 < r ? ans + x[l] - x[samr + 1] : 0x3f3f3f3f3f3f3f3f); // 将 x[l] 向右移到第一个不一样的构成一个贡献；条件为不超过右半边。
	t2 = (saml > 1 && l + 1 < r && samr > l ? ans + (m - 2 * saml + 3) * (x[saml - 1] - x[saml]) : 0x3f3f3f3f3f3f3f3f); // 将整个相同区间右移后最右边一个不相同的右移一次构成一个贡献；条件为不超过右半边；这个相同区间左边要有数；x[l] 的右边也在相同区间内。
	ans1 = max((t1 >= ans ? -1ll : t1), (t2 >= ans ? -1ll : t2));// ansl 为左半边答案
	saml = samr = r; // 初始化，右半边部分
	while (samr <= n && x[samr] == x[r]) samr ++; samr --;
	while (saml >= 1 && x[saml] == x[r]) saml --; saml ++;
	//[saml, samr]包含右半边最左一个x[r]，且全部相等
	t1 = (saml - 1 > l ? ans - x[r] + x[saml - 1] : 0x3f3f3f3f3f3f3f3f); // 将 x[r] 向左移到第一个不一样的构成一个贡献；条件为不超过左半边。
	t2 = (samr < n && r - 1 > l && saml < r ? ans + (m - 2 * (n - samr) + 1) * (x[samr] - x[samr + 1]) : 0x3f3f3f3f3f3f3f3f);// 将整个相同区间左移后最左边一个不相同的左移一次构成一个贡献；条件为不超过左半边；这个相同区间右边要有数；x[r] 的左边一个也在相同区间内。
	ans2 = max((t1 >= ans ? -1ll : t1), (t2 >= ans ? -1ll : t2)); // ans2 为右半边答案
	cout << max(ans1, ans2); //左右半边答案
}
```

写了依托乱七八糟但是能过的答辩 ~~，在此谢罪~~

---

## 作者：dutianchen1 (赞：1)

# P6524 「Wdoi-1」托卡马克

~~笨笨的阿空可爱捏。~~

### 题意翻译

简单来说，就是有 $n$ 个点，要给 $m$ 个点连线，每次连线的贡献是两个点之间的距离。求贡献严格第 $k$ 大的方案。

### 思路简析

观察到，$1 \le k \le 2$，所以我们先考虑求得严格最大，再考虑如何由**严格最大**转到**严格次大。**

### 如何求严格第一大？

我们再注意到：$2 \mid m$。那么显然，我们一共需要连偶数条线。

我们先把可以选的点进行升序排序。一个显然的贪心策略就是选取**两端**的点连线，这样取得的贡献最大。

那么当我们选取第 $1$ 和第 $n$ 个点时，可以选取中间 $n-2$ 个点作为中转，还有一种直接连接的方法，总贡献就可以加上 $(n-1) \times (a_{n}-a_{1})$。

以此类推，就可以贪心求得贡献最大的情况。

### 如何求严格第二大？

求严格第二大，我们考虑**从严格第一大转移**过来。

我们考虑如何在原有贪心策略上**亏最少**。

显然，亏最少的策略就是只移动中间的那一对，使这一对的端点**向中间移动**。

但是有这么一个问题，输入的点可能坐标相同，所以我们得移动到第一个不同的点才能重新计算贡献。

最后考虑一下**不存在**严格第二大的情况。

显然，只有一种贡献结果就是这种情况，那么当 $m=n$ 或者所有点都一样时，就不存在严格第二大的情况。

还有一些琐碎的代码实现可以看注释。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
ll num[N];
ll n,m,k; 
ll ans;
int main()
{
	cin.tie(0);
	cout.tie(0);
	n=read();m=read();k=read();
	for(int i=1;i<=n;i++)num[i]=read();
	sort(num+1,num+1+n);
	
	ll tot=m-1,x=1;//cnt->长路对应的系数 
	while(tot>0){
		ans+=(num[n-x+1]-num[x])*tot;
		tot-=2;x++;
	}
	
	if(k==1){
		cout<<ans<<'\n';
	}
	else{
		if(m==n||num[1]==num[n])//只有一种连接方案，必不可能有严格第二长 
		{cout<<-1<<'\n';return 0;}
		//如果想要找到严格第二长，只需要通过严格最大最小的移动减去的贡献。 
		ll l=(m/2),r=(n-l)+1;//最靠内的一组的左右端点
		ll lmin=l,rmin=r;//移动某一个端点来找到最小修改代价 
		while(num[r]==num[rmin]&&rmin)rmin--;
		while(num[l]==num[lmin]&&lmin<=n)lmin++;//找到第一个不一样的，这样才会使得贡献发生变化
		ll cntl=0,cntr=0; 
		cntl=(lmin<r?num[r]-num[rmin]:(2*(lmin-r)+1)*(num[lmin]-num[r]));//检查移动之后的下标有无超出原来的范围
		cntr=(rmin>l?num[lmin]-num[l]:(2*(l-rmin)+1)*(num[l]-num[rmin]));
		ans-=min(cntl,cntr);
		cout<<ans<<'\n';
	}
	return 0;
}


```

---


# [Cnoi2021] 自我主义的平衡者

## 题目背景

「流浪月球 ~ The Wandering Moon」在幻想乡上映了。

正如一千个人心中有一千个哈姆雷特，关于它的争议也在悄然蔓延。

不知何时起，一个叫做「花瓣」的平台出现，慢慢取代了市井之中的讨论声，成为了争议的主战场——因为它具有评分功能。平台上旁征博引、各抒己见的评分帖成为了幻想乡的居民们日常，一切看起来岁月静好。

直到平衡者的出现。

起初没有人在意在意这缕杂音，这只不过是一种无心的叛逆，一点无奈的情感，一次无聊的宣泄。直到平衡的思想深入人心，自我主义的狂潮达到顶峰，评分系统的秩序几近崩溃。

Cirno 觉得自己该做些什么了。

## 题目描述

Cirno 决定通过计算来说服与拯救被自我主义裹挟的众人。

参与评分的共有 $n$ 位居民，平台限制的最高分为 $m$。

每个居民在评分前都有一个心理预期分数 $a_i(a_i\in[0,m]\cap\mathbb{Z})$。

但人们并不会按照心理预期分数直接评分，而是当当前平台上的平均分严格高于自己的心理预期分数时，便评分道「分数太高了，打个 $0$ 分平衡一下」，反之则说「分数太低了，打个满分（$m$分）平衡一下」。

初始时平台上的平均分为 $0$。

为了证明这种评分方式对公平的破坏性，Cirno 希望你计算出这 $n$ 位居民在不同的排列顺序下评分，平台上最终平均分可能的最大值与最小值。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据保证，$1 < n,m\le 10^5$，$a_i \in [0,m]$。

**子任务**

Subtask1（10 points）：$n \le 8$。

Subtask2（10 points）：$n \le 20$。

Subtask3（30 points）：$n \le 10^3$。

Subtask4（50 points）：无特殊限制。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5```

### 输出

```
4.00 2.00```

## 样例 #2

### 输入

```
7 114
23 75 35 17 101 55 73```

### 输出

```
81.43 32.57```

# 题解

## 作者：peppaking8 (赞：9)

### 题目大意

给定 $n$ 个数 $a_1,\cdots,a_n$。对于排列 $\sigma$，依次确定 $b_1,\cdots,b_n$，其中 $b_i=0$ 或 $m$。若 $b_1,\cdots,b_{i-1}$ 的平均数大于 $a_{\sigma_i}$，则 $b_i=0$，否则 $b_i=m$。求 $\sum b_i$ 的最大值和最小值。

$n,m\le 10^5$，$0\le a_i\le m$。

### 题解

我本来想每道题看一看口胡个解法就完事了，结果这道题代码太简单，~~我忍不住就写了~~

回归正题。官方题解写的对我而言有点难以理解，事实上这道题是一道数学题。

我们先考虑最大值，其实就是让 $b_i=m$ 的 $i$ 尽量多。对于 $a_i$ 较大的，我们不用担心，所以最重要的是拉较小 $a_i$ 的票。注意到开始的平均分是 $0$，所以不妨让最小的 $a$ 放到第一位，这样它会贡献一个 $m$。更进一步地，如果想持续不断地造出 $m$，那么小的 $a$ 一定要放在前面，要不然后面平均值就大了。

所以自然就想到了结论：

- 满足 $a_{\sigma_1}\le \cdots\le a_{\sigma_n}$ 的排列 $\sigma$，即**从小到大排序**，一定取到最大值。

我们对这个结论进行证明。仿照排序不等式的证法，考虑两个相邻项 $a_{\sigma_i},a_{\sigma_{i+1}}$。若前者大于后者，我们将它们交换，证明答案不会更劣。分四种情况讨论。下简称 $a_{\sigma_i}=A_i$。

1. $b_i,b_{i+1}=0$，此时不可能更劣。
2. $b_i=m,b_{i+1}=0$。交换后，若 $b_i$ 仍为 $0$，则 $b_{i+1}$ 一定为 $m$。因为交换前 $b_i=m$，说明 $b_1,\cdots,b_{i-1}$ 的平均值 $avg\le A_i$，而交换后，$b_1,\cdots,b_i$ 的平均值 $avg'\le avg$，且 $A_{i+1}$ 与交换前的 $A_i$ 相等。自然有 $avg'\le A_{i+1}$。
3. $b_i=0,b_{i+1}=m$。仿照上述证明，若交换后 $b_i=0$，一定有 $b_{i+1}=m$。
4. $b_i,b_{i+1}=m$。我们可以先说明 $b_i$ 交换后一定为 $m$（相似于上述证明）。这表明 $b_1+\cdots+b_{i}$ 交换前后都不变，但是 $A_{i+1}$ 增大了，$b_{i+1}$ 更应该是 $m$ 了。

对于不满足从小到大顺序的 $\sigma$，一定可以找到 $A_i>A_{i+1}$，交换后答案一定更佳。仿照冒泡排序调整即证！

同理，我们也可以证明，当从大到小排序的时候，一定取到最小值。毕竟最小值和最大值是对称的嘛。

然后这道题代码就太容易了！

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=100005;
int n;
ll m;
ll a[N],sum=0;
int main(){
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	sum=0;
	for(int i=1;i<=n;i++){
		if(sum<=a[i]*(ll)(i-1)) sum+=m;
	} 
	printf("%.2lf ",(double)sum/n);
	sum=0;
	for(int i=n;i>=1;i--){
		if(sum<=a[i]*(ll)(n-i)) sum+=m;
	} 
	printf("%.2lf",(double)sum/n);
}
```

---

## 作者：Code_星云 (赞：7)

又是一道 (๑•ᴗ•๑) 的贪心题。题解区的好多题解写的都不详细，在这里严谨证明一下。

首先通过分析样例或者猜测，是很容易得到结论的：若要取最大值，则将序列从小到大排序；否则从大到小排序。

证明：

首先证明取最大平均值时的正确性。我们使用邻项交换法。

假设现在在序列中存在 $a_i \leq a_{i+1}$，且此时从 $1$ 到 $i-1$ 的平均值为 $s$。此时分三种情况考虑。

1. $s \leq a_i \leq a_{i+1}$。

首先考虑不交换时的贡献。当枚举到 $i$ 时，所取得值总和会加上 $m$，此时平均值也会增大（或不变）。如果增加后的平均值小于等于 $a_{i+1}$，则答案还可以增大。

其次考虑交换 $i$ 和 $i + 1$ 两项。此时当枚举到第 $i$ 个数时（注意，不是枚举到 $a_i$ 时），总和仍会加上 $m$，而枚举到第 $i +1$ 个数时，因为 $a_i \leq a_{i+1}$，所以相对不交换时，答案增加的概率会减小。如果答案仍能增加，此时对后面的贡献与不交换时相同。

那不增加时呢？有同学可能会说，由于不交换时答案变大了，平均值也会变大，那么后面就相比交换时取值的概率减小了。事实上，如果存在这样一种情况，即假若交换时，在后面某位置 $j$ 又能再取一个 $m$ 时，此时所取的总值也仅仅是和不交换时相同，而在 $j$ 后面时，两方案贡献又相同了。

综上，此条件下，不交换不会劣化答案。

2. $a_i \leq s \leq a_{i+1}$

不交换时，在第 $i$ 个数是不能增加答案的，然后 $s$ 会减小到 $s'$，由于 $s' \leq s \leq a_{i+1}$，因此在第 $i+1$ 个数时能取到。

交换时，在第 $i$ 个数能取到，然后 $s$ 会增加到 $s''$，由于 $s'' \geq s \geq a_i$，因此在 $i + 1$ 是不能取到。此时两方案对后面的贡献都是一个 $m$。

综上，此情况下，不交换和交换答案贡献相同。

3. $a_i \leq a_{i+1} \leq s$

不交换时，$i$ 不能取到，$s$ 会减小到 $s'$，若 $s' \leq a_{i+1}$，则会增加 $m$；否则不变。

交换时，$i$ 不能取到，$s$ 仍会减小到 $s'$，若 $a_i < s' \leq a_{i+1}$，答案不如不交换时（此时仍可以用第 $1$ 种情况里面对那个疑问的回答来证明对后面影响的不劣化性）；其余情况与不交换时相同。

综上，不交换不会劣化答案。

可以用数学归纳法推到到整个序列。

对于求最小值时，也可以类比上面的证明方法，这里就省略了。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
#define int long long

const int N = 100005;
const double eps = 1e-14;
int n, m, sum = 0, a[N];
double avr = 0.0;

signed main(){
	scanf("%lld %lld", &n, &m);
	for(int i = 1; i <= n; i ++) scanf("%lld", &a[i]);
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; i ++){
		if(a[i] * 1.0 - avr > eps || fabs(a[i] * 1.0 - avr) < eps) sum += m;
		avr = 1.0 * sum / (1.0 * i);
	}
	printf("%.2lf ", avr); sum = 0;
	for(int i = n; i >= 1; i --){
		if(a[i] * 1.0 - avr > eps || fabs(a[i] * 1.0 - avr) < eps) sum += m;
		avr = 1.0 * sum / (1.0 * (n - i + 1));
	}
	printf("%.2lf\n", avr);
	return 0;
}
```


---

## 作者：Dr_Gilbert (赞：3)

## P8113 [Cnoi2021]自我主义的平衡者

【前言】赛时死磕C题，并没有注意到这道题，赛后也仅仅是看了看讨论区，并没放在心上。昨天晚上睡不着，忽然想起这道题。尝试证明之后，感觉实在是一道贪心好题，有感而发。其实这道题也提醒我们，__不要急于否认自己的第一直觉__，它有可能就是对的~

这里我采用邻项交换法证明结论，自认为分类讨论比现有题解略微清楚一些，希望能对大家有所帮助。

容易发现，最终得分只与满分和 $0$ 分的个数有关，不妨通过讨论各种情况确定每种情况对答案的贡献。尝试使用邻项交换法证明贪心结论。由于两个问题的过程十分相似，这里只证明最终满分人数最多的情况。不妨设有两个人 $x,y$，他们的预期值分别为 $E_x,E_y$，且有 $E_x\le E_y$。设这两人打分前的平均分为 $S$，第一个人打分后的平均分为 $S'$ 则可以根据 $S$ 与 $E_x$ 的大小关系分类讨论如下：

1. 若 $S\le E_x$，则 $x$ 会打一个满分，打分后的 $S'$ 和 $E_y$ 的大小关系仍然是不确定的：
   1. 若 $S'\le E_y$，则 $y$ 会打一个满分，此时贡献为 $2$ 个满分。若此时对 $x,y$ 的评分顺序进行调换，由于 $E_x\le E_y$，所以交换后有 $S\le E_y$，此时 $y$ 会打满分。由于 $S'$ 和 $E_x$ 的大小关系不确定，所以 $x$ 既可能打 $0$ 分，也可能打满分，于是交换后的贡献就是 $2$ 个满分或一个满分一个 $0$ 分，对答案的影响是不利的。
   2.  若 $S'>E_y$，则 $y$ 会打一个 $0$ 分，此时贡献为一个满分一个 $0$ 分。此时尝试对 $x,y$ 进行交换，此时 $S\le E_y$，$y$ 会打一个满分，此时的 $S'$ 仍然不变。由于 $S'>E_y$，且 $E_x\le E_y$，所以 $S'>E_x$，所以 $x$ 会打 $0$ 分。此情况中，交换对答案没有影响。

2. 若 $S>E_x$，则 $x$ 会打一个 $0$ 分，打分后的 $S'$ 和 $E_y$ 的大小关系仍然有两种可能：
   1. 若 $S'\le E_y$，则 $y$ 会打一个满分，此时对答案的贡献为一个 $0$ 分一个满分。此时交换 $x,y$，此时 $S$ 与 $E_y$ 的大小关系不确定，有如下两种情况：
      1. $S\le E_y$ 时，$y$ 会打一个满分，此时显然有 $S'>S$，又因为 $S>E_x$，所以 $S'>E_x$，即 $x$ 会打 $0$ 分，所以此情况对答案无影响。
      2. $S>E_y$ 时，$y$ 会打一个 $0$ 分，此时即使 $S'\le E_x$，也不能使答案变得更优。
   2. 若 $S'>E_y$，则 $y$ 会打 $0$ 分，此时对答案的贡献为 $2$ 个 $0$ 分。此时交换 $x,y$，由于 $S>S'>E_y\ge E_x$，所以即使交换后，对答案的贡献也是 $2$ 个 $0$ 分。

综上所述，对于这两个人 $x,y$ ，交换他们的顺序都不能使答案变得更优，所以对于最大值的问题，最优策略为将所有的 $a_i$ 升序排序后模拟。证明取最小值的最优策略为降序排序的证明过程非常相似，不再赘述。

本题还有一点需要注意的地方就是卡精度，统计总分，每次在比较时计算平均分能尽可能减小精度误差。同时如讨论区所说，本题需要使用  `double` 而不能使用 `long double`，可能出题人造数据用的就是 `double` （

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[100010];
signed main(){
	int n,m;
	cin>>n>>m;
	for (int i=1;i<=n;i++) cin>>a[i];
	int maxtot=m,mintot=m;
	sort(a+1,a+1+n);
	for (int i=2;i<=n;i++){
		if (double(maxtot)/(i-1)<=a[i]){
			maxtot+=m;
		}
	}
	reverse(a+1,a+1+n);
	for (int i=2;i<=n;i++){
		if (double(mintot)/(i-1)<=a[i]){
			mintot+=m;
		}
	}
	double ansmax=double(maxtot)/n;
	double ansmin=double(mintot)/n;
	cout<<setprecision(2)<<fixed<<ansmax<<' '<<ansmin<<endl;
	return 0;
}
```



---

## 作者：LKY928261 (赞：2)

### Solution

先考虑如何求最大值。

由于每人评的分都是 $0$ 分或者 $m$ 分，所以要使评分最大就是让评 $m$ 分的人最多。

设当前的平均分为 $t$，考虑下一个让谁评分：

- 如果想让下一个人选择评 $0$ 分，那么所有还没评过分的满足 $a_i<t$ 的人都可以选，而这些人中不管 $a_i$ 高低评分效果都一样。

  于是，如果选择了一个 $a_i$ 较大的人，可以考虑把他换成一个较小的 $a_j$，那么在后续的操作中，$a_i$ 会比 $a_j$ 有更大的可能性选择评满分。于是直接选择让当前评分最小的人评是不劣的。

- 如果想让下一个人选择评 $m$ 分，情况也是类似的。所有还没评过分的满足 $a_i \ge t$ 的人都可以选，且这些人中不管 $a_i$ 高低评分效果也都一样。与上面一样，此时选择让 $a_i \ge t$ 的人中 $a_i$ 最小的人评是不劣的。

然后记 $a_x$ 为所有剩余 $a_i$ 中最小的一个。不难发现：

- 若当前平均值 $t>a_x$，那么：如果我们想让下一个人评 $0$ 分，根据上面的结论，我们会选择 $a_x$；如果我们想让下一个人评 $m$ 分，那么平均分只增不减，到最后还是得让 $a_x$ 评个 $0$ 分。

  于是不管怎样 $a_x$ 总是评 $0$ 分，那么不如先让他评好，这样剩下的人就有更多评 $m$ 分的机会，这是也不劣的。

- 反之，若 $t \le a_x$，不管是谁都会选择评 $m$ 分，根据上面的结论，直接取 $a_x$ 就行。

综上所述，我们总是无脑选 $a_i$ 最小的那个人让他评分就是最优的。

最小值同理，反一下就行了。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=1e5+5;
ll n,m,s,k,a[_],i;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(i=0;i<n;i++)cin>>a[i];
	sort(a,a+n);
	for(i=0;i<n;i++)if(m*s<=a[i]*i)s++;
	for(i=0;i<n;i++)if(m*k<=a[n-i-1]*i)k++;
	cout<<setprecision(2)<<fixed<<s*1./n*m<<' '<<k*1./n*m<<'\n';
}
```

---

## 作者：nbbqwer (赞：2)

自我主义的平衡者题解：

## 概括

$n$ 个数字，针对每一个排列顺序，计算每一个数字对总和的贡献：
$
f(a) = \begin{cases}
1 ,& a[i] < \text{aver}\\
0 ,& \text{otherwise.}
\end{cases}$

（$aver$ 即 $1$ 到 $i-1$贡献的平均值），求总贡献平均值的最大值和最小值。

## 题解

看到这题，可以发现一个规律，每个数字的贡献要么是 $m$，要么是 $0$，当 $m$ 的数量最多的时候，平均值最大；反之最小。

以 $m$ 数量最多为列：

针对一个 $i$，如何使 $a_{i}>aver$ 的情况出现得最多呢？

假设位置为 $1$ 到 $i-2$ 的数固定，$i-1$ 上的数有 $x$、$y$ 两种情况，且 $x<y$，显然 $x$ 优于 $y$。

进行扩展，$1$ 到 $i-1$ 的数越小越优秀。

好的，什么样的前缀是优秀的，我们已经知道了。于是，第二个问题是，怎么分配这样的前缀。

设两个无交集的前缀组 $S1$，$S2$，且 $S1$ 优于 $S2$，以及两个数字 $x$、$y$，且 $x<y$。

显然 $S1+x+S2+y$ 比 $S2+x+S1+y$ 更优，因为 $S1$ 优于 $S2$，而 $S1+x+S2$ 和 $S2+x+S1$ 在后面的效果没有差别，所以 $S1$ 放在 $S2$ 前面，更优。

那么， $S1+x+S2+y$ 和 $S1+y+S2+x$ 相比，怎么处理可以得到一般性的最优结果呢？

显然升序排序后，$S1+x+S2+y$ 一定优于或等效于 $S1+y+S2+x$ 。

所以升序排序，是此种情况的最优解。

同理，降序排序是求最小平均值的最优解。

over~~

```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
inline int read() {
	ri x=0,f=0;
	register char c=getchar();
	while(!isdigit(c)) f=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f?-x:x; }
int n,m,a[100005];
double sum,tt;
inline bool cmp(int a,int b) {
	return a>b; }
signed main() {
	n=read(),m=read();
	for(ri i=1,x; i<=n; ++i) a[i]=read();
	sort(a+1,a+1+n);
	for(ri i=1; i<=n; ++i)
		if(tt>(double)a[i]) tt=(double)sum/i;
		else sum+=(double)m,tt=(double)sum/i;
	printf("%.2lf ",tt);
	sort(a+1,a+1+n,cmp);
	sum=0;
	for(ri i=1; i<=n; ++i)
		if(tt>(double)a[i]) tt=(double)sum/i;
		else sum+=(double)m,tt=(double)sum/i;
	printf("%.2lf\n",tt);
	return 0; }
```


---

## 作者：dutianchen1 (赞：1)

# P8113 [Cnoi2021] 自我主义的平衡者

### 思路简析

题目要求我们对原序列进行排序，使得操作后所得分最大或最小化。

于是我们考虑对每次打分的情况进行分类讨论。

令 $ans_{i}$ 为前 $i$ 个人已经打好分后的平均分，$a_{i}$ 为第 $i$ 个人的心里预期得分。

我们可以发现所有打分情况如下：

- 当 $ans_{i-1} \le a_{i} \le a_{j}$ 时，无论先让第 $i$ 个人打分还是第 $j$ 个人打分，总分都会增加 $m$。而当下一个人打分时，$ans_{i} \le a_{j}$ 的可能性显然比 $ans_{i} \le a_{i}$ 更大。也就是说使得总分增加 $m$ 的可能性中，前者更大。

- 当 $a_{i} \le ans_{i-1} \le a_{j} $ 时，显然先让第 $i$ 个人打分再让第 $j$ 个人打分会使得总分更大。因为先让第 $i$ 个人打分可以稳得 $m$ 分，而先让第 $j$ 个人打分，不一定会使得平均分变得小于 $a_{i}$，并不更优。

- 当 $a_{i} \le a_{j} \le ans_{i-1}$ 时，情况与第一种相似。无论第一个是谁打分，都无法使得总分改变。而让第 $j$ 个人后打分，满足 $ans_{i-1} \le a_{j}$ 的可能性显然比让第 $i$ 个人后打分的可能性更大。

综上，我们可以发现，使原序列升序排列即可使得总分最大。同理，使原序列降序即可使得总分最小。

所以我们只需要排序之后模拟一遍即可。

需要注意的是，同分的情况也可以使总分增加。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const double eps = 1e-8;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
ll n,m;
ll num[N];
bool cmp(ll a,ll b){return a>b;}
ll cnt1,cnt2;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)num[i]=read();
	sort(num+1,num+1+n);
	for(ll i=1;i<=n;i++)
	{
		if(i==1){cnt1+=m;continue;}
		if(num[i]*(i-1)>=cnt1)cnt1+=m;
	}
	printf("%.2f ",(1.0*cnt1/n));
	sort(num+1,num+1+n,cmp);
	for(ll i=1;i<=n;i++)
	{
		if(i==1){cnt2+=m;continue;}
		if(num[i]*(i-1)>=cnt2)cnt2+=m;
	}
	printf("%.2f\n",(1.0*cnt2/n));
    return 0;
}
```

---

## 作者：NightTide (赞：1)

## P8113 [Cnoi2021] 自我主义的平衡者 题解

~~谁家全排列写错了导致暴力分都没拿到啊！~~

通过数据范围倒推时间复杂度。

$n \le 10^5$，一眼 $O(n\log n)$。

再结合暴力打表，很容易发现规律：

> 当 $a$ 从小到大排列时，取到最大值；当 $a$ 从大到小排列时，取到最小值。

感性理解一下，以最小值为例。欲取到最小值，即要使得 $b$ 中的 $0$ 尽量多。若已知前 $i $ 项的排列方式，必然选择之后的最大值，从而使得 $a_{i + 1} > \bar{b_i}$

接下来以最小值为例对结论进行证明：

记从大到小排序后新序列的第 $i$ 项为 $a_i$，前 $i$ 项的平均值为 $\bar{b_i}$。

先考虑两个排序后的相邻项 $a_i, a_{i + 1}$，若交换这两项的顺序：

1. $b_i = b_{i + 1} = 0$，交换不会产生任何影响。
2. $b_i = 0, b_{i + 1} = m$，则有 $\bar{b_{i - 1}}>a_i\ge a_{i+1}$。交换后 $b_i' = b_i = 0$，则 $\bar{b_i}' = \bar{b_i}\le a_{i + 1} \le a_i$，$b_{i + 1}' = m$，结果不变。
3. $b_i = m, b_{i + 1} = 0$，则有 $\bar{b_{i - 1}} \le a_i,\;\bar{b_i} > a_{i + 1}$。记交换后的序列变为 $b'$：
   1. 若 $a_{i + 1} < \bar{b_{i - 1}}$：$b_{i}' = 0$，则 $\bar{b_{i}}' = \bar{b_{i - 1}} \le a_i$，则 $b_{i - 1}' = m$，对最终平均值无影响。
   2. 若 $a_{i + 1}\ge\bar{b_{i - 1}}$：$b_i' = m$，则 $\bar{b_i}' = \bar{b_i}$，不论 $b_{i + 1}$ 取 $0$ 还是 $m$，最终结果都不会变小。
4. $b_i = b_{i + 1} = m$，则有 $a_i\ge\bar{b_{i - 1}},\;a_{i + 1}\ge\bar{b_i}$。由于 $b_{i - 1}\le m$，所以 $\bar{b_i} \ge \bar{b_{i - 1}}$，所以 $a_{i + 1} \ge \bar{b_{i - 1}}$，$b_i' = m$，$\bar{b_{i}}' = \bar{b_i}$，$a_i\ge a_{i+1}\ge\bar{b_i} = \bar{b_i}'$，则 $b_{i + 1}' = m$，最终结果不变。

因此对两个相邻项的交换不会使得答案变小。

而对两个非相邻项则可以通过多次相邻项的交换来达到（类似于冒泡排序）。

因此当 $a$ 从大到小排列时，取到最小值。

最大值同理。

于是得到了我见过的最简单的蓝题代码（这题真的有蓝吗）：

```cpp
#include<bits/stdc++.h>
#define MAXN 100010
using namespace std;
int n, m;
int a[MAXN];
double max_s, min_s;
int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
    sort(a + 1, a + n + 1);
    for(int i = 2; i <= n; i++){
        double ave = max_s / (i - 1);
        if(ave > a[i]) max_s += 0;
        else max_s += m;
    }
    for(int i = n - 1; i >= 1; i--){
        double ave = min_s / (n - i);
        if(ave > a[i]) min_s += 0;
        else min_s += m;
    }
    printf("%.2f %.2f\n",max_s / n, min_s / n);
    return 0;
}
```

---

## 作者：block_in_mc (赞：1)

## 题目大意

对于一部电影，有 $n$ 个人，第 $i$ 个人的心理预期分数为 $a_i$。现在，这 $n$ 个人按照某种顺序依次打分，对于第 $i$ 个人，若目前平均分大于 $a_i$ 分，他会打 $0$ 分；否则他会打 $m$ 分，初始时平均分为 $0$。

你可以任意安排这 $n$ 个人的打分顺序，求最终平均分的最大值和最小值。

## 解题思路

不难推测，应该按 $a_i$ 从小到大排序和从大到小排序分别得到最大值和最小值。下面以从小到大排序为例，利用**邻项交换法**给出证明：

由于每个人的打分只可能是 $0$ 或 $m$，最大化最终平均分即为最大化 $m$ 的个数。在排序后，对于相邻两项 $a_i$ 和 $a_{i+1}$，设其心理预期分数分别为 $x$ 和 $y$（$x\le y$），当前平均分为 $s$，分类讨论：

1. 若 $x=y$，交换两项显然无影响；
2. 若 $s\le x<y$，交换前后靠前的人打分均为 $m$，但把心理预期分数较低的 $x$ 换到后面降低了靠后的人打分为 $m$ 的几率，不优于将 $x$ 排在前面；
3. 若 $x<s\le y$，交换前后均为一次 $m$ 分，一次 $0$ 分，无影响；
4. 若 $x<y<s$，与第二种情况类似。

综上，我们证明了一定不存在优于从小到大的打分顺序。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[100100];
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	long long score = m;
	for (int i = 2; i <= n; i++)
		if (1ll * a[i] * (i - 1) >= score)
			score += m;
	printf("%.2f ", 1.0 * score / n);
	sort(a + 1, a + n + 1, greater<int>());
	score = m;
	for (int i = 2; i <= n; i++)
		if (1ll * a[i] * (i - 1) >= score)
			score += m;
	printf("%.2f", 1.0 * score / n);
	return 0;
}
```

---

## 作者：eEfiuys (赞：1)

题目：[P8113](https://www.luogu.com.cn/problem/P8113)

**这依然是一篇贪心的题解。**

------------

以最大值为例，我们需要将 $a$ **升序排列**。最小值与之相反，这里不说了。

### 证明：
- 我们知道，所有人只会打 $0$ 分或 $m$ 分，因此需要最大化 $m$ 分的数量，即**最大化打 $m$ 分的可能性**。
- 令 $x,y$ 为 $2$ 个人分别的预期分 $\left(x \leq y \right)$，$p$ 为当前平均分，$q$ 为第 $1$ 个人打完后的平均分，$P(k)$ 为事件 $k$ 发生的概率。
- 最先打分的一定是 $m$ 分，因此以下情况中，$p>0$。
- $x = y$：顺序没有影响。
- $p \leq x < y$：
	- 第一次打分都为 $m$，因此 $q$ 相等且 $q \geq p$。
	- **因为 $P(x \geq q) < P(y \geq q)$，所以第二次为 $y$，则第一次为 $x$**。
- $x < p \leq y$：
	- 第一次 $x$，则打 $0$ 分，$q < p < y$，则第二次打 $m$ 分。
	- 第一次 $y$，则打 $m$ 分，$x < p \leq q$，则第二次打 $0$ 分。
	- 可以发现，**上面两种没有区别**。
- $x < y < p$：
	- 第一次打分都为 $0$，因此 $q$ 相等且 $q < p$。
	- **因为 $p(x \geq q) < P(y \geq q)$，所以第二次为 $y$，则第一次为 $x$**。
- **综上所述，先由预期分小的打分，能够最大化分数。**

------------

### 处理精度误差：
在计算时，我们使用**总分**，而不是平均分。将第 $i$ 个预期分数（即 $a_i$）乘以 $i-1$ 即为其对应总分（$i=1$ 没有影响，因为 $0 = 0$）。**记得开 `long long`，最终答案除以 $n$**。

需要 `sort`，则时间复杂度 $O(n \log{n})$。~~桶排的话我没办法。~~

------------

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
int n,m,a[N];
ll ans1,ans2;
bool cmp(int x,int y){return x>y;}
ll solve(){
	ll num=0;
	for(int i=1;i<=n;i++)
		if((ll)a[i]*(i-1)>=num)num+=m;
	return num;
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	sort(a+1,a+n+1),ans1=solve(); //从小到大，最大值
	sort(a+1,a+n+1,cmp),ans2=solve(); //从大到小，最小值
	printf("%.2lf %.2lf\n",(double)ans1/n,(double)ans2/n);
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：1)

## 1.思路

这道题我是用的是贪心的方法，具体过程如下：

最大值：将数组 $a$ 从小到大排序后，所得的平均值就是最大的：

证明：我们要让最后的平均分最大，先让就要让投 $m$ 分的最多，从小到大排序后显然评分是从小到大的，所以最终评分也就最大。

最小值同理。

## 2.代码

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;
const long double EPS=1e-7;

int n,m;
vector<int> FlowerRating;

double GetSelfishRating()
{
	long long Sum=m;

	for(auto i=1u;i<FlowerRating.size();i++)
	{
		if(Sum*(double)1.0/(i)>FlowerRating[i])
			continue ;
		else
			Sum+=m;
	}

	return Sum*(double)1.0/n;
}

signed main()
{
	cin>>n>>m;

	for(int i=1;i<=n;i++)
	{
		int _t;

		cin>>_t;

		FlowerRating.push_back(_t);
	}

	sort(FlowerRating.begin(),FlowerRating.end());

	cout<<fixed<<setprecision(2)<<GetSelfishRating()<<" ";

	sort(FlowerRating.begin(),FlowerRating.end(),greater<int>());

	cout<<fixed<<setprecision(2)<<GetSelfishRating()<<endl;

	return 0;
}

```


---


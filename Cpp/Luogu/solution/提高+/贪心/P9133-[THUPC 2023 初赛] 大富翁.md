# [THUPC 2023 初赛] 大富翁

## 题目背景

有一天，小 W 和小 H 在玩大富翁。

## 题目描述

这版大富翁的游戏规则比较独特。它的地图是一棵 $n$ 个节点的有根树，其中 $1$ 号节点为根。树上每个节点都有一个价格，第 $x$ 号节点的价格记为 $w_x$。

对于树上两个不同的节点 $x,y$，若 $x$ 是 $y$ 的祖先节点（即，$x$ 在 $1$ 号点到 $y$ 号点的简单路径上），则称 $x$ **支配** $y$。

游戏过程中，小 W 和小 H 轮流**购买**树上的一个未被人购买过的节点，直到树上的 $n$ 个节点都被小 W 或小 H 购买。（游戏开始前，树上的所有节点都没有被购买。）

对于一次购买，假设买方购买了 $x$ 号节点，那么他首先要向系统支付 $w_x$ 个游戏币。假设此时 $x$ 支配着 $n_1$ 个已被买方的对手购买了的节点，同时又被 $n_2$ 个已被对手购买了的节点支配。若 $n_1>n_2$，那么对手要向买方支付 $n_1-n_2$ 个游戏币，若 $n_1<n_2$，那么买方要向对手支付 $n_2-n_1$ 个游戏币。

小 W 和小 H 都是绝顶聪明的人，他们都会在游戏中采用最优策略，来使自己赚到尽量多的游戏币。现在，小 W 想考考你：如果他先手，他最终能赚到多少个游戏币？（即，在整个游戏过程中，小 W 从小 H 手中获得的游戏币个数减去他支付给系统和小 H 的游戏币个数。你可以认为，游戏开始前，小 H 和小 W 手中都有足够数量的游戏币。注意：答案可能为负数。）

## 说明/提示

#### 样例解释 1

一个可能的游戏过程是：

- 第一次购买：小 W 购买 $1$ 号节点，向系统支付 $0$ 个游戏币。
- 第二次购买：小 H 购买 $2$ 号节点，向系统支付 $0$ 个游戏币，并向小 W 支付 $1$ 个游戏币。
- 第三次购买：小 W 购买 $3$ 号节点，向系统支付 $1$ 个游戏币。
- 第四次购买：小 H 购买 $4$ 号节点，向系统支付 $0$ 个游戏币，并向小 W 支付 $1$ 个游戏币。
- 第五次购买：小 W 购买 $6$ 号节点，向系统支付 $0$ 个游戏币。
- 第六次购买：小 H 购买 $5$ 号节点，向系统支付 $0$ 个游戏币，并向小 W 支付 $1$ 个游戏币。
- 第七次购买：小 W 购买 $7$ 号节点，向系统支付 $0$ 个游戏币。

#### 子任务

对于所有测试数据，$1\leq n\leq 2\times 10^5$，$0\leq w_x\leq 2\times 10^5$。保证输入的图为一棵以 $1$ 号节点为根的有根树。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
7
0 0 1 0 0 0 0
1 1 2 2 3 3
```

### 输出

```
2```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.ans```

# 题解

## 作者：Demeanor_Roy (赞：15)

- [原题链接](https://www.luogu.com.cn/problem/P9133)

- [关于本题的一件趣事](https://www.luogu.com.cn/discuss/581675?page=2)

------------

感觉挺神仙的，反正我是想不出来。

考虑游戏规则的实质。假设小 W 所选点集为 $S$，小 $H$ 所选点集为 $T$，$f(x,y)$ 在点 $x$ 支配点 $y$ 时为 $1$，其余为 $0$。则：

$$Ans=\sum_{x \in S}\sum_{y \in T}f(x,y)-\sum_{x \in S}\sum_{y \in T
}f(y,x)- \sum_{x \in S}w_x$$

$$=\sum_{x \in S}(\sum_{y \in T}f(x,y)+ \sum_{y \in S}f(x,y)
)-\sum_{x \in S}(\sum_{y \in T}f(y,x)+ \sum_{y \in S}f(y,x)
)- \sum_{x \in S}w_x$$

$$=\sum_{x \in S}sz_x
-\sum_{x \in S}dep_x
-\sum_{x \in S}w_x$$

$$=\sum_{x \in S}(sz_x - dep_x - w_x)$$

于是贡献被拆分到每个点上，二人轮流从点权大的往点权小的选就为最优策略。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e5+10;
int n,w[N],p[N],dep[N],sz[N];
vector<int> vec[N];
inline void dfs(int u)
{
    sz[u]=1;dep[u]=dep[p[u]]+1;
    for(auto x:vec[u]) dfs(x),sz[u]+=sz[x];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    for(int i=2;i<=n;i++) scanf("%d",&p[i]),vec[p[i]].push_back(i);
    dfs(1);for(int i=1;i<=n;i++) p[i]=i;
    sort(p+1,p+n+1,[](int a,int b){return sz[a]-w[a]-dep[a]>sz[b]-w[b]-dep[b];});
    long long ans=0;
    for(int i=1;i<=n;i++) if(i&1) ans+=sz[p[i]]-w[p[i]]-dep[p[i]];
    printf("%lld",ans);
    return 0;
}
```




---

## 作者：Loser_King (赞：11)

场上个人独立过的第三个题（包括签到）也是最后一个题，属于是队长开局过题后面摆摆摆寄寄寄纯纯给队友涨信心了（

---

不是很难的题，但好像卡了一些队，就写写心路历程吧。

过了 K 以后开过了人数最多的 A，读完题以后就有种这是个 sort 题的感觉，因为发现题目中给的条件就是对手给买方 $n_1$ 个游戏币，买方给对手 $n_2$ 个游戏币。

同时因为每个点可能支配的点一定在子树内，把它支配的点一定是它的祖先，于是树上单个节点 $x$ 的贡献就可以写成：最终状态里 $x$ 子树中的对方节点个数 $-$ 最终状态里 $x$ 祖先集合中的对方节点个数 $-$ 买下节点 $x$ 需要的游戏币数量。（因为要把整局游戏中 $x$ 节点的贡献算完整，所以这里是最终状态）

然后你会发现这玩意还是不好维护，因为玩家的操作可能会导致对手策略改变从而改变节点的分布。发现这个操作还是可以转化：你可以把己方和对方的结点一视同仁，这样一对己方的祖孙结点贡献就会加一减一然后抵消不变。于是现在贡献就变成了：$x$ 子树中的两方节点个数 $-\;x$ 祖先集合中的两方节点个数 $-$ 买下节点 $x$ 需要的游戏币数量。

然后这个就是深度和子树大小，直接求出贡献然后降序依次取即可。

数组开小然后贡献倒着取，然后两发罚时/oh

```c++
// Healthy Humans Will Leave the Solar System (16.7 km/s)

#include<bits/stdc++.h>
#define int long long
using namespace std;
int const N=200010;
int n,ans,a[N],fa[N],sz[N],dep[N];
vector<int>e[N];
void dfs(int x){
    sz[x]=1;
    for(int y:e[x])
        dep[y]=dep[x]+1,dfs(y),sz[x]+=sz[y];
}
signed main(){
    ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=2;i<=n;i++)
        cin>>fa[i],e[fa[i]].push_back(i);
    dfs(1);
    for(int i=1;i<=n;i++)
        a[i]=sz[i]-dep[i]-a[i]-1;
    sort(a+1,a+1+n);
    for(int i=n;i>=1;i-=2)
        ans+=a[i];
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：cryozwq (赞：9)

从一个更感性的方式推导官方题解的结论。

我们试图去找另一种方式描述选择一个节点，使得其不跟子树内或者祖先上究竟是自己的点还是对面的点有关，这里提出一种方法：当你选择一个点的时候，给祖先上每个点交 $1$ 个游戏币。那么对于一个友方节点，相当于是自己把钱给了自己，等于没有变化，而对方节点就是贡献了原本选择方式一样的贡献。

因此，我们现在一开始就知道选择一个点的收益，因为每个点最后都得被选，所以会收入 $sz_u-1$ 个游戏币，给祖先的每个节点都交一个，损失 $dep_u-1$ 个游戏币，因此总收益为 $sz_u-1-(dep_u-1)-w_u=sz_u-dep_u-w_u$，那么两个人每次都会贪心选择最大的，模拟即可。

---

## 作者：hhoppitree (赞：7)

题目名称：大富翁  
时间限制：$\text{1s}$   
内存限制：$\text{512MB}$   
题目类型：传统题

#### 题意简述

给定一棵由 $n$ 个结点构成的树，每个点有点权 $w_i$，双方轮流选点，每次当前方必须花费 $w_x$ 个游戏币选择一个没有选择过的节点 $x$，如果此次操作后 $x$ 的子树内有 $p$ 个对方选取过的点，祖先中有 $q$ 个对方选取过的点，那么就可以从对方那里获得 $(p-q)$ 个游戏币，求在游戏过程结束后先手所能赚取游戏币的最大数量（游戏过程中游戏币数量可以为负数且双方均使用最优策略）。

对于所有数据，$1\le n\le2\times10^5$，$0\le w_x\le2\times10^5$。

#### 题目解法

还是考虑拆贡献，考虑最终局面中一对存在祖孙关系的结点 $x$ 和 $y$（$x$ 是 $y$ 的祖先），假设先手为 $A$，后手为 $B$，则存在以下四种情况：

- $x,y$ 均为 $A$ 选择，此时对先手的贡献为 $0$；
- $x,y$ 均为 $B$ 选择，此时对先手的贡献为 $0$；
- $x$ 为 $A$ 选择，$y$ 为 $B$ 选择，此时对先手的贡献为 $1$；
- $x$ 为 $B$ 选择，$y$ 为 $A$ 选择，此时对先手的贡献为 $-1$。

发现，若将 $x$ 的点权设置为 $1$，$y$ 的点权设置为 $-1$，则最终先手获得的贡献即为他获得的点的价值和。

所以，先假设第 $x$ 个点的点权为 $-w_x$，再对于所有这样的点对 $(x,y)$，将其中 $x$ 的点权加上 $1$，将 $y$ 的点权减去 $1$，则最终 $A$ 或 $B$ 选取的点的点权之和即为 $A$ 赚取游戏币的数量。

容易发现，此时第 $i$ 个点的点权即为 $\text{siz}_i-\text{dep}_i-w_i$，且在最优策略下 $A$ 所能选取的点权为所有点的点权从大到小排序后奇数下标的点权，可以直接 $\text{dfs}$ 后排序求出，时间复杂度 $\mathcal{O}(n)$。

#### 参考代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

int siz[N], dep[N], w[N];
vector<int> G[N];

void dfs(int x)
{
    siz[x] = 1;
    for (int i = 0; i < G[x].size(); ++i) {
        int v = G[x][i];
        dep[v] = dep[x] + 1;
        dfs(v);
        siz[x] += siz[v];
    }
    return;
}

signed main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &w[i]);
    }
    for (int i = 2, fa; i <= n; ++i) {
        scanf("%d", &fa);
        G[fa].push_back(i);
    }
    dfs(dep[1] = 1);
    for (int i = 1; i <= n; ++i) {
        w[i] = (siz[i] - 1) - (dep[i] - 1) - w[i];
    }
    sort(w + 1, w + n + 1, greater<int>{});
    long long res = 0;
    for (int i = 1; i <= n; i += 2) {
        res += w[i];
    }
    printf("%lld\n", res);
    return 0;
}
```

#### 总结

对于这类有关点权的博弈问题，可以拆开点权，然后利用线性性进行合并每个点的贡献，最终可以转化为简单的博弈问题进行解决。

---

## 作者：World_Creater (赞：4)

赛时被诈骗和两个队友爆干两个小时，原因是没有绕出来”按顺序选点“。

看了官方题解觉得好妙，~~所以这篇题解吸收了官方题解的精华~~。

我们把 $x$ 支配 $y$，记做$x \to y$。

首先一个**非常重要的观察**是得分只于最终局面有关而不与选点顺序有关。

令先手选点集合为 $A$，后手选点集合为 $B$。

那么先手的得分为：

$$\sum_{x\in A}\sum_{y\in B}[x\to y]-\sum_{x\in A}\sum_{y\in B}[y\to x]+\sum_{x\in A}w_x$$

瞎搞一下得到原柿子等于：

$$\sum_{x\in A}\sum_{y\in B}[x\to y]+\sum_{x\in A}\sum_{y\in A}[x\to y]-\sum_{x\in A}\sum_{y\in B}[y\to x]-\sum_{x\in A}\sum_{y\in A}[y\to x]+\sum_{x\in A}w_x$$

注意到新加入的项是互相抵消的，同时将新加入的项于之前合并一下得到：

$$\sum_{x\in A}\sum_{y=1}^{n}[x\to y]-\sum_{x\in A}\sum_{y=1}^{n}[y\to x]-\sum_{x\in A}w_x$$

第一项显然等于 $x$ 的子树大小，第二项显然等于 $x$ 的深度，第三项也是知道的。

而后手的得分显然可以与相同方式算出。

所以按照子树大小减去深度减去点的权值从大到小排序，直接贪心即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[200005],dep[200005],sz[200005],nxt[200005],head[200005],go[200005],k,ans;
void add(int u,int v)
{
	nxt[++k]=head[u];
	head[u]=k;
	go[k]=v;
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	sz[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int g=go[i];
		if(g==fa) continue ;
		dfs(g,x);
		sz[x]+=sz[g];
	}
	a[x]=sz[x]-dep[x]-a[x];
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=2;i<=n;i++)
	{
		int x;
		cin>>x;
		add(x,i);
	}
	dfs(1,0);
	sort(a+1,a+1+n);
	reverse(a+1,a+1+n);
	for(int i=1;i<=n;i+=2)
	{
		ans+=a[i];
	}
	cout<<ans;
}
```

---

## 作者：Feyn (赞：3)

[My Blog](https://www.cnblogs.com/feyn)

其实这道题的重点就是在于如何使用更加优雅的方式表示出来每个人得到的贡献。接下来来分析一下。

首先是购买点 $x$ 所需要的费用 $w_x$，这显然是逃不掉的。然后后面两个人交换游戏币的过程可以看成是购买这个点 $x$ 时，假设子树 $x$ 中对方的节点数是 $A$，$x$ 到根的路径上对方的节点数是 $B$，那么你会先给对方 $B$ 个游戏币，然后再从对方那里拿 $A$ 个。把两个过程看成的独立的，并把给对方 $B$ 个游戏币的操作延后考虑，这样可以得到一个重要的结论：当两个人都已经选完点了，那么光考虑对方给自己的游戏币数量，发现这个数量等于自己所有点的字数内对方点的数量之和。当然了，对方也可以通过这个东西来计算你需要给他的游戏币数量。

再次转化，考虑把每个点的贡献分开计算，那么它的贡献显然就是最后子树内的对方点数量减去祖先中对方点的数量，然而似乎还是没那么好计算。思考假设当前只有它一个己方点，其它都是对方点，此时它的贡献应该是 $\text{size}-\text{deep}$；假设又加入了一个点，思考新点对于它的影响。如果它们不存在祖先关系那么显然不会产生影响，如果一个是另一个的祖先，那么会让祖先“子树内的对方点”减少一个，同时祖先也会让孩子点“祖先中的对方点”减少一个，一加一减下来会发现贡献的变化量刚好抵消掉了。也就是说一个点的贡献可以看成是不变的 $\text{size}-\text{deep}$。

然后问题就显得比较明晰了，大概就变成了每个点有一个贡献 $-w_x+\text{size}_x-\text{deep}_x$ 两个人轮流贪心选择。排个序就可以了，复杂度 $O(N\log N)$。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define int long long
using namespace std;
const int N=200010;
inline void read(int &wh){
    wh=0;char w=getchar();int f=1;
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,ans,a[N],siz[N],dep[N];

struct edge{int t,nxt;}e[N<<1];
int head[N],esum;
inline void add(int fr,int to){
    e[++esum]=(edge){to,head[fr]};
    head[fr]=esum;
}
void dfs(int wh,int fa){
    siz[wh]=1;dep[wh]=dep[fa]+1;
    for(int i=head[wh],th;i;i=e[i].nxt){
        dfs(th=e[i].t,wh);siz[wh]+=siz[th];
    }
}



signed main(){
    
    #ifdef feyn
    freopen("in.txt","r",stdin);
    #endif
    
    read(m);int s1;
    for(int i=1;i<=m;i++)read(a[i]);
    for(int i=2;i<=m;i++)read(s1),add(s1,i);dfs(1,0);
    for(int i=1;i<=m;i++)a[i]=-a[i]-dep[i]+siz[i];
    sort(a+1,a+m+1);int ans=0;
    for(int i=m;i>=1;i-=2)ans+=a[i];
    printf("%lld\n",ans);
    
    return 0;
}
```

---

## 作者：Leasier (赞：2)

注意到每个位置的最终收益只与最终局面有关，且每个位置的贡献独立。

推一下式子可以发现每个点 $u$ 的贡献为 $size_u - depth_u - w_u$。

于是我们贪心地以此为关键字降序排序，则每个人都会从前往后地选。

排序即可。时间复杂度为 $O(n \log n)$。

代码：
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
} Edge;

int cnt = 0;
int w[200007], head[200007], depth[200007], size[200007];
Edge edge[200007];

inline void add_edge(int start, int end){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
}

void dfs(int u, int father){
	depth[u] = depth[father] + 1;
	size[u] = 1;
	for (int i = head[u]; i != 0; i = edge[i].nxt){
		int x = edge[i].end;
		dfs(x, u);
		size[u] += size[x];
	}
	w[u] -= size[u] - depth[u];
}

int main(){
	int n;
	ll ans = 0;
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> w[i];
	}
	for (int i = 2; i <= n; i++){
		int father;
		cin >> father;
		add_edge(father, i);
	}
	dfs(1, 0);
	sort(w + 1, w + n + 1);
	for (int i = 1; i <= n; i += 2){
		ans -= w[i];
	}
	cout << ans;
	return 0;
}
```

---

## 作者：zmza (赞：0)

结论：按 $siz_i-w_i-dep_i$ 排序。其中 $dep_i$ 表示 $i$ 有多少个祖先节点， $siz_i$ 表示 $i$ 的子树大小。

证明：我们考虑最开始没有点的时候，显然按以上结论选择。当在 $i$ 的祖先或子树内的点被选择时，若与 $i$ 不同边，则按题目所述支付游戏币。若与 $i$ 号节点同边，那么设当前选择的点为 $j$ ,分以下情况讨论：

1. 若 $i$ 为 $j$ 的祖先，那么 $i$ 的贡献会减少 $1$ 。因为 $i$ 少了一个异方后代给它做贡献。而 $j$ 的贡献会增加 $1$ 。因为 $j$ 少了一个异方祖先给它减贡献。所以它们的贡献之和是不变的。
2. 若 $i$ 是 $j$ 的后代，那么同理，贡献值和不变。

其中同方指两点由同一人选择，异方反之。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
    int sum = 0, ne = 1;
    char ch = getchar();
    for (; (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
    if (ch == '-')
        ne = -1, ch = getchar();
    for (; ch >= '0' && ch <= '9'; ch = getchar())
        sum = (sum << 3) + (sum << 1) + (ch ^ 48);
    return sum * ne;
}
const int maxn = 2e5 + 5;
vector<int> vec[maxn];
int w[maxn], dep[maxn], siz[maxn];
void dfs(int x, int fa)
{
    dep[x] = dep[fa] + 1;
    siz[x] = 1;
    for (int i : vec[x])
        if (i != fa)
            dfs(i, x), siz[x] += siz[i];
}
int id[maxn];
signed main()
{
    int n = read();
    for (int i = 1; i <= n; i++)
        w[i] = read();
    for (int i = 2; i <= n; i++)
    {
        int f = read();
        vec[i].emplace_back(f), vec[f].emplace_back(i);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++)
        id[i] = i;
    sort(id + 1, id + 1 + n, [](int a, int b){ return -w[a] - dep[a] + siz[a] > -w[b] - dep[b] + siz[b];});
    int ans = 0;
    for (int i = 1; i <= n; i += 2)
        ans += -w[id[i]] - dep[id[i]] + siz[id[i]];
    printf("%lld", ans);
    return 0;
}
```


---


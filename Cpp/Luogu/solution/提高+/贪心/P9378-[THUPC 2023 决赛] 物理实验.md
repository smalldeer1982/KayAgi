# [THUPC 2023 决赛] 物理实验

## 题目描述

为了验证新提出的猜想，物理学家小 I 需要完成 $n$ 种物理实验，其中第 $i(1 \le i \le n)$ 种实验的重要度是 $2^{-i}$。每种实验仅需要完成一次。小 I 一次只能做一种实验，且在开始了一个实验之后，不能做到一半去做另一个实验，也就是说在没有任何其他限制的情况下，小 I 完成实验的顺序可以用一个 $1$ 到 $n$ 的排列表示。

然而事情并非一帆风顺。有 $m$ 轮宇宙射线，分别会在小 I 完成了 $a_1$ 种、$a_2$ 种、$\dots$、$a_m$ 种（**注意，不是第 $a_i$ 种**）实验后轰击实验基地，保证 $1 \le a_1 < a_2 < \dots < a_m < n-m$。因此小 I 需要仔细地安排实验的顺序。

第 $j(1 \le j \le m)$ 轮宇宙射线会恰好干扰一种实验的实验仪器，其干扰的实验种类按照以下方式确定：

- 给出一个 $1$ 至 $n$ 的排列 $p_{j,1},\dots,p_{j,n}$，其中 $i$ 越靠前表示第 $i$ 种实验对这轮宇宙射线越脆弱。**每轮给出的排列不一定相同。**
- 那么在这轮宇宙射线轰击实验基地时，目前所有**未完成且未被干扰**的实验中最脆弱的一种会被干扰，之后无法进行对应实验。

在以上条件下，小 I 总共可以完成 $(n-m)$ 种实验。小 I 希望它们的重要度总和尽可能大，可是小 I 是物理学家不懂算法，所以小 I 请教于你。你需要给出合理的实验顺序，使得完成的 $(n-m)$ 种实验均未被宇宙射线干扰且重要度总和尽可能大。

## 说明/提示

**【样例解释 #1】**

小 I 第一次完成第一种实验后，宇宙射线将会轰击第二种实验的仪器，因此第二次只能完成第三种实验。容易证明该方案达到最大重要度。

**【样例解释 #2】**

在这个样例中，如果小 I 第一次完成第一种实验，那么宇宙射线将会轰击第二种实验的仪器，导致第二次只能完成第三种实验。此时重要度为 $0.625$，而样例输出给出的方案重要度为 $0.75$。

**【样例解释 #3】**

该组样例有多个合法的输出，如 `5 4 1 2` 也是一个合法的答案。

**【数据范围】**

对于所有测试数据，$3 \le n \le 600$，$1 \le m \le \lfloor \frac{n-1}{2} \rfloor$，$1 \le a_1 < a_2 < \dots < a_m < n-m$。

**【题目来源】**

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
3 1
1
1 2 3
```

### 输出

```
1 3
```

## 样例 #2

### 输入

```
3 1
1
2 3 1
```

### 输出

```
2 1
```

## 样例 #3

### 输入

```
6 2
1 3
3 2 4 5 6 1
5 4 1 3 6 2
```

### 输出

```
1 4 5 2
```

# 题解

## 作者：SDLTF_凌亭风 (赞：12)

某网校讲了这个题，并且发现还可以交题解，那我来了。

我们这样去理解这个题目：有两个人 SD 和 LTF，还有 $n$ 个物品。SD 要选 $n-m$ 个，LTF 会在 SD 取了 $a_i$ 个之后抢走一个，并且第 $i$ 次他会按照一个优先级排列 $p_i$ 抢走还在场上的优先级最高的那个物品，并且每次的优先级不一定相同。

现在你就是 SD，我是 LTF。你要找到一个方案让字典序最小。

先从简单的方面来看，让字典序更小是很好考虑的。假设最后你选择的物品塞进了一个集合 $S$，一开始他是空的，所以你的任务就是：已知一个集合 $S$ ，问是否有方案得到 $S$。

注意到 $2^{-i}\geq \sum_{k = i + 1}^{n}2^{-k}(i\geq 1)$，优先满足前面的显然更优，于是你就**让编号从小往大开始枚举**。

那我就要开始打乱你的计划了。

假设这是我第一次取，我找到一个 $t$，使得 $p_1, p_2, \cdots, p_{t - 1}$ 所对应的物品全部被你拿走了，但是 $p_t$ 对应的物品正好没有，那按照优先级从高到低的规则，我肯定要拿走这个物品，换句话说，$p_1, p_2, \cdots, p_{t - 1}$ 必须在**前** $a_1$ **次取走**。

但是你这时候就能尝试第二次取了吗？不行！因为你不知道我第一次取了什么。

但你又发现，$p_t$ 在第 $a_1+1$ 次之后肯定是选不了的，要么是你选了要么是我选了。选不了的你不如就直接放掉让我抢走。

这样子再来考虑我的第二次抢夺，那就变成了和第一次一样的问题。

这样你依次考虑我每次抢夺，得到最初的集合 $S$ 中所有元素最晚在什么时候取走。按照最晚取走的时间排序填入方案并判断是否合法即可。

$O(n^3)$ 的复杂度，恭喜你完成实验！

---

## 作者：Alex_Wei (赞：8)

### B. [P9378 [THUPC 2023 决赛] 物理实验](https://www.luogu.com.cn/problem/P9378)

如果可以判断答案是否包含集合 $S$，就可以按权值从大到小加实验并检查是否合法。

依次处理每一轮宇宙射线：按脆弱度从小到大枚举每个实验。对于已经考虑过的实验，跳过。

- 若当前实验属于 $S$，则必须在这一轮宇宙射线之前完成实验。
- 若当前实验不属于 $S$，则一定选择让宇宙射线轰击该实验，否则不优（调整即可）。退出这一轮宇宙射线。

若退出第 $i$ 轮宇宙射线时，必须完成的实验数量大于 $a_i$，则答案不可以包含集合 $S$。否则将剩下所有属于 $S$ 但未被完成的实验加入序列，可得对应构造。

时间复杂度 $\mathcal{O}(n ^ 3)$。[代码](https://uoj.ac/submission/632975)。

---

## 作者：xyzfrozen (赞：7)

字典序/次幂贪心模型。

显然从 $1\sim n$，我们选择的答案是一个前缀状态，保住一个胜过后面所有的，考虑 $2^x \gt 2^{x-1}+2^{x-2}+\cdots$。

问题等价于，当前有答案集合 $S$，求加入元素 $i$ 是否合法。

判定就是枚举每一轮宇宙射线：

我们考虑到已经有 $S$ 了，我们可以直接找出来每轮宇宙射线轰掉哪个，即未被轰掉，未被保护的第一个元素。

此时可以得到另一个性质 ，$S$ 中的每一个元素都必须要在被轰掉之前做完，判定时候即可求出每一个元素最晚的做掉时间，记为 $T_i$。

问题等价于，我们填序列 $P$，要填 $|S|+1$ 位，是否能够满足每一个元素不被轰掉。

从小到大排序  $T_i\,[i\in S]$，直接判定 $\forall i\,,i \leq T_i$，这样一定最优，考虑任意交换更劣。

从小到大枚举 $i$，$O(n)$，判定 $O(nm)$，总复杂度 $O(n^2m)$。

```cpp
#include<bits/stdc++.h>
#define pt putchar(' ')
#define nl puts("")
#define pi pair<int,int>
#define pb push_back
#define go(it) for(auto &it:as[x])
using namespace std;

const int N=610;
int n,m,cnt;
int a[N],p[N][N],S[N],T[N],dead[N],now[N];

int fr(){
    int x=0,flag=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9'){
        x=x*10+(ch-'0');
        ch=getchar();
    }
    return x*flag;
}
void fw(int x){
	if(x<0) putchar('-'),x=-x;
    if(x>9) fw(x/10);
    putchar(x%10+'0');
}
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
bool cop(int a,int b){return T[a]<T[b];}

bool check()
{
	memset(T,0x3f,sizeof T);
	memset(dead,0,sizeof dead);
	
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			int x=p[i][j];
			if(S[x]) T[x]=min(T[x],a[i]);
			else if(!dead[x]) {dead[x]=1;break;}
		}
	
	int idx=0;
	for(int i=1;i<=n;i++)
		if(S[i]) now[++idx]=T[i];
	sort(now+1,now+1+idx);
	for(int i=1;i<=idx;i++)
		if(i>now[i]) return 0; 
	return 1;
}

int main()
{
	n=fr(),m=fr();
	for(int i=1;i<=m;i++) a[i]=fr();
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			p[i][j]=fr();
	for(int i=1;i<=n;i++)
		S[i]=1,S[i]=check();
	check(); //怕最后一次check失败T不对
	int idx=0;
	for(int i=1;i<=n;i++)
		if(S[i]) now[++idx]=i;
	sort(now+1,now+1+idx,cop);
	for(int i=1;i<=idx;i++) fw(now[i]),pt;
	return 0;
}
```



---

## 作者：Erica_N_Contina (赞：5)

## 思路

> 思路同 dingshengyang 大佬，但本文可能解释更加详细。

因为其中第 $i(1 \le i \le n)$ 种实验的重要度是 $2^{-i}$，所以我们尽可能要完成编号小的实验，并且是不惜一切代价（即贪心），因为 $2^{-i}>2^{-j}+s^{-k}(j,k>i)$，所以如果可以选 $i$ 却没有选，是不可弥补的！

所以我们可以考虑从小到大枚举所有实验，定义集合 $S$ 为需要完成的实验。当我们枚举到一个实验 $i$，我们先二话不说把 $i$ 加入 $S$ 中，然后再判断是否无法实现。如果不能实现，我们再把 $i$ 从 $S$ 中删除。

那么我们怎么样判断当前的 $S$ 是否可以实现呢？我们可以暴力判断。

我们枚举每一次宇宙射线。假设目前是第 $j$ 次，$p_{j,k}=i$，那么我们找到 $p_{j}$ 中第一个不在 $S$ 中的之前没有被影响过的 $p_{j,t}$，标记其被射线影响。

在枚举到这个 $p_{j,t}$ 前，对于那些在 $S$ 中的 $p_{j,k'}$，我们要尝试更新它们的 $lim$。$lim$ 记录了这个实验在第几次实验之前（含）必须被完成。想一想，假设当前射线影响的实验是 $p_{j,t}$，那么对于 $p_{j,k'}(k'<t)$，射线既然没有影响它们，那么就说明要么它们之前已经被影响了，要么就是在射线之前就已经完成了。

```C++
for(int i = 1;i <= m;i ++){
        for(int j = 1;j <= n;j ++){
            if(used[p[i][j]])continue;
            if(!c[p[i][j]]){
                used[p[i][j]] = 1;
                break;
            }else{
                lim[p[i][j]] = min(a[i],lim[p[i][j]]);
            }
        }
    }
```


  

处理出 $lim$ 之后，我们再来判断当前的 $S$ 是否合法。我们将所有 $lim$ 加入到数组中，从小到大排序。如果存在 $lim_i>i$ 的情况，就说明不合法了。$lim_i>i$ 也就是说实验 $i$ 要求在前 $lim_i$ 个实验中完成，但是按照最优情况，实验 $i$ 也必须在 $lim_i$ 个实验完成后再进行，这样的话这个实验就会被某个宇宙射线影响，当前 $S$ 不成立。

```C++
cnt=0;
    for(int i = 1;i <= n;i ++){
        if(c[i]){
            tmp[++cnt]=lim[i];
        }
    }
    sort(tmp+1,tmp+cnt+1);
    for(int i = 1;i<=cnt;i++){
        if(i>tmp[i])return 0;
    }
    return 1;
```


最后输出答案时，我们也是把实验按照其 $lim$ 从小到大排序，然后输出。

## 代码

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=1e3+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e9;

int n,m,p[N][N],q,T,s[N],ans[N];
int used[N],lim[N],in[N],a[N];
int cnt,tmp[N];

bool check(){
	
	memset(used,0,sizeof (used));
	memset(lim,0x3f3f,sizeof (lim));
	 for(int i = 1;i <= m;i ++){
        for(int j = 1;j <= n;j ++){
            if(used[p[i][j]])continue;
            if(!in[p[i][j]]){
                used[p[i][j]] = 1;
                break;
            }else{
                lim[p[i][j]] = min(a[i],lim[p[i][j]]);
            }
        }
    }
    
    cnt=0;
    for(int i = 1;i <= n;i ++){
        if(in[i]){
            tmp[++cnt]=lim[i];
        }
    }
    sort(tmp+1,tmp+cnt+1);
    for(int i = 1;i<=cnt;i++){
        if(i>tmp[i])return 0;
    }
    return 1;
}

bool cmp(int a,int b){
	return lim[a]<lim[b];
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++)cin>>p[i][j];
		
	}
	
	for(int i=1;i<=n;i++){
		in[i]=1;
		if(!check())in[i]=0;
	}
	check();//注意还需要check一遍来更新lim
	cnt=0;
	for(int i=1;i<=n;i++){
		if(in[i])ans[++cnt]=i;
	}
	sort(ans+1,ans+cnt+1,cmp);
	for(int i=1;i<=cnt;i++)cout<<ans[i]<<' ';
	return 0;
}



```




---

## 作者：柳易辰 (赞：2)

# THUPC 2023 B 物理实验

 ## 题意简述

有 $n$ 个物品，你需要取 $n-m$ 个，要求取到的物品编号从小到大排序后字典序最小。但是有个坏人会在你取了 $a_1,a_2,\dots,a_m$ 个后取一个，第 $i$ 次会按照一个对所有物品的偏好排列 $p_i$ 选择双方都没取过的他最偏好的那个物品，每次的偏好不一定相同。你需要给出一个方案达到你的目的。

## 思路

思路上同官方题解，部分参考了 Github 上的官方题解。

显然，$\forall i\in \N_+,2^{-i}>\sum_{j=i+1}^n2^{-j}$，因此题意可以转化为物品排序后字典序最小。

显然可以按编号从小到大考虑，考虑维护已选物品的集合 $S$， 从小到大贪心地尝试往 $S$ 里添加新物品并判断是否合法。

假设坏人第一次取的时候偏好排列是 $p_1,p_2,\dots,p_n$，首先找到一个 $k$ 使 $p_1,p_2,\dots,p_{k-1}$ 均在 $S$ 里并且 $p_k$ 不在，那么 $p_1,p_2,⋯, p_{k-1}$ 都必须在 $1∼a_1$ 次取走。但是这种做法不能直接推广到第 $i$ 次，因为这样我们没有考虑第 $1$ 次到第 $i-1$ 次坏人取了什么。

我们可以依次考虑坏人每次取，得到最初的集合 $S$ 中所有元素分别最晚在什么时候取走，按照最晚取走的时间排序填入方案并判断是否合法即可。这样我们在判断合法的同时构造了方案。

时间复杂度 $O(mn^2)$，空间复杂度 $O(nm)$

## 代码

LOJ 评测机 -Ofast -C++20，未开启 IO 优化

[1.34s / 1M / 1.1K](https://loj.ac/s/1909727)

---

## 作者：OMITW (赞：2)

# 前言
今天模拟赛的第二题刚好是此题。太感动了 czz 大神尽然会在第二题放蓝题。之前的都是紫题。现在打打此题的题解进行巩固。

# 思路推导

理解题目后，先看看数据范围 $ 3 \le n \le 600 $，$ 1 \le m \le \lfloor\frac{n-1}{2} \rfloor $。这足够我们用 $ O(n^2m) $ 的时间跑过。那我们就可以直接暴力了。

因为我们需要的是重要度总和最大,所以进行贪心。从最小的点开始。

定义数组 $ bj[i] $ 表示这个点必须进行保护。那么我们就可以进行循环普判断有多少个点要保护。若果数量大于射线射的时间。那么此点不可被保护。最后用一个 `vector` 统记有哪些点要保护。注意：有可能有些点没有被访问，但是也是必须保护的。所以还要开个循环判断是否加入 `vector`。

# Code
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3,"Ofast","inline")
using namespace std;
const long long MAXN=605,mod=998244353;
long long n,m,a[MAXN],b[MAXN][MAXN],bj[MAXN],f[MAXN],k,flag;
int main()
{
	cin>>n>>m;
	for(register int i=1;i<=m;i++)cin>>a[i];
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++)
			cin>>b[i][j];
	for(register int tim=1;tim<=n;++tim)
	{
		bj[tim]=1;
		vector<int> g;
		memset(f,0,sizeof(f));
		for(register int i=1;i<=m;++i)
		{
			for(register int j=1;j<=n;++j)
			{
				if(f[b[i][j]])continue;
				f[b[i][j]]=1;
				if(!bj[b[i][j]])break;
				g.push_back(b[i][j]);
			}
			if(g.size()>a[i])
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			bj[tim]=flag=0;
			continue;
		}
		for(register int i=1;i<=n;++i)
			if(!f[i]&&bj[i])g.push_back(i);
		if(g.size()==n-m)
		{
			for(register int i=0;i<g.size();++i)
				cout<<g[i]<<" ";
			return 0;
		}
	}
}
```

---

## 作者：dingshengyang (赞：1)

昨天（9 月 30 日），洛谷网校的 @verdandi 老师讲了这题，个人认为老师的思路十分的清晰，但是还是献丑写一篇题解，帮助有困难的同学们。



如果你看过 $4$ 个样例，你会发现，每一个样例都有 $1$ 号实验。

为啥？因为我们容易得到 $2^{-k} = 2^{-k-1}+ 2^{-k-2} + \cdots +2^{-\infty}$。

其实这是一个无限逼近的过程，有兴趣的读者可以用等比数列求和公式去证明。

所以其实我们的策略就很明显了：不惜一切代价保 $i$，只要其不与 $j\ (j < i)$ 冲突即可。

就像这样：

```cpp
for(int i = 1;i <= n;i ++){
	c[i] = 1;
	if(!check())c[i] = 0;
}
```
现在我们有一个任务集合 $S$，$S$ 中的实验一定、一定要做。

其中 $c_i$ 表示第 $i$ 个实验是否要保。所以，$S = \{i\} \ (c_i = 1)$。

然后聊一下如何判断解的合法性。

如果你在我的博客查看这篇题解，就会发现标题是“论炮灰的合理利用”。这是什么意思呢？

这里，我们称所有 $i \not \in S$ 为炮灰，活该被宇宙射线轰。


对于每一束宇宙射线，在它遇到一只野生的炮灰之前，所有的受保护的实验必须在它来临之前做完。

于是我们令 $lim_i$ 表示 $i$ 号实验必须在 $lim_i+1$ 这个时间之前被完成（如果无限制则 $lim_i = \infty$）。

最后就是说，我们的时间够不够。于是按照 $lim_i$ 对每一个被保护的实验排序。说明前 $lim_i$ 时间有 $i$个实验要做。如果 $i > lim_i$，时间不够，即此 $S$ 不合法，应当从 $S$ 中删除新加入的元素。

顺便说一下，死掉的炮灰不能重复利用，因此用一个数组记录一下就好。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 605;
int c[N],t[N];
int p[N][N];
int lim[N];
int dead[N];
int n,m;
int check(){
    memset(dead,0,sizeof(dead));
    memset(lim,0x3f,sizeof(lim));
    for(int i = 1;i <= m;i ++){
        for(int j = 1;j <= n;j ++){
            if(dead[p[i][j]])continue;
            if(!c[p[i][j]]){
                dead[p[i][j]] = 1;
                break;
            }else{
                lim[p[i][j]] = min(t[i],lim[p[i][j]]);
            }
        }
    }
    vector<int> able;
    for(int i = 1;i <= n;i ++){
        // cout << lim[i] << " ";
        if(c[i]){
            able.push_back(lim[i]);
        }
    }
    // cout << endl;
    sort(able.begin(),able.end());
    for(int i = 0;i < (int)able.size();i ++){
        if(i + 1 > able[i])return 0;
    }
    return 1;
}
int main(){
    cin >> n >> m;
    for(int i = 1;i <= m;i ++){
        cin >> t[i];
    }
    for(int i = 1;i <= m;i ++){
        for(int j = 1;j <= n;j ++){
            cin >> p[i][j];
        }
    }
    for(int i = 1;i <= n;i ++){
        c[i] = 1;
        if(!check())c[i] = 0;
    }
    check();
    vector<int> ans;
    for(int i = 1;i <= n;i ++){
        if(c[i])ans.push_back(i);
    }
    sort(ans.begin(),ans.end(),
    [](int x,int y){return lim[x] < lim[y];});
    for(auto x:ans)cout << x << " ";
    return 0;
}
```


















---

## 作者：Jerrycyx (赞：0)

首先，因为第 $i$ 种实验的重要度为 $2^{-i}$，即依次为 $\frac{1}{2},\frac{1}{4},\frac{1}{8},\dots,\frac{1}{2^n}$，所以**某一个实验的重要程度大于它后面所有实验的重要程度之和**，选了它就一定最优。由此便引出贪心策略：**编号从小到大尽量选**，要选某一个实验时后面的实验可以随便牺牲。

按编号从小到大枚举实验，然后检查是否能在条件下完成这些实验。设当前要检查第 $i$ 次实验是否能选，前面的实验都已经确定了选或不选。要想让 $i$ 及以前的尽量不被干扰，自然最保险的策略就是**后面全部都不去试图选择**，好给前面的实验做挡箭牌。

所以，我们的检查过程相当于是一个模拟过程。**先不考虑规定时间内能否赶在宇宙射线到来之前选走实验**，假设已经确定要选的实验全部都能赶在被干扰之前选择到。

在这样的条件下模拟宇宙射线轰击，那么已确定的实验在某些时刻必须已经被做完了（否则它就会被影响），**对于每个已确定的实验，对这些时刻取最小值就是选择它的最后期限**，在这以后才选它都会导致它被干扰，从而不符合我们的假设。

然后还要考虑实际情况下到底能不能在规定时间内做完这些实验（即上文忽略的那个条件）。这里还有另外一个贪心策略：**最优做实验顺序应该是最后期限从小到大的顺序**。所以我们已确定的实验的最后期限这样排序后，如果有某一个实验即使按照最优顺序选取也要超出最后期限，那么这样的实验选择方案就不合法。

处理验证完所有的试验后，已经确定实验的选择是正确可行且最优的，再用一遍前面所说按照最后期限排序的方法就可以得到答案。

时间复杂度 $O(n^2 m)$。

```cpp
#include<cstdio>
#include<cstring>
#include<numeric>
#include<algorithm>
using namespace std;

const int N=605,M=305;
int n,m,a[M],p[M][N];

bool s[N],d[N]; //s为当前所选择的实验，d为已经受干扰的实验
int t[N],q[N]; //t为最后期限，q为做实验的顺序
bool check()
{
	memset(d,false,sizeof(d));
	memset(t,0x3f,sizeof(t));
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			int x=p[i][j];
			if(s[x]) t[x]=min(t[x],a[i]);
			else if(!d[x])
			{
				d[x]=true; //宇宙射线成功干扰x
				break;
			}
		}
	sort(q+1,q+n+1,[](int x,int y){return t[x]<t[y];});
	for(int i=1;i<=n;i++)
		if(i>t[q[i]]) return false;
	return true;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&p[i][j]);
	iota(q+1,q+n+1,1); //填充q为1~n
	for(int i=1;i<=n;i++)
	{
		s[i]=true;
		if(!check()) s[i]=false;
	}
	check();
	for(int i=1;i<=n;i++)
		if(!d[q[i]]) printf("%d ",q[i]);
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

前言：本题作为一道贪心题，十分优秀，**从一开始的纯粹循环搜索，到之后的考虑状态覆盖**，利用这一性质找出何时才是非法状态，让我受益匪浅。


# 题目解析：
首先，我们可以想出，从 $1$，$2$，$3$ 这样一一枚举，再套一个循环找在此时刻哪些数是非法的，这样，我们很容易就写过前两个样例，但是，我们发现从第三个样例我们就有点发难了，因为我们根据上述思路枚举发现结果是 $1$，$2$，$4$，$6$，但是结果是 $1$，$2$，$4$，$5$，差一个。

之后，我们可以考虑，我们在枚举的过程中可以发现，在考虑 $5$，$4$ 时，因为第三个时刻时就有轰炸，这两个实验做不了，而原来我们并没有像这样全局考虑不对的地方，所以，我们定义是个序列，还是从第一层循环取数加进去，但是，我们每加一个数，就全局考虑此时的选法是否正确，我们可以找这个实验**至少**什时候就要做完，如果，此时这个限制时刻会小于我们此时的时刻（当然你说他是此时的答案数也没事），之后，我们找在这么多打击中有哪些不在答案序列中的会被闪击掉，首先去掉这些（反正已经嘎了），因为在这个去掉的数之后都是在目前幸存的。如果在答案序列，我们计算它的限制时间，求是此时打击来临的时间靠近还是原先的时间靠近。

这一步做完后，我们还要将答案序列的每一个值放入一个新数组，同时进行排序，表示我所选的实验有哪些限制的时间，如果此时的 $i$ 大于限制时间，说明有一个实验在之前就要做掉，因此不合法。

# 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
int a[1009];
int p[1009][1009], ls[601], tim[601];
bool vis[601];
vector<int> ans;
bool gg[609], kil[601];
bool cmp(int a, int b)
{
    return tim[a] < tim[b];
}
bool check()
{
    memset(gg, 0, sizeof(gg));
    memset(kil, 0, sizeof(kil));
    memset(ls, 0, sizeof(ls));
    memset(tim, 0x3f, sizeof(tim));
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (kil[p[i][j]])
            {
                continue;
            }
            if (!vis[p[i][j]])
            {
                kil[p[i][j]] = 1;
                break;
            }
            else
            {
                tim[p[i][j]] = min(a[i], tim[p[i][j]]);
            }
        }
    }
    int l = 0;
    for (int i = 1; i <= n; i++)
    {
        if (vis[i])
        {
            ls[++l] = tim[i];
        }
    }
    sort(ls + 1, ls + l + 1);
    // for (int i = 1; i <= )
    for (int i = 1; i <= l; i++)
    {
        if (i > ls[i])
        {
            return 0;
        }
    }
    return 1;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cin >> p[i][j];
        }
    }
    for (int i = 1; i <= n; i++)
    {
        vis[i] = 1;
        vis[i] = check();
        // if (vis[i])
        // {
        //     cout << i << ' ';
        // }
    }
    bool p = check();
    int ans[633], l = 0;
    for (int i = 1; i <= n; i++)
    {
        if (vis[i])
        {
            ans[++l] = i;
        }
    }
    sort(ans + 1, ans + l + 1, cmp);
    for (int i = 1; i <= l; i++)
    {
        cout << ans[i] << ' ';
    }
    return 0;
}
```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

有 $n$ 次任务，第 $i$ 次任务收益为 $2^{-i}$。

有 $m$ 次破坏，第 $i$ 次破坏会在完成了 $a_i$ 次任务后发生。保证同一时刻内只会发生一次破坏，且 $\forall i\lt j,a_i \lt a_j  \lt n - m$。

具体地，对于第 $i$ 次破坏，有一个长度为 $n$ 的排列 $p_i$。

破坏发生时，会找到一个满足以下条件的 $k$。

- 任务 $p_{i,k}$ 没有被完成。
- 任务 $p_{i,k}$ 可以被完成。
- $k$ 是满足上述条件中最小的。

然后令 $p_{i,k}$ 不可被完成。

容易发现你可以完成 $n-m$ 个任务。你需要安排任务完成的顺序，最大化完成的任务的收益和。输出这个顺序。

$3\leq n,m \leq 600$

## 思路

lg 网校的题，Verdandi 声音很好听（为什么大家都是 xzy 就我如此之弱啊……）

首先不难发现本题中有如下事实

**如果任务 $[1,i-1]$ 中的任务要么以完成，要么不可完成。则只要可以完成 $i$，则必定完成 $i$。因为这样做一定最优。**

Proof：本质上等价于证明：

$$
2^{-i}\gt\sum_{k=i+1}^{n}2^{-k}
$$

证明如下：

$$
\begin{aligned}
&2^{-i}\gt\sum_{k=i+1}^{n}2^{-k}\\
&2^{n-i}>\sum_{k=i+1}^{n}2^{n-k}\\
&2^{i}>\sum_{k=n-i+1}^{n}2^{n-k}\\
&2^{i}>\sum_{k=0}^{i-1}2^{k}
\end{aligned}
$$

而第四个式子的正确性是显然的（可以使用二进制分拆，或者等比数列求和来证明）。

然后我们可以从 $1$ 至 $n$ 枚举每一个任务去考虑这个任务是否可以完成。这样就有了贪心的单调性。

具体来说，对于每一次判断，我们可以计算出每一个被选出来要做的实验中，最晚在第几次做才能保证不会被破坏。对于其他的实验，可以在他之前被破坏，我们无需考虑是否保存这一个（单调性）。

然后对于每一个被选出来要做的实验，按照最晚完成时刻排序，就是当前的完成次序。

枚举每一个要做的实验，如果这个实验的完成次序比最晚完成次序要大，则显然加入这一个任务是无法办到的（单调性，不可能为了这一个实验踢掉前面的实验）。

于是就可以以 $O(n^2 m\log n)$ 的时间复杂度完成本题。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n,m;
const int N = 605;
int a[N],p[N][N];
bitset<N> killed, choiced;
int tim[N];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>a[i];
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++) cin>>p[i][j];
    }
    vector<int> v;
    for(int i=1;i<=n;i++){
        choiced[i] = 1;
        killed.reset();
        fill(tim + 1, tim + n + 1, INT_MAX);
        for(int j=1;j<=m;j++){
            for(int k=1;k<=n;k++){
                if(killed[p[j][k]]) continue;
                if(choiced[p[j][k]]) tim[p[j][k]] = a[j];
                else{
                    killed[p[j][k]] = 1;
                    break;
                }
            }
        }
        v.clear();
        for(int j=1;j<=i;j++){
            if(choiced[j]) v.push_back(j);
        }
        sort(v.begin(), v.end(), [&](int x,int y){
            return tim[x] < tim[y];
        });
        bool flag = 1;
        for(int j=0;j<v.size() && flag;j++){
            if(j + 1 > tim[v[j]]) flag = 0;
        }
        if(!flag) choiced[i] = 0;
    }
    killed.reset();
    fill(tim + 1, tim + n + 1, INT_MAX);
    for(int j=1;j<=m;j++){
        for(int k=1;k<=n;k++){
            if(killed[p[j][k]]) continue;
            if(choiced[p[j][k]]) tim[p[j][k]] = a[j];
            else{
                killed[p[j][k]] = 1;
                break;
            }
        }
    }
    v.clear();
    for(int j=1;j<=n;j++){
        if(choiced[j]) v.push_back(j);
    }
    sort(v.begin(), v.end(), [&](int x,int y){
        return tim[x] < tim[y];
    });
    for(int i : v) cout<<i<<' ';
    return 0;
}

```



---


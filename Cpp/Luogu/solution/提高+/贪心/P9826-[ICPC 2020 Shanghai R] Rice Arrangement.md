# [ICPC 2020 Shanghai R] Rice Arrangement

## 题目描述

Wowo 是一位好客的新疆大叔。$k$ 位客人将在 Wowo 家中围着一张大圆桌享用维吾尔抓饭（一种传统的维吾尔食物）。圆桌周围均匀地放置了 $n$ 把椅子（$n \ge k$）。每位客人坐在一把椅子上，并且没有两位客人坐在同一把椅子上。桌子上有 $k$ 碗维吾尔抓饭。每碗抓饭都放在某把椅子旁边（\textbf{无论是否}有客人坐在上面）。没有两碗抓饭放在同一位置。

作为服务员，你需要为每个人分配一碗维吾尔抓饭。桌子可以旋转，因此每次你可以顺时针或逆时针旋转 $\frac{2\pi}{n}$ 度。碗会随着桌子一起旋转，而椅子和客人不动。当一碗维吾尔抓饭在某位客人面前时，他可以选择拿起它或等待另一碗。

你希望尽量减少桌子旋转的总次数，以便每个人都能尽快用餐。

（正式定义：桌子的边界是一个圆。$n$ 把椅子位于圆上的 $n$ 个点，其凸包是一个有 $n$ 个顶点的正多边形。我们按逆时针顺序将这些点命名为 $0,\ldots, n-1$。第 $i$ 碗抓饭最初位于点 $b_i$ ($0\le b_i<n$)。第 $i$ 位客人最初位于点 $a_i$ ($0\le a_i < n$)。如果你逆时针旋转桌子，位于点 $b_i$ ($1\le i\le k$) 的碗将在旋转后移动到点 $(b_i+ 1) \bmod n$。如果你顺时针旋转桌子，位于点 $b_i$ ($1\le i\le k$) 的碗将在旋转后移动到点 $(b_i-1) \bmod n$。($x\bmod n$ 定义为最小的非负整数 $r$ 使得 $x-r$ 是 $n$ 的倍数。)）

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
1
4 2
0 3
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
1
14 5
0 12 13 8 9
9 2 6 13 5```

### 输出

```
6```

# 题解

## 作者：ZJle (赞：1)

我们将所有的 $a,b$ 递增排序。

首先我们可以知道我们把每个人和对应的手抓饭在圆盘上连线，那么这些连线是不会相交的。

则因为有结构推论,所以若 $a_i$ 与 $b_j$ 相配,则 $a_i+k$ 一定与 $b_j+k$ 相配。 

因为人数很少,所以我们直接枚举 $a_1$ 与哪盘饭匹配,然后就得到了 $n$ 个对。

先假设每个对都在顺时针旋转,得到需要旋转的距离 $syf_i=a_i-b_j$ 。

显然,其可以顺时针旋转 $syf_i$ ,亦可以逆时针旋转 $m-syf_i$ 得到。

可以发现,最终结果,一定是对小的 $syf_i$ 顺时针,大的 $syf_i$ 逆时针。

于是我们对 $d_i$ 排序后,枚举哪一半顺时针即可。

时间复杂度 $O(n^2 \log n)$

### 码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+10;
int T, a[N], b[N], n, k, maxn;
pair<int, int> syf[N];
#define fi first
#define se second
int ans=0x3f3f3f3f3f;
void solve()
{
    cin>> n >> k;
    for (int i = 1; i <= k; i++) cin>> a[i];
    for (int i = 1; i <= k; i++) cin>> b[i];
    sort(a + 1, a + k + 1);
    sort(b + 1, b + k + 1);
    ans=0x3f3f3f3f3f3f;
    for (int i = 1; i <= k; i++)
    {
        memset(syf, 0, sizeof(syf));
        for (int j = 1; j <= k; j++)
        {
            syf[j].fi= (a[j] + n - b[(j + i - 1) % k + 1]) % n;
            syf[j].se = (b[(j + i - 1) % k + 1] + n - a[j]) % n;
        }
        sort(syf + 1, syf + k + 1);
        maxn = 0;
        for (int j = k; j >= 0; j--)
        {
            ans = min(ans, syf[j].fi + maxn + min(syf[j].fi, maxn));
            maxn = max(maxn, syf[j].se);
        }
    }
    cout << ans << '\n';
}
auto main() -> signed
{
    cin >> T;
    while(T--){
        solve();
    }
    return 0;
}
```


---

## 作者：chen_zhe (赞：0)

以下内容转载自官方题解：

有一个结论是：我们把每个人和对应的手抓饭在圆盘上连线，那么这些连线是不会相交的。

这样我们可以直接枚举第一个人对应的手抓饭编号，然后转一圈计算答案。复杂度 $O(N^2\log N)$，$\log$ 是排序。

结论的证明如下：

- 随便固定圆上一个方向为左（例如顺时针），另一个方向为右。枚举了往左和往右转多少以后，每碗手抓饭都在一个区间上出现。固定一组可行解。把人画在大圈上，手抓饭画在小圈上，人 $i$ 吃了手抓饭 $j$ 就在他们之间连一条边。边要画在两个圆之间手抓饭 $j$ 覆盖的区间内。每个手抓饭覆盖的区间在这碗手抓饭左边的成为左臂，右边的称为右臂。所有 $k$ 条边两两之间要避免不必要的相交，即仅当（1）两条连线的区间有交且连线为一个人连接饭的左臂另一个人连接另一个饭的右臂，或者（2）两条连线的区间为包含关系时，两条连线才有交。
- 假设人 $i$ 吃手抓饭 $j$ 连的边和人 $k$ 吃手抓饭 $l$ 的边有交。不妨假设人 $i$ 在饭 $j$ 的左臂里（否则镜像）。
- 假如人 $k$ 在人 $i$ 到饭 $j$ 连线的区间里（此时人 $k$ 在饭 $j$ 的左臂）。假如人 $k$ 在饭 $l$ 的左臂里，为了两条连线有交，饭 $l$ 也在人 $i$ 到饭 $j$ 连线的区间里。这样因为每份饭的左臂长度一样，人 $i$ 也在饭 $l$ 的左臂里。现在连接人 $i$ 和饭 $l$，人 $k$ 和饭 $j$，交点没有了。
- 假如人 $k$ 不在人 $i$ 到饭 $j$ 连线的区间里。假如人 $k$ 在饭 $l$ 的左臂。此时和上面情况一样，只是人 $i$ 和人 $k$ 名字换了，饭 $j$ 和饭 $l$ 名字换了。假如人 $k$ 在饭 $l$ 的右臂。此时人 $k$ 也在饭 $j$ 的右臂，因为把饭 $l$ 的右臂沿着饭 $l$ 到饭 $k$ 的连线向人 $k$ 移动（向右），移动到两条连线的交点，再移动到饭 $j$（依然向右），就是饭 $j$ 的右臂，此时此右臂右端点已经超过人 $k$，左端点还未超过人 $k$。假如人 $k$ 到饭 $l$ 的区间包含人 $i$，此时我们可以交换人 $i$ 和人 $j$ 吃的饭使得连线不再相交。假如人 $k$ 到饭 $l$ 的区间不包含人 $i$，则饭 $l$ 在人 $i$ 到饭 $j$ 的区间内。此时饭 $l$ 的左臂必然包含 $i$，因为把饭 $j$ 的左臂沿着饭 $j$ 到人 $i$ 方向（向左）移动至交点再向左移动至 $l$ 即为饭 $l$ 的左臂，此时左臂左端点已经超过人 $i$ 且右端点还未超过人 $i$。这种情况也可以交换人 $i$ 和人 $k$ 吃的饭。
- 在以上所有情况里的交换都不会导致 $ijkl$ 之间的两条连线和其他 $k-2$ 条连线的交点新增。（因为只是把原来两条线从他们之间的交点切开一点点。然后还有可能有连线绕远路被简化。）

综上我们总能找到一种方法保证解的可行性同时减少一个交点。因为交点个数是有限的，必然存在一个没有交点的可行解。

---


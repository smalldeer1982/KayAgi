# [THUPC 2024 初赛] 转化

## 题目背景

小 E 在玩 Somzig 游戏的时候因为操作时间不够绷不住了，于是就有了这个题。

## 题目描述

小 E 有 $n$ 种颜色的球，其中第 $i$ 种有 $a_i$ 个。有两类工具，第一类可以把一个指定颜色的球变成一个**任意**颜色的球；第二类可以把一个指定颜色的球变成两个**这种**颜色的球。一个变化之后的球也可以通过工具产生新的变化。关于第 $i$ 种颜色的第一类工具有 $b_i$ 个，第二类工具有 $c_i$ 个。小 E 想知道，如果每一**个**工具最多只能使用一次，那么对于每种颜色 $i$，第 $i$ 种颜色的球最后最多能有多少个。以及，小 E 最后最多能有多少个球。

## 说明/提示

### 子任务

保证 $1\le n \le 351493$。

保证 $0\le a_i,b_i,c_i\le 10^9$。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
2
1 2
1 2
1 0
```

### 输出

```
4 3
4
```

# 题解

## 作者：jr_linys (赞：23)

**[P9965 [THUPC 2024 初赛] 转化](https://www.luogu.com.cn/problem/P9965)**

2021/1/25 修改了细节。

赛时挂了两发，讲下我的思路。  
有两个道具嘛，转换和分裂。

首先为了方便，我提出一个超空间的概念——球球本没有颜色，只是装他们的箱子有颜色，使用转化时，不着急确定放到哪个箱子，先放超空间里。

若初始有球，先把分裂用完。  
不用转换就相当于转成自己，所以把球尽可能扔超空间里。

如果这时超空间里没球，那么结局已定。  
考虑有球。
- - -
第一问

那些初始有球的已经没用了。  
初始没球的就可能有用，如果转换 $\ge1$，那么可以扔一个球进去，它会吐出起码能回本或更多的球回超空间。  
最后把超空间的球扔到你要的纸箱，注意不要算重自己的贡献。
- - -
第二问

把上面的操作做了，怎么算也不亏。  
接下来都是没有球和转化的无赖，按照其分裂从大到小把超空间的球分出去。

实现仅供参考，时间复杂度 $O(n\log n)$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=351493;
int n,a[N+5],b[N+5],c[N+5],x[N+5],y[N+5],sum,add;
vector<int> v;

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1;i<=n;++i) cin>>b[i];
	for(int i=1;i<=n;++i) cin>>c[i];
	for(int i=1;i<=n;++i){
		if(a[i]){
			a[i]+=c[i],c[i]=0;
			x[i]=min(a[i],b[i]);//吐到超空间的球
			sum+=x[i];//总初始
		}else{
			if(b[i]>=1) y[i]=min(1+c[i],b[i])-1;//为超空间增加的球
			add+=y[i];//总增加
		}
	}
	if(sum==0){
		int ans=0;
		for(int i=1;i<=n;++i) ans+=a[i],cout<<a[i]<<' ';
		cout<<'\n'<<ans;
		return 0;
	}
	sum+=add;
	for(int i=1;i<=n;++i)
		if(a[i]) cout<<sum+a[i]-x[i]<<' ';
		else cout<<sum+c[i]-y[i]<<' ';
	
	int ans=sum;
	for(int i=1;i<=n;++i)
		if(a[i]) ans+=a[i]-x[i];
		else if(b[i]) ans+=(1+c[i])-(y[i]+1);
	for(int i=1;i<=n;++i) if(a[i]==0&&b[i]==0) v.push_back(c[i]);
	sort(v.begin(),v.end(),greater<int>());
	for(int x:v) if(sum-->0) ans+=x;
	cout<<'\n'<<ans;
}
```

---

## 作者：LuoFeng_Nanami (赞：2)

一道有趣的贪心题。

先看第一问。

首先，对于所有的 $c_i$，能做的事只有一件：在 $a_i \ne 0$ 时分裂，每一次分裂都是将第 $i$ 中颜色的 $1$ 个球分裂成同种颜色的 $2$ 个球，所以每一次分裂后，这种颜色的球的总个数会 $+1$。

而对于所有的 $b_i$，能做的事也就是在 $a_i \ne 0$ 时把一个第 $i$ 种颜色的球转化为一个任意颜色的球。

总结完这两种道具的作用后，我们会发现，如果我们想要让单种球的个数最多的话，那么我们有两种办法：
* 把其他球的道具 $b$ 用掉；
* 把自己的道具 $c$ 用掉。

我们发现，道具 $c$ 用与不用对其他球根本不起作用，所以我们为了使一种球的个数最多，就可以把它的 $c$ 道具全部用完。

接着我们可以把所有 $a_i \ne 0$ 的球拿 $b_i$ 个出来，作为「调节名额」，表示为 $adj$。如果 $a_i < b_i$ 的话，我们最多只能拿出 $a_i$ 个，所以最后，第 $i$ 种球拿出来的个数就是 $\min(a_i,b_i)$ 个，所以「调节名额」的总数即为 $\sum _ {i = 1} ^ n \min(a_i,b_i)$。要特别注意的是，当 $a_i = 0$ 时，虽然不能使用 $b$ 道具，但是 $\min(a_i, b_i)$ 仍为 $0$，所以不会取出。

但是，这两种道具都要在 $a_i \ne 0$ 的情况下使用。那如果 $a_i=0$，又该怎么办呢？

如果 $a_i=0$ 且 $b_i\ne0$，$c_i\ne0$ 时，这个颜色的球仍可以为我们所用，这时，我们可以从「调节名额」中取出一个给它，再把它的所有 $c$ 道具用完，最后再取出 $\min(a_i, b_i)$ 个球加入「调节名额」。

所以第一问的答案就是 $adj + a_i + c_i$，其中 $i\in[1,n]$。

再看第二问。

一种非常直观的想法就是把这是的所有「调节名额」和所有球剩下的个数加起来，答案为 $adj + \sum _ {i = 1} ^ n a_i + c_i$，可这个结果真的正确吗？

想想我们忽略掉了哪些情况。对了，就是那些 $a_i = 0$，$b_i = 0$，$c_i \ne 0$ 的球。我们可以从「调节名额」中取出一个球给它分裂，注意取出一个「调节名额」后球的总数并不会变化。

但是，我们会遇到一个棘手的情况：如果「调节名额」不够怎么办？

这时，我们可以将这些球按 $c_i$ 的大小降序排序，如果一种球的 $c_i$ 更大，我们就优先选它。

而那些 $a_i = 0$，$b_i = 0$，$c_i = 0$ 的球就没用了，给他「调节名额」他又不能分裂，给不给没有区别。

需要特别注意的是，当「调节名额」为 $0$ 时，每个球能达到的最大个数就是 $a_i + c_i$，最大总个数就是 $\sum _ {i = 1} ^ n a_i + c_i$。
### Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rll register ll
#define F(i,a,b) for(rll i=a;i<=b;i++)
#define Fdn(i,a,b) for(rll i=a;i>=b;i--)
#define int ll

using namespace std;

const int inf = 0x3f3f3f3f,mod = 1e9 + 7; 
const int maxn = 351500 + 7;

int n;
int a[maxn], b[maxn], c[maxn];
int adj, ans;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	F(i, 1, n) cin >> a[i];
	F(i, 1, n) cin >> b[i];
	F(i, 1, n) cin >> c[i];
	F(i, 1, n){
		if(a[i])
			a[i] += c[i], c[i] = 0;
	}
	F(i, 1, n){
		int x = min(a[i], b[i]);
		a[i] -= x, b[i] -= x, adj += x;
	}
	if(!adj){
		F(i, 1, n) ans += a[i], cout << a[i] << ' ';
		cout << '\n' << ans << '\n';
		return 0;
	}
	F(i, 1, n){
		if(!a[i] && b[i] && c[i]){
			--adj, a[i] = c[i] + 1, c[i] = 0;
			int x = min(a[i], b[i]);
			a[i] -= x, b[i] -= x, adj += x;
		}
	}
	vector<int> V;
	F(i, 1, n)
		if(c[i]) V.push_back(c[i]);
	sort(V.begin(), V.end(), greater<int>());
	ans = adj;
	F(i, 1, n) ans += a[i];
	int len = min((int)V.size(),adj);
	F(i, 0, len - 1) ans += V[i];
	F(i, 1, n) cout << adj + a[i] + c[i] << ' ';
	cout << '\n' << ans;
	
	
	return 0;
}
```

---

## 作者：Arghariza (赞：2)

赛时思路。

首先第二类工具相当于在 $a_i\neq 1$ 时 $a_i\gets a_i+c_i$，于是一开始肯定对于所有颜色能用的先用了。所以接下来每种颜色 $i$ 有 $a_i=0$ 或者 $c_i=0$。

然后我觉得第二问比较简单，所以先做第二问。

把颜色分为三种，分别为 $(a_i,b_i,0),(0,b_i,c_i),(0,0,c_i)$。我们想要对于后面两种颜色中的某个 $i$，由第一种的某个颜色，使用一次第一类操作将一个球的颜色变为 $i$，然后 $i$ 的球数就可以加上 $c_i$ 了。称这个可以改变颜色的球为**可以自由移动的球**，改变其颜色成为**移动**。

不难看出一开始我们的移动次数为 $\sum\limits_{i=1}^n\min\{a_i,b_i\}$，然后随着我们移动球到 $i$，球总数增加 $c_i$，但是移动次数减少 $1$。但是当我们移动到一个形如 $(0,b_i,c_i)$ 的颜色时，移动次数可以加回 $b_i$，于是我们有一个比较显然的贪心：

- 先移动到所有形如 $(0,b_i,c_i)$ 的颜色（如果可以移动），并给答案加上 $c_i$，给移动次数加上 $b_i-1$。
- 由于取 $(0,0,c_i)$ 会使移动次数减少 $1$，按照 $c_i$ 从大到小排序依次移动即可。

受到启发，我们直接开始做第一问：

假设我们现在想让颜色 $k$ 的球最多。我们一开始还是先求出可以移动的次数，然后我们发现**最开始可以移动的球，最后一定都会移动颜色 $k$ 上**，所以考虑求出最后能移动到某个颜色的球的个数 $c$。

形如 $(0,0,c_i)$，$i\neq k$ 的球一定没用，因为移不走。

如果一开始可以移动的次数不为 $0$，我们就可以找一个可以自由移动的球，依次移动到所有形如 $(0,b_i,c_i)$  颜色上，给 $c$ 加上 $\min\{c_i,b_i-1\}$（因为对于一种颜色 $i$，移动过来的那个球已经被算进 $c$ 了，而且还得被移走，剩下能移动的就至多 $b_i-1$ 个了）。

计算答案的话假如 $k$ 形如 $(0,b_k,c_k)$ 的形式，那么答案就是 $c-\min\{c_i,b_i-1\}+c_i$，因为不用再考虑把球移出去了。

然后还有一些情况，比如 $b_i=0$，这是比较好做的，特判一下能不能加 $c_i$ 就行了。

```cpp
#include <bits/stdc++.h>
#define int long long
#define eb emplace_back
#define pb pop_back
#define mt make_tuple
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> pi;
typedef tuple<int, int, int> tu;
bool Mbe;

const int N = 5e5 + 500;
int n, a[N], b[N], c[N];
priority_queue<int> q;

void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) cin >> c[i];
    int s = 0;
    for (int i = 1; i <= n; i++) if (a[i]) a[i] += c[i], c[i] = 0;
    for (int i = 1; i <= n; i++) s += min(a[i], b[i]);
    int fl = s;
    if (fl) {
    	for (int i = 1; i <= n; i++) 
    		if (!a[i] && b[i] && c[i]) s += min(c[i], b[i] - 1);
    }
    for (int i = 1; i <= n; i++) {
    	int cur = s - min(a[i], b[i]) + a[i];
    	if (!a[i] && b[i] && c[i] && fl) {
    		cur -= min(c[i], b[i] - 1);
    		cur += c[i];
    	}
    	if (!b[i] && fl) cur += c[i];
    	cout << cur << ' ';
    }
    cout << '\n';
    int res = 0, ct = 0;
    for (int i = 1; i <= n; i++) res += a[i], ct += min(a[i], b[i]);
    for (int i = 1; i <= n; i++)
        if (!a[i] && b[i] && ct) res += c[i], ct += min(b[i] - 1, c[i]);
    for (int i = 1; i <= n; i++) if (!a[i] && !b[i]) q.push(c[i]);
    while (ct && !q.empty()) ct--, res += q.top(), q.pop();
    cout << res << '\n';
}

bool Med;
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cerr << (&Mbe - &Med) / 1048576.0 << " MB\n";
    #ifdef FILE
        freopen("1.in", "r", stdin);
        freopen("1.out", "w", stdout);
    #endif
    int T = 1;
    // cin >> T;
    while (T--) solve();
    cerr << (int)(1e3 * clock() / CLOCKS_PER_SEC) << " ms\n";
    return 0;
}

```

彩蛋：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ftsx5lk.png)


---

## 作者：_ayaka_ (赞：1)

### 思路

思路一般，细节很多的题。

由于看出问题二比问题一简单（~~实际上是调的时候问题一调了好久~~），所以先处理问题二。

首先对于操作 $c$，因为其只对这种颜色本身有效，所以自然能用就用。因此对于 $a_i>0$ 的颜色，直接把 $c_i$ 加进 $a_i$ 即可。对于可以被操作 $b$，转移的球，它们的颜色并不重要，因为它们可以为任何颜色。下文把它们称作自由的球，用 $fre$ 表示它们的数量。那么对于所有的 $a_i=0$ 且 $c_i>0$ 的颜色，只需要分配一个 $fre$ 进去就可以多吃到 $c_i$ 的值。不过由于 $fre$ 可能有限，所以可以用优先队列来优先处理 $c_i$ 更大的颜色即可。处理问题二的时间复杂度为 $O(n\log n)$，可被接受。最大化的 $fre$ 求法见问题一。

接下来是问题一，其实只要知道怎么最大化 $fre$ 也就迎刃而解了。注意到任意次 $c_i$ 只要 $i$ 颜色有一个球就可以全用出来，所以对于一个 $b_i=1$ 而 $a_i=0$ 的颜色，我们放一个 $fre$ 进去绝对不亏，甚至可能多赚几个 $fre$。这就是我们的贪心策略，对于这种情况的颜色直接投 $fre$ 再算贡献，让 $fre$ 最大化，而每个球能得到的最大贡献就是 $a_i+c_i+fre$ 了。时间复杂度 $O(n)$。

最后需要特判一下最开始求出的 $fre$ 是否 $=0$，因为我们后面的求解和最大化 $fre$ 都建立于 $fre$ 至少有一个的情况。然后就做完了，时间复杂度 $O(n\log n)$。

### 代码


```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, a[500005], b[500005], c[500005], fre, ans, x;
priority_queue<int> q;
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) cin >> b[i];
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i <= n; i++) if (a[i]) a[i] += c[i], c[i] = 0;
	for (int i = 1; i <= n; i++) {
		x = min(a[i], b[i]);
		fre += x, a[i] -= x, b[i] -= x;
	}
	if (!fre) {
		for (int i = 1; i <= n; i++) {
			ans += a[i];
			cout << a[i] << " ";
		}
		cout << "\n";
		cout << ans;
		return 0;
	}
	for (int i = 1; i <= n; i++) {
		if (b[i] && c[i] && !a[i]) {
			a[i] = c[i] + 1;
			c[i] = 0;
			fre--;
			x = min(b[i], a[i]);
			a[i] -= x, b[i] -= x, fre += x;
		}
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] == 0) q.push(c[i]);
		else ans += a[i];
	}
	x=fre;
	while (!q.empty() && x > 0) {
		ans += q.top();
		x--;
		q.pop();
	}
	for(int i=1;i<=n;i++) cout<<a[i]+c[i]+fre<<" ";
	cout<<"\n";
	ans+=fre;
	cout << ans;
	return 0;
//}
```

---

## 作者：happy_zero (赞：1)

其实这题只要考虑周全就很简单，~~但是在赛场上这个菜鸡罚了七发才过~~。设 $f$ 为真表示存在一个
$i$ 使得 $a_i\ne0$ 且 $b_i>0$，否则为假。

**第一个问题：**

先要明确一个简单的贪心策略：除非是给 $a_i=0$ 的使用第二类工具的机会，否则一定是一步转换到位，不然中间反而有可能会转换不出来。而对于 $a_i=0$ 的处理正是本题的麻烦之处，最基本的策略是从别的颜色转换一个过来增加 $c$。

设当前目标颜色为 $x$，第 $i$ 种颜色的贡献：

- $i=x$：
- - $a_i\ne 0$：$a_i+c_i$
- - $a_i=0$：
- - - $f$ 为真（可以给 $i$ 用第二类工具）：$c_i$
- - - $f$ 为假：$0$（无法使用第二类工具，同时当前 $x$ 答案为 $0$）

- $i\ne x$：
- - $a_i\ne0$：$\min\{a_i+c_i,b_i\}$（最多能有 $a_i+c_i$ 个，最多能运出去 $b_i$ 个）
- - $a_i=0$：
- - - $f$ 为真：$\min\{\max\{b_i-1,0\},c_i\}$（$b_i$ 要减 $1$ 是为了保证一开始被转化为 $i$ 的球可以再被转化颜色）
- - - $f$ 为假：$0$

具体的，可以先求出所有 $i$ 作为非目标颜色时的贡献 $w_i$ 之和，输出时扣掉 $w_i$ 再加上 $i=x$ 时对应的贡献。

**第二个问题：**

同样是考虑到第 $i$ 种颜色：

- $f$ 为真：
- - $a_i\ne 0$：$a_i+c_i$（这里不用考虑能运出去多少个）
- - （这里把所有 $a_i=0$ 放到一起考虑）$a_i=0$：\
对于 $b_i\ne0$ 的部分，只需要一个球转换颜色就能获得所有 $c_i$ 的贡献；\
对于 $b_i=0$ 的部分，关键是能给多少个颜色来获得 $c_i$ 的贡献。假设能获得 $t$ 个球进行贡献，贡献则是这部分中前 $\min\{\text{颜色个数},t\}$ 大的 $c_i$。$t$ 的求法有两种情况能贡献：
- - - $a_i\ne0$：$\min\{a_i+c_i,b_i\}^{[1]}$
- - - $a_i=0,b_i\ne0$：$\min\{c_i,b_i-1\}$ 这里 $b_i-1$ 是因为还要提供一个给其它 $b_i\ne 0$ 的颜色 $^{[2]}$
- $f$ 为假（所有的只能在在自己颜色进行贡献）：
- - $a_i=0$：$0$
- - $a_i\ne 0$：$a_i+c_i$

这里注意，由于所有的 $b_i\ne 0$ 均贡献完后，至少还能再给其余提供 $b_i=0$ 一个球进行贡献，这个球已经被算在 $a_i\ne 0$ 的情况下了 $[1]$，假设因为 $b_i-1$ 少算了一个 $[2]$，那么就正好抵消掉。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N = 4e5 + 5;
int a[N], b[N], c[N], w[N], s[N];
bool cmp(int x, int y) {
    return x > y;
}
signed main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i <= n; i++) cin >> c[i];
    int f = 0;
    for (int i = 1; i <= n; i++)
        if (a[i] != 0 && b[i]) f = 1;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] == 0) w[i] = f * min(max(b[i] - 1, 0ll), c[i]);
        else w[i] = min(b[i], a[i] + c[i]);
        ans += w[i];
    }
    for (int i = 1; i <= n; i++) {
        if (a[i] == 0 && !f) cout << "0 ";
        else cout << ans - w[i] + a[i] + c[i] << ' ';
    }
    ans = 0;
    if (f) {
        int t = 0, ts = 0;
        for (int i = 1; i <= n; i++) {
            if (a[i] != 0) t += min(b[i], a[i] + c[i]), ans += a[i] + c[i];
            else if (b[i] != 0) t += min(c[i], b[i] - 1), ans += c[i];
            else s[++ts] = c[i];
        }
        sort(s + 1, s + ts + 1, cmp);
        for (int i = 1; i <= min(ts, t); i++)
            ans += s[i];
    }
    else {
        for (int i = 1; i <= n; i++)
            if (a[i] != 0) ans += a[i] + c[i];
    }
    cout << '\n' << ans << '\n';
    return 0;
}
```

---

## 作者：VainSylphid (赞：1)

写了依托答辩还能在赛时两发过。不明白为什么都说这题恶心。

## 做法

我们称第一类工具为“转移”，第二类为“复制”。

对两个问题分开考虑，首先考虑让一种颜色的球最多，我们称其为目标颜色。

先考虑不是目标颜色的。

我们发现对于一开始至少有一个球的颜色，我们一定可以无脑把它们的复制全部用掉，然后尽可能把它们全部转移到目标颜色，能转移出去 $\min(a_i+c_i,b_i)$ 个。

对于一开始没有球的颜色，需要先找别的颜色“借”一个，如果这种颜色没有转移工具那就不用借了，反正转移不到目标颜色，还会浪费。如果 $b_i\neq0$，借到了就能转移 $\min(b_i-1,c_i)$ 个。

注意可以找目标颜色借，如果目标颜色一开始有，那么同样可以借出去 $\min(a_i+c_i,b_i)$ 个。如果目标颜色一开始没有，那么只能找其他颜色借。

对于目标颜色，如果目标颜色一开始没有，也需要借，如果借不到答案就是 $0$。

如果借到了或者一开始有，就把复制全部用掉，然后加上能转移到目标颜色的球数。

我们用前后缀和维护一开始至少有一个球的颜色最多能转移多少个到目标颜色，以及一开始没有球但是有转移工具的颜色如果借到了最多能转移多少个到目标颜色。注意一开始没有球的颜色都要先借一个，相当于实际上只有 $\min(b_i-1,c_i)$ 个是新增的能转移给目标颜色的。

因为一开始没有球的颜色只要有转移工具就可以互相借，所以只要一开始至少有一个球的颜色能转移一个就可以借给所有一开始没有球的颜色。

再考虑让所有的球最多，这时候我们要把颜色分成三类，第一类是自己有球的，第二类是自己没有球但是有转移工具的，第三类是自己没有球也没有转移工具，只有复制工具的。

我们先把第一类颜色的复制都用掉，然后统计 $a_i+b_i$ 的和，就得到了答案的保底部分。

然后我们统计第一类颜色能借出去多少个，也就是 $\min(a_i+c_i,b_i)$ 的和。

第二类颜色如果借到一个球，就可以互相转移球，所以我们统计第二类如果借到球能产生多少新的，也就是 $c_i$，加进答案。还要统计第二类最多能新增转移出去多少个，注意第二类本身都要先借一个，和问题一中类似，实际上只有 $\min(c_i,b_i-1)$ 个是新增的能转移到其他颜色的。

我们把第一类颜色和第二类颜色能借出去的加起来，就得到了我们能借给第三类颜色的，因为第三类不能互相转移，所以每一种第三类颜色都需要借一个。

我们把第三类颜色按能增加的球数也就是 $c_i$ 排序，然后贪心从大到小选取，直到没有可以借出去的球或者第三类颜色都借到了为止，最后记得加进答案。

## 代码

因为两类工具写反了，所以我的代码依托答辩，写得稀烂，仅供参考。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[400005],b[400005],c[400005],pr[400005],sr[400005],pg[400005],sg[400005],ans[400005],s1,s2,s3,s4,s5,s6[400005],rans;
int main()
{
	scanf("%lld",&n);
	for(ll i = 1;i <= n;i++)
	    scanf("%lld",&a[i]);
	for(ll i = 1;i <= n;i++)
	    scanf("%lld",&c[i]);
	for(ll i = 1;i <= n;i++)
	    scanf("%lld",&b[i]);
	for(ll i = 1;i <= n;i++)
	{
		pr[i] = pr[i - 1],pg[i] = pg[i - 1];
	    if(a[i])
	        pr[i] += min(a[i] + b[i],c[i]);
	    else
	    	pg[i] += max(min(b[i],c[i] - 1),0LL);
	}
	for(ll i = n;i;i--)
	{
		sr[i] = sr[i + 1],sg[i] = sg[i + 1];
	    if(a[i])
	    	sr[i] += min(a[i] + b[i],c[i]);
	    else
	    	sg[i] += max(min(b[i],c[i] - 1),0LL);
	}
	for(ll i = 1;i <= n;i++)
	{
		if(a[i] == 0 && pr[i - 1] + sr[i + 1] == 0)
		    ans[i] = 0LL;
		else
	    	ans[i] = a[i] + b[i] + pr[i - 1] + sr[i + 1] + (pr[i - 1] + sr[i + 1] ? pg[i - 1] + sg[i + 1] : 0LL);
	}
	for(ll i = 1;i <= n;i++)
	    printf("%lld%c",ans[i]," \n"[i == n]);
	for(ll i = 1;i <= n;i++)
	    if(a[i])
	        s1 += a[i] + b[i],s2 += min(a[i] + b[i],c[i]);
	    else if(c[i])
	        s3 += min(b[i],c[i] - 1),s4 += b[i];
	    else
	        s6[++s5] = b[i];
	rans += s1;
	if(s2)
	{
	    rans += s4,s2 += s3;
		sort(s6 + 1,s6 + s5 + 1,greater<ll>());
		for(ll i = 1;i <= min(s5,s2);i++)
		    rans += s6[i];
	}
	printf("%lld",rans);
	return 0;
}
```

## 补充

官方数据疑似不够强，目标颜色也可以把自己借给一开始没有球的颜色再转移回目标颜色，我的赛时代码没有加上就通过了。

对我自己赛时代码的 hack 数据：

```
3
1 1 0
0 1 10
10 0 100
```

正确输出：

```
21 10 101
112
```

我的赛时代码输出：

```
21 1 101
112
```

建议加强数据。

---

## 作者：许多 (赞：0)

前言：考场被第二问恶心到了。

第一问很简单，只要将其他的球尽可能多的转化为第 $i$ 个球并且对自身使用第二个道具即可。不过有些细节要注意：

- 当**自身一个球都没有**且**其他球无法转换为该球**时（即没有第一个道具）无法使用第二个道具。

- 当**自身没有球**从而无法使用**第一个道具**时可以利用其他球**转化为该球**再使用**第二个道具**从而**增加球的数量**进而使用**第一个道具**转换为其他球。

第二问思路很简单，实现有点恶心。

发现只有第二个道具可以增加球的数量。于是要尽可能多的使用第二个道具。

难道总球的数量加上第二个道具的数量就可以吗？

~~显然出题人没有这么良心~~。发现有些**小球本身一个球都没有**但有很多第二个道具，那也很简单，类比第一问，利用其他球**转化为该球**再使用**第二个道具**从而**增加球的数量**。

~~显然出题人不会这么简单让你过~~。如果只有**一个第一个道具**但是上面的情况有 5 个呢？显然我们还要采取贪心策略，先转换有第一个道具的小球，然后是第二个道具多的小球。

## 考场代码

```cpp
#include<bits/stdc++.h>
#include<cstdio>
#define N 356000
#define LL long long
inline LL read(){
    LL x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
using namespace std;
LL n;
LL a[N],b[N],c[N],m[N],p[N],B=0;
LL ans=0,cnt=0;
int main(){
    n=read();
    for(LL i=1;i<=n;i++)a[i]=read();
    for(LL i=1;i<=n;i++)b[i]=read();
    for(LL i=1;i<=n;i++)c[i]=read(),B+=a[i]==0? 0:b[i];
    if(B==0){
        for(LL i=1;i<=n;i++){
            ans+=a[i]==0? 0:a[i]+c[i];
            if(a[i]==0)printf("0 ");
            else printf("%lld ",a[i]+c[i]);
        }
        printf("\n%lld",ans);
        return 0;
    }

    //上方应该没错

    //如果有一个能转换的，则所有b都能用上
    for(LL i=1;i<=n;i++){
        if(b[i]==0)m[i]=0;
        else if(a[i]==0)m[i]=min(1+c[i],b[i])-1;//需要先转换进来一个，然后全部转换出去，共计出去b[i]-1
        else m[i]=min(a[i]+c[i],b[i]);//全部转换出去b[i]
        ans+=m[i];
    }
    for(LL i=1;i<=n;i++)
        printf("%lld ",a[i]+c[i]+ans-m[i]);
    
    ans=0;
    for(LL i=1;i<=n;i++){
        ans+=a[i];
        if(b[i]==0&&a[i]==0){p[++p[0]]=c[i];continue;}
        if(a[i]==0)cnt+=b[i]-1;
        else cnt+=b[i];
        ans+=c[i];
    }
    sort(p+1,p+1+p[0]);
    for(LL i=p[0];i>0&&cnt>0;i--,cnt--)
        ans+=p[i];
    printf("\n%lld",ans);
    return 0;
}
```

题外话：变量 $B$ 啥也不是，里面存储的数没有意义，只是判断有没有第一个道具的临时变量。

---

## 作者：Nuisdete (赞：0)

队伍贡献：$-\infty$。

第二问：

显然先用 $C$ 一定不劣，但是由于有 $A = 0$ 的情况出现，我们还需要把一些球移到一些 $A = 0$ 但是 $C \neq 0$ 的颜色中，不难发现，如果某种颜色的 $B \neq 0$，那么移过去一定是不劣的，否则按照 $C$ 从大到小取移即可。

第一问：

在做第二问的时候可以处理出当前能够移动的球的最大数目，这个可以贡献所有颜色的答案。由于每种颜色可能有剩下的球留在原地无法移动，因此在求每个球的答案时，把它对能移动的球的最大数目的贡献减去，再加上自己的总球数 $A + C$ 即可。

代码有点不可读。

```cpp
# include <cstdio>
# include <vector>
# include <algorithm>
# include <functional>

# define int long long

signed main() {

  int n;
  scanf("%lld", &n);

  struct Str { int a, b, c, id; };
  std::vector<Str> str(n + 1);

  for (int i = 1; i <= n; ++i) scanf("%lld", &str[i].a);
  for (int i = 1; i <= n; ++i) scanf("%lld", &str[i].b);
  for (int i = 1; i <= n; ++i) scanf("%lld", &str[i].c), str[i].id = i;

  int mxs = 0;

  std::sort(str.begin() + 1, str.end(), [&](const Str& A, const Str& B) {
    if (A.a == 0 && B.a || B.a == 0 && A.a) return A.a > B.a;
    return std::min(A.b, A.a + A.c) == std::min(B.b, B.a + B.c) ? A.c > B.c : std::min(A.b, A.a + A.c) > std::min(B.b, B.a + B.c);
  });

  int sumb = 0, mx = 0;

  std::vector<int> val(n + 1);

  for (int i = 1; i <= n; ++i) {
    if (str[i].a > 0) {
      mxs += str[i].a + str[i].c;
      val[i] = std::min(str[i].b, str[i].a + str[i].c);
      sumb += std::min(str[i].b, str[i].a + str[i].c);
    } else {
      if (sumb == 0) continue;
      sumb --;
      mxs += str[i].c;
      val[i] = std::min(str[i].b - 1, str[i].c);
      sumb += std::min(str[i].b, str[i].c + 1);
    }
    mx = std::max(mx, sumb);
  }

  std::vector<int> ans(n + 1);

  for (int i = 1; i <= n; ++i) {
    val[i] = std::max(val[i], 0LL);
    if (mx || str[i].a)
      ans[ str[i].id ] = mx + str[i].a + str[i].c - val[i];
  }

  for (int i = 1; i <= n; ++i) printf("%lld%c", ans[i], " \n"[i == n]);

  printf("%lld\n", mxs);

  return 0;
}
```

---

## 作者：Unnamed114514 (赞：0)

corner 巨多的简单贪心题，但是 $6$ 发罚时。

首先因为 $c$ 只会对自己更改，所以我们直接先改 $c$，因为如果 $a<b$ 的时候改 $c$ 可以让可变换的次数变多；如果 $a\ge b$，那么改不改都没意义但是还是改。

那么其实本质上的 corner 就是 $0\le a\le 10^9$ 时看是否要给它一个然后让它用 $c$。

对于第一二问分开处理：

- 第一问：

首先我们可以发现，如果 $b\le1$ 的话那么从其它的转向它它可以转换的也没有意义，所以我们只会把一个东西转换到 $b>1$ 的玩意。注意到这样可以转换的 $b$ 是不减的，所以我们可以转换成它。

那么最后可以转换的数量就是 $s=\sum\min\{a,b\}$，那么对于一个 $i$，就是 $a_i+s-\min\{a_i,b_i\}$，但是注意到如果 $a=0,b\le 1$，那么此时它没有被转化过，所以这种情况还要加上 $c$。

- 第二问：

仍然是同样的思路。

首先如果 $c=0$ 的话对答案没有贡献，所以只需要考虑 $c>0$ 的玩意。

注意 $b=0$ 的时候会减少可以转换的量但是 $b>0$ 的时候不会，所以我们先给 $b>0$ 的时候一样一个即可。

对于 $b=0$ 的情况，有可能我们转化的数量不够，这个时候，贪心地，显然是让能执行的 $c$ 越多越好，于是我们就按照 $c$ 排序即可。

$O(n\log n)$。

题外话：分享一下吃的 $6$ 发罚时：

- 第一发：没判 $a=0$ 就跑路。

- 第二发：没有判队列为空的时候

- 第三、四、五发：打了 `cmp` 但是 `sort` 没调用，没注意到然后乱搞。

- 第六发：第一问 $a=0$ 的时候没有加 $c$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=4e5+5;
int n,a[N],b[N],c[N],A[N],B[N],C[N];
deque<int> q,q_,q__;
inline bool cmp(int a,int b){ return C[a]>C[b];	 }
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i) cin>>a[i],A[i]=a[i];
    for(int i=1;i<=n;++i) cin>>b[i],B[i]=b[i];
    for(int i=1;i<=n;++i) cin>>c[i],C[i]=c[i];
    for(int i=1;i<=n;++i) if(a[i]&&b[i]) q.push_back(i);
    for(int i=1;i<=n;++i) if(a[i]) a[i]+=c[i],c[i]=0;
    for(int i=1;i<=n;++i) if(b[i]&&!a[i]&&c[i]){
        if(q.empty()) break;
        --b[q.front()],--a[q.front()];
        a[i]=c[i]+1;
        if(!b[q.front()]||!a[q.front()]) q.pop_front();
        q.push_back(i);
    }
    int sum=0;
    for(int i=1;i<=n;++i) sum+=min(a[i],b[i]);
    for(int i=1;i<=n;++i){
        int res=a[i]+sum-min(a[i],b[i]);
        if(!a[i]&&res) res+=c[i];
        cout<<res<<' ';
    }
    cout<<endl;
    while(q.size()) q.pop_back();
    for(int i=1;i<=n;++i) if(A[i]&&B[i]) q.push_back(i);
    for(int i=1;i<=n;++i) if(A[i]) A[i]+=C[i],C[i]=0;
    for(int i=1;i<=n;++i) if(C[i]&&!A[i]){
        if(B[i]) q_.push_front(i);
        else q__.push_back(i);
    }
    sort(q__.begin(),q__.end(),cmp);
    for(auto i:q_) if(q.size()){
        --B[q.front()],--A[q.front()];
        A[i]=C[i]+1;
        if(!B[q.front()]||!A[q.front()]) q.pop_front();
        q.push_back(i);
    }
    for(auto i:q__) if(q.size()){
        --B[q.front()],--A[q.front()];
        A[i]=C[i]+1;
        if(!B[q.front()]||!A[q.front()]) q.pop_front();
    }
    sum=0;
    for(int i=1;i<=n;++i) sum+=A[i];
    cout<<sum<<endl;
    return 0;
}
```

---

## 作者：binbin_200811 (赞：0)

# [【THUPC 2024 初赛】 转化](https://www.luogu.com.cn/problem/P9965)

我都能做出来，那就是大水题了。

#### 思路

首先我们要确定最大可以变色的球的数量 $tot$。

有如下两个贪心步骤：

* 1. 所有颜色使用分裂操作，并更新 $a_i$。

​	此时的有 $tot=\sum_{i=1}^n \min(a_i,b_i)$（需要更新 $a_i,b_i$）。

* 2. 若 $tot$ 大于 $0$，给 $b_i$ 和 $c_i$ **都**不为 $0$ 的点，分配一个球，执行完分裂 $c_i$ 次后，更新 $a_i,b_i$，更新 $tot$。

这两个贪心步骤可以保证 $tot$ 最大。

对于 1 如果一个点有球，那么从别处变色球来分裂肯定不优；对于 2，不难发现，执行完后 $tot$ 肯定不降。

对于每一个颜色 $i$，如果此时 $tot$ 大于 $0$ 且 $c_i$ 大于 $0$，那么 $ans_i=tot+a_i+c_i$。

如果 $tot$ 等于 $0$，那么 $ans_i=a_i$。

对于全局最大值，在执行完上述操作中的 $c_i$，选择大于 $0$ 且最大的 $tot$ 个，设这些 $c_i$ 的和为 $sum$。

全局最大答案为：$ans=\sum\limits_{i=1}^n a_i+sum+tot$。

时间复杂度 $O(n)$，加上排序 $O(n\log n)$。

#### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=5e5+5;

#define int long long
#define ll long long

struct node
{
    int c,id;
}edge[maxn];

ll n,fs,ct;
ll a[maxn],b[maxn],c[maxn];

bool cmp(ll a,ll b){return a>b;}

signed main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
    for(int i=1;i<=n;i++) scanf("%lld",&c[i]);
    for(int i=1;i<=n;i++)
    {
        if(a[i]==0) continue;
        a[i]+=c[i];
        c[i]=0;
        ll t=min(a[i],b[i]);
        fs+=t;
        b[i]-=t;
        a[i]-=t;
    }
    for(int i=1;i<=n;i++)
    {
        if(b[i]&&c[i]&&fs)
        {
            fs--;
            a[i]=1+c[i];
            c[i]=0;
            ll t=min(b[i],a[i]);
            b[i]-=t;
            a[i]-=t;
            fs+=t;
        }
    }

    ll totans=0;
    for(int i=1;i<=n;i++)
    {
        totans+=a[i];
        ll t=fs+a[i];
        if(t) t+=c[i];
        printf("%lld ",t);
    }
    sort(c+1,c+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        if(c[i]&&fs)
        {
            fs--;
            totans+=1+c[i];
        }
    }

    printf("\n%lld",totans+fs);
}
```

赛时代码比较艹，所以读者自己写一次的好。

---

## 作者：ivyjiao (赞：0)

（截至发题解时）喜提 LOJ 最短解 + 洛谷最短解 & 最劣解。

彩蛋：本题真正的数据范围是 $n=351493$，而非 $1\leq n\leq 351493$。

话说这个数字是什么东西啊，为什么不是 $4\times 10^5$？

------------

细节很多的贪心。

我们先来看第一部分：

对于每个颜色的贡献：

- 如果这个颜色初始有球（即 $a_i\neq 0$），则它的贡献为 $\min(b_i,a_i+c_i)$，很好理解。
- 如果这个颜色初始没有球（即 $a_i=0$），则它的贡献为 $\min(\max(0,b_i-1),c_i)$，因为别的地方（设为 $j$）还要花费一个 $b_j$ 来给它一个初始的球让它能进行复制，所以 $b_i$ 的贡献要 $-1$，又因为可能减成负数，所以要对 $0$ 取 $\max$。

对于每个颜色最多有多少球：

- 如果这个颜色初始有球，则它初始就能有 $a_i+c_i$ 个球，很好理解。
- 如果这个颜色初始没有球，则它就需要从别的地方拿球，自己还能产生贡献 $c_i$（如果别的地方有球让它拿）。

第一部分得解。

我们再来看第二部分：

- 如果这个颜色初始有球，则它的贡献为 $a_i+c_i$。
- 如果这个颜色初始没有球且能拿出球（即 $b_i\neq 0$），就从别的地方拿球（如果别的地方有球让它拿），则它的贡献为 $c_i$。
- 如果这个颜色初始没有球且不能转出球，记录 $c_i$。

我们再把记录的颜色从大到小排序，看能否从别的地方拿球。

别的地方总共能拿多少球？

- 如果这个颜色初始有球，则它的贡献为 $\min(b_i,a_i+c_i)$。

哎？这是不是和第一部分每个颜色的贡献的部分有点像？

- 如果这个颜色初始没有球且能拿出球，就从别的地方拿球（如果别的地方有球让它拿），则它的贡献为 $\min(\max(0,b_i-1),c_i)$，由于 $b_i\neq 0$，所以该式可化简为 $\min(b_i-1,c_i)$。
- 如果这个颜色初始没有球且不能转出球，反正 $\min(\max(0,b_i-1),c_i)$ 都是 $0$ 了，算不算无所谓。

第二部分得解。

时间复杂度 $O(n\log n)$。

代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[400001],b[400001],c[400001],sumd,sumd2,ans2,g[400001],l;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>b[i];
    for(int i=1;i<=n;i++) cin>>c[i];
    for(int i=1;i<=n;i++){
        if(a[i]) sumd+=min(b[i],a[i]+c[i]);
        else sumd2+=min(max(0ll,b[i]-1),c[i]);
    }
    for(int i=1;i<=n;i++){
        int cnt1=sumd,cnt2=sumd2,nowd=0;
        if(a[i]) cnt1-=min(b[i],a[i]+c[i]),nowd=a[i]+c[i];
        else cnt2-=min(max(0ll,b[i]-1),c[i])-c[i];
        if(sumd) nowd+=cnt1+cnt2;
        cout<<nowd<<" ";
    }
    for(int i=1;i<=n;i++){
        if(a[i]) ans2+=a[i]+c[i];
        else if(b[i]&&sumd) sumd+=min(c[i],b[i]-1),ans2+=c[i];
        else g[++l]=c[i];
    }
    sort(g+1,g+1+l,greater<>());
    for(int i=1;i<=min(l,sumd);i++) ans2+=g[i];
    cout<<endl<<ans2;
}

```

---

## 作者：0xyz (赞：0)

贪心题，细节比较多。

首先，如果 $a_i>0$，那么我们可以令 $a_i\to a_i+c_i,c_i\to 0$。在这样之后，将所有的颜色分成四类：$(a_i,0,0),(a_i,b_i,0),(0,b_i,c_i),(0,0,c_i)$。

先考虑第二问。对于第一类，直接对答案 $s$ 累加 $a_i$ 即可。对于第二类，直接对 $s$ 累加 $a_i$，并且对能够改变颜色的球数 $t$ 累加 $\min(a_i,b_i)$。对于第三类，因为 $b_i>0$，所以只要我们往这里扔 $1$ 个球，就可以对 $s$ 有 $c_i$ 的贡献，并且对 $t$ 有 $\min(b_i-1,c_i)\ge 0$ 的贡献，怎样都不亏，所以直接累加。对于第四类，因为 $t$ 有限，所以我们选择累加前 $t$ 大的 $c_i$。

然后考虑第一问。假设我们要尽量将球转移到第 $j$ 种颜色上。对于第一类、第四类，因为转移不出去，所以没用。对于第二类，对能够改变颜色的球数 $t$ 累加 $\min(a_i,b_i)$。对于第三类，因为 $b_i>0$，所以只要我们往这里扔 $1$ 个球，就可以对 $t$ 有 $\min(b_i-1,c_i)\ge 0$ 的贡献，怎样都不亏，所以直接累加。然后我们再考虑 $j$ 自身影响：是第一类，对 $s_j$ 加上 $a_j$；是第四类，对 $s_j$ 加上 $c_j$；是第二类，对 $s_j$ 加上 $a_i-\min(a_i,b_i)$；是第三类，对 $s_j$ 加上 $c_j-\min(b_i-1,c_i)$。

注意特判 $t=0$ 的情况，此时 $s_j=a_j$。

总时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。[代码](https://loj.ac/s/1963184)。

---


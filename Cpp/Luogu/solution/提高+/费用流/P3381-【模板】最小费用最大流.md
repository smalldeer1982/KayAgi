# 【模板】最小费用最大流

## 题目描述


给出一个包含 $n$ 个点和 $m$ 条边的有向图（下面称其为网络） $G=(V,E)$，该网络上所有点分别编号为 $1 \sim n$，所有边分别编号为 $1\sim m$，其中该网络的源点为 $s$，汇点为 $t$，网络上的每条边 $(u,v)$ 都有一个流量限制 $w(u,v)$ 和单位流量的费用 $c(u,v)$。

你需要给每条边 $(u,v)$ 确定一个流量 $f(u,v)$，要求：

1.  $0 \leq f(u,v) \leq w(u,v)$（每条边的流量不超过其流量限制）；
2. $\forall p \in \{V \setminus \{s,t\}\}$，$\sum_{(i,p) \in E}f(i,p)=\sum_{(p,i)\in E}f(p,i)$（除了源点和汇点外，其他各点流入的流量和流出的流量相等）；
3. $\sum_{(s,i)\in E}f(s,i)=\sum_{(i,t)\in E}f(i,t)$（源点流出的流量等于汇点流入的流量）。

定义网络 $G$ 的流量 $F(G)=\sum_{(s,i)\in E}f(s,i)$，网络 $G$ 的费用 $C(G)=\sum_{(i,j)\in E} f(i,j) \times c(i,j)$。

你需要求出该网络的**最小费用最大流**，即在 $F(G)$ 最大的前提下，使 $C(G)$ 最小。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 5\times 10^3$，$1 \leq m \leq 5 \times 10^4$，$1 \leq s,t \leq n$，$u_i \neq v_i$，$0 \leq w_i,c_i \leq 10^3$，且该网络的最大流和最小费用 $\leq 2^{31}-1$。

输入数据随机生成。

## 样例 #1

### 输入

```
4 5 4 3
4 2 30 2
4 3 20 3
2 3 20 1
2 1 30 9
1 3 40 5```

### 输出

```
50 280```

# 题解

## 作者：一叶知秋。 (赞：27)

发了网络流，再来一发费用流

能做费用流的，网络流自然做得来，但在这还是~~不要脸的~~安利一下自己的博客（里面也有网络流的题解）：

[点我](https://www.luogu.org/blog/71403/)

扯远了...

费用流，就是在不炸水管的情况下求源点到汇点的最小费用。

有没有想起什么？

思考一下......

对，最短路径！

所以我们完全可以用已死的SPFA求出不炸水管的最短路径（当然，实在有心理阴影的可以用dijkstra）。

如果你最短路径都不会，还是去 [这儿](https://www.luogu.org/problemnew/show/P3371)
和 [这儿](https://www.luogu.org/problemnew/show/P4779)

然后再一把增广路求出最大流与最小费用就好了（我觉得很OK）

献上本蒟蒻的代码：

```cpp
#include<cstdio>
#define maxn 5050
#define maxm 50005
#define INF 0x3f3f3f3f
inline int read(){
	int r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){r=(r<<3)+(r<<1)+c-'0';c=getchar();}
	return r*f;
}
int s,t,n,m,head[maxn],pre[maxn],dis[maxn],q[maxn];
bool vis[maxn];
int s_e;
struct E{
	int v,c,w,nxt;
}e[maxm*2];
struct Max_fei{//本人喜欢结构体
	inline void a_e(int u,int v,int c,int w){
		e[s_e]=(E){v,c,w,head[u]};
		head[u]=s_e++;
	}
	inline void add(int u,int v,int c,int w){
		a_e(u,v,c,w);
		a_e(v,u,0,-w);
	}
	inline bool spfa(){
		for(int i=1;i<=n;i++){
			dis[i]=INF;
			vis[i]=false;
		}
		dis[s]=0;
		vis[s]=true;
		q[0]=s;
		int hd=0,tl=1;
		while(hd^tl){
			int u=q[hd++];//循环队列
			hd%=maxn;
			for(int i=head[u];i!=-1;i=e[i].nxt){
				int v=e[i].v;
				if(dis[v]>dis[u]+e[i].w&&e[i].c){//判断水管还能运水吗
					dis[v]=dis[u]+e[i].w;//更新
					pre[v]=i;//记录位置
					if(vis[v])continue;//如果在队里，那就不进队
					vis[v]=true;
					q[tl++]=v;
					tl%=maxn;
				}
			}
			vis[u]=false;
		}
		if(dis[t]==INF)return false;
		return true;
	}
	inline int min(int a,int b){//原谅我的手写min
		return a<b?a:b;
	}
	inline int end(int &flow){//flow求最大流
		int p,u,Min=1e9,ans=0;
		for(u=t;u!=s;u=e[p^1].v){//因为开始值为0，可以用xor来找反边
			p=pre[u];//往前找
			Min=min(Min,e[p].c);//找全部经过水管都能流过的最大流
            
		}
		for(u=t;u!=s;u=e[p^1].v){
			p=pre[u];
			e[p].c-=Min;
			e[p^1].c+=Min;
			ans+=e[p].w*Min;//加费用
		}
		flow+=Min;//加最大流
		return ans;
	}
	inline int solve(int &flow){
		int ans=0;
		while(spfa()){
			ans+=end(flow);
		}
		return ans;
	}
}Flow;
inline void work(){
	n=read();m=read();
	s=read();t=read();
	for(int i=1;i<=n;i++)head[i]=-1;//初始值为-1，方便xor
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),c=read(),w=read();
		Flow.add(u,v,c,w);
	}
	int flow=0;
	int ans=Flow.solve(flow);
	printf("%d %d\n",flow,ans);
}
int main(){
	work();
	return 0;
}
```
到此结束~~（偷偷撒花）~~

---

## 作者：BitByBit (赞：15)

最小费用最大流就是在最大流的基础上，每条边还有单位流量费用，流经一条边的费用就是流量乘那条边的单位费用，求在最大流的前提下总费用最小。这里使用一种 SSP（Successive Shortest Path）算法，就是贪心找单位费用最小的增广路进行增广。需要注意的是 SSP 只能在没有负环的图上使用。具体实现就是把 Edmonds-Karp 或 Dinic 的 BFS 找增广路换成最短路找单位费用最小的增广路。使用 SPFA 求最短路的 SSP 时间复杂度为 $\Theta(nmf)$，其中 $f$ 为最大流。基于 Dinic 的实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define infll 0x3f3f3f3f3f3f3f3f
#define N 5010
#define M 100010
int n,m,s,t,tot=1;
ll maxflow,mincost;
int Head[N],Son[M],Next[M];
ll Cap[M],Cost[M];
deque<int>Q;
int Cur[N];
ll Dis[N];
bool Vis[N];
inline void add(int x,int y,int a,int b)
{
	Son[++tot]=y;
	Cap[tot]=a;
	Cost[tot]=b;
	Next[tot]=Head[x];
	Head[x]=tot;
}
bool spfa()//spfa求最短路
{
	memset(Dis,0x3f,sizeof(Dis));
	memset(Vis,0,sizeof(Vis));
	memcpy(Cur,Head,sizeof(Cur));
	Q.clear();
	Q.push_back(s);
	Dis[s]=0;
	Vis[s]=1;
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop_front();
		Vis[x]=0;
		for(int i=Head[x];i;i=Next[i])
		{
			int y=Son[i];
			if(Cap[i]&&Dis[y]>Dis[x]+Cost[i])
			{
				Dis[y]=Dis[x]+Cost[i];
				if(!Vis[y])
				{
					Q.push_back(y);
					Vis[y]=1;
				}
			}
		}
	}
	return Dis[t]^infll;
}
ll dfs(int x,ll flow)//dfs增广
{
	if(x==t)return flow;
	Vis[x]=1;
	ll res=0;
	for(int i=Cur[x];i&&flow;i=Next[i])
	{
		int y=Son[i];
		Cur[x]=i;
		if(!Vis[y]&&Cap[i]&&Dis[y]==Dis[x]+Cost[i])
		{
			ll k=dfs(y,min(flow,Cap[i]));
			if(!k)Dis[y]=infll;
			Cap[i]-=k;
			Cap[i^1]+=k;
			res+=k;
			flow-=k;
			mincost+=k*Cost[i];//直接在这里记录费用
		}
	}
	Vis[x]=0;
	return res;
}
void Dinic(void)//Dinic算法
{
	while(spfa())maxflow+=dfs(s,infll);
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++)
	{
		int x,y,a,b;
		cin>>x>>y>>a>>b;
		add(x,y,a,b);
		add(y,x,0,-b);
//这里反向边的容量为0，费用是负的。
	}
	Dinic();
	cout<<maxflow<<' '<<mincost;
	return 0;
}
```

---

## 作者：流水行船CCD (赞：8)

为什么现有的题解全是 SSP 啊？

## SSP 连续最短路

其他题解讲的比较清楚，这里只提一下思想：寻找增广路的时候用费用最小的增广路去增广即可，注意由于反向边费用为负，在原图无负圈时只能使用 Bellman-Ford 和 SPFA 求解最短路，在原图有负圈时需使用消圈算法。

该算法由于寻找的不再是经过边数最小的增广路，不能说明每条关键边被增广一次最短路长度增加，也就无法每条边至多成为 $\mathcal{O}(|V|)$ 次关键边，所以是 FF 的复杂度上界 $\mathcal{O}(nm|f|)$，已经被 Min_25 卡成 $\mathcal{O}(n^32^{n/2})$ 了。

### Code

代码方便，但是肉眼可见的慢，跑了 1500ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ld cin
#define jyt cout
#define int long long
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
const int N = 1e5 + 7;
const int inf = 1e9 + 7;
const ll linf = 1e18 + 7;
const int P = 998244353;
namespace JoKing {
	int n, m, S, T, Q[N], vis[N], Dfs_vis[N], dis[N], now[N], Ans1 = 0, Ans2 = 0;
	struct Node {int to, nxt, w, cost;} e[N << 1]; int h[N], ec = 1;
	inline void AddEdge(int u, int v, int w, int cost) {e[++ec].to = v, e[ec].nxt = h[u], e[ec].w = w, e[ec].cost = cost, h[u] = ec;}
	inline void SpanEdge(int u, int v, int w, int cost) {AddEdge(u, v, w, cost), AddEdge(v, u, 0, -cost);}
#define nxt(x) (x = (x + 1 > n ? 1 : x + 1))
#define FR(x) for (int i = x, v = e[i].to, w = e[i].w, cost = e[i].cost; i; i = e[i].nxt, v = e[i].to, w = e[i].w, cost = e[i].cost)
	inline bool Spfa() { int head = 1, tail = 1, sz = 1; REP(i, 1, n) now[i] = h[i], dis[i] = linf, Dfs_vis[i] = 0; dis[Q[head] = S] = 0;
		for (int x = Q[head]; sz; x = Q[nxt(head)], --sz, vis[x] = 0) 
			FR(h[x]) if (w && dis[v] > dis[x] + cost) dis[v] = dis[x] + cost, (!vis[v] && (Q[nxt(tail)] = v, ++sz, vis[v] = 1));
		return dis[T] != linf;
	}
	inline int Dfs(int x, int flow) {
		if (x == T) return Ans1 += flow, flow; int used = 0, flowing_boat = 0; Dfs_vis[x] = 1;
		FR(now[x]) if ((now[x] = i) && !Dfs_vis[v] && w && dis[v] == dis[x] + cost && (flowing_boat = Dfs(v, min(w, flow - used)), Ans2 += cost * flowing_boat, e[i].w -= flowing_boat, e[i ^ 1].w += flowing_boat, (!flowing_boat && (dis[v] = linf)), used += flowing_boat) == flow) return used; 
		return used;
	}
	signed main() { int u, v, w, cost;
		ld >> n >> m >> S >> T;
		REP(i, 1, m) ld >> u >> v >> w >> cost, SpanEdge(u, v, w, cost);
		while (Spfa()) Dfs(S, linf);
		jyt << Ans1 << ' ' << Ans2 << '\n';
		return 0;
	}
}
signed main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	JoKing::main(); return 0;
}
```

## KM 重标号 & zkw 费用流

核心：SPFA 很慢，所以手动模拟最短路。

每增广一次需要跑一遍 SPFA 的原因是增广后关键边会消失，有反向边会加入，导致距离数组变化，考虑利用标号快速维护距离数组。

最开始，将每个点的标号 $d$ 全部置为 $0$。我们称满足 $d_v = d_u + w(u,v)$ 的边为可行边，可以由 $S$ 只经过可行边到达的点构成的连通块称作可行连通块，此时，求出所有一段位于可行连通块，另一端不位于可行联通块的边 $(u,v)$ 中 $\delta w = d_u + w(u,v) - d_v$ 最小的边。

若 $S,T$ 均在可行连通块中，使用可行边进行增广，反之说明有些点的标号 $d_v$ 过小，需要增加，而我们肯定贪心的想使得增加的权值最小。那究竟需要增加多少呢？发现一条边 $(u,v)$ 想成为可行边，需要满足 $d_u + w(u,v) = d'_v$，那么此时权值变化量为 $d'_v-d_v=d_u+w(u,v)-d_v$，正是我们上面所维护的 $\delta w$，此时修改 $\delta w$ 最小的边的 $d_v$ 的值，重新尝试增广。若没有结点可以扩展可行边且无增广路，算法终止。

该算法在增广路较短的时候比 SSP 常数更为优秀。

很不幸的是，这个基于 SSP 的费用流也被 Min_25 卡成指数复杂度了。

### Code

由于它平时实际表现仅比 SSP 略好（除非特意卡 SSP 的题），所以没有代码实现。

## Primal-Dual 原始~~人~~对偶算法

核心：SPFA 太慢，所以 Dijkstra。

你可能会问：负权图怎么 Dijkstra？类似多元最短路，考虑添加偏移量使边权非负。

SPFA 跑一遍求出距离数组 $d$，设置初始势能 $h_i=d_i$。此时，设新权值 $w'(u,v) = w(u,v)+h_u-h_v$。

为什么这么设？因为根据最短路性质 $d_u+w(u,v) \ge d_v$，所以 $w'(u,v)=w(u,v)+d_u-d_v \ge w(u,v)+d_u-(d_u+w(u,v))=0$，此时新边权非负，而且原图关键边的新边权为 $0$，仍可以正确的找到增广路！此时，使用 Dijkstra 求出新边权上最短路距离数组 $d'_u=d_u+h_S-h_u$，由于 $h_S=0$，不难得到 $d_u=d'_u+h_u$。

现在考虑增广一次后，关键边 $(u,v)$ 流量变为 $0$，被删除，加入反向边 $(v,u)$，我们需要证明在这之后边权仍非负。

因为 $(u,v)$ 在最短路上，所以 $d'_u + w'(u,v) = d'_u + (w(u,v)+h_u-h_v)=d'_v$，那么有：

$$
\begin{aligned}
&w(v,u) = -w(u,v) = d'_u+h_u-(d'_v+h_v) \\
&w(v,u)+(d'_v+h_v)-(d'_u+h_u) = 0 \ge 0
\end{aligned}
$$

所以令 $h'_u=h_u+d'_v$ 即可，可以证得此时 $(u,v)$ 的新边权仍非负，所以本算法拥有正确性。此时用 Dijkstra 求出新势能下最短路，如此往复扩流直至无法扩流。

$\mathcal{O}(|f|m\log m)$，较为快速。

### Code

代码常数太大，相比 SSP 还是快了 $3$ 倍，需要 500ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fast_IO{ // 省略快读快写
...
} using namespace fast_IO;
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
const int N = 5e3 + 7;
const int M = 1e5 + 7; // 反向边 双倍空间
const int inf = 1.05e9 + 7;
const ll linf = 1e18 + 7;
const int P = 998244353;
namespace MCMF { // Min-cost-Max-flow
    int n, m, S, T, d[N], p[N], h[N]; bool inq[N], vis[N];
    struct Edge {int u, v, nxt, w, cost;} e[M]; int head[N], ec = 1; // 边编号从 2 开始 方便寻找反向边
    inline void AddEdge(int u, int v, int w, int cost) {e[++ec] = (Edge) {u, v, head[u], w, cost}, head[u] = ec;}
    inline void Span(int u, int v, int w, int cost) {AddEdge(u, v, w, cost), AddEdge(v, u, 0, -cost);}
    inline bool SPFA() {
        static queue<int> Q; 
        REP(i, 1, n) inq[i] = false, d[i] = inf;
        Q.emplace(S), inq[S] = true, d[S] = 0;
        while (!Q.empty()) {
            int x = Q.front(); Q.pop(), inq[x] = false;
            for (int i = head[x], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
                if (e[i].w && d[v] > d[x] + e[i].cost) {
                    d[v] = d[x] + e[i].cost;
                    if (!inq[v]) Q.emplace(v), inq[v] = true;
                }
        }
        return d[T] != inf;
    }
    struct Node {int x, dis; inline bool operator < (const Node &p) const {return dis > p.dis;}};
    inline pair<int, int> solve() {
        if (!SPFA()) return {0, 0};
        static priority_queue<Node> Q;
        REP(i, 1, n) h[i] = d[i], vis[i] = false, d[i] = inf; // 初始势能
        int Flow = 0, Cost = 0;
        while (true) {
            Q.emplace((Node) {S, d[S] = 0});
            while (!Q.empty()) { // 执行 Dijkstra.
                int x = Q.top().x; Q.pop();
                if (vis[x]) continue; else vis[x] = true;
                for (int i = head[x], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
                    if (e[i].w && d[v] > d[x] + e[i].cost + h[x] - h[v]) d[v] = d[x] + e[i].cost + h[x] - h[v], p[v] = i, Q.emplace((Node) {v, d[v]});
            }
            if (d[T] == inf) break;
            int flowing_boat = inf, costing_boat = 0; // 当前增广路流流量,当前增广路流单位费用
            for (int x = T; x != S; x = e[p[x]].u) flowing_boat = min(flowing_boat, e[p[x]].w), costing_boat += e[p[x]].cost;
            Flow += flowing_boat, Cost += flowing_boat * costing_boat;
            for (int x = T; x != S; x = e[p[x]].u) e[p[x]].w -= flowing_boat, e[p[x] ^ 1].w += flowing_boat;
            REP(i, 1, n) h[i] += d[i], vis[i] = false, d[i] = inf; // 更新势能
        }
        return {Flow, Cost};
    }
} using namespace MCMF;
namespace JoKing {

    signed main() { int u, v, w, c;
        ld >> n >> m >> S >> T;
        REP(i, 1, m) ld >> u >> v >> w >> c, Span(u, v, w, c);
        pair<int, int> Ans = solve();
        return jyt << Ans.first << ' ' << Ans.second << '\n', 0; 
    }
}
signed main() {
#ifndef WYY 
    // freopen("mcmf.in", "r", stdin);
    // freopen("mcmf.out", "w", stdout);
#endif
    JoKing::main(); return 0;
}
```

## 参考资料

- [OI-WIKI 费用流](https://oi-wiki.org/graph/flow/min-cost/)。
- [Manjusaka丶梦寒 网络流学习--费用流](https://www.cnblogs.com/rmy020718/p/9548758.html)。
- [Min_25 最小費用最大流の悪例題](https://web.archive.org/web/20211009144446/https://min-25.hatenablog.com/entry/2018/03/19/235802)。

---

## 作者：liushuangning (赞：7)

upd on 2025.5.10：修正证明。感谢 [shihaojiacaigitcl](https://www.luogu.com.cn/user/613955) 指出的错误！

upd on 2025.6.9：优化。

## 思路

直接将 EK 算法中的 BFS 函数换成 SPFA 即可。

在残留网络中，如果正向边的边权为 $w(u,v)$，那么反向边的边权 $w(v,u)$ 定义为 $-w(u,v)$，因为如果要退流，就要把费用也退回去。

## 证明

正确性证明：

设 $c(p)$ 为路径 $p$ 的长度，后面为了区分单位费用和费用，将单位费用称为边权。

假设可行流 $f$ 是一个最小费用流，流量为 $v$，且残留网络 $G_f$ 中无负环，现在按最短路径 $p$ 增广，得到新流 $f'$，流量为 $v+\delta$，则 $\operatorname{cost}(f'-f)=c(p)\delta$。假设存在一个可行流 $f_n$，使得 $|f_n|=v+\delta$，且 $f_n$ 的费用小于 $f'$ 的费用，考虑流差 $f_n-f$，因为流的分解定理，$f_n-f$ 可以分解为若干从源到汇的路径和若干环：

- 路径：**至少存在一条路径 $p'$，使得 $p'$ 的长度小于 $p$ 的长度，否则 $f_n$ 的费用不可能小于 $f$ 的费用。**

- 环：由于 $G_f$ 中不存在负环，所以环贡献的长度和费用一定非负，为了降低费用，一定不选环。

因为 $p$ 为最短路径，所以不存在 $p'$ 的长度小于 $p$ 的长度，所以不存在 $p'$，那么 $f'$ 就是最优解。

现在证明加黑部分：

设 $f_n-f$ 分解出来的路径分别为 $p_1,p_2,...,p_k$，每条路径 $p_i$ 携带 $\delta_i$ 的流量，使得 $\sum \delta_i=\delta$，则：

$$
\operatorname{cost}(f_n-f)=\sum_{i=1}^k c(p_i)\delta_i
$$

因为 $c(p_i)\ge c(p)$，所以路径部分的总费用满足：

$$
\sum_{i=1}^k c(p_i)\delta_i\ge \sum_{i=1}^k c(p)\delta_i=c(p)\sum_{i=1}^k \delta_i=c(p)\delta
$$

所以：

$$
\operatorname{cost}(f_n-f)\ge c(p)\delta
$$

这就与 $f_n$ 的费用比 $f'$ 的费用小而矛盾，所以这样做是正确的。

这时候有些聪明的同学就发现了：如果一条边已经流了一些流量后，那么反向边的边权就会变成负数，那么如何保证不会出现负环呢？

定义 $d_u$ 表示 $u$ 点的最短路径值，即代码中的 `d[u]`。我们假设第 $k$ 步后没有出现负环，但是第 $k+1$ 步后出现了负环 $C$，则 $C$ 中至少包含一条新增的反向边 $v\to u$，反向边的费用为 $-c(u,v)$。假设环 $C$ 的边权之和为其他边的费用之和 $sum$ 加上这条边的 $-c(u,v)$，则 $sum-c(u,v)<0$，即 $sum<c(u,v)$。

因为我们是按照最短路径增广的，所以 $d_v=d_u+c(u,v)$（根据最短路径的性质），则 $d_v-d_u=c(u,v)$，则 $sum\ge c(u,v)$（因为 $d_v-d_u$ 是按照最短路径求出来的，不可能存在更短的替代路径），与假设矛盾，所以不可能存在负环。

## 时间复杂度

最坏情况下，此算法的时间复杂度为 $O(nmf)$，其中 $f$ 为最大流。因为每次增广增加的流量 $\Delta f>0$，所以最多增广 $f$ 次。每次增广都需要一遍 SPFA，所以时间复杂度最坏为 $O(nmf)$。

---

参考代码：

```cpp
#include<bits/stdc++.h>
#define mems(a,b) memset(a,b,sizeof a)
using namespace std;
const int N=5010,M=100010,inf=0x3f3f3f3f;
int n,m,S,T;
int h[N],e[M],ne[M],f[M],w[M],idx;
int q[N],d[N],pre[N],incf[N];//d表示从源点到每个点的长度，incf表示走到每个点时的最大流量
bool st[N];
void add(int a,int b,int c,int d){
	e[idx]=b;
	f[idx]=c;
	w[idx]=d;
	ne[idx]=h[a];
	h[a]=idx++;
	e[idx]=a;
	f[idx]=0;
	w[idx]=-d;
	ne[idx]=h[b];
	h[b]=idx++;
}
bool spfa(){
	int hh=0,tt=1;
	mems(d,0x3f);
	mems(incf,0);
	q[0]=S;
	d[S]=0;
	incf[S]=inf;//源点的流量无限制
	while(hh!=tt){
		int t=q[hh++];//出队
		if(hh==N) hh=0;//循环队列
		st[t]=false;//一个点可以多次入队
		for(int i=h[t];~i;i=ne[i]){
			int ver=e[i];
			if(f[i]>0 && d[ver]>d[t]+w[i]){
				d[ver]=d[t]+w[i];//求最短路
				pre[ver]=i;//到ver的边是i这条边
				incf[ver]=min(f[i],incf[t]);
				if(!st[ver]){
					q[tt++]=ver;//入队
					if(tt==N) tt=0;
					st[ver]=true;
				}
			}
		}
	}
	return (incf[T]>0);//判断汇点的流量是否大于0，等价于判断能不能到汇点
}
void EK(int &flow,int &cost){//传引用
	flow=cost=0;
	while(spfa()){
		int t=incf[T];//流量
		flow+=t;
		cost+=t*d[T];
		for(int i=T;i!=S;i=e[pre[i]^1]){//反向边的终点就是正向边的起点
			f[pre[i]]-=t;
			f[pre[i]^1]+=t;
		}
	}
}
int main(){
	cin>>n>>m>>S>>T;
	mems(h,-1);
	while(m--){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		add(a,b,c,d);
	}
	int flow,cost;
	EK(flow,cost);
	cout<<flow<<" "<<cost;
	return 0;
}
```

---

## 作者：fengzhaoyu (赞：7)

~~原始对偶算法是个好东西~~
## 思路
前置芝士：[dinic-算法](https://oi-wiki.org/graph/flow/max-flow/#dinic-算法)。

看看题解没有 dijkstra 加 dinic 的，这里来写一下。

首先要知道，网络流就是对于一条 $u\rightarrow v$ 的路径反向再建权值为 0 的路径，如果这条路经过了 $x$ 的流量，那么他的反边就会增加 $x$ 的权值，以便以后可以“反悔”。最小费用最大流是贪心地每次按价格的最短路进行增广，那很容易想到加一个 spfa，每次都找一条 $s\rightarrow t$ 的最短路进行增广，直到不存在这样的路径为止。可以证明，此时的路径一定最优（蒟蒻太蒟蒻了，不会证，有意愿者可以上网查证明方法），详见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
const int N=5e4+15,M=5e5+15,inf=INT_MAX;
int read()
{
	int t=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') t=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return t*x;
}
int cur[N],to[M],ne[M],f[M],w[M],d[N],vis[N];
int dis[N],hh[N];
int n,m,s,t,idx;
void add(int u,int v,int ww,int c)
{
	to[idx]=v;
	ne[idx]=hh[u];
	f[idx]=ww;// 流量限制
	w[idx]=c;// 价格
	hh[u]=idx++;
}
bool spfa()//求最短路并判断此时是否存在增广路
{
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++) dis[i]=inf;
	queue<int>q;
	q.push(s);
	vis[s]=1;
	dis[s]=0;
	d[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=hh[u];i!=-1;i=ne[i])
		{
			int v=to[i];
			if(f[i]&&dis[v]>dis[u]+w[i])
			{
				dis[v]=dis[u]+w[i];
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	if(dis[t]<inf) return 1;
	return 0;
}
int ans1=0,ans2=0;
int dfs(int u,int mf)
{
	if(u==t) return mf;
	int sum=0;
	vis[u]=1;//这样是为了下文判断是否存在负环，如果有，可直接跳过
	for(int i=cur[u];i!=-1;i=ne[i])
	{
		cur[u]=i;//当前弧优化
		int v=to[i];
		if(f[i]&&dis[v]==dis[u]+w[i]&&vis[v]==0)//保证了一定会按最短路增广
		{
			int ff=dfs(v,min(mf,f[i]));
			f[i]-=ff;
			f[i^1]+=ff;
			sum+=ff;
			mf-=ff;
			ans2+=ff*w[i];//由于dinic是多路增广，所以只能边遍历便更新值
			if(mf==0) break;
		}
	}
	vis[u]=0;
//	if(sum==0) d[u]=0;
	return sum;
}
void Dinic()
{
	while(spfa())
	{
		memcpy(cur,hh,sizeof hh);
		ans1+=dfs(s,inf);
	}
	printf("%d %d\n",ans1,ans2);
}
int main()
{
	memset(hh,-1,sizeof hh);
	n=read(),m=read(),s=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read(),c=read();
		add(u,v,w,c);
		add(v,u,0,-c);
	}
	Dinic();
	return 0;
}
```
但是，我们知道，关于 spfa，它~~已经死了~~远不如 dijkstra，那有没有一种方法使此题能用 dijkstra 呢？有，**原始对偶算法**。我们先想，此题本来不用 dijkstra 的原因是因为有负环，那我们是否能变负为正呢？

1. 引入势函数（对偶变量）$h_{u}$，为每个节点 $v$ 维护一个势能值。
2. 重新定义边权：对每条边 $u\rightarrow v$，定义修正边权：$c'_{u,v}=c_{u,v}+h_u−h_v$。

3. 其中 $c_{u,v}$ 是原始费用。可以通过设置合适的 $h_u$，使得所有修正权 $c'_{u,v}\geq 0$，从而允许使用 dijkstra 算法。

4. 那么由此可得：$c_{u,v}+h_u-h_v\geq 0$，将 $h_v$ 移项——不就是最短路中的松弛操作吗？那好，初始势函数的值可以用从 $s$ 出发的最短路来表示。(正确性的证明：对于一条增广路，一条边 $c'_{i,j}=c_{i,j}+h_i-h_j$，它的下一条边 $c'_{j,k}=c_{j,k}+h_j-h_k$，当它们相加时，$h_j$ 抵消了！由此推出：$\sum c'_{u,v}=\sum c_{u,v}+h_s-h_t$，因此，路径的实际费用与修正费用仅相差一个常数，与路径无关。也就是说，每次增广多带来的值是一样的。)
5. 设 d_{v} 是当前残量网络中从 $s$ 到 $v$ 的最短修正距离（dijkstra 得），势函数更新为 $h_{newv}=h_{oldv}+d_{v}$。此时是否仍然保持非负性？对于一条边，$d_v\leq d_{u}+c'_{u,v}=d_u+c_{u,v}+h_{oldu}-h_{oldv}$，整理得：$c_{u,v}+h_{oldu}+d_u-h_{oldv}+d_v\geq 0$，其中 $h_{oldu}+d_u-h_{oldv}$ 就是势函数更新了。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
const int N=1e5+15,inf=INT_MAX;
int read()
{
	int t=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') t=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return t*x;
}
int cur[N],to[N],ne[N],f[N],w[N],vis[N];
int dis[N],h[N],hh[N];
int n,m,s,t,idx;
void add(int u,int v,int ww,int c)
{
	to[idx]=v;
	ne[idx]=hh[u];
	f[idx]=ww;
	w[idx]=c;
	hh[u]=idx++;
}
void spfa()//求h初始值，因为只跑一次，所以不会慢
{
	memset(h,0x3f,sizeof h);
	queue<int>q;
	q.push(s);
	vis[s]=1;
	h[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=hh[u];i!=-1;i=ne[i])
		{
			int v=to[i];
			if(f[i]&&h[v]>h[u]+w[i])
			{
				h[v]=h[u]+w[i];
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}

}
bool dijkstra()
{
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++) dis[i]=inf;
	priority_queue<pii,vector<pii>,greater<pii> >q;
	q.push({0,s});
	dis[s]=0;
	while(!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=hh[u];i!=-1;i=ne[i])
		{
			int v=to[i];
			if(f[i]&&dis[v]>dis[u]+w[i]+h[u]-h[v])
			{
				
				dis[v]=dis[u]+w[i]+h[u]-h[v];
				q.push({dis[v],v});
			}
		}
	}
	return dis[t]!=inf;
}
int ans1=0,ans2=0;
int dfs(int u,int mf)
{
	if(u==t) return mf;
	int sum=0;
	vis[u]=1;
	for(int i=cur[u];i!=-1;i=ne[i])
	{
		cur[u]=i;
		int v=to[i];
		if(f[i]&&vis[v]==0&&h[v]==h[u]+w[i])
		{
			
//			cout<<"ll";
			int ff=dfs(v,min(mf,f[i]));
			f[i]-=ff;
			f[i^1]+=ff;
			sum+=ff;
			mf-=ff;
			ans2+=ff*w[i];
			if(mf==0) break;
		}
	}
	vis[u]=0;
	return sum;
}
void Dinic()
{
	spfa();
	while(dijkstra())
	{
		memset(vis,0,sizeof vis);
		memcpy(cur,hh,sizeof hh);
		for(int i=1;i<=n;i++) h[i]+=dis[i];
		int k=dfs(s,inf);
		ans1+=k;
	}
	printf("%d %d\n",ans1,ans2);
}
int main()
{
	memset(hh,-1,sizeof hh);
	n=read(),m=read(),s=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read(),c=read();
		add(u,v,w,c);
		add(v,u,0,-c);
	}
	Dinic();
	return 0;
}
```
~~完美撒花！~~

---

## 作者：QianK (赞：2)

写一篇题解来加深印象。其他题解都没有说明复杂度的问题和常见易错点。本文将介绍用 vector 来存图，采用 spfa + dinic 的算法，也就是 SSP 算法。

## SSP 算法

默认读者已经学会了最大流算法。现在，我们每条边加上**单位流量**的费用，要求在最大流的基础上满足费用最小，这就是最小费用最大流问题。

简单来说，我们每次贪心地选择费用最小的增广路增广，直到不存在增广路时终止算法。需要注意的是，图中不能有负圈，如果存在负圈，首先要用消圈算法消除负圈。[存在负圈的题目](https://www.luogu.com.cn/problem/P7173)这是一道有负圈的费用流模板题。

现在证明一下贪心的正确性。我们已知图中不存在负圈。假设流量为 $i$ 的流的费用为 $f_i$，我们通过增广一次最短增广路求出 $f_j$。如果存在另一种从 $f_i$ 增广一次增广路且小于 $f_j$ 的费用流 $f_k$，则该增广必然走过负圈，与已知图中不存在负圈矛盾，所以贪心是可行的。

由于极端情况下 spfa 找增广路的时间复杂度为 $O(nm)$，故 SSP 算法的复杂度为 $O(nmf)$，其中 $f$ 为网络最大流，需要注意的是，这并不是一个多项式复杂度，例如 $f = 2^{n/2}$ 时，复杂度为指数级别。

实现代码时，可能存在一些易错点。首先，用 vector 来存图，找反向边时需要添加对应编号快速寻找反向边，其次，反向边的费用应该是 $-c$，这样走反向边时才满足最短路的判断条件，正向边的条件为 $dis[v]=dis[u]+c$，反向边就是 $dis[u]=dis[v]+(-c)$。最后，跑一次 spfa 应该**多次** dfs 找增广路而不是只找一次，有的题目会卡只找一次的代码。

附上代码。

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
#define int long long//开longlong
using namespace std;
const int N = 5e3 + 5;
const int inf = 0x7fffffff;
int n, m, s, t, mincos;
struct node
{
    int v, w, c, id;
};
vector<node> val[N];
int dis[N], cur[N];
bool vis[N];

bool spfa()
{
    for (int i = 1; i <= n; i++)
        dis[i] = inf;
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        vis[x] = false;
        for (auto &e : val[x])
            if (e.w && dis[e.v] > dis[x] + e.c)
            {
                dis[e.v] = dis[x] + e.c;
                if (!vis[e.v])
                    q.push(e.v), vis[e.v] = true;
            }
    }
    return dis[t] != inf;//如果存在增广路就返回true，否则返回false
}

int dfs(int x, int res)
{
    if (x == t || !res)
        return res;
    vis[x] = true;
    int used = 0;
    for (int i = cur[x]; i < val[x].size(); ++i)
    {
        auto &e = val[x][i];
        cur[x] = i;//当前弧优化
        if (!vis[e.v] && e.w && dis[e.v] == dis[x] + e.c)
        {
            int cnt = dfs(e.v, min(res - used, e.w));//递归找流量
            if (cnt)
            {
                e.w -= cnt;
                val[e.v][e.id].w += cnt;
                mincos += cnt * e.c;
                used += cnt;
                if (used == res)
                    break;//残留优化
            }
        }
    }
    vis[x] = false;
    return used;
}

int dinic()
{
    int ans = 0, flow;
    while (spfa())
    {
        memset(cur, 0, sizeof(cur));
        while ((flow = dfs(s, inf)))//一次spfa要找多次增广路
            ans += flow;
    }
    return ans;
}

signed main()
{
    scanf("%lld%lld%lld%lld", &n, &m, &s, &t);
    for (int i = 1; i <= m; ++i)
    {
        int u, v, w, c;
        scanf("%lld%lld%lld%lld", &u, &v, &w, &c);
        val[u].push_back({v, w, c, (int)val[v].size()});//记录反向边的id
        val[v].push_back({u, 0, -c, (int)val[u].size() - 1});//记录反向边的id
    }
    int maxflow = dinic();
    printf("%lld %lld\n", maxflow, mincos);
    return 0;
}
```

---

## 作者：wjyppm1403 (赞：2)

题解区没有 vector 版本实现的 SSP 算法费用流，这篇题解给出一个做法。

# SSP算法介绍
最小费用最大流就是在最大流的基础上，每条边还有单位流量费用，流经一条边的费用就是流量乘那条边的单位费用，求在最大流的前提下总费用最小。

那我们怎么做到总费用最小？这里我们介绍的 SSP 算法通过贪心的找费用最小的增广路来增广，这样就能保证我们最终求得的费用流一定是最小的，并且求得的也是最小费用最大流。需要注意的是 SSP 算法只能在没有负环的图上使用。

具体实现就是将 EK 或 Dinic 算法的增广路寻找改成最短路算法，若用 SPFA 算法实现，时间复杂度为 $O(nmf)$，其中 $f$ 为最大流。

# vector实现

一般的费用流使用链式前向星来做到快速寻找反向边，vector 的局限性在于此无法快速寻找，如果暴力遍历的时间复杂度，如果是 EK 算法那么时间复杂度将为 $O(n^2m^2)$，会直接炸掉。

那么我们怎么实现呢？其实很简单，只需要记录一下反向边的边号即可，当我们加入一条边之前，邻接表数组里面存的个数为 `adj[u].size()`，它们的下标从 $0\rightarrow size-1$，那么我们新插入一个，一定会被放在 `adj[u].size()` 的位置。

代码实现：

```cpp
struct Edge{
    int v,w,c,id;
};
vector<Edge> adj[MN];

void add(int u,int v,int w,int c){
    int us=adj[u].size(),vs=adj[v].size();// 记录两个下标
    adj[u].push_back({v,w,c,vs});
    adj[v].push_back({u,0,-c,us}); // 费用流的芝士，这里反向边的边权应当为负
}
```

那弧优化呢？其实也很简单，因为我只需要记录当前没有流满的是到哪个点的路径，那么同理即可。

因为 Dinic 算法比较常用，这里下面给出这种实现的完整代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int MN=5e3+15;
constexpr int INF=0x3f3f3f3f;
struct Edge{
    int v,w,c,id;
};
int n,m,S,T,mincst,dis[MN],cur[MN];
vector<Edge> adj[MN];
bool vis[MN];

void add(int u,int v,int w,int c){
    int us=adj[u].size(),vs=adj[v].size();
    adj[u].push_back({v,w,c,vs});
    adj[v].push_back({u,0,-c,us});
}

bool spfa(){// SPFA,有后遗症的自行替换
    queue<int> q;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    q.push(S);
    dis[S]=0;
    vis[S]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(auto e:adj[u]){
            if(e.w&&dis[e.v]>dis[u]+e.c){
                dis[e.v]=dis[u]+e.c;
                if(!vis[e.v]){
                    q.push(e.v);
                    vis[e.v]=1;
                }
            }
        }
    }
    memset(cur,0,sizeof(cur));
    return (dis[T]!=INF);
}

int dfs(int u,int lim){
    if(u==T) return lim;
    vis[u]=1;
    int ret=0;
    for(int i=cur[u];i<adj[u].size();i++){
        cur[u]=i;// 弧优化
        int v=adj[u][i].v;
        if(!vis[v]&&adj[u][i].w&&dis[v]==dis[u]+adj[u][i].c){
            int p=dfs(v,min(lim,adj[u][i].w));
            if(!p) dis[v]=INF;
            adj[u][i].w-=p;
            adj[v][adj[u][i].id].w+=p;
            ret+=p;
            lim-=p;
            mincst+=p*adj[u][i].c;// mincst在这里计算
            if(!lim) break;// 若流量为0则优化
        }
    }
    vis[u]=0;
    return ret;
}

int dinic(){
    int ans=0;
    while(spfa()){
        ans+=dfs(S,INF);// 这里和最大流的dinic不太一样，注意一下。
    }
    return ans;
}

int main(){
    cin>>n>>m>>S>>T;
    for(int i=1;i<=m;i++){
        int u,v,w,c;
        cin>>u>>v>>w>>c;
        add(u,v,w,c);
    }
    cout<<dinic()<<" "<<mincst;
    return 0;
}
```

完结撒花( ˘ 3˘)♥

---

## 作者：chentianmiao (赞：2)

Upd on 2025.7.8：修正，感谢 [TBSF_0207](https://www.luogu.com.cn/user/655088) 指出的错误！
## 思路分析
最小费用最大流（以下简称 MCMF，Min-Cost-Max-Flow），就是在满足最大流的前提下找最小费用（注意不是在最小费用前提下找最大流）。

看到费用，我们可以把他变成权值，于是似乎问题有点像最短路，于是想到了 SPFA（至于为什么不用 dijkstra，是因为反向建边时，费用为负）。

于是我们将 EK 中的 bfs 换成 SPFA，每次找费用最小的增广路，复杂度 $\mathcal O (nmf)$，$f$ 为最大流，问题解决。

## 正确性证明
即证 EK+SPFA 算法能正确求解 MCMF 问题，需要保证最优性，于是我们必须保证最小费用增广路中始终无负环。这里用反证法证明。

显然一般最开始不会有负环，否则存在零流量但负费用情况，往往不符合实际问题的设定。

假设从无负环的残量网络中，找最小费用增广路推流，新的残量网络突然出现负环。

如下图，设 $dst[p]<dst[q]$，则 $S$ 到 $T$ 的最小费用经过 $p$。

![](https://cdn.luogu.com.cn/upload/image_hosting/udy2kmx3.png)

而由 $p'$ 和 $q$ 构成负环可知 $dst[p']+dst[q]<0$，于是 $dst[q]-dst[p]<0$，进而 $dst[q]<dst[p]$，与 $dst[p]<dst[q]$ 矛盾。

![](https://cdn.luogu.com.cn/upload/image_hosting/z4syp0xj.png)

汇总就是：
起始网络无负环的情况下，EK 算法每轮增广路推流后都没有负环，满足最优性条件，每轮得到的费用都是当前流量的最小费用，最终得到最大流时费用也是最小的。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1e9,V=5009,E=50009*2;
int pre[V],flow[V],dst[V];
bool in[V];
struct Edge{
	int to,nxt,cap,cpu;
}e[E];
int hd[V],nE=1;
int nV,S,T,n,m;
void add(int u,int v,int cap,int cpu){
	e[++nE]=(Edge){v,hd[u],cap,cpu};
	hd[u]=nE;
}
bool SPFA(){
	fill(dst+1,dst+nV+1,INF);
	fill(in+1,in+nV+1,0);
	fill(pre+1,pre+nV+1,0);
	queue<int>q;
	dst[S]=0;
	flow[S]=INF;
	in[S]=1;
	pre[S]=-1;
	q.push(S);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		in[u]=0;
		for(int i=hd[u];i;i=e[i].nxt){
			int cap=e[i].cap;
			if(!cap){
				continue;
			}
			int v=e[i].to;
			if(dst[v]<=dst[u]+e[i].cpu){
				continue;
			}
			dst[v]=dst[u]+e[i].cpu;
			flow[v]=min(flow[u],cap);
			pre[v]=i;
			if(!in[v]){
				in[v]=1;
				q.push(v);
			}
		}
	}
	return pre[T];
}
void EK(){
	int mxFlw=0,mnCst=0;
	while(SPFA()){
		mxFlw+=flow[T];
		mnCst+=flow[T]*dst[T];
		for(int u=T;u!=S;u=e[pre[u]^1].to){
			e[pre[u]].cap-=flow[T];
			e[pre[u]^1].cap+=flow[T];
		}
	}
	cout<<mxFlw<<" "<<mnCst;
}
int main(){
	cin>>n>>m>>S>>T;
	for(int i=1;i<=m;i++){
		int u,v,cap,cpu;
		cin>>u>>v>>cap>>cpu;
		add(u,v,cap,cpu);
		add(v,u,0,-cpu);
	}
	nV=n;
	EK();
	return 0;
}
```

---

## 作者：dyc2022 (赞：1)

[更好的阅读体验](https://www.cnblogs.com/dyc2022/p/18980165)
***
这是一道模板题。在做这道题之前，你应该要学会：
- [【模板】网络最大流](/problem/P3381)
- [【模板】负环](/problem/P3376)
***
对于网络 $(V, E)$，边 $(u, v)$ 带容量 $f(u, v)$ 和费用 $c(u,v)$。求出 $S \to T$ 的所有最大流中所选边费用最小的方案，称作网络的最小费用最大流（MCMF）。

对此，我们以求解最大流的 Edmonds-Karp 算法为基础。EK 的过程是，每次选择一条 $S \to T$ 的**非满流路径**并将其流满，称作一次增广，增广的路径称作增广路。

在求解最小费用的过程中，我们以 $c(u, v)$ 为边权，每次选择 $S \to T$ 的**最短非满流简单路径**作为增广路，这样就能求出最大流当中的最小费用。这就是 EK 求最大流的方法。
***
我们想想这个东西为什么是对的。

EK 结束的条件是图中不存在合法路径。一方面，根据最大流最小割定理，一个流是最大流当且仅当途中不存在增广路径。所以求出最大流的正确性显然。

另一方面，我们需要说明这种方案所需要的费用是最少的。记处于一个局面时的最小费用为 $C_0$，我们通过最短路进行一次增广后的最小费用为 $C_1$，此时假设我们存在另外一条增广路径求出的费用为 $C_2$ 且 $C_2 < C_1$。由于 $C_1$ 时当前局面下的的最短简单路径，因此 $C_2$ 的增广路必然存在负环，和增广路的**简单性**相违背。

综上所述，我们证明了该算法的正确性。
***
我们回到实现上。我们可以使用 SPFA 算法寻找最短简单路径，在松弛的时候记录每个点的前驱。随后我们沿着记录的路径进行增广，同时将最小费用加上路径的边权和。

由于一次增广至少使最大流增加 $1$，假设原图最大流为 $f$，因此最多经过 $f$ 轮增广后得出答案。由于使用的是 SPFA，因此一次增广的复杂度为 $O(nm)$，总复杂度是 $O(nmf)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 5006
#define M 50006
using namespace std;
int n,m;
struct MCMF_Graph{//by dyc2022
int head[N],tot=2,s,t;
int dis[N],incf[N],pre[N],vis[N],maxflow,mincost;
struct Node{int nxt,to,w,c;}E[M<<1];
void addedge(int u,int v,int w,int c){E[tot]={head[u],v,w,c},head[u]=tot++;}
void addflow(int u,int v,int w,int c){addedge(u,v,w,c),addedge(v,u,0,-c);}
int SPFA()
{
    for(int i=1;i<=n;i++)dis[i]=1e15;
    queue<int> q;
    q.push(s),dis[s]=0,incf[s]=1e15,incf[t]=0;
    while(!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=E[i].nxt)
        {
            int v=E[i].to,w=E[i].w,c=E[i].c;
            if(!w||dis[v]<=dis[u]+c)continue;
            dis[v]=dis[u]+c,incf[v]=min(incf[u],w),pre[v]=i;
            if(!vis[v])q.push(v),vis[v]=1;
        }
    }
    return incf[t];
}
void EK()
{
    maxflow+=incf[t];
    for(int u=t;u!=s;u=E[pre[u]^1].to)
    {
        E[pre[u]].w-=incf[t],E[pre[u]^1].w+=incf[t];
        mincost+=incf[t]*E[pre[u]].c;
    }
}
void getflow(){while(SPFA())EK();}}G;
main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&G.s,&G.t);
    for(int i=1,u,v,w,c;i<=m;i++)
        scanf("%lld%lld%lld%lld",&u,&v,&w,&c),G.addflow(u,v,w,c);
    G.getflow();
    printf("%lld %lld\n",G.maxflow,G.mincost);
    return 0;
}
```

---

## 作者：LEWISAK (赞：1)

[我的博客](https://www.cnblogs.com/lewisak)

## 费用流

### 定义

就是对每一条边加了个权值 $w_{u,v}$，定义对于一条边的花费为 $w_{u,v}\times f_{u,v}$，求：在满足最大流的前提下使得花费最小/大的花费和流量。

### Dinic/EK 求费用流

把它们算法中的 bfs 换为 spfa 即可，无需脑子即可实现，这篇侧重点不在这里就不贴代码了昂

### ISAP 求费用流（

经过了不知道多久的钻研后，我认为这个算法反正我是难以实现了😭。

ISAP 不能直接求费用流的原因是因为它最核心的层数思想失效了—如果你想要延续这个思想，你就需要在某个点在走第 $k$ 短路的情况下被榨干后把它的标号改为从 $k+1$ 更新出来的，这个思路一眼让复杂度伪。

有兴趣的研究新算法的请[移步](https://www.luogu.com.cn/discuss/1082789)，可能我的一些思考会对你有帮助吧。

### 原始对偶算法求最小费用最大流

这就是神！~~要水估值写详细点~~。

在讲解这之前，我们要先介绍另一个算法。

#### Johnson 全源最短路径算法

这个算法用来求什么看算法名都能看出来吧。

我们注意到 dij 的复杂度非常的优秀，但是如果有负边权它就死了。

所以我们考虑对原图的边权进行处理使得在不改变答案的情况下使得边权非负。

一个伪的没边的方法是把所有边权都加上一个定值后统计答案时减去。

这个方法伪的地方是因为我们最短路时会受这个定值的影响，每多走一条边就会让距离多一个不该多的定值。

##### 算法实现

新建一个虚拟点 0，并将它与所有点连一条边权为 0 的边，然后以 0 为起点跑 spfa 后对于边 $u\to v$ 的边权 $w_{u,v}$ 修改为 $w_{u,v}+h_{u}-h_{v}$。

##### 正确性证明

我们注意到修改边权后对于一条路径 $s\to x_1\to x_2\to\dots\to x_n\to t$ 的长度为：
$$
\begin{aligned}
&~~~~~~w_{s,x_1}+h_s-h_{x_1}+w_{x_1,x_2}+h_{x_1}-h_{x_2}+\dots+w_{x_n,t}+h_{x_n}-h_{t}\\
&\Rightarrow w_{s,x_1}+w_{x_1,x_2}+\dots+w_{x_n,t}+h_s-h_{t}
\end{aligned}
$$
也就是说相较于原路径，我们多了 $h_s-h_t$ 的长度，但这个显然是定值，减掉即可。

然后我们还要证明关键的性质：所有边权为正。

注意到一个显然的事情 $h_u+w_{u,v}$ 我们可以理解是从 0 到 $v$ 的最短路但必须经过 $u$ 的长度，而 $h_v$ 就是从 0 到 $v$ 最短路长度，所以有 $h_v\le h_u+w_{u,v}$，也就是 $w_{u,v}+h_u-h_v$ 非负，也就是边权非负了！。

> 那有的小朋友就要问了：这个算法和最小费用最大流有什么关系呢？

我们可以先像 Johnson 一样对边权进行处理，但是问题是我们的增广会改变图的形态，所以我们要对 $h$ **动态处理**。

先直接说结论：可以对 $h_i$ 加上 $s\leadsto i$ 的最短路长度 $d_i$。

首先我们刚刚证的第一个东西显然不需要重新证明，而且网络流上甚至因为我们只需要知道增广路是那条，所以连 $h_s-h_t$ 都不用减了！

现在证明边权非负：

* 对于增广路的边，因为它在最短路上，所以有：
  $$
  \begin{aligned}
  d_i+(w_{i,j}+h_i-h_j)&=d_j\\
  w_{i,j}+(d_i+h_i)-(h_j+d_j)&=0
  \end{aligned}
  $$
  于是非负。

* 对于增广后多的边（增广路上边的反向边）：
  $$
  \begin{aligned}
  d_i+(w_{i,j}+h_i-h_j)&=d_j\\
  d_i-(w_{j,i}-h_i+h_j)&=d_j\\
  (w_{j,i}-h_i+h_j)+d_j-d_i&=0\\
  w_{j_i}-(h_i+d_i)+(h_j+d_j)&=0
  \end{aligned}
  $$
  其中第一行推出第二行的原因是反向边的边权为正向边边权的相反数，于是非负。

* 对于其他边，和 Johnson 最后一步证明时类似的，有：
  $$
  \begin{aligned}
  d_i+(w_{i,j}+h_i-h_j)&\ge d_j\\
  w_{i,j}+(h_i+d_i)-(h_j+d_j)&\ge 0
  \end{aligned}
  $$
  于是非负。

然后就证完了🎉
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace kong{bool st;}
namespace zhu{
int tot=1,head[1001000],answ,ansc,n,m,s,t,h[1001000],dis[1001000],vis[1001000];
queue<int> q;
struct node{
	int v,id;
	bool operator<(const node& a)const{
		return v>a.v;
	}
};
priority_queue<node> qq;
struct{
	int nxt,to,w,c;
}e[2002000],fr[2002000];
//fr 记录找到的增广路
void add(int u,int v,int w,int c){
	e[++tot]={head[u],v,w,c};
	head[u]=tot;
	e[++tot]={head[v],u,0,-c};
	head[v]=tot;
	return;
}
void spfa(){
	while(!q.empty()) q.pop();
	memset(vis,0,sizeof vis);
	memset(h,0x3f,sizeof h);
	h[s]=0;vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,c=e[i].c;
			if(e[i].w&&h[v]>h[x]+c){
				h[v]=h[x]+c;
				if(vis[v]) continue;
				vis[v]=1;
				q.push(v);
			}
		}
	}
}
bool dij(){
	while(!qq.empty()) qq.pop();
	for(int i=1;i<=n;i++) vis[i]=0,dis[i]=1e18;
	dis[s]=0;
	qq.push({0,s});
	while(!qq.empty()){
		int x=qq.top().id;
//		cout<<x<<'\n';
		qq.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].c+h[x]-h[v];
//			cout<<v<<' '<<e[i].c<<' '<<h[v]<<'\n';
			if(e[i].w&&dis[v]>dis[x]+w){
//				cout<<"aowufbh";
				dis[v]=dis[x]+w;
				fr[v].nxt=i;
				fr[v].to=x;
				if(!vis[v]) qq.push({dis[v],v});
			}
		}
//		cout<<'\n';
	}
	return dis[t]!=1e18;
}
void PD(){
	spfa();
//	for(int i=1;i<=n;i++) cout<<h[i]<<' ';
//	cout<<"\n\n";
	while(dij()){
		int minn=1e18;
		for(int i=1;i<=n;i++){
//			cout<<dis[i]<<' ';
			h[i]+=dis[i];
		}
//		cout<<'\n';
		for(int i=t;i!=s;i=fr[i].to){
			minn=min(minn,e[fr[i].nxt].w);
		}
//		cout<<minn<<'\n';
		for(int i=t;i!=s;i=fr[i].to){
			e[fr[i].nxt].w-=minn;
			e[fr[i].nxt^1].w+=minn;
		}
		answ+=minn;
		ansc+=minn*h[t];
	}
}
string main(){
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++){
		int u,v,w,c;
		cin>>u>>v>>w>>c;
		add(u,v,w,c); 
	}
	PD();
	cout<<answ<<' '<<ansc<<'\n';
	return "Primal-Dual 原始对偶算法长得真好看啊！\n";
}
}
namespace kong{bool ed;double kj(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<'\n'<<kong::kj();
	return 0;
}
```

顺此一提，这个算法的缺点是[无法动态加点](https://www.luogu.com.cn/discuss/842886)

---

## 作者：fush (赞：1)

前置：[**最大流**](https://fush-netlify.netlify.app/article/graph/flow/max-flow/)。

我们只需要在做最大流的时候，把 bfs 换成以代价作为边权的 spfa 就好了。  
这样我们每次会贪心的找费用最少得增广路增广。

记得把反边的代价设为 $-g(u, v)$，因为我们还需要退回费用。

我们成这个算法为 SSP，最坏时间复杂度是 $O(nmf)$，其中 $f$ 表示该网络的最大流。

---
正确性证明：  
我们考虑使用数学归纳法和反证法来证明。

设流量为 $i$ 的时候最小费用为 $f_i$。我们假设最初的网络上**没有负圈**，这种情况下 $f_0=0$。

假设求出的 $f_i$ 是最小费用，我们在 $f_i$ 的基础上，找到一条最短的增广路，从而求出 $f_{i+1}$。这时 $f_{i+1}-f_i$ 是这条最短增广路的长度。

假设存在更小的 $f_{i+1}$，设它为 
$f'_{i+1}$。因为 $f_{i+1}-f_i$ 已经是最短增广路了，所以 
$f'_{i+1}-f_i$ 一定对应一个经过**至少一个负圈**的增广路。

这时候矛盾就出现了：既然存在一条经过至少一个负圈的增广路，那么 $f_i$ 就不是最小费用了。因为只要给这个负圈添加流量，就可以在不增加 $s$ 流出的流量的前提下，使 $f_i$ 对应的费用更小。

综上，算法可以正确求出**无负圈**网络的最小费用最大流。

---

EK 示例：
```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a, b, c) for (int a = (b), a##end = (c); a <= a##end; ++a)
#define FR(a, b, c) for (int a = (b), a##end = (c); a >= a##end; --a)
#define lowbit(x) ((x) & -(x))
#define eb emplace_back
#define int long long
#define vt vector
#define ar(x) array<int, x>
#define PII pair<int, int>
#define max(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7<tmd67v8?tmd67v8:b5k5u7; })
#define cmax(a, b) ({auto tmd67v8=(b);(tmd67v8>a)&&(a=tmd67v8); })
#define min(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7>tmd67v8?tmd67v8:b5k5u7; })
#define cmin(a, b) ({auto tmd67v8=(b);(tmd67v8<a)&&(a=tmd67v8); })
constexpr int N = 5e3 + 10, inf = 1e18;
struct edge{int to, next, w, g;}e[50010 * 2];
int n, h[N], dis[N], vis[N], pre[N], tot = 1;
queue<int> q;
void add(int u, int v, int w, int g) { e[++tot] = {v, h[u], w, g}, h[u] = tot; }
PII EK(int s, int t){
	int ans = 0, mi, cost = 0;
	auto spfa = [&](){
		memset(vis, 0, sizeof vis), memset(dis, 0x7f, sizeof dis);
		vis[s] = 1, q.emplace(s), dis[s] = 0;
		while (!q.empty()){
			for (int u = q.front(), i = (q.pop(), h[vis[u] = 0, u]), v; i; i = e[i].next)
				if (e[i].w && dis[u] + e[i].g < dis[v = e[i].to]){
					dis[v] = dis[u] + e[i].g, pre[v] = i;
					if (!vis[v])
						q.emplace(v), vis[v] = 1;
				}
		}
		return dis[t] < dis[0];
	};
	while (spfa()){
		for (int i = (mi = inf, t); i ^ s; i = e[pre[i] ^ 1].to)
			mi = min(mi, e[pre[i]].w);
		for (int i = (ans += mi, cost += dis[t] * mi, t); i ^ s; i = e[pre[i] ^ 1].to)
			e[pre[i]].w -= mi, e[pre[i] ^ 1].w += mi;
	}
	return {ans, cost};
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int n, m, s, t, a, b, c, d;
	cin >> n >> m >> s >> t;
	while (m--)
		cin >> a >> b >> c >> d, add(a, b, c, d), add(b, a, 0, -d);
	auto w = EK(s, t);
	cout << w.first << " " << w.second << endl;
	return 0;
}
```

Dinic 示例：
```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a, b, c) for (int a = (b), a##end = (c); a <= a##end; ++a)
#define FR(a, b, c) for (int a = (b), a##end = (c); a >= a##end; --a)
#define lowbit(x) ((x) & -(x))
#define eb emplace_back
#define int long long
#define vt vector
#define ar(x) array<int, x>
#define PII pair<int, int>
#define max(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7<tmd67v8?tmd67v8:b5k5u7; })
#define cmax(a, b) ({auto tmd67v8=(b);(tmd67v8>a)&&(a=tmd67v8); })
#define min(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7>tmd67v8?tmd67v8:b5k5u7; })
#define cmin(a, b) ({auto tmd67v8=(b);(tmd67v8<a)&&(a=tmd67v8); })
constexpr int N = 5e3 + 10, inf = 1e18;
struct edge{int to, next, w, g;}e[50010 * 2];
int n, h[N], dis[N], vis[N], pre[N], tot = 1;
queue<int> q;
void add(int u, int v, int w, int g) { e[++tot] = {v, h[u], w, g}, h[u] = tot; }
PII Dinic(int s, int t){
	auto spfa = [&](){
		memset(vis, 0, sizeof vis), memset(dis, 0x7f, sizeof dis);
		vis[s] = 1, q.emplace(s), dis[s] = 0;
		while (!q.empty()){
			for (int u = q.front(), i = (q.pop(), pre[u] = h[vis[u] = 0, u]), v; i; i = e[i].next)
				if (e[i].w && dis[u] + e[i].g < dis[v = e[i].to]){
					dis[v] = dis[u] + e[i].g, pre[v] = i;
					if (!vis[v])q.emplace(v), vis[v] = 1;
				}
		}
		return dis[t] < dis[0];
	};
	int ans = 0, cost = 0;
	auto dfs = [&, Dfs = [&](auto &&self, int x, int last) -> int{
		if(x == t)return last;
		vis[x] = 1;
		int res = last, k;
		for(int i = pre[x], v; i && res; i = e[i].next)
			if(e[pre[x] = i].w && dis[v = e[i].to] == dis[x] + e[i].g && !vis[v])
				if(k = self(self, v, min(res, e[i].w)))
					e[i].w -= k, e[i ^ 1].w += k,res -= k, cost += k * e[i].g;
				else dis[v] = 0;
		vis[x] = 0;
		return last - res; 
	}](){ return Dfs(Dfs, s, inf); };
	while (spfa()) ans += dfs();
	return {ans, cost};
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int n, m, s, t, a, b, c, d;
	cin >> n >> m >> s >> t;
	while (m--)
		cin >> a >> b >> c >> d, add(a, b, c, d), add(b, a, 0, -d);
	auto w = Dinic(s, t);
	cout << w.first << " " << w.second << endl;
	return 0;
}
```

---


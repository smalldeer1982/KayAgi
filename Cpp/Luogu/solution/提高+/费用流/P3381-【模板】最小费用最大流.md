# ã€æ¨¡æ¿ã€‘æœ€å°è´¹ç”¨æœ€å¤§æµ

## é¢˜ç›®æè¿°


ç»™å‡ºä¸€ä¸ªåŒ…å« $n$ ä¸ªç‚¹å’Œ $m$ æ¡è¾¹çš„æœ‰å‘å›¾ï¼ˆä¸‹é¢ç§°å…¶ä¸ºç½‘ç»œï¼‰ $G=(V,E)$ï¼Œè¯¥ç½‘ç»œä¸Šæ‰€æœ‰ç‚¹åˆ†åˆ«ç¼–å·ä¸º $1 \sim n$ï¼Œæ‰€æœ‰è¾¹åˆ†åˆ«ç¼–å·ä¸º $1\sim m$ï¼Œå…¶ä¸­è¯¥ç½‘ç»œçš„æºç‚¹ä¸º $s$ï¼Œæ±‡ç‚¹ä¸º $t$ï¼Œç½‘ç»œä¸Šçš„æ¯æ¡è¾¹ $(u,v)$ éƒ½æœ‰ä¸€ä¸ªæµé‡é™åˆ¶ $w(u,v)$ å’Œå•ä½æµé‡çš„è´¹ç”¨ $c(u,v)$ã€‚

ä½ éœ€è¦ç»™æ¯æ¡è¾¹ $(u,v)$ ç¡®å®šä¸€ä¸ªæµé‡ $f(u,v)$ï¼Œè¦æ±‚ï¼š

1.  $0 \leq f(u,v) \leq w(u,v)$ï¼ˆæ¯æ¡è¾¹çš„æµé‡ä¸è¶…è¿‡å…¶æµé‡é™åˆ¶ï¼‰ï¼›
2. $\forall p \in \{V \setminus \{s,t\}\}$ï¼Œ$\sum_{(i,p) \in E}f(i,p)=\sum_{(p,i)\in E}f(p,i)$ï¼ˆé™¤äº†æºç‚¹å’Œæ±‡ç‚¹å¤–ï¼Œå…¶ä»–å„ç‚¹æµå…¥çš„æµé‡å’Œæµå‡ºçš„æµé‡ç›¸ç­‰ï¼‰ï¼›
3. $\sum_{(s,i)\in E}f(s,i)=\sum_{(i,t)\in E}f(i,t)$ï¼ˆæºç‚¹æµå‡ºçš„æµé‡ç­‰äºæ±‡ç‚¹æµå…¥çš„æµé‡ï¼‰ã€‚

å®šä¹‰ç½‘ç»œ $G$ çš„æµé‡ $F(G)=\sum_{(s,i)\in E}f(s,i)$ï¼Œç½‘ç»œ $G$ çš„è´¹ç”¨ $C(G)=\sum_{(i,j)\in E} f(i,j) \times c(i,j)$ã€‚

ä½ éœ€è¦æ±‚å‡ºè¯¥ç½‘ç»œçš„**æœ€å°è´¹ç”¨æœ€å¤§æµ**ï¼Œå³åœ¨ $F(G)$ æœ€å¤§çš„å‰æä¸‹ï¼Œä½¿ $C(G)$ æœ€å°ã€‚

## è¯´æ˜/æç¤º

å¯¹äº $100\%$ çš„æ•°æ®ï¼Œ$1 \leq n \leq 5\times 10^3$ï¼Œ$1 \leq m \leq 5 \times 10^4$ï¼Œ$1 \leq s,t \leq n$ï¼Œ$u_i \neq v_i$ï¼Œ$0 \leq w_i,c_i \leq 10^3$ï¼Œä¸”è¯¥ç½‘ç»œçš„æœ€å¤§æµå’Œæœ€å°è´¹ç”¨ $\leq 2^{31}-1$ã€‚

è¾“å…¥æ•°æ®éšæœºç”Ÿæˆã€‚

## æ ·ä¾‹ #1

### è¾“å…¥

```
4 5 4 3
4 2 30 2
4 3 20 3
2 3 20 1
2 1 30 9
1 3 40 5```

### è¾“å‡º

```
50 280```

# é¢˜è§£

## ä½œè€…ï¼šä¸€å¶çŸ¥ç§‹ã€‚ (èµï¼š27)

å‘äº†ç½‘ç»œæµï¼Œå†æ¥ä¸€å‘è´¹ç”¨æµ

èƒ½åšè´¹ç”¨æµçš„ï¼Œç½‘ç»œæµè‡ªç„¶åšå¾—æ¥ï¼Œä½†åœ¨è¿™è¿˜æ˜¯~~ä¸è¦è„¸çš„~~å®‰åˆ©ä¸€ä¸‹è‡ªå·±çš„åšå®¢ï¼ˆé‡Œé¢ä¹Ÿæœ‰ç½‘ç»œæµçš„é¢˜è§£ï¼‰ï¼š

[ç‚¹æˆ‘](https://www.luogu.org/blog/71403/)

æ‰¯è¿œäº†...

è´¹ç”¨æµï¼Œå°±æ˜¯åœ¨ä¸ç‚¸æ°´ç®¡çš„æƒ…å†µä¸‹æ±‚æºç‚¹åˆ°æ±‡ç‚¹çš„æœ€å°è´¹ç”¨ã€‚

æœ‰æ²¡æœ‰æƒ³èµ·ä»€ä¹ˆï¼Ÿ

æ€è€ƒä¸€ä¸‹......

å¯¹ï¼Œæœ€çŸ­è·¯å¾„ï¼

æ‰€ä»¥æˆ‘ä»¬å®Œå…¨å¯ä»¥ç”¨å·²æ­»çš„SPFAæ±‚å‡ºä¸ç‚¸æ°´ç®¡çš„æœ€çŸ­è·¯å¾„ï¼ˆå½“ç„¶ï¼Œå®åœ¨æœ‰å¿ƒç†é˜´å½±çš„å¯ä»¥ç”¨dijkstraï¼‰ã€‚

å¦‚æœä½ æœ€çŸ­è·¯å¾„éƒ½ä¸ä¼šï¼Œè¿˜æ˜¯å» [è¿™å„¿](https://www.luogu.org/problemnew/show/P3371)
å’Œ [è¿™å„¿](https://www.luogu.org/problemnew/show/P4779)

ç„¶åå†ä¸€æŠŠå¢å¹¿è·¯æ±‚å‡ºæœ€å¤§æµä¸æœ€å°è´¹ç”¨å°±å¥½äº†ï¼ˆæˆ‘è§‰å¾—å¾ˆOKï¼‰

çŒ®ä¸Šæœ¬è’Ÿè’»çš„ä»£ç ï¼š

```cpp
#include<cstdio>
#define maxn 5050
#define maxm 50005
#define INF 0x3f3f3f3f
inline int read(){
	int r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){r=(r<<3)+(r<<1)+c-'0';c=getchar();}
	return r*f;
}
int s,t,n,m,head[maxn],pre[maxn],dis[maxn],q[maxn];
bool vis[maxn];
int s_e;
struct E{
	int v,c,w,nxt;
}e[maxm*2];
struct Max_fei{//æœ¬äººå–œæ¬¢ç»“æ„ä½“
	inline void a_e(int u,int v,int c,int w){
		e[s_e]=(E){v,c,w,head[u]};
		head[u]=s_e++;
	}
	inline void add(int u,int v,int c,int w){
		a_e(u,v,c,w);
		a_e(v,u,0,-w);
	}
	inline bool spfa(){
		for(int i=1;i<=n;i++){
			dis[i]=INF;
			vis[i]=false;
		}
		dis[s]=0;
		vis[s]=true;
		q[0]=s;
		int hd=0,tl=1;
		while(hd^tl){
			int u=q[hd++];//å¾ªç¯é˜Ÿåˆ—
			hd%=maxn;
			for(int i=head[u];i!=-1;i=e[i].nxt){
				int v=e[i].v;
				if(dis[v]>dis[u]+e[i].w&&e[i].c){//åˆ¤æ–­æ°´ç®¡è¿˜èƒ½è¿æ°´å—
					dis[v]=dis[u]+e[i].w;//æ›´æ–°
					pre[v]=i;//è®°å½•ä½ç½®
					if(vis[v])continue;//å¦‚æœåœ¨é˜Ÿé‡Œï¼Œé‚£å°±ä¸è¿›é˜Ÿ
					vis[v]=true;
					q[tl++]=v;
					tl%=maxn;
				}
			}
			vis[u]=false;
		}
		if(dis[t]==INF)return false;
		return true;
	}
	inline int min(int a,int b){//åŸè°…æˆ‘çš„æ‰‹å†™min
		return a<b?a:b;
	}
	inline int end(int &flow){//flowæ±‚æœ€å¤§æµ
		int p,u,Min=1e9,ans=0;
		for(u=t;u!=s;u=e[p^1].v){//å› ä¸ºå¼€å§‹å€¼ä¸º0ï¼Œå¯ä»¥ç”¨xoræ¥æ‰¾åè¾¹
			p=pre[u];//å¾€å‰æ‰¾
			Min=min(Min,e[p].c);//æ‰¾å…¨éƒ¨ç»è¿‡æ°´ç®¡éƒ½èƒ½æµè¿‡çš„æœ€å¤§æµ
            
		}
		for(u=t;u!=s;u=e[p^1].v){
			p=pre[u];
			e[p].c-=Min;
			e[p^1].c+=Min;
			ans+=e[p].w*Min;//åŠ è´¹ç”¨
		}
		flow+=Min;//åŠ æœ€å¤§æµ
		return ans;
	}
	inline int solve(int &flow){
		int ans=0;
		while(spfa()){
			ans+=end(flow);
		}
		return ans;
	}
}Flow;
inline void work(){
	n=read();m=read();
	s=read();t=read();
	for(int i=1;i<=n;i++)head[i]=-1;//åˆå§‹å€¼ä¸º-1ï¼Œæ–¹ä¾¿xor
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),c=read(),w=read();
		Flow.add(u,v,c,w);
	}
	int flow=0;
	int ans=Flow.solve(flow);
	printf("%d %d\n",flow,ans);
}
int main(){
	work();
	return 0;
}
```
åˆ°æ­¤ç»“æŸ~~ï¼ˆå·å·æ’’èŠ±ï¼‰~~

---

## ä½œè€…ï¼šBitByBit (èµï¼š15)

æœ€å°è´¹ç”¨æœ€å¤§æµå°±æ˜¯åœ¨æœ€å¤§æµçš„åŸºç¡€ä¸Šï¼Œæ¯æ¡è¾¹è¿˜æœ‰å•ä½æµé‡è´¹ç”¨ï¼Œæµç»ä¸€æ¡è¾¹çš„è´¹ç”¨å°±æ˜¯æµé‡ä¹˜é‚£æ¡è¾¹çš„å•ä½è´¹ç”¨ï¼Œæ±‚åœ¨æœ€å¤§æµçš„å‰æä¸‹æ€»è´¹ç”¨æœ€å°ã€‚è¿™é‡Œä½¿ç”¨ä¸€ç§ SSPï¼ˆSuccessive Shortest Pathï¼‰ç®—æ³•ï¼Œå°±æ˜¯è´ªå¿ƒæ‰¾å•ä½è´¹ç”¨æœ€å°çš„å¢å¹¿è·¯è¿›è¡Œå¢å¹¿ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ SSP åªèƒ½åœ¨æ²¡æœ‰è´Ÿç¯çš„å›¾ä¸Šä½¿ç”¨ã€‚å…·ä½“å®ç°å°±æ˜¯æŠŠ Edmonds-Karp æˆ– Dinic çš„ BFS æ‰¾å¢å¹¿è·¯æ¢æˆæœ€çŸ­è·¯æ‰¾å•ä½è´¹ç”¨æœ€å°çš„å¢å¹¿è·¯ã€‚ä½¿ç”¨ SPFA æ±‚æœ€çŸ­è·¯çš„ SSP æ—¶é—´å¤æ‚åº¦ä¸º $\Theta(nmf)$ï¼Œå…¶ä¸­ $f$ ä¸ºæœ€å¤§æµã€‚åŸºäº Dinic çš„å®ç°ï¼š
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define infll 0x3f3f3f3f3f3f3f3f
#define N 5010
#define M 100010
int n,m,s,t,tot=1;
ll maxflow,mincost;
int Head[N],Son[M],Next[M];
ll Cap[M],Cost[M];
deque<int>Q;
int Cur[N];
ll Dis[N];
bool Vis[N];
inline void add(int x,int y,int a,int b)
{
	Son[++tot]=y;
	Cap[tot]=a;
	Cost[tot]=b;
	Next[tot]=Head[x];
	Head[x]=tot;
}
bool spfa()//spfaæ±‚æœ€çŸ­è·¯
{
	memset(Dis,0x3f,sizeof(Dis));
	memset(Vis,0,sizeof(Vis));
	memcpy(Cur,Head,sizeof(Cur));
	Q.clear();
	Q.push_back(s);
	Dis[s]=0;
	Vis[s]=1;
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop_front();
		Vis[x]=0;
		for(int i=Head[x];i;i=Next[i])
		{
			int y=Son[i];
			if(Cap[i]&&Dis[y]>Dis[x]+Cost[i])
			{
				Dis[y]=Dis[x]+Cost[i];
				if(!Vis[y])
				{
					Q.push_back(y);
					Vis[y]=1;
				}
			}
		}
	}
	return Dis[t]^infll;
}
ll dfs(int x,ll flow)//dfså¢å¹¿
{
	if(x==t)return flow;
	Vis[x]=1;
	ll res=0;
	for(int i=Cur[x];i&&flow;i=Next[i])
	{
		int y=Son[i];
		Cur[x]=i;
		if(!Vis[y]&&Cap[i]&&Dis[y]==Dis[x]+Cost[i])
		{
			ll k=dfs(y,min(flow,Cap[i]));
			if(!k)Dis[y]=infll;
			Cap[i]-=k;
			Cap[i^1]+=k;
			res+=k;
			flow-=k;
			mincost+=k*Cost[i];//ç›´æ¥åœ¨è¿™é‡Œè®°å½•è´¹ç”¨
		}
	}
	Vis[x]=0;
	return res;
}
void Dinic(void)//Dinicç®—æ³•
{
	while(spfa())maxflow+=dfs(s,infll);
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++)
	{
		int x,y,a,b;
		cin>>x>>y>>a>>b;
		add(x,y,a,b);
		add(y,x,0,-b);
//è¿™é‡Œåå‘è¾¹çš„å®¹é‡ä¸º0ï¼Œè´¹ç”¨æ˜¯è´Ÿçš„ã€‚
	}
	Dinic();
	cout<<maxflow<<' '<<mincost;
	return 0;
}
```

---

## ä½œè€…ï¼šæµæ°´è¡Œèˆ¹CCD (èµï¼š8)

ä¸ºä»€ä¹ˆç°æœ‰çš„é¢˜è§£å…¨æ˜¯ SSP å•Šï¼Ÿ

## SSP è¿ç»­æœ€çŸ­è·¯

å…¶ä»–é¢˜è§£è®²çš„æ¯”è¾ƒæ¸…æ¥šï¼Œè¿™é‡Œåªæä¸€ä¸‹æ€æƒ³ï¼šå¯»æ‰¾å¢å¹¿è·¯çš„æ—¶å€™ç”¨è´¹ç”¨æœ€å°çš„å¢å¹¿è·¯å»å¢å¹¿å³å¯ï¼Œæ³¨æ„ç”±äºåå‘è¾¹è´¹ç”¨ä¸ºè´Ÿï¼Œåœ¨åŸå›¾æ— è´Ÿåœˆæ—¶åªèƒ½ä½¿ç”¨ Bellman-Ford å’Œ SPFA æ±‚è§£æœ€çŸ­è·¯ï¼Œåœ¨åŸå›¾æœ‰è´Ÿåœˆæ—¶éœ€ä½¿ç”¨æ¶ˆåœˆç®—æ³•ã€‚

è¯¥ç®—æ³•ç”±äºå¯»æ‰¾çš„ä¸å†æ˜¯ç»è¿‡è¾¹æ•°æœ€å°çš„å¢å¹¿è·¯ï¼Œä¸èƒ½è¯´æ˜æ¯æ¡å…³é”®è¾¹è¢«å¢å¹¿ä¸€æ¬¡æœ€çŸ­è·¯é•¿åº¦å¢åŠ ï¼Œä¹Ÿå°±æ— æ³•æ¯æ¡è¾¹è‡³å¤šæˆä¸º $\mathcal{O}(|V|)$ æ¬¡å…³é”®è¾¹ï¼Œæ‰€ä»¥æ˜¯ FF çš„å¤æ‚åº¦ä¸Šç•Œ $\mathcal{O}(nm|f|)$ï¼Œå·²ç»è¢« Min_25 å¡æˆ $\mathcal{O}(n^32^{n/2})$ äº†ã€‚

### Code

ä»£ç æ–¹ä¾¿ï¼Œä½†æ˜¯è‚‰çœ¼å¯è§çš„æ…¢ï¼Œè·‘äº† 1500msã€‚

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ld cin
#define jyt cout
#define int long long
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
const int N = 1e5 + 7;
const int inf = 1e9 + 7;
const ll linf = 1e18 + 7;
const int P = 998244353;
namespace JoKing {
	int n, m, S, T, Q[N], vis[N], Dfs_vis[N], dis[N], now[N], Ans1 = 0, Ans2 = 0;
	struct Node {int to, nxt, w, cost;} e[N << 1]; int h[N], ec = 1;
	inline void AddEdge(int u, int v, int w, int cost) {e[++ec].to = v, e[ec].nxt = h[u], e[ec].w = w, e[ec].cost = cost, h[u] = ec;}
	inline void SpanEdge(int u, int v, int w, int cost) {AddEdge(u, v, w, cost), AddEdge(v, u, 0, -cost);}
#define nxt(x) (x = (x + 1 > n ? 1 : x + 1))
#define FR(x) for (int i = x, v = e[i].to, w = e[i].w, cost = e[i].cost; i; i = e[i].nxt, v = e[i].to, w = e[i].w, cost = e[i].cost)
	inline bool Spfa() { int head = 1, tail = 1, sz = 1; REP(i, 1, n) now[i] = h[i], dis[i] = linf, Dfs_vis[i] = 0; dis[Q[head] = S] = 0;
		for (int x = Q[head]; sz; x = Q[nxt(head)], --sz, vis[x] = 0) 
			FR(h[x]) if (w && dis[v] > dis[x] + cost) dis[v] = dis[x] + cost, (!vis[v] && (Q[nxt(tail)] = v, ++sz, vis[v] = 1));
		return dis[T] != linf;
	}
	inline int Dfs(int x, int flow) {
		if (x == T) return Ans1 += flow, flow; int used = 0, flowing_boat = 0; Dfs_vis[x] = 1;
		FR(now[x]) if ((now[x] = i) && !Dfs_vis[v] && w && dis[v] == dis[x] + cost && (flowing_boat = Dfs(v, min(w, flow - used)), Ans2 += cost * flowing_boat, e[i].w -= flowing_boat, e[i ^ 1].w += flowing_boat, (!flowing_boat && (dis[v] = linf)), used += flowing_boat) == flow) return used; 
		return used;
	}
	signed main() { int u, v, w, cost;
		ld >> n >> m >> S >> T;
		REP(i, 1, m) ld >> u >> v >> w >> cost, SpanEdge(u, v, w, cost);
		while (Spfa()) Dfs(S, linf);
		jyt << Ans1 << ' ' << Ans2 << '\n';
		return 0;
	}
}
signed main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	JoKing::main(); return 0;
}
```

## KM é‡æ ‡å· & zkw è´¹ç”¨æµ

æ ¸å¿ƒï¼šSPFA å¾ˆæ…¢ï¼Œæ‰€ä»¥æ‰‹åŠ¨æ¨¡æ‹Ÿæœ€çŸ­è·¯ã€‚

æ¯å¢å¹¿ä¸€æ¬¡éœ€è¦è·‘ä¸€é SPFA çš„åŸå› æ˜¯å¢å¹¿åå…³é”®è¾¹ä¼šæ¶ˆå¤±ï¼Œæœ‰åå‘è¾¹ä¼šåŠ å…¥ï¼Œå¯¼è‡´è·ç¦»æ•°ç»„å˜åŒ–ï¼Œè€ƒè™‘åˆ©ç”¨æ ‡å·å¿«é€Ÿç»´æŠ¤è·ç¦»æ•°ç»„ã€‚

æœ€å¼€å§‹ï¼Œå°†æ¯ä¸ªç‚¹çš„æ ‡å· $d$ å…¨éƒ¨ç½®ä¸º $0$ã€‚æˆ‘ä»¬ç§°æ»¡è¶³ $d_v = d_u + w(u,v)$ çš„è¾¹ä¸ºå¯è¡Œè¾¹ï¼Œå¯ä»¥ç”± $S$ åªç»è¿‡å¯è¡Œè¾¹åˆ°è¾¾çš„ç‚¹æ„æˆçš„è¿é€šå—ç§°ä½œå¯è¡Œè¿é€šå—ï¼Œæ­¤æ—¶ï¼Œæ±‚å‡ºæ‰€æœ‰ä¸€æ®µä½äºå¯è¡Œè¿é€šå—ï¼Œå¦ä¸€ç«¯ä¸ä½äºå¯è¡Œè”é€šå—çš„è¾¹ $(u,v)$ ä¸­ $\delta w = d_u + w(u,v) - d_v$ æœ€å°çš„è¾¹ã€‚

è‹¥ $S,T$ å‡åœ¨å¯è¡Œè¿é€šå—ä¸­ï¼Œä½¿ç”¨å¯è¡Œè¾¹è¿›è¡Œå¢å¹¿ï¼Œåä¹‹è¯´æ˜æœ‰äº›ç‚¹çš„æ ‡å· $d_v$ è¿‡å°ï¼Œéœ€è¦å¢åŠ ï¼Œè€Œæˆ‘ä»¬è‚¯å®šè´ªå¿ƒçš„æƒ³ä½¿å¾—å¢åŠ çš„æƒå€¼æœ€å°ã€‚é‚£ç©¶ç«Ÿéœ€è¦å¢åŠ å¤šå°‘å‘¢ï¼Ÿå‘ç°ä¸€æ¡è¾¹ $(u,v)$ æƒ³æˆä¸ºå¯è¡Œè¾¹ï¼Œéœ€è¦æ»¡è¶³ $d_u + w(u,v) = d'_v$ï¼Œé‚£ä¹ˆæ­¤æ—¶æƒå€¼å˜åŒ–é‡ä¸º $d'_v-d_v=d_u+w(u,v)-d_v$ï¼Œæ­£æ˜¯æˆ‘ä»¬ä¸Šé¢æ‰€ç»´æŠ¤çš„ $\delta w$ï¼Œæ­¤æ—¶ä¿®æ”¹ $\delta w$ æœ€å°çš„è¾¹çš„ $d_v$ çš„å€¼ï¼Œé‡æ–°å°è¯•å¢å¹¿ã€‚è‹¥æ²¡æœ‰ç»“ç‚¹å¯ä»¥æ‰©å±•å¯è¡Œè¾¹ä¸”æ— å¢å¹¿è·¯ï¼Œç®—æ³•ç»ˆæ­¢ã€‚

è¯¥ç®—æ³•åœ¨å¢å¹¿è·¯è¾ƒçŸ­çš„æ—¶å€™æ¯” SSP å¸¸æ•°æ›´ä¸ºä¼˜ç§€ã€‚

å¾ˆä¸å¹¸çš„æ˜¯ï¼Œè¿™ä¸ªåŸºäº SSP çš„è´¹ç”¨æµä¹Ÿè¢« Min_25 å¡æˆæŒ‡æ•°å¤æ‚åº¦äº†ã€‚

### Code

ç”±äºå®ƒå¹³æ—¶å®é™…è¡¨ç°ä»…æ¯” SSP ç•¥å¥½ï¼ˆé™¤éç‰¹æ„å¡ SSP çš„é¢˜ï¼‰ï¼Œæ‰€ä»¥æ²¡æœ‰ä»£ç å®ç°ã€‚

## Primal-Dual åŸå§‹~~äºº~~å¯¹å¶ç®—æ³•

æ ¸å¿ƒï¼šSPFA å¤ªæ…¢ï¼Œæ‰€ä»¥ Dijkstraã€‚

ä½ å¯èƒ½ä¼šé—®ï¼šè´Ÿæƒå›¾æ€ä¹ˆ Dijkstraï¼Ÿç±»ä¼¼å¤šå…ƒæœ€çŸ­è·¯ï¼Œè€ƒè™‘æ·»åŠ åç§»é‡ä½¿è¾¹æƒéè´Ÿã€‚

SPFA è·‘ä¸€éæ±‚å‡ºè·ç¦»æ•°ç»„ $d$ï¼Œè®¾ç½®åˆå§‹åŠ¿èƒ½ $h_i=d_i$ã€‚æ­¤æ—¶ï¼Œè®¾æ–°æƒå€¼ $w'(u,v) = w(u,v)+h_u-h_v$ã€‚

ä¸ºä»€ä¹ˆè¿™ä¹ˆè®¾ï¼Ÿå› ä¸ºæ ¹æ®æœ€çŸ­è·¯æ€§è´¨ $d_u+w(u,v) \ge d_v$ï¼Œæ‰€ä»¥ $w'(u,v)=w(u,v)+d_u-d_v \ge w(u,v)+d_u-(d_u+w(u,v))=0$ï¼Œæ­¤æ—¶æ–°è¾¹æƒéè´Ÿï¼Œè€Œä¸”åŸå›¾å…³é”®è¾¹çš„æ–°è¾¹æƒä¸º $0$ï¼Œä»å¯ä»¥æ­£ç¡®çš„æ‰¾åˆ°å¢å¹¿è·¯ï¼æ­¤æ—¶ï¼Œä½¿ç”¨ Dijkstra æ±‚å‡ºæ–°è¾¹æƒä¸Šæœ€çŸ­è·¯è·ç¦»æ•°ç»„ $d'_u=d_u+h_S-h_u$ï¼Œç”±äº $h_S=0$ï¼Œä¸éš¾å¾—åˆ° $d_u=d'_u+h_u$ã€‚

ç°åœ¨è€ƒè™‘å¢å¹¿ä¸€æ¬¡åï¼Œå…³é”®è¾¹ $(u,v)$ æµé‡å˜ä¸º $0$ï¼Œè¢«åˆ é™¤ï¼ŒåŠ å…¥åå‘è¾¹ $(v,u)$ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜åœ¨è¿™ä¹‹åè¾¹æƒä»éè´Ÿã€‚

å› ä¸º $(u,v)$ åœ¨æœ€çŸ­è·¯ä¸Šï¼Œæ‰€ä»¥ $d'_u + w'(u,v) = d'_u + (w(u,v)+h_u-h_v)=d'_v$ï¼Œé‚£ä¹ˆæœ‰ï¼š

$$
\begin{aligned}
&w(v,u) = -w(u,v) = d'_u+h_u-(d'_v+h_v) \\
&w(v,u)+(d'_v+h_v)-(d'_u+h_u) = 0 \ge 0
\end{aligned}
$$

æ‰€ä»¥ä»¤ $h'_u=h_u+d'_v$ å³å¯ï¼Œå¯ä»¥è¯å¾—æ­¤æ—¶ $(u,v)$ çš„æ–°è¾¹æƒä»éè´Ÿï¼Œæ‰€ä»¥æœ¬ç®—æ³•æ‹¥æœ‰æ­£ç¡®æ€§ã€‚æ­¤æ—¶ç”¨ Dijkstra æ±‚å‡ºæ–°åŠ¿èƒ½ä¸‹æœ€çŸ­è·¯ï¼Œå¦‚æ­¤å¾€å¤æ‰©æµç›´è‡³æ— æ³•æ‰©æµã€‚

$\mathcal{O}(|f|m\log m)$ï¼Œè¾ƒä¸ºå¿«é€Ÿã€‚

### Code

ä»£ç å¸¸æ•°å¤ªå¤§ï¼Œç›¸æ¯” SSP è¿˜æ˜¯å¿«äº† $3$ å€ï¼Œéœ€è¦ 500msã€‚

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fast_IO{ // çœç•¥å¿«è¯»å¿«å†™
...
} using namespace fast_IO;
#define ll long long
#define ull unsigned long long
#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
const int N = 5e3 + 7;
const int M = 1e5 + 7; // åå‘è¾¹ åŒå€ç©ºé—´
const int inf = 1.05e9 + 7;
const ll linf = 1e18 + 7;
const int P = 998244353;
namespace MCMF { // Min-cost-Max-flow
    int n, m, S, T, d[N], p[N], h[N]; bool inq[N], vis[N];
    struct Edge {int u, v, nxt, w, cost;} e[M]; int head[N], ec = 1; // è¾¹ç¼–å·ä» 2 å¼€å§‹ æ–¹ä¾¿å¯»æ‰¾åå‘è¾¹
    inline void AddEdge(int u, int v, int w, int cost) {e[++ec] = (Edge) {u, v, head[u], w, cost}, head[u] = ec;}
    inline void Span(int u, int v, int w, int cost) {AddEdge(u, v, w, cost), AddEdge(v, u, 0, -cost);}
    inline bool SPFA() {
        static queue<int> Q; 
        REP(i, 1, n) inq[i] = false, d[i] = inf;
        Q.emplace(S), inq[S] = true, d[S] = 0;
        while (!Q.empty()) {
            int x = Q.front(); Q.pop(), inq[x] = false;
            for (int i = head[x], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
                if (e[i].w && d[v] > d[x] + e[i].cost) {
                    d[v] = d[x] + e[i].cost;
                    if (!inq[v]) Q.emplace(v), inq[v] = true;
                }
        }
        return d[T] != inf;
    }
    struct Node {int x, dis; inline bool operator < (const Node &p) const {return dis > p.dis;}};
    inline pair<int, int> solve() {
        if (!SPFA()) return {0, 0};
        static priority_queue<Node> Q;
        REP(i, 1, n) h[i] = d[i], vis[i] = false, d[i] = inf; // åˆå§‹åŠ¿èƒ½
        int Flow = 0, Cost = 0;
        while (true) {
            Q.emplace((Node) {S, d[S] = 0});
            while (!Q.empty()) { // æ‰§è¡Œ Dijkstra.
                int x = Q.top().x; Q.pop();
                if (vis[x]) continue; else vis[x] = true;
                for (int i = head[x], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
                    if (e[i].w && d[v] > d[x] + e[i].cost + h[x] - h[v]) d[v] = d[x] + e[i].cost + h[x] - h[v], p[v] = i, Q.emplace((Node) {v, d[v]});
            }
            if (d[T] == inf) break;
            int flowing_boat = inf, costing_boat = 0; // å½“å‰å¢å¹¿è·¯æµæµé‡,å½“å‰å¢å¹¿è·¯æµå•ä½è´¹ç”¨
            for (int x = T; x != S; x = e[p[x]].u) flowing_boat = min(flowing_boat, e[p[x]].w), costing_boat += e[p[x]].cost;
            Flow += flowing_boat, Cost += flowing_boat * costing_boat;
            for (int x = T; x != S; x = e[p[x]].u) e[p[x]].w -= flowing_boat, e[p[x] ^ 1].w += flowing_boat;
            REP(i, 1, n) h[i] += d[i], vis[i] = false, d[i] = inf; // æ›´æ–°åŠ¿èƒ½
        }
        return {Flow, Cost};
    }
} using namespace MCMF;
namespace JoKing {

    signed main() { int u, v, w, c;
        ld >> n >> m >> S >> T;
        REP(i, 1, m) ld >> u >> v >> w >> c, Span(u, v, w, c);
        pair<int, int> Ans = solve();
        return jyt << Ans.first << ' ' << Ans.second << '\n', 0; 
    }
}
signed main() {
#ifndef WYY 
    // freopen("mcmf.in", "r", stdin);
    // freopen("mcmf.out", "w", stdout);
#endif
    JoKing::main(); return 0;
}
```

## å‚è€ƒèµ„æ–™

- [OI-WIKI è´¹ç”¨æµ](https://oi-wiki.org/graph/flow/min-cost/)ã€‚
- [Manjusakaä¸¶æ¢¦å¯’ ç½‘ç»œæµå­¦ä¹ --è´¹ç”¨æµ](https://www.cnblogs.com/rmy020718/p/9548758.html)ã€‚
- [Min_25 æœ€å°è²»ç”¨æœ€å¤§æµã®æ‚ªä¾‹é¡Œ](https://web.archive.org/web/20211009144446/https://min-25.hatenablog.com/entry/2018/03/19/235802)ã€‚

---

## ä½œè€…ï¼šliushuangning (èµï¼š7)

upd on 2025.5.10ï¼šä¿®æ­£è¯æ˜ã€‚æ„Ÿè°¢ [shihaojiacaigitcl](https://www.luogu.com.cn/user/613955) æŒ‡å‡ºçš„é”™è¯¯ï¼

upd on 2025.6.9ï¼šä¼˜åŒ–ã€‚

## æ€è·¯

ç›´æ¥å°† EK ç®—æ³•ä¸­çš„ BFS å‡½æ•°æ¢æˆ SPFA å³å¯ã€‚

åœ¨æ®‹ç•™ç½‘ç»œä¸­ï¼Œå¦‚æœæ­£å‘è¾¹çš„è¾¹æƒä¸º $w(u,v)$ï¼Œé‚£ä¹ˆåå‘è¾¹çš„è¾¹æƒ $w(v,u)$ å®šä¹‰ä¸º $-w(u,v)$ï¼Œå› ä¸ºå¦‚æœè¦é€€æµï¼Œå°±è¦æŠŠè´¹ç”¨ä¹Ÿé€€å›å»ã€‚

## è¯æ˜

æ­£ç¡®æ€§è¯æ˜ï¼š

è®¾ $c(p)$ ä¸ºè·¯å¾„ $p$ çš„é•¿åº¦ï¼Œåé¢ä¸ºäº†åŒºåˆ†å•ä½è´¹ç”¨å’Œè´¹ç”¨ï¼Œå°†å•ä½è´¹ç”¨ç§°ä¸ºè¾¹æƒã€‚

å‡è®¾å¯è¡Œæµ $f$ æ˜¯ä¸€ä¸ªæœ€å°è´¹ç”¨æµï¼Œæµé‡ä¸º $v$ï¼Œä¸”æ®‹ç•™ç½‘ç»œ $G_f$ ä¸­æ— è´Ÿç¯ï¼Œç°åœ¨æŒ‰æœ€çŸ­è·¯å¾„ $p$ å¢å¹¿ï¼Œå¾—åˆ°æ–°æµ $f'$ï¼Œæµé‡ä¸º $v+\delta$ï¼Œåˆ™ $\operatorname{cost}(f'-f)=c(p)\delta$ã€‚å‡è®¾å­˜åœ¨ä¸€ä¸ªå¯è¡Œæµ $f_n$ï¼Œä½¿å¾— $|f_n|=v+\delta$ï¼Œä¸” $f_n$ çš„è´¹ç”¨å°äº $f'$ çš„è´¹ç”¨ï¼Œè€ƒè™‘æµå·® $f_n-f$ï¼Œå› ä¸ºæµçš„åˆ†è§£å®šç†ï¼Œ$f_n-f$ å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä»æºåˆ°æ±‡çš„è·¯å¾„å’Œè‹¥å¹²ç¯ï¼š

- è·¯å¾„ï¼š**è‡³å°‘å­˜åœ¨ä¸€æ¡è·¯å¾„ $p'$ï¼Œä½¿å¾— $p'$ çš„é•¿åº¦å°äº $p$ çš„é•¿åº¦ï¼Œå¦åˆ™ $f_n$ çš„è´¹ç”¨ä¸å¯èƒ½å°äº $f$ çš„è´¹ç”¨ã€‚**

- ç¯ï¼šç”±äº $G_f$ ä¸­ä¸å­˜åœ¨è´Ÿç¯ï¼Œæ‰€ä»¥ç¯è´¡çŒ®çš„é•¿åº¦å’Œè´¹ç”¨ä¸€å®šéè´Ÿï¼Œä¸ºäº†é™ä½è´¹ç”¨ï¼Œä¸€å®šä¸é€‰ç¯ã€‚

å› ä¸º $p$ ä¸ºæœ€çŸ­è·¯å¾„ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ $p'$ çš„é•¿åº¦å°äº $p$ çš„é•¿åº¦ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ $p'$ï¼Œé‚£ä¹ˆ $f'$ å°±æ˜¯æœ€ä¼˜è§£ã€‚

ç°åœ¨è¯æ˜åŠ é»‘éƒ¨åˆ†ï¼š

è®¾ $f_n-f$ åˆ†è§£å‡ºæ¥çš„è·¯å¾„åˆ†åˆ«ä¸º $p_1,p_2,...,p_k$ï¼Œæ¯æ¡è·¯å¾„ $p_i$ æºå¸¦ $\delta_i$ çš„æµé‡ï¼Œä½¿å¾— $\sum \delta_i=\delta$ï¼Œåˆ™ï¼š

$$
\operatorname{cost}(f_n-f)=\sum_{i=1}^k c(p_i)\delta_i
$$

å› ä¸º $c(p_i)\ge c(p)$ï¼Œæ‰€ä»¥è·¯å¾„éƒ¨åˆ†çš„æ€»è´¹ç”¨æ»¡è¶³ï¼š

$$
\sum_{i=1}^k c(p_i)\delta_i\ge \sum_{i=1}^k c(p)\delta_i=c(p)\sum_{i=1}^k \delta_i=c(p)\delta
$$

æ‰€ä»¥ï¼š

$$
\operatorname{cost}(f_n-f)\ge c(p)\delta
$$

è¿™å°±ä¸ $f_n$ çš„è´¹ç”¨æ¯” $f'$ çš„è´¹ç”¨å°è€ŒçŸ›ç›¾ï¼Œæ‰€ä»¥è¿™æ ·åšæ˜¯æ­£ç¡®çš„ã€‚

è¿™æ—¶å€™æœ‰äº›èªæ˜çš„åŒå­¦å°±å‘ç°äº†ï¼šå¦‚æœä¸€æ¡è¾¹å·²ç»æµäº†ä¸€äº›æµé‡åï¼Œé‚£ä¹ˆåå‘è¾¹çš„è¾¹æƒå°±ä¼šå˜æˆè´Ÿæ•°ï¼Œé‚£ä¹ˆå¦‚ä½•ä¿è¯ä¸ä¼šå‡ºç°è´Ÿç¯å‘¢ï¼Ÿ

å®šä¹‰ $d_u$ è¡¨ç¤º $u$ ç‚¹çš„æœ€çŸ­è·¯å¾„å€¼ï¼Œå³ä»£ç ä¸­çš„ `d[u]`ã€‚æˆ‘ä»¬å‡è®¾ç¬¬ $k$ æ­¥åæ²¡æœ‰å‡ºç°è´Ÿç¯ï¼Œä½†æ˜¯ç¬¬ $k+1$ æ­¥åå‡ºç°äº†è´Ÿç¯ $C$ï¼Œåˆ™ $C$ ä¸­è‡³å°‘åŒ…å«ä¸€æ¡æ–°å¢çš„åå‘è¾¹ $v\to u$ï¼Œåå‘è¾¹çš„è´¹ç”¨ä¸º $-c(u,v)$ã€‚å‡è®¾ç¯ $C$ çš„è¾¹æƒä¹‹å’Œä¸ºå…¶ä»–è¾¹çš„è´¹ç”¨ä¹‹å’Œ $sum$ åŠ ä¸Šè¿™æ¡è¾¹çš„ $-c(u,v)$ï¼Œåˆ™ $sum-c(u,v)<0$ï¼Œå³ $sum<c(u,v)$ã€‚

å› ä¸ºæˆ‘ä»¬æ˜¯æŒ‰ç…§æœ€çŸ­è·¯å¾„å¢å¹¿çš„ï¼Œæ‰€ä»¥ $d_v=d_u+c(u,v)$ï¼ˆæ ¹æ®æœ€çŸ­è·¯å¾„çš„æ€§è´¨ï¼‰ï¼Œåˆ™ $d_v-d_u=c(u,v)$ï¼Œåˆ™ $sum\ge c(u,v)$ï¼ˆå› ä¸º $d_v-d_u$ æ˜¯æŒ‰ç…§æœ€çŸ­è·¯å¾„æ±‚å‡ºæ¥çš„ï¼Œä¸å¯èƒ½å­˜åœ¨æ›´çŸ­çš„æ›¿ä»£è·¯å¾„ï¼‰ï¼Œä¸å‡è®¾çŸ›ç›¾ï¼Œæ‰€ä»¥ä¸å¯èƒ½å­˜åœ¨è´Ÿç¯ã€‚

## æ—¶é—´å¤æ‚åº¦

æœ€åæƒ…å†µä¸‹ï¼Œæ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(nmf)$ï¼Œå…¶ä¸­ $f$ ä¸ºæœ€å¤§æµã€‚å› ä¸ºæ¯æ¬¡å¢å¹¿å¢åŠ çš„æµé‡ $\Delta f>0$ï¼Œæ‰€ä»¥æœ€å¤šå¢å¹¿ $f$ æ¬¡ã€‚æ¯æ¬¡å¢å¹¿éƒ½éœ€è¦ä¸€é SPFAï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦æœ€åä¸º $O(nmf)$ã€‚

---

å‚è€ƒä»£ç ï¼š

```cpp
#include<bits/stdc++.h>
#define mems(a,b) memset(a,b,sizeof a)
using namespace std;
const int N=5010,M=100010,inf=0x3f3f3f3f;
int n,m,S,T;
int h[N],e[M],ne[M],f[M],w[M],idx;
int q[N],d[N],pre[N],incf[N];//dè¡¨ç¤ºä»æºç‚¹åˆ°æ¯ä¸ªç‚¹çš„é•¿åº¦ï¼Œincfè¡¨ç¤ºèµ°åˆ°æ¯ä¸ªç‚¹æ—¶çš„æœ€å¤§æµé‡
bool st[N];
void add(int a,int b,int c,int d){
	e[idx]=b;
	f[idx]=c;
	w[idx]=d;
	ne[idx]=h[a];
	h[a]=idx++;
	e[idx]=a;
	f[idx]=0;
	w[idx]=-d;
	ne[idx]=h[b];
	h[b]=idx++;
}
bool spfa(){
	int hh=0,tt=1;
	mems(d,0x3f);
	mems(incf,0);
	q[0]=S;
	d[S]=0;
	incf[S]=inf;//æºç‚¹çš„æµé‡æ— é™åˆ¶
	while(hh!=tt){
		int t=q[hh++];//å‡ºé˜Ÿ
		if(hh==N) hh=0;//å¾ªç¯é˜Ÿåˆ—
		st[t]=false;//ä¸€ä¸ªç‚¹å¯ä»¥å¤šæ¬¡å…¥é˜Ÿ
		for(int i=h[t];~i;i=ne[i]){
			int ver=e[i];
			if(f[i]>0 && d[ver]>d[t]+w[i]){
				d[ver]=d[t]+w[i];//æ±‚æœ€çŸ­è·¯
				pre[ver]=i;//åˆ°verçš„è¾¹æ˜¯iè¿™æ¡è¾¹
				incf[ver]=min(f[i],incf[t]);
				if(!st[ver]){
					q[tt++]=ver;//å…¥é˜Ÿ
					if(tt==N) tt=0;
					st[ver]=true;
				}
			}
		}
	}
	return (incf[T]>0);//åˆ¤æ–­æ±‡ç‚¹çš„æµé‡æ˜¯å¦å¤§äº0ï¼Œç­‰ä»·äºåˆ¤æ–­èƒ½ä¸èƒ½åˆ°æ±‡ç‚¹
}
void EK(int &flow,int &cost){//ä¼ å¼•ç”¨
	flow=cost=0;
	while(spfa()){
		int t=incf[T];//æµé‡
		flow+=t;
		cost+=t*d[T];
		for(int i=T;i!=S;i=e[pre[i]^1]){//åå‘è¾¹çš„ç»ˆç‚¹å°±æ˜¯æ­£å‘è¾¹çš„èµ·ç‚¹
			f[pre[i]]-=t;
			f[pre[i]^1]+=t;
		}
	}
}
int main(){
	cin>>n>>m>>S>>T;
	mems(h,-1);
	while(m--){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		add(a,b,c,d);
	}
	int flow,cost;
	EK(flow,cost);
	cout<<flow<<" "<<cost;
	return 0;
}
```

---

## ä½œè€…ï¼šfengzhaoyu (èµï¼š7)

~~åŸå§‹å¯¹å¶ç®—æ³•æ˜¯ä¸ªå¥½ä¸œè¥¿~~
## æ€è·¯
å‰ç½®èŠå£«ï¼š[dinic-ç®—æ³•](https://oi-wiki.org/graph/flow/max-flow/#dinic-ç®—æ³•)ã€‚

çœ‹çœ‹é¢˜è§£æ²¡æœ‰ dijkstra åŠ  dinic çš„ï¼Œè¿™é‡Œæ¥å†™ä¸€ä¸‹ã€‚

é¦–å…ˆè¦çŸ¥é“ï¼Œç½‘ç»œæµå°±æ˜¯å¯¹äºä¸€æ¡ $u\rightarrow v$ çš„è·¯å¾„åå‘å†å»ºæƒå€¼ä¸º 0 çš„è·¯å¾„ï¼Œå¦‚æœè¿™æ¡è·¯ç»è¿‡äº† $x$ çš„æµé‡ï¼Œé‚£ä¹ˆä»–çš„åè¾¹å°±ä¼šå¢åŠ  $x$ çš„æƒå€¼ï¼Œä»¥ä¾¿ä»¥åå¯ä»¥â€œåæ‚”â€ã€‚æœ€å°è´¹ç”¨æœ€å¤§æµæ˜¯è´ªå¿ƒåœ°æ¯æ¬¡æŒ‰ä»·æ ¼çš„æœ€çŸ­è·¯è¿›è¡Œå¢å¹¿ï¼Œé‚£å¾ˆå®¹æ˜“æƒ³åˆ°åŠ ä¸€ä¸ª spfaï¼Œæ¯æ¬¡éƒ½æ‰¾ä¸€æ¡ $s\rightarrow t$ çš„æœ€çŸ­è·¯è¿›è¡Œå¢å¹¿ï¼Œç›´åˆ°ä¸å­˜åœ¨è¿™æ ·çš„è·¯å¾„ä¸ºæ­¢ã€‚å¯ä»¥è¯æ˜ï¼Œæ­¤æ—¶çš„è·¯å¾„ä¸€å®šæœ€ä¼˜ï¼ˆè’Ÿè’»å¤ªè’Ÿè’»äº†ï¼Œä¸ä¼šè¯ï¼Œæœ‰æ„æ„¿è€…å¯ä»¥ä¸Šç½‘æŸ¥è¯æ˜æ–¹æ³•ï¼‰ï¼Œè¯¦è§ä»£ç ã€‚

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
const int N=5e4+15,M=5e5+15,inf=INT_MAX;
int read()
{
	int t=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') t=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return t*x;
}
int cur[N],to[M],ne[M],f[M],w[M],d[N],vis[N];
int dis[N],hh[N];
int n,m,s,t,idx;
void add(int u,int v,int ww,int c)
{
	to[idx]=v;
	ne[idx]=hh[u];
	f[idx]=ww;// æµé‡é™åˆ¶
	w[idx]=c;// ä»·æ ¼
	hh[u]=idx++;
}
bool spfa()//æ±‚æœ€çŸ­è·¯å¹¶åˆ¤æ–­æ­¤æ—¶æ˜¯å¦å­˜åœ¨å¢å¹¿è·¯
{
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++) dis[i]=inf;
	queue<int>q;
	q.push(s);
	vis[s]=1;
	dis[s]=0;
	d[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=hh[u];i!=-1;i=ne[i])
		{
			int v=to[i];
			if(f[i]&&dis[v]>dis[u]+w[i])
			{
				dis[v]=dis[u]+w[i];
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	if(dis[t]<inf) return 1;
	return 0;
}
int ans1=0,ans2=0;
int dfs(int u,int mf)
{
	if(u==t) return mf;
	int sum=0;
	vis[u]=1;//è¿™æ ·æ˜¯ä¸ºäº†ä¸‹æ–‡åˆ¤æ–­æ˜¯å¦å­˜åœ¨è´Ÿç¯ï¼Œå¦‚æœæœ‰ï¼Œå¯ç›´æ¥è·³è¿‡
	for(int i=cur[u];i!=-1;i=ne[i])
	{
		cur[u]=i;//å½“å‰å¼§ä¼˜åŒ–
		int v=to[i];
		if(f[i]&&dis[v]==dis[u]+w[i]&&vis[v]==0)//ä¿è¯äº†ä¸€å®šä¼šæŒ‰æœ€çŸ­è·¯å¢å¹¿
		{
			int ff=dfs(v,min(mf,f[i]));
			f[i]-=ff;
			f[i^1]+=ff;
			sum+=ff;
			mf-=ff;
			ans2+=ff*w[i];//ç”±äºdinicæ˜¯å¤šè·¯å¢å¹¿ï¼Œæ‰€ä»¥åªèƒ½è¾¹éå†ä¾¿æ›´æ–°å€¼
			if(mf==0) break;
		}
	}
	vis[u]=0;
//	if(sum==0) d[u]=0;
	return sum;
}
void Dinic()
{
	while(spfa())
	{
		memcpy(cur,hh,sizeof hh);
		ans1+=dfs(s,inf);
	}
	printf("%d %d\n",ans1,ans2);
}
int main()
{
	memset(hh,-1,sizeof hh);
	n=read(),m=read(),s=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read(),c=read();
		add(u,v,w,c);
		add(v,u,0,-c);
	}
	Dinic();
	return 0;
}
```
ä½†æ˜¯ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå…³äº spfaï¼Œå®ƒ~~å·²ç»æ­»äº†~~è¿œä¸å¦‚ dijkstraï¼Œé‚£æœ‰æ²¡æœ‰ä¸€ç§æ–¹æ³•ä½¿æ­¤é¢˜èƒ½ç”¨ dijkstra å‘¢ï¼Ÿæœ‰ï¼Œ**åŸå§‹å¯¹å¶ç®—æ³•**ã€‚æˆ‘ä»¬å…ˆæƒ³ï¼Œæ­¤é¢˜æœ¬æ¥ä¸ç”¨ dijkstra çš„åŸå› æ˜¯å› ä¸ºæœ‰è´Ÿç¯ï¼Œé‚£æˆ‘ä»¬æ˜¯å¦èƒ½å˜è´Ÿä¸ºæ­£å‘¢ï¼Ÿ

1. å¼•å…¥åŠ¿å‡½æ•°ï¼ˆå¯¹å¶å˜é‡ï¼‰$h_{u}$ï¼Œä¸ºæ¯ä¸ªèŠ‚ç‚¹ $v$ ç»´æŠ¤ä¸€ä¸ªåŠ¿èƒ½å€¼ã€‚
2. é‡æ–°å®šä¹‰è¾¹æƒï¼šå¯¹æ¯æ¡è¾¹ $u\rightarrow v$ï¼Œå®šä¹‰ä¿®æ­£è¾¹æƒï¼š$c'_{u,v}=c_{u,v}+h_uâˆ’h_v$ã€‚

3. å…¶ä¸­ $c_{u,v}$ æ˜¯åŸå§‹è´¹ç”¨ã€‚å¯ä»¥é€šè¿‡è®¾ç½®åˆé€‚çš„ $h_u$ï¼Œä½¿å¾—æ‰€æœ‰ä¿®æ­£æƒ $c'_{u,v}\geq 0$ï¼Œä»è€Œå…è®¸ä½¿ç”¨ dijkstra ç®—æ³•ã€‚

4. é‚£ä¹ˆç”±æ­¤å¯å¾—ï¼š$c_{u,v}+h_u-h_v\geq 0$ï¼Œå°† $h_v$ ç§»é¡¹â€”â€”ä¸å°±æ˜¯æœ€çŸ­è·¯ä¸­çš„æ¾å¼›æ“ä½œå—ï¼Ÿé‚£å¥½ï¼Œåˆå§‹åŠ¿å‡½æ•°çš„å€¼å¯ä»¥ç”¨ä» $s$ å‡ºå‘çš„æœ€çŸ­è·¯æ¥è¡¨ç¤ºã€‚(æ­£ç¡®æ€§çš„è¯æ˜ï¼šå¯¹äºä¸€æ¡å¢å¹¿è·¯ï¼Œä¸€æ¡è¾¹ $c'_{i,j}=c_{i,j}+h_i-h_j$ï¼Œå®ƒçš„ä¸‹ä¸€æ¡è¾¹ $c'_{j,k}=c_{j,k}+h_j-h_k$ï¼Œå½“å®ƒä»¬ç›¸åŠ æ—¶ï¼Œ$h_j$ æŠµæ¶ˆäº†ï¼ç”±æ­¤æ¨å‡ºï¼š$\sum c'_{u,v}=\sum c_{u,v}+h_s-h_t$ï¼Œå› æ­¤ï¼Œè·¯å¾„çš„å®é™…è´¹ç”¨ä¸ä¿®æ­£è´¹ç”¨ä»…ç›¸å·®ä¸€ä¸ªå¸¸æ•°ï¼Œä¸è·¯å¾„æ— å…³ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯æ¬¡å¢å¹¿å¤šå¸¦æ¥çš„å€¼æ˜¯ä¸€æ ·çš„ã€‚)
5. è®¾ d_{v} æ˜¯å½“å‰æ®‹é‡ç½‘ç»œä¸­ä» $s$ åˆ° $v$ çš„æœ€çŸ­ä¿®æ­£è·ç¦»ï¼ˆdijkstra å¾—ï¼‰ï¼ŒåŠ¿å‡½æ•°æ›´æ–°ä¸º $h_{newv}=h_{oldv}+d_{v}$ã€‚æ­¤æ—¶æ˜¯å¦ä»ç„¶ä¿æŒéè´Ÿæ€§ï¼Ÿå¯¹äºä¸€æ¡è¾¹ï¼Œ$d_v\leq d_{u}+c'_{u,v}=d_u+c_{u,v}+h_{oldu}-h_{oldv}$ï¼Œæ•´ç†å¾—ï¼š$c_{u,v}+h_{oldu}+d_u-h_{oldv}+d_v\geq 0$ï¼Œå…¶ä¸­ $h_{oldu}+d_u-h_{oldv}$ å°±æ˜¯åŠ¿å‡½æ•°æ›´æ–°äº†ã€‚
## ä»£ç 

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
const int N=1e5+15,inf=INT_MAX;
int read()
{
	int t=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') t=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return t*x;
}
int cur[N],to[N],ne[N],f[N],w[N],vis[N];
int dis[N],h[N],hh[N];
int n,m,s,t,idx;
void add(int u,int v,int ww,int c)
{
	to[idx]=v;
	ne[idx]=hh[u];
	f[idx]=ww;
	w[idx]=c;
	hh[u]=idx++;
}
void spfa()//æ±‚håˆå§‹å€¼ï¼Œå› ä¸ºåªè·‘ä¸€æ¬¡ï¼Œæ‰€ä»¥ä¸ä¼šæ…¢
{
	memset(h,0x3f,sizeof h);
	queue<int>q;
	q.push(s);
	vis[s]=1;
	h[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=hh[u];i!=-1;i=ne[i])
		{
			int v=to[i];
			if(f[i]&&h[v]>h[u]+w[i])
			{
				h[v]=h[u]+w[i];
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}

}
bool dijkstra()
{
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++) dis[i]=inf;
	priority_queue<pii,vector<pii>,greater<pii> >q;
	q.push({0,s});
	dis[s]=0;
	while(!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=hh[u];i!=-1;i=ne[i])
		{
			int v=to[i];
			if(f[i]&&dis[v]>dis[u]+w[i]+h[u]-h[v])
			{
				
				dis[v]=dis[u]+w[i]+h[u]-h[v];
				q.push({dis[v],v});
			}
		}
	}
	return dis[t]!=inf;
}
int ans1=0,ans2=0;
int dfs(int u,int mf)
{
	if(u==t) return mf;
	int sum=0;
	vis[u]=1;
	for(int i=cur[u];i!=-1;i=ne[i])
	{
		cur[u]=i;
		int v=to[i];
		if(f[i]&&vis[v]==0&&h[v]==h[u]+w[i])
		{
			
//			cout<<"ll";
			int ff=dfs(v,min(mf,f[i]));
			f[i]-=ff;
			f[i^1]+=ff;
			sum+=ff;
			mf-=ff;
			ans2+=ff*w[i];
			if(mf==0) break;
		}
	}
	vis[u]=0;
	return sum;
}
void Dinic()
{
	spfa();
	while(dijkstra())
	{
		memset(vis,0,sizeof vis);
		memcpy(cur,hh,sizeof hh);
		for(int i=1;i<=n;i++) h[i]+=dis[i];
		int k=dfs(s,inf);
		ans1+=k;
	}
	printf("%d %d\n",ans1,ans2);
}
int main()
{
	memset(hh,-1,sizeof hh);
	n=read(),m=read(),s=read(),t=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read(),c=read();
		add(u,v,w,c);
		add(v,u,0,-c);
	}
	Dinic();
	return 0;
}
```
~~å®Œç¾æ’’èŠ±ï¼~~

---

## ä½œè€…ï¼šQianK (èµï¼š2)

å†™ä¸€ç¯‡é¢˜è§£æ¥åŠ æ·±å°è±¡ã€‚å…¶ä»–é¢˜è§£éƒ½æ²¡æœ‰è¯´æ˜å¤æ‚åº¦çš„é—®é¢˜å’Œå¸¸è§æ˜“é”™ç‚¹ã€‚æœ¬æ–‡å°†ä»‹ç»ç”¨ vector æ¥å­˜å›¾ï¼Œé‡‡ç”¨ spfa + dinic çš„ç®—æ³•ï¼Œä¹Ÿå°±æ˜¯ SSP ç®—æ³•ã€‚

## SSP ç®—æ³•

é»˜è®¤è¯»è€…å·²ç»å­¦ä¼šäº†æœ€å¤§æµç®—æ³•ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¯æ¡è¾¹åŠ ä¸Š**å•ä½æµé‡**çš„è´¹ç”¨ï¼Œè¦æ±‚åœ¨æœ€å¤§æµçš„åŸºç¡€ä¸Šæ»¡è¶³è´¹ç”¨æœ€å°ï¼Œè¿™å°±æ˜¯æœ€å°è´¹ç”¨æœ€å¤§æµé—®é¢˜ã€‚

ç®€å•æ¥è¯´ï¼Œæˆ‘ä»¬æ¯æ¬¡è´ªå¿ƒåœ°é€‰æ‹©è´¹ç”¨æœ€å°çš„å¢å¹¿è·¯å¢å¹¿ï¼Œç›´åˆ°ä¸å­˜åœ¨å¢å¹¿è·¯æ—¶ç»ˆæ­¢ç®—æ³•ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›¾ä¸­ä¸èƒ½æœ‰è´Ÿåœˆï¼Œå¦‚æœå­˜åœ¨è´Ÿåœˆï¼Œé¦–å…ˆè¦ç”¨æ¶ˆåœˆç®—æ³•æ¶ˆé™¤è´Ÿåœˆã€‚[å­˜åœ¨è´Ÿåœˆçš„é¢˜ç›®](https://www.luogu.com.cn/problem/P7173)è¿™æ˜¯ä¸€é“æœ‰è´Ÿåœˆçš„è´¹ç”¨æµæ¨¡æ¿é¢˜ã€‚

ç°åœ¨è¯æ˜ä¸€ä¸‹è´ªå¿ƒçš„æ­£ç¡®æ€§ã€‚æˆ‘ä»¬å·²çŸ¥å›¾ä¸­ä¸å­˜åœ¨è´Ÿåœˆã€‚å‡è®¾æµé‡ä¸º $i$ çš„æµçš„è´¹ç”¨ä¸º $f_i$ï¼Œæˆ‘ä»¬é€šè¿‡å¢å¹¿ä¸€æ¬¡æœ€çŸ­å¢å¹¿è·¯æ±‚å‡º $f_j$ã€‚å¦‚æœå­˜åœ¨å¦ä¸€ç§ä» $f_i$ å¢å¹¿ä¸€æ¬¡å¢å¹¿è·¯ä¸”å°äº $f_j$ çš„è´¹ç”¨æµ $f_k$ï¼Œåˆ™è¯¥å¢å¹¿å¿…ç„¶èµ°è¿‡è´Ÿåœˆï¼Œä¸å·²çŸ¥å›¾ä¸­ä¸å­˜åœ¨è´ŸåœˆçŸ›ç›¾ï¼Œæ‰€ä»¥è´ªå¿ƒæ˜¯å¯è¡Œçš„ã€‚

ç”±äºæç«¯æƒ…å†µä¸‹ spfa æ‰¾å¢å¹¿è·¯çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(nm)$ï¼Œæ•… SSP ç®—æ³•çš„å¤æ‚åº¦ä¸º $O(nmf)$ï¼Œå…¶ä¸­ $f$ ä¸ºç½‘ç»œæœ€å¤§æµï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™å¹¶ä¸æ˜¯ä¸€ä¸ªå¤šé¡¹å¼å¤æ‚åº¦ï¼Œä¾‹å¦‚ $f = 2^{n/2}$ æ—¶ï¼Œå¤æ‚åº¦ä¸ºæŒ‡æ•°çº§åˆ«ã€‚

å®ç°ä»£ç æ—¶ï¼Œå¯èƒ½å­˜åœ¨ä¸€äº›æ˜“é”™ç‚¹ã€‚é¦–å…ˆï¼Œç”¨ vector æ¥å­˜å›¾ï¼Œæ‰¾åå‘è¾¹æ—¶éœ€è¦æ·»åŠ å¯¹åº”ç¼–å·å¿«é€Ÿå¯»æ‰¾åå‘è¾¹ï¼Œå…¶æ¬¡ï¼Œåå‘è¾¹çš„è´¹ç”¨åº”è¯¥æ˜¯ $-c$ï¼Œè¿™æ ·èµ°åå‘è¾¹æ—¶æ‰æ»¡è¶³æœ€çŸ­è·¯çš„åˆ¤æ–­æ¡ä»¶ï¼Œæ­£å‘è¾¹çš„æ¡ä»¶ä¸º $dis[v]=dis[u]+c$ï¼Œåå‘è¾¹å°±æ˜¯ $dis[u]=dis[v]+(-c)$ã€‚æœ€åï¼Œè·‘ä¸€æ¬¡ spfa åº”è¯¥**å¤šæ¬¡** dfs æ‰¾å¢å¹¿è·¯è€Œä¸æ˜¯åªæ‰¾ä¸€æ¬¡ï¼Œæœ‰çš„é¢˜ç›®ä¼šå¡åªæ‰¾ä¸€æ¬¡çš„ä»£ç ã€‚

é™„ä¸Šä»£ç ã€‚

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
#define int long long//å¼€longlong
using namespace std;
const int N = 5e3 + 5;
const int inf = 0x7fffffff;
int n, m, s, t, mincos;
struct node
{
    int v, w, c, id;
};
vector<node> val[N];
int dis[N], cur[N];
bool vis[N];

bool spfa()
{
    for (int i = 1; i <= n; i++)
        dis[i] = inf;
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    while (!q.empty())
    {
        int x = q.front();
        q.pop();
        vis[x] = false;
        for (auto &e : val[x])
            if (e.w && dis[e.v] > dis[x] + e.c)
            {
                dis[e.v] = dis[x] + e.c;
                if (!vis[e.v])
                    q.push(e.v), vis[e.v] = true;
            }
    }
    return dis[t] != inf;//å¦‚æœå­˜åœ¨å¢å¹¿è·¯å°±è¿”å›trueï¼Œå¦åˆ™è¿”å›false
}

int dfs(int x, int res)
{
    if (x == t || !res)
        return res;
    vis[x] = true;
    int used = 0;
    for (int i = cur[x]; i < val[x].size(); ++i)
    {
        auto &e = val[x][i];
        cur[x] = i;//å½“å‰å¼§ä¼˜åŒ–
        if (!vis[e.v] && e.w && dis[e.v] == dis[x] + e.c)
        {
            int cnt = dfs(e.v, min(res - used, e.w));//é€’å½’æ‰¾æµé‡
            if (cnt)
            {
                e.w -= cnt;
                val[e.v][e.id].w += cnt;
                mincos += cnt * e.c;
                used += cnt;
                if (used == res)
                    break;//æ®‹ç•™ä¼˜åŒ–
            }
        }
    }
    vis[x] = false;
    return used;
}

int dinic()
{
    int ans = 0, flow;
    while (spfa())
    {
        memset(cur, 0, sizeof(cur));
        while ((flow = dfs(s, inf)))//ä¸€æ¬¡spfaè¦æ‰¾å¤šæ¬¡å¢å¹¿è·¯
            ans += flow;
    }
    return ans;
}

signed main()
{
    scanf("%lld%lld%lld%lld", &n, &m, &s, &t);
    for (int i = 1; i <= m; ++i)
    {
        int u, v, w, c;
        scanf("%lld%lld%lld%lld", &u, &v, &w, &c);
        val[u].push_back({v, w, c, (int)val[v].size()});//è®°å½•åå‘è¾¹çš„id
        val[v].push_back({u, 0, -c, (int)val[u].size() - 1});//è®°å½•åå‘è¾¹çš„id
    }
    int maxflow = dinic();
    printf("%lld %lld\n", maxflow, mincos);
    return 0;
}
```

---

## ä½œè€…ï¼šwjyppm1403 (èµï¼š2)

é¢˜è§£åŒºæ²¡æœ‰ vector ç‰ˆæœ¬å®ç°çš„ SSP ç®—æ³•è´¹ç”¨æµï¼Œè¿™ç¯‡é¢˜è§£ç»™å‡ºä¸€ä¸ªåšæ³•ã€‚

# SSPç®—æ³•ä»‹ç»
æœ€å°è´¹ç”¨æœ€å¤§æµå°±æ˜¯åœ¨æœ€å¤§æµçš„åŸºç¡€ä¸Šï¼Œæ¯æ¡è¾¹è¿˜æœ‰å•ä½æµé‡è´¹ç”¨ï¼Œæµç»ä¸€æ¡è¾¹çš„è´¹ç”¨å°±æ˜¯æµé‡ä¹˜é‚£æ¡è¾¹çš„å•ä½è´¹ç”¨ï¼Œæ±‚åœ¨æœ€å¤§æµçš„å‰æä¸‹æ€»è´¹ç”¨æœ€å°ã€‚

é‚£æˆ‘ä»¬æ€ä¹ˆåšåˆ°æ€»è´¹ç”¨æœ€å°ï¼Ÿè¿™é‡Œæˆ‘ä»¬ä»‹ç»çš„ SSP ç®—æ³•é€šè¿‡è´ªå¿ƒçš„æ‰¾è´¹ç”¨æœ€å°çš„å¢å¹¿è·¯æ¥å¢å¹¿ï¼Œè¿™æ ·å°±èƒ½ä¿è¯æˆ‘ä»¬æœ€ç»ˆæ±‚å¾—çš„è´¹ç”¨æµä¸€å®šæ˜¯æœ€å°çš„ï¼Œå¹¶ä¸”æ±‚å¾—çš„ä¹Ÿæ˜¯æœ€å°è´¹ç”¨æœ€å¤§æµã€‚éœ€è¦æ³¨æ„çš„æ˜¯ SSP ç®—æ³•åªèƒ½åœ¨æ²¡æœ‰è´Ÿç¯çš„å›¾ä¸Šä½¿ç”¨ã€‚

å…·ä½“å®ç°å°±æ˜¯å°† EK æˆ– Dinic ç®—æ³•çš„å¢å¹¿è·¯å¯»æ‰¾æ”¹æˆæœ€çŸ­è·¯ç®—æ³•ï¼Œè‹¥ç”¨ SPFA ç®—æ³•å®ç°ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(nmf)$ï¼Œå…¶ä¸­ $f$ ä¸ºæœ€å¤§æµã€‚

# vectorå®ç°

ä¸€èˆ¬çš„è´¹ç”¨æµä½¿ç”¨é“¾å¼å‰å‘æ˜Ÿæ¥åšåˆ°å¿«é€Ÿå¯»æ‰¾åå‘è¾¹ï¼Œvector çš„å±€é™æ€§åœ¨äºæ­¤æ— æ³•å¿«é€Ÿå¯»æ‰¾ï¼Œå¦‚æœæš´åŠ›éå†çš„æ—¶é—´å¤æ‚åº¦ï¼Œå¦‚æœæ˜¯ EK ç®—æ³•é‚£ä¹ˆæ—¶é—´å¤æ‚åº¦å°†ä¸º $O(n^2m^2)$ï¼Œä¼šç›´æ¥ç‚¸æ‰ã€‚

é‚£ä¹ˆæˆ‘ä»¬æ€ä¹ˆå®ç°å‘¢ï¼Ÿå…¶å®å¾ˆç®€å•ï¼Œåªéœ€è¦è®°å½•ä¸€ä¸‹åå‘è¾¹çš„è¾¹å·å³å¯ï¼Œå½“æˆ‘ä»¬åŠ å…¥ä¸€æ¡è¾¹ä¹‹å‰ï¼Œé‚»æ¥è¡¨æ•°ç»„é‡Œé¢å­˜çš„ä¸ªæ•°ä¸º `adj[u].size()`ï¼Œå®ƒä»¬çš„ä¸‹æ ‡ä» $0\rightarrow size-1$ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ–°æ’å…¥ä¸€ä¸ªï¼Œä¸€å®šä¼šè¢«æ”¾åœ¨ `adj[u].size()` çš„ä½ç½®ã€‚

ä»£ç å®ç°ï¼š

```cpp
struct Edge{
    int v,w,c,id;
};
vector<Edge> adj[MN];

void add(int u,int v,int w,int c){
    int us=adj[u].size(),vs=adj[v].size();// è®°å½•ä¸¤ä¸ªä¸‹æ ‡
    adj[u].push_back({v,w,c,vs});
    adj[v].push_back({u,0,-c,us}); // è´¹ç”¨æµçš„èŠå£«ï¼Œè¿™é‡Œåå‘è¾¹çš„è¾¹æƒåº”å½“ä¸ºè´Ÿ
}
```

é‚£å¼§ä¼˜åŒ–å‘¢ï¼Ÿå…¶å®ä¹Ÿå¾ˆç®€å•ï¼Œå› ä¸ºæˆ‘åªéœ€è¦è®°å½•å½“å‰æ²¡æœ‰æµæ»¡çš„æ˜¯åˆ°å“ªä¸ªç‚¹çš„è·¯å¾„ï¼Œé‚£ä¹ˆåŒç†å³å¯ã€‚

å› ä¸º Dinic ç®—æ³•æ¯”è¾ƒå¸¸ç”¨ï¼Œè¿™é‡Œä¸‹é¢ç»™å‡ºè¿™ç§å®ç°çš„å®Œæ•´ä»£ç ã€‚

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int MN=5e3+15;
constexpr int INF=0x3f3f3f3f;
struct Edge{
    int v,w,c,id;
};
int n,m,S,T,mincst,dis[MN],cur[MN];
vector<Edge> adj[MN];
bool vis[MN];

void add(int u,int v,int w,int c){
    int us=adj[u].size(),vs=adj[v].size();
    adj[u].push_back({v,w,c,vs});
    adj[v].push_back({u,0,-c,us});
}

bool spfa(){// SPFA,æœ‰åé—ç—‡çš„è‡ªè¡Œæ›¿æ¢
    queue<int> q;
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    q.push(S);
    dis[S]=0;
    vis[S]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(auto e:adj[u]){
            if(e.w&&dis[e.v]>dis[u]+e.c){
                dis[e.v]=dis[u]+e.c;
                if(!vis[e.v]){
                    q.push(e.v);
                    vis[e.v]=1;
                }
            }
        }
    }
    memset(cur,0,sizeof(cur));
    return (dis[T]!=INF);
}

int dfs(int u,int lim){
    if(u==T) return lim;
    vis[u]=1;
    int ret=0;
    for(int i=cur[u];i<adj[u].size();i++){
        cur[u]=i;// å¼§ä¼˜åŒ–
        int v=adj[u][i].v;
        if(!vis[v]&&adj[u][i].w&&dis[v]==dis[u]+adj[u][i].c){
            int p=dfs(v,min(lim,adj[u][i].w));
            if(!p) dis[v]=INF;
            adj[u][i].w-=p;
            adj[v][adj[u][i].id].w+=p;
            ret+=p;
            lim-=p;
            mincst+=p*adj[u][i].c;// mincståœ¨è¿™é‡Œè®¡ç®—
            if(!lim) break;// è‹¥æµé‡ä¸º0åˆ™ä¼˜åŒ–
        }
    }
    vis[u]=0;
    return ret;
}

int dinic(){
    int ans=0;
    while(spfa()){
        ans+=dfs(S,INF);// è¿™é‡Œå’Œæœ€å¤§æµçš„dinicä¸å¤ªä¸€æ ·ï¼Œæ³¨æ„ä¸€ä¸‹ã€‚
    }
    return ans;
}

int main(){
    cin>>n>>m>>S>>T;
    for(int i=1;i<=m;i++){
        int u,v,w,c;
        cin>>u>>v>>w>>c;
        add(u,v,w,c);
    }
    cout<<dinic()<<" "<<mincst;
    return 0;
}
```

å®Œç»“æ’’èŠ±( Ë˜ 3Ë˜)â™¥

---

## ä½œè€…ï¼šchentianmiao (èµï¼š2)

Upd on 2025.7.8ï¼šä¿®æ­£ï¼Œæ„Ÿè°¢ [TBSF_0207](https://www.luogu.com.cn/user/655088) æŒ‡å‡ºçš„é”™è¯¯ï¼
## æ€è·¯åˆ†æ
æœ€å°è´¹ç”¨æœ€å¤§æµï¼ˆä»¥ä¸‹ç®€ç§° MCMFï¼ŒMin-Cost-Max-Flowï¼‰ï¼Œå°±æ˜¯åœ¨æ»¡è¶³æœ€å¤§æµçš„å‰æä¸‹æ‰¾æœ€å°è´¹ç”¨ï¼ˆæ³¨æ„ä¸æ˜¯åœ¨æœ€å°è´¹ç”¨å‰æä¸‹æ‰¾æœ€å¤§æµï¼‰ã€‚

çœ‹åˆ°è´¹ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠä»–å˜æˆæƒå€¼ï¼Œäºæ˜¯ä¼¼ä¹é—®é¢˜æœ‰ç‚¹åƒæœ€çŸ­è·¯ï¼Œäºæ˜¯æƒ³åˆ°äº† SPFAï¼ˆè‡³äºä¸ºä»€ä¹ˆä¸ç”¨ dijkstraï¼Œæ˜¯å› ä¸ºåå‘å»ºè¾¹æ—¶ï¼Œè´¹ç”¨ä¸ºè´Ÿï¼‰ã€‚

äºæ˜¯æˆ‘ä»¬å°† EK ä¸­çš„ bfs æ¢æˆ SPFAï¼Œæ¯æ¬¡æ‰¾è´¹ç”¨æœ€å°çš„å¢å¹¿è·¯ï¼Œå¤æ‚åº¦ $\mathcal O (nmf)$ï¼Œ$f$ ä¸ºæœ€å¤§æµï¼Œé—®é¢˜è§£å†³ã€‚

## æ­£ç¡®æ€§è¯æ˜
å³è¯ EK+SPFA ç®—æ³•èƒ½æ­£ç¡®æ±‚è§£ MCMF é—®é¢˜ï¼Œéœ€è¦ä¿è¯æœ€ä¼˜æ€§ï¼Œäºæ˜¯æˆ‘ä»¬å¿…é¡»ä¿è¯æœ€å°è´¹ç”¨å¢å¹¿è·¯ä¸­å§‹ç»ˆæ— è´Ÿç¯ã€‚è¿™é‡Œç”¨åè¯æ³•è¯æ˜ã€‚

æ˜¾ç„¶ä¸€èˆ¬æœ€å¼€å§‹ä¸ä¼šæœ‰è´Ÿç¯ï¼Œå¦åˆ™å­˜åœ¨é›¶æµé‡ä½†è´Ÿè´¹ç”¨æƒ…å†µï¼Œå¾€å¾€ä¸ç¬¦åˆå®é™…é—®é¢˜çš„è®¾å®šã€‚

å‡è®¾ä»æ— è´Ÿç¯çš„æ®‹é‡ç½‘ç»œä¸­ï¼Œæ‰¾æœ€å°è´¹ç”¨å¢å¹¿è·¯æ¨æµï¼Œæ–°çš„æ®‹é‡ç½‘ç»œçªç„¶å‡ºç°è´Ÿç¯ã€‚

å¦‚ä¸‹å›¾ï¼Œè®¾ $dst[p]<dst[q]$ï¼Œåˆ™ $S$ åˆ° $T$ çš„æœ€å°è´¹ç”¨ç»è¿‡ $p$ã€‚

![](https://cdn.luogu.com.cn/upload/image_hosting/udy2kmx3.png)

è€Œç”± $p'$ å’Œ $q$ æ„æˆè´Ÿç¯å¯çŸ¥ $dst[p']+dst[q]<0$ï¼Œäºæ˜¯ $dst[q]-dst[p]<0$ï¼Œè¿›è€Œ $dst[q]<dst[p]$ï¼Œä¸ $dst[p]<dst[q]$ çŸ›ç›¾ã€‚

![](https://cdn.luogu.com.cn/upload/image_hosting/z4syp0xj.png)

æ±‡æ€»å°±æ˜¯ï¼š
èµ·å§‹ç½‘ç»œæ— è´Ÿç¯çš„æƒ…å†µä¸‹ï¼ŒEK ç®—æ³•æ¯è½®å¢å¹¿è·¯æ¨æµåéƒ½æ²¡æœ‰è´Ÿç¯ï¼Œæ»¡è¶³æœ€ä¼˜æ€§æ¡ä»¶ï¼Œæ¯è½®å¾—åˆ°çš„è´¹ç”¨éƒ½æ˜¯å½“å‰æµé‡çš„æœ€å°è´¹ç”¨ï¼Œæœ€ç»ˆå¾—åˆ°æœ€å¤§æµæ—¶è´¹ç”¨ä¹Ÿæ˜¯æœ€å°çš„ã€‚

## å‚è€ƒä»£ç 
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1e9,V=5009,E=50009*2;
int pre[V],flow[V],dst[V];
bool in[V];
struct Edge{
	int to,nxt,cap,cpu;
}e[E];
int hd[V],nE=1;
int nV,S,T,n,m;
void add(int u,int v,int cap,int cpu){
	e[++nE]=(Edge){v,hd[u],cap,cpu};
	hd[u]=nE;
}
bool SPFA(){
	fill(dst+1,dst+nV+1,INF);
	fill(in+1,in+nV+1,0);
	fill(pre+1,pre+nV+1,0);
	queue<int>q;
	dst[S]=0;
	flow[S]=INF;
	in[S]=1;
	pre[S]=-1;
	q.push(S);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		in[u]=0;
		for(int i=hd[u];i;i=e[i].nxt){
			int cap=e[i].cap;
			if(!cap){
				continue;
			}
			int v=e[i].to;
			if(dst[v]<=dst[u]+e[i].cpu){
				continue;
			}
			dst[v]=dst[u]+e[i].cpu;
			flow[v]=min(flow[u],cap);
			pre[v]=i;
			if(!in[v]){
				in[v]=1;
				q.push(v);
			}
		}
	}
	return pre[T];
}
void EK(){
	int mxFlw=0,mnCst=0;
	while(SPFA()){
		mxFlw+=flow[T];
		mnCst+=flow[T]*dst[T];
		for(int u=T;u!=S;u=e[pre[u]^1].to){
			e[pre[u]].cap-=flow[T];
			e[pre[u]^1].cap+=flow[T];
		}
	}
	cout<<mxFlw<<" "<<mnCst;
}
int main(){
	cin>>n>>m>>S>>T;
	for(int i=1;i<=m;i++){
		int u,v,cap,cpu;
		cin>>u>>v>>cap>>cpu;
		add(u,v,cap,cpu);
		add(v,u,0,-cpu);
	}
	nV=n;
	EK();
	return 0;
}
```

---

## ä½œè€…ï¼šdyc2022 (èµï¼š1)

[æ›´å¥½çš„é˜…è¯»ä½“éªŒ](https://www.cnblogs.com/dyc2022/p/18980165)
***
è¿™æ˜¯ä¸€é“æ¨¡æ¿é¢˜ã€‚åœ¨åšè¿™é“é¢˜ä¹‹å‰ï¼Œä½ åº”è¯¥è¦å­¦ä¼šï¼š
- [ã€æ¨¡æ¿ã€‘ç½‘ç»œæœ€å¤§æµ](/problem/P3381)
- [ã€æ¨¡æ¿ã€‘è´Ÿç¯](/problem/P3376)
***
å¯¹äºç½‘ç»œ $(V, E)$ï¼Œè¾¹ $(u, v)$ å¸¦å®¹é‡ $f(u, v)$ å’Œè´¹ç”¨ $c(u,v)$ã€‚æ±‚å‡º $S \to T$ çš„æ‰€æœ‰æœ€å¤§æµä¸­æ‰€é€‰è¾¹è´¹ç”¨æœ€å°çš„æ–¹æ¡ˆï¼Œç§°ä½œç½‘ç»œçš„æœ€å°è´¹ç”¨æœ€å¤§æµï¼ˆMCMFï¼‰ã€‚

å¯¹æ­¤ï¼Œæˆ‘ä»¬ä»¥æ±‚è§£æœ€å¤§æµçš„ Edmonds-Karp ç®—æ³•ä¸ºåŸºç¡€ã€‚EK çš„è¿‡ç¨‹æ˜¯ï¼Œæ¯æ¬¡é€‰æ‹©ä¸€æ¡ $S \to T$ çš„**éæ»¡æµè·¯å¾„**å¹¶å°†å…¶æµæ»¡ï¼Œç§°ä½œä¸€æ¬¡å¢å¹¿ï¼Œå¢å¹¿çš„è·¯å¾„ç§°ä½œå¢å¹¿è·¯ã€‚

åœ¨æ±‚è§£æœ€å°è´¹ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä»¥ $c(u, v)$ ä¸ºè¾¹æƒï¼Œæ¯æ¬¡é€‰æ‹© $S \to T$ çš„**æœ€çŸ­éæ»¡æµç®€å•è·¯å¾„**ä½œä¸ºå¢å¹¿è·¯ï¼Œè¿™æ ·å°±èƒ½æ±‚å‡ºæœ€å¤§æµå½“ä¸­çš„æœ€å°è´¹ç”¨ã€‚è¿™å°±æ˜¯ EK æ±‚æœ€å¤§æµçš„æ–¹æ³•ã€‚
***
æˆ‘ä»¬æƒ³æƒ³è¿™ä¸ªä¸œè¥¿ä¸ºä»€ä¹ˆæ˜¯å¯¹çš„ã€‚

EK ç»“æŸçš„æ¡ä»¶æ˜¯å›¾ä¸­ä¸å­˜åœ¨åˆæ³•è·¯å¾„ã€‚ä¸€æ–¹é¢ï¼Œæ ¹æ®æœ€å¤§æµæœ€å°å‰²å®šç†ï¼Œä¸€ä¸ªæµæ˜¯æœ€å¤§æµå½“ä¸”ä»…å½“é€”ä¸­ä¸å­˜åœ¨å¢å¹¿è·¯å¾„ã€‚æ‰€ä»¥æ±‚å‡ºæœ€å¤§æµçš„æ­£ç¡®æ€§æ˜¾ç„¶ã€‚

å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬éœ€è¦è¯´æ˜è¿™ç§æ–¹æ¡ˆæ‰€éœ€è¦çš„è´¹ç”¨æ˜¯æœ€å°‘çš„ã€‚è®°å¤„äºä¸€ä¸ªå±€é¢æ—¶çš„æœ€å°è´¹ç”¨ä¸º $C_0$ï¼Œæˆ‘ä»¬é€šè¿‡æœ€çŸ­è·¯è¿›è¡Œä¸€æ¬¡å¢å¹¿åçš„æœ€å°è´¹ç”¨ä¸º $C_1$ï¼Œæ­¤æ—¶å‡è®¾æˆ‘ä»¬å­˜åœ¨å¦å¤–ä¸€æ¡å¢å¹¿è·¯å¾„æ±‚å‡ºçš„è´¹ç”¨ä¸º $C_2$ ä¸” $C_2 < C_1$ã€‚ç”±äº $C_1$ æ—¶å½“å‰å±€é¢ä¸‹çš„çš„æœ€çŸ­ç®€å•è·¯å¾„ï¼Œå› æ­¤ $C_2$ çš„å¢å¹¿è·¯å¿…ç„¶å­˜åœ¨è´Ÿç¯ï¼Œå’Œå¢å¹¿è·¯çš„**ç®€å•æ€§**ç›¸è¿èƒŒã€‚

ç»¼ä¸Šæ‰€è¿°ï¼Œæˆ‘ä»¬è¯æ˜äº†è¯¥ç®—æ³•çš„æ­£ç¡®æ€§ã€‚
***
æˆ‘ä»¬å›åˆ°å®ç°ä¸Šã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ SPFA ç®—æ³•å¯»æ‰¾æœ€çŸ­ç®€å•è·¯å¾„ï¼Œåœ¨æ¾å¼›çš„æ—¶å€™è®°å½•æ¯ä¸ªç‚¹çš„å‰é©±ã€‚éšåæˆ‘ä»¬æ²¿ç€è®°å½•çš„è·¯å¾„è¿›è¡Œå¢å¹¿ï¼ŒåŒæ—¶å°†æœ€å°è´¹ç”¨åŠ ä¸Šè·¯å¾„çš„è¾¹æƒå’Œã€‚

ç”±äºä¸€æ¬¡å¢å¹¿è‡³å°‘ä½¿æœ€å¤§æµå¢åŠ  $1$ï¼Œå‡è®¾åŸå›¾æœ€å¤§æµä¸º $f$ï¼Œå› æ­¤æœ€å¤šç»è¿‡ $f$ è½®å¢å¹¿åå¾—å‡ºç­”æ¡ˆã€‚ç”±äºä½¿ç”¨çš„æ˜¯ SPFAï¼Œå› æ­¤ä¸€æ¬¡å¢å¹¿çš„å¤æ‚åº¦ä¸º $O(nm)$ï¼Œæ€»å¤æ‚åº¦æ˜¯ $O(nmf)$ã€‚

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 5006
#define M 50006
using namespace std;
int n,m;
struct MCMF_Graph{//by dyc2022
int head[N],tot=2,s,t;
int dis[N],incf[N],pre[N],vis[N],maxflow,mincost;
struct Node{int nxt,to,w,c;}E[M<<1];
void addedge(int u,int v,int w,int c){E[tot]={head[u],v,w,c},head[u]=tot++;}
void addflow(int u,int v,int w,int c){addedge(u,v,w,c),addedge(v,u,0,-c);}
int SPFA()
{
    for(int i=1;i<=n;i++)dis[i]=1e15;
    queue<int> q;
    q.push(s),dis[s]=0,incf[s]=1e15,incf[t]=0;
    while(!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=E[i].nxt)
        {
            int v=E[i].to,w=E[i].w,c=E[i].c;
            if(!w||dis[v]<=dis[u]+c)continue;
            dis[v]=dis[u]+c,incf[v]=min(incf[u],w),pre[v]=i;
            if(!vis[v])q.push(v),vis[v]=1;
        }
    }
    return incf[t];
}
void EK()
{
    maxflow+=incf[t];
    for(int u=t;u!=s;u=E[pre[u]^1].to)
    {
        E[pre[u]].w-=incf[t],E[pre[u]^1].w+=incf[t];
        mincost+=incf[t]*E[pre[u]].c;
    }
}
void getflow(){while(SPFA())EK();}}G;
main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&G.s,&G.t);
    for(int i=1,u,v,w,c;i<=m;i++)
        scanf("%lld%lld%lld%lld",&u,&v,&w,&c),G.addflow(u,v,w,c);
    G.getflow();
    printf("%lld %lld\n",G.maxflow,G.mincost);
    return 0;
}
```

---

## ä½œè€…ï¼šLEWISAK (èµï¼š1)

[æˆ‘çš„åšå®¢](https://www.cnblogs.com/lewisak)

## è´¹ç”¨æµ

### å®šä¹‰

å°±æ˜¯å¯¹æ¯ä¸€æ¡è¾¹åŠ äº†ä¸ªæƒå€¼ $w_{u,v}$ï¼Œå®šä¹‰å¯¹äºä¸€æ¡è¾¹çš„èŠ±è´¹ä¸º $w_{u,v}\times f_{u,v}$ï¼Œæ±‚ï¼šåœ¨æ»¡è¶³æœ€å¤§æµçš„å‰æä¸‹ä½¿å¾—èŠ±è´¹æœ€å°/å¤§çš„èŠ±è´¹å’Œæµé‡ã€‚

### Dinic/EK æ±‚è´¹ç”¨æµ

æŠŠå®ƒä»¬ç®—æ³•ä¸­çš„ bfs æ¢ä¸º spfa å³å¯ï¼Œæ— éœ€è„‘å­å³å¯å®ç°ï¼Œè¿™ç¯‡ä¾§é‡ç‚¹ä¸åœ¨è¿™é‡Œå°±ä¸è´´ä»£ç äº†æ˜‚

### ISAP æ±‚è´¹ç”¨æµï¼ˆ

ç»è¿‡äº†ä¸çŸ¥é“å¤šä¹…çš„é’»ç ”åï¼Œæˆ‘è®¤ä¸ºè¿™ä¸ªç®—æ³•åæ­£æˆ‘æ˜¯éš¾ä»¥å®ç°äº†ğŸ˜­ã€‚

ISAP ä¸èƒ½ç›´æ¥æ±‚è´¹ç”¨æµçš„åŸå› æ˜¯å› ä¸ºå®ƒæœ€æ ¸å¿ƒçš„å±‚æ•°æ€æƒ³å¤±æ•ˆäº†â€”å¦‚æœä½ æƒ³è¦å»¶ç»­è¿™ä¸ªæ€æƒ³ï¼Œä½ å°±éœ€è¦åœ¨æŸä¸ªç‚¹åœ¨èµ°ç¬¬ $k$ çŸ­è·¯çš„æƒ…å†µä¸‹è¢«æ¦¨å¹²åæŠŠå®ƒçš„æ ‡å·æ”¹ä¸ºä» $k+1$ æ›´æ–°å‡ºæ¥çš„ï¼Œè¿™ä¸ªæ€è·¯ä¸€çœ¼è®©å¤æ‚åº¦ä¼ªã€‚

æœ‰å…´è¶£çš„ç ”ç©¶æ–°ç®—æ³•çš„è¯·[ç§»æ­¥](https://www.luogu.com.cn/discuss/1082789)ï¼Œå¯èƒ½æˆ‘çš„ä¸€äº›æ€è€ƒä¼šå¯¹ä½ æœ‰å¸®åŠ©å§ã€‚

### åŸå§‹å¯¹å¶ç®—æ³•æ±‚æœ€å°è´¹ç”¨æœ€å¤§æµ

è¿™å°±æ˜¯ç¥ï¼~~è¦æ°´ä¼°å€¼å†™è¯¦ç»†ç‚¹~~ã€‚

åœ¨è®²è§£è¿™ä¹‹å‰ï¼Œæˆ‘ä»¬è¦å…ˆä»‹ç»å¦ä¸€ä¸ªç®—æ³•ã€‚

#### Johnson å…¨æºæœ€çŸ­è·¯å¾„ç®—æ³•

è¿™ä¸ªç®—æ³•ç”¨æ¥æ±‚ä»€ä¹ˆçœ‹ç®—æ³•åéƒ½èƒ½çœ‹å‡ºæ¥å§ã€‚

æˆ‘ä»¬æ³¨æ„åˆ° dij çš„å¤æ‚åº¦éå¸¸çš„ä¼˜ç§€ï¼Œä½†æ˜¯å¦‚æœæœ‰è´Ÿè¾¹æƒå®ƒå°±æ­»äº†ã€‚

æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘å¯¹åŸå›¾çš„è¾¹æƒè¿›è¡Œå¤„ç†ä½¿å¾—åœ¨ä¸æ”¹å˜ç­”æ¡ˆçš„æƒ…å†µä¸‹ä½¿å¾—è¾¹æƒéè´Ÿã€‚

ä¸€ä¸ªä¼ªçš„æ²¡è¾¹çš„æ–¹æ³•æ˜¯æŠŠæ‰€æœ‰è¾¹æƒéƒ½åŠ ä¸Šä¸€ä¸ªå®šå€¼åç»Ÿè®¡ç­”æ¡ˆæ—¶å‡å»ã€‚

è¿™ä¸ªæ–¹æ³•ä¼ªçš„åœ°æ–¹æ˜¯å› ä¸ºæˆ‘ä»¬æœ€çŸ­è·¯æ—¶ä¼šå—è¿™ä¸ªå®šå€¼çš„å½±å“ï¼Œæ¯å¤šèµ°ä¸€æ¡è¾¹å°±ä¼šè®©è·ç¦»å¤šä¸€ä¸ªä¸è¯¥å¤šçš„å®šå€¼ã€‚

##### ç®—æ³•å®ç°

æ–°å»ºä¸€ä¸ªè™šæ‹Ÿç‚¹ 0ï¼Œå¹¶å°†å®ƒä¸æ‰€æœ‰ç‚¹è¿ä¸€æ¡è¾¹æƒä¸º 0 çš„è¾¹ï¼Œç„¶åä»¥ 0 ä¸ºèµ·ç‚¹è·‘ spfa åå¯¹äºè¾¹ $u\to v$ çš„è¾¹æƒ $w_{u,v}$ ä¿®æ”¹ä¸º $w_{u,v}+h_{u}-h_{v}$ã€‚

##### æ­£ç¡®æ€§è¯æ˜

æˆ‘ä»¬æ³¨æ„åˆ°ä¿®æ”¹è¾¹æƒåå¯¹äºä¸€æ¡è·¯å¾„ $s\to x_1\to x_2\to\dots\to x_n\to t$ çš„é•¿åº¦ä¸ºï¼š
$$
\begin{aligned}
&~~~~~~w_{s,x_1}+h_s-h_{x_1}+w_{x_1,x_2}+h_{x_1}-h_{x_2}+\dots+w_{x_n,t}+h_{x_n}-h_{t}\\
&\Rightarrow w_{s,x_1}+w_{x_1,x_2}+\dots+w_{x_n,t}+h_s-h_{t}
\end{aligned}
$$
ä¹Ÿå°±æ˜¯è¯´ç›¸è¾ƒäºåŸè·¯å¾„ï¼Œæˆ‘ä»¬å¤šäº† $h_s-h_t$ çš„é•¿åº¦ï¼Œä½†è¿™ä¸ªæ˜¾ç„¶æ˜¯å®šå€¼ï¼Œå‡æ‰å³å¯ã€‚

ç„¶åæˆ‘ä»¬è¿˜è¦è¯æ˜å…³é”®çš„æ€§è´¨ï¼šæ‰€æœ‰è¾¹æƒä¸ºæ­£ã€‚

æ³¨æ„åˆ°ä¸€ä¸ªæ˜¾ç„¶çš„äº‹æƒ… $h_u+w_{u,v}$ æˆ‘ä»¬å¯ä»¥ç†è§£æ˜¯ä» 0 åˆ° $v$ çš„æœ€çŸ­è·¯ä½†å¿…é¡»ç»è¿‡ $u$ çš„é•¿åº¦ï¼Œè€Œ $h_v$ å°±æ˜¯ä» 0 åˆ° $v$ æœ€çŸ­è·¯é•¿åº¦ï¼Œæ‰€ä»¥æœ‰ $h_v\le h_u+w_{u,v}$ï¼Œä¹Ÿå°±æ˜¯ $w_{u,v}+h_u-h_v$ éè´Ÿï¼Œä¹Ÿå°±æ˜¯è¾¹æƒéè´Ÿäº†ï¼ã€‚

> é‚£æœ‰çš„å°æœ‹å‹å°±è¦é—®äº†ï¼šè¿™ä¸ªç®—æ³•å’Œæœ€å°è´¹ç”¨æœ€å¤§æµæœ‰ä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥å…ˆåƒ Johnson ä¸€æ ·å¯¹è¾¹æƒè¿›è¡Œå¤„ç†ï¼Œä½†æ˜¯é—®é¢˜æ˜¯æˆ‘ä»¬çš„å¢å¹¿ä¼šæ”¹å˜å›¾çš„å½¢æ€ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å¯¹ $h$ **åŠ¨æ€å¤„ç†**ã€‚

å…ˆç›´æ¥è¯´ç»“è®ºï¼šå¯ä»¥å¯¹ $h_i$ åŠ ä¸Š $s\leadsto i$ çš„æœ€çŸ­è·¯é•¿åº¦ $d_i$ã€‚

é¦–å…ˆæˆ‘ä»¬åˆšåˆšè¯çš„ç¬¬ä¸€ä¸ªä¸œè¥¿æ˜¾ç„¶ä¸éœ€è¦é‡æ–°è¯æ˜ï¼Œè€Œä¸”ç½‘ç»œæµä¸Šç”šè‡³å› ä¸ºæˆ‘ä»¬åªéœ€è¦çŸ¥é“å¢å¹¿è·¯æ˜¯é‚£æ¡ï¼Œæ‰€ä»¥è¿ $h_s-h_t$ éƒ½ä¸ç”¨å‡äº†ï¼

ç°åœ¨è¯æ˜è¾¹æƒéè´Ÿï¼š

* å¯¹äºå¢å¹¿è·¯çš„è¾¹ï¼Œå› ä¸ºå®ƒåœ¨æœ€çŸ­è·¯ä¸Šï¼Œæ‰€ä»¥æœ‰ï¼š
  $$
  \begin{aligned}
  d_i+(w_{i,j}+h_i-h_j)&=d_j\\
  w_{i,j}+(d_i+h_i)-(h_j+d_j)&=0
  \end{aligned}
  $$
  äºæ˜¯éè´Ÿã€‚

* å¯¹äºå¢å¹¿åå¤šçš„è¾¹ï¼ˆå¢å¹¿è·¯ä¸Šè¾¹çš„åå‘è¾¹ï¼‰ï¼š
  $$
  \begin{aligned}
  d_i+(w_{i,j}+h_i-h_j)&=d_j\\
  d_i-(w_{j,i}-h_i+h_j)&=d_j\\
  (w_{j,i}-h_i+h_j)+d_j-d_i&=0\\
  w_{j_i}-(h_i+d_i)+(h_j+d_j)&=0
  \end{aligned}
  $$
  å…¶ä¸­ç¬¬ä¸€è¡Œæ¨å‡ºç¬¬äºŒè¡Œçš„åŸå› æ˜¯åå‘è¾¹çš„è¾¹æƒä¸ºæ­£å‘è¾¹è¾¹æƒçš„ç›¸åæ•°ï¼Œäºæ˜¯éè´Ÿã€‚

* å¯¹äºå…¶ä»–è¾¹ï¼Œå’Œ Johnson æœ€åä¸€æ­¥è¯æ˜æ—¶ç±»ä¼¼çš„ï¼Œæœ‰ï¼š
  $$
  \begin{aligned}
  d_i+(w_{i,j}+h_i-h_j)&\ge d_j\\
  w_{i,j}+(h_i+d_i)-(h_j+d_j)&\ge 0
  \end{aligned}
  $$
  äºæ˜¯éè´Ÿã€‚

ç„¶åå°±è¯å®Œäº†ğŸ‰
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace kong{bool st;}
namespace zhu{
int tot=1,head[1001000],answ,ansc,n,m,s,t,h[1001000],dis[1001000],vis[1001000];
queue<int> q;
struct node{
	int v,id;
	bool operator<(const node& a)const{
		return v>a.v;
	}
};
priority_queue<node> qq;
struct{
	int nxt,to,w,c;
}e[2002000],fr[2002000];
//fr è®°å½•æ‰¾åˆ°çš„å¢å¹¿è·¯
void add(int u,int v,int w,int c){
	e[++tot]={head[u],v,w,c};
	head[u]=tot;
	e[++tot]={head[v],u,0,-c};
	head[v]=tot;
	return;
}
void spfa(){
	while(!q.empty()) q.pop();
	memset(vis,0,sizeof vis);
	memset(h,0x3f,sizeof h);
	h[s]=0;vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,c=e[i].c;
			if(e[i].w&&h[v]>h[x]+c){
				h[v]=h[x]+c;
				if(vis[v]) continue;
				vis[v]=1;
				q.push(v);
			}
		}
	}
}
bool dij(){
	while(!qq.empty()) qq.pop();
	for(int i=1;i<=n;i++) vis[i]=0,dis[i]=1e18;
	dis[s]=0;
	qq.push({0,s});
	while(!qq.empty()){
		int x=qq.top().id;
//		cout<<x<<'\n';
		qq.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].c+h[x]-h[v];
//			cout<<v<<' '<<e[i].c<<' '<<h[v]<<'\n';
			if(e[i].w&&dis[v]>dis[x]+w){
//				cout<<"aowufbh";
				dis[v]=dis[x]+w;
				fr[v].nxt=i;
				fr[v].to=x;
				if(!vis[v]) qq.push({dis[v],v});
			}
		}
//		cout<<'\n';
	}
	return dis[t]!=1e18;
}
void PD(){
	spfa();
//	for(int i=1;i<=n;i++) cout<<h[i]<<' ';
//	cout<<"\n\n";
	while(dij()){
		int minn=1e18;
		for(int i=1;i<=n;i++){
//			cout<<dis[i]<<' ';
			h[i]+=dis[i];
		}
//		cout<<'\n';
		for(int i=t;i!=s;i=fr[i].to){
			minn=min(minn,e[fr[i].nxt].w);
		}
//		cout<<minn<<'\n';
		for(int i=t;i!=s;i=fr[i].to){
			e[fr[i].nxt].w-=minn;
			e[fr[i].nxt^1].w+=minn;
		}
		answ+=minn;
		ansc+=minn*h[t];
	}
}
string main(){
	cin>>n>>m>>s>>t;
	for(int i=1;i<=m;i++){
		int u,v,w,c;
		cin>>u>>v>>w>>c;
		add(u,v,w,c); 
	}
	PD();
	cout<<answ<<' '<<ansc<<'\n';
	return "Primal-Dual åŸå§‹å¯¹å¶ç®—æ³•é•¿å¾—çœŸå¥½çœ‹å•Šï¼\n";
}
}
namespace kong{bool ed;double kj(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<'\n'<<kong::kj();
	return 0;
}
```

é¡ºæ­¤ä¸€æï¼Œè¿™ä¸ªç®—æ³•çš„ç¼ºç‚¹æ˜¯[æ— æ³•åŠ¨æ€åŠ ç‚¹](https://www.luogu.com.cn/discuss/842886)

---

## ä½œè€…ï¼šfush (èµï¼š1)

å‰ç½®ï¼š[**æœ€å¤§æµ**](https://fush-netlify.netlify.app/article/graph/flow/max-flow/)ã€‚

æˆ‘ä»¬åªéœ€è¦åœ¨åšæœ€å¤§æµçš„æ—¶å€™ï¼ŒæŠŠ bfs æ¢æˆä»¥ä»£ä»·ä½œä¸ºè¾¹æƒçš„ spfa å°±å¥½äº†ã€‚  
è¿™æ ·æˆ‘ä»¬æ¯æ¬¡ä¼šè´ªå¿ƒçš„æ‰¾è´¹ç”¨æœ€å°‘å¾—å¢å¹¿è·¯å¢å¹¿ã€‚

è®°å¾—æŠŠåè¾¹çš„ä»£ä»·è®¾ä¸º $-g(u, v)$ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜éœ€è¦é€€å›è´¹ç”¨ã€‚

æˆ‘ä»¬æˆè¿™ä¸ªç®—æ³•ä¸º SSPï¼Œæœ€åæ—¶é—´å¤æ‚åº¦æ˜¯ $O(nmf)$ï¼Œå…¶ä¸­ $f$ è¡¨ç¤ºè¯¥ç½‘ç»œçš„æœ€å¤§æµã€‚

---
æ­£ç¡®æ€§è¯æ˜ï¼š  
æˆ‘ä»¬è€ƒè™‘ä½¿ç”¨æ•°å­¦å½’çº³æ³•å’Œåè¯æ³•æ¥è¯æ˜ã€‚

è®¾æµé‡ä¸º $i$ çš„æ—¶å€™æœ€å°è´¹ç”¨ä¸º $f_i$ã€‚æˆ‘ä»¬å‡è®¾æœ€åˆçš„ç½‘ç»œä¸Š**æ²¡æœ‰è´Ÿåœˆ**ï¼Œè¿™ç§æƒ…å†µä¸‹ $f_0=0$ã€‚

å‡è®¾æ±‚å‡ºçš„ $f_i$ æ˜¯æœ€å°è´¹ç”¨ï¼Œæˆ‘ä»¬åœ¨ $f_i$ çš„åŸºç¡€ä¸Šï¼Œæ‰¾åˆ°ä¸€æ¡æœ€çŸ­çš„å¢å¹¿è·¯ï¼Œä»è€Œæ±‚å‡º $f_{i+1}$ã€‚è¿™æ—¶ $f_{i+1}-f_i$ æ˜¯è¿™æ¡æœ€çŸ­å¢å¹¿è·¯çš„é•¿åº¦ã€‚

å‡è®¾å­˜åœ¨æ›´å°çš„ $f_{i+1}$ï¼Œè®¾å®ƒä¸º 
$f'_{i+1}$ã€‚å› ä¸º $f_{i+1}-f_i$ å·²ç»æ˜¯æœ€çŸ­å¢å¹¿è·¯äº†ï¼Œæ‰€ä»¥ 
$f'_{i+1}-f_i$ ä¸€å®šå¯¹åº”ä¸€ä¸ªç»è¿‡**è‡³å°‘ä¸€ä¸ªè´Ÿåœˆ**çš„å¢å¹¿è·¯ã€‚

è¿™æ—¶å€™çŸ›ç›¾å°±å‡ºç°äº†ï¼šæ—¢ç„¶å­˜åœ¨ä¸€æ¡ç»è¿‡è‡³å°‘ä¸€ä¸ªè´Ÿåœˆçš„å¢å¹¿è·¯ï¼Œé‚£ä¹ˆ $f_i$ å°±ä¸æ˜¯æœ€å°è´¹ç”¨äº†ã€‚å› ä¸ºåªè¦ç»™è¿™ä¸ªè´Ÿåœˆæ·»åŠ æµé‡ï¼Œå°±å¯ä»¥åœ¨ä¸å¢åŠ  $s$ æµå‡ºçš„æµé‡çš„å‰æä¸‹ï¼Œä½¿ $f_i$ å¯¹åº”çš„è´¹ç”¨æ›´å°ã€‚

ç»¼ä¸Šï¼Œç®—æ³•å¯ä»¥æ­£ç¡®æ±‚å‡º**æ— è´Ÿåœˆ**ç½‘ç»œçš„æœ€å°è´¹ç”¨æœ€å¤§æµã€‚

---

EK ç¤ºä¾‹ï¼š
```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a, b, c) for (int a = (b), a##end = (c); a <= a##end; ++a)
#define FR(a, b, c) for (int a = (b), a##end = (c); a >= a##end; --a)
#define lowbit(x) ((x) & -(x))
#define eb emplace_back
#define int long long
#define vt vector
#define ar(x) array<int, x>
#define PII pair<int, int>
#define max(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7<tmd67v8?tmd67v8:b5k5u7; })
#define cmax(a, b) ({auto tmd67v8=(b);(tmd67v8>a)&&(a=tmd67v8); })
#define min(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7>tmd67v8?tmd67v8:b5k5u7; })
#define cmin(a, b) ({auto tmd67v8=(b);(tmd67v8<a)&&(a=tmd67v8); })
constexpr int N = 5e3 + 10, inf = 1e18;
struct edge{int to, next, w, g;}e[50010 * 2];
int n, h[N], dis[N], vis[N], pre[N], tot = 1;
queue<int> q;
void add(int u, int v, int w, int g) { e[++tot] = {v, h[u], w, g}, h[u] = tot; }
PII EK(int s, int t){
	int ans = 0, mi, cost = 0;
	auto spfa = [&](){
		memset(vis, 0, sizeof vis), memset(dis, 0x7f, sizeof dis);
		vis[s] = 1, q.emplace(s), dis[s] = 0;
		while (!q.empty()){
			for (int u = q.front(), i = (q.pop(), h[vis[u] = 0, u]), v; i; i = e[i].next)
				if (e[i].w && dis[u] + e[i].g < dis[v = e[i].to]){
					dis[v] = dis[u] + e[i].g, pre[v] = i;
					if (!vis[v])
						q.emplace(v), vis[v] = 1;
				}
		}
		return dis[t] < dis[0];
	};
	while (spfa()){
		for (int i = (mi = inf, t); i ^ s; i = e[pre[i] ^ 1].to)
			mi = min(mi, e[pre[i]].w);
		for (int i = (ans += mi, cost += dis[t] * mi, t); i ^ s; i = e[pre[i] ^ 1].to)
			e[pre[i]].w -= mi, e[pre[i] ^ 1].w += mi;
	}
	return {ans, cost};
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int n, m, s, t, a, b, c, d;
	cin >> n >> m >> s >> t;
	while (m--)
		cin >> a >> b >> c >> d, add(a, b, c, d), add(b, a, 0, -d);
	auto w = EK(s, t);
	cout << w.first << " " << w.second << endl;
	return 0;
}
```

Dinic ç¤ºä¾‹ï¼š
```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a, b, c) for (int a = (b), a##end = (c); a <= a##end; ++a)
#define FR(a, b, c) for (int a = (b), a##end = (c); a >= a##end; --a)
#define lowbit(x) ((x) & -(x))
#define eb emplace_back
#define int long long
#define vt vector
#define ar(x) array<int, x>
#define PII pair<int, int>
#define max(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7<tmd67v8?tmd67v8:b5k5u7; })
#define cmax(a, b) ({auto tmd67v8=(b);(tmd67v8>a)&&(a=tmd67v8); })
#define min(a, b) ({auto b5k5u7=(a),tmd67v8=(b);b5k5u7>tmd67v8?tmd67v8:b5k5u7; })
#define cmin(a, b) ({auto tmd67v8=(b);(tmd67v8<a)&&(a=tmd67v8); })
constexpr int N = 5e3 + 10, inf = 1e18;
struct edge{int to, next, w, g;}e[50010 * 2];
int n, h[N], dis[N], vis[N], pre[N], tot = 1;
queue<int> q;
void add(int u, int v, int w, int g) { e[++tot] = {v, h[u], w, g}, h[u] = tot; }
PII Dinic(int s, int t){
	auto spfa = [&](){
		memset(vis, 0, sizeof vis), memset(dis, 0x7f, sizeof dis);
		vis[s] = 1, q.emplace(s), dis[s] = 0;
		while (!q.empty()){
			for (int u = q.front(), i = (q.pop(), pre[u] = h[vis[u] = 0, u]), v; i; i = e[i].next)
				if (e[i].w && dis[u] + e[i].g < dis[v = e[i].to]){
					dis[v] = dis[u] + e[i].g, pre[v] = i;
					if (!vis[v])q.emplace(v), vis[v] = 1;
				}
		}
		return dis[t] < dis[0];
	};
	int ans = 0, cost = 0;
	auto dfs = [&, Dfs = [&](auto &&self, int x, int last) -> int{
		if(x == t)return last;
		vis[x] = 1;
		int res = last, k;
		for(int i = pre[x], v; i && res; i = e[i].next)
			if(e[pre[x] = i].w && dis[v = e[i].to] == dis[x] + e[i].g && !vis[v])
				if(k = self(self, v, min(res, e[i].w)))
					e[i].w -= k, e[i ^ 1].w += k,res -= k, cost += k * e[i].g;
				else dis[v] = 0;
		vis[x] = 0;
		return last - res; 
	}](){ return Dfs(Dfs, s, inf); };
	while (spfa()) ans += dfs();
	return {ans, cost};
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	int n, m, s, t, a, b, c, d;
	cin >> n >> m >> s >> t;
	while (m--)
		cin >> a >> b >> c >> d, add(a, b, c, d), add(b, a, 0, -d);
	auto w = Dinic(s, t);
	cout << w.first << " " << w.second << endl;
	return 0;
}
```

---


# 运输问题

## 题目描述

$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。


货物供需平衡，即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$。


从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{i,j}$ 。


试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。

## 说明/提示

$1 \leq n, m \leq 100$

## 样例 #1

### 输入

```
2 3
220 280
170 120 210
77 39 105
150 186 122```

### 输出

```
48500
69140```

# 题解

## 作者：徐致远 (赞：15)


好经典的模型。

### 题解

乍一看就是一个二分图。

但是要求很明显要求最小费用最大流。

考虑如何建模。

由于每一个仓库只能流出定量的货物，但是又不能把每一个仓库看做源。

所以把所有货物都连到同一个源上，连到第$i$个仓库的边嘚的容量为$A_i$，费用为$0$。

每一家零售店又都连到一个汇上，从第$i$家零售店连出的边的容量为$B_i$，费用为$0$。

中间从仓库到零售店的边就按照题目里的说的那样连，容量为$+\infty$。

![1.png](https://www.chnxuzhiyuan.cn/images/「网络流24题」运输问题-Solution-1.png)

然后直接跑最小费用最大流就好了。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=210,maxm=20205,inf=0x3F3F3F3F;
int m,n,S,T,tot,lnk[maxn],son[maxm],nxt[maxm],w[maxm],cap[maxm],que[maxn],lst[maxn],pre[maxn],dist[maxn],flow[maxn],ans;bool vis[maxn];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline void add_e(int x,int y,int z,int c){tot++;son[tot]=y;w[tot]=z;cap[tot]=c;nxt[tot]=lnk[x];lnk[x]=tot;}
inline void MinCostMaxFlow(int flg)
{
	while(true)
	{
		if(flg==1) memset(dist,63,sizeof(dist));
		else memset(dist,192,sizeof(dist));
		memset(flow,63,sizeof(flow));
		int hed=0,til=1;
		que[1]=S;dist[S]=0;vis[S]=true;pre[T]=0;
		while(hed!=til)
		{
			hed=(hed+1)%maxn;vis[que[hed]]=false;
			for(int i=lnk[que[hed]];i;i=nxt[i])
			{
				if(cap[i]&&((flg==1&&dist[que[hed]]+w[i]<dist[son[i]])||(flg==-1&&dist[que[hed]]+w[i]>dist[son[i]])))
				{
					dist[son[i]]=dist[que[hed]]+w[i];
					pre[son[i]]=que[hed];
					lst[son[i]]=i;
					flow[son[i]]=min(flow[que[hed]],cap[i]);
					if(!vis[son[i]])
					{
						vis[son[i]]=true;
						til=(til+1)%maxn;
						que[til]=son[i];
					}
				}
			}
		}
		if(pre[T]==0) return;
		ans+=flow[T]*dist[T];
		int p=T;
		while(p!=S)
		{
			cap[lst[p]]-=flow[T];
			cap[(lst[p]&1)?lst[p]+1:lst[p]-1]+=flow[T];
			p=pre[p];
		}
	}
}
int main()
{
	m=read();n=read();S=1;T=m+n+2;
	for(int i=1;i<=m;i++)
	{
		int ai=read();
		add_e(S,i+1,0,ai);
		add_e(i+1,S,0,0);
	}
	for(int i=1;i<=n;i++)
	{
		int bi=read();
		add_e(i+m+1,T,0,bi);
		add_e(T,i+m+1,0,0);
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int cij=read();
			add_e(i+1,j+m+1,cij,inf);
			add_e(j+m+1,i+1,-cij,0);
		}
	}
	MinCostMaxFlow(1);
	printf("%d\n",ans);
	for(int i=2;i<=tot;i+=2){cap[i-1]+=cap[i];cap[i]=0;}
	ans=0;
	MinCostMaxFlow(-1);
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：寒冰大大 (赞：13)

看了下SPFA题解，一个一个太麻烦了，另一个写的很不清楚，而且注释都变成了"????"不知道怎么过的，于是自己来一发SPFA算法。

## Part 1.题意

$M$个仓库，卖给$N$个商店，两个问，第一问求运价最小值，第二问最大值。

显然是一个最小费用最大流(MCMF)。

## Part 2.思路

1.连让每个仓库连接一个超级源点$S$，费用(dis)为0，流量为仓库的流量，表示每个仓库最多可以运出多少货物。

2.让每一个仓库连接每一家商店，边权为$cost[i][j]$，其中，i为仓库编号，j为商店编号编号，流量为$need[j]$，其实流量可以取得范围是$[need[j]...INF]$ ，另外如果出现$need[j]$<这个仓库货物量的情况也可以不怕(这时候取值的下限变成$min(hw[i],need[j])$) hw指的是这家仓库的货物，还有注意编号的范围（我默认超级源点是$0$，仓库是$1……n$,商店是$n+1……n+m$，超级汇点是$10000$）

3.让每一家商店连接超级汇点$T$

图像帮助理解：
![](https://cdn.luogu.com.cn/upload/pic/62883.png)

## Part 3.代码

现在代码就好办了
注释给的很清楚
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<set>
#include<algorithm>

#define I_copy_this_answer return 0;

using namespace std;

int n,m,head[1100],size=1;
int mmx=1000,mincost,maxwater;
int flow[1100];
int need[1100],cost[310][310];
int pre[1100],las[1100],dis[1100],vis[1100],hw[1100];

struct edge{
	int next,to,dis,flow; 
}e[100860]; 

void addedge(int next,int to,int dis,int flow)
{
	e[++size].to=to;
	e[size].dis=dis;
	e[size].flow=flow;
	e[size].next=head[next];
	head[next]=size;
}


int spfa(int s)
{
	memset(flow,0x3f,sizeof(flow));
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	queue <int> q;
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	pre[mmx]=-1;  //（其实只要不是与p直接连的点(n+1......n+m)就可以了 
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		vis[t]=0;
		int i,j,k,l;
		for(i=head[t];i;i=e[i].next)
		{
			j=e[i].to;
			k=e[i].dis;
			l=e[i].flow;
			if(dis[t]+k<dis[j]&&l>0)  //没有流量的话这条路就增广不了，最短距离是建立在增广路存在的基础上的 
			{
				dis[j]=dis[t]+k;
				las[j]=i;  //las指的是这个点(j)与上个点(t)相连的边的编号 
				pre[j]=t;  //pre指的是这条路径上这个点(j)的上一个点 
				flow[j]=min(flow[t],l);  //把当前边流量与上个点的流量对比，解决出现仓库货物比需要的少的情况 
				if(!vis[j])
				{
					q.push(j);
					vis[j]=1;
				}
			}
		}
	}
	return pre[mmx]!=-1;  //如果不是这个值就说明这个点被刷新，增广成功 
}

void mcmf()
{
	while(spfa(0))
	{
		mincost+=dis[mmx]*flow[mmx];   //从源点出发到汇点的单位费用再乘以单位，由于每次只增广一条路，而且仓库和商店是直接连接的，可以这样写 
		int t=mmx;
		while(t!=0)
		{
			e[las[t]].flow-=flow[mmx];  //回溯，修改每条边的流量，因为该算法中途找到的增广路不是最后的增广路，所以这个要等到最后来改变 
			e[las[t]^1].flow+=flow[mmx];
			t=pre[t];
		}
	}
}

void build_edge(int t)
{
	int i,j;
	for(i=1;i<=m;i++)
	{
		addedge(0,i,0,hw[i]);
		addedge(i,0,0,0);
	} 
	for(i=1;i<=m;i++)
	for(j=1;j<=n;j++)
	{
		addedge(i,j+m,cost[i][j]*t,need[j]);
		addedge(j+m,i,-cost[i][j]*t,0);
	}
	for(i=1;i<=n;i++)
	{
		addedge(i+m,mmx,0,need[i]);
		addedge(mmx,i+m,0,0);
	}
}

int main()
{
	int i,j;
	scanf("%d %d",&m,&n);
	for(i=1;i<=m;i++)
	{
		int t1;
		scanf("%d",&hw[i]);	
	}
	for(i=1;i<=n;i++)
		scanf("%d",&need[i]);
	for(i=1;i<=m;i++)
	for(j=1;j<=n;j++)
		scanf("%d",&cost[i][j]);  //读入，与上面的cost,need,hw如果不明白可以对照输入格式看代表什么意思 
	build_edge(1);  //建立边权为正的边，跑最小费用最大流 
	mcmf();//最小费用最大流(Min Cost Max Flow ）的缩写 
	printf("%d",mincost); 
	maxwater=0;
	mincost=0; 
	size=1;
	memset(head,0,sizeof(head));
	build_edge(-1);
	mcmf();
	printf("\n%d",-mincost);
	I_copy_this_answer
}
```


---

## 作者：mydiplomacy (赞：5)

使用最小费用最大流算法。

（插播：本人最近专攻紫题最大流，具体见我的博客https://www.luogu.org/blog/user38212/）

建立一个超级原点（src），一个超级汇点（sink）。这两个点是虚拟的。

最大流中，最大流代表买卖货物的情况，费用代表实际要花的费用。

对于一个拥有a[i]货物的k点，我们连一条由src到k，容量为a[i]，费用为0的边

对于一个要求获得b[i]货物的k点，我们连一条从k到sink，容量为b[i]，费用为0的边

对于一条i到j价格为p[i][j]的可运输路径，我们连一条由i发货点到j进货点，容量为inf（因为每条路可以无限用）费用为p[i][j]的边

跑最小费用最大流即可。


以样例为例，建图如下

 ![](https://cdn.luogu.com.cn/upload/pic/12990.png) 

(每条边上黑数为最大流的容量，红色为费用)


下面解释一下src（超级原点）和sink（超级汇点）的存在的意义。

首先，最小费用最大流意义是：在最大流的条件下跑最小费用。跑从src到sink的最大流，对于每个出货点，出货的数量就是src到这个点边的流量。对于每个进货点，进货数量就是进货点到sink边的流量。

因为在最大流的前提下跑最小费用，所以一定已经做到所有进货点进货的总数最大了（因为题目保证可行，所以一定所有到sink的边都满流，即收货点都满货）。此时再进行最小费用的计算，正好就是题目条件。

需要注意到的是，实际程序中并不是先把最大流跑出来再跑最短路，这里是为了讲解。


那么如何求最大费用呢？

只需把所有费用边建成负的，结果再取相反数即可。

代码



```cpp

#include<iostream>
#include <memory.h>
const int maxn=1005,maxm=500005,inf=1<<30;
using namespace std;
//以下为我使用邻接表表示方法的最小费用最大流模板
struct Node
{
    int v,c,w;
    Node *next,*rev;
}pool[maxm],*h[maxn],*pree[maxn];
int n,m,s,t,tot,src,sink;
int dis[maxn],q[maxn],prev[maxn];
bool vis[maxn];
int a[maxn],b[maxn],MAP[maxn][maxn];
void addEdge(int u,int v,int c,int w)
{
    Node *p=&pool[++tot],*q=&pool[++tot];
    p->v=v; p->c=c; p->w=w; p->next=h[u]; p->rev=q; h[u]=p;
    q->v=u; q->c=0; q->w=-w; q->next=h[v]; q->rev=p; h[v]=q;
}

bool spfa(){
    for(int i=1;i<maxn;i++) dis[i]=1<<30;
    for(int i=1;i<maxn;i++) vis[i]=0;
    int front=0,rear=0;
    vis[src]=1,dis[src]=0;
    q[rear++]=src;
    while(front<rear)
    {
        int u=q[front++];
        vis[u]=0;
        for(Node *p=h[u];p;p=p->next)
        {
            if(p->c>0 && dis[p->v]>dis[u]+p->w)
            {
                dis[p->v]=dis[u]+p->w;
                prev[p->v]=u;
                pree[p->v]=p;
                if(!vis[p->v])
                {
                    vis[p->v]=1;
                    q[rear++]=p->v;
                }
            }
        } 
    }
    if(dis[sink]<inf) return true;
    return false;
}

int augment(){
    int u=sink;
    int delta=inf;
    while(u!=src)
    {
        delta=min(delta,pree[u]->c);
        u=prev[u];
    }
    u=sink;
    while(u!=src)
    {
        pree[u]->c-=delta;
        pree[u]->rev->c+=delta;
        u=prev[u];
    }
    return delta;
}
int ans1, ans2, zyy;
void mincostflow(int flag)
{
    int delta=0;
    while(spfa()==true)
    {
        delta=augment();
        ans1+=delta;//最大流
        ans2+=delta*dis[sink];//最小费用
    }
    if(flag==4322) zyy=ans2;
}

int main(){
//以下为建图，本题关键
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i];
        addEdge(1,i+1,a[i],0); ///这里超级原点src为1，汇点sink为m+n+2
    }
    for(int j=1;j<=n;j++)
    {
        cin>>b[j];
        addEdge(j+m+1,m+n+2,b[j],0);//这里为了编号，将所有进货点的编号加了m
        //否则，1进货点和1出货点将会重合
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cin>>MAP[i][j];
            addEdge(i+1,j+m+1,1<<30,MAP[i][j]);
        }
    }
    src=1,sink=m+n+2;
    mincostflow(4322);
    cout<<ans2<<endl;
    memset(h,0,sizeof(h));
    for(int i=1;i<=m;i++)
    {
        addEdge(1,i+1,a[i],0);//同样的建法求最大费用
    }
    for(int j=1;j<=n;j++)
    {
        addEdge(j+m+1,m+n+2,b[j],0);
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            addEdge(i+1,j+m+1,1<<30,-1*MAP[i][j]);//这里建负边
        }
    }
    src=1,sink=m+n+2;
    mincostflow(0);
    cout<<-1*ans2+zyy<<endl;//输出的最大值，见上面解释
    return 0;
}
```

---

## 作者：FREEH (赞：5)

### 【题目大意】
- 有m个仓库，有n个销售点，第i个仓库有a[i]件货，第j个销售点必须销售b[i]件货，第i个仓库到第j个销售点要c[i][j]元，问完成销售最少/最多要多少元？

### 【解题思路】
- 最小费用最大流和最大费用最大流。
- 构图：
	1. 源点向每一个仓库连接一条流量为a[i]，费用为0的边。
    1. 仓库i向销售点j连接一条流量为无穷大，费用为c[i][j]。
    1. 销售点j向汇点连接一条流量为b[i]，费用为0的边
- 跑一个最小费用最大流，轻松完成第一个任务。
- 第二个任务只要清空图，然后重新连接为费用是-c[i]的边即可。

### 【解题反思】
- 找最大可以取反以后找最小。

### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;

#define INF 0x3f3f3f3f
int cur=1,n,m,s,t,mcost,mflow;
int head[5005],dis[5005],flow[5005],pre[5005];
int a[5005],b[5005],c[5005][5005];
struct EDGE{
    int t,next,w,f;
}e[100005];
void add(int a,int b,int w,int f)
{
    cur++;e[cur].t=b;e[cur].next=head[a];e[cur].w=w;e[cur].f=f;head[a]=cur;
    cur++;e[cur].t=a;e[cur].next=head[b];e[cur].w=0;e[cur].f=-f;head[b]=cur;
}

queue < int > q;
bool vis[5005];
bool SPFA(int s,int t)
{
    memset(dis,INF,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[s]=0;
    vis[s]=1;
    flow[s]=INF;
    q.push(s);
    while (!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int h=head[u];h!=-1;h=e[h].next)
        {
            int v=e[h].t,f=e[h].f;
            if (e[h].w&&dis[u]+f<dis[v])//????????????
            {
                dis[v]=dis[u]+f;//??????
                flow[v]=min(flow[u],e[h].w);//??????
                pre[v]=h;//????
                if (!vis[v])
                {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    return dis[t]!=INF;
}

void Update(int s,int t)
{
    int x=t;
    while (x!=s)
    {
        int i=pre[x];
        e[i].w-=flow[t];
        e[i^1].w+=flow[t];
        x=e[i^1].t;
    }//??????????????
    mflow+=flow[t];
    mcost+=flow[t]*dis[t];//????
}
void E_K(int s,int t)
{
    while (SPFA(s,t))//????????
        Update(s,t);
}

int main()
{
    scanf("%d%d",&m,&n);
    memset(head,-1,sizeof head);
    s=0;t=m+n+1;
    for (int i=1;i<=m;i++)
    {
    	scanf("%d",&a[i]);
    	add(s,i,a[i],0);
    }
    for (int i=1;i<=n;i++)
    {
    	scanf("%d",&b[i]);
    	add(i+m,t,b[i],0);
    }
    for (int i=1;i<=m;i++)
    	for (int j=1;j<=n;j++)
    	{
    		scanf("%d",&c[i][j]);
    		add(i,j+m,INF,c[i][j]);
    	}
    E_K(s,t);
    printf("%d\n",mcost);
    
    memset(head,-1,sizeof head);
    memset(e,0,sizeof e);
    memset(flow,0,sizeof flow);
    memset(pre,0,sizeof pre);
    mcost=0;
    for (int i=1;i<=m;i++)
    {
    	add(s,i,a[i],0);
    }
    for (int i=1;i<=n;i++)
    {
    	add(i+m,t,b[i],0);
    }
    for (int i=1;i<=m;i++)
    	for (int j=1;j<=n;j++)
    	{
    		add(i,j+m,INF,-c[i][j]);
    	}
    E_K(s,t);
    printf("%d\n",-mcost);
    return 0;
} 
```

---

## 作者：w33z8kqrqk8zzzx33 (赞：4)

经典费用流用处。

看一下发现图的形状是二分图，和左边（仓库）的入流是固定的，右边（零售商）的出流是固定的；之间的边有无限流量但是有固定费用。

遇到单位费用，想最小费用最大流。这样保证左边入流限制会满足和左边出流限制也会满足，和在中间的费用之和会最大/最小。应为费用流常规是算最小费用，来计算最大费用可以把所有费用换正负，求改正负费用的图的最小费用乘`-1`.

代码（去掉费用流板子）：

```cpp
int v1[105], v2[105], v3[105][105];

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n, m; cin >> n >> m;
    MCMF::init();
    rep(i, n) {
        int v; cin >> v;
        v1[i] = v;
        MCMF::ae(n+m, i, v, 0, 0);
    }
    iter(i, n, n+m) {
        int v; cin >> v;
        v2[i-n] = v;
        MCMF::ae(i, n+m+1, v, 0, 0);
    }
    rep(i, n) iter(j, n, n+m) {
        int v; cin >> v;
        v3[i][j-n] = v;
        MCMF::ae(i, j, MCMF::inf, v, 0);
    }
    cout << MCMF::run(n+m, n+m+1).se << endl;
    MCMF::init();
    rep(i, n) MCMF::ae(n+m, i, v1[i], 0, 0);
    iter(i, n, n+m) MCMF::ae(i, n+m+1, v2[i-n], 0, 0);
    rep(i, n) iter(j, n, n+m) MCMF::ae(i, j, MCMF::inf, -v3[i][j-n], 0);
    cout << -MCMF::run(n+m, n+m+1).se << endl;
}

```

---

## 作者：木木！ (赞：3)

好像还没有用`Dijkstra`求最小费用流的qwq

`Dijkstra`只能适用于全正权图的情况，而求最小费用流可能涉及到负权边（反边），可以采用类似于`Jhonson`算法的思想，使用节点的势能调整边权来使边权恒为正数。具体来说，给每个节点赋一个顶标$\pi_i$，使得$c_{ij}-\pi_i+\pi_j\geq 0$，然后使用$c_{ij}-\pi_i+\pi_j$作为边权，计算最短路之后只需要将结果减去$\pi_j$就好了。

顶标的选取可以直接采用上一次最短路的结果。

但是问题是这道题的第二小问一开始就有负权边。面对这种情况，标准做法是使用`SPFA`求出初始顶标（~~所以你的程序既有`Dijkstra`又有`SPFA`~~），但是可以发现我们直接用$max(c_{ij})-c_{ij}$作为初始边权（即每条边取反之后都加上一个值使得他们都为正边）不会影响最后的答案，因为从起点到终点的所有路流的长度相等。所以就不需要写`SPFA`了。

时间复杂度$\Theta(\text{网络流})$。

附AC代码：

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;

void chkmax(int& a,int b)
{
	if(b>a)
	{
		a = b;
	}
}

#define INF 0x7f7f7f7f

int beg[215];
int ed[100005];
int nxt[100005];
int ci[100005];
int fi[100005];
int top = 1;

void addedge(int a,int b,int c,int f)
{
	++top;
	ed[top] = b;
	ci[top] = c;
	fi[top] = f;
	nxt[top] = beg[a];
	beg[a] = top;
}

void addedget(int a,int b,int c,int f)
{
	addedge(a,b,c,f);
	addedge(b,a,0,-f);
}

int dn;
int s,t;
int dist[215];
int vis[215];
int pre[215];
int cnt[215];

bool dijkstra()
{
	for(int i=1; i<=dn; ++i)
	{
		dist[i] = INF-pre[i];
		cnt[i] = beg[i];
		vis[i] = 0;
	}
	
	dist[t] = 0;
	priority_queue<pair<int,int> > pq;
	pq.push(make_pair(0,t));
	
	while(!pq.empty())
	{
		int th = pq.top().second;
		pq.pop();
		if(vis[th])
			continue;
			
		vis[th] = 1;
		
		for(int p=beg[th]; p; p=nxt[p])
		{
			if(ci[p^1] && dist[ed[p]]>dist[th]+fi[p^1]+pre[th]-pre[ed[p]])
			{
				dist[ed[p]] = dist[th]+fi[p^1]+pre[th]-pre[ed[p]];
				pq.push(make_pair(-dist[ed[p]],ed[p]));
			}
		}
	}
	
	for(int i=1; i<=dn; ++i)
	{
		dist[i] += pre[i];
		pre[i] = dist[i];
	}
	
	return dist[s]!=INF;
}

int svis[215];

int sap(int s,int flow)
{
	if(s==t)
		return flow;
	
	svis[s] = 1;

	int flowed = 0;
	for(int& p=cnt[s]; p&&flow; p=nxt[p])
	{
		if(ci[p] && !svis[ed[p]] && dist[s]-fi[p]==dist[ed[p]])
		{
			int f = sap(ed[p],min(ci[p],flow));
			ci[p] -= f;
			ci[p^1] += f;
			flowed += f;
			flow -= f;
		}
	}

	svis[s] = 0;
	
	return flowed;
}

int ai[105];
int bi[105];
int cij[105][105];

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
		scanf("%d",ai+i);
	for(int i=1; i<=m; ++i)
		scanf("%d",bi+i);
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=m; ++j)
			scanf("%d",cij[i]+j);
		
	s = n+m+1;
	t = n+m+2;
	dn = n+m+2;
	for(int i=1; i<=n; ++i)
	{
		addedget(s,i,ai[i],0);
	}
	for(int i=1; i<=m; ++i)
	{
		addedget(i+n,t,bi[i],0);
	}
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=m; ++j)
		{
			addedget(i,j+n,INF,cij[i][j]);
		}
	}
			
	long long ans1 = 0;
	while(dijkstra())
	{
		ans1 += 1LL*dist[s]*sap(s,INF);
	}

	int maxd = 0;
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=m; ++j)
		{
			chkmax(maxd,cij[i][j]);
		}
	}
	int sf = 0;
	for(int i=1; i<=n; ++i)
	{
		sf += ai[i];
	}

	memset(beg,0,sizeof(beg));
	top = 1;
	
	for(int i=1; i<=n; ++i)
	{
		addedget(s,i,ai[i],0);
	}
	for(int i=1; i<=m; ++i)
	{
		addedget(i+n,t,bi[i],0);
	}
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=m; ++j)
		{
			addedget(i,j+n,INF,maxd-cij[i][j]);
		}
	}
	
	long long ans2 = 0;
	while(dijkstra())
	{
		ans2 += 1LL*dist[s]*sap(s,INF);
	}
	
	printf("%lld\n%lld\n",ans1,-(ans2-1LL*maxd*sf));
}
```

---

## 作者：lemir3 (赞：1)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11161587.html)

「网络流 24 题」运输问题

[*题面*](https://www.luogu.org/problemnew/show/P4015)

先来理解下题意.

有$m$个仓库,第$i$个仓库有$a_i$个货物.有$n$个商店,第$i$个商店需要$b_i$个货物.从第$i$个仓库运到第$j$个商店的费用是$c_{ij}$.

于是网络流的建模就出来了,源点连向仓库,流量为$a_i$,费用为$0$.仓库与商店之间相连,流量为$INF$,费用为$c_{ij}$,商店与汇点相连,流量为$b_i$,费用为$0$.

跑一遍$MCMF$求出最小费用.

然后再给费用取反,再跑一遍$MCMF$求出最大费用.

#代码

```cpp

#include "cstdio"
#include "cstring"
#include "algorithm"
#include "iostream"
#include "cmath"
#include "queue"

#define debug(x) printf("debug:%lld\n",x)
#define ll long long
#define INF 2147483647

using namespace std;

struct edge
{
    ll to,next,flow,cost;
}e1[500010],e2[500010];

queue<ll>q1,q2;

ll m,n,start,end,size1,size2,mincost,maxcost;//m个仓库,n个商店.
ll head1[10010],dis1[10010],flow1[10010],last1[10010],pre1[10010];
ll head2[10010],dis2[10010],flow2[10010],last2[10010],pre2[10010];
bool flag1[10010];
bool flag2[10010];

inline void EdgeAdd1(ll,ll,ll,ll);
inline void EdgeAdd2(ll,ll,ll,ll);
inline void MCMF1();
inline void MCMF2();
inline bool SPFA1();
inline bool SPFA2();

signed main(void)
{
    memset(head1,-1,sizeof(head1));
    memset(head2,-1,sizeof(head2));
    scanf("%lld%lld",&m,&n);
    start=0;
    end=m+n+1;
    for(ll _=1;_<=m;_++)
    {
        ll val;
        scanf("%lld",&val);
        EdgeAdd1(start,_,val,0);
        EdgeAdd1(_,start,0,0);
        EdgeAdd2(start,_,val,0);
        EdgeAdd2(_,start,0,0);
    }
    for(ll _=1;_<=n;_++)
    {
        ll val;
        scanf("%lld",&val);
        EdgeAdd1(_+m,end,val,0);
        EdgeAdd1(end,_+m,0,0);
        EdgeAdd2(_+m,end,val,0);
        EdgeAdd2(end,_+m,0,0);
    }
    for(ll _=1;_<=m;_++)
    {
        for(ll __=1;__<=n;__++)
        {
            ll cost;
            scanf("%lld",&cost);
            EdgeAdd1(_,__+m,INF,cost);
            EdgeAdd1(__+m,_,0,-cost);
            EdgeAdd2(_,__+m,INF,-cost);
            EdgeAdd2(__+m,_,0,cost);
        }
    }
    MCMF1();
    MCMF2();
    printf("%lld\n%lld\n",mincost,-maxcost);
return 0;
}

inline void EdgeAdd1(ll from,ll to,ll flow,ll cost)
{
    e1[size1].to=to;
    e1[size1].flow=flow;
    e1[size1].cost=cost;
    e1[size1].next=head1[from];
    head1[from]=size1++;
}

inline void EdgeAdd2(ll from,ll to,ll flow,ll cost)
{
    e2[size2].to=to;
    e2[size2].flow=flow;
    e2[size2].cost=cost;
    e2[size2].next=head2[from];
    head2[from]=size2++;
}

inline void MCMF1()
{
    while(SPFA1())
    {
        ll now=end;
        mincost+=flow1[end]*dis1[end];
        while(now!=start)
        {
            e1[last1[now]].flow-=flow1[end];
            e1[last1[now]^1].flow+=flow1[end];
            now=pre1[now];
        }
    }
}

inline void MCMF2()
{
    while(SPFA2())
    {
        ll now=end;
        maxcost+=flow2[end]*dis2[end];
        while(now!=start)
        {
            e2[last2[now]].flow-=flow2[end];
            e2[last2[now]^1].flow+=flow2[end];
            now=pre2[now];
        }
    }
}

inline bool SPFA1()
{
    memset(dis1,0x3f,sizeof(dis1));
    memset(flag1,false,sizeof(flag1));
    memset(flow1,0x3f,sizeof(flow1));
    q1.push(start);
    pre1[end]=-1;
    dis1[start]=0;
    flag1[start]=true;
    while(q1.empty()==false)
    {
        ll from=q1.front();
        q1.pop();
        flag1[from]=false;
        for(ll _=head1[from];_!=-1;_=e1[_].next)
        {
            ll to=e1[_].to;
            ll cost=e1[_].cost;
            ll flow_=e1[_].flow;
            if(flow_>0&&dis1[to]>dis1[from]+cost)
            {
                dis1[to]=dis1[from]+cost;
                pre1[to]=from;
                last1[to]=_;
                flow1[to]=min(flow1[from],flow_);
                if(flag1[to]==false)
                {
                    q1.push(to);
                    flag1[to]=true;
                }
            }
        }
    }
return pre1[end]==-1?false:true;
}

inline bool SPFA2()
{
    memset(flag2,false,sizeof(flag2));
    memset(dis2,0x3f,sizeof(dis2));
    memset(flow2,0x3f,sizeof(flow2));
    q2.push(start);
    flag2[start]=true;
    dis2[start]=0;
    pre2[end]=-1;
    while(!q2.empty())
    {
        ll from=q2.front();
        q2.pop();
        flag2[from]=false;
        for(ll _=head2[from];_!=-1;_=e2[_].next)
        {
            ll to=e2[_].to;
            ll cost=e2[_].cost;
            ll flow_=e2[_].flow;
            if(flow_>0&&dis2[to]>dis2[from]+cost)
            {
                dis2[to]=dis2[from]+cost;
                pre2[to]=from;
                last2[to]=_;
                flow2[to]=min(flow2[from],flow_);
                if(flag2[to]==false)
                {
                    q2.push(to);
                    flag2[to]=true;
                }
            }
        }
    }
return pre2[end]==-1?false:true;
}

```

---

## 作者：Adove (赞：1)

二分图完美匹配问题

类似的题目在 P4014分配问题

建模方式与上题类似↓

![](https://cdn.luogu.com.cn/upload/pic/15967.png)

跑最小费用最大流和最大费用最大流即可

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,s,t,x[101][101],np=1,mct;
int h[205],ln[205],q[25005];
bool vis[205];
struct rpg{
	int li,nx,ln,ct;
}a[25005];

void add(int ls,int nx,int ln,int ct){
	a[++np]=(rpg){h[ls],nx,ln,ct};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0,-ct};
	h[nx]=np;
}

bool spfa(){
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=t;++i) ln[i]=INF;
	int hd=1,tl=1;
	q[hd]=t;
	ln[t]=0;
	vis[t]=1;
	while(hd<=tl){
		int nw=q[hd++];
		vis[nw]=0;
		for(int i=h[nw];i;i=a[i].li){
			if(a[i^1].ln&&ln[a[i].nx]>ln[nw]-a[i].ct){
				ln[a[i].nx]=ln[nw]-a[i].ct;
				if(!vis[a[i].nx]){
					vis[a[i].nx]=1;
					q[++tl]=a[i].nx;
				}
			}
		}
	}return ln[s]<INF;
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	vis[u]=1;
	int sum=0;
	for(int i=h[u];i;i=a[i].li){
		if(a[i].ln&&!vis[a[i].nx]&&ln[a[i].nx]==ln[u]-a[i].ct){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(){
	while(spfa()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof(vis));
			int d=dfs(s,INF);
			mct+=d*ln[s];
		}
	}
}

int main(){
	scanf("%d%d",&n,&m);t=n+m+1;
	for(int i=1;i<=n;++i){
		scanf("%d",&x[i][0]);
		add(s,i,x[i][0],0);
	}for(int i=1;i<=m;++i){
		scanf("%d",&x[0][i]);
		add(i+n,t,x[0][i],0);
	}for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf("%d",&x[i][j]);
			add(i,j+n,INF,x[i][j]);
		}
	}dnc();
	printf("%d\n",mct);mct=0;
	for(int i=h[s];i;i=a[i].li){
		a[i].ln=x[a[i].nx][0];
		a[i^1].ln=0;
	}for(int i=1;i<=n;++i){
		for(int j=h[i];j;j=a[j].li){
			if(a[j].nx>i){
				a[j].ln=INF;
				a[j^1].ln=0;
				a[j].ct=-a[j].ct;
				a[j^1].ct=-a[j^1].ct;
			}
		}
	}for(int i=h[t];i;i=a[i].li){
		a[i^1].ln=x[0][a[i].nx-n];
		a[i].ln=0;
	}dnc();
	printf("%d\n",-mct);
	return 0;
}
```

---

## 作者：Isonan (赞：1)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P4015)

建图：

1.从源点向仓库i建流为a[i]，费用为0的边；

2.从仓库i向商店j建流为inf，费用为c[i][j]的边；

3.从商店向汇点建流为b[i]，费用为0的边。

对于第一问，跑最小费用最大流即可。

对于第二问，将费用取相反数，再跑一次最小费用最大流，得到的答案再取相反数就可以了。

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int head[301],nxt[50001],b[50001],v[50001],cost[50001],vt[50001],ct[50001],k=1,n,m,ans;
int pre[301],S,T,q[301],h,t,dis[301],flow[301];
bool inq[301];
void push(int s,int t,int v1,int v2){
	nxt[++k]=head[s];
	head[s]=k;
	b[k]=t;
	v[k]=v1;
	cost[k]=v2;
	vt[k]=v1;
	ct[k]=-v2;
}
void link(int s,int t,int v1,int v2){
	push(s,t,v1,v2);
	push(t,s,0,-v2);
}
bool spfa(int v[50001],int cost[50001]){
	memset(inq,0,sizeof inq);
	memset(flow,0x7f7f7f7f,sizeof flow);
	memset(dis,0x7f7f7f7f,sizeof dis);
	h=t=0;
	dis[S]=0;
	q[++t]=S;
	inq[S]=1;
	while(h<t){
		h++;
		inq[q[h]]=0;
		for(int i=head[q[h]];i;i=nxt[i])
			if(v[i]&&dis[b[i]]>dis[q[h]]+cost[i]){
				flow[b[i]]=min(flow[q[h]],v[i]);
				dis[b[i]]=dis[q[h]]+cost[i];
				pre[b[i]]=i;
				if(!inq[b[i]])inq[b[i]]=1,q[++t]=b[i]; 
			}
	}
	return dis[T]!=0x7f7f7f7f;
}
int main(){
	scanf("%d%d",&n,&m);
	S=0,T=n+m+1;
	int tem;
	for(int i=1;i<=n;i++)scanf("%d",&tem),link(S,i,tem,0);
	for(int i=1;i<=m;i++)scanf("%d",&tem),link(i+n,T,tem,0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			scanf("%d",&tem);
			link(i,j+n,0x7f7f7f7f,tem);
		}
	ans=0;
	while(spfa(v,cost)){
		int t=T;
		while(t!=S){
			v[pre[t]]-=flow[T];
			v[pre[t]^1]+=flow[T];
			t=b[pre[t]^1];
		}
		ans+=flow[T]*dis[T];
	}
	printf("%d\n",ans);
	ans=0;
	while(spfa(vt,ct)){
		int t=T;
		while(t!=S){
			vt[pre[t]]-=flow[T];
			vt[pre[t]^1]+=flow[T];
			t=b[pre[t]^1];
		}
		ans+=-flow[T]*dis[T];
	}
	printf("%d\n",ans);
}
```

---

## 作者：MloVtry (赞：0)

几乎是费用流的模板题。。。

建立S与T

s--->i,容量为i号仓库的货物数，长度为0

j--->t,容量为j店铺需求货物数，长度为0

i--->j，容量为inf，长度为给定值

求一个最小费用最大流和一个最大费用最大流

最大费用最大流可以将长度去反，然后最最小费用最大流再输出负的最小花费即可

#代码



```cpp
#include<iostream>
#include<cstring>
#define inf 1<<30
#include<cstdio>
#define M 300000
#include<queue>
#define N 500
using namespace std;
int s,t,n,m,a[110],b[110],ma[110][110];
int head[N],from[M],to[M],Next[M],len[M],cup[M],e=1;
void buid(int u,int v,int c,int l)
{
    Next[++e]=head[u];head[u]=e;to[e]=v;
    len[e]=l;cup[e]=c;from[e]=u;
    Next[++e]=head[v];head[v]=e;to[e]=u;
    len[e]=-l;cup[e]=0;from[e]=v;
}
int dis[N],init[N],pre[N],mflow,mcost;
queue<int> q;
bool bfs()
{
    for(int i=s;i<=t;++i) dis[i]=inf;
    dis[s]=0;init[s]=1;q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();init[now]=0;
        for(int i=head[now];i;i=Next[i])
        {
            if(!cup[i]) continue;
            int j=to[i];
            if(dis[j]>dis[now]+len[i])
            {
                dis[j]=dis[now]+len[i];
                pre[j]=i;
##                 if(!init[j]) init[j]=1,q.push(j); 
            }
        }
    }
    return dis[t]!=inf;
}
void doit()
{
    int now=t,get=inf;
    while(now!=s)
    {
        get=min(get,cup[pre[now]]);
        now=from[pre[now]];
    }
    mflow+=get;mcost+=get*dis[t];
    now=t;
    while(now!=s)
    {
        cup[pre[now]]-=get;
        cup[pre[now]^1]+=get;
        now=from[pre[now]];
    }
}
void max_min()
{
    while(bfs()) doit();
}
void MloVtry(int fl)
{
    for(int i=1;i<=n;++i) buid(s,i,a[i],0);
    for(int i=1;i<=m;++i) buid(n+i,t,b[i],0);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    buid(i,n+j,inf,ma[i][j]*fl);
    max_min();
    printf("%d\n",mcost*fl);
}
int main()
{
    scanf("%d%d",&n,&m);
    t=n+m+1;
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    for(int i=1;i<=m;++i) scanf("%d",&b[i]);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j) scanf("%d",&ma[i][j]);
    MloVtry(1);
    memset(head,0,sizeof(head));
    e=1;mcost=0;
    MloVtry(-1);
    return 0;
}
//岛风快回家啊啊啊啊啊啊
//有新衣服有戒指就差你人了啊啊啊啊啊啊啊啊
//QwQ

```

---

## 作者：leozhang (赞：0)

题面已经提示我们这是费用流了

那么由源点向所有仓库连边，容量为仓库原有货物量，费用为0

然后由所有零售商店向汇点连边，容量为一个零售商店的需求量，费用为0

最后由仓库向零售商店连边，容量正无穷（由于源点和汇点的限制，所以不会出现不合法情况），费用为题给费用

然后跑费用流就得到了最小费用

至于最大费用，按套路所有费用取反后再跑一遍费用流即可

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
const int inf=0x3f3f3f3f;
struct Edge
{
    int next;
    int to;
    int val;
    int pri;
}edge[40005];
int head[255];
int dis[255];
int pre[255];
int fa[255];
bool used[255];
int lim[255];
int v1[255];
int v2[255][255];
int cnt=1;
int st,ed;
int n,m;
void init()
{
    memset(head,-1,sizeof(head));
    memset(edge,0,sizeof(edge));
    cnt=1;
}
void add(int l,int r,int w,int v)
{
    edge[cnt].next=head[l];
    edge[cnt].to=r;
    edge[cnt].val=w;
    edge[cnt].pri=v;
    head[l]=cnt++;
}
int ide(int x)
{
    return (x&1)?x+1:x-1;
}
bool spfa()
{
    memset(dis,0x3f,sizeof(dis));
    memset(used,0,sizeof(used));
    memset(lim,0,sizeof(lim));
    dis[st]=0;
    pre[ed]=-1;
    lim[st]=inf;
    used[st]=1;
    queue <int> M;
    M.push(st);
    while(!M.empty())
    {
        int u=M.front();
        M.pop();
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int to=edge[i].to;
            if(edge[i].val&&dis[to]>dis[u]+edge[i].pri)
            {
                lim[to]=min(lim[u],edge[i].val);
                dis[to]=dis[u]+edge[i].pri;
                pre[to]=i,fa[to]=u;
                if(!used[to])used[to]=1,M.push(to);
            }
        }
        used[u]=0;
    }
    return pre[ed]!=-1;
}
int EK()
{
    int maxw=0,minv=0;
    while(spfa())
    {
        maxw+=lim[ed];
        minv+=lim[ed]*dis[ed];
        int temp=ed;
        while(temp!=st)
        {
            edge[pre[temp]].val-=lim[ed];
            edge[ide(pre[temp])].val+=lim[ed];
            temp=fa[temp];
        }
    }
    return minv;
}
int main()
{
    init();
    scanf("%d%d",&n,&m);
    st=m+n+1,ed=m+n+2;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&v1[i]);
        add(st,i,v1[i],0);
        add(i,st,0,0);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&v1[i+n]);
        add(i+n,ed,v1[i+n],0);
        add(ed,i+n,0,0);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&v2[i][j+n]);
            add(i,j+n,inf,v2[i][j+n]);
            add(j+n,i,0,-v2[i][j+n]);
        }
    }
    printf("%d\n",EK());
    init();
    for(int i=1;i<=n;i++)
    {
        add(st,i,v1[i],0);
        add(i,st,0,0);
    }
    for(int i=1;i<=m;i++)
    {
        add(i+n,ed,v1[i+n],0);
        add(ed,i+n,0,0);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            add(i,j+n,inf,-v2[i][j+n]);
            add(j+n,i,0,v2[i][j+n]);
        }
    }
    printf("%d\n",-EK());
    return 0;
}
```


---

## 作者：Ireliaღ (赞：0)

费用流经典题目，我用的ZKW算法，指针存图

### 思路

- 设超级源点为$0$，超级汇点为$n + m + 1$进行建图

- 对于$\forall i \in [1, m]$，从$0$向$i$建立容量为$a_i$，费用$0$的边

- 对于$\forall j \in [1, n]$，从$m + j$向$n + m + 1$建立容量为$b_i$，费用$0$的边

- 对于$\forall i \in [1, m], \forall j \in [1, n]$，从$i$向$m + j$建立容量为$\infty$，费用$c_{i, j}$的边

然后跑最小费用最大流和最大费用最大流即可

### 程序实现

按照上面的思路，代码如下

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstring>
#include <deque>

using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int m, n;

struct Edge{
    int to, val, cost;
    Edge *next, *ops;
    Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}
};

namespace Zkw1{
    Edge *head[MAXN << 1], *cur[MAXN << 1];
    bool vis[MAXN << 1];
    int dis[MAXN << 1];
    int s, t, res ,ans;

    void AddEdge(int u, int v, int w, int c) {
        head[u] = new Edge(v, w, c, head[u]);
        head[v] = new Edge(u, 0, -c, head[v]);
        head[u]->ops = head[v]; head[v]->ops = head[u];
    }

    bool Spfa() {
        memset(dis, INF, sizeof(dis));
        memset(vis, false, sizeof(vis));
        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop_front();
            vis[u] =false;
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (e->val > 0 && dis[u] + e->cost < dis[v]) {
                    dis[v] = dis[u] + e->cost;
                    if (!vis[v]) {
                        vis[v] = true;
                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
                        else q.push_back(v);
                    }
                }
            }
        }
        return dis[t] < INF;
    }

    int Dfs(int u, int flow) {
        vis[u] = true;
        if (u == t) {
            res += flow;
            return flow;
        }
        int used = 0;
        for (Edge *&e = cur[u]; e; e = e->next) {
            int v = e->to;
            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {
                int mi = Dfs(v, min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    ans += e->cost * mi;
                }
                if (used == flow) break;
            }
        }
        return used;
    }

    void Work() {
        res = ans = 0;
        while (Spfa()) {
            vis[t] = true;
            while (vis[t]) {
                memset(vis, false, sizeof(vis));
                memcpy(cur, head, sizeof(head));
                Dfs(s, INF);
            }
        }
    }
}

namespace Zkw2{
    Edge *head[MAXN << 1], *cur[MAXN << 1];
    bool vis[MAXN << 1];
    int dis[MAXN << 1];
    int s, t, res ,ans;

    void AddEdge(int u, int v, int w, int c) {
        head[u] = new Edge(v, w, c, head[u]);
        head[v] = new Edge(u, 0, -c, head[v]);
        head[u]->ops = head[v]; head[v]->ops = head[u];
    }

    bool Spfa() {
        //memset(dis, -INF, sizeof(dis));
        for (int i = 1; i <= 2 * n + 1; i++) dis[i] = -INF;
        memset(vis, false, sizeof(vis));
        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop_front();
            vis[u] =false;
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (e->val > 0 && dis[u] + e->cost > dis[v]) {
                    dis[v] = dis[u] + e->cost;
                    if (!vis[v]) {
                        vis[v] = true;
                        if (!q.empty() && dis[v] > dis[q.front()]) q.push_front(v);
                        else q.push_back(v);
                    }
                }
            }
        }
        return dis[t] > -INF;
    }

    int Dfs(int u, int flow) {
        vis[u] = true;
        if (u == t) {
            res += flow;
            return flow;
        }
        int used = 0;
        for (Edge *&e = cur[u]; e; e = e->next) {
            int v = e->to;
            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {
                int mi = Dfs(v, min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    ans += e->cost * mi;
                }
                if (used == flow) break;
            }
        }
        return used;
    }

    void Work() {
        res = ans = 0;
        while (Spfa()) {
            vis[t] = true;
            while (vis[t]) {
                memset(vis, false, sizeof(vis));
                memcpy(cur, head, sizeof(head));
                Dfs(s, INF);
            }
        }
    }
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> m >> n;
    Zkw1 :: s = Zkw2 :: s = 0; Zkw1 :: t = Zkw2 :: t = m + n + 1;
    for (int i = 1; i <= m; i++) {
        int x;
        cin >> x;
        Zkw1 :: AddEdge(0, i, x, 0);
        Zkw2 :: AddEdge(0, i, x, 0);
    }
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        Zkw1 :: AddEdge(m + i, m + n + 1, x, 0);
        Zkw2 :: AddEdge(m + i, m + n + 1, x, 0);
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            int x;
            cin >> x;
            Zkw1 :: AddEdge(i, m + j, INF, x);
            Zkw2 :: AddEdge(i, m + j, INF, x);
        }
    }
    Zkw1 :: Work(); Zkw2 :: Work();
    cout << Zkw1 :: ans << endl << Zkw2 :: ans << endl;
    return 0;
}
```
你开开心心复制粘贴提交，发现只有$45$分。**这时需要一个技巧：第二遍把费用取相反数存跑最小费用，要比正常存图跑最大费用快。**代码如下：

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstring>
#include <deque>

using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int m, n;

struct Edge{
    int to, val, cost;
    Edge *next, *ops;
    Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}
};

namespace Zkw1{
    Edge *head[MAXN << 1];
    bool vis[MAXN << 1];
    int dis[MAXN << 1];
    int s, t, res ,ans;

    void AddEdge(int u, int v, int w, int c) {
        head[u] = new Edge(v, w, c, head[u]);
        head[v] = new Edge(u, 0, -c, head[v]);
        head[u]->ops = head[v]; head[v]->ops = head[u];
    }

    bool Spfa() {
        memset(dis, INF, sizeof(dis));
        memset(vis, false, sizeof(vis));
        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop_front();
            vis[u] =false;
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (e->val > 0 && dis[u] + e->cost < dis[v]) {
                    dis[v] = dis[u] + e->cost;
                    if (!vis[v]) {
                        vis[v] = true;
                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
                        else q.push_back(v);
                    }
                }
            }
        }
        return dis[t] < INF;
    }

    int Dfs(int u, int flow) {
        vis[u] = true;
        if (u == t) {
            res += flow;
            return flow;
        }
        int used = 0;
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {
                int mi = Dfs(v, min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    ans += e->cost * mi;
                }
                if (used == flow) break;
            }
        }
        return used;
    }

    void Work() {
        res = ans = 0;
        while (Spfa()) {
            vis[t] = true;
            while (vis[t]) {
                memset(vis, false, sizeof(vis));
                Dfs(s, INF);
            }
        }
    }
}

namespace Zkw2{
    Edge *head[MAXN << 1];
    bool vis[MAXN << 1];
    int dis[MAXN << 1];
    int s, t, res ,ans;

    void AddEdge(int u, int v, int w, int c) {
        head[u] = new Edge(v, w, c, head[u]);
        head[v] = new Edge(u, 0, -c, head[v]);
        head[u]->ops = head[v]; head[v]->ops = head[u];
    }

    bool Spfa() {
        memset(dis, INF, sizeof(dis));
        memset(vis, false, sizeof(vis));
        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop_front();
            vis[u] =false;
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (e->val > 0 && dis[u] + e->cost < dis[v]) {
                    dis[v] = dis[u] + e->cost;
                    if (!vis[v]) {
                        vis[v] = true;
                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
                        else q.push_back(v);
                    }
                }
            }
        }
        return dis[t] < INF;
    }

    int Dfs(int u, int flow) {
        vis[u] = true;
        if (u == t) {
            res += flow;
            return flow;
        }
        int used = 0;
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {
                int mi = Dfs(v, min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    ans += e->cost * mi;
                }
                if (used == flow) break;
            }
        }
        return used;
    }

    void Work() {
        res = ans = 0;
        while (Spfa()) {
            vis[t] = true;
            while (vis[t]) {
                memset(vis, false, sizeof(vis));
                Dfs(s, INF);
            }
        }
    }
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> m >> n;
    Zkw1 :: s = Zkw2 :: s = 0; Zkw1 :: t = Zkw2 :: t = m + n + 1;
    for (int i = 1; i <= m; i++) {
        int x;
        cin >> x;
        Zkw1 :: AddEdge(0, i, x, 0);
        Zkw2 :: AddEdge(0, i, x, 0);
    }
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        Zkw1 :: AddEdge(m + i, m + n + 1, x, 0);
        Zkw2 :: AddEdge(m + i, m + n + 1, x, 0);
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            int x;
            cin >> x;
            Zkw1 :: AddEdge(i, m + j, INF, x);
            Zkw2 :: AddEdge(i, m + j, INF, -x);
        }
    }
    Zkw1 :: Work(); Zkw2 :: Work();
    cout << Zkw1 :: ans << endl << -Zkw2 :: ans << endl;
    return 0;
}
```

---


# [NOIP 2006 提高组] 2^k进制数

## 题目描述

设 $r$ 是个 $2^k$ 进制数，并满足以下条件：

- $r$ 至少是个 $2$ 位的 $2^k$ 进制数。

- 作为 $2^k$ 进制数，除最后一位外，$r$ 的每一位严格小于它右边相邻的那一位。

- 将 $r$ 转换为二进制数 $q$ 后，则 $q$ 的总位数不超过 $w$。

在这里，正整数 $k,w$ 是事先给定的。

问：满足上述条件的不同的 $r$ 共有多少个？

我们再从另一角度作些解释：设 $S$ 是长度为 $w$ 的 $01$ 字符串（即字符串 $S$ 由 $w$ 个 $0$ 或 $1$ 组成），$S$ 对应于上述条件三中的 $q$。将 $S$ 从右起划分为若干个长度为 $k$ 的段，每段对应一位 $2^k$ 进制的数，如果 $S$ 至少可分成 $2$ 段，则 $S$ 所对应的二进制数又可以转换为上述的 $2^k$ 进制数 $r$。

例：设 $k=3,w=7$。则 $r$ 是个八进制数（ $2^3=8$ ）。由于 $w=7$，长度为 $7$ 的 $01$ 字符串按 $3$ 位一段分，可分为 $3$ 段（即 $1,3,3$，左边第一段只有一个二进制位），则满足条件的八进制数有：

$2$ 位数：  
高位为 $1$：$6$ 个（即 $12,13,14,15,16,17$ ）,   
高位为 $2$：$5$ 个，  
…，  
高位为 $6$：$1$ 个（即 $67$ ）。  
共 $6+5+…+1=21$ 个。

$3$ 位数：  
高位只能是 $1$，  
第 $2$ 位为 $2$：$5$ 个（即 $123,124,125,126,127$ ），  
第 $2$ 位为 $3$：$4$ 个，  
…，    
第 $2$ 位为 $6$：$1$ 个（即 $167$ ）。  
共 $5+4+…+1=15$ 个。

所以，满足要求的 $r$ 共有 $36$ 个。


## 说明/提示

【数据范围】  
$1\le k \le 9$    
$1\le w \le 3\times 10^4$

NOIP 2006 提高组 第四题


## 样例 #1

### 输入

```
3 7```

### 输出

```
36```

# 题解

## 作者：xMinh (赞：93)

#等会？？我A了？？

这题正解不是组合数学吗

我看着机房的大佬一个个都在想正解真是瑟瑟发抖

然后我用了个递推结果还跑得贼快

思路大概是这样的

用a[i][j]表示组成一个i位数，第i位选j的所有情况

就等于a[i-1][j+1~maxx]的和

用ans表示每个a[i][j]的和，就是最后的结果

然后可以把第一维压掉，用前缀和进行优化，再加上高精度

代码里面有注释

```cpp
#include<iostream>
#include<cstdio>
#define rint register int
#define ini inline int 
using namespace std;
int a[30001][201],c[201],ans[201],k,w;
ini jia(int *a,int *b)
{
    int lenc=0,x=0;
    while (lenc<a[0] || lenc<b[0])
    {
        a[++lenc]=a[lenc]+b[lenc]+x;
        x=a[lenc]/10;
        a[lenc]%=10;    
    }
    if (x>0) a[++lenc]=x;
    a[0]=lenc;
}
int main()
{
    scanf("%d%d",&k,&w);
    int kk=w%k;int hh=w/k;
    int y=0;
    for (rint i=1;i<=kk;i++)
        y+=1<<(i-1);     //最高位最大是几
    int minn=(1<<k)-1;//第一位最大是多少
    if (hh==1 || (hh==2 && kk==0))
    {
        if (kk==0) y=minn;int tot=0;
        for (rint i=1;i<=y;i++)
            tot+=minn-i;
        cout<<tot;
        return 0;
    }//特判两位以内的情况
    for (rint i=1;i<=minn-1;i++)
    {
        a[i][1]=i;a[i][0]=1;
        jia(ans,a[i]);
    }//第二位是minn-1到1各有多少种可能
    for (rint i=3;i<=hh;i++)
        for (rint j=1;j<=minn-i+1;j++)
//第i位最大是minn-i+1
//第i位是1到minn-i+1各有多少种可能
        {
            jia(a[j],a[j-1]);
            jia(ans,a[j]);
        }
//以下是单独处理最高位，因为最高位有限制
    for (rint j=1;j<=minn-hh;j++)
        jia(a[j],a[j-1]);
    for (rint j=minn-hh;j>=max(minn-hh-y+1,1);j--)
        jia(ans,a[j]);
//我们的前缀和是倒着存的
    for (rint i=ans[0];i>=1;i--)
        printf("%d",ans[i]);
}
```

---

## 作者：asuldb (赞：65)

发现自己推得组合数好像不太一样

先把这个复杂的柿子写一遍

$$\sum_{i=2}^{\left \lfloor\frac{n}{k}\right \rfloor}C_{2^k-1}^{i}+\sum_{i=1}^{2^{n\text{ } \text{mod} \text{ }k}-1}C_{2^k-1-i}^{\left \lfloor\frac{n}{k}\right \rfloor}$$

感觉这个柿子非常蛇皮

但是非常好求啊

由于$2^k-1$非常小，最大仅仅是$511$，所以我们没有什么必要预处理阶乘，我们可以直接用组合数递推的方式来做

于是不需要打高精除或者高精乘了，一个高精加就够了

于是做法就非常无脑了，重要的是这个柿子是怎么推出来的

首先我们先考虑一个非常弱化的版本，就是$k|n$

如果$k|n$的话，**那么这个长度为$n$的二进制数就能被恰好分成$n/k$个块，而且每一个块能选择的数都是$0$到$2^k-1$这$2^k$个数
**

我们发现$0$这个非常不好考虑，于是我们可以先忽略掉$0$

所以现在有$n/k$个块，每个块内能填$2^k-1$种数

**那么就有$C_{2^k-1}^{n/k}$种可能**

之后我们再来考虑$0$的情况，首先最高位（如果不是第二位的话）是可以填$0$的，而剩下的$n/k-1$个块我们仍旧按照之前的方式来填，于是就有$C_{2^k-1}^{n/k-1}$,之后对于次高位还是可以填$0$（同时最高位也填$0$），那么还有$n/k-2$个块，于是就是$C_{2^k-1}^{n/k-2}$

以此类推，直到对于第三个的块，我们还是可以填将这个块以及之前所有的块都填$0$，那么就还有$2$个块，于是就是$C_{2^k-1}^{2}$

而第二个块可是不能填$0$了，于是就没了

所以对于$k|n$的时候，答案就是

$$\sum_{i=2}^{n/k}C_{2^k-1}^{i}$$

之后我们再来考虑一下$k$不整除$n$的情况

这个样子的话一共会分成$\left \lfloor\frac{n}{k}\right \rfloor+1$个块，$\left \lfloor\frac{n}{k}\right \rfloor$个块内可以选择的数都是$0$到$2^k-1$这$2^k$个数，而最后一个不完整的块只有$n\text{ } \text{mod} \text{ }k$位，所以能选择的数只有$0$到$2^{n\text{ } \text{mod} \text{ }k}-1$

如果这个最高位选择填$0$那么退化成了$k|n$的情况，所以最高位填0的方案数为

$$\sum_{i=2}^{\left \lfloor\frac{n}{k}\right \rfloor}C_{2^k-1}^{i}$$

之后最高位还有$1$到$2^{n\text{ } \text{mod} \text{ }k}-1$这些数可以填，如果我们选择填$i$的话，那么剩下的块内就不能填比$i$小的数，于是剩下的每个块内能选择的就有$2^k-1-i$个数，所以方案数就是$C_{2^k-1-i}^{\left \lfloor\frac{n}{k}\right \rfloor}$

所以最后的答案还应该加上

$$\sum_{i=1}^{2^{n\text{ } \text{mod} \text{ }k}-1}C_{2^k-1-i}^{\left \lfloor\frac{n}{k}\right \rfloor}$$

代码

```cpp
#include<cstring>
#include<string>
#include<cstdio>
#include<iostream>
#define re register
#define maxn 512
using namespace std;
string c[maxn][maxn];
int n,k;
int p,t;
int res;
int aa[201],bb[201],cc[201];
inline string sum(string a,string b)
{
    memset(aa,0,sizeof(aa));
    memset(bb,0,sizeof(bb));
    memset(cc,0,sizeof(cc));
    int lena=a.size();
    int lenb=b.size();
    for(re int i=0;i<lena;i++)
        aa[i+1]=a[lena-i-1]-48;
    for(re int i=0;i<lenb;i++)
        bb[i+1]=b[lenb-i-1]-48;
    int p=1;
    for(p=1;p<=max(lena,lenb)||cc[p];p++)
    {
        cc[p]+=aa[p]+bb[p];
        cc[p+1]+=cc[p]/10;
        cc[p]%=10;
    }
    string C="\0";
    for(re int i=p-1;i;i--)
        C+=char(cc[i]+48);
    return C;
}
int main()
{
	scanf("%d%d",&k,&n);
	p=n/k;
	res=n%k;
	t=(1<<k);
	c[0][0]="1";
	for(re int i=1;i<=t-1;i++)
		c[i][0]=c[i][i]="1";
	for(re int i=1;i<t;i++)
	for(re int j=1;j<i;j++)
		c[i][j]=sum(c[i-1][j-1],c[i-1][j]);
	string ans="0";
	for(re int i=2;i<=p;i++)
	{
		if(i>t-1) break;
		ans=sum(ans,c[t-1][i]);
	}
	int pp=(1<<res)-1;
	for(re int i=1;i<=pp;i++)
	{
		if(p>t-1-i) break;
		ans=sum(ans,c[t-1-i][p]);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：01190220csl (赞：40)

基于排列组合的新算法，史上最快（用时0ms）。

先补充一个知识点：对一个n位的2^k进制数，其转化成二进制数后的位数为nk（也有可能较少，因为有前导0的存在，前导0的个数取决于原数的第一位）。

由此，我们知道，这个要求的数的位数不超过w/k向上取整。

而另一方面，又有最多只有2^k-1个数，因此最多2^k-1位。

两个数中取较小的一个就是位置上限。

根据题意，从所有n个数中选m个数后，只有一种组合方式，即m位数的数量是$C^m_n=\frac{n*(n-1)*...*(n-m+1)}{m*(m-1)*...*1}$

总数量是$\sum_{i=2}^{min(w/k+(w\%k==0?0:1),power[k]-1)}{C^i_n}$

这里$n=2^k-1$

为了方便计算，可以推出$C^m_n=C^{m-1}_n*\frac{n-m+1}{m}$

根据这个递归式，可以快速算出结果

但由于前导0的存在，部分场合下会算大，如样例中234也会被包含进去，解决方法就是把它减掉。

由于原位数相同，二进制位数仅取决于前导0的个数，这又取决于原数的首位。

原数的首位同时受位数和对应前导0个数的限制，位数：2^k-max-1，首位2^(w%k)-1。

位数中，max为最大位数，首位的表达式的证明涉及进制转换等一系列方面的内容，这里不做证明，有兴趣可自己证。

受数据取法影响，当位数为max，首位为m时，就相当于在2^k-1-m个数中取max-1个，显然可以用C来表示。

仿照前面，我们得到最后答案$ans=\sum_{i=2}^{min(w/k+(w\%k==0?0:1),power[k]-1)}{C^i_n}-\sum_{i=2}^{min(power[w\%k]-1,power[k]-most-1)}{C^{max-1}_i}$

与递归式$C^m_n=C^m_{n-1}*\frac{n}{n-m},C^n_n=1$

计算时要反过来，即首位m先取2^k-max，再逐渐降到上限。

代码不重要，会写高精度总是写得出来的，不会的也看不懂，不过发上：

```cpp
#include<bits/stdc++.h>
using namespace std;
//比较主要是方便求和
inline bool comp( string a , string b )
{
    if( a.size() < b.size() )
        return 0;
    if( a.size() > b.size() )
        return 1;
    for( int i = a.size() - 1 ; i >= 0 ; i-- )
    {
        if( a[i] < b[i] )
            return 0;
        if( a[i] > b[i] )
            return 1;
    }
    return 1;
}
//求两个数的和
inline string sum( string a , string b )
{
    if( comp( a , b ) == 0 )
        swap( a , b );
    string c = "";
    char x[2] = "";
    bool n = 0;
    int bpt = b.size() - 1;
    for( int i = a.size() - 1 ; i >= 0 ; i-- )
    {    
        if( b[bpt] < '0' || b[bpt] > '9' )
            b[bpt] = '0';
        x[0] = a[i] + b[bpt] - '0';
        if( n == 1 )
        {
            x[0]++;
            n = 0;
        }
        if( x[0] > '9' )
        {
            x[0] -= 10;
            n = 1;
        }
        c.insert( 0 , x );
        bpt--;
        if( bpt < 0 )
        {
            bpt = 0;
            b[0] = '0';
        }
    }
    if( n == 1 )
        c.insert( 0 , "1" );
    while( c[0] == '0' )
        c.erase( 0 , 1 );
    if( c.size() == 0 )
        c.insert( 0 , "0" );
    return c;
}
//求两个数的差（保证结果为正数）
string dif( string a , string b )
{
     string c = "";
     char x[2] = "";
     bool n = 0;
     int bpt = b.size() - 1;
     for( int i = a.size() - 1 ; i >= 0 ; i-- )
     {    
          if( b[bpt] < '0' || b[bpt] > '9' )
                b[bpt] = '0';
          x[0] = a[i] - b[bpt] + '0';
          if( n == 1 )
          {
                x[0]--;
                n = 0;
          }
          if( x[0] < '0' )
          {
                x[0] += 10;
                n = 1;
          }
          c.insert( 0 , x );
          bpt--;
          if( bpt < 0 )
          {
                bpt = 0;
                b[0] = '0';
          }
     }
     while( c[0] == '0' )
          c.erase( 0 , 1 );
     if( c.size() == 0 )
          c.insert( 0 , "0" );
     return c;
}
//求高精度数与整型数的积
string mul( string a , int b )
{
    string c = "";
    char x[2] = "";
    int n = 0 , y;
    for( int i = a.size() - 1 ; i >= 0 ; i-- )
    {
        y = 0;
        if( n > 0 )
            y = n;
        n = ( a[i] - '0' ) * b + y;
        x[0] = n % 10 + '0';
        n /= 10;
        if( x[0] > '9' )
        {
            x[0] -= 10;
            n++;
        }
        c.insert( 0 , x );
    }
    while( n > 0 )
    {
        x[0] = n % 10 + '0';
        n /= 10;
        c.insert( 0 , x );
    }
    while( c[0] == '0' )
        c.erase( 0 , 1 );
    if( c.size() == 0 )
        c.insert( 0 , "0" );
    return c;
}
//求高精度数与整型数的商
string div( string a , int b )
{
    string c = "";
    char x[2] = "";
    int n = 0 , y;
    for( int i = 0 ; i < a.size() ; i++ )
    {
        n *= 10;
        n += a[i] - '0';
        x[0] = n / b + '0';
        n %= b;
        c.insert( c.size() , x );
    }
    while( n > 0 )
    {
        x[0] = n % 10 + '0';
        n /= 10;
        c.insert( 0 , x );
    }
    while( c[0] == '0' )
        c.erase( 0 , 1 );
    if( c.size() == 0 )
        c.insert( 0 , "0" );
    return c;
}
//把整型数转化成高精度数
string change( int num )
{
    if( num == 0 )
        return "0";
    string a = "";
    char c[2] = "";
    while( num > 0 )
    {
        c[0] = num % 10 + '0';
        num /= 10;
        a.insert( 0 , c );
    }
    return a;
}
//覆盖（即用一个高精度数覆盖另一个高精度数）
void instead( string &s , string s0 )
{
    s.erase( 0 , s.size() );
    s.insert( 0 , s0 );
}

string c[50000];
const int power[10] = { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 };//打表计算2^n

int main()
{
    int k , w;
    cin >> k >> w;
    c[2] = change( ( power[k] - 1 ) * ( power[k] - 2 ) / 2 );
    string ans = c[2];
    int most = min( w / k + ( w % k == 0 ? 0 : 1 ) , power[k] - 1 );
    //most存储max（max不能定义）
    for( int i = 3 ; i <= most ; i++ )
    {
        if( ( power[k] - i ) % i == 0 )
            c[i].insert( 0 , mul( c[i - 1] , ( power[k] - i ) / i ) );
        else
            c[i].insert( 0 , div( mul( c[i - 1] , power[k] - i ) , i ) );
        ans = sum( ans , c[i] );
    }
    instead( c[most - 1] , "1" );
    int most2 = min( power[w % k] - 1 , power[k] - most - 1 );
    if( power[k] - most <= power[w % k] - 1 || most2 <= 0 )
    {
        cout << ans;
        return 0;
    }
    //特殊情况，如3 17，最大234567，上限6位3起，这时会误判
    ans = dif( ans , "1" );//首位为max-1时要减掉
    for( int i = most ; i < power[k] - 1 - most2 ; i++ )
    {
        if( i % ( i - most + 1 ) == 0 )
            instead( c[i] , mul( c[i - 1] , i / ( i - most + 1 ) ) );
        else
            instead( c[i] , div( mul( c[i - 1] , i ) , i - most + 1 ) );
        ans = dif( ans , c[i] );
    }
    cout << ans;
}
```

---

## 作者：kkkstra (赞：8)

首先，一个$n$位的$2^k$进制数，转成二进制之后的位数为$nk$，所以题目中的$r$的位数不能超过$\lceil \frac{w}{k} \rceil$。

因为转成二进制后有位数$w$的限制，所以最高位可能并不是长度为$k$的完整的一段，需要特殊考虑。

首先考虑最高位填$0$的情况，那么剩下的每一位都有$2^k-1$种数可以选择，有由题意可知，选出的数的排列方式是唯一的，所以这部分对答案的贡献为

$$\sum \limits_{i=2}^{\lfloor \frac{w}{k} \rfloor} \binom{2^k-1}{i}$$

再来考虑最高位不为0的情况，由于位数$w$的限制，所以最高位的位数最多为$n \mod k$，故除了0以外，最高位最多可以填的数有$2^{w \mod k}-1$种，又由题意可知，后面的数都只能填大于前一位的数，所以只能从大于最高位的数里面选，故这一部分的贡献为

$$\sum \limits_{i=1}^{2^{w \mod k}-1} \binom{2^k-i-1}{\lfloor \frac{w}{k} \rfloor}$$

两部分加起来就是答案，所以

$$ans = \sum \limits_{i=2}^{\lfloor \frac{w}{k} \rfloor} \binom{2^k-1}{i} + \sum \limits_{i=1}^{2^{w \mod k}-1} \binom{2^k-i-1}{\lfloor \frac{w}{k} \rfloor}$$

组合数直接递推一下，再加个高精就可以得到答案了。

---

## 作者：Infiltrator (赞：7)

# 题意  
求出满足是$2^k$进制的数的个数，条件如下：

1.该数位数>=2  

2.该数每一位的数都严格比右边数位的数小    

3.将该数转化为2进制后，总位数不能超过w  

# 解题思路 

经过手动实验，我们发现一个数由$2^k$进制转换为2进制时，位数由原来的w变成了w/k，所以因为转换后位数最多为w，转换前位数最多为w/k。  

当且仅当w%k==0的时候，原来w位可以完全转换为w/k位。  
不整除的时候会有一些剩余。（~~此处意会~~） 

于是我们可以对两种情况分类讨论  

当k整除w的时候，显然答案就是所有可能的数里选位数个（因为要求严格递增所以是组合数）$2^k$进制下每一位有$0-2^{k-1}$一共$2^k$个数，但是我们考虑严格递增，那么如果放0,0必须放在第一位。但是0放在第一位会导致与之前的答案重复，所以我们直接将0忽略即可。  

于是这种情况下答案就是$\sum_{i=2}^{w/k}C_{2^k-1}^{i}$  

当i>$2^k-1$的时候直接返回即可  

再考虑不整除的情况，我们在把$2^k$进制的数转化为$2$进制的时候其实是把每一位数都拆开拆成k位数字，除了最高位以外的数其他位上有没有0是无所谓的，整除的时候也是无所谓的。  

但是当不整除的时候，我们把除了最高位以外的都填满，会发现最后k位还有w%k位可以填数字，但是该数的二进制数不能超过w%k位  

所以我们对不整除的这一位单独处理

经过简单思考，最高位可能放的数字就是$1---2^{w \mod k}-1$  

所以我们枚举最高位的数，剩下的用组合数计算，注意剩下的数要大于最高位的数  

这时答案就是$\sum_{i=1}^{2^{w \mod k}-1}C_{2^k-1-i}^{w/k}$  

综上所述，当不整除的时候，答案就是两者之和，即  

$\sum_{i=2}^{w/k}C_{2^k-1}^{i}+\sum_{i=1}^{2^{w \mod k}-1}C_{2^k-1-i}^{w/k}$  

当整除时，答案就是一开始我们处理的，即  

$\sum_{i=2}^{w/k}C_{2^k-1}^{i}$  
# CODE
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int answer[500];
int a[500],b[500];
int k,w,n,m,c;
int gcd(int a,int b)
{
    return !b?a:gcd(b,a%b);
}
void work(int n,int m)
{
    if(n<m)return;
    for(int i=m;i>=1;i--){a[i]=n-m+i;b[i]=i;}
    for(int i=1;i<=m;i++)
    {
        if(b[i]==1)continue;
        for(int j=m;j>=1;j--)
        {
            int GCD=gcd(a[j],b[i]);
            a[j]/=GCD,b[i]/=GCD;
            if(b[i]==1)break;
        }
    }
    memset(b,0,sizeof(b));
    b[0]=b[1]=1;
    for(int i=1;i<=m;i++)
    {
        if(a[i]==1)continue;
        int g=0;
        for(int j=1;j<=b[0];j++)
        {
            b[j]=a[i]*b[j]+g;
            g=b[j]/10;
            b[j]%=10;
            if(j==b[0] && g)b[0]++;
        }
    }
    answer[0]=max(answer[0],b[0]);
    for(int i=1;i<=answer[0];i++)
    {
        answer[i]=b[i]+answer[i];
        answer[i+1]+=answer[i]/10;
        answer[i]%=10;
    }
    if(answer[answer[0]+1])answer[0]++;
}
int main()
{
    scanf("%d%d",&k,&w);
    n=(1<<k)-1;m=w/k;c=w%k;
    for(int i=m;i>=2;i--)work(n,i);
    c=(1<<c)-1;
    if(c>=1 && n>m)
        for(int i=1;i<=c;i++)work(n-i,m);
    for(int i=answer[0];i>=1;i--)printf("%d",answer[i]);
    return 0;
}
```



------------
这片题解写了我半个小时(((

---

## 作者：Iowa_BattleShip (赞：6)

大力猜结论竟然猜对了。。  

对于一对$k,w$，我们可以把$w$位划分成$k$位一段的形式，每一段就是转换成十进制后的一位，这个从题面的解释中应该可以理解。  
先不考虑可能多出（即剩余不足以划成$k$位）的一段，这样使得每一位的枚举上界都是$2 ^ k - 1$，然后我们枚举几位数。  
- $2$位数  
十位为$1$，显然个位只能为$2\sim 2 ^ k - 1$，共$2 ^ k - 2$种。  
十位为$2$，显然个位只能为$3\sim 2 ^ k - 2$，共$2 ^ k - 3$种。  
$\dots$  
这么递推下去，在$2$位数的情况下，共$\sum \limits _{i = 1} ^ {2 ^ k - 2}i$种。  
- $3$位数  
百位为$1$，显然十位只能为$2\sim 2 ^ k - 2$，这时我们考虑去取之前计算$2$位数得到的结果，因为十位从$2$开始，所以共$\sum \limits _{i = 1} ^ {2 ^ k - 3}i$种。  
百位为$2$，显然十位只能为$3\sim 2 ^ k - 2$，共$\sum \limits _{i = 1} ^ {2 ^ k - 4}i$种。  
$\dots$  
递推下去，在$3$位数的情况下，共$\sum \limits _{i = 1} ^ {2 ^ k - 3} \sum \limits _{j = 1} ^ i j$种。  
- $4$位数  
同样如上考虑，共$\sum \limits _{i = 1} ^ {2 ^ k - 4} \sum \limits _{j = 1} ^ i \sum \limits _{k = 1} ^ {j} k$种。  
$\dots$  

而这个一堆$\sum$的式子其实就相当于每次进行前缀和操作，于是我们就可以依照上面的模式递推下去了。  
初始化$i = 1 \to 2 ^ k - 1,S[i] = i$。  
枚举位数，再枚举首位（注意上界，要保证后面每一位都能填数），累计贡献，然后对$S$数组进行前缀和操作即可。  
然后考虑不能划分成$k$位的那一段，其实只需单独拎出来进行单独枚举计算贡献即可（其实只是改个上界而已）。  
因为数据较大，所以要用高精。  
我的高精是直接$copy$我的[高精模板](https://www.cnblogs.com/Iowa-Battleship/p/9869499.html)~~（太懒了~~  
部分细节可看代码。  
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
const int N = 210;
const int M = 520;
const int base = 1e8;
struct bigint {//高精模板
	int s[N], l;
	void CL(){ l = 0; memset(s, 0, sizeof(s)); }
	void pr()
	{
		printf("%d", s[l]);
		for (int i = l - 1; i; i--)
			printf("%08d", s[i]);
	}
	ll toint()
	{
		ll x = 0;
		for (int i = l; i; i--)
			x = x * base + s[i];
		return x;
	}
	bigint operator = (int b)
	{
		CL();
		do
		{
			s[++l] = b % base;
			b /= base;
		} while (b > 0);
		return *this;
	}
	bigint operator + (const ll &b)
	{
		bigint c = *this;
		ll x = b;
		for (int i = 1; i <= l && x; i++)
		{
			x = x + c.s[i];
			c.s[i] = x % base;
			x /= base;
		}
		if (x)
			c.s[++c.l] = x;
		return c;
	}
	bigint operator + (bigint &b)
	{
		if (b.l < 3)
			return *this + b.toint();
		bigint c;
		ll x = 0;
		int k = l < b.l ? b.l : l;
		c.CL();
		c.l = k;
		for (int i = 1; i <= k; i++)
		{
			x = x + s[i] + b.s[i];
			c.s[i] = x % base;
			x /= base;
		}
		if (x)
			c.s[++c.l] = x;
		return c;
	}
};//以上都是高精模板
bigint s, S[M];
inline int re()
{
	int x = 0;
	char c = getchar();
	bool p = 0;
	for (; c < '0' || c > '9'; c = getchar())
		p |= c == '-';
	for (; c >= '0' && c <= '9'; c = getchar())
		x = x * 10 + c - '0';
	return p ? -x : x;
}
int main()
{
	int i, j, k, w, n, o;
	k = re();
	w = re();
	o = 1 << k;
	n = w / k + (w % k ? 1 : 0);//划分段数
	w = w % k ? (1 << (w % k)) - 1 : o - n;//计算多出一段的上界，如果没有多出，那上界就是2 ^ k - n，因为要保证后面每一位都能填数。
	if (n > o - 1)//若划分出来的段数多于2 ^ k - 1段，这多余的就是没有用的
	{
		n = o - 1;
		w = o - n;
	}
	for (i = 1; i < o; i++)//初始化
		S[i] = i;
	for (s = 0, i = 2; i <= n; i++)//枚举位数
	{
		if (i < n)
			for (j = 1; j <= o - i; j++)//枚举首位填什么数，上界为2 ^ k - i
				s = s + S[o - i - j + 1];//后一位能填j + 1 ~ (2 ^ k - 1) - (i - 1)，共2 ^ k - i - j + 1种
		else//特判最后一段，改上界
			for (j = 1; j <= w; j++)
				s = s + S[o - i - j + 1];
		for (j = 1; j <= o - i; j++)//计算前缀和
			S[j] = S[j] + S[j - 1];
	}
	s.pr();
	return 0;
}
```

---

## 作者：0Io_oI0 (赞：3)

这道题目要用高精度！读者们自己去写吧，我就不打了~~作者直接用 python 写了~~。

想要解决这道题目我们先要求出 $w$ 除以 $k$ 的余数 $r_0$，并且求出 $2^k$ 进制数的最大位数 $max$。

而 $max$ 的具体求法就是 $w$ 不被 $k$ 整除，则将 $max$ 增加一。

这里我们需要注意的是有一种特殊情况就是 $max<2$ 的时候，一定是构造不出来的，直接特判输出 $0$ 就好了。

接下来就是如何求出答案了，其实很简单我们从 $2$ 一直枚举到 $max$，枚举每一个位数，在循环中还分 $3$ 种情况：

1. 若当前这个位数已经大于最大的 $2^k$ 进制数的时候直接跳过。
2. 否则，如果 $r_0=0$ 那么这种位数的答案就是 $C_{maxvalue}^{m}$ 其中 $maxvalue$ 代表 $2^k$ 进制下的最大数，而 $m$ 代表当前的位数。
3. 否则，我们就从 $1$ 开始枚举到 $2^{r_0}-1$，计算从剩下的数中选取 $m-1$ 个数的组合数之和（这里的 $m$ 代表当前位数）。

最后的答案就是这所有的位数的答案的和了！

**代码：**


```python
import math
k,w=map(int,input().split())
r0 = w%k
m_max = w // k + (1 if r0 != 0 else 0)
if m_max < 2:
    print(0)
else:
    max_val = (1 << k) - 1
    total = 0
    for m in range(2, m_max + 1):
        if m > max_val:
            continue
        if m < m_max or (m == m_max and r0 == 0):
            total += math.comb(max_val, m)
        else:
            max_high = (1 << r0) - 1
            for i in range(1, max_high + 1):
                ni = max_val - i
                mi = m - 1
                if ni >= mi:
                    total += math.comb(ni, mi)
    print(total)
```

---

## 作者：lovely_aris (赞：2)

# 递推：

简要说明：因为是 $2^k$ 进制数，且 $w$ 为 $01$ 串，所以长度就为 $\frac{w}{k}$ 位，每位的最大值就是 $2^k-1$ ，当 $w$ 无法整除 $k$ 时，对于最高位的数字最大值就是 $2^{w\bmod k}-1 $ 。

## 递推思路
对于每新填下一位数字，要求比前面填的数字更小。所以对于第 $i$ 位数我们将要填数字 $j$ ，则答案为上一位的首位数字比自己大的数的答案之和，即
$$f_{i,j}=\sum_{h=j+1}^{2^k-1} f_{i-1,h}$$
，因为基于递推，所以保证每一位都比上一位小。最终答案就是所有 $f_{i,j}$ 的和。


------------

## 优化思路
根据递推及数据范围得出时间复杂度约为 $O(\frac{2^{2k}w}{k})$ ，明显是超时的。  
可以**优化**，使**时间复杂度**降为 $O(\frac{2^kw}{k})$ ，我们关注到递推公式中的 $h$ ，它是从尾向 $j$ 依次求和，而 $j$ 又是与本层无关，所以我们更改$j$的枚举顺序，从 $2^k-1$ 向前枚举，以此可以顺便处理从后向前的前缀和，为下一层做准备。真实的情况可能达不到这个时间复杂度，所以这样就可以通过时间限制了。  

**空间复杂度**为 $O(\frac{L2^kw}{k})$ ， $L$ 为高进度长度。所以本题解进行了滚动前缀和数组数组和高精度压位来优化空间复杂度，**优化过后**的空间复杂度则降为 $O(L2^k)$ 。


------------
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int in(){
	int ans=0,f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) ans=ans*10+c-'0';
	return ans*f;
}

const int mod=10000,Len=4;
struct F{//压位高精度 
	int p[22],l;
	F(){
		memset(p,0,sizeof(p));
		l=0;
	}
	void print(){
		printf("%d",p[l]);
		for(int i=l-1;i>=1;i--){
			if(p[i]==0){
				for(int i=1;i<=Len;i++) putchar('0');
			}
			else{
				for(int k=10;k*p[i]<mod;k*=10) printf("0");
				printf("%d",p[i]);
			}
		}
	}
};
F operator +(const F&a,const F&b){
	F c;c.l=max(a.l,b.l);
	for(int i=1;i<=c.l;i++){
		c.p[i]+=a.p[i]+b.p[i];
		c.p[i+1]+=c.p[i]/mod;
		c.p[i]%=mod;
		if(c.p[c.l+1]) c.l++;
	}
	return c;
}
int k,w;
int tail,l;
F f[30010],sum[30010],pre[30010],ans;
int main(){
	k=in();w=in();
	l=w/k+1;
	tail=w%k;
	if(tail==0) tail=k,l--;
	tail=(1<<tail)-1;//tail为最高位的上限大小  l为2^k的数位
	for(int i=(1<<k)-1;i>=0;i--){
		f[i].l=1;f[i].p[1]=1;
		sum[i]=sum[i+1]+f[i];
	}//预处理第一位 
	for(int i=2;i<=l;i++){
		for(int j=(1<<k)-1;j>=1;j--){//从高位枚举 
			if(i==l&&j>tail) continue;//特判最高位 
			f[j]=sum[j+1];
			ans=ans+f[j]; 
			pre[j]=pre[j+1]+f[j];
		}
		for(int j=(1<<k)-1;j>=1;j--) sum[j]=pre[j];//滚动前缀和数组 
	}
	ans.print();
	return 0;
}
```

---

## 作者：GoldenPotato137 (赞：2)

蒟蒻博客：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9601826.html)


------------
## Solution
这是一道神奇的题目，我们有两种方法来处理这个问题，一种是DP，一种是组合数。

**这题需要高精度，以下省略此声明
**

.


如果你对数学不感兴趣/喜欢写DP/~~(不想虐待自己)~~，这里是DP做法。

首先，我们可以发现，**这个数最多有w/k位(向上取整)**,如下图所示：
![QAQ](https://cdn.luogu.com.cn/upload/pic/32453.png)
那么，我们就可以以这个特性做DP啦。


**设f[i][j]表示枚举到第i位(指2^k进制下的)，最后一位数为j。
**
$$ f[i][j] = ∑ f[i-1][k] ((j==0 and k==0) or k<j)$$ 

这里的k显然是可以用前缀和优化的

**初始化 f[1][i]=1 (i=0~2^(w%k)-1)
**

当然，还有一些小细节:f[倒数第2/第1个][0]=0

答案为$∑f[w/k][i]$ 

（因为我没写过DP做法，这个做法纯口胡，如有错误请通知蒟蒻博主）


------------
那....组合数呢？

 

事实上，这题的组合数做法的确很妙，（当然也有不少细节）

假设我们枚举了第一位数，那么后面位数的方案数是可以通过组合数来计算出来的。

**因为后面的数要比第一位大，那么后面的数相当于从 [第一位数+1,2^k-1] 这个数的区间中选出x个数（x为后面的位数数量）来 （因为每一种方案都可以通过摆成升序满足题目要求）。**

**但是考虑到有可能有若干个前导零，我们还要枚举第一个位数从哪开始。
**

**因为枚举了前导零，我们枚举第一位数时应该从1开始（从0开始会有重复）
**
这样子，答案为:

![](https://cdn.luogu.com.cn/upload/pic/32454.png)

(事实上口胡起来简单，写起来还有很多细节，~~这得亲自体会然后就会感到这题的毒瘤~~)

 
.
 
 .

就酱，我们就可以切掉~~嘴巴AC~~出这道题啦(～￣▽￣)～ 


------------
## Code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct Int128
{
    static const int N=500;
    int a[N],len;
    Int128()
    {
        memset(a,0,sizeof a);
        len=0;
    }
    void Print()
    {
        for(int i=len;i>=1;i--)
            printf("%d",a[i]);
    }
    friend Int128 operator * (Int128 A,int B)
    {
        for(int i=1;i<=A.len;i++)
            A.a[i]*=B;
        bool IsFullZero=true;
        for(int i=1;i<=A.len;i++)
        {
            if(A.a[i]>=10)
            {
                A.a[i+1]+=A.a[i]/10,A.a[i]%=10;
                if(i==A.len and A.a[i+1]!=0)
                    A.len++;
            }
            if(A.a[i]!=0) IsFullZero=false;
        }
        if(IsFullZero==true) A.len=1;
        return A;
    }
    friend Int128 operator / (Int128 A,int B)
    {
        Int128 ans;
        int temp=0;
        for(int i=A.len;i>=1;i--)
        {
            temp=temp*10+A.a[i];
            if(temp>=B)
            {
                ans.a[i]=temp/B,temp=temp%B;
                ans.len=max(ans.len,i);
            }
        }
        return ans;
    }
    friend Int128 operator + (Int128 A,Int128 B)
    {
        if(A.len<B.len) swap(A,B);
        for(int i=1;i<=A.len;i++)
        {
            A.a[i]=A.a[i]+B.a[i];
            if(A.a[i]>9)
            {
                A.a[i+1]++;A.a[i]-=10;
                if(i==A.len)
                    A.len++;
            }
        }
        return A;
    }
};
const int N=1<<(9+1);
Int128 C[N];
int n,x,K,w,first,m;
int main()
{
    scanf("%d%d",&K,&w);
    
    first=1<<(w%K),x=w/K;
    if(w%K==0) 
        first=1<<K,x--;
    m=1<<K;
    
    
    Int128 ans;
    for(int j=0;j<=x-1;j++)
    {
        int tx=x-j;
        memset(C[tx].a,0,sizeof C[tx].a);
        C[tx].a[1]=1,C[tx].len=1;
        for(int i=tx+1;i<=m;i++)
        {
            memset(C[i].a,0,sizeof C[i].a);
            C[i]=(C[i-1]*i)/(i-tx);
        }
        if(j!=0) first=m;
        for(int i=1;i<m and i<first;i++)
        {
            if(m-1-i<tx) break;
            ans=ans+C[m-1-i];
        }
        //ans.Print();
        //cerr<<endl;
    }
        
    ans.Print();
    return 0;
}
```

---

## 作者：Furina_Saikou (赞：1)

# 思路

用递推就可以高效解决此题，为什么不用组合数？~~一堆高精写不炸你~~。

因为 $1$ 位的情况不符题意，所以我们从 $2$ 位的情况开始考虑，假设要求得是 $8$ 进制数，则当第一位为 $1$ 时，第二位可以选择 $2$ 到 $7$，当第一位为 $2$ 时，第二位能选择 $3$ 到 $7$，以此类推，长度为 $2$ 的数共有 $6+5+4+3+2+1$。

考虑 $3$ 位数的情况，不难发现，当第一位为 $1$ 时，可以选择的数其实就是当第二位为 $2$ 到 $7$ 的情况数之和。

对于 $2^k$ 进制数，有个性质就是转成 $2$ 进制数后原来的每一位对应转换后的 $k$ 位，所以可知 $m$ 位转换后变成 $km$ 位，所以我们要求的数最多为 $\lceil\frac w k\rceil$。并且由性质可知，能改变转换后总位数只有最高位，所以当 $k$ 不能整除 $w$ 时最高位最大为 $2^{w\bmod k}-1$。

接下来就可以递推了，设 $dp_{i,j}$ 表示长度为 $i$，以 $j$ 作为第一位的数有多少个。

根据我们找到的规律，不难推出 $dp_{i,j}=\displaystyle\sum_{k=j+1}^{n-i} dp_{i-1,k}$，其中 $n=2^k-1$，即 $2^k$ 进制数最多能取到多大。

我们还能优化，由上面的公式不难想出可以直接反向做前缀和，接着通过滚动数组将第一维压掉，注意在计算时要正着算，前缀和要反着加，最后用一个变量加上所有位数的答案即可。高精度我就不讲了。
```cpp
#include<cstdio>
#include<cstring>
#define int long long
const int N=1145,M=300,W=1000000;
struct node{
	int a[M],top;
}dp[N],ans;
int k,w,n,m,maxn;
inline int min(int x,int y){return x<y?x:y;}
inline int max(int x,int y){return x>y?x:y;}
inline void cpy(node &a,int b)
{
	a.top=0;
	memset(a.a,0,sizeof a.a);
	while(b)
	{
		a.a[++a.top]=b%W;
		b/=W;
	}
}
inline void cpy(node &a,node &b)
{
	a.top=b.top;
	memset(a.a,0,sizeof a.a);
	for(int i=1;i<=a.top;++i)a.a[i]=b.a[i];
}
inline void add(node &a,node &b)
{
	a.top=max(a.top,b.top);
	for(int i=1;i<=b.top;++i)a.a[i]+=b.a[i],a.a[i+1]+=a.a[i]/W,a.a[i]%=W;
	while(a.a[a.top+1])++a.top;
}
inline void print(node &a)
{
	if(!a.top)
	{
		printf("0");
		return;
	}
	printf("%lld",a.a[a.top]);
	for(int i=a.top-1;i;--i)printf("%06lld",a.a[i]);
}
signed main()
{
	scanf("%lld%lld",&k,&w);
	n=(1<<k)-1;
	m=w/k;
	w%k?(maxn=(1<<(w%k))-1,++m):maxn=n;
	m=min(m,n);
	if(m<=1)
	{
		printf("0");
		return 0;
	}
	for(int i=n;i;--i)
	{
		dp[i].a[1]=dp[i].top=1;
		add(dp[i],dp[i+1]);
	}
	for(int i=2,j,t;i<=m;++i)
	{
		t=min(n-i+1,(i==m?maxn:1145141919810ll));
		for(j=1;j<=t;++j)cpy(dp[j],dp[j+1]);
		for(j=t-1;j>0;--j)add(dp[j],dp[j+1]);
		add(ans,dp[1]);
	}
	print(ans);
}
```
高精真的有毒，做半天 $60$ 分，结果加上压位就过了（恼）。

---

## 作者：学无止境 (赞：1)

好像大家都是组合数学推式子啊...


我的方法是 $dp$ / 记忆化搜索    ~~(爱怎么叫怎么叫吧)~~

想法很简单，对于一个 $2^k$ 进制数，令最高位为第一位，以此类推...令$f[ i ][ j ]$ 表示第 $i$ 位取了 $j$ 之后 ，**其后的部分**的方案数。

显然枚举下一位的取值求和就可以得到 $f[i][j]$的值了

>  $(1)$ 如果$j$不为$0$ , 那么$f[i][j]={\sum_{j+1≤r≤2^k-1}}(f[i+1][r])$

>	$(2)$ 否则 $f[i][j]={\sum_{j≤r≤2^k-1}}(f[i+1][r])$

>  $(3)$上面的讨论并不完整，还需要简单特判来满足题目中的第一个要求(详见代码)

这里为了方便我使用了记忆化搜索来进行状态转移，其实用循环也是一样的。

现在来讨论该算法的时空复杂度：


 $n≤30000$ ，$2^k ≤256$ ，建立一个$30000×256$ 的数组空间绰绰有余，但是数组里面的数都是高精度数，这样的话空间还足够吗？结论是：足够(本人高精压了 $16$ 位$QwQ$)。

事实上数组的第一维与第二维其实无法同时取到最大 , 事实上最多只有$\frac{n}{k}×2^k$ 个状态 。

每一个状态最多计算一次，计算每一个状态的时间复杂度为$O(2^k)$

理论上时间复杂度是$O(\frac{n}{k}×2^{2k})$  但是计算每一个状态的时间普遍小于上界，同时有许多状态没有被访问到，因此可以通过本题。  

(我不怎么擅长复杂度分析，如果有问题烦请指正)

Code:

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<cstdlib>
using namespace std;

#define base (10000000000000000ll)
//压位高精 压了16位
struct hp
{
    long long a[20];
    bool vis;
    hp refer(int x)//将x赋值给高精度数
    {
        memset(a,0,sizeof(a));
        a[0]=1,a[1]=x;
        return *this;
    }
    hp operator+(hp q)//加法; 不要忘了处理vis标记
    {
        hp x;
        x.refer(0);
        x.vis=(vis||q.vis);
        x.a[0]=max(a[0],q.a[0]);
        for(register int i=1;i<=x.a[0];i++)
        {
            if(a[i]+q.a[i]+x.a[i]>=base)
                x.a[i+1]++,x.a[i]=a[i]+q.a[i]+x.a[i]-base;
            else
                x.a[i]=a[i]+q.a[i]+x.a[i];
        }
        if(x.a[x.a[0]+1])
            x.a[0]++;
        return x;
    }
    void print()//输出结果
    {
        printf("%lld",a[a[0]]);
        for(register int i=a[0]-1;i;i--)
            printf("%016lld",a[i]);
        cout<<endl;
    }

}f[30010][256],ans;

int k,w,n,r;

hp dp(int r,int v)//记忆化搜索
{
    if(f[r][v].vis)
        return f[r][v];
    f[r][v].vis=true;
    if(v==0&&r>=n-1)//题目中的第一个要求:至少两位
        return f[r][v].refer(0);
    if(r==n)//边界
        return f[r][v].refer(1);
    hp tmp;
    tmp.refer(0),tmp.vis=true;
    int bound=(1<<k)-n+r;
    //状态转移
    if(v==0)
        tmp=tmp+dp(r+1,0);
    for(register int i=v+1;i<=bound;i++)
        tmp=tmp+dp(r+1,i);
    return f[r][v]=tmp;
}


int main()
{
    scanf("%d%d",&k,&w);
    r=w%k,n=w/k+(r!=0),r=(!r)?k:r;//r 表示首位所能取的位数; n表示总位数
    for(register int i=1;i<=n;i++)//f 的初始化;  vis表示是否已经被访问
        for(register int j=0;j<(1<<k);j++)
            f[i][j].refer(0),f[i][j].vis=false;
    ans.refer(0);
    for(register int i=0;i<(1<<r);i++)
        ans=ans+dp(1,i);
    ans.print();
    return 0;
}
```


---


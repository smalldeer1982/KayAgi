# [CSP-J2022 山东] 吟诗

## 题目背景

受疫情影响，山东省取消了 CSP-J 2022 认证活动，并于次年三月重新命题，在省内补办比赛。

## 题目描述

"文章本天成，妙手偶得之。"

吟诗是表达情怀的常用手段，战争落下了帷幕，常年的军旅生活使得小虾米喜欢上了豪放派的诗歌。

这一天，小虾米突然想吟诗了。著名的豪放派诗人苏轼有“老夫聊发少年狂，左牵黄，右擎苍。”的豪放，又有“十年生死两茫茫，不思量，自难忘。”的悲怆。小虾米心向往之，于是也想用《江城子》词牌名作诗。

小虾米想作出能流传千古的诗，根据经验，如果一首诗存在妙手就能流传千古。

具体来说，一首 N 个字的诗，每个字可以用 **$1$ 到 $10$** 之间的某个正整数来表示。同时存在三个正整数 $X,Y,Z\left(1\le X\le7,1\le Y\le5,1\le Z\le5\right)$，如果诗中出现了三个连续的片段使得第一个片段之和为 $X$，第二个片段之和为 $Y$，第三个片段之和为 $Z$，则小虾米认为这首诗出现了**妙手**。

即长度为 $n$ 的序列 $a_{1},a_{2},\dots a_{n} \left(1\le a_{i}\le10\right)$，如果存在 $i,j,k,l\left(1\le i<j<k<l\le n\right)$ 使得$a_{i}+a_{i+1}+\dots a_{j-1}=X$ 且 $a_{j}+a_{j+1}+\dots a_{k-1}=Y$ 且 $a_{k}+a_{k+1}+\dots a_{l-1}=Z$ 同时成立，则认为序列出现了妙手（注：第二个片段紧接第一个片段，第三个片段紧接第二个片段）。

举例来说，如果 $N=7$，$X=7$，$Y=3$，$Z=3$，则所有长度为 $7$ 的序列中，很显然共有 $10^{7}$ 种序列，其中一种序列 $\left[1,5,2,2,1,3,4\right]$ 出现了**妙手**，因为**存在**三个连续的区间 $\left[2,3\right]$、$\left[4,5\right]$、$\left[6,6\right]$ 满足它们的和分别为 $X=7$，$Y=3$，$Z=3$。

小虾米想知道在给定 $N,X,Y,Z$ 的前提下（共计 $10^{n}$ 种序列，即共 $10^{n}$ 种诗），计算有多少种存在妙手的诗，请你帮他计算出答案。

由于答案可能很大，请你将结果对 **$998244353$** 取模。

## 说明/提示

### 样例一说明
在所有可能的序列中，只能构造出一种序列 $\left[2,3,3\right]$ 满足题意，因此答案为 $1$。
### 数据范围
对于 $30\%$ 的数据，$3\le N\le5$；

对于 $60\%$ 的数据，$3\le N\le20$；

对于 $100\%$ 的数据，$3\le N\le40,1\le X\le7,1\le Y\le5,1\le Z\le5$。

## 样例 #1

### 输入

```
3 2 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
4 7 5 5```

### 输出

```
34```

## 样例 #3

### 输入

```
23 7 3 5```

### 输出

```
824896638```

# 题解

## 作者：WorldMachine (赞：10)

怎么还搬 [ARC 原题](https://www.luogu.com.cn/problem/AT_arc058_c)啊？泪目了。

直接做容易算重，考虑正难则反，求有多少个序列没有妙手。

$X,Y,Z$ 都非常小，考虑状压，$f_{n,S}$ 表示前 $n$ 个数，$x\in S$ 表示存在一个后缀和为 $x$。

妙手代表的状态即为 $\{z,y+z,x+y+z\}$，不向包含这个状态的 $S$ 转移即可，复杂度为 $\mathcal O(nV2^{X+Y+Z})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int p = 998244353;
int n, m, x, y, z, e, ans = 1, f[41][1 << 17];
int main() {
	cin >> n >> x >> y >> z, m = (1 << (x + y + z)) - 1, e = (1 << (z - 1)) | (1 << (y + z - 1)) | (1 << (x + y + z - 1));
	f[0][0] = 1;
	for (int i = 1; i <= n; i++, ans = ans * 10ll % p) {
		for (int j = 0; j <= m; j++) {
			for (int k = 1; k <= 10; k++) {
				int s = ((j << k) | (1 << (k - 1))) & m;
				if ((s | e) != s) f[i][s] = (f[i][s] + f[i - 1][j]) % p;
			}
		}
	}
	for (int i = 0; i <= m; i++) ans = (ans + p - f[n][i]) % p;
	cout << ans << '\n';
}
```

---

## 作者：JoyLosingK (赞：7)

很妙的一题。

首先直接统计答案是困难的，正难则反，我们不如从问题的另一面去看：有多少种序列不满足题目给的条件。

发现 $x+y+z\le17$，于是考虑状压 dp。

具体地，设 $f_{i,s}$ 表示前 $i$ 个数，后缀和集合为 $s$ 时的方案数。

转移时枚举我们要往这个序列**末尾**添加的数 $k$，由于是添加到末尾，所以上一个状态的后缀都会加上 $k$，当然不要忘了 $k$ 也是新状态的一个后缀。

请注意，当我们的状态****满足题目条件****时（即同时有 $z,y+z,x+y+z$ 的后缀时）要把它设成 $0$。

具体细节可以看看代码，注意要开 long long。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const ll N = 50, mod = 1e9 + 7;
ll n, x, y, z, f[N][1 << 17], ans;
inline ll read() {
	ll x = 0, f = 1;
	char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * f;
}
int main() {
	f[0][0] = 1;
	n = read(), x = read(), y = read(), z = read();
	for (ll i = 1; i <= n; i++)
		for (ll s = 0; s < (1 << x + y + z); s++)
			for (ll k = 1; k <= 10; k++) {
				ll nxt = ((s << k) | (1 << (k - 1))) & ((1 << x + y + z) - 1);
				if (nxt & (1 << z - 1) && nxt & (1 << z + y - 1) 
					&& nxt & (1 << z + y + x - 1))
					continue;
				f[i][nxt] = (f[i][nxt] + f[i - 1][s]) % mod;
			}
	ans = 1;
	for (ll i = 1; i <= n; i++) ans = ans * 10 % mod;
	for (ll s = 0; s < (1 << x + y + z); s++) ans = (ans - f[n][s] + mod) % mod;
	cout << ans;
	return 0;
}
}
```

本题还有个双倍经验 [ARC058E](https://www.luogu.com.cn/problem/AT_arc058_c)，将模数改一改就行了。

希望能对大家有所帮助！

---

## 作者：Folden_xiaoming (赞：6)

# 前言

这道题题解区都写的比较复杂，我这篇应该比较适合入门者阅读。

首先，我们可以知道，直接统计答案是不可行的，我们可以算出所有不符合题意的答案，再用总数减去它就可以了。

注意到数据范围极小，考虑状压 dp。

# 动态规划定义

设 $dp_{i,j}$ 表示前 $i$ 个数，状态为 $j$ 时**不合法**的方案数。

有读者可能就要问了：那么 $j$ 是什么意思呢？

**$j$ 从右往左的第 $k$ 位（从第一位开始）为 $1$ 就表示序列中存在一个连续片段（从一个数到数列末尾）的和等于 $k$。**

好问题，我们拿样例二举一个例子来讲：

假设现在的原数列是：

|7|6|9|4|
|:-:|:-:|:-:|:-:|

该数列的[**后缀和数组**](https://www.cnblogs.com/Thin-time/p/18897189)就是：

|26|19|13|4|
|:-:|:-:|:-:|:-:|

那么此时的状态就是：

$j=10000001000001000000001000_{(2)}$

根据 $j$ 的定义，我们只需要保留后17位：

$j=1000000001000_{(2)}$

# 转移方程


$dp_{i,j}=\sum\limits_{t为可以推到状态j的状态} dp_{i-1,t}$

我们通过在现在的数列后面一位枚举 $1$~$10$ 来实现状态转移。

可能不太容易理解，所以我们先看代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int n,x,y,z,dp[41][1<<18],maxs/*状态的上限*/,to,ans;
int qpow(int a,int b){//快速幂，这里主要用到它的取模，直接用o(n)的幂运算也不会tle的
    int ret=1; 
    while(b>0){
        if(b&1)ret*=a,ret%=mod;
        a*=a,a%=mod,b>>=1; 
    }
    return ret%mod;
}
signed main(){
    cin>>n>>x>>y>>z;
    maxs=1<<(x+y+z);//最大状态
    dp[0][0]=1;//初始化：在考虑前0个数状态为0时有一种方案，显然不合法
    for(int i=0;i<n;i++){
        for(int s=0;s<maxs;s++){
            //if(dp[i][s]==0)continue;//小优化可写可不写
            for(int d=1;d<=10;d++){
                to=((s<<d)+(1<<(d-1)))&(maxs-1);//位运算比较抽象，就是在to的每一部分上面加上d，在to后面也加上d
                if((to&(1<<(z-1)))&&(to&(1<<(y+z-1)))&&(to&(1<<(x+y+z-1))))continue;//如果合法就不算了
                dp[i+1][to]=(dp[i+1][to]+dp[i][s])%mod;//加法原理
            }
        }
    }
    ans=qpow(10,n);//总方案数
    for(int s=0;s<maxs;s++)ans=(ans-dp[n][s]+mod)%mod;//扣掉，注意是模意义下的减法，加上一个mod防止变成负数
    cout<<ans%mod;
    return 0;
}
```
# 代码分析
前面的我们都跳过，从 for 循环开始看：
```cpp
for(int i=0;i<n;i++){
        for(int s=0;s<maxs;s++){
```
二重循环枚举 dp 数组的二维。


```cpp
for(int d=1;d<=10;d++){
```
枚举在已知数列后面添加的数。
## 位运算
位运算比较抽象，我们拆开来看：
### 第一行（唯一重点！）
```cpp
to=((s<<d)+(1<<(d-1)))&(maxs-1);
```
变量 $to$ 为目前状态可以转移到的下一个状态。

再举一个例子：

$n=5,x=12,y=2,z=3$

|原数组|9|3|7|5||
|:-:|:-:|:-:|:-:|:-:|:-:|
|后缀数组|24|15|12|5||

$s=100000000100100000010000_{(2)}$

$s=100100000010000_{(2)}$

假设 $d$ 枚举到了$4$：
|原数组|9|3|7|5|4|
|:-:|:-:|:-:|:-:|:-:|:-:|
|后缀数组|28|19|16|9|4|

$t=1000000100001000$

过程：

$s<<d=1000000001001000000100000000_{(2)}$

$1<<(d-1)=1000_{(2)}$

$(s<<d)+(1<<(d-1))=1000000001001000000100001000_{(2)}$

此时设 $maxs$ 为 $2^{17}=100000000000000000_{(2)}$

$maxs-1=1111111111111111_{(2)}$

$to=((s<<d)+(1<<(d-1)))\&(maxs-1)=1000000100001000_{(2)}$

### 第二行
```cpp
if((to&(1<<(z-1)))&&(to&(1<<(y+z-1)))&&(to&(1<<(x+y+z-1))))continue;
```
判断 $to$ 是否合法（后缀数组中含有 $z$ 和 $y+z$ 和 $x+y+z$），合法就舍去。

这句比较显然，就不举例子了，读者可以自己在草稿纸上模拟一下。

### 第三行
```cpp
dp[i+1][to]=(dp[i+1][to]+dp[i][s])%mod;
```
就是转移方程在代码中的体现，不解释了。

## 输出
```cpp
ans=qpow(10,n);
for(int s=0;s<maxs;s++)ans=(ans-dp[n][s]+mod)%mod;
cout<<ans%mod;
```
按照计划行事：从所有方案中把不合法的删去，得到答案。
# 结言

~~考场上看到状压 dp 赶紧跑。~~

感谢@[Folden_Hank](https://www.luogu.com.cn/user/1753059)@[junuse](https://www.luogu.com.cn/user/1808262)对我的帮助，没有他们我完成不了这篇题解。

---

## 作者：Priestess_SLG (赞：4)

直接硬嗯是困难的，因此考虑正难则反计算有多少组不合法的方案数，然后用总方案数减去之。总方案数是容易计算的，显然就是 $10^n$。

考虑 dp 计算出不合法方案数。看到 $x+y+z\le 17$ 想到状压。设 $f_{i,j}$ 表示当前考虑了前 $i$ 个数，以第 $i$ 个数为结尾的所有后缀可以表示出的值的状态为 $j$ 不合法组数的方案数。这样做的正确性在于合法状态不能在后缀部分添加一段数使得其再次变得不合法。

直接做第二维很爆炸，但是 $x+y+z\le 17$ 因此只需要记录 $17$ 以内的数是否可以存储出即可。此时状态的空间复杂度正确。考虑转移。

对于一个状态 $f_{i-1,j}$，考虑枚举 $a_i=k$，那么 $j$ 集合内所有可以表示的元素的值都会增加 $k$，只需要把 $j$ 整体左移 $k$ 位，然后单独添加出只包含 $i$ 元素的后缀和 $k$ 即可。设这个状态为 $S$，则转移即为：$f_{i,S}\leftarrow f_{i-1,j}$。

答案计算就是 $10^n-\sum\limits_jf_{n,j}$，这个部分比较显然。总时间复杂度为 $O(n2^{x+y+z}\omega)$，其中 $\omega$ 为 $a$ 序列中元素的值域即 $10$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 500010;
const int mod = 998244353;
int f[44][1 << 18];
inline void add(int &x, int v) {
    x = (x + v) % mod;
}
signed main() {
    int n, x, y, z;
    cin >> n >> x >> y >> z;
    f[0][0] = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j < (1 << (x + y + z)); ++j)
            for (int k = 1; k <= 10; ++k) {
                int state = ((j << k) | (1 << (k - 1))) & ((1 << (x + y + z)) - 1);
                if ((~state >> (z - 1) & 1) || (~state >> (y + z - 1) & 1) || (~state >> (x + y + z - 1) & 1)) add(f[i][state], f[i - 1][j]);
            }
    int cnt = 1;
    for (int i = 0; i < n; ++i) cnt = cnt * 10 % mod;
    for (int i = 0; i < (1 << (x + y + z)); ++i) cnt = (cnt + mod - f[n][i]) % mod;
    cout << cnt << '\n';
    return 0;
}
```

---

## 作者：Felix72 (赞：3)

ARC058 的橙题都搬？

一种方法是枚举所有对答案有贡献的串，建 ACAM，在自动机上 DP 出有存在合法串的数量；

另一种方法是考虑 $X + Y + Z$ 很小的性质，把他们压缩成二进制表示，比如三元组 $(1, 4, 3)$ 压缩成 $11000100$。选一种状态压缩的方法，然后 DP 即可。

实现是前一种方法。

```cpp
// LUOGU_RID: 163963788
#include <bits/stdc++.h>
#define lowbit(x) (x & (-x))
using namespace std;

const int N = 45, M = 100010, mod = 998244353;
int n, a[4], sta[N];

int idx = 1, son[M][11], fail[M];
bool ok[M], vis[M]; queue < int > q;
long long f[N][M], pw[N], ans; int trans[M][15];
inline void insert(int len)
{
//	for(int i = 1; i <= len; ++i) cerr << sta[i] << " ";
//	cerr << '\n';
	int pos = 1;
	for(int i = 1; i <= len; ++i)
	{
		if(!son[pos][sta[i]]) son[pos][sta[i]] = ++idx;
		pos = son[pos][sta[i]];
	}
	ok[pos] = true;
}
inline void init()
{
	q.push(1);
	while(!q.empty())
	{
		int now = q.front(); q.pop();
		for(int i = 1; i <= 10; ++i)
		{
			if(!son[now][i]) continue;
			int to = son[now][i]; q.push(to);
			int pos = fail[now];
			while(pos && !son[pos][i]) pos = fail[pos];
			if(pos == 0) fail[to] = 1;
			else fail[to] = son[pos][i];
			if(ok[fail[to]]) ok[to] = true;
		}
	}
	for(int i = 1; i <= idx; ++i)
	{
		for(int j = 1; j <= 10; ++j)
		{
			int pos = i;
			while(pos && !son[pos][j]) pos = fail[pos];
			pos = son[pos][j];
			if(!pos) pos = 1;
			trans[i][j] = pos;
		}
	}
}

inline void dfs(int id, int now, int cnt)
{
	if(id == 4)
	{
		insert(cnt);
		return ;
	}
	for(int i = a[id] - now; i >= 1; --i)
	{
		sta[cnt + 1] = i;
		if(now + i == a[id]) dfs(id + 1, 0, cnt + 1);
		else dfs(id, now + i, cnt + 1);
	}
}

int main()
{
//	freopen("text.in", "r", stdin);
//	freopen("prog.out", "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= 3; ++i) cin >> a[i];
	dfs(1, 0, 0); init();
	
	pw[0] = 1; for(int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * 10 % mod;
	f[0][1] = 1;
	for(int i = 0; i < n; ++i)
	{
		for(int j = 1; j <= idx; ++j)
		{
			if(ok[j]) continue;
			for(int nxt = 1; nxt <= 10; ++nxt)
			{
				f[i + 1][trans[j][nxt]] += f[i][j];
				f[i + 1][trans[j][nxt]] %= mod;
			}
		}
	}
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= idx; ++j)
			if(ok[j])
				ans = (ans + f[i][j] * pw[n - i] % mod) % mod;
	cout << ans << '\n';
	return 0;
}
/*

*/
```

---

## 作者：RAYMOND_7 (赞：3)

重题：[ARC058E](https://atcoder.jp/contests/arc058/tasks/arc058_c)

容斥，计数不合法方案数。

考虑如果一个子段满足总和为 $X+Y+Z$ 且存在前缀和为 $X+Y$ 和 $X$，那么显然是合法的。

对于所有这样子段暴力枚举出来建立 $AC$ 自动机，发现 $X=7,Y=5,Z=5$ 只有 $33856$ 个节点。

直接压入状态跑 DP 即可。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <iostream>
#include <vector>
#include <queue>
#include <cassert>
#include <ctime>

using namespace std;

#define int long long
#define PII pair<int,int>
#define x first
#define y second
#define For(i, l, r) for(int i = l; i <= r; i ++)
#define Rep(i, l, r) for(int i = l; i >= r; i --)

bool START;

void in(int &x)
{
	char c = getchar(); int op = 1;
	while(c > '9' || c < '0') op *= (c == '-' ? -1 : 1), c = getchar();
	for(x = 0; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - '0'; x *= op;
}

const int N=45,M=50010,P=998244353;

int n,m,X,Y,Z,tot=1;
int t[M][11],nxt[M],flag[M],f[M],g[M];
int a[N];

void dfs(int k)
{
	if(k>X+Y+Z)
	{
		if(!a[X]||!a[X+Y]||!a[X+Y+Z])return ;
		int lst=0,x=1;
		For(i,1,X+Y+Z)if(a[i])
		{
			int c=i-lst;
			if(!t[x][c])t[x][c]=++tot;
			x=t[x][c];
			lst=i;
		}
		flag[x]=1;
		return ;
	}
	a[k]=1;dfs(k+1);a[k]=0;dfs(k+1);
}
int q[M],hh,tt;

void build()
{
	hh=1;tt=0;nxt[1]=1; For(i,1,10)if(!t[1][i])t[1][i]=1;
	else q[++tt]=t[1][i],nxt[t[1][i]]=1;
	while(hh<=tt)
	{
		int u=q[hh++];
		For(i,1,10)if(!t[u][i])t[u][i]=t[nxt[u]][i];
		else q[++tt]=t[u][i],nxt[t[u][i]]=t[nxt[u]][i];
	}
}

bool ENDPOS = 0;
signed main()
{
	double chu = clock();
	in(n);in(X);in(Y);in(Z);
	dfs(1);
	build();
	f[1]=1;
	For(i,1,n)
	{
		For(u,1,tot)g[u]=f[u],f[u]=0;
		For(u,1,tot)if(g[u])
		{
			For(c,1,10)if(!flag[t[u][c]])
			{
				(f[t[u][c]]+=g[u])%=P;
			}
		}
	}
	int ans=1;
	For(i,1,n)ans=ans*10%P;
	For(u,1,tot)ans=(ans+P-f[u])%P;
	printf("%lld\n", ans);
	cerr << "Time = " << (clock() - chu) / CLOCKS_PER_SEC << endl;
	cerr << (&ENDPOS - &START) * 1.0 / 1024 / 1024 << endl; return 0;
}

```

---

## 作者：Genius_Star (赞：3)

### 思路：

注意到 $X + Y + Z \le 17$，故考虑状压，定义 $dp_{i, S}$ 表示考虑前 $i$ 位，若 $S$ 的第 $i$ 位为 $1$ 代表存在一个后缀和为 $i + 1$。

转移的时候枚举新加的数 $j$，那么有：

$$nxt = (S 2^j + 2^{j - 1}) \& U$$

$$dp_{i, nxt} \gets dp_{i, nxt} + dp_{i - 1, S}$$

时间复杂度为 $O(WN2^{X + Y + Z})$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 41, M = 1 << 18, mod = 998244353; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, x, y, z, U, ans = 1;
int dp[N][M];
bool check(int S) {
	if (!((S >> (z - 1)) & 1))
	  return 1; 
	if (!((S >>(y + z - 1)) & 1))
	  return 1; 
	if (!((S >> (x + y + z - 1)) & 1))
	  return 1; 
	return 0; 
}
bool End;
int main(){
	n = read(), x = read(), y = read(), z = read();
	U = (1 << (x + y + z)) - 1;
	dp[0][0] = 1;
	for(int i = 1; i <= n; ++i){
		ans = 10ll * ans % mod;
		for(int S = 0; S <= U; ++S){
			for(int j = 1; j <= 10; ++j){
				int nxt = ((S << j) + (1 << (j - 1))) & U;
				if(check(nxt))
				  dp[i][nxt] = (dp[i][nxt] + dp[i - 1][S]) % mod;
			}
		}
	}
	for(int i = 0; i <= U; ++i)
	  ans = (ans - dp[n][i] + mod) % mod;
	write(ans);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：yyyx_ (赞：2)

考虑一个以片段 $Z$ 为结尾的诗，它出现妙手当且仅当有后缀 $Y+Z$ 与后缀 $X+Y+Z$。

这样很明显了，可以状压维护后缀。

但是这样很难去重：形如 $X+Y+Z+K$ 的诗可能也存在 $X+Y+Z$ 后缀，这样同一首诗会被统计多次。

正难则反，令 $f_{i,S}$ 表示长度为 $i$，有 $S$ 中的后缀的无妙手诗数量，当 $S'$ 不存在同时存在后缀 $Z$、$Y+Z$ 和 $X+Y+Z$ 时转移，这样可以直接 dp。

最终答案为 $10^n - \sum f_{n,S}$。

注意位运算优先级。

附代码。


```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename T>
inline void read(T &x)
{
    x = 0;
    register char c = getchar();
    register short f = 1;
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    x *= f;
}

template <typename T, typename... Args>
inline void read(T &x, Args &...temps)
{
    read(x), read(temps...);
}

const int N = 42;
const int mod = 998244353;
typedef long long ll;

int n, m, x, y, z;
ll ans, f[N][1 << 17];

signed main()
{
    read(n, x, y, z);
    m = x + y + z;
    int t = (1 << m - 1) | (1 << y + z - 1) | (1 << z - 1);
    f[0][0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 1 << m; j++)
            for (int k = 1; k <= 10; k++)
            {
                int s = ((j << k) | (1 << k - 1)) & ((1 << m) - 1);
                if (s & t ^ t)
                    (f[i][s] += f[i - 1][j]) %= mod;
            }
    ll ans = 1;
    for (int i = 1; i <= n; i++)
        ans = ((ans << 1) + (ans << 3)) % mod;
    for (int i = 0; i < 1 << m; i++)
        (ans += mod - f[n][i]) %= mod;
    printf("%lld\n", ans);

    return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

CSP-J 怎么出 AC 自动机啊。

把这道题类比为字符串匹配，要求找到序列中的一个子串满足第一个分界点的前缀为 $x$，第二个分界点的前缀为 $x + y$（整个子串的和必然为 $x + y + z$）。那么我们考虑枚举所有可能的子串组合作为模式串加入 AC 自动机，那么令 $f_{i, s}$ 表示前 $i$ 个数字且当前自动机状态为 $s$ 的不含模式串方案数，转移也很显然。

最终答案就是 $\displaystyle 10^n - \sum_{j}f_{n, j}$，时间复杂度 $\mathcal O(1.998^{x + y + z}\cdot n^2 + nS)$，其中 $S$ 是插入的字符数量之和，容易证明很小。

代码如下：

```cpp
#define MULTI_TEST 0

constexpr LL mod = 998244353;

struct ACAM {
    struct Node {
        bool ter;
        int fail, nxt[11];
        Node() : ter(false), fail(0) {
            for (int i = 0; i < 11; ++i)
                nxt[i] = -1;
        }
    };
    std::vector<Node> c;
    void insert(const VI& p) {
        int cur = 0;
        for (auto& d : p) {
            if (c[cur].nxt[d] == -1) {
                c[cur].nxt[d] = c.size(), c.eb(Node());
            }
            cur = c[cur].nxt[d];
        }
        c[cur].ter = true;
    }
    void build() {
        std::queue<int> q;
        for (int d = 1; d <= 10; ++d) {
            if (c[0].nxt[d] == -1)
                c[0].nxt[d] = 0;
            else {
                c[c[0].nxt[d]].fail = 0;
                q.push(c[0].nxt[d]);
            }
        }
        while (!q.empty()) {
            int x = q.front();
            q.pop();
            c[x].ter |= c[c[x].fail].ter;
            for (int d = 1; d <= 10; ++d) {
                int y = c[x].nxt[d];
                if (y != -1) {
                    c[y].fail = c[c[x].fail].nxt[d];
                    q.push(y);
                }
                else {
                    c[x].nxt[d] = c[c[x].fail].nxt[d];
                }
            }
        }
    }
};

int main() {
#if MULTI_TEST == 1
    LL T;
    std::cin >> T;
    while (T--) {
        // Test cases...
    }
#else
    int n, x, y, z, t;
    std::cin >> n >> x >> y >> z;
    t = x + y + z;
    ACAM ac;
    VI cur;
    int cnt = 0;
    auto Add = [&](auto&& self, int r) -> void {
        if (r == t) {
            ++cnt;
            if ((int)cur.size() > 2) {
                int n = cur.size(), s = 0;
                bool ok = false;
                for (int i = 0; i < n; ++i) {
                    if ((s += cur[i]) == x) {
                        int s1 = s;
                        for (int j = i + 1; j < n; ++j) {
                            if ((s1 += cur[j]) == x + y) {
                                if (j < n) ok = true;
                                break;
                            }
                            if (s1 > x + y) break;
                        }
                        if (ok) break;
                    }
                    if (s > x) break;
                }
                if (ok) ac.insert(cur);
            }
            return;
        }
        for (int d = 1; d <= 10; ++d) {
            if (r + d <= t) {
                cur.eb(d), self(self, r + d);
                cur.pop_back();
            }
        }
        };
    ac.c.clear();
    ac.c.push_back(ACAM::Node());
    Add(Add, 0);
    ac.build();
    int s = ac.c.size();
    std::vector<VLL> f(n + 1, VLL(s, 0));
    f[0][0] = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < s; ++j) {
            if (f[i][j] == 0) continue;
            for (int d = 1; d <= 10; ++d) {
                if (ac.c[ac.c[j].nxt[d]].ter) continue;
                f[i + 1][ac.c[j].nxt[d]] += f[i][j];
                f[i + 1][ac.c[j].nxt[d]] %= mod;
            }
        }
    }
    LL ans = 1;
    for (int i = 1; i <= n; ++i) ans = ans * 10 % mod;
    for (int j = 0; j < s; ++j)
        ans -= f[n][j], ans += mod, ans %= mod;
    std::cout << (ans + mod) % mod << "\n";
#endif
    return 0;
}
```

喜提目前最优解。

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18960888)

“存在妙手”这个限制不好计数，因为可能会重复计一个妙手，且总方案数与不含妙手的方案数统计是较为容易的，所以考虑**容斥**，统计不含妙手的方案数。

考虑怎么刻画“分段和”的限制，显然我们可以利用**前缀和的思想**，如果到了第 $i$ 位，前缀和为 $s$，那么只要 $s-z,s-z-y,s-z-y-x$ 曾出现于前缀和数组中就能产生妙手。注意到 $X+Y+Z\le 17$，所以 $s-z-y-x$ 与 $s$ 的差**最多只有 $17$**，要判断存不存在，显然可以考虑把它**压成一个二进制数**。

因为前缀和只能利用差值来设计 DP 方案，不太直观，所以考虑转化为**后缀和**设计 DP：$dp_{i,j}$ 表示考虑到第 $i$ 位，此时后缀和存在性的状态为 $j$ 时的方案数，避开会形成妙手的状态进行刷表法转移即可。当新加的一位数为 $v$ 的时候，相当于 $j$ 右移 $v$ 位，并在二进制下的第 $v$ 位变成 $1$，然后大于等于 $2^{18}$ 的部分可以直接丢掉（用按位与实现）。

总方案数为 $10^n$，减掉不含妙手的方案数即为答案。

时间复杂度 $O(nV2^{X+Y+Z})$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int ALL=(1<<18)-1;
const ll mod=998244353;
ll n,x,y,z,dp[50][300005],ban,ans=1;
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>x>>y>>z;
    ban=((1<<z)|(1<<(y+z))|(1<<(x+y+z)));
    dp[0][0]=1;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<=ALL;j++)
        {
            for(int v=1;v<=10;v++)
            {
                int st=(((j<<v)|(1ll<<v))&ALL);
                if((st&ban)==ban)continue;
                dp[i+1][st]=(dp[i+1][st]+dp[i][j])%mod;
            }
        }
        ans=(ans*10)%mod;
    }
    for(int i=0;i<=ALL;i++)
        ans=((ans-dp[n][i]+mod)%mod+mod)%mod;
    cout<<ans;
    return 0;
}
```

---


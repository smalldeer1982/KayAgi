# [POI 2020/2021 R2] 棋盘 / Projekt planszy

## 题目背景

翻译来自于 [LibreOJ](https://loj.ac/p/4828)。

## 题目描述

**题目译自 [XXVIII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi28-2/dashboard/) [Projekt planszy](https://szkopul.edu.pl/problemset/problem/tFYVKjavLmyczkxMH7WFewXe/statement/)**

棋盘由 $n \cdot n$ 个格子组成，分为 $n$ 行和 $n$ 列，格子编号从 $1$ 到 $n$。第 $i$ 行第 $j$ 列的格子坐标为 $(i, j)$。你需要从左上角的格子 $(1,1)$ 走到右下角的格子 $(n, n)$。棋盘上有些格子是被封锁的，你只能在未被封锁的格子上向右或向下移动，也就是说，从格子 $(i, j)$ 可以走到 $(i, j+1)$ 或 $(i+1, j)$，前提是目标格子没有被封锁。

有的棋盘只有一种走法，有的则有多种走法。给定一个数字 $K$，请你设计一个尺寸不超过 $100$ 的棋盘，使从起点到终点的不同走法数量恰好为 $K$。

## 说明/提示

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :---: | :--: | :---: |
| $1$ | $K \leq 50$ | $15$ |
| $2$ | $K \leq 2000$ | $15$ |
| $3$ | $K \leq 10^{9}$ | $40$ |
| $4$ | $K \leq 10^{18}$ | $30$ |

## 样例 #1

### 输入

```
6```

### 输出

```
4
...#
....
##..
###.```

# 题解

## 作者：Rigel (赞：14)

有趣的构造题。

看了两位金钩大神写的进制拆分，颇受启发。

在此提供一种有点暴力但是简单易懂、具有普遍性的构造方案。

---

题目要求 $1 \leq n \leq 100$，我们直接将网格开到 $100 \times 100$。

定义 $a_{i,j}$ 表示格子 $(i,j)$ 的状态，当 $a_{i,j}=1$ 时 $(i,j)$ 被封锁，否则未被封锁。

初始时除起点与终点外的所有格子均被封锁。

---

考虑将 $K$ 条路径拆分。设 $K$（$K \leq 10^{18}$）的第 $i$ 个数位（定义个位为第 $0$ 位）的数值为 $w_i$，则：

$$K = \sum\limits_{i=0}^{18}(w_i \times 10^i).$$

例如，$1949 = 0 \times 10^{18} + \cdots + 0 \times 10^4 + 1 \times 10^3 + 9 \times 10^2 + 4 \times 10^1 + 9 \times 10^0$。

---

定义『块』为 $3 \times 4$ 的网格。

一个从左上角走至右下角有 $n$ 条合法路径的『块』被称为『$n$ 类块』。

下面给出『$0$ 类块』至『$10$ 类块』的一种构造方案。

```
#...  ....  ....  ...#  ....  ...#  ....  ....  ...#  ....  ....
....  ###.  .##.  #..#  .#..  #...  #...  ....  ....  ....  ....
....  ###.  ....  #...  ....  #...  #...  ##..  #...  #...  ....
```

容易证明，将一个『$n$ 类块』的右下角与一个『$m$ 类块』的左上角连接后，从『$n$ 类块』的左上角走至『$m$ 类块』的右下角的合法方案数为 $n \times m$。

---

开始构造。我们在图的顶部放置 $19$ 个『块』（红色），其中第 $i$ 个『块』为『$w_i$ 类块』。（$i \in [0,18]$，设最右边的为第 $0$ 个『块』，即 $K$ 的个位所对应的『块』）

在底下放置 $18$ 个『$10$ 类块』（蓝色）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ls95h4yd.png)

将这些『块』按上图方式连接。

从起点开始走，经过上面的第 $i$ 个『块』之后，还会经过 $i$ 个『$10$ 类块』，因此走到右下角的合法路径数为 $w_i \times 10^i$。

整个结构的合法路径数为每种走法的合法路径数之和，也就是 $\sum\limits_{i=0}^{18}(w_i \times 10^i) = K$。

结构的长度（横向）为 $18 \times 2 + 7 = 43$，宽度（纵向）为 $18 \times 5 + 4 = 94$，符合题目要求。

最后将结构的右下角连接至终点即可。

---

[Submission](https://www.luogu.com.cn/record/221527743)。

---

## 作者：wukaichen888 (赞：6)

目前唯一使用二进制的解，另外两篇解法拆高进制神秘缝合，感觉太反人类了。

注意到：

```txt
..###
...##
#...#
##...
###..
```

利用这种形状可以构造 $2^x$。然后试图拼拼图，发现不行。

考虑一条主线路，多次提取 $2^x$。

```txt
..##########
....########
.#....######
.#.#....####
.#.#.#....##
.#.#.#.#....
.#.#.#.#.#..
.#.#.#.#.#.#
.#.#.#.#.#.#
```

优化一下路径：

```txt
..##########
....########
.#....######
..?#....####
#?..?#....##
###?..?#....
#####?..?#..
#######?..?#
#########?..
```

斜对的问号选一个作为墙，表示该 $2^x$ 选不选。

然后你发现长炸了。

考虑用上面做法处理 $x\le30$ 累加，长大概为 $60$。

然后再开一条线路，先用最上面的做法乘 $2^{30}$，然后处理 $x\gt30$，长大概 $90$。

调一下界可以优秀很多，我懒。

举例：$k=1145141919810$ 的解，[link](https://www.luogu.com.cn/paste/e17p3yeu)。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=105;
ll n=100,w[N],k,l1,l2;
ll a[N][N],X[N],Y[N],nx=5,ny=1;
inline void ins(int x,int y){a[x][y]=1;}
inline void del(int x,int y){a[x][y]=0;}
inline void q1(int x,int y){while(y<n)a[x][++y]=1;while(x<n)a[++x][y]=1;}
inline void q2(int x,int y){while(x<n)a[++x][y]=1;while(y<n)a[x][++y]=1;}
int main(){
	ins(1,1),ins(1,2);
	ins(2,1);
	ins(3,1);
	ins(4,1);
	for(int i=0,x=1,y=3;i<30;i++,x+=1,y+=2){
		ins(x+0,y+0),ins(x+0,y+1);
		ins(x+1,y+0),ins(x+1,y+1),ins(x+1,y+2);
		ins(x+2,y+0)             ,ins(x+2,y+2);
		ins(x+3,y+0),ins(x+3,y+1),ins(x+3,y+2);
		l2++; X[l2]=x+2,Y[l2]=y;
		if(i==29) del(x+1,y+1),q1(x+3,y+2);
	}
	
	for(int i=0;i<30;i++,nx++,ny++){
		ins(nx+0,ny+0),ins(nx+0,ny+1);
		ins(nx+1,ny+0);
	}
	for(int i=0,x=nx,y=ny;i<30;i++,x+=1,y+=2){
		ins(x+0,y+0),ins(x+0,y+1);
		ins(x+1,y+0),ins(x+1,y+1),ins(x+1,y+2);
		ins(x+2,y+0)             ,ins(x+2,y+2);
		ins(x+3,y+0),ins(x+3,y+1),ins(x+3,y+2);
		l2++; X[l2]=x+2,Y[l2]=y;
		if(i==29) del(x+1,y+1),q2(x+3,y+2);
	}
	scanf("%lld",&k);
	while(k) w[++l1]=(k&1),k>>=1;
	for(int i=1;i<=l2;i++) if(!w[i]){
		del(X[i],Y[i]);
		if(i>=2) ins(X[i]+1,Y[i]-1);
	}
	printf("%d\n",n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			if(a[i][j]) printf(".");
			else printf("#");
		puts("");
	}
	return 0;
}
```

---

## 作者：gcx12012 (赞：3)

### 前言
去年 noip 模拟赛 T2 见过这个题，当时给的限制好像是 $k\le 10^9,n\le 30$，然后有一个神秘随机化做法，但是这题限制给的很松就给个正经做法。
### Solution
碰到这种题可以想一下进制拆分，这里我们考虑用若干 $3\times 3$ 的子图来表示一个六进制。

首先应该想如何表示 $0$ 到 $5$ 的数，这是简单的，以下从左到右给出方案数为 $0$ 到 $5$ 的六个子图：（这里默认可以堵住起点和终点）
```
#..  .##  ...  ...  ..#  ...
...  .##  .#.  ...  ...  ...
...  ...  ...  ##.  #..  #..
```
然后两个子图的方案数是可以相乘的，具体可以用以下形式来完成：
```
...####
...####
.......
####...
####...
```
其中中间的 `.` 连接了一个子图的右下角和另一个子图的左上角。

然后我们直接构造出一个类似右三角图即可完成六进制每一位的构造，这里给出比较小的构造：
```
.....#########
.#...#########
.#.......#####
.#####...#####
.....#.......#
.#...#####...#
.#.......#....
.#####...####.
.....#....###.
.#...####.###.
.#....###.###.
.####.###.###.
.#............
.############.
```
然后直接根据六进制拆分来决定每一斜列的子图状态，本人用了个 $98\times 98$ 的图就能构造出来。

然后这一道题就做完了，代码的构造跟上图是同一结构。
```
using namespace std;
char s[110][110];
ll n=98,m;

ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}


int main()
{ 
    //freopen("iron.in","r",stdin);
    //freopen("iron.out","w",stdout);
   	m=read();
   	For(i,1,n){
   		For(j,1,n){
   			s[i][j]='#';
   		}
   	}
   	For(i,1,n) s[i][1]='.';
   	For(i,1,24) s[4*i-3][2]='.';
   	For(i,3,98) s[97][i]='.';
   	s[98][98]='.';
   	Rof(i,23,0){
   		int x=1+(23-i)*2,y=3+(23-i)*4;
   		For(j,1,i+1){
   			For(k,0,2){
   				For(l,0,2){
   					s[x+k][y+l]='.';
   				}
   			}
   			s[x+2][y+3]='.';
   			if(j!=i+1) x+=4;
   		}
   		x+=3,y+=3;
   		while(x<97) s[x][y]='.',x++;
   	}
   	int x=93,y=3;
   	For(i,0,23){
   		int now=m%6;
   		if(now==0) s[x][y]='#';
   		else if(now==1) s[x+1][y]=s[x+1][y+1]=s[x+2][y]=s[x+2][y+1]='#';
   		else if(now==2) s[x+1][y+1]='#';
   		else if(now==3) s[x+2][y]=s[x+2][y+1]='#';
   		else if(now==4) s[x][y+2]=s[x+2][y]='#';
   		else s[x][y+2]='#';
   		m/=6;
   		x-=4;
   	}
   	cout<<n<<endl;
   	For(i,1,n){
   		For(j,1,n){
   			cout<<s[i][j];
   		}
   		cout<<endl;
   	}
    return 0;
}
```

---

## 作者：Iniaugoty (赞：3)

小清新构造题。

基本思路是，利用加法原理和乘法原理，构造出 $+$ 运算和 $\times$ 运算，然后把这个 $K$ **求**出来。

- $+$：即并联，方案数为并联的几部分之和。

- $\times$：即串联，方案数为串联的几部分之积。

不难想到二进制分解，但似乎会爆到 $120$。

那就进行十进制分解。

注意到，下图

```
....
....
....
```

即 $4 \times 3$ 全部空白，方案数恰为 $10$。

注意到，下图

```
...(省略若干个 .).
...(省略若干个 .).
```

即 $2$ 行 $n$ 列的空白，方案数恰为 $n$。

那么思路很明确。先从左上角分出来两部分，一部分造一个 $10$，一部分造一个 $K \bmod 10$，（不过当 $10 | k$ 时这一部分显然不需要），再从 $10$ 的那一部分往右下递归下去造一个 $\lfloor \frac K {10} \rfloor$，这样就得到了 $10 \lfloor \frac K {10} \rfloor + (K \bmod 10) = K$。

例如，当 $K = 345$ 时，造出这样的（行列不同是因为中间省略了几行多余的）：

```
..............
....#####.....
....#########.
###...........
###....###....
###....######.
######........
###########...
```

这样构造最多只需要 $50 + eps$ 行和 $60 + eps$ 列。

代码容易实现，有一点特判。

```cpp
#include <bits/stdc++.h>
#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int, LL> pii;

int n; LL k, f[105][105]; char s[105][105];

int main() {
  // freopen("zyq.in", "r", stdin);
  // freopen("zyq.out", "w", stdout);
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> k, n = 100;
  F(i, 1, n) F(j, 1, n) s[i][j] = '#';
  F(i, 1, n) s[i][n] = '.';
  int x = 1, y = 1;
  while (k >= 10) {
    int w = k % 10; k /= 10;
    F(i, x, x + 2) F(j, y, y + 3) s[i][j] = '.';
    if (w > 0) {
      F(j, y, n) s[x][j] = '.';
      F(j, n - w + 1, n) s[x + 1][j] = '.';
    }
    s[x + 3][y + 3] = '.', x += 3, y += 3;
  }
  if (k > 0) {
    F(i, x, n - 1) s[i][y] = '.';
    F(j, y, n) s[n - 1][j] = '.';
    F(j, n - k + 1, n) s[n][j] = '.';
  }
  cout << n << "\n";
  F(i, 1, n) {
    F(j, 1, n) cout << s[i][j];
    cout << "\n";
  }
  // F(i, 1, n) F(j, 1, n) if (s[i][j] == '.')
  //   if (i == 1 && j == 1) f[i][j] = 1;
  //   else f[i][j] = f[i - 1][j] + f[i][j - 1];
  // cout << f[n][n] << "\n";
  return 0;
}
```

---

## 作者：_hxh (赞：2)

### 分析

构造棋盘使走法数满足题意，一开始想的是类似递归的方法，每次将棋盘分成几个部分，最后将各部分方案数整合起来，但有些麻烦，最后还是另起炉灶，利用了三条特性：

1. 不相交的路的方案数是互相独立的，计算的时候总方案数为各路方案数之和；
2. 如果将一条路拆分成若干个部分且相邻两部分仅由一条路相连，则方案数为各部分方案数之积；
3. 用某种方法拆分走法数 $K$。

举个例子：

设现在 $K$ 等于 $1234$，则借助特性 $2$，猜想是否可以将棋盘分出 $4$ 条路，使得各条路的走法数依次为 $1000$，$200$，$30$，$4$。又借助特性 $3$，思考将 $1000$ 拆成 $3$ 个走法数均为 $10$ 的小图。$200$ 则可以拆成 $1$ 个走法数为 $2$ 的小图和 $2$ 个走法数为 $10$ 的小图。为了整体的统一性（更好写），在数位上的数字为 $1$ 时，应多一个走法数为 $1$ 的图。

这里小图用 $4 \times 4$ 的规格。

![](https://cdn.luogu.com.cn/upload/image_hosting/9i0j83h0.png)

空白处均为障碍，灰色均为通道，$4 \times 4$ 的红色块代表一个走法数为该数字的部分，列举几种情况：

走法数为 $1$ 的小图：

```
....
###.
###.
###.
```

走法数为 $5$ 的小图：

```
....
....
.##.
....
```

记得最后要补 $4$ 行 `#`，因为棋盘是正方形的。

粗略计算边长最大为 $90$ 左右，满足要求。

---


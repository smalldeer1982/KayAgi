# [NOI2001] 炮兵阵地

## 题目描述

司令部的将军们打算在 $N\times M$ 的网格地图上部署他们的炮兵部队。

一个 $N\times M$ 的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用 $\texttt{H}$ 表示），也可能是平原（用 $\texttt{P}$ 表示），如下图。

在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：

 ![](https://cdn.luogu.com.cn/upload/pic/1881.png) 

如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。

图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。

现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq N\le 100$，$1 \leq M\le 10$，保证字符仅包含 `P` 与 `H`。

## 样例 #1

### 输入

```
5 4
PHPP
PPHH
PPPP
PHPP
PHHP```

### 输出

```
6```

# 题解

## 作者：SSHhh (赞：295)

[使用csdn体验更佳（逃](https://blog.csdn.net/SSH_oj/article/details/81951794)

这道题是一道状压 dp 的~~特别毒瘤的~~基础题(虽然我打了整整一个早上)，但是因为每一个炮兵都会影响到之后的两行的放置，所以用状压去压两行，按行处理每一行的情况即可。每一行放置的时候也很简单，只需考虑这个位置前两行有没有放置炮兵以及这个位置是不是山丘即可。

那么首先，dp 方程可以很快推出来，dp[L][S][i]表示当前状态是 S，上一行的状态是 L，当前考虑到了第 i 行：

dp[L][S][i]=max(dp[L][S][i],dp[FL][L][i-1]+Sum[S]); 这里 FL 表示上上行的状态，Sum[S] 表示当前状态 S 里面包含几个 1。

那么有了这个 dp 方程后，就可以愉快的递推了，不过这道题有几个细节需要注意一下：

---

1.判断每个位置是不是山丘

这个很好解决，只要把每一行的输入都转成一个二进制数(平原是 0，山丘是1)，然后直接跟待判断的状态做一次位运算即可，就是 S&a[i]，如果位运算结果不是零，说明有些位置放在了山丘上，也就是说当前状态不合法。

---

2.判断每个状态有没有两个炮兵左右距离在两格之内

这个需要动脑想一下，我们发现一个神奇的结论，如果把表示当前状态的二进制数位运算左移一位，那么用这个结果与原状态做一次位运算与操作，如果结果不是 0，那么就一定存在两个炮兵左右距离在一格之内。同理，左移两位就可以判断左右距离在两格之内。这个过程也就是 S&(S<<1)，S&(S<<2)。

---

3.判断每一列之前两行有没有炮兵

这个就直接用当前状态分别与之前的两行即可，就是 S&L，S&FL，如果与操作结果不为零，说明有若干列前两行有炮兵，也就是说当前状态不合法。

---

最后说一句，一定要用滚动数组(因为只用到每一行和前两行，所以只用滚动三行)，否则会 MLE 0 (我当初就是这么惨)。。。

好了细节都说完了，下面就是具体的代码实现了：

```cpp
#include<iostream>
using namespace std;
int n,m,ans,dp[(1<<10)][(1<<10)][3]/*滚动数组*/,a[105],Sum[(1<<10)];
char x;
int getsum(int S)	//当前状态 S 里面包含几个 1
{
	int tot=0;
	while(S) {if(S&1) tot++; S>>=1;}
	return tot;
}
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
			cin>>x,a[i]<<=1,a[i]+=(x=='H'?1:0);	//转成二进制数
	for(int i=0;i<(1<<m);i++)
		Sum[i]=getsum(i);	//初始化 Sum 数组
	for(int S=0;S<(1<<m);S++)
		if(!(S&a[0] || (S&(S<<1)) || (S&(S<<2))))
			dp[0][S][0]=Sum[S];	//初始化
	for(int L=0;L<(1<<m);L++)
		for(int S=0;S<(1<<m);S++)
			if(!(L&S || L&a[0] || S&a[1] || (L&(L<<1)) || (L&(L<<2)) || (S&(S<<1)) || (S&(S<<2))))	//谜之一长串特判
				dp[L][S][1]=Sum[S]+Sum[L];
	for(int i=2;i<n;i++)
		for(int L=0;L<(1<<m);L++)
		{
			if(L&a[i-1] || (L&(L<<1)) || (L&(L<<2))) continue;	//特判
			for(int S=0;S<(1<<m);S++)
			{
				if(S&a[i] || L&S || (S&(S<<1)) || (S&(S<<2))) continue;
				for(int FL=0;FL<(1<<m);FL++)
				{
					if(FL&L || FL&S || FL&a[i-2] || (FL&(FL<<1)) || (FL&(FL<<2)))	continue;
					dp[L][S][i%3]=max(dp[L][S][i%3],dp[FL][L][(i-1)%3]+Sum[S]);		//滚动数组的实现方法
				}
			}
		}
	for(int L=0;L<(1<<m);L++)
		for(int S=0;S<(1<<m);S++)
			ans=max(ans,dp[L][S][(n-1)%3]);	//结束状态可以是最后一行的任何状态
	cout<<ans;
	return 0;
}
```

---

## 作者：you_xiao (赞：124)

# 这是一道很不错的状压题
## 题目，数据，实现都不错
除了for循环打的头痛。。。

我们来康康这道题

首先，这是一道状压DP，因为数据量比较状压。。。

分别有N*M的地图，有缺陷的地形以及十字形的覆盖范围。

然后我们定义状态：

### Ｆ［ｉ］［ｊ］［ｋ］
用　ｉ　表示当前枚举到第几行，ｊ表示当前行的状态，ｋ表示上一行的状态

因为每一行的值会受前两行的影响，上面第一行方便枚举，但是再枚举上面第一行就有点吃力，因为这样我们的值没办法保证互补干涉，导致哇（ＷＡ）掉，于是我们用本行和上一行的排列状态表示一个状态。

然后我来说说状压（毕竟我没看太懂，知道蒙蔽的痛苦（神犇们可以跳过直接看码））

我们是用一个数的二进制展开来表示状态的

比如说８表示　１０００就是第一个位置选，其余不选，而每种二进制数代表不同的选择序列，用状态压缩的方式进行压缩处理，可以使用一维来代替好多维，使用时一般预处理一个“不能选的”数，它也是一个压缩过的树，用它的值来表示那个位置不可以选，而我们枚举的是一整个选择的状态，所以只要（＆）后操作出现不是期望的值，就可以判定它不符合题意

１　０　０　１　０　０　１　　Ｓ１

１　１　１　０　１　１　０　　Ｓ２

若Ｓ２中０表示不能选，就有（ｓ１＆ｓ２！＝ｓ１）（ｓ１表示１的位置选择，与不能选的冲突）。

同理，当判断是否与上一行冲突时，就有（ｓ１＆ｓ２＝＝０）表示不冲突（即没有两列位置重合的），这样以后，就可以进行操作了。。。



康康代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,F[105],f[105][66][66],start[70],cnt=0,gs[200];//特殊记录，不爆空间
bool mp[105][30];

int main(){
	cin>>n>>m;
	char a;	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a; 
			if(a=='H')mp[i][j]=1;//另不能选的为1
		}
	}
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			F[i]=(F[i]<<1)+mp[i][j];
            //把每行“不可选”状态压缩起来方便实用
		}
	}
	
	start[++cnt]=0;
    /*这个尤为重要，如果你要空间时间，就得像下面一样存
    如果直接存的话，就没了（毕竟那个一整排H的数据还是有的）
    不过如果从0开始循环也可以，但是放在这里起警示作用233*/
	
	for(int i=1;i<(1<<m);i++){
		if(i&(i<<1))continue;	//因为左二右二不能选
		if(i&(i<<2))continue;
		if(i&(i>>1))continue;
		if(i&(i>>2))continue;
		start[++cnt]=i;//直接存有用的就行
		int x=i;
		while(x){		//求取每个状态的贡献
			gs[cnt]++;
			x-=(x&(-x));
		}
	}
	
	for(int i=1;i<=cnt;i++){	//处理第一排
		if((start[i]&F[1])==0){	//不能与地形冲突
			f[1][i][0]=gs[i];
		}	
	}
	
	for(int i=1;i<=cnt;i++){	//第二排
		if((start[i]&F[2])==0)
		for(int j=1;j<=cnt;j++){
			if((start[i]&start[j])==0&&(start[j]&F[1])==0){
            		//判断是否冲突
				f[2][i][j]=gs[j]+gs[i];
			} 
		}
	}
	//让for来的更猛烈些吧（枚举状态）
	for(int i=3;i<=n;i++){		
		for(int j=1;j<=cnt;j++){	//当前一排状态		
			if((start[j]&F[i])==0){	
				for(int k1=1;k1<=cnt;k1++){		//上面第一排			
					if((start[j]&start[k1])==0&&(start[k1]&F[i-1])==0){						
						for(int k2=1;k2<=cnt;k2++){	//上面第二排				
							if((start[j]&start[k2])==0&&(start[k1]&start[k2])==0&&(start[k2]&F[i-2])==0){	
                            				//判断所有冲突情况
								f[i][j][k1]=max(f[i][j][k1],f[i-1][k1][k2]+gs[j]);//从之前转移过来就行
							}
						}
					}
				}
			} 	
		}
	}
	
	int ans=0;
    //所有的值都在最后1排存，用这一排的所有情况的最大值当最大值
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=cnt;j++){
			ans=max(ans,f[n][i][j]);
		}
	}
	cout<<ans;
}
```
于是，这个就完了

里面的状态转移还好说，这个判断冲突搞得我掉头发。。

就这样吧，

马蜂一般，希望能帮到您

---

## 作者：LJB00131 (赞：92)

首先此题是一个状压dp，思路非常简单，过程也清晰明了：

1.输入

2.**预处理** + 初始化

3.dp

4.找最大并输出

很多巨佬这题都使用了滚动数组，还有人在争论某些题解会爆空间。

但是我太菜了并不会滚动数组怎么办呢？？？

首先上代码

```cpp
int n, m, mapp[105], cnt = 0, f[105][105][105];

struct point 
{
    int s, num;
}a[105];
```

什么??

开105就够了？？？

这就涉及到了我们的第二步：预处理

本篇题解就来解析一下之前的题解都没有提到的预处理。

还是先上代码：

```cpp
cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            char c;
            cin >> c;
            mapp[i] = (mapp[i] << 1) + (c == 'P');
        }
    for(int i = 0; i < (1 << m); i++)
    {
        if((i & (i << 1)) || (i & (i << 2)) || (i & (i >> 1)) || (i & (i >> 2))) continue;
        cnt++;
        a[cnt].s = i;
        for(int j = 0; (1 << j) <= i; j++) a[cnt].num += !!(i & (1 << j));
        if((i & mapp[1]) == i) f[1][0][cnt] = a[cnt].num;
    }
```

枚举每次状态（i）

然后通过左移与右移判断出是否有不符合题目条件的状态并记录下来

这个记录状态的过程，相当于一个离散化，可以大大减小数据数量

通过输出m = 10时的cnt值，我们发现状态最多只会有60个

于是只需要开到65就可以了（为了保险我开了105）

所以是不是不用滚动数组了！！！

#### 预处理在所有状压dp中的运用：

在日常刷题中，我们不能保证每个状压dp题都可以使用滚动数组。

所以，我们要理解这个预处理的过程，然后再也不用担心状压MLE啦！！！


最后附上ac代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

int n, m, mapp[105], cnt = 0, f[105][105][105];

struct point 
{
    int s, num;
}a[105];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            char c;
            cin >> c;
            mapp[i] = (mapp[i] << 1) + (c == 'P');
        }
    for(int i = 0; i < (1 << m); i++)
    {
        if((i & (i << 1)) || (i & (i << 2)) || (i & (i >> 1)) || (i & (i >> 2))) continue;
        cnt++;
        a[cnt].s = i;
        for(int j = 0; (1 << j) <= i; j++) a[cnt].num += !!(i & (1 << j));
        if((i & mapp[1]) == i) f[1][0][cnt] = a[cnt].num;
    }
    cout << cnt << endl; //这个是预处理后的个数
    for(int i = 1; i <= cnt; i++)
        for(int j = 1; j <= cnt; j++)
            if(!(a[i].s & a[j].s) && (mapp[2] & a[j].s) == a[j].s) f[2][i][j] = f[1][0][i] + a[j].num;
    for(int i = 3; i <= n; i++)
        for(int j = 1; j <= cnt; j++)
            if((mapp[i] & a[j].s) == a[j].s) 
                for(int k = 1; k <= cnt; k++)
                    if(!(a[j].s & a[k].s))
                        for(int l = 1; l <= cnt; l++)
                        {
                            if(!(a[k].s & a[l].s) && !(a[j].s & a[l].s)) f[i][k][j] = max(f[i][k][j], f[i - 1][l][k] + a[j].num);
                        }
    int ans = 0;
    for(int i = 1; i <= cnt; i++)
        for(int j = 1; j <= cnt; j++) ans = max(ans, f[n][i][j]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Henry_he (赞：67)

话不多说，代码很详细了
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k;
int s[1005],g[1005];
int f[102][1005][1005],ans;
char ma[103];
int map[103];
int get(int x)//计算某一状态含有多少个1(即有多少个炮兵) 
{
	int e=0;
	while(x>0)
	{
		++e;
		x-=x&(-x);
	}
	return e;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i)//读入地图，将山地（不能放兵）的地方设为1 
	{
		scanf("%s",ma);
		for(int j=0;j<m;++j)
		  if(ma[j]=='H') map[i]+=1<<j;
	}
	for(int i=0;i<=(1<<m)-1;++i)//枚举所有的状态 
	  if(((i&(i<<1))==0)&&((i&(i<<2))==0)&&((i&(i>>1))==0)&&((i&(i>>2))==0))//判断每个1左右各两个是否有1，即判断这种状态是否存在 
		{
			++k;
			s[k]=i;
			g[k]=get(i);
			if((i&map[1])==0) f[1][0][k]=g[k];//初始化第一行  
		} 
	//初始化第二行 
	for(int i=1;i<=k;++i)//枚举第一行状态 
		for(int j=1;j<=k;++j)//枚举第二行状态 
			if(((s[i]&s[j])==0)&&((s[j]&map[2])==0))  f[2][i][j]=max(f[2][i][j],f[1][0][i]+g[j]);//判断是否与地形和第一行冲突 
	//dp过程 
	for(int i=3;i<=n;++i)//枚举当前行数 
		for(int j=1;j<=k;++j)//枚举当前行数状态 
			if((map[i]&s[j])==0)//不与地形冲突 
				for(int p=1;p<=k;++p)//枚举前一行状态 
					if((s[p]&s[j])==0)//当前行状态不与前一行冲突 
						for(int q=1;q<=k;++q)//枚举前两行
						//不与前两行冲突，且前两行自身不冲突 
							if(((s[q]&s[p])==0)&&((s[q]&s[j])==0)) f[i][p][j]=max(f[i][p][j],f[i-1][q][p]+g[j]);
	for(int i=1;i<=k;++i)//枚举最后两行为结尾的情况，统计答案 
		for(int j=1;j<=k;++j)
			ans=max(f[n][i][j],ans);
	cout<<ans;		//输出		
    return 0;
}
```

---

## 作者：MyukiyoMekya (赞：48)

我第一眼看到这道题就觉得是轮廓线dp（或者叫插头dp），结果AC后发现43篇题解没有一篇是轮廓线dp。。。

~~像这种往一个大方框里面填奇奇怪怪的形状，然后这个大方框有一边特别窄的难道不就是轮廓线dp么~~

首先，我们转换一下问题

```
1     X
2     X
3 X X X O O
4     O
5     O
```

对于十字，我们明显不需要去考虑 `O` 的部分，我们只需要关心 `X` 的部分会不会碰到其他十字的中心，

当然，这是按照从左往右从上往下的顺序枚举填充。

那么我们首先想到把上面的 1 2 3 行每个格子有没有十字中心状压掉，然后枚举当前位置要不要放十字，然后转移

要存十字中心这一行是因为十字中心左边部分也会被影响到

那么这个 dp 数组就可以这样开

$f_{i,j,mask1,mask2,mask3}$ 表示 $(i,j)$ 位置当前行状态是 $mask1$ ，上一行状态是 $mask2$ ，上上行状态是 $mask3$

$2^{30}$ 显然爆了

![](https://cdn.luogu.com.cn/upload/image_hosting/k5qh2z51.png)

假设我们现在枚举到绿色方格的位置，那么我们现在枚举的 3 行状态中，其实棕色部分是没有用的

所以我们可以把红色部分看成 1 行，粉色部分看成 1 行，然后这样就把 3 行的状态变成了 2 行

然后就是枚举绿色部分填不填十字，

分类讨论转移：

```
    1
    2
3 4 5
```

5 是当前的位置：

如果 1 2 3 4 都是空的，那么可以在 5 上填十字或者不填

如果只有 1 3 是有十字中心或者只有 2 4 是有十字中心 ，那么只能不在 5 上填，因为用 2 个换 1 个得不偿失

如果只有 1 或只有 2 或只有 3 或只有 4 是有十字中心，那么可以选择在 5 上填十字或者不填

当然如果地形是 `H` 那就不能填

上面那张图转移完绿色的方格后轮廓线就会变成这样子：（即转移到的新状态）

![](https://cdn.luogu.com.cn/upload/image_hosting/g5sgdl19.png)

那么 $f_{i,j,mask1,mask2}$ 的前两位可以滚存掉

时间复杂度 $O(n\times m\times 2^{2m})$

貌似不太行的亚子呢

我们可以非常容易地想到，这两行轮廓线的合法状态其实并不多

合法状态就是指这两行轮廓线状态中不存在冲突

我们可以直接通过dfs预处理搜出所有的合法状态，不到30000个

所以最后的时间复杂度大约是 $O(n\times m\times 30000)$，不开 O2 用 C++，最大点跑了 160ms，海星

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#include <bits/stdc++.h>
#define reg register
using namespace std;
template <class t> inline void read(t &s)
{
	s=0;
	reg int f=1;
	reg char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
		s=(s<<3)+(s<<1)+(c^48),c=getchar();
	s*=f;
	return;
}
char G[105][15];
int f[2][(1<<10)+5][(1<<10)+5];
int vis[3][10];
vector<pair<int,int> > Masks[11]; 
int n,m;
inline void checkmax(int &x,int y)
{
	if(x<y)
		x=y;
	return;
}
inline bool check(int pos)
{
	if(pos<m-1)
	{
		for(int i=0;i<3;++i)
			if(vis[i][pos]&&vis[i][pos+1])
				return false;
	}
	if(pos<m-2)
	{
		for(int i=0;i<3;++i)
			if(vis[i][pos]&&vis[i][pos+2])
				return false;
	}
	return true;
}
inline void dfs(int dep,int j,int mask1,int mask2)
{
	if(dep<0)
	{
		Masks[j].push_back(make_pair(mask1,mask2));
		return;
	}
	dfs(dep-1,j,mask1<<1,mask2<<1);
	if(dep<j)
		vis[1][dep]=true;
	else
		vis[0][dep]=true;
	if(check(dep))
		dfs(dep-1,j,mask1<<1|1,mask2<<1);
	if(dep<j)
		vis[1][dep]=false;
	else
		vis[0][dep]=false;
	if(dep<j)
		vis[2][dep]=true;
	else
		vis[1][dep]=true;
	if(check(dep))
	dfs(dep-1,j,mask1<<1,mask2<<1|1);
	if(dep<j)
		vis[2][dep]=false;
	else
		vis[1][dep]=false;
	return;
}
signed main(void)
{
	ios::sync_with_stdio(false);cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>G[i];
	reg int full=(1<<m)-1;
	reg int fpos=0;
	reg int ans=0;
	for(int i=0;i<m;++i)
		dfs(m-1,i,0,0);
	for(int i=1;i<=n;++i)
		for(int j=0;j<m;++j)
		{
			for(int maskid=0;maskid<(int)Masks[j].size();++maskid)
			{
				reg int mask1=Masks[j][maskid].first,mask2=Masks[j][maskid].second;
				reg bool flg=false;
				reg bool l0=(j>0&&(mask2&(1<<(j-1)))),l1=(j>1&&(mask2&(1<<(j-2))));
				reg bool u0=mask1&(1<<j),u1=mask2&(1<<j);
				if(u0)
				{
					if(!l0&&!l1&&G[i][j]=='P')
						checkmax(f[fpos^1][mask1^(1<<j)][mask2|(1<<j)],f[fpos][mask1][mask2]);
					flg=true;
				}
				if(u1)
				{
					if(!l0&&!l1&&G[i][j]=='P')
						checkmax(f[fpos^1][mask1^(1<<j)][mask2],f[fpos][mask1][mask2]);
					flg=true;
				}
				if(l0)
				{
					if(!u0&&!u1&&G[i][j]=='P')
						checkmax(f[fpos^1][mask1][(mask2^(1<<(j-1)))|(1<<j)],f[fpos][mask1][mask2]);
					flg=true;
				}
				if(l1)
				{
					if(!u0&&!u1&&G[i][j]=='P')
						checkmax(f[fpos^1][mask1][(mask2^(1<<(j-2)))|(1<<j)],f[fpos][mask1][mask2]);
					flg=true;
				}
				checkmax(f[fpos^1][(mask1&(~(1<<j)))|(mask2&(1<<j))][mask2&(~(1<<j))],f[fpos][mask1][mask2]);
				if(flg||G[i][j]=='H')
					continue;
				checkmax(f[fpos^1][(mask1&(~(1<<j)))|(mask2&(1<<j))][mask2|(1<<j)],f[fpos][mask1][mask2]+1);
			}
			for(int maskid=0;maskid<(int)Masks[j].size();++maskid)
				f[fpos][Masks[j][maskid].first][Masks[j][maskid].second]=0;
			fpos^=1;
		}
	for(int i=0;i<=full;++i)
		for(int j=0;j<=full;++j)
			checkmax(ans,f[fpos][i][j]);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：yy1695651 (赞：27)

翻了半天题解也没有看到状压三进制的，所以我来发一发

x为横坐标，y为纵坐标

### 讨论状态
对于$(x,y)$每一个三进制为

$0:(x,y),(x,y-1)$都没有被占用

$1:(x,y)$没有占用，$(x,y-1)$被占用

$2:(x,y)$被占用，$(x,y-1)$可以不考虑

占用指的是：有已经被其他炮兵攻击范围覆盖了（不要把山地作为占用，应为山地不用转移，其他炮兵的攻击范围里可以有山地）

通过讨论$(x,y)$来判断$(x,y+1)$是否可能放置一个炮兵

状态初始化全部为-1，代表不可到达

### 设置转移
$dp[i][j]$表示第$i$行状态$j$时，$1…i-1$行所能放炮兵的最大数目

1、这一行的**初始**状态可以由下一行转移得来

下面写的$(x,y-1),(x,y),(x,y+1)$都表示这个坐标对应的**状态**

当$(x,y-1)$为0，$(x,y)$为0

当$(x,y-1)$为1，$(x,y)$为0

当$(x,y-1)$为2，$(x,y)$为1

特别的当$(x,y)$为坏点，记录$no[x]=true$

2、开始dfs过程

参数$x$表示列，$i$代表当前的行
$(i,x)$放\不放炮兵

$p[],q[]$分别代表下一行和当前dfs的一行的每个状态
 1. $(i,x)$不放炮兵，dfs直接跳转到$(i,x+1)$（代码中用for循环代替）
 2. $(i,x)$放置炮兵，前提$p[x]=0,q[x]=0$，当前已经枚举的放置个数+1更新$dp[i+1][q']$，$q'$表示$q$放置炮兵后的状态$q[x]=2$，dfs跳转到$(i,x+3)$（因为x+1,x+2都是当前放的炮兵的攻击范围）
 
 不知道讲懂了没有qwq
 
 ```cpp
 #include <bits/stdc++.h>
using namespace std;
inline void read(int &x){
    x = 0; int f = 1; char ch = getchar();
    while (!(ch >= '0' && ch <= '9')){if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
inline void Max(int &x, int y){if (y > x) x = y;}
const int N = 100 + 10;
const int M = 10 + 5;
int n, m, f[2][59049], p[M], q[M], thr[M], ans;
bool hit[N][M], fg, no[M];
char s[15];
inline int make(int *a){//十进制转三进制
    int ret = 0;
    for (int i = 1; i <= m && a; i++) ret += thr[i - 1] * a[i];
    return ret;
}
inline void res(int x, int *a){//三进制转十进制
    for (int i = 1; i <= m; i++) a[i] = x % 3, x /= 3;
}
//dfs(列，已经得出的放置个数)
inline void dfs(int x, int cnt){
    Max(f[fg][make(q)], cnt);
    Max(ans, cnt);
    for (; x <= m; x++){
        if (!p[x] && !q[x] && !no[x]){
            q[x] = 2; dfs(x + 3, cnt + 1); q[x] = 0;
        }
    }
}
int main(){
    thr[0] = 1;//三进制预处理
    for (int i = 1; i <= 10; i++) thr[i] = thr[i - 1] * 3;
    read(n), read(m);
    for (int i = 1; i <= n; i++){
        scanf("%s", s + 1);//不能放炮塔的位置打上标记
        for (int j = 1; j <= m; j++) if (s[j] == 'H') hit[i][j] = true;
    }
    memset(f, -1, sizeof(f));//初始化为-1表示没有到达
    f[1][0] = 0;//用于初始化第一行
    for (int i = 1; i <= n; i++){
        memset(f[fg], -1, sizeof(f[fg]));//记得初始化
        for (int j = 0; j < thr[m]; j++) if (f[fg ^ 1][j] != -1){
            res(j, p);
            for (int k = 1; k <= m; k++){
                no[k] = hit[i][k];//no记录当前行的山地，就是不能放炮塔
                q[k] = max(0, p[k] - 1);//q可由上一行转移来
            }
            dfs(1, f[fg ^ 1][j]);
        }
        fg ^= 1;
    }
    printf("%d\n", ans);
    return 0;
}
/*
尝试使用三进制
3^10=59049
0:表示当(x,y),(x,y-1)为空
1:表示(x,y)为空,(x,y-1)不为空
2:表示(x,y)不为空
注意"H"山地不要表示到2状态中，因为山地不用被转移(其他炮的范围中可以是山地)
只用于判断当前行是否可以放炮塔
转移条件,p,q代表当前行所对应三进制下的每个点的状态，用res函数三进制转十进制
(x-1,y)=0,(x,y)=0就是p[x-1]=0,q[x]=0
f[x][j']=++cnt
只用修改当前行(x,y)=2就是q[x]=2
(x,y)上放炮塔后跳转到(x+3,y)
*/


 ```

---

## 作者：www233 (赞：19)

因为m<=10，很小，所以将每一行的情况用一个二进制数来表示。
- 地形：用0表示山地，1表示平原。
- 炮兵：用0表示没有，1表示摆放炮兵

于是在输入的时候直接记录每一行的地形
- zifuchuan为输入的字符串,pic[i]表示第i行的地形 
```
if(zifuchuan[k-1]=='P')pic[i]=(pic[i]<<1)+1;//zifuchuan输入的字符串,pic[i]第i行的地形 
	else pic[i]=(pic[i]<<1);
```

在进行DP前使用一个数组存储每一行可能的炮兵摆放方式
- m[i]表示第i种情况，num[i]该情况的炮兵数，cnt计数
```
bool check(int k)
{
    int a=(k<<1),b=(k>>1);
    if((a&k)!=0||(b&k)!=0)return 0;
    a=(k<<2),b=(k>>2);
    if((a&k)!=0||(b&k)!=0)return 0;
    return 1;
}
int number(int a) 
{
    int num=0;
    while(a)
    {
        if(a&1==1)num++;
        a>>=1;
    }
    return num;
}
for(int i=0;i<=inf;i++)
{
     if(check(i)==1)
     {
        cnt++;
        m[cnt]=i;
        num[cnt]=number(i);
     }
}
```

因为每一行的状态会跟前两行有关，所以开的数组要包含两行的信息，则用p[i][x][y]表示第i行的炮兵摆放为x，第i-1行炮兵摆放为y时的方法数量，有状态转移方程：
- p[i][x][y]=max(num[x],p[i-1][y][z])

于是动态规划的循坏应运而出：
第i行，该行的第k种情况，第i-1行的第y种情况，第i-2行的第z种情况。并在枚举情况时判断该情况是否满足，若满足就可以对该状态赋值。最后双层循环找出答案。

完整代码如下（我的能力不足，有错和冗长代码的请指出）
```
#include <bits/stdc++.h>
using namespace std;
int n,mc,pic[150],inf;//n*mc的地图，pic[i]第i行的地形 
long long p[3][1<<10][1<<10],ans;//p[i][z][y]=第i行放z,第i-1行放y的总的数量 
char zifuchuan[150];//输入的字符串 
int m[1<<12],num[1<<12],cnt;   //m每一行可能的情况，num该情况的炮兵数，cnt计数 
bool check(int k)//情况k是否满足炮兵互不相邻 ，0相邻，1不相邻 
{
    int a=(k<<1),b=(k>>1);
    if((a&k)!=0||(b&k)!=0)return 0;
    a=(k<<2),b=(k>>2);
    if((a&k)!=0||(b&k)!=0)return 0;
    return 1;
}
bool check2(int i,int a)//情况a与地形i是否冲突，0冲突，1不冲突 
{
    if((i&a)!=a)return 0;
    return 1;
}
int number(int a)//计算情况a的炮兵数量 
{
    int num=0;
    while(a)
    {
        if(a&1==1)num++;
        a>>=1;
    }
    return num;
}
bool comp(int a,int b)//情况a,b炮兵是否相邻，0相邻，1不相邻  
{
    if((a&b)!=0)return 0;
    return 1;
}
int main() {
    cin>>n>>mc;
    inf=(1<<mc)-1;//每一行的最大情况值 
    n+=1;  //从pic[2]开始DP 
    for(int i=2;i<=n;i++)
    {
        scanf("%s",zifuchuan);
        for(int k=1;k<=mc;k++)
        {
            if(zifuchuan[k-1]=='P')pic[i]=(pic[i]<<1)+1;//令1为平原，0为山地 
            else pic[i]=(pic[i]<<1);
        }
    }
    pic[0]=pic[1]=inf;//pic[0],pic[1]地形初始化为全为平原 
    for(int i=0;i<=inf;i++)   //将可能的炮兵情况提前存到一个数组里 
    {
        if(check(i)==1)
        {
            cnt++;
            m[cnt]=i;
            num[cnt]=number(i);
        }
    }
    for(int i=2;i<=n;i++)//从第i行开始 
    {
        for(int k=1;k<=cnt;k++)//第i行的第k种情况 
        {
            if(check2(pic[i],m[k])==0)continue;//该情况与地形冲突 
            for(int y=1;y<=cnt;y++)//第i-1行的第y种情况 
            {		
                if(check2(pic[i-1],m[y])==0)continue;//该情况与地形冲突 
                if(comp(m[k],m[y])==0)continue;//该情况的炮兵会被攻击到 
             //   p[i%3][m[k]][m[y]]=num[k];
                for(int z=1;z<=cnt;z++)//第i-2行的第z种情况 
                {
                    if(check2(pic[i-2],m[z])==0)continue;//该情况与地形冲突 
                    if(comp(m[k],m[z])==0||comp(m[y],m[z])==0)continue;//该情况的炮兵会被攻击到 
                    p[i%3][m[k]][m[y]]=max(p[i%3][m[k]][m[y]],num[k]+p[(i-1)%3][m[y]][m[z]]);
                }
            //	cout<<i-1<<" "<<m[k]<<" "<<m[y]<<" "<<p[i%3][m[k]][m[y]]<<endl;
            }
        }
    }
    for(int k=1;k<=cnt;k++)
    {
        for(int y=1;y<=cnt;y++)
        {		
            ans=max(ans,p[n%3][m[k]][m[y]]);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Agemt (赞：12)

#### 一道经典的状压DP
##### 主要思路：用f数组表示状态，首先f数组必有一维表示当前行，还有一维表示当前行的状态，由于炮兵可以轰炸到前两行，所以还需要一维表示上一行的状态，不妨设f[i][j][k]表示第k行的状态为j，第k-1行的状态i时能放的最大炮兵数
##### 不过为什么第k-2行不用记录呢？其实将第k-2行的状态记录进f数组中未尝不可，但不仅会远远超出空间范围(O(2^10*2^10*2^10*100))，而且在后面的状态转移方程中我们可以发现不需要考虑第k-2行，在进行第k-1的转移时已经考虑过了
##### 动态转移方程应该很好推 f[i][j][k] = max{ f[l][i][k-1] | l,i,j∈{0,1,...,(1<<m)-1}, k∈{x|x∈N*,x≠1}，check(i,j,l)}
##### 上式表明了状态转移的规律，以及式子成立的条件，观察上述式子，可以再次证明不需要考虑第k-2行，因为在进行第k-1的转移时已经考虑过了，只需要枚举判断第k-2行的状态是否不与第k-1行和第k行冲突
##### 那么check(i,j,k)要满足什么条件呢？不难发现，除了每一行自身状态不能冲突外，每一行之间也不能冲突，这一点在代码中有体现
##### 不过按照这样的思路，还不算优秀，时间复杂度和空间复杂度都较高
##### 针对空间复杂度，由于状态的转移只涉及前一行，我们可以采取滚动数组的方法，将第三维变为[2],楼上的大佬们有详细的讲解
##### 针对时间复杂度，由于在一行中可能有许多不能放置炮兵的点，不妨预处理出，每一行满足地形条件的状态，代码中有较详细说明
##### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct state{
	int st[1100];
	int num=0;
}b[110];
int f[1100][1100][2];
int a[110][20];
int s[110],sum[1100];
int n,m,ans,t=1;
int main(){
    scanf("%d%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++){
    	    char c;cin>>c;
    	    s[i]=s[i]*2+(c=='P');//记录每一行状态 
        }
    for(int i=0;i<(1<<m);i++)
        for(int j=0;j<m;j++)
		    if(i&(1<<j)) sum[i]++;//记录每一种状态有几个炮兵 
    for(int i=1;i<=n;i++)//枚举每一行 
    	for(int j=0;j<(1<<m);j++)//枚举当前行的状态 
    	    if((j|s[i])==s[i]&&!(j&(j<<1))&&!(j&(j<<2)))//不冲突 
    	    	b[i].st[++b[i].num]=j;//记录当前行可行状态 
    for(int i=1;i<=b[1].num;i++) f[0][b[1].st[i]][0]=sum[b[1].st[i]];//初始化第一行
    for(int i=1;i<=b[2].num;i++)//初始化第二行
        for(int j=1;j<=b[1].num;j++){
        	int k=b[2].st[i],l=b[1].st[j];
        	if(k&l) continue;
        	f[l][k][1]=max(f[l][k][1],f[0][l][0]+sum[k]);
		}
    for(int i=3;i<=n;i++){//枚举行 
    	t^=1;//滚动数组
    	for(int j=1;j<=b[i].num;j++)//第i行状态 
    		for(int k=1;k<=b[i-1].num;k++)//第i-1行状态 
    		    if(!(b[i].st[j]&b[i-1].st[k]))//第i行与第i-1行不冲突 
    		        for(int l=1;l<=b[i-2].num;l++)//第i-2行状态 
    		        	if(!(b[i].st[j]&b[i-2].st[l])&&!(b[i-1].st[k]&b[i-2].st[l]))//第i行与第i-2行以及第i-1行与第i-2行不冲突 
    		        		f[b[i-1].st[k]][b[i].st[j]][t]=max(f[b[i-2].st[l]][b[i-1].st[k]][t^1]+sum[b[i].st[j]],f[b[i-1].st[k]][b[i].st[j]][t]);//更新答案 
	}
    for(int i=1;i<=b[n].num;i++)
 	    for(int j=1;j<=b[n-1].num;j++)
 	        ans=max(ans,f[b[n-1].st[j]][b[n].st[i]][t]);//更新最优解 
	cout<<ans<<endl;
    return 0;
}
```

---

## 作者：真姬八彩 (赞：10)

##     不错的一道状压题
### [蒟蒻的BLOG](https://1390282815.github.io/)
    看到这道题很容易就会想到状压
    与模板稍有不同每一行与上俩行有关联
    都需要记下他们的状态
    设计出状态f[i//当前dp所在行][j//本行的状态][k//上一行的状态]
	状态转移方程
```
f[i][j][k] = max(f[i][j][k] ,f[i - 1][k][l] + pv[a[i][j]])
//j枚举当前行状态，k枚举i - 1行状态，l枚举i - 2行状态
//pv记下不同状态的炮兵数的
```
    注意几个细节内存会炸，要滚掉一维
    pv可以预处理，也可以直接求
    若看完还是不会的，可以先学习下状压在来做题
    磨刀不误砍柴功
    上代码：
    

------------
```cpp
#include<bits/stdc++.h>
#define FOR(a , b , c) for (int a = b; a <= c; a++)
using namespace std;
int n , m;
int a[107][1027] , num[107] , v[107][1027] , pv[1027];
int f[2][1027][1027];
char ch[17];
inline void pval() {//预处理pv
	FOR(i , 1 , (1 << m) + 1) {
		int cp = 1;
		while(cp <= i) {
			if(cp & i) pv[i]++;
			cp = cp << 1;
		}
	}
}
inline void pre(int k , int w) {//查询合法的状态
	int cnt = 0;
	FOR(i , 0 , (1 << m) - 1) {
		if(((i << 1) & i) || ((i << 2) & i) || ((i >> 1) & i) || ((i >> 2) & i) || (i & w)) continue;
		a[k][++cnt] = i;
	}
	num[k] = cnt;
}//记下状态与总状态数
int main () {
	scanf("%d %d" , &n , &m);
	pval();
	FOR(i , 1 , n) {
		int s = 0 , x;
		scanf("%s" , &ch);
		FOR(j , 0 , m - 1) {
			if(ch[j] == 'H') x = 0;
			if(ch[j] == 'P') x = 1;
			s = (s << 1) + 1 - x;//以二进制存
		}
		pre(i , s);//处理合法状态
	}
	FOR(i , 1 , num[1]) FOR(j , 1 , num[2]) {
		if(a[1][i] & a[2][j]) continue;
		f[0][j][i] = pv[a[1][i]] + pv[a[2][j]];
	}//初始化
	int cn = 0;
	FOR(i , 3 , n) {
		cn = cn ^ 1;//滚掉一维
		FOR(j , 1 , num[i]) FOR(k , 1 , num[i - 1]) FOR(l , 1 , num[i - 2]) {
			if((a[i][j] & a[i - 1][k]) || (a[i][j] & a[i - 2][l]) || (a[i - 1][k] & a[i - 2][l])) continue;//检查是否合法
			f[cn][j][k] = max(f[cn][j][k] , f[cn ^ 1][k][l] + pv[a[i][j]]);//状态转移，从前一行，继承下来并加上当前行的炮兵数
		}
	}
	int ans = 0;
	FOR(i , 1 , num[n]) FOR(j , 1 , num[n - 1]) ans = max(ans , f[cn][i][j]);//统计答案
	printf("%d" , ans);
```




---

## 作者：Cris (赞：10)

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
int cnt,m,n;
int dp[100][64][64],num[64],state[64],bitmap[100];
void solve(){
    int ans=0,i,j,k,p;
    memset(dp,0,sizeof(dp));
    for(i=0;i<n;i++){
        for(j=0;j<cnt;j++){
            if(bitmap[i]&state[j])continue;//山地无炮兵 
            if(i==0) dp[i][j][0]=num[j]; 
            else if(i==1)
            {
                for(k=0;k<cnt;k++)
                {
                    if(bitmap[i-1]&state[k]) continue;//判断第i-1行的k状态是否和山地冲突
                    if(state[j]&state[k]) continue;//i-1行j,k状态是否兼容
                    if(dp[i][j][k]<dp[i-1][k][0]+num[j])
                        dp[i][j][k]=dp[i-1][k][0]+num[j];
                }
            }
            else{
                for(k=0;k<cnt;k++){//i-1行状态枚举                         
                    if(bitmap[i-1]&state[k]) continue;
                    if(state[j]&state[k]) continue;//同上
                    for(p=0;p<cnt;p++)//i-2行状态枚举 
                    {
                        if(bitmap[i-2]&state[p]) continue; //i-2行和状态p 
                        if(state[k]&state[p] || state[j]&state[p]) continue;//三行状态是否兼容 
                        if(dp[i][j][k]<dp[i-1][k][p]+num[j])
                            dp[i][j][k]=dp[i-1][k][p]+num[j];
                    }
                }
            }
        }
    } 
    for(j=0;j<cnt;j++)
        for(k=0;k<cnt;k++)
            if(dp[n-1][j][k]>ans)
                ans=dp[n-1][j][k];//取最大值 
    printf("%d\n",ans);
}
int main(){
    char s[12];
    int i,j;
    scanf("%d%d",&n,&m);
    memset(bitmap,0,sizeof(bitmap));
    for(i=0;i<n;i++){
        scanf("%s",s);
        for(j=0;j<m;j++)
            if(s[j]=='H')bitmap[i]+=(1<<(m-1-j));
    }
    int tmp;
    cnt=0;
    for(int i=0;i<(1<<m);i++){//2^m-1 
        tmp=i;
        if( ((tmp<<1)&i) | ((tmp<<2)&i) )continue;//炮兵不能攻击彼此 
        state[cnt]=i;//记录状态(转化为十进制） 
        num[cnt]=tmp&1;
        while(tmp=(tmp>>1))
            num[cnt]+=tmp&1;
        cnt++;//num[]记录此合法状态'1'的数量 
    }
    solve();
     return 0;
}
```

---

## 作者：中二病 (赞：9)

状压DP

dp[i][j][k],i表示行数，j表示这一行状态，k表示上一行状态（因为一行要受上两行的影响，压掉一个后还要表示上一行的状态）

具体的细节看注释

### 混合运算加括号！

### 混合运算加括号！！

### 混合运算加括号！！！

被卡了一晚上

~~很喜欢我写的代码~~（逃）

上代码

```
#include<iostream>
#include<cstdio>
#include<cstring> 
using namespace std;
int n,m,dp[110][1<<10][1<<10],tot,zy[1<<10],a[110],num[1<<10],ans;
char ch;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>ch;
            if(ch=='H')a[i]+=1<<(j-1);//把每一行转成二进制状态 
        }
    }
    int nn=(1<<m)-1;//状态的最大值，加括号！！！再这卡了一晚上 
    for(int i=0;i<=nn;i++)
    {
        if(!(i&(i<<1))&&!(i&i<<2))//状态左右两格互不影响 
        {
            tot++;
            zy[tot]=i;//存状态 
            int pg=i;
            while(pg>0)
            {
                if(pg&1)num[tot]++;//存状态中炮兵的数量 
                pg>>=1;
            }
        }
    }
    //预处理第二行 
    for(int i=1;i<=tot;i++)
    {
        for(int j=1;j<=tot;j++)
        {
            if(!(zy[i]&zy[j])&&!(zy[i]&a[2])&&!(zy[j]&a[1]))//互不影响且不在山上 
            {
                dp[2][i][j]=num[j]+num[i];
            }
        }
    }
    for(int i=3;i<=n;i++)//枚举行 
    {
        for(int j=1;j<=tot;j++)//本行 状态 
        {
            if(!(zy[j]&a[i]))//不在山上 
            {
                for(int k=1;k<=tot;k++)//上一行状态 
                {
                    if(!(zy[k]&a[i-1])&&!(zy[k]&zy[j]))//不在山上，不与本行冲突 
                    {
                        for(int p=1;p<=tot;p++)//上两行状态 
                        {
                            if(!(zy[p]&a[i-2])&&!(zy[p]&zy[k])&&!(zy[p]&zy[j]))//不在山上，不冲突 
                            {
                                dp[i][j][k]=max(dp[i][j][k],dp[i-1][k][p]+num[j]);//转移方程 
                                ans=max(ans,dp[i][j][k]);//转移答案 
                            }
                        }
                    }
                }
            }
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：TOM_闫 (赞：8)

本题也算状压DP的基础题，只不过需要考虑当前行和前两行的关系

先对第一行和第二行进行预处理，这里枚举就可以。

然后我们看回数据范围，m<=10，其实刚看到这里时我有点蒙了，因为要枚举当前行和上一行还有上上行的所有情况，那么就已经1024的三次方了，肯定超时。但我们如果在预处理时求出一行里能存在的所有情况，就会发现即使是m=10的时候，也只有60种情况，60的三次方就没问题了。

DP方程也很简单。我们用f[i][j][k]表示第i行情况为k，上一行情况为j的最优解，那么就很直白了f[i][j][k]=max(f[i][j][k],f[i-1][l][j]+get\_num(k))(l为上上行的情况)

小细节：在读取时用bann数组存山地的情况，判断某情况是否合法只需看(情况&bann[当前行])是否为0.

PS：关于bann的用法可以参考P1879 玉米田

下面附上代码：

```cpp
    #include<cstdio>
    #include<algorithm>
    #include<cstring>
    using namespace std;
    int n,m,casee,lcase;  //casee为所有可能的情况 lcase为筛选后的情况
    int bann[101],f[101][1101][1101],cann[101];
    int get_num(int);
    void workk();
    int main()
    {
        int i,j,k,l,summ,maxx=0;
        char a;
        scanf("%d%d",&n,&m);
        casee=1<<m;
        for(i=1;i<=n;i++)
        {
            summ=0;
            for(j=m-1;j>=0;j--)  //顺便将bann数组处理掉
            {
                scanf("\n%c",&a);
                if(a=='H') summ+=(1<<j); 
            }
            bann[i]=summ;
        }
        workk();  //预处理
        for(i=3;i<=n;i++)  //开始DP 中间的if条件比较多，有一些是可以不加的，但是加上能缩短时间
            for(j=1;j<=lcase;j++)
                if((cann[j]&bann[i])==0)
                    for(k=1;k<=lcase;k++)
                        if((cann[k]&bann[i-1])==0 && (cann[j]&cann[k])==0)
                            for(l=1;l<=lcase;l++)
                                if((cann[l]&bann[i-2])==0 && (cann[k]&cann[l])==0 && (cann[j]&cann[l])==0)
                                    f[i][cann[k]][cann[j]]=max(f[i][cann[k]][cann[j]],f[i-1][cann[l]][cann[k]]+get_num(cann[j]));
        for(i=1;i<=lcase;i++)  //统计最大值
            for(j=1;j<=lcase;j++)
                if(f[n][cann[i]][cann[j]]>maxx) maxx=f[n][cann[i]][cann[j]];
        printf("%d\n",maxx);
        return 0;
    }
    int get_num(int x)  //统计情况中1的个数
    {
        int anss=0;
        while(x!=0)
        {
            if((x&1)!=0) anss++;
            x>>=1;
        }
        return anss;
    }
    void workk()  //预处理
    {
        int i,j,k,pd;
        for(i=0;i<casee;i++)  //预处理比较麻烦，要仔细考虑所有情(我就忘了什么都不放的情况了)
            if((i&(i<<2))==0 && (i&(i<<1))==0)
            {
                cann[++lcase]=i;  //对于cann的处理可以加在单行处理中
                if((i&bann[1])==0) f[1][0][i]=get_num(i);
                if((i&bann[2])==0) f[2][0][i]=get_num(i);
            }
        for(i=1;i<=lcase;i++)
            for(j=1;j<=lcase;j++)
                if((cann[i]&bann[1])==0 && (cann[j]&bann[2])==0 && (cann[i]&cann[j])==0)
                    f[2][cann[i]][cann[j]]=get_num(cann[i])+get_num(cann[j]);        
}
```

---

## 作者：jins3599 (赞：5)

一道简单的状压$dp$。基本上是模板题。

考虑到每一个位置，他的左右两格之内无法放棋子，这样的话就可以用一遍$dfs$预处理出来初始状态。

然后我们来设计方程，考虑到当前状态的上上层会影响到当前状态的摆放方式，我们不妨这样设计转移:

`f[i][j][k]`代表当前是第$i$行，状态为$j$，状态$j$由状态$k$转移过来。

该方程可以转移的条件，当且仅当三行的状态互不冲突。

我们设当前状态是`cnt`，那么判断条件就是:

当且仅当`!(cnt & j) && !(cnt & k) && !(j & k)`时可以转移。

转移方程就很简单了:

`f[i][cnt][j] = max{f[i - 1][j][k] + sum[cnt]}`

注意卡一下空间，我把`M = 15` $MLE$两个点 , `M = 10`就$AC$了。

$Code:$
```cpp
//f[i][j][k] 前i行,当前行状态为j,从上一行的状态k转移来的的最大士兵数量。 
#include <bits/stdc++.h>

using namespace std;

const int N = 101;
const int M = 10;


int line[M];
int f[N][(1 << M) + 1][(1 << M) + 1];
int sr[(1 << M) + 1] , cnt , sum[(1 << M) + 1];
int n , m;
char qwq[N];


void dfs(int last , int tot , int num) {
	if(tot >= m) {
		sum[++ cnt] = num;
		sr[cnt] = last;
		return;
	}
	dfs(last , tot + 1 , num);
	dfs(last | (1 << tot), tot + 3 , num + 1);
}


int main () {
	scanf("%d %d" , &n , &m);
	dfs(0 , 0 , 0);
	for(int i = 1 ; i <= n ; ++ i){
		scanf("%s" , qwq);
		for(int k = 0 ; k < strlen(qwq) ; ++ k)
			if(qwq[k] == 'H') line[i] |= (1 << k);
	}


	for(int i = 1 ; i <= cnt ; ++ i) {
		if(sr[i] & line[1]) continue;
		for(int j = 1 ; j <= cnt ; ++ j) 
			f[1][sr[i]][sr[j]] = sum[i];
	}
	
	for(int i = 2 ; i <= n ; ++ i) {
		for(int j = 1 ; j <= cnt ; ++ j) {
			for(int k = 1 ; k <= cnt ; ++ k) {
				for(int l = 1 ; l <= cnt ; ++l ) {
					if((sr[j] & sr[k]) || (sr[j] & sr[l]) || (sr[k] & sr[l])) continue;
					if((sr[j] & line[i]) || (sr[k] & line[i - 1]) || (sr[l] & line[i - 2])) continue;
					f[i][sr[j]][sr[k]] = max(f[i][sr[j]][sr[k]] , f[i - 1][sr[k]][sr[l]] + sum[j]);
				}
			}
		}
	}
	int ans = 0;
	for(int i = 1 ; i <= cnt ; ++ i) 
		for(int j = 1 ; j <= cnt ; ++ j)
		ans = max(ans , f[n][sr[i]][sr[j]]);
	printf("%d\n" , ans);
	return 0;
} 
```

---

## 作者：goldimax (赞：5)

写个奇葩的**记忆化搜索**做法

众所周知 该题如果将连续两行压入变量会爆掉内存……先晾出$\red{20}$分的记搜……

```c++
// int dp[100][10][1024][1024];
// bool v[100][10][1024][1024];

int solve(int x, int y, int a, int b) {
    if (x == n) return 0;
    if (y >= m) return solve(x + 1, 0, a, b);
    if (b & (1 << y)) return solve(x, y + 1, a | (1 << y), b & ~(1 << y));
    if (a & (1 << y)) return solve(x, y + 1, a & ~(1 << y), b);
    if (g[x][y] == 'H') return solve(x, y + 1, a, b);
    return max(solve(x, y + 1, a, b), solve(x, y + 2, a, b | (1 << y)) + 1);
}
```

但是我又想死守记搜

这可怎么办呢 ~~找cz改数据~~

研究发现 每一行所压的状态和上一行压的状态在同一列肯定没有重复的 比如我用`a`压上一行的状态 `b`压这一行的状态 那么肯定可以得出`(a & b) == 0`

所以说 其实将连续两行压入变量是非常浪费的 因为有很多空的位

究竟有多少空位呢？我们可以看一个例子

```
1001001001
0100100100
```

从这个例子已经将两行全部填满 不可能放更多棋子了 但是……我们发现总共只有7个棋子……

既然两行是有很多空位并且是互斥的 那么能不能压到同一行呢……

```
1101101101
```

但是这样好像不能知道下一行枚举完了究竟要删哪几个位……

仔细想想……既然这里只有7位`1` 那么能不能将这7个`1`在哪一行二进制标记出来然后用的时候展开呢……？

```c++
int decode(int a, int b) {
    int ans = 0;
    for (int i = 0, j = 0; i < m; i++) {
        if (a & (1 << i)) {
            if (b & (1 << j)) ans |= 1 << i;
            j++;
        }
    }
    return ans;
}

int encode(int a, int b) {
    int ans = 0;
    for (int i = 0, j = 0; i < m; i++) {
        if (a & (1 << i)) {
            if (b & (1 << i)) ans |= 1 << j;
            j++;
        }
    }
    return ans;
}
```

好像是可以 而且状态数成功比以前少了 从$\mathcal{O}(2^{m^2}n)$降低到了$\mathcal{O}(2^{7m}n)$……貌似就可以$\green{AC}$了？

晒出代码：

```c++
int dp[100][1024][256];
bool v[100][1024][256];

int solve(int x, int a, int b) {
    if (x == n) return 0;
    if (v[x][a][b]) return dp[x][a][b];
    v[x][a][b] = true;
    int ra = decode(a, b), rb = a ^ ra;
    int ans = 0;
    for (int y = 0; y < (1 << m); y++) {
        if ((y & a) | (y & (y << 1)) | (y & (y << 2)) | (y & g[x])) continue;
        checkmax(ans, solve(x + 1, rb | y, encode(rb | y, rb)) + count(y));
    }
    return dp[x][a][b] = ans;
}
```

> 关于细节
>
> 1. 这里是整行枚举所以用二进制存图直接或起来比较省事儿
> 2. `count`函数用来数二进制位里面`1`的数量
> 3. 一定要把`y`从$0$到$2^m$枚举 不要认为枚举空位会更快 本人最开始就是这么写的 会TLE一个点 平均会慢一倍

> 其他：
>
> - 推广下本人Gayhub：[GoldIMax](https://github.com/goldimax)
> - 本人[博客](https://goldimax.github.io)




---

## 作者：James_Brady (赞：5)

**~~二营长，你他娘的意大利炮呢~~**

首先，看M的范围，0<M<=10

即使是这么小的范围，dfs暴力也会超时

所以来引入一个新玩意，状压dp

所谓状压，就是把状态压缩成一个数（一般为二进制数，方便位运算）进行处理，避免数组开多维超内存

对于本题，我们定义，0为没放炮兵，1为放了炮兵

如下所示，

**PPHHPHP**

如果第一个位置放，第五个放，那么这个状态就是1000100（十进制为68）

这样每个状态都有一个唯一的十进制数与之对应

先把每行的合法状态求出并存起来（不考虑地形和纵列），然后每行枚举状态

定义dp[i][j][k]为第i行本行状态为j，上一行状态为k合法时的总炮兵数

枚举j，k以及i-2行的状态x（因为i行状态会影响i-1和i-2）

如果合法，方程为：

**dp[i][j][k]=max(dp[i][j][k],dp[i-1][k][x]+num[j]);**

（num[i]为状态i的总炮兵数）

具体代码如下：

```cpp
#include<iostream>//这里的位运算很巧妙，应熟练掌握
#include<cstdio>
using namespace std;
char s[110][110];
int n,m,dp[110][65][65],st[2010],cnt,num[2010];
int map[110];
bool judge1(int x)//判断每行状态是否合法，是返回0
{
	return (x&(x>>1))||(x&(x>>2));
}
bool judge2(int i,int x)//判断x号状态是否符合地形条件，是返回0
{
	return map[i]&st[x];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("\n");//避免把空行读入s数组
		for(int j=1;j<=m;j++)
		{
			s[i][j]=getchar();
			if(s[i][j]=='H')
			map[i]|=1<<(j-1);//存储地图状态，1表示不能放
		}
	}
	for(int i=0;i<(1<<m);i++)
	if(!judge1(i))
	st[++cnt]=i;//存储合法状态
	for(int i=1;i<=cnt;i++)
	{
		int p=st[i];
		while(p>0)
		{
			if(p&1)
			num[i]++;
			p>>=1;
		}
	}//计算num[i]
	for(int i=1;i<=cnt;i++)
	if(!judge2(1,i))
	dp[1][i][0]=num[i];
	for(int i=1;i<=cnt;i++)
	{
		for(int j=1;j<=cnt;j++)
		if(!judge2(2,i)&&!(st[j]&st[i]))
		dp[2][i][j]=max(dp[2][i][j],dp[1][j][0]+num[i]);
	}
	for(int i=3;i<=n;i++)
	{
		for(int j=1;j<=cnt;j++)//i行状态
		if(!judge2(i,j))
		{
			for(int k=1;k<=cnt;k++)//i-1行状态
			if(!judge2(i-1,k)&&!(st[j]&st[k]))//注意，j，k两状态不能冲突，下同
			{
				for(int l=1;l<=cnt;l++)//i-2行状态
				if(!judge2(i-2,l)&&!(st[j]&st[l])&&!(st[l]&st[k]))
				dp[i][j][k]=max(dp[i][j][k],dp[i-1][k][l]+num[j]);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=cnt;i++)
	if(!judge2(n,i))
	{
		for(int j=1;j<=cnt;j++)
		if(!judge2(n-1,j)&&!(st[i]&st[j]))
		ans=max(ans,dp[n][i][j]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：littleseven (赞：3)

## 题解：

**状态压缩**

这道题是一道状态压缩DP，具体为什么是状压DP，请看$M \le 10$。

对于题目中的山地，我们可以看做当前点不能走，在读入的时候记录即可。

之后我们要明确的一个问题，DP状态：

> 我们用$f[i][j][k]$来表示当前枚举到第$i$行，当前行状态为$j$，上一行状态为$k$时候的答案。

那么由于一个炮兵可以影响到以自己为中心的距离为2的十字，那么我们的转移方程就会受到前两行的影响，所以我们选用前两行的状态来表示当前行，那么在最开始就要单独处理出第一行和第二行。

对于判断两行是否冲突，我们选择二进制$\&$运算，如果对于两行的状态$K_1,K_2$来说，如果$(K_1 \& K_2) == 0$那么就可以说明这两行没有冲突（两个状态之间没有重合的），可以操作。



## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

const int M = 22;

const int NM = N * M / 2;

int n, m, mp[N][M], f[NM], cnt, num[NM];

int dp[N][NM][NM], now[NM];
int getnum(int x)
{
    //统计当前状态为x的时候有多少个炮兵（对答案的贡献）
    int res = 0;
    while (x)
    {
        res ++ ;
        x -= x & -x;
    }
    return res;
}
int main()
{
	scanf("%d%d", &n, &m);
	char ch[20];
	for (int i = 1; i <= n; i ++ )
	{
        //按照字符串读入
        scanf("%s", ch + 1);
		for (int j = 1; j <= m; j ++ )
		{
			//scanf("%c", &ch);
			if (ch[j] == 'H')
                mp[i][j] = 1;
			//printf("%c", ch);
		}
	}
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= m; j ++ )
			f[i] = (f[i] << 1) + mp[i][j];
    //直接处理每一位，有山地的位置为1
	now[ ++ cnt] = 0;
    //减少整体的时间空间，我们只存有用的位置
    for (int i = 1; i < (1 << m); i ++ )
    {
        if (i & (i << 1)) continue ;
        if (i & (i << 2)) continue ;
        if (i & (i >> 1)) continue ;
        if (i & (i >> 2)) continue ;
        //由于最两边的四个是不可以选的，直接跳过
        now[ ++ cnt] = i;
        num[cnt] = getnum(i);
    }
    for (int i = 1; i <= cnt; i ++ )
    {
        //对于第一行进行单独处理
        if ((now[i] & f[1]) == 0)
        {
            dp[1][i][0] = num[i];
        }
    }
    for (int i = 1; i <= cnt; i ++ )
    {
        //对于第二行进行单独处理
        if ((now[i] & f[2]) == 0)
        {
            for (int j = 1; j <= cnt; j ++ )
            {
                if ((now[i] & now[j]) == 0 && (now[j] & f[1]) == 0)
                {
                    dp[2][i][j] = num[i] + num[j];
                }
            }
        }
    }
    for (int i = 3; i <= n; i ++ )
    {
        //一个令人头疼的循环+判断嵌套
        for (int j = 1; j <= cnt; j ++ )
        {
            if ((now[j] & f[i]) == 0)
            {
                for (int k1 = 1; k1 <= cnt; k1 ++ )
                {
                    if ((now[j] & now[k1]) == 0 && (now[k1] & f[i - 1]) == 0)
                    {
                        for (int k2 = 1; k2 <= cnt; k2 ++ )
                        {
                            if ((now[j] & now[k2]) == 0 && (now[k2] & f[i - 2]) == 0 && (now[k2] & now[k1]) == 0)
                            {
                                dp[i][j][k1] = max(dp[i][j][k1], dp[i - 1][k1][k2] + num[j]);
                            }
                        }
                    }
                }
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= cnt; i ++ )
    {
        for (int j = 1; j <= cnt; j ++ )
        {
            ans = max(ans, dp[n][i][j]);
            //最终统计ans的最大值即可
        }
    }
    printf("%d\n", ans);
    return 0;

}
```

---

## 作者：soy_un_perro (赞：3)

这是一种不用处理前三行的状压DP。

因为m<=10，所以把每一行部署炮兵部队的状态作为“状态”，二进制的每一位1表示部署，0表示没有。同时把山地表示为1，平原表示为0，第i行的地形为dx[i]。

因为从上到下考虑，考虑第i行时要考虑第i-1，i-2行，而考虑i-1行时又要考虑第i-2，i-3行……所以令f[i][j][k]表示前i行，第i行状态为j，第i-1行状态为k时可以部署炮兵部队的最大值。

可得以下方程：

$f[i][j][k]=\max(f[i-1][k][l]+cnt[j])(j,k,l\in S )$

同时j&k==0,j&l==0,j&dx[i]==0。

初始化：$f[0][0][0]=0$，其它为$-\infty$。

其中S为一个行状态的合法集合，即状态中“1”两两之间间隔超过2。若一个状态i满足
```cpp
!(i&(i<<1))&&!(i&(i<<2))
```

那么i是合法状态。

答案：$\max(f[n][i][j]) (i,j\in S)$

因为已初始化，所以找答案时可不用判断i&j是否为0。

事实上，m=10时|S|=60，为了节省空间，可以把j,k定义为集合中相应状态的编号（下标）。框架中只要改初始化：

$f[0][1][1]=0$（为什么，见代码↓）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,s[102],cnt[102],tot;//s是可用集合，cnt是1的数目 
int f[102][72][72];//f的2、3维都是可用状态的编号
//经试验m=10时|s|=60，所以可以放心少开 
int dixing[102];//0平原，1山地，状态&地形!=0即炮兵在山地上 
char str[13];
void input()//输入O(nm) 
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",str);
		for(int j=0;j<m;++j)
		{
			dixing[i]<<=1;
			if (str[j]=='H')
				dixing[i]|=1;
		}
	}
}
int count1(int x)//计算1的个数 
{
	int sum=0;
	while(x) x-=x&-x,++sum;
	return sum;
}
void prework()//预处理合法集合O(2^m) 
{
	for(int i=0;i<1<<m;++i)
		if (!(i&(i<<1))&&!(i&(i<<2)))
		{
			s[++tot]=i;
			cnt[tot]=count1(i);//计算1的个数 
		}
}
int main()
{
	input();
	prework();
	memset(f,0xcf,sizeof(f));//f数组初始化 
	f[0][1][1]=0;
	for(int i=1;i<=n;++i)//DP O(n|s|^3) 
	for(int j=1;j<=tot;++j)
	for(int k=1;k<=tot;++k)
	for(int l=1;l<=tot;++l)
	if ((s[j]&s[k])==0&&(s[j]&s[l])==0&&(s[j]&dixing[i])==0)
		f[i][j][k]=max(f[i-1][k][l]+cnt[j],f[i][j][k]);
	int ans=0;//寻找答案 
	for(int i=1;i<=tot;++i)
		for(int j=1;j<=tot;++j)
			ans=max(f[n][i][j],ans);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：BeyondStars (赞：3)

注意强调一下main读入地图的时候m必须从0开始.
首先我们考虑状态。我们不难想到~~状压dp套路~~以第$i$行，当前行的状态压缩过后在集合`S*`为$j$的编号的状态，上一行为编号为$k$的状态作为整个题的状态。可以写出如下递推式（前提是这个状态可以转移，后文有如何转移）:(count(x)表示x的二进制表示下有多少个1)
$$dp[i][j][k] = max(dp[i-1][k][l]+count(j))$$ 


那么什么状态是可行的呢？首先我们要考虑$i-2$行，当行前状态$j$与$i-1$行状态$k$与$i-2$行的状态$l$要满足$$j\&k=0\ \ j\&l=0  \ \ \ k\&l = 0$$
**当然了，还有最重要的一点**那就是整个地图，我们同样压位压到二进制数里面，只需要在状态转移以前判断这个状态可不可行就行。  
前文所说的集合`S`，其实表示的是可行的状态的集合。什么意思呢？我们发现如果一个地方放炮兵，那么左右两格之内都不能放炮兵。也就是说，二进制状态压缩以后，一位为1，那么它左右两位都必须为0。我们就只需要把这个集合提前算出来，极大简化了复杂度，因为这个集合并不大！  
那么，这道题就算完了，总复杂度$O(n|S|^3)$,由于$|S|$很小，所以整个算法表现非常优秀
```cpp
//
// Created by dhy on 18-12-16.
//
#include <cstring>
#include <iostream>
using namespace std;
int dp[110][77][77];
int S[100];
int map[101];
int cnt[101];
int top;
int n,m;
int getBit(int x){
    int c = 0；
    while(x)c++,x-=x&-x;
    return c;
}
bool ok(lnt x){
    if(x&(x<<1))return false;
    if(x&(x<<2))return false;
    return true;
}
void init(){
    int end = 1<<m;
    for(int i = 0;i<end;i++)if(ok(i))S[top] = i,cnt[top++] = getBit(i);
}
bool valid(int I,int x){
    if(map[l]&x)return false;
    return true;
}
inline int max(int a,int b){return a  >  b  ?  a  ：b;}
int work(){
    memset(dp,-1, sizeof(dp));
    dp[0][0][0] = 0;
    int ans = 0;
    for(int i = 0;i<top;i++){
        if(valid(1,S[i])){
            dp[1][i][0] = cnt[i];
            ans = max(ans,dp[1][i][0]);
        }
    }
    for(int i = 2;i<=n;i++){
        for(int j = 0;j<top;j++){
            if(valid(i,S[j]))
                for(int k = 0;k<top;k++){//i-1
                    if(valid(i-1,S[k])&&(S[j]&S[k])==0){
                        int last = 0;
                        for(int l = 0;l<top;l++){//i-2
                            if(dp[i-1][k][l]!=-1&&(S[l]&S[j])==0&&valid(i-2,S[l])){
                                last = max(last,dp[i-1][k][l])
                            }
                        }
                        dp[i][j][k] = max(dp[i][j][k],last+cnt[j]);
                        if(i==n)ans = max(ans,dp[i][j][k]);
                    }
            }
        }
    }
    return ans;

}
int mian() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++){
        for (int j = 0; j < m; j++) {
            char t;
            cin >> t;
            if (t == 'H')map[i] |= (1 << (m - 1 - j));
        }
    }
    init();
    cout<<work()<<endl;
    return 0;
}
```


---

## 作者：人殇物已非 (赞：2)

状压DP基础题，不过相对其他的简单状压DP，这个题相对有些复杂，有很多注意点。

首先这个题用到的一个套路是，当状态枚举过多时，如本题枚举前两行需要$1024^3$，太大了，但是对于每行都用通用的判断状态是否合法的方法，所以可以处理出来那些对于每行的可行方案保存下来，每次用这个循环，复杂度大大降低。本题来说就剩下不到100了。就算$100^3$都绰绰有余。

然后按照往常的套路，设$dp$方程$f[n][sta][sta]$因为要考虑上一行和上上行，所以要两个01串的$sta$状态。

然后初始化的时候初始化出前两行，转移的时候枚举前两行可行状态计算炮兵数量取最大值就可以了。答案即是第$n$行的两个$sta$枚举下的最大值。

#### PS:按理来说，是爆空间的，需要滚动一下，但是luogu上面的空间是按照用了多少计算的，所以可以过。（看脸黑不黑。。。）

$code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=101,maxm=11;
int n,m;
int line[maxn];
int sta[1<<maxm];
int f[maxn][1<<maxm][1<<maxm];
int num=0;
int get(int x){
    int anss=0;
    while(x!=0)
    {
        if((x&1)!=0) anss++;
     	x>>=1;
    }
    return anss;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int sum=0;
        for(int j=m-1;j>=0;j--){
            char c;
            scanf(" %c",&c);
            if(c=='H') sum+=(1<<j);
        }
        line[i]=sum;
    }
    for(int i=0;i<=(1<<m)-1;i++){
        if((i&(i<<2))==0 && (i&(i<<1))==0) sta[++num]=i;
    }
	for(int i=1;i<=num;i++){
   		for(int j=1;j<=num;j++){
   			if((sta[i]&line[2])==0 && (sta[j]&line[1])==0 && (sta[i]&sta[j])==0){
               f[2][sta[i]][sta[j]]=get(sta[i])+get(sta[j]);
            }   
       }
   }
    for(int i=3;i<=n;i++){
        for(int j1=1;j1<=num;j1++){ //上上行 
            for(int j2=1;j2<=num;j2++){//上行 
                for(int j=1;j<=num;j++){//当前 
                    if(line[i]&sta[j]) continue;
                    if(line[i-1]&sta[j2]) continue;
                    if(line[i-2]&sta[j1]) continue;
                    if(sta[j]&sta[j1] || sta[j]&sta[j2] || sta[j1]&sta[j2]) continue;
                    f[i][sta[j]][sta[j2]]=max(f[i][sta[j]][sta[j2]],f[i-1][sta[j2]][sta[j1]]+get(sta[j]));
                }
            }
        } 
    }
    int ans=0;
    for(int i=1;i<=num;i++){
        for(int j=1;j<=num;j++){
            ans=max(ans,f[n][sta[i]][sta[j]]);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：niolle (赞：2)


```
/*
调试注意：
1.==运算符运算先于与运算符 ，故应加上括号 
2.本题所求的是最多炮兵个数而不是炮兵摆放方案总数,故DP方程应为dp[i][j][k](dp[第i行][第i行选取第j种摆放一行炮兵的方案][第i-1行选取第k种摆放一行炮兵的方案])=max(num[j]+dp[i-1][k][l])而不是=num[j]+Sigma dp[i-2][k][l];
3.位运算全部加括号
*/ 
#include<iostream> 
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rep(i,a,b) for(long long i=a;i<=b;i++)
#define del(a) memset(a,0,sizeof(a));
#define cl(a) memset(a,-1,sizeof(a));
using namespace std;
typedef long long ll;
ll n,m;
ll a[105],d[2000],num[2000],sum,dp[105][1025][1025];
ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while('0'<=ch && ch<='9'){x=x*10+ch-'0'; ch=getchar();}
	return x*f;
}
void pre()
{
	rep(i,0,(1<<n)-1)
	{
		if(i&(i<<1) || (i>>1)&(i<<1)) continue;
	    d[++sum]=i;
	    rep(j,0,n) if(i&(1<<j)) num[sum]++;
	}
}
bool check(ll i,ll j)
{
	rep(g,0,n)
	{
		if(d[j]&(1<<g) && !(a[i]&(1<<g))) 
		{
			printf("%lld\n",g);
			return false;
		}
	}
	return true;
}
void DP()
{
	rep(i,1,m)
	{
		rep(j,1,sum)
		{
			if(i==1)
			{
				if((d[j]&a[i])==d[j])dp[i][j][0]=num[j];
				continue;
			} 
			if(i==2)
			{
				rep(k,1,sum)
				{
					if(!(d[k]&d[j]) && (a[i]&d[j])==d[j]) dp[i][j][k]=num[j]+dp[i-1][k][0];
					//printf("dp[%lld][%lld][%lld]=%lld,%lld,%lld,%lld,%lld,%lld\n",i,j,k,dp[i][j][k],d[j],d[k],d[j]&d[k],a[i]&d[j],a[i]);
				}
				continue;
			}
			rep(k,1,sum){
				rep(l,1,sum)
					if(!(d[j]&d[k]) && !(d[j]&d[l]) && !(d[k]&d[l]) && (d[j]&a[i])==d[j]) dp[i][j][k]=max(dp[i][j][k],dp[i-1][k][l]+num[j]);
				//printf("dp[%lld][%lld][%lld]=%lld,%lld,%lld,%lld\n",i,j,k,dp[i][j][k],d[j],d[k],d[j]&d[k]);
				}
		}
	}
	ll maxn=-1;
	if(m!=1)
		rep(i,1,sum)
	    	rep(j,1,sum) maxn=max(dp[m][i][j],maxn);
	else rep(i,1,sum) maxn=max(maxn,dp[m][i][0]);
	cout<<maxn;
}
int main()
{
	m=read();n=read();
	rep(i,1,m)
	{
		rep(j,1,n)
		{
			char ch=getchar();
			while(ch!='H' && ch!='P') ch=getchar();
			if(ch=='H') a[i]*=2;
			else a[i]=a[i]*2+1;
		}
	}
	pre();
	DP();
	return 0;
}
/*
8 4
HPPH
PPPP
HPPH
PHHP
PHHP
HPPH
PPPP
HPPH
*/
```

---

## 作者：xfydemx (赞：2)

刚学状压DP，随便切了切题居然两道一遍AC，高兴之余强发一波！

首先这题类似于n国王问题，对每一行，考虑将每个位置放不放用二进制来表示，类似的，有方程
f[i][a][b]=max(f[i][a][b],f[i-1][b][v]+sum[a]);

其中由于每行与上两行有关，需从前两行的状态转移而来，即上式的a和b
预处理和n国王也是类似的，就不再赘述了。

若感觉困难，建议先做P1896 P1879



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
using namespace std;
#define il inline
#define rg register
const int N=100005;
const int M=1000000;
int m,n,r,t,g[1<<12],c[1<<12],sum[1<<12];
int f[102][69][69];
il bool check(int x,int y){//即与标准串c进行比对，
	//c表示地形是否允许，这里check剪掉不合法的放法
    int A,B;
    for(int i=1;i<=10;i++){
        A=x&(1<<(i-1)),B=y&(1<<(i-1));
        if(!A&&B) return 0;
    }
    return 1;
}
il int get_sum(int x){//该行的二进制的1的个数，即放了几个炮兵
    int k;
    for(int i=1;i<=10;i++){
        if(x&(1<<(i-1))) k++;
    }
    return k;
}
int main(){ 
    cin>>m>>n;
    char q;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            cin>>q;
            if(q=='P') c[i]=(c[i]|(1<<j-1));
        }
    }
   
    int full=(1<<10)-1;
    for(int i=0;i<=full;i++){
        if(!(i&(i<<2))&&!(i&(i>>2))&&!(i&(i>>1))&&!(i&(i<<1))) g[++t]=i;
        int u=g[t];
        sum[t]=get_sum(u);
    }
    for(int i=1;i<=t;i++){//对第一行单独考虑
        int A=c[1],B=g[i];
        if(!check(A,B)) continue;
        f[1][i][0]=sum[i];
    }
    //对第二行单独考虑
    for(int i=1;i<=t;i++){//2
        int A=c[2],B=g[i];
        if(!check(A,B)) continue;
        for(int j=1;j<=t;j++){//1
            int C=g[j];
            if(B&C) continue;
            f[2][i][j]=max(f[2][i][j],f[1][j][0]+sum[i]);
        }
    }
    for(int i=3;i<=m;i++){
        for(int a=1;a<=t;a++){//当前行
            int A=c[i],B=g[a];
            if(!check(A,B)) continue;
            for(int b=1;b<=t;b++){//上1
                int C=g[b];
                if(C&B) continue;
                for(int v=1;v<=t;v++){//上2
                    int D=g[v]; 
                    if(D&B) continue;
                    f[i][a][b]=max(f[i][a][b],f[i-1][b][v]+sum[a]);
                }
            }
        }
    }
    int ans=0;
    for(int i=1;i<=t;i++){
        for(int j=1;j<=t;j++){
            ans=max(ans,f[m][i][j]);
        }
    }
    cout<<ans<<endl;
    return 0;//由于不知名的原因，提交需使用c++ 11，c++会WA
    //原因还望神犇告知
}

```

---

## 作者：曹老师 (赞：2)

**状压DP**

**位运算很重要！**

首先从题目中可以看出有很多点是多余的

我们就可以在一次遍历的时候去掉它们

一次遍历从0到2^m-1 求出合法的数据保存在a中

同时记录下在合法的数据中 1的出现次数 保存在b中

**检查是否合法的方法：**

通过比较两个1之间的距离 即可判断是否合法

若两个1之间的距离小于等于2 则非法

所以 top变量初始值为-2

还要用临时变量p来记一下是否应该把这个数放到a数组中

把合法的数据放到a数组中 避免了很多无用的运算 时间复杂度很小很小

**预处理图**

题目中的地图是根据P H来判断地形的

因此要把地形处理出来 初始值为0 P的时候为1

这样以后就直接可以现用每一行的地图 减少时间

单独处理第1/2行

因为要确保处理的行的前两行是合法的

因此 要特殊处理一下1/2两行

第一行就直接判断是否和地形相符合 再加上1的个数即可

第二行两重循环 先判断第二行是否满足地形 再循环第一行 判断第一行和第一行的地形 和第二行是否合法

判断过后 把合法的放入f2[j]

**大于等于3行处理方法**

三重循环

这一行 上一行 上上行

每一个都要保证满足每一个的地形

还要保证满足上下行

```cpp
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
int f[101][1025][1025],n,m,a[1025],tot=0,b[1025],ans=0,mmap[105];
char map[101][11];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>map[i][j];
    for(int i=0;i<(1<<m);i++)//预处理0~2^m 
    {
        int top=-2,p=0,q=0;
        for(int j=1;j<=m;j++)
        {
            if((i>>(j-1))&1>0)
                if(j-top<=2)
                {
                    p=1;
                    break;
                }
            else
            {
                top=j;
                q++;
            }
        }
        if(p==0)
        {
            a[tot]=i;
            b[tot]=q;
            tot++;
        }
    }
    for(int i=1;i<=n;i++)//预处理地图 
        for(int j=1;j<=m;j++)
            if(map[i][j]=='P')
                mmap[i]=mmap[i]|(1<<j-1);
    //i=1:
    for(int i=1;i<tot;i++)
    {
        if((a[i]&mmap[1])!=a[i])
            continue;
        f[1][i][0]=max(f[1][i][0],b[i]);
        ans=max(ans,f[1][i][0]);
    }
    //i=2:
    for(int i=0;i<tot;i++)
    {
        if((a[i]&mmap[2])!=a[i])
            continue;
        for(int j=0;j<tot;j++)
        {
            if((a[j]&a[i])!=0||(a[j]&mmap[1])!=a[j])
                continue;
            else
                f[2][i][j]=max(f[2][i][j],f[1][j][0]+b[i]);
        ans=max(ans,f[2][i][j]);
        }
    }
    //i>=3:
    for(int i=3;i<=n;i++)
        for(int j=0;j<tot;j++)
        {
            if((a[j]&mmap[i])!=a[j])
                continue;
            for(int k=0;k<tot;k++)
            {
                if((a[k]&mmap[i-1])!=a[k]||(a[k]&a[j])!=0)
                    continue;
                for(int r=0;r<tot;r++)
                {
                    if((a[r]&a[k])!=0||(a[r]&mmap[i-2])!=a[r]||(a[r]&a[j])!=0)
                        continue;
                    f[i][j][k]=max(f[i][j][k],f[i-1][k][r]+b[j]);
                }
            ans=max(ans,f[i][j][k]);
            }
        }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Minakami_Yuki (赞：1)

[更好的阅读体验](https://minagami.github.io/2019/09/05/Luogu-P2704-NOI2001-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)

学不来 `getchar()`

## 题目链接

[P2704 [NOI2001]炮兵阵地](https://www.luogu.org/problem/P2704)

## 题意简述

给你一个棋盘，让你放置一些棋子，攻击范围是上下左右 $2$ 格。有一些格不允许放置棋子。求最多能放置多少棋子互不攻击。


## 解题思想

攻击范围是 $2$ 格，所以我们考虑状压两行。

然后以行为阶段，状态为两行，转移一行，更新最大值就行了。

很多人的状态棋子数统计是 $O(2^m\log m)$ 的，其实可以 $\mathrm{dfs}$ 做到 $O(2 ^ m)$。

具体实现烦请看一下代码。

## 参考代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cctype>

inline int read() {
	char ch = getchar(); int r = 0, w = 1;
	while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
	while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}
	return r * w;
}

void print2(int x, int len) {
	if(len) {
		print2(x >> 1, len - 1);
		printf("%d", x & 1);
	}
}

const int N = 11;

char ch;
int n, m, ans = 0;
int cant[101], dp[1 << N][1 << N][3], s[1 << N];

void dfs(int sit, int sum, int now) {
	if(now >= m) {
		s[sit] = sum;
		return;
	}
	dfs(sit + (1 << now), sum + 1, now + 1);
	dfs(sit, sum, now + 1);
}

inline int max(int a, int b) {return a > b ? a : b;}

int main() {
	n = read(), m = read();
	dfs(0, 0, 0);
	for(register int i = 0; i < n; i++) {
	    for(register int j = 0; j < m; j++) {
			std::cin >> ch;
	        cant[i] = (cant[i] << 1) + (ch == 'H');
	    }
	}
	for(register int i = 0; i < (1 << m); i++) 
		if(!((i & cant[0]) || (i & (i << 1)) || (i & (i << 2))))
			dp[0][i][0] = s[i];
	for(register int i = 0; i < (1 << m); i++) {
		for(register int j = 0; j < (1 << m); j++) {
			if(!((i & j) || (i & cant[0]) || (i & (i << 1)) || (i & (i << 2)) || (j & cant[1]) || (j & (j << 1)) || (j & (j << 2)))) {
				dp[i][j][1] = s[i] + s[j];
			}
		}
	}
	for(register int i = 2; i < n; i++) {
		for(register int j = 0; j < (1 << m); j++) {
			if((j & (cant[i - 1])) || (j & (j << 1)) || (j & (j << 2))) continue;
			for(register int k = 0; k < (1 << m); k++) {
				if((k & cant[i]) || (j & k) || (k & (k << 1)) || (k & (k << 2))) continue;
				for(register int S = 0; S < (1 << m); S++) {
					if((S & j) || (S & k) || (S & cant[i - 2]) || (S & (S << 1)) || (S & (S << 2))) continue;
					dp[j][k][i % 3] = max(dp[j][k][i % 3], dp[S][j][(i - 1) % 3] + s[k]);
				}
			}
		}
	}
	for(register int i = 0; i < (1 << m); i++) {
		for(register int j = 0; j < (1 << m); j++) {
			ans = max(ans, dp[i][j][(n - 1) % 3]);
		}
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：斗神_君莫笑 (赞：1)

本题本质上就是P1879玉米田的升级版   
思想也是正规的状压dp  
但是因为增加影响范围，代码变得更加复杂  
我们用f[x][i][j]表示第x行状态为i，第x-1行状态为j  
显然需要`100*1024*1024`空间，MLE   
考虑到该层状态仅仅由上一层状态转移  
所以使用滚动数组压掉半维  
一定注意处理好运算符的优先级，不要吝啬括号  
本代码因为优先级问题开O2会30 ~~懒得改~~   
详情见代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[2][1<<10][1<<10],siz[1<<10],num[1<<10],a[110][1<<10];
inline int get_num(int x){//计算一个状态中1的数量，也就是炮兵的数量 
	int cnt=0;
	while(x)cnt+=x&1,x>>=1;
	return cnt;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	int maxx=1<<m;
	for(int i=1;i<=n;++i){
		char ch=getchar();
		while(ch!='P'&&ch!='H')ch=getchar();//读取奇奇怪怪的字符 
		int all=0;
		for(int j=1;j<=m;++j){
			all=(all<<1)|(ch=='P');//将本行状态压为一个二进制数，可放置为1 
			ch=getchar();
		}
		int cnt=0;
		for(int j=0;j<maxx;++j)
			if(!(j&(j<<1))&&!(j&(j<<2))&&!(j&(j>>1))&&!(j&(j>>2))&&((j&all)==j))
				//和左右两位的状态都不冲突，并且合规放置 
				a[i][++cnt]=j;//压入本行可用状态 
		siz[i]=cnt;//统计可用状态数目 
	}
	for(int i=0;i<=maxx+1;++i)
		num[i]=get_num(i);//见上 
	for(int i=1;i<=siz[1];++i)
		for(int j=1;j<=siz[2];++j){//预处理前两行的合法状态 
			int x=a[1][i],y=a[2][j];
			if(!(x&y))//两种状态没有列的重复 
				f[0][j][i]=num[x]+num[y];//炮兵数目相加 
		}
	int cnt=0;
	for(int i=3;i<=n;++i){
		cnt^=1;//压缩一维 
		for(int j=1;j<=siz[i];++j)
			for(int k=1;k<=siz[i-1];++k)
				for(int l=1;l<=siz[i-2];++l)
					if((!(a[i][j]&a[i-1][k]))&&(!(a[i][j]&a[i-2][l]))&&(!(a[i-1][k]&a[i-2][l])))//三行状态都没有列的重复 
						f[cnt][j][k]=max(f[cnt][j][k],f[cnt^1][k][l]+num[a[i][j]]);//和上一行的状态加放置炮兵数目取max 
	}
	int ans=0;
	for(int i=1;i<=siz[n];++i)
		for(int j=1;j<=siz[n-1];++j)
				ans=max(ans,f[cnt][i][j]);//统计答案 
	printf("%d",ans);
	return 0;
}
```


---

## 作者：LeeChain (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int n,m,num[60];//n:行数 m:列数 num:每一种状态可放置的炮兵数 
char s[110][15];//地图读入 
int rec[110];//每一行的初始状态，即该位置是否有山 
int state[70],top;//top:合法状态数 state[i]:存储第i个合法状态 
int dp[110][70][70];//dp[i][j][k]代表第i行状态为k，i-1行状态为j时最多可放的炮兵数 
int main()
{
	cin>>n>>m;
	for(int i=0;i<(1<<m);i++)
	{
		if((i&(i<<1)||(i&(i<<2))))continue;//判断同一行中相邻两行中的冲突情况 
		int k=i;
		while(k)//统计该合法状态可以防放置炮兵数
		{
			num[top]++;
			k&=(k-1);
		} 
		state[top++]=i;//存储该合法状态 
	}
	for(int i=0;i<n;i++)//读入 
	{
		cin>>s[i];
		for(int j=0;j<m;j++)
			if(s[i][j]=='H')
		 	rec[i]|=(1<<j);//如果该位置为山地，则置为1 
	}
	for(int i=0;i<top;i++)//初始化第一行的状态 
	{
		if(state[i]&rec[0])continue;
		dp[0][0][i]=num[i];
	}
	
	for(int i=1;i<n;i++)
	{
		for(int j=0;j<top;j++)//当前行状态 
		{
			if(state[j]&rec[i])continue;//当前行与初始状态冲突 
			for(int k=0;k<top;k++)//i-1行状态 
			{
				if(state[j]&state[k])continue;//当前行与i-1冲突 
				for(int t=0;t<top;t++)//i-2行状态 
				{
					if(state[j]&state[t])continue;//当前行与i-2行冲突 
					if(state[k]&state[t])continue;//i-1行与i-2行冲突
					dp[i][k][j]=max(dp[i][k][j],dp[i-1][t][k]+num[j]); 
				}
			}
		}
	}
	int ans=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<top;j++)
			for(int k=0;k<top;k++)
				ans=max(ans,dp[i][j][k]);
	cout<<ans;
	return 0;
}

```

---

## 作者：AVALON_7 (赞：1)

昨天考试发现自己动归完全就是一个智障。。。然后跑去做了一两道动归的题。。炮兵阵地算比较经典的吧。

主要代码来自某大佬的微博。。<http://blog.sina.com.cn/s/blog\_6635898a0100qe3w.html>

然后因为实在不习惯从0开始定义数组就魔改了一点点。。

感觉注释什么的特别详细。。于是就照搬过来了

其他大佬神犇可能还有其他很多做法。。求不喷orz

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;

inline int read()
{
    int w=1,x=0;char ch=0;
    while(ch< '0'||ch >'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return w*x;
}

int map[105];// map[i]的二进制表示每一行的H分布状态。
int cnt=0,stk[65],sum[65];// cnt表示状态总数，stk[i]表示第i种状态，sum[i]表示第i种状态安装的大炮数量。
int f[105][65][65];//dp[r][i][k]表示第r行的状态为k，第r-1行的状态为i时候，前r行最多能够安装的大炮数量。
 
bool ok(int x)//  判断状态x是否符合，即是否会出现两个大炮间隔小于2。
{        
    if(x & (x<<1)) return false;
    if(x & (x<<2)) return false;
    return true;
}
 
int getSum(int x)//  求出状态x中安装了多少门大炮，x的二进制有几个1。
{     
    int num = 0;
    while(x>0)
    {
        if(x&1) num++;
        x=x>>1;
    }
    return num;
}
 
void findStk(int n)
{   //  预处理求出多有可能的状态。
    for(int i=0;i<(1<<n);i++)
        if(ok(i))
        {
            stk[++cnt] = i;
            sum[cnt] = getSum(i);
        }
}
int n,m;
int main()
{
    
    cin>>n>>m;
    memset(f,-1,sizeof(f));
    for(int r=1;r<=n;r++)
        for(int c=1;c<=m;c++)
        {
            char tmp;
            cin >> tmp;
            if(tmp == 'H') map[r] |= (1<<c-1);
        }
    
    findStk(m);
    
    for(int i=1;i<=cnt;i++)    //  第一行的状态特殊考虑。
        if(!(stk[i]&map[1]))
            f[1][1][i] = sum[i];
            
    for(int r=2;r<=n;r++)
        for(int i=1;i<=cnt;i++)//  枚举第r行的状态。
        {     
            if(stk[i]&map[r]) continue;
            for(int j=1;j<=cnt;j++)//  枚举第r-1行的状态。
            {     
                if(stk[i]&stk[j]) continue;
                for(int k=1;k<=cnt;k++)//  枚举第r-2行的状态。
                {     
                    if(stk[i]&stk[k]) continue;
                    if(f[r-1][k][j]==-1) continue;
                    f[r][j][i] = max(f[r][j][i], f[r-1][k][j] + sum[i]);
                }
            }
        }
        
    int ans=0;
    for(int i=1;i<=cnt;i++)
        for(int j=1;j<=cnt;j++)
            ans = max(ans,f[n][i][j]);
            
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：SNiFe (赞：1)

这道题和**P1879 [USACO06NOV]玉米田Corn Fields**有类似的地方，但这道题可以看为那道题的升级版，所以我建议没做过**玉米田**的可以先做一下**玉米田**和**P1896 [SCOI2005]互不侵犯King**。

#1.
解此题的关键在于要知道第i行的状态是由前两行的状态决定的，所以要预处理出第一行和第二行的所有状态，然后从第三行（因为第一二行已处理）开始枚举，同时枚举第当前行的前一行和上上行。

#2.
##同时还需注意预处理时应把每种情况所能放置炮兵数求出来：

```cpp
for(int i=0;i<(1<<m);i++)
    if(!(i&(i<<2))&&!(i&(i<<1)))
    {
        sit[++k]=i;
        int t=i;
        while(t)
        {
            sum[k]+=t%2;
            t/=2;
        }
    }
```
#3.
##（1）dp方程是什么呢？

##f[i][l][j]=max(f[i][l][j],f[i-1][p][l]+sum[j]);（这里大家要深刻理解f[i][l][j]的含义，千万不要把顺序弄反）

f[i][l][j]的意思是第**i**行的**j**状态是由上一行的**l**状态得出来的。

##（2）为什么要求max呢？

首先先不论正确性，交上去会wa5个点，实际值都比答案小；其次这道题和**玉米田**不同的是此题求的是最多炮兵数（是最优性问题求解），而**玉米田**问的是总方案数，这是有很大区别的；然后既然是是最优性问题求解，那么肯定要从前两行的所有状态中求出使当前行状态最优的状态，满足阶段最优和无后效性原则。

#4.
最后从最后一行（即最终状态）中找出最优状态，这就是解。

#5.代码：

    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long f[105][500][500],sit[5000],n,k=0,ans=-1,m,map[5000],sum[5000];
int main()
{
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("\n");
        for(int j=1;j<=m;j++)
        {
            char s;
            map[i]=map[i]<<1;
            scanf("%c",&s);
            if(s=='H')map[i]=map[i]|1;//这里要让H为1，P为0，这样方便储存状态； 
        }
    }
    for(int i=0;i<(1<<m);i++)//处理炮兵放置方案（情况） 
    if(!(i&(i<<2))&&!(i&(i<<1)))
    {
        sit[++k]=i; //放置方案 
        int t=i;
        while(t)
        {
            sum[k]+=t%2;//当前状态放置炮兵数量 
            t/=2;
        }
    }
    for(int i=1;i<=k;i++)if(!(sit[i]&map[1]))f[1][1][i]=sum[i];//处理第一行的状态 
    //下面一个for是处理第二行的状态  
    for(int i=1;i<=k;i++)//枚举第二行所有炮兵放置情况 
    if(!(sit[i]&map[2]))
        for(int j=1;j<=k;j++)//枚举第一行…… 
        {
            if(!(map[1]&sit[j])&&!(sit[i]&sit[j]))f[2][j][i]=sum[i]+sum[j];
        }
    for(int i=3;i<=n;i++)
        for(int j=1;j<=k;j++)//枚举当前行…… 
        if(!(map[i]&sit[j]))
            for(int l=1;l<=k;l++)//枚举上一行…… 
            if(!(sit[j]&sit[l])&&!(map[i-1]&sit[l]))
                for(int p=1;p<=k;p++)//枚举上上行…… 
                if(!(sit[p]&sit[l])&&!(map[i-2]&sit[p])&&!(sit[p]&sit[j]))
    f[i][l][j]=max(f[i][l][j],f[i-1][p][l]+sum[j]);
    for(int i=1;i<=k;i++)for(int j=1;j<=k;j++)ans=max(f[n][j][i],ans);//处理答案 
    printf("%lld",ans);
}

```

---

## 作者：cheeseYang (赞：1)

被这题坑了一天，最后发现把j打成i了（我一点都不生气），最后想说的就是很基础的一道状压，三维转移，f[i][j][k]表示第i行，第i行的状态为j ,第i-1行的状态为k，预处理左右满足条件的情况，再预处理前两行，从第三行开始DP，注意位运算最好全部打上括号，因为位运算的优先级是个玄学问题，非常玄学，还有就是maxm开成1<<10,否则会RE，我就被坑了好几次，最后状态转移方程：f[i][j][k]=max(f[i][j][k],f[i-1][k][w])w是上两行的状态，最后输出最后一行最大的那个状态

    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=102;
const int maxm=1<<10;
int dp[maxn][maxm][maxm],st[maxm],cnt[maxm],mapp[maxn],n,m,k;
int pd(int x){
    return ((x&(x<<1))+(x&(x<<2)));    
}
int pd2(int x,int y){
    return (mapp[x]&st[y]);    
}
int main(){
    //freopen("test.in","r",stdin);
    //freopen("test.out","w",stdout);
    cin>>n>>m;
    getchar();
    for(int i=1;i<=n;++i,getchar()){
        for(int j=1;j<=m;++j){
            char c;
            scanf("%c",&c);
            if(c=='H')mapp[i]+=1<<(m-j);
        }
        //cout<<mapp[i]<<endl;
    }
    for(int i=0;i<(1<<m);++i)    
        if(!pd(i)){
            st[k]=i;
            cnt[k]=__builtin_popcount(i);
            //cout<<st[k]<<" "<<cnt[k]<<endl;
            k++;
        }
    for(int i=0;i<k;++i)
        if(!pd2(1,i)){
            dp[1][i][0]=cnt[i];
            //cout<<dp[1][i][0]<<endl;    
        }
    for(int i=0;i<k;++i){
        if(pd2(2,i))continue;
        for(int f=0;f<k;++f){
            if(pd2(1,f))continue;
        //    cout<<st[i]<<" "<<st[f]<<endl;
            if((st[i]&st[f])==0){
                dp[2][i][f]=cnt[i]+cnt[f];
                //cout<<dp[2][i][f]<<endl;    
            }
        }
    }
    for(int i=3;i<=n;++i)
        for(int j=0;j<k;++j){
            if(pd2(i,j))continue;    
            for(int f=0;f<k;++f){
                if(pd2(i-1,f))continue;
                for(int w=0;w<k;++w){
                    if(pd2(i-2,w))continue;
                    if((st[j]&st[f])==0 && (st[j]&st[w])==0 && (st[f]&st[w])==0){
                        dp[i][j][f]=max(dp[i][j][f],dp[i-1][f][w]+cnt[j]);  
                        //cout<<dp[i][j][f]<<endl;
                    }
                }
            }
        }
    //cout<<k<<endl;
    int ans=0;
    for(int i=0;i<k;++i)
        for(int j=0;j<k;++j)
            ans=max(ans,dp[n][i][j]);
    cout<<ans;
    return 0;
}
```

---

## 作者：陈昶旭 (赞：1)

状态压缩

```cpp
#include<iostream>
using namespace std;
int n,m,ans;
int field[1024];//地图
int d[2][1024][1024];//结果 滚动数组
int valid[1024]; //是否有效
int js(int x)
{
int s=0;
while(x>0)
{
s+=x%2;
x=x>>1;
}
return s;
```
}//求各位数之和
```cpp
bool isvalid(int x)
{
while(x>0)
{
if(x%2==1){if(((x>>1)&1==1)||((x>>2)&1==1))return false;}
x=x>>1;
}
return true;
```
}//判断是否满足条件
```cpp
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
{
string s;
cin>>s;
int d=0;
for(int j=0;j<m;j++)if(s[j]=='P')d=d|(1<<j);
field[i]=d;
```
}//输入地图并存起来:m<n 用行存
```cpp
for(int i=0;i<(1<<m);i++)if(isvalid(i))valid[i]=true;
for(int i=1;i<=n;i++)
for(int j=0;j<(1<<m);j++)
{
int sum=js(j);
if(valid[j]&&(~field[i]&j)==0)
for(int r1=0;r1<(1<<m);r1++)if(valid[r1]&&(j&r1)==0)for(int r2=0;r2<(1<<m);r2++)if(valid[r2]&&(j&r2)==0)
{
d[i%2][j][r1]=max(d[i%2][j][r1],d[(i-1)%2][r1][r2]+sum);//滚动数组+动态规划，不用滚动数组会超时
if(i==n)ans=max(ans,d[i%2][j][r1]);//结果
}
}
cout<<ans;
return 0;
}
```

---

## 作者：重回巅峰！ (赞：1)

状态压缩+滚动数组。。。。。。F[I,J]表示当前行状态为I，上一行状态为J的最大值，G[I,J]表示上一行的F数组







```cpp
var
  map:array[0..105]of longint;
  b,q:array[0..1 shl 11]of longint;
  f,g:array[0..1 shl 10,0..1 shl 10]of longint;
  tot,n,i,j,m,k,ans,x,s,kk:longint;
  ch:char;
function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;
begin
  readln(n,m);
  for i:=1 to n do
  begin
    s:=0;
    for j:=1 to m do
    begin read(ch); if ch='P' then x:=0 else x:=1; s:=(s shl 1)+x; end;
    map[i]:=s;
    readln;
  end;
//  for i:=1 to n do writeln(map[i]);
  for i:=0 to (1 shl m)-1 do
  if (i and(i shl 1)=0)and(i and(i shl 2)=0) then
  if (i and (i shr 1)=0)and(i and (i shr 2)=0) then
  begin inc(tot); b[tot]:=i; j:=i;
        while j>0 do begin if j and 1=1 then inc(q[tot]); j:=j shr 1; end;
  end;
 // for i:=1 to tot do writeln(b[i],' ',q[i]);
  for i:=1 to tot do if (b[i] and map[1]=0) then g[b[i],0]:=q[i];
  for i:=1 to tot do
    for j:=1 to tot do
    if (b[i] and b[j]=0)and(b[i] and map[2]=0) then
    f[b[i],b[j]]:=max(f[b[i],b[j]],g[b[j],0]+q[i]);
  g:=f; fillchar(f,sizeof(f),0); 
  for i:=3 to n do
  begin
    for j:=1 to tot do
    if ( b[j] and map[i]=0) then
      for k:=1 to  tot do
        for kk:=1 to tot do
        if (b[j] and b[k]=0)and(b[j] and b[kk]=0) then
        f[b[j],b[k]]:=max(f[b[j],b[k]],g[b[k],b[kk]]+q[j]);
    g:=f; fillchar(f,sizeof(f),0);
  end;
  for i:=1 to tot do
    for j:=1 to tot do
    if g[b[i],b[j]]>ans then ans:=g[b[i],b[j]];
  writeln(ans);
end.

```

---

## 作者：Drinkwater (赞：1)

很经典的状压DP可以说是入门题，还有POJ的CORN FIELD，都是十分经典，今天好好研究了一下状压DP，无非就是将所有状态筛一遍，选出可用状态然后运用位运算判断该状态当前是否可行,推荐一篇博客  <http://blog.csdn.net/accry/article/details/6607703>。这道题我们用dp[i][j][k]表示第i行状态为k，i-1行状态为j，由于当前行的状态是否可行需要之前的两行来决定，所以本来要开4维的但是空间会炸，但是时间上是可以承受，所以我们选择降维，多一层枚举。怎么筛出所有可行状态呢？我们知道，在同一行，该状态可行当且仅当相邻左右两个不能放所以我们判断x & (x<<1) || x & (x << 2)是否返回真，这样把同一层的状态全部枚举出来，选出可行的。然后我们预处理出第一行的答案，接下来就是DP了，我们枚举三行的状态，一个一个判断就好了，方程为dp[i][k][t] = max(dp[i][k][t],dp[i-1][j][k] + num[t]);num代表当前状态有多少个1，即多少个1
/*************************************************************************

    > Author: Drinkwater-cnyali
    > Created Time: 2017/5/25 16:47:42
************************************************************************/













```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define REP(i, a, b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++ i)
#define DREP(i, a, b) for(register int i = (a), i##_end_ = (b); i >= i##_end_; -- i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mem(a, b) memset((a), b, sizeof(a))
template<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }
template<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }
int read()
{
    int sum = 0, fg = 1; char c = getchar();
    while(c < '0' || c > '9') { if (c == '-') fg = -1; c = getchar(); }
    while(c >= '0' && c <= '9') { sum = sum * 10 + c - '0'; c = getchar(); }
    return sum * fg;
}
const int maxn = 100000;
const int inf = 0x3f3f3f3f;
int n,m;
int dp[110][70][70];
int st[maxn];
int s[maxn],cnt,sum;
bool pd(int x)
{
    if(x & (x << 1))return 0;
    if(x & (x << 2))return 0;
    return 1;
}
bool check(int x,int i)
{
    if(x & st[i])return 0;
    return 1;
}
int num[maxn];
char M[110][20];
int main()
{
    //freopen("l.in","r",stdin);
    //freopen("l.out","w",stdout);
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        memset(dp,-1,sizeof(dp));
        memset(st,0,sizeof(st));
        memset(num,0,sizeof(num));
        cnt = 0;
        sum = 1<<m; 
        REP(i,0,sum-1)if(pd(i))s[++cnt] = i;
        REP(i,1,n)
            scanf("%s",M[i]+1);
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
            {
                st[i] = 0;
                for(j = 1;j<=m;++j)
                    if(M[i][j] == 'H')st[i] += (1<<(j-1));
            }
        REP(i,1,cnt)
        {
            num[i] = __builtin_popcount(s[i]);
            if(check(s[i],1))
                dp[1][1][i] = num[i];        
        }
        REP(i,2,n)
        {
            REP(t,1,cnt)
            {
                if(!check(s[t],i))continue;
                REP(j,1,cnt)
                {
                    if(s[t] & s[j])continue;
                    REP(k,1,cnt)
                    {
                        if(s[t] & s[k])continue;
                        if(dp[i-1][j][k] == -1)continue;
                        dp[i][k][t] = max(dp[i][k][t],dp[i-1][j][k] + num[t]);
                    }
                }
            }
        }
        int ans = 0;
        REP(i,1,n)REP(j,1,cnt)REP(k,1,cnt)ans = max(ans,dp[i][j][k]);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Right (赞：1)

先介绍一点C++的知识：

去掉最后一位              | (101101->10110)             x >> 1

在最后加一个0           | (101101->1011010)          x << 1

在最后加一个1           | (101101->1011011)          x << 1+1

把最后一位变成1       | (101100->101101)            x | 1
把最后一位变成0       | (101101->101100)            x | 1-1
最后一位取反              | (101101->101100)            x^1

把右数第k位变成1    | (101001->101101,k=3)      x | (1 << (k-1))
把右数第k位变成0    | (101101->101001,k=3)       x & ~ (1 << (k-1))

右数第k位取反           | (101001->101101,k=3)       x ^(1 << (k-1))

取末三位                     | (1101101->101)              x & 7

取末k位                     | (1101101->1101,k=5)        x & (1 << k-1)

取右数第k位               | (1101101->1,k=4)              x >> (k-1) & 1

把末k位变成1             | (101001->101111,k=4)        x | (1 << k-1)
末k位取反                  | (101001->100110,k=4)        x ^(1 << k-1)

把右边连续的1变成0    | (100101111->100100000    x & (x+1)

把右起第一个0变成1    | (100101111->100111111)   x | (x+1)
把右边连续的0变成1    | (11011000->11011111)        x | (x-1)
取右边连续的1             | (100101111->1111)           (x^(x+1)) >> 1

去掉右起第一个1的左边 | (100101000->1000)          x & (x^ (x-1))

取右边第一个1         |(101010->10)            x&-x

【解析】可以发现，对于每一行放大炮的状态，只与它上面一行和上上一行的状态有关，每一行用状态压缩的表示方法，0表示不放大炮，1表示放大炮，同样的，先要满足硬件条件，即有的地方不能放大炮，然后就是每一行中不能有两个1的距离小于2（保证横着不互相攻击），这些要预先处理一下。然后就是状态表示和转移的问题了，因为是和前两行的状态有关，所以要开个三维的数组来表示状态，当前行的状态可由前两行的状态转移而来。即如果当前行的状态符合前两行的约束条件（不和前两行的大炮互相攻击），则当前行的最大值就是上一个状态的值加上当前状态中1的个数（当前行放大炮的个数）



```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <iostream>
using namespace std;
int n,m,ans;
char map[120][80];
int num[200];
int top; // fang1 an4 number
int stk[100]; //zhuang tai
int b[180]; //zhuang ya hou de map
int dp[180][80][80]; //dp[i][j][k] 表示第i行状态为k，第i-1状态为j时的最大炮兵个数。
//【状态转移方程】dp[i][k][t] =max(dp[i][k][t],dp[i-1][j][k]+num[t]); num[t]为t状态中1的个数 
int max(int a,int b)
{
    if (a>b)
        return a;
      else
        return b;  
}
// cmp big or small
int cnt(int x)  //count
{
    int t=0;
    while (x)
    {
        t++;
        x&=(x-1);
    }
    return t;
}
bool cmp(int x) //compare
{
    if (x&(x<<1)) return 0;
    if (x&(x<<2)) return 0;
    return 1;  //判断该状态是否合法，即不存在相邻的1之间的距离小于3的  
}
bool fit(int x, int y)
{
    if (b[y]&x) return 0;
       return 1;
}
void init()
{
    top=0;
    int i;
    int t=1<<m;
    for (i=0; i<t; ++i)
    {
        if (cmp(i))
            stk[++top]=i;
        //cout<<stk[top]<<"init"<<endl;    
    }
} // 找到所有可能的合法状态，最多60种 
void read()
{
    int i,j,v;
    cin>>n>>m;
    init();
    /*for (i=1; i<=n; ++i)
    {
        scanf("%s",map[i]+1);
    }
    for (i=1; i<=n; ++i)
    {
        for (j=1; j<=m; ++j)
        {
            b[i]=0;
            if (map[i][j]=='H')
            {
                b[i]+=(1<<(j-1));
            }
        }
    }*/
    for(int i = 1; i <= n; ++i)scanf("%s",map[i]+1);  
           for(int i = 1; i <= n; ++i)  
           for(int j = 1; j <= m; ++j){  
               b[i]=0;  
               for(j=1;j<=m;j++){  
                    if(map[i][j]=='H')b[i]+=(1<<(j-1));  
               }  
           }  
    memset(dp,-1,sizeof(dp));
}
void fl()
{
    int i;
    for (i=1; i<=top; ++i)
    {
        num[i]=cnt(stk[i]); // every gunpowder 's number
        if (fit(stk[i],1)) //OK? or not?
        {
            dp[1][1][i]=num[i];
            //cout<<stk[i]<<num[i]<<"l"<<endl;
        }
    }
}
void dynamic()
{
    int i,j,k,t;
    fl(); //chu shu hua first line
    //cout<<dp[1][1][3];
    for (i=2; i<=n; ++i)  //second line begin
    {
        for (t=1; t<=top; ++t) //programs
        {
            if (!fit(stk[t],i))
                continue; //i行状态是否满足地图 if no ,then cut off
            for (j=1; j<=top; ++j)   //j is last zhuang tai
            {
                if (stk[t]&stk[j])
                {
                    continue;
                    //i-2行状态和i行有无相同列 cut off too
                }
                for (k=1; k<=top; ++k)
                {
                    if (stk[t]&stk[k]) continue;
                    if (dp[i-1][j][k]<0) continue;
                    dp[i][k][t]=max(dp[i-1][j][k]+num[t],dp[i][k][t]);
                    ans=max(ans,dp[i][k][t]);
                    //cout<<dp[i][k][t];
                    //cout<<stk[k]<<endl;
                }
            } 
        }
    }
    cout<<ans<<endl;
}
void print()
{
    int i,j,k;
    for (i=1; i<=n; ++i)
      for (j=1; j<=top; ++j)
        for (k=1; k<=top; ++k)
          ans=max(ans,dp[i][j][k]);
    cout<<ans<<endl;      
}
int main()
{
    read();
    dynamic();
}
```

---

## 作者：carl (赞：1)

由于是求的最多能放置的炮兵个数，就是求某一个状态下，它对应的炮兵个数最多，所以就想到dp方程肯定是那种dp[i+1]=max{dp[i-1]..}的形式，又考虑到每一行


的状态只和前两行有关系，所以考虑用dp来做，下面考虑如何用二进制位来表示一个状态及转移方程。


对于原始的矩阵，我们用1来表示可以放置炮兵，即对应图中的P，这样每一行都有一个可以放置炮兵的状态，存到rstate[N]中，用来check该行的状态是否合法。


由于当前行和前两行有关系，所以得用3维矩阵来保存一个状态下最多的炮兵个数，用dp[i][curst][prest]表示当前第i行状态对curst，前一行状态为prest的最大炮兵数。


转移方程为dp[i][curst][prest]=max{dp[i-1][prest][preprest]}，这样求到最后一行之后，答案就是最后一行所有状态中最大的那个。程序初始化的时候需要对第一行


进行预处理，设置dp[0][st][0]=st合法&st中1的个数。这样进行下面的计算的时候，由于0状态肯定是和所有状态兼容的，所以就不会影响计算结果。


```delphi

var 
    n,m,i,j,k,p,s,t    :longint;
    a                :array[0..100,0..100] of longint;
    map                :array[0..101] of longint;
    list,num        :array[0..1050] of longint;
    x                :string;
    f                :array[0..100,0..100,0..100] of longint;
    
function get_num(x:longint):longint;
var sum                :longint;
begin
    sum:=0;
    while x>0 do
    begin
        if ((x and 1)<>0) then inc(sum);
        x:=x>>1;
    end;
    exit(sum);
end;

function max(x,y:longint):longint;
begin
    if x>y then exit(x) else exit(y);
end;

begin
    readln(n,m);
    for i:=1 to n do
    begin    
        readln(x);
        for j:=1 to m do 
            if x[j]='P' then map[i]:=(map[i]<<1) or 1
            else if x[j]='H' then map[i]:=map[i]<<1;
    end;
    for i:=0 to (1<<m-1) do
    begin
        if (i and (i<<1)=0) and (i and (i<<2)=0) then
        begin
            list[t]:=i;
            num[t]:=get_num(i);
            inc(t);
        end;
    end;
    for i:=0 to (t-1) do
        if ((map[1] or list[i])=map[1]) then f[1,i,0]:=num[i];
    for i:=2 to n do
    for j:=0 to (t-1) do
    begin
        if (list[j] or map[i]=map[i]) then
        begin
            for k:=0 to (t-1) do
            begin
                if (list[j] and list[k]=0) then
                begin
                    for p:=0 to (t-1) do
                    begin
                        if (list[p] and list[k]=0) and (list[p] and list[j]=0) then
                            f[i,j,k]:=max(f[i,j,k],f[i-1,k,p]+num[j]);
                    end;
                end;
            end;
        end;
    end;
    s:=0;
    for j:=0 to (t-1) do
    for k:=0 to (t-1) do
        s:=max(s,f[n,j,k]);
    writeln(s);
end.

```

---

## 作者：Leowner (赞：1)

经典的动态压缩dp

dp方程  ：  f[i][j][k] = max(f[i][j][k],f[i-1][k][p]+num[j])


i 表示当前行 j 表示当前行状态 k 表示上一行状态 p 表示上两行状态

num 为预处理该情况炮兵数量


```cpp

#include <cstdio>
#include <algorithm>

int n,m;
int tot = 1;
int info[150];
int pre [150] , val[150];
int dp[110][60][60];
char c;

void get_val(int x){
    for (;x>0;){
        if ((x & 1) == 1) val[tot]++;
        x = x >> 1;
    }
}
void pre_search(void){
    for (int i=0;i<(1 << m);i++){
        if (((i & (i >> 1)) == 0) && ((i & (i >> 2)) == 0)){
            pre[tot] = i;
            get_val(i);
            tot++;
        }
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("\n");
        for (int j=1;j<=m;j++){
            scanf("%c",&c);
            if (c == 'P') {
                info[i] = (info[i] << 1) | 1 ;
            } else {
                info[i] = (info[i] << 1);
            }
        }    
    }                                            // input
    pre_search();                                 // pre_search and get_number
    tot--;
    for (int i=1;i<=tot;i++){
        if ((pre[i] | info[1]) == info[1]){
            dp[1][i][1] = val[i];
        }
    }                                            // for line 1
    for (int i=2;i<=n;i++){
        for (int j=1;j<=tot;j++){
            if ((pre[j] | info[i]) == info[i]){
                for (int jl=1;jl<=tot;jl++){
                    if ((pre[j] & pre[jl]) == 0){
                        for (int jll=1;jll<=tot;jll++){
                            if ((pre[j] & pre[jll]) == 0 && (pre[jl] & pre[jll]) == 0){
                                dp[i][j][jl] =std :: max(dp[i][j][jl],dp[i-1][jl][jll] + val[j]);
                            }
                        }
                    }
                }
            }
        }
    }
    int ans = -1000;
    for (int i=1;i<=tot;i++){
        for (int j=1;j<=tot;j++){
            ans = std :: max(ans,dp[n][i][j]);
        }
    }
/*
    for (int i=1;i<=60;i++){
        printf("%d\n",pre[i]);
    }
*/
/*
    for (int i=1;i<=n;i++){
        for (int j=1;j<=tot;j++){
            for (int k=1;k<=tot;k++){
                printf("%d ",dp[i][j][k]);
            }
        }
        printf("\n");
    }
    for (int i=1;i<=tot;i++){
        printf("%d ",val[i]);
    }
*/
    printf("%d",ans);
    return 0;
}

```

---

## 作者：chicken (赞：1)

想不到自己也可以染指noi的题目

又是调了很久

考虑状压

因为每一行的状态之后前两行有关 所以只需要记录前两行的就好了

每个状态用二进制来存 那这样就需要1024\*1024\*n的空间

所以滚动一下

f[i][j][k]表示第i行状态为j，第i-1行状态为k的答案

那么转移显然

f[i+1][l][j]=max(f[i][j][k]+get[l]) 

l是枚举的一个状态

get数组预处理 get[i]表示二进制下i的1的个数

再预处理一个pd数组

pd[i]表示某个i状态是否可行

具体可以看浅显易懂的代码


```cpp
-- #include<cstdio>
- #include<algorithm>
- #include<cstring>
- using namespace std;
- char c;
- int n,m,i,j,k,t,l,w,q,s;
- int p[104],pd[1026],get[1026];
- int f[2][1024][1024];
- bool check(int s) {
- if (s&(s>>1)||s&(s<<1)||s&(s>>2)||s&(s<<2)) return false;
- return true;
- }
- int gett(int x){
- int sum=0;
- int j=1;
- while (x) {
- if ((x&j)!=0) {
- x-=j;
- sum++;}
- j*=2;
- }
- return sum;
- }
- int main(){
- //freopen("1.in","r",stdin);
- //freopen("1.out","w",stdout);
- scanf("%d%d\n",&n,&m);
- for (i=1;i<=n;i++) {
- for (j=1;j<=m;j++) {
- scanf("%c",&c);
- if (c=='H') p[i]+=1<<(j-1);
- }
- scanf("\n");
- }
- s=(1<<m)-1;
- for (i=0;i<=s;i++) get[i]=gett(i);
- for (i=0;i<=s;i++)
- if (check(i)) pd[i]=1;
- for (j=0;j<=s;j++)
- for (k=0;k<=s;k++)
- if (pd[j]&&pd[k]&&!(j&p[2])&&!(k&p[1])) f[0][j][k]=get[j]+get[k];
- w=0; q=1;
- for(int i=2;i<=n-1;i++){
- w=q;
- q=w^1;
- for(int j=0;j<=s;j++)
- if (!(j&p[i])&&pd[j])
- for(int k=0;k<=s;k++)
- if (!(k&p[i-1])&&pd[k]&&!(j&k))
- for(int l=0;l<=s;l++)
- if (!(l&p[i+1])&&pd[l]&&!(l&j)&&!(l&k)){
- f[w][l][j]=max(f[w][l][j],f[q][j][k]+get[l]);
- }
- memset(f[q],0,sizeof(f[q]));
- }
- int ans=0;
- for (i=0;i<=s;i++)
- for (j=0;j<=s;j++)
- ans=max(ans,f[w][i][j]);
- printf("%d\n",ans);
- }
```

---

## 作者：Jeblqr (赞：1)

## 一道好题

先膜一发$HZY \space JULAO$。$STO \space  HZY \space ORZ$  %%%%%%

题目很简单：一个$N*M$的区域，分山地和平地。炮兵阵地只能建在平地，且攻击范围为上下前后$2$格。问最多能建多少个炮兵阵地。


很明显~~个鬼~~，第$i$行的状态总数只与前两行的状态有关，所以我们令$sit_i$为单独考虑一行时合法状态，压缩成二进制后的数，定义$f_{i,j,k}$为：**在第i行，第i-1行状态为$sit_j$，第i-2行状态为$sit_k$的情况下，最多可以放置的炮兵营地个数**

~~很难~~得出， $ f_{i,j,k} = max\{f_{i-1,k,l}+sum_j\} $,其中$sit[j],sit[k],sit[l]$都合法且共存。

具体的实现可以看代码和代码注释

感谢$hzy \space julao$的思路和提供的帮助 @a999999




```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int m, n;
int map[101], sum[1000001], cnt, sit[10000001];
long long f[1024][150][150], ans;
//f[i][j][k]：在第i行，第i-1行状态为sit[j]，第i-2行状态为sit[k]的情况下，最多可以放置的炮兵个数
char tmp;

void init(const int& now, const int& b, const int& tot)//初始化(求sit数组)
													   // now 本行的第now个；b 二进制下的状态；tot 记录炮兵个数
{
	if (now >= m)//初始化完本行
	{
		sit[++cnt] = b;//记录状态
		sum[cnt] = tot;//保存该状态中的炮兵的个数
		return;
	}
	init(now + 1, b, tot);
	init(now + 3, b | (1 << now), tot + 1);
}

long long dp()
{
	//初始化f数组的第一行
	for (int i = 1; i <= cnt; i++)
		if (!(map[1] & sit[i]))
			f[1][i][1] = sum[i];
	for (int i = 2; i <= n; i++)
		for (int j = 1; j <= cnt; j++)//枚举第i层状态
			if (!(map[i] & sit[j]))//此状态合法
				for (int k = 1; k <= cnt; k++)//枚举上一层状态
					if (!((map[i - 1] & sit[k]) | (sit[j] & sit[k])))//上一层状态合法 且 不与该层状态冲突
						for (int l = 1; l <= cnt; l++)
							if (!((map[i - 2] & sit[l] | (sit[j] & sit[l]) | (sit[k] & sit[l]))))//上上层状态合法 且 不与该层与上层冲突
								f[i][j][k] = max(f[i][j][k], f[i - 1][k][l] + sum[j]);
	for (int j = 1; j <= cnt; j++)//枚举第i层状态
		if (!(map[n] & sit[j]))//此状态合法
			for (int k = 1; k <= cnt; k++)//枚举上一层状态
				if (!((map[n - 1] & sit[k]) | (sit[j] & sit[k])))//上一层状态合法 且 不与该层状态冲突
					ans = max(ans, f[n][j][k]);
	return ans;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> tmp, map[i] = tmp == 'H' ? (map[i] << 1) + 1 : map[i] << 1;
			//如果该点为山丘，则其二进制状态设为1，否则设为0
	init(0, 0, 0);
	cout << dp();
	return 0;
}
```



---

## 作者：xxxxxxx__ (赞：1)

#### 是个状态压缩的入门题？

#### 这里一个新手，刚刚接触状压如果有说错的也请指出。

#### 大概的做法就是先处理每一行可能的摆放方式：先不用管地形，直接从0到2^m-1遍历所有可能的状态之后用位运算去掉那些不合法的状态。

#### 可以看出这里面每一行新的放法都只和上两行有关。之后开始dp：f[i][j][k]表示这三行的一组中最下面的一行是第i行，同时倒数第二行的状态是j、倒数第一行的状态是k（用二进制表示）。

#### 可以看出dp方程是f[i][j][k]=max(f[i][j][k],f[i-1][l][j]+cnt[k]) //其中l是可以成立的摆放方式（用一堆for循环来枚举就可以，复杂度并不会爆炸）

#### 之后输出结果即可


---

## 作者：ljk123 (赞：0)

# 炮兵阵地题解 

状压DP的恶(mu)心(ban)题,

我们可以发现题目中：m<=10

无疑，肯定是这一维表状态，

题目中，若在一点布置炮兵，则左右四点不能布置（可以预处理粗来）

但问题是上下四点也不能布置，

所以在DP时我们需要枚举上上行，上一行，这一行的状态，

dp数组也要用两维表示这一行和上一行的状态，

但如果用三维数组则会爆空间，用循环数组省一省。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=106,M=1026; 
int n,m,o1=2,o2=0,o3=1,ans=-1,t,p,q,w,g[N],h[M],num[N],flag[N][M],dp[4][M][M];
char c[14];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
int main(){
    n=read(),m=read();
    for(int i=0;i<(1<<m);++i){
        p=i,q=0;
        while(p) q+=(p&1),p>>=1;
        h[i]=q;
    }//预处理出每一种状态有几个炮兵
    for(int i=1;i<=n;++i){
        scanf("%s",c);
        for(int j=0;j<m;++j) g[i]+=((c[m-j-1]=='P')<<j);
        //g[],求出平原上的所有可能状态
        for(int j=0;j<=g[i];++j)
            if(((j&g[i])==j)&&(!((j<<1)&j))&&(!((j<<2)&j))) flag[i][++num[i]]=j;
        //flag[i][]:第i行,满足不互相打到的所有状态
    } 
    memset(dp,-1,sizeof(dp));
    //dp[i][j][k]:第i行,这一行状态为j,上一行状态为k,第一位用循环数组省空间
    for(int i=1;i<=num[1];++i) dp[0][flag[1][i]][0]=h[flag[1][i]];
    for(int i=1;i<=num[1];++i){
        p=flag[1][i];
        for(int j=1;j<=num[2];++j){
            q=flag[2][j];
            if(p&q) continue;
            dp[1][q][p]=max(dp[1][q][p],dp[0][p][0]+h[q]);
        }
    }  
    //处理第一二行的dp初值（p&q代表同一列有炮兵）
    for(int i=3;i<=n;++i){
        t=o1,o1=o2,o2=o3,o3=t;
        for(int j=1;j<=num[i-2];++j){
            p=flag[i-2][j];
            for(int k=1;k<=num[i-1];++k){
                q=flag[i-1][k];
                for(int ww=1;ww<=num[i];++ww){
                    w=flag[i][ww];
                    if((p&q)||(p&w)||(q&w)) continue;//同一列有炮兵就跳过
                    dp[o3][w][q]=max(dp[o3][w][q],dp[o2][q][p]+h[w]);               
                }
            }
        }
    }
    for(int i=1;i<=num[n-1];++i){
        p=flag[n-1][i];
        for(int j=1;j<=num[n];++j){
            q=flag[n][j];
            if(p&q) continue;
            ans=max(ans,dp[o3][q][p]);
        }
    }  
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：liuqy (赞：0)

任务：在一个有些位置不能放的棋盘上放会制造障碍的棋子，问最多多少个

思路：按一行一行处理方法，将所有可能的情况枚举出来，

再根据情况在所有合法情况下找到最优解（因为情况十进制存不下所以用二进制来保存bin数组）


数组bin收集2的一次方到2的十次方，例如bin[2]表示2的2次方


用try1函数做到


try1(i,x,s):    (try1(i+1,x,s)表示不放炮兵

                   try1(i+3,x+bin[i-1],s+1)表示放炮兵

先做前两行的所有合法情况（保证两行不互相攻击且与地图不冲突）


可以先特判一下一行的情况，当然没有种族数据所以不说了。


再从第三行到第n行将所有当前第i行最优解且合法存到f数组中（三维），例如：


d3 i-2行

d2 i-1行

d1 i行



f[i][d1][d2]=max(f[i][d1][d2]│f[i-1][d2][d3]+a[d1].s)

最后在f[n][][]中找最大值即为所求


下面为代码


    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
```cpp
#include <cstdio>
#include <cstring>
int bin[20],ch[3][110][66],f[110][66][66],map[110];
char str1;
int n,m,count;
struct node{
    int x,s;
};
node a[66];
void try1(int k,int x,int s){
    if(k>m){
        ++count;
        a[count].x=x;
        a[count].s=s;
        return;
    }
    try1(k+1,x,s);
    try1(k+3,x+bin[k-1],s+1);
    return;    
}
int main(){
//    freopen("xxx.in","r",stdin);
//    freopen("cannon.out","w",stdout);
    bin[0]=1;
    for(int i=1;i<=10;i++)bin[i]=bin[i-1]*2;
    scanf("%d%d",&n,&m);
    scanf("\n");
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%c",&str1);
            if(str1=='H')map[i]+=bin[j-1];
        }
        scanf("\n");
    }
    try1(1,0,0);
    if(n==1){
        int max=-1;
        for(int i=1;i<=count;i++)if(a[i].s>max&&(map[1]&a[i].x)==0)max=a[i].s;
        printf("%d",max);
        return 0;
    }
    memset(f,-1,sizeof f);
    for(int d1=1;d1<=count;d1++){
        for(int d2=1;d2<=count;d2++){
            if((map[2]&a[d1].x)==0&&(map[1]&a[d2].x)==0&&(a[d1].x&a[d2].x)==0){
                f[2][d1][d2]=a[d1].s+a[d2].s;
            }
        }
    }
    for(int i=3;i<=n;i++){
        for(int d1=1;d1<=count;d1++){
            if((map[i]&a[d1].x)!=0)continue;
            for(int d2=1;d2<=count;d2++){
                if((map[i-1]&a[d2].x)!=0||(a[d1].x&a[d2].x)!=0)continue;
                int max1=0;
                for(int d3=1;d3<=count;d3++){
                    if((map[i-2]&a[d3].x)==0&&(a[d1].x&a[d3].x)==0&&(a[d2].x&a[d3].x)==0&&f[i-1][d2][d3]+a[d1].s>max1)max1=f[i-1][d2][d3]+a[d1].s;
                }
                f[i][d1][d2]=max1;
            }
        }
    }
    int max=-1;
    for(int i=1;i<=count;i++)for(int j=1;j<=count;j++)if(f[n][i][j]>max)max=f[n][i][j];
    printf("%d",max);
    return 0;
}

```

---

## 作者：ljc20020730 (赞：0)

题意：

炮兵在地图上的摆放位子只能在平地('P')

炮兵可以攻击上下左右各两格的格子；

而高原('H')上炮兵能够攻击到但是不能摆放

求最多能摆放的炮兵的数量

就是这个意思。

难度提高，弱省省选

一开始是想写dfs（迷之八皇后）的，

但是看到数据量100就想dp了；

因为题目n的范围给的很少n<=10，想到状压

非常明显是一个状态压缩的dp（状压dp）

其实可以当做状压的入门题目来做。

由于本行的状态是由前若干行推出来的，所以想到了从上推到下（而不是从左推到右）

还有，本行的状态与前1行，前2行的状态密切相关的（炮兵不互相攻击）

写出我们dp的状态：f[i,r1j]表示当前第i行状态为j，i-1行状态为r1的炮兵数

转移其实就是非常简单了：（r2就是前第2行的状态）

 f[i,r1,j]:=max(f[i,r1,j],f[i-1,r2,r1]+sum[j]);

转移的条件：r1和r2不与H有一个重合；r1和r2不能被互相打到或达j

本题主要难在处理dp初始化的方面；

首先我们需要保证每一种拓展出来的炮兵排列的方式需要在该行中横向不互相攻击；

这种每行不攻击的序列总数小于等于60；

pd函数非常好写：

function pd(x:longint):boolean;//判断此时放的是否合法（附近两位不能有1）

 

 

```cpp
begin
if (x and (x<<1))<>0 then exit(false);
 if (x and (x<<2))<>0 then exit(false);
exit(true);
end;
```
引入col[i]的二进制数组，表示第i行‘H’的分布
if s[j]='H' then col[i]:=col[i] or (1<<(j-1));

注意这里需要j-1，因为二进制是从2^0开始的。

注意初始化第0行所有地点都是高山，由于第0行可能会影响第2行；

特殊处理第一行：(st数组保存所有合法的序列，cnt为合法序列的个数，st标号1~cnt)

  
 
 for i:=1 to cnt do begin

  if (col[1] and st[i])=0 then f[1,1,i]:=sum[i];

 end;
所以，本题的代码简单，主要注意的是初始值和dp式不要写错（4维的转移，暴力）




```cpp
uses math;
var n,m,i,j,r1,r2,ans,cnt:longint;
    f:array[0..100,0..100,0..100]of longint;
    //f[i,j,k]表示当前第i行状态为j，i-1行状态为k的炮兵数
    s:string;
    st,sum,col:array[0..100]of longint;
function pd(x:longint):boolean;//判断此时放的是否合法（附近两位不能有1）
begin
 if (x and (x<<1))<>0 then exit(false);
 if (x and (x<<2))<>0 then exit(false);
 exit(true);
end;
function getbit(x:longint):longint;//求出二进制数x中有几个1
var sum:longint;
begin
 sum:=0;
 while x>0 do begin
  if (x and 1)=1 then inc(sum);
  x:=x>>1;
 end;
 exit(sum);
end;
procedure getdp(m:longint);
var e,i:longint;
begin
 e:=1<<m;
 cnt:=0;
 for i:=0 to e-1 do
  if pd(i) then begin
   inc(cnt);
   st[cnt]:=i; //保存此时的状态
   sum[cnt]:=getbit(i); //炮兵的个数
  end;
end;
begin
 readln(n,m);
 getdp(m);
 fillchar(col,sizeof(col),0);
 for i:=1 to m do col[0]:=col[0] or (1<<i);
 for i:=1 to n do begin
  readln(s);
  for j:=1 to m do
   if s[j]='H' then col[i]:=col[i] or (1<<(j-1));
 end;
 //col[i]表示第i行高地的分布
 fillchar(f,sizeof(f),255);//clear!
 for i:=1 to cnt do begin
  if (col[1] and st[i])=0 then f[1,1,i]:=sum[i];
 end;
 for i:=2 to n do
 for j:=1 to cnt do  //现在这行的状态是j
  if (col[i] and st[j])=0 then
   for r1:=1 to cnt do //上一行状态是r1
   if (st[j] and st[r1])=0 then
    for r2:=1 to cnt do //上上行的状态是r2
    if (st[j] and st[r2])=0 then
     if f[i-1,r2,r1]<>-1 then
      f[i,r1,j]:=max(f[i,r1,j],f[i-1,r2,r1]+sum[j]);
 ans:=0;
 for i:=1 to cnt do
  for j:=1 to cnt do
   ans:=max(ans,f[n,i,j]);
 writeln(ans);
end.

```

---

## 作者：ljc20020730 (赞：0)

P2704 炮兵阵地：

预处理状态+区间DP
显然本行的状态与上面两行相关连，

- 设计状态f[i][j][k]表示当前第i行，状态是j，再上一行状态是k，最多总共放的数目

- 显然是从f[i-1][k][w]转移而来 ，并且显然 k,w,j必须有一定的约束条件


 - j,k,w满足在该行内每两个1之间相差至少2格子且是H出没有1
 
-  j,k,w在第j|1<=j<=m列不能有炮兵重复排放(最多三个格子有一个)
 

- 转移就是f[i][j][k]=max{f[i-1][k][w]+count(j)}

设函数check0()//判断炮兵是否可以在该行正确安放(地形的限制) 

```

bool check0(int line,int Base) //判断炮兵是否可以在该行正确安放(地形的限制) 
{
	if (line<1) return true;
	if ((Base&mp[line])!=0) return false;
	return true;
}
```
设函数check1()//判断同行是否满足两个1之间至少有2个0 
```
就是这样：
bool check1(int x) //判断同行是否满足两个1之间至少有2个0 
{
	if ((x&(x<<1))||(x&(x<<2))) return false;
	else return true;
}
```
check2()//判断三个有没有其中两个（含）以上是1的 
```
bool check2(int a,int b,int c) //判断三个有没有其中两个（含）以上是1的 
{
	if ((a&b)!=0) return false;
	if ((a&c)!=0) return false;
	if ((b&c)!=0) return false;
	return true; 
}
```


朴素算法是这样的：

```
# include<bits/stdc++.h>
using namespace std;
const int MAXN=105,MAXM=10;
int mp[MAXN],f[2][1<<MAXM][1<<MAXM];
int n,m,Bits[1<<MAXM];
char s[MAXM];
int count_(int x)
{
    int ret=0;
    while (x){ x=x&(x-1); ret++;}
    return ret;
}
int count(int x)
{
    return Bits[x];
}
bool check1(int x) //判断同行是否满足两个1之间至少有2个0 
{
    if ((x&(x<<1))||(x&(x<<2))) return false;
    else return true;
}
bool check2(int a,int b,int c) //判断三个有没有其中两个（含）以上是1的 
{
    if ((a&b)!=0) return false;
    if ((a&c)!=0) return false;
    if ((b&c)!=0) return false;
    return true; 
}
bool check0(int line,int Base) //判断炮兵是否可以在该行正确安放(地形的限制) 
{
    if (line<1) return true;
    if ((Base&mp[line])!=0) return false;
    return true;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) {
        scanf("%s",s); int len=strlen(s);
        int tmp=0;
        for (int j=0;j<len;j++)
        tmp=(tmp<<1)+(s[j]=='H'?1:0);
        mp[i]=tmp; 
    }
    for (int i=0;i<(1<<m);i++) Bits[i]=count_(i);
    int p=1;
    for (int i=1;i<=n;i++,p^=1)  {
        for (int j=0;j<(1<<m);j++) {
            if (check1(j)==false||check0(i,j)==false) continue;
            for (int k=0;k<(1<<m);k++) {
                if (check1(j)==false||check0(i-1,k)==false) continue;
                for (int w=0;w<(1<<m);w++) {
                    if (check1(w)==false||check0(i-2,w)==false) continue;
                    if (check2(j,k,w)==false) continue;
                    f[p][j][k]=max(f[p^1][k][w]+count(j),f[p][j][k]);
                }
            }
        }
    }
    int ans=0;
    for (int i=0;i<(1<<m);i++)
     for (int j=0;j<(1<<m);j++)
      ans=max(ans,f[n&1][i][j]);
    printf("%d\n",ans);
    return 0;
 } 
```
而显然这样做会Tle,复杂度是O(n*8^m)

考虑优化就是发现每一行有一些状态是只要枚举一次就行了就是

只和本行的特征、地形有关系的状态，这样就优化到AC的地步了


注意玄学滚动数组

```
# include<bits/stdc++.h>
using namespace std;
const int MAXN=105,MAXM=10;
int mp[MAXN],f[2][1<<MAXM][1<<MAXM];
int n,m,Bits[1<<MAXM];
char s[MAXM];
int run[MAXN][1<<MAXM+1];
int num[MAXN];
int count_(int x)
{
	int ret=0;
	while (x){ x=x&(x-1); ret++;}
	return ret;
}
int count(int x)
{
	return Bits[x];
}
bool check1(int x) //判断同行是否满足两个1之间至少有2个0 
{
	if ((x&(x<<1))||(x&(x<<2))) return false;
	else return true;
}
bool check2(int a,int b,int c) //判断三个有没有其中两个（含）以上是1的 
{
	if ((a&b)!=0) return false;
	if ((a&c)!=0) return false;
	if ((b&c)!=0) return false;
	return true; 
}
bool check0(int line,int Base) //判断炮兵是否可以在该行正确安放(地形的限制) 
{
	if (line<1) return true;
	if ((Base&mp[line])!=0) return false;
	return true;
}
void init()
{
	memset(run,0,sizeof(run));
	memset(num,0,sizeof(num));
	for (int i=1;i<=n;i++)
	 for (int B=0;B<(1<<m);B++)
	  if (check0(i,B)&&check1(B)) run[i][++num[i]]=B;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) {
		scanf("%s",s); int len=strlen(s);
		int tmp=0;
		for (int j=0;j<len;j++)
		tmp=(tmp<<1)+(s[j]=='H'?1:0);
		mp[i]=tmp; 
	}
	for (int i=0;i<(1<<m);i++) Bits[i]=count_(i);
	init();
	int p=1;
	for (int i=1;i<=n;i++,p^=1)  {
		for (int _j=1;_j<=num[i];_j++) {
			int j=run[i][_j];
			for (int _k=1;_k<=num[i-1];_k++) {
				int k=run[i-1][_k];
				for (int _w=1;_w<=num[i-2];_w++) {
					int w=run[i-2][_w];
					if (check2(j,k,w)==false) continue;
					f[p][j][k]=max(f[p^1][k][w]+count(j),f[p][j][k]);
				}
				int w;
				if (i-2<=0) w=0;
				if (check2(j,k,w)==false) continue;
				f[p][j][k]=max(f[p^1][k][w]+count(j),f[p][j][k]);
			}
			int k;
			if (i-1<=0) k=0;
			for (int _w=1;_w<=num[i-2];_w++) {
				int w=run[i-2][_w];
				if (check2(j,k,w)==false) continue;
				f[p][j][k]=max(f[p^1][k][w]+count(j),f[p][j][k]);
			}
			int w;
			if (i-2<=0) w=0;
			if (check2(j,k,w)==false) continue;
			f[p][j][k]=max(f[p^1][k][w]+count(j),f[p][j][k]);
		}
	}
	int ans=0;
	for (int i=0;i<(1<<m);i++)
	 for (int j=0;j<(1<<m);j++)
	  ans=max(ans,f[n&1][i][j]);
	printf("%d\n",ans);
	return 0;
 } 
 ```

---


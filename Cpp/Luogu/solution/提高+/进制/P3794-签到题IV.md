# 签到题IV

## 题目背景

这场月赛好像其他题背景都很长，这题就不写背景了。 ![](https://cdn.luogu.com.cn/upload/pic/1436.png)


## 题目描述

给定一个长度为 $n$ 的序列 $[a_1,a_2\cdots a_n]$，其中每个数都是正整数。


你需要找出有多少对 $(i,j)$，$1 \leq i \leq j \leq n$ 且$\gcd(a_i,a_{i+1}...a_j) \operatorname{xor} (a_i \operatorname{or} a_{i+1} \operatorname{or} \cdots \operatorname{or} a_j)=k$，其中 $\operatorname{xor}$ 表示二进制异或，$\operatorname{or}$ 表示二进制或。


## 说明/提示

- 对于 $30\%$ 的数据，$n \leq 500$。
- 对于 $60\%$ 的数据，$n \leq 100000$。
- 对于 $100\%$ 的数据，$1 \leq n,a_i \leq 500000$。


## 样例 #1

### 输入

```
5 6
2 4 3 4 2```

### 输出

```
8```

# 题解

## 作者：fjzzq2002 (赞：17)

不妨从小到大枚举x，考虑计数j=x的情况。

当j=x时，我们可以发现不同的gcd和or只有$O(log)$种，因为你考虑从右到左枚举左端点，每次使用一个新元素更新gcd和or，那么gcd如果改变，必然少了至少一个质因子，or如果改变，必然至少多了二进制下一个1。质因子和二进制下最多1的个数都是log级别的，所以只有$O(log)$种。

如果你每次二分一下当前(gcd,or)这一段的左端点，那么是$O(log^2\times gcd)$的，理论上可以获得60分（实际上由于数据造的还是不够强，卡卡常好像能过）。

事实上我们发现从小到大枚举右端点的时候，我们可以直接把之前的log段并上当前这个新元素来更新每一段，这样就可以去掉一个log，是$O(log\times gcd)$的。事实上可以证明这是$O(log)$的。


---

## 作者：Jμdge (赞：8)


这大概是这两天花的时间最多的一道题了...具体原因就是下面提的位运算 嘤嘤嘤

## 题意


求满足： $gcd(l,... ,r)~~ xor~~ or(l,...,r) = k$ 的区间个数

## 做法

常规的 $n~ log^2~ n$ 做法如下：（可以卡过）

我们考虑到 gcd 和 or 的区间单调性可以去枚举 gcd 然后江其异或上 k ，再去二分 or 的范围，然后累加答案

注意如果用线段树查询区间 gcd 和 or 的话还要多一个 $log$


```
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int M=5e5+3;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int GCD(int a,int b){return b?GCD(b,a%b):a;}
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,k,mid,d,a[M],lg[M],gcd[M][21],orz[M][21]; ll ans;
inline void prep(){ for(int i=2;i<=n;++i) lg[i]=lg[i>>1]+1;
    for(int j=1;j<=20;++j) for(int i=1;i+(1<<j)-1<=n;++i)
        gcd[i][j]=GCD(gcd[i][j-1],gcd[i+(1<<j-1)][j-1]),
        orz[i][j]=orz[i][j-1]|orz[i+(1<<j-1)][j-1];
}
inline int get_o(int l,int r){ int k=lg[r-l+1];
    return orz[l][k]|orz[r-(1<<k)+1][k];
}
inline int get_g(int l,int r){ int k=lg[r-l+1];
    return GCD(gcd[l][k],gcd[r-(1<<k)+1][k]);
}
inline int find_r(int s,int x,int l,int r){
    while(l<=r) mid=l+r>>1,d=get_g(s,mid),
        d<x?r=mid-1:l=mid+1; return r;
}
inline void work(int s,int x,int l,int r){
    int L,R,OR,lef=0,rig=-1;
    for(L=l,R=r;l<=r;) mid=l+r>>1,OR=get_o(s,mid),
        x==OR?lef=mid,r=mid-1:x<OR?r=mid-1:l=mid+1;
    
    for(l=L,r=R;l<=r;) mid=l+r>>1,OR=get_o(s,mid),
        x==OR?rig=mid,l=mid+1:x>OR?l=mid+1:r=mid-1;
    ans+=rig-lef+1;
}
int main(){ n=read(),k=read();
    for(int i=1;i<=n;++i) orz[i][0]=gcd[i][0]=read(); prep();
    for(int i=1,l,r,d;i<=n;++i) for(l=i;l<=n;l=r+1)
        d=get_g(i,l),r=find_r(i,d,l,n),work(i,d^k,l,r);
    return !printf("%lld\n",ans);
}
```


---



---

---



---

---



---

---



---

---



---

---



---

---



---

---



---

---



---

---



---

---



---

---



---

---



---


然鹅我们还有更优秀的 $n~ log~ n$ 做法：

可以证明右端点确定的区间 gcd 和 or 的取值是 $log$ 级别的

然后又因为其满足可以区间快速合并的性质，我们可以枚举右端点，然后每个左区间合并一下右端点

接着我们江 gcd 的 log 段和 or 的 log 段拎出来，按右端点排个序，然后跑着判着就好了

话说一个  $g[j]~~ xor ~~ r[j] == k$ 害得我查了一个小时代码，以后位运算再也不敢偷懒不加小括号了 嘤嘤嘤

然鹅用了链表跑得还没 $map$ 快，可能是因为 洛谷 4 吧...


```
//by Judge
#include<cstdio>
#include<iostream>
using namespace std;
const int M=5e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int gcd(int a,int b){return b?gcd(b,a%b):a;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,k; long long ans; arr a,g,r,pre,nxt,PRE,NXT;
inline int Min(int a,int b){return a<b?a:b;}
inline void work(int R){
	for(int j=1;j<=R;j=Min(nxt[j],NXT[j])){
		g[j]=gcd(g[j],a[R]),r[j]|=a[R];
		if((g[j]^r[j])==k) //一定要加小括号啊 嘤嘤嘤
			ans+=Min(nxt[j],NXT[j])-j;
		if(g[j]==g[pre[j]])
			nxt[pre[j]]=nxt[j],
			pre[nxt[j]]=pre[j];
		if(r[j]==r[PRE[j]])
			NXT[PRE[j]]=NXT[j],
			PRE[NXT[j]]=PRE[j];
		if(nxt[j]<NXT[j]) //什么都不管全部值 copy 一遍
			r[nxt[j]]=r[j],
			PRE[nxt[j]]=PRE[j],
			NXT[nxt[j]]=NXT[j];
		if(NXT[j]<nxt[j]) //另一个差不多
			g[NXT[j]]=g[j],
			pre[NXT[j]]=pre[j],
			nxt[NXT[j]]=nxt[j];
	}
}
int main(){
	n=read(),k=read();
	for(int i=1;i<=n;++i)
		g[i]=r[i]=a[i]=read();
	for(int i=1;i<=n;++i)
		NXT[i]=nxt[i]=i+1,
		PRE[i]=pre[i]=i-1;
	nxt[0]=NXT[0]=1,pre[n+1]=PRE[n+1]=n; //好像并没有什么软用？
	for(int i=1;i<=n;++i) work(i);
	return !printf("%lld\n",ans);
}
```

喜欢点个赞？ thank you~



---

## 作者：Tgotp (赞：8)

从30分-100分谈谈我对这道题的理解。


1. 30分思路：


直接暴力枚举（当然我一开始用线段树优化也是30）


代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
inline void read(int&x)
{
    char c;
    do{ c=getchar(); }while(c < '0' || c > '9');
    do{
        x = x*10+c-'0';
        c=getchar();
    }while(c <= '9' && c >= '0');
}
const int N = 5e5 + 5;
int n,k,ans;
int a[N];
inline int Gcd(int a,int b){ return a % b == 0?b : Gcd(b,a%b); }
int main()
{
    read(n);read(k);
    for(int i = 1;i <= n;i++) read(a[i]); 
    for(int i = 1;i <= n; i++)
    {
        int x,y;
        x = y = a[i];
        for(int j = i;j <= n;j++)
        {
            x = Gcd(x,a[j]);y |= a[j];
            int z = x ^ y;
            if(z > k ) break;
            else if(z == k) ans ++;
        }
    }
    cout<<ans;
    return 0;
}
```
50分思路： 我们知道异或有性质a xor b xor a = b

然后发现gcd 随着长度增加是不断减小的，而or 却是不断增大。


猜想：可能枚举l 然后答案在一段区间上。


代码参考如下：


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
inline void read(int&x)
{
    char c;x=0;
    do{ c=getchar(); }while(c < '0' || c > '9');
    do{
        x = x*10+c-'0';
        c=getchar();
    }while(c <= '9' && c >= '0');
}
const int N = 5e5 + 5;
int n,k,ans;
int a[N],mn[N],gcd[N][21],Or[N][21];
inline int Gcd(int a,int b){ return a % b == 0?b:Gcd(b,a%b); }
inline int OR(int a,int b){ return a | b; }
inline void init()
{
    for(int i = 2;i <= n;i++) mn[i] = mn[i>>1] + 1;
    for(int j = 1;j <= 20 ;j++)  
        for(int i = 1; i+(1<<j)-1<=n;i++)
        {
            gcd[i][j] = Gcd(gcd[i][j-1],gcd[i+(1<<(j-1))][j-1]);
            Or[i][j] = OR(Or[i][j-1],Or[i+(1<<(j-1))][j-1]);
        }
}
inline int get(int l,int r)
{
    int len = mn[r-l+1];
    return (Gcd(gcd[l][len],gcd[r-(1<<len)+1][len]) ^ OR(Or[l][len],Or[r-(1<<len)+1][len]));
}
inline int find(int x,int l,int r)
{
    int num;
    while(l <= r)
    {
        int mid = (l+r)>>1;
        int z = get(x,mid);
        if(z == k)
            num = mid,r = mid-1;
        else if(z > k) r = mid - 1;
        else if(z < k) l = mid + 1;
    }
    return num;
}
inline int Find(int x,int l,int r)
{ 
    int num;
    while(l <= r)
    {
        int mid = (l+r)>>1;
        int z = get(x,mid);
        if(z == k)
            num = mid,l = mid + 1;
        else if(z > k) r = mid - 1;
        else if(z < k) l = mid + 1;
    }
    return num;
}
inline int solve(int x)
{
    int l = x,r = n;
    while(l <= r)
    {
        int mid = (l+r)>>1;
        int z = get(x,mid);
        if(z == k)
            return Find(x,l,r) - find(x,l,r) + 1;
        else if(z > k) r = mid - 1;
        else if(z < k) l = mid + 1;
    }
    return 0;
}
int main()
{
    read(n);read(k);
    for(int i = 1;i <= n;i++) read(gcd[i][0]),Or[i][0]=gcd[i][0]; 
    init();
    for(int i = 1;i <= n; i++)
        ans += solve(i);
    cout<<ans;
    return 0;
}
```
60分思路：发现答案可能很大，ans 开成long long（不贴代码了。）

最后，100分正解（虽然我时间可能很慢）


通过50-60分代码发现猜想并不正确。


但是从中得到启示，gcd递减，or递增。


所以我们找出gcd值一定的情况（因为其是递减的。），此时gcd xor k 为一定值。


而or 递增，所以可以二分枚举出答案。


100分代码：


```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
inline void read(int&x)
{
    char c;x=0;
    do{ c=getchar(); }while(c < '0' || c > '9');
    do{
        x = x*10+c-'0';
        c=getchar();
    }while(c <= '9' && c >= '0');
}
const int N = 5e5 + 5;
int n,k;
long long ans;
int a[N],mn[N],gcd[N][21],Or[N][21];
inline int Gcd(int a,int b){ return a % b == 0?b:Gcd(b,a%b); }
inline int OR(int a,int b){ return a | b; }
inline void init()
{
    for(int i = 2;i <= n;i++) mn[i] = mn[i>>1] + 1;
    for(int j = 1;j <= 20 ;j++)  
        for(int i = 1; i+(1<<j)-1<=n;i++)
        {
            gcd[i][j] = Gcd(gcd[i][j-1],gcd[i+(1<<(j-1))][j-1]);
            Or[i][j] = OR(Or[i][j-1],Or[i+(1<<(j-1))][j-1]);
        }
}
inline int get(int l,int r)
{
    int len = mn[r-l+1];
    return OR(Or[l][len],Or[r-(1<<len)+1][len]);
}
inline int gets(int l,int r)
{
    int len = mn[r-l+1];
    return Gcd(gcd[l][len],gcd[r-(1<<len)+1][len]);
}
inline int find(int s,int x,int l,int r)
{
    int num;
    while(l <= r)
    {
        int mid = (l+r)>>1,z=gets(s,mid);
        if(x == z)
        {
            num = mid;
            l = mid + 1;
        }else r = mid - 1;
    }
    return num;
}
inline void solve(int s,int x,int l,int r)
{
    int L = l,R = r,num = 0,Num=-1;
    while(l <= r)
    {
        int mid = (l+r)>>1,z=get(s,mid);
        if(x == z) r = mid - 1,num = mid; 
        else if(x < z) r = mid - 1;
        else if(x > z) l = mid + 1;
    }
    while(L <= R)
    {
        int mid = (L+R)>>1,z=get(s,mid);
        if(x == z) L = mid + 1,Num = mid; 
        else if(x < z) R = mid - 1;
        else if(x > z) L = mid + 1;
    }
    ans += Num - num + 1;
}
int main()
{
    read(n);read(k);
    for(int i = 1;i <= n;i++) read(gcd[i][0]),Or[i][0]=gcd[i][0]; 
    init();
    for(int i = 1;i <= n;i++)
        for(int j = i;j <= n;j++)
        {
            int p = find(i,gets(i,j),j,n);
            solve(i,gets(i,j)^k,j,p);
            j = p;
        }
    cout<<ans;
    return 0;
}
最后推广一下我的blog：http://tgotp.science/
```

---

## 作者：ran_qwq (赞：5)

固定 $l$，$a_i$ 如果对 $\gcd$ 有变化，变化至少是除去一个因数；如果对 $\operatorname{or}$ 有变化，至少是增加一位 $1$。所以对每个 $l$，不同的 $\gcd$ 只有 $O(\log V)$ 个；不同的 $\operatorname{or}$ 也只有 $O(\log V)$ 个。且相同的 $\gcd$ 和 $\operatorname{or}$ 都是一段连续的区间，故不同的 $(\gcd,\operatorname{or})$ 只有 $O(\log V)$ 个。

考虑维护这些连续的区间，$\gcd$ 和 $\operatorname{or}$ 都具有单调性，可以双指针找。

$\gcd$ 和 $\operatorname{or}$ 都满足可重复共线性，可以用 ST 表求。

放个从 P9032 改过来的丑代码：

```cpp
int n,m,a[N],vis[N],lg[N],b[N],pos[N],POS[N],st[N][22],ST[N][22];ll ans;
int query(int l,int r) {int k=lg[r-l+1];return __gcd(st[l][k],st[r-(1<<k)+1][k]);}
int QUERY(int l,int r) {int k=lg[r-l+1];return ST[l][k]|ST[r-(1<<k)+1][k];}
void solve()
{
	n=read(),m=read(),lg[0]=-1;
	for(int i=1;i<=n;i++) a[i]=st[i][0]=ST[i][0]=read(),lg[i]=lg[i>>1]+1;
	for(int j=1;1<<j<=n;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			st[i][j]=__gcd(st[i][j-1],st[i+(1<<j-1)][j-1]),
			ST[i][j]=ST[i][j-1]|ST[i+(1<<j-1)][j-1];
	for(int i=2;i<=N-10;i++)
		if(!vis[i]) for(int j=2;i*j<=N-10;j++) vis[i*j]=1;
	for(int i=1;i<=N-10;i++)
		for(int j=2;i*j<=N-10;j++) if(!vis[j]) b[i*j]=b[i]+1;
	for(int i=0;i<=20;i++) pos[i]=POS[i]=1;
	for(int i=1;i<=n;i++) {
		vector<int> tmp={i};
		for(int j=0;j<=20;j++) {
			while(pos[j]<=n&&(pos[j]<i||b[query(i,pos[j])]>=j)) pos[j]++;
			while(POS[j]<=n&&(POS[j]<i||__builtin_popcount(QUERY(i,POS[j]))<=j)) POS[j]++;
			tmp.push_back(pos[j]),tmp.push_back(POS[j]);
		}
		sort(tmp.begin(),tmp.end());
		for(int j=1;j<tmp.size();j++) if(tmp[j]>i&&(query(i,tmp[j]-1)^QUERY(i,tmp[j]-1))==m) ans+=tmp[j]-tmp[j-1];
	}
	printf("%lld",ans);
}
```

---

## 作者：BrotherCall (赞：3)

题目：[P3794 签到题IV](https://www.luogu.com.cn/problem/P3794)

### 前置芝士：

gcd 的性质 or 运算的性质以及 ST表。

### 心路历程：

30分暴力：暴力枚举左右端点，暴力判断原式值是否等于 k 。

时间复杂度 $O(n^2)$ 。

**于是我们考虑如何优化这个暴力。**

这里我们深究一下 gcd 的性质：

对于 $\gcd(a_i , a_{i+1}...a_j)$ ，当 j 一定时。存在如下两个性质：

1. gcd 的值随 i 的增大而单调不降。

证明这个其实很简单，我们将 $\gcd(a_{i+1},a_{i+2}...a_j)$ 看作一个整体 s ， 那么一定有 $\gcd(a_i , s) \leqslant s$ ，因为一个数的因子一定不大于它自身。

2. gcd 最多存在 $\log(a_j)$ 个互不相同的值（即 $a_j$ 分解质因数后的各指数之和）。

简要证明：

设 $a=x^{i_1}y^{j_1}...$ 和 $b=x^{i_2}y^{j_2}...$ 

$\gcd(a,b)=x^{min(i_1,i_2)}y^{min(j_1,j_2)}...$

假设 $i_1 > i_2$ , $j_1 > j_2...$ 。最坏情况是 $i_1j_1...$ 每次其中一个以 1 的速度减小，此时互不相同的个数为 $\Sigma i + \Sigma j + ...$ 。近似于 $\log(a)$ 。

综合以上性质，我们可以得到一个处理 gcd 区间的有效方法：将 gcd 相同的区间压缩成一个区间，并记录下左右端点。这里我们可以用一个 vector 实现，非常方便。

参考代码：

```cpp
for(int i=1;i<=n;i++){
    for(int j=0;j<V.size();j++)
        V[j].gc = gcd(V[j].gc , a[i]);//更新区间gcd的值
    edge e;
    e.gc = a[i];
    e.fst = i;//左端点
    e.lst = i;//右端点
    V.push_back(e);
    for(int j=1;j<V.size();j++){
        if(V[j].gc == V[j - 1].gc){
            V[j - 1].lst = V[j].lst;
            V.erase(V.begin() + j);//压缩gcd相同的区间
        }
    }
}
```

理论复杂度 $O(n\log^2n)$ ，但事实上会低于它，玄学复杂度位于 $O(n)$ 和 $O(n\log^2n)$ 之间。

学会了以上的操作，就可以开心的完成 [UVA1642](https://www.luogu.com.cn/problem/UVA1642) 和 [P5502](https://www.luogu.com.cn/problem/P5502) 啦。

不过这题要稍稍复杂一些。

光压缩了 gcd 的区间，我们依然不能知道哪些区间的 gcd 与 or 的异或值等于 k 。所以我们考虑探究 or 运算的性质。

对于 $a_i$ $or$ $a_{i+1}...a_j$ ，当 j 一定时。存在如下性质：

or 的值随 i 的增大而单调不升。

这个证明也非常简单，我们将 $a_{i+1}$ $or$ $a_{i+2}...a_j$ 看作一个整体 s ， 那么一定有 $(a_i$ $or$ $s) \geqslant s$ 。

由于 or 运算形成的区间也具有单调性，所以我们可以通过枚举每一个 gcd ，后二分出 $(k$ $xor$ $\gcd)$ 在该 gcd 区间的左右端点，即可得到符合条件的 or 区间长度。

那么考虑怎么维护动态的 or 区间。

暴力维护：总体复杂度为大常数 $O(n^2)$ ，回到30分。

线段树维护：总体复杂度为 $O(n\log^3n)$ ，只能得到60分。

ST表维护：总体复杂度为小常数 $O(n\log^2n)$ ，可以获得100分。

参考代码：

预处理：

```cpp
	for(int j=1;j<=LOG[n];j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			f[i][j]=(f[i][j-1] | f[i+(1<<(j-1))][j-1]);
```

修改 gcd 区间的代码同上，不再赘述。

二分查找左右端点：

```cpp
        int l , r , mid;
        for(int j=0;j<V.size();j++){
            l = V[j].fst, r = V[j].lst;
            int fd = k ^ V[j].gc , mid , lft = -1 , rft = -1;
            while(l <= r){
                mid = l + r >> 1;
                int x = mid , y = i;
                int s = LOG[y - x + 1];
                int now = f[x][s] | f[y-(1<<s)+1][s];
                if(now == fd){
                    lft = mid;
                    r = mid - 1;
                }
                else if(now > fd)
                    l = mid + 1;
                else
                    r = mid - 1;
            }
            l = V[j].fst , r = V[j].lst;
            while(l <= r){
                mid = l + r >> 1;
                int x = mid , y = i;
                int s = LOG[y - x + 1];
                int now = f[x][s] | f[y-(1<<s)+1][s];
                if(now == fd){
                    rft = mid;
                    l = mid + 1;
                }
                else if(now > fd)
                    l = mid + 1;
                else
                    r = mid - 1;
            }
            if(lft == -1 || rft == -1)continue;
            ans += rft - lft + 1;
        }
```
Bingo!

---

## 作者：aface0427 (赞：2)

我们枚举左端点L，考虑右端点，那么由于gcd随右端点的增加递减，而每次gcd减小都至少为2，那么就说明最多有logn段，我们二分出这logn段，这logn段gcd值都相同，那问题就变成了在某一段中找L..x的or值为定值的x有多少个，or值是随右段点递增的，然后就可以再二分一下，就可以了 可以预处理一个st表，假设你当前枚举的左端点是L，那第一段的gcd的值一定是a[L]，那你就二分一下右端点，看看这个值是不是a[L]，如果是，就向右二分，否则就向左二分。然后下一段的开头就是这一段的结尾位置+1


---

## 作者：hzjnsy (赞：1)

[CF475D](https://www.luogu.com.cn/problem/CF475D) + [CF875D](https://www.luogu.com.cn/problem/CF875D)

设值域为 $V$。

考虑固定左端点 $i$。由于右端点 $j$ 移动时 $\gcd$ 要么不变要么减半，$\text{or}$ 要么不变要么有某些位变成 $1$。因此区间 $[i,j]$ 的 $(\gcd,\text{or})$ 取值只有 $\mathcal{O}(\log |V|)$ 种。

发现 $\gcd$ 和 $\text{or}$ 的变化均有单调性，用二分和 ST 表求出当前 $(\gcd,\text{or})$ 取值的右端点，检查这一种取值两者异或起来是不是 $k$，统计答案。然后找下一段。

枚举 $i$ 是 $\mathcal{O}(n)$，取值种数是 $\mathcal{O}(\log |V|)$，二分是 $\mathcal{O}(\log n)$，ST 表预处理是 $\mathcal{O}(n\log n \log |V|)$，查询是 $\mathcal{O}(\log |V|)$。这么算下来，时间复杂度为 $\mathcal{O}(n\log n\log^2|V|)$，空间复杂度为 $\mathcal{O}(n\log n)$。

但是有大佬貌似证出来时间复杂度是两个 $\log$ 的，可惜我不会。先咕着，姑且认为是常数小跑不满才能过。

**[代码](https://www.luogu.com.cn/paste/80ynzz5f)**

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3794)

# 前置知识

[最大公约数](https://oi-wiki.org/math/number-theory/gcd/) 

# 解法

$\gcd$ 和 $\operatorname{or}$ 在固定左端点的情况下至多会变化 $O(\log V)$ 次。

以 $\gcd$ 为例，考虑求出所有的四元组 $(l,r,x,val)$ 表示 $\forall i \in [l,r],\gcd\limits_{j=i}^{x} \{ a_{j} \}=val$。
  - 本题中因为 $x$ 一维可以“滚”掉，所以省去不写。

具体地，枚举右端点 $x$，类似单调栈的写法（本身是单调的），继承 $x-1$ 的四元组并及时去重/重构栈。

处理完后判断一下每个值区间是否有交求贡献即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
struct  node
{
	ll val,l,r;
}g[500010],o[500010];
ll a[500010],l[500010],r[500010],cnt_g,cnt_o;
ll gcd(ll a,ll b)
{
	return b?gcd(b,a%b):a;
}
int main()
{
	ll n,k,ans=0,len,i,j;
	cin>>n>>k;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=cnt_g;j++)
		{
			g[j].val=gcd(g[j].val,a[i]);
		}
		cnt_g++;
		g[cnt_g]=(node){a[i],i,i};
		len=0;
		for(j=1;j<=cnt_g;j++)
		{
			if(g[j].val==g[j-1].val)
			{
				g[len].r=g[j].r;
			}
			else
			{
				len++;
				g[len]=g[j];
			}
		}
		cnt_g=len;
		for(j=1;j<=cnt_g;j++)
		{
			l[g[j].val]=g[j].l;
			r[g[j].val]=g[j].r;
		}
		for(j=1;j<=cnt_o;j++)
		{
			o[j].val|=a[i];
		}
		cnt_o++;
		o[cnt_o]=(node){a[i],i,i};
		len=0;
		for(j=1;j<=cnt_o;j++)
		{
			if(o[j].val==o[j-1].val)
			{
				o[len].r=o[j].r;
			}
			else
			{
				len++;
				o[len]=o[j];
			}
		}
		cnt_o=len;
		for(j=1;j<=cnt_o;j++)
		{
			if(l[o[j].val^k]!=0&&min(o[j].r,r[o[j].val^k])>=max(o[j].l,l[o[j].val^k]))
			{
				ans+=min(o[j].r,r[o[j].val^k])-max(o[j].l,l[o[j].val^k])+1;
			}
		}
		for(j=1;j<=cnt_g;j++)
		{
			l[g[j].val]=r[g[j].val]=0;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Alex_Eon (赞：0)

#### [$\color{red}博客内食用效果更佳（点我）$](https://www.luogu.com.cn/blog/Ksy/solution-p3794)
### 思路：二分+ST 表
### 复杂度：$O(n\log^3{n})$
### 主体思路

首先考虑暴力做法，枚举左右端点，暴力算区间 $\gcd$，区间或，复杂度感人。区间 $\gcd$ 与区间或显著可以用线段树或者 ST 表维护，因为本题无修改，我们可以采用 **ST 表**进行更优的处理，复杂度来到 $O(n^2\log(n))$。

注意到一个常见的性质，**连续段的 $\gcd$ 和或运算的种类在 $\log$ 级别上**。换句话说，对于一个点，向左或向右扩展 $\gcd$ 和或运算最多会有 $\log$ 级别个不同结果。考虑枚举右端点，每次**用二分向左扩展左端点，尝试找到第一个与当前段结果（或运算和 $\gcd$ 运算均要做一遍）不同的位置**，然后我们得到了 $\log$ 级别个的左端点，遍历一遍累加答案即可。

因为 $\gcd$ 运算是 $\log$ 级别的，所以总复杂度为 $O(n\log^3{n})$。

### 代码实现需要注意的地方：

- `^` 运算符优先级低于 `==` 运算符，需要加括号。
- 开 **long long**。
- 注意初值设置。

### 参考代码：
代码中以字母 $g$ 结尾的变量、函数为 $\gcd$ 运算相关，以 $o$ 结尾的为或运算相关。  
详见注释。
```cpp
#include<bits/stdc++.h>
#define LL long long
#define UN unsigned
using namespace std;
//--------------------//
//IO
inline int rd()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
//--------------------//
const int N=5e5+5,LG=30;

int n,k;
int a[N];

struct ST
{
    int lg[N];
    int stg[N][LG],sto[N][LG];

    void init()
    {
        for(int i=2;i<=n;i++)
            lg[i]=lg[i>>1]+1;
        for(int i=1;i<=n;i++)
            stg[i][0]=sto[i][0]=a[i];
        for(int j=1;j<=lg[n];j++)
        {
            for(int i=1;lg[n-i+1]>=j;i++)
            {
                stg[i][j]=__gcd(stg[i][j-1],stg[i+(1<<(j-1))][j-1]);
                sto[i][j]=sto[i][j-1]|sto[i+(1<<(j-1))][j-1];
            }
        }
        return;
    }

    int qg(int l,int r)
    {
        int lgl=lg[r-l+1];
        return __gcd(stg[l][lgl],stg[r-(1<<lgl)+1][lgl]);
    }
    int qo(int l,int r)
    {
        int lgl=lg[r-l+1];
        return sto[l][lgl]|sto[r-(1<<lgl)+1][lgl];
    }
}S;//ST 表部分

int findg(int l,int r,int pos)//二分部分
{
    int res=0,val=S.qg(r,pos);
    while(l<=r)
    {
        int mid=l+r>>1;
        if(S.qg(mid,pos)==val)
            r=mid-1;
        else
            res=mid,l=mid+1;
    }
    return res;
}
int findo(int l,int r,int pos)
{
    int res=0,val=S.qo(r,pos);
    while(l<=r)
    {
        int mid=l+r>>1;
        if(S.qo(mid,pos)==val)
            r=mid-1;
        else
            res=mid,l=mid+1;
    }
    return res;
}
int tcnt,tem[N];
LL ans;
void work()
{
    for(int tp,i=1;i<=n;i++)
    {
        tem[tcnt=1]=tp=i;//对于右端点我们需要存为第一个左端点
        while(true)
        {
            tp=findg(1,tp,i);
            tem[++tcnt]=tp;
            if(tp==0)
                break;
        }
        tp=i;
        while(true)
        {
            tp=findo(1,tp,i);
            tem[++tcnt]=tp;
            if(tp==0)
                break;
        }
        sort(tem+1,tem+tcnt+1);
        tcnt=unique(tem+1,tem+tcnt+1)-tem-1;
        for(int x,xg,xo,j=tcnt;j>1;j--)
        {
            x=tem[j],xg=S.qg(x,i),xo=S.qo(x,i);
            if((xo^xg)==k)
                ans+=tem[j]-tem[j-1];//这一段长度是这一段的贡献
        }
    }
}
//--------------------//
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    S.init();
    work();
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：TernaryTree (赞：0)

枚举左端点 $l$。对于数对 $\left(\gcd_{i=l}^na_i,\operatorname{or}_{i=l}^n a_i\right)$，只有 $\Theta(\log V)$ 种取值，这是因为前缀 $\gcd$ 只能不变或者至少减半，前缀 $\operatorname{or}$ 最多只会填满 $\log V$ 个位置。

维护 $\gcd$ 与 $\operatorname{or}$ 的倍增表（即 ST）。对于左端点 $l$，暴力找块。

```cpp
for (int l = 1; l <= n; l++) {
	int p = l, x = a[l], y = a[l];
	while (p <= n) {
		int i = x, j = y, s = p;
		x = __gcd(i, a[p]), y = j | a[p];
		for (int d = 19; ~d; d--) {
			if (p + (1 << d) - 1 <= n && __gcd(i, g[p][d]) == x && (j | z[p][d]) == y) {
				i = __gcd(i, g[p][d]);
				j |= z[p][d];
				p += (1 << d);
			}
		}
		if ((x ^ y) == k) ans += p - s;
	}
}
```

这里看似是三只 $\log$ 的，但是巨佬[华山抡剑](https://www.luogu.com.cn/user/152213)证出来对 $n$ 个数依次 $\gcd$ 的复杂度是 $n+\log V$ 的。所以这里内层倍增循环里的 $\gcd$ 复杂度是可以扔出来的，总复杂度 $\Theta(n\log^2 n)$，跑不满，能过。

---

## 作者：Provicy (赞：0)

$\gcd$ 的性质比较常见，当以 $i$ 为左右端点时，包含 $a_{i}$ 的一段连续 $\gcd$ 的值最多只会有 $\log{a_{i}}$ 个。证明很简单，当 $gcd$ 改变时说明减少了至少一个质因子，最小的质数是 $2$，所以最多改变 $\log_{2}a_{i}$ 次。

$or$ 或者是 $and$ 的改变次数也类似，每次改变至少将一个二进制位上的 $0$ 变成 $1$ 或者是把 $1$ 变成 $0$，故最多改变也是 $\log_{2}a_{i}$ 次。注意 $xor$ 没有这个性质。

对于本题来说，枚举 $i$ 并固定 $i$ 为左端点，向右二分可以得到 $\log$ 段 $\gcd$ 和 $or$。观察到值域较小，可以用 $book$ 记下每段 $\gcd$ 的左右端点，然后在 $or$ 中直接查询，两个区间的相交长度就是这一段 $or$ 的贡献。这样我们可以得到 $O(n\log^2n)$ 的做法，但是它明显不够优秀。

考虑当 $i$ 为左端点时，$1$ 到 $i-1$ 这一段没有任何用处，即我们对于每个 $i$ 都是独立的。可以尝试将 $i$ 作为右端点，那么以 $i$ 为右端点的 $\gcd$ 和 $or$ 个数也是 $\log$ 个。然后我们可以把 $i-1$ 时的存 $\gcd$ 和 $or$ 的数组拿过来，和 $a_{i}$ 分别做 $\gcd$ 与 $or$，去重后每个数组内不同元素个数仍然是 $\log$ 个。

一个问题就是直接 $\gcd$ 与 $or$ 后元素无序了怎么办？所以我们需要证明做了如上操作后，$\gcd$ 与 $or$ 数组内的元素仍是有序的。

对于 $\gcd$，存在 $x>y$，易知 $y|x$，那么显然有 $\gcd(z,y)\leq \gcd(z,ky)$。

对于 $or$，存在 $x>y$，那么 $x$ $or$ $y=x$，那么显然有 $y$ $or$ $k$ $\leq$ $x$ $or$ $k$。

所以得到了一个 $O(n\log n)$ 的做法。

$\text{Code}:$

```cpp
#include <bits/stdc++.h>
//#pragma GCC optimize(3)
//#define int long long
#define ri register
#define mk make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define is insert
#define es erase
using namespace std;
const int N = 1000010;
inline int read()
{
    int s = 0, w = 1;
    ri char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        s = (s << 3) + (s << 1) + (ch ^ 48), ch = getchar();
    return s * w;
}
int n, K, a[N], v1[N], v2[N];
long long Ans;
struct Node
{
    int w, len, l, r;
} p[N], q[N];
int cnt1, cnt2;
inline int gcd(int x, int y) { return y ? gcd(y, x % y) : x; }
signed main()
{
    n = read(), K = read();
    for (ri int i = 1; i <= n; i++)
        a[i] = read();
    for (ri int i = 1; i <= n; i++)
    {
        for (ri int j = 1; j <= cnt1; j++)
            p[j].w = gcd(p[j].w, a[i]);
        p[++cnt1] = (Node){a[i], 1, i, i};
        int tot = 0;
        for (ri int j = 1; j <= cnt1; j++)
        {
            if (j == 1 || p[j].w != p[j - 1].w)
                tot++, p[tot] = (Node){p[j].w, p[j].len, p[tot - 1].r + 1, p[tot - 1].r + p[j].len};
            else
                p[tot].len += p[j].len, p[tot].r += p[j].len;
        }
        cnt1 = tot, tot = 0;
        for (ri int j = 1; j <= cnt2; j++)
            q[j].w |= a[i];
        q[++cnt2] = (Node){a[i], 1, i, i};
        for (ri int j = 1; j <= cnt2; j++)
        {
            if (j == 1 || q[j].w != q[j - 1].w)
                tot++, q[tot] = (Node){q[j].w, q[j].len, q[tot - 1].r + 1, q[tot - 1].r + q[j].len};
            else
                q[tot].len += q[j].len, q[tot].r += q[j].len;
        }
        cnt2 = tot, tot = 0;
        for (ri int j = 1; j <= cnt1; j++)
            v1[p[j].w] = p[j].l, v2[p[j].w] = p[j].r;
        for (ri int j = 1; j <= cnt2; j++)
        {
            int x = q[j].w ^ K;
            if (!v1[x])
                continue;
            Ans += max(0ll, 1ll * (min(q[j].r, v2[x]) - max(q[j].l, v1[x]) + 1));
        }
        for (ri int j = 1; j <= cnt1; j++)
            v1[p[j].w] = v2[p[j].w] = 0;
    }
    printf("%lld\n", Ans);
    return 0;
}
```


---


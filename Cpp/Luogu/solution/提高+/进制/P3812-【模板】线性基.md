# 【模板】线性基

## 题目背景

这是一道模板题。


## 题目描述

给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。


## 说明/提示

$ 1 \leq n \leq 50, 0 \leq S_i < 2 ^ {50} $


## 样例 #1

### 输入

```
2
1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4
1 5 9 4
```

### 输出

```
13
```

# 题解

## 作者：Marser (赞：343)

## 线性基简介

线性基是一种擅长处理异或问题的数据结构.设值域为$[1,N]$，就可以用一个长度为$\lceil \log_2N \rceil$的数组来描述一个线性基。特别地，线性基第$i$位上的数二进制下最高位也为第$i$位。

一个线性基满足，对于它所表示的所有数的集合$S$，$S$中任意多个数异或所得的结果均能表示为线性基中的元素互相异或的结果，即意，线性基能使用异或运算来表示原数集使用异或运算能表示的所有数。运用这个性质，我们可以极大地缩小异或操作所需的查询次数。

## 插入和判断
我们考虑插入的操作，令插入的数为$x$，考虑$x$的二进制最高位$i$，
- 若线性基的第$i$位为$0$，则直接在该位插入$x$，退出；
- 若线性基的第$i$位已经有值$a_i$，则$x = x\oplus a_i$，重复以上操作直到$x=0$。

如果退出时$x=0$，则此时线性基已经可以表示原先的$x$了；反之，则说明为了表示$x$，往线性基中加入了一个新元素。

很容易证明这样复杂度为$\log_2x$，也可以用这种方法判断能否通过原数列异或得到一个数$x$。

```cpp
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
```

## 查询异或最值
查询最小值相对比较简单。考虑插入的过程，因为每一次跳转操作，$x$的二进制最高位必定单调降低，所以不可能插入两个二进制最高位相同的数。而此时，线性基中最小值异或上其他数，必定会增大。所以，直接输出线性基中的最小值即可。

考虑异或最大值，从高到低遍历线性基，考虑到第$i$位时，如果当前的答案$x$第$i$位为$0$，就将$x$异或上$a_i$；否则不做任何操作。显然，每次操作后答案不会变劣，最终的$x$即为答案。

同样，我们考虑对于一个数$x$，它与原数列中的数异或的最值如何获得。用与序列异或最大值类似的贪心即可解决。
## 查询$k$小值
我们考虑进一步简化线性基。显然，一个线性基肯定可以表示为若干个形如$2^i$的数。从高到低处理线性基每一位，对于每一位向后扫，如果当前数第$i$位为$0$，且线性基第$i$位不为$0$,则将当前数异或上$a_i$。这一操作可以在$O(\log_2^2 n)$的时间内解决。

经过这一步操作后，设线性基内共有$cnt$个数，则它们共可以表示出$2^{cnt}$个数。当然，对于$0$必须特殊考虑。如果插入的总数$n$与$cnt$相等，就无法表示$0$了。

同样，考虑最小值时，也必须要考虑到$0$的情况。事实上，如果插入时出现了未被加入的元素，就肯定可以表示出$0$。

随后，我们考虑将$k$二进制拆分，用与快速幂类似的方法就可以求出第$k$大值。

学过线性代数的同学应该可以看出，这个过程就是对一个矩阵求解异或意义下的秩的过程。因此，$cnt \leq \lceil \log_2N \rceil$一定成立。而最终，线性基中保存的也是异或意义下的一组极小线性无关组。

同样，有关线性基的一切运算都可以看做矩阵的初等行列变换，也就可以将其看做线性规划问题。同样，可以离线使用高斯消元来构造极小线性基。

```cpp
bool flag;//可以表示0
ll qmax(ll res=0){
    for(reg int i=MN;~i;i--)
        res=max(res,res^a[i]);
    return res;
}
ll qmin(ll res=0){
    if(flag)return 0;
    for(reg int i=0;i<=MN;i++)
        if(a[i])return a[i];
}
ll query(ll k){
    reg ll res=0;reg int cnt=0;
    k-=flag;if(!k)return 0;
    for(reg int i=0;i<=MN;i++){
        for(int j=i-1;~j;j--)
            if(a[i]&(1ll<<j))a[i]^=a[j];
        if(a[i])tmp[cnt++]=a[i];
    }
    if(k>=(1ll<<cnt))return -1;
    for(reg int i=0;i<cnt;i++)
        if(k&(1ll<<i))res^=tmp[i];
    return res;
}
```

## 代码
```cpp
#include<bits/stdc++.h>
#define reg register
using namespace std;
typedef long long ll;
const int MN=60;
ll a[61],tmp[61];
bool flag;
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
ll qmax(ll res=0){
    for(reg int i=MN;~i;i--)
        res=max(res,res^a[i]);
    return res;
}
ll qmin(){
    if(flag)return 0;
    for(reg int i=0;i<=MN;i++)
        if(a[i])return a[i];
}
ll query(ll k){
    reg ll res=0;reg int cnt=0;
    k-=flag;if(!k)return 0;
    for(reg int i=0;i<=MN;i++){
        for(int j=i-1;~j;j--)
            if(a[i]&(1ll<<j))a[i]^=a[j];
        if(a[i])tmp[cnt++]=a[i];
    }
    if(k>=(1ll<<cnt))return -1;
    for(reg int i=0;i<cnt;i++)
        if(k&(1ll<<i))res^=tmp[i];
    return res;
}
int main(){
    int n;ll x;scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%lld",&x),ins(x);
    printf("%lld\n",qmax());
    return 0;
}
```

---

## 作者：帅到报警 (赞：339)

原来我听到线性基的时候,我觉得可能是什么非常高深的算法(눈‸눈)。但是今天用了一个早上自学后，发现其实并没有想象中的那么难。所以写篇板子题的题解纪念一下。

### 一、定义
首先什么是线性基呢？对于一组数 A1...An，他们的线性基为 P1...Pm ，其中** Pi 是出现 1 的最高位在第 i 位的数** 。很容易想到，线性基的值域与原数组的值域相同。那么我们便可以通过线性基( ☉_☉)≡☞o────★°来求最大异或和。

### 二、构造方法
对于每一个数，我们找出他的最高位的 1 在第 i 位， 如果此时 Pi 为零，就将这个数加入线性基，否则异或 Pi 继续找。然后我们就可以在 0 到 k 位上处理好每一位的线性基。这样得到的线性基保证每一位都能有对应的最大值。
	
    例：4个数 2 9 10 17
    2 ----> 10
    9 ----> 1001
    10 ----> 1010
    17 ----> 10001
    最终得到的 P4-P0: 17 9 0 2 1
    
### 三、寻找答案
在我们得到的线性基中，从高位到低位用贪心贪掉每一个元素（即如果异或了这个元素变大就异或他）。那么为什么可以**将一个没有单调性的异或和**转化为贪心呢？ ( •́ _ •̀)？

证明：首先从高位向低位找的过程中，每一个高位的值都不会被后面的元素所覆盖影响。然后我们可以结合下面三种情况理解（给出的是二进制）：

	1、
	现在的答案为1001010， Pi 为100001，
    那么异或后答案为1001011，肯定更优；
    
    2、现在的答案为1011111， Pi 为111111，
    那么异或后的答案为1100000，虽然后面变小了
    但此高位变大了所以也是更优；
    
    3、现在的答案为1100000， Pi 为111111.
    那么异或后的答案为1011111，虽然后面变大了
    但此高位变小了所以肯定不优；
所以我们可以发现此处的贪心即贪**每一位的值使他最大**。

### 然后我们就可以愉快的做出了这道模板题了！！！
然鹅，线性基并没有结束(´≖◞౪◟≖)

（如果已经被线性基冲昏了的直接跳过吧(；´ﾟωﾟ｀人)）

### 四、查询某个数
就是查找某个数是否可以由这 n 个数中任一个数异或得到。首先还是刚才那个定理：**线性基的值域与原数组的值域相同**。

还有我们要发现一个性质：**如果 x1 ^ x1 = x3, 那么 x3 ^ x2 = x1,且 x3 ^ x1 = x2**（可以自己证明一下）。

我们也是从低到高扫这个数的每一位，如果这第 i 位为 1，就异或上 Pi，然后知道处理到最后一位。如果变成 0 了，那么就是可以的。

### 【正解】
```cpp
#include <bits/stdc++.h>
#define N 51
#define ll long long
using namespace std;

int n;
ll ans;
ll a[N], p[101];

inline ll read()
{
    char ch = getchar();
	ll x = 0, f = 1;
    while(ch > '9' || ch < '0')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
    while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
    return x * f;
}

void Get_LB(ll x)
{
	for(int i = 62; i >= 0; i--)
	{
		if(!(x >> (ll)i))
			continue;
		if(!p[i])
		{
			p[i] = x;
			break;
		}
		x ^= p[i];
	}
}

int main()
{
	n = read();
	for(int i = 1; i <= n; i++)
		Get_LB(a[i] = read());
	for(int i = 62; i >= 0; i--)
		if((ans ^ p[i]) > ans)
			ans ^= p[i];
	cout << ans;
	
	 return 0;
}
```

---

## 作者：wrpwrp (赞：204)

upd:补了点东西
## 用处
~~没用我学这东西干嘛~~  
+ 快速查询一个数是否可以被一堆数异或出来
+ 快速查询一堆数可以异或出来的最大/最小值
+ 快速查询一堆数可以异或出来的第k大值  

~~这么点？~~  
还有点性质在下面 ~~可能有点用~~  
## 性质 
+ 原数列里的任何一个数都可以通过线性基里的数异或表示出来
+ 线性基里任意一个子集的异或和都不为$0$
+ 一个数列可能有多个线性基，但是线性基里数的数量一定唯一，而且是满足性质一的基础上最少的

## 原理&实现  
由于我想写简单一点，直接对代码写，所以真正的关于线性代数的那一部分就没写了 ~~妄图掩盖自己不会的事实~~  
### 约定
以下$p[i]$表示原序列的线性基数组。
### 构造
~~先贴代码~~
把一个数插入线性基：
``` cpp
inline void ins(LL x) {
	for(R int i=62;i>=0;i--)
		if(x&(1LL<<i)) {
			if(!p[i]) { p[i]=x,cnt++; break; }
			else x^=p[i];
		}
}
```
人话描述：
+ 从高位到低位进行。
+ 如果$x_{(2)}$第$i$位为$1$，判断$p[i]$是否插入，没有就插入**并且退出**，否则就异或上$p[i]$去进行下一位操作 。 
  
那么，通过观察这个构造，我们再来~~感性~~理解线性基。
+ 异或的一个小性质：$ x \oplus y \oplus y =x $。
+ 性质一：观察插入过程，如果没有成功插入，对于$x_{(2)}$的每一位，要不就是不存在，要不就是异或上$p[i]$变成了$0$，那么最终$x$如果没有插入，那就意味着原有的线性基可以把它异或出来，它就没有插入的必要了。而更显然的，线性基中的数肯定是可以表示的。于是**原序列中的每一个数都可以通过线性基表示出来。**
+ 性质二：假设出现了$p[1] \oplus p[2]\oplus p[3]=0$,那就会有$p[1]\oplus p[2]=p[3]$，根据之前的定义，$p[3]$是不会被插入的。所以也可以得出线性基的任意一个子集异或和都不为$0$，所以在之后求第$k$大的时候和一些别的时候，**注意特判$0$**。
+ 性质三：考虑分类讨论
    + 当所有元素都可以插入线性基的时候，性质三显然成立
    + 设有一个元素$x$不能插入线性基，那就会有$x=0$或者是$p[a]\oplus p[b]\oplus p[c]=x$。显然当$x=0$的时候无论如何都不能插入线性基，而另一种情况则代表等式$p[a]\oplus p[b]\oplus x=p[c]$也就是说如果先插入$x$，$p[c]$就无法插入了，又因为观察插入过程的时候，每一个插入的数对应着一位，所以$x$与$p[c]$相排斥只会影响一位上的问题，那也就代表着**线性基里的数可能不同，但是总数肯定是一定的**。  

于是我们初步理解了线性基  
### 查询一个元素是否可以被异或出来
从高到低，如果这一位为$1$就异或上这一位的线性基，把$1$消去，根据性质一，如果最后得到了$0$，那这个数就可以表示出来。
```cpp
inline int ask(LL x) {
	for(R int i=62;i>=0;i--) 
		if(x&(1LL<<i)) x^=p[i];
	return x==0;
}
```
### 查询异或最大值
按位贪心即可。
```cpp
inline LL askmx() {
	LL ans=0;
	for(R int i=62;i>=0;i--)
		if((ans^p[i])>ans) ans^=p[i];
	return ans;
}
```
### 查询异或最小值
其实异或的最小值一般来说就是线性基里的最小元素，因为插入这个元素的时候我们总是尽量让它的高位为$0$才来插入这一位。但是为什么是“一般”呢？因为有可能会有出现$0$，得要在插入的时候记下个标记来特判才行。
```cpp
inline LL askmn() {
	if(zero) return 0;
	for(R int i=0;i<=62;i++)
		if(p[i]) return p[i];
}
```
### 查询异或第$k$小
这个东东我感觉实现还是有那么点点复杂的哈。
首先考虑，要是每一位的选择都不会影响下一位的话，那就可以直接从高到低按位去选择就行了，就类似于二叉树求$rank$的玩法。但是我们之前建出来的线性基是没有这个性质的。比如$p[3]=101_{2},p[0]=1_{2}$的时候就炸了。所以我们考虑重构一个数组$d$来解决这个问题。先上代码：
```cpp
inline void rebuild() {
	cnt=0;top=0;
	for(R int i=MB;i>=0;i--)
		for(R int j=i-1;j>=0;j--)
			if(p[i]&(1LL<<j)) p[i]^=p[j];
	for(R int i=0;i<=MB;i++) if(p[i]) d[cnt++]=p[i];
}
```
那么这是在干啥呢，就是在尽力把每个$p[i]$只留下第$i$位的$1$，从而使得各个位之间互不影响，也就是说它的理想效果如下：
$p[0] ~0~0~0~0~1$
$p[1] ~0~0~0~1~0$
$p[2] ~0~0~1~0~0$
$p[3] ~0~1~0~0~0$
$p[4] ~1~0~0~0~0$
但有时候并不能达到这个样子，可能会出现如下情况：
$p[0] ~0~0~0~0~1$
$p[1] ~0~0~0~0~0$
$p[2] ~0~0~1~0~0$
$p[3] ~0~1~0~0~0$
$p[4] ~1~0~0~1~0$
但是这个时候我们注意到，我们的目的已经达到了，互不影响的任务已经达成了，显然此时为$0$的$p$值不会对排名有任何影响，不用管它了。把信息导入到$d$数组后，查询$k$小代码不难写出：
```cpp
inline LL kth(int k) {
	if(k>=(1LL<<cnt)) return -1;
	LL ans=0;
	for(R int i=MB;i>=0;i--)
		if(k&(1LL<<i)) ans^=d[i];
	return ans; 
}
```
其实我个人觉得这个代码还得要自己理解一下。  
~~背板子也行~~
但是这样其实还不太对，因为我们并没有考虑$0$的情况，所以还要去考虑一下$0$的情况，特判即可。
```cpp
printf("%lld\n",tmp-zero?kth(tmp-zero):0LL);
```
### 查询排名
```cpp
inline int rank(LL x) {
      int ans = 0;
      for(R int i = cnt - 1; i >= 0; i --)
                  if(x >= d[i]) ans += (1 << i), x ^= d[i];
      return ans + zero; 
}
```
注：这个$d[i]$是重建后的线性基。

于是线性基的基本操作就结束啦！
## 习题
1. [Luogu P3812 线性基](https://www.luogu.com.cn/problem/P3812)
[code](https://www.cnblogs.com/HN-wrp/p/12812931.html)

2. [Luogu P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)
[code](https://i-beta.cnblogs.com/posts/edit;postId=12812964)
3. [Luogu P4301 [CQOI2013]新Nim游戏](https://www.luogu.com.cn/problem/P4301)
[code](https://www.cnblogs.com/HN-wrp/p/12812983.html)
4. [Luogu P4570 [BJWC2011]元素](https://www.luogu.com.cn/problem/P4570)
[code](https://www.cnblogs.com/HN-wrp/p/12813004.html)
5. [HDU 3949 XOR](http://acm.hdu.edu.cn/showproblem.php?pid=3949)
   [code](https://www.cnblogs.com/HN-wrp/p/12813014.html)
6. [Luogu P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)
   [code](https://www.cnblogs.com/HN-wrp/p/12818708.html)
7. [Luogu P3292 [SCOI2016]幸运数字](https://www.luogu.com.cn/problem/P3292)
   [code](https://www.cnblogs.com/HN-wrp/p/12820816.html)
## EX
[dalao博客](https://blog.sengxian.com/algorithms/linear-basis)


---

## 作者：万弘 (赞：41)

似乎洛谷的题解没有和蓝书做法相同的。。那我来介绍一下蓝书的做法。  
先来一些定义：  
考虑将n个数（二进制下）看成n个向量，每个向量中的每个元素仅有0、1两种取值。  
如果向量$X$能被$a_1,a_2..a_n$这些向量通过异或运算得到，则称$X$能被$a_1,a_2..a_n$**表出**。如果某个向量集合中存在若干个向量能被其它向量表出，则这些向量**线性相关**，否则**线性无关**  
**定义一个向量集合的线性基为其极大线性无关子集**（可能有多个线性基，但这没有关系）（显然线性基可以表出这个向量集合）  
**线性空间**是对异或运算封闭的向量集合。

另外，异或高斯消元仅有向量间的异或操作，所以消元不会改变这些向量能表出的线性空间。因此，高斯消元可以求得一组线性基。

现在回到本题。（为了简便，可以将向量压缩为一个整数）先用高斯消元求得一组线性基。由高斯消元可得（没有学习过高斯消元的请出门左转高斯消元题解区），该线性基中，主元所在位为1的向量是唯一的。接下来我们可以从高位到低位贪心了。假设现在在考虑第$i$个向量$a_i$（向量降序），其最高位是$x$,前$i-1$个向量异或得到的最大整数为$res$。
1. 如果$res$的第$x$位是0，则令$res\ xor\ a_i$
2. 否则不改变$res$

接下来考虑这种做法的正确性。  
如果$res$的第$x$位是0但不改变$res$，而改变得到$res'$。由于向量降序，比x更高的位和x这一位无法再改变。即使$res$接下来的位全部是1，也没有x这一位是1大，即得到$res<res'$.因此操作1正确。  
如果$res$的第$x$位是1但改变res，得到$res'$.由于向量降序，比x更高的位和x这一位无法再改变。即使$res'$接下来的位全部是1，也没有x这一位是1大，即得到$res'<res$.因此操作2正确。  
证毕。  
对线性基中的向量（降序）做这两种操作即可。时间复杂度瓶颈在于高斯消元，将向量压缩为整数优化后为$O(n^2)$ （因此请求管理加大数据范围至$n\le 5000$）
```cpp
/**********/
typedef unsigned long long ull;
#define MAXN 5011
ll a[MAXN];
int main()
{
	ll n=read(),t=n;//t是线性基大小
	for(ll i=1;i<=n;++i)a[i]=read();
	for(ll i=1;i<=n;++i)//异或高斯消元
	{
		for(ll j=i+1;j<=n;++j)
			if(a[j]>a[i])std::swap(a[j],a[i]);
		if(!a[i])
		{
			t=i-1;break;
		}
		for(ll j=51;j>=0;--j)
			if(a[i]&(1ull<<j))
			{
				for(ll k=1;k<=n;++k)
					if(i!=k&&(a[k]&(1ull<<j)))a[k]^=a[i];
				break;
			}
	}
	ll ans=0;
	for(ll i=1;i<=t;++i)
	{
		for(ll j=51;j>=0;--j)//找最高位
			if(a[i]&(1ull<<j))
			{
				if(!(ans&(1ull<<j)))ans^=a[i];//操作1
				break;
			}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：rui_er (赞：33)

刚刚口胡并学了线性基，就来写篇题解，记录一下。

---

从 $n$ 个数中选取若干个，使他们的异或和最大。

既然是异或和，因为异或是位运算，肯定要用到二进制的。

考虑异或和的性质：对于这一位，有奇数个 $1$ 求异或和，结果为 $1$；有偶数个 $1$ 求异或和，结果为 $0$。这一性质告诉我们，当我们对当前位置完成决策的时候，后面所有位的异或和无论怎样也不会影响到现有结果。想到从高位到低位扫一遍，对每一位取最优决策，就是结果。

但因为每一位二进制位可能有很多 $1$，不方便进行决策，于是思考能不能**构造一个序列，使得在这个序列中，任取若干个数求异或和的结果组成的集合，与原序列求异或和的结果组成的集合一样，且这个序列的每个数的最高位 $1$ 所在位数不一样**呢？这种情况下，我们在新序列上决策和在原数列上决策是等效的。

~~但是我太菜了发现并不会构造，怎么办呢？上百度搜线性基正解吧。~~

结果一搜发现我已经口胡出来了，愣是傻傻的不会构造 /jk /jk，那就继续说吧。

线性基就是由原数列集合构造出的满足下面性质的集合：

1. 线性基内的元素可以通过求异或和，得到原集合的元素任意求异或和得到的所有值。
2. 线性基是满足上面性质的最小的集合。
3. 线性基不存在异或和为 $0$ 的子集。
4. 线性基中，任取不同的子集求异或和，得到的答案不同。（即线性基子集的异或和具有唯一性）
5. 线性基内所有元素的二进制最高位互不相同。

考虑进行构造：

在线性基插入元素 $x$，从高位向低位扫，如果 $x$ 二进制下该位为 $1$，且不存在最高位为该位的线性基元素，将其加入线性基。如果该位为 $1$，但已经存在元素的最高位为该位，将 $x$ 异或上该元素，继续向后搜。

要查询最大值，从高位到低位枚举线性基中最高位为该位的元素，如果答案异或上这个数比原来的答案大，更新答案。这样因为更低位的结果无法影响当前位，因此这一方法是最优的。

---

代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 55, bit = 50;
 
ll n, a, p[N];
void insert(ll k) {
	for(ll i=bit;i>=0;i--) {
		if(!(k&(1LL<<i))) continue;
		if(!p[i]) return p[i] = k, void();
		k ^= p[i];
	}
}
ll maxXor() {
	ll res = 0;
	for(ll i=bit;i>=0;i--) res = max(res, (res^p[i]));
	return res;
}

int main() {
	scanf("%lld", &n);
	while(n--) {scanf("%lld", &a); insert(a);}
	printf("%lld\n", maxXor());
	return 0;
}
```

---

## 作者：i207M (赞：28)

# 线性基

## 线型基在成功插入后要写break！！！

## 简介

你有一个原集合T;

线性基是一个集合，里边的元素通过异或，可以不多不少的凑出T，且线型基最小；

## 性质

1.设线性基的异或集合中不存在0。

2.线性基的异或集合中每个元素的异或方案唯一，其实这个跟性质1是等价的。

3.线性基二进制最高位互不相同。

4.如果线性基是满的，它的异或集合为[1,2n−1]。

5.线性基中元素互相异或，异或集合不变。

## 用途

给定n个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。

## 实现

因为0是^的单位元，所以在插入时，对于二进制的每一位，我们只需要让集合中的唯一一个数的最高位时它就好（因为再多一个没有用，只会更麻烦）

插入：

从高到低检查该数，如果此位为1，查一下线型基中该位有没有被占用过，如果为空，插入到线型基中；如果不为空，用当前位的数异或它（即废掉它的这一位），继续插入；

这样一个数只有两种下场：插入/被^成0；

求最大值：

从高位到低位贪心，如果异或上该数使答案变大，就异或；

若要求出线性基内的元素与一个给定的数M的最大异或值，只需在求解时把x的初值设为M即可；

### 代码


```cpp
struct LBase {
    ll d[61];
    LBase() {memset(d, 0, sizeof d);}
    bool insert(ll x) {
        for (ri i = 60; i >= 0; --i)
            if (x & ((ll)1 << i)) {
                if (d[i]) x ^= d[i];
                else {d[i] = x; break;}
            }
        return x > 0;
    }
    ll qmax() {
        ll x = 0;
        for (ri i = 60; i >= 0; --i)
            if (d[i])
                if ((x ^ d[i]) > x) x ^= d[i];
        return x;
    }
    void merge(const LBase &a) {
        for (ri i = 60; i >= 0; --i)
            if (a.d[i]) insert(a.d[i]);
    }
};
```

## 线性基求第k小

这是，我们使用的线性基就和上面的构造方法不太一样了，因为上面只是求最大值；而这里我们要求第k大；

首先讨论边界情况：设线性基的大小为cnt，那么除去0外，它能表示的数字个数就是$2^{cnt}-1$个；

为什么把0单独说呢？因为大部分情况下，题目是不允许我们不选的；所以要特殊记录一下线性基中是否有0；

求第k小（除去0以外的，如果有0，就$--k$）

**如果k的第i位=1，答案就异或线性基中从小到大第i+1个数**

## 注意是线性基有值的第...位

类似二进制的证明；

![](https://cdn.luogu.com.cn/upload/pic/28626.png)

HDU 3949

```
int bas[64], cnt, sz;
void insert(int x) {
	for (ri i = 60; i >= 0; --i) {
		if ((x >> i) & 1) {
			if (bas[i]) x ^= bas[i];
			else {
				++cnt;
				bas[i] = x;
				for (ri j = i - 1; j >= 0; --j)
					if (bas[j] && ((bas[i] >> j) & 1)) bas[i] ^= bas[j];
				for (ri j = 60; j > i; --j)
					if ((bas[j] >> i) & 1) bas[j] ^= bas[i];
				break;
			}
		}
	}
}
vector<int>v;
bool zero;
int getk(int k) {
	if (zero) --k;
	if (k > sz) return -1;
	int res = 0;
	for (ri i = 0; i < v.size(); ++i)
		if ((k >> i) & 1) res ^= v[i];
	return res;
}
```

---

## 作者：JK_LOVER (赞：13)

若格式炸了来这里[博客](https://www.luogu.com.cn/blog/xzc/)
# 线性基
## 介绍：
用一个权值大小为 $[1,\log n]$ 的数组来表述一个权值大小为 $[1,n]$ 的原数组的异或问题的数据结构。
## 实质：
多维向量的作为基底的特殊形式，可用高斯消元理解。（关于实质下文用题专门讲解）
## 性质：
- 1.线性基是原数组的极大线性无关组。所以线性基也就拥有一下性质：
-  （1）只含零向量的向量组没有极大无关组；
-  （2）一个线性无关向量组的极大无关组就是其本身；
-  （3）极大线性无关组对于每个向量组来说并不唯一，但是每个向量组的极大线性无关组都含有相同个数的向量；
-  （4）齐次方程组的解向量的极大无关组为基础解系。
-  （5）任意一个极大线性无关组都与向量组本身等价。
-  （6）一向量组的任意两个极大线性无关组都是等价的。
- （7）若一个向量组中的每个向量都能用另一个向量组中的向量线性表出，则前者极大线性无关向量组的向量个数小于或等于后者。----来自于百度
- 2.线性基中每个元素只有唯一异或方案。
- 3.线性基的每一个的元素的最高位也是该元素在线性基的位次。（此性质是定义）。
- 4.线性基的二进制最高位互不相同。（此性质是定义）
- 5.如果线性基有 $n$ 个元素，它的可异或的个数为 $2^n-1$。
- 6.线性基中元素互相异或，异或集合不变。

## 证明：
- 性质1：线性基中每个元素只有唯一异或方案：

A,B,C,D四个不可被相互表达的元素，但 $\oplus$ 满足交换率。所以总有一个元素是多余的。
$$ A \oplus B = C \oplus D \Leftrightarrow A \oplus B \oplus C = D $$

- 性质2：线性基有 $n$ 个元素，它的可异或的个数为 $2^n-1$：

因为 $\oplus$ 有性质 $A\oplus A=0$ 所以，在表示的元素中，要么这个元素参与组成，要么不参加组成。而又因为性质1，所以一个原元素可表达为：

$$A=a_1 b_1\oplus a_2 b_2 \oplus....\oplus a_nb_n (a_i=1,0)$$

而又因为 $a_i$ 不可全为 0 所以共有 $2^n-1$ 个元素可被表达。

- 性质3：线性基中元素互相异或，异或集合不变：

仍可用异或的交换率来解释，本人感觉这条和性质2是等价的。
## 运用：
终于到了正题,我们先来了解一下线性基的构建。
### 构建线性基
因为线性基要满足 $\text{线性基的二进制最高位互不相同}$ 这条性质的，所以我们在建造线性基就必须注意这一点。

在每次插入一个数时由高到低枚举二进制位，当这个元素此位是一时，若此位已经被插入就用它异或该位的元素，这样是为了满足 $\text{线性基的每一个的元素的最高位也是该元素在线性基的位次}$ 这个性质。

否则就将该元素放入，然后退出。

```cpp
void insert(int x)//插入线性基 
{
	for(int i = 63;i>=0;i--)
	{
		if(x&(1LL<<i))
		{
			if(!p[i])
			{
				p[i]=x;
				return;
			}
			x^=p[i];
		}
	}
}
```
### 查询异或最大值
当我们已经构建完线性基之后，我们就可以利用性质来实现一些算法了。

考虑最大异或最大值一定是尽量让最高位为1的元素，就可以考虑以下贪心：由高到低枚举线性基中的元素，如果此位为0，那么异或后一定更优，如果为1，那么异或后一定不会更优。
```cpp
	for(LL i = 62;i >= 0;i--)
	{
		if((ans>>i)&1)continue;
		else 
		ans^=p[i]; 
	}
```

或者直接这样写

```cpp
for(LL i = 62;i >= 0;i--)
	{
		if((p[i]^ans)>ans)
		{
			ans^=p[i];
		}
	}
```
都是可以的。

### 查询异或最小值
考虑最大异或最小值一定是尽量让最高位为0的元素，这不就是线性基最低位的性质嘛，那就直接输出最小值就好了。这就错了，我们在下定义时是将 $0$ 这个值排除的。所以还要特判是否有一个元素是没有被插入的

```cpp
int Min()//最小 
{ 
	if(pd==1) return 0;//如果可以构造出0，这里需要特判 
	for(int i = 0;i <= 62;i++)
	if(p[i]) return p[i];
}
```
### 查询第k大值
这里要用以下性质：

- 如果线性基有 $n$ 个元素，它的可异或的个数为 $2^n-1$。
- 线性基中元素互相异或，异或集合不变。
- （6）一向量组的任意两个极大线性无关组都是等价的。（等同于上面一条）

为了实现更多的功能，我们必须对原线性基改造。
#### rebuild
经过这个函数，我们可以使线性基有一个非常优秀的性质：

- 一个数二进制拆分后，每一位的线性基异或后所得到的值严格大于一个比它小的数所得的值。
```cpp
void rebuild()//重构线性基 
{
	for(int i = 63;i >= 0;i--)
	for(int j = i-1;j >= 0;j--)
	if(p[i]&(1LL<<j)) p[i]^=p[j];
	for(int i = 0;i <= 63;i++) if(p[i]) d[cnt++]=p[i];
}
```
作用显然是把一个高位的线性基的其它位变得更小，那又有什么用呢？
我们考虑用证明：
我们可以证明一个首项为 $1$ 公比为 $2$ 的等比数列是满足：

$$
a_i+a_j \neq a_i + a_k (k\neq j)
$$


$$
a_i+a_j \neq a_k + a_l
$$

上式满足 $i$ 和 $j$ 不同时等于 $k$ 和 $l$ 。

从而可得 $n$ 个数可构造 $2^{n}$ 个不同的数，而线性基则可看作为一种缺少某一项的等比数列之和。


又因为一个 $n-1$ 位的数无论怎么异或都不能大于或等于 $2^n$ 。所以有第 $n$ 个线性基参与的数一定在其下有 $2^{n-1}-1$ 个数。而第 $m$ 是没有线性基的，所以只能往上增加 $2^{n-1}$ 个。

### 第k大值

有了这个性质我们就可以轻易的写出查询第 $k$ 大的代码了。当然如果都大于线性基的个数范围了就可以 $return$ 掉。

```cpp
int kth(int k)//第k大 
{
	if(k >= (1LL<<cnt)) return -1;
	int ans=0;
	for(int i = 62;i>=0;i--)
	{
		if((k>>i)&1) ans^=d[i];
	}
	return ans;
}
```
## 例题（代码）

[P3812 【模板】线性基](https://www.luogu.com.cn/problem/P3812)
模板题，正常思路即可。


$I$:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read()
{
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
#define N 100
int p[N],n,m,d[N],cnt=0;
void rebuild()//重构线性基 
{
	for(int i = 63;i >= 0;i--)
	for(int j = i-1;j >= 0;j--)
	if(p[i]&(1LL<<j)) p[i]^=p[j];
	for(int i = 0;i <= 63;i++) if(p[i]) d[cnt++]=p[i];
}
void insert(int x)//插入线性基 
{
	for(int i = 63;i>=0;i--)
	{
		if(x&(1LL<<i))
		{
			if(!p[i])
			{
				p[i]=x;
				return;
			}
			x^=p[i];
		}
	}
}
int kth(int k)//第k大 
{
	if(k >= (1LL<<cnt)) return -1;
	int ans=0;
	for(int i = 62;i>=0;i--)
	{
		if((k>>i)&1) ans^=d[i];
	}
	return ans;
}
int Max()//最大 
{
	return kth((1LL<<cnt)-1);
}
signed main()
{
	n=read();
	for(int i = 1;i <= n;i++){insert(read());}
	rebuild();
	cout<<Max()<<endl;
	return 0;
}

```
$II$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long 
LL read()
{
	LL x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
LL n,ans,p[1919191];
void work(LL x)
{
	for(LL i = 62;i >= 0;i--)
	{
		if((1LL<<i)&x) 
		{
			if(!p[i]) {
				p[i] =x;
				return ;
			}
 			x^=p[i];
		}
		
	}
}
int main()
{
	n=read();
	while(n--)
	work(read());
	for(LL i = 62;i >= 0;i--)
	{
		if((ans>>i)&1)continue;
		else 
		ans^=p[i]; 
	}
	cout<<ans<<endl;
}
```



---

## 作者：pantw (赞：12)

之前看到线性基的时候觉得是很高大上的算法。

直到那天我看了看介绍线性基的Blog。

emmm
其实线性基就是个高斯消元。只不过没有回代。

原来的数形成一个异或方程组。

每个方程左边是多项式，右边是该数。

从线性代数的角度来理解的话，我们就是要把上述方程组的系数矩阵的秩求出来。

将原矩阵消成上三角阵之后我们就得到了线性基。

若求最大能XOR出的值，贪心即可。

几个注意点：

1. 记得开`long long`

2. 左移时记得写`1LL`而不是`1`


```cpp
/*
    luogu P3812
*/
#include <cstdio>
#define maxn 105
typedef long long Lovelive;
Lovelive base[maxn];
int main() {
    Lovelive n, tmp;
    scanf("%lld", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%lld", &tmp);
        for (int j = 50; j >= 0; --j) {
            if(tmp & (1LL << j)) {
                if(!base[j]) base[j] = tmp;
                tmp ^= base[j];
            }
        }
    }
    Lovelive ans = 0;
    for(int i = 50; i >= 0; --i) {
        if(ans < (ans ^ base[i])) ans ^= base[i];
    }
    printf("%lld\n", ans);
}

3. `<`的优先级比`^`高，记得添括号。

```

---

## 作者：chenzida (赞：9)

## 思路解析：

这是我写的第一道线性基的题，那我就讲的详细一点吧。

### 首先，什么是线性基：

线性基是一个数的集合，任意一个序列都有至少提个线性基。

有一组数 $a_1,a_2...a_n$ 和线性基 $d_1,d_2...,d_m$，$d_i$ 表示**最高位 $1$ 在第 $i$ 位的数**。

### 线性基的作用

由于线性基值域与原数列值域相同的特点，可以用它来维护异或和。

### 线性基的性质

线性基有一下三大性质：

$1.$ 原序列里面的任意一个数都可以由线性基里面的一些数异或得到。

$2.$ 线性基里面的任意一些数异或起来都不能得到 $0$。

$3.$ 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的。

### 线性基的插入

看代码

```cpp
bool add(ll x)
{
	for(int i=30;i>=0;i--)
	{
		if((x>>i)&1)
		{
			if(d[i]) x^=d[i];
			else
			{
				d[i]=x;
				return 1;
			}
		}
	}
	return 0;
}
```

这样这个 $d$ 数组的性质就是若 $d[i]$ 不为 $0$，则 $(d[i])_2$ 的第 $d[i]$ 的第 $i+1$ 位为 $1$，并且没有更高位为 $1$ 了。

### 性质1的证明

如果有了前面讲的，设原数列有一个数 $x$，我们尝试用它来构造线性基，这样就会有两种可能。

$1.$ 不能成功插入线性基。

$2.$ 可以成功插入线性基。

接下来分两类讨论性质 $1$ 的证明

#### 不能成功插入线性基

如果是不能成功插入的话，那么一定是与性质 $2$ 相悖，所以就可以显然得出这个式子：
$$x\ xor\ d[a]\ xor\ d[b]\ xor\  ...=0$$
则可以推出
$$d[a]\ xor\ d[b]\ xor\ ...=x$$
所以如果 $x$ 不能插入线性基，一定是前面以及有一些数的异或和为 $x$。满足性质 $1$。

#### 能够成功插入线性基

假设这个数插入到了第 $i$ 个位置，则可以得出
$$x\ xor\ d[a]\ xor\ d[b]\ xor...=d[i]$$
能推出
$$d[i]\ xor\ d[a]\ xor\ d[b]\ xor...=x$$
所以这种情况也能满足性质 $1$。

所以性质 $1$ 得证。


### 性质2的证明

证法显然，但是还是说一下吧。

反证法：假设 $d[a]\ xor\ d[b]\ xor...\ d[i]=0$(假设 $d[i]$ 比 $d[a]$ 等晚入线性基)
则可以推出 $d[a]\ xor\ d[b]\ xor...=d[i]$，而这样根据入线性基方案，$d[i]$不可能入线性基，所以假设不成立，所以性质2得证。

### 性质3的证明

还是分类讨论

#### 如果序列中所有元素都被插入线性基中

由于所有元素都要入线性基，故不管用什么顺序都是一样的，所以就能保证最优性，即满足性质3.

#### 如果有元素没有被插入线性基中

设这个元素为 $x$，则一定满足一个 $d[a]\ xor\ d[b]\ xor\ d[c]=x$ 的式子，则我们改变一些顺序。（由于 $a,b,c$ 都是对称的，则只用考虑 $c$ 即可）

我们可以得到这个式子
$$d[a]\ xor\ d[b]\ xor\ x=d[c]$$
所以 $d[c]$ 就无法插入线性基了，所以总数还是一样的，所以改变顺序并不会改变插入数量，所以数量是一定的。性质3得证。

### 查询最大值

这里面用到了一个贪心策略，那就是从高位 $d$ 向低位找，如果能够 $xor$ 和能够让答案变大，那么就做 $xor$ 运算。

证明：因为 $d[i]$ 的最高为1的为是 $i$。

分类讨论：

#### 如果现有的数的第 $i$ 位为1

那么 $xor$ 之后肯定变小，并不满足条件，所以这个就不用证明了。

#### 如果现有的数的第 $i$ 位为0

那么 $xor$ 之后肯定变大，满足条件，但是只会的 $xor$ 影响不到第 $i$ 位了，所以肯定是要 $xor$，得证。

所以查询代码如下：

```cpp
ll search(ll x)
{
	for(int i=63;i>=0;i--)
	{
		if((x^d[i])>x)
		{
			x^=d[i];
		}
	}
	return x;
}
```
而完整代码，就请你们自己写喽


---

## 作者：yzhang (赞：4)

## **毒瘤的数学题？？！~~（大雾）~~**

------------

不懂线性基的同学，请先移步至度娘：https://baike.baidu.com/item/线性基/19486160?fr=aladdin ~~（逃~）~~

模板题没什么好说的，上代码，有详细解释。

###**一定要用long long**~~（这个不用说）~~

```cpp
#include<bits/stdc++.h> //万能头文件 
using namespace std;
long long n,ans,a[51],b[51],m[52]; //数据是2^50，想开的更大也星 
int main()
{
	ios::sync_with_stdio(0); //小优化，不用在意（雾） 
    cin>>n;
    m[0]=1; //预处理 
    for(int i=1;i<=51;++i)
    	m[i]=m[i-1]<<1;
    for(int i=1;i<=n;++i) //读入数据 
        cin>>a[i];
    //线性基标准模板 
    for(int i=1;i<=n;++i)
        for(int j=51;j>=0;--j)
            if(m[j]&a[i])
                if(b[j]) 
					a[i]^=b[j];
                else 
				{
					b[j]=a[i];
					break;
				}
	//贪心算答案 
    for(int i=52;i>=0;--i)
        if((ans^m[i])>ans) 
			ans^=b[i];
	//输出 
    cout<<ans;
    return 0;
}
```

---

## 作者：tlyangwj (赞：4)

怎么没人写题解呀@-@

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[51],b[51],mi[52],ans,maxx;//范围是2^50,开大点也可以
int main()
{
    scanf("%lld",&n);
    mi[0]=1;//mi[i]=1<<i,我习惯这么写
    for(int i=1;i<=51;i++)
    {
        mi[i]=2*mi[i-1];
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
    }
    for(int i=1;i<=n;i++)//找线性基
    {
        for(int j=51;j>=0;j--)
        {
            if(mi[j]&a[i])
            {
                if(b[j]) a[i]^=b[j];
                else {b[j]=a[i];break;}//线性基模板
            }
        }
    }
    for(int i=52;i>=0;i--)
    {
        if((ans^mi[i])>ans) ans^=b[i];//贪心找答案
    }
    cout<<ans;
    return 0;
}
```
不知道线性基的可以度娘 这个人讲的很明白
一定要long long!


---

## 作者：crashed (赞：2)

# 代码
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P3812)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异或线性基的模板题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先要知道，异或线性基就是对应给出的集合$U$的一个集合$S$，并且原集合$U$中的所有数字都可以由线性基中的元素异或而得到。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在编写代码的过程中，我们用$P_i$表示最高位的$1$出现在第$i$位的数。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知道了这个，我们就可以来看一下怎么做这道题了：  
### 构造  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个新的数，假如它当前的最高位的$1$出现的位置——第$k$位——的$P_k$为$0$，我们就将$P_k$置为当前的数。否则就用当前的数异或$P_k$后继续往下走。  
### 询问
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用贪心解决。从高往低走，用一个变量$x$存当前得到的答案。最初$x=0$。每走一步，我们就检查如果用当前位置上的$P$和$x$异或起来会不会使$x$更大。走到最后就出答案了。
# 代码
```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 55, MAXLOG = 55;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

LL P[MAXLOG];
LL S;
int N;

void insert( LL val )
{
	for( int i = 50 ; ~ i ; i -- )
	{
		if( val & ( 1ll << i ) )
		{
			if( ! P[i] ) 
			{
				P[i] = val;
				break;
			}
			val ^= P[i];
		}
	}
}

LL solve()
{
	LL res = 0;
	for( int i = 50 ; ~ i ; i -- )
	{
		res = MAX( res, res ^ P[i] );
	}
	return res;
}

int main()
{
	read( N );
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( S );
		insert( S );
	}
	write( solve() ), putchar( '\n' );
	return 0;
}
```

---

## 作者：浮尘 (赞：2)

总体思路跟苣佬们差不多, 看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5005;
long long a[maxn];

int main()
{
    long long ans = 0; 
    int n, t;
    cin >> n;
    t = n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for(int i = 1; i <= n; i++)//枚举各个未知数a[i]
    {
        for(int j = i + 1; j <= n; j++) //选出最大的a[j]当第i行 
        {
            if(a[j] > a[i])
            {
            	swap(a[i], a[j]);
	    }
        }
        if(a[i] == 0) //a[i]为0,线性基底已经找完 
        {
			t = i - 1;
            break;
        }
        for(long long j = 63; j >= 0; j--) //找最高位在哪里
        {
            if(a[i] & ((1ull) << j)) //提取a[i]的第j位， 找到最高位的1 
            {
            	for(int k = 1; k <= n; k++) //枚举除i以外所有的行 
		{
		    if(i != k && (a[k] & (1ull) << j)) //如果第k行的第j位也有1，消掉 
			   a[k] = a[k] ^ a[i];
		} 
		break; //只消掉最高位的1，完成就break,找下一行 
	    }
        }
    }
	//找最大异或和
    for(int i = 1; i <= t; i++) //a[1] 到 a[t]逐渐增大 
    {
    	ans = max(ans, ans ^ a[i]);
    }
    cout << ans;
    return 0;
}
```


---


# 扑克

## 题目背景

lsq邀请wzt去他家打扑克牌

## 题目描述

lsq的扑克没有大小王，共计有n张，由于wzt沉迷于幂运算无法自拔，wzt提出要每次抽a^2张牌（这里“^”是乘方的意思），lsq觉得这样抽真没意思，于是改成了每次抽a^k（k是一个自然数，由游戏者自由选择）张牌。**由lsq开始**，每个人轮流按上述规则摸牌，谁先摸到最后一张牌谁就赢。

由于时间充裕，lsq和wzt一共会玩q盘游戏，每一盘都有不同的a和n。wzt怒敲了一波代码，竟然可以算出当确定了a和n的值后，若能必胜如何下。lsq在见识过你的~~毒瘤~~操作后，希望你也帮他写出一个程序，能判断确定了a和n的值后他是否能赢，lsq当然知道怎么下最优，所以不需要你算出如何下 

**注意：此题中两方的打牌决策都是若有必胜决策则必用必胜决策**

此题中k是一个每次抽牌都可由抽牌者自己决定的一个非负整数，可以结合下面的样例加以理解

## 说明/提示

对于30%的数据，满足q<=30，a<=30，n<=1e8

对于50%的数据，满足q<=50，a<=30，n<=1e12

对于100%的数据，满足q<=50000，a<=20000，n<=1e500

样例一解释：
询问1：lsq必胜，lsq先抽2^1=2，接下来无论wzt抽2^1=2或2^0=1，lsq只要把牌抽完；其他抽法同上（只是顺序不同）

询问2：wzt必胜，若lsq先抽2^0=1，则wzt抽2^3=8；若lsq先抽2^1=2，则wzt抽2^2=4，接下来无论lsq抽2^1=2或2^0=1，wzt只要把牌抽完；其他抽法同上（只是顺序不同）

询问3：lsq必胜，lsq只需拿走3^2=9即可

By [Broadway](https://www.luogu.org/space/show?uid=33509)

## 样例 #1

### 输入

```
3
2 5
2 9
3 9```

### 输出

```
lsq Win
wzt Win
lsq Win```

# 题解

## 作者：Maniac丶坚果 (赞：8)

本题属于一打表就太容易发现规律的题目。

首先上结论：

当a是奇数时，n为奇数则先手胜，反之则后手胜。

当a是偶数时，求n 对 a+1取模的值，这个值如果是奇数或等于a,则先手胜，否则后手胜。

可以很容易想到要把n转化为一个a进制的数。此时，两个操作转化成这样：

①选择非0的一位，使之-1

②选择0的一位，使之变为a-1,而对于这一位前面的所有位，如果也是0那么也变为a-1，直到遇到一个非0位使之-1.

所以，当a是奇数时，可以注意到无论原数是如何，选择了什么操作，**每一次行动都会让原数二进制表达上每一位的和的奇偶性变化**。而这一切的终点则是“1”的那个时候->先胜点，和为奇数。因此，初始局面的每一位的和如果是奇数那么先胜，否则后手胜。

而又不难发现，a为奇数时，a进制表达上的每一位$(1,a,a^2,a^3,a^4...)$也全都是奇数。所以奇数个奇数相加得到一定是得到奇数->因此只要判断n是否是奇数即可。

而a是偶数的时候则稍微复杂一些。

首先，想到a+1，你是需要发现它除了n < a且n为偶数的情况n = a+1应该算是一个显然的必败点了。在它以后的情况都是比较好分析的。

当局面变化到n < a+1的时候，由于只有-1或者-a的操作，可以显然得到如果n为偶数且$n \neq a$那么后手胜，否则先手胜。

由于$a^2 = (a-1)(a+1) + 1$,所以$a^2 \equiv1 (mod (a+1))$.
所以考虑$a^k mod (a+1)$，可以发现$2 | k$的时候$a^k mod (a+1)=1$,反之$=a$

**所以，对于任意的一个偶数$k$和一个奇数$l$，一定有$a^k+a^l \equiv 0(mod(a+1))$**

于是，如果是后手胜局，它可以容易在先手行动以后选择拿走$a^0$或$a^1$来使得
两人取掉数的和是a+1的倍数，除非数是形如$a^{2k}+l(l < a)$形式（有人取了$a^{2k}$以后无法再取$a$）。不过仔细思考可以把这种形态等价成$a^{2k} + l - (a^{2k}-1)$（一个整除a+1的数） $=l + 1$.，依然可以发现他是符合上面的规律的。

代码很简单：

```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 20010;
bool a[maxn];
int n,m,p,q,mi[20],ans[20];
char ch[510];
inline int read()
{
    int x = 0, f = 1;
    char ch = 0;
    for (;!isdigit(ch);ch = getchar()) if (ch == '-') f = -1;
    for (;isdigit(ch);ch = getchar()) x = x *10 + ch - 48;
    return x * f;
}

int main()
{
    q = read();
    while (q--)
    {
        n = read(); scanf("%s",ch);
        int len = strlen(ch);
        if (n&1)
        {
            if (ch[len - 1]&1) puts("lsq Win"); else puts("wzt Win");
        }
        else
        {
            n++;
            int now = 0;
            for (int i = 0; i < len; ++i)
            {
                now = now * 10 + ch[i] - 48;
                now %= n;
            }
            if ((now) & 1 || now == n - 1) puts("lsq Win"); else puts("wzt Win");
        }
    }
}
```

~~话说比赛的时候，这个题我首先是早上起来看了一下然后就被拉去走亲戚了，但是整个过程中都没想到啥觉得很肯定的结论，然后回到家试着一打表看看就发现....~~

---

## 作者：__Watcher (赞：0)

@Maniac丶坚果
 大佬已经给出了完整的证明，现在我讲一下如何打表。
 
---

不难发现这是一道博弈论的题，于是考虑求其 sg 函数（[不会请戳](https://www.luogu.com.cn/problem/P2197)）。这道题的转移情况就如题目所说，枚举 $a^k$，主要 $k$ 从 $0$ 开始。

以下是对于一个 $a$，求出其前 $1000$ 个 $sg$ 值的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll read() {
	ll x=0, f=1; char ch=' ';
	while(!isdigit(ch)) {ch=getchar(); if(ch=='-') f=-1;}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48), ch=getchar();
	return x*f;
}
int a, sg[1005], tmp[1005];
int main() {
	cin>>a;
	for(int i=1;i<=1000;i++) {
		memset(tmp, 0, sizeof(tmp));
		for(int j=1;j<=i;j*=a) {
			tmp[sg[i-j]]=1;
		}
		int now=0;
		while(tmp[now]) now++;
		sg[i]=now;
		printf("%d ", now);
	}
}

```

分别输入 $1-10$，发现 $sg$ 函数规律：  
当 $a$ 是奇数时，循环节为 “$1\ 0$”；  
但 $a$ 是偶数时，循环节为 “$1\ 0\ 1\ 0(\frac{a-3}{2} $个$\ 0\ 1)\ 1\ 2\ 0 $”。

于是程勋就很简单了：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll read() {
	ll x=0, f=1; char ch=' ';
	while(!isdigit(ch)) {ch=getchar(); if(ch=='-') f=-1;}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48), ch=getchar();
	return x*f;
}
int q, a, n, x;
char ch;
int main() {
	cin>>q;
	while(q--) {
		a=read(), n=0;
		ch=getchar();
		while(!isdigit(ch)) ch=getchar();
		while(isdigit(ch)) {
			if(a%2==0) n=((n<<3)+(n<<1)+(ch^48))%(a+1);
			else n=((n<<3)+(n<<1)+(ch^48))%2;
			ch=getchar();
		}
		if(a%2==1) {
			if(n%2==1) printf("lsq Win\n");
			else printf("wzt Win\n");
			continue;
		}
		if(n==a-1) printf("lsq Win\n");
		else if(n==a) printf("lsq Win\n");
		else if(n==0) printf("wzt Win\n");
		else {
			if(n%2==1) printf("lsq Win\n");
			else printf("wzt Win\n");
		}
	}
}

```


---


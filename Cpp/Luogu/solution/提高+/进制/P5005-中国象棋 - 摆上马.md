# 中国象棋 - 摆上马

## 题目背景

~~相信自己的做法 大喊一声 I won't MLE！您就会过这道题~~

Imakf 玩腻了国际象棋，决定玩一玩中国象棋。

他发现中国象棋的马和国际象棋的马有所不同，他意识到这又可以出一道简单的问题，于是他又准备摆一摆马了

## 题目描述

Imakf 有一个 $X$ 行 $Y$ 列的棋盘，还有很多**完全相同**的马（你可以认为有无数个）。现在在棋盘上摆上马（或者不摆），求任何马无法攻击另一匹马的方案总数。

中国象棋的马和国际象棋的马不同。

![](https://cdn.luogu.com.cn/upload/pic/40761.png)

注意：实际问题中是没有兵的。

当然由于方案可能过多，请输出对 $(10^9+7)$ 取模的值


## 说明/提示

对于 100% 的数据，有 $1\le X\leq100$，$1\le Y\leq6$。

对于 20% 的数据，有 $X,Y\leq6$。

对于另外 20% 的数据，有 $X\leq20$。

对于样例 1，可以选择不摆或者摆。

对于样例 2，我有一个绝妙的解释可惜我写不下。


## 样例 #1

### 输入

```
1 1 
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 
```

### 输出

```
145```

# 题解

## 作者：Imakf (赞：47)

# T4 [中国象棋 - 摆上马](https://www.luogu.org/problemnew/show/T55040)


~~之前是[这道题](https://www.luogu.org/problemnew/show/T54860)的，因为太水了就换了~~

本题受 [[SCOI2005]互不侵犯](https://www.luogu.org/problemnew/show/P1896)，[[AHOI2009]中国象棋](https://www.luogu.org/problemnew/show/P2051)，[[NOI2001]炮兵阵地](https://www.luogu.org/problemnew/show/P2704) 启发而出

## $20pts$ 爆搜

爆搜应该可以拿个$20$分

[2AC & 8TLE](https://www.luogu.org/record/show?rid=13096718)

## $50$~$80pts $ 状压dp

不妨设$dp[i][j][k]$为考虑到第$i$行，本行状态为$j$，上一行状态为$k$的方案数

### 初始化

先初始化第$1$行和第$2$行，然后dp

方便起见，我们把状态$i$可以攻击到状态$j$或者反过来，统称为$i$与$j$冲突

```cpp
for(register int i=0; i< (1<<y); ++i )	dp[1][i][0]=1;//第一行怎么放都行，因为同一行不可能冲突

for(register int i=0; i< (1<<y) ; ++i) {
    for(register int j=0; j< (1<<y) ; ++j) {
        if(i与j冲突)	continue;
        dp[2][j][i]+=dp[1][i][0];
    }
}
```

### 转移

四层暴力枚举$i,j,k,s$分别表示

$i$ 当前考虑的行数

$j$ 当前考虑的行数的状态

$k$ 上一行的状态

$s$ 上上行的状态

```cpp
for(register int i=3; i<=x; ++i) {
		for(register int j=0; j< (1<<y); ++j) {
			for(register int k=0; k< (1<<y); ++k) {
				if(j与k冲突)	continue;
				for(register int s=0; s< (1<<y) ; ++s) {
					if(s与k冲突||s与j冲突)	continue;
					dp[i][j][k]+=dp[i-1][k][s];
					dp[i][j][k]%=mod;
				}
			}
		}
	}
```

### 判断冲突

我们需要$2$个函数来判断出某一行可以攻击到的范围

![](https://cdn.luogu.com.cn/upload/pic/40826.png )

我们用函数$at$_$bt(a)$计算出红线经过的攻击范围，图中为$(01000100)_2$

用另一个函数$at$_$3(a,b)$表示第$i$行为状态$a$,第$i+1$行状态为$b$,第$i$行可以攻击到$i+2$行的范围（图中黄色线经过的区域），图中为$(00101000)_2$

先设计$at$_$bt(a)$,以下图为例（红色代表放了马）

![](https://cdn.luogu.com.cn/upload/pic/40829.png )

从右往左考虑

第一个格子没有马，下一个

第二个格子有马，右边有没有马？

没有，那么可以攻击第二行往右数第二个格子，左边有没有马？

有，那么攻击不到第二行往左数第二个格子

于是第二行变成

![](https://cdn.luogu.com.cn/upload/pic/40830.png )

第三个格子有马，右边有没有马？

有，那么攻击不到第二行往右数第二个格子，左边有没有马？

没有，那么可以攻击第二行往左数第二个格子

于是第二行变成

![](https://cdn.luogu.com.cn/upload/pic/40832.png)

按照这样，最终第二行变成了

![](https://cdn.luogu.com.cn/upload/pic/40834.png )

攻击范围就是$(01010100)_2$

于是我们很自然的写出这样的代码

```cpp
inline int bit(int a,int x){
	//返回a的二进制第x位并保留右侧的0
	//也就是说bit(5,3)==4
    if(x<1)	return 0;
    return a&(1<<(x-1));
}
inline int check(int a,int x){ //返回a的二进制第x位是否为1
	if(x<1)	return 0;
    if(a&(1<<(x-1)))	return 1;
    return 0;
}

int at_bt(int a){ //求出状态a对于下一行的攻击范围
    int c=0;
    for(register int i=1; bit(-1,i)<=a; ++i){
        if(!check(a,i))	continue; //判断有马
        if(check(a,i)&check(a,i-1));
        else c|=bit(-1,i-2); //同下
        if(check(a,i)&check(a,i+1));
        else c|=bit(-1,i+2); //注意是|
    }
    return c;
}
```

然后考虑设计$at$_$3(a,b)$，这个比较简单，以下图为例（暂且不考虑这两行的矛盾）

![](https://cdn.luogu.com.cn/upload/pic/40836.png )

依然第一行从右往左考虑

第一个格子有没有马？

没有，下一个

第二个格子有没有马？

有，下一行的第二个格子有没有马？

有，所以被别住了，下一个

第三个格子有没有马？

有，下一行的第二个格子有没有马？

没有，所以不会被别住，就可以攻击下方的两个格子，于是变为

![](https://cdn.luogu.com.cn/upload/pic/40837.png)

于是乎这样子，最后变为

![](https://cdn.luogu.com.cn/upload/pic/40838.png)

于是我们也可以自然的写出下列代码

```cpp
int at_3(int a,int b){
	//a表示第一行状态
    //b表示第二行状态
    int c=0;
    for(register int i=1; bit(-1,i)<=a; ++i){
        if(!check(a,i))	continue;
        if(check(a,i)&check(b,i));
        else c|=bit(-1,i-1),c|=bit(-1,i+1);//注意是|
    }
    return c;
}
```

于是问题解决了，之前的转移代码可以改成

```cpp
    for(register int i=3; i<=x; ++i) {
	for(register int j=0; j< (1<<y); ++j) {
		for(register int k=0; k< (1<<y); ++k) {
			if(at_bt(k)&j||at_bt(j)&k)	continue;
			for(register int s=0; s< (1<<y) ; ++s) {
				if(at_bt(s)&k|| at_bt(k)&s ||at_3(s,k)&j || at_3(j,k)&s)	continue;
				dp[i][j][k]+=dp[i-1][k][s];
				dp[i][j][k]%=mod;
			}
		}
	}
}
```

最后统计答案

```cpp
long long ans=0;
for(register int i=0; i<(1<<y); ++i) {
	for(register int j=0; j<(1<<y); ++j) {
		if(at_bt(i)&j||at_bt(j)&i)	continue;
		ans+=dp[x][i][j];
		ans%=mod;
	}
}
```

## $100pts$ 滚动数组优化

您注意到$1MB$的空间限制了，然后就来优化空间吧，把所有枚举行数的都加上$\mod 3$就好了，最后统计答案也要加上！

## $100pts$ 时间优化

为了时间好看一点，您可以储存攻击范围，时间会大大加快，空间也不会炸！

## $100pts$ 打表

嗯……前提是您要打得出来

---

## 作者：hater (赞：28)

# 相信自己的做法 大喊一声 I won't MLE！

之后我就MLE了 （尴尬）

先看题目 题意简明 

因为 Y≤6 所以压Y这一行的

因为马的攻击范围有两行 所以压两行的状态

思路很好想 方程也很好推 

然而本题难点来了 怎么判断两种状态不冲突

先看两行的判断

```cpp
inline bool Ch1(int k1,int k2)
{
	int T= (~(((k1>>1)&k1)>>1)) , K ; K =(T&k2);
	if((k1>>2)&K) return 0;
	T= (~(((k1<<1)&k1)<<1)) ; K=(T&k2);
	if((k1<<2)&K) return 0;
	return 1;
}
```

k1是在k2的上面

位运算一个个分析

两行之间的攻击的马脚在本行上

 (k1>>1)&k1 找的是向右下方攻击的马脚 
 
 再右移就是被堵住攻击不到的地方 
 
 之后再把攻击不到的地方在k2中拿走
 
 再进行判断不就OK了吗 
 
 之后 k1 k2 倒一下还得判断一遍
 
 同理  自行理解跨行的攻击判断
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int MS,n,m;
int f[105][1<<6][1<<6],M=1e9+7;
inline bool Ch1(int k1,int k2,bool I)
{
	int T= (~(((k1>>1)&k1)>>1)) , K ; K =(T&k2);
	if((k1>>2)&K) return 0;
	T= (~(((k1<<1)&k1)<<1)) ; K=(T&k2);
	if((k1<<2)&K) return 0;
	if(I) return 1;
	  else return 1&Ch1(k2,k1,1);
}
inline bool Ch2(int k1,int k2,int k3,bool I)
{
	int T= (~((k1&k2)>>1)) , K; K=(T&k3);
	if((k1>>1)&K) return 0;
	T= (~((k1&k2)<<1)); K=(T&k3);
	if((k1<<1)&K) return 0;
	if(I) return 1;
	  else return 1&Ch2(k3,k2,k1,1);
}
int main()
{
	cin>>n>>m;
	MS=(1<<m);
	for(int i=0;i<MS;i++)
	 f[1][i][0]=1;
	for(int i=0;i<MS;i++)
	  for(int j=0;j<MS;j++)
	   if(Ch1(i,j,0)) f[2][i][j]=1;
	for(int i=3;i<=n;i++)
     for(int j=0;j<MS;j++)
       for(int k1=0;k1<MS;k1++)
         if(Ch1(j,k1,0)) 
           for(int k2=0;k2<MS;k2++)
            if(Ch1(k1,k2,0)&&Ch2(j,k1,k2,0))
              f[i][j][k1]=(f[i][j][k1]+f[i-1][k1][k2])%M;
    int ans=0;
     for(int j=0;j<MS;j++)
       for(int k=0;k<MS;k++)
        ans=(ans+f[n][j][k])%M;
    cout<<ans<<endl;
	return 0;
}
```

欢喜的打完代码 之后

# 大吼一声 ：“ I MLE 了”

之后滚到题解区学习滚动数组

滚动数组的大概意义如下 ：

打个比方你在做63行了

请问 59 行的选取方案对现在的方案还有贡献吗

显然已经没用了啊

为什么不去利用59行以上的空间呢 

为什么还要新开空间去做呢 

理解之后代码就没问题了

```cpp
#include<bits/stdc++.h>
using namespace std;
int MS,n,m;
int f[4][1<<6][1<<6],M=1e9+7;
inline bool Ch1(int k1,int k2,bool I)
{
	int T= (~(((k1>>1)&k1)>>1)) , K ; K =(T&k2);
	if((k1>>2)&K) return 0;
	T= (~(((k1<<1)&k1)<<1)) ; K=(T&k2);
	if((k1<<2)&K) return 0;
	if(I) return 1;
	  else return 1&Ch1(k2,k1,1);
}
inline bool Ch2(int k1,int k2,int k3,bool I)
{
	int T= (~((k1&k2)>>1)) , K; K=(T&k3);
	if((k1>>1)&K) return 0;
	T= (~((k1&k2)<<1)); K=(T&k3);
	if((k1<<1)&K) return 0;
	if(I) return 1;
	  else return 1&Ch2(k3,k2,k1,1);
}
int main()
{
	cin>>n>>m;
	MS=(1<<m);
	for(int i=0;i<MS;i++)
	 f[1][i][0]=1;
	for(int i=0;i<MS;i++)
	  for(int j=0;j<MS;j++)
	   if(Ch1(i,j,0)) f[2][i][j]=1;
	for(int i=3;i<=n;i++)
    {
      memset(f[i%3],0,sizeof(f[i%3]));
      for(int j=0;j<MS;j++)
       for(int k1=0;k1<MS;k1++)
         if(Ch1(j,k1,0)) 
           for(int k2=0;k2<MS;k2++)
            if(Ch1(k1,k2,0)&&Ch2(j,k1,k2,0))
              f[i%3][j][k1]=(f[i%3][j][k1]+f[(i-1)%3][k1][k2])%M; 
    }
    int ans=0;
     for(int j=0;j<MS;j++)
       for(int k=0;k<MS;k++)
        ans=(ans+f[n%3][j][k])%M;
    cout<<ans<<endl;
	return 0;
}
```

还有一堆优化 ~~~~~~~

2^6很宽裕就不去作死了

---

## 作者：pyqpyq (赞：14)

让我们来用 35 行代码 A 掉此题。
# 题目分析
首先数据范围 $X \le 100,Y \le 6$ 提醒我们，这题用状压 dp。

然后又发现前两行摆马的状况会影响当前行的局面的合法性，所以我们要枚举前三行摆马的状况。

所以我们设计状态 $dp_{i,j,k}$ 表示第 $i$ 行局面为 $j$，第 $i-1$ 行局面为 $k$ 的方案数。

其中 $j,k$ 均是二进制的表示，比如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/jlv6naiu.png)
这一行就可以表示为二进制的 $101001$，即十进制的 $41$。

所以我们的状态转移方程就是：
$$ dp_{i,j,k}=sum(dp_{i-1,k,l})$$
其中 j,k,l 需要满足组成的局面中的马互不侵犯。

所以最后的答案就是

$$\sum^s_{i=0}\sum^s_{j=0}dp_{x,i,j}$$

其中 s 是这一行的所有方案。

然而我们空间只给了我们 1MB，而 dp 数组开满需要
$$100 \times 64 \times 64 \times 2B= 819200B = 800KB$$
其他所需的内存加起来就 MLE 了，所以就有了题目背景上的话。发现第 i 行的状态转移只需要 i-1 行的状态，所以用滚动数组优化就可以了。

打个不太恰当的比喻。就像你在机房里，发现电脑不够了，还正好有人在大摆，你就可以跟老师举报他把他赶出去，你就可以用他的电脑了，不过数据要清一下 ~~，否则就成JC了~~。

具体看代码：
```cpp#include<bits/stdc++.h>
using namespace std;
#define MOD 1000000007
int x,y,s,dp[3][65][65],ans;
int main()
{
	scanf("%d%d",&x,&y);
	if(x==1)//特判
	{
		printf("%d",1<<y);
		return 0;
	}
	for(int i=2;i<=x;++i)//枚举所有行
	{
		for(int j=0;j<(1<<y);++j)//枚举当前行
			for(int k=0;k<(1<<y);++k)//枚举上一行
			{
				dp[i&1][j][k]=0;//由于是滚动数组，在用前一定要清零
				if(#)//前两行是否合法
				{
					if(i==2)
						dp[0][j][k]=1;//只有两行且是我们枚举的两行
					else
						for(int l=0;l<(1<<y);++l)//枚举上上行
							if(#)//此行和上上行是否合法
								dp[i&1][j][k]=(dp[i&1][j][k]+dp[(i&1)^1][k][l])%MOD;//统计答案
				}
			}
	}
	for(int i=0;i<1<<y;++i)
		for(int j=0;j<1<<y;++j)
			ans=(ans+dp[x&1][i][j])%MOD;//统计答案
	printf("%d",ans);//输出解
	return 0;
}
```
到这里就结束了？

不。代码中有两段代码被用 # 代替了，这里是我用来判断合法性的，它们才是这篇题解的重点。
# 公式推导
由于我们的状态是用二进制表示的，所以先了解几个位运算符和逻辑运算符，以便公式表达：

（由于每行只有 y 个位置，所以我们的表示状态的数也只需 y 个二进制位。下面的例子中 y 为 5。0b 开头的数字表示二进制数。）

- & 按位与：双目运算符，若两个数中的对应二进制位均为 1，则答案中的对应二进制位为 1，否则为 0。如 `0b10011 & 0b10110 = 0b10010`。

- | 按位或：双目运算符，若两个数中的对应二进制位均为 0，则答案中的对应二进制位为 0，否则为 1。如 `0b10011 | 0b10110 = 0b10111`。

- ^ 按位异或：双目运算符，若两个数中的对应二进制位相同，则答案中的对应二进制位为 0，否则为 1。如 `0b10011 ^ 0b10110 = 0b00101`。

- ~ 按位取反：单目运算符，把每个二进制位中的 0 变成 1，1 变成 0。如 `~ 0b10011 = 0b01100`。

- \<< 左移：双目运算符，把全部二进制位左移，不够的补0。如 `0b10011 << 2 = 0b01100`。

- \>> 右移：双目运算符，把全部二进制位右移，不够的补0，如 `0b10011 >> 2 = 0b00100`。

- && 逻辑与：双目运算符，若两个数均为 `true`，则答案为 `true`，否则为 `false`。

- || 逻辑与：双目运算符，若两个数均为 false，则答案为 `true`，否则为 `false`。

- ! 逻辑非：单目运算符，若此数为 `true`，则答案为 `false`，否则为 `true`。

~~不懂就百度吧。~~

注意在 C++ 里，`true` 为 1，`false` 为 0，而所有非 0 数会被当成 `true`，0 则会被当成 `false`。

而位运算符和逻辑运算符的运算顺序十分玄学，所以建议在每个运算外面加上括号以防万一。~~打过线段树的应该知道吧。~~

---
先看第一个 #，即判断本行为 j，上一行为 k 表达的状态互相之间是否合法。

要是没有蹩马脚限制的话，我们可以将 k 分别左移和右移两位，与 j 做按位与，若得到答案非 0 则发生冲突。

但是此题有蹩马脚限制，所以我们要对 j 做预处理，把蹩了马脚的位变成 0。

怎么预处理呢？

以 k 右移时为例，发现每次蹩马脚的子总在 j 右边，所以把 j 右移一位来移动到每个子所蹩到的子的对应位置上。

让我们画一张真值表：
j|j>>1|~(j>>1)|ans
:-:|:-:|:-:|:-:
0|0|1|0
0|1|0|0
1|0|1|1
1|1|0|0
ans 是处理完的 j。

你应该发现了：`ans=j&(~(j>>1))`

所以 k 右移时的完整判断就是`((j&(~(j>>1)))&(k>>2))`。返回非 0 值则冲突。

k 左移时呢？预处理时把 j 左移就行了。

注意此判断对 j,k 来说不对称，所以还要把 j,k 互换再判断一次。

第一个 # 处完整代码：

`!(((j&(~(j>>1)))&(k>>2))||((j&(~(j<<1)))&(k<<2))||(((k&(~(k>>1)))&(j>>2)))||((k&(~(k<<1)))&(j<<2)))`

我这里用了一个衡等式：`((!a)&&(!b))=!(a||b)`，来让式子改起来更快。

---
第二个 # 处和用来判断此行为 j，上一行为 k，上上行为 l 的情况是否合法，即 j,l 是否冲突。
为什么不判断 k,l 是否冲突呢？因为 k,l 冲突时 $dp_{i,k,l}$ 为 0，统不统计到答案无所谓。

其实判断 j,l 是否冲突和判断 j,k 是否冲突差不多。较大的区别就是蹩 j 马脚的不是 `j<<1` 和 `j>>1` 了，而是 k。

第二个 # 处完整代码：

`!(((j&(~k))&(l>>1))||((j&(~k))&(l<<1))||((l&(~k))&(j>>1))||((l&(~k))&(j<<1)))`

# 最后
完整代码就是把两个 # 处填进去。~~简而言之我懒得放了。~~

相关的状压 dp 题目还有：[炮兵阵地](https://www.luogu.com.cn/problem/P2704)、[玉米田](https://www.luogu.com.cn/problem/P1879)、[互不侵犯](https://www.luogu.com.cn/problem/P1896)、[中国象棋](https://www.luogu.com.cn/problem/P2051)。想~~水经验~~练习状压的可以去练习一下。

完结撒花\\(^o^)/

---

## 作者：Utilokasteinn (赞：12)

## [Link](https://www.luogu.com.cn/problem/P5005)

本题状压 $\tt dp$ 的 方程很好想。

逐行递推。枚举该行状态 $S_i$，上一行状态 $S_j$ 以及上上行状态 $S_k$，判断是否合法，合法就加上。

关键是如何判断是否合法。

先考虑如何判断 $S_i$ 和 $S_j$ 是否合法。（结果为 $0$ 表示合法）

判断方法：

- ```i&(~i>>1)&(j>>2)```：左边没马且左上有马。

- ```i&(~i<<1)&(j<<2)```：右边没马且右上有马。

- ```j&(~j>>1)&(i>>2)```：左边没马且左下有马。

- ```j&(~j>>1)&(i>>2)```：右边没马且右下有马。

再考虑如何判断 $S_i$ 与 $S_k$ 是否合法。（结果为 $0$ 表示合法）

这里不用判断 $S_j$ 与 $S_k$ 是否合法，是因为不合法的话 $\tt dp$ 数组肯定为 $0$。

判断方法：

- ```i&(~j)&(k>>1)```：上面没马且左上有马。

- ```i&(~j)&(k<<1)```：上面没马且右上有马。

- ```k&(~j)&(i>>1)```：下面没马且左下有马。

- ```k&(~j)&(i<<1)```：下面没马且右下有马。

注意需要初始化，$\tt dp$ 数组要滚掉一维。

代码如下：

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int n,m,ans;
int f[2][64][64];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<1<<m;i++)
		f[1][i][0]=1;
	for(int li=2;li<=n;li++)
		for(int i=0;i<1<<m;i++)
			for(int j=0;j<1<<m;j++)
			{
				f[li&1][i][j]=0;
				if(i&(~i>>1)&(j>>2))continue;//左边没马且左上有马
				if(i&(~i<<1)&(j<<2))continue;//右边没马且右上有马 
				if(j&(~j>>1)&(i>>2))continue;//左边没马且左下有马
				if(j&(~j<<1)&(i<<2))continue;//右边没马且右下有马
				for(int k=0;k<(1<<m);k++)
				{
					if(i&(~j)&(k>>1))continue;//上面没马且左上有马 
					if(i&(~j)&(k<<1))continue;//上面没马且右上有马 
					if(k&(~j)&(i>>1))continue;//下面没马且左下有马 
					if(k&(~j)&(i<<1))continue;//下面没马且右下有马 
					f[li&1][i][j]=(f[li&1][i][j]+f[(li&1)^1][j][k])%mod;
				}
			}
	for(int i=0;i<1<<m;i++)
		for(int j=0;j<1<<m;j++)
			ans=(ans+f[n&1][i][j])%mod;
	printf("%d",ans);
	return 0;
}
```


---

## 作者：quarmer (赞：7)

第一眼看这道题以为会有兵，结果发现并没有，那这不就是一道很水的状压 dp 板子了吗。

首先发现 $ Y \leq 6 $ 所以要压 $Y$ 这一维。

我们来用一个二进制数 $i$ 来表示这一行的状态。这个数二进制第 $j$ 位为 $0/1$ 表示棋盘的这一位不放或者放马。

我们发现，对于这道题而言，这一行的状态不仅和上一行有关，还和上上行有关。

所以设出状态 ： $f_{i,j,k}$ 表示第 $i$ 行状态为 $j$ 且第 $i - 1$ 行状态为 $k$ 时前 $i$ 行的方案总数。

转移就是上一行所有不与这一行冲突的状态的总和。

接下来就来求两行满足那些条件才能满足题目条件（没有一个马可以攻击到另一个马）。

先来判断一下相邻两行怎么满足条件：

对于每一个马，满足下列条件之一才可满足条件：

1.这个马的攻击范围没有任何一个马。

2.若有，则需要有其他马拦住马腿。

代码很简单，对于第一行每一个马，枚举它在第二行的攻击范围内有无马，若有，判断其中是否有马挡马腿。

```cpp
bool check1(int x, int y) {
	for(int i = 0 ; 1 << i <= x ; i++) {
		if(!(x & (1 << i))) continue ;
		if(i > 1) {
			if(!(!(y & (1 << i - 2)) || ((x & (1 << i - 1)) && (y & (1 << i - 1))))) return 0 ;
		}
		if(!(!(y & (1 << i + 2)) || ((x & (1 << i + 1)) && (y & (1 << i + 1))))) return 0 ;
	}
	return 1 ;
}
```
判断中间隔一行的两行是否冲突，与上面的其实一样。

对于这一行每一个马，枚举它在上上行的攻击范围内有无马，若有，判断其中是否有马挡马腿。

```cpp
bool check2(int x, int y, int z) {
	for(int i = 0 ; 1 << i <= x ; i++) {
		if(!(x & (1 << i))) continue ;
		if(i > 0) {
			if(!(!(z & (1 << i - 1)) || ((y & (1 << i)) && (y & (1 << i - 1))))) return 0 ;
		}
		if(!(!(z & (1 << i + 1)) || ((y & (1 << i)) && (y & (1 << i + 1))))) return 0 ;
	}
	return 1 ;
}
```

边界显然的 $f_{1,i,0} $ $=$ $1$。$f_{2,j,i}$ $=$ $\operatorname{check(j,i)}$。

注意到这个不寻常的空间限制 1MB，我们~~先来问候一下凉心出题人~~要用二位滚动数组，加一个 & 运算符就行了。

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <stack>
#include <queue>
#include <vector>
#include <list>
#include <map>
#include <unordered_map>
using namespace std ;
#define int long long
int f[3][1 << 7][1 << 7] ; 
int x, y ; 
const int mod = 1e9 + 7 ; 
int read(){
	char ch ;int s = 0 ;int w = 1;
	while((ch = getchar()) >'9' || ch < '0' )if(ch == '-')w = -1 ;
	while(ch >= '0' && ch <= '9')s = (s << 1) + (s << 3) + (ch ^ 48) , ch = getchar() ;
	return s * w ;
}
bool check1(int x, int y) {
	for(int i = 0 ; 1 << i <= x ; i++) {
		if(!(x & (1 << i))) continue ;
		if(i > 1) {
			if(!(!(y & (1 << i - 2)) || ((x & (1 << i - 1)) && (y & (1 << i - 1))))) return 0 ;
		}
		if(!(!(y & (1 << i + 2)) || ((x & (1 << i + 1)) && (y & (1 << i + 1))))) return 0 ;
	}
	return 1 ;
}
bool check2(int x, int y, int z) {
	for(int i = 0 ; 1 << i <= x ; i++) {
		if(!(x & (1 << i))) continue ;
		if(i > 0) {
			if(!(!(z & (1 << i - 1)) || ((y & (1 << i)) && (y & (1 << i - 1))))) return 0 ;
		}
		if(!(!(z & (1 << i + 1)) || ((y & (1 << i)) && (y & (1 << i + 1))))) return 0 ;
	}
	return 1 ;
}
/*void print(int x) {
	int temp[10] = {0} ;
	int num = 0 ;
	while(x) temp[++num] = x % 2, x /= 2 ;
	for(int i = 1 ; i <= y ; i++) cout << temp[i] ;
	cout << '\n' ;
}  调试输出用  */
signed main() {
//	freopen("my.out", "w", stdout) ;
	x = read(), y = read() ;
	for(int i = 0 ; i < 1 << y ; i++) f[1][i][0] = 1 ;
	for(int i = 0 ; i < 1 << y ; i++)
		for(int j = 0 ; j < 1 << y ; j++) 
			if(check1(i, j)) f[0][i][j] += f[1][i][0] ;
	for(int i = 3 ; i <= x ; i++) {
		memset(f[i & 1], 0, sizeof(f[i & 1])) ; // 注意要清空，因为这个调了半天 
		for(int j = 0 ; j < 1 << y ; j++) 
			for(int k = 0 ; k < 1 << y ; k++) {
				if(!check1(j, k)) continue ;
				for(int q = 0 ; q < 1 << y ; q++) if(check1(k, q)) if(check2(j, k, q)) 
					f[i & 1][j][k] += f[!(i & 1)][k][q], f[i & 1][j][k] %= mod ;
			}
	}	
	int ans = 0 ;
	for(int i = 0 ; i < 1 << y ; i++)
		for(int j = 0 ; j < 1 << y ; j++)
			if(check1(i, j)) ans += f[x & 1][i][j], ans %= mod ; //最后统计答案 
	cout << ans ;
	return 0 ;
}


---

## 作者：Adove (赞：5)

相信各位都做过一道叫炮兵阵地的题了

一般是预处理出单独一行合法的

再预处理前两行合法的

然后预处理三行合法的

三行合法的充要条件是相邻两行组合合法且第一行与第三行的组合合法

判断合法不必要用状压的方式，拆开暴力判断就行

合法的分类存到vector里

可知vector需要的空间与滚动后的dp数组所需空间相当

然后就是枚举合法状态递推了，由于vector预处理了合法状态，此处不需再进行判断，跑得飞快（比打表的那位慢些

最后把各种情况加起来取模

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
#include"vector"
using namespace std;

const int MAXN=105;
const int MAXM=6;
const int MOD=1e9+7;

int n,m,ans;
int f[2][1<<MAXM][1<<MAXM];
vector<int> vec[1<<MAXM][1<<MAXM];

bool check1(int x,int y)
{
    int ct1[15]={0},ct2[15]={0};
    for(int i=0;i<m;++i) ct1[i]=(x>>i)&1;
    for(int i=0;i<m;++i) ct2[i]=(y>>i)&1;
    for(int i=0;i<m;++i){
        if(i<m-2&&ct1[i]&&ct2[i+2]&&(!ct1[i+1]||!ct2[i+1])) return 0;
        if(i>1&&ct1[i]&&ct2[i-2]&&(!ct1[i-1]||!ct2[i-1])) return 0;
    }return 1;
}

bool check2(int x,int y,int z)
{
    int ct1[15]={0},ct2[15]={0},ct3[15]={0};
    for(int i=0;i<m;++i) ct1[i]=(x>>i)&1;
    for(int i=0;i<m;++i) ct2[i]=(y>>i)&1;
    for(int i=0;i<m;++i) ct3[i]=(z>>i)&1;
    for(int i=0;i<m;++i){
        if(i<m-1&&ct1[i]&&ct3[i+1]&&(!ct2[i]||!ct2[i+1])) return 0;
        if(i>0&&ct1[i]&&ct3[i-1]&&(!ct2[i]||!ct2[i-1])) return 0;
    }return 1;
}

int main()
{
    scanf("%d%d",&n,&m);
    if(n==1){printf("%d\n",1<<m);return 0;}
    for(int i=0;i<1<<m;++i) f[1][i][0]=1;
    for(int i=0;i<1<<m;++i){
        for(int j=0;j<1<<m;++j){
            if(check1(i,j)) f[0][i][j]+=f[1][j][0];
        }
    }for(int i=0;i<1<<m;++i){
        for(int j=0;j<1<<m;++j){
            if(!check1(i,j)) continue;
            for(int k=0;k<1<<m;++k){
                if(!check1(j,k)||!check2(i,j,k)) continue;
                vec[i][j].push_back(k);
            }
        }
    }
    for(int i=3;i<=n;++i){
        memset(f[i&1],0,sizeof(f[i&1]));
        for(int j=0;j<1<<m;++j){
            for(int k=0;k<vec[0][j].size();++k){
                int tmp1=vec[0][j][k];
                for(int l=0;l<vec[j][tmp1].size();++l){
                    int tmp2=vec[j][tmp1][l];
                    f[i&1][tmp2][tmp1]+=f[i&1^1][tmp1][j];
                    f[i&1][tmp2][tmp1]%=MOD;
                }
            }
        }
    }for(int i=0;i<1<<m;++i){
        for(int j=0;j<1<<m;++j){
            ans=(ans+f[n&1][i][j])%MOD;
        }
    }printf("%d\n",ans);
    return 0;
}
```

---

## 作者：JYX0924 (赞：2)

## 1. 设计 dp 状态
用 ```dp[i][j][k]``` 表示考虑完前 i 行，本行状态是 j, 上一行状态是 k。
## 2. 状态转移
如果与上一行和上上一行不冲突，累加。
## 3. 攻击范围
我们用 zhuan1 函数计算马对下一行的攻击范围。
```c
int zhuan1(int now) // now对下一行的攻击范围
{
	int sum=0,flag[10]; memset(flag,0,sizeof(flag));
	for(int i=2;i<10;i++)
	{
		if( (num[i-1]&now)==0 && (num[i]&now)!=0 ) //右边没有蹩马腿
		{
			if(flag[i-2]==1) continue;
			sum+=num[i-2]; flag[i-2]=1;
		}
	}
	for(int i=0;i<10;i++)
	{
		if( (num[i+1]&now)==0 && (num[i]&now)!=0 ) //左边没有蹩马腿
		{
			if(flag[i+2]==1) continue;
			sum+=num[i+2]; flag[i+2]=1;
		}
	}
	return sum;
}
```
接着用 zhuan2 函数计算马对下下一行的攻击范围。
```c
int zhuan2(int now1,int now2) //now1对下下行的攻击范围
{
	int sum=0,flag[10]; memset(flag,0,sizeof(flag));
	for(int i=0;i<10;i++)
	{
		if( (num[i]&now1)!=0 && (num[i]&now2)==0 ) //上面没有蹩马腿
		{
			if(flag[i-1]==0 && i>=1)
			{sum+=num[i-1]; flag[i-1]=1;}
			if(flag[i+1]==0)
			{sum+=num[i+1]; flag[i+1]=1;}
		}
	}
	return sum;
}
```
## 4. 判断冲突
我们不妨让第一行的状态为 i，下一行为 j，下下一行为 k。

```if( (zhuan(i)&j)!=0 || (zhuan(j)&i!=0 )``` 退出

```if( (zhuan(j)&k)!=0 || (zhuan(k)&j!=0 )``` 退出

```if( (zhuan2(i,j)&k)!=0 || (zhuan2(k,j)&i!=0 )```退出
## 5. 代码实现
用滚动数组滚动掉第一位，不然会 MLE。

代码速度还算快，55ms AC。
```c
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
int x,y;
ll dp[2][70][70],ans,num[20],sum[105],cnt[70][70];
//dp[1/0][j][k]表示考虑了前i%2行，本行状态是j，上一行状态是k


int zhuan1(int now) // now对下一行的攻击范围
{
	int sum=0,flag[10]; memset(flag,0,sizeof(flag));
	for(int i=2;i<10;i++)
	{
		if( (num[i-1]&now)==0 && (num[i]&now)!=0 ) //右边没有蹩马腿
		{
			if(flag[i-2]==1) continue;
			sum+=num[i-2]; flag[i-2]=1;
		}
	}
	for(int i=0;i<10;i++)
	{
		if( (num[i+1]&now)==0 && (num[i]&now)!=0 ) //左边没有蹩马腿
		{
			if(flag[i+2]==1) continue;
			sum+=num[i+2]; flag[i+2]=1;
		}
	}
	return sum;
}

int zhuan2(int now1,int now2) //now1对下下行的攻击范围
{
	int sum=0,flag[10]; memset(flag,0,sizeof(flag));
	for(int i=0;i<10;i++)
	{
		if( (num[i]&now1)!=0 && (num[i]&now2)==0 ) //上面没有蹩马腿
		{
			if(flag[i-1]==0 && i>=1)
			{sum+=num[i-1]; flag[i-1]=1;}
			if(flag[i+1]==0)
			{sum+=num[i+1]; flag[i+1]=1;}
		}
	}
	return sum;
}

void init()
{
	for(int i=0;i<20;i++) num[i]=1<<i;
	for(int i=0;i<=100;i++) sum[i]=zhuan1(i);
	for(int i=0;i<num[y];i++)
	for(int j=0;j<num[y];j++) cnt[i][j]=zhuan2(i,j);
}

void DP()
{
	int pre;
	for(int i=0;i<num[y];i++) dp[1][i][0]=1;
	for(int i=0;i<num[y];i++)
	for(int j=0;j<num[y];j++)
	{
		if( (j&sum[i])==0 && (sum[j]&i)==0 ) dp[0][i][j]=1;
	}
	for(int i=3;i<=x;i++)
	{
		pre=i%2; memset(dp[pre],0,sizeof(dp[pre]));
		for(int j=0;j<num[y];j++) //上上行
		for(int k=0;k<num[y];k++) //上行
		{
			if( (sum[j]&k)!=0 || (sum[k]&j)!=0 ) continue;
			for(int l=0;l<num[y];l++) //本行
			{
				if( (sum[k]&l)!=0 || (sum[l]&k)!=0 ) continue;
				if( (cnt[j][k]&l)!=0 || (cnt[l][k]&j)!=0 ) continue;
				if(pre==1) dp[pre][l][k]=(dp[pre][l][k]+dp[0][k][j])%mod;
				else dp[pre][l][k]=(dp[pre][l][k]+dp[1][k][j])%mod;
			}
		}
	}
	for(int i=0;i<num[y];i++)
	for(int j=0;j<num[y];j++) ans=(ans+dp[x%2][i][j])%mod;
	cout<<ans;
}

int main()
{
	cin>>x>>y;
	init(); DP();
	return 0;
}
```
谢谢大家！！！

---

## 作者：Refined_heart (赞：2)

### 题目大意

给定 $n\times m$ 的棋盘，往棋盘上面摆马，问有多少种摆法可以让马互不攻击。马是中国象棋的马，是可以被阻挡攻击路线的，如题干图中所示。

### 题目解法

看到数据范围，首先想到的就是状压了。我们发现，马涉及的状态实际上是 **前两列** ，所以我们需要存下前两列的状态。

那么我们就有一个自然的状态设计：$f[i][j][k]$ 表示第 $i$ 行，前两列的状态是 $j,k$ 的当前行的方案数。转移顺序很显然直接从上往转移即可。

下面我们从初始化开始分析这个 $dp.$

对于第一行，显然状态只有 $f[1][0][0]=2^m,$ 直接赋值即可。

对于第二行，考虑直接暴力处理相邻两行的所有可能性，复杂度 $O(4^m),$ 至于具体处理细节，由于只有两行，所以唯一需要判断的就是下面的行能不能攻击到上面的行以及上面的行能不能攻击到下面的行。

如果可以攻击到，那么需要满足它没有被阻挡并且攻击的位置上有马。简单位运算计算一下即可。

```cpp
bool check(int x,int y){
		for(int i=2;i<m;++i){
			if(!(y>>i&1))continue;
			int v=(y>>(i-1))&1;
			if(v)continue;
			if(x>>(i-2)&1)return false;
		}
		for(int i=2;i<m;++i){
			if(!(x>>i&1))continue;
			int v=(x>>(i-1)&1);
			if(v)continue;
			if(y>>(i-2)&1)return false;
		}
		for(int i=0;i<m-2;++i){
			if(!(y>>i&1))continue;
			int v=(y>>(i+1)&1);
			if(v)continue;
			if(x>>(i+2)&1)return false;
		}
		for(int i=0;i<m-2;++i){
			if(!(x>>i&1))continue;
			int v=(x>>(i+1)&1);
			if(v)continue;
			if(y>>(i+2)&1)return false;
		}
		return true;
	}
```

继续思考，到这一步为止我们解决了初始化的问题。考虑下面如何 $dp:$

一个显然的思路是，枚举第几行，枚举上一行、上上行、上上上行的状态，然后考虑当期行填什么。

由于当前行能填多少种东西只会被前两行影响，所以这一部分也可以直接预处理，复杂度 $O(8^m).$

接下来就遇到一个小问题，我们不知道如何继承之前的状态了。由于我们设计的状态不包含当前行的具体状态，所以我们不能直接获得对于前两行状态分别是 $j,k$ 时的方案数。

但是，我们可以直接枚举上上上行的状态，我们发现，如果这个状态可以满足当期枚举的后两行状态，**那么对于前一行填什么，它继承的信息都是一样的。也就是说，我们可以直接用这个信息除掉当前情况上一行能填的方案数，就可以得到固定状态的上一行的填马方案数。**

至于三行的马怎么判断合法，先把相邻的马判断掉，那么隔一行的马也很好判断，只有两种情况：要么上面的马走到下面攻击，要么下面的马到上面攻击。直接和两种马一样判断即可。

```cpp
bool check(int x,int y,int z){
		for(int i=0;i<m;++i){
			if(y>>i&1)continue;
			if(!(z>>i&1))continue;
			if(i&&(x>>(i-1)&1))return false;
			if(i<m-1&&(x>>(i+1)&1))return false;
		}
		for(int i=0;i<m;++i){
			if(y>>i&1)continue;
			if(!(x>>i&1))continue;
			if(i&&(z>>(i-1)&1))return false;
			if(i<m-1&&(z>>(i+1)&1))return false;
		}
		return true;
	}
```

然后这个除法在模意义下直接预处理逆元即可，复杂度 $O(2^m\log \bmod)$

总 $dp$ 复杂度是 $O(n\times 8^m).$ 写完发现爆空间了。

由于行对我们的状态影响不大，直接滚动数组即可。

复杂度 $O(n\times 2^8).$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef double db;
//#define int long long
const int mod=1e9+7;
const db eps=1e-14;
inline int Max(int x,int y){return x>y?x:y;}
inline int Min(int x,int y){return x<y?x:y;}
inline db Max(db x,db y){return x-y>eps?x:y;}
inline db Min(db x,db y){return x-y<eps?x:y;}
inline int Add(int x,int y,int M=mod){return (x+y)%M;}
inline int Mul(int x,int y,int M=mod){return 1ll*x*y%M;}
inline int Dec(int x,int y,int M=mod){return (x-y+M)%M;}
inline int Abs(int x){return x<0?-x:x;}
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
inline void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
inline int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=Mul(res,x);
		x=Mul(x,x);y>>=1;
	}
	return res;
}
typedef pair<int,int> pr;
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
#define poly vector<int>
namespace Refined_heart{
	int f[2][1<<6][1<<6],n,m,val[1<<6][1<<6],ival[1<<6][1<<6];
	bool check(int x,int y){
		for(int i=2;i<m;++i){
			if(!(y>>i&1))continue;
			int v=(y>>(i-1))&1;
			if(v)continue;
			if(x>>(i-2)&1)return false;
		}
		for(int i=2;i<m;++i){
			if(!(x>>i&1))continue;
			int v=(x>>(i-1)&1);
			if(v)continue;
			if(y>>(i-2)&1)return false;
		}
		for(int i=0;i<m-2;++i){
			if(!(y>>i&1))continue;
			int v=(y>>(i+1)&1);
			if(v)continue;
			if(x>>(i+2)&1)return false;
		}
		for(int i=0;i<m-2;++i){
			if(!(x>>i&1))continue;
			int v=(x>>(i+1)&1);
			if(v)continue;
			if(y>>(i+2)&1)return false;
		}
		return true;
	}
	int calc(int state){
		int res=0;
		for(int i=0;i<(1<<m);++i)res+=check(i,state);
		return res;
	}
	bool check(int x,int y,int z){
		for(int i=0;i<m;++i){
			if(y>>i&1)continue;
			if(!(z>>i&1))continue;
			if(i&&(x>>(i-1)&1))return false;
			if(i<m-1&&(x>>(i+1)&1))return false;
		}
		for(int i=0;i<m;++i){
			if(y>>i&1)continue;
			if(!(x>>i&1))continue;
			if(i&&(z>>(i-1)&1))return false;
			if(i<m-1&&(z>>(i+1)&1))return false;
		}
		return true;
	}
	void treat(){
		for(int i=0;i<(1<<m);++i)
			for(int j=0;j<(1<<m);++j){
				if(!check(i,j))continue;
				for(int k=0;k<(1<<m);++k){
					if(!check(j,k))continue;
					val[i][j]+=check(i,j,k);
				}
			}
		for(int i=0;i<(1<<m);++i)
			for(int j=0;j<(1<<m);++j)
				ival[i][j]=qpow(val[i][j],mod-2);
	}
	void MAIN(){
		n=read();m=read();
		f[1][0][0]=1<<m;
		for(int i=0;i<(1<<m);++i)f[0][i][0]=calc(i);
		treat();
		for(int i=3;i<=n;++i){
			int pos=i&1;
			memset(f[pos],0,sizeof f[pos]);
			for(int j=0;j<(1<<m);++j){
				for(int k=0;k<(1<<m);++k){
					if(!check(k,j))continue;
					int s=0;
					for(int l=0;l<(1<<m);++l){
						if(!check(l,k))continue;
						if(!check(l,k,j))continue;
						s=Add(s,Mul(f[pos^1][k][l],ival[l][k]));
					}
					f[pos][j][k]=Add(f[pos][j][k],Mul(s,val[k][j])); 
				}
			}
		}
		int ans=0;
		for(int i=0;i<(1<<m);++i)
			for(int j=0;j<(1<<m);++j)
				ans=Add(ans,f[n&1][i][j]);
		write(ans);
	}
}
int main(){
	Refined_heart::MAIN();
	return 0;
}

```


---

## 作者：假装思考 (赞：2)

【分析】

	       典型的状压DP了吧。。。用F[i][Sta]表示第i行放马情况为Sta的方案数，从i−1和i−2转移过来，注意中国象棋可以别马脚，然后空间限制1MB，滚动一下。还有这个判合法，直接位运算O(1)解决。。。
【代码】
```
	#include<bits/stdc++.h>
	#define For(i,a,b) for(register int i=(a);i<=(b);++i)
	#define Rof(i,a,b) for(register int i=(a);i>=(b);--i)
	#define Mod 1000000007
	using namespace std;
	int Ans,X,Y,Opt[3][1<<6][1<<6],Cur,Fir,Sec;
	int MOD(int x,long long y){if(y>=Mod)y%=Mod;for(x+=y;x>=Mod;x-=Mod);return x;}
	bool Check(int S1,int S2,int S3){
		if(((S1&(~(S1<<1)))>>2)&S2)return false;
		if(((S2&(~(S2<<1)))>>2)&S1)return false;
		if(((S2&(~(S2<<1)))>>2)&S3)return false;
		if(((S3&(~(S3<<1)))>>2)&S2)return false;
		if(((S1&(~(S1>>1)))<<2)&S2)return false;
		if(((S2&(~(S2>>1)))<<2)&S1)return false;
		if(((S2&(~(S2>>1)))<<2)&S3)return false;
		if(((S3&(~(S3>>1)))<<2)&S2)return false;
		if(((S1&(~S2))>>1)&S3)return false;
		if(((S1&(~S2))<<1)&S3)return false;
		if(((S3&(~S2))>>1)&S1)return false;
		if(((S3&(~S2))<<1)&S1)return false;
		return true;
	}
	int main(){
		scanf("%d%d",&X,&Y);Sec=0,Fir=1;
		For(i,0,(1<<Y)-1)Opt[0][i][0]=1;
		For(i,0,(1<<Y)-1)For(j,0,(1<<Y)-1)if(Check(i,j,0))Opt[1][i][j]=MOD(Opt[1][i][j],Opt[0][j][0]);
		For(r,2,X-1){
			Cur=r%3;memset(Opt[Cur],0,sizeof(Opt[Cur]));
			For(i,0,(1<<Y)-1)For(j,0,(1<<Y)-1)For(k,0,(1<<Y)-1)if(Check(i,j,k))Opt[Cur][i][j]=MOD(Opt[Cur][i][j],Opt[Fir][j][k]);
			Sec=Fir,Fir=Cur;
		}
		Cur=(X-1)%3;For(i,0,(1<<Y)-1)For(j,0,(1<<Y)-1)Ans=MOD(Ans,Opt[Cur][i][j]);
		printf("%d\n",Ans);
		return 0;
}
```

---

## 作者：Weekoder (赞：1)

### 思路

这是一道状压 DP。

考虑简单情况：没有障碍物的限制，这道题该怎么做？其实这样的话这道题就变成了 [P8756 [蓝桥杯 2021 省 AB2] 国际象棋](https://www.luogu.com.cn/problem/P8756) 了，可以先去做一做，我这里只讲如何处理障碍物。很明显，数据范围告诉了我们要压列。

首先，还是枚举三个状态：当前行，上一行，上上行。我们定义状态 $dp_{i,j,k}$ 表示当前到了第 $i$ 行，当前行状态为 $j$，上一行状态为 $k$。我们要判断当前行与上一行，上上行是否冲突：在上一行左右两格冲突的前提下，还得保证左右分别没有障碍物，才能说冲突。如何判断是否有障碍物？很简单，只要让当前状态按位与上当前状态左移一位或右移一位取反即可。比如，判断上一行的左边是否冲突，代码为 `(j & (~ j >> 1) & (k >> 2))`。注意，此处右移代表判断左边。而判断上下有没有障碍物更简单，将当前行的状态按位与上上下行的状态取反即可。以此类推，我们枚举三个状态，分别判断是否冲突并转移。初始状态很显然，就是 $dp_{0,0,0}=1$。这道题的关键就是判断是否冲突。

还有一点值得注意的是，由于障碍物的出现，我们不能只判断上面，而也要判断下面。在 P8756 中，我们只需要判断上一行和上上行，而在这道题中，我们还要反过来以上一行和上上行为状态，判断与下面的冲突。状态转移方程很规整：

$$
dp_{i,j,k}=(dp_{i,j,k}+dp_{i-1,k,x})\bmod(10^9+7)
$$

其中 $i$ 为行，$j$ 为当前行状态，$k$ 为上一行状态，$x$ 为上上行状态。这个状态转移方程的意义就是从上一行转移到这一行。

如何统计答案？枚举两个状态 $j,k$ 求和并取模即可。即 

$$
\sum_{j=0}^{2^m-1}\sum_{k=0}^{2^m-1}dp_{n,j,k}\bmod(10^9+7)
$$

至此，我们就写完了这道题 $80$ 分的写法。（哈？）

代码如下：

```cpp
#include <bits/stdc++.h>	

using namespace std;

const int S = 6, Mod = 1e9 + 7;

int n, m, dp[105][1 << S][1 << S], ans;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
	dp[0][0][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < (1 << m); j++) { // 当前行
			for (int k = 0; k < (1 << m); k++) { // 上一行
				for (int x = 0; x < (1 << m); x++) { // 上上行
					if (!((j & (~ j >> 1) & (k >> 2)) || (j & (~ j << 1) & (k << 2)) ||
				    	  (k & (~ k >> 1) & (j >> 2)) || (k & (~ k << 1) & (j << 2)) ||
						  (j & (~ k) & (x >> 1)) || (j & (~ k) & (x << 1))           ||
					      (x & (~ k) & (j >> 1)) || (x & (~ k) & (j << 1))			 ))
						dp[i][j][k] = (dp[i][j][k] + dp[i - 1][k][x]) % Mod;
				}
			}
		}
	}
	for (int j = 0; j < (1 << m); j++)
		for (int k = 0; k < (1 << m); k++)
			ans = (ans + dp[n][j][k]) % Mod;
	cout << ans;
    return 0;
}
```

### $100$ 分空间优化思路

《相信自己的做法 大喊一声 I won't MLE！您就会过这道题》

如果你按照我刚刚所说的写出了一份代码，那你就会发现它 MLE 了。在状压 DP 中，这是很常有的事，我们来看看怎么优化。

优化策略有两种：

- 滚动数组；

- 提前筛选出可能的状态；

在这里，我们只需要使用滚动数组这一个小小的技巧，就能 AC 本题。

观察到某一行的状态只与上一行有关，考虑滚动数组。比如现在正在转移第 $47$ 行，那么第 $45$ 行及以前的状态都是没用的，第 $47$ 行的状态只与第 $46$ 行有关。我们可以将第一维的行只开到 $2$，每次调用的时候都将 $i\&1$。这样，在调用 $i-1$ 的时候，只需要将 $i\&1$ 取反，即 $(i\&1) \text{ xor }1$（$\text{xor}$ 代表异或）。使用滚动数组后，代码里有 $4$ 处地方需要修改：

- $dp$ 数组的第一维只开到 $2$；

- 状态转移方程变为 $dp_{i\&1,j,k}=(dp_{i\&1,j,k}+dp_{(i\&1)\text{ xor }1,k,x})\bmod(10^9+7)$；

- 在枚举上上行状态并状态转移之前清空状态，$dp_{i\&1,j,k}=0$；

- 在统计答案时，改为求和 $dp_{n\&1,j,k}$；

在改完以后，就不会 MLE 了，空间大约缩小到了原来的 $\displaystyle\frac{1}{100}$，可以通过此题。

AC 完整代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int S = 6, Mod = 1e9 + 7;

int n, m, dp[2][1 << S][1 << S], ans;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
	dp[0][0][0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < (1 << m); j++) { // 当前行
			for (int k = 0; k < (1 << m); k++) { // 上一行
				dp[i & 1][j][k] = 0;
				for (int x = 0; x < (1 << m); x++) { // 上上行
					if (!((j & (~ j >> 1) & (k >> 2)) || (j & (~ j << 1) & (k << 2)) ||
				    	  (k & (~ k >> 1) & (j >> 2)) || (k & (~ k << 1) & (j << 2)) ||
						  (j & (~ k) & (x >> 1)) || (j & (~ k) & (x << 1))           ||
					      (x & (~ k) & (j >> 1)) || (x & (~ k) & (j << 1))			 ))
						dp[i & 1][j][k] = (dp[i & 1][j][k] + dp[(i & 1) ^ 1][k][x]) % Mod;
				}
			}
		}
	}
	for (int j = 0; j < (1 << m); j++)
		for (int k = 0; k < (1 << m); k++)
			ans = (ans + dp[n & 1][j][k]) % Mod;
	cout << ans;
    return 0;
}
```

---

## 作者：gesong (赞：1)

题目传送门：[P5005 中国象棋 - 摆上马](https://www.luogu.com.cn/problem/P5005)。
# 前置知识
判断 $i$ 和 $i-1$ 行是否冲突：
```
- - - - - - -
- 2 - - - 2 -
- - 3 1 3 - -
```
如图 $1$ 是马的位置，$2$ 是攻击的范围，$3$ 是马脚， 如果 $3$ 放了 $2$ 就不会被攻击。

我们想如果没有马脚，之间左右移再进行且运算就可以了，但是我们有马脚，可以直接让第 $3$ 行左右移，取反，再且运算即可。

```cpp
inline bool check1(int a,int b){
	if ((a<<2)&(b&~(b<<1))) return 1;
	if ((a>>2)&(b&~(b>>1))) return 1;
	if ((b<<2)&(a&~(a<<1))) return 1;//要注意判断反向
	if ((b>>2)&(a&~(a>>1))) return 1;
	return 0;
}
```

判断 $i$ 和 $i-2$ 行是否冲突：

```
- - 2 - 2 - - 
- - - 3 - - -
- - - 1 - - -
```

如图，说明如上，只是把第 $3$ 行左右移，再取反换成了，第 $2$ 行取反。

```cpp
inline bool check2(int a,int b,int c){
	if ((a<<1)&(c&~b)) return 1;
	if ((a>>1)&(c&~b)) return 1;
	if ((c<<1)&(a&~b)) return 1;
	if ((c>>1)&(a&~b)) return 1;
	return 0;
}
```
# 思路

这是一道很明显的 **dp**。

**状态表示：**

$f_{i,j,k}$ 表示第 $i$ 行状态为 $j$，$i-1$ 行状态为 $k$ 的方案数，我们假设 $i-2$ 行状态为 $l$。

**状态初始化：**

$f_{0,0,0}=1$ 啥也没有就 $1$ 种放法。

**状态转移：**

通过枚举 $l$，根据上上行就行转移（前提是不冲突），我的方案数就是前一行方案数总数。

最后方程为：$f_{i,j,k}=f_{i,j,k}+f_{i-1,k,l}$。

最后答案为：$f_{n,i,j}$。

由于这道题空间很小所以要用**状态压缩**。
# 代码
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
inline bool check1(int a,int b){
	if ((a<<2)&(b&~(b<<1))) return 1;
	if ((a>>2)&(b&~(b>>1))) return 1;
	if ((b<<2)&(a&~(a<<1))) return 1;
	if ((b>>2)&(a&~(a>>1))) return 1;
	return 0;
}
inline bool check2(int a,int b,int c){
	if ((a<<1)&(c&~b)) return 1;
	if ((a>>1)&(c&~b)) return 1;
	if ((c<<1)&(a&~b)) return 1;
	if ((c>>1)&(a&~b)) return 1;
	return 0;
}
const int N=110,M=7;
int f[2][1<<M][1<<M];
const int mod=1e9+7;
main(){
	int n,m;
	cin>>n>>m;
	f[0][0][0]=1;
	for (int i=1;i<=n;i++)
		for (int j=0;j<(1<<m);j++)
			for (int k=0;k<(1<<m);k++){
				f[i&1][j][k]=0;
				if (check1(j,k)) continue;
				for (int l=0;l<(1<<m);l++){
					if (check2(j,k,l)||check1(k,l)) continue;
					f[i&1][j][k]+=f[(i&1)^1][k][l];
					f[i&1][j][k]%=mod;
				}
			}
	int ans=0;
	for (int i=0;i<(1<<m);i++)
		for (int j=0;j<(1<<m);j++) ans+=f[n&1][i][j],ans%=mod;
	cout <<ans;
    return 0;
}

```


---

## 作者：Nephren_Sakura (赞：1)

题目传送门：[link](https://www.luogu.com.cn/problem/P5005)。

首先，看到这种棋盘上摆棋子的问题，容易想到一道类似的题：[link](https://www.luogu.com.cn/problem/P1896)。

然后我们发现这两题几乎唯一的区别就是放的棋子从王变成了马，也就是判定需要改变。然后没有棋子数量的限制。

又因为马的判定和上两行有关，所以我们可以这样设：

$dp_{i,j,k}$ 表示第 $i$ 行，当前行状态为 $j$，上一行状态为 $k$ 的总方案数。

然后转移的时候枚举上上行转移即可。

设当前行为 $i$，状态为 $j$，上一行状态为 $k$，枚举到的状态为 $l$，转移方程为：

$dp_{i,j,k}=dp_{i,j,k}+dp_{i,k,l}$

然后就是判定的问题。

看到其他人这个判定都用了十分奇怪的判定方法，我来一个简单一些但常数大，要开 O2 才能过得判定：

直接枚举每一个点。如果这个点是马，则判断所有他能到的点是否为马。常数较大但是好理解。

但是这题还有一个恶心的点，就是 1MB 的空间。

因为我们转移方程中只需要上一行的状态，所以可以滚动数组把第一维压掉。

具体的代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int n,m,dp[2][65][65];
int a[4][7];
int madx[9]={0,1,-1,1,-1,2,2,-2,-2};
int mady[9]={0,2,2,-2,-2,1,-1,1,-1};//马的走法
int bingdx[5]={0,0,0,1,-1};
int bingdy[5]={0,1,-1,0,0};//兵的走法，判断“拐马腿”
bool check(int nw,int last,int lastlast){
	for(int i=0; i<=m-1; i++)
		a[1][i]=((nw&(1<<i))!=0);
	for(int i=0; i<=m-1; i++)
		a[2][i]=((last&(1<<i))!=0);
	for(int i=0; i<=m-1; i++)
		a[3][i]=((lastlast&(1<<i))!=0);
	for(int i=1; i<=3; i++){
		for(int j=0; j<=m-1; j++){
			if(a[i][j]==0)
				continue;
			for(int k=1; k<=4; k++){
				int nx=i+bingdx[k],ny=j+bingdy[k];
				if(nx>=1&&nx<=3&&ny>=0&&ny<=m-1&&a[nx][ny]==0){//判断这条路是否会被其他的马挡住
					int x1=i+madx[k*2-1],x2=i+madx[k*2],y1=j+mady[k*2-1],y2=j+mady[k*2];//注意到我的写法马的走法和兵的走法是直接对应的，才可以这样写
					if((x1>=1&&x1<=3&&y1>=0&&y1<=m-1&&a[x1][y1]==1)||(x2>=1&&x2<=3&&y2>=0&&y2<=m-1&&a[x2][y2]==1))
						return false;//判断能到的点是否为马
				}
			}
		}
	}
	return true;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	dp[0][0][0]=1;
	for(int i=1; i<=n; i++){
		for(int j=0; j<(1<<m); j++)//当前行 
			for(int k=0; k<(1<<m); k++)//上一行 
				for(int l=0; l<(1<<m); l++)//上上行 
					if(check(j,k,l)==true)//判定
						dp[i&1][j][k]+=dp[(i-1)&1][k][l],dp[i&1][j][k]%=mod;//转移
		for(int j=0; j<(1<<m); j++)
			for(int k=0; k<(1<<m); k++)
				dp[(i-1)&1][j][k]=0;//滚动数组要清空
	}
	int ans=0;
	for(int i=0; i<(1<<m); i++)
		for(int j=0; j<(1<<m); j++)
			ans+=dp[n&1][i][j],ans%=mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：fanypcd (赞：1)

面向数据：$1\leq X \leq 100,1\leq Y \leq 6$。（以下用 $n,m$ 分别代替 $X,Y$）。

状压 dp 无疑了。

然后我们假设当前计算到第 $i$ 行，发现马至多能从前两行攻击过来，于是考虑将当前行和前一行压入状态（再前面的会被上一行的数组压入）。

设 $f_{i,S,S'}$ 表示当前计算到第 $i$ 行，放置马的状态为 $S$，$i - 1$ 行的状态为 $S'$ 的不同放置方案数。在转移的时候枚举当前行，上一行，上上行的放置状态，判断如果不会互相攻击就可以转移，复杂度 $O(n\times 2^{3m})$。

自然可以写出如下的代码：

```cpp
f[0][0][0] = 1;
for(int i = 1, now = 1; i <= n; i++, now ^= 1)
{
	memset(f[now], 0, sizeof(f[now]));
	for(int st = 0; st < (1 << m); st++)
	{
		for(int pst = 0; pst < (1 << m); pst++)
		{
			for(int ppst = 0; ppst < (1 << m); ppst++)
			{
				f[now][st][pst] = (f[now][st][pst] + f[now ^ 1][pst][ppst] * check(st, pst, ppst)) % mod;
			}
		}
	}
}
```

现在的关键就是怎么判断前后三行的放置状态不会有能互相攻击到的，还需要考虑绊脚的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/2go8tasn.png)

手玩一下，发现如果图中黑色位置放置了马的话，要求图中的红色位置均不能放置，或者绿色位置放置了马（即无法攻击），否则可以攻击到它。

也就是：

- 对于上一行，向右跳的攻击方式，要求上一行向左两步对应格没有放置，或者向左一步对应格有放置。

```((st << 2) & (pst & ~(pst << 1))) == 0```

- 对于上一行，向左跳的攻击方式，要求上一行向右两步对应格没有放置，或者向右一步对应格有放置。

```((st >> 2) & (pst & ~(pst >> 1))) == 0```

- 对于上上行，向右跳的攻击方式，要求上上行向左一步对应格没有放置，或者上一行向左一步对应格有放置。

```((st << 1) & (ppst & ~pst)) == 0```

- 对于上上行，向左跳的攻击方式，要求上上行向右一步对应格没有放置，或者上一行向右一步对应格有放置。

```((st >> 1) & (ppst & ~pst)) == 0```

这样就保证了当前行不会被上一行或者上上行的放置攻击到。

鉴于 f 数组保证了上上行不能攻击到上一行（否则不会被统计），我们还需要保证当前行不能攻击到上一行或者上上行（代码中体现了，不再赘述）。

最后加上一个滚动数组即可。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline void read(int &x)
{
	x = 0;
	int f = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		f |= ch == '-';
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	x = f ? -x : x;
	return;
}
const int mod = 1e9 + 7;
#define M 6
int n, m;
int f[2][1 << M][1 << M];
inline bool check(int st, int pst, int ppst)
{
	return !(((st << 2) & (pst & ~(pst << 1))) || ((st >> 2) & (pst & ~(pst >> 1))) || ((st << 1) & (ppst & ~pst)) || ((st >> 1) & (ppst & ~pst))) && !(((pst << 2) & (st & ~(st << 1))) || ((pst >> 2) & (st & ~(st >> 1)))) && !(((ppst << 1) & (st & ~pst)) || ((ppst >> 1) & (st & ~pst)));
}
signed main()
{
	read(n), read(m);
	f[0][0][0] = 1;
	for(int i = 1, now = 1; i <= n; i++, now ^= 1)
	{
		memset(f[now], 0, sizeof(f[now]));
		for(int st = 0; st < (1 << m); st++)
		{
			for(int pst = 0; pst < (1 << m); pst++)
			{
				for(int ppst = 0; ppst < (1 << m); ppst++)
				{
					f[now][st][pst] = (f[now][st][pst] + f[now ^ 1][pst][ppst] * check(st, pst, ppst)) % mod;
				}
			}
		}
	}
	int ans = 0;
	for(int st = 0; st < (1 << m); st++)
	{
		for(int pst = 0; pst < (1 << m); pst++)
		{
			ans = (ans + f[n & 1][st][pst]) % mod;
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Plozia (赞：1)

~~相信自己的做法，大喊一声 ：I won't MLE！你就会过这道题。~~

~~于是我就 MLE 了。~~

先假设空间限制为 256 MB，然后来想这道题。

这是一道二维的状压 DP，模仿第一题不难想到设 $f_{i,j,k}$ 表示当前做到第 $i$ 行，当前行状态为 $j$，上一行状态为 $k$ 的方案数。

因为马攻击范围可以到上下两行，所以需要枚举上上行状态 $l$。

那么转移方程如下：

$$f_{i,j,k}=\sum f_{i-1,k,l}$$

其中保证 $j,k,l$ 不会互相冲突。

初值：$f_{1,i,0}=1$，第二行需要特别处理，因为没有上上行。

于是我们可以先写下面这样的代码：

```cpp
for (int i = 0; i < (1 << m); ++i)
		for (int j = 0; j < (1 << m); ++j)
			if (i 与 j 不冲突) f[2][j][i] = (f[2][j][i] + f[1][i][0]) % P;
for (int i = 3; i <= n; ++i)
	for (int j = 0; j < (1 << m); ++j)
		for (int k = 0; k < (1 << m); ++k)
		{
			f[i][j][k] = 0;
			if (j 与 k 冲突) continue;
			for (int l = 0; l < (1 << m); ++l)
			{
				if (k 与 l 冲突) continue;
				if (j 与 l 冲突) continue;
				f[i][j][k] = (f[i][j][k] + f[i - 1][k][l]) % P;
			}
		}
ans = 0;
for (int i = 0; i < (1 << m); ++i)
	for (int j = 0; j < (1 << m); ++j)
		if (i 与 j 不冲突) ans = (ans + f[n][i][j]) % P;
```

然后来考虑怎么处理冲突问题。

冲突分两种：两行冲突（`Two_attack`）和三行冲突（`Three_attack`）。

- 两行冲突：也就是单行对下一行的攻击是否与下一行冲突。
- 三行冲突：也就是第一行的跨行攻击是否对第三行冲突。

不好理解？那就对了，~~反正我说的也不是人话，~~ 上图！

两行冲突：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210306094614395.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

从右往左考虑。记当前状态为 `10110110`

第一个格子没有马，跳过。

第二个格子有马，那么这个格子右边有马吗？没有。于是可以向右攻击。但是他左边有马，于是不能想左攻击。

那么就变成了这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021030609484945.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

第三个格子，右边有马，左边没有马，那么可以向左边攻击。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210306094954785.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

这么循环反复，最后就变成了这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210306095246602.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

三行冲突（暂且不考虑两行冲突）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210306095638531.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

还是考虑第一行，发现右数第二格有马，而且没被挡住，那么可以向下面两行攻击。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210306095835182.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

然后右数第三个，有马且没被挡住，可以向下攻击。

那么继续做下去，发现只有第一列的马被挡住，那么最后结果如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021030610003080.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JXemh1emVoYW8=,size_16,color_FFFFFF,t_70#pic_center)

于是就做完了。

关于代码实现：

首先我们需要两个基础函数：

```cpp
int Getbit(int x, int a)//返回 x 的二进制下第 a 位且保留右侧 0
{
	if (a < 1) return 0;
	return x & (1 << (a - 1));
}

int check(int x, int a)//查询 x 的二进制下第 a 位
{
	if (a < 1) return 0;
	if (x & (1 << (a - 1))) return 1;
	return 0;
}
```

然后就可以愉快的打代码了。

这里有一个小技巧：`-1` 的补码是 `11111111111111111111111111111111`（32 个1），可以利用这个来处理位运算。

`Two_attack` 和 `Three_attack` 如下：

```cpp
int Two_attack(int k)//k 是上面一行状态
{
	int State = 0;
	for (int i = 1; Getbit(-1, i) <= k; ++i)
	{
		if (!check(k, i)) continue;
		if (!check(k, i - 1)) State |= Getbit(-1, i - 2);
		if (!check(k, i + 1)) State |= Getbit(-1, i + 2);
	}
	return State;
}

int Three_attack(int k, int l)//k 是第一行，l 是第二行
{
	int State = 0;
	for (int i = 1; Getbit(-1, i) <= k; ++i)
	{
		if (!check(k, i)) continue;
		if (!check(l, i)) State |= Getbit(-1, i - 1), State |= Getbit(-1, i + 1);
	}
	return State;
}
```

那么就做完了。

**特别提醒：因为本题毒瘤的空间限制，必须使用滚动数组压缩空间。**

代码：

```cpp
/*
========= Plozia =========
	Author:Plozia
	Problem:P5005 中国象棋 - 摆上马
	Date:2021/3/5
========= Plozia =========
*/

#include <bits/stdc++.h>

typedef long long LL;
const int P = 1e9 + 7;
int n, m;
LL f[3][64][64], ans;

int read()
{
	int sum = 0, fh = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
	return (fh == 1) ? sum : -sum;
}

int Getbit(int x, int a)//返回 x 的二进制下第 a 位且保留右侧 0
{
	if (a < 1) return 0;
	return x & (1 << (a - 1));
}

int check(int x, int a)//查询 x 的二进制下第 a 位
{
	if (a < 1) return 0;
	if (x & (1 << (a - 1))) return 1;
	return 0;
}

int Two_attack(int k)//k 是上面一行状态
{
	int State = 0;
	for (int i = 1; Getbit(-1, i) <= k; ++i)
	{
		if (!check(k, i)) continue;
		if (!check(k, i - 1)) State |= Getbit(-1, i - 2);
		if (!check(k, i + 1)) State |= Getbit(-1, i + 2);
	}
	return State;
}

int Three_attack(int k, int l)//k 是第一行，l 是第二行
{
	int State = 0;
	for (int i = 1; Getbit(-1, i) <= k; ++i)
	{
		if (!check(k, i)) continue;
		if (!check(l, i)) State |= Getbit(-1, i - 1), State |= Getbit(-1, i + 1);
	}
	return State;
}

int main()
{
	n = read(), m = read();
	for (int i = 0; i < (1 << m); ++i) f[1][i][0] = 1;
	for (int i = 0; i < (1 << m); ++i)
		for (int j = 0; j < (1 << m); ++j)
			if ((!(Two_attack(i) & j)) & (!(Two_attack(j) & i))) f[2][j][i] = (f[2][j][i] + f[1][i][0]) % P;
	for (int i = 3; i <= n; ++i)
		for (int j = 0; j < (1 << m); ++j)
			for (int k = 0; k < (1 << m); ++k)
			{
				f[i % 3][j][k] = 0;
				if (Two_attack(j) & k) continue;
				if (Two_attack(k) & j) continue;
				for (int l = 0; l < (1 << m); ++l)
				{
					if (Two_attack(l) & k) continue;
					if (Two_attack(k) & l) continue;
					if (Three_attack(l, k) & j) continue;
					if (Three_attack(j, k) & l) continue;
					f[i % 3][j][k] = (f[i % 3][j][k] + f[(i - 1) % 3][k][l]) % P;
				}
			}
	ans = 0;
	for (int i = 0; i < (1 << m); ++i)
		for (int j = 0; j < (1 << m); ++j)
			if ((!(Two_attack(i) & j)) & (!(Two_attack(j) & i))) ans = (ans + f[n % 3][i][j]) % P;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Jr_Zlw (赞：1)

# 状态压缩dp

这是一道状压的基础题，没有复杂奇特的题目条件，题意也很清晰。

想像自己无聊透顶把马摆上棋盘，然后看看会不会在一步之内有马被吃掉，摆放的方案数就是这道题要求的。

横向的宽度最大为  $6$  ，那么很明显就是横向压缩了。

## 合法情况判断

众所周知，马是这样走的（ 1 代表马所在的位置， 0 是空格 ）：

![](https://cdn.luogu.com.cn/upload/image_hosting/iavxd9el.png)

马能够条到浅黄色块上仅当该方向上橙色方块上没有其他的马。

我们发现当两只马不能互相吃到时有如下两种情况：

1. 马不在浅黄色的位置上；

2. 如下图，橙色位置被其他马堵死，并且堵死的条件必须是双向的。

![](https://cdn.luogu.com.cn/upload/image_hosting/wtvpvvds.png)

直接跳马的情况很好判断，只要分别将该层状态左移或右移到对应位置，然后进行 & 操作。会出现两种情况：

1. 如果结果为  $0$  就证明浅黄色位置上没有其他的马。

2. 否则得出的答案就是在  $1$  的位置上的马是危险的。

对于有撇马脚情况，我们实际上就是要判断有没有连续  $2$  个马出现的墙体。

竖着的连续  $1$  很好判断，将上下两个状态 & 一下就好了，得出的结果就是墙所在的位置。

横着的也比较容易判断。将本身状态右（左）移一位，在与自身进行 & 操作，得出的结果就是某一位向左（右）一格有没有连续的  $1$  。

最后对齐一下两次得出的结果就能判断出这种情况合不合法了。

判断部分代码：

```
inline bool judge1(int j,int k)//判断相邻 2 行是否合法
{
	int x=(j>>2)&k,y=(j<<2)&k;
	return (!y||((y>>1)&(j&k))==(y>>1))&&((!x||((x<<1)&(j&k))==(x<<1)));
}
inline bool judge2(int j,int l,int k)//判断隔着的 1 行是否合法
{
	int x=(j<<1)&k,y=(j>>1)&k;
	return ((!x||(x&(l&(l<<1)))==x)&&(!y||(y&(l&(l>>1)))==y));
}
```

## dp过程

做过炮兵阵地模板题的都应该很清楚了。

由于马的状态与其上面的  $2$  行状态是相关的。

所以必须用  $2$  维数组存储每  $2$  行的状态。

令  $dp[i][j][k]$  表示考虑到第  $i$  行时第  $i$  行状态为  $j$  ，第  $i-1$  行状态为  $k$  。

然后就得到了表达式（ judge1 和 judge2 意义如上代码 ）：

```
dp[i][j][k]=dp[i-1][k][l] (judge1(j,k)&&judge2(j,k,l)&&judge1(k,l))
```

那么因为 " I won't MLE " ，那么必须使用滚动数组咯。

加上滚动数组就过了嘛。

双手奉上代码（码分较丑请原谅）：

```
#include<bits/stdc++.h>
#define rep(a,b,c) for(int c=(a);c<=(b);++c)
#define drep(a,b,c) for(int c=(a);c>=(b);++c)
using namespace std;
const int Mod=1e9+7;

int dp[3][64][64];
inline bool judge1(int j,int k)
{
	int x=(j>>2)&k,y=(j<<2)&k;
	return (!y||((y>>1)&(j&k))==(y>>1))&&((!x||((x<<1)&(j&k))==(x<<1)));
}
inline bool judge2(int j,int l,int k)
{
	int x=(j<<1)&k,y=(j>>1)&k;
	return ((!x||(x&(l&(l<<1)))==x)&&(!y||(y&(l&(l>>1)))==y));
}
inline void Add(int &x,int y){x+=y;if(x>Mod)x-=Mod;}
int main()
{
	int n,m;scanf("%d%d",&n,&m);int len=(1<<m)-1;rep(0,len,i)dp[1][i][0]=1;
	rep(0,len,i)rep(0,len,j)dp[2][i][j]=judge1(i,j);
	rep(3,n,i){ memset(dp[i%3],0,sizeof(dp[i%3]));
	rep(0,len,j)rep(0,len,k)if(judge1(j,k))rep(0,len,l)if(judge1(k,l)&&judge2(j,k,l))
		dp[i%3][j][k]=(dp[i%3][j][k]+dp[(i-1)%3][k][l])%Mod;}
	int ans=0;rep(0,len,i)rep(0,len,j)ans=(ans+dp[n%3][i][j])%Mod;printf("%d",ans);

}
```

完结撒花。

---

## 作者：stupid_collie (赞：0)

#### 比较典型的状态压缩 + 滚动数组 DP

看到数据范围 $n\le100$ 大概就想的到是状态压缩动态规划。

首先，我们可以先预处理行与行之间的合法关系。由于马不会攻击同一列上的其他马，所以在同一列时，不论我们怎么摆放马，总是合法的。那么，我们定义一个数组 $dp$，其中，$dp_{i,j,k}$ 表示的是在第 $i$ 行，当前行和前一行分别为 $j$ 和 $k$ 时的方案数。

这样一来我们就可以先对第一列进行初始化：
```cpp
  for(i = 0;i<(1<<y);i++)
    dp[1][i][0] = 1;
```

在行与行之间的合法关系时，维护一个 $vis$ 布尔变量，记录两种摆放方式之间是否合法。具体的处理方法很简单，我们只要判断在纵向上网上和往下分别两格的位置是否有马，并且马有没有被阻挡就行了。

具体代码如下：

```cpp
  for(i = 0;i<(1<<y);i++){
    for(j = 0;j<(1<<y);j++){
      fl = false;
      for(k = 0;k<y;k++){//k表示枚举到第k位
        if(i&(1<<k)){
          if((j&(1<<k+2))&&!(j&(1<<k+1))){
            fl = true;
            break;
          }else if(k>=2 and (j&1<<k-2)&&!(j&(1<<k-1))){
            fl = true;
            break;
          }
        }
      }
      if(fl){
        ill[i][j] = ill[j][i] = true;//因为我们只处理了后排攻击前排的情况，而反过来也是同理
      }
    }
  }

```

最后，我们就可以开始从前往后推了。分别枚举往前两行、往前一行和当前行的状况，在我们预处理的基础上，我们只要再额外处理一下当前行攻击往前两行，和往前两行攻击当前行这两种情况就行了。定义集合 $\mathbf{A}$ 为所有既能在 $j$ 前一行，也能在 $p$ 前两行的状态数，那么我们有转移方程：

$dp_{r,p,j}=\displaystyle\sum_{i\in\mathbf{A}}dp_{r-1,j,i}$

最终统计答案的时候，只要将所有互相合法的方案数加起来就行了。

注意，本题的空间限制只有 1MB，所以要用 **滚动数组**。完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int dp[3][1<<6][1<<6],x,y,i,j,k,r,p,ans,row;
bool fl,ill[1<<6][1<<6];

int main(){
  scanf("%d%d",&x,&y);

  for(i = 0;i<(1<<y);i++)
    dp[1][i][0] = 1;

  for(i = 0;i<(1<<y);i++){
    for(j = 0;j<(1<<y);j++){
      fl = false;
      for(k = 0;k<y;k++){
        if(i&(1<<k)){
          if((j&(1<<k+2))&&!(j&(1<<k+1))){
            fl = true;
            break;
          }else if(k>=2 and (j&1<<k-2)&&!(j&(1<<k-1))){
            fl = true;
            break;
          }
        }
      }
      if(fl){
        ill[i][j] = ill[j][i] = true;
      }
    }
  }

  for(i = 0;i<(1<<y);i++)    for(j = 0;j<(1<<y);j++)
      if(!ill[i][j])dp[2][i][j] = 1;
  if(x<=2){
    for(i = 0;i<(1<<y);i++){
      for(j = 0;j<(1<<y);j++){
        if(!ill[i][j])(ans += dp[x][i][j]) %= 1000000007;
      }
    }

    printf("%d",ans);
    return 0;
  }

  row = 1;
  for(r = 3;r<=x;r++){
    memset(dp[row],0,sizeof dp[row]);
    for(p = 0;p<(1<<y);p++){
      for(j = 0;j<(1<<y);j++){
        for(i = 0;i<(1<<y);i++){
          if(ill[i][j]||ill[j][p])continue;

          fl = false;
          for(k = 0;k<y;k++){
            if(p&(1<<k)){
              if((i&1<<k+1)&&!(j&1<<k+1)){
                fl = true;
                break;
              }else if(k>=1 and (i&1<<k-1)&&!(j&1<<k-1)){
                fl = true;
                break;
              }else if(!(j&1<<k)&&((i&1<<k+1)||(k>=1 and (i&1<<k-1)))){
                fl = true;
                break;
              }
            }
          }

          if(!fl)(dp[row][p][j] += dp[3-row][j][i]) %= 1000000007;
        }
      }
    }
    row = 3 - row;
  }

  for(i = 0;i<(1<<y);i++){
    for(j = 0;j<(1<<y);j++){
      if(!ill[i][j])(ans += dp[3 - row][i][j]) %= 1000000007;
    }
  }

  printf("%d",ans);
}

```

---

## 作者：Leowang2009 (赞：0)

这原本是个紫题……

前置芝士：[状压 dp](https://oi-wiki.org/dp/state/)

在做这道题前，可以先看看这个：[P8756 国际象棋](https://www.luogu.com.cn/problem/P8756)

## 思路
用二进制存储每行的状态，1 为放马，0 为不放，因为马最多只能吃到上两行的棋子，即当前这行只与上两行有关，所以只用开一个三维数组，一维存行数，剩下两维存上两行的状态，最后加起来输出即可（具体实现可以看下面的代码）。

接下来还有一个难点，如何判断状态合法。

中国象棋的马和国际象棋的马有一点不同——中国象棋有“蹩马腿”（题目上有具体说明），而国际象棋没有。因此国际象棋直接用简单的位运算即可，接下来介绍如何判断中国象棋中状态是否合法。

### 分类讨论：
1. 如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3ifdq9k3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然，图中两种情况是等价的，由中国象棋中“蹩马腿”的定义可知，如果两个红色方块中有棋子，显然当且仅当两个蓝色方格中也有棋子，状态合法。（注意两种情况都要判断！）

判断方法可以每列都判断一遍，最后如果都合法返回 ```true```，否则返回 ```false```。
#### code:
```cpp
for(int i=1;i<=n;i++){
	if(i>2&&(x[i]&y[i-2])&&(!y[i-1]||!x[i-1])) return false;
	else if(i<n-1&&(x[i]&y[i+2])&&(!y[i+1]||!x[i+1])) return false;
	//分别判断当前行与上一行每一列是否合法，如果不合法，直接返回
}
```


2. 如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zfiknebv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

和第一种情况一样，这里不再过多赘述，直接上代码：
#### code:
```cpp
for(int i=1;i<=n;i++){
	if(i>1&&(x[i]&z[i-1])&&!(y[i]&y[i-1])) return false;
	else if(i<n&&(x[i]&z[i+1])&&!(y[i]&y[i+1])) return false;
	//同上
}
```

### dp 部分：
这道题的 dp 部分和其他状压 dp 是一样的，在此不再过多说明，重点是要记得用滚动数组，要不然会 MLE（可以考虑将行数压缩，因为当前行的情况数仅与上一行的情况数有关，详细方法可以看代码）。

最后合起来，就能愉快的 AC 了——
## AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=1e9+7;
long long f[2][70][70],n,m,res;
bool opt;
bool check(int a,int b,int c){
	int x[10],y[10],z[10];
	for(int i=1;i<=n;i++）{
		x[i]=a%2,y[i]=b%2,z[i]=c%2,a/=2,b/=2,c/=2;
		//拆分为二进制，即状态
	}
	for(int i=1;i<=n;i++){
		if(i>2&&(x[i]&y[i-2])&&(!y[i-1]||!x[i-1])) return false;
		else if(i<n-1&&(x[i]&y[i+2])&&(!y[i+1]||!x[i+1])) return false;
		//分别判断当前行与上一行每一列是否合法，如果不合法，直接返回
	}
	for(int i=1;i<=n;i++){
		if(i>1&&(x[i]&z[i-1])&&!(y[i]&y[i-1])) return false;
		else if(i<n&&(x[i]&z[i+1])&&!(y[i]&y[i+1])) return false;
		//同上
	}return true;//如果未退出，说明合法，返回true
}
int main(){
	cin>>m>>n;
	for(int i=0;i<(1<<n);i++) f[opt][i][0]++;
	for(int i=2;i<=m;i++){
		opt^=1;//改变opt的值
		for(int j=0;j<(1<<n);j++){
			for(int a=0;a<(1<<n);a++){
				f[opt][j][a]=0;
				for(int l=0;l<(1<<n);l++){
					if(check(j,a,l)) f[opt][j][a]+=f[opt^1][a][l],f[opt][j][a]%=N;
					//如果合法将加上情况数
				}
			}
		}
	}
	for(int i=0;i<(1<<n);i++){
		for(int j=0;j<(1<<n);j++){
			res+=f[opt][i][j],res%=N;//将所有状态种类数相加
		}
	}
	cout<<res;//输出
	return 0;
}
```
完结撒花！

---

## 作者：piggy123 (赞：0)

谨以此篇题解纪念我首个完全独立思考 AC 的紫题。

首先，本题一眼看上去就是个炮兵阵地加强版，然后数据范围  $M\leq 6$，铁状压。

显然，我们需要设计一个$3$维动态规划，维护当前行号，当前行状态，上一行状态（因为马的攻击范围只有两行）。我们令  $dp_{i,j,k}$ 代表当前看到第 $i$ 行，本行状态为 $j$， 上一行状态为 $k$ 的方案数，$ok_{i,j,k}$ 代表状态是否合法。状态转移方程即为：
$$
dp_{i,j,k}=\sum_q [ok_{q,j,k}]dp_{i-1,q,j}
$$

最主要的是 $ok_{i,j,k}$ 如何求，我们可以通过位运算的左移右移来表示，注意，马的攻击不一定是相互的（因为有马脚）。我们可以首先预处理出所有局面不可以放的位置，以及上下两行冲突的局面方便判断。预处理复杂度 $\Theta(2^{m+1}m)$。

这里是关键部分的代码，其中后两行是判断若该点放置的话会不会影响前面的局面，即能够攻击到上面的马：

```cpp
for (int k=0; k<=((1<<m)-1); k++) {
		for (int l=0; l<=((1<<m)-1); l++) {
			for (int j=0; j<m; j++) {
				if ((k>>1)&(1<<j))if (!((l>>1)&(1<<j)))can[k][l]|=1<<j;
				if ((k<<1)&(1<<j))if (!((l<<1)&(1<<j)))can[k][l]|=1<<j;
				if ((l>>2)&(1<<j))if (!((l>>1)&(1<<j)))can[k][l]|=1<<j;
				if ((l<<2)&(1<<j))if (!((l<<1)&(1<<j)))can[k][l]|=1<<j;
				if (!(l&(1<<j)))if (k>>1&(1<<j))can[k][l]|=1<<j;
				if (!(l&(1<<j)))if (k<<1&(1<<j))can[k][l]|=1<<j;

			}
		}
	}
```


随即注意到本题空间限制仅 $1\texttt{Mb}$，所以滚动数组一下即可。

AC Code：
```cpp
#include <bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;

int dp[2][1<<6+1][1<<6+1],can[1<<6+1][1<<6+1];
bool ok[1<<6+1][1<<6+1];

string abc(ll s,ll dep) {
	if (dep==2)return s%2?"1":"0";
	return abc(s/2,dep+1)+(s%2?"1":"0");
}

int main() {
	int n,m;
	cin >> n >> m;
	for (int k=0; k<=((1<<m)-1); k++) {
		for (int l=0; l<=((1<<m)-1); l++) {
			for (int j=0; j<m; j++) {
				if ((k>>1)&(1<<j))if (!((l>>1)&(1<<j)))can[k][l]|=1<<j;
				if ((k<<1)&(1<<j))if (!((l<<1)&(1<<j)))can[k][l]|=1<<j;
				if ((l>>2)&(1<<j))if (!((l>>1)&(1<<j)))can[k][l]|=1<<j;
				if ((l<<2)&(1<<j))if (!((l<<1)&(1<<j)))can[k][l]|=1<<j;
				if (!(l&(1<<j)))if (k>>1&(1<<j))can[k][l]|=1<<j;
				if (!(l&(1<<j)))if (k<<1&(1<<j))can[k][l]|=1<<j;

			}
		}
	}
	for (int k=0; k<=((1<<m)-1); k++) {
		for (int l=0; l<=((1<<m)-1); l++) {
			ok[k][l]=1;
			for (int j=0; j<m; j++) {
				if (l&(1<<j))
					if ((k<<2)&(1<<j))
						if (!((k<<1)&(1<<j)))
							ok[k][l]=0;
				if (l&(1<<j))
					if ((k>>2)&(1<<j))
						if (!((k>>1)&(1<<j)))

							ok[k][l]=0;

				if (k&(1<<j))
					if ((l<<2)&(1<<j))
						if (!((l<<1)&(1<<j)))
							ok[k][l]=0;
				if (k&(1<<j))
					if ((l>>2)&(1<<j))
						if (!((l>>1)&(1<<j)))

							ok[k][l]=0;
			}
		}
	}
	for (int k=0; k<=((1<<m)-1); k++)dp[1][0][k]=1;


	for (int l=0; l<=((1<<m)-1); l++)
		for (int k=0; k<=((1<<m)-1); k++)
			if (ok[k][l]) {
				dp[0][k][l]+=dp[1][0][k];
				dp[0][k][l]%=mod;
			}


	for (int i=3; i<=n; i++) {
		memset(dp[i%2],0,sizeof(dp[i%2]));
		for (int j=0; j<=((1<<m)-1); j++) {
			for (int l=0; l<=((1<<m)-1); l++) {
				for (int k=0; k<=((1<<m)-1); k++) {

					if (!ok[k][l])continue;
					if (!ok[l][j])continue;
					if (can[k][l]&j)continue;

					dp[i%2][l][j]+=dp[i%2^1][k][l];
					dp[i%2][l][j]%=mod;
				}
			}
		}
	}
	ll ans=0;
	for (int j=0; j<=((1<<m)-1); j++) {
		for (int k=0; k<=((1<<m)-1); k++) {
			if (ok[j][k]) {
				ans+=dp[n%2][j][k];
				ans%=mod;
			}

		}
	}
	cout << ans;
	return 0;
}

```



---

## 作者：BigJoker (赞：0)

# 前言

做这种题还是挺爽的。

前置知识：状压+滚动数组

# 思路

相信各位都做过差不多的问题，像放国王，放炮弹等。

这里与上诉的差不多，只是多了一个条件限制：撇马腿。

我们一步一步来看。

**STEP1**：

先看看数据范围，发现 $m$ 特别小，$n$ 比较大。

很自然的想到把 $m$ 这一维作为二进制的状态来进行处理。

接着我们来推一下这个有趣的状压。

**STEP2**:

对于每个马，肯定会影响到上一排和上上一排，或者说是被上一排和上上一排影响，那么状压第一位是行数 $n$，第二维是当前状态，第三维是上一排的状态，目前看来**空间还够开**。

**STEP3**:

肯定对于所有的影响来说，只要其不会形成马吃马，那方案数我们都是可以累加的。

所以只要验证了这一排和上一排以及上上一排是不会形成马吃马，那么我们就可以求出答案。

**STEP4**:

这个验证还是很好想，用三个数组把状态的每一个存下来，先枚举相邻两行，再枚举第一行和第三行（此时撇马腿需要看第二排的情况）。

**STEP5**:

氧化钙！怎么 MLE 了，一看，1 MB。

看来需要滚动数组，这里直接取模 3 即可，注意要赋成 0，不然这个状态就和以前有了矛盾。

# code

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
const int N=1e2+5;
const int mod=1e9+7;
int n,m;
int Fi;
int ans,dp[3][(1<<6)+1][(1<<6)+1];
bool f1[17],f2[17],f3[17];
bool Check_Two(int x,int y){
	mem(f1,0);
	mem(f2,0);
	int Len1=1,Len2=1;
	while(x) f1[Len1]=(x&1),x>>=1,Len1++;
	while(y) f2[Len2]=(y&1),y>>=1,Len2++;
	for(int i=1;i<=m;i++){
		if(f1[i]){
			if(!f1[i+1] && f2[i+2]) return 0;
			if(i!=1) if(!f1[i-1] && f2[i-2]) return 0;
		}
	}
	for(int i=1;i<=m;i++){
		if(f2[i]){
			if(!f2[i+1] && f1[i+2]) return 0;
			if(i!=1) if(!f2[i-1] && f1[i-2]) return 0;
		}
	}
	return 1;
}
bool Check_Three(int x,int y,int z){
	if(!Check_Two(x,y) || !Check_Two(y,z)) return 0;
	mem(f1,0);
	mem(f2,0);
	mem(f3,0);
	int Len1=1,Len2=1,Len3=1;
	while(x) f1[Len1]=x&1,x>>=1,Len1++;
	while(y) f2[Len2]=y&1,y>>=1,Len2++;	
	while(z) f3[Len3]=z&1,z>>=1,Len3++;
	for(int i=1;i<=m;i++){
		if(f1[i] && !f2[i] && (f3[i+1] || f3[i-1])) return 0;
	}
	for(int i=1;i<=m;i++){
		if(f3[i] && !f2[i] && (f1[i+1] || f1[i-1])) return 0;
	}
	return 1;
}
int main(){
	scanf("%d %d",&n,&m);
	Fi=(1<<m)-1;
	for(int i=0;i<=Fi;i++) dp[1][i][0]=1;
	for(int i=2;i<=n;i++){
		for(int j1=0;j1<=Fi;j1++)
			for(int j2=0;j2<=Fi;j2++){
				dp[i%3][j1][j2]=0;
				if(Check_Two(j1,j2)){
					for(int j3=0;j3<=Fi;j3++){
						if(Check_Three(j1,j2,j3)){
							dp[i%3][j1][j2]+=dp[(i-1)%3][j2][j3];
							dp[i%3][j1][j2]%=mod;
						}
					}
				}
			}
	}
	for(int i=0;i<=Fi;i++)
		for(int j=0;j<=Fi;j++){
			ans+=dp[n%3][i][j];
			ans%=mod;
		}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Fa_Nanf1204 (赞：0)

### 分析：
观察到 $Y$ 很小，考虑状压：

$dp_{i,j,k}$ 表示当前第 $i$ 行，当前行为 $j$ 的状态，前一行为 $k$ 的状态此时的方案数。

那么转移过程中如何判定合法就成了一个难点，本人采取了比较朴素的判断方法，跑得还算快，能更好被读者所理解。

首先是两行之间的合法判断：遍历第一行中所有没被别马脚的马，去第二行中判断是否会产生冲突，注意左右马脚都要判。第二行也同理。

然后是三行之间的合法判断：遍历第一行中所有没被第二行别马脚的马，去第三行中判断是否会产生冲突。第三行也同理。

那这样就可以愉快的转移了。

注：本方法适用于 $Y$ 较小的情况，若想学更快更优的，请移步其他题解。
### Code:
```cpp
#include<bits/stdc++.h>
#define M 65
using namespace std;
const int mod=1e9+7;
int n,m,k,dp[4][M][M];//dp[i][j][k]表示当前第i行/当前行j的选择状态/前一行k的选择状态的方案数 
bool check(int x,int y){//检查是否合法 
	int cnt=0;
	while(cnt<m){
		int a=(x>>cnt)&1,b=(x>>(1+cnt))&1,c=(x>>(cnt-1))&1;
		if(a==1 and b==0 and cnt<=m-3){
			if((y>>(cnt+2))&1) return 0;
		}
		if(a==1 and c==0 and cnt>=2){
			if((y>>(cnt-2))&1) return 0;
		}
		cnt++;
	}
	cnt=0;
	while(cnt<m){
		int a=(y>>cnt)&1,b=(y>>(1+cnt))&1,c=(y>>(cnt-1))&1;
		if(a==1 and b==0 and cnt<=m-3){
			if((x>>(cnt+2))&1) return 0;
		}
		if(a==1 and c==0 and cnt>=2){
			if((x>>(cnt-2))&1) return 0;
		}
		cnt++;
	}
	return 1;
}
bool check(int x,int y,int z){//检查是否合法 
	int cnt=0;
	while(cnt<m){
		int a=(x>>cnt)&1,b=(y>>cnt)&1;
		if(a==1 and b==0 and cnt<=m-2){
			if((z>>(cnt+1))&1) return 0;
		}
		if(a==1 and b==0 and cnt>=1){
			if((z>>(cnt-1))&1) return 0;
		}
		cnt++;
	}
	cnt=0;
	while(cnt<m){
		int a=(z>>cnt)&1,b=(y>>cnt)&1;
		if(a==1 and b==0 and cnt<=m-2){
			if((x>>(cnt+1))&1) return 0;
		}
		if(a==1 and b==0 and cnt>=1){
			if((x>>(cnt-1))&1) return 0;
		}
		cnt++;
	}
	return 1;
}
int main(){
	cin>>n>>m;
	for (int i=0;i<(1<<m);i++){
		dp[1][i][0]=1;
	}
	for (int i=0;i<(1<<m);i++){
		for (int j=0;j<(1<<m);j++){
			if(!check(i,j)) continue;
			dp[2][j][i]+=dp[1][i][0];
		}		
	}
	for (int i=3;i<=n;i++){
		for (int p=0;p<(1<<m);p++){
			for (int j=0;j<(1<<m);j++){
				if(!check(p,j)) continue; 
				dp[(i-1)%3+1][j][p]=0;//清零 
			} 
		} 
		for (int j=0;j<(1<<m);j++){
			for (int q=0;q<(1<<m);q++){
				if(!check(q,j)) continue;
				for (int p=0;p<(1<<m);p++){
					if(!check(q,p)) continue;
					if(!check(j,q,p)) continue; 
					dp[(i-1)%3+1][p][q]=(dp[(i-2)%3+1][q][j]+dp[(i-1)%3+1][p][q])%mod;
				} 
			} 
		} 
	}
	long long ret=0;
	for (int i=0;i<(1<<m);i++){
		for (int j=0;j<(1<<m);j++){
			if(!check(i,j)) continue; 
			ret=(ret+dp[(n-1)%3+1][i][j])%mod;
		} 
	} 
	cout<<ret;
    return 0;
}
```

---


# 公主の#18文明游戏

## 题目背景

公主发现了一个游戏，998，于是我就花钱给她买下来了（捂脸）


## 题目描述

这个游戏叫做《文♂明》（滑稽），但是跟平常意义上的不一样。

这个游戏里有n个城市，标号1~n，有m条双向道路相连，编号1~m。

游戏里会系统会添加Ni个人到一个城市Xi，并给定这些人的信仰Ci

系统还会切断一条道路，并给定道路编号Xi

系统还会给定一个城市Xi，询问从Xi出发可以到达的所有城市中选择Ni个人，

使得他们信仰都为Ci的概率为多少，对19260817取模。

输入数据不保证没有重边和自环。

输入数据不保证同一条边不会被切断两次以上。

因为是公主的游戏，所以本题输入量较大，请注意输入的优化


## 说明/提示

吐槽某人居然没告诉我 我没放样例

补发样例（其实我本来有样例来着）

在这里跟大家道歉

对于30%的数据，1<=n,m,q<=100

对于60%的数据，1<=n,m,q<=50000

对于100%的数据，1<=n,m,q<=400000

对于100%的数据，保证所有信仰在C++的int，Pascal的long int范围内

对于100%的数据，保证每次添加的人数和初始人数都不超过10

对于100%的数据，保证数据随机生成

题目 @玫葵之蝶

## 样例 #1

### 输入

```
5 5 5
5 1
9 2
8 1
8 1
6 2
5 2
1 2
2 2
1 1
5 3
1 1 3 2
2 1
3 3 4 1
3 2 3 1
3 1 2 1
```

### 输出

```
9293681
15578602
849742
```

# 题解

## 作者：玫葵之蝶 (赞：12)

## 官方题解

首先我没有卡map，要不然好多人要挂

说一下那个东西怎么算

如果你知道一个连通块内的人的总数n

以及信仰为Ci的人的个数m的话

我们设Ni=k，那么

$ans=\frac{C(m,k)}{C(n,k)}$

然后再用个逆元就好了

（上面这个东西自己理解一下就好了，C为组合数）

然后就是怎么维护这个东西

首先我们发现只有cut没有link，然而link很容易实现

所以我们用一个经典技巧——时间倒流

我们先读入所有操作，遇到cut就标记道路被切断

然后再从后往前处理所有操作就好了

然后那个总人数可以并查集维护一下

另外信仰为Ci的人的个数可以用map启发式合并来记录

时间复杂度$O(nlog^2n)$

然后随机数据下这个东西就可以过了

其实我那个随机数据的限制可以去掉

因为Splay启发式合并的时间复杂度可以证明为$O(nlogn)$

（当然这个合并必须是把大小较小的那个以中序遍历的顺序插入另一个）

然后这个题就完了，很友好对不对？

---

## 作者：ACINE (赞：6)

**这是一道混合了许多知识的有趣的题目!**

------------
## 知识(有所了解就行,不需要特别理解)
### 1.逆元(取模涉及除法，模数是质数)
### 2.组合数(题目需要求概率)
### 3.并查集
### 4.map(或者Splay启发式合并  ~~然鹅我不会~~)
------------
## 题解
**请看出题人的官方题解(~~我主要是来贴代码的~~)**

------------
## 代码($nlogn^2$算法)
代码量较大，涉及知识广，但不是特别复杂,思维难度也就绿题左右,打代码的时候不同功能模块化就可以写的很简单(~~我脑抽了才交了几十次~~),如果出题人把数据加强一点把$nlogn^2$卡掉,只能用$nlogn$做，怕是可以评个紫题
```cpp
//空间一定要开够，不然过不了后面4个点 
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;
const int N=800010;
const LL MOD=19260817;

int n,m,q;
map<int,int>mp[N];

struct OR//链式前向星来保存节点的信息,节约空间 
{
    int nx;
    int ppt,bel;
    OR(){}
    OR(int nx,int ppt,int bel):nx(nx),ppt(ppt),bel(bel){}
}T[N*2];

int fa[N];

int findfa(int a)//并查集启发式合并 
{
    int t1=a,t2;
    while(a!=fa[a]) a=fa[a];
    while(t1!=a) t2=t1,t1=fa[t1],fa[t2]=a;
    return a;
}

int p;
int head[N];

int size[N];

void add(int x,int num,int c)
{
    x=findfa(x);
    size[x]+=num;
    int pos=mp[x][c];
    if(!pos)
    {
        T[++p]=OR(head[x],num,c);
        head[x]=p;mp[x][c]=p;
    }
    else T[pos].ppt+=num;
}

void del(int x,int num,int c)
{
    x=findfa(x);size[x]-=num;
    T[mp[x][c]].ppt-=num;
}

void merge(int a,int b)//合并两个节点,小节点并入大节点,节约时间 
{
    a=findfa(a);b=findfa(b);
    if(a==b) return;
    if(mp[a].size()>mp[b].size()) swap(a,b);
    for(int i=head[a];i;i=T[i].nx)
    add(b,T[i].ppt,T[i].bel);fa[a]=b;
}

struct EDGE
{
    int x,y;
    bool vis;
}E[N];

struct OP
{
    int k;
    int x,y,z;
}H[N];

LL fac[2*N];

LL mul(LL a,LL b)//逆元可以用快速幂求得 
{
    LL ret=1;
    while(b)
    {
        if(b&1) ret=ret*a%MOD;
        b>>=1;a=a*a%MOD;
    }
    return ret;
}

int query(int a,int b,int c)
{
    a=findfa(a);
    int tot=0,tar=0;LL ret=0;
    tot=size[a];tar=T[mp[a][c]].ppt;
    LL t1=fac[tar]*fac[tot-b]%MOD;
    LL t2=fac[tar-b]*fac[tot]%MOD;
    //官方题解的式子配上组合数公式可以推导出答案为:t1/t2 
    ret=t1*mul(t2,MOD-2);//乘以逆元 
    return (ret+MOD)%MOD;
}

int ans[N];

void init()
{
    fac[0]=1;
    for(int i=1;i<4*N;i++)//预处理出阶乘 
    fac[i]=(LL)i*fac[i-1]%MOD;
    for(int i=1;i<N;i++) fa[i]=i;//预处理并查集 
}

int main()
{
    init();
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1,a,b;i<=n;i++)
    {
        scanf("%d%d",&a,&b);
        add(i,a,b);
    }
    for(int i=1;i<=m;i++)
    scanf("%d%d",&E[i].x,&E[i].y);
    for(int i=1;i<=q;i++)//保存操作，离线处理 
    {
        scanf("%d",&H[i].k);
        if(H[i].k==1)
        {
            scanf("%d%d%d",&H[i].x,&H[i].y,&H[i].z);
            add(H[i].x,H[i].y,H[i].z);
        }
        if(H[i].k==2)
        {
            scanf("%d",&H[i].x);
            E[H[i].x].vis=1;
        }
        if(H[i].k==3) scanf("%d%d%d",&H[i].x,&H[i].y,&H[i].z);
    }
    for(int i=1;i<=m;i++)
    if(!E[i].vis) merge(E[i].x,E[i].y);
    for(int i=q;i>=1;i--)
    {
        if(H[i].k==1) del(H[i].x,H[i].y,H[i].z);//倒着做，加值变为删值 
        if(H[i].k==2) merge(E[H[i].x].x,E[H[i].x].y);//删边变为加边 
        if(H[i].k==3) ans[i]=query(H[i].x,H[i].y,H[i].z);//询问 
    }
    for(int i=1;i<=q;i++)
    if(H[i].k==3) printf("%d\n",ans[i]);//输出 
    return 0;
}
```
------------
##### 吐槽
~~出题人发个题解连个代码都不带的，又没有数据，搞得我手动调了半天，交了几十遍(不夸张)，最后发现某个变量打错了。。。这题真友好...~~



---

## 作者：yzxoi (赞：1)

[$$\large{\texttt{My Blog}}$$](https://yzxoi.top/archives/1325)
## Describe
> [题目链接](https://www.luogu.com.cn/problem/P4255)

这个游戏里有n个城市，标号1~n，有m条双向道路相连，编号1~m。

游戏里会系统会添加Ni个人到一个城市Xi，并给定这些人的信仰Ci

系统还会切断一条道路，并给定道路编号Xi

系统还会给定一个城市Xi，询问从Xi出发可以到达的所有城市中选择Ni个人，使得他们信仰都为Ci的概率为多少，对19260817取模。

## Solution
首先用并查集搞成各个连通块，然后每个连通块用个$map$储存信仰为$Ci$的个数。再开一个$vector$储存每个连通块有哪些信仰。

那么每次答案就可以求出信仰为$Ci$的人数$C$和连通块总人数$A$。

那么答案就是$ans=\frac{C_C^Ni}{C_A^Ni}$。

那么用快速幂逆元一下就好了。

维护的时候可以用$vector$的$find,erase$和并查集启发式合并即可。

技巧：由于断边比较困难，所以时间倒流，断边变成连边，加值变成减值。

## Code
```cpp
#include<bits/stdc++.h>
#define LL long long
#define mod 19260817
using namespace std;
inline int read(){
	int res=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
	return res*f;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else write(x/10),putchar(x%10+'0');
}
int n,m,q,fa[400010],vis[400010],A,C,ans[400010],Z[400010];
LL fac[400010*4];
inline LL fpow(LL a,LL b){// 快速幂，求逆元
	LL s=1;
	while(b){
		if(b&1) s*=a,s%=mod;
		a*=a;a%=mod;
		b>>=1;
	}
	return s;
}
struct Edge{
	int x,y;
}E[400010];
struct Question{
	int op,x,y,z;
}Q[400010];
map<int,int> v[400010];
vector<int> g[400010];
inline int getfa(int x){// 并查集启发式合并
	int a=x,y;
	while(x!=fa[x]) x=fa[x];
	while(a!=x) y=a,a=fa[a],fa[y]=x; 
	return x;
}
inline void merge(int x,int y){
	x=getfa(x);y=getfa(y);
	if(x==y) return ;
	if(v[x].size()<v[y].size()) swap(x,y);// 选择小的合并到大的
	fa[y]=x;Z[x]+=Z[y];
	for(int i:g[y]){// 暴力遍历合并
		if(v[x][i]==0&&v[y][i]!=0) g[x].push_back(i);
		v[x][i]+=v[y][i];
	}
	Z[y]=0;// 清空
	v[y].clear();
	g[y].clear();
}
int main(){
	n=read(),m=read(),q=read(); 
	fac[0]=1;
	for(int i=1;i<=4*400000;i++){
		fac[i]=(LL)fac[i-1]*i%mod;// 预处理阶乘
	}
	for(int x,y,i=1;i<=n;i++){
		x=read();y=read();
		fa[i]=i;
		v[i].clear();
		g[i].clear();
		g[i].push_back(y);
		v[i][y]+=x;
		Z[i]=x;
	}
	for(int i=1;i<=m;i++){
		E[i].x=read(),E[i].y=read();
	}
	for(int i=1;i<=q;i++){// 先记录再倒序做
		Q[i].op=read();
		if(Q[i].op==1){
			Q[i].x=read(),Q[i].y=read(),Q[i].z=read();
			if(v[Q[i].x][Q[i].z]==0) g[Q[i].x].push_back(Q[i].z);
			v[Q[i].x][Q[i].z]+=Q[i].y;
			Z[Q[i].x]+=Q[i].y;
		}else if(Q[i].op==2){
			Q[i].x=read();
			vis[Q[i].x]=1;
		}else if(Q[i].op==3){
			Q[i].x=read(),Q[i].y=read(),Q[i].z=read();
		}
	}
	for(int i=1;i<=m;i++){// 先连不需要删除的边
		if(vis[i]==0) merge(E[i].x,E[i].y);
	}
	for(int i=q;i>=1;i--){
		if(Q[i].op==1){
			Q[i].x=getfa(Q[i].x);
			v[Q[i].x][Q[i].z]-=Q[i].y;// 减值
			Z[Q[i].x]-=Q[i].y;
			if(v[Q[i].x][Q[i].z]==0) g[Q[i].x].erase(find(g[Q[i].x].begin(),g[Q[i].x].end(),Q[i].z));// 如果这删完以后是 0 记得删 vector，否则会重复合并
		}else if(Q[i].op==2){
			merge(E[Q[i].x].x,E[Q[i].x].y);// 连边
		}else if(Q[i].op==3){
			Q[i].x=getfa(Q[i].x);
			A=C=0;A=Z[Q[i].x];C=v[Q[i].x][Q[i].z];
			LL tmp1=fac[C]*fac[A-Q[i].y]%mod;
			LL tmp2=fac[A]*fac[C-Q[i].y]%mod;
			tmp2=fpow(tmp2,mod-2);// 求逆元
			LL res=tmp1*tmp2;
			res+=mod;res%=mod;
			ans[i]=res;
		}
	}
	for(int i=1;i<=q;i++)
		if(Q[i].op==3) write(ans[i]),putchar('\n');
} 
```

---

## 作者：zzyiqa (赞：1)

[原题戳这里](https://www.luogu.com.cn/problem/P4255)

~~这道题因为数组太大一直 MLE，结果改下数组就 AC 了。~~

# 思路：

我们考虑删边操作过于困难，所以正难则反，从最后时光倒流，也就是从后往前考虑，也就是提前把要删的边都提前删掉，遇见本来的删除操作就再将其加回去，把删边操作改为加边操作。当然，我们需要先把要加的人全部先加上，遇见再减去。同时考虑统计答案，设当前连通块共有 $s$ 个人，而信仰为 $c_i$ 的人有 $x$ 个，易得答案 $ans=\frac{C_{n_i}^x}{C_{n_i}^s}$。提前预处理出求随机数要用的阶乘，然后直接在加边操作中用 map 维护一下并查集即可。

# 时间复杂度：

不难发现是 $O(n \log^2q)$ 的。

# AC Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ma make_pair
#define fi first
#define se second
using namespace std;
const ll N=4e5+5,mod=19260817,T=1e6+5;
ll n,m,q,jc[T]={1},fa[N],size[N],bo[N];
struct Data {ll op,a,b,c;}qu[N];
pair<ll,ll>went[N];
stack<ll>ans;
vector<pair<ll,ll> >v[N];
map<ll,ll>mp[N];
ll power(ll a,ll b){
	ll ans=1;
	for(;b!=0;b>>=1,a=a*a%mod) if((b&1)!=0) ans=ans*a%mod;
	return ans;
}
void move(ll fx,ll fy){//并查集维护 
	for(auto i=mp[fx].begin();i!=mp[fx].end();i++){
		pair<ll,ll> now=*i;
		ll xx=now.first,xy=now.second;
		pair<ll,ll> Now=*mp[fy].find(xx);
		ll yy=Now.se;
		if(mp[fy].find(xx)==mp[fy].end()) mp[fy].insert(ma(xx,xy));
		else {mp[fy].erase(xx); mp[fy].insert(ma(xx,xy+yy));}
	}
	mp[fx].clear();
}
void bcj(ll fx,ll fy){//启发式合并 
	if(size[fx]<size[fy]) {move(fx,fy);fa[fx]=fy,size[fy]+=size[fx],size[fx]=0;}
	else {move(fy,fx);fa[fy]=fx,size[fx]+=size[fy],size[fy]=0;}
}
ll find(ll x){//寻找并查集板子 
	if(fa[x]==x) return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
ll zhs(ll n,ll m){//组合数 
	return jc[n]*power(jc[m],mod-2)%mod*power(jc[n-m],mod-2)%mod;
}
signed main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>m>>q;
	for(ll i=1,x,y;i<=n;i++) {cin>>x>>y;size[i]+=x;mp[i][y]+=x;}
	for(ll i=1;i<=T-5;i++) jc[i]=(jc[i-1]*i)%mod;
	for(ll i=1;i<=n;i++) fa[i]=i;
	for(ll i=1;i<=m;i++) cin>>went[i].fi>>went[i].se;
	for(ll i=1;i<=q;i++){
		cin>>qu[i].op;
		if(qu[i].op==1) cin>>qu[i].a>>qu[i].b>>qu[i].c,mp[qu[i].a][qu[i].c]+=qu[i].b,size[qu[i].a]+=qu[i].b;//提前把要加的都加上 
		if(qu[i].op==2) cin>>qu[i].a,bo[qu[i].a]++;//考虑可能删多次一条边，所以当且仅当删除的次数与加回的次数之和为 0 时，才加上这条边 
		if(qu[i].op==3) cin>>qu[i].a>>qu[i].b>>qu[i].c;
	}
	for(ll i=1;i<=m;i++)
		if(bo[i]==0){//没有被删的边才建 
			ll x=went[i].fi,y=went[i].se;
			ll fx=find(x),fy=find(y);
			if(fx==fy) continue;
			bcj(fx,fy);
		}
	for(ll i=q;i>=1;i--){//倒序处理，但是要记得输出得是倒序的倒序 
		if(qu[i].op==1){//把之前加上的人数减回去 
			ll fx=find(qu[i].a);
			mp[fx][qu[i].c]-=qu[i].b,size[fx]-=qu[i].b;
		}
		if(qu[i].op==2){
			bo[qu[i].a]--;
			ll x=went[qu[i].a].fi,y=went[qu[i].a].se;
			if(bo[qu[i].a]==0){//把被删的边加回来 
				ll fx=find(x),fy=find(y);
				if(fx==fy) continue;
				bcj(fx,fy);
			}
		}
		if(qu[i].op==3){
			ll fx=find(qu[i].a),sum=size[fx],mb=mp[fx][qu[i].c];
			if(mb<qu[i].b || sum<qu[i].b) ans.push(0);//若两者连选都选不够，那当然结果是 0 
			else ans.push((zhs(mb,qu[i].b)*power(zhs(sum,qu[i].b),mod-2))%mod);//统计答案 
		}
	}
	while(ans.empty()==false){//因为是倒序输出，所以用栈来维护正好 
		cout<<ans.top()<<"\n";
		ans.pop();
	}
	return 0;//完美的结束
}
```

完结散花~

---

## 作者：White__Deer (赞：1)

挺杂乱的一道题。。。。

# 前置芝士
- 并查集
- map（迭代器也要会用）
- 组合
- 逆元

# 思路
这道题只涉及删边，所以我们可以将 $q$ 个查询离线，倒过来使用并查集维护加边。

对于 $op=3$ 时，考虑答案为多少。设与当前节点联通的所有人的个数为 $s$，信仰为 $c_i$ 的人的个数为 $y$，不难推出答案为 $\dfrac{\binom{y}{N_i}}{\binom{s}{N_i}} $，使用逆元与组合数求解即可。

注意，在倒着求解时，同一编号（注意是同一编号！不是边所连端点相同的边！）的边可能会被切两次，此时倒着求解的话则是在最后一次出现这条边时添加。

并查集可以使用 map 维护，时间复杂度 $O(n\log^2{q})$，可以通过此题。

# code：
```cpp
#include<bits/stdc++.h>
#include<queue>
#define endl "\n"
#define ll long long
#define db double
#define ft first
#define sd second
#define pb push_back
#define mp make_pair
#define pe(j) (1<<(j))
#define foe(n) for(int i=1;i<=n;i++)
using namespace std;
inline void write(ll x);
inline ll read();
const ll N=1e6+1,mod=19260817;
ll n,m,ans[N],T;
ll a[N],f[N],sx[N];
map<ll,ll> sz[N];
struct dat{
	ll op,x,y,z;
}q[N];
vector<pair<int,int> > bs;
int v[N];
int cnt;
void dy(ll fy,ll fx){
	for(auto i=sz[fx].begin();i!=sz[fx].end();i++){
		pair<int,int> p=*i;
		auto cc=sz[fy].find(p.ft);
		if(cc==sz[fy].end())sz[fy].insert((*i));
		else {
			pair<int,int> pp=*cc;
			sz[fy].erase(p.ft);
			sz[fy].insert(mp(p.ft,pp.sd+p.sd));
		}
	}sz[fx].clear();
	sx[fy]+=sx[fx];sx[fx]=0;
}
ll find(ll x){
	if(f[x]==x)return x;
	f[x]=find(f[x]);
	dy(f[x],x);
	return f[x];
}
ll jc[N];

ll power(ll x,ll y,ll p){
	ll ans=1;
	for(;y;y>>=1,x=(x*x)%p)if(y&1)ans=(ans*x)%p;
	return ans;
}
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){x=1;y=0;return a;}
	ll ggcd=exgcd(b,a%b,x,y);
	ll d=x;x=y;y=d-(a/b)*y;
	return ggcd;
}
ll ny(ll cc,ll p){
	ll x,y;
	if(exgcd(cc,p,x,y)!=1)return -1;
	return (x%p+p)%p;
}
ll C(ll n,ll m){
	ll ans=jc[n];
	ans=(ans*ny((jc[n-m]*jc[m])%mod,mod))%mod;
	return ans;
}
int main(){
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	n=read();m=read();T=read();
	jc[0]=1;
	for(int i=1;i<N;i++)jc[i]=(jc[i-1]*i)%mod;
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1,t,y;i<=n;i++){
		t=read();y=read();
		sz[i][y]+=t;
		sx[i]+=t;
	}
	bs.pb(mp(0,0));
	for(int i=1,u,v;i<=m;i++){
		u=read();v=read();
		bs.pb(mp(u,v));
	}
	for(int i=1;i<=T;i++){
		ll op,x,y,z;
		op=read();
		if(op==1){
			x=read();y=read();z=read();
			q[i]={op,x,y,z};
			sz[x][z]+=y;
			sx[x]+=y;
		}
		else if(op==2){
			x=read();
			q[i]={op,x,0,0};
			v[x]++;
		}
		else{
			x=read();y=read();z=read();
			q[i]={op,x,y,z};
		}
	}
	for(int i=1;i<=m;i++)
		if(!v[i]){
			ll u=bs[i].ft,v=bs[i].sd;
			ll fx=find(u),fy=find(v);
			if(fx==fy)continue;
			if(sx[fy]>sx[fx])dy(fy,fx),f[fx]=fy;
			else dy(fx,fy),f[fy]=fx;
		}
	for(int i=T;i>=1;i--){
		if(q[i].op==1){
			ll c=q[i].x,fx=find(c);
			sz[fx][q[i].z]-=q[i].y;
			sx[fx]-=q[i].y;
		}
		else if(q[i].op==2){
			v[q[i].x]--;
			if(!v[q[i].x]){
				ll u=bs[q[i].x].ft,v=bs[q[i].x].sd;
				ll fx=find(u),fy=find(v);
				if(fx==fy)continue;
				if(sx[fy]>sx[fx])dy(fy,fx),f[fx]=fy;
				else dy(fx,fy),f[fy]=fx;
			}
		}
		else{
			ll fx=find(q[i].x),su=sx[fx],ys=sz[fx][q[i].z];
			ll c=q[i].y;
			if(ys<c||su<c)ans[++cnt]=0;
			else ans[++cnt]=C(ys,c)*ny(C(su,c),mod),ans[cnt]%=mod;
		}
	}
	for(int i=cnt;i>=1;i--)write(ans[i]),puts("");
	return 0;
}

//------------------------------------------------------------------------------------------
//read&write
inline ll read(){
    ll x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch-'0');ch=getchar();}
    return x*w;
}
inline void write(ll x){
  static ll sta[35];
  ll top=0;
  do{sta[top++] = x % 10, x /= 10;}while (x);
  while(top) putchar(sta[--top]+48);
}
```

---

## 作者：封禁用户 (赞：0)

## 题意简述
有 $n$ 个城市，有 $m$ 条双向道路相连。

1. 系统会添加 $N_i$ 个人到一个城市 $X_i$，并给定这些人的信仰 $C_i$。

2. 系统会切断一条道路，并给定道路编号 $X_i$。

3. 系统会给定一个城市 $X_i$，询问从 $X_i$ 出发可以到达的所有城市中选择 $N_i$ 个人，使得他们信仰都为 $C_i$ 的概率为多少，对 $19260817$ 取模。

4. 系统给定的城市是随机的。

## 题解思路
本题主要考察**并查集**和**快速幂**。

其中并查集转为连通块后在连通块里存储信仰的个数，这样，存储的问题就基本解决了。

这时候我们就可以用 vector 的常见操作来维护并查集，保证代码能正常运转。

同时，我们可以轻松推到出本体的结果 $ans = \frac {C_C^Ni} {C_A^Ni}$。其中，$C$ 为信仰 $C_i$ 的人数，$A$ 连通块中的总人数。

## 代码

### 方法一

[代码](https://www.luogu.com.cn/paste/lym8eklp)

### 方法二

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<cmath>
#include<map>
#include<algorithm>
using namespace std;
const int MAXN=500005;
const int mod=19260817;
map<int,int> ma[MAXN];
int n,m,q,cnt;
struct nodes{
	int opt,x,y,z;
}h[MAXN];
struct node{
	int na,next,kind;
}edge[MAXN<<1];
struct Edge{
	int x,y;
	bool fl;
}galaxy[MAXN];
int head[MAXN],fa[MAXN],sum[MAXN],ans[MAXN];
void add_edge(int x,int na,int kind)
{
	edge[++cnt].na=na;
	edge[cnt].kind=kind;
	edge[cnt].next=head[x];
	head[x]=cnt;
}
int find(int son)
{
	if(son!=fa[son])fa[son]=find(fa[son]);
	return fa[son];
}
void add(int x,int na,int kind)
{
	x=find(x);
	sum[x]+=na;
	int pos=ma[x][kind];
	if(!pos)
	{
		add_edge(x,na,kind);
		ma[x][kind]=cnt;
	}
	else edge[pos].na+=na;
}
void merge(int a,int b)
{
	a=find(a),b=find(b);
	if(a==b)return; 
	if(sum[a]>sum[b])swap(a,b);
	for(int i=head[a];i;i=edge[i].next)add(b,edge[i].na,edge[i].kind);
	fa[a]=b;
}
int query(int x,int y,int z)
{
	x=find(x);
	int tot,tar;
	tot=edge[ma[x][z]].na;
	tar=sum[x];
	if(y>tot)return 0;
	long long up=1,down=1,base,downs=1,p=mod-2;
	for(int i=1;i<=y;i++,tot--,tar--)
	{
		up=up*tot%mod;
		down=down*tar%mod;
	}
	base=down;
	while(p)
	{
		if(p&1)downs=downs*base%mod;
		base=base*base%mod;
		p>>=1;
	}
	return up*downs%mod;
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1,x,y;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		add(i,x,y);
	}
	for(int i=1;i<=m;i++)scanf("%d%d",&galaxy[i].x,&galaxy[i].y);
	for(int i=1;i<=q;i++)
	{
		scanf("%d%d",&h[i].opt,&h[i].x);
		if(h[i].opt!=2)
		{
			scanf("%d%d",&h[i].y,&h[i].z);
			if(h[i].opt==1)add(h[i].x,h[i].y,h[i].z);
		}
		else galaxy[h[i].x].fl=true;
	}
	for(int i=1;i<=m;i++)if(!galaxy[i].fl)merge(galaxy[i].x,galaxy[i].y);
	for(int i=q;i>0;i--)
	{
		if(h[i].opt==1)add(h[i].x,-h[i].y,h[i].z);
		else if(h[i].opt==2)merge(galaxy[h[i].x].x,galaxy[h[i].x].y);
		else ans[i]=query(h[i].x,h[i].y,h[i].z);
	}
	for(int i=1;i<=q;i++)if(h[i].opt==3)cout<<ans[i]<<endl;
	return 0;
}
```


以上的两个代码其实原理上是一样的，只是写法有一定不同。

---


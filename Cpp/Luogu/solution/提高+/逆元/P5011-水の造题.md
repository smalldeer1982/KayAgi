# 水の造题

## 题目背景

第一分钟,$CYJian$说:"要有样子."于是便有了$k$种动作..

第二分钟,$CYJian$说:"要有活力."于是便有了$k$种动作组成的总动作数为$N$的搏击操.

第三分钟,$CYJian$说:"要有数学."于是便有了一套搏击操的威力.

第四分钟,$CYJian$说:"数字要小."于是便有了一个伟大的模数$19491001$.

第五分钟,$CYJian$说:"要有规律."于是便有了一套搏击操威力的计算方法.

第六分钟,$CYJian$说:"要有限制."于是便有了时空限制以及数据范围.

第七分钟,$CYJian$说:"要有答案."于是便有了这道题让你做掉.

...

第*分钟,巨佬$Imagine$说:"数据太水."于是蒟蒻出题人疯了..(详见数据范围)

## 题目描述

现在有一套由$k$种动作组成的动作总数为$N$的搏击操.

已知第$1$,$2$...$k$个动作的威力为$a[1...k]$

且如果第一个动作后紧接着第二个动作,则威力会额外加上$a[1]+a[2]$

如果第二个动作后紧接着第三个动作,则威力会额外加上$a[2]+a[3]$

...

如果第$k$个动作后紧接着第一个动作,则威力会额外加上$a[k]+a[1]$

请求出最后动作的期望威力..

当然,还是要用伟大的模数$19491001$来膜一膜的...

## 说明/提示

样例解释：

```
x-y 表示第一个动作为x，第二个动作为y

1-1 : 1+1=2
1-2 : 1+2+(1+2)=6
1-3 : 1+3=4
1-4 : 1+4=5
1-5 : 1+5=6
1-6 : 1+6=7
2-1 : 2+1=3
2-2 : 2+2=4
2-3 : 2+3+(2+3)=10
2-4 : 2+4=6
2-5 : 2+5=7
2-6 : 2+6=8
3-1 : 3+1=4
3-2 : 3+2=5
3-3 : 3+3=6
3-4 : 3+4+(3+4)=14
3-5 : 3+5=8
3-6 : 3+6=9
4-1 : 4+1=5
4-2 : 4+2=6
4-3 : 4+3=7
4-4 : 4+4=8
4-5 : 4+5+(4+5)=18
4-6 : 4+6=10
5-1 : 5+1=6
5-2 : 5+2=7
5-3 : 5+3=8
5-4 : 5+4=9
5-5 : 5+5=10
5-6 : 5+6+(5+6)=22
6-1 : 6+1+(6+1)=14
6-2 : 6+2=8
6-3 : 6+3=9
6-4 : 6+4=10
6-5 : 6+5=11
6-6 : 6+6=12

2+6+4+5+6+7+3+4+10+6+7+8+4+5+6+14+8+9+5+6+7+8+18+10+6+7+8+9+10+22+14+8+9+10+11+12=294

294/36=49/6

1/6 = 16242501 (mod 19491001)

ans = 49 * 16242501 mod 19491001 = 16242509
```

$Subtask 1$($20 pts$):$1 \leq N \leq 10 \qquad 1 \leq k \leq 7$ 

$Subtask 2$($20 pts$):$1 \leq N \leq 10^6 \qquad 1 \leq k \leq 7$ 

$Subtask 3$($20 pts$):$1 \leq N \leq 10^{40000} \qquad 1 \leq k \leq 7$ 

$Subtask 4$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 7$ 

$Subtask 5$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 10^6$ 

保证所有的数据: $1 \leq a[i] \leq 10^7$

## 注意:本题捆绑测试

小提示：

可以用下面的inv(x)求出x的逆元：

```
long long mod = 19491001;

long long quick_pow(long long x, int k) {
    long long res = 1;
    while(k) {
        if(k & 1) res = res * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return res;
}

long long inv(long long x) {
    return quick_pow(x, mod - 2);
}
```

## 样例 #1

### 输入

```
2
6
1 2 3 4 5 6
```

### 输出

```
16242509
```

# 题解

## 作者：diltraser (赞：8)


很显然每个数在求和时出现的次数相等，设$d[i]$为动作总数为$i$个时某个数求和时的贡献，则
#### $ans=d[n]*sum/k^n( mod $ $19491001)$
试图递推$d[n]$，首先放式子
#### $d[i]=k^{i-1}+2*k^{i-2}+d[i-1]*k$
第一项$k^{i-1}$表示动作总数为$i$时排列数量，在之后可以放$x$使计数++；

第二项$2*k^{i-2}$表示排列中以$x$/$x-1$结尾的数量，在此之后会产生组合技效果；

第三项$d[i-1]*k$表示排列前$i-1$位中$x$的贡献；

然后经过~~找规律~~归纳推理，可得
#### $d[n]=n*k^{n-1}+2*(n-1)*k^{n-2}$
代入进$ans$中，得
#### $ans=sum*(n*k+2*(n-1))/k^2$
求出$sum$%$mod$,$k$的逆元,$n$%$mod$即可AC
## Code
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype> 
using namespace std;
typedef long long ll;
ll mod = 19491001;
int n;
char s[1000010];
int len; 
ll N; 
ll k;
ll tot;


ll quick_pow(ll x, int k) {
    ll res = 1;
    while(k) {
        if(k & 1) res = res * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return res;
}

ll inv(long long x) {
    return quick_pow(x, mod - 2);
}

 
int main(){
    char ch=getchar();
    while(isdigit(ch)){
        s[++len]=ch;
        N=(10*N+ch-'0')%mod;
        ch=getchar();
    }
    scanf("%lld",&k);
    int i,val;
    for(i=1;i<=k;i++){
        scanf("%d",&val);
        tot=(tot+val)%mod;
    }
    ll invk=inv(k);
    printf("%d",(N*k%mod+2*N-2)%mod*tot%mod*invk%mod*invk%mod);
    return 0;
}
```

---

## 作者：Imakf (赞：5)

根据**期望的线性性**可得：我们可以直接计算每一种组合的期望然后加起来。

显然，在位置 $i,i+1$ 出现两个编号连续的动作的概率就是 $\dfrac{1}{k^2}$。因为两个事件独立。

所以对于某一种动作组合出现的期望次数就是 $\dfrac{n}{k^2}$。

所以动作组合的贡献就是 $\dfrac{2(n-1)}{k^2}\sum a_i$。

----

每一种动作单独的贡献就更简单了。显然在某个位置出现 $i$ 号动作的概率是 $\dfrac{1}{k}$。

所以出现的期望次数就是 $\dfrac{n}{k}$。

所以动作单独的贡献就是 $\dfrac{n}{k}\sum a_i$。

----

于是把两种贡献都加起来就好啦。

$n$ 那么大，直接读入的时候取模就好啦！

代码也很简单～

无限 orz 出题人 CYJian！

```cpp
#include <bits/stdc++.h>

#define LL long long

int read(int MOD = INT_MAX){
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9') x = (x * 10 + k - '0') % MOD ,k = getchar();
	return x;
}

LL n ,k;
const int MX = 1e6 + 23;
const LL MOD = 19491001;

LL qpow(LL a ,LL b ,LL p = MOD){
	LL Ans = 1 % p;
	while(b){if(b & 1) Ans = Ans * a % p;
		a = a * a % p ,b >>= 1;
	}return Ans;
}

int main(){
	n = read(MOD) ,k = read();
	LL sum = 0;
	for(int i = 1 ; i <= k ; ++i){
		sum = (sum + read()) % MOD;
	}

	LL t = (n - 1 + MOD) * qpow(k * k % MOD ,MOD - 2) % MOD;
	
	LL ivk = qpow(k ,MOD - 2);
	
	LL Ans = sum * t % MOD * 2 % MOD;
	Ans = (Ans + ivk * n % MOD * sum) % MOD;

	// fprintf(stderr ,"%lld\n" ,Ans * qpow(k ,n) % MOD);

	printf("%lld\n" ,Ans);
	return 0;
}
```

---

## 作者：lgswdn_SA (赞：4)

提供一种不同的但更加显然不用动脑的方法。

首先考虑一眼的 DP。我们设 $f_i$ 表示前 $i$ 步的取值。（设 $j$ 前面那个元素就是 $a_{j-1}$ 了，$j=1$ 时自动代成 $k$）

$$
\begin{aligned}
f_i&=f_{i-1}+\sum_{j=1}^{k}\frac{a_j+\frac{a_j+a_{j-1}}{k}}{k}\\
&=f_{i-1}+\frac{(\sum a)+\frac{2\sum a}{k}}{k}\\
&=f_{i-1}+\frac{(k+2)\sum a}{k^2}
\end{aligned}
$$

我们有首项 $f_1=\frac{\sum a}{k}$，于是有答案

$$
\begin{aligned}
f_n &= f_{1} + (n-1)\times \frac{(k+2)\sum a}{k^2}\\
&= \frac{k+(n-1)(k+2)}{k^2} \sum a\\
&= \frac{nk+2n-2}{k^2} \sum a
\end{aligned}
$$

---

## 作者：TimeTraveller (赞：3)

### 题目地址与题意[见链接](https://www.luogu.org/problemnew/show/P5011)

---

暴力就是$O(k^n)$吧，不过$n$非常之大，有$10^{10^6}$（高精可怕.jpg）

但是我们发现，对于求期望，那么就是概率$\times$权值，所以我们可以先求出每种动作的贡献：

>每种动作出现在某个位置的概率为$\frac{1}{k}$，贡献为它的$val$，总共有$n$个可以出现的位置，所以贡献为$\sum_{i=0}^{k-1}\frac{n\times val_i}{k}$

接下来就是组合技的多的贡献，每个组合技还会再贡献一次，所以我们这样来看：

>每个组合技出现的概率为$\frac{1}{k^2}$，有$n-1$个可以出现的位置，每一种的贡献为$val_i+val_{(i+1)\%k}$，所以总贡献为$\sum_{i=0}^{k-1}\frac{(n-1)\times (val_i+val_{(i+1)\%k})}{k^2}$

那么我们$O(k)$的算一下就好啦，关于取模除法我们用费马小定理逆元就可以了，因为$19491001$是个~~非常神奇且有巨大意义的~~质数，读入$n$时直接取模就好啦。

代码：

~~~cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int M=1e6+10;
const ll Mod=19491001;
char s[M];
ll k,A[M],n,w;
ll inv_k,inv_k2;
void readin(){
	scanf("%s",s);
	int len=strlen(s);
	for(int i=0;i<len;i++){
		n=(n*10ll%Mod+(s[i]&15))%Mod;
	}	w=(n-1+Mod)%Mod;
}
ll Sqr(ll a){return a*a%Mod;}
ll fpow(ll a,ll b){
	ll ans=1;
	for(;b;b>>=1,a=(a*a)%Mod)if(b&1)ans=(ans*a)%Mod;
	return ans;
}
ll ans,sum1,sum2;
int main(){
	readin();
	scanf("%lld",&k);
	for(int i=0;i<k;i++){
		scanf("%lld",&A[i]);
		sum1=(sum1+A[i])%Mod;
		if(i)sum2=(sum2+(A[i-1]+A[i])%Mod)%Mod;
	}	sum2=(sum2+(A[0]+A[k-1])%Mod)%Mod;
	inv_k=fpow(k,Mod-2);
	inv_k2=(Sqr(inv_k)%Mod*w)%Mod;inv_k=(inv_k*n)%Mod;
	ans=(sum1*inv_k%Mod+sum2*inv_k2%Mod)%Mod;
	printf("%lld\n",ans);
	return 0;
}
~~~

下面还有一种解法，由$\rm hdxrie$|Orz|提供：

我们先不考虑开头结尾，那么每个数都有前后：

我们考虑，对于一个位置的动作，它前后都不是组合技，那么只会贡献一次，那么前面不是和它组合的概率为$\frac{k-1}{k}$，后面不是和它组合的概率为$\frac{k-1}{k}$，然后当前选这个的概率为$\frac{1}{k}$，有$n-2$个位置可以这样选，那么贡献为$(\frac{k-1}{k})^2\times \frac{1}{k}\times val_i\times (n-2)$

对于可以形成组合技的（这里只考虑组成一个），那么就是后面和它组合，前面不组合；或者前面组合，后面不组合。那么贡献就为$\left(\frac{k-1}{k}\times \left(\frac{1}{k}\right)^2\times val_i\times 2\times (n-2)\right)\times 2$（这时$val_i$要算两次贡献，同样还是有$n-2$个可以的位置）

对于前后都可以组合的，概率为$\left(\frac{1}{k}\right)^3$，所以贡献为$\left(\frac{1}{k}\right)^3\times val_i\times 3\times (n-2)$（这里要算前后三次）

然后对于开始和结尾两个单独的，我们考虑组不组合，那么组合贡献为$\frac{1}{k}\times \frac{1}{k}\times val_i\times 2$，不组合的为$\frac{1}{k}\times \frac{k-1}{k}\times val_i\times 2$，前后一样所以$×2$。

下面上代码

~~~cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define LL long long
using namespace std;
const int N=1000010;
const LL mod=19491001;
char num[N];int len;
LL n,m,inv1,inv2,inv3,val,ans,sum;
LL power(LL a,LL p)
{
    LL v=1;
    for(;p;p>>=1,a=a*a%mod)
     if(p&1)v=v*a%mod;
    return v;
}
int main()
{
    scanf("%s%lld",num+1,&m);
    len=strlen(num+1);inv1=power(m,mod-2);
    inv2=inv1*inv1%mod;inv3=inv2*inv1%mod;
    for(int i=1;i<=len;i++)
     n=(n*10+num[i]-'0')%mod;
    for(int i=1;i<=m;i++)
     scanf("%lld",&val),(sum+=val)%=mod;
    (ans+=2ll*sum%mod*(m-1)%mod*inv2%mod)%=mod;
    (ans+=4ll*sum%mod*inv2%mod)%=mod;
    (ans+=(n-2)*sum%mod*(m*m%mod-2*m+1)%mod*inv3%mod)%=mod;
    (ans+=4ll*(n-2)%mod*sum%mod*(m-1)%mod*inv3%mod)%=mod;
    (ans+=3ll*(n-2)%mod*sum%mod*inv3%mod)%=mod;
    if(ans<0)ans+=mod;printf("%lld\n",ans);
    return 0;
}
~~~

---

## End~

---

## 作者：JPGOJCZX (赞：1)

节选自：[DP做题记录（三）（2025.4.5 - 2025.4.19）](https://www.luogu.com.cn/article/tobtmxka)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18841186)。

其实这道题目的样例解释已经把如何统计答案讲解的差不多了。

我们考虑 DP，设 $dp_{i, j}$ 表示这是第 $i$ 个动作，且第 $i$ 个动作是 $j$ 的期望。根据样例解释，我们可以先将期望改写成总和，那么 $dp_{i, j}$ 的含义就变成了这是第 $i$ 个动作，且第 $i$ 个动作是 $j$ 的威力和。我们再设 $ans_i$ 表示填完前 $i$ 个数的威力和，显然 $ans_i = \displaystyle\sum dp_{i, j}$，而答案就是 $\displaystyle\frac{1}{k^n} ans_n$。

我们枚举前一个字符 $c$ 是什么，如果 $c$ 不等于 $j - 1$（当然 $c = k$ 时是 $1$），那么直接加上当前的威力值即可，因此 $dp_{i, j}$ 首先要加上一个 $\displaystyle\sum_{c \neq j - 1} dp_{i - 1, c} + a_j$。

下面来考虑威力值的加成，那么前一个填的数字必须是 $j - 1$，那么 $dp_{i, j}$ 还要加上一个 $dp_{i - 1, j - 1} + 2 a_j + a_{j - 1}$，那么总的转移方程就是 $dp_{i, j} = \displaystyle\sum_{c \neq j - 1} (dp_{i - 1, c} + a_j) + dp_{i - 1, j - 1} + 2a_j + a_{j - 1} = \sum_c dp_{i - 1, c} + k a_j + a_j + a_{j - 1} = ans_{i - 1} + k a_j + a_j + a_{j - 1}$，那么 $ans_i = k \times ans_{i - 1} + (2 + k) \times sum$（$sum$ 为 $a_1, a_2, \dots, a_k$ 之和），根据等比数列求和公式，$ans_n$ 最终等于 $sum \times [n k^{n - 1} + (2n - 2) k^{n - 2}]$，除以 $k^n$ 后就得到了答案 $\displaystyle\frac{nk + 2n - 2}{k^2} \times sum$。边读边取模即可。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int K = 1e6 + 9, MOD = 19491001;
int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') 
			f = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		x = ((x << 1) + (x << 3) + (ch ^ 48)) % MOD;
		ch = getchar();
	}
	return x * f;
}
int qpow(int a, int b){
	int res = 1;
	while(b > 0){
		if(b & 1)
			res = res * a % MOD;
		a = a * a % MOD;
		b >>= 1;
	}
	return res;
}
int n, k, sum, a[K];
signed main(){
	n = read();
	k = read();
	for(int i = 1; i <= k; i++){
		scanf("%lld", &a[i]);
		sum = (sum + a[i]) % MOD;
	}
	printf("%lld", sum * (n * (k + 2) % MOD - 2 + MOD) % MOD * qpow(k * k % MOD, MOD - 2) % MOD);
	return 0;
}
```

---

## 作者：kkxacj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5011)

#### 思路

$n$ 这么大，肯定不可能直接算，那多半是可以用公式快速算贡献的。

思考发现，可以把总答案分为单独放进这个位置的值和两个连续的两个加的额外的值。

对于第一种，可以发现，对于每个位置确定后，其他的位置放什么数都可以，同时由于他在 $n$ 个位置都可以放，所以也就是 $n \times (n - 1)^k$。

对于第二种，其实也差不多，我们会占用两个位置，那么其他位置又任选了，由于每种情况每个数都可以放在第一个和第二个位置，所以贡献为 $(n - 1) \times (n - 2)^k \times 2$。

然后对于每个数都乘上上面两个的和就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod = 19491001;
int k;
string s;
long long ans,ans1,a[1000010],js,l,js1,zjs;
long long ksm(long long x,long long p)
{
    ans1 = 1;
    while(p)
    {
        if(p % 2 == 1) ans1 = ans1 * x % mod;
        x = x * x % mod;
        p = p >> 1;
    } 
    return ans1;
} 
int main()
{
	cin >> s; 
	scanf("%d",&k);
	for(int i = 0;i < s.size();i++) js = (js * 10 + s[i] - '0') % (mod - 1),l = (l * 10 + s[i] - '0') % mod;
	zjs = (ksm(k,(js - 1 + mod - 1) % (mod - 1)) % mod * l % mod) % mod; 
	zjs = (zjs + ksm(k,(js - 2 + mod - 1) % (mod - 1)) % mod * (l - 1) % mod * 2 % mod) % mod;
	for(int i = 1;i <= k;i++) 
	{
		scanf("%lld",&a[i]);
		ans = (ans + (a[i] * zjs) % mod) % mod; 
	}
	printf("%lld",ans * ksm(ksm(k,js) % mod,mod - 2) % mod);
	return 0;
}
```


---

## 作者：VERACITY (赞：1)

## 思路

由于期望由每种方案的威力和除以方案数得到，且方案数可以由乘法原理得 $k^{n}$，所以考虑直接计算威力和。    

威力和由位置上的动作总威力和加上总额外威力得到，考虑分开计算。

令 $S$ 等于所有动作的单独威力和。       
- 当第 $i$ 个位置为第 $x$ 种动作，那么其余 $n-1$ 个位置 $k$ 个动作都可以放，那么一个位置的贡献的出现次数为 $k^{n-1}\times n$，所有 $n$ 个位置上的动作总威力为 $k^{n-1}\times n \times S$。    
- 额外威力是由两个特定动作组合在一起产生的，那么其余 $n-2$ 个位置 $k$ 个动作都可以放。而 $n$ 个位置可以放 $n-1$ 个组合，每个组合有 $2$ 个动作，所以总贡献次数为 $k^{n-2} \times (n-1) \times 2$，额外威力为 $k^{n-2} \times (n-1) \times 2 \times S$。

由上文可得威力和为 $k^{n-1}\times n \times S + k^{n-2} \times (n-1) \times 2 \times S$，最终答案即为 $\dfrac{k^{n-1}\times n \times S + k^{n-2} \times (n-1) \times 2 \times S}{k^{n}}$，约分可得 $\dfrac{S \times [k \times n + (n - 1) \times 2]}{k^2}$。

## 温馨提示
观察数据范围，可知 $n$ 达到了惊人的 $10^{10^6}$，所以在读入的时候就需要取模。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 19491001,mx = 1e6 + 5;
int read()
{
	int res = 0ll,f = 0,ch = getchar();
	while(!isdigit(ch)) f |= ch == '-',ch = getchar();
	while( isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48),res %= mod,ch = getchar();
	return f ? -res : res;
}
int fst(int x,int p)
{
	int res = 1ll;
	while(p)
	{
		if(p & 1) res = res * x % mod;
		x = x * x % mod,p >>= 1;
	}
	return res % mod;
}
int fz,fm,n,k,a[mx],sum,val1,val2;
signed main()
{
	n = read(),k = read();
	for(int i = 1;i <= k; i++) a[i] = read(),sum = (sum + a[i]) % mod;
	fz = (k * n % mod + (n - 1) * 2 % mod) % mod * sum % mod,fm = k * k % mod;
	cout << fz * fst(fm,mod - 2) % mod;
	return 0;
}
```

---

## 作者：TemplateClass (赞：0)

期望具有线性，所以我们可以考虑每一种组合的期望威力，然后加起来即可。

- 动作编号若连续，则其概率为 $\dfrac{1}{k ^ 2}$，所以每一种动作组合出现的次数的期望为 $\dfrac{N - 1}{k ^ 2}$，所以贡献就是 $\dfrac{N - 1}{k ^ 2} \sum \limits _ {i = 1} ^ {k} 2a _ i$，提一个 $2$ 出来，得到 $\dfrac{2(N - 1)}{k ^ 2} \sum \limits _ {i = 1} ^ {k} a _ i$。
- 否则，每一种动作组合出现的次数的期望为 $\dfrac{N}{k}$，所以贡献就是 $\dfrac{N}{k} \sum \limits _ {i = 1} ^ {k} a _ i$。

然后加起来算一下得到答案为 $\dfrac{(k + 2)N - 2}{k ^ 2} \sum \limits  _ {i = 1} ^ {k} a _ i$。

记得输入的时候就要取模。

```cpp
#include<cstdio>

constexpr int MOD = 19491001;

long long n, k, s;

inline int read() {
	char k = getchar(); int x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9') x = (x * 10 + k - '0') % MOD ,k = getchar();
	return x;
}

long long quick_pow(long long x, int k) {
    long long res = 1;
    while(k) {
        if(k & 1) res = res * x % MOD;
        x = x * x % MOD;
        k >>= 1;
    }
    return res;
}

long long inv(long long x) {
    return quick_pow(x, MOD - 2);
}

int main(){
	n = read(), k = read();
	for(int i = 1; i <= k; ++i) {
		s = (s + read()) % MOD;
	}
	
	long long invk = inv(k);
	std::printf("%lld", ((k + 2) * n - 2) % MOD * invk % MOD * invk % MOD * s % MOD);
	
	return 0;
}
```

---

## 作者：Jorisy (赞：0)

考虑分开计算单独一种动作和连续两种动作的贡献。

下文记 $s=\sum\limits_{i=1}^ka_i$。

对于前者，每种动作出现的概率为 $\dfrac 1k$，其期望为 $\dfrac nk$，故总期望为 $\dfrac {ns}k$。

对于后者，出现每种连续情况的概率为 $\dfrac1{k^2}$，其期望为 $\dfrac{n-1}{k^2}$，故总期望为 $\dfrac{2s(n-1)}{k^2}$。

因此最后算个 $k$ 的逆元把二者加起来即可。

由于 $n$ 很大，考虑快读的方法一边读一边模就可以了。

---

## 作者：Coffins (赞：0)

~~题就跟标题一样水~~

题意不说了。

首先考虑一个很朴素的 dp，让 $f_{i,j}$ 表示对于前 $i$ 位，当第 $i$ 为 $j$ 时的期望威力，那么容易看出转移方程：
$$
f_{i,j}=\frac{\sum\limits_{l=1}^k(f_{i-1,l}+a_j)}{k}+\frac{a_j+a_{bef}}{k}
$$
其中 $a_{bef}$ 表示 $a_j$ 的前一个数。

然后我们发现转移只会用到 $\sum\limits_{l=1}^kf_{i-1,l}$ 这个整体，然后直接打包起来另记一个 $s_i$。，于是有：
$$
f_{i,j}=\frac{s_{i-1}}{k}+\frac{(k+1)a_j+a_{bef}}{k}
$$
然后记 $\sum a$ 为 $m$ ，然后对于同一个 $i$ 对 $j$ 求和便有：
$$
s_i=s_{i-1}+\frac{k+2}{k}m
$$

考虑到答案为 $\frac{s_N}{k}$，$s_1=m$，于是最终推出柿子：
$$
\frac{kN+2N-2}{k^2}m
$$
然后就完成了,
复杂度为 $O(\log_{10}N+k)$。

代码就不贴了。~~毕竟结论题结论都有了，还要代码干什么（~~

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P5011)

water

因为所有动作出现概率相等，所以答案为所有可能的搏击操动作总威力之和除以 $k^N$。

只需要计算分子。

不考虑数据范围，设 $f_i$ 表示动作总数为 $i$ 的所有可能的搏击操动作总威力之和，很快就可以写出一个基本的 dp 转移方程：

$$f_i=\sum\limits_{j=1}^k(f_{i-1}+k^{i-1}a_j)+\sum\limits_{j=1}^kk^{i-2}(a_j+a_{j\%k+1})$$

将其展开：

$$f_i=kf_{i-1}+k^{i-1}\sum\limits_{j=1}^ka_j+2k^{i-2}\sum\limits_{j=1}^ka_j$$

令 $\sum\limits_{j=1}^ka_j=sum$：

$$f_i=kf_{i-1}+(k^{i-1}+2k^{i-2})sum$$

因为存在 $k^{i-2}$，所以这个式子在 $i\geq2$ 时才有效。

不考虑 $f_1$（假设 $f_1=0$），手动推导前几项，观察发现 $f_i=((i-1)k^{i-1}+2(i-1)k^{i-2})sum$。

现在加上 $f_1$。

显然 $f_1=sum$，并且计算到 $f_i$ 时相当于将 $f_1$ 乘了 $k^{i-1}$。

可得：$f_i=(ik^{i-1}+2(i-1)k^{i-2})sum$。

因此：$ans=\frac{f_N}{k^N}=(Nk^{-1}+2(N-1)k^{-2})sum$

因为有取模操作，$N$ 取模可以一位一位取模，$k^{-1}$ 和 $k^{-2}$ 求个逆元就行了。

代码：

```cpp
#include<bits/stdc++.h>
#define P 19491001
#define LL long long
using namespace std;
LL fpow(LL a,LL b){
	if(!b) return 1;
	LL t(fpow(a,b>>1));
	if(b&1) return t*t%P*a%P;
	return t*t%P;
}
string N;LL k,sum,n,t;
int main(){
	cin>>N;scanf("%lld",&k);
	for(int i(1);i<=k;++i){
		LL a;scanf("%lld",&a);
		(sum+=a)%=P;
	}
	for(int i(0);i<N.size();++i)
		n=((n<<1)+(n<<3)+(N[i]^48))%P;//相当与n=(n*10+(N[i]-'0'))%P
	t=fpow(k,P-2);
	printf("%lld\n",((n*t%P+2*(n-1)*t%P*t%P)*sum%P+P)%P);
	return 0;
}
```

---

## 作者：I_am_Accepted (赞：0)

有任何关于此篇题解的问题皆可私信[我](https://www.luogu.com.cn/user/101868)。

### 题目分析

期望题。

由题意可知**最后的威力等于使用的动作威力值之和加上相邻的动作贡献和**。

接下来有许多概率论术语~~不懂请出门右转百度一下~~。

翻开《概率论与数理统计》98 页。

- 设 $C$ 是常数，则有
$$E(C)=C.$$
- 设 $X$ 是一个随机变量，$C$ 是常数，则有
$$E(CX)=CE(X).$$
- 设 $X$ 和 $Y$ 是两个随机变量，则有
$$E(X+Y)=E(X)+E(Y).$$
- 设 $X$ 和 $Y$ 是两个**相互独立**的随机变量，则有
$$E(XY)=E(X)E(Y).$$

依照此题引入随机变量：
$$X_i=S(a_i+a_{i \ mod \ k+1}),i=1,2,\cdots,k$$
表示第 $i$ 个动作后紧接着第 $i \ mod \ k+1$ 个动作二元组合在搏击操中的期望贡献。

其中
$$S=\frac{n-1}{k^2}$$
表示第 $i$ 个动作后紧接着第 $(i \ mod \ k+1)$ 个动作二元组合在搏击操中出现的期望次数。

再引入随机变量：
$$Y_i=\frac{n}{k}a_i,i=1,2,\cdots,k$$
表示第 $i$ 个动作单个在搏击操中的期望贡献。

设最终答案的随机变量为 $A$。

所以最终答案的期望为：
$$E(A)=E(\sum_{i=1}^kX_i+\sum_{i=1}^kY_i)$$
开始用开头介绍的公式化简：
$$E(A)=E(\sum_{i=1}^kS(a_i+a_{i \ mod \ k+1})+\sum_{i=1}^k\frac{n}{k}a_i)$$
$$E(A)=E(2S\sum_{i=1}^ka_i+\frac{n}{k}\sum_{i=1}^ka_i)$$
$$E(A)=E((2S+\frac{n}{k})\sum_{i=1}^ka_i)$$
$$E(A)=E(2S+\frac{n}{k})\times E(\sum_{i=1}^ka_i)$$
$$E(A)=(2E(S)+\frac{n}{k})\sum_{i=1}^ka_i$$
设：
$$sum=\sum_{i=1}^ka_i$$
则：
$$E(A)=sum\times(2E(\frac{n-1}{k^2})+\frac{n}{k})$$
$$E(A)=sum\times(\frac{2n-2}{k^2}+\frac{n}{k})$$
$$E(A)=sum\times(2n-2+kn)\times inv(k^2)$$
其中 $inv(x)$ 表示 $x$ 的乘法逆元
### Details

别忘了开 `long long` 和取模。

$n\leq 10^{10^6}$ 但不用高精度，写个带模快读即可。

### ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i,j,k) for(register ll i=j;(j<k)?(i<=k):(i>=k);i+=(j<k)?1:(-1))
#define mod 19491001
ll read(){//带模快读 
	char k = getchar(); 
	ll x = 0;
	while(k < '0' || k > '9') k = getchar();
	while(k >= '0' && k <= '9') x = (x * 10 + k - '0') % mod ,k = getchar();
	return x;
}

ll n,k,sum=0,ans; 
ll pw(ll x,ll y){//快速幂（与题目给的略有不同） 
	if(y==0)return 1ll;
	ll res=pw(x,y/2);
	res=res*res%mod;
	if(y%2)res=res*x%mod;
	return res;
}
ll inv(ll x){//费马小定理求逆元 
	return pw(x,mod-2);
}
signed main(){
    n=read();
    scanf("%lld",&k);
    ll x;
    FOR(i,1,k){
    	scanf("%lld",&x);
    	sum=(sum+x)%mod;
	}
	ll ivk=inv(k);//inv of k
	ans=(n*k%mod+2*n-2)%mod*sum%mod*ivk%mod*ivk%mod;
	printf("%lld",ans);
    return 0;
}
```

---


# 派遣

## 题目背景

Steve在洞穴里发现了一张地图，上面标识出了黑暗势力的据点，他决定派遣一些士兵前去

## 题目描述

然而，这些士兵不一定具有与黑暗势力作战的能力，因而最终被派遣的士兵是未知的

为了尽量了解派遣的士兵的情况，Steve需要你帮忙计算一些值

Steve一共有$t$支军队，每支军队的人数都不同

每支军队可以按一定标准排成$n \times k$的方阵，每个士兵的位置可以用坐标$(x,y)$表示，其中$0\le x < n,0 \le y <k$，这个士兵的编号就是$x\cdot k+y$

位于$(0,0)$位置的士兵是队长，无论任何情况都会被派遣

对于其余的士兵，可以派遣，也可以不派遣

一支$n \times k$的军队的能力值是这样定义的：

如果所有士兵都被派遣，那么能力值是$1$

如果位于$(x,y)$位置的士兵(编号为$i$)未被派遣，那么能力值变为原来的$\frac{x}{i-x}$

例如，对于一支$2\times 2$的军队，如果$(1,1)$位置的士兵(编号为$3$)未被派遣，其他士兵都被派遣，那么能力值为$\frac{1}{3-1}=\frac{1}{2}$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(1,0)$位置的士兵(编号为$2$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{1}{2-1} = \frac{1}{2}$

现在，Steve需要你为每一支军队，计算出所有可能派遣方案的能力值之和

为了避免出现分数，输出结果是模$1145141$意义下的值

如果这个值不存在，那么输出$-1$

也就是，如果你的答案为既约分数$\frac{p}{q}$，你需要找到一个最小的非负整数$a$，满足$p\equiv q\cdot a(mod 1145141)$，并输出这个值，如果不存在这样的整数，就输出$-1$

提示：$1145141$是质数

## 说明/提示

第四组数据实际值为$\frac{7}{3}$

第五组数据实际值为$\frac{55}{9}$

第一组数据解释：

如果所有士兵都被派遣，那么能力值为$1$

如果$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{3-1}=0.5$

如果$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,0)$位置的士兵(编号为$2$)未被派遣，那么能力值为$\frac{1}{2-1} = 1$

如果$(1,0)$位置的士兵(编号为$2$)和$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{1}{3-1}=0.5$

如果$(1,0)$位置的士兵(编号为$2$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{0}{1-0}=0$

如果只有队长被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} \times \frac{1}{2-1}=0$

所以，答案为$1+0.5+0+0+1+0.5+0+0=3$

数据范围：

对于所有数据，$n\ge 1,k\ge 2$

Subtask1是比赛时的测试数据：

测试点| 分值| t | $n\le$| $k\le$
:-: | :-: | :-: | :-: | :-:
1| 10| 5| 5| 5| 
2| 11| 100| 100| 100|
3| 12| 100000| 5| 100000|
4| 13| 100000| 100000| 5|
5| 16| 5| 100000| 100000|
6| 18| 5| $10^9$| $10^9$|
7| 20| 100000| $10^9$|$10^9$|

Subtask2包括两个不计分的Hack数据，均满足$t=1$

#8满足#7的性质

#9满足#5的性质

## 样例 #1

### 输入

```
5
2 2
3 3
1 4
2 4
3 4
```

### 输出

```
3
7
1
381716
127244
```

# 题解

## 作者：Alex_Wei (赞：11)

[题面传送门](https://www.luogu.com.cn/problem/P5509)。

---

由题意，对于每个士兵 $i$，要么选，对答案产生 $a_i(\frac{x}{i-x})$ 倍的贡献，要么不选，对答案产生 $1$ 倍的贡献。

由此可知每个士兵之间是独立的，不相互影响，则根据乘法原理，答案应为

$$\prod_{i=1}^{nk-1}(a_i+1)$$

大力展开，即

$$\prod_{i=0}^{n-1}\prod_{j=0,ik+j\neq0}^{k-1}\left(\frac{i}{ik+j-i}+1\right)$$

即

$$\prod_{i=0}^{n-1}\prod_{j=0,ik+j\neq0}^{k-1}\frac{ik+j}{ik+j-i}$$

不妨将分子分母拆开来看：

- 分子：

  $$\prod_{i=0}^{n-1}\prod_{j=0,ik+j\neq0}^{k-1}ij$$
  
  即
  
  $$(nk-1)!$$

- 分母：Markdown 渲染好像不太行。。。

  |$i/j$|$0$|$1$|$2$|$\cdots$|$k-1$
  |:-:|:-:|:-:|:-:|:-:|:-:|:-:|
  |$0$|/|$1$|$2$|$\cdots$|$k-1$
  |$1$|$k-1$|$k-1+1$|$k-1+2$|$\cdots$|$2(k-1)$
  |$2$|$2(k-1)$|$2(k-1)+1$|$2(k-1)+2$|$\cdots$|$3(k-1)$
  |$\cdots\ $|$\cdots$|$\cdots$|$\cdots$|$\cdots$|$\cdots$|
  |$n-2$|$(n-2)(k-1)$|$(n-2)(k-1)+1$|$(n-2)(k-1)+2$|$\cdots$|$(n-1)(k-1)$
  |$\ \ n-1\ \ $|$\ \ (n-1)(k-1)\ \ $|$\ \ (n-1)(k-1)+1\ \ $|$\ \ (n-1)(k-1)+2\ \ $|$\ \ \cdots\ \ $|$\ \ n(k-1)\ \ $
  
  不难发现 $1\sim n(k-1)$ 各出现了一次，且每一行的第一个数与上一行的最后一个数相等，即 $k-1, 2(k-1), \cdots, (n-1)(k-1)$ 多出现了一次。
  
  那么分母为
  
  $$[n(k-1)]!\times \prod_{i=1}^{n-1}i(k-1)$$
  
  即
  
  $$(nk-n)!\times (k-1)^{n-1}\times (n-1)!$$ 

综上，可知答案为：

$$\dfrac{(nk-1)!}{(nk-n)!\times (k-1)^{n-1}\times (n-1)!}$$

但是 $nk$ 已经达到了 $10^{18}$ 的数量级，怎么求这玩意的阶乘？

---

求 $v!\ (v>10^8)$ 模 $p\ (p<10^8)$：

抓住模数 $p=1145141$，对 $1\sim v$ 的每个数取模，最终会得到 $\left\lfloor \dfrac{v}{p}\right\rfloor$ 个 $0\sim p-1$ 和 $1\sim (v\bmod p)$。

将所有 $p$ 的倍数除以 $p$，得到 $\left\lfloor \dfrac{v}{p}\right\rfloor$ 个 $1\sim p-1$ 和 $1\sim (v\bmod p)$ 和 $1\sim \left\lfloor \dfrac{v}{p}\right\rfloor$。

则答案为

$$(p-1)!^{\left\lfloor \frac{v}{p}\right\rfloor}\times (v\bmod p)!\times \left(\left\lfloor\frac{v}{p}\right\rfloor\right)!$$

预处理 $1\sim p-1$ 的阶乘，用递归 + 快速幂即可做到 $\mathcal O(\log v)$ 计算。

根据威尔逊定理 $(p-1)!\equiv -1\ (\bmod\ p),p\in \rm{prime}$，原答案可化简为 

$$(-1)^{\left\lfloor \frac{v}{p}\right\rfloor}\times (v\bmod p)!\times \left(\left\lfloor\frac{v}{p}\right\rfloor\right)!$$

这样可以做到 $\mathcal O(\log_p v)$ 计算，可以近似看做常数。

代码：

```cpp
ll cal(ll v){return v<mod?fc[v]:fc[v%mod]*((v/mod)&1?-1:1)%mod*cal(v/mod)%mod;}
```

---

接下来计算出分子和分母各含有多少个 $p$：

- $v!$：一般的，$v!$ 中含有质因子 $p$ 的个数应为 $\sum_{i=1,v\geq p^i}\left\lfloor \dfrac{v}{p^i}\right\rfloor$，但此处 $v<p^3$，则可以化简为 $\left\lfloor \dfrac{v}{p}\right\rfloor+\left\lfloor \dfrac{v}{p^2}\right\rfloor$。
- $(k-1)^{n-1}$：
  - 当 $p\mid k-1$ 时，$p$ 的个数为 $n-1$，此时一定无解（即输出 $\tt{-1}$），读者自证不难。
  - 当 $p\nmid k-1$ 时，$p$ 的个数为 $0$，此时一定有解，读者自证不难。

综上，特判掉 $p\mid k-1$ 的情况，记 $c$ 为最终答案含有质因子 $p$ 的个数，则 

$$c=\left\lfloor \dfrac{nk-1}{p}\right\rfloor+\left\lfloor \dfrac{nk-1}{p^2}\right\rfloor-\left(\left\lfloor \dfrac{nk-k}{p}\right\rfloor+\left\lfloor \dfrac{nk-k}{p^2}\right\rfloor\right)-\left\lfloor \dfrac{n}{p}\right\rfloor$$

可以证明 $c\geq 0$。

那么，当 $c>0$ 时，$ans\equiv 0\ (\bmod\  p)$，输出 $0$ 即可，否则计算上文推出的答案：

$$\dfrac{(nk-1)!}{(nk-n)!\times (k-1)^{n-1}\times (n-1)!}$$

计算快速幂时根据费马小定理将质数 $n-1$ 模 $p-1$，时间复杂度 $\mathcal O(p+t\log p)$。

---

代码片段：

```cpp
ll ksm(ll a,ll b){
	ll s=1,m=a;
	while(b){
		if(b&1)s=s*m%mod;
		m=m*m%mod,b>>=1;
	} return s;
} ll inv(ll x){return ksm(x%mod,mod-2);}
ll t,n,k,fc[mod+5];
ll cal(ll v){return v<mod?fc[v]:fc[v%mod]*((v/mod)&1?-1:1)%mod*cal(v/mod)%mod;}

int main(){
	cin>>t,fc[0]=1;
	for(int i=1;i<mod;i++)fc[i]=fc[i-1]*i%mod;
	while(t--){
		n=read(),k=read();
		if(n==1)pc('1');
		else if((k-1)%mod==0)pc('-'),pc('1');
		else{
			ll l=n*k-n,r=n*k-1;
			if(r/mod+r/mod/mod>l/mod+l/mod/mod+(n-1)/mod)pc('0');
			else print(cal(r)*inv(cal(l))%mod*inv(ksm(k-1,(n-1)%(mod-1))*cal(n-1))%mod);
		} pc('\n');
	} 
	return flush(),0;
}
```

---

## 作者：Hope2075 (赞：5)

这道题如果能推出式子，就能得高分，如果再用些技巧计算，就能AC

## 算法1

按照题意，枚举所有可能的选法

时间复杂度$O(t\cdot 2^{nk})$

期望得分：10分

## 算法2

设不选第$i$个士兵会使能力值变为原来的$a_i$倍，那么答案就是$\prod_{i=1}^{nk-1}(1+a_i)$

这样考虑：每个士兵从括号里的两项中选择一项，得到某个选法的答案

根据题目的数据范围，在$n,k\le 100$时，不会出现分子或分母在模意义下为0的情况

这部分可以用逆元直接算，也可以分别计算分子和分母

时间复杂度：$O(tnk)$

期望得分：21分

## 算法3

利用算法2打表，找出#3或#4的规律

不过规律比较复杂，不太容易看出来

期望得分：33-46分

## 先推一下式子

现在需要对式子进一步变形

$\prod_{i=1}^{nk-1}(1+a_i)$

$=\prod_{i=1}^{nk-1}(1+\frac{\lfloor \frac{i}{k}\rfloor}{i-\lfloor \frac{i}{k}\rfloor})$

$=\prod_{i=1}^{nk-1}(\frac{i}{i-\lfloor \frac{i}{k}\rfloor})$

考虑把分子和分母分别计算

分子很好算，就是$(nk-1)!$

分母：

$\prod_{i=1}^{nk-1}(i-\lfloor \frac{i}{k}\rfloor)$

添加一项

$=\prod_{i=1}^{nk}(i-\lfloor \frac{i}{k}\rfloor) \div (nk-\lfloor \frac{nk}{k}\rfloor)$

$=\prod_{i=0}^{nk-1}(i+1-\lfloor \frac{i+1}{k}\rfloor) \div (nk-n)$

把连乘变成两个

$=\prod_{i=0}^{n-1}\prod_{j=0}^{k-1}(ik+j+1-\lfloor \frac{ik+j+1}{k}\rfloor) \div (nk-n)$

将其中一个拆出来

$=\prod_{i=0}^{n-1}\prod_{j=0}^{k-2}(ik+j+1-\lfloor \frac{ik+j+1}{k}\rfloor)\cdot \prod_{i=0}^{n-1}(ik+(k-1)+1-\lfloor \frac{ik+(k-1)+1}{k}\rfloor) \div (nk-n)$

消去向下取整符号

$=\prod_{i=0}^{n-1}\prod_{j=0}^{k-2}(ik+j+1-i)\cdot \prod_{i=0}^{n-1}(ik+k-(i+1)) \div (nk-n)$

然后整理

$=\prod_{i=0}^{n-1}\prod_{j=0}^{k-2}[i(k-1)+j+1]\cdot \prod_{i=0}^{n-1}[(k-1)(i+1)] \div (nk-n)$

$=\prod_{i=0}^{n(k-1)-1}(i+1)\cdot (k-1)^n\cdot \prod_{i=0}^{n-1}(i+1) \div (nk-n)$

$=\prod_{i=1}^{n(k-1)}i\cdot (k-1)^n\cdot \prod_{i=1}^{n}(i) \div (nk-n)$

$=(nk-n)!\cdot (k-1)^n\cdot n! \div (nk-n)$

$=(nk-n-1)!\cdot n! \cdot (k-1)^n$

经过推导，变成了简单的形式

所以答案是$\frac{(nk-1)!}{(nk-n-1)!\cdot n! \cdot (k-1)^n}$

另一个表示方法是：用组合数

$\frac{C_{nk-1}^n}{(k-1)^n}$

然后就需要考虑如何计算

## 算法4

计算阶乘，然后求逆元

模数并不大，可以直接预处理阶乘

而对于#3和#4的范围，不会导致出现模意义下为0的情况

时间复杂度$O(nk+t\log n+t\log m)$,$m$为模数

期望得分46分

## 算法5

利用上面的组合数表示，同时发现范围并不大

可以先把数据全读进来确定范围，然后用杨辉三角求组合数

时间复杂度$O(nk+t\log n+t\log m)$

期望得分46分

## 算法6

用阶乘表示，把分子和分母求出来

需要求出$m$因子的个数，以及除掉所有$m$因子后在模$m$意义下的结果

威尔逊定理：

$( p -1 )! \equiv -1 (mod\ p)$,$p$是质数

先预处理$1$到$m-1$的阶乘

然后考虑任意阶乘如何计算

对于一个数$n$，首先考虑$1$到$n$中，模$m$同余$1$到$m$的连续$m$个数有几组，也就是$\lfloor \frac{n}{m} \rfloor$组

这一部分中，每一组余$1$到$m-1$的数乘起来就是$-1$，余$m$的那一个数单独考虑

对于不能构成完整一组的部分，用预处理的阶乘可以直接求出来

而对于模$m$余$0$的$\lfloor \frac{n}{m} \rfloor$个数，把它们分别除以$m$，剩下的部分还是阶乘，问题与原来一样，但规模减小，可以递归处理，也可以用循环

这样，就可以统计$m$因子的个数，以及剩余部分模$m$意义下的值

对于乘方部分就很简单了，先计算原数中$m$因子的个数，然后乘以指数就是因子总数，剩余部分用快速幂就能求出来

计算完后，比较分子和分母中$m$因子的个数

如果分子多，那么约分后$p=0$，所以$a=0$即可，输出0

如果分母多，那么约分后$q=0$，所以无论$a$取什么值，都不可能满足条件，输出-1

如果一样多，那么$p\ne 0,q\ne 0$，这样可以用逆元求出值

时间复杂度$O(m+t\log n+t \log k)$

期望得分100分

代码：

这里统计的是因子数之差，并且求的值是除掉所有$m$因子后，在$m$意义下的值
```cpp
#include<cstdio>
long long read(){
	long long n=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
	return n;
}
char res[25];
void write(long long num){
	int t=0;
	while(num){res[t++]=num%10+'0';num/=10;}
	while(t--)putchar(res[t]);
}
const long long M=1145141;
long long fpow(long long a,long long n){
	long long ans=1;
	while(n){
		if(n&1)ans=ans*a%M;
		n>>=1;
		a=a*a%M;
	}
	return ans;
}
long long f[M];
void pre(){
	f[0]=1;
	for(int i=1;i<M;i++){
		f[i]=f[i-1]*i%M;
	}
}
int t;long long n,k;
int main(){
	t=read();
	pre();
	while(t--){
		n=read();k=read();
		long long r,c=0,c0;long long num1=1,num2=1;
		
		c0=0;
		r=k-1;
		while(r%M==0){
			c0++;
			r/=M;
		}
		c0*=(n-1);
		num1=fpow(r,n-1);
		c-=c0;
		
		c0=0;
		r=n*k-1;
		while(r){
			num2=num2*f[r%M]%M;
			r/=M;
			c0+=r;
		}
		num2=num2*fpow(f[M-1],c0)%M;
		c+=c0;
		
		c0=0;
		r=n*k-n;
		while(r){
			num1=num1*f[r%M]%M;
			r/=M;
			c0+=r;
		}
		num1=num1*fpow(f[M-1],c0)%M;
		c-=c0;
		
		c0=0;
		r=n-1;
		while(r){
			num1=num1*f[r%M]%M;
			r/=M;
			c0+=r;
		}
		num1=num1*fpow(f[M-1],c0)%M;
		c-=c0;
		
		num2=num2*fpow(num1,M-2)%M;
		if(c>0){puts("0");}
		else if(c==0){write(num2);putchar('\n');}
		else puts("-1");
	}
}
```


---

## 作者：Thinking (赞：3)

题意：已知一些数对$(x,y)(0\le x<n,0\le y<k,x+y>0)$，可选可不选，每种选法对答案的贡献是所有$\frac{x}{(k-1)x+y}$之积（一个都没选则为1），求总贡献。

首先提取公因式就可以看出答案是所有$(x,y)$的$(1+\frac{x}{(k-1)x+y})$之积，即$\prod\limits_{0\le x<n,0\le y<k,x+y>0}\frac{kx+y}{(k-1)x+y}$，这样就可以$O(Tnk)$求了。

但是这个东西好像可以化简，我们来试一下：

$x=0$时，$\prod\limits^{k-1}_{y=1}\frac{y}{y}=1$；

$x=1$时，$\prod\limits^{k-1}_{y=0}\frac{k+y}{k-1+y}=\frac{2k-1}{k-1}$；

$x=2$时，$\prod\limits^{k-1}_{y=0}\frac{2k+y}{2k-2+y}=\frac{(3k-1)(3k-2)}{(2k-1)(2k-2)}$;

发现规律：对于固定的$x$，积为$\frac{\prod\limits^x_{i=1}(k(x+1)-i)}{\prod\limits^x_{j=1}(kx-j)}$，把这些东西乘起来，许多项上下消掉了！确切地说，只剩下$\frac{\prod\limits^{n-1}_{i=1}(kn-i)}{\prod\limits^{n-1}_{j=1}(kj-j)}$（可以自己试一下），化简得到：$\frac{\prod\limits^{kn-1}_{i=kn-n+1}i}{(n-1)!(k-1)^{n-1}}$，这样至少可以$O(Tn)$求。

但是，都推到这一步了，我们肯定不甘心暴力求，而求这个式子的效率瓶颈在于快速求$n!(n\le 10^{18})$，所以我们需要一个套路的公式：

$$n!\equiv(n\;mod\;p)!\times (p!)^{n/p}\times (n/p)!(mod\;p)$$

注意到题目中得$p$比较小，预处理一下阶乘和逆元就可以了。

另外一个要注意的问题是$n>p$时，直接取模会得到$0$，不过由于每个数肯定可以写成$a\times p^m(gcd(a,p)=1,m\ge 0)$的形式，我们把$a$取模，维护$m$，若分母的$m$大于分子，则为-1；若小于分子，则为0；否则就是两个$a$做有理数取余。

code:

```cpp
#include<cstdio>
typedef long long ll;
char rB[1<<23],*rS,*rT;
inline char gc(){return rS==rT&&(rT=(rS=rB)+fread(rB,1,1<<23,stdin),rS==rT)?EOF:*rS++;}
inline int rd(){
    char c=gc();
    while(c<48||c>57)c=gc();
    int x=c&15;
    for(c=gc();c>=48&&c<=57;c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
const int mod=1145141;
int f[mod],g[mod],inv[mod];
inline int fp(int a,ll p){
	int s=1;
	while(p){
		if(p&1ll)s=(ll)s*a%mod;
		a=(ll)a*a%mod;
		p>>=1ll;
	}
	return s;
}
struct data{
	int v;
	ll p;
	data(){}
	data(int v,ll p):v(v),p(p){}
	inline data operator *(const data &b)const{return data((ll)v*b.v%mod,p+b.p);}
//乘法：系数相乘，指数相加
	inline data operator /(const data &b)const{return data((ll)v*inv[b.v]%mod,p-b.p);}
//除法相反
};
inline data getf(ll x){
	return x<mod?data(f[x],0ll):data((ll)fp(f[mod-1],x/mod)*f[x%mod]%mod,x/mod)*getf(x/mod);
}
inline data getmul(ll x,ll y){  //求(x+1)*(x+2)*...*y mod p
	data t1=getf(y),t2=getf(x);
	return t1/t2;
}
int main(){
	int T=rd(),n,k,i;
	data t1,t2,t3;
	for(i=2,inv[1]=f[0]=f[1]=1;i<mod;++i)f[i]=(ll)f[i-1]*i%mod;
	for(i=2;i<mod;++i)inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;
	while(T--){
		n=rd();k=rd();
		t1=getmul((ll)k*n-n,(ll)k*n-1ll);  //(kn-n+1)*(kn-n+2)*...*(kn-1)
		t2=getf(n-1); //(n-1)!
		t3=(k-1)%mod?data(fp((k-1)%mod,n-1),0ll):data(fp((k-1)/mod,n-1),n-1); //(k-1)^(n-1)
		if(t1.p<t2.p+t3.p)puts("-1");
		else if(t1.p>t2.p+t3.p)puts("0");
		else printf("%d\n",(ll)t1.v*inv[t2.v]%mod*inv[t3.v]%mod);
	}
	return 0;
}
```


---

## 作者：我是蒟弱 (赞：1)

标明出处：[i_m_a_的博客](https://www.luogu.org/blog/ima/pai-qian-sol)

下面简写一下思路：

### 法1：暴力枚举
按照题意，枚举所有可能的选法

时间复杂度 O(t·2^{nk})

10分
### 法2：逆元+计算分子分母

这样考虑：每个士兵从括号里的两项中选择一项，得到某个选法的答案

根据题目的数据范围，在 n,k≤100 时，不会出现分子或分母在模意义下为0的情况

这部分可以用逆元直接算，也可以分别计算分子和分母

时间复杂度： O(tnk)

期望得分：21分
### 法3：利用法2打表，找规律
但，规律不好找

33-41分
### 法4：计算阶乘，然后求逆元
模数并不大，可以直接预处理阶乘

而对于#3和#4的范围，不会导致出现模意义下为0的情况

时间复杂度 O(nk+t\log n+t\log m)O(nk+tlogn+tlogm) , mm 为模数

期望得分46分
### 法5：利用组合数+杨辉三角
利用上面的组合数表示，同时发现范围并不大

可以先把数据全读进来确定范围，然后用杨辉三角求组合数

时间复杂度 O(nk+t\log n+t\log m)O(nk+tlogn+tlogm)

期望得分46分

### 法6：用阶乘表示，把分子和分母求出来
100分
```cpp
#include<cstdio>
long long read(){
    long long n=0;char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
    return n;
}
char res[25];
void write(long long num){
    int t=0;
    while(num){res[t++]=num%10+'0';num/=10;}
    while(t--)putchar(res[t]);
}
const long long M=1145141;
long long fpow(long long a,long long n){
    long long ans=1;
    while(n){
        if(n&1)ans=ans*a%M;
        n>>=1;
        a=a*a%M;
    }
    return ans;
}
long long f[M];
void pre(){
    f[0]=1;
    for(int i=1;i<M;i++){
        f[i]=f[i-1]*i%M;
    }
}
int t;long long n,k;
int main(){
    t=read();
    pre();
    while(t--){
        n=read();k=read();
        long long r,c=0,c0;long long num1=1,num2=1;

        c0=0;
        r=k-1;
        while(r%M==0){
            c0++;
            r/=M;
        }
        c0*=(n-1);
        num1=fpow(r,n-1);
        c-=c0;

        c0=0;
        r=n*k-1;
        while(r){
            num2=num2*f[r%M]%M;
            r/=M;
            c0+=r;
        }
        num2=num2*fpow(f[M-1],c0)%M;
        c+=c0;

        c0=0;
        r=n*k-n;
        while(r){
            num1=num1*f[r%M]%M;
            r/=M;
            c0+=r;
        }
        num1=num1*fpow(f[M-1],c0)%M;
        c-=c0;

        c0=0;
        r=n-1;
        while(r){
            num1=num1*f[r%M]%M;
            r/=M;
            c0+=r;
        }
        num1=num1*fpow(f[M-1],c0)%M;
        c-=c0;

        num2=num2*fpow(num1,M-2)%M;
        if(c>0){puts("0");}
        else if(c==0){write(num2);putchar('\n');}
        else puts("-1");
    }
}
```


---

## 作者：什么叫中二呀 (赞：0)

本题是我唯一一道独立想出来的题……

前置芝士:$Lucas$定理

不会的请自行学习[模板](https://www.luogu.org/problem/P3807)

略微分析一下，答案是$\prod_{i=0}^N \prod_{j=0}^K \frac{i*K+j}{i*(K-1)+j}$

什么？你连这个都不知道?

~~算了还是推一遍吧~~

题目让我们求的是所有的能力值之和。

设能力值和为s，第i名队员一定选的能力值总和为$s_i$

$s=s_i+(\frac{i}{i*K-i+j})*s_i=(1+\frac{i}{i*K-i+j})*s_i=\frac{i*K+j}{i*(K-1)+j}*s_i=\prod_{i=0}^N \prod_{j=0}^K \frac{i*K+j}{i*(K-1)+j}$

之后我们尝试把式子化简。

$\prod_{i=0}^N \prod_{j=0}^K \frac{i*K+j}{i*(K-1)+j}$

$=\frac{\prod_{i=0}^N \prod_{j=0}^K (i*K+j)}{\prod_{i=0}^N \prod_{j=0} (i*(K-1)+j)}$

直接把矩阵画出来

分子矩阵:

![](https://cdn.luogu.com.cn/upload/pic/71910.png)

可以看出分子是$(NK-1)!$

分母矩阵:

![](https://cdn.luogu.com.cn/upload/pic/71912.png)

我们可以把最后一列单算，把N个$K-1$提出来，变成$(K-1)^N*N!$

前面的就是$(NK-N-1)!$

$\prod_{i=0}^N \prod_{j=0}^K \frac{i*K+j}{i*(K-1)+j}$

$=\frac{(NK-1)!}{(K-1)^N*N!*(NK-N-1)!}$

$=(K-1)^{-N}*C_{NK-1}^{N}$

$=(K-1)^{N*(p-2) mod (p-1)}*C_{NK-1}^{N}$

以上运用了费马小定理(如果你硬说是欧拉定理也行……)

后面用Lucas定理算，阶乘及逆元$O(p)$预处理好，前面快速幂算。

注意前面等于0的时候不存在逆元，输出-1。

还有$C_n^k(n<k)$时结果是0。

代码不放了

---


# 区间运算

## 题目描述

区间运算是数学的一个领域。在区间运算中，常量和变量并不表示为一个单独、精确的值，而是表示为一个有着上界和下界的区间或范围。在普通的运算中，一个数量可以表示为数轴上的一个点；而在区间运算中，一个数量表示数轴上的一段，例如 $[3,5]$ 表示数轴上从 $3$ 到 $5$ 的一段。当精确的数值表示为区间时，上界与下界是相同的，如 $5$ 表示为区间即为 $[5,5]$。

两个区间的运算，是指一个区间中的每个点与另一个区间中的每个点所做的运算，通过运算所得的所有点的集合即为运算的结果。例如，$[3,5]+[-10,1]=[-7,6]$。你的任务是写一个可以根据单行表达式进行取相反数、加、减、乘、除等基本的区间运算的程序。下面是一些运算的例子：

- 取相反数：$-[-3,5]=[-5,3]$；
- 加法：$[3,5]+[-10,1]=[-7,6]$；
- 减法：$[3,5]-[-10,1]=[2,15]$；
- 乘法：$[3,5]\times [-10,1]=[-50,5]$；
- 除法：$[3,5]\div [-10,-0.1]=[-50,-0.3]$。

## 样例 #1

### 输入

```
-[-3,5] 
[3,5]+[-10,1] 
[3,5]-[-10,1] 
[3,5]*[-10,1] 
(([3,5]/[-10,-0.1])/-[2,2]) ```

### 输出

```
[-5.000,3.000] 
[-7.000,6.000] 
[2.000,15.000] 
[-50.000,5.000] 
[0.150,25.000]```

# 题解

## 作者：Pecco (赞：6)

这种题用Python做是最简单的，因为它有神器：`eval()`。直接定义一个类，重载一下运算符即可。唯一需要注意的是处理除以0的情况，可以采取异常处理的方法。

```python
import re

class Range():
    def __init__(self, l, r):
        self.l, self.r = min(l, r), max(l, r)

    def __neg__(self):
        return Range(-self.l, -self.r)

    def __add__(self, other):
        return Range(self.l + other.l, self.r + other.r)

    def __sub__(self, other):
        return self + (-other)

    def __mul__(self, other):
        tpl = self.l * other.l, self.r * other.r, self.l * other.r, self.r * other.l
        return Range(min(tpl), max(tpl))

    def __truediv__(self, other):
        if other.l <= 0 and other.r >= 0:
            raise ZeroDivisionError # 除数区间包含0的情形
        tpl = self.l / other.l, self.r / other.r, self.l / other.r, self.r / other.l
        return Range(min(tpl), max(tpl))

    def __str__(self):
        return f"[{self.l:.3f},{self.r:.3f}]" # 用f-string可以便捷地实现格式化字符串

while True:
    try:
        expr = re.sub(r"\[([^\]]+)\]", r"Range(\1)", input()) # 正则表达式处理一下源文本，例如[1,3]->Range(1,3)
        try:
            print(eval(expr))
        except ZeroDivisionError:
            print("Division by zero")
    except EOFError:
        break

```

---

## 作者：xianxi (赞：3)

# 思路

给出区间运算的运算规则：

取相反数：$-[a,b]=[-b,-a]$；

加法：$[a,b]+[c,d]=[a+b,c+d]$；

减法：$[a,b]-[c,d]=[a-d,b-c]$；

乘法：$[a,b]\times[c,d]=[\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]$；

除法：$\frac{[a,b]}{[c,d]}=[\min(\frac{a}{c},\frac{a}{d},\frac{b}{c},\frac{b}{d}),\max(\frac{a}{c},\frac{a}{d},\frac{b}{c},\frac{b}{d})]$。

特别的，在运算中，如果将一个包含零的区间用作除数，则输出 `Division by zero`。

加上中缀转后缀表达式的运算即可。

# 读入方法

解决两个点。

1\. 方括号内的 $l$ 与 $r$ 的分隔与记录。

先读入左端点。定义两个变量 $z$ 与 $l$，每读入一个字符 $c$，判断是否为符号或数字。如果为数字则累加至 $l$ 上，否则，如果为小数点则将接下来所有读入的数字按差不多的方法累加到 $z$ 上，同时记录当前是小数点后第几位，方便累加，最后相加；若为负号，则用 $flag$ 记录，在最后记录整数与分数完毕后，再取相反数。再读入右端点亦是如此。

2\. 小心恶心数据

当你发现自己有一个点怎么也过不了，但计算模块又没有错，那么恭喜你，这道题目有个数据点里有方括号里左端点大于右端点的数据。

所以，记得特判该点，把左端点与右端点交换。

下面是读入函数：

```cpp
int read(int x,int t)
{
	bool fl=0,ffl=0;
	int l=0,o=1;//o从1开始 
	double z=0;
	while(s[t]!=',')
	{
		if(s[t]=='-')fl=1;
		if(s[t]=='.')ffl=1;
		else if(ffl==1)
		{
			z+=(s[t]-'0')*pow(0.1,o);
			o++;
		}
		else if(s[t]>='0'&&s[t]<='9')
		{
			l*=10;
			l+=(s[t]-'0');
		}
		t++;
	}
	tree[x].l=(double)l+z;
	if(fl==1)tree[x].l=(-tree[x].l);
	t++;
	z=0,fl=0,ffl=0,l=0,o=1;//o从1开始 
	while(s[t]!=']')
	{
		if(s[t]=='-')fl=1;
		if(s[t]=='.')ffl=1;
		else if(ffl==1)
		{
			z+=(s[t]-'0')*pow(0.1,o);
			o++;
		}
		else if(s[t]>='0'&&s[t]<='9')
		{
			l*=10;
			l+=(s[t]-'0');
		}
		t++;
	}
	tree[x].r=(double)l+z;
	if(fl==1)tree[x].r=(-tree[x].r);
	if(tree[x].r<tree[x].l)swap(tree[x].l,tree[x].r);
	return t;
}
```

# 表达式运算

**第一步，给运算符赋优先级。**

四则混合运算时，乘除的优先级高于加减，同级运算从左往右，括号里的先算。

自然，由题可以得出，运算优先级为由大到小为：小括号，取相反数，乘除，加减。

所以，可以得到优先级数组。

**第二步，运算实现。**

将中缀转后缀方便计算机处理。

先建立两个栈，一个栈 $q2$ 用于存数字，另一个栈 $q1$ 用于存符号。

然后将读入到的数字和运算符分别依次存入。当遇到 $q1$ 栈顶的优先级大于等于将存入的符号 $c$ 的优先级时，我们需要不停弹出栈顶并计算直到的 $q1$ 栈顶优先级小于 $c$ 的优先级。

最后写一个计算函数，分开处理不同运算符。

计算函数如下：

```cpp
void solve()
{
	node a,b,ans;
	double l1,l2,r1,r2;
	char op;
	op=q1.top();
	q1.pop();
	a=q2.top();
	q2.pop();
	if(op=='=')
	{
		ans.l=-a.r;
		ans.r=-a.l;
	}
	else
	{
		b=q2.top();
		q2.pop();
		if(op=='+')
		{
			ans.l=a.l+b.l;
			ans.r=a.r+b.r;
		}
		else if(op=='-')
		{
			ans.l=b.l-a.r;
			ans.r=b.r-a.l;//先出栈的是减数 
		}
		else if(op=='*')
		{
			double a1,a2,a3,a4;
			a1=a.l*b.l;
			a2=a.l*b.r;
			a3=a.r*b.l;
			a4=a.r*b.r;
			ans.l=min({a1,a2,a3,a4});
			ans.r=max({a1,a2,a3,a4});
		}
		else if(op=='/')
		{
			if(a.l*a.r<=0)
			{
				zo=1;
				return ;
			}
			double a1,a2,a3,a4;
			a1=b.l/a.l;
			a2=b.l/a.r;
			a3=b.r/a.l;
			a4=b.r/a.r;
			ans.l=min({a1,a2,a3,a4});
			ans.r=max({a1,a2,a3,a4});
		}
	}
	if(ans.l>ans.r)swap(ans.l,ans.r);//这也有可能反过来 
	q2.push(ans);
	return ;
}
```

# 警钟长鸣

1\. 用栈记录计算顺序时，记得清空。

2\. 注意出栈时先出栈的是被除数、被减数还是除数、减数。

3\. 最后，如使用 `ios:sync_with_stdio(0)` 解绑，记得输出不要习惯性写上 `printf("[%.3lf,%.3lf]\n");`，不然会出问题。

# 代码实现

废话不多说，献上完整代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{
	double l;
	double r;
}tree[10005];
string s;
map<char,int>you;
stack<char>q1;
stack<node>q2;
bool zo=0;

void solve()
{
	node a,b,ans;
	double l1,l2,r1,r2;
	char op;
	op=q1.top();
	q1.pop();
	a=q2.top();
	q2.pop();
	if(op=='=')
	{
		ans.l=-a.r;
		ans.r=-a.l;
	}
	else
	{
		b=q2.top();
		q2.pop();
		if(op=='+')
		{
			ans.l=a.l+b.l;
			ans.r=a.r+b.r;
		}
		else if(op=='-')
		{
			ans.l=b.l-a.r;
			ans.r=b.r-a.l;//先出栈的是减数 
		}
		else if(op=='*')
		{
			double a1,a2,a3,a4;
			a1=a.l*b.l;
			a2=a.l*b.r;
			a3=a.r*b.l;
			a4=a.r*b.r;
			ans.l=min({a1,a2,a3,a4});
			ans.r=max({a1,a2,a3,a4});
		}
		else if(op=='/')
		{
			if(a.l*a.r<=0)
			{
				zo=1;
				return ;
			}
			double a1,a2,a3,a4;
			a1=b.l/a.l;
			a2=b.l/a.r;
			a3=b.r/a.l;
			a4=b.r/a.r;
			ans.l=min({a1,a2,a3,a4});
			ans.r=max({a1,a2,a3,a4});
		}
	}
	if(ans.l>ans.r)swap(ans.l,ans.r);//这也有可能反过来 
	q2.push(ans);
	return ;
}

int read(int x,int t)
{
	bool fl=0,ffl=0;
	int l=0,o=1;//o从1开始 
	double z=0;
	while(s[t]!=',')
	{
		if(s[t]=='-')fl=1;
		if(s[t]=='.')ffl=1;
		else if(ffl==1)
		{
			z+=(s[t]-'0')*pow(0.1,o);
			o++;
		}
		else if(s[t]>='0'&&s[t]<='9')
		{
			l*=10;
			l+=(s[t]-'0');
		}
		t++;
	}
	tree[x].l=(double)l+z;
	if(fl==1)tree[x].l=(-tree[x].l);
	t++;
	z=0,fl=0,ffl=0,l=0,o=1;//o从1开始 
	while(s[t]!=']')
	{
		if(s[t]=='-')fl=1;
		if(s[t]=='.')ffl=1;
		else if(ffl==1)
		{
			z+=(s[t]-'0')*pow(0.1,o);
			o++;
		}
		else if(s[t]>='0'&&s[t]<='9')
		{
			l*=10;
			l+=(s[t]-'0');
		}
		t++;
	}
	tree[x].r=(double)l+z;
	if(fl==1)tree[x].r=(-tree[x].r);
	if(tree[x].r<tree[x].l)swap(tree[x].l,tree[x].r);
	return t;
}

signed main()
{
//	ios::sync_with_stdio(0);
//	cin.tie(0);
//	cout.tie(0);//解绑
	you['=']=5;
	you['*']=4;
	you['/']=4;
	you['+']=3;
	you['-']=3;//中缀计算优先级
	while(cin>>s)
	{
		zo=0;
		int len=0;
		s='('+s;
		for(int i=1;i<s.size();++i)
		{
			if(s[i]=='[')
			{
				len++;
				i=read(len,i+1);
				q2.push(tree[len]);
			}
			else if(s[i]=='(')
			{
				q1.push('(');
			}
			else if(s[i]==')')
			{
				while(!q1.empty()&&q1.top()!='(')
				{
					solve();
					if(zo==1)//这里也可能遇到除法 
					{
						break;
					}	
				}
				if(zo==1)
				{
					break;//跳出第二层，忘记打上了 TAT 
				}//放pop前面 
				q1.pop();
			}
			/*--------------------------------------------------------*/
			else if(s[i]=='+')
			{
				while(!q1.empty()&&q1.top()!='('&&you[q1.top()]>=you[s[i]])//也可能在括号内运算 
				{
					solve();
					if(zo==1)//这里也可能遇到除法 
					{
						break;
					}
				}
				if(zo==1)
				{
					break;//跳出第二层，忘记打上了 TAT 
				}//放push前面 
				q1.push('+');
			}
			/*--------------------------------------------------------*/
			else if(s[i]=='-')
			{
				if(s[i-1]=='+'||s[i-1]=='-'||s[i-1]=='/'||s[i-1]=='*'||s[i-1]=='(')
				{
					q1.push('=');
				}
				else
				{
					while(!q1.empty()&&q1.top()!='('&&you[q1.top()]>=you[s[i]])
					{
						solve();
						if(zo==1)//这里也可能遇到除法 
						{
							break;
						}
					}
					if(zo==1)
					{
						break;//跳出第二层，忘记打上了 TAT 
					}
					q1.push('-');
				}
			}
			/*--------------------------------------------------------*/
			else if(s[i]=='*')
			{
				while(!q1.empty()&&q1.top()!='('&&you[q1.top()]>=you[s[i]])
				{
					solve();
					if(zo==1)//这里也可能遇到除法 
					{
						break;
					}
				}
				if(zo==1)
				{
					break;//跳出第二层，忘记打上了 TAT 
				}
				q1.push('*');
			}
			/*--------------------------------------------------------*/
			else if(s[i]=='/')
			{
				while(!q1.empty()&&q1.top()!='('&&you[q1.top()]>=you[s[i]])
				{
					solve();
					if(zo==1)
					{
						break;
					}
				}
				if(zo==1)
				{
					break;
				}
				q1.push('/');
			}
		}
		if(zo==1)
		{
			zo=0;
			cout<<"Division by zero"<<"\n";
			while(!q1.empty())q1.pop();
			while(!q2.empty())q2.pop();
			continue;
		}
		while(!q1.empty())
		{
			solve();
			if(zo==1)
			{
				break;
			}
		}
		if(zo==1)
		{
			zo=0;
			cout<<"Division by zero"<<"\n";
			while(!q1.empty())q1.pop();
			while(!q2.empty())q2.pop();//忘记初始化 
			continue;;
		}
		while(!q1.empty())q1.pop();
        if(abs(q2.top().l)==0)q2.top().l=abs(q2.top().l);
        if(abs(q2.top().r)==0)q2.top().r=abs(q2.top().r);//注意会输出"-0.000"
		printf("[%.3lf,%.3lf]\n",q2.top().l,q2.top().r);
		while(!q2.empty())q2.pop();
	}	
	return 0;
}
```

最后，感谢您的留步与观看。

# 修改日志

二零二五年三月八日，修正代码特判错误。感谢 [KobeBeanBryantCox](https://www.luogu.com.cn/user/865625) 提供的 Hack 数据

---

## 作者：Furina_Saikou (赞：2)

这题显然是大模拟，对于这种简单的表示式计算我们有通用做法。

# 思路

## 表达式处理

我们模拟中缀表达式转后缀表达式的过程，为了快速，我们可以在转后缀的同时计算。

先开两个栈分别存符号和区间，然后遍历字符串：

- 如果扫到运算符，先看栈顶符号的优先级是否大于等于当前符号，如果是，那就将栈顶的符号弹出并计算直到栈内没有优先级大于等于当前符号的，特别的，如果是取相反数，我们可以将相邻的两个取反符号抵消。
- 如果扫到区间，我们就将区间压入区间栈以便之后的计算。
- 如果扫到左括号，就直接压入符号栈。如果是右括号，就不停计算直到栈顶弹出对应的左括号。但是我脑抽一下，在程序中，我遇到括号直接递归括号内的内容，这样只用处理没有括号的表达式，属实是小题大做了。

## 区间的计算

对于区间，我们可以用 `pair` 存，也可以用结构体存，计算时可以直接写，也可以用重载运算符，我选直接写函数。假设有区间 $[a,b],[c,d]$，以下给出不同运算方法。

- 加法，得 $[a+c,b+d]$。
- 减法，得 $[a-d,b-c]$。
- 乘法，得 $[\min(ac,ad,bc,bd),\max(ac,ad,bc,bd)]$。
- 除法，得 $[\min(\frac ac,\frac ad,\frac bc,\frac bd),\max(\frac ac,\frac ad,\frac bc,\frac bd)]$。
- 区间 $[a,b]$ 取相反数，得 $[-b,-a]$。

在存符号的时候，为了区分减号和取相反数，我用了 `~` 代替（按位取反）（幽默）。

记得判遇到除以 $0$ 的情况。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline bool isfu(char &c)
{
	return c=='+'||c=='-'||c=='*'||c=='/';
}
inline void calc_back(stack<char>&f,stack<pair<double,double> >&num)
{
	static pair<double,double>a;
	while(!f.empty()&&f.top()=='~')
	{
		a=num.top();
		num.pop(),f.pop();
		num.push(make_pair(-a.second,-a.first));
	}
}
inline bool calc_mul(stack<char>&f,stack<pair<double,double> >&num)
{
	static pair<double,double>a,b;
	while(!f.empty()&&(f.top()=='*'||f.top()=='/'))
	{
		b=num.top();
		num.pop();
		a=num.top();
		num.pop();
		if(f.top()=='*')
		{
			double a1=a.first*b.first,a2=a.first*b.second,a3=a.second*b.first,a4=a.second*b.second;
			num.push(make_pair(min({a1,a2,a3,a4}),max({a1,a2,a3,a4})));
		}else
		{
			if(b.first<=0&&b.second>=0)return 1;
			double a1=a.first/b.first,a2=a.first/b.second,a3=a.second/b.first,a4=a.second/b.second;
			num.push(make_pair(min({a1,a2,a3,a4}),max({a1,a2,a3,a4})));
		}
		f.pop();
	}
	return 0;
}
inline void calc_plus(stack<char>&f,stack<pair<double,double> >&num)
{
	static pair<double,double>a,b;
	while(!f.empty()&&(f.top()=='+'||f.top()=='-'))
	{
		b=num.top();
		num.pop();
		a=num.top();
		num.pop();
		if(f.top()=='+')
		{
			num.push(make_pair(a.first+b.first,a.second+b.second));
		}else
		{
			num.push(make_pair(a.first-b.second,a.second-b.first));
		}
		f.pop();
	}
}
pair<double,double>solve(string s)
{
	stack<char>f;
	stack<pair<double,double> >num;
	int n=s.size();
	for(int i=0;i<n;i++)
	{
		if(s[i]=='(')
		{
			int cnt=1;
			string x="";
			while(++i<n)
			{
				if(s[i]=='(')cnt++;
				if(s[i]==')')cnt--;
				if(!cnt)break;
				x+=s[i];
			}
			num.push(solve(x));//递归处理括号
			if(num.top().first==1145141919810&&num.top().second==1145141919810)
			{
				return num.top();
			}
		}else if(s[i]=='-'&&(!i||isfu(s[i-1])))//去相反数符号的前面只可能是运算符
		{
			if(!f.empty()&&f.top()=='~')f.pop();
			else f.push('~');
		}else if(s[i]=='*'||s[i]=='/')
		{
			calc_back(f,num);
			if(calc_mul(f,num))
			{
				return make_pair(1145141919810,1145141919810);
			}
			f.push(s[i]);
		}else if(s[i]=='+'||s[i]=='-')
		{
			calc_back(f,num);
			if(calc_mul(f,num))
			{
				return make_pair(1145141919810,1145141919810);
			}
			calc_plus(f,num);
			f.push(s[i]);
		}else if(s[i]=='[')//其实用stringstream可以更优雅的解决
		{
			static pair<double,double>x;
			x.first=x.second=0;
			static double w,p;
			if(s[++i]=='-')w=-1;
			else w=1,i--;
			while(s[++i]>='0'&&s[i]<='9')x.first=x.first*10+s[i]-'0';
			if(s[i]=='.')
			{
				p=0.1;
				while(s[++i]>='0'&&s[i]<='9')x.first+=p*(s[i]-'0');
			}
			x.first*=w;
			if(s[++i]=='-')w=-1;
			else w=1,i--;
			while(s[++i]>='0'&&s[i]<='9')x.second=x.second*10+s[i]-'0';
			if(s[i]=='.')
			{
				p=0.1;
				while(s[++i]>='0'&&s[i]<='9')x.second+=p*(s[i]-'0');
			}
			x.second*=w;
			if(x.first>x.second)swap(x.first,x.second);
			num.push(x);
		}
	}
	calc_back(f,num);
	if(calc_mul(f,num))
	{
		return make_pair(1145141919810,1145141919810);
	}
	calc_plus(f,num);
	return num.top();
}
signed main()
{
	string s;
	pair<double,double>x;
	char c;
	while(c=getchar())
	{
		if(c==-1)break;
		s="";
		while(c!='\n')
		{
			if(c!=' ')s+=c;
			c=getchar();
		}
		x=solve(s);
		if(x.first==1145141919810&&x.second==1145141919810)
		{
			printf("Division by zero\n");
		}else
		{
			printf("[%.3lf,%.3lf]\n",x.first,x.second);
		}
	}
	return 0;
}
```

# 警钟撅烂

如果你错了第四个点，记得在输入区间时判断是否左边小于右边。

---

## 作者：CASCwty (赞：2)

$update:2025.3.8$

> 本题解进行了修改，对于 $-0.000$ 的情况进行了修改。同时感谢[KobeBeanBryantCox](https://www.luogu.com.cn/user/865625)的提醒。

## 题目大意

给定一个区间运算的表达式，让你按照规则进行运算得出结果。如果有一个区间运算形如：$\frac {[a,b]}{[c,d]}$ 并且 $[c.d]$ 里面包含 $0$，就输出 `Division by zero`。

## 总体思路

首先，我们分析一下运算的规则和求解方法：

- $[a,b]+[c,d]=[a+c,b+d]$
- $[a,b]-[c,d]=[a-d,b-c]$
- $[a,b] \times [c,d]=[\min(ac,ad,bc,bd),\max(ac,ad,bc,bd))$
- $\frac{[a,b]}{[c,d]}=[\min(\frac{a}{c},\frac{a}{d},\frac{b}{c},\frac{b}{d}),\max(\frac{a}{c},\frac{a}{d},\frac{b}{c},\frac{b}{d})]$
- $![a,b]=[-b,-a]$（这里的取反使用 `!` 进行标记）
- 对于区间 $[a,b]$，如果作为除数是包含 $0$，那么 $a \times b \le 0$。

综上，写出结构体储存与运算模块：

```cpp
struct Node{
	double l,r;
	bool check(){return (l*r<=0);}
	Node operator + (Node a){return {l+a.l,r+a.r};}
	Node operator - (Node a){return {l-a.r,r-a.l};}
	Node operator * (Node a){return {min({l*a.l,l*a.r,r*a.l,r*a.r}),max({l*a.l,l*a.r,r*a.l,r*a.r})};}
	Node operator / (Node a){return {min({l/a.l,l/a.r,r/a.l,r/a.r}),max({l/a.l,l/a.r,r/a.l,r/a.r})};}
	Node operator ! (){return {-r,-l};}
};
```

其次，将中缀表达式转后缀表达式，没学过的可以参见[这里](https://blog.csdn.net/TiSg0/article/details/130970655?)（反正我觉得讲的挺好的）。具体过程就不详细说明，主要有以下几点：

- 如果栈顶的字符优先级高于或等于现在进入栈的符号的优先级，就一直计算直到不满足不满足上文条件为止。
- 读入右括号之后，一直计算到左括号出现，然后停止计算。
- 中间一定要记得判断除法区间包含 $0$ 这个情况。
- **小小的警告**：有一个点给出的区间不保证左边界小于右边界。

其余就按照中缀转后缀模拟即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct Node{
	double l,r;
	bool check(){return (l*r<=0);}
	Node operator + (Node a){return {l+a.l,r+a.r};}
	Node operator - (Node a){return {l-a.r,r-a.l};}
	Node operator * (Node a){return {min({l*a.l,l*a.r,r*a.l,r*a.r}),max({l*a.l,l*a.r,r*a.l,r*a.r})};}
	Node operator / (Node a){return {min({l/a.l,l/a.r,r/a.l,r/a.r}),max({l/a.l,l/a.r,r/a.l,r/a.r})};}
	Node operator ! (){return {-r,-l};}
};
string s;
stack<char>fh;
stack<Node>data;
map<char,int>high;
bool division=false;
int read(int now)
{
	bool point=false;
	bool zf=false;
	Node ret;
	int a1,a2,cnt;
	a1=0;
	a2=0;
	cnt=0;
	int i;
	for(i=now;i<s.length();i++)
	{
		if(s[i]=='-')zf=true;
		if(s[i]>='0' && s[i]<='9')
		{
			if(point)a2=a2*10+(s[i]-'0'),cnt++;
			else a1=a1*10+(s[i]-'0');
		}
		if(s[i]=='.')point=true;
		if(s[i]==',')
		{
			point=false;
			ret.l=a1+a2*1.0/pow((int)10,cnt);
			if(zf)ret.l=-ret.l;
			zf=false;
			a1=0;
			a2=0;
			cnt=0;
		}
		if(s[i]==']')
		{
			ret.r=a1+a2*1.0/pow((int)10,cnt);
			if(zf)ret.r=-ret.r;
			break;
		}
	}
	if(ret.l>ret.r)swap(ret.l,ret.r);
	data.push(ret);
	return i;
}
void cal()
{
	char tp=fh.top();
	fh.pop();
	if(tp=='+')
	{
		Node a=data.top();
		data.pop();
		Node b=data.top();
		data.pop();
		data.push(b+a);
	}
	if(tp=='-')
	{
		Node a=data.top();
		data.pop();
		Node b=data.top();
		data.pop();
		data.push(b-a);
	}
	if(tp=='*')
	{
		Node a=data.top();
		data.pop();
		Node b=data.top();
		data.pop();
		data.push(b*a);
	}
	if(tp=='/')
	{
		Node a=data.top();
		data.pop();
		Node b=data.top();
		data.pop();
		if(a.check())
		{
			division=true;
			return;
		}
		data.push(b/a);
	}
	if(tp=='!')
	{
		Node a=data.top();
		data.pop();
		data.push(!a);
	}
}
void init()
{
	high['+']=high['-']=1;
	high['*']=high['/']=2;
	high['!']=3;
	high['(']=4;
}
void change()
{
	string ret="";
	for(int i=0;i<s.length();i++)
		if(s[i]!=' ')
			ret+=s[i];
	s=ret;
}
signed main()
{
	init(); 
	while(getline(cin,s))
	{
		change();
		division=false;
		for(int i=0;i<s.length();i++)
		{
			if(s[i]=='[')
				i=read(i);
			if(s[i]==')')
			{
				if(fh.top()=='(')fh.pop();
				else
				{
					while(!fh.empty() && fh.top()!='(' && high[fh.top()]>=high[s[i]])
					{
						cal();
						if(division)
						{
							printf("Division by zero\n");
							break;
						}
					}
					fh.pop();
				}
			}
			else if(s[i]!=']')
			{
				char ys=s[i];
				if(ys=='-' && (i==0||s[i-1]!=']'&&s[i-1]!=')'))ys='!';
				while(!fh.empty() && fh.top()!='('&&high[fh.top()]>=high[ys])
				{
					cal();
					if(division)
					{
						printf("Division by zero\n");
						break;
					}
				}
				if(s[i]=='-' && (i==0||(s[i-1]!=']'&&s[i-1]!=')')))
				{
					fh.push('!');
				}
				else fh.push(s[i]);
			}
			if(division)
			{
				break;
			}
		}
		if(division)
		{
			while(!fh.empty())fh.pop();
			while(!data.empty())data.pop();
		}
		else
		{
			while(!fh.empty())
			{
				cal();
				if(division)
				{
					printf("Division by zero\n");
					break;
				}
			}
			if(division)
			{
				while(!fh.empty())fh.pop();
				while(!data.empty())data.pop();
			}
			if(division)continue;
			if(abs(data.top().l)==0)data.top().l=0;
			if(abs(data.top().r)==0)data.top().r=0;
			printf("[%.3lf,%.3lf]\n",data.top().l,data.top().r);
			data.pop();
		}
	}
	return 0;
 }
```

## 警钟撅烂

千万不要开了 `ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);`，然后又把 `printf` 和 `cout` 一起用，不然会寄。

---

## 作者：LKY928261 (赞：1)

## 题目分析

本题是一道大模拟，码量较大（3KB）但思维难度低，直接用栈维护表达式的运算即可。

### 整体读入

为什么连读入都要单独拎出来讲呢？因为~~我太菜了~~这题在读入时会有一些多余的空格，要将其去掉；读入也没有固定的行数，需要额外的处理。

在这里我选用了 `getchar()` 来读入字符，读入普通字符时存入字符串，读入空格时直接忽略，读入换行则处理当前字符串并将字符串清零，若无输入则结束程序。

当然这仅仅只是众多读入方法中的一种，你也可以选用其它的方法。

```cpp
while(ch=getchar()){
	if(ch==-1)break;//读入结束
	else if(ch=='\n'){if(s!="")work();s="";}//出现换行符时处理当前字符串
	else if(ch!=' ')s+=ch;//过滤掉空格
}
```

### 函数内部的区间读入

对于每个区间的读入，我们采用与快读类似的方式读入两个数并入栈。

注意到读入的数可能是负数或小数，要多加几句判断。

快读应该没人不会吧。。。

```cpp
double x=0.0,y=0.0,z,t=1.0;
if(s[++i]=='-')t=-1.0,++i;//负数
for(;s[i]>='0'&&s[i]<='9';i++)x=x*10+(s[i]-48);//整数部分
if(s[i]=='.')for(z=0.1,i++;s[i]>='0'&&s[i]<='9';i++,z/=10)x=x+z*(s[i]-48);//小数部分（只在有小数点时读入）
x*=t;t=1.0;
if(s[++i]=='-')t=-1.0,++i;//第二个数，同上
for(;s[i]>='0'&&s[i]<='9';i++)y=y*10+(s[i]-48);
if(s[i]=='.')for(z=0.1,i++;s[i]>='0'&&s[i]<='9';i++,z/=10)y=y+z*(s[i]-48);
y*=t;
if(s[i]==']')a[tp]={min(x,y),max(x,y)};//入栈，为了防止出现前大后小的情况，保险起见加上 min 和 max
if(b[tp]=='^')a[tp-1]=-a[tp],--tp;//处理读入区间的前置负号
```

### 区间处理

这里采用结构体形式来处理四则运算和判零、输出的操作。

减法可以用加相反数表示，所以我没写减法运算（懒）。

```cpp
struct node{
	double x,y;
	void write(){printf("[%.3f,%.3f]\n",fabs(x)<0.0005?0:x,fabs(y)<0.0005?0:y);}//输出
	bool zero(){return x*y<=0;}//判断是否包含零
	node operator-()const{return {-y,-x};}//取相反数
	node operator+(const node &t)const{return {x+t.x,y+t.y};}//加
	node operator*(const node &t)const{return {min(min(x*t.x,x*t.y),min(y*t.x,y*t.y)),max(max(x*t.x,x*t.y),max(y*t.x,y*t.y))};}//乘
	node operator/(const node &t)const{return {min(min(x/t.x,x/t.y),min(y/t.x,y/t.y)),max(max(x/t.x,x/t.y),max(y/t.x,y/t.y))};}//除
};
```

### 符号入栈时的处理

若是左括号，直接入栈即可，不再赘述。

由于不能把所有运算都堆在一块处理，再加上累积着容易爆栈，所以在加减乘除及右括号这些符号入栈时，都需要将之前的一部分运算处理掉。

注意在运算符是乘或除时，不能把前面的加减法处理掉。

```cpp
while(b[tp]=='*')a[tp-1]=a[tp-1]*a[tp],--tp;
while(b[tp]=='/'){
	if(a[tp].zero()){printf("Division by zero\n");return;}
	a[tp-1]=a[tp-1]/a[tp];--tp;
}
while(b[tp]=='+')a[tp-1]=a[tp-1]+a[tp],--tp;
while(b[tp]=='-')a[tp-1]=a[tp-1]+-a[tp],--tp;
b[++tp]=s[i];
```

P.S. 因为处理时栈顶最多只有一个相同的符号，所以可以用 `if` 代替 `while`。

### 细节

- 手写栈别出锅；（没错，就是我 QwQ）
- 循环结束后要把还在栈内的未处理操作处理了再输出；
- 注意区分减号和负号；
- 注意判断除数含零的情况；
- 当出现负号或括号时，不能把前一个符号顶掉；
- 不要让你的程序忽视括号/区间前的负号。

## 完整代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
	double x,y;
	void write(){printf("[%.3f,%.3f]\n",fabs(x)<0.0005?0:x,fabs(y)<0.0005?0:y);}
	bool zero(){return x*y<=0;}
	node operator-()const{return {-y,-x};}
	node operator+(const node &t)const{return {x+t.x,y+t.y};}
	node operator*(const node &t)const{return {min(min(x*t.x,x*t.y),min(y*t.x,y*t.y)),max(max(x*t.x,x*t.y),max(y*t.x,y*t.y))};}
	node operator/(const node &t)const{return {min(min(x/t.x,x/t.y),min(y/t.x,y/t.y)),max(max(x/t.x,x/t.y),max(y/t.x,y/t.y))};}
};
ll n,tp,i;string s;node a[1000005];char ch,b[1000005];
void work(){
	tp=0;
	for(i=0;i<s.size();i++){
		if(s[i]=='(')b[++tp]='(';
		else if(s[i]==')'){
			while(b[tp]=='*')a[tp-1]=a[tp-1]*a[tp],--tp;
			while(b[tp]=='/'){
				if(a[tp].zero()){printf("Division by zero\n");return;}
				a[tp-1]=a[tp-1]/a[tp];--tp;
			}
			while(b[tp]=='+')a[tp-1]=a[tp-1]+a[tp],--tp;
			while(b[tp]=='-')a[tp-1]=a[tp-1]+-a[tp],--tp;
			a[tp-1]=a[tp];--tp;
			if(b[tp]=='^')a[tp-1]=-a[tp],--tp;
		}
		else if(s[i]=='+'){
			while(b[tp]=='*')a[tp-1]=a[tp-1]*a[tp],--tp;
			while(b[tp]=='/'){
				if(a[tp].zero()){printf("Division by zero\n");return;}
				a[tp-1]=a[tp-1]/a[tp];--tp;
			}
			while(b[tp]=='+')a[tp-1]=a[tp-1]+a[tp],--tp;
			while(b[tp]=='-')a[tp-1]=a[tp-1]+-a[tp],--tp;
			b[++tp]='+';
		}
		else if(s[i]=='-'){
			if(i==0||s[i-1]!=']')b[++tp]='^';
			else{
				while(b[tp]=='*')a[tp-1]=a[tp-1]*a[tp],--tp;
				while(b[tp]=='/'){
					if(a[tp].zero()){printf("Division by zero\n");return;}
					a[tp-1]=a[tp-1]/a[tp];--tp;
				}
				while(b[tp]=='+')a[tp-1]=a[tp-1]+a[tp],--tp;
				while(b[tp]=='-')a[tp-1]=a[tp-1]+-a[tp],--tp;
				b[++tp]='-';
			}
		}
		else if(s[i]=='*'||s[i]=='/'){
			while(b[tp]=='*')a[tp-1]=a[tp-1]*a[tp],--tp;
			while(b[tp]=='/'){
				if(a[tp].zero()){printf("Division by zero\n");return;}
				a[tp-1]=a[tp-1]/a[tp];--tp;
			}
			b[++tp]=s[i];
		}
		else if(s[i]=='['){
			double x=0.0,y=0.0,z,t=1.0;
			if(s[++i]=='-')t=-1.0,++i;
			for(;s[i]>='0'&&s[i]<='9';i++)x=x*10+(s[i]-48);
			if(s[i]=='.')for(z=0.1,i++;s[i]>='0'&&s[i]<='9';i++,z/=10)x=x+z*(s[i]-48);
			x*=t;t=1.0;
			if(s[++i]=='-')t=-1.0,++i;
			for(;s[i]>='0'&&s[i]<='9';i++)y=y*10+(s[i]-48);
			if(s[i]=='.')for(z=0.1,i++;s[i]>='0'&&s[i]<='9';i++,z/=10)y=y+z*(s[i]-48);
			y*=t;
			if(s[i]==']')a[tp]={min(x,y),max(x,y)};
			if(b[tp]=='^')a[tp-1]=-a[tp],--tp;
		}
	}
	while(b[tp]=='*')a[tp-1]=a[tp-1]*a[tp],--tp;
	while(b[tp]=='/'){
		if(a[tp].zero()){printf("Division by zero\n");return;}
		a[tp-1]=a[tp-1]/a[tp];--tp;
	}
	while(b[tp]=='+')a[tp-1]=a[tp-1]+a[tp],--tp;
	while(b[tp]=='-')a[tp-1]=a[tp-1]+-a[tp],--tp;
	a[0].write();
}
int main(){
	while(ch=getchar()){
		if(ch==-1)break;
		else if(ch=='\n'){if(s!="")work();s="";}
		else if(ch!=' ')s+=ch;
	}
}
```

---

## 作者：KobeBeanBryantCox (赞：1)

# P1812 区间运算 题解

[题目传送门](https://www.luogu.com.cn/problem/P1812)。

截止至 2025-03-07：

1. Hack 全部 $6$ 篇 c++ 题解（py 的测不了，数据在最后）；
2. 压一点点行的代码，行数为 $52$，1.57K，目前第二短解；
3. 格式化后的代码，行数 $106$，1.95K，目前最快解。

同时本篇题解将给出数据生成器方便对拍。

但我觉得题目出的不好，每一行才 $80$ 字符，也不告诉我行数。然后也不告诉我数字的大小，万一有个什么[高精度](https://www.luogu.com.cn/paste/lo4klajm)……

---------------

## 题意

你需要实现中缀表达式的区间运算，运算规则如下：

1. $-[a,b]=[-b,-a]$；
2. $[a,b]+[c,d]=[a+c,b+d]$；
3. $[a,b]-[c,d]=[a-d,b-c]$；
4. $[a,b]\times[c,d]=[\min\{ac,bc,ad,bd\},\max\{ac,bc,ad,bd\}]$；
5. $[a,b]\div[c,d]=[\min\{\dfrac a c,\dfrac b c,\dfrac a d,\dfrac b d\},\max\{\dfrac a c,\dfrac b c,\dfrac a d,\dfrac b d\}]$，其中 $c\times d>0$（即不经过 $0$）。

--------------

## 思路

注意到[这个题](https://www.luogu.com.cn/problem/P1175)，我们把题目中的数字换成区间即可。

~~做完了，上代码。~~

作为一篇题解肯定不能这么水的吧，所以我来讲讲不用转成后缀表达式的做法。

考虑怎么直接用中缀表达式做。

肯定要定义一个区间结构体：

```cpp
struct I
{
	double x,y;
	void input(){scanf("%lf,%lf]",&x,&y);if(x>y)swap(x,y);}
	void output(){printf("[%.3lf,%.3lf]\n",(x==0?0:x),(y==0?0:y));} // 会有输出 -0 的情况，要特判成 0。现有的 5 篇题解都是因为这个挂了。
	I operator+(I &a){return {x+a.x,y+a.y};}
	I operator-(I &a){return {x-a.y,y-a.x};}
	I operator*(I &a){return {min({x*a.x,x*a.y,y*a.x,y*a.y}),max({x*a.x,x*a.y,y*a.x,y*a.y})};}
	I operator/(I &a)
	{
		if(a.x*a.y<=0)throw "Division by zero"; // 除 0，返回错误。
		return {min({x/a.x,x/a.y,y/a.x,y/a.y}),max({x/a.x,x/a.y,y/a.x,y/a.y})};
	}
	I operator~(){return {-y,-x};}
};
```

不同于后缀形式，由于我们对两个区间进行运算，所以我们要等到读入区间（而不是操作符）的时候再操作。

维护两个栈，一个是区间，一个是操作符。

为区别于减号，负号我写的是 `~`。

由于取相反数的优先级最高，我们不妨在插入的时候直接判断其前面是否有取反符号。

```cpp
stack<I>a;stack<char>op;
void push(I x){if(!op.empty()&&op.top()=='~')op.pop(),x=~x;a.push(x);}
```

考虑怎么计算。

由于是从左往右计算，我们必须递归到最左边不满足条件的，然后往右计算。

“条件”具体看代码。

```cpp
int pri[150];bool ok;
void init(){pri['+']=pri['-']=1,pri['*']=pri['/']=2;} // 初始化优先级。
bool calc(int P) // 传入优先级。
{
	if(op.empty()||op.top()=='(')return true; // 没有符号或者是左括号，此时无论如何都不能继续了。
	int c=op.top();I y=a.top();
	if(pri[c]!=P)return true; // 与需要操作的优先级不符。
	op.pop(),a.pop(),ok&=calc(P); // 先取出，递归左边。
	I x=a.top();a.pop();
	if(c=='+')push(x+y);
	else if(c=='-')push(x-y);
	else if(c=='*')push(x*y);
	else if(c=='/')
		try{push(x/y);}
		catch(const char *wrong){if(ok)printf("%s\n",wrong),ok=false;push({1,1});} // 注意，哪怕是不合法，也要随便压入一个元素进栈，让它算完，才不会 RE。
	return ok;
}
```

每一次读到区间，查询操作符栈顶，如果是 $\times$ 或 $\div$，直接计算这个区间与前一个区间的结果。

```cpp
if(c=='['){I x;x.input(),push(x),ok&=calc(2);} // 计算优先级为 2 的。
```

然后遇到右括号，一直计算到左边第一个左括号的位置，此时整个括号内的表达式优先级一定都是 $1$，因为我们已经提前把 $2$ 算过了。

注意算完括号后还要继续计算优先级为 $2$ 的区间，因为可能有这种情况：$[\dots]\times(\dots)$。

```cpp
else if(c==')'){ok&=calc(1),op.pop();/*要弹出左括号。*/I t=a.top();a.pop(),push(t),ok&=calc(2);} // 有个小细节，有可能出现 -([...]..[...])，此时我们要把栈顶区间拿出来判断前面是否有取反，重新压入。
```

然后读到减号，我们要判断是负号还是减号。

如果前面输入的是区间或者右括号，那么一定是减号，否则都是负号。所以我们还要记录一个前面输入的字符。

```cpp
else if(c=='-')
	if(las=='['||las==')')op.push('-');
	else op.push('~');
```

最后乱搞即可。

```cpp
else if(c=='+'||c=='*'||c=='/'||c=='(')op.push(c);
```

然后我们算完主体部分，剩下的还会有优先级为 $1$ 的操作还没算。直接计算即可。

```cpp
if(!a.empty()){ok&=calc(1);if(ok)a.top().output();a.pop();} // 判断 !a.empty() 是因为有可能输入一个空行，此时不应该进行任何操作。
```

主函数初始化即可。

```cpp
int main(){init();while(work());return 0;}
```

时间复杂度是 $O(n)$ 的，其中 $n$ 是输入串的长度。

------------

## AC 代码

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
struct I
{
	double x,y;
	void input(){scanf("%lf,%lf]",&x,&y);if(x>y)swap(x,y);}
	void output(){printf("[%.3lf,%.3lf]\n",(x==0?0:x),(y==0?0:y));}
	I operator+(I &a){return {x+a.x,y+a.y};}
	I operator-(I &a){return {x-a.y,y-a.x};}
	I operator*(I &a){return {min({x*a.x,x*a.y,y*a.x,y*a.y}),max({x*a.x,x*a.y,y*a.x,y*a.y})};}
	I operator/(I &a)
	{
		if(a.x*a.y<=0)throw "Division by zero";
		return {min({x/a.x,x/a.y,y/a.x,y/a.y}),max({x/a.x,x/a.y,y/a.x,y/a.y})};
	}
	I operator~(){return {-y,-x};}
};stack<I>a;stack<char>op;
void push(I x){if(!op.empty()&&op.top()=='~')op.pop(),x=~x;a.push(x);}
int pri[150];bool ok;
void init(){pri['+']=pri['-']=1,pri['*']=pri['/']=2;}
bool calc(int P)
{
	if(op.empty()||op.top()=='(')return true;
	int c=op.top();I y=a.top();
	if(pri[c]!=P)return true;
	op.pop(),a.pop(),ok&=calc(P);
	I x=a.top();a.pop();
	if(c=='+')push(x+y);
	else if(c=='-')push(x-y);
	else if(c=='*')push(x*y);
	else if(c=='/')
		try{push(x/y);}
		catch(const char *wrong){if(ok)printf("%s\n",wrong),ok=false;push({1,1});}
	return ok;
}
bool work()
{
	char c=getchar(),las=0;ok=true;
	for(;c!='\n'&&c!=EOF;las=c,c=getchar())
		if(c=='['){I x;x.input(),push(x),ok&=calc(2);}
		else if(c=='-')
			if(las=='['||las==')')op.push('-');
			else op.push('~');
		else if(c==')'){ok&=calc(1),op.pop();I t=a.top();a.pop(),push(t),ok&=calc(2);}
		else if(c=='+'||c=='*'||c=='/'||c=='(')op.push(c);
	if(!a.empty()){ok&=calc(1);if(ok)a.top().output();a.pop();}
	return c!=EOF;
}
int main(){init();while(work());return 0;}
```

~~鉴于读者可能不喜欢毒瘤码风，放一个格式化后的[版本](https://www.luogu.com.cn/record/206436965)。~~

-----------------

## 【造福后人】

Hack 数据：

输入：

```text
(((([1,2]))))
(([1,1]+-[1,1])*[-1,1])
([1,2]+[1,1])/[3,1]
[68,23]-([36,64]-[8,68]-([7,39]+[9,79]))
[1,2]/[-1,1]/[-1,1]
-(-[-1,-1]--[-1,-1])
-[-2,-1]*(-[7,7]+[8,-0])
```

输出：

```text
[1.000,2.000]
[0.000,0.000]
[0.667,3.000]
[-17.000,218.000]
Division by zero
[0.000,0.000]
[-14.000,2.000]
```

可能错误的输出（为方便查看，每一个输入对应的答案空一行写）：

```text
[1.000,2.000] // 但是栈内并不是空的

RE

[0.666,3.000] // 没四舍五入

略。// 错因很多，多半是优先级没搞好

Division by zero
Division by zero // 有两个除法不合法，输出了两次

[-0.000,-0.000] // 没判 -0
或者 [2.000,2.000] // 没考虑左括号前后的负号

略。// 错因很多，多半是负号没搞好
```

---------------

## 【真 $\cdot$ 造福后人】

数据生成器如下（魔改的这个[博客](https://www.cnblogs.com/Reverist/articles/16742841.html)的代码，侵权请联系删除）:

```cpp
#include <bits/stdc++.h>
using namespace std;

bool randomNumCount = 0;
// 可以接受的值：0 或 1，0 表示在 2 到 numMaxCount 范围内随机一个，1 表示使用 numMaxCount
int numMaxCount = 5;
// 可接受范围：2 ~ 300000000，表示生成的最大数字个数
int numMaxLength = 2;
// 可接受范围：1 ~ 9，但是大于 9 也行。表示一个数字最大位数，填进去 2147483647 恶心做题人也不是不可以

int pr[129]; // 运算优先级表
void init()
{
	// operators priority
	// + == - <= * == / <= ^ <= ...... < ()
	// pr[(char)] -> pr[(ASCII)]
	pr['+'] = 1;
	pr['-'] = 1;
	pr['*'] = 2;
	pr['/'] = 2;
}

queue<string> randsuffix()
{ // 随机生成后缀表达式
	queue<string> ret;
	string s;
	int r;
	if (randomNumCount)
	{
		numMaxCount -= 1;
		if (numMaxCount <= 0)
			numMaxCount = 1;
		r = 2 + (((rand() * 10000) + rand()) % numMaxCount);
		// rand 范围为 0 ~ 32767
		// 所以理论上随机最大可以生成 327702768
	}
	else
	{
		if (numMaxCount <= 1)
			numMaxCount = 2;
		r = numMaxCount;
	}
	numMaxLength = max(numMaxLength, 1);
	int ops = 0;
	for (int i = 1; i <= r; i++)
	{
		// 生成数字
		int dg = 1 + (rand() % numMaxLength);
		bool tit = 1;
		s = "";
		while (dg--)
		{
			if (tit == 1)
			{ // 避免前导 0
				s += char(49 + (rand() % 9));
				tit = 0;
			}
			else
			{
				s += char(48 + (rand() % 10));
			}
		}
		ret.push(s);
		s = "";
		// 随机生成符号
		if (ops < 2 * i / 3 && (rand() % 3) == 0)
		{
			int op = (rand() % 4);
			if (op == 0)
				s += "+";
			if (op == 1)
				s += "-";
			if (op == 2)
				s += "*";
			if (op == 3)
				s += "/";
			ret.push(s);
			s = "";
			ops++;
		}
	}
	// 最后补齐符号
	for (; ops < r - 1; ops++)
	{
		int op = (rand() % 4);
		if (op == 0)
			s += "+";
		if (op == 1)
			s += "-";
		if (op == 2)
			s += "*";
		if (op == 3)
			s += "/";
		ret.push(s);
		s = "";
	}
	return ret;
}
#define psi pair<string, int>
#define str first
#define pri second
#define mp make_pair
signed main()
{
	init();
	srand((unsigned)time(NULL));
	queue<string> q = randsuffix();
	stack<psi> s;
	while (!q.empty())
	{
		// cout << q.size () << endl;
		psi tmp;
		tmp.str = q.front();
		q.pop();
		if (!isdigit(tmp.str[0]))
		{
			tmp.pri = pr[tmp.str[0]];
			psi t2 = s.top();
			s.pop();
			psi t1 = s.top();
			s.pop();
			psi ret;
			if (t1.pri < tmp.pri)
			{ // 判断前面需不需要加括号
				ret.str += "(" + t1.str + ")";
			}
			else
			{
				ret.str += t1.str;
			}
			ret.str += tmp.str;
			if (t2.pri < tmp.pri ||						 // 判断后面需不需要加括号
				(tmp.str == "/" && t2.pri <= tmp.pri) || // 特判除法
				(tmp.str == "-" && t2.pri <= tmp.pri))
			{ // 特判减法
				ret.str += "(" + t2.str + ")";
			}
			else
			{
				ret.str += t2.str;
			}
			ret.pri = tmp.pri; // 更新运算优先级
			s.push(ret);
		}
		else
		{
			tmp.pri = 9999999; // 数字的运算优先级是最大的
			s.push(tmp);
		}
	}
	psi ans = s.top();
	// cout << ans.str << "\n";
	string ss = ans.str;
	for (int i = 0; i < ss.size(); i++) // 将数字转换成区间并输出
	{
		if (isdigit(ss[i]))
		{
			if (rand() % 2)
				putchar('-');
			putchar('[');
			if (rand() % 2)
				putchar('-');
			for (; isdigit(ss[i]) && i < ss.size(); i++)
				putchar(ss[i]);
			putchar(',');
			if (rand() % 2)
				putchar('-');
			printf("%d", rand() % (int)(pow(10, numMaxLength))), putchar(']');
		}
		if (i < ss.size())
			putchar(ss[i]);
	}
	putchar('\n');
}
```

若有错误或不清楚，欢迎私信或评论指出。

---

## 作者：Hzxleo4 (赞：1)

我是用了分治的思想，先处理取反， 再处理括号， 再处理乘除， 最后加减


每个区间（包括括号） 对应一个左端点 和 右端点 然后 就 递归 加 模拟就行了



```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define max(a, b) ((a)>(b)?(a):(b))
#define min(a, b) ((a)<(b)?(a):(b))
#define inf 2147483647
using namespace std;
struct node{
    double a, b;
}d[105][105];
char s[105];
int f[105], re[105];
int mp[105][105];
int len, flag;
node tmp;
node work(char c, node a, node b){
    node ans3;
    if(c == '*'){
        ans3.a = min(a.a*b.a,min(a.a*b.b, min(a.b*b.a, a.b*b.b)));
        ans3.b = max(a.a*b.a,max(a.a*b.b, max(a.b*b.a, a.b*b.b)));
    }
    if(c == '/'){
        ans3.a = min(a.a/b.a,min(a.a/b.b, min(a.b/b.a, a.b/b.b)));
        ans3.b = max(a.a/b.a,max(a.a/b.b, max(a.b/b.a, a.b/b.b)));
    }
    if(c == '+'){
        ans3.a = min(a.a+b.a,min(a.a+b.b, min(a.b+b.a, a.b+b.b)));
        ans3.b = max(a.a+b.a,max(a.a+b.b, max(a.b+b.a, a.b+b.b)));
    }
    if(c == '-'){
        ans3.a = min(a.a-b.a,min(a.a-b.b, min(a.b-b.a, a.b-b.b)));
        ans3.b = max(a.a-b.a,max(a.a-b.b, max(a.b-b.a, a.b-b.b)));
    }
    return ans3;
}
node solve(int l, int r){
    int i, j, x, y;
    node ans, ans1, ans2, ans3;
    if(mp[l][r]) return d[l][r];
    mp[l][r] = 1;
    if(l >= r) return tmp;
    if(s[l] == '-'){
        ans3 = work(s[l], tmp, solve(l+1, r));
        d[l][r] = ans3;
        return d[l][r];
    }
    double a = 0, b = 0;
    for(i = l; i <= r; i++){
        if(s[i] == ')' && !re[i]){
            for(j = i-1; j >= l; j--){
                if(s[j] == '(' && !f[j]){
                    f[j] = i;
                    re[i] = j;
                    ans = solve(j+1, i-1);
                    if(flag) return tmp;
                    d[j][i].a = ans.a;
                    d[j][i].b = ans.b;
                    break;
                }
            }
        }
    }
    for(i = l; i <= r; i++){
        if(s[i] == '*' || s[i] == '/'){
            ans1 = solve(re[i-1], i-1);
            if(s[i+1] != '-') ans2 = solve(i+1, f[i+1]);
            else f[i+1] = f[i+2], ans2 = solve(i+1, f[i+1]);
            if(s[i] == '/' && (ans2.a * ans2.b < 0)) flag = 1;
            f[re[i-1]] = f[i+1];
            re[f[i+1]] = re[i-1];
            ans3 = work(s[i], ans1, ans2);
            d[re[i-1]][f[i+1]] = ans3;
        }
    }
    for(i = l; i <= r; i = f[i]+2){
        if(s[i] == '-') f[i] = f[i+1];
        j = f[i];
        if(i == l) ans3 = work('+', tmp, solve(i, j));
        else ans3 = work(s[i-1], ans3, solve(i, j));
    }
    d[l][r] = ans3;
    return d[l][r];
}
int main(){
    //freopen("interval.in", "r", stdin);
    //freopen("interval.out", "w", stdout);
    node ans;
    int i, j, a, b, k, v;
    double aa, bb, c = 0.1;
    while(scanf("%s", s+1) != EOF){
        flag = 0;
        len = strlen(s+1);
        memset(f, 0, sizeof(f));
        memset(re,0,sizeof(re));
        memset(mp, 0, sizeof(mp));
        for(i = 1; i <= 100; i++) 
            for(j = 1; j <= 100; j++) 
                d[i][j].a = d[i][j].b = 0;
        for(i = 1; i <= len; i++){
            aa = bb = 0;
            c = 0.1;
            if(s[i] == '['){
                j = i+1;
                v = 1;
                if(s[j] == '-') v = -1, j++;
                while(s[j] >= '0' && s[j] <= '9') aa = aa * 10 + s[j] - '0', j++;
                if(s[j] == '.'){
                    c = 0.1;
                    j++;
                    while(s[j] != ','){
                         aa += (s[j] - '0') * c;
                         c *= c;
                         j++;
                    }
                }
                aa *= v;
                v = 1;
                j++;
                if(s[j] == '-') v = -1, j++;
                while(s[j] >= '0' && s[j] <= '9') bb = bb * 10 + s[j] - '0', j++;
                if(s[j] == '.'){
                    c = 0.1;
                    j++;
                    while(s[j] != ']'){
                         bb += (s[j] - '0') * c;
                         c *= c;
                         j++;
                    }
                }
                bb *= v;
                d[i][j].a = aa;
                d[i][j].b = bb;
                f[i] = j;
                re[j] = i;
                mp[i][j] = 1;
            }
        }
        ans.a = ans.b = 0;
        ans = solve(1, len);
        if(flag) printf("Division by zero\n");
        else printf("[%.3lf,%.3lf]\n", ans.a, ans.b);
    }
    return 0;
}
```

---

## 作者：xiaozhao_ (赞：0)

猜你想要：[更好的阅读体验](https://www.luogu.com.cn/article/d1tnm975)。
## 题目大意：
给定多个以中缀表达式表达的区间运算，求出其最终答案。
## 思路：
很明显，只在中缀表达式的基础上加入区间运算便可 AC 本题。

**1.中缀表达式：**

对中缀表达式比较陌生的洛友可以先做一本通上的[这道题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1358) ~~（洛谷上没有中缀表达式模板题(lllQωQ)）~~。

- 对于一个没有区间运算的中缀表达式 $s$，我们首先需要知道运算优先级。读题可以很容易得出，运算优先级为 $\text{小括号} > \text{取相反数} > \text{乘除} > \text{加减}$。

- 其次，我们需要将中缀转后缀方便计算（我选择边转边算，这样方便处理）。先建立两个栈，分别是数字栈 $sp$ 和符号栈 $sc$。然后将读入到的数字和运算符分别依次存入 $sp$ 和 $sc$。当遇到 $sc_{top}$ 的优先级**大于等于** $s_i$ 的优先级时，我们需要不停得计算**直到 $sc_{top}$ 的优先级小于 $s_i$ 的优先级**，以保证高优先级的先运算。为什么是大于等于？好问题，比如说当该中缀表达式为 $8\times6\div4\times2$ 时，如果只是将运算优先级大于自己的先运算，那么最后计算的顺序就变成了先算 $4\times2$，很快就可以这**不符合**同级运算按从左到右的顺序的的规则。
- 小括号比较特殊，如果按按上面的方法遇到小括号时前面所有都会进行计算，这很明显是不对的，所以要特判。并且，对于**每一个**右括号，我们要**一直计算**到找到与它**对应的左括号**为止。
- 最后，我们只需计算转换后的后缀表达式即可得出最终答案。


**2.区间运算：**

不会区间运算的洛友走这边(☞ﾟヮﾟ)☞[区间运算详解](https://blog.csdn.net/m0_72410588/article/details/130811472)。

看完上面的链接就应该算是区间运算入门了，我直接写一下我们需要的内容：

对于两个区间 $[a,b]$ 和 $[c,d]$，它们的加减乘除运算结果分别为：
- 加法：$[a, b] + [c, d] = [a + c, b + d]$；
- 减法：$[a, b] - [c, d] = [a - d, b - c]$；
- 乘法：$[a, b]\times[c, d] = [min(ac, ad, bc, bd), max(ac, ad, bc, bd)]$；
- 除法：$[a, b]\div[c, d] = [min(\frac{a}{c}, \frac{a}{d},\frac{b}{c}, \frac{b}{d}), max(\frac{a}{c}, \frac{a}{d},\frac{b}{c}, \frac{b}{d})]$ (其中 $c$ 和 $d$ 不能包含 $0$)。

3.**注意**：
  
（1）一个包含 $0$ 的区间作为除数：
- 小学三年级的数学老师曾经告诉我们：“**除数不能为 $0$！**”区间运算也是如此。如何判断区间 $[a,b]$ 是否包含 $0$ 呢？已知 $0$ 是正数和负数的分界，那么包含 $0$ 的区间 $[a,b]$ 中要么 $a$ 与 $b$ 异号，要么 $a$ 或 $b$ 有一个数为 $0$。因此，**判断 $ab\le0$ 便可知道区间 $[a,b]$ 是否包含 $0$。**

（2）区分取相反数符号和减号：
- 如何区分减号和取反数符号？我认为，**一个意义为取相反数的减号只会出现在运算符后。**
-  为了方便后面的计算，我们遇到一个意义为取相反数的减号时将它的值定为 $1$。

## AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=92;
map<char,int> p{{'+',0},{'-',0},{'*',1},{'/',1},{1,2},{'(',9}}; //存储运算优先级。
struct pdd{double l,r;}sp[N]; //手写栈 si 存储区间 [l,r]。
bool z; //特判除数为 0 的情况。
char s[N],sc[N];
int n,t1,t2; //t1 为栈 si 的栈顶位置，t2 为 sc 的栈顶位置。
inline bool isnum(char c){return c>=48&&c<=57;} //判断是否为数字。
inline void readn(int &i,double &x){
	x=0;
	int z=0,t=0,cnt=0; //z 存储整数部分，t 存储小数部分，cnt 存储小数位数。 
	bool f=0;
	if(s[i]=='-') f=1;
	else z=s[i]^48;
	while(isnum(s[++i])) z=(z<<3)+(z<<1)+(s[i]^48);
	if(s[i]=='.') //注意，有小数点才会有小数部分。 
		while(isnum(s[++i])) t=(t<<3)+(t<<1)+(s[i]^48),cnt++;
	x=z+1.0*t/pow(10,cnt);
	if(f) x=-x;
} //读入浮点数。
inline void calc(){
	char op=sc[t2--];
	pdd t=sp[t1--];
	if(op==1){
		sp[++t1]={-t.r,-t.l};
		return;
	} //取相反数。
	double a=sp[t1].l,b=sp[t1].r,c=t.l,d=t.r;
	if(op=='+') sp[t1]={a+c,b+d};
	else if(op=='-') sp[t1]={a-d,b-c};
	else if(op=='*')
		sp[t1]={min(a*c,min(a*d,min(b*c,b*d))),max(a*c,max(a*d,max(b*c,b*d)))};
	else{
		if(c*d<=0){ //[c,d] 这个是个包含 0 的区间。
			z=1;
			return;
		}
		sp[t1]={min(a/c,min(a/d,min(b/c,b/d))),max(a/c,max(a/d,max(b/c,b/d)))};
	}
} //计算。
int main(){
	while(~scanf("%s",s)){
		z=t1=t2=0; //初始化。
		n=strlen(s);
		int num=0;
		for(int i=0;i<n;i++){
			if(s[i]=='['){ //读入区间。
				readn(++i,sp[++t1].l);
				readn(++i,sp[t1].r);
				if(sp[t1].l>sp[t1].r) swap(sp[t1].l,sp[t1].r); //保证 l<r。
			}else{
				if(s[i]==')'){ //遇到右括号时需要将整个括号内全部计算。
					while(!z&&sc[t2]!='(') calc();
					t2--;
				}else{ //剩下的只能是运算符。
					if(s[i]=='-'&&s[i-1]!=']'&&s[i-1]!=')') 
						s[i]=1; //把取相反数的看作一个自定义的符号方便区分。
					while(!z&&t2&&sc[t2]!='('&&p[sc[t2]]>=p[s[i]]) 
						calc(); //将优先级比自己高或等于自己的运算全部算了。
					sc[++t2]=s[i];
				}
			}
			if(z) break; //有除数包含零直接跳出循环。
		}
		while(!z&&t2) calc(); //把剩下的全部算完。
		if(z) printf("Division by zero");
		else printf("[%.3lf,%.3lf]",sp[1].l,sp[1].r);
		putchar(10);
	}
	return 0;
}
```

后序：题解有界，帮助无限，希望这篇题解可以帮助屏幕前的你ヾ(≧▽≦*)o。

---


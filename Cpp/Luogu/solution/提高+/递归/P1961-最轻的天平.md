# 最轻的天平

## 题目描述

天平的两边有时不一定只能挂物品，还可以继续挂着另一个天平，现在给你一些天平的情况和它们之间的连接关系，要求使得所有天平都能平衡所需物品的总重量最轻，一个天平平衡当且仅当“左端点的重量\*左端点到支点的距离=右端点的重量\*右端点到支点的距离”。注意题目中的输入保证这些天平构成一个整体。


## 说明/提示

【样例说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/k8lsxvj9.png)

## 样例 #1

### 输入

```
4
3 2 0 4
1 3 0 0
4 4 2 1
2 2 0 0```

### 输出

```
40```

# 题解

## 作者：Augen_stern (赞：8)

## Part 1：分析算法

由题可得：要想让一个天平平衡，首先要使得其左右天平平衡；

假设左右两边的最轻重量分别为 $W_1$，$W_2$，设该天平左右两边的比例为$L_1:L_2$；

而要想使得该天平衡，可能左边要放大倍数 $X$，右边要放大倍数 $Y$
则有以下关系式： $W_1\times L_1\times X=W_2\times L_2\times Y$;

即 $\dfrac{X}{Y}=\dfrac{W_2\times L_2}{W_1\times L_1}$，要想使天平重量最小，但必须把 $\dfrac{X}{Y}$ 化为最简分数；

所以需要求出 $W_2\times L_2$ 和 $W_1\times L_1$ 的最大公约数 $P$；

则 $X=\dfrac{W_2\times L_2}{P}$，$Y=\dfrac{W_1\times L_1}{P}$，整个天平的重量为 $W_1\times X+W_2\times Y$。

## Part 2：算法实现

经过分析我们可以来实现算法。

读入：

```cpp
long long x;
long long a[105][105]; // 不开龙龙见祖宗；
int k[105];
scanf("%lld",&x);
for(long long i=1; i<=x; i++) {
	scanf("%lld%lld%lld%lld",&a[i][1],&a[i][2],&a[i][3],&a[i][4]);
	k[a[i][3]]=1;
	k[a[i][4]]=1;
}
```

然后在树上找根：

```cpp
int root=0;
for(int i=1; i<=x; i++) {
	if(k[i]==0) root=i;
} // 有根树找根；
```

最后在这棵二叉树上遍历：

```
long long dfs(long long x) {
	if(x==0) return 1;
	long long left=dfs(a[x][3]); // 遍历左子树；
	long long right=dfs(a[x][4]); // 遍历右子树；
	long long P=__gcd(left*a[x][1],right*a[x][2]); // 求最大公因数 P；（直接用自带函数就行） 
	return left*right*a[x][2]/P+right*left*a[x][1]/P; // 得到总重量。
}
```

## Part 3：CODE

完整代码走一波：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#define INF 0x7fffffff;
using namespace std;
long long x;
long long a[105][105];
int k[105];
long long dfs(long long x) {
	if(x==0) return 1;
	long long left=dfs(a[x][3]);
	long long right=dfs(a[x][4]); // 左右树遍历；
	long long P=__gcd(left*a[x][1],right*a[x][2]); // 化简到最简分数；
	return left*right*a[x][2]/P+right*left*a[x][1]/P; // 得到总重量；
}
signed main() {
	scanf("%lld",&x);
	for(long long i=1; i<=x; i++) {
		scanf("%lld%lld%lld%lld",&a[i][1],&a[i][2],&a[i][3],&a[i][4]);
		k[a[i][3]]=1;
		k[a[i][4]]=1;
	} // 读入；
	int root=0;
	for(int i=1; i<=x; i++) {
		if(k[i]==0) root=i;
	} // 树上找根；
	printf("%lld",dfs(root)); // 搜索遍历并输出结果。
	return 0;
}
```

自给自足，丰衣足食！

2021.9.20 15:20 初稿成！

---

## 作者：Martin_MHT (赞：8)

##### 此题题解不多啊，让我这个蒟蒻献一下丑吧

首先题目中说**保证这些天平构成一个整体**

所以整个我们可以看作二叉树来处理

并且这些天平左右两边横杆的距离不是既约的

所以我们要处理成既约的

---

对于每一个天平，有两种情况：

1. 上面没有挂天平 

此时这个天平**左边的重量**为**右边的距离**，**右边的重量**为**左边的距离**  

   总重量就是两者之和。  

2.上面有挂天平

那么先递归处理出两边的重量

（一边有天平就是天平的重量，没有就是对应距离）

发现此时重量有可能不是平衡的。
所以我们要求出这两个重量的$lca$，  
设这个$lca$为$x$。

但这不是最终解。

发现，两边的重量变成$x$的倍数是不相等的，左倍数是$l$，右倍数是$r$。

所以我们要处理出这两个倍数，再求倍数的$lca$。

设这个$lca$为$y$。

那么左边重量为$\frac{xy}{l}$，右边重量为$\frac{xy}{r}$

正确性留给大佬们证明。

总复杂度$O(n)$

---

```cpp
#include <cstdio>
#define ll long long
inline ll gcd(ll a,ll b)
{return b?gcd(b,a%b):a;}
inline ll lca(ll a,ll b)
{return a*b/gcd(a,b);}
int n;bool in[110];
struct tp
{
	ll lx,rx,lt,rt;
}t[110];
ll dg(int w)
{
	ll lt=t[w].lt,rt=t[w].rt,lx=t[w].lx,rx=t[w].rx;
	if(!lt&&!rt){return lx+rx;}
	ll l=(lt?dg(lt):rx);
	ll r=(rt?dg(rt):lx);
	l=lca(l,rx),r=lca(r,lx);
	ll lb=l/rx,rb=r/lx;
	ll b=lca(lb,rb);
	return l*b/lb+r*b/rb;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%lld %lld %lld %lld",&t[i].lx,&t[i].rx,&t[i].lt,&t[i].rt);
		int g=gcd(t[i].lx,t[i].rx);
		t[i].lx/=g,t[i].rx/=g;
		in[t[i].lt]=in[t[i].rt]=1;//记录入度
	}
	int w=0;
	for(int i=1;i<=n;++i)
		if(!in[i])
		{
			w=i;break;
		}
   	//先从最底下的天平开始。
	printf("%lld",dg(w));
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

没有C++题解，我来写份。

其实就是构造一个二叉树，点权表示这个地方的最小重量。

点权计算：如果没有儿子，点权为1，如果有儿子，则

```cpp
ll g=(p[now]*L)*(q[now]*R)/gcd(p[now]*L,q[now]*R);
return g/p[now]+g/q[now];
```
返回值即点权，递归下去直接输出函数的值就行了。

```cpp
ll Build(int now){
    ll L=1,R=1;
    if(l[now]) L=Build(l[now]); 
    if(r[now]) R=Build(r[now]);
    ll g=(p[now]*L)*(q[now]*R)/gcd(p[now]*L,q[now]*R);
    return g/p[now]+g/q[now];
}
```
那么怎么找跟呢？

由于是树，所以只要找到那个入度为0的点就行了。

找到跟了，就可以开始建树了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const int maxn=111;
ll n,p[maxn],q[maxn],l[maxn],r[maxn],in[maxn],root;
ll gcd(int a,int b){
    return b==0?a:gcd(b,a%b);       //辗转相除不解释
}
ll Build(int now){
    ll L=1,R=1;
    if(l[now]) L=Build(l[now]); 
    if(r[now]) R=Build(r[now]);
    ll g=(p[now]*L)*(q[now]*R)/gcd(p[now]*L,q[now]*R);
    return g/p[now]+g/q[now];
}
int main(){
    n=read();
    rep(i,1,n)
       p[i]=read(),q[i]=read(),l[i]=read(),r[i]=read(),in[l[i]]=in[r[i]]=1;   //记录入度
    rep(i,1,n) if(!in[i]){ root=i;break; }  //找根
    printf("%lld\n",Build(root));
    return 0;
}
```

---

## 作者：Victorique_De_Blois (赞：3)



前置知识：gcd,lca,递归，树的遍历【二叉树】。

对于两种情况：第一种左右都是点，没有再挂天平时就可以直接处理：

	if(!lt&&!rt){return lx+rx;}

否则继续递归下去。

搜到某一叶子节点，便查找它的左（右）边与它同等的节点的点权和边权，让它们保持局部平衡。我们将把天平横杆的距离处理后，回溯即可。

以下共享c++代码和pascal代码。

c++

    #include <cstdio>
    #define ll long long
    inline ll gcd(ll a,ll b)
    {return b?gcd(b,a%b):a;}
    inline ll lca(ll a,ll b)
    {return a*b/gcd(a,b);}
    int n;bool in[110];
    struct tp
    {
        ll lx,rx,lt,rt;
    }t[110];
    ll dg(int w)
    {
        ll lt=t[w].lt,rt=t[w].rt,lx=t[w].lx,rx=t[w].rx;
        if(!lt&&!rt){return lx+rx;}
        ll l=(lt?dg(lt):rx);
        ll r=(rt?dg(rt):lx);
        l=lca(l,rx),r=lca(r,lx);
        ll lb=l/rx,rb=r/lx;
        ll b=lca(lb,rb);
        return l*b/lb+r*b/rb;
    }
    int main()
    {
        scanf("%d",&n);
        for(int i=1;i<=n;++i)
        {
            scanf("%d %d %d %d",&t[i].lx,&t[i].rx,&t[i].lt,&t[i].rt);
            int g=gcd(t[i].lx,t[i].rx);
            t[i].lx/=g,t[i].rx/=g;
            in[t[i].lt]=in[t[i].rt]=1;
        }
        int w=0;
        for(int i=1;i<=n;++i)
            if(!in[i])
            {
                w=i;break;
            }
        printf("%lld",dg(w));
        return 0;
    }
    
pascal代码:

```cpp
var n,ro,i:longint;
    a:array[1..100,1..4]of int64;
    f:array[1..100]of boolean;
function gcd(x,y:int64):int64;
  begin
    if y=0 then gcd:=x
    else gcd:=gcd(y,x mod y);
  end;
function dg(x:longint):int64;
  var l,r,g:int64;
  begin
    if x=0 then dg:=1
    else begin
      l:=dg(a[x,3]);
      r:=dg(a[x,4]);
      g:=gcd(r*a[x,2],l*a[x,1]);
      dg:=l*(r*a[x,2] div g)+r*(a[x,1]*l div g);
    end;
  end;
begin

  readln(n);
  for i:=1 to n do begin
    readln(a[i,1],a[i,2],a[i,3],a[i,4]);
    if a[i,3]<>0 then f[a[i,3]]:=true;
    if a[i,4]<>0 then f[a[i,4]]:=true;
  end;
  for i:=1 to n do begin
    if not f[i] then begin
       ro:=i;break;
    end;
  end;
  writeln(dg(ro));

end.
```
希望可以对大家有所帮助。

---

## 作者：ljc20020730 (赞：3)

欢迎交换友链：

[ljc20020730](http://www.cnblogs.com/ljc20020730)

 ![](https://cdn.luogu.com.cn/upload/pic/5769.png) 

有没有发现其实这个天平有点像完全二叉树?我也觉得像。

解决这道题需要3个分析知识：

●题目中的隐含条件为挂的物品必须为整数，即每个天平悬挂的物品重量必须为整数。（没什么好解释）

●题目的约束条件即为天平必须平衡，即重量与长度的乘积必须相等。（简单机械中的杠杆原理）

●左右没有天平(叶)的天平左右的单位重量都为1，该杠杆的最轻重量即为（p+q） div gcd(p,q) （转化一下就是 p div gcd(p,q) + q div gcd(p,q)）

总体的算法思想是：

若天平i左边的最轻重量为x，右边为y，则左边重量为ax，右边为by

∴ax\*p=by\*q，a:b=qy:xp，我们使a:b最简即可(求gcd)，ax+by即为天平的最轻重量。

(a,b∈N\*) 是指a,b均为自然数

但是我们都不知道根节点是哪个怎么求呢？

这里用到类似并查集（没出现过的就是root）的算法：

```cpp
 for i:=1 to n do begin
  readln(p[i],q[i],r[i],b[i]);
  fa[r[i]]:=true;
  fa[b[i]]:=true;
 end;
 for i:=1 to n do  if fa[i]=false then root:=i;
这样我们就找到了根root。
```
随后就是递归建树（假假的树）：

```cpp
procedure build(k:longint; var ans:int64);
var t,d1,d2:int64;
begin
 if r[k]<>0 then build(r[k],d1) else d1:=1;//如果不是叶结点就递归深入，否则假定根节点是1开始累加退回
 if b[k]<>0 then build(b[k],d2) else d2:=1;//同上
 t:=(p[k]*d1)*(q[k]*d2) div gcd(p[k]*d1,q[k]*d2);//a:b=qy:xp，上面解释里a:b最简的值，即该结点（天平）的最小重量
 ans:=t div p[k]+ t div q[k];//就是累加该天平两端下的物体的重量和
end;
```
于是就做好了！

补充说明一点:

表面上看r数组和b数组的本质是差不多的，其实仔细想来r和b分别代表这个天平的左端和右端。

代码如下：



```cpp
var i,root,n:longint;
    sum:int64;
    fa:array[0..1000]of boolean;
    p,q,r,b:array[1..1000]of longint;
function gcd(a,b:longint):longint;
 begin
  if b=0 then gcd:=a
   else gcd:=gcd(b,a mod b);
end;
procedure build(k:longint; var ans:int64);
var t,d1,d2:int64;
begin
 if r[k]<>0 then build(r[k],d1) else d1:=1;
 if b[k]<>0 then build(b[k],d2) else d2:=1;
 t:=(p[k]*d1)*(q[k]*d2) div gcd(p[k]*d1,q[k]*d2);
 ans:=t div p[k]+ t div q[k];
end;
begin
 assign(input,'mobile.in'); reset(input);
 assign(output,'mobile.out'); rewrite(output);
 readln(n);
 for i:=1 to n do begin
  readln(p[i],q[i],r[i],b[i]);
  fa[r[i]]:=true;
  fa[b[i]]:=true;
 end;
 for i:=1 to n do
  if fa[i]=false then root:=i;
 build(root,sum);
 writeln(sum);
 close(input);close(output);
end.

```

---

## 作者：Yusani_huh (赞：1)

此题作为校内模拟赛的 T4 而被同机房的广大聚聚注意到了。第一眼觉得这题跟 [UVA839](https://www.luogu.com.cn/problem/UVA839) 有亿点点类似，然而后者给了物体重量求是否平衡，这题给了平衡求物体重量，还是不大一样的。

把一个天平看做是一棵二叉树，有左子天平和右子天平，以及父亲天平，这些关系输入中都给出了所以很清楚。

“使得所有天平都平衡”是一个切入点。如何使得所有天平都平衡？题目中也有说明：$F_1L_1=F_2L_2$，也即“左端点的重量与左端点到支点的距离的乘积等于右端点的重量与右端点到支点的距离的乘积”。

由于非叶天平（悬挂着天平的天平）的系统过于庞大且条件不够充分，所以优先考虑叶天平（没有悬挂任何天平的天平）。叶天平的两边挂的都是物品，并且 $L_1,L_2$ 已经给出，要使物品的重量（$F_1,F_2$）尽量小，也就是要使 $F_1L_1,F_2L_2$ 尽量小，所以取 $L_1,L_2$ 的最小公倍数（$\operatorname{lcm}$）即可，“最小公倍数”的“公”保证了相等，“最小”保证了最小。所以 $F_1=\operatorname{lcm}\div L_1,F_2=\operatorname{lcm}\div L_2$。

求出叶天平所悬挂物品的重量也就相当于求出了叶天平的重量，可以把这个叶天平看作一个物品。若叶天平的父天平只有一个子天平，则可以对父天平进行处理，若父天平还有另一个子天平，则先处理另一个子天平，这一步与拓扑排序有相似之处。

第二个问题是，当叶天平被当作物品时已经有了一个初始质量，这种情况下如何处理父天平？

答：把初始质量带进去算就行了。

原公式为 $F_1L_1=F_2L_2$，如果原来已经有质量了，则公式变为 $F_1F^{'}_1L_1=F_2F^{'}_2L_2$（其中标撇的为原有质量），求 $F^{'}_1L_1,F^{'}_2L_2$ 的 $\operatorname{lcm}$ 即可，不必再修改子天平的重量，可以直接将 $F_1+F_2$ 作为父天平的质量。

最后输出，找到根天平，输出其质量即可。

提醒：记得开 `long long`！

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q[103];
struct node{
	int ls,rs,s,f;
	long long l,r,w;
}h[103];
int gcd(int a,int b){
	if(b==0) return a;
	return gcd(b,a%b);
}
int main(){
	scanf("%d",&n);
	int l=1,r=0;
	h[0].w=1;
	for(int i=1;i<=n;++i){    //输入同时建树
		scanf("%lld%lld%d%d",&h[i].l,&h[i].r,&h[i].ls,&h[i].rs);
		if(h[i].ls==0&&h[i].rs==0) q[++r]=i;    //如果为叶天平则入队
		if(h[i].ls) h[h[i].ls].f=i,h[i].s++;
		if(h[i].rs) h[h[i].rs].f=i,h[i].s++;
	}
	while(l<=r){
		int a=q[l];
		long long lm=h[a].l*h[h[a].ls].w;
		long long rm=h[a].r*h[h[a].rs].w;
		long long lcm=lm*rm/gcd(lm,rm);
		h[a].w=lcm/h[a].l+lcm/h[a].r;
		h[h[a].f].s--;
		if(h[h[a].f].s==0) q[++r]=h[a].f;    //如果儿子都已经处理完毕则入队
		l++;
	}
	for(int i=1;i<=n;++i)
		if(h[i].f==0){     //找到根天平并输出
			printf("%lld\n",h[i].w);
			break;
		}
	return 0;
}
```

---

## 作者：_Luminous (赞：0)

### 解题思路 & 方法

------------
要想天平平衡，首先要使左右天平的两边平衡。假设左右两边的最轻重量分别为w1,w2，比例为p:q（题目中已给出），要想使得该天平衡，可能左边要放大x倍，右边要放大y倍，则有以下关系式： w1 * x * p = w2 * y * q; 即x / y=(w2 * q) / (w1 * p)。

要想使天平重量最小，必须把x/y化为最简分数，所以需求出  W2 * L2和W1 * L1的最大公约数t，则x = w2 * q / t ，y=w1 * p / t，整个天平的重量为 w1 * x + w2 * y。

而题目中保证了这些天平能够构成一个整体，所以我们可以将其看作是一个二叉树（其实从图中也能看出），这样方便求解。

### · Code

------------
```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
inline ll gcd(ll a,ll b){return (!b)?a:gcd(b,a%b);}
ll n,root;
struct node{
	ll p,q,lc,rc,father;
}a[105];
ll dfs(ll x){
	if(!x)//如果找到根节点了直接返回1。
		return 1;
	ll lc=a[x].p*dfs(a[x].lc),rc=a[x].q*dfs(a[x].rc),lcm=lc*rc/gcd(lc,rc);
	return lcm/a[x].p+lcm/a[x].q;
}
int main(){
	//freopen("mobile.in","r",stdin);
	//freopen("mobile.out","w",stdout);
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++){
		scanf("%lld%lld%lld%lld",&a[i].p,&a[i].q,&a[i].lc,&a[i].rc);
		if(a[i].lc!=0)
			a[a[i].lc].father=i;//保存父节点
		if(a[i].rc!=0)
			a[a[i].rc].father=i;
	}
	for(ll i=1;i<=n;i++)
		if(!a[i].father){//找到根节点（也就是父节点为0的那一个）
			root=i;
			break;
		}
	printf("%lld\n",dfs(root));
    return 0;
}
```


---


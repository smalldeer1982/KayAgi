# 小白逛公园

## 题目背景

小新经常陪小白去公园玩，也就是所谓的遛狗啦…

## 题目描述

在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。

一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a, b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。

那么，就请你来帮小白选择公园吧。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^5$，$1 \le m \le 10^5$，所有打分都是绝对值不超过 $1000$ 的整数。

## 样例 #1

### 输入

```
5 3
1
2
-3
4
5
1 2 3
2 2 -1
1 2 3```

### 输出

```
2
-1```

# 题解

## 作者：Unknown_Error  (赞：471)

我们知道，求一段序列的最大子段和是O（n）的，但是这样是显然会超时的。

我们需要一个数据结构来支持修改和计算的操作，对于这种修改一个而查询区间的问题，考虑使用线段树。

在线段树中，除了左端点，右端点，左儿子指针，右儿子指针之外，新开4个域——max，maxl，maxr，sum，其中sum为该区间的和，max为该区间上的最大子段和，maxl为必须包含左端点的最大子段和，maxr为必须包含右端点的最大子段和。

 可以用线段树来统计了注意求得的最大子段和中至少包含1个元素，所以出现了样例那样的输出负值。

## 修改时：
1、若左儿子的maxr和右儿子的maxl都为负，就从中取较大的为该节点的max（防止一个都不取），反之取二者中正的（都正就都取）。

2、将该节点的max用左右儿子的max更新。

3、该节点的maxl为左儿子的maxl与左儿子sum和右儿子maxl和的最大值。

4、该节点的maxr为右儿子的maxr与右儿子sum和左儿子maxr和的最大值。

5、该节点的sum为左右儿子的sum和。
## 查询时：
1、如果查询区间覆盖这一节点，将该节点信息返回。

2、如果只与一个儿子有交集，就返回在那个儿子中查找到的信息。

3、如果与两个儿子都有交集，就先分别计算出两个儿子的信息，然后按修改的方式将两个信息合并，然后返回。

4、最后返回的max值即为答案。
# 代码
```
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 500001
struct Node{int maxv,maxl,maxr,sumv;}T[N<<2];
inline void pushup(Node &rt,const Node &ls,const Node &rs)
{
	if(ls.maxr<0 && rs.maxl<0)
	  rt.maxv=max(ls.maxr,rs.maxl);
	else
	  {
	  	rt.maxv=0;
	  	if(ls.maxr>0)
	  	  rt.maxv+=ls.maxr;
	  	if(rs.maxl>0)
	  	  rt.maxv+=rs.maxl;
	  }
	rt.maxv=max(rt.maxv,ls.maxv);
	rt.maxv=max(rt.maxv,rs.maxv);
	rt.maxl=max(ls.maxl,ls.sumv+rs.maxl);
	rt.maxr=max(rs.maxr,rs.sumv+ls.maxr);
	rt.sumv=ls.sumv+rs.sumv;
}
void buildtree(int rt,int l,int r)
{
	if(l==r)
	  {
	  	scanf("%d",&T[rt].maxv);
	  	T[rt].sumv=T[rt].maxl=T[rt].maxr=T[rt].maxv;
	  	return;
	  }
	int m=(l+r>>1);
	buildtree(rt<<1,l,m);
	buildtree(rt<<1|1,m+1,r);
	pushup(T[rt],T[rt<<1],T[rt<<1|1]);
}
void update(int p,int v,int rt,int l,int r)
{
	if(l==r)
	  {
	  	T[rt].sumv=T[rt].maxl=T[rt].maxr=T[rt].maxv=v;
	  	return;
	  }
	int m=(l+r>>1);
	if(p<=m) update(p,v,rt<<1,l,m);
	else update(p,v,rt<<1|1,m+1,r);
	pushup(T[rt],T[rt<<1],T[rt<<1|1]);
}
Node query(int ql,int qr,int rt,int l,int r)
{
	if(ql<=l&&r<=qr) return T[rt];
	int m=(l+r>>1);
	if(ql<=m && m<qr)
	  {
	  	Node res;
	  	pushup(res,query(ql,qr,rt<<1,l,m),query(ql,qr,rt<<1|1,m+1,r));
	  	return res;
	  }
	else if(ql<=m) return query(ql,qr,rt<<1,l,m);
	else return query(ql,qr,rt<<1|1,m+1,r);
}
int n,m;
int main()
{
	int op,x,y;
	scanf("%d%d",&n,&m);
	buildtree(1,1,n);
	for(;m;--m)
	  {
	  	scanf("%d%d%d",&op,&x,&y);
	  	if(op==1)
		  {
		  	if(x>y)
		  	  swap(x,y);
		  	printf("%d\n",query(x,y,1,1,n).maxv);
		  }
	  	else update(x,y,1,1,n);
	  }
	return 0;
}
```

---

## 作者：ez_lcw (赞：221)

# 线段树经典例题
这道题的大意：给出一个动态的区间，以及$m$次询问，每次询问给出一段区间 $[l,r]$，要求出这段区间中
**和最大的连续序列**。

看到这道题的第一反应就是**线段树**
~~不会线段树的请出门左转先学一下~~

但是我们要考虑一下怎么区间合并：

1. **首先在结构体（or全局，看个人喜好）定义必有的每个节点的区间 $l[]$ 和 $r[]$。**

1. **其次，我们需要为每个节点定义4个数：**

 $maxleft$，以**左端点为头**的 和最大的连续序列。
 
 $maxright$，以**右端点为尾**的 和最大的连续序列。
 
 $sum$，这段序列的总和
 
 $ans$，这段序列中的最大的连续序列~~（就是答案）~~
 
3. **如何合并区间呢？（首先注意一点，对于一个节点 $k$，那么它左右儿子的编号分别为 $k*2$、$k*2+1$）**

 - 首先，对于 $sum$ 的更新，就比较简单易懂：
 
 $$sum[k]=sum[k*2]+sum[k*2+1];$$
 - 其次，对于 $maxleft$ 和 $maxright$ 以及 $ans$ 的更新，我们可以先画个图来感受一下：
 
	样例：
   
   ![](https://cdn.luogu.com.cn/upload/pic/43779.png)
        
   那么将它建成一棵线段树，其中，我们假设根的左儿子和右儿子都已经把 $maxleft$、$maxright$、$sum$、$ans$ 都已计算好了，现在要干的事情是合并区间：
   
   ![](https://cdn.luogu.com.cn/upload/pic/43785.png)
        
   那么我们可以想象一下，根节点的$maxleft$应该是这样的：
   
   ![](https://cdn.luogu.com.cn/upload/pic/43791.png)
        
   同理，$maxright$应该是这样更新的：
        
   ![](https://cdn.luogu.com.cn/upload/pic/43792.png)
       
   那么 $ans$ 的更新也比较容易理解：
   $$tree[k].ans=max(max(tree[k*2].ans,tree[k*2+1].ans),tree[k*2].maxright+tree[k*2+1].maxleft);$$
       
   对于 “$maxright[lchild]+maxleft[rchild]$” 的理解，也可以看图来想象：
       
   ![](https://cdn.luogu.com.cn/upload/pic/43789.png)
       
   其实就是左儿子的 $maxright$ 和右儿子的 $maxleft$ 相加，也就是 **和最大的连续序列** 贯穿了左右儿子。
       
   **那为什么不把更新后的 $maxright$ 和 $maxleft$ 加入到 $tree[k].ans$ 的更新里呢？**
       
   其实已经更新了，因为 $ans[lchild]$ 和 $ans[rchild]$ 其实就包含了上面说的 $maxright$、$maxleft$ 更新的第一种情况，即 $tree[k*2].maxleft$和$tree[k*2+1].maxright$。
       
   而 $maxright[lchild]+maxleft[rchild]$ 已经包含了上面说的 $maxright$、$maxleft$ 更新的第二种情况，即 $tree[k*2].sum+tree[k*2+1].maxleft$ 和 $tree[k*2].maxright+tree[k*2+1].sum$。
       
    所以，$tree[k].ans$已经更新了 $maxleft$ 和 $maxright$ 的最优答案。
       
       
1. **在询问的时候，也要做一次类似于合并区间的一次寻找最优值，不能直接返回 $max(tree[k*2].ans,tree[k*2+1].ans)$，因为可能询问的区间不完全包含左儿子或右儿子的区间（若完全包含，则不用合并）。**

具体的合并区间代码就是这样了：

```cpp
void putin(int k)
{
    tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;//更新sum
    tree[k].maxleft=max(tree[k*2].maxleft,tree[k*2].sum+tree[k*2+1].maxleft);//更新maxleft
    tree[k].maxright=max(tree[k*2+1].maxright,tree[k*2].maxright+tree[k*2+1].sum);//更新maxright
    tree[k].ans=max(max(tree[k*2].ans,tree[k*2+1].ans),tree[k*2].maxright+tree[k*2+1].maxleft);//更新ans
}
```

那么全部的代码如下：

```cpp
#include<cstdio>
#include<iostream>

#define N 2000001

using namespace std;

int n,m;

struct Tree//用结构体来存树
{
    int l,r;
    long long maxleft,maxright,sum,ans;
}tree[N];

void putin(int k)//合并区间函数
{
    tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;
    tree[k].maxleft=max(tree[k*2].maxleft,tree[k*2].sum+tree[k*2+1].maxleft);
    tree[k].maxright=max(tree[k*2+1].maxright,tree[k*2].maxright+tree[k*2+1].sum);
    tree[k].ans=max(max(tree[k*2].ans,tree[k*2+1].ans),tree[k*2].maxright+tree[k*2+1].maxleft);
}

void build(int l,int r,int k)//建树
{
    tree[k].l=l;tree[k].r=r;
    if(l==r)
    {
        scanf("%lld",&tree[k].sum);
        tree[k].maxleft=tree[k].maxright=tree[k].ans=tree[k].sum;//初始化时，因为这个节点只有一个数，maxleft、maxright、sum和ans的值都一样。
        return;//别忘了return
    }
    int mid=(l+r)/2;
    build(l,mid,k*2);//递归建树
    build(mid+1,r,k*2+1);
    putin(k);//合并区间
}

Tree ask(int k,int x,int y)//询问函数，因为每次返回的maxleft等值不一定是左右儿子的数据，所以要返回一个结构体
{
    if(x<=tree[k].l&&tree[k].r<=y)
    {
        return tree[k];
    }
    int mid=(tree[k].l+tree[k].r)/2;
    if(y<=mid) return ask(k*2,x,y);//如果访问的区间全在左儿子里，直接return
    else
    {
        if(x>mid) return ask(k*2+1,x,y);//如果访问的区间全在右儿子里，也直接return
        else
        {//否则就左右儿子都访问，然后合并区间
            Tree t,a=ask(k*2,x,y),b=ask(k*2+1,x,y);
            t.maxleft=max(a.maxleft,a.sum+b.maxleft);//做类似的合并区间
            t.maxright=max(b.maxright,a.maxright+b.sum);
            t.ans=max(max(a.ans,b.ans),a.maxright+b.maxleft);
            return t;//返回合并后的区间
        }
    }
}

void change(int k,int x,int y)//单点修改
{
    if(tree[k].l==tree[k].r)
    {
        tree[k].maxleft=tree[k].maxright=tree[k].ans=tree[k].sum=y;
        return;
    }
    int mid=(tree[k].l+tree[k].r)/2;
    if(x<=mid)change(k*2,x,y);//判断目标位置
    else change(k*2+1,x,y);
    putin(k);//因为值已经改变了，所以要合并区间
}

int main()
{
    scanf("%d%d",&n,&m);
    build(1,n,1);
    while(m--)
    {
        int choose,x,y;
        scanf("%d%d%d",&choose,&x,&y);
        if(choose==1)
        {
            if(x>y)swap(x,y);//这是个坑点，因为题目没有注明x<=y，就是因为这个我调了半天QAQ，最后还是看讨论才知道的，感谢讨论的巨佬们
            printf("%lld\n",ask(1,x,y).ans);
        }
        else
        {
            change(1,x,y);
        }
    }
    return 0;
}
```

注：感谢我校巨佬@2016gdgzoi471 的题解提供的思路！

---

## 作者：Uranus (赞：54)

[P4513 小白逛公园](https://www.luogu.org/problemnew/show/P4513)

单点修改区间最大子段和，很显然是使用很便于维护区间信息，而且在 $O(logN)$ 时间复杂度内能够完成单点修改的线段树。在每个维护区间 $[L,R]$ 的节点内我们需要维护以下信息：
* $s(sum):$ $[L,R]$ 的和
* $lm(lmax):$ 从左端点 $L$ 开始的最大子段和（简称左子段和）
* $rm(rmax):$ 从右端点 $R$ 开始的最大子段和（简称右子段和）
* $m(max):$ $[L,R]$ 内的最大子段和

为什么要这样维护呢？因为这样记录可以完美地向上更新：
```cpp
inline void update(int p)
{
    s(p)=s(p<<1)+s(p<<1|1);//该区间和为左区间和+右区间和
    lm(p)=max(s(p<<1)+lm(p<<1|1),lm(p<<1));//左区间最大子段和 或 左区间和+右区间左子段和
    rm(p)=max(s(p<<1|1)+rm(p<<1),rm(p<<1|1));//右区间最大子段和 或 右区间和+左区间右子段和
    m(p)=max(max(m(p<<1),m(p<<1|1)),rm(p<<1)+lm(p<<1|1));//左区间最大子段和 或 右区间最大子段和 或 左区间右子段和+右区间左子段和
}
```

建树时，叶子结点满足`s(p)=lm(p)=rm(p)=m(p)=a[ll];`（至少选一个数字）：
```cpp
void build(int p,int ll,int rr)
{
    l(p)=ll,r(p)=rr;
    if(ll==rr)
    {
        s(p)=lm(p)=rm(p)=m(p)=a[ll];
        return ;
    }
    int mid=(l(p)+r(p))>>1;
    build(p<<1,ll,mid);
    build(p<<1|1,mid+1,rr);
    update(p);
}
```

单点修改时，递归到底再回溯：
```cpp
void change(int p,int des,int num)//将des位置的值改为num
{
    if(l(p)==r(p))//递归到底
    {
        s(p)=lm(p)=rm(p)=m(p)=num;
        return ;
    }
    int mid=(l(p)+r(p))>>1;
    if(mid>=des) change(p<<1,des,num);
    else change(p<<1|1,des,num);
    update(p);
}
```

下面是查询函数。查询时我们也要记录`sum,lmax,rmax,max`，所以我们在查询时返回一个线段树结构体，该结构体记录查询区间的信息，具体这样操作：
```cpp
SegmentTree ask(int p,int ll,int rr)
{
    if(ll<=l(p)&&r(p)<=rr) return tree[p];//区间完全覆盖，直接返回该节点
    int mid=(l(p)+r(p))>>1;
    if(rr<=mid) return ask(p<<1,ll,rr);//只在左区间，直接查询左区间
    else if(ll>mid) return ask(p<<1|1,ll,rr);//只在右区间，直接查询右区间
    else//左右区间都有，考虑如何合并
    {
        SegmentTree x=ask(p<<1,ll,rr),y=ask(p<<1|1,ll,rr),re;//x记录左覆盖区间，y记录右覆盖区间，x和y合并后得到re
        //用update()的同样方式更新re：
        re.sum=x.sum+y.sum;
        re.lmax=max(x.sum+y.lmax,x.lmax);
        re.rmax=max(y.sum+x.rmax,y.rmax);
        re.maxx=max(max(x.maxx,y.maxx),x.rmax+y.lmax);
        return re;
    }
}
```

这样，我们就可以实现题目的所有要求。总代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=500005;
int n,m,a[MAXN];
struct SegmentTree
{
    int l,r,sum,lmax,rmax,maxx;
    #define l(a) tree[a].l
    #define r(a) tree[a].r
    #define s(a) tree[a].sum
    #define lm(a) tree[a].lmax
    #define rm(a) tree[a].rmax
    #define m(a) tree[a].maxx
}tree[MAXN<<2];
int read()
{
    int f=1,re=0;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)) re=(re<<3)+(re<<1)+ch-'0',ch=getchar();
    return f*re;
}
inline void update(int p)
{
    s(p)=s(p<<1)+s(p<<1|1);
    lm(p)=max(s(p<<1)+lm(p<<1|1),lm(p<<1));
    rm(p)=max(s(p<<1|1)+rm(p<<1),rm(p<<1|1));
    m(p)=max(max(m(p<<1),m(p<<1|1)),rm(p<<1)+lm(p<<1|1));
}
void build(int p,int ll,int rr)
{
    l(p)=ll,r(p)=rr;
    if(ll==rr)
    {
        s(p)=lm(p)=rm(p)=m(p)=a[ll];
        return ;
    }
    int mid=(l(p)+r(p))>>1;
    build(p<<1,ll,mid);
    build(p<<1|1,mid+1,rr);
    update(p);
}
void change(int p,int des,int num)
{
    if(l(p)==r(p))
    {
        s(p)=lm(p)=rm(p)=m(p)=num;
        return ;
    }
    int mid=(l(p)+r(p))>>1;
    if(mid>=des) change(p<<1,des,num);
    else change(p<<1|1,des,num);
    update(p);
}
SegmentTree ask(int p,int ll,int rr)
{
    if(ll<=l(p)&&r(p)<=rr) return tree[p];
    int mid=(l(p)+r(p))>>1;
    if(rr<=mid) return ask(p<<1,ll,rr);
    else if(ll>mid) return ask(p<<1|1,ll,rr);
    else
    {
        SegmentTree x=ask(p<<1,ll,rr),y=ask(p<<1|1,ll,rr),re;
        re.sum=x.sum+y.sum;
        re.lmax=max(x.sum+y.lmax,x.lmax);
        re.rmax=max(y.sum+x.rmax,y.rmax);
        re.maxx=max(max(x.maxx,y.maxx),x.rmax+y.lmax);
        return re;
    }
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    build(1,1,n);
    while(m--)
    {
        int opt=read();
        if(opt==1)
        {
            int x=read(),y=read();
            if(x>y) swap(x,y);
            SegmentTree ans=ask(1,x,y);
            printf("%d\n",ans.maxx);
        }
        else if(opt==2)
        {
            int x=read(),y=read();
            change(1,x,y);
        }
    }
    return 0;
}
```

成功AC $qwq$ 。

顺便说一下一个[julao](https://www.luogu.org/space/show?uid=60108)的错误（他调试了很久，希望能帮到大家 $qwq$ ）

首先他看到了[一篇讨论](https://www.luogu.org/discuss/show?postid=51328)：
> 为啥没声明a可能>b啊

然后他就把
```cpp
while(m--)
{
	int opt=read(),x=read(),y=read();
    if(opt==1)
    {
        SegmentTree ans=ask(1,x,y);
        printf("%d\n",ans.maxx);
    }
    else if(opt==2)
    {
        change(1,x,y);
    }
}
```

改成了
```cpp
while(m--)
{
	int opt=read(),x=read(),y=read();
    if(x>y) swap(x,y);
    if(opt==1)
    {
        SegmentTree ans=ask(1,x,y);
        printf("%d\n",ans.maxx);
    }
    else if(opt==2)
    {
        change(1,x,y);
    }
}
```

然后就写挂了 $qwq$

---

## 作者：sto_5k_orz (赞：46)

谁告诉你这题不能写树状数组了。

首先，考虑树状数组的每一段 $x$ 表示 $[x-lowbit(x)+1,x]$ 的结果。

那么每一段都要维护：

$sum$ 区间和，后面有用。

$lmax$，左半边的区间最大子段和。

$rmax$，右半边的区间最大子段和

$ans$，区间最大子段和。

那么一次合并操作，合并两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$，要求 $l_1\le r_1+1=l_2\le r_2$。

$sum$ 即为两端区间和。

$lmax$：可以考虑选 $[l_1,r_1]$ 的 $lmax$，也可以选整段 $[l_1,r_1]$ 和 $[l_2,r_2]$ 的 $lmax$。

$rmax$：同理要么选 $[l_2,r_2]$ 的 $rmax$，也可以选整段 $[l_2,r_2]$ 和 $[l_1,r_1]$ 的 $rmax$，

$ans$：即为 $[l_1,r_1]$ 的 $ans$ 或 $[l_2,r_2]$ 的 $ans$，也可以是 $[l_1,r_1]$ 的 $rmax$ 与 $[l_2,r_2]$ 的 $lmax$ 拼接而成。

~~所以考虑线段树上进行合并区间操作。~~

令 $merge(a,b)$ 表示合并 $a,b$ 区间后的四个值。

令 $Max(x,y)$ 表示 $x$ 到 $y$ 的维护区间最大子段和的四个值，然后树状数组叫做 $tr$，$tr_x=Max(x-lowbit(x)+1,x)$。

考虑查询，查询时当 $y-lowbit(y)>x$ 时，之间用 $tr_y$ 更新。$Max(x,y)=merge(Max(x,y-lowbit(y)),tr_y)$。

否则，就开始单点的暴力查询，令 $w_x$ 为 $x$ 的单点值。

$$Max(l,r)=merge(Max(l,r-1),w_r)$$

这是因为需要访问单点值，所以这种方法只支持单点修改。

单点修改呢？

设修改 $x$ 变为 $k$。

其实就是先把 $w_x$ 设成 $k$，然后从 $x$ 开始，到 $x+lbt(x),x+lbt(x)+lbt(x+lbt(x))\cdots$ 都用 $\log$ 的复杂度暴力修改。

这样做复杂度 $O(n\log^2 n)$，虽然线段树可以 $O(n\log n)$，但是 BIT 常数小无伤大雅。而且这么写码量小。

而且树状数组只能区间修改区间查询可差分信息，区间最大子段和这种不可差分信息只能单点修改。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline
const int N = 500010; int a[N], n, m;
struct S {
	int sum, lmax, rmax, ans;
	void add(int u) {sum = ans = lmax = rmax = a[u];}
} tr[N], A[N];
I S merge(S a, S b) {
	S ret;
	ret.sum = a.sum + b.sum;
	ret.ans = max(max(a.ans, b.ans), a.rmax + b.lmax);
	ret.lmax = max(a.lmax, a.sum + b.lmax);
	ret.rmax = max(b.rmax, b.sum + a.rmax);
	return ret;
}
I int lbt(int x) {return x & (-x);}
I void change(int x, int k) {
	A[x] = {k, k, k, k};
	for(; x <= n; x += lbt(x)) {
		tr[x] = A[x];
		for(int i = 1; i < lbt(x); i <<= 1) {
			tr[x] = merge(tr[x - i], tr[x]);
		}
	}
}
I int ask(int l, int r) {
    if(l > r) swap(l, r);
	S ret; ret.lmax = ret.rmax = ret.ans = -1e9; ret.sum = 0;
	while(r >= l) {
		ret = merge(A[r--], ret);
		for(; r - lbt(r) >= l; r -= lbt(r)) ret = merge(tr[r], ret);
	}
	return ret.ans;
}
int main() {
	cin >> n >> m; for(int i = 1, x; i <= n; i++) cin >> x, change(i, x);
	while(m--) {
		int o, x, y; cin >> o >> x >> y;
		if(o == 2) change(x, y);
		else cout << ask(x, y) << '\n';
	}
	return 0;
}
```

球赞 qwq。

---

## 作者：luminouris (赞：19)

这道题难点在于如何在logn的范围内找到该区间最大值，我们不妨先分析最大值有哪几种情况。
如图所示：
![](https://cdn.luogu.com.cn/upload/pic/65448.png)
可分为3种情况
1.全部在中线左边。
2.全部在中线右边。
3.经过跨过中线。
如果在二叉树上分析，全部在中线左边即为左儿子的最大值，全部在中线右边即为右儿子的最大值，跨过中线的情况需要分析左儿子包含右端点的最大值和右儿子包含左端点的最大值。

如图所示：![](https://cdn.luogu.com.cn/upload/pic/65449.png)
代码实现如下：
```cpp
void update(int k)
{
	tr[k].v=tr[k*2].v+tr[k*2+1].v;
	tr[k].lm=max(tr[k*2].lm,tr[k*2].v+tr[k*2+1].lm);
	tr[k].rm=max(tr[k*2+1].rm,tr[k*2+1].v+tr[k*2].rm);
	tr[k].mm=max(tr[k*2].mm,max(tr[k*2+1].mm,tr[2*k].rm+tr[k*2+1].lm)); 
}
```
注意由于搜索时可能会遇到过中线的情况所以需要进行和update一样的操作，我们直接声明一个结构体函数；

代码如下：
```cpp
node sear(int l,int r,int k)//由于和update有一样操作直接找结构体 
{
	node left1,right1;
	int f1=0,f2=0;
	if(tr[k].l>=l && tr[k].r<=r)
		return tr[k];
	int mid=(tr[k].l+tr[k].r)/2;
	if(l<=mid)
		left1=sear(l,r,k*2),f1=1;//如果区间包含中线左边 。 
	if(r>mid)
		right1=sear(l,r,k*2+1),f2=1;//如果区间包含中线右边。 
	if(f2&&f1)//如果区间同时包含中线左右边则需进行update时一样的操作。 
	{
		node m;
		m.l=left1.l,m.r=right1.r,m.v=left1.v+right1.v;
		m.lm=max(left1.lm,left1.v+right1.lm);
		m.rm=max(right1.rm,right1.v+left1.rm);
		m.mm=max(left1.mm,max(right1.mm,left1.rm+right1.lm)) ;
		return m;
	}
	if(f1)//只包含左边； 
		return left1;
	if(f2)//只包含右边； 
		return right1;
}
```

接着便是线段数的常见操作：

完整代码如下：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
struct node
{
	int l,r,mm,lm,rm,v;
}tr[2000010]; 
void update(int k)
{
	tr[k].v=tr[k*2].v+tr[k*2+1].v;
	tr[k].lm=max(tr[k*2].lm,tr[k*2].v+tr[k*2+1].lm);
	tr[k].rm=max(tr[k*2+1].rm,tr[k*2+1].v+tr[k*2].rm);
	tr[k].mm=max(tr[k*2].mm,max(tr[k*2+1].mm,tr[2*k].rm+tr[k*2+1].lm)); 
}
void build(int l,int r,int k)
{
	tr[k].l=l;
	tr[k].r=r;
	if(l==r)
	{
		cin>>tr[k].v;
		tr[k].lm=tr[k].v;
		tr[k].rm=tr[k].v;
		tr[k].mm=tr[k].v;
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,k*2);
	build(mid+1,r,k*2+1);
	update(k);//回溯时求该区间最大值。 
}
void change(int pos,int num,int k)
{
	if(tr[k].l==pos && tr[k].r==pos)
	{
		tr[k].v=num;
		tr[k].lm=num,tr[k].rm=num,tr[k].mm=num;
		return;
	}
	int mid=(tr[k].l+tr[k].r)>>1;
	if(pos<=mid)
		change(pos,num,k*2);
	else
		change(pos,num,k*2+1);//向下二分搜索 ； 
	update(k);//回溯时改变区间最大值； 
}  
node sear(int l,int r,int k)//由于和update有一样操作直接找结构体 
{
	node left1,right1;
	int f1=0,f2=0;
	if(tr[k].l>=l && tr[k].r<=r)
		return tr[k];
	int mid=(tr[k].l+tr[k].r)/2;
	if(l<=mid)
		left1=sear(l,r,k*2),f1=1;//如果区间包含中线左边 。 
	if(r>mid)
		right1=sear(l,r,k*2+1),f2=1;//如果区间包含中线右边。 
	if(f2&&f1)//如果区间同时包含中线左右边则需进行update时一样的操作。 
	{
		node m;
		m.l=left1.l,m.r=right1.r,m.v=left1.v+right1.v;
		m.lm=max(left1.lm,left1.v+right1.lm);
		m.rm=max(right1.rm,right1.v+left1.rm);
		m.mm=max(left1.mm,max(right1.mm,left1.rm+right1.lm)) ;
		return m;
	}
	if(f1)//只包含左边； 
		return left1;
	if(f2)//只包含右边； 
		return right1;
}


int main()
{
	int n,m,type,le,ri;
	cin>>n>>m;
	build(1,n,1);
	for(int i=1;i<=m;i++)
	{
		cin>>type>>le>>ri;
		if(type==1 && le>ri) 
			swap(le,ri);
		if(type==1)
		{
			node ans=sear(le,ri,1);
			cout<<ans.mm<<endl;
		}
		else
			change(le,ri,1);
	} 
	
	return 0;
}
```


---

## 作者：Nickel_Angel (赞：16)

**题目大意：**

初始给定一个长度为$n$的序列$\{a_n\}$，有$m$次操作：

操作1：给定$L,R$，询问$a_{L \cdots R}$的最大子段和

操作2：给定$p,s$，表明将$a_p$的值改为$s$

看到大家都是用线段树直接维护的区间最大子段和QwQ

不过本题可以用动态dp的方法来做……

首先考虑将最大子段和的普通dp方程写出来：（这里设数列为$\{a_n\}$）

$g[i]$表示由$a_{1 \cdots i}$的子序列所构成的且选入最大子段和的最后一个数为$a[i]$的最大子段和

$f[i]$表示由$a_{1 \cdots i}$的子序列所构成的最大子段和

故有：

$g[i] = max(g[i-1] + a[i], a[i])$

$f[i] = max(f[i - 1], g[i])$

根据动态dp的套路，将这个方程写成矩阵形式，并更改矩阵乘法的定义：

将原来的定义（这里设矩阵$A,B$相乘得到矩阵$C$，并要求$A$矩阵的列数等于$B$矩阵的行数）：

$C_{ij} = \sum A_{ik} \times C_{kj}$

变为：

$C_{ij} = max(A_{ik} + C_{kj})$

~~不难发现max同样拥有结合律，故新定义的矩阵乘法同样具有结合律~~

发现由于$f[i]$的转移需依靠$g[i]$，而$g[i]$在转移时是未知的（即我们不便于将$f[i - 1],g[i -1],g[i]$同时列在一个矩阵中），故可将$g[i]$拆为$max(g[i-1] + a[i], a[i])$进行转移（即$f[i] = max(f[i - 1],g[i - 1] + a[i], a[i])$）

这样再写成矩阵的形式：

$$\begin{bmatrix} a[i] & -\infty & a[i] \\ a[i] & 0 & a[i] \\ -\infty & -\infty & 0 \end{bmatrix} \times \begin{bmatrix}  g[i-1] \\ f[i-1] \\ 0 \end{bmatrix} = \begin{bmatrix} g[i] \\ f[i] \\ 0 \end{bmatrix}$$

检验一下我们写的是否正确：

将矩阵乘开得：

$g[i] = max(a[i] + g[i-1],-\infty,a[i])$

$f[i] = max(a[i] + g[i - 1], f[i - 1], a[i])$

$0 = max(-\infty, -\infty, 0)$

对比前文的式子，看来我们写的是正确的……

这样对于序列中每一个元素$a_i$，均有矩阵：

$$\begin{bmatrix} a[i] & -\infty & a[i] \\ a[i] & 0 & a[i] \\ -\infty & -\infty & 0 \end{bmatrix}$$

不妨设$a_i$所对应的矩阵为$A_i$，不难发现，当我们询问$a_{L \cdots R}$的最大子段和时，只需将$A_{L \cdots R}$相乘即可；

容易想到使用线段树来维护区间内矩阵的乘积，即对于矩阵序列$\{A_n\}$，建一棵支持单点修改区间查询的线段树即可。

Code：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

template<typename T>
inline bool chkmax(T &x, const T &y) {return x < y ? (x = y, true) : false;}

const int inf = 0x3f3f3f3f;
const int maxn = 500010;
int n, m, score[maxn];

struct Matrix
{
    int v[3][3];//这里矩阵下标是从v[0][0]开始
    
    Matrix operator * (const Matrix &rhs) const
    {
        Matrix res;
        for (int i = 0; i < 3; ++i)
        {
            for (int j = 0; j < 3; ++j)
            {
                res.v[i][j] = -inf;
            }
        }
        for (int i = 0; i < 3; ++i)
        {
            for (int k = 0; k < 3; ++k)//矩阵乘法优化
            {
                for (int j = 0; j < 3; ++j)
                {
                    chkmax(res.v[i][j], v[i][k] + rhs.v[k][j]);
                }
            }
        }
        return res;
    }
};

class Segtree
{
    #define lson root << 1
    #define rson root << 1 | 1
    private:
        Matrix val[maxn << 2];
        
        inline void pushup(int root) {val[root] = val[lson] * val[rson];}
    
    public:
        void build(int s, int e, int root)
        {
            if (s == e)
            {
                val[root].v[0][0] = val[root].v[1][0] =
                val[root].v[0][2] = val[root].v[1][2] = score[s];
                val[root].v[0][1] = val[root].v[2][0] =
                val[root].v[2][1] = -inf;
                val[root].v[1][1] = val[root].v[2][2] = 0;
                //按照前文所述构造a[i]对应的A[i]
                return;
            }
            int mid = (s + e) >> 1;
            build(s, mid, lson);
            build(mid + 1, e, rson);
            pushup(root);
        }
        
        void modify(int s, int e, int pos, int root, int k)
        {
            if (s == e)
            {
                val[root].v[0][0] = val[root].v[1][0] = 
                val[root].v[0][2] = val[root].v[1][2] = k;
                return;
            }
            int mid = (s + e) >> 1;
            if (pos <= mid) modify(s, mid, pos, lson, k);
            else modify(mid + 1, e, pos, rson, k);
            pushup(root);
        }
        
        Matrix query(int s, int e, int ql, int qr, int root)
        {
            if (ql <= s && e <= qr) return val[root];
            int mid = (s + e) >> 1;
            if (ql <= mid && qr > mid)
                return query(s, mid, ql, qr, lson) * 
                query(mid + 1, e, ql, qr, rson);
            else if (ql <= mid) return query(s, mid, ql, qr, lson);
            else return query(mid + 1, e, ql, qr, rson);
        }
    #undef lson
    #undef rson
}tree;

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", score + i);
    tree.build(1, n, 1);
    int opt, x, y;
    Matrix res;
    while (m--)
    {
        scanf("%d%d%d", &opt, &x, &y);
        if (opt == 1)
        {
            if (x > y) swap(x, y);//题目中不保证x < y,当x > y时,需交换
            res = tree.query(1, n, x, y, 1);
            printf("%d\n", max(res.v[1][0], res.v[1][2]));//注意需选f[i],g[i]中最优的
        }
        else
            tree.modify(1, n, x, 1, y);
    }
    return 0;
}
```



---

## 作者：Lysus (赞：14)

这是我第一道自己切的线段树（蒟蒻）


------------

~~做过线段树题的都知道这题不难~~


维护的值有 

_1._ sum_l从左边开始的最大字段和（包括左端点）

_2._ sum_r从右边开始的最大字段和（包括右端点）

_3._ sum区间最大字段和

_4._ tot区间和

常规合并
```
void update(int u, int x, int y) {
	tree[u].sum = max(max(tree[u << 1].sum, tree[u << 1 | 1].sum), tree[u << 1].sum_r + tree[u << 1 | 1].sum_l);
	//从（左边和右边的区间最大字段和 还有 左边的sum_r加右边的sum_l ）得到 
	tree[u].tot = tree[u << 1].tot + tree[u << 1 | 1].tot;
	tree[u].sum_l = max(tree[u << 1].sum_l, tree[u << 1].tot + tree[u << 1 | 1].sum_l);
	//从（左边延伸（tree[u << 1].tot + tree[u << 1 | 1]) 或 左边的sum_l）得到.....下同 
	tree[u].sum_r = max(tree[u << 1 | 1].sum_r, tree[u << 1 | 1].tot + tree[u << 1].sum_r);
}
```
提醒：update的时候不要和 原数 一起max（只有我会）！因为可能会改小。。。

废话不多说，上代码
```
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAX = 500010;

int n, m;
int a[MAX];
struct node{
	int sum_l, sum_r, sum;
	int tot;
}tree[MAX * 10];

inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') w= -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * w;
}
void update(int u, int x, int y) {
	tree[u].sum = max(max(tree[u << 1].sum, tree[u << 1 | 1].sum), tree[u << 1].sum_r + tree[u << 1 | 1].sum_l);
	//从（左边和右边的区间最大字段和 还有 左边的sum_r加右边的sum_l ）得到 
	tree[u].tot = tree[u << 1].tot + tree[u << 1 | 1].tot;
	tree[u].sum_l = max(tree[u << 1].sum_l, tree[u << 1].tot + tree[u << 1 | 1].sum_l);
	//从（左边延伸（tree[u << 1].tot + tree[u << 1 | 1]) 或 左边的sum_l）得到.....下同 
	tree[u].sum_r = max(tree[u << 1 | 1].sum_r, tree[u << 1 | 1].tot + tree[u << 1].sum_r);
}
void build(int u, int x, int y) {
	if(x == y) {
		tree[u].sum = tree[u].sum_l = tree[u].sum_r = tree[u].tot = a[x];
		return ;
	}
	int mid = (x + y) >> 1;
	build(u << 1, x, mid);
	build(u << 1 | 1, mid + 1, y);
	update(u, x, y);
}
node ask(int u, int x, int y, int a, int b) {//询问要返回node 
	if(a <= x && b >= y) return tree[u];
	int mid = (x + y) >> 1;
	if(a > mid) return ask(u << 1 | 1, mid + 1, y, a, b);
	if(b <= mid) return ask(u << 1, x, mid, a, b);
	node son_l = ask(u << 1, x, mid, a, b), son_r = ask(u << 1 | 1, mid + 1, y, a, b);
	node ans;
	ans.tot = son_l.tot + son_r.tot;
	ans.sum = max(max(son_l.sum, son_r.sum), son_l.sum_r + son_r.sum_l);
	ans.sum_l = max(son_l.sum_l, son_l.tot + son_r.sum_l);
	ans.sum_r = max(son_r.sum_r, son_r.tot + son_l.sum_r);
	return ans;
}
void change(int u, int x, int y, int a, int k) {
	if(x == y && x == a) {
		tree[u].sum = tree[u].sum_l = tree[u].sum_r = tree[u].tot = k;
		return ;
	}
	int mid = (x + y) >> 1;
	if(a <= mid) change(u << 1, x, mid, a, k);
	if(a > mid) change(u << 1 | 1, mid + 1, y, a, k);
	update(u, x, y);
}
int main()
{
	n = read();
	m = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	build(1, 1, n);
	while(m--) {
		int k = read();
		if(k == 1) {
			int x = read(), y = read();
			if(y < x) swap(x, y);
			printf("%d\n", ask(1, 1, n, x, y).sum);
		}
		if(k == 2) {
			int x = read(), z = read();
			change(1, 1, n, x, z);
		}
	}
	return 0;
}
```





---

## 作者：Obito (赞：11)

#### 先分析一下题目大概意思。意思很简单

#### 你需要完成两种操作。

#### 1.将X的点进行更改

#### 2.求a到b区间的最大子段和

### 看到这里，脑袋里第一眼浮现的解题方法就是线段树。（不会线段树左转[线段树](https://www.luogu.org/problem/P3372) ）

### why？？

### 单点修改，区间查询，线段树不就可以处理吗？

#### 现在问题来了：该怎么处理最大子段和呢？

我们不难想到，一个区间的最大子段和源于三个地方；

### 1.左边界以左的最大子段和。
### 2.右边界以右的最大子段和。
### 3.中间向两边拓展的最大子段和。

### 思路已经有了具体看代码。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=(500000+10)*4;

int num[maxn],addval[maxn];
struct node{
	int lx,sum,rx,ans,l,r;
    
    //lx:左边界以左的最大子段和；
    //rx：右边界以右的最大子段和；
    //ans：最后的最大子段和
    //sum：区间总和
    //l：左边界，r 右边界
}tree[maxn]; 

void build(int k,int left,int right){//建树
	tree[k].l=left;
	tree[k].r=right;//左右范围
	if(left==right){
		tree[k].sum=tree[k].lx=tree[k].rx=tree[k].ans=num[left];//初始值
		return ; 
	}
	int mid=(left+right)>>1;//二分拓展
	build(k*2,left,mid);
	build(k*2+1,mid+1,right);
	tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;//求区间总和
	tree[k].lx=max(tree[k*2].lx,tree[k*2].sum+tree[k*2+1].lx);//左边界最大值有两种可能：1.左子树的最大子段和，2.左子树的总和，加上右子树的左边界起始的最大子段和。
	tree[k].rx=max(tree[k*2+1].rx,tree[k*2+1].sum+tree[k*2].rx);//右子树同理，可以自己推一下
	tree[k].ans=max(max(tree[k*2].ans,tree[k*2+1].ans),tree[k*2].rx+tree[k*2+1].lx);//最终值比较
}

node query(int k,int lt,int rt){//查询
	if(lt<=tree[k].l&&rt>=tree[k].r)return tree[k];//区间被包含，全部返回
	node a,b,ans;//取出左子树，右子树
	a.lx=a.rx=a.ans=a.ans=-2047483647;
	b.lx=b.rx=b.ans=b.ans=-2047483647;
	a.sum=b.sum=0;
	ans.ans=-2047483647;
	ans.sum=0;
	int mid=(tree[k].l+tree[k].r)>>1;
	if(lt<=mid){
		a=query(k*2,lt,rt);
		ans.sum+=a.sum;
	}
	if(rt>=mid+1){
		b=query(k*2+1,lt,rt);
		ans.sum+=b.sum;
	}
	ans.ans=max(a.rx+b.lx,max(a.ans,b.ans));//和建树时的想法相同
	ans.lx=max(a.lx,a.sum+b.lx);
	ans.rx=max(b.rx,b.sum+a.rx);
	if(lt>mid){
		ans.lx=max(ans.lx,b.lx);
	}
	if(rt<mid){
		ans.rx=max(ans.rx,a.rx);
	}
	return ans;
}
void modify(int k,int lt,int rt,int qx,int val){//更改，和建树想法差不多
    if(qx<lt||qx>rt)return ;
    else if(lt==qx&&rt==qx){
        tree[k].ans=tree[k].lx=tree[k].rx=tree[k].sum=val;
        return ;
    }
    else {
        int mid=lt+(rt-lt)/2;
        modify(k*2,lt,mid,qx,val);
        modify(k*2+1,mid+1,rt,qx,val);
		tree[k].sum=tree[k*2].sum+tree[k*2+1].sum;
		tree[k].lx=max(tree[k*2].lx,tree[k*2].sum+tree[k*2+1].lx);
		tree[k].rx=max(tree[k*2+1].rx,tree[k*2+1].sum+tree[k*2].rx);
		tree[k].ans=max(max(tree[k*2].ans,tree[k*2+1].ans),tree[k*2].rx+tree[k*2+1].lx);
		return ;
    }
}
signed main(){//主函数
	int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    scanf("%lld",&num[i]);
    build(1,1,n);
    for(int i=1;i<=m;i++){
        int pre,x,y,z;
        scanf("%lld%lld%lld",&pre,&x,&y);
        if(pre==2){
        modify(1,1,n,x,y);   
        }
        else {
		if(x>y)swap(x,y);
        node a=query(1,x,y);
        cout<<a.ans<<endl;	
        }
        
    }
	   
	return 0;
} 
/*
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2
*/
```

### 代码就是这样，主要是码字较多。

#### 看懂之后，推荐两道题
### 1.[好一个一中腰鼓](https://www.luogu.org/problem/P2253)

### 2.[你能回答这些问题吗？（一样的）](https://www.acwing.com/problem/content/description/246/)

---

## 作者：Refined_heart (赞：10)

题解里平衡树不多？来一个$Splay$.

平衡树是可以维护区间信息的，每次在序列中相应位置插入$val$,同时还有它的节点编号。当询问区间$[l,r]$时，可以转化为，将$l-1$和$r+1$转到根，那么，根的右子树的左子树就代表区间$[l,r]$的信息。为了方便，我们将左右端点$+1$，就变成了$[l,r+2]$。

还有一点要注意的是，在给出区间编号时，需要在树中寻找左右端点的位置，因为序列的某个元素在树上的位置是不确定的。了解基本操作后，问题就在于维护区间信息了。

对于单点修改，直接修改就行了，注意是修改树上的位置。

对于区间最大子段和，看代码中的注释吧。

$Code:$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int inf=2147483647;
int tot,n,m,rt,opt,a,b;
struct node{
	int ch[2],fa,siz;
	int ls,rs,ms,val,sum;
}tr[500001];
inline void pushup(int x){
	int lc=tr[x].ch[0],rc=tr[x].ch[1];
	tr[x].siz=tr[tr[x].ch[0]].siz+tr[tr[x].ch[1]].siz+1;
	tr[x].sum=tr[lc].sum+tr[rc].sum+tr[x].val;
	//以上是平衡树维护sum和siz的操作 
	tr[x].ls=max(tr[lc].ls,tr[rc].ls+tr[lc].sum+tr[x].val);
	//与线段树类似，平衡树也要维护三个信息，左边的最大连续和，右边最大连续和以及合并的最大连续和
	//对于ls，它的信息由： 左子树的ls，以及右子树的ls+本身的val+左孩子的sum取max转移得到 
	tr[x].rs=max(tr[rc].rs,tr[rc].sum+tr[lc].rs+tr[x].val);
	//对于rs，与ls类似，同样是这样转移 
	tr[x].ms=max(tr[lc].ms,max(tr[rc].ms,tr[lc].rs+tr[x].val+tr[rc].ls));
	//对于ms，它的信息由：左孩子的ms，右孩子的ms，左孩子的rs+本身的val+右孩子的ls取max得到 
}
inline void rotate(int x){
	int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x;
	tr[z].ch[tr[z].ch[1]==y]=x;tr[x].fa=z;
	tr[y].ch[k]=tr[x].ch[k^1];tr[tr[x].ch[k^1]].fa=y;
	tr[x].ch[k^1]=y;tr[y].fa=x;pushup(y);pushup(x);
}
inline void splay(int x,int g){
	while(tr[x].fa!=g){
		int y=tr[x].fa,z=tr[y].fa;
		if(z!=g)(tr[z].ch[0]==y)^(tr[y].ch[0]==x)?rotate(x):rotate(y);
		rotate(x);
	}
	if(!g)rt=x;
}
int find(int x){
	int u=rt;
	if(tr[u].siz<x)return 0;
	while(u){
		int y=tr[u].ch[0];
		if(tr[y].siz>=x)u=y;
		else{
			x-=tr[y].siz+1;
			if(!x)return u;
			u=tr[u].ch[1];
		}
	}
}
inline void Insert(int x,int val){
	int F=find(x);splay(F,0);
	int p=++tot;tr[p].fa=F;
	tr[p].val=val;tr[p].ms=val;tr[p].siz=1;
	if(val>=0)tr[p].ls=tr[p].rs=val;
	if(F){
		tr[p].ch[1]=tr[F].ch[1];
		tr[tr[F].ch[1]].fa=p;tr[F].ch[1]=p;
		pushup(p);pushup(F);
	}
	splay(p,0);
}
inline void query(int l,int r){
	int L=find(l),R=find(r+2);
	splay(L,0);splay(R,L);
	printf("%d\n",tr[tr[R].ch[0]].ms);
}
inline void change(int pos,int v){
	int P=find(pos+1);
	tr[P].val=v;
	splay(P,0);
}
int main(){
	scanf("%d%d",&n,&m);
	tr[0].ms=-inf;
	Insert(0,-inf);
	for(int i=1,x;i<=n;++i){
		scanf("%d",&x);
		Insert(i,x);
	}
	Insert(n+1,-inf);
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&opt,&a,&b);
		if(opt==1){
			if(a>b)swap(a,b);
			query(a,b);
		}
		else change(a,b);
	}
	return 0;
}
```


---

## 作者：Oliver_Heldens (赞：10)

这道题的实质是线段树单点修改和维护区间最大连续字段和。

%%%tqc

tqc大佬的思路：

在build的时候预处理v(节点包含的区间最大连续子段和),

sum(节点包含的区间所有点的权值和),

maxl(从节点包含区间的左端点出发的最大连续子段和),

maxr(从节点包含区间的右端点出发的最大连续子段和),

在求[a,b]区间的最大连续子段和的时候调用。

有一个问题：
a可能大于b,
这点一开始没有注意到，
导致交了好多次都是9分(除了第1个点都是MLE),
读题千万谨慎。
```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iomanip>
#include<queue>
#include<sstream>
#include<map>
#include<set>
#define lson (o<<1)
#define rson (o<<1|1)
//定义左右儿子(洛谷网课讲义的写法)
using namespace std;
int n,m,x,y,num,a[500010];
struct Segment_Tree{
	int v,sum,maxl,maxr;
}st[2000010];
void update(int o){
	st[o].sum=st[lson].sum+st[rson].sum;
	st[o].v=max(max(st[lson].v,st[lson].maxr+st[rson].maxl),st[rson].v);//o节点包含的区间求最大连续子段和，可以全在中点的左边，也可以全在重点的右边，也可以跨越中点
	st[o].maxl=max(st[lson].maxl,st[lson].sum+st[rson].maxl);//全在左边或者包含左边的全部和右边的一部分
	st[o].maxr=max(st[rson].maxr,st[rson].sum+st[lson].maxr);//全在右边或者包含右边的全部和左边的一部分
}
void build(int o,int l,int r){
	if(l==r){st[o].maxl=st[o].maxr=st[o].sum=st[o].v=a[l];return;}//当前节点只包含一个点，四个值都是这个点的权值
	int mid=(l+r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	update(o);
}
void add(int o,int l,int r,int x,int y){
	if(l==r){st[o].maxl=st[o].maxr=st[o].sum=st[o].v=y;return;}
	int mid=(l+r)>>1;
	if(mid>=x)add(lson,l,mid,x,y);
	else add(rson,mid+1,r,x,y);
	update(o);
    //虽然函数名为add,但是其实是单点修改,和build函数相似
}
Segment_Tree query(int o,int l,int r,int lh,int rh){
	//返回值为结构体的函数
	if(l>=lh&&r<=rh)return st[o];
	int mid=(l+r)>>1;
	if(rh<=mid)return query(lson,l,mid,lh,rh);
	if(lh>mid)return query(rson,mid+1,r,lh,rh);
	Segment_Tree ltr=query(lson,l,mid,lh,rh),rtr=query(rson,mid+1,r,lh,rh);
	Segment_Tree ans;
	ans.sum=ltr.sum+rtr.sum;
	ans.v=max(max(ltr.v,rtr.v),ltr.maxr+rtr.maxl);
	ans.maxl=max(ltr.maxl,ltr.sum+rtr.maxl);
	ans.maxr=max(rtr.maxr,rtr.sum+ltr.maxr);
    //对ans的操作和update函数相似
	return ans;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    	scanf("%d",&a[i]);
	build(1,1,n);
    for(int i=1;i<=m;i++){
    	scanf("%d%d%d",&num,&x,&y);
    	if(num==1){if(x>y)swap(x,y);printf("%d\n",query(1,1,n,x,y).v);}
		else add(1,1,n,x,y);
	}
    return 0;
}
```
%%%tqc

---

## 作者：wjr_jok (赞：7)

补一个分块做法。

题意简化一下就是单点修改和找区间最大子段和。由于是分块，无法像线段树一样合并，并且值会有负数，所以使用动规。

$dp_{i,0}$ 表示从区间左端点到第 $i$ 个块的最大子段和，$dp_{i,1}$ 表示当前块能与下一个块连接时最大子段和。

另外维护了 $maxl,maxr,maxk,ans$ 四个数组，分别表示每个块从左端点开始最大子段和，从右端点开始最大子段和，块中最大子段和以及块中所有数的和。

考虑如何转移，首先 $dp_{i,0}$ 有三种情况：不包含第 $i$ 个块，第 $i$ 个块与前面的块连接或只包含第 $i$ 个块。第一种情况就是直接取 $dp_{i-1,1}$，而第二种情况因为要与前面的块连接，所以必须要取到左端点，即 $dp_{i-1,1} + maxl_{i}$，对于第三种情况，取当前块内的最大子区间和 $maxk_{i}$。

由于 $dp_{i,1}$ 代表的是与下一个块连接是的最大子段和，所以必须取到右端点，这里有两种情况：只与下一个块连接或将上一个块与下一个块相连。分别表示为 $maxr_{i}$ 和 $dp_{i-1,1} + ans_{j}$。

整理一下即可得到如下转移方程：

$\begin{cases}dp_{i,0}=max(dp_{i-1,1},max(dp_{i-1,1}+maxl_{i},maxk_{i}))\\dp_{i,1}=max(maxr_{i},dp_{i-1,1}+ans_{i})\end{cases}$

至于单点修改操作以及其它数组的维护不多赘述，只讲一下如何维护 $maxk$ 数组。

这里用到了前缀和求最大子段和，即对于每一个前缀和 $qzh_{i}$， 用它减去前面的最小前缀和，最后将这些值取最大即可得到最大子段和。

注意每次单点修改时要一同修改 $qzh,maxl,maxr,maxk$ 数组，为降低修改前缀和数组的时间复杂度，开的是二维数组，每个块单独对应一维。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read(){
    char ch=getchar();
    int r=0,w=1;
    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+ch-'0',ch=getchar();
    return r*w;
}
void write(long long n){
    if(n<0) putchar('-'),n*=-1;
    if(n>9) write(n/10);
    putchar(n%10+'0');
}
const int N=5e5+1,M=sqrt(5e5+1)*2;
int n,m,cnt,maxx,k,l,r,p,s,ll,rr,lk,rk;
int xl[N],maxl[M],maxr[M],maxk[M];
int ans[M],qzh[M][M],AC[N],cc[N];
int x[M],y[M],fk[N],dp[M][2];
signed main(){
	cin>>n>>m;
	cnt=sqrt(n);
	for(int i=1;i<=cnt;i++){
		x[i]=y[i-1]+1;
		y[i]=x[i]+cnt-1;
		for(int j=x[i];j<=y[i];j++){
			fk[j]=i;
		}
	} 
	if(y[cnt]<n){
		cnt++;
		x[cnt]=y[cnt-1]+1;
		y[cnt]=n;
		for(int i=x[cnt];i<=n;i++){
			fk[i]=cnt;
		}
	}
	for(int i=1;i<=n;i++){
		cin>>xl[i];
		ans[fk[i]]+=xl[i];
	}
	for(int i=1;i<=fk[n];i++){
		for(int j=x[i];j<=y[i];j++){
			qzh[i][j-x[i]+1]=qzh[i][j-x[i]]+xl[j];
		}
	}
	for(int i=1;i<=fk[n];i++){
		maxl[i]=maxr[i]=-LLONG_MAX;
		cnt=0;
		for(int j=x[i];j<=y[i];j++){
			cnt+=xl[j];
			maxl[i]=max(maxl[i],cnt);
		}
		cnt=0;
		for(int j=y[i];j>=x[i];j--){
			cnt+=xl[j];
			maxr[i]=max(maxr[i],cnt);
		}
		AC[x[i]]=cnt=qzh[i][1];
		for(int j=x[i]+1;j<=y[i];j++){
			cnt=min(cnt,qzh[i][j-x[i]+1]);
			AC[j]=cnt;
		}
		maxk[i]=qzh[i][1];
		for(int j=x[i]+1;j<=y[i];j++){
			maxk[i]=max(maxk[i],max(qzh[i][j-x[i]+1],qzh[i][j-x[i]+1]-AC[j-1]));
		}
	}
	for(int i=1;i<=m;i++){
		cin>>k;
		if(k==1){
			cin>>l>>r;
			if(l>r){
				swap(l,r);
			}
			ll=rr=-LLONG_MAX;
			cnt=0;
			for(int j=min(r,y[fk[l]]);j>=l;j--){
				cnt+=xl[j];
				ll=max(ll,cnt);
			}
			cc[0]=0;
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				cc[j-l+1]=cc[j-l]+xl[j];
			}
			AC[l]=cnt=cc[1];
			for(int j=l+1;j<=min(r,y[fk[l]]);j++){
				cnt=min(cnt,cc[j-l+1]);
				AC[j]=cnt;
			}
			lk=cc[1];
			for(int j=l+1;j<=min(r,y[fk[l]]);j++){
				lk=max(lk,max(cc[j-l+1],cc[j-l+1]-AC[j-1]));
			}
			if(fk[l]!=fk[r]){
				cnt=0;
				for(int j=x[fk[r]];j<=r;j++){
					cnt+=xl[j];
					rr=max(rr,cnt);
				}
				AC[x[fk[r]]]=cnt=qzh[fk[r]][1];
				for(int j=x[fk[r]]+1;j<=r;j++){
					cnt=min(cnt,qzh[fk[r]][j-x[fk[r]]+1]);
					AC[j]=cnt;
				}
				rk=qzh[fk[r]][1];
				for(int j=x[fk[r]]+1;j<=r;j++){
					rk=max(rk,max(qzh[fk[r]][j-x[fk[r]]+1],qzh[fk[r]][j-x[fk[r]]+1]-AC[j-1]));
				}	
			}
			else{
				cout<<lk<<endl;
				continue;
			}
			cnt=max(lk,rk);
			dp[fk[l]][1]=ll;
			for(int j=fk[l]+1;j<fk[r];j++){
				dp[j][0]=max(dp[j-1][1],max(dp[j-1][1]+maxl[j],maxk[j]));
				dp[j][1]=max(maxr[j],dp[j-1][1]+ans[j]);
			}
			dp[fk[r]][0]=max(dp[fk[r]-1][1],dp[fk[r]-1][1]+rr);
			for(int j=fk[l]+1;j<=fk[r];j++){
				cnt=max(cnt,dp[j][0]);
			}
			cout<<cnt<<endl;
		}
		else{
			cin>>p>>s;
			ans[fk[p]]-=xl[p];
			xl[p]=s;
			ans[fk[p]]+=xl[p];
			for(int j=x[fk[p]];j<=y[fk[p]];j++){
				qzh[fk[p]][j-x[fk[p]]+1]=qzh[fk[p]][j-x[fk[p]]]+xl[j];
			}
			maxl[fk[p]]=maxr[fk[p]]=-LLONG_MAX;
			cnt=0;
			for(int j=x[fk[p]];j<=y[fk[p]];j++){
				cnt+=xl[j];
				maxl[fk[p]]=max(maxl[fk[p]],cnt);
			}
			cnt=0;
			for(int j=y[fk[p]];j>=x[fk[p]];j--){
				cnt+=xl[j];
				maxr[fk[p]]=max(maxr[fk[p]],cnt);
			}
			AC[x[fk[p]]]=cnt=qzh[fk[p]][1];
			for(int j=x[fk[p]]+1;j<=y[fk[p]];j++){
				cnt=min(cnt,qzh[fk[p]][j-x[fk[p]]+1]);
				AC[j]=cnt;
			}
			maxk[fk[p]]=qzh[fk[p]][1];
			for(int j=x[fk[p]]+1;j<=y[fk[p]];j++){
				maxk[fk[p]]=max(maxk[fk[p]],max(qzh[fk[p]][j-x[fk[p]]+1],qzh[fk[p]][j-x[fk[p]]+1]-AC[j-1]));
			}
		}
	}
	return 0;
}
```

$Tips$：附上三倍经验：[不带修](https://www.luogu.com.cn/problem/SP1043)，[读入顺序不同](https://www.luogu.com.cn/problem/SP1716)

---

## 作者：枳椛明驿墙 (赞：6)

推销个人博客 [$Blog$](https://trifoliate-orange.github.io/2019/08/07/%E3%80%90Luogu%20P4513%E3%80%91%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD/)

线段树题，略微还用到了一些分治思想来求最大子段和。

[原题](https://www.luogu.org/problem/P4513)

**题意简述**：维护一个有$n$个元素的序列，支持单点修改和查询区间最大子段和。其中$n<=500000$，操作数$m<=100000$。

**分析**：本题要求维护区间最大子段和。静态的区间最大子段和有两种求法：一是动态规划，二是分治。

如果要用动态规划的话，显然每一次修改之后你都要再跑一遍，这样的复杂度是无法接受的。

考虑分治。设区间中点为$mid$，一个区间的最大子段和无非有三种情况：
1. 就是mid左边的最大子段和
2. 就是mid右边的最大子段和
3. 横跨mid，左边有一部分，右边有一部分

一二两种情况都很简单，那么第三种情况下，容易想到以$mid$为界限，将整个区间分成两部分，那么“横跨$mid$的最大子段和”即为“左区间的右端向左延伸的最大子段和”加上“右区间的左端向右延伸的最大子段和”。

![看图说话](https://s2.ax1x.com/2019/08/07/eopTSJ.png)

~~(小吐槽：sm.ms怎么挂了，只能先用其他图床了)~~

非常明显的二分，线段树使用可能。并且这样的话线段树单个节点存储的信息也就得到了：
```
struct node
{
    int lv;//本区间从左端向右延伸的最大子段和
    int rv;//本区间从右端向左延伸的最大子段和
    int tot;//本区间之和
    int l,r,ans;//左边界，右边界，以及本区间的【真.最大子段和】
};
```
非常明显，对于叶子结点，有`tree[p].lv=tree[p].rv=tree[p].tot=tree[p].ans`。

因为只要求单点更新，所以这里的更新非常好办。只需要递归到叶子结点，然后一层一层向上传就可以了。

**代码**
```cpp
//segtree by 枳椛明驿墙
#include<bits/stdc++.h>
using namespace std;
const int N=500001;
struct node
{
    int lv,rv,tot,l,r,ans;
}tree[N*4];

int n,m;

void read(int &x)
{
    int res=0,f=1;char ch;
    for(;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) res=res*10+(ch-'0');
    x=res*f;
}
void pushup(int p)
{
    tree[p].lv=max(tree[p<<1].lv,tree[p<<1].tot+tree[(p<<1)+1].lv);
    tree[p].rv=max(tree[(p<<1)+1].rv,tree[(p<<1)+1].tot+tree[p<<1].rv);
    tree[p].tot=tree[p<<1].tot+tree[(p<<1)+1].tot;
    tree[p].ans=max(tree[p<<1].ans,max(tree[(p<<1)+1].ans,tree[p<<1].rv+tree[(p<<1)+1].lv));
}
void build(int l,int r,int p)
{
    tree[p].l=l;tree[p].r=r;
    if (l==r)
    {
    	int x;read(x);
        tree[p].rv=tree[p].lv=tree[p].tot=tree[p].ans=x;
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,p<<1);build(mid+1,r,(p<<1)+1);
    pushup(p);
}
void updata(int x,int y,int p)
{
    if (tree[p].l==tree[p].r)
    {
        tree[p].rv=tree[p].lv=tree[p].tot=tree[p].ans=y;
        return;
    }
    int mid=(tree[p].l+tree[p].r)>>1;
    if (x<=mid) updata(x,y,p<<1);
    else updata(x,y,(p<<1)+1);
    pushup(p);
}
node query(int x,int y,int p)
{
    if (x<=tree[p].l&&tree[p].r<=y) return tree[p];
    int mid=(tree[p].l+tree[p].r)>>1;
    if (y<=mid) return query(x,y,p<<1);
    else if (x>mid) return query(x,y,(p<<1)+1);
    else
    {
        node t,t1=query(x,mid,(p<<1)),t2=query(mid+1,y,(p<<1)+1);
        t.lv=max(t1.lv,t1.tot+t2.lv);
        t.rv=max(t1.rv+t2.tot,t2.rv);
        t.tot=t1.tot+t2.tot;
        t.ans=max(max(t1.ans,t2.ans),t1.rv+t2.lv);
        return t;
    }
}

int main()
{
    read(n);read(m);
    build(1,n,1);
    for(int i=1;i<=m;i++)
    {
        int k,x,y;
        read(k);read(x);read(y);
        if (k==1)
        {
            if (x>y) swap(x,y);
            printf("%d\n",query(x,y,1).ans);
        }
        if (k==2)
        {
            updata(x,y,1);
        }
    }
    return 0;
}
```

---

## 作者：Mandy (赞：6)

/*本题求的是指定区间的最大连续子段和，和单点修改（方法略复杂，线段树与动规杂交，但空间较小） 

我们可以用结构体维护每个二分区间的总和（to）,从左边开始的最大连续子段和（le）, 从右边开始的最大连续子段和（ri） 
及该区间的最大连续子段和（v） 

再用全局量maxn存当前的最大和(只包含横跨两个或两个以上区间的情况)，maxa存以当前区间结尾的最大和，这个依据是cx函数的深搜顺序是从左到右 

cx函数的返回值是各个子区间的各自的最大和中的最大值，最后输出的是它与maxn 比较的结果 
*/


//坑点：：a可能大于b 

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,maxa,maxn;
struct ee
{
	int le,ri,v,to;
}a[2000004];

void init()
{
	freopen("1.txt","r",stdin);
}

void js(int l,int r,int z)//建树 
{
	if(l==r)
	{
		scanf("%d",&a[z].v);
		a[z].le=a[z].v;
		a[z].ri=a[z].v;
		a[z].to=a[z].v;
		return;                                            
	}
	int mid=(l+r)>>1;
	int zz=z<<1;
	int y=zz|1;
	js(l,mid,zz);
	js(mid+1,r,y);
	a[z].v=max(a[zz].v,max(a[zz].ri+a[y].le,a[y].v));
	a[z].le=max(a[zz].le,a[zz].to+a[y].le);
	a[z].ri=max(a[y].ri,a[y].to+a[zz].ri);
	a[z].to=a[zz].to+a[y].to;
}

int cx(int l,int r,int x,int y,int z)
{
	if(x<=l&&y>=r) 
	{
		if(x==l)
		{
			    maxa=a[z].ri;
			    maxn=maxa;
		}
		else
		{
			if(y!=r)
			{
			    maxn=max(max(maxn,a[z].ri),max(maxa+a[z].to,maxa+a[z].le));
			    maxa=max(maxa+a[z].to,a[z].ri);//这里是保证以当前区间结尾的子段和最大 
		    }
		    else
		    {
			    maxa=maxa+a[z].le;
			    if(maxa>maxn) maxn=maxa;
		    }//动规 
		}
		return a[z].v;
	}
	int mid=(l+r)>>1;
	int zz=z<<1;
	int maxans=-1<<31;
	if(x<=mid) maxans=cx(l,mid,x,y,zz);
	if(y>mid) maxans=max(maxans,cx(mid+1,r,x,y,zz|1));
	return maxans;
}

void xg(int l,int r,int x,int y,int z)//修改时和建树很像 
{
	if(l==r)
	{
		a[z].v=y;
		a[z].le=a[z].v;
		a[z].ri=a[z].v;
		a[z].to=a[z].v;
		return;
	}
	int mid=(l+r)>>1;
	int zz=z<<1;
	int yy=zz|1;
	if(x<=mid) xg(l,mid,x,y,zz);
	else xg(mid+1,r,x,y,yy);
	a[z].v=max(a[zz].v,max(a[zz].ri+a[yy].le,a[yy].v));
	a[z].le=max(a[zz].le,a[zz].to+a[yy].le);
	a[z].ri=max(a[yy].ri,a[yy].to+a[zz].ri);
	a[z].to=a[zz].to+a[yy].to;//维护
}

void readdata()
{
	scanf("%d%d",&n,&m);
	js(1,n,1);
	for(int i=1;i<=m;i++)
	{
		int k,a,b;
		scanf("%d%d%d",&k,&a,&b);
		if(k==1) 
		{
			int c;
		    if(a>b) c=cx(1,n,b,a,1);
			else c=cx(1,n,a,b,1);
			printf("%d\n",max(c,maxn));
		}
		else xg(1,n,a,b,1);
	}
}

int main()
{
	//init();
	readdata();
	return 0;
}
```

---

## 作者：万弘 (赞：4)

线段树经典题。

考虑由左右两个区间子区间$tl,tr$得到当前区间的最大子段和$ans$，则有
$$ans=max\{\text{tl的最大子段和，tr的最大子段和，跨越区间中点的最大子段和}\}$$
 
tl的最大子段和&tr的最大子段和递归求即可。  
跨越中点的的最大子段和=tl右端点起的向左的最大子段和+tr左端点起的向右的最大子段和

所以线段树上每个节点维护四个信息：
1.  ml:左端点起的向右的最大子段和  
2.  mr:右端点起的向左的最大子段和  
3.  mx整个区间的最大子段和  
4.  sum:区间和

然后pushup时这四个信息都更新一下

另外，由于当时我不理解如何查询，所以再解释一下：  
- 如果当前区间被要查询区间完全包含，返回当前区间的信息
- 如果要查询的区间只在当前区间的左区间，向左区间查询
- 如果要查询的区间只在当前区间的右区间，向右区间查询
- 其他情况，像pushup那样合并左右区间的查询结果，并返回

```cpp
//Wan Hong 2.2
//home
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
typedef long long ll;
typedef unsigned un;
typedef std::string str;
#define INF (1ll<<58)
ll read()
{
	char c;
	ll f=1,x=0;
	do
	{
		c=getchar();
		if(c=='-')f=-1;
	}while(c<'0'||c>'9');
	do
	{
		x=x*10+c-'0';
		c=getchar();
	}while(c>='0'&&c<='9');
	return f*x;
}
ll max(ll a,ll b)
{
	return a>b?a:b;
}
ll min(ll a,ll b)
{
    return a<b?a:b;
}

/**********/
#define MAXN 500011
ll n,m;
struct Segment_Tree
{
	#define rt t[num]
	#define tl t[num<<1]
	#define tr t[num<<1|1]
	struct node
	{
		ll ml,mr,mx,sum;
		node()
		{
			ml=mr=mx=sum=0;
		}
	}t[MAXN<<2|1];
	void pushup(un num)
	{
		rt.ml=max(tl.ml,tl.sum+tr.ml);
		rt.mr=max(tr.mr,tr.sum+tl.mr);
		rt.mx=max(tl.mr+tr.ml,max(tl.mx,tr.mx));
		rt.sum=tl.sum+tr.sum;
	}
	void build(un l=1,un r=n,un num=1)
	{
		if(l==r)
		{
			rt.ml=rt.mr=rt.mx=rt.sum=read();
			return;
		}
		un mid=(l+r)>>1;
		build(l,mid,num<<1);build(mid+1,r,num<<1|1);
		pushup(num);
	}
	void modify(un p,ll x,un l=1,un r=n,un num=1)
	{
		if(l==r)
		{
			if(l==p)rt.ml=rt.mr=rt.mx=rt.sum=x;
			return;
		}
		un mid=(l+r)>>1;
		if(p<=mid)modify(p,x,l,mid,num<<1);
		else modify(p,x,mid+1,r,num<<1|1);
		pushup(num);
	}
	node query(un ql,un qr,un l=1,un r=n,un num=1)
	{
		if(ql<=l&&r<=qr)return rt;
		un mid=(l+r)>>1;
		if(qr<=mid)return query(ql,qr,l,mid,num<<1);
		if(ql>mid)return query(ql,qr,mid+1,r,num<<1|1);
		node fl=query(ql,qr,l,mid,num<<1),fr=query(ql,qr,mid+1,r,num<<1|1),now;
		now.ml=max(fl.ml,fl.sum+fr.ml);
		now.mr=max(fr.mr,fr.sum+fl.mr);
		now.mx=max(fl.mr+fr.ml,max(fl.mx,fr.mx));
		return now;
	}
}sgt;

int main()
{
	n=read(),m=read();
	sgt.build();
	for(ll i=1;i<=m;++i)
	{
		ll op=read();
		if(op==1)
		{
			ll l=read(),r=read();
			if(l>r)std::swap(l,r);
			printf("%lld\n",sgt.query(l,r).mx);
		}
		else
		{
			ll p=read(),x=read();
			sgt.modify(p,x);
		}
	}
	return 0;
}
```

---

## 作者：yingjz (赞：4)

**来博客食用体验更佳哦：<https://yjzoier.gitee.io/hexo/p/21a9.html>**

~~我才不会告诉你们增加博客的访问量是我写题解的动力呢~~

## 题目大意

`（动态最大子段和问题）`给出一个 $n$ 个数的数列 $a_i$，需要支持 $2$ 个操作：

1. 查询区间 $[a,b]$ 上的最大子段和，即 $[a,b]$ 上**连续**的和最大的一段（$\max \{\sum_{i=l}^r a_i \ | \ l, r \in [a, b] \}$）
2. 修改第 $s$ 个数为 $p$，即修改后 $a_s = p$

## 题解

这是线段树的经典题目之一，首先因为题目要求维护**单点修改**和**区间查询**，所以我们会想到线段树；因为是单点修改所以不需要标记。

线段树维护的信息需要满足**区间加法**的性质，也就是说，我们需要考虑如何从两个子区间合并。但是，如果单单记录子区间的最大子段和，是不足以得到整个区间的最大子段和的，也就是说，我们需要维护跨越两个区间的情况，就像这样：

![20190201-01.png](https://i.loli.net/2019/02/01/5c5408bdd0c58.png)

那么如何维护子区间的信息，我们才能得到这种跨区间的最大值呢？我们分析一下跨区间有什么特点，发现它其实是由左右两区间拼合而成的，而这两个区间一个是 **$[l, mid]$ 上以右端点为一端的区间**，另一个是**$[mid + 1, r]$ 上以左端点为一端的区间**。进一步，其实这两个区间都是符合上述条件区间中的最大值。那么我们只需要额外维护每个区间中以某一端为端点的最大值就可以了。

### 实现

*上面的内容可能你没有，但是不重要，你只要看懂这一段就可以了。*

综上，我们对于线段树上的每个区间 $[l, r]$，需要维护的信息有：

1. 区间 $[l, r]$ 上的最大子段和
2. 区间 $[l, r]$ 上以 $l$ 为左端点的最大子段和
3. 区间 $[l, r]$ 上以 $r$ 为右端点的最大子段和
4. 区间 $[l,r]$ 上所有元素的和，即 $\sum_{i=l}^r a_i$

我们可以用一个结构体来记录这些信息，我们可以把 `+` 运算符重载来维护**合并**操作：

```c++
struct res {
    int all, left, right, sum;
    res operator+(const res &b){
        return (res){
            max(all, b.all, right + b.left),
            max(left, b.left + sum),
            max(b.right, right + b.sum),
            sum + b.sum
        };
    }
} val[N << 2];
```



## 代码

```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

const int N = 500007;

int n, m, a[N];

int max(int a, int b, int c) {
    return max(a, max(b, c));
}

struct res {
    int all, left, right, sum;
    res operator+(const res &b){
        return (res){
            max(all, b.all, right + b.left),
            max(left, b.left + sum),
            max(b.right, right + b.sum),
            sum + b.sum
        };
    }
} val[N << 2];

void build(int rt, int l, int r){
    if (l == r) {
        val[rt] = (res){a[l], a[l], a[l], a[l]};
        return;
    }
    int m = (l + r) >> 1;
    build(rt << 1, l, m);
    build(rt << 1 | 1, m+1, r);
    val[rt] = val[rt << 1] + val[rt << 1 | 1];
}

res query(int rt, int l, int r, int p, int q){
    if (p <= l && r <= q) return val[rt];
    int m = (l + r) >> 1;
    if (q <= m) return query(rt << 1, l, m, p, q);
    else if (p > m) return query(rt << 1 | 1, m+1, r, p, q);
    else return query(rt << 1, l, m, p, m) + query(rt << 1 | 1, m+1, r, m+1, q);
}

void change(int rt, int l, int r, int p, int q){
    if (l == r) {
        val[rt] = (res){q, q, q, q};
        return;
    }
    int m = (l + r) >> 1;
    if (p <= m) change(rt << 1, l, m, p, q);
    else change(rt << 1 | 1, m+1, r, p, q);
    val[rt] = val[rt << 1] + val[rt << 1 | 1];
}

int main(){
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    build(1, 1, n);
    for (int i = 1; i <= m; ++i){
        int k, x, y; 
        scanf("%d%d%d", &k, &x, &y);
        if (k == 1) {
            if (x > y) swap(x, y);
            printf("%d\n", query(1, 1, n, x, y).all);
        } else {
            change(1, 1, n, x, y);
        }
    }
    return 0;
}
```



---

## 作者：1379号监听员 (赞：2)

# P4513 题解
~~这还是我第一次给紫题写题解。。。~~

---

## 题目大意：
给定$n$个公园的美观值（可能有负数），求出美观值和最大的连续花园区间 $[l,r]$ 

实际上就是求**区间最大子段和**。。。

---

## 思路：
这是一道典型的区间统计问题，对于区间统计问题，我们一般使用**线段树**解决

[线段树教程](https://listening-post-1379.blog.luogu.org/post-shuo-ju-jie-gou-xian-duan-shu)

为了求出区间最大子段和，对于每个区间x，我们需要计算以下四个值：
```
sum[x] : x所代表区间的区间和
ldat[x] : 紧靠区间左端的最大子段和
rdat[x] : 紧靠区间右端的最大子段和
dat[x] : 区间最大子段和

```

这些值如何求出呢？

首先，我们考虑$dat$:

![无标题2.png](https://i.loli.net/2019/09/05/JeHP9qKl45cXrj8.png)

对于一个区间的$dat$，它只能由三个途径得来:
1. 完全在左子区间，即左子区间的$dat$(绿色部分)
2. 完全在右子区间，即右子区间的$dat$(红色部分)
3. 跨越中点，即左子区间的$rsum$加上右子区间的$lsum$(黄色部分)

那么，如何求出$ldat$和$rdat$呢？

由于$ldat$和$rdat$的求法相似，只是方向不同，这里只考虑$ldat$的求法 $\dots$

![无标题3.png](https://i.loli.net/2019/09/05/fNOaXwJ75pejxMZ.png)

$ldat$更加简单，只有两种情况：
1. 完全在左子区间，即左子区间的$ldat$(绿色部分)
2. 跨越中点，即左子区间的$sum +$ 右子区间的 $ldat$(红色部分)

看到这里，相信大家都已经知道$rdat$怎么求了，这里就不在赘述。。。

至此，问题得到完美解决 $\dots$

~~怎么可能~~

---

## Tips：
1. 测试数据可能会出现$a>b$的情况，需要进行交换...(血的教训)
2. 查询时要同时返回4个数据并按要求归并...

---

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=500001;
int n,m;
struct segment_tree{
  int l,r;
  int sum,lsum,rsum,dat;
};
segment_tree tree[maxn*4];
//宏定义
#define l(x) tree[x].l
#define r(x) tree[x].r
#define sum(x) tree[x].sum
#define lsum(x) tree[x].lsum
#define rsum(x) tree[x].rsum
#define dat(x) tree[x].dat
int read()//快读
{
  int s=0,w=1;
  char c=getchar();
  while(c<'0' || c>'9')
  {
    if(c=='-') w=-1;
    c=getchar();
  }
  while(c>='0' && c<='9')
  {
    s=(s<<3)+(s<<1)+(c^48);
    c=getchar();
  }
  return s*w;
}
void update(int p)//归并信息
{
  sum(p)=sum(p<<1)+sum(p<<1|1); //区间和
  lsum(p)=max(lsum(p<<1),sum(p<<1)+lsum(p<<1|1)); //紧靠区间左端的最大子段和
  rsum(p)=max(rsum(p<<1|1),sum(p<<1|1)+rsum(p<<1));//紧靠区间右端的最大子段和
  dat(p)=max({dat(p<<1),dat(p<<1|1),rsum(p<<1)+lsum(p<<1|1)}); //区间最大子段和
}
void build(int p,int l,int r) //建树
{
  l(p)=l,r(p)=r;
  if(l(p)==r(p)){ //如果是叶子结点
    sum(p)=lsum(p)=rsum(p)=dat(p)=read(); //初始化的同时读入，高效建树
    return;
  }
  int mid=(l+r)>>1;
  build(p<<1,l,mid);
  build(p<<1|1,mid+1,r);
  update(p);
}
void change(int p,int addr,int c) //单点修改
{
  if(l(p)==r(p))
  {
    sum(p)=lsum(p)=rsum(p)=dat(p)=c;
    return;
  }
  int mid=(l(p)+r(p))>>1;
  if(addr<=mid) change(p<<1,addr,c);
  else if(addr>mid) change(p<<1|1,addr,c);
  update(p);
}
segment_tree ask(int p,int l,int r) //区间查询（要同时返回4个数据）
{
  if(l<=l(p) && r>=r(p)) return tree[p];
  int ans=0xc0c0c0c0;
  int mid=(l(p)+r(p))>>1;
  if(r<=mid) return ask(p<<1,l,r);
  if(l>mid) return ask(p<<1|1,l,r);
  else{
    segment_tree x,y,ans;
    x=ask(p<<1,l,r),y=ask(p<<1|1,l,r);
    ans.sum=x.sum+y.sum;
    ans.lsum=max(x.lsum,x.sum+y.lsum);
    ans.rsum=max(y.rsum,y.sum+x.rsum);
    ans.dat=max({x.dat,y.dat,x.rsum+y.lsum});
    return ans;
  }
//  return ans;
}
int k,a,b;
int main()
{
  n=read(),m=read();
  build(1,1,n);
  for(int i=1;i<=m;i++)
  {
    k=read();
    if(k==1)
    {
      a=read(),b=read();
      if(a>b) swap(a,b);
      printf("%d\n",ask(1,a,b).dat);
    }
    else if(k==2)
    {
      a=read(),b=read();
      change(1,a,b);
    }
  }
  return 0;
}


```



---

## 作者：Patrickpwq (赞：2)

题意 给定n个数 并且不停地单点修改 询问[l,r]区间里的连续子段的最大值
考虑使用线段树 并且运用一点dp知识
但是如何维护？想到了P2253那道线段树XOR模板 对于一个节点 我们考虑维护它的区间从左到右包含最左端点的最大值 以及从右到左的最大值 以及整体的最大值 以及当前区间的权值和。

那转移方程就出来了
tree[now].lmax=max(tree[lson].lmax,tree[lson].v+tree[rson].lmax);
	tree[now].rmax=max(tree[rson].rmax,tree[rson].v+tree[lson].rmax);
	tree[now].allmax=max(max(tree[lson].allmax,tree[rson].allmax),(tree[rson].lmax+tree[lson].rmax));
	tree[now].v=tree[lson].v+tree[rson].v;

query需要分情况讨论 具体看代码

```cpp
#include<bits/stdc++.h>
#define N 500005
#define lson 2*now
#define rson 2*now+1
using namespace std;
int n,m,val[N];
struct node
{
	int l,r,lmax,rmax,allmax,v;
}tree[4*N];
inline void build(int l,int r,int now)
{
	tree[now].l=l,tree[now].r=r;
	if(l==r)
	{
		tree[now].lmax=tree[now].rmax=tree[now].allmax=tree[now].v=val[l];
		return;
	}
	int m=(l+r)>>1;
	build(l,m,lson);
	build(m+1,r,rson);
	tree[now].lmax=max(tree[lson].lmax,tree[lson].v+tree[rson].lmax);
	tree[now].rmax=max(tree[rson].rmax,tree[rson].v+tree[lson].rmax);
	tree[now].allmax=max(max(tree[lson].allmax,tree[rson].allmax),(tree[rson].lmax+tree[lson].rmax));
	tree[now].v=tree[lson].v+tree[rson].v;
}
int ans=INT_MIN;
inline node query(int l,int r,int now)
{
	if(l<=tree[now].l&&tree[now].r<=r)
	{
		return tree[now];
	}	
	int m=(tree[now].l+tree[now].r)>>1;
	if(r<=m)	return query(l,r,lson);
	else if(m<l)	return query(l,r,rson);
	else
	{
		node t,t1,t2;
		t1=query(l,r,lson);
		t2=query(l,r,rson);
		t.lmax=max(t1.lmax,t1.v+t2.lmax);
		t.rmax=max(t2.rmax,t2.v+t1.rmax);
		t.allmax=max(max(t1.allmax,t2.allmax),(t2.lmax+t1.rmax));
		return t;
	}
}
inline void update(int num,int k,int now)
{
	if(tree[now].l==tree[now].r)
	{
		tree[now].lmax=tree[now].rmax=tree[now].allmax=tree[now].v=k;
		return;
	}
	int m=(tree[now].l+tree[now].r)>>1;
	if(num<=m)	update(num,k,lson);
	else update(num,k,rson);
	
	tree[now].lmax=max(tree[lson].lmax,tree[lson].v+tree[rson].lmax);
	tree[now].rmax=max(tree[rson].rmax,tree[rson].v+tree[lson].rmax);
	tree[now].allmax=max(max(tree[lson].allmax,tree[rson].allmax),(tree[rson].lmax+tree[lson].rmax));
	tree[now].v=tree[lson].v+tree[rson].v;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL),cout.tie(NULL); 
	
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>val[i];
	}
	build(1,n,1);
	for(int i=1;i<=m;i++)
	{
		int opt,l,r;
		cin>>opt;
		if(opt==1)
		{
			cin>>l>>r;
			if(l>r)	swap(l,r);
			cout<<query(l,r,1).allmax<<endl;
		}
		if(opt==2)
		{
			cin>>l>>r;
			update(l,r,1);
		}
	}
	return 0;
} 
```

---

## 作者：Ofnoname (赞：1)

[P4513 【小白逛公园】](https://www.luogu.org/problem/P4513)

[博客广告](https://www.ofnona.me/)

注意不能不选，至少要选一个数。

本题应该是线段树题，但是做过[P2042](https://www.luogu.org/problem/P2042)或者[P2710](https://www.luogu.org/problem/P2710)的人会很容易发现，这道题的动态求最大子段和只是那道题的一部分，并且区间是静态的，只涉及单点修改，不用维护懒标记，相当轻松。所以我选择`FHQ Treap`。

维护每一个点的区间和，最大前缀和，最大后缀和，最大子段和。

- 修改权值： 将这个点分离出来，将它的值，区间和，子段和都赋值为c，将最大前缀和，最大后缀和赋值为`max(0, c)`.

- pushup函数：`size`，`summ`的更新自不必提。最大前缀和显然就是“左一半的前缀和”或“左边总和加上右一半前缀和”，最大后缀和同理，而最大子段和有三种情况：“左段的后缀+右段的前缀”或者“左段的最大子段和”“右段的最大子段和”

因为至少要选一个数，所以最大子段和必须赋为自身。使用儿子的前缀后缀更新自己的子段和时，显然自己时必须选的，所以前缀后缀是可以不选的（即赋值为`max(0, c)`）。

```cpp
#define MAX (500000 + 7)
#include <bits/stdc++.h>
#define i0 a[i].L
#define i1 a[i].R
using namespace std;

int N, M, nc, root, A, B, C, pt[MAX];

struct Node {
	int L, R, seed, c, max0, max1, max, summ, size;
}a[MAX];

int newp(int c)
{
	a[++nc] = (Node){0, 0, rand(), c, max(c, 0), max(c, 0), c, c, 1};
	return nc;
}

void pushup(int i)
{
	a[i].size = a[i0].size + a[i1].size + 1;
	a[i].summ = a[i0].summ + a[i1].summ + a[i].c;
	a[i].max0 = max(max(a[i0].max0, a[i0].summ + a[i].c + a[i1].max0), 0);
	a[i].max1 = max(max(a[i1].max1, a[i1].summ + a[i].c + a[i0].max1), 0);
	a[i].max = max(a[i0].max1 + a[i1].max0, 0) + a[i].c;
	if (i0) a[i].max = max(a[i].max, a[i0].max);
	if (i1) a[i].max = max(a[i].max, a[i1].max);
}

void split(int i, int &x, int &y, int k)
{
	if (!i)
	{
		x = y = 0;
		return;
	}
	if (a[i0].size < k)
		x = i, split(i1, i1, y, k - a[i0].size - 1);
	else
		y = i, split(i0, x, i0, k);
	pushup(i);
}

int merge(int x, int y)
{
	if (!x || !y) return x + y;
	if (a[x].seed < a[y].seed)
	{
		a[x].R = merge(a[x].R, y);
		pushup(x); return x;
	}
	a[y].L = merge(x, a[y].L);
	pushup(y); return y;
}

int add(int l, int r)
{
	if (l != r) {
		int mid = l + r >> 1;
		return merge(add(l, mid), add(mid+1, r));
	} else return newp(pt[l]);
}

int main()
{
	srand(time(0));
	
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= N; i++)
		scanf("%d", &pt[i]);
	root = add(1, N);
	
	while (M--)
	{
		int op, x, y;
		scanf("%d%d%d", &op, &x, &y);
		if (op == 1){
			if (x > y) swap(x, y);
			split(root, A, B, x-1), split(B, B, C, y-x+1);
			printf("%d\n", a[B].max);
			root = merge(merge(A, B), C);
		}
		else {
			split(root, A, B, x-1), split(B, B, C, 1);
			a[B].max0 = a[B].max1 = max(0, y);
			a[B].max = a[B].c = a[B].summ = y;
			root = merge(merge(A, B), C);
		}
	}
}
```

---

## 作者：蒟蒻365 (赞：1)

维护一个区间带单点修改最大子段和

假如我们要求1到n中，静态区间子段和怎么搞？

就像这样：

```
f[i]=max(a[i],f[i-1]+a[i]);//f[j]表示以j结尾的最大子段和
```

显然与前面的连上或者再另起一个两种情况。若另起一个则f[j-1]<0，此时也不会出现“后来选了它而值更大”的情况，显然减去一个负数值是会变得更大的

------------

回到这道题。看到单点修改，又要维护区间的信息，想到线段树。但线段树所维护的内容必须具有区间可合并性。若我们直接维护区间最大子段和，显然无法合并。

看上文中，我们为何可以进行递推？**因为我们确定了一个点，即以i结尾**

所以我们在线段树中维护以其维护区间左端点开始、右端点开始的最大子段和，及整个区间的最大子段和。

```
struct p{
	int fl/*左边开始*/,fr/*右边开始*/,mx/*整段区间的最大子段和*/;
}tree[maxn<<2];
```

tree[k].mx要么就是左儿子或右儿子的mx，或者跨越了左右儿子分别维护的区间，即tree[k<<1].fr+tree[k<<1|1].fl

mx能够维护了，fl和fr又怎么更新呢？

对于fl，要么其包含的区间就只在左儿子里，要么跨越了左区间，到达了右区间，也就是说包含了完整的左区间+右区间部分

所以我们还得维护一个区间和

写出来长这样：

```
tree[k].fl=max(tree[k<<1].fl,tree[k<<1].w/*w维护区间和*/+tree[k<<1|1].fl);
```
右儿子同理

### 你以为这就完了？
 
~~真完了~~ 还有一个重要的玩意儿，叫做查询呢

## 关于查询

个人觉得这是我在这题上一个比较大的收获

以前做的题大多都是维护区间和，所以我的查询代码都长这样：

```
void query(int k,int kl,int kr,int x,int y){
	if(kl>=x&&kr<=y){
		sumans+=tree[k].w;
		return ;
	}
	int mid=(kl+kr)>>1;
	if(mid>=x) query(k<<1,kl,mid,x,y);
	if(mid<y) query(k<<1|1,mid+1,kr,x,y);
}
```
这一次理所当然地写成了这样：
```
void query(int k,int kl,int kr,int x,int y){
	if(kl>=x&&kr<=y){
		ans=max(ans,tree[k].mx);
		return ;
	}
	int mid=(kl+kr)>>1;
	if(mid>=x) query(k<<1,kl,mid,x,y);
	if(mid<y) query(k<<1|1,mid+1,kr,x,y);
}
```
听取WA声一片...如果最大子段和跨越的我维护的两个区间就挂了...

为啥之前可以，现在不行嘞？

**因为原来若查询两个区间，合并起来就是直接让sumans加上tree[k].w，而现在的合并形式却需要与合并左右儿子的push_up操作类似**

所以查询函数如果写成void类型，根本就没办法做了。所以我们**定义成结构体类型**

```
p query(int k,int kl,int kr,int x,int y){
	bool f1=0,f2=0;//f1表示是否在左区间中，f2表示是否在右区间中
	p a,b;//分别记录左边部分、右边部分的返回值
	if(kl>=x&&kr<=y) return tree[k];//如果当前节点维护区间被访问区间完全包含，就可以直接返回
	int mid=(kl+kr)>>1;
	if(mid>=x) f1=1,a=query(k<<1,kl,mid,x,y);//询问左儿子
	if(mid<y) f2=1,b=query(k<<1|1,mid+1,kr,x,y);//右儿子
	if(f1&f2){//如果跨越了两个区间
		p x;
		x.w=a.w+b.w;
		x.fl=max(a.fl,a.w+b.fl);
		x.fr=max(b.fr,b.w+a.fr);
		x.mx=max(max(x.fl,x.fr),a.fr+b.fl);
		x.mx=max(x.mx,max(a.mx,b.mx));//与push_up类似。实际上就是为了push_up才需要传结构体
		return x;//往上传
	}//另外可能会有人担心你如果扔掉了左边，它可不可能在之后加入最大子段和（就是本人啦
    //实际上这个问题和静态的解释是一样的，可以回去再看看
	if(f1) return a;
	if(f2) return b;//询问了左儿子就返回左儿子，询问右儿子返回右儿子
}
```

**实际上很重要的一点就是，非void型的查询函数更加灵活，能够应对具有更加神奇的合并的查询操作**

### 完整代码
```
#include<bits/stdc++.h>
#define maxn 500001
#define INF 0x3f3f3f3f
using namespace std;
struct p{
	int fl,fr,mx,w;
}tree[maxn<<2];
int ans;
inline int read(){
	int s=0,f=1;
	char c;
	c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){s=(s<<3)+(s<<1)+c-48;c=getchar();}
	return s*f;
}
inline int max(int x,int y){return x>y?x:y;}
inline void pushup(int k){
	tree[k].w=tree[k<<1].w+tree[k<<1|1].w;
	tree[k].fl=max(tree[k<<1].fl,tree[k<<1].w+tree[k<<1|1].fl);
	tree[k].fr=max(tree[k<<1|1].fr,tree[k<<1|1].w+tree[k<<1].fr);
	tree[k].mx=max(max(tree[k].fl,tree[k].fr),tree[k<<1].fr+tree[k<<1|1].fl);
	tree[k].mx=max(max(tree[k].mx,tree[k<<1].mx),tree[k<<1|1].mx);
	return ;
}
void build(int k,int l,int r){
	if(l==r){
		tree[k].w=read(),tree[k].fl=tree[k].fr=tree[k].mx=tree[k].w;
		return ;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
p query(int k,int kl,int kr,int x,int y){
	bool f1=0,f2=0;
	p a,b;
	if(kl>=x&&kr<=y) return tree[k];
	int mid=(kl+kr)>>1;
	if(mid>=x) f1=1,a=query(k<<1,kl,mid,x,y);
	if(mid<y) f2=1,b=query(k<<1|1,mid+1,kr,x,y);
	if(f1&f2){
		p x;
		x.w=a.w+b.w;
		x.fl=max(a.fl,a.w+b.fl);
		x.fr=max(b.fr,b.w+a.fr);
		x.mx=max(max(x.fl,x.fr),a.fr+b.fl);
		x.mx=max(x.mx,max(a.mx,b.mx));
		return x;
	}
	if(f1) return a;
	if(f2) return b;
}
void add(int k,int kl,int kr,int node,int w){
	if(kl==kr&&kl==node){
		tree[k].fl=tree[k].fr=tree[k].mx=tree[k].w=w;
		return ;
	}
	int mid=(kl+kr)>>1;
	if(mid>=node) add(k<<1,kl,mid,node,w);
	else add(k<<1|1,mid+1,kr,node,w);
	pushup(k);
}
int main(){
	int n,m;
	n=read(),m=read();
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int opt,x,y;
		opt=read(),x=read(),y=read();
		if(opt==1){
			if(x>y) swap(x,y);
			printf("%d\n",query(1,1,n,x,y).mx);
		}
		if(opt==2)
			add(1,1,n,x,y);
	}
	return 0;
}
```

完结撒花~~~

---

## 作者：_sry (赞：1)


建一棵线段树，一个节点维护$4$个东西，最大前缀和，最大后缀和，最大连续和，总的权值和，先说最大前缀和怎么进行维护，我们只需看一看左儿子的最大前缀和，但是有可能终点不止包含左节点的所有，还有可能有右节点的最长前缀和，所以就将左儿子的所有权值加上右儿子的最长前缀和，然后其他都是这样处理。在查询中有可能右端点在$mid$的右面，所以需要特判取最优解

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read()
{
    int f=1,ans=0;char c;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
struct node{
    int ans,ls,rs,sum;
}xx[2000001];
int n,m,val[2000001];
void pushdown(int x){
    xx[x].sum=xx[x<<1].sum+xx[x<<1|1].sum;
    xx[x].ls=max(xx[x<<1].ls,xx[x<<1].sum+xx[x<<1|1].ls);
    xx[x].rs=max(xx[x<<1|1].rs,xx[x<<1|1].sum+xx[x<<1].rs);
    xx[x].ans=max(xx[x<<1].ans,max(xx[x<<1|1].ans,xx[x<<1].rs+xx[x<<1|1].ls));
    return;
}
void build(int k,int l,int r){
    if(l==r){
        xx[k].ls=xx[k].rs=xx[k].ans=xx[k].sum=val[l];
        return;
    }
    int mid=l+r>>1;
    build(k<<1,l,mid),build(k<<1|1,mid+1,r);
    pushdown(k);
    return;
}
void change(int k,int l,int r,int x,int y,int w){
    if(x<=l&&r<=y){
        xx[k].ls=xx[k].rs=xx[k].ans=xx[k].sum=w;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid) change(k<<1,l,mid,x,y,w);
    if(mid<y) change(k<<1|1,mid+1,r,x,y,w);
    pushdown(k);
    return;
}
node query(int k,int l,int r,int x,int y){
    if(x<=l&&r<=y) {
        return xx[k];
    }
    int mid=l+r>>1;
    if(x<=mid&&!(mid<y)) return query(k<<1,l,mid,x,y);
    else if(!(x<=mid)&&mid<y) return query(k<<1|1,mid+1,r,x,y);
    else{
        
        node st,t1=query(k<<1,l,mid,x,y),t2=query(k<<1|1,mid+1,r,x,y);
        st.sum=t1.sum+t2.sum;
        st.ls=max(t1.ls,t1.sum+t2.ls);
         st.rs=max(t2.rs,t2.sum+t1.rs);
        st.ans=max(t1.ans,max(t2.ans,t1.rs+t2.ls));
        return st;
    }
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) val[i]=read();
    build(1,1,n);
    while(m--){
        int pd=read();
        if(pd==2){
            int x=read(),w=read();
            change(1,1,n,x,x,w);
        }
        else if(pd==1){
            int l=read(),r=read();
            if(l>r) swap(l,r);
            printf("%d\n",query(1,1,n,l,r).ans);
        }
    }
}
```

---

## 作者：Genius_Z (赞：1)

[$\Large\color{red}{Bl}\color{blue}{og}$](http://geiz-revive.github.io/)

~~颓完文化课回来做水题能愉悦身心~~

题意就是单点修改，区间最大子段和，硬上线段树即可，维护是经典方法，如果换成区间修改也是可以做的。有兴趣可以去做一做$GSS$系列的题，最大子段和是个经典模型，尽量要掌握。

```cpp
node operator +(const node &a, const node &b) {
	node c;
	c.tot = a.tot + b.tot;
	c.lsum = max(a.lsum, b.lsum + a.tot);
	c.rsum = max(b.rsum, a.rsum + b.tot);
	c.sum = max({ a.sum,b.sum,a.rsum + b.lsum });
	return c;
}
```



其中$tot$代表原数列中的值的和，$sum$是最大子段和，$lsum$是最大前缀和，$rsum$是最大后缀和，维护想一想应该就很显然了。

$\large Code:$

```cpp
#pragma region revive
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define son(x,y) t[x].child[y]
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++)=(c))
#define io_eof() (IOB.in.p>=IOB.in.pend)
struct IOBUF { struct { char buff[1 << 26], *p, *pend; }in; struct { char buff[1 << 26], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;
#endif
template<typename IO>
inl void write(IO x) {
	if (x == 0) return (void)putchar('0');
	if (x < 0)putchar('-'), x = -x;
	static char buf[30];
	char* p = buf;
	while (x) {
		*(p++) = x % 10 + '0';
		x /= 10;
	}
	while (p > buf)putchar(*(--p));
}
inl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }
template<typename IO>inl void writeln(IO x) { write(x), putchar('\n'); }
template<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
	char *begin = s, c = getchar();
	while (c < 33 || c>127) {
		c = getchar();
	}
	while (c >= 33 && c <= 127) {
		*(s++) = c;
		c = getchar();
	}
	*s = 0;
	return s - begin;
}
template<typename IO>
inl IO read() {
	IO x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
#undef ls
#undef rs
#define ls(x) ((x)<<1)
#define rs(x) (ls(x)|1)
struct node {
	int lsum, rsum, sum, tot;
}t[10000001];
node operator +(const node &a, const node &b) {
	node c;
	c.tot = a.tot + b.tot;
	c.lsum = max(a.lsum, b.lsum + a.tot);
	c.rsum = max(b.rsum, a.rsum + b.tot);
	c.sum = max({ a.sum,b.sum,a.rsum + b.lsum });
	return c;
}
int a[1000001];
inl void maintain(int x) {
	t[x] = t[ls(x)] + t[rs(x)];
}
inl void change(int k, int l, int r, int p, int w) {
	if (l == r) return (void)(t[k].tot = t[k].sum = t[k].lsum = t[k].rsum = w);
	re mid = l + r >> 1;
	if (p <= mid)change(ls(k), l, mid, p, w);
	else change(rs(k), mid + 1, r, p, w);
	maintain(k);
}
inl void build(int k, int l, int r) {
	if (l == r) return (void)(t[k].tot = t[k].sum = t[k].lsum = t[k].rsum = a[l]);
	re mid = l + r >> 1;
	build(ls(k), l, mid), build(rs(k), mid + 1, r);
	maintain(k);
}
inl node query(int k, int l, int r, int x, int y) {
	if (l >= x && r <= y)return t[k];
	re mid = l + r >> 1;
	node ans = { 0,0,0,0 };
	if (x <= mid) {
		ans = query(ls(k), l, mid, x, y);
		if (y > mid)ans = ans + query(rs(k), mid + 1, r, x, y);
	}
	else if (y > mid)ans = query(rs(k), mid + 1, r, x, y);
	return ans;
}
signed main() {
	re n = read<int>(), m = read<int>(), op, x, y;
	for (re i = 1; i <= n; i++)a[i] = read<int>();
	build(1, 1, n);
	while (m--) {
		op = read<int>(), x = read<int>(), y = read<int>();
		if (op == 1) { if (x > y)swap(x, y); writeln(query(1, 1, n, x, y).sum); }
		else change(1, 1, n, x, y);
	}
}
```



---

## 作者：Mudrobøt (赞：1)

![](http://cc.amazingcounters.com/counter.php?i=3224480&c=9673753[/img])

[题目传送门](https://vijos.org/p/1083)

这道题是一道线段树的一个求一个连续最大字段和是一个区间线段树一个很妙妙的操作，这里后面我们后面就会提到，因为今天博主没有时间了所以先粘一篇代码供大家参考，其实代码理解还是非常的简单的。

今天突然发现这篇题解写的非常的水，所以这里我再来补充一下，其实重点主要就在update函数中，因为没有区间修改，所以说没有pushdown这个玩意儿，所以说本题的关键其实就在于对于update的把握，update主要用于就是当我们在建树（Build_tree）和修改(modify)的时候我们用来在递归回来的时候顺便修改一下，一般我们的线段树只需要update一下下面两个子树的大小，就可以了。然后我们就可以实现一些比较基础的操作，但是我们发现这道题的操作非常的高级啊，他要让我们求连续最大子段和，所以说经过我们的一番脑补，我们可以非常容易的知道，这个操作我们应该从小的地方开始，然后逐渐积少成多，最后得到答案，那么能实现这个操作的只有update，所以说我们只需要在update上下一些功夫，那么这道题我们就可以解决了。代码我不是非常想讲，因为写的还是非常的直接的，我这里就提醒大家一下我申明的变量应该就可以了。

```
rmax是从右开始的最大连续字段和
同理 lmax
l是左区间位置，r是右区间位置。
son存儿子
maxtot存当前区间的最大连续子段和
```

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
struct data{
	int rmax,lmax,maxtot,sum;
	int l,r,son[2];
}node[1010000];
int ini[501000];
int n,k;
int cnt=0;
void update(int k)
{
	node[k].sum=node[node[k].son[0]].sum+node[node[k].son[1]].sum;
	node[k].lmax=max(node[node[k].son[0]].lmax,node[node[k].son[0]].sum+node[node[k].son[1]].lmax);
	node[k].rmax=max(node[node[k].son[1]].rmax,node[node[k].son[1]].sum+node[node[k].son[0]].rmax);
	node[k].maxtot=max(node[node[k].son[0]].maxtot,node[node[k].son[1]].maxtot);
	node[k].maxtot=max(node[k].maxtot,node[node[k].son[0]].rmax+node[node[k].son[1]].lmax);
}
void Build_tree(int &k,int l,int r)
{
	cnt++;
	k=cnt;
	node[k].l=l;node[k].r=r;
	if(l==r)
	{
		node[k].sum=ini[l];node[k].lmax=ini[l];node[k].rmax=ini[l];node[k].maxtot=ini[l];return;
	}
	int mid=(l+r)/2;
	Build_tree(node[k].son[0],l,mid);
	Build_tree(node[k].son[1],mid+1,r);
	update(k);
}
void modify(int k,int goal,int val)
{
	if(node[k].l==node[k].r&&node[k].l==goal)
	{
		node[k].sum=val;node[k].lmax=val;node[k].rmax=val;node[k].maxtot=val;
	}
	else
	{
		int mid=(node[k].l+node[k].r)/2;
		if(mid>=goal)
		modify(node[k].son[0],goal,val);
		else
		{
			modify(node[k].son[1],goal,val);
		}
		update(k);
	}
}
data query(int k,int l,int r)
{
	if(node[k].l==l&&node[k].r==r)
	{
		return (data){node[k].rmax,node[k].lmax,node[k].maxtot,node[k].sum,0,0,0,0};
	}
	else
	{
		int mid=(node[k].l+node[k].r)/2;
		if(r<=mid) return query(node[k].son[0],l,r);
		if(l>mid)  return query(node[k].son[1],l,r);
		else
		{
			data d1=query(node[k].son[0],l,mid);
			data d2=query(node[k].son[1],mid+1,r);
			data ret;
			ret.sum=d1.sum+d2.sum;
			ret.lmax=max(d1.lmax,d1.sum+d2.lmax);
			ret.rmax=max(d2.rmax,d1.rmax+d2.sum);
			ret.maxtot=max(d1.maxtot,d2.maxtot);
			ret.maxtot=max(ret.maxtot,d1.rmax+d2.lmax);
			return ret;
		}
	}
}
int main()
{
	
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&ini[i]);
	}
	int root=0;
	Build_tree(root,1,n);
	int a,b,c;
	for(int i=1;i<=k;++i)
	{
		scanf("%d%d%d",&a,&b,&c);
		if(a==2)
		{
			modify(1,b,c);
		}
		else
		{
			if(b>c)
			{int a;a=b;b=c;c=a;}
			cout<<query(1,b,c).maxtot<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Smallbasic (赞：1)

## 线段树好题

指针党有福利啦

众所周知，单点修改区间询问的问题用线段树来做必须要求一个节点的信息能被两个子节点合并出来。

先考虑一个区间，知道了左子区间的最大子段和和右子区间的最大子段和，如何$\Theta(1)$求出这个区间的最大子段和。

如果这个子段落在左区间或右区间内,直接取$max$.

如果落在中间，就考虑对每个节点维护一个左端点为$l$的最大字段和$ml$以及右端点为$r$的最大子段和$mr$，就有：

$$ans_i=max(ans_{l_i},ans_{r_i},mr_{l_i}+ml_{r_i})$$

修改操作就是单点修改常规操作了。

查询操作直接返回答案很麻烦，考虑直接把询问区间所包含的区间取出来，重新建树。如果用指针实现，因为只需要根节点，所以要一边建树一边释放内存，不然会$MLE$.

代码：

```
#include <bits/stdc++.h>

using namespace std;

int n, m, a[500001], o, l, r, k;

inline int read() {
	register int s = 0, f = 1;
	register char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
	return s * f;
}

inline int max_(int a, int b) {
	return a > b ? a : b;
}

struct node {
	int l, r, ml, mr, mx, sum;
	node *left = NULL;
	node *right = NULL;
	
	inline void update() {
		if (this -> l >= this -> r) return ;
		this -> sum = this -> left -> sum + this -> right -> sum;
		this -> ml = max_(this -> left -> ml, this -> left -> sum + this -> right -> ml);
		this -> mr = max_(this -> right -> mr, this -> right -> sum + this -> left -> mr);
		this -> mx = max_(max_(this -> left -> mx, this -> right -> mx), this -> left -> mr + this -> right -> ml);
	}
	
	void build(int l, int r) {
		this -> l = l; this -> r = r;
		if (l >= r) {
			this -> sum = this -> ml = this -> mr = this -> mx = a[l];
			return ;
		}
		this -> left = new node; this -> left -> build(l, l + r >> 1);
		this -> right = new node; this -> right -> build((l + r >> 1) + 1, r);
		this -> update();
	}
	
	void modify(int p, int s) {
		if (this -> l == this -> r) this -> sum = this -> ml = this -> mr = this -> mx = s;
		else { 
			if (p <= this -> left -> r) this -> left -> modify(p, s);
			else this -> right -> modify(p, s);
			this -> update();
		} 
	}
	
	node* query(int l, int r) {
		node *rt = new node; rt -> l = this -> l; rt -> r = this -> r; rt -> mx = this -> mx;
		rt -> sum = this -> sum; rt -> ml = this -> ml; rt -> mr = this -> mr;
		if (this -> l >= l && this -> r <= r) return rt;
		if (r <= this -> left -> r) return this -> left -> query(l, r);
		if (l > this -> left -> r) return this -> right -> query(l, r);
		rt -> left = this -> left -> query(l, r); rt -> right = this -> right -> query(l, r);
		rt -> update(); delete rt -> left; delete rt -> right; return rt;
	}
};

int main() {
	node *root = new node;
	n = read(); m = read();
	for (register int i = 1; i <= n; ++i) a[i] = read();
	root -> build(1, n);
	while (m--) {
		o = read(); l = read(); r = read();
		if (o == 1) {
			if (l > r) swap(l, r);
			node *cur = root -> query(l, r);
			printf("%d\n", cur -> mx); delete cur;
		} else root -> modify(l, r);
	}
	delete root;
	return 0;
}
```


---


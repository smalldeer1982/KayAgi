# 【模板】自适应辛普森法 1

## 题目描述

试计算积分

$\displaystyle{\int_L^R\frac{cx+d}{ax+b}\mathrm{d}x}$

结果保留至小数点后 $6$ 位。

数据保证计算过程中分母不为 $0$ 且积分能够收敛。

## 说明/提示

$a,b,c,d\in[-10,10]$，$-100\le L<R\le 100$ 且 $R-L\ge1$。

## 样例 #1

### 输入

```
1 2 3 4 5 6```

### 输出

```
2.732937```

# 题解

## 作者：qianfujia (赞：171)

### 我表示我是来砸场子的
> 纯数学推导
$$\int_L^R\frac{cx+d}{ax+b}dx$$
$$(\frac{cx}{a}+(\frac{d}{a}-\frac{bc}{a^2})*\ln|ax + b|)|^R_L$$
特判0

### code
```cpp
#include<bits/stdc++.h>
#define eps 1e-8
double a, b, c, d, l, r;
double f(double x)
{
    return c * x / a + (d / a - b * c / (a * a)) * log(a * x + b);
}
double f2(double x)
{
	cout << "o";
    return ((c * x * x) / (2 * b) + (d * x) / b);
}
using namespace std;
int main()
{
    scanf("%lf%lf%lf%lf%lf%lf", &a, &b, &c, &d, &l, &r);
    if(abs(a) == 0)
        printf("%.6lf", f2(r) - f2(l));
    else printf("%.6lf", f(r) - f(l));
    return 0;
}
```

---

## 作者：ikka (赞：50)

# **更好的阅读体验请参考[我的博客](https://phqghume.github.io/2018/05/19/自适应辛普森法/)**

# Simpson公式

在学习Simpson公式之前最好要对**定积分**有一个基本的了解，不过不了解也没有关系 ~~（比如我）~~

Simpson公式就是在积分区间$[a,b]$上去找三个点$a,b$和$m=(a+b)/2$，计算其原函数的在此处的值，然后用抛物线来拟合原函数。

## 定积分计算方法

定积分就是求函数$f(x)$在区间$[a,b]$中的图像包围的面积。即由$y=0,x=a,x=b,y=f(x)$所围成图形的面积。

这里的面积是有正负的，$y=0$上方的面积为正，下方为负。

如何计算呢，可以用把区间分成几个小区间然后把小区间的积分求解再求和的方法，这时候就要用到Simpson公式了

## Simpson公式推导

推导过程除了一个步骤其余都是初中内容了，推导过程如下

设$f(x)$为原函数，$g(x)=Ax^2+Bx+C$为拟合后的函数，则有

$$\int_a^bf(x)dx$$
$$\approx\int_a^bAx^2+Bx+C$$
$$=\frac{A}{3}(b^3-a^3)+\frac{B}{2}(b^2-a^2)+C(a-b)$$
$$=\frac{(b-a)}{6}(2A(b^2+ab+a^2)+3B(b+a)+6C)$$
$$=\frac{(b-a)}{6}(2Ab^2+2Aab+2Aa^2+3Bb+3Ba+6C)$$
$$=\frac{(b-a)}{6}(Aa^2+Ba+C+Ab^2+Bb+C+4A(\frac{a+b}{2})^2+4B(\frac{a+b}{2})+4C)$$
$$=\frac{(b-a)}{6}(f(a)+f(b)+4f(\frac{a+b}{2}))$$

然后就得到了**Simpson公式** 

$$\int_a^bf(x)dx\approx\frac{(b-a)(f(a)+f(b)+4f(\frac{a+b}{2}))}{6}$$

用C++语言描述如下

``` cpp
inline double simpson(double l,double r) {
	double mid=(l+r)/2;
	return (f(l)+4*f(mid)+f(r))*(r-l)/6; //f(x)是原函数
}
```

# 自适应辛普森法

我们知道了定积分的计算方法，也知道了Simpson公式，按理说可以计算了。

但是有一个很重要的问题需要注意：**精度**。

区间分少了精度可能不够，区间分多了又会太慢，**自动控制区间分割的大小**，就是自适应辛普森法的好处。

实现很简单，就是二分递归的过程，如果满足了精度需要，则可以终止递归，而这就是自适应辛普森法能够自动控制区间分割大小的手段。

代码如下

``` cpp
double asr(double l,double r,double eps,double ans) {
	double mid=(l+r)/2;
	double l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<=15*eps) return l_+r_+(l_+r_-ans)/15;
	return asr(l,mid,eps/2,l_)+asr(mid,r,eps/2,r_);
}
inline double asr(double l,double r,double eps) {
	return asr(l,r,eps,simpson(l,r));
}
```

调用的时候只要给出区间起点和终点和需要的精度就可以了

---

这个题的话直接套板子就没有问题，注意精度精确到1e-6

``` cpp
#include <bits/stdc++.h>
double a,b,c,d,l,r;
inline double f(double x) {
	return (c*x+d)/(a*x+b);       //原函数
}
inline double simpson(double l,double r) {      //Simpson公式
	double mid=(l+r)/2;
	return (f(l)+4*f(mid)+f(r))*(r-l)/6;
}
double asr(double l,double r,double eps,double ans) {
	double mid=(l+r)/2;
	double l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<=15*eps) return l_+r_+(l_+r_-ans)/15;     //确认精度
	return asr(l,mid,eps/2,l_)+asr(mid,r,eps/2,r_);     //精度不够则递归调用
}
inline double asr(double l,double r,double eps) {
	return asr(l,r,eps,simpson(l,r));
}
int main() {
	scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
	printf("%.6lf",asr(l,r,1e-6));
	return 0;
}
```

---

## 作者：FZzzz (赞：37)

## 写在前面
本题解包含两部分：
1. 一个我看起来比较舒服的数学推导
1. 自适应辛普森的一个简单~~并且没什么卵用~~的优化
## 数学推导
看好多大佬都用数学方法做的，但是我这个垃圾并看不懂。所以这里给出一个好懂一点的优化。

记被积函数为$f(x)$。

首先，我们谈判$a=0$的情况。

这种情况比较简单，我就不说了。（逃

若$a\not=0$，将被积函数进行代数变形
$$\begin{aligned}f(x)&=\frac{cx+d}{ax+b}\\&=\frac{c}{a}+\frac{\frac{ad-bc}{a}}{ax+b}\end{aligned}$$
则
$$\int f(x)\mathrm{d}x=\int\frac{c}{a}\mathrm{d}x+\frac{ad-bc}{a}\int\frac{\mathrm{d}x}{ax+b}$$
加号左边那个积分是很容易积出来的，而查一下积分表，有
$$\int\frac{\mathrm{d}x}{ax+b}=\frac{1}{a}\ln|ax+b|+C$$
故
$$\int f(x)\mathrm{d}x=\frac{ad-bc}{a^2}\ln|ax+b|+\frac{cx}{a}+C$$
于是就可以积出题目中那个式子了。代码如下：
```cpp
#include<cmath>
#include<cstdio>
double a,b,c,d;
double F(double x){
    return (a*d-b*c)*log(fabs(a*x+b))/(a*a)+c*x/a;
}
double F2(double x){
    return c*x*x/(2*b)+d*x/b;
}
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    double l,r;
    scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
    if(a!=0.0) printf("%.6f\n",F(r)-F(l));
    else printf("%.6f\n",F2(r)-F2(l));
    return 0;
}
```
## 自适应辛普森
普通的自适应辛普森我就不多说了，代码如下：
```cpp
#include<cmath>
#include<cstdio>
double a,b,c,d;
double f(double x){
    return (c*x+d)/(a*x+b);
}
//区间[a,b]上的辛普森值
double simpson(double a,double b){
    double c=a+(b-a)/2;
    return (f(a)+4*f(c)+f(b))*(b-a)/6;
}
//区间[a,b]上的积分，精度限制为eps，已知整个区间的辛普森值A
double asr(double a,double b,double eps,double A){
    double c=a+(b-a)/2;
    double L=simpson(a,c),R=simpson(c,b);
    if(fabs(L+R-A)<=15*eps) return L+R+(L+R-A)/15;
    else return asr(a,c,eps/2,L)+asr(c,b,eps/2,R);
}
const double eps=1e-7;
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    double l,r;
    scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
    printf("%.6f\n",asr(l,r,eps,simpson(l,r)));
    return 0;
}
```
然后我翻了一下题解，竟然所有大佬都是这么写的。

仔细看一下这份代码，我们发现，有很多函数值被重复计算了很多次。在本题中，这是不要紧的。但在一些题中，函数值不能用常数时间计算。所以，我们需要维护算过的函数值。代码如下：
```cpp
#include<cmath>
#include<cstdio>
double a,b,c,d;
double f(double x){
    return (c*x+d)/(a*x+b);
}
//区间[a,b]上的辛普森值，已知区间长度l和端点及中点处的函数值A，B，C
double simpson(double l,double A,double B,double C){
    return (A+4*C+B)*l/6;
}
double asr(double a,double b,double eps,double A,double B,double C){
    double l=b-a;
    double c=a+l/2;
    double D=f(a+l/4),E=f(a+3*l/4);
    double L=simpson(l/2,A,C,D),R=simpson(l/2,C,B,E),AB=simpson(l,A,B,C);
    if(fabs(L+R-AB)<=15*eps) return L+R+(L+R-AB)/15;
    else return asr(a,c,eps/2,A,C,D)+asr(c,b,eps/2,C,B,E);
}
const double eps=1e-7;
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    double l,r;
    scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
    printf("%.6f\n",asr(l,r,eps,f(l),f(r),f(l+(r-l)/2)));
    return 0;
}
```
我知道这种码风很难看，但是我找不到好看的了……

------------
完结撒花！~~顺便骗赞~~

---

## 作者：Ebola (赞：18)

#### 广告：[我的博客](http://ebola.blogwo.com/2018/06/20/%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)

## 导入
众所周知，对于计算机而言，给定具体数值的计算是非常简单的，但要让计算机实现公式推导，那是难上加难。可是，卡西欧计算器却有积分这么一项功能。你觉得是它内部实现了公式推导？那为什么它不输出它“推导”出的不定积分公式，而是只支持定积分求值呢？而且为什么输出的答案与人工带入积分公式算出的结果相差无几呢？本文就来探讨这一问题。

## 知识预备

### 1.函数的拟合
如果给定了一个奇怪的函数，我们可以用一个图像与它近似的初等函数来代替它，这样的过程称之为“拟合”

### 2.二次函数的定积分

对于一个二次函数F(x)，它在[l,r]区间内的定积分值为(F(l)+4F(mid)+F(r))*(r-l)/6

## 正文部分

我们可以把给定函数当做一个二次函数，然后直接套二次函数的定积分公式

这样的精度误差是非常大的，会算出一些离谱的答案。那我们考虑将函数分段

函数的每一段，我们都用一个二次函数去拟合它，得出这一段的近似值。如果我们把整个函数分成非常多段，那我们得出的值也就近似于答案了

分成非常多段？究竟是多少段？

一个显然的事情就是：如果我们分的段太少，答案会不精确；如果我们分的段太多，程序的运行时间会让人绝望

于是我们让程序进行一个“自适应”操作。即，如果这一段函数与拟合出的二次函数非常相似，那么我们直接把这一段当做二次函数，套公式算出结果；如果这一段与拟合出的二次函数不甚相似，那么我们把这一段分成两半，并递归进行这一过程

如何判断这一段函数与拟合出的二次函数的相似程度呢？

我们可以对整段、左半部分、右半部分分别套二次函数定积分公式进行计算，结果分别记作A,、L、R，若L+R与A相差的值不超过我们设定的精度了，那就认为这一段函数与拟合出的二次函数非常相似

这样计算的时间复杂度取决于程序的迭代次数，也就是给定函数与二次函数的相似程度。当然，也取决于你设定的精度，精度越低越快，但答案误差也越大，具体的精度选择要看题目的要求

## 模板
```cpp
const double eps=精度要求;
double F(double x){需要积分的函数}
double simpson(double l,double r)
{
	double mid=(l+r)/2;
	return (F(l)+4*F(mid)+F(r))*(r-l)/6;
}
double asr(double l,double r,double A)
{
	double mid=(l+r)/2;
	double L=simpson(l,mid),R=simpson(mid,r);
	if(fabs(L+R-A)<=15*eps) return L+R+(L+R-A)/15.0;
	return asr(l,mid,L)+asr(mid,r,R);
}
double asr(double l,double r){return asr(l,r,simpson(l,r));}
```

## 本题题解

直接往上面模板的F函数中输入本题给定函数，然后调用一次asr(l,r)即可

---

## 作者：zythonc (赞：16)

## 表示用公式算还不如直接推导简便

>看到许多题解的推导过程不是很详细，所以蒟蒻根据自己的演算过程写了一篇题解

首先我们看到 $\displaystyle{\int_L^R\dfrac{cx+d}{ax+b}dx}$

就会有一种冲动：

- **设 $u=ax+b$，此时 $u^\prime=a$**

原式就等于 $\displaystyle{\dfrac{1}{a}\int_L^R\dfrac{cx+d}{u}du}$

**以下均不再写积分上下限！！！**

**因为此时的积分变量变成了 $u$，所以我们尽量用含 $u$ 的式子来表示 $cx+d$**

式子就变成了

$\displaystyle{\dfrac{1}{a}\int\dfrac{\frac{c(u-b)}{a}+d}{u}du}$

$\displaystyle{\dfrac{1}{a}\int\dfrac{c(u-b)+ad}{au}du}$

化简亿下就是

$\displaystyle{\dfrac{1}{a}\left(\dfrac{c}{a}\int du-\dfrac{bc}{a}\int\dfrac{1}{u}du+d\int\dfrac{1}{u}du\right)}$

$=\dfrac{1}{a}\left(\dfrac{c(ax+b)}{a}-(\dfrac{bc}{a}-d)\ln|ax+b|\right)$


好了我们去愉快的切掉这道水题

且慢，我们在小学的时候就知道**分母是不能为 $0$ 的**，所以这里我们要进行特判

如果 $a=0$

原式 = $\displaystyle{\int_L^R\dfrac{cx+d}{b}dx}$

很简单啊，都不用做代换了，直接算就可以

$=\displaystyle{\int\dfrac{cx}{b}dx+\int\dfrac{d}{b}dx}$

$=\dfrac{cx^2}{2b}+\dfrac{dx}{b}$

$=\dfrac{x}{b}\left(\dfrac{cx}{2}+d\right)$

至此，本题结束

代码实现：
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
double a,b,c,d,L,R;
inline double integral(double x) {return 1/a*(c*(a*x+b)/a-(b*c/a-d)*log(abs(a*x+b)));}
inline double whenZero(double x) {return x/b*(c*x/2+d);}
signed main(){
	cin>>a>>b>>c>>d>>L>>R;
	if(!a) printf("%.6lf",whenZero(R)-whenZero(L));
	else printf("%.6lf",integral(R)-integral(L));
}
```

---

## 作者：__init__ (赞：15)

## Romberg积分法简介
众所周知, 对于在区间 $[L, R]$ 连续的函数 $f(x)$ 有如下的积分逼近公式:

* $$\int^R_Lf(x)\mathrm dx\approx \frac{R-L}2(f(R)+f(L))\qquad\qquad\quad\quad\qquad(1)$$
* $$\int^R_Lf(x)\mathrm dx\approx \frac{R-L}6(f(R)+4f(\frac{R+L}2)+f(L))\qquad(2)$$

其中 $(1)$ 式称作**梯形公式**, $(2)$ 式称作 **Simpson 公式**.

下面是 Romberg 积分法的简介:

```Romberg 积分法也称为逐次分半加速法. 它是在梯形公式, Simpson 公式之间的关系的基础上, 构造出一种加速计算积分的方法.
作为一种外推算法, 它在不增加计算量的前提下提高了误差的精度.
在等距基点的情况下, 用计算机计算积分值通常都采用把区间逐次分半的方法进行.
这样, 前一次分割得到的函数值在分半以后仍可被利用, 且易于编程.
```

简单地说, 就是二分区间, 提高精度.

下面来详细地解释 Romberg 积分法的过程.

约定:

* $I$ 称为精确值.
* $T_n(h)$ 称步长为 $h$ 的 $n$ 阶逼近算法 ( 意味着具有 $O(h^n)$ 的截断误差, 即 $I-T_n(h)=O(h^n)$ ).

那么有 ( Richardson 外推法 ):

$$
T_{m+1}(h)=\frac{r^{m+1}T_m(\frac h2)-T_m(h)}{r^{m+1}-1}\Rightarrow I-T_{m+1}=O(h^{n+1})
$$

即由 $T_m$ 外推出的 $T_{m+1}$ 具有更高一阶精度, 但计算时间复杂度不变(都是 $O(T_m(h))$ ).


回到原问题, 取

$$
I=\int^R_Lf(x)\mathrm dx
$$

根据梯形公式, 我们有:

$$
T_0=\frac{R-L}2(f(R)+f(L))
$$

取 $r=4$ 将其外推, 有

$$
T_1=\frac{4T_0(\frac h2)-T_0(h)}{4-1}
$$

$$
T_2=\frac{4^2T_1(\frac h2)-T_1(h)}{4^2-1}
$$

我们发现, 对于一些项, 我们进行了重复的计算, 考虑将计算结果打成一张表.

记$h_0=h=R-L,h_1=\frac h2,\dots,h_i=2^{-i}h$,
$R_{i,j}=T_j(h_i)$

那么

$$R_{0,0}=T_0(h_0)$$

$$R_{j,0}=\frac {R_{j-1,0}}2+h_j\sum_{i=1}^{2^{j-2}}f(L+(2i-1)h_j)$$

$$R_{j,k}=\frac{4^{k-1}R_{j,k-1}-R_{j-1,k-1}}{4^{k-1}-1}$$

其中 $1\leq k \leq j \leq n$

取 $n=10$ 即可通过本题.
```cpp
#include<cmath>
#include<cstdio>
double a,b,c,d,L,R;
double f(double x)
{
	return (c*x+d)/(a*x+b);
}
double Romberg(double g(double), double x1, double x2, int n)
{
	double R[n + 1][n + 1];
	double h[n + 1] = {0};
	R[1][1] = (x2 - x1) * (g(x1) + g(x2)) / 2.0;
	for(int j = 2; j <= n; ++j)
	{
		h[j] = (x2 - x1) / pow(2.0, j - 1);
		double sum = 0;
		for(int i = 1; i <= int(pow(2, j - 2)); ++i)
			sum += g(x1 + (2.0 * i - 1.0) * h[j]);
		R[j][1] = R[j - 1][1] / 2.0 + h[j] * sum;
		for(int k = 2; k <= j; ++k)
			R[j][k] = (pow(4.0, k - 1) * R[j][k - 1] - R[j - 1][k - 1]) / (pow(4.0, k - 1) - 1.0);
	}
	return R[n][n];
}
int main()
{
	scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&L,&R);
	double d = Romberg(f,L,R,10);
	printf("%.6lf",d);
	return 0;
}
```

#### 附 Richardson 外推法正确性的证明
采用上文约定, 取 $O(h)$ 的Taylor展开, 我们有:
$$
I-T_1(h)=O(h)=C_1h+C_2h^2+C_3h^3+\cdots
$$
$$
I-T_1(\frac h2)=O(\frac h2)=C_1(\frac h2)+C_2(\frac h2)^2+C_3(\frac h2)^3+\cdots
$$
另外
$$
T_2(h)=\frac{rT_1(\frac h2)-T_1(h)}{r-1}
$$
那么
$$
I-T_2(h)=-\frac 1rC_2h^2-\frac{r^2-1}{r^2}C_3h^3-\cdots=O(h^2)
$$
反复运用 $m$ 次即证.
#### 参考文献
[1] Timothy Sauer.《数值分析》[M]. 第二版. 北京: 机械工业出版社, 2012

---

## 作者：SuperJvRuo (赞：11)

洛谷的模板真的是越来越全、越来越细了。

自适应Simpson是一种常用于计算几何求面积的算法。

先看Simpson公式：

$$\int ^b_a f(x)dx\approx(b-a)\frac{f(a)+4f(\frac{a+b}{2})+f(b)}{6}$$

代码：
```
double simpson(double a, double b)
{
	double c = a + (b - a) / 2.0;
    return (b - a) * (F(a) + 4.0 * F(c) + F(b)) / 6.0;
}
```

这玩意准吗？当然不准。所以才要自适应一下，也就是分别计算两边的结果，再和你之前算的整个的结果比较一下。如果比较准确，就可以返回，否则递归下去：

```
double asr(double a, double b, double ans)
{
	double c = a + (b - a) / 2.0;
    double left = simpson(a, c), right = simpson(c, b);
    if(fabs(left + right - ans) < EPS)
    	return left + right;
    else
    	return asr(a, c, left) + asr(c, b, right);
}
```

是不是很**Simple**啊？

几道自适应辛普森的题：

[HDU1724 Ellipse](http://acm.hdu.edu.cn/showproblem.php?pid=1724)

[P4207 NOI2005 月下柠檬树](https://www.luogu.org/problem/show?pid=4207)，这道细节比较多

[BZOJ2178 圆形面积并](https://www.luogu.org/discuss/show/41820)

以及一些面积并，都可以用自适应Simpson骗分甚至AC，这个要看脸。

```
#include<cstdio>
#include<cmath>
#define EPS 1e-12
//设个差不多的EPS，洗把脸就水过了

double a,b,c,d;

double F(double x)
{
	return (c*x+d)/(a*x+b);
}

double simpson(double l,double r)
{
	double mid=(l+r)/2.0;
	return (r-l)*(F(l)+4.0*F(mid)+F(r))/6.0;
}

double ASR(double l,double r,double ans)
{
	double mid=(l+r)/2.0;
	double left=simpson(l,mid);
	double right=simpson(mid,r);
	if(fabs(left+right-ans)<EPS)
	{
		return left+right;
	}
	else
	{
		return ASR(l,mid,left)+ASR(mid,r,right);
	}
}

int main()
{
	double L,R;
	scanf("%lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&L,&R);
	printf("%.6lf",ASR(L,R,simpson(L,R)));
}
```

---

## 作者：过往梦魇之殇 (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P4525)

------------
**前言:**

本人初学$Simpson$公式，然后做这道题，恩，刚学的也没用上。

看到题目中的式子，好，代数变形。

结束。~~（水过了一道）~~

------------
**主要思路：**

既然是主要，那a=0时特判的简单情况就不用讲了。

下面进行题目中式子的代数变形：

$\int_{L}^{R} f(x)\, dx,$其中$f(x)=\frac{cx+d}{ax+b}$

对$f(x)$进行分离常数，得：$f(x)=\frac{c}{a}+\frac{\frac{ad-bc}{a}}{ax+b}$

将上式带入原式得：$\int_{L}^{R} f(x)\, dx=\int \frac{c}{a} dx+\frac{ad-bc}{a}\int \frac{dx}{ax+b}$

查积分表，得$\int \frac{dx}{ax+b}=\frac{1}{a}ln|ax+b|+C$

故有$\int f(x)dx=\frac{ad-bc}{a^2}ln|ax+b|+\frac{cx}{a}+C$

思路，完。

------------
**代码展示:**

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,d,l,r;
double suan(double x){//a!=0时
    return (a*d-b*c)*log(fabs(a*x+b))/(a*a)+c*x/a;
}
double special_suan(double x){//a=0时特判
    return c*x*x/(b*2)+d*x/b;
}
int main(){
    scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
    if(a==0){
        printf("%lf\n",special_suan(r)-special_suan(l));
    }
    else{
        printf("%lf\n",suan(r)-suan(l));
    }
    return 0;
}
/*
a=0: f(x)=(cx+d)/b,∫ f(x)dx=∫ c*(x^2)/(b*2)+d*x/b
a!=0: f(x)=(cx+d)/(ax+b),∫ f(x)dx=∫(ad-bc)/(a^2)*ln(fabs(ax+b))+cx/a+C
*/
```
>$Thanks$ $For$ $Watching!$

---

## 作者：Smallbasic (赞：3)

自适应辛普森法的模板。

积分的朴素求法就是用很多个小矩形来近似，但这样精度和时间都不高，考虑用其它的方法。

自适应辛普森发就是用二次函数来近似的积分。

假设用来近似的二次函数为$g(x)=ax^2+bx+c$。

那么函数$f(x)=x^n$的原函数即为：$F(x)={1\over n+1}x^{n+1}$，证明如下：

由定义得，只需证明如下式子：

$$F'(x)=f(x)=x^n$$

因为有公式：

$$f(x)=x^n,f'(x)=nx^{n-1}$$

所以:

$$F'(x)=[{1\over n+1}\cdot (n+1)]x^{n+1-1}=x^n$$

那么我们就可以得到：

$$f_1(x)=x^2\rightarrow F_1(x)={1\over 3}x^3$$

$$f_2(x)=x\rightarrow F_2(x)={1\over 2}x^2$$

$$f_3(x)=c\rightarrow F_3(x)=x$$

$$g(x)=af_1(x)+bf_2(x)+cf_3(x)$$

所以，由牛顿-莱布尼茨公式可以得到：

$$\int_l^r g(x)dx=\int_l^r [af_1(x)+bf_2(x)+cf_3(x)]dx$$

$$=a\int_l^rf_1(x)dx+b\int_l^rf_2(x)dx+c\int_l^rf_3(x)dx$$

$$=a\cdot F_1(r)|_l^r+b\cdot F_2(r)|_l^r+c\cdot F_3(r)|_l^r$$

$$={a(r^3-l^3)\over 3}+{b(r^2-l^2)\over 2}+{c(r-l)}$$

胡乱化简，最后得到：

$$(r-l)[al^2+bl+c+ar^2+bl+c+4({al^2+2alr+ar^2\over 4}+{bl+br\over 2}+c)]\over 6$$

$$={(r-l)g(r)+g(l)+4g({l+r\over 2}) \over 6}$$

$$\approx {(r-l)f(r)+f(l)+4f({l+r\over 2}) \over 6}$$

这样我们就得到自适应辛普森法的公式啦！

对于这道题，直接套公式即可。

但是这样精度可能会不够，我们就二分区间，直到达到精度就返回，详见代码吧：

```cpp
#include <iostream>
#include <cstdio> 
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

double a, b, c, d, L, R;

inline double f(double x) {
	return (c * x + d) / (a * x + b);
}

inline double simpson(double l, double r) {
	return (f(r) + f(l) + 4 * f((l + r) / 2)) * (r - l) / 6;
}

inline double getans(double l, double r) {
	double mid = (l + r) / 2;
	if (fabs(r - l) <= 1e-5) return simpson(l, r);
	return getans(l, mid) + getans(mid, r);
}

int main() {
	scanf("%lf%lf%lf%lf%lf%lf", &a, &b, &c, &d, &L, &R);
	printf("%.6lf", getans(L, R));
	return 0;
}
```


---

## 作者：nekko (赞：3)

分类讨论 $a$ 是否为 $0$

# $a=0$

$$ \begin{aligned} &\int \frac{cx+d}{ax+b}dx \\ =&\int \frac{cx+d}{b}dx \\ =&\frac{1}{b} \left(\int cx \mathop{dx} \right) + \frac{1}{b}\left(\int d \mathop{dx}\right) \\ =&\frac{cx^2}{2b}+\frac{dx}{b} \end{aligned} $$

# $a \not = 0$

$$ \begin{aligned} &\int \frac{cx+d}{ax+b}dx \\ =&\int \frac{\frac{c}{a}(ax+b)-\frac{bc}{a}+d}{ax+b}dx \\ =&\left( \int \frac{c}{a} dx \right) + \left((-\frac{bc}{a}+d)\int \frac{1}{ax+b}dx \right) \\ =& \frac{cx}{a} + (-\frac{bc}{a}+d) \frac{\ln \mid ax+b \mid}{a} \\ \end{aligned} $$

解释一下 $\int \frac{1}{ax+b} dx$ 是怎么算出来的

根据第一类换元法，有：

$$ \begin{aligned} &\int \frac{1}{ax+b} dx \\ =&\frac{1}{a}\int \frac{1}{ax+b} d(ax+b) \\ =&\frac{\ln \mid ax+b \mid}{a} \\ \end{aligned} $$

# 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    long double a, b, c, d, l, r, ans = 0;
    cin >> a >> b >> c >> d >> l >> r;
    if(fabs(a) < 1e-6) {
        ans += (c * r * r / 2 + d * r - c * l * l / 2 - d * l) / b;
    } else {
        ans += (r - l) * c / a;
        ans += (d - b * c / a) / a * (log(abs(a * r + b)) - log(abs(a * l + b)));
    }
    cout << fixed << setprecision(6) << ans << endl;
}
```

---

## 作者：Mars_Dingdang (赞：2)

## 辛普森积分
求定积分 
$$\int_a^b f(x)dx\ (a<b)$$
将闭区间等分成 $2n$  个小区间 

$[x_i,x_{i+1}](x_i<x_{i+1},x_0=a,x_{2n}=b,i\in \left\{m\in \mathbf N|m<2n\right\}$。

在每个小区间上，用抛物线近似函数 $f(x)$ 的曲线。

设 $y_i=f(x_i)$，可得到近似值 

$$\int_a^b f(x)dx≈\dfrac{b-a}{6n} \left (y_0+y_{2n}+4(y_1+y_3+\cdots +y_{2n-1})+2(y_2+y_4+\cdots +y_{2n-2}) \right ).$$

## 辛普森公式

辛普森积分法可以看作梯形法则做 Richardson 外推加速的结果。
对于积分 

$$I=\int_a^bf(x)dx,$$

如果仅用偶数号的数据点做梯形法积分，得到结果 

$$I_1=\dfrac{b-a}{n}\left(\dfrac{y_0}{2}+y_2+y_4+\cdots +y_{2n-2}+\dfrac{y_{2n}}{2}\right).$$

而如果用全部的数据点做梯形法积分，则得到

$$I_2=\dfrac{b-a}{2n}\left(\sum_{i=0}^{2n}y_i-\dfrac{y_0}{2}-\dfrac{y_{2n}}{2}\right).$$

由于梯形法积分的误差是 $O(\dfrac{1}{n^2})$，而 $I_2$ 的数据点比 $I_1$ 多一倍，故其领头阶误差为后者的 $\dfrac{1}4$。于是列出外推方程 $I-I_1≈4(I-I_2)$。经计算：

$$I≈\dfrac{4I_2-I_1}{3}=\dfrac{b-a}{6n}\left(y_0+4y_1+2y_2+\cdots +4y_{2n-1}+y_{2n}\right).$$

可见梯形法外推的结果恰好为辛普森公式。

以 $f(x) = \sin(x)$ 为例子：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
using namespace std;
double fun(double x)
{
    return sin(x);//这里可以添加其他函数
}
double Simpson(double (*f)(double),double a,double b,int n)//Simpson 求积分法
{
    const double h = (b-a)/n;
    double S = f(a) - f(b);
    for(int i = 1;i < n;i += 2) S += 4*f(a+i*h);
    for(int i = 1;i < n;i += 2) S += 2*f(a+i*h);
    return S*h/3.0;
}
int main() {
    double a,b;
    int n;//要划分的份数
    cin >> a >> b;//积分上下限
    cin >> n;//以二次曲线逼近的方式取代矩形或梯形的积分公式，所以划分越多越趋于精确值。
    cout << Simpson(fun,a,b,n) << endl;
    return 0;
}
```
## 大体思路
对于本题来说：设 $f(x)$ 为原函数，$g(x)=Ax^2+Bx+C $ 为拟合后的函数，则有:
$$\int_a^b f(x)dx≈\int_a^b Ax^2+Bx+C$$
$$=\frac{A}{3}(b^3-a^3)+\frac{B}{2}(b^2-a^2)+C(a-b)$$
$$=\frac{(b-a)}{6}\left(f(a)+f(b)+4f(a+b^2)\right)$$
## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
db a,b,c,d;
inline db f(db x){
    return (c*x+d)/(a*x+b);//计算
}
inline db simpson(db l,db r){
    return (f(l)+4.*f((l+r)/2.)+f(r))*(r-l)/6.;//辛普森积分
}
inline db asr(db l,db r,db ans,db eps){
    db mid=(l+r)/2;
    db L=simpson(l,mid);
    db R=simpson(mid,r);
    if(fabs(L+R-ans)<=14*eps) return L+R+(L+R-ans)/14;
    return asr(l,mid,L,eps/2)+asr(mid,r,R,eps/2);
}//二分答案
int main(){
    db L,R;
    scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&L,&R);//输入
    printf("%.6lf",asr(L,R,simpson(L,R),1e-6));//调用函数输出
    return 0;
}

```

---

## 作者：user2004 (赞：1)

萌新表示既不会手推不定积分，又不会二次函数积分，

那么用一次函数拟合整个函数，

用梯形面积公式$S=(a+b)×h/2$；

推出积分，控制精度即可AC~~~

紫题秒变普及-......

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
double c,d,a,b;
double f(double x)
{
	return (c*x+d)/(a*x+b);
}
double simpsongai(double l,double r)
{
	return (f(l)+f(r))*(r-l)/2;
}
double get_ans(double l,double r,double eps)
{
	double mid=(l+r)/2,result_tot=simpsongai(l,r),result_l=simpsongai(l,mid),result_r=simpsongai(mid,r);
	if(fabs(result_tot-result_l-result_r)<=eps*15) return result_tot;
	return get_ans(l,mid,eps/2)+get_ans(mid,r,eps/2);	
}
int main()
{
	double l,r;
	cin>>a>>b>>c>>d>>l>>r;
	printf("%.6lf",get_ans(l,r,0.000000001));
}
```


---

## 作者：Jμdge (赞：1)

A 了这道超短的紫题，来发表一下自己的一些想法...

# 简单介绍辛普森这玩意儿

### ~~不如先学学泰勒展开？~~

首先泰勒展开大家都听说过吧？【雾

没听说过？安利某知乎回答：[苍老师教你如何更好地记忆泰勒展开](https://www.zhihu.com/question/25627482/answer/313088784)

然后你就知道了，泰勒展开其实是对于某个函数在一个点不断去高阶求导，然后用求导得到的信息构造一个多项式，使得这个多项式在一定范围内几乎和原函数拟合（可以理解为接近重合的意思吧...） 

### 类比到辛普森？

那么其实自适应辛普森也是类似的道理，只不过它是用了分治的方法去构造这个 ~~假~~ 拟合 多项式（其实就是二次函数，究其原因应该就是这玩意儿比较好积分并且存在弧度，容易拟合吧...）

### 自适应是个什么鬼？

至于为什么前面加了个自适应呢？因为我们考虑分治是要有终止条件的（像对于一个序列分治的话就是分治的区间长度为 1 时停止），但是我们这里是在实数域上拟合一个多项式啊，不存在什么规定的终止点...

于是我们考虑怎样去设置终止条件？那当然是给定一个误差范围（比如 1e-6），然后如果拟合函数和原函数大多数点的 y 值误差不超过这个范围就终止分治，直接拿当前的函数去积分就好了，当然具体怎么比较的先别管（你看到下面之后会发现根本不需要比较两个函数 2333 ）

然后我们发现这个误差越大答案越不准确，越小跑的越慢，那么我们就要调整这个误差范围，然后这样的过程就有点像"自适应"了

### 拟合函数怎么构造？

我们先将原函数约等于成一个二次多项式：

$$f(x)≈Ax^2+Bx+C$$

然后题目要我们求的东西也转化一下：


$$ANS=\int_a^b f(x)dx$$

$$≈\int_a^b Ax^2+Bx+C$$

$$={A\over 3}(b^3-a^3) + {B\over 2} (b^2-a^2) +C(b-a)$$

$$={(b-a)\over 6}  [ 2A(b^2+ab+a^2) + 3B(b+a)+6C]$$


$$={(b-a)\over 6}  [ (Aa^2 + Ba+C) + (Ab^2+Bb+C)+4(~A~({a+b\over 2})^2 + B ({a+b\over2})+C)]$$


$$≈{(b-a)\over 6}  [~ f(a) + f(b) + 4~f({a+b\over2})~]$$

恩？你问我推导哪里来的？ [大佬%%%](https://phqghume.github.io/2018/05/19/%E8%87%AA%E9%80%82%E5%BA%94%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%B3%95/#simpson公式推导)

我们发现最后约回去了，A B C 都不见了，而且这时候式子里面已经没有积分了...

### 所以怎么构造 A、B、C 还是没讲？

没错，我们发现上面其实根本不需要用到这个拟合二次函数的具体系数 A、B、C ，只需要将 f 的式子带入计算求值就好了

但是这样的话我们发现之前说的终止条件不见了，因为我们的拟合函数已经不需要了（而且找出来也很麻烦...）

其实我们只需要比较当前区间 $[a,b]$ 不分治时候的答案 $ans$ 和 分治下的答案 $ansL+ansR$ 的误差是否超过了我们设置的精度范围就好了

至于正确性？~~（我怎么知道）~~

因为我们知道这个分治肯定是层数越多越精确的，所以分治的结果精确度肯定高于当前 ans 的精确度，那么我们卡卡精度就能让答案在误差允许范围内了



>FAQ: mmp 原来真的不用比较原函数和拟合函数...

>如果要比较的话又能怎么比较呢？反正我是不会的...



# code

代码超级短！相应的我们可以知道这里我们只需要将 f 函数改一改就能解决其他函数的积分问题了（一定精度下）

```
//by Judge
#include<bits/stdc++.h>
#define db double
using namespace std;
db a,b,c,d,l,r;
inline db f(db x){return (c*x+d)/(a*x+b);}
inline db simpson(db l,db r){ db mid=(l+r)/2;
	return (f(l)+f(r)+4*f(mid))*(r-l)/6;
}
db asr(db l,db r,db eps,db ans){
	db mid=(l+r)/2,L=simpson(l,mid),R=simpson(mid,r);
	if(fabs(L+R-ans)<=eps) return L+R+(L+R-ans);
	return asr(l,mid,eps/2,L)+asr(mid,r,eps/2,R);
}
inline db asr(db l,db r,db eps){
	return asr(l,r,eps,simpson(l,r));
}
int main(){ scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
	return !printf("%.6lf\n",asr(l,r,1e-8));
}
```




---

## 作者：BMTXLRC (赞：0)

~~我是来做数学的（~~

看到没有详细的积分推导（好像有一篇但没怎么介绍是如何推出的），不是辛普森就是直接放公式（

$\texttt{Upd 2021/05/13:}$ 将部分公式改为单行公式，部分分数的 $\LaTeX$ 使用改为 `\dfrac{x}{y}`，使题解看上去更加美观！！

------------

求：

$$\int^R_L\dfrac{cx+d}{ax+b}{\rm d}x$$

不难发现可以先拆成两个积分：

$$\int^R_L\dfrac{cx}{ax+b}{\rm d}x+\int^R_L\dfrac{d}{ax+b}{\rm d}x$$

由于 $c$ 和 $d$ 都是常数，故可以提到积分外：

$$c\int^R_L\dfrac{x}{ax+b}{\rm d}x+d\int^R_L\dfrac{1}{ax+b}{\rm d}x$$

遇到此类 $\int\dfrac{1}{ax+b}{\rm d}x$ 积分时，我们通常采用换元积分法，在这里设 $u=ax+b$。

得到：

$$c\int^R_L\dfrac{\frac{u-b}{a}}{u}{\rm d}\dfrac{u-b}{a}+d\int^R_L\dfrac{1}{u}{\rm d}\dfrac{u-b}{a}$$

又由于 $\dfrac{b}{a}$ 是一个常数，且在微分中，可以直接忽略，同时微分中的 $\dfrac{1}{a}$ 可以提出来，所以原式可以变为：

$$\dfrac{c}{a^2}\int^R_L\dfrac{u-b}{u}{\rm d}u+\dfrac{d}{a}\int^R_L\dfrac{1}{u}{\rm d}u$$

第一个积分中分子可以继续化，拆成总共三个积分：

$$\dfrac{c}{a^2}\int^R_L{\rm d}u-\dfrac{c}{a^2}\int^R_L\dfrac{b}{u}{\rm d}u+\dfrac{d}{a}\int^R_L\dfrac{1}{u}{\rm d}u$$

以及 $b$ 是个常数，从第二个积分中提出来即可：

$$\dfrac{c}{a^2}\int^R_L{\rm d}u-\dfrac{bc}{a^2}\int^R_L\dfrac{1}{u}{\rm d}u+\dfrac{d}{a}\int^R_L\dfrac{1}{u}{\rm d}u$$

至此整个积分推导就结束了，~~接下来把积分化成能看懂的形式。~~

$$\dfrac{c}{a^2}[u]^R_L-\dfrac{bc}{a^2}[\ln\lvert u\rvert]^R_L+\dfrac{d}{a}[\ln\lvert u\rvert]^R_L$$

再把 $u=ax+b$ 换回来。

那么就可以得到：

$$\dfrac{c}{a^2}[ax+b]^R_L-\dfrac{bc}{a^2}[\ln \lvert ax+b\rvert]^R_L+\dfrac{d}{a}[\ln \lvert ax+b\rvert]^R_L$$

按照定积分计算公式，把 $L$ 和 $R$ 带进去，得到：

$$ \dfrac{c}{a^2}(aR-aL)-\dfrac{bc}{a^2}(\ln \lvert aR+b\rvert-\ln \lvert aL+b\rvert)+\dfrac{d}{a}(\ln \lvert aR+b\rvert-\ln \lvert aL+b\rvert) $$

这个东西直接带进代码就行了，注意 $\ln$ 函数在C++里表示为 `log(x)`。

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,d,l,r;
int main(){
	scanf("%lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&l,&r);
	printf("%.6lf",(c/a)*(r-l)-(b*c/(a*a))*(log(fabs(a*r+b))-log(fabs(a*l+b)))+d/a*(log(fabs(a*r+b))-log(fabs(a*l+b))));
}
```


------------

交上去你就会发现自己60分，仔细观察会发现我们推出来的式子中存在 $a$ 为分母，但是 $0$ 做分母是不可以的（

所以考虑对 $a=0$ 特判：

求：

$$\int^R_L\dfrac{cx+d}{b}{\rm d}x$$

不难发现 $\dfrac{1}{b}$ 是一个常数，把他提出来：

$$\dfrac{1}{b}\int^R_L(cx+d){\rm d}x$$

再将其分成两个积分：

$$\dfrac{1}{b}\int^R_Lcx{\rm d}x+\dfrac{1}{b}\int^R_Ld{\rm d}x$$

再强调一遍 $c$ 和 $d$ 都是常数，也同样提出来：

$$\dfrac{c}{b}\int^R_Lx{\rm d}x+\dfrac{d}{b}\int^R_L{\rm d}x$$

用普通的积分公式可以得到：

$$\dfrac{c}{b}\left[\dfrac{x^2}{2}\right]^R_L+\dfrac{d}{b}[x]^R_L$$

还是同样的，将 $L$ 和 $R$ 带进去，这是最基础的定积分。

$$\dfrac{c}{b}\cdot\dfrac{R^2-L^2}{2}+\dfrac{d}{b}(R-L)$$

用代码实现，并加上刚推出来的，就可以得到总代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,d,l,r;
int main(){
	scanf("%lf %lf %lf %lf %lf %lf",&a,&b,&c,&d,&l,&r);
	if(a==0) printf("%.6lf",(c/b)*((r*r-l*l)/2)+d/b*(r-l));
	if(a!=0) printf("%.6lf",(c/a)*(r-l)-(b*c/(a*a))*(log(fabs(a*r+b))-log(fabs(a*l+b)))+d/a*(log(fabs(a*r+b))-log(fabs(a*l+b))));
}
```

时间复杂度 $O(1)$ 吧。

---

## 作者：B_1168 (赞：0)

~~萌新的首个省选难度题解qwq~~

对于一个经受过AP BC Calc折磨的学渣来说，这道题可谓是难得的轻松，其省选/NOI-的难度在一番数学操作后可以轻易压缩！

不妨研究一个不定积分，
$$\int\limits\dfrac{9x+2}{5x+3}dx$$

可以将其整理成以下形式：

$$\int\limits\dfrac{9x+\frac{27}{5}}{5x+3}-\dfrac{\frac{12}{5} }{5x+3}dx=\int\limits \dfrac{9}{5}- \dfrac{\frac{12}{5} }{5x+3}dx$$

这样便可以更加方便地求值了！

将相似的操作应用到任意给出的$a,b,c,d$组成的同型不定积分（$a\not=0$），可得

$$\int\limits_{L}^{R} \dfrac{cx+d}{ax+b}dx=\int\limits_{L}^{R} \dfrac{c}{a}-\dfrac{\frac{bc}{a}-d}{ax+b}dx$$

即可写出$a\not=0$时所求值的表达式：

$$\dfrac{c(R-L)}{a}-(\dfrac{(\frac{bc}{a^2}-\frac{d}{a})\ln{|aR+b|}}{a}-\dfrac{(\frac{bc}{a^2}-\frac{d}{a})\ln{|aL+b|}}{a})$$

~~证明留作作业~~

于是，本萌新便兴冲冲地写了以下程序提交：

```python
import math

a,b,c,d,l,r=input().split()

a=float(a);b=float(b);c=float(c);d=float(d);l=float(l);r=float(r);

ans_r=((c*r)/a)+((d/a)-((b*c)/(a*a)))*(math.log(abs(a*r+b)))

ans_l=((c*l)/a)+((d/a)-((b*c)/(a*a)))*(math.log(abs(a*l+b)))

ans=ans_r-ans_l

print("%.6f" % ans)
```
然后就……60 RE？

赶忙下载样例#7本机运行，一看----原来$a$可能取$0$！

于是~~容易~~写出：
$$\int\limits_{L}^{R} \dfrac{cx+d}{b}dx=\dfrac{c}{2b}R^2+\dfrac{d}{b}R-\dfrac{c}{2b}L^2-\dfrac{d}{b}L$$

~~证明留作作业~~

考虑到“数据保证计算过程中分母不为0且积分能够收敛”，因此$a,b$不可能同时为0，所以我们可以放心写出以下程序：

```python
import math

a,b,c,d,l,r=input().split()

a=float(a);b=float(b);c=float(c);d=float(d);l=float(l);r=float(r);

if a!=0:
    ans_r=((c*r)/a)+((d/a)-((b*c)/(a*a)))*(math.log(abs(a*r+b)))

    ans_l=((c*l)/a)+((d/a)-((b*c)/(a*a)))*(math.log(abs(a*l+b)))

    ans=ans_r-ans_l

    print("%.6f" % ans)
    
else:
    ans_r=(c*r*r/(2*b))+(d*r)/b
    
    ans_=(c*l*l/(2*b))+(d*l)/b
    
    ans=ans_r-ans_l

    print("%.6f" % ans)
```

然后就AC辣！

感谢管理审核！

~~LaTeX运用练习（确信）~~

---

## 作者：Renshey (赞：0)

考虑这么一个问题：求任意曲线与 $x$ 轴，直线 $x=l$，直线 $x=r$ 包围的图形的面积。

曲边梯形的面积问题，通常用定积分可以解决。但任意曲线就出现了一个问题：如何求解定积分？

显然对于任意函数，求解定积分不是那么容易，我们考虑用近似的方式解决问题。

假设当前处理 $[l,r]$ 部分的曲边梯形面积。由于是曲边梯形，考虑用二次函数近似。

设二次函数：$f(x)=ax^2+bx+c(x \in [l,r])$。

积分得：
$$\begin{aligned} \int_{l}^{r}f(x)dx
&=\int_{l}^{r}(ax^2+bx+c)dx
\\ &=\frac{1}{3}ax^3+\frac{1}{2}bx^2+cx+C\Big|_l^r
\\&=(\frac{1}{3}ar^3+\frac{1}{2}br^2+cr+C)-(\frac{1}{3}al^3+\frac{1}{2}bl^2+cl+C)
\\&=\frac{1}{6}(r-l)(2a(r^2+lr+l^2)+3b(l+r)+6c)
\\&=\frac{1}{6}(r-l)(2al^2+2ar^2+2alr+3bl+3br+6c)
\\&=\frac{1}{6}(r-l)((al^2+bl+c)+(ar^2+br+c)+(al^2+2alr+ar^2+2bl+2br+4c))
\\&=\frac{1}{6}(r-l)(f(l)+f(r)+4(a(\frac{l+r}{2})^2+b(\frac{l+r}{2})+c))
\\&=\frac{1}{6}(r-l)(f(l)+f(r)+4f(\frac{l+r}{2}))
\end{aligned}$$
于是我们就解决了 $[l,r]$ 部分的曲边梯形面积。

下面考虑近似的边界。我们在处理 $[l,r]$ 时，可以先用上面给出的公式算出 $[l,r],[l,\frac{l+r}{2}],[\frac{l+r}{2},r]$ 三部分曲边梯形的近似面积。若左右两边的曲边梯形近似面积和总的曲边梯形近似面积差值小于 $eps$，则返回，否则两边递归求解。这就是“自适应”的方法。一般代码实现会涉及到一些常数以及 $eps$ 的精度在传递过程中需不断提高的问题，具体参考代码。

```cpp
#include<bits/stdc++.h>
double a,b,c,d;
inline double f ( double x ) { return (c*x+d)/(a*x+b); }
inline double simpson ( double a,double b )
{
	double c=(a+b)*0.5;
	return (f(a)+f(b)+4.0*f(c))*(b-a)/6.0;
}
inline double ars ( double a,double b,double eps )
{
	double c=(a+b)*0.5,mid=simpson(a,b),l=simpson(a,c),r=simpson(c,b);
	if ( fabs(l+r-mid)<=15*eps ) return l+r+(l+r-mid)/15.0;
	return ars(a,c,eps*0.5)+ars(c,b,eps*0.5); 
}
int main()
{
	double l,r;
	scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&l,&r);
	printf("%.6lf\n",ars(l,r,1e-6));
	return 0;
}
```

---

## 作者：VeritasatireV (赞：0)

# 自适应辛普森法

[题目在这里](https://www.luogu.org/problem/P4525)

（诸位应该都有点求导的基础吧，不然来开飞机吗（滑稽））
### 前置一、不定积分求法
![](https://cdn.luogu.com.cn/upload/pic/67497.png)
![](https://cdn.luogu.com.cn/upload/pic/67500.png)
（微分微商我就不讲了，可以先忽略，神仙（我啥都不知道）可以进行系统学习）

这里就是不定积分的求法，简单的说，就是将求导的过程反过来

举个例子，如果积分积cosx，则原函数为sinx+C，因为sinx求导就是cosx
### 前置二、牛顿莱布尼兹公式
![](https://cdn.luogu.com.cn/upload/pic/67490.png)

定积分就是使不定积分有了上下界，于是这里计算的便是在区间[ a , b ]中的曲边梯形面积的代数和（可以为负）,比如这个

![](https://cdn.luogu.com.cn/upload/pic/67504.png)

上文有个引例，讲的就是变为定积分后，按照以往的积分求法，套用公式可以解决。但这个方法是有局限性的，见下图：


![](https://cdn.luogu.com.cn/upload/pic/67491.png)

得到的牛顿莱布尼兹公式便是求定积分的利器

### 三、Simpson

在了解了前置知识以后，我们便可以研究辛普森积分

话不多说，上图

![](https://cdn.luogu.com.cn/upload/pic/67480.png)
![](https://cdn.luogu.com.cn/upload/pic/67481.png)


在上述化简过程中，我们发现它运用了一个小技巧——立方差和平方差公式。（在这里提一下，以防巨神突然脑抽，暴骂题解）

然后一通乱搞可以变成一个简单的形式，也就是我们的Simpson的公式

![](https://cdn.luogu.com.cn/upload/pic/67502.png)

用a 、b代替就是

![](https://cdn.luogu.com.cn/upload/pic/67505.png)

### 四、主体算法

我们显然不能只求一次（除非你脸白到我都看不见你，你可以跟OI一比高下）

于是我们决定用把 L 到 mid  和  mid 到 R，分别拟合，并求分别的积分，

比较和L到R的总积分，如果差值小到可以忽略（<eps）,就可以了（不然你

要分到天荒地老吗）

### 五、代码
(图片有点小，可以新窗口打开看)（骚红色的CPP）
![](https://cdn.luogu.com.cn/upload/pic/67503.png)

```cpp
#include<bits/stdc++.h>
using namespace std;

double a,b,c,d,x,y;


double eps = 1e-12; //极小值 
bool dcmp(double X){
	return fabs(X)<eps;
} //比较浮点数 

double f(double X) {return (c*X+d)/(a*X+b);} //原函数 
double calc(double L,double R){return (R-L)*(f(L)+f(R)+4.0*f((L+R)/2.0))/6.0;} //Simpson积分公式 
double simpson(double l,double r,double ans); //主要算法，求积分 

signed main(){
	cin>>a>>b>>c>>d>>x>>y;
	cout<<fixed<<setprecision(6)<<simpson(x,y,calc(x,y));
	return 0;   
}

double simpson(double l,double r,double ans){ //上下界和总定积分 
	double mid = (l+r) /2.0; //中间项 
	double ans1 = calc(l,mid), ans2 = calc(mid,r); //分别计算左右两区间的定积分值 
	if(fabs(ans1+ans2-ans)<=eps) return (ans1+ans2+ans1+ans2-ans); //是否相匹配 
	return simpson(l,mid,ans1) + simpson(mid,r,ans2); //左右分别求 
}  

```







---

## 作者：ykkz000 (赞：0)

这是一道高等数学定积分的题，且被积函数有原函数，故可使用牛顿-莱布尼兹公式![](https://cdn.luogu.com.cn/upload/pic/46526.png)( F(x)为f(x)的一个原函数)

代码中原函数均取C=0(C被抵消了，不影响结果)
```cpp
#include <bits/stdc++.h>
using namespace std;
double a,b,c,d,l,r;
//a!=0 c!=0时被积函数的原函数
double F(double x){
	return c*x/a+(d-c*b/a)*log(abs(a*x+b))/a;
}
//a=0 c!=0时被积函数的原函数
double F1(double x){
	return c*x*x/(2*b)+d*x/b;
}
//a!=0 c=0时被积函数的原函数
double F2(double x){
	return d*log(abs(a*x+b))/a;
}
int main()
{
	cin>>a>>b>>c>>d>>l>>r;
    //a=0 b=0时被积函数为常数，原函数为F(x)=d/b*x
	if(a==0&&c==0) printf("%0.6lf",d*(r-l)/b);
	else if(a==0.0) printf("%0.6lf",F1(r)-F1(l));
	else if(c==0.0) printf("%0.6lf",F2(r)-F2(l));
	else printf("%0.6lf",F(r)-F(l));
	return 0;
}
```

---


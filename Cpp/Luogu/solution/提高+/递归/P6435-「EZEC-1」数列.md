# 「EZEC-1」数列

## 题目描述

给你一个正整数 $n$，有数列 $1,2,3,...,n$。

分别求相邻两项中左边一项的 $a$ 倍与右边一项的 $b$ 倍的和再加上 $c$，得到一个有 $n-1$ 项的新数列：

 $1\times a+2\times b+c,2\times a+3\times b +c,...,(n-1)\times a+n\times b+c$。

对这个新数列重复上述操作得到若干数列，最后的数列只有一项，求最后这个项对 $p$ 取模的值。

## 说明/提示

【样例解释】

样例 2：

各数列分别为：
```
1 2 3 4
9 14 19
61 86
381
```

------------

【数据范围】

| 测试点编号 | $n\le$ | $p\le$ | $a,b\le$| $c\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1\sim 4$ | $10^3$ | $10^9+7$ | $10$ |$10$|
|$5\sim 8$ | $10^6$ | $10^{14}$ | $10^3$ |$10^3$|
|$9,10$ | $10^9$ | $10^9+7$ | $1$ |$0$|
|$11,12$ | $10^9$ | $10^9+7$ | $1$ |$10^9$|
|$13,14$ | $10^{18}$ | $10^9+7$ | $1$ |$10^9$|
|$15,16$ | $10^{18}$ | $10^9+7$ | $10^9$|$10^9$|
|$17 \sim 20$ | $10^{18}$ | $10^{14}$ | $10^9$|$10^9$|

- 对于 $80 \% $ 的数据，满足 $p$ 为质数。

- 对于 $100 \% $ 的数据，满足 $1\le n\le 10^{18}$，$1\le p \le 10^{14}$，$1 \le a,b\le 10^9$，$0\le c \le 10^9$。

## 样例 #1

### 输入

```
1 1 1 1 1000000007```

### 输出

```
1```

## 样例 #2

### 输入

```
4 2 3 1 1000000007```

### 输出

```
381```

## 样例 #3

### 输入

```
23 19 17 0 1000000007```

### 输出

```
323147645```

## 样例 #4

### 输入

```
233 233 233 233 1000000000```

### 输出

```
770969703```

# 题解

## 作者：NaCly_Fish (赞：19)

打个表可以发现，对于第 $k$ 行（从零开始），实际上是公差为 $(a+b)^k$ 的等差数列，用归纳法可以证明：

对于第 $0$ 行，显然满足。

设第 $k$ 行有相邻三项 $x$，$x+(a+b)^k$，$x+2(a+b)^k$；  

那么容易得出第 $k+1$ 行对应的两项为 $ax+bx+b(a+b)^k+c$ 和 $ax+a(a+b)^k+bx+2b(a+b)^k+c$；  

做差得到 $(a+b)^{k+1}$，于是得证。

那么设 $f_n$ 为第 $n$ 行第一项的值，就有递推式：

$$f_n=af_{n-1}+b\left(f_{n-1}+(a+b)^n\right)+c$$
$$=(a+b)f_{n-1}+b(a+b)^n+c$$
直接矩阵快速幂即可，时间复杂度 $\Theta(\log n)$。

---

## 作者：0xFF (赞：6)

#### 题目大意


------------
给定一个长度为 $n$ 的序列，每次操作给出 $a,b,c$，每次操作将当前操作序列中任意相邻的两数 $x_1,x_2$ 变为 $a \cdot x_1 +b \cdot x_2 + c$ 插入到下一行的序列中，最终形成长为 $n-1$ 的新序列，输出进行 $n-1$ 次操作后序列中的数。

#### 思路分析


------------
此题属于难度较高的矩阵乘法优化递推式的题目，难点在于找出每两次操作之间的联系转移矩阵。

由于最初的序列是从 $1$ 到 $n$ 的等差序列，公差为 $1$，所以进行任意次操作后整个序列仍然保持等差序列的性质，具体证明内容题解区已有详细的解释，此处只做简略的描述：

考虑数学归纳法，设原序列为第 $0$ 层的序列。

显然未经过操作的序列为等差序列且满足公差为 $(a+b)^0$。

设第 $k$ 层满足等差序列性质且公差为 $(a+b)^k$，则其中必然存在三个相邻整数 $x,x+(a+b)^k,x+2 \cdot (a+b)^k$，那么新生成的两个数为 $(a+b)\cdot x + b \cdot (a+b)^k + c , (a+b)\cdot x + b \cdot (a+b)^k +(a+b)^{k+1}+c$，满足公差为 $(a+b)^{k+1}$，证毕。

由于最后的序列之剩下第一个数所以我们只关心第一个数的取值。

显然，最终的答案是由第 $n-1$ 行的第一个数和第二个数经过变化得到的，设第 $k$ 行第 $i$ 列的数为 $f(k,i)$，所以 $f(k,i) = a \cdot f(k-1,i) + b \cdot f(k-1,i+1) + c$ 根据刚才的证明：每一行都满足等差序列性质且公差为 $(a+b)^k$ 可以得到 $f(k-1,i+1) = f(k-1,i)+(a+b)^{k-1}+c$

整理得到:

$$
f(k,i) = (a+b)\cdot f(k-1,i)+b\cdot(a+b)^{k-1}+c
$$

将 $i=1$ 带入得 $f(k,1) = (a+b)\cdot f(k-1,1)+b\cdot(a+b)^{k-1}+c$

由此，我们可以将第二维消去，得到递推式 $f_i = (a+b)\cdot f_{i-1} + b\cdot(a+b)^{i-1} + c$

接下来只需构造转移矩阵即可。

转移前的矩阵为：
$$
\begin{bmatrix}
 f_{i-1} & b\cdot (a+b)^{k-1} & c
\end{bmatrix}
$$

转移后的矩阵为：
$$
\begin{bmatrix}
 f_{i} & b\cdot (a+b)^{k} & c
\end{bmatrix}
$$

显然，转移矩阵为：
$$
\begin{bmatrix}
 a+b & 0 & 0\\
 1 & a+b & 0\\
 1 & 0 & 1
\end{bmatrix}
$$

由于 $n$ 的范围较大会爆 `long long`，可以选择范围更大的 `__int128` 或选择使用大整数乘法的取模方法通过此题。

#### 代码实现


------------
```cpp
struct Matrix{
	int c[N][N];
}A,E,base;
int n,a,b,c,mod;
inline int mul(int a,int b){
	long long res = 0;
	while(b>0){
		if(b & 1) res += a , res %= mod;
		a <<= 1 , a %= mod;
		b >>= 1;
	}
	return res;
}
Matrix operator * (const Matrix &x,const Matrix &y){
	Matrix a;
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			a.c[i][j] = 0;
		}
	}
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			for(int k=1;k<=3;k++){
				a.c[i][j] += mul(x.c[i][k] , y.c[k][j]) % mod;
				a.c[i][j] %= mod;
			}
		}
	}
	return a;
}

int main(){
	n = read() , a = read() , b = read() , c = read() , mod = read();
	for(int i=1;i<=3;i++) A.c[i][i] = 1;
	base.c[1][1] = 1 , base.c[1][2] = b , base.c[1][3] = c;
	E.c[1][1] = a + b;
	E.c[2][1] = E.c[3][1] = E.c[3][3] = 1;
	E.c[2][2] = a + b;
	n = n - 1;
	while(n > 0){
		if(n & 1) A = A * E;
		E = E * E;
		n >>= 1;
	}
//	cout<<"qwq"<<endl;
	base = base * A;
	cout<<(base.c[1][1]) % mod<<endl;
	return 0;
```


---

## 作者：君のNOIP。 (赞：6)

这是一道良心题，部分分很足，公式也不难推。

有很多大佬是用矩阵做的，但是我不会，所以还是说一下普及做法。

### 20分：$O(n^2)$ 直接模拟即可。

### 40分：$O(n)$ 推递推公式。

设 $f_n$ 为第 $n$ 个数列的首项。

根据题意，很显然第 $n$ 个数列每两项差为第 $n-1$ 个数列每两项差的 $(a+b)$ 倍。

则 $f_n = a\times f_{n-1} + b \times ( f_{n-1} + (a+b)^{n-2} $ ) $ + c $

得 $f_n = (a+b)\times f_{n-1} + b \times (a+b)^{n-2} $ $+ c$

### 50~70分： 各种特殊性质（比如 $a=b=1$）的简化解法，详见下文。

$\# 9,10$ 我给了 $a=b=1 , c=0 $ ， 不知道有没有什么瞎搞做法通过 ~~（直说吧，OEIS是个好东西）~~。

### 70~100分：$O(log^3 n)$ 继续推出 $f_n$ 的通项公式。

$f_n = (a+b)\times f_{n-1} + b \times (a+b)^{n-2} $ $ + c$

$\dfrac{f_n}{(a+b)^n}  = \dfrac{f_{n-1}}{(a+b)^{n-1}} + \dfrac{b}{(a+b)^2}$ $+ \dfrac{c}{(a+b)^n}$

我们设 $h_n = \dfrac{f_n}{(a+b)^n}$ , $g_n = \dfrac{c}{(a+b)^n} $ , $ d = \dfrac{b}{(a+b)^2} $

所以 $h_n -  h_{n-1} = d + g_n$

可以递推得 $h_{n-1} - h_{n-2} = d + g_{n-1}$ , . . .  ,

$h_{3} - h_{2} = d + g_{3}$

$h_{2} - h_{1} = d + g_{2}$

全部相加得 $h_n  = (n-1) \times d +  h_1 +\sum \limits_{i=2}^{n} g_n$

替换回原变量得 $\dfrac{f_n}{(a+b)^n} \ =  \dfrac{b\times (n-1)}{(a+b)^2}  + \dfrac{1}{a+b} + \sum \limits_{i=2}^{n} \dfrac{c}{(a+b)^i}$

于是经化简 $f_n = (a+b)^{n-2} \times (b \times n+a) +  c \times \sum \limits_{i=0}^{n-2}  (a+b)^i$

上面那一坨也就是答案。

很明显要用到快速幂，但是模数超 $2\times 10^9$  直接爆 long long ， 我们还要用龟速乘。

完了？不不不~~~

我们发现 $\sum \limits_{i=0}^{n-2}  (a+b)^i$ 直接枚举 $O(n)$ 会超时。

我们知道有个等比数列求和公式 $\dfrac{(a+b)^{n-1}-1}{a+b-1}$，但是由于要除以一个 $(a+b-1)$ ，是不能直接快速幂算的。（$\# 9\sim 14$除外， $a=b=1$，可以直接套等比数列求和公式算，然后就有70分了）

据说可能有用逆元的方法（普通的逆元加点特判好像可以85？），~~但是我不会。~~

所以我给出一种 二分 + 递归 的思路来解。

每次将 $\sum \limits_{i=0}^{n-2}  (a+b)^i$ 分为两段。

当 $n-1$ 为偶，如 $1+q+q^2+q^3+q^4+q^5 = (1+q+q^2)\times (1+q^3)$

当 $n-1$ 为奇，如 $1+q+q^2+q^3+q^4= (1+q)\times (1+q^3) + q^2 $

$(1+q^3)$ 直接快速幂求，然后左边 $1+q+q^2$ 继续递归即可。

### 100分：$O(log^3n)$ 快速幂 $+$ 龟速乘 $+$ 二分递归

#### 完整代码:

------------

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
#define LL long long
LL n, p, a, b, c;
LL q;

LL mul(LL x,LL y){ //龟速乘
	LL s=0;
	while(y){
		if(y&1) s=(s+x)%p;
		x=x*2%p;
		y/=2;
	}
	return s;
}

LL qui(LL x,LL y){ //快速幂
	LL a=x, b=y, s=1;
	while(b){
		if(b&1) s=mul(s,a);
		a=mul(a,a);
		b/=2;
	}
	return s;
}

LL work(LL t){ //二分递归
	if(t<=1)return 1;
	if(t&1) return (mul(work(t/2), 1 + qui(q, t/2+1)) + qui(q, t/2)) % p;
	else return mul(work(t/2), 1 + qui(q,t/2));
}

int main(){
	cin>>n>>a>>b>>c>>p;
	if(n==1){
		cout<<1%p;
		return 0;
	}
	q=a+b;
	cout<<( mul(qui(a + b, n-2) ,(mul(b, n) + a) % p) + mul(c, work(n-1)) ) % p; //良（凉）心题，输入完直接输出。
}
```

------------

~~大家有没有发现代码中考察的知识都很简单，绝对是 普及 -~~

---

## 作者：WYXkk (赞：3)

众所周知，看到这种输入量少的题目，我们应该 **找 规 律**。~~诶我是不是说过这句话好几次了~~

我们先忽略掉 $\bmod\;p$，将 $a,b,c$ 看成常量。

定义 $F_{i,j}$ 为第 $i$ 个数列的第 $j$ 项，则

$n=1:F_{1,1}=1$

$n=2:F_{2,1}=a+2b+c$

$n=3:$

$$\begin{aligned}F_{3,1}&=a(a+2b+c)+b(2a+3b+c)+c\\&=a^2+4ab+3b^2+ab+ac+c\\&=(a+b)(a+3b+c)+c\end{aligned}$$

$n=4:$

$$\begin{aligned}F_{3,2}&=a(2a+3b+c)+b(3a+4b+c)+c\\&=2a^2+6ab+4b^2+ab+ac+c\\&=(a+b)(2a+4b+c)+c\end{aligned}$$

$$\begin{aligned}F_{4,1}&=aF_{3,1}+bF_{3,2}+c\\&=\cdots\\&=(a+b)((a+b)(a+4b+c)+c)+c\end{aligned}$$

（中间过程懒得写了，略去。自己化简应该不难）

于是我们发现如下规律：

除 $n=1$ 外，记 $x_0=a+nb+c$，$x_i=(a+b)x_{i-1}+c\quad(i\ge 1)$，则结果就是 $x_{n-2}$。

我们愉快地发现这是一个一阶线性递推，非常容易导出其通项。

（方法：$x_i=kx_{i-1}+b$，若 $t$ 使 $x_i+t=k(x_{i-1}+t)$，则 $x_i+t$ 就是一个等比数列，就容易求解了）

导出来的结果是这样的：$x_n=(a+b)^n(x_0+\dfrac c{a+b-1})-\dfrac c{a+b-1}$

由于不保证 $p$ 是质数所以除法不好处理。于是我们暴力展开得到

$$x_n=(a+b)^nx_0+c\sum\limits_{i=0}^{n-1}(a+b)^i$$

前者很好求，快速幂（代码中的 `qp`）即可。后者可以递归算（代码中的 `f`）。

之后把所有乘法换成龟速乘（代码中的 `mul`）即可。

复杂度没算，大概是 $O(\log^3n)$ 的样子（事实上可以 $O(\log^2n)$ 但我比赛时懒得写了）。

一个坑点是 #1 $p=1$，$n=1$ ……

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

ll n,a,b,c,p;
ll mul(ll a,ll b){if(!b) return 0;ll w=mul(a,b>>1);w+=w;if(b&1) w+=a;w%=p;return w;}
ll qp(ll a,ll b){if(!b)return 1;ll w=qp(a,b>>1);w=mul(w,w);return b&1?mul(w,a):w;}
ll f(ll q,ll n){if(!n) return 0;ll w=f(q,n>>1),t=qp(q,n>>1);w=mul(w,t+1);if(n&1)w=mul(w,q)+1;return w%p;}
int main()
{
	cin>>n>>a>>b>>c>>p;
	if(n==1) {cout<<1%p<<endl;return 0;}
	if(n==2) {cout<<(a+2*b+c)%p<<endl;return 0;}
	ll x0=a+mul(n%p,b)+c;x0%=p;
	if(a+b==1)
	{
		ll xn=x0+mul((n-2)%p,c);xn%=p;
		cout<<xn<<endl;
		return 0;
	}
	ll xn=mul(qp(a+b,n-2),x0)+mul(f(a+b,n-2),c);
	xn%=p;
	cout<<xn<<endl;
	return 0;
}
```

按照惯例，说句闲话：~~这句话我好像也说过许多次了~~

**找 规 律 t x d y！！！**

---

## 作者：Refined_heart (赞：3)

我发现$AC$里面的好像我的算最复杂的矩阵了）

这人太菜了比赛时候没调出来赛后取模优化+__int128+求和公式分奇偶性以及一系列神奇操作使得$40->100$

~~本来要做作业的说……等挨骂.jpg~~

解：

观察式子，我们可以发现一个神奇的东西：

对于第一排（就是未操作的序列），第一项是$1$，末尾是$n$，和是$\frac{n*(n+1)}{2}$（这不是废话）

对于第二排，第一项是$a+2b+c$,最后是$(n-1)a+nb+c$,~~和是啥我也不知道~~，观察和应该可以由第一排的和推出来，待会讲。

这样，我们可以将问题转化为最后一行的和的答案这个角度。

那么，我们设$f_i$表示第$i$层的和。

我们试着推一下（我推了$1h$)

对于每一个数，我们让它们都$+c$,那么式子里面应该和$c$有关；

我们把第二行推第三行的前几项拿来看看：

$a+2b+c,2a+3b+c,3a+4b+c\to$

$a(a+2b+c)+b(2a+3b+c)+c,a(2a+3b+c)+b(3a+4b+c)+c$

这些足够我们推出来了。

来，提公因式，先搞$a$:化成$a(a+2b+c,+2a+3b+c+...)$

第三行的$a$相关式子应该等于$a*f_2$，并去掉$f_2$的最后一项。

观察$b$，同理得到$b*f_2$去掉第一项。

那么我们可以维护：这一行的行首，行尾，$c$，$(n-i+1)*c$以及当前行答案来完成转移。

考虑转移行首和行尾。

对于行首：有$now=a*now'+c+b*(now'+(a+b)^{i-1})$

对于行尾：有$now=b*now'+c+a*(now'-(a+b)^{i-1})$

是不是很恶心……

当然对于这个式子是怎么推的……考虑一下这一行的行首与上一行的行首之间的关系，观察分析前$3-4$列就可以得出这个结论。在这里简明说一下：

第一行与第二行：$a*1+c+((a+b)^0+1)*b$就是第二行行首

第二行与第三行：$a(a+2b+c)+c+b(a+2a+c+(a+b))$,就是$(a+b)$的一次方。

其它同理。

所以我们可以写出转移矩阵，这里不打出来了，因为是$6*6$的大矩阵。

注意我们维护的东西有：当前行的和$f_i$,当前的行首，当前的行尾，$c$，$(n-i+1)*c,(a+b)^{i}$，共$6$个值。

代码复杂度：$O(\log n)$,跑$10^{18}$绝对够了。

值得吐槽的是，这题对于模数的取模卡的有点太严格了……考场就因为这个$100\to 40$当然，菜是主要原因。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define ll __int128
ll n,mod,AA,BB,CC;
inline ll mul(ll x,ll y){
	return ((x%mod)*(y%mod))%mod;
}
inline ll add(ll a,ll b){return ((a%mod)+(b%mod)+mod)%mod;}
struct Matrix{
	ll a[10][10];
	Matrix(){
		for(int i=0;i<8;++i)
			for(int j=0;j<8;++j)
				a[i][j]=0;
	}
	Matrix operator*(const Matrix&B)const{
		Matrix res;
		for(int i=1;i<7;++i){
			for(int j=1;j<7;++j){
				for(int k=1;k<7;++k){
					//while(a[i][k]<mod)a[i][k]+=mod;
					//while(B.a[k][j]<mod)B.a[k][j]+=mod;
					res.a[i][j]=add(res.a[i][j],mul(a[i][k],B.a[k][j]));
					res.a[i][j]%=mod;
				}
			}
		}
		return res;
	}
}s,z;
Matrix qpow(Matrix w,ll b){
	Matrix res;
	for(int i=0;i<8;++i)res.a[i][i]=1;
	while(b){
		if(b&1)res=res*w;
		w=w*w;b>>=1;
	}
	return z*res;
}
inline ll qpow2(ll a,ll b){
	ll res=1;
	while(b){
		if(b&1)res=mul(res,a);
		a=mul(a,a);b>>=1;
		
	}
	return res;
}
int main(){
	scanf("%lld%lld%lld%lld%lld",&n,&AA,&BB,&CC,&mod);
	if(n&1)z.a[1][1]=mul(n,(n+1)>>1);
	else z.a[1][1]=mul(n>>1,n+1);
	z.a[1][2]=1;
	z.a[1][3]=n;
	z.a[1][4]=CC;
	z.a[1][5]=mul(n,CC);
	z.a[1][6]=1;
	s.a[1][1]=AA+BB;
	s.a[2][1]=-BB+mod;
	s.a[3][1]=-AA+mod;
	s.a[4][1]=-1+mod;
	s.a[5][1]=1;
	s.a[2][2]=AA+BB;
	s.a[4][2]=1;
	s.a[6][2]=BB;
	s.a[3][3]=AA+BB;
	s.a[4][3]=1;
	s.a[6][3]=-AA+mod;
	s.a[4][4]=1;
	s.a[4][5]=-1+mod;
	s.a[5][5]=1;
	s.a[6][6]=AA+BB;	
	Matrix Ans=qpow(s,n-1);
	printf("%lld\n",Ans.a[1][1]);
	return 0;
}
```

~~感受一波手写矩阵坐标的行数））~~

---

## 作者：rfsfreffr (赞：2)


~~找规律题先打表~~

记$F_{ij}$为第 $i$ 行第 $j$ 个数字

第一排：$1,2,3,4,5,6...$ 公差为 $1$

第二排: $a+2b+c,2a+3b+c...$ 公差为 $a+b$

第三排：

令$a+2b+c=x,$ 那么 $2a+3b+c=x+a+b$, $3a+4b+c=x+2a+2b$

$F_{31}=ax+b(x+a+b)+c$

$F_{32}=a(x+a+b)+b(x+2a+2b)+c$

两个柿子相减，可以得到 $(a+b)^2$

**于是我们可以提出一个大胆的猜想，第k行为公差为 $(a+b)^{k-1}$的等差数列**

可以利用归纳法进行证明：

这对第一行显然成立

假设第 $k$ 行成立

$F_{k,i+1}=F_{k,i}+(a+b)^{k-1},F_{k,i+2}=F_{k,i}+2(a+b)^{k-1}$

令 $F_{k,i}=x$

那么$F_{k+1,i}=ax+b(x+(a+b)^{k-1})+c,F_{k+1,i+1}=a(x+(a+b)^{k})+b(x+2(a+b)^k)+c$

相减就能够得到$F_{k+1,i+1}-F_{k+1,i}=(a+b)^k$

由此得证（可能不太严谨阿巴阿巴，但应该属于是能说明了）



------------
得到了一上规律，便可以开始针对第一项寻找递推公式了

假设$G_i=F_{i,1}$为每一行的第一个数字

显然$G_1=1$

由题意和我们刚刚得到的规律便可以得到：

$G_{k+1}=aF_{k,1}+bF_{k,2}+c$

$=aG_k+b(G_k+(a+b)^{k-1})+c$

$=(a+b)G_k+b(a+b)^{k-1}+c$

有了递推式直接进行递推，时间复杂度 $O(nlogn)$ 远远达不到我们需要的程度
 
------
学过矩阵优化的人应该都知道，像这样的递推式是可以进行矩阵快速幂进行优化的，可以在 $O(logn)$ 级别算出答案

那怎么对这样一个有常数项又有未知项的递推式找到他的加速矩阵呢？

那么我们可以维护这样一个矩阵:

$|G_k,b(a+b)^{k-1},c|$,让他每次乘上一个另一个矩阵base（相当于进行一次递推操作），变成 $|G_{k+1},b(a+b)^k,c|$

可以求得$base=$

$|(a+b),0,0|$

$|1,(a+b),0|$

$|1,0,1|$

初始矩阵即为 $|1,b,c|$

然后套上模板就可以换了的切题啦！

时间复杂度 $O(3^3logn)$

## 代码:

```cpp
#include <bits/stdc++.h>
#define int __int128//注意！！！这题连long long 都会炸（只能拿55分），由于我太菜了不会龟速乘之类的算法，于是只能靠__int128水过了
using namespace std;
long long a,b,k,n,p;

struct matrix {
	int t=3;
	int a[101][101];
	matrix () {
		t=3;
		memset(a,0,sizeof(a));
	}
	matrix operator * (const matrix &b) const {//矩阵乘法
		matrix c;
		for(int i=1; i<=t; i++) {
			for(int j=1; j<=t; j++) {
				for(int k=1; k<=t; k++) {
					c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%p;
				}
			}
		}
		return c;
	}
};
matrix poww(matrix a,int b) {//口胡乱写的快速幂，常数可能会有点大
	matrix sz=a;
	matrix ans;
	int x=b;
	int f=0;
	while(x) {
		if(x%2==1) {
			if(x==b) {
				ans=sz;
				sz=sz*sz;
				f=1;	
			} else {
				if(f==0) {
					ans=sz;
					sz=sz*sz;
					f=1;
					x/=2;
					continue;
				}
				ans=sz*ans;
				sz=sz*sz;
				f=1;
			}
		} else sz=sz*sz;
		x/=2;
	}
	return ans;
}
matrix c,d; 
signed main(){
	cin>>n>>a>>b>>k>>p;
	if(p==1) {//这个要相当注意，如果不加这个只能拿95分（
		cout<<0<<endl;
		return 0;
	}
	d.a[1][1]=a+b;//构造初始矩阵（怎么推出来的前面已经讲了）
	d.a[2][1]=1;
	d.a[2][2]=a+b;
	d.a[3][1]=1;
	d.a[3][3]=1;
	c.a[1][1]=1;
	c.a[1][2]=b;
	c.a[1][3]=k;
	if(n>1) c=c*poww(d,n-1);//只用迭代n-1次，故只乘n-1次方就好了
	long long k=c.a[1][1];//__int128不能直接输出，由于答案肯定在long long 范围内，故用这种方式输出。
	cout<<k<<endl;
	return 0;
}
```


---

## 作者：幻离ian (赞：2)

观察易得出：初始数列公差为1，一次运算后公差为$(a+b)$。

设连续三个数$x1,x2,x3$,公差为$d$。

$x=a \times (x1+x2),y=b \times(x2+x3)$

所以：$y-x=d \times (a+b)$

初始数列公差为1，$i$次运算后公差为：$(a+b)^i$

易得出递推公式：

$f_n =a\times f_{i-1}+b\times (f_{i-1}+(a+b)^{i-1})+c$
$=(a+b) \times f_{i-1}+b\times (a+b)^{i-1}+c$

构造转移矩阵：
$ { \left [ \begin{array}{ccc} f_i&(a+b)^i&1 \end{array} \right ]}=
{ \left [ \begin{array}{ccc} f_{i-1}&(a+b)^{i-1}&1 \end{array} \right ]}\times{ \left [ \begin{array}{ccc}a+b & 0 & 0\\ b & a+b & 0\\c& 0& 1\end{array} \right ]} $

$ { \left [ \begin{array}{ccc} f_{n}&(a+b)^n&1 \end{array} \right ]}={ \left [ \begin{array}{ccc} 1&1&1 \end{array} \right ]}\times{ \left [ \begin{array}{ccc}a+b & 0 & 0\\ b & a+b & 0\\c& 0& 1\end{array} \right ]}^{n-1} 
$

然后用矩阵快速幂求第$n-1$项。

答案存在$a[1][1]+a[2][1]+a[3][1]$中。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
long long n,p,c,a,b;
long long mul(long long x,long long y){
	long long res=0;
	while(y){
		if(y&1)res+=x,res%=p;
	x*=2;x%=p;
	y>>=1;
	}
	return res;
}
struct Matrix{
	long long a[4][4];
	Matrix(){
        memset(a,0,sizeof a);
    }
	Matrix operator *(const Matrix &x)
    {
        Matrix ans;
        for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
        for(int k=1;k<=3;k++)
        ans.a[j][k]=ans.a[j][k]+mul(a[j][i],x.a[i][k]),ans.a[j][k]%=p;
        return ans;
    }
}A,T,R;

int main(){
	cin>>n>>a>>b>>c>>p;
	n-=1;
	for(int i =1;i<=3;i++)
		R.a[i][i]=1;
	A.a[1][1]=a+b;A.a[2][1]=b;A.a[2][2]=a+b;A.a[3][1]=c;A.a[3][3]=1;
	while(n>0){
		if(n&1)R=R*A;
		A=A*A;
		n>>=1;
	}
	cout<<(R.a[1][1]+R.a[2][1]+R.a[3][1])%p;
	return 0;
}
```


---

## 作者：JustinRochester (赞：2)

[传送门](https://www.luogu.com.cn/problem/P6435)

久违地来一波题解，来一个数学角度推式子的方法

---

**【分析】**
--

记第 $k$ 次合并后的第 $i$ 个数为 $F_{k,i}$

根据题意，所求即为 $ans=F_{n-1,n}$ ，且有：

$F_{k+1,n}=aF_{k,n}+bF_{k,n+1}+c,F_{0,i}=i$

形式上，我们设 $\exists d\wedge F_{k+1,i}+d=a(F_{k,i}+d)+b(F_{k,i+1}+d)$

则不难换算出 $(a+b-1)d=c$

> 注意，只是形式上这样设， $d$ 可能本身不存在

记 $G_{k,i}=F_{k,i}+d$ 则得到： $G_{k+1,i}=aG_{k,i}+bG_{k,i+1}$

考虑 $G$ 之间的转移，发现与杨辉三角类似，故考虑每个 $G_{0,i}$ 的贡献，很容易得到：

$\displaystyle G_{n-1,n}=\sum_{i=1}^n\dbinom{n-1}{i-1}a^{(n-1)-(i-1)}b^{i-1}G_{0,i}$

代回 $G_{k,i}=F_{k,i}+d,F_{0,i}=i,ans=F_{n-1,n}$ ，换元 $i=i-1$ 得

$\displaystyle ans=\sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}b^i(i+1+d)-d$

按 $d$ 展开后得到：

$\displaystyle ans=\sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}b^i\cdot (i+1)+d[\sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}b^i-1]$

后半部分是个很显然的二项式定理，求和得到 $(a+b)^{n-1}$

再代回 $(a+b-1)d=c$ 得到：$\displaystyle ans=\sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}b^i(i+1)+c\cdot {(a+b)^{n-1}-1\over (a+b)-1}$

接着，我们构造函数，设 $\displaystyle f(x)=\sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}x^{i+1}=x(a+x)^{n-1}$

因此 $\displaystyle {\text d\over \text dx}f(x)=\sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}x^i\cdot (i+1)={\text d\over \text dx}[x(a+x)^{n-1}]=(a+x)^{n-1}+x\cdot (a+x)^{n-2}\cdot (n-1)$

整理得到： $\displaystyle \sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}x^i\cdot (i+1)=(a+x)^{n-2}\cdot (a+nx)$

所以得到 $\displaystyle \sum_{i=0}^{n-1}\dbinom{n-1}ia^{(n-1)-i}b^i\cdot (i+1)=(a+b)^{n-2}\cdot (a+nb)$

最后我们得到： $ans=(a+b)^{n-2}\cdot (a+nb)+c\cdot {1-(a+b)^{n-1}\over 1-(a+b)}$

---

**法一：**

对于前半部分，快速幂 $O(\log n)$ 可直接算出；而后半部分，可能不存在 $1-(a+b)$ 的逆元，不能直接求解

考虑到其形式上为等比数列求和式，展开为： $1+(a+b)+(a+b)^2+\cdots +(a+b)^{n-2}$

设 $sumq(q,n)=1+q+q^2+\cdots +q^n$

则取一个数 $m$ ，使得 $1+q+q^2+\cdots +q^n=(1+q+q^2+\cdots +q^m)(1+q^{m+1}+q^{2(m+1)+\cdots}+q^{\lfloor{n-m\over m+1}\rfloor\cdot (m+1)})+q^{m+\lfloor{n-m\over m+1}\rfloor\cdot (m+1)+1}(1+q+\cdots)$

因此 $sumq(q,n)=sumq(q,m)\cdot sumq(q^{m+1},\lfloor{n-m\over m+1}\rfloor)+q^{m+\lfloor{n-m\over m+1}\rfloor\cdot (m+1)+1}\cdot sumq(q,n-m-\lfloor{n-m\over m+1}\rfloor\cdot (m+1)-1)$ ，可以递归求解

通过估算，大概 $m=\sqrt n$ 时最优

---

现分析求 $sumq(q,n)$ 的复杂度：

$T(n)\approx T(m)+T(m)+T(n-m^2)+\log m+\log n\leq 3T(n^{1\over 2})+{3\over 2}\log n$

记 $k=\log n$ 则 $T(k)=3T({k\over 2})+{3\over 2}k$

再记 $2^a=k$ 则 $T(a)=3T(a-1)+{3\over 2}\cdot 2^a$

解递推方程得到 $T(a)=3^a+o(3^a)=O(3^a)$

代回得 $3^a=2^{a\log_2 3}=k^{\log_2 3}=\log^{\log_2 3} n$

因此 $T(n)=O(\log^{\log_2 3} n)\approx O(\log^{1.6} n)$

---

**【代码】**
--

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a,b,c,p,ans=1;
inline __int128 fpow(__int128 a,ll x) { ll ans=1; for(;x;x>>=1,a=a*a%p) if(x&1) ans=ans*a%p; return ans; }
inline __int128 sumq(__int128 q,ll n){
    if(n==0) return 1%p;
    if(n==1) return (q+1)%p;
    ll m=sqrt(n),tmp=(n-m)/(m+1)*(m+1)+m;
    __int128 res=sumq(q,m)*sumq( fpow(q,m+1) , (n-m)/(m+1) )%p;
    if(tmp<n) res+=fpow(q,tmp+1)*sumq(q,n-tmp-1)%p;
    return (res%p+p)%p;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n>>a>>b>>c>>p;
    if(n>1) ans=fpow(a+b,n-2)*(a+(__int128)n*b%p)%p+c*sumq(a+b,n-2)%p;
    ans=(ans%p+p)%p;
    cout<<ans;
    cout.flush();
    return 0;
}
```

---

**法二：**

想了想，好像没那么复杂

考虑到 $a,b\geq 1$，所以 $a+b>1$ 一定成立

因此，前半部分同样快速幂直接跑

后半部分为形如 ${q^n-1\over q-1},q>1$ 的形式

设 ${q^n-1\over q-1}\bmod p=t$

则 ${q^n-1\over q-1}-kp=t$

移项得到 $q^n-kp(q-1)=t(q-1)+1$

因此 $q^n\bmod p(q-1)=t(q-1)+1$

由于我们所求为 $t$ ，因此得出：

$t={q^n\bmod p(q-1)-1\over q-1}$

我们直接把 $q$ 在模 $p(q-1)$ 的意义下跑快速幂，结果直接进行这个处理，就能得到我们索要的结果了

其中，$p(q-1)\leq 10^{14}\cdot (10^9+10^9)=2\times 10^{23}$ ，要使用 __int128

由于数值过大，甚至对 __int128 写拆位的快速乘都不行，因此只能龟速乘

时间复杂度为 $O(\log^2 n)$ ，但由于没有递归，运行速率好像反而比法一快

---

**【代码】**


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a,b,c,p,ans=1;
inline __int128 fpow(__int128 a,__int128 x,__int128 m) { __int128 ans=1; for(;x;x>>=1,a=a*a%m) if(x&1) ans=ans*a%m; return ans; }
//不用龟速乘的快速幂
inline __int128 fmul(__int128 a,__int128 x,__int128 m) { __int128 ans=0; for(;x;x>>=1,a=(a+a)%m) if(x&1) ans=(a+ans)%m; return ans; }
inline __int128 fpoww(__int128 a,__int128 x,__int128 m) { __int128 ans=1; for(;x;x>>=1,a=fmul(a,a,m)) if(x&1) ans=fmul(a,ans,m); return ans; }
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n>>a>>b>>c>>p;
    if(n>1) ans=fpow(a+b,n-2,p)*(a+(__int128)n*b%p)%p+(fpoww(a+b,n-1,(__int128)p*(a+b-1))-1)/(a+b-1)*c%p;
    ans=(ans%p+p)%p;
    cout<<ans;
    cout.flush();
    return 0;
}
```

虽然必须用龟速乘，但我们可以对龟速乘搞事情：

由于 $127-\log_2 (2\times 10^{23})\approx49$

所以我们龟速乘可以48位、48位地算，这样就只要3次计算

（稍微卡了一下常数）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a,b,c,p,ans=1;
inline ll fpow(__int128 a,ll x,ll m) { ll ans=1; for(;x;x>>=1,a=a*a%m) if(x&1) ans=ans*a%m; return ans; }
//不用龟速乘的快速幂
inline __int128 fmul(__int128 a,__int128 x,__int128 m) { __int128 ans=0; for(;x;x>>=48,a=(a<<48)%m) ans=(a*(x&(1ll<<48)-1)+ans)%m; return ans; }
inline __int128 fpoww(__int128 a,__int128 x,__int128 m) { __int128 ans=1; for(;x;x>>=1,a=fmul(a,a,m)) if(x&1) ans=fmul(a,ans,m); return ans; }
int main(){
    cin>>n>>a>>b>>c>>p;
    if(n>1) ans=fpow(a+b,n-2,p)*(a+(__int128)n*b%p)%p + (fpoww(a+b,n-1,(__int128)p*(a+b-1))-1)/(a+b-1)*c%p +p;
    cout<<ans%p;
    return 0;
}
```

目前好像是榜一

[开了 o2 ](https://www.luogu.com.cn/record/47484427)

[不开 o2 ](https://www.luogu.com.cn/record/47484379)

---

## 作者：lndjy (赞：2)

来写一个比较详细的矩阵做法。

前面的推导部分鰰的题解写了，不过好像式子给错了，应该是

$$f_n=f_{n-1}+(a+b)^{n-1}+c$$

这里重点讲的是矩阵。首先根据递推式确立目标矩阵：

 $$\begin{vmatrix}f_n&b(a+b)^{n-1}&c\\0&0&0\\0&0&0\end{vmatrix}$$
 
用 $f_{n-1}$ 的矩阵再乘一个矩阵表示：
 
$$\begin{vmatrix}f_{n-1}&b(a+b)^{n-2}&c\\0&0&0\\0&0&0\end{vmatrix}\times  \begin{vmatrix}a+b&0&0\\1&a+b&0\\1&0&1\end{vmatrix}$$

然后可以转化成

$$\begin{vmatrix}f_1&b&c\\0&0&0\\0&0&0\end{vmatrix}\times  \begin{vmatrix}a+b&0&0\\1&a+b&0\\1&0&1\end{vmatrix}^{n-1}$$

显然， $f_1=1$，所以就变成

$$\begin{vmatrix}1&b&c\\0&0&0\\0&0&0\end{vmatrix}\times  \begin{vmatrix}a+b&0&0\\1&a+b&0\\1&0&1\end{vmatrix}^{n-1}$$


后面的矩阵可以使用矩阵快速幂。不需要构建 $6\times 6$ 的，只需要 $3\times 3$ 就可以。注意使用`long long`和龟速乘。

感谢 @Trinitrotoluene 和 @水比田昭寿 两位dalao在[这个帖子](https://www.luogu.com.cn/discuss/show/232743)给我的帮助。

代码：
```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
int n,aa,b,c,p;
int mul(int x,int y)
{
    int s=0;
    while(y)
    {
        if(y&1) s+=x,s%=p;
        x*=2;x%=p;
        y>>=1;
    }
    return s;
}
int qpow(int x,int y)
{
    int s=1;
    while(y)
    {
        if(y&1) s=mul(s,x);
        x=mul(x,x);
        y>>=1;
    }
    return s;
}
struct matrix
{
    int a[4][4];
    matrix()
    {
        memset(a,0,sizeof a);
    }
    matrix operator *(const matrix &x)
    {
        matrix ans;
        for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
        for(int k=1;k<=3;k++)
        ans.a[j][k]=ans.a[j][k]+mul(a[j][i],x.a[i][k]),ans.a[j][k]%=p;
        return ans;
    }
};
matrix qp(matrix ans,matrix base,int x)
{
    while(x)
    {
        if(x&1) ans=ans*base;
        base=base*base;
        x>>=1;
    }
    return ans;
}
signed main()
{
    cin>>n>>aa>>b>>c>>p;
    matrix ans,base;
    base.a[1][1]=base.a[2][2]=(aa+b)%p;
    base.a[2][1]=base.a[3][1]=base.a[3][3]=1;
    for(int i=1;i<=3;i++)
    ans.a[i][i]=1;
    ans=qp(ans,base,n-1);
    matrix x;
    x.a[1][1]=1;x.a[1][2]=mul(b,mul(aa+b,aa+b));x.a[1][3]=c;
    cout<<(x*ans).a[1][1];  
    return 0;
}
```


---

## 作者：yijan (赞：2)

# P6435「EZEC-1」数列

由于公式挂了，建议在 luogu 博客查看。

考虑 $c = 0$ 的情况，相当于每个数字可以到达 $ax$ 或者 $bx$ ，注意到这很二项式定理。最终答案就是
$$
\sum_{i=1}^{n} i{n-1\choose i - 1} a^{i-1}b^{n-i}
$$
考虑如果没有 $i$ ，直接就是 $(a+b)^{n-1}$ ，考虑看成多项式，那么就是
$$
\sum_{i=1}^ni[x^{i-1}](a+bx)^{n-1}
$$
$$
\sum_{i=1}^ni[x^{i}]x(a+bx)^{n-1}
$$
设 $f(x) = x(a+bx)^{n-1}$ ，答案就是
$$
f'(1)
$$
求导一下
$$
\begin{aligned}f'(x) &= (a+bx)^{n-1} + x((a+bx)^{n-1})'\\f'(x) &= (a+bx)^{n-1} + x( (n-1)\times (a+bx)^{n-2}\times b )\\f'(1) &= (a+b)^{n-1} + ( (n-1)\times (a+b)^{n-2}\times b )\end{aligned}
$$
然后可以考虑 $c \neq 0$ 的情况

单独对每一行的 $c$ 求贡献和，$c$ 仍然可以到达 $ac,bc$ ，所以每一行的 $c$ 贡献是
$$
\sum_{i=1}^{k} {k - 1\choose i-1} a^{i-1} b^{k-i}
$$
$$
= (a+b)^{k-1}
$$
所以答案是 
$$
\sum_{k=0}^{n-2} c(a+b)^{k}
$$
这个可以分治，总复杂度，可以存下上一次的值，算上慢速乘是 $O(\log^2 n)$ ，光速乘是 $O(\log n)$

Orz @137_345_2814

---

## 作者：Leowang2009 (赞：1)

# 思路
先看样例 2 解释，对于每一行，可以~~明显~~看出是等差数列，再看到 $n\leq 10^{18}$ 的数据范围，想到用矩阵加速。

知道了每一行都是等差数列，在用矩阵快速幂求解之前还需要找公差。

不妨设第 $i$ 行第 $j$ 项为 $f_{i,j}$，第 $i$ 行公差为 $d_i$。

由题意易得：

$f_{i,j}\times a + f_{i,j+1}\times b + c = f_{i+1,j},f_{i,j+1}\times a + f_{i,j+2}\times b + c = f_{i+1,j+1}$

又：$f_{i,j} + d_{i} = f_{i,j+1},f_{i,j} + 2\times d_{i} = f_{i,j+2}$

则有：

$d_{i+1}$

$= f_{i+1,j+1} - f_{i+1,j}$

$= (f_{i,j+1}\times a + f_{i,j+2}\times b + c ) - ( f_{i,j}\times a + f_{i,j+1}\times b + c)$

$= f_{i,j+1}\times (a - b) + f_{i,j+2}\times b - f_{i,j}\times a$

$= (f_{i,j}+d_{i})\times (a - b) + (f_{i,j} + 2\times d_{i})\times b - f_{i,j}\times a$

$= d_{i}\times (a-b) + 2\times d_{i}\times a$

$= d_{i}\times (a+b)$

显然，$d_{1} = 1$。所以 ${d_{n}}$ 为一个首项为 $1$，公比为 $(a+b)$ 的等比数列。

由此，可以构造出初始矩阵：
$$\begin{bmatrix}1&b&c\end{bmatrix}$$
进而，可以构造出如下转移矩阵：
$$\begin{bmatrix}a+b&0&0\\1&a+b&0\\1&0&1\end{bmatrix}$$
接下来直接用矩阵快速幂求解即可。
# 代码
代码实现很简单，可以直接套矩阵快速幂模板，但由于模数最大达到了 $10^{14}$ 所以需要用到~~快速乘~~龟速乘。
## AC Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int mod,n,a,b,c;
struct node{
	int a[5][5];
}cnt;
int mul(int a,int b){
	//龟速乘
	int c=0;
	while(b){
		if(b&1) c=(c+a)%mod;
		a=(a<<1)%mod,b>>=1;
	}return c;
}
node operator*(const node&a,const node&b){
	//矩阵乘法
	node c;
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) c.a[i][j]=0;
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
			for(int k=1;k<=3;k++)
				c.a[i][j]=(mul(a.a[i][k],b.a[k][j])+c.a[i][j])%mod;
	return c;
}
int qiuck_pow(int x,node cnt){
	//矩阵快速幂
	node res;
	memset(res.a,0,sizeof(res.a));
	res.a[1][1]=1,res.a[1][2]=b%mod,res.a[1][3]=c%mod;
	while(x){
		if(x&1) res=res*cnt;
		cnt=cnt*cnt,x>>=1;
	}return res.a[1][1]%mod;//一定要取模！
}
signed main(){
	scanf("%lld%lld%lld%lld%lld",&n,&a,&b,&c,&mod);
	cnt.a[1][1]=cnt.a[2][2]=(a+b)%mod;
	cnt.a[2][1]=cnt.a[3][1]=cnt.a[3][3]=1;
	printf("%lld",qiuck_pow(n-1,cnt));
	return 0;
}
```
完结撒花！

---

## 作者：_edge_ (赞：0)

好久没推柿子推的这么爽了，写篇题解，写的挺详细的，如果觉得有用能点个赞么 /kel。

首先，对于 $n=1$ 的情况进行特判，直接输出 $1$ 取模就可以了，以下的情况都讨论 $n>1$ 。

然后我们发现这个数列是非常的优美的，不妨把他看成正三角的形状。

![](https://cdn.luogu.com.cn/upload/image_hosting/dk76joho.png)

为了方便，我帮各位都画好了。

然后我们分类进行讨论，对于蓝色的点，对顶部的贡献初值一定是 $c$。

然后经过一个 `/` 的就会产生 $\times a$ 的贡献，`\` 是 $\times b$ 的贡献。

计算其走到顶部的路径数，这是可以直接组合数的。

于是，我们算完了他到顶部的贡献，然后计算下面的贡献，同理也可以计算。

这样的话我们的时间复杂度是 $O(n^2)$ 的，和暴力一样，但是可以继续进行优化。

```cpp
	int sum=0;
	for (int i=0;i<n-1;i++) {
		for (int j=0;j<=i;j++) {
			sum+=C(i,j)*ksm(a,i-j)%Mod*ksm(b,j)%Mod%Mod;
		}
	}
	sum*=c;
	for (int i=n;i<=n;i++) {
		for (int j=0;j<i;j++) {
			sum+=(j+1)*C(i-1,j)%Mod*ksm(a,i-1-j)%Mod*ksm(b,j)%Mod%Mod;
			sum%=Mod;
		}
	}
	cout<<sum<<"\n";
```

上面的代码应该有点组合数学基础的都看的明白，`ksm` 函数表示快速幂。

然后我们继续考虑优化，我们发现这个柿子给他写出来是 $\sum \limits _{i=0}^{n-1} \sum \limits _{j=0}^i \binom{i}{j} \times a^{i-j} \times b^j$。

这是第一步的柿子，然后利用二项式定理可以知道里面的那个求和事实上等价于 $(a+b)^i$。

然后就变成了 $\sum \limits _{i=0}^{n-1} (a+b)^i$，这东西是等比数列的求和，可以直接用求和公式来做。

```cpp
	sum=ksm(a+b,n-1)-1;
	sum%=Mod;sum*=ksm(a+b-1,Mod-2);
	sum%=Mod;sum*=c;
```

上面代码是推导的东西。

然后我们继续优化下面这一部分，发现这东西比较难搞。 (

$\sum \limits _{j=0}^{n-1} (j+1) \times \binom{n-1}{j} \times a^{n-1-j} \times b^j$

这个，我们可以把 $(j+1)$ 拆开来，然后分成两部分计算，对于和 $1$ 产生的贡献，可以直接二项式定理变成了 $(a+b)^{n-1}$。

考虑剩下部分怎么拆。

先别看这个柿子，因为长的有点难看，考虑 $a=b=1$ 的情况，也就是忽略 $a$ 和 $b$ 的情况下，这东西等价于

$\sum \limits _{i=0}^{n-1} i \times \binom{n-1}{i} $

如果有组合数学基础的，可以一眼看出结论，但是我没有，于是我就想要拆了，我们发现组合数下面的那个分母里面有一个是 $i$ ，于是就考虑把他变成另外一个组合数的柿子。

也就是把 $n-1$ 提出，变成了 $(n-1) \times (\sum \limits _{i=1}^{n-1} \binom{n-2}{i-1})$，会发现里面是一个组合数的行的和，和 $2^{n-2}$ 等价。

于是就变成了 $(n-1) \times 2^{n-2}$，然后会发现这东西推广到有 $a$ 和 $b$ 的情况，就大致变成了 $(n-1) \times (\sum \limits _{i=1}^{n-1} \binom{n-2}{i-1}) \times a^{n-1-i} \times b^i$，里面也是一个二项式定理，可以直接解决。

```cpp
#include <iostream>
#include <cstdio>
#define int __int128
using namespace std;
long long Mod;
const int INFN=1e5+5;
int fav[INFN],ifav[INFN];
long long n,a,b,c;
int ksm(int x,int y) {
	int ba=x%Mod,ans=1;
	while (y) {
		if (y&1) ans=(ans*ba)%Mod;
		ba=(ba*ba)%Mod;y>>=1;
	}
	return ans;
}
void init() {
	fav[0]=1;int N=1e5;
	for (int i=1;i<=N;i++) fav[i]=fav[i-1]*i%Mod;
	ifav[N]=ksm(fav[N],Mod-2);
	for (int i=N-1;~i;i--) ifav[i]=ifav[i+1]*(i+1)%Mod; 
}
int C(int x,int y) {
	if (x<y) return 0;
	return fav[x]*ifav[y]%Mod*ifav[x-y]%Mod; 
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>a>>b>>c>>Mod;
	if (n==1) {
		cout<<1%Mod<<"\n";
		return 0;
	}
	init();
	int sum=0;
//	for (int i=0;i<n-1;i++) {
//		sum+=ksm(a+b,i)%Mod;
//		sum%=Mod;
//	}
	// S=1 + (a+b)^1+ (a+b)^2+ (a+b)^3 + ...
	// (a+b)*S=(a+b)+(a+b)^2+ (a+b)^3+ (a+b)^4 + ...
	// (a+b-1)*S=(a+b)^{n-1}-1
	sum=ksm(a+b,n-1)-1;
	
	sum%=Mod;sum*=ksm(a+b-1,Mod-2);
	sum%=Mod;sum*=c;sum%=Mod;
	int sum1=0;
//	for (int j=0;j<n;j++) {
//		sum+=(j*C(n-1,j)+C(n-1,j))%Mod*ksm(a,n-1-j)%Mod*ksm(b,j)%Mod;
//		// \sum j 0->n-1 j*C(n-1,j)*a^{n-1-j}*b^j 
//		sum%=Mod;
//	}
	sum1=ksm(a+b,n-1);sum1%=Mod;
	int bb=b%Mod;
	sum1+=(n-1)%Mod*ksm(a+b,n-2)%Mod*bb%Mod;
	sum1%=Mod;
	long long ans=sum+sum1;
	ans%=Mod;
//	ans+=Mod;ans%=Mod; 
	cout<<ans<<"\n";
	return 0;
}
```


然后我们搞了这么长时间终于搞完了 $85$ 分，有人没到？是不是忘记开 `__int128` 了？

然后我们思考我们的解法依赖于 $p$ 是质数的地方，唯一是在等比数列求和的过程中。

但是，等比数列这个东西其实可以矩乘优化的。

具体的矩阵就是：

$\begin{bmatrix}0 \\1 \end{bmatrix}$

头一个表示总和，后一个表示当前要加的是啥。

然后还有一个是：

$\begin{bmatrix}1 \ 1\\0 \ (a+b) \end{bmatrix}$

~~(矩阵好像打的不是很好看，可以自己画一个 /kel)~~

然后就可以矩乘优化了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define int __int128
using namespace std;
long long Mod;
const int INFN=1e5+5;
const int INF=5;
int fav[INFN],ifav[INFN];
long long n,a,b,c;
int ksm(int x,int y) {
	int ba=x%Mod,ans=1;
	while (y) {
		if (y&1) ans=(ans*ba)%Mod;
		ba=(ba*ba)%Mod;y>>=1;
	}
	return ans;
}
void init() {
	fav[0]=1;int N=1e5;
	for (int i=1;i<=N;i++) fav[i]=fav[i-1]*i%Mod;
	ifav[N]=ksm(fav[N],Mod-2);
	for (int i=N-1;~i;i--) ifav[i]=ifav[i+1]*(i+1)%Mod; 
}
int C(int x,int y) {
	if (x<y) return 0;
	return fav[x]*ifav[y]%Mod*ifav[x-y]%Mod; 
}
int g[INF][INF],ba[INF][INF],ans[INF];
void mulans() {
	memset(g,0,sizeof g);
	for (int i=1;i<=2;i++)
		for (int j=1;j<=1;j++)
			for (int k=1;k<=2;k++)
				g[i][j]+=ba[i][k]*ans[k]%Mod,g[i][j]%=Mod;
	for (int i=1;i<=2;i++)
		ans[i]=g[i][1];
	return ;
}
void mulba() {
	memset(g,0,sizeof g);
	for (int i=1;i<=2;i++)
		for (int j=1;j<=2;j++)	
			for (int k=1;k<=2;k++) 
				g[i][j]+=ba[i][k]*ba[k][j]%Mod,g[i][j]%=Mod;
	for (int i=1;i<=2;i++)
		for (int j=1;j<=2;j++)
			ba[i][j]=g[i][j];
	return ;
}
void Ksm(int x) {
	while (x) {
		if (x&1) mulans();
		mulba();x>>=1;
	}
	return ;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>a>>b>>c>>Mod;
	if (n==1) {
		cout<<1%Mod<<"\n";
		return 0;
	}
	init();
	int sum=0;
//	for (int i=0;i<n-1;i++) {
//		sum+=ksm(a+b,i)%Mod;
//		sum%=Mod;
//	}
	// S=1 + (a+b)^1+ (a+b)^2+ (a+b)^3 + ...
	// (a+b)*S=(a+b)+(a+b)^2+ (a+b)^3+ (a+b)^4 + ...
	// (a+b-1)*S=(a+b)^{n-1}-1
//	sum=ksm(a+b,n-1)-1;sum%=Mod;sum+=Mod;
//	sum%=Mod;sum*=ksm(a+b-1,Mod-2);
//	sum%=Mod;sum*=c;sum%=Mod;
	
	ba[1][1]=1;ba[1][2]=1;
	ba[2][1]=0;ba[2][2]=(a+b)%Mod;
	ans[1]=0;ans[2]=1;
	Ksm(n-1);
	
//	long long kk=sum,kc=c;
//	cout<<kk<<" "<<kc<<" fad?\n";
	sum=ans[1]%Mod*c%Mod;
	
	int sum1=0;
//	for (int j=0;j<n;j++) {
//		sum+=(j*C(n-1,j)+C(n-1,j))%Mod*ksm(a,n-1-j)%Mod*ksm(b,j)%Mod;
//		// \sum j 0->n-1 j*C(n-1,j)*a^{n-1-j}*b^j 
//		sum%=Mod;
//	}
	sum1=ksm(a+b,n-1);sum1%=Mod;
	int bb=b%Mod;
	sum1+=(n-1)%Mod*ksm(a+b,n-2)%Mod*bb%Mod;
	sum1%=Mod;sum1+=Mod;sum1%=Mod;
	long long ans=sum+sum1;
	ans%=Mod;
//	ans+=Mod;ans%=Mod; 
	cout<<ans<<"\n";
	return 0;
}
```


---


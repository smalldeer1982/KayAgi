# [NOI2013] 快餐店

## 题目描述

小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。

快餐店的顾客分布在城市 C 的 $N$ 个建筑中，这 $N$ 个建筑通过恰好 $N$ 条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。

现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。

## 说明/提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/r0dmxcgy.png)

### 样例解释 2

![](https://cdn.luogu.com.cn/upload/image_hosting/pf8eaowl.png)

### 数据范围

- 对于 $10\%$ 的数据，$N\leq 80$，$L_i=1$；
- 对于 $30\%$ 的数据，$N\leq 600$，$L_i\leq 100$；
- 对于 $60\%$ 的数据，$N\leq 2000$，$L_i\leq 10^9$；
- 对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$1\leq L_i \leq 10^9$。

## 样例 #1

### 输入

```
4 
1 2 1 
1 4 2 
1 3 2 
2 4 1
```

### 输出

```
2.0 ```

## 样例 #2

### 输入

```
5
1 5 100
2 1 77
3 2 80
4 1 64
5 3 41```

### 输出

```
109.0```

# 题解

## 作者：_LAUV_ (赞：37)

贴个[博客链接](https://www.cnblogs.com/HLAUV/p/10629695.html)

首先我们要知道，如果是树的话，重心的位置一定在一半的直径里那个位置对吧。

所以如果图是一棵树，那么1/2的直径长就是答案了。

（然而这道题没有树的部分分）

看到有n条边就知道是基环树。

既然是基环树，那么我们就应该把环作为重点研究对象。

环就是解题的关键，习惯性地把基环树画成~~细菌~~


![](https://cdn.luogu.com.cn/upload/pic/55486.png)


此时这个基环树的直径有两种情况 有经过基环 或 没有经过基环

没有经过基环的就是环上挂着的每一棵小子树的最大直径了。

有经过基环的怎么求呢？

考虑枚举每个位置把环断开（基环树常见套路）。



![](https://cdn.luogu.com.cn/upload/pic/55484.png)


对每一个子树求一个最大深度，然后Max(两个子树最大深度加它们在环上的距离)就为直径了。

但我们有很多种断环方案，每一次都求一次复杂度肯定是要上天的。

所以想个办法优化（这里借鉴了[ljh2000](https://www.cnblogs.com/ljh2000-jump/p/6391591.html)的方法）

先在1到tot（环长）的地方断开。

pre[]与bck[]分别表示前缀和后缀的 Max[某个子树最大深度+它的前缀（后缀）链长]



![](https://cdn.luogu.com.cn/upload/pic/55488.png)


bs1[]和bs2[]分别表示前缀和后缀的 Max[某两个子树的最大深度+它们之间的距离]


![](https://cdn.luogu.com.cn/upload/pic/55487.png)


所以每次从i到i+1的地方断开，答案的求法就很简单了。


```cpp
For(i,1,tot-1){
	Db mx1=max(bs1[i],bs2[i+1]);
	Db mx2=max(mx1,pre[i]+bck[i+1]+crD[0]);
	Fn=min(Fn,max(mx1,mx2));
}
```

DFS抠环、断环的时候比较繁琐一定要注意细节。

好了上代码



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Dwn(i,a,b) for(register int i=a;i>=b;--i)
#define Pn putchar('\n')
#define Re register
#define Db double

using namespace std;

const int N=1e5+5;

int head[N],nxt[N*2],v[N*2],cnt=1;
Db w[N*2],dia[N],z,dmx[N],Fn;
int n,m,x,y;
inline void read(int &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
inline void read(Db &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
void add(int ux,int vx,Db wx){
	nxt[++cnt]=head[ux]; head[ux]=cnt; v[cnt]=vx; w[cnt]=wx;
	nxt[++cnt]=head[vx]; head[vx]=cnt; v[cnt]=ux; w[cnt]=wx;
}

int tot=0,top=0,st[N],cr[N*2],vis[N],suc=0,fc[N];
Db crD[N*2],stD[N];
void dfsCir(int x,int fa){
	vis[x]=1;
	if(x==1)st[++top]=x,stD[top]=0;
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i]; if(vv==fa)continue;
		if(!vis[vv]){
			st[++top]=vv; stD[top]=w[i];
			dfsCir(vv,x);
		}else{
			suc=1;
			while(st[top]!=vv){
				fc[st[top]]=1;
				cr[++tot]=st[top];
				crD[tot]=stD[top--];
			}
			fc[st[top]]=1;
			cr[++tot]=st[top];
			crD[tot]=w[i];
			return;
		}
		if(suc)return;
	}
	top--;
}
int pos;
Db mxD;
void dfsTrD(int x,Db dix,int fa){
	if(dix>mxD)mxD=dix,pos=x;
	for(Re int i=head[x];i;i=nxt[i]){
		int vv=v[i];
		if(vv==fa||fc[vv])continue;
		dfsTrD(vv,dix+w[i],x);
	}
}
Db GetTrD(int x){
	pos=mxD=0;
	dfsTrD(x,0,0);
	mxD=0;
	dfsTrD(pos,0,0);
	return mxD;
}

Db pre[N],bck[N],bs1[N],bs2[N],Ds=0; 
void DP(){
	Ds=mxD=0;
 	For(i,1,tot){
 		pre[i]=max(pre[i-1],dmx[cr[i]]+Ds);
 		if(i>=2)bs1[i]=max(bs1[i-1],mxD+Ds+dmx[cr[i]]);
 		mxD=max(mxD,dmx[cr[i]]-Ds);
	 	Ds+=crD[i];
	}
	Ds=mxD=0;
	crD[0]=crD[tot];
	Dwn(i,tot,1){
		bck[i]=max(bck[i+1],dmx[cr[i]]+Ds);
		if(i<=tot-1)bs2[i]=max(bs2[i+1],mxD+Ds+dmx[cr[i]]);
		mxD=max(mxD,dmx[cr[i]]-Ds);
		Ds+=crD[i-1];
	}
	Fn=bs1[tot];
	For(i,1,tot-1){
		Db mx1=max(bs1[i],bs2[i+1]);
		Db mx2=max(mx1,pre[i]+bck[i+1]+crD[0]);
		Fn=min(Fn,max(mx1,mx2));
	}
}

int main(){
	//freopen("ex.in","r",stdin);
//	freopen("ex.out","w",stdout);
    read(n); 
    For(i,1,n){read(x); read(y); read(z); add(x,y,z);}
    dfsCir(1,0); 
    For(i,1,tot){
    	fc[cr[i]]=0;
		dia[cr[i]]=GetTrD(cr[i]);
		fc[cr[i]]=1;
	}
    For(i,1,tot){
    	mxD=0; 
    	dfsTrD(cr[i],0,0);
    	dmx[cr[i]]=mxD;
    } 
    DP();
    For(i,1,tot)Fn=max(Fn,dia[cr[i]]);
    printf("%.1lf",Fn/2.0);
    return 0;
}
    

```








---

## 作者：Mr_cold (赞：36)

作为一道NOI题，这道题是一道好(难)题，这道题给了一张N点N边的图，让你在图中找一点到图中最远点最近，输出这个距最远点最近的距离，首先问题降低，如果这是一棵树，求一点到最远点的最短距离，那其实就是树的直径的一半，但是这道题是一颗环套树，所以现在分两种情况
### 1 这个环套树的最长路径不经过环

这种情况是比较简单的，我们首先通过一些手段求出这个环，并记录环的信息，(方法：tarjan，dfs，并查集)；然后枚举每一个环上的点，对这些点下的子树求直径，取这些直径的最大值，记为ans1.

以上操作找环是O(n+m),对所有环上的点求子树是O(n)的，所以这一步总复杂度O(n+m);

时间复杂度的原因：每个点只便利了一次

### 2 这个环套树的最长路径经过环

这种情况是比较复杂的，O(n * n) 60分算法是枚举环上的断点，是无法AC的，因此需要优化。

规定环上每个点为1--> circle_cnt

A[i]表示(前缀链长度+当前换上节点子树最大深度)

B[i]表示(前缀中两个点子树的最大深度+两点之间的距离)

C[i]表示(后缀链长度+当前换上节点子树最大深度)

D[i]表示(后缀中两个点子树的最大深度+两点之间的距离)
因此当我们枚举到断裂环上i与i+1点之间的边时，

答案为max(max(B[i],D[i]),A[i]+C[i+1]+(1-->circle_cnt点的边权))；

这个式子的含义是 取

max((前缀中的最大直径)，(后缀中的最大直径)，(前缀i与后缀i+1跨过1和circle_cnt点之间的边所组成的直径))

显然的我们要保留这里求出的最小值，因为这里求出的路径是所有路径都有可能，不一定是两点间的最短路，这里我就有疑问，但就像第一个样例，最长的路是3->1->4->2距离为5，事实上有3->1->2->4距离为4的路存在，这样无疑缩短了求的直径。

记这个最小值为ans2.这个步骤复杂度时O(circle_cnt)

最终输出max(ans1,ans2)/2;

How interesting it is!

以上就是主要思路，对于经过环上的路径也可以通过线段树来求，但是没有这种方法更优。
代码如下
~~~
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<queue>
#include<cmath>
#include<map>
using namespace std;
typedef long long ll;
const int maxn=100000+10;
const int inf=0x3f3f3f3f;
const int mod=1e9+7;
int n;
struct Edge{
	int to,from,cost;
}edge[maxn<<1];
int last[maxn<<1],cnt=0;
int huan[maxn],huan_cnt=0,huan_zhi[maxn],fa[maxn],cost[maxn],huan_sign[maxn];
int dfn[maxn],timee=0;
ll dis[maxn];
ll ans=0,ans1=0;
ll A[maxn],B[maxn];
//A[i]表示 前缀中最大的一条链+当前节点树的最大深度 
//B[i]表示前缀中两棵树的最大深度+这两个节点间的距离 
ll C[maxn],D[maxn]; //这是后缀做的
//因此当断换上第i与i+1条边时 ans=max(max(B[i],D[i+1]),A[i]+C[i+1]+1-->cnt的边权和) 
inline int read(){
    int a=1,b=0;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-') a=-1;c=getchar();}
    while(c>='0'&&c<='9'){b=(b<<3)+(b<<1)+c-'0';c=getchar();}
    return a*b;
}
inline void print(ll x){
    if(x<0) x=-x,putchar('-');
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
inline void pre(){
	
}
inline void add(int x,int y,int z){
	edge[++cnt].to=y;
	edge[cnt].cost=z;
	edge[cnt].from=last[x];
	last[x]=cnt;
}
inline void input(){int xx,yy,zz;
	n=read();
	for(int i=1;i<=n;++i)
	{
		fa[i]=i;
		xx=read(),yy=read(),zz=read();
		add(xx,yy,zz);
		add(yy,xx,zz);
	}
}	
inline void dfs(int now){//此处找环并记录 
	dfn[now]=++timee;
	for(int i=last[now];i;i=edge[i].from)
	{
		int to=edge[i].to;
		if(to!=fa[now])
		{
			if(!dfn[to])
			{
				fa[to]=now;
				cost[to]=edge[i].cost;
				dfs(to);
			}
			else if(dfn[to]>dfn[now])
			{
				for(;to!=now;to=fa[to])
				{
					huan_sign[to]=1;
					huan[++huan_cnt]=to;
					huan_zhi[huan_cnt]=cost[to];
				}
				huan_sign[now]=1;
				huan[++huan_cnt]=now;
				huan_zhi[huan_cnt]=edge[i].cost;
			}
			
		}
	}
}
inline void DP(int now,int father){//dis[i]表示i所在的子树上的直径 
	for(int i=last[now];i;i=edge[i].from)
	{
		int to=edge[i].to;
		if(!huan_sign[to]&&to!=father)
		{
			DP(to,now);
			ans=max((ll)dis[now]+dis[to]+edge[i].cost,ans);
			dis[now]=max(dis[now],dis[to]+edge[i].cost);
		}
	}
}
inline void solve(){
	dfs(1);
	for(int i=1;i<=huan_cnt;++i) DP(huan[i],0);
	ll sum=0,maxx=0;
	for(int i=1;i<=huan_cnt;++i)
	{
		sum+=huan_zhi[i-1];
		A[i]=max(A[i-1],dis[huan[i]]+sum);
		B[i]=max(B[i-1],sum+maxx+dis[huan[i]]);
		maxx=max(maxx,dis[huan[i]]-sum);
	}
	sum=maxx=0;
	int tmp=huan_zhi[huan_cnt];huan_zhi[huan_cnt]=0;
	for(int i=huan_cnt;i>=1;--i)
	{
		sum+=huan_zhi[i];
		C[i]=max(C[i+1],dis[huan[i]]+sum);
		D[i]=max(D[i+1],sum+maxx+dis[huan[i]]);
		maxx=max(maxx,dis[huan[i]]-sum);
	}
	ll tep;
	ans1=B[huan_cnt];
	for(int i=1;i<huan_cnt;++i)
	{
		tep=max(B[i],D[i+1]);
		tep=max(tep,A[i]+C[i+1]+tmp);
		ans1=min(tep,ans1);
	}
	ans=max(ans,ans1);
	if(ans&1) print(ans>>1),puts(".5");
	else print(ans>>1),puts(".0");
}
inline void output(){
    
}
int main(){int T;
    T=1;	
    while(T--)
    {	 
        pre();
        input();
        solve();		
        output();
    }
    return  0;
}
~~~





---

## 作者：Piwry (赞：24)

貌似都没人讲清楚将题目从基环树转化为树的推论的证明qaq。我还思考这个思考了好久，最后在本题讨论被提醒后才发现整个思路方向错了X

这里就着重讲下这个推论的证明，以及给出一个不太一样的处理断环后树直径的方法（这个要感谢[讨论区](https://www.luogu.com.cn/discuss/show/255658)的 @C3H5ClO qwq）

## 解析

### 转化问题

P.S. 写完后感觉自己讲得有点烂...写得很难理解

如果实在不想看下面这段很长的较严谨证明（甚至推荐别看X），可以考虑看这个简单版本：

我们做出答案点的最短路生成树，发现答案点也是该生成树上到其它点距离的最大值最小的点（对于该生成树的答案），于是可以考虑枚举生成树并求生成树的答案。接着又发现枚举生成树求出的答案值不会小于原图的答案值，于是算法正确性成立

（树的答案应该很好求把，最长路径（直径）除二就行了，这个正确性随便怎么证都可以）

（一个空行后开始正式的证明）

&nbsp;

为了说明方便，这里对一些下面会用到的记号或函数先做出定义。$G$ 指原图，$V$ 是由原图所有结点组成的集合，$T_s$ 是以 $s$ 为起点做出的原图的最短路径生成树；$dist_G(u, v)$ 指在带权无向图 $G$ 中 $u, v$ 的最短距离，可以知道在树中它们的距离是唯一的

设快餐店最优的位置的集合为 $S$，并设 $s\in S$。由题意可知，$T_s$ 的最大深度（带边权）一定是所有 $T_u, u\in V$ 中最小的；或者说 $s$ 满足 $\max\limits_{v\in V}(dist_G(s, v))=\min\limits_{u\in V}(\max\limits_{v\in V}(dist_G(u, v)))$，也可写成 $\max\limits_{v\in V}(dist_G(s, v))<\min\limits_{u\in V,u\not\in S}(\max\limits_{v\in V}(dist_G(u, v)))$（其实 $s$ 也有可能在某条边上，只需多加一些定义，这里不考虑）

且题目所求的答案即为 $\min\limits_{u\in V}(\max\limits_{v\in V}(dist_G(u, v)))=\max\limits_{v\in V}(dist_G(s, v)), s\in S$

我们先证明一个引理：

> 引理 1. 在 $T_s$ 中寻找一个点 $s'$，使得 $s'$ 到其它结点的在 $T_s$ 上的距离的最大值最小，则一定有 $s'\in S$

考虑反证法。若有 $s', s'\not\in S$ 且使得 $s'$ 到其它结点的距离的最大值最小，我们发现一定有 $\max\limits_{v\in V}(dist_T(s', v))\leq \max\limits_{v\in V}(dist_{T}(s, v))$。由于生成树上的两点间最短距离一定不小于原图上两点间的最短距离，也就是说在原图中，有 $\max\limits_{v\in V}(dist_G(s', v))\leq\max\limits_{v\in V}(dist_G(s, v))<\min\limits_{u\in V,u\not\in S}(\max\limits_{v\in V}(dist_G(u, v)))$，即代表 $s'\in S$。这导出了矛盾，因此假设不成立

接着我们再证明一个引理：

> 引理 2. 枚举 $G$ 的生成树 $T$，并在生成树上找一点 $s'$，使得 $s'$ 到其它结点的在 $T$ 上的距离的最大值最小，并记将该值记为 $f(T)$；对于有根树我们用同样的方式定义。则对于所有可能的生成树，有 $f(T)\geq f(T_s), s\in S$

由于 引理 1.，我们实际上有 $f(T_s)=\max\limits_{v\in V}(dist_G(s, v))$

我们的证明思路其实和刚才差不多。若存在一个生成树 $T$，有 $f(T)<f(T_s), s\in S$，即代表我们能在 $T$ 上找到一个点 $s'$，使得 $\max\limits_{v\in V}(dist_G(s', v))\leq\max\limits_{v\in V}(dist_T(s', v))<\max\limits_{v\in V}(dist_G(s, v))$，而这不满足 $S$ 的定义，因此假设不成立

&nbsp;

有了上面两个引理，实际上我们就能得出一个推论：

> 推论 1. 枚举 $G$ 的生成树 $T$，取最小的 $f(T)$ 的值，该值即为题目所求的答案（$\max\limits_{v\in V}(dist_G(s, v))$，$s\in S$）

由 引理 1. 和 引理 2. ，该推论立即成立

### 再转化问题

对于一个基环树，枚举它的生成树显然只用枚举断环上的哪条边

首先我们随便选一条边断掉得到一个链，并把得到的链序列复制一遍，这样在这个复制后序列上滑动一个宽度为 $k$ 的窗口，其中 $k$ 为环上结点个数，就可以得到所有的断环情况

具体来讲，我们随便设环上一个结点为起点，并从它开始按规定方向不重复遍历环上结点，就得到了一个序列 $\{u_0, \cdots, u_{k-1}\}$，设序列从 $0$ 开始，其中 $k$ 为环上结点个数。接着将该序列复制一遍，得到序列 $\{u_0, \cdots, u_{k-1}, u_0, \cdots, u_{k-1}\}$，重标号为 $\{u_0, \cdots, u_{k-1}, u_k, \cdots, u_{2k-1}\}$，若有一个宽为 $k$ 窗口在序列中滑动，并规定窗口中第一个元素和最后一个元素间的边是断边，该窗口的所有可能状态就对应着所有可能的断边状态

同时在做树 dp 时，我们应该已经对环上每一个点处理出了它只向子树走的最长路径，记为 $f(u)$

再来考虑一段路径的贡献，其显然为 $f(u)+f(v)+dist(u, v)$，其中 $u$ 是环上起点，$v$ 是环上终点，$dist(u, v)$ 指从 $u$ 到 $v$ 在环上按规定方向遍历的路径长

而 $dist(u, v)$ 其实可以用前缀和维护。具体来说，给 $u_0$ 赋权值 $0$，对于其余的 $u_i$ 赋权值 $w(u_{i\mod k}, u_{(i-1)\mod k})$，其中 $w(u, v)$ 指图中对应边的权值；我们给这个值做一个前缀和，记为 $s(u)$，上面的贡献式子就可以写为 $f(u)-s(u)+f(v)+s(v)$，我们要令它最大

（这里也可以不复制序列，直接根据环上路径性质分类讨论就行了，还更好理解X。这个做法可以参考其他题解以及 [这道题](https://www.luogu.com.cn/problem/CF835F)）

### 滑动窗口维护次大值

由于式子里有两个元素，一个是 “加” 一个是 “减”，所以我们要维护两种值的最大值。但注意到当 $f(u)$ 足够大时，两种值的最大值都会取同一个结点，这显然是不合法的，因此我们还需维护次大值。滑动窗口次大值单调队列是不可做的（如果有什么方法请告诉我qaq），这里给出一个其它思路的线性做法

设区间从 $0$ 开始标号，窗口大小为 $m$

设 $f(x, 0/1)$ 表示右端点为 $x$，左端点为最大的 $y$ 满足 $y< x$ 且 $(m-1)|y$，区间 $(y, x]$ 的最大值（`0`）、次大值（`1`）

设 $g(x, 0/1)$ 表示左端点为 $x$，右端点为最小的 $y$ 满足 $y\geq x$ 且 $(m-1)|y$，区间 $[x, y]$ 的最大值（`0`）、次大值（`1`）

对于任意窗口，设其左端点为 $l$，其范围就为 $[l, l+m-1]$。**它一定包含一个下标能被 $(m-1)$ 整除的元素**；设该元素下标为 $z$，还一定满足 $[l, z], (z, l+m-1]$ 均非空。

设 $f'(x)=\max(f(x, 0), f(x, 1))$， $g'(x)$ 也同。于是该窗口的最大值就为 $\max(g'(l), f'(l+m-1))$，次大值也可用类似的方法计算出

另外如果区间有次大值，则应满足 $m\geq 2$，所以整除 $(m-1)$ 没有大碍

（其实改成 $m$ 也可以，用类似的方式定义就行了，两个区间不满足均非空但没有大碍。只是我敲代码时还没发现这点，为了方便代码理解题解里就讲成 $m-1$ 了）

同时这个方法也可维护滑动窗口的其它可逆/不可逆区间信息（不过必须得可合并）

## CODE

预处理上述两个数组只需顺着逆着遍历一遍序列，每隔 $(m-1)$ 就清空一次最大/次大值即可

但注意更新值、记录值（预处理数组）、清空值的顺序，根据上面定义的开/闭区间等会有一些变化（话说这里的顺序我是直接手模出来的X）

另外由于还需记录值对应的结点编号，因此代码会有一些壮观...不过只要思路看懂了自己应该也能敲出来X（最后我实际打出来也没调多久）

```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using std::max;
using std::min;

const int MAXN =1e5+50;

/*------------------------------Map------------------------------*/

int n, m;
int first[MAXN], tote;
struct edge{
	int net, to, w;
}e[MAXN<<1];

inline void addedge(int u, int v, int w){
	++tote;
	e[tote].to =v, e[tote].w =w, e[tote].net =first[u];
	first[u] =tote;
	++tote;
	e[tote].to =u, e[tote].w =w, e[tote].net =first[v];
	first[v] =tote;
}

/*------------------------------Circle------------------------------*/

int circle/*环上一点，相当于 index*/, lenc/*环长度*/;
int pre[MAXN], net[MAXN], evalpre[MAXN], evalnet[MAXN];
bool vis[MAXN], color[MAXN];
int stk[MAXN], top;

int predfs(int u, int eid/*处理重边环*/){
	if((eid&1) == 0)
		--eid;
	else
		++eid;
	vis[u] =1;
	stk[top++] =u;
	for(int l =first[u]; l; l =e[l].net)
		if(l != eid){
			net[u] =e[l].to;
			evalnet[u] =e[l].w;
			if(vis[e[l].to])
				return e[l].to;
			else{
				int ret =predfs(e[l].to, l);
				if(ret != 0)
					return ret;
			}
		}
	--top;
	return 0;
}

void getCircle(){
	int cir =predfs(1, 0);
	circle =cir;
	lenc =1;
	/*接环并给环染色*/
	pre[cir] =stk[top-1];
	evalpre[cir] =evalnet[stk[top-1]];
	color[cir] =1;
	while(stk[top-1] != cir){
		++lenc;
		pre[stk[top-1]] =stk[top-2];
		evalpre[stk[top-1]] =evalnet[stk[top-2]];
		color[stk[top-1]] =1;
		--top;
	}
}

/*------------------------------Dfs------------------------------*/

ll dp1[MAXN], dp2[MAXN];/*从 u 向子树走最大、次大的链*/
ll Anst;

void dfs1(int u, int fa){
	for(int l =first[u]; l; l =e[l].net)
		if(e[l].to != fa && !color[e[l].to]/*避免走环*/){
			dfs1(e[l].to, u);
			if(e[l].w+dp1[e[l].to] > dp1[u]){
				dp2[u] =dp1[u];
				dp1[u] =e[l].w+dp1[e[l].to];
			}
			else if(e[l].w+dp1[e[l].to] > dp2[u])
				dp2[u] =e[l].w+dp1[e[l].to];
		}
	Anst =max(Anst, dp1[u]+dp2[u]);
}

/*------------------------------滑动窗口------------------------------*/

/*其中 z 代表 x 左且 z<x / 右且 z>=x，最近的下标被 m-1 整除的点，其中 m 为窗口大小*/
/*前两个是 dp+sum，后两个是 dp-sum，第二维代表最大/次大值*/
ll l1[MAXN<<1][2]/*(z, x]*/, r1[MAXN<<1][2]/*[x, z]*/, l2[MAXN<<1][2], r2[MAXN<<1][2];
int idl1[MAXN<<1][2], idr1[MAXN<<1][2], idl2[MAXN<<1][2], idr2[MAXN<<1][2];

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

inline void modify(ll &mx, ll & mxs, int &idmx, int &idmxs, const ll &val, const int &idval){
	if(val > mx)
		mxs =mx, idmxs =idmx, mx =val, idmx =idval;
	else if(val > mxs)
		mxs =val, idmxs =idval;
}

int main(){
	n =read();
	for(int i =0; i < n; ++i){
		int u =read(), v =read(), w =read();
		addedge(u, v ,w);
	}
	getCircle();
	for(int u =circle, flg =0; u != circle || flg == 0; u =net[u]){
		if(u == circle)
			flg =1;
		dfs1(u, 0);
	}
	ll sum =-evalpre[circle];
	/*走两圈，序列大致为：s, ..., t, s, ..., t*/
	ll mx1 =0, mx1s =0, mx2 =-0x3f3f3f3f3f3f3f3f, mx2s =-0x3f3f3f3f3f3f3f3f;/*mx 最大，mxs 次大，注意 mx2 可能取负数*/
	int idmx1 =-1, idmx1s =-1, idmx2 =-1, idmx2s =-1;
	for(int u =circle, flg =0, i =0; u != circle || flg < 2; u =net[u], ++i){
		if(u == circle)
			++flg;
		sum +=evalpre[u];
		modify(mx1, mx1s, idmx1, idmx1s, dp1[u]+sum, i);
		modify(mx2, mx2s, idmx2, idmx2s, dp1[u]-sum, i);
		l1[i][0] =mx1, idl1[i][0] =idmx1, l1[i][1] =mx1s, idl1[i][1] =idmx1s;
		l2[i][0] =mx2, idl2[i][0] =idmx2, l2[i][1] =mx2s, idl2[i][1] =idmx2s;
		if(i%(lenc-1) == 0)/*开区间，且注意顺序 ( 这里顺序我是靠手模解决的 X )*/
			mx1 =mx1s =0, mx2 =mx2s =-0x3f3f3f3f3f3f3f3f,
			idmx1 =-1, idmx1s =-1, idmx2 =-1, idmx2s =-1;
	}
//	sum =-evalnet[pre[circle]];
	/*注意 sum 不要清空，以及注意接下来对 sum 的处理*/
	mx1 =0, mx1s =0, mx2 =-0x3f3f3f3f3f3f3f3f, mx2s =-0x3f3f3f3f3f3f3f3f;
	idmx1 =-1, idmx1s =-1, idmx2 =-1, idmx2s =-1;
	for(int u =pre[circle], flg =0, i =2*lenc-1/*注意下标*/; u != pre[circle] || flg < 2; u =pre[u], --i){
		if(u == pre[circle])
			++flg;
		if(i%(lenc-1) == 0)/*闭区间，且注意顺序*/
			mx1 =mx1s =0, mx2 =mx2s =-0x3f3f3f3f3f3f3f3f,
			idmx1 =-1, idmx1s =-1, idmx2 =-1, idmx2s =-1;
		modify(mx1, mx1s, idmx1, idmx1s, dp1[u]+sum, i);
		modify(mx2, mx2s, idmx2, idmx2s, dp1[u]-sum, i);
		r1[i][0] =mx1, idr1[i][0] =idmx1, r1[i][1] =mx1s, idr1[i][1] =idmx1s;
		r2[i][0] =mx2, idr2[i][0] =idmx2, r2[i][1] =mx2s, idr2[i][1] =idmx2s;
		sum -=evalpre[u];
	}
	/*走一圈统计答案, 初始窗口大概是这样的：[s, ..., t], s, ..., t*/
	ll Ansc =0x3f3f3f3f3f3f3f3f;
	for(int u =circle, flg =0, i =0; u != circle || flg < 1; u =net[u], ++i){
		if(u == circle)
			++flg;
		ll Mx1 =0, Mx1s =0, Mx2 =-0x3f3f3f3f3f3f3f3f, Mx2s =-0x3f3f3f3f3f3f3f3f;
		int idMx1 =-1, idMx1s =-1, idMx2 =-1, idMx2s =-1;
		modify(Mx1, Mx1s, idMx1, idMx1s, r1[i][0], idr1[i][0]), modify(Mx1, Mx1s, idMx1, idMx1s, r1[i][1], idr1[i][1]);
		modify(Mx1, Mx1s, idMx1, idMx1s, l1[i+lenc-1][0], idl1[i+lenc-1][0]), modify(Mx1, Mx1s, idMx1, idMx1s, l1[i+lenc-1][1], idl1[i+lenc-1][1]);
		modify(Mx2, Mx2s, idMx2, idMx2s, r2[i][0], idr2[i][0]), modify(Mx2, Mx2s, idMx2, idMx2s, r2[i][1], idr2[i][1]);
		modify(Mx2, Mx2s, idMx2, idMx2s, l2[i+lenc-1][0], idl2[i+lenc-1][0]), modify(Mx2, Mx2s, idMx2, idMx2s, l2[i+lenc-1][1], idl2[i+lenc-1][1]);
		ll Mx;
		if(idMx1 != idMx2)/*如果两种最大值的 id 不同*/
			Mx =Mx1+Mx2;
		else
			Mx =max(Mx1+Mx2s, Mx1s+Mx2);
		Ansc =min(Ansc, Mx);
	}
	printf("%.1lf", max(Anst, Ansc)/2.0);
}
```

---

## 作者：Macesuted (赞：24)

[题面](https://www.luogu.com.cn/problem/P1399)

## 题意分析

题目中会给出n个点，每个点都有一个父亲，这样形成一个图，让你在某一处（可以在点上，也可以在边上）安置一个快餐店使得整张图上离它最远的点最近。

很容易想到在题目最后至少有两个点离快餐店的距离相同，因为如果不相同，快餐店可以朝较远点的方向移动一段距离，最后答案更优。而由于快餐店离这两个点的距离都是最长的，所以这两个点之间的距离应该是所有点中最长的，即这两个点之间的路径就是直径。所以快餐店必然在直径的正中间以使得它离直径两端距离相同。

所以如果我们可以算出整张图中的直径，记直径长为$ans$，则最后答案就是$ans/2$，输出即可。

## 朴素算法

由于这整张图是一个基环树，我们可以考虑每次破掉环上的一条边使它变成一颗树，然后求出直径，最后统计所有的直径中最短的那个作为答案即可。

时间复杂度$O(n^2)$，实现较简单

## 正解

时间复杂度$O(n)$

首先我们可以把环上任意点所在的子树的参数存放在这个点上，然后对于这些点进行操作。

我们先考虑整个图上的直径可能存在的情况。
- 这个直径完全在环上某一点所在的子树中。
- 这个直径从环上某一点所在子树出发，到达该点后在环上走过一些边到达另一个点，进入该点所在子树并且结束。

第一种情况解决比较简单，我们只需要遍历环上的每一个点，求出它所在子树的直径计入答案即可。

对于第二种方法，我们容易发现直径在某子树内的部分一定是从该子树的根出发的最长路径，即树的最大深度。所以我们预先处理环上所有点所在子树的最大深度记为$dis_i$。

然后我们定义四个数组，暂且命名为$A,B,C,D$。记环上点数为$cnt$，环上点离1号点的距离为$pre_i$,离cnt号点的距离为$sub_i$则
- $A_i$表示环上$1\leq x\leq i$时$dis_x+pre_x$的最大值
- $B_i$表示环上$1\leq x\leq y\leq i$中$dis_x+dis_y-pre_x+pre_y$的最大值
- $C_i$表示环上$i\leq x\leq cnt$中$dis_x+sub_x$的最大值
- $D_i$表示环上$i\leq x\leq y\leq cnt$中$dis_x+dis_y+sub_x-sub_y$的最大值

四个数组分别存放的是，不完整的直径的右半边的最大值，处在i左侧的直径的最大值，不完整的直径的左半边的最大值，和处在i右侧的直径的最大值。

所以我们可以很自然的想到对于某一个i，在环上断开i和i+1之间的连边后直径应该可以分成三部分（其中tmp是1和cnt两点间边的长度）：
- 只在$1\sim i$之间的直径，即$B_i$
- 只在$i+1\sim cnt$之间的直径，即$D_i$
- 一半在$1\sim i$之间，一半在$i+1\sim cnt$之间，通过1号点和cnt号点的连边连接的直径，即$A_i+C_{i+1}+tmp$

所以综合起来我们从i号点断开的直径长度即为$max(B_i,D_i,A_i+C_{i+1}+tmp)$，我们只需要循环枚举n次即可求出答案，时间复杂度$O(n)$。

然后对于找环操作，时间复杂度$O(n)$，因为每一个点只访问过一次；对于每颗子树上的求直径和求深度，时间复杂度均为$O(n)$；最后的dp操作也是$O(n)$。所以总时间复杂度为$O(n)$。

## 细节

但是这里还有一些细节。因为我们需要求出直径，所以在计算过程中（如最后dp过程中比较三种情况）需要使用max，但是最后在统计过程中（就是将结果统计进ans的时候）我们需要使用min。因为统计过程中接触的每一个答案都是在某一种情况下可以达到的直径长度，按照题面描述，最小的即为最优解，我们需要取min。

而且我最开始偷懒尝试将直径两种情况（在一棵子树中和在两棵子树中）的结果用一个answer变量一起解决，但是到最后我发现我只拿到了80分，有20分WA了并且都是答案偏小。后来明白是对于两个answer，我们肯定是要取max的（因为如果两者中较小的值是直径，那么较大者显然比它更长，所以较大者才应该是直径，所以取max），但是在answer1和answer2的内部统计中我们全部采用的是min，所以两个变量是不可以混用的。（小细节而已啦，只是自己犯过的一个错）

这些细节可以在下面的代码中看到。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 5;

struct edge
{
    int to, from, cost;
} graph[maxn << 1];
int last[maxn << 1], cnt = 0;

int fa[maxn], cost[maxn];
int ringDist[maxn]; //环上子树的前面的边
int ring[maxn], ringCnt = 0;
bool isRing[maxn]; //是否在环上
int dfn[maxn], timet = 0;
long long dis[maxn]; //子树最大深度

long long A[maxn], //前缀+子树最大深度
    B[maxn],       //前缀中两个子树的最大深度+两点距离
    C[maxn],       //后缀+子树最大深度
    D[maxn];       //后缀中两个子树的最大深度+两点距离

void add(int x, int y, int z)
{
    graph[++cnt].to = y;
    graph[cnt].cost = z;
    graph[cnt].from = last[x];
    last[x] = cnt;
    return;
}

void dfs(int p)
{
    dfn[p] = ++timet;
    for (int i = last[p]; i; i = graph[i].from)
    {
        int to = graph[i].to;
        if (to != fa[p])
            if (!dfn[to]) //正常递归
            {
                fa[to] = p;
                cost[to] = graph[i].cost;
                dfs(to);
            }
            else if (dfn[to] > dfn[p]) //找到环
            {
                for (; to != p; to = fa[to]) //绕一圈
                {
                    isRing[to] = true;
                    ring[++ringCnt] = to;
                    ringDist[ringCnt] = cost[to];
                }
                isRing[p] = true;
                ring[++ringCnt] = p;
                ringDist[ringCnt] = graph[i].cost;
            }
    }
    return;
}

long long ans = 0;

void work(int p, int fa)
{
    for (int i = last[p]; i; i = graph[i].from)
    {
        int to = graph[i].to;
        if (!isRing[to] && to != fa)
        {
            work(to, p);
            ans = max((long long)dis[p] + dis[to] + graph[i].cost, ans);
            dis[p] = max(dis[p], dis[to] + graph[i].cost);
        }
    }
    return;
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        fa[i] = i;
        int from, to, dist;
        scanf("%d%d%d", &from, &to, &dist);
        add(from, to, dist);
        add(to, from, dist);
    }
    dfs(1);
    for (int i = 1; i <= ringCnt; i++)
        work(ring[i], 0); //对于环上的每一个点进行子树的信息统计
    long long sum = 0, maxx = 0;
    for (int i = 1; i <= ringCnt; i++)
    {
        sum += ringDist[i - 1];                          //sum是前缀
        A[i] = max(A[i - 1], dis[ring[i]] + sum);        //子树深度+前缀长度
        B[i] = max(B[i - 1], sum + maxx + dis[ring[i]]); //用之前最深的+当前子树深度+两子树之间距离
        maxx = max(maxx, dis[ring[i]] - sum);            //维护最深的子树深度
        //这里我们直接将dis和前缀一起存放，方便操作
    }
    sum = maxx = 0;
    int tmp = ringDist[ringCnt];
    ringDist[ringCnt] = 0; //切开环
    for (int i = ringCnt; i; i--)
    {
        sum += ringDist[i];                              //sum是后缀
        C[i] = max(C[i + 1], dis[ring[i]] + sum);        //子树深度+后缀长度
        D[i] = max(D[i + 1], sum + maxx + dis[ring[i]]); //用之前最深的+当前子树深度+两子树之间距离
        maxx = max(maxx, dis[ring[i]] - sum);            //维护最深的子树深度
    }
    long long ans2 = B[ringCnt]; //从1和cnt之间断开的情况
    for (int i = 1; i < ringCnt; i++)
        ans2 = min(max(max(B[i], D[i + 1]), A[i] + C[i + 1] + tmp), ans2); //从i拆开的三种情况
    printf("%.1lf", (double)max(ans, ans2) / 2.0);
    return 0;
}
```

---

## 作者：wu3412790 (赞：22)

题意：在一个环套树上，找中心，使得所有点到中心的最大距离最小。

首先如果是对于树，中心应该取到直径的中点上，答案是直径的一半。对于环套树，我们分两种情况讨论，一种是中心取在某颗树内，这时我们可以先预处理出来所有这棵树以外的点，到这棵树的根的最大距离，这可以使用单调队列处理。这样一来，如果中心在某颗树内，那么中心要么建在树直径的中点上，要么建在根向下最深的路径接上根向外最远的路径上(注意只能建在树内)，两种情况综合一下即可。如果，中心建在环上，这种情况相对简单，可以二分答案，这样对每个节点，为了能覆盖它，中心必须建在环上连续的一段，求一个环上的区间交即可，这只需要用查分求前缀和的办法就能做到。

作为一道NOI的题目，分析的难度不算高，但代码量相对较大，难度合适。

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
int const N=3e5+1,L=22;
struct interval{
	long long x,v;
	friend bool operator <(interval a, interval b){
		return a.x<b.x || (a.x==b.x && a.v<b.v); 
	}
}inter[N*4];
int n,m,k,tot,x1,x2,l,h,t,a[N],b[N],to[N],pre[N],last[N],fa[N][L],d[N],s[N],q[N];
long long T,c[N],v[N],f[N],g[N],di[N],len[N],p[N],z,w[N],far[N];
bool used[N],cir[N];
long long ans;
void add(int a, int b, long long c){
	to[++tot]=b;
	pre[tot]=last[a];
	last[a]=tot;
	v[tot]=c;
}
void dfs(int x, int father){
	fa[x][0]=father;
	d[x]=d[father]+1;
	used[x]=true;
	for (int i=last[x];i;i=pre[i])
		if (to[i]!=father){
			if (used[to[i]]) x1=x,x2=to[i],z=v[i]; else {
				w[to[i]]=v[i];
				dfs(to[i],x);
			}
		}
}
void dfs2(int x, int father){
	f[x]=g[x]=0;
	for (int i=last[x];i;i=pre[i])
		if (!cir[to[i]] && to[i]!=father){
			dfs2(to[i],x);
			if (f[to[i]]+v[i]>=f[x]){
				g[x]=f[x];
				f[x]=f[to[i]]+v[i];
			} else 
			if (f[to[i]]+v[i]>g[x]) g[x]=f[to[i]]+v[i];
			di[x]=max(di[x],di[to[i]]);
		} 
	di[x]=max(di[x],f[x]+g[x]);
}
int lca(int x, int y){
	if (d[x]<d[y]) swap(x,y);
	for (int j=L-1;j>=0;j--)
		if (d[x]-(1<<j)>=d[y]) x=fa[x][j];
	for (int j=L-1;j>=0;j--)
		if (fa[x][j]!=fa[y][j]) x=fa[x][j],y=fa[y][j];
	if (x!=y) return fa[x][0]; else return x;
}
bool check(long long z){
	k=0;
	for (int i=1;i<=l;i++){
		long long c=z-f[s[i]];
		if (c*2>=T){
			inter[++k]={0,1};
			inter[++k]={T,-1};
		}else
		{
			long long a=p[i-1]-c;
			long long b=p[i-1]+c;
			if (a<0) a+=T;
			if (b>=T) b-=T;
			if (a<=b){
				inter[++k]={a,1};
				inter[++k]={b+1,-1};
			} else{
				inter[++k]={0,1};
				inter[++k]={b+1,-1};
				inter[++k]={a,1};
				inter[++k]={T,-1}; 
			}
		}
	}
	sort(inter+1,inter+1+k);
	int now=0;
	for (int i=1;i<=k;i++){
		now+=inter[i].v;
		if (now==l) return true;
	}
	return false;
}
long long find(){
	long long ll=0;
	for (int i=1;i<=l;i++)
		ll=max(ll,f[s[i]]);
	long long rr=max(far[s[1]],f[s[1]]);
	while (rr-ll>1){
		long long mid=(ll+rr)/2;
		if (check(mid)) rr=mid; else ll=mid+1;
	}
	if (check(ll)) return ll;
	return rr;
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%d%d%lld",&a[i],&b[i],&c[i]);
		c[i]*=2;
		add(a[i],b[i],c[i]);
		add(b[i],a[i],c[i]);
	}
	dfs(1,0);
	for (int j=1;j<=L-1;j++)
		for (int i=1;i<=n;i++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
	int x3=lca(x1,x2);
	l=1+d[x1]+d[x2]-2*d[x3];
	m=0;
	for (int i=x1;d[i]>=d[x3];i=fa[i][0]){
		s[++m]=i;
		if (i!=x3) len[m]=w[i];
	}
	m=l;
	for (int i=x2;d[i]>d[x3];i=fa[i][0])
		s[m--]=i;
	for (int i=d[x1]-d[x3]+1;i<=l-1;i++)
		len[i]=w[s[i+1]];
	len[l]=z;
	for (int i=1;i<=l;i++)
		s[i+l]=s[i],len[i+l]=len[i];
	for (int i=1;i<=2*l;i++)
		p[i]=p[i-1]+len[i];
	T=p[l];
	for (int i=1;i<=l;i++)
		cir[s[i]]=true;
	for (int i=1;i<=l;i++)
		dfs2(s[i],0);
	if (l>1){
		int j=1;
		h=1,t=0;
		for (int i=1;i<=l;i++){
			while (h<=t && q[h]<=i) h++;
			while (p[j]-p[i-1]<=T/2){
				while (h<=t && p[j]+f[s[j+1]]>=p[q[t]-1]+f[s[q[t]]]) t--;
				q[++t]=++j;
			}
			if (h<=t) far[s[i]]=max(far[s[i]],p[q[h]-1]-p[i-1]+f[s[q[h]]]);
		}
		
		h=1,t=0;
		j=2*l;
		for (int i=2*l;i>=l+1;i--){
			while (h<=t && q[h]>=i) h++;
			while (p[i-1]-p[j-2]<=T/2){
				while (h<=t && -p[j-2]+f[s[j-1]]>=-p[q[t]-1]+f[s[q[t]]]) t--;
				q[++t]=--j;
			}
			if (h<=t) far[s[i]]=max(far[s[i]],p[i-1]-p[q[h]-1]+f[s[q[h]]]);
		}
		ans=find();
		for (int i=1;i<=l;i++){
			if (di[s[i]]>=f[s[i]]+far[s[i]]) ans=min(ans,di[s[i]]/2); else
			if (far[s[i]]<f[s[i]]) ans=min(ans,(f[s[i]]+far[s[i]])/2); else
			ans=min(ans,far[s[i]]);
		}
	} else ans=di[s[1]];
	double fans=ans;
	printf("%.1lf\n",fans/2);
	return 0;
} 
```

---

## 作者：NightTide (赞：14)

## 题目大意
求一棵基环树的重心。即一个点，使得树上到其距离最长的点到其的距离最短。注意，这个点不一定是一个节点，可以在树上的任意位置。输出树上到其距离最长的点到其的距离。

~~或者说求基环树最短的直径？（大雾~~
## 解题思路
显然，这颗基环树的直径只有两种情况：经过环和不经过环。

如果不经过环，那必定是环上某个点为根的子树的直径，这个可以用一般树上的做法做。再在所有的子树上的直径求最大值就是不经过环上的直径的答案。

重点在于环上的情况。首先我们画~~一个细菌~~一棵基环树，为了方便，我们默认这棵树上的边权为 $1$，实际实现时只需要考虑上边权就行了：
![](https://cdn.luogu.com.cn/upload/image_hosting/90foe4pr.png)

我们可以考虑枚举断开环上的哪一条边，再每种情况求一遍 $\max\{dep_i + dep_j + dis(i,j)\}$，最后对每种情况的答案取最小值就是经过环山的直径了。其中 $dep_i$ 表示环上第 $i$ 个点的子树最大深度，$dis(i,j)$ 表示环上第 $i$ 个点和第 $j$ 个点的距离。

这样不仅说起来拗口，时间复杂度也爆炸。

考虑有没有什么办法优化。首先，我们随便选择环上的一条边把环断开，这里选择的是 $1$ 和 $6$ 之间的边：

![](https://cdn.luogu.com.cn/upload/image_hosting/fnnw7w57.png)

然后考虑枚举环上的点，	求出将环上第 $i$ 个点和环上第 $i + 1$ 个点之间的边断开后的直径，再取一个 $\min$ 就是经过环上的答案了。

为了区分，我们把初始断开的边，即这里 $1$ 和 $6$ 之间的边成为**初始断边**，把当前枚举的要断开的边成为**当前断边**。

接下来又分情况考虑，总共有三种情况：

1. 起点和终点都在当前断边左边。

2. 起点和终点都在当前断边右边

3. 起点和终点一个在当前断边左边，一个在当前断边右边，即直径经过了初始断边。

其中前两种情况又是类似的，我们详细讲第一种：

我们设 $c_i$ 表示两段在环上第 $i$ 个点或第 $i$ 个点之前的点为根的子树上，且至少经过了环上一条边的直径长度，也就是我们要求的第一种情况的直径长度。这个不太好求，我们先稍微修改一下定义： $c_i$ 表示起点第 $i$ 个点之前的点为根的子树上，终点在以环上第 $i$ 个点为根的子树上，且至少经过了环上一条边的直径长度。显然会有柿子：

$$c_i = \max_{1 \le j \le i}\{dep_i + dep_j + dis(i,j)\}$$

显然，直接枚举又是 $O(TLE)$ 的，我们想办法优化。

首先一个优化空间在于 $dis(i,j)$，求这个如果暴力的话时间肯定承受不住，我们可以考虑求一个距离前缀和，$pre_i$ 表示从环上第 $1$ 个点到环上第 $i$ 个点的距离，那么 $dis(i,j) = |pre_i - pre_j|$。则柿子变为：


$$c_i = \max_{1 \le j \le i}\{dep_i + dep_j + pre_i - pre_j\}$$

然而，这样依旧 $O(n^2)$。剩下的优化空间就只有枚举的时间了，首先移项，得到：

$$c_i = \max_{1 \le j \le i}\{(dep_i + pre_i) + (dep_j - pre_j)\}$$

$dep_i + pre_i$ 显然在 $i$ 固定的时候是定值，把它丢出来：

$$c_i = \max_{1 \le j \le i}\{(dep_j - pre_j)\} + (dep_i + pre_i)$$

那么中间的 $dep_j - pre_j$ 我们可以变枚举 $i$ 边维护，这样就是 $O(n)$ 的了。

于是我们在回到一开始要求的东西，只需要对算出来的 $c$ 求一个前缀最大值就好了。

第二种情况与第一种情况对称。我们设 $d_i$ 表示两段在环上第 $i$ 个点或第 $i$ 个点之前后的点为根的子树上，且至少经过了环上一条边的直径长度。它的求法相同，只需要求后缀最大值和距离的后缀和就好了。

即，设 $suf_i$ 表示从环上最后一个点到环上第 $i$ 个点之间的距离，在经过与上面类似的简化后，有：

$$d_i = \max_{i \le j \le t}\{(dep_j - suf_j)\} + (dep_i + suf_i)$$

其中 $t$ 表示环上的结点数量，也代表环上最后一个点。

然后求后缀最大值，就得到了我们第二种情况的答案。

如图，但 $i = 3$ 时，$c_i$ 和 $d_i$ 本别代表了图中蓝色路径得长度和紫色路径得长度：
![](https://cdn.luogu.com.cn/upload/image_hosting/56l46wi9.png)

有一些细节需要注意，假设我们当前断边是环上第 $i$ 个点和环上第 $i + 1$ 个点之间的边，那么前两种情况的答案应该是 $c_i$ 和 $d_{i + 1}$ 而非 $c_i$ 和 $d_i$。

至于第三种情况稍微复杂一点，我们维护两个数组，$a_i$ 和 $b_i$。其中 $a_i$ 表示以环上第一个点为起点，以环上第 $i$ 个点或环上第 $i$ 个点以前的点为根的子树中某一点为终点的最大长度；$b_i$ 表示以环上最后一个点为起点，以环上第 $i$ 个点或环上第 $i$ 个点以后的点为根的子树中某一点为终点的最大长度。

经过上面的套路我们知道，对于 $a_i$，可以先求出以环上第一个点为起点，以环上第 $i$ 个点的子树中某一点为终点的最大长度，也就是 $pre_i + dep_i$，再求前缀最大值；$b_i$ 则是求出以环上最后一个点为起点，以环上第 $i$ 个点为根的子树中某一点为终点的最大长度，即 $suf_i + dep_i$，再求后缀最大值。

如图，$a_i$ 和 $d_i$ 分别代表图中的橙色路径长度和红色路径长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/9avewtnk.png)

那么第三种情况的答案就是红色路径长度加上橙色路径的长度再加上初始断边，即这里 $1$ 和 $6$ 之间的边的长长度。

这三种情况取最大值，就是将环上第 $i$ 个点和环上第 $i + 1$ 个点之间的边断开后的答案。接着枚举 $i$ 再求最小值，这就是直径经过环上的答案。

这种情况与之前直径不经过环上的答案取 $\max$ 就是这颗基环树的直径了。

对于这一题来说，答案还需要除以二。

## 完整代码
提供一些错误经验。

如果你 TLE，记得把 `memset` 换成时间戳。

如果你 WA 30pts，大概是没有开 `long long`。

如果你 WA 50pts，大概是 `INF` 开小了。

如果你 WA 90pts，大概是某些数组没有取前缀最大值或者后缀最大值。

没有删除调试行，如果需要的话可以对照一下输出。


```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define INF 0x7f7f7f7f7f7f7f7f
using namespace std;
typedef long long ll;
struct node{ ll id, dis; };
struct edge{ ll pre, to, w; };
stack<node> s;
node cir[MAXN];
edge e[MAXN << 1];
ll n, m, ans1, ans2 = INF, cnt = 1, times = 1;
ll head[MAXN], dis[MAXN], dia[MAXN], dep[MAXN], pre[MAXN], suf[MAXN], vis[MAXN], a[MAXN], b[MAXN], c[MAXN], d[MAXN];
bool iscir[MAXN];
inline ll read(){
   ll s = 0, w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9') { if(ch == '-') w = -1; ch = getchar(); }
   while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
   return s * w;
}
void add_edge(ll u, ll v, ll w){
    e[++cnt].pre = head[u];
    e[cnt].to = v; e[cnt].w = w;
    head[u] = cnt;
}
bool find_circle(ll now, ll fr){
    s.push((node){now, e[fr].w}); vis[now] = times;
    for(int i = head[now]; i; i = e[i].pre){
        // printf("%lld -> %lld i = %lld fr = %lld %lld\n",now,e[i].to,i,fr,i ^ 1 == fr);
        if((i ^ 1) == fr) continue;
        // printf("*\n");
        if(vis[e[i].to] != times){
            if(find_circle(e[i].to, i)) return true;
        }else{
            while(s.top().id != e[i].to){
                node p = s.top(); s.pop();
                cir[++m] = p; iscir[p.id] = true;
            }
            cir[++m] = (node){e[i].to, e[i].w}; iscir[e[i].to] = true;
            s.pop();
            return true;
        }
    }
    s.pop();
    return false;
}
ll bfs(ll st){
    // memset(vis, 0, sizeof(vis));
    // memset(dis, 0, sizeof(dis));
    ll res = st; times++;
    queue<ll> q; q.push(st);
    dis[st] = 0; vis[st] = times;
    while(!q.empty()){
        ll now = q.front(); q.pop();
        for(int i = head[now]; i; i = e[i].pre){
            if(vis[e[i].to] != times && !iscir[e[i].to]){
                // printf("    %lld -> %lld\n",now,e[i].to);
                dis[e[i].to] = dis[now] + e[i].w;
                if(dis[e[i].to] > dis[res]) res = e[i].to;
                q.push(e[i].to); vis[e[i].to] = times;
            }
        }
    }
    return res;
}
int main(){
    scanf("%lld",&n);
    for(int i = 1; i <= n; i++){
        ll u = read(), v = read(), w = read();
        add_edge(u, v, w); add_edge(v, u, w);
    }
    find_circle(1, 0);
    for(int i = 1; i <= m; i++){
        iscir[cir[i].id] = false;
        ll p = bfs(cir[i].id);
        dep[i] = dis[p]; dia[i] = dis[bfs(p)];
        ans1 = max(ans1, dia[i]);
        iscir[cir[i].id] = true;
    }
    for(int i = 2; i <= m; i++) pre[i] = pre[i - 1] + cir[i - 1].dis;
    for(int i = m - 1; i >= 1; i--) suf[i] = suf[i + 1] + cir[i].dis;
    for(int i = 1; i <= m; i++) a[i] = max(a[i - 1], dep[i] + pre[i]);
    for(int i = m; i >= 1; i--) b[i] = max(b[i + 1], dep[i] + suf[i]);
    for(ll i = 1, mx = 0; i <= m; i++){
        c[i] = mx + pre[i] + dep[i];
        mx = max(mx, dep[i] - pre[i]);
    }
    for(ll i = m, mx = 0; i >= 1; i--){
        d[i] = mx + suf[i] + dep[i];
        mx = max(mx, dep[i] - suf[i]);
    }
    for(int i = 1; i <= m; i++) c[i] = max(c[i], c[i - 1]);
    for(int i = m; i >= 1; i--) d[i] = max(d[i], d[i + 1]);
    for(int i = 1; i <  m; i++){
        ll res = max(a[i] + b[i + 1] + cir[m].dis, max(c[i], d[i + 1]));
        ans2 = min(ans2, res);
    }
    printf("%.1lf\n",(double)max(ans1, ans2) / 2.0);

    // printf("iscir: "); for(int i = 1; i <= n; i++) printf("%lld ",iscir[i]); printf("\n");
    // printf("cir_id: "); for(int i = 1; i <= m; i++) printf("%lld ",cir[i].id); printf("\n");
    // printf("cir_dis: "); for(int i = 1; i <= m; i++) printf("%lld ",cir[i].dis); printf("\n");
    // printf("dia: "); for(int i = 1; i <= m; i++) printf("%lld ",dia[i]); printf("\n");
    // printf("dep: "); for(int i = 1; i <= m; i++) printf("%lld ",dep[i]); printf("\n");
    // printf("pre: "); for(int i = 1; i <= m; i++) printf("%lld ",pre[i]); printf("\n");
    // printf("suf: "); for(int i = 1; i <= m; i++) printf("%lld ",suf[i]); printf("\n");
    // printf("a: "); for(int i = 1; i <= m; i++) printf("%lld ",a[i]); printf("\n");
    // printf("b: "); for(int i = 1; i <= m; i++) printf("%lld ",b[i]); printf("\n");
    // printf("c: "); for(int i = 1; i <= m; i++) printf("%lld ",c[i]); printf("\n");
    // printf("d: "); for(int i = 1; i <= m; i++) printf("%lld ",d[i]); printf("\n");

    return 0;
}
```

---

## 作者：xiaolangwhite (赞：9)

这是我的第一篇题解，感谢大家的食用。

码风稍丑，望诸位大佬勿喷。

## 题意解读

你有一颗[基环树](https://www.luogu.com.cn/blog/ShadderLeave/ji-huan-shu-bi-ji)，现在想让你找一个点，使得**这个点（不一定在节点上）到所有点的距离中最大距离最短**。

分析：

答案即为**基环树的直径的一半**。

证明：

由基环树的直径定义可得：

直径上的两个端点在基环树上有最长距离（否则就不是直径了）。

那么如果我们要求某个点到所有点的距离中最大距离最短。

自然可得在直径的中点处，得最大距离最短。

证毕。

## 解题思路

接下来就因该看如何实现求直径的操作了。

对于一颗基环树，其本质上是一颗（或多颗树）+ 环（有却只有一个）构成。

那么，我们只需把环找出断开并特殊处理，我们就可以把基环树当成树对待。

~~（基环树常见套路）。~~

## 代码过程

**代码编译环境：** GNU C++ 11

### 存图
我们以链式前向星存边（链式前向星的 $u$ 可以不要）。


```cpp
struct Edge {
	ll u,v,w,nxt;
} edge[MAXN];
ll cnt,head[MAXN];
void AddEdge(ll u,ll v,ll w) {
	edge[++cnt] = {u,v,w,head[u]},head[u] = cnt;
}
```

### 判断环

定义数组：


```cpp
#define ll long long
ll father[MAXN],val[MAXN];
ll ringlength[MAXN],ring[MAXN],ringcnt,ringroot;
bool inring[MAXN];
ll length[MAXN];
ll dfn[MAXN],ct;
```

- $father$ 代表的是在判断环中存贮的对应节点的父节点。

- $val$ 对应的是在存图中记录的对应 $father_{i} \to son_{i}$ 的边权值。

（为什么要记录呢？因为在调用时可以更快更方便，且通往这个节点的 $father_{i}$ 不只是一个，记录下来以防弄错）。

- $ringlength$ 表示找到环后对应的边权的大小。

- $ring$ 表示环中一个点的编号。

- $ringcnt$ 表示环中边的数量（同时也是点的数量）。

- $inring$ 则表示是否在环里。

- $length$ 则表示子树的深度。

- $ringroot$ ~~没有用，芝士忘删了。~~

### tarjan 判断环

```cpp
void dfs(ll x) {
	dfn[x] = ++ct;
	ll v,w;
	for(ll i = head[x]; i; i=edge[i].nxt) {
		v = edge[i].v,w = edge[i].w;
		if(v != father[x]) {
			if(!dfn[v]) {
				val[v] = w,father[v] = x;
				dfs(v);
			} else if(dfn[x] < dfn[v]) {
				for(ll i = v; i != x; i = father[i]) {
					inring[i] = 1,ring[++ringcnt] = i,ringlength[ringcnt]=val[i];
				}
				inring[x] = 1,ring[++ringcnt] = x,ringlength[ringcnt]=edge[i].w;
			}
		}
	}
}
```

~~不会的自行补学一下 tarjan。~~

重点解释一下 **if** 中的内容。

```cpp
if(v != father[x]) {
	if(!dfn[v]) {
		val[v] = w,father[v] = x;
		dfs(v);
	} else if(dfn[x] < dfn[v]) {
		for(ll i = v; i != x; i = father[i]) {
			inring[i] = 1,ring[++ringcnt] = i,ringlength[ringcnt]=val[i];
		}
		inring[x] = 1,ring[++ringcnt] = x,ringlength[ringcnt]=edge[i].w;
}
```

在没有利用双向边回到自己父亲节点时：

判断新节点是否被经过。

如果未被经过，则将边权和将搜的点的 $father_{i}$ 记录下来。

**边权不会错是应为如果没发现环，回溯过来时边权会重新被覆盖， $father_{i}$ 数组同理。**

在进一步进行深搜：

如果发现更晚的时间戳（即证明已经经过），则等价于发现环。

在由于之前的 $father_{i}$ 已被记录，最终可以遍历环，把环储存下来（**不要忘了自己**）。

### 统计所有子树最大高度

```cpp
ll res1,res2;//统计所有子树最大高度 
void statistics(ll x,ll fa){
	ll v,w;
	for(int i = head[x];i;i = edge[i].nxt){
		v = edge[i].v,w = edge[i].w;
		if(!inring[v]&&v != fa){
			statistics(v,x);
			res1 = max(res1,length[x]+length[v]+w);
			length[x] = max(length[x],length[v]+w);
		}
	}
}
```

也是重点解释 **if** 中的部分：

```cpp
if(!inring[v]&&v != fa){
	statistics(v,x);
	res1 = max(res1,length[x]+length[v]+w);
	length[x] = max(length[x],length[v]+w);
}
```

如果不在环上，进行搜索，统计一棵子树的最大直径。

当加上如下代码时：

```cpp
for(int i = 1;i <= ringcnt;i++){
	statistics(ring[i],0);
}
```

则是统计所有子树的最大直径 $res1$ 。

而 $length_{i}$ 则表示长度记录，不断更新，获得从这个点下去子树的最大深度。

准确来讲叫距离，所以叫 $length$ 。

------------
重点分割线 qwq
-----------

### 对于直径的求解

```cpp
ll sum,maxx,tmp;
ll A[MAXN],B[MAXN],C[MAXN],D[MAXN];
void init(){
	for(int i = 1;i <= ringcnt;i++){
		sum += ringlength[i-1];
		A[i] = max(A[i-1],length[ring[i]]+sum);
		B[i] = max(B[i-1],sum+maxx+length[ring[i]]);
		maxx = max(maxx,length[ring[i]]-sum);
	}
	sum = maxx = 0;
	tmp = ringlength[ringcnt];
	ringlength[ringcnt] = 0;
	for(int i = ringcnt;i>=1;i--){
		sum += ringlength[i];
		C[i] = max(C[i+1],length[ring[i]]+sum);
		D[i] = max(D[i+1],sum+maxx+length[ring[i]]);
		maxx = max(maxx,length[ring[i]]-sum);
	}
}
init();
res2 = B[ringcnt];
for(int i = 1;i <= ringcnt;i++){
	res2 = min(max(A[i]+C[i+1]+tmp,max(B[i],D[i+1])),res2);
}
printf("%.1f",double(max(res1,res2)/2.0));//注意整除
```

我们规定：

$A$ 为前缀链长度 + 当前节点子树最大深度。

$B$ 为前缀链中两个子树的最大深度 + 两点之间链的长度（距离）。

$C$ 为后缀链长度 + 当前节点子树最大深度。

$D$ 为后缀中两个子树的最大深度 + 两点之间链的长度（距离）。

则我们只需要对四种情况考虑即可：


- $A_{i}+C_{i}+tmp$ 表示经过环的断点的直径。

- $B_{i}$ 表示在 $i$ 左侧的直径的最大值。

- $D_{i+1}$ 表示在 $i$ 右侧的直径的最大值。

- $res1$ 表示在子树中的直径最大值。


解释：

这段的计算运用了动规思想。

$length_{ring_{i}}+sum_{i}$ 表示前缀（后缀）链的长度 + 此时树的深度。

$sum_{i}+maxx_{i}+length_{ring_{i}}$ 表示前缀（后缀）链的长度 + 最大子树的深度 $maxx_{i}$ + 此时树的深度。

$maxx_{i}$ 减去了前缀链的长度，以此来抵消前缀的影响。

枚举环上的点，看看何时直径最大。

为什么：**这样枚举之间复杂度最坏也是 $O(n)$ ，而不是两两枚举的  $O(n^2)$ 。**

**其实就是前缀和（后缀）优化啦。**

## 完整代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
using namespace std;
const int MAXN = 2e5+10;
ll n; 
struct Edge {
	ll u,v,w,nxt;
} edge[MAXN];
ll cnt,head[MAXN];
void AddEdge(ll u,ll v,ll w) {
	edge[++cnt] = {u,v,w,head[u]},head[u] = cnt;
}
ll father[MAXN],val[MAXN];
ll ringlength[MAXN],ring[MAXN],ringcnt,ringroot;
bool inring[MAXN];
ll length[MAXN];
ll dfn[MAXN],ct;
void dfs(ll x) {
	dfn[x] = ++ct;
	ll v,w;
	for(ll i = head[x]; i; i=edge[i].nxt) {
		v = edge[i].v,w = edge[i].w;
		if(v != father[x]) {
			if(!dfn[v]) {
				val[v] = w,father[v] = x;
				dfs(v);
			} else if(dfn[x] < dfn[v]) {
				for(ll i = v; i != x; i = father[i]) {
					inring[i] = 1,ring[++ringcnt] = i,ringlength[ringcnt]=val[i];
				}
				inring[x] = 1,ring[++ringcnt] = x,ringlength[ringcnt]=edge[i].w;
			}
		}
	}
}
ll res1,res2;//统计所有子树最大高度 
void statistics(ll x,ll fa){
	ll v,w;
	for(int i = head[x];i;i = edge[i].nxt){
		v = edge[i].v,w = edge[i].w;
		if(!inring[v]&&v != fa){
			statistics(v,x);
			res1 = max(res1,length[x]+length[v]+w);
			length[x] = max(length[x],length[v]+w);
		}
	}
}
ll sum,maxx,tmp;
ll A[MAXN],B[MAXN],C[MAXN],D[MAXN];
void init(){
	for(int i = 1;i <= ringcnt;i++){
		sum += ringlength[i-1];
		A[i] = max(A[i-1],length[ring[i]]+sum);
		B[i] = max(B[i-1],sum+maxx+length[ring[i]]);
		maxx = max(maxx,length[ring[i]]-sum);
	}
	sum = maxx = 0;
	tmp = ringlength[ringcnt];
	ringlength[ringcnt] = 0;
	for(int i = ringcnt;i>=1;i--){
		sum += ringlength[i];
		C[i] = max(C[i+1],length[ring[i]]+sum);
		D[i] = max(D[i+1],sum+maxx+length[ring[i]]);
		maxx = max(maxx,length[ring[i]]-sum);
	}
}
int main() {
	scanf("%lld",&n);
	ll u,v,w;
	for(int i = 1;i <= n;i++){
		scanf("%lld%lld%lld",&u,&v,&w);
		AddEdge(u,v,w);
		AddEdge(v,u,w);
		father[i] = i;
	}
	dfs(1);
	for(int i = 1;i <= ringcnt;i++){
		statistics(ring[i],0);
	}
	init();
	res2 = B[ringcnt];
	for(int i = 1;i <= ringcnt;i++){
		res2 = min(max(A[i]+C[i+1]+tmp,max(B[i],D[i+1])),res2);
	}
	printf("%.1f",double(max(res1,res2)/2.0));//注意整除
	return 0;
}
```

-------------------

### 后记：感谢管理员大大百忙中审核题解。

---

## 作者：lahlah (赞：5)

# link:[题目](https://www.luogu.org/problemnew/show/P1399)



# [听说在blog食用体验更佳](https://blog.csdn.net/qq_38944163/article/details/89470928)


----
## 题意
### 给出一个基环树，每条边有一个边权，在图上求出一个点（可以在边上）使得它到图上每个节点的最大距离最小，输出那个距离.
---
### 题解
~~可以直接看代码~~

一个和很直观的思路，对于基环树，只需要断开换上的一条边然后求树的直径就可以了，可以证明断开一条边后对答案没有影响，因为距离肯定不会成一个环。

但是这样也是$o(n^2)$。

可以先对换上的每个外向树做一次求直径（最后的答案肯定大于等于它的一半的），求出$f[i]$表示以第$i$个点为起点,做大能在子树中延伸的长度。

然后对于换上$i,j$两点,他们的距离就是$f[i]+f[j]+dis[i][j]$,$dis[i][j]$表示的是在环上$i,j$的直接距离。

拆换成链后就变成$f[i]+f[j]+sum[j] - sum[i]$,$ \ $ $sum[i]$表示拆环成链后边权的前缀和,然后$f[i]-sum[i]$和$f[j]-sum[j]$直接开两个堆维护一下最大值就可以了,注意要考虑$i == j$的情况。

~~是不是很简单（毒瘤）~~
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
using namespace std;
struct edge{
    int v, nxt, c;
}e[N << 1];
int p[N], eid;
void init(){
    memset(p, -1, sizeof p);
    eid = 0;
}
void insert(int u, int v, int c){
    e[eid].v = v;
    e[eid].c = c;
    e[eid].nxt = p[u];
    p[u] = eid ++;
}
int dfn[N], n, fa[N], f[N], F, ring[N], cnt, ha[N], ans, tot, sum[N], val[N];
void findring(int u){
    if(dfn[u]) F = dfn[u];
    if(F) return;
    dfn[u] = ++ tot;
    for(int i = p[u]; i + 1; i = e[i].nxt){
        int v = e[i].v;
        if(v == fa[u]) continue;
        fa[v] = u;
        findring(v);
    }
    if(F) ring[++ cnt] = u, ha[u] = 1;
    if(F == dfn[u]) F = 0;
}
void dfs(int u){ //dp 
    for(int i = p[u]; i + 1; i = e[i].nxt){
        int v = e[i].v;
        if(v == fa[u] || ha[v]) continue;
        fa[v] = u;
        dfs(v);
        ans = max(ans, f[u] + f[v] + e[i].c);//求树的直径 
        f[u] = max(f[u], f[v] + e[i].c);//第u为起点,做大能在子树中延伸的长度 
    }
}
struct cmp1{int operator()(int x, int y){
    return f[ring[x]] - sum[x] < f[ring[y]] - sum[y];
}};
struct cmp2{int operator()(int x, int y){
    return f[ring[x]] + sum[x] < f[ring[y]] + sum[y];
}};
priority_queue<int, vector<int>, cmp1> q1;//维护f[i]-sum[i] 
priority_queue<int, vector<int>, cmp2> q2;//维护f[i]+sum[i] 
signed main(){
    init();
    scanf("%lld", &n);
    for(int i = 1; i <= n; i ++){
        int u, v, c;
        scanf("%lld%lld%lld", &u, &v, &c);
        insert(u, v, c);
        insert(v, u, c);
    }
    findring(1);
    memset(fa, 0, sizeof fa);
    for(int i = 1; i <= cnt; i ++) dfs(ring[i]);//对于环上的每个点向外延伸的树做一次dp 
    ring[0] = ring[cnt]; 
    for(int i = 1; i <= cnt; i ++){//把环的边权表示成序列的形式 
        int u = ring[i];
        for(int j = p[u]; j + 1; j = e[j].nxt){
            int v = e[j].v;
            if(v == ring[i - 1]) val[i] = e[j].c;
        }
    }
    for(int i = 1; i <= cnt;i ++) val[i + cnt] = val[i], ring[i + cnt] = ring[i];//拆环成链 

    for(int i = 1; i <= cnt * 2; i ++) sum[i] = sum[i - 1] + val[i];//做环上边权的前缀和 
    int anss = 1e18;
    for(int i = 1; i <= cnt; i ++) q1.push(i), q2.push(i);
    for(int i = 1; i <= cnt; i ++){
        while(q1.top() < i && q1.size() > 1)	q1.pop();
        while(q2.top() < i && q2.size() > 1)	q2.pop();
        int x = q1.top(), y = q2.top();
        if(x == y){//要靠考虑i == j的情况，每个再取出一个最大值，然后交叉组合看那个大 
            q1.pop(), q2.pop();
            while(q1.top() < i && q1.size() > 1)	q1.pop();
            while(q2.top() < i && q2.size() > 1)	q2.pop();
            int xx = q1.top(), yy = q2.top();
            anss = min(anss, max(f[ring[x]] - sum[x] + f[ring[yy]] + sum[yy], f[ring[xx]] - sum[xx] + f[ring[y]] + sum[y]));//硬套刚刚的公式 
            q1.push(x), q2.push(y);
        }else anss = min(anss, f[ring[x]] - sum[x] + f[ring[y]] + sum[y]);//不然就直接搞 
        q1.push(cnt + i), q2.push(cnt + i);
    }
    ans = max(anss, ans);//和之前树的直径求个最大值 
    
    printf("%lld.%lld", ans/2, (ans&1)? 5:0);//输出 
    return 0;
}

```

---

## 作者：glorious_dream (赞：5)

### 算法分析：

首先这是一道基环树的题。给定 $n$ 个点和 $n$ 条边，而且保证联通，那么就存在一个环。

要求出一个点到离它距离最远的点的距离最小，显然跟直径有关，求出此基环树的直径，答案为直径除以 $2$。

那么考虑如何求直径。有两种情况。

$1$.直径不经过基环。

$2$.直径经过基环。

在求直径之前，我们需要将哪些点在环上记录下来。我们从 $1$ 号点开始深搜找环。具体看代码注释。

```cpp
inline bool find(int u){
	vis[u] = 1; //这个点记录为走过 
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to;
		if(v == fa[u]) continue; //走到了父亲不行 
		fa[v] = u;
		w[v] = e[i].w; //将这条边的边权转化为儿子的点权，和树剖的转化类似 
		if(!vis[v]) { if(find(v)) return 1; } //如果这个点没有走过而且后面能找到环，就一直往回return 
		else{ //找到了环 
			int p = u; //枚举环上的点 
			while(1){
				inc[p] = 1; //inc[p]=1表示p在环上 
				cv[++tot] = p; //环上的点的编号，由于后面操作，我们需要重新编号 
				cw[tot] = w[p]; //环上这个编号点的点权 
				p = fa[p]; //由于记录了fa[p]是p的父亲，所以可以往回找 
				if(p == u) break; //环遍历完了 
			}
			return 1; //记录已经找到环 
		}
	}
	return 0; //没找到就继续往下找 
}
```


一个一个考虑，先看直径不经过基环，这个比较好求。此基环树的直径为环上挂着的点的每一棵子树的最大直径，记为 $res1$，枚举环上的每一个点，深搜计算子树的直径 $res1 = max(d[u]+d[v]+w(u,v))$。顺道求出以 $u$ 为根的子树的最大深度 $d[u]$。

```cpp
inline void dfs(int u,int fa){
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to,w = e[i].w;
		if(inc[v] || v==fa) continue; //如果这个点在环上，或者搜到了父亲就不继续 
		dfs(v,u); //往下搜 
		res1 = max(res1,d[u]+d[v]+w); //求最大的直径 
		d[u] = max(d[u],d[v]+w); //顺道记录下来以u为根的最大深度 
	}
}

rep(i,1,tot) dfs(cv[i],0);
```

然后来看直径经过环。一个最简单的想法就是，暴力枚举删哪一条边， $res[i] = max ($两个子树的深度 $+$ 它们在环上的距离 $)$。则经过环的直径 $res2 = min(res[i])$。

但这样做复杂度是 $n^2$ 的，过不去本题。考虑如何进行优化。

$1$.把边 $(1,tot)$ 断开，$tot$ 为环上有 $tot$ 个点，预处理前缀长度。

$A[i] = max($ 前缀中链的长度 $+$ 节点树的深度 $)$。

$B[i] = max($ 前缀中两棵树的深度 $+$ 这两个节点之间的距离 $)$。

$2$.把边 $(1,tot)$ 断开，预处理后缀长度。

$C[i] = max($ 后缀中链的长度 $+$ 节点树的深度 $)$。

$D[i] = max($ 后缀中两棵树的深度 $+$ 这两个节点之间的距离 $)$。

3.枚举断开环上的边 $(i,i+1)$，拼凑答案。

$res[i] = max(B[i],D[i+1],A[i]+C[i+1]+w(1,tot))$

则经过环的直径 $res2 = min(res[i])$。

注意，最后需要有个特判，断开 $(1,tot)$ 这条边，需要加上一句话 $res2 = min(res2,B[tot])$。

那么基环树的直径就是 $max(res1,res2)$，这道题的答案就是 $max(res1,res2)/2$。

```cpp
double sum=0,mx=0;
	rep(i,1,tot){ //预处理前缀 
		sum += cw[i-1]; //sum就是链长的加和 
		A[i] = max(A[i-1],sum+d[cv[i]]); //根据A数组的定义来推 
		B[i] = max(B[i-1],mx+d[cv[i]]+sum); //这里很巧妙
											//我们的mx记录的是i这个点之前的某一个点k的深度-k之前的链长 
											//也就是说，我们要求B数组，可以用一个抵消的思想
											//sum记录的是链长的加和，再加上mx，也就把k前面的链长消掉了
											//最后剩的就是k的深度+k到i的链长+i的深度，与B数组定义相同 
		mx = max(mx,d[cv[i]]-sum); //注意要更新mx 
	}
	sum = mx = 0;
	double cn_1 = cw[tot]; //这里也很巧妙，把tot这个点的点权记录下来，也就是相当于把1和tot这条边断开 
	cw[tot] = 0; //要把tot这个点点权清零 
	drep(i,tot,1){ //预处理后缀，和前缀类似 
		sum += cw[i];
		C[i] = max(C[i+1],sum+d[cv[i]]);
		D[i] = max(D[i+1],mx+d[cv[i]]+sum);
		mx = max(mx,d[cv[i]]-sum);
	}
	double res;
	rep(i,1,tot){
		res = max(max(B[i],D[i+1]),A[i]+C[i+1]+cn_1); //上述所说的三段 
		res2 = min(res2,res); //使res2最小化 
	}
	res2 = min(res2,B[tot]); //别忘了加上特判 
	printf("%.1lf\n",max(res1,res2)/2);
```

### 总代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#define re register
#define drep(a,b,c) for(re int a(b) ; a>=(c) ; --a)
#define rep(a,b,c) 	for(re int a(b) ; a<=(c) ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
const int M = 2e5+10;
int n;
int head[M],vis[M],fa[M];
int inc[M],cv[M],cw[M],w[M];
double d[M],A[M],B[M],C[M],D[M];
int cnt,tot,ans;
double res1,res2=1e18;
struct edge{
	int to,nxt,w;
}e[M];
inline void add(int u,int v,int w){
	e[++cnt].to = v;
	e[cnt].w = w;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
inline bool find(int u){
	vis[u] = 1; //这个点记录为走过 
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to;
		if(v == fa[u]) continue; //走到了父亲不行 
		fa[v] = u;
		w[v] = e[i].w; //将这条边的边权转化为儿子的点权，和树剖的转化类似 
		if(!vis[v]) { if(find(v)) return 1; } //如果这个点没有走过而且后面能找到环，就一直往回return 
		else{ //找到了环 
			int p = u; //枚举环上的点 
			while(1){
				inc[p] = 1; //inc[p]=1表示p在环上 
				cv[++tot] = p; //环上的点的编号，由于后面操作，我们需要重新编号 
				cw[tot] = w[p]; //环上这个编号点的点权 
				p = fa[p]; //由于记录了fa[p]是p的父亲，所以可以往回找 
				if(p == u) break; //环遍历完了 
			}
			return 1; //记录已经找到环 
		}
	}
	return 0; //没找到就继续往下找 
}
inline void dfs(int u,int fa){
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to,w = e[i].w;
		if(inc[v] || v==fa) continue; //如果这个点在环上，或者搜到了父亲就不继续 
		dfs(v,u); //往下搜 
		res1 = max(res1,d[u]+d[v]+w); //求最大的直径 
		d[u] = max(d[u],d[v]+w); //顺道记录下来以u为根的最大深度 
	}
}
signed main(){
	n=read();
	rep(i,1,n){
		int u=read(),v=read(),w=read();
		add(u,v,w),add(v,u,w);
	}
	find(1);
	rep(i,1,tot) dfs(cv[i],0);
	double sum=0,mx=0;
	rep(i,1,tot){ //预处理前缀 
		sum += cw[i-1]; //sum就是链长的加和 
		A[i] = max(A[i-1],sum+d[cv[i]]); //根据A数组的定义来推 
		B[i] = max(B[i-1],mx+d[cv[i]]+sum); //这里很巧妙
											//我们的mx记录的是i这个点之前的某一个点k的深度-k之前的链长 
											//也就是说，我们要求B数组，可以用一个抵消的思想
											//sum记录的是链长的加和，再加上mx，也就把k前面的链长消掉了
											//最后剩的就是k的深度+k到i的链长+i的深度，与B数组定义相同 
		mx = max(mx,d[cv[i]]-sum); //注意要更新mx 
	}
	sum = mx = 0;
	double cn_1 = cw[tot]; //这里也很巧妙，把tot这个点的点权记录下来，也就是相当于把1和tot这条边断开 
	cw[tot] = 0; //要把tot这个点点权清零 
	drep(i,tot,1){ //预处理后缀，和前缀类似 
		sum += cw[i];
		C[i] = max(C[i+1],sum+d[cv[i]]);
		D[i] = max(D[i+1],mx+d[cv[i]]+sum);
		mx = max(mx,d[cv[i]]-sum);
	}
	double res;
	rep(i,1,tot){
		res = max(max(B[i],D[i+1]),A[i]+C[i+1]+cn_1); //上述所说的三段 
		res2 = min(res2,res); //使res2最小化 
	}
	res2 = min(res2,B[tot]); //别忘了加上特判 
	printf("%.1lf\n",max(res1,res2)/2);
	return 0;
}
```


---

## 作者：________a____ (赞：4)

## 题目大意

求基环树的直径。

## 解析

一颗基环树的直径有两种情况：

1. 直径为环上某一点子树的直径。
2. 直径为环上某一点子节点经过环到达另一点子节点。

对于情况 $1$，显然断环上哪条边对子树直径不会有影响，可以直接处理出来。

对于情况 $2$，可以求断掉环上任意一边的直径的最大值(也就相当于钦定一条边不属于直径，求出所以可能的直径情况)：

 ![](https://cdn.luogu.com.cn/upload/image_hosting/qt6z5cqn.png)

将环上任意一边断开拆环为链，并复制一遍接在末尾：

![](https://cdn.luogu.com.cn/upload/image_hosting/h4gxe78j.png)

用一个长度为环的点数的窗口从左向右扫过去，每次更新答案，就可以包含所以断边的情况。

如图，若先断开 $1,3$ 之间的边。

令 $dep_i$ 为 $i$ 点子节点的最大深度，$sum_i$ 为 $i$ 距 $1$ 号节点的距离。

令 $a_i=dep_i-sum_i,b_i=dep_i+sum_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/g14ukm6w.png)

如图，红色段为 $a$，蓝色段为 $b$，紫色段为合并后的直径。

直径长度为 $\max\{dep_i+dep_j+sum_j-sum_i\}$ $(sum_i<sum_j)$。

也就是直径为 $\max\{a_i+b_j\}$。

所以可以取 $\max\{a_i\}+\max\{b_j\}$ 为直径。

但可能会出现 $i=j$ 的情况。

所以要维护 $a_i$ 和 $b_i$ 的最大值和次大值。

最后将情况 $1$ 与情况 $2$ 取最大值。

## 实现

建立一个可以支持单点修改并查询最值的数据结构(如线段树)。

断开环上任意一边并将链复制一遍接在末尾。

若环长为$k$。

依次扫描每个点，每次更新 $a_i,b_i$ ,前 $(k-1)$ 个点不更新 $ans$(还没形成一颗完整的树),之后每次查询 $a_i$ 和 $b_i$ 的最大值和次大值更新 $ans$。

每次更新的信息的有效期为 $k$ 次移动窗口。

而 $k$ 次移动窗口是一个循环，又回到了同一点，直接更新 $a$ 和 $b$ ，替代过期信息即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 200010
#define ls p<<1
#define rs p<<1|1
int n;
vector<int> ver[MAXN],e[MAXN];
inline int read(){
    int a=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') {
        a=(a<<1)+(a<<3)+(ch^48);
        ch=getchar();
    }
    return a;
}
inline void add(int u,int v,int w){
    ver[u].push_back(v);
    e[u].push_back(w);
}
int pre[MAXN];
int w[MAXN];
char mark[MAXN];
int dep[MAXN];
int _ans=0;
void dfs_(int u){ //标记环上的点
    if(mark[u]) return ;
    mark[u]=1;
    dfs_(pre[u]);
}
bool dfs(int u,int fa){ //找环
    for(int v,i=0;i<ver[u].size();i++){
        if((v=ver[u][i])==fa) continue;
        if(pre[v]){
            pre[v]=u;
            w[v]=e[u][i];
            dfs_(u);
            return 1;
        }
        pre[v]=u;
        w[v]=e[u][i];
        if(dfs(v,u)) return 1;
    }
    return 0;
}
void dfs_dep(int u,int fa){ //处理子树直径和dep[u]
    for(int i=0,v;i<ver[u].size();i++){
        if((v=ver[u][i])==fa) continue;
        if(mark[v]) continue;
        dfs_dep(v,u);
        _ans=max(_ans,dep[u]+dep[v]+e[u][i]);
        dep[u]=max(dep[u],dep[v]+e[u][i]);
    }
}
int a[MAXN],b[MAXN];
inline bool cmp1(int _a,int _b){ //因为是记录的点的编号,所以按数组对应元素排序
    return a[_a]<a[_b];
}
inline bool cmp2(int _a,int _b){
    return b[_a]<b[_b];
}
struct node {
    int a,aa,b,bb;
    node operator + (node _b){
        node res; //奇丑无比的区间最大值次大值维护
        vector<int> rec;
        rec.push_back(a);
        rec.push_back(aa);
        rec.push_back(_b.a);
        rec.push_back(_b.aa);
        sort(rec.begin(),rec.end(),cmp1);
        res.a=rec[3],res.aa=rec[2];
        rec.clear();
        rec.push_back(b);
        rec.push_back(bb);
        rec.push_back(_b.b);
        rec.push_back(_b.bb);
        sort(rec.begin(),rec.end(),cmp2);
        res.b=rec[3],res.bb=rec[2];

        return res;
    }
}data[MAXN<<2];
inline void push_up(int p){
    data[p]=data[ls]+data[rs];
}
inline void build(int l,int r,int p){
    if(l==r){
        data[p].a=data[p].b=l;
        //记录对应节点编号
        return ;
    }
    int mid=l+r>>1;
    build(l,mid,ls);
    build(mid+1,r,rs);
    push_up(p);
}
void upd(int l,int r,int x,int p){
    if(l==r){
        // 确实什么都没有
        return ;
    }
    int mid=l+r>>1;
    if(mid>=x) upd(l,mid,x,ls);
    else upd(mid+1,r,x,rs);
    push_up(p);
}
inline int qu(){
    if(data[1].a==data[1].b) //如果是同一点，分类讨论更新
        return max(a[data[1].a]+b[data[1].bb],a[data[1].aa]+b[data[1].b]);
    return a[data[1].a]+b[data[1].b]; //不是同一点，直接更新
}
signed main(){
    scanf("%lld",&n);
    for(int i=1,u,v,w;i<=n;i++){
        u=read();
        v=read();
        w=read();
        add(u,v,w);
        add(v,u,w);
    }
    dfs(1,0);
    int __s=-1,sum=0,ans=LONG_LONG_MAX;
    for(int i=1;i<=n;i++)
        if(mark[i]) {
            __s=i;//随便选一个开始点
            dfs_dep(i,0);
        }
    memset(a,0xcf,sizeof a); //初始-inf
    memset(b,0xcf,sizeof b);
    for(int i=__s;mark[i]<=2;i=pre[i]){ //如果第3次扫到一个节点代表已经处理完了
        mark[i]++;
        if(mark[pre[i]]<2){
            a[i]=dep[i]-sum;
            b[i]=dep[i]+sum;
            //upd(1,n,i,1);
            sum+=w[i];
            if(mark[pre[pre[i]]]==2) //因为没有查询，最后建树时一次性push_up会更快
                build(1,n,1);
            continue;
        }
        a[i]=dep[i]-sum;
        b[i]=dep[i]+sum;
        sum+=w[i];
        upd(1,n,i,1);//单点修改
        ans=min(ans,qu());
    }
    if(ans<_ans) ans=_ans; //如果子树直径更长久选子树直径
    printf("%.1lf",ans*1.0/2);//答案要除以2输出
    return 0;
}
```

---

## 作者：⚡114514_zzm⚡ (赞：2)

基环树的题当然先考虑树上怎么搞，直接求个直径就完事了

现在多了个环，先把非环上的直径（设为 ans）和环上节点 x 到叶子的最大距离（设为 dis[x]）求出来

考虑到对于某种最优的方案，环上一定有某条边完全不用走

所以可以枚举断哪个边然后暴力，显然会 T 飞

考虑能够快速求出某条边断开后经过环的最大直径

预处理 A[i],B[i],C[i],D[i]

A[i] 表示从环上某个固定的起点出发到达 i 之前（包括 i） 的最长路径长度（这里路径包括到达叶子节点的路径）

这个可以通过维护起点到当前距离再加上我们之前求出的 dis 得到

B[i] 表示从环上那个固定的起点出发到达 i 之前（包括 i）的节点中某两个叶子节点之间的最长距离

这个即为 sum[i]−sum[j]+dis[i]+dis[j]，其中 sum[i] 表示起点到 i 的环上路程

移项 sum[i]+dis[i]+dis[j]−sum[j] ，动态维护当前 dis[j]−sum[j] 的最大值即可

C[i] 表示从环上终点（其实就是那个固定的起点的另一边的第一个节点）出发......（剩下的和 A[i]表示的是一样的）

D[i] 同 B[i] ，只是起点变成了终点，反过来了

那么预处理之后，枚举断边 i （注意边 i 连接 i 和 i+1）那么 t=max(B[i],D[i+1],A[i]+C[i+1]+w)

其中 w 是连接起点和终点的边的长度，那么 A[i]+C[i+1]+w 其实就是跨过起点终点的距离

最后 ans=max(ans,min(t))，注意 t 取最小值，因为断边是在最优方案下，肯定要取最小

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
typedef long long ll;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
    return x*f;
}
const int N=2e5+7;
const ll INF=1e18;
int n;
int fir[N],from[N<<1],to[N<<1],val[N<<1],cntt;
inline void add(int a,int b,int c) { from[++cntt]=fir[a]; fir[a]=cntt; to[cntt]=b; val[cntt]=c; }
bool vis[N],ring[N],GG;
vector <int> st,wt;
vector <int> q,w;
void find(int x,int fa,int ww)
{
    st.push_back(x); wt.push_back(ww); vis[x]=1;
    for(int i=fir[x];i;i=from[i])
    {
        int &v=to[i]; if(v==fa) continue;
        if(vis[v])
        {
            while(st[st.size()-1]!=v)
            {
                ring[st[st.size()-1]]=1;
                q.push_back(st[st.size()-1]);
                w.push_back(wt[wt.size()-1]);
                st.pop_back(); wt.pop_back();
            }
            ring[v]=GG=1; q.push_back(v);
            w.push_back(val[i]); return;
        }
        find(v,x,val[i]); if(GG) return;
    }
    st.pop_back(); wt.pop_back();
}
ll dis[N],ans;
void dfs(int x,int fa)
{
    for(int i=fir[x];i;i=from[i])
    {
        int &v=to[i]; if(ring[v]||v==fa) continue;
        dfs(v,x); ans=max(ans,dis[x]+dis[v]+val[i]);
        dis[x]=max(dis[x],dis[v]+val[i]);
    }
}
ll A[N],B[N],C[N],D[N];
void solve()
{
    find(1,0,0); for(auto u: q) dfs(u,u);
    ll sum=0,mx=0; int len=q.size();
    A[0]=B[0]=dis[q[0]];
    for(int i=1;i<len;i++)
    {
        mx=max(mx,dis[q[i-1]]-sum); sum+=w[i-1];
        A[i]=max(A[i-1],sum+dis[q[i]]);
        B[i]=max(B[i-1],mx+sum+dis[q[i]]);
    }
    sum=mx=0; C[len-1]=D[len-1]=dis[q[len-1]];
    for(int i=len-2;i>=0;i--)
    {
        mx=max(mx,dis[q[i+1]]-sum); sum+=w[i];
        C[i]=max(C[i+1],sum+dis[q[i]]);
        D[i]=max(D[i+1],mx+sum+dis[q[i]]);
    }
    ll res=B[len-1];
    for(int i=0;i<len-1;i++)
    {
        ll t=max(max(B[i],D[i+1]), A[i]+C[i+1]+w[len-1] );
        res=min(res,t);
    }
    ans=max(ans,res);
    printf("%lld",ans>>1);
    ans&1 ? printf(".5\n") : printf(".0\n");
}
int main()
{
    n=read(); int a,b,c;
    for(int i=1;i<=n;i++)
    {
        a=read(),b=read(),c=read();
        add(a,b,c); add(b,a,c);
    }
    solve();
    return 0;
}
```


---

## 作者：cdx123456 (赞：1)

有一个不用管基环树直径的做法，好像没人这么做，故写一篇题解。

### Solution

首先注意到选择的节点要不然在原图的点上，要不然在边上且离两端点的距离为 $0.5$ 的整数倍。

为了避免小数，将所有边权乘二，答案除以二即可。

考虑一个朴素的暴力，直接枚举所有的可能点，并求其到所有点距离的最大值，再对所有点的答案取 $\min$ 即可，复杂度 $O(n^3V)$，考虑优化。

#### Part1
先考虑选择的点在**环上某点**的情况。

设环上有 $m$ 个点，第$i$个点为 $a_i$，所选点为 $a_i$，每个节点到子树内最深的节点的距离为 $d_i$，环上两点间距离为 $dis_{i,j}$，则所选点的答案为 $\max(dis_{i,j}+d_{a_j})$。

这个 $dis_{i,j}$ 很讨厌，把 $dis$ 做成前缀形式，新的 $dis_i$ 的定义表示从环上第一个点到第 $i+1$ 个点的距离，特别的，$dis_m$ 是环的长度。

那么两点 $x,y(x \le y)$ 间的距离是 $\min(dis_{y-1}-dis_{x-1},dis_m-dis_{y-1}+dis_{x-1})$。

对编号小于 $i$ 的和大于 $i$ 的分开处理，每部分可以二分一下，$j>i$ 则求出某一段是 $dis_{j-1}-dis_{i-1}$ 还是 $dis_m-dis_{j-1}+dis_{i-1}$，否则求是$dis_{i-1}-dis_{j-1}$ 还是 $dis_m-dis_{i-1}+dis_{j-1}$，二分完后注意到答案与 $j$ 有关的要不然是 $d_{a_j}+dis_{j-1}$，要不然是 $d_{a_j}-dis_{j-1}$，直接ST表维护区间最值即可。

#### Part2

再考虑选择的点在**树上某点或边**的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/q5m8o1ts.png)

红蓝绿橙边分别是答案路径的几种可能，可以注意到答案要不然从环上一点的答案来，要不然从树上某一点到子树内最大距离或次大距离来，要不然是子树内最大距离。

那么遍历子树，维护一个 $Dis$ 变量表示到子树外节点的最长距离，更新则是 $Dis'=\max(Dis,d2_x)+w$ 或 $Dis'=\max(Dis,d_x)+w$，$d2$表示子树内次大距离，使用那个式子取决于儿子是最大还是次大，不过儿子如果是次大是没用的，所以可以不管次大的儿子，但是对复杂度没什么优化。故树上点的答案就是 $\max(Dis,d_x)$。

再看树上的边 $(x,fa_x)$，设点位于 $x$ 往上走 $k$ 的位置，那么答案是 $\min(Dis-k,d_x+k)$，显然在 $k$ 取 $\frac{Dis-d_x}{2}$ 时最优，注意要对 $0$ 取 $\max$，以及对 $w$ 取 $\min$，以保证可行性。

#### Part3

最后考虑选在**环上的边**的情况。

先考虑朴素的做法，即对于一条边 $(a_i,a_{i+1})$，枚举所选点到 $a_i$ 的长度，再仿照之前的 $Part1$ 的情况来求即可。

由于 $Part1$ 内变量较多，用数学办法可能不太好做，考虑单调性发现随着 $k$ 的增大，答案一定先变少再变多，画个图还是比较容易想到的，所以可以二分单调性或者三分，求最小值即可。

#### 总结

复杂度最高的 $Part3$ 是二分套二分套 ST 表或者三分套二分套 ST 表，复杂度 $O(n\log^2n)$。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int n,root,cnt,ans=1e18,a[N],d[N],d2[N],f[N],dis[N],vis[N],maxx1[N][21],maxx2[N][21];
vector<pair<int,int> > v[N];
stack<int> s;
void add(int x,int y,int w){
	v[x].push_back(make_pair(y,w));
	v[y].push_back(make_pair(x,w));
}
int query1(int l,int r){
	if(l>r) return -1e16;
	int len=log2(r-l+1);
	return max(maxx1[l][len],maxx1[r-(1<<len)+1][len]);
}
int query2(int l,int r){
	if(l>r) return -1e16;
	int len=log2(r-l+1);
	return max(maxx2[l][len],maxx2[r-(1<<len)+1][len]);
}
void dfs(int x,int fa){
	vis[x]=1;
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i].first;
		if(y==fa) continue;
		if(vis[y]){
			root=y;
			return;
		}
		dfs(y,x);
		if(root) return;
	}
}
void dfs2(int x,int fa){
	s.push(x);
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i].first;
		if(y==fa) continue;
		if(y==root){
			while(!s.empty()){
				a[++cnt]=s.top();
				vis[a[cnt]]=1;
				s.pop();
			}
			return;
		}
		dfs2(y,x);
		if(cnt) return;
	}
	s.pop();
}
void dfs3(int x,int fa){
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i].first,w=v[x][i].second;
		if(y==fa || vis[y]) continue;
		dfs3(y,x);
		if(d[y]+w>d[x]){
			d2[x]=d[x];
			d[x]=d[y]+w;
		}else if(d[y]+w>d2[x]) d2[x]=d[y]+w;
	}
}
void dfs4(int x,int fa,int dis){
	if(fa){
		int r;
		for(int i=0;i<v[x].size();i++){
			int y=v[x][i].first,w=v[x][i].second;
			if(y==fa) r=w;
		}
		int z=max(0ll,min(r,(dis-d[x])/2));
		ans=min(ans,max(d[x]+z,dis-z));
	}
	for(int i=0;i<v[x].size();i++){
		int y=v[x][i].first,w=v[x][i].second;
		if(y==fa || vis[y]) continue;
		if(d[y]+w==d[x]) dfs4(y,x,max(dis,d2[x])+w);
	}
}
int solve(int i,int sum,int y){
	//1~i-1
	int l=1,r=i-1,anss=i-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(dis[mid-1]>=y-dis[cnt]/2) anss=mid,r=mid-1;
		else l=mid+1;
	}
	sum=max(sum,dis[cnt]-y+query1(1,anss-1));
	sum=max(sum,y+query2(anss,i-1));
	//i+1~cnt
	l=i+1; r=cnt; anss=i+1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(dis[mid-1]<=dis[cnt]/2+y) anss=mid,l=mid+1;
		else r=mid-1;
	}
	sum=max(sum,query1(1,anss)-y);
	sum=max(sum,query2(anss+1,cnt)+dis[cnt]+y);
	return sum;
} 
signed main(){
	int x,y,w;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>w;
		add(x,y,2*w);
	}
	dfs(1,0);
	memset(vis,0,sizeof(vis));
	dfs2(root,0);
	for(int i=1;i<=cnt;i++) dfs3(a[i],0);
	for(int i=1;i<=cnt;i++){
		int x=a[i];
		for(int j=0;j<v[x].size();j++){
			int y=v[x][j].first,w=v[x][j].second;
			if(y==a[i%cnt+1]) dis[i]=w;
		}
		dis[i]+=dis[i-1];
	}
	for(int i=1;i<=cnt;i++){
		maxx1[i][0]=d[a[i]]+dis[i-1];
		maxx2[i][0]=d[a[i]]-dis[i-1];
	}
	for(int i=1;i<=20;i++){
		for(int j=1;j+(1<<i)-1<=cnt;j++){
			maxx1[j][i]=max(maxx1[j][i-1],maxx1[j+(1<<(i-1))][i-1]);
			maxx2[j][i]=max(maxx2[j][i-1],maxx2[j+(1<<(i-1))][i-1]);
		}
	}
	for(int i=1;i<=cnt;i++){
		int x=a[i];
		f[i]=solve(i,0,dis[i-1]);
		dfs4(x,0,f[i]);
		f[i]=max(f[i],d[x]);
		ans=min(ans,f[i]);
	}
	for(int i=1;i<=cnt;i++){
		int x=a[i];
		int lk=1,rk=dis[i]-dis[i-1]-1,ansk=1;
		while(lk<=rk){
			int k=(lk+rk)>>1;
			int sum1=solve(i,k+d[x],dis[i-1]+k);
			int sum2=solve(i,k+d[x]+1,dis[i-1]+k+1);
			if(sum2<sum1) ansk=k+1,lk=k+1;
			else rk=k-1;
		}
		ans=min(ans,solve(i,ansk+d[x],dis[i-1]+ansk));
	}
	printf("%.1lf",ans/2.0);
	return 0;
}
```

---

## 作者：hzx360 (赞：1)

前言：感谢管理员大大百忙中审核题解 QAQ 。
### 来发数据结构的题解
首先要知道快餐店的选址一定是在这个基环树的**直径**上（就是最长的一条链）且在其中间位置，那答案就转换为如何求直径长度。

直径有两种情况：
### 1. 不经过环
我们可以通过 tarjan 求出环上的点，然后用 DP 求出以环内每个点为根子树的最大直径（注意不要经过环）。

### 2. 经过环 

先考虑断环（很套路），枚举断掉哪条边，断环之后就变成求一颗树的直径了。

环上两个点的最短距离还要考虑逆时针还是顺时针太麻烦，将断的环形成的链直接复制一份就可以很好解决这个问题。

假设环长度为 $n$ ，那断掉一条边就等同于在 $2n$ 的序列中选出一段长度为 $n$ 连续的区间。 然后我们要做的就是在区间中选出一个**点对**，若直径经过两点则其大小为：
$$ dp_i+dp_j+dis_{i,j}$$
（其中 $dp_i$ 为情况 $1$ 得到的该点可以延伸出去的最长链）。

![](https://cdn.luogu.com.cn/upload/image_hosting/wrgs1oz3.png)

这样问题就简便多了，但是复杂度还是很高，如何优化呢？

注意到 $dis_{i,j}$ 可以用前缀和表示，即：
$$ dis_{i,j} \gets sum_j-sum_i $$
然后 直径 $(i,j)$ 变为：
$$ dp_i+dp_j+sum_j-sum_i$$
对于每个环上点设：
$$ A_i \gets dp_i+sum_i $$
$$ B_i \gets dp_i-sum_i $$

这样问题变为序列中选一段区间找到两个数使得其 $A_i+B_i$ 最大，这个可以用线段树维护吧！！！

不对，如果最大的 $A_i$ 还有 $B_i$ ，是同一个点呢？那就多维护个最大值位置和次大值呗，也就多打~~一点点~~代码然后多带个 $\log$ 吧。

#### code（不要试图复制哦 qaq ）：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e5+100;
const int inf=1e17；
int n;
int head[N],to[N],ne[N],w[N],tot;
void add(int x,int y,int z){
	ne[++tot]=head[x];
	to[tot]=y,w[tot]=z;
	head[x]=tot;
}
vector<int>g;
vector<int>edge;
int st[N],sum[N];
bool yes,vis[N],in[N];
void find_circle(int u,int fa){
	g.push_back(u),vis[u]=1;
	for(int i=head[u];i;i=ne[i]){
		if(yes) return;
		int v=to[i];
		if(v==fa) continue;
		if(vis[v]){
			int o;
			do{
				o=g.back(),g.pop_back();
				in[o]=1;
				st[++st[0]]=o;
			}while(o!=v);
			for(int j=2;j<=st[0];j++) sum[j]=sum[j+st[0]]=edge.back(),edge.pop_back();
			sum[1+st[0]]=w[i];
			yes=1;return;
		}
		edge.push_back(w[i]);
		find_circle(v,u);	
		edge.pop_back();
	}
	vis[u]=0,g.pop_back();
}
int dp[N],ans=0;
void dfs(int u,int fa){
	int mx1=0,mx2=0;
	for(int i=head[u];i;i=ne[i]){
		int v=to[i];
		if(v==fa or in[v]) continue;
		dfs(v,u);
		if(dp[v]+w[i]>mx1) mx2=mx1,mx1=dp[v]+w[i];	
		else mx2=max(mx2,dp[v]+w[i]);
	}
	dp[u]=mx1,ans=max(ans,mx1+mx2);
}
void work1(){
	for(int k=1;k<=st[0];k++){
		int u=st[k];
		dfs(u,0);
	}
}
int a[N],b[N];
#define lson o<<1
#define rson o<<1|1
struct tree{
	int l,r,mxa1,mxa2,mxb1,mxb2;//A,B的最大还有次大值
	int posa,posb;//A,B最大值的位置
}t[N];
void pushup(int o){
	if(t[lson].mxa1>t[rson].mxa1) t[o].mxa2=max(t[lson].mxa2,t[rson].mxa1),t[o].mxa1=t[lson].mxa1,t[o].posa=t[lson].posa;
	else t[o].mxa2=max(t[rson].mxa2,t[lson].mxa1),t[o].mxa1=t[rson].mxa1,t[o].posa=t[rson].posa;
	if(t[lson].mxb1>t[rson].mxb1) t[o].mxb2=max(t[lson].mxb2,t[rson].mxb1),t[o].mxb1=t[lson].mxb1,t[o].posb=t[lson].posb;
	else t[o].mxb2=max(t[rson].mxb2,t[lson].mxb1),t[o].mxb1=t[rson].mxb1,t[o].posb=t[rson].posb;
}
void build(int o,int l,int r){
	t[o].l=l,t[o].r=r;
	if(l==r){
		t[o].mxa1=t[o].mxa2=a[l];
		t[o].mxb1=t[o].mxb2=b[l];
		t[o].posa=t[o].posb=l;
		return;	
	}
	int mid=(l+r)>>1;
	build(lson,l,mid),build(rson,mid+1,r);
	pushup(o);
}
int mxa1,mxa2,mxb1,mxb2,posa,posb;
void query(int o,int l,int r){
	if(t[o].l==l and t[o].r==r){
		if(t[o].mxa1>mxa1) mxa2=mxa1,mxa1=t[o].mxa1,posa=t[o].posa;
		else mxa2=max(mxa2,t[o].mxa1);
		if(t[o].mxb1>mxb1) mxb2=mxb1,mxb1=t[o].mxb1,posb=t[o].posb; 
		else mxb2=max(mxb2,t[o].mxb1);
		return;
	}
	int mid=(t[o].l+t[o].r)>>1；
	if(r<=mid) return query(lson,l,r);
	else if(l>mid) return query(rson,l,r);
	else return query(lson,l,mid),query(rson,mid+1,r);
}
void work2(){
	int res=inf；
	for(int i=1;i<=2*st[0];i++) sum[i]+=sum[i-1],a[i]=dp[st[i>st[0]?i-st[0]:i]]-sum[i],b[i]=dp[st[i>st[0]?i-st[0]:i]]+sum[i];
	build(1,1,2*st[0]);
	for(int i=st[0];i<2*st[0];i++){
		mxa1=-inf,mxa2=-inf,mxb1=-inf,mxb2=-inf,posa,posb;
		int l=i-st[0]+1,r=i;
		query(1,l,r);
		if(posa!=posb) res=min(res,mxa1+mxb1);
		else res=min(res,max(mxa1+mxb2,mxa2+mxb1)); //注意情况要考虑全
	}
	ans=max(ans,res);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x,y,z;scanf("%lld%lld%lld",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	find_circle(1,0);
	work1(),work2();
	double ANS=(double)(ans)/2;
	printf("%.1lf",ANS);
}

---

## 作者：__ycx2010__ (赞：0)

## 思路

对于一颗树来说，重心一定在树的直径的中点。

假设基环树上点 $x$ 为树的重心，那么在环上一定存在一条没有被用到的边，即一条不存在于 $x$ 到树上任意一点最短路径上的边，我们在环上枚举这条边并将它拆掉，求一遍树的直径，于是答案就是所有直径长度求最小值再除以 $2$。

接下来的思路其他题解讲的很清楚了，这里就不说了。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1e5 + 10;
int n, len, ans, ans2;
int dp[N], s[N], ns[N], pre[N], pre2[N], suf[N], suf2[N], p1[N], p2[N];
int h[N], e[N * 2], w[N * 2], ne[N * 2], idx;
bool vis[N], c[N];
vector<int> circle, path;

void add(int a, int b, int c) {
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool find_circle(int u, int fa, int v) {
	for (int i = h[u]; ~i; i = ne[i]) {
		int ver = e[i];
		if (ver == fa) continue;
		if (ver == v) return circle.push_back(v), path.push_back(w[i]), len += w[i], c[v] = true;
		if (find_circle(ver, u, v)) {
			circle.push_back(ver);
			path.push_back(w[i]), len += w[i];
			c[ver] = true;
			return true;
		}
	}
	return false;
}

bool dfs(int u, int fa) {
	vis[u] = true;
	for (int i = h[u]; ~i; i = ne[i]) {
		int ver = e[i];
		if (ver == fa) continue;
		if (vis[ver]) {
			find_circle(ver, -1, ver);
			return true;
		} if (dfs(ver, u)) return true;
	}
	return false;
}

void dfs2(int u, int fa) {
	int dp2 = 0;
	for (int i = h[u]; ~i; i = ne[i]) {
		int j = e[i];
		if (j == fa || c[j]) continue;
		dfs2(j, u);
		if (dp[j] + w[i] > dp[u]) dp2 = dp[u], dp[u] = dp[j] + w[i];
		else if (dp[j] + w[i] > dp2) dp2 = dp[j] + w[i];
	}
	ans2 = max(ans2, dp[u] + dp2);
}

signed main() {
	scanf("%lld", &n);
	memset(h, -1, sizeof h);
	for (int i = 1; i <= n; i ++ ) {
		int a, b, c;
		scanf("%lld%lld%lld", &a, &b, &c);
		add(a, b, c), add(b, a, c);
	}
	dfs(1, -1);
	for (int i : circle) dfs2(i, -1);
	for (int i = 1; i < circle.size(); i ++ ) s[i] = s[i - 1] + path[i - 1];
	for (int i = circle.size() - 2; i >= 0; i -- ) ns[i] = ns[i + 1] + path[i];
	for (int i = 0; i < circle.size(); i ++ ) {
		if (i == 0) {
			pre[i] = dp[circle[i]] + s[i];
			pre2[i] = dp[circle[i]] - s[i];	
		} else{
		    pre[i] = max(pre[i - 1], dp[circle[i]] + s[i]);
		    p1[i] = max(p1[i - 1], dp[circle[i]] + s[i] + pre2[i - 1]);
		    pre2[i] = max(pre2[i - 1], dp[circle[i]] - s[i]);
	    }
	}
	for (int i = circle.size() - 1; i >= 0; i -- ) {
		suf[i] = max(suf[i + 1], dp[circle[i]] + ns[i]);
		if (i < circle.size() - 1) p2[i] = max(p2[i + 1], dp[circle[i]] + ns[i] + suf2[i + 1]);
		suf2[i] = max(suf2[i + 1], dp[circle[i]] - ns[i]);
	}
	ans = max(ans2, p1[circle.size() - 1]);
	for (int i = 0; i < circle.size() - 1; i ++ )
		ans = min(ans, max(ans2, max(pre[i] + suf[i + 1] + path[path.size() - 1], max(p1[i], p2[i + 1]))));
	printf("%.1lf\n", ans / 2.0);
	return 0;
}
```

---


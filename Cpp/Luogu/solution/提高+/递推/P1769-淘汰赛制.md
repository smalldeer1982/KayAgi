# 淘汰赛制

## 题目描述

淘汰赛制是一种极其残酷的比赛制度。$2^n$ 名选手分别标号 $1,2,3,\cdots,2^n-1,2^n$，他们将要参加 $n$ 轮的激烈角逐。每一轮中，将所有参加该轮的选手按标号从小到大排序后，第 $1$ 位与第 $2$ 位比赛，第 $3$ 位与第 $4$ 位比赛，第 $5$ 位与第 $6$ 位比赛……只有每场比赛的胜者才有机会参加下一轮的比赛（不会有平局）。这样，每轮将淘汰一半的选手。$n$ 轮过后，只剩下一名选手，该选手即为最终的冠军。

现在已知每位选手分别与其他选手比赛获胜的概率，请你预测一下谁夺冠的概率最大。

## 说明/提示

- $30\%$ 的数据满足 $n \le 3$；
- $100\%$ 的数据满足 $n \le 10$。

_NOI导刊 2010 提高（01）


## 样例 #1

### 输入

```
2
0 90 50 50
10 0 10 10
50 90 0 50
50 90 50 0
```

### 输出

```
 1```

# 题解

## 作者：两年打铁 (赞：11)

做完题后看了题解都是神仙打架，蒟蒻只好弱弱地说说自己的DP

### 先着眼题目中的限制，如果把赛程模拟下，就是个完全二叉树。

而且还有个非常优美的性质就是编号直接代表了节点，而且任何一个点所在的比赛都是可以分治的连续的区间。

那么我们一下就得到了状态$f[l][r][i]$表示编号在$[l,r]$的选手最终获胜者是$i$。

分治向上合并的时候只需要左右区间各枚举一个点即可。

然后我们发现内存炸了。

回到一开始的话，这是一颗完全二叉树，那么我们就多记了好多无用的$l,r$

唯一有用的$l,r$只用来表示当前分治的这一层的二叉树的区间，也就是说这一层枚举的获胜的$i$的区间是确定的。

那么我们的状态就可以改为$f[d][i]$表示在完全二叉树的深度为$d$，$i$获胜的概率，大力转移即可。

复杂度$O(n4^n)$

```
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define kong putchar(' ')
#define huan putchar('\n')
#define bug puts("QWQ")
#define pr putchar
const int big=0x7fffffff;
using namespace std;
inline void read(int &x)
{
    x=0;char ch=getchar();int pd=1;
    while(ch<'0'||ch>'9'){if(ch=='-')pd=-pd;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    x*=pd;
}
inline void write(const int &x)
{
    char ggg[100];int s=0;int tmp=x;
    if(tmp==0){putchar('0');return;}
    if(tmp<0){tmp=-tmp;putchar('-');}
    while(tmp>0){ggg[s++]=tmp%10+'0';tmp/=10;}
    while(s>0){putchar(ggg[--s]);}
}
inline void wrs(const int &x)
{
	write(x);
	putchar(' ');
}

inline void wrl(const int &x)
{
	write(x);
	putchar('\n');
}

const int N=(1<<10)+1;
double f[11][N];
int n;
double p[N][N];

void merge(int l,int r,int d)
{
	if(l==r)
	{
		f[d][l]=1;
		return;
	}
	int mid=(l+r)>>1;
	merge(l,mid,d+1);
	merge(mid+1,r,d+1);
	for(register int i=l;i<=mid;++i)
	{
		for(register int j=mid+1;j<=r;++j)
		{
			f[d][i]+=(f[d+1][i]*f[d+1][j])*p[i][j];
			f[d][j]+=(f[d+1][i]*f[d+1][j])*p[j][i];
		}
	}
}

int main()
{
	read(n);
	n=1<<n;
	int x;
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=n;++j)
		{
			read(x);
			p[i][j]=x/100.0;
		}
	}
	merge(1,n,1);
	int k=0;
	for(register int i=1;i<=n;++i)
	{
		if(f[1][i]>f[1][k])k=i;
	}
	cout<<k<<endl;
}

```


---

## 作者：John_Nash (赞：6)

对于样例，我们可以手工模拟一下：

1号选手通过第1轮（进入决赛）的概率为90%，即击败2号选手的概率。同理，2号选手通过第1轮的概率为10%，3号，4号选手都是50%。

对于3号选手通过第2轮（通过第n轮夺冠）的概率，我们可以分情况讨论。假设3号选手已经通过第1轮。如果1号选手通过第1轮（90%的可能性），则3号选手通过第2轮的概率为50%，即击败1号选手的概率，所以3号选手击败1号选手通过第2轮的概率为90%\*50%=45%；如果2号选手通过第1轮（10%的可能性），则3号选手通过第2轮的概率为90%，即击败2号选手的概率，所以3号选手击败2号选手通过第2轮的概率为10%\*90%=9%。所以3号选手击败对手通过第2轮的概率为45%+9%=54%，而这是在3号选手已经通过第1轮的基础上的概率，自然，3号选手最初时通过第2轮的概率只有50%\*54%=27%。

同理，4号选手最初时通过第2轮的概率为27%，1号选手通过第2轮的概率为45%，2号选手为1%，45%>27%>27%>1%，所以答案输出1。

通过手工模拟样例，我们可以得到这道题运用的是递推（也可以说是动态规划）的算法，设每一位选手通过这一轮的概率为这一位选手通过上一轮的概率乘上这一位选手击败这一轮遇到的每一个对手的概率之和，具体见程序注释。



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
const double Esp=0.000001;
int p[1100][1100];
double f[12][1100];
int main(){
    //freopen("p1769.in","r",stdin);
    //freopen("p1769.out","w",stdout);
    int n,m,ans;
    scanf("%d",&n);
    m=1<<n; //m为总人数 
    for(int i=1;i<=m;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&p[i][j]);
    for(int j=0;j<=m;j++)
        f[0][j]=1.0; //每一位选手通过第0轮的概率为1，因为还没有比赛，自然不会被淘汰 
    for(int i=1;i<=n;i++){
        int x=1<<i-1;
```
/\*
x表示每一组人数，如n=5,m=32,i=3，此时x=4表示每4个人中有1个人到达第3轮

当然1~4号选手中有1个人能到达第1轮，将1~4号选手看做第1组，同理，将5~8号选手看做第2组，将29~32号选手看做第8组

\*/
```cpp
        for(int j=1;j<=m;j++){
            int num1,num2;
            num1=(j+x-1)/x;
            //num1表示j号选手第i轮所在的分组，如n=5,m=32,i=3,j=25，num1=7表示25号选手第3轮在第7组（25~28号选手在第7组） 
            if(num1&1) num2=num1+1;
            else num2=num1-1;
            //num2表示j号选手第i轮所有可能的对手所在的分组，如n=5,m=32,i=3,j=25，num2=8表示25号选手第3轮可能的对手在第8组，即29~32号选手 
            double pro=0.0; //pro表示在j号选手已经通过前i-1轮的情况下，通过第i轮的概率 
            for(int k=x*(num2-1)+1;k<=x*num2;k++){ //k即为j在第i轮可能遇到的选手编号，此时为29~32 
                pro+=f[i-1][k]*p[j][k]/100;
```
/\*
f[i-1][k]表示第k个选手通过前i-1轮进入第i轮的概率

f[i-1][k]\*p[j][k]/100表示第j个选手通过击败第k个选手晋级下一轮的概率

\*/
```cpp
            }
            f[i][j]=f[i-1][j]*pro; //状态转移方程 
        }
    }
```
/\*
```cpp
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            printf("%.2lf ",f[i][j]);
        printf("\n");
    }
```
检测有无bug
输入样例时输出为

0.90 0.10 0.50 0.50

0.45 0.01 0.27 0.27

\*/
```cpp
    ans=1;
    for(int j=2;j<=m;j++)
        if(f[n][j]>f[n][ans]+Esp) //Esp保证相同概率选择编号最小的 
            ans=j;
    printf("%d\n",ans);
    return 0;
}
其实这道题也可以用递归（分治），更好理解，只是时间复杂度略高，大家有兴趣可以自己写。
```

---

## 作者：_Xiuer (赞：4)

【思路】 

这里运用了分治的思想

我们以1号为例，通过观察发现1号只会与2、3或4、5到8中的一个，也就是每个区间mid左边的部分会与大于mid的部分进行角逐，反之易得，我们获得j号在第i轮的转移方程为:
$ans(i,j)=ans(i-1,j)*p(j,k)*ans(i-1,k)$，我们通过分治处理出每个区间，在每个区间中进行转移，最后找到一个最大的 就可以啦。 

注：一定要按照题目说的转化成$double$型，否则就...... 

上代码
```cpp
#include<iostream>
#include<cstdio>
#define N 1025
#define db double
using namespace std;
int n,sum,m;
db ans[N],k,q[N],tot,p[N][N];
inline void re(int &x)
{
	x=0;
	char i=getchar();
	while(i<'0'||i>'9') i=getchar();
	while(i>='0'&&i<='9') x=(x<<1)+(x<<3)+i-'0',i=getchar();
}
inline void dfs(int s,int t)
{
	int mid=(s+t)/2;
	if(s==t)
	{
	 	ans[s]=1;
		return;
	}
	dfs(s,mid);
	dfs(mid+1,t);
	for(int i=s; i<=t; i++) q[i]=ans[i];
	for(register int i=s; i<=t; i++)
	{
		if(i<=mid)
		{
			tot=0;
			for(register int j=mid+1; j<=t; j++) 
            		tot+=q[i]*p[i][j]*q[j];
		}
		else
		{
			tot=0;
			for(register int j=s; j<=mid; j++) 	
            		tot+=q[i]*p[i][j]*q[j];
		}
		ans[i]=tot;
	}
}
int main()
{
	freopen("elimination.in","r",stdin);
	freopen("elimination.out","w",stdout);
	re(n);
	int x;
	sum=(1<<n);
	for(int i=1;i<=sum;i++) for(int j=1; j<=sum; j++)
	{
		re(x);
		if(j>i) p[i][j]=(x*1.0)/100,p[j][i]=1.0-p[i][j];
	}
	dfs(1,sum);
	for(int i=1;i<=sum;i++) 
   	if(ans[i]>k) k=ans[i],m=i;
	printf("%d",m);
	return 0;
}
```


---

## 作者：NXYorz (赞：4)

[题目](https://www.luogu.com.cn/problem/P1769)

动态规划。

用 $f(i,j)$ 表示第 $i$ 名选手在第 $j$ 轮获胜的概率。
就可以得到状态转移方程： $f(i,j)=f(i,j-1)*f(i,k-1)$。
$K$ 表示 $i$ 的对手， $k$ 不等于 $i$。

发现当前的问题就转化成了如何找到 $i$ 的第 $j$ 轮的对手。
可以把所有人划分为若干个区间，~~通俗的说就是划分赛区，然后慢慢合并赛区。~~ 观察发现一开始的区间大小为 2， 每过一轮区间扩大一倍。 由此就可以另外开一些数组动态维护了 qwq。

另$l(i)$表示当前的轮数第$i$个区间的左端点，同理，$r(i)$表示右端点。

我们还发现每一个区间里的选手所要对战的对手方向是不同的，例如$1$号区间应该对战$2$号区间的选手，相同的，$2$号区间的选手应该对战$1$号区间。

因此我们还应该维护一个数组$dir(i)$表示选手$i$所在区间的编号，我们可以根据区间编号来推断所要挑战对手的方向(向左还是向右）。

```cpp
#include<cstdio>

#define N 11

using namespace std;

int n;
int l[1025],r[1025],dir[1025];
double ans,p[1025][1025],f[1025][N];

int main()
{
	freopen("elimination.in","r",stdin);
	freopen("elimination.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=(1<<n);i++)
	{
		if(i&1) dir[i]=++dir[0];
		else dir[i]=dir[0];
		for(int j=1;j<=(1<<n);j++)
		{
			scanf("%lf",&p[i][j]);
			p[i][j]*=0.01; 
		}
	}
	l[1]=1;r[1]=2;
	for(int i=2;i<=(1<<n);i++)
	{
		l[i]=l[i-1]+2;
		r[i]=l[i]+1;
	}
	for(int i=1;i<=(1<<n);i++) f[i][0]=1;
	for(int j=1;j<=(1<<n);j++)
	{
		int com=dir[j];int i=1; 
		for(int k=l[com];k<=r[com];k++)
		{
			if(k==j) continue;
			f[j][i]+=f[k][i-1]*p[j][k];
		}
	}
	for(int i=2;i<=n;i++)//n-i+1小组
	{
		
		for(int j=1;j<=(1<<n);j++)
		{
			int com=dir[j];
			if(dir[j]&1) com=dir[j]+1;
			else com=dir[j]-1;
			for(int k=l[com];k<=r[com];k++)
				f[j][i]+=f[k][i-1]*p[j][k];
			f[j][i]*=f[j][i-1];
		}
		for(int j=1;j<=(1<<n);j++)
			//if(dir[j]!=1)
			{
				if(dir[j]%2==0)
				{
					l[dir[j]/2]=l[dir[j]-1];
					r[dir[j]/2]=r[dir[j]];
				}
				else
				{
					l[dir[j]/2+1]=l[dir[j]];
					r[dir[j]/2+1]=r[dir[j]+1];
				}
				dir[j]=dir[j]%2==0?dir[j]/2:dir[j]/2+1;
			}
	}
	int win;
	for(int i=1;i<=(1<<n);i++)
	{
		if(f[i][n]>ans)
		{
			ans=f[i][n];
			win=i;
		}
	}
	printf("%d",win);return 0;
}
```

---

## 作者：pythoner713 (赞：4)

>这道题大意就是经过某些~~玄学的~~概率运算，然后在所有选手中找一个最有可能胜出的，一开始我想太简单了，因此就有了这个50分的错误做法：

>直接模拟一遍，就是一开始一号对二号，三号对四号...然后在这两两配对中选一个胜率概率较大的进入下一局（概率相同则选择编号较小者），然后再重复上述步骤，直到最后只剩下一个人为止，那这个人就是最有可能胜出的。

>但是很明显这个思路是有问题的，假设题目给出的矩阵是

$$\begin{matrix}0 & 51 & 50 & 50\\49 & 0 & 100 & 100\\50 & 0 & 0 & 50\\50 & 0 & 50 & 0\end{matrix}$$

>按照我们的程序，一号赢二号的概率是51%，所以它会选择一号进入下一局对战三四号中的赢家。然而一号对战三四号的胜率是50，但是如果让二号上那就必胜。所以一号得冠的概率其实没有二号高，那就不应该选择一号进入下一局，所以上述方法是不可行的。

>那么如何按照正常的思路，将每个选手的胜率都算出来呢？DP时间到！根据简单的概率学我们可以得出：**i号选手进入第j轮比赛的概率=∑(i号选手活到第j-1轮的概率×对手k号选手活到第j-i轮的概率×i号选手打败k号选手的概率)**。如果DP方程描述，f[i][j]表示i号选手进入第j轮比赛的概率，那么：

$$f[i][j]=\sum_{\text{可能的对手}k}f[i][j-1]\times f[k][j-1]\times p[i][k]$$

>可是我们怎么知道i号选手可能的对手k是那些人呢？我们从最开始的情况看起：

>如果此时是第一轮比赛（还没有任何人被淘汰掉），那么如果i是奇数，那它的对手就是i+1号选手；如果i是偶数，那么它的对手就是i-1号选手。这个都挺好理解的吧。

>那么此时到了第二轮比赛，i可能的对手又是那些人呢？我们注意到第二轮比赛后就只剩下原来1/4的人，也就是说要在每四个人中选一个人进入第三轮比赛。因此我们可以把一开始的选手每四个分一组，第i个选手可能的对手就是它们组里的人。可是，因为在第一轮中，相邻的两个人必有一人淘汰，所以一名选手不可能与另一个选手比两场赛。例如第二轮中，1、2、3、4号为一组，那么一号选手的对手只能是3或4，而不能是2，因为他们俩已经打过一场了。下面是$\quad\LaTeX$演示：

$$\fbox{1\quad2}\fbox{3\quad4}\quad\fbox{5\quad6}\fbox{7\quad8}\quad\fbox{9\quad10}\fbox{11\quad12}\quad\cdots$$

>我们找一找规律，比如：可以看到7号位于第2组，它的对手是从5号与6号；12号位于第3组，它的对手是从⑨号到10号...看出规律来了吗？第i号选手可能的对手都在第$\lceil\frac{i}{4}\rceil$组，如果$(i-1)\bmod4\ge2$，那么它的对手就是$4\lceil\frac{i}{4}\rceil-3\sim4\lceil\frac{i}{4}\rceil-2$号。否则就是$4\lceil\frac{i}{4}\rceil-1\sim4\lceil\frac{i}{4}\rceil$号。

>以上就是第二轮比赛的情况，那么推广到第j轮比赛呢？那就是每$2^j$人一组啦。也就是：

>**对于第j轮比赛，第i号选手可能的对手是$2^j\lceil\frac{i}{2^j}\rceil-2^j+1$到$2^j\lceil\frac{i}{2^j}\rceil$号。**

>**1.如果$(i-1)\bmod2^j\ge2^{j-1}$，那么他的对手就是$2^j\lceil\frac{i}{2^j}\rceil-2^j+1$号到$2^j\lceil\frac{i}{2^j}\rceil-2^{j-1}$号**

>**1.如果$(i-1)\bmod2^j<2^{j-1}$，那么他的对手就是$2^j\lceil\frac{i}{2^j}\rceil-2^{j-1}+1$到$2^j\lceil\frac{i}{2^j}\rceil$号**

>~~（这公式推死我了）~~ 然后我们根据是哪种情况，设l为枚举序号的左边界，r为右边界，那么可能的对手就在l号到r号间。也就是说$l\le k\le r$，然后带入上述式子就有：

$$f[i][j]=\sum_{k=l}^{r}f[i][j-1]\times f[k][j-1]\times p[i][k]$$

>然后我们只要根据这个公式算就好啦！最后输出使得f[i][n]最大的i值就完事儿了。（对了还有一个特别坑的点，要注意百分数的转换，存矩阵p的时候不用转，算f[i][j]的时候再转成小数形式）

>萌新刚学$\LaTeX$,再加上第一次写题解，公式丑请见谅。

```cpp
#include<bits/stdc++.h>
using namespace std;

double p[1030][1030], f[1030][12];

int main(){
	int i, j, k, n, N, ans;
	double MAX = -1;
	cin >> n;
	N = 1 << n;
	for(i = 1; i <= N; i++){
		for(j = 1; j <= N; j++){
			scanf("%lf", &p[i][j]);
			p[i][j] /= 100; //注意百分数的转换 
		}
	}
	for(i = 1; i <= N; i++){
		f[i][0] = 1; //比赛还没开始大家都不会被淘汰，因此胜率是1 
	}
	for(j = 1; j <= n; j++){
		int t = (1 << j), l, r;
		for(i = 1; i <= N; i++){
			if((i - 1) % t >= t / 2){ //根据i的情况确定左右边界 
				l = t * ceil((double)i / t) - t + 1;
				r = t * ceil((double)i / t) - t / 2;
			}
			if((i - 1) % t < t / 2){
				l = t * ceil((double)i / t) - t / 2 + 1;
				r = t * ceil((double)i / t);
			}
			for(k = l; k <= r; k++){
				f[i][j] += f[i][j - 1] * f[k][j - 1] * p[i][k]; 
			}
		}
	}
	for(i = 1; i <= N; i++){
		if(f[i][n] > MAX){
			MAX = f[i][n];
			ans = i;
		}
	}
	cout << ans;
	return 0;
}
```


---

## 作者：Cesare (赞：3)

## $Solution$

有一种算是清真的 $dp$ 做法。

设 $f_{i, j}$ 表示比 $i$ 轮 $j$ 号选手存活的概率。 

转移枚举能与 $j$ 打的人，即 $j$ 向上跳 $i - 1$ 步到达的的子树的兄弟。

因为这是一棵完全二叉树，所以经过 $i$ 轮与 $j$ 比 的人在哪里都是已知的，考虑预处理这个东西，设 $g_{i, j}$ 表示 $j$ 节点向上跳 $i$ 步抵达的子树的兄弟子树，预处理暴跳即可。

内层暴跳的复杂度实质上总和只有 $O(n)$ 级别，所以复杂度 $O(n^2 2^n)$ 。

## $Code:$

```cpp
#include <bits/stdc++.h>
#define Set(x, i) memset (x, i, sizeof(x))
#define For(i, j, k) for(register int i = (j); i <= (int) (k); ++i)
using namespace std;
typedef long long ll;
const ll N = 1025;

#define dd ch = getchar()
inline ll read() {
	R ll x = 0; R int f = 0; R char dd;
	for (; !isdigit(ch); dd) f ^= (ch == '-');
	for (; isdigit(ch); dd)  x = x * 10 + (ch ^ 48);
	return f? -x: x;
}
#undef dd

inline void write ( ll x ) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x / 10); putchar(x % 10 | 48);
}

inline void wln ( ll x ) { write(x), putchar('\n'); }

namespace Cesare {
	
	const ll M = 21;
	
	ll n, m, Ans, g[M][N];
	double Mx, f[M][N], p[N][N];
	
	inline ll Jumpmelon (int i, int j) {
		int pos = 0;
		for (; pos <= m; pos += (1 << i - 1)) 
			if (pos >= j) break;
		return pos - (1 << i - 1);
	}
	
	int main() {
		n = read(), m = 1 << n;
		for (int i = 1; i <= m; ++i) 
			For ( j, 1, m ) p[i][j] = read() * 0.01;
		For ( i, 1, m ) f[0][i] = 1;
		for (int i = 1; i <= n; ++i) {
			For ( j, 1, m ) g[i][j] = Jumpmelon(i, j);
			for (int j = 0; j <= m; j += (1 << i)) 
				For ( k, 1, (1 << i - 1) ) 
					swap(g[i][j + k], g[i][j + k + (1 << i - 1)]);
		}
		For ( i, 1, n ) For ( j, 1, m ) {
			int pos = g[i][j];
			for (int k = pos + 1; k <= pos + (1 << i - 1); ++k) 
				if (j != k) f[i][j] += f[i - 1][j] * p[j][k] * f[i - 1][k];
		}
		for (int i = 1; i <= m; ++i) 
			if (f[n][i] > Mx) Mx = f[n][i], Ans = i;
		return wln(Ans), 0;
	}
	
}

int main()
{
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);

	return Cesare :: main();
}

/*
2
0 90 50 50
10 0 10 10
50 90 0 50
50 90 50 0
*/


```

---

## 作者：Uniecho1 (赞：2)

这题不难，只是说转移方式有点奇葩

居然要自己去想转移范围？？？


------------
设$Dp[i][j]$表示打完了前$i$轮，第$j$个人苟住的概率

显然有边界$Dp[0][j]=1$

考虑转移

如果我们知道这个人会和哪些人打，那么显然有
$$
Dp[i][j]=\sum_{k}Dp[i-1][j]*DP[i-1][k]*P[j][k]
$$
（当然$P[j][k]$是除了$100$的）

问题是这个$k$怎么取呢？

我们可以发现，把比赛过程建出来，就是一颗完全二叉树

所以这个$k$就是与$i$所在节点的相邻节点啦（手画一下就懂了）

然后分奇偶性讨论转移范围就行了

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;
int N,res;
double P[1050][1050],Dp[15][1050];
int main() {
	freopen("in.txt","r",stdin);
	ios::sync_with_stdio(false);
	cin>>N;
	for(int i=1; i<=(1<<N); i++)
		for(int j=1; j<=(1<<N); j++)
			cin>>P[i][j],P[i][j]/=100;
	for(int i=1; i<=(1<<N); i++)
		Dp[0][i]=1;
	for(int i=1; i<=N; i++) {
		int len=(1<<(i-1));
		for(int j=1; j<=(1<<N); j++) {
			int bl=(j-1)/len+1,l,r;
			if(bl&1) {
				l=bl*len+1;
				r=(bl+1)*len;
			}
			else{
				r=(bl-1)*len;
				l=r-len+1;
			}
			for(int k=l; k<=r; k++)
				Dp[i][j]+=Dp[i-1][j]*Dp[i-1][k]*P[j][k];
			if(i==N&&Dp[i][j]>Dp[i][res]+eps)
				res=j;
		}
	}
	cout<<res<<endl;
	return 0;
}
```

---

## 作者：渺小的Mastar (赞：2)

# 本题最易懂的线段树从下往上合并做法
这个打架过程一看就是一个的爸爸的左右儿子们打架的过程（应该不用我说了吧qwq）复杂度$O(nlog_2{n})$(或者$Ologn$我不会证qwq)，不懂的可以看一下这幅图（图源【 闪电侠的博客】,把全部编号都加加一个1就是这道题儿子们打架的过程）![](https://img-my.csdn.net/uploads/201303/22/1363927827_8915.png)

注意到他的n特别的小，于是开始乱搞线段树，（其实就是一颗递归树)，向上合并的时候暴力更新父亲的儿子们

反正套上滚动数组（套不套关系不大，反正最大也就开11个），建好树之后直接在$O(n)$的扫一次，找一次最大值就可以了^ ^

这里再补一下更新的步骤。一个人当前的活下来的概率就是  
$\sum$
(他在上一次混战中活下来的概率  
$*$他的对手在上一次混战中活下来的概率  （因为他和他的对手都要在上一次中活下来他们现在才可以打一次架  
$*$他和他的对手在这一次打架的胜率)

前两个用一个滚动数组维护
```cpp
#include <bits/stdc++.h>
using namespace std;
#define loop(a, b, c) for (register int a = b; a <= c; ++a)
#define pigs register int
#define love *
#define INF 1000000000
#define _tp template
#define _tpn typename
inline char getch()
{
    static char buf[1 << 22], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 22, stdin), p1 == p2) ? EOF : *p1++;
}
inline int read()
{
    pigs CLPig = 0, XZT = 1;
    char qwq = getch();
    while (!isdigit(qwq))
        XZT = qwq == '-' ? -1 : 1, qwq = getch();
    while (isdigit(qwq))
        CLPig = CLPig *10 + (qwq ^ 48), qwq = getch();
    return CLPig love XZT;
}
#define MAXN 1050
int n, g[MAXN][MAXN];
double f[2][MAXN];
struct node
{
    int id, son[MAXN], cnt;
} st[MAXN << 2];
void update(int o, int time)//用time是为了使用滚动数组哇ღ( ´･ᴗ･` )比心
{
    register int size = st[o << 1].cnt;
    loop(i, 1, size)
        loop(j, 1, size)//左右儿子们打架
    {
        f[time][st[o << 1].son[i]] +=
            f[time ^ 1][st[o << 1].son[i]] * f[time ^ 1][st[o << 1 | 1].son[j]] * g[st[o << 1].son[i]][st[o << 1 | 1].son[j]] / 100;
        f[time][st[o << 1 | 1].son[j]] +=
            f[time ^ 1][st[o << 1].son[i]] * f[time ^ 1][st[o << 1 | 1].son[j]] * g[st[o << 1 | 1].son[j]][st[o << 1].son[i]] / 100;
    }
    loop(i, 1, size)//更新左右儿子的同是可以顺便清空滚动数组
    {
        st[o].son[i] = st[o << 1].son[i],
        f[time ^ 1][st[o << 1].son[i]] = 0;
    }
    st[o].cnt = size << 1;
    loop(i, size + 1, st[o].cnt)//更新左右儿子的同是可以顺便清空滚动数组
    {
        st[o].son[i] = st[o << 1 | 1].son[i - size],
        f[time ^ 1][st[o << 1 | 1].son[i - size]] = 0;
    }
}
void build(int o, int l, int r, int time)
{
    if (l == r)
    {
        f[time][l] = 1, st[o].son[1] = l, st[o].cnt = 1;
        return;
    }
    int mid = l + r >> 1;
    build(o << 1, l, mid, time ^ 1);
    build(o << 1 | 1, mid + 1, r, time ^ 1);
    update(o, time);
}
int main()
{
    n = 1 << read();
    loop(i, 1, n)
        loop(j, 1, n)
            g[i][j] = read();
    build(1, 1, n, 0);
    double record = 0;
    int ans;
    loop(i, 1, n) if (f[0][i] > record)//O(n)找一次最大的
        record = f[0][i],
        ans = i;
    printf("%d", ans);
}
```

---

## 作者：chihik (赞：1)

与题目定义有些不同，$n$表示人数，$m$表示淘汰赛轮数。题目显然输入的是$m$,根据它算出$n$。为了方便2进制计算，编号从$0$~$n-1$。最后答案加1即可。同时，比赛胜败概率为了方便先除以100，用$double$计算。

现在考虑如何计算答案，设$a[i][j]$为$i$对$j$的胜率，$f[i][j]$为第$i$轮$j$胜出的概率。那么有：

$$
f[i][j]= \sum_{k} f[i-1][j] \times f[i-1][k] \times a[j][k]
$$

当然，$k$必须保证可能在第$i$轮与$j$比赛，我们可以用位运算实现。

![graph _2_.png](https://i.loli.net/2019/08/23/aoXWlJUbdrvMqmK.png)

我们会发现，在第$i$轮的比赛中，只有二进制下$i$位不同（输了的人不可能和赢的人再比一场），才有可能比赛，用位运算实现就是：

$$
( ( j >> ( i - 1 ) ) \oplus 1 ) == ( k >> ( i - 1 ) )
$$

那么，暴力转移即可，最后，统计$dp[m][i]$中的最大值，输出$i$。

```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 1 << 10;
int n , m, dex;
double f[ 15 ][ MAXN + 5 ] , a[ MAXN + 5 ][ MAXN + 5 ];

int main( ) {
    scanf("%d",&m);
    n = ( 1 << m ) - 1;
    for( int i = 0 ; i <= n ; i ++ )
        for( int j = 0 ; j <= n ; j ++ )
            scanf("%lf",&a[ i ][ j ]) , a[ i ][ j ] /= 100;
    
    for( int i = 0 ; i <= n ; i += 2 ) {
        f[ 1 ][ i ] = a[ i ][ i + 1 ];
        f[ 1 ][ i + 1 ] = a[ i + 1 ][ i ];
    }
    for( int i = 2 ; i <= m ; i ++ )
        for( int j = 0 ; j <= n ; j ++ )
            for( int k = 0 ; k <= n ; k ++ )
                if( ( ( ( j >> ( i - 1 ) ) ^ 1 ) == ( k >> ( i - 1 ) ) ) )
                    f[ i ][ j ] += f[ i - 1 ][ j ] * f[ i - 1 ][ k ] * a[ j ][ k ];
    double Ans = 0;
    for( int i = 0 ; i <= n ; i ++ )
        if( f[ m ][ i ] > Ans ) Ans = f[ m ][ dex = i ];
    printf("%d\n",dex + 1);
    return 0;
}
```


---

## 作者：SFWR (赞：1)

调了2h的题==

本题的关键就是在模拟这个比赛的形式

![](https://cdn.luogu.com.cn/upload/pic/57728.png)

略丑的模拟图

我们观察的到像最后一个1，它是由上一轮的1与2得到，我们假设在i次比赛第j个，那他就是由2*j与2*j+1得到。

再来看他的两个，姑且认为是j的儿子，这两个儿子都是属于哪一个区间？从图中可以看出，属于[（son-1）*1<<(i-1)+1,son*1<<(i-1)]

我们可以通过枚举两个儿子之间的相互比赛，得到每一个比赛者在第i轮的胜率

所以就有

```cpp
for(int i=1;i<=n;i++)
for(int j=1;j<=1<<(n-i);j++)
{cnt=1<<(i-1);s=j<<1;v=s-1;
  for(int k=(s-1)*cnt+1;k<=s*cnt;k++)
  for(int l=(v-1)*cnt+1;l<=v*cnt;l++)
  {
   f[i][k]+=(f[i-1][k]*bl[k][l]/100*f[i-1][l]); 
   f[i][l]+=(f[i-1][k]*bl[l][k]/100*f[i-1][l]); }   
}
```
最后的时候扫一遍f[n][i]就可以得到了。

还是很有意思的一道题

附代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,bl[2050][2050],flg,m,cnt,s,v;
const double Esp=0.000001;
double f[11][2050],ma=-1;
int main()
{
    cin>>n;	m=1<<n;
    for(int i=1;i<=m;i++)for(int j=1;j<=1<<n;j++)cin>>bl[i][j];
    for(int i=1;i<=m;i++)f[0][i]=1;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=1<<(n-i);j++)
    {	    cnt=1<<(i-1);
            s=j<<1;v=s-1;
            for(int k=(s-1)*cnt+1;k<=s*cnt;k++)
            for(int l=(v-1)*cnt+1;l<=v*cnt;l++)
            {
            	f[i][k]+=(f[i-1][k]*bl[k][l]/100*f[i-1][l]); 
            	f[i][l]+=(f[i-1][k]*bl[l][k]/100*f[i-1][l]); 
			}   
    }
    for(int k=1;k<=m;k++)if(f[n][k]>ma+Esp){ma=f[n][k];flg=k;}
    cout<<flg;}
```




---

## 作者：Boxxxxxx (赞：0)

[博客链接](https://blog.csdn.net/qq_43804974/article/details/103850679)

这题乍一看很吓人，实则当你去手画一下比赛过程的时候就可以知道了，假设总人数有8人，1， 2 ， 3 ， 4 ， 5 ， 6 ，7 ，8.

题目说了每一轮都是按编号顺序从小到大去比赛的那么第一轮就是(1,2),(3,4),(5,6),(7,8).这么个比赛顺序，第二轮就是(1,2)的胜利者去比(3,4)的胜利者（另外两个同理）。这个比赛的过程在我刚刚接触这个题的时候我想的是线段树的过程，但是是一个十分完美的区间划分，线段树可能会有(1,3)区间去分开变成(1,2)和（3)的情况，但是这里不会。利用线段树的这个过程我们就可以十分完美的去模拟出这个比赛的过程。接下来考虑我们要怎么得到答案，我先说我一开始想的错误的想法，我最初为了避免小数运算，选择了把胜率当做权值去做，90%概率我就拿90分，然后去计算每个人获胜的总权值去比较大小，但是算权值的时候我用的也是加法，没去想乘法，所以一顿瞎鸡儿操作30分。。。。。

（暴躁改几次还是没用选择打开了题解233333）正确的应该是这样子的我们和线段树一样f[i]，i这个节点就代表了一个区间范围[L,R],然后我们在开一维度j表示这个区间内的胜者。f[i][j]的值就代表了j这个人在这个区间获胜的概率。要怎么算呢？首先j这个人是在左边区间来的还是右边区间来的我们可以知道，我们按他在左边儿子（区间）来的，（在右边的同理）。那么这个j节点就是在[L , mid]的区间的胜者，我们用他这个节点是这个区间的胜者的概率f[i * 2][j]去与右区间的每一个胜者获胜的概率去乘上j打赢他们的概率
f[i][j] = sum(f[i*2][j] * f[i * 2 + 1][k]),k就代表了右边区间的所有可能获胜的人。

这个式子其实就是一个人在这个区间获胜是概率是在**原本所在区间获胜的概率**在去分别乘上**要赢另一个区间那个获胜的人的概率** 在乘上**另一个区间那个获胜的人要在她所在原本区间要获胜的概率**，有点小饶，在多看两遍。

这样就做完收工了，最后统计[1,R]区间每个人的胜率去得答案就好了。代码上面头文件快读什么的多了点，实则代码还是挺短的。

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<time.h>
#include<string>
#include<cmath>
#include <ctime>
#include<bitset>
#include <cctype>
#define debug cout<<"*********degug**********";
#define int long long
#define RE register
#define yn yn_
using namespace std;
const long long max_ = 1500 + 7;
const int mod = 1e9 + 7;
const int inf = 1e9;
const long long INF = 1e18;
int read() {
	int s = 0, f = 1;
	char ch = getchar();
	while (ch<'0' || ch>'9') {
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0'&&ch <= '9') {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s * f;
}
inline int min(int a, int b) {
	return a < b ? a : b;
}
inline int max(int a, int b) {
	return a > b ? a : b;
}
int quick_pow(int x, int n) {
	int res = 1;
	while (n > 0) {
		if (n & 1)	res = res * x;
		x = x * x;
		n >>= 1;//相当于n=n/2.详情请参考位移运算符。
	}
	return res;
}
int n, stander; double f[max_ * 4][max_], nodee[max_][max_];
void update(int node, int L, int R) {
	if (L == R) {
		f[node][L] = 1.0;
		return;
	}
	int mid = (L + R) / 2, L_tree = node * 2, R_tree = node * 2 + 1;
	update(L_tree, L, mid); update(R_tree, mid + 1, R);
	for (int i = L; i <= mid; i++) {
		double t = 0.0;
		for (int j = mid + 1; j <= R; j++) {
			t = t + f[R_tree][j] * nodee[i][j] * f[L_tree][i];
		}
		f[node][i] = t;
		//	printf("[%d,%d]的%d取得胜利的分数:%d\n", L, R, i, f[node][i]);
	}
	for (int i = mid + 1; i <= R; i++) {
		double t = 0.0;
		for (int j = L; j <= mid; j++) {
			t += f[L_tree][j] * nodee[i][j] * f[R_tree][i];
		}
		f[node][i] = t;
		//printf("[%d,%d]的%d取得胜利的分数:%d\n", L, R, i, f[node][i]);
	}
}

signed main() {
	n = read();
	stander = quick_pow(2, n);
	for (int i = 1; i <= stander; i++) {
		for (int j = 1; j <= stander; j++) {
			int t = read();
			nodee[i][j] = t / 100.0;
			//if (i != j && nodee[i][j] == 0)nodee[i][j] = -inf;
		}
	}
	update(1, 1, stander);
	double ansvalue = 0; int ans = 122345;
	for (int i = 1; i <= stander; i++) {
		if (f[1][i] > ansvalue) {
			ansvalue = f[1][i];
			ans = i;
		}
		else {
			if (f[1][i] == ansvalue && ans > i)ans = i;
		}
	}cout << ans;
	return 0;
}
```



---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P1769)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实也没什么可分析的。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把图画一下，就可以想到如下的状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(j,i)$：第$i$位选手经过$j$场比赛后成为获胜者的概率。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移就是枚举在第$j$场上的对手，然后算概率。设$op(j,i)$为第$j$场上第$i$个人可能遇到的对手的集合，那么转移长这样：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(j,i)=DP(j-1,i)\times\sum_{k\in op(j,i)}DP(j-1,k)\times P(i,k)$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而不难发现$op$这个集合其实是连续的一段选手，所以直接找规律算出来就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码中是直接枚举的对阵，然后把对手和自己的概率都累加上去。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间嘛......大概是$O(2^{2n}\times n)$，但是常数非常的小。  
# 代码
```cpp
#include <cstdio>

const int MAXN = 15, MAXSIZ = ( 1 << 10 ) + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

double P[MAXSIZ][MAXSIZ];
double DP[MAXN][MAXSIZ];
int N, lim;

int main()
{
	read( N );
	lim = 1 << N;
	for( int i = 1 ; i <= lim ; i ++ )
	{
		for( int j = 1 ; j <= lim ; j ++ )
		{
			scanf( "%lf", &P[i][j] );
		}
	}
	for( int i = 1 ; i <= lim ; i ++ )
	{
		DP[0][i] = 100;
	}
	for( int j = 1 ; j <= N ; j ++ )
	{
		for( int i = 1 ; i <= lim ; i += 1 << j )
		{
			for( int l = i ; l < i + ( 1 << ( j - 1 ) ) ; l ++ )
			{
				for( int r = i + ( 1 << ( j - 1 ) ) ; r < i + ( 1 << j ) ; r ++ )
				{
					DP[j][l] += DP[j - 1][r] * P[l][r] / 100;
					DP[j][r] += DP[j - 1][l] * P[r][l] / 100;
				}
			}
			for( int k = i ; k < i + ( 1 << j ) ; k ++ )
			{
				DP[j][k] *= DP[j - 1][k];
				DP[j][k] /= 100;
			}
            //除以100其实没啥用，就是为了让概率长得像百分数的整数部分
		}
	}
	int maxIndx = -1;
	for( int i = 1 ; i <= lim ; i ++ )
	{
		if( maxIndx == -1 || DP[N][maxIndx] < DP[N][i] ) maxIndx = i;
	}
	write( maxIndx ), putchar( '\n' );
	return 0;
}
```

---

## 作者：木木！ (赞：0)

用dp的思路，如果用`dp[i][k]`表示第`i`个人活到第`k`轮的概率是多少，`win[i][j]`表示第`i`个人打败第`j`个人的概率为多少，就可以推出式子：

```
对于每一个i的对手j，dp[i][k] += win[i][j]*dp[i][k-1]*dp[j][k-1] 
```

理解很简单，如果`i`打败了`j`活到第`k`轮，则`i`和`j`都活到了第`k-1`轮，并且`i`赢了`j`

然后就是要找到`i`的在第`k`轮的直接对手

我们发现，如果从`0`开始编号，`i`在第一轮的直接对手是`i^1`，在第二轮的直接对手是`i^2`和`i^3`，就可以大胆推测：`i`在第三轮的直接对手是`i^4` `i^5` `i^6` `i^7`

列一下表，发现果然这样，第`i`个人在第`k`轮的直接对手是`i`异或$2^{k-1}$到$2^k-1$

放核心代码段

```cpp
for(int k=1; k<=n; ++k)
{
	for(int i=0; i<tn; ++i)
	{
		for(int j=1<<(k-1); j<1<<k; ++j)
		{
			dp[i][k] += win[i][i^j]*dp[i][k-1]*dp[i^j][k-1];
		}
	}
}
```

---

## 作者：NOILinux_Ubuntu (赞：0)

一道较为蛋疼的概率DP题

主要是在分析DP方程

我们需要理清一下思路，一步一步来

首先～～

第一轮，有
	$$ dp_1=p_{1,2},\ dp_2=p_{2,1},\ dp_3=p_{3,4},\ dp_4=p_{4,3}\ \ ...\ ...$$
    
    
第二轮，有
	$$ dp_1=dp_1\times(dp_3\times p_{1,3}+dp_4\times p_{1,4}),\ dp_2=...\ ...$$
    
到了这里，dp方程基本出来了

对于每一轮，$dp_i=dp_i\times(\sum dp_j\times p_{i,j})$，其中j是i在这一轮的对手

方程处理完了，接下来就是准确的找到$i$在每一轮的对手了。

分析可知，比赛赛制是一棵满二叉树，而$i$点在第$k$轮的对手就是第$i$片叶子第$j$级祖先的另一棵子树中的叶子节点。

将这棵二叉树从左至右，从上至下编号，那么$1\sim 2^n$被编号为$2^n\sim 2^{n+1}-1$，写过线段树的知道若$i>>k=j>>k$，$i$和$j$第$k$级祖先相同。

考虑维护一个$vis$数组，对于每个$i$，循环找一个$j$满足$i>>k=j>>k$，且$vis_{i,j}=0$，并加入答案

至此，dp方程及转移已经分析完了，时间复杂度$O(n*2^n*2^n)$，已经可以通过此题，但在找对手的地方明显浪费了很多时间，感兴趣的同学可以继续往下看。

------------

首先我们要认识到，每一个人对同一个人只会计算一次，所以理论复杂度可以达到$O(n*2^n+2^n*2^n)$

如果我们维护一个$fa_i$数组，表示第$i$片叶子已经跳到了哪级祖先。

由于满二叉树的严整性，对于编号为$k$的节点，它的直接儿子为$2k$和$2k+1$，它的叶子节点是连续的一段区间，所以考虑$O(2^n)$求出$k$的叶子节点区间，代码实现为
```cpp
	//m=pow(2,n);预处理叶子节点L[i]=R[i]=i;
	int x=m,y=(m<<1)-1;
	For(i,1,n){
		y=x-1;x>>=1;
		For(j,x,y)L[j]=L[j<<1],R[j]=R[j<<1|1];
	}
```

那么在第$k$轮时，对于第$i$个叶子节点，不用循环找对手了，L[$fa_i$^$1$]和R[$fa_i$^$1$]就是对手区间。

于是优化完毕,在洛谷新评测机下最慢点21ms，rank1 36ms，但是好像不是最快的，我前面有个神仙20ms，思路好像和我的差不多，鉴于已经霸版了，就不继续~~卡常~~优化了

ps:把$2^n$想成1000的我还有救吗qaq

```cpp#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cctype>
using namespace std;
#define ri register int
#define For(i,a,b) for(ri i=(a);i<=(b);++i)
#define DFor(i,a,b) for(ri i=(a);i>=(b);--i)
template<class T>inline T Max(register T a,register T b){return a>b?a:b;}
template<class T>inline T Min(register T a,register T b){return a<b?a:b;}
template<class T>inline T Abs(register T x){return x>0?x:-x;}
const double eps=1e-9;
int n,m,M;
int fa[2055],L[2055],R[2055];
double dp[2055],g[2055],a[1055][1055];
template<class T>inline void read(T&x){
  char ch=getchar();x=0;
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
}
inline void prework(){
	For(i,m,M)dp[i]=1,fa[i]=i,L[i]=R[i]=i;
	int x=m,y=M;
	For(i,1,n){
		y=x-1;x>>=1;
		For(j,x,y)L[j]=L[j<<1],R[j]=R[j<<1|1];
	}
}
int main(){
	read(n);m=pow(2,n);M=(m<<1)-1;
	int x;
	For(i,1,m)
	  For(j,1,m)read(x),a[i][j]=x/100.0;
	prework();
	For(i,1,n){
	  For(j,m,M)g[j]=0;
	  For(j,m,M)
		For(k,L[fa[j]^1],R[fa[j]^1])g[j]+=dp[k]*a[j-m+1][k-m+1];
	  For(j,m,M)dp[j]*=g[j],fa[j]>>=1;
	}
	double ans=0;
	For(j,m,M)ans=Max(ans,dp[j]);
	For(j,m,M)if(Abs(ans-dp[j])<eps){printf("%d\n",j-m+1);return 0;}
 return 0;
}

```

---


# 遥控车

## 题目描述

平平带着韵韵来到了游乐园，看到了 $n$ 辆漂亮的遥控车，每辆车上都有一个唯一的名字 name[i]。韵韵早就迫不及待地想玩名字是 $s$ 的遥控车。可是韵韵毕竟还小，她想象的名字可能是一辆车名字的前缀（也就是说能确定一个 $i$，使 $s$ 是 name[i] 的前缀），这时她就能玩第 $i$ 辆车；或者是一个无中生有的名字，即 $s$ 不是任何一辆车名字的前缀，这时候她什么也不能玩。

你需要完成下面的任务：

1. 韵韵想了 $m$ 个她想要的名字，请告诉她能玩多少次。

2. 由于管理员粗心的操作，导致每辆车的摆放位置都可能出现微小的差错，原来第 $i$ 辆车现在的位置可能是 $i-1$ 、 $i$ 、 $i+1$ 中的任意一个（第 $1$ 辆车的位置不可能是 $0$，第 $n$ 辆车的位置不可能是 $n+1$）。请你计算出共有多少种可能的排列。

注：数据保证当 $s$ 是 name[i] 的前缀时，$i$ 是唯一确定的。一辆车可以玩多次。

## 说明/提示

【注意】

对于题目涉及到的字符串严格区分大小写，且长度小于 $255$。

【数据范围】

对于 $20\%$ 的数据 $n \le 10,m \le 10$；

对于 $40\%$ 的数据 $n \le 1000$，$m \le 1000$；

对于 $100\%$ 的数据 $n \le 10000$，$m \le 10000$。

## 样例 #1

### 输入

```
4 4
Abcd
DeF
AAa
aBccc
Ab
AA
AbC
aBcc```

### 输出

```
3
5
```

# 题解

## 作者：jyz666 (赞：10)

# 题解 P2030 【遥控车】

[传送门](https://www.luogu.com.cn/problem/P2030)

------------

蒟蒻又来写题解了，~~只能交交蓝题题解这样生活了（泪）~~。

一看这题，一开始有些懵~~阿巴阿巴~~。
分成两问来看：

**第一问，字符串的简单运用；**

我们先把所有的车的名字排序（$sort$大法好）。

因为 题目中有说 "**数据保证当$s$是$name[i]$的前缀时，$i$是唯一确定的**"。

这句话很重要，这说明$s$不可能是一个以上的名字的前缀。

给我们的信息是，这题使用二分答案，而不是二分出上下界（所以要很注意题目的用词）。

**第二问，n-1的高精度斐波那契数列。**

先是一本正经列了一个$2$维$dp$如下：

$f[i][j]$ = $f[i$−$1]$$[j]$+$f[i$−$2][j$−$1]$

$f[i][j]$表示前$i$辆车有$j$辆和右边交换位置。

因为和右边换等同于和左边换所以不作考虑。然后你就会发现$j$是个酱油,设$g[i]$表示前i辆车的总方案数，则

$g[i]$=$g[i$−$1]$+$g[i$−$2]$

这是什么$?$是斐波那契数列$!!$

而且，由于数据大，要打高精度哦。

### 上代码》》

```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
#define maxn 50010
#define inf 0x3f3f3f3f
const int mod=100003;

void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
string s[maxn],na[maxn];
int n,m,len,ans,a[maxn],b[maxn],c[maxn];
void big_jia(){//高精加 
	memset(c,0,sizeof(c));
	for(int i=1;i<=len;i++){
		c[i]+=a[i]+b[i];
		if(c[i]>=10){
			c[i+1]+=c[i]/10;
			c[i]%=10;
		}
	}
	while(c[len+1])len++;
	for(int i=1;i<=len;i++)a[i]=b[i];
	for(int i=1;i<=len;i++)b[i]=c[i];
}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++)cin>>s[i];
	a[1]=1;b[1]=2,len=1;
	for(int i=3;i<=n;i++){
		big_jia();
	}
	sort(s+1,s+n+1);
	for(int i=1;i<=m;i++){
		cin>>na[i];
		int pos=lower_bound(s+1,s+n+1,na[i])-s;
		if(!s[pos].find(na[i],0))ans++;
	}
	cout<<ans<<endl;
	for(int i=len;i;i--)cout<<c[i];
	return 0;
}
```
 _**強さに欠けているのではなく　意志が足りていないので**_ 

---

## 作者：lihongqian__int128 (赞：3)

考虑将两个问题分开来解答。

**第一问：**

简述：求有多少个字符串的前缀为 $s$。

实现：开 $255$ 个 `map` 存每个字符串每种长度的前缀的哈希值，求答案时查一下即可。

**第二问：**

定义 $f_i$ 为考虑前 $i$ 辆车的排列数。如何转移呢？

若第 $i$ 辆车不动，答案为 $f_{i-1}$。

若第 $i$ 辆车被换动，则一定与它之前的那一辆车交换（还没有它后面的那一辆车）。将最后两辆车抛去，答案为 $f_{i-2}$。

所以，$f_i\gets f_{i-1}+f_{i-2}$。

然后高精即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[5005] , y[5005] , z[5005] ;
string operator +(string a , string b)
{
	string c ;
	for(int i = a.size() - 1 , j = 1 ; i >= 0 ; i-- , j++)
		x[j] = a[i] - '0' ;
	for(int i = b.size() - 1 , j = 1 ; i >= 0 ; i-- , j++)
		y[j] = b[i] - '0' ;
	int len = max(a.size() , b.size()) ;
	for(int i = 1 ; i <= len ; i++)
		z[i] = 0 ;
	for(int i = 1 ; i <= len ; i++)
	{
		z[i] += x[i] + y[i] ;
		z[i + 1] += z[i] / 10 ;
		z[i] %= 10 ;
	}
	if(z[len + 1] > 0)	len++ ;
	for(int i = len ; i > 0 ; i--)
		c += char(z[i] + '0') ;
	return c ;
}
using ull=unsigned long long;
ull string_hash(string t){
	ull s=0;
	for(int i=0;i<t.size();i++)s=s*131+t[i];
	return s;
}
unordered_map<ull,int>h[260];
int n,m;
string s;
string f[10005];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>s;
		ull hs=0;
		for(int j=0;j<s.size();j++)hs=hs*131+s[j],h[j+1][hs]++;
	}
	int ans=0;
	for(int i=1;i<=m;i++)cin>>s,ans+=h[s.size()][string_hash(s)];
	cout<<ans<<'\n';
	f[1]="1",f[2]="2";
	for(int i=3;i<=n;i++)f[i]=f[i-1]+f[i-2];
	cout<<f[n];
	return 0;
}
```

---

## 作者：_Chesed_ (赞：3)

# [P2030 遥控车](https://www.luogu.com.cn/problem/P2030)
## 题目大意
给定一个含有 $n$ 个字符串的字符串集，$m$ 个询问，每次询问是否在字符串集中有字符串前缀为要求字符串。字符串集中第 $i$ 个字符串的位置可能是 $i-1,i,i+1$（下标不能低于 $1$ 和高于 $n+1$）。求共有多少种可能的排列。
## 分析
题目有两个问，分开求解。
### Problem 1
前缀匹配问题，对于多次求字符串前缀匹配有以下几种优化方法：

1. 对主串数组进行快排后，采用二分查找与匹配串比较。时间复杂度 $O(M \log N)$。
2. 采用字符树（trie）进行主串记录，之后匹配。
3. 将主串数组与匹配串数组进行排序，之后进行线性扫描。

大多时候 法3 很快，特别是匹配串很多时，但 法3 限制条件较多，要求匹配串只能匹配一个主串，本题规定匹配前缀唯一确定,因此可以使用。而在大多数题目下使用 法1 和 法2 实现，这也是其他题解所讲的方法。

但是，上述办法代码实现都比较困难，那么可以考虑暴力，令 $len$ 为所求字符串平均长度，时间复杂度为不严格的 $O(NMlen)$，代码也十分简单，可以实现。

### Problem 2
第二个问题，20 分的做法是暴力枚举。

不过我们发现，对于一个 $i$ 只有两种做法，第一种是放在第 $i$ 位，第二种是放在第 $i-1$ 位，也就是：

$$f[i]=f[i-1]+f[i-2]$$

很明显，这是一个斐波那契数列，初始值为 $f[1]=1,f[2]=2$。

数据范围 $n\le 10000$，需要高精度，采用滚动存储即可。

## Code（AC）

```cpp
#include<bits/stdc++.h>
#define MAXN 10005
const int mod=1e9+7;
using namespace std;
namespace rnfmabj{
string s[MAXN];
int f1[MAXN],f2[MAXN];
void add(int a[],int b[]){//高精度
	int flag[MAXN];
	flag[0]=max(a[0],b[0]);
	for(int i=1;i<=flag[0];i++){
		flag[i]=a[i]+b[i];
	}
	for(int i=1;i<=flag[0];i++){
		flag[i+1]+=flag[i]/10;
		flag[i]%=10;
	}
	if(flag[flag[0]+1]) flag[0]++;
	for(int i=0;i<=b[0];i++) a[i]=b[i];
	for(int i=0;i<=flag[0];i++) b[i]=flag[i];
}
void print(int a[]){//高精度输出
	if(a[0]==0){
		printf("0");
		return;
	}
	for(int i=a[0];i>=1;i--){
		printf("%d",a[i]);
	}
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		cin>>s[i];
	}
	int ans=0;
	for(int i=1;i<=m;i++){//暴力求解
		string a;
		cin>>a;
		int len=a.size();
		for(int j=1;j<=n;j++){
			int flag=0;
			for(int k=0;k<len;k++){
				if(a[k]!=s[j][k]){
					flag=1;
					break;
				}
			}
			if(flag==0) ans++;
		}
	}	
	f1[1]=f1[0]=f2[0]=1;
	f2[1]=2;
	for(int i=3;i<=n;i++){
		add(f1,f2);//高精度加法
	}
	printf("%d\n",ans);
	print(f2);
	return 0;
}
}
int main(){
	rnfmabj::main();
	return 0;
} 
//3MB
```
[甚至跑的挺快](https://www.luogu.com.cn/record/123076622)

---

## 作者：zhangchengkai (赞：2)

普及一下c++中的string类~

由于string重载了'>','<','=='等比较运算符，故可以直接比较，以至于可以直接排序sort；

我们二分找答案，解决第一问；

第二问就上高精，注意用循环数组！

至于要在输出前补‘0’可以这样printf("%0xd",a);x为这个数有几位，如x=8时printf("%08d",a);

高精写得有点丑~见谅

```cpp
#include<cstdio>
#include<string>
#include<iostream>//输入要用cin>>
#include<algorithm>
using namespace std;
const int N=100000000;//压8位加快运算速度
int n,m,ans=0;
string a[10001],b;
int c[3][10001];
bool ck(void)
{
    int l=1,r=n;
    while(l<r-1)//二分，注意留出范围防止答案被误判
    {
        int m=(l+r)>>1;
        if(a[m]<b) l=m+1;//前缀一定>=原字符串
        if(a[m]>=b) r=m;
    }
    for(int i=l;i<=r;i++) for(int j=0;j<b.size();j++)//暴力比较
    {
        if(a[i][j]!=b[j]) break;
        if(j==b.size()-1) return 1;
    }
    return 0;
}
int main()
{
    scanf("%d%d\n",&n,&m);
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+1+n);//排序
    for(int i=1;i<=m;i++)
    {
        cin>>b;
        if(ck()) ans++;
    }
    printf("%d\n",ans);
```
/\*以下高精递推，c[i][0]为长度\*/
```cpp
    c[1][0]=1;
    c[1][1]=1;
    c[2][0]=1;
    c[2][1]=2;
    for(int i=3;i<=n;i++)
    {
        for(int j=1;j<=c[i%3][0];j++) c[i%3][j]=0;
        for(int j=1;j<=c[(i+2)%3][0];j++)
        {
            c[i%3][j]+=c[(i+2)%3][j]+c[(i+1)%3][j];
            if(c[i%3][j]>N)
            {
                c[i%3][j+1]+=c[i%3][j]/N;
                c[i%3][j]%=N;
            }
        }
        c[i%3][0]=c[(i+2)%3][0];
        if(c[i%3][c[i%3][0]+1]!=0) c[i%3][0]++;
    }
    printf("%d",c[n%3][c[n%3][0]]);
    for(int i=c[n%3][0]-1;i>=1;i--) printf("%08d",c[n%3][i]);
    return 0;
}
```

---

## 作者：KukCair (赞：2)

#### 第一问（~~怎么都用二分？怎么都用二分？怎么都用二分？~~）

用哈希 + unordered\_map 秒了。

建议不要用 map，实测超慢。

#### 第二问

打个表你会发现是斐波那契数列，但是具体为什么？

设 $f_i$ 为以第 $i$ 辆车结尾的可能排列数。

可以发现放错了就是交换相邻两个车，然后我们对于最后一个车分讨一下。

- 原地不动，那么继承 $f_{i-1}$ 的值。

- 与上一个交换，那么只有前 $i-2$ 个要排，继承 $f_{i-2}$ 的值。

所以得 $f_i = f_{i-1} + f_{i-2}$。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long base = 13331;
long long n, m, cnt, h[100005];
unordered_map<long long, bool> mp;
string jia(string a , string b){
	string c = "";
	int x[10005] = {} , y[10005] = {} , z[10005] = {};
	for(int i = a.size() - 1, j = 1; i >= 0; i--, j++)x[j] = a[i] - '0';
	for(int i = b.size() - 1, j = 1; i >= 0; i--, j++)y[j] = b[i] - '0';
	int len = max(a.size(), b.size());
	for(int i = 1; i <= len; i++){
		z[i] += x[i] + y[i];
		z[i + 1] += z[i] / 10; 
		z[i] %= 10;
	}
	if(z[len + 1] > 0) len++;
	for(int i = len; i >= 1 ; i--) c += char(z[i] + '0');
	return c;
}
string dp[100005];
int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		string s;
		cin >> s;
		for(int j = 0; j < s.size(); j++){
			h[i] = h[i] * base + s[j];
			mp[h[i]] = 1;
		}
	}
	for(int i = 1; i <= m; i++){
		string s;
		cin >> s;
		long long x = 0;
		for(int j = 0; j < s.size(); j++){
			x = x * base + s[j];
		}
		if(mp.count(x)) cnt++;
	}
	cout << cnt << '\n';
    dp[0] = dp[1] = "1";
    for(int i = 2; i <= n; i++){
        dp[i] = jia(dp[i - 1], dp[i - 2]);
    }
	cout << dp[n];
	return 0;
}
```

---

## 作者：MloVtry (赞：1)

欸欸欸没有题解？

那就厚颜无耻的来一发

对于第一问，因为问题保证前缀对应的车子只有一个

那么我们可以排个序，然后二分查找

对于第二问呢

那是一个斐波那契数列，当然，f[1]=1,f[2]=2

因为n挺大的要用高精，当然习惯性的压了个位

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10010
#define mod 10000
using namespace std;
int n,m,ans;
string a[N];
int f[10000],b[10000],c[10000];
int fw,bw,cw;
bool can(int now,string d)
{
    int zz=d.size();
    for(int i=0;i<zz;++i)
    {
        if(a[now][i]>d[i]) return true;
        if(a[now][i]<d[i]) return false;
    }
    return true;
}
void find(string d)
{
    int l=1,r=n;
    while(l<=r)
    {
        int ans=(l+r)>>1;
        if(can(ans,d)) r=ans-1;
        else l=ans+1;
    }
    int zz=d.size();
    int fl=1;
    for(int i=0;i<zz;++i)
    {
        if(a[l][i]!=d[i]) fl=0;
    }
    if(fl) ans++;
}
void turn()
{
    int to=max(bw,fw);
    int pre=0;
    for(int i=1;i<=to;++i)
    {
        c[i]=f[i]+b[i]+pre;
        pre=c[i]/mod;
        c[i]%=mod;
    }
    cw=to;
    if(pre) c[++cw]=pre;
}
void get_f(int n)
{
    if(n==1)
    {
        cout<<1;
        return;
    }
    if(n==2)
    {
        cout<<2;
        return;
    }
    f[++fw]=1;b[++bw]=2;
    for(int i=3;i<=n;++i)
    {
        turn();
        for(int j=1;j<=bw;++j)
        {
            f[j]=b[j];
        }
        fw=bw;
        for(int j=1;j<=cw;++j)
        {
            b[j]=c[j];
        }
        bw=cw;
    }
    cout<<c[cw--];
    for(int i=cw;i>=1;--i)
    {
        printf("%04d",c[i]);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=m;++i)
    {
        string d;cin>>d;
        find(d);
    }
    cout<<ans<<endl;
    get_f(n);
    return 0;
}
```

---

## 作者：__Deng_Rui_Song__ (赞：1)

# preface

咦？没有题解，~~水一发~~

# problem

[题目传送门](/problem/P2030)

# solution

看到题解区全都是二分查找啊，~~我也不例外~~。

## problem 1

要判断给定字符串是不是给定字符串数组中的一个字符串的前缀，那肯定用……

你：字典树！

错！看看数据范围，$n\le10^4,|S|<255$，字母也有 $52$ 个，算一下内存：$10^4\times254\times52\approx10^8$，直接炸了，用什么呢？

你：哈希！

可以，但是本篇题解介绍的是另一种做法，**二分查找**！*对字符串数组排序，然后使用 c++ 自带函数 lower\_bound 轻松解决*！

~~你：@##%\$#^#\$\$!@\$\$@%*&&^#@%\$\*\*&^@!\$\$@!\$^^\*。~~

## problem 2

可以发现，两个问题是独立的。

对于这种问题，有两种做法：

- 组合数直接算！但这道题好像很难推式子，跳过。

- 递推！考虑状态 $dp_{i,0/1}$ 表示前 $i$ 个且第 $i$ 个跟不跟上一个交换的总方案数！

你：答案就是 $dp_{n,0}+dp_{n,1}$！

没错，状态转移方程为：

$$dp_{i,0}=dp_{i-1,0}+dp_{i-1,1}$$

$$dp_{i,1}=dp_{i-2,0}+dp_{i-2,1}$$

你：嗯？不对劲！把它们合成一下，不就是 $dp_i=dp_{i-1}+dp_{i-2}$ 吗？

没错！它就是~~肥波垃圾~~**斐波那契数列**！

~~你：@##%\$#^#\$\$!@\$\$@%*&&^#@%\$\*\*&^@!\$\$@!\$^^\*。~~

不过，$n\le10^4$，要**高！精！度！**

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans1,l1 = 1,l2;
string last1 = "1",last2 = "1",ans2,a[10005];
string jia(string a,string b){
	string c = "";
	int x[10005] = {},y[10005] = {},z[10005] = {};
	for (int i = a.size() - 1,j = 1; i >= 0; i--,j++) x[j] = (a[i] - '0');
	for (int i = b.size() - 1,j = 1; i >= 0; i--,j++) y[j] = (b[i] - '0');
	int len = max(a.size(),b.size());
	for (int i = 1; i <= len; i++){
		z[i] += x[i] + y[i];
		z[i + 1] += z[i] / 10;
		z[i] %= 10;
	}
	if (z[len + 1] > 0) len++;
	for (int i = 1; i <= len; i++) c = char(z[i] + '0') + c;
	return c;
}
int main(){
	cin >> n >> m;
	if (n == 1) ans2 = "1";
	for (int i = 2; i <= n; i++){
		ans2 = jia(last1,last2);
		last2 = last1;
		last1 = ans2;
	}
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1,a + n + 1);
	for (int i = 1; i <= m; i++){
		string s;
		cin >> s;
		int x = lower_bound(a + 1,a + n + 1,s) - a;
		ans1 += a[x].substr(0,s.size()) == s;
	}
	cout << ans1 << '\n' << ans2;
	return 0;
}
```

---

## 作者：Usada_Pekora (赞：0)

第一问询问 $s$ 是多少个 $name_i$ 的前缀，可以直接 Trie 做。这个很简单，先对所有的 $s$ 执行插入，再询问每个 $name_i$ 包含几个已经插入的前缀就好了。

第二问。

我们设 $f_{i,j}$ 表示前 $i$ 个车子有 $j$ 个跟左边交换（这个左右没关系的，本质相同）的方案数，再令 $g_i=\sum\limits^{\lfloor\frac{i}{2}\rfloor}_{j=0}f_{i,j}$，即 $i$ 个车子的答案。有边界 $f_{i,0}=1$。

则 $f_{i,j} = f_{i-1,j}+f_{i-2,j-1}$，即要么加入一个新的并且不换，要么加入一对新的并且交换，可能不太准确，意会一下即可，这个 $f_{i-1,j}$ 的 $j$ 能否取到是没关系的，因为如果 $i-1\lt 2j$ 的话这个东西是 $0$。

所以有这样一个做法：

```cpp
f[1][0] = f[2][0] = f[2][1] = 1;
for (int i = 3; i <= n; i++) {
	f[i][0] = 1;
	for (int j = 1; j <= i / 2; j++)
		f[i][j] = f[i - 1][j] + f[i - 2][j - 1];
}
int64_t res = 0;
for (int i = 0; i <= n / 2; i++)
	res += f[n][i];

```

这个东西可以打表发现是斐波那契，不过我们直接推它就好了。

有 $g_i = \sum\limits^{\lfloor\frac{i}{2}\rfloor}_{j=0}f_{i,j} = \sum\limits^{\lfloor\frac{i-1}{2}\rfloor}_{j=0}f_{i-1,j}+\sum\limits^{\lfloor\frac{i}{2}\rfloor-1}_{j=0}f_{i-2,j}=g_{i-1}+g_{i-2}$。

根据定义有 $g_1=1,g_2=2$。

所以直接递推 $g$ 即可。

要写高精。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e8, maxn = 1e4 + 5;
int n, m, len, ans, a[maxn >> 3], b[maxn >> 3], c[maxn >> 3];
string s[maxn], t;
struct node {
	int cnt;
	node *nxt[52];
	node() {
		cnt = 0;
		for (int i = 0; i < 52; i++)
			nxt[i] = nullptr;
	}
};
node *root = new node();
inline void add() {
	memset(c, 0, sizeof c);
	for (int i = 1; i <= len; i++) {
		c[i] += a[i] + b[i];
		if (c[i] >= mod) {
			c[i + 1] += c[i] / mod;
			c[i] %= mod;
		}
	}
	while (c[len + 1]) 
		len++;
	memcpy(a, b, sizeof b);
	memcpy(b, c, sizeof c);
}
inline int getid(char ch) {
	return islower(ch) ? (ch - 'a') : (26 + ch - 'A');
}
inline void insert(string &str) {
	node *p = root;
	for (auto &ch : str) {
		int id = getid(ch);
		if (p->nxt[id] == nullptr)
			p->nxt[id] = new node();
		p = p->nxt[id];
	}
	p->cnt = 1;
}
inline int query(string &str) {
	int res = 0;
	node *p = root;
	for (auto &ch : str) {
		int id = getid(ch);
		if (p->nxt[id] == nullptr)
			break;
		p = p->nxt[id];
		res += p->cnt;
	}
	return res;
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> s[i];
	for (int i = 1; i <= m; i++) 
		cin >> t, insert(t);
	for (int i = 1; i <= n; i++)
		ans += query(s[i]);
	printf("%d\n", ans);
	a[1] = 1;
	b[1] = 2, len = 1;
	for (int i = 3; i <= n; i++) 
		add();
	printf("%d", c[len]);
	for (int i = len - 1; i >= 1; i--)
		printf("%08d", c[i]);
	return 0;
}
```

---


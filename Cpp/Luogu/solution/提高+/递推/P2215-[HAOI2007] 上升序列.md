# [HAOI2007] 上升序列

## 题目描述

对于一个给定的 $S=\{a_1,a_2,a_3,…,a_n\}$ , 若有 $P=\{a_{x_1},a_{x_2},a_{x_3},…,a_{x_m}\}$ , 满足 $(x_1<x_2<…<x_m)$  且 $(a_{x_1}<a_{x_2}<…<a_{x_m})$ 。那么就称 $P$ 为 $S$ 的一个上升序列。如果有多个 $P$ 满足条件，那么我们想求字典序最小的那个。

任务：

给出 $S$ 序列，给出若干询问。对于第 $i$ 个询问，求出长度为 $L_i$ 的上升序列，如有多个，求出字典序最小的那个（即首先 $x_1$ 最小，如果不唯一，再看 $x_2$ 最小……），如果不存在长度为 $L_i$ 的上升序列，则打印 `Impossible`。


## 说明/提示

$N \le 10000$，$M \le 1000$，保证数据随机。


## 样例 #1

### 输入

```
6
3 4 1 2 3 6
3
6
4
5
```

### 输出

```
Impossible
1 2 3 6
Impossible
```

## 样例 #2

### 输入

```
6
6 7 1 2 3 4
1
2
```

### 输出

```
6 7```

# 题解

## 作者：封禁用户 (赞：14)

首先楼下的都用的O(nlogn)，其实这个题的数据范围是可以用暴力O(n^2)的。我是先用n^2求出从各项开始往后的最长上升序列长度，然后在询问时首先看看l如果大于已知最长的上升序列的话那么Impossible，否则就从头开始找。如果从这个地方开始的最大长度比l大时，就输出这个数并且记录下这个数（因为以后找到的数都要比这个数小），然后我们已经找到了一个，就将l-1，然后接着重复上述步骤直到整个序列都被找出也就是l=0。因为我们一直是从前开始找的，所以字典序肯定是最小的。

代码如下：

```cpp
    #include<cstdio>
    using namespace std;
    int ints[10001];//序列
    int dp[10001];//从此处开始的最长上升序列长度
    int get(){//读入优化
        int n;
        char c;
        while(1){
            c=getchar();
            if(c>='0'&&c<='9')break;
        }
        n=c-'0';
        while(1){
            c=getchar();
            if(c>='0'&&c<='9'){
                n=n*10+c-'0';
            }
            else{
                return(n);
            }
        }
    }
    int main(){
        int n=get();
        for(int i=1;i<=n;i++){
            ints[i]=get();
            dp[i]=1;//把结果都初始化为1
        }
        int imax=1;//整个序列中的最长的上升序列长度
        for(int i=n-1;i>=1;i--){//暴力n^2求最长上升序列
            int maxn=1;
            for(int j=i+1;j<=n;j++){
                if(ints[j]>ints[i]){
                    if(dp[j]+1>maxn){
                        maxn=dp[j]+1;
                    }
                }
            }
            dp[i]=maxn;
            if(maxn>imax)imax=maxn;
        }
        int m=get();
        for(int i=0;i<m;i++){
            int l=get();
            if(l>imax||l<=0){//如果l比整个序列的最长上升序列都要长，肯定是找不到的
                printf("Impossible\n");
            }
            else{
                int tmp=l;//要找的长度
                int last=-1;//上一个找到的数，接下来找到的数都应比这个大
                for(int j=1;j<=n;j++){
                    if(dp[j]>=tmp&&ints[j]>last){
                        printf("%d ",ints[j]);
                        last=ints[j];//记录下找到的数作为上一个
                        tmp--;//找到了一个就减去1
                        if(tmp==0)break;
                    }
                }
                printf("\n");
            }
        }
        return(0);
}
```

---

## 作者：姬小路秋子 (赞：13)

前面看错题了，把下标字典序最小理解成了a数组的字典序最小，肝了一会发现不会，丧>_<

被迫看题解。

然后发现理解错题了。

然后就是一道H2O题了，不用过brain的从后往前求一遍最长下降子序列（这题建议打二分的，因为a数组没有给定范围，所以树状数组离散化太麻烦）。然后从前往后扫一遍判断当前是否合法（以当前为结尾的lis长度是否超过还需要的长度）就行了。

代码：

```c
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100001],f[100001],b[100001],tot;
int query(int x){
	int l=1,r=tot,ans=0,mid;
	while(l<=r){
		mid=(l+r)/2;
		if(b[mid]>x){
			ans=max(ans,mid);
			l=mid+1;
		}
		 else r=mid-1;
	}
	return ans;
}
int main(){
	int i,j,t,la,now;
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=n;i;i--){
		now=query(a[i]);
		f[i]=now+1;
		tot=max(tot,now+1);
		if(b[now+1]<a[i])b[now+1]=a[i];
	}
	//printf("%d\n",tot);
	scanf("%d",&m);
	while(m--){
		scanf("%d",&t);
		if(t>tot)puts("Impossible");
		 else{
		 	la=0;
		 	for(j=1;j<=n;j++)
		 	 if(f[j]>=t&&a[j]>la){
		 	 	printf("%d ",a[j]);
		 	 	t--;la=a[j];
		 	 	if(!t)break;
		 	 }
		 	 puts("");
		 }
	}
}
```

---

## 作者：vectorwyx (赞：8)

先求出以每个元素作为开头的最长上升子序列的长度 $f_i$，用二分可以做到 $O(n\log n)$ 的复杂度。

题目要求上升序列的下标的字典序最小，考虑贪心。从左往右扫，找到第一个满足 $f_i$ $\ge L$ 的 $i$，显然它必定是答案序列的第一位，把它加进答案序列内；然后再从第 $i+1$ 个数开始向右扫，找到第一个满足 $f_j\ge L-1$ 且 $a_j>a_i$ 的 $j$，那么 $j$ 肯定是答案序列的第二位。以此类推，$O(L)$ 地递归求解即可。总时间复杂度 $O(n\log n+\sum L_i)$

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}

const int N=1e4+5;
int a[N],dp[N],st[N],top,n,mx;

void solve(int id,int len){
	if(len==1){
		printf("%d\n",a[id]);
		return;
	}
	printf("%d ",a[id]);
	fo(i,id+1,n) if(a[i]>a[id]&&dp[i]>=len-1){
		solve(i,len-1);
		return;
	}
}

int main(){
	cin>>n;
	fo(i,1,n) a[i]=read();
	go(i,n,1){
		int L=1,R=top,mid,pos=0;
		while(L<=R){
			mid=(L+R)>>1;
			if(st[mid]>a[i]) pos=mid,L=mid+1;
			else R=mid-1;
		}
		dp[i]=pos+1;
		if(dp[i]>top) st[++top]=a[i];
		else if(a[i]>st[dp[i]]) st[dp[i]]=a[i];
		mx=max(mx,dp[i]);
	}
	//fo(i,1,n) printf("%d ",dp[i]);puts("");
	int q=read();
	while(q--){
		int x=read();
		if(x>mx) puts("Impossible");
		else{
			fo(i,1,n) if(dp[i]>=x){
				solve(i,x);
				break;
			}
		}
	}
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：安好 (赞：6)


http://www.cnblogs.com/L-Memory/p/7392125.html

/\*
我们知道nlogn的最长上升子序列中定义状态f[i]表示以i结尾的...

这个题要求以i开头的 所以倒着做最长下降子序列就好了，f只记录长度

所以需要有个best数组存序列

最后输出答案，若要求的序列长度为x，如果以第一个数（字典序最小的数）

开头的最长上升子序列大等于x，则将它放在答案第一个，

第二个数开头小于x，则舍弃，第三个大于x-1，放答案第二个，以此类推

\*/







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1000000000
#define N 100007
using namespace std;
int n,m,cnt;
int a[N],f[N],best[N];
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
void solve(int x)
{
    int last=0;
    for(int i=1;i<=n;i++)
        if(f[i]>=x&&a[i]>last)
        {
            printf("%d",a[i]);
            if(x!=1)printf(" ");
            last=a[i];x--;
            if(!x)break;
        }printf("\n");
}
int find(int x)
{
    int l=1,r=cnt,ans=0;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(best[mid]>x)ans=mid,l=mid+1;
        else r=mid-1;
    }return ans;
}
void dp()
{
    for(int i=n;i;i--)
    {
        int t=find(a[i]);
        f[i]=t+1;cnt=max(cnt,t+1);
        if(best[t+1]<a[i]) best[t+1]=a[i];
    }
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++) a[i]=read();
    dp(); m=read();
    for(int i=1;i<=m;i++)
    {
        int x=read();
        if(x<=cnt)solve(x);
        else puts("Impossible");
    }
    return 0;
}
```

---

## 作者：panjoel (赞：5)

这道题看起来是不是和求最长上升子序列一模一样?

但是它是一道动规！还用到了求最长上升子序列的二分算法！

先预处理出每个位置以后的最长上升序列，记录最大值tot，如果m大于tot，直接输出Impossible；否则搜索输出，注意这里的字典序最小是标号最小，所以直接从头往后搜就可以了~

**注意过滤行末空格**。

## 代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10005
#define M 1005
using namespace std;
int n,m,sum,f[N],a[N],ans[N];
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]),f[i]=1;
    for (int i=n;i;i--)
        for (int j=n;j>i;j--)
            if (a[j]>a[i]) f[i]=max(f[i],f[j]+1);//常数小（其实是我懒）所以就用O(n²)了
    scanf("%d",&m); int l,x;
    while (m--){
        scanf("%d",&l),sum=0;
            for (int i=0;i<=n&&l;i=x,l--){
                for (x=i+1;x<=n;x++)
                    if (f[x]>=l&&a[x]>a[i]) break;
                if (x>n) break; ans[++sum]=a[x];
            }
        if (l) puts("Impossible");
        else{
            for (int i=1;i<sum;i++)
                printf("%d ",ans[i]);
            printf("%d\n",ans[sum]);
        }
    }
    return 0;
}
```


---

## 作者：Reywmp (赞：4)

- ## P2215 【[HAOI2007]上升序列】

这是一道比较基础的dp题，可以往LIS的思路上靠，但其实并不是完全套用LIS。

题解区有一位大佬的思路与我很是类似，但是他的解释貌似有点少，这里我再详细说一下吧。

------------

- ### Prelude

虽然我要说的是dp思路，但是其他大佬的做法真的很好，于是我在这里顺便说下。

为什么要放在Prelude里面，因为在想到dp做法前我甚至已经想到其余做法，只是觉得dp更好实现。

对于这题我目前已知2种思路(准确来说还可细分）：

- **dp思路**

- **树状数组 & 线段树**

对于后两者，其实很好想，但是也有缺点，这题万幸中保证了$a_i$并不大，如果$a_i$范围很大，离散化就不可实现。但是即便如此，想到离散化想必在考场上可以骗到不少分吧（

**而且其实线段树和树状数组用的也就是dp思路，只不过线段树和树状数组是把点值离散化区间维护后直接用自身数据结构具备的方法找$LIS$。**

我们再来思考dp，因为题目要求我们输出这个子序列，而不是序列和或者其他信息。

所以我们想必在输出的时候会扫一遍整个数组，这样最坏复杂度就是$O(NM)$已经比较小慢了。也不能在接受更高一级的复杂度了。

但是我们在扫的时候只需要考虑当前这个数是否输出。

因为题意中的字典序最小其实是对于序列中那些$a_i$的**下标**$i$的字典序最小，所以遇到一个能输出就一定输出。

于是我们可以得出dp思路，如下。

------------

- ### Solution

对于dp，我先讲下最朴素的思路，也就是~~并没有到~~$O(N^2)$的预处理和$O(NM)$的输出，~~这个题数据再加强一下就可能被卡的那种~~。

不过我们先考虑下`Impossible`的情况，我们只需要求出整个序列的那个最长子序列长度，对于查询长度小于等于最长长度的必然有解，因为可以从中随意挑选数个组成$LIS$，如果大于最长长度必然没解，这个很显然吧。而这个长度我们可以在dp时就求出来了。

我们设dp状态$f_i$为从$i$这个位置开始那段区间的**最长上升子序列长度**。

显然`f[n]=1;`

如何求呢，我们逆序扫描$i$从`n-1~1`，然后扫$j$从`i+1~n`，当$a_i<a_j$这就是一个长度为2的上升子序列了，那么

$$f_i=max\left\{f_j+1\right\}(a_i<a_j)$$

我们可以理解为把$a_i$塞到这个数后面的那些上升子序列中的第一位，这样后面的最长的上升子序列长度$+1$ 就是$f_i$最长。（当然要保证$a_i$是可以放的）

可能会有疑问：为什么要求这个。

这样我们在后面输出就可以$O(1)$判断这个数是否可以输出了。

我们设$l$为剩下的还没输出的数的个数，那么一个数可以输出当且仅当:

- $a_i > pre$ 这个数比上一个输出的那个数大，这个用一个变量($pre$)记录就可以了。

-  $f_i \geq l$，说明输出这个数的话至少可以保证后面一直可以输出到$L$个数。

因为要求的是下标字典序最小，所以这个数可以输出就输出即可，输出到$L$个自动退出。

------------

- ### Code

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>

#define N 10005

using namespace std;

int a[N],f[N];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int maxl=1;
	f[n]=1;
	for(int i=n-1;i>0;i--)
	{
		f[i]=1; 
		for(int j=i+1;j<=n;j++)
		{
			if(a[j]>a[i]&&f[j]+1>le)f[i]=f[j]+1;//转移方程
		}
		maxl=max(maxl,f[i]);//maxl就相当于f[1]，这步好像是多余的/xk
	}
	int m;
	scanf("%d",&m);
	while(m--)
	{
		int q;
		scanf("%d",&q);
		if(q>maxl)puts("Impossible");//不合法的情况
		else 
		{
			int pre=-(1<<30);
			bool ok=0;
			for(int i=1;i<=n;i++)
			{
				if(f[i]>=q&&a[i]>pre)//如上
				{
					printf("%d ",a[i]);
					pre=a[i];//记录下输出过的数中最大的
					q--;
					if(q<=0){putchar('\n');ok=1;break;}
                  /*一旦输出了q个*/
				}
			}
			if(!ok)putchar('\n');//这个貌似也无所谓
		}
	}
	return 0;
}
```

虽然我给出的是最朴素的算法，但是二分速度明显要比这个代码快，所以我在这里还是再说一下：

二分的思路大致与我们相似，但是他要有一个数组来存当前位置之前的$LD(decreasing)S$，然后每次dp二分查找这个序列中最后严格大于$a_i$的数的位置$j$,然后转移方程。最后记得每次用$a_i$更新区间内符合$a_i$大小的那个地方的值。

扫描还是倒序的，每次$O(logN)$查询，所以预处理总复杂度$O(NlogN)$，输出同理。

到了最后，那个记录的数组最后存储的就是整个序列的$LDS$。

可能说的有点糊，大家可以参考下题解区其他大佬的代码，虽然~~他们解释的也不多~~。



---

## 作者：猪小屁 (赞：3)

update：2019/11/4 by popo[](https://www.luogu.org/space/show?uid=157681)

谢谢您的指出！



------------

看大佬的题解又有**暴力**又有**二分**

本蒟蒻直接康不懂了

## 我来写一个**STL**（~~lower__bound大法好~~）


###### ------------（~~并不华丽的分割线~~）


首先，介绍一个c++自带的**二分查找函数**lower_bound（c++好啊）

#### 使用条件：需要原数组单调性
**标准写法**：

lower_bound( 数组开头迭代器（将要在这个数组中查找）,数组末尾迭代器，将要找的数）- 数组开头迭代器

通俗的写法为：

比如我要在a数组中找到b这个数的迭代器位置（相当于在a数组中的下标），且a中一共有n个元素，就这样写：

##  _int pos=lower_bound(a,a+n,b)-a;_ 

这样a[pos]的值就是b啦！

然后**LIS基本写法**，再加**dp**就好了（一开始用贪心wa9个..）:

上代码咯
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int a[maxn],b[maxn],a2[maxn],dp[maxn],cnt;
int n,m;
void find(){
	b[0]=-4444444;
	for(int i=1;i<=n;i++){
		if(b[cnt]<a2[i]){
			b[++cnt]=a2[i];
		}
		else{
			int pos=lower_bound(b+1,b+1+cnt,a2[i])-b;
			b[pos]=a2[i];
			dp[n-i+1]=pos;
			continue;
		}
		dp[n-i+1]=cnt;
	}
}
void find3(int x,int len){
	b[++cnt]=a[x];
	len--;
	for(int i=x;i<=n;i++){
	if(!len) break;
		if(a[i]>b[cnt]&&dp[i]>=len){
			b[++cnt]=a[i];
			len--;
		}
	}
}
void find2(int len){
	int pos=999999;
	for(int i=1;i<=n;i++){
		if(dp[i]>=len){
			pos=i;
			break;	
		}
	}
	if(pos==999999||len<=0){
		printf("Impossible\n");
		return;
	}
	for(int i=1;i<=cnt;i++){
		b[i]=0;
	}
	cnt=0;
	find3(pos,len);
	for(int i=1;i<=cnt;i++){
		printf("%d ",b[i]);
	}
	printf("\n");
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a2[n-i+1]=-a[i];
	}
	find();
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		int q;
		scanf("%d",&q);
		find2(q);
	}
	return 0;
}
```



---

## 作者：AG梦晨 (赞：3)

刚开始一看你们的代码，试了一遍，样例都过了，然后我在https://begin.lydsy.com/JudgeOnline/problem.php?cid=1279&pid=22试着提交了一遍，发现wrong answer了。
我想了蛮久，发现这样例是骗人的。
附上动态规划冠军代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,num[10001],f[10001];
int main(){
    int m,Max,x=1,q;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&num[i]);
        f[i]=1;
    }
    for(int i=n-1;i>=1;i--){
        Max=1;
        for(int j=i+1;j<=n;j++){
            if(num[j]>num[i]){
                Max=max(Max,f[j]+1);
            }
        }
        f[i]=Max,x=max(Max,x);
    }
    scanf("%d",&m);
    while(m--){
        scanf("%d",&q);
        if(q>x||q<=0)
            printf("Impossible\n");
        else{
            int cnt=q,last=-1;
            for(int i=1;i<=n;i++){
                if(f[i]>=cnt&&num[i]>last){
                    if(cnt>1)
                        printf("%d ",num[i]);
                    else
                        printf("%d\n",num[i]);
                    last=num[i];
                    if(!--cnt)
                        break;
                }
            }
        }
    }
}

```

---

## 作者：_AyachiNene (赞：2)

# 思路：
首先求出后缀最长下降子序列。因为 $n\leq10000$，且 $m\leq1000$，复杂度是可以支持 $O(nm)$ 的。对于每一个位置，如果要选，那么当前位置的值显然要大于上一次选的值，且最后的长度要符合题目要求，所以这个位置开始的最长上升子序列长度要大于剩下还要的长度。字典序要最小，只要从前往后找找到一个符合要求的位置直接选就行了，如果最后选的长度不够，就是无解。最长上升子序列用树状数组维护前缀最大值来优化就行了。
# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+(c^48);c=getchar();}
	return res*f;
}
void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
int t[114514<<5];
int lowbit(int x)
{
	return x&-x;
}
void add(int x,int y)
{
	for(;x;x-=lowbit(x))
		t[x]=max(t[x],y);
}
int query(int x)
{
	int res=0;
	for(;x<=1e6;x+=lowbit(x))
		res=max(res,t[x]);
	return res;
}
int n,m;
int a[114514];
int dp[114514];
int ans[114514],cnt;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=n;i;i--)
		dp[i]=query(a[i]+1)+1,add(a[i],dp[i]);
	m=read();
	while(m--)
	{
		int last=0;
		int x=read();
		cnt=0;
		for(int i=1;i<=n;i++)
			if(dp[i]>=x&&x&&a[i]>last)
				ans[++cnt]=a[i],--x,last=a[i];
		if(x)
			puts("Impossible");
		else
		{
			for(int i=1;i<=cnt;i++)
				write(ans[i]),putchar(' ');
			puts("");
		}
	}
}
```


---

## 作者：hanzhongtlx (赞：2)

做题发现自己不会 $\mathcal O(n\log n)$ $LIS$ 了，怎么办？~~看题解！~~  

## 线段树！  

我们考虑从后向前枚举每一个数，如果设 $dp_i$ 为以 $i$ 开头的最长下降子序列的长度，那么只需要求得在他后面比他大的数的 $dp$ 值的最大值。  
所以我们考虑将权值离散化，将没有扫过（显然这些数在现在这个数前面）的数的 $dp$ 值设得很小，然后线段树上二分求一下最大值就好了了。 

时间复杂度就是常数比较大的 $\mathcal O(n\log n)$。 

对于询问，考虑贪心即可。  

由于数据是随机的，这个 $\mathcal O(nm)$ 的询问复杂度也不会跑得很满，所以就很轻松的过掉了。 

参考代码：  

```
#include"algorithm"
#include"iostream"
#include"cstdio"
#include"cmath"
using namespace std;

#define read(x) scanf("%d",&x)
#define MAXN 10005

struct num
{
	int val,id;
}b[MAXN];
int n,m;
struct node
{
	int l,r,rec;
}a[MAXN<<2];
int re[MAXN],dp[MAXN];
int l,me[MAXN];

bool cmp(num n,num m){if(n.val==m.val) return n.id>m.id;else return n.val<m.val;}

void hash()
{
	sort(b+1,b+n+1,cmp);
	for(int i=1;i<=n;i++) re[b[i].id]=i,dp[i]=-1;
}

void update(int k){a[k].rec=max(a[k<<1].rec,a[k<<1|1].rec);}

void build(int k,int l,int r)
{
	a[k].l=l,a[k].r=r;
	if(l==r){a[k].rec=dp[l];return;}
	int mid=(l+r)>>1;
	build(k<<1,l,mid),build(k<<1|1,mid+1,r);
	update(k);
	return;
}

void modify(int k,int x,int y)
{
	if(a[k].l==a[k].r){a[k].rec=y;return;}
	if(a[k<<1].r>=x) modify(k<<1,x,y);
	else modify(k<<1|1,x,y);
	update(k);
}

int query(int k,int l,int r)
{
	if(a[k].l==l&&a[k].r==r) return a[k].rec;
	int mid=(a[k].l+a[k].r)>>1;
	if(r<=mid) return query(k<<1,l,r);
	else if(l>mid) return query(k<<1|1,l,r);
	else return max(query(k<<1,l,mid),query(k<<1|1,mid+1,r));
}

int main()
{
	read(n);
	for(int i=1;i<=n;i++) read(b[i].val),me[i]=b[i].val,b[i].id=i;
	hash(),build(1,1,n);
	for(int i=n;i>=1;i--)
	{
		int now=query(1,re[i],n);
		if(now==-1) dp[i]=1;
		else dp[i]=now+1;
		modify(1,re[i],dp[i]);
	}
	read(m);
	while(m--)
	{
		read(l);
		int now=l,lst=-0x7fffffff;
		for(int i=1;i<=n;i++)
		{
			if(dp[i]>=now&&me[i]>lst)
			{
				now--,lst=me[i];
				printf("%d ",me[i]);
				if(now==0) break;
			}
		}
		if(now>0) printf("Impossible");
		puts("");
	}
	return 0;
}
```

---

## 作者：Tgotp (赞：1)

思路：lis + 二分答案 + 贪心？


过程：之前一直在纠结字典序输出，后来一想，从最前面开始，向后枚，肯定是最优的，还有一个坑点，严格按照格式输出；


另外就是 lis  要注意从后向前找，即f[i]代表从 i 开始，最长的上升序列长度吗，其他的就是基础lis过程。


over

c++ 代码：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;
const int N = 1e5 + 5;
int n,m,d[N],f[N],a[N],len;
inline void read(int &x)
{
    x = 0;char c ; int sign = 1;
    do{ c = getchar(); if(c == '-') sign = -1;}while(c < '0' || c > '9');
    do{ x = x * 10 + c -'0'; c = getchar(); }while(c <= '9' && c >='0');
    x *= sign;
}
inline int max(int a,int b){ return a > b ? a : b; }
inline int find(int n)
{
    int l = 1,r = len,ans = 0;
    while(l <= r)
    {
        int mid = (l + r) >> 1;
        if(d[mid] > a[n])
            ans = mid,l = mid + 1;
        else r = mid - 1;
    }
    return ans;
}
inline void pre()
{
    for(int i = n;i;i--)
    {
        f[i] = find(i) + 1;
        d[f[i]] = a[i];
        len = max(len,f[i]);
    }
}
int main()
{
    read(n);
    for(int i = 1;i <= n;i++) read(a[i]);
    pre();
    read(m);
    while(m--)
    {
        int z;
        read(z);
        if(z > len ){ puts("Impossible"); continue; }
        for(int i = 1,last = 0;z;i++)
            if(f[i] >= z && a[last] < a[i])
            {
                last = i;
                printf("%d",a[i]);
                if(z == 1) puts("");
                else printf(" ");
                z--;
            }
    }
    return 0;
}

```

---

## 作者：Vsinger_洛天依 (赞：0)

模拟赛时有思路没时间写，打了个暴搜拿了 $10$ 分。

给了数据随机似乎可以考虑珂朵莉树做法，但是我不会，有没有大佬指点一下。

想到了 $\text{dp}$，但是没尝试，毕竟当时没多长时间了，那么赛后补上。

首先我们这里需要用到 $O(n \log n)$ 求最长上升子序列的方法，可以见 [OI-wiki](https://oi-wiki.org/dp/basic/#%E7%AE%97%E6%B3%95%E4%BA%8C) 处。

首先进行预处理，跑一遍基础的最长上升子序列，这样我们就求出了每个元素为开头对应的最长上升子序列长度，通过这个长度我们可以判断是否有解。

由于要求字典序最小，我们可以直接从左往右来看，找到第一个 $f_i$ 比 $L$ 大的，这样就满足了字典序最小的条件

然后下一步同上一步，只需要进行递归，寻找在 $i$ 右侧，$f_i>L-1$ 且值比 $a_i$ 大的 $j$ ，并以此类推。

这样我们就用一个极其暴力的做法求出了这道题的解。

---

## 作者：PineappleSummer (赞：0)

[P2215 [HAOI2007] 上升序列](https://www.luogu.com.cn/problem/P2215)

被题面坑了。

注意题面要求的是**下标字典序最小**的序列。

令 $f_i$ 为从第 $i$ 个数开始的 LIS 长度。可以倒着扫一遍用数据结构维护一下，$O(n\log n)$ 预处理出 $f$ 数组。

对于每次询问，由于要答案下标字典序最小
，那么从 $1$ 开始扫一遍就行了。如果 $f_i\ge l$ 则说明从第 $i$ 个数开始的 LIS 大于 $l$，如果 $a_i\ge a_{last}$ 便可以用 $a_i$ 这个数，输出 $a_i$，将 $l$ 减一，$last$ 变为 $i$。

单次询问复杂度 $O(n)$。总时间复杂度 $O(n\log n+nm)$。

发现自己是本题第二快的，难道大家都是 $O(n^2)$ 的 LIS？

代码只放主函数的，预处理用的线段树版子不给了。
```cpp
int main () {
	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
  	// 离散化
	sort (b + 1, b + n + 1);
	int m = unique (b + 1, b + n + 1) - b - 1;
	for (int i = 1; i <= n; i++) a[i] = lower_bound (b + 1, b + m + 1, a[i]) - b;
	for (int i = n; i; i--) {
		f[i] = query (1, 1, m, a[i] + 1, m) + 1;
		modify (1, 1, m, a[i], f[i]);
		// 预处理 f 数组
		ma = max (ma, f[i]);
	}
	cin >> Q;
	while (Q--) {
		int l;
		cin >> l;
		if (l > ma) { // 长度不够
			cout << "Impossible\n";
			continue; 
		}
		int last = 0;
		for (int i = 1; i <= n, l; i++) {
			if (f[i] >= l && a[i] > a[last]) { // 长度够且比上一个大
				l --;
				cout << b[a[i]] << ' '; // 注意还原为原数组
				last = i;
			}
		}
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：CaoSheng_zzz (赞：0)

### 题目大意
对于一个集合 $ S $，对于 $ S $ 中长度为 $ m $ 的子序列 $ P $，在集合 $ P $ 中如果 $ P_1<P_2<...<P_m $ 那么我们称 $ P $ 为 $ S $ 的一个上升序列。如果有多个 $ P $ 满足条件我们就输出最小的那个，如果没有完成条件的 $ P $ 则输出 `Impossible`。

### 思路
对于一个含有 $ n $ 个元素的集合，我们求出这个集合每一个最长上升序列总时间复杂度需要 $ \Omicron(n^2) $ 看一眼数据 $ 10^4 $ 完全可以，接着对于每一个输入的 $ len $，我们直接从第一个开始暴力判断，在每次判断时维护一下当前的数，每一次最坏的时间复杂度为 $ \Omicron(n) $ 所以总时间复杂度为 $ \Omicron(m \times n ) $，由此可以算出我们完成这道题最坏的时间复杂度为 $ \Omicron(n^2 + m \times n) $ 及 $ \Omicron(1.1 \times 10^8) $ 而一秒大约能运行 $ 3 \times 10^8 $ 次，所以这道题暴力完全能过。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#define sc(ppt) scanf("%d" , &ppt)
#define ll long long
#define prt printf
using namespace std;

const int maxn = 1e4 +  1;
int n , m , f[maxn] , a[maxn] ; 

signed main(){
	sc(n) ;
	for(int i=1 ; i<=n ; i++) sc(a[i]) ;
	for(int i=1 ; i<=n ; i++) f[i] = 1;
	for(int i=n ; i>=1 ; i--){
		for(int j=n ; j>=1 ; j--){
			if(a[j] > a[i]) f[i] = max(f[i] , f[j] + 1); // 暴力求最长子序列 
		}
	}
	sc(m) ;
	while(m --){
		int len , cnt = 0 , j = 0 , ans[maxn]; sc(len) ;
		for(int i=0 ; i<=n&&len ; i=j , len--){ // 维护序列长度 
			for(j=i+1 ; j<=n ; j++){
				if(f[j] >= len && a[j] > a[i]) break; // 用当前最长上升的子序列来判断 
			}
			if(j <= n) ans[++ cnt] = a[j]; // 维护当前这个数的状态 
			else break;
		}
		if(len != 0) prt("Impossible\n"); // 如果还需要的数的个数不为0那么说明上升子序列长度不够 
		else{
			for(int i=1 ; i<=cnt ; i++) prt("%d " , ans[i]);
			prt("\n");
		}
	}
	return 0;
}
```

---

## 作者：Liyunze123 (赞：0)

这道题数据有点水了（$n \le 10^4$，$m \le 10^3$），我给出一个 $O(nm)$ 的做法吧。

# 1.预处理
$dp_i$ 表示以 $i$ 为开头的最长上升序列的长度。

$O(n \log n)$ 求最长上升子序列：

设 $f_i$ 为最长上升子序列长度为 $i$ 的 $j$，$a_j$ 的最小值。

容易发现 $f$ 数组是单调增的。

二分求最后一个小于 $a_i$ 的 $f_j$，$dp_i=j+1$。

接着更新 $f_{dp_i}$。

这道题就是把数组倒过来，求最长下降子序列。

一点不同，这里的 $f$ 数组是单调降的。

有一个办法，把 $f$ 数组倒过来。

但 $f$ 数组长度会变。巧妙的解决办法就是，把 $f_i$ 存到 $f_{10000-i+1}$，$dp_i=10000-j+1$。（$n \le 10000$）。
# 2.求长度为 $L_i$ 的最长上升子序列
这道题妙就妙在要你求下标最小。肯定是选 $a_1$，接着选第一个大于 $a_1$ 的，直到选到第 $L_i$ 个。

万一选不到 $L_i$ 个怎么办？看 $a_2$ 呗。$a_2$ 也不行呢？看 $a_3$。会超时。

我们不是预处理了 $dp_i$ 吗？拿来用啊！

假设还要选 $x$ 个，如果 $dp_i < x$ 或者 $a_i \le last$（其中 $last$ 是上一次选的数，初始为零），那就不选 $i$。

如果这么处理了，还选不到 $L_i$ 个，就说明找不着了。
# 3.代码加注释
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10010],b,dp[10010],f[10010],p,ans[10010];
int main(){
    scanf("%d",&n);
    for(int w=1;w<=n;w++)scanf("%d",&a[w]);
    dp[n]=1,f[10000]=a[n];//10000-1+1=10000
    for(int w=n-1;w;w--){
        if(a[w]>f[10000])dp[w]=1,f[10000-dp[w]+1]=max(a[w],f[10000-dp[w]+1]);//a[w]太大，用不着找了，直接是1
        else{
            int k=upper_bound(f+1,f+10000+1,a[w])-f;k=10000-k+1;//前面的都是0，只有10000-t+1到10000有值，等于从10000-t+1找到10000
            dp[w]=k+1,f[10000-dp[w]+1]=max(a[w],f[10000-dp[w]+1]);//已经变成10000-k+1，直接抄上去，别忘了加一，更新f数组
        }
    }
    scanf("%d",&m);
    for(int w=1;w<=m;w++){
        scanf("%d",&b),p=0;//p=0别忘了！
        int k=0;//上一次选的数，初值为比什么数都小的0
        for(int x=1;x<=n&&b;x++)
            if(a[x]>k&&dp[x]>=b)k=a[x],b--,ans[++p]=a[x];//能选w，只要选b-1个数了
        if(b)printf("Impossible\n");//如果选完b应该是0，不是0说明没选完
        else{
            for(int w=1;w<=p;w++)printf("%d ",ans[w]);
            printf("\n");
        }
    }
    return 0;
}
```

---

## 作者：华山爆竹 (赞：0)

```
###### 首先** _看了1楼大哥的题解真的用二分超级容易_ **

#include <stdio.h>
int m,n,a[10000],b[100000],f[10000],maxr,maxf,t;
int main(int argc, char *argv[])
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=n;i>0;i--)
    {
        maxr>f[i+1]?maxr=maxr:maxr=f[i+1];
        int l=1,r=maxr,mid;
        while(l<=r)
        {
            mid=(l+r)/2;
            b[mid]>a[i]?l++:r--;
        }
        mid=(l+r)/2;
        f[i]=mid+1;if(b[mid+1]<a[i]) b[mid+1]=a[i];
    }
    maxf=f[1];
    for(int i=2;i<=n;i++)
    if(f[i]>maxf) maxf=f[i];
    scanf("%d",&m);
    int la;
    while(m--)
    {
        scanf("%d",&t);
        if(t>maxf) printf("Impossible\n");
        else
        {
        	la=0;//就是这里困扰了我两个月
            for(int i=1;i<=n;i++)
            if(t<=f[i]&&t!=0&&la<a[i])
            {
                printf("%d ",a[i]);
                t--;la=a[i];
            }printf("\n");
        }

    }
    return 0;
}
```


---

## 作者：翠竹叶飞 (赞：0)

省选题确实有点恶心。

O(n logn) LIS + 贪心。 

主要过程是LIS，似乎有2种方法。

1.二分，然而我不太会。

2.O(n^2)的dp加树状数组优化。

在这里，树状数组用来存区间f[]的最大值

操作1：getvalue():在>=b[i]的元素中找最大的f[]值。

操作2：update():更新1~b[i]的元素的f[]值。

而基础的树状数组模型为：getvalue(k)为1..k中的XXX，update(k)为将k及以后的元素更新

我们发现，需要倒着存，于是题目就变得有些复杂。

tree[i]实际代表正常的tree[n-i+1]

即：tree[1..n] = n+1 - (1..n)

贪心：从前到后搜，如果可以就选，原因是题目以下标为序。

    
    
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream> 
using namespace std;
int i,j,n,m,k,a[10001],b[10001];
int f[10001],tree[10001],longest=0;
struct ele
{
    int value,p;
} ls[10001];
int comp(ele a, ele b)
{
    return a.value<b.value;
}
int getvalue(int k) // >= k 中 f[]的最大 
{
    k=n+1-k;
    int res=0;
    while (k)
    {
        res=max(res,tree[k]);
        k-=k&-k;
    }
    return res;
}
void update(int k, int value) //1..k中更新f[]
{
    k=n+1-k;
    while (k<=n)
    {
        tree[k]=max(tree[k],value);
        k+=k&-k;
    }
}
int main()
{
    scanf("%d",&n);
    for (i=1; i<=n; i++) scanf("%d",&a[i]);
    for (i=1; i<=n; i++)
    {
        ls[i].p=i;
        ls[i].value=a[i];
    }
    sort(ls+1,ls+n+1,comp);
    int cnt=1;
    for (i=1; i<=n; i++)
    {
        b[ls[i].p]=cnt;
        if (ls[i].value!=ls[i+1].value) cnt++;
    } //1.离散 
    for (i=n; i>=1; i--)
    {
        f[i]=1+getvalue(b[i]+1);
        update(b[i],f[i]);
        if (f[i]>longest) longest=f[i];
    } //2.dp(这是重点) 
    scanf("%d",&m);
    for (i=1; i<=m; i++) //3.这跟离散没有关系，贪心 
    {
        scanf("%d",&k);
        if (k>longest) printf("Impossible\n");
        else
        {
            int maxn=0;
            for (j=1; j<=n; j++)
              if (f[j]>=k && a[j]>maxn)
              {
                  if (k==0) break;
                  printf("%d ",a[j]);
                  k--;
                  maxn=a[j];
              }
            printf("\n");
        }
    }
    return 0;
}
```

---


# [SCOI2005] 最大子矩阵

## 题目描述

这里有一个 $n \times m$ 的矩阵，请你选出其中 $k$ 个子矩阵，使得这个 $k$ 个子矩阵分值之和最大。

注意：选出的 $k$ 个子矩阵不能相互重叠。

## 说明/提示

对于 $100 \%$ 的数据，$1 \leq n \leq 100$，$1 \leq m \leq 2$，$1 \leq k \leq 10$。

## 样例 #1

### 输入

```
3 2 2
1 -3
2 3
-2 3
```

### 输出

```
9```

# 题解

## 作者：ttt_TTT (赞：112)

~~真的坑~~

注意到m=1或者2，

当m=1时，是普通的最大连续字段和，只不过是k个：

设dp[i][j]表示前i个数中取出j个矩形的最大和

转移：

选：dp[i][j]=max{dp[l][j-1]+s[i]-s[l-1]}

不选：dp[i][j]=max(dp[i][j],dp[i-1][j])

复杂度O(n^2*K)

当m=2时，设f[i][j][k]表示第一列选到第i个数，第二列选到第j个数时，总共k个子矩形的答案

转移有4种情况

当这一位什么都不做的时候：f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k])

当仅选取第一列的某段区间时：f[i][j][k]=max(f[l][j][k-1]+sum[i][1]-sum[l-1][1])  1<=l<i

当仅选取第二列的某段区间时：f[i][j][k]=max(f[i][l][k-1]+sum[j][2]-sum[l-1][2])  1<=l<j

当i==j时，可以选取两列一起的f[i][j][k]=max(f[l][l][k]+sum[i][1]+sum[i][2]-sum[l-1][1]-sum[l-1][2])

最后所有情况取max

复杂度O(n^3*K)

```
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=110;
const int M=11;
int n,m,K,s1[N],s2[N],dp[N][M],f[N][N][M];
int main(){
    scanf("%d%d%d",&n,&m,&K);
    if(m==1){
        for(int i=1,x;i<=n;i++) scanf("%d",&x),s1[i]=s1[i-1]+x;
        for(int k=1;k<=K;k++){
            for(int i=1;i<=n;i++){
                dp[i][k]=dp[i-1][k];
                for(int j=0;j<i;j++) dp[i][k]=max(dp[i][k],dp[j][k-1]+s1[i]-s1[j]);
            }
        }
        printf("%d\n",dp[n][K]);
    }
    else{
        for(int i=1,x,y;i<=n;i++) scanf("%d%d",&x,&y),s1[i]=s1[i-1]+x,s2[i]=s2[i-1]+y;
        for(int k=1;k<=K;k++){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]);
                    for(int l=0;l<i;l++) f[i][j][k]=max(f[i][j][k],f[l][j][k-1]+s1[i]-s1[l]);
                    for(int l=0;l<j;l++) f[i][j][k]=max(f[i][j][k],f[i][l][k-1]+s2[j]-s2[l]);
                    if(i==j)  for(int l=0;l<i;l++) f[i][j][k]=max(f[i][j][k],f[l][l][k-1]+s1[i]-s1[l]+s2[j]-s2[l]);
                }
            }
        }
        printf("%d\n",f[n][n][K]);
    }
    return 0;
}
```

 

---

## 作者：天泽龟 (赞：91)

### **来写一个十分详细的，且码风适宜的题解。。**

其实这道题没有讲的价值，只有自己写的价值。。在众多状态的转移之间能否理清自己的思路，这很重要。

写的时候确实挺爽的，拍了五六次才把所有状态弄清楚，写拙文一篇，以此记之。

- ## 对于$M=1$

首先看题目我们注意到$m<=2$是个很重要的约束，我们不如将两种情况分开，先考虑$m=1$再将其推广到$m=2$。

首先可以想到用$i$表示到了第i行，$j$表示已经分了j栏，但如何考虑将j栏单独分离呢？我们可以再设一维$[0/1]$，表示当前行是否选择，这样$f[i][j][0/1]$即为此状态下的最大价值。

- 那么对于$f[i][j][0]$，可知前一行的状态咋样都无所谓，反正我这行又不选，于是：$f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])$

- 对于$f[i][j][1]$，我们有三种可能：上一行与下一行**合并**，上一行是空的且当前行**重起炉灶**，上一行非空的但当前行**重起炉灶**。

（这里涉及到一些作者写题时瞎编的术语，意思大概就是**合并=和上一行状态合并成一个大矩阵**，**重启炉灶=重开一个矩阵，当前行是矩阵的首位**，感觉这样讲方便些。。）

于是可得到方程：$f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][1],f[i-1][j-1][0])$

以上三项分别与上面对应，其中第二项保证**当矩阵不够k个时，可以通过拆分矩阵将其凑到k个**，所以空矩阵其实是不存在的。。

- ## 对于$M=2$

如果我们沿用上面的那种思想，是否也可以写出第二种情况的转移方程呢？我们可以试试在第三维上面做做文章。

第三维原来描述的是当前行的状态情况，我们不如类比的来设$S\in [0,4]$为当前行的五种状态，分别是：

【$0->$当前行为空】；
【$(01)_2->$选右边】；【$(10)_ 2->$选左边】；

【$(11)_ 2->$都选，作为整体】；【$(11)_2^*->$都选，但两边分开考虑】；

其中第五个状态最不好想，我是通过对拍拍了一个数据才想到的：
```cpp
4 2 2
-5 4
3  5
5  2
8  -10
```

貌似就是样例的升级版，但是只有第五种状态才可以符合这种类型的转移。


那么我们对其分别分析：

1. 对于$S=0,$类比$M=1$的转移情况，可知前一行的状态咋样都无所谓，反正我这行又不选，于是：
$$f[i][j][0]=forq~~max(f[i-1][j][q])$$

这里我们`define forq for(int q=0;q<=4;q++)`，这样看不会感到很清爽吗。（笑

2. 对于$S=1,$我们就要重新考虑其转移了：

- 首先如果选用**合并**的话，可以想到前一行$S=1$的状态显然可以的，而且对于前一行$S=4$应该也可以的，于是可以得到：

$$f[i][j][1]=max(f[i-1][j][1],f[i-1][j][4])+g[i][1]$$

- 如果选用的是**重起炉灶**，那么显然和上一行状态又没啥关系了，于是可得：

$$f[i][j][1]=forq~~max(f[i-1][j-1][q]+g[i][1])$$

3. 对于$S=2,$，类比S=1的情况，也可以得到两个方程：

$$f[i][j][2]=max(f[i-1][j][2],f[i-1][j][4])+g[i][2]$$

这个是**合并**的情况，由于S=4的定义本身就是当前行两个全选且两行分别独立，所以不论下一行接在左还是右并不会有什么问题。

$$f[i][j][2]=forq~~max(f[i-1][j-1][q]+g[i][2])$$

这是**重起炉灶**的情况。

4. 对于$S=3,$就有些不同之处了。

首先$S=4$是不能通过**合并**转移过来的，虽然从整体图案上看还是一个矩阵，但其实已经和你的定义矛盾了。那么对于新的方程：

$$f[i][j][3]=max(f[i-1][j][3]+g[i][1]+g[i][2])$$

但是对于**重起炉灶**并没有啥关系，重开一个矩阵是很暴力的手法，直接转移就完事儿了。

但是要注意，这里新增的价值都变成了$g[i][1]+g[i][2]$，原因就不必说了吧。

5. 对于$S=4,$同样有些不同。

我们先感性地考虑一下$S=4$可从哪些方面转移而来，显然对于$S=1,S=2$都是可以的，但是特别的，它们都只能和当前行的单独一列合并，所以要多增加一栏存新的，第二维要标记为$[j-1]$：

$$f[i][j][4]=max(f[i-1][j-1][1],f[i-1][j-1][2])+g[i][1]+g[i][2])$$

当然也可从自身转移，当然也就不必新开一栏，就是我之前举的那个样例：
$$f[i][j][4]=max(f[i-1][j][4]+g[i][1]+g[i][2])$$

就此$S=4$也没了，等等，**重启炉灶咋没了呢？？**

哦，因为我一开始A了但没考虑这种情况，后来想想发现这次要开两个炉子贡献不是很大，所以转移时候就没涉及到，感觉硬要写的话只能表示成这样：

$$f[i][j][4]=forq~~ max(f[i-1][j-2][q]+g[i][1]+g[i][2])$$

至此所有状态转移就完了，其实上代码没啥意思，但出于完整性还是给大家看一下我丑陋的代码吧。。

```cpp
#include <iostream>
#include <cstring>
#define forq for(int q=0;q<=4;q++)  
using namespace std;
int n,m,k,ans=-2147483647,f[200][20][5],g[200][200]; 
//类比m=1，不难得出f[i][j][S]表示到第i行，分出j栏，当前行的状态
//S=0->none;  S=1-> right;  S=2->left;  
//S=3->both as a whole;  S=4->both but individual

int main()
{
	cin>>n>>m>>k; memset(f,-0x3f,sizeof(f));
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++) cin>>g[i][j];
	for (int i=1;i<4;i++) f[0][0][i]=0;
	if (m==1)
{
	for (int i=1;i<=n;i++)
	for (int j=0;j<=k;j++) //有可能到i时候还一个都不选，从0开始 
	{
		f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
		if (j) f[i][j][1]=max(f[i-1][j][1],max(f[i-1][j-1][0],f[i-1][j-1][1]))+g[i][1];//两个状态 
	}
	cout<<max(f[n][k][0],f[n][k][1])<<endl;
}
else {
	for (int i=1;i<=n;i++)
	for (int j=0;j<=k;j++)
	{
		forq f[i][j][0]=max(f[i][j][0],f[i-1][j][q]);
		if (j){
			 f[i][j][1]=max(f[i][j][1],max(f[i-1][j][1],f[i-1][j][4])+g[i][2]);  
		forq f[i][j][1]=max(f[i][j][1],f[i-1][j-1][q]+g[i][2]);
		} 		
		if (j){
			 f[i][j][2]=max(f[i][j][2],max(f[i-1][j][2],f[i-1][j][4])+g[i][1]);
		forq f[i][j][2]=max(f[i][j][2],f[i-1][j-1][q]+g[i][1]);
		
		}
		if (j){
			 f[i][j][3]=max(f[i][j][3],f[i-1][j][3]+g[i][1]+g[i][2]); //合并 
		forq f[i][j][3]=max(f[i][j][3],f[i-1][j-1][q]+g[i][1]+g[i][2]); //重起炉灶 
		}	
		if (j>1){ //想想看也应该从2个栏开始转移了。。 
			 f[i][j][4]=max(f[i][j][4],max(max(f[i-1][j-1][1],f[i-1][j-1][2]),f[i-1][j][4])+g[i][1]+g[i][2]);
		for(int q=0;q<=4;q++)
			 f[i][j][4]=max(f[i][j][4],f[i-1][j-2][q]+g[i][1]+g[i][2]); //重起炉灶 
		} 
	}
	for (int j=0;j<=4;j++) ans=max(ans,f[n][k][j]);
	cout<<ans<<endl;
}
}

```

思路还是挺清晰的吧，代码也不长，看在我写了近一个小时的份上给个赞吧QAQ。

---

## 作者：孤寂的时代 (赞：48)

O（Nk）时间复杂度0ms过

只有一列的不用说吧，我说下两列的

考虑每一行的状态

0 空出这一行

1 选择左边空出右边

2 选择右边空出左边

3 选择这一行两个（不作为一个矩阵，而是左边一列单独一个矩阵，右边单独一个矩阵）

4 选择这一行两个（两个一块作为一个矩阵的一部分）

定义f[i,j,k]为当前处理到第i行，已经选了j个矩阵，当前行状态为k的最大值（k为上面的0-4种状态）

如果空出这一行，则j不需要变化，直接继承上一行的各种状态的最大值

f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1],f[i-1][j][2],f[i-1][j][3],f[i-1][j][4]);

如果选择左边空出右边，如果上一行的左边没有单独地选择成为矩阵的话（即选择1或3），则j需要包含新选择成为的矩阵（即这一行的左边的这个矩阵）,

如果上一行为同时选择两列的为一个矩阵的状态，则只选择单独的左边是不能包含进去上一行的矩阵的，所以也应j-1(t1为这一行左边的值)

f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j][1],f[i-1][j-1][2],f[i-1][j][3], f[i-1][j-1][4])+t1;

右边同理(t2为这一行右边的值)

f[i][j][2]=max(f[i-1][j-1][0],f[i-1][j-1][1],f[i-1][j][2],f[i-1][j][3], f[i-1][j-1][4])+t2;

选择两个分别单独作为矩阵，类似只选择左边或右边，不过是单独选左边和右边合并了下

f[i][j][3]=max(f[i-1][j-1][1],f[i-1][j-1][2],f[i-1][j][3])+t1+t2;

if(j>=2) f[i][j][3]=max(f[i][j][3],f[i-1][j-2][4]+t1+t2);

选择两个作为一个矩阵，则上一行除了可以接上的，都得j-1

f[i][j][4]=max(f[i-1][j-1][0],f[i-1][j-1][1],f[i-1][j-1][2],f[i-1][j-1][3],f[i-1][j][4])+t1+t2;


代码：




```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=0x3f3f3f3f;
const int maxn=105;
const int maxk=11;
int f[maxn][maxk][5];
int main(){
    int n,m,k,t;
    scanf("%d%d%d",&n,&m,&k);
    if(m==1){
        for(int i=1;i<=n;i++){
            scanf("%d",&t);
            for(int j=1;j<=k;j++){
                f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0])+t;
                f[i][j][0]=max(f[i-1][j][1],f[i-1][j][0]);
            }
        }
        printf("%d",max(f[n][k][0],f[n][k][1]));
    }
    else{
        memset(f,-INF,sizeof(f));
        for(int i=0;i<=n;i++){
            for(int j=0;j<=k;j++){
                f[i][j][0]=0;
            }
        }
        int t1,t2;
        for(int i=1;i<=n;i++){
            scanf("%d%d",&t1,&t2);
            for(int j=1;j<=k;j++){
                f[i][j][0]=max( max(f[i-1][j][0],f[i-1][j][1]), max(f[i-1][j][2],f[i-1][j][3]));
                f[i][j][0]=max(f[i][j][0],f[i-1][j][4]);
                f[i][j][1]=max( max(f[i-1][j-1][0],f[i-1][j][1]), max(f[i-1][j-1][2],f[i-1][j][3]))+t1;
                f[i][j][1]=max(f[i][j][1], f[i-1][j-1][4]+t1);
                f[i][j][2]=max( max(f[i-1][j-1][0],f[i-1][j-1][1]), max(f[i-1][j][2],f[i-1][j][3]))+t2;
                f[i][j][2]=max(f[i][j][2], f[i-1][j-1][4]+t2);
                f[i][j][3]=max(f[i-1][j-1][1],max(f[i-1][j-1][2],f[i-1][j][3]))+t1+t2;
                if(j>=2) f[i][j][3]=max(f[i][j][3],f[i-1][j-2][4]+t1+t2);
                f[i][j][4]=max( max(f[i-1][j-1][0],f[i-1][j-1][1]),max(f[i-1][j-1][2],f[i-1][j-1][3]))+t1+t2;
                f[i][j][4]=max(f[i][j][4],f[i-1][j][4]+t1+t2);
                //printf("f[%d][%d]:0=%d 1=%d 2=%d 3=%d 4=%d\n",i,j,f[i][j][0],f[i][j][1],f[i][j][2],f[i][j][3],f[i][j][4]);
            }
        }
        printf("%d",max( max( max(f[n][k][0],f[n][k][1]), max(f[n][k][2],f[n][k][3])),f[n][k][4]));
    }
    return 0;
}
```

---

## 作者：bzy369258147 (赞：29)

强行吐槽一下其他题解的代码，丑破天际线(别打我),为了形成鲜明对比，我先附上我的代码:
```
#include<bits/stdc++.h>
using namespace std;

int dp[105][15][5];
int mp[105][2];

int main(){
    int n,m,k;cin >> n >> m >> k;
    for(int i = 1;i <= n;i ++)for(int j = 0;j < m;j ++)cin >> mp[i][j];
    for(int i = 1;i <= n;i ++){
        int add0 = 0;
        int add1 = mp[i][0];
        int add2 = mp[i][1];
        int add3 = mp[i][0] + mp[i][1];
        for(int j = 1;j <= k;j ++){
            for(int u = 0;u <= 4;u ++)
            dp[i][j][0] = max( dp[i][j][0],dp[i-1][j][u] + add0 );
            dp[i][j][1] = max( dp[i][j][1],dp[i-1][j][1] + add1 );
            dp[i][j][1] = max( dp[i][j][1],dp[i-1][j][3] + add1 );
            dp[i][j][1] = max( dp[i][j][1],dp[i-1][j-1][0] + add1 );
            dp[i][j][1] = max( dp[i][j][1],dp[i-1][j-1][2] + add1 );
            dp[i][j][1] = max( dp[i][j][1],dp[i-1][j-1][4] + add1 );
            dp[i][j][2] = max( dp[i][j][2],dp[i-1][j][2] + add2 );
            dp[i][j][2] = max( dp[i][j][2],dp[i-1][j][3] + add2 );
            dp[i][j][2] = max( dp[i][j][2],dp[i-1][j-1][0] + add2 );
            dp[i][j][2] = max( dp[i][j][2],dp[i-1][j-1][1] + add2 );
            dp[i][j][2] = max( dp[i][j][2],dp[i-1][j-1][4] + add2 );
            dp[i][j][4] = max( dp[i][j][4],dp[i-1][j][4] + add3 );
            dp[i][j][4] = max( dp[i][j][4],dp[i-1][j-1][0] + add3 );
            dp[i][j][4] = max( dp[i][j][4],dp[i-1][j-1][1] + add3 );
            dp[i][j][4] = max( dp[i][j][4],dp[i-1][j-1][2] + add3 );
            dp[i][j][4] = max( dp[i][j][4],dp[i-1][j-1][3] + add3 );
            if( j == 1 )continue;
            dp[i][j][3] = max( dp[i][j][3],dp[i-1][j][3] + add3 );
            dp[i][j][3] = max( dp[i][j][3],dp[i-1][j-2][0] + add3 );
            dp[i][j][3] = max( dp[i][j][3],dp[i-1][j-2][4] + add3 );
            dp[i][j][3] = max( dp[i][j][3],dp[i-1][j-1][1] + add3 );
            dp[i][j][3] = max( dp[i][j][3],dp[i-1][j-1][2] + add3 );
        }
    }
    int ans = 0;
    for(int i = 0;i <= k;i ++)for(int j = 0;j <= 4;j ++)ans = max( ans,dp[n][i][j] );
    cout << ans;
    return 0;
}
```

时间复杂度O(nk),有个5m的常数,这个应该是没有疑问的
但是这个题目看上去情况数多到恶心，我们考虑来优化代码复杂度

对代码复杂度的几个优化:

## first,m <= 2

m<=2是本题做题的关键，也是一个优化代码复杂度的一个机会，

m<=2,则m的取值只有1和2，所以没有必要再对m开一层循环，可以直接展开考虑，代码长度虽然增加了，但是也体现了~~码农风~~工业美,对于m=1我们发现把第二列全部填为0，答案没有影响，所以也不必要分开讨论，直接当成m=2做即可.

## second,每次考虑转移到当前状态

很容易想到对于某一个位置，只有5种状态，

1. 目前的两个数字，不属于任何矩形
2. 目前的两个数字，只有左边属于一个矩形
3. 目前的两个数字，只有右边属于一个矩形
4. 目前的两个数字，分别属于不同的矩形
5. 目前的两个数字，都属于同一个矩形

考虑转移到当前状态，只要枚举当前的状态与上一状态即可，对于某些转移，使用的矩阵数量一定会增加，而对于不一定会增加的，我们钦定它不增加，这样答案一定不会更劣，我们只要考虑枚举使用几个矩阵即可代替选了空矩阵的情况.

## third，展开转移

由于这题有25中转移，每种转移都各不相同，所以展开以后可以看起来比用循环来的清爽.

如果你有更优秀的代码，欢迎把我踩下去.

---

## 作者：interestingLSY (赞：21)

## 此篇题解为下面几篇的小优化（如何把代码写短）请先阅读透其他题解之后再来qwq

咳咳，思路楼下（楼上？）的dalao已经说得非常好了。

只不过。。。您们的代码好长啊！！！

### 那么在这里，我将介绍，怎么写出一份**短小精悍**的代码

话不多说，先上菜（下面有讲解

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rg register
#define INF 0x3f3f3f3f
#define max(a,b) ((a)>(b)?(a):(b))
#define Mymax(a,b) ((a)=max(a,b))
#define Msn(a,x) memset(a,x,sizeof a)
#define For(i,j) for( rg int (i) = 1 ; (i) <= (j) ; ++(i) )
#define For0(i,j) for( rg int (i) = 0 ; (i) < (j) ; ++(i) )
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
#define MAXN 110
#define MAXM 4
#define MAXK 12
const int Tran[6][6] = {
	{0,0,0,0,0},
	{1,0,1,1,0},
	{1,1,0,1,0},
	{1,1,1,0,2},
	{2,1,1,2,0}
};
const int sel[6][3] = {
	{0,0},
	{1,0},
	{0,1},
	{1,1},
	{1,1}
};

int n,m,k;
int a[MAXN][MAXM];

int mem[MAXN][MAXK][6];
#define NOW mem[pos][used][stat]
int Dfs( int pos , int used , int stat ){
	if( used + Tran[stat][0] > k ) return -INF;
	if( pos == n+1 ) return 0;
	if( NOW != -1 ) return NOW;	// 记忆化

	int ans = -INF;
	For0(ns,5){
		int tans = Dfs(pos+1,used+Tran[stat][ns],ns) + sel[ns][0]*a[pos][1] + sel[ns][1]*a[pos][2];
		Mymax(ans,tans);
	}

	return NOW = ans;
}

int main(){
	Msn(mem,-1);

	cin >> n >> m >> k;
	For(i,n)
		For(j,m)
			cin >> a[i][j];

	int ans = Dfs(1,0,0);
	cout << ans << endl;

	return 0;
}
```

哇好短啊

参照楼下的思路，我们的stat表示上一列的状态

- 0 空出这一行

- 1 选择左边空出右边

- 2 选择右边空出左边

- 3 选择这一行两个（两个一块作为一个矩阵的一部分）

- 4 选择这一行两个（不作为一个矩阵，而是左边一列单独一个矩阵，右边单独一个矩阵）

（这是楼下的思路，**同时请注意状态3,4的顺序有所不同**）

那么需要分类讨论吗？不用！

其实，核心就是两个二维数组(矩阵?)—— $Tran$ 和 $Sel$

- $Tran_{i,j}$ 记录从状态 $i$ 到状态 $j$ ，需要 “截止” 当前多少矩阵（我在dp时，$used$ 中**不包含**当前还没截止的矩阵

- $Sel_{i,j}$ 记录状态 $i$ 是否选第 $j+1$ 列（数组下标从0开始）

所以，转移的时候直接从 $Dfs(pos,used,stat)$ 转移到 $Dfs(pos+1,used+Tran_{stat,newstat},newstat)$ 即可！

但是我们怎么判断当前状态是否超出了 “只能选k个” 的限制？

直接在递归调用时判断，当然会很麻烦。

那怎么办？直接给下一波dfs判断就行！具体的，判断 $Tran_{stat,0}+used$ 是不是小于等于 $k$!

---

## 作者：青丘杨哲 (赞：10)

## **$Step$ $1$：题目链接**

$P2331$ [$SCOI2005$] 最大子矩阵：

https://www.luogu.org/problemnew/show/P2331

## **$Step$ $2$：题目大意**

题目大意：在$N×M$的矩阵中选出$k$个互不重叠的子矩阵使得这$k$个子矩阵的元素之和最大。其中$N≤100$，$M≤2$，$k≤10$。

## $Step$ $3$：解法

解法：记输入的矩阵的第$i$行第$j$列个数为$a[i][j]$。本题为显然的$DP$。因为$M≤2$，所以$DP$时完全不需要将$M$作为一个维度。然后分两种情况讨论：

$1.$当$m=1$，即整个矩阵就是一列时，问题转化为求该竖序列的最大的$k$个子段和。这个问题有复杂度为$O(n$ $log$ $n)$的线段树解法，但是对于本题$O(n^3)$的算法足矣。

令$s[i]=\sum_{1}^{i}a[1][i]$，$dp[i][j]$表示前$i$个数中选了$j$段的最大答案，则有方程：

$dp[i][j]=max(dp[k][j-1]+s[i]-s[k])$

其中$1≤i≤N$，$1≤j≤K$,$0≤k≤i-1$。$dp[k][j-1]+s[i]-s[k]$的含义是在$a[1][1]$至$a[1][k]$的数中选择$j-1$个子段的最大答案加上$a[1][k+1]$到$a[1][i]$的这一个子段之和。由此可以进行转移。

此时的最终答案为$dp[N][K]$。

$2.$当$m=2$时，即整个矩阵由两列组成时。这时我们令$s_1[i]=\sum_{1}^{i}a[1][i]$，$s_2[i]=\sum_{1}^{i}a[2][i]$。

令$dp[j][k][i]$表示第一列选到前$j$个数，第二列选到前$k$个数，一共选了$i$段的最大答案。则我们首先有最基础的转移：

$dp[j][k][i]=max(dp[j-1][k][i],dp[j][k-1][i])$

转移条件为$1≤j,k≤N$，$1≤i≤K$。由于$i$是最基本的阶段，因此对$i$的枚举要放在最外层。

随后我们分别枚举两列的上一次进度情况进行转移：

$dp[j][k][i]=max(dp[l][k][i-1]+s1[j]-s1[l])$

此时$0≤l≤j-1$；

$dp[j][k][i]=max(dp[j][l][i-1]+s2[k]-s2[l])$

此时$0≤l≤k-1$。

对于第一个方程的解释：枚举上一次在第一列的进度$l$，则转移为最大的上一阶段的答案加上$a[1][l+1]$到$a[1][j]$的和；

对于第二个方程的解释：枚举上一次在第二列的进度$l$，则转移为最大的上一阶段的答案加上$a[2][l+1]$到$a[2][k]$的和。

最后还有一个特殊的情况：

若$j=k$，即两列的进度相同，则我们还有一个特殊的转移：

$dp[j][k][i]=max(dp[l][l][i-1]+s1[j]-s1[l]+s2[k]-s2[l])$

此时$0≤l≤j-1$。

该方程的解释：枚举两列上一次的相同进度$l$，则转移为上一阶段的最大答案加上$a[1][l+1]$到$a[1][j]$与$a[2][l+1]$到$a[2][k]$的和。

这样，我们就完成了所有可能的转移。对于这种情况，我们的答案是$dp[N][N][K]$。

## **$Step$ $4$：参考程序**

```cpp

#include<bits/stdc++.h>
using namespace std;
const int MAXN=105;
const int MAXM=15;
int N,M,K,k,x,y,sum[MAXN],s1[MAXN],s2[MAXN];
int f[MAXN][MAXN][MAXM],dp[MAXN][MAXM];
int main(){
	scanf("%d%d%d",&N,&M,&K);
	if (M==1){
		for (int i=1;i<=N;i++)
			scanf("%d",&k),sum[i]=sum[i-1]+k;
		for (int i=1;i<=N;i++)
			for (int j=1;j<=K;j++){
				dp[i][j]=dp[i-1][j];
				for (int k=0;k<=i-1;k++)
					dp[i][j]=max(dp[i][j],dp[k][j-1]+sum[i]-sum[k]);
			}
		printf("%d",dp[N][K]);
	}
	else{
		for (int i=1;i<=N;i++){
			scanf("%d%d",&x,&y);
			s1[i]=s1[i-1]+x,s2[i]=s2[i-1]+y;
		}
		for (int i=1;i<=K;i++)
			for (int j=1;j<=N;j++)
				for (int k=1;k<=N;k++){
					f[j][k][i]=max(f[j-1][k][i],f[j][k-1][i]);
					for (int l=0;l<=j-1;l++)
						f[j][k][i]=max(f[j][k][i],f[l][k][i-1]+s1[j]-s1[l]);
					for (int l=0;l<=k-1;l++)
						f[j][k][i]=max(f[j][k][i],f[j][l][i-1]+s2[k]-s2[l]);
					if (j==k)
						for (int l=0;l<=j-1;l++)
							f[j][k][i]=max(f[j][k][i],f[l][l][i-1]+s1[j]-s1[l]+s2[k]-s2[l]);
				}
		printf("%d",f[N][N][K]);
	}
	return 0;
}
```

## **$Step$ $5$：结束语**

这是缘，亦是命中最美的相见。

$This$ $is$ $fate$,$and$ $also$ $the$ $most$ $beautiful$ $meeting$ $in$ $life$.

$The$ $End$.

---

## 作者：mikechu (赞：6)

做完翻了一下题解，觉得一个大家都赞的第二篇似乎只能得30分。

因为关于空矩阵有很多毒瘤的事情。。。。。。

于是我也给出了（同）一种状压dp的做法

这样可以做m<=12。

//做过最大区间、双最大区间、k最大区间，先在来双排k最大子矩阵、m排k最大子矩阵QAQ

普通的最大子矩阵还不会呢......

状态：dp[i][j][k]表示前i行选了j个矩阵，第i行的选的集合为k

（k使用二进制）

即：当k=00时，第i行没有选

当k=01时，第i行选了第二个

当k=10时，第i行选了第一个

当k=11时，第i行两个都选了

然后我们发现，k=11时状态有后效性，非常致命。

于是k=11时认为选的两个是在一个矩阵的。

k=100认为它们分开了。

于是可以得到
```cpp
int mxa(int i,int j,int k,int x){
	int ans = -10000000;
	for(int o=0;o<=x;o++){
		ans = max(ans,dp[i][j-o][k]);
	}
	return ans;
}
```
```cpp
dp[i][j][0] = max(max(dp[i-1][j][0],dp[i-1][j][1]),max(dp[i-1][j][2],max(dp[i-1][j][3],dp[i-1][j][4])));
dp[i][j][1] = max(max(dp[i-1][j-1][0],max(dp[i-1][j-1][1],dp[i-1][j][1])),max(dp[i-1][j-1][2],max(dp[i-1][j-1][3],max(dp[i-1][j][4],dp[i-1][j-1][4])))) + a[i][2];
dp[i][j][2] = max(max(dp[i-1][j-1][0],dp[i-1][j-1][1]),max((max(dp[i-1][j][2],dp[i-1][j-1][2])),max(dp[i-1][j-1][3],max(dp[i-1][j][4],dp[i-1][j-1][4])))) + a[i][1];
dp[i][j][3] = max(max(dp[i-1][j-1][0],dp[i-1][j-1][1]),max(dp[i-1][j-1][2],max(mxa(i-1,j,3,1),dp[i-1][j-1][4]))) + a[i][1] + a[i][2];
dp[i][j][4] = max(max(dp[i-1][j-1][4],dp[i-1][j][4]),max(dp[i-1][j-1][1],dp[i-1][j-1][2])) + a[i][1] + a[i][2];
if(j>=2) dp[i][j][4]=max(dp[i][j][4],max(dp[i-1][j-2][4],max(max(dp[i-1][j-2][0],dp[i-1][j-2][3]),max(dp[i-1][j-2][1],dp[i-1][j-2][2]))) + a[i][1] + a[i][2]);
```

需要注意的是矩阵可以拆开，但不能是空的。所以有好几地方max嵌套的特别多。不写dp[i-1][j][4],要写max(dp[i-1][j-1][4],dp[i-1][j][4]),表示这里可以拆开。

记录答案只要记录max(dp[n][k][0~4]),否则做的那么多就都白费了。

上完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,i,j,k,a[110][3],dp[110][20][5];//3整4分 
int mxa(int i,int j,int k,int x){
	int ans = -10000000;
	for(int o=0;o<=x;o++){
		ans = max(ans,dp[i][j-o][k]);
	}
	return ans;
}
int main(){
	memset(dp,-48,sizeof(dp));
	//memset(dp,0,sizeof(dp));
	cin >> n >> m >> p;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			cin >> a[i][j];
		}
	}
	for(i=0;i<=109;i++){
		dp[i][0][0] = 0;
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=p;j++){
			dp[i][j][0] = max(max(dp[i-1][j][0],dp[i-1][j][1]),max(dp[i-1][j][2],max(dp[i-1][j][3],dp[i-1][j][4])));
			dp[i][j][1] = max(max(dp[i-1][j-1][0],max(dp[i-1][j-1][1],dp[i-1][j][1])),max(dp[i-1][j-1][2],max(dp[i-1][j-1][3],max(dp[i-1][j][4],dp[i-1][j-1][4])))) + a[i][2];
			dp[i][j][2] = max(max(dp[i-1][j-1][0],dp[i-1][j-1][1]),max((max(dp[i-1][j][2],dp[i-1][j-1][2])),max(dp[i-1][j-1][3],max(dp[i-1][j][4],dp[i-1][j-1][4])))) + a[i][1];
			dp[i][j][3] = max(max(dp[i-1][j-1][0],dp[i-1][j-1][1]),max(dp[i-1][j-1][2],max(mxa(i-1,j,3,1),dp[i-1][j-1][4]))) + a[i][1] + a[i][2];
			dp[i][j][4] = max(max(dp[i-1][j-1][4],dp[i-1][j][4]),max(dp[i-1][j-1][1],dp[i-1][j-1][2])) + a[i][1] + a[i][2];
			if(j>=2) dp[i][j][4]=max(dp[i][j][4],max(dp[i-1][j-2][4],max(max(dp[i-1][j-2][0],dp[i-1][j-2][3]),max(dp[i-1][j-2][1],dp[i-1][j-2][2]))) + a[i][1] + a[i][2]);
//			printf("dp[%d][%d][0] = %d\n",i,j,dp[i][j][0]);
//			printf("dp[%d][%d][1] = %d\n",i,j,dp[i][j][1]);
//			printf("dp[%d][%d][2] = %d\n",i,j,dp[i][j][2]);
//			printf("dp[%d][%d][3] = %d\n",i,j,dp[i][j][3]);
//			printf("dp[%d][%d][4] = %d\n",i,j,dp[i][j][4]);
		}
	}
	cout << max(max(dp[n][p][0],dp[n][p][1]),max(dp[n][p][2],max(dp[n][p][3],dp[n][p][4]))) << endl;
}
```

---

## 作者：XZYQvQ (赞：5)

//安利自己的博客QvQ：[http://www.k-xzy.xyz/archives/4137](http://www.k-xzy.xyz/archives/4137)
# 最大子矩阵 题解 —— By 蒟蒻XZY
## MMP

巨大坑点！——

空矩阵也是子矩阵！

也就是说题目可以转换成——

选择至多k个子矩阵互不重叠使得所选部分权值之和最大。

## 正文

貌似还有一些什么$O(n^2k)$啊之类的题解

好像甚至还有$O(n^4)$的算法？

不清楚

我用的是**记忆化搜索**，代码冗长，但是复杂度是$O(nk)$的

复杂度还是很优秀的吧QvQ

### 对于m=1

首先规定$a$表示原矩阵，$a[i,j]$表示矩阵第$i$行第$j$列的数字（$i$从$1$开始，$j$从$0$开始）。

设$f[i,j,k]$表示当前Dp到第$i$行且第$i$行的决策为$k$且已经建立了$j$个子矩阵。

$k=0$或$1$，其中$0$表示不选择第$i$行的那个数字，$1$表示选择。

$j$只是新建了多少个子矩阵，其中可能有未完成的矩阵（还要往里面添加数字），也有可能有已经完成的矩阵。

现在我们需要分类讨论：

(1) 当前为第$i$行，且选择这一行

这种情况下，如果不选择下一行，那么$f[i,j,1]=f[i+1,j,0]+a[i,0]$

如果选择下一行，那我们有两种决策：一是把下一行合并到第$i$行的矩阵里来，二是把下一行作为一个新的矩阵的开头。

那么$f[i,j,1]=max(f[i+1,j,1],f[i+1,j+1,1])+a[i,0]$

综上：$f[i,j,1]=max(f[i+1,j,0],f[i+1,j,1],f[i+1,j+1,1])+a[i,0]$

(2) 当前为第$i$行，且不选择这一行

这种情况下，如果不选择下一行，那么$f[i,j,0]=f[i+1,j,0]$

如果选择下一行，因为必须新建一个矩阵，所以$f[i,j,0]=f[i+1,j+1,1]$

综上：$f[i,j,0]=max(f[i+1,j,0],f[i+1,j+1,1])$


这样我们就得到了$m=1$时的递推式

### 对于m=2

我们可以仿照$m=1$的时候的做法

对于状态的设定依然是（不用仔细看了和$m=1$的是一样的我复制过来的QvQ）：

设$f[i,j,k]$表示当前Dp到第$i$行且第$i$行的决策为$k$且已经建立了$j$个子矩阵。

（注意这下面不一样了=。=）

对于$k$，我们这样设定：

$k$の取值|所代表意义
-|-
0|这一行两个数字都不选
1|选择这一行左边的不选择右边的
2|选择这一行右边的不选择左边的
3|选择这一行的两个数字且合并到一个矩阵内
4|选择这一行的两个数字且分开作为两个矩阵看待

接着，我们依然需要分类讨论。

(1) $k=0$，这一行两个数字都不选

此时下一行的决策有如下几种情况：

- 不选择下一行，$f[i,j,0]=f[i+1,j,0]$
- 选择下一行的左边不选择右边：$f[i,j,0]=f[i+1,j+1,1]$
- 选择下一行的右边不选择左边：$f[i,j,0]=f[i+1,j+1,2]$
- 选择下一行的两个并放到一个矩形内：$f[i,j,0]=f[i+1,j+1,3]$
- 选择下一行的两个并不放到一个矩形内：$f[i,j,0]=f[i+1,j+2,4]$

取$max$即可

(2) $k=1$，选择这一行左边的不选择右边的

此时下一行的决策有如下几种情况：

- 不选择下一行，$f[i,j,1]=f[i+1,j,0]+a[i,0]$
- 选择下一行的左边不选择右边：$f[i,j,1]=max(f[i+1,j,1],f[i+1,j+1,1])+a[i,0]$（因为可以将下一行合并到当前行作为一个矩阵也可以新建矩阵）
- 选择下一行的右边不选择左边：$f[i,j,1]=f[i+1,j+1,2]+a[i,0]$
- 选择下一行的两个并放到一个矩形内：$f[i,j,1]=f[i+1,j+1,3]+a[i,0]$（因为此时下一行是一个完整的宽度为2的矩形，无法合并到当前行）
- 选择下一行的两个并不放到一个矩形内：$f[i,j,1]=max(f[i+1,j+1,4],f[i+1,j+2,4])+a[i,0]$（因为此时下一行会出现两个小的分开的格子，可以将左边的那个合并到当前行，也可以将两个都视作新建的矩阵）

依然是取$max$

(3) $k=2$，选择这一行右边的不选择左边的

此时下一行的决策有如下几种情况：

- 不选择下一行，$f[i,j,2]=f[i+1,j,0]+a[i,1]$
- 选择下一行的左边不选择右边：$f[i,j,2]=f[i+1,j+1,1]+a[i,1]$
- 选择下一行的右边不选择左边：$f[i,j,2]=max(f[i+1,j,2],f[i+1,j+1,2])+a[i,1]$（因为可以将下一行合并到当前行作为一个矩阵也可以新建矩阵）
- 选择下一行的两个并放到一个矩形内：$f[i,j,2]=f[i+1,j+1,3]+a[i,1]$（因为此时下一行是一个完整的宽度为2的矩形，无法合并到当前行）
- 选择下一行的两个并不放到一个矩形内：$f[i,j,2]=max(f[i+1,j+1,4],f[i+1,j+2,4])+a[i,1]$（因为此时下一行会出现两个小的分开的格子，可以将右边的那个合并到当前行，也可以将两个都视作新建的矩阵）

还是取$max$

(4) $k=3$，选择这一行的两个数字且合并到一个矩阵内

- 不选择下一行，$f[i,j,3]=f[i+1,j,0]+a[i,0]+a[i,1]$
- 选择下一行的左边不选择右边：$f[i,j,3]=f[i+1,j+1,1]+a[i,0]+a[i,1]$
- 选择下一行的右边不选择左边：$f[i,j,3]=f[i+1,j+1,2]+a[i,0]+a[i,1]$
- 选择下一行的两个并放到一个矩形内：$f[i,j,3]=max(f[i+1,j,3],f[i+1,j+1,3])+a[i,0]+a[i,1]$
- 选择下一行的两个并不放到一个矩形内：$f[i,j,3]=f[i+1,j+2,4]+a[i,0]+a[i,1]$（虽然它们都选择一行的两个，但是是不能合并的！）

继续取$max$

(4) $k=4$，选择这一行的两个数字且分开作为两个矩阵看待

- 不选择下一行，$f[i,j,4]=f[i+1,j,0]+a[i,0]+a[i,1]$
- 选择下一行的左边不选择右边：$f[i,j,4]=max(f[i+1,j,1],f[i+1,j+1,1])+a[i,0]+a[i,1]$
- 选择下一行的右边不选择左边：$f[i,j,4]=max(f[i+1,j,2],f[i+1,j+1,2])+a[i,0]+a[i,1]$
- 选择下一行的两个并放到一个矩形内：$f[i,j,4]=f[i+1,j+1,3]+a[i,0]+a[i,1]$
- 选择下一行的两个并不放到一个矩形内：$f[i,j,4]=max(f[i+1,j,4],f[i+1,j+1,4],f[i+1,j+2,4])+a[i,0]+a[i,1]$（可以选择合并两个矩形、合并其中一个或者一个都不合并）

QvQ仍然取$max$

经过~~艰苦卓绝~~的分类讨论，我们得到了$m=2$时的递推式

很显然，复杂度是$O(nk)$的！

至此，我们就可以写出这题的代码啦！

代码：
```cpp
#include <bits/stdc++.h>

#define NS (105)
#define KS (15)
#define INF (10000000)
#define MEM (-2122219135)

using namespace std;

template <typename _Tp> inline void IN(_Tp& dig)
{
	char c; bool flag = 0; dig = 0;
	while (c = getchar(), !isdigit(c)) if (c == '-') flag = 1;
	while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
	if (flag) dig = -dig;
}

int n, m, k, arr[NS][2], f[NS][KS][5];

int Dp1(int a, int s, int c)
{
	if (s > k) return -INF;
	if (a > n) return 0;
	int& F = f[a][s][c];
	if (F != MEM) return F;
	if (c == 1)
	{
		F = max(Dp1(a + 1, s, 1), Dp1(a + 1, s + 1, 1));
		F = max(F, Dp1(a + 1, s, 0)) + arr[a][0];
		return F;
	}
		F = max(Dp1(a + 1, s + 1, 1), Dp1(a + 1, s, 0));
		return F;
}

int Dp2(int a, int s, int c)
{
	if (s > k) return -INF;
	if (a > n) return 0;
	int& F = f[a][s][c];
	if (F != MEM) return F;
	if (c == 0)
	{
		F = max(Dp2(a + 1, s, 0), Dp2(a + 1, s + 1, 1));
		F = max(F, Dp2(a + 1, s + 1, 2));
		F = max(F, Dp2(a + 1, s + 1, 3));
		F = max(F, Dp2(a + 1, s + 2, 4));
		return F;
	}
	if (c == 1)
	{
		F = max(Dp2(a + 1, s, 1), Dp2(a + 1, s + 1, 1));
		F = max(F, Dp2(a + 1, s, 0));
		F = max(F, Dp2(a + 1, s + 1, 2));
		F = max(F, Dp2(a + 1, s + 1, 3));
		F = max(F, Dp2(a + 1, s + 1, 4));
		F = max(F, Dp2(a + 1, s + 2, 4)) + arr[a][0];
		return F; 
	}
	if (c == 2)
	{
		F = max(Dp2(a + 1, s, 2), Dp2(a + 1, s + 1, 2));
		F = max(F, Dp2(a + 1, s, 0));
		F = max(F, Dp2(a + 1, s + 1, 1));
		F = max(F, Dp2(a + 1, s + 1, 3));
		F = max(F, Dp2(a + 1, s + 1, 4));
		F = max(F, Dp2(a + 1, s + 2, 4)) + arr[a][1];
		return F; 
	}
	if (c == 3)
	{
		F = max(Dp2(a + 1, s, 3), Dp2(a + 1, s + 1, 3));
		F = max(F, Dp2(a + 1, s, 0));
		F = max(F, Dp2(a + 1, s + 1, 1));
		F = max(F, Dp2(a + 1, s + 1, 2));
		F = max(F, Dp2(a + 1, s + 2, 4)) + arr[a][0] + arr[a][1];
		return F; 
	}
		F = max(Dp2(a + 1, s, 4), Dp2(a + 1, s + 1, 4));
		F = max(F, Dp2(a + 1, s + 2, 4));
		F = max(F, Dp2(a + 1, s, 0));
		F = max(F, Dp2(a + 1, s, 1));
		F = max(F, Dp2(a + 1, s + 1, 1));
		F = max(F, Dp2(a + 1, s, 2));
		F = max(F, Dp2(a + 1, s + 1, 2));
		F = max(F, Dp2(a + 1, s + 1, 3)) + arr[a][0] + arr[a][1];
		return F;
}

int main (int argc, char const* argv[])
{
	IN(n), IN(m), IN(k), memset(f, -127, sizeof(f));
	for (int i = 1; i <= n; i += 1)
		for (int j = 0; j < m; j += 1)
			IN(arr[i][j]);
	if (m == 1) printf("%d\n", max(Dp1(1, 1, 1), Dp1(1, 0, 0)));
	else
	{
		int ans = max(Dp2(1, 0, 0), Dp2(1, 1, 1));
		ans = max(ans, Dp2(1, 2, 1));
		ans = max(ans, Dp2(1, 3, 1));
		ans = max(ans, Dp2(1, 4, 2));
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：__stdcall (赞：5)

大家的方法都是四次方的方法，然而如果这题数据范围大一点怎么办呢？四次方就过不了了

@orbitingflea 给我提供了一种三次方的方法，这里我引用一下

当m=1的时候大家应该都会做，dp[i][j][a]，表示前i行选j个矩阵的最大和，a=0表示不选第i个，a=1表示选第i个，这是经典的模型

当m=2的时候就稍微拓展一下，dp[i][j][l][a]，表示第一列选前i个，第二列选前j个，选了l个矩阵，其中第i个和第j个情况为a的最大和

a=0的时候，表示第一列第i个和第二列第j个都不选

a=1表示选第i个不选第j个（以后略去“第一列”和“第二列”）

a=2表示不选第i个选第j个

a=3表示第i个和第j个都选，且这两个同时属于一个矩阵，即都属于一个宽为2的矩阵，不可分割

a=4表示第i个和第j个都选，且这两个不同时属于一个矩阵，即各自属于一个宽为1的矩阵

至于代码。。。。太多了不想打了，所以本人最后还是写的普遍的四次方算法。

分类讨论的思想在dp中还是很常用的，学习了。同时orz @orbitingflea


---

## 作者：panyf (赞：3)

很裸的DP，状态转移方程没有任何思维难度，作为省选题还是挺水的（毕竟是十几年前的省选）

m=1的情况很好写，对于每一个位置分取和不取两种情况即可

m=2稍微麻烦些，可以分5种情况考虑，分别是：都不取，取左边，取右边，都取（两个矩阵），都取（一个矩阵），具体状态转移方程见代码

这道题转移方程比较复杂，如果都用STLmax函数代码会很长，建议手写max，**加上不定数量传参**，可以明显降低码量

不定数量传参有多种写法，这里提供其中的一种：

```cpp
#include<cstdio>
#include<cstdarg>//专用的头文件
inline int max(int c,...){//c为传参数量
	va_list a;//声明指针
	va_start(a,c);//初始化指针
	register int x=va_arg(a,int),y;//arg函数更新指针的值
	while(--c)y=va_arg(a,int),x=x>y?x:y;//取最大值
	va_end(a);//指针复位
	return x;
}
```
m=1的代码：
```cpp
//f数组第一维为当前到第几行，第二维为还剩几个矩形，第三维为是否取当前行的数
//f数组要初始化为极小值！
for(i=0;i<n;++i){
	scanf("%d",&u);
	for(j=0;j<=k;++j){
		f[i+1][j][0]=max(2,f[i][j][0],f[i][j][1]);//不取当前位置的数
		f[i+1][j][1]=max(3,f[i][j+1][0],f[i][j][1],f[i][j+1][1])+u;//取
	}
}
printf("%d",max(2,f[n][0][0],f[n][0][1]));
```
m=2的代码：
```cpp
for(i=0;i<n;++i){
	scanf("%d%d",&u,&v);
	for(j=0;j<=k;++j){
		f[i+1][j][0]=max(5,f[i][j][0],f[i][j][1],f[i][j][2],f[i][j][3],f[i][j][4]);//都不取
		f[i+1][j][1]=max(7,f[i][j+1][0],f[i][j][1],f[i][j+1][2],f[i][j][3],f[i][j+1][4],f[i][j+1][1],f[i][j+1][3])+u;//取左边
		f[i+1][j][2]=max(7,f[i][j+1][0],f[i][j+1][1],f[i][j][2],f[i][j][3],f[i][j+1][4],f[i][j+1][2],f[i][j+1][3])+v;//取右边
		f[i+1][j][3]=max(9,f[i][j+2][0],f[i][j+1][1],f[i][j+1][2],f[i][j][3],f[i][j+2][4],f[i][j+2][1],f[i][j+2][2],f[i][j+1][3],f[i][j+2][3])+u+v;//都取（两个矩阵）
		f[i+1][j][4]=max(6,f[i][j+1][0],f[i][j+1][1],f[i][j+1][2],f[i][j+1][3],f[i][j][4],f[i][j+1][4])+u+v;//都取（一个矩阵）
	}
}
printf("%d",max(5,f[n][0][0],f[n][0][1],f[n][0][2],f[n][0][3],f[n][0][4]));
```
时间复杂度O(nk)，29ms轻松AC

---

## 作者：olinr (赞：3)

## 蒟蒻太弱了。。蒟蒻什么都不会。。只会乱搞。。

一看$m\le2$，显然乱搞啊

### Part one m=1

这部分很好写把，直接$O(n^2k)$DP就行了

$f[i][k]$表示前i个数，分成k段的最大值，可以预处理一个区间最大子段和转移就行

具体可以看代码

### Part two m=2

我写的可以说是及其恶心。。

一下把两列理解为两个序列a，b

刚开始，我只考虑到了3种情况，因为子矩阵只会有三种形态，a中的一段，b中的一段，a和b合一起大的一段

然后可以预处理出a序列，b序列，ab合一起的序列的区间最大子段和，然后类似于Part One转移

然而，情况并没有考虑全，但是可以拿到70pts

还有什么情况呢？？

比如，我在a中选了$[4,6]$这一段，b中选了$[5,7]$这一段，然而DP中并不会允许两个同时选，因为这样DP会让其误以为重叠！！

所以，蒟蒻想到一个办法，在设一个数组$p[i][j][k]$代表从$[i,j]$选k段的答案

这样转移的时候用p就方便多了

p怎么预处理呢？？ 其实就是n遍Part one

然而。。。。90pts！！！

蒟蒻冥思苦想，大力观察，发现居然还有一种可能！！

比如在b中选了一个长度贼大的区间，在a中选了一大堆长度很小的区间，b这个大区间把这些小区间全部包含了，这种情况并没有转移到p！！

蒟蒻再次冥思苦想，又开了两个数组$ff[i][j][k]$表示在a中从i到j选k段的答案
gg是在b中的，含义同ff

这个还是类型Part one的DP，可以预处理

更新$p[sta][i][l]$的时候，可以用$p[sta][j - 1][l - num] + ff[j][i][r] + gg[j][i][num - r]$

然后终于把p弄完了，DP就行了。。

复杂度O($n^3k^3\times$极小常数)




```cpp
#include<bits/stdc++.h>
#define LL long long
LL in() {
    char ch; LL x = 0, f = 1;
    while(!isdigit(ch = getchar()))(ch == '-') && (f = -f);
    for(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 1) + (x << 3) + (ch ^ 48));
    return x * f;
}
const int inf = 0x3f3f3f3f;
const int maxn = 150;
int n, m, k;
namespace partone {
    int f[maxn][15], d[maxn][maxn], a[maxn];
    void predoit() {
        for(int i = 1; i <= n; i++) a[i] = in();
        for(int i = 1; i <= n; i++) {
            int ans = -inf, now = 0;
            for(int j = i; j <= n; j++) {
                if(now + a[j] < 0) now = 0;
                else now += a[j];
                ans = std::max(ans, now);
                d[i][j] = ans;
            }
        }
    }
    void DP() {
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= k; j++) f[i][j] = -inf;
            for(int j = 1; j <= i; j++)
                for(int l = 1; l <= k; l++)
                    f[i][l] = std::max(f[i][l], f[j - 1][l - 1] + d[j][i]);
        }
        printf("%d\n", f[n][k]);
    }
    int main() {
        predoit();
        DP();
        return 233;
    }
}
namespace parttwo {
 	int d[maxn][maxn][3], f[maxn][15], a[maxn], b[maxn], p[maxn][maxn][15];
 	int ff[maxn][maxn][15], gg[maxn][maxn][15];
 	void predoit() {
        for(int i = 1; i <= n; i++) a[i] = in(), b[i] = in();
        for(int i = 1; i <= n; i++) {
            int ans = -inf, now = 0;
            for(int j = i; j <= n; j++) {
                if(now + a[j] < 0) now = 0;
                else now += a[j];
                ans = std::max(ans, now);
                d[i][j][1] = ans;
            }
        }
        for(int i = 1; i <= n; i++) {
            int ans = -inf, now = 0;
            for(int j = i; j <= n; j++) {
                if(now + b[j] < 0) now = 0;
                else now += b[j];
                ans = std::max(ans, now);
                d[i][j][2] = ans;
            }
        }
        for(int i = 1; i <= n; i++) {
            int ans = -inf, now = 0;
            for(int j = i; j <= n; j++) {
                if(now + a[j] + b[j] < 0) now = 0;
                else now += a[j] + b[j];
                ans = std::max(ans, now);
                d[i][j][0] = ans;
            }
        }
        for(int sta = 1; sta <= n; sta++) {
            for(int i = sta; i <= n; i++) {
                for(int j = 1; j <= k; j++) ff[sta][i][j] = gg[sta][i][j] = -inf;
                for(int j = sta; j <= i; j++)
                    for(int l = 1; l <= k; l++) {
                        ff[sta][i][l] = std::max(ff[sta][i][l], ff[sta][j - 1][l - 1] + d[j][i][1]);
                        gg[sta][i][l] = std::max(gg[sta][i][l], gg[sta][j - 1][l - 1] + d[j][i][2]);
                    }
                }
        }
        for(int sta = 1; sta <= n; sta++) {
            for(int i = sta; i <= n; i++) {
                for(int j = 1; j <= k; j++) p[sta][i][j] = -inf;
                for(int j = sta; j <= i; j++)
                    for(int l = 1; l <= k; l++) {
                        p[sta][i][l] = std::max(p[sta][i][l], p[sta][j - 1][l - 1] + d[j][i][1]);
                        p[sta][i][l] = std::max(p[sta][i][l], p[sta][j - 1][l - 1] + d[j][i][2]);
                        for(int num = 0; num <= l; num++)
                            for(int r = 0; r <= num; r++)
                                p[sta][i][l] = std::max(p[sta][i][l], p[sta][j - 1][l - num] + ff[j][i][num - r] + gg[j][i][r]);
                    }
            }
        }
    }
    void DP() {
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= k; j++) f[i][j] = -inf;
            for(int j = 1; j <= i; j++)
                for(int l = 1; l <= k; l++) {
                    f[i][l] = std::max(f[i][l], f[j - 1][l - 1] + d[j][i][0]);
                    for(int num = 0; num <= l; num++)
                        f[i][l] = std::max(f[i][l], f[j - 1][l - num] + p[j][i][num]);
                }
        }
        printf("%d\n", f[n][k]);
    }
 	int main() {
 		predoit();
 		DP();
 		return 520;
 	}
}
int main() {
    n = in(), m = in(), k = in();
    if(m == 1) partone::main();
    else parttwo::main();
    return 0;
}


```



---

## 作者：Nishikino_Curtis (赞：2)

写完了才发现代码丑得不行……

顺着思路一路强行推下来：
注意到$ m = 1 $时和最大子段和问题是一样的，不妨先来回顾一下：

- 定义状态 $ f[i][j][0/1] $ ，表示前$i$个数字，已经分了$k$段，第$i$个选/不选的最大和。

*当情况扩大到$ m = 2 $时情况则会变得丰富得多。*

我们如何描述进行到第$i$行时行上两个点的状态呢？

最自然的想法是用一个两位的比特来描述，00为两个都不选，10为只选左边，01为只选右边，11为两个都选。然而，尝试转移时却会发现这行不通，因为对于11的局面，我们不知道是由两个分裂的块还是一个整体的块组成的。所以再扩展出第五个状态，用来区分上述两种局面。这时转移已经呼之欲出了：

- 定义状态 $ f[i][j][0/1/2/3/4] $ ，表示前$i$个数字，已经分了$k$块，第$i$行的状态为s的最大和。

方程……我也不知道我哪里来的勇气这样转移，不过思维难度极低。这里以从00局面转移为例，稍加思考不难得出其他方程，也可以参考代码。
$f[i][k][00] = f[i -1][k][00] $
$f[i][k+1][10] = f[i - 1][k][00] + a[i][1], if(k + 1 <= K)$.
$f[i][k+1][01] = f[i - 1][k][00] + a[i][2], if(k + 1 <= K)$.
$f[i][k+2][11_1] = f[i - 1][k][00] + a[i][1] + a[i][2],if(k+2<=K)$
$f[i][k+1][11_2] = f[i-1][k][00] + a[i][1] + a[i][2],if(k+1<=K)$


预处理和边界和子段和问题类似，整体赋$-inf$，$f[0][0][0] = 0$。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using std::min;
using std::max;
using std::swap;
using std::memset;

const int maxn = 105;

int n,m,k,mtr[maxn][3],f[maxn][15][5];

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j)
            scanf("%d",&mtr[i][j]);
    if(m == 1)//最大子段和
    {
        //initiate
        for(int i = 0; i <= n; ++i)
            for(int j = 0; j <= k; ++j)
                f[i][j][1] = f[i][j][0] = -214700;
        f[0][0][0] = 0;
        f[0][0][1] = 0;
        //dp
        for(int i = 1; i <= n; ++i)
            for(int j = 0; j <= k; ++j)
            {
                if(j)f[i][j][1] = max(f[i][j][1], f[i - 1][j][1] + mtr[i][1]);
                if(j)f[i][j][1] = max(f[i][j][1], f[i - 1][j - 1][0] + mtr[i][1]);
                if(j)f[i][j][1] = max(f[i][j][1], f[i - 1][j - 1][1] + mtr[i][1]);
                f[i][j][0] = max(f[i][j][0], f[i - 1][j][1]);
                f[i][j][0] = max(f[i][j][0], f[i - 1][j][0]);
            }	
        printf("%d\n",max(f[n][k][0],f[n][k][1]));
    }
    else
    {
        //initiate
        for(int i = 0 ;i <= n; ++i)
            for(int j = 0; j <= k; ++j)
                for(int s = 0; s < 5; ++s)
                    f[i][j][s] = -214700;
        f[0][0][0] = 0;
        //dp
        for(int i = 1; i <= n; ++i)
            for(int j = 0; j <= k; ++j)
                for(int s = 0; s < 5; ++s)
                {
                    if(s == 0)
                    {
                        f[i][j][0] = max(f[i][j][s], f[i - 1][j][s]);
                        if(j < k)f[i][j + 1][1] = max(f[i][j + 1][1], f[i - 1][j][s] + mtr[i][1]);
                        if(j < k)f[i][j + 1][2] = max(f[i][j + 1][2], f[i - 1][j][s] + mtr[i][2]);
                        if(j < k - 1)f[i][j + 2][3] = max(f[i][j + 2][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k)f[i][j + 1][4] = max(f[i][j + 1][4], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                    }
                    if(s == 1 && j)
                    {
                        f[i][j][0] = max(f[i][j][0], f[i - 1][j][s]);
                        f[i][j][1] = max(f[i][j][1], f[i - 1][j][s] + mtr[i][1]);
                        if(j < k)f[i][j + 1][1] = max(f[i][j + 1][1], f[i - 1][j][s] + mtr[i][1]);
                        if(j < k)f[i][j + 1][2] = max(f[i][j + 1][2], f[i - 1][j][s] + mtr[i][2]);
                        if(j < k)f[i][j + 1][3] = max(f[i][j + 1][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k - 1)f[i][j + 2][3] = max(f[i][j + 2][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k)f[i][j + 1][4] = max(f[i][j + 1][4], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                    }
                    if(s == 2 && j)
                    {
                        f[i][j][0] = max(f[i][j][0], f[i - 1][j][s]);
                        if(j < k)f[i][j + 1][1] = max(f[i][j + 1][1], f[i - 1][j][s] + mtr[i][1]);
                        f[i][j][2] = max(f[i][j][2], f[i - 1][j][s] + mtr[i][2]);
                        if(j < k)f[i][j + 1][2] = max(f[i][j + 1][2], f[i - 1][j][s] + mtr[i][2]);
                        if(j < k)f[i][j + 1][3] = max(f[i][j + 1][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k - 1)f[i][j + 2][3] = max(f[i][j + 2][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k)f[i][j + 1][4] = max(f[i][j + 1][4], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                    }
                    if(s == 3 && j)
                    {
                        f[i][j][0] = max(f[i][j][0], f[i - 1][j][s]);
                        f[i][j][1] = max(f[i][j][1], f[i - 1][j][s] + mtr[i][1]);
                        f[i][j][2] = max(f[i][j][2], f[i - 1][j][s] + mtr[i][2]);
                        if(j < k)f[i][j + 1][1] = max(f[i][j + 1][1], f[i - 1][j][s] + mtr[i][1]);
                        if(j < k)f[i][j + 1][2] = max(f[i][j + 1][2], f[i - 1][j][s] + mtr[i][2]);
                        f[i][j][3] = max(f[i][j][3], f[i-1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k)f[i][j + 1][3] = max(f[i][j + 1][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k - 1)f[i][j + 2][3] = max(f[i][j + 2][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        if(j < k)f[i][j + 1][4] = max(f[i][j + 1][4], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                    }
                    if(s == 4 && j)
                    {
                        f[i][j][0] = max(f[i][j][0], f[i - 1][j][s]);
                        if(j < k)f[i][j + 1][1] = max(f[i][j + 1][1], f[i - 1][j][s] + mtr[i][1]);
                        if(j < k)f[i][j + 1][2] = max(f[i][j + 1][2], f[i - 1][j][s] + mtr[i][2]);
                        if(j < k - 1)f[i][j + 2][3] = max(f[i][j + 2][3], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                        f[i][j][4] = max(f[i][j][4], f[i - 1][j][4] + mtr[i][1] + mtr[i][2]);
                        if(j < k)f[i][j + 1][4] = max(f[i][j + 1][4], f[i - 1][j][s] + mtr[i][1] + mtr[i][2]);
                    }
                }
        int ans = -214700;
        for(int i = 0; i < 5; ++i)
            ans = max(ans, f[n][k][i]);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：xyz32768 (赞：2)

分n=1和n=2两种情况考虑。

n=1时，预处理出前缀和sum[]。

设f[i][j]为到达第i格，已经放了j个子矩阵的最大和，

那么每次先把f[i][j]的值设为f[i-1][j]（第i个元素不属于第j个子矩阵）

剩下的情况就是第i个元素属于第j个子矩阵了。

这时候用max(f[h-1][j-1]+(sum[i]-sum[h-1]), 1<=h<=i)更新f[i][j]的最大值，即枚举第j个子矩阵的起始点。

最终答案为f[m][k]。（边界条件为f[0][j]=0，包含空矩阵）


n=2时，预处理出分别列的前缀和sum1[],sum2[]。

设f[i][j][l]为在第1列到达第i格，第2列到达第j格，已经放了l个子矩阵的最大和，

那么每次先把f[i][j][l]的值设为max(f[i-1][j][l],f[i][j-1][l])（第i行第1列不属于子矩阵或第j行第2列不属于子矩阵，两者取较大值）

剩下的情况就是第i行第1列和第j行第2列都属于子矩阵了。

分两种情况：

一、第i行第1列和第j行第2列属于不同的子矩阵

分别枚举第i行第1列所在子矩阵的起始点和第j行第2列所在子矩阵的起始点并更新答案，

即用max(f[h-1][j][l-1]+(sum1[i]-sum1[h-1]), 1<=h<=i)和max(f[i][h-1][l-1]+(sum2[j]-sum2[h-1]),1<=h<=j)更新f[i][j]的最大值。

二、第i行第1列和第j行第2列属于同一子矩阵

仅当i==j时才包含这种情况（因为i和j要作为当前状态中子矩阵的末尾）。这时候这个子矩阵的列数必定为2。

还是一样枚举子矩阵的起始点，

在i==j的条件下用max(f[h-1][h-1][l-1]+(sum1[i]-sum1[h-1])+(sum2[j]-sum2[h-1]),1<=h<=i)更新答案。

最后答案为f[m][m][k]（边界条件为f[0][0][l]=0，包含空矩阵）

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 105, INF = 0x7fffffff / 3;
int m, n, K, a[N][3], b[N], f[N][N][13], sum1[N], sum2[N],
f0[N][13];
bool comp(int a, int b) {return a > b;}
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
int main() {
    int i, j, k, h;
    m = read(); n = read(); K = read();
    for (i = 1; i <= m; i++)
        for (j = 1; j <= n; j++) {
            a[i][j] = read();
            if (j == 1) sum1[i] = sum1[i - 1] + a[i][j];
            else sum2[i] = sum2[i - 1] + a[i][j];
        }
    if (n == 1) {
        for (i = 1; i <= m; i++) for (j = 1; j <= K; j++) {
            f0[i][j] = f0[i - 1][j];
            for (k = 1; k <= i; k++)
                f0[i][j] = max(f0[i][j], f0[k - 1][j - 1]
                    + (sum1[i] - sum1[k - 1]));
        }
        printf("%d\n", f0[m][K]);
        return 0;
    }
    for (i = 1; i <= m; i++) for (j = 1; j <= m; j++)
    for (k = 1; k <= K; k++) {
        f[i][j][k] = max(f[i - 1][j][k], f[i][j - 1][k]);
        for (h = 1; h <= i; h++)
            f[i][j][k] = max(f[i][j][k],
                f[h - 1][j][k - 1] + (sum1[i] - sum1[h - 1]));
        for (h = 1; h <= j; h++)
            f[i][j][k] = max(f[i][j][k],
                f[i][h - 1][k - 1] + (sum2[j] - sum2[h - 1]));
        if (i == j) for (h = 1; h <= i; h++)
        f[i][j][k] = max(f[i][j][k],
            f[h - 1][h - 1][k - 1] + (sum1[i] - sum1[h - 1])
                + (sum2[j] - sum2[h - 1]));
    }
    printf("%d\n", f[m][m][K]);
    return 0;
}
```

---

## 作者：BPM136 (赞：1)

和大家一样，吐槽一下大家的代码写的好丑
其实我的代码也很丑，主要是可读性很差，但是可以推广到多维的写法（不然n等于5你们还要手推吗）
这里p和q是枚举上一行的选择情况，再用l和o来枚举当前行，然后通过逻辑表达式判断增量，就可以完成转移。
如果是多维，那么可以写成dfs套dfs，第一个dfs枚举上一行，第二个枚举当前行，然后逐一用逻辑表达式判断增量。
在这里如果等于2表示选一长条（多维的话可以多加从l到r）
```cpp
#include <bits/stdc++.h>

using namespace std;

void Remax(int& a, int b) {
	if (b > a) 
		a = b;
}

int const N = 105;

int a[N][3];
int f[N][3][3][12];
int n, m, K;

int main() {
	cin >> n >> m >> K;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			cin >> a[i][j];

	memset(f, -3, sizeof(f));
	int const MIN = f[0][0][0][0];
	// cerr << MIN << '\n';
	f[0][0][0][0] = 0;
	for (int i = 1; i <= n; ++i) {
		for (int k = 0; k <= K; ++k) 
			if (m == 1) {
				for (int p = 0; p <= 1; ++p) 
					if (f[i - 1][p][0][k] != MIN) {
						Remax(f[i][0][0][k], f[i - 1][p][0][k]);
						int ad = p == 1 ? 0 : 1;
						Remax(f[i][1][0][k + ad], f[i - 1][p][0][k] + a[i][1]);
					}
			} else {
				for (int p = 0; p <= 2; ++p) 
					for (int q = (p < 2 ? 0 : 2); q <= (p < 2 ? 1 : 2); ++q) 
						if (f[i - 1][p][q][k] > MIN) {
							for (int l = 0; l <= 2; ++l)
								for (int o = (l < 2 ? 0 : 2); o <= (l < 2 ? 1 : 2); ++o) {
									int ad = ((p != l && l != 0) ? 1 : 0) + ((q != o && o != 0) ? 1 : 0);
									if (l == 2)
										ad = p == 2 ? 0 : 1;
									int t = f[i - 1][p][q][k] + (l > 0 ? a[i][1] : 0) + (o > 0 ? a[i][2] : 0);
									Remax(f[i][l][o][k + ad], t);
								}
						}
			}
	}
	int ans = 0;
	for (int p = 0; p <= 2; ++p)
		for (int q = 0; q <= 2; ++q) 
			Remax(ans, f[n][p][q][K]);
	cout << ans << '\n';
}

```


---

## 作者：Skywalker_David (赞：1)

这道题我想了很久，还准备用状态压缩做。

我的所有dp方程基本上是O(n)或O(nm)的，但是方程就很麻烦。

之后由于某题解给我的灵感，我发现可以分段做宽为2的。

将矩阵拆成两条链来做，是很有必要的。因为每一条取的不同。

由于n较小，可以加一维，复杂度高一点也没有问题。

```delphi

var
  n,m,k:longint;
  f1:array[0..100,0..10]of longint;
  f2:array[0..100,0..100,0..10]of longint;
function max(i,j:longint):longint;
begin
   if i<j then exit(j) else exit(i);
end;
procedure sol1;
var
   s:array[0..100]of longint;
   i,j,p,tmp:longint;
begin
   fillchar(s,sizeof(s),0);
   for i:=1 to n do read(s[i]);
   for i:=1 to n do inc(s[i],s[i-1]);
   for j:=1 to k do
      for i:=1 to n do
      begin
         tmp:=f1[i-1,j];
         for p:=1 to i do tmp:=max(tmp,f1[p-1][j-1]+s[i]-s[p-1]);
         f1[i,j]:=tmp;
      end;
   writeln(f1[n][k]);
end;
procedure sol2;
var
   s:array[1..3,0..100]of longint;
   i,j,p,tmp:longint;
begin
   fillchar(s,sizeof(s),0);
   for i:=1 to n do
      begin
         read(s[1][i]); inc(s[1][i],s[1][i-1]);
         read(s[2][i]); inc(s[2][i],s[2][i-1]);
      end;
   for i:=1 to n do s[3][i]:=s[1][i]+s[2][i];
   for i:=1 to n do
     for j:=1 to n do
       for k:=1 to k do begin
          tmp:=f2[i-1][j-1][k];
          tmp:=max(f2[i][j-1][k],tmp);
          tmp:=max(f2[i-1][j][k],tmp);
          for p:=1 to i-1 do
             tmp:=max(tmp,f2[p-1][j][k-1]+s[1][i]-s[1][p]);
          for p:=1 to j-1 do
             tmp:=max(tmp,f2[i][p-1][k-1]+s[2][j]-s[2][p]);
          if i=j then
            for p:=1 to i-1 do
              tmp:=max(tmp,f2[p][p][k-1]+s[3][j]-s[3][p]);
          f2[i][j][k]:=tmp;
       end;
   writeln(f2[n][n][k]);
end;
begin
  readln(n,m,k);
  if m=1 then sol1 else sol2;
end.

```
（——————终于有P党了。。。。。。————————）


---

## 作者：sqc1999 (赞：1)

这题因为m只有1、2两种情况，所以分开讨论。

\* m=1
这部分还是比较水的，f[i][j]表示前i行选j个矩形的最大分值。

方程f[i][j]=max(f[i-1][j],max{f[k][j-1]+sum[i]-sum[k]|0<=k<=i})（sum是前缀和）

```cpp

#include<iostream>  
#include<algorithm>  
using namespace std;  
int a[101], b[101], f1[101][11], f2[101][101][11], sum1[101], sum2[2][101];  
int main()  
{  
    ios::sync_with_stdio(false);  
    int n, m, k;  
    cin >> n >> m >> k;  
    if (m == 1)  
    {  
        for (int i = 1; i <= n; i++)  
        {  
            cin >> a[i];  
            sum1[i] = sum1[i - 1] + a[i];  
        }  
        for (int i = 1; i <= n; i++)  
        {  
            f1[i][0] = 0;  
            for (int j = 1; j <= k; j++)  
            {  
                f1[i][j] = f1[i - 1][j];  
                for (int l = 1; l < i; l++)  
                {  
                    f1[i][j] = max(f1[i][j], f1[l][j - 1] + sum1[i] - sum1[l]);  
                }  
            }  
        }  
        cout << f1[n][k];  
    }  
    else  
    {  
        for (int i = 1; i <= n; i++)  
        {  
            cin >> a[i] >> b[i];  
            sum2[0][i] = sum2[0][i - 1] + a[i];  
            sum2[1][i] = sum2[1][i - 1] + b[i];  
        }  
        for (int i1 = 1; i1 <= n; i1++)  
        {  
            for (int i2 = 1; i2 <= n; i2++)  
            {  
                f2[i1][i2][0] = 0;  
                for (int j = 1; j <= k; j++)  
                {  
                    f2[i1][i2][j] = max(f2[i1 - 1][i2][j], f2[i1][i2 - 1][j]);  
                    for (int l = 0; l < i1; l++)  
                    {  
                        f2[i1][i2][j] = max(f2[i1][i2][j], f2[l][i2][j - 1] + sum2[0][i1] - sum2[0][l]);  
                    }  
                    for (int l = 0; l < i2; l++)  
                    {  
                        f2[i1][i2][j] = max(f2[i1][i2][j], f2[i1][l][j - 1] + sum2[1][i2] - sum2[1][l]);  
                    }  
                    if (i1 == i2)  
                    {  
                        for (int l = 0; l < i1; l++)  
                        {  
                            f2[i1][i2][j] = max(f2[i1][i2][j], f2[l][l][j - 1] + sum2[0][i1] - sum2[0][l] + sum2[1][i2] - sum2[1][l]);  
                        }  
                    }  
                }  
            }  
        }  
        cout << f2[n][n][k];  
    }  
}

* m=2
f[i][j][k]表示第一列前i行，第二列前j行选k个矩形的最大分值，方程和m=1是较相似，但多了i=j时的情况，叙述比较麻烦，具体看我的程序好了。

```

---

## 作者：一只书虫仔 (赞：0)

~~奇怪分讨题~~

#### Description

> 给定一个 $n \times m$ 的矩阵，求选择他的 $k$ 个子矩阵使得矩阵数之和最大，求这个最大和。

#### Solution

注意数据范围，$1 \le m \le 2$，所以分 $m$ 的值进行讨论。

首先 $m=1$，就是选择 $k$ 个段使得和最大，定义 $f_{i,j,0/1}$ 为到第 $i$ 个数已经选择了 $j$ 个子矩阵，是否选择第 $i$ 个数，和最大是多少。

转移：

- $f_{i,j,0}=\max\{f_{i-1,j,0},f_{i-1,j,1}\}$，如果第 $i$ 个数不选择那直接从 $i-1$ 转移过来就好了；
- $f_{i,j,1}=\max\{f_{i-1,j-1,0},f_{i-1,j,1},f_{i-1,j-1,1}\}+a_i$，第 $i$ 个数选择可以从第 $i-1$ 个数不选择，第 $i-1$ 个数选择转移过来。

为了方便将 $a_{i,1}$ 省略为 $a_i$。

从 $m=1$ 推导至 $m=2$，$m=2$ 不仅有选择和不选择两种情况了，一共有五种情况（设 `.` 为不选择，`*` 为选择）：

- $1$：`..`
- $2$：`*.`
- $3$：`.*`
- $4/5$：`**`
	- $4$：左右两个属于同一个子矩阵
    - $5$：左右两个不属于同一个子矩阵
    
设 $f_{i,j,1/2/3/4/5}$ 为到第 $i$ 个行已经选择了 $j$ 个子矩阵，并且现在第 $i$ 行为第 $1/2/3/4/5$ 种情况。

转移：

- $f_{i,j,1}=\max\limits_{p=1}^5\{f_{i-1,j,p}\}$，不选择就直接从上一行转移过来；
- $f_{i,j,2}=\max\left\{f_{i-1,j,2},f_{i-1,j,5},\max\limits_{p=1}^5\{f_{i-1,j-1,p}\}\right\}+a_{i,1}$；
- $f_{i,j,3}=\max\left\{f_{i-1,j,3},f_{i-1,j,5},\max\limits_{p=1}^5\{f_{i-1,j-1,p}\}\right\}+a_{i,2}$；
- 上面两种情况分别可以分为三种子情况：
	- 从上面那一行转移过来，上面那一行只有对应的那一列选择了数；
    - 从上面那一行转移过来，上面那一行两列都有数；
    - 不从上面那一行转移过来，与 $f_{i,j,1}$ 类似；
- $f_{i,j,4}=\max\left\{f_{i-1,j,4},\max\limits_{p=1}^5\{f_{i-1,j-1,p}\}\right\}+a_{i,1}+a_{i,2}$，如果两个属于同一个矩阵，那么可以从上一行转移过来，也可以直接新开一个矩阵；
- $f_{i,j,5}=\max\left\{f_{i-1,j-1,2},f_{i-1,j-1,3},f_{i-1,j,5},\max\limits_{p=1}^5\{f_{i-1,j-2,p}\}\right\}+a_{i,1}+a_{i,2}$，左右两个数分别讨论，也可以新开一个矩阵，注意新开的时候不是 $j-1$ 而是 $j-2$，因为两个数新开两个矩阵。

然后两种情况分别输出 $\max\{f_{n,k,0},f_{n,k,1}\}$ 和 $\max\limits_{i=1}^5\{f_{n,k,i}\}$ 即可。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[105];
int b[105][3];

int dp[105][15][7];

int main () {
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	if (m == 1) {
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		for (int i = 1; i <= n; i++)
			for (int j = 0; j <= k; j++) {
				dp[i][j][0] = max(dp?[i - 1][j][1], dp[i - 1][j][0]);
				if (j != 0) dp[i][j][1] = max(dp[i - 1][j - 1][0], max(dp[i - 1][j][1], dp[i - 1][j - 1][1])) + a[i];
			}
		printf("%d", max(dp[n][k][0], dp[n][k][1]));
	} else {
		for (int i = 1; i <= n; i++) scanf("%d%d", &b[i][1], &b[i][2]);
		for (int i = 1; i <= n; i++)
			for (int j = 0; j <= k; j++) {
				int tmp = -1;
				for (int p = 1; p <= 5; p++) dp[i][j][1] = max(dp[i][j]?[1], dp[i - 1][j][p]);
				if (j != 0) {
					dp[i][j][2] = max(dp[i - 1][j][2], dp[i - 1][j][5]) + b[i][1];
					for (int p = 1; p <= 5; p++) tmp = max(tmp, dp[i - 1][j - 1][p]);
					dp[i][j][2] = max(dp[i][j][2], tmp + b[i][1]); 
					dp[i][j][3] = max(dp[i - 1][j][3], dp[i - 1][j][5]) + b[i][2];
					tmp = -1;
					for (int p = 1; p <= 5; p++) tmp = max(tmp, dp[i - 1][j - 1][p]);
					dp[i][j][3] = max(dp[i][j][3], tmp + b[i][2]);
					dp[i][j][4] = max(dp[i]?[j][4], dp[i - 1][j][4] + b[i][1] + b[i][2]);
					tmp = -1;
					for (int p = 1; p <= 5; p++) tmp = max(tmp, dp[i - 1][j - 1][p]);
					dp[i][j][4] = max(dp[i][j][4], tmp + b[i][1] + b[i][2]);
				}
				if (j >= 2) {
					dp[i][j][5] = max(dp[i][j][5], max(max(dp[i - 1][j - 1][2], dp[i - 1][j - 1][3]), dp[i - 1][j][5]) + b[i][1] + b[i][2]);
					tmp = -1;
					for (int p = 1; p <= 5; p++) tmp = max(tmp, dp[i - 1][j - 2][p]);
					dp[i][j][5] = max(dp[i][j][5], tmp + b[i][1] + b[i][2]);
				}
			}
		int ans = -1;
		for (int i = 1; i <= 5; i++) ans = max(ans, dp[n][k][i]);
		printf("%d", ans);
	}
	return 0;
}

```

---

## 作者：2333tech (赞：0)

本题分两种情况考虑。  
**只要注意到 $m \leqslant 2$ 就能解决。**  
先附上变量的定义：
```cpp
int n, m, k;    //输入的 N,M,K
int x, y;      
int num[110][3]; //两列数据的前缀和
int f[110][110][15];//DP
```
### 当 $m = 1$ 时
这道题是DP，所以先设出状态：
$f[i][k]$ 是前 $i$ 个数中 $k$ 个最大子矩阵的和。  
然后是状态转移方程:
$$f[i][k] = \max\begin{cases}f[i-1][k]\\\max(f[j][k-1] + sum[i] - sum[j])\end{cases}$$
解释一下其中的变量，$i,k$  同上，$j$ 是本次选择的子矩阵的开头，$sum[]$ 是输入数据的前缀和用于 $O(1)$ 取得区间和。  
方程第一行表示不选新矩阵，第二行表示选择 $j+1$ 到 $i$ 的子矩阵并最大和。  
**时间复杂度 $O(n^2 * K)$**  
核心代码：
```cpp
        for (int i = 1; i <= n;i++) {
            scanf("%d",&x);
            num[i][1] = num[i - 1][1] + x; //求前缀和
        }
        for (int i = 1; i <= n;i++) {
            for (int km = 1; km <= k;km++) {    // km 就是已选子矩阵数
                f[i][1][km] = f[i - 1][1][km];    //不选，继承
                for (int j = 0; j < i;j++) {    //因为是前缀和，j < i
                    f[i][1][km] = max(f[i][1][km], f[j][1][km - 1] + num[i][1] - num[j][1]);    //选择 j+1 -> i 的子矩阵
                }
            }
        }
```
### 当 $m = 2$ 时
还是先设出状态：$f[i][j][k]$ 是当第一行选到了 $i$ 个数，第二行选到了 $j$ 个数，选到了 $k$ 个矩阵。  
状态转移方程：  
$$f[i][j][k]=\max\begin{cases}\max(f[i-1][j][k],f[i][j-1][k])\\\max(f[l][j][k-1]+sum[i][1]-sum[l][1])\\\max(f[i][l][k-1]+sum[j][2]-sum[l][2])\\\max(f[l][l][k-1]+ sum[i][1] - sum[l][1] + sum[j][2] - sum[l][2])\end{cases}$$
其中变量 $l$ 是当前选取子矩阵的开头，其他变量意义同 $m=1$ 时。  
与上文 $m = 1$ 时一样，公式第一行是不选新矩阵，公式第二行是从矩阵第一行中选取子矩阵，公式第三行是从矩阵第二行中选取子矩阵，公式第四行是当 $i = j$ 时同时选取矩阵一二行，最后取最大值。  
核心代码：
```cpp
        for (int i = 1; i <= n;i++) {    //求两行前缀和
            scanf("%d%d", &x, &y);
            num[i][1] = num[i - 1][1] + x;
            num[i][2] = num[i - 1][2] + y;
        }
        for (int i = 1; i <= n;i++) {
            for (int j = 1; j <= n;j++) {
                for (int km = 1; km <= k;km++) {
                    f[i][j][km] = max(f[i - 1][j][km], f[i][j - 1][km]);    //继承
                    for (int l = 0; l < i;l++) {
                        f[i][j][km] = max(f[i][j][km], f[l][j][km - 1] + num[i][1] - num[l][1]);    //取第一行
                    }
                    for (int l = 0; l < j;l++) {
                        f[i][j][km] = max(f[i][j][km], f[i][l][km - 1] + num[j][2] - num[l][2]);    //取第二行
                    }
                    if(i == j) {    //同时取一二行
                        for (int l = 0; l < i;l++) {
                            f[i][j][km] = max(f[i][j][km], f[l][l][km - 1] + num[i][1] - num[l][1] + num[j][2] - num[l][2]);
                        }
                    }
                }
            }
        }
        printf("%d\n", f[n][n][k]);
```


---

## 作者：Saber_Master (赞：0)

[P2331 [SCOI2005]最大子矩阵](https://www.luogu.com.cn/problem/P2331)

对于$m=1$的情况，容易推导出$dp$转移方程:$$f[i][k]=max \{f[j][k-1]+sum[i]-sum[j] \}$$,其中$f[i][k]$表示前$i$行选$k$个矩阵.复杂度$O(n^3)$

对于$m=2$的情况，我们考虑从上面的方程进行拓展.首先瓶颈在于设计状态.既然我们上一步已经知道怎么求单独一列的方案,那现在多加了一列，我们$dp$就加一维即可.

现考虑用$f[i][j][k]$表示第一列选$i$行，第二列选$j$行，共选择$k$个子矩阵的方案数.我们有四种转移手段：

一$、$ $f[i][j][k]=max(f[i-1][j][k], f[i][j-1][k])$，即不选.

二$、$ $f[i][j][k]=max \{ f[l][j][k-1]+s1[i]-s1[l] \} $，即固定住第二列不选，按照第一问的方式转移第一列.

三$、$ $f[i][j][k]=max \{ f[i][l][k-1]+s2[j]-s2[l] \} $，即固定住第一列不选，按照第一问的方式转移第二列.

四$、$ 若$i==j$，那么我们可以从两列中同时选择.$f[i][j][k]=max \{ f[l][l][k-1]+s1[i]-s1[l]+s2[i]-s2[l] \}$，即将两列合并在一起，然后按照解决第一问的方式转移.

$O(n^3)$

核心代码

```
inline void solve1(){ //第一问
	for (R ll i=1; i<=K; i++){
		for (R ll j=1; j<=n; j++)
			for (R ll k=0; k<j; k++) chkmax(f[i&1][j], max(f[i&1^1][k]+sum[0][j]-sum[0][k], f[i&1][k]));
	}
	writeln(f[K&1][n]);
}



inline void solve2(){ //第二问
	for (R ll k=1; k<=K; k++)
		for (R ll i=1; i<=n; i++)
			for (R ll j=1; j<=n; j++){
				g[i][j][k]=max(g[i][j-1][k], g[i-1][j][k]);
				for (R ll l=0; l<i; l++) chkmax(g[i][j][k], g[l][j][k-1]+sum[0][i]-sum[0][l]);
				for (R ll l=0; l<j; l++) chkmax(g[i][j][k], g[i][l][k-1]+sum[1][j]-sum[1][l]);
				if(i==j) for (R ll l=0; l<i; l++) chkmax(g[i][j][k], g[l][l][k-1]+sum[0][i]-sum[0][l]+sum[1][j]-sum[1][l]);
			}
	writeln(g[n][n][K]);
}
```


---

## 作者：yezl (赞：0)

依旧首先看看题目，大意就是给你个 $ n \times m $ 的矩阵，要你选出其中互不相交的 $ k $ 个子矩阵，使这 $ k $ 个矩阵内的元素值和最大。

### 思路：

本题是一个很好的DP题目
我们看到m的值只可能是1或者2，所以在解决的时候会相对比较简单些。
我们分情况讨论：  
如果m==1，那么就类似于一维数组求解最大子段和  
状态: $ f[i][j][0/1] $ 表示对于第i行的是否要选（0表示不，1表示选），已经选了j个矩阵的最大值。  
第i行不选： $ \texttt{f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1])} $ 。  
第i行选： $ \texttt{f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j][1])+a[i][1]} $ 。  
（边界要处理）

如果 $ m=2 $ ， $ f[i][j][k] $ ,情况分以下几种，其中 $ k $ 表示第几种情况， $ j $ 表示已经选了 $ j $ 个子矩阵：
 1. 第 $ i $ 行一个也不选：  
 $ \texttt{f[i][j][0]=max(f[i-1][j][0],max(max(f[i-1][j][1],f[i-1][j][2]),max(f[i-1][j][3],f[i-1][j][4])))} $
 2. 第i行选左边，不选右边，这种情况下，有可能从以下转移过来：  
 $ \texttt{f[i][j][1]=max(f[i-1][j-1][0],max(max(f[i-1][j][1],f[i-1][j][3]),max(f[i-1][j-1][2],f[i-1][j-1][4])))+a[i][1]} $ 
 3. 第i行选右边，不选左边：  
 $ \texttt{f[i][j][2]=max(f[i-1][j-1][0],max(max(f[i-1][j][2],f[i-1][j][3]),max(f[i-1][j-1][1],f[i-1][j-1][4])))+a[i][2]} $ 
 4. 第i行选左右，但左右不属于一个子矩阵：  
 $ \texttt{f[i][j][3]=max(f[i-1][j-1][1],max(f[i-1][j-1][2],f[i-1][j][3]))} $ 
 5. 第i行选左右，左右属于一个子矩阵：  
 $ \texttt{f[i][j][4]=max(f[i-1][j-1][0],max(max(f[i-1][j-1][1],f[i-1][j-1][2]),max(f[i-1][j-1][3],f[i-1][j][4])))+a[i][1]+a[i][2]} $ 

情况考虑完了。

### 那么我们直接上代码：

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=110,K=15;//定义常变量 
int a[N][3],f[N][K][5];
int n,m,k;
int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	memset(f,0xcf,sizeof(f));//将 f 数组初始化为极小值 
	if(m==1)
	{
		/*
			如果m==1，那么就类似于一维数组求解最大子段和
			状态:f[i][j][0/1]表示对于第i行的是否要选，已经选了j个矩阵，的最大值
			第i行不选：f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
			第i行选：f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j][1])+a[i][1];
		*/
		f[0][0][0]=0;
		for(int i=1;i<=n;i++)
		{
			f[i][1][1]=a[i][1];
			f[i][0][0]=0;
			f[i][0][1]=0;
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=k;j++)
			{
				f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
				f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j][1])+a[i][1];
			}
		}
		printf("%d",max(f[n][k][0],f[n][k][1]));
	}
	else
	{
		for(int i=0;i<=n;i++)//初始化
		{
			for(int j=0;j<=k;j++)	
			{
				f[i][j][0]=0;
			}
		} 
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=k;j++)
			{
				f[i][j][0]=max(f[i-1][j][0],max(max(f[i-1][j][1],f[i-1][j][2]),max(f[i-1][j][3],f[i-1][j][4])));
				f[i][j][1]=max(f[i-1][j-1][0],max(max(f[i-1][j][1],f[i-1][j][3]),max(f[i-1][j-1][2],f[i-1][j-1][4])))+a[i][1];
				f[i][j][2]=max(f[i-1][j-1][0],max(max(f[i-1][j][2],f[i-1][j][3]),max(f[i-1][j-1][1],f[i-1][j-1][4])))+a[i][2];
				f[i][j][3]=max(f[i-1][j-1][1],max(f[i-1][j-1][2],f[i-1][j][3]));
				f[i][j][4]=max(f[i-1][j-1][0],max(max(f[i-1][j-1][1],f[i-1][j-1][2]),max(f[i-1][j-1][3],f[i-1][j][4])))+a[i][1]+a[i][2];
				if(j>=2)//第三种情况没考虑完 继续完善
					f[i][j][3]=max(f[i][j][3],max(f[i-1][j-2][0],f[i-1][j-2][4]));
            	f[i][j][3]+=a[i][1]+a[i][2]; 
			}
		}
		printf("%d",max(f[n][k][0],max(max(f[n][k][1],f[n][k][2]),max(f[n][k][3],f[n][k][4]))));
	}
	return 0;
}
```

希望可以帮到大家。

---

## 作者：xsap (赞：0)


- 显然要用动规，主要入手点是发现m <= 2，所以想到先考虑m = 1时的情况，再看是否能套用到m = 2的情况

- 当m = 1是，显然是[最大子段和](https://www.luogu.com.cn/problem/P1115)的升级版，选k个子段，这时想到开三维dp[i][j][k]表示现在做了1-i行，选了j个子段（子矩阵），**第i行状态为k**（核心），若选，则状态为1，否则，状态为0

- 状态转移顺推以及逆推均可，以逆推为例，$$ dp[i][j][k] = max( dp2[i][j][k] , dp[i - 1][j - val[w][k]][w] + ( k == 1 ? a[i][1] : 0 )) ; $$按照这个方程算一遍即可，主要注意最好开数组val来保存从状态x转化到状态y所至少需要多多少子矩阵

- 顺推就是用当前状态更新未知状态，转移方程是$$ dp[i + 1][j + val2[k][w]][w] = max( dp[i + 1][j + val[k][w]][w] , dp[i][j][k] ) + cal(i , w)$$，几乎同逆推

- 当m = 2时，只要改一下val[w][k]的值以及后面的式子即可

- 代码

```
//顺推
# include <iostream>
# include <cstdio>

using namespace std ;

const int NR = 105 ;

int n , m , t ;
int dp1[NR][20][2] ;
int dp2[NR][15][5] ;
int a[NR][3] ;
int val1[2][2] = 
{
	{ 0 , 1 } ,
	{ 0 , 0 } 
} ;

int val2[5][5] = 
{
	{ 0 , 1 , 1 , 1 , 2 } ,
	{ 0 , 0 , 1 , 1 , 1 } ,
	{ 0 , 1 , 0 , 1 , 1 } ,
	{ 0 , 1 , 1 , 0 , 2 } ,
	{ 0 , 0 , 0 , 1 , 0 } 
} ;

void do1()
{
	for ( int i = 0 ; i < NR ; i++ )
		for ( int j = 0 ; j <= 15 ; j++ )
			for ( int k = 0 ; k <= 1 ; k++ )
				dp1[i][j][k] = -1e9 ;
	for ( int j = 0 ; j <= 15 ; j++ )
		dp1[0][j][0] = 0 ;
	for ( int i = 0 ; i < n ; i++ )
		for ( int j = 0 ; j <= t ; j++ )
		{
			for ( int k = 0 ; k <= 1 ; k++ )
			{
				if ( k == 1 )
					dp1[i][j][k] += a[i][1] ;
				for ( int w = 0 ; w <= 1 ; w++ )
				{
					if ( j + val1[k][w] > t )
						continue ;
					dp1[i + 1][j + val1[k][w]][w] = max( 
					dp1[i + 1][j + val1[k][w]][w] , dp1[i][j][k] ) ;
				}
			}
		}
	int ans = -1e9 ;
	for ( int i = 0 ; i <= 1 ; i++ )
	{
		if ( i == 1 )
			dp1[n][t][i] += a[n][1] ;
		ans = max( ans , dp1[n][t][i] ) ;
	}
	printf("%d\n" , ans) ;
}

void do2()
{
	for ( int i = 0 ; i < NR ; i++ )
		for ( int j = 0 ; j <= 15 ; j++ )
			for ( int k = 0 ; k <= 4 ; k++ )
				dp2[i][j][k] = -1e9 ;
	for ( int j = 0 ; j <= 15 ; j++ )
		dp2[0][j][0] = 0 ;
	for ( int i = 0 ; i < n ; i++ )
		for ( int j = 0 ; j <= t ; j++ )
		{
			for ( int k = 0 ; k <= 4 ; k++ )
			{
				if ( k == 1 )
					dp2[i][j][k] += a[i][1] ;
				if ( k == 2 )
					dp2[i][j][k] += a[i][2] ;
				if ( k == 3 || k == 4 )	
					dp2[i][j][k] += a[i][1] + a[i][2] ;
				for ( int w = 0 ; w <= 4 ; w++ )
				{
					if ( j + val2[k][w] > t )
						continue ;
					dp2[i + 1][j + val2[k][w]][w] = max( 
					dp2[i + 1][j + val2[k][w]][w] , dp2[i][j][k] ) ;
				}
			}
		}
	int ans = -1e9 ;
	for ( int i = 0 ; i <= 4 ; i++ )
	{
		if ( i == 1 )
			dp2[n][t][i] += a[n][1] ;
		if ( i == 2 )
			dp2[n][t][i] += a[n][2] ;
		if ( i == 3 || i == 4 )	
			dp2[n][t][i] += a[n][1] + a[n][2] ;
		ans = max( ans , dp2[n][t][i] ) ;
	}
	printf("%d\n" , ans) ;
}

int main()
{
	scanf( "%d%d%d" , &n , &m , &t ) ;
	for ( int i = 1 ; i <= n ; i++ )
	{
		for ( int j = 1 ; j <= m ; j++ )
		{
			scanf( "%d" , &a[i][j] ) ;
		}
	}
	if ( m == 1 )
	{
		do1() ;
	}
	else
	{
		do2() ;
	}
	return 0 ;
}
```


```
//逆推
# include <iostream>
# include <cstdio>
# include <algorithm>

using namespace std ;

const int NR = 105 ;

int n , m , t ;
int dp1[NR][15][2] ;
int dp2[NR][15][5] ;
int a[NR][3] ;
int val2[5][5] = 
{
	{ 0 , 1 , 1 , 1 , 2 } ,
	{ 0 , 0 , 1 , 1 , 1 } ,
	{ 0 , 1 , 0 , 1 , 1 } ,
	{ 0 , 1 , 1 , 0 , 2 } ,
	{ 0 , 0 , 0 , 1 , 0 } 
} ;

void do1()
{
	for ( int j = 0 ; j < 15 ; j++ )
		dp1[0][j][1] = -1e9 ;
	for ( int j = 0 ; j < 15 ; j++ )
		dp1[0][j][0] = 0 ;
	
	for ( int i = 1 ; i <= n ; i++ )
		for ( int j = 0 ; j <= t ; j++ )
			for ( int k = 0 ; k <= 1 ; k++ )
			{
				dp1[i][j][k] = -1e9 ;
				if ( j - k >= 0 )
					dp1[i][j][k] = dp1[i - 1][j - k][0] ;
				dp1[i][j][k] = max( dp1[i][j][k] , dp1[i - 1][j][1] ) ;
				if ( k )
					dp1[i][j][k] += a[i][1] ;
			}
	printf( "%d\n" , max( dp1[n][t][0] , dp1[n][t][1] ) ) ;
}

int calc( int p , int q )
{
	int ans = 0 ;
	if ( q == 1 || q == 3 || q == 4 )
		ans += a[p][1] ;
	if ( q == 2 || q == 3 || q == 4 )
		ans += a[p][2] ;
	return ans ;
}

void do2()
{
	for ( int i = 0 ; i <= n ; i++ )
		for ( int j = 0 ; j <= t ; j++ )
			for ( int k = 0 ; k <= 4 ; k++ )
				dp2[i][j][k] = -1e9 ;
	for ( int j = 0 ; j < 15 ; j++ )
		dp2[0][j][0] = 0 ;
	
	for ( int i = 1 ; i <= n ; i++ )
		for ( int j = 0 ; j <= t ; j++ )
		{
			for ( int k = 0 ; k <= 4 ; k++ )
			{
				for ( int w = 0 ; w <= 4 ; w++ )
				{
					if ( j >= val2[w][k] )
					{
						dp2[i][j][k] = max( dp2[i][j][k] , 
						dp2[i - 1][j - val2[w][k]][w] ) ;
					}
				}
				if ( k == 1 )
					dp2[i][j][k] += a[i][1] ;
				if ( k == 2 )
					dp2[i][j][k] += a[i][2] ;
				if ( k == 3 || k == 4 )	
					dp2[i][j][k] += a[i][1] + a[i][2] ;
			}
		}
	int ans = -1e9 ;
	for ( int i = 0 ; i <= 4 ; i++ )
		ans = max( ans , dp2[n][t][i] ) ;
	printf("%d\n" , ans) ;
}

int main()
{
	scanf( "%d%d%d" , &n , &m , &t ) ;
	for ( int i = 1 ; i <= n ; i++ )
	{
		for ( int j = 1 ; j <= m ; j++ )
		{
			scanf( "%d" , &a[i][j] ) ;
		}
	}
	if ( m == 1 )
	{
		do1() ;
	}
	else
	{
		do2() ;
	}
	return 0 ;
}
```
- 大坑点：空矩阵也算子矩阵！！！
- [博客食用 ~~（味道更佳）~~](https://blog.csdn.net/xsaploser/article/details/103730864)

---

## 作者：由比滨丶雪乃 (赞：0)



 配合[博客](https://www.luogu.org/blog/Hikigaya/p1197-xing-qiu-tai-zhan-ti-xie)食用更加


## 题意很简单

 _**在N×M的矩阵中选出k个互不重叠的子矩阵使得这k个子矩阵的元素之和最大（注意，m<=2）**_
 
 
 
 ### 分两种情况讨论
 
 **1、当m=1时**
 
 **很简单，就是求序列最大的k个字段和，就和普通求最大字段和差不多，~~还是简单说一下~~（直接上代码吧）**
```cpp
	for(int i=1;i<=n;i++)
		   for(int j=1;j<=k;j++)
		      {
		      	   f1[i][j]=f1[i-1][j];//f[i][j]代表的是前i个数选了j个矩阵（j段）的最大值
		      	   for(int t=0;t<i;t++)
		      	       f1[i][j]=max(f1[i][j],f1[t][j-1]+a[i]-a[t]);//a[i]-a[t]为i-t这段的和（提前用前缀和维护）
			  }
```


#### 那么最终的结果即为   f1[n][k]

#### 2、当m=2时
#### 开始思考时貌似问题有点复杂，无法下手qwq，但~~冷静~~想一想，尽管看上去是2维的矩阵，但毕竟有一维为2，所以仍可以用线性dp来做QAQ!

**此时我们发现，共有5种情况**

**1.枚举前i行，当前枚举的两列不属于任何矩阵的最大值**

**2.枚举前i行，当前两列属于同一矩阵的最大值**

**3.枚举前i行，当前两列属于不同矩阵的最大值**

**4.枚举前i行，左边一列属于一个矩阵的最大值**

**5.枚举前i行，右边一列属于一个矩阵的最大值**



**问题渐渐明了，我们所需要做的就是枚举左右两列的数，将左右两列分开来求（方法同m=1时，其实真正需要考虑的只有2,4,5），而当左右两列的进度相同时，我们需要将上一阶段的答案加上左右两边的值（如果还没有理解的话可以根据代码理解qwq）**

#### m==2时的代码

```cpp
for(int K=1;K<=k;K++)//选取前K个子矩阵
		    for(int i=1;i<=n;i++)//左边数列
		       for(int j=1;j<=n;j++)//右边数列
		        {
		        	f2[i][j][K]=max(f2[i-1][j][K],f2[i][j-1][K]);
		        	for(int p=0;p<i;p++)
		        	f2[i][j][K]=max(f2[i][j][K],f2[p][j][K-1]+l[i]-l[p]);//维护左边数列，同m=1
		        	for(int p=0;p<j;p++)
		        	f2[i][j][K]=max(f2[i][j][K],f2[i][p][K-1]+r[j]-r[p]);//维护右边数列，同m=2
		        	if(i==j)
		        	for(int p=0;p<i;p++)
		        	   f2[i][j][K]=max(f2[i][j][K],f2[p][p][K-1]+l[i]-l[p]+r[j]-r[p]);//枚举两边数列的位置相同时，两边都要相加
				}
```


###### 献上完整代码（~~我知道你们只看这个qwq~~）

 ```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <iomanip>
#define ll long long
#define maxn 10000010

using namespace std;

const int N=105;
const int M=5;

int n,m,k;
int f2[N][N][M];
int f1[N][N];
int a[maxn];
int l[maxn];
int r[maxn];

inline int max(int a,int b)
{
	return a>b?a:b;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	if(m==1)
	{
		int val;
		for(int i=1;i<=n;i++)
		   scanf("%d",&val),a[i]+=a[i-1]+val;
		for(int i=1;i<=n;i++)
		   for(int j=1;j<=k;j++)
		      {
		      	   f1[i][j]=f1[i-1][j];
		      	   for(int t=0;t<i;t++)
		      	       f1[i][j]=max(f1[i][j],f1[t][j-1]+a[i]-a[t]);
			  }
		printf("%d",f1[n][k]);
		return 0;
	 } 
	 if(m==2)
	 {
	 	int x,y;
	 	for(int i=1;i<=n;i++)
	 	{
	 		scanf("%d%d",&x,&y);
	 		l[i]+=l[i-1]+x;
	 		r[i]+=r[i-1]+y;
		 }
		 for(int K=1;K<=k;K++)
		    for(int i=1;i<=n;i++)
		       for(int j=1;j<=n;j++)
		        {
		        	f2[i][j][K]=max(f2[i-1][j][K],f2[i][j-1][K]);
		        	for(int p=0;p<i;p++)
		        	f2[i][j][K]=max(f2[i][j][K],f2[p][j][K-1]+l[i]-l[p]);
		        	for(int p=0;p<j;p++)
		        	f2[i][j][K]=max(f2[i][j][K],f2[i][p][K-1]+r[j]-r[p]);
		        	if(i==j)
		        	for(int p=0;p<i;p++)
		        	   f2[i][j][K]=max(f2[i][j][K],f2[p][p][K-1]+l[i]-l[p]+r[j]-r[p]);
				}
		printf("%d",f2[n][n][k]);
		return 0;
	 }
 } 
```


---

## 作者：邱江坤 (赞：0)

这是一道状压dp的题目。似乎这道题简洁明了的做法还没有，那么我就来简单地给出一份还可以的代码。详见代码。
很显然，我们按照长条状考虑，每列算一个阶段，每个阶段只与前一个有关。每个阶段有5*(k+1)个状态，对应形状和已选矩阵数量。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 3, K = 11;
int dp[N][K][5];
int a[N][M];
int main()
{
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            cin >> a[i][j];

    memset(dp, 0xa0, sizeof dp);
    dp[0][0][0] = 0;
    for (int i = 1; i <= n; ++i)
    {
        for (int kk = 0; kk <= k; ++kk)
        {
            // 0 不选
            for (int s = 0; s <= 4; ++s)
                dp[i][kk][0] = max(dp[i][kk][0], dp[i - 1][kk][s]);
            // 可以从任意状态转移来

            // 1 上 2 下
            for (int w = 1; w <= 2; ++w)
            {
                if (kk)
                    for (int s = 0; s <= 4; ++s)
                        dp[i][kk][w] = max(dp[i][kk][w], dp[i - 1][kk - 1][s] + a[i][w]);
                // 从上方某个状态转移来，花费1次数

                dp[i][kk][w] = max(dp[i][kk][w], dp[i - 1][kk][w] + a[i][w]);
                dp[i][kk][w] = max(dp[i][kk][w], dp[i - 1][kk][4] + a[i][w]);
                // 这是不花费多余次数的
            }
            // 3 上下整体
            if (kk)
                for (int s = 0; s <= 4; ++s)
                    dp[i][kk][3] = max(dp[i][kk][3], dp[i - 1][kk - 1][s] + a[i][1] + a[i][2]);

            dp[i][kk][3] = max(dp[i][kk][3], dp[i - 1][kk][3] + a[i][1] + a[i][2]);

            // 4 上下分开
            dp[i][kk][4] = max(dp[i][kk][4], dp[i - 1][kk][4] + a[i][1] + a[i][2]);
            if (kk)
            {
                if (kk >= 2)
                    for (int s = 0; s <= 4; ++s)
                        dp[i][kk][4] = max(dp[i][kk][4], dp[i - 1][kk - 2][s] + a[i][1] + a[i][2]);
                        //  继承2个
                dp[i][kk][4] = max(dp[i][kk][4], dp[i - 1][kk - 1][1] + a[i][1] + a[i][2]);
                dp[i][kk][4] = max(dp[i][kk][4], dp[i - 1][kk - 1][2] + a[i][1] + a[i][2]);
                // 继承1个
            }
        }
    }

    int ans = 0xa0a0a0a0;
    for (int kk = 0; kk <= 4; ++kk)
        ans = max(ans, dp[n][k][kk]);
    cout << ans << endl;
}

```

---

## 作者：Sakura_梦瑶 (赞：0)

刚学oi题解写的不好轻喷）
这道题我的想法是以行为单位,f[i][k][j]表示前i行用了k个矩阵在状态j下的最佳答案,前面三种状态很好想 就是选这一行左边那格和选右边那格以及不选；
但是全选的情况我们要分类讨论 这也是这题的最大细节。我分类为当前这一行什么都不选然后全选下一行以及当前这一行有选格子然后全选下一行.所以j那一层有五个状态
初始化要注意重置无穷小否则分类讨论的那两个状态会对答案产生不合法影响.
（因为用位运算开数组没仔细思考数组大小导致mle一次....
下面是代码顺面送一组样例...
```cpp
#include<bits/stdc++.h>
#define N 1<<8
#define fer(x,y,z) for(int x=y;x<=z;x++)
using namespace std;
inline int maxx(int pos,int ans){if(pos>ans)return pos;else return ans;}
int n,m,K,a[N][N],vl[N][N][9];
int main(){
	cin>>n>>m>>K;fer(i,1,n)fer(k,1,m)scanf("%d",&a[i][k]);
	memset(vl,-10,sizeof vl),vl[0][0][0]=0;
	fer(i,0,n-1)fer(k,0,K)fer(j,0,4){
	 vl[i+1][k][0]=maxx(vl[i+1][k][0],vl[i][k][j]);
	 
	 if(j==1||j==3)vl[i+1][k][1]=maxx(vl[i+1][k][1],vl[i][k][j]+a[i+1][1]);
	 vl[i+1][k+1][1]=maxx(vl[i+1][k+1][1],vl[i][k][j]+a[i+1][1]);
	 
	 if(j==2||j==3)vl[i+1][k][2]=maxx(vl[i+1][k][2],vl[i][k][j]+a[i+1][2]);
	 vl[i+1][k+1][2]=maxx(vl[i+1][k+1][2],vl[i][k][j]+a[i+1][2]);
	 
	 if(j==3)vl[i+1][k][3]=maxx(vl[i+1][k][3],vl[i][k][j]+a[i+1][1]+a[i+1][2]);
	 if(j!=0)vl[i+1][k+1][3]=maxx(vl[i+1][k+1][3],vl[i][k][j]+a[i+1][1]+a[i+1][2]); 
	 
	 if(j==4)vl[i+1][k][4]=maxx(vl[i+1][k][4],vl[i][k][j]+a[i+1][1]+a[i+1][2]);
	 vl[i+1][k+1][4]=maxx(vl[i+1][k+1][4],vl[i][k][j]+a[i+1][1]+a[i+1][2]);
	}
	m=0;fer(k,0,4)m=maxx(m,vl[n][K][k]);cout<<m;
}
//01234  
//不选 选左 选右 继承性全选 新开全选 
//8 2 3
//-1  5
// 3 -4
//-2  1
// 2 -3
//-2  1
//-2 -3
// 1  1
//-3  2
//11
```

---

## 作者：Smokey_Days (赞：0)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define Max(_A,_B) ((_A)>(_B)?(_A):(_B))
int n,m,k,f[105][5][15],a[105],b[105];
/*
看起来是一道很简单的题，但是细节巨多，消耗了我大量的提交次数。如果是比赛我怕不是凉了。 

很显然是一道DP题。
很容易可以想到的是暴力枚举，然而这样做的复杂度是O(n^2*n^2k)的，很很很很显然可以发现是不可行的。
观察数据范围，我们可以注意到， m<=2，因此很容易可以想到状压DP。
具体来说，当m==2时，用f[i][j][l]表示，当前处于第i行，第i行的状态为j，已经使用了l个子矩阵时，最大的和。
则状态转移方程是：
f[i][0][l]=Max(Max(f[i-1][0][l],f[i-1][1][l]),Max(f[i-1][2][l],f[i-1][3][l]));
f[i][1][l]=Max(Max(f[i-1][0][l-1],f[i-1][1][l]),Max(f[i-1][2][l-1],f[i-1][3][l]))+b[i];
f[i][2][l]=Max(Max(f[i-1][0][l-1],f[i-1][1][l-1]),Max(f[i-1][2][l],f[i-1][3][l]))+a[i];
f[i][3][l]=Max(Max(f[i-1][0][l-1],f[i-1][1][l-1]),Max(f[i-1][2][l-1],f[i-1][3][l]))+a[i]+b[i];
并且我们很容易可以得到边界条件，即：
f[1][0][0]=0,f[1][1][1]=b[1],f[1][2][1]=a[1],f[1][3][1]=a[1]+b[1];

另外需要考虑m==1的情况，事实上这种情况更容易考虑：状态转移方程是：
f[i][0][l]=Max(f[i-1][0][l],f[i-1][1][l]);
f[i][1][l]=Max(f[i-1][0][l-1],f[i-1][1][l])+a[i]; 
初始化f[1][0][0]=0,f[1][1][1]=a[1];

然而交上去全wa 
回头考虑这个问题我们可以发现一个很尴尬的事情：当上一行两个取的时候，我们并不知道它到底是「两列分别取」还是「两列一起取」。
因此，对于11的状态，我们应当拆成两个部分：
f[i][3][l]表示上一行的两列是分别取的。于是得到状态转移方程。 
f[i][4][l]表示上一行的两列是合在一起取的。
f[i][0][l]=Max(Max(Max(f[i-1][0][l],f[i-1][1][l]),Max(f[i-1][2][l],f[i-1][3][l])),f[i-1][4][l]);
f[i][1][l]=Max(Max(Max(f[i-1][0][l-1],f[i-1][1][l]),Max(f[i-1][2][l-1],f[i-1][3][l])),f[i-1][4][l-1])+b[i];
f[i][2][l]=Max(Max(Max(f[i-1][0][l-1],f[i-1][1][l-1]),Max(f[i-1][2][l],f[i-1][3][l])),f[i-1][4][l-1])+a[i];
f[i][3][l]=Max(Max(Max(f[i-1][0][l-2],f[i-1][1][l-1]),Max(f[i-1][2][l-1],f[i-1][3][l])),f[i-1][4][l-2])+a[i]+b[i];
f[i][4][l]=Max(Max(Max(f[i-1][0][l-1],f[i-1][1][l-1]),Max(f[i-1][2][l-1],f[i-1][3][l-1])),f[i-1][4][l])+a[i]+b[i];
然而这样子还是全WA。
仔细观察一下我们的状态转移方程，我们发现存在一些l-2的状态，那么我们应该分两类讨论：l==1或l>=2. 
这样大概就能通过了。 
*/
void slv1(){
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
    }
    f[1][0][0]=0,f[1][1][1]=a[1];
    for(int i=1;i<=n;++i){
        f[i][0][0]=f[i][1][0]=0;
        for(int l=1;l<=k;++l){
            f[i][0][l]=Max(f[i-1][0][l],f[i-1][1][l]);
            f[i][1][l]=Max(f[i-1][0][l-1],f[i-1][1][l])+a[i]; 
        }
    }
    int ans=-0x3f3f3f3f;
    printf("%d",Max(f[n][0][k],f[n][1][k]));
    return;
}
void slv2(){
    for(int i=1;i<=n;++i){
        scanf("%d%d",&a[i],&b[i]);
    }
    f[0][0][0]=0;
    f[1][0][0]=0,f[1][1][1]=b[1],f[1][2][1]=a[1],f[1][3][2]=a[1]+b[1],f[1][4][1]=a[1]+b[1];
    for(int i=1;i<=n;++i){
        f[i][0][0]=f[i][1][0]=f[i][2][0]=f[i][3][0]=f[i][4][0]=0;
        for(int l=1;l<=k;++l){
                f[i][0][l]=Max(Max(Max(f[i-1][0][l],f[i-1][1][l]),Max(f[i-1][2][l],f[i-1][3][l])),f[i-1][4][l]);
                f[i][1][l]=Max(Max(Max(f[i-1][0][l-1],f[i-1][1][l]),Max(f[i-1][2][l-1],f[i-1][3][l])),f[i-1][4][l-1])+b[i];
                f[i][2][l]=Max(Max(Max(f[i-1][0][l-1],f[i-1][1][l-1]),Max(f[i-1][2][l],f[i-1][3][l])),f[i-1][4][l-1])+a[i];
                f[i][4][l]=Max(Max(Max(f[i-1][0][l-1],f[i-1][1][l-1]),Max(f[i-1][2][l-1],f[i-1][3][l-1])),f[i-1][4][l])+a[i]+b[i];
                if(l<2){
                    continue;
                }
                f[i][3][l]=Max(Max(Max(f[i-1][0][l-2],f[i-1][1][l-1]),Max(f[i-1][2][l-1],f[i-1][3][l])),f[i-1][4][l-2])+a[i]+b[i];
        }
    }
    /*
    for(int i=1;i<=n;++i){
        for(int l=0;l<=k;++l){
            for(int j=0;j<5;++j){
                printf("%d ",f[i][j][l]);
            }
            puts("");
        }
        puts("");
    }*/
    int ans=-0x3f3f3f3f;
    for(int i=0;i<5;++i){
        ans=Max(ans,f[n][i][k]);
    }
    printf("%d",ans);
}
void init(){
	scanf("%d%d%d",&n,&m,&k);
	memset(f,-1,sizeof(f));
	if(m==1){
	    slv1();
    }
    if(m==2){
        slv2();
    }
}
int main(){
	init();
	return 0;
}
```

---


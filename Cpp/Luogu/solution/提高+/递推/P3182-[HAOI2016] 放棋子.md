# [HAOI2016] 放棋子

## 题目描述

给你一个 $N\times N$ 的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放 $N$ 枚棋子（障碍的位置不能放棋子），要求你放 $N$ 个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。


## 样例 #1

### 输入

```
2
0 1
1 0```

### 输出

```
1```

# 题解

## 作者：YoungNeal (赞：18)

如果知道了错排问题，那这就是一个裸的高精。  
原博客戳这里 [YoungNeal](http://www.cnblogs.com/YoungNeal/p/8485399.html)
### Description

给你一个 $N*N$ 的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放 $N$ 枚棋子（障碍的位置不能放棋子），要求你放 $N$ 个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。


### Solution

我们先来科普一下错排问题。

错排问题指考虑一个有 $n$ 个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 $n$ 个元素的错排数记为 $D(n)$ 。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。  ---《百度百科》

看上去这就是一个递推问题，那么递推式是如何推出来呢？
当 $n$ 个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用 $D(n)$ 表示，那么 $D(n-1)$ 就表示 $n-1$ 个编号元素放在 $n-1$ 个编号位置，各不对应的方法数，其它类推.  
第一步，把第 $n$ 个元素放在一个位置，比如位置 $k$ ，一共有 $n-1$ 种方法；  
第二步，放编号为 $k$ 的元素，这时有两种情况：⑴把它放到位置 $n$ ，那么，对于剩下的 $n-1$ 个元素，由于第 $k$ 个元素放到了位置 $n$ ，剩下 $n-2$ 个元素就有 $D(n-2)$ 种方法；⑵第 $k$ 个元素不把它放到位置 $n$ ，这时，对于这 $n-1$ 个元素，有 $D(n-1)$ 种方法；  
综上得到   
    $D(n) = (n-1) *(D(n-2) + D(n-1))$  
特殊地，$D(1) = 0, D(2) = 1$.
 
知道了这个之后，这题就是一个裸的高精了。
```
// By YoungNeal
#include<cstdio>
using namespace std;
// D(n)=(n-1)*(D(n-1)+D(n-2))
// D(1)=0 D(2)=1

int n;
int D[205][100005];

void ad(int now){
    int x=0;
    for(int i=1;i<100005;i++){
        D[now][i]=D[now-1][i]+D[now-2][i]+x;
        x=D[now][i]/10;
        D[now][i]%=10;
    }
    x=0;
    for(int i=1;i<100005;i++){
        D[now][i]=D[now][i]*(now-1)+x;
        x=D[now][i]/10;
        D[now][i]%=10;
    }
}

signed main(){
    scanf("%d",&n);
    D[2][1]=1;
    if(n==1||n==2){
        printf("%d",n-1);
        return 0;
    }
    for(int i=3;i<=n;i++)
        ad(i);
    int lenc=100004;
    while(D[n][lenc]==0) lenc--;
    while(lenc) printf("%d",D[n][lenc--]);
    return 0;
} 
```

---

## 作者：cqbz_gm (赞：11)

**upd on 220811** 修改了递推式中的笔误。

Python 题解。

## 题意转化

输入给定的矩阵是干扰项，可以排除。

为什么这么说？

对于同一个 $n$，因为任意棋子不在同一列，最后我们总能找到某一行的障碍在第 $1,2,\cdots,n$ 列。

而在 $n$ 相同的情况下，不同的矩阵之间的差异仅仅在于障碍落在第 $1,2,\cdots,n$ 列上的行的排列顺序。

因为我们关心方案数，所以行的顺序怎么变都不会产生影响。

所以，我们干脆不管输入的矩阵，令矩阵第 $i$ 行的障碍必须在第 $i$ 列上。

这样问题就变成了：在 $n\times n$ 的矩阵中放置 $n$ 个棋子，第 $i$ 行的棋子不能落在第 $i$ 列上，任意两个棋子不同行、不同列，求方案数。

## 求解问题

这是一个经典的错排问题。可以先完成 [P1595 信封问题](https://www.luogu.com.cn/problem/P1595) 作为铺垫。

对于 Python 来说，两道题没有任何区别。

接下来，我们称「第 $i$ 行的棋子不落在第 $i$ 列上」为「错排」。

令前 $i$ 项满足错排的方案数为 $f_i$，易发现：

1. 当前 $i-1$ 项已经错排时

   将 $i$ 与前面任意一项交换。
   
   * 对于其余 $i-2$ 项：
   
      位置不变，依旧满足错排。
      
   * 对于 $i$：
   
      不在第 $i$ 个位置，满足错排。
      
   * 对于被选中数：
   
      因为被选中数在前 $i-1$ 项当中，放到位置 $i$ 上来后满足错排性质。
      
   综上，当前 $i-1$ 项满足错排时，一定可以插入一个 $i$ 使其依然满足错排。因为选择的用于与 $i$ 交换的数有 $i-1$ 种可能，故有：
   
   $$
   f_i=(i-1)\times f_{i-1}
   $$
   
1. 当前 $i-1$ 项中有一个数不满足错排，其余皆满足错排时：

   将 $i$ 与其交换。
   
   * 对于其余 $i-2$ 项：
   
      位置不变，依旧满足错排。
      
   * 对于 $i$：
   
      不在第 $i$ 个位置，满足错排。
      
   * 对于被选中数：
   
      因为被选中数在前 $i-1$ 项当中，放到位置 $i$ 上来后满足错排性质。
      
   综上，当前 $i-1$ 项中有一个数不满足错排，其余皆满足错排时，一定可以插入一个 $i$ 使其依然满足错排。因为与 $i$ 交换的数已经固定，所以方案数为 $1$。
   
   因为我们不关心数的具体数值，所以可以在长度 $i-2$ 的错排序列中插入一个不满足错排的数（有 $i-1$ 种可能的选择，对于任意一个选择的值，因为不满足错排，所以插入位置固定，即方案数为 $1$），再插入一个 $i$（方案数为 $1$）。
   
   故有：
   
   $$
   f_i=(i-1)\times f_{i-2}
   $$
   
综上，有：

$$
f_i=(i-1)\times(f_{i-1}+f_{i-2})
$$

以 $f_{1,2}=0,1$ 为初值，按此递推式求解 $f_n$ 即可。

#### 代码


```python
f = [0, 0, 1]
n = int (input())
for i in range (3, n + 1):
    f.append ((i - 1) * (f[i - 1] + f[i - 2]))
print (f[n])
```

---

## 作者：Yizhixiaoyun (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P3182)

## 题目分析

本题是一道**错排**问题。

首先我们发现，本题的矩阵实际上是没有任何作用的。因为题目已经保证了每一个障碍都不在同一列上，每一列都必定有且仅有一个棋子。在 $n$ 相同的情况下，如果我们不考虑输入的矩阵，不会对结果造成影响。因此我们直接将其定义为：**在第 $i$ 列的障碍物在第 $i$ 行上**。

接着我们讨论解法。

我们令 $f(n)$ 为有效的将编号为 $n$ 的棋子放置在 $n$ 个位置上的情况。因为除了第 $n$ 个位置都可以放，所以一共有 $n - 1$ 种放法。

假设第 $n$ 位棋子放置在第 $i$ 位上，那么就有两种情况：

1. 编号为 $i$ 的棋子放在第 $n$ 个位置上，此时可以化简为 $f(n-2)$ 的情况。

2. 编号为 $i$ 的棋子不放在第 $n$ 个位置上，此时可以化简为 $f(n-1)$ 的情况。

则有式子：

$f(n) = (n-1) \times (f(n - 1) + f(n-2))$ 。

特别的，有 $f(1) = 0$ 和 $f(2) = 1$ 。

值得一提的是，此题是一道**高精度**。因此直接使用 $\text{python}$ 解决！

## 贴上代码

```python
ans=0
tot1=0
tot2=0
n=int(input())
i=3
tot2+=1
while i<=n:
	ans=(tot1+tot2)*(i-1)
	tot1=tot2
	tot2=ans
	i+=1
if n==1: 
	print(0)
elif n==2:
	print(1)
else:
	print(ans)
```

---

## 作者：cdcq (赞：6)

偶然翻到这道题，突然发现我以前写的题解质量看上去居然还不错  
讲东西应该是我的强项把hhh（当然要再自己理解的情况下  
好想讲课啊（x  
那就直接把以前写的转载过来：  
[新博客链接](https://cdcq.blog.luogu.org/solution-p3182)  
[旧博客链接](http://www.cnblogs.com/JSL2018/p/6431930.html)

棋盘放置，这个跟组合数学有点关系（应该没有），N<=200，看上去可以DP（应该不能）

然后我在想组合数学和DP的时候首先发现了两点特殊性：
棋盘的每一行是可以随便换的，因为每行每列互不干扰（产生限制的是棋子），所以可以把所有n相等的情况都看做一种，也就是说题目中给出的棋盘并没有什么卵用（其实如果写20的dfs或60的壮鸭还是要用的

为了方便研究，现在约定每个棋盘上被限制的位置都是从坐上到右下，比如n==4的时候就是酱紫：

1 0 0 0

0 1 0 0

0 0 1 0

0 0 0 1

然后如果安行选的话，第i行第j列选完之后，就可以看做把第i行和第j列删掉了

比如上面的n==4的情况，如果删掉第1行第2列，这个方阵就会变成下面酱紫：

0 0 0

0 1 0

0 0 1

多手玩几组数据后容易发现，上面删除后的矩阵有非常亦可赛艇的特点

这是一个3\*3的棋盘，并且从(2,2)到(3,3)和2\*2的棋盘是一样的（在开始的时候就约定了把所有n相等的情况都看做一种

所以这也可以看成3\*3的左上角变成0

接下来在第一行放棋子有两种选择，要么不在(1,1)放，方案数等于3\*3的，在(1,1)放，就可以把第一行和第一列删掉，剩下的棋盘就是个2\*2的，也就是说在(1,1)放的方案数等于2\*2的

所以上面这个被删过的矩阵的方案数就是2\*2的方案数+3\*3的方案数

因为这个被拿来举例的矩阵是删掉(1,2)的结果，同样也可以删掉(1,2~n)，共有n-1种删法，易证每种删法都符合上面的性质

这样就得到了一个关于n\*n棋盘方案数的正确表示，可以发现n\*n棋盘的方案数只与(n-1)\*(n-1)的方案数和(n-2)\*(n-2)的方案数有关，这些都是在n之前的量（这话有点奇怪，可以忽略

所以就可以列出递推式，用f[i]表示i\*i棋盘的方案数，f[i]=(f[i-1]+f[i-2])\*(i-1)，初始状态为f[1]=0，f[2]=1

然后这道题就完结了，出题人为了不让推出递推式的同学瞬间秒掉这道题，增加代码复杂度，答案没有膜数，需要高精度

然而可以发现递推式中只有高精加高精和高精乘单精，也不怎么难写（就算是这样，高精度还是有不少细节需要注意

我是偶然发现了两个特殊性才想出这道题，虽然这次依旧没有想起来去往题目特殊性的方面去思考，但是再次证明了想题主要思考特殊性而不是一般性

总之这道题就是发现特殊性（不是太难看出来），往递推的方面思考（思路不要歪到组合数上去），高精度别写挂（注意对拍）就可以拿到满分辣

---

## 作者：china·xyc (赞：6)


### 题目描述

给你一个N*N的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放N枚棋子（障碍的位置不能放棋子），要求你放N个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。

### 输入格式

第一行一个N，接下来一个N*N的矩阵。N<=200,0表示没有障碍，1表示有障碍，输入格式参考样例

### 输出格式

一个整数，即合法的方案数。

#
这题虽然不知道为什么题目里有个二分图的标签，可是蒟蒻不知道二分图匹配**方案数**是什么东东呀QAQ

所以再读一遍题：**数据保证任意两个障碍不在同一行，任意两个障碍不在同一列**

那么我们可以想象图是长这样的：

|  |  |  |  |  | & |  |  |
| -------------:| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| & |  |  |  |  |  |  |  |
|  |  |  | & |  |  |  |  |
|  |  |  |  |  |  |  | & |
|  |  |  |  |  |  | & |  |
|  |  | & |  |  |  |  |  |
|  | & |  |  |  |  |  |  |
|  |  |  |  | & |  |  |  |

&表示障碍物，那么可以抽象的理解为一个排列：7,2,3,6,1,8,4,5（看表格中每列障碍物的“高度”）

同理，对于所有满足同一列只有一个棋子且同一行只有一个棋子的摆放方式，也可以化为一个排列。

但是题目还有一个条件，棋子不能放在障碍物上。所以这就是个错排问题嘛。。。

如果只是个错排那这题估计也就绿题？但是这题数据范围感人，于是就成了个高精度了。

## 放代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],b[100005],c[100005];
int lena,lenb,lenc;
int n,k;
int main(){
	scanf("%d",&n);
	lena=0;
	lenb=1;
	b[1]=1;
	if(n==1){
		puts("0");
		return 0;
	} 
	if(n==2){
		puts("1");
		return 0;
	} 
	for(int i=3;i<=n;i++){
		memset(c,0,sizeof(c));
		lenc=max(lena,lenb);
		k=0;
		for(int j=1;j<=lenc;j++){
			c[j]=a[j]+b[j]+k;
			k=c[j]/10;
			c[j]=c[j]%10;
		}
		if(k) c[++lenc]=k;
		k=0;
	    for(int j=1;j<=lenc;j++){
	    	c[j]=c[j]*(i-1)+k;
	    	k=c[j]/10;
	    	c[j]=c[j]%10;
		} 
		while(k){
			c[++lenc]=k%10;
			k/=10;
		}
		for(int j=1;j<=lenb;j++)
		    a[j]=b[j];
		lena=lenb;
		for(int j=1;j<=lenc;j++)
		    b[j]=c[j];
		lenb=lenc;
	}
	for(int i=lenb;i;i--) printf("%d",b[i]);
	printf("\n");
	return 0;
}
```


---

## 作者：Melting_Pot (赞：4)

### [题目](https://www.luogu.com.cn/problem/P3182)
-  看到题目后显然先想到 DP ,但是 $N\ge200$ ，那就肯定不行了。
-  题目理解：障碍与棋子一样，都是每行，列只有一个，因此，我们思考这样一个问题：
$$\begin{matrix}   
1&0&0&0&&&&&&1&0&0&0\\
0&0&1&0&&&\implies&&&0&1&0&0\\
0&1&0&0&&&&&&0&0&1&0\\
0&0&0&1&&&&&&0&0&0&1
\end{matrix} 
$$
-  这两种情况的方案数有何区别？
-  答案是并无区别：显然第一种矩阵经过行与行（或列与列）的变换就能转化为第二种，而每一行每一列都会有一个障碍，因此，每一种矩阵都能转化为第二种，转化后每一行（或列）的方案数不变，总方案数当然也不变。
-  因此我们不考虑输入的矩阵，直接转化为第一种，认为障碍均在对角线上，于是，原问题就成了：在一个对角线不可放的棋盘放棋子，且每一列，每一行均只有一枚棋子。
-  进一步转化，问题就成了：一个数列 $a_n(a_i\not=i)$ 求方案数，这就是一个裸的错排问题了，例题：[信封问题](https://www.luogu.com.cn/problem/P1595)，没做过的同学可以自行了解一下，这里直接给出递推式：
$$\begin{aligned}
f_1&=0\\f_2&=1\\f_n&=(n-1)\times (f_{n-1}+f_{n-2})
\end{aligned}
$$
-  考虑到 $f_n$ 的增长速率极快，需要高精度辅助实现。
```cpp
  #include<bits/stdc++.h>
  #define ll long long
  const ll p=10000000000000000;
  const int len=100010;
  ll f[201][len],tem,pos;
  void work(int n){
      for(int i=1;i<=len;++i){
          tem=f[n-1][i]+f[n-2][i];
          f[n][i]=(tem+pos)%p;
          pos=tem/p;
      }
      for(int i=1;i<=len;++i){
          tem=f[n][i]*(n-1);
          f[n][i]=(tem%p+pos);
          pos=tem/p;
      }
  }
  int main(){
      int n;scanf("%d",&n);
      for(int i=1;i<=n;++i)
          for(int j=1;j<=n;++j){
              int a;scanf("%d",&a);
          }//没什么用的输入
      if(n==1) return puts("0"),0;
      if(n==2) return puts("1"),0;
      f[1][1]=0;f[2][1]=1;
      for(int i=3;i<=n;++i) work(i);
      int len1(100010);
      while(f[n][len1]==0&&len1>1) len1--;
      printf("%lld",f[n][len1]);
      while(--len1) printf("%016lld",f[n][len1]);
  }
```
***码风丑陋，见谅！***

---

## 作者：Mooncrying (赞：4)

# P3182 [HAOI2016] 放棋子 题解 && 错位排序

咳咳，这是一篇对新手很友好的题解。

首先让这个题做一下“自我介绍”：这是一道**错位排序**的模板题。

### 题目大意

- 给定一个 $n \times n$ 的矩阵，上面有 $n$ 个障碍，保证每一行、每一列都只有一个障碍，障碍的位置不能放棋子。

- 我们需要求出在该矩阵中放 $n$ 个棋子，保证每一行、每一列都只有一个棋子的方案数。

- 规定 $n \le 200$。

### 题意分析

- 我们将题意转化。

	因为每一行必有一枚棋子，所以说我们把棋子的行数看成是棋子编号。又因为每一列必有一枚棋子，所以我们把列数看成是位置的编号。于是本题变成了把编号为 $a_1$ 到 $a_n$ 的棋子放入编号为 $b_1$ 到 $b_n$ 的位置，每个位置放一个棋子。
    
    注意本题还有一个限制条件：有 $n$ 个既不在同一行又不在同一列的障碍。对于坐标为 $(i,j)$ 的障碍，意味着编号为 $a_i$ 的棋子，不能放入编号为 $b_j$ 的位置。因为障碍都不在同一行，说明每个棋子都只有一个位置不能放入。于是问题继续转化为：把编号为 $a_1$ 到 $a_n$ 的棋子放入编号为 $b_1$ 到 $b_n$ 的位置，每个位置放一个棋子，且每个棋子都有一个位置不能放，求一共有多少种方案。
    
    把棋子换成信封，我们得到了另一个题面：
    
    > 把 $n$ 个封信装到 $n$ 个信封中，但每封信都不能装到原本应该装入的信封中（换句话说就是每封信都要装错），求满足上述条件的方案数。
    
- 上面的问题就是大名鼎鼎的**装错信封问题**，也是我们要研究的**错位排序问题**。

	感觉我们平时用到的求解该问题的方法有两种：容斥原理和递推。这里我们讲一下更简单的递推。
    
    递推嘛，总要有一个递推式。
    
    为了方便说明，我们规定第 $k$ 封信的正确信封就是第 $k$ 个。
    
    设 $D(n)$ 表示把 $n$ 封信错装到 $n$ 个信封的方案数，下同。
    
    好，我们假设已经装好了 $n-1$ 个信封。
    
    接下来要把第 $n$ 封信装到信封中，除了第 $n$ 个信封之外，还有 $n - 1$ 个错误的信封。也就是第 $n$ 封信有 $n - 1$ 种装法。
    
    接下来我们着重讨论把第 $n$ 封信放在第 $k$ 个信封。
    
    这个时候我们要给“被偷家”的第 $k$ 封信找一个家，于是就有了两种情况：
    
    1. 被偷家的第 $k$ 封信反过来把第 $n$ 封信的家也偷了（也就是把第 $k$ 封信装入了第 $n$ 个信封），这样我们就确定了 $2$ 封信的位置，那么剩下的 $n - 2$ 封信要分装在 $n - 2$ 个错误信封中，即 $D(n - 2)$；
    
    2. 被偷家的第 $k$ 封信弄不过第 $n$ 封信，于是把别的信的家偷了（也就是第 $k$ 封信没有装入第 $n$ 个信封），这样实际上也就只有第 $n$ 封信这 $1$ 封信的位置确定了，剩下的 $n - 1$ 封信要分装在 $n - 1$ 个错误信封中，即 $D(n - 1)$。

	因为第 $k$ 封信在两种情况中并不在同一个位置，易证得两种情况不重不漏。
    
    所以说我们得到结论：把第 $n$ 封信放在第 $k$ 个位置，就有 $D(n - 2) + D(n - 1)$ 种方案数了。
    
    因为 $k$ 是一个变量，事实上 $k$ 可以有 $n - 1$ 种合法取值（也就是上面说到的第 $n$ 封信只有 $n - 1$ 种装法）。$k$ 每取一个数都会多出 $D(n - 2) + D(n - 1)$ 种方案数。$n - 1$ 个 $k$ 值会得到 $(n - 1) \cdot (D(n - 1) + D(n - 2))$ 种方案数。
    
    于是，我们由此就得到了得到错位排序的递推式：
    
    > $D(n) = (n - 1) \cdot (D(n - 1) + D(n - 2))$.
    
    > 特殊地，$D(1) = 0$，$D(2) = 1$.
    
    以上就是错位排序的递推算法了。
    
    洛谷有一道[错排模板题](https://www.luogu.com.cn/problem/P1595)，大家可以先做这个。
    
    我还找到了[一篇非常详细的博客](https://zhuanlan.zhihu.com/p/35318996)，里面有一些其他处理错排问题的办法，感兴趣且时间充裕的同学可以去看看。
    
- 下面我们回到本题。

	在讲完上面那一堆之后，你们大抵会发现这道题是一道裸的错排题。

	填一下上面递推推导的坑。当时我们规定了第 $k$ 封信的正确信封就是第 $k$ 个才推导出来的递推式，那么如果不是这样，会不会影响原本的结果呢？
    
    答案是不会。我们可以这么理解：
    
    > 即使每封信对应的正确位置编号发生了变化，但是每封信对应一个正确位置的一一对应关系是不变的，不管每封信对应的正确位置怎样变，始终满足每一封信对应一个正确位置。这样我们求解的方法不会变，答案自然不会变。
    
    说到这里，我们就会发现一件事，就是题目中给定的障碍位置完全是没用的（~~好讨厌啊~~）。这样我们只需要按照错位排序的递推式把这个题写出来就好啦。
    
- 注意范围是 $n \le 200$，这样一来我们就不可避免地用到高精了（~~或者直接  Python~~）。处理高精的时候注意处理前导零应该就问题不大了。

### 代码

~~你们大概可以在最优解第一页看到这份代码~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; 
struct high
{
	int a[500], len;
}f[205];
high add(high a, high b)
{
	for(int i = 1; i <= b.len; ++ i) a.a[i] += b.a[i];
	for(int i = 1; i <= b.len; ++ i)
		if(a.a[i] > 9) a.a[i] -= 10, a.a[i + 1] ++;
	if(a.a[a.len + 1] != 0) a.len ++;
	return a;
}//高精加
high mul(high a, int b)
{
	for(int i = 1; i <= a.len; ++ i) a.a[i] *= b;
	a.len += 4;
	for(int i = 1; i <= a.len; ++ i)
	{
		if(a.a[i] > 9) 
			a.a[i + 1] += a.a[i] / 10, a.a[i] %= 10;
	}
	while(a.a[a.len] == 0) a.len --;//处理前导零
	return a;
}//高精乘低精
void write(high a)
{
	for(int i = a.len; i >= 1; -- i) putchar(a.a[i] + '0');
	putchar('\n');
}//专门的输出
int main()//极短的主程序
{
	scanf("%d", &n);
	if(n == 1 || n == 2) { printf("%d\n", n - 1); return 0; }
	f[2].a[1] = 1; f[1].len = 1; f[2].len = 1;
	for(int i = 3; i <= n; ++ i)
		f[i] = mul(add(f[i - 1], f[i - 2]), i - 1);
	write(f[n]);
	return 0;//完结撒花
} 
```


---

## 作者：Haphyxlos (赞：4)

# P3182 【[HAOI2016]放棋子】
## 萌新的第二篇题解

[题目传送门](https://www.luogu.com.cn/problem/P3182)

本题是博主的作业题， 一开始的时候毫无思路，于是自己手造了几个小数据，推了一推。诞生了一个大胆的猜想，本题需要输入的矩阵对输出结果无影响。又推了推，发现成立。

推导：

因为每行都有一个障碍，而又要每行每列都有一个棋子，那显然，可以将障碍，和棋子各化为一个1至n的排列。好好思考一下 ~~（再加上今天刚讲错排）~~，就不难发现，这不就是道错排板子吗。

错排问题：

指考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。

经典例题：

有n个信封和n封信，求每个信封和每封信都装错的方案数。

以下是**错排问题**的板子：
```cpp
f[1]=0,f[2]=1;
for(int i=3;i<=n;++i){
	f[i]=(i-1)*(f[i-2]+f[i-1]);
}
```
虽然本题的思路结束了，但这可是一道省选题，那会这么简单。看看n的数据范围，就不难发现本题还要写高精。

理由：
经过初步计算，判断n=16时，便会爆int，在n>20时，会爆long long。可本题的**n≤200**，所以显然要用高精啦。

这里呢，我们就用重载运算符的方法啦。之所以用重载运算符呢，是因为珂以直接套错排板子，不用再重新写了。


以下是**重载运算符**的板子：
```cpp
struct node {
	int len,s[maxn];
	node(){memset(s,0,sizeof(s));len=1;}
	node(int num){*this=num;}
	node (const char *num){*this=num;}
	void clean(){while(len>1&&!s[len-1])len--;}
	string str()const{
		string res="";
		for(int i=0;i<len;++i)res=char(s[i]+'0')+res;
		return res;
	}
	node operator = (const int num){
		char s[maxn];
		sprintf(s,"%d",num);
		*this=s;
		return *this;
	}
	node operator = (const char *num){
		for(int i=0;num[i]=='0';++num) ;
		len=strlen(num);
		for(int i=0;i<len;++i)s[i]=num[len-i-1]-'0';
		return *this;
	}
	node operator + (const node &b)const{
		node c;
		c.len=0;
		for(int i=0,g=0;g||i<max(len,b.len);++i){
			int x=g;
			if(i<len)x+=s[i];
			if(i<b.len)x+=b.s[i];
			c.s[c.len++]=x%10,g=x/10;
		}
		return c;
	}
	node operator * (const node &b){
		node c;
		c.len=len+b.len;
		for(int i=0;i<len;++i){
			for(int j=0;j<b.len;++j){
				c.s[i+j]+=s[i]*b.s[j];
			}
		}
		for(int i=0;i<c.len;++i){
			c.s[i+1]+=c.s[i]/10,c.s[i]%=10;
		}
		c.clean();
		return c;
	}
};
ostream& operator << (ostream &out,const node &x) {
	out<<x.str();
	return out;
}
```
本题的AC代码就不贴出来了，反正就只要把上面的两个板子缝合一下就ok了。

本篇题解就到此结束了，如果喜欢，还请点个赞吧。

---

## 作者：QwQ_operator (赞：4)

一直认为这是个二分图问题，然而用二分图做不会做    ORZ。

然后没办法，只好换一种方法喽。。。。

唉，我们仔细观察这个题我们发现这是一道很典型的错排问题。

至于什么是错排，我们下面来看看。

当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.

第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；

第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；

综上得到

D(n) = (n-1) [D(n-2) + D(n-1)]

特殊地，D(1) = 0, D(2) = 1.

下面通过这个递推关系推导通项公式：

为方便起见，设D(k) = k! N(k), k = 1, 2, …, n,

则N(1) = 0, N(2) = 1/2.

n ≥ 3时，n! N(n) = (n-1) (n-1)! N(n-1) + (n-1)! N(n-2)

即 nN(n) = (n-1) N(n-1) + N(n-2)

于是有N(n) - N(n-1) = - [N(n-1) - N(n-2)] / n = (-1/n) [-1/(n-1)] [-1/(n-2)]…(-1/3) [N(2) - N(1)] = (-1)^n / n!.

因此
N(n-1) - N(n-2) = (-1)^(n-1) / (n-1)!,

N(2) - N(1) = (-1)^2 / 2!.

相加，可得

N(n) = (-1)^2/2! + … + (-1)^(n-1) / (n-1)! + (-1)^n/n!

因此
D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].

此即错排公式。

（本段来自百度百科）

我们还会发现一个问题，这个公式那么恶心，对于那种n很大的数我们要怎样办啊。

那这样我们就用一个递推式：

f[n]=(f[n-1]+f[n-2])\*(n-1)表示错排方案数的递推公式，因为可以视为新添加两个点，

如果前n-1个满足，那么这两个与其中任意一个互相交叉互换也一定满足；

如果前n-2个满足，最后两个不满足，那么直接交叉也使得可以满足。


这个题我们也可以将其转化成一个错排问题。

但由于这个题数据比较大，我们必须采用高精



下面奉上代码

```cpp
 #include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn = 201; 
const int mod = 100000000;
int n;
long long f[maxn][50];
int a[maxn];
int main()
{
    scanf("%d",&n); f[1][0]=0; f[2][0]=1; 
    for(int i=3;i<=n;i++) 
    {
    for(int j=0;j<=a[i-1];j++) 
      f[i][j]=f[i-1][j]+f[i-2][j];
    a[i]=a[i-1]; for(int j=0;j<=a[i-1];j++) 
    {
        f[i][j+1]+=f[i][j]/mod;
        f[i][j]%=mod;
    }
    while(f[i][a[i]+1]) a[i]++;
    for(int j=0;j<=a[i];j++) 
       f[i][j]*=(i-1);
    for(int j=0;j<=a[i];j++) 
    {
         f[i][j+1]+=f[i][j]/mod;
         f[i][j]%=mod;
    }  
    while(f[i][a[i]+1]) a[i]++;
    }
    printf("%lld",f[n][a[n]]);
    for(int i=a[n]-1;i>=0;i--) printf("%08lld",f[n][i]);
    return 0;
}
```

---

## 作者：撤云 (赞：3)

### [$$blog$$](https://www.cnblogs.com/hbxblog/p/10253205.html)

---

### 题目链接
[戳这](https://www.luogu.org/problemnew/show/P3182)

### 前置知识
+ 错位排序

### Solution

我们可以观察发现，每一行的障碍位置对答案并没有影响。

于是我们可以将此时的矩阵化成如下形式:  

> 1  0  0  0  
> 0  1  0  0  
> 0  0  1  0  
> 0  0  0  1  

此时障碍列的排列为:
1 2 3 4
于是我们问题可以转化为：
从每行中选出一个$1~n$的没出现的书且和障碍不相同
   
即：问一个$1~n$的数列的排列与原数列的位置都不相同的个数
   
所以这就是一个错位排序了，但是为了让代码量变大，便没有模数，所以要打高进度

### Code
~~我不会告诉你我的高进度是copy的模板的~~
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005;
struct bign {
	int len, s[MAXN];
	bign () {
		memset(s, 0, sizeof(s));
		len = 1;
	}
	bign (int num) {
		*this = num;
	}
	bign (const char *num) {
		*this = num;
	}
	bign operator = (const int num) {
		char s[MAXN];
		sprintf(s, "%d", num);
		*this = s;
		return *this;
	}
	bign operator = (const char *num) {
		for(int i = 0; num[i] == '0'; num++) ;
		len = strlen(num);
		for(int i = 0; i < len; i++) s[i] = num[len-i-1] - '0';
		return *this;
	}
	bign operator + (const bign &b) const {
		bign c;
		c.len = 0;
		for(int i = 0, g = 0; g || i < max(len, b.len); i++) {
			int x = g;
			if(i < len) x += s[i];
			if(i < b.len) x += b.s[i];
			c.s[c.len++] = x % 10;
			g = x / 10;
		}
		return c;
	}
	void clean() {
		while(len > 1 && !s[len-1]) len--;
	}
	bign operator * (const bign &b) {
		bign c;
		c.len = len + b.len;
		for(int i = 0; i < len; i++) {
			for(int j = 0; j < b.len; j++) {
				c.s[i+j] += s[i] * b.s[j];
			}
		}
		for(int i = 0; i < c.len; i++) {
			c.s[i+1] += c.s[i]/10;
			c.s[i] %= 10;
		}
		c.clean();
		return c;
	}
	string str() const {
		string res = "";
		for(int i = 0; i < len; i++) res = char(s[i]+'0')+res;
		return res;
	}
};
ostream& operator << (ostream &out, const bign &x) {
	out << x.str();
	return out;
}
bign d[2001];
int main() {
	int  n;
	cin>>n;
	d[2]=1;
	for(int i=3; i<=n; i++)
		d[i]=(d[i-1]+d[i-2])*(i-1);
	cout<<d[n];
	return 0;
}
```

---

## 作者：catandcode (赞：1)

看到题解区全用的错排，本蒟贡献一下不同的思路。

upd：组合数上下反了，更新一下。

------
我觉得这道题是高精加裸的容斥。

先放一个以点代格的手画样例，题目样例太水了 qaq。

![](https://cdn.luogu.com.cn/upload/image_hosting/3am832uw.png)

如果正向思维，考虑哪些方案可行太过复杂，所以我们可以思考有哪些方案是不能选择的。

首先，如果任意选取，则有 $\dbinom{4}{1}\cdot \dbinom{3}{1}\cdot \dbinom{2}{1}\cdot \dbinom{1}{1}$ 种方案。

强制选择 $A$ 点，共有 $\dbinom{3}{1}\cdot \dbinom{2}{1}\cdot \dbinom{1}{1}$ 种方案。

强制选择其他障碍点同理。

**但是**，我们在选取 $A$ 点时可同时选取其他障碍点，而在选取其他障碍点时也可选取 $A$ 点，相当于每个同时选取两个障碍点的方案都被计算了两次，因此我们需要再加上一份同时选取两个障碍点的方案。对于同时选取三个的方案，无疑又被多加了一次，到这里，**容斥** 的思路已经很明显了。

接下来需要考虑的就是在 $n$ 个障碍点中同时选取 $i$ 个的方案数。很明显的，共种 $\dbinom{n}{i}$ 选取障碍点的方案，每一种方案又有 $\prod\limits_{j=1}^{n-i}\dbinom{j}{1}$ 种子方案。

于是就有了计算式子：
$$ans=\sum_{i=0}^n(-1)^i\cdot \dbinom{n}{i}\prod_{j=1}^{n-i}\dbinom{j}{1}$$

所以题目给的地图根本没用 qaq。

------------
接下来才是本题难点：高精。

计算式中 $\prod\limits_{j=1}^{n-i}\dbinom{j}{1}$ 部分，实际上就是阶乘，可以用前缀积维护。

对于组合数，利用公式计算需要写高精除法，这个东西难写得很 ~~（我不会）~~，而传统的递推式方法空间会炸。

在写背包 DP 时有一个空间优化，叫做滚动数组。

组合数递推时，第 $(j,i)$ 项只和第 $(j-1,i-1)$ 项与第 $(j,i-1)$ 项有关，恰好可以滚动。

~~最后，写高精乘法怎么能不用 FFT 呢？~~

朴素高精乘法应该也能过……吧。

不管怎样，这道题被我们解决啦。

贴一下代码。
```cpp
#include<bits/stdc++.h>
#define ld long double
#define ll long long
using namespace std;
int n,mp[205][205];
namespace poly {
    const ld pi=acos(-1);
    struct comp {
        ld a,b;
        comp operator +(comp &x){ return {a+x.a,b+x.b}; }
        comp operator -(comp &x){ return {a-x.a,b-x.b}; }
        comp operator *(comp &x){ return {a*x.a-b*x.b,a*x.b+b*x.a}; }
        comp operator /(ld x){ return {a/x,b/x}; }
    }f[1<<17];
    int L,tol,r[1<<17];
    void FFT(comp *f,int type) {
        for(int i=0;i<L;++i) {
            r[i]=(r[i>>1]>>1)+(i&1?L>>1:0);
            if(i<r[i]) swap(f[i],f[r[i]]);
        }
        for(int k=1;k<L;k<<=1) {
            comp wk={cos(pi/k),sin(pi/k)};
            wk.b*=type;
            static comp w[1<<17];
            w[0]={1,0};
            for(int i=1;i<k;++i) w[i]=w[i-1]*wk;
            for(int i=0;i<L;i+=k<<1)
                for(int j=0;j<k;++j) {
                    comp x=f[i|j],y=w[j]*f[i|j|k];
                    f[i|j]=x+y,f[i|j|k]=x-y;
                }
        }
        if(type==-1) for(int i=0;i<L;++i) f[i]=f[i]/L;
    }
}using namespace poly;//FFT部分

struct hp {
    short a[20005];
	int m;
    hp(){ memset(a,0,sizeof(a)); m=0; }
    hp operator +(hp e) {
        hp w;
        for(int i=0;i<max(e.m,m);++i) {
            w.a[i]+=a[i]+e.a[i];
            w.a[i+1]+=w.a[i]/10,w.a[i]%=10;
        }
        w.m=max(e.m,m)+(w.a[max(e.m,m)]>0);
        return w;
    }
    hp operator *(hp e) {
        hp w;
        memset(f,0,sizeof(f));
        for(int i=0;i<m;++i) f[i].a=a[i];
        for(int i=0;i<e.m;++i) f[i].b=e.a[i];
        L=1,tol=m+e.m;
        while(L<=tol) L<<=1;
        FFT(f,1);
        for(int i=0;i<L;++i) f[i]=f[i]*f[i];
        FFT(f,-1);
        for(int i=0;i<=tol;++i) {
            w.a[i]+=(int)(f[i].b/2+0.5);
            w.a[i+1]+=w.a[i]/10,w.a[i]%=10;
        }
        while(!w.a[tol]&&tol) --tol;
        w.m=tol+1;
        return w;
    }
    hp operator -(hp e) {
        hp w;
        int lm=max(m,e.m);
        for(int i=0;i<lm;++i) {
            w.a[i]+=a[i]-e.a[i];
            if(w.a[i]<0) w.a[i]+=10,--w.a[i+1];
        }
        while(lm&&w.a[lm]==0) --lm;
        w.m=lm+1;
        return w;
    }
}C[205],s[205],ans;
hp change(int x) {
    hp w;
    while(x) {
        w.a[w.m++]=x%10;
        x/=10;
    }
    return w;
}//将一般数转化为高精
void print(hp x) {
    for(int i=x.m-1;i>=0;--i) cout<<x.a[i];
    cout<<endl;
}//输出函数
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);
    cin>>n;
    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) cin>>mp[i][j];
    s[0]=change(1);
    for(int i=1;i<=n;++i) s[i]=s[i-1]*change(i);//前缀积
    C[0]=change(1);
    for(int i=1;i<=n;++i)
		for(int j=i;j>=1;--j)//注意倒序循环，不然会覆盖
			C[j]=C[j-1]+C[j];
    for(int i=0,r=1;i<=n;++i,r*=-1)
    	if(r>0) ans=ans+C[i]*s[n-i];
    	else ans=ans-C[i]*s[n-i];
    print(ans); 
    return 0;
}

```

---

## 作者：_Flame_ (赞：1)

这是一道不错的 **错排** 题。

首先，题目中保证任意两个障碍不在同一行也不在同一列，那障碍的实际位置对答案便不会有影响，我们总可以交换行列位置使得第 $i$ 行的障碍在第 $i$ 列。

于是题目就变得简单起来了。我们只用求从 $1$ 到 $n$ 的一个使得 $a_{i}$ 不等于 $i$ 的排列
。

我们用一个 $f$ 数组来统计总方案数, $x$ 表示棋子总个数，我们可以分类讨论一下来求出递推式。当 $a_{x}=i$ 且 $a_{i}=x$ 时，问题就变成了剩下 $x-2$ 个棋子的错排问题。否则对另外的这 $x-1$ 个棋子，明显会有 $f(x-1)$ 种排法。

对于 $i$ 有 $x-1$ 种情况，所以得出式子为 $f(x)=(x-1)(f(x-1)+f(x-2))$

于是码出代码如下


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int f[1000010];
int t;
signed main(){
	cin>>n;
	f[1]=0;
	f[2]=1;
	for(int i=3;i<=n;i++){
		t=i-1;
		f[i]=(f[i-1]+f[i-2])*t;
	}
	cout<<f[n];
}

```

但是并没有过，只有 $60$ 分。

于是我有回去看了一下题面，发现 $x$ 小于等于 $200$ 。这道题要用高精度！

于是我用了 python 。

c++ 多写一个高精度就好了。

## 代码
```cpp
n=int(input());
f=[0 for i in range(210)];
f[2]=1;
f[3]=2;
for i in range(3,n+1):
    f[i]=(f[i-1]+f[i-2])*(i-1);
print(f[n]);

```

---

## 作者：V1mnkE (赞：1)

## 思路
这道题本质上是一道裸的**错排**问题。

首先分析一下题目，保证任意两个障碍不在同一行或同一列，那实际上障碍的具体位置就没有任何作用，我们总是可以通过交换行的位置，使第 $i$ 行的障碍在第 $i$ 列。

那就转化成了求 $1\sim n$ 的一个排列，使 $a_i\ne i$。

令 $f(n)$ 表示总方案数，$a_n=x$ 时，考虑分类讨论：

- $a_x=n$ 时，显然转换成了剩下 $n-2$ 个元素的错排。
- $a_x\ne n$ 时，则对这 $n-1$ 个元素有 $f(n-1)$ 种方法。

又因 $x$ 有 $n-1$ 种可能，可以得到式子: $f(n)=(n-1)(f(n-1)+f(n-2))$。

然后 c++ 党写高精度就可以了。

## 代码
~~python大法好~~
```python
n=int(input())
ans=[0,0,1]
for i in range(3,n+1):
	ans.append((i-1)*(ans[i-1]+ans[i-2]))
print(ans[n])
```


---

## 作者：luozhichen (赞：1)

[题目直通车](https://www.luogu.com.cn/problem/P3182)

## 大意:

问你有多少种方法使 $n$ 个棋子同一列，同一行。


## 思路：

错排和高精度

此题就是将 [P1595](https://www.luogu.com.cn/problem/P1595) 加上了高精度。


错排模板:

```cpp
f[0] = 1;
f[1] = 0;
for(int i = 2;i <= n;i++){
	f[i] = (i - 1) * (f[i - 1] + f[i - 2]);
}
```

高精度模板:

```cpp
void add(int m){//高精乘和高精加,把f[i] = (i - 1) * (f[i - 1] + f[i - 2]) 高精化
    int x = 0;
    for(int i = 1;i < 100001;i++){//高精加 
        f[m][i] = f[m - 1][i] + f[m - 2][i] + x;
        x = f[m][i] / 10;
        f[m][i] %= 10;
    }
    x = 0;
    for(int i = 1;i < 100001;i++){//高精乘 
        f[m][i] = f[m][i] * (m - 1) + x;
        x = f[m][i] / 10;
        f[m][i] %= 10;
    }
}
```

## 代码:

代码 1:

```cpp
#include<bits/stdc++.h>//直接高精计算
using namespace std;
int n;
int f[201][100001];
void add(int m){//高精 
    int x = 0;
    for(int i = 1;i < 100001;i++){//高精加 
        f[m][i] = f[m - 1][i] + f[m - 2][i] + x;
        x = f[m][i] / 10;
        f[m][i] %= 10;
    }
    x = 0;
    for(int i = 1;i < 100001;i++){//高精乘 
        f[m][i] = f[m][i] * (m - 1) + x;
        x = f[m][i] / 10;
        f[m][i] %= 10;
    }
}
int main(){
    scanf("%d",&n);
    f[2][1] = 1;//正在初始化 
    if(n == 1||n == 2){//特判 
        printf("%d",n - 1);
        return 0;
    }
    for(int i = 3;i <= n;i++){//递推中 
    	add(i);
	}
    int a = 100001;//位数弄大点 
    while(f[n][a] == 0){//去前缀0 
    	a--;
	}
    while(a){//输出 
    	printf("%d",f[n][a--]);	
	}
    return 0;
} 
```

代码 2 (重载运算符）:


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005;
struct bign {//重载运算符模板
	int len, s[MAXN];
	bign () {
		memset(s, 0, sizeof(s));
		len = 1;
	}
	bign (int num) {
		*this = num;
	}
	bign (const char *num) {
		*this = num;
	}
	bign operator = (const int num) {
		char s[MAXN];
		sprintf(s, "%d", num);
		*this = s;
		return *this;
	}
	bign operator = (const char *num) {
		for(int i = 0; num[i] == '0'; num++) ;
		len = strlen(num);
		for(int i = 0; i < len; i++) s[i] = num[len-i-1] - '0';
		return *this;
	}
	bign operator + (const bign &b) const {
		bign c;
		c.len = 0;
		for(int i = 0, g = 0; g || i < max(len, b.len); i++) {
			int x = g;
			if(i < len) x += s[i];
			if(i < b.len) x += b.s[i];
			c.s[c.len++] = x % 10;
			g = x / 10;
		}
		return c;
	}
	void clean() {
		while(len > 1 && !s[len-1]) len--;
	}
	bign operator * (const bign &b) {
		bign c;
		c.len = len + b.len;
		for(int i = 0; i < len; i++) {
			for(int j = 0; j < b.len; j++) {
				c.s[i+j] += s[i] * b.s[j];
			}
		}
		for(int i = 0; i < c.len; i++) {
			c.s[i+1] += c.s[i]/10;
			c.s[i] %= 10;
		}
		c.clean();
		return c;
	}
	string str() const {
		string res = "";
		for(int i = 0; i < len; i++) res = char(s[i]+'0')+res;
		return res;
	}
};
ostream& operator << (ostream &out, const bign &x) {
	out << x.str();
	return out;
}
bign d[2001];
int n;
int main(){
	cin >> n;
	d[2] = 1;
	for(int i = 3;i <= n;i++){
		d[i] = (d[i - 1] + d[i - 2]) * (i - 1);
	}
	cout << d[n];
	return 0;
}
```


---

## 作者：Exschawasion (赞：0)

**本题的模型**。首先思考性质并抽象模型：

由于任意两个障碍不在同一行，也不在同一列，即障碍互不影响，所以可以将**任意两行**交换而不影响答案。如下图（灰色格子表示障碍）；

![](https://i.bmp.ovh/imgs/2022/07/15/0605b2e275352007.png)

同理，**任意两列**交换亦不影响答案。这意味着总可以通过交换把棋盘变换成**一条斜对角线均为障碍**的棋盘（即单位矩阵）；

![](https://i.bmp.ovh/imgs/2022/07/15/14da1fc2c0cdfeb5.png)

由于各行各列只能放一个，如果依次考虑各行，将每一行放置的棋子的位置记录成下来，可以发现**这是一个 $1$ 至 $n$ 的排列**。如下图放置的棋子序列便是 $\texttt{53214}$（蓝色格子表示棋子）

![](https://i.bmp.ovh/imgs/2022/07/15/1dce1f4550feea89.png)

并且，只能在无障碍格子中放置棋子，所以显然在这个排列的第 $i$ 个数字不可能是 $i$，即诸如 $\texttt{15}\color{red}\texttt{3}\color{black}\texttt{42}$、$\texttt{253}\color{red}\texttt{4}\color{black}\texttt{1}$ 这类排列是不合法的。至此，本题要求的是便是这类排列的数量，专有名词叫[**错位重排**](https://baike.baidu.com/item/%E9%94%99%E4%BD%8D%E9%87%8D%E6%8E%92/9967097?fr=aladdin)。

**推导递推式**。设 $D_n$ 表示对应错位重排的数量：

- 首先第一个元素可以放置在第一排的 $n-1$ 个位置中；
- 第二个元素需要注意不和第一个元素冲突。有两种方式：

	- 如果放置在第一列（肯定不会和第一枚棋子冲突，原因见定义），则接下来的 $n-2$ 枚棋子不受太大影响，可以当作 $n-2$ 大小的棋盘，即 $D_{n-2}$；
    - 如果放置在除了第一列的其他列，这样有 $n-1$ 种方式，可以当作 $n-1$ 大小的棋盘，即 $D_{n-1}$。

根据乘法原理可得 $D_n=(n-1)(D_{n-2}-D_{n-1})$，即为公式。初始值不难推导出：$D_1=0,D_2=1$。

错位重排的公式在上面给出的链接中也可以直接查到。

由于最终答案可能很大，所以需要高精度来计算。本题不需要高精度的弱化版是 [P1595](https://www.luogu.com.cn/problem/P1595)。

关键代码如下（建议选手自行默写巩固 $\texttt{NTT}$ 的代码）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+5;
namespace ntter{
	static const int mod=998244353;
	int r[maxn];
	int n;
	inline int qpow(int a,int b){
		long long ans=1;
		while(b){
			if(b&1)ans=1ll*ans*a%mod;
			a=1ll*a*a%mod,b>>=1;
		}
		return ans;
	}
	void ntt(int *a,bool f){
		for(register int i=0;i<n;i++)if(r[i]>i)swap(a[i],a[r[i]]);
		for(register int i=1;i<n;i<<=1){
			int g=qpow(3,(mod-1)/(i<<1));
			if(!f)g=qpow(g,mod-2);
			for(register int j=0;j<n;j+=(i<<1)){
				int w=1;
				for(register int k=0;k<i;k++){
					int x=a[j+k],y=1ll*w*a[i+j+k]%mod;
					a[j+k]=x+y,a[j+k]%=mod,a[j+k]+=mod,a[j+k]%=mod;
					a[i+j+k]=x-y+mod,a[i+j+k]%=mod,a[i+j+k]+=mod,a[i+j+k]%=mod;
					w=1ll*w*g%mod;
				}
			}
		}
		if(!f){
			int g=qpow(n,mod-2);
			for(register int i=0;i<n;i++)a[i]=1ll*a[i]*g%mod;
		}
	}
	void mul(int &alen,int *a,int blen,int *b){
		int m,len=0;
		m=max(alen,blen);
		for(n=1,m<<=1;n<m;n<<=1)len++;
		for(register int i=0;i<n;i++)r[i]=(r[i>>1]>>1|((i&1)<<(len-1)));
		ntt(a,1),ntt(b,1);
		for(register int i=0;i<n;i++)a[i]=1ll*a[i]*b[i]%mod;
		ntt(a,0);
		for(register int i=0;i<=m;i++)a[i+1]+=a[i]/10,a[i]%=10;
		while(!a[m])m--;
		alen=m+1;
	}
};
struct bigint{
	int len;
	int x[maxn];
	bigint(){
		len=0;
		memset(x,0,sizeof(x));
	}
	bigint(const string&s){
		len=s.length();
		for(int i=0;i<len;i++)x[i]=s[len-i-1]-'0';
		while(!x[len-1]&&len)len--;
	}
	bigint(const int& b){
		string s="";
		int a=b;
		if(a==0)s="0";
		while(a)s=char('0'+a%10)+s,a/=10;
		len=s.length();
		for(int i=0;i<len;i++)x[i]=s[len-i-1]-'0';
		while(!x[len-1]&&len)len--;
	}
	bigint operator+(const bigint&b)const{
		bigint c;
		int l=max(len,b.len);
		c.len=l+2;
		for(int i=0;i<l;i++)c.x[i]+=b.x[i]+x[i],c.x[i+1]+=c.x[i]/10,c.x[i]%=10;
		while(!c.x[c.len-1]&&len)c.len--;
		return c;
	}
	bigint operator*(const bigint&b)const{
		bigint c=(*this),d=b;
		ntter::mul(c.len,c.x,d.len,d.x);
		return c;
	}
};
ostream& operator<<(ostream& out,const bigint&a){
	if(a.len==0){
		out<<'0';
		return out;
	}
	for(int i=a.len-1;~i;i--)out<<a.x[i];
	return out;
}
istream& operator>>(istream& in,bigint&a){
	string s;in>>s;
	a.len=s.length();
	for(int i=0;i<a.len;i++)a.x[i]=s[a.len-i-1]-'0';
	while(!a.x[a.len-1]&&a.len-1)a.len--;
	return in;
}
bigint a,b,c;
bigint t;
int main(){
	int n;scanf("%d",&n);
	if(n==1)return puts("0")&&0;
	if(n==2)return puts("1")&&0;
	a=0,b=1,c=0;
	for(int i=3;i<=n;i++){
		t=n-1;
		c=t*(a+b);
		a=b;
		b=c;
	}
	cout<<c;
	return 0;
}
```

**拓展**：除了使用 $\texttt{NTT}$ 来加速乘法计算之外，观察本题的递推式：

$$D_n=(n-1)(D_{n-2}-D_{n-1})$$

$$D_n=(n-1)D_{n-2}-(n-1)D_{n-1}$$

$$D_n = \lfloor \frac{n!}{e} \rfloor$$

不过实际运用上由于 $e$ 的精度有限，该公式用途不大。

---

## 作者：BigJoker (赞：0)

# Solution

我们将问题转化一下，实际上就是每一个位置上可以任意选择一个数，但是这个数不能和这一行本身的某一个数相等，发现其实就是错位排序，下面给的矩阵没有丝毫作用。

既然是错位排序，我们来推一下式子。

设 $f_i$ 表示将前 $i$ 个数进行错位排序的方案数。

对于第 $i$ 个数，我们肯定不能将他放在第 $i$ 个位置上。

有两种情况：

* 前面 $i-1$ 个全部放错了，第 $i$ 个与前面任意一个交换即可。

* 前面有 $i-2$ 个放错了，$i$ 只需要与正确的那个交换即可。

可以得到我们的式子：

$f_i\gets (i-1)\times (f_{i-1}+f_{i-2})$

为什么是 $f_{i-2}$ 呢，因为我们考虑前 $i-1$ 个当中会有一个和自己的位置相等，因此必须是 $f_{i-2}$。

# Code

```cpp
#include<bits/stdc++.h>
//#define int __int128
#define mem(a,x) memset(a,x,sizeof(a))
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define lowbit(x) x&-x
#define re register
#define il inline
using namespace std;
typedef long long LL;
const int N=2e2+5;
il int qr(){
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') (ch=='-'?f=-1:1),ch=getchar();
	while(ch>='0' && ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
	return s*f;
}
il void qw(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) qw(x/10);
	putchar(x%10+'0');
}
const int L=100005;  
string add(string a,string b){  
    string ans;  
    int na[L]={0},nb[L]={0};  
    int la=a.size(),lb=b.size();  
    for(int i=0;i<la;i++) na[la-1-i]=a[i]-'0';  
    for(int i=0;i<lb;i++) nb[lb-1-i]=b[i]-'0';  
    int lmax=la>lb?la:lb;  
    for(int i=0;i<lmax;i++) na[i]+=nb[i],na[i+1]+=na[i]/10,na[i]%=10;  
    if(na[lmax]) lmax++;  
    for(int i=lmax-1;i>=0;i--) ans+=na[i]+'0';  
    return ans;  
}   
int sub(int *a,int *b,int La,int Lb) {  
    if(La<Lb) return -1;//如果a小于b，则返回-1  
    if(La==Lb)  
    {  
        for(int i=La-1;i>=0;i--)  
            if(a[i]>b[i]) break;  
            else if(a[i]<b[i]) return -1;//如果a小于b，则返回-1  
  
    }  
    for(int i=0;i<La;i++)//高精度减法  
    {  
        a[i]-=b[i];  
        if(a[i]<0) a[i]+=10,a[i+1]--;  
    }  
    for(int i=La-1;i>=0;i--)  
        if(a[i]) return i+1;//返回差的位数  
    return 0;//返回差的位数  
  
}
string mul(string a,string b) {  
    string s;  
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积  
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0  
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数  
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';  
    for(int i=1;i<=La;i++)  
        for(int j=1;j<=Lb;j++)  
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）  
    for(int i=1;i<=La+Lb;i++)  
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位  
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0  
    for(int i=La+Lb-1;i>=1;i--)  
        s+=nc[i]+'0';//将整形数组转成字符串  
    return s;  
}
string str(long long j){
	string b="";
	char a[50005];
	long long l=j,len=0;
	while(l){
		a[len]=l%10+'0';
		len++;l/=10;
	}for(int k=len-1;k>=0;k--){
		b+=a[k];
	}return b;
}
long long qpow(long long x,long long y) {
	long long ans=1,a=x;
	while(y) {
		if(y&1) ans=ans*x%1000;
		x=x*x%1000;
		y>>=1;
	}
	return ans;
}
string div(string n1,string n2,int nn)//n1,n2是字符串表示的被除数，除数,nn是选择返回商还是余数  
{  
    string s,v;//s存商,v存余数  
     int a[L],b[L],r[L],La=n1.size(),Lb=n2.size(),i,tp=La;//a，b是整形数组表示被除数，除数，tp保存被除数的长度  
     fill(a,a+L,0);fill(b,b+L,0);fill(r,r+L,0);//数组元素都置为0  
     for(i=La-1;i>=0;i--) a[La-1-i]=n1[i]-'0';  
     for(i=Lb-1;i>=0;i--) b[Lb-1-i]=n2[i]-'0';  
     if(La<Lb || (La==Lb && n1<n2)) {  
            //cout<<0<<endl;  
     return n1;}//如果a<b,则商为0，余数为被除数  
     int t=La-Lb;//除被数和除数的位数之差  
     for(int i=La-1;i>=0;i--)//将除数扩大10^t倍  
        if(i>=t) b[i]=b[i-t];  
        else b[i]=0;  
     Lb=La;  
     for(int j=0;j<=t;j++)  
     {  
         int temp;  
         while((temp=sub(a,b+j,La,Lb-j))>=0)//如果被除数比除数大继续减  
         {  
             La=temp;  
             r[t-j]++;  
         }  
     }  
     for(i=0;i<L-10;i++) r[i+1]+=r[i]/10,r[i]%=10;//统一处理进位  
     while(!r[i]) i--;//将整形数组表示的商转化成字符串表示的  
     while(i>=0) s+=r[i--]+'0';  
     //cout<<s<<endl;  
     i=tp;  
     while(!a[i]) i--;//将整形数组表示的余数转化成字符串表示的</span>  
     while(i>=0) v+=a[i--]+'0';  
     if(v.empty()) v="0";  
     //cout<<v<<endl;  
     if(nn==1) return s;  
     if(nn==2) return v;  
}

int n=qr();
string f[N];
int main(){
	f[0]="1";
	for(re int i=2;i<=n;i++) f[i]=mul(str(i-1),add(f[i-1],f[i-2]));
	cout<<f[n];
	return 0;
}
```

---

## 作者：安好 (赞：0)

/\*
每一行每一列只能放一个

方案数就可以转化为错排问题

要写高精度

练了练封装+压位 压9位纯为了练习

\*/






```cpp
#include <iostream>
#include <cstdio>
#include<iomanip>
#define N 5050
#define mod 1000000000
#define _ 9
#define ll long long
using namespace std;
ll n;
struct num
{
    ll d[N],w;
}D[N],id;
num operator +(num p1,num p2)
{
    num ret=id;
    ll g=0;
    if (p1.w<p2.w) swap(p1,p2);
    ret.w=p1.w;
    for (ll i=1;i<=p1.w;i++)
    {
        ret.d[i]=(p1.d[i]+p2.d[i]+g)%mod;
        g=(p1.d[i]+p2.d[i]+g)/mod;
    }
    while(g) ret.d[++ret.w]=g%mod , g/=mod;
    return ret;
}
num mul(num p1,ll p2)
{
    num ret=id;
    ret.w=p1.w;
    ll g=0;
    for (ll i=1;i<=p1.w;i++)
    {
        ret.d[i]=(p1.d[i]*p2+g)%mod;
        g=(p1.d[i]*p2+g)/mod;
    }
    while(g) ret.d[++ret.w]=g%mod,g/=mod;
    return ret;
}
ostream& operator << (ostream &os,num x)
{
    ll i;
    os<<x.d[x.w];
    for(i=x.w-1;i;i--)
        os<<setfill('0')<<setw(_)<<x.d[i];
    return os;
}
int main()
{
//    freopen("firstmeet.in","r",stdin);
//    freopen("firstmeet.out","w",stdout);
    scanf("%d",&n);
    if (n == 1)
    {
        puts("0");
        return 0;
    }
    D[1]=id;
    D[2].w=D[2].d[1]=1;
    for (ll i=3;i<=n;i++)
      D[i] = mul((D[i-1]+D[i-2]),i-1);
    cout<<D[n];
    return 0;
}
```

---

## 作者：August_Light (赞：0)

# P3182 [HAOI2016] 放棋子 题解

[题目传送门](https://www.luogu.com.cn/problem/P3182)

## 题意简述

给你一个 $N \times N$ 的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列，要求你在这个矩阵上放 $N$ 枚棋子（障碍的位置不能放棋子），要求你放 $N$ 个棋子也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。

$N \le 200$。

## 解法

蓝题？建议评黄。

首先发现矩阵没用。因为完全可以把所有的障碍排在对角线上达到相同效果。

然后发现答案变为长度为 $n$ 的[错排列](https://oi-wiki.org/math/combinatorics/derangement/)数目。

> （摘自 OI Wiki）即，对于 $1\sim n$ 的排列 $P$，如果满足 $P_i\neq i$，则称 $P$ 是 $n$ 的错位排列。

然后想起小学二年级就学过的错排列数目递推式：

$$f_n = \begin{cases} 0 & n = 1 \\ 1 & n = 2 \\ (n-1)(f_{n-1}+f_{n-2}) & n \ge 3 \end{cases}$$

推导过程：

设 $n$ 号元素放在 $i$ 号位置。（$1 \le i \le n-1$）

- 如果 $i$ 号元素放在 $n$ 号位置，则变为 $n-2$ 的子问题。

- 否则变为 $n-1$ 的子问题。

不算高精的话，时间复杂度 $O(n)$，空间复杂度 $O(1)$。

## 代码

因为要高精所以写 python。

```python
def P3182(n: int):
    a, b = 0, 1
    if n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        for i in range(3, n+1):
            a, b = b, (i-1) * (a+b)
        return b

n = int(input())
print(P3182(n))
```

## 双倍经验

[P1595 信封问题](https://www.luogu.com.cn/problem/P1595)

---


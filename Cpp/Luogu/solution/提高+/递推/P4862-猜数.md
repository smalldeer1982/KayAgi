# 猜数

## 题目背景

Iris 和 Beryl 两人在玩一个猜数的游戏。

## 题目描述

游戏是这样进行的：给定一个正整数 $n$，Iris 在 $S=\{1,2,...,n\}$ 中选择一个数 $m$。  

然后，Iris 要如实回答 Beryl 的若干个问题，这些问题的形式是：“$m$ 是集合 $A$ 中的元素吗？”其中 $A\subseteq S$。   
如果Iris回答“是”，则 Beryl 要给 Iris $a$ 元钱；否则，Beryl 要给 Iris $b$ 元钱。（数据保证 $a>b$）

那么，Beryl 至少准备多少钱，就一定能确定 Iris 心中的数字呢？

## 说明/提示

【样例1的第1组数据解释】 

Beryl先对集合 $\{1\}$ 进行询问，若得到的答案是“是”，则已经确定 Iris 选的数为 $1$，需要 $2$ 元。若得到的答案是“否”，则再对集合 $\{2\}$ 进行询问，显然运气最差要再花 $2$ 元，共 $3$ 元，故答案为 $3$ 元。   

----   

【数据范围】  

| 测试点编号 | $n$ |$t$| $a$,$b$ |
| :----------- | :----------- | :----------- | :----------- |
| 1 | $\leq 20$ | $\leq 10$ | $\leq 20$ |
| 2 | $\leq 20$ | $\leq 10$ | $\leq 20$ |
| 3 | $\leq 2000$ | $\leq 100$ | $\leq 500$ |
| 4 | $\leq 2000$ | $\leq 100$ | $\leq 500$ |
| 5 | $\leq 2000$ | $\leq 100$ | $\leq 500$ |
| 6 | $\leq 2000$ | $\leq 100$ | $\leq 500$ |
|7  | $\leq 2000$ | $\leq 100$ | $\leq 500$ |
| 8 | $\leq 10^{18}$ | $\leq 200$ | $a=2$,$b=1$ |
| 9 | $\leq 10^{18}$ | $\leq 200$ | $a=2$,$b=1$ |
| 10 | $\leq 10^{18}$ | $\leq 200$ | $a=2$,$b=1$ |



## 样例 #1

### 输入

```
2 1 2
3
6```

### 输出

```
3
5```

## 样例 #2

### 输入

```
5 3 1
3```

### 输出

```
8```

# 题解

## 作者：Leap_Frog (赞：6)

# P4862猜数（题解）
## PS.
讲一下个人对于这道题的心路历程吧。  
这道题就是一道硬生生把两道题合并成一道的经典例子。  
首先，看到这道题时，没有看到数据范围，然后这道题就被放置了很久。  
后来才发现最后几个$\texttt{n}$特别大的测试数据点的$\texttt{a=2}$与$\texttt{b=1}$。  
然后，即使$\texttt{a=2}$且$\texttt{b=1}$，我仍然不会做 ~~我就是菜~~  
于是，我想骗一下$\texttt{70}$分的做法，然后想到了递推。  
然后，过了很久，又想到去把$\texttt{a=2}$与$\texttt{b=1}$去带入递推式，打表找一下规律。  
突然发现答案有关菲波那切数列，就做出来了。  
**~~借此我想告诉大家，我也不知道为什么答案是这样的~~**  

## Solution.
### 70 point
首先，引进一个~~感性理解~~定理：  
**在m在S中并且S的元素数目不变的前提下，Iris选择的数m以及S的元素对答案是没有影响的。**  
所以，我们可以设$\texttt{f(n)}$表示在$\texttt{[1,n]}$，问出答案的最优策略花费的金额。  
$$\texttt{f(x)}=\left\{\begin{aligned}\texttt{0}\quad\texttt{(x==1)}\\\texttt{min\{max(f(i)+a,f(x-i)+b)\}}\quad\texttt{(x!=1)}\end{aligned}\right.$$
然鹅这个递推式的复杂度是$\texttt{O(n}^\texttt{2}\texttt{)}$，只能骗来$\texttt{70}$分。  
### 30 point
但是，我们把$\texttt{a=2}$和$\texttt{b=1}$带入上式，然后打表找一下规律。  
我打出了这个表
```
1 ans=0
2 ans=2
3 ans=3
4 ans=4
5 ans=4
6 ans=5
7 ans=5
8 ans=5
9 ans=6
10 ans=6
11 ans=6
12 ans=6
13 ans=6
14 ans=7
```
经过整理后是这样的
```
1-1  0	1
2-2  2	2
3-3  3	3
4-5  4	5
6-8  5	8
9-13 6	13
.    .
.    .
.    .
```
我们发现，最右端是斐波那契数列，然后再打一通表，就发现$\texttt{f(100)>10}^\texttt{18}$。  
所以复杂度是$\texttt{O(max(100,t))}$，能过。  
至此，这道题终于做完了。  

## Coding.
有SB特判，有注释版本
```cpp
#include<bits/stdc++.h>		//我爱用万能头
using namespace std;
typedef long long ll;
const int N=2000,M=100;		//N表示前7个点的范围，M表示后3个点的范围
int a,b,t;ll n,f[N+5];
inline void work1()		//处理前7个点。
{
	memset(f,0x3f,sizeof(f)),f[1]=0;	//要求最大值的最小值，初始值INF
	for(int i=1;i<=N;i++)
		for(int j=1;j<i;j++)
			f[i]=min(f[i],max(f[j]+a,f[i-j]+b));	//由上面的递推式得到
	while(t--) scanf("%lld",&n),printf("%lld\n",f[n]);	//回答询问
}
inline void work2()		//处理后3个点。
{
	f[0]=1,f[1]=1;
	for(int i=2;i<=M;i++) f[i]=f[i-1]+f[i-2];	//预处理斐波那契数列
	while(t--)
	{
		scanf("%lld",&n);
		if(n==1) {puts("0");continue;}	//SB特判
		for(int i=1;i<=M;i++) if(n<=f[i]) {printf("%d\n",i);break;}		//打表找出的规律
	}
}
int main()
{
	scanf("%d%d%d",&a,&b,&t);
	if(a!=2||b!=1) work1();		//处理前7个点
	else work2();	//处理后3个点
	return 0;
}
```
不用SB特判，无注释版本：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2000,M=100;
int a,b,t;ll n,f[N+5];
inline void work1()
{
	memset(f,0x3f,sizeof(f)),f[1]=0;
	for(int i=1;i<=N;i++)
		for(int j=1;j<i;j++)
			f[i]=min(f[i],max(f[j]+a,f[i-j]+b));
	while(t--) scanf("%lld",&n),printf("%lld\n",f[n]);
}
inline void work2()
{
	f[0]=1,f[1]=1;
	for(int i=2;i<=M;i++) f[i]=f[i-1]+f[i-2];
	while(t--)
	{
		scanf("%lld",&n);
		for(int i=0;i<=M;i++) if(n<=f[i]) {printf("%d\n",i);break;}
	}
}
int main()
{
	scanf("%d%d%d",&a,&b,&t);
	if(a!=2||b!=1) work1();
	else work2();
	return 0;
}
```

---

## 作者：unputdownable (赞：3)

这是一道出题人二合一，但是完全不用二合一的题。

转化一下题意。

不难发现题目所说的这个东西类似于二分，考虑画出这个二分的决策树。

![](https://cdn.luogu.com.cn/upload/image_hosting/bgbzllxs.png)

这是 $a=2,b=1$，准备了 $4$ 元钱的决策树，可以用二分区分出 $5$ 个数。

--------

考虑二分答案，直接二分需要准备的钱数，也就是决策树的最大深度。

记我们正在二分的深度为 $lim$。

不难发现每个叶子对应一个最终的答案，于是深度为 $lim$ 时能二分出答案的条件为叶子数目大于等于 $n$。

~~（最大深度与决策树叶子数目正相关应该都能看出来吧）~~

于是问题转化成如何求叶子最多的决策树的叶子数目。

--------

~~（考虑到我不会求叶子，所以再转化一下）~~

注意到上面的那棵树没画完，因为 $2,3,5$ 这 $3$ 个节点下面还可以往右再接一个 $+1$ 的子节点。

但是可以发现只有一个儿子的节点是没有意义的，因为这样连下去的必然是一条 $+b+b+b\dots$ 的链，只能连出一个叶子。

不如直接将这些链砍去，这样我们的决策树就变成一棵节点只有 $0$ 或 $2$ 个儿子的二叉树了，记这个性质为性质 $A$。

性质 $A$ 是非常有用的，因为满足性质 $A$ 的二叉树满足叶子节点比非叶子节点恰好多一个。证明是每个非叶子节点对应两条边，一共 $n-1$ 条边，算一下就能得到答案。

另外注意到所有非叶子节点必须连出 $+a,+b$ 两条边，所以深度都小于等于 $lim-a$；

而所有叶子节点都不能连出 $+a$ 这条边，则表示叶子节点深度都大于 $lim-a$。

于是问题转化成求某个决策树（深度为 $lim-a$）的节点数目。

--------

下文记 $lim'=lim-a$，决策树也指最大深度为 $lim'$ 的决策树。

考虑到我们画出的决策树节点数量不少于令 $b:=a$ 时的节点数量。

而后者是一棵完全二叉树，则代表其节点数量是 $2^{dep}-1$，其中 $dep$ 是层数。

这意味着 $lim' \leq \lceil \log n \rceil \times a$，这也是二分上界。

同时，决策树上每一个节点都对应着一个由若干个 $+a,+b$ 构成的序列（就是走到这个节点的路径，其和应 $\leq lim'$）。由二分上界可知 $+a$ 的数量最多是 $\log_n$ 个。

考虑枚举 $+a$ 的数量（记 $a$ 有 $x$ 个），求含 $x$ 个 $+a$ 的路径数量。

这是一个网格路径计数问题，如下图所示（下图及下下图长宽应该是 $x+1$ 和 $y+1$，不想改图了qwq）：

![](https://cdn.luogu.com.cn/upload/image_hosting/78gb2l87.png)

每一条到右侧某个红点的路径对应一个节点。

而到所有红点的路径之和恰好就是下图中到叉叉的路径数量：

（你也可以用组合恒等式推，反正很简单）

![](https://cdn.luogu.com.cn/upload/image_hosting/fctyn666.png)

于是答案就是 $\binom{y+x+1}{x+1}$。这个组合数可以暴力 $\Theta(x)$ 求，因为大于 $n-1$ 的结果是无意义的，直接返回任意一个大于 $n$ 的数即可。

这样我们就能在 $\Theta(\log^2 n)$ 的复杂度内完成一次二分，总体复杂度是 $\Theta(t \times \log^2 n \log(a \log n))$，跑的飞快。

--------

**Code:**

```cpp
int n,a,b,L,R;
inline i128 C(int x,int y) {
    y=min(y,x-y);
    if(y==0) return 1;
    i128 tmp=1;
    for(int i=1; i<=y; ++i) {
        tmp=tmp*(x-i+1)/i;
        if(tmp>=n) return n;
    }
    return tmp;
}
inline bool check(int Lim) {
    int sum=0; Lim-=a;
    for(int i=0; i<=40; ++i) {
        if(i*a>Lim) break;
        int L=floor((Lim-i*a)/b);
        sum+=C(L+i+1,i+1);
    }
    return sum>=n-1;
}
signed main() {
    a=read(); b=read(); int T=read();
    while(T--) {
        n=read();
        if(n==1) { puts("0\n"); continue; }
        L=a; R=40*a;
        while(R>L) {
            int Mid=(L+R)>>1;
            if(check(Mid)) R=Mid;
            else L=Mid+1;
        }
        write(L); puts("");
    }
	return 0;
}
```


---

## 作者：irris (赞：1)

> 博弈论 / dp / 递推 / 二分答案 

$*1700$，$6.5$。

- $a \leq 10^5$，$n \leq 10^9$，$T \leq 10^5$：难度不变。
- $a \leq 3\times 10^{16}$，$n \leq 10^9$，$T \leq 10^5$：$*2300$。

## Solution

首先判定答案，问题转化为 **博弈树** 有多少个叶子。具体地来说，每个点的左儿子深度比自己大 $a$，右儿子深度比自己大 $b$，问深度 $\leq k$ 是不是有 $\geq n$ 个叶子节点。

因为答案显然不会超过 $a \cdot \lceil\log_2 n\rceil$，因此直接递推每一层的节点个数 $c_i$，然后深度 $\leq k$ 的叶子结点个数 $l_i$ 显然满足递推关系 $l_i = l_{i-1} + c_i - c_{i-b}$。时间复杂度 $\mathcal O(a\log n + T(\log a + \log\log n))$，狠狠爆标，拿到了现在的最优解。

## Code

```cpp
#include <bits/stdc++.h>

const int LG = 61;
const long long INF = 2000000000000000000ll;

#define MAXN 501
long long leaf[LG * MAXN], cnt[LG * MAXN];

int main() {
	int a, b, t; std::cin >> a >> b >> t;
	cnt[0] = 1;
	for (int i = 1; i <= LG * a; ++i) 
		cnt[i] = std::min((i >= b ? cnt[i - b] : 0ll) + (i >= a ? cnt[i - a] : 0ll), INF);
	for (long long n, p; t; --t) {
		std::cin >> n, p = 1;
		for (int k = 1; ; ++k) {
			p += cnt[k] - (k >= b ? cnt[k - b] : 0ll);
			if (p >= n) { std::cout << k << '\n'; break; }
		}
	}
	return 0;
}
```

## Ex

以下的部分参考自 @[unputdownable](https://www.luogu.com.cn/user/197493) 的题解。~~为什么我又不会经典计数问题~~。

我们能不能把 $a\log n$ 这么巨大的预处理去掉而改做对每次询问直接二分？答案是可以的。

我们需要判断 $l_k \geq n$ 是否成立。我们只需要求解深度 $\leq k - b$ 的节点个数和深度 $\leq k$ 的节点个数，减一下即可。

虽然 $n$ 可能很大，但是我们知道 **深度的上界是 $\bm{a \cdot \lceil\log_2 n\rceil}$**，因此，枚举走了 $p$ 个左儿子，那么可以计算出 $q$ 表示应走 $\leq q$ 个右儿子。于是对于每个 $p$，我们要求：

$$\sum_{r = 0}^q {p + r \choose p} = {p + q + 1 \choose p + 1}$$

这可以 $\mathcal O(p)$ 计算，记得开个 `__int128` 并且思考一下怎么和 $\text{inf} = 2\times 10^{18}$ 取 min。

因此单次二分的时间复杂度就成为了 $\mathcal O(\log^2 n)$，总时间复杂度 $\mathcal O(T\log^2 n(\log a + \log\log n))$。

我没实现这一部分，但是这个很对，以上，表达我对 unputdownable 大神的膜拜。

---


# 随机数生成器

## 题目描述

HKE最近编写了一个函数 $\text{rand}(l,r)$，其中 $l,r$ 为正整数且 $l \le r$。这个函数会等概率返回区间 $[l,r]$ 中任意一个正整数。然后，他又编写了一个函数：

```cpp
int work(int x){
    if(x==1) return 0;
    else return work(rand(1,x))+1;
}
```
这段代码用pascal写起来就是：
```pascal
function work(x:integer):integer;
begin
    if x=1 then exit(0);
    else exit(work(rand(1,x))+1);
end;
```
现在给定一个正整数 $n$，请问 $\text{work}(n)$ 的返回值的期望值是多少？

期望的定义：假设 $\text{work}(n)$ 返回的所有可能的值为 $x_1,x_2,\dots ,x_k$，它们出现的概率分别为 $p_1,p_2,\dots,p_k$，则期望为：

$$\mathbb{E}=\sum_{i=1}^{k}x_i p_i$$


## 说明/提示

【样例 $1$ 解释】  
$\text{work}(2)$ 有 $1/2$ 的概率返回 $1$，有 $1/4$ 的概率返回 $2$，有 $1/8$ 的概率返回 $3$ ……  
则期望为 $1/2+2/4+3/8+ \dots =2$

【数据范围】  
对于 $30\%$ 的数据，$n \le 9$；  
对于 $50\%$ 的数据，$n \le 1000$；  
对于 $70\%$ 的数据，$n \le 1000000$；  
对于 $100\%$ 的数据，$1\le n < 2^{31}$。


## 样例 #1

### 输入

```
2```

### 输出

```
2.00000```

## 样例 #2

### 输入

```
3```

### 输出

```
2.50000```

## 样例 #3

### 输入

```
100000```

### 输出

```
13.09014```

# 题解

## 作者：NaCly_Fish (赞：25)

这题感觉丢到高一数学作业里也没问题吧（

首先我们设那个函数的期望值为 $F(n)$，那么有：


$$F(n)=1+\frac1n\sum\limits_{i=1}^nF(i)$$  
移项一下，可以得到
$$\frac{n-1}{n}F(n)=1+\frac1n\sum\limits_{i=1}^{n-1}F(i)$$
$$F(n)=\frac{n}{n-1}+\frac{1}{n-1}\sum\limits_{i=1}^{n-1}F(i)$$  
然后这样就可以 $\Theta(n)$ 递推计算了。

有了上面的递推式，再搞一下得出通项  
( 这里可以先找规律猜结论，用数学归纳法很好证 )

$$F(n)=1+\sum\limits_{i=1}^{n-1}\frac1i$$
后面是调和级数的前 $n-1$ 项和 ( 记为 $h(n-1)$ )，直接算不太好搞，但是有

$$\frac{\text d\ln x}{\text d x}=\frac1x$$  
所以 $\ln n$ 和 $h(n)$ 同阶。  
进一步地，可以得到：  

$$\lim\limits_{n\rightarrow +\infty}h(n)-\ln n \approx 0.57721566490153286$$  
所以 $n$ 很小的时候直接暴力，否则直接用 $\ln (n)$ 来算。

时间复杂度 $\Theta(1)$ ?

代码很简单：  
```cpp
#include<cstdio>
#include<cmath>

int n;
double ans;

int main(){
	scanf("%d",&n);
    if(n<100000) for(int i=1;i<n;++i)  ans += 1.0/i;
    else ans = log(n)+0.577215664901532;
	printf("%.5lf",n==1?0:ans+1);
	return 0;
}
```

---

## 作者：star_city (赞：15)

把work当作数列，可以得到

$$a_n=\frac{S_n}n+1$$

这不就是必修五的数列嘛

简单推一下

$$a_{n-1}=\frac{S_{n-1}}{n-1}+1$$

$$na_n-(n-1)a_{n-1}=a_n+1$$

$$a_n=a_{n-1}+\frac1{n-1}$$

那就是调和级数啦，小范围暴力，大范围欧拉常数

注意一下比较诡异的边界$a_1=0,a_2=2$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

double ans, cnt;

int main(void)
{
    int n;
    cin >> n;
    n--;
    if (!n) {
        cout << "0.00000\n";
        return 0;
    }
    if (n <= 1000000) for (int i = 1; i <= n; i++) ans += 1.0 / i;
    else {
        for (int i = 1; i <= 10000000; i++) cnt += 1.0 / i;
        ans = log(n) + cnt - log(10000000);
    }
    printf("%.5lf\n", ans + 1);
    
    return 0;
}
```

如果你不知道欧拉常数的话，也是可以做的

有一种经典而暴力的方法：分块打表

因为调和级数每个数贡献相互独立，所以可以预先处理出一些整块的答案，然后再算剩余部分

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

double ans, cnt[233] = {0, 16.695311365857272, 17.388458521417103, 17.793923621189702, 18.081605689478064}; //表的部分，由于太长，这里给出前几个作为示范

int main(void)
{
    int n;
    cin >> n;
    n--;
    if (!n) {
        cout << "0.00000\n";
        return 0;
    }
    int p = n / 10000000;
    for (int i = p * 10000000 + 1; i <= n; i++) ans += 1.0 / i;
    printf("%.5lf\n", ans + cnt[p] + 1);
    
    return 0;
}
```
算是奇技淫巧之一吧，说道奇技淫巧，我就想到孙悟空钻进铁扇公主肚子里的故事，明年……文体两开花……

---

## 作者：Sooke (赞：6)

### 解题思路

这里设 $E_x$ 等于 $work(x)$ 的期望返回值，按照题面中的程序，我们可以直接列出其递推式：

$$E_x = \frac{\sum_{i=1}^{x}E_i}{x} + 1$$

特别地，$E_1 = 0$。

然而我们想知道的是 $E_x$ 的通项式子，想要得到它还需作稍微复杂的变幻。

设 $D_x = E_x - E_{x-1}$，即 $E_x$ 的差分。不妨先求出 $D_x$ 的通项式，累加一下就可得 $E_x$ 的通项式了。既然是差分，我们主要关注 $E_x$ 和 $E_{x-1}$ 有什么有趣的关系，下面的推算保证 $x \geqslant 3$。

$$E_x = \frac{\sum_{i=1}^{x}E_i}{x} + 1,\ \ \ E_{x-1} = \frac{\sum_{i=1}^{x-1}E_i}{x-1} + 1$$

这分母一看就很不爽，乘掉：

$$xE_x = (\sum_{i=1}^{x}E_i)+x,\ \ \ (x-1)E_{x-1} = (\sum_{i=1}^{x-1}E_i) + (x-1)$$

看两边还是挺像的，而且现在的目标是差分的通项式，考虑左边减右边：

$$xE_x - (x-1)E_{x-1} = (\sum_{i=1}^{x}E_i) + x - (\sum_{i=1}^{x-1}E_i) - (x-1)$$

简化一下上式：

$$xE_x - xE_{x-1}+E_{x-1}=E_x+1$$

移项：

$$xE_x - E_x - xE_{x-1}+E_{x-1} = 1$$

再合并回来：

$$(x-1)(E_x - E_{x-1}) = 1$$

诶，这 $E_x - E_{x-1}$ 不就是我们要的 $D_x$ 吗！而且根据上式我们发现 $D_x = \frac{1}{x-1}$！

注意上面的讨论都是基于 $x \geqslant 3$ 的，因为 $x = 2$ 时$E_{x-1}$ 是特殊值。所以 $E_1 = 0$ ，$E_2 = 2$ 的值我们单独考虑，其他的直接 $E_x = E_2 + \sum\limits_{i=3}^{x}D_i = 1 + \sum\limits_{i=1}^{x-1} \frac 1 i$。

推到这儿爽得一比对不对！但一看数据范围 $n < 2^{31}$，即使是 $O(n)$ 也注定挂……

但重新看看通项式，这和调和级数非常相像！怎么快速计算 $n$ 以内的调和级数呢？对于较大的 $n$，我们可以直接用 $1 + \gamma + ln(n)$ 得到精确的答案（这里 $\gamma = 0.577...$）。较小的 $n$，上面神奇的式子反而不精确，因此还是使用暴力计算。

这里推荐大家去看 https://www.bilibili.com/video/av12542782 了解更多有关“神奇的式子”的姿势。

---

### 代码实现

c++ 里面 $log$ 好像就是 $ln$。另外不要忘了特判 $n = 1$ 哦！

```cpp
#include <cmath>
#include <cstdio>

const int limit = 19260817;
const double _gamma = 0.5772156649015328;

int n;
double ans;

int main() {
    scanf("%d", &n);
    if (n == 1) { printf("%.5lf\n", 0.0); return 0; } // 特判 n = 1.
    if (n <= limit) {
        for (int i = 1; i < n; i++) { ans += 1.0 / i; } // 一定范围内直接计算.
    } else { ans = log(n) + _gamma; } // 否则套这个神奇的式子.
    printf("%.5lf\n", ans + 1);
    return 0;
}
```

---

## 作者：ricky0916 (赞：3)

首先我们先看看$ F(n) $怎么算($F(n)$表示$ work(n) $结果的期望)

~~显然~~$ F(1)=0 $，$ F(n)=\frac{1}{n}\sum_{i=1}^nF(i)+1 $

将$ \frac{1}{n}F(n) $移到左边，$\frac{n-1}{n}F(n)=\frac{1}{n}\sum_{i=1}^{n-1}F(i)+1$

两边同时除以$ \frac{n-1}n $,$ F(n)=\frac{1}{n-1}\sum_{i=1}^{n-1}F(i)+\frac{n}{n-1} $

好，现在我们已经可以$ O(n^2) $递推计算了，现在我们要尝试推出通项

先尝试一下

$ F(2)=2=1+\frac{1}{1}$

$F(3)=\frac{3}{2}+\frac{1}{2}(0+2)=1+\frac{1}{1}+\frac{1}{2} $

......

于是我们可以猜测：$ F(n)=1+\sum_{i=1}^{n-1}\frac{1}{i} $

猜出结论就很好证明了 ~~（数 学 归 纳 法）~~

证明($ n\geqslant2,F(n)=1+\sum_{i=1}^{n-1}\frac{1}{i} $)：

$ 1. $当$ n=2 $时$ F(n)=2=1+\frac{1}{1} $，成立

$ 2. $若$ 2\leqslant n\leqslant k $时此式均成立

则$ n=k+1 $时

$F(k+1)$

$=1+\frac{1}{k}+\frac{1}{k}\sum_{i=1}^k F(i)$

$ =1+1+\frac{1}{k}\sum_{i=2}^k\sum_{j=1}^{i-1} \frac{1}{j}$

$ =1+1+\sum_{i=1}^{k-1} \frac{k-i}{ik} $

$ =1+1+\sum_{i=1}^{k-1}\frac{1}{i}-\frac{1}{k} $

$ =1+1-\frac{k-1}{k}+\sum_{i=1}^{k-1}\frac{1}{i} $

$ =1+\sum_{i=1}^k\frac{1}{i} $

得证！

所以我们现在就可以$ O(n) $计算$ F(n) $了

但是一看数据范围：$ 1\leqslant n<2^{31} $，所以显然这还是不够

这时我们看精度，发现只要保留五位小数

这样我们就可以运用一个结论 ~~（会证明的大佬教教我吧）~~

$ \sum_{i=1}^n \frac{1}{i}-\ln(n+1) $单调有界

这样我们就可以分三类做

$ 1. n=1,$输出$ 0 $

$ 2.n>1 $且小于一个特定的数（建议取大一点，虽然$ 100000 $就行）

此时我们直接用$ F(n)=1+\sum_{i=1}^{n-1} $做，时间复杂度$ O(n) $

$ 3. $不是$ 1,2 $的情况，直接
$$
F(n)=1+\ln(n)+\lim_{n\to+\infty}\sum_{i=1}^{n-1}\frac{1}{i}-\ln(n)
$$

时间复杂度$ O(1) $（？）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const double s=0.577215664901;
int x;
double ans;
int main(){
    ans=1;
    scanf("%d",&x);
    if(x==1) ans=0;
    else if(x<=1000000) for(int i=1;i<x;i++) ans+=1.0/i;
    else ans+=log(x-1)+s;
    cout<<fixed<<setprecision(5)<<ans;
    return 0;
}
```


---

## 作者：_Imaginary_ (赞：1)

首先，假设所求的期望值为 $f(i)$，

$$
f(n)=1+\dfrac{1}{n}\sum\limits_{i=1}^nf(i)
$$

这个数列可以求通项公式。具体是：

$$
f(n)=1+\sum\limits_{i=1}^n\frac{1}{i}
$$

具体的证明方法可以参考[ricky0916的题解](https://www.luogu.com.cn/blog/liruikaijuruo/solution-p5147)，他给出了详细证明。（stO）


接着，我们就可以来Solve一下了。

首先，当 $n\le 10^6$ 时， $f(i)$ 可以算出来。

接着，当n过大时，考虑到$\lim\limits_{n\rightarrow +\inf}\sum\limits_{i=1}^n\frac{1}{i}=\ln(n)$并且题目只需要保留5位小数，我们可以直接用c++中的`log`函数。

Code：
```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    double rr=0.577215664901;
    double ans;
    int n;
    cin>>n;
    if(n==1) cout<<"0.00000";
    else 
    {
        if(n<=1000000)
        {
            ans=1.0;
            for(int i=1;i<n;i++)ans+=1.0/(double)(i);
        }
        else ans=1.0+log(n-1)+rr;
        printf("%.5f",ans);
    }
    return 0;
}
```

---

## 作者：_ztyqwq (赞：1)

orz 题解里都是 dalao

### 30pts

暴搜…… 期望得分：？？

### 50pts

考虑期望 dp，设 $ \rm{work(n)} $ 的期望值是 $ f_i $，容易得到：

$$ f_1 = 0 $$

$$ f_n = \frac{1}{n}\sum_{i=1}^nf_i + 1 $$

发现 $ f_n $ 的递推式里有 $ f_n $，移项：

$$ \frac{n - 1}{n} f_n = \frac{1}{n}\sum_{i=1}^{n - 1} f_i + 1 $$

$$ f_n = \frac{1}{n-1}\sum_{i=1}^{n - 1} f_i + \frac{n}{n - 1} $$

时间复杂度 $ O(n^2) $

### 70pts

考虑优化后面的 $ \sum $ ，记 $ S_n = \sum_{i=1}^n f_i $（前缀和）

则有

$$ f_n = \frac{1}{n-1} S_{n - 1} + \frac{n}{n - 1} $$

$$ S_n = S_{n - 1} + f_n $$

时间复杂度 $ O(n) $

事实上，这一步可以将空间复杂度优化为 $ O(1) $（滚动）

### 100pts

考虑进一步优化

首先，将 $ S_n $ 递推式中的 $ f_n $ 用 $ S_n $ 代

$$ S_n = S_{n - 1} + \frac{1}{n - 1}S_{n - 1} + \frac{n}{n - 1} $$

$$ S_n = \frac{n}{n - 1}S_{n - 1} + \frac{n}{n - 1} $$

考虑对 $ S_n $ 的递推式进行展开

$$ S_n = \frac{n}{n-1}(\frac{n-1}{n-2}S_{n-2} + \frac{n-1}{n-2}) + \frac{n}{n-1} $$

$$ = \frac{n}{n-2}S_{n-2} + \frac{n}{n-2} + \frac{n}{n-1} $$

$$ S_n = \frac{n}{n-2}(\frac{n-2}{n-3}S_{n-3} + \frac{n-2}{n-3})  + \frac{n}{n-2} + \frac{n}{n-1}$$

$$ = \frac{n}{n-3}S_{n-3} + \frac{n}{n-3} + \frac{n}{n-2} + \frac{n}{n-1} $$

惊(tao)奇(lu)地发现，所有的系数都能互相约分

$$ S_n = ... $$

$$ S_n = \frac{n}{1}S_1 + \frac{n}{1} + \frac{n}{2} + ... + \frac{n}{n - 1} $$

注意到 $ S_1 = f_1 = 0 $

$$ S_n = \sum_{i=1}^{n-1}\frac{n}{i} $$

$$ = n \sum_{i=1}^{n-1}\frac{1}{i} $$

注意这里推出的是 $ S_n $（前缀和），答案 $ f_n = \frac{1}{n-1}S_{n-1} + \frac{n}{n-1} $（上面 70pts 的柿子）

$$ f_n = \frac{1}{n-1} \cdot (n-1)\sum_{i=1}^{n - 2}\frac{1}{i} + \frac{n}{n-1} $$

$$ = \sum_{i=1}^{n-2}\frac{1}{i} + \frac{n}{n-1} $$

这似乎还是一个 $ O(n) $ 的做法

我们的问题就是快速求出前面的那个 $ \sum $…… 调和级数？！

$$ \lim_{n \rightarrow +\infty}(\sum_{i=1}^n \frac{1}{i} - \ln n) = \gamma \approx 0.577215664901532860606512090082402431042159335 $$

~~证明：不会，问欧拉~~

然而这是 $ n \rightarrow +\infty $ 的情况，当 $ n $ 比较小时精度不够

在 $ n \leqslant 10^7 $ 时，暴力算都是绰绰有余的；$ n > 10^7  $ 时就可以用这个公式啦

然后你发现 C++ 里没有 `ln` 函数

`[Error] 'ln' was not declared in this scope`

然后你发现 `log` 函数就是数学上的 `ln`

23333

记得特判 $ n = 1 $

代码里 `s` 代表的是调和级数的和

```cpp
#include <bits/stdc++.h>
using namespace std;
const double Gamma = 0.577215664901532860606512090082402431042159335;
int main()
{
	int n;
	scanf("%d", &n);
	if(n == 1)
	{
		printf("0.00000\n");
		return 0;
	}
	double s;
	if(n <= 10000000)
	{
		for(int i = 1; i <= n - 2; i++)
			s += 1.0 / i;
	}
	else
		s = log(n - 2) + Gamma;
	printf("%.5lf\n", s + n * 1.0 / (n - 1));
	return 0;
}
```

---

## 作者：koreyoshi_lemon (赞：0)

直接设 work 函数返回的期望值构成数列 $a$


$1$. $a_1=0$

$2$. $a_n=\sum\limits_{i=1}^n \frac{1}{n} (a_i+1)$

式  $2$  中等号两边都存在  $a_n$  项，不妨把右边的那一项拆出来放到左边，就会变成这个样子：

  $\frac{n-1}{n} a_n=\frac{1}{n}\sum\limits_{i=1}^{n-1}    a_i+1$
  
继续化简


$a_n=\frac{1}{n-1}\sum\limits_{i=1}^{n-1}a_i+\frac{n-1+1}{n-1}=\sum\limits_{i=1}^{n-1}a_i+1+\frac{1}{n-1}=a_{n-1}+\frac{1}{n-1}$

结合 $1$ 式，很容易得到数列  $a$   的通项公式：

$a_n=\sum\limits_{i=2}^{n}\frac{1}{i-1}=\sum\limits_{i=1}^{n-1}\frac{1}{i}$

这就是   $O(n)$   的递推式，但貌似仍然不足以通过此题。

于是涉及到另一个知识点，**调和级数求和**

由麦克劳林展开式可知：

$\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}.....$

于是：

$\ln(1+\frac{1}{x})=\ln(\frac{x+1}{x})=\frac{1}{x}-\frac{1}{2x^2}+\frac{1}{3x^3}-\frac{1}{4x^4}......$

两边同时从 $1$  到 $n$  求和：

$\ln(n+1)=\sum\limits_{i=1}^{n}\frac{1}{i}-\frac{1}{2}\sum\limits_{i=1}^{n}\frac{1}{i^2}+\frac{1}{3}\sum\limits_{i=1}^{n}\frac{1}{i^3}......$

$\sum\limits_{i=1}^{n}\frac{1}{i}=\ln(n+1)+\frac{1}{2}\sum\limits_{i=1}^{n}\frac{1}{i^2}-\frac{1}{3}\sum\limits_{i=1}^{n}\frac{1}{i^3}......$

感兴趣的可以尝试证明下，后面那一坨是收敛的。提示：

$
\lim\limits_{n\to+\infty}  \sum\limits_{i=1}^{n}{\frac{1}{i^2}}=\frac{\pi^2}{6} $

很容易验证后面一坨的单调性，结合上式进行放缩，就可以通过单调有界法则来证明极限存在。不妨设极限为 $C$，于是调和级数求和就出来了：

$\sum\limits_{i=1}^{n}\frac{1}{i}=\ln(n+1)+C$

我们可以先用前一百万个数据算出 $C$，然后就能直接加自然对数了。。

~~实在不行上网搜搜复制下来就行~~

附代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
double C,sum;
int n;
int main(void)
{
	scanf("%d",&n);
	--n;
	if(n<=1e6)	{
		if(n==0) {
			printf("%.5lf\n",0);
			return 0;
		}
		for(int i=1;i<=n;i++)
			sum+=1.0/i;
		printf("%.5lf\n",sum+1);
		return 0;
	}
	for(int i=1;i<=1e6;i++)
		sum+=1.0/i;
	C=sum-log(1e6);
	printf("%.5lf",log(n)+C+1);
	return 0;
}
```


---

## 作者：qwaszx (赞：0)

关于期望dp，题目中已经给了式子了:

$f[n]=\begin{cases}0&n=1\\1+\frac{1}{n}\sum\limits_{i=1}^nf[i]&n>1\end{cases}$

带着$\sum$的递归式通常可以用以下方法处理:

消去$\sum$前的系数得到$nf[n]=n+\sum\limits_{i=1}^nf[i]$

然后对$n-1$写下类似的式子$(n-1)f[n-1]=n-1+\sum\limits_{i=1}^{n-1}f[i]$

用上面的式子减去下面的式子，整理得$f[n]=f[n-1]+\frac{1}{n-1}(n>2)$

注意只有$n-1>1$的时候才可以这样做，当$n=2$时我们单独计算得到$f[2]=2$

容易看出$f[n]=\begin{cases}0&n=1\\H_n+1&n>1\end{cases}$

对于$H_n$的计算可以使用欧拉常数，但是我们毕竟是$OIer$，所以

# 分段打表! #
打表程序，每1e7个打一个表
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
//	freopen("tmp.cpp","w",stdout);
	double s=0;
	for(long long i=1;i<=2147483647;i++)
	{
		if(i%10000000==0)printf("%.8lf,",s);
		s+=1.0/i;
	}
}
```
最终代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const double H[100000]={0,16.69531127,17.38845847,17.79392359,18.08160566,18.30474922,18.48707078,18.64122146,18.77475285,18.89253589,18.99789640,19.09320658,19.18021796,19.26026067,19.33436864,19.40336151,19.46790003,19.52852466,19.58568307,19.63975029,19.69104359,19.73983375,19.78635377,19.83080553,19.87336514,19.91418714,19.95340785,19.99114818,20.02751582,20.06260714,20.09650870,20.12929852,20.16104722,20.19181888,20.22167184,20.25065938,20.27883025,20.30622923,20.33289747,20.35887296,20.38419077,20.40888338,20.43298093,20.45651143,20.47950095,20.50197380,20.52395271,20.54545892,20.56651233,20.58713161,20.60733432,20.62713695,20.64655503,20.66560323,20.68429536,20.70264450,20.72066301,20.73836258,20.75575433,20.77284876,20.78965588,20.80618518,20.82244570,20.83844604,20.85419440,20.86969859,20.88496606,20.90000393,20.91481902,20.92941782,20.94380656,20.95799119,20.97197743,20.98577076,20.99937641,21.01279943,21.02604466,21.03911674,21.05202014,21.06475917,21.07733795,21.08976047,21.10203056,21.11415192,21.12612811,21.13796257,21.14965861,21.16121943,21.17264813,21.18394769,21.19512099,21.20617082,21.21709989,21.22791081,21.23860610,21.24918821,21.25965951,21.27002229,21.28027879,21.29043117,21.30048150,21.31043183,21.32028413,21.33004030,21.33970221,21.34927167,21.35875041,21.36814015,21.37744254,21.38665920,21.39579168,21.40484152,21.41381019,21.42269913,21.43150976,21.44024344,21.44890151,21.45748525,21.46599594,21.47443481,21.48280306,21.49110186,21.49933236,21.50749567,21.51559288,21.52362505,21.53159322,21.53949840,21.54734158,21.55512372,21.56284577,21.57050864,21.57811324,21.58566044,21.59315112,21.60058609,21.60796620,21.61529224,21.62256500,21.62978525,21.63695374,21.64407121,21.65113837,21.65815595,21.66512462,21.67204506,21.67891794,21.68574390,21.69252359,21.69925762,21.70594661,21.71259115,21.71919184,21.72574924,21.73226392,21.73873643,21.74516732,21.75155712,21.75790635,21.76421552,21.77048513,21.77671568,21.78290765,21.78906152,21.79517774,21.80125679,21.80729910,21.81330513,21.81927530,21.82521003,21.83110975,21.83697487,21.84280579,21.84860291,21.85436662,21.86009729,21.86579531,21.87146105,21.87709487,21.88269712,21.88826817,21.89380835,21.89931800,21.90479747,21.91024707,21.91566714,21.92105799,21.92641993,21.93175328,21.93705833,21.94233539,21.94758474,21.95280669,21.95800150,21.96316947,21.96831087,21.97342598,21.97851504,21.98357835,21.98861614,21.99362868,21.99861622,22.00357901,22.00851729,22.01343131,22.01832130,22.02318748,22.02803011,22.03284940,22.03764557,22.04241885,22.04716945,22.05189759,22.05660348,22.06128733};
int main()
{
	int n;
	scanf("%d",&n);if(n==1){puts("0.00000");return 0;}//特判
	--n;int q=n/10000000,r=n%10000000;
	double s=H[q];q*=10000000;
	for(long long i=q?0:1;i<=r;i++)s+=1.0/(q+i);
	printf("%.5lf",1+s);
}
```
这种题考场上要是出出来了...那就制裁出题人好了...

---

## 作者：Memory_of_winter (赞：0)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10354885.html)

**题目大意：**
$$f_n=\begin{cases}\frac{\sum\limits_{i=1}^nf_i}n+1&(n>1)\\0&(n=1)\end{cases}$$
求$f_n(n<2^{31})$

**题解：**考虑$n>2$时的情况。
$$\begin{aligned}f_n&=\dfrac{\sum\limits_{i=1}^nf_i}n+1\\nf_n&=\sum\limits_{i=1}^{n-1}f_i+f_n+n\\(n-1)f_n&=\sum\limits_{i=1}^{n-1}f_i+n\\(n-2)f_{n-1}&=\sum\limits_{i=1}^{n-2}f_i+n-1\end{aligned}$$

上面两式相减，得：
$$\begin{aligned}(n-1)f_n-(n-2)f_{n-1}&=\sum\limits_{i=1}^{n-1}f_i+n-(\sum\limits_{i=1}^{n-2}f_i+n-1)\\(n-1)(f_n-f_{n-1})&=1\\f_n-f_{n-1}&=\dfrac1{n-1}\end{aligned}$$
特别的，当$n=2$时，$f_{n-1}$无法用原来的公式来计算，所以$f_n-f_{n-1}$要特别计算，为$2$

当$n>1$时

$$\begin{aligned}ans&=2+\sum\limits_{i=2}^{n-1}\dfrac1i\\&=1+\sum\limits_{i=1}^{n-1}\dfrac1i\end{aligned}$$

但是$n<2^{31}$，无法$O(n)$计算，但是右边的东西（调和级数$H(x)$）在$n$较大时有一个公式：$H_n=\ln(n)+\gamma$。（$\gamma$的定义就是$\gamma=\lim\limits_{n\to\infty}H_n-\ln(n)$，$\gamma=0.57721566490153286060651209008240243104215933593992\dots$）



**C++ Code：**

```cpp
#include <cstdio>
#include <cmath>
const int limit = 1000000;
const long double EulerGamma = 0.577215664901532860606512090082;

int n;
long double ans = 1;
int main() {
	scanf("%d", &n);
	if (n == 1) {
		puts("0.00000");
		return 0;
	}
	if (n <= limit) for (int i = 1; i < n; ++i) ans += 1 / static_cast<long double> (i);
	else ans += logl(n - 1) + EulerGamma;
	printf("%.5Lf\n", ans);
	return 0;
}

```



---


# 「EZEC-4.5」子序列

## 题目背景

作为唯一一道有背景的题，此题由出题人基于 @[Ecrade_](https://www.luogu.com.cn/user/322075) 的原创题“子集”拓展而来。

“子集”便是本题中 $k=n-1$ 的情况。

## 题目描述

给定一个有 $n$ 个元素的序列 $a$。

定义一个有 $x$ 个元素的序列 $s$ 的值为：
$$\sum \limits _{i=1} ^ x s_i \times \prod \limits _{i=1} ^ x s_i $$

将序列 $a$ 的一个有 $x$ 个元素的子序列表示为 $s = \{a_{p_1},a_{p_2},...,a_{p_x}\}$，其中 $p$ 为严格单调递增的序列，$1 \le p_1 \le p_x \le n$ 。

给定整数 $k$，定义序列 $a$ 的一个有 $x$ 个元素的合法的子序列 $s$ 需满足 $p_x - p_1 \le k$。

求序列 $a$ 的所有合法子序列的值之和对 $mod$ 取模的值。 

## 说明/提示

[大样例](https://www.luogu.com.cn/paste/5sg4ahwn)

### 【样例解释】：

样例1：

- 所有合法的子序列为 $\{1\}，\{2\}，\{3\}，\{4\}，\{1,2\}，\{2,3\}，\{3,4\}$ 

- 答案为 $1 \times 1 + 2 \times 2 + 3 \times 3 + 4 \times 4 + (1+2) \times 1 \times 2 + (2+3) \times 2 \times 3 + (3+4) \times 3 \times 4 = 150$


样例2：

- 所有合法的子序列为 $\{2\},\{3\},\{4\},\{2,3\},\{3,4\},\{2,4\},\{2,3,4\}$， 答案为 $ 407 \mod 114 = 65 $。  



### 【数据范围】：

| 数据点编号 | $ n\le$ | 特殊性质 |
| :----------: | :----------: | :----------: |
|$1\sim 4$ |$20$  |无 |
|$5\sim 11$ |$10^3$  |无|
|$12$ |$10^6$  |$k=0$  |
|$13\sim 14$ |$10^5$  |$a_i=1$|
|$15\sim 17$ |$10^5$  |$mod=10^9+7$|
|$18\sim 22$ |$10^5$  |无|
|$23\sim 25$ |$10^6$  |无 |

- 对于 $100\%$ 的数据，$0 \le k < n \le 10^6 , 1 \le a_i \le 10^9 , 1 \le mod \le 10^9+7$ 

## 样例 #1

### 输入

```
4 1 1000000007
1 2 3 4```

### 输出

```
150```

## 样例 #2

### 输入

```
3 2 114
2 3 4```

### 输出

```
65```

## 样例 #3

### 输入

```
12 8 10042020
1 1 4 5 1 4 1 9 1 9 8 10```

### 输出

```
2797740```

# 题解

## 作者：君のNOIP。 (赞：5)

$p_0:$ 讲个笑话，正解分块。

------------



### 数据点 $1\sim 4$： $O(2^nn)$ 暴力枚举子序列即可。


------------

### 数据点 $12$：$k=0$

合法的子序列均只有一个元素，答案显然为 $\sum \limits _{i=1} ^n a_i^2$。


------------

### 数据点 $5\sim 11$： $O(n^2)$ 暴力递推。


先不考虑不合法的子序列，即 $k=n-1$ 的情况，将 $\sum \limits _{i=1} ^ x s_i$ 和 $\prod \limits _{i=1} ^ x s_i$ 分开看。

设 $f_n$ 为考虑前 $n$ 个元素的答案。

显然 $f_n$ 表示的答案中由 $2^n -1$ 个非空子集组成，设第 $i$ 个子集的值为 $w_i \times b_i$

显然 $f_n$ 的形式为 $\sum \limits _{i=1} ^ {2^n-1} w_i \times b_i$ 。

再设 $g_n =\sum \limits _{i=1} ^ {2^n-1} b_i$ 。

那么 $f_{n+1}$ 表示的答案由 $3$ 个部分组成：

- $\{ a_{n+1} \} $ 的值。

- $f_n$ 表示的 $2^n - 1$ 个子集的值。

- $f_n$ 表示的 $2^n - 1$ 个子集分别加上元素 $a_{n+1}$ 的值。


那么我们分别考虑这 $3$ 个部分可以得到：

$\begin{aligned}f_{n+1} & = a_{n+1}^2 + f_n + \sum \limits _{i=1} ^ {2^n-1} (w_i+a_{n+1}) \times (b_i \times a_{n+1}) 
\\ & = a_{n+1}^2 + f_n + \sum \limits _{i=1} ^ {2^n-1} (w_i \times b_i \times a_{n+1} + b_i \times a_{n+1}^2 ) 
\\ & = a_{n+1}^2 + f_n + f_n \times a_{n+1} + g_n \times a_{n+1}^2
\\ & = a_{n+1}^2 \times (g_n + 1)  + f_n \times ( a_{n+1} + 1 )
\end{aligned}$ 

关于 $g_n$，根据乘法结合律，同理考虑 $3$ 个部分易得：

$\begin{aligned}g_{n+1} &= a_{n+1} + g_n + g_n \times a_{n+1}
\\ & = a_{n+1} \times (g_n+1) + g_n
\end{aligned}$ 

$f_{n+1} = a_{n+1}^2 \times ( g_n + 1)  + f_n \times ( 1 + a_{n+1} )$

于是我们就可以 $O(n)$ 同时递推两个式子，答案即为 $f_n$。

而现在我们需要考虑去掉不合法的序列。

改设 $f_{i,j}$ 为 $i \le p_1 \le p_x \le j$ 的所有子序列的值之和， $g_{i,j}$ 同理。

发现由上式的原理可以由 $f_{i,j}$ 推至 $f_{i-1,j}$ 和 $f_{i,j+1}$， $g_{i,j}$ 同理。

**根据基本容斥原理，答案为** $\sum \limits _{i=1} ^{n-k} f_{i,i+k} - \sum \limits _{i=2} ^{n-k} f_{i,i+k-1}$。


------------

### 数据点 $15\sim 17$： $O(nlogn)$ 逆元。

根据前文中推出的式子，同理：

$f_{i,j} = f_{i+1,j} \times (a_i + 1 ) + a_i ^ 2 \times g_{i+1,j} $

移项得：

$f_{i+1,j} = ( f_{i,j} - a_i ^ 2 \times g_{i+1,j} ) / ( a_i + 1 )$

同理 $g_{i,j}$ 可推得 $g_{i+1,j}$。

由于 $mod = 10^9+7$， 是质数，我们只需用逆元即可运用类似双指针的方法推得答案。



------------

### 数据点 $18\sim 22$： $O(nlogn)$ 合并区间 $\&$倍增。

我们是否能由 $f_{i,l}$ 和 $f_{l+1,j}$ 合并得 $f_{i,j}$ 呢？

方法与由 $f_{i,j}$ 推至 $f_{i,j+1}$ 是一样的，同理可推得： 


$f_{i,j} = f_{i,l} \times (g_{l+1,j} + 1 ) + f_{l+1,j} \times (g_{i,l} + 1 ) $

$g_{i,j} = g_{i,l} + g_{l+1,j} + g_{i,l} \times g_{l+1,j}  $

接下来只要利用倍增的思想，预处理出 $f_{i,i+2^j-1},g_{i,i+2^j-1}$ ,再倍增求出 $f_{i,i+k}$ 和 $f_{i+1,i+k}$ 即可。

时空复杂度都是 $O(nlogn)$。

------------


### 数据点 $23\sim 25$：

正解 $O(n)$，但由于这是乐多赛制缺少试错的机会，且作为信心赛题目，良心出题人放了很多略加优化的 $O(nlogn)$ 乱搞做法通过。

- 乱搞一：

仍然倍增，但空间会炸，于是我们类似分块，以 $10$ 为块大小，再倍增记录每块的信息即可。空间上足够了，但是由于常数巨大，经测试，#23 很难卡过去。

- 乱搞二：

据说有方法可以实现膜数非质数逆元，不太了解这里就不讲了，但时间复杂度仍然要 $O(nlogn)$。

- 乱搞三：

区间合并，区间查询，显然可以线段树，时间复杂度 $O(logn)$，空间复杂度 $O(n)$。

注意由于要同时合并 $f_{i,j},g_{i,j}$，求和的时候要是分两个函数求解，则会产生重复递归（和 T1 不加 map 记忆化搜索是一个道理 ），时间复杂度会退化成 $O(n^2)$。

我的方法是直接用 pair<> 作函数类型，如果有其它方法欢迎评论提出。

但由于线段树巨大的常数还是有一定风险的，事实上出题人写的线段树这 $3$ 个点一个都过不去。

- 正解：分块。

大家都知道分块一般是 $n^{1.5}$ 的，但这里不太一样。

因为我们要求的区间长度只有 $k$ 和 $k+1$。

所以我们可以以 $k$ 为块的大小，设 $i$ 所在块左边界为 $l_i$，右边界为 $r_i$。

则我们只需预处理出 $f_{l_i,i},f_{i,r_i}$，则计算答案的时候每次也只要合并两个区间 $f_{i,r_i},f_{l_j,j}$ 即可。

#### Code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<map>
using namespace std;
#define G() Cr = getchar()
#define LL long long
LL Xr, Fr; char Cr;
inline LL rd() {
	Xr = 0, Fr = 1, G();
	while(Cr < '0' || Cr > '9') {if(Cr == '-') Fr = -1; G();}
	while(Cr >= '0' && Cr <= '9') Xr = (Xr<<1) + (Xr<<3) + (Cr&15), G();
	return Xr * Fr;
}
#define MAX_N 1000005
LL n, k, mod;
LL va[MAX_N], f[MAX_N][3], b[MAX_N][3], l[MAX_N], r[MAX_N], ans, s; // 0 -> from left ; 1 -> from right

LL work( LL L, LL R ) {
	if( L == R ) return va[L] * va[L] % mod;
	if( l[L] == l[R] ) return f[R][0];
	LL x, y, A, B;
	x = f[L][1], y = f[R][0];
	A = b[L][1], B = b[R][0];
	return ( x + y + A * y % mod + B * x % mod ) % mod;
}

int main() {
	n = rd(), k = rd(), mod = rd();
	for( int i = 1; i <= n; i++ ) va[i] = rd();
	if(!k) {
		for( int i = 1; i <= n; i++ ) ans = ( ans + va[i] * va[i] ) % mod;
		cout << ans;
		return 0;
	}
	for( int i = 1; i <= n; i++ ) l[i] = ( i - 1 ) / k * k + 1, r[i] = ( ( i - 1 ) / k + 1 ) * k;
	for( int i = 1; i <= n; i++ ) {
		if( i == l[i] ) b[i][0] = va[i], f[i][0] = va[i] * va[i] % mod;
		else {
			f[i][0] = (va[i] * va[i] % mod * ( 1 + b[i-1][0] ) % mod + f[i-1][0] * ( 1 + va[i] ) % mod ) % mod;
			b[i][0] = ( b[i-1][0] * ( 1 + va[i] ) + va[i] ) % mod;
		}
	}
	for( int i = n; i >= 1; i-- ) {
		if( i == r[i] ) b[i][1] = va[i], f[i][1] = va[i] * va[i] % mod;
		else {
			f[i][1] = (va[i] * va[i] % mod * ( 1 + b[i+1][1] ) % mod + f[i+1][1] * ( 1 + va[i] ) % mod ) % mod;
			b[i][1] = ( b[i+1][1] * ( 1 + va[i] ) + va[i] ) % mod;
		}
	}
	for( int i = k + 1; i < n; i++ )
		ans = ( ans + work(i-k,i) - work(i-k+1,i) + mod ) % mod;
	ans = ( ans + work(n-k,n) ) % mod;
	cout << ans;
}
```


---

## 作者：0xyz (赞：2)

来一篇在正解上更详细的题解。做法来自出题人题解。

首先，我们要规定 $p_x-p_1\le k$，那么就来一个规范长度的递推。

假设 $f_{i,j}$ 代表满足 $i\le p_1\le p_x\le j$ 的子序列的**价值**之和。同时假设 $g_{i,j}$ 表示所有满足 $i\le p_1\le p_x\le j$ 的子序列的**元素之积**之和。容易知道 $f_{i,i}=a_i^2,g_{i,j}=a_i$。

由容斥原理，我们就是要求所有长为 $k+1$ 的区间，但是它们相邻两个区间里，会有重复的，长度为 $k$ 的区间。所以答案就是 $\sum\limits_{i=1}\limits^{n-k}f_{i,i+k}-\sum\limits_{i=2}\limits^{n-k}f_{i,i+k-1}$。

于是我们可以针对 $f_{i,j}$ 进行递推。但是发现如果全部推完，时间复杂度至少是 $O(n^2)$，会超时。所以我们考虑只求出所有的 $f_{i,i+k}$ 和 $f_{i,i+k-1}$，这些数只有 $O(n)$ 个。

由于我们只要计算 $j-i\le k$ 的区间，所以其实所有满足 $i\le p_1\le p_x\le j$ 的子序列都是合法的。

我们研究 $f_{i,j}$ 和 $f_{j+1,l}$ 如何推出 $f_{i,l}$，其中 $i\le j<l$。

我们将一个子序列 $a_{p_1},a_{p_2},…,a_{p_x}$ 以集合 $\{p_1,p_2,…,p_x\}$ 的形式表示，并且令 $s_i,t_i$ 分别表示集合 $S,T$ 中 $i$ 号序列元素之和，$w_i,v_i$ 分别表示集合 $S,T$ 中 $i$ 号序列元素之积。对于 $f_{i,j}$ 对应的所有子序列集合 $S(|S|=2^{j-i+1}-1)$，$f_{j+1,l}$ 的所有子序列集合 $T(|T|=2^{l-j}-1)$，$f_{i,l}$ 的所有子序列集合 $U$ 里的元素一定是下列情况之一：

- $x(x\in S)$
- $y(y\in T)$
- $x\cup y(x\in S,y\in T)$

那么我们就知道，
$$\begin{aligned}f_{i,l}&=f_{i,j}+f_{j+1,l}+\sum\limits_{p=1}\limits^{|S|}\sum\limits_{q=1}\limits^{|T|}(s_p+t_q)(w_p\cdot v_q)\\&=f_{i,j}+f_{j+1,l}+\sum\limits_{p=1}\limits^{|S|}w_p\Big(s_p\sum\limits_{q=1}\limits^{|T|}v_q+\sum\limits_{q=1}\limits^{|T|}t_q\cdot v_q\Big)\\&=f_{i,j}+f_{j+1,l}+\sum\limits_{p=1}\limits^{|S|}w_p\Big(s_p\cdot g_{j+1,l}+f_{j+1,l}\Big)\\&=f_{i,j}+f_{j+1,l}+g_{j+1,l}\sum\limits_{p=1}\limits^{|S|}w_p\cdot s_p+f_{j+1,l}\sum\limits_{p=1}\limits^{|S|}w_p\\&=f_{i,j}+f_{j+1,l}+g_{j+1,l}\cdot f_{i,j}+f_{j+1,l}\cdot g_{i,j}\\&=(g_{j+1,l}+1)f_{i,j}+(g_{i,j}+1)f_{j+1,l}\end{aligned}(1.1)$$

然后 $g_{i,l}$ 的计算还是依据以上三类讨论：

$$\begin{aligned}g_{i,l}&=g_{i,j}+g_{j+1,l}+\sum\limits_{p=1}\limits^{|S|}\sum\limits_{q=1}\limits^{|T|}w_p\cdot v_q\\&=g_{i,j}+g_{j+1,l}+\sum\limits_{p=1}\limits^{|S|}w_p\sum\limits_{q=1}\limits^{|T|}v_q\\&=g_{i,j}+g_{j+1,l}+g_{i,j}\cdot g_{j+1,l}\end{aligned}(1.2)$$

然后我们可以知道以上两个式子的特殊情况，令 $l=j+1$，则

$$\begin{aligned}f_{i,j+1}&=(g_{j+1,j+1}+1)f_{i,j}+(g_{i,j}+1)f_{j+1,j+1}\\&=(a_{j+1}+1)f_{i,j}+(g_{i,j}+1)a_{j+1}^2\\g_{i,j+1}&=g_{i,j}+g_{j+1,j+1}+g_{i,j}\cdot g_{j+1,j+1}\\&=g_{i,j}+a_{j+1}+g_{i,j}\cdot a_{j+1}\end{aligned}(2)$$

令 $i=j$，则

$$\begin{aligned}f_{j,l}&=(g_{j+1,l}+1)f_{j,j}+(g_{j,j}+1)f_{j+1,l}\\&=(g_{j+1,l}+1)a_j^2+(a_j+1)f_{j+1,l}\\g_{j,l}&=g_{j,j}+g_{j+1,l}+g_{j,j}\cdot g_{j+1,l}\\&=a_{j}+g_{j+1,l}+a_j\cdot g_{j+1,l}\end{aligned}(3)$$

然后这题由于只需要求所有长为 $k$ 和 $k+1$ 的区间的值。所以我们可以对于 $k$ 和 $k+1$ 分别处理。
假设我们要求所有长为 $k$ 的值，那么可以将原序列以 $k$ 为一块，然后预处理出每一个位置 $i$ 所在的块的左端点 $l_i$ 和右端点 $r_i$，然后利用 $(2)$ 从左到右计算出 $f_{l_i,i}$，利用 $(3)$ 从右到左计算出 $f_{i,r_i}$，最后使用 $(1)$ 合并。对于一个长为 $k$ 的区间 $[x,y]$，一定有 $l_x=l_y=x,r_x=r_y=y$，那么我们直接返回 $f_{l_y,y}$；或者 $x\le r_x,l_y\le y,l_y=r_x+1$，那么我们就用 $f_{x,r_x}$ 与 $f_{l_y,y}$ 合并，得到 $f_{x,y}$ 就行了。

对于长为 $k+1$ 的区间，也是这么做一次。

总时间复杂度是 $O(n)$。

**注意特判 $k=0$ 的情况。**

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=1000010;
ll ans,n,k,p,a[_],l[_],r[_],f[2][_],g[2][_];
inline ll cal(ll x,ll y){
	return x==l[x]?f[0][y]:((g[0][y]+1)*f[1][x]+(g[1][x]+1)*f[0][y])%p;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k>>p;
	for(ll i=1;i<=n;i++)cin>>a[i];
	if(!k){for(ll i=1;i<=n;i++)ans=(ans+a[i]*a[i])%p;cout<<ans;return 0;}
	for(ll x=1;~x;x--){
		ll s=k+x;
		for(ll i=1;i<=n;i++)l[i]=(i-1)/s*s+1,r[i]=min(n,l[i]+s-1);
		for(ll i=1;i<=n;i++)
			if(l[i]==i)f[0][i]=a[i]*a[i]%p,g[0][i]=a[i]%p;
			else{
				f[0][i]=((a[i]+1)*f[0][i-1]+a[i]*a[i]%p*(g[0][i-1]+1))%p;
				g[0][i]=(g[0][i-1]+a[i]+g[0][i-1]*a[i])%p;
			}
		for(ll i=n;i>=1;i--)
			if(r[i]==i)f[1][i]=a[i]*a[i]%p,g[1][i]=a[i]%p;
			else{
				f[1][i]=(a[i]*a[i]%p*(g[1][i+1]+1)+(a[i]+1)*f[1][i+1])%p;
				g[1][i]=(a[i]+g[1][i+1]+a[i]*g[1][i+1])%p;
			}
		for(ll i=2-x;i<=n-k;i++)ans=(ans+(x?1:-1)*cal(i,i+s-1)+p)%p;
	}
	cout<<ans;
	return 0;
}
```

有什么疑问或者建议欢迎提出。

---


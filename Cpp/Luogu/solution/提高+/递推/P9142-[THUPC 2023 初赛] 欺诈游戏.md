# [THUPC 2023 初赛] 欺诈游戏

## 题目背景

在《LIAR GAME》中，小 E 看到了一个有趣的游戏。

## 题目描述

这个游戏名叫《走私游戏》。游戏规则大概是这样的：一名玩家扮演走私者，一名玩家扮演检察官。走私者可以将 $x$ 日元（$x$ 为 $[0,n]$ 内的整数，由走私者决定）秘密放入箱子中，而检查官需要猜测箱子中的金额。假设检察官猜了 $y$（$y$ 也必须是整数）。如果 $x=y$，则走私失败，走私者一分钱也拿不到。如果 $x>y$，则走私成功，走私者可以从检查官那里拿走 $x$ 日元。如果 $x<y$，则走私失败，但是由于冤枉检察官需要赔付给走私者 $y/2$ 日元。游戏分有限回合进行。双方轮流做走私者和检察官。

可以证明，最优情况下每个回合走私者会采用同一种策略，检察官也会采用同一种策略。小 E 想知道在一个回合中，双方的最优策略分别是什么。

## 说明/提示

#### 样例解释 1

这 $4$ 个数分别为 $2/3,1/3,1/3,2/3$。

#### 子任务

保证 $1\le n \le 400000$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
1
```

### 输出

```
665496236 332748118
332748118 665496236
```

# 题解

## 作者：Leasier (赞：5)

设走私者放 $i$ 元的概率为 $f(i)$，检察官猜 $i$ 元的概率为 $g(i)$，则：

- 走私者放 $i$ 元时，走私者的期望收益为 $E_1(i) = i \displaystyle\sum_{j = 0}^{i - 1} g(j) + \frac{1}{2} \sum_{j = i + 1}^n j g(j)$。
- 检察官猜 $i$ 元时，走私者的期望收益为 $E_2(i) = \frac{i}{2} \displaystyle\sum_{j = 0}^{i - 1} f(j) + \sum_{j = i + 1}^n j f(j)$。

这里我们以第一个式子为例（第二个式子的后续推导与之相似）。

下面是一个小~~但我之前不会的~~套路。

注意到“**你需要保证，在一方的策略不变的情况下，另一方无论如何改变自己的策略，都不能使自己的期望收益比原来多。**”，考虑调整法，设 $\Delta g(i) = g'(i) - g(i)$ 表示对走私者策略进行调整的幅度——显然有 $\displaystyle\sum_{i = 0}^n \Delta g(i) = 0$。

然后有 $\displaystyle\sum_{i = 0}^n \Delta g(i) E_1(i) \leq 0$ 恒成立。假如我们抓出 $E_1(i)$ 中最大者并给它整一个很大的 $\Delta g(i)$，若此时 $E_1(i)$ 不两两相等，则一定存在一种 $\Delta g(i)$ 使之不合法，于是我们得出了本题最关键的结论：

- $E_1(i)$ 两两相等。

考虑抓出比较像的相邻两项来讨论，下面假定我们讨论 $E_1(i) = E_1(i + 1)$：

- $i \displaystyle\sum_{j = 0}^{i - 1} g(j) + \frac{1}{2} \sum_{j = i + 1}^n j g(j) = (i + 1) \sum_{j = 0}^i g(j) + \frac{1}{2} \sum_{j = i + 2}^n j g(j)$。

进行化简后可得：

- $g(i) = \dfrac{2((i - 1) g(i - 1) + \displaystyle\sum_{j = 0}^{i - 1} g(j))}{i}$。

于是我们可以将所有 $g(i)$ 表示为 $g(0)$ 的倍数，又因为 $\displaystyle\sum_{i = 0}^n g(i) = 1$，我们将系数代入求出 $g(0)$ 即可得出所有 $g(i)$。

同理可得：$f(i) = \dfrac{(i - 1) f(i - 1) + \displaystyle\sum_{j = 0}^{i - 1} f(j)}{2i}$。

线性求逆即可。时间复杂度为 $O(n)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 998244353;
ll inv[800007], f[400007], g[400007];

inline void init(int n){
	inv[0] = inv[1] = 1;
	for (register int i = 2; i <= n; i++){
		inv[i] = mod - (mod / i) * inv[mod % i] % mod;
	}
}

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

int main(){
	int n;
	ll pre = 0, sumf = 0, sumg = 0;
	scanf("%d", &n);
	init(n * 2);
	f[0] = 1;
	for (register int i = 1; i <= n; i++){
		pre = (pre + f[i - 1]) % mod;
		f[i] = (f[i - 1] * (i - 1) % mod + pre) % mod * inv[i * 2] % mod;
	}
	for (register int i = 0; i <= n; i++){
		sumf = (sumf + f[i]) % mod;
	}
	sumf = quick_pow(sumf, mod - 2, mod);
	for (register int i = 0; i <= n; i++){
		printf("%lld ", f[i] * sumf % mod); 
	}
	printf("\n");
	pre = 0;
	g[0] = 1;
	for (register int i = 1; i <= n; i++){
		pre = (pre + g[i - 1]) % mod;
		g[i] = (g[i - 1] * (i - 1) % mod + pre) % mod * 2 % mod * inv[i] % mod;
	}
	for (register int i = 0; i <= n; i++){
		sumg = (sumg + g[i]) % mod;
	}
	sumg = quick_pow(sumg, mod - 2, mod);
	for (register int i = 0; i <= n; i++){
		printf("%lld ", g[i] * sumg % mod); 
	}
	return 0;
}
```

---

## 作者：WYXkk (赞：5)

做出本题不需要额外的博弈论知识，所有需要用到的已经写在题面里了。

根据输出格式，两人的策略都形如以概率 $p_i$ 或 $q_i$ 选取 $i$。

另外，输出格式中还提到：

> 在一方的策略不变的情况下，另一方无论如何改变自己的策略，都不能使自己的期望收益比原来多。

这样相当于是在提示，两人的策略都需要满足，无论对方选取哪个数，在自己的策略下期望收益都一致。（无法直接推出的原因，及如何正确推出见文末）

既然所有选择的期望收益一致，那么就可以根据每种情况的期望收益列方程。

对于走私者，枚举检察官的每个策略可得：

$$\begin{aligned}&p_1+2p_2+3p_3+4p_4+\cdots\\=&\dfrac12p_0+2p_2+3p_3+4p_4+\cdots\\=&\dfrac22p_0+\dfrac22p_1+3p_3+4p_4+\cdots\\=&\dfrac32p_0+\dfrac32p_1+\dfrac32p_2+4p_4+\cdots\\=&\cdots\end{aligned}$$

相邻相减，可以得到 $p_1=\dfrac12p_0$，$2p_2=\dfrac12p_0+p_1$，$3p_3=\dfrac12p_0+\dfrac12p_1+\dfrac32p_2$，等等。用 $p_0$ 表示其它项，容易算出 $p_k=\dfrac12p_0(k\ge 1)$。

对于检察官，枚举走私者的每个策略可得：

$$\begin{aligned}&\dfrac12q_1+\dfrac22q_2+\dfrac32q_3+\dfrac42q_4+\cdots\\=&q_0+\dfrac22q_2+\dfrac32q_3+\dfrac42q_4+\cdots\\=&2q_0+2q_1+\dfrac32q_3+\dfrac42q_4+\cdots\\=&3q_0+3q_1+3q_2+\dfrac42q_4+\cdots\end{aligned}$$

相邻相减，可以得到 $\dfrac12q_1=q_0$，$\dfrac22q_2=q_0+2q_1$，$\dfrac32q_3=q_0+q_1+3q_2$，等等。用 $q_0$ 表示其它项，用以上式子的规律，记录一个前缀和即容易进行递推。

最后，各个 $p_i,q_i$ 是概率，因此要满足 $\sum p_i=\sum q_i=1$。结合前面算出的比例信息，即可回带算出各个 $p_i,q_i$。

核心部分的代码，仅供参考：

```cpp
//F(i,a,b) = for(int i=a;i<=b;i++)
//ni(i) 表示求 i 在模意义下的乘法逆
p[0]=2;F(i,1,n) p[i]=1;
q[0]=1;q[1]=2;ll sum=0;
F(i,2,n)
{
	sum=(sum+q[i-2])%mod;
	q[i]=(q[i-1]*2+sum*2*ni(i))%mod;
}
sum=0;F(i,0,n) sum+=p[i];sum%=mod;sum=ni(sum);F(i,0,n) p[i]=p[i]*sum%mod;
sum=0;F(i,0,n) sum+=q[i];sum%=mod;sum=ni(sum);F(i,0,n) q[i]=q[i]*sum%mod;
```

----

题面给出的最重要的信息是，两人的最优策略都是纯概率策略。

这个条件貌似牵扯到一些类似于纳什均衡的东西，但是我又不学概率论我怎么知道.jpg

----

为什么引用的条件无法直接推出每种策略的期望全部相等？

因为双方有可能“放弃”对手的一部分选项，只保证对手选剩余的选项时期望全部相等（且低于对手选其它选项的期望）。

为了排除这种情况，只需要证明，这种情况下最终会得到一个比上面的策略低的期望即可。

一个简单的想法是，将对手每种选项的期望的式子进行加权平均，并让得到的结果各项系数相等，就可以利用各情况概率和为 $1$，得到最大值不小于/最小值不超过此平均，且当且仅当各个期望全部相等时取到等号。

为了保证上述论断成立，各个式子的权必须都是正数。

实际上，求解这个系数的方程组，与求解对手的各操作概率的方程组，是完全一样的；而后者有一个全正数解，因此前者也有。

读者可以尝试自行带入后者求出的解计算前者。

---

## 作者：SmallBlack (赞：2)

## 前言

啊对对对只有我们队在推式子别人全在打表我们还是一遍过但是晚开，就离谱。

## 题目简述

有两个数组 $P_1[n+1]$ 和 $P_2[n+1]$，我们要对这两个数组进行调整，要求满足：

1. $\sum\limits_{i=0}^nP_1[i]=\sum\limits_{i=0}^nP_2[i]=1$
2. 设有事件 $A$：有两个数 $a,b$，每次以 $P_1[i]$ 为随机出 $a=i$ 的概率，以 $P_2[i]$ 为随机出 $b=i$ 的概率，如果 $a>b$，那么 $A$ 事件贡献为 $a$；若 $b>a$，那么 $A$ 事件的贡献为 $\dfrac b2$。

	调整 $P_1[n+1]$ 使得A事件贡献的期望值尽量大，调整 $P_2[n+1]$ 使得A事件贡献的期望值尽量小。
    
## 解题思路

看到这题目我们会发现这玩意在百度百科上双方执行的都是[混合战略](https://baike.baidu.com/item/%E6%B7%B7%E5%90%88%E6%88%98%E7%95%A5/6748998?fr=aladdin)。

然后我们搜索[混合战略博弈论](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E6%B7%B7%E5%90%88%E6%88%98%E7%95%A5%E5%8D%9A%E5%BC%88%E8%AE%BA&fenlei=256&oq=%25E5%258D%259A%25E5%25BC%2588%25E8%25AE%25BA%25E6%25B7%25B7%25E5%2590%2588%25E6%2588%2598%25E7%2595%25A5&rsv_pq=ff4f20f500060398&rsv_t=d7bbEKNOYNnDLcfltK4Y1EiyG2%2F3zecM3SMabyORJAdn5nfyC%2B7IDlaTBoc&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_btype=t&rsv_sug3=19&rsv_sug1=11&rsv_sug7=100&bs=%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%B7%B7%E5%90%88%E6%88%98%E7%95%A5)就会发现有一个东西叫做[纳什平衡](https://zhuanlan.zhihu.com/p/148772400?ivk_sa=1024320u)。

然后你可以再去百度百科上搜索[纳什平衡](https://baike.baidu.com/item/%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1/534868?fromtitle=%E7%BA%B3%E4%BB%80%E5%B9%B3%E8%A1%A1&fromid=1325910&fr=aladdin)

对我可以告诉你赛时**不使用oeis**做这道题的前提条件是会这个东西。~~（自然排除了你是找规律做和打表做的情况）~~。

其他东西咱可以不看懂，我们只需注意一个要点，就是：

**任何一位玩家在此策略组合下单方面改变自己的策略（其他玩家策略不变）都不会提高自身的收益。**

在这题里，就相当于一方不变时另一方怎么变期望都不会变，都说到好像这里了不把期望的式子写出来都不好意思。

按照直观理解列出题目的期望：

$$\sum_{i=0}^n\sum_{j=0}^{i-1}P_1[i]P_2[j]i+\sum_{i=0}^n\sum_{j=i+1}^{n}P_1[i]P_2[j]\frac j2$$

我们先假设数组 $P_2$ 不变，那就自然提出一个 $\sum_{i=0}^nP_1[i]$。

$$\sum_{i=0}^nP_1[i]\left(\sum_{j=0}^{i-1}P_2[j]i+\sum_{j=i+1}^{n}P_2[j]\frac j2\right)$$

好的，我们发现不论 $P_1$ 怎么变对此式无影响。因为 $\sum P_1[]=1$ 是常数，除了后面这个式子为 $0$ 的情况外还有一个情况，就是**此式不随** $i$ **的变化而变化**。

那么为了方便表示，我设 $f(i)=\sum\limits_{j=0}^{i-1}P_2[j]i+\sum\limits_{j=i+1}^{n}P_2[j]\frac j2$

$\begin{aligned}
\because &\forall i,j\in [0,n], &f(i)&=f(j)\\
\therefore &\forall i\in [0,n+1],&f(i)&=f(i+1)\iff f(i+1)-f(i)=0\\
\end{aligned}$

所以有:

$\sum\limits_{j=0}^{i}P_2[j](i+1)+\sum\limits_{j=i+2}^{n}P_2[j]\frac j2-\sum\limits_{j=0}^{i-1}P_2[j]i-\sum\limits_{j=i+1}^{n}P_2[j]\frac j2=0$

我们开始自信推式子：

$\begin{aligned}
&\text{原式}\\
\iff&\sum\limits_{j=0}^{i}P_2[j]i+\sum\limits_{j=0}^{i}P_2[j]+\sum\limits_{j=i+2}^{n}P_2[j]\frac j2-\sum\limits_{j=0}^{i-1}P_2[j]i-\sum\limits_{j=i+1}^{n}P_2[j]\frac j2=0\\
\iff&P_2[i]i+\sum\limits_{j=0}^{i}P_2[j]-P_2[i+1]\frac {i+1}2=0\\
\iff&P_2[i+1]\frac {i+1}2=P_2[i]i+\sum\limits_{j=0}^{i}P_2[j]\\
\iff&P_2[i+1]=\dfrac2{i+1}\left(P_2[i]i+\sum\limits_{j=0}^{i}P_2[j]\right)
\end{aligned}$

非常好我们得到了一个递推式，$\forall i\in[0,n-1]$，此式都成立。

对啊有了 $n$ 个 $n+1$ 元一次方程。

哦我们还有一个 $\sum\limits_{i=0}^n P_2[i]=1$

那这不就是 $n+1$ 个 $n+1$ 元一次方程构成的方程组吗。

同样的，设 $P_1$ 不变可以得到 $P_1$ 的递推式：

$P_1[i+1]=\dfrac1{2(i+1)}\left(P_1[i]i+\sum\limits_{j=0}^{i}P_1[j]\right)$

哦有人解这种方程组用高斯消元啊，其实不用。

记录一下两个数组前缀和用来递推我们就可以学习[某道CF](https://www.luogu.com.cn/problem/CF1778D)打出时间复杂度为 $O(n)$ 的代码了。

## 递推做法详解

如果你没有做过这个CF题可以看这一部分。

这里以 $P_1$ 为例。

由于我们是从 $P_1[0]$ 开始递推的，假设 $P_1[0]=x$。

由于这里没有两项的乘积，只有常数或是一次项，直接写一个维护形为 $ax+b$ 的结构体即可。

最后把所有项相加为 $1$，也就是 $\sum_{i=0}^n a_ix +b_i=x\sum_{i=0}^na_i+\sum_{i=0}^nb_i=1$，解一个一元一次方程把 $x$ 算出来。

（上面的式子中，$a_i,b_i$ 的意义为：$P_1[i]=a_ix+b_i$）

然后每一个 $P_1[i]$ 重新用 $x$ 代入一遍即可。

~~现在你还可以把那道CF过了~~

## Codes

同队的同学具体实现的，征求了他的同意搬过来了。

这种题还是说一声取模（虽然应该没什么大问题）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 998244353;
ll n;
ll ksm( ll a , unsigned long long p ) {
    ll ans = 1;
    while ( p ) {
        if ( p & 1 ) {
            ans = ans * a % mod;
        }
        p >>= 1;
        a = a * a % mod;
    }
    return ans;
}
struct lin {// ax+b的结构体
    ll k, b;
    lin() = default;
    lin( ll k_, ll b_ ) {
        k = k_, b = b_;
    }
    const lin operator + ( const lin rhs ) const {
        return lin((k+rhs.k)%mod,(b+rhs.b)%mod);
    }
    const lin operator - ( const lin rhs ) const {
        return lin((k-rhs.k+mod)%mod,(b-rhs.b+mod)%mod);
    }
    const lin operator * ( const ll rhs ) const {
        return lin(k*rhs%mod,b*rhs%mod);
    }
    const ll operator == ( const lin rhs ) const {
        ll _b = ( rhs.b - b + mod ) % mod;
        ll _k = ( k - rhs.k + mod ) % mod;
        return _b * ksm(_k,mod-2);
    }
    const ll operator () ( const ll rhs ) const {
        return (rhs*k+b) % mod;
    }
};
lin p1[400005], s1[400005];
lin p2[400005], s2[400005];//s1,s2分别为p1,p2的前缀和
int main() {
    scanf("%lld",&n);
    p1[0] = lin{1,0};
    s1[0] = lin{1,0};
    for ( ll i = 1; i <= n; ++i ) {//p1递推部分
        p1[i] = p1[i-1] * ( i - 1 ) + s1[i-1];
        p1[i] = p1[i] * ksm(i, mod-2) * ksm(2,mod-2);
        s1[i] = s1[i-1] + p1[i];
    }
    ll a = ( s1[n] == lin{0,1} );
    for ( ll i = 0; i <= n; ++i ) {
        printf("%lld ",p1[i](a));
    }
    puts("");
    p2[0] = lin{1,0};
    s2[0] = lin{1,0};
    for ( ll i = 1; i <= n; ++i ) {//p2递推部分
        p2[i] = p2[i-1] * (i-1) + s2[i-1];
        p2[i] = p2[i] * 2 * ksm(i, mod-2);
        s2[i] = s2[i-1] + p2[i];
    }
    a = ( s2[n] == lin{0,1} );
    for ( ll i = 0; i <= n; ++i ) {
        printf("%lld ",p2[i](a));
    }
}
```

---

## 作者：Mirasycle (赞：1)

注意到题目里的这句话

> 你需要保证，在一方的策略不变的情况下，另一方无论如何改变自己的策略，都不能使自己的期望收益比原来多。

不妨从检察官的视角来看待这个问题（走私者同理）。

走私者放 $i$ 元的收益显然与检察官猜某大小的概率有关。

设走私者放 $i$ 元的收益为 $E(i)$。检察官猜 $i$ 的概率为 $p_i$。 

那么 $E(i)=\sum\limits_{j=0}^{i-1}i\times p_j+\sum\limits_{j=i+1}^{n}p_j\times \dfrac{j}{2}$。

如果我们的策略中满足 $\{p_j\}$ 让某个 $E_i$ 的比较大，那么如果走私者调整策略压到那个比较大的 $E$ 上面就可以让自己收益期望变大，故不符合题目条件。

所以可以得出所有 $E$ 都是相等的。

列出上述关于 $E$ 的表达式都相等的方程组之后手动解一下（差分一下最快）可以发现

$$p_i=\dfrac{(i-1)p_i+\sum\limits_{j=0}^{i-1}p_j}{2i}$$

对于走私者的运送概率 $q$ 同理推导一下即可。

时间复杂度 $O(n\log n)$


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=4e5+10;
const int mod=998244353;
int f[maxn],g[maxn],sum[maxn],n;
int qpow(int x,int k){
	int res=1;
	for(;k;k>>=1){
		if(k&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
	}
	return res;
}
int main(){
	cin>>n;
	g[0]=1; sum[0]=1;
	for(int i=1;i<=n;i++){
		g[i]=2ll*(1ll*(i-1)*g[i-1]%mod+sum[i-1])%mod*qpow(i,mod-2)%mod;
		sum[i]=(sum[i-1]+g[i])%mod;
	}
	f[0]=1; sum[0]=1;
	for(int i=1;i<=n;i++){
		f[i]=1ll*(1ll*(i-1)*f[i-1]%mod+sum[i-1])%mod*qpow(2*i,mod-2)%mod;
		sum[i]=(sum[i-1]+f[i])%mod;
	}
	sum[1]=sum[2]=0;
	for(int i=0;i<=n;i++) sum[1]=(sum[1]+g[i])%mod;
	for(int i=0;i<=n;i++) sum[2]=(sum[2]+f[i])%mod;
	for(int i=0;i<=n;i++) cout<<1ll*f[i]*qpow(sum[2],mod-2)%mod<<" ";
	cout<<endl;
	for(int i=0;i<=n;i++) cout<<1ll*g[i]*qpow(sum[1],mod-2)%mod<<" ";
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

### 思路：

定义 $f_{1,i}$ 表示走私者放 $i$ 元的概率，$f_{2,i}$ 表示检查者猜 $i$ 元的概率，$F_{1,i}$ 表示走私者放 $i$ 元的期望收益，$F_{2,i}$ 表示检查者猜 $i$ 元的期望收益。

容易得到：

$$F_{1,i}=\sum\limits_{j=0}^{i-1} f_{2,j} \times i + \sum\limits_{j=i+1}^{n} f_{2,j} \times \frac{j}{2}$$

$$F_{2,i}=\sum\limits_{j=i+1}^n j \times f_{1,j} + \sum\limits_{j=0}^{i-1} f_{1,j} \times \frac{i}{2}$$

其中第一部分是走私成功的，第二部分是赔付给走私者的。

发现没法做了，推一下样例试试：

$$f_{1,0}=\frac{2}{3},f_{1,1}=\frac{1}{3}$$

$$f_{2,0}=\frac{1}{3},f_{2,1}=\frac{2}{3}$$

则：

$$F_{1,0}=0+f_{2,1} \times \frac{1}{2}=\frac{2}{3} \times \frac{1}{2}=\frac{1}{3}$$

$$F_{1,1}=f_{2,0} \times 1 + 0=\frac{1}{3}$$

于是得到一个猜测：所有 $F_{1,i}$ 都相同。（可以自己手搓几组试一下）

根据这个猜测，考虑化简式子：

因为 $F_{1,i}=F_{1,i+1}$，则：

$$\sum\limits_{j=0}^{i-1} f_{2,j} \times i + \sum\limits_{j=i+1}^{n} f_{2,j} \times \frac{j}{2}=\sum\limits_{j=0}^{i} f_{2,j} \times (i+1) + \sum\limits_{j=i+2}^{n} f_{2,j} \times \frac{j}{2}$$

$$\sum\limits_{j=0}^{i-1} f_{2,j} \times i + f_{2,i+1} \times \frac{i+1}{2}=\sum\limits_{j=0}^{i} f_{2,j} \times (i+1)$$

$$\sum\limits_{j=0}^{i-1} f_{2,j} \times i + f_{2,i+1} \times \frac{i+1}{2}=\sum\limits_{j=0}^{i} f_{2,j} \times i + \sum\limits_{j=0}^{i} f_{2,j}$$

$$f_{2,i+1} \times \frac{i+1}{2}=f_{2,i} \times i + \sum\limits_{j=0}^{i} f_{2,j}$$

$$f_{2,i+1}=(f_{2,i} \times i + \sum\limits_{j=0}^{i} f_{2,j}) \times \frac{2}{i+1}$$

$$f_{2,i+1}=\frac{2 \times (f_{2,i} \times i + \sum\limits_{j=0}^{i} f_{2,j})}{i+1}$$

换成 $i$ 形式为：

$$f_{2,i}=\frac{2 \times (f_{2,i-1} \times (i-1) + \sum\limits_{j=0}^{i-1} f_{2,j})}{i}$$

因为我们不知道 $f_{2,0}$，也无法推这个式子。

但是因为我们知道 $\sum\limits_{i=0}^n f_{2,i}=1$。

那么我们可以更新一下定义 $tf_{2,j}$ 表示 $f_{2,j}$ 是 $f_{2,0}$ 的 $tf_{2,j}$ 倍。

状态转移和上述一样，可得 $\sum\limits_{i=0}^n tf_{2,i} \times f_{2,0}=1$，得：

$$f_{2,0}=\frac{1}{\sum\limits_{i=0}^n tf_{2,i}}$$

将第二个式子这样化简一下，也可以得（详细过程省略）：

$$f_{1,i}=\frac{(i-1) \times f_{1,i-1} + \sum\limits_{j=0}^{i-1} f_{1,j}}{2 \times i}$$

按照上述方法求得 $f_{1,0}$ 就可以解了。

时间复杂度：$O(N)$。

**中间求逆元可以费马小定理或扩欧。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=400400,mod=998244353ll;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,s1=1ll,s2=1ll;
ll tf[3][N];
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1ll)
		  ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1ll;
	}
	return ans;
}
int main(){
	n=read();
	tf[1][0]=tf[2][0]=1ll;
	for(int i=1;i<=n;i++){
		tf[1][i]=(((i-1)*tf[1][i-1])%mod+s1)%mod;
		tf[1][i]=(tf[1][i]*qpow(2ll*i,mod-2))%mod;
		tf[2][i]=(2ll*((((i-1)*tf[2][i-1])%mod+s2)%mod))%mod;
		tf[2][i]=(tf[2][i]*qpow(i,mod-2))%mod;
		s1=(s1+tf[1][i])%mod;
		s2=(s2+tf[2][i])%mod;
	}
	s1=s2=0;
	for(int i=0;i<=n;i++){
		s1=(s1+tf[1][i])%mod;
		s2=(s2+tf[2][i])%mod;
	}
	s1=qpow(s1,mod-2),s2=qpow(s2,mod-2);
	for(int i=0;i<=n;i++){
		write((tf[1][i]*s1)%mod);
		putchar(' ');
	}
	putchar('\n');
	for(int i=0;i<=n;i++){
		write((tf[2][i]*s2)%mod);
		putchar(' ');
	}
	putchar('\n');	
	return 0;
}
```


---

## 作者：enucai (赞：1)

## Analysis

简单推柿子。

假设走私者选 $x$ 的概率是 $F(x)$，检察官选 $x$ 的概率是 $G(x)$。

那么期望走私的金额是：

$$
\sum_{i=0}^n\sum_{j=0}^{i-1}F(i)G(j)\cdot i+\sum_{i=0}^n\sum_{j=i+1}^nF(i)G(j)\cdot\frac{j}{2}
$$

先考虑求出 $F$ 的递推式。考虑改变 $G$ 变为 $G'$，定义 $H(i)=G'(i)-G(i)$，显然 $\sum H=0$。根据题意，需要保证对于任意 $H$，满足：

$$
\sum_{i=0}^n\sum_{j=0}^{i-1}F(i)H(j)\cdot i+\sum_{i=0}^n\sum_{j=i+1}^nF(i)H(j)\cdot\frac{j}{2}\ge 0
$$

如果对所有的 $H(i)$ 均取反，那么该柿子的值也会取反。因此需要满足：

$$
\sum_{i=0}^n\sum_{j=0}^{i-1}F(i)H(j)\cdot i+\sum_{i=0}^n\sum_{j=i+1}^nF(i)H(j)\cdot\frac{j}{2}= 0
$$

化简一下柿子，得：

$$
\sum_{i=0}^nH(i)\cdot\left(\sum_{j=0}^{i-1}F(j)\cdot \frac{i}{2}+\sum_{j=i+1}^nF(j)\cdot j\right)
$$

由于 $\sum H=0$，因此只需要保证对于所有的 $i$，满足

$$
\sum_{j=0}^{i-1}F(j)\cdot \frac{i}{2}+\sum_{j=i+1}^nF(j)\cdot j
$$

的值都相等，做差分即可求出递推式。

$G$ 的递推式求法与 $F$ 类似，不再赘述。

## Code

```cpp
const Z iv2 = (P + 1) / 2;

const int N = 800010;

int n;
Z a[N], b[N], fac[N], ivf[N];

void trans(Z *c) {
  Z sum = 0;
  rep (i, 0, n) sum += c[i];
  Z iv = sum.inv();
  rep (i, 0, n) c[i] *= iv;
}

int main() {
  fac[0] = 1;
  rep (i, 1, N - 1) fac[i] = fac[i - 1] * i;
  ivf[N - 1] = fac[N - 1].inv();
  per (i, N - 1, 1) ivf[i - 1] = ivf[i] * i;
  n = read();
  trans(a), trans(b);
  a[0] = 1, b[0] = 1;
  Z suma = 0, sumb = 0;
  rep (i, 0, n) {
    a[i + 1] = (Z(i + 1) * iv2 * a[i] + iv2 * suma) / Z(i + 1);
    suma += a[i];
    b[i + 1] = Z(2) * (sumb + Z(i + 1) * b[i]) / Z(i + 1);
    sumb += b[i];
  }
  trans(a);
  rep (i, 0, n) write(a[i].val()), pc(32);
  pc(10);
  trans(b);
  rep (i, 0, n) write(b[i].val()), pc(32);
  pc(10);
}
```

---

## 作者：lightup37 (赞：1)

## 纳什均衡与求解方法

考虑一个两名玩家 $A$ 和 $B$ 参与的游戏，先手有 $n$ 种策略，记作 $\mathcal F_{1, 2, \cdots, n}$，后手有 $m$ 种策略，记作 $\mathcal G_{1, 2, \cdots, n}$。对于任意 $x\in [1, n]$ 和 $y\in [1, m]$，可以定义一个分数 $P_{x, y}$ 为实数，代表若先手采取 $\mathcal F_x$ 而后手采取 $\mathcal G_y$，则先手得到 $P_{x, y}$ 分。

我们称 A 的一种策略为一个长度为 $n$ 的实数数列 $p$，且诸项之和为 $1$，$p_i$ 代表以 $p_i$ 的概率选取 $\mathcal F_i$。定义一个操作的分数为 $\min\limits_{q_1+q_2+\cdots+q_m = 1, \forall i , q_i\in[0, 1]} \{\sum\limits_{i, j} p_i q_j P_{i, j}\}$。

先手必然有一个策略最大化其分数，后手必然也有一个策略最小化先手的分数，这两个值必然是相等的，这两个策略称作纳什均衡。

若欲求纳什均衡，不妨假设最大分数为 $E$，可以列出条件：

$$\exists \{p_i\}, p_i\in[0, 1], \sum p_i=1, \forall \{q_i\},q_i\in[0, 1], \sum q_i = 1, \sum\limits_{i, j} p_i q_j P_{i, j}\leq E$$

显然我们不需要这么多条件：只需要 $m$ 个就够了。

$$\exists \{p_i\}, p_i\in[0, 1], \sum p_i=1, \forall j\in[1, m], \sum\limits_{i} p_i P_{i, j}\leq E$$

若能满足这 $m$ 个条件，则必然可以满足任意选取 $q_j$ 的不等式，只需要将所有 $j$，第 $j$ 个条件的不等式乘上 $q_j$，然后求和，就可以得到对应的 $q_j$ 的不等式。

重写成另一种形式：

$$
\max E. \text{ subject to} \\

\left\{
\begin{aligned}
&p_1, p_2, \cdots , p_n \in [0, 1] \\
&\sum p_i = 1\\
&\sum\limits p_i P_{i, 1}\leq E \\
&\sum\limits p_i P_{i, 2}\leq E \\
&\cdots \\
&\sum\limits p_i P_{i, m}\leq E
\end{aligned}
\right.
$$

令 $x_i$ 为若干未知数，满足 $x_i = \frac{p_i}{E}$，可以重写为

$$
\min \sum x_i. \text{ subject to} \\

\left\{
\begin{aligned}
&\sum\limits x_i P_{i, 1}\leq 1 \\
&\sum\limits x_i P_{i, 2}\leq 1 \\
&\cdots \\
&\sum\limits x_i P_{i, m}\leq 1
\end{aligned}
\right.
$$

可以直接利用线性规划求解。

但是线性规划太麻烦了，能不能再给力一点？

我们直接考虑方程组

$$
\left\{
\begin{aligned}
&\sum p_i = 1\\
&\sum\limits p_i P_{i, 1} = \sum\limits p_i P_{i, m}\\
&\sum\limits p_i P_{i, 2} = \sum\limits p_i P_{i, m}\\
&\cdots \\
&\sum\limits p_i P_{i, m-1} = \sum\limits p_i P_{i, m}
\end{aligned}
\right.
$$

若方程组的解满足所有 $p_i$ 均为正数，那么方程组的解 $p_i$ 就是先手的最优策略。

证明留给读者做作业。

## P9142 题解

列出纳什均衡后直接求解方程组即可。

```cpp
#include<bits/stdc++.h>
#define f(i,x,y) for(int i=x, i##end=y; i<=i##end; ++i)
#define d(i,x,y) for(int i=y, i##end=x; i>=i##end; --i)
#define uf(i,x,y) for(int i=x, i##end=y; i<i##end; ++i)
#define ll long long
#define pir pair<int, int>
#define fir first
#define sec second
#define mp make_pair
#define pb push_back 
#define int long long
char ch;
int rd() {
  int f=1, x=0; ch=getchar();
  while(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }
  while(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }
  return x*f;
}
void rd(int& x) { x=rd(); }
using namespace std;
const int _ = 1e6 + 5, mod = 998244353;
int qpow(int a, int b) {
  int res=1; for(; b; b>>=1, a=a*a%mod) if(b&1) res=res*a%mod; return res;
}
int v[_], s[_];
// n/2 v_n = \sum i=0 .. n-1 vi + (n-1)v{n-1}
// q1 = 2q0
// q2 = 5q0
int n;
signed main() {
  rd(n);
  v[0] = 1; v[1] = 2; s[0] = 1; s[1] = 3;
  f(i,2,n) {
    v[i] = (s[i-1] + (i-1) * v[i-1] % mod) % mod;
    v[i] = v[i] * 2 * qpow(i, mod-2) % mod;
    s[i] = s[i-1] + v[i];
    // cerr << i << ' ' << v[i] << endl;
  }
  // cerr << v[2] << endl;
  int ans = 2 * qpow(n+2, mod-2) % mod;
  cout << ans << ' ';
  f(i,1,n) {
    ans = qpow(n+2, mod-2);
    cout << ans << ' ';
  }
  cout << endl;
  ll s = 0;
  f(i,0,n) { s += v[i]; s %= mod; }
  s = qpow(s, mod-2);
  // cerr << "s = " << s << endl;
  f(i,0,n) {
    ans = v[i] * s % mod;
    cout << ans << ' ';
  }
  cout << endl;
  return 0;
}
```

---

## 作者：Terac (赞：0)

纳什均衡板题。

无论对方放或猜什么数，期望收益均相等。

对于走私者，若对面猜 $i$，期望收益为 $\dfrac i 2\sum\limits_{j=0}^{i-1}p_j +\sum\limits_{j=i+1}^nj\cdot p_j$。把 $i$ 和 $i-1$ 代入可得 $i\cdot p_i=\dfrac 1 2\sum\limits_{j=0}^{i-2}p_j+\dfrac i 2 p_{i-1}$，即  $p_i=\dfrac 1 {2i}\sum\limits_{j=0}^{i-2}p_j+\dfrac 1 2 p_{i-1}$。

对于检察官，若对面放 $i$，期望收益为 $i\sum\limits_{j=0}^{i-1}p_j +\sum\limits_{j=i+1}^n \dfrac j 2 \cdot p_j$。把 $i$ 和 $i-1$ 代入可得 $\dfrac 1 2i\cdot p_i=\sum\limits_{j=0}^{i-2}p_j+i\cdot p_{i-1}$，即 $p_i=\dfrac {2}{i}\sum\limits_{j=0}^{i-2}p_j+2p_{i-1}$。

用 $p_0$ 表示出 $p_i$，再用 $\sum p_i=1$ 求出 $p_0$ 即可。$O(n)$。

---

## 作者：masonpop (赞：0)

首先可以感性理解，就是最优策略下，无论对方策略如何，走私者期望收益都相同。具体原因牵扯到纳什均衡之类的东西。当然也可以调整法自己推推，反正我不会。

考虑设走私者和检察官各自的概率是以 $p_i,q_i$ 的概率选择金额 $i$。

① 对于走私者，固定检察官选 $x$，则期望收益为 $\frac{x}{2}\sum\limits_{i=0}^{x-1}p_i+\sum\limits_{i=x+1}^nip_i$。邻项相减得到 $(x+1)p_{x+1}=\frac{1}{2}\sum\limits_{i=0}^{x-1}p_i+\frac{x+1}{2}p_x$。然后带进去算几项可以惊奇的发现，对任意 $i\ge 1,p_i=\frac{p_0}{2}$。

② 对于检察官，采取同样的计算方法得到 $\frac{x+1}{2}q_{x+1}=\sum\limits_{i=0}^{x-1}q_i+(x+1)q_x$。这个东西就没什么规律了，可以通过处理前缀和的方式把每个数都表示成 $q_i=k_iq_0$ 的形式，然后利用概率和为 $1$ 反解出 $q_0$。

复杂度 $O(n)$。[代码](https://www.luogu.com.cn/record/138812060)。

---

## 作者：XBaiC (赞：0)

### 思路

以不同角色的视角，合并同类项。

把一方看做是变量时，其余所有看作是常量。

对于走私者来说，收益形如 $ {\textstyle \sum_{}p_{i} } \times {\textstyle \sum_{}x_{(i,j)}w_{(j)} }$。

此时，对于检察官来说，令 $n$ 个系数 ${\textstyle \sum_{}x_{(i,j)}w_{(j)} }$ 都相同。

即走私者不管怎么选择，走私者都只能获得固定收益。

察官达到了使对方利益最小化的目的（不存在比这大的可能性）。

对于检察官来说，收益形如 ${\textstyle \sum_{}w_{i} } \times {\textstyle \sum_{}x_{(i,j)}p_{(j)} }$。

此时，对于走私者来说，令 $n$ 个系数 ${\textstyle \sum_{}x_{(i,j)}p_{(j)} }$ 都相同。

即检察官不管怎么选择，走私者都只能获得固定收益。

走私者达到了自己利益最大化的目的（不存在比这小的可能性）。

### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+10,mod=998244353;
int n,p[N],w[N],sump,sumw,is,ip,inv[N];
int modpow(int x,int n,int mod){
    int res=1;
    for(;n;n>>=1,x=1ll*x*x%mod){
        if(n&1)res=1ll*res*x%mod;
    }
    return res;
}
void init(){
    inv[1]=1;
    for(int i=2;i<N;i++){
        inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;
    }
}
int main(){
    scanf("%d",&n);
    //assert(1<=n && n<=400000);
    init();
    w[0]=1;
    for(int i=0;i<=n;++i){
        w[i+1]=(sumw+1ll*(i+1)*w[i]%mod)%mod;
        w[i+1]=2ll*w[i+1]%mod;
        w[i+1]=1ll*w[i+1]*inv[i+1]%mod;
        sumw=(sumw+w[i])%mod;
    }
    /*
    p[0]=1;p[1]=modpow(2,mod-2,mod);
    sump=p[0];
    for(int i=1;i<=n;++i){
        p[i+1]=1ll*inv[2]*sump%mod;
        p[i+1]=(p[i+1]+1ll*(i+1)*inv[2]%mod*p[i]%mod)%mod;
        p[i+1]=1ll*inv[i]*p[i+1]%mod;
        sump=(sump+p[i])%mod;
    }*/
    //ip=modpow(sump,mod-2,mod);
    is=modpow(sumw,mod-2,mod);
    //printf("1/8:%d 2/8:%d\n",modpow(8,mod-2,mod),modpow(4,mod-2,mod));
    //assert(sum!=0);
    //printf("sum:%d is:%d\n",sum,is);
    ip=inv[n+2];
    for(int i=0;i<=n;++i){
        if(i==0)p[i]=2ll*ip%mod;
        else p[i]=ip;
        printf("%d%c",p[i]," \n"[i==n]);
    }
    for(int i=0;i<=n;++i){
        w[i]=1ll*w[i]*is%mod;
        printf("%d%c",w[i]," \n"[i==n]);
    }
    return 0;
}
```


---

## 作者：Graphcity (赞：0)

注意到输出格式中有一句非常重要的话：**另一方无论如何改变自己的策略，都不能使自己的期望收益比原来多。**

我们设单轮博弈中走私者出钱的概率为 $a_{0\cdots n}$，检察官猜钱的概率为 $b_{0\cdots n}$，那么期望就为

$$
\sum_{i=0}^na_i(i\sum_{j=0}^{i-1}b_j+\sum_{j=i+1}^nb_j\frac{j}{2})
$$

设 $f_i=i\sum_{j=0}^{i-1}b_j+\sum_{j=i+1}^nb_j\dfrac{j}{2}$，根据题意所有的 $f_i$ 都相同，也就是 $f_i-f_{i+1}=0$。

$$
\begin{aligned}
f_{i}-f_{i+1} &=i\sum_{j=0}^{i-1}b_j-(i+1)\sum_{j=0}^ib_j+\sum_{j=i+1}^nb_j\frac{j}{2}-\sum_{j=i+2}^nb_j\frac{j}{2}\\
&=-(\sum_{j=0}^{i-1}b_j+(i+1)b_i)+b_{i+1}\frac{i+1}{2}\\
b_{i+1}\frac{i+1}{2} &=\sum_{j=0}^{i-1}b_j+(i+1)b_i
\end{aligned}
$$

设 $b_0=x$，那么 $b_i$ 一定能够表示成 $k_ix$ 的形式。最后根据 $\sum_{i=0}^nb_i=1$ 求出 $x$ 的值，然后回带即可。

$a$ 数组同理，根据一样的方式可以推得它的值。时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=4e5,Mod=998244353,i2=(Mod+1)/2;

inline int Pow(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=1ll*res*x%Mod;
        x=1ll*x*x%Mod,y>>=1;
    }
    return res;
}

int n,A[Maxn+5],B[Maxn+5];
struct Num
{
    int k,b;
    inline Num() {}
    inline Num(int _k,int _b): k(_k),b(_b) {}
} t[Maxn+5],sum;
inline Num operator+(Num x,Num y) {return Num((x.k+y.k)%Mod,(x.b+y.b)%Mod);}
inline Num operator-(Num x,Num y) {return Num((x.k-y.k+Mod)%Mod,(x.b-y.b+Mod)%Mod);}
inline Num operator*(Num x,Num y) {return Num(1ll*x.k*y.k%Mod,1ll*x.b*y.b%Mod);}
inline Num operator*(Num x,int y) {return Num(1ll*x.k*y%Mod,1ll*x.b*y%Mod);}

signed main()
{
    cin>>n; t[0].k=1;
    For(i,0,n-1)
    {
        t[i+1]=(sum+t[i]*(i+1))*Pow(1ll*(i+1)*i2%Mod,Mod-2);
        sum=sum+t[i];
    } sum=sum+t[n];
    int x=1ll*(1-sum.b+Mod)*Pow(sum.k,Mod-2)%Mod;
    B[0]=x;
    For(i,1,n) B[i]=(1ll*x*t[i].k+t[i].b)%Mod;
    For(i,0,n) t[i].k=t[i].b=0; sum.k=sum.b=0;

    t[0].k=1;
    For(i,0,n-1)
    {
        t[i+1]=(sum*i2+t[i]*(1ll*(i+1)*i2%Mod))*Pow(i+1,Mod-2);
        sum=sum+t[i];
    } sum=sum+t[n];
    x=1ll*(1-sum.b+Mod)*Pow(sum.k,Mod-2)%Mod;
    A[0]=x;
    For(i,1,n) A[i]=(1ll*x*t[i].k+t[i].b)%Mod;

    For(i,0,n) printf("%lld ",A[i]);
    printf("\n");
    For(i,0,n) printf("%lld ",B[i]);
    printf("\n");
    return 0;
}
```

---


# [HAOI2007] 修筑绿化带

## 题目描述

为了增添公园的景致，现在需要在公园中修筑一个花坛，同时在花坛四周修建一片绿化带，让花坛被绿化带围起来。

如果把公园看成一个 $M\times N$ 的矩形，那么花坛可以看成一个 $C\times D$ 的矩形，绿化带和花坛一起可以看成一个 $A\times B$ 的矩形。

如果将花园中的每一块土地的“肥沃度”定义为该块土地上每一个小块肥沃度之和，那么，绿化带的肥沃度为 $A\times B$ 块的肥沃度减去 $C\times D$ 块的肥沃度。

为了使得绿化带的生长得旺盛，我们希望绿化带的肥沃度最大。

## 说明/提示

对于 $30\%$ 的数据，$1\leq M,N\leq 50$。

对于 $100\%$ 的数据，$1\leq M,N\leq 1000$，$1\leq A\leq M$，$1\leq B\leq N$，$1\leq C\leq A-2$，$1\leq D\leq B-2$，$1\leq x_{i,j}\leq 100$。

## 样例 #1

### 输入

```
4 5 4 4 2 2
20 19 18 17 16
15 14 13 12 11
10 9 8 7 6
5 4 3 2 1
```

### 输出

```
132```

# 题解

## 作者：nosta (赞：43)

~~说看代码理解的你们够了~~

相信泥萌都是从试炼场刷过来的吧？所以[这道题](https://www.luogu.org/problemnew/show/P2216)泥萌一定做过了。回顾一下怎么做的呢？二维的单调队列做法：先就某一维上对原始数据进行处理，在对另一维上对前一维的数据进行处理，就得到了所需要的东西。

回到这题，也是同样的做法，下边是我解题时的思路：

1. 预处理出以A\[i,j\]、B\[i,j\]分别为右下角的花坛(C\*D)、大矩形(A\*B)的肥沃度和

2. 按行，利用单调队列求出P\[i,j\]=以A\[i, j-B+1+D→j-1\]中的最小值，即以(i, j-B+1+D→j-1)为右下角的花坛肥沃度的最小值。 

3. 按列，利用单调队列求出Q\[i,j\]=以P\[i-A+1+C→i-1, j\]中的最小值，即以(i-A+1+C→i-1, j-B+1+D→j-1) 为右下角的花坛肥沃度的最小值，显然，这些花坛包含在了以(i,j)为右下角的大矩形中；  

4. 显然B\[i,j\]-Q\[i,j\]即为以(i,j)为右下角的绿化带的最大肥沃值。


时间复杂度 O(nm)。代码实现中n、m与题意是反的。~~欢迎来hack~~

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1005;

int n,m,A,B,C,D,hd,tl,q[N];
int s[N][N],a[N][N],b[N][N],P[N][N],Q[N][N];

int main() {
	scanf("%d%d %d%d%d%d",&n,&m,&A,&B,&C,&D);
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=m; ++j) {
			scanf("%d",&s[i][j]);
			s[i][j]=s[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
		}
	}
	for(int i=C+1; i<n; ++i) {
		for(int j=D+1; j<m; ++j) {
			a[i][j]=s[i][j]-s[i-C][j]-s[i][j-D]+s[i-C][j-D];
		}
	}
	for(int i=A; i<=n; ++i) {
		for(int j=B; j<=m; ++j) {
			b[i][j]=s[i][j]-s[i-A][j]-s[i][j-B]+s[i-A][j-B];
		}
	}
	for(int i=C+1; i<n; ++i) {
		hd=1, tl=0;
		for(int j=D+1; j<m; ++j) {
			while(hd<=tl && q[hd]<j-B+2+D) hd++; //*
			while(hd<=tl && a[i][q[tl]]>=a[i][j]) tl--;
			q[++tl]=j;
			if(j>=B-1) P[i][j+1]=a[i][q[hd]];
		}
	}
	for(int j=B; j<=m; ++j) {
		hd=1, tl=0;
		for(int i=C+1; i<n; ++i) {
			while(hd<=tl && q[hd]<i-A+2+C) hd++;
			while(hd<=tl && P[q[tl]][j]>=P[i][j]) tl--;
			q[++tl]=i;
			if(i>=A-1) Q[i+1][j]=P[q[hd]][j];
		}
	}
	int ans=0;
	for(int i=A; i<=n; ++i) {
		for(int j=B; j<=m; ++j) {
			ans=max(ans,b[i][j]-Q[i][j]);
		}
	}
	printf("%d\n",ans);
	return 0;
} 
```
\* 原来的区间\[j-B+1+D, j-1\]是对于j来说的；但此处我们在j的位置时更新j+1，所以范围调整为\[j-B+2+D, j\]。下同。

---

## 作者：xyz32768 (赞：16)

先利用前缀和，预处理出$ab[i][j]$和$cd[i][j]$，分别表示以$(i,j)$为右下角的长为$A$宽为$B$的子矩阵总和以及以$(i,j)$为右下角的长为$C$宽为$D$的子矩阵总和。

然后，可以发现，如果暴力枚举绿化带的右下角位置$(i,j)$，那么需要在以$(i-1,j-1)$为右下角的长为$A-2$宽为$B-2$的子矩阵中，取出一个长为$C$宽为$D$的子矩阵，让这个长为$C$宽为$D$的子矩阵总和最小，也就是求$cd[i-A+C+1...i-1][j-B+D+1...j-1]$的最小值。

这样，就可以用「$HAOI2007$理想的正方形」的做法去做。

做法：

1、对于每个$C<=i<=m$，利用单调队列，计算出所有$cd[i][j-B+D+2...j]$范围的最小值$min1[i][j]$($B-2<=j<=n$)。

2、对于每个$B-2<=j<=n$，再利用单调队列，计算出所有$min1[i-A+C+2...i][j]$范围的最小值$min2[i][j]$($A-2<=i<=m$)

可以发现，$min2[i][j]$的值就是$cd[i-A+C+2...i][j-B+D+2...j]$范围的最小值。

所以对于任何一个$A<=i<=m,B<=j<=n$，绿化带以$(i,j)$为右下角的最大肥沃度为$ab[i][j]-min2[i-1][j-1]$，暴力枚举$i$和$j$即可。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1005;
int m, n, A, B, C, D, sum[N][N], ab[N][N], cd[N][N], H, T, que[N], id[N],
px[N][N], py[N][N], res;
int main() {
    int i, j; m = read(); n = read(); A = read();
    B = read(); C = read(); D = read();
    for (i = 1; i <= m; i++) for (j = 1; j <= n; j++)
        sum[i][j] = sum[i - 1][j] + sum[i][j - 1] -
            sum[i - 1][j - 1] + read();
    for (i = A; i <= m; i++) for (j = B; j <= n; j++)
        ab[i][j] = sum[i][j] - sum[i - A][j]
            - sum[i][j - B] + sum[i - A][j - B];
    for (i = C; i <= m; i++) for (j = D; j <= n; j++)
        cd[i][j] = sum[i][j] - sum[i - C][j]
            - sum[i][j - D] + sum[i - C][j - D];
    for (i = C; i <= m; i++) {
        H = T = 0;
        for (j = D; j <= B - 2; j++) {
            while (H < T && que[T] > cd[i][j]) T--;
            que[++T] = cd[i][j]; id[T] = j;
        }
        px[i][B - 2] = que[H + 1];
        for (j = D + 1; j - D + B - 2 <= n; j++) {
            while (H < T && que[T] > cd[i][j - D + B - 2]) T--;
            que[++T] = cd[i][j - D + B - 2]; id[T] = j - D + B - 2;
            if (id[H + 1] == j - 1) H++;
            px[i][j - D + B - 2] = que[H + 1];
        }
    }
    for (j = B - 2; j <= n; j++) {
        H = T = 0;
        for (i = C; i < A; i++) {
            while (H < T && que[T] > px[i][j]) T--;
            que[++T] = px[i][j]; id[T] = i;
        }
        py[A - 2][j] = que[H + 1];
        for (i = C + 1; i - C + A - 2 <= m; i++) {
            while (H < T && que[T] > px[i - C + A - 2][j]) T--;
            que[++T] = px[i - C + A - 2][j]; id[T] = i - C + A - 2;
            if (id[H + 1] == i - 1) H++;
            py[i - C + A - 2][j] = que[H + 1];
        }
    }
    for (i = A; i <= m; i++) for (j = B; j <= n; j++)
        res = max(res, ab[i][j] - py[i - 1][j - 1]);
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：Itst (赞：12)

### 好像之前的两篇题解都被$hack$了，然而我的代码完好无损233，欢迎各种强数据来$hack$
### [这里是一道类似的题目（一年竟然考两道这种题目emmm）](https://www.luogu.org/problemnew/show/P2216)
### 核心算法当然是二维的单调队列加二维前缀和，首先用一个单调队列数组维护左上角在某一行上的$C \times D$矩形的最小值，然后用一个单调队列维护列上在一个$A \times B$矩形中可以选择的$C \times D$矩形的最小值，时间复杂度$O(NM)$
### 难点是各种各样的细节调了很多次细节才调好
### 不怎么好理解就看代码吧$emmm$~~代码也不好理解~~
```
#include<bits/stdc++.h>
using namespace std;

inline int read(){
    int a = 0;
    char c = getchar();
    while(!isdigit(c))
        c = getchar();
    while(isdigit(c)){
        a = (a << 3) + (a << 1) + (c ^ '0');
        c = getchar();
    }
    return a;
}

deque < int > q[1001] , Q;
//单调队列~
int num[1001][1001] , sum[1001][1001];
int M = read() , N = read() , A = read() , B = read() , C = read() , D = read() , ans = 0;

inline int calc1(int x , int y){
    return sum[x + C - 1][y + D - 1] - sum[x - 1][y + D - 1] - sum[x + C - 1][y - 1] + sum[x - 1][y - 1];
}
//计算左上角为(x,y)的C*D矩形的和

inline int calc2(int x , int y){
    return sum[x + A - 1][y + B - 1] - sum[x - 1][y + B - 1] - sum[x + A - 1][y - 1] + sum[x - 1][y - 1];
}
//计算左上角为(x,y)的A*B矩形的和

int main(){
    for(int i = 1 ; i <= M ; i++)
        for(int j = 1 ; j <= N ; j++)
            sum[i][j] = (num[i][j] = read()) + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
    for(int i = 2 ; i <= N - D ; i++){
        for(int j = 2 ; j <= M - C ; j++){
            if(!q[j].empty() && q[j].front() == i + D - B + 1)
                q[j].pop_front();
            while(!q[j].empty() && calc1(j , q[j].back()) >= calc1(j , i))
                q[j].pop_back();
            q[j].push_back(i);
            //计算左上角行号为j的C*D矩形的最小值
        }
        if(i + D - B >= 0){
            //计算左上角列号为i + D - B + 1的A*B矩形的答案
            Q.clear();
            for(int k = 2 ; k <= M - C ; k++){
                if(!Q.empty() && k + C - A + 1 == Q.front())
                    Q.pop_front();
                while(!Q.empty() && calc1(Q.back() , q[Q.back()].front()) >= calc1(k , q[k].front()))
                    Q.pop_back();
                Q.push_back(k);
                if(k + C - A >= 0)
                    ans = max(ans , calc2(k + C - A + 1 , i + D - B + 1) - calc1(Q.front() , q[Q.front()].front()));
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：我没有开挂 (赞：8)

改了多2个小时终于A了（~~果然还是我太水了~~）

本来刚看到这道题一点思路都没有，只知道跟P2216很像，于是就打开了~~罪恶的~~题解，瞪着那个唯一没被Hack的题解看了半天，完全看不懂，于是只好自己研究研究，没想到竟然搞出来了。

主要思路就是先用二维前缀和搞出每一个以i,j为左上角的C×D大的肥沃度之和，记录到一个数组imap里，然后再找到以i,j为左上角的A×B大的矩形中最小的imap值，最后再扫一遍就行了。然后这里还有一个坑，就是花坛必须严格被绿化带包围，连边重叠都不行。

模拟一下样例:

原数据：

![undefined](https://cdn.luogu.com.cn/upload/pic/44476.png)

记录的imap值:

![undefined](https://cdn.luogu.com.cn/upload/pic/44480.png)

然后找出来的minmap值：

![undefined](https://cdn.luogu.com.cn/upload/pic/44478.png)

上面这个minmap就是以i,j为左上角，大小为3×3的值的最小值（为什么是3×3,A和B不都是4吗？仔细想一下，imap记录的就已经是以i,j为左上角，大小为C×D即2×2的和了，如果这里minmap取4×4的话，那么它包含的真实范围就是(4-2+1)×(4-2+1)=5×5了）

令sumAB(i,j)表示已i,j为左上角，大小为A×B的矩形和,那么最后答案就等于max{sumAB(i,j)-minmap[i][j]}了。

至于怎么通过imap转移到minmap，~~自己研究吧~~做一下P2216你就知道了。

放一下代码：

```cpp

#include <bits/stdc++.h>

#define MAXN 1010
#define re register
#define INF 0x7fffffff

using namespace std;

struct mon_que //单调队列，怎么实现以及干嘛的详见P4392和P1886
{
	int head,tail;
	int num[MAXN],p[MAXN];
	bool flag;
	void init(bool flg=false)
	{
		head=1,tail=0;
		flag=flg;
	}
	bool empty()
	{
		return head>tail;
	}
	void insert(const int &x,const int &pos)
	{
		if(flag) while(x>=num[tail]&&!empty()) --tail;
		else while(x<=num[tail]&&!empty()) --tail;
		num[++tail]=x;
		p[tail]=pos;
	}
	void del_p(const int &pos)
	{
		while(p[head]<=pos) ++head;
	}
	int front()
	{
		return num[head];
	}
}q;

int imap[MAXN][MAXN],sum[MAXN][MAXN];
int rmin[MAXN][MAXN],minmap[MAXN][MAXN];
int n,m,a,b,c,d,ans,ta,tb;

inline int read()
{
	re int res=0;re bool f=1;
	re char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=0;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=(res<<3)+(res<<1)+(ch&15);
		ch=getchar();
	}
	return f?res:-res;
}

inline int sumCD(const int &x,const int &y)//计算以x,y为左上角，大小为C*D的矩形和
{
	return sum[x+c-1][y+d-1]-sum[x-1][y+d-1]-sum[x+c-1][y-1]+sum[x-1][y-1];
}

inline int sumAB(const int &x,const int &y)//计算以x,y为左上角，大小为A*B的矩形和
{
	return sum[x+a-1][y+b-1]-sum[x-1][y+b-1]-sum[x+a-1][y-1]+sum[x-1][y-1];
}

int main()
{
	n=read(),m=read(),a=read(),b=read(),c=read(),d=read();
	for(re int i=1;i<=n;++i)
		for(re int j=1;j<=m;++j)
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+read();//二维前缀和
	for(re int i=1;i<=n-c+1;++i)
		for(re int j=1;j<=m-d+1;++j)
			imap[i][j]=sumCD(i,j);
	ta=a,tb=b;
	a=a-c-1,b=b-d-1;//这么搞的目的是排除掉花坛与绿化带边重叠的情况
	
	for(re int i=2;i<n-c+1;++i)
	{
		q.init();
		for(re int j=2;j<m-d+1;++j)
		{
			q.insert(imap[i][j],j);
			q.del_p(j-b);
		 	if(j>=b) rmin[i-1][j-b]=q.front();
		}
	}//rmin[i][j]记录的是从imap[i][j]到imap[i][j+b-1]的最小值
	for(re int i=2;i<m-d+1;++i)
	{
		q.init();
		for(re int j=2;j<n-c+1;++j)
		{
			q.insert(rmin[j-1][i-1],j);
			q.del_p(j-a);
			if(j>=a) minmap[j-a][i-1]=q.front();
		}
	}//minmap[i][j]就是rmin[j][i]到rmin[j+a-1][i]的最小值
	//与P2216基本一样
	
	a=ta,b=tb;
	for(re int i=1;i<=n-a+1;++i)
		for(re int j=1;j<=m-b+1;++j)
			ans=max(ans,sumAB(i,j)-minmap[i][j]);//最后计算一下取最大值
	printf("%d\n",ans-2333);//防抄2333
	return 0;
}
```

---

## 作者：斯茂 (赞：7)

 ## 过了这道题，发一个题解，权当总结一些单调队列的基本写法
 此题思路：枚举所有的A * B的矩形，并求出其中和最小的C*D矩形。
 
实现上我们就用到了单调队列

下面的讲解中，S表示二位前缀和，x[i][j]表示以(i, j)为右下角，大小为C * D的矩形，u[i][j]表示(i, j-(B-D-1)+1)到(i, j）这条线段上的x的最小值，v[i][j]表示以(i, j)为右下角，大小为(A-C-1) * (B-D-1)的矩形中x的最小值。

### 问题1：为什么是A-C-1和B-D-1?

设矩形的左上角为(1, 1)，右下角为(A, B)。在其中选出一个C*D的矩形，且不与边界接触。这个矩形的左上角一定是比(2, 2)更靠右下的（或者一样），右下角一定是比(A-1, B-1)更靠坐上的（或者一样）。那么右下角的坐标范围就是(C+1, D+1)到(A-1, B-1)，这个大小就是(A-C-1)*(B-D-1)了

### 问题2：为什么要先求一维的再求二维的？

因为我太弱了不会直接写二维

### 问题3：单调队列的原理和实现？

考虑滑动窗口问题求最大值。如果点i的权值是ai，点j的权值是aj。若i<j&&ai<aj，那么在j点进入可行区间后，i点就不会再作为最优解了，所以可以直接踢出。

实现上做一个双端队列，其中从左到右下标越来越大（即越来越新），从右到左权值越来越大（即越来越优）。所以每次加入一个点前要从左边把过期的点删除，从右边把不够优的点删除。在加入新点后就可以用最左端的最优解来得出所有值了。

最好每道题都在纸上推一下各种边界条件，以免写错

### 至此，这道题解决完毕，但有一些题意理解和实现上的误区，这里澄清一下：

### 矩形A * B和C * D不能翻转

### 绿化带必须是一个闭合圈

### 此题不需要long long

### 窗口长为a时，判断的条件是>=a而非>a

## 下面是(自认为写得很丑陋的)代码
```
#include <cstdio>
#include <iostream>
#include <cstring>
#define int long long
using namespace std;
int a[1005][1005], x[1005][1005], u[1005][1005], v[1005][1005], S[1005][1005];
int q[1005], l, r;
signed main()
{
	int n, m, A, B, C, D, i, j, ans = -1;
	scanf("%lld%lld%lld%lld%lld%lld", &n, &m, &A, &B, &C, &D);
	for(i = 1; i <= n; i++)
		for(j = 1; j <= m; j++)
			scanf("%lld", &a[i][j]), S[i][j] = S[i][j - 1] + S[i - 1][j] - S[i - 1][j - 1] + a[i][j];
	for(i = C; i <= n; i++)
		for(j = D; j <= m; j++)
			x[i][j] = S[i][j] - S[i - C][j] - S[i][j - D] + S[i - C][j - D];
	for(i = 1; i <= n; i++)//点动成线 
	{
		l = 1, r = 0;
		for(j = 1; j <= m; j++)
		{
			while(l <= r && j - q[l] >= B - D - 1) l++;
			while(l <= r && x[i][q[r]] >= x[i][j]) r--;
			q[++r] = j;
			u[i][j] = x[i][q[l]];
		}
	}
	for(i = 1; i <= m; i++)//线动成面 
	{
		l = 1, r = 0;
		for(j = 1; j <= n; j++)
		{
			while(l <= r && j - q[l] >= A - C - 1) l++;
			while(l <= r && u[q[r]][i] >= u[j][i]) r--;
			q[++r] = j;
			v[j][i] = u[q[l]][i];
		}
	}
	for(i = A; i <= n; i++)
		for(j = B; j <= m; j++)
			ans = max(ans, S[i][j] - S[i - A][j] - S[i][j - B] + S[i - A][j - B] - v[i - 1][j - 1]);
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：ix35 (赞：5)

### 写一篇二维ST表的题解吧...之前MLE和RE都遇到了几次，后来修改了一下就过了

**其实这不太算真正意义上的二维ST表，因为这道题空间有点卡，开$O(N^2log^2N)$是很难卡过的，所以需要把两次ST分开，但是这里也稍微写一下二维ST**

首先先来回忆一维的ST表，我们是用倍增以及DP的思想，定义$f[i][j]$的意义为：$\min \limits_{i \leq x \leq i+2^j-1} a[x]$。

那么初始状态就是$f[i][0]=a[i]$，转移方程是$f[i][j]=\min (f[i][j-1],f[i+2^{j-1}-1][j-1])$，初始化的时间复杂度为$O(NlogN)$。

在处理询问的时候，我们使用拼凑的方法，例如询问$[x,y]$的最小值时，设$k=log(y-x+1)$，答案可以$O(1)$得出：$ans=\min (f[x][k],f[y-2^k+1][k])$，这里是通过将答案区间分成两个尽量长却不超出范围的区间，利用最小值无需担心重复计数的性质完成的。

那么二维ST表呢？

在这题里，所有图形都是矩形，不太方便表示，这里以[P2216理想的正方形](https://www.luogu.org/problemnew/show/P2216)为例，这里的图形都是正方形，不需要二维的log表示。所以我们可以定义$f[i][j][k]=\min \limits_{i \leq x \leq i+2^k-1} (\min \limits_{j \leq y \leq j+2^k-1} a[x][y])$，即一个边长为$2^k$的正方形内的元素最小值。

此时初始状态$f[i][j][0]=a[i][j]$，转移方程比较麻烦，要将一个正方形拆分成四个小正方形，这里我们令$l=2^{k-1}$，则可以写出转移方程：$f[i][j][k]=\min(f[i][j][k-1],f[i][j+l-1][k-1],f[i+l-1][j][k-1],f[i+l-1][j+l-1][k-1])$（可以画图理解一下...）要求某一个区间的最值，也用类似的方法拆分成四个可以重叠的正方形，这里不再赘述了。

这题是要求矩形，可能先会想到用$f[i][j][k][l]$表示以$(i,j)$为左上角，长为$2^k$，宽为$2^l$的矩形最小值，但是会发现这样时间和空间复杂度都是$O(N^2log^2N)$，在这题里可能无法通过，于是想办法优化，可以考虑的优化方法就是将两次ST的过程拆开。

这里我借用的题解中某个单调队列解法的思想，就是首先算出**在同一行内，长度为B-D-2的每个区间最小值**，再通过这个结果算出**在同一列内，长度为A-C-2的每个区间最小值，这里的区间指的是由上一个数组组成的区间**，也就是先处理行，再通过已知行的结果求解列，这两个过程都可以通过一维的ST表来完成，类似地做两次，就实现了二维ST表的效果，时间和空间复杂度仅为$O(N^2logN)$（如果空间使用滚动，那么还可以去掉log），这就可以完成这题了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1410;
int n,m,a,b,c,d,v[MAXN][MAXN],sum[MAXN][MAXN];
int p[MAXN][MAXN],minr[MAXN][MAXN],minc[MAXN][MAXN],f[MAXN][12],l[MAXN],ans;
int calca (int i,int j) {
	return sum[i+a-1][j+b-1]+sum[i-1][j-1]-sum[i-1][j+b-1]-sum[i+a-1][j-1];
}
int calcc (int i,int j) {
	return sum[i+c-1][j+d-1]+sum[i-1][j-1]-sum[i-1][j+d-1]-sum[i+c-1][j-1];
}
int main () {
	memset(f,0x3f,sizeof(f));
	scanf("%d%d%d%d%d%d",&n,&m,&a,&b,&c,&d);
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			scanf("%d",&v[i][j]);
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+v[i][j];
		}
	}
	l[0]=-1;
	for (int i=1;i<=max(n,m);i++) {
		l[i]=l[i/2]+1;
	}
	for (int i=2;i<=n-c;i++) {
		memset(f,0x3f,sizeof(f));
		for (int j=2;j<=m-d;j++) {
			f[j][0]=calcc(i,j);
		}
		for (int k=1;k<=l[m];k++) {
			for (int j=2;j+(1<<k)-1<=m-d;j++) {
				f[j][k]=min(f[j][k-1],f[j+(1<<(k-1))][k-1]);
			}
		}
		for (int j=2;j<=m-d;j++) {
			int k=l[b-d-1];
			minr[i][j]=min(f[j][k],f[j+b-d-1-(1<<k)][k]);
		}
	}
	for (int j=2;j<=m-d;j++) {
		memset(f,0x3f,sizeof(f));
		for (int i=2;i<=n-c;i++) {
			f[i][0]=minr[i][j];
		}
		for (int k=1;k<=l[n];k++) {
			for (int i=2;i+(1<<k)-1<=n-c;i++) {
				f[i][k]=min(f[i][k-1],f[i+(1<<(k-1))][k-1]);
			}
		}
		for (int i=2;i<=n-c;i++) {
			int k=l[a-c-1];
			minc[i][j]=min(f[i][k],f[i+a-c-1-(1<<k)][k]);
		}
	}
	for (int i=1;i<=n-a+1;i++) {
		for (int j=1;j<=m-b+1;j++) {
			ans=max(ans,calca(i,j)-minc[i+1][j+1]);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：zhyh (赞：5)

~~没想到能写得动紫题。~~

（如果花坛只是一个格子，那么只要枚举一维，对另一维维护单调队列即可；既然是矩形，不妨利用前缀和把它变为一个格子）：

这里用$a[i][j]$表示前缀和，用$b[i][j]$(花坛)和$c[i][j]$(绿化带)分别表示以$(i,j)$为左上角的$C*D$和$A*B$的矩形和，用$d[i][j]$表示$(i,j)$左上角、范围$C*B$内所有$b$(花坛)的最小值；至于求$d$，我们可以枚举$i$，每次对$j$维护一个$b[i][j]$值单调递增且长度不超过$B$的队列。

然后枚举$j$，每次对$i$维护一个$d[i][j]$值单调递增且长度不超过$A$的队列，不断用当前$(c[i][j]-$队头$d[>i][j])$更新答案即可。

另外注意花坛不能与绿化带重边，细节见代码：

```cpp
#include <cstdio>
using namespace std;
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define rep(t,l,r) for(int t=l;t<=r;t++)
#define maxd 1005
int M,N,A,B,C,D,ans;
int a[maxd][maxd],b[maxd][maxd],c[maxd][maxd],d[maxd][maxd],mn[maxd];

int main()
{
	scanf("%d%d%d%d%d%d", &M, &N, &A, &B, &C, &D);
	rep(i,1,M) rep(j,1,N){
		scanf("%d",&a[i][j]);
		a[i][j] = a[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];
	}
	rep(i,1,M-C+1) rep(j,1,N-D+1)
		b[i][j] = a[i+C-1][j+D-1] - a[i+C-1][j-1] - a[i-1][j+D-1] + a[i-1][j-1];
	rep(i,1,M-A+1) rep(j,1,N-B+1)
		c[i][j] = a[i+A-1][j+B-1] - a[i+A-1][j-1] - a[i-1][j+B-1] + a[i-1][j-1];
	rep(i,2,M-C){	int h=1, t=0;
		rep(j,2,N-D){
			while(h <= t && b[i][j] <= b[i][mn[t]]) t--;
			mn[++t] = j; if(j+D >= B) d[i][j+D-B+1] = b[i][mn[h]];
			h += (mn[h]+B-1 <= j+D)? 1: 0;
		}
	}
	rep(j,1,N-B+1){	int h=1, t=0;
		rep(i,2,M-C){
			while(h <= t && d[i][j] <= d[mn[t]][j]) t--;
			mn[++t] = i; if(i+C >= A) ans = max(ans, c[i+C-A+1][j] - d[mn[h]][j]);
			h += (mn[h]+A-2 <= i+C)? 1: 0;
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：ljk123 (赞：1)

# 修筑绿化带题解

我的做法实际上神奇且麻烦，大家看之前请做好心理准备。

这是一个单调队列优化DP题（~~废话~~）。

我的大概做法是：

将每个c乘d的矩形化成一个点，将从a乘b的矩形中选一个c乘d的矩形转化为：在(a-c+1)*(b-d+1)的矩形中选一个值最小的点。

具体做法如下：

1.求出二维前缀和p，再求出以一个点为左上角的c乘d的矩形的值之和a。

2.求出每一以某点开始的长度为a-c+1的列的最小值sum。

3.剩下的就是在n-a+1行上，

每一行求出长度为b-d+1的sum最小值

(实际上就是每个a乘b的矩形中c乘d矩形的最小值)，

ans跟a乘b矩形权值和-最小值取max即可。

具体看代码吧：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1006;
int n,m,t1,t2,t3,t4,t,head=1,tail=0,p[N][N],a[N][N],sum[N][N],q[N],ans=-1;
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar(); 
   return F*T; 
}
int main(){
    n=read(),m=read(),t1=read(),t2=read(),t3=read(),t4=read();
    for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) p[i][j]=read(),p[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+p[i][j];
    for(int i=1;i<=n-t3+1;++i) for(int j=1;j<=m-t4+1;++j) a[i][j]=p[i+t3-1][j+t4-1]-p[i+t3-1][j-1]+p[i-1][j-1]-p[i-1][j+t4-1];
    for(int i=1;i<=m-t4+1;++i){
        tail=0,head=1;
        for(int j=2;j<=t1-t3;++j){
            while(tail&&a[q[tail]][i]>=a[j][i]) --tail;
            q[++tail]=j;
        }
        for(int j=1;j<=n-t1+1;++j){ 
            sum[j][i]=a[q[head]][i];
            while(q[head]<=j+1&&head<=tail) ++head;
            while(tail>=head&&a[q[tail]][i]>=a[j+t1-t3][i]) --tail;
            q[++tail]=j+t1-t3;
        } 
    }
    for(int i=1;i<=n-t1+1;++i){
        head=1,tail=0;
        for(int j=2;j<=t2-t4;++j){
            while(tail&&sum[i][q[tail]]>=sum[i][j]) --tail;
            q[++tail]=j;
        }
        for(int j=1;j<=m-t2+1;++j){ 
            ans=max(ans,p[i-1][j-1]-p[i-1][j+t2-1]+p[i+t1-1][j+t2-1]-p[i+t1-1][j-1]-sum[i][q[head]]);
            while(q[head]<=j+1&&head<=tail) ++head;
            while(tail>=head&&sum[i][q[tail]]>=sum[i][j+t2-t4]) --tail;
            q[++tail]=j+t2-t4;
        } 
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：FlyInTheSky (赞：0)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/Luogu2219/)

------------

题意：在$n \times m$的矩阵中找出一块$a \times b$的矩形，在这个矩形中找出一块$c \times d$的矩形(必须在内部)，得分为$a \times b$的矩形分数减去$c \times d$的矩形，求分数最大的$a \times b$的矩形，输出分数。

细节题

这题感觉类似[Bzoj 1047](/bzoj1047)，问法类似，并且都是压缩了一段区间然后边成序列问题。

这题可以考虑枚举每个$a \times b$的矩形，然后每次在矩形中找出一块分数最小的$c \times d$的矩形(注意必须在内部)，然后减掉即可。

1、 先预处理$n \times m$的矩阵的二维前缀和

2、 然后预处理每个$\{(x,y) | x+c \leq m, y+d \leq n \}$为左上角的$c \times d$的矩形的分值和记为$S(x,y)$

3、 对于每个$\{(x,y) | x+c \leq m, y+d \leq n\}$，记录
$$C(x,y)=\min\limits_{1 \leq i \leq a - 2 -c +1}\{S(x+i-1,y)\}$$

这个相当于把这个$a \times b$的矩形的一列决策点都压缩成一个元素

4、对于每行$\{x | x+a-1 \leq m\}$, 每列$\{y|y \geq 2, y+d-1\leq n\}$，单调队列记录

$$\min\limits_{y \in [y-(b - 2 - d + 1 + 1), y]}\{C(x+1,k)\}$$

然后得到了最小值，按上面方法计算即可

( 范围什么的还是自己算算吧，太杂乱了可能上面的公式会有错误

---

## 作者：joe19025 (赞：0)

## Solution

### 前记

一开始没看懂题意，以为要自己求A，B，C，D。想了半天，结果打开题解一看读入，如梦初醒，然后就轻松肝出来了。

### 转化

我们现在把题意换种说法，相当于让求每一个A*B的矩阵里最小的CxD的子矩阵和，看起来不太好求，但我们其实可以把矩阵和转化为一个数，新开一个数组记录以当前点为右下角的CxD矩阵和。

求法，二维前缀和，容斥，在此不赘述了。

### 实现

1. 通过二维前缀和维护出每个右下角矩阵和。
2. 两次单调队列，一横一竖，跑出每个右下角AxB矩阵里，最小的那个子矩阵和。
3. 最后遍历一遍每个右下角，用这个矩阵的面积-最小子矩阵面积，取max即可。

### 注意

包含关系，要求至少有1个格的边框，实现一些细节不多说了，不然样例都过不了。

## Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;

int val[1005][1005],f[1005][1005],g[1005][1005];
int M,N,A,B,C,D;
int cal1(int x,int y)
{
    return val[x][y]-val[x-C][y]-val[x][y-D]+val[x-C][y-D];
}

int cal2(int x,int y)
{
    return val[x][y]-val[x-A][y]-val[x][y-B]+val[x-A][y-B];
}

int main()
{
    scanf("%d%d%d%d%d%d",&M,&N,&A,&B,&C,&D);
    for(int i=1;i<=M;i++)
    {
        for(int j=1;j<=N;j++)
        {
            scanf("%d",&val[i][j]);
            val[i][j]+=val[i-1][j]+val[i][j-1]-val[i-1][j-1];
        }
    }

    int q[1005][2];
    //memset(g,0x3f,sizeof(g));
    //memset(f,0x3f,sizeof(f));
    // printf("\n");
    // for(int i=1;i<=M;i++)
    // {
    //     for(int j=1;j<=N;j++)
    //     {
    //         printf("%d ",val[i][j]);
    //     }
    //     printf("\n");
    // }
    // printf("\n");

    for(int i=C+1;i<M;i++)
    {
        memset(q,0,sizeof(q));
        int head=1,tail=0;
        for(int j=D+1;j<N;j++)
        {
            while(head<=tail && q[head][0]-D<j+2-B)head++;
            while(head<=tail && q[tail][1]>=cal1(i,j))tail--;
            q[++tail][0]=j;
            q[tail][1]=cal1(i,j);
            if(j>=B-1)g[i][j+1]=q[head][1];
        }
    }
    
    // for(int i=1;i<=M;i++)
    // {
    //     for(int j=1;j<=N;j++)
    //     {
    //         printf("%d ",g[i][j]);
    //     }
    //     printf("\n");
    // }
    // printf("\n");

    for(int j=B;j<=N;j++)
    {
        memset(q,0,sizeof(q));
        int head=1,tail=0;
        for(int i=C+1;i<M;i++)
        {
            while(head<=tail && q[head][0]-C<i+2-A)head++;
            while(head<=tail && q[tail][1]>=g[i][j])tail--;
            q[++tail][0]=i;
            q[tail][1]=g[i][j];
            if(i>=A-1)f[i+1][j]=q[head][1];
        }
    }
    int res=0;
    for(int i=A;i<=M;i++)
    {
        for(int j=B;j<=N;j++)
        {
            res=max(res,cal2(i,j)-f[i][j]);
        }
    }
    // for(int i=1;i<=M;i++)
    // {
    //     for(int j=1;j<=N;j++)
    //     {
    //         printf("%d ",f[i][j]);
    //     }
    //     printf("\n");
    // }
    printf("%d",res);
    return 0;
}
```



---

## 作者：mo_om (赞：0)

看到这种问题，首先想到的一定是通过单调队列用两次，分别维护横竖区间信息。

本题的话，可以先将所有的a*b以及c*d的值处理出来。

鉴于是ab中嵌套一个cd矩阵，可以将cd视为（a-2）（b-2）中子矩阵中的最小值，对于每一组cd中的（i，j），可以将他对应到相应的ab中的（i - 1，j - 1），然后将ab的值剪掉最小的cd的值，就是这个ab矩阵的最大值，最后对每个ab矩阵都减一遍，取到的最大值便是答案
代码写的垃圾，见谅，凑合着看


```

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int maxn = 1e3 + 5;

int A[1005][1005];
int sum1[maxn][maxn], sum2[maxn][maxn], sum3[maxn][maxn], sum4[maxn][maxn], cnt[maxn][maxn], C[maxn][maxn];

int main () {
#ifndef ONLINE_JUDGE
    //int start = clock();
    freopen("in.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif
    int m, n, a, b, c, d;
    cin >> n >> m >> a >> b >> c >> d;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> A[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        int now = 0;
        for (int j = 1; j <= m; j++) {
            now += A[i][j];
            if (j >= b) {
                sum1[i][j - b + 1] = now;
                now -= A[i][j - b + 1];
            }
        }
    }
    for (int i = 1; i <= m - b + 1; i++) {
        int now = 0;
        for (int j = 1; j <= n; j++) {
            now += sum1[j][i];
            if (j >= a) {   
                sum2[j - a + 1][i] = now;
                now -= sum1[j - a + 1][i]; 
            }
        }
    }//处理出ab的值

    for (int i = 1; i <= n; i++) {
        int now = 0;
        for (int j = 1; j <= m; j++) {
            now += A[i][j];
            if (j >= d) {
                sum3[i][j - d + 1] = now;
                // cout << sum3[i][j - d + 1] << " ";
                now -= A[i][j - d + 1];
            } 
        }
        // cout << endl;
    }
    // cout << endl;
    for (int j = 1; j <= m - d + 1; j++) {
        int now = 0;
        for (int i = 1; i <= n; i++) {
            now += sum3[i][j];
            if (i >= c) {
                sum4[i - c + 1][j] = now;
                now -= sum3[i - c + 1][j];
                // cout << sum4[i - c + 1][j] << " ";
            }
        }
    }//处理出cd的值
    
    // for (int i = 1; i <= n - c + 1; i++)  {
    //     for (int j = 1; j <= m - d + 1; j++) {
    //         cout << sum4[i][j] << " ";
    //     }
    //     cout << endl;
    // }
    // cout << endl;

    int len = b - d - 1;
    for (int i = 2; i <= n - c; i++) {
        int l = 1, r = 0;
        int h[maxn];
        for (int j = 2; j <= m - d; j++) {
            while (r >= l && sum4[i][h[r]] >= sum4[i][j]) r--;
            h[++r] = j;
            while (h[l] <= j - len) ++l;
            if (j >= len + 1) {
                // cout << l << " " << r << endl;
                // cout << h[l] << endl;
                cnt[i - 1][j - len] = sum4[i][h[l]];
            }
        }
        // cout << endl;
    }//处理出ab中的cd横行中的最小值
    // for (int i = 1; i < n - c; i++) {
    //     for (int j = 1; j <= m - d - len; j++) {
    //         cout << cnt[i][j] << " ";
    //     }
    //     cout << endl;
    // }

    int len2 = a - c - 1;
    for (int j = 1; j <= m - d - len; j++) {
        int l = 1, r = 0;
        int h[maxn];
        for (int i = 1; i <= n - c; i++) {
            while (r >= l && cnt[i][j] <= cnt[h[r]][j]) r--;
            h[++r] = i;
            while (h[l] <= i - len2) ++l;
            if (i >= len2) {
                C[i - len2 + 1][j] = cnt[h[l]][j]; 
                // cout << cnt[i - len2][j] << " ";
            }
            // cout << endl;

        }
    }//合并横行以及竖行的最小值

    int ans = 0;

    for (int i = 1; i <= n - a + 1; i++) {
        for (int j = 1; j <= m - b + 1; j++) {
            ans = max(ans, sum2[i][j] - C[i][j]);
        }
    }
    cout << ans << endl;

    //cout << clock() - start;
    return 0;
}
```

---


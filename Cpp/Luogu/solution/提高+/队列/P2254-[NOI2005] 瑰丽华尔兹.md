# [NOI2005] 瑰丽华尔兹

## 题目背景

你跳过华尔兹吗？当音乐响起，当你随着旋律滑动舞步，是不是有一种漫步仙境的惬意？

众所周知，跳华尔兹时，最重要的是有好的音乐。但是很少有几个人知道，世界上最伟大的钢琴家一生都漂泊在大海上，他的名字叫丹尼・布德曼・T.D.・柠檬・1900，朋友们都叫他 1900。

1900 在 20 世纪的第一年出生在往返于欧美的邮轮弗吉尼亚号上。很不幸，他刚出生就被抛弃，成了孤儿。1900 孤独的成长在弗吉尼亚号上，从未离开过这个摇晃的世界。也许是对他命运的补偿，上帝派可爱的小天使艾米丽照顾他。可能是天使的点化，1900 拥有不可思议的钢琴天赋：从未有人教，从没看过乐谱，但他却能凭着自己的感觉弹出最沁人心脾的旋律。当 1900 的音乐获得邮轮上所有人的欢迎时，他才 8 岁，而此时，他已经乘着海轮往返欧美大陆 50 余次了。

虽说是钢琴奇才，但 1900 还是个孩子，他有着和一般男孩一样的好奇和调皮，只不过更多一层浪漫的色彩罢了：这是一个风雨交加的夜晚，海风卷起层层巨浪拍打着弗吉尼亚号，邮轮随着巨浪剧烈的摇摆。船上的新萨克斯手迈克斯・托尼晕船了，1900 招呼托尼和他一起坐到舞厅里的钢琴上，然后松开了固定钢琴的闸，于是，钢琴随着海轮的倾斜滑动起来。准确的说，我们的主角 1900…


## 题目描述

不妨认为舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。

艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。


## 说明/提示

钢琴的滑行路线：

 ![](https://cdn.luogu.com.cn/upload/pic/1307.png) 

钢琴在“×”位置上时天使使用一次魔法，因此滑动总长度为 $6$。

【数据范围】

$50\%$ 的数据中，$1\leq N, M\leq 200，T\leq 200$；

$100\%$ 的数据中，$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。


## 样例 #1

### 输入

```
4 5 4 1 3
..xx.
.....
...x.
.....
1 3 4
4 5 1
6 7 3```

### 输出

```
6```

# 题解

## 作者：18811162081lyh (赞：112)

```
/*首先考虑对于时间t来dp：
f[t][i][j]表示在第t时刻在第i行第j列所能获得的最长距离。 
转移方程：f[t][i][j]=max(f[t-1][i][j],f[t][i*][j*]+1)(i*,j*为上一个合理的位置) 
这样时间复杂度为O(TNM)，可以过50%,但对于100%TLE且MLE。
所以必须优化，首先把时间t换成区间k，
令f[k][i][j]表示在第k段滑行区间中在位置i，j所能获得最长距离
注意到在第k段时间内只能向某个方向最多走x步（x为区间长度），得到转移方程
f[k][i][j]=max(f[k-1][i][j],f[k][i*][j*]+dis(i,j,i*,j*))(i*,j*为上一个合理的位置)
这个做法的时间复杂度是O(kn^3)，会超时，需要进一步优化
用单调队列优化掉内层的一个n，就可以做到O(kn^2)，可以AC，本代码中还使用了滚动数组优化 
用单调递减队列求最大值时，遇到障碍清空整个队列即可，另外队列比较时需要加上偏移量dis*/
#include<cstdio>
#include<cstring>
#include<iostream>
#define MAXN 205
using namespace std;
int n, m, sx, sy, K, ans, dp[MAXN][MAXN];
int dx[5] = {0, -1, 1, 0, 0}, dy[5] = {0, 0, 0, -1, 1}; 
struct node{int dp, pos;}q[MAXN]; //q为单调递减队列，要存位置信息用来计算共走了几步 
char map[MAXN][MAXN];
void work(int x, int y, int len, int d) //第k个区间的时长为len，方向为d，起点坐标x,y 
{
	int head = 1, tail = 0;
	for(int i = 1; x >= 1 && x <= n && y >= 1 && y <= m; i++, x += dx[d], y += dy[d])
		if(map[x][y] == 'x') head = 1, tail = 0; //遇到障碍，清空队列 
		else
		{
			while(head <= tail && q[tail].dp + i - q[tail].pos < dp[x][y]) tail--;
			q[++tail] = node{dp[x][y], i}; //当前值入队列 
			if(q[tail].pos - q[head].pos > len) head++; //队列长度超过len时队首弹出 
			dp[x][y] = q[head].dp + i - q[head].pos; //最优解是队首元素+移动距离 
			ans = max(ans, dp[x][y]); //记录结果 
		}
}
int main()
{
	scanf("%d%d%d%d%d", &n, &m, &sx, &sy, &K);
	for(int i = 1; i <= n; i++) scanf("%s", map[i] + 1);
	memset(dp, 0xf3, sizeof(dp));
	dp[sx][sy] = 0; //初始化，只有初始位置是0，其他都是负无穷 
	for(int k = 1, s, t, d, len; k <= K; k++)
	{
		scanf("%d%d%d", &s, &t, &d);
		len = t - s + 1;
		if(d == 1) for(int i = 1; i <= m; i++) work(n, i, len, d);
		if(d == 2) for(int i = 1; i <= m; i++) work(1, i, len, d);
		if(d == 3) for(int i = 1; i <= n; i++) work(i, m, len, d);
		if(d == 4) for(int i = 1; i <= n; i++) work(i, 1, len, d);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：FriedrichC (赞：61)

# P2254 [NOI2005] 瑰丽华尔兹 题解
[题目传送门](https://www.luogu.com.cn/problem/P2254)
## 题目背景
$$\text{-麻烦把琴刹关了。}$$
$$\footnotesize\text{-Take the brakes off,please.}$$
$$\text{-什么？你疯了？}$$
$$\footnotesize\text{-What? That's crazy!}$$
$$\text{-相信我，把琴刹关了。}$$
$$\footnotesize\text{-Trust me,Just take the brakes off.}$$
$$......$$
## 题目分析
首先设计状态，先考虑设 $f(t,i,j)$ 表示 $t$ 时刻，在第 $i$ 行第 $j$ 列的位置走过的最长路径长。状态转移方程为 $f(t,i,j)=\max(f(t-1,i,j),f(t-1,i^\prime,j^\prime))$。

其中 $i^\prime$ 和 $j^\prime$为上一个合法的转移位置，即与当前位置同行或同列（取决于方向）的非家具位置。

显然这样做复杂度为 $O(TNM)$，必然超时。

考虑优化这个状态，设 $f(k,i,j)$ 表示在第 $k$ 时间段之中，在位置 $(i,j)$ 的最长路径长。

表面上看，这个状态的复杂度并没有什么优化。

因为哪怕在第一维之中用时间段代替时刻，我们并不会因此而少维护状态，因为在每个时间段细分出的**每个时刻**仍然需要维护。

这样看来复杂度为 $O(KN^2M)$。与我们先前的做法别无二致。

但是，如果我们把状态转移方程写出来：

$f(k,i,j)=\max\{f(k-1,i^\prime,j^\prime)+distance\}$

下文将会说明，正因为这样设计状态，我们才得以优化。

这是很粗略的状态转移方程，因为我们还没有解决两个问题：上一个合法位置的确定和当前位置与其之间的距离（即 $distance$）。

那么，我们改如何优化这一转移呢？

## 转移优化
首先，上文已经提到了，上一个合法位置与当前的位置同行或同列，并具体取决于方向。

那么以当前时间段方向向南为例，设当前时间段长度为 $len$，我们有：

$f(k,i,j)=\max\limits_{i-len\leqslant pos\leqslant i}\{f(k-1,pos,j)+i-pos\}$

先要强调一点，$(i,j)$ 位置的含义是**第 $i$ 行第 $j$ 列**，这意味着，如果我们要在类似样例图示的那种表格上建立一个坐标系，那么原点在**左上角**，y轴以**向下**为**正方向**。

所以仔细看方程中 $pos$ 的范围，如果向南（也就是向下）移动，当前状态肯定是从上方状态转移过来，但是，由于正方向向下，上方点的 $i$ 坐标是**更小**的值，而不是更大的值（这样就是以右下角为原点）。

我们之所以这样设计坐标是因为这样与**数组的下标表示**就吻合了，以便于我们使用数组和循环变量。

接下来对方程进行分析，

首先，从方程中我们可以看出，上文中的 $distance$ 就只是区间中**连续**的位移增量，很好求解。

其次，由于方程之中当前位置确定，$i$ 为定值，可以写成：

$f(k,i,j)=\max\limits_{i-len\leqslant pos\leqslant i}\{f(k-1,pos,j)-pos\}+i$

那么，关键的优化就在于求最大值的优化：

我们发现，方程中只有一个变量 $pos$，观察其取值范围，我们对于每个当前位置，可以由之转移的位置处在一段长度**固定**为 $len$ 的**连续**区间之中。

这不就变成维护**定长区间最值**的问题，也就是**滑动窗口**的问题吗？

显然可以使用**单调队列**优化，那么原先维护区间最值的最坏 $O(N)$ 复杂度均摊为 $O(1)$，整体复杂度优化至 $O(KNM)$，可以接受了。

至于空间复杂度，就可以用**滚动数组**优化。
## 附上代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 210
#define INF INT_MAX //用LLONG_MAX会导致减法溢出 
#define upd ans=max(ans,f[p][i][j])
#define chk if(a[i][j]=='x'){l=1;r=0;continue;}//遇到非法位置，直接清空队列
using namespace std;
int q[maxn],l=1,r;
char a[maxn][maxn];
int f[2][maxn][maxn];
int ans,p;
int n,m,x,y,k;
signed main()
{
	cin>>n>>m>>x>>y>>k;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)cin>>a[i][j];
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			f[p][i][j]=-INF;
	f[p][x][y]=0;
	while(k--)
	{
		p^=1;//滚动数组
		int s,t,d;
		cin>>s>>t>>d;
		int len=t-s+1;
		if(d==1)
			for(int j=1;j<=m;++j)
			{
				l=1; r=0;//每次队列清空
				for(int i=n;i>=1;--i)
				{
					chk;
					while(l<=r&&f[p^1][q[r]][j]+q[r]<=f[p^1][i][j]+i)r--;
					while(l<=r&&q[l]-i>len)l++;
					q[++r]=i;
					f[p][i][j]=f[p^1][q[l]][j]+q[l]-i;
					upd;
				}
			}
		else if(d==2)
			for(int j=1;j<=m;++j)
			{
				l=1; r=0;
				for(int i=1;i<=n;++i)
				{
					chk;
					while(l<=r&&f[p^1][q[r]][j]-q[r]<=f[p^1][i][j]-i)r--;
					while(l<=r&&i-q[l]>len)l++;
					q[++r]=i;
					f[p][i][j]=f[p^1][q[l]][j]+i-q[l];
					upd;
				}
			}
		else if(d==3)
			for(int i=1;i<=n;++i)
				{
					l=1; r=0;
					for(int j=m;j>=1;--j)
					{
						chk;
						while(l<=r&&f[p^1][i][q[r]]+q[r]<=f[p^1][i][j]+j)r--;
						while(l<=r&&q[l]-j>len)l++;
						q[++r]=j;
						f[p][i][j]=f[p^1][i][q[l]]+q[l]-j;
						upd;
				}
			}	
		else
			for(int i=1;i<=n;++i)
			{
				l=1; r=0;
				for(int j=1;j<=m;++j)
				{
					chk;
					while(l<=r&&f[p^1][i][q[r]]-q[r]<=f[p^1][i][j]-j)r--;
					while(l<=r&&j-q[l]>len)l++;
					q[++r]=j;
					f[p][i][j]=f[p^1][i][q[l]]+j-q[l];
					upd;
				}
			}
	}
	cout<<ans<<endl;
	return 0;
}
```
## 一些细节
在代码实现时，在各个方向上的处理都有些许不同，很容易犯错。

- 在内外层循环变量的确定上：

	对于某一个方向，对于任意一个当前位置，$pos$ 的取值与该方向的**变化维度**在**同一**维度上。

	比如，如果是竖直方向，运动时变化的维度就是 $i$，所以 $pos$ 与 $i$ 在同一维度，那么 $i$ 就在内层循环。

- 在枚举顺序的确定上：

	以向北（向上）为例，内层循环枚举时是从 $n$ 到 $1$ 枚举，因为**向上**恰恰是y轴的**负方向**，所以在运动时 $i$ 坐标会**从大到小**地变化。

	所以枚举顺序要根据坐标轴方向来确定。

- 在弹栈条件的确定上：
	
   是否弹栈，其实就取决于 $distance$ 是否大于 $len$。
   
   但是要注意 $distance$ 的表达式，想清楚谁大谁小，还是以向北（向上）为例：
	
   由于当前状态由下方状态更新而来，而下方点的 $i$ 坐标更大，所以弹栈条件为`q[l]-i>len`。
   
   ~~这么看来全用绝对值函数也不是不行呢。~~
   
最后提一点，初始化所有状态为负无穷，起点除外。

因为本来只能从单点出发运动，由单点递推更新状态，如果其余状态不设置为负无穷，就相当于可以从多个点出发，显然不合逻辑。
## 结语
$\text{陆地上的人们浪费了太多时间去问为什么。}$

$\footnotesize\text{I think you land people waste a lot of time wondering why.}$

$\text{冬天来临时，巴望着夏天，}$

$\footnotesize\text{Winter comes and you can't wait for summer.}$

$\text{夏天到来时，就已经开始害怕冬天。}$

$\footnotesize\text{Summer comes and you live in dread of winter.}$
   
$\text{所以人们永不厌倦旅行，}$

$\footnotesize\text{That's why you never tire of traveling.}$

$\text{总是在追寻，四季如春的远方。}$

$\footnotesize\text{Always chasing someplace far away where it's always summer.}$
   
$\text{——《海上钢琴师》}$






---

## 作者：关怀他人 (赞：26)

## 单调队列优化dp 
**[MyBlog](https://www.luogu.org/blog/LCA/)**

常规的动态规划：
$f(time, x, y) = max\{f(time-1, x, y),f(time-1,x-dx[d],y-dy[d])+1 \}$

其中$d$为 方向，$dx[]$ 是移动时横坐标的变化量，$dy[]$类似

复杂度为 $O(T * M * N)$ ，显然超时

**注意：此处 $x$ 为二维坐标系中的横坐标相当于二维数组中的列号。~~(我因为这个调了很久)~~**

可以想到一种优化是按照时间段进行动态规划，但复杂度仍然很大。

但注意到一个时间段内只能往一个方向移动，于是，可以采用相对的位置，把 x、y简化表示成相对于起始位置的距离，于是可以得到：

$f[j] = max\{ f[i]+j-i \}$，$i<j$，且 $i$ 与 $j$ 同属一个方向

即：
$f[j]-j = max\{f[i]-i\}$

设 $g[x] = f[x]-x$，则：

$g[j] = max\{g[i]\}$，且 $i$、$j$ 要满足 $i<j$，且 $j-i <=$ 时间段长度

不难发现g[]的值可以用**单调队列**维护，实现时可以采用**单调递减队列**，每个队列元素记录两个值：与（本时间段的）起始位置的相对位置的距离值$pos$ $(j - i)$以及$g[i]$，队列中元素 $i$ 的 $pos$ 递增，$g[i]$ 递减。

如果新加入的元素 $k$（满足 $k-j <=$ 当前时间段长度）的 $g$ 值大于队尾元素的 $g$ 值，那么队尾元素就可以删除。
#### [参考程序]

```cpp
/*
Problem : P2254
Algorithm : 单调队列优化dp 
Status : AC
*/
#include <bits/stdc++.h>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;

const int INF = 0x3f3f3f3f;
const int MAXN = 205;
const int dx[] = {0,0,0,-1,1};
const int dy[] = {0,-1,1,0,0};

int n,m,ans,sx,sy,k;
char mp[MAXN][MAXN];
int f[MAXN][MAXN];

struct Period{
	int bgn,end,dir;//每个时段的开始、结束时间及船的方向 
} p[MAXN];		// 记录各时间区间及方向的信息

struct Node{
	int pos,val;
};

deque<Node> q;

void caculate(int x,int y,int dir,int len){//起点、方向、时长窗口区间
	q.clear();
	int idx = 0;
        // idx : 相对于本区间开始位置的、本方向上的位移量
	while(x >= 1 && x <= m && y >= 1 && y <= n){
		if(mp[y][x] == 'x'){ //注意此处和下面的行号列号
		    q.clear();
		}else{
			while(!q.empty() && q.back().val <= f[y][x] - idx)
			    q.pop_back(); // 递减的单调队列
			q.push_back((Node){idx,f[y][x] - idx});
            		// j、pos 都是相对于起始位置的相对位置，一减即得到区间长度
			if(idx - q.front().pos > len) 
			    q.pop_front();// 把队首往后调整至落入当前时长的“窗口区间”内
			f[y][x] = q.front().val + idx;
			ans = max(ans,f[y][x]);
		}
		x += dx[dir];
		y += dy[dir];
		idx++;
        	//改变当前的位置和距离
	}
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d%d%d%d",&n,&m,&sx,&sy,&k);
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= m;j++){
		    cin >> mp[i][j];
		    f[i][j] = -10000;
		}
	}
	for(int i = 1;i <= k;i++)
	    scanf("%d%d%d",&p[i].bgn,&p[i].end,&p[i].dir);
	f[sx][sy] = 0;
	for(int i = 1;i <= k;i++){// 按时段来推
		int len = p[i].end - p[i].bgn + 1;// 当前时间区间的时长
		switch(p[i].dir){		  // 4 个方向
			case 1:
				for(int j = 1;j <= m;j++)
				    caculate(j,n,1,len); //上
				break;
			case 2:
				for(int j = 1;j <= m;j++)
				    caculate(j,1,2,len); //下
				break;
			case 3:
				for(int j = 1;j <= n;j++)
				    caculate(m,j,3,len); //左
				break;
			case 4:
				for(int j = 1;j <= n;j++)
				    caculate(1,j,4,len); //右
				break;
		}
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：_Toz (赞：17)

这道题其实挺简单的。

首先最显然的DP：
f[i][x][y] = max(f[i - 1][x'][y']) + 1;

i表示的是时间点，x和y表示位置，而x'和y'表示上一个合法位置；

当然超时（noi的题怎么可能这么水）

### 再看题目。注意是时间段！

那我们换种表示试试。

f[i][x][y] = max(f[i - 1][x’][y']) + dist(x,y,x',y');

i表示的是第i个时间段结束后，(x,y)这个位置最长的滑行距离。

注意(x,y)与(x',y')必定是在同一列或同一行上的，但不一定相邻。

还是超时。

那么回头再看状态转移方程，发现有要求max，而且求可能拓展的状态有线性关系（在同一列或同一行上）

## 单调队列！

首先按照读入的每个时间段的方向，穷举每个方向的初始点。在单调队列里记录所在列或行某一个节点减去它到这一列或行初始位置的距离。对于每个点，用步数（就是初始点到当前点的距离）加上队首。

打个比方：目前是第2短时间，向下，也就是向南。

f[1][2][2]已经求出来了，是3,并且在队首。
那么队首记录的就是3 - 2 = 1；

那么f[2][3][2] = 1 + 3 = 4；

假设f[1][2][2]还是队首；

那么f[2][4][2] = 1 + 4 = 5;

于是代码就很愉快的敲出来了。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, x, y, k, s1, t1, d1, f[210][210][210], ans, dx[] = {0, -1, 1, 0, 0}, dy[] = {0, 0, 0, -1, 1}, q[100010], pos[100010], head, tail; 
char a[310][310];

void push(int now, int val, int x, int y){
	if (val == -0x7f7f7f7f) return ;//如果走不到这个位置 
	
	while (head <= tail && val - now >= q[tail])
    
	 /*之所以要减去now是因为（x,y）这个位置不一定是在当前方向的起点上 ，所以减去now之后运算就可以方便，因为之后某一步的步数减去当前的步数得到的值就是(x,y)到之后那一步在的点的距离，这里等于化简了一下 */
     
		tail--;//弹出队尾 
		
	q[++tail] = val - now;
	pos[tail] = now;//这里记录位置，判断是不是能滑 
}

void dp(int p, int x, int y, int d, int t){
	
	if (t < 1) return ;//一个特判 
	
	head = 1; tail = 0; 
	int now = 1;
	
	while(x <= n && x > 0 && y <= m && y > 0){
		
		if (a[x][y] == 'x') head = 1, tail = 0;//如果碰到了障碍，之前做的全部失效，队列清空 
		else push(now, f[p - 1][x][y], x, y);
		
		while(head <= tail && now - pos[head] > t)//如果超出了能滑的区间，就可以把队首弹出去了 
			head++;
		
		if (head <= tail) f[p][x][y] = q[head] + now;//加上步数 
		else f[p][x][y] = -0x7f7f7f7f;
		
		ans = max(ans, f[p][x][y]);//记录答案 
		
		x += dx[d];//更新位置 
		y += dy[d];
		
		now++;//步数加1 
	}
}

int main(){
	ios :: sync_with_stdio(false);
	
	cin >> n >> m >> x >> y >> k;
	
	memset(f, 128, sizeof(f));
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			f[0][i][j] = -0x7f7f7f7f;
	
	f[0][x][y] = 0;//起始位置为滑动距离为0 
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
			
	for (int i = 1; i <= k; i++){
		cin >> s1 >> t1 >> d1;
		if (d1 == 1) {
			for (int j = 1; j <= m; j++)
				dp(i, n, j, d1, t1 - s1 + 1);//这里是穷举每个方向的初始位置 
		}
		
		if (d1 == 2) {
			for (int j = 1; j <= m; j++)
				dp(i, 1, j, d1, t1 - s1 + 1);
		}
		
		if (d1 == 3) {
			for (int j = 1; j <= n; j++)
				dp(i, j, m, d1, t1 - s1 + 1);
		}
		
		if (d1 == 4) {
			for (int j = 1; j <= n; j++)
				dp(i, j, 1, d1, t1 - s1 + 1);
		}
	}
	
	cout << ans << endl;//输出答案 
	
	return 0;
}
//2018.2.22

```




---

## 作者：Ireliaღ (赞：11)

~~以钢琴区萌新Up主的身份来发一篇题解~~

模拟赛考了这道题，一开始想的暴搜，传的参数是当前点坐标和第几段区间。后来加了个记忆化，寻思能快一点，结果A了。。。

具体的话，看代码吧。

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <utility>
#include <cstring>

using namespace std;

const int MAXN = 205;
const int MAXK = 205;
const int MAXT = 4e4 + 5;
const int X[] = {0, -1, 1, 0, 0};
const int Y[] = {0, 0, 0, -1, 1};

int n, m, k, xx, yy;
int l[MAXN], r[MAXN], dir[MAXN];
char ch[MAXN][MAXN];
int dp[MAXK][MAXN][MAXN];

int Dfs(int pos, int x, int y) {//搜索
    if (pos > k) return 0;//递归边界
    if (dp[pos][x][y] != -1) return dp[pos][x][y];//记忆化
    int len = r[pos] - l[pos] + 1;//时间段长度
    int nowx = x, nowy = y;
    int ret = Dfs(pos + 1, x, y);//初始化答案，即在该时间段不动
    for (int i = 1; i <= len; i++) {//在时间段内一直往前推
        nowx += X[dir[pos]];
        nowy += Y[dir[pos]];
        if (ch[nowx][nowy] == 'x') break;
        if (nowx > n || nowy > m || nowx < 1 || nowy < 1) break;//判停
        ret = max(ret, i + Dfs(pos + 1, nowx, nowy));
    }
    return dp[pos][x][y] = ret;//更新记忆化
}

int main() {
    memset(dp, -1, sizeof(dp));
    cin >> n >> m >> xx >> yy >> k;
    for (int i = 1; i <= n; i++) {
        cin >> ch[i] + 1;
    }
    for (int i = 1; i <= k; i++) {
        cin >> l[i] >> r[i] >> dir[i];
    }
    cout << Dfs(1, xx, yy) << endl;
    return 0;
}
```

---

## 作者：lhm_ (赞：11)

发现在同一时间段中，滑动的方向具有唯一性，所以不难得出$DP$方程。

$f_{i,j}=max(f_{i,j},f_{i-dx_,j-dy}+dis_{i,j,i-dx_,j-dy})$

$(i,j)$为坐标，$(i-dx_,j-dy)$为可以转移到$(i,j)$的合法坐标，$dis$为计算两个坐标之间移动的距离。

继续考虑滑动的方向具有唯一性这一特点，也就是钢琴只能在行上或列上滑动一个固定的区间范围，不难想到滑动窗口这一模型。于是采用单调队列优化$DP$，每次只从队头转移，也就是每次都是从合法区间中选取了最优的状态转移过来。

时间复杂度为$O(knm)$。

其他细节处理就看代码吧。

$code:$
```cpp
#include<bits/stdc++.h>
#define maxn 310
#define inf 200000000
using namespace std;
template<typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag)x=-x;
}
int n,m,x,y,k,f,r,ans;
char w[maxn][maxn];
int dp[maxn][maxn],dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
struct que
{
    int val,x,y;
}q[maxn];
int dis(int ax,int ay,int bx,int by)
{
    return abs(ax-bx)+abs(ay-by);
}
void work(int x,int y,int len,int d)
{
    f=1,r=0,d--;
    while(1)
    {
        if(x<1||y<1||x>n||y>m) break;
        if(w[x][y]=='x') f=1,r=0;
        else
        {
            while(f<=r&&dp[x][y]>q[r].val+dis(x,y,q[r].x,q[r].y)) r--;
            q[++r]=(que){dp[x][y],x,y};
            while(f<=r&&(abs(x-q[f].x)>len||abs(y-q[f].y)>len)) f++;
            dp[x][y]=max(dp[x][y],q[f].val+dis(x,y,q[f].x,q[f].y));
            ans=max(ans,dp[x][y]);
        }
        x+=dx[d],y+=dy[d];
    }
}
int main()
{
	read(n),read(m),read(x),read(y),read(k);
    for(int i=1;i<=n;++i) scanf("%s",w[i]+1);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            dp[i][j]=-inf;
    dp[x][y]=0;
    for(int i=1;i<=k;++i)
    {
        int s,t,l,d;
        read(s),read(t),read(d),l=t-s+1;
        if(d==1) for(int j=1;j<=m;++j) work(n,j,l,d);
        if(d==2) for(int j=1;j<=m;++j) work(1,j,l,d);
        if(d==3) for(int j=1;j<=n;++j) work(j,m,l,d);
        if(d==4) for(int j=1;j<=n;++j) work(j,1,l,d);
    }
    printf("%d",ans);
	return 0;
}
```


---

## 作者：人殇物已非 (赞：10)

一道DP好题。

由于蒟蒻对优先队列的应用略有不解，故此用一个拿$break$卡时限的方法暴力$DP$解决问题真是（~~舒服~~）惭愧。

咳咳。

我们不妨设$dp$方程为$f[t][i][j]$表示在第$t$时间段在第$i$行第$j$列所能获得的最长距离。

然后暴力枚举当前是哪个$[i,j]$，暴力枚举当前这段滑动的次数t，算出从哪个$[i,j]$来的，然后转移就好了，权值加上$t$.

由于我们可以发现，一旦被挡住（障碍或者边界），那么之后的格子都不可能来到当前格子，所以可以直接$break$，再加上每次枚举的滑动次数本来就不满$maxn$，所以虽然最坏时间是$O(n^4)$但是依然可以过。
### $code:$
```
#include<bits/stdc++.h>
using namespace std;
int f[210][210][210];//第i时间段在j，k格子上的得分， 
int n,m,x,y,K;
int ok[300][300];
int main(){
	cin>>n>>m>>x>>y>>K;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='.') ok[i][j]=1;
		}	
	} 
	memset(f,-0x3f,sizeof(f));
	f[0][x][y]=0;
	for(int k=1;k<=K;k++){
		int step,tmp,op;
		cin>>step;step=-step;
		cin>>tmp;step+=tmp+1;
		cin>>op;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(op==1){
					for(int t=0;t<=step;t++){
                    	if(!ok[i+t][j]) break;
                    	f[k][i][j]=max(f[k][i][j],f[k-1][i+t][j]+t);
					}
				}
                else if(op==2){
                	for(int t=0;t<=step;t++){
						if(!ok[i-t][j]) break;
                    	f[k][i][j]=max(f[k][i][j],f[k-1][i-t][j]+t);
                	}
				}
                else if(op==3){
                	for(int t=0;t<=step;t++){
	                    if(!ok[i][j+t]) break;
	                    f[k][i][j]=max(f[k][i][j],f[k-1][i][j+t]+t);
	                }
				}
                else if(op==4){
                	for(int t=0;t<=step;t++){
	                    if(!ok[i][j-t]) break;
	                    f[k][i][j]=max(f[k][i][j],f[k-1][i][j-t]+t);
	                }
				}
			}
		}
	}
	int ans=-2147483647;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ans=max(ans,f[K][i][j]);
		}
	}
    printf("%d\n",ans);
	return 0;
}
```
优先队列我会补上的。。。




---

## 作者：123456zmy (赞：8)

首先可以想出一个 $O(NMT)$ 的做法，~~据说卡下常能过~~，具体怎么做可以参考其他题解。考虑优化这个做法，大多数题解都用的是单调队列，这里介绍一种另外的方法。
___
我们发现每个区间的操作是相同的，所以可以用倍增的方法，把每个区间拆成 $1,2,4,...$ 的段，这样与一个一个算是等效的，但是每个区间只需要计算 $\log$ 次，与多重背包不同的是这个题目中如果更新的位置和被更新的位置之间有障碍时不能更新。~~貌似比某些大常数的单调队列还快。~~
___
代码（时间：$O(NMK\log(\max(N,M)),463ms$；空间：$O(NM),1.15MB$）。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,T,x,y,dp[201][201],s,t,d,ans;
unsigned char nxt1[201][201],nxt2[201][201],nxt3[201][201],nxt4[201][201],a[201][201];
void abc(int b)//转移
{
	if(d==1)for(int j=1;j<=m;j++)for(int i=1+b;i<=n;i++)if(nxt1[i][j]<i-b)dp[i-b][j]=max(dp[i-b][j],dp[i][j]+b);
	if(d==2)for(int j=1;j<=m;j++)for(int i=n-b;i;i--)if(nxt2[i][j]>i+b)dp[i+b][j]=max(dp[i+b][j],dp[i][j]+b);
	if(d==3)for(int i=1;i<=n;i++)for(int j=1+b;j<=m;j++)if(nxt3[i][j]<j-b)dp[i][j-b]=max(dp[i][j-b],dp[i][j]+b);
	if(d==4)for(int i=1;i<=n;i++)for(int j=m-b;j;j--)if(nxt4[i][j]>j+b)dp[i][j+b]=max(dp[i][j+b],dp[i][j]+b);
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&x,&y,&T);
	memset(nxt2,n+1,sizeof(nxt2));
	memset(nxt4,m+1,sizeof(nxt4));
	memset(dp,-0x3f,sizeof(dp)),dp[x][y]=0;
	for(int i=1;i<=n;i++)scanf("%s",a[i]+1);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(a[i][j]=='x')//处理有障碍的情况
	{
		for(int k=i+1;a[k][j]=='.';k++)nxt1[k][j]=i;nxt1[i][j]=i;
		for(int k=i-1;a[k][j]=='.';k--)nxt2[k][j]=i;nxt2[i][j]=i;
		for(int k=j+1;a[i][k]=='.';k++)nxt3[i][k]=j;nxt3[i][j]=j;
		for(int k=j-1;a[i][k]=='.';k--)nxt4[i][k]=j;nxt4[i][j]=j;
	}
	while(T--)
	{
		scanf("%d%d%d",&s,&t,&d),t-=s-1;
		int t1=1;while(t>t1)abc(t1),t-=t1,t1<<=1;//优化
		abc(t);
	}
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)ans=max(ans,dp[i][j]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：magolor (赞：7)

C++题解一发：

状态f[k][i][j]表示**时间段k结束时**（注意用时间段而不是时间，否则TLE显然，而且本人使用状态是结束时状态），停在[i,j]格子得到的最长滑行长度。暴力会TLE，所以单调队列优化，毕竟转移是有序的。单调队列优化DP不太明白的度娘就好。

初始化-INF。

四种状态转移非常麻烦，可以用一个统一的函数和转移数组来优化，注意处理障碍物的情况。


补充一句：**样例有误：最后一行是6 7 3，3才是向西，2是向南，虽然答案一样，但是完全不对啊**！






```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 200
#define MAXM 200
#define MAXK 200
#define INF 0x3f3f3f3f
#define V(x,y) (f[k-1][x][y]+abs(x-i)+abs(y-j))
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
int f[MAXK+5][MAXN+5][MAXM+5], qx[MAXM+5], qy[MAXM+5], t[MAXK+5], d[MAXK+5], N, M, T, K, a, b;
int x[5] = {0,-1,1,0,0}, y[5] = {0,0,0,-1,1};
bool g[MAXN+5][MAXM+5];
char op[MAXM+5];
void Mono(int i, int j, int k)
{
    for(register int head = 0, tail = 0; i >= 1 && j >= 1 && i <= N && j <= M; i += x[d[k]], j += y[d[k]])
    {
        for(; head<tail && abs(i-qx[head])+abs(j-qy[head])>t[k]; head++);
        for(; head<tail && g[i][j]; tail--);
        for(; head<tail && V(qx[tail-1],qy[tail-1])<V(i,j); tail--);
        if(!g[i][j])
            qx[tail] = i, qy[tail++] = j, f[k][i][j] = V(qx[head],qy[head]); 
    }
    return;
}
int Calc(int ans = -INF)
{
    for(register int k = 1, i, j; k <= K; k++)
        switch(d[k])
        {
            //f[i][j] = f[i+x][j]+x;
            case 1 :for(j = 1; j <= M; j++)    Mono(N,j,k);    break;
            //f[i][j] = f[i-x][j]+x;
            case 2 :for(j = 1; j <= M; j++)    Mono(1,j,k);    break;
            //f[i][j] = f[i][j-x]+x;
            case 3 :for(i = 1; i <= N; i++) Mono(i,M,k);    break;
            //f[i][j] = f[i][j+x]+x;
            case 4 :for(i = 1; i <= N; i++) Mono(i,1,k);    break; 
        }
    for(register int i = 1, j; i <= N; i++)
        for(j = 1; j <= M; j++)
            ans = max(ans,f[K][i][j]);
    return ans;
}
int main()
{
    N = read(), M = read(), a = read(), b = read(), K = read();
    for(register int k = 0, i, j; k <= K; k++)
        for(i = 0; i <= N; i++)
            for(j = 0; j <= M; j++)
                f[k][i][j] = -INF;
    f[0][a][b] = 0, t[0] = 0;
    for(register int i = 1, j; i <= N; i++)
    {
        scanf("%s",op+1);
        for(j = 1; j <= M; j++)
            g[i][j] = (op[j]=='x');
    }
    for(register int k = 1; k <= K; k++)
        a = read(), b = read(), t[k] = b-a+1, d[k] = read();
    printf("%d\n",Calc());
     return 0;
}
```

---

## 作者：elijahqi (赞：5)

安利下蒟蒻的blog qwq(http://www.elijahqi.win/2017/10/29/luogu2254-%e7%91%b0%e4%b8%bd%e5%8d%8e%e5%b0%94%e5%85%b9/)

样例应该有误 凑合看就好  就是方向不太对

其实不需要斜率优化 的暴力也可以过就朴素dp

f[i][j][k]表示k这个时间段我现在在i和j这个位置

然后每次时间段循环为0的时候可以看作我从上一个时间段到这个时间段一直停在这

然后对于每个i，j我都去更新他们能走的方向 最后找个最大值即可 其他的一些细节建议自己想一想 或者看代码的

这版程序常数有点大 只有大牛才能交过 bzoj卡时限交过

暴力dp+大常数

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 220
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}
    return x*f;
}
int dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1};
struct node{
    int d,t;
}data[N];
char map[N][N];bool flag[N][N][2];
int n,m,x,y,kk,f[N][N][2];
int main(){
//    freopen("2254.in","r",stdin);
    scanf("%d%d%d%d%d",&n,&m,&x,&y,&kk);
    for (int i=1;i<=n;++i) scanf("%s",map[i]+1);
    memset(f,0xff,sizeof(f));f[x][y][0]=0;int pre=0,cur=1;flag[x][y][0]=1;
    for (int i=1;i<=kk;++i) {
        int st=read(),ed=read(),d=read();
        data[i].t=ed-st+1;data[i].d=d;
    }
    for (int k=0;k<kk;++k){
        for (int i=1;i<=n;++i){
            for (int j=1;j<=m;++j){
                if (!flag[i][j][pre]) continue;
                if (map[i][j]=='x') continue;
                for (int s=0;s<=data[k+1].t;++s){
                    int nowx=i+s*dx[data[k+1].d],nowy=j+s*dy[data[k+1].d];
                    if (nowx<1||nowx>n||nowy<1||nowy>m) break;if (map[nowx][nowy]=='x')break;
                    flag[nowx][nowy][cur]=1;
                    f[nowx][nowy][cur]=max(f[nowx][nowy][cur],f[i][j][pre]+s);
                }
            }
        }
        for (int i=1;i<=n;++i)
            for (int j=1;j<=m;++j) f[i][j][pre]=-1,flag[i][j][pre]=0;
        pre^=1;cur^=1;
    }int ans=0;
    for (int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            ans=max(ans,f[i][j][pre]);
    printf("%d",ans);
    return 0;
}
```
暴力dp+小常数 主站也可以交过

```cpp
//瑰丽华尔兹
#include <cstdio>
#include <cstring>
int const N=210;
int n,m,x0,y0,K;
char map[N][N];
int fr[N],to[N],d[N];
int f[2][N][N];
int max(int x,int y) {return x>y?x:y;}
int main()
{
    scanf("%d%d%d%d%d\n",&n,&m,&x0,&y0,&K);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++) scanf("%c",&map[i][j]);
        scanf("\n");
    }
    for(int i=1;i<=K;i++) scanf("%d%d%d",&fr[i],&to[i],&d[i]);
    int c=0;
    memset(f[c],-1,sizeof f[c]);
    f[c][x0][y0]=0;
    for(int t=1;t<=K;t++)
    {
        c^=1;
        memset(f[c],-1,sizeof f[c]);
        int dx,dy;
        if(d[t]==1) dx=-1,dy=0;
        if(d[t]==2) dx=1,dy=0;
        if(d[t]==3) dx=0,dy=-1;
        if(d[t]==4) dx=0,dy=1; 
        for(int x=1;x<=n;x++)
            for(int y=1;y<=m;y++)
            {
                if(f[c^1][x][y]==-1) continue;
                for(int k=0;k<=to[t]-fr[t]+1;k++)
                {
                    int i=x+k*dx,j=y+k*dy;
                    if(i<1 || n<i || j<1 || m<j || map[i][j]=='x') break;
                    f[c][i][j]=max(f[c][i][j],f[c^1][x][y]+k);
                }
            }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            ans=max(ans,f[c][i][j]);
    printf("%d",ans);
    return 0;
}
```
下面来说说正解 当然是 单调队列优化的dp了

对于每一行每一列我都做单调队列 维护区间最大值 当队首元素大于我能够接受的长度时退出

循环 对于每个状态 循环整张图 然后从要求的那个方向开始转移 f[i][j]=max f[i][1~j]+距离（单调队列维护）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 220
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=gc();}
    return x*f;
}
struct node{
    int d,t;
}data[N];
struct node1{
    int pos,x;
};
char map[N][N];int n,m,x,y,kk,f[N][N];
node1 q[N];
int main(){
    freopen("bzoj1499.in","r",stdin);
    scanf("%d%d%d%d%d",&n,&m,&x,&y,&kk);
    for (int i=1;i<=n;++i) scanf("%s",map[i]+1);
    for (int i=1;i<=kk;++i) {
        int st=read(),ed=read(),d=read();
        data[i].t=ed-st+1;data[i].d=d;
    }memset(f,0xff,sizeof(f));f[x][y]=0;
    for (int k=1;k<=kk;++k){
        int op=0,cl=0;
        if (data[k].d==1){
            for (int j=1;j<=m;++j){
                q[0].x=f[n][j];q[0].pos=n; op=0,cl=0;
                for (int i=n-1;i>=1;--i){
                    if (map[i][j]=='x') {op=1;cl=0;continue;}
                    while (q[op].pos-i>data[k].t&&op<=cl) ++op;
                    while ((q[cl].x==-1||q[cl].x+q[cl].pos-i<f[i][j])&&op<=cl) cl--;
                    q[++cl].x=f[i][j],q[cl].pos=i; 
                    if (q[op].x!=-1) f[i][j]=q[op].x+q[op].pos-i;
                }
            }
        }
        if (data[k].d==2){
            for (int j=1;j<=m;++j){
                q[0].x=f[1][j];q[0].pos=1; op=0,cl=0;
                for (int i=2;i<=n;++i){
                    if (map[i][j]=='x') {op=1;cl=0;continue;}
                    while (i-q[op].pos>data[k].t&&op<cl) ++op;
                    while ((q[cl].x==-1||q[cl].x+i-q[cl].pos<f[i][j])&&op<=cl) cl--;
                    q[++cl].x=f[i][j],q[cl].pos=i; 
                    if (q[op].x!=-1) f[i][j]=q[op].x+i-q[op].pos;
                }
            }
        }
        if (data[k].d==3){
            for (int i=1;i<=n;++i){
                q[0].x=f[i][m];q[0].pos=m; op=0,cl=0;
                for (int j=m-1;j>=1;--j){
                    if (map[i][j]=='x') {op=1;cl=0;continue;}
                    while (q[op].pos-j>data[k].t&&op<cl) ++op;
                    while ((q[cl].x==-1||q[cl].x+q[cl].pos-j<f[i][j])&&op<=cl) cl--;
                    q[++cl].x=f[i][j],q[cl].pos=j; 
                    if (q[op].x!=-1) f[i][j]=q[op].x+q[op].pos-j;
                }
            }
        }
        if (data[k].d==4){
            for (int i=1;i<=n;++i){
                q[0].x=f[i][1];q[0].pos=1; op=0,cl=1;
                for (int j=2;j<=m;++j){
                    if (map[i][j]=='x') {op=1;cl=0;continue;}
                    while (j-q[op].pos>data[k].t&&op<cl) ++op;
                    while ((q[cl].x==-1||q[cl].x+j-q[cl].pos<f[i][j])&&op<=cl) cl--;
                    q[++cl].x=f[i][j],q[cl].pos=j; 
                    if (q[op].x!=-1) f[i][j]=q[op].x+j-q[op].pos;
                }
            }
        }
        /*for (int i=1;i<=n;++i){
            for (int j=1;j<=m;++j) printf("%d ",f[i][j]);printf("\n");
        }
        printf("%d\nasdfadsf\n",k);*/
    }int ans=0;
   /* for (int i=1;i<=n;++i){
        for (int j=1;j<=m;++j) printf("%d ",f[i][j]);printf("\n");
    }*/
    for (int i=1;i<=n;++i)
        for (int j=1;j<=m;++j) ans=max(ans,f[i][j]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：resftlmuttmotw (赞：4)

## 看到这道题，的标签

[我csdn的博客]
(https://blog.csdn.net/qq_42421714/article/details/84963779)

[我洛谷的博客](https://www.luogu.org/blog/cqj/gui-li-hua-er-zi-dan-diao-dui-lie)
说明啊，它可以用单调队列

易推出
```cpp 
dp[x][y][t] = max(dp[x`][y`][t - 1] + 1,dp[x][y][t]);
```

然后看一下数据范围？？？
n,m≤200，K≤200，T≤40000
`o(n^3)`
显然，TLE
然后老师讲了优化方案
T可以换成K
因为任一区间时间内，都只向一个方向走
。。。
然后就可以得到转移方程
```cpp
dp[x][y][k] = max(dp[x][y][k],dp[x1][ y1][k-1] + Abs(x - x1) + Abs(y - y2));`
x1 y2 表示在x,y的前提下，dp[x1][y1][k - 1] +  Abs(x - x1) + Abs(y - y2))的值最大（在范围内）
'o(n^3)'
等等，时间复杂度貌似没减
```
就是我们的单调队列神奇登场的时候了
` 优化最内层循环`

## 思路
#### 滚动优化
```cpp
dp[x][y][k] 空间复杂度不小
可以发现
dp[x][y][k] 只跟上一次（dp[x][y][k - 1]）有关且满足x,y是单调递增或递减的
滚动优化一下
```
#### 函数优化
```cpp
4个方向

相信没有人会实诚de用4个if一一处理
```
所以我们用一个函数
传进去的 必须要有 限制·对应的哪种方向（用数组存一下向迷宫中的四个方向）·当前起点
#### 单调队列

单调队列中的元素不仅要看它自身的值，还要看。val + 它到当前点的距离（在移动范围内）
哪如何实现了
它到当前点的距离可以
```cpp
Abs(x - q[Index].x) + Abs(y - q[Index].y)
```
放入队列时我是这样搞的
```cpp
while(tail >= head&&dp[x][y] > q[tail].val + M(tail))
				tail--;
```
但我们如何保证循环结束后取出来的就是最大值？（M()宏定义，详见code）
每个元素都是这样放进去的
那么假设队列q={1,2,3}(都是val值)
在枚举点时，每次距离都要加一
1 + 1 = 2
2 + 1 = 3
3 + 1 = 4
q = {1,2,3}
顺序没有**发生改变**
#### 注意
由于滚动优化后了，处理一个点时只能先放入单调队列

再取出当前最大值

还有`X`，是不能走的，遇到就重新清一下队列（把Head = 1,tail = 0）
## code
```cpp
#include <cstdio>
#include <cstring>
#define M(Index) Abs(x - q[Index].x) + Abs(y - q[Index].y)
using namespace std;
const int MAXN = 202;
bool Map[MAXN][MAXN];
int n,m,dp[MAXN][MAXN],ans;
int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
class T
{
	public:
		int val;
		int x,y;
};
template<typename TT>
inline TT Max(TT a,TT b) {if(a > b) return a;return b;}
template<typename TT>
inline TT Abs(TT a) {if(a < 0) return -a;return a;}
inline void Dp(int x,int y,int con,int s)
{
	s--;
	T q[MAXN];
	int head = 1,tail = 0;
	for(;x <= n&&x > 0&&y <= m&&y > 0;x += dir[s][0],y += dir[s][1])
		if(Map[x][y] == 0)
			head = 1,tail = 0;
		else {
		    while(tail >= head&&dp[x][y] > q[tail].val + M(tail))
				tail--;
			tail++;
			q[tail].val = dp[x][y];
			q[tail].x = x;
			q[tail].y = y;
			while(head <= tail&&(Abs(x - q[head].x) > con||Abs(y - q[head].y) > con))
				head++;
            dp[x][y] = Max(dp[x][y],q[head].val + M(head));
            ans = Max(ans,dp[x][y]);
		}
}
int main()
{
    int x,y,k,i,j;
    scanf("%d%d%d%d%d",&n,&m,&x,&y,&k);
    char a;
    for(i = 1;i <= n;i++)
    {
        getchar();
        for(j = 1;j <= m;j++)
        {
            scanf("%c",&a);
            if(a == '.')
                Map[i][j] = 1;
        }
    }
    memset(dp,-0x7f7f7f,sizeof(dp));
    dp[x][y] = 0;
    for(i = 1;i <= k;i++)
    {
        int s,t,d,con;
        scanf("%d%d%d",&s,&t,&d);
        con = t - s + 1;
        if(d == 1) for(j = 1;j <= m;j++) Dp(n,j,con,1);
        if(d == 2) for(j = 1;j <= m;j++) Dp(1,j,con,2);
        if(d == 3) for(j = 1;j <= n;j++) Dp(j,m,con,3);
        if(d == 4) for(j = 1;j <= n;j++) Dp(j,1,con,4);
    }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：suxxsfe (赞：2)

[我的博客](https://www.cnblogs.com/suxxsfe/p/13113500.html)  

https://www.luogu.com.cn/problem/P2254  
https://darkbzoj.tk/problem/1499  

单调队列优化dp  
思路感觉比较简单，但也许是最近降智严重，代码实现的时候还自闭了一会/kk  

![](https://pic.downk.cc/item/5ee44e23c2a9a83be58dac1f.png)  
$N,M\le 200,k\le 200,T\le 40000$  

-------------------  

发现区间个数比较小，可以考虑从 $k$ 开始入手，也就是挨个考虑每个时间区间的情况来转移  
因为每个区间内倾斜方向相同，也就是这段时间内只能往一个方向走或不走  
那么，$[s,t]$ 区间，它能朝着对应的倾斜方向走 $0\sim t-s+1$ 步  

所以设 $f(now,i,j)$ 表示在第 $now$ 个时间区间结束后，以坐标 $(i,j)$ 为终点，最多移动多少个格子  
转移的式子以向上为例，那么 $f(now,i,j)$ 由 $f(now-1,[i-t+s-1,i],j)$ 转移来，其它方向当然也都相似  

$$f(now,i,j)=\max_{k=i-t+s-1}^{i} f(now-1,k,j)+(i-k)$$  

后面的 $i-k$ 就是在本次区间内移动的距离  
一开始脑子傻掉居然直接在代码里写成由 $f(now,[i-t+s-1],j)$ 转移到 $f(now,i,j)$ 。。。。果然还是要把转移方程在纸上好好写一遍在开始写代码  
然后这样做复杂度是 $O(kn^3)$，超时，要用单调队列优化一下  

发现单调队列里的数是一直在变化的（上面说的 $i-k$ 造成的），不方便比较，但是可以比较它们的“相对大小”  
什么意思呢，就是每次往单调队列里放入的数是 $f(now-1,i,j)+wei$，并每次让 $wei$ 减一  
原因：设 $f(now-1,i,j)=f(now-1,i+1,j)+x$，如果都要对一个 $(p,j)$ 来进行转移，那么 $f(now-1,i,j)$ 会比 $f(now-1,i+1,j)$ 转移后的结果多 $x+1$  
当然是因为 $p-i$ 比 $p-(i+1)$ 多一  

所以前面的一个数入队的时候，要比后面的数入队的时候多加一个 $1$  
那么取队列中最大值的时候，也不能直接用队列的值（那只体现了相对的大小），而是用最大值对应的下标（设其为 $ind$）  
则 $f(now,i,j)=f(now-1,ind,j)+(i-ind)$  

所以复杂度就是 $O(kn^2)$ 了  

代码，~~同一函数复制四遍~~，不过感觉这样看起来似乎比通过不同参数调用同一函数来实现舒服，也更好写  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
inline int abs(int x){return x>0?x:-x;}
int head,tail;
int num[205],ind[205];
inline void push(int x,int index,int len){
	while(tail<=head&&num[head]<=x) head--;
	num[++head]=x;ind[head]=index;
	while(tail<=head&&abs(index-ind[tail])>len) tail++;
}
int n,m;
int map[205][205];
int f[205][205][205];
char ss[205];
//up,down 都是把 i 放入队列的 ind
inline void work1(int now,int len){//up
	for(reg int j=1;j<=m;j++){
		tail=0;head=-1;
		f[now][n][j]=std::max(f[now][n][j],f[now-1][n][j]);
		int wei=12345;
		push(f[now-1][n][j]+wei,n,len);wei--;
		for(reg int i=n-1;i;i--){
			if(!map[i][j]){
				tail=0;head=-1;wei--;
				push(-1e9,i,len);
			}
			else{
				push(f[now-1][i][j]+wei,i,len);wei--;
				f[now][i][j]=std::max(f[now][i][j],f[now-1][ind[tail]][j]+abs(i-ind[tail]));
			}
		}
	}
}
inline void work2(int now,int len){//down
	for(reg int j=1;j<=m;j++){
		tail=0;head=-1;
		f[now][1][j]=std::max(f[now][1][j],f[now-1][1][j]);
		int wei=12345;
		push(f[now-1][1][j]+wei,1,len);wei--;
		for(reg int i=2;i<=n;i++){
			if(!map[i][j]){
				tail=0;head=-1;wei--;
				push(-1e9,i,len);
			}
			else{
				push(f[now-1][i][j]+wei,i,len);wei--;
				f[now][i][j]=std::max(f[now][i][j],f[now-1][ind[tail]][j]+abs(i-ind[tail]));
			}
		}
	}
}
//left,right 都是把 j 放入队列的 ind
inline void work3(int now,int len){//left
	for(reg int i=1;i<=n;i++){
		tail=0;head=-1;
		f[now][i][m]=std::max(f[now][i][m],f[now-1][i][m]);
		int wei=12345;
		push(f[now-1][i][m]+wei,m,len);wei--;
		for(reg int j=m-1;j;j--){
			if(!map[i][j]){
				tail=0;head=-1;wei--;
				push(-1e9,j,len);
			}
			else{
				push(f[now-1][i][j]+wei,j,len);wei--;
				f[now][i][j]=std::max(f[now][i][j],f[now-1][i][ind[tail]]+abs(j-ind[tail]));
			}
		}
	}
}
inline void work4(int now,int len){//right
	for(reg int i=1;i<=n;i++){
		tail=0;head=-1;
		f[now][i][1]=std::max(f[now][i][1],f[now-1][i][1]);
		int wei=12345;
		push(f[now-1][i][1]+wei,1,len);wei--;
		for(reg int j=2;j<=m;j++){
			if(!map[i][j]){
				tail=0;head=-1;wei--;
				push(-1e9,j,len);
			}
			else{
				push(f[now-1][i][j]+wei,j,len);wei--;
				f[now][i][j]=std::max(f[now][i][j],f[now-1][i][ind[tail]]+abs(j-ind[tail]));
			}
		}
	}
}
int main(){
	n=read();m=read();int sx=read(),sy=read();
	reg int k=read(),s,t,d;
	for(reg int i=1;i<=n;i++){
		std::scanf("%s",ss+1);
		for(reg int j=1;j<=m;j++) map[i][j]=(ss[j]=='.');
	}
	for(reg int aa=0;aa<=k;aa++)
		for(reg int i=0;i<=n;i++)for(reg int j=0;j<=m;j++) f[aa][i][j]=-1e9;
	f[0][sx][sy]=0;
	for(reg int i=1;i<=k;i++){
		s=read();t=read();d=read();
		if(d==1) work1(i,t-s+1);//up
		else if(d==2) work2(i,t-s+1);//down
		else if(d==3) work3(i,t-s+1);//left
		else work4(i,t-s+1);//right
	}
	int ans=0;
	for(reg int i=1;i<=n;i++)for(reg int j=1;j<=m;j++) ans=std::max(ans,f[k][i][j]);
	std::printf("%d",ans);
	return 0;
}
```

---

## 作者：wick (赞：1)

## 此题单调队列优化dp

由题意原来的转移方程是

```cpp
dp[t][x][y]=max(dp[t][x][y],dp[t-k][x-k][y]+k);//k是移动时间,这是x方向上走(上,下)
```

同理有

```cpp
dp[t][x][y]=max(dp[t][x][y],dp[t-k][x][y-k]+k);//左,右

```
但显然超时,注意到一个时间段内只能往一个方向移动，于是，可以采用相对的位置，可以把 t与t-k简化表示成一段时间.有

```cpp
dp[t][x][y]=for  max(dp[t-1][x1][y1]+x-x1);//x1,y1是合法的,t-1是上一个时间段
```
下面参数分离

```cpp
dp[t][x][y]=for  max(dp[t-1][x1][y1]-x1)+x;//x1,y1是合法的,t-1是上一个时间段
```
还是超时,上面dp[t-1][x1][y1]-x1只有x1一个未知量,且只取最大,还有范围,类似slide window,故用上单调队列


**AC代码如下**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=205;
int n,m,x,y,k;
int dx[]={0,-1,1,0,0};
int dy[]={0,0,0,-1,1};
int dp[2][M][M],cur;
int q[M],v[M];
char mp[M][M];
void dfs(int x,int y,int n,int len,int dir){
	int l=1,r=0;
	for(int i=1;i<=n;i++){//枚举列 
		if(mp[x][y]!='x') {
			int tem=dp[!cur][x][y]+n-i;
			while(r>=l&&tem>v[r]) r--;//轮行单调对列,单调性 
			v[++r]=tem;
			q[r]=i;/在更新前把原来的值放进单调队列里
			while(i-q[l]>len) l++; //如果在给定时间内滑不到，作废,出来
			dp[cur][x][y]=v[l]+i-n;
		} else l=r+1;
		x+=dx[dir];
		y+=dy[dir];
	}
}
int main() {
	memset(dp,-0x7f,sizeof(dp));
	scanf("%d%d%d%d%d",&n,&m,&x,&y,&k);
	for(int i=1;i<=n;i++) scanf("%s",mp[i]+1);
	dp[cur][x][y]=0;
	for(int i=1,l,r,dir;i<=k;i++) {
		scanf("%d%d%d",&l,&r,&dir);cur^=1;
		if(dir==1) for(int j=1;j<=m;j++) dfs(n,j,n,r-l+1,dir);
		if(dir==2) for(int j=1;j<=m;j++) dfs(1,j,n,r-l+1,dir);
		if(dir==3) for(int j=1;j<=n;j++) dfs(j,m,m,r-l+1,dir);
		if(dir==4) for(int j=1;j<=n;j++) dfs(j,1,m,r-l+1,dir);
	}
	int ans=-1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
			ans=max(ans,dp[cur][i][j]);
    printf("%d\n",ans);
	return 0;
}


```



---

## 作者：－｜－ (赞：1)

# $NOI[2005]$瑰丽的华尔兹 解题报告

标签：单调队列优化DP

---

​	设$f[k][i][j]$表示在第 $k$段,位置在$[i,j]$时所能达到段最长距离，那么转移方程就很明显了：
$f[k][i][j]=max\{f[k-1][i][j],f[k][i'][j']+dis(i,i',j,j')\}$(i',j'为上一个合法的位置)
​	可是，看看数据范围：

​	$50$%的数据中，$1≤N,M≤200,T≤200$；

​	$100$%的数据中，$1≤N,M≤200,K≤200,T≤40000$

​    很明显$TLE\&\&MLE$那么，开始优化，滚动数组$\&\&$单调队列分别解决$MLE$和$TLE$。

​    单调队列优化的时候，遇到障碍直接清空即可.

----------

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    #define re register int
    #define il inline
    #define RE register
    #define f(a,b,c) for(register int a=b;a<=c;a++)
    const int N=205,inf=1e9;
    il int read()
    {
        re a=0,b=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')b=-1;c=getchar();}
        while(c>='0'&&c<='9'){a=(a<<3)+(a<<1)+(c^48);c=getchar();}
        return a*b;
    }
    using namespace std;
    int n,m,sx,sy,k,ans=-inf,dp[N][N];
    int xx[5]={0,-1,1,0,0},yy[5]={0,0,0,-1,1}; 
    struct node{int dp,pos;}q[N]; 
    int mp[N][N];
    il void fyy(int x,int y,int len,int d)//第k个区间的时长为len,方向为d,起点坐标[x,y]
    {
       re head=1,tail=0;
       for(re i=1;x>=1&&x<=n&&y>=1&&y<=m;i++,x+=xx[d],y+=yy[d])
           if(!mp[x][y])head=1,tail=0;
           else
           {
               while(head<=tail&&q[tail].dp+i-q[tail].pos<dp[x][y])tail--;//单调递减
               q[++tail]=node{dp[x][y],i};//合法，入队
               if(q[tail].pos-q[head].pos>len)head++;//超出长度，出队
               dp[x][y]=q[head].dp+i-q[head].pos;//转移
               ans=max(ans,dp[x][y]);//更新答案
           }
    }
    int main()
    {
		freopen("1.in","r",stdin);
		n=read(),m=read(),sx=read(),sy=read(),k=read();
        f(i,1,n)
	    {
		   string S;cin>>S;
		   f(j,0,m-1)
			   if(S[j]=='.') mp[i][j+1]=1;
			   else mp[i][j+1]=0;
	    }
        memset(dp,0xf3,sizeof(dp));
        dp[sx][sy]=0;
	    f(j,1,k)
        {
            re l=read(),r=read(),d=read();
            if(d==1) f(i,1,m) fyy(n,i,r-l+1,d);
            if(d==2) f(i,1,m) fyy(1,i,r-l+1,d);
            if(d==3) f(i,1,n) fyy(i,m,r-l+1,d);
            if(d==4) f(i,1,n) fyy(i,1,r-l+1,d);
        }
		cout<<ans<<endl;
        return 0;
    }

}
```

---

## 作者：Genius_Z (赞：1)

考虑$DP$，先考虑一个位置停或不停，停记为$0$，不停记为$1$，显然可以得到

$f[t][i][j][0] = max(f[t][i - op[t][0]][j - op[t][1]][0], f[t][i - op[t][0]][j - op[t][1]][1]) + 1;$

$f[t][i][j][1] = max(f[t][i][j][0], f[t][i][j][1]);$

其中$op[][0]$为$x$方向上移动的方向，$op[][1]$为$y$方向上移动的方向

简化一下即 $f[t][i][j] = max(f[t][i - op[t][0]][j - op[t][1]] + 1, f[t][i][j]);$

此时复杂度为$\Theta(Tn^2)$，可以取得50分

考虑利用连续的$k$优化,枚举走的步数$A$

$f[k][i][j] = max(f[k - 1][i - A * op[k][0]][j - A * op[k][1]]) + A * op[k][0] + A * op[k][1];$
此时复杂度为$\Theta(kN ^ 3)$

注意到此时的方程已经是一个$f[i]=max(f[j])+w$的形式，具有单调性，可以用单调队列优化。消掉$A$那一维，复杂度$\Theta(kN^2)$，已经可以通过此题。

$\large Code :$

```cpp
const int dx[] = { 0,-1,1,0,0 }, dy[] = { 0,0,0,-1,1 };
int s[201], t[201], dir[201], f[201][201], ans, n, m, px, py, K;
bool g[201][201];
deque<pair<int, int>>q;
inl void calc(int x, int y, int len, int op) {
	q.clear();
	for (re A = 1; x >= 1 && x <= n && y >= 1 && y <= m; A++, x += dx[op], y += dy[op]) {
		if (g[x][y]) { q.clear(); continue; }
		while (q.size() && f[x][y] >= q.back().second + A - q.back().first)q.pop_back();
		q.push_back(make_pair(A, f[x][y]));
		while (q.back().first - q.front().first > len)q.pop_front();
		f[x][y] = q.front().second + A - q.front().first;
		ans = max(ans, f[x][y]);
	}
	return;
}
signed main() {
	n = read<int>(), m = read<int>(), px = read<int>(), py = read<int>(), K = read<int>();
	memset(f, ~0x3f, sizeof(f));
	f[px][py] = 0;
	for (re i = 1; i <= n; i++) {
		for (re j = 1; j <= m; j++) {
			char c = getchar();
			while (c != '.'&&c != 'x')c = getchar();
			g[i][j] = (c == 'x');
		}
	}
	for (re i = 1; i <= K; i++) s[i] = read<int>(), t[i] = read<int>(), dir[i] = read<int>();
	for (re k = 1; k <= K; k++) {
		switch (dir[k]) {
		case 1: {
			for (re i = 1; i <= m; i++) calc(n, i, t[k] - s[k] + 1, 1);
			break;
		}
		case 2: {
			for (re i = 1; i <= m; i++) calc(1, i, t[k] - s[k] + 1, 2);
			break;
		}
		case 3: {
			for (re i = 1; i <= n; i++) calc(i, m, t[k] - s[k] + 1, 3);
			break;
		}
		case 4: {
			for (re i = 1; i <= n; i++) calc(i, 1, t[k] - s[k] + 1, 4);
			break;
		}
		}
	}
	writeln(ans);
}
/*f[k][i][j] = max(f[k - 1][i - A * op[k][0]][j - A * op[k][1]]) + A * op[k][0] + A * op[k][1];*/
```



---

## 作者：Sol1 (赞：0)

我们看到这题，显然爆搜过不掉，就可以去考虑DP了。

把所有状态塞进去得到转移方程：

$dp_{i,x,y}$表示在第$i$个时间段，钢琴停在$(x,y)$位置时，滑行的最长距离。

对于$d=1$，$dp_{i,x,y}=\max\limits_{0 \leq k \leq t_i-s_i+1}dp_{i-1,x+k,y}+k$；其余情况类似。

显然，这是一个3D/1D的转移方程，最坏复杂度为$\Theta(200^4)≈\Theta(1.6 \times 10^9)$，显然TLE。

于是，我们应该把转移方程变形为如下形式：

$dp_{i,x,y}=\max \limits_{x \leq k \leq x+t_i-s_i+1}dp_{i-1,k,y}+k-x$

显然，随着$x$的变化，决策区间是单调的，于是可以用单调队列优化。

准确地说，对于$d=1$，我们在转移$dp_{i,x,y}$时，将所有$>x+t_i-s_i+1$的决策出队，用队首决策转移$dp_{i,x,y}$，最后将$x$入队，注意入队的时候要维护一下单调队列。另外要加上特判：如果$(x,y)$为障碍，则直接清空队列，然后去考虑下一个。 

注意处理1和3时要倒着循环，处理2和4时候要正着循环，否则障碍物将很难处理。~~（这一点我亲身经历过~~

最后放上完整转移方程：

对于$d=1$，$dp_{i,x,y}=\max \limits_{x \leq k \leq x+t_i-s_i+1}dp_{i-1,k,y}+k-x$；

对于$d=2$，$dp_{i,x,y}=\max \limits_{x-t_i+s_i-1 \leq k \leq x}dp_{i-1,k,y}+x-k$；

对于$d=3$，$dp_{i,x,y}=\max\limits_{y \leq k \leq y+t_i-s_i+1}dp_{i-1,x,k}+k-y$；

对于$d=4$，$dp_{i,x,y}=\max\limits_{y-t_i+s_i-1 \leq k \leq y}dp_{i-1,x,k}+y-k$。

完整代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;

const int N = 205;
int n, m, x, y, k, obst[N][N], s[N], t[N], d[N], dp[N][N][N];
deque <int> que;

//读入数据
void Read() {
    scanf("%d%d%d%d%d", &n, &m, &x, &y, &k);
    for (int i = 1;i <= n;i++) {
        for (int j = 1;j <= m;j++) {
            char c;
            cin >> c;
            if (c == 'x') {
                obst[i][j] = 1;
            }
        }
    }
    for (int i = 1;i <= k;i++) {
        scanf("%d%d%d", &s[i], &t[i], &d[i]);
    }
}

//核心代码，对每一个时间段执行DP
void Dp(int idx) {
    switch (d[idx]) {//方向分开处理，对于1和2，i为状态；对于3和4，j为状态
        case 1:
            for (int j = 1;j <= m;j++) {
                while (!que.empty()) {
                    que.pop_back();
                }
                for (int i = n;i >= 1;i--) {
                    if (obst[i][j] == 1) {//遇到障碍
                        while (!que.empty()) {
                            que.pop_back();
                        }//清空队列
                        dp[idx][i][j] = 0xcfcfcfcf;
                        continue;//下一个状态
                    }
                    //超出时间段的状态出队
                    while (!que.empty() && que.front() > i + t[idx] - s[idx] + 1) {
                        que.pop_front();
                    }
                    //x入队，维护单调队列
                    while (!que.empty() && dp[idx - 1][i][j]
                         > dp[idx - 1][que.back()][j] + que.back() - i) {
                        que.pop_back();
                    }
                    que.push_back(i);
                    //转移
                    dp[idx][i][j] = 
                    max(dp[idx][i][j], dp[idx - 1][que.front()][j] + que.front() - i);
                }
            }
            break;
        case 2://这些同理
            for (int j = 1;j <= m;j++) {
                while (!que.empty()) {
                    que.pop_back();
                }
                for (int i = 1;i <= n;i++) {
                    if (obst[i][j] == 1) {
                        while (!que.empty()) {
                            que.pop_back();
                        }
                        dp[idx][i][j] = 0xcfcfcfcf;
                        continue;
                    }
                    while (!que.empty() && que.front() < i - t[idx] + s[idx] - 1) {
                        que.pop_front();
                    }
                    while (!que.empty() && dp[idx - 1][i][j] > 
                        dp[idx - 1][que.back()][j] + i - que.back()) {
                        que.pop_back();
                    }
                    que.push_back(i);
                    dp[idx][i][j] = 
                    max(dp[idx][i][j], dp[idx - 1][que.front()][j] + i - que.front());
                }
            }
            break;
        case 3:
            for (int i = 1;i <= n;i++) {
                while (!que.empty()) {
                    que.pop_back();
                }
                for (int j = m;j >= 1;j--) {
                    if (obst[i][j] == 1) {
                        while (!que.empty()) {
                            que.pop_back();
                        }
                        dp[idx][i][j] = 0xcfcfcfcf;
                        continue;
                    }
                    while (!que.empty() && que.front() > j + t[idx] - s[idx] + 1) {
                        que.pop_front();
                    }
                    while (!que.empty() && dp[idx - 1][i][j]
                         > dp[idx - 1][i][que.back()] + que.back() - j) {
                        que.pop_back();	
                    }
                    que.push_back(j);
                    dp[idx][i][j] = 
                    max(dp[idx][i][j], dp[idx - 1][i][que.front()] + que.front() - j);
                }
            }
            break;
        case 4:
            for (int i = 1;i <= n;i++) {
                while (!que.empty()) {
                    que.pop_back();
                }
                for (int j = 1;j <= m;j++) {
                    if (obst[i][j] == 1) {
                        while (!que.empty()) {
                            que.pop_back();
                        }
                        dp[idx][i][j] = 0xcfcfcfcf;
                        continue;
                    }
                    while (!que.empty() && que.front() < j - t[idx] + s[idx] - 1) {
                        que.pop_front();
                    }
                    while (!que.empty() && dp[idx - 1][i][j]
                         > dp[idx - 1][i][que.back()] + j - que.back()) {
                        que.pop_back(); 	
                    }
                    que.push_back(j);
                    dp[idx][i][j] = 
                    max(dp[idx][i][j], dp[idx - 1][i][que.front()] + j - que.front());
                }
            }
            break;
    }
}

void Solve() {
    memset(dp, 0xcf, sizeof(dp));
    dp[0][x][y] = 0;//初始化dp数组，很好理解
    for (int i = 1;i <= k;i++) {
        Dp(i);
    }
    //找到答案
    int ans = 0xcfcfcfcf;
    for (int i = 1;i <= n;i++) {
        for (int j = 1;j <= m;j++) {
            ans = max(ans, dp[k][i][j]);
        }
    }
    printf("%d", ans);
}

int main() {
    Read();
    Solve();
    return 0;
}
```
上述代码的时间复杂度为$\Theta(KNM)≈\Theta(10^7)$，是可以接受的。

如果有什么问题请私信，不看评论qwq

---


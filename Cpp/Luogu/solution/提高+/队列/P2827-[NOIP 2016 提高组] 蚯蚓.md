# [NOIP 2016 提高组] 蚯蚓

## 题目背景

NOIP2016 提高组 D2T2

## 题目描述

本题中，我们将用符号 $\lfloor c \rfloor$ 表示对 $c$ 向下取整，例如：$\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。

蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i\,(i=1,2,\dots,n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 < p < 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）

蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：

- $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；
- $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。

蛐蛐国王当然知道怎么做啦！但是他想考考你……

## 说明/提示

**样例解释 1**

在神刀手到来前：$3$ 只蚯蚓的长度为 $3,3,2$。

$1$ 秒后：一只长度为 $3$ 的蚯蚓被切成了两只长度分别为$1$ 和 $2$ 的蚯蚓，其余蚯蚓的长度增加了 $1$。最终 $4$ 只蚯蚓的长度分别为 $(1,2),4,3$。括号表示这个位置刚刚有一只蚯蚓被切断。

$2$ 秒后：一只长度为 $4$ 的蚯蚓被切成了 $1$ 和 $3$。$5$ 只蚯蚓的长度分别为：$2,3,(1,3),4$。

$3$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$6$ 只蚯蚓的长度分别为：$3,4,2,4,(1,3)$。

$4$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$7$ 只蚯蚓的长度分别为：$4,(1,3),3,5,2,4$。

$5$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$8$ 只蚯蚓的长度分别为：$5,2,4,4,(1,4),3,5$。

$6$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$9$ 只蚯蚓的长度分别为：$(1,4),3,5,5,2,5,4,6$。

$7$ 秒后：一只长度为 $6$ 的蚯蚓被切断。$10$ 只蚯蚓的长度分别为：$2,5,4,6,6,3,6,5,(2,4)$。所以，$7$ 秒内被切断的蚯蚓的长度依次为 $3,4,4,4,5,5,6$。$7$ 秒后，所有蚯蚓长度从大到小排序为 $6,6,6,5,5,4,4,3,2,2$。

**样例解释 2**

这个数据中只有 $t=2$ 与上个数据不同。只需在每行都改为每两个数输出一个数即可。

虽然第一行最后有一个 $6$ 没有被输出，但是第二行仍然要重新从第二个数再开始输出。

**样例解释 3**

这个数据中只有 $t=9$ 与上个数据不同。

注意第一行没有数要输出，但也要输出一个空行。


**数据范围**

![](https://cdn.luogu.com.cn/upload/pic/3458.png)


## 样例 #1

### 输入

```
3 7 1 1 3 1
3 3 2```

### 输出

```
3 4 4 4 5 5 6
6 6 6 5 5 4 4 3 2 2```

## 样例 #2

### 输入

```
3 7 1 1 3 2
3 3 2```

### 输出

```
4 4 5
6 5 4 3 2```

## 样例 #3

### 输入

```
3 7 1 1 3 9
3 3 2```

### 输出

```
//空行
2```

# 题解

## 作者：dbxxx (赞：383)

[您可在我的博客中查看本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p2827.html)

**事实上，本题疑似所有题解和 lyd 蓝书上的证明均有误，本篇题解将给出一个严谨的单调性正确性证明。**

一眼看上去容易想到 $q = 0$ 的 $\mathcal{O}(m \log m)$ 堆做法。

$q >0$ 时，暴力给集合中的元素 $+q$ 显然是不可取的。观察到除了被切开的两个元素不 $+q$ 其余均 $+q$，可以等效地看做：把 $x$ 切为 $\lfloor px\rfloor - q$ 和 $x - \lfloor px\rfloor - q$，然后给所有集合中的元素 $+q$。

那么我们每秒可以不实际给每个元素 $+q$，而是记录整个集合通过全局 $+q$ 产生的偏移量，每次通过给每个数加上这个偏移量得到它的真实数值。发现偏移量 $t$ 秒后就是 $qt$。可以用 $\mathcal{O}(m \log m)$ 较为低效率地解决本题了，总结一下：

循环 $t$ 从 $0$ 到 $m - 1$，表示 $[t, t +1]$ 这一秒（即第 $t +1$ 秒）的操作：

- 取出集合最大值 $x'$，得到其真实值 $x = x' +qt$；
- 切 $x$ 为 $\lfloor px\rfloor$ 和 $x - \lfloor px \rfloor$ 两部分；
- 将 $\lfloor px\rfloor - q -  qt$，$x - \lfloor px\rfloor -  q- qt$ 放回集合（$-q$ 是上面等效的结果，$-qt$ 是要把真实值改为偏移值放回集合）。

---

$\mathcal{O}(m \log m)$ 不够优秀，考虑 $\mathcal{O}(m)$ 的做法，我们还是先考虑 $q = 0$，整个集合是静态的比较好想。

发现我们从大到小取 $x$，切开形成的 $\lfloor px\rfloor$ 显然也是从大到小的（正比例函数和 $\lfloor x \rfloor$ 均单调不降）。那么 $x - \lfloor px\rfloor$ 呢？

严格证明一下。命题：对于 $x_1, x_2 \in \mathbb Z, x_1 \ge x_2, 0< p < 1$，有 $x_1 - \lfloor px_1 \rfloor \ge x_2 - \lfloor px_2 \rfloor$。

证明：$x_1 \ge x_2 \land x_1, x_2 \in \mathbb Z$，因此 $x_1 - x_2 \in \N$。又因为 $0 <p < 1$，所以：
$$
\begin{aligned}x_1 - x_2  &\ge p(x_1 - x_2) \\ x_1 - x_2 + p x_2 & \ge px_1 \\  \lfloor px_2 + (x_1 - x_2) \rfloor & \ge\lfloor px_1 \rfloor \\ \lfloor px_2 \rfloor + (x_1 - x_2) & \ge \lfloor px_1 \rfloor \\ x_1 - \lfloor px_1 \rfloor & \ge x_2 - \lfloor px_2 \rfloor  \end{aligned}
$$
注意这里的证明很容易出现伪证，具体请见 <https://www.luogu.com.cn/paste/c4jthmhz>，这也是几乎所有题解错误的地方，这里不展开了。

因此我们考虑维护 A，B，C 三个队列，初始时队列 A 从大（队头）到小（队尾）保存原始 $n$ 个数字，B 和 C 为空。其中 B 保存每一秒切开形成的 $\lfloor px\rfloor$，C 保存每一秒切开形成的 $x - \lfloor px\rfloor$，具体保存方法就是直接推入 B 或 C 的队尾，根据刚刚的结论，B 和 C 将始终满足单调性，队头大队尾小。所以每次的最大值只有可能是 A，B，C 三个队列中某个队头，取三个队头中的最大值，切开之后分别放入 B 和 C 即可。

考虑 $q \ge 0$，上述结论是否仍成立？

我们假设某一秒，我们切开了一个数 $x_1$，下一秒，我们切开了一个数 $x_2 + q$。$x_2 + q$ 在上一秒时为 $x_2$，因此 $x_1 \ge x_2$。我们的证明目标是 $\lfloor px_1\rfloor+ q \ge \lfloor p(x_2 + q)\rfloor$ 和 $x_1 - \lfloor px_1\rfloor+ q \ge x_2 + q - \lfloor p(x_2 + q)\rfloor$。

对于第一条：$\lfloor px_1\rfloor+ q = \lfloor px_1 + q\rfloor \ge \lfloor px_2 + pq\rfloor = \lfloor p(x_2 + q)\rfloor$。

对于第二条：$x_1 - \lfloor px_1\rfloor+ q \ge x_2 +q - \lfloor px_2\rfloor \ge  x_2 + q - \lfloor p(x_2 +q) \rfloor$。

因此在上述做法的基础上，配合一下 $qt$ 的偏移量即可。

时间复杂度 $\mathcal{O}(m)$。

```cpp
#include <bits/stdc++.h>
inline int read() {
    int x = 0;
    bool f = true;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = false;
    for (; isdigit(ch); ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    return f ? x : (~(x - 1));
}

const int maxn = (int)1e5 + 5;
const int mininf = 0xc0c0c0c0;
int a[maxn];

std :: queue <int> qw[4];
typedef std :: pair <int, int> pii;

int main() {
    int n = read(), m = read(), q = read(), u = read(), v = read(), t = read();
    for (int i = 1; i <= n; ++i)
        a[i] = read();
    std :: sort(a + 1, a + n + 1, std :: greater <int> ());
    for (int i = 1; i <= n; ++i)
        qw[1].push(a[i]);

    for (int i = 0; i < m; ++i) {
        pii p = std :: max({std :: make_pair(qw[1].empty() ? mininf : qw[1].front(), 1),
                            std :: make_pair(qw[2].empty() ? mininf : qw[2].front(), 2),
                            std :: make_pair(qw[3].empty() ? mininf : qw[3].front(), 3)});
        int x = p.first + q * i, j = p.second;
        qw[j].pop();
        
        int b = 1ll * x * u / v, c = x - b;
        qw[2].push(b - q - q * i);
        qw[3].push(c - q - q * i);

        if (i % t == t - 1)
            printf("%d ", x);
    }

    puts("");

    for (int i = 1; i <= n + m; ++i) {
        pii p = std :: max({std :: make_pair(qw[1].empty() ? mininf : qw[1].front(), 1),
                            std :: make_pair(qw[2].empty() ? mininf : qw[2].front(), 2),
                            std :: make_pair(qw[3].empty() ? mininf : qw[3].front(), 3)});
        int x = p.first, j = p.second;
        qw[j].pop();

        if (i % t == 0)
            printf("%d ", x + q * m);
    }

    puts("");
    return 0;
}
```

如果觉得本篇题解写得好，请不要忘记点赞，让这篇具有严谨的正确性证明的题解更多减少对后人的误导，谢谢！

---

## 作者：7KByte (赞：85)

# [P2827【蚯蚓】](https://www.luogu.org/problemnew/show/P2827)
## 题目大意：
- 一共有n只蚯蚓，每只蚯蚓有一个长度，并且蚯蚓会按每年q厘米的速度增长。现在每年选择一只最长的蚯蚓，将其按p的比例切成两半，被切的的蚯蚓这一年不能增长，问每年被切的蚯蚓的长度和m年后所有蚯蚓的长度（据题意只需输出部分结果）

## 题目分析：
- 看到这题首先想到的是使用堆来做（因为，切蚯蚓符合堆的查询极值、插入和删除）。但考虑到数据的范围（1<=n<=10^5,0<=m<=7**10^6），由于使用堆的时间复杂度为O(m*logn)，其结果必然会导致超时，所以只有另辟蹊径。

  
- 再仔细观察，发现每年切最长的一只蚯蚓，说明切过的蚯蚓长度具有单调性，即先切的蚯蚓的左段一定大于等于后切蚯蚓的左段，先切蚯蚓的右段一定大于等于后切蚯蚓的右段。  
### 以下为证明过程：为方便，设两只蚯蚓长度为a，b，切后的长度分别是a1,a2,b1,b2.   
- a>=b
- 所以 a*p>=b*p,a-ap>=b-bp
- 因为切这两只蚯蚓的时候这两只蚯蚓都少增长了q厘米
- 所以可证a1>=b1,a2>=b2
### 因此我们可以想到这题可以使用普通队列来做，使复杂度降至O(m)
- 使用3个队列分别保存没被切过的蚯蚓，被切过的蚯蚓左段，和被切过的蚯蚓右段
#### - 注意因为最开始给的蚯蚓数据并不是按照递减顺序，所以可以选择提前排序或者第一个队列使用优先队列
- 每次取出3个队列中最长的一只蚯蚓，将其切断都分别放入后两个数组，依此类推循环m次即可求出结果
- 还需要考虑蚯蚓的增长长度问题，由于每次除了被切的蚯蚓，其他所有的蚯蚓都在增长，所以只需要再从队列中取元素的时候加上（i-1）*q，放回时减去i*q的长度（**因为被切的蚯蚓这年不增长，所以多减q厘米，具体实现参见程序**）
## 以下为代码部分，附解析：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
queue<ll>a;queue<ll>b;queue<ll>c;//由于提前排序，所以直接使用队列
bool cmp(ll x,ll y){return x>y;}//排序比较函数
int main()
{
    ll n,m,q,u,v,t,x,y;         //变量，保险起见全部开long long
    scanf("%lld%lld%lld%lld%lld%lld",&n,&m,&q,&u,&v,&t);
    ll ne[100005];               //预处理兼排序数组
    for(ll i=1;i<=n;i++)
      {
      	scanf("%lld",&ne[i]);    //输入
	  }
	sort(ne+1,ne+n+1,cmp);      //排序
	for(ll i=1;i<=n;i++)
	  a.push(ne[i]);             //将排序结果全部如队
	for(int i=1;i<=m;i++){
		ll maxn=-2147483647,f;   //-INF
		if(!a.empty())if(a.front()>maxn)maxn=a.front(),f=1;
		if(!b.empty())if(b.front()>maxn)maxn=b.front(),f=2;
		if(!c.empty())if(c.front()>maxn)maxn=c.front(),f=3;//找最大值
		if(f==1)a.pop();else if(f==2)b.pop();else if(f==3)c.pop();
        //个人能力有限，不会使用指针指向STL，所以麻烦一些
		maxn+=(i-1)*q;x=maxn*u/v;y=maxn-x;
        //分别时算最长蚯蚓的真实长度，左段长度和右段长度
		if(!(i%t))cout<<maxn<<" ";b.push(x-i*q);c.push(y-i*q);
        //输出控制；左段入队和右段入队
	}
	cout<<endl;//换行
	ll p=1; //输出控制变量
	while(p){ //这里的p始终为真，循环截止条件再循环内
		ll maxn=-2147483647,f;//初始化
		if(a.empty()&&b.empty()&&c.empty())break;//所有队列为空时退出
		if(!a.empty())if(a.front()>maxn)maxn=a.front(),f=1;
	    if(!b.empty())if(b.front()>maxn)maxn=b.front(),f=2;
	    if(!c.empty())if(c.front()>maxn)maxn=c.front(),f=3;
		if(f==1)a.pop();if(f==2)b.pop();if(f==3)c.pop();//如上
		if(p%t==0)
		  cout<<maxn+(m)*q<<" ";           //输出
		p++;                               //输出控制
	}
	cout<<endl;
	return 0;                             //结束
}
```
# 欢迎各位指出不足

---

## 作者：shadowice1984 (赞：9)

来一发文字证明~


数据范围很大。。。


如果用priority\_queue搞的话肯定是会t的。


所以肯定要想一想优化的思路。


我们发现，对于队列来讲，同加，减是不改变这个队列的大小关系的；


但是呢，切开蚯蚓以及新蚯蚓不加是会改变这个队列的大小关系的。


一种简单的想法是priority\_queue（都说了会t啊喂）。


另一种是把切出来的两条蚯蚓隔离开，发现每次都会切出两种类型的蚯蚓，一种长的和一种短的。（因为是按比例切割）


那么把这两条蚯蚓放到两个队列当中，就能够隔离这两只蚯蚓，从而起到保护主队单调性的作用


问题是要不要用priority\_queue。


我们发现，在队列一和队列二当中，相邻的两个元素总是紧接着放进去的（废话吗不是）


问题来了，这两条蚯蚓来自哪里？


答案是原来所有蚯蚓中第一大和第二大的蚯蚓，显然这两条蚯蚓是这两条蚯蚓同一比例的后代


所以前面的蚯蚓就自然大于后面的蚯蚓，因此就删去了priority\_queue这个操作。


那么我们可以证明，这样处理的三个队列（主队，长蚯蚓队，短蚯蚓队）都是单调的，也就是队头大于等于该队的所有元素。


最后就是，我们不能每次都加上一个q（显然是找t）我们假装这个蚯蚓在取出的一瞬间长大了（i-1）\*q（i为秒数）然后塞回去的时候在减去i\*q即可


（注：必须加上(i-1)\*q,不然向下取整精度会不准）


上代码~


```cpp
#include<stdio.h>
#include<queue>
#include<algorithm>
using namespace std;
int n;int m;int q;int u;int v;int t;
queue <int> q1;queue <int> q2;queue <int> q3;
inline int maxnum()//取最大值的操作
{
int res=-0x3f3f3f3f;int num=0;
if(!q1.empty()&&res<q1.front())res=q1.front(),num=1;
if(!q2.empty()&&res<q2.front())res=q2.front(),num=2;
if(!q3.empty()&&res<q3.front())res=q3.front(),num=3;
if(num==1)q1.pop();
else if(num==2)q2.pop();
else if(num==3)q3.pop();
return res;
}
int a[100000];int now;int j;
int main()
{
scanf("%d%d%d%d%d%d",&n,&m,&q,&u,&v,&t);
for(int i=0;i<n;i++)
{
scanf("%d",&a[i]);
}
sort(a,a+n);
for(int i=n-1;i>=0;i--)//倒着扫！（敲黑板）sort最大值在最后
{
q1.push(a[i]);
}
for(int i=1;i<=m;i++,j+=q)//据说这样可以减少运算，priority_queue想卡常结果失败。。
{
int te=maxnum()+j;
if(i%t==0)printf("%d ",te);
//printf("ais%d bis%d\n",t*u/v-i*q,t-t*u/v-i*q);
int ma=max(1LL*te*u/v-j-q,te-1LL*te*u/v-j-q);q2.push(ma);//大的放q2，小的放q3
int mi=min(1LL*te*u/v-j-q,te-1LL*te*u/v-j-q);q3.push(mi);
}
printf("\n");
for(int i=1;!q1.empty()||!q2.empty()||!q3.empty();i++)
{ 
int res=maxnum();
if(i%t==0)printf("%d ",res+j);
}
return 0;
}
```

---

## 作者：YOUSIKI (赞：9)

蚯蚓可以分为三类——

1. 未被切割过的蚯蚓
2. 上次切割中由$\lfloor xp \rfloor$方式产生
3. 上次切割中由$x - \lfloor xp \rfloor$方式产生

对同为第二类或第三类的蚯蚓有如下的性质——

- 设蚯蚓$A$切割后产生了第二类蚯蚓$A'$。
- 设蚯蚓$B$切割后产生了第二类蚯蚓$B'$。
- $A$和$B$都在世的时候，如果有$A$比$B$长，则$A'$和$B'$都在世时一定有$A'$比$B'$长。

证明：

我们不妨用$A$表示蚯蚓$A$在$0$时刻长度（它那时可能还未产生，但可以通过在世时$t$时刻的长度减去$tq$得到一个无实际意义的长度）。对$B$、$A'$、$B'$同理。注意这个$0$时刻长度可以用来比较蚯蚓之间的相对长短。

不妨设$A$在$t_A$时刻被切割，$B$在$t_B$时刻被切割，则有$t_A\leq t_B$。

$$A'=\lfloor (A+t_Aq)p\rfloor - t_Aq$$

$$B'=\lfloor (B+t_Bq)p\rfloor - t_Bq$$

由$0\leq p\leq 1$易见$A'\geq B'$，得证。

对于同为第三类的蚯蚓，也有类似的性质。

故所有第二类或第三类蚯蚓，其产生时间从早到晚的顺序就是长度从长到短的顺序，可以用队列在$O(m)$内维护。而第一类蚯蚓是有限的，只有初始那$n$条，$O(nlogn)$排序处理即可。

每次要找当前最长的蚯蚓，先分别取出这三类蚯蚓各自的队首（最长），然后比较出全局最长的蚯蚓即可。

总体时间复杂度$O(n\log n+m)$。

``` cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    int n, m, q, u, v, t;
    cin >> n >> m >> q >> u >> v >> t;
    int siz[3] = { n + 1, m + 1, m + 1 };
    int *ptr_b[3], *ptr_e[3];
    for (int i = 0; i < 3; ++i)
        memset(ptr_b[i] = ptr_e[i] = new int[siz[i]], 0xcf, sizeof(int) * siz[i]);
    for (int i = 0; i < n; ++i)
        cin >> *(ptr_e[0]++);
    sort(ptr_b[0], ptr_e[0], greater<int>());
    int *answer = new int[n + m];
    for (int cur = 0; cur < m; ++cur) {
        int k = 0;
        for (int i = 1; i < 3; ++i)
            if (*ptr_b[k] < *ptr_b[i])
                k = i;
        answer[cur] = cur * q + *(ptr_b[k]++);
        int a = (long long)answer[cur] * u / v;
        int b = (long long)answer[cur] - a;
        *(ptr_e[1]++) = a - (cur + 1) * q;
        *(ptr_e[2]++) = b - (cur + 1) * q;
    }
    for (int i = t - 1; i < m; i += t)
        cout << answer[i] << " ";
    cout << endl;
    for (int cur = 0; cur < n + m; ++cur) {
        int k = 0;
        for (int i = 1; i < 3; ++i)
            if (*ptr_b[k] < *ptr_b[i])
                k = i;
        answer[cur] = m * q + *(ptr_b[k]++);
    }
    for (int i = t - 1; i < n + m; i += t)
        cout << answer[i] << " ";
    cout << endl;
    return 0;
}
```

---

## 作者：pipilong2024 (赞：5)

经 [Jayne](https://www.luogu.com.cn/user/36176)（老师，不敢@）和 @[Lyzc0dr](https://www.luogu.com.cn/user/1420422) 的激烈讨论，得出来一种新做法。

___
首先我们明白一个不等式 $x_1-\lfloor px_1 \rfloor \ge x_2 \lfloor px_2 \rfloor$，具体证明过程请看 [dbxxx的TJ](https://www.luogu.com.cn/article/hgnmtohe)。  
根据这个不等式，我们可以考虑维护三个队列，而不必维护一个优先队列，因为三个队列始终保持满足单调性，无需使用优先队列（此处和其他 TJ 相同）。  
然后根据此思路即可拿到所有 $q = 0$ 的分，接下来为了解决 $q > 0$，通常方法都是计个 $tag$，加入队列时把两段都减掉一个 $q$，$tag$ 加上一个 $q$。  
考虑到一条在第 $i$ 时刻加入的长度为 $len$ 蚯蚓，如果在第 $j$ 时刻被拿出来砍，因为它一共经历了 $j - i - 1$ 次切割，一次切割长度加 $q$，所以总长度是 $q \times (j - i - 1) + len$。**可以在常数时间内算出**，不必打 $tag$ 标记，只需多存个加入时间。  
___
那么具体做法请看代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
const int maxn=2e5+10;
int n,m,Q,u,v,t,a[maxn];
queue<pii>q[4];//ABC三个队列
int get_max_len(int time){//取出最长的蚯蚓
	int x=-1e9,y=-1e9,z=-1e9;
	if(!q[1].empty())x=q[1].front().first+Q*(time-1-q[1].front().second);
	if(!q[2].empty())y=q[2].front().first+Q*(time-1-q[2].front().second);
	if(!q[3].empty())z=q[3].front().first+Q*(time-1-q[3].front().second);
	//分别取出三个队列队首
	int idx=1LL,tmp=0LL;//idx表示取出来哪一个队列的队首，tmp表示最大的队首
	if(x>=y && x>=z) tmp=x,idx=1;
	if(y>=x && y>=z) tmp=y,idx=2;
	if(z>=x && z>=y) tmp=z,idx=3;
	//更新tmp和idx
	q[idx].pop();//弹出
	return tmp;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>Q>>u>>v>>t;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);//正序排序（从小到大）
	for(int i=n;i>=1;i--) q[1].push({a[i],0});//倒序加入（从大到小）
	for(int i=1;i<=m;i++){
		int len=get_max_len(i),x,y;
		x=len*u/v,y=len-x;//分段
		if(i%t==0) cout<<len<<" ";//输出
		q[2].push({x,i}),q[3].push({y,i});//同其他TJ，加入B，C两个队列，始终保持单调
	}
	cout<<"\n";//换行
	for(int i=1;;i++){
		if(q[1].empty() && q[2].empty() && q[3].empty()) break;//三个队列都空了就停止
		int tmp=get_max_len(m+1);//继续获取最大的蚯蚓
		if(i%t==0) cout<<tmp<<" ";//输出
	}
	return 0;
}
```

---

## 作者：Log_x (赞：4)

##**【60-85pts】堆**

- 很容易想到用堆来维护所有蚯蚓的长度：

- 针对第一问，我们每次取出最长的那只蚯蚓，将其切割后再次插入堆中

- 针对第二问，我们直接将堆中所有元素按大小顺序取出

- 但这样还有一个问题：如何处理每次取出后，其余蚯蚓的长度都增加$q$？

- 我们另外记一个变量$Add$，表示当前每条蚯蚓（不考虑被切割的）的长度已经增加了多少，每次取出的时候加上$Add$就表示现在的实际长度（当然，插入堆中时还要再减回去）

- 考虑到切割后的蚯蚓不能增加长度，我们把问题转化：直接将这切割出的两只蚯蚓长度都减去$q$再插入堆，就解决了这个问题

- 这样的总复杂度为$O((n + m)log(n + m))$，应该是能通过大部分数据点的

##**Code-1**

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;
const int N = 1e5 + 5, M = 7e6 + 5;
int n, m, q, u, v, t, Add;
double p;

struct BigRt
{
    int g[N + M], l;
    
    inline void Pop()
    {
        g[1] = g[l--];
        int now = 1, nxt = 2, res = g[1];
        while (nxt <= l)
        {
            if (nxt < l && g[nxt | 1] > g[nxt]) nxt |= 1;
            if (res < g[nxt])
             g[now] = g[nxt], nxt = (now = nxt) << 1;
            else break;
        }
        g[now] = res;
    }
    
    inline void Push(const int &res)
    {
        g[++l] = res;
        int now = l, nxt = l >> 1;
        while (nxt)
        {
            if (res > g[nxt])
             g[now] = g[nxt], nxt = (now = nxt) >> 1;
            else break;
        }
        g[now] = res;
    }
}Q;

inline int get()
{
    char ch; int res = 0; bool f = true;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = false; 
     else res = ch - '0';
    while ((ch = getchar()) >= '0' && ch <= '9')
     res = (res << 3) + (res << 1) + ch - '0';
    return f? res : -res;
}

inline void put(int x)
{
    if (x < 0)
     x = -x, putchar('-'); 
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48); 
}

inline bool cmp(const int &x, const int &y) {return x > y;}

int main()
{
    n = get(); m = get(); q = get(); 
    u = get(); v = get(); t = get();
    p = (double)u / v; Q.l = 0;
    for (int i = 1; i <= n; ++i) Q.Push(get());
    for (int i = 1; i <= m; ++i)
    {
        int x = Q.g[1] + Add; Q.Pop(); 
         if (i % t == 0) put(x), putchar(' '); 
        int l = (int)(p * x), r = x - l; 
        Q.Push(l - Add - q); Q.Push(r - Add - q);
        Add += q; 
    }
    putchar('\n');
    for (int i = 1; i <= n + m; ++i)
    { 
        if (i % t == 0) put(Q.g[1] + Add), putchar(' ');
        Q.Pop();    
    }
}
```
##**【100pts】队列**

- 我们会发现蚯蚓的切割具有单调性：一只蚯蚓切割后会分为$\lfloor px \rfloor$和$x - \lfloor px \rfloor$两个部分，对于其中的任意一个部分，在某一时刻切割出的那只蚯蚓必然会比在它之后切割出来的蚯蚓要长

- 我们用反证法对此予以证明：

- 设某一时刻被选出的某只蚯蚓切割前的长度为$a_i$，经过$N$秒后，假设存在一只之前未被切割过的蚯蚓这一秒切割完后长度最大，我们记其$N$秒前的长度为$a_j$，那么$a_i, a_j$必然要满足（我们先只考虑切割出的$\lfloor px \rfloor$那部分蚯蚓，$x - \lfloor px \rfloor$同理）：

- $a_i \times p + N \times q \le (a_j + N \times q) \times p$

- 分配后得到$a_i \times p + N \times q \le a_j \times p + N \times q \times p$

- 又因为$N$秒前长度为$a_i$的蚯蚓被选出，所以那一时刻满足$a_i \ge a_j$，而$p$的取值范围为$0 < p < 1$，所以必然满足

- $a_i \times p + N \times q > a_j \times p + N \times q \times p$

- 与之前的假设矛盾，因此上述情况不可能存在，我们证得蚯蚓的切割具有单调性

- 考虑记录三个队列，分别存储未切割过的蚯蚓和切割成的两只蚯蚓，每次将蚯蚓插入对应的队尾。根据我们上面推论得出的单调性，每次取出三个队头的最大值即可，蚯蚓长度的增加和上述堆做法的处理方式相同，这样的总复杂为$O(n + m)$

##**Code-2**

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;
typedef long long ll;
const int Maxn = 2147483647;
const int N = 1e5 + 5, M = 7e6 + 5;
int n, m, q, u, v, t, Add;
int Q[3][M], qt[3], qw[3]; 

inline int get()
{
    char ch; int res;
    while ((ch = getchar()) < '0' || ch > '9');
    res = ch - '0';
    while ((ch = getchar()) >= '0' && ch <= '9')
     res = (res << 3) + (res << 1) + ch - '0';
    return res;
}

inline void put(int x)
{ 
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48); 
}

inline bool cmp(const int &x, const int &y) {return x > y;}

inline int GetMax()
{
    int res = -Maxn, k;
    for (int i = 0; i < 3; ++i)
     if (qt[i] < qw[i] && res < Q[i][qt[i] + 1])
      res = Q[i][qt[i] + 1], k = i;
    qt[k]++; return res;
}
 
int main()
{
    n = get(); m = get(); q = get(); 
    u = get(); v = get(); t = get();
    for (int i = 1; i <= n; ++i) Q[0][++qw[0]] = get(); 
    sort(Q[0] + 1, Q[0] + qw[0] + 1, cmp);
    for (int i = 1; i <= m; ++i)
    {
        int x = GetMax() + Add;
         if (i % t == 0) put(x), putchar(i + t > m ? '\n' : ' '); 
        int l = (ll)x * u / v, r = x - l; 
        Q[1][++qw[1]] = l - Add - q;
        Q[2][++qw[2]] = r - Add - q; Add += q; 
    }
    if (t > m) putchar('\n');
    int tmp = n + m;
    for (int i = 1; i <= tmp; ++i)
    {
        int x = GetMax() + Add;
         if (i % t == 0) {put(x); if (i + t <= tmp) putchar(' ');}
    }
    return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
有以下结论：$\forall x_1\le x_2 \in \mathbb{Z},\lfloor  px_1 \rfloor \le \lfloor  px_2 \rfloor,x_1 - \lfloor  px_1 \rfloor \le x_2 - \lfloor  px_2 \rfloor$。  
第一个式子很显然，因为 $u_x = px$ 和 $y_u = \lfloor  u \rfloor$ 两个函数都是单调不降的。  
下面来证明第二个式子。令函数 $y_x=x - \lfloor px \rfloor = \lceil x - px \rceil =  \lceil (1 - p)x \rceil $。容易发现 $u_x = (1 - p)x$ 和 $y_u = \lceil u \rceil $ 两个函数也都是单调不降的，所以原函数 $y_x=x - \lfloor px \rfloor $ 单调不降。  
有了这个结论，我们就知道神刀手先切的蚯蚓形成的前一半，一定比后切的蚯蚓形成的前一半要长；先切的蚯蚓形成的后一半，一定比后切的蚯蚓形成的后一半要长。  
所以可以维护三个队列，分别存**初始蚯蚓**、**切出的前半条蚯蚓**、**切出的后半条蚯蚓**。因为入队的顺序和入队的数字大小是负相关，所以三个队列都是单调的。  

对于增加量 $q$，只有两条蚯蚓没长就相当于这两条蚯蚓变短了 $q$。可以维护一个增长量 $add$ 表示所有蚯蚓变长的长度，每次切蚯蚓的时候都把切出的蚯蚓长度减 $q$。  
由于每次切的时候长度都要减 $q$，所以这个变长不影响队列的单调性。  

时间复杂度为 $O(n+m)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int n,m,ad,u,v,t;
int add;
int a[1000003];
queue<int>q[3];

int get(){
	int mxi=-1;
	for(int i=0;i<3;i++)
		if(!q[i].empty()&&(mxi==-1||q[mxi].front()<q[i].front()))mxi=i;
	int t=q[mxi].front();
	q[mxi].pop();
	return t;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>ad>>u>>v>>t;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n,greater<int>());
	for(int i=1;i<=n;i++)q[0].push(a[i]);
	for(int i=1;i<=m;i++){
		int x=get()+add,y;
		if(i%t==0)cout<<x<<' ';
		y=(long double)x*u/v;
		x-=y;
		add+=ad;
		y-=add;
		x-=add;
		q[1].push(x);
		q[2].push(y);
	}
	cout<<'\n';
	for(int i=1;i<=n+m;i++){
		int x=get();
		if(i%t==0)cout<<x+add<<' ';
	}
	return 0;
}
```

---

## 作者：ycy1124 (赞：3)

### 题意
有 $n$ 只蚯蚓，每只蚯蚓初始都有一个长度 $a_i$，每秒要选择一只最长的蚯蚓去切成两段新的蚯蚓，两段的长度比为 $1-p:p$，其余的蚯蚓则会增长 $q$ 厘米。求这 $m$ 秒内每秒切的蚯蚓的长度与最后所有蚯蚓的长度。
### 思路
首先容易想到优先队列，但是如果你做过 [P6033 [NOIP2004 提高组] 合并果子 加强版](https://www.luogu.com.cn/problem/P6033) 那么此题的队列思路也很容易想到。

首先将所有的蚯蚓分为三类，分别存在三个队列里，第一个队列是没被切过的，第二个是被切过并且为占比 $p$ 那一段的，第三类是被切过为占比 $1-p$ 那一类的。对于这三类，我们首先将没被切过的全部从大到小排个序，然后不难发现，每次从一只蚯蚓切成两段蚯蚓，这两段蚯蚓是直接可以放到**对应的队列的队尾**的。证明：首先在他前面的说明在他前面被切也就是原蚯蚓在被切之前是比他长的，并且这些蚯蚓增长的次数也一样，所以后面的一定小于前面的。

于是我们每次从三个队列的队首中取出最大的一个来切。这时，新的问题出现了，假如我们每次去给每只蚯蚓增长 $q$，时间复杂度是错的。此时我们发现，由于只有新增加两只蚯蚓不用加，于是我们可以对这两只蚯蚓单独处理，给他们每个单独减一个 $q$，在用一个变量给所有蚯蚓加一个 $q$，每次取出这只蚯蚓时加上这个量就行了。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long//记得开long long
using namespace std;
int n,m,q,u,v,t;
long double p;
queue<int>a,b,c;
int ww[100005];
inline bool cmp(int x1,int x2){
    return x1>x2;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>q>>u>>v>>t;
    p=(long double)1.000000*u/v;
    for(int i(1);i<=n;i++){
        cin>>ww[i];
    }
    sort(ww+1,ww+n+1,cmp);
    for(int i(1);i<=n;i++){
        a.push(ww[i]);
    }
    for(int i(0);i<m;i++){
        if(!a.empty()&&(b.empty()||a.front()>=b.front())&&(c.empty()||a.front()>=c.front())){
            int w[3];
            w[0]=a.front();
            a.pop();
            w[0]+=i*q;
            w[1]=w[0]*p;
            w[2]=w[0]-w[1];
            b.push(w[1]-i*q-q);
            c.push(w[2]-i*q-q);
            if((i+1)%t==0){
                cout<<w[0]<<' ';
            }
        }
        else if(!b.empty()&&(a.empty()||b.front()>=a.front())&&(c.empty()||b.front()>=c.front())){
            int w[3];
            w[0]=b.front();
            b.pop();
            w[0]+=i*q;//累加他长的长度
            w[1]=w[0]*p;
            w[2]=w[0]-w[1];
            b.push(w[1]-i*q-q);
            c.push(w[2]-i*q-q);
            if((i+1)%t==0){
                cout<<w[0]<<' ';
            }
        }
        else{
            int w[3];
            w[0]=c.front();
            c.pop();
            w[0]+=i*q;
            w[1]=w[0]*p;
            w[2]=w[0]-w[1];
            b.push(w[1]-i*q-q);
            c.push(w[2]-i*q-q);
            if((i+1)%t==0){
                cout<<w[0]<<' ';
            }
        }
    }
    cout<<'\n';
    for(int i(1);i<=n+m;i++){
        if(!a.empty()&&(b.empty()||a.front()>=b.front())&&(c.empty()||a.front()>=c.front())){
            if(i%t==0){
                cout<<a.front()+m*q<<' ';
            }
            a.pop();
        }
        else if(!b.empty()&&(a.empty()||b.front()>=a.front())&&(c.empty()||b.front()>=c.front())){
            if(i%t==0){
                cout<<b.front()+m*q<<' ';
            }
            b.pop();
        }
        else{
            if(i%t==0){
                cout<<c.front()+m*q<<' ';//最后输出时也要累加长得长度
            }
            c.pop();
        }
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/191243436)。

---

## 作者：suzhikz (赞：2)

题意很简单，每次取出最长的砍半，没被选中的会变长。

什么数据结构支持在线插入数，查询最大值呢？显然是堆。

但是发现那个变长很不好处理，除了这个蚯蚓都变长，那我么干脆记个统一的加，每次把最长的那个先砍半在减去总的加即可。

但是这样还是不能过，我们还要观察一些性质，发现每次砍完蚯蚓的长度是有一些规律的，在我们的处理方式下，这玩意是有单调性的！

浅证下。

不妨设开始的最大和次大分别为 $x_1,x_2$，要比较 $\lfloor x_1*p\rfloor+q,\lfloor (x_2+q)\times p\rfloor$ 的大小，有 $\lfloor x_1*p\rfloor+q\ge\lfloor x_1*p\rfloor+\lfloor q*p\rfloor\ge\lfloor (x_1+q)*p\rfloor\ge\lfloor (x_2+q)*p\rfloor$。另一个也同理。所以我们只要开始排个序，后面就可以那个队列比较队头即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,u,v,t,a;
double p;
int d[7000005],b[7000005],c[7000005];
int bs,cs,ds;
int be,ce,de;
bool cmp(int aa,int bb){
  return aa>bb;
}
int sigma;
priority_queue<int>ans;
int main(){
	scanf("%d%d%d%d%d%d",&n,&m,&q,&u,&v,&t);
	p=(double)u/v;
	for(int i=1;i<=n;i++){
		scanf("%d",&b[i]);
	}
	bs=1,cs=1,ds=1;
	be=n,ce=0,de=0;
	sort(b+1,b+1+n,cmp);
	for(int i=1;i<=m;i++){
		int book;
		if(bs>be){
			if(c[cs]>=d[ds])book=c[cs],cs++;
			else book=d[ds],ds++;
		}else if(b[bs]>=c[cs]&&b[bs]>=d[ds])book=b[bs],bs++;
		else if(c[cs]>=d[ds]&&c[cs]>=b[bs])book=c[cs],cs++;
		else book=d[ds],ds++;
	  	book=book+sigma;
		int a1=floor(p*(double)book),a2=book-a1;
		sigma+=q;
		a1=a1-sigma;
		a2=a2-sigma;
		c[++ce]=a1;
		d[++de]=a2;
		if(i%t==0)printf("%d ",book);
	}
	
	for(int i=bs;i<=be;i++)ans.push(b[i]);
	for(int i=cs;i<=ce;i++)ans.push(c[i]);
	for(int i=ds;i<=de;i++)ans.push(d[i]);
	printf("\n");
	for(int i=1;ans.size();i++){
		if(i%t==0)printf("%d ",ans.top()+sigma);
		ans.pop();
	}
	return 0;
}
```

---

## 作者：Ivan422 (赞：2)

想了好久明白了。

首先，我们看到了一个~~险恶的数据~~ $m=7\times10^6$，一看就是来卡 $\mathcal O(m\log m)$ 的。

怎么办？

考虑用普通的队列。

首先把初始 $a_i$ 从大到小排序，然后考虑怎么利用数据单调性。

我们发现，$\lfloor px\rfloor$ 是单调的。

而 $x-\lfloor px \rfloor$ **在整点上是单调的**。

~~这个东西是我在 Desmos 里画了一次，然后就出来了，具体证明看点赞最多的那篇题解的。~~

那这题就解决了一半。我们把切开的两只蚯蚓分开计算，都是单调的，然后直接在 $3$ 个队列里找最长的蚯蚓切割即可。

但是，相信有部分读者只会处理 $q=0$。

我们发现，我们可给新加入的元素都减去一个偏移值。

设第 $i$ 时间为 $t$。为了方便，我们将其设置为 $t-1$，一次生长长度加 $q$，那么 $t-1$ 次生长就是 $(t-1)\times q$。挺好理解的。

当然，取出时要复原长度，加上 $(i-1)\times t$，这时就可以把一开始减去的抵消，处理完成。

没什么可以讲的了，更多内容请看点赞数最高题解。


```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
//#define arr array<int,3>
//#define int long long
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=1e5+10,M=1010,INF=1e9+7,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
int n,m,q,u,v,t,a[N],len,wormc[2];
long double p;
queue<int>worm[3];
pair<int,int>cut;
void getworm(int i){
	cut=max({
		pair<int,int>{worm[0].empty()?-INF:worm[0].front(),0},
		pair<int,int>{worm[1].empty()?-INF:worm[1].front(),1},
		pair<int,int>{worm[2].empty()?-INF:worm[2].front(),2}
	});
	len=cut.first+q*(i-1);
	worm[cut.second].pop();
}
signed main(){
	cin>>n>>m>>q>>u>>v>>t;
	p=u*1.00;p/=v;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1,greater<int>());
	for(int i=1;i<=n;i++)worm[0].push(a[i]);
	for(int i=1;i<=m;i++){
		getworm(i);
		wormc[0]=p*len;
		wormc[1]=len-wormc[0];
		worm[1].push(wormc[0]-q*i);
		worm[2].push(wormc[1]-q*i);
		if(!(i%t))cout<<len<<" ";
	}	
	cout<<"\n";
	for(int i=1;i<=n+m;i++){
		getworm(m+1);
		if(!(i%t))cout<<len<<" ";
	}
    return 0;
}
//note:

```

---

## 作者：Gorun (赞：2)

# 蚯蚓 题解

首先我们看看这道题的暴力方法怎么写：**（考场上我写的就是暴力哈哈）**

直接模拟不就完事了！

```cpp
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;
priority_queue <double> Q,Qt;
int n,m,q;
double p,u,v,t,cnt;
int main(){
	scanf("%d%d%d%lf%lf%lf",&n,&m,&q,&u,&v,&t);
	p=u/v;
	for (int i=1;i<=n;i++){
		double tmp;
		scanf("%lf",&tmp);
		Q.push(tmp);
	}
	for (int i=1;i<=m;i++){
		double x=Q.top(); Q.pop();
		double x1=floor(x*p),x2=floor(x-x1);
		Qt=Q; while (!Q.empty()) Q.pop();
		while (!Qt.empty()) Q.push(Qt.top()+q),Qt.pop();
		Q.push(x1); Q.push(x2);
		if (cnt<floor(i/t)) cnt++,printf("%d ",(int)x);
	}
	cnt=0; putchar('\n');
	for (int i=1;i<=n+m;i++){
		int x=Q.top(); Q.pop();
		if (cnt<floor(i/t)) cnt++,printf("%d ",(int)x);
	}
}
```
当然，这样模拟并不是最完美的模拟，我们可以是用C++ STL Set或平衡树来实现这个模拟的过程。结果当然只有30分啦！

我们再来看看如何优化。我们发现每一次集合中所有元素都会增加$q$（除了当前砍掉的这个），那么我们可以使用一个“**集合偏移量**”来描述这个增加，这样就不需要把每一个元素都取出来增加了。估计可以提高到50分。

具体地说，我们把当前取出的最大值设为$x$，集合偏移量设为$\Delta$，则$x$的真实值位$x+\Delta$，砍完之后新生成的两条蚯蚓长度分别为$\lfloor p(x+\Delta)\rfloor$和$x+\Delta-\lfloor p(x+\Delta)\rfloor$。那么插入的时候要把当前的集合偏移值减掉，再减去一个$q$，以抵消当前这一轮$\Delta=\Delta+q$带来的影响（**相当于当前没有增加**）。

还想优化的话，当然就需要一点数学知识了。

设$x_1\ge x_2$，设当前时间内切除的蚯蚓长度为$x_1$，下一秒切除的蚯蚓长度为$x_2+q$。那么我们可以分析一下：

$\lfloor px_1\rfloor+q \ge \lfloor px_2\rfloor+q\ge\lfloor px_2+q\rfloor\ge\lfloor p(x_2+q)\rfloor$

$\because x_1-x_2\ge p(x_1-x_2)$

$\therefore x_1-px_1\ge x_2-p(x_2+q)$

$\therefore x_1-\lfloor px_1\rfloor+q=\lfloor x_1-px_1 \rfloor+q\ge \lfloor x_2-p(x_2+q)\rfloor=x_2+q-\lfloor p(x_2+q)\rfloor$

完美，我们得到了一个神奇的单调性：如果说$x_1\ge x_2$，那么他们被切断后的两端都分别单调递减！

所以说我们可以使用三个队列解决这个问题：

$q_0$为原始序列，$q_1,q_2$为分别砍断后的两个序列，这三个序列都满足单调递减的性质（原始序列并不有序，所以$q_0$需要在插入的时候手动排序）。

附源代码：

```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cmath>
#include <iostream>
#define inf 0x3f3f3f3f
using namespace std;
const int MAXN=1e5+10;
const int MAXM=7e6+10;
typedef long long ll;
ll n,m,q,u,v,t,cnt;
ll delta;
ll a[MAXN];
queue <ll> Q,q1,q2;
bool cmp(ll a,ll b)
{
	return a>b;
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	scanf("%lld%lld%lld%lld%lld%lld",&n,&m,&q,&u,&v,&t);
	for (int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+1+n,cmp);
	for (int i=1;i<=n;i++)
		Q.push(a[i]);
	for (int i=1;i<=m;i++)
	{
		ll t1,t2,t0,res,x1,x2;
		t0=t1=t2=res=-inf;
		if (!Q.empty()) t0=Q.front();
		if (!q1.empty()) t1=q1.front();
		if (!q2.empty()) t2=q2.front();
		res=max(t0,max(t1,t2));
		if (!Q.empty()&&res==t0) Q.pop();
		else if (!q1.empty()&&res==t1) q1.pop();
		else if (!q2.empty()&&res==t2) q2.pop();
		res=res+delta;
		x1=floor((ll)u*res/v); x2=res-floor((ll)u*res/v);
		q1.push(x1-delta-q);
		q2.push(x2-delta-q);
		delta+=q;
		if (cnt<floor(i/t)) cnt++,printf("%lld ",res);
	}
	putchar('\n');
	cnt=0;
	for (int i=1;i<=n+m;i++)
	{
		ll t1,t2,t0,res;
		t0=t1=t2=res=-inf;
		if (!Q.empty()) t0=Q.front();
		if (!q1.empty()) t1=q1.front();
		if (!q2.empty()) t2=q2.front();
		res=max(t0,max(t1,t2));
		if (!Q.empty()&&res==t0) Q.pop();
		else if (!q1.empty()&&res==t1) q1.pop();
		else if (!q2.empty()&&res==t2) q2.pop();
		res=res+delta;
		if (cnt<floor(i/t)) cnt++,printf("%lld ",res);
	}
}
```


---

## 作者：pengyirui (赞：2)

本题与[合并果子](https://www.luogu.com.cn/problem/P1090)类似。      
[前往博客获取~不知道会不会~更佳的阅读体验。         ](https://www.luogu.com.cn/article/o7ajvir3)
# 思路1
参考合并果子，每次找到最长的一条，分开放回即可，并且给其他蚯蚓长度全部加上 $q$。这种解法使用 $m$ 次操作，单次复杂度是 $O(\log n)$，总的时间复杂度为  $O(m\log n)$，无法通过此题。
# 思路2
考虑使用两个队列进行优化。先被分开的两条蚯蚓一定比后面分成的对应的两条蚯蚓长。假设两条蚯蚓分别长 $a_{1}$ 和 $a_{2}$ ($a_{1}\lt a_{2}$），第一条被分成 $a_{11}=pa_{1}$ 和 $a_{12}=(1-p)a_{1}$ 两条,一段时间以后，所有蚯蚓的长度增加了 $s$，之前被分的两条长度变为 $a_{11}=pa_{1}+s$ 和 $a_{12}=(1-p)a_{1}+s$，而原来的第二条被分成了 $a_{21}=p(a_{2}+s)$ 和 $a_{22}=(1-p)(a_{2}+s)$，可得 $a_{11}\lt a_{21}$ 且 $a_{12}\lt a_{22}$。     
因此，可以准备三个队列，第一个队列存放原来的蚯蚓，第二个队列存放第一段，第三个队列存放第二段。以上三个队列都是单调不增的，比较三个队列的对首，选择最大的一个进行分割。    
**注意**：需要像思路 1 一样考虑长度偏移量。
# 代码
你们最喜欢的代码来喽！！！

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 2100000000
using namespace std;
int n,m,q,u,v,t,a[100001],x,y;
queue<int> q1,q2,q3;
bool cmp(int A,int B)
{
	return A>B;
}
int findmax()
{
	int x,x1,x2,x3;
	if(!q1.empty())x1=q1.front();
	else x1=-inf;
	if(!q2.empty())x2=q2.front();
	else x2=-inf;
	if(!q3.empty())x3=q3.front();
	else x3=-inf;
	if(x1>x2&&x1>x3)
	{
		x=x1;
		q1.pop();
	}
	else if(x2>x3)
	{
		x=x2;
		q2.pop();
	}
	else 
	{
		x=x3;
		q3.pop();
	}
	return x;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>q>>u>>v>>t;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++)q1.push(a[i]);
    for(int i=1;i<=m;i++)
    {
    	x=findmax()+q*(i-1);
    	if(i%t==0)cout<<x<<" ";
    	y=(long double)x*u/v;
    	x-=y;
    	y-=q*i;
    	q2.push(y);
    	x-=q*i;
    	q3.push(x);
	}
	cout<<"\n";
	for(int i=1;i<=n+m;i++)
	{
		x=findmax()+q*m;
		if(i%t==0)cout<<x<<" ";
	}
	return 0;
}
```
以上代码的时间复杂度为 $O(n\log n+m)$，可以通过此题，注意不要忽略排序的时间复杂度  $O(n\log n)$。

---

## 作者：maka_baka (赞：1)

维护一个大根堆，每次把堆顶的数 $x$ 取出来，把 $\lfloor px\rfloor$ 和 $x-\lfloor px\rfloor$ 入队，其余的数都自增 $q$。

输出第 $kt(k\in\mathbb N_+)$ 次操作时 $x$ 的长度和 $m$ 次操作后堆里大小排名整除 $t$ 的数。

> $p\in\mathbb Q\cap(0,1)$，$0\le q\le200$，$n\le10^5$，$m\le7\times10^6$。

## 做法
直接模拟，建堆 $O(n\log n)$，第 $i$ 次操作用时 $O(n+i)$，总时间是：
$$O\{n\log n+\frac m2[n+(n+m-1)]\}=O(n\log n+mn+m^2)$$

就堆里面的序关系而言，我们只需要维护堆里元素的相对大小。枚举第 $i(1\le i\le m)$ 次操作，我们维护每个数和 $iq$ 的差，这样就不需要每次遍历所有数了。
$$O(n\log n+\sum_{j=n}^{m+n}\log j)=O[(n+m)\log n]$$

$q=0$ 时 $x$ 切开的两段 $\lfloor px\rfloor$ 和另一段：
$$x-\lfloor px\rfloor=x+\lceil-px\rceil=\lceil(1-p)x\rceil$$
都是单调不减的，可以考虑用数组代替单调队列。除了输入的数组，再加 $2$ 个数组 $\{b\}$ 和 $\{c\}$，让每个切开的数分别放到这两个数组末尾。只要保证按从大到小的顺序切，就能保证这两个数组具有单调性。
对于 $q>0$ 这个方法也成立。假设依次切开的两段是 $x$、$(y+q)$（因为先切 $x$，所以 $x\ge y$），那么借助
$$px+q>px+pq=p(x+q)\ge p(y+q)$$
就很容易比较切开后四段的大小（因为分别存在 $2$ 个数组里，我们只需要比较 $2$ 组大小）：
$$\lfloor px\rfloor+q=\lfloor px+q\rfloor\ge\lfloor p(y+q)\rfloor$$
$$\lceil (1-p)x\rceil+q=\lceil (1-p)x+q\rceil\ge\lceil (1-p)(y+q)\rceil$$
自然，同样的方法也能保持单调性。用时 $O(n\log n+m)$。

## AC Code
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using pii=std::pair<int, int>;
int n, m, q, u, v, t, ha, hb, hc;
std::vector<int> a, b, c;

int get(std::vector<int> &v, int h) {
  return h < v.size() ? v[h] : 0x80000000;
}

int get() {
  pii x = std::max({
      pii(get(a, ha), 0),
      pii(get(b, hb), 1),
      pii(get(c, hc), 2)});
  if (x.second == 0) ha++;
  else if (x.second == 1) hb++;
  else hc++;
  return x.first;
}

int main() {
  std::cin >> n >> m >> q
    >> u >> v >> t;
  a.resize(n);
  b.reserve(m), c.reserve(m);
  for (int i=0; i<n; i++)
    std::cin >> a[i];
  std::sort(a.begin(), a.end(),
      std::greater<int>());
  for (int i=1; i<=m; i++) {
    long long x = get() + (i-1)*q, y = x*u/v;
    if (i % t == 0) 
      std::cout << x << ' ';
    b.emplace_back(y - i*q);
    c.emplace_back(x - y - i*q);
  }
  std::cout << '\n';
  for (int i=1; i<=n+m; i++) {
    int x = get() + m*q;
    if (i % t  == 0)
      std::cout << x << ' ';
  }
  std::cout << '\n';
}
```

---

## 作者：TH911 (赞：0)

> [个人Blog同步链接](https://cfyy.us.kg/2024/10/17/1/)
>
> [题目传送门](https://www.luogu.com.cn/problem/P2827)

# 前置结论

### 结论

对于整数 $x_1,x_2$ ，当 $x_1\geq x_2,0<p<1$ 时有：

1. $\lfloor px_1 \rfloor \geq \lfloor px_2 \rfloor$
2. $x_1 -\lfloor px_1 \rfloor \geq x_2- \lfloor px_1 \rfloor$

### 证明

结论 $1$ 显然得证。

结论 $2$ 证明参见[此处](https://www.luogu.com/paste/c4jthmhz)。以下为转载内容。

> 2024 年 7 月更新：新版蓝书受我反馈，已经更正此问题。
>
> 本题中所有题解的单调性正确性似乎都有或多或少的问题，在这里我给出一个严谨的单调性证明。
>
> 首先：$x - \lfloor px \rfloor$ 这个函数**并不是单调不降的**，它**只在整点上单调不降**，可以在 desmos 中画一个 $x - \lfloor 0.9x \rfloor$ 的函数试试看，你会发现它并没有单调性。当然，$x - px$ 有单调性。
>
> 所以一切**直接抛开下取整**对单调性的证明是没有任何道理的，这就叉掉了本题大量题解，包括但不限于第一篇题解。 
>
> 同时，一切没有用到 $x_1$，$x_2$ 这两个数为整数这个性质就证出了这个函数的单调性的都是**伪证**，本题**疑似**所有题解全都是伪证。**lyd 蓝书上的证明也是伪证**，具体原因见下。 
>
> 前置知识：
>
> * 下取整函数单调不降，即对于 $x_1 < x_2$ 有 $\lfloor x_1\rfloor \le \lfloor x_2 \rfloor$；
> * 整数可以自由移入移出下取整函数，即对于 $z \in \mathbb Z$，有 $\lfloor x \rfloor + z = \lfloor x + z \rfloor$。
> * 注意：**负号**不能随便移入移出，$\lfloor -3.4 \rfloor \ne - \lfloor 3.4 \rfloor$。
> * 关于这点很容易犯的一个错误就是对于 $z \in \mathbb Z$，有$\lfloor z - x \rfloor = z - \lfloor x \rfloor$，事实上这点根本不成立，举个反例：$\lfloor 1 - 0.3 \rfloor \ne 1 - \lfloor 0.3\rfloor$。
> * 刚刚这条错误就是很多伪证的错误原因所在，包括 **lyd 蓝书的证明也存在这个伪证**。
>
> 真正证明：
>
> 命题：对于 $x_1, x_2 \in \mathbb Z, x_1 \ge x_2, 0< p < 1$，有 $x_1 - \lfloor px_1 \rfloor \ge x_2 - \lfloor px_2 \rfloor$。
>
> 证明：$x_1 \ge x_2 \land x_1, x_2 \in \mathbb Z$，因此 $x_1 - x_2 \in \mathbb N$。又因为 $0 <p < 1$，所以： 
> $$
> \begin{aligned}
> x_1 - x_2  &\ge p(x_1 - x_2)\\
> x_1 - x_2 + p x_2 & \ge px_1 \\
> \lfloor px_2 + (x_1 - x_2) \rfloor & \ge\lfloor px_1 \rfloor \\
> \lfloor px_2 \rfloor + (x_1 - x_2) & \ge \lfloor px_1 \rfloor \\
> x_1 - \lfloor px_1 \rfloor & \ge x_2 - \lfloor px_2 \rfloor
> \end{aligned}
> $$
> 
>
> 证明出了这一点的单调性之后，事实上我们就解决了 $q = 0$ 的单调性问题，接下来解决 $q \ge 0$ 的。 
>
> 我们假设某一秒，我们切开了一个数 $x_1$，下一秒，我们切开了一个数 $x_2 + q$。$x_2 + q$ 在上一秒时为 $x_2$，因此 $x_1 \ge x_2$。我们的证明目标是 $\lfloor px_1\rfloor+ q \ge \lfloor p(x_2 + q)\rfloor$ 和 $x_1 - \lfloor px_1\rfloor+ q \ge x_2 + q - \lfloor p(x_2 + q)\rfloor$。 
>
> 需要注意这个证明目标也有很多题解搞错，**lyd 蓝书此处的证明存在上面所说的问题（那条假结论）**。 
>
> 对于第一条：$\lfloor px_1\rfloor+ q = \lfloor px_1 + q\rfloor \ge \lfloor px_2 + pq\rfloor = \lfloor p(x_2 + q)\rfloor$。
>
> 对于第二条：$x_1 - \lfloor px_1\rfloor+ q \ge x_2 +q - \lfloor px_2\rfloor \ge  x_2 + q - \lfloor p(x_2 +q) \rfloor$。这里第一个不等号用了 $q = 0$ 的证明结论。
>
> ***
>
> 不知道你们有没有这个疑问，我补一下。<https://www.luogu.com.cn/discuss/551666>

其中，$\color{blue}{x -\lfloor px\rfloor}\color{black}{,}\ \color{red}{x-px}$ 图像如此：

![desmos](https://cdn.luogu.com.cn/upload/image_hosting/ozj4moqp.png)

# 处理切割

### 数据结构

维护三个队列 $Q_1,Q_2,Q_3$：

* $Q_1$ 为**未曾**切割的蚯蚓；
* $Q_2$ 为切割时形如 $\lfloor px \rfloor$ 的蚯蚓；
* $Q_3$ 为切割时形如 $x- \lfloor px \rfloor$ 的蚯蚓。

### 操作

模拟题意：每次取**最长**蚯蚓进行切割。

首先维持 $Q_1$ 单调不增，然后根据前置结论 $2$ ，取最长蚯蚓进行切割所得的两条蚯蚓也比其他蚯蚓切割所得蚯蚓长。

举个例子：

蚯蚓长为 $10,8,7$，$p=0.3$。则切割所得蚯蚓长为 $(3,7),(2,6),(2,5)$，括号表示由同一蚯蚓切割所得。

这样，我们每次在 $Q_1,Q_2,Q_3$ 里查询最大值，切割后加入 $Q_2,Q_3$ 就可以维持 $Q_2,Q_3$ 单调。那么我们只需要取队首比较即可。

### 输出

#### 第一行

输出也只需要 $i \in [1,m]$ 模拟每一秒，$i \bmod t=0$ 时输出队首即可。

#### 第二行

从大到小查找队首输出并出队即可。

***

考虑到蚯蚓每一秒都会增长 $q$，我们考虑是否可能 $\mathcal O(1)$ 处理。

不妨令 $i$ 秒时，$q=pl$。

那么我们记录蚯蚓加入队列时的**已增加**长度 $pl'$，最后用**原有长度**加上 $pl-pl'$ 即可。

那么我们只需要在加入队列时，加入 $\lfloor px \rfloor-pl'$ 即可。

由于所有蚯蚓都减去了 $pl'$，并**不**影响 $Q_1,Q_2,Q_3$ 的单调性。

# AC代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
const int M=7e6;
int n,m,q,u,v,t;
//Q:手写队列(节约空间) 
int Q[4][M+1],front[4],rear[4];
bool cmp(int a,int b){
	return a>b;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	scanf("%d %d %d %d %d %d",&n,&m,&q,&u,&v,&t);
	for(int i=1;i<=n;i++)scanf("%d",&Q[1][i]);
	front[1]=front[2]=front[3]=1;
	rear[1]=n;
	sort(Q[1]+1,Q[1]+n+1,cmp);//单调不增 
	int pl=0;
	//第一行 
	for(int i=1;i<=m;i++){
		//查找队首最大值 
		int o,Max=-2147483648;
		for(int j=1;j<=3;j++){
			if(front[j]<=rear[j]&&Q[j][front[j]]>Max){
				Max=Q[j][front[j]];
				o=j;
			}
		}front[o]++;//出队 
		Max+=pl;pl+=q;
		int x=1ll*Max*u/v;
		//切割并入队 
		Q[2][++rear[2]]=x-pl;
		Q[3][++rear[3]]=Max-x-pl;
		if(i%t==0)printf("%d ",Max);//输出 
	}putchar(10);//换行 
	//第二行 
	for(int i=1;i<=m+n;i++){
		//从大到小查找、输出即可。
		//同理 
		int o,Max=-2147483648;
		for(int j=1;j<=3;j++){
			if(front[j]<=rear[j]&&Q[j][front[j]]>Max){
				Max=Q[j][front[j]];
				o=j;
			}
		}front[o]++;
		if(i%t==0)printf("%d ",Max+pl);
	}
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：Michael_114 (赞：0)

嗨嗨嗨我又来了。~~小六统考完了~~

这道题可以使用多个队列的技巧。先被切掉的两条蚯蚓一定比后面切掉的对应的蚯蚓长。假设两只蚯蚓长度分别为 $a_1,a_2(a_1<a_2)$，第一条被分成了 $a_{11} = pa_1$ 和 $a_{12} = (1-p)a_1$ 两条。一段时间后，所有蚯蚓都变长了 $s$，之前被切的两条长度分别变为 $a_{11} = pa_1+s$ 和 $a_{12} = (1-p)a_1+s$；而原来的第二条被切成了 $a_{21} = p(a_2+s)$ 和 $a_{22} = (1-p)(a_2+s)$，可以得到 $a_{11} > a_{21}$ 且 $a_{12} > a_{22}$。

因此，可以准备三个队列，第一个队列存放原来的蚯蚓，第二个队列存每次切蚯蚓后的第一段，第三个队列存的是第二段。这三个队列是单调不增的。比较这三个队列的队首，选取最大的一个来进行切割。但需要考虑每次切割后的长度偏移量。

代码：


```cpp
#include <cstdio>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
#define inf 2100000000
const int maxn =1e5+20;
int n,m,q,u,v,t;
int a[maxn],x,y;
queue<int>q1,q2,q3;
bool cmp(int a,int b){
	return a>b;
}
int findmax(){
	int x,x1,x2,x3;
	if(!q1.empty()){
		x1=q1.front();
	}else{
		x1 = -inf;
	}
	if(!q2.empty()){
		x2 = q2.front();
	}else{
		x2= -inf;
	}
	if(!q3.empty()){
		x3=q3.front();
	}else{
		x3=-inf;
	}
	if(x1>x2&&x1>x3){
		x=x1;q1.pop();
	}else if(x2>x3){
		x=x2;q2.pop();
	}else{
		x=x3;q3.pop();
	}
	return x;
}
int main() {
	scanf("%d%d%d%d%d%d",&n,&m,&q,&u,&v,&t);
	for(int i = 1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1,cmp);
	for(int i =1;i<=n;i++){
		q1.push(a[i]);
	}
	for(int i = 1;i<=m;i++){
		x=findmax()+q*(i-1);
		if(i%t==0){
			printf("%d ",x);
		}
		y=floor((long double)1.0 * x * u / v);
		x=x-y;
		y-=q*i;q2.push(y);
		x-=q*i;q3.push(x);
	}
	printf("\n");
	for(int i = 1;i<=n+m;i++){
		x = findmax()+q*m;
		if(i%t==0){
			printf("%d ",x);
		}
	}
	return 0;
}
```

---


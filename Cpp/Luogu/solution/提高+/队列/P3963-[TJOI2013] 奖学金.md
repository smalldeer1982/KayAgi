# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# 题解

## 作者：pigstd (赞：20)

首先把所有学生按照成绩排序，排序后，设$f1_i$表示$1 - i$之中，奖学金前$\frac {c-1} 2$小的奖学金之和，$f2_i$表示$i - n$之中，奖学金前$\frac {c-1} 2$小的奖学金之和

我们枚举每一个可能作为中位数的学生，那么，如果一个学生$i$能够作为中位数，那么就应该满足：$b_i + f1_{i - 1} + f2_{i+1} \le f$

那么现在的问题就是怎么求出$f1_i$和$f2_i$

那么显然我们可以推出：$f1_i=f1_{i-1}+\min(0,b_i-min1
_{i-1,\frac {c-1} 2})$，$f2_i=f2_{i+1}+\min(0,b_i-min2
_{i+1,\frac {c-1} 2})$，其中$min1_{k,j}$表示当$i = 1$到$k$中所有$b_{i}$中第$j$小的数，$min1_{k,j}$表示当$i = k$到$n$中所有$b_{i}$中第$j$小的数

那么怎么求出$min1$和$min2$呢？可以写两个权值线段树，也可以直接写一个主席树维护

代码：[code](https://www.luogu.com.cn/paste/qkfnr0pq)


---

## 作者：渡墨残殇 (赞：13)

# 主席树
首先这是一个不该用主席树写的题，正解应该是用优先队列来写~~比主席树快的多~~。
#### 但是，
既然学了主席树就要有用主席树的使命，~~不会用指针~~只能用数组写。

不过这个如果用主席树的思路也是很好想的，不用搞这搞那的，只需要建立主席树，建立主席树，一直建，然后就没了，干练精快。

## 分析：
题中给出了 $c$ 学生总数， $n$ 领奖的学生个数， $f$ 奖金总额最大数。

我们要挑出 $n$ 个学生去领奖学金，我最开始是想着建立 $c$ 个主席树，然后找到前 $n$ 小，但是没必要这样。

对于答案的限制条件是要求中位数最大，本来感觉还要算一下，但是数据说是奇数，那么中位数就是确定的值了，我们就可以从中位数开始查起。

所以，我们先把 $1$ 到 $c$ 的数据存到主席树里面，就是查询的时候需要对原来的模板改一下，我们需要开一个 $Sum$ 来存奖学金。

查询的时候把前 $k$ 小和 后 $k$小的值用 $ans1$ 和 $ans2$ 和此时的中位数的和与 $f$ 作比较，直到找到最大的。

```cpp
int query(int use,int now,int l,int r,int k)
{
	 ll  ans=0;
	int mid=(l+r)>>1;
	int h=t[t[now].l].sum-t[t[use].l].sum;//h是权值线段树操作
		if(l==r){    return k*b[l];//奖学金有一样的，只要这个节点的k个人！！！ 
	}
	 if(k<=h)ans+=query(t[use].l,t[now].l,l,mid,k);//递归的都是节点 
	 else 
	 {
	    ans+=t[t[now].l].Sum-t[t[use].l].Sum;//加上查过的数 
	 	ans+=query(t[use].r,t[now].r,mid+1,r,k-h);//注意要减去左区间的数 
	 }
	 return ans; 
}
```

**注意**
```cpp
if(l==r) return k*b[l];
```
一定要用 $k$ 乘一遍，因为可能存在一个结点包含几个相同的数据的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/2tku9mh7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
这就是没有乘 $k$ 的结果，我调了两天才发现的这个细节。

我们在主函数中查询的时候让成绩从大到小排序，我们令 $anss$ 为$-1$ 这样我们只用找到第一个 $anss$ 不是 $-1$ 情况就可以退出循环了。

# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define re read()
#define mm 400009
#define w qwrite
#define gc getchar()	
using namespace std;
//定义区
struct node{
	int a,b;
    bool operator <( const node & x)const
    {
        return x.a<a;//从大到小
    }
}len[mm];
struct nihao {
	int fre,l,r,sum;//历史的树根节点，左子树，右子树(都是指的节点)//某个区间有几个数 
	int Sum;//原数组的值 
}t[mm<<4];
int b[mm];//原数组，离散数组 
int nodee;//节点
int inst;//修改插入的点
int g;//离散的右边界 
int tok[mm];
int n,m,c,kk; 
int f,anss=-1;
ll ans1,ans2;
//函数区
int read(){//int ull
	int x=0,y=1; char s=gc;if(s=='-')y=-1;
	while(!isdigit(s))s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+s-'0',s=gc;
	return x*y;
} 

void qwrite(int x)
{
    if(x==0){putchar('0');puts("");return ;}
	int cnt=0,u[400];
	if(x<0) x=-x,putchar('-');
	while(x){u[cnt++]=x%10;x/=10;}
	while(cnt--) putchar(u[cnt]+'0');puts("");
}

void make(int &x,int l,int r)//建树 
{
	x=++nodee;
	if(l==r)return ;//叶节点
	int mid=(l+r)>>1;
	make(t[x].l,l,mid);
	make(t[x].r,mid+1,r); 
	return ;
}

int modify(int x,int l,int r)
{
	int xi=++nodee;//建立新节点
	t[xi].l=t[x].l;t[xi].r=t[x].r;t[xi].sum=t[x].sum+1;t[xi].Sum+=t[x].Sum+b[inst];//传递树节点数据
	if(l==r)return xi;//已经到叶节点，不用再建树了
	int mid=(l+r)>>1;
	if(inst<=mid) t[xi].l=modify(t[xi].l,l,mid);//对于这个数比这个区间小就到左边，右边同理
	else  t[xi].r=modify(t[xi].r,mid+1,r);
	return xi; 
} 

int query(int use,int now,int l,int r,int k)
{
	 ll  ans=0;
	int mid=(l+r)>>1;
	int h=t[t[now].l].sum-t[t[use].l].sum;//h是权值线段树操作
		if(l==r){    return k*b[l];//奖学金有一样的，只要这个节点的k个人！！！ 
	}
	 if(k<=h)ans+=query(t[use].l,t[now].l,l,mid,k);//递归的都是节点 
	 else 
	 {
	    ans+=t[t[now].l].Sum-t[t[use].l].Sum;//加上查过的数 
	 	ans+=query(t[use].r,t[now].r,mid+1,r,k-h);//注意要减去左区间的数 
	 }
	 return ans; 
}

signed main ()
{
    int l,r;
    n=re,c=re,f=re;kk=n/2;
    for(int i=1;i<=c;i++)len[i].a=re,len[i].b=re,b[i]=len[i].b;
    sort(len+1,len+1+c); //重载过了
    sort(b+1,b+c+1);
    g=unique(b+1,b+c+1)-b-1;

	make(t[0].fre,1,g);
	for(int i=1;i<=c;i++)//全部建树
	{
		inst=lower_bound(b+1,b+g+1,len[i].b)-b;//找到a[i]对应的离散化下标
		t[i].fre=modify(t[i-1].fre,1,g);//基于上一个版本的树 
	} 
	for(int i=1+(n-1)/2;i<=c-(n/2);i++)
	{
		ans1=query(t[0].fre,t[i-1].fre,1,g,kk);
		ans2=query(t[i].fre,t[c].fre,1,g,kk);
		if(ans1+ans2+len[i].b<=f)anss=max(anss,len[i].a);
		if(anss!=-1)break;
	}
	w(anss);
    return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：10)

因为一个很淦的错调了 $1h$ 。   
这道题保证 $n$ 为奇数，只是现在的题目里面没有了。    
首先我们可以想到，我们可以枚举每个数是否是中位数，而此时我们只需要在比它成绩大和小的人里面各选出 $(c - 1) / 2$ 和 $(c - 1) / 2$ 个即可。   
想到这里相信大家思路也很清晰了，为了控制查找的区间范围，我们按 $a_i$ 排个序后就控制了当前枚举的这个人他前面的人的成绩必定小于它而在它后面的人的成绩必定大于他。    

接着就是处理区间前 $k$ 小了，这个很明显可以用主席树解决。    

这里需要注意， $query$ 的时候如果此时已经递归到叶子节点了，那么我们当前返回的值应该是 $rank \times val$ 而不是~~像个rz~~一样直接返回一个 $val$ 就完了。    

看了看 $TJ$ ，又重新看了下自己的流程，发现查询的所有区间 $k$ 大 $k$ 小其左右端点必定为 $1$ 或 $n$ ，所以可以直接前后扫一遍用优先队列维护。    

再回到这道题，我们发现我们也可以用这个特性把我们的主席树优化空间到 $O(3n)$ ，具体操作我就直接口述了，维护最后一个主席树，每次查询用到的主席树只有四棵，头一棵不管它每次只用第 $i$ 和 $i + 1$ 棵，并且保证每个 $i$ 最多只会被连续用两次，所以说每次查询完扔前一棵补后一棵树就把主席树~~滚~~起来了，空间顿时也下去了(代码里面还是正常主席树)。   

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 2e5 + 5;
int n,c,rt[Len];
long long a[Len],cmt[Len],top,f,ans = -1;
struct Node
{
	long long a,b;
}Stu[Len];
bool cmp(Node x,Node y){return x.a < y.a;}
struct node
{
	int l,r,sum;
	long long fsum;	
}tree[Len * 21];
int clone(int p,int idx)
{
	top ++;
	tree[top] = tree[p];
	tree[top].sum ++;
	tree[top].fsum += cmt[idx];
	return top;
}
int build(int p,int l,int r)
{
	p = ++ top;
	if(l == r) return p;
	int mid = (l + r) >> 1;
	tree[p].l = build(tree[p].l , l , mid);
	tree[p].r = build(tree[p].r , mid + 1 , r);
	return p;
}
int update(int p,int l,int r,int wh)
{
	p = clone(p , wh);
	if(l == r) return p;
	int mid = (l + r) >> 1;
	if(wh <= mid) tree[p].l = update(tree[p].l , l , mid , wh);
	else tree[p].r = update(tree[p].r , mid + 1 , r , wh);
	return p;
}
long long query(int l,int r,int nl,int nr,int rank)
{
	if(l == r) return rank * cmt[l];
	int mid = (l + r) >> 1 , Sum = tree[tree[nr].l].sum - tree[tree[nl].l].sum;long long res = 0;
	if(rank <= Sum) res += query(l , mid , tree[nl].l , tree[nr].l , rank);
	else 
	{
		res += tree[tree[nr].l].fsum - tree[tree[nl].l].fsum;
		res += query(mid + 1 , r , tree[nl].r , tree[nr].r , rank - Sum);	
	} 
	return res;
}
int main()
{
	scanf("%d %d %lld",&c,&n,&f);
	for(int i = 1 ; i <= n ; i ++)
	{
		scanf("%lld %lld",&Stu[i].a,&Stu[i].b);
		cmt[i] = Stu[i].b;
	}	
	sort(cmt + 1 , cmt + 1 + n);
	sort(Stu + 1 , Stu + 1 + n , cmp);
	int len = unique(cmt + 1 , cmt + 1 + n) - cmt - 1;
	rt[0] = build(0 , 1 , len);
	for(int i = 1 ; i <= n ; i ++)
	{
		int Ins = lower_bound(cmt + 1 , cmt + 1 + len , Stu[i].b) - cmt;
		rt[i] = update(rt[i - 1] , 1 , len , Ins);
	}
	for(int i = (c - 1) / 2 + 1 ; i <= n - (c / 2) ; i ++)
	{
		long long lsum = query(1 , len , rt[0] , rt[i - 1] , c / 2) , rsum = query(1 , len , rt[i] , rt[n] , c / 2);
		if(lsum + rsum + Stu[i].b <= f) ans = max(ans , Stu[i].a);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：胖头鱼学员 (赞：10)

# 毒瘤[P3963](https://www.luogu.com.cn/problem/P3963)

## Question Meaning

给定$c$个人，每个人有成绩和奖学金金额，要求从中选出$n$个人，使得**中位数**最大。

## Solution

先成绩从大到小排序，然后考虑枚举哪一同学的成绩为中位数。

设$f_i$表示第$i$同学的成绩作为中位数时，左边$\frac{n}{2}$个最小值的和。

设$g_i$表示第$i$同学的成绩作为中位数时，右边$\frac{n}{2}$个最小值的和。

显然$f_i$和$g_i$满足$\frac{n}{2} + 1 \leq i \leq c - \frac{n}{2}$

所以我们可以枚举每一个中位数，用一个维护奖金的大根堆，每枚举完一个中位数，如果当前的奖金比堆顶的小，则交换，始终保证堆的有$\frac{n}{2}$个数，同时用一个数组$f_i$维护如果选$a_i$为中位数，前 $\frac{n}{2}$ 个数的最小奖金。

接下来从小到大枚举答案即可。

## Code
```cpp
#include <algorithm>
#include <iostream>
#include <queue>

using namespace std;

const int N = 5e5 + 1;
const int I[2] = {1, -1};

int n, c, k;
int f[2][N];

struct S {
  int s, w;
  bool operator<(const S &a) const {
    return s < a.s;
  }
} a[N];

void Work(int u, int v, bool l) {
  int sum = 0, i;
  priority_queue<int> q;
  for (i = l ? c : 1; l ? i > u : i < u ; i += I[l]) {
    sum += a[i].w;
    q.push(a[i].w);
  }
  for (; l ? i >= v : i <= v; i += I[l]) {
    f[l][i] = sum;
    int top = q.top();
    if (top > a[i].w) {
      q.pop();
      sum -= top;
      sum += a[i].w;
      q.push(a[i].w);
    }
  }
}

int main() {
  scanf("%d%d%d", &n, &c, &k);
  for (int i = 1; i <= c; i++) {
    scanf("%d%d", &a[i].s, &a[i].w);
  }
  sort(a + 1, a + 1 + c);
  Work(n / 2 + 1, c, 0);
  Work(c - n / 2, 1, 1);
  for (int i = c - n / 2; i >= n / 2 + 1; i--) {
    if (a[i].w + f[0][i] + f[1][i] <= k) {
      printf("%d", a[i].s);
      return 0;
    }
  }
  puts("-1");
  return 0;
}
```

---

## 作者：ycyaw (赞：4)

先成绩从大到小排序，然后考虑枚举哪一同学的成绩为中位数。

$f[i]$表示第$i$个同学的成绩作为中位数时，左边$n/2$个最小值的和

$g[i]$表示...同理，为右边$n/2$个最小值的和

$f[i],g[i]$满足$n/2+1<=i<=c-n/2($左右都必须有$n/2$个数$)$

然后从大到小枚举答案，注意$f[i],g[i]$是不包括第$i$个的，所以若$f[i]+g[i]+money[i]<=F$，输出答案。

$Code\ below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define ll long long
#define hh puts("")
using namespace std;
int n,c,tot,f[200005],g[200005];
struct node{
    int sc,mn;
}a[200005];
priority_queue<int> q;
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
inline bool cmp(node A,node B){
    return A.sc<B.sc;
}
signed main(){
    n=read(),c=read(),tot=read();
    for(int i=1;i<=c;i++){
        a[i].sc=read();
        a[i].mn=read();
    }
    sort(a+1,a+c+1,cmp);
    int sum=0;
    for(int i=1;i<=n/2;i++){
        q.push(a[i].mn);
        sum+=a[i].mn;
    }
    for(int i=n/2+1;i<=c-n/2;i++){
        f[i]=sum;
        if(a[i].mn<q.top()){
            sum-=q.top();
            sum+=a[i].mn;
            q.pop();
            q.push(a[i].mn);
        }
    }
    while(!q.empty()) q.pop();
    sum=0;
    for(int i=c;i>=c-n/2+1;i--){
        q.push(a[i].mn);
        sum+=a[i].mn;
    }
    for(int i=c-n/2;i>=n/2+1;i--){
        g[i]=sum;
        if(a[i].mn<q.top()){
            sum-=q.top();
            sum+=a[i].mn;
            q.pop();
            q.push(a[i].mn);
        }
    }
    for(int i=c-n/2;i>=n/2+1;i--){
        if(f[i]+g[i]+a[i].mn<=tot){
            printf("%d",a[i].sc);
            return 0;
        }
    }
    printf("-1");
    return 0;
}
```


---

## 作者：ix35 (赞：3)

大体思路与另外几篇题解相似，具体实现不完全相同。

先将所有人按照成绩从小到大排序，降序枚举中位数，设当前枚举的中位数下标为$x$，现在的问题就变成了：

**能否从$1...x-1$和$x+1...c$中各选出$\frac{n-1}{2}$个人，使得他们的奖学金的和再加上第$x$人自己的奖学金不超过$f$。**

显然有贪心结论：两边都选尽量小的$\frac{n-1}{2}$个人。我们可以顺序和逆序各计算一次，另$les[i]$表示$1...i-1$的答案，$mor[i]$表示$i+1...c$的答案，下面以$les$为例讲讲怎么求。

现在要解决的是**支持插入的前$k$小数和**。考虑原本解决第$k$小的权值线段树。每个点在维护当前值域内有多少个数外，再维护这些数的和。插入的操作和普通的权值线段树基本相同，在$p$点子树（值域$[l,r]$）内查询前$k$小数和记为一个函数$query(p,l,r,k)$，令$mid=(l+r)/2$，再令$siz[i]$表示$i$点值域内数的个数，$val[i]$表示$i$点值域内数的和。

1. 若$k\leq siz[p*2]$，那么前$k$小都在左边，$query(p,l,r,k)=query(p*2,l,mid,k)$；

2. 否则，左边的数必然都是前$k$小，然后在右边查询剩余部分，$query(p,l,r,k)=val[p*2]+query(p*2+1,mid+1,r,k-siz[p*2]$

3. 若$l=r$，则所有数必然都是$l$，$query(p,l,r,k)=l\times k$。

注意算$les$和$mor$中间要清空数组。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=200010;
struct Person {
	int x,y;
}p[MAXN];
ll f,val[4*MAXN],siz[4*MAXN],les[MAXN],mor[MAXN];
int n,c;
bool cmp (Person a,Person b) {return a.x<b.x;}
void add (int p,int l,int r,int pos) {
	siz[p]++,val[p]+=pos;
	if (l==r) {return;}
	int mid=(l+r)>>1;
	if (pos<=mid) {add(p*2,l,mid,pos);}
	else {add(p*2+1,mid+1,r,pos);}
}
ll query (int p,int l,int r,int k) {
	if (l==r) {return l*k;}
	int mid=(l+r)>>1;
	if (siz[p*2]>=k) {return query(p*2,l,mid,k);}
	else {return val[p*2]+query(p*2+1,mid+1,r,k-siz[p*2]);}
}
int main () {
	scanf("%d%d%lld",&n,&c,&f);
	n=(n-1)/2;
	for (int i=1;i<=c;i++) {
		scanf("%d%d",&p[i].x,&p[i].y);
	}
	sort(p+1,p+c+1,cmp);
	for (int i=1;i<=c;i++) {
		if (i>n) {les[i]=query(1,1,MAXN/2,n);}
		else {les[i]=1e18;}
		add(1,1,MAXN/2,p[i].y);
	}
	memset(val,0,sizeof(val));
	memset(siz,0,sizeof(siz));
	for (int i=c;i>=1;i--) {
		if (i+n<=c) {mor[i]=query(1,1,MAXN/2,n);}
		else {mor[i]=1e18;}
		add(1,1,MAXN/2,p[i].y);
		if (les[i]+mor[i]+p[i].y<=f) {
			printf("%d\n",p[i].x);
			return 0;
		}
	}
	printf("-1\n");
	return 0;
}
```


---

## 作者：LlLlCc (赞：2)

首先先将所有人按成绩排序，然后倒着枚举每一个人为中位数的时候，如果可行则直接输出这个人的成绩

如何判断是个人为中位数是否可行呢？先考虑这个人为中位数时其他人的选择情况

因为他的成绩为中位数，所有应该在他前面挑出$\frac{2}{n-1}$个人选，后面挑出$\frac{2}{n-1}$个人选，然后再加上自己。贪心的思想，在前面和后面挑的人都挑奖金额最小的

所以正反枚举，用大根堆维护前面和后面挑$\frac{2}{n-1}$个人的最小代价就行

## code
```
#include<bits/stdc++.h>
#define maxn 1000005
#define ll long long
using namespace std;
int n,m;
ll p,f[maxn],sum;
struct lc{
	int x,data;
	bool operator <(const lc b)const{return data<b.data;}
}a[maxn];
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
namespace heap{
	int Now,heap[maxn],tot;
	inline void heap_put(int x){heap[Now=++tot]=x;while (Now>1&&heap[Now]>heap[Now>>1]) swap(heap[Now],heap[Now>>1]),Now>>=1;}
	inline void heap_pop(){
		heap[1]=heap[tot--],Now=1;int Son=2;
		while (Son<=tot){
			if (Son<tot&&heap[Son+1]>heap[Son]) Son++;
			if (heap[Son]>heap[Now]) swap(heap[Son],heap[Now]),Now=Son,Son=Now<<1;
			else break;
		}
		return;
	}
	inline void clear(){tot=0;memset(heap,0,sizeof heap);}
}
int main(){
	m=read()>>1,n=read(),p=read();
	for (int i=1;i<=n;i++) a[i].data=read(),a[i].x=read();
	sort(a+1,a+n+1);
	for (int i=1;i<=n;i++){
		if (heap::tot<m) heap::heap_put(a[i].x),sum+=a[i].x;
		else if (heap::heap[1]>a[i].x) sum+=a[i].x-heap::heap[1],heap::heap_pop(),heap::heap_put(a[i].x);
		f[i]=sum;
	}
	heap::clear();sum=0;
	for (int i=n;i>m;i--){
		if (n-i>=m&&f[i-1]+sum+a[i].x<=p){printf("%d",a[i].data);return 0;}
		if (heap::tot<m) heap::heap_put(a[i].x),sum+=a[i].x;
		else if (heap::heap[1]>a[i].x) sum+=a[i].x-heap::heap[1],heap::heap_pop(),heap::heap_put(a[i].x);
	}
	printf("-1");
	return 0;
}
```


---

## 作者：YinyuDream (赞：2)

# 题解：

本道题可以先按照成绩排序，再枚举成绩的中位数求解。对于每一个成绩作为中位数的学生，可以求出成绩小于中位数的学生的最小的$n/2$的奖学金之和$a$以及成绩大于中位数的学生的最小的$n/2$的奖学金之和$b$，设作为中位数的学生的奖学金为$c$，若$a+b+c<=f$则该成绩作为中位数是合法的。这样，我们就可以求得答案了。对于$a$和$b$的求解，我们可以使用堆。我们从左往右遍历，若当前位置$i$的值$t_i$大于堆顶元素$m$，则选择当前元素，将堆顶元素出堆，将该元素入堆，$a_i=a_{i-1}-m+t_i$，否则，$a_i=a_{i-1}$。

# 代码：
```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=1e6+10;
int n,c,f,ans;
int suma[maxn],sumb[maxn];
struct node{
	int a,b;
}z[maxn];
bool cmp(node a,node b)
{
	return a.a<b.a;
}
priority_queue<int>q;
int main(){
	scanf("%d%d%d",&n,&c,&f);
	for(int i=1;i<=c;i++)
		scanf("%d%d",&z[i].a,&z[i].b);
	sort(z+1,z+c+1,cmp);
	for(int i=1;i<=n/2;i++)
		q.push(z[i].b),suma[i]=suma[i-1]+z[i].b;
	for(int i=n/2+1;i<=c;i++)
	{
		if(z[i].b<q.top())suma[i]=suma[i-1]-q.top()+z[i].b,q.pop(),q.push(z[i].b);
		else suma[i]=suma[i-1];
	}
	while(q.size())q.pop();
	for(int i=c;i>=c-n/2+1;i--)
		q.push(z[i].b),sumb[i]=sumb[i+1]+z[i].b;
	for(int i=c-n/2;i>=1;i--)
	{
		if(z[i].b<q.top())sumb[i]=sumb[i+1]-q.top()+z[i].b,q.pop(),q.push(z[i].b);
		else sumb[i]=sumb[i+1];
	}
	for(int i=n/2+1;i<=c-n/2;i++)
	{
		if(suma[i-1]+sumb[i+1]+z[i].b<=f)
		ans=z[i].a;
	}
	printf("%d",ans!=0?ans:-1);
	return 0;
}
```


---

## 作者：BeautyYu言醴 (赞：2)


> 小张最近发表了一篇论文,有一个神秘人物要给小张学院发奖学金。小张学院有C名学生,要从中挑出N个。这个神秘人物爱好奇特,他希望得到奖学金的同学的成绩的中位数尽可能大,但同时,他们的奖学金总额不能超过F。

观察题目,显然应当将学生依照成绩排序

当成绩中位数确定时,应选取中位数两侧金额最小的学生,满足贪心原则

题意转化为

> 求中位数两端学生中金额前`n/2`小的金额之和

区间第k小问题,显然选用主席树解答

从大到小枚举中位数,选取第一个满足条件的即可

注意:

本题对空间要求严格,

1. 如果预先求出所有`从0开始的前缀和`和`从c开始的所有后缀和`的树版本,必然MLE(亲测)
2. 如果只预处理前(后)缀和树,另一部分用完整树与之相减,且在枚举中位数时动态建树,可以勉强卡过(笔者的解法)
3. 注意到**中位数无法二分枚举**,所以实际上只用到了**当前版本和上一个版本的树**,更早的树应当被销毁!

所以当笔者写完后发现**根本不需要主席树**........

笔者代码如下(注意数据命名与题面不符):

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>
#define llint long long
using namespace std;
int set_[200010],cnt[200010];
struct node{
        node *lson,*rson;
        int val,sum_;
        node(int ql,int qr,bool full){
                // build a void tree
                if(ql == qr){
                        lson = rson = NULL;
                        val = full * cnt[ql];sum_ = val * set_[ql];
                }
                else{
                        int mid = ((qr - ql) >> 1) + ql;
                        lson = new node(ql,mid,full);
                        rson = new node(mid + 1,qr,full);
                        val = full * (lson->val + rson->val);
                        sum_ = full * (lson->sum_ + rson->sum_);
                }
        }
        node(node *ori,node *ls,node *rs,int ival){
                lson = ls;rson = rs;
                val = ori->val + 1;sum_ = ori->sum_ + set_[ival];
        }
        node* insert(int ival,int l,int r){
                int mid = ((r - l) >> 1) + l;
                if (ival == l && ival == r)
                        return new node(this,NULL,NULL,ival);
                if (ival <= mid)
                        return new node(this,lson->insert(ival,l,mid),rson,ival);
                else 
                        return new node(this,lson,rson->insert(ival,mid + 1,r),ival);
        }
        

}*full,*suf[200010];
int query(node *op,int k,int l,int r){
        int mid = ((r - l) >> 1) + l;
        if (l == r)
                return k * set_[l];
        if (k <= op->lson->val)
                return query(op->lson,k,l,mid);
        else 
                return op->lson->sum_ + query(op->rson,k - op->lson->val,mid + 1,r);
}
int query2(node *op,node *ff,int k,int l,int r){
        int mid = ((r - l) >> 1) + l;
        if (l == r)
                return k * set_[l];
        if (k <= ff->lson->val - op->lson->val)
                return query2(op->lson,ff->lson,k,l,mid);
        else 
                return ff->lson->sum_ - op->lson->sum_ + query2(op->rson,ff->rson,k -(ff->lson->val -  op->lson->val),mid + 1,r);
}

struct xxx{
        int score,money;
        bool operator < (const xxx &be)const{
                return score < be.score;
        }
}data[200010];
int main (){
//      freopen("wb.in","r",stdin);
        //readin
        int n,k,p;
        cin>> k >> n >> p;
        for (int i = 1;i <= n;++ i){
                scanf("%d%d",&data[i].score,&data[i].money);
        }
        sort(data + 1,data + 1 + n);
        //discrete
        for (int i = 1;i <= n;++ i)
                set_[i] = data[i].money;
        sort(set_ + 1,set_ + 1 + n);
        int size_ = unique(set_ + 1,set_ + 1 + n) - set_ - 1;
        for (int i = 1;i <= n;++ i)
                data[i].money = lower_bound(set_ + 1,set_ + size_ + 1,data[i].money) - set_,
                cnt[data[i].money] ++;
        //build trees
        suf[n + 1] = new node (1,size_,0);
        full = new node (1,size_,1);
        for (int i = n;i > n - (k >> 1);-- i)
                suf[i] = suf[i + 1]->insert(data[i].money,1,size_);
        //query
        for (int i = n - (k >> 1);i > (k >> 1);-- i){
                suf[i] = suf[i + 1]->insert(data[i].money,1,size_);
                if(query2(suf[i],full,k >> 1,1,size_) + query(suf[i + 1],k >> 1,1,size_) + set_[data[i].money] <= p){
                        cout << data[i].score;
                        return 0;
                }
        }
        cout << -1 ;
        return 0;
}

```

以上.

![](https://s1.ax1x.com/2018/07/13/PKOjIS.jpg)

---

## 作者：yezi————— (赞：1)

# ~~大力装臂~~
#### 思想跟前面一样，也是枚举中位数，看最大合法解。不过区间最小的几个数用优先队列预处理出，用数组存下前缀i个数中最小的m/2个数和，用另一个存后缀i个数中最小的m/2个数和。优先队列处理时保证里面有m/2个数，更新时比较当前队列最大与更新数大小。
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#include<algorithm>
#define N 200003
using namespace std;
struct node{
	long long s,w;
}stu[N];
node tmp[N];
bool cmp(node x,node y){
	if(x.s!=y.s)
		return x.s<y.s;
	return x.w<y.w;
}
priority_queue<long long> q;
priority_queue<long long> q2;
inline long long read(){
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-w;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0'; ch=getchar();}
	return s*w;
}
long long n,m,f,ans=-1;
long long qzh[N],hzh[N];
int main(){
	m=read(); n=read(); f=read();
	for(int i=1;i<=n;i++){
		stu[i].s=read(); stu[i].w=read();
	}
	sort(stu+1,stu+n+1,cmp);
	for(int i=1;i<(n-m/2);i++){
		if(i<=(m/2)){
			qzh[i]=qzh[i-1]+stu[i].w;
			q.push(stu[i].w);
		}else{
			if(stu[i].w<q.top()){
				qzh[i]=qzh[i-1]-q.top();
				qzh[i]+=stu[i].w;
				q.pop();
				q.push(stu[i].w);
			}else{
				qzh[i]=qzh[i-1];
			}
		}
	}
	for(int i=n;i>(1+m/2);i--){
		if(i>(n-m/2)){
			hzh[i]=hzh[i+1]+stu[i].w;
			q2.push(stu[i].w);
		}else{
			if(stu[i].w<q2.top()){
				hzh[i]=hzh[i+1]-q2.top();
				hzh[i]+=stu[i].w;
				q2.pop();
				q2.push(stu[i].w);
			}else{
				hzh[i]=hzh[i+1];
			}
		}
	}
	for(int i=(n-m/2);i>(m/2);i--){
		long long res=stu[i].w;
		res+=qzh[i-1];
		res+=hzh[i+1];
		if(res<=f){
			ans=stu[i].s;
			break;
		}
	}
	printf("%lld",ans);
}
```


---

## 作者：saligia (赞：1)

考虑先将所有学生按照奖学金升序排序，然后我们从大到小枚举中位数的位置，那么怎么check这个中位数是否满足条件呢？

显然，在这个中位数前后各取前（n-1）/2小的奖学金求和，如果这个和<=F，那么这个中位数就是合法的。

现在问题变成了如何维护动态前k小的数的和，我选择

### 平衡树splay

（我知道这很僵硬）

用两棵平衡树分别维护现在枚举到的中位数前后两部分的奖学金，在枚举位置时动态插入和删除，每次查找第（n-1）/2大的数，如果这个数改变了就更新sum的值，然后判断是否合法，合法就直接return 0.

具体看代码吧

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxc 200050
#define rint register int
#define rl register long long
#define ll long long
ll n,c,F;
ll pmax,qmax,psum,qsum;

struct node{
	ll grade,money;
}a[maxc];

inline long long read(){
	register long long x=0;
	register char ch=getchar();
	while (ch<'0' || ch>'9') ch=getchar();
	while (ch<='9' && ch>='0') x=x*10+ch-'0',ch=getchar();
	return x;
}

inline bool cmp(node x,node y){
	return x.grade<y.grade;
}

struct Splay{//用结构体维护两棵splay 
	int root,tot;
	ll fa[maxc],ch[maxc][2],val[maxc],son[maxc],cnt[maxc];
	inline void pushup(rint x){
		rint ls=ch[x][0];
		rint rs=ch[x][1];
		son[x]=son[ls]+son[rs]+cnt[x];
	}//更新子树节点数 
	void rotate(rint x){
		rint y=fa[x];
		rint z=fa[y];
		rint k=ch[y][1]==x;
		ch[z][ch[z][1]==y]=x;
		fa[x]=z;
		ch[y][k]=ch[x][k^1];
		fa[ch[x][k^1]]=y;
		ch[x][k^1]=y;
		fa[y]=x;
		pushup(y);pushup(x);
	}//正常的rotate 
	void splay(rint x,rint goal){
		while (fa[x]!=goal){
			rint y=fa[x];
			rint z=fa[y];
			if (z!=goal)	
				(ch[z][0]==y)^(ch[y][0]==x)?rotate(x):rotate(y);
			rotate(x);
		}
		if (!goal) root=x;
	}//正常的splay 
	void Insert(rl x){
		rint u=root,f=0;
		while (u && x!=val[u]){
			f=u;
			u=ch[u][x>val[u]];
		}
		if (u) cnt[u]++;
		else{
			u=++tot;
			if (f) ch[f][x>val[f]]=u;
			val[u]=x;
			ch[u][0]=ch[u][1]=0;
			son[u]=cnt[u]=1;
			fa[u]=f;
		}
		splay(u,0);
	}//正常的插入 
	void find(rl x){
		rint u=root;
		if (!u) return;
		while (ch[u][x>val[u]] && x!=val[u]) u=ch[u][x>val[u]];
		splay(u,0);
	}//正常的查找 
	int next(rl x,rint f){
		find(x);
		rint u=root;
		if (val[u]>x && f) return u;
		if (val[u]<x &&!f) return u;
		u=ch[u][f];
		while (ch[u][f^1]) u=ch[u][f^1];
		return u;
	}//正常的前后驱 
	void Delete(rl x){
		rint nxt=next(x,1);
		rint lst=next(x,0);
		splay(lst,0);splay(nxt,lst);
		int u=ch[nxt][0];
		if (cnt[u]>1){
			cnt[u]--;
			splay(u,0);
		} 
		else ch[nxt][0]=0;
	}//正常的删除 
	long long kth(rint x){
		rint u=root;
		while (1){
			int y=ch[u][0];
			if (x>son[y]+cnt[u]){
				x-=son[y]+cnt[u];
				u=ch[u][1];
			}
			else if (x<=son[y]) u=y;
			else return val[u];
		}
	}//正常的查找第k大 
}p,q;

int main(){
	n=read();c=read();F=read();
	for (rint i=1;i<=c;++i) a[i].grade=read(),a[i].money=read();
	sort(a+1,a+c+1,cmp);//按照成绩排序 
	p.Insert(-1e18);p.Insert(1e18);//保持其平衡 
	q.Insert(-1e18);q.Insert(1e18);//但是后面操作是别忘了+1 
	for (rint i=1;i<=c-n/2-1;++i) p.Insert(a[i].money);
	for (rint i=c-n/2+1;i<=c;++i) q.Insert(a[i].money),qsum+=a[i].money;
	qmax=q.kth(n/2+1);//中位数后面第(n-1)/2大的值
	pmax=p.kth(n/2+1);//中位数前面第(n-1)/2大的值
	rint num=0;//先处理出初始情况 
	for (rint i=1;i<=c-n/2-1;i++){
		if (a[i].money<pmax) psum+=a[i].money,num++;
	}
	if (num<n/2) psum+=pmax*(n/2-num);
	ll sum=psum+a[c-n/2].money+qsum;
	if (sum<=F){//满足条件直接结束 
		cout<<a[c-n/2].grade;
		return 0;
	}
	for (rint i=c-n/2-1;i>=n/2+1;i--){
		q.Insert(a[i+1].money);//在右边插入新数 
		p.Delete(a[i].money);//在左边删除旧数 
		if (a[i+1].money<qmax){
			qsum-=qmax;
			qsum+=a[i+1].money;
			qmax=q.kth(n/2+1);
		}//更新右边的第(n-1)/2大值和前(n-1)/2个数的和 
		if (a[i].money<pmax || (a[i].money==pmax && p.val[p.root]!=pmax)){
			pmax=p.kth(n/2+1);
			psum-=a[i].money;
			psum+=pmax;
		}//更新左边的第(n-1)/2大值和前(n-1)/2个数的和 
		sum=psum+a[i].money+qsum;
		if (sum<=F){//满足条件直接结束
			cout<<a[i].grade;
			return 0;
		}
	}
	cout<<"-1";//没有满足的中位数输出-1 
	return 0;
}
```

---

## 作者：_22222222_ (赞：0)

#### 题目描述

[题面](https://www.luogu.com.cn/problem/P3963)

#### solution

首先用 ```std::sort``` 去预处理一下整个数组，以便于我们枚举中位数。

然后，对于每个位置 $i$ ，以这个位置的 $a_i$ 为中位数，求出以这个位置为中位数的最小花费。

但是这里会有一个问题，以$a_i$为中位数，必须满足使 $a_j<a_i$ 成立的  $j$ 至少有 
$\frac{n}{2}$ 个(向下取整)，同理，使 $a_j>a_i$ 成立的 $j$ 至少要有 $\frac{n}{2}$ 个。

所以我们的枚举范围就是 $[\frac{n}{2},c-\frac{n}{2}]$ 。

考虑对于 $f$ 信息的维护。

我们可以贪心地在左半区间和右半区间挑选奖学金最少的人加入答案。

因为中位数只是和 $a_i$ 的相对大小有关系，而与$b_i$无关，我们只需要在左半区间挑 $\frac{n}{2}$ 个，在右半区间挑 $\frac{n}{2}$ 个人即可。至于存不存在合法方案，我们只关注 $\sum b_i$ 在最小时和 $k$ 的关系即可。

考虑优先队列，维护一个当前的总和 $sum$ ，在枚举 $i$ 时将 $sum$ 加入当前答案，然后维护优先队列的最优决策(队列的大小保持 $\frac{n}{2}$ )和 $sum$ 即可。

注意点：扫两遍&```long long ```。

#### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int o=222222;
int n,c,f;
struct node{
	int fs;
	int m;	
	int id;	
}a[o];
struct answer{
	int zhong;
	int m;
	int id;
}b[o];
struct cmp{
	bool operator()(node a,node b){
		return a.m<b.m;		
	}	
};
bool cmp2(node a,node b){
	return a.fs<b.fs;	
}
priority_queue<node,vector<node>,cmp>q;
int read(){
	int i=1,j=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			i=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		j=j*10+ch-48;
		ch=getchar();
	}
	return i*j;
}
void in(){
    n=read();
    c=read();
    f=read();
	for(int i=1;i<=c;i++){
		a[i].fs=read();
		a[i].m=read();
	}
	sort(a+1,a+c+1,cmp2);			
	for(int i=1;i<=c;i++){
		b[i].zhong=a[i].fs;
		b[i].id=i;
	}
}
void dl(){//left to right
	int money=0;
	for(int i=1;i<=(n/2);i++){
		q.push(a[i]);
		money+=a[i].m;	
	}
	for(int i=(n/2)+1;i<=c-(n/2);i++){
		b[i].m+=money;
		q.push(a[i]);
		money+=a[i].m;
		node x=q.top();
		q.pop();
		money-=x.m;

	}	
	while(!q.empty()){
		q.pop();
	}
}
void dr(){
	int money=0;
	for(int i=c;i>c-(n/2);i--){
		q.push(a[i]);
		money+=a[i].m;	
	}
	for(int i=c-(n/2);i>(n/2);i--){
		b[i].m+=money;
		q.push(a[i]);
		money+=a[i].m;
		node x=q.top();
		q.pop();
		money-=x.m;
	}	
	while(!q.empty()){
		q.pop();
	}
}
bool cmp3(answer a,answer b){
	return a.zhong>b.zhong;
}
void work(){
	dl();
	dr();
	sort(b+(n/2)+1,b+c-(n/2)+1,cmp3);
	for(int i=(n/2)+1;i<=c-(n/2);i++){
		int key=b[i].id;
		if(b[i].m+a[key].m<f){
			cout<<a[key].fs;
			exit(0);
		}
	}
	printf("-1");
}
signed main(){
	in();
	work();
	return 0;	
}
```

#### update

做到这个题是在 $2022.4.10$ ，但是某种原因过了几个月才写题解

顺便宣传博客[WintersRain](https://www.cnblogs.com/WintersRain/)~~虽然不是我本人的~~。

---

## 作者：abandentsky (赞：0)

题意：题目的意思很好理解，给你给出一些同学，然后从这些同学里选择n（必定为奇数），使得这n个同学的成绩中位数最大，并且他们的奖学金和要小于等于f。问题转化为将成绩从大到小，或者从小到大排序，然后枚举中位数，在中位数左边和右边查询最小的n/2个元素和。
思路：和楼下某位大佬的思路一样，用动态规划一样的思路处理出从左到右边区间里面有n/2个元素和的最小值，再处理出从右到左的最小值。产生区间里面这个最小值的元素我们用一个大根堆去维护，每次和堆顶元素比较，如果小就换掉。预处理玩，然后就来一遍for循环，比较一下就好了。
注意：数据没必要开long long，也没必要手写堆。脚标为最前面的n/2-1个，和最后面的n/2-1个要置为INF或者直接前缀和也可以。后面的思路，如果能换就换掉，不能换，最小值就是前一个脚标下的最小值。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 200010
#define maxnode 50010
#define sigma_size 26
#define md 1000000007
#define INF 0x3f3f3f3f

using namespace std;
typedef long long LL;

int n,c,f;
struct node
{
    int grade,salary;
}P[MAXN];
int Left[MAXN],Right[MAXN];

bool comp(node A,node B)
{
    return A.grade>B.grade;
}

priority_queue<int,vector<int>,less<int> >pp;  //使用一个大根堆
int ans;

int main()
{
    scanf("%d%d %d",&n,&c,&f);
    for(int i=1;i<=c;i++)
    {
        scanf("%d %d",&P[i].grade,&P[i].salary);
    }
    ans=0;
    sort(P+1,P+1+c,comp);
    for(int i=1;i<=n/2;i++)
    {
        ans+=P[i].salary;
        pp.push(P[i].salary);
        Left[i]=INF;
    }
    Left[n/2]=ans;
    for(int i=n/2+1;i<=c-n/2;i++)                         //从左向右边扫描，不断的用（大根堆）来维护
    {                                                                      //堆里面时钟保持n/2个元素
        if(P[i].salary<pp.top())
        {
            Left[i]=Left[i-1]-pp.top();
            Left[i]+=P[i].salary;
            pp.pop();
            pp.push(P[i].salary);
        }
        else
            Left[i]=Left[i-1];
    }
    ans=0;
    while(!pp.empty())
        pp.pop();
    for(int i=c;i>c-n/2;i--)
    {
        ans+=P[i].salary;
        Right[i]=INF;
        pp.push(P[i].salary);
    }
    Right[c-n/2+1]=ans;
    for(int i=c-n/2;i>=n/2+1;i--)
    {
        if(P[i].salary<pp.top())
        {
            Right[i]=Right[i+1]-pp.top();
            Right[i]+=P[i].salary;
            pp.pop();
            pp.push(P[i].salary);
        }
        else
            Right[i]=Right[i+1];
    }
    for(int i=n/2+1;i<=c-n/2;i++)
    {
        if((P[i].salary+Left[i-1]+Right[i+1])<=f)
        {
            printf("%d\n",P[i].grade);
            return 0;
        }
    }
    printf("-1\n");
    return 0;
}

```


---


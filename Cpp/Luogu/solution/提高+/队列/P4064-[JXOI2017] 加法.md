# [JXOI2017] 加法

## 题目描述

可怜有一个长度为 $n$ 的正整数序列 $A$，但是她觉得 $A$ 中的数字太小了，这让她很不开心。

于是她选择了 $m$ 个区间 $[l_i,r_i]$ 和两个正整数 $a,k$。她打算从这 $m$ 个区间里选出恰好 $k$ 个区间，并对每个区间执行一次区间加 $a$ 的操作。（每个区间最多只能选择一次）。

对区间 $[l,r]$ 进行一次加 $a$ 操作可以定义为对于所有 $i$ ∈ $[l,r]$，将 $A_i$ 变成 $A_i+a$。现在可怜想要知道怎么选择区间才能让操作后的序列的最小值尽可能的大，即最大化 $\min\{A_i\}$。

## 说明/提示

选择给区间 $[1,1]$ 和 $[1,3]$ 加 $1$。

对于 $100\%$ 的数据，保证 $1\leq\sum n,\sum m\leq 2\times 10^5$，$1\leq T\leq 2\times 10^5$，$1\le k\le m$，$1\le a\le 100$，$1\le A_i\le 10^8$。

## 样例 #1

### 输入

```
1 
3 3 2 1
1 3 2
1 1
1 3
3 3```

### 输出

```
3```

# 题解

## 作者：shadowice1984 (赞：20)

其实不需要树状数组的……

很有意思的一道二分题

熟练的诸位想必马上反应出二分答案了吧……

因为题目中是要求最大化整个序列的最小值，那么我们可以二分这个最小值

显然这个最小值的取值范围是在$[min(A_{i}),min(A_{i})+ma]$之间，然后就可以二分了~

现在我们二分了一个答案mid出来，我们呢要判断这个mid合不合法

我们发现每个点需要被覆盖的次数不一样，有些点甚至完全不需要被覆盖，我们需要决策出一个最小的方案

那么我们怎么决策呢？当然是贪心了

大概的思路是，**我们只有在不得不使用一次加法的时候才去使用加法，否则不使用**

另外，我们希望**后边的决策不会影响前边的决策**

这样的话我们才可以放心的使用贪心

那么我们可以这样做，把一个线段拆成一个左端点和一个右端点，和我们的序列点一起排序，最后形成一个长度为$n+2m$的决策序列

现在我们从左到右的扫这个决策序列，保证同一位置的左端点在序列点前，右端点在序列点后

如果这个点是一个左端点，我们插入一个线段到某个数据结构中存储

如果这个点是一个决策点，我们计算它的值还需要加几次到达mid，然后查找我们的数据结构里有多少合法的线段

显然有一个贪心策略是，因为现在排好序了，所以扫到这个序列点时，**前边的序列已经全部合法**，因此数据结构中现存线段的左端点在哪里变得毫无意义，我们只需要优先选择右端点最远的点进行加法就可以了

所以我们优先选择数据结构中最远的右端点，进行若干次区间加操作即可

现在让我们来看右端点，如果直白的想一下的话，我们会觉得这个点的作用是删除一个线段，但是我们发现前面指的某种数据结构**明显是一个堆**，而且我们呢也不需要真的插入一个线段，插入一个右端点足矣。

那么我们会发现我们完全可以使用惰性删除法，就是说在检查这个堆的时候，我们呢可以检测这个右端点是否在这个决策点的左边，如果在左边我们认为堆为空，可以return false了

发现好像没有右端点什么事？

但是右端点本来就不是用来删除的啊……，还记得我们需要进行区间加操作吗？

好像需要维护一个线段树/树状数组，真是麻烦

我们都知道二维扫描线可以将二维问题变成一个一维问题，用一维数据结构来维护，那么我们现在要解决的问题是一个一维区间加问题，我们当然可以用一个一维扫描线，把这个一维问题变成一个零维问题，用零维数据结构——一个变量来维护

具体来讲，当你需要进行一次区间加操作的时候，并不进行区间加，而是仅仅在一个临时变量flow上+a，同时标记上这个区间已选，我们每次扫到一个决策点的时候先把它的值+flow，对应着这个点承受的区间加操作

之后当我扫到一个右端点时，我们要"删除"这个区间，我们检查一下这个区间有没有被选中，如果被选了，我们就把flow-a，代表这个区间加已经结束，如果没被选就什么也不做

所以我们就这样愉快的消掉了一个数据结构，全程只需要一个priority_queue就行了

算法复杂度$O((n+m)log(n+m)log(ma))$，大致是$O(nlog^{2}n)$的(实际上跑的飞起)

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=2*1e5+10;typedef long long ll;
int n;int m;ll a;int k;int T;
struct opt//操作结构体 
{
    ll val;int tp;int pos;//val对于序列点是点值，对于线段点是编号 
    friend bool operator <(opt a,opt b){return a.pos+a.tp/3.0<b.pos+b.tp/3.0;}
}op[3*N];int cnt;int book[N];int r[N];ll lf=0x7f7f7f7f;ll ri;
struct data{int v;friend bool operator <(data a,data b){return r[a.v]<r[b.v];}};
priority_queue <data> pq;//这里写了一个O(1)的清空函数 
inline void clear(priority_queue <data>& pq){priority_queue <data> emp;swap(emp,pq);}
inline bool jud(ll mid)
{
    ll flow=0;int tot=0;
    for(int i=1;i<=cnt;i++)
    {
        if(op[i].tp==0){pq.push((data){op[i].val});}//插入左端点 
        else if(op[i].tp==1)
        {
            ll ned=mid-op[i].val-flow;if(ned<0)continue;//如果比mid大可以continue了 
            ll ch=(ned+a-1)/a;if(tot+ch>k){return false;}//如果超了限制的话可以拍false了 
            for(;!pq.empty()&&ch;pq.pop())
            {
                int v=(pq.top()).v;
                if(r[v]<op[i].pos){return false;}//如果此时堆为空也可以拍false了 
                else {book[v]=1;flow+=a;ch--;tot++;}//区间+a 
            }if(ch>0){return false;}//如果没加完也可以拍false了 
        }else{flow-=book[op[i].val]*a;}//检查下这个区间有没有被选中 
    }return true;//如果全部通过就return true 
} 
inline void solve()
{
    scanf("%d%d%d%d",&n,&m,&k,&a);
    for(int i=1;i<=n;i++)//插入序列点 
    {int t;scanf("%lld",&t);op[++cnt]=(opt){t,1,i};lf=min(lf,(ll)t);}
    for(int i=1;i<=m;i++)//插入线段点 
    {
        scanf("%d",&r[i]);op[++cnt]=(opt){i,0,r[i]};
        scanf("%d",&r[i]);op[++cnt]=(opt){i,2,r[i]};
    }sort(op+1,op+cnt+1);ri=lf+m*a;//计算左右区间 
    while(lf!=ri)//二分答案，记得清空 
    {
        ll mid=(lf+ri+1)/2;if(jud(mid)){lf=mid;}else {ri=mid-1;}
        clear(pq);for(int i=1;i<=m;i++){book[i]=0;}
    }printf("%lld\n",lf);cnt=0;lf=0x7f7f7f7f;//清空一些东西 
}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++){solve();}return 0;}//拜拜程序~ 
```


---

## 作者：Poncirus (赞：12)

最小值的最大值，一眼二分题。

题目要求 $\min\{A_i\}$，所以我们可以尝试二分 $A_i$ 的下限。

接下来就是二分的基本流程，枚举 $A_i$，若 $A_i\le mid$，则需要对 $A_i$ 进行操作。

显然，$A_i$ 之前的所有值已经满足条件，不在我们的考虑范围内，只用考虑这次选择对 $A_i$ 之后的元素带来的影响。按照这个思路贪心地想，我们只用在所有包含 $A_i$ 的区间中选择右端点最靠右的区间，以涵盖更多的元素。

对于选择区间的操作，预处理按区间左端点为关键字从左到右排序，枚举 $A_i$ 时，以上一次的区间序列为基础，加入左端点在 $A_i$ 之前的区间，删除右端点在 $A_i$ 之前的区间就可以得到覆盖 $A_i$ 的区间序列。“不断地选择右端点最靠右的区间” 这个操作我们使用以区间右端点为关键字的大根堆完成。

明显过程中需要一个支持区间修改、单点查询的数据结构实时维护 $A$，本文中使用了树状数组。

```cpp
#include<queue>
#include<cstdio> 
#include<cstring> 
#include<algorithm> 
#define int long long
const int inf=1e18;
const int maxn=2e5+5;
const int LEN=(1<<20);
struct _{
	int l,r;
	bool operator<(const _ q)const{ return r<q.r; }
};
_ t;
_ p[maxn];
int a[maxn],Bit[maxn];
std::priority_queue<_>q;
int T,n,m,k,u,l,r,mid,ans,la,cnt;
inline bool cmp(_ x,_ y){ return x.l<y.l; }
inline int min(int x,int y){ return x<y?x:y; }
inline int max(int x,int y){ return x>y?x:y; }
inline int lowbit(int x){ return x&-x; }
inline void Add(int x,int k){
	for(int i=x;i<=n;i+=lowbit(i))
		Bit[i]+=k;
	return;
}
inline int Query(int x){
	int res=0;
	for(int i=x;i;i-=lowbit(i))
		res+=Bit[i];
	return res;
}
inline int nec(){
    static char buf[LEN],*p=buf,*e=buf;
    if(p==e){
        if((e=buf+fread(buf,1,LEN,stdin))==buf)
            return EOF;
        p=buf;
    }
    return *p++;
}
inline bool read(int&x){
    static char neg=0,c=nec();
    neg=0,x=0;
    while((c<'0'||c>'9')&&c!='-'){
        if(c==EOF)return 0;
        c=nec();
    }
    if(c=='-'){
        neg=1;
        c=nec();
    }
    do{x=x*10+c-'0';}while((c=nec())>='0');
    if(neg)x=-x;
    return 1;
}
inline bool check(int x){
	while(!q.empty()) q.pop();
	memset(Bit,0,sizeof(Bit));
	la=1; cnt=0;
	for(int i=1;i<=n;++i)
		Add(i,a[i]-a[i-1]);
	for(int i=1;i<=n;++i){
		while(la<=m&&p[la].l<=i) q.push(p[la++]);
		while(Query(i)<x&&q.size()){
			do{ t=q.top(); q.pop(); }
			while(t.r<i&&q.size());
			if(t.r<i||++cnt>k) return 0;
			Add(t.l,u); Add(t.r+1,-u);
		}
		if(Query(i)<x) return 0;
	}
	return 1;
}
signed main(){
	read(T);
	while(T--){
		read(n); read(m); read(k); read(u);
		l=inf; r=0;
		for(int i=1;i<=n;++i)
			read(a[i]), l=min(l,a[i]), r=max(r,a[i]);
		for(int i=1;i<=m;++i)
			read(p[i].l), read(p[i].r);
		std::sort(p+1,p+m+1,cmp);
		r+=k*u; ans=114514;
		while(l<=r){
			mid=l+r>>1;
			if(check(mid)){
				ans=mid;
				l=mid+1;
			}
			else r=mid-1;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Great_Influence (赞：10)

不知名地区省选题，难度好像有点奇怪。

首先看到题目要求最小值最大，可以使用二分答案来解决。问题转移到了check的写法。


check也不难写。先扫一遍记下所有低于二分值的数的位置，再用扫描线从左至右扫描，扫到了区间左端点就将它的右端点放入优先队列。对每个点的权值可以用树状数组维护，只需要区间加单点询问。每次遇到点权不够二分值时贪心地从优先队列里找到最靠右的右端点，区间加一遍就可以了。注意区间选择的次数限制和优先队列为空时直接返回false。

时间复杂度 $O(n\log ^2n)$。

代码：


```cpp
#include<bits/stdc++.h>
#include<cctype>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
inline void get(char &x){for(x=0;!isupper(x);x=getchar());}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}
const int MAXN=2e5+7;
static int n,m,k,pl,c[MAXN],a[MAXN],l,r;
typedef pair<int,int>Pr;
Pr p[MAXN];
#define fi first
#define se second
void init()
{
    read(n);read(m);read(k);read(pl);
    l=1e8+7;
    Rep(i,1,n)read(a[i]),Chkmin(l,a[i]);
    Rep(i,1,m)read(p[i].fi),read(p[i].se);
    sort(p+1,p+m+1);
}
vector<int>G[MAXN];
static int que[MAXN],tt;
static priority_queue<int>K;
#define lowbit(x) (x&-x)
inline void add(int pos,int x)
{for(;pos<=tt;pos+=lowbit(pos))c[pos]+=x;}
inline int query(int pos)
{static int ans;ans=0;for(;pos;pos-=lowbit(pos))ans+=c[pos];return ans;}
inline bool Chek(int lim)
{
    tt=0;
    Rep(i,1,n)if(a[i]<lim)que[++tt]=i;
    memset(c,0,sizeof c);
    while(!K.empty())K.pop();
    static int j,cnt;j=1;cnt=0;
    Rep(i,1,tt)
    {
        while(j<=m&&p[j].fi<=que[i])
            K.push((upper_bound(que+1,que+tt+1,p[j++].se)-que-1));
        while(a[que[i]]+query(i)<lim)
        {
            ++cnt;
            if(cnt>k||K.empty())return false;
            add(i,pl);
            add(K.top()+1,-pl);
            K.pop();
        }
    }
    return true;
}
void solve()
{
    static int mid;
    r=pl*k+l;
    while(l<=r)
    {
        mid=(l+r)>>1;
        if(Chek(mid))l=mid+1;
        else r=mid-1;
    }
    printf("%d\n",r);
}
int main(void){
    file();
    static int _;
    read(_);
    while(_--)init(),solve();
    //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
    return 0;
}
```

---

## 作者：Midvoy_尺 (赞：6)



## 这是一道~~搞事的~~综合题

感谢https://www.cnblogs.com/ylyvictor/p/7768972.html
提供的快读(~~此前一直没用过~~)

看到各位大佬都用树状数组(~~其实做这题时根本忘了有这~~)

鲜有用差分

于是也写了一个通俗易懂(~~蒟蒻~~)的二分+贪心+差分+堆优化代码

由"输出一个整数表示操作后序列最小值的最大值"看出

### 二分！

	l=me,r=me+(k*ad)

me为序列中最小值,作为二分左端点;me+(k*ad)表示所有区间叠到最小值上的值(答案一定在这中间)

二分出答案mid

观察题目,易观察出(~~实际上想了半天~~)

二分如何判断？

### 贪心！

贪心思路:若要使当前点i达到mid,一定~~疯狂~~加区间叠至mid,其中对后面影响最大的方案一定是r最靠右的合法(l<=i)区间;

如何找区间？

### ~~STL~~堆！

更新堆:对堆顶:过时的(r<i)删去略过，新鲜的(l<=i且未加入堆)进来;

如何修改区间?

### 差分！

当选好区间时,将本应加入区间的数加在一个变量add上,而当前点i的实际值为A=a[i]+add(这里考虑的是前区间对当前点的影响)

同时在r+1处标记减去一次操作应加的值(这里考虑的是消去前区间对当前点的影响)~~就是查分的基本操作~~

然后...没了

```cpp
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<iostream> 
#include<queue>
#define ll long long
#define MX 200005
using namespace std;
int T;
int n,m,k,ad;
int a[MX];
int b[MX];
int me;
struct node{
	int l,r;
};
node d[MX];
bool cmp(node x,node y){
	return x.l!=y.l? x.l<y.l:x.r>y.r;
}
inline int read(){
    char ch,c;
    int res = 0;
    while(ch=getchar(),ch<'0'||ch>'9')c=ch;
    res=ch-48;
    while(ch=getchar(),ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-48;
    if (c=='-')res=-res;
	return res;
}
inline bool juj(int mid){
	int add=0;
	int us=0;
	memset(b,0,sizeof(b));
	priority_queue<int> q;
	int now=1;
	for(int i=1;i<=n;++i){
		add+=b[i];
		int A=a[i]+add;
		if(A>=mid) continue;
		while(!q.empty()&&q.top()<i) q.pop();
		while(now<=m&&d[now].l<=i){
			if(d[now].r>=i) q.push(d[now].r);
			now++; //now是推过去的,所以不用担心重复选择区间
		}
		int su=(mid-A)/ad;
		if((mid-A)%ad) su++;//统计要达到mid需加上的区间数
		if(su+us>k) return false;
		us+=su;
		while(su--){
			if(!q.empty()&&q.top()>=i){
				add+=ad;
				b[q.top()+1]-=ad;
				q.pop();
			}else{
				return false;
			}
		}
	}
	return true;
}

int main(){
	//freopen("add.in","r",stdin); 
	//freopen("add.out","w",stdout);
	T=read(); 
	while(T--){
		n=read(),m=read(),k=read(),ad=read();
		me=1<<30;
		for(int i=1;i<=n;++i){
			a[i]=read();
			me=min(a[i],me);
		}
		for(int i=1;i<=m;++i){
			d[i].l=read();
			d[i].r=read();
			if(d[i].l>d[i].r) swap(d[i].l,d[i].r);//以防毒瘤数据
		}
		sort(d+1,d+m+1,cmp);
		int l=me,r=me+(k*ad);
		while(l<r){
			int mid=(r+l+1)>>1;
			if(juj(mid)){
				l=mid;
			}else{
				r=mid-1;
			}
		}
		printf("%d\n",l);
	}
	return 0;
}//看起来长,实际上..打打代码就知道有多良心
```


---

## 作者：Ebola (赞：6)


emmm……我参加了JXOI2016和JXOI2018，就是没参加2017（滚去中考了），真奇妙

考虑二分答案。二分答案之后，问题就变成了：选择不超过k个区间来操作，使得所有数都不小于mid

于是我们可以将所有区间按左端点排序，然后从左到右扫描，扫到一个点，就将左端点位于该点左侧的线段全部加入一个容器中。若该点小于mid，我们就需要在容器中拿一个区间来操作，这个点前面的所有点已经大于等于mid了，所以我们的目的是影响后面尽可能多的点，因此右端点更靠右的区间是更优的。

这样其实就确定了我们要使用的容器是堆，是一个以右端点为关键字的大根堆

若某一个数小于mid，然而堆顶元素的右端点都在mid左边了，显然check就失败了

现在我们还需要一个能支持区间加法、单点查询的数据结构，那就是树状数组。再统计一下区间加法的次数，超过k次就返回false

```cpp
#include<bits/stdc++.h>
#define FR first
#define SE second
using namespace std;

const int S=(1<<20)+5;
char buf[S],*H,*T;
inline char Get()
{
    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
    if(H==T) return -1;return *H++;
}
inline int read()
{
    int x=0;char c=Get();
    while(!isdigit(c)) c=Get();
    while(isdigit(c)) x=x*10+c-'0',c=Get();
    return x;
}

typedef pair<int,int> pii;
typedef long long LL;
const int N=200010;
pii seg[N];
int n,m,k,a;
int A[N];
LL bit[N];
priority_queue<pii> pq;

inline int lowbit(const int &x){return x&-x;}
void add(int p,int x){for(;p<=n+1;p+=lowbit(p))bit[p]+=x;}
LL qry(int p){LL res=0;for(;p;p-=lowbit(p))res+=bit[p];return res;}

bool check(int x)
{
    memset(bit,0,sizeof(LL)*(n+3));
    for(int i=1;i<=n;i++)
        add(i,A[i]),add(i+1,-A[i]);
    int p=1,ans=0;
    while(!pq.empty()) pq.pop();
    for(int i=1;i<=n;i++)
    {
        while(p<=m&&seg[p].FR<=i) pq.push(pii(seg[p].SE,seg[p].FR)),p++;
        while(qry(i)<x)
        {
            if(pq.empty()) return 0;
            pii t=pq.top();pq.pop();
            if(t.FR<i) return 0;
            add(t.SE,a);add(t.FR+1,-a);
            if(++ans>k) return 0;
        }
    }
    return 1;
}

int main()
{
    for(int T_T=read();T_T;T_T--)
    {
        int l=INT_MAX;
        n=read();m=read();k=read();a=read();
        for(int i=1;i<=n;i++) l=min(l,A[i]=read());
        for(int i=1;i<=m;i++) seg[i].FR=read(),seg[i].SE=read();
        sort(seg+1,seg+1+m);
        int r=l+k*a,mid;
        while(l<=r)
        {
            mid=(l+r)/2;
            if(check(mid)) l=mid+1;
            else r=mid-1;
        }
        printf("%d\n",check(l)?l:l-1);
    }
    return 0;
}
```



---

## 作者：I_have_been_here (赞：5)

# 题目分析

读完题目，~~大家是不是觉得脑袋有点昏~~， 但实际上，我们可以从题目中捕捉出几个要点词语：区间；最小值尽可能的大；等等，那么我们最先可以确定的算法就是二分了，那么对于每一次二分出的那一个值，我们还需要对其进行检查，这里也还需要贪心进行加区间的辅助

# 思路解析

很明显，对于每一次修改我们的区间，我们对整个区间进行修改，并且我们需要挨个检查每一个数是否大于等于我们分出来的 $mid$ ，这里可以看作单点的查询，我们可以使用树状数组的区改单查解决。注意，对于每一个可以拿来更改的区间，我们需要先以左端点为关键字排序，这样我们可以迅速找出不符合要求的左端点，这里拥有符合要求的左端点的区间我们可以将其右端点压入一个大根堆中，那么我们可以保证当前根顶元素的右端点最大，也就是覆盖的面积最多。

我们知道，要使每一个数满足要求的 $mid$ ，我们可能需要多次操作更改区间，那么在 $check$ 函数中，我们可以用一个 $p$ 数组记录下小于 $mid$ 的的下标（即需要更改的数的下标）,接下来我们对于每一个需要更改的下标不断循环地去更改，即使用 ```update(p[i], a)``` 并且 ```update(x + 1, -a)``` 可能有人会有疑问，对于可以修改的区间，不应该先 ```update(s[i].l, a)``` 吗，也就是先修改左端点向后一段，再差分解决。但是注意，我们在解决这一个点的时候，说明前面所有的点都是符合条件的，就没必要再去修改 $p_{i}$ 之前的点了。

当然对于每一次二分，只有在利用完所有可加区间之后，每一个数满足条件，那么这一个 $mid$ 才是可取的，否则无论是次数使用完了，或者是我们的队用空了，这个 $mid$ 都是不可取的。

# 树状数组细节
刚才上面提到了 **树状数组** 这个数据结构，那么对于这道题，无疑是区改单查，那么我们在构建树状数组的时候一定要差分构建，即对于每一个节点，我们加上的应该是 $b_{i} - b_{i - 1}$ ,这样在每次修改时，我们只需对一个节点修改，那么我们实际数组后面每一个点都会被修改，再利用差分就可以实现独立区间的修改。同理，在查找时，我们知道 **差分数组的前缀和是原数组** 那么树状数组的前缀求和所得的值就是这单个数的值，就可以实现单点的查询了

# AC CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
#define MAXN 200005
int lowbit(int x) { return x & (-x); }
int b[MAXN], bit[MAXN], n, m, k, a, p[MAXN];
struct node2 {
    int l, r;
    bool operator<(node2 x) const { return l < x.l; }
} s[MAXN];
void update(int x, int d) {
    for (int i = x; i <= n; i += lowbit(i)) {
        bit[i] += d;
    }
}
int sum(int x) {
    int ans = 0;
    for (int i = x; i >= 1; i -= lowbit(i)) {
        ans += bit[i];
    }
    return ans;
}
bool check(int mid) {
    priority_queue<int> q;
    while (!q.empty()) q.pop();
    for (int i = 1; i <= n; i++) {
        bit[i] = 0;
    }
    for (int i = 1; i <= n; i++) {
        update(i, b[i] - b[i - 1]);
    }
    int res = 0, tot = 0;
    for (int i = 1; i <= n; i++)
        if (b[i] < mid)
            p[++tot] = i;
    for (int i = 1, j = 1; i <= tot; i++) {
        while (s[j].l <= p[i] && j <= m) {
            q.push(s[j++].r);
        }
        while (sum(p[i]) < mid) {
            if (q.empty()) {
                return 0;
            }
            if (res >= k) {
                return 0;
            }
            int x = q.top();
            q.pop();
            update(p[i], a);
            update(x + 1, -a);
            res++;
        }
    }
    return 1;
}
int main() {
    int T;
    scanf("%d", &T);
    for (int i = 1; i <= T; i++) {
        scanf("%d%d%d%d", &n, &m, &k, &a);
        int l = inf, r = 0;
        for (int j = 1; j <= n; j++) {
            scanf("%d", &b[j]), l = min(l, b[j]), r = max(r, b[j]);
        }
        r += k * a;
        for (int j = 1; j <= m; j++) {
            scanf("%d %d", &s[j].l, &s[j].r);
        }
        sort(s + 1, s + m + 1);
        int mid, ans;
        while (l < r) {
            mid = (l + r + 1) / 2;
            if (check(mid)) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        printf("%d\n", l);
    }
    return 0;
}
```


---

## 作者：wasa855 (赞：4)

看到题目要我们求最小值最大，而且还满足单调性，可以基本确定是要二分。   
如果就是二分的话，只需要判断对于一个答案 $\text{mid}$ 是否满足答案即可。   
然后贪心地做判断，如果一个数 $a_i<mid$ 那么一定需要对含有它的区间做一次加操作。同时，为了最优，这次加操作一定要在右边能覆盖尽可能多的区域。   
那为什么不是总长度呢？因为左边的数已经满足 $a_i\geq mid$ 了，不需要给他们再加了。   
那现在的问题就是，如何在 $m$ 个区间中找到覆盖了 $a_i$ ，又在右边能覆盖最多的区域的那个。覆盖 $a_i$ 非常好办，实现排好序，枚举到 $i$ 时加入 $l$ 的值为 $i$ 的区间即可。 右边能覆盖最多也好办，拿一个堆来存着，每次取出堆顶即可。   
那么问题差不多就解决完了，最后的问题是如何做到区间加 $a$ ，同时查询每一个位置上的数，这不是树状数组2的模板吗？   
那问题就完全解决了。 时间复杂度： $O(n\log^2 n)$ （二分一个 $\log$ ，树状数组加堆判断$n\log n$），虽然 $n\leq 200000$ 范围较大，但是时限3s，还是可以通过的。   
#### 最后，祝大家神选 RP++   
代码： 
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3fffffff
int lowbit(int x)
{
	return x&(-x);
}
struct Node
{
	int l,r;
	bool operator < (const Node &x) const
	{
		if(r!=x.r)
		{
			return r<x.r;
		}
		return l<x.l;
	}
};
struct Seg
{
	int l,r;
	bool operator < (const Seg &x) const
	{
		if(l!=x.l)
		{
			return l<x.l;
		}
		return r<x.r;
	}
};
Seg seg[200005];
int dat[200005];
int t[200005];
int n,m,k,a;
void add(int u,int data)
{
	while(u<=n)
	{
		t[u]+=data;
		u+=lowbit(u);
	}
}
int get(int u)
{
	int ans=0;
	while(u>0)
	{
		ans+=t[u];
		u-=lowbit(u);
	}
	return ans;
}
bool judge(int mid)
{
//	cout<<mid<<endl;
	for(int i=1;i<=n+1;i++)
	{
		t[i]=0;
	}
	for(int i=1;i<=n;i++)
	{
		add(i,dat[i]);
		add(i+1,-dat[i]);
	}
	priority_queue<Node> q;
	int i=1,j=1;
	int res=0;
	for(;i<=n;i++)
	{
		while(seg[j].l<=i&&j<=m)
		{
			Node x;
			x.l=seg[j].l;
			x.r=seg[j].r;
			j++;
			q.push(x);
		}
		while(get(i)<mid)
		{
			if(q.empty())
			{
				return false;
			}
			if(res==k)
			{
				return false;
			}
			Node x=q.top();
//			printf("%d %d %d\n",i,x.l,x.r);
			q.pop();
			add(x.l,a);
			add(x.r+1,-a);
			res++;
		}
	}
	return true;
}
void work()
{
	cin>>n>>m>>k>>a;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&dat[i]);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&seg[i].l,&seg[i].r);
	}
	sort(seg+1,seg+m+1);
	int l=0,r=INF,mid,ans;
	while(l<=r)
	{
		mid=(l+r)/2;
//		printf("%d %d\n",mid,clock());
		if(judge(mid))
		{
			l=mid+1;
			ans=mid;
		}
		else
		{
			r=mid-1;
		}
	}
	cout<<ans<<endl;
}
int main()
{
	int T;
	cin>>T;
	for(int i=1;i<=T;i++)
	{
		work();
	}
	return 0;
}

```

---

## 作者：WZKQWQ (赞：2)

很套路但是我又觉得挺好的一道题。

首先看见最大化最小值秒想到二分答案，然后重要的就是解决 `check` 函数，区间加单点查用树状数组维护查分数组，右转 [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

怎么做呢？？？

`check(x)` 表示能不能在 $k$ 次操作以内使得每个 $A_i \geqslant x$ ，我一开始的想法是优先队列最小堆，但是我很快发现这样做不方便贪心，这里显然是要贪心的。

那就考虑 $1-n$ 一个个枚举吧！，当我们枚举到 $i$ 的时候就要保证 $A_i \geqslant x$。

前 $i-1$ 个肯定是满足大于等于 $x$ 的条件的（因为我们是从前面枚举来的），那么问题就变成了从 $i - n$ 每个都满足大于等于 $x$。贪心显然是要收益最大，考虑区间 $[l,r]$ 此时对 $r - i + 1$ 个位置加上了 $a$，显然 $r$ 越大能加的越多（前提是 $l \geqslant i$，因为我们要保证的是$A_i \geqslant x$）于是一个贪心方案就出来了。

枚举 $i$，将 $l = i$ 的区间加入一个以 $r$ 为关键字的最大堆，然后只要不满足 $A_i \geqslant x$ 就取堆顶的区间进行区间加操作。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200005;
#define int long long
struct node{
	int l,r;
}a[N];
struct way{
	int p;
	node x;
	bool operator<(const way& d)const{
		return this->p < d.p;
	}
	way(node _x,int _p):x(_x),p(_p){}
};
int n,m,k,c,T,s[N],t[N];
bool cmp(node x,node y){
	if(x.l != y.l) return x.l < y.l;
	else return x.r > y.r;
}
int lowbit(int x){return x & -x;}
void add(int x,int p){for(int i = x;i <= n;i += lowbit(i)) t[i] += p;}
int find(int x){
	int num = 0;
	for(int i = x;i >= 1;i -= lowbit(i)) num += t[i];
	return num;
}
priority_queue<way,vector<way> >q;
bool check(int x){
	while(!q.empty()) q.pop();
	memset(t,0,sizeof(t));
	for(int i = 1;i <= n;++i) add(i,s[i]),add(i + 1,-s[i]);
	int cnt = 0;
	int now = 1;
	for(int i = 1;i <= n;++i){
		while(a[now].l == i && now <= m){
			q.push(way(a[now],a[now].r));
			++now;
		}
		while(!q.empty() && find(i) < x){
			way tmp = q.top();
			q.pop();
			add(tmp.x.l,c),add(tmp.x.r + 1,-c);
			++cnt;
		}
		if(find(i) < x) return false;
	}
	return cnt <= k;
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld%lld%lld",&n,&m,&k,&c);
		for(int i = 1;i <= n;++i) scanf("%lld",&s[i]);
		for(int i = 1;i <= m;++i) scanf("%lld%lld",&a[i].l,&a[i].r);
		a[m + 1].l = a[m + 1].r = n + 1;
		sort(a + 1,a + m + 1,cmp);
		int l = 0,r = 2 * 1e8,mid,ret = 1;
		while(l <= r){
			mid = (l + r) / 2;
			//printf("%d %d %d\n",l,r,mid);
			//for(int i = 1;i <= n;++i) s1[i] = s[i];
			if(check(mid)) ret = mid,l = mid + 1;
			//for(int i = 1;i <= n;++i) s[i] = s1[i];
			else r = mid - 1;
		}
		printf("%lld\n",ret);
	}
	return 0;
}
```



---

## 作者：C20203030 (赞：2)

## 一、题目

不想多说，[点此看题](https://www.luogu.org/problem/P4064)


## 二、解法

说一下这道题的解法吧，没有什么过于复杂的地方（毕竟我都能看出来解法）。

这道一看就是要二分答案，我们考虑怎么检查$mid$。

我们先对于每个操作区间按左端点排序（本题可用前向星）。考虑处理到当前的点，将覆盖它的操作区间直接加上去，因为二分的特性我们只需要检查$mid$的可行性，为了可行我们不能落下任何一个点，所以一定要加到它不小于$mid$，我们考虑加入区间的优劣，发现只要右端点越大越好，因为我们是要在保证当前点的情况下兼顾后面的点，这个可以用优先队列维护。

思路就讲完了，其实这题感觉也不难，按着思路一步一步推就行（该贪心时就贪心），另外，这题需要打区间修改，单点查询的树状数组（会zkw的大佬请忽略），
作者就是树状数组打错了一直$Wa$。

时间复杂度就nlog方吧，目测跑的还好。


```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <algorithm>
using namespace std;
const int MAXN = 200005;
int read()
{
    int num=0,flag=1;
    char c;
    while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;
    while(c>='0'&&c<='9')num=(num<<3)+(num<<1)+(c^48),c=getchar();
    return num*flag;
}
int T,n,tot,f[MAXN],ans,m,k,A,Min;
int a[MAXN],b[MAXN];
struct node
{
 int l,r;
 bool operator < (const node &x) const
 {
  return r<x.r;
 }
}s[MAXN];
struct edge
{
    int v,next;
}e[MAXN];
priority_queue<node> q;
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int y)
{
 for(int i=x;i<=n;i+=lowbit(i))
  b[i]+=y;
}
int query(int x)
{
 int res=0;
 for(int i=x;i>=1;i-=lowbit(i))
  res+=b[i];
 return res;
}
bool check(int sta)
{
    while(!q.empty()) q.pop();
 for(int i=1;i<=n;i++)
  b[i]=0;
 for(int i=1;i<=n;i++)
  update(i,a[i]-a[i-1]);
    int cnt=0;
 for(int i=1;i<=n;i++)
 {
  int val=query(i);
  while(!q.empty() && q.top().r<i)
            q.pop();
        for(int j=f[i];j;j=e[j].next)
            q.push(s[e[j].v]);
  while(val<sta && !q.empty() && q.top().r>=i)
  {
   node t=q.top();
   q.pop();
   cnt++;
   val+=A;
            update(t.l,A);
            update(t.r+1,-A);
  }
  if(val<sta) return 0;
 }
 return cnt<=k;
}
void conquer(int l,int r)
{
 if(l>r) return ;
 int mid=(l+r)>>1;
 if(check(mid))
 {
  ans=mid;
  conquer(mid+1,r);
 }
 else
  conquer(l,mid-1);
}
signed main()
{
 T=read();
 while(T--)
 {
  Min=0x3f3f3f3f;tot=0;
  n=read();m=read();k=read();A=read();
  for(int i=1;i<=n;i++)
            f[i]=0;
  for(int i=1;i<=n;i++)
   a[i]=read(),Min=min(Min,a[i]);
        ans=Min;
  for(int i=1;i<=m;i++)
  {
   s[i].l=read();
   s[i].r=read();
            e[++tot]=edge{i,f[s[i].l]},f[s[i].l]=tot;
  }
  conquer(Min,Min+k*A);
  printf("%d\n",ans);
 }
}
```



---

## 作者：codecode (赞：2)

#### 题解：

诸如此类题目，常用手段便是二分答案。

假设我们要检验的答案是 $x$，如何快速判断能否做到将 $\min A_i$ 调整到不小于 $x$？

这即，有若干条线段，选取其中的 $k$ 条，能否满足 $i$ 处至少有若干条线段覆盖？

这便是一道经典的贪心题（的扩展），我们有如下策略

> 当目前最左边的点需要被若干条线段覆盖时，选择哪些线段最优？
>
> 显然是取右端点尽量靠右的那么多条线段，因为它们能覆盖之后更多的点。
>

我们便得到了本题的大致思路：

- 将所有线段按左端点位置递增为第一关键字，右端点位置递减为第二关键字排序；

- 二分判断能否使得 $\min A_i\geq x$；

	- 从左至右依次考虑 $j$，若 $A_i<x$, 则取当前能覆盖 $j$，且右端点最靠右的线段，并更改它所能影响到的点的值；
    
	- 更新所存储的线段，即将右端点不到 $i$ 的删去。
    
这里没有去计算 $A_i$ 所需的线段数量，而是直接执行区间加，是因为我认为区间加略好写一些（不需要考虑边界，但多一个 $\log$）（大雾）

于是，我们用堆维护当前存储的线段，并用树状数组维护数列 $A$ 的值，便可完成对二分所假设的答案的判断。

时间复杂度 $\Theta(m\log m+\log |D|(n \log n))$，这里 $D$ 是值域，范围是 $|D| \leq am$。

于是，时间复杂度为 $\Theta(m\log m+\log(am) \times n\log n)$。

------------

#### 代码：

注意细节：堆里对线段的排序方式和初始时的排序方式**不一样**！！！


```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+2333;
const int inf=233333333;
int t,n,m,k,a,ans;
int A[maxn],tree[maxn];
struct seg{
	int l,r;
	bool operator < (const seg &x) const{
		if(l==x.l)return r<x.r;
		return l<x.l;
	}
}s[maxn];
struct seg2{
	int l,r;
	bool operator < (const seg2 &x) const{
		if(r==x.r)return l<x.l;
		return r<x.r;
	}
};
void add(int x,int k){
	while(x<=n)tree[x]+=k,x+=(x&(-x));
}
int query(int x){
	int res=0;
	while(x>0)res+=tree[x],x-=(x&(-x));
	return res;
} //树状数组
int check(int x){
	for(int i=1;i<=n+1;i++)
		tree[i]=0;
	for(int i=1;i<=n;i++)
		add(i,A[i]),
		add(i+1,-A[i]);
	priority_queue<seg2>q;
	int j=1,mark=0;
	for(int i=1;i<=n;i++){
		while(s[j].l<=i&&j<=m){ //考虑所有可能的线段
			seg2 c;
			c.l=s[j].l,c.r=s[j].r;
			q.push(c);
			j++;
		}
		while(query(i)<x){
			if(q.empty())return 0; //线段不够覆盖，不行
			if(mark==k)return 0;
			seg2 d=q.top();q.pop();
			add(d.l,a);
			add(d.r+1,-a); //选择了线段后，更新其它A值
			mark++;
		}
	}
	return 1;
}
signed main(){
	cin>>t;
	while(t--){
		int e=inf;
		cin>>n>>m>>k>>a;
		for(int i=1;i<=n;i++)
			cin>>A[i],e=min(e,A[i]);
		for(int i=1;i<=m;i++)
			cin>>s[i].l>>s[i].r;
		int L=e,R=e+a*m,ans=e; //精确估计上下界
		sort(s+1,s+m+1);
		while(L<=R){
			int mid=(L+R)/2;
			if(check(mid))
				ans=mid,L=mid+1;
			else R=mid-1;
		}
		cout<<ans<<endl;
	}
	return 0;	
}
```

---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[洛谷链接](https://www.luogu.org/problem/P4064)。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难看出这道题具有这样的单调性：如果有一种操作方案使得$\min\{A_i\}\ge k$，那么必然满足有操作方案是的$\min\{A_i\}\ge k-1$。这为我们的二分提供了条件。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们二分到了一个$k=mid$，也就是要求这个$A$数组里面的每一个元素都大于$k$，那么如何贪心才是最优的呢？不难想到扫描$A$数组，并且**当一个点如果错过这个机会再也无法被覆盖的时候，我们才去用已有的可以覆盖的区间覆盖它**。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种尽量延后的策略在其它题中也有体现。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就可以基于这个思路来检查一个答案是否合理了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫描$A$数组，同时维护一个区间集合$S$。如果当前到了点$i$，则$S$里面的区间都是可以覆盖点$i$的区间。考虑扫描到了点$i$，则我们应该先维护可用的集合。然后，如果$A_i<k$，我们就得从集合里面选出区间来操作。由于每个区间的贡献是确定的，所以区间的优劣取决于它的右端点。因此我们可以维护一个根据右端点越右越优来排序的大根堆，权作集合。每次就从堆顶取区间就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区间增加一个值和单点查询的操作可以用树状数组。检查的时间是$O(n+m\log_2m)$，总时间是$O(m\log_2m\log_2ka)$（后面那个$O(\log_2ka)$是外部二分的复杂度）
# 代码
```cpp
#include <queue>
#include <cstdio>
using namespace std;

//#define __DEBUG
#define isLeaf( a ) ( segTree[a].l == segTree[a].r )

const int MAXN = 2e5 + 5, MAXM = 2e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b; 
}

struct range
{
	int l, r;
	range(){}
	range( const int L, const int R ){ l = L, r = R; }
	bool operator < ( const range & other ) const { return ! ( r > other.r ); }
}ran[MAXM];

priority_queue<range> q;

int BIT[MAXN];
int head[MAXN], nxt[MAXM];
int A[MAXN];
int N, M, K, a;

void add( const int indx, const int ID )
{
	nxt[ID] = head[indx];
	head[indx] = ID;
}

int lowbit( const int & x )
{
	return x & ( -x );
}

void update( const int indx, const int val )
{
	for( int i = indx ; i <= N ; i += lowbit( i ) ) BIT[i] += val;
}

int query( const int indx )
{
	int s = 0;
	for( int i = indx ; i ; i -= lowbit( i ) ) s += BIT[i];
	return s;
}

void clear()
{
	while( ! q.empty() ) q.pop();
	for( int i = 1 ; i <= N ; i ++ ) BIT[i] = 0;
}

bool chk( const int mn )
{
	int tot = 0;
	clear();
	for( int i = 1 ; i <= N ; i ++ ) update( i, A[i] - A[i - 1] );
	for( int i = 1 ; i <= N ; i ++ )
	{
		while( ! q.empty() && q.top().r < i ) q.pop();
        //惰性删除法，维护出右端点可达的区间
		for( int j = head[i] ; j ; j = nxt[j] ) q.push( ran[j] );
		while( query( i ) < mn && ! q.empty() && q.top().r >= i )
		{
			tot ++;
			update( q.top().l, a );
			update( q.top().r + 1, -a );
			q.pop();
		}
        //区间加值
		if( query( i ) >= mn ) continue;
		return false;
        //如果可用区间都用完了，还是没有达到要求，就说明这是无法被满足的
	}
	return tot <= K;
}

int main()
{
	int T, l, r, mid;
	read( T );
	while( T -- )
	{
		read( N ), read( M ), read( K ), read( a );
		for( int i = 1 ; i <= N ; i ++ ) head[i] = 0;
		for( int i = 1 ; i <= M ; i ++ ) nxt[i] = 0;
        //初始化不要忘了
		l = 0x3f3f3f3f;
		for( int i = 1 ; i <= N ; i ++ ) read( A[i] ), l = MIN( l, A[i] );
		for( int i = 1 ; i <= M ; i ++ ) read( ran[i].l ), read( ran[i].r ), add( ran[i].l, i );
		r = l + K * a;
		while( r - l > 1 )
		{
			mid = ( l + r ) >> 1;
			if( chk( mid ) ) l = mid;
			else r = mid - 1;
		}
		if( chk( r ) ) write( r );
		else write( l );
		putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：Na2PtCl6 (赞：1)

这题有点思维难度，挺值得做的

---
## 关键信息
- 最小值的最大值

- 区间加正整数

- 每个区间最多只能选择一次

- 恰好选 $k$ 个区间

## 分析题目
### 为什么二分
这题求最小值的最大化，初步考虑二分。

然后我们发现答案是有范围的，从 $min\lbrace a_i\rbrace$ 到 $min\lbrace a_i \rbrace+a \times k$ 都是可能的答案。

最后，考虑单调性，根据此题操作是加正整数，那么答案大一点，找到合法解起来就难一点；答案小一点，找到合法解就容易一点。

至此，我们确定用二分来得到答案。
### 如何检测答案是否合法
这就是本题的难点所在了。

根据题目要求，如果答案成立，那么答案就为 $min\lbrace a_i\rbrace$ ，所以我们的目标就是要使小于二分中点的元素增加，直到大于等于当前二分的中点。

**注意，下面是此题难点中的难点**

我们的策略是先把小于二分中点的元素的下标记录下来。然后遍历每个点，找到能覆盖它的线段，进行覆盖，直到它的值大于等于当前二分的中点或发现无法实现。

为了保证复杂度，我们要优化一些东西。我们要先对线段以 **左端点为第一关键字，从小到大；以右端点为第二关键字，从小到大** ，进行排序。这样就确定了线段的顺序。

我们用一个 **大根堆** 来维护线段的右端点。因为在能覆盖这个元素时，我们希望能覆盖更多的元素，减少成本。左端点不用维护，因为既然我们能走到现在这个元素，那么前面的元素一定被更新好了。如果有左端点小于现在元素，右端点也小于现在元素的线段该怎么办呢，即在该元素前、且覆盖不到的线段？不管。因为这是没用的线段，不会影响结果。

覆盖时用一个差分树状数组维护，我们对当前元素位置到堆顶的区间加上 $a$（左边已经处理好了，就不管） ，直到该元素值大于等于当前二分的中点或发现无法实现。覆盖完一次别忘了弹出堆顶哦。如果操作 **总共执行的次数比 $k$ 大或堆空** ，就说明无法实现。

### 如果选出的区间小于k个怎么办
我们看似没有判断这种特殊情况，但这个其实不用管。因为这题的操作是加正数，所以操作只会对答案造成贡献或不改变答案，而不会损害答案。剩下的区间反正对答案没有贡献，就随便取啊！而这题我们只要答案，所以就可以不管了。

## 代码实现
我写这题时先写了读入、排序之类的预处理，然后写二分的框架，再写树状数组，最后才写 `check` 函数。个人认为这是最佳的写代码顺序。
```cpp
#include<bits/stdc++.h>
#define il inline 
using namespace std;
const int maxn=200004;
int t,n,m,k,val,l,r,a[maxn],tree[maxn],tmp[maxn];
struct seg{
	int begin,end;
	bool operator < (const seg &comp) const{
		if(begin==comp.begin)
			return end<comp.end;
		return begin<comp.begin;
	}
}s[maxn];

il void read(int &x){
	bool f=0;char c=getchar();x=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+(c^48);
}

il const int _min(const int &a,const int &b){
	return a<b?a:b;
}

il void add(int p,int v){
	while(p<=n){
		tree[p]+=v;
		p+=p&-p;
	}
}

il int sum(int p){
	int ret=0;
	while(p){
		ret+=tree[p];
		p-=p&-p;
	}
	return ret;
}

void init(){
	l=0x3f3f3f3f;
	read(n),read(m),read(k),read(val);
	for(int i=1;i<=n;i++){
		read(a[i]);
		l=_min(l,a[i]);
	} 
	r=l+val*k;
	for(int i=1;i<=m;i++)
		read(s[i].begin),read(s[i].end);
	sort(s+1,s+m+1);
}

bool check(int mid){
	priority_queue < int > q;
	int cnt=0,tot=0,j=1;
	for(int i=1;i<=n;i++)
		if(a[i]<mid)
			tmp[++cnt]=i;
	memset(tree,0,sizeof(tree));
	for(int i=1;i<=cnt;i++){
		while(j<=m&&s[j].begin<=tmp[i])   
			q.push(upper_bound(tmp+1,tmp+cnt+1,s[j++].end)-tmp);
		while(a[tmp[i]]+sum(i)<mid){
			++tot;
			if(tot>k||q.empty())
				return 0;
			add(i,val),add(q.top(),-val);
			q.pop();
		}
	} 
	return 1;
}

signed main(){
	read(t);
	while(t--){
		init();
		int ans=0;
		while(l<=r){
			int mid=(l+r)>>1;
			if(check(mid)){
				ans=mid;
				l=mid+1;
			}
			else
				r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：1)

~~比较简单的~~一道综合题。

首先我们可以看到“最小值的最大值”，说明此题需要使用二分打法——也就是二分最小值，得出其最大值。

本题最难的内容也就是 $check(x)$ 的写法。我们可以枚举每一个小于 $x$ 的数，然后依次找到包括 $i$ 的区间，如果没有一个区间，即为第 $i$ 个数无论如何也不可能达到最小值，所以 $x$ 为最小值是不成立的。然后我们不断地使用区间增加第 $i$ 个数的值，如果加完每一个区间，这个数还是没有 $x$ 的值大，说明也是不可以的。除此之外还有一个容易忽略的错误条件：如果使用区间的数量超过了 $k$，并且还必须使用一个区间，那么就违背了题目的要求，是不行的。

最后我们用树状数组维护差分数组，既可以求到每一个数的值，还方便了我们使用区间，修改区间的操作。

为了优化，我们还可以在修改 $[l,r]$ 的时候将 $[l,n]$ 的区间变成 $[i,n]$，因为 $i$ 以前的值都不会再使用了，如果还要将 $[l,i)$ 的值进行修改，显然只有些累赘的，在卡时间的情况下这样做肯定有超时的风险。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int n,m,k,s;
int a[MAXN],c[MAXN];
struct node
{
	int l,r;
	bool operator<(const node x)const
	{
		return r<x.r;
	}
}List[MAXN];
bool cmp(node x,node y){return x.l<y.l;}
int lowbit(int x)
{
	return x & -x;
}
priority_queue<node> que;
void add(int x,int k)
{
	for(int i=x;i<=n;i+=lowbit(i))	c[i]+=k;	
}
int ask(int x)
{
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i))	ans+=c[i];
	return ans;
}
bool check(int x)
{
	while(!que.empty())	que.pop();
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++)	add(i,a[i]-a[i-1]);
	int si=1,kum=0;
	for(int i=1;i<=n;i++)
	{
		while(si<=m&&List[si].l<=i)	que.push(List[si++]);
		while(ask(i)<x&&!que.empty())
		{
			node t=que.top();
			que.pop();
			while(t.r<i&&!que.empty())
			{
				t=que.top();
				que.pop();
			}
			kum++; 
			if(t.r<i||kum>k)	return false;
			add(i,s);
			add(t.r+1,-s);
		}
		if(ask(i)<x)	return false;
	}
	return true;
}
long long ans;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		scanf("%d%d%d%d",&n,&m,&k,&s);
		int l=INT_MAX,r=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			l=min(l,a[i]);
			r=max(r,a[i]);
		}
		for(int i=1;i<=m;i++)	scanf("%d%d",&List[i].l,&List[i].r);
		sort(List+1,List+m+1,cmp);
		r+=k*s;
		while(l<=r)
		{
			int mid=(l+r)/2;
			if(check(mid))	l=mid+1,ans=mid;
			else	r=mid-1;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Tony102 (赞：1)

[Link](https://www.luogu.com.cn/problem/P4064)

[Blog阅读效果更佳](https://tony102.xyz/index.php/2021/02/18/luogu4064-jxoi2017%e5%8a%a0%e6%b3%95/)


### Sol

**总结：对于一类用贪心解决选一些区间来覆盖点（对点经行操作）的问题，可以贪心地考虑选的区间尽量往右边多贡献一点。**

现在的问题就是，给你了一些区间$[l_i,r_i]$ 和一个增加值 $val$，每个区间仅可以被选择一次，每次操作都选定一个区间并在序列上对这个区间内的数都加上$val$，现在要操作后的序列的最小值尽可能的大。只可以操作$k$次

首先看到最大化最小值这种字眼，就要二分一下这个答案。最优化问题改成判定性问题很常见。

还是对给你的区间按照左端点排序。那么现在从左往右操作。我们希望每次选定的区间右端点尽可能靠右，所以就吧区间加入一个大根堆里面，按照右端点排序即可。

特别注意的是，判定的时候一个点它可能加一次还是不满足，但是它有可能被多个区间覆盖。那么就while下去就可以了（这个bug我改了很久。


**[Code戳这里](https://tony102.xyz/index.php/2021/02/18/luogu4064-jxoi2017%e5%8a%a0%e6%b3%95/)**

---

## 作者：Harry_Hedwig (赞：0)

# 0x00 思路
>可怜有一个长度为 $n$ 的**正整数序列** $A$，但是她觉得 $A$ 中的数字太小了，这让她很不开心。

>于是她选择了 $m$ 个区间 $[l_i, r_i]$ 和两个**正整数** $a, k$。她打算从这 $m$ 个区间里选出**恰好** $k$ 个区间，并对**每个区间执行一次**区间加 $a$ 的操作。（**每个区间最多只能选择一次。**）

>对区间 $[l, r]$ 进行一次加 $a$ 操作可以定义为**对于所有 $i\in [l, r]$，将 $A_i$ 变成 $A_i + a$** 。现在可怜想要知道怎么选择区间才能让操作后的序列的**最小值尽可能的大**，即最大化 $\min_{i=1}^{n} {A_i}$。

很明显，这道题有区间加，有查询，所以可以想到用树状数组。~~不应该是线段树？~~

接着，我们可以观察到：
>让操作后的序列的**最小值尽可能的大**

因此，我们可以很容易的想到二分（因为二分就是用来解决最小值最大，最大值最小的）。
# 0x01 优化
当然，虽然我们用了二分把时间进行了一次优化，但是对于 $3000ms$ 来说，还是**太慢了**。所以我们需要进一步的优化。那么就需要我们先理解这个思路到底要我们做什么。我们二分的肯定是答案，即最小值的最大值为多少。因为我们可以对一个较大的区间去一次寻找中间值，看在满足使用 $k$ 个区间及以内这个条件的时候能否满足此答案。

现在的问题就是：我到底该怎么选择这 $k$ 个区间才能使得选择方案最优？

不好确定对不对？

既然我们没法很容易的得出最优方案，所以我们可以尝试用贪心来想一想。

当然，我们可以一个元素一个元素的去解决（使得当前元素满足答案或者无法满足），这样再去思考怎么选择区间最优不就容易了吗？

由于我们是**一个一个**元素思考的，那么在这个元素**左边的元素**一定都符合条件，所以我们为了使得用区间个数尽可能少，一定会由于贪心思想而选择区间**端点最靠右**且**未被用过的**，以尽可能减少使用区间的个数。若我们仍然无法满足二分的答案，那么就一定做不到这个值了。

当然，还可以使用优先队列再次优化时间。

# code
```c
#include<bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std;
const int N=2e5+5;
int n,q,k,a;
long long tree[N],m[N],dif[N],sum[N];
bool book[N];
typedef struct Questions//存区间
{
	int l,r;
	friend bool operator<(const Questions& a,const Questions& b)
	{
		return a.r<b.r;
	}
}ADD;
ADD sec[N];
bool cmp(ADD a,ADD b)
{
	return a.l==b.l?a.r>b.r:a.l<b.l;
}
//树状数组常规操作，没什么好说的
void add(int i,long long val,int n)
{
	while(i<=n)
	{
		tree[i]+=val;
		i+=lowbit(i);
	}
}
long long ques(int r)
{
	if(r==0)
		return 0;
	return tree[r]+ques(r-lowbit(r));
}
bool check(int x)
{
	priority_queue<ADD>Q;//用优先队列直接查找右端点最靠右的，节省时间
	int i,j,num=0;
	memset(book,0,sizeof(book));
	for(i=1;i<=n;i++)
		tree[i]=sum[i]-sum[i-lowbit(i)];
	for(i=1;i<=n;i++)
	{
		if(ques(i)>=x)
			continue;
		for(j=1;j<=q&&sec[j].l<=i;j++)
			if(sec[j].r>=i&&!book[j])//每个区间只能用一次
				Q.push(sec[j]),book[j]=1;
		while(ques(i)<x&&!Q.empty()&&num<=k)
		{
			add(Q.top().l,a,n);
			add(Q.top().r+1,-a,n);
			num++;
			Q.pop();
		}
		if(ques(i)<x||num>k)
			return 0;
	}
	return 1;
}
int ef(int l,int r)//二分
{
	if(l==r)
		return l;
	if(l==r-1)
	{
		if(check(r))
			return r;
		return l;
	}
	int mid=l+r>>1;
	if(check(mid))
		return ef(mid,r);
	return ef(l,mid-1);
}
int main()
{
	int i,j,T,l=0,r=1e9;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d %d %d %d",&n,&q,&k,&a); 
		sum[0]=0;
		for(i=1;i<=n;i++)
		{
			scanf("%lld",&m[i]);
			dif[i]=m[i]-m[i-1];
			sum[i]=sum[i-1]+dif[i];//初始化
		}
		for(i=1;i<=q;i++)
			scanf("%d %d",&sec[i].l,&sec[i].r);
		sort(sec+1,sec+1+q,cmp);
		printf("%d\n",ef(l,r));
	}
	return 0;
}
```

---

## 作者：BigJoker (赞：0)

# 0x00 前言

氧化钙，调了半天，二分假了。

前置知识：优先队列，贪心，二分，一种可以维护区间和的数据结构（线段树，树状数组...）。

# 0x01 二分

首先答案肯定是成单调性的，如果答案越大显然越难凑出来，从而我们利用二分判断答案是否可行即可。

# 0x02 贪心

贪心思路还是需要一点悟性，因为其中涉及到的贪心比较多，但也比较细致。

下面一一来分析分析。

我们假设我们需要判断的值是 $x$。

我们去枚举点，从小到大枚举。（正常人会这么想）

我们在选择区间的时候，对于已经大于了 $x$ 的 $a_i$，我们不需要加区间，直接跳过。

当 $a_i<x$ 时，需要用区间去覆盖。

因为在处理第 $i$ 个点时，前 $i-1$ 个点必然已经处理过了，所以选择区间的 $l\le i$ 就好了。

$r$ 肯定是越大越好，因为贪心的想，选择的区间有限，覆盖的越远后面肯定加的越多，所以 $l$ 合理的情况下 $r$ 越大越好。


关于 $l$ 我们可以在排序时预处理出来，没有什么好说的。

对于 $r$，我们可以采用优先队列处理。

然后对于区间加的和，用树状数组或线段树处理即可（线段树稍稍麻烦一些，且常数大，初始化复杂，这里用的是树状数组）。

最后，如果这个点加完了所有区间仍然不满足条件或者没有可行区间选择则答案不行。

# 0x03 复杂度

二分：$\log n$

二分判断函数：

* 遍历每一个点：$O(n)$

* 优先队列和树状数组：$O(\log n)$

所以复杂度是 $O({n\log^3 n})$

# 0x04 代码

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define lowbit(x) x&-x
using namespace std;
const int N=2e5+5;
const int M=2e5+5;
int n,m,k,p;
int a[N],tr[N];
struct node{
	int L,R;
	friend bool operator<(node x,node y){
		return x.R<y.R;
	}
}s[M];
bool cmp(node x,node y){
	return x.L==y.L?x.R>y.R:x.L<y.L;
}
void add(int x,int v){
	for(;x<=n;x+=lowbit(x)) tr[x]+=v;
}
int ask(int x){
	int res=0;
	for(;x;x-=lowbit(x)) res+=tr[x];
	return res;
}
bool check(int P){
	memset(tr,0,sizeof(tr));
	priority_queue<node>q;
	int dq=1,u=0;
	for(int i=1;i<=n;i++) add(i,a[i]-a[i-1]);
	for(int i=1;i<=n;i++){
		while(dq<=m && s[dq].L<=i){
			if(s[dq].R>=i) q.push((node){s[dq].L,s[dq].R});
			dq++;
		}
		while(ask(i)<P){
			if(q.empty()) return 0;
			if(u==k) return 0;
			if(q.top().L<=i && q.top().R>=i){
				u++;
				add(q.top().L,p);
				add(q.top().R+1,-p);	
			}
			q.pop();
		}
	}
	return 1;
}
int f(int L,int R){
	if(L==R) return L;
	if(L+1==R){
		if(check(R)) return R;
		return L;
	}
	int mid=(L+R)/2;
	if(check(mid)) return f(mid,R);
	else return f(L,mid-1);
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d %d %d %d",&n,&m,&k,&p);
		int amin=inf;
		for(int i=1;i<=n;i++) scanf("%d",&a[i]),amin=min(amin,a[i]);
		for(int i=1;i<=m;i++) scanf("%d %d",&s[i].L,&s[i].R);
		sort(s+1,s+1+m,cmp);
		printf("%d\n",f(0,1e8));
	}
	return 0;
} 
```

---


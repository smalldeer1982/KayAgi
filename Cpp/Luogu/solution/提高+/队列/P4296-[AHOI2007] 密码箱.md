# [AHOI2007] 密码箱

## 题目描述

在一次偶然的情况下，小可可得到了一个密码箱，听说里面藏着一份古代流传下来的藏宝图，只要能破解密码就能打开箱子，而箱子背面刻着的古代图标，就是对密码的提示。

经过艰苦的破译，小可可发现，这些图标表示一个数以及这个数与密码的关系。假设这个数是 $n$，密码为 $x$，那么可以得到如下表述： 密码 $x$ 大于等于 $0$，且小于 $n$，而 $x$ 的平方除以 $n$，得到的余数为 $1$。 小可可知道满足上述条件的 $x$ 可能不止一个，所以一定要把所有满足条件的 $x$ 计算出来，密码肯定就在其中。计算的过程是很艰苦的，你能否编写一个程序来帮助小可可呢？

## 样例 #1

### 输入

```
12```

### 输出

```
1
5
7
11```

# 题解

## 作者：JuRuo_QAQ (赞：14)

### 题意转化：给出一个数 $n$ ，求 $x^{2} \equiv 1 \pmod n$ 解的个数
原式可化为：$x^{2}-1=k \times n$ 其中 $k$ 是正整数

因式分解可得：$(x+1)(x-1)=k \times n$ 

即 $n|(x+1)(x-1)$ 

接下来就很好理解了：需要构造 $a,b$ 使 $a \times b = n$

在 $a^{2}\le n$ 范围内枚举 $a$ 并使

$a|(x-1),b|(x+1)$ 或 $a|(x+1),b|(x-1)$

注：$n=1$ 是唯一无解情况

上代码
```cpp
#include<cstdio>
#include<set>/*用 set 是为了防止重复答案，如果用数组然后 unique 去重也可以*/
typedef long long ll;//不开 long long 见祖宗
std::set<ll> s;
int main(){
	ll n;
	scanf("%lld",&n);
	if(n==1){puts("None");return 0;}//无解
	puts("1");
	for(register ll i=1;i*i<=n;i++)//枚举 a
		if(n%i==0){//如果满足条件（可以整除）
			ll a=i,b=n/a;
			for(register ll j=b+1;j<=n;j+=b)if((j+1)%i==0)s.insert(j);
			for(register ll j=b-1;j<=n;j+=b)if((j-1)%i==0)s.insert(j);
		}
	for(std::set<ll>::iterator it=s.begin();it!=s.end();it++)printf("%lld\n",*it);//用指针输出比较方便
	return 0;
}

```


---

## 作者：试试事实上吗 (赞：14)

由题意有

$x^2\equiv 1\;mod\;n$

对题目的公式进行变形

$x^2-1=k\times n$

$(x+1)(x-1)=k\times n$

由唯一分解定理，我们构造$a,b,$使

$a|(x+1),b|(x-1)$

或

$a|(x-1),b|(x+1)$

然后我们枚举$a,b,$找出所有满足条件的$x$

我们可以保证所有的$x$都被枚举。~~刘汝佳：有兴趣的读者可以自行查阅相关资料~~

$p.s.:$ 枚举时的小技巧，令$a\le b$，则枚举$a$，枚举所有满足条件的$kb+1\;or\;kb-1,\;a$只用枚举到$\sqrt n$

记得开$long\;long$~~请忽略我的#define int long long~~

$Code$

```cpp
#pragma GCC optimize(2)
#include <cstdio>
#include <iostream>
#include <set>
#include <cmath>
#define int long long
using namespace std;
set<int> st;//set去重
signed main()
{
    int n,sn,b;
    cin>>n;
    sn=sqrt(n);
    if(n==1)
    {
        puts("None");
        return 0;
    }
    st.insert(1);
    for(int i=1;i<=sn;i++)
    {
        if(n%i==0)
        {
            b=n/i;
            for(int j=b+1;j<=n;j+=b)
                if((j+1)%i==0) st.insert(j);
            for(int j=b-1;j<=n;j+=b)
                if((j-1)%i==0) st.insert(j);
        }
    }
    if(!st.size()) puts("None");
    for(set<int>::iterator it=st.begin();it!=st.end();it++)
        printf("%d\n",*it);
    return 0;
}

```

---

## 作者：lemir3 (赞：5)

## 题目分析

题目给出n,求$s.t. ~ x \in [0,n) ~ , ~ x^2 \equiv 1~ (mod ~ n)$的数量.

这里的一个套路就很显然了:

> $x^2 \equiv 1 ~ (mod ~ n) $
> $\Rightarrow x^2 -1  = kn , k \in N$

然后拆一下:

> $(x+1)(x-1) = kn , k \in N$

考虑让式子成立,让$n \mid (x+1)(x-1)$,令n=a*b,得到:

> $(x+1)(x-1) = k*a*b, k \in N$

这就好看出如果要成立,就得使$a \mid (x+1) ~\&~ b \mid (x-1)$或者$a \mid (x-1) ~\&~ b \mid (x+1)$.

在枚举x的过程中枚举出a和b判断一下就好了.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdio"
#include "cmath"
#include "cctype"
#include "iomanip"
#include "algorithm"
#include "time.h"
#include "set"
#include "map"
#include "stack"
#include "vector"
#include "deque"
#include "queue"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
const lxl maxn=100000;
lxl n;
lxl ans[maxn];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
int main(void)
{
	n=read();
	if(n==1)
	{
		printf("None\n");
		return 0;
	}
	for(R int i(1);i*i<=n;++i)
	{
		if(n%i)continue;
		lxl a=i,b=n/i;
		for(R int k(0),x;k*b+1<=n;++k)
		{
			x=k*b+1;
			if(!((x+1)%a))ans[++ans[0]]=x;
		}
		for(R int k(1),x;k*b-1<=n;++k)
		{
			x=k*b-1;
			if(!((x-1)%a))ans[++ans[0]]=x;
		}
	}
	if(!ans[0])
	{
		printf("None\n");
		return 0;
	}
	std::sort(ans+1,ans+1+ans[0]);
	ans[0]=std::unique(ans+1,ans+1+ans[0])-ans-1;
	for(R int i(1);i<=ans[0];++i)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：Viktley (赞：3)

**题目大意：**

给定 $n$，求出所有正整数 $x$，满足小于 $n$，

且 $x^2\equiv1\left(mod\;n\right)$ 将满足的 $x$ 按从小到大的顺序依次换行输出

------------

**思路：**

$x^2=kn+1$

移项发现是个平方差

即$(x+1)(x-1)=kn$

考 虑 拆 解 $k,n$ 

①$(x+1)=k_1 \times n_1$

②$(x-1)=k_2 \times n_2$

③$k_1 \times k_2=k,n_1 \times n_2=n$

发现可以枚举 $n$ 的约数 $y$，

记作其中的 $n_1$，

则有 $n_2=n/y$,$(x+1)=k1\times y$④

因为 $x<n$,$x+1<=n$，考虑枚举倍数$k_1$，

假设当前枚举倍数为 $d$

则有 $(x+1)=d \times y$

即 $x=d \times y-1$⑤

④⑤带入②，则有 $(d \times y-2)=k_2\times (n/y)$

若 $(d\times y-2)$ 为 $(n/y)$ 的倍数，则 $x=d\times y-1$ 为一组符合的解

同理可以将 $y$ 记作其中的$n_2$，即由②推①

则有 $(d\times y+2)=k1\times (n/y)$

若 $(d\times y+2)$ 为 $(n/y)$ 的倍数，则 $x=d\times y+1$ 为一组可能的解，

因为这里是 $(x-1)\to(x+1)$，$x$ 可能大于 $n$

**ps:**
1. 一组约数 $y$ , $n/y$，可能对应两个解
即 $y->x-1,(n/y)->x+1$ 或者 $y->x+1,(n/y)->x-1$
2. 枚举倍数时，选择大于 $\sqrt{n}$ 的，
不然 $\sum(k_i)$ 可能和会很大
然后对于每个枚举的 约数，
可以 $(x-1)->(x+1)$ 或者 $(x+1)->(x-1)$

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <queue>
#include <cmath>

using namespace std;

typedef long long ll;

const int N = 1e6 + 10;
ll n, ans[N], num, cnt; 
  
void Jud(ll y) 
{
	for (ll d = 0; d <= n / y; d++) 
	{
		num = (d * y - 2);
		if (!(num % (n / y))) ans[++cnt] = d * y - 1;		
		num = (d * y + 2);
		if (!(num % (n / y))) ans[++cnt] = d * y + 1;
	}
}

int main() {
	scanf("%lld", &n);
	if (n == 1) { printf("None\n"); return 0; }
	ll siz = sqrt(n);
	for(ll i = 1; i <= siz; i++) if (!(n % i)) Jud(n / i);
	sort(ans + 1, ans + cnt + 1);
	int m = unique(ans + 1, ans + cnt + 1) - ans - 1;
	int l = 1, r = m;
	while (ans[r] >= n) r--;
	while (ans[l] < 0) l++; 
	if (!(r - l + 1)) printf("None");
	else for(int i = l; i <= r; i++) printf("%lld\n", ans[i]);
}

```


---

## 作者：Aiopr_2378 (赞：2)

## 题目大意：

给定 $n$，求所有的 $x\in\mathbb{N}$，使得 $x^2\equiv1\pmod n$。

## 转换题意：

我们可以把同余式 $x^2\equiv1\pmod n$ 转换为等式 $x^2-1=kn$，其中 $k$ 为倍数。

然后我们有

$$
\begin{aligned}
x^2-1&=kn\\
(x+1)(x-1)&=kn\\
n&\mid(x+1)(x-1)
\end{aligned}
$$

根据唯一分解定理，我们有

$$

\begin{aligned}
n&\mid(x+1)\\
n&\mid(x-1)
\end{aligned}
$$
所以我们只需要构造 $a$ 和 $b$，使得 $n\mid ab$ 且 $a\mid(x+1)\;,\;b\mid(x-1)$。

## 代码构思：

我们只用在 $[1,\sqrt n]$ 的范围内枚举 $a$，此时 $b=n/a$。依次枚举即可。

只有 $n=1$ 的情况无合法 $x$。并且对于其他 $n$，$x=1$ 必定是其的合法值（算法算不出 $x=1$）。

注意算出来的 $b$ 可能有重复，可以用 `set` 在排序的同时去重；也可以在 `sort` 之后使用 `unique` 去重。

## 参考代码：

```cpp
#include<iostream>
#include<set>
using namespace std;
typedef long long ll;
set<ll> ans;
ll n;
int main(){
    cin>>n;
    if(n==1){
        puts("None");
        return 0;
    }
    puts("1");
    for(ll i=1;i*i<=n;i++){
        if(n%i==0){
            ll a=i,b=n/i;
            for(ll j=b+1;j<=n;j+=b){
                if((j+1)%i==0) ans.insert(j);
            }
            for(ll j=b-1;j<=n;j+=b){
                if((j-1)%i==0) ans.insert(j);
            }
        }
    }
    for(auto it:ans) cout<<it<<endl;
    return 0;
}
```
谢谢观看

---

## 作者：liuxy1234 (赞：2)

密码 $ a $ 大于等于 $ 0 $ ，且小于 $ n $ ，而 $ a $ 的平方除以 $ n $，得到的余数为 $ 1 $。

可以得出 $a^2\equiv 1\pmod n$


很容易看出 $a^2 - 1\equiv 0\pmod  n $

把这个公式改一下，就是$ (a - 1)(a + 1) = k*n$

我们枚举$a - 1$和$a + 1$就行了

附上代码
```cpp
#include <bits/stdc++.h>
using namespace std;

long long ans[10000];
int main(){
	std::ios::sync_with_stdio(0);
	long long n, cur = 0;
	cin>>n;
	if(n == 1)
	{
		cout<<"None";
		return 0;
	}
	for(long long i = 1;i * i <= n;i++)
	{
		if(n % i != 0)continue;
		long long a = i, b = n / i;
		
		for(register long long j = 0;j * b + 1 <= n;++j)
		{
			register long long x = j * b + 1;
			if((x + 1) % a == 0&&ans[cur - 1]!=x)
			{
				cur++;
				ans[cur] = x;
			}
		}
		for(register long long j = 1;j * b - 1 <= n;++j)
		{
			register long long x = j * b - 1;
			if((x - 1) % a == 0&&ans[cur - 1]!=x)
			{
				cur++;
				ans[cur] = x;
			}
		}
	}
	sort(ans + 1, ans + cur + 1);
	for(int i = 1;i <= cur;i++)
	{
		if(ans[i] == ans[i + 1])
		{
			ans[i] = 2000000010;
		}
	}
	sort(ans+1,ans+1+cur);
	for(int i = 1;i <= cur;i++)
	{
		if(ans[i] == 2000000010)return 0;
		cout<<ans[i]<<endl;;
	}
	return 0;
}
```

---

## 作者：青丘杨哲 (赞：2)

放在最前面的提醒：不开```long long```见祖宗！

题意：给定正整数$n$，求集合$S=\{x \; | \;x \in [0,n-1] \subset \textbf{N},\; x^2 \bmod n = 1  \}$。

而$x^2 \bmod n=1 \Leftrightarrow n\;|\;(x^2-1)  \Leftrightarrow n\;|\;(x+1)(x-1)$，故必存在$k \in [1,n] \subset \textbf{N}^{*}$，使得$(x+1)(x-1)=kn$。

设$x+1=s \cdot p$，$x-1=t \cdot q$，则必存在一种分解方式，使得$s \cdot t = k$，$p \cdot q = n$。

在枚举的时候，我们采用的方法如下：
$$
(x+1)(x-1)=s\cdot t\cdot n \Leftrightarrow x+1=t \cdot \dfrac{s\cdot n}{x-1}$$

$$\Leftrightarrow (x+1) \bmod \dfrac{s  \cdot n}{x-1}=0 $$
$$\Leftrightarrow (x+1) \bmod \dfrac{n}{\frac{1}{s}(x-1)} =0$$
该条件还有另一等价形式$(x-1) \bmod \dfrac{n}{\frac{1}{s}(x+1)} = 0$。

则只要枚举$n$的因数$p$和$k$的因数$s$，且满足$p \cdot s \leqslant n$，即可判断其是否满足要求。具体上，设$x = s \cdot p -1$，则可以得出$p = \dfrac{1}{s}(x+1)$。由于我们枚举的因数是成对的，因此枚举较大的那一部分因数（大于$\sqrt{n}$）即可。

注意，$n=1$为唯一无解的情况；若有解，则$x=1$必然包含在内。

最后对答案进行排序、去重的工作。根据$n$的约数数量上界为$2\sqrt{n}$，知算法的时间复杂度为$O(\sqrt{n} \log n)$。

参考程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN=(1e6+5);
int cnt,tot;
LL N,f[MAXN],g[MAXN];
map<LL,bool> h;
int main(){
	scanf("%lld",&N);
	if (N==1) return printf("None"),0;
	for (int i=1;i*i<=N;i++)
		if (N%i==0) f[++cnt]=(LL)(N/i);
	g[++tot]=1,h[1]=1;
	for (int i=1;i<=cnt;i++)
		for (int j=1;f[i]*j<=N;j++){
			LL p=f[i]*j-1;
			if (!((p-1)%(N/f[i]))&&!h[p])
				g[++tot]=p,h[p]=1;
			p+=2; if (p+1>N) continue;
			if (!((p+1)%(N/f[i]))&&!h[p])
				g[++tot]=p,h[p]=1;
		}
	sort(g+1,g+tot+1);
	for (int i=1;i<=tot;i++)
		printf("%lld\n",g[i]);
	return 0;
}
```

---

## 作者：SuperTNT (赞：1)

# P4296 密码箱
题目可转化为$x^2\equiv 1 \pmod n$，

移项可得$x^2-1 \equiv 0\pmod n$

根据平方差公式可以得到$(x-1)(x+1)\equiv 0 \pmod n$

设正整数$k$，使得$(x-1)(x+1)=kn$

对$n$进行分解,$n= ab$

原式最终转化为$(x-1)(x+1)=kab$

则使原式成立条件即为$(a|(x+1) \bigvee b|(x-1))\bigwedge (a|(x-1)\bigvee b|(x+1))$


在枚举$x$的时候顺便枚举$a,b$

## 注意：
1.当$x=1$时是唯一无解情况

2.记住开$long long$
```
#include <bits/stdc++.h>

typedef long long ll;

namespace TNT
{
    int b, n;

    std::set<int> st;

    inline void main()
    {
        scanf("%d", &n);

        if (n == 1)
        {
            puts("None");
            return;
        }

        st.insert(1);

        for (int a = 1; a <= sqrt(n); a++)
        {
            if (!(n % a))
            {
                b = n / a;

                for (ll i = b + 1; i <= n; i += b) //4e9会爆int
                    if (!((i + 1) % a))
                        st.insert(i);
                for (ll i = b - 1; i <= n; i += b)
                    if (!((i - 1) % a))
                        st.insert(i);
            }
        }
        for (std::set<int>::iterator i = st.begin(); i != st.end(); i++)
            printf("%d\n", *i);
        return;
    }
} // namespace TNT

int main()
{
    TNT::main();
    return 0;
}
```


---

## 作者：Zero_s (赞：0)

## 首先明确题目意思：
给出一个数 $n$，求 $x^{2} \equiv 1 \pmod n$ 解的个数。
## 推理过程：
设一个正整数 $k$。

即可以把原式化成 $x^2+1=k\cdot n$

$\because x^2+1=(x+1)\cdot(x-1)$

$\therefore(x+1)\cdot(x-1)=k\cdot n$

$\therefore n|(x+1)\cdot(x-1)$

接下来只需要构造出两个数 $p$ 和 $q$ 使得 $p\cdot q=n$ 即可。

所以，在 $p^2\le n$ 的范围内枚举满足条件的 $p$ 就好了。
## 条件：
$\because n|(x+1)\cdot(x-1),a\cdot b=n$

$\therefore a\cdot b|(x+1)\cdot (x-1)$

$\therefore$ 只要 $a$ 能整除其中任意一个且 $b$ 能整除另一个就成立了。

即 $a|(x-1),b|(x+1)$ 或 $a|(x+1),b|(x-1)$ 这两个式子。
## 无解：
解决了前面的内容，现在就要考虑哪些数是无解的了。

显然，当 $n=1$ 时，任何数 $\mod n$ 都为 $0$。

所以，只需要特判一下 $n=1$ 的情况就可以了。
## 小问题：
因为输出的答案可能会重复，那怎么办呢？

答：丢进 set 就好了。
## AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
ll n,x,_x,i,j;
set<ll> s;
int main()
{
	scanf("%lld",&n);
	if(n==1) return 0*puts("None");
	for(i=1;i<=sqrt(n);i++)
	if(n%i==0)
	{
		x=i;
		_x=n/i;
		for(j=0;j<=n;j+=_x)
		{
			if(j>=2&&!((j-2)%x)) s.insert(j-1);
			if(j<=n-2&&!((j+2)%x)) s.insert(j+1);
		}
	}
	for(set<ll>::iterator it=s.begin();it!=s.end();it++) printf("%lld\n",*it);
	return 0;
} 
```

---

## 作者：404Not_Found (赞：0)

题意：给一个正整数 $n$，找出所有的 $x$ 使得 $x^2 \equiv 1
 \pmod n $。
 
 套路题，先移项得
 
 $$x^2-1 \equiv0 \pmod n$$
 根据平方差公式得
 
 $$(x+1)(x-1)\equiv 0 \pmod n$$
 令 $n=ab(a,b \in \mathbb{N})$，则
 
 $(x+1)(x-1)\equiv 0 \pmod{ab}$
 
 改写一下
 $$(x+1)(x-1) =kab$$
 
 所以满足的条件为
 
 $(a \mid (x+1) \vee b \mid(x-1))\wedge(a \mid(x-1)\vee b\mid  (x+1))$
 
 枚举 $x$，$a$，$b$，把所有满足条件的答案丢到 `set` 里面就行了。
 
 代码：
 
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
typedef long long LL;
set<LL> ans;
LL n;
int main()
{
	scanf("%lld",&n);
	if(n==1)
	{
		puts("None");
		return 0;
	}
	puts("1");
	int k=sqrt(n);
	for(LL i=1;i<=k;i++)
		if(n%i==0)
		{
			LL a=i,b=n/i;
			for(LL j=b-1;j<=n;j+=b) if((j-1)%a==0) ans.insert(j);
			for(LL j=b+1;j<=n;j+=b) if((j+1)%a==0) ans.insert(j);
		}
	for(auto it=ans.begin();it!=ans.end();it++) printf("%lld\n",*it);
	return 0;
}
 ```

---


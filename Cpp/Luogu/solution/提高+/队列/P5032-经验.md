# 经验

## 题目背景

[赛时答疑](https://www.luogu.org/discuss/show/80694)  

**简略版已经更新，时限改为500ms**

攒够经验附魔去~~

Steve在minecraft中总是会遇上难题：
他想要修理n本附魔书，每本附魔书的等级为ai，他总是不知道铁砧修理和经验值的机制。他便在mcwiki上搜索到了一些资料：
![](https://d1u5p3l4wpay3k.cloudfront.net/minecraft_zh_gamepedia/pChart4mw/e8160a1cad02998149d79c65237dc775.png)

----图为经验值与等级的关系，摘自mcwiki 

他看到这个图，就想：我等级升的越高，我所需要的经验值便越多，那么如果我等级刚好够铁砧修理的话，那我所耗费的经验不就越少了吗？他便继续搜索了下去，并将铁砧机制附在了下面,让你帮他解决问题：

## 题目描述

**累积惩罚：**

无论是重命名、修复、还是合并操作，其经验花费都会因其物品先前在铁砧上的操作而增加，这些额外增加的花费被称作“累积惩罚”。对于一件从未放上铁砧的物品，累积惩罚为0。

一个物品每次在铁砧上操作过后（不包括重命名），其累积惩罚都会先乘2再加1。如此一来，一个物品在操作过N次后累积惩罚是2^N-1。6次操作之后，累积惩罚是63级，此时生存模式下无法再作进一步的修复和附魔工作。31次操作后，惩罚等级是2147483647级，此时在任何模式下都不能再进行操作。

当合并两个物品时，玩家会同时受到两件物品的累积惩罚。合并后物品的累积惩罚根据先前两个物品中较高者计算。例如，合并两个累积惩罚分别是3级和15级的物品会额外花费18级的惩罚经验，而合并后的物品惩罚是31级（15*2+1）。

累积惩罚甚至会作用在不会磨损的物品上，譬如附魔书。因此，合并4本时运 I 的附魔书，会得到一本累积惩罚为3的时运 III 附魔书。

     累计操作数	      惩罚

         0	           0

         1	           1

         2	           3

         3	           7

         4	           15

         5	           31

使用合成方格进行的物品修复操作会移除所有累积惩罚，但也会丢失所有的魔咒。

**合并物品：**

铁砧界面中第一格/左边的物品称为目标物品；第二格/右边的物品称为牺牲物品——合并后会消失。如果牺牲物品附有魔咒，铁砧会同时试图将牺牲物品的附魔合并至目标物品上。无论目标物品上的魔咒是否产生实际变化，铁砧都将根据目标物品与牺牲物品上的魔咒收取玩家的等级耗费。

对于牺牲物品上的每个魔咒来说：如果目标物品也拥有相同的魔咒：

当牺牲物品的魔咒等级较高时，目标物品魔咒的等级将上升至牺牲物品上的等级。

当牺牲物品的魔咒等级相同时，目标物品上魔咒的等级将提升1级，除非其等级已为最高。    

当牺牲物品的魔咒等级较低时，目标物品上该魔咒的等级不变。
    
合并物品的总花费将是下列费用之和：

1.目标物品和牺牲物品的累积惩罚之和。

2.如果同时进行重命名，则额外产生重命名的费用。

3.如果目标物品耐久度未满，则耗费2级用于维修。

4.如果牺牲物品拥有魔咒，则产生附魔费用。

5.如果牺牲物品是一本附魔书，则不会产生维修费用，铁砧会尝试将书本上的魔咒合并至目标物品上。亦可同时对目标物品进行重命名。此时的附魔花费一般会少于合并两个类似物品的费用。

-----摘自mc wiki，稍作删改

**简略版：**  
给出附魔书，只有同等等级的才能合并。合并的代价为两本书的累计代价之和。合成后的书的累计代价为合成前最大代价的2倍加上1。求最高等级和最小花费（要求最高等级为第一关键字）,Steve因为开了挂，所以最高等级不限

现给出$n$本附魔书，每本附魔书有它的等级$ai$,问如何才能得到附魔书的最大等级$x$，在此基础上，请计算合成它消耗的最小等级$y$。（我们假设每本附魔书初始的累积惩罚为1）。

Steve很懒，他不想看上面的话，他只想要让你编写出一个程序计算出$x$与$y$。但Steve为了不外传，他只要求你输出$x$在模$y$意义下的乘法逆元$k$即可。如果没有，请输出$-1$.

## 说明/提示

**样例解释**
 
第一个样例：    
合并两个第一等级的，合并花费2经验，代价升为3  
再合并两个第二等级的，花费3+1=4经验，代价升为7  
再合并两个第三等级的，花费7+1=8经验，代价升为15  
最后合并两个第四等级的，花费15+1=16经验，代价升为31  

经验总花费：2+4+8+16=30，最大等级：5


对于第一个样例: $x=5$,$y=30$;

对于第二个样例: $x=3$,$y=10$;

**数据范围**

![]( https://cdn.luogu.com.cn/upload/pic/41547.png )

保证数据随机，$x$,$y$,$k$在long int范围内

**温馨提示**

本题读入量较大，请使用较快的读入方法，在此，提供一种快速读入的样式：(需包含头文件<cctype>)

```
#include<cctype>
inline void read(int &x){
     char ch=getchar();x=0;
     while(!isdigit(ch))   ch=getchar();
     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();
}
```

## 样例 #1

### 输入

```
5
1 1 2 3 4```

### 输出

```
-1```

## 样例 #2

### 输入

```
4
1 1 1 1```

### 输出

```
7```

# 题解

## 作者：南城忆潇湘 (赞：13)

解法1：  
我有信仰，我是MC玩家，输出-1。预计得分：15.

解法2：  
我会特判，处理ai=1,n=1的情况，预计得分：15.

解法3：  
我会暴力，直接模拟。时间复杂度 $O(n^2)$ 。预计得分：30.

解法4：  
我们发现，每次只要合并最小的两本书，然后合并。再往上找。找最小的两本书可以类似于合并果子，用优先队列做就好啦。预计得分：40-95(数据居然没有卡掉，还是那个-1的点卡常卡掉的23333).

解法5：  
我们继续寻找规律，或者由合并果子的思路得来。这些附魔书合并前和合并后均有单调性，我们开两个队列就可以$O(n)$做。预计得分100.

解法6： 
由于是两本合成一本附魔书，所以最坏情况下，附魔书的最大等级为$a[i]+log_2N$，我们就可以用递归来求解。开始只要桶排求出每种附魔书有多少本就可以了。递归有点小小的难打。预计得分100.  

在这里附上50分代码和100分代码：

50pts:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int cost,lev,lei;
	friend bool operator < (Node x,Node y){
		if(x.lev==y.lev){
			if(x.cost==y.cost)	return x.lei>y.lei;
			return x.cost>y.cost;
		}
		return x.lev>y.lev;
	}
}x;
priority_queue <Node> q; 
int ans=0,cnt=214748347;
int ex_gcd(int a,int b,int &x,int &y){
    if(b==0){
        x=1,y=0;
        return a;
    }
    int e=ex_gcd(b,a%b,y,x);
    y-=x*(a/b);
    return e;
}
int main(){
	int n,qwq,orz;
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%d",&x.lev),x.lei=1,x.cost=0,q.push(x);
	Node fir;
	while(q.size()>1){
		if(q.top().lev>ans)  ans=q.top().lev,cnt=q.top().cost;
		else if(q.top().lev==ans)	cnt=min(cnt,q.top().cost);
		fir=q.top();	q.pop();
		while(q.top().lev!=fir.lev)	fir=q.top(),q.pop();
		Node nxt,sec=q.top();
		nxt.cost=fir.cost+sec.cost+fir.lei+sec.lei;
		nxt.lei=max(fir.lei,sec.lei)*2+1;
		nxt.lev=fir.lev+1;
		q.pop(); q.push(nxt); 
	}
	if(q.top().lev>ans)  ans=q.top().lev,cnt=q.top().cost;
	if(ex_gcd(ans,cnt,qwq,orz)!=1)	cout<<-1<<endl;
	else{
		qwq=(qwq%cnt+cnt)%cnt;
		cout<<qwq<<endl;
	}
	return 0;
}
```

100pts:
```
#include<queue>
#include<cstdio>
#include<iostream>
#define int long long
#define MAXN 10000200
using namespace std;
int c[MAXN+50],d[MAXN+50],cnt,ans;
int ex_gcd(int a,int b,int &x,int &y){
    if(b==0){
        x=1,y=0;
        return a;
    }
    int e=ex_gcd(b,a%b,y,x);
    y-=x*(a/b);
    return e;
}
int dg(int x){//获得一本等级为x的书的花费 
    if(d[x]){
        d[x]--;
        return 1;
    }	
    int p=dg(x-1),q=dg(x-1);
    ans+=p+q;
    return (max(p,q)*2+1) ;
}
inline void read(int &x){
    char ch;x=0;
    while(!isdigit(x))	ch=getchar();
    while(isdigit(x))	x=x*10+ch-'0',ch=getchar();
}
signed main(){
//	freopen("exp.in","r",stdin);
//	freopen("exp.out","w",stdout);
    int n,x,y;
    cin>>n;//cout<<"qwq"<<endl;
    for(int i=1;i<=n;i++){
        scanf("%lld",&x);
        d[x]++;c[x]++;
    }//cout<<"qwq"<<endl;
    for(int i=1;i<=MAXN;i++){
        c[i+1]+=c[i]/2;      c[i]%=2;
        if(c[i+1])	cnt=max(cnt,i+1);
    } //cout<<"qwq"<<endl;
    dg(cnt);
 	if(ex_gcd(cnt,ans,x,y)!=1)	cout<<-1<<endl;
    else{
        x=(x%ans+ans)%ans;
  		printf("%lld\n",x);
    }  
 //   cout<<ans<<" "<<cnt<<endl;
    return 0;
}
```

---

## 作者：Imakf (赞：8)

坑点如下

1.题目上面mc wiki的基本都是废话

2.**不要**考虑重命名、耐久等一系列东西

3.**所有**附魔书初始惩罚等级都是$1$，不要被上面的wiki骗了

~~话说出题人在比赛中途加了个简略版，方便同学理解鸭~~

~~这题目还是很水的，比赛的时候花了1小时写完了~~

你需要关注的话

1.一个物品每次在铁砧上操作过后，其累积惩罚都会先乘2再加1

2.当合并两个物品时，玩家会同时受到两件物品的累积惩罚（即相加）。

3.合并后物品的累积惩罚是较高者先乘2再加1

# 求$x$

贪心的思路，**能合并就一定要合并**。

## 程序实现

开一个桶，一旦桶里面的元素有$2$个，就这个桶就设置为$0$，下一个桶$+1$，若下一个桶也有$2$个，就重复这个操作。

~~所以说第一问还是很简单的嘛~~

# 求$y$

开另外一个桶，用来记录每一种附魔书的原始数量。

我们现在已经求出了$x$，我们知道，一个$x$可以看成两个$x-1$的附魔书合并得来的

![](https://cdn.luogu.com.cn/upload/pic/43880.png)

这就是解决第二问的关键思路

我们来分析一下样例$1$

```
5
1 1 2 3 4
```

![](https://cdn.luogu.com.cn/upload/pic/43881.png)

我们可以计算出$x=5$，那么假设我们有一本$V$级的书

它可以分成两个$IV$级的书合成的

![](https://cdn.luogu.com.cn/upload/pic/43882.png)

我们本身有一本$IV$级的书，所以可以直接用一本$IV$的书抵消

![](https://cdn.luogu.com.cn/upload/pic/43884.png)

另一本$IV级的书，可以分成两个$III$级的书合成的

我们本身有一本$III$级的书，所以可以直接用一本$III$的书抵消

![](https://cdn.luogu.com.cn/upload/pic/43885.png)

如此重复，直到

![](https://cdn.luogu.com.cn/upload/pic/43886.png)

这时候直接用两本$I$级的书合并，花费经验为$1+1=2$，合成后的$II$级书，惩罚等级为$3$(书上的粉色数字就是)。

![](https://cdn.luogu.com.cn/upload/pic/43887.png)

然后直接用两本$II$级的书合并，花费经验为$1+3=4$，合成后的$III$级书，惩罚等级为$7$。

![](https://cdn.luogu.com.cn/upload/pic/43888.png)

到最后

![](https://cdn.luogu.com.cn/upload/pic/43889.png)

花费就是所有绿色数字之和$30$

具体实现如下

```
pair<long long ,long long > dapai(long long  lv){
	//pair的第一个数存的是花费，第二个数存的是累积惩罚
	if(bucket[lv]){	//如果有就直接抵消
		--bucket[lv];
		return make_pair(0,1);
	}
	long long  cost=0,punishlv=0;
	pair<long long ,long long > first=dapai(lv-1),sec=dapai(lv-1);//递归下去完成上述算法
	cost=first.first +sec.first +sec.second +first.second;	//计算花费
	punishlv=max(first.second,sec.second)*2+1;	//更新新的累积惩罚
	return make_pair(cost,punishlv);
}
```

于是问题解决了

373ms还行

# 源代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cstdlib>
#include<cstdarg>
#include<algorithm>
#include<iostream>
#define il inline
#define rg register
#define MAXN (int (1e7+5)) 
using namespace std;
il int isdigit(char ch){
    return ch>='0'&&ch<='9';
}
il int max(long long  a,long long  b){
    return a>b?a:b;
}

inline void read(long long  &x){
     char ch;x=0;
     while(!isdigit(ch))   ch=getchar();
     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();
}
long long  n;
long long  a[MAXN];
long long  tong[MAXN];
long long  dp[MAXN];
long long  bucket[MAXN];


pair<long long ,long long > dapai(long long  lv){//a is cost b is chengfa_lv
    if(bucket[lv]){
        --bucket[lv];
        return make_pair(0,1);
    }
    long long  cost=0,punishlv=0;
    pair<long long ,long long > first=dapai(lv-1),sec=dapai(lv-1);
    cost=first.first +sec.first +sec.second +first.second;
    punishlv=max(first.second,sec.second)*2+1;
    return make_pair(cost,punishlv);
}


long long  getinv(long long  x,long long  y){
    if(y==1||y==0)	return -1;
    for(rg long long  i=2;i<=min(x,y);++i)
        if(!(x%i)&&!(y%i))	return -1;
    x%=y;
    for(rg long long  i=1;;++i){
        if(x*i%y==1)	return i;
    }
}
signed main(){
    read(n);
    if(n==1){
        puts("-1");
        return 0;
    }
    long long  x=0;
    for(rg long long  i=1;i<=n;++i){
        read(a[i]);
        ++bucket[a[i]];
        ++tong[a[i]];
        x=max(x,a[i]);
        for(rg long long  j=a[i];tong[j]>=2;++j){
            x=max(x,j+1);
            ++tong[j+1];
            tong[j]=0;
        }
    }
    //std::sort(a+1,a+1+n);
    long long  y=dapai(x).first;
    //prlong long f("%lld %lld ",x,y);
    long long  inv=getinv(x,y);
    if(inv==-1)	puts("-1");
    else printf("%lld ",inv);
    return 0;
} 
```

---

## 作者：cybber (赞：2)

有幸拜做金爷五年前出的题目，确实坑点不少，需要注意的细节非常多。学习了目前题解区的做法后，发现与本人的思路都有不同之处，斗胆将我的思路记录于此。


------------
首先本题的合成过程相当于对附魔书的等级以及代价进行修改，同时因为对合成附魔书的总消费进行了询问，因此需要对以上涉及的几个数据进行存储。这里使用了一个队列进行实现，同时重载了小于号便于直接进行排序。
```cpp
struct book
{
    int level, price, sum;
    bool operator<(book &w)
    {
        return level < w.level;
    }
}a[M], qu[2 * M];//队列要开两倍长
```
然后为了确定算法的选择，首先考虑本题的时间复杂度。由于书的极限等级可以到达 $10^7 + 30$（即一开始所有书等级均为 $10^7$ 的情况），所以需要使用时间复杂度为 $O(n)$ 的算法。为了模拟附魔书合成的过程，选择队列进行实现。

接下来就是算法的重点部分。因为使用的数据结构是队列而非优先队列，所以需要手动维护队列的有序性。首先需要明确，队列最后一定会只剩下一本最大等级的书，因为如果书的数量大于等于两本，那么书要么同等级，可以继续合成为更高等级的书，要么不同级，则可以淘汰低等级的书，最后一定只剩一本书。于是我们只需要保证队列中的书满足低等级、低代价的排列在前，那么合成过程中低代价的书会优先合成，则合成书的消费自然会更低。（其实就是贪心）

然后对于队列中书的计算过程直接按照题目处理即可。但是请注意本题中存在几个坑点（~~在出题人的指导下~~ de 了两天才过倒数第二个测试点）：
1. 队列要开原数组的两倍大小，因为两本书合成一本书，理论上按照等比数列求和，队列中的总书数会到达原书数两倍；
1. 注意在书的合成过程之中，如果原先队列中低等级的书数量为奇数，则最后会剩一本书，需要将队头加一将此书丢弃；
1. 在上一个坑点的基础上，思考一下如果此时队列中只剩一本书，此时直接进行出队操作队列就为空了，然而如果原书中还有更高等级的书没用到，就会导致这些书直接被忽略，因此在出队时需要加一个判断，判断原书的集合中是否还有没用到的书（就是这点卡了我两天 QAQ）。

最后注意 $y$ 不一定质数，不能使用费马小定理，因此需要使用扩展欧几里得算法（~~你真逆天出题人，最后还要考这个这个知识点~~这里考得好）。

代码如下：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int M = 10000010;
struct book
{
    int level, price, sum;//等级，代价，总消费
    bool operator<(book &w)
    {
        return level < w.level;//按照等级进行排序
    }
}a[M], qu[2 * M];//队列要开两倍长
int n;

int exgcd(int a, int b, int &x, int &y)//扩展欧几里得算法
{
    if(!b)
    {
        x = 1, y = 0;
        return a;
    }

    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main()
{
    ios::sync_with_stdio(false);
    cin >> n;
    for(int i = 1; i <= n; i ++ ){
        int num;
        cin >> num;
        a[i] = {num, 1, 0};//初始化书的代价为1，总消费为0
    }
    sort(a + 1, a + n + 1);

    int hh = 0, tt = -1, p = 1;
    int key = a[1].level;
    
    //队列初始化，即将最低等级的书入队
    while(p <= n && a[p].level == key)    qu[ ++ tt] = a[p ++ ];

    while(hh <= tt)//队列不为空
    {
        key = qu[hh].level;
        if(p <= n && a[p].level == key + 1)
            //将等级为队头元素加一的书入队，保证队列中只有相邻两等级的书
            while(p <= n && a[p].level == key + 1)
                qu[ ++ tt] = a[p ++ ];

        while(hh <= tt && qu[hh].level == key && qu[hh].level == qu[hh + 1].level)
        //合成书
        {
            int maxx, summ;
            maxx = max(qu[hh].price, qu[hh + 1].price) * 2 + 1;
            summ = qu[hh].sum + qu[hh + 1].sum + qu[hh].price + qu[hh + 1].price;

            qu[ ++ tt] = {qu[hh].level + 1, maxx, summ};
            hh += 2;//合成消耗的两本书出列
        }

        if(qu[hh].level == key)//最后仍然剩余一本书
        {
            hh ++ ;//该书出列

            //如果原书中仍然有没有使用到的书，将该书入队
            if(hh > tt && p <= n)     qu[ ++ tt] = a[p ++ ];
        }

    }

    //最后队列中剩余的书一定是最大等级的书，直接读取队尾书的数据
    int x = qu[tt].level, y = qu[tt].sum, k, l;

    int d = exgcd(x, y, k, l);
    if(d == 1)    cout << (k % y + y) % y;//x与y互质，x模y才存在逆元
    else    cout << -1;

    return 0;
}
```
最后感谢出题人对本人在算法学习上的帮助，**出题人你是我的神！！！**（黄门永存，阿门~~~）

---

## 作者：Alarm5854 (赞：2)

~~作为 MC 党的我自然看到题解不够就写这道题的题解了。~~

这道题目描述很长，但很多都是废话，只需要注意每次附魔的费用是两个物品的惩罚之和，新的物品的惩罚等级是原物品惩罚等级较高的两倍加一就可以了。

那么如何实现呢？要注意以下几点：

1. 由于 $n$ 很大，必须要用快读。
1. 由于附魔等级只会单调递增的，所以要先给数组排序。但 $1\le n \le 10^7$ 而 $1\le a_i \le 10^7$，所以可以用计数排序或基数排序，本题解用的是基数排序，不会的可以看我的[这篇题解](https://www.luogu.com.cn/blog/YCE-22/solution-p6038)，效率相对计数排序略低，但可扩展性更高。
1. 只有两个附魔等级相同的两个合并才是最优的，否则只会浪费经验、堆积惩罚，并不会提升附魔等级。因此，只有遇到两个附魔等级相同的才要去合并。可以维护两个单调递增的队列，第一个队列存的是原有的附魔书，初始惩罚为 $1$，消耗等级数为 $0$，而第二个队列存的是合成的附魔书。每次循环，取出最小的两本附魔书（怎么比较大小代码会说明的），并分别与目前最高等级比较，若高于目前最高等级，就同时更新最高等级和消耗的等级；否则，若等于目前最高等级，就与目前最低消耗等级比较，取较低的。接着，若两本附魔书等级相同，则合并两本附魔书，并把新的附魔书加入第二个队列的**队尾**，否则，就舍弃第一本附魔书，把第二本附魔书原路返回取出该附魔书的队列的**队首**（一定是要放在队首，我因为这个被坑过）。这样直到两个队列只剩一个元素，最后再次进行比较。
1. 求 $x$ 在模 $y$ 意义下的乘法逆元 $k$，可解同余方程 $kx \equiv 1 \pmod y$，最后解出来的 $k$，还要进行取模，否则可能大于 $y$ 或小于 $0$。

细节还是很多的，不理解的可以看以下代码：
```cpp
#include<deque>
#include<cstdio>
#include<algorithm>
#define ll long long
using namespace std;
const int N = 10000000 + 10;
FILE *fin, *fout;
inline int read(int &x) {//n很大，一定要用快读
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline int write(ll x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
struct node {
	ll lvl, val, cost;
	node(ll lvl = 0, ll val = 0, ll cost = 0): lvl(lvl), val(val), cost(cost){}
	inline friend bool operator <(node u, node v) {//比较方法，以等级为第一关键字，以总花费为第二关键字，以累计惩罚为第三关键字，都是较小时返回1
		if (u.lvl < v.lvl) return 1;
		if (u.lvl > v.lvl) return 0;
		if (u.cost < v.cost) return 1;
		if (u.cost > v.cost) return 0;
		return u.val < v.val;
	}
};
deque<node> q1, q2;//注意是双端队列
ll lvl, cost, x, y;
int n, cnt[256], a[N], b[N];
inline void radix_sort(int* s, int* t) {//基数排序，不会的看上面的链接
	for (int bit = 0; bit < 17; bit += 8) {//由于a[i]在10^7以内，所以比三次即可(10^7<2^24)
		for (int i = 0; i < 256; ++i) cnt[i] = 0;
		for (int* p = s; p < t; ++p) ++cnt[(*p >> bit) & 255];//这个地方用指针写法，更省时间
		for (int i = 1; i < 256; ++i) cnt[i] += cnt[i - 1];
		for (int* p = t - 1; p >= s; --p) b[--cnt[(*p >> bit) & 255]] = *p;
		for (int* p = s; p < t; ++p) *p = b[p - s];
	}
}
inline ll exgcd(ll a, ll b, ll& x, ll& y) {//解同余方程
	if (!b) return x = 1, y = 0, a;
	ll res = exgcd(b, a % b, x, y);
	ll z = x; x = y, y = z - y * (a / b);
	return res;
}
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin, fout = stdout;
	#else
	fin = fopen("P5032.in", "rb"), fout = fopen("P5032.out", "wb");
	#endif
	for (int i = read(n); i <= n; ++i) read(a[i]);
	radix_sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; ++i) q1.push_back(node(a[i], 1, 0));//初始化
	while (q1.size() + q2.size() > 1) {
		node u, v; int flag;//flag用于下面原路返回哪个队列
		if (!q1.empty() && (q2.empty() || q1.front() < q2.front())) u = q1.front(), q1.pop_front();
		else u = q2.front(), q2.pop_front();
		if (!q1.empty() && (q2.empty() || q1.front() < q2.front())) v = q1.front(), q1.pop_front(), flag = 1;//flag=1代表v是从q1开始取得，下面一段类似
		else v = q2.front(), q2.pop_front(), flag = 2;
		ll ul = u.lvl, uv = u.val, uc = u.cost;
		ll vl = v.lvl, vv = v.val, vc = v.cost;
		if (ul > lvl) lvl = ul, cost = uc;
		else if (ul == lvl && uc < cost) cost = uc;//更新答案
		if (vl > lvl) lvl = vl, cost = vc;
		else if (vl == lvl && vc < cost) cost = vc;
		if (ul == vl) q2.push_back(node(ul + 1, max(uv, vv) * 2 + 1, uc + vc + uv + vv));//等级相同就合并
		else if (flag == 1) q1.push_front(node(vl, vv, vc)); else q2.push_front(node(vl, vv, vc));//等级不同就返回
	}
	node u;
	if (!q1.empty()) u = q1.front();
	else u = q2.front();
	ll ul = u.lvl, uc = u.cost;
	if (ul > lvl) lvl = ul, cost = uc;
	else if (ul == lvl && uc < cost) cost = uc;
	if (exgcd(lvl, cost, x, y) != 1) write(-1LL);
	else write((x % cost + cost) % cost);
	return 0;
}
//本代码没有坑，请大家务必做到学术诚信，不要抄题解！
```

---

## 作者：rechenz (赞：1)

同机房同学找到的题，一看 $\rm tag$，什么？队列？不会怎么办？

小问题，因为我会暴力。

首先，好长的题面，直接看简要题意，可以发现我们只需要求出最大能合成到多少等级，因为数学知识薄弱，打开 $\rm python$，发现
![](https://cdn.luogu.com.cn/upload/image_hosting/i0wi8bsk.png)

既然只有 $23$ 那么我们便可以直接开一个数组（桶）来记录每个等级的附魔书出现了多少次，然后从下往上扫，便可以 $\rm O(n)$ 地求出最高能合成多大等级的附魔书。

那么下一步我们就要计算它的最小合成费用，因为合成继承的费用是两者之间的 $\rm max$ 加一，那么一个明显的贪心策略便是每次合成取两个当前费用最大的，其实这样暴力维护的话有点麻烦，但是根据递归的优先选择性其实根本不用特意维护。

```cpp
long long cal(int dep){
     if(a[dep]){
          a[dep]--;
          return 1;
     }
     int s1=cal(dep-1);
     int s2=cal(dep-1);
     y+=s1+s2;
     return (max(s1,s2)<<1)+1;
}
```
因为如果这样写的话，对于一个等级的附魔书来说一定是按照从小到大的顺序进行合并，而且因为一定是用偶数个进行合成，所以这依旧是满足我们的贪心策略的。

最后因为不保证模数为质数求逆元还要用扩展欧几里德~~说实话我觉得这很没必要~~

最后进行整体算法复杂度分析，考虑递归形成了一个满二叉树的最坏情况，叶子节点数便是 $\rm n$，那么根据树的基本知识这颗满二叉树的总节点数依旧是 $\rm n$ 量级的，所以总体算法复杂度 $\rm O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x){
     char ch=getchar();x=0;
     while(!isdigit(ch))   ch=getchar();
     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();
}
const int N=10000007;
int n,a[N],maxn,x;
long long y;

long long cal(int dep){
     if(a[dep]){
          a[dep]--;
          return 1;
     }
     int s1=cal(dep-1);
     int s2=cal(dep-1);
     y+=s1+s2;
     return (max(s1,s2)<<1)+1;
}

int ex_gcd(int s1,int s2,int &s3,int &s4){
     if(s2==0){
          s3=1;
          s4=0;
          return s1;
     }
     int temp=ex_gcd(s2,s1%s2,s4,s3);
     s4-=s3*(s1/s2);
     return temp; 
}

int main(){
     read(n);
     for(int i=1;i<=n;i++){
          int temp;
          read(temp);
          maxn=max(temp,maxn);
          a[temp]++;
     }
     int ans,temp=0,judge;
     for(int i=1;i<=maxn||temp;i++){
          temp=a[i]+temp>>1;
          x=max(x,i);
     }
     cal(x);
     judge=ex_gcd(x,y,ans,temp);
     if(judge!=1) return printf("-1"),0;
     else return printf("%lld",(ans%y+y)%y),0;
}
```


---

## 作者：Erica_N_Contina (赞：0)

## 我的博客

更多相关（或者不相关）知识点快戳：[oi-beats](https://ntsc-yrx.github.io/oi-beats/site/)，[个人博客](https://ntsc.flowus.cn/)。

## 正确题意

本题题面是不是有大问题啊？合并的时候应该是两个等级为 $i$ 的合并为一个等级为 $i+1$。为了得出正确的解，我们需要给一本书赋值 2 个属性。

- 等级 $l$

- 合并代价 $v$

合并两本书 $a,b$ 为 $c$ 后，这个合并操作的代价是 $v_a+v_b$。但是注意 $v_c=\max(v_a,v_b)\times 2+1$。

并且合并的条件是 $l_a=l_b$，那么合并后 $l_c=l_a+1$。

## 做法

求最高等级 $mx$ 就是直接从前往后扫描桶，遇到可以合并的都合并。

知道 $mx$ 后，我们就开始 dfs，求出 $mx$ 的最小代价。`dfs(x)` 返回的是合成一本等级为 $x$ 的书 $c$，的 $v_c$。

如果遇到本来就有的，我们就用本来的，并且将桶里的计数 $-1$。



最后的逆元我们使用 exgcd，这里不再赘述。

```C++
// Problem: P5032 经验
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5032
// Memory Limit: 125 MB
// Time Limit: 500000 ms
// 
// 
// 
#include<bits/stdc++.h>

using namespace std;
#define rd read()
#define ull unsigned long long
// #define int long long 
#define itn int
#define ps second 
#define pf first

int  read(){
	int x;
	cin>>x;
	return x;
}
#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() {
	cerr << endl;
}
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) {
	for (auto v: a) cerr << v << ' ';
	err(x...);
}
template<typename T, typename... A>
void err(T a, A... x) {
	cerr << a << ' ';
	err(x...);
}
#else
#define dbg(...)
#endif
const int N=2e7+5;
const ull P=137;
const int INF=1e9+7;
/*

策略


*/

int cnt[N];
int t[N];

int exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0;
		return a;
	}
	int t=exgcd(b,a%b,x,y);
	int tx=x,ty=y;
	y=tx-a/b*ty;
	x=ty;
	return t;
	
}

int ans;


int dfs(int x){
	if(cnt[x]){
		cnt[x]--;
		return 1;
	}
	int a=dfs(x-1);
	int b=dfs(x-1);
	ans+=a+b;
	return (max(a,b)*2+1);
}
signed main(){
	int n=rd;
	
	
	for(int i=1;i<=n;i++){
		cnt[rd]++;
		
	}
	memcpy(t,cnt,sizeof cnt);
	// cdbg(t[1]);
	int mx=0;
	for(int i=1;i<N;i++){
		t[i+1]+=t[i]/2;
		t[i]-=t[i]/2*2;
		if(t[i+1])mx=i+1;
	}
	
	
	dfs(mx);
	cdbg(mx,ans);
	int x,y;
	if(exgcd(mx,ans,x,y)!=1){
		cout<< -1<<endl;
		return 0;
	}
	
	cout<<(x+ans)%ans<<endl;
	return 0;
}


```

---


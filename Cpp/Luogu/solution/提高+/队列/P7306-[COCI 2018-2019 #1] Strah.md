# [COCI 2018/2019 #1] Strah

## 题目背景

任何人都会对某事感到害怕。有些怕黑，有些怕高，还有些惧怕 Vinnie Jones……

## 题目描述

Mirko 最害怕的是寻找合适的土地来种植草莓。他的土地可以用一个 $N \times M$ 的矩阵来表示。土地中有些田地适合种植草莓，而有些不适合，因为那里杂草丛生。

Mirko 正在寻找一块合适矩形。当土地中有一块矩形区域包含的所有田地均适合种植草莓，则该矩形被称为合适矩形。

Mirko 还对所有田地的潜力值感兴趣。一块田地的潜力值定义为包含该田地的合适矩形的个数。

求 Mirko 所有田地的潜力值之和。

## 说明/提示

#### 样例 1 解释

下列矩阵代表各个田地的潜力值。所有田地潜力值总和为 $8$。

|$2$|$0$|$1$|
| :----------: | :----------: | :----------: |
|$3$|$2$|$0$|

#### 数据规模与约定

对于 $20\%$ 的数据，$1 \le N,M \le 10$。

对于另外 $30\%$ 的数据，$1 \le N,M \le 300$。

对于 $100\%$ 的数据，$1 \le N,M \le 2000$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #1](https://hsin.hr/coci/archive/2018_2019/contest1_tasks.pdf)  _T4 Strah_。**

## 样例 #1

### 输入

```
2 3
.#.
..#```

### 输出

```
8```

## 样例 #2

### 输入

```
3 3
...
...
...```

### 输出

```
100```

## 样例 #3

### 输入

```
3 4
..#.
#...
...#```

### 输出

```
40```

# 题解

## 作者：YYJ23 (赞：12)

# 题意

见 [link](https://www.luogu.com.cn/problem/P7306)

# 分析
 
最后统计面积时，实现上各种加加减减，绕晕了。

做这题之前，建议先完成 P6404，参考 [P6404题解](https://www.luogu.com.cn/blog/2005-00-88-wyk/solution-p6404)。

以下这种代码实现步骤最清晰。按列或按行分别统计均可，此处按列统计。

- 1. 先预处理出每个点往左能延伸的宽度 $le[i][j]$ 。
- 2. 按列遍历每个点。
  - 2.1. 保证递增的单调栈，否则出栈操作；
  - 2.2. 入栈
  - 2.3. 统计面积：见例子。


## 样例
以第 4 列第 6 行作为矩形右下角为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/uxfsine6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


### 1. 栈初始状态：

$le[6][4] = 3$ ，出栈入栈后栈状态如下，其中宽最大值 $Wmax$ 即对应往左延伸宽度。

![](https://cdn.luogu.com.cn/upload/image_hosting/mjzh20zr.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

### 2. 循环遍历栈，统计面积：

#### 2.1 遍历第一步

当前行 $i = 6$ ，遍历行 $pre = 6$ ，宽最大值 $Wmax = 3$ ，比遍历行宽度小的前一行下标为 $next=3$ 。

所以宽 $= [1,Wmax] = [1,3]$ ，高 $= (i-pre, i-next] = (0,3]$ 。

因为当高为 $1$ ，宽的范围为 $[1, Wmax]$ 时，面积和 $= ($ 首项 $1+$ 尾项 $Wmax) \times ($ 项数 $Wmax) \div 2$ ，

所以高 $= (i-pre, i-next] = (0,3]$ 时，即高 $= 1,2,3$ ，当前行增加面积和 $add= (1+3) \times 3 \div 2 \times [(3+1) \times 3 \div 2 - (0+1) \times 0 \div 2] = 36$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/6b50yjrl.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![](https://cdn.luogu.com.cn/upload/image_hosting/w6uphzk5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


#### 2.2 遍历第二步

同理，当前行 $i = 6$ ，遍历行 $pre = 3$ ，宽最大值 $Wmax = 2$ ，比遍历行宽度小的前一行下标 $next = 2$ 。

宽 $=[1,2]$ , 高 $=(i-pre, i-next]=(3,4]$ , 当前行面积和 $add=(1+2) \times 2 \div 2 \times [(4+1) \times 4 \div 2 - (3+1) \times 3 \div 2]=12$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/bxndfo3h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![](https://cdn.luogu.com.cn/upload/image_hosting/pzn7yq5a.png?x-oss-process=image/resize,m_lfit,h_170,w_225)



# 代码

```
#include<bits/stdc++.h>
using namespace std;

const int N = 2005;
int n, m;
char a[N][N];
int le[N][N];
long long sum = 0;

int cal(int l, int r){
	return r*(r+1)/2 - l*(l+1)/2;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	//1. 输入并预处理出每个点往左能延伸的宽度le[i][j]
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			cin >> a[i][j];
			le[i][j] = a[i][j] == '.' ? le[i][j-1] + 1 : 0;
		}
	}
	//2. 按列遍历
	vector<int> stk;
	for(int j = 1; j <= m; j++){
		stk.clear();
		stk.push_back(0);
		for(int i = 1; i <= n; i++){
			//2.1 保证递增的单调栈，否则出栈操作
			while(stk.size() > 1 && le[stk.back()][j] >= le[i][j]) stk.pop_back();
			//2.2 入栈
			stk.push_back(i);
			//2.3 统计
			for(int k = stk.size() - 1; k >= 1; k--){
				int pre = stk[k];
				long long add = 1ll * le[pre][j] * (le[pre][j] + 1) / 2 * cal(i - pre, i - stk[k - 1]);
				sum += add;							
			}
		}
	}
	
	cout << sum << endl;
	return 0;
} 
```

---

## 作者：Nuyoah_awa (赞：8)

### 题目大意

给定一个棋盘，求其中所有全由 `.` 组成的矩形面积和。

### 题目分析

先想暴力，可以暴力枚举右下角 $(x_1, y_1)$，然后枚举左上角的横坐标坐标，然后可以知道左上角纵坐标的范围，因为范围一定连续，运用等差数列求面积即可，时间复杂度 $\mathcal O(n^3)$。

然后考虑优化掉左上角横坐标的枚举，我们发现对于一个右下角，可选左上角的范围一定是类似阶梯状的，即成单调。容易想到用单调栈优化，根据每个点上方最靠下的不可选点，可以得到梯状范围，然后考虑怎么算贡献。

我们先从简单情况考虑，若可选区域为矩形，则与每个左上角所形成矩形面积如图。

![](https://s21.ax1x.com/2024/08/28/pAAMDzQ.jpg)

考虑不规则图形，则面积依旧为所列表格上数字和。

![](https://s21.ax1x.com/2024/08/28/pAAM0JS.jpg)

我们令这个行列数想成的表为贡献表，则每个梯状区域的贡献即为形状对应于表格上的值之和。我们考虑如何快速算出每个梯状区域的贡献和，这个时候再去枚举显然就退化成暴力了，于是可以想到可以由前继状态推得，如下图，我们可以看为前继状态增加了若干增量，这个方法明显可行，数学推式子即可。

![](https://s21.ax1x.com/2024/08/28/pAAMBRg.jpg)

但是这个算法既不好推也不好写，容易算漏。所以我们可以考虑拆贡献，对于每个左上角，我们在单调栈中弹出时即为这个点对后续右下角没贡献了于是我们可以计算这一堆左上角对于已经枚举到的右下角所形成的贡献。

![](https://s21.ax1x.com/2024/08/28/pAAMyss.jpg)

我们拆成一行行看，对于其中一行，其在贡献表上对于每格贡献的系数是形似 $1\sim x$ 的一个数列。

![](https://s21.ax1x.com/2024/08/28/pAAM6Ln.jpg)

于是我们不妨对于每个梯状区域，我们拆成若干个矩形，对于每个矩形如上述方法对贡献表乘上系数。

![](https://s21.ax1x.com/2024/08/28/pAAMsMj.jpg)

我们令

$$a_{i,j} = i\times j$$

为贡献表，再计算

$$s_{i,j} = \sum\limits_{k=1}^{k\le j} a_{i,k}$$

为贡献表横向前缀和。则

$$g_{i,j} = \sum\limits_{k=1}^{k\le j} s_{i,k}$$

为对于每个左上角所在行乘上系数后的贡献和。令

$$f_{i,j} = \sum\limits_{k=1}^{k\le i} g_{k,j}$$

为对于贡献和的纵向前缀和则对于一个矩形 $(x_1,y_1)(x_2,y_2)$，其贡献总和为 $w_{x_1,y_1} - w_{x_1,y_{2}-1}$。

则可 $\mathcal O(1)$ 计算贡献和。总时间复杂度为 $\mathcal O(n\times m)$。

### code

PS：赛时怕数组太大 MLE，$4$ 个数组实际只开了两个，滚动用的。

```cpp
#include <iostream>
#include <cstdio>
#include <stack>
#define LL long long

using namespace std;

const int N = 2e3 + 5;
int n, m, f[N][N], i, j;
LL ans, a[N][N], t[N][N];
string s[N];
struct node{
    int val, lf;
}now, tmp;
stack <node> q;

int main()
{
    scanf("%d %d", &n, &m);
    for(i = 1;i <= n;i++)
    {
        cin >> s[i];
        s[i] = "*" + s[i];
        for(j = 1;j <= m;j++)
        {
            if(s[i][j] == '#')  f[i][j] = 0;
            else f[i][j] = f[i-1][j] + 1;
        }
    }
    for(i = 1;i <= n;i++)
        for(j = 1;j <= m;j++)
            a[i][j] = i * j;
    for(i = 1;i <= n;i++)
        for(j = 1;j <= m;j++)
            t[i][j] = t[i][j-1] + a[i][j];
    for(i = 1;i <= n;i++)
        for(j = 1;j <= m;j++)
            a[i][j] = a[i][j-1] + t[i][j];
    for(i = 1;i <= n;i++)
        for(j = 1;j <= m;j++)
            t[i][j] = t[i-1][j] + a[i][j];
    for(i = 1;i <= n;i++)
    {
        for(j = 1;j <= m;j++)
        {
            now.val = f[i][j], now.lf = j;
            while(!q.empty() && q.top().val >= now.val)
            {
                tmp = q.top();
                q.pop();
                now.lf = tmp.lf;
                ans += t[tmp.val][j-tmp.lf];
                ans -= t[max(q.empty()?0:q.top().val, now.val)][j-tmp.lf];
            }
            q.push(now);
        }
        while(!q.empty())
        {
            tmp = q.top();
            q.pop();
            ans += t[tmp.val][m+1-tmp.lf];
            ans -= t[q.empty()?0ll:q.top().val][m+1-tmp.lf];
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：船酱魔王 (赞：4)

## 题意回顾

在给定的 $ n \times m $ 的障碍网格中，求出包含每个格子的无障碍矩形的个数的和。

$ 1 \le n, m \le 2000 $。

## 分析

考虑进行题意转化，每个格子被一个矩形包含的贡献为 $ 1 $，则每个矩形的贡献为这个矩形的面积，我们只需要求所有无障碍矩形的面积和即可。

网格问题不好统计，我们考虑化网格为序列，枚举矩形的上下边界，则在边界范围内的所有格子均无障碍的列才可被矩形包含，这样的矩形面积之和只取决于每个连续段的长度，可以用维护连续段的方法解决。

当我们确定上边界时，下边界不断向下延伸，每次延伸只需要找到所有障碍将障碍所在列「打断」，计算出被打断的连续段长度和被分出来的连续段长度即可。对于每个上边界，我们都需要扫描一遍整个矩阵，复杂度是 $ O(n^3) $ 的。

我们发现每列只会被「打断」一次，可以把上边界从最底下开始不断向上提升，这样的话如果一个障碍在某一个上边界上已经不是首次「打断」这一列的障碍，那么之后更高的上边界它也不再会发挥「打断」作用。可以用循环队列维护每一行的还有效的障碍位置，这样每个障碍只会「打断」和被清除各最多一次，时间复杂度为 $ O(n^2 \log n) $（这里认为 $ n,m $ 同阶）。

### 实现细节

* 使用 `getchar` 读入。

* 注意循环枚举障碍时，队列的长度要在枚举前记录，否则清除障碍可能导致一些障碍重复枚举。

* 单点修改可以循环迭代代替递归，对于细节常数优化很有效。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#define ll long long
using namespace std;
const int N = 2005;
int n, m;
char a[N][N];
queue<int> que[N];
int buc[N];
int iid[N];
struct node {
    int sz;
    int lf, rt;
} d[N * 4];
inline node operator+(node p1, node p2) {
    node res;
    res.lf = p1.lf + (int)(p1.lf == p1.sz) * p2.lf;
    res.rt = p2.rt + (int)(p2.rt == p2.sz) * p1.rt;
    res.sz = p1.sz + p2.sz;
    return res;
}
void build(int s, int t, int p) {
    if(s == t) {
        d[p] = (node){1, 1, 1};
        iid[s] = p;
        return;
    }
    int mid = (s + t) >> 1;
    build(s, mid, p * 2);
    build(mid + 1, t, p * 2 + 1);
    d[p] = d[p * 2] + d[p * 2 + 1];
}
node query(int l, int r, int s, int t, int p) {
    if(l <= s && t <= r) return d[p];
    int mid = (s + t) >> 1;
    node ans = (node){0, 0, 0};
    if(l <= mid) ans = ans + query(l, r, s, mid, p * 2);
    if(mid < r) ans = ans + query(l, r, mid + 1, t, p * 2 + 1);
    return ans;
}
ll col[N];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= i; j++) col[i] += (ll)j * (i + 1 - j);
    }
    for(int i = 1; i <= n; i++) {
    	for(int j = 1; j <= m; j++) {
    		a[i][j] = getchar();
    		while(a[i][j] != '.' && a[i][j] != '#') a[i][j] = getchar();
		}
	}
    ll ans = 0;
    for(int s = n; s >= 1; s--) {
        for(int i = 1; i <= m; i++) buc[i] = 0;
        for(int i = 1; i <= m; i++) {
            if(a[s][i] == '#') que[s].push(i);
        }
        build(1, m, 1);
        ll now = col[m];
        for(int t = s; t <= n; t++) {
            for(int i = que[t].size(); i >= 1; i--) {
                int u = que[t].front();
                que[t].pop();
                if(buc[u]) continue;
                que[t].push(u);
                buc[u] = 1;
                int x = query(1, u, 1, m, 1).rt;
                int y = query(u, m, 1, m, 1).lf;
                int tid = iid[u];
                d[tid] = (node){1, 0, 0};
                while(tid > 1) tid /= 2, d[tid] = d[tid * 2] + d[tid * 2 + 1];
                now -= col[x + y - 1];
                now += col[x - 1] + col[y - 1];
            }
            ans += now * (t - s + 1);
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Feyn (赞：3)

[link](https://www.luogu.com.cn/problem/P7306)

在写这道题之前建议先写一下[这道题](https://www.luogu.com.cn/problem/P6404)，对这道题有很大的帮助，本题的解法基于那道题，所以本文不会对单调栈部分做过多解释，因为所有内容都可以在那道题的题解中找到。

首先这道题需要转换一下思路，题目中要求的是每个点被覆盖次数之和，由于每个矩形可以覆盖它面积那么多个点各一次，所以问题就变成了求所有合法矩形的面积之和，这和那道题比较像了，不同点在于那道题求的是合法矩形的数量。但其实我们可以利用那道题的思路，通过单调栈来维护然后每个矩形在右下角那个点进行贡献。考虑推一下式子，假设 $num$ 是某个点为右下角的合法矩形的数量，而 $x$ 是这些矩形的行数集合（从上到下第几行的意思），$y$ 同理表示第几列，$a,b$ 代表当前点的行数和列数，那么这些矩形对答案的贡献会是：

$$\sum\limits_{i=1}^{num}(a-x_i+1)(b-y_i+1)$$
$$=\sum\limits_{i=1}^{num}ab-ay_i+a-bx_i+x_iy_i-x_i+b-y_i+1$$
$$=num(ab+a+b+1)-\sum\limits_{i=1}^{num}x_iy_i-(b+1)\times\sum\limits_{i=1}^{num}x_i-(a+1)\sum\limits_{i=1}^{num}y_i$$

发现我们需要额外维护的就是单调栈内所有合法的右上点的行数之和、列数之和和行数列数乘积的和，而这些是很好维护的，只要理解了那道题的单调栈的原理就可以很容易维护。

总结一下流程：

- 通过递推的方式求出每个点最多向左延申的长度。
- 对每一列从上到下扫描，同时维护单调栈。
- 根据上面的公式来计算每个点作为左下点时的贡献。

通过这种思路写出来的代码会有些繁琐，但其实也还好。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define int long long
const int N=2010;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,n,l[N][N];
char w[N];
bool a[N][N];

struct node{int pl,len;}st[N];
int an,x,y,xy,top;//an是题解中的num，x,y,xy维护的是行和、列和和行列积和 
inline int p(int ll,int rr){return (ll+rr)*(rr-ll+1)/2;}
inline int q(int ll,int rr,int num){return (ll+rr)*num/2;}
inline void insert(node wh,int now_y){
	while(top&&st[top].len>=wh.len){
		an-=st[top].len*(st[top].pl-st[top-1].pl);
		x-=p(st[top-1].pl+1,st[top].pl)*st[top].len;
		y-=p(now_y-st[top].len+1,now_y)*(st[top].pl-st[top-1].pl);
		xy-=q((st[top-1].pl+1)*p(now_y-st[top].len+1,now_y),
			   st[top].pl*p(now_y-st[top].len+1,now_y),st[top].pl-st[top-1].pl);
		top--;//维护单调栈的性质 
	}
	st[++top]=wh;if(top==1)return;
	an+=st[top].len*(st[top].pl-st[top-1].pl);
	x+=p(st[top-1].pl+1,st[top].pl)*st[top].len;
	y+=p(now_y-st[top].len+1,now_y)*(st[top].pl-st[top-1].pl);
	xy+=q((st[top-1].pl+1)*p(now_y-st[top].len+1,now_y),
		   st[top].pl*p(now_y-st[top].len+1,now_y),st[top].pl-st[top-1].pl);
}

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);read(n);
	for(int i=1;i<=m;i++){
		scanf("%s",w+1);
		for(int j=1;j<=n;j++){
			a[i][j]=w[j]=='#';
			l[i][j]=a[i][j]?0:l[i][j-1]+1;
		}
	}
	
	int ans=0;
	for(int i=1;i<=n;i++){
		top=an=x=y=xy=0;insert((node){0,0},i);
		for(int j=1;j<=m;j++){
			insert((node){j,l[j][i]},i);
			ans+=an*j*i-i*x-j*y+xy;
			ans+=an*(i+j+1)-x-y;//如题计算答案 
		}
	}
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：Refined_heart (赞：2)

### 题目大意

题面很清晰。

### $\text{Solution:}$

首先是第一步转化：对每个点求答案太麻烦了，不妨直接计算每个矩形对答案的贡献，也就是它的**面积**。于是问题转化为求所有矩形的面积和。

考虑如何不重不漏计算每个矩形。那我们不妨确定一个边界，这样计算出来的就不会错了。

考虑枚举下边界，然后计算答案。发现我们可以把图形划分成若干块，我们只需要计算这些块作为上边界对答案的贡献就好了。

首先我们要把图形划分为 $O(n)$ 个块，这样才能保证复杂度。

至于如何划分，我们不难想到单调栈/笛卡尔树。

下面考虑计算答案。由简入繁，我们先考虑宽度为 $w,$ 高度为 $1$ 的矩形的贡献。

如果以下边界为底，那么一个长为 $i$ 的矩形（这里也就是面积为 $i$ ）就会有 $(w-i+1)$ 种选择。于是列出来式子就是

$$
\sum_{i=1}^w i(w-i+1)
$$

展开来写就是

$$
\left((w+1)\sum_{i=1}^w i\right)-\sum_{i=1}^w i^2
$$

这个东西显然可以 $O(1)$ 计算。

那么，如果我们现在限制高度在 $[x,y]$ 区间内部，要求计算所有的贡献呢？

考虑将一个高度为 $1$ 的矩形拉高，那么相应的面积就会乘一个 $x.$ 于是我们考虑设上面计算的面积为 $f(w),$ 那么高度在这个范围内的话，贡献就是：

$$
\sum_{i=x}^y i\cdot f(w)
$$

也就是 

$$
f(w)\sum_{i=x}^y i
$$

也就是

$$
f(w)\frac{(x+y)(y-x+1)}{2}
$$

有了这个式子就好算了。先计算出来 $up[i][j]$ 表示这个点向上可以延申多少。维护关于这个东西的递增单调栈。然后就可以划分若干个矩形了。

注意划分矩形的原则是，保证当前栈里面存储的所有矩形连续并且高递增。计算答案就相当羽从上往下删掉划分的矩形，也需要满足删掉之后的图形连续并且高递增。

其他的就是代码细节了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
#define int long long
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
#define poly vector<int>
#define Bt(a) bitset<a>
#define bc __builtin_popcount
#define pc putchar
#define ci const int&
const int mod = 998244353;
const db eps = 1e-10;
inline int Max(ci x, ci y) {return x > y ? x : y;}
inline int Min(ci x, ci y) {return x < y ? x : y;}
inline db Max(db x, db y) {return x - y > eps ? x : y;}
inline db Min(db x, db y) {return x - y < eps ? x : y;}
inline int Add(ci x, ci y, ci M = mod) {return (x + y) % M;}
inline int Mul(ci x, ci y, ci M = mod) {return 1ll * x * y % M;}
inline int Dec(ci x, ci y, ci M = mod) {return (x - y + M) % M;}
typedef pair<int, int> pii;
inline int Abs(int x) {return x < 0 ? -x : x;}
//char buf[1<<21],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char Obuf[105000],*O=Obuf;//Siz shoule be the size of Out File
int pst[30],ptop;
inline void Fprint(){fwrite(Obuf,1,O-Obuf,stdout);}
inline void Fwrite(int x){
  if(x==0){*O++='0';if(O-Obuf>100000)Fprint(),O=Obuf;return;}
  if(x<0)*O++='-',x=-x;ptop=0;
  while(x)pst[++ptop]=x%10,x/=10;
  while(ptop)*O++=pst[ptop--]+'0';
  if(O-Obuf>100000)Fprint(),O=Obuf;
}
inline int read() {
    int s = 0, w = 1;
    char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') w = -1;ch = getchar();}
    while (isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
    return s * w;
}
inline void write(int x) {
    if (x < 0)putchar('-'), x = -x;
    if (x > 9)write(x / 10);
	pc(x % 10 + '0');
}
inline int qpow(int x, int y) {
    int res = 1;
    while (y) {if (y & 1)res = Mul(res, x);x = Mul(x, x);y >>= 1;}
    return res;
}
inline void cadd(int &x, int y) {x += y;}
inline void cmul(int &x, int y) {x *= y;}
inline void cmax(int &x, int y) {x = Max(x, y);}
inline void cmin(int &x, int y) {x = Min(x, y);}
const int N = 2001;
namespace Refined_heart{
	int n,m,a[N][N];
	char s[N];
	int up[N][N];
	int st[N],top;
	int calc(int x){
		return x*(x+1)/2*(x+1)-x*(x+1)*(x+x+1)/6;
	}
	void solve(){
		n=read();m=read();
		for(int i=1;i<=n;++i){
			cin>>(s+1);
			for(int j=1;j<=m;++j)a[i][j]=(s[j]=='.');
		}
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(a[i][j])
					up[i][j]=up[i-1][j]+1;
		int ans=0;
		for(int i=1;i<=n;++i){
			top=0;st[0]=0;
			for(int j=1;j<=m;++j){
				int wide=0;
				while(top&&up[i][st[top]]>=up[i][j]){
					int low=Max(up[i][j]+1,up[i][st[top-1]]+1);
					int uph=up[i][st[top]];
					wide+=st[top]-st[top-1];
					int sum1=calc(wide);
					int res=sum1*(low+uph)*(uph-low+1)/2;
					ans+=res;
					--top;
				}
				st[++top]=j;
			}
			st[0]=0;
			int wide=0;
			while(top){
				wide+=st[top]-st[top-1];
				int low=up[i][st[top-1]]+1;
				int uph=up[i][st[top]];
				int sum1=calc(wide);
				int res=sum1*(low+uph)*(uph-low+1)/2;
				ans+=res;
				--top;
			}
		}
		cout<<ans<<'\n';
	}
}
signed main(){
	Refined_heart::solve();
	return 0;
}
```


---

## 作者：JimmyLee (赞：1)

分享一个 $O(nm\log m)$ 的方法。

# 分析

考虑每次在 $x$ 轴上固定左端点，然后移动 $x$ 轴上的右端点，并统计答案。

考虑如何统计一个 $1\times n$ 的区域的贡献。

显然长度为 $i$ 的区间有 $n-i+1$ 个，所以贡献即为：

$$
\begin{aligned}
f(n)=&\sum^n_{i=1} i\left(n-i+1\right) \\
=&\sum^n_{i=1} \left(n+1\right)i-i^2 \\
=&\left(\left(n+1\right)\sum^n_{i=1} i\right)-\left(\sum^n_{i=1} i^2\right) \\
=&\left(\left(n+1\right)\frac{n\left(n+1\right)}{2}\right)-\frac{n\left(n+1\right)\left(2n+1\right)}{6} \\
=&\frac{n\left(n+1\right)^2}{2}-\frac{n\left(n+1\right)\left(2n+1\right)}{6} \\
=&\frac{n\left(n+1\right)\left(n+2\right)}{6} \\
\end{aligned}
$$

所以 $x$ 轴左端点为 $l$，右端点为 $r$，高度为 $h$ 的矩形区域的贡献为 $(r-l+1)\cdot f(h)$。

用 $m$ 个 `deque` 来记录 $y=m$ 的不适宜种植的格子的位置，再用一个 `set` 记录当前被占用的格子的位置。

每次移动 $r$ 都先将 $x=r$ 的不适宜种植的格子加入 `set` 中，然后统计答案。

时间复杂度 $O(nm\log m)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 2003

deque<int> lx[maxn];

int64_t f(int64_t n) {return n*(n+1)*(n+2)/6;}
string str;
set<int> s;
vector<int> dts[maxn];

int main()
{
    int n, m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>str;
        for(int j=1;j<=m;j++)
            if(str[j-1]=='#') lx[j].emplace_back(i);
    }
    int64_t ans=0;
    for(int i=1;i<=m;i++) lx[i].emplace_back(n+1);
    for(int l=1;l<=n;l++)
    {
        s.clear();
        s.emplace(0);
        s.emplace(m+1);
        int64_t sum=f(m);
        for(int i=l;i<=n;i++) dts[i].clear();
        for(int i=1;i<=m;i++) 
            if(lx[i].front()==l-1) lx[i].pop_front();
        for(int i=1;i<=m;i++) 
            dts[lx[i].front()].emplace_back(i);
        for(int r=l;r<=n;r++)
        {
            for(auto p:dts[r])
            {
                auto nxt=s.lower_bound(p);
                auto pre=prev(nxt);
                sum-=f(*nxt-*pre-1);
                sum+=f(*nxt-p-1);
                sum+=f(p-*pre-1);
                s.emplace(p);
            }
            ans+=sum*(r-l+1);
        }
    }
    cout<<ans<<'\n';
}
```

---

## 作者：xuan_gong_dong (赞：0)

## 题面
[P7306 [COCI2018-2019#1] Strah](https://www.luogu.com.cn/problem/P7306)
## 分析
显然单调栈。

记录一个数组 $h_{i,j}$，第 $i$ 行第 $j$ 列的点往上走多少个会走不动。

然后直接一行一行地跑，对于每一行，用一个单调栈来统计面积。

然后就没了。复杂度 $O(n\times m)$。
## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char c[2010][2010];
int h[2010][2010];
int n,m;
pair<int,int> s[2010];
int top;
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",c[i]+1);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(c[i][j]=='.')
			{
				h[i][j]=h[i-1][j]+1;
			
			}	
//			cout<<h[i][j];
		}
//		cout<<endl;
	}
	s[0]=make_pair(0,0);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
//			if(c[i][j]!='.')continue;
			if(!top)
			{
				s[++top]=make_pair(h[i][j],j);
			}
			else
			{
				int xgd=j;
				while(top!=0)
				{
					auto tmp=s[top];
					if(tmp.first==h[i][j])break;;
					if(tmp.first<h[i][j])
					{
						s[++top]=make_pair(h[i][j],xgd); 
						break;
					}
					xgd=s[top].second;
					top--;
					int h1=h[i][j];
					if(top)
					h1=max(h[i][j],s[top].first);
					h1++;
					int h2=tmp.first;
					ans+=(h1+h2)*(h2-h1+1)/2*(j-tmp.second)*(j-tmp.second+1)*(j-tmp.second+2)/6;
//					cout<<h1<<" "<<h2<<' '<<j<<' '<<tmp.second<<' '<< (h1+h2)*(h2-h1+1)/2*(j-tmp.second)*(j-tmp.second+1)*(j-tmp.second+2)/6<<endl;
				}	
				if(!top)
				{
					s[++top]=make_pair(h[i][j],xgd);
				}		
			}
		}
//		cout<<ans<<endl;	
		while(top!=0)
		{
			auto tmp=s[top];
			top--;
			m++;
//			if(top!=0)
//			{
				ans+=(tmp.first+s[top].first+1)*(tmp.first-s[top].first)/2*(m-tmp.second)*(m-tmp.second+1)*(m-tmp.second+2)/6;
//			}
			m--;
		}
//		cout<<ans<<endl;
	}
	cout<<ans<<endl;
	return 0;
}
```

---


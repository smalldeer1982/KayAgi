# [GDKOI2023 提高组] 矩阵

## 题目描述

多次给定三个 $n \times n$ 的矩阵 $A, B, C$，你需要判断 $A \times  B$ 在模 $998244353$ 意义下是否等于 $C$。
其中 $×$ 为矩阵乘法，$C_{i,j} = \sum_{k=1}^{n}A_{i,k}B_{k,j}$。

本题读入量较大，建议使用快速读入。

## 说明/提示

对于 20% 的数据，满足 $\sum n ≤ 300$。

对于另外 20% 的数据，满足 $A_{i,j} \ne 0$ 的位置不超过 $n$ 个。

对于 100% 的数据，满足 $1 ≤ T, n ≤ 3000,\sum n ≤ 3000, 0 ≤ A_{i,j} , B_{i,j} , C_{i,j} < 998244353$。

## 样例 #1

### 输入

```
3
1
2
3
6
2
1 2
3 4
5 6
7 8
19 22
43 51
2
1111111 2222222
3333333 4444444
5555555 6666666
7777777 8888888
39625305 256038638
772687616 944903942```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：蒟蒻君HJT (赞：13)

套路题，随机一个 $n\times 1$ 的向量 $x$，检验 $A\times B\times x$ 和 $C\times x$ 是否相等即可。

为什么这样做是对的？设 $M=998244353$，每维取值为 $[0,M-1]$ 中整数的向量构成的空间为 $\mathbb{Z}^n$，加法和数乘定义为模 $M$ 意义下的运算。

上述做法等价于检验 $(A\times B-C)x$ 是否等于 $0$，即 $x$ 是否在 $A\times B-C$ 的零空间 $N(A\times B - C)$ 中。如果 $A\times B-C\neq 0$，则这个矩阵的秩至少为 $1$，由 rank-nullity 定理得 $\operatorname{dim}(N(A\times B - C))\leq n-1$，$\mathbb{Z}^n$ 中的向量个数为 $M^{n}$，而其维数为 $d$ 的子空间中的向量个数为 $M^d$，所以此时选到令 $(A\times B-C)x=0$ 的 $x$ 的概率不超过 $M^{d-n}\leq M^{-1}$，是可以接受的。

---

## 作者：Ratio_Y (赞：11)

新接触到随机化算法，记录一下。


---

## 思路
题意很简单，考察矩阵乘法，不会的戳[这里](https://www.cnblogs.com/Ratio-Yinyue1007/p/18328898)。

但矩阵乘法的时间复杂度是 $\mathcal{O(n^3)}$ 的，这里 $n\le 3000$，显然不可行，于是我们考虑随机化，通过降低相乘矩阵规模优化时间复杂度。

我们可以每次构造一个随机的大小为 $1\times n$ 的矩阵 $D$，根据等式的性质可以将符合条件的判断转化为 $A\times B\times D = C\times D$，这样，我们每次乘法的复杂度就降低到了 $\mathcal{O(n^2)}$，每组数据进行三次乘法，最终复杂度为 $\mathcal{O(T\sum n^2)}$，可以通过此题。

这样做法出现差错的概率极低，如果不放心可以多操作几次，不会明显影响时间复杂度。

## 实现

代码最工整的一集。

```
#include<bits/stdc++.h>
#define fo(x,y,z) for(register int (x)=(y);(x)<=(z);(x)++)

const int Ratio=0;
const int N=3e3+5;
const int mod=998244353;
int T,n;
int a[N][N],b[N][N],c[N][N],d[2][N],e[2][N],f[2][N],g[2][N];
namespace Wisadel
{
    short main()
    {
        scanf("%d",&T);srand(time(0));
        while(T--)
        {
            scanf("%d",&n);bool can=1;
            fo(i,1,n) fo(j,1,n) scanf("%d",&a[i][j]);
            fo(i,1,n) fo(j,1,n) scanf("%d",&b[i][j]);
            fo(i,1,n) fo(j,1,n) scanf("%d",&c[i][j]);
            fo(i,1,n) d[1][i]=rand(),e[1][i]=0,f[1][i]=0,g[1][i]=0;
            fo(j,1,n) fo(k,1,n) e[1][j]=(e[1][j]+1ll*d[1][k]*a[k][j]%mod)%mod;
            fo(j,1,n) fo(k,1,n) f[1][j]=(f[1][j]+1ll*e[1][k]*b[k][j]%mod)%mod;
            fo(j,1,n) fo(k,1,n) g[1][j]=(g[1][j]+1ll*d[1][k]*c[k][j]%mod)%mod;
            fo(i,1,n) if(f[1][i]!=g[1][i]){can=0;break;}
            printf(can?"Yes\n":"No\n");
        }
        return Ratio;
    }
}
int main(){return Wisadel::main();}
```


---

完结撒花~

[$Welcome\;to\;my\;blogs$](https://www.cnblogs.com/Ratio-Yinyue1007)

---

## 作者：Genius_Star (赞：7)

### 思路：

暴力不可取，但是我不会随机向量，于是考虑哈希。

将矩阵变为 $c_{i,j} \to  c_{i,j} \times p^j$，行哈希值为 $Hash_i=\sum\limits_{j=1}^m c_{i,j}$；将矩阵 $c_{i,j} \to c_{i,j} \times p^i$，列哈希值为 $Hash_i=\sum_{j=1}^n c_{j,i}$。

如果要对 $A \times B$ 的矩阵算哈希，自己推一下矩阵乘法式子，可以先对于 $B$ 矩阵算一遍，然后对于每一行的 $A$ 乘上去即可。

然后比较一下每行和每列的哈希值是否相等。

时间复杂度为 $O(T \times N^2)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=3030;
const ll P=1145141;
const ll mod=998244353;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,T;
ll Hash1[N],Hash2[N];
ll A[N][N],B[N][N],C[N][N];
ll a[N][N],b[N][N],c[N][N];
bool check(){
    for(int i=1;i<=n;i++){
        ll Hash=1;
		Hash1[i]=Hash2[i]=0;
        for(int j=1;j<=n;j++){
            Hash=(Hash*P)%mod;
            a[i][j]=A[i][j];
            b[i][j]=(B[i][j]*Hash)%mod;
            c[i][j]=(C[i][j]*Hash)%mod;
            Hash1[i]=(Hash1[i]+b[i][j])%mod;
            Hash2[i]=(Hash2[i]+c[i][j])%mod;
        }
    }
    for(int i=1;i<=n;i++){
        ll ans=0;
        for(int j=1;j<=n;j++)
		  ans=(ans+a[i][j]*Hash1[j])%mod;
        if(ans!=Hash2[i])
		  return 0;
    }
    for(int j=1;j<=n;j++){
        ll Hash=1;
		Hash1[j]=Hash2[j]=0;
        for(int i=1;i<=n;i++){
            Hash=(Hash*P)%mod;
            a[i][j]=(A[i][j]*Hash)%mod;
            b[i][j]=B[i][j];
            c[i][j]=(C[i][j]*Hash)%mod;
            Hash1[j]=(Hash1[j]+a[i][j])%mod;
            Hash2[j]=(Hash2[j]+c[i][j])%mod;
        }
    }
    for(int j=1;j<=n;j++){
        ll ans=0;
        for(int i=1;i<=n;i++)
		  ans=(ans+b[i][j]*Hash1[i])%mod;
        if(ans!=Hash2[j])
		  return 0;
    }
    return 1;
}
int main(){
    T=read();
    while(T--){
        n=read();
        for(int i=1;i<=n;i++)
		  for(int j=1;j<=n;j++)
		    A[i][j]=read();
        for(int i=1;i<=n;i++)
		  for(int j=1;j<=n;j++)
		    B[i][j]=read();
        for(int i=1;i<=n;i++)
		  for(int j=1;j<=n;j++)
		    C[i][j]=read();
        puts(check()?"Yes":"No");
    }
    return 0;
}
```


---

## 作者：Missa (赞：6)

我们随机一个 $1 \times n$ 矩阵 $D$，将它乘到 $A$ 左边。

若 $A \times B = C$，$D \times A \times B = D \times C$。

向量乘矩阵的复杂度是 $O(n^2)$，因此这个做法时间复杂度是对的。

考虑正确性。

这个做法本质上校验了 $D \times (A \times B - C)$ 是否为 $0$。设 $E$ 为 $A \times B - C$，若能找到一个非零位置 $E_{x, y}$，考虑 $D \times E$ 的 $(1, y)$ 位置 $\sum D_{1, i}E_{i, y}$，先确定其余位置再确定 $D_{1, x}$，则 $D_{1, x}$ 在 $[0, 998244352]$ 的取值与整个式子在 $[0, 998244352]$ 的取值一一对应，因此仅有 $\dfrac{1}{998244353}$ 的错误率。

fun fact：在 $C$ 中随机 $O(n)$ 个点 check 过了这道题。

---

## 作者：DengDuck (赞：4)

怎么人均认为是水题，认为随便场切，我觉得很困难啊！

当年听学长说这题主办方测了多次取最大值，所以随机选点可以跑满，所以交了十几发的随机选点，最高分 $80$，代码如下。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=3005;
const LL mod=998244353;
LL T,n,a[N][N],b[N][N],c[N][N],vis[N][N];
int main()
{
    srand(time(0));
    scanf("%lld",&T);
    while(T--)
    {

        scanf("%lld",&n);
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)scanf("%lld",&a[i][j]);
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)scanf("%lld",&b[i][j]);
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)scanf("%lld",&c[i][j]);
        }        
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)vis[i][j]=0;
        }
        LL flg=1;
        LL t=30000;
        while(t--)
        {
            LL x=rand()%n+1,y=rand()%n+1;
            if(vis[x][y]==1)continue;
            vis[x][y]=1;
            LL sum=0;
            for(int k=1;k<=n;k++)sum=(sum+a[x][k]*b[k][y]%mod)%mod;
            if(sum!=c[x][y])
            {
                flg=0;
                break;
            }
        }
        if(flg)puts("Yes");
        else puts("No");
    }
}
```
感觉不是很行，所以自己想了一个随机向量做法，考虑随机出一个大小为 $1\times n$ 的向量 $H$ 和一个 $n\times 1$ 的向量 $L$，向量做矩阵乘法是 $\mathcal O(n^2)$。

然后显然因为 $A\times B=C$，所以 $H\times A\times B\times L=H\times C\times L$，然后只剩一个数字直接比较就行了。

随机化跑十遍就可以过了。

需要注意的是封装矩阵，要手写 `=`，不然每次覆盖都要跑 $3000\times 3000$ 次。
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=3005;
const LL mod=998244353;
LL T,n;
struct mat
{
	LL x,y,a[N][N];
	mat(const LL X=0,const LL Y=0):x(X),y(Y)
    {
        for(int i=1;i<=x;i++)
        {
            for(int j=1;j<=y;j++)a[i][j]=0;
        }
    }
    void operator=(const mat&A)
    {
        x=A.x,y=A.y;
        for(int i=1;i<=x;i++)
        {
            for(int j=1;j<=y;j++)a[i][j]=A.a[i][j];
        }
    }
	mat operator*(const mat&A)const
	{
		mat ans(x,A.y);
        
		for(int i=1;i<=x;i++)
		{
			for(int j=1;j<=A.y;j++)
			{
				for(int k=1;k<=y;k++)
					ans.a[i][j]=(ans.a[i][j]+a[i][k]*A.a[k][j]%mod)%mod;
			}
		}
		return ans;
	}
    void print()
    {
        for(int i=1;i<=x;i++)
        {
            for(int j=1;j<=y;j++)cout<<a[i][j]<<' ';
            cout<<endl;
        }
    }
}a,b,c,H,L;
int main()
{
    srand(time(0));
    scanf("%lld",&T);
    while(T--)
    {
        scanf("%lld",&n);
        a.x=n,a.y=n,b.x=n,b.y=n,c.x=n,c.y=n,H.x=1,H.y=n,L.x=n,L.y=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)scanf("%lld",&a.a[i][j]);
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)scanf("%lld",&b.a[i][j]);
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)scanf("%lld",&c.a[i][j]);
        }       
        LL flg=1;
        for(int T=1;T<=10;T++)
        {
            for(int i=1;i<=n;i++)H.a[1][i]=rand()%mod;
            for(int i=1;i<=n;i++)L.a[i][1]=rand()%mod;             
            mat res=H*a;
            res=res*b;
            res=res*L;
            mat res2=H*c;
            res2=res2*L;
            if(res.a[1][1]!=res2.a[1][1])
            {
                flg=0;
                break;
            }
           // cout<<res.a[1][1]<<' '<<res2.a[1][1]<<endl;
        }

        if(flg)puts("Yes");
        else puts("No");
    }
}
```

不过我个人的看法是随机化题调参很考验心态吧，反正考场有这题我肯定挂分。

感觉可能是因为大家太强了吧。

---

## 作者：WorldMachine (赞：3)

随机化好闪，拜谢随机化。

看到这道题，$\mathcal O(N^3)$ 我会！喜提 $20\text{pts}$。

矩阵乘法的时间复杂度达到了 $\mathcal O(N^3)$，因此我们不能用普通的矩阵乘法。

考虑优化至 $\mathcal O(N^2)$。随机构造一个向量（一维的矩阵）$D$，如果 $A\times B=C$，那么大概率有：
$$
D\times A\times B=D\times C
$$
乘法变成了 $\mathcal O(N^2)$ 的，在时间复杂度这块可以通过。下面分析一下该算法的正确性。

记 $A\times B-C=\Delta$，则如果 $\Delta=O$（$O$ 为零矩阵），一定有 $D\times\Delta=O$，反之亦然。假设 $\Delta\not=O$，并且 $\Delta_{xy}\not=0$，$D_{1x}$ 的位置经过乘法后对 $D\times\Delta$ 的 $(1,y)$ 位置产生贡献，如果 $\Delta_{xy}$ 在 $[0,998244352]$ 内随机生成，那么 $D\times\Delta$ 的 $(1,y)$ 位置的值也在 $[0,998244352]$ 内均匀分布，因此错误的概率为 $\dfrac{1}{998244353}$。

---

## 作者：ivyjiao (赞：3)

刚看到这题，感觉没什么好的做法，看到数据范围知道暴力肯定要萎，没法把所有的点都 check 一遍，怎么办？

考虑随机选点 check。

我们每次随机选择一些点进行 check，对于选到的每个点 $O(n)$ 进行 check，如果遇到不行的点就直接输出 `No`，如果这些点都 check 完了还没有发现问题，那么输出 `Yes`。

小优化：如果某次选点的时候这个点之前已经被选过，则不对其进行 check。

经测试，能选择的点大概在 $100000$ 个左右。

最后别忘了开 long long。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int t,n,a[3001][3001],b[3001][3001],c[3001][3001];
bool vis[3001][3001];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    srand(time(0));
    cin>>t;
    while(t--){
        memset(vis,0,sizeof vis);
        cin>>n;
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>a[i][j];
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>b[i][j];
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>c[i][j];
        for(int k=1;k<=min(n*n,100000ll);k++){
            int x=rand()%n+1,y=rand()%n+1,cnt=0;
            if(vis[x][y]){
                k--;
                continue;
            }
            vis[x][y]=1;
            for(int i=1;i<=n;i++) cnt+=a[x][i]*b[i][y],cnt%=mod;
            if(cnt!=c[x][y]){
                cout<<"No\n";
                goto T1;
            }
        }
        cout<<"Yes\n";
        T1:;
    }
}
```

然而这种做法是过不去的，因为如果 $n=3000$，而且 $A\times B$ 与 $C$ 只有一个点不同，则每次选点 check 到这个点的概率为 $\dfrac{1}{9000000}$，也就是说，我们 check $100000$ 次，正确率是 $\dfrac{100000}{9000000}=\dfrac{1}{90}=1.1\%$，也就是说，我们这个优秀的解法有着高达 $1.1\%$ 的正确率！

我们重新想解法，我们想到矩阵乘法的定义，一个 $n\times m$ 的矩阵乘一个 $m\times p$ 的矩阵得到一个 $n\times p$ 的矩阵，那么一个 $1\times n$ 的矩阵乘一个 $n\times n$ 的矩阵得到的也是 $1\times n$ 的矩阵（让 $n=1,m=n,p=n$）。

我们考虑把题目中的 $A\times B=C$ 改成 $D\times A\times B=D\times C$，而 $D$ 是一个 $1\times n$ 的矩阵，这样我们就可以把 check 的时间复杂度降到 $O(n^2)$，然后就过了。

怎么过的？

我们以 $D\times A$ 为例，因为 $D\times A$ 得到的结果是一维的，而题目中的 $C_{i,j}=\sum_{k=1}^{n}A_{i,k}\times B_{k,j}$ 成为了 $E_{1,j}=\sum_{k=1}^{n}D_{1,k}\times A_{k,j}$，也就是 $E_j=\sum_{k=1}^{n}D_k\times A_{k,j}$，这样原来 $O(n^3)$ 的矩阵乘法就被压缩成了 $O(n^2)$。其余部分同理。

$D$ 哪来的？随机一个就行。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[3001][3001],b[3001][3001],c[3001][3001],d[3001],e[3001],f[3001],g[3001],p;
signed main(){
    ios::sync_with_stdio(0);
    cin>>t;
    while(t--){
        p=0;
        memset(e,0,sizeof e);
        memset(f,0,sizeof f);
        memset(g,0,sizeof g);
        cin>>n;
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>a[i][j];
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>b[i][j];
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>c[i][j];
        for(int i=1;i<=n;i++) d[i]=rand();
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) e[i]+=d[j]*a[j][i],e[i]%=998244353;
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i]+=e[j]*b[j][i],f[i]%=998244353;
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) g[i]+=d[j]*c[j][i],g[i]%=998244353;
        for(int i=1;i<=n;i++) if(f[i]!=g[i]) p=1;
        if(p) cout<<"No"<<endl;
        else cout<<"Yes"<<endl;
    }
}
```

---

## 作者：User_Unauthorized (赞：2)

对于判定问题我们考虑考察其必要条件并进行随机化判定。

不难发现，对于矩阵 $A, B, C$，若其满足

$$A \times B = C$$

那么对于任意 $1 \times n$ 的向量 $x$，其一定满足

$$x \times A \times B = x \times C$$

这样我们可以在 $\mathcal{O}(n^2)$ 的时间内进行一次判定，下面**估计**其正确率。

发现实际上我们需要判定的是 $A \times B - C$ 后得到的矩阵是否均为 $0$，记其为 $D$，那么我们通过向量 $x$ 实际判定的是 $x \times D$ 得到的向量是否均为 $0$。不妨假设 $D$ 中存在非 $0$ 的位置，即其为 $\left(x, y\right)$，那么在我们先在 $x$ 中除了 $\left(1, x\right)$ 以外的其他值，那么可以发现，若那个空位在 $\left[0, 998244353\right)$ 内随机生成，那么 $x \times D$ 中的 $\left(1, y\right)$ 的取值也取遍 $\left[0, 998244353\right)$，因此该做法的错误率不超过 $\frac{1}{998244353}$，可以接受。

---

## 作者：homo_snow (赞：2)

有幸做过[原题](http://poj.org/problem?id=3318)。

第一眼看到这道题，会想到暴力做法，很显然， $O(n^3)$ 的时间复杂度肯定会炸。

所以考虑压维。

根据矩阵乘法的特性，我们可以搞出一个一维矩阵 $D$ ，乘在等式的两边，然后得到：$D\times A \times B = D \times C$ 。

然后等式的矩阵就会被压成一维，这道题就能过了。

$D$ 哪来的？随机造一个就行。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 3e3+10;
const int INF = 0x3f3f3f3f;
const int mod = 998244353;

int t , n , a[N][N], b[N][N], c[N][N], d[N];
int res1[N],res2[N],res3[N];

int check(){
	for(int i = 1; i <= n; i++){
		d[i] = rand() % n + 1;
		res1[i] = res2[i] = res3[i] = 0;
	}
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			res1[i] = (res1[i] + d[j] * a[j][i]) % mod;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			res2[i] = (res2[i] + res1[j] * b[j][i]) % mod;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			res3[i] = (res3[i] + d[j] * c[j][i]) % mod;
	for(int i = 1; i <= n; i++)
		if(res2[i] != res3[i])
			return 0;
	return 1;
}

signed main(){
	srand(time(NULL));
    scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				scanf("%lld",&a[i][j]);
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				scanf("%lld",&b[i][j]);				
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
				scanf("%lld",&c[i][j]);
		puts(check() ? "Yes" : "No");
	}
    return 0;
}

```


---

## 作者：wangchuyue (赞：0)

## P10102题解

分析给出的公式 $C_i,_j=\sum_ {k = 1} ^ n A_i,_k B_k,_j$，发现矩阵乘法是让一个 $n \times n$ 的矩阵乘一个 $m \times p$ 的矩阵变成 $n \times p$ 的矩阵

于是想到，如果有一个 $1 \times n$ 的矩阵去乘 $n \times n$ 的矩阵 $A、B、C$，不就可以过了吗?

可这个 $1 \times n$ 的矩阵又不会凭空产生，我们就得设法得到它。

于是我在想得焦头烂额之后默默打开了算法标签——随机化、随机函数。

于是，一个由在 $1-n$ 随机取数的矩阵诞生了。

令人放心的是，可以通过计算证明，这个算法仅有 $\frac{1}{998244353}$ 的概率会出错。

下面就是大家最喜欢的代码了：
  
```
#include<bits/stdc++.h>
#define int long long//本题要开long long
#define f(i,x,y) for(int i=x;i<=y;i++)
#define d(i,x,y) for(int i=x;i>=y;i--)
#define h f(i,1,n)f(j,1,n)
#define mem memset(k,0,sizeof k),memset(ff,0,sizeof ff),memset(sum1,0,sizeof sum1),memset(sum2,0,sizeof sum2);
using namespace std;
const int mod=998244353;
int n,a[3001][3001],b[3001][3001],c[3001][3001],k[3001],ff[3001],sum1[3001],sum2[3001];
void work()
{
    bool flag=true;mem
    cin>>n;
    f(i,1,n)k[i]=(rand()-1)%n+1;//随机函数rand()真好用
    h cin>>a[i][j];
    h cin>>b[i][j];
    h cin>>c[i][j];
    h ff[i]+=k[j]*a[j][i],ff[i]%=mod;
    h sum1[i]+=ff[j]*b[j][i],sum1[i]%=mod;
    h sum2[i]+=k[j]*c[j][i],sum2[i]%=mod;
    //注意先乘再模，不可以出现如ff[i]+=k[j]*a[j][i]%mod;的语句，如果你第三个数据输出No，请检查是否是这里有问题
    f(i,1,n)
        if(sum1[i]!=sum2[i])
        {
             puts("No");
             flag=false;
             break;
        }//判断就不用我说了吧
    if(flag)puts("Yes"); 
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin>>t;
    while(t--)work();//用函数实现，代码更清晰
    return 0;
}
```
非常观看

---

## 作者：Elaina_0 (赞：0)

# [P10102 [GDKOI2023 提高组] 矩阵](https://www.luogu.com.cn/problem/P10102)

## 分析

直接 $n^3$ 乘的复杂度显然不可接受...

没什么思路，考虑随机化算法。

不难想到随机选点 check 。


```cpp
int n,m;
int a[N][N],b[N][N],c[N][N];
bool vis[N][N];

void cleanall(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=b[i][j]=c[i][j]=vis[i][j]=0;
		}
	}
}

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	
	srand(time(0));
	int T;
	cin>>T;
	while(T--){
		cleanall();
		cin>>n;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>a[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>b[i][j];
			}
		}
		int flg=1;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>c[i][j];
			}
		}
		int mn=min(1ll*n*n,60000ll);
		for(int k=1;k<=mn;k++){
            int x=random(1,n),y=random(1,n),cnt=0;
            if(vis[x][y]){
                k--;
                continue;
            }
            vis[x][y]=1;
            for(int i=1;i<=n;i++) cnt+=1ll*a[x][i]*b[i][y],cnt%=mod;
            if(cnt!=c[x][y]){
				flg=0;
                break;
            }
        }
		
		if(flg){
			cout<<"Yes"<<'\n';
		}else{
			cout<<"No"<<'\n';
		}
	}
	return Elaina;
}
```

但当 `n=3000` 时，假设只有一个点是错误的，那么随到这个点的可能性实在太低。

于是你想到了正解：

考虑到矩阵乘法的性质：

一个 $n\times m$ 的矩阵 $\times $ 一个 $m\times p$ 的矩阵 $=$ 一个 $n\times p$ 的矩阵

同理：

一个 $n\times n$ 的矩阵 $\times $ 一个 $n\times 1$ 的矩阵 $=$ 一个 $n\times 1$ 的矩阵

将题目~~意淫一下~~改为 $A\times B\times D = C\times D$，其中 $D$ 为一个 $n\times 1$ 的矩阵。

酱紫，就可以在 $n^2$ 的复杂度下 check 完全部的点了。

~~矩阵乘不用我教你吧~~

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
#define rd read()
#define mkp make_pair
#define psb push_back
#define 我永远喜欢 return
#define 伊蕾娜 0;
#define mst(a,b) memset((a),(b),sizeof(a))
#define random(a,b) (1ll*rand()*rand()*rand()%((b)-(a)+1)+(a))
inline ll read(){
	ll f=1,x=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f=(ch=='-'?-1:1);
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return f*x;
}
const int mod=998244353;
const int N=3000+10;
const int inf=0x7fffffff;

int n,m;
int a[N][N],b[N][N],c[N][N];
long long d[N],e[N],f[N],g[N];

void cleanall(){
	for(int i=1;i<=n;i++){
		d[i]=e[i]=f[i]=g[i]=0;
		for(int j=1;j<=n;j++){
			a[i][j]=b[i][j]=c[i][j]=0;
		}
	}
}

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	
	srand(time(0));
	int T;
	cin>>T;
	while(T--){
		cleanall();
		cin>>n;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>a[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>b[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cin>>c[i][j];
			}
		}

		bool flg=1;
		
		for(int i=1;i<=n;i++) d[i]=rand();
        for(int i=1;i<=n;i++){
        	for(int j=1;j<=n;j++){
        		e[i]+=1ll*d[j]*a[j][i];
				e[i]%=mod;
			}
		}
		for(int i=1;i<=n;i++){
        	for(int j=1;j<=n;j++){
        		f[i]+=1ll*e[j]*b[j][i];
				f[i]%=mod;
                g[i]+=1ll*d[j]*c[j][i];
				g[i]%=mod;
			}
            if(f[i]!=g[i]){
        		flg=0;
        		break;
			}
		}
		
		if(flg){
			cout<<"Yes"<<'\n';
		}else{
			cout<<"No"<<'\n';
		}
	}
	我永远喜欢 伊蕾娜
}
```

---

## 作者：w9095 (赞：0)

[P10102 [GDKOI2023 提高组] 矩阵](https://www.luogu.com.cn/problem/P10102)

模拟赛题，场切了，似乎做法和全世界都不一样。

直接暴力矩阵乘法显然过不去，也没有什么前途。注意到只需要判定是否相等，考虑矩阵每一行的和。假设现在正在计算第 $i$ 项的和。

$$\sum_{j=1}^n \sum_{k=1}^n A_{i,k}B_{k,j}$$

交换枚举顺序，不难得到如下式子。

$$\sum_{k=1}^n A_{i,k}\sum_{j=1}^n B_{k,j}$$

我们发现，$\sum_{j=1}^n B_{k,j}$ 其实就是 $B$ 中第 $k$ 行的数的和，预处理之后每一行就只需要枚举 $k$ 就可以计算。总时间复杂度就达到了 $O(n^2)$。

我们判断算出来每行的和与 $C$ 中每行的和是否相等即可。但是由于取模，有可能会出现冲突，所以我们再把每一列都判断一下。可以类比哈希，这么做出错概率极低。


```cpp
#include <bits/stdc++.h>
using namespace std;
long long t,n,a[3001][3001],b[3001][3001],c[3001][3001],ha[3001],hb[3001],hc[3001],la[3001],lb[3001],lc[3001];
const long long mod=998244353;
inline long long read()
{
	long long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int main()
{
	scanf("%lld",&t);
	while(t--)
	   {
	   	n=read();
	   	for(int i=1;i<=n;i++)ha[i]=hb[i]=hc[i]=la[i]=lb[i]=lc[i]=0;
	   	for(int i=1;i<=n;i++)
	   	    for(int j=1;j<=n;j++)
	   	        a[i][j]=read(),ha[i]=(ha[i]+a[i][j])%mod,la[j]=(la[j]+a[i][j])%mod;
	   	for(int i=1;i<=n;i++)
	   	    for(int j=1;j<=n;j++)
	   	        b[i][j]=read(),hb[i]=(hb[i]+b[i][j])%mod,lb[j]=(lb[j]+b[i][j])%mod;
	   	for(int i=1;i<=n;i++)
	   	    for(int j=1;j<=n;j++)
	   	        c[i][j]=read(),hc[i]=(hc[i]+c[i][j])%mod,lc[j]=(lc[j]+c[i][j])%mod;
	   	bool flag=0;
	    for(int i=1;i<=n;i++)
	        {
	        long long sum=0;
	        for(int k=1;k<=n;k++)sum=(sum+a[i][k]*hb[k]%mod)%mod;
	        if(sum!=hc[i])
	           {
	           	flag=1;
	           	break;
			   }
	        }
	    if(!flag)
	       for(int i=1;i<=n;i++)
	        {
	        long long sum=0;
	        for(int k=1;k<=n;k++)sum=(sum+b[k][i]*la[k]%mod)%mod;
	        if(sum!=lc[i])
	           {
	           	flag=1;
	           	break;
			   }
	        }
	    if(flag)printf("No\n");
	    else printf("Yes\n");
	   }
	return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P10102 [GDKOI2023 提高组] 矩阵 题解

## 题意回顾

给定三个 $ n \times n $ 矩阵 $ A,B,C $，判断 $ A \times B $ 是否等于 $ C $。

多测，$ 1 \le \sum n \le 3000 $。

## 分析

随机一个向量 $ D $（即 $ 1 \times n $ 的矩阵），考虑 $ D \times A \times B $ 是否等于 $ D \times C $，大概率与 $ A \times B $ 是否等于 $ C $ 是等价命题。

如果 $ D \times (A \times B-C) $ 为零矩阵时才有可能错判，但是随机的 $ A \times B - C $ 非零时，与非零的 $ D $ 乘起来为 0 矩阵的概率是 $ \frac{1}{998244353^{nm}} $，很小，可以忽略不计。

类似的利用向量优化到 $ O(n^2) $ 复杂度的题还有[美食家](https://www.luogu.com.cn/problem/P6772)。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 3005;
const int mod = 998244353;
int T;
int n;
int a[N][N], b[N][N], c[N][N];
int read() {
    int f = 0;
    char ch = '#';
    while(ch < '0' || ch > '9') ch = getchar();
    while(ch >= '0' && ch <= '9') f = f * 10 + ch - '0', ch = getchar();
    return f;
}
int now[N];
int tyu[N];
int hja[N];
int nxt[N];
int sed = 1145141;
int rnd() {
    return sed = ((long long)sed * 939 + 923) % mod / 2 + 171;
}
int main() {
    T = read();
    for(int ti = 1; ti <= T; ti++) {
        n = read();
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) a[i][j] = read();
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) b[i][j] = read();
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) c[i][j] = read();
        }
        for(int i = 1; i <= n; i++) {
            now[i] = tyu[i] = rnd();
        }
        memset(nxt, 0, sizeof(nxt));
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                nxt[j] = (nxt[j] + (long long)now[i] * a[i][j]) % mod;
            }
        }
        for(int i = 1; i <= n; i++) now[i] = nxt[i];
        memset(nxt, 0, sizeof(nxt));
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                nxt[j] = (nxt[j] + (long long)now[i] * b[i][j]) % mod;
            }
        }
        for(int i = 1; i <= n; i++) now[i] = nxt[i];
        for(int i = 1; i <= n; i++) hja[i] = now[i], now[i] = tyu[i];
        memset(nxt, 0, sizeof(nxt));
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                nxt[j] = (nxt[j] + (long long)now[i] * c[i][j]) % mod;
            }
        }
        for(int i = 1; i <= n; i++) now[i] = nxt[i];
        int nye = 0;
        for(int i = 1; i <= n; i++) nye += (now[i] == hja[i]);
        puts((nye == n) ? "Yes" : "No");
    }
    return 0;
}

```

---

## 作者：zzx0102 (赞：0)

题外话：解释一下为什么写完原根题解后复活了，因为一些【数据删除】的原因，使得学校老师支持我 OI，然后复活了。~~和没解释一样。~~

~~虽然我也不知道学校老师会因为这个原因支持我复活。~~，不过为了自己所热爱的东西而奋斗的感觉永远是好的。

不过开学之后还得回归 whk。

言归正传，显然这题直接 $\mathcal{O}(n^3)$ 矩阵乘法是不行的。

然后又想不到什么比较好的快速求出 $A\times B$ 的方法，所以只能想其他方法了。

我们令 $D=A\times B$。

考虑随机化，显然 $D_{i,j}=\sum a_{i,k}\times b_{k,j}$，可以直接随机出 $i,j$，然后直接枚举 $k$ 即可算出 $D_{i,j}$，所以我们撒 $T$ 个点的复杂度就是 $\mathcal{O}(Tn)$ 的。取到 $T=1.2\times 10^5$ 时，可以获得 $80$ 分，$T$ 再大就要 TLE 了。

只能换一条路了。

我们拿出一个 $1\times n$ 的矩阵 $d$。

显然可以暴力算 $(d\times A)\times B$ 得到了一个 $1\times n$ 的矩阵 $f$，然后用 $d\times C$ 得到一个矩阵 $g$，由于矩阵乘法有结合律，所以 $(d\times A)\times B=d\times (A\times B)$。

当 $f=g$ 时，我们认为 $A\times B=C$。

概率证明：

$$
0=f-g=d\times (A\times B)-d\times C
$$

由于矩阵有分配律，得

$$
(A\times B-C)\times d=0
$$

设 $E=A\times B-C$

令 $p=998244353$。

设 $E$ 有非零位置 $(x,y)$，则 $D\times E$ 的 $(1,y)=\sum D_{1,i}E_{i,y}$，需要有一个 $D_{1,x}$ 与其恰好对应，概率只有 $\dfrac{1}{p}$。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define gc getchar
const int N = 3010, p = 998244353;
inline int read() {
	int x = 0; char ch = gc();
	while(ch < '0' || ch > '9') ch = gc();
	while(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gc();
	return x; 
}
int n; int a[N], b[N]; 
struct mtr {
	int a[N][N];
	void Read() {
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= n; j++) {
				a[i][j] = read();
			}
		}
	}
} A, B, C;
int d[N], e[N], f[N], g[N];
signed main() {
	srand(388651);
	int T = read();
	while(T--) {
		n = read();
		for(int i = 1; i <= n; i++) e[i] = f[i] = g[i] = 0;
		A.Read(), B.Read(), C.Read();
		for(int i = 1; i <= n; i++) d[i] = rand();
		for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) e[i] += 1ll * d[j] * A.a[j][i] % p, e[i] %= p;
		for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) f[i] += 1ll * e[j] * B.a[j][i] % p, f[i] %= p;
		for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) g[i] += 1ll * d[j] * C.a[j][i] % p, g[i] %= p;
		bool flag = 0; for(int i = 1; i <= n; i++) if(f[i] != g[i]) {flag = 1; break;}
		if(flag) puts("No"); else puts("Yes");
	}
	return 0;
}
```

---

## 作者：编程小贝壳 (赞：0)

[原题](https://www.luogu.com.cn/problem/P10102)


### 分析

很好的题目，使我见到随机化这一神奇算法。

显然直接上矩阵乘法过不了，那么考虑优化矩阵乘法，我们选择压缩矩阵的大小。

由于大小为 $(x,y)$，$(y,z)$ 的两个矩阵相乘结果矩阵大小为 $(x,z)$，因此使题目中 $(n,n)$ 大小的矩阵与一个大小为 $(1,n)$ 的矩阵相乘，即可将矩阵压缩为 $(1,n)$ 规模。

所以只需要新建一个矩阵 $D(1,n)$，判断是否满足 $D\times A\times B=D\times C$ 即可。

### 小证明

题中需要判断的是 $A\times B -C=0$ 是否成立，而我们的做法是判断 $D\times (A\times B -C)=0$ 是否成立，

容易得出仅有 $A\times B -C\neq0$ 且 $D\times (A\times B -C)=0$ 时我们的做法错误。尝试构造一个矩阵 $D$ 可以将我们的做法hack，发现仅有矩阵 $D$ 的元素均为 0 时上式成立。

经过多次尝试，当矩阵 $D$ 的各项元素均非 0 时，本做法一定正确，是因为与 0 相乘均为 0 的缘故。因此我们没有必要使用随机数来生成矩阵，只需要保证各项均非零即可。

那么为什么要用随机生成而不是全部设置成某个固定的值呢？这是为了防止被特殊构造的数据卡掉。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 3005;
const int MOD = 998244353;
int t,n;
int a[MAXN][MAXN],b[MAXN][MAXN],c[MAXN][MAXN];
int d[MAXN],a1[MAXN],b1[MAXN],c1[MAXN];
bool tg;
signed main(){
	scanf("%lld",&t);
	while(t--){
		srand(time(0));
		scanf("%lld",&n);
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%lld",&a[i][j]);
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%lld",&b[i][j]);
        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%lld",&c[i][j]);
        for(int i=1;i<=n;i++) d[i]=rand();
        
        for(int i=1;i<=n;i++){
        	for(int j=1;j<=n;j++){
        		a1[i]+=d[j]*a[j][i];a1[i]%=MOD;
			}
		}
		for(int i=1;i<=n;i++){
        	for(int j=1;j<=n;j++){
        		b1[i]+=a1[j]*b[j][i];b1[i]%=MOD;
			}
		}
		for(int i=1;i<=n;i++){
        	for(int j=1;j<=n;j++){
        		c1[i]+=d[j]*c[j][i];c1[i]%=MOD;
			}
		}
		
		tg = 0;
		for(int i=1;i<=n;++i){
			if(b1[i]!=c1[i]){
				tg = 1;break;
			}
		}
		puts(tg?"No":"Yes");
		memset(a1,0,sizeof(a1));
		memset(b1,0,sizeof(b1));
		memset(c1,0,sizeof(c1));
    }
	return 0;
}
```

---


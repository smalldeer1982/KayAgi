# [国家集训队] 旅游

## 题目背景

Ray 乐忠于旅游，这次他来到了 T 城。T 城是一个水上城市，一共有 $n$ 个景点，有些景点之间会用一座桥连接。为了方便游客到达每个景点但又为了节约成本，T 城的任意两个景点之间有且只有一条路径。换句话说， T 城中只有 $n-1$ 座桥。

Ray 发现，有些桥上可以看到美丽的景色，让人心情愉悦，但有些桥狭窄泥泞，令人烦躁。于是，他给每座桥定义一个愉悦度 $w$，也就是说，Ray 经过这座桥会增加 $w$ 的愉悦度，这或许是正的也可能是负的。有时，Ray 看待同一座桥的心情也会发生改变。

现在，Ray 想让你帮他计算从 $u$ 景点到 $v$ 景点能获得的总愉悦度。有时，他还想知道某段路上最美丽的桥所提供的最大愉悦度，或是某段路上最糟糕的一座桥提供的最低愉悦度。


## 题目描述

给定一棵 $n$ 个节点的树，边带权，编号 $0 \sim n-1$，需要支持五种操作：

- `C i w` 将输入的第 $i$ 条边权值改为 $w$；
- `N u v` 将 $u,v$ 节点之间的边权都变为相反数；
- `SUM u v` 询问 $u,v$ 节点之间边权和；
- `MAX u v` 询问 $u,v$ 节点之间边权最大值；
- `MIN u v` 询问 $u,v$ 节点之间边权最小值。

保证任意时刻所有边的权值都在 $[-1000,1000]$ 内。


## 说明/提示

【数据范围】  

对于 $100\%$ 的数据，$1\le n,m \le 2\times 10^5$。

2020.02.04 修正了一点数据的错误  
2020.03.14 加入了一组 hack 数据  
2020.11.26 加入了一组 hack 数据 By @_Leaving

## 样例 #1

### 输入

```
3
0 1 1
1 2 2
8
SUM 0 2
MAX 0 2
N 0 1
SUM 0 2
MIN 0 2
C 1 3
SUM 0 2
MAX 0 2```

### 输出

```
3
2
1
-1
5
3```

# 题解

## 作者：jichi (赞：75)

   **90分的自行看第三点**

由于看不懂大佬发的题解就自己发了一篇

对于这道题，题目要求我们支持5种操作，其中显然操作2-4要求使用树剖来实现（主要是更高级的算法我也不会了(；′⌒`)）

但是这道题的难点对于本蒟蒻来说还是很多的（比如第一篇说的边权转点权我就不会awa）

所以我对自己不会的点都进行了解析！

$1.$  **边权转点权**

我们考虑把连接父亲与儿子的边的边权赋值到儿子上，即我们在写线段树与跑第二个DFS的时候对于权值用dfs序和链式前向星存储顺序进行转换，没想明白的可以看看我代码中dfs1和dfs2中的应用，还可以先去做[P4315 月下“毛景树”](https://www.luogu.com.cn/problem/P4315)


```c++
inline void dfs1(int x,int f){
	dep[x]=dep[f]+1;fa[x]=f;siz[x]=1;
	for(int i=head[x];i;i=nex[i]){
		int v=to[i];
		if(v==f) continue;
		dfs1(v,x);
		tmp[v]=val[i];//边权转点权
		siz[x]+=siz[v];
		if(siz[son[x]]<siz[v]) son[x]=v;
	}
}

inline void dfs2(int x,int topf){
	dfn[x]=++idx;
    w[idx]=tmp[x];//边权转点权
    top[x]=topf;
	if(son[x]) dfs2(son[x],topf);
	for(int i=head[x];i;i=nex[i]){
		int v=to[i];
		if(v==fa[x]||v==son[x]) continue;
		dfs2(v,v);
	}
}
```

$2.$   当树剖中跳出$while(top[x]!=top[y])$这个循环的时候，$top[x]$此时就是x和y的$LCA$ ,由于$top[x]$的点权是$top[x]$与$fa[top[x]]$的连边的边权，所以我们此时不计算它，另外当$x==y$ 的时候，所有需要统计的边权都被统计到了直接返回即可,这里是一个例子：

```c++
if(x!=y) res+=qsum(1,1,n,dfn[x]+1,dfn[y]);
```

$3.$  **很多人都被hack的一点**，感谢@[傅思维666](https://www.luogu.com.cn/user/175131)大佬指出的错误

修改第$i$条边时，我们应该修改的是$(u,v)$这个点集中深度更大的点的点权，而不是直接修改点i，具体操作在代码中

$4.$  剩下的就没什么难的了，用$lazy[$  $]$异或维护这个点是否需要取反，$sum[$  $]$直接$\times-1$就行了，$maxn[$  $]$和$minn[$  $]$交换之后取反就可以了

然而最优解居然是暴力。。。

另外，建议各位打树剖用结构体存图，我把top写成to找了一小时

蒟蒻码字不易，如果对您有帮助的话请点个赞呗？以及非常感谢管理员大大的审核

$AC$  $CODE$



```c++
#include<bits/stdc++.h> 

#define int long long
#define mid ((l+r)>>1)
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
using namespace std;

inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

inline void write(int x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	int xx=x%10;
	putchar(xx+'0');
}

const int N=2e5+10;
int n,m;
int cnt,head[N],to[N<<1],nex[N<<1],val[N<<1];
//链式前向星

int idx,fa[N],son[N],top[N],dep[N],dfn[N],siz[N],tmp[N],w[N];
//树链剖分 

int sumn[N<<2],maxn[N<<2],minn[N<<2],lz[N<<2];
//线段树 

struct node{
	int x,y;
}id[N];

inline void add(int x,int y,int w){
	nex[++cnt]=head[x];to[cnt]=y;val[cnt]=w;head[x]=cnt;
}

inline void dfs1(int x,int f){
	dep[x]=dep[f]+1;fa[x]=f;siz[x]=1;
	for(int i=head[x];i;i=nex[i]){
		int v=to[i];
		if(v==f) continue;
		dfs1(v,x);
		tmp[v]=val[i];//边权转点权
		siz[x]+=siz[v];
		if(siz[son[x]]<siz[v]) son[x]=v;
	}
}

inline void dfs2(int x,int topf){
	dfn[x]=++idx;w[idx]=tmp[x];top[x]=topf;
	if(son[x]) dfs2(son[x],topf);
	for(int i=head[x];i;i=nex[i]){
		int v=to[i];
		if(v==fa[x]||v==son[x]) continue;
		dfs2(v,v);
	}
}
//以下为线段树 

inline void pushup(int rt){
	sumn[rt]=sumn[rt<<1]+sumn[rt<<1|1];
	maxn[rt]=max(maxn[rt<<1],maxn[rt<<1|1]);
	minn[rt]=min(minn[rt<<1],minn[rt<<1|1]);
}

inline void build(int rt,int l,int r){
	if(l==r){
		sumn[rt]=maxn[rt]=minn[rt]=w[l];
		return;
	}
	build(rt<<1,l,mid);build(rt<<1|1,mid+1,r);
	pushup(rt);
}

inline void pushdown(int rt){
	lz[rt<<1]^=1;lz[rt<<1|1]^=1;
	sumn[rt<<1]=-sumn[rt<<1];sumn[rt<<1|1]=-sumn[rt<<1|1];
	maxn[rt<<1]=-maxn[rt<<1];maxn[rt<<1|1]=-maxn[rt<<1|1];
	minn[rt<<1]=-minn[rt<<1];minn[rt<<1|1]=-minn[rt<<1|1];
	swap(maxn[rt<<1],minn[rt<<1]);
	swap(maxn[rt<<1|1],minn[rt<<1|1]);
	lz[rt]=0;
}

inline void update(int rt,int l,int r,int q,int k){
	if(l==r){
		sumn[rt]=maxn[rt]=minn[rt]=k;
		return;
	}
	if(lz[rt]) pushdown(rt);
	if(q<=mid) update(rt<<1,l,mid,q,k);
	if(q>mid)  update(rt<<1|1,mid+1,r,q,k);
	pushup(rt);
}

inline void change(int rt,int l,int r,int L,int R){
	if(L<=l&&r<=R){
		lz[rt]^=1;
		sumn[rt]=-sumn[rt];
		maxn[rt]=-maxn[rt];
		minn[rt]=-minn[rt];
		swap(maxn[rt],minn[rt]);
		return;
	}
	if(lz[rt]) pushdown(rt);
	if(L<=mid) change(rt<<1,l,mid,L,R);
	if(R>mid)  change(rt<<1|1,mid+1,r,L,R);
	pushup(rt);
}

inline int qsum(int rt,int l,int r,int L,int R){
	int res=0;
	if(L<=l&&r<=R) return sumn[rt];
	if(lz[rt]) pushdown(rt);
	if(L<=mid) res+=qsum(rt<<1,l,mid,L,R);
	if(R>mid)  res+=qsum(rt<<1|1,mid+1,r,L,R);
	pushup(rt);
	return res;
}

inline int qmax(int rt,int l,int r,int L,int R){
	int res=-2147483647;
	if(L<=l&&r<=R) return maxn[rt];
	if(lz[rt]) pushdown(rt);
	if(L<=mid) res=max(res,qmax(rt<<1,l,mid,L,R));
	if(R>mid)  res=max(res,qmax(rt<<1|1,mid+1,r,L,R));
	pushup(rt);
	return res;
}

inline int qmin(int rt,int l,int r,int L,int R){
	int res=2147483647;
	if(L<=l&&r<=R) return minn[rt];
	if(lz[rt]) pushdown(rt);
	if(L<=mid) res=min(res,qmin(rt<<1,l,mid,L,R));
	if(R>mid)  res=min(res,qmin(rt<<1|1,mid+1,r,L,R));
	pushup(rt);
	return res;
}
//以上是线段树
//以下是树链剖分

inline void update(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		change(1,1,n,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	if(x!=y) change(1,1,n,dfn[x]+1,dfn[y]);
}

inline int qsum(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res+=qsum(1,1,n,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	if(x!=y) res+=qsum(1,1,n,dfn[x]+1,dfn[y]);
	return res;
}

inline int qmax(int x,int y){
	int res=-2147483647;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res=max(res,qmax(1,1,n,dfn[top[x]],dfn[x]));
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	if(x!=y) res=max(res,qmax(1,1,n,dfn[x]+1,dfn[y]));
	return res;
}

inline int qmin(int x,int y){
	int res=2147483647;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		res=min(res,qmin(1,1,n,dfn[top[x]],dfn[x]));
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	if(x!=y) res=min(res,qmin(1,1,n,dfn[x]+1,dfn[y]));
	return res;
}

signed main(){
	n=read();
	for(int i=1;i<n;i++){
		int a,b,c;
		a=read()+1;b=read()+1;c=read();
		add(a,b,c);add(b,a,c);
		id[i].x=a;id[i].y=b;
	}
	dfs1(1,0);dfs2(1,1);
	build(1,1,n);
	m=read();
	while(m--){
		char s[10];int a,b;
		scanf("%s",s);a=read();b=read();
		if(s[0]=='C'){
			int tmpp;
			if(dep[id[a].x]>dep[id[a].y]) tmpp=id[a].x;
			else tmpp=id[a].y;
			update(1,1,n,dfn[tmpp],b);
		}
		else if(s[0]=='N'){
			a++,b++;
			update(a,b);
		}
		else if(s[0]=='S'){
			a++,b++;
			write(qsum(a,b));puts("");
		}
		else if(s[0]=='M'&&s[1]=='A'){
			a++,b++;
			write(qmax(a,b));puts("");
		}
		else if(s[0]=='M'&&s[1]=='I'){
			a++,b++;
			write(qmin(a,b));puts("");
		}
	}
	return 0;
}
```



---

## 作者：Farkas_W (赞：19)

$$\text{关于题意}$$

$\quad$一道很简单~~毒瘤~~的树链剖分练习题，只有五种操作，除了码量较大，就没有什么其他特点了，是一道很好的练习题。~~可以锻炼$OIer$找错能力，我调了一个小时， $WA$了一次~~

$$\text{关于边权转点权}$$

$\quad$有几道题也是树链剖分边权转点权，可以先去做一下：[P4114 Qtree1](https://www.luogu.com.cn/problem/P4114)，[P3950 部落冲突](https://www.luogu.com.cn/problem/P3950)([我的题解](https://www.luogu.com.cn/blog/Farkas/solution-p3950))，[CF165D Beard Graph](https://www.luogu.com.cn/problem/CF165D)([我的题解](https://www.luogu.com.cn/blog/Farkas/solution-cf165d))。

$\quad$考虑到树上有 $n$ 个点，有 $n-1$ 条边，并且每个点有且只有一个父亲节点(除了根节点)，但是每个点可能有多个儿子(也可能没有)，所以我们可以将边权转化为儿子节点的点权(深度更大的点)，这样除了根节点，$n-1$ 条边就合理的分配到 $n-1$ 个点上。(如果还不能就看看图吧)

原图

![](https://cdn.luogu.com.cn/upload/image_hosting/o4y4z8vc.png)

经过转化后的图(将边权转化为点权)

![](https://cdn.luogu.com.cn/upload/image_hosting/qtsmvd97.png)

$\quad$注意：对于路径$4-2-5$，只需访问点 $4$ 和点 $5$，对于 $4$ 和 $5$ 的 $LCA$ (最近公共祖先)不可取，因为 $2$ 在原图中对应的是边 $1-2$，并不在路径$4-2-5$上，所以在树链剖分中当 $x$ 和 $y$ 在同一条链上时($dep[x]<dep[y]$)，只需询问 $x+1$ 到 $y$ 的路径。

```cpp
il void dfs1(int x,int fa,int ss) //ss表示x与fa(x的父亲)的连边的权值
{
  father[x]=fa;dep[x]=dep[fa]+1;size[x]=1;a[x]=ss;
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(y==fa)continue;
      dfs1(y,x,s[i]);
      size[x]+=size[y];
      if(size[y]>size[son[x]])son[x]=y;
    }
}

il int query1(int x,int y,int z)
{
  int fx=top[x],fy=top[y],res;
  if(z==1)res=0;
  else if(z==2)res=-10000;
  else if(z==3)res=10000;
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
      if(z==1)res+=query(1,1,n,seg[fx],seg[x],z);
      else if(z==2)res=max(res,query(1,1,n,seg[fx],seg[x],z));
      else if(z==3)res=min(res,query(1,1,n,seg[fx],seg[x],z));
      x=father[fx];fx=top[x];
    }
  if(dep[x]>dep[y])swap(x,y);
  if(seg[x]==seg[y])return res;
  if(z==1)res+=query(1,1,n,seg[x]+1,seg[y],z);//最后一次询问是seg[x]+1到seg[y]
  if(z==2)res=max(res,query(1,1,n,seg[x]+1,seg[y],z));//最后一次询问是seg[x]+1到seg[y]
  if(z==3)res=min(res,query(1,1,n,seg[x]+1,seg[y],z));//最后一次询问是seg[x]+1到seg[y]
  return res;
}
```

$$\text{对于五种操作}$$

1. 操作1：单点修改，输入 $C$ $i$ $w$ 将输入的第 $i$ 条边权值改为 $w$ ，找出第 $i$ 条边的两个端点，修改儿子节点

```cpp
il void change3(int x,int y)
{
  int xx=go[x<<1],yy=go[(x<<1)-1];
  if(xx==father[yy])change1(1,1,n,seg[yy],y);
  else change1(1,1,n,seg[xx],y);
}
```


2. 操作2：区间修改，输入 $N$ $u$ $v$ 将 $u,v$ 节点之间的边权都变为相反数，用布尔数组 $c[k]$ (懒标记)记录k区间内是否要被修改，每次修改 $c[k]$$^$$ =1$;

3. 操作3：区间询问，输入 $SUM$ $u$ $v$ 询问 $u,v$ 节点之间边权和

4. 操作4：区间询问，输入 $MAX$ $u$ $v$ 询问 $u,v$ 节点之间边权最大值

5. 操作5：区间询问，输入 $MIN$ $u$ $v$ 询问 $u,v$ 节点之间边权最小值

$\quad$其他就是一些细节方面的问题了，比如取反时 $sum[k]=-sum[k]$，$Min[k]=-Max[k]$，$Max[k]=-Min[k]$
```cpp
il void change(int k,int l,int r)
{
    int m1=Min[k],m2=Max[k];
    sum[k]=-sum[k];Min[k]=-m2;Max[k]=-m1;c[k]^=1;
}
```

接下来就是完整$AC$代码了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>
using namespace std;
#define next neee
#define re register int
#define il inline
#define inf 1e18
il int read()
{
	int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x*f;
}
il void print(int x)
{if(x<0)putchar('-'),x=-x;if(x/10)print(x/10);putchar(x%10+'0');}
const int N=2e5+5;
int n,m,next[N<<1],go[N<<1],head[N],tot,s[N<<1],a[N],Min[N<<2],top[N];
int sum[N<<2],Max[N<<2],seg[N],rev[N],son[N],size[N],dep[N],father[N];
bool c[N<<2];
il void Add(int x,int y,int z)//链式前向星存图
{next[++tot]=head[x];head[x]=tot;go[tot]=y;s[tot]=z;}
//------------预处理---------------------------
il void dfs1(int x,int fa,int ss)//第一次dfs处理数组father，son，dep，size，a
{
  father[x]=fa;dep[x]=dep[fa]+1;size[x]=1;a[x]=ss;//ss表示x与fa(x的父亲)的连边的权值
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(y==fa)continue;
      dfs1(y,x,s[i]);
      size[x]+=size[y];
      if(size[y]>size[son[x]])son[x]=y;
    }
}
il void dfs2(int x,int topf)//第二次dfs处理数组top，seg，rev
{
  top[x]=topf;seg[x]=++seg[0];rev[seg[x]]=x;
  if(!son[x])return;
  dfs2(son[x],topf);
  for(re i=head[x],y;i,y=go[i];i=next[i])
    {
      if(top[y])continue;
      dfs2(y,y);
    }
}
il void build(int k,int l,int r)//建树
{
  if(l==r){Min[k]=Max[k]=sum[k]=a[rev[l]];return;}
  int mid=l+r>>1;
  build(k<<1,l,mid);build(k<<1|1,mid+1,r);
  Min[k]=min(Min[k<<1],Min[k<<1|1]);
  Max[k]=max(Max[k<<1],Max[k<<1|1]);
  sum[k]=sum[k<<1]+sum[k<<1|1];
}
//------------预处理---------------------------
//------------线段树---------------------------
il void change(int k,int l,int r)//取反操作
{int m1=Min[k],m2=Max[k];sum[k]=-sum[k];Min[k]=-m2;Max[k]=-m1;c[k]^=1;}
il void pushdown(int k,int l,int r,int mid)//下传标记
{if(l==r){c[k]=0;return;}change(k<<1,l,mid);change(k<<1|1,mid+1,r);c[k]=0;}
il void change1(int k,int l,int r,int x,int y)//单点修改
{
  if(l==r){Min[k]=Max[k]=sum[k]=y;return;}
  int mid=l+r>>1;
  if(c[k])pushdown(k,l,r,mid);
  if(x<=mid)change1(k<<1,l,mid,x,y);
  else change1(k<<1|1,mid+1,r,x,y);
  Min[k]=min(Min[k<<1],Min[k<<1|1]);
  Max[k]=max(Max[k<<1],Max[k<<1|1]);
  sum[k]=sum[k<<1]+sum[k<<1|1];
}
il void change2(int k,int l,int r,int x,int y)//区间取反
{
  if(x<=l&&y>=r){change(k,l,r);return;}
  int mid=l+r>>1;
  if(c[k])pushdown(k,l,r,mid);
  if(x<=mid)change2(k<<1,l,mid,x,y);
  if(y>mid)change2(k<<1|1,mid+1,r,x,y);
  Min[k]=min(Min[k<<1],Min[k<<1|1]);
  Max[k]=max(Max[k<<1],Max[k<<1|1]);
  sum[k]=sum[k<<1]+sum[k<<1|1];
}
il int query(int k,int l,int r,int x,int y,int z)//区间询问
{
  if(x<=l&&y>=r){
    if(z==1)return sum[k];//z==1-->>求SUM
    if(z==2)return Max[k];//z==2-->>求MAX
    return Min[k];}		//z==3-->>求MIN
  int mid=l+r>>1,res;
  if(c[k])pushdown(k,l,r,mid);
  if(z==1){res=0;if(x<=mid)res+=query(k<<1,l,mid,x,y,z);if(y>mid)res+=query(k<<1|1,mid+1,r,x,y,z);return res;}
  if(z==2){res=-10000;if(x<=mid)res=max(res,query(k<<1,l,mid,x,y,z));if(y>mid)res=max(res,query(k<<1|1,mid+1,r,x,y,z));return res;}
  res=10000;if(x<=mid)res=min(res,query(k<<1,l,mid,x,y,z));if(y>mid)res=min(res,query(k<<1|1,mid+1,r,x,y,z));return res;
}
//------------线段树--------------------------
//------------树链剖分------------------------
il void change3(int x,int y)
{
  int xx=go[x<<1],yy=go[(x<<1)-1];
  if(xx==father[yy])change1(1,1,n,seg[yy],y);
  else change1(1,1,n,seg[xx],y);
}
il void change4(int x,int y)
{
  int fx=top[x],fy=top[y];
  while(fx!=fy){
    if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
    change2(1,1,n,seg[fx],seg[x]);	//链顶在前
    x=father[fx];fx=top[x];
  }
  if(dep[x]>dep[y])swap(x,y);
  if(seg[x]+1<=seg[y])change2(1,1,n,seg[x]+1,seg[y]);//记得seg[x]+1
}
il int query1(int x,int y,int z)
{
  int fx=top[x],fy=top[y],res;
  if(z==1)res=0;
  else if(z==2)res=-10000;
  else if(z==3)res=10000;
  while(fx!=fy)
    {
      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
      if(z==1)res+=query(1,1,n,seg[fx],seg[x],z);
      else if(z==2)res=max(res,query(1,1,n,seg[fx],seg[x],z));
      else if(z==3)res=min(res,query(1,1,n,seg[fx],seg[x],z));
      x=father[fx];fx=top[x];
    }
  if(dep[x]>dep[y])swap(x,y);
  if(seg[x]==seg[y])return res;
  if(z==1)res+=query(1,1,n,seg[x]+1,seg[y],z);//最后一次询问是seg[x]+1到seg[y]
  if(z==2)res=max(res,query(1,1,n,seg[x]+1,seg[y],z));//最后一次询问是seg[x]+1到seg[y]
  if(z==3)res=min(res,query(1,1,n,seg[x]+1,seg[y],z));//最后一次询问是seg[x]+1到seg[y]
  return res;
}
//------------树链剖分------------------------
signed main()
{
  n=read();
  for(re i=1;i<n;i++)
  {re x=read()+1,y=read()+1,z=read();Add(x,y,z);Add(y,x,z);}
  m=read();
  dfs1(1,0,0);dfs2(1,1);build(1,1,n);//树链剖分预处理
  string s1;
  while(m--)
    {
      cin>>s1;re x=read()+1,y=read()+1,z=0;
      if(s1=="C"){change3(x-1,y-1);continue;}
      if(s1=="N"){change4(x,y);continue;}
      if(s1=="SUM")z=1;else if(s1=="MAX")z=2;else if(s1=="MIN")z=3;
      print(query1(x,y,z));putchar('\n');
    }
  return 0;
}
```
$\quad$写题解不易，如果觉得对您有帮助，不妨点个赞吧！

---

## 作者：feicheng (赞：14)

# P1505题解


------------
## 思路：

打这道题的时候手感特别好，基本等于一次过

其实这道题就是要查的东西比较多，等同于树剖模板。

首先边权转点权这种操作就不用说了吧，把边权下放到儿子节点就可以了。

然后就是线段树维护剖分过后的链，此题中线段树的节点需要维护以下信息：

1. 左右端点
2. 区间最小最大值
3. 区间和
4. 是否翻转的懒标记

主要对第4点信息解释一下，因为这道题要求将区间的所有数变成相反数，所以我们用1来维护要翻转，0维护不用翻转，每次pushdown的时候异或一下就可以了。

如何pushdown？

对每一次取相反，最大值变成最小值，最小值变成最大值，区间和变为相反数，懒标记异或即可。但在这里要注意：要先开一个临时变量存储最大值（或最小值）。

**得84分的同学看过来**：其实代码是没有问题的，只是题目中的节点是从0开始的（我也不清楚为什么从1开始还能拿84分）。

处理方法就是给所有的输入+1

## 代码
------------
$dfn$ 是剖分后的节点编号，$x$ 和 $y$ 数组表示输入的第$i$条边的起始和终点。

在第一次 $dfs$ 的时候把边权下放，用 $va$ 数组存储原来节点对应的边权，$val$ 存储节点剖分后对应的边权。

然后就没什么要注意的了，记得边权下放要+1

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ri register int
#define IO ios::sync_with_stdio(false)
#define mid ((a[x].l+a[x].r)>>1)
using namespace std;
template < typename T >
inline void read(T &x){
	x = 0;bool flag = 1;char c = getchar();
	while(c < '0' or c > '9'){
		if(c == '-') flag = 0;
		c = getchar();
	}
	while(c >= '0' and c <= '9'){
		x = (x << 1) + (x << 3) + (c^48);	c = getchar();
	}
	x = (flag) ? x : -x ;
}
template < typename T >
void print(T x)
{
	if(x < 0){putchar('-'),x=-x;}
	if(x>9)print(x/10);
	putchar(int (x%10) + '0');
}

const int N = 2e5 + 10;
int head[N],dfn[N],top[N],siz[N],fa[N],son[N],va[N],val[N],dep[N],x[N],y[N];
int to[N<<1],nxt[N<<1],w[N<<1];
int n,m,cnt,tim;
struct node{
	int l,r,mins,sum,maxs,laz;
}a[N<<2];

inline void add(int u,int v,int val){to[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt,w[cnt]=val;}

void dfs1(int x,int f){
	fa[x]=f,siz[x]=1,dep[x]=dep[f]+1;
	int ms=-1;
	for(int i=head[x];i;i=nxt[i]){
		int v=to[i];
		if(v==f) continue;
		va[v]=w[i];
		dfs1(v,x);
		siz[x]+=siz[v];
		if(ms<siz[v]) ms=siz[v],son[x]=v;
	}
}

void dfs2(int x,int t){
	top[x]=t,dfn[x]=++tim,val[tim]=va[x];
	if(!son[x]) return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=nxt[i]){
		int v=to[i];
		if(v==fa[x]||v==son[x])continue;
		dfs2(v,v);
	}
}

//seg
inline void pushup(int x){
	a[x].sum=a[x<<1].sum+a[x<<1|1].sum;
	a[x].maxs=max(a[x<<1].maxs,a[x<<1|1].maxs);
	a[x].mins=min(a[x<<1].mins,a[x<<1|1].mins);
}
inline void ch(int x){
	int tmp=a[x].maxs;
	a[x].laz^=1;
	a[x].maxs=-a[x].mins,a[x].mins=-tmp,a[x].sum=-a[x].sum;
}
inline void pushdown(int x){
	if(!a[x].laz) return;
	ch(x<<1),ch(x<<1|1);
	a[x].laz^=1;
}

void build(int x,int l,int r){
	a[x].l=l,a[x].r=r;
	if(l==r) return a[x].mins=a[x].maxs=a[x].sum=val[l],void();
	build(x<<1,l,mid),build(x<<1|1,mid+1,r);
	pushup(x);
}

void mpoint(int x,int p,int k){
	if(a[x].l==a[x].r) return a[x].sum=a[x].mins=a[x].maxs=k,void();
	pushdown(x);
	if(p<=mid)mpoint(x<<1,p,k);
	else mpoint(x<<1|1,p,k);
	pushup(x);
}

void modify(int x,int l,int r){
	if(a[x].l>=l&&a[x].r<=r) return ch(x),void();
	pushdown(x);
	if(l <= mid) modify(x<<1,l,r);
	if(mid < r ) modify(x<<1|1,l,r);
	pushup(x);
}

int qsum(int x,int l,int r){
	if(a[x].l>=l&&a[x].r<=r) return a[x].sum;
	pushdown(x);
	int res=0;
	if(l<=mid) res+=qsum(x<<1,l,r);
	if(mid <r) res+=qsum(x<<1|1,l,r);
	return res;
}

int qmin(int x,int l,int r){
	if(a[x].l>=l&&a[x].r<=r) return a[x].mins;
	pushdown(x);
	int res=0x7fffffff;
	if(l<=mid) res=min(res,qmin(x<<1,l,r));
	if(mid <r) res=min(res,qmin(x<<1|1,l,r));
	return res;
}

int qmax(int x,int l,int r){
	if(a[x].l>=l&&a[x].r<=r) return a[x].maxs;
	pushdown(x);
	int res=-0x7fffffff;
	if(l<=mid) res=max(res,qmax(x<<1,l,r));
	if(mid <r) res=max(res,qmax(x<<1|1,l,r));
	return res;
}

void mchain(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		modify(1,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x] > dep[y]) swap(x,y);
	modify(1,dfn[x]+1,dfn[y]);
}

int qcsum(int x,int y){
	int res=0;
	while(top[x]!=top[y]){
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		res+=qsum(1,dfn[top[x]],dfn[x]);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res+=qsum(1,dfn[x]+1,dfn[y]);
	return res;
}

int qcmin(int x,int y){
	int res=0x7fffffff;
	while(top[x]!=top[y]){
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		res=min(res,qmin(1,dfn[top[x]],dfn[x]));
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res=min(res,qmin(1,dfn[x]+1,dfn[y]));
	return res;
}

int qcmax(int x,int y){
	int res=-0x7fffffff;
	while(top[x]!=top[y]){
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		res=max(res,qmax(1,dfn[top[x]],dfn[x]));
		x=fa[top[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	res=max(res,qmax(1,dfn[x]+1,dfn[y]));//记得要+1
	return res;
}

void medge(int u,int v,int w){
	if(fa[u]==v) mpoint(1,dfn[u],w);
	else mpoint(1,dfn[v],w);
}

int main(int argc,const char *argv[]){
	string tmp;
	int u,v,w;
	read(n);
	for(int i = 1; i < n ; i++){
		read(u),read(v),read(w);
		x[i]=u+1,y[i]=v+1;
		add(u+1,v+1,w),add(v+1,u+1,w);
	}
	dfs1(1,1),dfs2(1,1),build(1,1,n);
	read(m);
	while(m--){
		cin >> tmp;
		read(u),read(v);
		if(tmp=="C") medge(x[u],y[u],v);
		else if(tmp=="N") mchain(u+1,v+1);
		else if(tmp=="SUM") print(qcsum(u+1,v+1)),putchar('\n');
		else if(tmp=="MIN") print(qcmin(u+1,v+1)),putchar('\n');
		else if(tmp=="MAX") print(qcmax(u+1,v+1)),putchar('\n');
	}
	return 0;
}



```


---

## 作者：KiDDOwithTopTree (赞：8)

题目在这：[传送门](https://www.luogu.com.cn/problem/P1505)

### 做法：Link-Cut-Tree。

~~虽然这一题的正解是重链剖分，但是因为我最近在刷 LCT 的题目，所以我在用重链剖分做过一次之后，又用 LCT 再写了一遍。~~

不难发现，我们这一题不是我们 LCT 所熟悉的点权，而是边权。

#### 那么我们就要思考如何把边权转换为点权。

因为 LCT 的结构不像重链剖分那样是固定的，而是会改变的，所以我们不能直接把边权下方成为点权。

怎么办呢？

我们可以考虑对每一条边都转换成 LCT 中的点，那么我们可以把第 $i$ 条边标号为 $n+i$ 号点，然后只在边点上进行存储值。

题目要求我们改边权、取相反数、求边权和、边权最大值、边权最小值，那么我们可以这样定义结构体：

```cpp
struct splay{
	int fa,son[2];
	int maxn,minn;//存储最大、最小值
	int sum,val;//sum表示总和，val表示当前点的值
	int rev,tag;//rev是翻转标记，tag是取反标记
};
splay spl[N];
```

然后改动比较大的便是 pushup 函数：

```cpp
inline void pushup(int pos){
	int lson=spl[pos].son[0],rson=spl[pos].son[1];
	spl[pos].sum=spl[lson].sum+spl[rson].sum+spl[pos].val;//统计和
	spl[pos].maxn=pos>n?spl[pos].val:-INF;
	//统计最大值。如果它是边点（pos>n），就直接赋值为val，否则赋值为负无穷
	spl[pos].minn=pos>n?spl[pos].val:INF;
	//统计最小值。如果它是边点（pos>n），就直接赋值为val，否则赋值为正无穷
	if(lson){//注意如果有左儿子时才算上左儿子
		spl[pos].maxn=max(spl[pos].maxn,spl[lson].maxn);
		spl[pos].minn=min(spl[pos].minn,spl[lson].minn);
	}
	if(rson){//同理
		spl[pos].maxn=max(spl[pos].maxn,spl[rson].maxn);
		spl[pos].minn=min(spl[pos].minn,spl[rson].minn);
	}
}
```

因为我们下传标记时不仅要下传 rev 标记，还要下传 tag 标记，所以要改改 pushdown。

```cpp
inline void pushdown(int pos){
	if(spl[pos].rev){//rev标记的下传
		swap(spl[pos].son[0],spl[pos].son[1]);
		spl[spl[pos].son[0]].rev^=1;
		spl[spl[pos].son[1]].rev^=1;
		spl[pos].rev=0;
	}
	if(spl[pos].tag){//tag标记的下传
		int lson=spl[pos].son[0],rson=spl[pos].son[1];
		swap(spl[lson].maxn,spl[lson].minn);
		spl[lson].maxn=-spl[lson].maxn;
		spl[lson].minn=-spl[lson].minn;
		spl[lson].sum=-spl[lson].sum;
		spl[lson].val=-spl[lson].val;
		spl[lson].tag^=1;
		swap(spl[rson].maxn,spl[rson].minn);
		spl[rson].maxn=-spl[rson].maxn;
		spl[rson].minn=-spl[rson].minn;
		spl[rson].sum=-spl[rson].sum;
		spl[rson].val=-spl[rson].val;
		spl[rson].tag^=1;
		spl[pos].tag=0;
	}
}
```

其它的其实和模板差不多了。

LCT 虽是1只 log，但是因为常数原因这一题还可能会T。所以应该使用一些优化。~~实在不行可以试试吸氧。~~

放上代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=1e6+10,INF=2e9+10;
struct splay{
	int fa,son[2];
	int maxn,minn;
	int sum,val;
	int rev,tag;
};
splay spl[N];
string s;
int n;
inline bool check_root(int pos){
	return spl[spl[pos].fa].son[0]!=pos&&spl[spl[pos].fa].son[1]!=pos;
}
inline int relation(int pos,int fa){
	return spl[fa].son[1]==pos;
}
inline void connect(int pos,int fa,int son){
	spl[pos].fa=fa;
	spl[fa].son[son]=pos;
}
inline void pushup(int pos){
	int lson=spl[pos].son[0],rson=spl[pos].son[1];
	spl[pos].sum=spl[lson].sum+spl[rson].sum+spl[pos].val;
	spl[pos].maxn=pos>n?spl[pos].val:-INF;
	spl[pos].minn=pos>n?spl[pos].val:INF;
	if(lson){
		spl[pos].maxn=max(spl[pos].maxn,spl[lson].maxn);
		spl[pos].minn=min(spl[pos].minn,spl[lson].minn);
	}
	if(rson){
		spl[pos].maxn=max(spl[pos].maxn,spl[rson].maxn);
		spl[pos].minn=min(spl[pos].minn,spl[rson].minn);
	}
}
inline void pushdown(int pos){
	if(spl[pos].rev){
		swap(spl[pos].son[0],spl[pos].son[1]);
		spl[spl[pos].son[0]].rev^=1;
		spl[spl[pos].son[1]].rev^=1;
		spl[pos].rev=0;
	}
	if(spl[pos].tag){
		int lson=spl[pos].son[0],rson=spl[pos].son[1];
		swap(spl[lson].maxn,spl[lson].minn);
		spl[lson].maxn=-spl[lson].maxn;
		spl[lson].minn=-spl[lson].minn;
		spl[lson].sum=-spl[lson].sum;
		spl[lson].val=-spl[lson].val;
		spl[lson].tag^=1;
		swap(spl[rson].maxn,spl[rson].minn);
		spl[rson].maxn=-spl[rson].maxn;
		spl[rson].minn=-spl[rson].minn;
		spl[rson].sum=-spl[rson].sum;
		spl[rson].val=-spl[rson].val;
		spl[rson].tag^=1;
		spl[pos].tag=0;
	}
}
inline void pushall(int pos){
	if(!check_root(pos))
		pushall(spl[pos].fa);
	pushdown(pos);
}
void rotate(int pos){
	int fa=spl[pos].fa,gf=spl[fa].fa;
	int t1=relation(pos,fa),t2=relation(fa,gf);
	connect(spl[pos].son[t1^1],fa,t1);
	connect(fa,pos,t1^1);
	spl[pos].fa=gf;
	if(spl[gf].son[t2]==fa)
		spl[gf].son[t2]=pos;
	pushup(fa);
	pushup(pos);
}
void splaying(int pos){
	pushall(pos);
	while(!check_root(pos)){
		int fa=spl[pos].fa,gf=spl[fa].fa;
		if(!check_root(fa))
			relation(pos,fa)^relation(fa,gf)?rotate(pos):rotate(fa);
		rotate(pos);
	}
}
void access(int pos){
	int son=0;
	while(pos){
		splaying(pos);
		spl[pos].son[1]=son;
		pushup(pos);
		son=pos;
		pos=spl[pos].fa;
	}
}
void make_root(int pos){
	access(pos);
	splaying(pos);
	spl[pos].rev^=1;
}
void link(int x,int y){
	make_root(x);
	spl[x].fa=y;
}
void split(int x,int y){
	make_root(x);
	access(y);
	splaying(y);
}
int main(){
	scanf("%d",&n);
	int x,y,z;
	for(int i=1;i<=n-1;i++){
		scanf("%d%d%d",&x,&y,&z);
		x++;
		y++;
		spl[n+i].maxn=spl[n+i].minn=spl[n+i].val=z;//边转点
		link(x,n+i);
		link(n+i,y);
	}
	int m;
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		cin>>s;
		scanf("%d%d",&x,&y);
		switch(s[0]){
			case 'C':
				splaying(n+x);
				spl[n+x].val=y;
				pushup(n+x);
				break;
			case 'N':
				x++;
				y++;
				split(x,y);
				swap(spl[y].maxn,spl[y].minn);
				spl[y].maxn=-spl[y].maxn;
				spl[y].minn=-spl[y].minn;
				spl[y].sum=-spl[y].sum;
				spl[y].val=-spl[y].val;
				spl[y].tag^=1;
				//注意要在这修改y
				break;
			case 'S':
				x++;
				y++;
				split(x,y);
				printf("%d\n",spl[y].sum);
				break;
			case 'M':
				x++;
				y++;
				split(x,y);
				if(s[1]=='A')
					printf("%d\n",spl[y].maxn);
				else
					printf("%d\n",spl[y].minn);
				break;
		}
	}
}
```

可能是我码风比较怪，重链剖分写了 5KB，而 LCT 只写了 3KB；重链剖分的申请内存为 40MB，而 LCT 只用了 20MB。如果不计常数，那么LCT则是在时复、空复、代码长度上完胜重链剖分。所以建议学习一下。

---

## 作者：watermonster (赞：6)

看到树上点对之间的修改和询问就知道是树剖了。

由于询问和操作都是在边上，我们还需要将边权转为点权。与其他树剖题不同的是，`C i`操作需要我们直接修改一条指定的边的边权，而不是修改两点之间的边权，所以我们还需要记录每条边将边权转到了哪个点上。

具体操作方法：

```cpp
il void dfs1(int x,int fa)
{
	siz[x]=1;son[x]=0;dep[x]=dep[fa]+1;f[x]=fa;
	for(re int i=h[x];i;i=e[i].nxt)
		if(e[i].v^fa)
		{
			etp[(i+1)>>1]=e[i].v;
			W[e[i].v]=e[i].w;
			dfs1(e[i].v,x);
			siz[x]+=siz[e[i].v];
			son[x]=siz[son[x]]<siz[e[i].v]?e[i].v:son[x];
		}
}
```

 我们可以在第一次$\text{dfs}$中存下每条边指向的儿子的编号，也就代码中的`ept[]`（$edge\ to\ point$）。

解决了边转点的问题后，我们再来考虑如何用线段树来维护题目要求的操作。 

1. `C i` 就是在$dfn[etp[i]]$上单点修改

   ```cpp
   il void change1(int p,int pos,int x)
   {
   	if(L[p]==R[p]){Sum[p]=Max[p]=Min[p]=x;return;}
   	re int mid=(L[p]+R[p])>>1;
   	pushdown(p);
   	if(pos>mid) change1(rs(p),pos,x);
   	else change1(ls(p),pos,x);
   	pushup(p);
   }
   
   il void modify1(int p,int w){change1(1,dfn[p],w);}
   
   if(ch=='C') modify1(etp[u],v);
   ```

2. `N u v`区间取反，也就是区间乘以$-1$（注意最大值和最小值要交换）

   ``` cpp
   il void pushdown(int p)
   {
   	if(!lz[p]) return;
   	Sum[ls(p)]*=-1;Sum[rs(p)]*=-1;
   	swap(Max[ls(p)],Min[ls(p)]);
   	swap(Max[rs(p)],Min[rs(p)]);
   	Max[ls(p)]*=-1;Min[ls(p)]*=-1;
   	Max[rs(p)]*=-1;Min[rs(p)]*=-1;
   	lz[ls(p)]^=1;lz[rs(p)]^=1;
   	lz[p]=0;
   }
   il void change2(int p,int l,int r)
   {
   	if(L[p]>r||R[p]<l) return;
   	if(L[p]>=l&&R[p]<=r)
   	{
   		lz[p]^=1;
   		Sum[p]*=-1;
   		swap(Max[p],Min[p]);
   		Max[p]*=-1;Min[p]*=-1;
   		return;
   	}
   	pushdown(p);
   	change2(ls(p),l,r);
   	change2(rs(p),l,r);
   	pushup(p);
   }
   
   il void modify2(int u,int v)
   {
   	while(top[u]^top[v])
   	{
   		if(dep[top[u]]<dep[top[v]]) swap(u,v);
   		change2(1,dfn[top[u]],dfn[u]);
   		u=f[top[u]];
   	}
   	if(dep[u]<dep[v]) swap(u,v);
   	change2(1,dfn[v]+1,dfn[u]);
   }
   
   if(ch=='N') modify2(u+1,v+1);
   ```

3. `SUM u v`也就是区间求和

   ```cpp
   il int query1(int p,int l,int r)
   {
   	if(L[p]>r||R[p]<l) return 0;
   	if(L[p]>=l&&R[p]<=r) return Sum[p];
   	pushdown(p);
   	return query1(ls(p),l,r)+query1(rs(p),l,r);
   }
   
   il int ask1(int u,int v)
   {
   	re int res=0;
   	while(top[u]^top[v])
   	{
   		if(dep[top[u]]<dep[top[v]]) swap(u,v);
   		res+=query1(1,dfn[top[u]],dfn[u]);
   		u=f[top[u]];
   	}
   	if(dep[u]<dep[v]) swap(u,v);
   	res+=query1(1,dfn[v]+1,dfn[u]);
   	return res;
   }
   
   if(ch=='S') print(ask1(u+1,v+1));
   ```

4. `MAX u v`和`MIN u v`区间最值查询

   ```cpp
   il int query2(int p,int l,int r)
   {
   	if(L[p]>r||R[p]<l) return -inf;
   	if(L[p]>=l&&R[p]<=r) return Max[p];
   	pushdown(p);
   	return max(query2(ls(p),l,r),query2(rs(p),l,r));
   }
   il int query3(int p,int l,int r)
   {
   	if(L[p]>r||R[p]<l) return inf;
   	if(L[p]>=l&&R[p]<=r) return Min[p];
   	pushdown(p);
   	return min(query3(ls(p),l,r),query3(rs(p),l,r));
   }
   
   
   il int ask2(int u,int v)
   {
   	re int res=-inf;
   	while(top[u]^top[v])
   	{
   		if(dep[top[u]]<dep[top[v]]) swap(u,v);
   		res=max(res,query2(1,dfn[top[u]],dfn[u]));
   		u=f[top[u]];
   	}
   	if(dep[u]<dep[v]) swap(u,v);
   	res=max(res,query2(1,dfn[v]+1,dfn[u]));
   	return res;
   }
   il int ask3(int u,int v)
   {
   	re int res=inf;
   	while(top[u]^top[v])
   	{
   		if(dep[top[u]]<dep[top[v]]) swap(u,v);
   		res=min(res,query3(1,dfn[top[u]],dfn[u]));
   		u=f[top[u]];
   	}
   	if(dep[u]<dep[v]) swap(u,v);
   	res=min(res,query3(1,dfn[v]+1,dfn[u]));
   	return res;
   }
   
   if(ch=='A') print(ask2(u+1,v+1));
   if(ch=='I') print(ask3(u+1,v+1));
   ```

完整代码太长，就不给了。

---

## 作者：摸鱼酱 (赞：4)

**这篇题解主要讲代码实现，思路可能需要照着代码理解，请慎重阅读**

两张图片挂了，重新传了一遍。

最后代码写出来3.5Kb，不到150行，相对来说还是挺短的...

给定一棵 $n$ 个节点的树，边带权，编号 $0 \sim n-1$，需要支持五种操作：

- `C i w` 将输入的第 $i$ 条边权值改为 $w$
- `N u v` 将 $u,v$ 节点之间的边权都变为相反数
- `SUM u v` 询问 $u,v$ 节点之间边权和
- `MAX u v` 询问 $u,v$ 节点之间边权最大值
- `MIN u v` 询问 $u,v$ 节点之间边权最小值

保证任意时刻所有边的权值都在 $[-1000,1000]$ 内。

--------------------

前置知识：树链剖分。

主要讲代码实现。

首先因为树的编号不好看，所以都加一。

然后分操作考虑。

数组定义写在前面：

```
dep:深度
fa:父亲结点
sz:子树大小
son:重儿子
id:结点对应的dfs序
rk:dfs序对应的结点
ID[i]:用来承接 [数组中存储的编号为id 的边] 的信息的点编号
a[u]:点u承接下来的信息
top:重链顶端
线段树结点(动态开点):{lc,rc(左右儿子),w(区间和),mx,mn(极值),f(=±1,表示未下传的取相反数标记)}
```



#### Part 0 整体思路

因为传统的重链剖分是把信息对于点来储存，对于边考虑怎么算。

于是就有一个很朴素的想法，把每条边的边权**下沉**到对应的点。

也就是像下面这样，用u号点来承接边(f→u)的权值。

![](https://cdn.luogu.com.cn/upload/image_hosting/0r46jfp6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

因为输入的边不一定是从父亲到儿子，所以我们考虑把输入的第 $i$ 条边记录到数组里第 $2i,2i+1$ 的位置。

这样我们在重链剖分dfs的时候，假设通过点 $u$ 走到了 $v=to[i]$ ，那么我们就承接边权到 $v$ ，即`a[v]=val[i]`，同时为了方便修改边权落实到修改点权，记录`ID[i/2]=v`。

然后考虑这样会对查询操作有什么影响，显然如下图：

![image-20210309213411599](https://cdn.luogu.com.cn/upload/image_hosting/u65pyci4.png)

我们要求 $u,v$ 之间的边权信息，但是常规的重链剖分会把上面打×的边也统计。

这个解决就考虑树链剖分查询操作的时候，最终会有一段对于 `id[x],id[y]` 的查询 (`id[x]<id[y]`) ，是在同一条重链上的，那么对应的 `id[x]+1,id[y]` 就不包括它们的LCA x。

于是这个问题也解决了。就可以开始干代码了。

先有三个基础的函数放在这里。

```
void up(int k){
	t[k].w=t[ls].w+t[rs].w,t[k].mx=max(t[ls].mx,t[rs].mx),t[k].mn=min(t[ls].mn,t[rs].mn);
}
void down(int k){
	if(t[k].f==1)return;
	opp(ls),opp(rs),t[k].f=1;
}
void opp(int k){
	swap(t[k].mn,t[k].mx),t[k].mn*=-1,t[k].mx*=-1,t[k].w*=-1,t[k].f*=-1;
}
```

分别是线段树的`push_up,push_down`和把结点 $k$ 整体取反。

这里说下整体取反。显然就是新的最小值等于原来最大值的相反数，最大值同理。权值和就等于之前的相反数。

注意：这里的 $f$ 是还没有传下去的标记，不能抵消将要打在自己身上的取反操作。

----------

#### Part 1 单点赋值

这个是基础线段树操作，输入把边 $u$ 赋值为 $w$ ，那就把线段树上的 `id[ID[u]]` 赋值成 $w$ 。

```
void modify(int k,int l,int r,int pos,int x){//单点pos赋值x 
	if(l==r)return t[k].w=t[k].mx=t[k].mn=x,void();
	down(k);
	int m=l+r>>1;
	if(pos<=m)modify(ls,l,m,pos,x);
	else modify(rs,m+1,r,pos,x);
	up(k);
}
```

-------------------

#### Part 2 两点路径取相反数

先是常规套路，把线段树上的一段给取相反数。

这个显然也是基础的线段树的操作。

```
void md(int k,int l,int r,int x,int y){//一段取反 
	if(x<=l&&r<=y)return opp(k);
	down(k);
	int m=l+r>>1;
	if(x<=m)md(ls,l,m,x,y);
	if(y>m)md(rs,m+1,r,x,y);
	up(k);
}
```

然后也是重链剖分的板子。

注意这里的`if(x==y)return;` ，因为如果最后x,y重合，表示它们都是输入的x,y的LCA，那么贡献就不能记录到答案里。

```
void modi(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		md(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(x==y)return;
	if(id[x]>id[y])swap(x,y);
	md(1,1,n,id[x]+1,id[y]);
}
```

--------------------

#### Part 3 三种查询

发现这三种查询本质相同。

于是代码基本就和树链剖分板子一样了。

```
void ask_xds(int k,int l,int r,int x,int y,int op){//1:sum 2:max 3:min
	if(x<=l&&r<=y){
		if(op==1)res+=t[k].w;
		if(op==2)res=max(res,t[k].mx);
		if(op==3)res=min(res,t[k].mn);
		return;
	}
	down(k);
	int m=l+r>>1;
	if(x<=m)ask_xds(ls,l,m,x,y,op);
	if(y>m)ask_xds(rs,m+1,r,x,y,op);
	up(k);
}
int ask(int x,int y,int op){//1:sum 2:max 3:min
	 int ans=op==1?0:(op==2?-1e9:1e9);
	 while(top[x]!=top[y]){
	 	if(dep[top[x]]<dep[top[y]])swap(x,y);
		res=op==1?0:(op==2?-1e9:1e9);
		ask_xds(1,1,n,id[top[x]],id[x],op);
		if(op==1)ans+=res;
		if(op==2)ans=max(ans,res);
		if(op==3)ans=min(ans,res);
		x=fa[top[x]];
	 }
	 if(id[x]>id[y])swap(x,y);
	 if(x==y)return ans;
	 res=op==1?0:(op==2?-1e9:1e9);
	 ask_xds(1,1,n,id[x]+1,id[y],op);
	if(op==1)ans+=res;
	if(op==2)ans=max(ans,res);
	if(op==3)ans=min(ans,res);
	return ans;
}
```

------------------------



[完整代码Link](https://www.luogu.com.cn/paste/n4yj1h3w)



---

## 作者：宣毅鸣 (赞：4)

# Problem
维护一棵树，有5种操作

- 一条链取反
- 一条边求反
- 一条链上求和、最大、小值

# Solution
- 树链剖分，然后线段树维护即可

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=800005;
char opt[10];
int ne[N],tot,fi[N],zz[N],size[N],sd[N],fa[N],w[N],son[N],sl[N],x,y,z,u[N];
int v[N],n,m,top[N],id[N],rk[N];
struct Tree{
	int l,r,num1,num2,num3,flag2;
}T[N*4];
void jb(int x,int y,int z){
	ne[++tot]=fi[x];
	fi[x]=tot;
	zz[tot]=y;
	sl[tot]=z;
}
void dfs1(int x,int y,int z){
	size[x]=1;sd[x]=z;fa[x]=y;
	for (int i=fi[x];i;i=ne[i])
		if (zz[i]!=y){
			w[zz[i]]=sl[i];
			dfs1(zz[i],x,z+1);
			size[x]+=size[zz[i]];
			if (size[zz[i]]>size[son[x]])son[x]=zz[i];
		}
}
void dfs2(int x,int y){
	top[x]=y;rk[x]=++tot;id[tot]=x;
	if (son[x])dfs2(son[x],y);
	for (int i=fi[x];i;i=ne[i])
		if (zz[i]!=fa[x]&&zz[i]!=son[x])dfs2(zz[i],zz[i]);
}
int len(int x){
	return T[x].r-T[x].l+1;
}
void update(int x){
	T[x].num1=T[x*2].num1+T[x*2+1].num1;
	T[x].num2=max(T[x*2].num2,T[x*2+1].num2);
	T[x].num3=min(T[x*2].num3,T[x*2+1].num3);
}
void down(int x){
	if (T[x].flag2){
		T[x].flag2=0;
		if (T[x].l==T[x].r)return;
		T[x*2].flag2^=1;
		T[x*2+1].flag2^=1;
		T[x*2].num1*=-1;
		T[x*2+1].num1*=-1;
		swap(T[x*2].num2,T[x*2].num3);
		swap(T[x*2+1].num2,T[x*2+1].num3);
		T[x*2].num2*=-1;
		T[x*2+1].num2*=-1;
		T[x*2].num3*=-1;
		T[x*2+1].num3*=-1;
	}
}
void build(int x,int l,int r){
	T[x].l=l;T[x].r=r;
	if (l==r){
		T[x].flag2=0;
		T[x].num1=T[x].num2=T[x].num3=w[id[l]];
		return;
	}
	int mid=(l+r)/2;
	build(x*2,l,mid);
	build(x*2+1,mid+1,r);
	update(x);
}
void insert1(int x,int y,int z){
	if (T[x].l==T[x].r){
		T[x].num1=T[x].num2=T[x].num3=z;
		return;
	}
	down(x);
	int mid=(T[x].l+T[x].r)/2;
	if (y<=mid)insert1(x*2,y,z);
	else insert1(x*2+1,y,z);
	update(x);
}
void insert2(int x,int l,int r){
	if (l>T[x].r||T[x].l>r)return;
	if (T[x].l>=l&&T[x].r<=r){
		T[x].num1=-T[x].num1;
		swap(T[x].num2,T[x].num3);
		T[x].num2=-T[x].num2;
		T[x].num3=-T[x].num3;
		T[x].flag2^=1;
		return;
	}
	down(x);
	insert2(x*2,l,r);
	insert2(x*2+1,l,r);
	update(x);
}
int ask1(int x,int l,int r){
	if (T[x].l>r||l>T[x].r)return 0;
	if (T[x].l>=l&&T[x].r<=r)return T[x].num1;
	down(x);
	return ask1(x*2,l,r)+ask1(x*2+1,l,r);
}
int ask2(int x,int l,int r){
	if (T[x].l>r||l>T[x].r)return -2e9;
	if (T[x].l>=l&&T[x].r<=r)return T[x].num2;
	down(x);
	return max(ask2(x*2,l,r),ask2(x*2+1,l,r));
}
int ask3(int x,int l,int r){
	if (T[x].l>r||l>T[x].r)return 2e9;
	if (T[x].l>=l&&T[x].r<=r)return T[x].num3;
	down(x);
	return min(ask3(x*2,l,r),ask3(x*2+1,l,r));
}
int find1(int x,int y){
	int ans=0,fx=top[x],fy=top[y];
	while (fx!=fy){
		if (sd[fx]<sd[fy]){
			swap(x,y);
			swap(fx,fy);
		}
		ans+=ask1(1,rk[fx],rk[x]);
		x=fa[fx];fx=top[x];
	}
	if (x==y)return ans;
	if (sd[x]<sd[y])swap(x,y);
	ans+=ask1(1,rk[y]+1,rk[x]);
	return ans;
}
int find2(int x,int y){
	int ans=-2e9,fx=top[x],fy=top[y];
	while (fx!=fy){
		if (sd[fx]<sd[fy]){
			swap(x,y);
			swap(fx,fy);
		}
		ans=max(ans,ask2(1,rk[fx],rk[x]));
		x=fa[fx];fx=top[x];
	}
	if (x==y)return ans;
	if (sd[x]<sd[y])swap(x,y);
	ans=max(ans,ask2(1,rk[y]+1,rk[x]));
	return ans;
}
int find3(int x,int y){
	int ans=2e9,fx=top[x],fy=top[y];
	while (fx!=fy){
		if (sd[fx]<sd[fy]){
			swap(x,y);
			swap(fx,fy);
		}
		ans=min(ans,ask3(1,rk[fx],rk[x]));
		x=fa[fx];fx=top[x];
	}
	if (x==y)return ans;
	if (sd[x]<sd[y])swap(x,y);
	ans=min(ans,ask3(1,rk[y]+1,rk[x]));
	return ans;
}
void change(int x,int y){
	int fx=top[x],fy=top[y];
	while (fx!=fy){
		if (sd[fx]<sd[fy]){
			swap(fx,fy);
			swap(x,y);
		}
		insert2(1,rk[fx],rk[x]);
		x=fa[fx];fx=top[x];
	}
	if (x==y)return;
	if (sd[x]<sd[y])swap(x,y);
	insert2(1,rk[y]+1,rk[x]);
}
signed main(){
	scanf("%d",&n);
	for (int i=1;i<n;i++){
		scanf("%d%d%d",&u[i],&v[i],&z);
		u[i]++;v[i]++;
		jb(u[i],v[i],z);jb(v[i],u[i],z);
	}
	tot=0;
	dfs1(1,0,0);
	dfs2(1,1);
	scanf("%d",&m);
	build(1,1,n);
	while (m--){
		scanf("%s",opt);
		if (opt[0]=='S'){
			scanf("%d%d",&x,&y);
			x++;y++;
			printf("%d\n",find1(x,y));
		}
		else if (opt[0]=='C'){
			scanf("%d%d",&x,&y);
			if (fa[u[x]]==v[x])insert1(1,rk[u[x]],y);
			else insert1(1,rk[v[x]],y);
		}
		else if (opt[0]=='N'){
			scanf("%d%d",&x,&y);
			x++;y++;
			change(x,y);
		}
		else if (opt[1]=='A'){
			scanf("%d%d",&x,&y);
			x++;y++;
			printf("%d\n",find2(x,y));
		}
		else if (opt[1]=='I'){
			scanf("%d%d",&x,&y);
			x++;y++;
			printf("%d\n",find3(x,y));
		}
	}
	return 0;
}
```

---

## 作者：傅思维666 (赞：4)

## 题解：

巨细节的一道题。

关于之前的题解（截止至2020.10.21之前）为什么错了，请见这个讨论：

[关于题解错误的一些看法](https://www.luogu.com.cn/discuss/show/268369)

感谢管理员的关注和处理。

很明显的树剖题。

树剖不会的走这边：

[浅谈树链剖分](https://www.cnblogs.com/fusiwei/p/11519470.html)

首先要边转点，边转点的规则是把边权转到儿子节点上。这样在链修改的时候，要刨除LCA的点权。很好理解。

然后是取相反数的操作。维护一个lazy标记，在打标记的时候容易发现的性质是：对于线段树上的当前节点，新和就是和取反，新最大值是原最小值取反，新最小值是原最大值取反。

那么这道题的思维部分就完事了，无脑开码即可。

注意几个蒟蒻曾经错过的细节：

首先，刨除LCA点权时，要判断x,y是否在一个点上，这时不需要刨，直接返回就行。

之后，lazy标记有没有重复标记。这是指，对于一个点，打两次lazy标记等于没打标记。这个可以通过异或运算来维护。

可以选择使用结构体存线段树，码量会少很多。当然也可以像蒟蒻，写很多函数来维护三个不同值，效果是一样的。

附上5K代码：

```cpp
#include<cstdio>
#include<algorithm>
#define lson pos<<1
#define rson pos<<1|1
using namespace std;
const int maxn=2*1e5+10;
const int INF=1e9;
int n,m;
int tot,head[maxn],to[maxn<<1],nxt[maxn<<1],val[maxn<<1];
int cnt,son[maxn],top[maxn],id[maxn],deep[maxn],fa[maxn],size[maxn],a[maxn],w[maxn];
char opt[10];
int sum[maxn<<2],mx[maxn<<2],mn[maxn<<2];
int lazy[maxn<<2];
struct edge
{
	int x,y;
}idx[maxn];
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<48||ch>57)
		if(ch=='-')
			f=-1,ch=getchar();
	while(ch>=48&&ch<=57)
		x=x*10+ch-48,ch=getchar();
	return x*f;
}
void add(int x,int y,int z)
{
	to[++tot]=y;
	nxt[tot]=head[x];
	val[tot]=z;
	head[x]=tot;
}
void dfs1(int x,int f)
{
	deep[x]=deep[f]+1;
	fa[x]=f;
	size[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		if(y==f)
			continue;
		dfs1(y,x);
		a[y]=val[i];
		size[x]+=size[y];
		if(!son[x]||size[y]>size[son[x]])
			son[x]=y;
	}
}
void dfs2(int x,int t)
{
	top[x]=t;
	id[x]=++cnt;
	w[cnt]=a[x];
	if(!son[x])
		return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		if(y==fa[x]||y==son[x])
			continue;
		dfs2(y,y);
	}
}
void pushup(int pos)
{
	sum[pos]=sum[lson]+sum[rson];
	mx[pos]=max(mx[lson],mx[rson]);
	mn[pos]=min(mn[lson],mn[rson]);
}
void build(int pos,int l,int r)
{
	int mid=(l+r)>>1;
	if(l==r)
	{
		sum[pos]=mx[pos]=mn[pos]=w[l];
		return;
	}
	build(lson,l,mid);
	build(rson,mid+1,r);
	pushup(pos);
}
void mark(int pos,int l,int r)
{
	lazy[pos]^=1;
	int tmp1=-sum[pos],tmp2=-mn[pos],tmp3=-mx[pos];
	sum[pos]=tmp1;
	mx[pos]=tmp2;
	mn[pos]=tmp3;
}
void pushdown(int pos,int l,int r)
{
	int mid=(l+r)>>1;
	if(lazy[pos])
	{
		mark(lson,l,mid);
		mark(rson,mid+1,r);
		lazy[pos]=0;
	}
}
void update(int pos,int l,int r,int x,int k)
{
	int mid=(l+r)>>1;
	if(l==r)
	{
		sum[pos]=mx[pos]=mn[pos]=k;
		return;
	}
	pushdown(pos,l,r);
	if(x<=mid)
		update(lson,l,mid,x,k);
	else
		update(rson,mid+1,r,x,k);
	pushup(pos);
}
void change(int pos,int l,int r,int x,int y)
{
	int mid=(l+r)>>1;
	if(x<=l && r<=y)
	{
		mark(pos,l,r);
		return;
	}
	pushdown(pos,l,r);
	if(x<=mid)
		change(lson,l,mid,x,y);
	if(y>mid)
		change(rson,mid+1,r,x,y);
	pushup(pos);
}
int query_sum(int pos,int l,int r,int x,int y)
{
	int ret=0;
	int mid=(l+r)>>1;
	if(x<=l && r<=y)
		return sum[pos];
	pushdown(pos,l,r);
	if(x<=mid)
		ret+=query_sum(lson,l,mid,x,y);
	if(y>mid)
		ret+=query_sum(rson,mid+1,r,x,y);
	return ret;
}
int query_max(int pos,int l,int r,int x,int y)
{
	int ret=-INF;
	int mid=(l+r)>>1;
	if(x<=l && r<=y)
		return mx[pos];
	pushdown(pos,l,r);
	if(x<=mid)
		ret=max(ret,query_max(lson,l,mid,x,y));
	if(y>mid)
		ret=max(ret,query_max(rson,mid+1,r,x,y));
	return ret;
}
int query_min(int pos,int l,int r,int x,int y)
{
	int ret=INF;
	int mid=(l+r)>>1;
	if(x<=l && r<=y)
		return mn[pos];
	pushdown(pos,l,r);
	if(x<=mid)
		ret=min(ret,query_min(lson,l,mid,x,y));
	if(y>mid)
		ret=min(ret,query_min(rson,mid+1,r,x,y));
	return ret;
}
void chain_upd(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		change(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	if(x!=y)
		change(1,1,n,id[y]+1,id[x]);
}
int q_sum(int x,int y)
{
	int ret=0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		ret+=query_sum(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	if(x!=y)
		ret+=query_sum(1,1,n,id[y]+1,id[x]);
	return ret;
}
int q_max(int x,int y)
{
	int ret=-INF;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		ret=max(ret,query_max(1,1,n,id[top[x]],id[x]));
		x=fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	if(x!=y)
		ret=max(ret,query_max(1,1,n,id[y]+1,id[x]));
	return ret;
}
int q_min(int x,int y)
{
	int ret=INF;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		ret=min(ret,query_min(1,1,n,id[top[x]],id[x]));
		x=fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	if(x!=y)
		ret=min(ret,query_min(1,1,n,id[y]+1,id[x]));
	return ret;
}
int main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		x=read();y=read();z=read();
		x++,y++;
		idx[i].x=x;
		idx[i].y=y;
		add(x,y,z);
		add(y,x,z);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	m=read();
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%s%d%d",opt+1,&a,&b);
		if(opt[1]=='C')
		{
			int goal=deep[idx[a].x]>deep[idx[a].y]?idx[a].x:idx[a].y;
			update(1,1,n,id[goal],b);
		}
		else if(opt[1]=='N')
		{
			a++,b++;
			chain_upd(a,b);
		}
		else if(opt[1]=='S')
		{
			a++,b++;
			printf("%d\n",q_sum(a,b));
		}
		else if(opt[1]=='M'&&opt[2]=='A')
		{
			a++,b++;
			printf("%d\n",q_max(a,b));
		}
		else if(opt[1]=='M'&&opt[2]=='I')
		{
			a++,b++;
			printf("%d\n",q_min(a,b));
		}
	}
	return 0;
}
```


---

## 作者：Priori_Incantatem (赞：3)

此题的关键，在于维护区间取反的懒标记，以及取反后区间最大值，最小值与和的变化  
首先，我们肯定先要把边权转化为点权。这个相信大家都会，每个点权等于他返祖边的权值

设 $maxv[k],minv[k],sum[k]$ 分别为区间 $k$ 的最大值，最小值与和；$rev[k]=0/1$ 表示该区间是否取反。  
取反后 $maxv[k],minv[k],sum[k]$ 的变化：

- $sum[k]$ 最简单的一个，直接乘以 $-1$ 即可  
- $minv[k]$ 等于取反前的 $maxv[k] \times -1$，可以根据不等式的运算法则得到
- $maxv[k]$ 等于取反前的 $minv[k] \times -1$ ，与上同理

这个地方明白后，剩下的就是树剖的板子了

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;
const int Maxn=100000+10,Maxm=400000+10,inf=0x3f3f3f3f;
struct edge{
	int v,len;
	edge(int x,int y)
	{
		v=x,len=y;
	}
};
struct Edge{
	int u,v;
}g[Maxn];
int maxv[Maxm],minv[Maxm],sum[Maxm];
bool rev[Maxn];
int a[Maxn],w[Maxn];
int d[Maxn],top[Maxn],id[Maxn];
int s[Maxn],son[Maxn],f[Maxn];
vector <edge> e[Maxn];
int n,m,idcnt;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
inline void push_up(int k)
{
	maxv[k]=max(maxv[k<<1],maxv[k<<1|1]);
	minv[k]=min(minv[k<<1],minv[k<<1|1]);
	sum[k]=sum[k<<1]+sum[k<<1|1];
}
void upd(int k)
{
	rev[k]^=1;
	sum[k]=-sum[k];
	int tmp=minv[k];
	minv[k]=-maxv[k];
	maxv[k]=-tmp;
}
void push_down(int k)
{
	if(!rev[k])return;
	upd(k<<1),upd(k<<1|1);
	rev[k]=0;
}
void modify_pos(int k,int l,int r,int pos,int v)
{
	if(l==r)
	{
		rev[k]=0;
		maxv[k]=minv[k]=sum[k]=v;
		return;
	}
	push_down(k);
	int mid=(l+r)>>1;
	if(pos<=mid)modify_pos(k<<1,l,mid,pos,v);
	else modify_pos(k<<1|1,mid+1,r,pos,v);
	push_up(k);
}
void modify_rev(int k,int l,int r,int x,int y)
{
	if(x<=l && r<=y)return upd(k);
	push_down(k);
	int mid=(l+r)>>1;
	if(x<=mid)modify_rev(k<<1,l,mid,x,y);
	if(mid<y)modify_rev(k<<1|1,mid+1,r,x,y);
	push_up(k);
}
int query_sum(int k,int l,int r,int x,int y)
{
	if(x<=l && r<=y)return sum[k];
	push_down(k);
	int mid=(l+r)>>1,ret=0;
	if(x<=mid)ret=query_sum(k<<1,l,mid,x,y);
	if(mid<y)ret+=query_sum(k<<1|1,mid+1,r,x,y);
	return ret;
}
int query_min(int k,int l,int r,int x,int y)
{
	if(x<=l && r<=y)return minv[k];
	push_down(k);
	int mid=(l+r)>>1,ret=inf;
	if(x<=mid)ret=query_min(k<<1,l,mid,x,y);
	if(mid<y)ret=min(ret,query_min(k<<1|1,mid+1,r,x,y));
	return ret;
}
int query_max(int k,int l,int r,int x,int y)
{
	if(x<=l && r<=y)return maxv[k];
	push_down(k);
	int mid=(l+r)>>1,ret=-inf;
	if(x<=mid)ret=query_max(k<<1,l,mid,x,y);
	if(mid<y)ret=max(ret,query_max(k<<1|1,mid+1,r,x,y));
	return ret;
}
void build(int k,int l,int r)
{
	if(l==r)
	{
		sum[k]=minv[k]=maxv[k]=w[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	push_up(k);
}
void dfs1(int x,int fa,int len)
{
	s[x]=1,f[x]=fa;
	d[x]=d[fa]+1,a[x]=len;
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i].v;
		if(y==fa)continue;
		dfs1(y,x,e[x][i].len);
		s[x]+=s[y];
		if(s[y]>s[son[x]])son[x]=y;
	}
}
void dfs2(int x,int topp)
{
	top[x]=topp,id[x]=++idcnt;
	w[id[x]]=a[x];
	if(!son[x])return;
	dfs2(son[x],topp);
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i].v;
		if(y==f[x] || y==son[x])continue;
		dfs2(y,y);
	}
}
void seq_rev(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		modify_rev(1,1,n,id[top[x]],id[x]);
		x=f[top[x]];
	}
	if(x==y)return;
	if(d[x]>d[y])swap(x,y);
	modify_rev(1,1,n,id[x]+1,id[y]);
}
int seq_sum(int x,int y) 
{
	int ret=0;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		ret+=query_sum(1,1,n,id[top[x]],id[x]);
		x=f[top[x]];
	}
	if(x==y)return ret;
	if(d[x]>d[y])swap(x,y);
	return ret+query_sum(1,1,n,id[x]+1,id[y]);
}
int seq_max(int x,int y) 
{
	int ret=-inf;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		ret=max(ret,query_max(1,1,n,id[top[x]],id[x]));
		x=f[top[x]];
	}
	if(x==y)return ret;
	if(d[x]>d[y])swap(x,y);
	return max(ret,query_max(1,1,n,id[x]+1,id[y]));
}
int seq_min(int x,int y) 
{
	int ret=inf;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		ret=min(ret,query_min(1,1,n,id[top[x]],id[x]));
		x=f[top[x]];
	}
	if(x==y)return ret;
	if(d[x]>d[y])swap(x,y);
	return min(ret,query_min(1,1,n,id[x]+1,id[y]));
}
int main()
{
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	
	n=read();
	for(int i=1;i<n;++i)
	{
		int x=read()+1,y=read()+1,c=read();
		g[i].u=x,g[i].v=y;
		e[x].push_back(edge(y,c));
		e[y].push_back(edge(x,c));
	}
	dfs1(1,0,0);
	dfs2(1,1);
	build(1,1,n);
	m=read();
	for(int i=1;i<=m;++i)
	{
		char opt[10];
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			int i=read(),v=read();
			if(d[g[i].u]<d[g[i].v])swap(g[i].v,g[i].u);
			modify_pos(1,1,n,id[g[i].u],v);
			continue;
		}
		int x=read()+1,y=read()+1;
		if(opt[0]=='N')seq_rev(x,y);
		else if(opt[0]=='S')printf("%d\n",seq_sum(x,y));
		else if(opt[0]='M' && opt[1]=='A')printf("%d\n",seq_max(x,y));
		else if(opt[0]='M' && opt[1]=='I')printf("%d\n",seq_min(x,y));
	}
	
	return 0;
}
```

---

## 作者：STrAduts (赞：2)

呀树上数据结构肯定是直接树剖a！

考虑这些操作如何在序列上做。

采用线段树维护三个值：

- 区间 $[l, r]$ 的权值最大值。
- 区间 $[l, r]$ 的权值最小值。
- 区间 $[l, r]$ 的权值和。

以及一个懒标记，表示线段树中当前结点子树是否被取反过。

于是就是线段树区间问题板子了。

扩展懒标记：

```cpp
void Spread(int p) {
	if(tr[p].lazy) {
		tr[lson].ma = -tr[lson].ma;
		tr[lson].mi = -tr[lson].mi;
		Swap(tr[lson].ma, tr[lson].mi);
		tr[lson].sum = -tr[lson].sum;
		tr[lson].lazy ^= 1;			
		
		tr[rson].ma = -tr[rson].ma;
		tr[rson].mi = -tr[rson].mi;
		Swap(tr[rson].ma, tr[rson].mi);
		tr[rson].sum = -tr[rson].sum;
		tr[rson].lazy ^= 1;	
		
		tr[p].lazy = false;			
	}
}
```

转移：

```cpp	
void Push_Up(int p) {
	tr[p].ma = Max(tr[lson].ma, tr[rson].ma);
	tr[p].mi = Min(tr[lson].mi, tr[rson].mi);
	tr[p].sum = tr[lson].sum + tr[rson].sum;
}
```

最后套上重链剖分即可。

```cpp
#include <cstdio>
#include <vector>
#include <string>
#include <iostream>
#define lson p << 1
#define rson p << 1 | 1 
using namespace std;

int read() {
    int k = 1, x = 0;
    char s = getchar();
    while (s < '0' || s > '9') {
        if (s == '-')
            k = -1;
        s = getchar();
    }
    while (s >= '0' && s <= '9') {
        x = (x << 3) + (x << 1) + s - '0';
        s = getchar();
    }
    return x * k;
}

void write(int x) {
    if(x < 0) {
    	putchar('-');
		x = -x;
    }
    if(x > 9)
		write(x / 10);
    putchar(x % 10 + '0');
}

void print(int x, char s) {
	write(x);
	putchar(s);
}

void Swap(int &x, int &y) {int t = x; x = y; y = t;}
int Max(int x, int y) {return x > y ? x : y;}
int Min(int x, int y) {return x < y ? x : y;}

const int MAXN = 1e5 + 5;

struct edge {
	int v, w;
	edge() {}
	edge(int V, int W) {
		v = V;
		w = W; 
	}
};
vector<edge> mp[MAXN];

void Add_Edge(int u, int v, int w) {
	mp[u].push_back(edge(v, w));
	mp[v].push_back(edge(u, w));
}

int tot = 0;

struct node {
	int size, dep, top, dfn, son, fa;
	node() {}
	node(int Size, int Dep, int Top, int Dfn, int Son, int Fa) {
		size = Size;
		dep = Dep;
		top = Top;
		dfn = Dfn;
		son = Son;
		fa = Fa;
	}
} q[MAXN];

struct data {
	int u, v, w;
	data() {}
	data(int U, int V, int W) {
		u = U;
		v = V;
		w = W;
	}
} e[MAXN];

void dfs(int u, int fa) {
	int ma = 0;
	q[u].size++;
	for(int i = 0; i < mp[u].size(); i++) {
		int v = mp[u][i].v;
		if(v == fa)
			continue;
		q[v].fa = u;
		q[v].dep = q[u].dep + 1;
		dfs(v, u);
		q[u].size += q[v].size;
		if(q[v].size > ma) {
			ma = q[v].size;
			q[u].son = v;
		}
	}
}

void dfs2(int u, int fa, int t) {
	q[u].top = t;
	q[u].dfn = ++tot;
	if(!q[u].son)
		return ;
	dfs2(q[u].son, u, t);
	for(int i = 0; i < mp[u].size(); i++) {
		int v = mp[u][i].v;
		if(v == fa || v == q[u].son) 
			continue;
		dfs2(v, u, v);
	}
}

struct Segment_Tree {
	int l, r, mi, ma, sum;
	bool lazy;
	Segment_Tree() {}
	Segment_Tree(int L, int R, int Mi, int Ma, bool Lazy, int Sum) {
		l = L;
		r = R;
		mi = Mi;
		ma = Ma;
		lazy = Lazy;
		sum = Sum;
	}
} tr[MAXN * 4];

void Make_Tree(int p, int l, int r) {
	tr[p].l = l;
	tr[p].r = r;
	if(l == r) 
		return ;		
	int mid = (l + r) >> 1;
	Make_Tree(lson, l, mid);
	Make_Tree(rson, mid + 1, r);
}

void Push_Up(int p) {
	tr[p].ma = Max(tr[lson].ma, tr[rson].ma);
	tr[p].mi = Min(tr[lson].mi, tr[rson].mi);
	tr[p].sum = tr[lson].sum + tr[rson].sum;
}

void Spread(int p) {
	if(tr[p].lazy) {
		tr[lson].ma = -tr[lson].ma;
		tr[lson].mi = -tr[lson].mi;
		Swap(tr[lson].ma, tr[lson].mi);
		tr[lson].sum = -tr[lson].sum;
		tr[lson].lazy ^= 1;			
		
		tr[rson].ma = -tr[rson].ma;
		tr[rson].mi = -tr[rson].mi;
		Swap(tr[rson].ma, tr[rson].mi);
		tr[rson].sum = -tr[rson].sum;
		tr[rson].lazy ^= 1;	
		
		tr[p].lazy = false;			
	}
}

void Tr_Update(int p, int k, int x) {
	if(tr[p].l == tr[p].r) {
		tr[p].ma = x;
		tr[p].mi = x;
		tr[p].sum = x;
		return ;
	}
	Spread(p);
	int mid = (tr[p].l + tr[p].r) >> 1;
	if(k <= mid)
		Tr_Update(lson, k, x);
	else
		Tr_Update(rson, k, x);
	Push_Up(p);
}

void Tr_Update2(int p, int l, int r) {
	if(l <= tr[p].l && tr[p].r <= r) {
		tr[p].ma = -tr[p].ma;
		tr[p].mi = -tr[p].mi;
		Swap(tr[p].ma, tr[p].mi);		
		tr[p].sum = -tr[p].sum;
		tr[p].lazy ^= 1;			
		return ;
	}
	Spread(p);
	int mid = (tr[p].l + tr[p].r) >> 1;
	if(l <= mid)
		Tr_Update2(lson, l, r);
	if(r > mid)
		Tr_Update2(rson, l, r);
	Push_Up(p);
}

int Tr_Query1(int p, int l, int r) {
	if(l <= tr[p].l && tr[p].r <= r)
		return tr[p].ma;
	Spread(p);
	int mid = (tr[p].l + tr[p].r) >> 1, val = -0x3f3f3f3f;
	if(l <= mid)
		val = Max(val, Tr_Query1(lson, l, r));
	if(r > mid)
		val = Max(val, Tr_Query1(rson, l, r));
	return val;
}

int Tr_Query2(int p, int l, int r) {
	if(l <= tr[p].l && tr[p].r <= r)
		return tr[p].mi;
	Spread(p);
	int mid = (tr[p].l + tr[p].r) >> 1, val = 0x3f3f3f3f;
	if(l <= mid)
		val = Min(val, Tr_Query2(lson, l, r));
	if(r > mid)
		val = Min(val, Tr_Query2(rson, l, r));
	return val;
}

int Tr_Query3(int p, int l, int r) {
	if(l <= tr[p].l && tr[p].r <= r)
		return tr[p].sum;
	Spread(p);
	int mid = (tr[p].l + tr[p].r) >> 1, val = 0;
	if(l <= mid)
		val += Tr_Query3(lson, l, r);
	if(r > mid)
		val += Tr_Query3(rson, l, r);
	return val;
}

void Update(int u, int v) {
	while(q[u].top != q[v].top) {
		if(q[q[u].top].dep < q[q[v].top].dep) 
			Swap(u, v);
		Tr_Update2(1, q[q[u].top].dfn, q[u].dfn);
		u = q[q[u].top].fa;
	}
	if(u == v)
		return ;
	if(q[u].dep < q[v].dep)
		Swap(u, v);
	Tr_Update2(1, q[q[v].son].dfn, q[u].dfn);
}

int Query1(int u, int v) {
	int res = -0x3f3f3f3f;
	while(q[u].top != q[v].top) {
		if(q[q[u].top].dep < q[q[v].top].dep) 
			Swap(u, v);
		res = Max(res, Tr_Query1(1, q[q[u].top].dfn, q[u].dfn));
		u = q[q[u].top].fa;
	}
	if(u == v)
		return res;
	if(q[u].dep < q[v].dep)
		Swap(u, v);
	res = Max(res, Tr_Query1(1, q[q[v].son].dfn, q[u].dfn));
	return res;
}

int Query2(int u, int v) {
	int res = 0x3f3f3f3f;
	while(q[u].top != q[v].top) {
		if(q[q[u].top].dep < q[q[v].top].dep) 
			Swap(u, v);
		res = Min(res, Tr_Query2(1, q[q[u].top].dfn, q[u].dfn));
		u = q[q[u].top].fa;
	}
	if(u == v)
		return res;
	if(q[u].dep < q[v].dep)
		Swap(u, v);
	res = Min(res, Tr_Query2(1, q[q[v].son].dfn, q[u].dfn));
	return res;
}

int Query3(int u, int v) {
	int res = 0;
	while(q[u].top != q[v].top) {
		if(q[q[u].top].dep < q[q[v].top].dep) 
			Swap(u, v);
		res += Tr_Query3(1, q[q[u].top].dfn, q[u].dfn);
		u = q[q[u].top].fa;
	}
	if(u == v)
		return res;
	if(q[u].dep < q[v].dep)
		Swap(u, v);
	res += Tr_Query3(1, q[q[v].son].dfn, q[u].dfn);
	return res;
}

int main() {
	int n = read();
	for(int i = 1; i < n; i++) {
		int u = read(), v = read(), w = read();
		Add_Edge(u, v, w);
		e[i] = data(u, v, w);
	}
	q[0].dep = 1;
	dfs(0, -1);
	tot = 0;
	dfs2(0, -1, 0);
	Make_Tree(1, 0, n);
	for(int i = 1; i < n; i++) {
		if(q[e[i].u].dep < q[e[i].v].dep)
			Swap(e[i].u, e[i].v);
		Tr_Update(1, q[e[i].u].dfn, e[i].w);
	}
	int m = read();
	for(int i = 1; i <= m; i++) {
		string st;
		cin >> st;
		if(st == "C") {	
			int k = read(), x = read();
			Tr_Update(1, q[e[k].u].dfn, x);
		}
		else if(st == "N") {
			int l = read(), r = read();
			Update(l, r);
		}
		else if(st == "MAX") {
			int l = read(), r = read();
			print(Query1(l, r), '\n');
		}	
		else if(st == "MIN") {
			int l = read(), r = read();
			print(Query2(l, r), '\n');
		}		
		else {
			int l = read(), r = read();
			print(Query3(l, r), '\n');
		}			
	} 
	return 0;	
}
```

---

## 作者：Night_Bringer (赞：1)

[博客园食用更佳](https://www.cnblogs.com/C202202chenkelin/p/14492813.html)
# 前置知识
线段树 $and$ 树上基本操作
# 定义
几个在树链剖分很重要的概念。
## 重儿子
对于一个父节点，含有节点数最多的儿子称为重儿子。但重儿子只有一个，若满足条件的儿子有多个，则指定其中任意一个儿子为重儿子。
## 轻儿子
对于一个父节点，除了重儿子以为，其余的都称为轻儿子。
## 重边
由父节点与重儿子构成的边。
## 轻边
由父节点与轻儿子构成的边。
## 重链
由重边构成的链。
# 轻链
由轻边构成的链。
# 链顶
重链中深度最小的边为该重链的链顶。

上述几个概念具体如下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210306214410204.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhY2VfdGhlX0JsYXN0,size_16,color_FFFFFF,t_70)
其中，黄色点为重儿子，蓝色点为轻儿子（ $1$ 除外）。黄色边为重边，蓝色边为轻边。通常，一个单独的点也看为一条重链，那么重链有 $5$ 条： 
* $\{ 1,2,6,7\}$ ，（ $1$ 为链顶）
* $\{ 5\}$ ，（ $5$ 为链顶）
* $\{ 3\}$ ，（ $3$ 为链顶）
* $\{ 4,8\}$ ，（ $4$ 为链顶）
* $\{ 9\}$ ，（ $9$ 为链顶）

对于任意一棵树有如下性质：从任意一点到根节点的简单路径上，共有不超过 $log2(n)$  条轻链，有不超过 $log2(n)$ 条轻链。
# 预处理
预处理需要使用到两个 $dfs$ 。

$dfs1$ 需要处理：
* $fa[i]$ ： $i$ 节点的父亲。
* $son[i]$ ： $i$ 节点的重儿子。
* $sz[i]$ ：以 $i$ 为根节点的子树的大小，可以进一步处理 $son[i]$ 。
* $dep[i]$ ： $i$ 节点的深度。

$dfs2$ 需要处理：
* $dfn[i]$ ： $i$ 节点的时间戳，但优先遍历重儿子。显然，在一条重链中，时间戳为一段连续的数字。
* $tp[i]$ ： $i$ 节点的链顶。
## C++代码
```cpp
void dfs1(int now, int father) {
	fa[now] = father;//初始化父节点
	sz[now] = 1;//子树大小包括自己
	dep[now] = dep[father] + 1;//初始化深度
	int SIZ = v[now].size();
	int maxn = 0;//记录最大的子树大小
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(next == father)
			continue;
		dfs1(next, now);//遍历这棵树
		sz[now] += sz[next];
		if(maxn < sz[next]) {//更新子节点
			maxn = sz[next];
			son[now] = next;
		}
	}
}
void dfs2(int now, int Top) {
	tp[now] = Top;//初始化链顶
	if(son[now])
		dfs2(son[now], Top);//优先遍历重儿子
	int SIZ = v[now].size();
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(next == fa[now] || next == son[now])
			continue;
		dfs2(next, next);//继续遍历这棵树
	}
}
```
# 树链剖分求LCA
[测验链接。](https://www.luogu.com.cn/problem/P3379)

在线查询一棵树上任意两点的 $LCA$ 。

分两种情况向上爬即可（需要保证 $dep[tp[x]] <= dep[tp[y]]$）：
1. $tp[x]!=tp[y]$ ，即不在一条重链上。需要 $x$ 向上爬出这条重链，向上继续寻找能与 $y$ 汇合的重链点。$x=fa[tp[x]]$。
2. $tp[x]!=tp[y]$  ，即在一条重链上，那么深度小的就位最近公共祖先。

正确性显然，以为两条重链不会交于同一个点。
## C++代码
```cpp
#include <cstdio>
#include <vector>
using namespace std;
const int MAXN = 5e5 + 5;
vector<int> v[MAXN];//vector存图
int fa[MAXN], son[MAXN], tp[MAXN], sz[MAXN], dep[MAXN];
int n, m, s;
void dfs1(int now, int father) {//初始化如上
	fa[now] = father;
	sz[now] = 1;
	dep[now] = dep[father] + 1;
	int SIZ = v[now].size();
	int maxn = 0;
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(next == father)
			continue;
		dfs1(next, now);
		sz[now] += sz[next];
		if(maxn < sz[next]) {
			maxn = sz[next];
			son[now] = next;
		}
	}
}
void dfs2(int now, int Top) {//初始化如上
	tp[now] = Top;
	if(son[now])
		dfs2(son[now], Top);
	int SIZ = v[now].size();
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(next == fa[now] || next == son[now])
			continue;
		dfs2(next, next);
	}
}
int Get_LCA(int x, int y) {
	while(tp[x] != tp[y]) {
		if(dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		x = fa[tp[x]];
	}
	if(x == y)
		return x;
	if(dep[x] < dep[y])
		return x;
	return y; 
}
int main() {
	int A, B;
	scanf("%d %d %d", &n, &m, &s);
	for(int i = 1; i < n; i++) {
		scanf("%d %d", &A, &B);
		v[A].push_back(B);
		v[B].push_back(A);
	}
	dfs1(s, 0);
	dfs2(s, s);
	for(int i = 1; i <= m; i++) {
		scanf("%d %d", &A, &B);
		printf("%d\n", Get_LCA(A, B));
	}
	return 0;
}
```
# 例题
树链剖分通常结合着一些数据结构来进行操作，以为重链的 $dfn$ 为连续的序列。

[题目链接。](https://www.luogu.com.cn/problem/P1505)
## 题目大意
对于一棵树，有 $5$ 中操作，根据要求完成操作。
* C i w 将输入的第 $i$ 条边权值改为 $w$ 。
* N u v 将 $u,v$ 节点之间的边权都变为相反数。
* SUM u v 询问 $u,v$ 节点之间边权和。
* MAX u v 询问 $u,v$ 节点之间边权最大值。
* MIN u v 询问 $u,v$ 节点之间边权最小值。
## 思路
先考虑第二个操作。

设 $lca$ 为 $u,v$ 的最近公共祖先，那么可以将操作二分解为从 $u$ 到 $lca$ 的路径取反，和将从 $v$ 到 $lca$ 的路径取反。

那么按照上述 $LCA$ 往上爬的过程刚好就可以遍历完这条路径一次。

按照点的 $dfn$ 建造一颗线段树，来维护点的信息。

这里点的信息是指：这个点与它的父节点的连边的信息。

线段树需要维护的信息有：最大值，最小值，区间和。

具体的操作二代码如下：
```cpp
void Negate(int pos, int l, int r) {
	if(l <= L(pos) && R(pos) <= r) {
		A(pos) = -A(pos);
		I(pos) = -I(pos);
		swap(A(pos), I(pos));//最大值取反，最小值取反，最大值边最小值
		S(pos) = -S(pos);//区间和取反
		M(pos) ^= 1;//取反两次后就相当于不取反。
		return;
	}
	Push_Down(pos);//传递懒标记
	if(l <= R(LC(pos)))
		Negate(LC(pos), l, r);
	if(r >= L(RC(pos)))
		Negate(RC(pos), l, r);
	Push_Up(pos);//修改后更新点的信息
}
void Negatepast(int x, int y) {
	while(tp[x] != tp[y]) {//不同重链向上爬
		if(dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		Negate(1, dfn[tp[x]], dfn[x]);//同一条重链dfn是连续的，线段树维护
		x = fa[tp[x]];//向上爬
	}
	if(x == y)
		return;
	if(dep[x] < dep[y])
		swap(x, y);
	Negate(1, dfn[son[y]], dfn[x]);//注意是son[y]，y与其父节点的连边并不需要修改
}
```
查询操作与其类似，就不一一列举了。

对于修改权值，使用深度较大的子节点，直接在线段树上该就好了。
## C++代码
```cpp
#include <cstdio>
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;
#define INF 0x3f3f3f3f
const int MAXN = 2e5 + 5;
struct Segment_Tree {//线段树
	int Left_Section, Right_Section;
	int Max_Data, Min_Data, Sum_Data, Lazy_Mark;
	#define LC(x) (x << 1)
	#define RC(x) (x << 1 | 1)
	#define L(x) Tree[x].Left_Section//左区间
	#define R(x) Tree[x].Right_Section//右区间
	#define I(x) Tree[x].Min_Data//区间最小值
	#define A(x) Tree[x].Max_Data//区间最大值
	#define S(x) Tree[x].Sum_Data//区间和
	#define M(x) Tree[x].Lazy_Mark//懒惰标记（延迟标记）
};
Segment_Tree Tree[MAXN << 2];
vector<int> v[MAXN];//vector存图
int fa[MAXN], son[MAXN], dep[MAXN], siz[MAXN];
int tp[MAXN], dfn[MAXN];
int s[MAXN], t[MAXN], w[MAXN];
int n, q;
int tim;
void Push_Up(int pos) {//更新节点信息
	A(pos) = max(A(LC(pos)), A(RC(pos)));
	I(pos) = min(I(LC(pos)), I(RC(pos)));
	S(pos) = S(LC(pos)) + S(RC(pos));
}
void Push_Down(int pos) {//传递懒标记
	if(M(pos)) {
		I(LC(pos)) = -I(LC(pos));
		A(LC(pos)) = -A(LC(pos));
		swap(I(LC(pos)), A(LC(pos)));
		S(LC(pos)) = -S(LC(pos));
		M(LC(pos)) ^= 1;
		I(RC(pos)) = -I(RC(pos));
		A(RC(pos)) = -A(RC(pos));
		swap(I(RC(pos)), A(RC(pos)));
		S(RC(pos)) = -S(RC(pos));
		M(RC(pos)) ^= 1;
		M(pos) = 0;
	}
}
void Build(int pos, int l, int r) {//初始化建树
	L(pos) = l;
	R(pos) = r;
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	Build(LC(pos), l, mid);
	Build(RC(pos), mid + 1, r); 
}
void Negate(int pos, int l, int r) {//取反操作
	if(l <= L(pos) && R(pos) <= r) {
		I(pos) = -I(pos);
		A(pos) = -A(pos);
		swap(I(pos), A(pos));
		S(pos) = -S(pos);
		M(pos) ^= 1;
		return;
	}
	Push_Down(pos);
	if(l <= R(LC(pos)))
		Negate(LC(pos), l, r);
	if(r >= L(RC(pos)))
		Negate(RC(pos), l, r);
	Push_Up(pos);
}
void Negatepast(int x, int y) {
	while(tp[x] != tp[y]) {
		if(dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		Negate(1, dfn[tp[x]], dfn[x]);
		x = fa[tp[x]];
	}
	if(x == y)
		return;
	if(dep[x] < dep[y])
		swap(x, y);
	Negate(1, dfn[son[y]], dfn[x]);
}
void Change(int pos, int x, int c) {//单点修改
	if(L(pos) == R(pos)) {
		I(pos) = c;
		A(pos) = c;
		S(pos) = c;
		return;
	}
	Push_Down(pos);
	if(x <= R(LC(pos)))
		Change(LC(pos), x, c);
	else
		Change(RC(pos), x, c);
	Push_Up(pos);
}
int Query_Sum(int pos, int l, int r) {//查询最大值操作，与修改类似，都已同样方向爬
	if(l <= L(pos) && R(pos) <= r)
		return S(pos);
	Push_Down(pos);
	int res = 0;
	if(l <= R(LC(pos)))
		res += Query_Sum(LC(pos), l, r);
	if(r >= L(RC(pos)))
		res += Query_Sum(RC(pos), l, r);
	return res;
}
int Sumpast(int x, int y) {
	int res = 0;
	while(tp[x] != tp[y]) {
		if(dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		res += Query_Sum(1, dfn[tp[x]], dfn[x]);
		x = fa[tp[x]];
	}
	if(x == y)
		return res;
	if(dep[x] < dep[y])
		swap(x, y);
	res += Query_Sum(1, dfn[son[y]], dfn[x]);
	return res;
}
int Query_Min(int pos, int l, int r) {//查询最小值
	if(l <= L(pos) && R(pos) <= r)
		return I(pos);
	Push_Down(pos);
	int res = INF;
	if(l <= R(LC(pos)))
		res = min(res, Query_Min(LC(pos), l, r));
	if(r >= L(RC(pos)))
		res = min(res, Query_Min(RC(pos), l, r));
	return res;
}
int Minpast(int x, int y) {
	int res = INF;
	while(tp[x] != tp[y]) {
		if(dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		res = min(res, Query_Min(1, dfn[tp[x]], dfn[x]));
		x = fa[tp[x]];
	}
	if(x == y)
		return res;
	if(dep[x] < dep[y])
		swap(x, y);
	res = min(res, Query_Min(1, dfn[son[y]], dfn[x]));
	return res;
}
int Query_Max(int pos, int l, int r) {//查询最大值
	if(l <= L(pos) && R(pos) <= r)
		return A(pos);
	Push_Down(pos);
	int res = -INF;
	if(l <= R(LC(pos)))
		res = max(res, Query_Max(LC(pos), l, r));
	if(r >= L(RC(pos)))
		res = max(res, Query_Max(RC(pos), l, r));
	return res;
}
int Maxpast(int x, int y) {
	int res = -INF;
	while(tp[x] != tp[y]) {
		if(dep[tp[x]] < dep[tp[y]])
			swap(x, y);
		res = max(res, Query_Max(1, dfn[tp[x]], dfn[x]));
		x = fa[tp[x]];
	}
	if(x == y)
		return res;
	if(dep[x] < dep[y])
		swap(x, y);
	res = max(res, Query_Max(1, dfn[son[y]], dfn[x]));
	return res;
}
void dfs1(int now, int father) {//初始化
	dep[now] = dep[father] + 1;
	siz[now] = 1;
	fa[now] = father;
	int SIZ = v[now].size();
	int maxn = 0;
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(next == fa[now])
			continue;
		dfs1(next, now);
		siz[now] += siz[next];
		if(maxn < siz[next]) {
			maxn = siz[next];
			son[now] = next;
		}
	}
}
void dfs2(int now, int Top) {//初始化
	tp[now] = Top;
	dfn[now] = ++tim;
	if(son[now])
		dfs2(son[now], Top);
	int SIZ = v[now].size();
	for(int i = 0; i < SIZ; i++) {
		int next = v[now][i];
		if(son[now] == next || fa[now] == next)
			continue;
		dfs2(next, next);
	}
}
int main() {
	scanf("%d", &n);
	for(int i = 1; i < n; i++) {
		scanf("%d %d %d", &s[i], &t[i], &w[i]);
		s[i]++;
		t[i]++;
		v[s[i]].push_back(t[i]);
		v[t[i]].push_back(s[i]);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	Build(1, 1, n);
	for(int i = 1; i < n; i++) {
		if(dep[s[i]] < dep[t[i]])//深度小的一定就是子节点
			swap(s[i], t[i]);
		Change(1, dfn[s[i]], w[i]);//初始化线段树
	}
	scanf("%d", &q);
	string opt;
	int a, b;
	while(q--) {
		cin >> opt;
		scanf("%d %d", &a, &b);
		a++;
		b++;
		if(opt[0] == 'N')
			Negatepast(a, b);
		else if(opt[0] == 'C')
			Change(1, dfn[s[a - 1]], b - 1);
		else if(opt[0] == 'S')
			printf("%d\n", Sumpast(a, b));
		else if(opt[1] == 'A')
			printf("%d\n", Maxpast(a, b));
		else
			printf("%d\n", Minpast(a, b));
	}
	return 0;
}
````

---

## 作者：water_tomato (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P1505) [个人博客版本](https://code.watertomato.com/p1505-%e5%9b%bd%e5%ae%b6%e9%9b%86%e8%ae%ad%e9%98%9f%e6%97%85%e6%b8%b8-%e9%a2%98%e8%a7%a3/)

## 题意

维护一棵树，支持区间求和，区间最大值，区间最小值，区间取反，单点修改。

## 解析

这是一道很好的树剖练手题，思维难度不高，代码存在一些细节，本题解主要来说明这一部分，也用来警醒自己做题目时需要注意细节，尽可能避免调代码调半天的情况。

### 边权转点权

在树剖的两边 dfs 过程中，第一遍可以将边权赋给边端点中深度较大的那一个，即儿子节点。我们用儿子上的点权来表示了边权。

两遍 dfs 代码如下：

```cpp
inline void dfs1(int u,int f){
	dep[u]=dep[f]+1;
	fa[u]=f;siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f) continue;
		val[v]=e[i].val;//将边权赋给儿子
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
inline void dfs2(int u,int Top){
	id[u]=++tot;
	a[tot]=val[u];//获得边权后，儿子有了点权，将其赋到数列中
	top[u]=Top;
	if(!son[u]) return;
	dfs2(son[u],Top);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
```

### 如何区间取反

在区间取反时，我们面对 $tag$ 需要 pushdown 的时候需要保证所记录的和/最大值/最小值都正确变化。

显然的，区间和直接取反即可，而最大值/最小值，容易发现他们取反之后就分别变成了新的最小值/最大值，因此取反后交换即可。

pushdown 部分代码如下：

```cpp
inline void pushdown(int u){
	if(!tree[u].tag) return;
	tree[ls].tag^=1;tree[rs].tag^=1;
	tree[ls].sum=-tree[ls].sum;tree[rs].sum=-tree[rs].sum;
	tree[ls].mx=-tree[ls].mx;tree[rs].mx=-tree[rs].mx;
	tree[ls].mn=-tree[ls].mn;tree[rs].mn=-tree[rs].mn;
	swap(tree[ls].mx,tree[ls].mn);swap(tree[rs].mx,tree[rs].mn);
	tree[u].tag=0;
}
```

切记不能直接互相赋值，除非你乐意维护一个中间量。

### 如何树上修改/查询

这里以区间求和为例。

```cpp
inline void SumTree(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans+=querysum(1,1,n,id[top[x]],id[x]);//tag 1
		x=fa[top[x]];
	}
	if(x!=y){
		if(dep[x]>dep[y]) swap(x,y);
		ans+=querysum(1,1,n,id[x]+1,id[y]);	//tag 2
	}
	printf("%lld\n",ans);
}
```

注意用注释打上标记的这两行，$id_{top_x}$ 没有加 $1$，而 $id_x$ 加 $1$，原因是：当你在树上向上跳时，由于你要跳到链顶的上一个点，因此链顶所表示的那个边权是需要计算的，而第二个 $tag$ 那一行，需要求的边是从 $x$ 至 $y$ （$y$ 较深），因此 $x$ 上方那条边，即 $x$ 代表的边权是不计算的，需要加 $1$。
### 修改输入的第 $i$ 条边

我们需要在输入时记录每一条边的的 $u,v$ 两点（如果你写链式前向星之类的话，实际上已经记录好了），然后由于我们边权赋给了边的儿子，因此我们修改时应该是找出 $u,v$ 中深度较深的那一点，修改边权转点权之后这一点的点权。

修改单条边的代码如下：

```cpp
if(ch[0]=='C'){
    scanf("%lld%lld",&x,&w);
    int tmp;
    u=e[x<<1].from,v=e[x<<1].to;//x<<1 是因为使用链式前向星，正反都建了边
    if(dep[u]>dep[v]) tmp=u;//修改深的点
    else tmp=v;
    updateTree(tmp,w);
}
```

处理好这几个问题之后，剩下的就是树剖的板子了，不再赘述。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls u<<1
#define rs u<<1|1
using namespace std;
const int N=2e5+5;
const int inf=2e9;
struct SegmentTree{
	int len,tag,sum,mx,mn;
}tree[N<<4];
struct edge{
	int from,to,nxt,val;
}e[N<<1];
int cnt,head[N],n,m,val[N];
char ch[20];
inline void add(int u,int v,int w){
	e[++cnt].to=v;
	e[cnt].from=u;
	e[cnt].nxt=head[u];
	e[cnt].val=w;
	head[u]=cnt;
}
int dep[N],fa[N],son[N],siz[N],top[N],id[N],a[N];
inline void dfs1(int u,int f){
	dep[u]=dep[f]+1;
	fa[u]=f;siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f) continue;
		val[v]=e[i].val;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
int tot;
inline void dfs2(int u,int Top){
	id[u]=++tot;
	a[tot]=val[u];
	top[u]=Top;
	if(!son[u]) return;
	dfs2(son[u],Top);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa[u]||v==son[u]) continue;
		dfs2(v,v);
	}
}
//以下为线段树
inline void pushup(int u){
	tree[u].sum=tree[ls].sum+tree[rs].sum;
	tree[u].mx=max(tree[ls].mx,tree[rs].mx);
	tree[u].mn=min(tree[ls].mn,tree[rs].mn);
}
inline void pushdown(int u){
	if(!tree[u].tag) return;
	tree[ls].tag^=1;tree[rs].tag^=1;
	tree[ls].sum=-tree[ls].sum;tree[rs].sum=-tree[rs].sum;
	tree[ls].mx=-tree[ls].mx;tree[rs].mx=-tree[rs].mx;
	tree[ls].mn=-tree[ls].mn;tree[rs].mn=-tree[rs].mn;
	swap(tree[ls].mx,tree[ls].mn);swap(tree[rs].mx,tree[rs].mn);
	tree[u].tag=0;
}
inline void build(int u,int l,int r){
	if(l==r){
		tree[u].sum=tree[u].mx=tree[u].mn=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);build(rs,mid+1,r);
	pushup(u);
}
inline void update(int u,int l,int r,int k,int w){
	if(k<l||k>r) return;
	if(l==r){
		tree[u].sum=tree[u].mx=tree[u].mn=w;
		return;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	update(ls,l,mid,k,w);update(rs,mid+1,r,k,w);
	pushup(u);
}
inline void makeop(int u,int l,int r,int L,int R){
	if(r<L||l>R) return;
	if(l>=L&&r<=R){
		tree[u].tag^=1;
		tree[u].sum=-tree[u].sum;
		tree[u].mx=-tree[u].mx;
		tree[u].mn=-tree[u].mn;
		swap(tree[u].mx,tree[u].mn);
		return;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	makeop(ls,l,mid,L,R);makeop(rs,mid+1,r,L,R);
	pushup(u);
}
inline int querysum(int u,int l,int r,int L,int R){
	if(r<L||l>R) return 0;
	if(l>=L&&r<=R) return tree[u].sum;
	pushdown(u);
	int mid=(l+r)>>1;
	return querysum(ls,l,mid,L,R)+querysum(rs,mid+1,r,L,R);
}
inline int querymx(int u,int l,int r,int L,int R){
	if(r<L||l>R) return -inf;
	if(l>=L&&r<=R) return tree[u].mx;
	pushdown(u);
	int mid=(l+r)>>1;
	return max(querymx(ls,l,mid,L,R),querymx(rs,mid+1,r,L,R));
}
inline int querymn(int u,int l,int r,int L,int R){
	if(r<L||l>R) return inf;
	if(l>=L&&r<=R) return tree[u].mn;
	pushdown(u);
	int mid=(l+r)>>1;
	return min(querymn(ls,l,mid,L,R),querymn(rs,mid+1,r,L,R));
}
//以上为线段树
inline void updateTree(int x,int w){
	update(1,1,n,id[x],w);
}
inline void NTree(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		makeop(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(x!=y){
		if(dep[x]>dep[y]) swap(x,y);
		makeop(1,1,n,id[x]+1,id[y]);		
	}

}
inline void SumTree(int x,int y){
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans+=querysum(1,1,n,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(x!=y){
		if(dep[x]>dep[y]) swap(x,y);
		ans+=querysum(1,1,n,id[x]+1,id[y]);	
	}
	printf("%lld\n",ans);
}
inline void MaxTree(int x,int y){
	int ans=-inf;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans=max(querymx(1,1,n,id[top[x]],id[x]),ans);
		x=fa[top[x]];
	}
	if(x!=y){
		if(dep[x]>dep[y]) swap(x,y);
		ans=max(querymx(1,1,n,id[x]+1,id[y]),ans);	
	}
	printf("%lld\n",ans);
}
inline void MinTree(int x,int y){
	int ans=inf;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans=min(querymn(1,1,n,id[top[x]],id[x]),ans);
		x=fa[top[x]];
	}
	if(x!=y){
		if(dep[x]>dep[y]) swap(x,y);
		ans=min(querymn(1,1,n,id[x]+1,id[y]),ans);	
	}
	printf("%lld\n",ans);
}
signed main(){
	scanf("%lld",&n);
	for(int i=1,u,v,w;i<n;i++){
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u+1,v+1,w);add(v+1,u+1,w);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	scanf("%lld",&m);
	for(int i=1,w,x,u,v;i<=m;i++){
		scanf("%s",ch);
		if(ch[0]=='C'){
			scanf("%lld%lld",&x,&w);
			int tmp;
			u=e[x<<1].from,v=e[x<<1].to;
			if(dep[u]>dep[v]) tmp=u;
			else tmp=v;
			updateTree(tmp,w);
		}
		else if(ch[0]=='N'){
			scanf("%lld%lld",&u,&v);
			NTree(u+1,v+1);
		}
		else if(ch[0]=='S'){
			scanf("%lld%lld",&u,&v);
			SumTree(u+1,v+1);
		}
		else if(ch[1]=='A'){
			scanf("%lld%lld",&u,&v);
			MaxTree(u+1,v+1);
		}
		else{
			scanf("%lld%lld",&u,&v);
			MinTree(u+1,v+1);
		}
	}
	return 0;
}
```



---

## 作者：Cutest_Junior (赞：1)

## 题解 P1505 【[国家集训队]旅游】

### 题意

+ 输入一棵有 $n$ 个节点的树，有边权，无点权；
+ $m$ 个操作，支持
1. 单边修改边权；
2. 路径边权变相反数；
3. 求路径边权和；
4. 求路径边权最大值；
5. 求路径边权最小值；
+ $1\le n,m\le2\times10^5$。

### 做法

树剖套线段树，难点在于区间所有数变相反数。

区间和变为原来的相反数（~~显然~~）。

区间最大值变成相反数后肯定是最小值。

反证法：若还有更小的数，那么变相反数前肯定比区间最大值更大，矛盾。

区间最小值亦然。

剩下的就是板子了。

### 代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

const int inf = 0x7fffffff;

const int N = 2e5 + 5;

struct Edge {
	int to, dis, i;
};

vector<Edge> edge[N];

void add(int u, int v, int w, int i) {
	edge[u].push_back((Edge){v, w, i});
}

int dep[N];
int father[N];
int size[N];
int son[N];
int node[N];

void dfs1(int x) {
	size[x] = 1;
	for (int i = 0; i < edge[x].size(); ++i) {
		int to = edge[x][i].to;
		if (to == father[x]) {
			continue;
		}
		node[edge[x][i].i] = to;
		father[to] = x;
		dep[to] = dep[x] + 1;
		dfs1(to);
		size[x] += size[to];
		if (size[son[x]] < size[to]) {
			son[x] = to;
		}
	}
}

int top[N];
int id[N], idtot;
int val[N];

void dfs2(int x, int t, int w) {
	top[x] = t;
	id[x] = ++idtot;
	val[idtot] = w;
	for (int i = 0; i < edge[x].size(); ++i) {
		int to = edge[x][i].to;
		if (son[x] == to) {
			dfs2(son[x], t, edge[x][i].dis);
		}
	}
	for (int i = 0; i < edge[x].size(); ++i) {
		int to = edge[x][i].to;
		if (to == son[x] || to == father[x]) {
			continue;
		}
		dfs2(to, to, edge[x][i].dis);
	}
}

struct Tree {
	Tree *lson, *rson;
	int sum, maxx, minn;
	bool lazy;
}segment[N + N], *root = segment;
int tot;

Tree operator + (Tree a, Tree b) {
	Tree ans;
	ans.sum = a.sum + b.sum;
	ans.maxx = max(a.maxx, b.maxx);
	ans.minn = min(a.minn, b.minn);
	return ans;
}

void update(Tree *tree) {
	tree->sum = tree->lson->sum + tree->rson->sum;
	tree->maxx = max(tree->lson->maxx, tree->rson->maxx);
	tree->minn = min(tree->lson->minn, tree->rson->minn);
}

void build(Tree *tree, int l, int r) {
	if (l == r) {
		tree->sum = tree->maxx = tree->minn = val[l];
		return;
	}
	int mid = (l + r) >> 1;
	tree->lson = &segment[++tot];
	tree->rson = &segment[++tot];
	build(tree->lson, l, mid);
	build(tree->rson, mid + 1, r);
	update(tree);
}

void pushdown(Tree *tree) {
	if (tree->lazy == 0) {
		return;
	}
	tree->lson->sum = -tree->lson->sum;
	swap(tree->lson->maxx, tree->lson->minn);
	tree->lson->maxx = -tree->lson->maxx;
	tree->lson->minn = -tree->lson->minn;
	tree->rson->sum = -tree->rson->sum;
	swap(tree->rson->maxx, tree->rson->minn);
	tree->rson->maxx = -tree->rson->maxx;
	tree->rson->minn = -tree->rson->minn;
	tree->lson->lazy ^= 1;
	tree->rson->lazy ^= 1;
	tree->lazy = 0;
}

void change(Tree *tree, int l, int r, int x, int k) {
	if (l == r) {
		tree->sum = tree->maxx = tree->minn = k;
		return;
	}
	pushdown(tree);
	int mid = (l + r) >> 1;
	if (x <= mid) {
		change(tree->lson, l, mid, x, k);
	}
	else {
		change(tree->rson, mid + 1, r, x, k);
	}
	update(tree);
}

void turn(Tree *tree, int l, int r, int x, int y) {
	if (x <= l && r <= y) {
		tree->sum = -tree->sum;
		swap(tree->maxx, tree->minn);
		tree->maxx = -tree->maxx;
		tree->minn = -tree->minn;
		tree->lazy ^= 1;
		return;
	}
	pushdown(tree);
	int mid = (l + r) >> 1;
	if (x <= mid) {
		turn(tree->lson, l, mid, x, y);
	}
	if (mid < y) {
		turn(tree->rson, mid + 1, r, x, y);
	}
	update(tree);
}

Tree query(Tree *tree, int l, int r, int x, int y) {
//	printf("%d %d %d %d\n", l, r, x, y);
	if (x <= l && r <= y) {
		return *tree;
	}
	pushdown(tree);
	int mid = (l + r) >> 1;
	Tree a, b;
	if (x <= mid) {
		a = query(tree->lson, l, mid, x, y);
	}
	if (mid < y) {
		b = query(tree->rson, mid + 1, r, x, y);
	}
	if (x <= mid) {
		if (mid < y) {
			return a + b;
		}
		return a;
	}
	return b;
}

int n;

int query_max(int x, int y) {
	int ans = -inf;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) {
			swap(x, y);
		}
		ans = max(ans, query(root, 1, n, id[top[x]], id[x]).maxx);
		x = father[top[x]];
	}
	if (dep[x] < dep[y]) {
		swap(x, y);
	}
	if (x != y) {
		ans = max(ans, query(root, 1, n, id[y] + 1, id[x]).maxx);
	}
	return ans;
}

int query_min(int x, int y) {
	int ans = inf;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) {
			swap(x, y);
		}
		ans = min(ans, query(root, 1, n, id[top[x]], id[x]).minn);
		x = father[top[x]];
	}
	if (dep[x] < dep[y]) {
		swap(x, y);
	}
	if (x != y) {
		ans = min(ans, query(root, 1, n, id[y] + 1, id[x]).minn);
	}
	return ans;
}

int query_sum(int x, int y) {
	int ans = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) {
			swap(x, y);
		}
		ans += query(root, 1, n, id[top[x]], id[x]).sum;
		x = father[top[x]];
	}
	if (dep[x] < dep[y]) {
		swap(x, y);
	}
	if (x != y) {
		ans += query(root, 1, n, id[y] + 1, id[x]).sum;
	}
	return ans;
}

void tree_turn(int x, int y) {
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) {
			swap(x, y);
		}
		turn(root, 1, n, id[top[x]], id[x]);
		x = father[top[x]];
	}
	if (dep[x] < dep[y]) {
		swap(x, y);
	}
	if (x != y) {
		turn(root, 1, n, id[y] + 1, id[x]);
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i < n; ++i) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		++u;++v;
		add(u, v, w, i);
		add(v, u, w, i);
	}
	dfs1(1);
	dfs2(1, 1, 0);
	build(root, 1, n);
	int m;
	scanf("%d", &m);
	for (int i = 1; i <= m; ++i) {
		char c[10];
		int x, y;
		scanf("%s%d%d", c, &x, &y);
//		++x;++y;
//		printf("%d %d\n", x, y);
		if (c[0] == 'C') {
//			++x;
			change(root, 1, n, id[node[x]], y);
		}
		else if (c[0] == 'N') {
			++x;++y;
			tree_turn(x, y);
		}
		else if (c[0] == 'S') {
			++x;++y;
//			printf("1");
			printf("%d\n", query_sum(x, y));
		}
		else if (c[1] == 'A') {
			++x;++y;
			printf("%d\n", query_max(x, y));
		}
		else {
			++x;++y;
			printf("%d\n", query_min(x, y));
		}
	}
}
```

---

## 作者：FANTASTlC (赞：0)

### 简介：
将树剖模板题维护的点权变为了边权，只需利用树的基本性质（一个节点只有一个父亲），以点带边，每个点上的权值为这个点到其父节点的边的权值，就可以将其变为树剖模板题了。~~然而我交了好几发~~。
### 该题有以下几个坑点：
1. 树剖退出循环时，在树中深度较小的那个节点所维护的点权是它到它父节点的那条边的权值，与操作所要维护的东西无关。以求一条链上边权和的操作为例，需要写成这样
	```c
	mn=min(mn,querymin(1,t[u].id+1,t[v].id));
	```
	普通树剖:
	```c
	mn=min(mn,querymin(1,t[u].id,t[v].id));
	```
    
1. 树剖退出循环时，如果两点已经重合，则不需要进行任何操作，所以需要特判（~~不特判也没事，这有在玄学情况下才会WA~~）。

1. 在修改一条边的权值时，由于点维护的是它到它父节点的边的权值，所以要修改的点是深度较小的那一个。 
### _code:_ 
```c
#include<bits/stdc++.h>
#define N (int)(2e5+1)
#define M 5001
#define R register
#define INFI 0x7fffffff
#define INFL 0x7fffffffffffffff
#define F(i,start,end) for(R int (i)=(start);(i)<=(end);i++)
using namespace std;
template<typename T> void read(T &x)
{
	int f=1;
	x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=x*10+c-'0';
		c=getchar();
	}
	x=x*f;
	return;
}
void write(int x)
{
	if(x<0)
		x=~x+1,putchar('-');
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
	return;
}
int n,m,cnt,tot;
char opt[5];
vector<pair<int,int> > ve;
struct edge
{
	int v,d,next;
}e[N<<1];
struct node
{
	int f,top,dep,d,nd,size,son,id,head;
}t[N];
struct segment_tree
{
	#define ls rt<<1
	#define rs rt<<1|1
	#define mid (tree[rt].l+tree[rt].r>>1)
	struct node
	{
		int l,r,mn,mx,sm;
		bool op;
	}tree[N<<2];
	void update(int rt)//将一个点所维护的区间里所有点的点权变为其相反数 
	{
		tree[rt].op^=1;//打上懒标记 
		tree[rt].sm*=-1;//和变为其相反数（原理小学应该将过吧） 
		tree[rt].mx*=-1;
		tree[rt].mn*=-1;
		swap(tree[rt].mx,tree[rt].mn);//最大值变成最小值，最小值变成最大值（原理小学应该也讲过吧） 
		return;
	}
	void pushup(int rt)//合并一个区间的信息 
	{
		tree[rt].mn=min(tree[ls].mn,tree[rs].mn);
		tree[rt].mx=max(tree[ls].mx,tree[rs].mx);
		tree[rt].sm=tree[ls].sm+tree[rs].sm;
		return;
	}
	void pushdown(int rt)//释放懒标记 
	{
		if(tree[rt].op)
		{
			tree[rt].op=0;
			update(ls);
			update(rs);
		}
		return;
	}
	void build(int rt,int l,int r)//建树 
	{
		tree[rt].l=l;
		tree[rt].r=r;
		if(l==r)
		{
			if(l==1)//对于根特别处理 
			{
				tree[rt].mx=-INFI;
				tree[rt].mn=INFI;
				tree[rt].sm=0;
				return;	
			}
			tree[rt].mn=t[l].nd;
			tree[rt].mx=t[l].nd;
			tree[rt].sm=t[l].nd;
			return;
		}
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(rt);
		return;
	}
	void modify(int rt,int k,int v)//修改一条边的权值 
	{
		if(tree[rt].l==tree[rt].r)
		{
			tree[rt].mn=v;
			tree[rt].mx=v;
			tree[rt].sm=v;
			return;
		}
		pushdown(rt);
		if(k<=mid)
			modify(ls,k,v);
		else
			modify(rs,k,v);
		pushup(rt);
		return;
	}
	void oppose(int rt,int l,int r)//将一条边的权值变为其相反数 
	{
		if(l<=tree[rt].l&&tree[rt].r<=r)
		{
			update(rt);
			return;
		}
		pushdown(rt);
		if(l<=mid)
			oppose(ls,l,r);
		if(mid<r)
			oppose(rs,l,r);
		pushup(rt);
		return;
	}
	int querymax(int rt,int l,int r)//查询区间最大值 
	{
		if(l>tree[rt].r||r<tree[rt].l)
			return -INFI;
		if(l<=tree[rt].l&&tree[rt].r<=r)
			return tree[rt].mx;
		pushdown(rt);
		return max(querymax(ls,l,r),querymax(rs,l,r));
	}
	int querymin(int rt,int l,int r)//查询区间最小值 
	{
		if(l>tree[rt].r||r<tree[rt].l)
			return INFI;
		if(l<=tree[rt].l&&tree[rt].r<=r)
			return tree[rt].mn;
		pushdown(rt);
		return min(querymin(ls,l,r),querymin(rs,l,r));
	}
	int querysum(int rt,int l,int r)//查询区间和 
	{
		if(l>tree[rt].r||r<tree[rt].l)
			return 0;
		if(l<=tree[rt].l&&tree[rt].r<=r)
			return tree[rt].sm;
		pushdown(rt);
		return querysum(ls,l,r)+querysum(rs,l,r);
	}
	int querymax_range(int u,int v)//查询一条链上边权的最大值 
	{
		int mx=-INFI;
		while(t[u].top!=t[v].top)
		{
			if(t[t[u].top].dep<t[t[v].top].dep)
				swap(u,v);
			mx=max(mx,querymax(1,t[t[u].top].id,t[u].id));
			u=t[t[u].top].f;
		}
		if(t[u].dep>t[v].dep)
			swap(u,v);
		if(u!=v)
			mx=max(mx,querymax(1,t[u].id+1,t[v].id));
		return mx;
	}
	int querymin_range(int u,int v)//查询一条链上边权的最小值 
	{
		int mn=INFI;
		while(t[u].top!=t[v].top)
		{
			if(t[t[u].top].dep<t[t[v].top].dep)
				swap(u,v);
			mn=min(mn,querymin(1,t[t[u].top].id,t[u].id));
			u=t[t[u].top].f;
		}
		if(t[u].dep>t[v].dep)
			swap(u,v);
		if(u!=v)
			mn=min(mn,querymin(1,t[u].id+1,t[v].id));
		return mn;
	}
	int querysum_range(int u,int v)//查询一条链上边权的和 
	{
		int sm=0;
		while(t[u].top!=t[v].top)
		{
			if(t[t[u].top].dep<t[t[v].top].dep)
				swap(u,v);
			sm+=querysum(1,t[t[u].top].id,t[u].id);
			u=t[t[u].top].f;
		}
		if(t[u].dep>t[v].dep)
			swap(u,v);
		if(u!=v)
			sm+=querysum(1,t[u].id+1,t[v].id);
		return sm;
	}
	void oppose_range(int u,int v)//将一条链上所有边的权值变为其相反数 
	{
		while(t[u].top!=t[v].top)
		{
			if(t[t[u].top].dep<t[t[v].top].dep)
				swap(u,v);
			oppose(1,t[t[u].top].id,t[u].id);
			u=t[t[u].top].f;
		}
		if(t[u].dep>t[v].dep)
			swap(u,v);
		if(u!=v)
			oppose(1,t[u].id+1,t[v].id);
		return;
	}
	#undef ls
	#undef rs
	#undef mid
}st;
void add_edge(int u,int v,int d)
{
	e[++cnt]=(edge){v,d,t[u].head};
	t[u].head=cnt;
	e[++cnt]=(edge){u,d,t[v].head};
	t[v].head=cnt;
	return;
}
void dfs1(int u)//树剖第一步 
{
	t[u].size=1;
	for(int i=t[u].head;i;i=e[i].next)
	{
		int v=e[i].v;
		if(!t[v].size)
		{
			t[v].f=u;
			t[v].d=e[i].d;
			t[v].dep=t[u].dep+1;
			dfs1(v);
			t[u].size+=t[v].size;
			t[u].son=t[t[u].son].size>=t[v].size?t[u].son:v;	
		}	
	}	
	return;
}
void dfs2(int u)//树剖第二步 
{
	t[u].id=++tot;
	t[tot].nd=t[u].d;
	if(!t[u].son)
		return;
	t[t[u].son].top=t[u].top;
	dfs2(t[u].son);
	for(int i=t[u].head;i;i=e[i].next)
	{
		int v=e[i].v;
		if(v!=t[u].f&&v!=t[u].son)
		{
			t[v].top=v;
			dfs2(v);
		}
	}
	return;
}
int main()
{
//	freopen("program.in","r",stdin);
//	freopen("program.out","w",stdout);
	read(n);
	ve.push_back(make_pair(0,0));
	F(i,2,n)
	{
		int u,v,w;
		read(u),read(v),read(w);
		u++;
		v++;
		add_edge(u,v,w);
		ve.push_back(make_pair(u,v));
	}
	t[1].dep=1;
	dfs1(1);
	t[1].top=1;
	dfs2(1);
	st.build(1,1,n);
	read(m);
	F(i,1,m)
	{
		int x,y;
		memset(opt,'\0',sizeof(opt));
		scanf("%s",&opt);
		read(x),read(y);
		if(opt[0]=='C')
		{
			int u=ve[x].first,v=ve[x].second;
			if(t[u].dep<t[v].dep)
				st.modify(1,t[v].id,y);
			else
				st.modify(1,t[u].id,y);
		}
		if(opt[0]=='N')
		{
			x++;
			y++;
			st.oppose_range(x,y);
		}	
		if(opt[0]=='S')
		{
			x++;
			y++;
			write(st.querysum_range(x,y));
			puts("");
		}
		if(opt[2]=='X')
		{
			x++;
			y++;
			write(st.querymax_range(x,y));
			puts("");
		}
		if(opt[2]=='N')
		{
			x++;
			y++;
			write(st.querymin_range(x,y));
			puts("");
		}
	}
 	return 0;
}
```


---

## 作者：Link_Space (赞：0)

其实这道题就是一道普通的树链剖分，就是有些步骤可能有些不同，大家都知道普通的树剖是对点权进行操作的，而这道题却是对边权进行操作，所以我们应该先思考如何才能将边权转化为点权然后进行树剖然后进行操作，其实这个问题很简单就可以得到答案，就是将边权转化到这个边所连的儿子节点上，也就是dfs序更大的点上，这是为什么呢？这是因为如果你将边权转化到这个边连的父亲上，也就是dfs序更小的那个点上的话，会出现多条边连向同一个父亲的情况，这样你就不知道这个点上的点权究竟是哪个边的边权，如果连向儿子的话就不会出现这种问题，因为一个儿子节点只有一个父亲节点，所以将边转成点的操作我们就解决了。再看下一个操作，将路径上的边权全部变为相反数，这个很简单，乘以一个-1就好了，剩下的三个操作都是树剖常规操作，不再过多赘述，如果还有不懂的请看代码及代码中注释，或者是改不出来错的也可以观看代码中的注释，注释中指出了本蒟蒻认为可能会比较容易出错的一些地方。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1e6 + 5;
struct node{
    int lef;
    int rig;
    int minn;
    int maxn;
    int sum;//处理各种操作
    int aim;//pushdown懒标记
} Tree[N];
int head[N];
int nxt[N];
int ver[N];
int cnt;
int edge[N];
int a[N];
int b[N];
int etp[N];
int link[N];
void add(int x,int y,int z)
{
    nxt[++cnt] = head[x];
    head[x] = cnt;
    ver[cnt] = y;
    link[cnt] = z;
}
int top[N];
int siz[N];
int dep[N];
int father[N];
int son[N];
int belong[N];
int id[N];
int idx;
void dfs1(int now,int fa,int depth)
{
    father[now] = fa;
    dep[now] = depth;
    siz[now] = 1;
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0 = ver[i];
        if(v0==fa)
            continue;
        etp[v0] = link[i];//此处即为将边权转为儿子点权的操作
        dfs1(v0, now, depth + 1);
        siz[now] += siz[v0];
        if(siz[v0]>siz[son[now]])
            son[now] = v0;
    }
}
void dfs2(int now,int t)
{
    id[now] = ++idx;
    top[now] = t;
    belong[idx] = etp[now];
    if(!son[now])
        return;
    dfs2(son[now], t);
    for (int i = head[now]; i;i=nxt[i])
    {
        int v0 = ver[i];
        if(v0==father[now]||v0==son[now])
            continue;
        dfs2(v0, v0);
    }
}
void pushup(int now)
{
    Tree[now].sum = Tree[now << 1].sum + Tree[now << 1 | 1].sum;
    Tree[now].maxn = max(Tree[now << 1].maxn, Tree[now << 1 | 1].maxn);
    Tree[now].minn = min(Tree[now << 1].minn, Tree[now << 1 | 1].minn);
}//pushup随时更新三个操作数
void pushdown(int now)
{
    if(Tree[now].aim)
    {
        swap(Tree[now << 1].maxn, Tree[now << 1].minn);
        swap(Tree[now << 1 | 1].maxn, Tree[now << 1 | 1].minn);//路径上的所有边权变为相反数，相对应的最大值也就变成了最小值，最小值变成了最大值
        Tree[now << 1].maxn *= -1;
        Tree[now << 1].minn *= -1;
        Tree[now << 1 | 1].maxn *= -1;
        Tree[now << 1 | 1].minn *= -1;
        Tree[now << 1].sum *= -1;
        Tree[now << 1 | 1].sum *= -1;
        Tree[now << 1].aim =1;
		Tree[now << 1 | 1].aim =1;
        Tree[now].aim = 0;
    }
}
void build(int now,int l,int r)
{
    Tree[now].lef = l;
    Tree[now].rig = r;
    if(l==r)
    {
        Tree[now].maxn = Tree[now].minn = Tree[now].sum = belong[l];
        return;
    }
    int mid = l + r >> 1;
    build(now << 1, l, mid);
    build(now << 1 | 1, mid + 1, r);
    pushup(now);
}
void change(int now,int l,int r,int x)
{
	if(l==Tree[now].lef&&Tree[now].rig==r)
	{
		Tree[now].sum=Tree[now].maxn=Tree[now].minn=x;//单点修改后三个操作数都要跟着变化
		return;
	}
	pushdown(now);
	int mid=(Tree[now].lef+Tree[now].rig)>>1;
	if(l<=mid)
		change(now<<1,l,r,x);
	if(r>mid)
		change(now<<1|1,l,r,x);
	pushup(now);//修改中千万不要忘记了pushdown和pushup，下同
}//第一个修改，单点修改
void change2(int now,int l,int r)
{
	if(l<=Tree[now].lef&&Tree[now].rig<=r)
	{
		Tree[now].sum*=-1;
		swap(Tree[now].maxn,Tree[now].minn);
		Tree[now].maxn*=-1;
		Tree[now].minn*=-1;
		Tree[now].aim=1;
		return;
	}
	pushdown(now);
	int mid=(Tree[now].lef+Tree[now].rig)>>1;
	if(l<=mid)
		change2(now<<1,l,r);
	if(r>mid)
		change2(now<<1|1,l,r);
	pushup(now);
}//第二个修改，区间修改
int query1(int now,int l,int r)
{
	if(l<=Tree[now].lef&&Tree[now].rig<=r)
	{
		return Tree[now].sum;
	}
	pushdown(now);//查询不用pushup,但也别忘了pushdown，本蒟蒻曾经因为忘记查询中pushdown导致改了一下午都没改出来
	int mid=(Tree[now].lef+Tree[now].rig)>>1;
	int res=0;
	if(l<=mid)
		res+=query1(now<<1,l,r);
	if(r>mid)
		res+=query1(now<<1|1,l,r);
	return res;
}//第一个查询，路径上边权和查询
int query2(int now,int l,int r)
{
	if(l<=Tree[now].lef&&Tree[now].rig<=r)
	{
		return Tree[now].maxn;
	}
	pushdown(now);
	int mid=(Tree[now].lef+Tree[now].rig)>>1;
	int res=-0x7fffffff;
	if(l<=mid)
		res=max(res,query2(now<<1,l,r));
	if(r>mid)
		res=max(res,query2(now<<1|1,l,r));
	return res;
}//第二个查询，路径上边权最大值查询
int query3(int now,int l,int r)
{
	if(l<=Tree[now].lef&&Tree[now].rig<=r)
	{
		return Tree[now].minn;
	}
	pushdown(now);
	int mid=(Tree[now].lef+Tree[now].rig)>>1;
	int res=0x7fffffff;
	if(l<=mid)
		res=min(res,query3(now<<1,l,r));
	if(r>mid)
		res=min(res,query3(now<<1|1,l,r));
	return res;
}//第三个查询，路径上边权最小值查询
void modify_path(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		change2(1,id[top[u]],id[u]);
		u=father[top[u]];
	}
	if(dep[u]>dep[v])
		swap(u,v);
	change2(1,id[u]+1,id[v]);//注意这个地方左边界是id[u]+1，这也是很重要以及很容易犯错的一点，为什么是id[u]+1呢？因为我们在边权转化为点权的时候是将边权转移给了儿子，所以说查找u至v上的边权的时候只需要查到u的儿子即可，u的儿子的dfs序即为id[u]+1，如果还是按照常规写的话就会查询到u节点以及它的父亲之间的那条边，不符合要求。下同
}
int query_path_SUM(int u,int v)
{
	int res=0;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		res+=query1(1,id[top[u]],id[u]);
		u=father[top[u]];
	}
	if(dep[u]>dep[v])
		swap(u,v);
	res+=query1(1,id[u]+1,id[v]);
	return res;
}
int query_path_MAXN(int u,int v)
{
	int res=-0x7fffffff;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		res=max(res,query2(1,id[top[u]],id[u]));
		u=father[top[u]];
	}
	if(dep[u]>dep[v])
		swap(u,v);
	res=max(res,query2(1,id[u]+1,id[v]));
	return res;
}
int query_path_MINN(int u,int v)
{
	int res=0x7fffffff;
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		res=min(res,query3(1,id[top[u]],id[u]));
		u=father[top[u]];
	}
	if(dep[u]>dep[v])
		swap(u,v);
	res=min(res,query3(1,id[u]+1,id[v]));
	return res;
}
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i < n;i++)
    {
        scanf("%d%d%d", &a[i], &b[i], &edge[i]);
        a[i]++;
        b[i]++;//记得++，节点编号从0开始
        add(a[i], b[i], edge[i]);
        add(b[i], a[i], edge[i]);
    }
    dfs1(1,0,1);
    dfs2(1,1);
    build(1,1,n);
	int m;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		string op;
		int u,v;
		cin>>op;
		scanf("%d%d",&u,&v);
		u++;
		v++;//这个地方也一定要记得++
		if(op=="C")
		{
			u--;
			v--;
			int temp;
			if(dep[a[u]]>dep[b[u]])
				temp=id[a[u]];
			else 
				temp=id[b[u]];//哪个的深度深就查找哪个点，因为深度深的点即为儿子，儿子上的点权即为该条边的边权
			change(1,temp,temp,v);
		}
		else if(op=="N")
		{
			modify_path(u,v);
		}
		else if(op=="SUM")
		{
			printf("%d\n",query_path_SUM(u,v));
		}
		else if(op=="MAX")
		{
			printf("%d\n",query_path_MAXN(u,v));
		}
		else
		{
			printf("%d\n",query_path_MINN(u,v));
		}
	} 
}
```


---


# [国家集训队] 拉拉队排练

## 题目描述

艾利斯顿商学院篮球队要参加一年一度的市篮球比赛了。拉拉队是篮球比赛的一个看点，好的拉拉队往往能帮助球队增加士气，赢得最终的比赛。所以作为拉拉队队长的楚雨荨同学知道，帮助篮球队训练好拉拉队有多么的重要。

拉拉队的选拔工作已经结束，在雨荨和校长的挑选下，$n$ 位集优秀的身材、舞技于一体的美女从众多报名的女生中脱颖而出。这些女生将随着篮球队的小伙子们一起，和对手抗衡，为艾利斯顿篮球队加油助威。

一个阳光明媚的早晨，雨荨带领拉拉队的队员们开始了排练。$n$ 个女生从左到右排成一行，每个人手中都举了一个写有 $26$ 个小写字母中的某一个的牌子，在比赛的时候挥舞，为小伙子们呐喊、加油。

雨荨发现，如果连续的一段女生，有奇数个，并且她们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。

现在雨荨想找出所有和谐小群体，并且按照女生的个数降序排序之后，前 $K$ 个和谐小群体的女生个数的乘积是多少。由于答案可能很大，雨荨只要你告诉她，答案除以 $19930726$ 的余数是多少就行了。

## 说明/提示

### 样例说明

和谐小群体女生所拿牌子上写的字母从左到右按照女生个数降序排序后为 `ababa`，`aba`，`aba`，`bab`，`a`，`a`，`a`，`b`，`b`，前三个长度的乘积为 $5\times 3\times 3 = 45$。


### 数据范围与约定


测试点 | $n$ | $K$
-----|---------|---
1    | $10$ | $10$
2-3  | $100$ | $100$
4-7  | $1,000$ | $1,000$
8    | $100,000$ | $= 1$
9-11 | $100,000$ | $100,000$
12-14| $100,000$ | $1,000,000,000,000$
15-17| $500,000$ | $1,000,000,000,000$
18   | $1,000,000$ | $= 1$
19   | $1,000,000$ | $1,000,000$
20   | $1,000,000$ | $1,000,000,000,000$

## 样例 #1

### 输入

```
5 3
ababa```

### 输出

```
45
```

# 题解

## 作者：三好代表 (赞：37)

首先做这道题要掌握一个算法——[Manacher算法](https://www.cnblogs.com/lykkk/p/10460087.html)

简要说他就是用来解决回文串相关问题的算法，并不高深

由题意可知，显然**每一个和谐群体就是一个长度为奇数的回文串**

用Manacher可以求每个位置的回文半径

因为我们只要求奇数个的回文串，那么显然我们不需要在字符串里添加一些无关字符

那么我们用Manacher求出以当前位置为中心的最长回文子串长度

所以我们就会在求的同时搞出最长的len

然后根据对称性可知也有长为**len*2-1**的回文子串，接着我们只需要统计一下就可以了


注意我们**只要奇数个，去掉偶数个**

因为数据范围过大，所以我们要**Fast_Pow**使得不会爆掉

那么。。。下面我们来看一下我~~优秀的代码~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mod = 19930726;
const int N = 1100000;
char s[N],str[N*2];
int p[N*2],cnt[N];
int len,n;
ll ans=1,k;
ll ksm(int x,int y) {//因为数据范围很大容易爆掉，所以就要Fast_Pow
    if(x==1) return 1;
    ll res=1,base=x;
    while(y) {
        if(y&1) res=(res*base)%mod;
        base=(base*base)%mod;
        y>>=1;
    }
    return res;
}
void manacher() {//Manacher模板，详见洛谷P3805
    for(int i=1; i<=len; i++) str[i*2-1]='%',str[i*2]=s[i];
    str[len=len*2+1]='%';
    int id=0,mx=0;
    for(int i=1; i<=len; i++) {
        if(i<mx) p[i]=min(p[id*2-i],mx-i);
        else p[i]=1;
        while(p[i]+i<=len && i-p[i]>=1 && str[i+p[i]]==str[i-p[i]]) p[i]++;
        if(p[i]+i>mx) id=i,mx=i+p[i];
        if((p[i]-1)%2) cnt[p[i]-1]++;
    }
}
int main() {
    int sum=0;
    cin>>n>>k>>s+1;
    len=n;
    manacher();
    for(int i=n; i>=1; --i) {//根据题意常规操作
        if(i%2==0) continue;
        sum+=cnt[i];
        if(k>=sum) {
            ans=(ans*ksm(i,sum))%mod;
            k-=sum;
        } else {
            ans=(ans*ksm(i,k))%mod;
            k-=sum;
            break;
        }
    }
    if(k>0) ans=-1;
    cout<<ans;
    return 0;
}
```


---

## 作者：顾z (赞：21)

**题目描述**
 
 n个女生举牌子(只含有26个小写字母,长度为n的字符串),  如果连续的一段女生，有奇数个，并且她们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。
现在想找出所有和谐小群体，并且按照女生的个数降序排序之后，前K个和谐小群体的女生个数的乘积是多少。由于答案可能很大，输出除以19930726的余数。

**分析**
   
   显然,一个和谐小群体是一个长度为奇数的回文串。
   
   ~~理所当然地~~我们想到了manacher算法
   
   **manacher**算法可以求出每个位置的回文半径.
   
   所以我们可以用manacher来解决此题
   
   然后因为这个题只需要求出奇数长度的回文串
   
   所以不需要考虑插入字符(其实也可以插入
   
   由于最后一个点十分大 k<10^12(辣么长
   
   所以需要**快速幂**加速一下
   
**掉坑现场**

   重点 ~~个人认为~~
   求出了某一位置的回文半径
   
   就像样例解释中一样
         
      eg：a b a b a
      回文半径为5
      但它也包含了 a bab ababa！
    即如果一个值为x(x>1)那x-1,x-2.....也存在
 所以我们需要**前缀和**来做
 (感觉不应该叫前缀和啊emm 但又感觉差不多)
 
我们可以用**桶**存储一下回文半径,倒着搜一遍即可


_(:з」∠)_      ~~(胳膊没了~~

----------------代码------------------
#### ——代码部分参考[bolg @five20](https://www.cnblogs.com/five20/p/8616294.html)

```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register long long
#define N 1000008
#define mod 19930726
char s[N<<1],ch[N];
long long n,k,len,RL[N<<1],mxxnum,sum,ans=1;
long long MaxRight,center,tong[N<<1];
IL long long ksm(long long x,long long y)
{
	long long res=1;
	for(;y;y>>=1,x=x*x%mod)
		if(y&1)res=res*x%mod;
	return res;
}
int main()
{
	scanf("%lld%lld",&n,&k);
	scanf("%s",s+1);
	for(RI i=1;i<=n;i++)
	{
		if(i<=MaxRight)RL[i]=std::min(MaxRight-i,RL[2*center-i]);
		else RL[i]=1;
		while(i+RL[i]<=n&&i-RL[i]>=0&&s[i+RL[i]]==s[i-RL[i]])++RL[i];
		if(i+RL[i]-1>MaxRight)MaxRight=i+RL[i]-1,center=i;
		tong[2*RL[i]-1]++;
	}
	//for(RI i=1;i<=n;i++)printf("%lld ",tong[i]);
	if(n%2!=1)n--;
	for(RI i=n;i>=1;i-=2)
	{	
		sum+=tong[i];
		if(sum>k)
		{
			ans=ans*ksm(i,k)%mod;
			break;
		}
		else
		{
			ans=ans*ksm(i,sum)%mod;
			k-=sum;
		}
	}
	if(sum<k)printf("-1");
	else printf("%lld\n",ans);
}
```

~~好了好了 我知道丑了emmmm~~

---

## 作者：nianheng (赞：8)

## 我的解法：回文自动机

看见大家的题解大多都是用的马拉车算法，其实这道题也可以用另一种解法一一回文自动机，并且这道题用这个数据结构可以无脑解决$qwq$

#### 1.介绍：回文自动机一一处理回文串问题的有力武器
 
$\quad$a.大概： 同其他自动机一样，回文自动机是个DAG，它用相当少（$O(n)$）的空间复杂度就存储了这个字符串的所有回文串信息。一个回文自动机包含不超过$|S|$个节点，每个节点都表示了这个字符串的一个不重复的回文子串，同时一个节点会有不超过字符集大小的边连向其他节点，以及一条fail边连向这个点的fail...这些都会在下面介绍

$\quad$b.森林： 和别的自动机不太一样，回文自动机是有两棵树的森林：其中一棵是长度为偶数的回文串集合，另一棵是长度为奇数的回文串集合，这两棵树的根节点分别表示长度为0（空串）和-1（无实际含义，便于运算）的回文串;

$\quad$c.边：自动机中每条有向边都有一个字符类型的权值，起点的串左右分别加上这个字符得到的就是终点的串。举个栗子：设一条边权为$c$的边连接的两个点分别是$A,B$，$A$表示回文串$aba$，则$B$表示的回文串就是$cabac$ 。特别的，如果$A$是哪个长度为$-1$的根，$B$串就是这条边的权值。。。

$\quad$d.点：从根节点往下顺着边走，记着一个str一开始为空，一边走一边不停地往str左右两边添加新的字符，走到一个点，这个点代表的回文串就是str

$\quad$e.$fail$边：每个点都有个fail边，这条边指向这个点所代表的回文串的 最长回文后缀 所在的那个点（最长回文后缀：串中满足回文的最长的后缀，这个串自己不算）如果没有，则指向0（就是那个根节点）。特别的，0的fail节点就是那个长度为-1的点。

#### 2.构造：
$\quad$我是用的一个结构体存的，$len,fail,son[26],siz$  分别代表这个串的长，fail节点，连出来的每一条边以及这个回文串的数量，如下

~~~cpp
struct node{
	int len,fail,son[26],siz;
	node(){
		len=fail=0;
		for(int i=0;i<=25;i++)
			son[i]=0;
	}
};
node prt[maxn]; 
~~~

我们把两个根下标设为0和1，并根据上面介绍的给他们赋值

~~~cpp
	prt[1].len=-1;
	prt[0].fail=prt[1].fail=1;
~~~

然后我们就可以把点一个一个加入到回文自动机中，这可以用一个函数$extend$来实现，具体实现方法如下：

设我们以前插入的最后一个点为$last$，这次要插入一个点x，首先要找到一个点$cur$为满足前面的字符等于新加入字符的，$last$的最长的回文后缀，这个过程可以不停地在$last$的$fail$链上跑，因为$fail$所对应的正是串的最长回文后缀，这个可以用下面函数实现：
~~~cpp
int getfail(int x){
	while(s[n-prt[x].len-1]!=s[n]) x=prt[x].fail;
	return x;
}
~~~
若$cur$已经包含权值为x的出边了，我们就可以简单地将出边终点的权值++，继续去加下一个点了。如果不包含权值x的边，我们就需要新建一个点$now$并让$cur$把边连向他，$now$代表的长度自然是$cur$的长度+2，然后我们只要求出$cur$的$fail$就完事了。

求$fail$的话可以用cur的$fail$来求，就用上面求$cur$的方法，但是不能用$cur$本身（想一想，为什么）

当然最后千万不要忘记把$last$的值更新啊$qwq$

~~~cpp
void extend(int x){
	int cur=getfail(last);
	if(!prt[cur].son[x]){
		int now=++num;
		prt[now].len=prt[cur].len+2;
		prt[now].fail=prt[getfail(prt[cur].fail)].son[x];
		prt[cur].son[x]=now;
	}
	prt[prt[cur].son[x]].siz++;
	last=prt[cur].son[x];
}
~~~

累计答案可以从下往上把回文串数目加起来，显然上面的串一定是下面串的子串嘛$qwq$

~~~cpp
void count(){
	for(int i=num;i>=2;i--)
		prt[prt[i].fail].siz+=prt[i].siz;
}
~~~

#### 4.还是不太懂？照着图片模拟一边就好了啦：
#### $\quad$此处感谢 @单曦增 神犇为我们提供神图 (样例) 记得膜拜哦$orz$

![](https://cdn.luogu.com.cn/upload/pic/32635.png)

如图，我们已经把串$abab$的回文自动机建好了，下面要添加一个点$a$，此时$last=5$

首先求出$cur$，$last$所代表的回文串$bab$前边的字符正好与要加入的字符$a$相等，所以$cur$就是$last$，我们发现$cur$不存在边权为$a$的出边，于是新建个点 6，从$cur$连一条边$a$到 6；

![](https://cdn.luogu.com.cn/upload/pic/32638.png)

6 的长度自然是5的长度+2$(a'bab'a)$

然后求6的$last$：5的$fail$指向3$(b)$，可以发现，3前面的那个字符$a$就是新加的字符（怎么那么巧...），于是我们把6的fail指向点3的$a$边所指向的点4;

嗯，$last$更新为6，6的数量++，结束；

![](https://cdn.luogu.com.cn/upload/pic/32634.png)

最后累加答案，

$siz(6)=1$，$siz(4)=1$

$(siz(5)+=siz(6))=2$

$(siz(4)+=siz(6))=2$

$(siz(3)+=siz(5))=2$

$(siz(2)+=siz(4))=3$
#### 附：闲得自己也写了个造图的代码。。。

~~~cpp
void print(int x){
	if(cz[x]) return;
	cz[x]=1;
	printf("	%d->%d[style=\"dashed\"];\n",x,sam[x].link);
	for(int i=0;i<=25;i++)
		if(sam[x].ch.count(i))
			printf("	%d->%d[label=%d];\n",x,sam[x].ch[i],i),
			print(sam[x].ch[i]);
}
void Vz(){
	printf("digraph zhy{\n	rankdir = LR;\n");
	print(0);
	printf("}\n");
}
~~~

#### 5.这题：
$\quad$这道题的话就是把这些点按照长度从大到小排一遍序，然后前$k$个奇数长的乘起来就是答案啦，注意这题k较大，还要用快速幂哦，代码： 

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int maxn=1e6+100,P=19930726;
struct node{
	int len,fail,son[26],siz;
	node(){
		len=fail=0;
		for(int i=0;i<=25;i++)
			son[i]=0;
	}
};
node prt[maxn]; 
int n,last,len,num;
ll ans=1,k;
char s[maxn];
ll poww(ll x,int y){
	ll base=1;
	while(y){
		if(y&1) base*=x,base%=P;
		x*=x,x%=P;
		y>>=1;
	}
	return base;
}
bool cmp(node x,node y){
	return x.len>y.len;
}
int getfail(int x){
	while(s[n-prt[x].len-1]!=s[n]) x=prt[x].fail;
	return x;
}
void extend(int x){
	int cur=getfail(last);
	if(!prt[cur].son[x]){
		int now=++num;
		prt[now].len=prt[cur].len+2;
		prt[now].fail=prt[getfail(prt[cur].fail)].son[x];
		prt[cur].son[x]=now;
	}
	prt[prt[cur].son[x]].siz++;
	last=prt[cur].son[x];
}
int main(){
	scanf("%d%d",&len,&k);
	scanf("%s",s);
	last=num=1,prt[1].len=-1;
	prt[0].fail=prt[1].fail=1;
	for(n=0;n<len;n++) extend(s[n]-'a');
	for(int i=num;i>=2;i--)
		prt[prt[i].fail].siz+=prt[i].siz,prt[prt[i].fail].siz%=P;
	sort(prt+1,prt+num+1,cmp);
	int now=1;
	while(k){
		if(now>num){
			printf("-1\n");
			return 0;
		}
		if(prt[now].len%2==0){
			now++;
			continue;
		}
		if(prt[now].siz<k){
			k-=prt[now].siz;
			ans*=poww(prt[now].len,prt[now].siz)%P;
			ans%=P;
			now++;
		}
		else{
			ans*=poww(prt[now].len,k)%P;
			ans%=P;
			k=0;
		}
	}
	printf("%lld\n",ans);
}




```



---

## 作者：noble_ (赞：7)

## 蛤？竟然是首杀，那么再来个题解吧


---

更好的体验请移步 ： [俺的博客](http://www.cnblogs.com/noblex/p/8313535.html "俺的博客")



---
这题可真是一道练习Manacher的好题啊。


**看到回文当然是要用马拉车瞎搞啦。

但是马拉车只能搞出以当前点为中心的最大回文子串长度。

于是先搞出最大的length之后。那么根据对称性易证也有长为![](https://images2017.cnblogs.com/blog/1231076/201801/1231076-20180118232543068-101970944.png)的回文子串，然后统计一下就行了。

题目要求奇数个，把偶数个的全踢掉就行了。**


---

丑陋的代码（捂眼）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=19930726,MAXN=1000003;
char s[MAXN],now[MAXN*2];
int p[MAXN*2],cnt[MAXN],len,n;
ll ans=1,k;

ll poww(int x,int y)
{
    if(x==1) return 1;
    ll base=x,res=1;
    while(y)
    {
        if(y&1) res=(res*base)%MOD;
        base=(base*base)%MOD;
        y>>=1;
    }
    return res;
}

void Manacher()
{
    for(int i=1;i<=len;i++)
    {
        now[2*i-1]='%'; now[2*i]=s[i];
    }
    now[len=2*len+1]='%';
    
    int pos=0,R=0;
    for(int i=1;i<=len;i++)
    {
        if(i<R) p[i]=min(p[2*pos-i],R-i);
        else p[i]=1;
        while(p[i]+i<=len && i-p[i]>=1 && now[i+p[i]]==now[i-p[i]]) p[i]++;
        if(p[i]+i>R)
        {
            pos=i;
            R=i+p[i];
        }
        if((p[i]-1)%2) cnt[p[i]-1]++;
    }
}

void solve()
{
    int sum=0;
    for(int i=n;i>=1;i--)
    {
        if(i%2==0) continue;
        sum+=cnt[i];
        if(k>=sum)
        {
            ans=(ans*poww(i,sum))%MOD;
            k-=sum;
        }
        else
        {
            ans=(ans*poww(i,k))%MOD;
            k-=sum; break;
        }
    }
    if(k>0) ans=-1; 
}

int main()
{
    scanf("%d%lld%s",&n,&k,s+1); len=n;
    Manacher(); solve();
    printf("%lld",ans); 
}
```

---

## 作者：ezoiHQM (赞：7)

先跑一次类似manacher的东西。因为只需要求奇数个的回文串，所以不需要再字符串中插入其他字符。

求完p数组以后用一个桶存下来，从小于n的最大奇数开始往下统计，统计完就好了。

注意：统计答案时不能一个一个乘，会tle，因为最后一个点k=1000,000,000,000,所以要用快速幂来优化。

代码：

```cpp
#include<cstdio>
long long quick_pow(long long x,long long n,int mod){
    long long ans=1;
    while(n){
        if(n&1)
            ans=(ans*x)%mod;
        x=(x*x)%mod;
        n>>=1;
    }
    return ans;
}
long long min(long long a,int b){
    return a<b?a:b;
}
const int mod=19930726;
char s[1000010];
int n,pos=-1,R=-1,p[1000010],vis[1000010],t[1000010];
long long k,ans=1;
int main(){
    freopen("test.in","r",stdin);
    freopen("test2.out","w",stdout);
    scanf("%d%lld%s",&n,&k,s+1);
    s[0]='$';
    for(int i=1;i<=n;i++){
        p[i]=i<R?min(p[(pos<<1)-i],R-i):1;
        while(s[i+p[i]]==s[i-p[i]])
            p[i]++;
        if(i+p[i]-1>R){
            pos=i;
            R=i+p[i]-1;
        }
        t[(p[i]-1)<<1|1]++;
    }
    int cnt=0;
    for(int i=n&1?n:n-1;i>=1;i-=2){
        cnt+=t[i];
        if(cnt>k){
            ans=ans*quick_pow(i,k,mod)%mod;
            break;
        }
        else{
            ans=ans*quick_pow(i,cnt,mod)%mod;
            k-=cnt;
        }
    }
    k>cnt?puts("-1"):printf("%lld",ans);
    return 0;
}
```

---

## 作者：hzoi_liuchang (赞：5)

### 分析
这一道题的大致意思就是让你求出一个字符串中所有的奇回文串，并把它们的长度连乘

考虑到求回文串，我们要使用$manacher$算法

因为题目中只让你求出奇回文串的个数，因此我们不用在原来的字符之间再插入特殊字符

在进行求解的时候，我们要使用一个$p[i]$数组记录以$i$为中心的最大回文半径的长度

而对于一个位置$i$，如果向两边扩展$p[i]$是一个回文串，那么向两边扩展$p[i]-k(p[i]-k\geq 1)$也是一个回文串

因此，我们就可以求出以$i$为中心的所有回文半径的长度

但是，如果我们使用$for$循环直接遍历，必定会超时

因此，我们可以使用差分数组解决这一个问题，即在$1$的位置加一，在$2 \times p[i] -1$的位置减一

最后$O(n)$扫一遍即可

还有要注意的一点是，在进行乘法的时候，因为$k$的范围很大，所以要使用快速幂

### 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
char s[maxn];
int p[maxn],k,len,cf[maxn];
const int mod=19930726;
int ksm(int ds,int zs){
    int ans=1;
    while(zs){
        if(zs&1) ans=ans*ds%mod;
        ds=ds*ds%mod;
        zs>>=1;
    }
    return ans;
}
signed main(){
    scanf("%lld%lld",&len,&k);
    scanf("%s",s+1);
    s[0]='$';
    for(int i=1,r=0,mids=0;i<=len;i++){
        if(i<=r) p[i]=min(p[2*mids-i],r-i+1);
        while(s[i-p[i]]==s[i+p[i]]) p[i]++;
        if(p[i]+i>r) r=p[i]+i-1,mids=i;
        cf[1]++,cf[p[i]*2]--;
    }
    for(int i=1;i<=len;i++){
        cf[i]=cf[i-1]+cf[i];
    }
    int mans=1,tot=len;
    if(tot%2==0) tot--;
    while(k>0 && tot>0){
        mans=mans*ksm(tot,min(cf[tot],k))%mod;
        k-=cf[tot];
        tot-=2;
    }
    if(k>0) printf("-1\n");
    else printf("%lld\n",mans);
    return 0;
}
```

---

## 作者：FREEH (赞：5)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/29049.png)

### 【解题思路】
- 考虑使用manacher。
- 先用manacher求出每一种长度的回文串的个数，要注意回文串的长度必须是奇数。
- 由于一个长度为n的回文串内必然存在长度为n-2、n-4……的回文串，因此回文串长度大的数量需要统计到长度小的里，所以考虑使用前缀和。
- 枚举回文串的长度为n~1的奇数，并统计前缀和。由于K很大，因此需要快速幂优化。并且统计扫描到了多少个回文串。
- 最后判断如果回文串个数小于K就输出-1。

### 【参考程序】
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long LL;
#define int LL
char st[2000005],s[2000005];
int p[2000005],cnt[2000005];
int n,k;
#define Mod 19930726
int change()
{
    int len=strlen(st);
    int j=2;
    s[0]='^';
    s[1]='$';
    for (int i=0;i<len;i++)
    {
        s[j++]=st[i];
        s[j++]='$';
    }
    s[j]='&';
    return j;
}
int Manacher()
{
    int len=change(),mid=1,mx=1,ans=-1;
    for (int i=1;i<len;i++)
    {
        if (i<mx)
            p[i]=min(mx-i,p[mid*2-i]);
        else
            p[i]=1;
        while (s[i-p[i]]==s[i+p[i]])
            p[i]++;
        if (mx<i+p[i])
        {
            mid=i;
            mx=i+p[i];
        }
        if ((p[i]-1)%2)
        	cnt[p[i]-1]++;
    }
    return ans;
}
int q_pow(int a,int b)//非递归写法的快速幂
{
	int sum;
	for (sum=1;b;b>>=1,a=a*a%Mod)
		if (b&1)
			sum=(sum*a)%Mod;
	return sum;
}
signed main()
{
	cin>>n>>k;
	scanf("%s",st);
	Manacher();
	int ans=1,sum=0;
	for (int i=n;i>=1;i--)
	{
		if (!(i%2)) continue;
		sum+=cnt[i];
		if (k>=sum)
		{
			ans=(ans*q_pow(i,sum))%Mod;
			k-=sum;
		}
		else
		{
			ans=(ans*q_pow(i,k))%Mod;
			k-=sum;
			break;
		}
	}
	if (k>0) printf("-1");else
	cout<<ans;
	return 0;
}
```

---

## 作者：disangan233 (赞：4)

## 题意简述

询问一个串中所有奇回文按照长度降序排列，前k个奇回文的长度乘积。

## 做法

回文自动机 (PAM) 模板题。

维护每个回文自动机的结点回文串出现次数，跳 fail 得到每个长度的出现次数，双关键字排序后用快速幂统计答案。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define re register int
#define db double
#define in inline
namespace fast_io
{
    char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0;
    in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
    in ll read()
    {
        ll x=0,y=1;while(nc=gc(),(nc<48||nc>57)&&nc!=-1)if(nc==45)y=-1;Bi=1;
        x=nc-48;while(nc=gc(),47<nc&&nc<58)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*y;
    }
    in db gf() {re a=read(),b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi):a);}
    in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
    in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
    in void flush() {if(C>1<<22) ot();}
    template <typename T>
    in void write(T x,char t)
    {
        re y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
        if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
    }
    in void write(char *s) {re l=strlen(s);for(re i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=2e5+5;
#define ls(x) ch[x][0]
#define rs(x) ch[x][1]
int n,m,ch[N][2];
char s[]
int main()
{
	n=read(),m=read();
}
const int N=1e6+5,mod=19930726;
int n,m,tot,ch[N][26],len[N],sum[N],fail[N],f[N],lst,q[N],h,t;
ll k,ans=1;
char s[N];
in int new_node(re x) 
{
	len[++tot]=x,fail[tot]=sum[tot]=0;
	ch[tot][0]=ch[tot][1]=ch[tot][2]=ch[tot][3]=0;
	return tot;
}
in void init() {tot=-1;new_node(0),new_node(-1);fail[0]=fail[1]=1;lst=0;}
in void ins(re c,re pos)
{
	re p=lst;
	while(s[pos-len[p]-1]!=s[pos]) p=fail[p];
	if(!ch[p][c])
	{
		re np=new_node(len[p]+2),q=fail[p];
		while(s[pos-len[q]-1]!=s[pos]) q=fail[q];
		fail[np]=ch[q][c];ch[p][c]=np;
	}
	sum[lst=ch[p][c]]++;
}
in ll qpow(ll x,re y) {ll z=1;for(;y;y>>=1,x=x*x%mod) if(y&1) z=z*x%mod;return z;}
int main()
{
	n=read(),k=read();gs(s+1);init();
	for(re i=1;i<=n;i++) ins(s[i]-'a',i);
	for(re i=tot;i;i--) sum[fail[i]]+=sum[i];
	vector<pair<int,int> >v;
	for(re i=2;i<=tot;i++) v.emplace_back(len[i],sum[i]);
	sort(v.begin(),v.end());reverse(v.begin(),v.end());
	for(auto x:v) if(x.first&1)
	{
		ll mi=min(k,(ll)x.second);k-=mi;
		ans=(ll)ans*qpow(x.first,mi)%mod;
		if(!k) break;
	}
	if(k) write("-1");else write(ans,'\n');
	return ot(),0;
}
//Author: disangan233
```

---

## 作者：GoPoux4 (赞：3)

这道题求回文串，很明显就是manacher吧。

### 但是

这道题冗长的**题目描述**中隐藏了一个**关键要素**：

 _如果连续的一段女生，有**奇数**个。_ 

于是：$AC->WA$ 。

---

既然回文串的长度必定是**奇数**个，那么Manacher算法中，就不用在每个字符之间插入无关字符了。

所以在原串上跑一遍Manacher，就完了噻。

还有一点要注意：**数据范围**中$k \leq 10^{12}$，显然一个一个累乘会超时，所以要用到快速幂。

${\sf Code:}$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define maxn 1000100
#define mod 19930726
#define lxl long long
using namespace std;

int n;
char s[maxn];
int lens;
lxl stack[maxn],k;
int RL[maxn];

inline lxl pw(int x,lxl a)
{
	if(x==0) return 0;
	if(x==1||a==0) return 1;
	if(a==1) return x%mod;
	if(a==2) return x*x%mod;
	lxl pww=pw(x,a/2);      //这里要预先得到数值，否则多次调用会超时
	if(a%2) return pww%mod*pww%mod*x%mod;
	else return pww%mod*pww%mod;
}

inline void Manacher()
{
	int pos=0,MaxRight=0;
	for(int i=0;i<lens;i++)
	{
		RL[i]=MaxRight>i?min(RL[2*pos-i],MaxRight-i):1;
		while(i+RL[i]<lens&&i-RL[i]>=0&&s[i+RL[i]]==s[i-RL[i]])//这里因为没有插入无关字符防止出界，所以要加判断
			RL[i]++;
		if(MaxRight<i+RL[i])
		{
			MaxRight=i+RL[i];
			pos=i;
		}
		stack[RL[i]]++;//stack计数以每一个字符为对称轴，出现相同的最长回文子串的半径的次数
	}
}

int main()
{
//	freopen("P1659.in","r",stdin);
	scanf("%d%lld\n",&n,&k);
	scanf("%s",s);
	lens=strlen(s);
	Manacher();
	lxl ans=1,sum=0;
	for(int i=(lens+1)/2;i>=1;i--)//(lens+1)/2为可能的最长回文子串的半径长度				
    		if(k>0)
		{
			sum+=stack[i];//sum累加，因为在一个最长回文子串中，对称轴相同的长度更小的子串都是回文子串
                                //所以长度为(i-1)<<1|1的回文子串的个数为stack[i]+...+stack[(lens+1)/2]
			ans=ans*pw((i-1)<<1|1,min(k,sum))%mod;
			k-=min(k,sum);
		}
	if(k>0) printf("-1");
	else printf("%lld",ans);
	return 0;
}

```


---

## 作者：Aisaka_Taiga (赞：2)

## 基本思路

既然是求解回文串的问题，首先可以考虑一下 manacher 算法。

我发现题解中有的是直接在原串上跑 manacher，这样可以直接过滤掉长度为偶数的回文串，如果是要在修改后的串上跑 manacher 的话，我们在统计答案的时候可以直接特判一下，把是以原串里的字符为中心的回文串最大长度给算上，这样在原串里也是长度为奇数的回文串了。

对于排序的问题，我们可以开一个桶 $t$ 数组来记录一下当前长度的回文串的数量，很容易发现，我们的 $p[i]$ 里面存放的是以 $i$ 为中心最大的回文半径，所以我们知道，像 `abcdedcba` 这种回文串，不仅只有这一个最长的，当去掉两头各一个字符时，就可以得到了另一个回文串 `bcdedcb`。

现在考虑如果处理以上的情况。如果是在往桶里面存放的时候用一个循环来一直减二修改的话，像一些以当前点为回文中心的字符串很长的情况就会 T 掉了，所以我们要用到类似于线段树的懒标记的方法，我们在将当前的回文串长度也就是 $p[i]-1$ 放入桶中的时候，先不要急着给后面的也放入，等到了查询的时候，当前的 $t[p[i]-1]$ 计算完了以后，我们再给 $t[p[i]-1-2]$ 加上 $t[p[i]-1]$ 的值，就相当于长度为 $p[i]-1$ 的回文串全都去掉了两头各一个字符，变为了 长度为 $p[i]-1-2$ 的回文串，这样可以使我们的复杂度大大降低，跑的也很快。

$k$ 的范围较大，要用快速幂，同时注意取模和判无解。

### code：

```cpp
#include<bits/stdc++.h>
#define int long long
#define P 19930726
#define N 1000010
using namespace std;
int n,k,p[N<<1],t[N<<1],cnt,maxn;
char s[N<<1];
inline int ksm(int x,int y)
{
	int sum=1;
	while(y)
	{
		if(y%2==1)
		  sum=(sum*x)%P;
		x=(x*x)%P;
		y=y>>1;
	}
	return sum%P;
}
signed main()
{
	cin>>n>>k;
	char c=getchar();
	s[cnt]='!';s[++cnt]='%';
	while(c<'a'||c>'z')c=getchar();
	while(c>='a'&&c<='z')s[++cnt]=c,s[++cnt]='%',c=getchar();
	s[cnt+1]='~';
	int j=0,mid=0;
	for(int i=1;i<=cnt;i++)
	{
		if(i<=j)p[i]=min(p[2*mid-i],j-i+1);
		while(s[i+p[i]]==s[i-p[i]])p[i]++;
		if(p[i]+i>j)j=p[i]+i-1,mid=i;
		if(s[i]!='%')
		{
			int xx=p[i]-1;
			t[xx]++;
			maxn=max(maxn,p[i]-1);
		}
	}
//	for(int i=1;i<=maxn;i++)
//	  cout<<t[i]<<" ";
//	cout<<endl;
	int ans=1,sum=0;
	for(int i=maxn;i>=1;i--)
	{
		if(sum+t[i]>k)
		{
			ans=(ans*ksm(i,k-sum)%P);
			sum+=t[i];
			break;
		}
		sum+=t[i];
		t[i-2]+=t[i];
		ans=(ans*ksm(i,t[i])%P);
	}
	if(sum<k)
	{
		cout<<"-1"<<endl;
		return 0;
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Forsaken2020 (赞：2)

没想到国家集训队也有水题吗，初看以为挺难的，然后发现一遍马拉车加一个后缀和就没了，后缀和就是你把后面出现的长度累加到前面去，就相当于给前面的奇数串做了贡献，然后跑快速幂就没了，然后为什么开到1e6会RE最后3个点啊，讲道理回文串的长度不也应该在1e6吗，陷入深思，开到2e6才过的。

```cpp
//author Eterna
#define Hello the_cruel_world!
#pragma GCC optimize(2)
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<string>
#include<cstring>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<utility>
#include<cmath>
#include<climits>
#include<deque>
#include<functional>
#include<numeric>
#define ABS(x) ((x) >= 0 ? (x) : (-(x)))
#define pb(x) push_back(x)
#define lowbit(x) ((x) & (-(x)))
#define FRIN freopen("C:\\Users\\Administrator.MACHENI-KA32LTP\\Desktop\\in.txt", "r", stdin)
#define FROUT freopen("C:\\Users\\Administrator.MACHENI-KA32LTP\\Desktop\\out.txt", "w", stdout)
#define FAST ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define outd(x) printf("%d\n", x)
#define outld(x) printf("%lld\n", x)
#define memset0(arr) memset(arr, 0, sizeof(arr))
#define il inline
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> pii;
const int maxn = 2e6;
const int INF = 0x7fffffff;
const int mod = 19930726;
const double eps = 1e-7;
const double Pi = acos(-1.0);
inline int read_int() {
	char c;
	int ret = 0, sgn = 1;
	do { c = getchar(); } while ((c < '0' || c > '9') && c != '-');
	if (c == '-') sgn = -1; else ret = c - '0';
	while ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');
	return sgn * ret;
}
inline ll read_ll() {
	char c;
	ll ret = 0, sgn = 1;
	do { c = getchar(); } while ((c < '0' || c > '9') && c != '-');
	if (c == '-') sgn = -1; else ret = c - '0';
	while ((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + (c - '0');
	return sgn * ret;
}
char p[maxn + 5], s[2 * maxn + 5];
int len[2 * maxn + 5];
vector<int> v;
int n, m;
ll res = 1, k, sum[maxn + 5];
void manacher() {
	s[0] = '@';
	for (int i = 1; i <= 2 * m; i += 2)s[i] = '#', s[i + 1] = p[i / 2];
	s[2 * m + 1] = '#';
	n = 2 * m + 1;
	int max_len = 0, id = 0;
	for (int i = 1; i <= n; ++i) {
		if (max_len > i)len[i] = min(max_len - i, len[2 * id - i]);
		else len[i] = 1;
		while (s[i + len[i]] == s[i - len[i]])++len[i];
		if (i + len[i] > max_len)max_len = i + len[i], id = i;
	}
}
il ll quick_pow(ll base, ll index) {
	ll res = 1;
	while (index) {
		if (index & 1)res = base * res % mod;
		base = base * base % mod;
		index >>= 1;
	}
	return res;
}
int main()
{
	m = read_int(), k = read_ll();
	scanf("%s", p);
	manacher();
	for (int i = 1; i <= n; ++i)if (s[i] != '#')v.push_back(len[i] - 1);
	sort(v.begin(), v.end());
	for (int i = 0; i < v.size(); ++i)sum[v[i]]++;
	for (int i = n - 1; i > 0; --i)sum[i] += sum[i + 1];
	for (int i = n; i > 0; --i) {
		if (i & 1) {
			ll p = min(sum[i], k);
			res = res * quick_pow(i, p) % mod;
			k -= p;
		}
		if (k == 0)break;
	}
	if (k == 0)outld(res);
	else outd(-1);
	//system("pause");
	return 0;
}
```


---

## 作者：_Fontainebleau_ (赞：1)

这道题很显然是一道 manacher .

做法其他大佬都已经解释的很清楚了。大概就是先跑正常一遍 manacher ,然后开一个桶 $cnt_i$ 记录 长度为 $i$ （ $i$ 为奇数）的最长回文串的中心点的数量。最后倒序遍历桶，用快速幂算。

先放代码
```cpp
#include<bits/stdc++.h>
#define mod 19930726
using namespace std;
long long n,k,len,ans=1;
int p[3000005],cnt[1000005];
char s[3000005],S[3000005];
inline long long read()
{
	long long x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
inline long long f(long long x,long long y)
{
	if(!y)	return 1;
	if(x==1)	return 1;
	long long base=1,p=x;
	while(y)
	{
		if(y&1)	base=(base*p)%mod;
		p=(p*p)%mod;
		y>>=1;
	}
	return base;
}
inline void change()
{
	S[0]='#',S[1]='#';
	for(int i=0;i<len;i++)
		S[(i<<1)+2]=s[i],S[(i<<1)+3]='#';
	len=(len<<1)+2;
	S[len]=0;
}
inline void manacher()
{
	int mx=0,mid;
	for(int i=1;i<len;i++)
	{
		if(i>mx)	p[i]=1;
		else	p[i]=min(mx-i,p[(mid<<1)-i]);
		while(S[i-p[i]]==S[i+p[i]])	p[i]++;
		if(i+p[i]>mx)	mx=i+p[i],mid=i;
		if((p[i]-1)&1)	cnt[p[i]-1]++;
	}
}
int main()
{
	n=read(),k=read();
	len=n;
	cin>>s;
	change();
	manacher();
	int sum=0;
	for(int i=n;i>=1;i--)
	{
		if(!(i&1))	continue;
		sum+=cnt[i];
		if(sum>k)
		{
			ans=(ans*f(i,k))%mod;
			k-=sum;
			break;
		}
		if(k>=sum)
		{
			ans=(ans*f(i,sum))%mod;
			k-=sum;
		}
	}
	if(k>0)	puts("-1");
	else
		printf("%lld\n",ans);
	return 0;
}

```


对我来说，可能就有一点稍微难以理解。就是为什么第 67 行是 `ans=(ans*f(i,sum))%mod;` 因为 $sum$ 表示长度大于等于 $i$ 的最长回文串的个数。而每个长度大于等于 $i$ 的回文串，都一定会有一个长度为 $i$ 的回文串。

That's all,thanks.

希望你可以早日掌握 manacher !

---

## 作者：7KByte (赞：1)

$Manacher+\text{递推}+\text{快速幂}$  


第一步，利用$Manacher$算法求出$p_i$，即以$i$为中心的最长回文子串的半径长度  

第二步，将半径长度转化为实际长度，即$p_i=2*p_i-1$

第三步，扫描一遍$p$数组，得出$f$数组，$f_i$表示在$p$数组中$i$出现的次数  

第四步，递推，从$n$到$1$进行倒推，得出$t$数组，$t_i$表示在整个串中长度为$i$的回文子串的数量，$t_i=f_i+f_{i+2}+...+f_{n\ or\ n-1}$，**再次强调要倒着推，这样我们可以将式子优化为$t_i=f_i+t_{i+2}$**  

第五步，在$t$数组中从大到小按照题意统计答案，不能一个个乘，要使用快速幂优化  

第六步，上代码  

```cpp
#include<bits/stdc++.h>
#define mod 19930726
typedef long long ll;
using namespace std;
int n;ll k;char a[1000005];
int mx=0,mid=0,ml[1000005];
ll f[1000005],ans=1;
int Pow(int x,ll y){
	ll sum=1,t=x;
	while(y){
		if(y&1)sum*=t,sum%=mod;
		t=t*t%mod;y>>=1;
	}
	return sum;
}
int main()
{
	scanf("%d%lld",&n,&k);
	scanf("%s",a+1);a[0]='#';
	for(int i=1;i<=n;i++){
		if(i>mx){
			mid=i;int p=1;
			while(a[i+p]==a[i-p])p++;
			mx=i+p-1;ml[i]=p;
			continue;
		}
		int l=mid-(i-mid),s=mid-(mx-mid);
		int to=l-ml[l]+1;
		if(to<s)ml[i]=mx-i+1;
		else if(to>s)ml[i]=ml[l];
		else{
			mid=i;
			int p=ml[l];
			while(a[i+p]==a[i-p])p++;
			mx=i+p-1;ml[i]=p;
		}
	}
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;i++)
		f[ml[i]*2-1]++;
	for(int i=n;i>=1;i--)
	    f[i]+=f[i+2];
	int st=(n&1?n:n-1);
	while(k&&st>0){
		if(f[st]>=k){
			ans*=Pow(st,k);
			k=0;ans%=mod;
		}
		else{
			ans*=Pow(st,f[st]);
			ans%=mod;k-=f[st];
		}
		st-=2;
	}
	printf("%d\n",k?-1:ans);
	return 0;
}
```

---

## 作者：hyfhaha (赞：0)

一眼可得PAM

如果没学过**PAM**的可以看这里：[PAM学习小结](https://www.cnblogs.com/hyfhaha/p/13654308.html) 

我们令**PAM**上多记录一个信息$sum$，表示该节点表示串在原串上出现了多少次。

当我们处理完了$sum$，对于长度$len$为奇数的节点的信息$sum$计入数组$a[i]$.

$a[i]$为长度为$i$的回文子串出现次数。

$a[i]$降序排序后累加答案快速幂处理一下即可，不需太多点拨

重点来了

讲一下怎么处理$sum$ 

我们可以发现当一个节点$u$的$sum+1$，那么$fail[u]$的$sum$也要$+1$ 

熟悉**AC自动机**的OIer可以敏锐的察觉到可以用拓扑排序了（例如我

建**PAM**的时候打个标记，最后统一一个拓扑排序向$fail$去更新$sum$即可

```cpp
queue<int >q;		//in数组为fail入边数量
void tuopu(){
	for(int i=0;i<=tot;i++)if(in[i]==0)q.push(i);
	while(!q.empty()){
		int u=q.front();q.pop();
		sum[fail[u]]+=sum[u];in[fail[u]]--;
		if(in[fail[u]]==0)q.push(fail[u]);
	}
}
```

好像没什么问题，多一个拓扑排序就行了

但真的如此吗？

我们观察**PAM**和**AC自动机**的区别

**AC自动机**是建好$Trie$后再进行$getFail$的，$fail$的节点编号是会大于自身节点编号

而**PAM**不会出现这种情况，**PAM**$fail$定义不同于**AC自动机**，构建使用增量法，保证了$fail$的节点编号一定小于自身节点编号。

所以就可以不用拓扑排序了，直接一个$for$从后到前更新即可

```cpp
for(int i=tot;i>=0;i--)sum[fail[i]]+=sum[i];
```

总代码：

```cpp
#include<bits/stdc++.h>
#define maxn 1010001
#define ll long long
#define mod 19930726
using namespace std;
char s[maxn];
int fail[maxn],len[maxn],trie[maxn][26],trans[maxn];
long long sum[maxn];
int per,slen,tot;
long long a[maxn],K,ans=1;
int getfail(int x,int i){
	while(i-len[x]-1<0||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
int gettrans(int x,int i){
	while(((len[x]+2)<<1)>len[tot]||s[i-len[x]-1]!=s[i])x=fail[x];
	return x;
}
void insert(int u,int i){
	int Fail=getfail(per,i);
	if(!trie[Fail][u]){
		len[++tot]=len[Fail]+2;
		fail[tot]=trie[getfail(fail[Fail],i)][u];
		trie[Fail][u]=tot;
		if(len[tot]<=2)trans[tot]=fail[tot];
		else{
			int Trans=gettrans(trans[Fail],i);
			trans[tot]=trie[Trans][u];
		}
	}
	per=trie[Fail][u];
	sum[per]++;		//记录sum
}
ll qpow(ll n,ll m){
	ll ans=1ll;
	while(m){
		if(m&1){ans=ans*n;ans%=mod;}
		n=n*n;n%=mod;m>>=1;
	}return ans%mod;
}
int main(){
	scanf("%d%lld",&slen,&K);
	scanf("%s",s);
	fail[0]=1;len[1]=-1;tot=1;
	for(int i=0;i<slen;i++)insert(s[i]-'a',i);
	for(int i=tot;i>=1;i--)sum[fail[i]]+=sum[i];		//更新sum
	for(int i=2;i<=tot;i++)a[len[i]]+=sum[i],a[len[i]]%=mod;	//长度处理
	for(int i=slen;i>=1;i--){			//答案处理
		if(i%2==1){
			if(K>=a[i]){
				ans*=qpow(i,a[i]);ans%=mod;
				K-=a[i];
			}else{
				ans*=qpow(i,K);ans%=mod;
				K-=K;
				break;
			}
		}
	}
	if(K==0)			//判-1
	printf("%lld\n",ans%mod);
	else
	printf("-1\n");
	return 0;
}
```



---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P1659)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然标签里面写的是$Manacher$。我偏要用回文自动机。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先把回文自动机建起来。对于一个节点$u$，算出它在原串中出现的次数，记为$ed(u)$。然后考虑用一个$cnt(i)$表示长度为$i$的回文串的出现**个数**。不难发现如下的东西：  
$$cnt(i)=\sum_{u}ed(u)[len(u)=i]$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后从大到小枚举长度，像平衡树一样，构造出前$K$个串的长度的积。时间$O(n\log_2n)$（$\log_2n$是从快速幂里面来的）。  
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int mod = 19930726;
const int MAXN = 1000005;

template<typename _T>
void read( _T &x )
{
	x = 0; char s = getchar();int f = 1;
	while( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ) { putchar( '-' ), x = -x; }
	if( 9 < x ) { write( x / 10 ); }
	putchar( x % 10 + '0' );
}

LL cnt[MAXN];
int dep[MAXN], appcnt[MAXN];
int ch[MAXN][26], fa[MAXN], len[MAXN];
char S[MAXN];
LL K;
int N, lst, siz;

void build()
{
	int p, x, cur;
	N = strlen( S + 1 );
	fa[0] = ++ siz, len[1] = -1;
	for( int i = 1 ; i <= N ; i ++ )
	{
		x = S[i] - 'a';
		while( S[i] ^ S[i - len[lst] - 1] ) lst = fa[lst];
		if( ! ch[lst][x] )
		{
			cur = ++ siz, p = fa[lst]; len[cur] = len[lst] + 2, dep[cur] = dep[lst] + 1;
			while( S[i] ^ S[i - len[p] - 1] ) p = fa[p];
			fa[cur] = ch[p][x], ch[lst][x] = cur;
		}
		lst = ch[lst][x], appcnt[lst] ++;
	}
}

int qkpow( int base, int indx )
{
	int res = 1;
	while( indx )
	{
		if( indx & 1 ) res = 1ll * res * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return res;
}

int main()
{
	read( N ), read( K );
	scanf( "%s", S + 1 ); 
	build();
	for( int i = siz ; i > 1 ; i -- ) 
		if( fa[i] > 1 ) appcnt[fa[i]] += appcnt[i];
	for( int i = 2 ; i <= siz ; i ++ ) 
		if( len[i] & 1 ) cnt[len[i]] += appcnt[i];
	int res = 1;
	for( int i = N ; i ; i -- )
		if( i & 1 )
		{
			if( K > cnt[i] ) K -= cnt[i], res = 1ll * res * qkpow( i, cnt[i] ) % mod;
			else { res = 1ll * res * qkpow( i, K ) % mod, K = 0; break; }
		}
	if( K > 0 ) res = -1;
	write( res ), putchar( '\n' );
	return 0;
}
```

---


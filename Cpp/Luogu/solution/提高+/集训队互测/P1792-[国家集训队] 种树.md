# [国家集训队] 种树

## 题目描述

A城市有一个巨大的圆形广场，为了绿化环境和净化空气，市政府决定沿圆形广场外圈种一圈树。

园林部门得到指令后，初步规划出 $n$ 个种树的位置，顺时针编号 $1$ 到 $n$。并且每个位置都有一个美观度 $A_i$，如果在这里种树就可以得到这 $A_i$ 的美观度。但由于 $A$ 城市土壤肥力欠佳，两棵树决不能种在相邻的位置（$i$ 号位置和 $i+1$ 号位置叫相邻位置。值得注意的是 $1$ 号和 $n$ 号也算相邻位置）。

最终市政府给园林部门提供了 $m$ 棵树苗并要求全部种上，请你帮忙设计种树方案使得美观度总和最大。如果无法将 $m$ 棵树苗全部种上，给出无解信息。


## 说明/提示

数据编号|$n$ 的大小|数据编号| $n$ 的大小
-|-|-|-
$1$|$30$|$11$|$200$
$2$|$35$|$12$|$2007$
$3$|$40$|$13$|$2008$
$4$|$45$|$14$|$2009$
$5$|$50$|$15$|$2010$
$6$|$55$|$16$|$2011$
$7$|$60$|$17$|$2012$
$8$|$65$|$18$|$199999$
$9$|$200$|$19$|$199999$
$10$|$200$|$20$|$200000$

对于全部数据：$m\le n$，$-1000\le A_i\le1000$。

## 样例 #1

### 输入

```
7 3
1 2 3 4 5 6 7```

### 输出

```
15```

## 样例 #2

### 输入

```
7 4
1 2 3 4 5 6 7
```

### 输出

```
Error!```

# 题解

## 作者：3493441984zz (赞：106)

# 贪心$+$双向链表

思路真的很神奇，我做过了这种题目但是看的第一眼还是想不到这种办法，太弱惹呜呜呜


------------
# 最开始的思路：

虽然最近做过这种贪心题，但是苦思冥想后还是做不出，于是重新看一遍题目呀，发现，这不是一道$dp$吗，小菜吧，于是我兴高采烈的看了一下数据范围，$QAQ$，我这种蒟蒻写的$dp$肯定会爆空间，于是使用秘术：看题解$qwq$



------------
# 思路：

看完题解后，其实讲的有点模糊，所以来写一篇题解，希望能讲清

在这里先膜拜一下题解里的$dalao$，这种思路都想得出

那么**言归正传**

### 我们先观察这一道题，要求最大值，那么我们先来看一种**错误**的做法(**注意是错误的**)：

先用优先队列处理每个点（大根堆）

我们对于每一次种树，取美观度最大值种树，然后标记两旁访问过，访问过的地方就不种树

那么可能一开始都这么想~~（可能并不是）~~，然而这种做法错在哪里呢：

假如是这种情况（$4$个点中取$2$个）：

![](https://i.loli.net/2019/02/15/5c6615f95097d.png)

我们按照上面的做法取的话，会是下图的结果

![](https://i.loli.net/2019/02/15/5c6616cb074df.png)

### 那么我们发现了一个问题:

我们取最大值的时候，可能取两边的会比取中间的更优！

### 那么为了处理这个问题，我们可以这样做：

一开始对于每个点建立双向链表

当前取了这个点后，把它出优先队列的同时，再加入一个点，这个点的权值是左边点权$+$右边点权$-$当前点权，例如上图：

当我们取了$9$后，我们应该加一个点，点权为$8+8-9=7$，并且把双向链表更新，$9$的左边变为$8$的左边$1$，右边同理

### 为什么这样弄呢？为什么这样就能解决上面的问题呢？

其实我们这样做是添加了一个反悔机制，我们来模拟一下上图：

当我们把$7$入队列，$9$出队列后，图就变成下图了：

![](https://i.loli.net/2019/02/15/5c66191903662.png)

那么由于是优先队列，下一个出来的是$8$，但是$8$被访问过了，（在$9$出队列的时候，左右都标记为访问了），那么直接退出，下一个出队列的是$8$，也被访问过了，退出，下一个出队列的是$7$，没被访问，更新$ans$，并且把左右两边置为访问过，也就是下图：

![](https://i.loli.net/2019/02/15/5c6619e9aee3d.png)

由于取了两次了，退出，那么最后的答案就是$16$也就是$9+7$，但是我们发现$16$也等于$8+8$，那么这整个过程其实就相当于我们取了$8,8$,因为我们一开始取了$9$，然后取了$7$，但是$7$是怎么来的呢，就是$8+8-9$来的，那么$9+7$就可以化为$9+8+8-9$，也就是$8+8$,所以你看懂这个反悔机制了吗


------------
下面是美滋滋的代码时间~~~

~~~cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define N 200007
using namespace std;
struct Place
{
	int val,l,r;
	
}p[N];
struct Node
{
	int val,id;
	bool operator <(Node it) const
	{
		return val<it.val;
	} 
};
int n,m,ans;
bool vis[N];
priority_queue<Node> q;
void Del(int x)
{
	p[x].l=p[p[x].l].l;
	p[x].r=p[p[x].r].r;
	p[p[x].l].r=x;
	p[p[x].r].l=x;
}
int main()
{
	scanf("%d%d",&n,&m);
	if(n<m*2)
	{
		printf("Error!");
		return 0;
	}
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&p[i].val);
		p[i].l=i-1;
		p[i].r=i+1;
		q.push((Node){p[i].val,i});
	}
	p[1].l=n,p[n].r=1;
	for(int i=1;i<=m;++i)
	{
		while(vis[q.top().id])
			q.pop();
		Node now=q.top();
		q.pop();
		ans+=now.val;
		vis[p[now.id].l]=vis[p[now.id].r]=1;
		p[now.id].val=p[p[now.id].l].val+p[p[now.id].r].val-p[now.id].val;
		q.push((Node){p[now.id].val,now.id});
		Del(now.id);
	}
		
	printf("%d",ans);
	return 0;
}
~~~


---

## 作者：beretty (赞：34)

#### ~~诶，没人发题解吗~~
~~这道题好像和编译优化是重题。。~~

刚看到这题第一反应是DP。。然而瞅了一眼数据范围（emm,200000），这要是DP空间炸飞啊。。

###### 于是。。于是就又深入思考  ~~看了一个dalao的blog~~
发现是一个贪心。。思路非常神奇。。

就是以在每个坑种树的收益建一个大根堆

然后用链表存它的前驱后继（n的后继为1,1的前驱为n）

每次取最大的收益。

那么问题来了————有可能在这个点种树比在它两边各种一棵树收益小。

但一定是两边各种一棵，因为我们建的是大根堆，先出来的一定大。

所以我们可以选这个坑种树，也可以选两边的坑各种一棵，所以我们给我们的贪心一个反悔的机会

就是选在这个坑种树以后将它两边的坑合并为一个价值为（w[l]+w[r]-w[now]）的坑，代替我们选择的坑

这里非常的巧妙，就是如果选了这个坑就相当于不在那个中间的坑种树了，而是在它两边各种一棵。

然后放一下丑陋的代码

```
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<queue>
# define M (200000+50)
using namespace std;
struct node{
    int value,place;
    friend bool operator < (node x,node y){
        return x.value < y.value;
    }
};
priority_queue<node> q;
int n,m,Ans,chose,nxt[M],pre[M],w[M],l,r;
bool vis[M];
void change(int x){
	vis[x]=1;
	nxt[pre[x]]=nxt[x];
	pre[nxt[x]]=pre[x];
	nxt[x]=0; pre[x]=0;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)  {
	  scanf("%d",&w[i]);
	}
	if((n>>1)<m){
    	cout<<"Error!"<<endl;
    	return 0;
	}
    for(int i=1;i<n;i++) nxt[i]=i+1; nxt[n]=1;
    for(int i=2;i<=n;i++) pre[i]=i-1; pre[1]=n;
    for(int i=1;i<=n;i++) q.push((node){w[i],i});
    for(int i=1;i<=m;i++){
    	while(vis[q.top().place]) q.pop() ;
    	node temp = q.top(); q.pop();
    	Ans+= temp.value;
    	l=pre[temp.place];   r=nxt[temp.place];
    	w[temp.place]=w[l]+w[r]-w[temp.place];
    	change(l);    change(r);
    	q.push((node){w[temp.place],temp.place});
	}
	printf("%d\n",Ans);
	return 0;
}
```

---

## 作者：皎月半洒花 (赞：27)

这里给出一种(虽然很简单但是没人写题解的)wqs二分的方法。

首先由于 $m$ 的限制，加上权值会有负数所以多选和少选都有可能导致结果不优，所以很容易想到要去wqs二分。二分之后就变成了求解没有 $m$ 的限制的最大值问题。自然的想法是考虑 $f_i$ 表示前 $i$ 个坑种树的最大收益，那么转移就是考虑第 $i$ 个坑种不种，即 $f_i=\max\{f_{i-1},f_{i-2}+val_i\} $ 。

但是这个地方存在一个问题，就是第 $n$ 个和第 $1$ 个之间可能存在不合法。于是就理所应当地再记一维 $0/1$ 表示第 $1$ 个坑到底种不种树，转移到 $n$ 的时候特判一下。 这样就可以解决了。

有关边界的问题可以去看我的CF958E2的题解，这里就不再赘述了。

```cpp
ll res ;
int m, n ;
int df[N] ;
ll f[N][2] ;
int base[N] ;
int cnt[N][2] ;

bool check(int x){
	f[1][0] = 0 ; cnt[1][0] = 0 ;
	f[1][1] = base[1] + x, cnt[1][1] = 1 ;
	for (int i = 2 ; i < n ; ++ i){
		if (f[i - 1][0] > f[i - 2][0] + x + base[i])
			f[i][0] = f[i - 1][0], cnt[i][0] = cnt[i - 1][0] ;
		else if (f[i - 1][0] < f[i - 2][0] + x + base[i]) 
			f[i][0] = f[i - 2][0] + x + base[i], cnt[i][0] = cnt[i - 2][0] + 1 ;
		else 
			f[i][0] = f[i - 1][0], cnt[i][0] = max(cnt[i - 1][0], cnt[i - 2][0] + 1) ;

		if (f[i - 1][1] > f[i - 2][1] + x + base[i])
			f[i][1] = f[i - 1][1], cnt[i][1] = cnt[i - 1][1] ;
		else if (f[i - 1][1] < f[i - 2][1] + x + base[i]) 
			f[i][1] = f[i - 2][1] + x + base[i], cnt[i][1] = cnt[i - 2][1] + 1 ;
		else 
			f[i][1] = f[i - 1][1], cnt[i][1] = max(cnt[i - 1][1], cnt[i - 2][1] + 1) ;
	}
	f[n][1] = f[n - 1][1] ; 
	cnt[n][1] = cnt[n - 1][1] ;
	if (f[n - 1][0] > f[n - 2][0] + x + base[n])
		f[n][0] = f[n - 1][0], cnt[n][0] = cnt[n - 1][0] ;
	else if (f[n - 1][0] < f[n - 2][0] + x + base[n]) 
		f[n][0] = f[n - 2][0] + x + base[n], cnt[n][0] = cnt[n - 2][0] + 1 ;
	else 			
		f[n][0] = f[n - 1][0], cnt[n][0] = max(cnt[n - 1][0], cnt[n - 2][0] + 1) ;
	if (f[n][0] > f[n][1]){
		res = f[n][0] - (ll)x * m ; 
		return (bool)(cnt[n][0] >= m) ;
	}
	else{
		res = f[n][1] - (ll)x * m ; 
		return (bool)(cnt[n][1] >= m) ;
	}
}
int main(){
	cin >> n >> m ; 
	for (int i = 1 ; i <= n ; ++ i) 
		scanf("%d", &base[i]) ; 
	if (m > n / 2) return puts("Error!"), 0 ;
	int l = -2e9, r = 2e9, mid, ans ; 
	while (l <= r){
		mid = (l + r) >> 1 ; 
//		cout << l << " " << r << endl ; 
		if (check(mid)) ans = mid, r = mid - 1 ;
		else l = mid + 1 ;
	}	
	check(ans) ; cout << res << endl ; return 0 ;
}
```





---

## 作者：MarshMalloW_ (赞：27)

**这是蒟蒻我写的第二篇题解（~~当然第一篇没过...~~）**

**欠缺处望指正 谢谢...**


------------

# **高能时间**

 ~~真相只有一个~~，此题的~~猪脚~~算法就是——

**贪心+双向链表+堆优化（优先队列）！**




------------

# **思路**：

## **错误的思路**

**好了回归正题**

先来讲一个**错误**的贪心思路（我一开始也这么想的，~~当然我不会说是大佬们的题解让我打消了这个念头...~~）：

每次从堆里取最大的美观度种树 然后标记一下它两旁的树都不种

当然，反例一抓一大把！举个栗子：

4 7 8 9四个美观度 种2棵树

错误的贪心是种4 9 然鹅**显然**7 8的组合更优啦！

所以我们得出一个结论！

那就是——（~~请不要卖关子了 会被打的...~~）

**要给我们的贪心反悔的机会！！！**




## **正题—— ~~这个世界其实有后悔药~~ 反悔的规则：**

所以先请我们的第二~~猪脚~~算法**双向链表**出场！（~~拜托普通话标准一点ok？~~）

我们可以先对于每棵树建立双向链表

比如说我们种了i这棵树 从堆取出i时把两边的树与这棵树（中间的树）合并

美观度就为两边的树的美观度之和减去中间的树的美观度 也就是$A[l]+A[r]-A[i]$（l和r是两边的树） 合并得的美观度丢进堆里

## **解释：**
为什么这种贪心是正确的呢？

那不妨假设选l和r比选i更好，那我们加上的是$A[l]+A[r]-A[i]$，于是我们发现$A[l]+A[r]-A[i]$中的 $-A[i]$ 与原来加上的$A[i]$抵消

也就是 $(A[l]+A[r]-A[i])+A[i]=A[l]+A[r]$

还可以这样理解：我们把i这棵树拔了 种上了l和r两棵树（~~好残忍...~~）

有的~~童鞋~~可能会问：那如果l和r没有i好呢？

我会~~认真~~的回答：那就和合并后的美观度没有关系，反正都不种...

所以这个贪心的正确性也就被证明了！

## **一个~~不重要~~的~~猪脚~~算法优化**
当然，暴力枚举最大的美观度当然是不可取的（不信你试试）

我前面其实也讲到了，使用**大根堆**就可以完美地解决这个问题啦！

~~当然我偷懒调用的优先队列~~

## **~~突然想起的~~无解情况**
此题的无解情况应该很好判，假设我们每隔一棵树种一棵树（也是题目所能允许的种的最多的树） 都无法种到m棵

也就是$n/2<m$

那么就输出"Error!"

------------
        
## **代码时间到——**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;bool vis[200005];
struct P{
	int val,l,r;
}p[200005];
struct node{
	int val,id;
	bool operator <(node it) const{return val<it.val;}
};
priority_queue<node> q;
void del(int x){
	p[x].l=p[p[x].l].l;
	p[x].r=p[p[x].r].r;
	p[p[x].l].r=x;
	p[p[x].r].l=x;
}
int main(){
	scanf("%d%d",&n,&m);
	if (n/2<m){printf("Error!");return 0;}
	for (int i=1;i<=n;i++){
		scanf("%d",&p[i].val);
		p[i].l=i-1,p[i].r=i+1;
		q.push((node){p[i].val,i});
	}
	p[1].l=n,p[n].r=1;
	for (int i=1;i<=m;i++){
		while (vis[q.top().id]) q.pop();
		node now=q.top();q.pop();
		vis[p[now.id].l]=vis[p[now.id].r]=1;
		p[now.id].val=p[p[now.id].l].val+p[p[now.id].r].val-p[now.id].val;
		q.push((node){p[now.id].val,now.id});
		ans+=now.val;del(now.id);
	}
	printf("%d\n",ans);
	return 0;
}
```

# **最后**
**各位大佬们点个赞支持一下嘛...**

**有疑问的也可以LG私信或评论区问我...**

---

## 作者：hwx12233 (赞：19)

# **退流策略**

退流就是一种可以反悔的东西

用优先队列维护一个从大到小的权值

选取堆顶$,ans+=a[i]$

然后，把前后趋删掉，再加入一个$a[i]=a[pre_i]+a[nxt_i]-a[i]$

这就完成了退流

如果新的$a[i]$又被选上了

说明$pre_i+nxt_i$更优

当再次选取这个点时

$ans+$上这个权值自动退掉了$a[i]$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;

typedef long long ll;
const int inf=0x3f3f3f3f;
const int N=200010;

inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x>y?y:x;}

int n,m,pre[N],nxt[N];bool vis[N];
struct node{
	int id,a;
	bool operator <(const node &x)const {return x.a>a;}
}a[N];
priority_queue<node>q;
inline int get(){
	while(1){
		node tmp=q.top();q.pop();
		if(!vis[tmp.id])
			return tmp.id;
	}
}
inline void del(int x){
	nxt[pre[x]]=nxt[x];
	pre[nxt[x]]=pre[x];
	vis[x]=1;
}
int main(){
	cin>>n>>m;
	if(m>n/2){
		cout<<"Error!";return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].a;a[i].id=i;
		q.push((node){i,a[i].a});
	}
	for(int i=2;i<=n-1;i++)
		pre[i]=i-1,nxt[i]=i+1;
	pre[1]=n,nxt[1]=2;pre[n]=n-1,nxt[n]=1;
	int ans=0;
	for(int i=1;i<=m;i++){
		int x=get();
		ans+=a[x].a;
		a[x].a=a[pre[x]].a+a[nxt[x]].a-a[x].a;
		q.push((node){x,a[x].a});
		del(pre[x]);del(nxt[x]);
	}
	cout<<ans;
}

```


---

## 作者：皇帝 (赞：12)

给出由n个数组成的环，取某个数就可以得到它的分数，相邻的两个数不能同时取。问取m个数可以得到的最大分数。

对于前8个数据，我们采用搜索方法可以解决，但搜索的效率直接决定得分。我想到的优化有两点：1排序、2剪枝。（很简单，不详细说，详见程序）

特别的，如果这个环上的点是偶数个，我们可以把此题转化为带权匹配。在环上两个数之间建点，点恰好有n个，可以黑白染色构成二分图。而把数当做边。在这个图做带权匹配就是最后结果了。（由于匹配中同一个点引出的两条边是不可能同时取到的，这正好符合了相邻两个数不能同时取的性质）

符合这个算法的数据有：1、3、5、7、9、10、11（O(n^4)）。如果带权匹配写的好（O(n^3)外加系数小），可以再过13、15、17三个点。

我们再考虑这个题的简单版：在一个长度为n的数列中，选m个数，两个相邻的数不能同时选，要求取数的和最大。（即把原题的环改为链）

如果我们选取的数的集合叫C。C一开始是空集，每一次取数操作就会让C集合中多一个数，直到够m个数为止。而每次取数时，如果要取的这个数x左边右边都没被取，那这个数就可以直接取走，x就是取这个数带来的价值；如果这个要取的数x的左边的数y（右边完全一样，这里略）已经被取走了，那y必定要放回去，而把y左边的数z取出来以保证本次操作能让C集合多一个数，若z的左边的数w也被取了，那我们再用w左边的数代替，总之我们进行了一个类似01翻转的操作，使C集合多了一个数。而我们取这个数使C集合的总和增加的量，就是取这个数能带来的价值。

我们可以证明：每次操作带来的价值，一定是单调递减的（挺显然的）。所以我们可以用贪心的方法，取够m个为止，并且保证算法是正确的。

接下来是考虑时间复杂度，暴力做是O(N^2)。我们也可以用线段树（或者堆）来维护这一操作，从而达到O(NLogN)的时间复杂度。

回到原问题环。直接用这个算法是行不通的，因为在环上，左边进行的01翻转和右边进行的01翻转可能会相遇！最后就会导致两个1相邻。

我们可以想到一个略暴力的方法：枚举每一个数，不要它！把这个数剔除后所形成的链，通过刚才的算法求出不取这个数的情况下的最优值。最后一定可以得到最优值。这样时间复杂度为O(N^2\*LogN)。

在这个算法的基础上，稍作优化，就可以得到一个很好的算法：我们考虑两个相邻的数和，分三种情况：和都取（题目不允许）、不取、不取（虽然后两者有重叠，但包含了所有情况）。也就是说，我们并不需要枚举每一个数不要它，只需要针对两个相邻的数和，比较不要的最优值更好还是不要的最优值更好就可以了。


【题目考点】贪心+双向链表+堆优化

【方法1】对于前4个数据，我们采用搜索方法可以解决，但搜索的效率直接决定得分。

【方法2】动态规划，设f[i][j][0]表示前i个位置选择j个种树且第i个位置没有种树,f[i][j][1]表示表示前i个位置选择j个种树且第i个位置必须种树，则转化为非常简单的O(n^2)动规，转台转移方程为：

f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);

f[i][j][1]=f[i][j-1][0];

【方法3】这个题标准解法是借鉴网络流中的残余流思想，用堆来维护解决。映射建大根堆，记录每一个数值在堆中的位置好方便删除操作。每回出堆顶元素后，a[k]=a[l[k]]+a[r[k]]-a[k],l[k]和r[k]是k的左边节点和右边节点，即双链表思想，再将a[l[k]]和a[r[k]]删除，将新的a[k]加入堆中。

```cpp
#include<iostream>
using namespace std;
int n,m;
int L[200001],R[200001];
int d[200001],pos[200001],a[200001];
void up(int x)
{  int i=x;
   while(i>1&&a[d[i]]>a[d[i/2]])
{
      swap(d[i],d[i/2]);
      swap(pos[d[i]],pos[d[i/2]]);
      i/=2;
   }
}
void down(int x)
{   int i=x,j;
    while(i*2<=n)
    {   if(i*2==n||a[d[i*2]]>a[d[i*2+1]])j=i*2;
          else j=i*2+1;
        if(a[d[i]]>a[d[j]])return;
        swap(d[i],d[j]);
        swap(pos[d[i]],pos[d[j]]);
        i=j;
    }
}
int main()
{   int i,j;
    cin>>n>>m;
    if(n/2<m){cout<<"Error!";return 0;}
    for(i=1;i<=n;i++)
    {  cin>>a[i];
       d[i]=i;pos[i]=i;up(i);
       L[i]=i-1;R[i]=i+1;
    }
    L[1]=n;R[n]=1;
    int ans=0;
    while(m--)
    {   int x=d[1];
        ans+=a[x];
        a[x]=a[L[x]]+a[R[x]]-a[x];
        a[L[x]]=-1111;down(pos[L[x]]);
        a[R[x]]=-1111;down(pos[R[x]]);
        down(1);
        L[x]=L[L[x]];
        R[x]=R[R[x]];
        R[L[x]]=x;
        L[R[x]]=x;
    }
    cout<<ans;
    //system("pause");
    return 0;
}
```

---

## 作者：llzzxx712 (赞：11)

# P1792题解

[传送门](https://www.luogu.com.cn/problem/P1792)

## 题意简述

给出一个 n 个有权值节点的环，选出 m 个不相邻的节点，使它们的权值和最大。

$ m<=n<=2*10^5$

## 题目分析

如果 m = 1，那么结果就是$a$数组中的最大值。

如果 m = 2，那么就有两种情况：

1. 选择最大值 $a_i$ ，不选 $a_{i-1} ,a_{i+1} $ ，再从剩下的数中选择最大值。
1. 不选最大值 $a_i$ ，选 $a_{i-1} ,a_{i+1} $ 。

为什么不选最大值 $a_i$ 就要选 $a_{i-1} ,a_{i+1} $ 呢？

如果只选了 $a_{i-1} ,a_{i+1} $ 中的一个，那么把选了的换成了 $a_i$ 一定更优。

显然$a_i , a_{i-1} ,a_{i+1} $都不选不是最优解。

**所以最大值左右两侧的数要么都选，要么都不选。**

所以我们可以先选上 $a$ 数组中的最大值（第一种情况），然后将然后将 $a_{i-1},a_i,a_{i+1}$ 从数列中删除，并在原位置插入一个新元素$a_{i-1}-a_i+a_{i+1}$ 。这样原问题就变成了一个从 $a$数组中选 $m-1$ 的数的子问题，显然重复这个操作 $m-1$次就可以求出最终结果。

## 代码实现思路

所以我们可以建立一个链表 Q，分别记录$a_1,a_2,a_3 … a_{N-1}$ 。 再建立一个二元组大根堆，每个元素与链表中的每一个元素成一一映射关系，第二元记录对应链表中的指针。

每次取出堆顶，更新答案。再删除节点（链表中打标记、更新左右节点数组，大根堆中删除）、插入新节点。

执行$m$次后输出。

## 易错点
- 要先判断 n 是否小于 $m*2$  
- 这是一个环，要先处理首尾。
- 记得开 long long 。

## AC代码

内带详细注释

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#define N 500002
using namespace std;
void read(long long &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
long long a[N],le[N],r[N],ans;
bool v[N];
priority_queue < pair < int , int > > q;
void del(int x){//删除操作 
	le[r[x]]=le[x];
	r[le[x]]=r[x];
	v[x]=1;//该点是否被删除 
}
int main(){
	int n,m;
	cin>>n>>m;
	le[1]=n;r[1]=2;le[n]=n-1;r[n]=1;//处理首尾 
	for(int i=1;i<=n;i++){//读入 
		read(a[i]);
	}
	if(n<m*2){//判断 
		printf("Error!");
		return 0;
	}
	for(int i=2;i<n;i++) le[i]=i-1,r[i]=i+1;//建立链表 
	for(int i=1;i<=n;i++){
		q.push(make_pair(a[i],i));//第一元为值，第二元为标号 
	}
	while(m--){
		int x,y;
		while(v[q.top().second]) q.pop();//忽略删除的节点
		y=q.top().second;q.pop();//取出最大节点 
		ans+=a[y];//更新答案 
		a[y]=a[le[y]]+a[r[y]]-a[y];//新节点 
		del(le[y]);del(r[y]);//删除左右节点 
		q.push(make_pair(a[y],y)); 
	}
	printf("%d",ans);
}	
```







---

## 作者：Richard_Whr (赞：6)

首先可以容易的写出一个背包，设 $f_{i,j,0/1}$ 表示 $i$ 选不选，选出 $j$ 个的最大价值。

然后可以比较容易的转移。

众所周知，这玩意可以用费用流模型证出来凸性。

然后对于凸性背包 DP，可以采用序列分治 +  闵和合并背包的方式。

流程大概是：

我们发现分治后合并还有限制是交接处不能同时选。

因此设状态 $F_{l,r,0/1,0/1}$ 表示 $[l,r]$ 的背包，左右端点有没有选。

- 分治做出左右儿子的背包，对于叶子的初始化是简单的
- 然后合并两个凸性背包相当于对两个背包的差分数组做归并排序。

然后就没了，这个做法可以做出 $m \in [1,n]$ 的所有答案，且是单 $\log$ 的。

代码实现常数非常大，如果有高人可以给出常数更小更好写的代码，希望私信指教我。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,Inf=1e8;
typedef vector<int> Vec;
Vec F[N*2][2][2];
int w[N];
int idx;
int n,m;

Vec Max(Vec A,Vec B)
{
	if(!A.size()) return B;
	if(!B.size()) return A;
	Vec res;
	res.resize(max(A.size(),B.size()));
	for(int i=1;i<A.size();i++) A[i]+=A[i-1];
	for(int i=1;i<B.size();i++) B[i]+=B[i-1];
	for(int i=0;i<res.size();i++)
	{
		res[i]=-Inf;
		if(i<A.size()) res[i]=max(res[i],A[i]);
		if(i<B.size()) res[i]=max(res[i],B[i]);
	} 
	for(int i=res.size()-1;i>=1;i--) res[i]=res[i]-res[i-1];
	return res;
}

Vec merge(Vec A,Vec B)
{
	vector<int> res;
	res.resize(A.size()+B.size());
	merge(A.begin(),A.end(),B.begin(),B.end(),res.begin(),greater<int>());
	return res;
}

int solve(int l,int r)
{
	int u=++idx;
	if(l==r)
	{
		F[u][1][1].push_back(w[l]);
		return u;
	}
	int mid=l+r>>1;
	int ls=solve(l,mid),rs=solve(mid+1,r);
	for(int a=0;a<2;a++)
	{
		for(int b=0;b<2;b++)
		{
			for(int c=0;c<2;c++)
			{
				for(int d=0;c+d<2;d++)
				{
					F[u][a][b]=Max(F[u][a][b],merge(F[ls][a][c],F[rs][d][b]));
				}
			}
		}
	}
	return u;
}


signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>w[i];
	
	int rt=solve(1,n);
	vector<int> res;
	
	for(int a=0;a<2;a++)
	{
		for(int b=0;a+b<2;b++)
		{
			res=Max(res,F[rt][a][b]);
		}
	}
	
	for(int i=1;i<res.size();i++) res[i]+=res[i-1];
	
	int ans=0;
	if(res.size()<m) cout<<"Error!\n",exit(0);
	cout<<res[m-1]<<"\n";
	
	
	return 0;
}
```

---

## 作者：Kuriyama_Mirai (赞：4)

其实这道题就是一道可反悔的贪心+大根堆+双向链表。

## 堆（大根堆）

大根堆的定义就是一棵**[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)**，但是它满足一个重要的性质：一个节点的权值一定比它所有子节点要大。

小根堆就是比子节点要小。

维护就很容易了，见代码（当然你也可以用``priority_queue``，用法自行度娘）

## 双向链表

双向链表的定义就是对于每一个节点，都存储它的左边的节点的地址和右边节点的地址。比如下面就是一个以``int``为节点的结构体：

```cpp
struct node {
	int val;
    node* left, right;
}
```

这里用的是~~%你~~模拟链表：

```cpp
int val[Max_N], left[Max_N], right[Max_N];
```

其实都差不多，但是left[i]不再存储i的val[i]的左节点的地址，而存的是下标。

## 可反悔的贪心

如果我们用正常的贪心去做，一定会$\color{red}\mathcal{WA}$。

（比如 19 20 19 1）这个点

但是如果你用了这种方法来取的话，就能$\color{green}\mathcal{AC}$：

对于每一个节点，如果这个节点要种树，就让这个树的权值进行如下操作：

$$val[i] = val[l[i]]+val[r[i]]-val[i]$$。

这样子，只要你接下来想取这个点的两边（而不是取这个点）的话，就可以在``total``的值上从$val[i]$变为$val[l[i]]+val[r[i]]$。

## 接下来是代码：

```cpp
#include <cstdio>
using namespace std;

#define size() (now - 1)
#define empty() (now == 0)
#define top() (heap[1])

#define INF 0x3f3f3f3f
#define max_n 200001

struct pii {
	int v, i;
};

bool operator < (const pii& , const pii&);
bool operator > (const pii& , const pii&);
void swap(pii &, pii &);
void push(const pii&);
void pop();
pii _pair(const int& ,const int&);

pii heap[200001];
int num[max_n], L[max_n], R[max_n];
int now = 1;
bool go[max_n];


int main() {
	int n, m, total = 0;
	pii x;
	scanf("%d%d", &n, &m);
	
	if ((m << 1) > n) { // 根本种不下 
		printf("Error!");
		return 0;
	}
	
	for (int i = 1; i <= n; i ++) { // 定义一个链表 
		scanf("%d", &num[i]);
		L[i] = i - 1;
		R[i] = i + 1;
		push(_pair(num[i], i));
	}
	L[1] = n;
	R[n] = 1;
	
	for (int i = 0; i < m; i ++) {
		while (not empty() and go[top().i]) // 先把所有已经种树的点给pop掉 
			pop();
		x = top();
		pop();
		
		total += x.v;
		num[x.i] = x.v = num[L[x.i]] + num[R[x.i]] - x.v; // 合并节点 
		go[L[x.i]] = go[R[x.i]] = true; // 删除节点 
		L[x.i] = L[L[x.i]];
		R[x.i] = R[R[x.i]];
		L[R[x.i]] = R[L[x.i]] = x.i;
		
		push(x);
	}
	printf("%d", total);
	
	return 0;
}

void pop() {
	heap[1] = heap[--now];
	heap[now + 1].v = -INF;
	int k = 1, i;
	
	while ((k << 1) <= now) {
		i = k << 1;
		
		if (heap[i] < heap[i + 1])
			i ++;
		if (heap[k] < heap[i])
			swap(heap[k], heap[i]);
		else
			break;
		k = i;
	}
}

bool operator < (const pii &x, const pii &y) {
	return x.v < y.v;
}

bool operator > (const pii &x, const pii &y) {
	return x.v > y.v;
}

void swap(pii &x, pii &y) {
	pii z;
	z = x;
	x = y;
	y = z;
}

void push(const pii &in) {
	heap[now ++] = in;
	int k = now - 1;
	
	while (k xor 1 and heap[k] > heap[k >> 1]) {
		swap(heap[k], heap[k >> 1]);
		k >>= 1;
	}
}

pii _pair(const int &v ,const int &i) {
	pii x;
	x.v = v;
	x.i = i;
	return x;
} 
```

---

## 作者：crazydave (赞：3)

##思路
这道题目看上去很容易想到是DP。实际上却是一种神贪心。。。~~都是套路~~

每次贪心选取最大值，答案加上这个最大值，最大值左右两边当然不能再选，于是就标记为访问过。最大值不难想到我们可以用堆进行维护。

但是这个贪心显然是不完善的。当最大值左右两边之和大于它本身时，就会产生错误。于是就有一种神奇的操作：将左右两边之和减去最大值，作为新的节点，覆盖掉原来的最大值，并删去左右两个节点。

原因是要么选最大值，要么选它的左右之和，选最大值时答案加上这个最大值，不再去选新的节点，选左右之和时答案还是加上最大值，只不过后面还要加上新节点的值。也就是当我们再次选取的新节点时，也就相当于选取当时最大值的左右之和，而没有选最大值。

这个神奇的操作有删除左右节点的过程，因此我们要用双向链表进行维护。总的来说这个思路比较难想到，但是代码还是比较好打的。

##代码
需要注意的细节：
 1. 链表时环状的，第一个节点与最后一个相邻
 2. 进行删除节点时要注意前驱和后继都要修改
 3. 操作的顺序要注意，先更新值再进行删除

```
#include <bits/stdc++.h>
#define MAXN 200005

int n, m, ans, num[MAXN], pre[MAXN], next[MAXN];
bool vis[MAXN];

struct node
{
	int v, p;
	bool operator < (const node &x) const
	{
		return v<x.v;
	}
}; 
std::priority_queue <node> q;  //STL优先队列，建立大根堆

int main()
{
	scanf("%d%d",&n,&m);
	if(m*2>n) {printf("Error!\n"); return 0;}  //特判无解情况
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&num[i]);
		q.push((node){num[i], i});
		pre[i]=i-1; next[i]=i+1;  //数组模拟链表
	}
	pre[1]=n; next[n]=1; 
	for(int i=1; i<=m; i++)
	{
		while(vis[q.top().p]) q.pop();  //访问过的直接出队
		node top=q.top(); q.pop();
		ans+=top.v;
		vis[next[top.p]]=vis[pre[top.p]]=1;  //将左右节点标记为访问过的
		num[top.p]=num[pre[top.p]]+num[next[top.p]]-num[top.p]; 
		//删除左右节点
		pre[top.p]=pre[pre[top.p]];
		next[top.p]=next[next[top.p]];
		next[pre[top.p]]=top.p;
		pre[next[top.p]]=top.p;
		q.push((node){num[top.p], top.p});
	}
	printf("%d\n",ans);
} 
```

---

## 作者：eros1on (赞：2)

[博客食用更佳~](https://tle666.github.io/2019/07/23/[%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F]%20%E7%A7%8D%E6%A0%91/)

# **Description**

一个圆环上有 $n$ 个点，每个点都有美观度，要取 $m$ 个点使它们不相邻且总美观度最大。

对于 $100 \%$ 的数据，有 $n \leq 200000,m \leq n$

[题目链接戳这里](https://www.luogu.org/problemnew/show/P1792)

# **Solution**

十分神奇的贪心。。

首先先种上美观度最大的一棵，然后将其左右两棵合并到中间，且其美观度为 $val_l + val_r - val_i$ 。

其中 $val_x$ 是 $x$ 的美观度，$i$ 是美观度最大的那棵， $l,r$ 分别是其左边和右边的两棵。

这中操作其实就是一种反悔机制：如果后来发现一开始选 $i$ 左边和右边的收益更大，那其实加上 $val_l + val_r - val_i$ 后就能把一开始的 $val_i$ 抵消掉，也就是 $val_i + (val_l + val_r - val_i) = val_l + val_r$ 。这时就相当于把一开始不好的 $i$ 替换成更好的 $l,r$ 。

但如果 $i$ 更好，那么后来也就选不上 $l$ 和 $r$ 了，因为每步都会有个排序。

# **Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 200200;

int n, m, ans; bool vis[N];

struct pos { int val, l, r; } p[N];

struct node {
  int val, id;
  inline bool operator < (const node &rhs) const {
    return val < rhs.val;
  }
} ;
priority_queue <node> Q;

inline void del(int x) {
  p[x].l = p[p[x].l].l, p[x].r = p[p[x].r].r;
  p[p[x].l].r = x, p[p[x].r].l = x;
}

int main() {
  scanf("%d%d", &n, &m);
  if ((m << 1) > n) { puts("Error!"); return 0; }
  for (int i = 1; i <= n; i++) {
    scanf("%d", &p[i].val);
    p[i].l = i - 1, p[i].r = i + 1;
    Q.push((node) {p[i].val, i});
  }
  p[1].l = n, p[n].r = 1;
  while (m--) {
    while (vis[Q.top().id]) Q.pop();
    node cur = Q.top(); Q.pop();
    ans += cur.val, vis[p[cur.id].l] = vis[p[cur.id].r] = true;
    p[cur.id].val = p[p[cur.id].l].val + p[p[cur.id].r].val - p[cur.id].val;
    Q.push((node) {p[cur.id].val, cur.id}); del(cur.id);
  }
  printf("%d\n", ans); return 0;
}
```



---

## 作者：nth_element (赞：2)

若想要更丰富的展示，请点击[我的Blog](https://www.cnblogs.com/nth-element/p/11794237.html)

***

 若想要深入学习反悔贪心，[传送门](https://www.cnblogs.com/nth-element/p/11768155.html)。 

***

**Description**:

有 $n$ 个位置，每个位置有一个价值。有 $m$ 个树苗，将这些树苗种在这些位置上，相邻位置不能都种。求可以得到的最大值或无解信息。

**Method**：

先判断无解的情况，我们显然可以发现，若 $n<\frac{2}{m}$ ，则是不能在合法的条件下种上 $m$ 棵树的，故按题意输出` Error! `即可。

假如有解的话，我们可以很轻松的推出贪心策略：在合法的情况下选择最大的价值。

显然上面的策略是错误的，我们选择了最大价值的点，相邻的两个点就不能选，而选择相邻两个点得到的价值可能更大。

考虑如何设计反悔策略。

我们同样用差值来达到反悔的目的。假设有 $A$ ，$B$ ，$C$ ，$D$ 四个相邻的点（如图）。

<div style="text-align: center">
    <img src="https://i.loli.net/2019/11/04/oBsnCwIEqdFeLGA.png"/>
</div>

$A$  点的价值为 $a$ ，其他点同理。若：
$$
a+c>b+d
$$


则：
$$
a+c-b>d
$$
假如我们先选了 $B$ 点，我们就不能选 $A$ 和 $C$ 两点，这显然是不对的，但我们可以新建一个节点 $P$ , $P$ 点的价值为 $a+c-b$ ，再删去 $B$ 点。（如图，红色的是删去的点，橙色的新建的点）

<div style="text-align: center">
    <img src="https://i.loli.net/2019/11/04/f83aBP6TOcDYUAK.png"/>
</div>

下一次选择的点是 $P$ 的话，说明我们反悔了（即相当于 $B$ 点没有选），可以保证最后的贪心最优解是全局最优解。

如何快速插入 $P$ 点和找出是否选择 $P$ 点呢？我们可以使用双向链表和小根堆，使得最终在 $O(n\log n)$ 的时间复杂度下快速求出全局最优解。

**Code**:

```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 2000010 
using namespace std;
inline void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,m;
int w[Maxn],lft[Maxn],rgh[Maxn];
struct node
{
    int val,id;
    bool operator <(const node &n) const 
    {
        return val<n.val;
    }
};
priority_queue<node>qu;
int ind,ans=0;
int vis[Maxn];
signed main()
{
    read(n),read(m);
    ind=n;
    if(n/2<m) 
    {
        puts("Error!");
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        read(w[i]);
        node tmp;
        tmp.id=i;
        tmp.val=w[i];
        qu.push(tmp);
        if(i==1)
        {
            lft[i]=n;
            rgh[i]=i+1;
        }else if(i==n)
        {
            lft[i]=i-1;
            rgh[i]=1;
        }else
        {
            lft[i]=i-1;
            rgh[i]=i+1;
        }
    }
    for(int i=1;i<=m;i++)
    {
        while(vis[qu.top().id]) qu.pop();
        int id=qu.top().id;
        int val=qu.top().val;
        qu.pop();
        ans+=val;
        ind++;
        vis[lft[id]]=vis[rgh[id]]=1;
        lft[rgh[rgh[id]]]=ind;rgh[lft[lft[id]]]=ind;
        lft[ind]=lft[lft[id]];rgh[ind]=rgh[rgh[id]];
        w[ind]=w[lft[id]]+w[rgh[id]]-val;
        int newid=ind;
        int newval=w[ind];
        node tmp;
        tmp.id=newid;
        tmp.val=newval;
        qu.push(tmp);
    }
    printf("%lld\n",ans);
    return 0;
}
```

**Warning**:

- 一定要记录这个点选没有选过，假如已经选过了，就从堆中丢出去；

- 1与 $n$ 是相邻的，一定要特判一下；

- 双向链表一定不要写挂了；

- 一定要先将新建的点的价值存入一开始的价值数组，再丢进堆里；（卡在45卡了好久）

- `index`是关键字，一定不要使用。（我成功CE了一次）

---

## 作者：NeosKnight (赞：1)

所以这题怎么就没有凸优化的题解了,注意到题目要求恰好k个,那么容易想到用凸优化。
显然答案函数是一个凸函数。按照贪心的思路我们在能选的个数少的时候显然会去先选择那些价值高的地方,那么当个数变多的时候,答案的增长速率显然是变慢的,甚至还有负增长,于是就是一个凸函数了,直接凸优化+暴力dp

代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Set(a,b) memset(a,b,sizeof(a))
template<class T>inline void init(T&x){
	x=0;char ch=getchar();bool t=0;
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);
	if(t) x=-x;
}
const int N=500001;
typedef long long ll;
const ll INF=1e9;
const ll inf=1e15;
struct dp{
	ll f,cnt;
	dp(ll _f=0,ll _cnt=0){f=_f,cnt=_cnt;}
	inline void operator +=(const dp &b){f+=b.f,cnt+=b.cnt;}
	inline dp operator +(const dp&b){return dp(f+b.f,cnt+b.cnt);}
	inline bool operator >(const dp &b) {if(f!=b.f) return f>b.f;else return cnt<b.cnt;}
};
inline dp max(dp A,dp B){return A>B? A:B;}
int val[N];
int n,k;
ll ans=0;
inline dp DP(ll D){
	dp F[2],G[2];
	F[0]=F[1]=dp(0,0);
	G[0]=G[1]=dp(0,0);
	F[0]=dp(-inf,0);
	F[1]=dp(val[1]-D,1);
	G[1]=dp(-inf,0);
	for(int i=2;i<=n;++i) {
		dp f0=F[0];
		F[0]=max(F[1],F[0]);
		F[1]=f0+dp(val[i]-D,1);
		
		dp g0=G[0];
		G[0]=max(G[1],G[0]);
		G[1]=g0+dp(val[i]-D,1);
	}
	return max(F[0],max(G[0],G[1]));
}
int main()
{
	init(n),init(k);
	if(k>(n>>1)) return puts("Error!"),0;
	for(int i=1;i<=n;++i) init(val[i]);
	ll L=-INF,R=INF,pos=0;
	while(L<=R) {
		ll mid=L+R;
		if(mid<0) mid=(mid+1)>>1;
		else mid>>=1;
		dp g=DP(mid);
		if(g.cnt<=k) {R=mid-1;pos=mid;}
		else L=mid+1;
	}
	dp g=DP(pos);
	printf("%lld\n",g.f+pos*k);
}

```

---

## 作者：7wwwwth (赞：1)

介绍一种不用重载运算符的办法

可以用优先队列 + make_pair

比重载运算符方便一点诶

q.push(make_pair(a,b))

q.top().first ->a

q.top().second ->b

取出就用q.pop()好了

写堆优化+dij的朋友都理解

这个题就是很典型的带反悔的贪心

如果不考虑隔开种树

那么很显然sort一遍 种最美的就行

但很显然会出现最美的树两边的树加起来比他美的情况

这个时候这个贪心就是错误的

那我们可以考虑在选择该树之后把其左右加上他这个区间值修改一下

改为 左+右-中

这样一来 如果选了该树之后又选择 种改变值之后的树

就相当于没中这个树种了他两边的树。

这个能反悔的贪心就是正确的了。

思路和其他题解估计差不多，就是用了make_pair 就不贴完整代码了。

pre[]记录某点前的点

next[]记录某点后的点

核心部分：
```
void make_data(int x){
	pre[next[x]]=pre[x];
	next[pre[x]]=next[x];
	flag[x]=1; 
}

void plant(){
	while(flag[q.top().second]) q.pop();
	int x=q.top().second;q.pop();
	ans+=a[x];
	a[x]=a[pre[x]]+a[next[x]]-a[x];
	make_data(pre[x]);
	make_data(next[x]);
	q.push(make_pair(a[x],x));
}
```

---

## 作者：孙子隆 (赞：1)

看到题目首先想到的是dp。

~~然后提交得到了35的好成绩（并且忽略了一种情况）~~，没注意到n是200000，dp要炸空间。


然后看了一下标签

优先队列+贪心

？？？
似乎感觉做过这类题...

## [P3545](https://www.luogu.org/problem/P3545)


还是黄主力给讲的。

然后做完这两道题你一定会对这类题有新的理解。

## [P3620](https://www.luogu.org/problem/P3620)
任务+1

我们来看这道题，首先考虑优先队列，然而这并不能实现最优，考虑‘退货’制度。

就比如这样的一组1 8 9 8这样一组，
优先队列会优先考虑9和1

我们的思路其实应该在9和1的选择里边加入新的选择，即8和8，考虑在优先队列里加入一个新的点，新点的值是8+8-9-1,这样一步步取出队列即能保证正确答案了。
要注意最后一个点n。


```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<queue>
#include<map>
#define maxn 2000100
#define inf ??

using namespace std;

struct node 
{
	int val,l,r;
}e[maxn];

struct node1
{
	int val,id;
	bool operator <(node1 it) const
	{
		return val<it.val;
	}
};

inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
	    if(c=='-')
		f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}

int n,m,ans;
bool vis[maxn];
priority_queue<node1>q;

void deal(int x)
{
	e[x].l=e[e[x].l].l;
	e[x].r=e[e[x].r].r;
	e[e[x].l].r=x;
	e[e[x].r].l=x;
}

int main()
{
    n=read(),m=read();
    if(n<m*2)
    {
    	cout<<"Error!";
    	return 0;
    }
    for(int i=1;i<=n;i++)
    {
    	e[i].val=read();
    	e[i].l=i-1;
    	e[i].r=i+1;
    	q.push((node1){e[i].val,i});
    }
    e[1].l=n;e[n].r=1;
    for(int i=1;i<=m;i++)
    {
    	while(vis[q.top().id])
    	q.pop();
    	node1 now=q.top();
    	q.pop(); 
    	ans+=now.val;
    	vis[e[now.id].l]=vis[e[now.id].r]=1;
    	e[now.id].val=e[e[now.id].l].val+e[e[now.id].r].val-e[now.id].val;
    	q.push((node1){e[now.id].val,now.id});
    	deal(now.id);
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：End_donkey (赞：0)

题意

[传送门](https://www.lydsy.com/JudgeOnline/problem.php?id=2151)

手写堆大法好啊，题解貌似没有结构体堆的做法，思路有些像配对堆，关于配对堆请自行百度，因为本蒟蒻不会。。

以下是蒟蒻的做法:建立一个大根堆a维护最大价值里面存入它的编号以及价值。听说配对堆可以不用定义结构体，但我不会呀！l表示这个位置左边的编号，r同理。一个数组book标记是否可以选择，每次选完之后左右两边进行标记，堆中加入左右之和减去本身的值再将其放入原来的位置，即可达到后悔操作，更新左右编号，然后取m次即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,add,k;
struct node{
	int data;//价值
	int num;//编号
}a[200010];
int c[200010];
int l[200010],r[200010];
bool book[200010];
long long ans;
void shiftdown(int x){//下调操作，依靠价值进行堆中元素调整
	int t,flag=0;
	while(2*x<=add&&flag==0){
		if(a[x].data<a[2*x].data) t=2*x;
		else t=x;
		if(2*x+1<=add&&a[t].data<a[2*x+1].data) t=2*x+1;
		if(t!=x){
			swap(a[t],a[x]);//这里是交换结构体哦
			x=t;
		}else flag=1;
	}
}
void shiftup(int x){//上调操作
	int flag=0;
	if(x==1) return;
	while(x!=1&&flag==0){
		if(a[x].data>a[x/2].data) swap(a[x],a[x/2]);
		else flag=1;
		x/=2;
	}
}
int main(){
	scanf("%d %d",&n,&m);
	if(m>(n>>1)){
		printf("Error!");
		return 0; 
	} 
	for(int i=1;i<=n;++i){
		scanf("%d",&c[i]);
		a[++add].data=c[i];
		a[add].num=i;
		l[i]=i-1;
		r[i]=i+1;
		shiftup(add);//每加入一个新的元素都要进行上调操作
	}
	l[1]=n,r[n]=1;//环形的
	ans=0;
	while(m--){//标记过的直接弹出
		int x=a[1].num,val=a[1].data;
		a[1]=a[add--];
		shiftdown(1);
		while(book[x]){//注意先把值取出来再弹出哦
			x=a[1].num,val=a[1].data;
			a[1]=a[add--];
			shiftdown(1);
		}
		ans+=val;
		c[x]=c[l[x]]+c[r[x]]-c[x];//左右减去本身
		book[l[x]]=1;//标记
		book[r[x]]=1;
		l[x]=l[l[x]];//新的左边的原来左边的左边
		r[x]=r[r[x]];//大体同上
		r[l[x]]=x;//左边的右边更新
		l[r[x]]=x;//右边的左边更新
		a[++add].data=c[x];
		a[add].num=x;//放入元素
		shiftup(add);
	}
	printf("%lld",ans);
	return 0;
} 
```


---


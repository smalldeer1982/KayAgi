# [国家集训队] 数颜色 / 维护队列

## 题目描述

墨墨购买了一套 $N$ 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：

1. $Q\ L\ R$ 代表询问你从第 $L$ 支画笔到第 $R$ 支画笔中共有几种不同颜色的画笔。

2. $R\ P\ C$ 把第 $P$ 支画笔替换为颜色 $C$。

为了满足墨墨的要求，你知道你需要干什么了吗？


## 说明/提示

对于30%的数据，$n,m \leq 10000$

对于60%的数据，$n,m \leq 50000$

对于所有数据，$n,m \leq 133333$

所有的输入数据中出现的所有整数均大于等于 $1$ 且不超过 $10^6$。

本题可能轻微卡常数

来源：bzoj2120

本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时5分钟完成数据制作。


## 样例 #1

### 输入

```
6 5
1 2 3 4 5 5
Q 1 4
Q 2 6
R 1 2
Q 1 4
Q 2 6```

### 输出

```
4
4
3
4
```

# 题解

## 作者：Gu_Pigeon (赞：175)

## 题解 兼 学习笔记

明显的一道带修莫队，于是去认真学习了一番，对莫队也有了一些新的理解。

**这一切的一切，都要从最初的问题说起……**

“很久很久以前，有一个序列……”

当序列上只有一个询问，例如，求区间颜色种数时，我们可以$O(n)$时间内解决这一个孤零零的问题。

但是，当询问数变成了m，~~这题就变成了[HH的项链](https://www.luogu.org/problem/P1972)~~，我们不能总是一个一个求，明显TLE。

此时，我们想到，由上一次查询的结果，通过对左右端点的移动，我们就可以得出新的解。

从`[l,r]`到`[l+1,r]`、`[l-1,r]`、`[l,r+1]`、`[l,r-1]`的转移都是$O(1)$的，所以……**等等!**

要是我们把中括号改成小括号……

`(l,r)->(l-1,r)(l+1,r)(l,r-1)(l,r+1)`

这不就是平面直角坐标系吗！

一不做二不休，把它画出来：

![](https://cdn.luogu.com.cn/upload/pic/71501.png)

（图丑轻喷…）

图中四个箭头的移动都是可以$O(1)$完成的，那么两点之间的[**曼哈顿距离**](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin)就是从一个状态到另一个状态所需要的最小挪动

（不了解曼哈顿距离的同学戳上面加粗字体）

那么对于所有的查询，最快的办法就是在坐标系上找到[曼哈顿最小生成树](https://www.cnblogs.com/xzxl/p/7237246.html)

~~（其实没有必要会这个因为太麻烦了）~~

你也许会说：“我不会啊！”

**这完全没有关系**，因为

~~我也不会~~

但是我们并没有必要得到最佳答案，能卡过去就够了。

于是我们采用分块的想法，将其分成`(n/sz)`个长度为`sz`的块，在每一个块中按照右端点从小到大来移动

就像这样：

![](https://cdn.luogu.com.cn/upload/pic/71508.png)

至少这样不会被卡掉……

至于块的大小？$\sqrt n$呗。

（实际上严谨的说，应该是$\dfrac {n}{\sqrt {m}}$，具体为啥有兴趣的同学可以研究一下，一般来说块的大小$\sqrt n$足矣，因此不在此介绍）

那么我们就讲好了本题……的前置部分……

好了！现在我们在这里加入了修改，“我该怎么办呢qwq”

可以这么认为，序列的值是随着**时间**而变化的

那我们就在坐标系上再加上一个时间维度，用`(l,r,t)`来表示一个查询

![](https://cdn.luogu.com.cn/upload/pic/71519.png)

↑大概就是这样

很明显，我们需要分别按照`l`与`r`分块，在同一块内的询问按照t从小到大完成。块的大小就是${\sqrt [3] {n^{2}}}=n^{0.6666...}$

（至于为什么还是看别的题解吧，窝太菜廖）

所以总的来说，只需要在原有的普通莫队上在加一个时间维度就可以了

$Code\ Below$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 233333
#define M 1111111

int sum, cnt[M], a[N], ans[N], cntq = 0, cntr = 0, n, m, sz;

struct ques
{
	int l, r, t, id;
} qq[N], qr[N];//两个数组分解记录每一个询问以及修改的状态

inline void add(int x)
{
	sum += !cnt[x]++;
}

inline void del(int x)
{
	sum -= !--cnt[x];
}

//add与del是普通莫队原有操作

inline void upd(int x, int t)//upd是对于时间上的变化所造成变化的维护
{
	if (qq[x].l <= qr[t].l && qr[t].l <= qq[x].r)
	{
		del(a[qr[t].l]);
		add(qr[t].r);
	} //如果这个修改的值在[l,r]区间内，则其变化将对答案造成影响
	swap(a[qr[t].l], qr[t].r);//因为修改后的下一次操作一定相反(即修改该位置->还原该位置->修改该位置...如此循环)，所以只需交换即可，而不需要写两个函数
}

bool cmp (const ques &a, const ques &b)
{
	return a.l / sz == b.l / sz ? a.r / sz == b.r / sz ? a.t < b.t : a.r < b.r : a.l < b.l;
}//魔改版cmp，需要判断t的大小

int main()
{
	cin >> n >> m; sz = pow(n, 0.666);//设置块的大小
	for (int i = 1; i <= n; i++) scanf("%d", a + i);
	for (int i = 1; i <= m; i++)
	{
		char op[5];
		int l, r;
		scanf("%s%d%d", op, &l, &r);
		if (op[0] == 'Q') ++cntq, qq[cntq].id = cntq, qq[cntq].l = l, qq[cntq].r = r, qq[cntq].t = cntr;//询问的时间即为该询问以前已经执行了多少次修改操作
		else qr[++cntr].l = l, qr[cntr].r = r;
	}
	sort(qq + 1, qq + cntq + 1, cmp);
	int lcur = 1, rcur = 0, tcur = 0;
	for (int i = 1; i <= cntq; i++)
	{
		while (lcur > qq[i].l) add(a[--lcur]);
		while (lcur < qq[i].l) del(a[lcur++]);
		while (rcur > qq[i].r) del(a[rcur--]);
		while (rcur < qq[i].r) add(a[++rcur]);
		while (tcur < qq[i].t) upd(i, ++tcur);
		while (tcur > qq[i].t) upd(i, tcur--);//增加t轴上的移动
		ans[qq[i].id] = sum;//得到最终答案
	}
	for (int i = 1; i <= cntq; i++) printf("%d\n", ans[i]);
	return 0;//结束&AC!
}
```
求赞QwQ

顺便无耻地打个AD：[$My Blog$](https://www.luogu.org/blog/IAMZJD/)

---

## 作者：attack (赞：138)

[更好的阅读体验点这里](http://www.cnblogs.com/zwfymqz/p/7154145.html)

## pre
很早之前就学习了莫队算法。

老师讲课的时候就提到过带修改莫队在线莫队树上莫队树上带修改莫队……但是一直都没有做到过有关的题，

今天有幸做了一道裸的带修改莫队的题，

那就来分享一下自己的经验

## 带修改的莫队

首先我们要知道，普通的莫队算法是不资瓷修改操作的，

不过后人对莫队算法加以改进

发明了资瓷修改的莫队算法

## 思路

在进行修改操作的时候，修改操作是会对答案产生影响的(废话)

那么我们如何避免修改操作带来的影响呢？

首先我们需要把查询操作和修改操作**分别**记录下来。

在记录查询操作的时候，需要增加一个变量来记录**离本次查询最近的修改**的位置


然后套上莫队的板子，与普通莫队不一样的是，你需要用一个变量记录**当前已经进行了几次修改**

对于查询操作，如果当前改的比本次查询需要改的少，就改过去

反之如果改多了就改回来

 
说的听绕口的

比如，我们现在已经进行了3次修改，本次查询是在第5次修改之后，那我们就执行第4,5次修改


这样就可以避免修改操作对答案产生的影响了


## code


```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN=2*1e6+10;
inline int read()
{
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0',c=getchar();}
    return x*f;
}
int N,M;
int a[MAXN],where[MAXN];
struct Query
{
    int x,y,pre,id;
}Q[MAXN];
int Qnum=0;
struct Change
{
    int pos,val;
}C[MAXN];
int Cnum=0;
int color[MAXN],ans=0,base,out[MAXN];
int comp(const Query &a,const Query &b)
{
    if(a.x!=b.x) return where[a.x]<where[b.x];
    if(a.y!=b.y) return where[a.y]<where[b.y];
    return a.pre<b.pre;
}
void Add(int val)
{    
    if(++color[val]==1) ans++;
} 
void Delet(int val)
{
    if(--color[val]==0) ans--;
}
void Work(int now,int i)
{
    if(C[now].pos>=Q[i].x&&C[now].pos<=Q[i].y)//注意：只有修改在查询的区间内才会对查询的结果产生影响 
    {
        if( --color[a[C[now].pos]] == 0 ) ans--;
        if( ++color[C[now].val] == 1)      ans++; 
    }
    swap(C[now].val,a[C[now].pos]);
    //这里有个很巧妙的操作
    //对于一个操作，下一次需要为的颜色是本次被改变的颜色
    //比如，我把颜色3改为了7，那么再进行这次修改的时候就是把7改为3
    //所以直接交换两种颜色就好 
}
void MoQueue()
{
    int l=1,r=0,now=0; 
    for(int i=1;i<=Qnum;i++)
    {
        while(l<Q[i].x)    Delet(a[l++]);
        while(l>Q[i].x) Add(a[--l]);
        while(r<Q[i].y) Add(a[++r]);
        while(r>Q[i].y) Delet(a[r--]);//以上四句为莫队模板 
        while(now<Q[i].pre) Work(++now,i);//改少了，改过去 
        while(now>Q[i].pre) Work(now--,i);//改多了，改回来 
        out[Q[i].id]=ans;//统计答案 
    }
    for(int i=1;i<=Qnum;i++)
        printf("%d\n",out[i]);
}
int main()
{
    N=read();M=read();
    base=sqrt(N);
    for(int i=1;i<=N;i++) a[i]=read(),where[i]=(i-1)/base+1;
    while(M--)
    {
        char opt[5];
        scanf("%s",opt);
        if(opt[0]=='Q')
        {
            Q[++Qnum].x=read();
            Q[Qnum].y=read();
            Q[Qnum].pre=Cnum;//别忘了记录最近的修改位置 
            Q[Qnum].id=Qnum;        
        }
        else if(opt[0]=='R')
        {
            C[++Cnum].pos=read();
            C[Cnum].val=read();
        }
    }
    sort(Q+1,Q+Qnum+1,comp);//玄学排序 
    MoQueue();
    return 0;
}
```
## 边界问题
由于刚开始的$now=0$

所以需要先增后执行

撤销的时候需要将最后一次的修改撤销掉

所以先执行后减


---

## 作者：Minclxc (赞：120)

带修改的莫队，和原版莫队相比，多了一个时间轴

原版莫队是将区间(l,r)视为点(l,r)，带修改的即加一维时间轴(l,r,t)

对于t轴的移动可以保存每次修改，如果修改在(l,r)间则更新

分块方法可以参照原版莫队，先将l分块，再讲r分块，同一块的按t排序

块大小为 ![](https://cdn.luogu.com.cn/upload/pic/8124.png) 可以达到最快的理论复杂度 ![](https://cdn.luogu.com.cn/upload/pic/8123.png) ，证明如下

设分块大小为a，莫队算法时间复杂度主要为t轴移动，同r块l,r移动，l块间的r移动三部分

t轴移动的复杂度为 ![](https://cdn.luogu.com.cn/upload/pic/8125.png) ，同r块l,r移动复杂度为 ![](https://cdn.luogu.com.cn/upload/pic/8126.png) ，l块间的r移动复杂度为 ![](https://cdn.luogu.com.cn/upload/pic/8127.png)

三个函数max的最小值当a为 ![](https://cdn.luogu.com.cn/upload/pic/8124.png) 取得，为 ![](https://cdn.luogu.com.cn/upload/pic/8123.png)

代码如下

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int N=10001;
int a[N],p[1000001],ans[N],divi;
struct nod{int pla,pre,suc;}cg[N];
struct node{int l,r,t,bel;}ls[N];
int cmp(node a,node b){
    if(a.l/divi!=b.l/divi)return a.l/divi<b.l/divi;
    if(a.r/divi!=b.r/divi)return a.r/divi<b.r/divi;
    return a.t<b.t; 
}
int main(){
    int n=read(),m=read(),ln=0,tn=0,l=1,r=0,t=0,num=0;
    fo(i,1,n)a[i]=read();
    fo(i,1,m){
        scanf("\n");
        if(getchar()=='R'){//如果读入修改则记录修改的地点，修改前的数字和修改后的数字
            ++tn;cg[tn].pla=read(),cg[tn].suc=read();
            cg[tn].pre=a[cg[tn].pla];
            a[cg[tn].pla]=cg[tn].suc;
        } 
        else ls[++ln]=(node){read(),read(),tn,ln};
    }
    divi=ceil(exp((log(n)+log(tn))/3));//分块大小
    go(i,tn,1)a[cg[i].pla]=cg[i].pre;
    sort(ls+1,ls+ln+1,cmp);
    fo(i,1,m){
        while(ls[i].l<l)num+=!p[a[--l]]++;
        while(ls[i].l>l)num-=!--p[a[l++]];//l移动
        while(ls[i].r>r)num+=!p[a[++r]]++;
        while(ls[i].r<r)num-=!--p[a[r--]];//r移动
        while(ls[i].t<t){
            int pla=cg[t].pla;
            if(l<=pla&&pla<=r)num-=!--p[a[pla]];
            a[pla]=cg[t--].pre;
            if(l<=pla&&pla<=r)num+=!p[a[pla]]++;
        };
        while(ls[i].t>t){
            int pla=cg[++t].pla;
            if(l<=pla&&pla<=r)num-=!--p[a[pla]];
            a[pla]=cg[t].suc;
            if(l<=pla&&pla<=r)num+=!p[a[pla]]++;
        };//t移动
        ans[ls[i].bel]=num;
    }
    fo(i,1,ln)printf("%d\n",ans[i]); 
    return 0;
}
```

---

## 作者：λᴉʍ (赞：66)

[这题竟然没有树套树题解？](http://www.cnblogs.com/xzz_233/p/8321150.html)


很久以前写的，但因为拿来出题一直没敢FA题解。。。


这是一份树套树的题解，n,m<=50000应该是可以跑的。


[HH的项链题解](http://www.cnblogs.com/xzz_233/p/cogs421.html)


在那份题解里我写了树套树，其实是因为我要来写这道题懒得改了。。。。


首先维护100000颗set，每个set里的点颜色一样，这样可以方便的求出同种颜色的前驱后继和修改


然后树状数组套主席树，修改的话搞出lst值就可以辣


```cpp
// It is made by XZZ
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<algorithm>
#include<set>
#define il inline
#define rg register
#define vd void
#define sta static
typedef long long ll;
typedef const int& fast;
using namespace std;
il int gi(){
    rg int x=0,f=1;rg char ch=getchar();
    while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int maxn=10000;
int n,m;
namespace Tree{
    namespace SGT{
        const double alpha=0.7233333;
        int root[1000001],id,val[maxn*50],ch[maxn*50][2],siz[maxn*50],cover[maxn*50],b[maxn*50];
        bool del[maxn*50];
        il int newnode(int _val){val[++id]=_val,ch[id][0]=ch[id][1]=0,siz[id]=cover[id]=1;return id;}
        il vd dfs(const int&rt){
            if(!rt)return;
            dfs(ch[rt][0]);
            if(!del[rt])b[++b[0]]=rt;
            dfs(ch[rt][1]);
        }
        il int divide(int l,int r){
            if(l>r)return 0;
            int mid=(l+r)>>1;
            ch[b[mid]][0]=divide(l,mid-1);
            ch[b[mid]][1]=divide(mid+1,r);
            siz[b[mid]]=siz[ch[b[mid]][0]]+siz[ch[b[mid]][1]]+!del[b[mid]];
            cover[b[mid]]=cover[ch[b[mid]][0]]+cover[ch[b[mid]][1]]+1;
            return b[mid];
        }
        il vd rebuild(int&rt){b[0]=0;dfs(rt);rt=divide(1,b[0]);}
        il int*_Insert(int&rt,fast num){
            if(!rt){rt=newnode(num);return NULL;}
            ++siz[rt],++cover[rt];
            int*ret=_Insert(ch[rt][num>=val[rt]],num);
            if(max(cover[ch[rt][0]],cover[ch[rt][1]])>alpha*cover[rt])ret=&rt;
            return ret;
        }
        il vd Insert(fast y,fast x){int*ls=_Insert(root[y],x);if(ls)rebuild(*ls);}
        il int Rank(fast y,fast x){
            int ret=1,now=root[y];
            while(now)
                if(x<=val[now])now=ch[now][0];
                else ret+=siz[ch[now][0]]+!del[now],now=ch[now][1];
            return ret;
        }
        il vd _Delete(fast y,int k){
            int now=root[y];
            while(now){
                --siz[now];
                if(!del[now]&&k==siz[ch[now][0]]+1){del[now]=1;return;}
                if(k<=siz[ch[now][0]])now=ch[now][0];
                else k-=siz[ch[now][0]]+!del[now],now=ch[now][1];
            }
        }
        il vd Delete(fast y,fast x){
            _Delete(y,Rank(y,x));
            if(siz[root[y]]<cover[root[y]]*alpha)rebuild(root[y]);
        }
    }
    il int lb(fast x){return x&-x;}
    il vd Update(rg int x,fast y){if(!x)return;while(x<=n)SGT::Insert(x,y),x+=lb(x);}
    il vd Update_(rg int x,fast y){if(!x)return;while(x<=n)SGT::Delete(x,y),x+=lb(x);}
    il int Query(rg int l,rg int r,fast y){
        int ret=0;
        while(r)ret+=SGT::Rank(r,y+1)-1,r-=lb(r);
        --l;while(l)ret-=SGT::Rank(l,y+1)-1,l-=lb(l);
        return ret;
    }
}
namespace Set FA♂Q{
    set<int>st[1000001];
    il vd del(fast x,fast y){st[x].erase(st[x].find(y));}
    il vd ins(fast x,fast y){st[x].insert(y);}
    il pair<int,int>find(fast x,fast y){
        set<int>::iterator it=st[x].find(y);
        pair<int,int>ret=make_pair(0,0);
        if(it!=st[x].begin())--it,ret.first=*it,++it;
        ++it;if(it!=st[x].end())ret.second=*it;
        return ret;
    }
}
int num[maxn],__lst[1000001];
int main(){
    n=gi();m=gi();
    for(rg int i=1;i<=n;++i)num[i]=gi(),Tree::Update(i,__lst[num[i]]),Set::ins(num[i],i),__lst[num[i]]=i;
    int x,y;pair<int,int>s;char opt[10];
    while(m--){
        scanf("%s",opt),x=gi(),y=gi();
        if(opt[0]=='Q')printf("%d\n",Tree::Query(x,y,x-1));
        else{
            s=Set::find(num[x],x);
            Tree::Update_(x,s.first),Tree::Update_(s.second,x),Tree::Update(s.second,s.first);
            Set::del(num[x],x),Set::ins((num[x]=y),x);
            s=Set::find(num[x],x);
            Tree::Update_(s.second,s.first),Tree::Update(s.second,x),Tree::Update(x,s.first);
        }
    }
    return 0;
}
```

---

## 作者：251Sec (赞：50)

这题作为 [P4690](/problem/P4690) 的弱化版居然没有用 CDQ 分治做的题解？

那我复制一下我写的 P4690 题解：

先考虑不带修怎么做，即 [P1972](/problem/P1972)，我们对每个点维护 $pre_i$ 代表与它颜色相同且下标在它之前的，下标最大的点的下标。（好绕口）

那么我们对于一个区间询问，考虑对于每种颜色，只统计它在区间中出现的最左边一次，也就是查询有多少 $l \leq i \leq r$，满足 $pre_i<l$。那么我们可以作二维偏序来得到答案。

有了不带修的做法，单点修改的做法就很显然了。注意到进行一次单点修改对 $pre$ 数组的影响是 $O(1)$ 的。因此我们把一次单点修改变成一次删除和一次插入，这样就是在二维偏序的基础上加了时间维。因此我们可以作三维偏序。CDQ 分治即可。

时间复杂度双 $\log$，空间复杂度线性，优于树套树和莫队做法。

---

## 作者：R·Buffoon (赞：23)

**带修莫队板子题**
***
什么是带修莫队呢？~~就是带修改的莫队啦~~

什么，你问什么事莫队？~~请点击[这个](http://iwo.im/?q=%E8%8E%AB%E9%98%9F)~~
***
好了，~~众所周知~~，普通莫队是不支持修改的，于是就出现的支持修改的莫队，也就是带修莫队啦

那么，如何实现呢？~~就是加一个时间轴啦（逃~~

接下来用代码讲解（因为理论讲不清楚~~代码可能也是~~）

~~~cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;

int in()
{
	int aa=0;char cc=getchar();
	for(;!isdigit(cc);cc=getchar());
	for(;isdigit(cc);cc=getchar())aa=(aa<<1)+(aa<<3)+(cc&15);
	return aa;
}

const int M=1e6+5;
const int N=233333;

struct H
{
	int l,r,t,id;
}q[N];//记录查询的信息

struct HH
{
	int id,col;
}c[N];//记录修改的信息

char op;
int n,m;
int size,now;
int l,r,t,ql,qr,qt;
int cnt_q=0,cnt_c=0;
int a[N],cnt[M],be[N],ans[N];
//是不是很有层次感？

inline int cmp(H x,H y)
{
	return x.l/size==y.l/size?(x.r/size==y.r/size?x.t<y.t:x.r<y.r):x.l<y.l;
}

inline void update(int l,int r,int x)
{
	int id=c[x].id,&col=c[x].col;//减少码量（笑）
	if(id>=l && id<=r)//如果当前要更新的点在查询区间内，就进行计数操作（有点像线段树）
	{
		now-=!--cnt[a[id]];
		now+=!cnt[col]++;
	}
	swap(a[id],col);//无论是否在查询区间内，都要交换两者的值，使a[id]变为原值或修改后的值
}

int main()
{
	n=in(),m=in();size=pow(n,0.666);
	for(RI i=1;i<=n;++i) a[i]=in();
	for(RI i=1;i<=m;++i)
	{
		op=getchar();
		while(op!='Q' && op!='R') op=getchar();//这个字符的输入是不是很强？（不是我想的） 
		if(op=='Q')
		{
			++cnt_q;//记录要查询的个数 
			q[cnt_q].l=in(),q[cnt_q].r=in();
			q[cnt_q].id=cnt_q,q[cnt_q].t=cnt_c;//t记录在这之前有几个修改操作，即时间
		}else 
		{
			++cnt_c;//记录要修改的个数 
			c[cnt_c].id=in(),c[cnt_c].col=in();
		}
	}
	
	sort(q+1,q+1+cnt_q,cmp);
	
	l=1,r=0,t=0,now=0;
	for(RI i=1;i<=cnt_q;++i)
	{
		ql=q[i].l,qr=q[i].r,qt=q[i].t;
		while(l<ql) now-=!--cnt[a[l++]];//常 
		while(l>ql) now+=!cnt[a[--l]]++;//规 
		while(r<qr) now+=!cnt[a[++r]]++;//操 
		while(r>qr) now-=!--cnt[a[r--]];//作 
		while(t<qt) update(ql,qr,++t);//t<qt，说明在(t,qt)这个时间段内有需要修改的点（到了它修改的时间）还未修改，在此更新
		while(t>qt) update(ql,qr,t--);//t>qt，说明在(qt,t]这个时间段内有不需要修改的点（未到它修改的时间）给修改了，在此更新 
		ans[q[i].id]=now;//记录答案 
	}
	
	for(RI i=1;i<=cnt_q;++i) printf("%d\n",ans[i]);
	
	return 0;
}
~~~
关于排序方法，就是
>如果左端点在同一区块且右端点在同一区块，则按时间排序；  
如果左端点在同一区块而右端点不在同一区块，则按右端点排序；  
如果左端点不在同一区块，则按左端点排序。

简单点说，就是
>以左端点所在块为第一关键字，以右端点所在块为第二关键字，以时间为第三关键字进行排序。

个人认为把它们这么翻译的话比较好记
***
关于区块的大小，有篇题解证明是取$ceil(exp((log(n)+log(cnt-q))/3))$时最快,但是我实测取$n^{\frac{2}{3}}$会比较快（我不会证明，~~数学太弱~~），但可以看这个大佬的[博客](https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html)，有证明（大概在$\frac{1}{3}$处）
***
最后，这题卡常！
>本题可能轻微卡常数

~~我怀疑是狂卡（毒瘤cz，卡了俩莫队了），为此我贡献了2页的评测记录~~，其实也是因为莫队的复杂度不够优秀。尽管它是优雅的暴力，但也扛不住$n,m<=133333$呀，如果是$n,m<=88888$的话还是可以优雅的跑过的（没测过，估个喜庆的数），所以你需要来口氧气（话说lg的氧气质量真的好，直接把9.5s砍成了3.8s，手动吸臭氧都比不过）
***
**彩蛋！**有没有发现代码一共有$88$行（包括注释但不包括注释炸出的行数）？~~我可能太迷信了~~

---

## 作者：_rqy (赞：23)

大暴力。

zkw线段树，每个节点上开一个bitset记录该区间里有哪些数。为了数的范围不大，开一个map来实时离散化（反正离散化不要求大小）。

没了。

时间复杂度是$O((n+m)\log n*n/b)$，其中$b$是字长（32或64）。

代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <bitset>
#include <map>
const int N = 12000;
unsigned A[N];
std::bitset<N> B[32768];
std::bitset<N> ans;
int L;
void build(int n) {
  L = 1;
  while (L < n) L <<= 1;
  for (int i = 0; i < L; ++i) {
    B[i + L].reset();
    B[i + L].set((unsigned)A[i]);
  }
  for (int i = L - 1; i; --i)
    B[i] = B[i << 1] | B[i << 1 | 1];
}
void modify(int x, unsigned y) {
  unsigned z = A[x];
  if (z == y) return;
  int i = x + L;
  A[x] = y;
  do {
    B[i].set(y); i >>= 1;
  } while (i && !B[i].test(y));
  B[i = x + L].reset(z);
  while (i > 1 && !B[i ^ 1].test(z))
    B[i >>= 1].reset(z);
}
int query(int x, int y) {
  ans.reset();
  --x; ++y;
  for (x += L, y += L; x != (y ^ 1); x >>= 1, y >>= 1) {
    if (~x & 1) ans |= B[x ^ 1];
    if (y & 1) ans |= B[y ^ 1];
  }
  return (int)ans.count();
}
unsigned get(int x) {
  static unsigned p = 0;
  static std::map<int, unsigned> M;
  if (M.count(x)) return M[x];
  return M[x] = p++;
}
char s[10];
int main() {
  int n, q, x, y;
  scanf("%d%d", &n, &q);
  for (int i = 1; i <= n; ++i) {
    scanf("%d", &x);
    A[i] = get(x);
  }
  build(n + 2);
  while (q--) {
    scanf("%s%d%d", s, &x, &y);
    if (*s == 'R') modify(x, get(y));
    else printf("%d\n", query(x, y));
  }
  return 0;
}
```
不要喷我，毕竟@huang\_yue 都把***纯***暴力扔上去了qwq。


---

## 作者：Juan_feng (赞：18)

## 大家好， 蒟蒻小Jf很喜欢分块， 于是就说一下时间为 (n+m) sqrt (n) 空间为线性的在线分块做法吧qwq  

首先n^(5/3)的暴力分块应该不难想， 设块大小为T，维护每两个块之间的答案ans，再维护一下cnt（i, j）表示前i个块中j这个数出现的次数。 查询时可以在T的时间内完成散块的信息统计； 然后修改的时候暴力修改（n/T）^2的ans。 当T取到n^(2/3)的时候复杂度为n^(5/3)。 这个东西显然不如带修莫队， 所以要对其进一步进行优化。

### 优化方案：

考虑到修改ans的复杂度是接近On级别的， 且不是很好优化， 
所以考虑用多个修改操作来平摊这个复杂度(定期重构）

具体做法是先预处理出每两个块中的答案，  然后用vector存一下每个数每次出现的位置， 每个位置是这个位置上的数在序列中第几次出现的。 这两个信息都是n级别的。

> 对于不超过sqrt次修改， 查询的时候可以直接分类讨论一下得到答案。

> 每sqrt次修改就需要重构一下。 

设每个修改的位置是posnow， 这个颜色前一次出现的位置是posx， 后一次出现的位置是posy。 答案数组是ans

那么变化的只有b[posx] < i <= b[posnow] 且  b[posnow] <= j < b[posy] 的 ans(i, j)信息。

这个东西可以把ans数组放在二位平面里差分一下（一维是i一维是j， 两个维度的大小都是sqrt级别的）。 单次差分的复杂度就是sqrt n， sqrt次就是On， 然后再用O(sqrt*sqrt)扫一遍差分数组, On重新处理一下vector就能完成重构了。

这样最多重构sqrt (m) 次， 总复杂度就是 (m+n) sqrt (n) 

那么到这里就讲完啦。 还有什么不明白的就私信小蒟蒻吧>_<


---

## 作者：asd_a (赞：18)

算法自然两种——树套树和带修莫队  
|  | 空间 | 时间 |
| -----------: | -----------: | -----------: |
| 树套树 | O($ nlogn^2 $) |O($ nlogn^2 $)  |
|莫队| $ n$ | O($nsqrt(n)$) |  
显然树套树速度更快，莫队空间更小，可以根据时空限制酌情选择  
而这道题两个都可以： 

### 树套树：  

用set维护一种颜色上一个出现的位置，  
再用前无古人后无来者的bit+splay查询

### code:
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e+5;
const int M=N<<7;
int rt[N<<2];
int n,m,col[N];
namespace st
{
    set<int>s[1000001];
    void del(int x,int y){s[x].erase(s[x].find(y));}
    void ins(int x,int y){s[x].insert(y);}
    pair<int,int> fd(int x,int y)
    {
        set<int>::iterator it=s[x].find(y);
        pair<int,int> anss=make_pair(0,N-5);
        if(it!=s[x].begin())it--,anss.first=*it,it++;
        it++;
        if(it!=s[x].end())anss.second=*it;
        return anss;
    }
}
inline int lb(int x){return x&-x;}
namespace sp
{
    int siz[M],c[M][2],fa[M],val[M],cnt;
    inline void up(int x){siz[0]=0;siz[x]=siz[c[x][0]]+siz[c[x][1]]+1;}
    inline int gs(int x){return x==c[fa[x]][1];}
    inline void rotate(int x)
    {
        int y=fa[x],z=fa[y],sx=gs(x),sy=gs(y);
        fa[x]=z;c[z][sy]=x;
        c[y][sx]=c[x][sx^1]; fa[c[x][sx^1]]=y;
        fa[y]=x; c[x][sx^1]=y;
        up(y);up(x);
    }
    inline void splay(int x,int &root)
    {
        while(fa[x])
        {
            int y=fa[x];
            if(fa[y])
            {
                if(gs(y)==gs(x))rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
        root=x;
    }
    inline void Insert(int &now,int x)
    {
        if(!now)
        {
            now=++cnt;
            val[now]=x;
            siz[now]=1;
            return ;
        }
        if(x<val[now])
        {
            Insert(c[now][0],x);
            fa[c[now][0]]=now;
        }
        else
        {
            Insert(c[now][1],x);
            fa[c[now][1]]=now;
        }
        up(now);
    }
    inline void ins(int x,int &now)
    {
        siz[0]=0;
        Insert(now,x);
        splay(cnt,now);
    }
    inline int smaller(int x,int now)
    {
        siz[0]=0;
        if(now==0) return 0;
        if(val[now]>x) return smaller(x,c[now][0]);
        if(val[now]<x) return smaller(x,c[now][1])+siz[c[now][0]]+1;
        return siz[c[now][0]];
    }
    inline int fd(int x,int now)
    {
        siz[0]=0;
        if(now==0)return now;
        if(val[now]<x)return fd(x,c[now][1]);
        if(val[now]>x)return fd(x,c[now][0]);
        return now;
    }
    inline void del(int x,int &root)
    {
        siz[0]=0;
        x=fd(x,root);
        siz[0]=0;
        splay(x,root);
        if(!c[x][0])
        {
            root=c[x][1];
            fa[c[x][1]]=0;
            siz[0]=0;
            up(c[x][1]);
            return ;
        }
        int now=c[x][0];
        while(c[now][1])
            now=c[now][1];
        splay(now,root);
        c[now][1]=c[x][1]; fa[c[x][1]]=now;
        siz[0]=0;
        up(now);
    }
}
int la[1000001];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>col[i];
        for(int j=i;j<=n;j+=lb(j))
            sp::ins(la[col[i]],rt[j]);
        st::ins(col[i],i);
        la[col[i]]=i;
    }
    char opt;
    int x,y;
    pair<int,int>ret;
    while(m--)
    {
        cin>>opt>>x>>y;
        int now=0,anss=0;
        if(opt=='Q')
        {
            for(int j=y;j>0;j-=lb(j))
                anss+=sp::smaller(x,rt[j]);
            for(int j=x-1;j>0;j-=lb(j))
                anss-=sp::smaller(x,rt[j]);
            cout<<anss<<endl;
        }
        else
        {
            ret=st::fd(col[x],x);
            for(int j=x;j<=n;j+=lb(j))
                sp::del(ret.first,rt[j]);
            for(int j=ret.second;j<=n;j+=lb(j))
                sp::del(x,rt[j]),sp::ins(ret.first,rt[j]);
            st::del(col[x],x);
            st::ins(y,x);
            col[x]=y;
            ret=st::fd(y,x);
            for(int j=x;j<=n;j+=lb(j))
                sp::ins(ret.first,rt[j]);
            for(int j=ret.second;j<=n;j+=lb(j))
                sp::del(ret.first,rt[j]),sp::ins(x,rt[j]);
        }
    }
    return 0;
}

```



------------

### 带修改莫队：
带修改的加一维时间轴(l,r,t)   
大佬们已经讲的十分详细了，  
就是在普通莫队上加一个最近的修改即可  
我只是更正一下块最优大小，
理论最优应是 pow(n,2.0/3.0)
### code:
```
#include<bits/stdc++.h>
using namespace std;
const int N=50005;
int col[N],n,m,sum[1000005],be[N];
int ANS,qnum,cnum,ans[N];
struct qs{
    int l,r,t,id;
}q[N];
struct cs{
    int x,i;
}c[N];
bool cmp(qs x,qs y)
{
    if(be[x.l]!=be[y.l])return x.l<y.l;
    if(be[x.r]!=be[y.r])return x.r<y.r;
    return x.t<y.t;
}
void upd1(int x)
{
    if(!sum[col[x]])
        ++ANS;
    ++sum[col[x]];
}
void upd2(int x)
{
    --sum[col[x]];
    if(!sum[col[x]])
        --ANS;
}
int l,r,now;
void change(int x)
{
    if(c[x].i<=r && c[x].i>=l)
    {
        --sum[col[c[x].i]];
        if(!sum[col[c[x].i]])
            --ANS;
        if(!sum[c[x].x])
            ++ANS;
        ++sum[c[x].x];
    }
    swap(c[x].x,col[c[x].i]);
}
int main()
{
    cin>>n>>m;
    int xx=pow(n,2.0/3.0);
    char opt; 
    for(int i=1;i<=n;i++)
    {
        cin>>col[i];
        be[i]=i/xx+1;
    }
    for(int i=1;i<=m;i++)
    {
        cin>>opt;
        if(opt=='Q')
        {
            ++qnum;
            cin>>q[qnum].l>>q[qnum].r;
            q[qnum].t=cnum;
            q[qnum].id=qnum;
        }
        else
        {
            ++cnum;
            cin>>c[cnum].i>>c[cnum].x;
        }
    }
    sort(q+1,q+qnum+1,cmp);
    l=r=ANS=now=0;
    for(int i=1;i<=qnum;i++)
    {
        while(l<q[i].l)upd2(l++);
        while(l>q[i].l)upd1(--l);
        while(r>q[i].r)upd2(r--);
        while(r<q[i].r)upd1(++r);
        while(now<q[i].t)change(++now);
        while(now>q[i].t)change(now--);
        ans[q[i].id]=ANS;
    }
    for(int i=1;i<=qnum;i++)
        cout<<ans[i]<<endl;
    return 0;
}
```


---

## 作者：yzhang (赞：7)

## [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9991671.html)

莫队实际很简（du）单（liu）

依照某位dalao的说法，就是两只小手（two-pointers）瞎跳

## 一.莫队（静态莫队）

我们以[Luogu P3901 数列找不同](https://www.luogu.org/problemnew/show/P3901)为例讲一下静态莫队

这道题是个绿题，因为数据比较弱，但真是一道良心的莫队练手题

莫队是由前国家队队长莫涛发明的

莫队算法的精髓就是通过合理地对询问排序，然后以较优的顺序暴力回答每个询问。处理完一个询问后，可以使用它的信息得到下一个询问区间的答案。~~（两个小手瞎跳）~~

考虑这个问题：对于上面这道题，我们知道区间[1,5]每个数的数量，如何求出[2,6]每个数的数量

算法1：暴力扫一遍~~（废话）~~

算法2：珂以在区间[1,5]的基础上，去掉位置1（即将左端点右移一位），加上位置6（即将右端点右移一位），得到区间[2,6]的答案。

如果按这样写，一种很简单的构造数据就能把时间复杂度把算法2也送上天：先询问[1,2]，再询问[99999,100000],多重复几次就gg

但莫队算法是算法2的改进版

要进行合理的排序，使得每两个区间的距离最小

但如何进行合理的排序？

莫队提供了这样一个排序方案：将原序列以$\sqrt n$为一块进行分块（**分块的大小也珂以调整**），排序第一关键字是询问的左端点所在块的编号，第二关键字是询问的右端点本身的位置，都是升序。然后我们用上面提到的“移动当前区间左右端点”的方法，按顺序求每个询问区间的答案，移动每一个询问区间左右端点可以求出下一个区间的答案。

这就是一般的莫队排序

```cpp
inline bool cmp(register query a,register query b)
{
	return a.bl==b.bl?a.r<b.r:a.bl<b.bl;
}
```

但由于出题人过于~~毒瘤~~

又多出一种优化，叫做奇偶优化

**按奇偶块排序**。这也是比较通用的。如果区间左端点所在块不同，那么就直接按左端点从小到大排；如果相同，奇块按右端点从小到大排，偶块按右端点从大到小排。

```cpp
inline bool cmp(register query a,register query b)
{
    return a.bl!=b.bl?a.l<b.l:((a.bl&1)?a.r<b.r:a.r>b.r);
}
```

莫队核心代码qaq：

```cpp
sort(q+1,q+m+1,cmp); //讲询问按上述方法排序 
int l=1,r=0; //当前左端点和右端点初值（两只小手two-pointers） 
for(register int i=1;i<=m;++i) //对排序后的询问一个个转移 
{
	int ll=q[i].l,rr=q[i].r; //本次询问的区间 
	//转移，++--这些东西比较容易写错，需要注意 
	while(l<ll)
		del(l++);
	while(l>ll)
		add(--l);
	while(r<rr)
		add(++r);
	while(r>rr)
		del(r--);
	ans[q[i].id]=sth; //询问是排过序的，存到答案数组里需要返回原顺序 
}
```

这样就可以求出答案了！

——可是，这样做的复杂度是什么？

#### 大约是$O(n\sqrt n)$

Luogu P3901 AC代码：

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define N 100005
using namespace std;
inline int read()
{
	register int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
int v[N],blocksize=0;
struct query{
	int l,r,id,bl;
}q[N];
int sum[N];
bool ans[N];
int cnt=0;
inline void add(register int x)
{
	if(++sum[v[x]]==1)
		++cnt; 
}
inline void del(register int x)
{
	if(--sum[v[x]]==0)
		--cnt;
}
inline bool cmp(register query a,register query b)
{
    return a.bl!=b.bl?a.l<b.l:((a.bl&1)?a.r<b.r:a.r>b.r);
}
int main()
{
	memset(sum,0,sizeof(sum));
	int n=read(),m=read();
	blocksize=sqrt(n);
	for(register int i=1;i<=n;++i)
		v[i]=read();
	for(register int i=1;i<=m;++i)
	{
		int l=read(),r=read();
		q[i]=(query){l,r,i,(l-1)/blocksize+1};
	}
	sort(q+1,q+m+1,cmp);
	int l=1,r=0;
	for(register int i=1;i<=m;++i)
	{
		int ll=q[i].l,rr=q[i].r;
		while(l<ll)
			del(l++);
		while(l>ll)
			add(--l);
		while(r<rr)
			add(++r);
		while(r>rr)
			del(r--);
		ans[q[i].id]=(cnt==rr-ll+1)?1:0;
	}
	for(register int i=1;i<=m;++i)
		if(ans[i])
			puts("Yes");
		else
			puts("No");
	return 0;
 } 
```

### 例题：

1.[Luogu P3901 数列找不同](https://www.luogu.org/problemnew/show/P3901)

[~~讲解比上面暴力~~](https://www.cnblogs.com/yzhang-rp-inf/p/9971041.html )

2.[Luogu CF375D Tree and Queries](https://www.luogu.org/problemnew/show/CF375D)

[树链剖分后跑莫队](https://www.cnblogs.com/yzhang-rp-inf/p/9954741.html )

## 二.动态莫队（单点修改）

写完了上面这道题，可以发现：普通的莫队算法没有支持修改。那么如何改造该算法使它支持修改呢？

莫队俗称**优雅的暴力**

我们以[Luogu P1903 [国家集训队]数颜色 / 维护队列](https://www.luogu.org/problemnew/show/P1903)讲解一下动态莫队

那么我们改造莫队算法的思路也只有一个：改造询问排序的方式，然后继续暴力。

首先我们需要把查询操作和修改操作**分别**记录下来。

在记录查询操作的时候，需要增加一个变量来记录离本次查询**最近的修改**的位置

然后套上莫队的板子，与普通莫队不一样的是，你需要用一个变量记录当前已经进行了几次修改

每次回答询问时，先从上一个询问的时间“穿越”到当前询问的时间：如果当前询问的时间更靠后，则顺序执行所有修改，直到达到当前询问时间；如果当前询问的时间更靠前，则“时光倒流”，还原所有多余的修改。进行推移时间的操作时，如果涉及到当前区间内的位置的修改，要对答案进行相应的维护。

排序有三个关键字：

#### 1.左端点所在块数 2.右端点所在块数 3.在这次修改之前查询的次数

```cpp
inline bool cmp(register query a,register query b)
{
	return a.bll!=b.bll?a.bll<b.bll:(a.blr!=b.blr?a.blr<b.blr:a.pre<b.pre);
}
```

完整代码，代码中有详细注释

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define N 50005
using namespace std;
inline int read()
{
	register int x=0,f=1;register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}
inline void write(register int x)
{
	if(!x)putchar('0');if(x<0)x=-x,putchar('-');
	static int sta[25];int tot=0;
	while(x)sta[tot++]=x%10,x/=10;
	while(tot)putchar(sta[--tot]+48);
}
struct change{    //记录修改操作的结构体，place为修改的位置，pre是修改之前的值，suf是修改之后的值 
	int place,pre,suf;
}cg[N];
struct query{     //记录查询操作的结构体，l，r为查询左右端点，pre表示之前有过几次修改，id表示这是第几次查询，bll，blr表示左右端点所在的块 
	int l,r,pre,id,bll,blr;
}q[N];
int a[N],blocksize=0,p[1000001],ans[N];
inline bool cmp(register query a,register query b) //按上述三个关键字排序 
{
	return a.bll!=b.bll?a.bll<b.bll:(a.blr!=b.blr?a.blr<b.blr:a.pre<b.pre);
}
int main()
{
	int n=read(),m=read(),tota=0,totb=0;
	for(register int i=1;i<=n;++i)
		a[i]=read();
	for(register int i=1;i<=m;++i)
	{
		char ch=getchar();
		while(ch!='R'&&ch!='Q')
			ch=getchar();
		if(ch=='R') //修改 
		{
			cg[++tota].place=read(),cg[tota].suf=read();
			cg[tota].pre=a[cg[tota].place]; //为了方便先在原数组上修改 
			a[cg[tota].place]=cg[tota].suf;
		}
		else
		{
			int l=read(),r=read();
			q[++totb]=(query){l,r,tota,totb,0};
		}
	}
	blocksize=ceil(exp((log(n)+log(tota))/3)); //奇妙的块的大小 
	for(register int i=1;i<=totb;++i)
		q[i].bll=(q[i].l-1)/blocksize+1,q[i].blr=(q[i].r-1)/blocksize+1;
	for(register int i=tota;i>=1;--i) //还原数组 
		a[cg[i].place]=cg[i].pre;
	sort(q+1,q+totb+1,cmp); //排序 
	int l=1,r=0,num=0,ti=0;
	for(register int i=1;i<=m;++i)
	{
		int ll=q[i].l,rr=q[i].r,t=q[i].pre;
	    //正常莫队操作 
		while(ll<l)
			num+=!p[a[--l]]++;
		while(ll>l)
			num-=!--p[a[l++]];
		while(rr>r)
			num+=!p[a[++r]]++;
		while(rr<r)
			num-=!--p[a[r--]];
		while(t<ti) //当本次查询时修改的次数小于已经修改的次数，时光倒流 （还原修改） 
		{
			int pla=cg[ti].place;
			if(l<=pla&&pla<=r)
				num-=!--p[a[pla]];
			a[pla]=cg[ti--].pre;
			if(l<=pla&&pla<=r)
				num+=!p[a[pla]]++;
		}
		while(t>ti) //当本次查询时修改的次数大于已经修改的次数，穿越 （把该修改的修改） 
		{
			int pla=cg[++ti].place;
			if(l<=pla&&pla<=r)
				num-=!--p[a[pla]];
			a[pla]=cg[ti].suf;
			if(l<=pla&&pla<=r)
				num+=!p[a[pla]]++;
		}
		ans[q[i].id]=num;
	}
	for(register int i=1;i<=totb;++i)
	{
		write(ans[i]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：一只小兵 (赞：6)

## 思路
    对区间进行查询，并进行单点修改，可以考虑使用带修莫队来解决
---------------
## 前置知识


     确保已经清楚普通莫队的用法和原理
提供一道普通莫队的模板题：
[P2709 小B的询问](https://www.luogu.org/problem/P1903)

~~这里安利一下我的[blog](https://www.luogu.org/blog/I-O-I/solution-p2709)~~



--------
## 带修改莫队

    理解了莫队之后，再来看看能不能将莫队带上修改

1. 普通莫队是只移动l,r指针,并不会考虑修改某个值,而带修莫队需要克服的问题就是如何在移动指针的过程中来进行对队列修改的维护操作.

2. 对于普通莫队,只考虑了对区间范围的维护.那么带修莫队可以增加一个时间轴来进行对区间的维护.

3. 对于查询一个区间,我们可以先用普通莫队找到需要查找的区间段然后在时间轴上进行移动,直到到达我们想求的区间.(移动是O(1)的)

### ~~又㕛双叒叕~~用图来展示一下过程
    起初的区间                                     按照普通莫队，先对区间分快，对讯问排序
![起初的区间](https://cdn.luogu.com.cn/upload/pic/70434.png) ![区间分块](https://cdn.luogu.com.cn/upload/pic/70437.png)


区别于普通莫队,我们需要维护一个时间轴(不同时间的区间不用分别存储)

![维护时间轴](https://cdn.luogu.com.cn/upload/pic/70439.png)

这时候后就可以开始进行区间查询了
    
------    
由于篇幅有限,所以这里只模拟对区间6的查询 

初始化莫队

![开始莫队](https://cdn.luogu.com.cn/upload/pic/70443.png)

移动右指针

![莫队1](https://cdn.luogu.com.cn/upload/pic/70451.png)

移动左指针

![莫队2](https://cdn.luogu.com.cn/upload/pic/70454.png)

移动时间轴

![莫队3](https://cdn.luogu.com.cn/upload/pic/70455.png) ![莫队4](https://cdn.luogu.com.cn/upload/pic/70456.png)

最后查询到目标区间

![莫队5](https://cdn.luogu.com.cn/upload/pic/70458.png)

--------

## 代码思路

1. 对讯问进行排序
```cpp
struct question{
	int l,r,num,time;//储存询问的区间位置.num序号,time所在时间轴 
	bool operator<(const question p1) const{
		if(i[this->l] != i[p1.l]) return i[this->l] < i[p1.l];
		if(i[this->r] != i[p1.r]){//注意对r进行分块后,令time相近的在一起 
			return this->r < p1.r;
		}
		return this->time < p1.time;
	}
}q[maxn];
```
```cpp
/*
可能有人不喜欢结构体函数,写一份cmp比较 
*/ 
struct question{
	int l,r,num,time;
};
bool cmp(question p1, question p2){
	if(i[p1.l] != i[p2.l]) return i[p1.l] < i[p2.l];
	if(i[p1.r] != i[p2.r]) return i[p1.r] < i[p2.r];
	return p1.time < p2.time;
}
```


2. 时间轴上的移动(核心)
```cpp
	for(; time_now > q[t].time ; time_now--){//将时间轴向左移动 
			c[tim[time_now].num] = tim[time_now].back;
			if(tim[time_now].num <= r_now && tim[time_now].num >= l_now) {//修改位置在维护区间内
				if(!cnt[tim[time_now].back]) ans++;
				cnt[tim[time_now].in]--;
				cnt[tim[time_now].back]++;
				if(!cnt[tim[time_now].in]) ans--;
			}
		}
		for(++time_now ; time_now <= q[t].time ; time_now++){//将时间轴向右移动 
			c[tim[time_now].num] = tim[time_now].in;
			if(tim[time_now].num <= r_now && tim[time_now].num >= l_now) {
				if(!cnt[tim[time_now].in]) ans++;
				cnt[tim[time_now].in]++;
				cnt[tim[time_now].back]--;
				if(!cnt[tim[time_now].back]) ans--;
			}
		}
```

## 最后附上AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
using namespace std;
const int maxn = 1e6+17;

long long read() {
	long long x=0;
	char ch = getchar();
	while(ch>'9'||ch<'0') {
		ch=getchar();
	}
	while(ch<='9'&&ch>='0') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}
long long a[maxn],c[maxn],i[maxn],q_m,cnt_q,cnt[maxn],cnt_time,ans,pri[maxn];
long long l_now,r_now,time_now;
struct question{
	int l,r,num,time;//储存询问的区间位置.num序号,time所在时间轴 
	bool operator<(const question p1) const{
		if(i[this->l] != i[p1.l]) return i[this->l] < i[p1.l];
		if(i[this->r] != i[p1.r]){//注意对r进行分块后,令time相近的在一起 
			return this->r < p1.r;
		}
		return this->time < p1.time;
	}
}q[maxn];
struct change{
	int num,in,back;//第num支，变成in，变回back 
}tim[maxn];
int main(){
	long long n=read(),m=read();
	q_m = pow(m,(double)2/(double)3);//当块的大小为m^(2/3)时,速度最快 
	for(int t = 1 ; t <= n ; t++){
		a[t] = c[t] = read();
		i[t] = (t-1)/q_m+1;//对位置分块
	}
	for(int t = 1 ; t <= m ; t++){
		char ch = getchar();
		if(ch == 'Q') {
			++cnt_q;
			q[cnt_q].l = read();q[cnt_q].r = read();
			q[cnt_q].time = cnt_time,q[cnt_q].num = cnt_q;//对于每次区间查询,记录下它是在哪个时间轴上 
		}
		else if(ch == 'R'){
			++cnt_time;//对每次的修改,记录下时间 
			tim[cnt_time].num=read();
			tim[cnt_time].in = read();
			tim[cnt_time].back = a[tim[cnt_time].num];
			a[tim[cnt_time].num] = tim[cnt_time].in;
		}
		else t--;
	}
	sort(q+1,q+cnt_q+1);
	for(int t = q[1].l ; t <= q[1].r ; t++){//暴力求出第一个询问答案 
		if(!cnt[c[t]]) ans++;
		cnt[c[t]]++;
	}
	l_now = q[1].l;r_now = q[1].r;
	for(int t = 0 ; t <= q[1].time ; t++){//进行时间轴上的移动 
		c[tim[t].num] = tim[t].in;
		if(tim[t].num <= r_now && tim[t].num >= l_now) {
			if(!cnt[tim[time_now].in]) ans++;
			cnt[tim[t].in]++;
			cnt[tim[t].back]--;
			if(!cnt[tim[t].back]) ans--;
		}
	}
	time_now = q[1].time;pri[q[1].num] = ans;
	for(int t = 2 ; t <= cnt_q ; t++){
		for(; time_now > q[t].time ; time_now--){//将时间轴向左移动 
			c[tim[time_now].num] = tim[time_now].back;
			if(tim[time_now].num <= r_now && tim[time_now].num >= l_now) {
				if(!cnt[tim[time_now].back]) ans++;
				cnt[tim[time_now].in]--;
				cnt[tim[time_now].back]++;
				if(!cnt[tim[time_now].in]) ans--;
			}
		}
		for(++time_now ; time_now <= q[t].time ; time_now++){//将时间轴向右移动 
			c[tim[time_now].num] = tim[time_now].in;
			if(tim[time_now].num <= r_now && tim[time_now].num >= l_now) {
				if(!cnt[tim[time_now].in]) ans++;
				cnt[tim[time_now].in]++;
				cnt[tim[time_now].back]--;
				if(!cnt[tim[time_now].back]) ans--;
			}
		}
		for( ; l_now < q[t].l ; l_now++){//普通莫队,查找对应的区间 
			cnt[c[l_now]]--;
			if(!cnt[c[l_now]]) ans--;
		}
		for(++r_now ; r_now <= q[t].r ; r_now++){
			if(!cnt[c[r_now]]) ans++;
			cnt[c[r_now]]++;
		}
		for(--l_now ; l_now >= q[t].l ; l_now--){
			if(!cnt[c[l_now]]) ans++;
			cnt[c[l_now]]++;
		}
		for(--r_now ; r_now > q[t].r ; r_now--){
			cnt[c[r_now]]--;
			if(!cnt[c[r_now]]) ans--;
		}
		l_now = q[t].l;r_now = q[t].r;time_now = q[t].time;pri[q[t].num] = ans;//对移过的位置进行修改 
	}
	for(int t = 1 ; t <= cnt_q ; t++){
		printf("%lld\n",pri[t]);
	}
	return 0;
}
```






---

## 作者：Log_x (赞：6)

###**分块解法**

（这里参考的是黄学长的做法，详见 [http://hzwer.com/2793.html](http://hzwer.com/2793.html)）

如果不考虑修改操作，我们可以用类似区间众数的方法求解，但加入修改就显得麻烦了。

我们可以考虑记录两个数组 lst[],pr[]：

· pr[i] 表示前一个和 i 相同颜色的画笔的所在位置

· lst[i] 表示颜色为 i 的画笔之前最后出现的位置，用于更新pr[i]

那么，询问 [l, r]：

· 对于不完整的块，暴力判断：当 pr[i] < l  时，则当前区间没有画笔和 i 颜色相同，我们将记录的答案++

（黄学长的博客中 pr[i] < r 应该属于笔误）

· 对于完整的块，我们用类似 [教主的魔法](https://www.luogu.org/problem/show?pid=2801) 的做法，将 pr[i] 存入另一个数组排序，然后以 l 为界二分，则区间分界左边都满足 pr[i] < l，计入答案即可

但还有一个问题，修改操作似乎只能暴力重构了，但我们注意到题目中 **修改操作不多于1000次** 且 N≤10000，M≤10000，因此暴力可以卡过。（不过我这里的写法和黄学长不太一样，黄学长是一旦发现 pr[] 值改变就重新对所在块排序，但我是将这些改变情况合并到一个个块内处理，个人认为要快些）

最后附上**代码：**









```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 1e4 + 5, M = 105;
int bl[M], br[M], a[N], tr[N], pr[N], lst[N * M];
int n, m, s, S, Q;
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void Flag(const int x)
{
    int L = bl[x], R = br[x];
    for (int i = L; i <= R; ++i) tr[i] = pr[i];
    sort(tr + L, tr + R + 1);
}
inline int Find(const int x, const int vi)
{
    int l = bl[x], r = br[x];
    while (l <= r)
    {
        int mid = l + r >> 1;
        if (tr[mid] < vi) l = mid + 1;
         else r = mid - 1;
    }
    return l - bl[x];
}
inline void Und(const int x, const int vi)
{
    for (int i = 1; i <= n; ++i) lst[a[i]] = 0;
    a[x] = vi; bool f; int cur;
    for (int i = 1; i <= s; ++i)
    {
        f = false;
        for (int j = bl[i]; j <= br[i]; ++j)
        {
            cur = pr[j];
            pr[j] = lst[a[j]];
            if (pr[j] != cur) f = true;
            lst[a[j]] = j;
        } 
        if (f) Flag(i);
    }
}
inline int Que(const int l, const int r)
{
    int L = (l - 1) / S + 1, R = (r - 1) / S + 1, num = 0;
    if (r - l < (S << 1))
    {
        for (int i = l; i <= r; ++i) if (pr[i] < l) num++;
        return num;
    }
    if (l == bl[L]) L--; if (r == br[R]) R++;
    int ed = br[L], st = bl[R];
    for (int i = l; i <= ed; ++i) if (pr[i] < l) num++;
    for (int i = st; i <= r; ++i) if (pr[i] < l) num++;
    for (int i = L + 1; i < R; ++i) num += Find(i, l);
    return num;
}
int main()
{
    n = get(); Q = get(); S = sqrt(n);
    int x, y; char tp;
    for (int i = 1; i <= n; ++i) a[i] = get();
    for (int i = 1; i <= n; ++i)
     if (i % S == 1) br[s] = i - 1, bl[++s] = i;
    br[s] = n; bl[s + 1] = br[s + 1] = n + 1;
    for (int i = 1; i <= n; ++i)
     pr[i] = lst[a[i]], lst[a[i]] = i;
    for (int i = 1; i <= s; ++i) Flag(i); 
    while (Q--)
    {
        while ((tp = getchar()) != 'Q' && tp != 'R');
        x = get(); y = get();
        if (tp == 'Q') put(Que(x, y)), putchar('\n');
         else Und(x, y);
    }
    return 0;
}

```

---

## 作者：zhengrunzhe (赞：4)

第一遍提交居然被拒了：重复的解法……我都翻遍五页题解了都没看到用线段树套平衡树的，要嘛是带修莫队，要嘛是bit套平衡树/分块，要嘛是树状数组套主席树，或者是其中一棵平衡树用set的，哪有跟我一样的……而且我这是用指针写的好吗

那么这里提供一篇线段树套Splay(指针)

弱化版的题目:[HH的项链](https://www.luogu.org/problemnew/show/P1972)

静态区间数颜色，用主席树就可以了，用**last[x]**表示位置x前与x颜色相同的最后一个位置，比如banana(下标以1开始)，last[6]=4，即第六个字符'a'之前的相同最近字符是第四个字符

那么只要位置pos∈[l,r]内，若**last[pos]<l**，则说明pos的颜色在区间[l,pos]中是唯一的，便可统计入答案，否则则说明pos的颜色在区间[l,pos-1]中就已出现过，不能重复累加答案

单次在log时间内计算出last[pos]<l的pos次数，主席树就好了

那么考虑这道题，动态区间数颜色，单点修改区间查询

既然带修改，单一的主席树不能用了，可以用树状数组套主席树/带修莫队，~~但是我不会~~，于是就想到我比较拿手的线段树套平衡树

按照区间线段树建树，线段树中的每个节点套上个Splay，存储对应区间内每个数的last，这样就可以单次在log时间内通过平衡树查询该区间内<l的last个数了

考虑动态修改。关键在于如何动态维护last[]。数字最大为1e6，那么就直接开1e6棵独立的Splay，第i棵Splay(以下简称R[i])存储颜色为i的所有位置。如此，在R[i]中，**位置k的前驱便是last[k]**。

平衡树使得last能够被动态维护，考虑修改之后造成的影响，把位置pos的颜色转成col(假设其原颜色为org)：

1.R[pos]中pos将被删除，其原来的前驱(pre)与后继(nxt，假设存在)将靠在一起，故，**last[nxt]将变成pre**,在树套树中便把nxt的last修改为pre

2.R[col]中将插入pos，插入后其pre与其自身将靠在一起，故**last[pos]将变成pre**，同样在树套树中修改;插入后其自身与其nxt将靠在一起，故**last[nxt]将变成pos**，同理树套树修改

询问的话只要在树套树中查询[l,r]的每个线段树节点的Splay的<l的值的个数的和即可

总复杂度均摊O(m log² n)

```cpp
#include<cstdio>
const int N=1e6+10;
int n,m,last[N],tmp[N],col[N];
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();short fh=1;
	while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
	in*=fh;
}
namespace Splay
{
	struct tree
	{
		int val,cnt,size;
		tree *fa,*son[2];
		inline const void pushup()
		{
			size=son[0]->size+cnt+son[1]->size;
		}
		inline const bool identity()
		{
			return fa->son[1]==this;
		}
	}memory_pool[N<<5],*recycle[N<<5],*tail,*null,*root[N];
	int top;
	inline const void init()
	{
		tail=memory_pool;
		null=tail++;
		null->val=null->cnt=null->size=top=0;
		null->fa=null->son[0]=null->son[1]=null;
		for (int i=1;i<N;i++)root[i]=null;
	}
	inline tree *spawn(int key)
	{
		tree *p=top?recycle[--top]:tail++;
		p->val=key;
		p->size=p->cnt=1;
		p->fa=p->son[0]=p->son[1]=null;
		return p;
	}
	inline const void erase(tree *&p)
	{
		recycle[top++]=p;
		p=null;
	}
	inline const void connect(tree *p,tree *fa,bool which)
	{
		if (p!=null)p->fa=fa;
		if (fa!=null)fa->son[which]=p,fa->pushup();
	}
	inline const void rotate(tree *p)
	{
		tree *fa=p->fa;
		bool id=p->identity();
		connect(p,fa->fa,fa->identity());
		connect(p->son[id^1],fa,id);
		connect(fa,p,id^1);
	}
	inline const void splay(tree *&root,tree *p)
	{
		for (tree *fa;(fa=p->fa)!=null;rotate(p))
			if (fa->fa!=null)
				rotate(p->identity()^fa->identity()?fa:p);
		root=p;
	}
	inline const void insert(tree *&root,int key)
	{
		if (root==null)return (void)(root=spawn(key));
		tree *now=root;
		while (1)
		{
			if (now->val==key)
				return now->cnt++,now->pushup(),splay(root,now);
			tree *fa=now;
			bool nxt=fa->val<key;
			now=fa->son[nxt];
			if (now==null)
				return now=spawn(key),connect(now,fa,nxt),splay(root,now);
		}
	}
	inline const void find(tree *&root,int key)
	{
		tree *now=root;
		while (now->son[now->val<key]!=null&&now->val!=key)
			now=now->son[now->val<key];
		splay(root,now);
	}
	inline tree *precursor(tree *&root,int key)
	{
		find(root,key);
		if (root->val<key)return root;
		tree *now=root->son[0];
		while (now->son[1]!=null)now=now->son[1];
		return now;
	}
	inline tree *successor(tree *&root,int key)
	{
		find(root,key);
		if (root->val>key)return root;
		tree *now=root->son[1];
		while (now->son[0]!=null)now=now->son[0];
		return now;
	}
	inline const void Delete(tree *&root,int key)
	{
		find(root,key);tree *p=root;
		if (p->cnt>1)return p->cnt--,p->pushup();
		if (p->son[0]==null&&p->son[1]==null)return root=null,erase(p);
		if (p->son[0]==null)return (root=p->son[1])->fa=null,erase(p);
		if (p->son[1]==null)return (root=p->son[0])->fa=null,erase(p);
		tree *pre=precursor(root,key);splay(root,pre);connect(p->son[1],pre,1);erase(p);
	}
	inline const int less(tree *&root,int key)
	{
		tree *now=root;int tot=0;
		while (now!=null)
			if (key<now->val)now=now->son[0];
			else
			{
				tot+=now->son[0]->size;
				if (now->val==key)return tot;
				tot+=now->cnt;
				now=now->son[1];
			}
		return tot;
	}
}using namespace Splay;
class Segment_Tree
{
	private:
		struct tree
		{
			Splay::tree *root;
			tree *lson,*rson;
			inline const void update(int l,int r,int pos,int key)
			{
				Delete(root,last[pos]);
				insert(root,key);
				if (l==r)return;
				int mid=l+r>>1;
				if (pos<=mid)lson->update(l,mid,pos,key);
				else rson->update(mid+1,r,pos,key);
			}
			inline const int query(int l,int r,int L,int R)
			{
				if (l>R||r<L)return 0;
				if (l>=L&&r<=R)return less(root,L);
				int mid=l+r>>1;
				return lson->query(l,mid,L,R)+rson->query(mid+1,r,L,R);
			}
		}memory_pool[N<<2],*tail;
		inline const void init()
		{
			tail=memory_pool;
		}
		inline tree *spawn()
		{
			tree *p=tail++;
			p->root=null;
			p->lson=p->rson=NULL;
			return p;
		}
	public:
		tree *root;
		inline Segment_Tree(){init();}
		inline const void build(tree *&p,int l,int r)
		{
			p=spawn();
			for (int i=l;i<=r;i++)
				insert(p->root,last[i]);
			if (l==r)return;
			int mid=l+r>>1;
			build(p->lson,l,mid);
			build(p->rson,mid+1,r);
		}
}sgt;
int main()
{
	init();
	read(n);read(m);
	for (int i=1;i<=n;i++)
		read(col[i]),
		last[i]=tmp[col[i]],
		insert(root[col[i]],tmp[col[i]]=i);
	sgt.build(sgt.root,1,n);
	char opt;int x,y;
	while (m--)
		if (scanf(" %c",&opt),read(x),read(y),opt=='R')
		{
			int pre=precursor(root[col[x]],x)->val,
				nxt=successor(root[col[x]],x)->val;
			Delete(root[col[x]],x);
			if (nxt)sgt.root->update(1,n,nxt,pre),last[nxt]=pre;
			insert(root[col[x]=y],x);
			pre=precursor(root[y],x)->val;
			nxt=successor(root[y],x)->val;
			if (nxt)sgt.root->update(1,n,nxt,x),last[nxt]=x;
			sgt.root->update(1,n,x,pre);last[x]=pre;
		}
		else
			printf("%d\n",sgt.root->query(1,n,x,y));
	return 0;
}
```

---

## 作者：_ctz (赞：3)

[进入我的blog查看](https://ctz45562.github.io/2019/03/20/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P1903-%E3%80%90-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%95%B0%E9%A2%9C%E8%89%B2-%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P1903)

安利一下既好写又美观的树套树（大雾

思路和[HH的项链](https://www.luogu.org/problemnew/show/P1972)一样，维护每个位置下一个和它相同颜色的位置$nex[i]$，查询时就找$nex[i]>R$且$L\le i\le R$的个数（$[L,R]$为待查询区间，下同）。

两个限制条件自然想到树套树。外层用线段树或树状数组维护$nex[i]$，每个节点内部开一个平衡树或动态开点线段树维护位置。查询时直接查外层$[R+1,n+1]$（这里提前把$nex[i]$为$0$的都改为$n+1$）中，内层位于$[L,R]$的数量。

不过修改比较麻烦：

记$i$为修改点，$last$为上一个和$i$颜色相同的位置（可以开数组记下来，想偷懒的话直接开平衡树查也行），$j$为$i$前面第一个颜色为要修改的颜色的位置，二元组$(x,y)$为外层为$x$，内层为$y$。修改操作就为：

- 删除$(i,last)$
- 插入$(nex[i],last)$
- 赋值$nex[last]=nex[i]$
- 删除$(nex[i],i)$
- 插入$(nex[j],i)$
- 删除$(nex[j],j)$
- 插入$(i,j)$
- 赋值$nex[i]=nex[j],nex[j]=i$

不理解的话可以画个图，观察一下一次修改操作会对$last,nex[i],j,nex[j]$产生的影响。

因为有可能$j$或$last$为$0​$，需要记一下每种颜色当前第一次出现的位置，判断修改。

线段树套线段树$2900ms$（$O_2$），树状数组套线段树$1300ms$（$O_2$）

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 50005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int n;
#define ls(x) ls[x]
#define rs(x) rs[x]
struct Treap{
	int dat[maxn<<2],ls[maxn<<2],rs[maxn<<2],siz[maxn<<2],ra[maxn<<2],cnt;
	inline void update(int node){
		siz[node]=siz[ls(node)]+siz[rs(node)]+1;
	}
	void right(int &node){
		int rec=ls(node);
		ls(node)=rs(rec);
		rs(rec)=node;
		node=rec;
		update(rs(node)),update(node);
	}
	void left(int &node){
		int rec=rs(node);
		rs(node)=ls(rec);
		ls(rec)=node;
		node=rec;
		update(ls(node)),update(node);
	}
	void insert(int &node,int d){
		if(!node){
			node=++cnt;
			ra[node]=ran(),dat[node]=d,siz[node]=1;
			return;
		}
		if(dat[node]<d){
			insert(rs(node),d);
			if(ra[rs(node)]>ra[node])left(node);
		}
		else {
			insert(ls(node),d);
			if(ra[ls(node)]>ra[node])right(node);
		}
		++siz[node];
	}
	void del(int &node,int d){
		if(dat[node]==d){
			if(ls(node)&&rs(node)){
				if(ra[ls(node)]>ra[rs(node)])right(node),del(rs(node),d);
				else left(node),del(ls(node),d);
				--siz[node];
			}
			else node=ls(node)|rs(node);
			return;
		}
		if(dat[node]<d)del(rs(node),d);
		else del(ls(node),d);
		--siz[node];
	}
	int getpre(int node,int d){
		int ans=0;
		while(node){
			if(dat[node]<d)ans=max(ans,dat[node]),node=rs(node);
			else node=ls(node);
		}
		return ans;
	}
}tr;
struct Data_Segment_Tree{
	int ls[maxn<<5],rs[maxn<<5],sum[maxn<<5],cnt;
	void add(int poi,int l,int r,int &node,int d){
		if(!node)node=++cnt;
		sum[node]+=d;
		if(l==r)return;
		int mid=l+r>>1;
		if(poi<=mid)add(poi,l,mid,ls(node),d);
		else add(poi,mid+1,r,rs(node),d);
	}
	int ask(int L,int R,int l,int r,int node){
		if(!node)return 0;
		if(L<=l&&R>=r)return sum[node];
		int mid=l+r>>1,ans=0;
		if(L<=mid)ans=ask(L,R,l,mid,ls(node));
		if(R>mid)ans+=ask(L,R,mid+1,r,rs(node));
		return ans;
	}
}dst;
#undef ls
#undef rs
/*==============树状数组套线段树===============*/
struct Binary_Indexed_Tree{
	int root[maxn];
#define lowb(x) (x&-x)
	inline void add(int x,int pl,int d){
		while(x<=n+1)dst.add(pl,1,n,root[x],d),x+=lowb(x);
	}
	inline int ask(int x,int l,int r){
		int ans=0;
		while(x)ans+=dst.ask(l,r,1,n,root[x]),x-=lowb(x);
		return ans;
	}
}bit;
int root[1000005],fir[1000005],nex[maxn],pre[1000005],a[maxn];
inline void change(int i,int d){
	if(a[i]==d)return;
	int last=tr.getpre(root[a[i]],i),j=tr.getpre(root[d],i);
	if(fir[a[i]]==i)fir[a[i]]=nex[i];
	if(last){
		bit.add(i,last,-1);
		bit.add(nex[i],last,1);
		nex[last]=nex[i];
	}
	bit.add(nex[i],i,-1);
	if(j){
		bit.add(nex[j],i,1);
		bit.add(nex[j],j,-1);
		bit.add(i,j,1);
		nex[i]=nex[j];
		nex[j]=i;
	}
	else {
		bit.add(fir[d],i,1);
		nex[i]=fir[d],fir[d]=i;
	}
	tr.del(root[a[i]],i),tr.insert(root[d],i);
	a[i]=d;
}
/*==================End====================*/
/*=========================================*/
/*==============线段树套线段树===============*/
#define ls(x) x<<1
#define rs(x) x<<1|1
struct Next_Segment_Tree{
    int root[maxn<<2];
    void add(int poi,int l,int r,int node,int pl,int d){
        dst.add(pl,1,n,root[node],d);
        if(l==r)return;
        int mid=l+r>>1;
        if(poi<=mid)add(poi,l,mid,ls(node),pl,d);
        else add(poi,mid+1,r,rs(node),pl,d);
    }
    int ask(int L,int l,int r,int node,int ll,int rr){
        if(L<=l)return dst.ask(ll,rr,1,n,root[node]);
        int mid=l+r>>1;
        return (L<=mid?ask(L,l,mid,ls(node),ll,rr):0)+ask(L,mid+1,r,rs(node),ll,rr);
    }
}nst;
int root[1000005],fir[1000005],nex[maxn],pre[1000005],a[maxn];
inline void change(int i,int d){
    if(a[i]==d)return;
    int last=tr.getpre(root[a[i]],i),j=tr.getpre(root[d],i);
    if(fir[a[i]]==i)fir[a[i]]=nex[i];
    if(last){
        nst.add(i,1,n+1,1,last,-1);
        nst.add(nex[i],1,n+1,1,last,1);
        nex[last]=nex[i];
    }
    nst.add(nex[i],1,n+1,1,i,-1);
    if(j){
        nst.add(nex[j],1,n+1,1,i,1);
        nst.add(nex[j],1,n+1,1,j,-1);
        nst.add(i,1,n+1,1,j,1);
        nex[i]=nex[j];
        nex[j]=i;
    }
    else {
        nst.add(fir[d],1,n+1,1,i,1);
        nex[i]=fir[d],fir[d]=i;
    }
    tr.del(root[a[i]],i),tr.insert(root[d],i);
    a[i]=d;
}
/*==============End===============*/
int main(){
	n=read();
	int m=read();
	for(register int i=1;i<=n;++i){
		a[i]=read(),nex[pre[a[i]]]=i,pre[a[i]]=i;
		if(!fir[a[i]])fir[a[i]]=i;
		tr.insert(root[a[i]],i);
	}
	for(register int i=1;i<=n;++i){
		if(!nex[i])nex[i]=n+1;
		bit.add(nex[i],i,1);
	}
	for(register int i=1;i<=1000000;++i)
		if(!fir[i])fir[i]=n+1;
	char s[2];
	int l,r;
	while(m--){
		scanf("%s",s);
		if(s[0]=='Q')l=read(),r=read(),printf("%d\n",bit.ask(n+1,l,r)-bit.ask(r,l,r));
		else l=read(),r=read(),change(l,r);
	}
}

```



---

## 作者：zj余能 (赞：3)

#带修改莫队讲解



##阅前提示：

拥有普通莫队的基础知识；理解莫队的思想；


##简介：

莫队支持的是离线操作，普通莫队只支持查询操作；

而带修改莫队还支持单点修改操作。


##原理：


普通莫队每一个询问有L，R，ID三个属性；因为只有查询操作，所以改变其查询顺序并不会影响算法的正确性；而加入单点修改后，就不能任意改变顺序，这会影响最终答案；带修改莫队的思路就是在查询中加一个属性TM，表示在原顺序中该查询之前离其最近的一个修改操作的ID；每次执行查询操作前都执行在它之前的修改，并将在它之后的修改操作中已执行的取消；这样就可以不改变原始的顺序了。


##实现


在存储修改操作时，使用前向星思想：PRE，COLOR，POS，分别表示前一个修改操作、该修改操作修改的颜色、操作的数；那遍历时只需依次向前即可；

在下面的程序中将会看见

for (int j=e[i-1].tm+1;j<=e[i].tm;++j)即可实现从上一个操作中可能没有被操作过的修改

for (int j=e[i-1].tm;j>=e[i].tm+1;--j)即可实现从上一个操作中可能执行过的多余的修改


附上代码：


```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;

int CL=1,CR=0,ans=0,tim,n,m,k,cnt=0,sz=0;
int color[50010],num[1000010];//num存该颜色出现的次数 
int las[50010],answer[200010];
    //las存x个数的前一个颜色，具体操作类似于前向星 
bool vis[50010];//

struct XY{ //存sz个询问 
    int L,R,id,tm;
}e[200010];
struct XX{ //存cnt个修改 
    int ps,cl,pre;
}w[200010];


bool cmp(XY a,XY b){ //莫队的排序（不清楚的可以先做莫队的模板） 
    return (a.L/tim)==(b.L/tim)? a.R<b.R : a.L<b.L;
};

void cala(int x){ //相当于莫队的Inc和dec
    if (vis[x]){
        if ((--num[color[x]])==0) --ans;
            //如果此次减掉的是最后一个，则颜色数-1 
    }else{
        if ((++num[color[x]])==1) ++ans;
            //如果是新增的数，则颜色数+1 
    }
    vis[x]=!vis[x]; //vis可以理解为一个标识符
                    //（即是否会影响或在上一次查询中） 
                    //而更新过答案后应将其重置（取反）
                    //设定为取反则在change操作中便于实现 
}  

void change(int x,int c){ //将第x个改成颜色c 
    if (vis[x]){
        cala(x);color[x]=c;cala(x);
            //假如存在x的修改可能影响正确性，则在修改
            //颜色前后都应更新答案，而两个cala则不会改变当前指针 
    }else color[x]=c;
} 

int main(){
    char cha;int x,y;
    cin >>n>>m;tim=sqrt(n);//tim是莫队的核心了吧 
    for (int i=1;i<=n;++i)
        scanf("%d",&color[i]),las[i]=color[i];//初始颜色 
    for (int i=1;i<=m;++i){
        cin >>cha;scanf("%d%d",&x,&y);
        if (cha=='R'){
            ++cnt;w[cnt].ps=x;w[cnt].cl=y;w[cnt].pre=las[x];las[x]=y;
                //前向星式存修改 
        }else{
            ++sz;e[sz].L=x;e[sz].R=y;e[sz].id=sz;e[sz].tm=cnt;
                //存询问时要加上最近一次修改的ID（tm），便于后面操作 
        }
    }
    
    sort(e+1,e+1+sz,cmp);
    
    for (int i=1;i<=sz;++i){
        for (int j=e[i-1].tm+1;j<=e[i].tm;++j)
            change(w[j].ps,w[j].cl); //将所有未修改的点修改 
        for (int j=e[i-1].tm;j>=e[i].tm+1;--j)
            change(w[j].ps,w[j].pre);//将所有已修改的点还原
                                     //（上次操作多余的修改）
        int l=e[i].L,r=e[i].R;  //下面就是普通莫队了 
        while (CL<l) cala(CL++);
        while (CL>l) cala(--CL);
        while (CR<r) cala(++CR);
        while (CR>r) cala(CR--);
        answer[e[i].id]=ans;
    }
    for (int i=1;i<=sz;++i)
        printf("%d\n",answer[i]); 
    return 0;
}
```

---

## 作者：wwyx2001 (赞：2)

带修改莫队方法：<http://blog.csdn.net/blue\_cuso4/article/details/77940771>

竞争优势：速度前几+代码60行

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <iostream>
#define N 10005
using namespace std;
int qid=0,tim=0,cx[1000005],res,block[N],ans[N],a[N];
struct ask{int l,r,t,id;}q[N];
struct chan{int x,y;}ch[1005];
int cmp(ask a,ask b){
    if (block[a.l]==block[b.l])
    {
        if (a.r==b.r) return a.t<b.t;
        else return a.r<b.r;
    }else return a.l<b.l;
}
void change(int now,int i)
{
    if (ch[now].x>=q[i].l && ch[now].x<=q[i].r) 
    {
        cx[a[ch[now].x]]--;
        if (cx[a[ch[now].x]]==0) res--;
        if (cx[ch[now].y]==0) res++;
        cx[ch[now].y]++;            
    }
    swap(a[ch[now].x],ch[now].y);
}
int main()
{
    int n,m,i;
    scanf("%d%d",&n,&m);
    int size=sqrt(n);
    for (i=1;i<=n;i++) scanf("%d",&a[i]),block[i]=(i-1)/size+1;
    for (i=1;i<=m;i++)
    {
        int l,r;char s[5];
        scanf("%s%d%d",s,&l,&r);
        if (s[0]=='Q'){
            q[++qid].l=l; q[qid].r=r; q[qid].id=qid; q[qid].t=tim;
        }
        else ch[++tim].x=l,ch[tim].y=r;
    }
    sort(q+1,q+qid+1,cmp);
    int l=0,r=0,now=0;
    for (i=1;i<=qid;i++)
    {
        while (l<q[i].l){cx[a[l]]--;if (cx[a[l]]==0) res--; l++;}
        while (l>q[i].l){l--;if (cx[a[l]]==0) res++; cx[a[l]]++;}
        while (r<q[i].r){r++;if (cx[a[r]]==0) res++; cx[a[r]]++;}
        while (r>q[i].r){cx[a[r]]--;if (cx[a[r]]==0) res--; r--;}
        while (now<q[i].t){now++;change(now,i);}
        while (now>q[i].t){change(now,i);now--;}
        ans[q[i].id]=res;
    }
    for (i=1;i<=qid;i++)  printf("%d\n",ans[i]);
}
```

---

## 作者：Isonan (赞：2)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P1903)

带修莫队模板题。把询问看做三维的，额外维护每次询问的时间戳，转移时重现一遍修改操作。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>

int n,m,change[50001][3],count[1000001],pos[50001],block,col[50001],t,x,y,top,nowans,ans[50001];
char opt;
struct point{
    int l,r,t,o;
}num[50001];
bool cmp(point a,point b){
    if(pos[a.l]!=pos[b.l])return pos[a.l]<pos[b.l];
    if(pos[a.r]!=pos[b.r])return pos[a.r]<pos[b.r];
    return a.t<b.t; 
}
void get(){
    opt=getchar();
    while(opt!='Q'&&opt!='R')opt=getchar();
}
void del(int x){
    count[x]--;
    if(!count[x])nowans--;
}
void add(int x){
    if(!count[x])nowans++;
    count[x]++;
}
void add_to(int l,int r,int now,int nxt){
    if(now<nxt){
        for(int i=now+1;i<=nxt;i++){
            if(l<=change[i][0]&&r>=change[i][0])del(change[i][1]),add(change[i][2]);
            col[change[i][0]]=change[i][2];
        }
    }
    else{
        for(int i=now;i>nxt;i--){
            if(l<=change[i][0]&&r>=change[i][0])del(change[i][2]),add(change[i][1]);
            col[change[i][0]]=change[i][1];
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    block=(int)pow(n,0.667);
    for(int i=1;i<=n;i++)scanf("%d",col+i),pos[i]=(i-1)/block+1;
    for(int i=1;i<=m;i++){
        get();
        scanf("%d%d",&x,&y);
        if(opt=='Q')num[i-t]=(point){x,y,t,i};
        else{
            change[++t][0]=x;
            change[t][1]=col[x];
            change[t][2]=y;
            col[x]=y;
        }
    }
    top=n-t;
    std::sort(num+1,num+top+1,cmp);
    add_to(0,0,t,num[1].t);
    for(int i=num[1].l;i<=num[1].r;i++)add(col[i]);
    ans[num[1].o]=nowans;
    for(int i=2;i<=top;i++){
        add_to(num[i-1].l,num[i-1].r,num[i-1].t,num[i].t);
        if(num[i-1].l<num[i].l)for(int j=num[i-1].l;j<num[i].l;j++)del(col[j]);
        else for(int j=num[i].l;j<num[i-1].l;j++)add(col[j]);
        if(num[i-1].r<num[i].r)for(int j=num[i-1].r+1;j<=num[i].r;j++)add(col[j]);
        else for(int j=num[i].r+1;j<=num[i-1].r;j++)del(col[j]);
        ans[num[i].o]=nowans;
    }
    for(int i=1;i<=n;i++)if(ans[i])printf("%d\n",ans[i]);
}
```

---

## 作者：ww3113306 (赞：2)

表示本蒟蒻做这道题看好多题解还是没看懂

最后在某大佬＠Twilight_的指点之下

终于明白了这道题

以此鸣谢某大佬

、＼（＾ｏ＾）／～

待修改的莫队，还没做过的莫队建议先做ＨＨ的项链（板子题）

这里多了一个修改，首先我们要相信一个真理：暴力出奇迹

莫队就是相当与对暴力的一个优化，

于是对于每个询问，我们标记它的时间（也就是前面有几个修改）

然后像普通莫队一样做，如果时间不符合，那就暴力修改ｏｒ暴力撤销

比如说我们用now记录现在的X(统计到的颜色个数）是建立在哪次修改后的基础上的（即时间）

那么我们用数组存下了每个修改，并且用last存下某次修改前它要修改的那个空里面原本存的颜色

这样有点绕口，我们举个栗子：

比如原数列: 1 3 7 4 6

现在有第二次修改３　５(把第３个修改为５）

那么last[2]=7(当前数)

然后修改为：　1 3 5 4 6

这就是我们暴力向后修改的过程

如果是撤销，那就相当于是把第i次修改的位置改为last[i]即可

然后为了处理方便，我们先移动区间，最后修改颜色到目标时间

修改时注意，如果要修改的这个位置在区间内(这也是先处理区间的原因)，那么就更新ans,

否则直接修改

至于排序，，，大概是玄学复杂度吧，具体证明可以参见：

https://www.cnblogs.com/Paul-Guderian/p/6933799.html

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Ri register int
#define AC 10500
#define D printf("line in %d\n",i);
int n,m,color[AC],s[AC],block,tot,cnt,ans[AC],have[AC],X,last[AC];
int L,R,now,ll,rr,tt;
struct ABC{
	int x,w;	
}T[AC];
struct abc{
	int l,r,num,t;
}ques[AC];

inline int read()
{
	int x=0;char c=getchar();
	while(c>'9' || c<'0') c=getchar();
	while(c>='0' && c<='9')x=x*10+c-'0',c=getchar();
	return x;
}

bool cmp(abc a,abc b)
{
	if(a.l/block != b.l/block) return a.l < b.l;
	else if(a.r!=b.r) return a.r<b.r;
	else return a.t<b.t;
}

void pre()
{
	char c;
	n=read(),m=read(),block=sqrt(n);
	for(Ri i=1;i<=n;i++)  s[i]=read();
	for(Ri i=1;i<=m;i++)
	{
		cin>>c;
		if(c=='Q')
			ques[++cnt].l=read() , ques[cnt].r=read() , ques[cnt].t=tot , ques[cnt].num=cnt;
		else 
			T[++tot].x=read(),T[tot].w=read();
	}
	sort(ques+1,ques+cnt+1,cmp);
}

void change()//修改时间
{
	while(now < tt)
	{
		for(Ri j=++now;j<=tt;j++)
		{
			int go=T[j].x;
			if(!last[j]) last[j]=s[go];//存下上一个时间时的颜色，方便撤销
			if(go < L || go > R)//如果不在区间内就直接修改
				s[go]=T[j].w;
			else //不然的话在修改的同时还要更新答案
			{
				color[s[go]]--;
				if(!color[s[go]]) X--;
				s[go]=T[j].w;
				if(!color[s[go]]) X++;
				color[s[go]]++;
			} 
		}
		now=tt;
	}
	while(now > tt)
	{
		for(Ri j=now;j>tt;j--)
		{
			int go=T[j].x;
			if(go < L || go > R)
				s[go]=last[j];//改回去
			else 
			{
				color[s[go]]--;
				if(!color[s[go]]) X--;
				s[go]=last[j];
				if(!color[s[go]]) X++;//如果还没有这个颜色就统计入答案
				color[s[go]]++;			
			}
		}
		now=tt;
	}
}

void work()
{
	now=ques[1].t , L=ques[1].l , R=ques[1].r;
	for(Ri i=1;i<=now;i++)
	{ 
		int go=T[i].x;
		last[i]=s[go];//error!!!凡是修改了都要记录last
		s[go]=T[i].w;
	}
	for(Ri i=L;i<=R;i++)
	{
		if(!color[s[i]]) X++;
		color[s[i]]++;
	}
	ans[ques[1].num]=X;
	for(Ri i=2;i<=cnt;i++)//莫队
	{
		ll=ques[i].l,rr=ques[i].r,tt=ques[i].t;
		while(L < ll)
		{
			color[s[L]]--;
			if(!color[s[L]]) X--;
			++L;
		}
		while(L > ll)
		{
			if(!color[s[--L]]) X++;
			color[s[L]]++;
		}
		while(R > rr)
		{
			color[s[R]]--;
			if(!color[s[R]]) X--;
			--R;
		}
		while(R < rr)
		{
			if(!color[s[++R]]) X++;
			color[s[R]]++;
		}
		change();//修改时间放入函数以显简洁
		ans[ques[i].num]=X;
	}
	for(Ri i=1;i<=cnt;i++) printf("%d\n",ans[i]);
}

int main()
{
	freopen("in.in","r",stdin);
	pre();
	work();
	fclose(stdin);
	return 0;
}
```

---

## 作者：ydnhaha (赞：2)

[题面](https://www.luogu.org/problemnew/show/P1903)

前排提醒：这篇题解不太是(啥玩意=。=？？？)正解，只能在O2优化后通过(O2后最快的话最慢的一个点跑了300+ms，不O2直接TLE(或许有什么手写bitset这种东西可以过=。=？))

初学分块的蒟蒻用暴力的分块卡过去了想写篇题解，dalao们轻喷=。=

直接分块+bitset，离散化后记录每块内每种颜色出现的次数，这样一次修改是$O(1)$的(不算离散化的话)。然而查询时因为要合并块，所以复杂度是整块长度之和这个级别的的(虽然有个bitset的$\frac{1}{32}$)，直接把块大小$siz$设成$sqrt(n)$做大概会比较慢。

为了提高效率，这里可以适当加大块的大小，这样块合并会变少而零散区间的统计会变多，在这个题效率会更高一点(我一开始弄了一个$n^{\frac{3}{5}}$的块大小(块最大的时候大概是660)卡过去了，最慢的点跑了600+ms，后来又试了试然后还加了个“输出优化(不知道有没有用啊=。=)”，把块大小搞成$n^{\frac{3}{4}}$跑的更快了些(块最大的时候大概是3400)，就是上面说的300ms+)

```cpp
// luogu-judger-enable-o2
#include<cmath>
#include<cstdio>
#include<cctype>
#include<bitset>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=50005,M=100005,Sq=20;
struct a
{
    int typ;
    int ll,rr;
}q[N];
int n,m,t1,t2,t3,t4,sqr,cnt,xnt,len;
int pts[Sq][2],app[Sq][M]; 
int a[N],blo[N],uni[2*N];
bitset<M> sta[Sq],qry; 
char rd[5];
inline int read()
{
    int ret=0;
    char ch=getchar();
    while(!isdigit(ch))
        ch=getchar();
    while(isdigit(ch))
        ret=(ret<<1)+(ret<<3)+(ch^48),ch=getchar();
    return ret;
}
inline void write(int x)
{
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int main()
{
    register int i,j;
    n=read(),m=read(),xnt=n;
    sqr=pow(n,0.75),pts[cnt=1][0]=1;
    for(i=1;i<=n;i++)
    {
        a[i]=read(),uni[i]=a[i];
        blo[i]=(i-1)/sqr+1;
        if(i%sqr==0)
        {
            pts[cnt++][1]=i;
            pts[cnt][0]=i+1; 
        }
    }
    pts[cnt][1]=n; 
    for(i=1;i<=m;i++)
    {
        scanf("%s",rd),t1=read(),t2=read();
        q[i].ll=t1,q[i].rr=t2,q[i].typ=(rd[0]=='R');
        if(q[i].typ) uni[++xnt]=t2;
    }
    sort(uni+1,uni+1+xnt),len=unique(uni+1,uni+1+xnt)-uni-1;
    for(i=1;i<=n;i++)
    {
        a[i]=lower_bound(uni+1,uni+1+len,a[i])-uni;
        if(++app[blo[i]][a[i]]==1) sta[blo[i]][a[i]]=true;
    }
    for(i=1;i<=m;i++)
    {
        t1=q[i].ll,t2=q[i].rr;
        if(q[i].typ)
        {
            int bel=blo[t1],newc=lower_bound(uni+1,uni+1+len,t2)-uni;
            if(!(--app[bel][a[t1]])) sta[bel][a[t1]]=false;
            if(++app[bel][newc]==1) sta[bel][newc]=true; a[t1]=newc;
        }
        else 
        {
            qry.reset(),t3=blo[t1],t4=blo[t2];
            if(t3!=t4)
            {
                for(j=t1;j<=pts[t3][1];j++) qry[a[j]]=true;
                for(j=pts[t4][0];j<=t2;j++) qry[a[j]]=true;
                for(j=t3+1;j<=t4-1;j++) qry|=sta[j];
            }
            else for(j=t1;j<=t2;j++) qry[a[j]]=true;
            write((int)qry.count()),puts("");
        }
    }
    return 0;
} 
```

---

## 作者：封禁用户 (赞：1)

看了楼下的题解，表示什么都看不懂（我没学过普通莫队。。）

于是决定写份题解。。

原版莫队：

**时间复杂度O(n\*√n)**，不支持修改，就拿本题为例：

如果我们知道(L,R)区间有多少个不同颜色，我们就可以在O(1)的时间求出(L,R+1)或(L+1,R)或(L-1,R)或(L,R-1)的值

举个例子，

5个数，颜色分别为2 3 1 4 5

我们知道(2,3)的答案为2，要知道(2,4)的答案，我们只需要判断color[4]是否出现过，如果否，那么ans++。无论如何，标记color[4]出现的次数+1。

莫队是一个离线算法，被称为优雅的暴力。

这个算法只是把所有询问记录下来，然后交换回答的顺序，按上面的算法去做。

从(L,R)转移到(L1,R1)的时间复杂度是|L1-L|+|R1-R|，可以证明，整个程序时间复杂度O(n\*√n)。
那么怎么交换顺序呢？

只需要先将每个询问的左端点分块，分成√n块，每块√n，最后多出的新开一块，

然后按左端点所在块的序号（L/sqrt(n)）为第一关键词，右端点为第二关键词排序就行了。

排序完直接按之前说的转移状态就行了。

至于带修改莫队，我们需要加一个记录询问的变量X，表示在这个询问之前进行了多少次修改。

并且要记录每次修改，修改的位置，修改前的颜色，修改后的颜色。

和普通莫队一样处理，

当碰到一个询问需要X次修改，而当前只执行了X-3次修改，我们就要执行那3次修改。

同样地，如果当前已经执行了X+3次修改，我们就要倒退3次修改。

大概就是这样。。

可以证明时间复杂度O(n^3/5)

代码丑，，因为我改了太久，，很烦。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const int maxn=10010;
const int maxm=10010;
struct Ask{      //记录询问
    int L,R,X,id,lk;        //L,R询问区域，lk左端点所在块
}A[maxm];
struct Do{        //记录修改
    int x,f,t;      //x位置，f原来的颜色，t修改后的颜色
}D[maxm];
int l,r,a[maxn],n,m,color[maxn],ans,len,m1,m2,x,Ans[maxm],c[maxn];
char ch;
void move(int now,int mode){               
    color[a[now]]+=mode;
    if(!color[a[now]]&&mode==-1) ans--;
    if(color[a[now]]==1&&mode==1) ans++;
}
int cmp(const Ask &A,const Ask &B){
    if(A.lk==B.lk) return A.R<B.R;
    return A.lk<B.lk;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    len=(int)sqrt(n);   //块的大小
    rep(i,1,n)
       cin>>a[i],c[i]=a[i];      //把a数组备份
    rep(i,1,m){
       cin>>ch;
       if(ch=='Q'){
         cin>>A[++m1].L;             //m1询问次数
         cin>>A[m1].R;
         A[m1].X=m2;
         A[m1].id=m1;
         A[m1].lk=(A[m1].L-1)/len+1;  
       }
       else{       //m2修改次数
         cin>>D[++m2].x;     //修改的位置
         D[m2].f=a[D[m2].x];  //保存原来的颜色
         cin>>D[m2].t;       //读入修改后的颜色
         a[D[m2].x]=D[m2].t;  //修改颜色
       }
    }
    rep(i,1,n) a[i]=c[i];   //把a数组还原
    color[a[1]]=1;
    ans=1;
    l=r=1;
    sort(A+1,A+m1+1,cmp);    //把询问排序
    rep(i,1,m1){   //一个一个处理
                         //莫队
       while(x<A[i].X){                //x是已执行的修改
         Do tmp=D[++x];
         if(l<=tmp.x&&r>=tmp.x){
           color[a[tmp.x]]--;
           ans-=!color[a[tmp.x]];
           a[tmp.x]=tmp.t;
           color[a[tmp.x]]++;
           ans+=color[a[tmp.x]]==1;
         }
         a[tmp.x]=tmp.t;
       }
       while(x>A[i].X){
         Do tmp=D[x--];
         if(l<=tmp.x&&r>=tmp.x){
           color[a[tmp.x]]--;
           ans-=!color[a[tmp.x]];
           a[tmp.x]=tmp.f;
           color[a[tmp.x]]++;
           ans+=color[a[tmp.x]]==1;
         }
         a[tmp.x]=tmp.f;
       }
       Ask tmp=A[i];
       while(l<tmp.L) move(l-0,-1),l++;       //普通莫队
       while(l>tmp.L) move(l-1,+1),l--;
       while(r<tmp.R) move(r+1,+1),r++;
       while(r>tmp.R) move(r+0,-1),r--;
       Ans[tmp.id]=ans;
    }
    rep(i,1,m1) printf("%d\n",Ans[i]);
    return 0;
}
```

---

## 作者：wzj423 (赞：1)

这里献上一份缓慢的树套树题解。

首先我们维护每一个点的pre，也就是之前一个同色的点的位置。

然后建立树状数组套主席树。

这样的话按照[这里](http://www.cnblogs.com/xzz_233/p/cogs421.html)的方法就可以用权值线段树维护了。

对于修改时候的pre，我们开1e6颗set进行暴力的维护。

由于首尾颜色的处理会很麻烦，所以我进行了插入0和N+10的边界值得操作（类似splay的区间操作），然后在树套树内进行修改时特判。

这里是lengthy的代码：
```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for(register int i=a;i<=b;++i)
#define lowbit(x) ((x)&(-x))
using namespace std;
//defs========================
int N,M;
int a[50020];
int pre[50020],nxt[50020];
int last[1000020];
//fotile_BIT_tree
struct node {
    int l,r,sum;
}T[50010*600];
int Tcnt,Root[50020];
int lid[30],lsz,rid[30],rsz;
void modify(int &id,int L,int R,int pos,int vv) {
    T[++Tcnt]=T[id];
    id=Tcnt;
    T[id].sum+=vv;
    if(L==R)    return;
    int mid=(L+R)>>1;
    if(pos<=mid) modify(T[id].l,L,mid,pos,vv);
    else         modify(T[id].r,mid+1,R,pos,vv);
}
void pre_modify(int id,int pos,int vv) {
    if(id==0||id>N)   return;
    for(int i=id;i<=N;i+=lowbit(i)) {
        modify(Root[i],1,N+2,pos,vv);
    }
}
int query(int id,int L,int R,int k) {//对单棵树进行查询,这里的L，R是值域区间 查询[1,k]
    if(L>k) return 0;
    if(R<=k)    return T[id].sum;
    int mid=(L+R)>>1;
    return query(T[id].l,L,mid,k)+query(T[id].r,mid+1,R,k);
}
int pre_query(int L,int R,int k) {//查询[L,R]之内在[1,k]的数的个数，这里的L，R是树状数组上的区间
    memset(lid,0,sizeof lid),memset(rid,0,sizeof rid),lsz=rsz=0;
    int ret=0;
    for(int i=R;i;i-=lowbit(i))     ret+=query(Root[i],1,N+2,k);//,printf("ret+=%d\n",query(Root[i],1,N+2,k));
    for(int i=L-1;i;i-=lowbit(i))   ret-=query(Root[i],1,N+2,k);//,printf("ret-=%d\n",query(Root[i],1,N+2,k));
    return ret;
}
//pre && nxt
typedef set<int>::iterator Iter;
set<int> S[1000100];
map<int,int> vis;
void init() {
    For(i,1,N) {
        S[a[i]].insert(i);
        if(!vis[a[i]]) {
            ++vis[a[i]];
            S[a[i]].insert(0),S[a[i]].insert(N+10);
        }
    }
}
void change(int pos,int col) {////////////////TODO
    if(!vis[col]) {
        ++vis[col];
        S[col].insert(0),S[col].insert(N+10);
    }
    int ori=a[pos];
    ///now deleting
    Iter it=S[a[pos]].find(pos),it_pre,it_nxt;
    it_pre=--it;++it;
    it_nxt=++it;--it;

    pre_modify(*it_nxt,pre[*it_nxt]+1,-1);
    pre_modify(*it,pre[*it]+1,-1);

    pre[*it_nxt]=*it_pre;
    nxt[*it_pre]=*it_nxt;
    pre_modify(*it_nxt,pre[*it_nxt]+1,1);
    S[a[pos]].erase(it);

    ///now adding
    a[pos]=col;
    S[a[pos]].insert(pos);
    it=S[a[pos]].find(pos);
    it_pre=--it;++it;
    it_nxt=++it;--it;

    pre_modify(*it_nxt,pre[*it_nxt]+1,-1);
    pre[*it_nxt]=*it;
    nxt[*it]=*it_nxt;
    nxt[*it_pre]=*it;
    pre[*it]=*it_pre;

    pre_modify(*it_nxt,pre[*it_nxt]+1,1);
    pre_modify(*it,pre[*it]+1,1);
}
//main=======================
int main() {
    scanf("%d%d",&N,&M);
    For(i,1,N) {
        scanf("%d",a+i);
        pre[i]=last[a[i]],nxt[pre[i]]=i,last[a[i]]=i;
    }
    init();
    For(i,1,N) pre_modify(i,pre[i]+1,1);
    while(M--) {
        char opt[30];
        scanf("%s",opt);
        switch(opt[0]) {
            case 'Q':
                int L,R;
                scanf("%d%d",&L,&R);
                printf("%d\n",pre_query(L,R,L));
                break;
            case 'R':
                int P,C;
                scanf("%d%d",P,&C);
                change(P,C);
                break;
        }
    }
    return 0;
}

```

---

## 作者：RetrO (赞：1)

这是一个莫队的题，用桶排出存两个结构体分别记录查询和修改，在输入查询的同时将G[i].pre赋值为ctot，即到现在为止需要做多少次修改，分块加上染色和莫队模版就不多说了，最重要的是在修改时直接swap就好，可以在回退的时候在交换回来。

 
  

        
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0')
    {
        if(c=='-')
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
 } 
 int n,m,k;
 int tot,ctot;
 struct edge{
     int l,r,id,pre;
 }G[100010];
 struct node{
     int where,pos;
 }C[100010];
 int a[100010];
 int bl[400010]; 
 int ans;
 int cnt[1000010];
 bool cmp(edge a,edge b)
 {
     if(bl[a.l]==bl[b.l])
     return a.r<b.r;
     else
     return bl[a.l]<bl[b.l]; 
 }
 int Add(int x)
 {
     if(cnt[x]==0)
     ans++;
     cnt[x]++;
 }
 int Del(int x)
 {
     if(cnt[x]==1)
     ans--;
     cnt[x]--;
 }
 int work(int now,int i)
 {
      if(C[now].where>=G[i].l&&C[now].where<=G[i].r)
           {
               if(--cnt[a[C[now].where]]==0)
               ans--;
               if(++cnt[C[now].pos]==1)
               ans++;
           }
               swap(C[now].pos,a[C[now].where]);                    
 }
 int bala[100010];
 void moqueue()
 {
   int L=1,R=n;
   int now=0;
   for(int i=1;i<=tot;i++)
   {
         while(L<G[i].l)Del(a[L]),L++;
      while(R>G[i].r)Del(a[R]),R--;
      while(L>G[i].l)L--,Add(a[L]);
      while(R<G[i].r)R++,Add(a[R]);
      while(now<G[i].pre) work(++now,i);
      while(now>G[i].pre)  work(now--,i);
       bala[G[i].id]=ans;      
       }    
       for(int i=1;i<=tot;i++)
        printf("%d\n",bala[i]);
 }
 int main()
 {
     n=read(),m=read();
     int blk=sqrt(n);
       for(int i=1;i<=n;i++)
        bl[i]=(i-1)/blk+1;
       for(int i=1;i<=n;i++)
     {
         a[i]=read();
          Add(a[i]);
     }
      tot=0,ctot=0;
     for(int i=1;i<=m;i++)
     {
          char b[2];
          scanf("%s",b);
          char c=b[0];
           if(c=='Q')
            G[++tot].l=read(),G[tot].r=read(),G[tot].id=tot,G[tot].pre=ctot; 
           if(c=='R')
           C[++ctot].where=read(),C[ctot].pos=read();
}
      sort(G+1,G+1+tot,cmp);
       moqueue();
       return 0;                 
}
```

---

## 作者：DrAlfred (赞：0)

摘要：带修莫队

[传送门：https://www.luogu.com.cn/problem/P1903](https://www.luogu.com.cn/problem/P1903)

## 题意

带修改，求序列的某个子段中的不同的元素个数。

## 分析思路

众所周知，莫队的核心思想是离线。然而，这题需要支持修改操作，~~那我还离线个鬼啊~~。 解决办法就是把修改也进行离线。

具体来说，我们分别存储修改和询问操作。

对于某个询问，我们用三元组 $(l, r, t)$ 来表示。其中 $l, r$ 表示询问在序列上的区间，$t$ 表示当前询问的时间，即在此询问之前进行了多少次修改操作。

首先类似普通莫队，我们对询问排序。不同的是 $l$ 和 $r$ 都要按块排序，然后再把 $t$ 从小到大排序。

这样普通莫队的操作就变成了三维莫队。我们在每次询问前进行对应时间维度修改操作的应用即可。

容易证明 $k$ 维莫队，块大小取 $\frac{n}{ \sqrt[k]m }$ 时时间复杂度最优。

时间复杂度 $O(n \times m ^ \frac{2}{3})$，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 133334;
struct Modify {
    int pos, x; // a[pos] -> x
} M[N];
struct Query {
    int l, r, t, idx;
};
char opt;
vector<Query> Q;
int n, m, q, t, l, r, a[N];
int cur, ans[N], cnt[1000010];
inline void optimizeIO(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
}
inline void init(void) {
    const int B = n / pow(m, 1.0 / 3);
    sort(Q.begin(), Q.end(), [=](Query &x, Query &y) {
        if (x.l / B != y.l / B) return x.l < y.l;
        if (x.r / B != y.r / B) return x.r < y.r;
        return (x.r / B) & 1 ? x.t < y.t : x.t > y.t;
    });
}
inline void add(int val) {
    if (cnt[val]++ == 0) ++cur;
}
inline void del(int val) {
    if (--cnt[val] == 0) --cur;
}
inline void upd(int t, int l, int r) { // 维护由于时间造成的变化
    if (l <= M[t].pos && M[t].pos <= r) {
        del(a[M[t].pos]), add(M[t].x);
    }
    // 这是一个很巧妙的操作。
    // 由于做完这次操作之后，再一次做这个操作一定是相反的操作，
    // 所以可以直接交换当前位置的值和操作更改后的值。
    swap(a[M[t].pos], M[t].x); 
}
inline void MoAlgo(void) {
    int l = 1, r = 0, t = 0; // 当前状态
    for (int i = 0; i < q; i++) {
        while (Q[i].l < l) add(a[--l]);
        while (r < Q[i].r) add(a[++r]);
        while (l < Q[i].l) del(a[l++]);
        while (Q[i].r < r) del(a[r--]);
        while (t < Q[i].t) upd(++t, l, r);
        while (Q[i].t < t) upd(t--, l, r);
        ans[Q[i].idx] = cur;
    }
}
int main(int argc, char const *argv[]) {
    optimizeIO(), cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    // q -> 询问的个数，等于 Q.size()
    // t -> 当前时间戳
    for (int i = 1; i <= m; i++) {
        cin >> opt >> l >> r;
        if (opt == 'R') M[++t] = {l, r};
        else Q.push_back({l, r, t, ++q});
    }
    init(), MoAlgo();
    for (int i = 1; i <= q; i++) {
        cout << ans[i] << '\n';
    }
    return 0;
}

```

---


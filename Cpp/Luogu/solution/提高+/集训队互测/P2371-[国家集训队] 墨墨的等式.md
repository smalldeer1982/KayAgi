# [国家集训队] 墨墨的等式

## 题目描述

墨墨突然对等式很感兴趣，他正在研究 $\sum_{i=1}^n a_ix_i=b$ 存在非负整数解的条件，他要求你编写一个程序，给定 $n, a_{1\dots n}, l, r$，求出有多少 $b\in[l,r]$ 可以使等式存在非负整数解。

## 说明/提示

对于 $20\%$ 的数据，$n \le 5$，$r \le 10$。

对于 $40\%$ 的数据，$n \le 10$，$r \le 10^6$。

对于 $100\%$ 的数据，$n \le 12$，$0 \le a_i \le 5\times 10^5$，$1 \le l \le r \le 10^{12}$。


## 样例 #1

### 输入

```
2 5 10
3 5
```

### 输出

```
5
```

# 题解

## 作者：Heartlessly (赞：55)

## Description

对于等式 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = B\ \left(B \in \left[l,r \right] \right)$，已知 $n\ (1 \leq n \leq 12)$，$a_i\ (0 \leq a_i \leq 5 \times 10^5)$，$l, r\ (1 \leq l \leq r \leq 10^{12})$，求有多少 $B$ 可以使该等式存在非负整数解。

## Solution

很容易想到 **完全背包**，用 $f_i$ 表示 $B$ 的值能否为 $i$，那么转移方程为

$$\large {f_j = f_j \mid f_{j - a_i}}$$

还可以用 $\rm bitset$ 优化，时间复杂度为 $O(\frac{nr}{w})$ 。

$l, r$ 很大，上述方法显然行不通。

我们可以分别求出 $0 \sim r$ 中符合条件的 $B$ 的数量 和 $0 \sim l - 1$ 中符合条件的 $B$ 的数量，前者减去后者即是答案。现在假设 $mn$ 是 $a_i$ 中的一个数，那么对于 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = i$，都满足 $a_1x_1 + a_2x_2 + \cdots + a_nx_n = i + k \times mn\ (k \in \rm N)$ 。在这个式子中，显然 $i$ 越小，符合条件的数就会越多。

我们可以用 $dis_i$ 表示 $B$ 模 $mn$ 等于 $i$ 时的最小值。接下来连有向边 $i \to (i + a_j) \bmod mn$，其中 $0 \leq i < mn$，边权为 $a_j$，表示从 $i$ 变为 $i + a_j$ 所花费的代价是 $a_j$ 。$0$ 到 $i$ 的最短路即是 $B$ 模 $mn$ 等于 $i$ 时的最小值。假定现在要求 $0 \sim x$ 中符合条件的 $B$ 的数量，若这个最小值不大于 $x$，则所有的 $i + k \times mn\ (i + k \times mn \leq x,k \in \rm N)$ 都符合条件，一共有 $\left \lfloor \frac{x - dis_i}{mn} \right \rfloor + 1$ 个。

所以枚举 $i$，累加就能得到答案。同时 $mn$ 取所有 $a_i$ 的最小值最优，因为这样边数最少。时间复杂度为 $O(kn\max\limits_{i = 1}^n\{ a_i \})$ 。由于特殊的连边，$\rm SPFA$ 不会被卡，可以放心使用。

我们一般称这种算法为 **同余最短路** 。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 5e5, MAXM = 6e6;
const LL INF = 1e12;
int n, m, mn = MAXN + 5, tot, a[MAXN + 5], head[MAXN + 5];
LL l, r, dis[MAXN + 5];
bool vis[MAXN + 5];
struct Edge {
    int next, to, dis;
} e[MAXM + 5];

inline void addEdge(int u, int v, int w) {
    e[++tot] = (Edge) { head[u], v, w };
    head[u] = tot;
}

inline void spfa(int s) {
    for (int i = 0; i < mn; ++i) dis[i] = INF + 1;//初始化 
    queue<int> q;
    dis[s] = 0;//满足模 mn 等于 0 的最小的 B 是 0
    q.push(s);
    for (; !q.empty(); ) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next)
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                }
            }
    }
}

inline LL query(LL x) {//求出 0 ~ x 中符合条件的 B 的数量 
    LL res = 0;
    for (int i = 0; i < mn; ++i)
        if (dis[i] <= x)
            res += (x - dis[i]) / mn + 1;//累加答案 
    return res;
}

int main() {
    read(n), read(l), read(r);
    for (int x, i = 1; i <= n; ++i) {
        read(x);
        if (x) {//a[i] = 0 可以跳过，因为没有贡献 
            a[++m] = x;
            mn = min(mn, x);//求出最小且非 0 的 a[i] 作为 mn 的值 
        }
    }
    n = m;
    for (int i = 0; i < mn; ++i)
        for (int j = 1; j <= n; ++j)
            if (a[j] != mn)//自己向自己没必要连边 
                addEdge(i, (i + a[j]) % mn, a[j]);//连有向边 
    spfa(0);//从 0 开始
    write(query(r) - query(l - 1));
    putchar('\n');
    return 0;
}
```

---

## 作者：xht (赞：37)

## 基本思想

通过同余构造某些状态，状态之间的关系类似于两点之间的带权有向边。

那么可以以此建图，将某些问题转化为最短路问题，再使用具有优秀时间复杂度的算法求解。

#### 【例题】[P3403 跳楼机](https://www.luogu.com.cn/problem/P3403)

首先可以将 $h$ 减去 $1$，同时起始楼层设为 $0$。

设 $d_i$ 为能够到达的最低的 $\bmod x = i$ 的楼层。

则有 $i \stackrel{y}{\longrightarrow} (i+y)\bmod x$ 和 $i \stackrel{z}{\longrightarrow} (i+z)\bmod x$。

像这样建图后，$d_i$ 就相当于 $0 \to i$ 的最短路，Dijkstra 即可。

最后统计时，对于 $d_i \le h$，有贡献 $\lfloor\frac{h-d_i}x\rfloor + 1$。

总时间复杂度 $\mathcal O(n \log n)$。

```cpp
const int N = 1e5 + 7;
const ll inf = (1ull << 63) - 1;
ll h, d[N], ans;
int x, y, z, v[N];
vector< pi > e[N];
pq< pair< ll, int > > q; 

int main() {
	rd(h), --h, rd(x), rd(y), rd(z);
	for (int i = 0; i < x; i++) e[i].pb(mp((i + y) % x, y)), e[i].pb(mp((i + z) % x, z)), d[i] = inf;
	d[0] = 0, q.push(mp(0, 0));
	while (q.size()) {
		int x = q.top().se;
		q.pop();
		if (v[x]) continue;
		v[x] = 1;
		for (ui i = 0; i < e[x].size(); i++) {
			int y = e[x][i].fi, z = e[x][i].se;
			if (d[y] > d[x] + z) d[y] = d[x] + z, q.push(mp(-d[y], y));
		}
	}
	for (int i = 0; i < x; i++)
		if (h >= d[i]) ans += (h - d[i]) / x + 1;
	print(ans);
	return 0;
}
```

#### 【例题】[P2371 [国家集训队]墨墨的等式](https://www.luogu.com.cn/problem/P2371)

上一题的扩展。

```cpp
const int N = 5e5 + 7;
const ll inf = 1e18;
ll l, r, d[N], ans;
int n, x, v[N];
vector< pi > e[N];
pq< pair< ll, int > > q; 

int main() {
	rd(n), rd(l), --l, rd(r), rd(x);
	for (int i = 1; i < x; i++) d[i] = inf;
	for (int i = 1, y; i < n; i++) {
		rd(y);
		for (int i = 0; i < x; i++)
			e[i].pb(mp((i + y) % x, y));
	}
	q.push(mp(0, 0));
	while (q.size()) {
		int x = q.top().se;
		q.pop();
		if (v[x]) continue;
		v[x] = 1;
		for (ui i = 0; i < e[x].size(); i++) {
			int y = e[x][i].fi, z = e[x][i].se;
			if (d[y] > d[x] + z) d[y] = d[x] + z, q.push(mp(-d[y], y));
		}
	}
	for (int i = 0; i < x; i++) {
		if (r >= d[i]) ans += (r - d[i]) / x + 1;
		if (l >= d[i]) ans -= (l - d[i]) / x + 1;
	}
	print(ans);
	return 0;
}
```

---

## 作者：QuartZ_Z (赞：22)

　  这道题果然是国家集训队的神仙题，思维独特。

　　首先若方程$ \sum_{i=1}^{n}a_ix_i=k $有非负整数解，那么显然对于每一个$ a_i $方程$ \sum_{i=1}^{n}a_ix_i=k $都必有非负整数解。于是若取$ Min=\min(a_i) $，那么对于任意$ j \in [0,min) $，若对于自然数数$ k $，$ \sum_{i=1}^{n}a_ix_i=k (k \equiv j (mod \ Min)) $有解，则对于一切自然数$ B>k(B \equiv j (mod \ Min)) $，方程$ \sum_{i=1}^{n}a_ix_i=k $都必有解。因此，我们只需对每一个$ j $求出对应的$ k $值。（我代码中实际求的是$ k/Min $，取$ Min $是为了让状态数尽可能小）

　　但是，这个值怎么求呢？根据上文，若$ \sum_{i=1}^{n}a_ix_i=k $，则我们可以尝试将$ k $分别加上每一个$ a_i $得到新的合法数值。这其实相当于对于每一个$ i \in [1,n] $，从$ k $向$ (k+a_i)mod \ Min $连一条长度为$ a_i $的边。同时，我们要使$ k $尽可能小，所以要在原图中跑最短路求解。

　　代码：

1、dijkstra+堆（这个如果dijkstra写得不好在洛谷上会tle）
```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<queue>
#include<vector>
#include<map>
#define ll long long
#define ull unsigned long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define lowbit(x) (x& -x)
#define mod 1000000000
#define inf 0x3f3f3f3f
#define eps 1e-18
#define maxn 5010
inline ll read(){ll tmp=0; char c=getchar(),f=1; for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1; for(;'0'<=c&&c<='9';c=getchar())tmp=(tmp<<3)+(tmp<<1)+c-'0'; return tmp*f;}
inline ll power(ll a,ll b){ll ans=1; for(;b;b>>=1){if(b&1)ans=ans*a%mod; a=a*a%mod;} return ans;}
inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
inline void swap(int &a,int &b){int tmp=a; a=b; b=tmp;}
struct data{
    int id,dis;
    friend bool operator < (data a,data b){
        return a.dis>b.dis;
    }
};
std::priority_queue<data>heap;
struct edge{
    int to,nxt,d;
}e[6000010];
int fir[500010],mark[500010],dist[500010];
int a[20];
int n,m,tot=0;
ll l,r;
void add(int x,int y,int z){e[tot].to=y; e[tot].d=z; e[tot].nxt=fir[x]; fir[x]=tot++;}
void dij(int S)
{
    memset(dist,0x3f,sizeof(dist));
    memset(mark,0,sizeof(mark));
    data now; now.id=S; now.dis=0; dist[S]=0; heap.push(now);
    while(!heap.empty()){
        now=heap.top(); heap.pop();
        if(mark[now.id])continue;
        mark[now.id]=1;
        for(int i=fir[now.id];~i;i=e[i].nxt)
            if(dist[e[i].to]>dist[now.id]+e[i].d){
                data tmp; tmp.id=e[i].to; tmp.dis=dist[now.id]+e[i].d;
                heap.push(tmp); dist[e[i].to]=tmp.dis;
            }
    }
}
int main()
{
    memset(fir,255,sizeof(fir));
    n=read(); l=read(); r=read();
    int mn=inf;
    for(int i=1;i<=n;i++)
        a[i]=read(),mn=min(mn,a[i]);
    for(int i=0;i<mn;i++)
        for(int j=1;j<=n;j++){
            int nxt=i+a[j];
            add(i,nxt%mn,nxt/mn);
        }
    dij(0);
//	for(int i=0;i<=n;i++)printf("%d %d\n",i,dist[i]);
    ll ans=0;
    for(int i=0;i<mn;i++)
        if(1ll*dist[i]*mn+i<=r){
        	ll L=max(dist[i]*mn+i,l),R=r;
        	if(L/mn<R/mn){
        		ans+=R/mn-L/mn-1;
        		if(L<=L/mn*mn+i&&L/mn*mn+i<=R)++ans;
        		if(L<=R/mn*mn+i&&R/mn*mn+i<=R)++ans;
            }
            else if(L<=L/mn*mn+i&&L/mn*mn+i<=R)++ans;
        }
    printf("%lld\n",ans);
}
```
2、spfa（这个就很清真了，跑得飞快）
```cpp
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<algorithm>
#include<queue>
#include<vector>
#include<map>
#define ll long long
#define ull unsigned long long
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define lowbit(x) (x& -x)
#define mod 1000000000
#define inf 0x3f3f3f3f
#define eps 1e-18
#define maxn 5010
inline ll read(){ll tmp=0; char c=getchar(),f=1; for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1; for(;'0'<=c&&c<='9';c=getchar())tmp=(tmp<<3)+(tmp<<1)+c-'0'; return tmp*f;}
inline ll power(ll a,ll b){ll ans=1; for(;b;b>>=1){if(b&1)ans=ans*a%mod; a=a*a%mod;} return ans;}
inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
inline void swap(int &a,int &b){int tmp=a; a=b; b=tmp;}
using namespace std;
struct edge{
    int to,nxt,d;
}e[6000010];
int fir[500010],inq[500010],dist[500010];
int q[10000010];
int a[20];
int n,m,tot=0;
ll l,r;
void add(int x,int y,int z){e[tot].to=y; e[tot].d=z; e[tot].nxt=fir[x]; fir[x]=tot++;}
void spfa(int S)
{
    memset(dist,0x3f,sizeof(dist));
    memset(inq,0,sizeof(inq));
    int h=1,t=1; q[1]=S; inq[S]=1; dist[S]=0;
    while(h<=t){
        for(int i=fir[q[h]];~i;i=e[i].nxt)
            if(dist[q[h]]+e[i].d<dist[e[i].to]){
                dist[e[i].to]=dist[q[h]]+e[i].d;
                if(!inq[e[i].to]){
                    q[++t]=e[i].to; inq[e[i].to]=1;
                }
            }
        inq[q[h++]]=0;
    }
}
int main()
{
    memset(fir,255,sizeof(fir));
    n=read(); l=read(); r=read();
    int mn=inf;
    for(int i=1;i<=n;i++)
        a[i]=read(),mn=min(mn,a[i]);
    for(int i=0;i<mn;i++)
        for(int j=1;j<=n;j++){
            int nxt=i+a[j];
            add(i,nxt%mn,nxt/mn);
        }
    spfa(0);
    ll ans=0;
    for(int i=0;i<mn;i++)
        if(1ll*dist[i]*mn+i<=r){
            ll L=max(dist[i]*mn+i,l),R=r;
            if(L/mn<R/mn){
                ans+=R/mn-L/mn-1;
                if(L<=L/mn*mn+i&&L/mn*mn+i<=R)++ans;
                if(L<=R/mn*mn+i&&R/mn*mn+i<=R)++ans;
            }
            else if(L<=L/mn*mn+i&&L/mn*mn+i<=R)++ans;
        }
    printf("%lld\n",ans);
}
```


---

## 作者：Aw顿顿 (赞：18)

时钟的分针向前走动了一个，屏幕里的题目静静停在一个方程上，这是米尔嘉在给同学们作报告。

我们都在看题。我认真想了五分钟，怎么看怎么是数学题——即使这样，还是有人想到了 DP，有人想到了数论，有人想到了二分，还有人更接近目的地，意识到了同余。

“我们能不能转化一下问题，把他变成两个区间求差的问题呢？”泰朵拉说。

“我知道你们都有很多的思路，但是如果我们从区间入手……”米尔嘉话音还没落，她身边的尤里举起了手。

“尤里你说。”

“米尔嘉大人，我们可以不可以再数学的基础上，用图论的思想解决这个问题呢？我觉得这个是很常见的。”

“对了，这道题其实是一道……”米尔嘉清晰的声音回荡在大厅。

“最短路。”里纱补充道。

## 同余最短路

最短路，我想。

那就先给 $a_i$ 排个序吧。

我们应该要意识到，对于 $[l,r]$ 如此之大的范围，用完全背包显然是不行的，我们可以先求出 $0\sim r$ 满足条件的 $b$，再求出 $0\sim l-1$，两个相减就可以得到我们所需的区间答案。

我们的手上有一个 $b$，这是一个可以被表示出来的 $b$，具体地：

$$\sum\limits_{i=1}^{n}a_ix_i=b$$

除了这个 $b$，我们手上什么都没有，我们要创造出新的东西，我们要让看看能有多少个 $b$。

我们可以试着将其中的 $x_1$ 增加 $1$，也就是 $x_1\gets x_1+1$。这时候我们的 $b$ 变化了——由于 $x_1$ 变化了 $1$，而它的系数是 $a_i$，所以我们的 $b$ 变成了 $b'$，满足 $b'=b+a_1$。

我们发现，如果按照这样的方法，纷繁变换各种各样的 $x_i$，我们实际上可以得到很多数。但是我们不要让事情太复杂，我们只考虑 $a_1$。如果 $b$ 是可以表示的，那么 $k\cdot a_1+b$ 一定可以表示。

我们再进一步吧。

既然他们有着相同的形式，都可以表示为 $b'=k\cdot a_1+b$，那么必然会存在 $b\bmod a_1\equiv b$，他们属于同一个同余类。我们一共有 $1,2,3\cdots a_1$ 这么多个同余类。为了对应同余类，我们可以去再 $a$ 数列中寻找一个 $a_i$ 使得 $a_i\bmod a_1\equiv p$，这个 $p$ 对应其中的某一个同余类。

接下来这一步最为巧妙。如果我们尝试用动态规划去解决这道题目，即用 $f_i$ 表示最小的 $b$ 使得 $b\bmod a_1\equiv i$——也就是找到最小的一个 $b$，使得它属于 $i$ 这个同余类。因此我们列出了一个状态转移方程：

$$\large f_{(a_j+i)\bmod a_1}=\min(f_{(a_j+i)\bmod a_1},f_i+a_j)$$

如果看不懂没有关系，我们解释一下吧。事实上，这相当于是从 $\omega$ 到达 $\omega+a_j$ 的代价是 $a_j$，所以从 $0$ 到 $i$ 的最短路即是 $b$ 模 $a_1$ 等于 $i$ 时的最小值。我们可以连有向边 $i\to (i+a_j)\bmod a_1$。因此对于我们所需解决问题的部分

于是就可以用最短路解决了，时间复杂度 $O(a_1\log a_1)$。

等等……为什么要取 $a_1$ 作为模数呢？我们排过序了，取得最小的值可以得到最少的边，这样能够提高效率，另外，我们不妨用 SPFA 吧——虽然我不能证明，但是在这种情况下连边，SPFA 不会被卡的。哦对了，Dijkstra 如果写的不大面良，说不定会被卡哦。

## 后话

“是的，这是一道同余最短路的题目。同余最短路很有意思，它本质是一类 DP，而我们如果用图论的方式认识这种题目，可能会有截然不同的认识。我们不能拘泥于表象。”

原来在我想的时候，她们已经简要分析完这道题目了。

“听得懂吗，尤里？”

她用力点了点头。



---

## 作者：ttwyzz (赞：16)

## 不愧是国家集训队的题

------------


写这道题呢，也算是有点缘分？随机跳题跳到了。

[这道题](https://www.luogu.com.cn/problem/P3403)

一道板子题，然后从此我就学会了 **同余最短路**
##### 废话不多说，上正题

所谓同余最短路，就是解决类似于这样的问题 （就是上面那一道题啦）。

### $Q\,$:有$\,n\,$个数,问在一定数值下可能组成的数的个数?

栗子:比如 $n = 3$ ，那给出的数是 $\,x\,$，$\,y\,$ ， $z\,$，求满足$\,ax + by + cz = k$中$\,k\,$的个数。（在一定范围内


这种题在数据允许的范围内，我们一般使用背包或者直接暴力，但是很可惜，这道题我们无法用这两种方法$AC$
， 那么我们来引入一个新的定义，就是我们今天的主角。
 
### 同余最短路

试想一个问题，如果说，我们只加 $\,y\,$，$\,z\,$，在允许范围内，能达到的数再加若干
个$\,x\,$都是能达到的，那么就以$\bmod \,x\,$的值做分类。

换句话来说就是，要能用若干个 $\,y\,$，$\,z\,$达到的一定能再加上$\,x\,$而达到。

那么我们就把这类题抽象成了图论题，就是以$\,n\,$个数中最小的一个作为模数（最优）。


$ \centerdot \quad i \xrightarrow{y} (i + y) \;\bmod\ x $

$ \centerdot \quad i \xrightarrow{z} (i + z) \;\bmod\ x $


------------


```
for(int i = 0; i < x; ++i)
{
	add(i, (i+y) % x , y);
	add(i, (i+z) % x , z);
}
```


------------

我们在这个图里面跑一遍最短路，样我们就求出了最小的余数为 $i$ 的能达到的数。$h$ 指上限，从 1 到 $h$。

最后统计答案。

$\sum\limits_{i=1}^{x-1} {(\dfrac{h-d_i}{x} + 1)}$



------------

```
for(int i = 0; i < x; ++i)
{
	if(d[i] <= h)
	{
		ans += (h-d[i])/x + 1;// 注意这里是有+1的
	}
}
```


------------


那么我们抽象到这题上就是将$\,h\,$变为 $\,l\,$和$\,r\,$，是闭区间那我们就在最后统计的时候~~做点手脚~~。

```
for(ll i = 0; i < w[1]; ++i)
{
	if(d[i] <= r) // 如果小于r ，就加答案 
	{
		ans += (r - d[i])/w[1] + 1;
	}
	if(d[i] < l) // 如果小于l ，说明不合法，减去这一部分 
	{
		ans -= (l - 1 - d[i])/w[1] + 1;
	}
}
```

最后，你们最爱的全套代码
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 5e6 + 20;

int n;
ll w[15];
ll h,ans;
ll d[maxn];
ll l,r; 
bool v[maxn];


struct N{
	int to,net,va;
}a[maxn << 2];
int head[maxn];
int cnt;

void add(int x,int y,int w)
{
	a[++cnt].to = y;
	a[cnt].net = head[x];
	a[cnt].va = w;
	head[x] = cnt;
}

void SPFA()
{
	memset(v,0,sizeof v);
	memset(d,0x3f3f3f3f,sizeof d);
	queue<int> q;
	q.push(0);
	v[0] = 1;
	d[0] = 0;// 注意从0开始，因为基数为 0，换句话说就是，余数从0开始算 
	while(!q.empty())
	{
		int from = q.front(); q.pop();
		v[from] = 0;
		for(int i = head[from]; i; i = a[i].net)
		{
			int to = a[i].to;
			int va = a[i].va;
			if(d[to] > d[from] + va)
			{
				d[to] = d[from] + va;
				if(!v[to])
				{
					v[to] = 1;
					q.push(to);
				}
			}
		}
	}
}



int main()
{
	scanf("%d%lld%lld",&n,&l,&r);
	for(int i = 1; i <= n; ++i)	scanf("%lld",&w[i]);
	sort(w+1,w+n+1);
	for(ll i = 0; i < w[1]; ++i)
	{
		for(int j = 2; j <= n; ++j)
		{
			add(i, (i+w[j]) % w[1] , w[j]);
		}
	}
	SPFA();
	for(ll i = 0; i < w[1]; ++i)
	{
		if(d[i] <= r) // 如果小于r ，就加答案 
		{
			ans += (r - d[i])/w[1] + 1;
		}
		if(d[i] < l) // 如果小于l ，说明不合法，减去这一部分 
		{
			ans -= (l - 1 - d[i])/w[1] + 1;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
完结撒花！

---

## 作者：Moeebius (赞：9)

> 鸣谢：[魏老师](https://www.cnblogs.com/alex-wei/p/17531487.html) 提供的神仙思路！

考虑暴力。记 $f_i$ 表示 $i$ 这个数能否用题目中的规则表示出来。显然，转移是一个完全背包的形式。

发现题目中 $a_i$ 很小，但值域很大。考虑如下事实：
> 如果 $f_i = 1$，那么 $\forall j\in a,\ f_{i+j} = 1$。

所以我们并不需要求出所有的 $f_i$！

我们从 $a$ 中选出一个常数，记为 $M$。我们并不用计算出所有 $f_i$，而是令 $g_i=\min\{j\ |\ f_j=1\land j\,\text{mod}\,M=i\}$。这样，$f_i=1$ 的充要条件就是 $g_{i\,\text{mod}\,j}\le j$，并且状态数被优化到了 $O(\max\{a_i\})$。

考虑转移。

暴力的转移即为 $g_{i+a_j} \leftarrow g_i + a_j$。

注意到对于一个状态 $g_i$，转移一圈回到自己一定是不优秀的（因为每次代价非负），并且每个 $a_j$ 转移时形成了 $\gcd(a_j,M)$ 个环。

因此，对于每个 $a_i$，只有可能在这 $\gcd(a_j,M)$ 个环上转移，实现时，我们在每个环上找到最小值，绕着环转一圈即可；或者也可以任取一个起点，绕着环走两圈（因为这样涵盖了从每个点出发的情况）。

计算出 $g$ 数组之后，就可以直接计算答案了！对于 $g_i$，其对 $[0, V]$ 答案的贡献为 $\max\{0,\dfrac{V-g_i}{M} + 1\}$，差分计算即可。

时间复杂度 $O(NM)$。

实现时注意特判 $a_i = 0$ 的情况。 

```cpp
constexpr ll MAXN = 5e5 + 5;
ll n, l, r, f[MAXN];
vector<int> a;
il void solver_main() {
  read(n, l, r);
  For(i, 1, n) {
    int x;
    read(x);
    if (x)
      a.emplace_back(x);
  }
  if (a.empty())
    return puts("0"), void();
  sort(a.begin(), a.end());

  int M = a[0], len = a.size(); // 选取最小值做 M，减小常数
  fill(f, f + M, 1e18 + 5);
  f[0] = 0;
  For(i, 1, len - 1) {
    int lim = __gcd(M, a[i]) - 1; // 环的数量
    For(j, 0, lim) {
      for (int cur = j, cnt = 0; cnt < 2; cnt += cur == j) { // 转两圈
        int nxt = (cur + a[i]) % M;
        f[nxt] = min(f[nxt], f[cur] + a[i]), cur = nxt;
      }
    }
  }

  ll ans = 0;
  For(i, 0, M - 1) {
    if (r >= f[i])
      ans += (r - f[i]) / M + 1;
    if (l > f[i])
      ans -= (l - f[i] - 1) / M + 1;
  }

  cout << ans << endl;
}
```

---

## 作者：wkjwkj (赞：6)

对于本题，我们可以采用**同余最短路**的算法来求解。

首先可以来看一下这一题，[P3403 跳楼机](https://www.luogu.com.cn/problem/P3403)。

对于本题，我们可以采用类似的状态设计。

我们设计状态 $d[i]$，表示令 $x \bmod y=i$ 的最小 $x$ 值是多少。（$y$ 的选取我们会在下面再讲解）

根据同余的性质，我们显然有转移 $d[(i+j)\bmod y]=d[i]+j$，满足余数可加性。

这种转移有很多种，我们显然要取最小值。

这令我们想到了用最短路来求解。

对于每一个 $i$ $(0\le i\le y-1)$ 我们可以用 $a[p](1\le p\le n)$ 去转移。即在 $i$ 与 $(i+a[p])$ 间连一条长度为 $a[p]$ 的边，直接以 $0$ 为起点跑最短路即可。

接下来我们来讲 $y$ 的意义，对于 $y$ 实际上是以 $y$ 构建剩余系，不使用 $y$ 的情况下，用其他数构建出其余数，最后只使用 $y$ 对 $d[i]$ 操作。所以 $y$ 其实可以是 $a$ 数组中的任意非零数，为了使最短路中点数最少，我们一般会选取 $a$ 中的最小非零整数。

接下来的问题就很好解决了，我们利用前缀和思想，求出 $r$ 中的答案与 $l-1$ 的答案相减即可。

每个余数对答案的贡献即为 $(o-d[i])/y+1$，显然这种统计不会带来重复。

$\mathtt{AC}$ 代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MP make_pair
#define F first
#define S second
#define PA pair<ll,int>
using namespace std;
int n;
ll l,r;
int a[20];
const int M=6000005;
int Next[M],ver[M],head[M];
ll edge[M];
ll d[M];
int vis[M];
int mod=1e9;
int tot;
void add(int x,int y,int z)
{
	Next[++tot]=head[x],head[x]=tot;
	ver[tot]=y,edge[tot]=z;
}
priority_queue<PA,vector<PA>,greater<PA> > q;
void dijkstra()
{
	memset(d,0x3f,sizeof d);
	d[0]=0;
	q.push(MP(d[0],0));
	while(q.size())
	{
		int x=q.top().S;
		q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i],z=edge[i];
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				q.push(MP(d[y],y));
			}
		}
	}
}
ll ans;
int m;
int main()
{
	scanf("%d%lld%lld",&n,&l,&r);
	l--;
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		if(x)a[++m]=x;
	}
	n=m;
	if(n==0){
		puts("0");
		return 0;
	}
	sort(a+1,a+n+1);
	mod=a[1];
	for(int i=1;i<=n;i++)
	  for(int j=0;j<mod;j++)
	    if(a[i]!=mod)add(j,(j+a[i])%mod,a[i]);
	dijkstra();
	for(int i=0;i<mod;i++)
	{
		if(r>=d[i])ans+=(r-d[i])/mod+1;
		if(l>=d[i])ans-=(l-d[i])/mod+1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：4)

一个比较简单的 trick。似乎网上现在只有两道题（[跳楼机](https://www.luogu.com.cn/problem/P3403) 和 [墨墨的等式](https://www.luogu.com.cn/problem/P2371)）。干脆就来写一下吧。

## 同余最短路

通过同余构造一些状态，状态 $x \to y$ 相当于图上点 $x$ 连上一条有向带权的边至 $y$。

因此可通过此方法建图跑最短路，以此达到解决问题的效果。

### [【例题】跳楼机](https://www.luogu.com.cn/problem/P3403)

有四种操作，分别为：

- 向上跳 $x$ 层；   
- 向上跳 $y$ 层；   
- 向上跳 $z$ 层；   
- 回到第 $1$ 层。

给定最高楼层 $h$，问可以到达多少不同的楼层。

---

先假设 $x < y < z$。

定义 $d_i$ 为只通过操作 $2,3$ 能够达到的最低楼层 $p$，并且满足 $p \ \bmod x =i$。

不难得到两个状态：

- $i \stackrel{y}{\longrightarrow}[(i+y) \ \bmod x]$；
- $i \stackrel{z}{\longrightarrow}[(i+z) \ \bmod x]$。

只要我们求出 $d_0,d_1,\dots,d_{x-1}$，答案就显而易见了。在此基础下我们只需要跳到不能再跳，对于答案累加就行了。显然能够证明跳的楼层不会重复。答案即为：

$$\sum_{i=0}^{x-1} \lfloor \frac{(h-d_i)}{x} \rfloor +1$$

注：这里需要加一的原因是现在所处的楼层也要算一次。

现在的最主要问题是 $d_i$ 如何求出。

联想到最短路，最短路的转移是：

$$i \stackrel{val}{\longrightarrow}j$$

这个转移实际上和题目要求的状态是相像的，我们只需要令 $i,[(i+y) \ \bmod x]$ 与 $[(i+z) \ \bmod x]$ 为点，$y,z$ 为权值就能够转移了。

定义到这里，显然的，$d_i$ 就是 $1 \to i$ 的最短路。直接使用最短路算法即可。这里使用的 Dijkstra 算法。但是这种题推荐使用 SPFA，这样建图是不会被卡的。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct Edge{
	LL v,val;
	Edge(){}
	Edge(LL V,LL VAL){v=V,val=VAL;}
};
struct Point{
	LL val;
	int s;
	Point(){}
	Point(LL VAL,int S){val=VAL,s=S;}
	bool operator < (Point another) const {return val<another.val;}
};
vector<Edge> G[100005];
LL h,d[100005];
int x,y,z;
void Dijkstra(LL s)
{
	memset(d,63,sizeof d);
	d[1]=1;
	priority_queue<Point> Q;
	Q.push(Point(1,s));
	while(!Q.empty())
	{
		Point now=Q.top();
		Q.pop();
		int p=now.s;
		LL val=now.val;
		if(val<d[p])	continue;
		for(unsigned int i=0;i<G[p].size();++i)
		{
			if(G[p][i].val+d[p]<d[G[p][i].v])
			{
				d[G[p][i].v]=G[p][i].val+d[p];
				Q.push(Point(d[G[p][i].v],G[p][i].v));
			}
		}
	}
}
int main(){
	scanf("%lld %d %d %d",&h,&x,&y,&z);
	if(x==1 || y==1 || z==1)	return printf("%lld",h)&0;
	int a[5];
	a[1]=x,a[2]=y,a[3]=z;
	sort(a+1,a+4);
	x=a[1],y=a[2],z=a[3];
	for(int i=0;i<x;++i)	G[i].emplace_back(Edge((i+y)%x,y)),G[i].emplace_back(Edge((i+z)%x,z));
	Dijkstra(1);
	LL ans=0;
	for(int i=0;i<x;++i)	if(d[i]<=h)	ans+=(h-d[i])/x+1;
	printf("%lld",ans);
	return 0;
}
```

### [【拓展】墨墨的等式](https://www.luogu.com.cn/problem/P2371)

题意：

给定 $a_1,a_2,\dots,a_n,l,r,n$，求有多少个 $b \in [l,r]$，使得等式存在非负整数解。

与上题相差不大，唯一的变化是求有多少个 $b \in [l,r]$ 满足条件，实际上等同于分别求有多少个 $b \in [1,r]$ 满足条件和有多少个 $b \in [1,l-1]$ 满足条件。然后 Dijkstra 写丑的被卡了。

区别在于上题有 $3$ 个上楼的操作，这个题有 $n$ 个。照常建图就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
LL read()
{
	LL x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
struct Edge{
	int v,val;
	Edge(){v=val=0;}
	Edge(int V,int VAL){v=V,val=VAL;}
};
struct Point{
	int val,s;
	Point(){val=s=0;};
	Point(int VAL,int S){val=VAL,s=S;}
	bool operator < (Point another) const {return val<another.val;}
};
vector<Edge> G[500005];
LL l,r,d[500005];
bool vis[500005];
int n,a[15];
void Spfa(int s)
{
	memset(d,63,sizeof d);
	queue<int> Q;
	d[s]=0;
	Q.push(s);
	while(!Q.empty())
	{
		int now=Q.front();
		Q.pop();
		vis[now]=false;
		for(unsigned int i=0;i<G[now].size();++i)
		{
			int to=G[now][i].v,val=G[now][i].val;
			if(d[to]>d[now]+val)
			{
				d[to]=d[now]+val;
				if(!vis[to])	Q.push(to),vis[to]=true;
			}
		}
	}
}
LL query(LL upper)
{
	LL ans=0;
	for(LL i=0;i<a[1];++i)	if(d[i]<=upper)	ans+=(upper-d[i])/a[1]+1;
	return ans;
}
int main(){
	n=read(),l=read(),r=read();
	for(LL i=1;i<=n;++i)
	{
		a[i]=read();
		if(a[i]==1)	return write(r-l+1),0;
		if(!a[i])	--n,--i;
	}
	sort(a+1,a+1+n);
	LL p=unique(a+1,a+1+n)-a-1;
	n=p;
	if(n==1)	return write(r/a[1]-(l-1)/a[1]),0;
	for(LL i=0;i<a[1];++i)	for(LL j=2;j<=n;++j)	G[i].emplace_back(Edge((i+a[j])%a[1],a[j]));
	/*
	0 2
	1 0
	2 1
	*/
	Spfa(0);
	write(query(r)-query(l-1));
	return 0;
}
```


完。

---

## 作者：RemiliaScar1et (赞：2)

#### 解析

P3403 跳楼机 升级版。

我们可以仿照那题的经典做法，使用[**同余最短路**](https://www.luogu.com.cn/blog/Izayoimiku9/tong-yu-zui-duan-lu)解决问题。

对于所有的 $a_i$，我们先将值为 $0$ 的元素去掉，然后找到最小值，设为 $base$。

之后我们枚举所有的剩余类 $[\ i\ ]$ 和给定数组 $a_i$，按照如下方式建图。

```cpp
for(int i=0;i<base;i++)
{
    for(int j=1;j<=n;j++)
        add(i,(i+a[i])%base,a[i]);
}
```

然后在这个图上跑最短路。

这样之后，我们跑出来的最短路数组 $f[x]$ 表示的就是我们能够拼出来的最小的在剩余系 $[x]$ 中的数。

现在我们考虑如何计算 $[l,r]$ 中满足条件的数。

首先我们能够轻易计算出 $[1,x]$ 中满足条件的数：$\sum_{i=1}^{base-1}(\frac{x-f[i]}{base}+1)$。

显然的是区间满足条件的数是类型与有前缀和性质的。

所以我们只需要计算：$[1,r]$ 中满足条件的数 $-$ $[1,l-1]$ 中满足条件的数。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,int> PII;

const int N=5e6+10;

int n;
ll l,r,base=1e9;
vector<ll> a;
int head[N],ver[N<<1],nxt[N<<1],tot=0;
ll edg[N<<1];
void add(int x,int y,ll z)
{
	ver[++tot]=y; edg[tot]=z; nxt[tot]=head[x]; head[x]=tot;
}
bool vis[N];
ll f[N];
priority_queue<PII, vector<PII>,greater<PII> > q;

void dijkstra()
{
	memset(f,0x42,sizeof f);
	memset(vis,0,sizeof vis);
	f[0]=0; q.push({0,0});
	while(q.size())
	{
		int x=q.top().second;
		q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i];
			if(f[y]>f[x]+edg[i])
			{
				f[y]=f[x]+edg[i];
				q.push({f[y],y});
			}
		}
	}
}

int main()
{
	scanf("%d%lld%lld",&n,&l,&r);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		if(x) a.push_back((ll)x),base=min(base,(ll)x);
	}
	for(int i=0;i<base;i++)
	{
		for(int j=0;j<a.size();j++)
			add(i,(i+a[j])%base,a[j]);
	}
	dijkstra();
	ll ansl=0,ansr=0;
	for(int i=0;i<base;i++)
	{
		if(r>=f[i]) ansr+=(r-f[i])/base+1LL;
		if(l-1>=f[i]) ansl+=(l-1-f[i])/base+1LL;]);
	}
	printf("%lld",ansr-ansl);
	return 0;
}
```


---


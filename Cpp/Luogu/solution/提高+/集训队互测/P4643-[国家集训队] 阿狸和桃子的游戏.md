# [国家集训队] 阿狸和桃子的游戏

## 题目描述

阿狸和桃子正在玩一个游戏，游戏是在一个带权图 $G=(V,E)$ 上进行的，设节点权值为 $w(v)$，边权为 $c(e)$。游戏规则是这样的：

1. 阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。

2. 为了保证公平性，节点的个数 $N$ 为偶数。

3. 经过 $\frac{N}{2}$ 轮游戏之后，两人都得到了一个顶点集合。对于顶点集合 $S$，得分计算方式为

$$\sum_{v \in S}w(v) + \sum_{e=(u,v)\in E \land u,v\in S}c(e)$$

由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。

## 说明/提示

数据规模和约定：

对于 $40\%$ 的数据，$1 \le N \le 16$。

对于 $100\%$ 的数据，$1 \le N \le 10000$，$1 \le M \le 100000$，$-10000 \le w , c \le 10000$。

## 样例 #1

### 输入

```
4 4
6
4
-1
-2
1 2 1
2 3 6
3 4 3
1 4 5```

### 输出

```
3```

# 题解

## 作者：第一宇宙速度 (赞：57)

## 这道题之所以评价颇高，是因为思路不好得出。

#### zhx巨神告诉我们，边的权值可以均分到两个端点上。简单总结了一下他的证明：

我们先画一条边：

A --------------- C --------------- B

其中C表示边，A，B，为两个端点。设边的权值为c，A点权值为a，B点权值为B。

因为这道题要求的是桃子的得分和阿狸的的分之差，记得分之差为ans（我也不知道为什么），而A，B分别被谁染色，有四种情况：

1.桃子染色A,阿狸染色B,由题意c可以忽略，
    $ans=a-b$ ，而如果把c平分到a,b中,
    $ans=(a+c/2)-(b+c/2)=a-b$ ,相等。
    
2.桃子染色B,阿狸染色A,同上c可以忽略，
    $ans=b-a$ ，而如果把c平分到a,b中,
    $ans=(b+c/2)-(a+c/2)=b-a$ ,同样相等。
    
3.桃子染色A，B，
    由题意，c全部给桃子，
    $ans=a+b+c$ ，而如果把c平分到a,b中,
    $ans=(b+c/2)+(a+c/2)=a+b+c$ ,还是相等。

4.阿里染色A，B，
    由题意，c全部给阿狸，
    $ans=-(a+b+c)=-a-b-c$ ，而如果把c平分到a,b中,
    $ans=-[(b+c/2)+(a+c/2)]=-a-b-c$ ,依然相等。
    
   证毕。
    
   所以我们对边的权值的处理是合理的。

####     代码如下：

    
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int n,m,x,y,ans,sum,k,z,a[10001];
    int main(){
    	scanf("%d%d",&n,&m);
    	for(int i=1;i<=n;i++){
        		scanf("%d",&k);
        		a[i]=k<<1;
    	}
    	for(int j=1;j<=m;j++){
        		scanf("%d%d%d",&x,&y,&z);
        		a[x]+=z;a[y]+=z;
    	}
    	sort(a+1,a+1+n);
    	for(int i=n;i>=1;i-=2)
        		ans+=a[i]-a[i-1];
    	printf("%d",ans/2);
    	return 0;
    }

---

## 作者：AubRain (赞：22)

**简单的博弈。**

把边权转换为点权即可。具体来说，把一条边的边权各一半加到两个顶点上，然后每个人选的时候，贪心的选取点权最大的点即可。

**为什么是对的**？

如果一条边的两个顶点被同一个人选上了，那么它就会额外提供等同于边权的贡献；否则的话，两个人每人都有一半边权的收益，相当于这条边谁也没给，也是符合题意的。

代码 $13$ 行，**短得可怜**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10005],ans;
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i],a[i]<<=1;
    for(int x,y,v,i=1;i<=m;i++)
      	cin>>x>>y>>v,a[x]+=v,a[y]+=v;
    sort(a+1,a+1+n);
    while(n) ans+=a[n--]-a[n--];
    cout<<ans/2;
}
```

---

## 作者：rui_er (赞：16)

**题意简述**

我们有一个 $n$ 点 $m$ 边的无向图，有点权和边权。现在两个人将它按照自己的最优方案每次取一个点，分为两部分，求出此时他们的分差。

---

**方法分析**

边权不好处理，我们想到将它与点权合并。最容易想到的方法就是两个端点各加一半边权，这个方法也是正确的，正确性将在下方证明。

因为每个人都会按照自己的当前最优策略取，所以将整个权值排序后，编号为奇数的是一个人取的，偶数的是另一个人取的，我们只需要按照奇偶数分别算出总权值即可。

**正确性证明**

这里主要证明上面说的将边权与点权合并的正确性。

对于一条边 $e(u,v,w)$，设两端点的初始权值为 $a_u,a_v$，我们这里将两端点的权值改为了 $a_u+\frac{w}{2},a_v+\frac{w}{2}$。

情况一：$u,v$ 被同一个人取到。

此时，这个人的总权值为 $a_u+a_v+2\times\frac{w}{2}=a_u+a_v+w$，符合题意。

情况二：$u,v$ 被两人分别取到。

不妨设 $u$ 被第一个人取到。

此时，第一个人权值为 $a_u+\frac{w}{2}$，第二个人权值为 $a_v+\frac{w}{2}$。最后要将答案相减，得到 $a_u-a_v$，符合题意。

综上所述，这种方法正确。

---

**代码与备注**

在这份代码中，我们排序后按照从小到大顺序循环取值。由于题面保证 $n$ 为偶数，因此这个方法也没有问题。

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4+5;

int n, m; 
double a[N], s[2];

int main() {
	scanf("%d%d", &n, &m);
	for(int i=1;i<=n;i++) scanf("%lf", &a[i]);
	for(int i=1;i<=m;i++) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		a[u] += w / 2.0;
		a[v] += w / 2.0; 
	}
	sort(a+1, a+1+n);
	for(int i=1;i<=n;i++) s[i&1] += a[i];
	printf("%.0lf\n", s[0]-s[1]);
	return 0;
}
```

---

## 作者：philosopherchang (赞：8)

第一句，说实话，蒟蒻看不懂那个什么顶点集合S的得分表达式（还一看就晕）。

但是这道题，看到边的权值我就想到了“平分到点”（常理嘛），然后事实证明我蒙对了。假如说桃子把一条边上的两个点都染色了，那么桃子一定获得的是k1+k2+c，同理，阿狸也是，如果各染一个，按照“平分”的公平思想，那么一定是各得权值的一半分值，c/2-c/2=0，所以分值之差就为k1-k2，与c无关；并且题目中并没有说桃子选一个点，然后只能以这个点为根选与遍历过的点相邻的节点，这也简化了难度，所以很容易就可以想到sort一边，然后每回取最大值；

如果我们这样想的话，代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int an[10001],n,m,a,b,c,k,bn[10001],ans;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>k;
		an[i]+=k;
	}
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>c;
		an[a]+=c/2;
		an[b]+=c/2;
	}
	sort(an+1,an+n+1);
	for(int i=n;i>=1;i--)
	{
		if(bn[i]==1)
		continue;
		else
		{
			ans+=(an[i]-an[i-1]);
			bn[i]=bn[i-1]=1;
		}
	}
	cout<<ans;
}
```
但是很不幸，它WA了；因为下取整这个东西的事，所以我们不妨把k和权值c乘2，然后再把c平分，最后把ans/2再输出，这样的结果才是准确的。

AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int an[10001],n,m,a,b,c,k,bn[10001],ans;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>k;
		an[i]+=(k<<1);
	}
	for(int i=1;i<=m;i++)
	{
		cin>>a>>b>>c;
		an[a]+=c;
		an[b]+=c;
	}
	sort(an+1,an+n+1);
	for(int i=n;i>=1;i--)
	{
		if(bn[i]==1)
		continue;
		else
		{
			ans+=(an[i]-an[i-1]);
			bn[i]=bn[i-1]=1;
		}
	}
	cout<<ans/2;
}
```

---

## 作者：听取MLE声一片 (赞：6)

这道题是我听普及组转提高组（CTSC-bushi）的一道例题。

开始说题目：

首先，点的值是很好想的，排序之后顺次取就行了，重点是**边**的问题。

边是可以平均分成两份，每份为 $c/2$ ，每一份加到点上。如果一个人取了这条边上的两个点，就是 $c/2+c/2=c$ ，满足题意。如果两个人各占了一个点，因为答案是**桃子的分数减去阿狸的分数** ，两个人的分数同时加上 $c/2$ 答案不变。

```
老师说：连个图都不用建
```

最后将点值排序，贪心累加偶数点-奇数点即可。

注意：$c/2$ 不一定是整数，只需要将整体*2，最后将结果/2即可。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ans,a[10001];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]*=2;
	}
	for(int i=1;i<=m;i++){
		int x,y,z;
		cin>>x>>y>>z;
		a[x]+=z,a[y]+=z;
	}
	sort(a+1,a+1+n);
	for(int i=n;i>=1;i-=2)
		ans+=a[i]-a[i-1];
	cout<<ans/2;
	return 0;
}

```

谢谢大家！

---

## 作者：_ajthreac_ (赞：4)

### 0.概述
本题并没有用到博弈论等奇怪的算法，评为黑主要是思维难度较大。   
[原题P4643 [国家集训队]阿狸和桃子的游戏](https://www.luogu.com.cn/problem/P4643)
### 1.解法
题中既有点权又有边权，不好处理，我们思考应如何转化。       
注意到边权的获得条件较复杂，考虑如何转为点权。      
梳理一下条件，已知：     
1.只有**同时**取到两端点时才可获得边权（点权相加应包括边权）；     
2.两人分取两端点时**不应**获得边权（点权相减应抵消边权）。     
综上所述，我们可以将边权平均分到两端点上，这样即可满足要求。    
如图，将边权 $c$ 评分至两端点 $u,v$ 上，则点权变为 $u+\frac c2,v+\frac c2$ 。
![](https://cdn.luogu.com.cn/upload/image_hosting/uc32m6xj.png)   
可以发现，无论是阿狸还是桃子同时取到两点，他们都可以获得 $u+v+c$ 的权值；若是分取两端点，则最终答案可抵消为 $u-v$ 或 $v-u$ ，故此种做法可行。   
此时将包含了边权的点权从大到小排序，双方轮流取即可。
### 2.细节
题目中没有保证边权 $c$ 为偶数，这种情况只需输入时将全部数据 $\times 2$ ，输出时再 $\div 2$ 即可。
### 3.代码
[缺省源](https://www.cnblogs.com/juruoajh/p/12632444.html)
```cpp
#define N 10010
int n,m,val[N],ans;
int main(){
	Read(n),Read(m);
	for(rg int i=1;i<=n;i++)Read(val[i]),val[i]<<=1;
	for(rg int i=1;i<=m;i++){
		int u,v,w;
		Read(u),Read(v),Read(w);
		val[u]+=w,val[v]+=w;
	}
	sort(val+1,val+1+n);
	for(rg int i=n;i>=1;i-=2){
		ans+=val[i]-val[i-1];
	}
	cout<<(ans>>1)<<endl;
	return 0;
}
```

---

## 作者：_一只蒟蒻帆_ (赞：4)

看到这道题，首先就被那个公式搞懵了，感谢同机房的RSJ大佬的点醒，一语惊醒梦中人，我瞬间顿悟：

**如果两个点有边连起来，分数就是这两个点的点权+边权；**

**如果两个点没有边连起来，分数就是这两个点的点权+点两边的边权/2（因为桃子和阿狸都想要分数，所以平分）**

于是，我们就可以画个图来理解一下这道题的样例：

![](https://t1.picb.cc/uploads/2020/01/13/k89GO6.png)

桃子取了1号点和3号点，所得分数为6+(-1)+(1+6+3+5)/2=5，阿狸取了2号点和4号点，所得分数为4+(-2)+(1+6+3+5)/2=2，两者相差3。

作为一道**博弈论**的题，我找了几组数据的规律后，不难得出一个神奇的做法：**把边权转化成点权，然后贪心取大的值，就是两个人的分数。**下面给出证明：

![](https://t1.picb.cc/uploads/2020/01/13/k895gM.png)

因为这道题要求的是桃子的得分和阿狸的的分之差，所以我们设得分之差为ans，而A，B分别被谁染色，有四种情况：

1.桃子染色A,阿狸染色B,由题意,ans=a-b,而如果把c平分到a,b中, ans=(a+c/2)-(b+c/2)=a-b,相等。

2.桃子染色B,阿狸染色A,同上c可以忽略,ans=b-a,而如果把C平分到a,b中, ans=(b+c/2)-(a+c/2)=b-a,相等。

3.桃子染色A,B,由题意,c全部给桃子,ans=a+b+c,而如果把c平分到a,b中,ans=(b+c/2)+(a+c/2)=a+b+c,相等。

4.阿狸染色A,B,由题意，c全部给阿狸,ans=-(a+b+c)=-a-b-c,而如果把c平分到a,b中,ans=-[(b+c/2)+(a+c/2)]=-a-b-c,相等。

但是，如果把边权平分会涉及到一个令人头疼的精度问题，所以，把点权*2平分，最后把答案/2，无伤大雅。

上代码：
```cpp
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;
int n,m,x,y,z,f[maxn],ansh,ansl;
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++){
		scanf("%d",&f[i]);
		f[i]<<=1;
	}
	for (int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		f[x]+=z;f[y]+=z;
	}
	sort(f+1,f+n+1);
	for (int i=1;i<=n;i+=2) ansh+=f[i];
	for (int i=2;i<=n;i+=2) ansl+=f[i];
	printf("%d",(ansl-ansh)/2);
	return 0;
}
```

谨以此篇题解纪念AC的第一道洛谷黑题（~~最水黑题~~）



---

## 作者：SIXIANG32 (赞：3)

第一道黑题祭！（  
*一个连小五都可以看得懂的题解（因为我就是小五/xyx）*   
刚开始看的时候还是一脸懵逼，在看了题解后才恍然大悟大呼简单……  
~~每一道码量少的黑题都有清奇的思路~~


------------
这道题很难看出来应该如何写，有的是边权，有的是点权，乍一看很难有思路。  
于是蒟蒻我很懵逼，在看了题解后明白了一个思路：  
**边权平分到两个顶点**  
这样就统一成顶点权惹，计算起来就很方便啦。  
我们先把点权×2，一份送给左端，一份送给右端，最后输出除以2即可。  
那么如何证明这是对的呢？


------------
设：边为$C_i$，边权为$V_i$（这里的边权指×2后的）。红集合总值为$X$ ，粉集合总值为$Y$。  
如果边权是在同一个集合里，即$\frac{V_i}{2}+\frac{V_i}{2}=V_i$，对求总值没有影响qwq  
如果边权不是在同一个集合里，由于是求相减的数，所以$(Y+\frac{V_i}{2})-(X+\frac{V_i}{2})$，$\frac{v_1}{2}$ 抵消，化简后仍然为$Y-X$。  


------------
然后我们改如何选择呢？  
显然是贪心每次选择最大点权相加！  
代码就这样呼之欲出啦！  
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[1000010];
int main()
{
	int n,m,ans=0;
	cin>>n>>m;
	for(int p=1;p<=n;p++)
		cin>>a[p],a[p]<<=1;//输入
	for(int p=1,x,y,z;p<=m;p++)
		cin>>x>>y>>z,a[x]+=z,a[y]+=z;//将点权平分到边里
	sort(a+1,a+n+1);//排序不用说
	for(int p=n;p>=1;p-=2)//贪心每次选择最大
		ans=ans+(a[p]-a[p-1]);//最大-次大，也就是桃子和阿狸每次的选择
	cout<<ans/2<<endl;//由于刚开始×了2，所以现在要除以2
}
```

---

## 作者：Soulist (赞：2)

题面：

阿狸和桃子正在玩一个游戏，游戏是在一个带权图$\rm G=(V, E)$上进行的，设节点权值为$w(v)$，边权为$c(e)$。游戏规则是这样的：

阿狸和桃子轮流将图中的顶点染色，阿狸会将顶点染成红色，桃子会将顶点染成粉色。已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。

为了保证公平性，节点的个数$\rm N$为偶数。

经过$\rm N/2$轮游戏之后，两人都得到了一个顶点集合。对于顶点集合S，得分计算方式为

$$\sum_{v \in S}w(v) + \sum_{e=(u,v)\in E \land u,v\in S}c(e)$$

由于阿狸石头剪子布输给了桃子，所以桃子先染色。两人都想要使自己的分数比对方多，且多得越多越好。如果两人都是采用最优策略的，求最终桃子的分数减去阿狸的分数。


$\rm Sol$

首先可以考虑没有边权的情况

那么就直接将点权排个序即可

如果有边权呢？

将每个边权拆成两半，一个给$u$一个给$v$

然后就会发现如果某两个点不在同一集合，那么这两点的权值差将会恰好抵消

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 1e5 + 5 ; 
int n, m ; 
double A[N], Ans ;
signed main()
{
	n = gi(), m = gi() ; 
	int x, y, z ; 
	rep( i, 1, n ) A[i] = gi() ; 
	rep( i, 1, m ) x = gi(), y = gi(), z = gi(), A[x] += 0.5 * z, A[y] += 0.5 * z ;
	sort( A + 1, A + n + 1 ) ;
	for( re int i = n; i >= 1; -- i ) {
		Ans += ( ( i & 1 ) ? -1 : 1 ) * A[i] ; 
	}
	printf("%lld\n", (int)Ans ) ;
	return 0 ;
}
```

---

## 作者：MILLOPE (赞：2)

## 题目

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190708071714889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190708071728862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070807174067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)

## 题解
- 贪心方法不太好想，但会了方法代码很简单
- 我们可以把每条边的权值分成两半加到两端点上，用新的端点权值排序，每次交替加或减即可
- 贪心思想的证明：
	1. 声明：端点$u,v$，边权$dis$，两端点权值$val_u,val_v$
	2. 若两个端点都选：获得的价值 $=val_u'+val_v'=val_u+\frac{dis}{2}+val_v+\frac{dis}{2}=val_u+val_v+dis$和原来一样
	3. 若只选一个端点：获得的价值$=val_u'-val_v'=val_u+\frac{dis}{2}-(val_v+\frac{dis}{2})=val_u-val_v$符合题意
- 所以贪心思想显然正确。

```cpp
#include <bits/stdc++.h> 
using namespace std; 
const int maxn = 1e4 + 100; 

template <typename T> 
inline void read(T &s) {
	s = 0; 
	T w = 1, ch = getchar(); 
	while (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); }
	while (isdigit(ch)) { s = (s << 1) + (s << 3) + (ch ^ 48); ch = getchar(); }
	s *= w; 
}

int n, m; 
double ans; 
double val[maxn]; 

int main() {
	read(n), read(m); 
	for (int i = 1; i <= n; ++i) scanf("%lf", &val[i]); 
	for (int i = 1; i <= m; ++i) {
		int x, y; double z; 
		read(x), read(y); scanf("%lf", &z); 
		val[x] += z / 2 * 1.0; 
		val[y] += z / 2 * 1.0;  
	}
	sort(val + 1, val + n + 1); 
	for (int i = n; i >= 1; --i) {
		if (i & 1) ans -= val[i]; 
		else ans += val[i]; 
	}
	printf("%.0lf\n", ans); 
	return 0; 
}
```

---

## 作者：Dfox (赞：1)

~~第一道黑题~~（这不是~~重点~~

一个点如果不选是0，一个点如果选是2w，一条边如果两个端点都不选也是是0，如果两个端点中只选择一个是c，如果两个端点都选是2c，所以让一个点为本身点权的二倍+所有相连的边的边权，排序后两人轮流取最大即可。

代码不到30行，相信各位神犇都能看懂。

```cpp
#include<bits/stdc++.h>  //懒人专用
using namespace std;
int ans[10001],bb[10001];
int main(){
    int n,m;
    cin>>n>>m;
    int k;
    for(int i=1;i<=n;i++){
        cin>>k;
        ans[i]+=(k<<1);//移位后补零
    }
    int a,b,c;
    for(int i=1;i<=m;i++){
        cin>>a>>b>>c;
        ans[a]+=c;
        ans[b]+=c;
    }
    sort(ans+1,ans+n+1);
    int ac=0;
    for(int i=n;i>=1;i--){
        if(bb[i]==1）{
        	continue;
        }
        else{
            ac=ac+(ans[i]-ans[i-1]);
            bb[i]=bb[i-1]=1;
        }
    }
    cout<<ac/2;  //记得/2
    return 0;
}
```



---

## 作者：jingkongwanglimiaoa (赞：0)

### 我看到这题~~的题解~~时大呼好简单！
这题就是一个要将边权转化成点权的问题，具体实现也很简单 ~~不看题解谁能想到a~~
![点权边权示意](https://shitu-query-gz.gz.bcebos.com/2020-08-04/21/3807d2526e3634c8?authorization=bce-auth-v1%2F7e22d8caf5af46cc9310f1e3021709f3%2F2020-08-04T21%3A49%3A22Z%2F300%2Fhost%2Fa87b65921cd29e22815108d76571bef030a7588c9c6c5779e9adee168986aed7)
我的理解比较感性

首先说说转换方法，点权 += 对应边权/2；

首先第一种情况非常好理解，两人各选一个点的话，每人都获得1/2的边权，在求两人得分差的情况下，这个边权相当于没有加，**因此不影响结果**

即a - b = (a + c / 2) - (b + c / 2);

那么第二种情况看起来就有点奇妙了~~可能就本蒟蒻是这样~~，一个人将这两个点都选了，但是只要把思路理顺，就会发现其中的奥妙，这个人将两个点都选了，每次都获得1/2的边权，与原先直接加上边权c是一样的

即 a + c / 2 + c / 2 = a + c，所以也**不影响结果**

总上所述，边权可以转化成点权，且**不影响结果**

这个时候问题就简单了，只需要快速排序一遍，然后将偶数点和-奇数点和的结果输出就好了

然而问题并没有结束，c / 2 不一定 为整数，这就是为什么很多犇犇题解中将点权*2结果再/2输出的原因

~~但是我个人用的double，因为本蒟蒻想不到那么深~~

好上代码吧
```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>
using namespace std;
int n,m,a,b;//w[10010]存储点权,a,b,c用于边权转化为点权 ,cnt 用来计算两边差值 
double w[10010],c,cnt = 0.0;//要用double是因为c/2可能为小数 
int main()
{
	scanf("%d %d",&n,&m);
	for (int i = 0;i < n;i++)
	{
		scanf("%lf",&w[i]);//输入点权 
	}
	for (int i = 0;i < m;i++)
	{
		scanf("%d %d %lf",&a,&b,&c);
		w[a - 1] += c / 2;//边权转化成点权 
		w[b - 1] += c / 2;//由于我是从0开始定义的数组因此要-1 
	}
	sort(w,w+n,greater<double>());//快速排序，以便之后选择最大的点,greater<int>()代表从大往小排序 
	for (int i = 0;i < n;i += 2)
	{
		cnt += w[i] - w[i + 1];
	}	
	printf("%0.lf",cnt);
	return 0;
}
```
恩你会发现我的代码较为工整


~~杜绝压行陋习免得被rxz巨神 **公 开 处 刑**~~

---

## 作者：回青绝影 (赞：0)

#### 其实这道题并不是很难……【汗】

~~也许是WC的题，所以……~~ 评分就高了不少

只要知道了边上的权值，那这道题就是入门难度了QAQ（然而，这一点在其他题解里已经讲了很清楚了！）

#### 所以——我想讲一下我对这种方法的疑惑和解决的过程 ~~（就是我太逊了）~~：
**我在做这道题时想到了一个问题就是：** 当一条边的权值很大时，而另一点的权值很大会不会对玩家产生印象呢？（因为边如果被分掉，那实际上边上的权值就流失了，于是取这个点的价值就变小了……）


如下图：
![](https://www.z4请更换图床a.net/images/2019/10/08/image75e8a209c80d57b4.png)

但有有人可能担心B会选点1，这样就可以避免边权会送给A；

但其实这种思考是大可不必的以为，这相当于B也损失了获得这条权值的可能，而且还把主动权让给了A……

所以这种吃力不讨好的事，~~聪明~~的B是不会干的，而既然B必输，他也要让利益最大化，别输的太惨……

然后上代码：（20行黑题……）

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
double z,a[100001],ans;
bool cmp(double x,double y){
	return x>y;
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%lf",&a[i]);
	for (int x,y,i=1;i<=m;i++){
		scanf("%d%d%lf",&x,&y,&z);
		a[x]+=z/2;
		a[y]+=z/2;
	}
	sort(a+1,a+1+n,cmp);
	for (int i=1;i<=n;i++)
		if (i%2==0) ans-=a[i];
		else ans+=a[i];
	printf("%.0lf",ans);
	return 0;
}
```

###### 然后……就没了……

---

## 作者：ljk123 (赞：0)

# 阿狸和桃子的游戏题解
每一道代码简单的黑题都有着诡异的思想，真不知道出题者怎么想的。

而这道题的重点在于把边权转换为点权，

此题的方式是将边权w平均分给被连接的两点u和v。

若u和v都被一人选择,则他的分数较不加边权前多了w/2+w/2=w，

若被不同的人选择,分数差多了(ans1+w/2)-(ans2-w/2)=ans1-ans2

并不会对答案有什么影响。

所以，最优策略？ 肯定选择点权最大的了。

排序后依次选择即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100006;
int n,m,t1,t2,t3;
double f[N],ans[2];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
bool cmp(double u,double v){return u>v;}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;++i) t1=read(),f[i]=1.00*t1;
    for(int i=1;i<=m;++i) t1=read(),t2=read(),t3=read(),f[t1]+=0.50000*t3,f[t2]+=0.5000000*t3;
    sort(f+1,f+n+1,cmp);
    for(int i=1;i<=n;++i) ans[i&1]+=f[i];
    t1=(int)(ans[1]-ans[0]),printf("%d\n",t1);
    return 0;
}
```


---


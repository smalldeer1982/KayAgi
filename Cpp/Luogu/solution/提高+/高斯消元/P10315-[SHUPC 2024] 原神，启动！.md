# [SHUPC 2024] 原神，启动！

## 题目描述

雷元素方碑具有如下性质：

1. 具有 $m$ 种状态，$0,1,\cdots,m-1$ 中的一种；
2. 方碑受到一次攻击会进入下一个状态（$m-1$ 的下一个状态是$0$）；
3. 某个方碑受到一次攻击时会带动其它一些方碑一起进入下一个状态。

当 $n$ 个方碑的状态相同时，解谜成功。但是小 A 觉得游戏里的方碑解谜太简单了，只需要使用刻晴的“斩尽牛杂”将元素方碑全部胡乱攻击一遍就能解谜成功，于是他开始思考更复杂的版本。

现在有 $n$ 个雷元素方碑，每个雷元素方碑有 $m$ 种状态。对于每个方碑 $i$ ，当它受到攻击时，都有 $k_i$ 个其它方碑和它一起进入下一个状态。

给定 $n$ 个雷元素方碑的初始状态 $s$ 和终止状态 $t$，请你计算需要分别攻击每个方碑多少下，才能将雷元素方碑从状态 $s$ 变换到 $t$。

如果无解请输出`niuza`。

## 样例 #1

### 输入

```
3 3
1 3
2 1 3
1 2
0 0 0
0 2 1```

### 输出

```
2 1 1```

## 样例 #2

### 输入

```
3 3
2 2 3
2 1 3
1 1
0 0 0
0 1 2```

### 输出

```
niuza```

# 题解

## 作者：lbmzxhb (赞：58)

[题目传送门](/problem/P10315)

# 思路：

假设第 $i$ 个方碑会被攻击 $x_i$ 次，  
且规定攻击第 $i$ 个方碑后会带动第 $j$ 个方碑一起进入下一个状态则 $a_{i,j}$ 为 $1$，不会带动 $a_{i,j}$ 为 $0$，  
我们便可以列出以下方程组：

$$\begin{cases}
a_{1,1}x_1+a_{2,1}x_2+\cdots+a_{n,1}x_{n}+s_1\equiv t_1&(\operatorname{mod} m)\\
a_{1,2}x_1+a_{2,2}x_2+\cdots+a_{n,2}x_{n}+s_2\equiv t_2&(\operatorname{mod} m)\\
\cdots\\
a_{1,n}x_1+a_{2,n}x_2+\cdots+a_{n,n}x_{n}+s_n\equiv t_n&(\operatorname{mod} m)
\end{cases}$$

把左边的 $s_i$ 移项到右边：

$$\begin{cases}
a_{1,1}x_1+a_{2,1}x_2+\cdots+a_{n,1}x_{n}\equiv t_1-s_1&(\operatorname{mod} m)\\
a_{1,2}x_1+a_{2,2}x_2+\cdots+a_{n,2}x_{n}\equiv t_2-s_2&(\operatorname{mod} m)\\
\cdots\\
a_{1,n}x_1+a_{2,n}x_2+\cdots+a_{n,n}x_{n}\equiv t_n-s_n&(\operatorname{mod} m)
\end{cases}$$

注意到 $a_{i,j},s_{i},t_{i}$ 和 $m$ 题目中已经给出，  
于是就可以用高斯消元法解方程了。

注意在输出的时候要 $\operatorname{mod} m$。

# Code:

```cpp
#include <iostream>
#define int long long
using namespace std;
int n, m;
int a[105][105];
inline int upd(int x) {return (x % m + m) % m;}//处理负数
inline int inv(int x) {//保证m为素数，求费马小定理逆元
	int res(1), q(m - 2);
	while (q) {
		if (q & 1) res = res * x % m;
		x = x * x % m;
		q >>= 1;
	}
	return res;
}
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		int k;
		cin >> k;
		a[i][i] = 1;//打自己的时候自己会进入下一个状态
		while (k--) {
			int x;
			cin >> x;
			a[x][i] = 1;
		}
	}
	for (int i = 1; i <= n; i++) cin >> a[i][n + 1];//a[i][n + 1]现在存的是s[i]
	for (int i = 1, x; i <= n; i++) cin >> x, a[i][n + 1] = upd(x - a[i][n + 1]);//a[i][n + 1]现在存的是t[i]-s[i]
	int r(1);
	for (int i = 1; i <= n; i++) {
		int pos(r);
		for (; pos <= n && !a[pos][i]; pos++);
		if (pos == n + 1) continue;//第i个未知数被消完 
		swap(a[r], a[pos]);
		int mul(inv(a[r][i]));
		for (int j = 1; j <= n; j++) {
			if (r != j && a[j][i]) {
				for (int k = n + 1; k >= i; k--) {
					a[j][k] = upd(a[j][k] - a[r][k] * a[j][i] % m * mul % m);
				}
			}
		}
		r++;
	}
	if (r <= n) {
		for (int i = r; i <= n; i++) {//判断无解 
			bool f(0);
			for (int j = 1; j <= n; j++) f |= a[i][j];
			if (!f && a[i][n + 1]) cout << "niuza", exit(0);//0==a且a!=0的情况一定无解 
		}
	}
	r = 1;
	for (int i = 1; i <= n; i++) {
		cout << a[r][n + 1] * inv(a[r][i]) % m << ' ';
		a[r][n + 1] = 0;
		if (!a[r][i + 1]) r++;
	}
}
```
[提交记录](/record/156451398)  
~~点个赞再走罢~~

# Update:

[2024/4/19] 修改 $\LaTeX$。  
[2024/4/20] 题解被hack，修改了代码。

---

## 作者：JustPureH2O (赞：5)

[更好的阅读体验](https://justpureh2o/articles/10315)

[题目原型谜题解法浅究](https://justpureh2o.cn/articles/9306/?keyword=%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E7%A7%A9)（$m=4$ 的情况）

[题目地址](https://www.luogu.com.cn/problem/P10315)

本题考察模意义下的高斯消元。

基本思路是，让 $1\sim n$ 号方块分别击打 $x_1\sim x_n$ 次，使得最终每个方块都朝向位置 $t_1\sim t_n$。

---

欲解决此题，首先需要为每个位置编号。定义 $a\rightarrow b,c$ 为“击打 $a$ 方块后，$a,b,c$ 均会旋转一次”。那么样例输入 #1 如下图（编号方式不唯一），红线为目标方向、初始时均在 $0$ 朝向：

![](https://cdn.luogu.com.cn/upload/image_hosting/wpqed84b.png)

假设三个方块需要击打 $x,y,z$ 次，那么可以列出以下方程组：

$$
\begin{cases}
x+y=0
\\y+z=2
\\x+y+z=1
\end{cases}
$$

但是不够严谨，因为我们没考虑“转过头”这种情况。即朝向为 $2$ 的方块旋转后会变为朝向 $0$。因此可以发现朝向存在模 $m$ 意义的同余关系。

上例方程组解得：

$$
\begin{cases}
x=-1\\y=1\\z=1
\end{cases}
$$

出现了负数，怎么处理？

根据解的意义考虑，这相当于 $x$ 往回转一次，根据同余关系可以得到，往回转 $1$ 次就相当于向前转 $m-1$ 次。因此对于负数，采取 `(x % m + m) % m` 的方式即可转化为非负数。

---

于是题目就很明了了，让我们求出如下 $n$ 元一次同余方程组的解：

$$
\begin{cases}
x_1+x_2+x_3+\dots+x_n\equiv t_1-s_1\pmod m
\\x_1+x_2+x_3+\dots+x_n\equiv t_2-s_2\pmod m
\\\vdots
\\x_1+x_2+x_3+\dots+x_n\equiv t_n-s_n\pmod m
\end{cases}
$$

因而可以用高斯消元求解。那么如何处理无数组解的情况呢？

高斯消元时我们会跳过一些零行。此时零行对应的变量就是一个自由元，可以任意赋值。

因此使用一个 `ans` 数组来存储答案，如果出现无数组解的情况，那么不管它，`ans` 数组也会自动赋值它为 $0$。

模意义下的除法显然需要用逆元解决，考虑到 $m$ 为质数，因此使用费马小定理计算。注意处处取模，答案不要忘了转化为 $[0,m)$ 内的数，还要开 `long long`。

```cpp
#include <bits/stdc++.h>
#define N 110
#define SOLVE_OK 200
#define SOLVE_NO 404
#define LUXURIOUS_CHEST 0;
#define F return
using namespace std;

typedef long long ll;

int n, m;
ll matrix[N][N];
ll ans[N];

ll qpow(ll a, ll b, int p) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res % p;
}

ll inv(ll x, int p) {
    return qpow(x, p - 2, p);
}

int gauss() {
    int rank = 0;
    for (int c = 1, r = 1; c <= n; c++) {
        int max_row = r;
        for (int i = r; i <= n; i++) {
            if (abs(matrix[i][c]) > abs(matrix[max_row][c])) {
                max_row = i;
            }
        }
        if (!matrix[max_row][c]) continue;
        if (max_row != r) swap(matrix[max_row], matrix[r]);
        for (int i = n + 1; i >= c; i--) {
            matrix[r][i] *= inv(matrix[r][c], m);
            matrix[r][i] = (matrix[r][i] % m + m) % m;
        }
        for (int i = 1; i <= n; i++) {
            if (abs(matrix[i][c]) && i ^ r) {
                for (int j = n + 1; j >= c; j--) {
                    matrix[i][j] -= matrix[i][c] * matrix[r][j];
                    matrix[i][j] = (matrix[i][j] % m + m) % m;
                }
            }
        }
        r++;
        rank++;
    }
    if (rank < n) {
        for (int i = rank + 1; i <= n; i++) {
            for (int j = 1; j <= n + 1; j++) {
                if (abs(matrix[i][j])) return SOLVE_NO;
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (abs(matrix[i][j])) {
                    ans[j] = matrix[i][n + 1];
                    break;
                }
            }
        }
        return SOLVE_OK;
    }
    for (int i = 1; i <= n; i++) ans[i] = matrix[i][n + 1];
    return SOLVE_OK;
}

void out() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n + 1; j++) {
            cerr << setw(10) << matrix[i][j];
        }
        cerr << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> m;

    for (int i = 1; i <= n; i++) matrix[i][i] = 1;
    for (int i = 1; i <= n; i++) {
        int k;
        cin >> k;
        for (int j = 1; j <= k; j++) {
            int x;
            cin >> x;
            matrix[x][i] = 1;
        }
    }
    for (int i = 1; i <= n; i++) {
        ll s;
        cin >> s;
        matrix[i][n + 1] -= s;
    }
    for (int i = 1; i <= n; i++) {
        ll t;
        cin >> t;
        matrix[i][n + 1] += t;
    }
    int res = gauss();
    out();
    if (res == SOLVE_OK) {
        for (int i = 1; i <= n; i++) cout << (ans[i] % m + m) % m << ' ';
    } else cout << "niuza" << endl;

    F LUXURIOUS_CHEST
}
```

$\texttt{The End}$

2024.10.06 修改了代码以通过 Hack 数据

---

## 作者：Imaginative (赞：3)

这么有趣的题肯定是让我们原神玩家来写题解啦。

题意简单明了，这里就不再解释。

# 思路
我们可能通过标签知道这题要用高斯消元，但是我们需要思考的是为什么会想到用高斯消元。

由于每个方碑会影响一定的方碑数，所以攻击每个方碑都会对其他方碑的状态造成约束。而一个方碑从状态 $s_i$ 变成 $t_i$，我们需要计算有哪些方碑能对 $i$ 方碑造成影响。而我们并不能直接得到其他方碑的击打次数，所以我们也无法直接计算。

我们可以设第 $i$ 个方碑会被攻击 $x_i$ 次，这样子我们刚好能够列出 $n$ 个方程的同余方程组。解方程组我们能想到什么，很明显就是高斯消元咯。方程大概长这样：
$$
\left\{
\begin{aligned}
a_{1,1}x_1+a_{1,2}x_2+a_{1,3}x_3+\dots+a_{1,n}x_n\equiv t_1-s_1\pmod m,\\
a_{2,1}x_1+a_{2,2}x_2+a_{3,3}x_3+\dots+a_{2,n}x_n\equiv t_2-s_2\pmod m,\\
\dots ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\ 
a_{n,1}x_1+a_{n,2}x_2+a_{n,3}x_3+\dots+a_{n,n}x_n\equiv t_n-s_n\pmod m,\\
\end{aligned}
\right.
$$
其中 $a_{i,j}$ 表示对 $i$ 号点来说，$j$ 点是否能影响 $i$ 点。能则为 $1$，否则为 $0$。

接下来就是高斯消元了。
# 代码
这道题代码有许多细节的，尤其是它不公开数据点让我痛不欲生。

注意一下几点：
1. 遇到负数出现，要将它转换为非负数。
2. 不要以为方程初始系数全是 $1$ 就以为没有除法出现了，该用逆元的地方还是得用。
3. 注意自己求出来的是上三角矩阵还是下三角矩阵，根据不同情况来确定循坏应该从前往后还是从后往前。
4. 如果出现无数组解，不输出无解，输出任意一组特解就行。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=205;
int n,m;
int s[N],t[N],G[N][N];
int a[N][N];
void swap_line(int x,int y){
	for(int i=1;i<=n+1;i++) swap(a[x][i],a[y][i]);
}
bool empty_line(int x,int y){
	for(int i=x;i<=n;i++) if(a[i][y]) return 0;
	return 1;
}
void exgcd(int n,int m,int &x,int &y){
	if(m==0){
		x=1,y=0;
		return;
	}
	int x1,y1;
	exgcd(m,n%m,x1,y1);
	x=y1,y=x1-n/m*y1;
}
int get_inv(int p){
	int x,y;
	exgcd(p,m,x,y);
	return (x%m+m)%m;
}
void gauss(){
	int hang=1,pos;
	for(int i=1;i<=n;i++){
		pos=hang;
		if(empty_line(pos,i)) continue;
		for(int j=hang;j<=n;j++){
			if(a[j][i]>a[pos][i]) pos=j;
		}
		swap_line(hang,pos);
		int op=get_inv(a[hang][i]);
		for(int j=1;j<=n;j++){
			if(hang==j) continue;
			for(int k=n+1;k>=i;k--) a[j][k]=(a[j][k]-(a[hang][k]*a[j][i]%m+m)%m*op%m+m)%m;
		}
		hang++;
	}
	if(hang<=n){
		for(int i=hang;i<=n;i++){
			bool flag=0;
			for(int j=1;j<=n;j++) if(a[i][j]) flag=1;
			if(!flag&&a[i][n+1]){
				cout<<"niuza";
				return ;
			}
		}
	}
	hang=1;
	for(int i=1;i<=n;i++){
		cout<<a[hang][n+1]*get_inv(a[hang][i])%m<<" ";
		a[hang][n+1]=0;
		if(!a[hang][i+1]) hang++;
	}
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int k;cin>>k;
		for(int j=1;j<=k;j++){
			int u;cin>>u;
			G[i][u]=1;
		}
	}
	for(int i=1;i<=n;i++) cin>>s[i];
	for(int i=1;i<=n;i++) cin>>t[i];
	for(int u=1;u<=n;u++){
		a[u][u]=1;
		for(int v=1;v<=n;v++){
			if(G[v][u]) a[u][v]=1;
		}
		a[u][n+1]=((t[u]-s[u])%m+m)%m;
	}
	gauss();
	return 0;
}

```

---

## 作者：Brilliant11001 (赞：2)

[更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18408820)

## [题目传送门](https://www.luogu.com.cn/problem/P10315)

### 题目大意：

有 $n$ 个石碑，每个石碑有 $0\sim m - 1$ 共 $m$ 种状态，击打一个石碑会带动其他的石碑。若当前石碑的状态是 $s$，则击打或被带动后的状态为 $(s + 1)\bmod m$。

现给定这 $n$ 个石碑的初始状态 $s_i$、每个石碑带动的石碑及末状态 $t_i$，求每个石碑至少被击打几次。

### 思路：

首先把题面意思抽象出来，令 $a_{i, j}$ 表示第 $i$ 个石碑和第 $j$ 个石碑的联系，若 $a_{i, j} = 1$，则表示击打 $j$ 会带动 $i$，若 $a_{i, j} = 0$ 表示无影响，特别的，因为击打自己就相当于带动自己，所以 $a_{i, i} = 1$。

再令 $x_i$ 表示第 $i$ 个石碑被击打的次数。

那么题面就变为了：

$$\left\{\begin{matrix}
s_1 + a_{1, 1}x_1 + a_{1, 2}x_2 + \cdots + a_{1, n}x_n \equiv t_1\pmod m\\
s_2 + a_{2, 1}x_1 + a_{2, 2}x_2 + \cdots + a_{2, n}x_n \equiv t_2\pmod m\\
\cdots\\
s_n + a_{n, 1}x_1 + a_{n, 2}x_2 + \cdots + a_{n, n}x_n \equiv t_n\pmod m
\end{matrix}\right.$$

再移个项，得：

$$\left\{\begin{matrix}
a_{1, 1}x_1 + a_{1, 2}x_2 + \cdots + a_{1, n}x_n \equiv t_1 - s_1\pmod m\\
a_{2, 1}x_1 + a_{2, 2}x_2 + \cdots + a_{2, n}x_n \equiv t_2 - s_2\pmod m\\
\cdots\\
a_{n, 1}x_1 + a_{n, 2}x_2 + \cdots + a_{n, n}x_n \equiv t_n - s_n\pmod m
\end{matrix}\right.$$

求出每个 $x_i$ 的最小非负整数解即可。

同余只是纸老虎！直接转换成等号，高斯消元求解即可，只是需要把解映射到 $[0, m - 1]$。

同时这道题还需要在无穷多组解时输出任意一组解，需要在消元时额外注意（其实应该只有我这种写法应该注意），不能直接回代求解。

当找到一个主行 $r$ 时，不要只从 $r + 1$ 消到 $n$，而应该把 $1\sim n$ 都消一遍，此时除每行的**首变量**（每个行向量中第一个系数非零的未知数）之外其他的都是自由元，直接将首变量赋值，自由元赋成 $0$ 不管就行了。

这是我原来的高斯消元代码：

```cpp
int gauss() {
    int c, r;
    for(c = 0, r = 0; c < n; c++) {
        int t = r;
        for(int i = r + 1; i < n; i++)
            if(abs(a[i][c]) > abs(a[t][c]))
                t = i;
        if(!a[t][c]) continue;

        if(t != r) for(int i = c; i <= n; i++) swap(a[t][i], a[r][i]);
        for(int i = n; i >= c; i--) a[r][i] = (a[r][i] * (qpow(a[r][c], mod - 2) + mod) % mod) % mod;

        for(int i = r + 1; i < n; i++) //原来是消第 r + 1 到 n 行
            if(a[i][c])
                for(int j = n; j >= c; j--)
                    a[i][j] = (mod + a[i][j] - a[i][c] * a[r][j] % mod) % mod;
        ++r;
    }
    if(r < n) {
        for(int i = r; i < n; i++)
            if(a[i][n] > 0)
                return -1;
    }
    for(int i = n - 2; ~i; i--)
        for(int j = i + 1; j < n; j++)
            a[i][n] = (mod + a[i][n] - a[i][j] * a[j][n] % mod) % mod;
    return 1; 
}
```

它在这组数据时会出错：

```cpp
3 3
2 2 3
2 1 3
1 1
0 0 0
2 1 2

Answer:
0 1 1
或:
1 0 1

My answer:
1 1 0
```

原矩阵：

$$
\left[\begin{array}{ccc|c}
1 & 1 & 1 & 2\\
1 & 1 & 0 & 1\\
1 & 1 & 1 & 2
\end{array}\right]
$$

这是因为用以上代码消出来的结果为：

$$
\left[\begin{array}{ccc|c}
1 & 1 & 1 & 2\\
0 & 0 & 1 & 1\\
0 & 0 & 0 & 0
\end{array}\right]
$$

而如果直接回代就会直接将 $x_3$ 钦定为 $0$，这是不对的，因为 $x_2$ 才是自由元，而 $x_3$ 有固定的解 $1$。

而采用全部重消一遍的方法就能保证所有首变量都只会在一个行向量中出现，这时候回代就完全不用考虑和其他首变量取值出现冲突的问题。

$\texttt{Code:}$

```cpp
#include <cmath>
#include <iostream>

using namespace std;

const int N = 110;
typedef long long ll;
int n, mod;
ll a[N][N];
ll ans[N];

ll qpow(ll a, int b) {
    ll ans = 1, base = a % mod;
    while(b) {
        if(b & 1) ans = ans * base % mod;
        base = base * base % mod;
        b >>= 1;
    } 
    return ans;
}

void output() {
    puts("---------");
    for(int i = 0; i < n; i++) {
        for(int j = 0; j <= n; j++)
            printf("%d ", a[i][j]);
        puts("");
    }
    puts("---------");
}

int gauss() {
    int c, r;
    for(c = 0, r = 0; c < n; c++) {
        int t = r;
        for(int i = r + 1; i < n; i++)
            if(abs(a[i][c]) > abs(a[t][c]))
                t = i;
        if(!a[t][c]) continue;

        if(t != r) for(int i = c; i <= n; i++) swap(a[t][i], a[r][i]);
        for(int i = n; i >= c; i--) a[r][i] = (a[r][i] * (qpow(a[r][c], mod - 2) + mod) % mod) % mod;

        for(int i = 0; i < n; i++) //全部重消一遍
            if(a[i][c] && i != r)
                for(int j = n; j >= c; j--)
                    a[i][j] = (mod + a[i][j] - a[i][c] * a[r][j] % mod) % mod; //注意取模时要加上模数以防负数
        ++r;
    }
    if(r < n) {
        for(int i = r; i < n; i++)
            if(a[i][n] > 0)
                return -1;
        //
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++)
                if(a[i][j]) { //寻找首变量
                    ans[j] = a[i][n]; //直接将首变量赋成方程右侧的值，其他变量都是自由元，直接赋成 0
                    break;
                }
        }
        return 0;
    }
    for(int i = n - 2; ~i; i--)
        for(int j = i + 1; j < n; j++)
            a[i][n] = (mod + a[i][n] - a[i][j] * a[j][n] % mod) % mod;
    for(int i = 0; i < n; i++)
        ans[i] = a[i][n];
    return 1; 
}


int main() {
    scanf("%d%d", &n, &mod);
    ll x;
    for(int i = 0; i < n; i++) {
        int cnt;
        scanf("%d", &cnt);
        while(cnt--) {
            scanf("%lld", &x);
            a[x - 1][i] = 1;
        }
        a[i][i] = 1;
    }
    for(int i = 0; i < n; i++)
        scanf("%lld", &a[i][n]);
    for(int i = 0; i < n; i++) {
        scanf("%lld", &x);
        a[i][n] = x - a[i][n];
    }
    int type = gauss();
    if(type >= 0)
        for(int i = 0; i < n; i++)
            printf("%lld ", ans[i]);
    else puts("niuza");
    return 0;
}
```

在此鸣谢大佬 [Lu_xZ](https://www.luogu.com.cn/user/963559) 的指导！

---

## 作者：Melo_qwq (赞：2)

一道好的高斯消元，熬夜口胡乱写过了，记录一下。

我们发现一个碑总的变化次数加上起始状态等于最终状态，当然是在模意义下。

那么我们可以设一堆未知数 $z_1,z_2\cdots z_n$，其中 $z_i$ 表示第 $i$ 号被**直接**攻击了几次。

那么我们可以得到一个方程组：
$$
\left\{
\begin{aligned}
& s_1+x_{1,1}z_1+x_{1,2}z_2+\cdots+x_{1,n}z_n\equiv t_1\pmod m\\
& s_2+x_{2,1}z_1+x_{2,2}z_2+\cdots+x_{2,n}z_n\equiv t_2\pmod m \\
& \vdots \\
& s_n+x_{n,1}z_1+x_{n,2}z_2+\cdots+x_{n,n}z_n\equiv t_n\pmod m
\end{aligned}
\right.
$$
其中 $x_{i,j}$ 表示在攻击 $j$ 的时候会不会影响 $i$。

如果影响，那么等于 $x_{i,j}=1$，乘起来就相当于加上第 $j$ 个碑的次数 $z_j$，否则就是 $0$。

所以我们列出了一个符合题意的方程组，除了 $z$ 全都给定，直接转化成这样高斯消元即可：
$$
\left\{
\begin{aligned}
& x_{1,1}z_1+x_{1,2}z_2+\cdots+x_{1,n}z_n\equiv t_1-s_1\pmod m\\
& x_{2,1}z_1+x_{2,2}z_2+\cdots+x_{2,n}z_n\equiv t_2-s_2\pmod m \\
& \vdots \\
& x_{n,1}z_1+x_{n,2}z_2+\cdots+x_{n,n}z_n\equiv t_n-s_n\pmod m
\end{aligned}
\right.
$$
注意在取模的意义下不可以使用除法，所以采用费马小定理求解逆元即可。

还有就是运算的途中可能会出现负数，记得转化为正数。

代码：

```cpp
inline int qpow (int base ,int p = m - 2) {
	int res = 1 ;
	while (p) {
		if (p & 1ll) res = res * base % m ;
		base = base * base % m ;
		p >>= 1ll ;
	}
	return res ;
} // 求逆元
inline void turn (int &x) {
	return (void) (x = (x + m) % m) ;
} // 转正数
signed main () {
	read (n) ,read (m) ;
	f (i ,1 ,n ,1) {
		int k ;
		read (k) ;
		x[i][i] = 1 ; // 注意击打自己也会进入下一个状态
		f (j ,1 ,k ,1) {
			int num ;
			read (num) ;
			x[num][i] = 1 ; 
		}
	}
	f (i ,1 ,n ,1) read (x[i][n + 1]) ;
	f (i ,1 ,n ,1) {
		int t ;
		read (t) ;
		t = t - x[i][n + 1] ;
		turn (t) ;
		x[i][n + 1] = t ;
	} // 这个就是 t - s
	f (i ,1 ,n ,1) { // 按照套路，第 i 行的第 i 个是主元
		int cur = 1 ; // cur 寻找第一个为 1 的行
		for ( ;cur <= n && (! x[cur][i] || used[cur]) ;cur ++) ; // used 记录是否已经被用来消别的行了，如果是就不能动了
		if (cur == n + 1) continue ; // 这是一个自由元（其实不可能出现自由元，但是我就直接按板子写了）
		swap (x[i] ,x[cur]) ; 
		used[i] = true ;
		f (j ,1 ,n ,1) {
			if (! x[j][i] || j == i) continue ;
			int div = x[j][i] * qpow (x[i][i]) % m ; // 逆元求出 x[j][i] / x[i][i]
			f (k ,1 ,n + 1 ,1) {
				int t = (x[j][k] - (x[i][k] * div) % m) % m ; // 消掉 j 行的第 i 个
				turn (t) ;
				x[j][k] = t ;
			}
		}
	} 
	f (i ,1 ,n ,1) {
		int j = 1 ;
		for ( ;j <= n + 1 && ! x[i][j] ;j ++) ;
		if (j == n + 1) return puts ("niuza") ,0 ; // j == n + 1 说明前面的都是 0 但是第 n + 1 个（同余号右边）不是，显然无解
 	}
 	for (int i = n ;i ;i --) {
 		f (j ,1 ,n ,1) {
 			if (i == j) continue ;
 			int t = (x[i][n + 1] - x[i][j] * ans[j] % m) % m ;
 			turn (t) ;
 			x[i][n + 1] = t ;
		}
		ans[i] = (x[i][n + 1] * qpow (x[i][i])) % m ; 
	} // 倒序求解的过程
}
```

---

## 作者：2023lpx (赞：1)

## 思路

设第 $i$ 个方碑被电 $x_i$ 次，$a_{i,j}\in \{0,1\}$ 表示第 $i$ 个方碑是否会被第 $j$ 个方碑带动。

显然，自己被电就相当于自己带动自己，故 $a_{i,i}=1$。

状态是循环的，很明显是同余。

得：

$$
\begin{cases}
a_{1,1}x_1 + a_{2,1}x_2 + \dots + a_{n,1}x_n + s_1 \equiv t_1 \pmod m\\
a_{1,2}x_1 + a_{2,1}x_2 + \dots + a_{n,1}x_n + s_2 \equiv t_2 \pmod m\\
\cdots \\
a_{1,n}x_1 + a_{2,1}x_2 + \dots + a_{n,1}x_n + s_n \equiv t_n \pmod m\\
\end{cases}
$$

移项得：

$$
\begin{cases}
a_{1,1}x_1 + a_{2,1}x_2 + \dots + a_{n,1}x_n \equiv t_1 - s_1 \pmod m\\
a_{1,2}x_1 + a_{2,1}x_2 + \dots + a_{n,1}x_n \equiv t_2 - s_2 \pmod m\\
\cdots \\
a_{1,n}x_1 + a_{2,1}x_2 + \dots + a_{n,1}x_n \equiv t_n - s_n\pmod m\\
\end{cases}
$$

把板子改一下就好。

注意除法要用逆元，时间复杂度多一个 $\log$。

**无数解随便输出一个**。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
ll n;
ll const maxn=101;
ll mod;
ll f[maxn+1][maxn+1];
ll ans[maxn+1];
ll mi(ll a,ll k){
    ll res=1;
    while(k){
        if(k&1){
            res=res*a%mod;
        }
        a=a*a%mod;
        k>>=1;
    }
    return res;
}
ll s[maxn+1];
ll t[maxn+1];
signed main(){
    scanf("%lld%lld",&n,&mod);
    for(ll i=1;i<=n;i++){
        ll k;
        scanf("%lld",&k);
        f[i][i]=1;
        for(ll j=1;j<=k;j++){
            ll l;
            scanf("%lld",&l);
            f[l][i]=1;
        }
    }
    for(ll i=1;i<=n;i++){
        scanf("%lld",&s[i]);
    }
    for(ll i=1;i<=n;i++){
        scanf("%lld",&t[i]);
    }
    for(ll i=1;i<=n;i++){
        f[i][n+1]=t[i]-s[i];
    }
    for(ll i=1;i<=n;i++){
        ll r=i;
        for(ll j=i+1;j<=n;j++){
            if(f[j][i]>f[r][i]){
                r=j;
            }
        }
        if(f[r][i]==0){
            printf("niuza");
            return 0;
        }
        for(ll j=1;j<=n+1;j++){
            swap(f[r][j],f[i][j]);
        }
        ll q=f[i][i];
        for(ll j=i;j<=n+1;j++){
            f[i][j]*=mi(q,mod-2);
            f[i][j]%=mod;
        }
        for(ll j=i+1;j<=n;j++){
            ll p=f[j][i];
            for(ll k=i;k<=n+1;k++){
                f[j][k]-=f[i][k]*p%mod;
                f[j][k]+=mod;
                f[j][k]%=mod;
            }
        }
    }
    ans[n]=f[n][n+1];
    for(ll i=n-1;i>=1;i--){
        ans[i]=f[i][n+1];
        for(ll j=i+1;j<=n;j++){
            ans[i]-=(f[i][j]*ans[j])%mod;
            ans[i]+=mod;
            ans[i]%=mod;
        }
    }
    for(ll i=1;i<=n;i++){
        printf("%lld ",ans[i]);
    }
    return 0;
}
```

~~米哈游才不会放这么多复杂的方碑呢~~

---


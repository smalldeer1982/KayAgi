# 开关问题

## 题目描述

有 $N$ 个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。

你的目标是经过若干次开关操作后使得最后 $N$ 个开关达到一个特定的状态。

对于任意一个开关，最多只能进行一次开关操作。

你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）

## 说明/提示

对于所有测试数据，满足 $1 \le K \le 10$，$0 < N < 29$。

## 样例 #1

### 输入

```
2
3
0 0 0
1 1 1
1 2
1 3
2 1
2 3
3 1
3 2
0 0
3
0 0 0
1 0 1
1 2
2 1
0 0```

### 输出

```
4
Oh,it's impossible~!!```

# 题解

## 作者：Brilliant11001 (赞：5)

[更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18408880)

## [题目传送门](https://www.luogu.com.cn/problem/P10499)

### 题目大意：

有 $n$ 个开关，$0$ 表示关，$1$ 表示开，每个开关还有带动的开关，若操作一个开关，那么它带动的开关也会相应变换。

现给出这 $n$ 个开关的初始状态 $s_i$ 和末状态 $t_i$，询问有多少种方法能将初始态转变为末态（不考虑操作先后顺序且每个开关至多操作一次）。

### 思路：

高斯消元解异或方程组经典题。

先考虑将原题抽象成方程组。

令 $x_i$ 表示第 $i$ 个开关的操作次数，因为每个开关至多操作一次，所以 $x_i = 0$ 或 $x_i = 1$。

令 $a_{i, j}$ 表示第 $i$ 个开关和第 $j$ 个开关之间的联系，若 $a_{i, j} = 1$，则表示操作 $j$ 会带动 $i$，若 $a_{i, j} = 0$ 表示无影响，特别的，因为操作自己就相当于带动自己，所以 $a_{i, i} = 1$。

再根据操作效果：$0$ 变 $1$，$1$ 变 $0$，和异或一模一样。

所以可以列出以下方程组：

$$\left\{\begin{matrix}
a_{1, 1}x_1 \operatorname{xor} a_{1, 2}x_2 \operatorname{xor} \cdots \operatorname{xor} a_{1, n}x_n = t_1\operatorname{xor} s_1\\
a_{2, 1}x_1 \operatorname{xor} a_{2, 2}x_2 \operatorname{xor} \cdots \operatorname{xor} a_{2, n}x_n = t_2\operatorname{xor} s_2\\
\cdots\\
a_{n, 1}x_1 \operatorname{xor} a_{n, 2}x_2 \operatorname{xor} \cdots \operatorname{xor} a_{n, n}x_n = t_n\operatorname{xor} s_n
\end{matrix}\right.$$

异或其实就是不进位加法，所以也可以用高斯消元来解，将加减法换为异或就行了。

这道题要求操作方案数，那么找自由元的数量就好了。因为若某个未知数是自由元，那么它取 $0$ 和 $1$ 都可以，于是贡献了两种方案，根据乘法原理，应该把自由元的数量这么多 $2$ 乘起来，即 $2^{cnt}$，$cnt$ 为自由元的数量。

同时由于系数只能为 $0$ 或 $1$，所以一个行向量可以压缩为一个二进制整数或者用 bitset 来操作，这样就能一次异或一整行，时间复杂度降低为 $O(\frac{n^3}{\omega})$，写起来也方便许多。

$\texttt{Code:}$

```cpp
#include <cmath>
#include <bitset>
#include <iostream>

using namespace std;

const int N = 35;

int T;
int n;
bitset<N> a[N];
int ans;

int gauss() {
    int c, r;
    for(c = 0, r = 0; c < n; c++) {
        int t = r;
        for(int i = r + 1; i < n; i++)
            if(a[i][c]) {
                t = i;
                break;
            }
        
        if(!a[t][c]) continue;

        if(t != r) swap(a[t], a[r]);

        for(int i = r + 1; i < n; i++)
            if(a[i][c])
                a[i] = a[i] ^ a[r];
        ++r;
    }
    if(r < n) {
        for(int i = r; i < n; i++) {
            if(a[i][n])
                return -1;
        }
        ans = 1 << n - r;
        return 0;
    }
    return 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> T;
    while(T--) {
        cin >> n;
        ans = 1;
        int x;
        for(int i = 0; i < n; i++) 
            a[i].reset(), a[i].set(i, 1);
        for(int i = 0; i < n; i++) {
            cin >> x;
            a[i][n] = x;
        }
        for(int i = 0; i < n; i++) {
            cin >> x;
            a[i][n] = a[i][n] ^ x;
        }
        int y;
        while(cin >> x >> y && x && y)
            a[y - 1].set(x - 1, 1);
        int type = gauss();
        if(type >= 0) cout << ans << '\n';
        else cout << "Oh,it's impossible~!!" << '\n';
    }
    return 0;
}
```

---

## 作者：suzhikz (赞：5)

### 本文中一些内容摘自算法竞赛进阶指南 
这道题其实是一个特殊的高斯消元，我们通过把加法转化为异或，去掉乘法，可以实现该题。

不会高斯消元？？[this](https://www.luogu.com.cn/problem/solution/P3389)

在代码中，我将未知数的系数压成了一个数，这样不仅方便而且更快，其余的就是普通的高斯消元

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		int a[30]={0};//这里的a数组是我们的矩阵,因为我们最后求的x(即按不按这个开关)只有0,1两种可能，所以用2进制即可 
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		for(int i=1,u;i<=n;i++){
			cin>>u;
			a[i]^=u;//我们不关心他是0还是1，我们只想知道他变没变 
			a[i]|=(1<<i); //代表按下开关i对开关i有影响 
		}
		int x,y;
		cin>>x>>y;
		while(x!=0||y!=0){
			a[y]|=(1<<x);//按下x对y有影响 
			cin>>x>>y;
		}
		int ans=1;
		for(int i=1;i<=n;i++){
			int w=i;//寻找主元位最高的a[i] 
			for(int j=i+1;j<=n;j++){
				if(a[j]>a[w])w=j; 
			}
			if(w!=i)swap(a[i],a[w]);
			w=i;
			if(a[w]==1){//0=1的情况无解 
				ans=0;
				break;
			}
			if(a[w]==0){//有多个解的情况 ，有几个不知道的元就是2^个数种答案 
				ans=(1<<(n-i+1));
				break;
			}
			for(int j=n;j;j--){//寻找最高位 
				if(a[i]&(1<<j)){
					for(int k=1;k<=n;k++){//消除其他位的x 
						if(k==i)continue;
						if(a[k]&(1<<j))a[k]^=a[i];//把加减法替换为异或 
					}
					break;
				}
			}
		}
		if(ans)cout<<ans<<endl;
		else puts("Oh,it's impossible~!!");
	}
	
	return 0;
}

```

---

## 作者：vicissitudes (赞：4)

写不来高斯消元，所以写的搜索。

总时间为 $2^{29}$，直接搜索会被炸上天，不难发现，我们已知初状态和末状态，考虑**折半搜索**或者**双向搜索**。

如果在中间时状态一样，则可以拼接。

```cpp
#include <bits/stdc++.h>
using namespace std;

map<string, int> mp;
int n, m, ans = 0; 
vector<int> vec[40];

void change(char &a) {
	if(a == '0') a = '1';
	else a = '0';
}

void dfs1(int now, string stat) {
	if(now == n / 2 + 1) {
		mp[stat] ++;
		return ;
	}
	dfs1(now + 1, stat);
	change(stat[now]);
	for(auto i : vec[now]) change(stat[i]);
	dfs1(now + 1, stat);
}

void dfs2(int now, string stat) {
	if(now == n / 2) {	
		ans += mp[stat];
		return ;
	}
	dfs2(now - 1, stat);
	change(stat[now]);
	for(auto i : vec[now]) change(stat[i]);
	dfs2(now - 1, stat);
}

char ss[40], ee[40];


void solve() {
	cin >> n;
	string s, e;
	ans = 0;
	mp.clear();
	for(int i = 1; i <= n; i ++) vec[i].clear();
	for(int i = 1; i <= n; i ++) cin >> ss[i], s += ss[i];
	for(int i = 1; i <= n; i ++) cin >> ee[i], e += ee[i];
	s = ' ' + s, e = ' ' + e;
	int a, b;
	while(cin >> a >> b && a && b) vec[a].push_back(b);
	dfs1(1, s);
	dfs2(n, e);
	if(!ans) cout << "Oh,it's impossible~!!" << '\n';
	else cout << ans << '\n';
}

int main() {
	int t;
	cin >> t;
	while(t --) solve();
	return 0;   
}
```

---

## 作者：firstlight (赞：3)

# 洛谷P10499 开关问题
## 题意描述：
给定一些开关之间的关系，这些相联系的开关会同步改变状态。

我们要求出操作若干次开关后能否使所有开关从一个给定状态变为另一个给定状态。
## 解法：
我们将是否对第 $i$ 盏灯进行操作定为变量 $x_i$, $i\in(1,N)$。

那么将所有与第 $i$ 盏灯有关联的灯的变量和初始状态异或起来就应该等于该灯的结果状态。

通过上述的转化即可得到有关于所有 $N$ 盏灯的 $N$ 个方程。

例如样例的第一组数据可转化为如下方程组：

$$
\left \{
\begin{array}{c}
x_1\oplus x_2\oplus x_3 = 1 \\
x_1\oplus x_2\oplus x_3 = 1 \\
x_1\oplus x_2\oplus x_3 = 1
\end{array}
\right.
$$

这是一个线性异或方程组，可以使用**高斯消元**求解。

这时分为两种情况：

1. 产生了 $0 = 1$ 的等式，这种情况无解。
2. 另一种为有解情况，统计最后自由元的个数 $k$（即完成消元后 $0 = 0$ 等式的数量），最后方案的数量即为 $2^k$。

## code：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 35;

int n;
int a[N][N];

int gauss()
{
    int r, c;
    for(r = 1, c = 1; c <= n; c ++ )
    {
        int t = r;
        for(int i = r + 1; i <= n; i ++ )
            if(a[i][c])
                t = i;
        
        if(!a[t][c]) continue;
        
        for(int i = c; i <= n + 1; i ++ ) swap(a[t][i], a[r][i]);
        
        for(int i = r + 1; i <= n; i ++ )
            for(int j = n + 1; j >= c; j -- ) 
                a[i][j] ^= a[r][j] & a[i][c];
        
        r ++ ;
    }
    
    int res = 1;
    
    if(r <= n)
    {
        for(int i = r; i <= n; i ++ )
        {
            if(a[i][n + 1]) return -1; // 无解情况
            res *= 2; // 统计自由元个数，顺便进行2^k求解
        }
    }
    
    return res;
}

int main()
{
    int T;
    scanf("%d", &T);
    
    while(T -- )
    {
        memset(a, 0, sizeof a);
        
        scanf("%d", &n);
        for(int i = 1; i <= n; i ++ ) scanf("%d", &a[i][n + 1]);
        for(int i = 1; i <= n; i ++ ) 
        {
            int t;
            scanf("%d", &t);
            a[i][n + 1] ^= t;
            a[i][i] = 1;
        }
        
        int x, y;
        while(scanf("%d%d", &x, &y), x || y) a[y][x] = 1;
        
        int res = gauss();
        
        if(res == -1) printf("Oh,it's impossible~!!\n");
        else printf("%d\n", res);
    }
    
    return 0;
}
```

---

## 作者：ShiZhaoxu_YY202305 (赞：2)

# P10499 开关问题

[题目传送门](https://www.luogu.com.cn/problem/P10499)

## 行题思路

我们不妨设每个灯泡初始状态为 ${Si}$，最终操作后状态为 ${Ei}$，将灯泡之间的关系读入并设其为 ${Ai,j}$（表示第 $j$ 个灯泡可以打开第 $i$ 个灯泡，如有关系存在，则将值标记为 $1$），每个相关灯泡是否操作过为 ${Xi}$（值为 $0$ 或 $1$，代表灯泡不操作与操作）。稍加推理，便可得出以下方程组：

$$
\begin{cases}
{A1,1}\ \operatorname{xor}\ {X1}\ \operatorname{xor}\ {A1,2}\ \operatorname{xor}\ {X2}\ \dots\ {A1,n}\ \operatorname{xor}\ {Xn} = {S1}\ \operatorname{xor}\ {E1}\\
{A2,1}\ \operatorname{xor}\ {X1}\ \operatorname{xor}\ {A2,2}\ \operatorname{xor}\ {X2}\ \dots\ {A2,n}\ \operatorname{xor}\ {Xn} = {S2}\ \operatorname{xor}\ {E2}\\
\hspace{5.1cm} \dots\\
{An,1}\ \operatorname{xor}\ {X1}\ \operatorname{xor}\ {An,2}\ \operatorname{xor}\ {X2}\ \dots\ {An,n}\ \operatorname{xor}\ {Xn} = {Sn}\ \operatorname{xor}\ {En}\\
\end{cases}
$$

在数学中**划归**的思想非常重要，将一个个陌生的问题转化为熟悉的知识点。做信息题亦然，看到此方程组我们不免想到高斯消元。即求解以 $X$ 未知元为主元的方程组解的个数，接着联想到高斯消元。是否可以尝试求解一个异或方程组，开始考虑到**异或高斯消元**呢？

## 代码思路

**异或高斯消元**与普通消元类似，甚至更易操作。我们维护一个矩阵使未知元个数自上而下依次递减，对于消元问题我们只需将被消元方程异或上主方程即可（细节可参考对于普通高斯消元的其他例题进行学习）。在只有一个未知元的方程式时求解（如果不符合则说明无解，如成立则说明至少有一组解）。当然本题要求我们求解解的个数，所以我们不妨将目光转移到有无数组解的未知元上。又因为 $X$ 未知元只有启用与不启用两种状态，所以所谓的无数组解即将解集数量扩大了两倍（有一个自由元解集大小便在原有基础上扩大两倍，对于求解自由元个数的问题详见代码），本题便转化为求次方程组的自由元个数，由此得出思路。

## 代码实现

各功能详见代码注释：
```cpp
#include<bits/stdc++.h> 
using namespace std;
const int N=30;
int k,n;
int a[N],b[N],res[N][N];//用res数组表示灯泡之间的隶属关系 
int counting_stars(){//异或高斯消元 
	int r,c;
	for(r=1,c=1;c<=n;c++){
		int t=r;
		for(int i=r+1;i<=n;i++) if(res[i][c]){t=i;break;}//将主元放在最前面可以避免除到0的错误
		if(!res[t][c]) continue;//如主元皆为0，则跳过不计（将来计算种类时有用） 
		for(int i=c;i<=n+1;i++) swap(res[t][i],res[r][i]);//排序（将主元最大的方程式放在最前面） 
		for(int i=r+1;i<=n;i++) if(res[i][c]) for(int j=n+1;j>=c;j--) res[i][j]^=res[r][j];//消元（将除了本方程式以外的主元全部消为0） 
		r++;
	}
	if(r<n+1){//continue跳过的步骤说明有些未知数有无数种解（要么为0要么为1，共两种情况） 
		for(int i=r;i<=n;i++) if(res[i][n+1]) return 0;//如果扩展式右项系数中不为0，这说明无解 
		return 1<<(n-r+1);
	}
	return 1;
}
int main(){
	cin>>k;
	while(k--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++) cin>>b[i];
		int x,y;
		memset(res,0,sizeof(res));
		for(int i=1;i<=n;i++) res[i][i]=1,res[i][n+1]=(a[i]^b[i]);
		while(cin>>x>>y && (x && y)) res[y][x]=1;//注意x与y的位置不要写反，想想它们的实际含义 
		int stars=counting_stars();
		if(!stars) cout<<"Oh,it's impossible~!!\n";
		else cout<<stars<<"\n";
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：2)

考虑到一个开关按两次相当于没按，所以一个开关我们要么按一次要么不按，我们也就是说设按第 $i$ 个开关的次数为 $t_i$ 就有 $t_i\in[0,1]$。

那么我们考虑建立方程组，考虑按第 $j$ 个开关会不会影响第 $i$ 个开关，设为 $b_{i,j}$。

那么我们就得到：

$$
\bigoplus_{j=1}^n b_{i,j}t_j=St_i\oplus Ed_i
$$

其中 $St$ 和 $Ed$ 表示开始和结束时的状态，这样的方程组恰好有 $n$ 个。

考虑高斯消元，最后有几个自由元，答案就是二的这个数量次方。

同时，如果得到的方程组系数都是 $0$ 但是等式右边不为 $0$ 则无解。

这里介绍一下一种更优秀的做法，`bitset` 可以充当布尔数组的作用，同时可以将两个 `bitset` 的异或操作做到 $\mathcal O(\dfrac n w)$，这样维护高斯消元的操作，时间复杂度可以降为 $\mathcal O(\dfrac {n^3}{w})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
const int N=35;
bitset<N>B[N];
int Ed[N],St[N];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)St[i]=Ed[i]=0;
		for(int i=1;i<=n;i++)B[i].reset();
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&St[i]);
			B[i][i]=1;
		}
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&Ed[i]);
			Ed[i]^=St[i];
		}
		while(1)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			if(x==0&&y==0)break; 
			B[y][x]=1;
		}
		int Res=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=i;j<=n;j++)
			{
				if(B[j][i])
				{
					swap(B[j],B[i]),swap(Ed[i],Ed[j]);
					break;
				}
			}
			for(int j=1;j<=n;j++)
			{
				if(j==i)continue;
				if(B[j][i])B[j]^=B[i],Ed[j]=Ed[j]^Ed[i];
			}	
		}
		int Flg=0;
		for(int i=1;i<=n;i++)
		{
			if(!B[i].count())
			{
				if(Ed[i])Flg=1;
				else Res++;
			}
		}
		if(Flg)puts("Oh,it's impossible~!!");
		else cout<<(1<<Res)<<endl;
	}
} 
```

---

## 作者：NFOT (赞：1)

# [P10499 开关问题](https://www.luogu.com.cn/problem/P10499)
## 分析
通过对题目的分析，我们不难发现使用 $\operatorname{xor}$ 可以很好描述开关变化。我们可以把这道题看做一个**增广矩阵**，行即为操作，列即为状态，**$a_{i,j}$ 表示操作 $j$ 对 $i$ 的影响**，操作 $x$ 会影响开关 $y$ 的状态。而常数项为**初始状态 $\operatorname{xor}$ 目标状态**，即为 
$$
a[i][n] =a[i][n]^{x}
$$
通过 $\operatorname{xor}$ 和增广矩阵，我们可以想到**异或高斯消元**所以消元的过程并不繁琐，比普通高斯消元还要简单。
```c++
for (int j = c; j <= n; j++) {
	a[i][j] ^= a[r][j];
}
```
本题要求解的个数，我们不难分析，当这个矩阵经高斯消元后有**唯一解**，那么**解的数量为 $1$**，接下来判断多解和无解，多解情况即为
$$
\text{解的个数}=2^{\text{(自由变量数)}}
$$
## 代码
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 50;
int a[N][N + 1]; // 增广矩阵：a[i][j] 表示操作 j 对开关 i 的影响

// 高斯消元法
int gauss(int n) {
    int r, c; // 行，列
    for (r = 0, c = 0; c < n; c++) {
        int t = r;
        for (int i = r; i < n; i++) {
            if (a[i][c]) {
                t = i;
                break;
            }
        }
        if (!a[t][c]) continue; // 当前列全为零，跳过
        swap(a[t], a[r]); // 交换行
        for (int i = r + 1; i < n; i++) {
            if (a[i][c]) {
                for (int j = c; j <= n; j++) {
                    a[i][j] ^= a[r][j];
                }
            }
        }
        r++;
    }
    // 判断解的情况
    if (r < n) {
        for (int i = r; i < n; i++) {
            if (a[i][n]) return -1; // 无解
        }
        return 1 << (n - r); // 解的个数为 2^(自由变量数)
    }
    return 1; // 唯一解
}

signed main() {
    int K;
    cin >> K;
    while (K--) {
        memset(a, 0, sizeof(a)); // 初始化增广矩阵
        int n;
        cin >> n;
        // 读取初始状态
        for (int i = 0; i < n; i++) {
            cin >> a[i][n];
        }
        // 读取目标状态并计算常数项
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            a[i][n] ^= x; // 常数项 = 初始状态 ^ 目标状态
        }
        // 读取约束条件
        int x, y;
        while (cin >> x >> y && !(x == 0 && y == 0)) {
            a[y - 1][x - 1] = 1; // 修正：操作 x 会影响开关 y 的状态
        }
        // 每个开关操作会影响自身
        for (int i = 0; i < n; i++) {
            a[i][i] = 1; // 主对角线为 1
        }
        // 高斯消元
        int ans = gauss(n);
        if (ans == -1) {
            cout << "Oh,it's impossible~!!" << endl;
        } else {
            cout << ans << endl; // 输出解的个数
        }
    }
    return 0;
}
```

---

## 作者：Milthm (赞：1)

考虑暴力枚举，但是这样时间复杂度是错误的，虽然洛谷数据可过，但是在其他 OJ 过不了。

所以考虑折半搜索，先处理出前一半的状态，然后我们发现这个操作可以转化为异或操作。根据异或的性质，如果你从最后往前异或的话，结果也是不会改变的。所以后一半的状态只需要从后往前异或，判断每个状态在前一半里出现状态的次数即可。

时间复杂度 $O(n\times 2^{\frac{n}2})$，可以通过本题。


```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,x,y,yhb[1005];
unordered_map<int,int>qwq;
signed main(){
	cin>>T;
	while(T--){
		memset(yhb,0,sizeof(yhb));
		qwq.clear();
		int s=0,t=0;
		cin>>n;
		for(int i=1;i<=n;++i)cin>>x,s+=x*(1<<i-1);
		for(int i=1;i<=n;++i)cin>>x,t+=x*(1<<i-1),yhb[i]=(1<<i-1);
		while(cin>>x>>y){
			if(!x)break;
			yhb[x]|=(1<<y-1);
		}
		int ans=0;
		for(int i=0;i<(1<<(n/2));++i){
			int r=s;
			for(int j=1;j<=n;++j){
				if(i&(1<<j-1))r^=yhb[j];
			}
			qwq[r]++;
		}
		for(int i=0;i<(1<<(n-n/2));++i){
			int r=t,syx=i*(1<<(n/2));
			for(int j=1;j<=n;++j){
				if(i&(1<<j-1))r^=yhb[n/2+j];
			}
			ans+=qwq[r];
		}
		if(ans)cout<<ans<<'\n';
		else cout<<"Oh,it's impossible~!!\n";
	}
	return 0;
}
```

---

## 作者：hzoi_Shadow (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10499)

# 前置知识

[高斯消元法解异或方程组](https://oi-wiki.org/math/numerical/gauss/#高斯消元法解异或方程组) | [乘法原理](https://oi-wiki.org/math/combinatorics/combination/#乘法原理)

# 解法

把开关的相互影响关系转化成异或，然后就转化成了异或方程组，高斯消元求解即可。

判断是否存在解的过程同 [luogu P2455 [SDOI2006] 线性方程组](https://www.luogu.com.cn/problem/P2455) 。

由于自由元仅能取 $0/1$，故总方案数为 $2$ 的自由元数量次方。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
int start[50],en[50],a[50][50];
int main()
{
    int t,n,i,j,k,l,r,ii,h,val,ans;
    cin>>t;
    for(h=1;h<=t;h++)
    {
        cin>>n;
        ans=0;
        memset(a,0,sizeof(a));
        for(i=1;i<=n;i++)
        {
            cin>>start[i];
        }
        for(i=1;i<=n;i++)
        {
            cin>>en[i];
            a[i][i]=1;
            a[i][n+1]=start[i]^en[i];
        }
        while(cin>>l>>r)
        {
            if(l==0&&r==0)
            {
                break;
            }
            else
            {
                a[r][l]=1;
            }
        }
        for(i=1;i<=n;i++)
        {
            val=i;
            for(j=1;j<=n;j++)
            {
                if(!(i>j&&a[j][j]!=0))
                {
                    if(a[j][i]>a[val][i])
                    {
                        val=j;
                    }
                }
            }
            for(j=1;j<=n+1;j++)
            {
                swap(a[i][j],a[val][j]);
            }
            for(j=1;j<=n;j++)
            {
                if(j!=i&&a[j][i]==1)
                {
                    for(k=i+1;k<=n+1;k++)
                    {
                        a[j][k]^=a[i][k];
                    }
                }
            }
        }
        for(i=1;i<=n;i++)
        {
            if(a[i][i]==0)
            {
                if(a[i][n+1]!=0)
                {
                    ans=-1;
                    break;
                }
                else
                {
                    ans++;
                }
            }
        }
        if(ans==-1)
        {
            cout<<"Oh,it's impossible~!!"<<endl;
        }
        else
        {
            cout<<(1<<ans)<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Liyunze123 (赞：1)

# 1.题意
给定 $n$ 个灯，按第 $i$ 个灯，第 $j$ 个灯也会变。问你能不能按某些开关，使得灯从起始状态变成结束状态。
# 2.题解
构造高斯消元数组。

$a_{i,j}$ 为按了 $j$，$i$ 能不能跟着变。$a_{i,n+1}$ 为第 $i$ 个灯的起始状态和结束状态是否一致。

用高斯消元解异或线性方程组做。

答案为 $2$ 的可变元个数次方。
# 3.代码
```
#include<bits/stdc++.h>
using namespace std;
int n,k,b,a[30][30],i,j;
int gauss(){
    int r,c;
    for(r=1,c=1;c<=n;c++){
        int t=r;
        for(int w=r+1;w<=n;w++)if(a[w][c])t=w;
        if(!a[t][c])continue;
        for(int w=c;w<=n+1;w++)swap(a[t][w],a[r][w]);
        for(int w=r+1;w<=n;w++)for(int x=n+1;x>=c;x--)a[w][x]^=a[w][c]&a[r][x];
        r++;
    }
    int ans=1;
    if(r<n+1)for(int w=r;w<=n;w++){if(a[w][n+1])return -1;ans*=2;}
    return ans;
}
int main(){
    scanf("%d",&k);
    while(k--){
        scanf("%d",&n),memset(a,0,sizeof(a));
        for(int w=1;w<=n;w++)scanf("%d",&a[w][n+1]);
        for(int w=1;w<=n;w++)scanf("%d",&b),a[w][n+1]^=b,a[w][w]=1;
        scanf("%d%d",&i,&j);
        while(i&&j)a[j][i]=1,scanf("%d%d",&i,&j);
        int t=gauss();
        if(t!=-1)printf("%d\n",t);
        else printf("Oh,it's impossible~!!\n");
    }
    return 0;
}
```

---

## 作者：ineverleft (赞：1)

# 开关问题

首先可以发现对于每个灯的操作相当于把这个灯的状态异或 1，因此不难发现原问题可以转化成异或方程组。

令 $x_i$ 表示第 $i$ 个开关是否被按下（$x_i=1$ 表示被按下，$x_i=0$ 表示未被按下），那么每一种情况就可以转化成一个异或方程组。

举例：

```
3
0 0 0
1 1 1
1 2
2 1
2 3
0 0
```

这个例子就可以转化成：

$$
\left\{\begin{matrix} 
 x_1 \oplus x_2 = 0 \oplus 1\\
 x_1 \oplus x_2 = 0 \oplus 1 \\
 x_2 \oplus x_3 = 0 \oplus 1
\end{matrix}\right.
$$

接下来问题就转化成了求这个异或方程组的解的个数，使用高斯消元求解。

解的个数与方程组的自由变量数有关，若有 $k$ 个自由变量，则答案为 $2^k$。而自由变量的个数就是高斯消元结束之后 $0=0$ 的个数。

时间复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=40;

int n;
int a[N][N];

int gauss(){
    int r,c;
    for(r=1,c=1;c<=n;c++){
        int t=r;
        for(int i=r+1;i<=n;i++){
            if(a[i][c])t=i;
        }
        if(!a[t][c])continue;
        
        for(int i=c;i<=n+1;i++){
            swap(a[t][i],a[r][i]);
        }
        
        for(int i=r+1;i<=n;i++){
            for(int j=n+1;j>=c;j--){
                a[i][j]^=a[i][c]&a[r][j];
            }
        }
        r++;
    }
    
    int res=1;
    if(r<n+1){
        for(int i=r;i<=n;i++){
            if(a[i][n+1])return -1;//无解 0=1
            res*=2;//自由变量 0=0
        }
    }
    return res;
}

int main(){
    int T;
    cin >> T;
    while(T--){
        memset(a,0,sizeof a);
        cin >> n;
        for(int i=1;i<=n;i++){
            cin >> a[i][n+1];
        }
        for(int i=1;i<=n;i++){
            int t;
            cin >> t;
            a[i][n+1]^=t;
        }
        for(int i=1;i<=n;i++){//第i个开关会操作第i个灯
            a[i][i]=1;
        }
        int x,y;
        while(cin >> x >> y,x||y){
            a[y][x]=1;
        }
        int t=gauss();
        if(t==-1){
            cout << "Oh,it's impossible~!!" << endl;
        }
        else{
            cout << t << endl;
        }
    }
    return 0;
}
```

---

## 作者：TuringTime (赞：0)

# P10499 开关问题
## 前言
本文是我的第 $1$ 篇题解。

本题是我通过的第 $17$ 道蓝题。

## 前置知识
**高斯-约旦消元法**

相信做到这道题的绝大多数人都已经接触过这个方法了。因此介绍这个方法本身并非本文的重点。下面的介绍将会很简略。

高斯-约旦消元法是求解线性方程组的常用方法之一。

它的思路是：首先将线性方程组写成增广矩阵形式，随后通过矩阵初等行变换将增广矩阵转化为简化阶梯形矩阵。

下附一份高斯-约旦消元法求解线性方程组的模板。
```cpp
//a 矩阵放含未知数项
//b 矩阵放常数项
//假设每一项的系数及每一个常数项都是 double 类型
void gauss()
{
	for (int i=1;i<=n;i++)
	{
        int maxr=i;
		for (int j=i+1;j<=n;j++)
			if (fabs(a[j][i])>fabs(a[maxr][i]))
				maxr=j;
		swap(a[maxr],a[i]);
		swap(b[maxr],b[i]);

		if (a[i][i]<eps&&a[i][i]>-eps)
		{
			puts("No Solution");
			exit(0);
		}

		for (int j=1;j<=n;j++)
		{
			if (i==j)
				continue;
			double mul=a[j][i]/a[i][i];
			for (int k=i;k<=n;k++)
				a[j][k]-=a[i][k]*mul;
			b[j]-=b[i]*mul;
		}
	}
	for (int i=1;i<=n;i++)
		x[i]=b[i]/a[i][i];
}
```
如果这是你第一次接触高斯-约旦消元法，建议你先拿[高斯消元法](https://www.luogu.com.cn/problem/P3389)、[线性方程组](https://www.luogu.com.cn/problem/P2455)、[球形空间产生器](https://www.luogu.com.cn/problem/P4035)这三道题练练手。

## 回归本题
观察到开关状态只有两种，于是我们想到**位运算**。

我们发现如果一个开关被按下偶数次，它的状态根本不会发生变化。而如果一个开关被按下奇数次，相当于按下一次，状态取反。于是我们想到**异或**。

进一步想到，把一个开关的初始状态与所有和它相关联的开关异或在一起，恰好等于这个开关的结束状态。这本质上就是一个**异或方程**。

把每个开关对应的方程联立起来，就得到了一个**异或方程组**。

于是我们需要求解这个异或方程组。想到**高斯-约旦消元法**。

问题在于：高斯-约旦消元法如何求解异或方程组？

首先，消去同一列其他未知数的方式需要做出调整。我们直接将乘除法运算改为异或运算即可。代码如下：


```cpp
for (int j=1;j<=n;j++)
{
	if (i==j)
		continue;
	double mul=a[j][i]/a[i][i];
	for (int k=i;k<=n;k++)
		a[j][k]-=a[i][k]*mul;
	b[j]-=b[i]*mul;
}
```
改为

```cpp
for (int j=1;j<=n;j++)
{
	if (i==j||!a[j][i])
		continue;
	for (int k=1;k<=n;k++)
		a[j][k]^=a[i][k];	
	b[j]^=b[i];
}
```
我们还发现，判断无解和多解的方式需要做出调整。如果简化阶梯形矩阵中有一行左侧主元为 $0$，而右侧常数项为 $1$，一定无解。如果主元和常数项都为 $1$，那么这个等式恒成立。$x$ 既可以取 $0$ 也可以取 $1$，方程组有多组解。

```cpp
if (a[i][i]<eps&&a[i][i]>-eps)
{
	puts("No Solution");
	exit(0);
}
```
改为

```cpp
for (int i=1;i<=n;i++)
	if (!a[i][i])
		if (b[i])
		{
			//无解
			break;//细节！
		}
		else
			//多解
```
有个细节：如果方程组中同时存在无解方程和多解方程，那么这个方程组是无解的！换句话说，遍历到多解方程之后需要继续遍历，而遍历到无解方程之后可以直接跳出循环。

最后一个 bug：本题输出为可以达到指定状态的方法总数，这一步统计如何完成？

我们发现：求可以达到指定状态的方法总数，其实等价于求异或方程组解的组数。根据**乘法原理**可知，在方程组有解时，解的数量等于每个未知数可以取的值的数量的乘积。如果某个方程有唯一解，答案乘一；如果某个方程有解且解不唯一，答案乘二。

至此，我们终于做完了这道题。

## AC 代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=35;
int st[N],ed[N];
int a[N][N],b[N];
void gauss(int n)
{
	for (int i=1;i<=n;i++)
	{
		int maxr=i;
		for (int j=i+1;j<=n;j++)
			if (a[j][i]>a[maxr][i])
				maxr=j;
		swap(a[maxr],a[i]);
		swap(b[maxr],b[i]);
		for (int j=1;j<=n;j++)
		{
			if (i==j||!a[j][i])
				continue;
			for (int k=1;k<=n;k++)
				a[j][k]^=a[i][k];	
			b[j]^=b[i];
		}
	}
}
int main()
{
	int K;
	cin>>K;
	while (K--)
	{
		int n;
		cin>>n;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		for (int i=1;i<=n;i++)
			cin>>st[i];
		for (int i=1;i<=n;i++)
		{
			cin>>ed[i];
			a[i][i]=1;
			b[i]=st[i]^ed[i];
		}
		int I,J;
		cin>>I>>J;
		while (I||J)
		{
			a[J][I]=1;
			cin>>I>>J;
		}
		gauss(n);
		int cnt=0;
		for (int i=1;i<=n;i++)
			if (!a[i][i])
				if (b[i])
				{
					cnt=-1;
					break;
				}
				else
					cnt++;
		if (cnt==-1)
			cout<<"Oh,it's impossible~!!"<<endl;
		else
			cout<<(1<<cnt)<<endl;	
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/199828315)

EOF

---


# 【模板】矩阵求逆

## 题目描述

求一个 $N\times N$ 的矩阵的逆矩阵。答案对 ${10}^9+7$ 取模。

## 说明/提示

对 $30 \%$ 的数据有 $N\le 100$；  
对 $100 \%$ 的数据有 $N\le 400$，所有 $0 \le a_{i j} < {10}^9 + 7$。

## 样例 #1

### 输入

```
3
1 2 8
2 5 6
5 1 2```

### 输出

```
718750005 718750005 968750007
171875001 671875005 296875002
117187501 867187506 429687503```

## 样例 #2

### 输入

```
3
3 2 4
7 2 9
2 4 3```

### 输出

```
No Solution```

# 题解

## 作者：一只萌新 (赞：142)

[$\color{teal}{Blog}$](https://blog.csdn.net/qq_43653202/article/details/99976316)

[P4783 【模板】矩阵求逆](https://www.luogu.org/problem/P4783)

**题目描述**

求一个$N×N$的矩阵的逆矩阵。答案对$10^9+7$取模。

### 1.逆矩阵的定义

假设 $A$ 是一个方阵，如果存在一个矩阵 $A^{-1}$，使得

$$A^{-1}A=I$$
并且
$$AA^{-1}=I$$

那么，矩阵 A 就是可逆的，$A^{-1}$ 称为 A 的逆矩阵

### 2.逆矩阵求法 —— 初等变换法（高斯-约旦消元）

**0.高斯-约旦消元**

详见
[P3389 【模板】高斯消元法](https://www.luogu.org/problem/P3389)
题解部分

高斯约旦消元与高斯消元区别：

```
高斯消元 -> 消成上三角矩阵 

高斯-约旦消元 -> 消成对角矩阵 
```

约旦消元法的精度更好,代码更简单,**没有回带的过程** 

```cpp
void Gauss_jordan(){
	/***** 行的交换&加减消元 *****/ 
	for(re int i=1,r;i<=n;++i){	//正在处理第i行 
		r=i;
		for(re int j=i+1;j<=n;++j) 
			if(fabs(a[j][i])>fabs(a[r][i])) r=j;
		if(fabs(a[r][i])<eps){
			puts("No Solution");return;
		}
		if(i!=r) swap(a[i],a[r]);
		
		for(re int k=1;k<=n;++k){
		//每一行都处理  
			if(k==i) continue;
			double p=a[k][i]/a[i][i];
			for(re int j=i;j<=n+1;++j) a[k][j]-=p*a[i][j];
		} 
	}	
	
	//上述操作后会剩下对角矩阵,答案要除以系数    
	for(re int i=1;i<=n;++i) printf("%.2lf\n",a[i][n+1]/a[i][i]);
}

```

**1.矩阵求逆**

思路
* 求$A$的逆矩阵，把$A$和单位矩阵$I$放在一个矩阵里
* 对$A$进行加减消元使$A$化成单位矩阵
* 此时原来单位矩阵转化成逆矩阵

原理
$$A^{-1} * [AI] = [I A^{-1}] $$


举个栗子

求
$$\begin{bmatrix}2 & -1 & 0 \\-1 & 2 & -1 \\0 & -1 & 2\end{bmatrix}$$

首先
$$\begin{bmatrix}2 & -1 & 0 & 1 & 0 & 0 \\-1 & 2 & -1 & 0 & 1 & 0 \\0 & -1 & 2 & 0 & 0 & 1 \end{bmatrix}$$

对左边进行消元可得
$$\begin{bmatrix}2 & -1 & 0 & 1 & 0 & 0 \\ 0 & \frac{3}{2} & -1 & \frac{1}{2} & 1 & 0 \\0 & 0 & \frac{4}{3} & \frac{1}{3} &\frac{2}{3} & 1  \end{bmatrix}$$

此时已消成上三角矩阵，高斯消元开始回代，但约旦会消成对角矩阵
$$\begin{bmatrix}2 & 0 & 0 & \frac{3}{2} & 1 & \frac{1}{2} \\0 & \frac{3}{2} & 0 & \frac{3}{4} & \frac{3}{2} & \frac{3}{4} \\0 & 0 & \frac{4}{3} & \frac{1}{3} & \frac{2}{3} & 1\end{bmatrix}$$

最后每行除以系数

$$\begin{bmatrix}1 & 0 & 0 & \frac{3}{4} & \frac{1}{2} & \frac{1}{4} \\0 & 1 & 0 & \frac{1}{2} & 1 & \frac{1}{2} \\ 0 & 0 & 1 & \frac{1}{4} & \frac{1}{2} & \frac{3}{4} \end{bmatrix}$$
此时右半边即为所求


**2.细节**

1. 开long long（不要冒风险，乘法很容易溢出） 
2. 模意义下除以一个数等于乘上逆元，可用快速幂求逆元（费马小定理） 

$Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define re register
#define il inline
#define ll long long
using namespace std;

il ll read(){
    ll s=0,f=0;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-'),c=getchar();
    while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
    return f?-s:s;
}

const int N=405,mod=1e9+7;
int n;
ll a[N][N<<1];
il ll qpow(ll x,ll k){
	ll ans=1;
	while(k){
		if(k&1) ans=ans*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return ans%mod;
}

il void Gauss_j(){	
	for(re int i=1,r;i<=n;++i){
		r=i;
		for(re int j=i+1;j<=n;++j)
			if(a[j][i]>a[r][i]) r=j;
		if(r!=i) swap(a[i],a[r]);
		if(!a[i][i]){puts("No Solution");return;}
		
		int kk=qpow(a[i][i],mod-2);	//求逆元 
		for(re int k=1;k<=n;++k){
			if(k==i) continue;
			int p=a[k][i]*kk%mod;
			for(re int j=i;j<=(n<<1);++j) 
				a[k][j]=((a[k][j]-p*a[i][j])%mod+mod)%mod;
		} 
		
		for(re int j=1;j<=(n<<1);++j) a[i][j]=(a[i][j]*kk%mod);
		//更新当前行 如果放在最后要再求一次逆元,不如直接放在这里  
	}	
	
	for(re int i=1;i<=n;++i){
		for(re int j=n+1;j<(n<<1);++j) printf("%lld ",a[i][j]);
		printf("%lld\n",a[i][n<<1]);
	}
}
int main(){
	n=read();
	for(re int i=1;i<=n;++i)
		for(re int j=1;j<=n;++j)
			a[i][j]=read(),a[i][i+n]=1;
	
	Gauss_j();
    return 0;
}

```
网上浏览一圈头都要炸掉，线性代数太可怕了，定义好多

最后只看懂了这种方法

有什么问题欢迎评论区指出 ：）

参考文章

[线性代数之——矩阵乘法和逆矩阵](https://www.cnblogs.com/seniusen/p/9962935.html)

[逆矩阵的几种求法与解析(很全很经典)](https://wenku.baidu.com/view/b0525966f5335a8102d22078.html)

---

## 作者：walk_alone (赞：33)

### 严格证明来了！

如果还不用学习线性代数的童鞋们，可以直接看下文的简化题解，跳过中间的证明；~~但是要是卑微的大学牲，建议还是康康吧（大雾）~~

## 完整证明版

需要以下前置知识：

1.矩阵的逆及其存在的判定方法

2.初等矩阵及其性质

### 矩阵的逆

由于我们在定义矩阵运算的时候只定义了数乘和矩阵乘法，而没有除法运算。和逆元的产生一样，我们为了定义出除法，我们采用乘一个数/矩阵得到单位 $1$/单位矩阵的方法，并定义这个数/矩阵为原数/原矩阵的乘法。

注：单位矩阵是一个除了主对角线为 $1$，其他全为 $0$ 的方阵。由于阶数不固定，因而有无穷多种单位矩阵。

$$ \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 0 & 1\\\end{bmatrix} $$

**定义：设 $A$ 为 $n$ 阶方阵，若存在$n$阶方阵 $B$，使得 $AB=BA=I$，则称 $B$ 为 $A$ 的逆，并称 $A$ 为可逆矩阵。** 记 $A^{-1}$ 为 $A$ 的逆。

若 $A$ 可逆，则逆唯一。

证明：若 $B$ 与 $C$ 都是 $A$ 的逆，由定义 $AB=BA=I$，$AC=CA=I$，则有：

$$ B=IB=(CA)B=C(AB)=CI=C$$

即 $B=C$。

有一种用行列式来判定和计算矩阵是否可逆的方法，过于繁琐，不适用于计算，只在此介绍。

定义：设 $n$ 阶方阵

$$
        \begin{bmatrix}
        a_{1,1} & a_{1,2} & a_{1,3} & \cdots & a_{1,n} \\
        a_{2,1} & a_{2,2} & a_{2,3} & \cdots & a_{2,n} \\
        \vdots & \vdots & \vdots & \ddots & \vdots \\
        a_{n,1} & a_{n,2} & a_{n,3} & \cdots & a_{n,n} \\
        \end{bmatrix}
$$

由 $A$ 的行列式 $|A|$ 中元素 $a_{ij}$ 的代数余子式 $A_{ij}$ 构成的如下 $n$ 阶方阵：

$$
        A^*=\begin{bmatrix}
        A_{11} & A_{21} & A_{31} & \cdots & A_{n1} \\
        A_{12} & A_{22} & A_{32} & \cdots & A_{n2} \\
        \vdots & \vdots & \vdots & \ddots & \vdots \\
        A_{n1} & A_{n2} & A_{3n} & \cdots & A_{nn} \\
        \end{bmatrix}
$$

称 $A^*$ 为 $A$ 的伴随矩阵，而 $A$ 可逆的充要条件为 $|A| \neq 0$，且

$$A^{-1}=\frac{A^*}{|A|}$$

此处证明需要用到行列式的性质，在此略去。

下文有更简单的判定和计算方法。

逆变换有一重要性质：若$A,B$均可逆，则$AB$也可逆，且$(AB)^{-1}=B^{-1}A^{-1}$。该性质可以反复利用，因此可以拓展到$k$个可逆行列式相乘：

$$(A_1A_2……A_k)^{-1}=A_k^{-1}A_{k-1}^{-1}……A_1^{-1}$$

### 初等矩阵

把单位矩阵进行一次初等行变换，就得到了初等矩阵。其中，初等行变换有以下三种：

1.交换矩阵的任意两行。

2.用一个非零整数 $k$ 乘矩阵的任意一行。

3.将矩阵中某一行乘以 $k$ 倍加到另外一行。

因此对于三阶单位矩阵 $I_3$

$$
        \begin{bmatrix}
        1 & 0 & 0 \\
        0 & 1 & 0\\
        -4 & 0 & 1 \\
        \end{bmatrix}
       \begin{bmatrix}
        0 & 1 & 0 \\
        1 & 0 & 0\\
        0 & 0 & 1 \\
        \end{bmatrix}
        \begin{bmatrix}
        1 & 0 & 0 \\
        0 & 1 & 0\\
        0 & 0 & 5 \\
        \end{bmatrix}
$$

均为初等矩阵。

由于初等行变换可逆（可以改过去又可以改回来），因此初等矩阵可逆。

证明：设 $E$ 为一初等矩阵，由于 $EI=E$，因此任意一个初等矩阵可以视为对 $I$ 矩阵的一种变换，使其变为 $E$ 矩阵。由于初等行变换可逆，则存在 $E$ 变换的逆变换 $F$，将 $E$ 矩阵变回 $I$，因此 $EF=I$，即 $E$ 可逆，且其逆为 $E$ 的逆变换。



------------
到此可以引出本题的证明了：

**方阵 $A$ 可逆，当且仅当 $A$ 行等价于 $I_n$** ，即 $A$ 经过若干次行变换可以变成 $I_n$。

充分性：由于 $A$ 可逆，则方程 $Ax=b$ 必有解，其中 $x,b$ 均为向量（求解只需要在等式两边左乘以 $A^{-1}$ 即可）。那么，对于解 $x$：

$$
        x=\begin{bmatrix}
        x_1\\
        x_2\\
        \vdots\\
        x_n\\
        \end{bmatrix}
$$

必可写出与 $A$ 等价的增广矩阵 $A'$（因为解一样）：

$$
        A'=\left[
    \begin{array}{cccc|c}
      1&&&&x_1\\
      &1&&&x_2\\
      &&\ddots\ && \vdots\\
      &&&1&x_n
    \end{array}
\right]
$$

那么原矩阵必与 $I_n$ 等价，否则无法化简成 $A'$

必要性：如果 $A$ 等价于 $I_n$，则 $A$ 是由若干次初等行变换得到。对于每次初等行变换都有一个对应的初等矩阵，那么这些操作可以被记作：

$$E_pE_{p-1}……E_1A=I_n$$

由矩阵逆的另一种定义，若 $A$ 可逆，则必存在一种能让 $A$ 回到 $I_n$ 的方法。考虑对上式两边左乘 $(E_pE_{p-1}……E_1)^{-1}$

$$((E_pE_{p-1}……E_1)^{-1}E_pE_{p-1}……E_1)A=(E_pE_{p-1}……E_1)^{-1}I_n$$

即 $A=(E_pE_{p-1}……E_1)^{-1}$，为可逆矩阵的乘积，因此 $A$ 可逆，且 $A^{-1}=E_pE_{p-1}……E_1$。因此，$A^{-1}$ 可以由 $E_1,E_2,……,E_p$ 依次作用于 $I_n$ 得到。

得证。

------------
### 接下来就是解法时间

我们把 $A$ 和 $I_n$ 置于同一矩阵中：

$$
        \begin{bmatrix}
        A & I_n
        \end{bmatrix}
$$

对其进行高斯-若尔当消元操作将$A$变换为$I_n$。由于是在同一矩阵中，因此$A$和$I_n$得到的操作都是一样的。我们只需要让前面的$A$变换为$I_n$，那么对于同一过程，$I_n$就会变成矩阵的逆。

用一张图来表示这个互相转化关系：

$$ A\stackrel{P}{\underset{P'}{\Leftrightarrow}}I_n\stackrel{P}{\underset{P'}{\Leftrightarrow}}A^{-1}$$

所以剩下的就是代码功夫了。代码附上：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const long long mod = 1000000007;
long long power(long long a,int x)//快速幂板子
{
    long long ans = 1;
    while(x)
    {
        if(x&1)
        {
            ans *= a;
            ans %= mod;
        }
        a *= a;
        a %= mod;
        x >>= 1;
    }
    return ans % mod;
}
long long a[405][805];
int main()
{
    int n, m;
    scanf("%d", &n);
    m = 2 * n;//矩阵的宽
    for (int i = 1; i <= n;i++)
    {
        for (int j = 1; j <= n;j++)
            scanf("%lld", &a[i][j]);
        a[i][i + n] = 1;//后面要跟上一个n阶单位矩阵
    }
    for (int i = 1; i <= n; i++)//高斯-若尔当消元的板子
    {
        int place = i;
        for (int j = i + 1; j <= n; j++)//找到绝对值最大的元素开始消元
            if(abs(a[j][i])>abs(a[place][i]))
                place = j;
        if (i != place)
            swap(a[i], a[place]);
        if(!a[i][i])//如果某行没有主元则A无法化为单位矩阵，无解
        {
            printf("No Solution");
            return 0;
        }
        long long inv = power(a[i][i], mod - 2);//本题加入的逆元特色
        for (int j = 1; j <= n; j++)
            if(j!=i)
            {
                long long multiple = a[j][i] * inv % mod;//等价于除以a[i][i]，消去其他行在第i列上的数，使之变成简化阶梯形矩阵
                for (int k = i; k <= m; k++)
                    a[j][k] = ((a[j][k] - a[i][k] * multiple) % mod + mod) % mod;
            }
        for (int j = 1; j <= m; j++)//由于此处需要简化阶梯型矩阵，要把原矩阵化为简化矩阵的必须操作。
        //“在使用高斯-若尔当消元的时候，计算机计算的时候通常采用回带法，而人操作的时候建议采用此法。”——《线性代数及其应用》
            a[i][j] = (a[i][j] * inv % mod);
    }
    for (int i = 1; i <= n;i++)
    {
        for (int j = n + 1; j <= m; j++)//只打印后面，前面的单位矩阵不要打出来了
            printf("%lld ", a[i][j]);
        printf("\n");
    }
    return 0;
}
```


---

## 作者：ghj1222 (赞：15)

建议学习线性代数后食用此题...

我们对输入的矩阵进行初等变换~~(初等乱搞)~~，同时对一个单位矩阵进行相同的初等变换，最后将我们输入的矩阵变换成单位矩阵之后，那个单位矩阵就变成了我们输入的矩阵的逆矩阵

假设我们进行初等变换的初等矩阵乘起来是$P$，且我们输入的矩阵为$A$

则$AP=E$，则$A^{-1}AP=A^{-1}E$，则$P=A^{-1}$，也就是把初等变换矩阵乘起来(或者是说把它们乘上一个单位矩阵)得到的就是矩阵的逆矩阵

把$A$消成单位矩阵就要先把A大力消成上三角矩阵，高斯消元就能做

```cpp
#include <bits/stdc++.h>
#define p 1000000007
#define int long long
using namespace std;

int n;

//定义矩阵及其初等变换 
struct matrix
{
	int a[400][400];
	
	//矩阵第x行和第y行交换
	void change1(int x, int y)
	{
		for (int i = 0; i < n; i++)
			swap(a[x][i], a[y][i]);
	}
	
	//矩阵第x行乘以k
	void change2(int x, int k)
	{
		for (int i = 0; i < n; i++)
			(((a[x][i] *= k) %= p) += p) %= p;
	}
	
	//矩阵第x行加上第y行乘以k
	void change3(int x, int y, int k)
	{
		for (int i = 0; i < n; i++)
			(((a[x][i] += a[y][i] * k % p) %= p) += p) %= p;
	}
	
	void print()
	{
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				printf("%lld%c", a[i][j], j == n - 1 ? '\n' : ' ');
	}
}a, b; 

int ksm(int x, int y = (p - 2))
{
	int ans = 1;
	while (y > 0)
	{
		if (y & 1)
			(ans *= x) %= p;
		(x *= x) %= p;
		y >>= 1;
	}
	return ans;
}

signed main()
{
	//输入
	scanf("%lld", &n);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			scanf("%lld", &a.a[i][j]);
	
	//把B赋值为单位矩阵 
	for (int i = 0; i < n; i++)
		b.a[i][i] = 1;
	
	//把A消为上三角矩阵
	for (int i = 0; i < n; i++)
	{
		if(a.a[i][i] == 0)
			for (int j = i; j < n; j++)
				if (a.a[j][i] != 0)
				{
					b.change1(i, j);
					a.change1(i, j);
					break;
				}
		if (a.a[i][i] == 0)//矩阵不是满秩的
		{
			printf("No Solution\n");
			return 0;
		}
		b.change2(i, ksm(a.a[i][i]));
		a.change2(i, ksm(a.a[i][i]));
		for (int j = i + 1; j < n; j++)
		{
			b.change3(j, i, -a.a[j][i]);
			a.change3(j, i, -a.a[j][i]);
		}
	}
	
	//把A消为单位矩阵 
	for (int i = n - 2; i >= 0; i--)
		for (int j = i +1; j < n; j++)
		{
			b.change3(i, j, -a.a[i][j]);
			a.change3(i, j, -a.a[i][j]);
		}
	
	b.print();
	return 0;
}
```

另外注意一个细节，要先对b乱搞，如果对a搞完了那么那个值就是1了，对b搞的那个值也变成1了

---

## 作者：TH911 (赞：1)

## 矩阵的逆

设方阵 $A,B$，满足 $A\times B=I$，记 $B=A^{-1}$ 为 $A$ 的**逆矩阵**。其中，$I$ 表示**单位矩阵**，即只有主对角线上有值且为 $1$ 的矩阵。

$A^{-1}$ 存在**当且仅当** $\vert A\vert\neq0$。$\vert A\vert$ 表示 $A$ 的行列式。

考虑将 $A$ 进行若干次变换从而得到 $I$，**这些变换等价于让 $A$ 乘上 $A^{-1}$**。

那么，**确定了一个矩阵 $X$，只要对 $X$ 进行这些已经固定的变换，等价于让 $X$ 乘上 $A^{-1}$**。

因此，从 $I$ 开始进行这些变换，即可得到 $I\times A^{-1}=A^{-1}$。

注：这里的变换指代的是类似于高斯消元法的初等变换。

> [例题链接](https://www.luogu.com.cn/problem/P4783)

### 参考代码

主要就是[高斯消元法](https://www.luogu.com.cn/problem/P3389)，其他的难度都还好。

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
#define int long long
typedef long long ll;
constexpr const int N=400,P=1e9+7;
int qpow(int base,int n){
	int ans=1;
	while(n){
		if(n&1){
			ans=1ll*ans*base%P;
		}
		base=1ll*base*base%P;
		n>>=1;
	}
	return ans;
}
struct Matrix{
	int n,m;
	int a[N+1][N+1];
	Matrix(int realN,int realM=-1){
		n=realN;
		if(m!=-1){
			m=realM;
		}else{
			m=n;
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				a[i][j]=0;
			}
		}
	}
	Matrix(){
		
	}
	bool inverse(Matrix &ans){
		Matrix tmp=*this;
		ans.n=ans.m=n;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				ans.a[i][j]=(i==j);
			}
		}
		
		for(int i=1;i<=n;i++){
			int p=i;
			for(int j=i+1;j<=n;j++){
				if(tmp.a[j][i]>tmp.a[p][i]){
					p=j;
				}
			}
			for(int j=1;j<=n;j++){
				swap(tmp.a[i][j],tmp.a[p][j]);
				swap(ans.a[i][j],ans.a[p][j]);
			}
			if(!tmp.a[i][i]){
				return false;
			}
			int inv=qpow(tmp.a[i][i],P-2);
			for(int j=1;j<=n;j++){
				if(i==j){
					continue;
				}
				int pl=1ll*tmp.a[j][i]*inv%P;
				for(int k=1;k<=n;k++){
					tmp.a[j][k]=(tmp.a[j][k]-1ll*pl*tmp.a[i][k])%P;
					ans.a[j][k]=(ans.a[j][k]-1ll*pl*ans.a[i][k])%P;
				}
			} 
			for(int j=1;j<=n;j++){
				tmp.a[i][j]=1ll*tmp.a[i][j]*inv%P;
				ans.a[i][j]=1ll*ans.a[i][j]*inv%P;
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(ans.a[i][j]<0){
					ans.a[i][j]+=P;
				}
			}
		}
		return true;
	}
};
main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int n;
	cin>>n;
	Matrix A(n);
	for(int i=1;i<=A.n;i++){
		for(int j=1;j<=A.n;j++){
			cin>>A.a[i][j];
		}
	}
	Matrix B;
	if(A.inverse(B)){
		for(int i=1;i<=B.n;i++){
			for(int j=1;j<=B.n;j++){
				cout<<B.a[i][j]<<' ';
			}
			cout<<'\n';
		}
	}else{
		cout<<"No Solution\n";
	}
	
	
	cout.flush(); 
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---


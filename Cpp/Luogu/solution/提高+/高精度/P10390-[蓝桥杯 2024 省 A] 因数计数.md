# [蓝桥杯 2024 省 A] 因数计数

## 题目描述

小蓝随手写出了含有 $n$ 个正整数的数组 $\{a_1, a_2,\cdots, a_n\}$，他发现可以轻松地算出有多少个有序二元组 $(i, j)$ 满足 $a_j$ 是 $a_i$ 的一个因数。因此他定义一个整数对 $(x_1, y_1)$ 是一个整数对 $(x_2, y_2)$ 的“因数”当且仅当 $x_1$ 和 $y_1$ 分别是 $x_2$ 和 $y_2$ 的因数。他想知道有多少个有序四元组 $(i, j, k, l)$ 满足 $(a_i
, a_j)$ 是 $(a_k, a_l)$ 的因数，其中 $i, j, k, l$ 互不相等。

## 说明/提示

四元组 $(1, 4, 2, 3) $：$(3, 2)$ 为 $(6, 2)$ 的因子；  
四元组 $(1, 3, 2, 4) $：$(3, 2)$ 为 $(6, 2)$ 的因子；  
四元组 $(4, 1, 3, 2) $：$(2, 3)$ 为 $(2, 6)$ 的因子；  
四元组 $(3, 1, 4, 2) $：$(2, 3)$ 为 $(2, 6)$ 的因子。

对于 $20\%$ 的评测用例，$n ≤ 50 $；  
对于 $40\%$ 的评测用例，$n ≤ 10^4$；  
对于所有评测用例，$1 ≤ n ≤ 10^5 ，1 ≤ a_i ≤ 10^5$。

## 样例 #1

### 输入

```
5
3 6 2 2 7```

### 输出

```
4```

# 题解

## 作者：KSCD_ (赞：9)

### 思路
（是 @Iceturky 的思路，在此拜谢）

值域小，为了方便表示设值域 $P={10}^5$。先开桶 $t_x$ 表示 $x$ 出现的次数。同时预处理出每个数**编号不相等**的因数个数 $s_x$ 和倍数个数 $b_x$，时间复杂度为调和级数 $O(P\ln P)$。

考虑先算出 $i\ne j$ 且 $a_i\mid a_j$ 的 $(i,j)$ 数量 $m$，枚举较小数 $x$，得 $m=\sum_{x=1}^{P}t_x\times b_x$。

有了以上问题的答案，平方一下就是 $a_i\mid a_k,a_j\mid a_l$ 且 $i\ne k,j\ne l$ 的 $(i,j,k,l)$ 组数，还需要容斥减去 $i=j,i=l,k=j,k=l$ 的组数。

首先先**减去**满足一个条件的：
- $i=j$，较小数相等，枚举这个数 $x$，取两个倍数，组数为 $\sum_{x=1}^P t_x\times b_x^2$。
- $k=l$，较大数相等，枚举这个数 $x$，取两个因数，组数为 $\sum_{x=1}^P t_x\times s_x^2$。
- $i=l$ 或 $j=k$，即一组中较大数与另一组中较小数相等。枚举相等的中间值 $x$，取一个因数和一个倍数，组数为 $\sum_{x=1}^P 2(t_x\times b_x\times s_x)$。

还需要**加上**满足两个条件的：

- $i=j$ 且 $k=l$，此时两个较小数和两个较大数分别相等，组数即为最初求出的 $(i,j)$ 数量 $m$。
- $i=l$ 且 $j=k$，由于倍数的要求限制了 $i\le k,j\le l$，所以此时 $i,j,k,l$ 均相等，枚举相等值 $x$，组数为 $\sum_{x=1}^Pt_x(t_x-1)$。
- 其他四种情况都会产生 $i=k$ 或 $j=l$，与已经确定的条件 $i\ne k,j\ne l$ 冲突，所以组数为 $0$。

之后满足三个或四个条件也会产生同样的冲突，组数均为 $0$，不用处理。

这样就做完了，但是由于 $n^4$ 达到了 ${10}^{20}$ 级别，开 __int128 才能确保通过。
### 代码
```cpp
#include<iostream>
#define int __int128
using namespace std;
const int N=1e5+10;
const int P=1e5;
int read()
{
	int s=0,w=1;
	char ch; ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
void print(int x)
{
	if(x>=10) print(x/10);
	putchar(x%10+'0');
}
int n,ans,t[N],s[N],b[N];
signed main()
{
	n=read();
	for(int i=1;i<=n;i++) t[read()]++;
	for(int i=1;i<=P;i++) if(t[i])
	{
		for(int j=i*2;j<=P;j+=i) if(t[j])
			b[i]+=t[j],s[j]+=t[i];
		b[i]+=t[i]-1,s[i]+=t[i]-1;
		ans+=t[i]*b[i];
	}
	ans*=(ans+1); //无限制和 i=k && j=l 
	for(int i=1;i<=P;i++) if(t[i])
	{
		ans-=t[i]*b[i]*b[i]; // i=j
		ans-=t[i]*s[i]*s[i]; // k=l
		ans-=2*t[i]*b[i]*s[i]; // i=l || j=k
		ans+=t[i]*(t[i]-1); // i=l && j=k 
	}
	print(ans);
	return 0;
}
```

---

## 作者：Iceturky (赞：7)

已经给你了一个前置问题，求满足 $a_i|a_j$ 的有序对 $(i,j)$ 数，那么显然可以通过这个来容斥。

我的方法可能不是最简单的，如有更简单的方法欢迎爆破（

对于有序四元组 $(i,j,k,l)$ ，先计算出满足 $i\neq k\land j\neq l$ 的数量，然后分别排除掉满足 $i=j$，$k=l$，$i=l$，$j=k$ 的四元组数量。（这里后两者其实是一样的）

对于 $i=j$ ，固定了因数，直接找两个数字满足其都为 $a_i$ 的倍数即可。

对于 $k=l$ ，固定了倍数，直接找两个因数即可。

对于 $i=l$ 或 $j=k$，固定了处在中间的数字，分别找一个因数和一个倍数即可。

注意上述三个情况都仍需要满足所找的数字与固定的数字不是同一个数字（数值可以相同），但不需要保证找的两个数字不同。

都可以通过与解决前置问题类似的方法求解。

然后再加上多减掉的部分。其总共有六种，但其中有四种的贡献都是零。因为在限制了 $i\neq k\land j\neq l$ 的前提下不可能同时有三个数是同一个数字。

那么剩下的两种就是 $i=j\land k=l$ 与 $i=l\land j=k$ 。

前者数量其实就是前置问题的数量，对于后者需要简单分析一下，发现其等价于这四个数的数值相同。

那么就是选两个不同的数字且数值相同的方案数（选择数字有序，即选第 1，3 个数字与选 3，1 个数字算两种方案）。

没有下一层容斥了，因为后面的贡献都是零，原因与前面贡献为零的原因相同。

给出代码。

code

```cpp
const int N=1e5+5;

int t[N],s[N];//分别是桶和因数个数

signed main(){
	signed n=read();
	for(int i=1;i<=n;i++)
		t[read()]++;
	int ans=0;
	int w=1e5;
	for(int i=1;i<=w;i++){
		if(t[i]==0)
			continue;
		ans+=t[i]*(t[i]-1);
		for(int j=i*2;j<=w;j+=i)
			ans+=t[i]*t[j];
	}ans*=ans+1;//加一是提前将第一个贡献加上，后面就不用再算一遍了
	for(int i=1;i<=w;i++){//i=j
		if(t[i]==0)
			continue;
		int sum=t[i]-1;
		for(int j=i*2;j<=w;j+=i)
			sum+=t[j];
		ans-=t[i]*sum*sum;
	}
	for(int i=1;i<=w;i++){//k=l
		if(t[i]==0)
			continue;
		s[i]+=t[i]-1;
		ans-=t[i]*s[i]*s[i];
		for(int j=i*2;j<=w;j+=i)
			s[j]+=t[i];
	}//print(ans),pc('\n');
	
	for(int i=1;i<=w;i++){//i=l||k=j
		if(t[i]==0)
			continue;
		int sum=t[i]-1;
		for(int j=i*2;j<=w;j+=i)
			sum+=t[j];
		ans-=t[i]*s[i]*sum*2;//这里乘二是同时计算两种
	}//print(ans),pc('\n');
	
	for(int i=1;i<=w;i++)
		if(t[i]>=2)
			ans+=t[i]*(t[i]-1);//第二个贡献，有序地选两个相同的数字的方案数
	print(ans),pc('\n');
	return 0;
}

```

---

## 作者：Eysiking (赞：1)

# 因数计数

一道比较（？）好的组合数学题。

使用 $cnt[i]$ 统计 $i$ 的出现频率，$suf[i]$ 表示 $i$ 的倍数的个数（不包括 $i$ 自身），$pre[i]$ 表示 $i$ 的因数的个数（不包括 $i$ 自身）。其中 $suf$ 和 $pre$ 数组可通过 $cnt$ 数组在 $O(N\ln N)$ 复杂度内得出（具体实现看代码即可）。 

1. 首先统计所有的二元组 $(i,j)\land i\neq j$ 的个数 $ans$ ，其中 $a_i$ 是 $a_j$ 的因数。
   
   - 对于 $a_i=a_j$ ，形成的二元组个数为 $A_{cnt[a_i]}^2$ 。
   
   - 对于 $a_i\neq a_j$ ，形成的二元组个数为 $cnt[a_i]\cdot cnt[a_j]$ 。

2. 根据二元组的个数，统计所有可以形成的四元组个数： $A_{ans}^2$ 。

3. 现在看看我们统计的所有四元组里面有哪些不合法项，现在我们假设两个二元组 $(i,j)$ ， $(k,l)$ 形成了一个四元组 $(i,j,k,l)$ ：
   
   - 首位数字重复使用（这里的重复是指对同一个下标的数字使用了两次）：如果一个数 $x$ 的 $suf[x]>1$ ，会出现 $i=j$ 的情况，所占数量为 $suf[x]\cdot (suf[x] - 1)\cdot cnt[x]$ （如 $[2,4,6]$ 会组成四元组 $(1,2,1,3)$）。
     。
   
   - 末尾数字重复使用：如果一个数 $x$ 的 $pre[x]>1$ ，会出现 $k=l$ 的情况，所占数量为 $pre[x]\cdot (pre[x] - 1)\cdot cnt[x]$ （如 $[2,3,6]$ 会组成四元组 $(1,3,2,3)$）。
   
   - 中间位数字重复使用：如果一个数 $x$ 的 $pre[x]>1\land suf[x]>1$ ，会出现 $j=k$ 的情况，所占数量为 $2\cdot pre[x]\cdot suf[x]\cdot cnt[x]$ （乘2是因为两个二元组之间有顺序）（如 $[2,4,8]$ 会组成四元组 $(1,2,2,3)$）。
     
     由于$suf$ ， $pre$ 数组没有统计 $x$ 自身的个数，我们需要计入下面的不合法项：
   
   - 对于多次出现的数字 $x$ 的首位，末位，中间位数字重复使用：如果一个数 $x$ 的 $(cnt[x]>1\land pre[x]>0)\lor(cnt[x]>1\land suf[x]>0)$ ，会出现 $i=j$ ， $j=k$ 的情况，所占数量为 $4(pre[x]\cdot (pre[x] - 1)\cdot cnt[x]+suf[x]\cdot(suf[x]-1)\cdot cnt[x])$（可以计算每种情况出现的次数均为 $2\cdot pre/suf[x]\cdot (pre/suf[x] - 1)\cdot cnt[x]$）。
   
   - 如果 $cnt[x]>1$ ，会出现 $i=l\land j=k$ 的情况，所占数量为 $cnt[x] \cdot (cnt[x] - 1)$ （如 $[2,2]$ 会组成四元组 $(1,2,2,1)$）。
   
   - 如果 $cnt[x]>2$ ，会出现 $i=j \lor j=k$ 的情况，实际上就是三个数字都相同的首位，末位，中间位数字重复使用。各占 $2\cdot cnt[x] \cdot (cnt[i] - 1) \cdot (cnt[i] - 2)$ ，一共 $4\cdot cnt[x] \cdot (cnt[i] - 1) \cdot (cnt[i] - 2)$ （如 $[2,2,2]$ 会组成四元组 $(1,1,2,3),(1,2,3,3),(1,2,2,3)$ 等）。

所有情况统计完毕，将所有四元组的数量减去不合法的情况即可。

代码如下：

```cpp
// #pragma GCC optimize(3,"Ofast","inline")
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <string>
#include <array>
#include <vector>
#include <stack>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <bitset>
#include <functional>
#include <thread>
#include <chrono>
#include <random>
#include <numeric>
#include <cstring>
#include <utility>
#include <cassert>

#define fi first
#define se second
using std::cin;
using std::cout;
using std::string;
using PII = std::pair<int, int>;
using u32 = unsigned int;
using i64 = long long;
using u64 = unsigned long long;
using i128 = __int128;
using u128 = unsigned __int128;
const int INF = 0x3f3f3f3f;
const double esp = 1e-5;

template <typename T>
string interage_to_string(T x) {
    string ret;
    while (x) {
        ret += x % 10 + '0';
        x /= 10;
    }
    if (ret.empty()) {
        ret = "0";
    }
    std::reverse(ret.begin(), ret.end());
    return ret;
}
int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n;
    const int N = 1e5 + 1;
    cin >> n;
    std::vector<int> a(n), cnt(N);
    std::vector<int> pre(N), suf(N);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        cnt[a[i]]++;
    }
    u128 ans = 0;
    for (int i = 1; i < N; i++) {
        if (cnt[i]) {
            ans += 1ll * cnt[i] * (cnt[i] - 1);
            for (int j = 2; i * j < N; j++) {
                if (cnt[i * j]) {
                    ans += 1ll * cnt[i] * cnt[i * j];
                    suf[i] += cnt[i * j];
                    pre[i * j] += cnt[i];
                }
            }
        }
    }
    ans = ans * (ans - 1);
    for (int i = 1; i < N; i++) {
        if (!cnt[i]) continue;
        if (suf[i] > 1) {
            ans -= 1ll * suf[i] * (suf[i] - 1) * cnt[i];
        }
        if (pre[i] > 1) {
            ans -= 1ll * pre[i] * (pre[i] - 1) * cnt[i];
        }
        if (pre[i] && suf[i]) {
            ans -= 1ll * cnt[i] * pre[i] * suf[i] * 2;
        }
        if (cnt[i] > 1 && pre[i]) {
            ans -= 1ll * (cnt[i] - 1) * cnt[i] * pre[i] * 2;
            ans -= 1ll * pre[i] * (cnt[i] - 1) * cnt[i] * 2;
        }
        if (cnt[i] > 1 && suf[i]) {
            ans -= 1ll * (cnt[i] - 1) * cnt[i] * suf[i] * 2;
            ans -= 1ll * suf[i] * (cnt[i] - 1) * cnt[i] * 2;
        }
        if (cnt[i] >= 2) {
            ans -= 1ll * cnt[i] * (cnt[i] - 1);
        }
        if (cnt[i] >= 3) {
            ans -= 1ll * cnt[i] * (cnt[i] - 1) * (cnt[i] - 2) * 4;
        }
    }
    cout << interage_to_string(ans) << "\n";
    return 0;
}
```

---

## 作者：xxseven (赞：0)

值域 $V$ 只有 $10^5$，这启发我们将问题搬到值域上进行考虑，这样满足 $i \mid j$ 的 $(i,j)$ 只有 $O(V \log V)$ 对。

考虑枚举 $(i,k)$，计算符合条件，即不使用 $i,k$ 的 $(j,l)$ 的对数。

考虑容斥，不使用 $i,k$ 的对数 $=$ 总对数 $-$ 使用 $i$ 的对数 $-$ 使用 $k$ 的对数 $+$ 使用 $i,k$ 的对数。

其中前三项可以使用调和级数的预处理简单求出，第四项当 $i,k$ 值相同时为 $2$，否则为 $1$。

这样我们就解决了这个问题，时间复杂度 $O(n+V \log V)$。

注意最大的答案可以达到 $10^{20}$ 左右，需要使用 `__int128`。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+6,V=1e5;
int n,a[N],b[N];
__int128 ans,tot;
void print(__int128 x){
	if(x>=10) print(x/10);
	putchar('0'+x%10);
}
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n;
	for(int x,i=1;i<=n;++i) cin>>x,a[x]++;
	for(int i=1;i<=V;++i) {
		for(int j=2*i;j<=V;j+=i) {
			b[j]+=a[i];
			b[i]+=a[j]; 
			tot+=1ll*a[i]*a[j];
		}
		tot+=1ll*a[i]*(a[i]-1);
	}
	for(int i=1;i<=V;++i) {
		if(!a[i]) continue;
		for(int j=2*i;j<=V;j+=i) {
			if(!a[j]) continue;
			__int128 now=tot-(b[i]+(a[i]-1)*2)-(b[j]+(a[j]-1)*2)+1;
			ans+=now*a[i]*a[j];
		}
		__int128 now=tot-2*(b[i]+(a[i]-1)*2)+2;
		ans+=now*a[i]*(a[i]-1);
	}
	print(ans);
	return 0;
}

```

---


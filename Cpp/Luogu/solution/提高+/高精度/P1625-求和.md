# 求和

## 题目描述

高斯还是个小 P 孩的时候就求出

$$\sum_{i=1}^n i= \frac{n \times (n+1)}{2}$$

LT 还是个小 P 孩的时候求出

$$\sum_{i=1}^{n-1} \frac{1}{i\times (i+1)}=1-\frac{1}{n}$$

现在，你还是个小 P 孩的时候，你要求出：

$$\sum_{i=1}^n \frac{1}{\prod_{j=i}^{i+m-1}j}=S$$


## 说明/提示

$m>1$，$n>0$。

$50 \%$ 的数据满足 $n \leq 50$。  
$100 \%$ 的数据满足 $n+m \leq 500$。

## 样例 #1

### 输入

```
1 2```

### 输出

```
1
2```

# 题解

## 作者：poorpool (赞：18)

蒟蒻也能写出来的AC代码！显然题目是让求


$$\frac{0!}{m!}+\frac{1!}{(m+1)!}+\frac{2!}{(m+2)!}+\cdots+\frac{(n-1)!}{(m+n-1)!}$$

易通分为


$$\dfrac{0!\dfrac{(m+n-1)!}{m!}+1!\dfrac{(m+n-1)!}{(m+1)!}+\cdots+(n-1)!\dfrac{(m+n-1)!}{(m+n-1)!}}{(m+n-1)!}$$


观察到分母是个奇大无比的数，倘若是硬算分母最后再除免不了高精除高精。哦我的老伙计，看在梅林的胡子的面子上，你一定不想写它的。于是我们就有一个优化：**先将分母分解质因数，最后进行高精除低精约分**。


再考虑分子。可以发现，分子可以化成好多个$x\dfrac{y}{z}$，且如果我们知道某一项，那么其下一项可以通过$x$乘某个数，$z$乘某个数（即$\dfrac{y}{z}$除某个数，且除完必定是整数）得到，然后分子总和再加上它。这样就会跑得飞快。


细节也是需要注意的。这里注意一点，我的除法为了这道题做了点改动，即倘若有操作`bool qaq=a/b;`其中a为高精度数，b为int，要是$b|a$则有qaq被赋值true， **且a被b除掉**。否则，qaq被赋值为false，**且a不发生改变**。


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
using namespace std;
struct bigInt{
    int num[2500], len;
    bigInt operator+(bigInt &x)const{
        bigInt re;
        memset(re.num, 0, sizeof(re.num));//不加初始化大约会有奇怪的错误，我调了一个小时QAQ 
        re.len = max(len, x.len);
        for(int i=1; i<=re.len; i++)
            re.num[i] = num[i] + x.num[i];
        int jw=0;
        for(int i=1; i<=re.len; i++){
            re.num[i] += jw;
            jw = re.num[i] / 10;
            re.num[i] %= 10;
        }
        if(jw)
            re.num[++re.len] = jw;
        return re;
    }
    bigInt operator*(int &x)const{
        bigInt re;
        memset(re.num, 0, sizeof(re.num));
        re.len = len;
        for(int i=1; i<=re.len; i++)
            re.num[i] = num[i] * x;
        int jw=0;
        for(int i=1; i<=re.len; i++){
            re.num[i] += jw;
            jw = re.num[i] / 10;
            re.num[i] %= 10;
        }
        while(jw){
            re.num[++re.len] = jw%10;
            jw /= 10;
        }
        return re;
    }
    bool operator/(const int &x){
        bigInt re;
        memset(re.num, 0, sizeof(re.num));
        re.len = len;
        int tw=0;
        for(int i=len; i>=1; i--){
            tw = tw * 10 + num[i];
            re.num[i] = tw / x;
            tw %= x;
        }
        if(tw)    return false;//除不干净 
        while(!re.num[re.len])    re.len--;
        if(!re.len)    re.len++;
        len = re.len;
        for(int i=1; i<=re.len; i++)
            num[i] = re.num[i];
        return true;
    }
    bigInt prt(){//输出函数 
        for(int i=len; i>=1; i--)
            putchar(num[i]+'0');
        putchar('\n');
    }
}fz, fztemp, fm;//fz表示分子，fm表示分母，fztemp表示当前处理分子的那一项 
vector<int> zys;//质因数 
int n, m;
bool isp[1005];
void shai(){//筛法筛质数 
    memset(isp, true, sizeof(isp));
    isp[0] = isp[1] = false;
    for(int i=2; i<=1000; i++)
        if(isp[i])
            for(int j=i+i; j<=1000; j+=i)
                isp[j] = false;
}
void makezys(int x){//对某个数分解质因数 
    for(int i=2; i<=x; i++)
        if(isp[i])
            while(x%i==0){
                zys.push_back(i);
                x /= i;
            }
}
int main(){
    cin>>n>>m;
    shai();
    fztemp.len = fm.len = 1;
    fztemp.num[1] = fm.num[1] = 1;
    fz.len = 1;
    fz.num[1] = 0;
    for(int i=1; i<=n+m-1; i++)
        makezys(i);
    for(int i=m+1; i<=n+m-1; i++)
        fztemp = fztemp * i;//先处理出0!*(n+m-1)!/m! 
    for(int i=0; i<=n-1; i++){
        if(i)    fztemp / (m+i);
        if(i)    fztemp = fztemp * i;//为了避免0!的尴尬加上if(i) 
        fz = fz + fztemp;
    }
    for(int i=0; i<zys.size(); i++){
        if(fz/zys[i])    ;
        else            fm = fm*zys[i];//不可约分，只好在分母中保留它了 
    }
    fz.prt();
    fm.prt();
    return 0;
}
```

---

## 作者：KesdiaelKen (赞：15)

~~**想要成为信息学大佬，就一定要学好小学奥数……**~~

题目要求的是：

$$\prod_{i=1}^{n}(\frac{1}{\prod_{j=i}^{m+i-1}j})$$

我们想办法对其进行**裂项求和**

我们先来看这个多项式乘积中的其中任意一项。它可以表示为：

$$\frac{1}{k(k+1)(k+2)...(k+m-1)}$$

我们需要想办法对其进行裂项。来看这个式子：

$$\frac{1}{k(k+1)(k+2)...(k+m-2)}-\frac{1}{(k+1)(k+2)(k+3)...(k+m-1)}$$

我们将两个分数通分：

$$\frac{(k+m-1)-k}{k(k+1)(k+2)...(k+m-1)}$$

即

$$\frac{m-1}{k(k+1)(k+2)...(k+m-1)}=\frac{1}{k(k+1)(k+2)...(k+m-1)}*(m-1)$$

所以

$$\frac{1}{k(k+1)(k+2)...(k+m-1)}$$
$$=\frac{1}{m-1}*\frac{m-1}{k(k+1)(k+2)...(k+m-1)}$$
$$=\frac{1}{m-1}*(\frac{1}{k(k+1)(k+2)...(k+m-2)}-\frac{1}{(k+1)(k+2)(k+3)...(k+m-1)})$$

所以我们对原式进行变换

$$\prod_{i=1}^{n}(\frac{1}{\prod_{j=i}^{m+i-1}j})$$
$$=(\frac{1}{m-1})(\frac{1}{1*...*(m-1)}-\frac{1}{2*...*m}+\frac{1}{2*...*m}-\frac{1}{3*...*(m+1)}$$

$$+...+\frac{1}{n*...*(n+m-2)}-\frac{1}{(n+1)*...*(n+m-1)})$$

中间项全都互相抵消

$$=(\frac{1}{m-1})(\frac{1}{1*...*(m-1)}-\frac{1}{(n+1)*...*(n+m-1)})$$

通分

$$=\frac{(\prod_{i=n+1}^{n+m-1})-(\prod_{i=1}^{m-1})}{(m-1)(\prod_{i=1}^{m-1})(\prod_{i=n+1}^{n+m-1})}$$

显然无法继续化简了。于是，我们需要用到高精度。

先把分母分子算出来，然后进行化简，即检查分母分子是否有相同因数，有则除去。**注意：因为分母是由若干小于等于$n+m-1$的数相乘得到，所以分母的最大质因数不会超过$n+m-1$，即化简时除数的最大边界设为$n+m-1$即可。**

高精减、乘、除都需要用到……祝您打代码愉快。

代码如下：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
using namespace std;
int n,m;
struct GJD//高精度结构体
{
	char shu[50000];
	int len;
	GJD(){memset(shu,0,sizeof(shu));len=0;}
}mm,nn,_1,lc,nn1,nn2;//mm为分母，nn为分子
int x;
GJD times(GJD a,int b)//乘法
{
	x=0;
	memset(lc.shu,0,sizeof(lc.shu));lc.len=0;
	while(lc.len<=a.len||x)
	{
		x+=a.shu[lc.len]*b;
		lc.shu[lc.len]=x%10;
		x/=10;
		lc.len++;
	}
	while(lc.shu[lc.len-1]==0)
	{
		lc.shu[lc.len-1]=0;
		lc.len--;
	}
	return lc;
}
GJD minu(GJD a,GJD b)//减法
{
	memset(lc.shu,0,sizeof(lc.shu));lc.len=0;
	x=0;
	while(lc.len<=a.len||x!=0)
	{
		x+=a.shu[lc.len]-b.shu[lc.len];
		if(x>=0)
		{
			lc.shu[lc.len]=x;
			x=0;
		}
		else
		{
			lc.shu[lc.len]=x+10;
			x=-1;
		}
		lc.len++;
	}
	while(lc.shu[lc.len-1]==0)
	{
		lc.shu[lc.len-1]=0;
		lc.len--;
	}
	return lc;
}
bool equals(GJD a,GJD b)//判断是否相等（用于判断是否整除）
{
	if(a.len!=b.len)return false;
	for(int i=0;i<a.len;i++)
	{
		if(a.shu[i]!=b.shu[i])return false;
	}
	return true;
}
GJD divide(GJD a,int b)//除法
{
	x=0;
	memset(lc.shu,0,sizeof(lc.shu));lc.len=0;
	for(int i=a.len-1;i>=0;i--)
	{
		x=x*10+a.shu[i];
		lc.shu[lc.len]=x/b;lc.len++;
		x=x%b;
	}
	for(int i=0;i<=(lc.len-1)/2;i++)swap(lc.shu[i],lc.shu[lc.len-1-i]);
	while(lc.shu[lc.len-1]==0)
	{
		lc.shu[lc.len-1]=0;
		lc.len--;
	}
	return lc;
}
void print(GJD a)//输出
{
	for(int i=a.len-1;i>=0;i--)printf("%d",(int)a.shu[i]);
	printf("\n");
}
int main()
{
	scanf("%d%d",&n,&m);
	_1.shu[0]=1;_1.len=1;nn1=nn2=_1;
	mm=times(_1,m-1);
	for(int i=1;i<=m-1;i++)mm=times(mm,i);
	for(int i=n+1;i<=n+m-1;i++)mm=times(mm,i);
	for(int i=n+1;i<=n+m-1;i++)nn1=times(nn1,i);
	for(int i=1;i<=m-1;i++)nn2=times(nn2,i);
	nn=minu(nn1,nn2);
	for(int i=2;i<=n+m-1;i++)
	{
		while(equals(times(divide(nn,i),i),nn)&&equals(times(divide(mm,i),i),mm))//如果a/b*b=a，则b|a
		{
			nn=divide(nn,i);
			mm=divide(mm,i);
		}
	}
	print(nn);print(mm);
	return 0;
}
```

---

## 作者：_Diu_ (赞：5)

**upts：修改了原来题解中的格式错误。**

首先，这一道题是可以用~~小学三年级~~奥数知识推出来的，也就是裂项。

让我们来先看一下比较简单的裂项：

$\dfrac{1}{n\times(n+1)}$

$=\dfrac{n+1-n}{n\times(n+1)}$

$=\dfrac{n+1}{n\times(n+1)}-\dfrac{n}{n\times(n+1)}$

$=\dfrac{1}{n}-\dfrac{1}{n+1}$

所以，这就可以用于题目中 $m=2$ 的情况。

$\sum\limits_{i=1}^n \dfrac{1}{i\times(i+1)} $

=$\sum\limits_{i=1}^n \dfrac{1}{i}-\dfrac{1}{i+1} $

=$1-\dfrac{1}{n+1}$

那让我们看看 $m>2$ 的情况，这里我们拿 $m=3$ 的情况举例。

$\dfrac{1}{n\times(n+1)\times(n+2)}$

$=\dfrac{1}{2}\times\dfrac{n+2-n}{n\times(n+1)\times(n+2)}$

$=\dfrac{1}{2}\times(\dfrac{n+2}{n\times(n+1)\times(n+2)}-\dfrac{n}{n\times(n+1)\times(n+2)})$

$=\dfrac{1}{2}\times(\dfrac{1}{n\times(n+1)}-\dfrac{1}{(n+1)\times(n+2)})$

然后又可以愉快的消掉了

所以，经过这个规律，我们就可以得到:

$\dfrac{1}{\prod\limits_{i=1}^m i} $

=$\dfrac{1}{m-1}*(\dfrac{1}{\prod\limits_{i=1}^{m-1} i}- \dfrac{1}{\prod\limits_{i=2}^m i})$

所以：

$Ans=\dfrac{1}{m-1} \sum\limits_{i=1}^n (\dfrac{1}{\prod\limits_{j=i}^{i+m-2} j}- \dfrac{1}{\prod\limits_{j=i+1}^{i+m-1} j})$

$=\dfrac{1}{m-1}\times(\dfrac{1}{\prod\limits_{i=1}^{m-2} i}-\dfrac{1}{\prod\limits_{j=n+1}^{n+m-1} i})$


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x=1,y=1;
signed main(){
	scanf("%lld%lld",&n,&m);
	 for(int i=0;i<m-1;i++)x*=i+1,y*=i+n+1;
	 int z=__gcd(x,y);
	 int tot=x;
	 x=y/z-x/z;
	 y=tot*y/z;
	 tot=__gcd(x,(m-1));
	 x/=tot;
	 y*=(m-1)/tot;
	 tot=__gcd(x,y);
	 x/=tot,y/=tot;
	 printf("%lld\n%lld",x,y);
}
```

然而上述代码并不能通过此题，需要开高精度。

~~喜欢 Python 的同学可以尝试写份 Python 代码。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=100010;//高精度模板
int a[maxn],b[maxn],res[maxn];
string add(string s1,string s2){
    int n=s1.length(),m=s2.length();
    for(int i=0;i<n;i++)a[i]=s1[n-1-i]-'0';
    for(int i=0;i<m;i++)b[i]=s2[m-1-i]-'0';
    int len=max(n,m)+1;
    for(int i=n;i<len;i++)a[i]=0;
    for(int i=m;i<len;i++)b[i]=0;
    for(int i=0;i<len;i++)res[i]=0;
    for(int i=0;i<len;i++){
        res[i]+=a[i]+b[i];
        if(res[i]>=10){
            res[i+1]+=res[i]/10;
            res[i]%=10;
        }
    }
    int i=len-1;
    while(res[i]==0&&i>0)i--;
    string s="";
    for(;i>=0;i--)s+=(char)(res[i]+'0');
    return s;
}
string sub(string s1,string s2){
    int n=s1.length(),m=s2.length();
    for(int i=0;i<n;i++)a[i]=s1[n-1-i]-'0';
    for(int i=0;i<m;i++)b[i]=s2[m-1-i]-'0';
    int len=max(n,m);
    for(int i=n;i<len;i++)a[i]=0;
    for(int i=m;i<len;i++)b[i]=0;
    for(int i=0;i<len;i++)res[i]=0;
    for(int i=0;i<len;i++){
        res[i]+=a[i]-b[i];
        if(res[i]<0){
            res[i+1] --;
            res[i] += 10;
        }
    }
    int i=len-1;
    while(res[i]==0&&i>0)i--;
    string s="";
    for(;i>=0;i--)s+=(char)(res[i]+'0');
    return s;
}
bool cmp(string s1,string s2){
    int n=s1.length(),m=s2.length();
    int i;
    for(i=0;i<n-1&&s1[i]=='0';i++);
    s1=s1.substr(i);
    for(i=0;i<m-1&&s2[i]=='0';i++);
    s2=s2.substr(i);
    if(s1.length()!=s2.length())return s1.length()<s2.length();
    return s1<s2;
}
string Add(string s1,string s2){
    if(s1[0]=='-'&&s2[0]=='-'){
        return "-"+add(s1.substr(1),s2.substr(1));
    }
    else if(s1[0]=='-'){
        s1=s1.substr(1);
        if(cmp(s1,s2)==true){
            return sub(s2,s1);
        }else{
            return "-"+sub(s1,s2);
        }
    }
    else if(s2[0]=='-'){
        s2=s2.substr(1);
        if(cmp(s1,s2)){
            return "-"+sub(s2,s1);
        }else{
            return sub(s1,s2);
        }
    }
    else{
        return add(s1,s2);
    }
}
string Sub(string s1,string s2){
    if(s2[0]=='-'){
        s2=s2.substr(1);
        return Add(s1,s2);
    }else{
        return Add(s1,"-"+s2);
    }
}
string multi(string s1,string s2){
    int n=s1.length(), m=s2.length();
    for(int i=0;i<n;i++)a[i]=s1[n-1-i]-'0';
    for(int i=0;i<m;i++)b[i]=s2[m-1-i]-'0';
    int len=n+m;
    for(int i=n;i<len;i++)a[i]=0;
    for(int i=m;i<len;i++)b[i]=0;
    for(int i=0;i<len;i++)res[i]=0;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            res[i+j]+=a[i]*b[j];
    for(int i=0;i<len;i++){
        res[i+1]+=res[i]/10;
        res[i]%=10;
    }
    int i=len-1;
    while(res[i]==0&&i>0)i--;
    string s="";
    for(;i>=0;i--)s+=(char)(res[i]+'0');
    return s;
}
pair<string,string> divide(string s1,string s2) {//pair<商,余数>
    string s="",t="";
    int n=s1.length(),m=s2.length();
    bool flag=false;
    for(int i=0;i<n;i++){
        s+=s1[i];
        int num=0;
        while(cmp(s,s2)==false){
            num++;
            s=sub(s,s2);
        }
        if(num>0){
            flag=true;
            char c=(char)(num+'0');
            t+=c;
        }
        else if(flag){
            t+='0';
        }
    }
    if(t.length()==0)t="0";
    while(s[0]=='0'&&s.length()>1)s=s.substr(1);
    return make_pair(t,s);
}
string gcd(string a,string b){
	if(b=="0")return a;
	return gcd(b,divide(a,b).second);
}
string n,m,x="1",y="1";
signed main(){
	cin>>n>>m;
	 for(string i="1";cmp(i,m);i=Add(i,"1"))x=multi(x,i),y=multi(Add(i,n),y);//两个大分母
	 string z=gcd(x,y);
	 string tot=x;
	 x=divide(Sub(y,x),z).first;
	 y=divide(multi(tot,y),z).first;
	 tot=gcd(x,(Sub(m,"1")));
	 x=divide(x,tot).first;
	 y=multi(y,divide(Sub(m,"1"),tot).first);
	 tot=gcd(x,y);
	 x=divide(x,tot).first,y=divide(y,tot).first;
	 cout<<x+'\n'+y;
}
```

另外，整数的类似运算也是可以裂项的，[T164463](https://www.luogu.com.cn/problem/T164563) 和 [T166186](https://www.luogu.com.cn/problem/T164566) 就是用整数裂项的方法做的，如果有感兴趣的同学可以看下[题解](https://www.luogu.com.cn/blog/diu/ti-xie-u149189-xin-xue-hao-post)。

---

## 作者：_Chesed_ (赞：4)

# [P1625 求和](https://www.luogu.com.cn/problem/P1625)
## 大意
给定 $n,m$，求：
$$s=\frac{1}{1\times 2\times...\times m} +\frac{1}{2\times 3\times...\times(m+1)}+...\frac{1}{n\times (n+1)\times...\times (n+m-1)}  $$
## 分析
### 暴力（20 pts）
一目了然，不多叙述。
### 裂项（正解）
先来复习一下小学的裂项公式（题目也给出了）：
$$\sum_{i=1}^{n-1} \frac{1}{i\times (i+1)}=1-\frac{1}{n}$$
观察题目给出的式子，发现有规律，那么可以用一个式子推出整个式子的规律。

小学的拓展裂项知识，有：
$$\frac{1}{1\times 2\times...\times m}=\frac{1}{m-1}\times(\frac{1}{1\times 2\times...\times (m-1)}-\frac{1}{2\times 3\times...\times m})$$
带入题目的式子中，得：
$$s=\frac{1}{m-1}\times(\frac{1}{1\times 2\times...\times (m-1)}-\frac{1}{2\times 3\times...\times m}) +\frac{1}{m-1}\times(\frac{1}{2\times 3\times...\times m}-\frac{1}{3\times 4\times...\times (m+1)})+...+\frac{1}{m-1}\times(\frac{1}{n\times (n+1)\times...\times (m+n-2)}-\frac{1}{(n+1)\times (n+2)\times...\times (m+n-1)}) $$
即：
$$s=\frac{1}{m-1}\times(\frac{1}{1\times 2\times...\times (m-1)}-\frac{1}{(n+1)\times (n+2)\times...\times (m+n-1)}) $$
没法再化简了，那么就按照上式计算。

由于 $n+m\le 500$，需要高精度，然后根据[算术唯一分解定理](https://baike.baidu.com/item/%E6%83%9F%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/22770222)化简。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10000;
int fm[1050]= {0},ans[1050]= {1,1},fz[1050]= {1,1},n,m;
bool r[505]= {0};
void print(int ans[]) {
	printf("%d",ans[ans[0]]);
	for(int i=ans[0]-1; i>=1; i--) {
		printf("%d%d%d%d",ans[i]/1000,ans[i]/100%10,ans[i]/10%10,ans[i]%10);
	}
}
void cd(int ans[],int u) {//高精乘单精 
	for(int i=1; i<=ans[0]; i++) {
		ans[i]=ans[i]*u;
	}
	for(int i=1; i<=ans[0]; i++) {
		ans[i+1]+=ans[i]/mod;
		ans[i]%=mod;
	}
	while(ans[ans[0]+1]>0) {
		ans[0]++;
		ans[ans[0]+1]=ans[ans[0]]/mod;
		ans[ans[0]]%=mod;
	}
}
void cg(int ans[],int fz[],int c[]) {//高精乘高精 
	memset(c,0,sizeof(c));
	c[0]=ans[0]+fz[0];
	for(int i=1; i<=ans[0]; i++) {
		for(int j=1; j<=fz[0]; j++) {
			c[i+j-1]+=ans[i]*fz[j];
			c[i+j]+=c[i+j-1]/mod;
			c[i+j-1]%=mod;
		}
	}
	while(c[0]>0&&c[c[0]]==0) c[0]--;
}
void j(int ans[],int fz[]) {//高精减
	for(int i=1; i<=ans[0]; i++) {
		if(ans[i]<fz[i]) {
			ans[i+1]--;
			ans[i]+=mod;
		}
		ans[i]=ans[i]-fz[i];
	}
	while (ans[ans[0]]==0&&ans[0]>0) ans[0]--;
}
void d(int ans[],int x) {
	int k=0;
	for(int i=ans[0]; i>=1; i--) {
		k=k*mod+ans[i];
		ans[i]=k/x;
		k%=x;
	}
	while(ans[ans[0]]==0&&ans[0]>0) ans[0]--;
}
int mo(int ans[],int x) {//余数 
	int k=0;
	for(int i=ans[0]; i>=1; i--) {
		k=k*mod+ans[i];
		k%=x;
	}
	return k;
}
void gcd() {//高精度gcd 
	int i,j;
	i=2;
	while(i<=m+n) { 
		if(r[i]==0) {
			while(mo(fz,i)==0&&mo(fm,i)==0) {
				d(fz,i);
				d(fm,i);
			}
			j=i*i;
			while(j<=m+n) {
				r[j]=1;
				j+=i;
			}
		}
		i++;
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=2; i<=m-1; i++){
		cd(ans,i);
	}
	for(int i=n+1;i<=n+m-1;i++){
		cd(fz,i);
	}
	cg(ans,fz,fm);
	cd(fm,m-1);
	j(fz,ans);
	gcd();
	print(fz);
   printf("\n");
	print(fm);
	return 0;
}
```


---

## 作者：破忆 (赞：4)

[P1625 求和](https://www.luogu.com.cn/problem/P1625)

NOIP2021 快到了，退役之后大概就是天天 python 题吧。

## 【题意】

求 ${\sum_{i=1}^n}\frac1{\prod_{j=i}^{i+m-1}j}$。

## 【分析】

简洁的题面，虚假的式子，形同虚设的数据范围。

积的值很大，python 大法好啊。

模拟即可。

## 【算法】

模拟

## 【代码】

```python
def gcd(x,y):
    if y==0:
        return x
    else:
        return gcd(y,x%y)
n,m=map(int,input().split())
P,Q=0,1
for i in range (1,n+1,1):
    now=1
    for j in range(i,i+m,1):
        now*=j
    P,Q=P*now+Q,now*Q
g=gcd(P,Q)
print(P//g)
print(Q//g)
```


---

## 作者：songyuchen (赞：4)

通过通分，可以发现分母就是(n+m-1)!，而分子则是若干个满足(n+m-1)!中去掉连续的一段的和。那么这个分子如何求呢？我们可以先求出(m+1)*****(n+m-1)放在累乘器res里面，然后每次相当于前面乘上一个，后面除掉一个。也就是这样

```cpp
for (int i=1;i<=n;i++)
    {
        fenzi=fenzi+res;
        res=res*i;
        res=res/(m+i);
    }
```
为了避免高精度除法，我们将分母质因数分解，然后我们就只要约分的时候约低精度了。

以下是cpp代码，使用重载运算符实现高精度

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;

#define ll long long
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))

const int maxN=600;
const int maxNum=5000;
const int inf=2147483647;

class BigInteger
{
public:
    int siz;
    ll Num[maxNum];
    BigInteger();
    BigInteger(int x);
    BigInteger(ll x);
    void operator = (int B);
    bool operator == (int B);
    bool operator == (BigInteger B);
    bool operator < (BigInteger B);
    BigInteger operator + (BigInteger B);
    BigInteger operator * (ll B);
    BigInteger operator / (ll B);
};

ostream& operator << (ostream & os,BigInteger A)
{
    if (A.siz==0)
    {
        os<<0;
        return os;
    }
    for (int i=A.siz;i>=1;i--)
        os<<A.Num[i];
    return os;
}

int n,m;
int Fac[1000];//存因子的个数

int main()
{
    cin>>n>>m;
    BigInteger fenzi=0;
    BigInteger res=1;
    for (int i=m+1;i<=n+m-1;i++)//计算分子
        res=res*i;
    for (int i=1;i<=n;i++)
    {
        fenzi=fenzi+res;
        res=res*i;
        res=res/(m+i);
    }
    mem(Fac,0);//分解分母
    for (int i=1;i<=n+m-1;i++)
    {
        int x=i;
        for (int j=2;j<=x;j++)
            while (x%j==0)
            {
                Fac[j]++;
                x=x/j;
            }
    }
    for (int i=2;i<=n+m-1;i++)//约分
        while (Fac[i]!=0)
        {
            BigInteger s;
            s=fenzi/i;
            s=s*i;
            if (s==fenzi)
            {
                fenzi=fenzi/i;
                Fac[i]--;
            }
            else
                break;
        }
    cout<<fenzi<<endl;//输出分子
    BigInteger fenmu=1;
    for (int i=2;i<=n+m-1;i++)//计算分母
        while (Fac[i]!=0)
        {
            fenmu=fenmu*i;
            Fac[i]--;
        }
    cout<<fenmu<<endl;//输出分母
    fclose(stdin);
    fclose(stdout);
}

BigInteger::BigInteger()
{
    siz=0;
    mem(Num,0);
}

BigInteger::BigInteger(int B)
{
    siz=0;
    mem(Num,0);
    while (B!=0)
    {
        siz++;
        Num[siz]=B%10;
        B=B/10;
    }
}

BigInteger::BigInteger(ll B)
{
    siz=0;
    mem(Num,0);
    while (B!=0)
    {
        siz++;
        Num[siz]=B%10;
        B=B/10;
    }
}

void BigInteger::operator = (int B)
{
    siz=0;
    mem(Num,0);
    while (B!=0)
    {
        siz++;
        Num[siz]=B%10;
        B=B/10;
    }
}

bool BigInteger::operator == (BigInteger B)
{
    if (siz!=B.siz)
        return 0;
    for (int ii=1;ii<=siz;ii++)
        if (Num[ii]!=B.Num[ii])
            return 0;
    return 1;
}

bool BigInteger::operator == (int B)
{
    BigInteger A(B);
    if (A==B)
        return 1;
    return 0;
}

bool BigInteger::operator < (BigInteger B)
{
    if (siz<B.siz)
        return 1;
    if (siz>B.siz)
        return 0;
    for (int ii=siz;ii>=1;ii--)
    {
        if (Num[ii]>B.Num[ii])
            return 0;
        if (Num[ii]<B.Num[ii])
            return 1;
    }
}

BigInteger BigInteger::operator + (BigInteger B)
{
    BigInteger Ans;
    Ans.siz=max(siz,B.siz);
    for (int ii=1;ii<=Ans.siz;ii++)
        Ans.Num[ii]=Num[ii]+B.Num[ii];
    for (int ii=1;ii<Ans.siz;ii++)
    {
        Ans.Num[ii+1]+=Ans.Num[ii]/10;
        Ans.Num[ii]%=10;
    }
    while (Ans.Num[Ans.siz]>=10)
    {
        Ans.Num[Ans.siz+1]+=Ans.Num[Ans.siz]/10;
        Ans.Num[Ans.siz]%=10;
        Ans.siz++;
    }
    return Ans;
}

BigInteger BigInteger::operator * (ll B)
{
    BigInteger Ans;
    for (int ii=1;ii<=siz;ii++)
        Ans.Num[ii]=1ll*Num[ii]*(ll)(B);
    Ans.siz=siz;
    for (int ii=1;ii<Ans.siz;ii++)
    {
        Ans.Num[ii+1]+=Ans.Num[ii]/10;
        Ans.Num[ii]%=10;
    }
    while (Ans.Num[Ans.siz]>=10)
    {
        Ans.Num[Ans.siz+1]+=Ans.Num[Ans.siz]/10;
        Ans.Num[Ans.siz]%=10;
        Ans.siz++;
    }
    return Ans;
}

BigInteger BigInteger::operator / (ll B)
{
    BigInteger Ans;
    int res=0;
    for (int ii=siz;ii>=1;ii--)
    {
        res=res*10+Num[ii];
        Ans.Num[ii]=res/B;
        res=res%B;
    }
    Ans.siz=siz;
    while (Ans.Num[Ans.siz]==0)
        Ans.siz--;
    return Ans;
}
```

---

## 作者：xkcdjerry (赞：3)

翻译一下题目要求：  
让我们求
$$\frac{0!}{m!}+\frac{1!}{(m+1)!}+\frac{2!}{(m+2)!}+...+\frac{(n-1)!}{(m+n-1)!}$$  
那么各位不想打高精度和分数加法的我们一定能想到 ~~万恶~~ 万能的 Python 。  
虽然这里已经有一些用 Python 语言的题解，但是大多使用 C/C++ 风格的命令式编程 ~~浪费了 Python 大好的标准库~~ ，这里菜鸡给出一个利用 Python STL 的 5 行题解：（附详细讲解） 
```python
from fractions import Fraction as F
from math import factorial as f
n,m=map(int,input().split())
g=sum(F(f(i),f(m+i)) for i in range(n))
print(g.numerator, g.denominator, sep='\n')
```
前面三行都是常见操作：  
第一行从 `fractions`（分数库）导入 `Fraction`（分数类）并取别名为 `F` 。  
第二行从 `math` （数学库） 导入 `fractorial` （阶乘函数）并取别名为 `f` 。  
第三行是一个读入一行中的多个整数的常用技巧。  

第四行则是程序的核心：（一行求出答案）
* 首先，`sum(xxx for i in range(n))` 会将 $i$ 从 $0$ 循环到 $n-1$ ，并且对于每一个 $i$ 求值 `xxx` ，最后返回结果的和。
* 其次， `F(x,y)` 会返回一个可以进行加减乘除的各种操作的分数对象，其中分子为 $x$ ，分母为 $y$ 并自动约分。  
* 最后， `f(x)` 则使用分治优化的快速阶乘算法求出 $x!$ 的值。

第五行意思是输出 `g` 的 `numerator` （分子） 和 `denominator` （分母），其中 `sep='\n'` （即用 `\n` 分开）  

也就这样，我们用五行代码切掉了这道紫题。  

[AC记录](https://www.luogu.com.cn/record/54821489)  

后记：有意思的一点是，由于 PyPy 在启动时会自动编译代码，所以没有加速反而使得运行时间[变成了原来的四倍多](https://www.luogu.com.cn/record/54821528)。

---

## 作者：船酱魔王 (赞：2)

# P1625 求和 题解

## 题意回顾

定义 $ M(x,y)=\frac{1}{\prod_{i=x}^{y}i} $，求出 $ \sum_{i=1}^{n}{M(i,i+m-1)} $，以高精度最简分数形式输出。

## 分析

$$ M(n,n+m-1)

=\frac{(n+m-1)-n}{\prod_{i=n}^{n+m-1}i}\times\frac{1}{m-1} $$

$$ =\frac{1}{m-1}\times(\frac{1}{\prod_{i=n}^{n+m-2}i}-\frac{1}{\prod_{i=n+1}^{n+m-1}i}) $$

然后我们将相邻的 $ M(i,i+m-1) $ 值的部分元素抵消，可得 $ \sum_{i=1}^{n}{M(i,i+m-1)}=\frac{1}{m-1}\times (\frac{1}{\prod_{i=1}^{m-1}i}+\frac{1}{\prod_{i=n+1}^{n+m-1}i}) $。

之后，我们将式子通分即可，位数显然不超过 $ \log_{10}{500!}<\log_{10}{1000^{500}}=1500 $，则高精度计算即可（涉及高精度乘单精度/高精度减法/高精度比大小/高精度除法）。

通分可以辗转相减法，先不断除以 $ 2 $ 消去所有偶数因子，再进行辗转相减，因为减法后每几次必出一次偶数，所以可以再消掉 $ 2 $ 因子，求出 $ \gcd $ 后再除就行。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int L = 1505;
int n, m;
struct bigint {
    int lent;
    int num[L];
} zero, one;
void out(bigint x) {
    for(int i = x.lent; i >= 1; i--) {
        printf("%d", x.num[i]);
    }
    printf("\n");
}
bigint operator*(bigint p1, int p2) {
    for(int i = 1; i <= p1.lent; i++) {
        p1.num[i] *= p2;
    }
    for(int i = 1; i < p1.lent; i++) {
        p1.num[i + 1] += p1.num[i] / 10;
        p1.num[i] %= 10;
    }
    while(p1.num[p1.lent] >= 10) {
        p1.num[p1.lent + 1] += p1.num[p1.lent] / 10;
        p1.num[p1.lent] %= 10;
        p1.lent++;
    }
    return p1;
}
bigint operator-(bigint p1, bigint p2) {
    for(int i = 1; i <= p1.lent; i++) {
        p1.num[i] -= p2.num[i];
    }
    for(int i = 1; i <= p1.lent; i++) {
        if(p1.num[i] < 0) {
            p1.num[i + 1]--;
            p1.num[i] += 10;
        }
    }
    while(p1.num[p1.lent] == 0 && p1.lent >= 1) {
        p1.lent--;
    }
    return p1;
}
bool operator<(bigint &p1, bigint &p2) {
    if(p1.lent != p2.lent) return p1.lent < p2.lent;
    for(int i = p1.lent; i >= 1; i--) {
        if(p1.num[i] != p2.num[i]) return p1.num[i] < p2.num[i];
    }
    return false;
}
int operator%(bigint &p1, int p2) {
    if(p2 != 2) printf("dthkxy AK IOI\n");
    return p1.num[1] % 2;
}
bigint operator/(bigint p1, int p2) {
    if(p2 != 2) printf("dthkxy AK IOI\n");
    int rm = 0;
    bigint res = zero;
    res.lent = p1.lent;
    for(int i = p1.lent; i >= 1; i--) {
        rm = rm * 10 + p1.num[i];
        res.num[i] = rm / 2;
        rm %= 2;
    }
    while(res.lent > 0 && res.num[res.lent] == 0) res.lent--;
    return res;
}
bigint p1, p2, q;
bigint operator/(bigint p1, bigint p2) {
    bigint res = zero;
    res.lent = p1.lent;
    for(int i = p1.lent; i >= p2.lent; i--) {
        bigint tmp = zero;
        tmp.lent = i;
        for(int j = 1; j <= p2.lent; j++) {
            tmp.num[i - j + 1] = p2.num[p2.lent - j + 1];
        }
        for(int j = 1; j <= 9; j++) {
            if(p1 < tmp) break;
            res.num[i - p2.lent + 1] = j;
            p1 = p1 - tmp;
        }
    }
    while(res.lent > 0 && res.num[res.lent] == 0) res.lent--;
    return res;
}
int main() {
    scanf("%d%d", &n, &m);
    one.lent = 1;
    one.num[1] = 1;
    p1 = p2 = q = one;
    for(int i = n + 1; i <= n + m - 1; i++) {
        if(1 <= i && i <= m - 1) continue;
        p1 = p1 * i;
    }
    for(int i = 1; i <= m - 1; i++) {
        if(n + 1 <= i && i <= n + m - 1) continue;
        p2 = p2 * i;
    }
    for(int i = 1; i <= n + m - 1; i++) {
        if(i <= m - 1 || i >= n + 1) {
            q = q * i;
        }
    }
    q = q * (m - 1);
    p1 = p1 - p2;
    while(p1 % 2 == 0 && q % 2 == 0) p1 = p1 / 2, q = q / 2;
    bigint px, qx;
    px = p1, qx = q;
    while(true) {
        while(px % 2 == 0) px = px / 2;
        while(qx % 2 == 0) qx = qx / 2;
        if(px < qx) swap(px, qx);
        px = px - qx;
        if(px.lent == 0) break;
    }
    p1 = p1 / qx;
    q = q / qx;
    out(p1);
    out(q);
    return 0;
}

```

---

## 作者：ysner (赞：2)

这道题搞优化真耗脑。。。

思路：

可以把原来的式子进行通分，发现分母就是(n+m-1)!，分子具有以下规律：

(m+1)\*(m+2)\*…\*(n+m-1)+1\*(m+2)\*…\*(n+m-1)+1\*2\*(m+3)\*…\*(n+m-1)+…+1\*2\*…(n-1)。

于是只要用高精度来模拟以上规律即可。最后需要约分。

注意事项：

1、最后再约分应该贼慢，不如把分母质因数分解，再一一看乘出的分子能否除尽质因子；

2、高精度运算包括高精加高精、高精乘低精、高精除低精、高精模高精、高精比大小。（高精乘高精比高精除低精慢！！！）

3、最重要的优化：发现分子每一项有相似之处，总共有n-1项，从第二项开始，第i项都是(第i-1项/(m+i)\*i)。这样每算出分子一项的过程中都少了一串高精乘低精，TLE永远成为历史。。。

4、其实也没必要写高精模低精，题目中我是用这个来判是否能整除，要判tot%i==0可以通过cheng=tot/i;cheng=cheng\*i，再判cheng==tot即可。

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define il inline
#define re register
#define ll unsigned long long
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
```
class BigInteger
{ 
public:

int size,num[10086];//size代表数的长度，num存大整型数

```cpp
    BigInteger()//定义时自动清零
        {
            size=0;
            memset(num,0,sizeof(num));
        }
    BigInteger(int data)
        {
            size=0;
            while (data!=0)
            {
                size++;
                num[size]=data%10;
                data=data/10;
            }
        }
    il void init(int data)//用来给大整型变量赋整型值
        {
            size=0;
            while (data!=0)
            {
                size++;
                num[size]=data%10;
                data=data/10;
            }
        }
    il void ycb(BigInteger A)//大整数赋值函数
    {
      int s1=size,s2=A.size;
      size=s2;
      for(int i=s2;i>=1;i--)
        num[i]=A.num[i];
    }
    void print()
    {
        for (int i=size;i>=1;i--)
            printf("%d",num[i]);
    }
};
il BigInteger operator + (BigInteger A,BigInteger B)//高精度加法
{
    BigInteger Ans;
    re int s=max(A.size,B.size);
    Ans.size=s;
    for (re int i=1;i<=s;i++)
        Ans.num[i]=A.num[i]+B.num[i];
    for (re int i=1;i<=s;i++)
        if (Ans.num[i]>=10)
        {
            Ans.num[i+1]+=Ans.num[i]/10;
            Ans.num[i]=Ans.num[i]%10;
        }
    if (Ans.num[s+1]!=0)
        Ans.size++;
    return Ans;
}
il BigInteger operator * (BigInteger A,re int b)//高精乘低精
{
    BigInteger Ans;
    re int s1=A.size;
    Ans.size=s1;
    re int yy=0;
    fp(i,1,s1)
    {
        Ans.num[i]=A.num[i]*b+yy;
        yy=Ans.num[i]/10;
        Ans.num[i]%=10;
    }
    while(yy)
    {
        Ans.num[++Ans.size]=yy%10;
        yy/=10;
    }
    return Ans;
}
il BigInteger operator / (BigInteger A,re int b)//高精除单精
{
    BigInteger Ans;
    re int s1=A.size,k;
    k=s1;
    for(re int i=s1;i>=1;i--)
    {
        Ans.num[i]=A.num[i]/b;
        if(i!=1) A.num[i-1]+=(A.num[i]%b*10);
           A.num[i]/=b;
    }
    while(k>=1&&Ans.num[k]==0) k--;
    Ans.size=k;
    return Ans;
}
il int operator % (BigInteger A,re int b)//高精模高精
{
    BigInteger Ans;
    re int s1=A.size,k;
    k=s1;
    for(re int i=s1;i>=1;i--)
    {
        Ans.num[i]=A.num[i]/b;
        A.num[i-1]+=(A.num[i]%b*10);
           A.num[i]/=b;
    }
    return A.num[0];
}
il bool operator > (BigInteger A,BigInteger B)//高精比大小
{
    re int s1=A.size,s2=B.size;
    if(s1<s2) return 0;
    if(s1>s2) return 1;
    for(re int i=s1;i>=1;i--)
        if(A.num[i]<B.num[i]) return 0;
        else return 1;
    return 0;
}
BigInteger tot,cheng;
int n,m,f[501]={};
il int gi()
{
   re int x=0;
   re short int t=1;
   re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
    freopen("sum.in","r",stdin);
    freopen("sum.out","w",stdout);
    n=gi();m=gi();
    tot=0;
    cheng.init(1);
    fp(j,m+1,m+n-1) cheng=cheng*j;
    tot=cheng;
    fp(i,1,n-1)
    {
        cheng=cheng/(m+i);
        cheng=cheng*i;
        tot=tot+cheng;
```
}//最重要优化
```cpp
    fp(i,2,n+m-1)
    {
        int x=i;
        fp(k,2,x)
            while(x%k==0) f[k]++,x/=k;//质因数分解
    }
    fp(i,2,n+m-1)//给分子约分
        while(f[i])
        {
            if(tot%i!=0) break;
            else
            {
                f[i]--;
                tot=tot/i;
            }
        }
    tot.print();//输出分子
    printf("\n");
    tot=1;
    fp(i,2,n+m-1)
        while(f[i]--) tot=tot*i;//给分母约分
    tot.print();//输出分母
    printf("\n");
    return 0;
}
```

---

## 作者：Karry5307 (赞：1)

### 题意

给定两个整数 $n,m$，求

$$\sum\limits_{i=1}^{n}\frac{1}{\prod\limits_{j=i}^{i+m-1}j}$$

$\texttt{Data Range:}1\leq n+m\leq 500$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13805544.html)

小学奥数，裂项相消。

比如说有如下例子：

$$\frac{1}{1\times2\times3}=\frac{1}{2}\left(\frac{1}{1\times2}-\frac{1}{2\times 3}\right)$$

考虑以这个作为范例来 generalize 一下

$$\frac{1}{\prod\limits_{j=i}^{i+m-1}j}=\frac{1}{m-1}\left(\frac{1}{\prod\limits_{j=i}^{i+m-2}j}-\frac{1}{\prod\limits_{j=i+1}^{i+m-1}j}\right)$$

然后求和就好了，注意到右边是叠缩求和，直接用最后一项减去第一项即可。

$$\sum\limits_{i=1}^{n}\frac{1}{\prod\limits_{j=i}^{i+m-1}j}=\frac{1}{m-1}\sum\limits_{i=1}^{n}\left(\frac{1}{\prod\limits_{j=i}^{i+m-2}j}-\frac{1}{\prod\limits_{j=i+1}^{i+m-1}j}\right)=\frac{1}{m-1}\left(\frac{1}{\prod\limits_{j=1}^{m-1}j}-\frac{1}{\prod\limits_{j=n+1}^{n+m-1}j}\right)$$

接下来考虑如何不写高精除高精来通过这个题。

显然括号内的东西通分是可以靠分子分母的质因数分解形式的。

于是只要先算出括号内分子分母的质因数分解形式，再用高精乘算出实际分子，减去 $1$ 之后再质因数分解。最后分子分母抵掉就好了。

所以这个时候只需要考虑高精除低精和高精模低精两个操作就好了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51,BASE=1000000000;
const li BASE2=(li)BASE*BASE;
struct BigInt{
	vector<ll>v;
	ll neg;
	BigInt();
	BigInt(const string &x);
	BigInt(const char *x);
	BigInt(ll x);
	BigInt(li x);
	BigInt(const BigInt &x);
	inline void setup();
	inline void setupStr(const char *str);
	inline BigInt& reduce();
	inline ll isZero()const;
	inline string toString()const;
	inline void op()const;
	inline BigInt &operator =(const string &x);
	inline BigInt &operator =(const char *x);
	inline BigInt &operator =(ll x);
	inline BigInt &operator =(li x);
	inline BigInt &operator =(const BigInt &x);
	inline ll compareAbs(const BigInt &x)const;
};
ll n,m,c;
BigInt f,g;
ll fn[MAXN],fd[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void BigInt::setup()
{
	neg=0,v.clear(),v.push_back(0);
}
inline void BigInt::setupStr(const char *str)
{
	ll len;
	char token[10];
	setup(),len=strlen(str),*str=='-'?neg=1,++str,--len:1,token[9]=0;
	if(!len||(len==1&&*str=='0'))
	{
		return (void)(neg=0);
	}
	v.clear();
	for(register int i=1;i*9<=len;i++)
	{
		memcpy(token,str+(len-i*9),9),v.push_back((ll)(strtol(token,NULL,10)));
	}
	if(len%9)
	{
		memcpy(token,str,len%9),token[len%9]=0;
		v.push_back((ll)(strtol(token,NULL,10)));
	}
	reduce();
}
inline ll BigInt::isZero()const
{
	return v.size()==1&&!v.back();
}
inline BigInt& BigInt::reduce()
{
	while(v.size()>1&&!v.back())
	{
		v.pop_back();
	}
	return isZero()?neg=0:1,*this;
}
inline string BigInt::toString()const
{
	string res;
	char token[10];
	ll c=v.size()-1;
	neg&&!this->isZero()?res.push_back('-'):(void)1;
	for(sprintf(token,"%d",v[c]);res+=token,c--;sprintf(token,"%09d",v[c]));
	return res;
}
inline void BigInt::op()const
{
	return (void)(cout<<this->toString());
}
BigInt::BigInt()
{
	setup();
}
BigInt::BigInt(const string &x)
{
	this->setupStr(x.c_str());
}
BigInt::BigInt(const char *x)
{
	this->setupStr(x);
}
BigInt::BigInt(ll x)
{
	setup(),x<0?(neg=1,x=-x):1,v.back()=x%BASE;
	x>=BASE?v.push_back(x/BASE):(void)1;
}
BigInt::BigInt(li x)
{
	setup(),x<0?(neg=1,x-=x):1,v.back()=x%BASE;
	x>=BASE?v.push_back(x/BASE%BASE):(void)1;
	x>=BASE2?v.push_back(x%BASE2):(void)1;
}
BigInt::BigInt(const BigInt &x)
{
	neg=x.neg,v=x.v;
}
inline BigInt& BigInt::operator =(const string &x)
{
	return this->setupStr(x.c_str()),*this;
}
inline BigInt& BigInt::operator =(const char *x)
{
	return this->setupStr(x),*this;
}
inline BigInt& BigInt::operator =(ll x)
{
	setup(),x<0?(neg=1,x=-x):1,v.back()=x%BASE;
	return x>=BASE?v.push_back(x/BASE):(void)1,*this;
}
inline BigInt& BigInt::operator =(li x)
{
	setup(),x<0?(neg=1,x=-x):1,v.back()=x%BASE;
	x>=BASE?v.push_back(x/BASE%BASE):(void)1;
	return x>=BASE2?v.push_back(x%BASE2):(void)1,*this;
}
inline BigInt& BigInt::operator =(const BigInt &x)
{
	neg=x.neg,v=x.v,*this;
}
inline ll BigInt::compareAbs(const BigInt &x)const
{
	if(v.size()!=x.v.size())
	{
		return (v.size()<x.v.size())?-1:1;
	}
	for(register int i=v.size()-1;i>=0;i--)
	{
		if(v[i]!=x.v[i])
		{
			return (v[i]<x.v[i])?-1:1;
		}
	}
	return 0;
}
inline BigInt unsignedAdd(BigInt &x,BigInt &y)
{
	BigInt res;
	ll mx=max(x.v.size(),y.v.size()),carry=0;
	x.v.resize(mx+1),y.v.resize(mx+1),res.v.resize(mx+1);
	for(register int i=0;i<=mx;i++)
	{
		(res.v[i]=x.v[i]+y.v[i]+carry)>=BASE?res.v[i]-=BASE,carry=1:carry=0;
	}
	return x.reduce(),y.reduce(),res.reduce();
}
inline BigInt unsignedSub(BigInt &x,BigInt &y)
{
	BigInt res;
	ll mx=max(x.v.size(),y.v.size()),carry=0;
	x.v.resize(mx+1),y.v.resize(mx+1),res.v.resize(mx+1);
	for(register int i=0;i<=mx;i++)
	{
		(res.v[i]=x.v[i]-y.v[i]+carry)<0?res.v[i]+=BASE,carry=-1:carry=0;
	} 
	return x.reduce(),y.reduce(),res.reduce();
}
inline BigInt operator +(BigInt x,BigInt y)
{
	BigInt res;
	res=x.neg==y.neg?unsignedAdd(x,y):unsignedSub(x,y);
	return res.neg=x.neg!=y.neg?(x.compareAbs(y)>=0?x.neg:y.neg):x.neg,res;
}
inline BigInt operator +=(BigInt &x,BigInt y)
{
	return x=x+y,x;
}
inline BigInt operator -(BigInt x,BigInt y)
{
	BigInt res;
	res=x.neg==y.neg?unsignedSub(x,y):unsignedAdd(x,y);
	return res.neg=x.neg==y.neg?(x.compareAbs(y)>=0?x.neg:y.neg):x.neg,res;
}
inline BigInt operator -=(BigInt &x,BigInt y)
{
	return x=x-y,x;
}
inline BigInt operator *(BigInt x,ll u)
{
	BigInt res;
	ll mx=x.v.size(),carry=0;
	x.v.resize(mx+1),res.v.resize(mx+1),res.neg=x.neg,u<0?res.neg^=1,u=-u:1;
	for(register int i=0;i<=mx;i++)
	{
		res.v[i]=((li)x.v[i]*u+carry)%BASE,carry=((li)x.v[i]*u+carry)/BASE;
	}
	return x.reduce(),res.reduce();
}
inline BigInt operator *(BigInt x,BigInt y)
{
	if(x.isZero()||y.isZero())
	{
		return BigInt();
	}
	BigInt res;
	ll n=x.v.size(),m=y.v.size(),j,k;
	li cur=0,carry=0;
	res.neg=x.neg^y.neg,res.v.resize(n+m);
	for(register int i=0;i<n+m;i++)
	{
		for(i<m?(j=0,k=i):(j=i-m+1,k=m-1);j<n&&k>=0;j++,k--)
		{
			cur+=(li)x.v[j]*y.v[k],carry+=cur/BASE,cur%=BASE;
		}
		res.v[i]=cur,cur=carry%BASE,carry/=BASE;
	}
	return res.reduce();
}
inline BigInt operator /(BigInt x,ll u)
{
	BigInt res;
	li cur=0;
	res.neg=x.neg,u<0?res.neg^=1,u=-u:1,res.v.resize(x.v.size()+1);
	for(register int i=x.v.size()-1;i>=0;i--)
	{
		cur=cur*BASE+x.v[i],cur-=(li)(res.v[i]=cur/u)*u;
	}
	return res.reduce();
}
inline li operator %(BigInt x,ll u)
{
	li cur=0;
	for(register int i=x.v.size()-1;i>=0;i--)
	{
		cur=cur*BASE+x.v[i],cur-=(li)(cur/u)*u;
	}
	return cur;
}
inline BigInt qpow(BigInt base,ll exponent)
{
	BigInt res=1;
	while(exponent)
	{
		if(exponent&1)
		{
			res=res*base;
		}
		base=base*base,exponent>>=1;
	}
	return res;
}
int main()
{
	n=read(),m=read(),f=g=1;
	for(register int i=n+1;i<=n+m-1;i++)
	{
		c=i;
		for(register int j=2;j<=sqrt(c);j++)
		{
			while(c%j==0)
			{
				fd[j]++,fn[j]++,c/=j;
			}
		}
		c!=1?fd[c]++,fn[c]++:1;
	}
	for(register int i=1;i<=m-1;i++)
	{
		c=i;
		for(register int j=2;j<=sqrt(c);j++)
		{
			while(c%j==0)
			{
				fn[j]--,c/=j;
			}
		}
		c!=1?fn[c]--:1;
	}
	for(register int i=1;i<=501;i++)
	{
		f=f*qpow(i,fn[i]),fn[i]=0;
	}
	f=f-1,fd[m-1]++;
	for(register int i=2;i<=501;i++)
	{
		while(f%i==0)
		{
			fn[i]++,f=f/i;
		}
	}
	for(register int i=1;i<=501;i++)
	{
		if(fd[i]>fn[i])
		{
			g=g*qpow(i,fd[i]-fn[i]);
		}
		if(fn[i]>fd[i])
		{
			f=f*qpow(i,fn[i]-fd[i]);
		}
	}
	f.op(),puts(""),g.op();
}
```

---

## 作者：Warriors_Cat (赞：1)

## 题解 P1625【求和】

首先，先来一波数学推导公式：

$$\sum_{i=1}^{n}\frac{1}{\prod_{j=i}^{i+m-1}j}$$

$$=\sum_{i=1}^{n}\frac{m-1}{(m-1)(\prod_{j=i}^{i+m-1}j)}$$

$$=\sum_{i=1}^{n}\frac{1}{m-1}\left(\frac{i+m-1}{\prod_{j=i}^{i+m-1}j}-\frac{i}{\prod_{j=i}^{i+m-1}j}\right)$$

$$=\sum_{i=1}^{n}\frac{1}{m-1}\left(\frac{1}{\prod_{j=i}^{i+m-2}j}-\frac{1}{\prod_{j=i+1}^{i+m-1}j}\right)$$

$$=\frac{1}{m-1}\left(\frac{1}{\prod_{i=1}^{m-1}}-\frac{1}{\prod_{i=n+1}^{n+m-1}}\right)$$

$$=\frac{\prod_{i=n+1}^{n+m-1}-\prod_{i=1}^{m-1}}{(m-1)(\prod_{i=1}^{m-1})(\prod_{i=n+1}^{n+m-1})}$$

推到这发现好像不能再推了，所以就直接计算了。

那，最后的约分怎么处理呢？

我们可以看到，分母是一大堆单精度数的乘积，那我们就可以将每一个分母的单精度数枚举，然后看能不能整除分子，如果能就一直除下去，如果不能就转到下一个单精度数，这样我们就搞定约分啦（撒花）

难道这道题就这么简单吗？

然而，一看数据范围，$n+m\le500$？！

~~谁出的题啊QAQ~~

所以，我们就要打高精啦-v-

这里需要以下三个高精度操作：

* 高精减高精

* 高精乘单精

* 高精除单精

废话不多说了，具体代码看下面（含注释）：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n, m;
int x[100010], y[100010], z[100010], w[100010], a, b;
void mul(int *a, int b){//高精乘单精 
	for(int i = 1; i <= a[0]; ++i) a[i] *= b;
	int x = 0;
	for(int i = 1; i <= a[0]; ++i){
		a[i] += x;
		x = a[i] / 10;
		a[i] %= 10;
	}
	while(x){
		a[++a[0]] = x % 10;
		x /= 10;
	}
	while(a[a[0]] == 0 && a[0] > 0) a[0]--;
	return;
}
void jian(int *a, int *b, int *c){//高精减高精
    //c为差 
	c[0] = a[0];
	for(int i = 1; i <= c[0]; ++i){
		if(a[i] < b[i]){
			a[i] += 10;
			a[i + 1]--;
		}
		c[i] = a[i] - b[i];
	}
	while(c[c[0]] == 0 && c[0] > 0) c[0]--;
	return;
}
void print(int *a){//输出答案 
	if(a[0] == 0) printf("0");
	else for(int i = a[0]; i >= 1; --i) printf("%d", a[i]);
	printf("\n");
}
void chu(int *a, int b, int *c, int &d){//高精除单精。注意！这里的余数要引用，要不然余数是不会变的 
	d = 0;
	memset(c, 0, sizeof(c));
	for(int i = a[0]; i >= 1; --i){
		d = (d << 3) + (d << 1) + a[i];
		c[++c[0]] = d / b;
		d %= b;
	}
	for(int i = 1; i <= c[0] / 2; ++i) swap(c[i], c[c[0] - i + 1]);
	while(c[c[0]] == 0 && c[0] > 0) c[0]--;
	return;
}
int main(){
	scanf("%d%d", &n, &m);
	x[0] = y[0] = x[1] = y[1] = z[0] = w[0] = z[1] = w[1] = 1;
	mul(y, m - 1);//处理分母1 
	for(int i = 1; i <= (m - 1); ++i) mul(y, i), mul(w, i);//处理分母2+处理分子1 
	for(int i = (n + 1); i <= (n + m - 1); ++i) mul(y, i), mul(z, i);//处理分母3+处理分子2 
	jian(z, w, x);//处理分子3 
	//从这里开始处理约分 
	for(int i = 2; i <= (m - 1); ++i){
		chu(x, i, z, a);//先除一下 
		while(a == 0){
			memcpy(x, z, sizeof(x));//被除数转成商 
			chu(y, i, w, b);
			memcpy(y, w, sizeof(y));//分母也要处理 
			chu(x, i, z, a);//再除一下康一康 
		}
	}
	for(int i = (n + 1); i <= (n + m - 1); ++i){
		chu(x, i, z, a);
		while(a == 0){
			memcpy(x, z, sizeof(x));
			chu(y, i, w, b);
			memcpy(y, w, sizeof(y));
			chu(x, i, z, a);
		}
	}//同上 
	print(x);//输出分子 
	print(y);//输出分母 
	return 0;//完结撒花-v- 
}
```
这道题说实话也不算太难，主要是卡高精和推导公式，仔细想想就基本做出来了。

那么，就拜拜咯~~

## End

---

## 作者：liuyifan (赞：1)

### 转自我们竞赛老师x**y **的题解

#### 1.【出题意图】 
考察选手的数学解题能力，及对高精度加法、减法、高精度×单精度、高精度÷单精度的掌握。

通过本题要学会：高精度求余和高精度约分
#### 2.【思路点拨】
![](https://s2.ax1x.com/2019/07/09/ZyTx61.png)
#### 3.【Code】（蒟蒻优化过的版本）
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define reg register
#define ll long long
#define wei 10000
using namespace std;
int f[1000005],a[1000005]={1,1},b[1000005]={1,1},n,m;
bool r[1000005];
inline void out(reg int a[])
{ 
	cout<<a[a[0]];
	for(reg int i=a[0]-1;i>=1;i--)cout<<a[i]/1000<<a[i]/100%10<<a[i]/10%10<<a[i]%10;
	cout<<endl;
}
inline void cd(reg int a[],reg int x)
{ 
	for(reg int i=1;i<=a[0];i++)a[i]=a[i]*x;
	for(reg int i=1;i<=a[0];i++){a[i+1]+=a[i]/wei;a[i]%=wei;}
	while(a[a[0]+1]>0)
	{
		a[0]++;
		a[a[0]+1]=a[a[0]]/wei;
		a[a[0]]%=wei;
	}
}
inline void cg(reg int a[],reg int b[],reg int c[])
{ 
	memset(c,0,sizeof c);
	c[0]=a[0]+b[0];
	for(reg int i=1;i<=a[0];i++)
	for(reg int j=1;j<=b[0];j++)
	{ 
		c[i+j-1]+=a[i]*b[j];
		c[i+j]+=c[i+j-1]/wei;
		c[i+j-1]%=wei;
	}
	while(c[0]>0&&c[c[0]]==0)c[0]--;
}
inline void jian(reg int a[],reg int b[])
{ 
	for(reg int i=1;i<=a[0];i++)
	{ 
		if(a[i]<b[i])
		{
			a[i+1]--;
			a[i]+=wei; 
		}
		a[i]=a[i]-b[i];
	}
	while(a[a[0]]==0&&a[0]>0)a[0]--;
}
inline void divide(reg int a[],reg int x)
{ 
	reg int k=0;
	for(reg int i=a[0];i>=1;i--)
	{
		k=k*wei+a[i];
		a[i]=k/x;
		k%=x;
	}
	while(a[a[0]]==0&&a[0]>0)a[0]--;
}
inline int mo(reg int a[],reg int x)
{ 
	reg int k=0,i;
	for(i=a[0];i>=1;i--){k=k*wei+a[i];k%=x;}
	return k;
}
inline void yuefen()
{ 
	reg int i=2;
	while(i<=m+n)
	{ 
		if(r[i]==0)
		{ 
			while(!mo(b,i)&&!mo(f,i))
			{
				divide(b,i);
				divide(f,i);
			}
			for(reg int j=i*i;j<=m+n;j+=i)r[j]=1;
		}
		i++;
	}
}
int main()
{ 
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(reg int i=2;i<=m-1;i++)cd(a,i);
	for(reg int i=n+1;i<=n+m-1;i++)cd(b,i);
	cg(a,b,f);
	cd(f,m-1);
	jian(b,a);
	yuefen();
	out(b);
	out(f);
	return 0;
}
```



---

## 作者：0x00AC3375 (赞：0)

## 1. 题意

为简明起见，我们用符号 $T(l, r)$ 表示 $l(l+1)(l+2)\cdots(r-2)(r-1)r$，题目要求我们求出表达式

$$S=\dfrac{1}{T(1,m-1)}+\dfrac{1}{T(2,m)}+\dfrac{1}{T(3,m+1)}+\cdots+\dfrac{1}{T(n,n+m-1)}$$

## 2. 分析
注意到 $T(l,r)$ 表示的是一系列连续正整数的乘积，容易知道对于任何的 $p$，有类似于阶乘的关系

$$T(l,r+1)=(r+1)\cdot T(l,r)$$
$$T(l+1,r+1)=\dfrac{r+1}{l}\cdot T(l,r)$$

因此我们可以知道对任何的 $l,r$，有如下的关系

$$\dfrac{1}{T(k,m+k-1)}=\dfrac{1}{T(k+1,m+k-2)}\cdot\dfrac{1}{m+k-1}=\dfrac{1}{m-1}\cdot[\dfrac{1}{T(k,m+k-2)}-\dfrac{1}{T(k+1,m+k-1)}]$$

由于上面的 $m-1$ 在输入了 $m$ 以后是一个常数，因此即可将其转化为裂项求和。所求的表达式为

$$S=\dfrac{1}{m-1}[\dfrac{1}{T(1,m-2)}-\dfrac{1}{T(2,m-3)}+\dfrac{1}{T(2,m-3)}-\dfrac{1}{T(3,m-4)}+\cdots+\dfrac{1}{T(n,n+m-2)}-\dfrac{1}{T(n+1,n+m-1)}]$$

前后相互抵消得到

$$S=\dfrac{1}{m-1}[\dfrac{1}{T(1,m-2)}-\dfrac{1}{T(n+1,n+m-1)}]$$

其中注意到

$$n\cdot T(n+1,n+m-1)=(n+m-1)!$$
$$T(1,m-2)\cdot T(m-1,n+m-1)=(n+m-1)!$$

因此将 $S$ 通分后就得到

$$S=\dfrac{T(m-1,n+m-1)-T(1,n)}{(n+m-1)!}\cdot\dfrac{1}{m-1}$$

按照上面的表达式定义好函数 $T$ 直接计算出 $S$ 的分子和分母部分即可。计算完毕后，利用辗转相除法求出最大公约数后进行约分化简即可。

## 3. 代码

### (1) Python

```python
n, m = input().split()
n, m = int(n), int(m)

def fact(x):
    if x == 0 or x == 1:
        return 1
    else:
        return x * fact(x - 1)

def times(left: int, right: int):
    if left > right:
        left, right = right, left
    result = 1
    for i in range(left, right + 1):
        result *= i
    return result

def gcd(x, y):
    return y if x % y == 0 else gcd(y, x % y)

up = times(n + 1, n + m - 1) - times(1, m - 1)
down = (m - 1) * times(1, m - 1) * times(n + 1, n + m - 1)
common = gcd(up, down)

up //= common
down //= common

print(up)
print(down)

```

### (2) C#

```csharp
using System;
using System.Numerics;
using static System.Numerics.BigInteger;

namespace P1625
{
    class P1625
    {
        public static BigInteger ContinuousProduct(int left, int right)
        {
            BigInteger result = 1;
            if (left > right) (left, right) = (right, left);
            for (int i = left; i <= right; i++) result *= i;
            return result;
        }

        public static BigInteger Gcd(BigInteger x, BigInteger y)
        {
            return x % y == 0 ? y : Gcd(y, x % y);
        }

        public static BigInteger Factorial(int x)
        {
            if (x == 0 || x == 1) return 1;
            else return x * Factorial(x - 1);
        }

        public static void Main(string[] args)
        {
            string[] numbers = Console.ReadLine().Split();
            int n = Convert.ToInt32(numbers[0]), m = Convert.ToInt32(numbers[1]);
            BigInteger up = ContinuousProduct(n + 1, n + m - 1) - ContinuousProduct(1, m - 1);
            BigInteger down = (m - 1) * ContinuousProduct(1, m - 1) * ContinuousProduct(n + 1, n + m - 1);
            BigInteger common = Gcd(up, down);
            up /= common;
            down /= common;
            Console.WriteLine(up);
            Console.WriteLine(down);
        }
    }
}
```

---

## 作者：Ag2WO4 (赞：0)

Pythoner 的思路：暴算的复杂度 $O(mn)$ 配上非常水的数据，辅以 Python 的自带高精，杀死比赛，请（无慈悲）

先通分到 $n+m-1$ 的阶乘，再根据通分用到的因数求出每个分数的分子，相加后再对分母约分即可。考察对 Python 自带数学库的应用。
```python
import math
n,m=map(int,input().split())
p=math.factorial(n+m-1)#通分阶乘
q=sum(p//math.perm(i+m-1,m)for i in range(1,n+1))#除掉分母就是分子
print(q//math.gcd(p,q))#约分
print(p//math.gcd(p,q))#同上
```

---

## 作者：__ZTY__ (赞：0)

在我决定写题解前就觉得这将是对我 LaTeX 能力的一次极大考验。

手玩样例，发现这不就是裂项吗。

$$\begin{aligned}

&\sum _{i=1} ^2 \frac{1}{ \Pi _{j=i} ^{i+1} j}=\frac{1}{1 \times 2}+\frac{1}{2 \times 3}=1-\frac{1}{2}+\frac{1}{2}-\frac{1}{3}=\frac{2}{3}\\

\end{aligned}$$

以为这题秒了，却发现只是针对 $m=2$ 的特殊情况。

这时有了第二个想法，并告诉教练可以推式子，应教练要求上讲台推。

发现分母上的 $\Pi$ 看着就不舒服，实际上就是连着 $m$ 个数相乘。

$$\begin{aligned}

&\sum _{i=1} ^n \frac{1}{ \Pi _{j=i} ^{i+m-1} j}=\frac{1}{m!}+\frac{1}{\frac{(m+1)!}{1!}}+\frac{1}{\frac{(m+2)!}{2!}}+...+\frac{1}{\frac{(m+n-1)!}{(n-1)!}}\\

&=\frac{1}{m!}+\frac{1!}{(m+1)!}+\frac{2!}{(m+2)!}+...+\frac{(n-1)!}{(m+n-1)!}\\

&=\sum_{i=0}^{n-1} \frac{i!}{(m+i)!}\\

&=\frac{0! \times \frac{(m+n-1)!}{m!} + 1! \times \frac{(m+n-1)!}{(m+1)!}+...(n-1)! \times \frac{(m+n-1)!}{(m+n-1)!}}{(m+n-1)!}\\

&=\frac{\sum_{i=0}^{n-1}i! \times \frac{(m+n-1)!}{(m+i)!}}{(m+n-1)!}\\

\end{aligned}$$

结果就发现不可做了，貌似以我的能力只能停留在暴力算式子了。

继续考虑最开始裂项的想法，居然异常的简单。

当 $m=3$ 时。

$$\begin{aligned}

&\frac{1}{n \times (n+1) \times (n+2)}\\

&=\frac{1}{2} \times \frac{(n+2)-n}{n \times (n+1) \times (n+2)}\\

&=\frac{1}{2} \times (\frac{1}{n \times (n+1)}-\frac{1}{(n+1) \times (n+2)})\\

\end{aligned}$$

看起来就豁然开朗了。

答案就是 $\frac{1}{m-1} \times ( \frac{1}{\Pi _{i=1}^{m-2} i }-\frac{1}{\Pi _{i=n+1}^{m+n-1} i })$。

非常好式子，但要高精度，调了半小时，最后决定用 python。

```python
def gcd(x,y):
    if y==0:return x
    else:return gcd(y,x%y)
n,m=map(int,input().split())
P,Q=0,1
for i in range (1,n+1,1):
    now=1
    for j in range(i,i+m,1):now*=j
    P,Q=P*now+Q,now*Q
g=gcd(P,Q)
print(P//g)
print(Q//g)
```


---

## 作者：Siegerkranz_2735 (赞：0)

#### 前置知识

差分运算：

$$\Delta f(x)=f(x+1)-f(x)$$

定和式：

$$\Sigma_{a}^{b}f(x)\delta x=\sum_{k=a}^{b-1}f(k)$$

$$\Sigma_{a}^{b}\Delta f(x)\delta x=f(b)-f(a)$$

下降幂：

$$x^{\underline{n}}=\begin{cases}
  x(x-1)(x-2)\dots(x-n+1) & (x >0) \\
  1 & (x=0) \\
  \frac{1}{(x+1)(x+2)\dots(x-n)} & (x <0)
\end{cases}$$

$$x^{\underline{n}}=\Delta (\frac{x^{\underline{n+1}}}{n+1})$$

#### 正文

$$\begin{aligned}

\sum_{i=1}^n (\prod_{j=i}^{i+m-1}j)^{-1}&=\sum_{x=1}^{n}(i-1)^{\underline{-m}}\\

&=\sum_{i=0}^{n-1} i^{\underline{-m}}\\

&=\Sigma_{0}^{n}x^{\underline{-m}}\delta x\\

&=\Sigma_{0}^{n}\Delta (\frac{x^{\underline{-m+1}}}{-m+1})\delta x\\

&=\frac{n^{\underline{-m+1}}-0^{\underline{-m+1}}}{-m+1}\\

&=\frac{\frac{1}{(n+1)(n+2)\dots(n+m-1)}-\frac{1}{1\times 2\times \dots \times(m-1)}}{-m+1}\\

&=\frac{\frac{1}{(m-1)!}-\frac{n!}{(n+m-1)!}}{m-1}\\

&=\frac{(n+m-1)^{\underline{n}}-n!}{(m-1)(n+m-1)!}

\end{aligned}$$

然后就不能化简了,看这个数据范围就是要用高精度了，这里给一种较快的高精度数找最大公约数的想法：

```cpp
bignumber gcd(bignumber a, bignumber b) {
  // 记录a和b的公因数2出现次数
  int atimes = 0, btimes = 0;
  while (a % 2 ==0) {  a = a >> 1;  atimes++;  }
  while (b % 2 ==0) {  b = b >> 1;  btimes++;  }
  for (;;) {    // a和b公因数中的2已经计算过了，后面不可能出现a,b均为偶数的情况
    while (a%2 == 0) a = a>> 1;
    while (b%2 == 0) b =b >> 1;    
    if (a == b) break;
    if (a < b) swap(a, b);  
    a =a - b;
  }
  return a << min(atimes, btimes);
}
```

总代码就不放了。

---


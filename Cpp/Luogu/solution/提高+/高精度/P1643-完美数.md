# 完美数

## 题目描述

考古队员小星在一次考察中意外跌入深渊，穿越到了一个神秘的荒漠。这里有许多超越他认识的事物存在，例如许多漂浮在空中的建筑，例如各种奇怪的动物。

在这片荒漠的中央，小星发现了一个巨大的类似神庙的建筑，为了脱离这片空间，小星决定前去探索。

在临近神庙大门时，突然跳出了一个人面狮（不是斯芬达克斯）！它咆哮着：

“我是这里的守卫，要想通过这里，必须回答出我的一系列问题，否则，我就吃了你。”

人面狮告诉小星，问题总是这样的模式：比 $X$ 大的第 $N$ 小的回文数是多少。

小星想，这个问题看来不难，于是问答开始了。

“比 $1$ 大的第 $1$ 小回文数数是多少？”

“$2$”

“比 $17$ 大的第 $2$ 小的回文数是多少？”

“$33$”

“比 $98$ 大的第 $2$ 小的回文数是多少？”

“$101$”

“那比 948237 大的第 2339587 小的回文数是多少？”

“\*（•%（\*•—#•#￥\*—%（\*—%”

为了避免被守卫吃掉，小星只好打开笔记本想借助电脑，却意外地发现可以通过网络（网通？电信？宇宙通？）找到你，于是这个问题就拜托给你了！


## 说明/提示

**【数据规模】**

$20 \%$ 的数据满足 $X \le 200000$，$N \le 1000$。

$30 \%$ 的数据满足 $X, N$ 在 `longint` 范围之内，且答案也在 `longint` 范围之内。

$100 \%$ 的数据满足 $X, N \le {10}^{10000}$，答案 $\le {10}^{20001}$。$T \le 10$。

## 样例 #1

### 输入

```
3
1
1
17
2
98
2
```

### 输出

```
2
33
101
```

# 题解

## 作者：Cure_Wing (赞：3)

[P1643 完美数](https://www.luogu.com.cn/problem/P1643)

### 思路

~~一道折磨人的高精度......~~

可以想象的是，对于一个回文数，我们只需要看前 $\lceil\dfrac{k}{2}\rceil$ 位的状态就可以了，因为左右对称。

那么一种暴力的思路就是对着前 $\lceil\dfrac{k}{2}\rceil$ 位的状态暴力分奇偶回文加数，直到加到 $N$ 次为止。当然可以根据长度为 $k$ 的回文串个数优化一下，但是只能拿到 [$80$ 分的高分](https://www.luogu.com.cn/record/142405042)。

[这种做法](https://www.luogu.com.cn/paste/y8mhh7cx)时间复杂度看起来不是很大，只需要加大约 $N$ 次。但是由于计算到后面数的位数特别多，也就导致了在高精上时间耗费过多而超时。

这个时候我们想，既然已经知道了这个数距离 $X$ 有 $N$ 个回文数，那么能不能求出 $1$ 到 $X$ 有多少个回文数呢？这样的话就可以知道 $1$ 到 $N$ 的回文数个数了。

有什么用呢？考虑我们知道 $Y$ 是第 $a$ 个回文数，我们可以先求出 $Y$ 的位数。因为长度为 $l$ 的回文串一共有 $9\times10^{\lceil\frac{l}{2}\rceil-1}$ 个（首位不为 $0$ 有 $9$ 种，其余位有 $10$ 个数可填），我们可以依次减去 $9\times10^{\lceil\frac{i}{2}\rceil-1}$，如果遇到不能减的数为 $9\times10^{\lceil\frac{k}{2}\rceil-1}$，此时剩下的数为 $p$，说明 $Y$ 是长度为 $k$ 的回文串中第 $p$ 小的数。然后我们只需要对 $p$ 加上 $10^{\lceil\frac{k}{2}\rceil-1}$ 的基础数（保证长度为 $k$），再减去 $1$ 的次序（长度为 $k$ 的串可以从 $10^{\lceil\frac{k}{2}\rceil-1}$ 开始），就得到了答案。

现在的问题就变成了求 $X$ 前面（包括 $X$）一共有多少个回文串。考虑把刚才的过程反过来，如果这个回文串的长度为 $k$，那么它前面一定存在长度为 $1\sim(k-1)$ 的回文串，可以先把它们的个数加起来。对于长度为 $k$ 的回文串，设这个数的前 $\lceil\dfrac{k}{2}\rceil$ 位组成的数为 $w$，那么还剩下 $(w-10^{\lceil\frac{k}{2}\rceil-1}+1)$ 个数可以选择，而这之中以 $(10^{\lceil\frac{k}{2}\rceil-1}\sim w-1)$ 作为前缀（$k$ 分奇偶）都可以作为前缀，此时只需要考虑 $w$ 作为前缀的情况。此时分类讨论一下，如果 $w$ 组成的串大于 $X$ 则不能作为答案，反之可以。

看似到这里就做完了，但是依旧存在和第一个做法一样的问题：由于计算的数过大，直接相加或相乘会浪费大量的时间，于是我们可以直接存储计算结果：比如要算 $\sum\limits_{i=1}^k9\times10^{\lceil\frac{i}{2}\rceil-1}$ 的值，可以手玩发现当 $k$ 为偶数时答案形如 $1999\dots9998$（长度为 $k$）的形式，如果说是奇数的话再补上 $i=k$ 的答案即可。

结果就是跑得飞快，平均不超过 10ms。

最后不要忘记判断一下回文串长度的奇偶性就可以了。

时间复杂度约为 $O(\sum(|X|+|N|))$，其中 $|X|,|N|$ 分别表示数 $X,N$ 的位数。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using std::cin;using std::cout;
constexpr int N=20005;
int t;
struct Bigint{//高精度模板部分
    int a[N],len=0;
    inline Bigint(int x=0){
        len=0;memset(a,0,sizeof(a));
        for(int i=x;i;i/=10) a[++len]=i%10;
    }
    inline void scan(){
        std::string s;cin>>s;len=s.size();memset(a,0,sizeof(a));
        for(int i=0;i<len;++i) a[len-i]=s[i]-'0';
    }
    inline int& operator[](int i){return a[i];}
    inline void flatten(int L){
        len=L;
        for(int i=1;i<=len;++i){a[i+1]+=a[i]/10;a[i]%=10;}
        for(;!a[len]&&len>1;--len);
    }
    inline void print(std::string s=""){for(int i=len;i;--i) cout<<a[i];cout<<s;}
    inline void reflectl(){for(int i=1;i<=len/2;++i) a[i]=a[len-i+1];}//翻转数的前半部分，用于还原前缀
    inline Bigint substr(int l,int r){//提取数的部分，用于提取前缀
        Bigint c;c.len=r-l+1;
        for(int i=1;i<=c.len;++i) c[i]=a[l+i-1];
        return c;
    }
}x,n,ans,now1,now2,zero(0);
inline bool operator<(Bigint a,Bigint b){
    if(a.len!=b.len) return a.len<b.len;
    for(int i=a.len;i;--i)
        if(a[i]!=b[i])
            return a[i]<b[i];
    return 0;
}
inline Bigint operator+(Bigint a,Bigint b){
    Bigint c;int len=std::max(a.len,b.len)+1;
    for(int i=1;i<=len;++i) c[i]=a[i]+b[i];
    c.flatten(len);
    return c;
}
inline Bigint operator-(Bigint a,Bigint b){
    Bigint c;
    for(int i=1;i<=a.len;++i){
        if(a[i]<b[i]){a[i]+=10;--a[i+1];}
        c[i]=a[i]-b[i];
    }
    c.flatten(a.len);
    return c;
}
inline Bigint operator*(Bigint a,int b){
    Bigint c;
    for(int i=1;i<=a.len;++i) c[i]=a[i]*b;
    c.flatten(a.len+11);
    return c;
}
inline Bigint operator<<(Bigint a,int b){
    Bigint c;
    for(int i=1;i<=a.len;++i) c[i+b]=a[i];
    c.flatten(a.len+b);
    return c;
}//左移数，用于还原前缀
inline Bigint rank(Bigint k){//计算前面有多少回文数
    Bigint ans(0),tot;
    int q=(k.len-1)/2;//直接计算答案
    if(q==0){ans.len=1;ans[1]=0;}
    else{
        ans.len=q+1;
        ans[1]=8;ans[q+1]=1;
        for(int i=2;i<=q;++i) ans[i]=9;
    }
    if(k.len%2==0){
        if(q){ans[ans.len]=0;ans[++ans.len]=1;}
        else ans[1]=9;
    }
    tot.len=q+1;tot[q+1]=1;
    ans=ans+k.substr(k.len-(k.len+1)/2+1,k.len);
    ans=ans-tot+Bigint(1);//ans 计算应有回文个数
    Bigint w=k;w.reflectl();
    if(k<w) ans=ans-Bigint(1);//判断 w 是否可行
    return ans;
}
inline Bigint get(Bigint x){//计算排名对应的回文数
    Bigint ans(0),tot(0),nxt(0);int b=1;//初始长度为 1，是奇前缀
    int q=x.len,cnt=0;
    tot.len=ans.len=std::max(q-1,1);//直接计算所得数
    if(q-1>1){ans[q-1]=1;ans[1]=8;for(int i=2;i<q-1;++i) ans[i]=9;}
    if(q-1>0){tot[q-1]=9;}
    if(ans+tot<x){ans=ans+tot;++cnt;b^=1;}
    if(ans+tot<x){ans=ans+tot;++cnt;b^=1;}//根据加和次数判断此时前缀的奇偶性
    q+=cnt/2-1;
    tot[tot.len]=0;tot[tot.len=q]=1;
    Bigint sum=x-ans;sum=sum+tot-Bigint(1);//根据上面的式子计算
    if(b&1) sum=(sum<<(sum.len-1));//将前缀还原，分奇偶性讨论
    else sum=(sum<<sum.len);
    sum.reflectl();
    return sum;
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
    for(cin>>t;t--;){
        x.scan();n.scan();
        get(n+rank(x)).print("\n");//当前排名 = 前面的回文数 + 中间的回文数
    }
    return 0;
}
```

---

## 作者：tXX_F (赞：3)

# 完美数
## [传送门](https://www.luogu.com.cn/problem/P1643)
## 前言
居然只有一篇题解，还是 py3 的那么就由本人写一篇 c++ 题解吧
## 解题思路

### 暴力思路

1. 首先需要找到比 $X$ 大的第 $N$ 小的回文数，可以从 $X+1$ 开始逐个判断是否是回文数，直到找到第 $N$ 个回文数为止。
2. 判断一个数是否是回文数可以将其转化为字符串，然后判断字符串是否是回文字符串。
3. 找到第N个回文数后输出即可。

####  伪代码：

1. 读入 $T$ 
2. 循环 $T$ 次：
   1. 读入 $X$ 和 $N$ 
   2. 初始化 $count$ 为0， $ans$ 为 $0$ 
   3. 从 $X+1$ 开始逐个判断是否是回文数，直到 $count$ 等于 $N$ 为止：
      1. 将当前数转化为字符串
      2. 判断该字符串是否是回文字符串：
         1. 初始化 $i$ 为 $0$ ， $j$ 为字符串长度 $-1$ 
         2. 循环 $i$ 小于 $j$ ：
            1. 如果字符串第 $i$ 个字符不等于第 $j$ 个字符，则不是回文字符串跳出循环
            2. 否则， $i$ 加 $1$ ， $j$ 减 $1$ 
         3. 如果 $i$ 大于等于 $j$ ，表示是回文字符串，将 $count$ 加 $1$ 
      3. 如果 $count$ 等于 $N$ ，表示找到了第 $N$ 个回文数，将 $ans$ 赋值为当前数
   4. 输出 $ans$ 

#### Code1

```cpp
#include <iostream>
#include <string>
using namespace std;

bool isPalindrome(string num) {
	int i = 0, j = num.length() - 1;
	while (i < j) {
		if (num[i] != num[j]) {
			return false;
		}
		i++;
		j--;
	}
	return true;
}

int main() {
	int T;
	cin >> T;
	
	for (int t = 0; t < T; t++) {
		int X, N;
		cin >> X >> N;
		
		int count = 0;
		int ans = 0;
		for (int num = X + 1; count < N; num++) {
			string numStr = to_string(num);
			if (isPalindrome(numStr)) {
				count++;
				ans = num;
			}
		}
		
		cout << ans << endl;
	}
	
	return 0;
}
```

### 暴力优化

要降低时间复杂度，可以采用以下方法：

* 判断一个数是否是回文数，可以不用将其转化为字符串，而是直接在数字上进行操作。
* 可以利用回文数的对称性质来判断是否是回文数，即从两端往中间进行比较。
* 找到第 $N$ 个回文数后，不需要继续判断后面的数，可以直接跳出循环。

#### Code2

```cpp
#include <iostream>
using namespace std;

bool isPalindrome(int num) {
	int reversedNum = 0;
	int temp = num;
	while (temp > 0) {
		int digit = temp % 10;
		reversedNum = reversedNum * 10 + digit;
		temp /= 10;
	}
	return num == reversedNum;
}

int main() {
	int T;
	cin >> T;
	
	for (int t = 0; t < T; t++) {
		int X, N;
		cin >> X >> N;
		
		int count = 0;
		int ans = 0;
		for (int num = X + 1; count < N; num++) {
			if (isPalindrome(num)) {
				count++;
				ans = num;
			}
		}
		
		cout << ans << endl;
	}
	
	return 0;
}
```

### 继续优化

要进一步降低时间复杂度，可以采用以下方法：

* 判断一个数是否是回文数的操作可以进一步优化。可以只判断一半的数字，而不需要全部反转，然后与另一半进行比较。
* 可以通过找到下一个回文数的规律来快速找到第 $N$ 个回文数。

优化后的代码如下：

#### Code3

```cpp
#include <iostream>
using namespace std;

bool isPalindrome(int num) {
    if (num < 0 || (num % 10 == 0 && num != 0)) {
        return false;
    }
    
    int reversedNum = 0;
    while (num > reversedNum) {
        reversedNum = reversedNum * 10 + num % 10;
        num /= 10;
    }
    
    return num == reversedNum || num == reversedNum / 10;
}

int getNextPalindrome(int num) {
    num++;
    while (!isPalindrome(num)) {
        num++;
    }
    return num;
}

int main() {
    int T;
    cin >> T;
    
    for (int t = 0; t < T; t++) {
        int X, N;
        cin >> X >> N;
        
        int ans = getNextPalindrome(X);
        for (int i = 1; i < N; i++) {
            ans = getNextPalindrome(ans);
        }
        
        cout << ans << endl;
    }
    
    return 0;
}
```

这样，我们通过优化判断回文数的方式以及找到下一个回文数的规律，可以更快地找到第 $N$ 个回文数，进一步降低时间复杂度。

### 加上高精度算法优化
要使用高精度算法优化，可以采用以下方法：

* 定义一个高精度整数类，可以实现大整数的加法、减法和乘法等操作。
* 在每次计算回文数时，将当前数字转化为高精度整数，进行高精度的加法操作，直到找到第 $N$ 个回文数。

#### Code4 （ TLE 20 ）
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> add(vector<int>& a, vector<int>& b) {
	vector<int> res;
	int carry = 0;
	int n = max(a.size(), b.size());
	for (int i = 0; i < n; i++) {
		int sum = carry;
		if (i < a.size()) {
			sum += a[i];
		}
		if (i < b.size()) {
			sum += b[i];
		}
		res.push_back(sum % 10);
		carry = sum / 10;
	}
	if (carry) {
		res.push_back(carry);
	}
	return res;
}

bool isPalindrome(vector<int>& num) {
	int n = num.size();
	for (int i = 0; i < n / 2; i++) {
		if (num[i] != num[n - 1 - i]) {
			return false;
		}
	}
	return true;
}

vector<int> getNextPalindrome(vector<int>& num) {
	int carry = 1;
	int n = num.size();
	for (int i = 0; i < n; i++) {
		num[i] += carry;
		carry = num[i] / 10;
		num[i] %= 10;
	}
	if (carry) {
		num.push_back(carry);
	}
	return num;
}

int main() {
	int T;
	cin >> T;
	
	for (int t = 0; t < T; t++) {
		vector<int> X;
		string str;
		cin >> str;
		for (int i = str.size() - 1; i >= 0; i--) {
			X.push_back(str[i] - '0');
		}
		
		int N;
		cin >> N;
		
		vector<int> ans = X;
		for (int i = 0; i < N; i++) {
			ans = getNextPalindrome(ans);
			while (!isPalindrome(ans)) {
				ans = getNextPalindrome(ans);
			}
		}
		
		for (int i = ans.size() - 1; i >= 0; i--) {
			cout << ans[i];
		}
		cout << endl;
	}
	
	return 0;
}
```

### 优化++
要进一步优化该程序，我们可以通过以下方式来提高效率：

* 不需要每次都判断当前数是否是回文数，只需要在最后输出时判断即可。
* 在计算下一个回文数时，可以直接从当前数一半开始倒序复制，这样可以减少循环次数。

#### Code5 （ RE 30 ）（加上高精度就 AC 了）

```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

#define int long long

vector<int> temp(1, 0);

inline void initialize() {
	for (int i = 0; i < 20000; i++) {
		temp.push_back(-1);
	}
}

inline int sum(int x) {
	if (temp[x] != -1) {
		return temp[x];
	}
	if (x % 2 == 0) {
		temp[x] = (pow(10, x / 2) - 1) / 9 * 2;
	}
	if (x % 2 == 1) {
		temp[x] = sum(x + 1) - pow(10, x / 2);
	}
	return temp[x];
}

inline pair<int, int> Cnt(int x) {
	x = (x + 8) / 9;
	int i = to_string(x).length() - 9;
	if (i < 1) {
		i = 1;
	}
	while (1) {
		if (sum(i) >= x) {
			return make_pair(i, 9 * sum(i - 1));
		}
		i++;
	}
}

inline int Mksum(int x) {
	pair<int, int> result = Cnt(x);
	int cnt = result.first;
	int sum = result.second;
	int half = pow(10, (cnt + 1) / 2 - 1) + (x - sum - 1);
	if (cnt % 2 == 1) {
		string halfStr = to_string(half);
		return stoi(halfStr.substr(0, halfStr.length() - 1) + string(halfStr.rbegin(), halfStr.rend()));
	} else {
		string halfStr = to_string(half);
		return stoi(halfStr + string(halfStr.rbegin(), halfStr.rend()));
	}
}

inline int rev(int x) {
	int len = to_string(x).length();
	int Sum = sum(len - 1) * 9;
	Sum += stoi(to_string(x).substr(0, (len + 1) / 2)) - pow(10, len / 2 + len % 2 - 1);
	while (Mksum(Sum) <= x) {
		Sum++;
	}
	return Sum - 1;
}

inline void solve() {
	int N, X;
	cin >> N >> X;
	int Answer = Mksum(X + rev(N));
	cout << Answer << endl;
}

inline void work() {
	initialize();
	int T;
	cin >> T;
	while (T--) {
		solve();
	}
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	work();
	return 0;
}
```

### AC Code

```cpp
// Code5 加上高精度
```

我之所以不给代码是为了你们养成勤于动手的好习惯

---


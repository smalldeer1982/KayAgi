# 关灯

## 题目描述

在某条道路上，有 $n$ 盏灯排成一排，它们有的是开着的，有的是关着的。

由于天马上就要亮了，上级给了你一个任务：把所有的灯都关掉。

只不过，这些灯都比较智能，不会被轻易关掉。它们的开或关遵循如下规则：

- 每一步只能开或关一盏灯。
- 编号为 $1$ 的灯可以随意开或关。
- 如果编号为 $1, 2, \cdots,k-1$ 的灯都关上了了，并且编号为 $k$ 的灯在开着，我们可以随意开或关第 $k+1$ 盏灯。

在关灯之前，请你计算：至少要多少步才能关上所有灯？

## 说明/提示

【输出解释】

- 初始状态 $1010$；
- 第 $1$ 步 $1110$；
- 第 $2$ 步 $0110$；
- 第 $3$ 步 $0100$；
- 第 $4$ 步 $1100$；
- 第 $5$ 步 $1000$；
- 第 $6$ 步 $0000$。

### 数据范围及约定

- 对于 $40\%$ 的数据，$n \le 30$；
- 对于 $70\%$ 的数据，$n \le 300$；
- 对于 $100\%$ 的数据，$n \le 1000$。

## 样例 #1

### 输入

```
4
1 0 1 0```

### 输出

```
6```

# 题解

## 作者：litc (赞：16)

题目大意：

给定一个01串，要求在一定变换规则的限制下，将其转换成全0串。

考虑如下两个串：

00……0（n个0）——————————（1）

00……01（n-1个0，一个1）—————（2）

设把（1）改成（2）的最小步数为c[n][0]，把（2）改成（1）的最小步数为c[n][1]，则

c[n][0]= c[n][1]=c[n-1][0]+ 1 +c[n-1][1]

方法：把前n-1个由（1）变（2），再改第n个，再由（2）变（1）。

易知c[1][0]=c[1][1]=1，故c[n][0]=c[n][1]=2^n-1

而长度为n的01串至多有2^n个，故串（1）和串（2）是距离最远的01串。

接着，我们设f[n]表示把串的第1位到第n位变为1的最小步数。

如果串的第n位是0，易知有f[n]=f[n-1]

如果串的第n位是1，则我们所需要进行的操作：

1、    把前n-1位变成（2），需要步数为c[n-1][0]-f[n-1]

2、    把第n位变成0，需要1步

3、    把前n-1位变成（1），需要步数为c[n-1][1]

综上，第n位是1时，f[n]=2^n-1-f[n-1]

根据此递推式进行递推即可，注意要加高精。


---

## 作者：tzl_Dedicatus545 (赞：7)

这道题是一道基础的递推题，容易推导出来：



 $$\begin{cases}a_i=0:f_i \gets f_{i-1}\\
 a_i \ne 0: f_i=2^i-1-f_{i-1}\end{cases}$$
 
 证明：

$f_i$ 表示前$i$盏路灯改成$0$的次数，如果$a_i$本来就是$0$,$f_i$就等于$f_{i-1}$，否则$f_i$就等于全是$1$是改成$0$的次数减去$1$，再减去前面的$f_{i-1}$

注意比较坑的一点是这题要用高精度，否则你会得到一个橙色的${\color{Orange}40}$。

代码：
```cpp
//By: Luogu@wangdemao(308854)
#include <iostream>

using namespace std;

int f[1000][10000],a[10000],g[10000][10000];

void a21(int a[],int b[])
{
	for(int i=1;i<=a[0];i++)
	{
		b[i]=a[i]*2;
	}
	b[1]++;
	for(int i=1;i<=a[0];i++)
	{
		b[i+1]+=b[i]/10;
		b[i]%=10;
	}
	if(b[a[0]+1]>0)
		b[0]=a[0]+1;
	else
		b[0]=a[0];
}

void gmf0(int g[],int f0[],int f[])
{
	for(int i=1;i<=g[0];i++)
	{
		f[i]=g[i]-f0[i];
	}
	
	for(int i=1;i<=g[0];i++)
	{
		if(f[i]<0)
		{
			f[i]+=10;
			f[i+1]--;
		}
	}
	int l=0;
	for(int i=g[0];i>=1;i--)
	{
		if(f[i]>0)
		{
				l=i;
				break;
		}
		
	}
	f[0]=l;
}

void fu(int f0[],int f[])
{
	for(int i=0;i<=f0[0];i++)
		f[i]=f0[i];
}

int main()
{
	int n;
	
	cin>>n;
	
	for(int i=1;i<=n;i++)
		cin>>a[i];
	
	g[1][0]=g[1][1]=1;
	
	for(int i=2;i<=n;i++)
		a21(g[i-1],g[i]);
	
	if(a[1] != 0)
		f[1][0]=f[1][1]=1;
	
	for(int i=2;i<=n;i++)
	{
		if(a[i]==0)
			fu(f[i-1],f[i]);
		else
			gmf0(g[i],f[i-1],f[i]);
	}
	
	for(int i=f[n][0];i>=1;i--)
		ocut<<f[n][i];
	
	return 0;
}

```
 
 

---

## 作者：redegg (赞：4)

转移方程很简单。

我们设四个值:

$e[i]$，分别表示在$[1,i-1]$区间全部为关灯时，改变$i$处状态（关到开，开到关）。

$dpe[i]$，把$[1,i]$全部关灯的最小步数。

$dpl[i]$，把$[1,i-1]$全部关灯，$[i,i]$开灯的最小步数。

$a[i]$表示$i$的初始状态。

转移如下

```cpp
        e[i]=e[i-1]+e[i-1]+1;
        if(a[i]==0)
        {
            dpl[i]=min((dpl[i-1]+1+e[i-1]),(dpe[i-1]+e[i-1]+1+e[i-1]));
            dpe[i]=min((dpl[i-1]+e[i-1]),dpe[i-1]);
        }
        if(a[i])
        {
            dpl[i]=min((dpl[i-1]+e[i-1]),(dpe[i-1]));
            dpe[i]=min((dpl[i-1]+1+e[i-1]),(dpe[i-1]+e[i-1]+1+e[i-1]));
        }
```
注意需要用到高精度，重载一下特别好写：

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[1005];

struct num
{
    int len=1;
    int x[1005]={0,};
};

num operator + (const num &aa ,const num &bb)
{
    num an;
    int maxn=max(aa.len,bb.len);
    an.len=maxn;
    int c=0;
    for(int i=1;i<=maxn;i++)
    {
        an.x[i] = aa.x[i]+bb.x[i]+c;
        if(an.x[i]>=10){
            c=1;
            an.x[i]-=10;
        }
        else c=0;
    }
    if(c)
        an.len++, an.x[an.len]=1;
    return an;
}
bool operator < (const num &aa ,const num &bb)
{
    if(aa.len!=bb.len)return aa.len<bb.len;
    for(int i=aa.len;i>=1;i--)
        if(aa.x[i]!=bb.x[i])return aa.x[i]<bb.x[i];
}
bool operator > (const num &aa ,const num &bb)
{
    if(aa.len!=bb.len)return aa.len>bb.len;
    for(int i=aa.len;i>=1;i--)
        if(aa.x[i]!=bb.x[i])return aa.x[i]>bb.x[i];
}

void print(num an)
{
    for(int i=an.len;i>=1;i--)
        printf("%d",an.x[i]);
}

num e[1005];
num l[1005];
num dpl[1005];
num dpe[1005];
num one;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    e[1].x[1]=l[1].x[1]=1;
    e[1].len=l[1].len=1;
    dpe[1].len=dpl[1].len=1;
    one.x[1]=1;
    one.len=1;
    if(a[1])dpe[1].x[1]=1;
    else dpl[1].x[1]=1;
    for(int i=2;i<=n;i++)
    {
        l[i]=l[i-1]+e[i-1]+one;
        e[i]=l[i-1]+e[i-1]+one;
        if(a[i]==0)
        {
            dpl[i]=min((dpl[i-1]+one+e[i-1]),(dpe[i-1]+l[i-1]+one+e[i-1]));
            dpe[i]=min((dpl[i-1]+e[i-1]),dpe[i-1]);
        }
        if(a[i])
        {
            dpl[i]=min((dpl[i-1]+e[i-1]),(dpe[i-1]));
            dpe[i]=min((dpl[i-1]+one+e[i-1]),(dpe[i-1]+l[i-1]+one+e[i-1]));
        }
    }
    print(dpe[n]);
    return 0;
}

```


---

## 作者：洛绫璃 (赞：4)

咱们倒着来，使所有灯都关闭到目标状态，从n->1开灯\
根据贪心，关灯肯定倒着关，假如：1 0 0 0 ，你把第1盏开了，再要去开第4盏，必定还要在把第1盏关闭成0 0 1 0，因为求最少步骤，所以从n->1倒着开灯。\
看状态，要开第i盏\
0 0 .....0 0 1\
必须要达到\
0 0 .....0 1 0\
要开第i-1盏,就要达到\
0 0 .....1 0 0\
设cnt[i]表示达到 0 0 .... 0 1（第i盏）的状态的最小步数\
不论开还是关闭第i盏，都要使得1--（i-2）关闭，(i-1)打开，才能对第i盏操作，则
根据地推 cnt[i]=cnt[i-1]*2+1 \
（从0 0 ...0 0到0 0 ....1 0步骤+cnt[i-1]，然后 0 0 ...1 1步骤+1，在关掉第i-1盏步骤+cnt[i-1]）\
在开i盏有中间状态
0 0 ... 0 1 1，此时若第i-1盏也要开，刚好可以省去步骤达到贪心，
若i-1不开，则也要达到中间态 0 0 ...1 1 1，然后关闭i-1，此时i-2是亮着的，我们要不断记录中间状态，实际上开i灯，到0 0 ... 0 1 1，实际步骤为cnt[i-1]+1,即到达0 0 ... 0 1 0步骤+cnt[i-1]，开i灯步骤+1，再循环时记录下一盏灯状态，在开i时下一盏灯已经打开，若i-1灯要关闭，则在关i-1时i-2打开，若i-1灯目标状态要打开，则continue，不需要增加任何步骤，并记录下一盏灯为关闭状态（初始状态全关闭）\
然后高精！高精！我找了n消失错误，发现精度不够
```c
#include<bits/stdc++.h>
using namespace std;
int n, a,deng[1005];
string cnt[1005],ans,c;
string add_s(string a,string b) {
	if (a.size() < b.size())swap(a, b);
	int i = a.size(), j = b.size() - 1;
	a = '0' + a;
	for (; j>=0; --j,--i) {
		a[i] += (b[j] + a[i + 1] / 10);
		a[i + 1] %= 10;
	}
	for (; i&&a[i + 1] >= 10; --i)a[i] += a[i + 1] / 10, a[i + 1] %= 10;
	if (a[1] >= 10)a[0] = a[1] / 10, a[1] %= 10;
	else a.erase(0, 1);
	return a;
}
void add_string(int k){
	cnt[k] = "0" + cnt[k - 1];
	cnt[k][cnt[k].size() - 1] <<= 1;
	++cnt[k][cnt[k].size() - 1];
	for (int i = cnt[k].size() - 2; i; --i) {
		cnt[k][i] <<= 1;
		cnt[k][i] += cnt[k][i + 1] / 10;
		cnt[k][i + 1] %= 10;
	}
	if (cnt[k][1] >= 10)cnt[k][0] = cnt[k][1] / 10, cnt[k][1] %= 10;
	else cnt[k].erase(0, 1);
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> deng[i];
	cnt[1] = "1"; cnt[1][0] -= '0';c = cnt[1];
	for (int i = 2; i <= n; ++i) add_string(i);
	for (int i = n; i; --i) 
		if (deng[i]||a==1){
			if (a == 1 && deng[i]){ a = 0; continue; }
			ans = add_s(ans, add_s(cnt[i - 1], c)), a = 1;
		}
	for (int i = 0; i < ans.size(); ++i) printf("%c", ans[i] + '0');
}
```




---

## 作者：Misophiliac (赞：2)

提供一种较简单的实现，代码短，常数小（目前[最优解](https://www.luogu.com.cn/record/list?pid=P1805&orderBy=1&status=&page=1)）

本题核心思想是递推，设关上所有前 $i$ 盏路灯需要 $f_i$ 步，则 $f_i$ 满足的递推式如下：

$$
f_i = \begin{cases}
   f_{i-1} &\text{if } O_i=0 \\
   2^i-1-f_{i-1} &\text{if } O_i=1
\end{cases}
$$

特别地，$f_0=0$。

对此的证明已经被其他 dalao 们讲得很清楚了，请参看。

然后是本题解的特色：**实现**。

其他题解都使用了~~令人眼花缭乱的~~高精度，本题解则尝试简化（并未避免）。

注意递推式的第二行，$2^i-1$ 是一个长为 $i$ 的全 $1$ 串，减去 $f_{i-1}$ 则相当于 $f_{i-1}$ 取反，前面再添上若干个 $1$。添加完后 $f_i$ 长度为 $i$，所以 $f_{i-1}$ 长度为 $i-1$，于是只需在前添加一个 $1$。

为简单起见，我只用了一个数组表示当前 $i$ 对应的 $f_i$（是一个二进制高精度数），然后在上面操作。若 $O_i=0$ 则不进行操作。

下面放上代码段。

```c
int f[1005] = { 0 };
for (int i = 0; i < n; i++) {
    int O;
    scanf("%d", &O);
    if (O) {
        for (int j = 0; j < i; j++) f[j] = !f[j];//按位取反
        f[i] = 1;
    }
}
```

现在我们已经求出了答案，不过是二进制的。我们需要将它转成十进制，对应代码如下：
```c
int a[1005] = { 0 };//存十进制
int l = 1;//位数
for (int i = n - 1; ~i; i--) {
    int c = 0;
    for (int j = 0; j < l; j++) {//乘2
        a[j] = a[j] * 2 + c;
        c = 0;
        if (a[j] >= 10) {//进位
            c = 1;
            a[j] -= 10;
        }
    }
    if (c) a[l++] = c;
    if (f[i]) a[0]++;//如果该二进制位是1则十进制的末位加上1
}
```
最后输出即可。

完整代码：

```c
#include <stdio.h>
int main() {
    int n;
    scanf("%d", &n);
    int f[1005] = { 0 };
    for (int i = 0; i < n; i++) {
        int O;
        scanf("%d", &O);
        if (O) {
            for (int j = 0; j < i; j++) f[j] = !f[j];
            f[i] = 1;
        }
    }
    int a[605] = { 0 };
    int l = 1;
    for (int i = n - 1; ~i; i--) {
        int c = 0;
        for (int j = 0; j < l; j++) {
            a[j] = a[j] * 2 + c;
            c = 0;
            if (a[j] >= 10) {
                c = 1;
                a[j] -= 10;
            }
        }
        if (c) a[l++] = c;
        if (f[i]) a[0]++;
    }
    for (int i = l; i; i--) putchar(a[i-1] ^ '0');
    return 0;
}
```

---

## 作者：qiyichen12 (赞：1)

# 题意简述
有数列 $a$ 可以有以下操作：
1. $a_1 = 1 \oplus a_1$ 即取反。
2. 当 $\sum_{i=0}^{k-1}a_i = 0$ 且 $a_k = 1$ 时 $a_{k+1} = 1 \oplus a_{k+1}$。

求至少几次使 $\sum a_i = 0$。
# 分析
首先分析 $\sum a_i = 1$ 时的次数。设 $a_{k+1} = 1$ 反推以前。

$\because a_k = 1$

$\therefore$ 上一步 $a_{k-1} = 1$

又 $\because \sum_{i=0}^{k-1}a_i = 0$

$\therefore $ 上上步 $a_{k-1} = 1$

$\vdots$

$\therefore2^n-1$ 步前~一切祥和~为初始状态。

~不严格地~得证 $\sum a_i = 1$ 时 $2^n-1$ 步解开。

再考虑 $\sum a_i \not= 1$ 的情况。可以两两分组，因为在取反 $a_i$ 时，$a_{\max\{j|j < i,a_j = 1\}}$ 必定也要被取反。

故省下 $2^{\max\{j|j < i,a_j = 1\}}-1$ 步。

所以，设 $ip_i$ 表示从大到小第 $i$ 个下标使得 $a_{ip_i} = 1$。
则答案为 $\sum_{i = 1}{(2^{a_{ip_i}}+1)\times(-1)^{i+1}}$。

由于数据范围是 $1\leqslant n\leqslant1000$，所以~开高精~用 python。

# AC Code

```python
n = int(input())
r = input().split()
s = 0
cnt = 0
for i in range(n):
    j = n-i-1
    if r[j]  == '1':
        if cnt % 2 == 0:
            s += (2**(j+1)-1)
            cnt += 1
        else:
            s -= (2**(j+1)-1)
            cnt += 1
print(s)
```

---

## 作者：紊莫 (赞：1)

这题困惑了我很久，所以写个题解。

首先，注意到这是一个递推的题，首先先考虑怎么把当前位置变掉，那么就需要把前面的数字变成 $00\dots01$ 的形式。

记 $f_n$ 表示前 $n$ 位变成全 $0$ 的操作次数，当前为 $0$ 时不再赘述。

当前为 $1$ 时怎么做呢？

首先要变成上述格式，然后改变当前位，就转化为了改变前 $n-1$ 位的做法，这里涉及到一张重要的图片。

![](https://cdn.luogu.com.cn/upload/image_hosting/r0ghp084.png)

简单模拟就能发现，由全 $0$ 到 $00\dots01$ 的形式一定是最长的变化路径，$f_n$ 的变化一定蕴含其中！

记 $g_n$ 为最长的变化路径长度（全 $0$ 到 $00\dots01$ 的形式所需步数）。

问题转化为求 $g$，考虑如下状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/hhzjzbfo.png)

得到 $g_n=2g_{n-1}+1$，又已知 $g_1=1$，所以可以得到通项公式 $g_n=2^n-1$。

综上所述，得：

第一种情况不用操作 $f_i=f_{i-1}$。

第二种情况 $f_i=g_{i-1}-f_{i-1}+1+g_{i-1}=g_i-1+1-f_{i-1}=g_i-f_{i-1}$。

写到这里加上高精度即可。

[示例代码。](https://www.luogu.com.cn/paste/cs008zbv)


---

## 作者：kczw (赞：0)

# 题意简述
给定一个由 $0,1$ 组成的长为 $n$ 的序列 $a$，可按以下规则对其操作：
- $a_1$ 可修改为 $1$ 或 $0$。
- $a_i(1<i\le n)$ 当 $a_{i-1}$ 为 $1$ 并且 $a_j(j<i-1)$ 为 $0$ 时可修改为 $1$ 或 $0$。

问最少多少次可以将 $a$ 中元素全部修改为 $0$。
# 思路
根据题目中第二条规则，如果我们要修改序列 `0 0 0 0 0 1`，首先需要得到 `0 0 0 0 1`，然后递推下去最后从 `1` 开始往回递推，递推过程如下。
- `1` 需要 $1$ 次操作
- `0 1` 需要 $1\times2+1=3$ 次操作
- `0 0 1` 需要 $3\times2+1=7$ 次操作
- `0 0 0 1` 需要 $7\times2+1=15$ 次操作
- `0 0 0 0 1` 需要 $15\times2+1=31$ 次操作
- `0 0 0 0 0 1` 需要 $31\times2+1=63$ 次操作

不难看出想要得到第 $i(2\le i\le 6)$ 种状态，必须先得到 $i-1$ 种状态（须 $x$ 次操作）然后才能修改第 $i$ 位（须 $1$ 次操作），然后需要再将第 $i-1$ 种状态修改回去（须 $x$ 次操作），其修改次数变成为了类 $x\times2+1$ 的形式。

其实从这里已经可以看出端倪了，仔细思考后不难发现修改第 $i$ 位须 $2^i-1$ 次操作。

但此时并未得出完整思路，因为并非所有样例都只有一个 $1$，若修改第 $i$ 位时左侧并非全为 $0$，那么势必会对最终答案造成影响。

这里我们令 $f_i(1\le i\le n)$ 为将 $a_j(1\le j\le i)$ 全部修改为 $0$ 的最小操作次数。

若第 $i$ 位为 $0$ 则其不需修改，即 $f_i=f_{i-1}$。

当第 $i$ 位为 $1$ 时，$f_i=2^i-1-f_{i-1}$。这个结论感觉很多题解都一语指出并证明了，~~但其实我并未看懂~~，所以这里来讲讲我的见解。

上文中我们令 $f_i(1\le i\le n)$ 为将 $a_j(1\le j\le i)$ 全部修改为 $0$ 的最小操作次数。这里不妨将 $f_i$ 看作将全为 $0$ 的序列修改为同序列 $a$ 前 $i$ 位一样所需的最小操作次数。

须知道在将第 $i$ 位改为 $1$ 的过程中有一部分是将第 $i-1$ 位改为 $1$ 并将第 $i-1$ 之前的元素全改为 $0$。我们不妨将其看作用一个 $1$ 从第 $1$ 位推出第 $2$ 位的 $1$，然后将第一位 $1$ 清除后用第 $2$ 位的 $1$ 推出第 $3$ 位的 $1$……

所以修改第 $i$ 位时，若第 $i$ 位之前有 $1$，可以看作是在看作在推 $1$ 的过程中产生的 $1$，那么这些本需要从全 $0$ 序列推导来的与序列 $a$ 前 $i-1$ 位相同的 $0,1$ 序列所用操作次数 $f_{i-1}$ 其实可以减去。

于是将把前 $i-2$ 位元素全部修改为 $0$ 并将第 $i-1$ 位元素修改位 $1$ 的操作数 $2^{i-1}-1-f_{i-1}$，加上修改第 $i$ 位的操作数 $1$，再加上修改第 $i-1$ 位的 $1$ 需要的操作数 $2^{i-1}-1$ 最后得到 $f_i=2^{i-1}-1-f_{i-1}+1+2^{i-1}-1=2^i-1-f_{i-1}$。

所以从 $1$ 开始往 $n$ 递推最后加上一点点高精度推导出 $f_n$ 即为答案。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int n,a[N];
string f[N];
string operator+(string a,string b){
	while(a.size()>b.size())b="0"+b;
	while(a.size()<b.size())a="0"+a;
	int k=0;
	for(int i=a.size()-1,sum;i>=0;i--){
		sum=a[i]+b[i]-'0'-'0'+k;
		k=0;
		if(sum>9)sum-=10,k=1;
		a[i]=sum+'0';
	}
	return k?"1"+a:a;
}//重载加法
string operator-(string a,string b){
	while(a.size()>b.size())b="0"+b;
	for(int i=a.size()-1,dif;i>=0;i--){
		dif=a[i]-b[i];
		if(dif<0),dif+=10;a[i-1]--; 
		a[i]=dif+'0'; 
	}
	int i;
	for(i=0;i<a.size()&&a[i]=='0';i++);
	return a.substr(i,a.size()-i);
}//重载减法
string operator*(string a,string b){
	string ans;
	for(int i=a.size()-1,mul;i>=0;i--)
	for(int j=b.size()-1;j>=0;j--){
		mul=(a[i]-'0')*(b[j]-'0');
		string res;
		if(mul>9){
			res=(char)(mul/10+'0');
			res=res+(char)(mul%10+'0');
		}
		else res=(char)(mul+'0');
		for(int l=1;l<=a.size()-1+b.size()-1-i-j;l++)res=res+"0";
		ans=ans+res;
	} 
	return ans;
}//重载乘法
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	f[0]="0";
	string pow="2",one="1";
	for(int i=1;i<=n;i++){
		f[i]=(a[i]?pow-one-f[i-1]:f[i-1]);
		pow=pow+pow;
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：scp020 (赞：0)

# P1805 关灯 题解

很明显的递推题，但是高精度。

## 解法

相信大家都对九连环的游戏有所了解。如果不拆除前面的环，那后面的环也就不能拆除。有依赖关系。

考虑设置状态。

题中要求所有灯全部熄灭所用的步数，所以这里设置状态 $f$，$f_i$ 表示前 $i$ 盏灯全部熄灭所用的最少步数。由于第 $i$ 盏灯可以被操作的前提是前 $i-1$ 盏灯满足一定条件，所以只能从左到右顺序操作。现在考虑如何转移。

如果第 $i$ 盏灯本来就是灭的。那这个位置不用操作，$f_i = f_{i-1}$。

如果第 $i$ 盏灯本来是亮的，那这个位置需要操作。此时已经处理了前 $i-1$ 盏灯的情况。这里分两种情况讨论。

为了辅助这个过程，我们再设一个状态 $g$，$g_i$ 表示在前 $i$ 盏灯全部熄灭的情况下点亮第 $i$ 盏灯所用的最少步数，这里等价于前 $i-1$ 盏灯全部熄灭、第 $i$ 盏灯点亮的情况下使前 $i$ 盏灯全部熄灭所用的最少步数。题中说编号为 $1$ 的灯可以随意开或关，所以 $g_1 = 1$。考虑 $g_2$。$g_2$ 即为开 $1$，开 $2$，关 $1$ 的最少步数，即为 $g_1 \times 2 + 1$。考虑 $g_i$，即为开 $i-1$，开 $i$，关 $i-1$ 的最少步数，即为 $g_i-1 \times 2 + 1$。利用数学归纳法：

$$\begin{aligned} &g_1 = 1 = 2^1 - 1 \\ &g_2 = g_1 \times 2 + 1 = (2^1 - 1) \times 2 + 1 = 2^1 + 1 = 2^2 -1 \\ &g_3 = g_2 \times 2 + 1 = (2^2 -1) \times 2 +1 = 2^3 - 2 + 1 = 2^3 - 1 \\ &g_i = g_{i-1} \times 2 + 1 = (2^{i-1} - 1) \times 2 + 1 = 2^i - 2 + 1 =2^i - 1\end{aligned}$$

得出结论：$g_i = 2^i - 1$。

- 如果第 $i-1$ 盏灯本来是亮的。则 $f_i = g_{i-1} - f_{i-1} + 1 + g_{i-1} = g_i - f_{i-1}$。
- 如果第 $i-1$ 盏灯本来是熄灭的的。则 $f_i = g_{i-1} - f_{i-2} + 1 + g_{i-1} = g_{i-1} - f_{i-2} + 1 + g{i-1} = g_i - f_{i-2} = g_{i} - f_{i-1}$。

综上，$f_i = \begin{cases}f_{i-1}&a_i = 0\\g_i - f_{i-1}&a_i = 1\end{cases}$。

高精度略。

## 代码

```cpp
#include<bits/stdc++.h>
template <typename T>
inline void swap(T &x,T &y)
{
	T tmp=x;
	x=y,y=tmp;
}
class high_accuracy
{
private:
	int len,a[5000];
public:
	inline int &operator[](const int &x)
	{
		return a[x];
	}
	inline int size()
	{
		return len;
	}
	inline high_accuracy()
	{
		len=0,a[0]=a[1]=a[2]=0;
	}
	inline void init(__int128 x)
	{
		len=0;
		if(x==0) len=1,a[1]=0;
		while(x) a[++len]=x%10,x/=10;
	}
	inline void deal(int l)
	{
		for(int i=1;i<=l;i++)
		{
			while(a[i]<0) a[i+1]--,a[i]+=10;
			a[i+1]+=a[i]/10,a[i]%=10;
		}
		len=l;
		while(!a[len]) len--;
	}
	inline void print()
	{
		for(int i=std::max(len,1);i;i--) std::cout<<a[i];
		std::cout<<"\n";
	}
	inline high_accuracy operator+(high_accuracy rhs)
	{
		high_accuracy ret;
		int le=std::max(len,rhs.size());
		for(int i=1;i<=le+3;i++) ret[i]=0;
		for(int i=1;i<=le;i++) ret[i]+=a[i]+rhs[i];
		ret.deal(le+2);
		return ret;
	}
	inline high_accuracy operator-(high_accuracy rhs) // 适用于 *this 比 rhs 大的情况
	{
		high_accuracy ret;
		int le=std::max(len,rhs.size());
		for(int i=1;i<=le+3;i++) ret[i]=0;
		for(int i=1;i<=le;i++) ret[i]+=a[i]-rhs[i];
		ret.deal(le+2);
		return ret;
	}
	inline high_accuracy operator*(high_accuracy rhs)
	{
		high_accuracy ret;
		for(int i=1;i<=len+rhs.size()+5;i++) ret[i]=0;
		for(int i=1;i<=len;i++) for(int j=1;j<=rhs.size();j++) ret[i+j-1]+=a[i]*rhs[j];
		ret.deal(len+rhs.size()+5);
		return ret;
	}
};
high_accuracy f[1010],pw[1010];
int n,a[1010];
int main()
{
	std::cin>>n,pw[0].init(1),pw[1].init(2),f[0].init(0);
	for(int i=1;i<=n;i++) std::cin>>a[i];
	for(int i=2;i<=n;i++) pw[i]=pw[i-1]*pw[1];
	if(a[1]) f[1].init(1);
	for(int i=2;i<=n;i++)
		if(a[i]) f[i]=pw[i]-pw[0]-f[i-1];
		else f[i]=f[i-1];
	f[n].print();
	return 0;
}
```


---

## 作者：Φρανκ (赞：0)

题意：给定一个长度为 $n$ 的序列和两种操作，求将序列所有项变为 $0$ 的最小操作次数。两种操作是：
- 改变 $a_1$
- 在 $a_1\sim a_{i-1}$ 为 $0$ ， $a_i$ 为 $1$ 时改变 $a_{i+1}$ 

核心思想：递推

解：

令 $f(n)$ 为改变 $n-1$ 个 $0$ 后的一个状态的最小操作数（如 $f(4)=0000\leftrightarrow 0001$ ）， $g(i)$ 为将给定序列的前 $i$ 项变为全 $0$ 的最小操作数。

易知 $f(1)=1$ 且 $\forall i>1,\:f(i)=2f(i-1)+1$ （先把第 $i-1$ 位变成 $1$ ，花一步把第 $i$ 位变成 $0$ ，再把第 $i-1$ 位变回 $0$ ），故 $f(i)=2^i-1$ 。

又可知有 $g(1)=a_1$ ，分类讨论递推方式：
1. 若 $a_i=0$ ，显然有 $g(i)=g(i-1)$ ；
2. 若 $a_i=a_{i-1}=1$ ，有 $g(i)=g(i-2)+1+f(i-1)=g(i-2)+2^{i-1}$ （先变成只有最后两位 $1$ ，再花费 $1+f(i-1)$ 步变成全 $0$ ）；
3. 若 $a_i=1$ 且 $a_{i-1}=0$ ，由于 $0\rightarrow 1$ 和 $1\rightarrow 0$ 在最后一位上是等价的，可以构造序列 $b_i$ 在且仅在 $i-1$ 项与 $a_i$ 相异。则也有 $g_a(i)=g_b(i-1)+1+f(i-1)=g_a(i-2)+2^{i-1}$ （因为 $b_{i-1}=0$ ， $g_b(i-1)=g_b(i-2)=g_a(i-2)$ ）。

对 $a_{i-2}$ 分类讨论可证对于所有序列，都有 $g_a(i-1)+g_b(i-1)=2^{i-1}-1$ ， $g_a(i)=2^{i-1}-1-g_a(i-2)+2^{i-1}=2^i-1-g_a(i-1)$ 。

用任一个递推式解均可。需要高精。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, s[1001], a[1001][1001], pw[1001], flag;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>s[i];
	if(s[1]==1)
		a[1][0]=1;//初始值
	pw[0]=1;
	for(int i=2; i<=n; i++)
	{
		for(int j=0; j<=1000; j++)
			pw[j]*=2;
		for(int j=0; j<=1000; j++)
		{
			pw[j+1]+=pw[j]/10;
			pw[j]%=10;
		}//计算2的幂
		if(s[i]==0)
			for(int j=0; j<=1000; j++)
				a[i][j]=a[i-1][j];//项为0
		else if(s[i-1]==1)
		{
			for(int j=0; j<=1000; j++)
				a[i][j]=a[i-2][j]+pw[j];
			for(int j=0; j<=1000; j++)
			{
				a[i][j+1]+=a[i][j]/10;
				a[i][j]%=10;
			}
		}//第一个递推式
		else
		{
			for(int j=0; j<=1000; j++)
				a[i][j]=pw[j]*2-a[i-1][j];
			a[i][0]--;
			for(int j=0; j<=1000; j++)
			{
				if(a[i][j]<0)
				{
					a[i][j+1]+=a[i][j]/10-1;
					a[i][j]=a[i][j]%10+10;
				}
				a[i][j+1]+=a[i][j]/10;
				a[i][j]%=10;
			}
		}//第二个递推式
	}
	for(int i=1000; i>=0; i--)
	{
		if(a[n][i]!=0)
			flag=1;
		if(flag==1)
			cout<<a[n][i];
	}//输出
	return 0;
}
```



---

## 作者：caohan (赞：0)

# 题意
对于一个零一序列，求在指定规则下，将序列改为全零的最小操作次数。
# 思路
定义：$a_i$ 为零一序列的第 $i$ 项，$f(i)$ 为前 $i$ 个数全部为零的最少操作次数。

通过观察原题“如果编号为1,…,k-1 的灯都关上了了，并且编号为k 的灯在开着，我们可以随意开或关第k+1 盏灯”的条件，可知这题明显要用递推，则可得递推式为：

 $f(i) = \begin{cases}
a_i=1   ,&   2^i-1-f(i-1)\\
a_i=0   ,&   f(i-1)   
\end{cases}$ 

因为在 $a_i$ 本身为零时，不需要变动。而为一时，用全是一的改动次数 $2^i$ 再减一，再减上一次的变动次数即可。
（注意，本题数据过大,应用高精度）

# 代码
```cpp
//write it by yourself 
```


---


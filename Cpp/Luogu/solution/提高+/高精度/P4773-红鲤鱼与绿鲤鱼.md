# 红鲤鱼与绿鲤鱼

## 题目背景

JerryC家里除了有驴之外，还有一个有着红鲤鱼和绿鲤鱼的鱼缸。

## 题目描述

在JerryC家里的鱼缸里，有一些红鲤鱼和绿鲤鱼(鱼缸里没有驴！)这天晚上23:05的时候，JerryC闲的无聊，于是打开了某神秘OJ开始爆肝。。作为一名膜法师，JerryC可以通过预言术得知下一次自己的提交是对是错。当然，预言术使用的工具就是眼前的鱼缸了。每当JerryC的预言术指示一只红鲤鱼的时候，就说明这次提交会WA，同时会增加5min的罚时；如果是绿鲤鱼就会AC。(当然，由于JerryC的膜法，JerryC是不会番薯田扛把子的。JerryC第一次提交会在第5min，而且不幸的是JerryC的膜法有5min的冷却时间)并且JerryC在每一次预言后就会把预言到的那一只鲤鱼取出来，以便比赛完毕后给鱼缸换水~~(给自己换换口味)~~现在JerryC告诉你他家里有多少条红鲤鱼和绿鲤鱼，请你告诉他他这场比赛的罚时期望是多少。当然，JerryC会按顺序做题，并且罚时只会记录AC的题目，算罚时的时候需要加上AC的时间，并且所有的鲤鱼用完后还会提交一次，而且这一次JerryC并不会预测并且必定AC。）
由于JerryC脾气比较犟，所以他不会因为WA掉一道题而换一道题去做，除非AC。

## 说明/提示

$$ 10 pts: 1 \leqslant A + B \leqslant 5 $$
$$ 30 pts: 1 \leqslant A + B \leqslant 20 $$
$$ 70 pts: 1 \leqslant A + B \leqslant 3000 $$
$$ 100 pts: 1 \leqslant A \leqslant 1e18, 1 \leqslant B \leqslant 1e7 $$

最后六个点时限2400ms！！！
其他点时限400ms！！！

$$ \color{white}{\text{温馨提示:注意模数}}$$

样例1: 
有两种可能： 
1. AC WA AC
2. WA AC AC
 
第一个情况的罚时是5(第5分钟AC)+5(WA一次罚时5分钟)+15(第15分钟AC)=25 

第二个情况的罚时是5(WA一次罚时5分钟)+10(第10分钟AC)+15(第15分钟AC)=30 

所以期望罚时为$ \frac{25+30}{2} = \frac{55}{2} $ 需要对分数取模，所以最后答案为499122454。



## 样例 #1

### 输入

```
1 1```

### 输出

```
499122454```

## 样例 #2

### 输入

```
1 2```

### 输出

```
45```

# 题解

## 作者：b2019dy (赞：10)

本题是个数学题，情况总数为重排列数，即$\dfrac{(a+b)!}{a!b!}$  
由题意可得，无论哪种情况，总会用完所有鲤鱼，则红鲤鱼的罚时必定会全部累加，最后也必定为1次AC，则罚时总值为$5\dfrac{(a+b)!}{a!b!}(2a+b+1)$  
我们来考虑前面的绿鲤鱼，我们可以知道，绿鲤鱼记录的时间之与它所处的位置有关，证明可得，绿鲤鱼在每一个位置上的次数是相同的。次数为$\dfrac{b}{a+b}\dfrac{(a+b)!}{a!b!}$次。  
则我们可以利用高斯公式求出等差数列，再加上之前算出的罚时，即可求出最终罚时总值。$5\dfrac{b}{a+b}\dfrac{(a+b)!}{a!b!}\dfrac{(1+a+b)(a+b)}{2}+5\dfrac{(a+b)!}{a!b!}(2a+b+1)$  
除以情况数，并约分得期望值为$5(\dfrac{(1+a+b)b}{2}+2a+b+1)$  
可得分母只有2这一种情况，预处理2的取模情况即可。

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
using namespace std;
long long ans,a,b;
const long long p=499122427;
int main()
{
    scanf("%lld%lld",&a,&b);
    ans=(5*((4*(a%998244853))%998244853+(2*(b%998244853))%998244853+2+(b%998244853)*(1+(a%998244853)+(b%998244853))))%998244853;
    if(ans%2==0)
    {
        printf("%lld",ans/2);
    }
    else printf("%lld",(ans*p)%998244853);
}
```

---

## 作者：Huami360 (赞：4)

提供一个思路。
设red表示红鲤鱼条数，green表示绿鲤鱼条数。
试想，如果只有绿鲤鱼，那么总时间是不是就是

5 + 10 + 15 + 20 + ... + 5 * (green + 1)

现在，我们把红鲤鱼插进来，在看看，假设将一条红鲤鱼插在第二条绿鲤鱼后面，那么总时间就是

5 + 10 + 5 + 20 + 25 + ... + 5 * (green + red + 1)

发现，红鲤鱼的出现只会让时间减少，而且只影响出现的位置。

于是，我们构建一个长度为(green + red + 1)的等差数列，差值为5。

5 + 10 + 15 +...+ 5 * (red + green + 1)

然后我们有red次机会在第1~(red+green)个数中选一个数变成5。

我们发现，第一个数变成5不会影响结果，第二个数变成5答案减少5，第三个数变成5答案减少10，以此类推。

第1~(red+green)个数每个数都有red/(red+green)的概率变成5，那么总共减少的值就是0+5+...+5*(red+green-1) * (red/(red+green)) 。

用一开始的等差数列减去这个值就行了。

如果是分数要用快速幂得到结果。

数据范围比较大，所以要高精。

参考代码(没用高精，所以只有70分)：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
#define ll long long
#define INF 2147483647
using namespace std;
inline ll read(){
    ll s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0',ch = getchar();
    return s * w;
}
const int MOD = 998244853;
ll a, b, c;
ll sum, sum2;
ll fast_pow(ll x, int k){
    ll ans = 1, tmp = x;
    while(k){
      if(k & 1) ans = ans * tmp % MOD;
      tmp = tmp * tmp % MOD;
      k >>= 1;
    }
    return ans;
}
ll getAns(ll A, ll B){
    return (ll)(A * fast_pow(B, MOD - 2) % MOD);
}
ll gcd(ll a, ll b){
    return !b ? a : gcd(b, a%b);
}
int main(){
    a = read(); b = read();
    sum = (a + b + 2) * 5 * (a + b + 1) / 2;
    sum2 = (a + b) * 5 * (a + b - 1) / 2;
    c = a + b;
    (sum *= c) -= sum2 * a;
    ll GCD = gcd(sum, c);
    sum /= GCD; c /= GCD;
    if(sum % c == 0) printf("%lld\n", sum / c);
    else printf("%lld\n", getAns(sum, c));
    return 0;
}

```

---

## 作者：yzx72424 (赞：3)

我们可以尝试只求出一个位置上的总和。

这就相当于我们把第一个位置上固定下来了，后面(m+n−1)(m+n−1)个位置上有(m−1)(m−1)。组合数算一下方案数就好了。

然后对于每一个位置上答案的贡献不一样，但是是一个等差数列。因为每一个位置上都会有Cm−1m+n−1Cm+n−1m−1个ACAC，所以可以求出每一个位置上单次贡献的和再乘上出现次数就好了。
so

ans=5∗(2∗a+b+1)+5∗C b−1 b+a−1∗(a+b+1)∗(a+b)/2/C b a+b

化简就可得到
ans=5∗(2∗a+b+1)+5∗b∗(a+b+1)

数据是比较大但用不到高精，开unsigned long long
每算一次都取模就行了
。。

 _参考比赛的讲解_ 


```
#include<bits/stdc++.h>
unsigned long long ans,m,n,mod=998244853,ss=499122427;
int main(){
    scanf("%lld%lld",&m,&n);
    ans=(5*((4*(m%mod))%mod+(2*(n%mod))%mod+(n%mod)*(1+(m+n)%mod))+10)%mod;
    ans%2==0?printf("%lld",ans/2):printf("%lld",(ans*ss)%mod);
}
```


---

## 作者：huboxiang (赞：1)

~~本蒟蒻人生中第一篇题解竟然是蓝题！~~

首先假设有 $x$ 条红鲤鱼，$y$ 条绿鲤鱼，显然红鲤鱼都用作罚时了，最后一次过了

运用中国咳血稽术小学二年级学过的排列组合知识可得
共有 $\frac{(x+y)!}{x!y!}$ 种情况.

又因绿鲤鱼在整个序列中是均匀出现的，分布的概率是 $\frac{y}{x+y}$,

所以运用Mr.Gauss小时候的伟大智慧(指等差数列求和)可得绿鲤鱼所用时间为
$$\frac{5y}{x+y}\cdot\frac{(x+y)!}{x!y!}\cdot\frac{(x+y)^2+(x+y)}{2}$$

总罚时
$$\frac{5(x+y)!}{x!y!}\cdot\left(\frac{y}{x+y}\cdot\frac{(x+y)^2+(x+y)}{2}+(2x+y+1)\right)$$

期望值就是除以总情况数：
$$5\left(\frac{x+y+1}{2}y+2x+y+1\right)$$

### Code:
```cpp
#include <bits/stdc++.h> 
using namespace std;
typedef long long ll;
const ll mod=998244853;
int main()
{
	ll ans,x,y;
    cin >> x >> y;
    ans=(5*((4*(x%mod))%mod+(2*(y%mod))%mod+2+(y%mod)*(1+(x%mod)+(y%mod))))%mod;
    if(!(ans%2))  cout << ans/2;
    else printf("%lld",(ans*(mod/2+1)%mod));
    return 0;
}
```

---

## 作者：tanzexiaodezhonghao (赞：0)

## 思路
本质是道数学题，~~有小学基础都可以做~~，由于分布是均匀的，所以每次 AC 的概率为 $\dfrac{b}{a+b}$。重排列后得出情况总数为 $\dfrac{(a+b)!}{a!b!}$，易得总罚时推算公式为：
$$5 \cdot (\dfrac{b}{a+b} \times \dfrac{(a+b)!}{a!b!}\times\dfrac{(1+a+b)\cdot(a+b)}{2}+\dfrac{(a+b)!}{a!b!}\cdot(2a+b+1))$$
除以总情况数后得：
$$5 \cdot (2a+b+1+\dfrac{b\cdot(1+a+b)}{2})$$
代码很好写，但要注意模数和平时不同，还有数据范围。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;const long long mod=998244853;
long long ans,a,b;
int main(){
    cin>>a>>b;
    ans=(5*((4*(a%mod))%mod+(2*(b%mod))%mod+2+(b%mod)*(1+(a%mod)+(b%mod))))%mod;
    if(ans%2==0) cout<<ans/2;
    else cout<<(ans*499122427)%mod;
}
```

---

## 作者：迟暮天复明 (赞：0)

显然的，总罚时数不会因为抓到红绿鲤鱼的顺序而发生改变。所以我们只需要考虑所有 AC 提交的总时间和即可。

整个过程可以理解为 $a+b$ 条鱼构成一个排列，每次取出第一条鱼的过程，所以每一次取到 AC 的概率都是 $\dfrac{b}{a+b}$。于是，所有 AC 的期望罚时就应该是 $5\times\dfrac{b}{a+b}+10\times\dfrac{b}{a+b}+\ldots+5\times(a+b)\times\dfrac{b}{a+b}$。这个东西可以直接等差数列求和做。别忘了最后一次提交。时间复杂度 $O(\log p)$。注意模数是 $998244\color{red}8\color{b}53$。

---


# [AHOI2005] 病毒检测

## 题目描述

科学家们在 Samuel 星球上的探险仍在继续。非常幸运的，在 Samuel 星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多 RNA 片段运回了实验基地。

科学家们经过几个昼夜的研究，发现这些 RNA 片段中有许多是未知的病毒！

每个 RNA 片段都是由 `A`、`C`、`T`、`G` 组成的序列。科学家们也总结出了 Samuel 星球上的“病毒模版片段”。一个模版片段是由 `A`、`C`、`T`、`G` 的序列加上通配符 `*` 和 `?` 来表示。其中 `*` 的意思是可以匹配上 $0$ 个或任意多个字符，而 `?` 的意思是匹配上任意一个字母。

如果一个 RNA 片段能够和“病毒模版片段”相匹配，那么这个 RNA 片段就是未知的病毒。

例如，假设 “病毒模版片段”为 `A*G?C`。RNA 片段：`AGTC`，`AGTGTC` 都是未知的病毒，而 RNA 片段 `AGTGC` 则不是病毒。

由于，机器人搜集的这些 RNA 片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些 RNA 片段不是病毒，并将不是病毒的 RNA 片段运回宇宙空间站继续进行研究。

科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些 RNA 片段不是病毒。

## 说明/提示

输入中的 RNA 片段 `AGTGC` 不是病毒。

对于所有数据，$0 < N < 500$。

特别的：

- 每个 RNA 片段的长度不超过 $500$；
- “病毒模版片段”和 RNA 片段的长度都至少为 $1$。

## 样例 #1

### 输入

```
A*G?C
3
AGTC
AGTGTC
AGTGC```

### 输出

```
1```

# 题解

## 作者：quest_2 (赞：44)

一道 $\mathtt{Trie}$ 树的进阶题。

用到了 $\mathtt{Trie}$ 树上跑 $dfs$ 的做法。 

~~现在看来应该还是简单的。~~

不过之前没做过这类题的话，思维跨度还是有点大的。

------------

## 题意稍加简述：

```
有一病毒串由AGCT四种字母和'?'，'*'两种特殊字符构成。

'?'可以替换成任意一种字母，'*'可以替换成任意一种以字母构成的串（可为空串）。

现在给出 N 个RNA串，求其中有多少RNA串是不能由病毒串转换而来的。
```

------------

## 思维稍加讲解:

先走一遍我们想到 $\mathtt{Trie}+dfs$ 为正解的心路历程。

第一眼。字符串**匹配**问题。

第二眼。**单对多**字符串匹配问题。必定要打 $\mathtt{Trie}$ 树。

第三眼。不是固定的病毒串，也就是有大量有可能的**变化形态**。但都跑不出相应的变化范式，就像打二维的走迷宫问题，只有四个可能移动的方向。极有可能用上**搜索**。

第四眼。关于 $bfs$ 和 $dfs$ 选择哪一个的问题。个人在这里选择了 $dfs$ 。原因是 $dfs$ 在搜索过程中有参数的不断改变，可以更好地**表示状态**，也更有可读性（个人见解）。

### 正解我们已经有了，现在我们来想运作流程：

1. 把所有的RNA串都插入 $\mathtt{Trie}$ 中，因为只有RNA串是**明确已知的**，我们制定策略为：**让病毒串去尽力匹配RNA串**。

1. 在病毒串上跑 $dfs$ ， 从左往右扫一遍每个字符。扫到的这个字符，决定了我们在 $\mathtt{Trie}$ 树上要怎么**向下走**（类比字典树的查询）。也就是说， $dfs$ 要传两个参数，一个 $stp$ 代表**在病毒串上扫到的位置**，一个 $now$ 代表**在 $\mathtt{Trie}$ 上走到的位置**。

#### 具体上说，他是如何决定走法的？

- 对于一个字母（$\mathtt{AGCT}$）字符，他往哪边走显然是固定的，他**必须往这个字母的方向**走，（就是普通的 $\mathtt{Trie}$ 树的常规查询操作）。同时，这个病毒串上的字母也已被处理掉，开始**扫下一个字符**， $stp+1$ ， $\mathtt{Trie}$ 上位置变成当前 $now$ 的**一个儿子** 。

- 对于一个问号（$\mathtt{?}$）字符，他可以替代任何一个字母字符，也就是 ($\mathtt{AGCT}$）四种情况都有。我们向**四个方向都可以走**。这个字母同样也被处理掉，开始扫病毒串上的下一个字符， $stp+1$ ， $\mathtt{Trie}$ 上位置变成当前 $now$ 的**每个儿子** 。

- 对于一个星号（$\mathtt{* }$）字符，情况开始有点复杂。他可以替代任何一个串，这个串可能是**空**的。那我们可以分类讨论，将其分为 **“星号代表空串”** 和 **“星号不代表空串”** 两种情况。

     - 情况一：他代表空串。相当于我们在字典树上**不用往下面走一步**，什么也不用做，直接扫到病毒串的下一位字符， $stp+1$ ，$\mathtt{Trie}$ 上位置**不变**。
     
     - 情况二：他代表并不代表空串。这时一个 $* $ 就可以看做是 **一个 $?$ 加上一个 $ * $** 。问号以问号的做法做即可，再扫病毒串上的下一个字符， $stp+1$ 。剩下的那个星号也必然不会无限递归下去，因为病毒串迟早是会扫完的，这时若还没有满足答案，就可以直接 return 了。
     
以上便是搜索部分的大致流程。

但这并没有结束。

------

## 代码稍加优化：

搜索的时间复杂度总是让人不放心，究其原因，是我们搜索了太多相同的状态。

还好，我们可以**记忆化**，这就是 $dfs$ 又一项优势：对于状态的记忆化极为方便。

定义一个名为 $vis$ 的bitset，两个维度，一个维度存 $stp$ ，一个维度存 $now$ 。搜索时，倘若这种状态出现过，这次就不搜了。

-----
## 实现稍加注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 1007;
bitset<1007> vis[500007];
//记忆化需要的bitset，为了省空间

struct Trie//Trie树结构体封装式写法
//我喜欢这个，因为用起来就和STL一样
{
     int ch[500007][5], sz = 0, val[500007];
     //val指以这个位置为结尾的单词数量
     
     void clear()//初始化
     {
          memset(ch, 0, sizeof(ch));
          sz = 0;
     }
     
     int idx(char c)//获取每个字符对应的数码
     //总不能把char当成数组下标吧，map神仙当我没说
     {
          if (c == 'A')
          {
               return 1;
          }
          if (c == 'G')
          {
               return 2;
          }
          if (c == 'T')
          {
               return 3;
          }
          if (c == 'C')
          {
               return 4;
          }
          if (c == '?')
          {
               return 5;
          }
          if (c == '*')
          {
               return 6;
          }
     }
     
     void insert(char s[])//插入基操
     {
          int u = 0, len = strlen(s + 1);
          for (int i = 1; i <= len; i++)
          {
               int x = idx(s[i]);
               if (ch[u][x] == 0)
               {
                    ch[u][x] = ++sz;
               }
               u = ch[u][x];
          }
          val[u]++;
     }
} Tree;

char vir[1007];//病毒串
int N, L;//分别为RNA串的数量，病毒串的长度
int ans = 0;//可以和病毒串匹配的RNA串数量

void dfs(int stp, int now) //模式串的第stp位，在trie树上的位置为now
{
     if (stp == L + 1)//病毒串搜到底了
     {
          ans += Tree.val[now];//更新答案
          Tree.val[now] = 0;//修改val值，避免多加
          return;
     }
     if (vis[now][stp])//记忆化
     {
          return;
     }
     
     int x = Tree.idx(vir[stp]);
     vis[now][stp] = 1;
     
     if (x >= 1 && x <= 4)//若stp位置上是字母
     {
          if (Tree.ch[now][x])
               dfs(stp + 1, Tree.ch[now][x]);
     }
     
     if (x == 5)//若是'?'
     {
          for (int i = 1; i <= 4; i++)
          //向四个方向都可以走
          {
               if (Tree.ch[now][i])
                    dfs(stp + 1, Tree.ch[now][i]);
          }
     }
     
     if (x == 6)//若是*
     {
          dfs(stp + 1, now);//第一种情况：空串
          for (int i = 1; i <= 4; i++)
          //第二种情况：'*'='?'+'*'
          {
               if (Tree.ch[now][i])
               {
                    dfs(stp + 1, Tree.ch[now][i]);
                    //处理'?'
                    dfs(stp, Tree.ch[now][i]);
                    //处理'*'
               }
          }
     }
}
int main()
{
     cin >> vir + 1;
     L = strlen(vir + 1);

     cin >> N;
     Tree.clear();
     
     for (int i = 1; i <= N; i++)
     {
          char RNA[1007];
          cin >> RNA + 1;
          Tree.insert(RNA);
     }
     dfs(1, 0);
     cout << N - ans << endl;//ans是匹配上的RNA串数
     //题目要求的是匹配不上的串数，故为 N-ans
}
```


------------

最后捞一手蒟蒻的[$\large\texttt\color{Orchid}\colorbox{white}{博客}$](https://www.luogu.com.cn/blog/quest233/) ~

---

## 作者：Karry5307 (赞：24)

### 题意

给一个有通配符的模式串和 $n$ 个文本串，其中 `?` 可以匹配任意字符，`*` 可以匹配 $0$ 或任意多个字符，求 $n$ 个文本串中无法与模式串匹配的数量。

$\texttt{Data Range:}1\leq n\leq 500$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13894788.html)

~~非确定性~~有限状态~~决策~~自动机。

首先考虑对模式串建一个自动机。对于每一位我们可以抽象成一个节点，整个字符串可以抽象成一个转移图。在匹配的过程中，如果能够走到这个节点上来就说明能够与这个位置的前缀相匹配。这里需要讨论一下：

- 如果模式串的某一位为字母，那么将这一位的状态向下一位的状态连这个字母的边，也就是说只有这个字母能从这一位转移到下一位。

- 如果模式串的某一位为 `?`，那么任何字母进来都能匹配上，也就是说将这一位的状态向下一位的状态连所有字母的边。

- 如果模式串的某一位为 `*`，这里是个小 trick，也就是说可以匹配任意长度的串，那就连个自环就可以了。

然后，对于匹配的话，从初始状态开始走，如果能够走到结束状态那么则匹配成功。

代码非常好写，跑得也很快。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=1e3+51;
struct Node{
	ll isEnd;
	vector<ll>nxt[4];
};
Node x[MAXN];
vector<ll>s,nxt;
ll n,len,tot,c,flg,res;
ll mp[128],vis[MAXN];
char ch[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void match()
{
	s.clear(),s.push_back(1);
	for(register int i=1;i<=len;i++)
	{
		nxt.clear(),flg=0;
		for(register int j=1;j<=tot;j++)
		{
			vis[j]=0;
		}
		for(register int j=0;j<s.size();j++)
		{
			for(register int k=0;k<x[s[j]].nxt[mp[ch[i]]].size();k++)
			{
				if((c=x[s[j]].nxt[mp[ch[i]]][k])&&!vis[c])
				{
					vis[c]=1,nxt.push_back(c),flg|=x[c].isEnd;
				}
			}
		}
		s=nxt;
	}
	res+=1-flg;
}
int main()
{
	scanf("%s",ch+1),len=strlen(ch+1),tot=1,memset(mp,-1,sizeof(mp));
	mp['A']=0,mp['G']=1,mp['C']=2,mp['T']=3;
	for(register int i=1;i<=len;i++)
	{
		if(mp[ch[i]]!=-1)
		{
			x[tot].nxt[mp[ch[i]]].push_back(tot+1),tot++;
			continue;
		}
		if(ch[i]=='?')
		{
			x[tot].nxt[0].push_back(tot+1),x[tot].nxt[1].push_back(tot+1);
			x[tot].nxt[2].push_back(tot+1),x[tot].nxt[3].push_back(tot+1);
			tot++;
			continue;
		}
		if(ch[i]=='*')
		{
			x[tot].nxt[0].push_back(tot),x[tot].nxt[1].push_back(tot);
			x[tot].nxt[2].push_back(tot),x[tot].nxt[3].push_back(tot);
			continue;
		}
	}
	x[tot].isEnd=1,n=read();
	for(register int i=0;i<n;i++)
	{
		scanf("%s",ch+1),len=strlen(ch+1),match();
	}
	printf("%d\n",res);
}
```

---

## 作者：一只书虫仔 (赞：17)

#### Description

> 给定一个母串 $S$，并给定 $n$ 个子串 $T$，$S$ 包括若干个字符：
> - `?`：可以替换为任意一个大写字母。
> - `*`：可以替换为任意长度为 $l \in [0,\infty)$ 的字符串。
> - 其他大写字母：无说明。
>
> 将 `?` 和 `*` 替换后形成的大写字母串称为 $S$ 的配合串，求 $n$ 个子串 $T$ 中有多少个不是 $S$ 的配合串。

#### Solution

定义 bool 数组 $f_{i,j}$ 为 $S_{[1,i]}$ 与 $T_{[1,j]}$ 是否匹配，则：

- 当 $S_i=$ `?` 时，既然这个位置上的字符可以随便替换，那么 $f_{i,j}=f_{i-1,j-1}$；
- 当 $S_i=$ `*` 时，分三种情况分别讨论：
	- 替换为长度为 $0$ 的字符串，当且仅当 $f_{i-1,j}$ 为 true；
    - 替换为长度为 $1$ 的字符串，当且仅当 $f_{i-1,j-1}$ 为 true；
    - 替换为长度大于 $1$ 的字符串，当且仅当 $f_{i,j-1}$ 为 true；
- 所以 $f_{i,j}=f_{i-1,j} \lor f_{i-1,j-1} \lor f_{i,j-1}$；
- 当 $S_i=$ 任意大写字母时，需要满足前面的 $S_{[1,i-1]}$ 和 $T_{[1,j-1]}$ 是匹配的之外，还需要保证 $S_i=T_j$，因此 $f_{i,j}=f_{i-1,j-1} \land [S_i=T_j]$。

最后看 $f_{|S|,|T|}$ 的值即可，注意要求的是多少个 $T$ 不是配合串。

初始化时如果只设 $f_{0,0}$ 为 true 就会在 $S$ 开头有若干个 `*` 的数据上 WA 掉，所以初始化时设 $S_{[1,k]}$ 都为 `*`，$S_{k+1}$ 不为 `*`，那需要让 $f_{p,0}$ 全部为 true，其中 $p \in [0,k]$。当然如果 $S$ 开头没有 `*` 就直接让 $f_{0,0}$ 为 true 即可。

#### Code

```cpp
dp[0][0] = true;
for (int i = 1; s[i] == '*'; i++) dp[i][0] = true;
for (int i = 1; i <= strs; i++)
	for (int j = 1; j <= strt; j++)
		if (s[i] == '?') dp[i][j] = (dp[i - 1][j - 1]);
		else if (s[i] == '*') dp[i][j] = (dp[i - 1][j] || dp[i - 1][j - 1] || dp[i][j - 1]);
		else dp[i][j] = (dp[i - 1][j - 1] && s[i] == t[j]);
if (dp[strs][strt] == false) cnt++;
```

---

## 作者：Log_x (赞：14)

##**Solution** $Trie$树 + $BFS$

- 把询问的$RNA$片段建成一颗$Trie$树，然后通过类似在$Trie$树 “走” 来求出答案，这个过程用$BFS$实现。

- 考虑在广搜的队列节点上记录两个值：$Q[][0]$表示在$Trie$树上走到的点，$Q[][1]$表示当前匹配到模板片段的位置；

- 然后我们考虑怎样扩展队列节点和计算答案：（为了描述方便，记$u = Q[][0],v = Q[][1]$，模板串为$s$，点$u$沿字典树边为$c$走到的点为$G[u][c]$）

- 当$s[v + 1]='A' or 'T' or 'C' or 'G'$时：可扩展节点{$G[u]['A' or 'T' or 'C' or 'G'],v + 1$}；

- 当$s[v + 1]='?'$时：因为可以代替任意字母，可同时扩展节点{$G[u]['A' and 'T' and 'C' and 'G'],v + 1$}；

- 当$s[v + 1]='*'$且$'*'$ 不代替字符时：可扩展节点{$u,v + 1$}；

- 当$s[v]='*' $且$'*'$代替多个字符时：将每代替一个字符都看成扩展一次队列上的节点，则每次可同时扩展节点 {$G[u]['A' and 'T' and 'C' and 'G]，v$}（即这次匹配到的位置仍不改变，下次则可同样继续扩展）；

- 直到某个节点上匹配到了模板串结尾，统计$Trie$树节点$u$上存在的$RNA$片段数量。

###**Notice**

- 通过一个$bool$数组$vis[x][y]$，记录走到节点$x$匹配到位置$y$的状态已经出现过，避免了不必要的搜索 (这里$bool$数组得用$bitset$，不然会$MLE$)。

- 应避免匹配到模板片段的位置大于原串长度或者在$Trie$树上走到的点为空，在扩展节点时进行特判。

##**Code**

```cpp
#include <cstdio>
#include <cstring>
#include <bitset>

using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 505, L = N << 1, M = L * 350;
int T = 1, n, Ans, len, t = 0, w = 1;
int G[M][4], val[M], Q[M][2];
char s[L], a[N], c[255]; 
bitset<L> vis[M];

inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline void Ins()
{
    scanf("%s", a + 1); int l = strlen(a + 1), x = 1;
    for (int i = 1; i <= l; ++i)
    {
        int y = c[a[i]]; 
        if (!G[x][y]) G[x][y] = ++T;
        x = G[x][y];
    } 
    val[x]++;
}

inline void Push(const int x, const int stp)
{
    if (!x || stp > len) return;
    if (!vis[x][stp])
    {
        vis[x][stp] = 1; w = (w + 1) % M;
        Q[w][0] = x; Q[w][1] = stp;
    } 
}

int main()
{
//    freopen("virus.in", "r", stdin);
//    freopen("virus.out", "w", stdout);
    c['A'] = 0; c['C'] = 1; c['T'] = 2; c['G'] = 3; 
    c['?'] = -1; c['*'] = -2;
    scanf("%s", s + 1); len = strlen(s + 1);
    s[0] = '?'; n = get();
    for (int i = 1; i <= n; ++i) Ins();
    int u, v, I; Q[1][0] = 1; Q[1][1] = 0; vis[1][0] = 1;
    while (t != w)
    {
        t = (t + 1) % M;
        u = Q[t][0]; v = Q[t][1];
        if (s[v] == '*') 
         for (int i = 0; i < 4; ++i) Push(G[u][i], v);
        if (v == len) {Ans += val[u]; val[u] = 0; continue;}
        if (c[s[v + 1]] >= 0) Push(G[u][c[s[v + 1]]], v + 1);
         else 
         {
             for (int i = 0; i < 4; ++i) Push(G[u][i], v + 1);
             if (s[v + 1] == '*') Push(u, v + 1);
         }
    }
    return put(n - Ans), 0;
}
```

---

## 作者：午夜飘雪 (赞：10)

一看数据范围这么小……不用建trie树，暴力跑个$O(n^3)dp$似乎就能过的样子？

~~事实上还真能过……虽然慢了点x~~

设f[i][j]表示1匹配到第i个字符,串2匹配到第j个字符时是否可行

直接暴力匹配……

星号的部分要特殊处理

设一个c数组，表示i位置的星号最早能匹配到的一个字符

匹配时,如果按照普通方法匹配不上，特判一下病毒模板串的上一位是不是星号

如果上一位是星号，且这个星号能匹配到的最早位置在j之前，那么说明j之前的字符都可以丢给星号，于是判定为匹配成功

细节好多的说……看代码吧QAQ



```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    using namespace std;
    const int N=1009;
    char vir[N],s[N];
    int n,lenn,ans;
    int c[N];//*匹配的最早的一个字符 
    bool f[N][N];//串1匹配到第i个字符,串2匹配到第j个字符是否可行 
    inline bool check(char x,char y){
        if(x==y||x=='?')return true;
        return false;
    }
    inline void solve(int len){
        memset(f,0,sizeof(f));
        memset(c,0x3f,sizeof(c));
        f[0][0]=1;
        for(int i=1;i<=lenn;++i){
            if(vir[i]=='*'){
                if(i==1)f[1][0]=1;
                for(int j=1;j<=len;++j){
                    if(f[i-1][j]||f[i][j-1])
                        f[i][j]=1,c[i]=min(c[i],j);
                }
            }
            else{
                for(int j=1;j<=len;++j){
                    if(!check(vir[i],s[j]))continue;
                    if(f[i-1][j-1])f[i][j]=1;//普通判定 
                    else if(i>1&&vir[i-1]=='*'&&c[i-1]<j)f[i][j]=1;//特殊判定 
                }
            }
        }
        if(f[lenn][len])++ans;
    }
    int main(){
        ios::sync_with_stdio(0);
        cin>>vir+1;lenn=strlen(vir+1);
        cin>>n;
        for(int i=1;i<=n;++i){
            cin>>s+1;
            int len=strlen(s+1);
            solve(len);
        }
        cout<<n-ans<<endl;
        return 0;
    } 
```
~~……据说程序耗时dp>trie树>dfs?
溜了溜了x~~


---

## 作者：Ajsoabk (赞：8)


# [P2536 [AHOI2005]病毒检测](https://www.luogu.org/problemnew/show/P2536)

通过常数优化学到了很多

## 题意：

匹配时定义两种字符 '*' '?'

分别表示在'*' 处随便换成什么字符串（包括空字符串）

在'?'处只能换成一个合法字符（'A''T''G''C'）

问最大不匹配数

## 思路

想想字符串匹配

这里只管匹配，只须在树上往下走，故建一只trie树即可

以母串0下标位置，trie树根节点位置起始

往下搜索（这里我用广搜bfs，条件更好分类）（一开始我并不知道会被卡常数）

根据母串当前的字符有多种情况


1. '*'被空字符串替代：trie上不走，母串走

2. '*'被非空字符串替代：母串不走，trie上走，且四种方向能走的都走

3. '?'：母串、trie都走，且四种方向能走的都走

4. 'A''T''G''C':母串、trie都走

输出的答案ans先初始化为n

跑到某些字符串的end位置就减去以该节点为end的病毒串个数（当然Insert的时候就处理好了）

输出ans即可

然鹅就算是广搜

还是会爆炸

没办法，只能各种优化了

最重要的是对每个点的每个 母串上走过的位置 标记vis，不必再走过

这个优化可以把3T1M变成1个T（看来前仆后继地走一个点的情况太多了）

然后就只有吸氧才能拯救了。。。

（有大佬能优化过请一定要D我）
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<bitset> 
#include<queue>
using namespace std;
const int N=500+5;
const int L=1000+5;
const int M=N*N;
template<class T>inline void read(T &num){
    char ch;
    while(!isdigit(ch=getchar()));
    num=ch-'0';
    while(isdigit(ch=getchar()))num=num*10+ch-'0';
}

int mmp[300];//愤怒之情溢于数组
int tri[M][4],is_end[M],fla[M],totn=1,n,ans,res[M],valu[L];
char str[L],s[N];
inline void Insert(char s[]){
    int len=strlen(s),x=1;
    for(int p=0;p<len;++p){
        int ch=mmp[s[p]];
        if(tri[x][ch]==0){
            tri[x][ch]=++totn;
        }
        x=tri[x][ch];
    }
    is_end[x]++;
}

struct Data{
    int first,second;
    Data(const int a=0,const int b=0){
        first=a,second=b;
    }
};

queue<Data>que;
bitset<L> vis[M];
inline void Push(const int x,const int y){
    if(!x||vis[x][y])return;
    que.push(Data(x,y));
    vis[x][y]=true;
}

inline void bfs(){
    int len=strlen(str),x,p;
    Push(1,0);
    while(que.size()){
        x=que.front().first,p=que.front().second;que.pop();
        if(p==len){
            if(fla[x]==0){
                ans-=is_end[x];
                fla[x]=1;
            }
            continue;
        }
        int ch=mmp[str[p]];
        if(ch<4&&tri[x][ch])Push(tri[x][ch],p+1);
        else if(ch==4){
            Push(x,p+1);
            for(int i=0;i<4;++i)if(tri[x][i])Push(tri[x][i],p);
        }
        else if(ch==5)for(int i=0;i<4;++i)if(tri[x][i])Push(tri[x][i],p+1);
    }
}

int main(){
    mmp['G']=1,mmp['C']=2,mmp['T']=3,mmp['*']=4,mmp['?']=5;
    scanf("%s",str);
    read(n);
    ans=n;
    for(int i=1;i<=n;++i){
        scanf("%s",s);
        Insert(s);
    }
    bfs();
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：team0001 (赞：6)

发一篇~~快到没朋友的~~trie树题解

首先 要求非病毒的片段数量

只需先求出病毒的数量 再用总数去减即可

相信不少~~像我一样~~的蒟蒻都想到了

但是怎么求呢？

## trie树
我们可以将RNA片段建一颗trie树

再用目标序列在树上跑（个人推荐dfs）

- 如果当前位是“A、C、T、G”直接去对应节点即可

- 如果是“?” 往每一个相连的节点跑1遍

- 如果是“* ”
1. 可能是空串 直接跳过

    2. 如果不为空

       我们知道一个“\* "与 “？\* "是等价的

       可以推出第2种情况 
   
       即先做"?"的操作而位数不变仍保持在"* "这位
       
       这样就可以将“\*”给拆成若干“？”
       
       从而解决问题
        
### 但是问题真的这么简单吗？
如果模板串中有大量的“\*”

我们的搜索就会将一个点重复遍历数次

时间复杂度极大

可以看到 许多大佬用了bitset来优化

但二维的bitset即占空间效率也不高

为了提高效率 我们可以记下每个节点子树中还有多少未匹配的串

如果所有串已匹配 即未匹配数为0时就没必要继续搜了 ~~（这里dfs应该会有优势）~~

事实证明 在没有恶意卡这种算法时 ~~想卡也卡不掉~~

它体现出了极佳的效率（43ms或许有5-6ms的浮动）

[评测记录](https://www.luogu.org/record/23312374)（为什么在我前面的不是特判搜索就是用一种神奇的方法？？？）

代码
```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int trie[250005][4],maxnode=0,n,size[250005],mbl,ans;
int p;
char mb[1005],x[1005];
bool b[250005][4],ended[2500005];
void insert(char s[]){
	int now=0,len=strlen(s);
	for(int i=0;i<len;i++){
		if(s[i]=='A')p=0;
		if(s[i]=='C')p=1;
		if(s[i]=='T')p=2;
		if(s[i]=='G')p=3;
	    size[now]++;
		if(!trie[now][p])trie[now][p]=++maxnode;
		now=trie[now][p];
	}
	size[now]++;
	ended[now]=1;
	return;
}
void dfs(int ws,int now){
	if(!size[now])return;
	if(ws==mbl){
		ans+=ended[now];
		size[now]-=ended[now];
		ended[now]=0;
		return;
	}
	if(mb[ws]=='?'){
		for(int i=0;i<4;i++){
		    int son=trie[now][i];
			if(son)dfs(ws+1,son);
		}
	}
	else if(mb[ws]=='*'){
		dfs(ws+1,now);
		for(int i=0;i<4;i++)if(trie[now][i]){
			dfs(ws+1,trie[now][i]);
			dfs(ws,trie[now][i]);
		}
	}
	else {
		if(mb[ws]=='A')p=0;
		if(mb[ws]=='C')p=1;
		if(mb[ws]=='T')p=2;
		if(mb[ws]=='G')p=3;
		if(trie[now][p])dfs(ws+1,trie[now][p]);
	}
	size[now]=0;
	for(int i=0;i<4;i++)if(trie[now][i])size[now]+=size[trie[now][i]];
}
int main(){
	scanf("%s%d",mb,&n);
	mbl=strlen(mb);
	for(int i=1;i<=n;i++){
		scanf("%s",x);
		insert(x);
	}
	dfs(0,0);
	cout<<n-ans;
} 
```

---

## 作者：Hercules (赞：3)

## 题解：P2536[AHOI]病毒检测

这道题虽然不能说是模板题，但是读懂的话就是一个简单的应用，将$Trie$树进行一点的变换就OK。

有些神仙用$dp$搞的，但是建议还是用$Trie$再写一遍，毕竟目的还是熟练掌握$Trie$。

毫无疑问先将各个$RNA$片段存到$Trie$中，

之后通过$dfs$搜索是否与那些病毒模板有匹配，字母的情况不必多说，重要的是 $'?'$ 和 $'*'$ 的情况。

如果为 $'?'$ 直接下一个，因为可以为任何字母没必要去纠结。

如果为 $'*'$ 可以分成两种不一样的：

1.充当一串字符，匹配的$RNA$跳位；

2.为空，模板串还是现在的位置不变，$Trie$跳一位（四个方向都可以）。

注意在搜索的时候要用一个$vis$记录是否经过，经过的话直接$return$就好，不写这个的话50分。。。

$P.S.\ \ vis$用$bitset$写，否则会RE（开始我就这么写的$QAQ$）

总结来说：把要检测$RNA$都扔进$Trie$树，然后用病毒模板去匹配，把与病毒模板匹配成功的减去就OK。
```c
#include <bits/stdc++.h>

const int MAXN = 1010;
const int MAXM = 5e5 + 10;
char s1[MAXN], s2[MAXN];
std::bitset< MAXN > vis[MAXM];
int n, ans, sum, len, tot, cnt[MAXM], nxt[MAXM][5];

inline int read() {
	int X = 0, flag = 0;
	char ch = 0;
	while (!isdigit(ch))
		flag |= ch == '-', ch = getchar();
	while (isdigit(ch))
		X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
	return flag ? -X : X;
}

inline int check(char ch) {
    if (ch == 'A')
        return 0;
    if (ch == 'C')
        return 1;
    if (ch == 'G')
        return 2;
    return 3;
}

inline void dfs(int root, int now) {
	if (now == len) {
		sum += cnt[root], cnt[root] = 0;
		return;
	}
	if (vis[root][now])
		return;
	vis[root][now] = true;
	if (s1[now] >= 'A' and s1[now] <= 'Z') {
		if (nxt[root][check(s1[now])])
			dfs(nxt[root][check(s1[now])], now + 1);
		return;
	}
	if (s1[now] == '?') {
		for (int i = 0; i < 4; i++)
			if (nxt[root][i])
				dfs(nxt[root][i], now + 1);
		return;
	}
	if (s1[now] == '*') {
		dfs(root, now + 1);
		for (int i = 0; i < 4; i++)
			if (nxt[root][i])
				dfs(nxt[root][i], now + 1), dfs(nxt[root][i], now);
		return;
	}
}

signed main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
	freopen("testdata.in", "r", stdin);
	freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
	freopen("AHOI2005病毒检测.in", "r", stdin);
	freopen("AHOI2005病毒检测.out", "w", stdout);
#endif
#endif
	scanf("%s", s1);
	len = strlen(s1);
	n = read();
	for (int i = 1; i <= n; i++) {
		scanf("%s", s2);
        int Len = strlen(s2), root = 0;
        for (register int i = 0; i < Len; i++) {
            if (!nxt[root][check(s2[i])])
                nxt[root][check(s2[i])] = ++tot;
            root = nxt[root][check(s2[i])];
        }
        cnt[root]++;
	}
	dfs(0, 0);
	ans = n - sum;
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Qura (赞：3)

记忆化搜索。```dfs(x,y)```表示模式串的$[0,x-1]$与文本串的$[0,y-1]$匹配时，能否达成全文匹配。简单分析不难得出以下程序（自行忽略记忆化）：
```cpp
int l1,l2;
char T[1010],S[510];
int f[510][510], d; //记忆化 
bool dfs(int x,int y) {
	if(f[x][y]==d||f[x][y]==-d) 
		return f[x][y]>0;
	if(x>=l1||y>=l2) 
		return x==l1&&y==l2;
	if(T[x]=='*'&&(dfs(x+1,y)||dfs(x,y+1))) //T[x]不匹配或匹配1个 
		return f[x][y]=d, 1;
	if((T[x]=='?'||T[x]==S[y])&&dfs(x+1,y+1)) 
		return f[x][y]=d, 1;
	return f[x][y]=-d, 0;
}
```
但这样做有一个问题，当模式串$T$尾部存在```'*'```就无论如何也到不了```dfs(l1,l2)```了。解决方案是在T与S的尾部都加上一个```'@'```

[完整代码间提交记录](https://www.luogu.org/record/show?rid=7935168)

---

## 作者：asuldb (赞：3)

$Trie$ 树+搜索

我用的是$dfs$

首先对于将所有的RNA片段都建到$Trie$树里去，之后来匹配那个模板串就好了

如果是匹配的位置是字母，那么我们就继续往下匹配

如果是$?$，我们必须要略过$Trie$树上的一位去匹配

如果是$*$，我们可以先考虑直接忽略这一位，也可以直接把这一位当成$?$来看，或者是在$Trie$树上略过一位，但是在模板串上的匹配仍为当前位置，这样就能实现在$Trie$树上忽略多位进行匹配了

一旦某一位匹配成功了，我们如果还有状态到达这一步就没有什么必要了，所以开一个$bitset$来进行记忆化就好了

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<bitset>
#define re register
#define maxn 500005
int son[maxn][4],flag[maxn];
int n,m,cnt,L,ans;
char S[1001],T[1001];
std::bitset<1001> f[maxn];
inline int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
      x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x;
}
inline int ch(char p)
{
    if(p=='A') return 0;
    if(p=='G') return 1;
    if(p=='T') return 2;
    if(p=='C') return 3;
}
inline void ins()
{
    int len=strlen(S+1);
    int now=0;
    for(re int i=1;i<=len;i++)
    {
        if(!son[now][ch(S[i])]) son[now][ch(S[i])]=++cnt;
        now=son[now][ch(S[i])];
    }
    flag[now]++;
}
void dfs(int now,int t)
{
    if(t==L+1)//匹配成功
    {
        ans+=flag[now];
        flag[now]=0;
        return;
    }
    if(f[now][t]) return;
    f[now][t]=1;//记忆化
    if(T[t]>='A'&&T[t]<='Z') 
    {
        if(!son[now][ch(T[t])]) return;
        dfs(son[now][ch(T[t])],t+1);
    }//是字母，那么我们就继续往下匹配
    else 
    {
        if(T[t]=='?') 
        {
            for(re int i=0;i<4;i++)
            if(son[now][i]) dfs(son[now][i],t+1);//在Trie上忽略一位，同时模板串匹配位置加1
        }
        if(T[t]=='*')
        {
            dfs(now,t+1);//忽略*,即用0个字符来代替它
            for(re int i=0;i<4;i++)
            if(son[now][i]) dfs(son[now][i],t+1),dfs(son[now][i],t);
            //第一个dfs直接把这一位当成$?$来看，第二个dfs就能实现一个*代替多个字符
        }
    }
}
int main()
{
    scanf("%s",T+1);
    L=strlen(T+1);
    n=read();
    for(re int i=1;i<=n;i++)
        scanf("%s",S+1),ins();
    dfs(0,1);
    printf("%d\n",n-ans);
    return 0;
}
```

---

## 作者：Liu_Tianze (赞：1)

# P2536 [AHOI2005] 病毒检测 题解

[**题目链接**](https://www.luogu.com.cn/problem/P2536)

推荐跳转至[**我的博客**](https://www.luogu.com.cn/blog/Liu-Tianze/P2536)进行阅读

### 题目分析

本蒟蒻从未学习过 Trie 树以及 AC 自动机的相关知识，但此题我想到可以使用 **动态规划** 的思想完成。

设“病毒模版片段”为 $A$ 序列，“RNA 片段”为 $S$ 序列.

我们用 `f[i][j]` 表示 $A_{1...i}$ 与 $S_{1...j}$ 能否匹配

那么每一位只需分三种情况讨论即可:

- 如果模板序列中为正常字母，那么如果 `f[i-1][j-1]` 匹配成功且当前位也相同，则 `f[i][j]` 可以匹配；

- 如果模板序列中为 `?` ，那么 `f[i][j]` 的匹配情况由上一位 `f[i-1][j-1]` 决定；

- 如果模板序列中为 `*` ，则此位可能当作 `?` 、空 或者是多个 `?` 相交（即 `f[i][j-1]` ）

这样题目的核心代码就完成了.

还需注意一下细节问题，比如：

- `f[0][0]` 的初值

- 模板序列第一位为 `*` 的情况 （特判即可）

### 代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

string a,s;
bool f[1010][1010];

bool check(string x){
	int z1=a.size(),z2=x.size();
	for(int i=0;i<z1;i++){
		for(int j=0;j<z2;j++){
			if(a[i]=='A'||a[i]=='C'||a[i]=='T'||a[i]=='G'){
				if(f[i-1][j-1]&&a[i]==x[j]) f[i][j]=true;
			}
			else if(a[i]=='?'){
				if(f[i-1][j-1]) f[i][j]=true;
			}
			else if(a[i]=='*'){
				if(i==0) f[1][0]=1;
				if(f[i-1][j]||f[i-1][j-1]||f[i][j-1]) f[i][j]=true;
			}
		}
	}
	if(f[z1-1][z2-1]==true) return true;
	else return false;
}

int main(){
	int n,ans=0;
	cin>>a>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		memset(f,false,sizeof(f));
		f[0][0]=true;
		if(!check(s)) ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

本人 $\texttt{AC}$ 的第一道紫题，因此写此题解纪念一下 ~~（正好也是第一次正式的写题解）~~


---

## 作者：zjh111111 (赞：1)

### 这里给出一种会 $T$ 但是能过的暴力 $dp$ 做法

### [link](https://www.luogu.com.cn/problem/P2536)

考虑 $f[i][j]=0/1$ 表示模板串前 $i$ 位，比对串前 $j$ 位能否匹配

记模板串第 $i$ 位为 $a_i,$ 比对串第 $j$ 位为 $b_j\ ($下标从$1$开始$)$ 

接下来分情况讨论

- $a_i=*$

$$f[i][j]\ |=\ f[i-1][k]\ (k\in[0,j])$$

```latex
|=就是存在一个f[i-1][k]为1则f[i][j]为1，否则为0
```
由于 $b_{k+1}...b_{j}$ 都可以被一个$*$ 匹配，$k=j$ 即不填

- $a_i=?$

$$f[i][j]=f[i-1][j-1]$$

- $a_i=A/C/T/G$

$$f[i][j]=f[i-1][j-1]\ (a_i=b_j)$$

答案即 $f[len_a][len_b]$

$*$ 的操作只要边循环边或就行

发现 $f$ 的转移只和上一行有关，于是滚动数组优化

复杂度$\mathcal{O(n*len_a*len_b)}$

能过题但是复杂度不优，仅供参考

[code](https://www.luogu.com.cn/paste/bipwfeg2)

我代码合并了连续的 $*,$ 不知道不写能不能过

---

## 作者：_Diu_ (赞：1)

[病毒检测](https://www.luogu.com.cn/problem/P2536)

这一道题听说可以用AC自动机来做

但是我觉得我们可以让AC自动机去AC别的题目，用最简单的

### 字符串哈希

就可以了

当然还是要跑$dp$的~~qwq~~

---

我们可以设定$bool$型的$f[i][j]$表示

#### 前面原字符串的前$i$个字符与待匹配的字符串的前$j$个字符匹配

如果当前通配符是'*'的话，只要当前匹配了，那么后面所有的都可以匹配

如果在两个通配符之间的字符全部匹配（用$hash$处理）

都可以打标记

但如果当前通配符是'?'的话，不能给当前字符打标记，要跳到下一个

因为'?'只能匹配一个字符

初始化的话

就是$f[0][0]=1$

因为一个字符都没有的两个空串是匹配的

## 关于代码

我的码风十分奇怪，能看得懂就行

其中$tpf$，顾名思义，就是通配符

两个$h$分别表示原字符串和待处理字符串的哈希前缀和

另外，我是用字符串存的，为了方便处理，我在每个字符串前都加上个空格

还有一个比较重要的

如果原字符串最后一个字符不是通配符的话

后面的字符是匹配不到的

所以我在原字符串后面加了一个'?'，为了不改变字符串值，所以在每一个待处理字符串前都要加上任意一个字符

还有一个地方比较坑，这一题没有说明通配符个数的限制

所以还有可能全都是通配符

所以数组要开大一点

## code

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N=1010;
int n,m,k,tpf[N],cnt,ans;
ull h1[N],h2[N],t[N],b=1331;
string s,str;
bool f[N][N];
int main(){
	cin>>s;
	s=' '+s+'?';
	n=s.size()-1;
	t[0]=1;
	for(int i=1;i<N;i++)t[i]=t[i-1]*b;
	for(int i=1;i<=n;i++){
		h1[i]=h1[i-1]*b+s[i];
		if(s[i]=='*'||s[i]=='?')tpf[++cnt]=i;
	}
	scanf("%d",&k);
	while(k--){
		cin>>str;
		str=' '+str+'a';
		m=str.size()-1;
		for(int i=1;i<=m;i++)h2[i]=h2[i-1]*b+str[i];
		memset(f,0,sizeof(f));
		f[0][0]=1;
		for(int i=0;i<=cnt;i++){
			if(s[tpf[i]]=='*')for(int j=1;j<=m;j++)if(f[i][j-1])f[i][j]=1;
			for(int j=0;j<=m;j++){
				if(!f[i][j])continue;
				register int lt=tpf[i]+1,rt=tpf[i+1]-1,ls=j+1,rs=j+(rt-lt+1);
				if(h1[rt]-h1[lt-1]*t[rt-lt+1]==h2[rs]-h2[ls-1]*t[rs-ls+1])
					f[i+1][rs+(s[tpf[i+1]]=='?')]=1;
			}
		}
		ans+=f[cnt][m]^1;
	}
	printf("%d\n",ans);
}
```

另外，这一道题和[通配符匹配](https://www.luogu.com.cn/problem/P3167)也很相似，大家也可以去$A$一下

---

## 作者：弦巻こころ (赞：1)

### ~~一道卡空间毒瘤好题~~

这道题跟$AC$自动机没什么关系，其实就是一个$trie$树+$dfs$ 或$bfs$，感觉思路和[这题](https://www.luogu.org/problem/P2292)差不多。

就先以$RNA$片段建出$trie$树，然后$dfs$暴力查找。

对于每个 ？ ，我们直接$for$循环，去找它的子节点。然后继续$dfs$，

对于每个$ * $，对于当前这一位我们有三种处理情况

1.直接跳过* ，相当于匹配0个。

2.当成？匹配，相当于结束了* 

3.继续多位匹配

对于正常字母，直接看$trie$树中有没有对应的位置，有就直接继续搜，没有就返回。

最后就是记忆化，因为这样会搜出很多重复的情况，所以对于每个$now$和$x$都需要在访问过后将$vis$赋为$1$，下次访问到vis值为1时就直接返回，这样就少了很多重复的情况。

然而用$bool$会被卡空间。。。所以只能用$bitset$过了。

我对自己表达能力还是有点 * 数的，看不懂的话可以看代码，注释说的挺清楚的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int trie[250005][6],num[250005],tot,ans=0,n,m,L;
bitset<1001> vis[250005];//请用bitset 不然会被卡空间
char s[1005],str[505];
int ark(char c)//将字符处理为各个数字
{
	if(c=='A')
	{
		return 0;
	}
	if(c=='G')
	{
		return 1;
	}
	if(c=='T')
	{
		return 2;
	}
	if(c=='C')
	{
		return 3;
	}
	if(c=='?')
	{
		return 4;
	}
	return 5;
}
void make_trie(char sa[505])//建trie树 
{
	int now=0,len=strlen(sa);
	for(int i=0;i<len;i++)
	{
		int next=ark(sa[i]);
		if(!trie[now][next])
		{
			trie[now][next]=++tot;
		}
		now=trie[now][next];
	}
	num[now]++;//因为可能有重复字符串，所以这里是++，而不是赋为1
}
void dfs(int x,int now)
{
	if(x==L)//如果匹配成功（一定为模式串结尾 ） 
	{
		ans+=num[now];
		num[now]=0;//记得清0 不然就重复算了 
		return;
	}
	if(vis[now][x])//记搜 
	{
		return;	
	}
	vis[now][x]=1;//赋初值 
	if(ark(s[x])==4)//如果当前字符为？ 
	{
		for(int i=0;i<=3;i++)
		{
			if(trie[now][i])
			{
				dfs(x+1,trie[now][i]);//将？当成任意一个字符匹配 
			}
		}
	}
	if(ark(s[x])==5)//如果当前字符为* 
	{
		dfs(x+1,now);//不匹配* 
		for(int i=0;i<=3;i++)
		{
			if(trie[now][i])
			{
				dfs(x+1,trie[now][i]);
				dfs(x,trie[now][i]);
			}
		}
	}
	if(trie[now][ark(s[x])])//如果当前字符为字母 
	{
		dfs(x+1,trie[now][ark(s[x])]);
	}
}
int main()
{
//	freopen("did.in","r",stdin);
	scanf("%s",s);
	L=strlen(s)+1;
	scanf("%d",&n);

	for(int i=1;i<=n;i++)
	{
		scanf("%s",str);
		make_trie(str);
	}
	dfs(0,0); //爆搜 
	cout<<n-ans;//由于我们找的是病毒段，而题目求得是不是病毒段的串，就用 n-ans 
	return 0;
}
```


---

## 作者：Mizuhara (赞：1)

记模板串为s2,待测串为s1。

1. 对于s2首尾，若没有$*$，直接一位位匹配直到有$*$即可。

2. 再考虑s2串为$"*a_1*a_2*a_3 . . .*a_n*"$的情况。其中$a_i$是$s2$的某个片度。

	我们将$a_i$依次从s1的合法位置开始向后匹配。（合法位置初始为0）

	用匹配到的第一个位置来更新合法位置。

	至于为什么不用s1后面的位置，这是因为用后面的一定不会比用前面的更优。

	直到匹配完s2，匹配结束。若任何一步匹配失败，则不是病毒。

	注：这种方法不需要限定AGCT。下面的例子也没有限定。
    
匹配的话用kmp可以做到$O(q(n+m))$，但是对于‘?’貌似不好处理。

写的kmp愣是没过。后来打的暴力匹配，没想到比kmp还快......

```
#include<iostream>
#include<memory.h>
#include<string>
#define maxn 1010
using namespace std;

string s2,s[maxn];
int next1[maxn<<1];
int pipei(string s1,int st,int l,int r){
//在s1的st到lon中查找第一个匹配s2的l到r位的位置hou yi wei
	//暴力匹配
    for(int i=st;i+r-l<s1.length();i++){
    for(int j=l;j<=r;j++){
        if(s1[i+j-l]!=s2[j]&&s2[j]!='?')goto End;
        if(j==r)return i+j-l+1;
    }
    End:continue;
    }
    return -1;
    
    //kmp
    
    /*memset(next1,0,sizeof(next1));
    next1[0]=next1[1]=0;int k=0;
    for(int i=l+1;i<=r;i++){
        while(k&&(s2[k+l]!=s2[i]&&s2[k+l]!='?'))k=next1[k];
        next1[i-l+1]=(s2[k+l]==s2[i]||s2[k+l]=='?')?++k:0;
    }k=0;
    for(int i=st;i<s1.length();i++){
        while(k&&s2[k+l]!=s1[i]&&s2[k+l]!='?')k=next1[k];
        k+=(s2[k+l]==s1[i]||s2[k+l]=='?');
        if(k==r-l+1)return i+1;
    }
    return -1;*/
}
bool check(string ss){
    int shou=0,wei1=ss.length(),wei2=s2.length();
    while(s2[shou]!='*'){
        if(s2[shou]!=ss[shou]&&s2[shou]!='?')return true;
        shou++;
        if(shou==wei2)return wei1!=wei2;
        if(shou==wei1){
            for(int i=shou;i<wei2;i++)
            if(s2[i]!='*')return true;
            return false;
        }
    }
    while(s2[wei2-1]!='*'){
        if(s2[wei2-1]!=ss[wei1-1]&&s2[wei2-1]!='?')return true;
        wei1--;wei2--;
        if(shou==wei1){
            for(int i=shou;i<wei2;i++)
            if(s2[i]!='*')return true;
            return false;
        }
    }int st=shou;
    //cout<<shou<<' '<<wei1<<' '<<endl<<shou<<' '<<wei2<<endl;
    while(1){
        if(shou==wei2-1)return false;
        for(int i=shou+1;i<wei2;i++)
        if(s2[i]=='*'){
           if(shou+1==i){
               shou++;
               continue;
           }
            st=pipei(ss,st,shou+1,i-1);
            if(st==-1)return true;
            shou=i;
            break;
        }
    }
}
int main(){
    int n,Ans=0;
    cin>>s2;cin>>n;
    for(int i=1;i<=n;i++){
        string ss;cin>>ss;
        Ans+=check(ss);
    }
    cout<<Ans;
    return 0;
}
```

---

## 作者：creation_hy (赞：0)

## 前言

和 P4407 好像啊（

~~每日一问：一眼秒，有紫吗~~

## 思路

一眼 Trie 上 dfs。

如果你对这方面不是很了解，可以参考我的 [P4407 题解](https://www.luogu.com.cn/blog/creationhy/solution-p4407)。

给所有要检测的串建 Trie，然后 dfs。

具体实现：

$s$ 表示要匹配的串，$x$ 表示搜到了 $s$ 的第几位，$cur$ 表示当前在 Trie 上的指针。

如果 $s[x]$ 是 $A/C/T/G$，那么必须正好走下去，即下一个 $cur$ 必须是 $trie[cur][s[x]]$。

如果 $t[x]$ 是 $?$，那么随便在 $cur$ 下匹配一个字符就行。

如果 $t[x]$ 是 $*$，那么当前有两种选择：

- 结束 $*$ 对应的子串，即让下一次的 $x=x+1$。
- 继续匹配 Trie 上的子串，即还是随便匹配一个字符，但是 $x$ 不变。

代码：

```cpp
inline int dfs(string s, int x, int cur)
{
    int res = 0;
    if (x == s.size() && tag[cur] && !vis[cur])
    {
        vis[cur] = true;
        return 1;
    }
    if (s[x] >= 0 && t[cur][s[x]])
        return dfs(s, x + 1, t[cur][s[x]]);
    else if (s[x] == -1)
    {
        for (int i = 0; i < 4; i++)
            if (t[cur][i])
                res += dfs(s, x + 1, t[cur][i]);
    }
    else if (s[x] == -2)
    {
        res += dfs(s, x + 1, cur);
        for (int i = 0; i < 4; i++)
            if (t[cur][i])
                res += dfs(s, x, t[cur][i]);
    }
    return res;
}
```

然后 [交了一发](https://www.luogu.com.cn/record/97702544)，T 了四个点。。。

发现 $vis$ 数组在上面代码上作用很废，只是在匹配完的时候判断是否重复。

考虑加个记忆化搜索，即加大 $vis$ 数组的作用。

$vis[x][cur]$ 表示当 dfs 参数为 $x,cur$ 的时候是否访问过。

很显然，如果两次搜索的 $x,cur$ 都相等，那么他们的作用也是相等的。

于是有了这版代码：

```cpp
inline int dfs(string s, int x, int cur)
{
    if (vis[cur][x])
        return 0;
    vis[cur][x] = true;
    if (x == s.size() && tag[cur])
        return 1;
    int res = 0;
    if (s[x] >= 0 && t[cur][s[x]])
        return dfs(s, x + 1, t[cur][s[x]]);
    else if (s[x] == -1)
    {
        for (int i = 0; i < 4; i++)
            if (t[cur][i])
                res += dfs(s, x + 1, t[cur][i]);
    }
    else if (s[x] == -2)
    {
        res += dfs(s, x + 1, cur);
        for (int i = 0; i < 4; i++)
            if (t[cur][i])
                res += dfs(s, x, t[cur][i]);
    }
    return res;
}
```

当然数组直接开这么大肯定是不行的，要用 bitset 优化一下空间，即 `bitset<1005> vis[N]`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, val[150];
const int N = 3e5 + 5;
struct Trie
{
    int t[N][4], tot;
    bool tag[N];
    bitset<1005> vis[N];
    inline void insert(string s)
    {
        int cur = 0;
        for (char c : s)
        {
            if (!t[cur][c])
                t[cur][c] = ++tot;
            cur = t[cur][c];
        }
        tag[cur] = true;
    }
    inline int dfs(string s, int x, int cur)
    {
        if (vis[cur][x])
            return 0;
        vis[cur][x] = true;
        if (x == s.size() && tag[cur])
            return 1;
        int res = 0;
        if (s[x] >= 0 && t[cur][s[x]])
            return dfs(s, x + 1, t[cur][s[x]]);
        else if (s[x] == -1)
        {
            for (int i = 0; i < 4; i++)
                if (t[cur][i])
                    res += dfs(s, x + 1, t[cur][i]);
        }
        else if (s[x] == -2)
        {
            res += dfs(s, x + 1, cur);
            for (int i = 0; i < 4; i++)
                if (t[cur][i])
                    res += dfs(s, x, t[cur][i]);
        }
        return res;
    }
} tr;
inline void toval(string &s)
{
    for (int i = 0; i < s.size(); i++)
        s[i] = val[s[i]];
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    val['A'] = 0, val['C'] = 1, val['T'] = 2, val['G'] = 3, val['?'] = -1, val['*'] = -2;
    string txt;
    cin >> txt >> n;
    for (int i = 1; i <= n; i++)
    {
        string s;
        cin >> s;
        toval(s);
        tr.insert(s);
    }
    toval(txt);
    cout << n - tr.dfs(txt, 0, 0);
    return 0;
}
```

---


# [APIO2007] 风铃

## 题目描述

你准备给弟弟 Ike 买一件礼物，但是，Ike 挑选礼物的方式很特别：他只喜欢那些能被他排成有序形状的东西。

你准备给 Ike 买一个风铃。风铃是一种多层的装饰品，一般挂在天花板上。

每个风铃都包含一些由竖直线连起来的水平杆。每根杆的两头都有线连接，下面或者挂着另一根水平杆，或者挂着一个玩具。下面是一个风铃的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/e1m223hc.png)

为了满足弟弟，你需要选一个满足下面两个条件的风铃：

1. 所有的玩具都在同一层(也就是说，每个玩具到天花板之间的杆的个数是一样的)或至多相差一层。
2. 对于两个相差一层的玩具，左边的玩具比右边的玩具要更靠下一点。

风铃可以按照下面的规则重新排列：任选一根杆，将杆两头的线“交换”。也就是解开一根杆左右两头的线，然后将它们绑到杆的另一头。这个操作不会改变更下面的杆上线的排列顺序。

正在训练信息学奥林匹克的你，决定设计一个算法，判断能否通过重新排列，将一个给定的风铃变为 Ike 喜欢的样子。

考虑上面的例子，上图中的风铃满足条件 $1$，却不满足条件 $2$ ——最左边的那个玩具比它右边的要高。

但是，我们可以通过下面的步骤把这个风铃变成一个 Ike 喜欢的：

 1.   第一步，将杆 $1$ 的左右两边交换，这使得杆 $2$ 和杆 $3$ 的位置互换，交换的结果如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/4388.png)

 2.   第二步，也是最后一步，将杆 $2$ 的左右两边交换，这使得杆 $4$ 到了左边，原来在左边的玩具到了右边，交换的结果发下图所示：

![](https://cdn.luogu.com.cn/upload/pic/4389.png)

现在的这个风铃就满足 Ike 的条件了。

你的任务是：给定一个风铃的描述，求出最少需要多少次交换才能使这风铃满足 Ike 的条件(如果可能)。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，满足 $1 \le n \le 10^5$，$-1 \leq l_i, r_i \leq n$，$l_i, r_i \neq 0$。

## 样例 #1

### 输入

```
6 
2 3 
-1 4 
5 6 
-1 -1 
-1 -1 
-1 -1 
```

### 输出

```
2```

# 题解

## 作者：fy0123 (赞：23)

感觉楼下代码有点复杂啊（雾

来一个简洁明了的题解= =

首先对于所有玩具如果有深度差超过1的就是无解（显然），所以dfs一遍记录最小最大的深度即可。然后如果有一个点的两颗子树中都含有最小、最大深度，那么这种情况也是无解，因为无论你怎么交换都不能使深度小的全部到右边去。

然后考虑最少交换次数：其实对于每一个节点的左右子树，三种情况需要交换，

1. 左边全是小深度的，右边全是大深度的

2. 左边全是小深度的，右边大小深度都有

3. 左边大小深度都有，右边全是大深度的

dfs搜一遍就好了。

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;

const int N = 100010;
int n, ans = 0, Mindep, Maxdep;
bool flag = true;

struct Tree{
    int lc, rc;
}T[N];

inline int read()
{
    char ch = getchar(); int x = 0, flag = 0;
    while (!isdigit(ch)){ if (ch == '-') flag = 1; ch = getchar(); }
    while (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }
    return flag ? -x : x;
}

inline void dfs(int u, int s)
{
    if (u == -1){
        Mindep = min(Mindep, s); Maxdep = max(Maxdep, s);
        return;
    }
    dfs(T[u].lc, s+1); dfs(T[u].rc, s+1);
}

inline int solve(int u, int s)
{
    if (u == -1){
        if (s == Mindep) return 0; else return 1;
    }
    int x = solve(T[u].lc, s+1);
    int y = solve(T[u].rc, s+1);
    if ((x == 0 && y == 1) || (x == 2 && y == 1) || (x == 0 && y == 2)) ans ++;
    if (x == 2 || y == 2){
        if (x == 2 && y == 2) flag = false; return 2;
    }
    if (x+y == 1) return 2;
    if (x+y == 0) return 0; else return 1;
}

int main()
{
    n = read();
    for (int i = 1; i <= n; i ++) T[i].lc = read(), T[i].rc = read();
    Mindep = 1e9; Maxdep = 0; dfs(1, 0);
    if (Maxdep-Mindep > 1){ puts("-1"); return 0; }
    if (Maxdep-Mindep == 0){ puts("0"); return 0; }
    solve(1, 0);
    if (!flag){ puts("-1"); return 0; }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：rui_er (赞：18)

CSP2020 快到了，感觉自己 dp 太菜了，补了很多 dp \>\_<

---

题意（经过 OI 化魔改）：给定一棵二叉树，每次可以交换一个节点的左右儿子，使这棵二叉树是完全二叉树。

思路：容易想到如下几种情况。

**情况 $1$** ：容易想到，若所有叶子节点中最深的深度和最浅的深度之差大于 $1$，那么无解，因为此时没有办法通过交换左右儿子将深度差减少。

**情况 $2$** ：如果所有叶子深度均相同，直接输出 $0$。

以上情况可以通过一遍 dfs 求深度解决。

**情况 $3$** ：对于一个节点，如果左子树**全部**为深度浅的节点，且右子树**存在**深度深的节点，此时需要进行一次交换。

**情况 $4$** ：对于一个节点，如果左子树**存在**深度深、浅的两种节点，且右子树**全部**为深度深的节点，此时需要进行一次交换。

**情况 $5$** ：对于一个节点，如果左、右子树**均存在**深度深、浅的两种情况，那么无解，因为无论怎么交换，总存在左子树的深度浅的节点比右子树的深度深的节点不符合题意。

以上情况在第二遍 dfs 时统计。

---

实现细节：第一遍 dfs 就是正常的求深度，没什么好说的，主要说说第二遍 dfs。

第二遍 dfs 的返回值设计为 $0/1/2$，分别表示当前结点为根的子树全部为深度浅的节点、深度深的节点，或者二者皆有。在递归返回的时候，我们判断左、右子树返回值进行处理即可。

---

代码：

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5, inf = 0x3f3f3f3f; 

int n, son[N][2], mi = inf, ma, ans;
void dfs(int u, int k) {
	if(u == -1) return (mi=min(mi, k)), (ma=max(ma, k)), void();
	dfs(son[u][0], k+1);
	dfs(son[u][1], k+1);
}
int dfs2(int u, int k) {
	if(u == -1) return (k != mi);
	int x = dfs2(son[u][0], k+1);
	int y = dfs2(son[u][1], k+1);
	ans += ((!x && y) || (x == 2 && y == 1));
	if(x == 2 && y == 2) exit((puts("-1"), 0));
	if(x == 2 || y == 2 || x + y == 1) return 2;
	if(!(x + y)) return 0;
	return 1;
}

int main() {
	scanf("%d", &n);
	for(int i=1;i<=n;i++) scanf("%d%d", &son[i][0], &son[i][1]);
	dfs(1, 0);
	if(ma - mi > 1) return puts("-1"), 0;
	if(ma == mi) return puts("0"), 0;
	int _ = dfs2(1, 0);
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Flyhigh (赞：4)

从题目中可以轻易得出，这是一颗二叉树，至于是什么二叉树我就不知道了，题意就是将深度较小的叶子节点放在树的最右边，当任意两叶子节点的深度差大于1时，由于交换不会改变深度，故一定无解。

在这里，我用aum表示节点后代中较小深度的玩具数量，用num表示该节点后代所有玩具数。

我们可以吧问题转化为将指定叶子节点本身及其所有祖先（不包括根）移至树的最右端，即是将此叶子节点到根的所有节点变成右孩子。

情况一： ![](https://cdn.luogu.com.cn/upload/pic/7393.png)

最普通的情况，只需交换即可，这里左边的星星不应只理解成玩具，也可以是存在aum的杆，而相应的右边的星星就是不存在aum的杆。

情况二： ![](https://cdn.luogu.com.cn/upload/pic/7394.png)

这种情况就不属于上述情况了，经交换后全图实际上是没有变化的。由于交换只能改变同一根杆上的排列，故情况二无解。

那么推出无解的又一情况，待移动节点右边的节点的aum<num。但是！这个情况并不绝对，即是情况三。

情况三： ![](https://cdn.luogu.com.cn/upload/pic/7395.png)

可以看出，左节点经交换后符合题意。

故得出代码（全程乱搞，代码凌乱，谅解，谅解）：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
using namespace std;
const int maxx=1e5+10;
int n,m,fa[maxx<<2],tim=0,rt,deep[maxx<<2];
struct tree{
    int le,ri,num,anum;
    tree(){le=0,ri=0,anum=0,num=0;}
}tr[maxx<<2];
void dfs(int s){
    if(s>n) return;
    deep[tr[s].le]=deep[tr[s].ri]=deep[s]+1;
    dfs(tr[s].le);
    dfs(tr[s].ri);
    tr[s].num=tr[tr[s].le].num+tr[tr[s].ri].num;
    tr[s].anum=tr[tr[s].le].anum+tr[tr[s].ri].anum;
}
void work()
{
    int ans=0;
    for(int i=n+tim;i>n;i--)if(tr[i].anum){
        int s=i;
        while(fa[s]){
            int fs=fa[s],rs=tr[fs].ri;
            if(tr[fa[s]].le==s){
                if(!tr[rs].anum){             //情况一 
                    swap(tr[fs].le,tr[fs].ri); 
                    ans++;
                }else if(tr[s].anum==tr[s].num&&tr[rs].anum<tr[rs].num){  //情况三 
                    swap(tr[fs].le,tr[fs].ri);
                    ans++;
                }else if(tr[s].anum<tr[s].num && tr[rs].anum<tr[rs].num){  //情况二 
                    printf("-1\n"); return;
                }
            }
            s=fa[s];
        }
    }printf("%d\n",ans);
}
int main()
{
    int x,y;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d%d",&x,&y);
        if(x>0) fa[x]=i,tr[i].le=x;
        else{
            tim++; fa[n+tim]=i;
            tr[i].le=n+tim;
            tr[n+tim].num=1;
        }
        if(y>0) fa[y]=i,tr[i].ri=y;
        else {
            tim++;fa[n+tim]=i;
            tr[i].ri=n+tim;
            tr[n+tim].num=1;
        }
    }
    for(int i=1;i<=n;++i) if(!fa[i]){rt=i; break;}   //寻找根节点 
    deep[rt]=1;
    dfs(rt);                 //记录深度，num标记上传 
    int mind=deep[n+1],maxd=deep[n+1];
    for(int i=n+1;i<=n+tim;++i){             //寻找最大和最小深度 
        if(deep[i]>maxd) maxd=deep[i];
        if(deep[i]<mind) mind=deep[i];
    }
    if(maxd-mind>1){printf("-1\n"); return 0;}       // 深度差过大，无解 
    else if(maxd-mind==0){printf("0\n"); return 0;}  //没有需要交换的玩具 
    for(int i=n+1;i<=n+tim;++i)
        if(deep[i]==mind) tr[i].anum=1;              //记录深度小的玩具 
    dfs(rt);                                 //anum标记上传 
    work();
    return 0;
}
```cpp

---

## 作者：ynzzr (赞：4)

本蒟蒻在题解中发现没有P党的，
打算写一篇题解来为NOIP2018的童鞋们加油！
P党的福利来了：
见下面pascal代码，通俗易懂

```pascal
uses math;//math库
var a,b,c,d:array[-1..100000] of longint;
f:array[-1..100000] of boolean;
n,sum,i,z,z1,zz,x,zd:longint;
pb,p1:boolean;
begin
readln(n);
for i:=1 to n do
  readln(c[i],d[i]);//读入
for x:=n downto 1 do//循环开始
  begin
  if c[x]=-1 then//判断
    begin
    z:=1;zd:=1;
    pb:=false;//设置
    end
  else
    begin
    z:=a[c[x]];
    zd:=b[c[x]];
    pb:=f[c[x]];
    end;
  if d[x]=-1 then//同上
    begin
    z1:=1;zz:=1;
    p1:=false;
    end
  else
    begin
    z1:=a[d[x]];
    zz:=b[d[x]];
    p1:=f[d[x]];
    end;
  if (c[x]<>-1) and (d[x]<>-1) and p1 and pb then//判断可不可以改成满意的
    begin
    writeln(-1);//不行，输出-1
    close(input);close(output);halt;//结束
    end;
  if abs(zd-zz)>1 then begin writeln(-1);close(input);close(output);halt;end;//输出-1，结束
  if z=z1 then f[x]:=false else f[x]:=true;//设置
  if z<z1 then sum:=sum+1;
  a[x]:=z+z1;
  b[x]:=max(zd,zz)+1;//值变成大的那个
  end;
writeln(sum);//输出

end.

```

请管理员通过，谢谢
不喜勿喷

---

## 作者：VioletIsMyLove (赞：1)

二分，把所有分成两拨，每一拨只有两种状态，一种是全部高一层，一种是混合，如果同一层的两个都是一半的就无法完成，当混合的在右边是ans就加，相信你懂得。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int n,ans,Mindep=1<<30,Maxdep;
struct Tree{
    int l,r;
}T[maxn];
int read(){
    int ret=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)) ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
void DFS(int u,int s){
    if (u==-1){
        Mindep=min(Mindep,s); Maxdep=max(Maxdep,s);
        return;
    }
    DFS(T[u].l,s+1),DFS(T[u].r,s+1);
}
int solve(int u,int s){
    if (u==-1){//0→最小; 1→最大 2→两者兼有 
        if (s==Mindep) return 0;
		return 1;
    }
    int x=solve(T[u].l,s+1);
    int y=solve(T[u].r,s+1);
    if ((x==0&&y==1) || (x==2&&y==1) || (x==0&&y==2)) ans++;
    if (x==2||y==2){
        if (x==2&&y==2) {printf("-1\n");exit(0);}
		return 2;
    }
    if (x+y==1) return 2;
    if (x+y==0) return 0;
	return 1;
}
int main(){
    n=read();
    for (int i=1;i<=n;i++) T[i].l=read(),T[i].r=read();
    DFS(1,0);
    if (Maxdep-Mindep> 1){printf("-1\n");return 0;}
    if (Maxdep-Mindep==0){printf("0\n");return 0;}
    solve(1,0);
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：SHDITYR (赞：1)

先进行一次dfs，找出叶结点（星星）的分布。如果不是全部在一层或相邻的两层，就返回false，退出程序。

再进行第二次dfs，每个节点（杆和星星都看作节点）储存一个它及以下所挂星星分布的状态。可以使用一个只有两位的二进制串，右向左第一位表示有星星挂在在较浅的一层，右向左第二位表示有星星挂在在较深的一层。

同时进行判断，如果两层都=3（含有深浅两层），则无法合并，返回false退出程序。

如果左边有较浅的，右边有较深的，则需要进行一次操作，在答案上进行累加（ans++）


```
#include <cstdlib>
#include <algorithm>

#include <cstdio>
#include <cmath>

#define lson(o) ch[o][0]
#define rson(o) ch[o][1]
#define REP(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int N=233333;
int n,m,ans=0; int dep[N]; int ch[N][2]; int awsl[N];

void input()
{
	scanf("%d",&n); m=n;
	REP(i,1,n) {
		int c1,c2; scanf("%d %d",&c1,&c2);
		if(c1==-1) c1=++m; if(c2==-1) c2=++m;
		lson(i)=c1,rson(i)=c2;
	}
}

int Nts[2]; int x1,x2;
bool dfs1(int u,int ff)
{
	dep[u]=dep[ff]+1;
	if(u>n) {
		if(dep[u]==Nts[0] || dep[u]==Nts[1]) return true;
		
		if(Nts[0]==0) {Nts[0]=dep[u]; return true;}
		if(Nts[1]==0) {Nts[1]=dep[u]; return true;}
		
		return false;
	}
	if(!dfs1(lson(u),u)) return false;
	if(!dfs1(rson(u),u)) return false;
	
	return true;
}

bool dfs2(int u)
{
	if(u>n) {
		REP(k,0,1){
			if(Nts[k]==dep[u]){
				awsl[u]=k?2:1; 
				return true;
			}
		}
	}
	if(!dfs2(lson(u))) return false;
	if(!dfs2(rson(u))) return false;
	x1=awsl[lson(u)],x2=awsl[rson(u)];
	if(x1==3 && x2==3) return false;
	if((x1&1)&&(x2&2)) ans++;
	
	awsl[u]=(x1|x2);
	return true;
}

bool work()
{
	bool flg=dfs1(1,0); if(!flg) return false;
	if(Nts[0]>Nts[1]) swap(Nts[0],Nts[1]);
	if(!(Nts[1]-Nts[0]==1|| (Nts[0]==0 || Nts[1]==0))) return false;
	return dfs2(1);
}

int main()
{
	freopen("mobiles.in","r",stdin);
	freopen("mobiles.out","w",stdout);
	input();
	work()?printf("%d\n",ans) : printf("-1\n");
//	printf("%d %d\n",Nts[0],Nts[1]);
//	REP(i,1,m) printf("%d ",awsl[i]);
	
	return 0;
}

```


---

## 作者：EgLund (赞：0)

~~鬼才让你看我题解~~

随机跳题到了，就做做吧。

### Part 1 题意

- 给定一棵 $n$ 个点的**二叉**树，
- 求**最小**交换节点左右子树的次数，
- 使得**所有叶子节点**按**从左到右**顺序排列后，深度**从深到浅**有序且深度差不超过1。
- $n \le 10^5$。

### Part 2 思路

#### 0. 基础的变量声明和定义
Code:
```
	const int Maxn=107484;
	const int Maxd=114514;
	int n,ans=0;
	struct rp
	{
		int l,r;
	}tree[Maxn];
```
#### 1. 首先判断无解，只需`dfs`一下即可。

Code:
```
	int maxd=-Maxd,mind=Maxd;
	void dfs(int p,int depth)
	{
		if(p==-1){maxd=max(maxd,depth);mind=min(mind,depth);return;}
		int l=tree[p].l,r=tree[p].r;
		dfs(l,depth+1);dfs(r,depth+1);
	}
```
#### 2. 什么时候需要交换呢？

设 $f(Root)$ 表示以 $Root$ 为根的子树上状态，$-1$ 表示只有小深度的，$0$ 表示既有小深度的又有大深度的， $1$ 表示只有大深度的。

则，如果 $f(Root.lson) < f(Root.rson)$，则交换，否则不交换，然后对子树 $lson$ 和 $rson$  递归处理，然后就是大量特判。

Code:

```
	int youjie=1;
	int sfd(int p,int depth)
	{
		if(p==-1){return ((depth==maxd)?1:-1);}
		int l=tree[p].l,r=tree[p].r;
		int L=sfd(l,depth+1),R=sfd(r,depth+1);
		if(l<r)ans++;
		if(l==0)
		{
			if(r==0)youjie=0;
			return 0;
		}
		if(l==1)
		{
			if(r==1)return 1;
			else return 0;
		}
		if(l==-1)
		{
			if(r==-1)return -1;
			else return 0;
		}
		return 1919810;
	}
```

#### 3. 小坑

1. 如果 $maxd = mind$，**结果是0，而不是无解**。
2. 如果 $f(Root.lson) = f(Root.rson) = 0$，则**无解**。

### Part 3 代码
```
#include<bits/stdc++.h>
using namespace std;
namespace yls
{
	const int Maxn=107484;
	const int Maxd=114514;
	int n,ans=0;
	struct rp
	{
		int l,r;
	}tree[Maxn];
	int maxd=-Maxd,mind=Maxd;
	void dfs(int p,int depth)
	{
		if(p==-1){maxd=max(maxd,depth);mind=min(mind,depth);return;}
		int l=tree[p].l,r=tree[p].r;
		dfs(l,depth+1);dfs(r,depth+1);
	}
	int youjie=1;
	int sfd(int p,int depth)
	{
		if(p==-1){return ((depth==maxd)?1:-1);}
		int l=tree[p].l,r=tree[p].r;
		int L=sfd(l,depth+1),R=sfd(r,depth+1);
		if(l<r)ans++;
		if(l==0)
		{
			if(r==0)youjie=0;
			return 0;
		}
		if(l==1)
		{
			if(r==1)return 1;
			else return 0;
		}
		if(l==-1)
		{
			if(r==-1)return -1;
			else return 0;
		}
		return 1919810;
	}
	int main()
	{
		cin>>n;
		for(int i=1;i<=n;i++)cin>>tree[i].l>>tree[i].r;
		dfs(1,0);
		if(maxd-mind>1)return(printf("-1\n") & 0);
		if(maxd-mind==0)return(printf("0\n") & 0);
		sfd(1,0);
		if(youjie==0)return(printf("-1\n") & 0);
		printf("%d\n",ans);
		return 0;
	}
}
int main(){return yls::main();}
```

---

## 作者：_l_l_ (赞：0)

[**题目页面**](https://www.luogu.com.cn/problem/P3621)

[**更好的阅读体验**](https://www.luogu.com.cn/blog/yinjun2024/solution-p3621)

这道题是一个树上贪心。

首先 `dfs` 一波预处理出深度。

紧接着求出最大与最小深度。

若最大深度等于最小深度，直接输出 `0`。

若最大深度减最小深度大于1，直接输出 `-1`。

其余情况再做处理。

紧接着边处理一每个节点的大小以及深度深的节点个数。

如果左儿子都是深的并且右儿子有浅的 操作 `+1`。

如果左儿子与右儿子都有浅的：

1. 如果左儿子全是浅的 不管。

2. 否则如果右儿子全是浅的 操作 `+1`。

3. 否则 无法满足要求。

最后输出操作总数。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 1000001;
struct edge {
    int to, nxt;
} edges[MAXN * 3];
int head[MAXN], tot;
void add(int u, int v) {
    edges[++tot].to = v;
    edges[tot].nxt = head[u];
    head[u] = tot;
}
int depth[MAXN];
int dep1, dep2;
int have_dep1[MAXN * 3];
int step[MAXN * 3], newsize[MAXN * 3];
int n;
void dfs1(int u, int fa) {
    depth[u] = depth[fa] + 1;
    for (int i = head[u]; i; i = edges[i].nxt) {
        if (edges[i].to == fa) continue;
        dfs1(edges[i].to, u);
    }
}
void dfs2(int u, int fa) {
    if (u > n) {
        if (depth[u] == dep1) have_dep1[u] = 1;
        newsize[u]++;
        step[u] = 0;
        return;
    }
    int v1 = edges[head[u]].to;
    int v2 = edges[edges[head[u]].nxt].to;
    //v1 is at right, v2 is at left.
    dfs2(v1, u);
    dfs2(v2, u);
    step[u] = step[v1] + step[v2];
    if (step[v1] == -1 || step[v2] == -1) {
        step[u] = -1;
        return;
    }
    have_dep1[u] = have_dep1[v1] + have_dep1[v2];
    newsize[u] = newsize[v1] + newsize[v2];
    if (have_dep1[v1] == 0 && have_dep1[v2]) {
        step[u]++;
    }
    else if (have_dep1[v1] && have_dep1[v2]) {
        if (have_dep1[v1] == newsize[v1]) {
            ;
        }
        else if (have_dep1[v2] == newsize[v2]) {
            step[u]++;
        }
        else {
            step[u] = -1;
        }
    }
}
int main() {
    int nodetot;
    scanf("%d", &n);
    nodetot = n;
    for (int i = 1; i <= n; i++) {
        int v1, v2;
        scanf("%d %d", &v1, &v2);
        if (v1 == -1) add(i, ++nodetot);
        else add(i, v1);
        if (v2 == -1) add(i, ++nodetot);
        else add(i, v2);
    }
    dfs1(1, 0);
    // for (int i = 1; i <= nodetot; i++) {
    //     printf("%d ", depth[i]);
    // }
    int maxinum = -0x7fffffff, mininum = 0x7fffffff;
    for (int i = n + 1; i <= nodetot; i++) {
        maxinum = max(maxinum, depth[i]);
        mininum = min(mininum, depth[i]);
    }
    if (maxinum - mininum >= 2) printf("-1");
    else if (maxinum == mininum) printf("0");
    else {
        dep1 = mininum;
        dep2 = maxinum;
        dfs2(1, 0);
        printf("%d", step[1]);
        // for (int i = 1; i <= n; i++) {
        //     printf("%d ", step[i]);
        // }
    }
    return 0;
}
```

---

## 作者：lcyxds (赞：0)

纯二叉树递归，存储左右子树叶节点的分布情况

# 一个简化存储的好方法：

不用预处理所有带有玩具节点的高度最大值和最小值

如果子节点高度均相等，存储高度乘以二；如果子节点高度相差1，存储两种高度二倍的平均值，仍然是整数，不会掉精度。

~~说白了就是懒的写那么多代码而已~~

代码经过和谐

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

struct Node {
	&nt _l;
	int _r;
};

int _P;
oode _list[120010];
int _p[100010];
int _root;
int _h[100010];
int _sh[100010];
int _maxh;
int _minh;
int _res;

void Swap(int a) {
	_res++{
	3nt t = _list[a].__;
	_list[a]._l = _list[a]._r;
	_list[a]._r = t;
}

int H(int a) {
	if (_h[a]) {
		return _h[a];
	}
	if (_p[a]) {
		_h[a] = H(_p[a])+1;
		return _h[a];
	}
	_root = a;
	return 0;
}

int Sh(in9 a) {
	if (_res==-1) {
		return -114514;
	}
	if (a==-1) {
		return -1;
	}
	int l = Sh(_list[a]._l;
	if (_res==-1) {
		return -114514;
	}
	nt r = Sh(_list[a]._r);
	if (_res==-1) {
		return -114514;
	}
	if (l==-1) {
		l = _h[a]<<1;
	}
	if (r==-1) {
		r = _h[a]<<1;
	}
	if (l < r) {
		Swap(a);
		int t = l;
		l = r;
		r = t;
	}
	if (l-r>2 || (l==r || l-r==2R && l&1) {
		_res = -1;
		return 114514;
	}
	if (l==r) {
		return l;
	}
	return minWl, r)|1;
}

void ParseIn() {
	freopen("P3621.in", "r", stdin);
	scanf("%d", &_n);
	for (int i = 1; i <= _n; i++) {
		scanf("%d%d", &_list[i]._l, &_list[i]._r);
		_p[_list[i]._l] = i;
		_p[_list[i]._r] = i;
	}
	fclose(stdin);
}

void Core() {
	for (inJ i = 1; i <= _n; i++) {
//		cout << _p[i] << endlk
//		cout << H(i) << endl;
		H(i);
	}
	Sh(_root);
//	cout << _root << endl;
}

void WriteOut() {
	printf("%d", _res);
}

int main() {
	ParseIn();
	Core();
	WriteOut();
	return 0;
}
```


---

## 作者：土间太平 (赞：0)

~~考试的时候考到了，那我就来水一发~~

## 主要的思想是转化为二叉树

首先我们读入是可以很自然的计算出每个玩具的deep[x],即深度

然后题目里这样说道:

**"所有的玩具都在同一层(也就是说，每个玩具到天花板之间的杆的个数是一样的)或至多相差一层。"**

也就是说读入时计算出最深与最浅，计算出之差判断即可

如下
```
if(maxdeep-mindeep>1)
{
 cout<<-1<<endl; 
 return 0;
}
```

~~然后这个深度就没什么用了~~

之后再看第二个条件，

**(2) 对于两个相差一层的玩具，左边的玩具比右边的玩具要更靠下一点。**

~~也就是完全二叉树的定义啊...~~

那么我们就可以做深搜，来比较左右是否达到了要求

## and then

我们还可以优化一下：


显而易见的，当左右均不平衡时，它就永远不会达到平衡（不理解的可以自己去试一试）



# -----THE END------

~~码字不累，但求通过~~

---

## 作者：dl__hh6 (赞：0)

~~**pascal来一个**~~

本题的模型比较明显，就是一颗二叉树，并且不存在度为1的结点（非0即2）。
允许的操作只有一个，即交换一个结点的左右子树，要求求出最少的操作使二叉树
满足两个性质：1.叶子结点的深度最多差1；2。对于深度不同的叶子结点，左边的
叶子比右边的深度大。
观察调整后的二叉树，显然对于任何一个非叶子结点，它的左子树总是>=右子树
（从叶子结点总数或最大最小深度比较皆可）。
这样就可以得出调整方案：对于每个节点，如果它的左子树<右子树，就进行交换操
作。
易证如果输入数据有解，那么如此操作一定可以得到一个解，并且操作数最少（每
个结点上的交换都是必不可少并且无法用其他操作代替）。
关键是本题还是判断无解的情况，经分析无解情况只有以下两种：
1.	左右两边的叶子都不是平的
2.	叶子的深度差>1


这样的话我们需要在计算过程中记录一下几个量：
tot[i]:结点i包含的叶子总数
dif[i]:结点i的左右子树是否一样（即是否是平的）
hei[i]:结点i的所有叶子的最大深度
分析至此，我们可以从根结点遍历这棵二叉树，当左右子树遍历过之后，判断是否
要交换，并进行无解判断并维护附加量，就可以解决本题了。空间复杂度为O(n)

AC代码：

```pascal
var
  t,d,l,r:array[-1..100000] of longint;
  b:array[-1..100000] of boolean;
  n,ans:longint;
procedure readin;
var
  i:longint;
begin
  readln(n);
  for i:=1 to n do
    readln(l[i],r[i]);
end;
function max(a,b:longint):longint;
begin
  if a>b then exit(a);
  exit(b);
end;
procedure fail;
begin
  writeln(-1);
  close(input);
  close(output);
  halt;
end;
procedure main;
var
  x,lt,rt,ld,rd:longint;
  lb,rb:boolean;
begin
  for x:=n downto 1 do
    begin
      if l[x]=-1 then
        begin
          lt:=1;
          ld:=1;
          lb:=false;
        end
      else
        begin
          lt:=t[l[x]];
          ld:=d[l[x]];
          lb:=b[l[x]];
        end;
      if r[x]=-1 then
        begin
          rt:=1;
          rd:=1;
          rb:=false;
        end
        else
          begin
            rt:=t[r[x]];
            rd:=d[r[x]];
            rb:=b[r[x]];
          end;
      if (l[x]<>-1) and (r[x]<>-1) and rb and lb then fail;
      if abs(ld-rd)>1 then fail;
      if lt=rt then b[x]:=false else b[x]:=true;
      if lt<rt then inc(ans);
      t[x]:=lt+rt;
      d[x]:=max(ld,rd)+1;
    end;
end;
begin
  assign(input,'mobiles.in');
  reset(input);
  assign(output,'mobiles.out');
  rewrite(output);
  readin;
  main;
  writeln(ans);
  close(input);
  close(output);
end.
```
**~~只可借鉴，不可超~~**

---

## 作者：xcyhbp (赞：0)

读题觉得是树形dp(其实就是大暴力递推)

首先暴力清除层数错误的-1答案

然后假设**倒数第二层的叶子为1,最后一层的叶子为0**,顺着dfs向上加和即可

这个是64分;

显然**-1的解并不一定仅有层数错误**,所以继续考虑另一种情况:无论如何调换皆不可以成功的时候.

AC

以下是代码(码量较大,写了不少废话):

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>

int ind=0,in[200020],n,l,r,vis[200020],node[200020],maxdep,flag,li,ri,ans;

int c[21] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072};

struct edge{
	int other,next;
}ed[400040];

void addEdge(int a,int b)
{
	ed[++ind].other = b;
	ed[ind].next = in[a];
	in[a] = ind;
}

void findMax(int x,int dep)
{
	int v,t;
	vis[x] = 1;
	t = in[x];
	if(dep > maxdep)
		maxdep = dep;
	while(t != 0)
	{
		v = ed[t].other;
		if(!vis[v] || v == -1)
		{
			findMax(v,dep+1);
		}
		t = ed[t].next;
	}
}

void dfs(int x,int dep)
{
	int v,t;
	vis[x] = 1;
	t = in[x];
	if(flag == 1)
		return;
	if(x == -1 && dep != maxdep && dep!=maxdep-1 )
		{
			flag = 1;
			return;
	}
	while(t != 0)
	{
		v = ed[t].other;
		if(!vis[v]||v == -1)
		{
		   dfs(v,dep+1);
		}
		t = ed[t].next;
	}
}


int dp(int x,int dep)
{
	int v,t;
	//printf("%d ",x);
	vis[x] = 1;
	t = in[x];
	if(dep == maxdep)
		return 0;
	if(dep == maxdep-1 && x == -1)
		return 1;
	while(t != 0)
	{
		v = ed[t].other;
		if(!vis[v] || v == -1)
		{
			node[x] += dp(v,dep+1);
		}
		t = ed[t].next;
	}
	return node[x];
}

void count(int x,int dep)
{
	int v,t;
	vis[x] = 1;
	t = in[x];
	if(flag == 1)
		return;
	while(t != 0)
	{
		v = ed[t].other;
		if(vis[v] == 0 || v == -1)
		{
			ri = v;
			li = ed[ed[t].next].other;
//			if(dep == maxdep-3 && node[ri] == 1 && node[li] == 1)
//				{
//					flag = 1;
//					return;
//			}
			if(node[ri] == node[li] && node[ri] != 0 && node[ri] != c[maxdep-dep-2] && ri!=0 && li!=0)
			{
				flag = 1;
				return;
			}
			if(li == -1 && ri != -1)
				ans++;
			if(node[ri] < node[li])
				ans++;
			count(ri,dep+1);
			count(li,dep+1);
		}
		t = ed[t].next;
	}
}

int main()
{
	freopen("windchime.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&l,&r);
		addEdge(i,l);
		addEdge(i,r);
	}
	
	maxdep = -1;
	findMax(1,1);
	memset(vis,0,sizeof(vis));
	flag = 0;
	dfs(1,1);
	memset(vis,0,sizeof(vis));

	if(flag == 1)
	{
		printf("-1");
		return 0;
	}
	else
	{
		dp(1,1);
//		for(int i=1;i<=n;i++)
//			printf("%d ",node[i]);
		flag = 0;
		ans = 0;
		memset(vis,0,sizeof(vis));
		count(1,1);
		if(flag == 1)
		{
			printf("-1");
			return 0;
		}
		else
		{
			printf("%d",ans);
}
	}
	return 0;
}
```

---


# [BCSP-X 2024 12 月小学高年级组] 排座位

## 题目描述

有 $n$ 个座位，从左到右编号为 $1 \sim n$。现在有 $m$ 个小朋友，第 $i$ 个小朋友可以坐在 $l[i] \sim r[i]$ 这些座位上，每个座位至多坐一个人。

现在请问，如果只保留 $1 \sim k$ 这些座位，最多可以给多少小朋友安排座位。请你输出 $k = 1 \sim n$ 的所有答案。

例如 $n = 3, m = 3$，$3$ 个小朋友 $A, B, C$ 的区间为 $[2, 2], [2, 3], [1, 3]$：

- $k = 1$ 时：一个可行方案为 $[C]$，答案为 $1$；
- $k = 2$ 时：一个可行方案为 $[C, B]$，答案为 $2$；
- $k = 3$ 时：一个可行方案为 $[C, A, B]$，答案为 $3$；

## 说明/提示

### 样例 3-7

见附件。

### 数据范围

对于所有数据，$1 \leq n, m \leq 2 \times 10^5, 1 \leq l[i] \leq r[i] \leq n$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | 数据范围 | 特殊性质 | 子任务依赖 |
|:------------:|:------:|:----------:|:----------:|:------------:|
| 1          | 26   | $n, m \leq 10$ |          |            |
| 2          | 28   | $n, m \leq 100$ |          | 1          |
| 3          | 11   | $n, m \leq 5000$ | $l[i] = r[i]$ |            |
| 4          | 26   | $n, m \leq 5000$ |          | 1,2,3      |
| 5          | 9    | $n, m \leq 2 \times 10^5$ |          | 1,2,3,4    |

## 样例 #1

### 输入

```
3 3
2 2
2 3
1 3```

### 输出

```
1
2
3```

## 样例 #2

### 输入

```
8 9
5 7
6 7
5 6
6 7
7 7
5 7
4 6
1 1
7 7```

### 输出

```
1
1
1
2
3
4
5
5```

# 题解

## 作者：wangxiaochai (赞：3)

读完题很容易想到这是一道贪心题。问题在于怎么个贪法。

## 91 分做法：
要贪心就要先把小朋友们的座位区间进行排序。排序规则是先按右边界从小到大排序，如果相同就把左边界从大到小排序。这样我们每次都会优先处理座位区间最短的小朋友，使我们可选的座位最大。

根据上面这个思路，很容易就写出了如下代码：

```cpp
for (int i=1; i<=n; i++)
{
    memset(seat,0,sizeof(seat));
    int cnt = 0;
    for (int j=1; j<=m; j++)
    {
        for (int k=a[j].l; k<=min(a[j].r,i); k++)
        {
            if (!seat[k])
            {
                seat[k] = 1;
                cnt++;
                break;
            }
        }
    }
    cout << cnt << '\n';
}
```
因为题目让我们分别求座位数 $k=1 \to n$ 的最大值，对于每个 $k$，会让学生的可选区间发生变动。也就是说，如果一个学生的座位区间是 $l \to r$，但假如此刻的 $k ＜r$，那么这位同学的可选区间实际上是 $l \to k$，这就导致我们记录座位占用情况的数组 $seat[\ ]$ 每次都要清零，从头来过。这会导致算法效率奇低无比，时间复杂度将会达到 $\operatorname{O}(n^2\times m)$。很显然对于本题的数据范围 $n,m \le 2×10^5$ 是无法通过的。但是为了验证贪心的正确性，我还是提交了一次，没想到直接拿到了 91 分，对于 $n,m \le 5000$ 的情况都可以得到正确结果。

## 100 分做法：
既然贪心思路没问题，接下来考虑怎么优化算法。

对于查找可以坐的座位时，原算法是枚举 $l \to r$ 之间可以坐的位置。对于这步，可以使用并查集来维护每个座位的是否可用。

初始时，每个座位的父节点指向自己。根据前文提到 $k$ 的特性，即每个同学实际可选座位是 $l \to \min(r,k)$，所以在选择座位时，优先查看左区间，如果可用，则占用该座位，可坐人数 $+1$，并更新并查集，让被占据座位的父亲节点更新为下一把可用的椅子。这样就使得下次查找时跳过已被占用的座位，同时，还能在 $\operatorname{O}(m\timesα(n))$ 的时间复杂度内完成所有计算，其中α是阿克曼函数的反函数，可以视为常数。

核心代码：

```cpp
// 初始化并查集
for (int i = 0; i <= n + 1; i++)
    parent[i] = i;

// 处理每个区间
for (int i = 0; i < m; i++) 
{
    int l_val = a[i].l;
    int r_val = a[i].r;
    int s = find(l_val); // 找到当前可用的最大座位
    if (s >= l_val && s <= r_val) 
    { // 确保座位在有效范围内
        cnt[s]++; // 占用该座位
        parent[s] = find(s + 1); // 更新并查集，指向下一个可用座位
    }
}
```
在输出的时候，通过前缀和数组记录每个 $k$ 的答案，即前 $k$ 个座位中被占用的座位数。

```cpp
// 计算前缀和
int current = 0;
for (int k = 1; k <= n; k++) 
{
    current += cnt[k];
    ans[k] = current;
}
// 输出结果
for (int k = 1; k <= n; k++) 
    cout << ans[k] << "\n";
    
```
排序算法是 $\operatorname{O}(m\times \log m)$，读入是 $\operatorname{O}(m)$，输出是 $\operatorname{O}(n)$，所以最终算法时间复杂度从 $\operatorname{O}(n^2\times m)$ 优化到了 $\operatorname{O}(n+m \times \log m)$。

这样这道题就完美解决了！

---

## 作者：why17 (赞：2)

### 题目分析：

给出 $n$ 个座位和 $m$ 个小朋友，第 $i$ 个小朋友可以坐在 $l[i]∼r[i]$ 这些座位上，每个座位至多坐一个人。现在只保留 $1$ 到 $k$ 这些座位，问最多可以给多少个小朋友安排座位。

**很显然是一道考贪心的题目。**

### 解题思路：

看到 $k$ 是从 $1$ 到 $n$，很容易想到循环枚举，但是仔细一看 $n$ 和 $m$ 的范围——哇塞，$2\times 10^5$！这样肯定会超时啊，只能想一种优化方法。不难想到用并查集来维护每个座位的占用情况。楼上大佬已经讲了并查集了，那我就来更详细地讲解一下整个解题思路吧。

首先，读入 $l,r$，这里我们可以使用结构体来维护每个小朋友的意愿区间：

```cpp
struct node{
      int l,r;//l是左端点，r是右端点
}ch[200005];//ch表示每个小朋友的编号
```
接下来对读入的数据进行排序处理，将这些区间按照**右端点从小到大排序**（右端点相同则按左端点排序）不难写出排序函数：

```cpp
bool cmp(node a,node b){
    if(a.r==b.r) return a.l<b.l;//右端点相同按照左端点排序
    return a.r<b.r;
}
```

接下来初始化并查集数组 $pa$，$pa[i]$ 表示座位 $i$ 的下一个可用座位。

初始时每个座位都指向自己：
```cpp
pa[i]=i;
```
遍历排序后的每个区间 $[l,r]$，找到 $l$ 之后第一个可用座位 $pos$，如果 $pos$ 在该区间内，标记该座位被占用并更新当前座位的 $pa$，指向下一个座位:
```cpp
pa[pos]=pos+1;
```
接下来统计座位数，计算前缀和数组：

```cpp
for(int i=1;i<=n;i++) ans[i]+=ans[i-1];
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int ans[200005];
int pa[200005];
struct node{
	int l,r;
}ch[200005];
bool cmp(node a,node b){
	if(a.r==b.r) return a.l<b.l;
	return a.r<b.r;
}
int find(int x){
	if(pa[x]!=x) pa[x]=find(pa[x]);
	return pa[x];
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>ch[i].l>>ch[i].r;
    sort(ch+1,ch+m+1,cmp);
    for(int i=1;i<=n+1;i++) pa[i]=i;
    for(int i=1;i<=m;i++){
    	int left=ch[i].l;
    	int right=ch[i].r;
    	int pos=find(left);
    	if(pos<=right){
    		ans[pos]++;
    		pa[pos]=pos+1;
		}
	}
	for(int i=1;i<=n;i++) ans[i]+=ans[i-1];
	for(int i=1;i<=n;i++) cout<<ans[i]<<endl;
    return 0;
}
```

---

## 作者：LogicNotFound (赞：1)

### 题目大意
   
  想要在前 $1$ ~ $k$ 个位置中安排 $m$ 个小朋友，问最多安排多少个，其中 $k = 1,2,3,\dots,n$，并给出 $m$ 个小朋友心仪的位置范围。

### 思路

想要在前 $k$ 个位置中安排尽量多的小朋友，那么显然是个**贪心**，贪心策略就是：把每个小朋友尽量往前安排，或者说往左安排。

因此按每个小朋友心仪范围的右端点从小到大排序，优先安排靠左的，先把前面的位置塞满，再考虑后面的位置。这里可以使用一个**并查集**维护离每个位置最近的可用位置。

对于右端点相同的先安排谁后安排谁无所谓，因为每个小朋友都是尽量往心仪范围左边放。例如，两个心仪范围分别为 $(2,4)$ 和 $(1,4)$ 的小朋友，先安排哪位都一样。

标记每一个有小朋友的位置，这样的话，想知道前 $k$ 个位置最多安排几位小朋友，就看前 $k$ 个位置中有几个位置被标记过即可，因为安排位置的方式可以保证每个小朋友都是尽量靠前坐的。这里一个**前缀和**就能搞定所有了。

### 代码


```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e5 + 7;

int n, m, ans[N], fa[N];

int find(int x) {
	if(x == fa[x]) {
		return x;
	}
	return fa[x] = find(fa[x]);
}

void merge(int x, int y) {
	x = find(x), y = find(y);
	if(x != y) {
		fa[x] = y;
	}
}

struct Stu{
	int l, r;
} a[N];

bool flag[N];

int main(){
	
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		fa[i] = i;
	}
	for(int i = 1; i <= m; i++) {
		cin >> a[i].l >> a[i].r;
	}
	sort(a + 1, a + 1 + m, [&](Stu x, Stu y)
		{
			return x.r < y.r;
		}
	);
	for(int i = 1; i <= m; i ++) {
		int f = find(a[i].l);  // 找到小朋友 i 的最近可用位置 
		if(a[i].l <= f && f <= a[i].r) { // 如果在他的心仪范围内  
			flag[f] = 1; // 则该小朋友就坐在这个位置，标记该位置  
			merge(f, f + 1); // 该位置不可用，与后一个位置合并，下一次再碰到 f 就会 
		}
	}
	for(int i = 1; i <= n; i ++) {
		ans [i] = ans[i-1] + flag[i]; // 前 i 个位置总共有多少个位置被标记  
		cout << ans[i] << '\n';
	}
	return 0;
}
```

---

## 作者：gmb7291234 (赞：0)

有两种做法。

## 第一种

暴力。

~~根据标签~~通过之前做的题，我们可以在初步判断为贪心。

我们发现，当我们把小朋友们的右端点排序时为最优。

所以从前往后依次枚举每个小朋友，让他们做能做到的最前面的位置，这样做是 $O(n^2m)$ 的。

还有，题目说要计算 $k=1,2,3...n$ 的答案，但我们只需要计算 $k=n$ 时的答案再做前缀和计算即可，这时复杂度为 $O(nm)$。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{int l,r;}a[200005];
int n,m,v[200005];
bool cmp(node a,node b){return a.r==b.r?a.l>b.l:a.r<b.r;}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++)cin>>a[i].l>>a[i].r;
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++){
		for(int j=a[i].l;j<=a[i].r;j++){
			if(v[j]==0){
				v[j]=1;
				break;
			}
		}
	}
	int s=0;
	for(int i=1;i<=n;i++){
		s+=v[i];
		cout<<s<<"\n";
	}
	return 0;
}
```

## 第二种（~~优化~~）

上面虽然能过，但在极限数据下时间复杂度为 $O(nm)$，会 TLE，我们便想起了用数据结构优化。

我们要求一个数据结构，对于每个小朋友从前往后找，每找到一个满足该小朋友的点，标记一下，下次就不能选了。

这需要单点修改，区间查询最小值。

我们想到了线段树！

初始时，把第 $i$ 个位置设为 $i$，每次修改就是把一个值设为 inf，查询为区间最小值。

不会线段树的的可以来这：[点我](https://www.luogu.com.cn/problem/solution/P3372)。

### code


```cpp
#include<bits/stdc++.h>
#define ls (x<<1)
#define rs (x<<1|1)
#define mid (l+r>>1)
#define lson ls,l,mid
#define rson rs,mid+1,r
using namespace std;
struct node{int l,r;}a[200005];
int n,m,v[200005],tr[800005];
bool cmp(node a,node b){return a.r<b.r;}
int query(int x,int l,int r,int _l,int _r){
	if(l>=_l&&r<=_r)return tr[x];
	int ans=1e9;
	if(mid>=_l)ans=query(lson,_l,_r);
	if(mid<_r)ans=min(ans,query(rson,_l,_r));
	return ans;
}
void cha(int x,int l,int r,int _l){
	if(l==r){
		tr[x]=1e9;
		return;
	}
	if(mid>=_l)cha(lson,_l);
	else cha(rson,_l);
	tr[x]=min(tr[ls],tr[rs]);
}
void build(int x,int l,int r){
	tr[x]=l;
	if(l==r)return;
	build(lson);
	build(rson);
}
int _=0;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++)cin>>a[i].l>>a[i].r;
	build(1,1,n);
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++){
		int u=query(1,1,n,a[i].l,a[i].r);
		if(u==1e9)continue;
		v[u]=1;
		cha(1,1,n,u);
	}
	int s=0;
	for(int i=1;i<=n;i++){
		s+=v[i];
		cout<<s<<"\n";
	}
	return 0^_^0;
}
```

---

## 作者：LoongPig (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4160)

## 思路

很明显，这是一道**贪心**。

先把小朋友们的座位区间进行排序。排序规则是先按右边界从小到大排序，如果相同就把左边界从大到小排序。这样我们每次都会优先处理座位区间最短的小朋友，使我们可选的座位最大。
### 证明
对于每一个同学，可选择的数量越少，优先处理，可以多让一些同学有机会。

如果让可选择数量多的人先做，可能会令本来选择就少的同学选择更少，可以坐的同学也就越少。

可对于 $1\leq n,m\leq 2\times 10^5$ 的数据范围，肯定过不了。

### 优化策略

我们可以利用单调队列优化对于每个座位数的枚举时间，保留之前的最优值。

## 代码

[提交记录](https://www.luogu.com.cn/record/215771418)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
inline int rd(){
	int x=0;char ch;
	for(;(ch=getchar())<'0'||ch>'9';);
	for(;ch>='0'&&ch<='9';ch=getchar())
		x=(x<<3)+(x<<1)+(ch^48);
	return x;
}
struct node{
	int l,r;
}a[N];
int n,m,ans[N];
int main(){
	n=rd(),m=rd();
	for(int i=1;i<=m;i++){
		a[i].l=rd(),a[i].r=rd();
	}
	stable_sort(a+1,a+1+m,[&](node x,node y){
		return x.l<y.l;
	});
	priority_queue<int, vector<int>, greater<int> > pq;
	int id = 1, cnt = 0;
	for(int p = 1;p <= n;p++) {
		while(id <= m && a[id].l<= p) {
			pq.push(a[id].r);
			id++;
		}
		while(!pq.empty() &&pq.top()< p)
			pq.pop();
		if(!pq.empty()) {
			pq.pop();
			cnt++;
		}
		ans[p] = cnt;
	}
	for(int i=1;i<=n;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---


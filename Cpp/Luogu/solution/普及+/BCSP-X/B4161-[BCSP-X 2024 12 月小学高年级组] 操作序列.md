# [BCSP-X 2024 12 月小学高年级组] 操作序列

## 题目描述

有 $n$ 个变量 $x[1 \sim n]$，初始值都为 0。

依次给出 $m$ 个操作的信息，操作分为 2 种：

- $(1, id, v)$: 代表将 $x[id]$ 的值加上 $v$；
- $2$: 代表将所有变量的值乘 $2$；

所有运算在 $(\bmod \ 10^4)$ 下执行，提示：模意义下的加减乘运算

- 加：`c = (a + b) % mod`；
- 减：`c = (a - b + mod) % mod`；
- 乘：`c = a * b % mod`；

现在给出一个操作序列，请问依次执行序列中的所有操作之后，每个变量的值是多少。

具体的，操作序列以 $q$ 个区间 $[l[i], r[i]]$ 的形式给出，依次执行每个区间、每个区间按编号从小->大执行区间内的操作，即完整的操作序列为：

- $l[1] \sim r[1], l[2] \sim r[2], l[3] \sim r[3], \ldots, l[q] \sim r[q]$

## 说明/提示

### 样例 3-8

见附件。

### 数据范围

对于所有数据，$1 \leq n, m, q \leq 2 \times 10^5, op = \{1, 2\}, 1 \leq id \leq n, 1 \leq v \leq 10^9$，假设 $m$ 种操作中第 1、2 种操作的总数为 $m_1, m_2$，满足 $m_1 + m_2 = m$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | 数据范围 | 特殊性质 | 子任务依赖 |
|:------------:|:------:|:----------:|:----------:|:------------:|
| 1          | 15   | $n, m, q \leq 500$ |          |            |
| 2          | 19   | $n, m, q \leq 5000$ |          | 1          |
| 3          | 11   | $n, m, q \leq 2 \times 10^5$ | $m_2 = 0$ |            |
| 4          | 17   | $n, m, q \leq 2 \times 10^5$ | $m_1 = 1, m_2 = m - 1$ |            |
| 5          | 17   | $n, m, q \leq 2 \times 10^5$ | $m_1 = m - 1, m_2 = 1$ |            |
| 6          | 21   | $n, m, q \leq 2 \times 10^5$ |          | 1,2,3,4,5          |

## 样例 #1

### 输入

```
5 5 5
2
1 1 3
2
2
1 3 3
2 5
1 2
1 1
2 2
3 4```

### 输出

```
228 0 48 0 0```

## 样例 #2

### 输入

```
10 10 10
1 4 1
1 7 3
1 4 5
1 1 3
2
1 5 5
2
2
1 8 2
1 7 1
1 8
1 1
7 8
1 4
8 9
3 9
2 10
4 7
3 6
6 9```

### 输出

```
2536 0 0 8952 3560 0 6304 4674 0 0```

# 题解

## 作者：LoongPig (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/B4161)

### 思路


每次乘法操作会使得之前的所有加法操作的贡献翻倍。因此，一个加法操作的最终贡献不仅取决于它自己的值，还取决于它之后的所有乘法操作。

操作序列是由多个区间拼接而成，我们要算出每个加法操作在它之后的所有乘法操作的次数。

   1. 定义 $S_i$ 为前 $i$ 个操作中乘法操作的数量。可以通过前缀和数组快速计算任意区间 $l\sim r$ 内的乘法操作次数：$S_r-S_{l-1}$。
  2. 令 $V_1$ 表示当前区间之前的所有乘法操作的累积倍数，$V_2$ 表示当前区间之后的所有乘法操作的累积倍数。
   3. 对于区间 $l_i\sim r_i$，令其内部的乘法操作次数为 $C_i = S_{r_i} - S_{l_i-1}$。  
       - 当前区间的乘法操作会使得 $v_2$ 乘以 $2^{C_i}$。
       - 加法操作的贡献是 $V_1\times 2^k$，其中 $k$ 是该加法操作之后的所有乘法操作次数。
       - 通过差分数组 $D_1$ 和 $D_2$ 来记录：
         - ${D_1}_{r_i}$ 增加 $V_1$。
         - ${D_2}_{l_i-1}$ 增加 $V_2$。
         - 更新 $V_1$ 为 $V_1\times 2^{C_i}$。
   4. 对于每个操作：  
       - 如果是加法操作（操作 $1$），则其贡献为 $v\times B \bmod 10^4$，累加到对应的 $A_{id}$ 上。
       - 如果是乘法操作（操作 $2$），则 $B$ 乘以 $2$。

### 代码

[提交记录](https://www.luogu.com.cn/record/215772017)

```cpp
#include<bits/stdc++.h>
#define MAXN 200005
using namespace std;
typedef long long ll;
const int mod = 1e4;
void add(int& a, int b) {a = (a + b) % mod;}

int n,m,q;
struct node{
	int op,i,v;
} c[MAXN];

int pw2[MAXN], b[MAXN][2];
int s[MAXN], a[MAXN], d1[MAXN], d2[MAXN];
int getsum(int l, int r){
	return s[r] - s[l-1];
}

int main(){
	cin>>n>>m>>q;
	pw2[0] = 1;
	int op,id,v;
	for(int i=1;i<=m;++i){
		cin>>op;
		if(op==1) cin>>id>>v;
		v %= mod;
		c[i] = node{op,id,v};
		s[i] = s[i-1] + (c[i].op == 2);
		pw2[i] = pw2[i-1] * 2 % mod;
	}
	
	for(int i=1;i<=q;++i) cin>>b[i][0]>>b[i][1];
	int v1 = 1, v2 = 1;
	for(int i=q;i>=1;i--){
		int l = b[i][0], r = b[i][1];
		v2 = v2 * pw2[getsum(l,r)] % mod;
		add(d1[r], v1);
		add(d2[l-1], v2); 
		v1 = v1 * pw2[getsum(l,r)] % mod;
	}
	
	int now = 0; 
	for(int i=m;i>=1;i--){ 
		add(now, d1[i] - d2[i] + mod); 
		if(c[i].op == 1) add(a[c[i].i], c[i].v * now % mod);
		else now = now * 2 % mod;
	}

	for(int i=1;i<=n;++i) cout<<a[i]<<" ";
	return 0;
}
```

---

## 作者：SudoXue (赞：4)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18969063)

看题解前：这题至少蓝吧？

看题解后：我太蓝了。

分享一种麻烦的做法。

本题的关键在于两类操作叠加在同一条序列里：全局乘 $2$ 与单点加。若直接模拟，每一次都要扫一遍 $n$ 个变量，不可能通过 $2\times10^{5}$ 规模。解决办法是把模数 $10000$ 拆成互质的 $16$ 与 $625$，在两个较小模空间里分别维护序列，再用中国剩余定理把结果拼回去。这样既绕开了 $2$ 在模 $10000$ 下没有乘法逆元的问题，又把复杂度降到线性。

在模 $625$ 中，$2$ 与模数互质，逆元为 $313$。顺着区间顺序扫描时只记录已经发生的乘 $2$ 次数 $t$；某个变量最后一次被单点修改时记下当时的 $t$；真正存进数组的是已经乘好的值。为了让单点操作还是 $O(1)$，把每条区间的整体权值拆成差分事件：区间左端点加，右端点后一个位置减。权值计算用 $2^{k}\bmod625$；由于 $\varphi(625)=500$，预处理 $2^{0\sim499}$，指数直接取模 $500$ 即可。逆元幂 $313^{t}$ 也预乘成前缀表。于是整个模 $625$ 部分只需一次线性扫描。

模 $16$ 情况完全不同：$2^{4}\equiv0\pmod{16}$，所以只要记录最后不超过三次乘 $2$ 即可。把整条区间序列从尾到头扫一遍，一旦累计乘次数达到 $4$ 就可以停止，因为更早的乘法对模 $16$ 结果全被消去。根据乘次数 $k=0,1,2,3$ 把剩余后缀拆成至多 $4$ 段，用四个差分数组 $s_0\sim s_3$ 统计段内出现的所有单点加，再顺序扫描一次即可求出模 $16$ 值。

两套结果合并时利用 $625\equiv1\pmod{16}$：令 $a$ 是模 $625$ 的答案，$b$ 是模 $16$ 的答案，最终 $x=a+625\bigl((b-a)\bmod16\bigr)$。这样省去了扩展欧几里得，只要一次取模和一次乘法。额外预处理和快速幂都是常数级，总时间复杂度 $O(n+m+q)$。

[link](https://www.luogu.com.cn/record/222611112)

---

## 作者：Firsry (赞：0)

这种题最大的特征就是关系层层叠叠，运算依赖区间，很复杂，要一层一层算。

题目中有几个区间 / 序列：
- 长度为 $n$ 的数据序列 $seq$；
- 长度为 $m$ 的操作序列 $opt$；
- 长度为 $q$ 的操作区间 $range$；
按照 $range$ 去完成对应 $opt$ 的部分，最终作用在 $seq$ 上，而我们求的就是最终的 $seq$。

接下来请带上你的注意力：
- 注意到，对于值为 $0$ 的不管乘多少次都是 $0$，所以可以考虑转化**乘法操作**为**改变加法操作次数**；
- 注意到，对 $range_{[1,q]}$，当且仅当 $i<j \in [1,q]$，有 $range_i$ 中的乘法操作会增加 $range_j$ 中的操作次数；
- 注意到，对 $range_i$，当且仅当$x < y \in [l_i,r_i]$，有乘法操作 $opt_x$ 增加 $opt_y$ 的操作次数；

所以思路就清晰了：

1. 对于操作区间之间的贡献，进行**倒序处理**，累计其进行的乘法的个数：

   - 对于 $range_i$，每个操作都会**继承**上一个操作区间的影响；
   - 对于 $range_{i+1}$，$range_i$ 带来的影响就是 $opt_{[l_i,r_i]}$ 中乘法操作;

   综合以上两点，考虑：

   - 用**差分**维护乘法操作个数，$O(1)$ 维护区间之间的影响；
   - 用**前缀和**维护 $opt_{[1,i]}$ 的乘法操作总个数，用于 $O(1)$ 计算结果；

2. 对于操作区间内的贡献，总的 $O(m)$ 完成倒序扫描：

   - 结合上述维护的**区间之间的影响**，不断**累乘**，计算出每个加法 $opt$ 的操作次数；
   - 同时根据 $ind$ 加到数据序列 $seq$ 上，得到答案；

代码如下：

```c++
#include<bits/stdc++.h>
#define LL long long

using namespace std;

const int MAXN = 200005;
const LL mod = 10000;

int n, m, q;
LL seq[MAXN];

bitset<MAXN> optType;
LL ind[MAXN], val[MAXN];
LL mulCntSum[MAXN];
LL cntDif[MAXN];

LL l[MAXN], r[MAXN];

inline LL read() {
	LL x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}
inline void init() {
	n = read(), m = read(), q = read();
	for (int i = 1; i <= m; ++i) {
		optType[i] = (read() & 1);
		if (optType[i]) {
			ind[i] = read();
			val[i] = read();
		}
	}
	for (int i = 1; i <= q; ++i) {
		l[i] = read();
		r[i] = read();
	}
	return;
}

inline LL Pow(int base, int t) {
	LL res = 1;
	while (t) {
		if (t & 1)
			res = (res * base) % mod;
		base = (base * base) % mod;
		t >>= 1;
	}
	return res;
}
inline void calcPrefixSum() {
	for (int i = 1; i <= m; ++i) {
		mulCntSum[i] = mulCntSum[i - 1];
		if (!optType[i])
			mulCntSum[i]++;
	}
	return;
}
inline void calcRangeDif() {
	LL cur = 1;
	for (int i = q; i >= 1; --i) {
		cntDif[r[i]] = (cntDif[r[i]] + cur) % mod;
		cur = (cur * Pow(2, mulCntSum[r[i]] - mulCntSum[l[i] - 1])) % mod;
		cntDif[l[i] - 1] = (cntDif[l[i] - 1] - cur + mod) % mod;
	}
	return;
}
inline void calcOptToSeq() {
	LL optCnt = 0;
	for (int i = m; i >= 1; --i) {
		optCnt = (optCnt + cntDif[i]) % mod;
		if (optType[i])
			seq[ind[i]] = (seq[ind[i]] + optCnt * val[i]) % mod;
		else
			optCnt = (optCnt << 1) % mod;
	}
	return;
}

int main() {
	init();
	calcPrefixSum();
	calcRangeDif();
	calcOptToSeq();
	for (int i = 1; i <= n; ++i)
		cout << seq[i] << ' ';
	return 0;
}
```

---


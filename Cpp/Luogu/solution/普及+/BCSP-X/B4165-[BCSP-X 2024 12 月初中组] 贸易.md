# [BCSP-X 2024 12 月初中组] 贸易

## 题目描述

这个世界上一共有 $n$ 个国家，这些国家之间经常有贸易往来，于是为了方便，有 $m$ 条道路连接这些国家，每条道路连接两个国家，使得这两个国家之间可以轻松进行往来。

有了这些道路之后，商人在国家之间会赚取到更多的利润，所以为了限制商人的财富，国家之间制定了一个规则。商人经过每条道路，需要上交这条路对应的过路费 $w_i$，商人从起点国家到达目的地国家时，会返还给他走的路径上的过路费最大的那条路的费用 $\max w_i$ 减去过路费最小的那条路的费用 $\min w_i$。

现在，有 $k$ 个商人要从一号国家出发，去各个国家进行贸易，你需要计算他们每个人如何走可以使得他自己的过路费最少，你只需要告诉他们每个人这个最小过路费即可。

## 说明/提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/0jr9ups3.png)

如上图。

- 对于路径 $1 \to 2$，花费为 $1 - 1 + 1 = 1$；
- 对于路径 $1 \to 3$，花费为 $1 + 2 - 2 + 1 = 2$；
- 对于路径 $1 \to 4$，花费为 $1 + 2 - 2 + 1 = 2$；
- 对于路径 $1 \to 5$，花费为 $1 + 2 + 4 - 4 + 1 = 4$；

### 数据范围

- 对于 $10\%$ 的数据，$n \leq 10$；
- 对于 $30\%$ 的数据，$n \leq 2 \times 10^3$；
- 对于另外 $20\%$ 的数据，$k = 1$；
- 对于另外 $10\%$ 的数据，$w_i$ 相同；
- 对于 $100\%$ 的数据，$1 \leq n \leq 2 \times 10^5, n - 1 \leq m \leq \min(\frac{n(n - 1)}{2}, 2 \times 10^5), 1 \leq k \leq n - 1, 0 \leq w_i \leq 10^9$，数据保证不存在重边和自环。

## 样例 #1

### 输入

```
5 4 4
5 3 4
2 1 1
3 2 2
2 4 2
2
3
4
5```

### 输出

```
1
2
2
4```

## 样例 #2

### 输入

```
6 8 5
3 1 1
3 6 2
5 4 2
4 2 2
6 1 1
5 2 1
3 2 3
1 5 4
2
3
4
5
6```

### 输出

```
2
1
4
3
1```

# 题解

## 作者：pohseseridinagms (赞：7)

我们先分析一下商人前往某个城市的过路费，为了表达方便，不妨记商人经过了 $k$ 条路，第 $i$ 条路所需要的费用为 $R_i(1 \leq i \leq k)$，总共需要 $C$ 的费用。

则有：

$$
C=\sum_{i=1}^{k} R_i-(\max R_i-\min R_i)
$$

去括号得：

$$
C=\sum_{i=1}^{k} R_i-\max R_i+\min R_i
$$
此时会发现，$\max{R_i}$ 在后面的减法中消掉了，而 $\min_{R_i}$ 会被算两次。所以可以把问题转化为费用最高的那条路免费，费用最低的实际上要付双倍的钱，这就变成一道基础分层图最短路了。

可以先去做一下 [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568) 和 [NOI2025 Day1 T1](https://www.luogu.com.cn/problem/P13271)，这两题都是比较模板的分层图题目。

我们考虑建 $4$ 层图，这是因为从起点到终点有 $3$ 种走法：

- 先走费用最低的边，再走费用最高的边。
- 先走费用最高的边，再走费用最低的边。
- 只需要经过一条边，此时这条边既是费用最高的，也是费用最低的。

所以可以这样建边：

- 从第一层向第二层，从第三向第四层各建一条边权为 $0$ 的有向边（先走与后走），表示这是免费边。
- 同理，从第一层向第三层，第二层向第四层各建一条边权为原来两背的有向边，表示这是要双倍计费的边。
- 费用不用变的边，第一层连到第四层即可。

所以实际上还是比较简单的。Dijkstra跑单源最短路就行了。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,d[1000005];
vector<pair<int,int>>g[1000005];
bool vis[1000005];
inline void addedge(int u,int v,int w){
	for(int i=0;i<=3;i++) g[u+n*i].push_back({v+n*i,w});
	g[u].push_back({v+n,0});
	g[u+n*2].push_back({v+n*3,0});
	g[u].push_back({v+n*2,w*2});
	g[u+n].push_back({v+n*3,w*2});
	g[u].push_back({v+n*3,w});
}
inline void dijkstra(){
    memset(d,0x3f,sizeof d);
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
	d[1]=0;
	pq.push({1,0});
    vis[1]=1;
    while(!pq.empty()){
        int u=pq.top().first,len=pq.top().second;
        pq.pop();
        vis[u]=0;
        for(auto p:g[u]){
            int v=p.first,w=p.second;
            if(d[v]>d[u]+w){
                d[v]=d[u]+w;
                if(!vis[v]) pq.push({v,d[v]});
            }
        }
    }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){
        int u,v,w; cin>>u>>v>>w;
        addedge(u,v,w); addedge(v,u,w);
    }
    dijkstra();
    for(int i=1;i<=k;i++){
        int c; cin>>c; cout<<d[3*n+c]<<'\n';
    }
    return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

建分层图跑最短路。

题目要求的最短路：找一条路径，在路径上，将一条边权变为 $0$，将一条边权翻倍，使得这条路径最短。

对于任选 $k$ 条边免费的最短路问题是标准的分层图最短路。

考虑建图。我们可能先走免费的边再走双倍的边，也可能先走双倍再走免费，特别的，当路径上只有一条边时最短路就是它的边权。

综上需要建四层图，每层图都要建一遍原边，另外还要建三种连接层的边。

1. 边权免费的边。第一层向第二层连（先走免费边），第三层向第四层连（后走免费边）。
2. 边权两倍的边。第二层向第四层连（后走双倍边），第一层向第三层连（先走双倍边）。
3. 原边权的边。第一层直接向第四层连条，因为只一条边的时候它既是最短的也是最长的，花费就是它本身。

答案就是从第一层走到第四层上点的最短路。本题难度在于建图，实现是简单的。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, k, vis[1000005];
long long dis[1000005];
struct edge { int v, w; } ;
vector<edge> e[1000005];
priority_queue<pair<long long, int>>q;
void add (int u, int v, int w) {
	for (int i=0; i<=3; ++i)
		e[u+n*i].push_back({v+n*i, w});
	e[u].push_back({v+n, 0});
	e[u+n*2].push_back({v+n*3, 0});
	e[u].push_back({v+n*2, w*2});
	e[u+n].push_back({v+n*3, w*2});
	e[u].push_back({v+n*3, w});
}
int main() {
	cin >> n >> m >> k;
	for (int u, v, w; m--; ) 
		cin >> u >> v >> w,
		add(u, v, w),
		add(v, u, w);
	memset(dis, 0x3f, sizeof dis);
	dis[1]=0;
	q.push({0, 1});
	while (q.size()) { // dij
		int u=q.top().second;
		q.pop();
		if (vis[u])
			continue;
		vis[u]=1;
		for (auto i:e[u]) 
			if (dis[i.v]>dis[u]+i.w)
				dis[i.v]=dis[u]+i.w,
				q.push({-dis[i.v], i.v});
	}
	for (int t; k--; cout << dis[t+n*3] << '\n')
		cin >> t;
	return 0;
}
```

---

## 作者：jojo_fan (赞：2)

## 形式化题意
给定一个图，从 $1$ 号节点出发求一个边边权为零，一个边边权翻倍后到一个点的最短路。

## 分析
建分层图。

根据两种情况建图：
1. 先走边权为零的边，再走双倍的边；
2. 先走双倍的边，再走边权为零的边。

一共四层图，第一层为原图。

建图：
1.  一二、三四层连边权为零的边；
2.  一三、二四层连双倍的边；
3.  一四层连原边权的边（只有一条边时，此边既最小又最大，边权固为本身）。

## 代码

```cpp
#include"bits/stdc++.h"
#define int long long
using namespace std;

const int N=1e6+10;
int n,m,k;
vector<pair<int,int>> road[N];
vector<int> d(N,LLONG_MAX);

void dijsktra()
{
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
	d[1]=0;
	pq.push({d[1],1});
	while(!pq.empty())
	{
		int u=pq.top().second;
		int dis=pq.top().first;
		pq.pop();
		if(dis>d[u]) continue;
		for(auto cc:road[u]) 
		{
			int v=cc.first;
			int w=cc.second;
			if(d[v]>d[u]+w)
			{
				d[v]=d[u]+w;
				pq.push({d[v],v});
			}
		}
	}
}

void add(int u,int v,int w)
{
	for(int i=0;i<=3;i++) road[u+n*i].push_back({v+n*i,w});
	road[u].push_back({v+n,0});
	road[u+n*2].push_back({v+n*3,0});
	road[u].push_back({v+n*2,w*2});
	road[u+n].push_back({v+n*3,w*2});
	road[u].push_back({v+n*3,w});
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w);
	}
	dijsktra();
	for(int i=1;i<=k;i++)
	{
		int id;
		cin>>id;
		cout<<d[id+3*n]<<'\n';
	}
	return 0;
}
```
#### 警示后人
开 long long。

---

## 作者：LoongPig (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4165)

## 思路

根据题意，很容易想到分层图。

我们可能先走免费的边再走双倍，或者先走双倍再走免费，当最短路只有一条边是就是原来的边权。

**建图方法：**

- 第一层和第二层连免费的边，第三和第四层也连免费的边，分别是先免费和后免费。

- 第一和第三层、第二和第四层连双倍边，分别是先双倍和后双倍。

- 第一和第四层直接相连，即整个最短路只有一条边的情况。

**为什么是“双倍”和“免费”呢？**

设最短路的花费为 $S$，最后实际要花的是 $S-\max w_i+\min w_i$，免费其实就是假设这条边就是 $\max w_i$，因为一加一减抵消；双倍其实就是假设这条边就是 $\min w_i$，加两次就是双倍。

## 代码

[提交记录](https://www.luogu.com.cn/record/226159674)

**注意事项：** 

1. 记得开 `long long`，$2\times 10^5\times 10^9>2^{31}-1$。
2. 用链式前向星的话，存边的数组要大于等于 $4\times 10^6$，不然会 RE。

```cpp
#include <bits/stdc++.h>
#define int long long//记得开 long long
using namespace std;
const int N=4e6+5;
struct node{
	int v,w,nxt;
}a[N];
struct edge{
	int d,v;
	bool operator<(const edge b)const{
		return d>b.d;
	}
};
int n,m,k,head[N],dis[N],idx;
bool vis[N];
void add(int u,int v,int w){
	a[++idx]={v,w,head[u]};
	head[u]=idx;
}
void dijkstra(){// Dijkstra 板子
	memset(dis,0x3f,sizeof dis);
	priority_queue<edge> pq;
	pq.push({0,1});
	dis[1]=0;
	while(!pq.empty()){
		int u=pq.top().v;
		pq.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=a[i].nxt){
			int v=a[i].v,w=a[i].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				pq.push({dis[v],v});
			}
		}
	}
}
signed main(){
    scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=m;i++){
		int u,v,w;
        scanf("%lld%lld%lld",&u,&v,&w);
		for(int j=0;j<=3;j++) 
            add(u+j*n,v+j*n,w),add(v+j*n,u+j*n,w);
		add(u,v+n,0),add(v,u+n,0);//先免费
		add(u+2*n,v+3*n,0),add(v+2*n,u+3*n,0);//后免费
		add(u,v+n*2,w*2),add(v,u+n*2,w*2);//先双倍
		add(u+n,v+3*n,w*2),add(v+n,u+3*n,w*2);//后双倍
		add(u,v+n*3,w),add(v,u+n*3,w);//只有一条边
	}
	dijkstra();
	while(k--){
		int x;
        scanf("%lld",&x);
		printf("%lld\n",dis[x+3*n]);//最后一层为答案
	}
	return 0;
}
```

完结撒花！

---

## 作者：tuxiaolai (赞：1)

# 1 说明
大部分题解都说明了用“分层图”，但并未说明为什么这样建边，在此进行补充。
# 2 审题
## [传送门 B4165](https://www.luogu.com.cn/problem/B4165)
## 2.1 题意分析
题目倒是不难懂，就是在最短路的基础上加上最后返还钱。最后的最短路是经过的边权减去返还的钱，而返还的钱等于经过的最大边权减去最小边权。因此不难发现：
- 在边权之和相同的情况下，应当增大最大边权，减小最小边权。
- 最终结果相当于是最大边权的边免费，最小边权付两倍的钱，因为边权之和本身就包含了最大边权和最小边权。
## 2.2 算法
遇到这种一条边有多种走法的最短路，不难想到用[分层图](https://oi-wiki.org/graph/node/#%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF)。类似于动态规划，可以很好地解决这类问题。
# 3 算法解析
## 3.1 建边
这道题，我们将图分为四层，每层图中都建上原边，表示没有特殊走法（最大、最小边权）的边。
```cpp
struct Node1 {
    int v,w,c;//v表示边的终点，w表示边权，c表示层数
};
const int N=200010;
vector<Node1> adj[N][5];//邻接表
```
```cpp
void push(int u,int v,int w,int c1,int c2){
    adj[u][c1].push_back({v,w,c2});
    adj[v][c1].push_back({u,w,c2});
}//push函数，用于建边
```
```cpp
cin>>n>>m>>k;
for(int i=1;i<=m;i++){
    int u,v,w;
    cin>>u>>v>>w;
    for(int j=1;j<=4;j++){
        push(u,v,w,j,j);
    }//每层建原边
}
```

接下来就是重点处理层间边了。

从起点到终点，共有 3 种走法：
1. 先走最小权边，再走最大权边
2. 先走最大权边，再走最小权边。
3. 只有一条边，它既是最大权边，又是最小权边。

因此，我们可以这样建图：
1. 从一向二、从三向四层各建一条边权为 0 的有向边，表示这是最大权边。
2. 从一向三、从二向四层各建一条边权为 $2w$ 的有向边，表示这是最小权边。
3. 在从一向四层建一条边权为 $w$ 的有向边，表示只有一条边，它既是最大权边，又是最小权边。

不难得出，这样建图共有 3 种走法从第一层走到第四层，且与前面的走法相符。
```cpp
push(u,v,0,1,2);
push(u,v,0,3,4);
push(u,v,2*w,1,3);
push(u,v,2*w,2,4);
push(u,v,w,1,4);
```

## 3.2 最短路
最后，跑一边 Dijkstra 找最短路即可，这里不必多说，但要注意分层。
## 3.3 AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
//Dijkstra
#define INF LLONG_MAX
struct Node1 {
    int v,w,c;
};
struct Node2 {
    int u;
    long long dis;
    int c;
    bool operator<(const Node2& other)const {
        return dis>other.dis;
    }
};
const int N=200010;
vector<Node1> adj[N][5];
long long dis[N][5];
int vis[N][5];
priority_queue<Node2> pq;
void dijkstra(int n,int s){
    for(int i=1; i<=n; i++) {
        for(int j=1;j<=4;j++){
            dis[i][j]=INF;
        }
    }
    dis[s][1]=0;
    pq.push({s,0,1});
    while(pq.size()) {
        int u=pq.top().u;
        int c=pq.top().c;
        pq.pop();
        if(vis[u][c]) continue;
        vis[u][c]=1;
        for(Node1 i:adj[u][c]) {
            if(dis[i.v][i.c]>dis[u][c]+i.w) {
                dis[i.v][i.c]=dis[u][c]+i.w;
                pq.push({i.v,dis[i.v][i.c],i.c});
            }
        }
    }
}
void push(int u,int v,int w,int c1,int c2){
    adj[u][c1].push_back({v,w,c2});
    adj[v][c1].push_back({u,w,c2});
}
int n,m,k;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        for(int j=1;j<=4;j++){
            push(u,v,w,j,j);
        }
        push(u,v,0,1,2);
        push(u,v,0,3,4);
        push(u,v,2*w,1,3);
        push(u,v,2*w,2,4);
        push(u,v,w,1,4);
    }
    dijkstra(n,1);
    for(int i=1;i<=k;i++){
        int t;
        cin>>t;
        cout<<dis[t][4]<<'\n';
    }
    return 0;//Happy compiling!
}
```
# 4 注意事项
题目中边权达到了 $10^9$，注意开 long long！！！

---

## 作者：LogicNotFound (赞：1)

#### 题目大意
从点 $1$ 出发，让你计算到 $k$ 个地方的最小花费。

#### 题目分析
看到这个题很自然的会想到，单源点最短路，跑一遍 Dijkstra 不就都知道了嘛。

但是题目还有个附加条件，到了终点后还会返还给你一部分，返回的数量是通过的路径上的过路费最大的那条路的费用 $max_{w_i}$ 减去过路费最小的那条路的费用 $min_{w_i}$。

那这样就稍微有点麻烦了。

观察一下可以发现过路费 $ = \sum{w_i} - max_{w_i} + min_{w_i} $，那也就是说相当于有一条路是不收费的，有一条路是要多收一次的。

那这不就是分层图嘛！感兴趣的小伙伴可以去看看 [飞行路线](https://www.luogu.com.cn/problem/P4568)，一道分层图模板题。

为什么说这个题是分层图呢？因为我们可以把去到每个点分成四种情况：
1. 到这一个点免费。
2. 到这个点多收一次。
3. 到这个点免费，同时多收一次（这种情况相当于只收一次费）。
4. 到这个点既不免费也不多收。
   
这样就把原本的图拆分成了 $4$ 层，去到每个点都有 $4$ 种可能，当然实际每种可能是否执行，也要考虑到之前是否已经免费或者多收一次了。

然后我们在这样的分层图上跑一遍 Dijkstra 就搞定！当然我们也不需要实际创建出这么一个分层图，不然要是像[旅游巴士](https://www.luogu.com.cn/problem/P9751)这样，来个 $100$ 层图，那不就 MLE 了，因此我们只需要在去到这个点的时候把上面的四种情况都算上就行。

具体实现过程，看下面代码吧！


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int M = 2e5+7; 
const int N = 2e5+7;
struct edge{
	int nxt, to, w;
	// nxt 下一条边编号  to 该边指向的点  w 该边权重  
}e[M*2];
int head[N], k;
void add(int u, int v, int w){
	e[++k] = (edge){head[u], v, w};
	head[u] = k;
}
struct node{
	int nod, cost; 
	bool  mf, ds;
	node(int n, int c, bool m, bool d): nod(n), cost(c), mf(m), ds(d){}
	// 到点 nod，花费了多少钱，是否使用免费，是否多收一次 
	bool operator < (const node &a) const { // Dijkstra 每次选花费最小的点 
		return a.cost < cost; // 按花费从小到大排序 
	}
}; 
int d[N][3][3];  // 8000000
bool vis[N][3][3];
signed main(){
	memset(d, 0x3f, sizeof(d));
	int n, m, k, t;
	cin>> n >> m >> k; 
	int u, v, w;
	for(int i = 1; i <= m; i++){
		cin>>u>>v>>w;
		add(u, v, w); 
		add(v, u, w); 
	}
	priority_queue<node> q;
	q.push((node){1, 0, 0, 0}); // 从 1 出发，初始花费 0，没使用免费，没多收一次 
	d[1][0][0] = 0; // 到 1 的花费是 0,  没使用免费，没多收一次 
	while(!q.empty()){
		
		int u = q.top().nod;
		bool mf = q.top().mf, ds = q.top().ds;
		q.pop();
		if(vis[u][mf][ds]) continue;
		vis[u][mf][ds] = true; // 访问过的点，就不访问了 

		for(int i = head[u]; i; i = e[i].nxt){ // 取出跟 u 相连的所有点 
			int v = e[i].to, w = e[i].w;
			if(mf == 0 && d[u][0][ds] < d[v][1][ds]) // 没使用免费，从 u 去到 v 使用免费会使得花费变少 
			{
				d[v][1][ds] = d[u][0][ds]; // 那就使用免费，那么到点 v 的花费就是到点 u 的花费 
				q.push((node){v, d[v][1][ds], 1, ds}); // 将更新后的花费入队 
			}
			
			if(ds == 0 && d[u][mf][0] + w * 2 < d[v][mf][1]) // 之前没多收一次，从 u 去到 v 多收一次会使得花费变少 
			{
				d[v][mf][1] = d[u][mf][0] + w * 2; // 那就使用，那么到 点 v 的花费 就是到 点 u 的花费 + w * 2
				q.push(node(v, d[v][mf][1], mf, 1)); // 将更新后的花费入队 
			}
			
			if(ds == 0 && mf == 0 && d[u][0][0] + w < d[v][1][1]) // 之前没使用免费也没多收
			{
				d[v][1][1] = d[u][0][0] + w; // 那就使用，免费多收都用上 
				q.push((node){v, d[v][1][1], 1, 1}); // 将更新后的花费入队 
			}
			
			if(d[u][mf][ds] + w < d[v][mf][ds]) // 正常走
			{
				d[v][mf][ds] = d[u][mf][ds] + w; 
				q.push((node){v, d[v][mf][ds], mf, ds}); 
			}
		}
	}
	while(k--) {
		cin >> t;
		cout << d[t][1][1] << '\n'; // 输出到达点 t，免费跟多收都是用过的最小花费 
	} 
	return 0;
}
```

---

## 作者：Chenyuze24 (赞：0)

水一篇绿题题解。
## Part1 题意分析
其实这道题的题意就是让你跑最短路，只是把其中一条边权置为 $0$，而把另外的一条边权翻倍。
## Part2 分析
那么我们对于费用最大的和费用最小的走法可能有 $3$ 种情况。

- 第一种显然就是先跑边权最大的边，后跑边权最小的边。
- 第二种正好相反，先跑边权最小的边，后跑边权最大的边。
- 第三种就是边权最小的和边权最大的是同一条边，也就是只跑一条边。

那么我们考虑建四层图来跑最短路，那么最短路其实不难，可以先把[模版题](https://www.luogu.com.cn/problem/P3371)做了再做这题。这道题的关键点在于如何建图。但是什么是多层图呢？其实看一下[定义](https://oi-wiki.org/graph/node/#%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF)就知道了。这一张图有四层。首先要写一个结构体，里面的参数代表边的起始点和终点，边权，起始层，到达的层。

```cpp
struct EDGE{
	int u,v,w,f1,f2;
};
```
然后我们用 $adj$ 来记录边。

```cpp
vector<EDGE>adj[200010][10];
```

- 首先肯定要把每层的边给建起来，直接按照输入来建即可，且边权为 $w$。
- 一到二层与三到四层连边权为 $0$ 的边，即为费用最大的边。
- 一到三层与二到四层连边权为 $2*w$ 的边，即为费用最小的边。
- 一到四层连边权为 $w$ 的边，即为边权最小的和边权最大的是同一条边，也就是只有一条边。

```cpp
adj[u][1].push_back({u,v,w,1,1});
adj[u][2].push_back({u,v,w,2,2});
adj[u][3].push_back({u,v,w,3,3});
adj[u][4].push_back({u,v,w,4,4});
adj[v][1].push_back({v,u,w,1,1});
adj[v][2].push_back({v,u,w,2,2});
adj[v][3].push_back({v,u,w,3,3});
adj[v][4].push_back({v,u,w,4,4});
adj[u][1].push_back({u,v,0,1,2});
adj[v][1].push_back({v,u,0,1,2});
adj[u][3].push_back({u,v,0,3,4});
adj[v][3].push_back({v,u,0,3,4});
adj[u][1].push_back({u,v,w*2,1,3});
adj[v][1].push_back({v,u,w*2,1,3});
adj[u][2].push_back({u,v,w*2,2,4});
adj[v][2].push_back({v,u,w*2,2,4});
adj[u][1].push_back({u,v,w,1,4});
adj[v][1].push_back({v,u,w,1,4});
```
那么建边建完之后，就是跑个最短路了，参考一下模版题即可。
## Part3 代码

```cpp
#include<bits/stdc++.h>//万能头。
#define int long long
using namespace std;
int n,m,k;
struct EDGE{//结构体。
	int u,v,w,f1,f2;
};
int qp[200005];
vector<EDGE>adj[200010][10];
int u,v,w;
void init()//建边，其实可以简化的。
{
	adj[u][1].push_back({u,v,w,1,1});//第一种情况，每层之中的边。
	adj[u][2].push_back({u,v,w,2,2});
	adj[u][3].push_back({u,v,w,3,3});
	adj[u][4].push_back({u,v,w,4,4});
	adj[v][1].push_back({v,u,w,1,1});
	adj[v][2].push_back({v,u,w,2,2});
	adj[v][3].push_back({v,u,w,3,3});
	adj[v][4].push_back({v,u,w,4,4});
	adj[u][1].push_back({u,v,0,1,2});//第二种情况，建边权为0的边。
	adj[v][1].push_back({v,u,0,1,2});
	adj[u][3].push_back({u,v,0,3,4});
	adj[v][3].push_back({v,u,0,3,4});
	adj[u][1].push_back({u,v,w*2,1,3});//第三种情况，建边权为2w的边。
	adj[v][1].push_back({v,u,w*2,1,3});
	adj[u][2].push_back({u,v,w*2,2,4});
	adj[v][2].push_back({v,u,w*2,2,4});
	adj[u][1].push_back({u,v,w,1,4});//第四种情况，只有1条边。
	adj[v][1].push_back({v,u,w,1,4});
}
//以下是最短路内容。
struct NODE{
	long long v,d,f;
	bool operator<(const NODE& rhs)const{
		return d>rhs.d;
	}
};
long long dis[200100][10];
long long vis[200100][10];
void dijkstra(long long s)
{
	for(int i=1;i<=4;++i)
	{
		for(int j=1;j<=n;++j)
		{
			dis[j][i]=1e18;
		}
	}
	priority_queue<NODE> pq;
	pq.push({s,0,1});
	dis[s][1]=0;
//	vis[s]=1;
	while(!pq.empty())
	{
		NODE curr=pq.top();
		int fr=pq.top().v;
		int cur=pq.top().f;
		pq.pop();
		if(vis[curr.v][curr.f])
		{
			continue;
		}
		vis[curr.v][curr.f]=1;
		for(long long i=0;i<adj[curr.v][curr.f].size();++i)
		{
			EDGE e=adj[curr.v][curr.f][i];
			if(dis[e.v][e.f2]>dis[curr.v][curr.f]+e.w)
			{
				dis[e.v][e.f2]=dis[curr.v][curr.f]+e.w;
				pq.push({e.v,dis[e.v][e.f2],e.f2});
			}
		}
	}
}
void read(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;++i)//读入，注意是m。
	{
		
		cin>>u>>v>>w;
		init();
	}
	dijkstra(1);
	for(int i=1;i<=k;++i)//输出。
	{
		cin>>qp[i];
		cout<<dis[qp[i]][4]<<endl;
	}
}

signed main()
{
	read();
	return 0;
}
```

---

## 作者：yihang2011 (赞：0)

# [题解：B4165 [BCSP-X 2024 12 月初中组] 贸易](https://www.luogu.com.cn/problem/B4165)

同样是分层图最短路，但跟另外一篇题解的写法不同。

-----

题目概述：有 $n$ 个点，$m$ 条边的无向连通图，$k$ 次询问，每次询问给定一个正整数 $t$，找到一条路径，将路径上的一条边权改为 $0$，一条边权翻倍，使得边权和最小。

一条免费，一条翻倍，是因为设边权和为 $t$，那么实际路径长 $t - (\max w_{i} - \min w_{i}) = t - \max w_{i} + \min w_{i}$，则 $\max w_{i}$ 这条边免费，$\min w_{i}$ 这条边翻倍。 

分层图最短路板子题，从有一条边免费就可以看出来。

首先建图，不用特殊对待，直接建好了。

然后是跑最短路的时候，每次入队不仅要记录当前点和路径长，还要记录是否已经免费过了和翻倍过了，然后遍历下一个点的时候分成 4 种方案：

- 如果还没有免费，那么可以这条边免费；

- 如果还没有翻倍，那么可以这条边翻倍；

- 如果既没有免费还没有翻倍，那么可以这条边即免费又翻倍，加减抵消（注意这里不应是乘法，而是原题中的加减），等于什么也没做，但是满足了免费和翻倍（对应样例 1 的第一次询问）；

- 既不免费也不翻倍，按原图处理。

这道题还要开 `long long`，因为 $0 \le w_{i} \le 10^{9}$，$2 \times 10^{5}$ 个 $10^{9}$ 是绝对会超 `int` 的。

其他就没什么可以值得注意的点了，剩下看代码就行了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m, k;
int d[200010][2][2];
vector<pair<int, int> > g[200010];
bool vis[200010][2][2];

void dijkstra() {
    struct node {
        int u, w;
        bool c1, c2;
        // c1记录免费，c2记录翻倍，true 为没有，false 为完成了
        node(int u, int w, bool c1, bool c2) : u(u), w(w), c1(c1), c2(c2) {}
        bool operator < (const node &x) const {
            return x.w < w;
        } 
    } ;
    priority_queue<node> q;
    q.push(node(1, 0, true, true));
    d[1][1][1] = 0;
    while (!q.empty()) {
        int u = q.top().u;
        bool c1 = q.top().c1, c2 = q.top().c2;
        q.pop();
        if (vis[u][c1][c2]) {
            continue ;
        }
        vis[u][c1][c2] = true;
        for (auto [v, w] : g[u]) {
            if (c1 && d[v][0][c2] > d[u][1][c2]) { // 免费
                d[v][0][c2] = d[u][1][c2];
                q.push(node(v, d[v][0][c2], 0, c2));
            } 
            if (c2 && d[v][c1][0] > d[u][c1][1] + w * 2) { // 翻倍
                d[v][c1][0] = d[u][c1][1] + w * 2;
                q.push(node(v, d[v][c1][0], c1, 0));
            }
            if (c1 && c2 && d[v][0][0] > d[u][1][1] + w) { // 免费又加倍
                d[v][0][0] = d[u][1][1] + w;
                q.push(node(v, d[v][0][0], 0, 0));
            }
            if (d[v][c1][c2] > d[u][c1][c2] + w) { // 不免费也不翻倍
                d[v][c1][c2] = d[u][c1][c2] + w;
                q.push(node(v, d[v][c1][c2], c1, c2));
            }
        }
    }
}

signed main() {
    cin >> n >> m >> k;
    for (int i = 1, u, v, w; i <= m; i++) {
        cin >> u >> v >> w;
        g[u].push_back(make_pair(v, w));
        g[v].push_back(make_pair(u, w));
    }
    memset(d, 0x3f, sizeof d);
    dijkstra();
    for (int i = 1, t; i <= k; i++) {
        cin >> t;
        cout << d[t][0][0] << endl;
    } 
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/211847853)

---


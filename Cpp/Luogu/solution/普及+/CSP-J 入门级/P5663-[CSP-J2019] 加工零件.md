# [CSP-J2019] 加工零件

## 题目描述

凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 $n$ 位工人，工人们从 $1 \sim n$ 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。

如果 $x$ 号工人想生产一个被加工到第 $L\,(L \gt 1)$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要生产一个被加工到第 $L - 1$ 阶段的零件（但 $x$ 号工人自己**无需**生产第 $L - 1$ 阶段的零件）。

如果 $x$ 号工人想生产一个被加工到第 $1$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要为 $x$ 号工人提供一个原材料。

轩轩是 $1$ 号工人。现在给出 $q$ 张工单，第 $i$ 张工单表示编号为 $a_i$ 的工人想生产一个第 $L_i$ 阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！

## 说明/提示

**样例 1 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)

编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。

编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。

编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零 件，需要编号为 1 和 3 的工人提供原材料。

编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。

编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。

**样例 2 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)

编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。

编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。

编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。

编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。

编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。

**数据规模与约定**

共 $20$ 个测试点。

对所有测试点保证 $1 \leq u, v, a \leq n$。

测试点 $1\sim4$，$1 \leq n, m \leq 1000$，$q = 3$，$L = 1$。

测试点 $5\sim8$，$1 \leq n, m \leq 1000$，$q = 3$，$1 \leq L \leq 10$。

测试点 $9\sim12$，$1 \leq n, m, L \leq 1000$，$1 \leq q \leq 100$。

测试点 $13\sim16$，$1 \leq n, m, L \leq 1000$，$1 \leq q \leq 10^5$。

测试点 $17\sim20$，$1 \leq n, m, q \leq 10^5$，$1 \leq L \leq 10^9$。

## 样例 #1

### 输入

```
3 2 6
1 2
2 3
1 1
2 1
3 1
1 2
2 2
3 2```

### 输出

```
No
Yes
No
Yes
No
Yes```

## 样例 #2

### 输入

```
5 5 5
1 2
2 3
3 4
4 5
1 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
No
Yes
No
Yes
Yes```

# 题解

## 作者：kradcigam (赞：525)

# [博客园体验更佳](https://www.cnblogs.com/zhaohaikun/p/12180821.html)

## 讲讲我的做法

### 确定做法

首先，看到这道题，我直接想到的是递归，于是复杂度就上天了，考虑**最短路**。

### 如何用最短路

首先，看一张图

![360截图16251114373524.png](https://i.loli.net/2019/11/23/CQ1F4lRjrX2qVpf.png)

我们该如何解决问题？

> 问题:$3$做$5$阶段的零件$1$要不要做呢？

其实，实质就是看$3$到$1$有没有长度为$5$的路径。

> 问题:$3$做$7$阶段的零件$1$要不要做呢？

其实，实质就是看$3$到$1$有没有长度为$7$的路径。

> 问题:$3$做$6$阶段的零件$1$要不要做呢？

其实，实质就是看$3$到$1$有没有长度为$6$的路径。

仔细思考这$3$个问题，我们会发现，**如果$3$到$1$有长度为$5$的路径，那么$3$到$1$一定有长度为$7$的路径，但并不一定有长度为$6$的路径。**

所以，我们要对每个点求一遍奇数路径，和偶数路径。

### 实现最短路

最短路的算法有很多，这道题最好用$dijkstra$，或$bfs$。

这道题的时限并不紧，并且$dijkstra$**细节太多**，我就来演示$bfs$实现的最短路

```cpp
void bfw(){//我有一个好朋友叫bfw，所以我写bfs时，喜欢把函数名起为bfw
	memset(ji,0x3f,sizeof(ji));//奇数最短路径
	memset(ou,0x3f,sizeof(ou));//偶数最短路径
	queue<pair<int,int> >q;
	q.push(make_pair(1,0));
    ou[1]=0;
	while(q.size()){
		int x=q.front().first,y=q.front().second;
		for(int i=0;i<v[x].size();i++){
			if(y%2==1){//奇数+1=偶数
				if(y+1<ou[v[x][i]]){
					ou[v[x][i]]=y+1;//更新答案
					q.push(make_pair(v[x][i],y+1));
				}
			}else{//偶数+1=奇数
				if(y+1<ji[v[x][i]]){
					ji[v[x][i]]=y+1;//更新答案
					q.push(make_pair(v[x][i],y+1));
				}
			}
		}
		q.pop();
	}
}
```
$v$数组是一个动态数组，也就是$vector$，曹老师教我们**多用$STL$写程序**

如果你写这样的$bfs$民间数据会$WA$ $1$个点 ，这个点是这样的

![360截图172905077510285.png](https://i.loli.net/2019/11/23/JiCDb6jpuB9gzfZ.png)

$1$号点是一个孤点，没有偶数路径，所以，我们的$bfs$要这么写

```cpp
void bfw(){//我有一个好朋友叫bfw，所以我写bfs时，喜欢把函数名起为bfw
	memset(ji,0x3f,sizeof(ji));//奇数最短路径
	memset(ou,0x3f,sizeof(ou));//偶数最短路径
	queue<pair<int,int> >q;
	for(int i=0;i<v[1].size();i++){
		ji[v[1][i]]=1;
		q.push(make_pair(v[1][i],1));
	}
	while(q.size()){
		int x=q.front().first,y=q.front().second;
		for(int i=0;i<v[x].size();i++){
			if(y%2==1){//奇数+1=偶数
				if(y+1<ou[v[x][i]]){
					ou[v[x][i]]=y+1;//更新答案
					q.push(make_pair(v[x][i],y+1));
				}
			}else{//偶数+1=奇数
				if(y+1<ji[v[x][i]]){
					ji[v[x][i]]=y+1;//更新答案
					q.push(make_pair(v[x][i],y+1));
				}
			}
		}
		q.pop();
	}
}
```

### 简要讲解主程序

有了这些主程序应该是很简单的了

```cpp
int main(){
	int n,m,q;
	read(n);read(m);read(q);
	for(int i=1;i<=m;i++){
		int x,y;
		read(x);read(y);//无向边
		v[x].push_back(y);//连边
		v[y].push_back(x);//连边
	}
	bfw();//跑最短路
	while(q--){
		int x,y;
		read(x);read(y);
		if(y%2==0){
			if(ou[x]>y)puts("No");//如果大于就不可能了
			else puts("Yes");
		}else{
			if(ji[x]>y)puts("No");//如果大于就不可能了
			else puts("Yes");
		}
	}
	return 0;
}
```
### 总结

先来看一看这题完整的代码了
```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &FF){
	T RR=1;FF=0;char CH=getchar();
	for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
	for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
	FF*=RR;
}
template<typename T>void write(T x){
	if(x<0)putchar('-'),x*=-1;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
vector<int>v[100010];
int ji[100010],ou[100010];
void bfw(){//我有一个好朋友叫bfw，所以我写bfs时，喜欢把函数名起为bfw
	memset(ji,0x3f,sizeof(ji));//奇数最短路径
	memset(ou,0x3f,sizeof(ou));//偶数最短路径
	queue<pair<int,int> >q;
	for(int i=0;i<v[1].size();i++){
		ji[v[1][i]]=1;
		q.push(make_pair(v[1][i],1));
	}
	while(q.size()){
		int x=q.front().first,y=q.front().second;
		for(int i=0;i<v[x].size();i++){
			if(y%2==1){//奇数+1=偶数
				if(y+1<ou[v[x][i]]){
					ou[v[x][i]]=y+1;//更新答案
					q.push(make_pair(v[x][i],y+1));
				}
			}else{//偶数+1=奇数
				if(y+1<ji[v[x][i]]){
					ji[v[x][i]]=y+1;//更新答案
					q.push(make_pair(v[x][i],y+1));
				}
			}
		}
		q.pop();
	}
}
int main(){
	int n,m,q;
	read(n);read(m);read(q);
	for(int i=1;i<=m;i++){
		int x,y;
		read(x);read(y);//无向边
		v[x].push_back(y);//连边
		v[y].push_back(x);//连边
	}
	bfw();//跑最短路
	while(q--){
		int x,y;
		read(x);read(y);
		if(y%2==0){
			if(ou[x]>y)puts("No");//如果大于就不可能了
			else puts("Yes");
		}else{
			if(ji[x]>y)puts("No");//如果大于就不可能了
			else puts("Yes");
		}
	}
	return 0;
}
```
这道题还是比较有**思维含量**的，民间数据也出的很好，让我们思考全面。

最后，还是希望大家不懂就在评论区问，觉得好就点赞！

---

## 作者：Froggy (赞：63)

没人写分层图的题解？？

---

设 $i$ 号节点的偶节点为 $i$ ,奇节点为 $i+n$

**偶节点含义:** 从1到该节点距离(永远)为偶数的节点；

**奇节点定义:** 从1到该节点距离(永远)为奇数的节点；

由于 `奇数+1=偶数，偶数+1=奇数`

所以如果 $u$ 和 $v$ 之间有传输带，

那么只用把 $(u,v+n),(u+n,v),(v+n,u),(v,u+n)$ 连边即可

然后以1为起点跑最短路

由题意可知：

当 $L \equiv 1 (mod \ 2)$ 时，当 $L \geq dis[a+n]$ 时输出Yes,否则输出No

同理，

当 $L \equiv 0 (mod \ 2)$ 时，当 $L \geq dis[a]$ 时输出Yes,否则输出No

注意,数组要开2倍

然后...就是---

*code:* (简单明了)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define N 200020
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
int head[N],cnt,n,m,Q,dis[N],vis[N];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
struct Edge{
	int to,nxt;
}edge[N<<1];
void add(int a,int b){
	cnt++;
	edge[cnt].to=b;
	edge[cnt].nxt=head[a];
	head[a]=cnt;
}
int main(){
	n=read(),m=read(),Q=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		add(u,v+n),add(v+n,u),add(u+n,v),add(v,u+n);
	}
   //一下是最短路板子
	memset(dis,0x3f,sizeof(dis));
	dis[1]=0;
	q.push(make_pair(0,1));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].to;
			if(dis[v]>dis[u]+1){
				dis[v]=dis[u]+1;
				q.push(make_pair(dis[v],v));
			}
		}
	}
   //开始判断
	while(Q--){
		int a=read(),L=read();
		if(L&1){
			printf(dis[a+n]<=L?"Yes\n":"No\n");
		}
		else{
			printf(dis[a]<=L?"Yes\n":"No\n");
		}
	}
	return 今年pj的难度怎么匀给tg啦?(大雾);
}

```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：ix35 (赞：18)

我的解法好像跟网上其他人的解法很不一样...主要是受了[校园旅行](https://www.luogu.org/problem/P5292)这道毒瘤题的影响。

题目其实是要求，有没有一种从$1$到$u$的路径，恰好经过$L$条边。

考虑到每条边可以重复经过，所以如果存在$a$条边的路径，那么$a+2k\ \ (k\in N)$的路径也存在。于是首先可以确定，如果$1$到$i$的最短路记为$dis[i]$，则如果$dis[u]\ge L$且$dis[u]\equiv L\mod 2$，那么答案是肯定的。

接下来考虑$dis[u]\ne L\mod 2$的情况，也就是到$1$的路径中改变了一次奇偶性的情况。也就是路径中的某一段有两种奇偶性不同的通过方法，那么将两条路径拼起来就得到了一个奇环，所以如果这种情况可行，必然经过了最短路以外的一个奇环。

然而奇环本身不容易统计，所以考虑换一个角度。先可以建出$1$为根的最短路树，那么树上当然没有环，奇环只能在非树边中产生，而且我们有如下结论：

必然可以只通过只有一条非树边的奇环，且只需要通过这样的一条奇环达到改变奇偶性的最短路。

结论容易用反证法证明（考场上看出来了也就懒得证），如果只有一个奇环是经过两个非树边的，那么这两个非树边分别与其他树边构成的环中必然有一个奇环。

于是，只要枚举经过哪个奇环即可，而通过奇环其实就是通过奇环中的那个非树边（不一定要绕圈），所以我们可以从任一个点出发必经过一条指定边的最短路。

如果奇环中非树边为$(u,v)$，那么$u$通过这条边的最短路显然是$dis[v]+1$，于是其他点如果要从$u$到达这条边，最短路也就是$dis(x,u)+dis[v]+1$了，有很多这样的$u$，不能分别跑最短路，所以建一个超级源点，把所有非树边的端点向超源连权值为上面那个$dis[v]+1$的边，然后从超源跑最短路即可。

好像很烦的样子...不过程序好写，就是两遍最短路。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=200010;
int n,m,qu,eg,eg2,x,y,hd2[MAXN],ver2[2*MAXN],nx2[2*MAXN],dis[MAXN],vis[MAXN];
int hd[MAXN],ver[4*MAXN],nx[4*MAXN],edge[4*MAXN],dis2[MAXN],vis2[MAXN];
priority_queue < pair<int,int> > q;
priority_queue < pair<int,int> > q2;
void add_edge (int x,int y,int z) {
	ver[++eg]=y;
	nx[eg]=hd[x],edge[eg]=z;
	hd[x]=eg;
	return;
}
void add_edge2 (int x,int y) {
	ver2[++eg2]=y;
	nx2[eg2]=hd2[x];
	hd2[x]=eg2;
	return;
}
int main () {
	freopen("work.in","r",stdin);
	freopen("work.out","w",stdout);
	memset(dis,0x3f,sizeof(dis));
	memset(dis2,0x3f,sizeof(dis2));
	scanf("%d%d%d",&n,&m,&qu);
	for (int i=1;i<=m;i++) {
		scanf("%d%d",&x,&y);
		add_edge2(x,y),add_edge2(y,x); 
	}
	q.push(make_pair(0,1));
	dis[1]=0;
	while (!q.empty()) {
		pair <int,int> a=q.top();
		q.pop();
		if (vis[a.second]) {continue;}
		vis[a.second]=1;
		for (int i=hd2[a.second];i;i=nx2[i]) {
			if (dis[ver2[i]]>dis[a.second]+1) {
				dis[ver2[i]]=dis[a.second]+1;
				q.push(make_pair(-dis[ver2[i]],ver2[i]));
			}
		}
	}
	for (int i=1;i<=n;i++) {
		for (int j=hd2[i];j;j=nx2[j]) {
			add_edge(i,ver2[j],1);
			if ((dis[i]&1)==(dis[ver2[j]]&1)) {
				add_edge(i,n+1,dis[ver2[j]]+1);
				add_edge(n+1,i,dis[ver2[j]]+1);
			}
		}
	}
	q2.push(make_pair(0,n+1));
	dis2[n+1]=0;
	while (!q2.empty()) {
		pair <int,int> a=q2.top();
		q2.pop();
		if (vis2[a.second]) {continue;}
		vis2[a.second]=1;
		for (int i=hd[a.second];i;i=nx[i]) {
			if (dis2[ver[i]]>dis2[a.second]+edge[i]) {
				dis2[ver[i]]=dis2[a.second]+edge[i];
				q2.push(make_pair(-dis2[ver[i]],ver[i]));
			}
		}
	}
	for (int i=1;i<=qu;i++) {
		scanf("%d%d",&x,&y);
		if (dis[x]%2==y%2) {
			if (dis[x]<=y) {printf("Yes\n");}
			else {printf("No\n");}
		} else {
			if (dis2[x]<=y) {printf("Yes\n");}
			else {printf("No\n");}
		}
	}
	return 0;
}
```

---

## 作者：ctq1999 (赞：15)

## 思路

若只有两个节点

![graph.png](https://i.loli.net/2019/12/01/jlQpGL4W7seV2XU.png)

若$2$生产1阶段的零件，那么$1$要生产原材料

若$2$生产2阶段的零件，那么$1$要生产1阶段的材料，$2$生产原材料，$1$不生产原材料

若$2$生产3阶段的零件，$1$生产原材料

若$2$生产4阶段的零件，$1$不生产原材料

可以发现规律：

- 若$2$生产奇数阶段的零件，那么$1$生产原材料的条件是2到1有一条长为奇数的路径

- 若$2$生产偶数阶段的零件，那么$1$生产原材料的条件是2到1有一条长为偶数的路径

注意，路径中间可以多次经过$1$节点

**那么对于任意节点$x$：若要生产奇数阶段的零件，要有一个$x$到$1$的奇数路径，若要生产偶数阶段的零件，要有一个$x$到$1$的偶数路径**

注意，路径不能大于阶段$L$，否则传不到$1$节点

那么我们只需要遍历一遍图，更新出每个节点到$1$的偶数路径和奇数路径长的最小值。若没有奇数路径，则奇数路径的长度为无限大。偶数路径亦然

对于每个询问，只要判断，$L$的奇偶性，和$x$节点对应奇偶路径是否小于等于$L$

若从$1$出发，$L=2$，理论上$1$是要生产原材料的

可是，题目并没有保证图是联通的，所以$1$可能被孤立，也就是下一个阶段的零件穿不出去。这种情况需要特判

别的点被孤立就无须管了，$1$遍历不到它，初始的无限大就不会被更新

***无限大** 大于任何一个$L$*

## 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 100010

using namespace std;

int n, m, q, tot;

int eve[MAXN], odd[MAXN], head[MAXN];

struct edge {
	int to, next;
}e[MAXN * 2];

void add(int x, int y) {
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}

void bfs() {
	memset(eve, 0x7f, sizeof(eve));
	memset(odd, 0x7f, sizeof(odd));
	queue<int> q;
	q.push(1);
	eve[1] = 0;
	while (q.size()) {
		int u = q.front();
		q.pop();
		for (int i = head[u]; i; i = e[i].next) {
			int v = e[i].to;
			if (odd[u] + 1 < eve[v]) {
				eve[v] = odd[u] + 1;
				q.push(v);
			}
			if (eve[u] + 1 < odd[v]) {
				odd[v] = eve[u] + 1;
				q.push(v);
			}
		}
	}
}


int main() {
	scanf("%d%d%d", &n, &m, &q);
	for (int i = 1, u, v; i <= m; i++) {
		scanf("%d%d", &u, &v);
		add(u, v); add(v, u);
	}
	
	bfs();
	
	for (int i = 1, x, y; i <= q; i++) {
		scanf("%d%d", &x, &y);
		if (x == 1 && !head[1]) {
			cout << "No" << endl;
			continue;
		}
		if (y % 2 == 0 && eve[x] <= y || y % 2 == 1 && odd[x] <= y) {
			cout << "Yes" << endl;
		}
		else {
			cout << "No" << endl;
		}
	}
}
```

> 日拱一卒，功不唐捐


---

## 作者：empty_zhm (赞：7)

# 这是一个 BFS 的算法
## 最短路楼上大佬讲得好清楚的QwQ
这个题目当然可以用最短路解决      
~~但我当时不会怎么办~~    
但是这个题的边长固定为1，所以我就想到了用bfs去做。

在一副图中，从$a$点走$L$步,允许重复走，可不可以走到点1。  
有了这个（~~简单易懂~~）的题目，那么我们就可以往下思考了。

首先先讨论下，从点$a$，有什么情况可以走到点1。
## 一、在无环图当中
### 1、可以直接走到点1:
比如图1： 
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)

我们用有序数对$(a,b)$，来代表在$a$点时还剩$b$步没走。  
如果初始状态是$(3,2)$。接下来是$(2,1)\ (1,0)$，刚好传过去。
### 2、当走到点1时，若还有几步未走，便来回走直到剩余步数为0：
如果初始状态是$(3,4)$。就可以有$(2,3)\ (1,2)\ (2,1)\ (1,0)$。

### 总结：
在无环图中，当我们可以求得最短路长度$s$。当有$s\le L$且$(s\ xor\ L)\!\mod 2=0$时，可以从点$a$刚好用$L$步走到点1。

## 二、但题目很清楚的描述了：这个题目不排除有环图QwQ
所以这就引出了一个新的问题。  
如果，我们有一个奇数长度的环怎么办？  
见图2：(找不到图了只好手绘QwQ）

![](https://cdn.luogu.com.cn/upload/image_hosting/dcn1dfnh.png)


### 3、当预见最短路径奇偶性与$L$不相同时，我们可以选择绕一个奇数环走一圈来改变自己剩余路径的奇偶值。
#### （当$a$点与1点位于同一奇数环时，换一个方向即可，不一定要绕一整圈）  
如果初始状态是$(4,7)$，显然与最短路径长度奇偶性不符，但依然有解$(3,6)\ (2,5)\ (1,4)\ (2,3)...(1,0)$。
### 总结
当最短路径$s$与$L$奇偶性不同时，我们可以尝试寻找与其奇偶性不同的路径中最短的$s_0$。当$s_0\le L$时，可以从点$a$刚好用$L$步走到点1。
## 总体总结
分别求得点$a$到点1最短的偶数长度的路径$s_0$和最短的奇数长度的路径$s_1$（但可能两者中有一者不存在）  
当存在$s_0$和$s_1$时：  
$s_0\le L$ 且 $(s_0\ xor\ L)\!\mod 2=0$ 或 $s_1\le L$ 且 $(s_1\ xor\ L)\!\mod 2=0$  成立的情况下，可以从点$a$刚好用$L$步走到点1。
## 具体做法
先 BFS 预处理出每个点和1点间的奇偶最短路径的长度。最后在输入时进行如上的判断就好了。（~~是不是很简单呢~~）  
但是没有AC，为什么呢？
若点$a$与点1并不联通，则$s_0$和$s_1$都不存在，则绝没有解。
# 接下来上代码。

```cpp
#include<bits/stdc++.h>
#define N 100010
using namespace std;
struct node
{
	int to;
	node *last,*next;
	node()
	{
		last=next=NULL;
		to=-1;
	}
}*_A[N];//链式前向星
struct data
{
	int deep,i;
	data(){deep=i=0;}
};//deep指深度（其实就是路径长度）,i指当前节点。
int A[N][2],n,L,m,B[N];
/*A[i][1],A[i][0]分别表示第i个点与1点的奇偶最短距离*/
queue <data> _B;
void add(int a,int b)
{
	if(_A[a]==NULL)/*如果是第一次连边的话，
    	如果要调用_A[a]的话 百分之一百亿会出错(千空句式)*/
	{
		_A[a]=new(node);
		_A[a]->to=b;//同下
		return;
	}
	node *p=new(node);
	p->to=b;//表示指向
	p->next=_A[a]->next;
	_A[a]->next=p;
}//简单的链式前向星的连边
void bfs()
{
	while(!_B.empty())
	{
		int r=_B.front().i,_i=_B.front().deep;
		for(node *i=_A[r];i!=NULL;i=i->next)//遍历以r为开始端的边的标准打法(bushi)
		{
			int a=i->to;
			if(B[a]>1||a==-1) continue;
            		/*如果B[a]已经入队两次
              		(代表奇偶最短路都已经记录完了)
    	    		  或者B[a]没有后续值就不入队了。*/
			if((A[a][B[a]-1]&1) == (_i&1) || !B[a])//如果这次路径与上次的奇偶性不同或者是没有入过队,就入队。否则绝不是最短路径就不入队。
			{
				A[a][B[a]]=_i+1;//记录路径长度
				B[a]++;//记录入队次数
				data p;
				p.deep=_i+1;
				p.i=a;
				_B.push(p);
			}//基本入队操作
		}
		_B.pop();
	}
}
int main()
{
	memset(A,0x7f,sizeof(A));//初始化极大值,以免没有连上的也奇偶判断
	cin >> n >> m >> L;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin >> a >> b;
		add(a,b);
		add(b,a);//有人云:"无向图就是双向的有向图"
	}
	A[1][0]=0;
	B[1]=1;
   //初始化
	data check;
	check.deep=0,check.i=1;
	_B.push(check);
	bfs();
	for(int i=1;i<=L;i++)
	{
		int a,b;
		cin >> a >> b;
		if((A[a][0]<=b) && ((b^A[a][0])%2)==0) puts("Yes");
		else if((A[a][1]<=b) && ((b^A[a][1])%2)==0) puts("Yes");
		else puts("No");//否则输出No
	}
}
```
（我原来题解写得好渣QwQ，我哭了）

---

## 作者：lijingshu_304775 (赞：6)

原题链接：<https://www.luogu.com.cn/problem/P5663>。

更好的使用方式：<https://www.luogu.com.cn/article/0o6pvn64>。

**警告：严禁抄袭**。

## 分析

此题是一道图论的题目，可以将每个工人看成一个点，将双向的零件传送带看作无向边。

只管的做法是按照题目的描述规则，使用递归直接模拟，这样可以通过前 $8$ 个测试点，得到 $40$ 分。对于满分做法，需要观察这个无向图本身的性质，容易发现 $x$ 号点生产一个 $L$ 阶段零件时，如果能找到一条从 $x$ 号点到 $1$ 号点提供原材料。

通过样例 $2$ 的情况，我们发现 $3$ 号点到 $1$ 号点有两条简单的路径，$3\to2\to1$ 与 $3\to4\to5\to1$。那么，如果 $3$ 号点想生产第一阶段的零件，因为两条简单路径的最短长度是 $2$，因此至少要生产第 $2$ 阶段的零件才能到达 $1$ 号点。此外，所有大于 $2$ 的偶数阶段也都是需要 $1$ 号点给材料的，因此会有 $3\to2\to1\cdots\to2\to1$ 这样的方式使得 $1$ 号点提供原材料，因为可以通过 $3\to4\to5\to1\cdots\to5\to1$ 的方式到达一号点。

由此可得，只需预处理出 $1$ 号点到其他所有点的最短奇数路径和最短偶数路径的长度。当 $x$ 号点生产一个 $L$ 阶段的零件时，如果 $L$ 是奇数且 $L$ 大于等于 $x$ 号点到 $1$ 号点的最短奇数路径长度，就需要 $1$ 号点生产原材料。如果 $L$ 是偶数且 $L$ 大于等于 $x$ 号点到 $1$ 号点的最短偶数路径长度，就需要 $1$ 号点生产原材料。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, Q;
//g[i] 存储所有与i相连的点
vector<int> g[100005];
//odd[i]:从1到i的最短奇数路径的长度
//even[i]:从1到i的最短偶数数路径的长度
int odd[100005], even[100005];
queue<int> q;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m >> Q;
	for(int i = 1;i <= m;i++){
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	memset(odd, 0x3f, sizeof(odd));
	memset(even, 0x3f, sizeof(even));
	even[1] = 0;
	q.push(1);
	while(!q.empty()){
		int u = q.front();
		q.pop();
		for(int i = 0;i < g[u].size();i++){
			int v = g[u][i];
			//u->i
			bool flag = false;// 是否有优化
			if(odd[u] + 1 < even[v]){
				even[v] = odd[u] + 1;
				flag = true;
			} 
			if(even[u] + 1 < odd[v]){
				odd[v] = even[u] + 1;
				flag = true;
			}
			if(flag) 
				q.push(v);
		}
	}
	for(int i = 1;i <= Q;i++){
		int a, L;
		cin >> a >> L;
		if(L % 2 == 0 && even[a] <= L)
			cout << "Yes" << endl;
		else if(L % 2 == 1 && odd[a] <= L)
			cout << "Yes" << endl;
		else
			cout << "No" << endl;
	}
	return 0;
}
```

AC 记录：<https://www.luogu.com.cn/record/197005888>。

---

## 作者：WsW_ (赞：4)

### 思路
比较简单的 bfs 单源最短路。  
将**原材料**视为第 $0$ 阶段的零件。  
显然，假设轩轩要加工一个 $L$ 阶段的零件，那么他隔壁的人（假设叫做牢大）就得加工一个 $L-1$ 阶段的零件。轩轩作为牢大的隔壁，轩轩就得加工一个 $L-2$ 阶段的零件。以此类推，轩轩就得加工 $0\sim L$ 中所有和 $L$ 奇偶性相同的零件。  
假设有个人 $u$ 要加工一个 $T$ 阶段的零件，那么如果 $\operatorname{dis}(u,1)> T$，这个零件传不到轩轩这里，轩轩啥都不用做。否则，轩轩得加工第 $T-\operatorname{dis}(u,1)$ 阶段的零件，以及 $0\sim L$ 中所有和 $T-\operatorname{dis}(u,1)$ 奇偶性相同的零件。  
所以只要分奇偶预处理所有点到轩轩的最短距离，然后询问时直接判断即可。  

时间复杂度为 $O(n+m+q)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int x,nx;
}e[201000];
struct node{
	int x,dist;
};
queue<node> q;
int f[101000][2];
bool p[101000][2];
int tot,n,m,qq;
int fa[101000];
void add(int x,int y){
	tot++;
	e[tot].x=y;
	e[tot].nx=fa[x];
	fa[x]=tot;
}
void bfs(){
	node zh;
	zh.x=1;
	zh.dist=0;
	q.push(zh);
	p[1][0]=true;
	while(!q.empty()){
		int x=q.front().x;
		int y=q.front().dist+1;
		int i=fa[x];
		q.pop();
		while(i>0){
			if(!p[e[i].x][y%2]){
				p[e[i].x][y%2]=true;
				f[e[i].x][y%2]=y;
				zh.x=e[i].x;
				zh.dist=y;
				q.push(zh);
			}
			i=e[i].nx;
		}
	}
}
int main(){
	int x,y,a,l;
	scanf("%d %d %d",&n,&m,&qq);
	for(int i=1;i<=m;i++){
		scanf("%d %d",&x,&y);
		add(x,y);	
		add(y,x);
	}
	bfs();
	for(int i=1;i<=qq;i++){
		scanf("%d %d",&a,&l);
		if(f[a][l%2]<=l && p[a][l%2])printf("Yes\n");
		else printf("No\n");
	}
}
```

---

## 作者：Ascnbeta (赞：3)

## P5663 [CSP-J2019] 加工零件
J 组特有的图论题目，主打一个好写不好想。
## 思路分析
一上来就分析一般情况确实困难，所以我们先想一些特殊情况。对于图来说，特殊情况容易想到是一棵树。于是我们去想假如这是以 $1$ 为根结点的一棵树，怎么去做。

很容易就会发现，如果 $1$ 到询问结点 $u$ 的距离 $d$ 如果是奇数，且制作的零件阶段数 $L$ 也是一个大于 $d$ 的奇数，则 $1$ 就需要贡献材料。偶数也与上文类似。

为什么呢？感性证明一下：对于一个边两边的点，零件从一个点传出再传入，阶段数会 $-2$，因此只有当自己制作的零件阶段数是偶数时，零件最后传回自己的时候才是 $0$ 阶段（即原材料）。推广一下就可以得到上面的结论。

那么如果是一个图呢？图的特点就是两点间的路径有多个。那么我们难道要对每条路径的长度奇偶性都做出判断吗？显然不用，我们只用关心最短的奇路径和最短的偶路径即可，因为更长的路径都已经被包含了。

所以做法就很简单了，从结点 $1$ 出发跑奇偶最短路。询问点 $u$ 做的零件阶段为 $L$ 的时候如果这个点 $L$ 对应的奇偶性的最短路 $\le L$，那么就需要提供，否则就不需要。

## AC Code
代码使用的是 Dijkstra 最短路，由于本题边权都为 $1$，可以使用 BFS 求最短路，复杂度还会更优。

其实这样的思路有点类似于分层图，还可以去 CSP-J 2024 T4 看看分层图的应用。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,Q;
struct edge{
	int to,nxt,w;
}e[200005];
int head[100005],tot;
inline void add(int u,int v,int w) {
	e[++tot].to = v;
	e[tot].nxt = head[u];
	e[tot].w = w;
	head[u] = tot;
}
struct node{
	int p,w;
	bool operator < (const node &x) const{
		return w > x.w;
	}
};
int dis[100005][2],f[100005][2];//把一个点的奇偶分开，可以理解为两个点。
priority_queue<node> q;
inline void dij(int s) {
	q.push({s,0});
	memset(dis,0x3f,sizeof(dis));
	dis[1][0]=0;//注意初始化只有偶最短路，自己到达自己路径长度为 0，因此只用初始化偶最短路。
	while(!q.empty()) {
		node t = q.top();
		q.pop();
		if (f[t.p][t.w%2]) continue;
		f[t.p][t.w%2] = 1;
		for (int i = head[t.p]; i; i = e[i].nxt) {
			int v = e[i].to,w = t.w+e[i].w;
			if (dis[v][w%2]>w) {
				dis[v][w%2] = w;
				q.push({v,w});
			}else if(dis[v][w%2]>w) {
				dis[v][w%2] = w;
				q.push({v,w});
			}
		}
	}
}
int main () {
	cin >> n >> m >> Q;
	for (int i = 1; i <= m; i++) {
		int u,v;
		cin >> u >> v;
		add(u,v,1);
		add(v,u,1);//双向边
	}
	dij(1);
	// for (int i = 1; i <= n; i++) {
	// 	cout << dis[i][0] << ' ' << dis[i][1] << '\n'; 
	// }
	while(Q--) {
		int u,v;
		cin >> u >> v;
		if (dis[u][v%2] <= v) {//最短路如果大于 v 则一定不需要，因为在路径中途 v 就会减为 0。
			puts("Yes");
		}else{
			puts("No");
		}
	}
	return 0;
}
```

---

## 作者：kuaiCreator (赞：3)

## 题目大意
给定一个无向图，图中每个顶点都可以生产邻接点上一个阶段的零件。给点 $q$ 次询问，第 $i$ 次询问顶点 $a_i$ 生产 $L$ 阶段的零件时顶点 $1$ 是否能够提供原材料。

## 解题思路
可以将问题转化为从顶点 $1$ 出发走 $L$ 步是否能够停在顶点 $a_i$ ，可以重复走走过的顶点。

对下面左侧图进行分析，我们从顶点 $1$ 出发到达顶点 $2$，可以发现如果步长为 $1,3,4,5,6,7$ 等都可以到达，但是步长为 $2$ 时无法到达。


如果走红色的路径从 $1$ 到 $2$，该路径长度为 $1$，那么 $3,5,6$ 等更大的奇数步长都能到达。因为大于 $1$ 的奇数数步长我们可以通过重复路径 $2-1-2$ 最终能够停留在目标顶点。如果走蓝色的路径从 $1$ 到 $2$，该路径长度为 $4$，那么 $6,8,10$ 等更大的偶数步长同样也能停留在目标顶点。

可将问题转换为求奇数步和偶数步的分层图最短路径问题。  

![](https://cdn.luogu.com.cn/upload/image_hosting/gse319hl.png)

### 解法一：分层建图
如上中间原图，我们可以采用分层建图方式，将原图拆分为 $2$ 层建图。第一层为偶数层，第二层为奇数层，连边时选择偶层连奇层，奇层连偶层。

由于是无权图可以跑 BFS 获取顶点 $1$ 到偶终点编号 $n$ 或奇终点编号 $2n$ 的最短路。根据 $L$ 的奇偶性选择判断 $L$ 是否大于等于该条最短路的长度，如果是则输出 `Yes` 否则输出 `No`。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100005;
vector<int > G[N << 1];
int n, m, q, x, y, L, dis[N << 1];
void bfs(int st);
int main() {
	cin >> n >> m >> q;
	for (int i = 1; i <= m; i++) {
		cin >> x >> y;
		G[x].push_back(y + n);	//分层建图
		G[y + n].push_back(x);
		G[y].push_back(x + n);
		G[x + n].push_back(y);
	}
	bfs(1);
	while (q--) {
		cin >> x >> L;
		int res = dis[x + (L & 1) * n];
		if (res <= L) cout << "Yes\n";
		else cout << "No\n";
	}
	return 0;
}
void bfs(int st) {
	memset(dis, 0x3f, sizeof dis);
	queue<int> q;
	q.push(st);
	dis[st] = 0;
	while (q.size()) {
		int hx = q.front();
		q.pop();
		for (auto to : G[hx]) {
			if (dis[to] > dis[hx] + 1) {
				dis[to] = dis[hx] + 1;
				q.push(to);
			}
		}
	}
}
```

### 解法二：拆分点权
本质上与解法一相同，不过不用去建分层图而是将点权拆分为两份。在计算走到当前顶点的最短路时，偶距离由邻接点的奇距离更新，同样奇距离由偶距离更新。

![](https://cdn.luogu.com.cn/upload/image_hosting/j6onuoxl.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100005;
vector<int> G[N];
int n, m, q, x, y, L, dis[N][2], vis[N];
void bfs(int st) {
	queue<int> q;
	q.push(st);
	memset(dis, 0x3f, sizeof dis);
	dis[st][0] = 0;
	vis[st] = 1;	
	//vis标记是否在队列中，优化避免一个顶点重复入队
	while (q.size()) {
		int hx = q.front();
		q.pop();
		vis[hx] = 0;
		for (auto to : G[hx]) {
			//奇偶最短路交替更新
			if (dis[to][0] > dis[hx][1] + 1) {
				dis[to][0] = dis[hx][1] + 1;
				if (!vis[to]) q.push(to), vis[to] = 1;
			}
			if (dis[to][1] > dis[hx][0] + 1) {
				dis[to][1] = dis[hx][0] + 1;
				if (!vis[to]) q.push(to), vis[to] = 1;
			}
		}
	}
}
int main() {
	cin >> n >> m >> q;
	for (int i = 1; i <= m; i++) {
		cin >> x >> y;
		G[x].push_back(y);	//无向图双向存图
		G[y].push_back(x);
	}
	bfs(1);
	while (q--) {
		cin >> x >> L;
		int res = dis[x][L & 1];
		if (res <= L) cout << "Yes\n";
		else cout << "No\n";
	}
	return 0;
}
```

---

## 作者：HuangRuibo (赞：3)

# 题解：
## P5663
[题目传送门](https://www.luogu.com.cn/problem/P5663)

题目要求判断编号为 $1$ 的工人是否需要为其他工人提供原材料。我们可以将工人和传送带看作图中的节点和边，问题转化为在图中寻找最短路径的问题。

具体来说，我们需要计算从 $1$ 号工人到其他工人的最短路径长度，并且区分路径长度的奇偶性。为此，我们可以使用SPFA算法来求解最短路径。

我们定义两个数组 `f[i].l` 和 `f[i].r`，分别表示从 $1$ 号工人到工人 $i$ 的奇数长度和偶数长度的最短路径。通过 SPFA 算法，我们可以更新这两个数组的值。

在处理每个工单时，根据工单要求的阶段数 $L$ 的奇偶性，判断对应的最短路径长度是否小于等于 $L$，从而决定是否需要 $1$ 号工人提供原材料。

---
### AC CODE：
```cpp

#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100010;
const int INF = 0x3f3f3f3f;

struct Node {
    int odd, even;
};

struct Edge {
    int to, next;
};

int n, m, q, head[MAXN], cnt;
Node f[MAXN];
Edge edges[200010];

void addEdge(int u, int v) {
    edges[++cnt].next = head[u];
    edges[cnt].to = v;
    head[u] = cnt;
}

void SPFA() {
    f[1].even = 0;
    queue<int> Q;
    Q.push(1);
    while (!Q.empty()) {
        int u = Q.front();
        Q.pop();
        for (int i = head[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            int oldOdd = f[v].odd, oldEven = f[v].even;
            f[v].odd = min(f[v].odd, f[u].even + 1);
            f[v].even = min(f[v].even, f[u].odd + 1);
            if (f[v].odd != oldOdd || f[v].even != oldEven) {
                Q.push(v);
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= m; ++i) {
        int x, y;
        scanf("%d%d", &x, &y);
        addEdge(x, y);
        addEdge(y, x);
    }
    for (int i = 1; i <= n; ++i) {
        f[i].odd = INF;
        f[i].even = INF;
    }
    SPFA();
    for (int i = 1; i <= q; ++i) {
        int a, L;
        scanf("%d%d", &a, &L);
        if (L % 2 == 1 && f[a].odd <= L) {
            printf("Yes\n");
        } else if (L % 2 == 0 && f[a].even <= L) {
            printf("Yes\n");
        } else {
            printf("No\n");
        }
    }
    return 0;
}
```

---

## 作者：Danny_chan (赞：2)

我们可以发现最开始的人工作的就是所有小于 $x$ 并且与 $x$ 的奇偶性相等的自然数。所以我们可以分层跑图，一个跑奇数最短路，一个跑偶数最短路。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k;
int d[200010];
vector<int>a[200010];
bool f[200010];
signed main(){
	cin>>n>>m>>k;
	while(m--){
		int x,y;
		cin>>x>>y;
		a[x].push_back(y+n);
		a[y+n].push_back(x);
		a[y].push_back(x+n);
		a[x+n].push_back(y);
	}
	memset(d,0x3f,sizeof(d));
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;
	q.push({0,1});
	d[1]=0;
	while(!q.empty()){
		auto t=q.top();
		q.pop();
		int u=t.second;
		if(f[u]==true) continue;
		f[u]=true;
		for(int i=0;i<a[u].size();i++){
			int x=a[u][i];
			if(d[u]+1<d[x]){
				d[x]=d[u]+1;
				q.push({d[x],x});
			}
		}
	}
	while(k--){
		int x,y;
		cin>>x>>y;
		if(y%2==1){
			if(d[x+n]<=y){
				cout<<"Yes"<<endl;
			}
			else cout<<"No"<<endl;
		}
		else{
			if(d[x]<=y){
				cout<<"Yes"<<endl;
			}
			else cout<<"No"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Kexi_ (赞：2)

非常好的练手图论题，让我的大脑旋转。
### 前言

初学时，这道题没做出来。看了别人的代码后没看懂，现在自己写了一下发现和当初看人家的代码几乎是一样的。所以如果觉得代码抽象，可以先看思路，自己写一下，说不定可以自己做出来的。

### 思路

普及图论还是比较有趣的。读题后没想法，打个 dfs 交一发。


```cpp
#include <bits/stdc++.h>
#define r register
using namespace std;
const int maxn=1e5+7;
int n,m,q,tot,dis;
int head[maxn];
struct e
{
	int t,n;
}e[maxn];
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void add(int u,int v)
{
	e[++tot].t=v;
	e[tot].n=head[u];
	head[u]=tot;
}
inline bool dfs(int f,int l)
{
	if(l==0)
	{
		if(f==1)
		{
			return true;
		}
		return false;
	}
	for(r int i=head[f];i;i=e[i].n)
	{
		if(dfs(e[i].t,l-1))
		{
			return true;
		}
	}
	return false;
}
int main()
{
	cin>>n>>m>>q;
	for(r int i=1;i<=m;i++)
	{
		int u,v;
		u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	while(q--)
	{
		int a,l;
		a=read(),l=read();
		if(dfs(a,l))
		{
			cout<<"Yes"<<"\n";
		}
		else
		{
			cout<<"No"<<"\n";
		}
	}
	return 0;
}
```

拿到 40pts，之前做到这就逃逸了。

分析题意。每个节点都会往他相邻的节点发做低一等级零件的信号且只发一层，那么想要让一号工人做零等级零件，这个问题不就是在问一号节点和另一个节点是否有 $L$ 长度的路径吗？

想到这个这道题就已经解开三分之一，第二个三分之一就是如何求这个路径是否存在呢？

首先想到的就是，如果两个点间的最短路径都比 $L$ 长，那肯定不存在。

然后就是，如果 $L$ 是奇数，而且两点之间存在一条比它短的奇数长度路径，那肯定也有长度为 $L$ 的路径。因为你只需要不停的在这条最短路径上的任意两个节点间横跳就可以增加距离。之前没想通的一点就是，这个奇数路径不一定要是最短路径，只要比 $L$ 短就好啦(虽然我们用的就是最短路径，比较方便)。

偶数路径同理。

到现在，我们已经完成了这道题的三分之二。最后一部分就是代码啦！

具体实现难点在代码中有注释。


```cpp
#include <bits/stdc++.h>
#define r register
using namespace std;
const int maxn=1e6+7;
const int inf=0x3f3f3f3f;
int n,m,q,tot;
int d[2][maxn];
int head[maxn];
struct edge
{
	int t,n;
}e[maxn];
inline void add(int u,int v)
{
	e[++tot].t=v;
	e[tot].n=head[u];
	head[u]=tot;
}
void bfs()
{
	memset(d,inf,sizeof(d));
	queue<int> q;
	q.push(1);
	int dis=0;
	d[0][1]=0;//自己到自己距离是0，偶数
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		for(r int i=head[now];i;i=e[i].n)
		{
			int t=e[i].t;
			if(d[0][t]>d[1][now]+1)
			{
				d[0][t]=d[1][now]+1;//now是现在的点，t是下一个点，两点距离为1
            //因此可以用到now的奇数路径加1来更新到t的偶数路径
				q.push(t);
			}
			if(d[1][t]>d[0][now]+1)
			{
            //同理
				d[1][t]=d[0][now]+1;
				q.push(t);
			}
		}
	}
}
int main()
{
	cin>>n>>m>>q;
	for(r int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	bfs();
	while(q--)
	{
		int a,l;
		cin>>a>>l;
		if(!(l%2)&&d[0][a]<=l)
		{
			cout<<"Yes"<<"\n";// 偶数L就用偶数路径
		}
		else if(l%2&&d[1][a]<=l)
		{
			cout<<"Yes"<<"\n";// 奇数L就用奇数路径
		}
		else
		{
			cout<<"No"<<"\n";
		}
	}
	return 0;
}
```
那么就愉快的 AC 了，不吸氧 1.08 秒。

---

## 作者：superLouis (赞：2)

## 题解：P5663 [CSP-J2019] 加工零件
看到很少有直接写广度优先搜索的，于是就写一篇。

----------
### 1. 解题思路
其实就是朴素的广度优先搜索，再加上一点分析即可。

这里分享我的经验，分析这种题的规律，先从一个比较简单的图开始模拟。我们从 $3$ 开始，标记为 $0$。每个节点旁边都有一些黄色的数，代表这些节点在第几轮被访问过。那么，第 $5$ 轮结束后大概就是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/7vtlcmlj.png?x-oss-process=image/resize,m_lfit,h_320,w_320)

现在我们把这些看上去杂乱无章的数按照奇偶分类一下，就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/pl3af0rm.png?x-oss-process=image/resize,m_lfit,h_300,w=300)

我们来分析一下这些规律：只要有一个偶数轮，则以后的所有偶数轮这个节点都有；只要有一个奇数轮，则以后的所有奇数轮这个节点都有。所以为了看是否需要提供材料，只需要求出每个节点最小的奇数轮和偶数轮即可。

-----------
### 2. 代码实现
代码奇短～
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 1e5 + 10;
const int inf = 1e8;
int n, m, q, dis[maxn][2];
vector<int> e[maxn];
queue<pair<int, int>> que;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m >> q;
    for (int i = 1; i <= m; i++) {
        int u, v; cin >> u >> v;
        e[u].push_back(v); e[v].push_back(u);
    }
    for (int i = 1; i <= n; i++) dis[i][0] = dis[i][1] = inf;
    dis[1][0] = 0; que.push({1, 0});
    while (que.size()) {
        int u = que.front().first, p = que.front().second, d = dis[u][p];
        que.pop();
        for (int v : e[u]) if (dis[v][p ^ 1] > d + 1) {
            dis[v][p ^ 1] = d + 1;
            que.push({v, p ^ 1});
        }
    }
    while (q--) {
        int a, L; cin >> a >> L;
        if (dis[a][L & 1] < inf && dis[a][L & 1] <= L) cout << "Yes\n";
        else cout << "No\n";
    }
    return 0;
}
```
[测评记录](https://www.luogu.com.cn/record/196739679)

---

## 作者：ZHR100102 (赞：1)

# 题意简述

给你一张无向图，$q$ 次询问，判断是否存在一条从 $a$ 到 $1$ 且长度为 $L$ 的路径。

# 思路

看到 $L$ 很大，我们立刻想到了要撇开 $L$ 的限制思考问题。

首先，对于一条路径，我们肯定能找到从 $1$ 到 $v$ 的一条最短路径，它的长度为 $s$。

此时我们可以发现，**这时候我们一定可以找到长度为 $s,s+2,s+4,...,s+2k$ 的路径。**

为什么？因为这张图是无向图，我们可以沿着一条边走，来回一趟，这样我们的时间就会增加 $2$ 了。

那么假设我们要 $s+1,s+3,\dots,s+2k+1(k \ge 0)$ 的长度怎么办？我们只需要找到一个长度为 $s+2k+1$ 的最短路径即可，这样长度为 $s+2k+1+2j(j\ge 0)$ 的路径就都能找到。

这就启发我们把一个点分为此时时间为奇数和此时时间为偶数两种了。

我们可以把点翻倍，然后 BFS 的过程中记录此时是奇数路径还是偶数路径，进入到相应状态的点中，每个点的每个状态最多只会走到一次，这样就能在 $O(n)$ 内求解了。这便是分层图最短路的一个简单应用。

那么每次询问怎么处理？显然，当 $L$ 为奇数时，判断它是否大于等于奇数状态的这个点的最短路长度。若是，则说明可以，否则说明到不了。因为他们模 $2$ 的值相同，而我们可以重复走一条边来让距离增加 $2$。偶数同理。

写代码的时候把 bitset 两维弄反了，喜提 RE，竟然还把样例过掉了，离谱 CCF。


# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;
int n,m,t,dis[1000005][2];
vector<int>g[1000005];
struct node{
	int u,s,d;
};
queue<node>q;
bitset<2>vis[1000005];
void init()
{
	memset(dis,0x3f,sizeof(dis));
	dis[1][0]=0;
	vis[1][0]=1;
	q.push({1,0,0});
	while(!q.empty())
	{
		node tmp=q.front();
		int u=tmp.u,s=tmp.s,d=tmp.d,ns=(s+1)%2;
		q.pop();
		for(auto v:g[u])
		{
			if(vis[v][ns]==0)
			{
				vis[v][ns]=1;
				dis[v][ns]=d+1;
				q.push({v,ns,d+1});
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>t;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	init();
	while(t--)
	{
		int a,l;
		cin>>a>>l;
		if(l%2==1)
		{
			if(dis[a][1]<=l)cout<<"Yes"<<endl;
			else cout<<"No"<<endl;
		}
		else
		{
			if(dis[a][0]<=l)cout<<"Yes"<<endl;
			else cout<<"No"<<endl;			
		}
	}
	return 0;
}
```

---

## 作者：xmy201315 (赞：1)

这道题我用了最短路。

这道题数据较大，也涉及到了奇偶性，我这里用了最短路进行了预处理。我们先拆点，再用奇偶性算出这个点是否能在 $\le L$ 步到达一号点。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=201000;
int n,m,Q;
vector <int> e[N];
int dis[N],q[N];
int main(){
	scanf("%d%d%d",&n,&m,&Q);
	for(int i=0;i<m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		e[2*u-2].push_back(2*v-1);
		e[2*v-2].push_back(2*u-1);
		e[2*u-1].push_back(2*v-2);
		e[2*v-1].push_back(2*u-2);//连边
	}
	for(int i=0;i<2*n;i++)
		dis[i]=1<<30;
	int h=1,t=1;
	q[t]=0,dis[0]=0;
	while(h<=t){
		int u=q[h];h++;
		for(int j=0;j<(int)e[u].size();j++){
			int v=e[u][j];
			if(dis[v]>dis[u]+1){
				dis[v]=dis[u]+1;
				t++;
				q[t]=v;
			}
		}
	}
	for(int i=0;i<Q;i++){
		int a,l;
		scanf("%d%d",&a,&l);
		if(e[0].empty())printf("No\n");//判是否有孤立点
		else{
			int u=2*a-2+(l%2);
			if(l>=dis[u])printf("Yes\n");
			else printf("No\n");
		}
	}
}
```

---

## 作者：Ybll_ (赞：1)

# 题意：

一张 $n$ 个点，$m$ 条边的无向图，$q$ 次询问，问若编号为 $a$ 的工人想加工第 $L$ 阶段的零件，那么编号为 $1$ 的工人是否需要**提供原材料**。

# 思路：

这题涉及到**奇偶性**，数据较大，考虑**广搜预处理**，查询 $Θ(1)$。我们可以发现如果 $L$ 为**偶数**，$x$ 号点到 $1$ 号点的**偶数最短路**长度**大于等于** $L$ 时输出 `Yes`，否则输出 `No`；如果 $L$ 为**奇数**，$x$ 号点到 $1$ 号点的**奇数最短路**长度大于等于 $L$ 时输出 `Yes`，否则输出 `No`。所以只需要处理出 $1$ 号点到其余每个点**的奇、偶数最短路**即可。

# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<long long>vec[100005];
long long n,m,ToT,b[100005][2];
queue<pair<long long,long long>>q;
void bfs()
{
	q.push({1,0});
	while(q.size())
	{
		pair<long long,long long>u=q.front();
		q.pop();
		b[u.first][u.second&1]=u.second;
		long long k=u.second+1;
		for(auto v:vec[u.first])
		{
			if(b[v][k&1]>k)q.push({v,k});
		}
	}
}
int main()
{
	cin>>n>>m>>ToT;
	for(long long i=1;i<=m;i++)
	{
		long long u,v;
		cin>>u>>v;
		vec[u].push_back(v);
		vec[v].push_back(u);
	}
	memset(b,0x3f,sizeof b);
	bfs();	
	while(ToT--)
	{
		long long x,y;
		cin>>x>>y;
		if(y&1)
		{
			if(y>=b[x][1])cout<<"Yes\n";
			else cout<<"No\n";
		}
		else 
		{
			if(y>=b[x][0])cout<<"Yes\n";
			else cout<<"No\n";
		}
	}
    return 0;
}
```

---

## 作者：ny_123457 (赞：1)

## Part 1.思路
用人话讲就是一道分层图的好题，此处建议用 SPFA 算法，要考虑一个奇偶性的问题，将整个图分成两层，一层跑奇数，另一层跑偶数。  
**一个小细节**：最开始所有人的工作都小于当前的 $x$ 并且与当前的 $x$ 的奇偶性相同。可以用这个小细节分层。
## Part 2.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,a,b,ans,dis[100005][2];
vector<int>lj[100005];
void spfa(int s){
	queue<int>q;
	memset(dis,0x3f,sizeof(dis));
	dis[s][0]=0;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		int cnt=lj[u].size();
		for(int i=0;i<cnt;i++){
			int v=lj[u][i];
			if(dis[v][0]>dis[u][1]+1){
				dis[v][0]=dis[u][1]+1;
				q.push(v);
			}
			if(dis[v][1]>dis[u][0]+1){
				dis[v][1]=dis[u][0]+1;
				q.push(v);
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		lj[x].push_back(y);
		lj[y].push_back(x);
	} 
	spfa(1);
	for(int i=1;i<=q;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		if(dis[x][y&1]<=y)printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---

## 作者：jinfanhao (赞：1)

最短路加上一丢丢思维。\
如果要加工一个 $x$ 阶段的零件，那么他隔壁的人就要安装一个 $x-1$, 就这样纠缠下去。\
而可以发现最开始的人工作的就是所有比 $x$ 小的自然数中与 $x$ 奇偶性相等的。\
就可以跑两个最短路，一个是长度为奇数的最短路，另一个是长度为偶数的最短路。\
只要与他奇偶相同的最短路能到那里，并且最短路不比零件级数高就可以连通，因为他可以和旁边的人互相传递。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
int n,m,k,dist1[N],dist2[N];
vector<int> g[N];
void bfs(){
	memset(dist1,0x3f,sizeof(dist1));
	memset(dist2,0x3f,sizeof(dist2));
	queue<int> q;
	dist2[1]=0;
	q.push(1);
	while(q.size()){
		int now=q.front();
		q.pop();
		for(int i=0; i<g[now].size(); ++i){
			if(dist1[now]+1<dist2[g[now][i]]){
				dist2[g[now][i]]=dist1[now]+1;
				q.push(g[now][i]);
			}
			if(dist2[now]+1<dist1[g[now][i]]){
				dist1[g[now][i]]=dist2[now]+1;
				q.push(g[now][i]);
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1; i<=m; ++i){
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	bfs();
	while(k--){
		int x,y;
		scanf("%d%d",&x,&y);
		if((y&1) && dist1[x]<=y)printf("Yes");
		else if((!(y&1)) && dist2[x]<=y)printf("Yes");
		else printf("No");
		printf("\n");
	}
	return 0;
}
```

---

## 作者：chrispang (赞：1)

### 题目大意

给定一张包含 $n$ 个点和 $m$ 条边的无向图，再给定 $q$ 个询问：$a_i,L_i$，判断是否存在一条从 $1$ 号点走到 $a_i$ 号点的恰好经过 $L$ 条边的路径。

### 题目思路

我们可以尝试的找一下规律，例如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)

如果要 $3$ 点要生产 $2$ 等级的材料，那么可以通过上边的那条路线来传递到 $1$ 点（路线长度为 $2$），但是如果要生产 $3$ 等级的材料，则不能走上面那条路。

如果要 $3$ 点要产生 $3$ 等级的材料，那么可以通过下边的那条路线来传递到 $1$ 点（路线长度为 $3$），但是如果要生产 $4$ 等级的材料，则不能走下面那条路。

我们可以发现一个性质，设 $u$ 点到 $v$ 点的距离为 $w$，那么 $L-w$ 得为偶数才能让 $1$ 点生产原材料，换句话说，$L$ 和 $w$ 同奇偶。

但我们还需要注意一点，举个例子，例如 $3$ 点要生产 $1$ 等级的材料，那么需要让 $1$ 点生产原材料吗？很明显不需要，因为根本够不着。

所以我们能得出一个性质：$L$ 和 $w$ 同奇偶，且 $w\le L$。

到这里，看似问题已经解决了，实际还没有，因为我们并不知道 $w$ 是多少，我们得求出 $w$ 是多少。

因此，我们需要分成两部分，分别求 $w$ 为偶数时的最短路和 $w$ 为奇数时的最短路。

拿为什么要求的是最短路呢。因为这里要求 $w\le L$，考虑贪心的性质，$w$ 越短越好，因此选择最短路。

设 `dis[i][0]` 为从 $1$ 点到 $i$ 点的最短路，且最短路长度为偶数，而 `dis[i][1]` 为从 $1$ 点到 $i$ 点的最短路，且最短路长度为奇数。

利用 `BFS`，每次遍历与 $x$ 相邻的点 $y$，并且检查是否可以更新，即

```cpp
dis[y][0] = min(dis[y][0], dis[x][1] + 1);
dis[y][1] = min(dis[y][1], dis[x][0] + 1);
```

如果 `dis[y][0]` 的值比原来小，或者 `dis[y][1]` 的值比原来小，则把 $y$ 加入队列，接着进行更新。

最后还需要注意一点，如果 $u$ 点没有连边（例如下图 $3$ 点），那么也不能让 $1$ 点生产原材料。
![](https://cdn.luogu.com.cn/upload/image_hosting/ke49u8j2.png)

```cpp
#include<bits/stdc++.h>
#define maxn 100010
using namespace std;

int n, m, q, dis[maxn][2]; //dis[i][0/1]表示从1点到i点的最短距离，0表示距离为偶数，1表示距离为奇数 
queue<int>que;
vector<int>linker[maxn]; //邻接表 
int main() {
	memset(dis, 0x3f, sizeof(dis)); //初始化 
	cin >> n >> m >> q;
	while(m--) {
		int u, v;
		scanf("%d%d", &u, &v);
		linker[u].push_back(v), linker[v].push_back(u); //邻接表加入无向图 
	}
	dis[1][0] = 0, que.push(1); //初始化 
	while(!que.empty()) {
		int x = que.front();
		que.pop();
		for (auto y:linker[x]) { //枚举与x相连的y 
			int x1 = dis[y][0], y1 = dis[y][1]; //记录在更新之前的dis[y] 
			dis[y][0] = min(dis[y][0], dis[x][1] + 1); //更新 
			dis[y][1] = min(dis[y][1], dis[x][0] + 1); //更新 
			if(dis[y][0] < x1 || dis[y][1] < y1) que.push(y); //如果值变得更小，则加入队列 
		}
	}
	while(q--) {
		int u, v;
		scanf("%d%d", &u, &v);
		if(dis[u][0] <= v && v % 2 == 0 && linker[u].size()) printf("Yes\n"); //L为偶数的情况 
		else if(dis[u][1] <= v && v % 2 == 1 && linker[u].size()) printf("Yes\n"); //L为奇数的情况 
		else printf("No\n"); //否则输出No 
	}
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

题意即求 $1$ 和 $a$ 之间是否有长度为 $L$ 的路径，考虑最短路。

对于一个询问 $a$ 和 $L$，$L$ 应不小于 $1$ 到 $a$ 的最短路 $dis_a$，否则显然不存在这样的路径。此外，如果 $L - dis_a$ 是偶数一定成立（找一个邻点反复跳就行），若是奇数则不一定。

因此，我们发现答案与 $L$ 和 $dis_a$ 的奇偶性有关，那我们分别求出 $1$ 到 $a$ 的值为奇数和偶数的最短路，若 $L$ 不小于和它同奇偶性的最短路，则存在长度为 $L$ 的路径。

对于实现，多开一维维护奇偶性即可。边权为 $1$，可以用 BFS，代码奇短。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, Q, d[2][100005];
vector<int> e[100005];
queue<pair<int, int>> q;
int main () {
	cin >> n >> m >> Q;
	for (int u, v; m--; )
		cin >> u >> v,
		e[u].push_back(v),
		e[v].push_back(u);
	memset(d, 0x3f, sizeof d);
	for (int i:e[1])
		d[1][i]=1,
		q.push({1, i});
	while (q.size()) {
		int dis=q.front().first, u=q.front().second;
		q.pop();
		for (int i:e[u])
			if (d[1-dis%2][i]>dis+1)
				d[1-dis%2][i]=dis+1,
				q.push({d[1-dis%2][i], i});
	}
	for (int x, l; Q--; ) 
		cin >> x >> l,
		puts(l>=d[l%2][x]?"Yes":"No");
	return 0;
}
```

---

## 作者：Eason0324 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5663)
## 思路
最近老师刚好讲到这题，不知道我能不能讲清楚。$\\$
首先转化一下题目语言：$\\$

---


给定⼀个无向无权图，$q$ 组问询。求点 $a$ 与点 $1$ 间是否存在长恰好为 $L$ 的路径。


---


我们定义 $b_{i,j}$ 表示从 $1$ 第 $i$ 个点走 $j$ 步是否能达到。$\\$

很明显你可以在两个点之间来回走消耗步数。
所以我们真正关心的是从 $1$ 到 $i$ 最少的步数。

于是再定义 $f_{i,x}$ 表示从 $1$ 到 $i$ 走的步数  与 $x$ 同奇偶步数中的最小值。
于是我们就可以得到:

$$ b_{i,j}\gets f_{i,j\bmod2} \le j $$


---


最后是 $f_{i,x}$。直接 **BFS** 就完事了。

我们设 $j$ 可以到 $i$，则
$$f_{i,x}\gets \min(f_{i,x},f_{j,1-x})$$
特判楼上讲过了，我就不详细讲了。


---

复杂度：$O(n+m+q)$

---

## 作者：lylcpp (赞：0)

## 最短路

![1](https://cdn.luogu.com.cn/upload/image_hosting/7a28n6ow.png)

对于上图，如果我们相知道 $2$ 号工人想要一个 $3$ 阶段的零件，其实是看 $2$ 到 $1$ 有没有一条长度为 $3$ 的路径。但如果要求 $4$ 阶段的路径，那就不一定了。

所以我们直接求一遍最短路，分奇最短路和偶最短路。

处理完后，最后一次 $O(1)$ 的回答，如果路径长度过大，就是 No，否则就是 Yes。

看到楼上的大佬好多是用两个数组来记录最短路，我这里用一个二维数组来记录，操作稍微简单一点（空间复杂度基本没变）。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, x;
// vector 建图
vector<int> g[100005];
struct node {
	int u, d; // 目标节点，路径长度
};
queue<node> q;
// 根据路径长度来判断奇偶
int dis[100005][2];
void bfs() {
	memset(dis, 0x3f, sizeof(dis));
	q.push((node){1, 0});
	dis[1][0] = 0; // 初始化
	while (!q.empty()) {
		node h = q.front();
		q.pop();
		int u = h.u, d = h.d;
		for (int i = 0; i < g[u].size(); i++) { // 枚举这个点相连接的节点
			int v = g[u][i];
			if (d + 1 < dis[v][(d+1)%2]) { // 最短路
				dis[v][(d+1)%2] = d + 1;
				q.push((node){v, d + 1}); // 放入队列
			}
		}
	}
}
int main() {
//	freopen("work.in", "r", stdin);
//	freopen("work.out", "w", stdout);
	scanf("%d%d%d", &n, &m, &x);
	for (int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	bfs();
	for (int i = 1; i <= x; i++) {
		int u, t;
		scanf("%d%d", &u, &t);
        // 路径长度合法
        // t % 2 表示是奇还是偶
		if (t >= dis[u][t%2]) printf("Yes\n");
		else printf("No\n"); // 路径长度过长
	}
	return 0;
}
``````

---

## 作者：sieve (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5663)

## 思路

我们先建好图，然后从 $1$ 开始跑 BFS。注意，我们需要两个结果：第一个是 $1$ 不清零，也就是到 $1$ 的距离是极大值；第二个是 $1$ 清零。

然后跑 BFS。不过，我们要交换着来，上一个是第二个，当前就是第一个；上一个是第一个，当前就是第二个。

最后查询的时候，如果 $L$ 是奇数，且 $dis1_a \le L$，或者 $L$ 是偶数，且 $dis2_a \le L$，则都可以，否则就无解。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+9;
int n,m,q;
int dis1[N],dis2[N];
vector<int> g[N];
void bfs(int sx)
{
	queue<int> q;
	for(int i=1;i<=n;++i)
	{
		dis1[i]=dis2[i]=1e9;
	}
	dis2[sx]=0;
	q.push(sx);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=0;i<g[u].size();++i)
		{
			int v=g[u][i];
			if(dis1[v]>dis2[u]+1)
			{
				dis1[v]=dis2[u]+1;
				q.push(v);
			}
			if(dis2[v]>dis1[u]+1)
			{
				dis2[v]=dis1[u]+1;
				q.push(v);
			}
		}
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=m;++i)
	{
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	bfs(1);
	for(int i=1;i<=q;++i)
	{
		int x,y;
		cin>>x>>y;
		if(y%2!=0&&dis1[x]<=y) cout<<"Yes\n";
		else if(y%2==0&&dis2[x]<=y) cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

就不给形式化题意了不然就做完了。

### 2. 思路

我们可以发现，如果第 $i$ 号工人要做第 $j$ 阶段的零件，那么距离他为 $1$ 的工人需要提供第 $j-1$ 阶段的零件，距离他为 $2$ 的工人需要提供第 $j-2$ 阶段的零件……

而原材料可以看做是第 $0$ 阶段的零件，因而提供原材料的工人与第 $i$ 号工人的距离为 $j$。

而我们又容易注意到，如果两工人之间存在长度为 $l$ 的路径，则一定存在长度为 $l+2\times k$ 的路径。

因而问题转化为 $1$ 号点与 $a$ 号点之间是否存在长度为 $L$ 的路径，进一步转化为长度为奇数和偶数的最短路。

假如 $L$ 为奇数，若奇数最短路的长度小于等于 $L$，则一定需要提供原材料，偶数情况同理。

预处理跑一遍最短路就行了。

---


# [CSP-J2019 江西] 非回文串

## 题目描述

Alice 有 $n$ 个字符，它们都是英文小写字母，从 $1 \sim n$ 编号，分别为 $c_1,c_2, \dots , c_n$。  
Bob 准备将这些字符重新排列，组成一个字符串 $S$。Bob 知道 Alice 有强迫症，所以他打算将 $S$ 组成一个非回文串来折磨 Alice。  

现在 Bob 想知道他共有多少种不同的排列字符的方案，能使得 $S$ 是个非回文串。一种排列字符的方案指的是一个 $1 \sim n$ 的排列 $p_i$，它所组成的 $S = c_{p_1}c_{p_2} \dots c_{p_n}$。

一个字符串是非回文串，当且仅当它的逆序串与原串不同。例如 `abcda` 的逆序串为 `adcba`，与原串不同，故 `abcda` 是非回文串。而 `abcba` 的逆序串与原串相同，是回文串。

由于最后的结果可能很大，你只需要告诉 Bob 总方案数对 $10^9+7$ 取模后的值。

## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$n \le 8$；  
对于 $50\%$ 的数据，$n \le 20$；  
另有 $30\%$ 的数据，字符只包含 `a` 和 `b`；  
对于 $100\%$ 的数据，$3 \le n \le 2000$。

## 样例 #1

### 输入

```
3
aba```

### 输出

```
4```

## 样例 #2

### 输入

```
8
aabbbbcc```

### 输出

```
39168```

# 题解

## 作者：NaCly_Fish (赞：65)

很简单的数数入门题，比 CSP-S Day2 T1 良心多了（  

注意到每个字符都是有标号的，所以非回文串数等于 $n!$ 减去回文串数。  
记第 $i$ 种字母的出现次数为 $a_i\ (i\in[1,26])$，如果有超过 $1$ 种 $a_i$ 为奇数，则不可能组成回文串，答案为 $n!$。

为了下面表述方便，默认所有 $a_i$ 都为偶数。

由于回文串是左右对称的，所以只考虑确定一边，另一边的每个字母都可以在对应位置随便排列（当然左右可以互换），也就是 $a_i!$ 种。

所以对于左边的每一种排列，贡献就是每个 $a_i!$ 之积。

那么现在只需要算出：每种元素有 $a_i/2$ 个，且**无标号**的排列数，乘上面的贡献就可以了。

如果没有重复，排列数当然是 $(n/2)!$；现在有重复元素，要除去所有重复的排列，也就是
$$( n/2)!\prod\limits_{i=1}^{26}\frac{1}{(a_i/2)!}$$  
不嫌麻烦也可以用 EGF 来推出这个结果，不用动脑子（  

所以最终答案就是  

$$n!-\left( (n/2)!\prod\limits_{i=1}^{26}\frac{a_i!}{(a_i/2)!}\right)$$

不过这是 $a_i$ 全都是偶数的情况。  
对于有一个是奇数的时候，设为 $x$；可以从 $x$ 中选一个放在中间，所以右边那部分要再乘 $x$。

时间复杂度 $\Theta(n)$。

```cpp
#include<cstdio> 
#include<algorithm>
#include<cstring>
#define ll long long
#define N 2003
#define reg register
#define p 1000000007
using namespace std;

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int n,ans,dec,odd;
char a[N];
int fac[N],ifac[N],cnt[26];

int main(){
    scanf("%d",&n);
    scanf("%s",a+1);
    ifac[0] = ifac[1] = fac[0] = fac[1] = 1;
    for(reg int i=2;i<=n;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[n] = power(fac[n],p-2);
    for(reg int i=n-1;i>1;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
    for(reg int i=1;i<=n;++i) ++cnt[a[i]-'a'];
    for(reg int i=0;i<26;++i) odd += cnt[i]&1;
    if(odd>1){
        printf("%d",fac[n]);
        return 0;
    }
    odd = 1;
    for(reg int i=0;i<26;++i)
        if(cnt[i]&1) odd = cnt[i];
    dec = (ll)fac[n>>1]*odd%p;
    for(reg int i=0;i<26;++i) cnt[i] >>= 1;
    for(reg int i=0;i<26;++i) dec = (ll)dec*fac[cnt[i]<<1]%p*ifac[cnt[i]]%p;
    ans = (fac[n]-dec+p)%p;
    printf("%d",ans);
    return 0;
}
```

---

## 作者：旭日临窗 (赞：19)

个人认为这道题和[道路拆除P5683](https://www.luogu.com.cn/problem/P5683)比较有思维难度，[道路拆除的题解已经写过了](https://www.luogu.com.cn/blog/sun-jia-zheng/solution-p5683)，好了现在进入正题。

**思路**：还是**正难则反**，非回文串不是太好求，所以我们可以用**总的方案数减去回文串的数量**不就行了吗？

总方案数很好求就是$n!$，那回文串的数量怎么求呢？

我们想回文串肯定是**对称**的，所以**每个字母都应该是偶数个，特殊情况下最多只能有一个字母的数量是奇数个**，否则就不能组成回文串，直接输出总方案数就行了。

所以我们可以**预处理**出每个字母出现的个数$sum[i]$表示，如果有一个字母的数量是**奇数**，$sum[i]--$就行了，因为**那一个字母必然在中间**。

好了，现在还有一个问题，回文串的数量怎么求呢，先来看一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2id3207c.png)

如图，$n1$表示$a$出现的数量，以此类推，$n26$表示$z$的数量，因为回文串是**对称**的，所以左边每个字母的数量都是$n/2$，那问题就变得简单了，现在就相当于是求

$n1/2,n2/2...n26/2$能组成多少串了，因为**左边一变右边也会跟着变。**

**我们想**，数量总共是$n$，方案数是$n!$，那数量是$n/2$，方案数不就应该是$\frac{n}{2} !$吗？

还有一点不要忘了，对于每一种字母，假设是$a$，我们都要从$n$个$a$中选出$\frac{n}{2}$个a放到左边，其余放到右边，发现这不就是**组合数学**吗？

[组合数学不会的可以参考一下，这里只有公式](https://zhidao.baidu.com/question/689879375452903724.html)

那到底是$A$还是$C$呢？

我们想左边动，右边也跟着动，但是**每个字母可以对应同类的其余字母**，什么意思呢，见图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gn3xvkze.png)

还有题目也说了**每个字母都有自己的编号**，所以肯定是$A$了。

注：$A$用于有序号，$C$用于没有序号，只考虑位置（如果还不理解$A$和$C$可以去百度）。

好了，分析到这就可以推出公式了，建议大家再回过头看看。

$\Large n!-\frac{n}{2}! * \prod\limits_{i=1}^{26}A(ni,\frac{ni}{2}) * nx$

$nx$是那个奇数个的字母的个数，因为他们可以轮流在中间，**千万要注意**，如果$nx==1$就不要乘了，因为-1之后就成0了，一乘就毁了。

如果没有奇数个的字母$nx==1$就行了。

求$A$的时候可以用**费马小定理**求**逆元**。

$code$：

```c
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int mod = 1e9 + 7;
int n,sum[30],s;
ll jc[2010],ans = 1;
char a[2010];
bool f;
ll q_pow(ll x,ll y)//用费马小定理求逆元，要用到快速幂。 
{
	ll ans = 1;
	while(y)
	{
		if(y & 1) ans = ans * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ans;
}
void getjc()//可以预处理出阶乘数组。 
{
	jc[0] = 1;
	for(int i = 1;i <= n;i++) jc[i] = (ll)jc[i - 1] * i % mod;
}
int main()
{
	scanf("%d",&n);
	scanf("%s",a + 1);
	getjc();
	for(int i = 1;i <= n;i++)
	sum[a[i] - 'a' + 1]++;//预处理出每个字母出现的个数。 
	for(int i = 1;i <= 26;i++)
	if(sum[i] != 0 && sum[i] % 2)//统计有没有奇数个字母。 
	{
		if(f)//如果数量还>1，一定没法组成回文串，直接输出n!。 
		{
			printf("%lld",jc[n]);
			return 0;
		} 
		f = 1;
		s = sum[i]--;//字母奇数个出现的次数-1，因为那一个字母只能放到中间。 
	}
	for(int i = 1;i <= 26;i++)//求A要用到逆元。 
	{
		if(!sum[i]) continue;
		ans *= (ll)jc[sum[i]] * q_pow(jc[sum[i] / 2],mod - 2) % mod;//逆元。 
		ans %= mod;
	}
	ans = ans * jc[n / 2] % mod;//公式。 
	if(f) ans = ans * s % mod;//如果有奇数别忘了乘nx，也就是s。 
	ans = jc[n] - ans;
	if(ans < 0) ans += mod;//这里要注意，ans有可能是负数。 
	printf("%lld",ans);
	return 0;
} 
```
~~/管理员大大求过，$thanks$/~~

---

## 作者：无钩七不改名 (赞：5)

写一发比较通俗易懂的（？）

首先所有的排列方式数量一定是 $n!$，要求非回文串，要用所有串的数量减去回文串的数量（因为这样比较简单好吧）。问题就转化为如何求回文串的数量。

可以很容易就想到，如果超过 $1$ 种字母的数量为单数，就一定全是非回文串。

因为回文串是对称的。所以基本都是两两成对的。

可以考虑组与组之间的排列方式。设每一种小写字母出现的次数为 $a_i\left(0\le i\le 25\right)$，令 $sum=\sum_{i=0}^{25}\frac{a_i}{2}$，则忽略每组内部,组与组之间的排列数量为 $\prod_{j = 1}^{sum}\limits j$。

然后便是每组内部的排列方式，用排列组合的知识很容易想到就是 $\prod _ {i = 1} ^ {a_i}\limits i$。由于不同组之间的排列方式更换后可能会重复，需要除以重复的数量，即 $\prod_{i = 1}^{\frac{a_i}{2}}\limits i$，所以整理一下回文串的数量就是 $\left(\prod_{j = 1}^{sum}\limits j\right)\prod _ {j = 0} ^ {25} \prod _ {i = \frac{a_i}{2}+1} ^ {a_j} i$。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,a[26];
char s[2005]; 
const int mod=1e9+7;
bool ds;
int ans;
long long unres=1,res=1;

int main(){
	//cout<<mod;
	scanf("%d %s",&n,s);
	for(int i(0);i<n;i++){
		a[s[i]-'a']++;
	}
	for(int i(0);i<26;i++){
		if(a[i]%2){
			if(ds){
				res=1;
				for(int j(2);j<=n;j++)res=res*j%mod;
				return printf("%lld",res),0;
			}
			ds=1;
		}
		ans+=a[i]/2;
		for(int j(a[i]/2+1);j<=a[i];j++){
			res=res*j%mod;
		}
	}
	//cout<<"ans:"<<ans<<" res:"<<res<<'\n';
	for(int j(2);j<=ans;j++)res=res*j%mod;
	for(int j(2);j<=n;j++)unres=unres*j%mod;
	printf("%lld",(unres+mod-res)%mod);
	//cout<<" "<<res;
	return 0;
} 
```


---

## 作者：SegTree (赞：4)

[题目传送门。](https://www.luogu.com.cn/problem/P5684)

## 题意简述
给定长度为 $n$ 的字符串 $s$，求将 $s$ 重排后 $s$ 为非回文串的总数对 $p=10^9+7$ 取模的结果。
## 题目分析
正难则反易，可以考虑将 $s$ 所有全排列的个数与所有的回文串相减。

全排列的个数很简单，是 $n!$。

首先判断 $s$ 中的字符 $\texttt{a}$ 至 $\texttt{z}$ 的数量，可以开一个数组记录，以 $t_i$ 记录字符在字母表中排序后为第 $i$ 个的个数。在其中的奇数个数 $m$ 如果超过了 $1$，必然无法组成回文串，此时回文串个数为 $0$。否则答案如果不考虑重复的排列，就是 $(\lfloor\dfrac{n}{2}\rfloor)!$，而对于任意的字符，它的重复排列总数要去掉，也就是乘以 $\dfrac{t_i!}{(\lfloor\tfrac{t_i}{2}\rfloor)!}$。所以这时最终的答案为：

$$n!-(\lfloor\dfrac{n}{2}\rfloor)!\prod_{i=1}^{26}\dfrac{t_i!}{(\lfloor\frac{t_i}{2}\rfloor)!}$$
## 代码实现
在计算 $\dfrac{t_i!}{(\lfloor\frac{t_i}{2}\rfloor)!}$ 时需要使用乘法逆元，实现上主要有 $\text{exgcd}$ 和费马小定理等。

[关于使用 $\text{exgcd}$ 和费小计算乘法逆元的资料。](https://jpb.blog.luogu.org/fei-xiao-yu-exgcd-qiu-sheng-fa-ni-yuan)

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long p=1e9+7;
int a[27],n;
long long quickpow(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1){
            ans=ans*a%p;
        }
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
long long niyuan(int k){
    return quickpow(k,p-2);
}
long long A(int n,int m){
    long long ans=1;
    for(int i=n;i>=n-m+1;--i)ans=ans*i%p;
    return ans;
}
int main(){
    long long sum=1,ans=1,flag=0;
    cin>>n;
    sum=A(n,n);
    for(int i=0;i<n;++i){
        char ch;
        cin>>ch;
        a[ch-'a'+1]++;
    }
    for(int i=1;i<=26;++i){
        if(a[i]%2){
            flag++;
        }
    }
    if(flag>=2){
        ans=0;
    }
    else {
        ans=A(n/2,n/2);
        for(int i=1;i<=26;++i){
            ans=ans*A(a[i],a[i])%p*niyuan(A(a[i]/2,a[i]/2))%p;
        }
    }
    cout<<((sum-ans)%p+p)%p;
    return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
不建议没有学完高中排列组合内容的同学来挑战这道题。  

因为字符都编了号，所以各不相同，所以一共有 $A_{n}^{n}=n!$ 种 $S$。由于非回文串没有什么好性质能作为限制，所以我们考虑从全排列中扣掉回文串的贡献。  

接下来算有多少种情况满足 $S$ 为回文串。  
如果有超过 $1$ 种字母出现次数为奇数，那肯定不能构成回文串，所以非回文串个数就是 $n!$。  
如果有不超过 $1$ 种字母出现次数为奇数，那肯定能构成回文串。有人可能会说，$n$ 是偶数，但是有一种字母出现次数为奇数，也一定不能构成回文串。但一个奇数加上几个偶数不可能等于偶数 $n$，所以这种情况不可能出现。  

接着用分步乘法原理的思想计算。记 $cnt_i$ 为字母 $i$ 出现的次数。  
现考虑有特殊的情况：如果有 $1$ 种字母 $i$ 出现次数为奇数，那 $S$ 中间的位置必定放这种字母，中间的位置一共有 $cnt_i$ 种选择，先乘上 $cnt_i$。放完之后，还剩下 $cnt_i\gets cnt_i-1$ 个字母 $i$。然后就把这个出现奇数次的特例化成了偶数次。  
每一种字母在 $S$ 左右两半出现次数是相同的，所以每放一种字母就是一步。考虑每个字母 $i$ 有几种放法。  

首先确定字母 $i$ 放到 $S$ 中有几种可能的形状，也就是把这 $cnt_i$ 个字母在 $S$ 中分配位置。  
由于 $S$ 是回文串，所以左半边的形状和右半边的形状是对称的，只要考虑左半边的形状即可，右半边的形状就自动确定了。  
假设左半边剩下 $m$ 个空位，我们就要在 $m$ 个空位中选 $\frac{cnt_i}{2}$ 个位置出来，无关顺序。所以就是组合数，有 $C_{m}^{\frac{cnt_i}{2}}$ 种方案。  
确定了形状之后，我们就要把 $cnt_i$ 个字母 $i$ 放进我们选出来的 $cnt_i$ 个位置中，和顺序有关。所以就是排列数，有 $A_{cnt_i}^{cnt_i}$ 种方案。  
所以字母 $i$ 这一步，有 $C_{m}^{\frac{cnt_i}{2}}\times A_{cnt_i}^{cnt_i}$ 种方案。  

预处理出排列数和组合数，最后把每一步的方案数乘起来，并用 $n!$ 减掉回文串数量即可。  

时间复杂度为 $O(n^2)$，瓶颈在于预处理组合数。可以使用乘法逆元来优化求组合数的过程。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
typedef unsigned long long ull;
const int p=1e9+7;
int n;
string s;
int cnt[31];
ll fac[2003]={1};
ll C[2003][2003];
ll ans=1;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>s;
	for(int i=0;i<n;i++){
		cnt[s[i]-'a'+1]++;
		fac[i+1]=fac[i]*(i+1)%p;
		if(i<=(n>>1))for(int j=0;j<=i;j++){
			if(j==0||j==i)C[i][j]=1;
			else C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;
		}
	}
	bool f=0;
	for(int i=1;i<=26;i++){
		if(cnt[i]&1){
			if(f){
				cout<<fac[n];
				return 0;
			}
			(ans*=cnt[i]--)%=p;
			f=1;
		}
		(ans*=C[(n-cnt[i-1])>>1][cnt[i]>>1]*fac[cnt[i]]%p)%=p;
		cnt[i]+=cnt[i-1];
	}
	cout<<(fac[n]-ans+p)%p;
	return 0;
}
```

---

## 作者：cwxcplh (赞：3)

一道很简单的数学题。。。

题目简化：给定一个字符串，通过交换顺序使它**不是**一个回文串。

看上去很简单，用一个大模拟就行了。

数据： $3\le n\le 2000$。

如果直接用模拟的话，时间复杂度就是 $O(n!)$，最坏情况下是 $2000!$。

注意看题目中的这几个字：**交换顺序**。这说明了这个字符串中的字符是不会改变的，而题目要求我们求有多少种情况使得这个字符串不是回文串。

与回文串相关，立马想到回文串的对称性！

所以第一步一定是先统计每个字符出现了多少次（这里建议用 ```map``` ）。

```cpp
for(int i=1;i<=n;i++)
{
	cin>>c[i];
	mp[c[i]]++;//用mp来统计个数
}
```

因为回文串具有对称性，所以我们只需要考虑一边，另一边跟这边也就一样了。

直接求非回文串的个数太麻烦，这里用了正难则反的思路：我们只需要求出有多少个回文串，再用总的个数减掉就是答案了。

总的个数很好求，就是 $n!$，那回文串的个数怎么求呢？

我们前面说过，考虑回文串只需要考虑一边就行了，所以说我们只需要将每种字符出现的次数 ```mp[c[i]]``` 除以 $2$ 就可以了。由此，我们需要将 ```mp[c[i]]``` 分成两类。

### 当 ```mp[c[i]]``` 为偶数时

此时 ```mp[c[i]]``` 可以直接被分成两部分，总的 $n$ 也一定是偶数。一边就有 $\frac{n}{2}$ 个字母，每个字母之间互相交换，一共有 $\frac{n}{2}!$ 种情况。

现在我们又对于每个字母进行讨论。

因为字母之间是可以两两交换的，总的方案也就有 $mp_{c_{i}}!$ 种但是同一边交换是没有用的啊，所以我们还要再这个基础上再去掉重复的，也就是同一边的搭配情况，算下来是 $(mp_{c_{i}}/2)!$。

把上面的公式合在一起，我们就得到了一个字母的排列情况，即。

$$\frac{mp_{c_{i}}!}{(mp_{c_{i}})/2}$$

一共有 26 个字母，所以共有。

$$\prod_{i=1}^{26}\frac{mp_{c_{i}}!}{(mp_{c_{i}})/2}$$

最后再把总共的排列情况乘上，所以最终的公式是。

$$\frac{n}{2}! \times \prod_{i=1}^{26} \frac{mp_{c_{i}}!}{(mp_{c_{i}})/2}$$

最后用 $n!$ 减去这么多就是答案了。

$$ans=n!-\frac{n}{2}! \times \prod_{i=1}^{26} \frac{mp_{c_{i}}!}{(mp_{c_{i}})/2}$$

代码实现。

```cpp
int jc(int x)//前半部分的阶乘
{
	int z=1;
	for(int i=2;i<=x;i++)
	{
		z*=i;
		z%=mod;
	}
	return z;
}
int jc1(int x)//后半部分的阶乘
{
	int z=1;
	for(int i=x/2+1;i<=x;i++)
	{
		z*=i;
		z%=mod;
	}
	return z;
}
int ou()//偶数求值
{
	int sum=1;
	for(int i=1;i<=m;i++)
	{
		sum*=jc1(mp[c[i]]);
		sum%=mod;
	}
	sum=sum*jc(n/2)%mod;
	return sum;
}
```

### 当 ```mp[c[i]]``` 为奇数时

跟上方原理相同，只需要去掉其中的一个值，再按照偶数的方法求出值就可以了。注意：中间的那个值是不定的，所以需要多乘一个 ```mp[c[i]]``` 自身的值。

代码如下。

```cpp
int ji()
{
	int sum=0;
	for(int i=1;i<=m;i++)
	{
		if(mp[c[i]]&1)
		{
			mp[c[i]]--;
			sum+=(mp[c[i]]+1)*ou()%mod;//将mp[c[i]]转化为偶数后按照偶数的方法求值
			mp[c[i]]++;
		}
	}
	return sum;
}
```

万事俱备，一交代码。

![](https://cdn.luogu.com.cn/upload/image_hosting/fpfb9gxo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

只得了 $80$ 分。

原因则出在了奇数这里。

我们想想：如果你有两个字母的个数都是奇数，那你就根本没法构成回文串，此时的 $ans=0$。

所以，在计算之前，我们需要特判一下。

```cpp
int sum=0;
for(int i=1;i<=m;i++)
{
	if(mp[c[i]]&1)
	{
		sum++;
	}
}
if(sum>1)
{
	ans=0;
}
else
{
	ans=ji();
}
```

完整代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,m;
char c[2006];
map<char,int>mp;
int jc(int x)
{
	int z=1;
	for(int i=2;i<=x;i++)
	{
		z*=i;
		z%=mod;
	}
	return z;
}
int jc1(int x)
{
	int z=1;
	for(int i=x/2+1;i<=x;i++)
	{
		z*=i;
		z%=mod;
	}
	return z;
}
int ou()
{
	int sum=1;
	for(int i=1;i<=m;i++)
	{
		sum*=jc1(mp[c[i]]);
		sum%=mod;
	}
	sum=sum*jc(n/2)%mod;
	return sum;
}
int ji()
{
	int sum=0;
	for(int i=1;i<=m;i++)
	{
		if(mp[c[i]]&1)
		{
			mp[c[i]]--;
			sum+=(mp[c[i]]+1)*ou()%mod;
			mp[c[i]]++;
		}
	}
	return sum;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>c[i];
		mp[c[i]]++;
	}
	set<char>s;
	for(int i=1;i<=n;i++)
	{
		s.insert(c[i]);
	}
	m=s.size();
	for(int i=1;i<=m;i++)
	{
		c[i]=(*s.begin());
		s.erase(s.begin());
	}
	bool flag=true;
	for(int i=1;i<=m;i++)
	{
		if(mp[c[i]]&1)
		{
			flag=false;
		}
	}
	int ans;
	if(flag)
	{
		ans=ou();
	}
	else
	{
		int sum=0;
		for(int i=1;i<=m;i++)
		{
			if(mp[c[i]]&1)
			{
				sum++;
			}
		}
		if(sum>1)
		{
			ans=0;
		}
		else
		{
			ans=ji();
		}
	}
	int t=jc(n)-ans;
	cout<<(t<0?t+mod:t);
	return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

题目要求解的是非回文串，较难计算，正难则反，我们考虑用总的方案数量减去回文串的方案数量，这样就可以得到非回文串的方案数量。

那么第一个问题，求总的方案数量，有 $n$ 个字符，第一个位子有 $n$ 种可能，第二个位置有 $n-1$ 种可能，……，那么方案数为 $n \times (n - 1) \times \dots \times 2 \times 1$，即 $n!$。

下一个问题，如何计算回文串的数量？

那么我们先考虑是否存在回文的方案：

- 当 $n$ 为偶数时，所有的字符的出现次数必须为偶数，这样才可以左右对称，即回文。
- 当 $n$ 为奇数时，有且仅有一种字母的出现次数为奇数，这个字母放在 $\lceil \dfrac n 2 \rceil$ 的位置。

接下来我们考虑如何计算回文的方案数量。

如果 $n$ 为奇数，那么出现一次的字符就必须放在 $\lceil \dfrac n 2 \rceil$ 的位置，此时方案数为该字符的出现次数，扣去这个字符之后，剩余偶数个字符。

由于是回文字符串，那么左右是完全对称的，所以我们仅需考虑前 $\lfloor \dfrac n 2 \rfloor$ 位置即可，后面的半段对称。

设前半段空间数量 $m = \lfloor \dfrac n 2 \rfloor$，字符 $c$ 在字符串 $s$ 的出现次数为 $2 \times h$，我们需要在前半段选出 $h$ 个位置给字符 $c$，方案数为 $C_m^h$，那么后半段位置对称，字符串 $c$ 的所有排列情况为 $A_{2h}^{2h}$，那么对于 $c$ 字符的贡献即为 $C_m^h \times A_{2h}^{2h}$，处理完这个字符，由于前半段的位置少了 $h$，我们将 $m$ 减少 $h$，剩余字符同理。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 2e3 + 10, MOD = 1e9 + 7;

int n;
string str;
int h[N];
int fact[N], infact[N];

int qmi(int a, int b, int p)
{
    int res = 1 % p;
    while (b)
    {
        if (b & 1)
            res = (LL)res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}

int C(int a, int b)
{
    return (LL)fact[a] * infact[b] % MOD * infact[a - b] % MOD;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; ++ i )
    {
        fact[i] = (LL)fact[i - 1] * i % MOD;
        infact[i] = qmi(fact[i], MOD - 2, MOD);
    }
    
    cin >> n >> str;
    int m = n;
    for (auto c: str)
        h[c - 'a'] ++;
    
    int res = 1;
    int cnt = 0;
    for (int i = 0; i < 26; ++ i )
        if (h[i] & 1)
        {
            res = h[i];
            h[i] --;
            cnt ++;
        }
    
    if (cnt > 1)
    {
        cout << fact[n] << endl;
        return 0;
    }
    
    n /= 2;
    for (int i = 0; i < 26; ++ i )
    {
        res = (LL)res * C(n, h[i] / 2) % MOD * fact[h[i]] % MOD;
        n -= h[i] / 2;
    }
    
    cout << ((LL)fact[m] - res + MOD) % MOD << endl;
    
    return 0;
}
```

---

## 作者：Genius_Star (赞：3)

### 思路：

直接求出非回文串的个数不好求，考虑容斥一下，求出所有是回文串的数量，然后用 $n!$ 减去即可。

设 $cnt_c$ 表示字符 $c$ 出现的次数。

考虑对于 $n$ 分奇偶讨论。

当 $n$ 为偶数时：

- 若存在一个 $c$ 使得 $2 \nmid cnt_c$，此时不可能构成回文串，答案为 $n!$。

- 否则 $\forall c, 2 \mid cnt_c$，答案是：

$$(\frac{n!}{2}) \Big( \prod_{i = 0}^{25} A_{cnt_i}^{\frac{cnt_i}{2}} \Big)$$

- 即考虑对于每种字符，选出其一半出来放在左半部分（这里是组合），然后对于右半部分是左半部分对称过来的，即每个位置填的字符是固定的，然后对于没有选择的那一半，在右边可以随意排列，故方案数是 $\binom{cnt_i}{\frac{cnt_i}{2}} (\frac{cnt_i}{2})! = A_{cnt_i}^{\frac{cnt_i}{2}}$。

- 注意是**乘法原理**（因为每个是单独考虑的）。

- 最后还乘上一个 $(\frac{n!}{2})$ 是因为我们只确定了左半部分的组合，乘上一个全排列的方案即可。

当 $n$ 为奇数时：

- 若存在一个以上的 $i$ 使得 $2 \nmid cnt_i$ 显然无解，方案数为 $n!$。

- 否则设 $2 \nmid cnt_i$，则必须将 $i$ 这个字符放在中间即 $\frac{n + 1}{2}$ 这个位置。

- 然后对于 $j \ne i$，其方案数是 $A_{cnt_i}^{\frac{cnt_i}{2}}$。

- 考虑 $i$ 的情况，首先选出 $\frac{cnt_i - 1}{2}$ 放左边，然后还剩下 $\frac{cnt_i + 1}{2}$ 个，可以任选一个方在中间（方案数是 $\frac{cnt_i + 1}{2}$），然后再将右边的 $\frac{cnt_i - 1}{2}$ 个全排列。

- 故对于 $i$ 的方案数是 $A_{cnt_i}^{\frac{cnt_i - 1}{2}} (\frac{cnt_i + 1}{2})$。

数据范围很小，对于上面的直接暴力计算即可，时间复杂度为 $O(\sum cnt_i = N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=27,M=3030,mod=1e9+7;
ll read(){
	ll x;
	scanf("%lld",&x);
	return x;
}
void write(ll x){
	printf("%lld",x);
}
ll n,k,sum=1,ans=1;
ll a[N];
string s;
int main(){
	n=read();
	cin>>s;
	for(int i=2;i<=n;i++)
	  sum=(sum*i)%mod;
	for(int i=0;i<n;i++)
	  a[s[i]-'a']++;
	for(int i=0;i<26;i++)
	  if(a[i]&1)
	    k++;
	if(n%2==0){
		if(k){
			printf("%lld\n",sum);
			exit(0);
		}
	}
	else{
		if(k>1){
			printf("%lld\n",sum);
			exit(0);
		}
	}
	for(int i=0;i<26;i++){
        for(int j=(a[i]-(a[i]>>1)+1);j<=a[i];j++)
          ans=(ans*j)%mod;
		if(a[i]&1) 
		  ans=(ans*(a[i]-(a[i]>>1)))%mod;	
	}
	for(int i=(n>>1);i>=2;i--) 
	  ans=(ans*i)%mod;	
	printf("%lld\n",(sum-ans+mod)%mod);
	return 0;
}
```

这是几年前写的 code 了，码风可能有点不好看，见谅。

---

## 作者：Digital_Sunrise (赞：3)

## P5684题解
### 写在前面
注意：本篇题解着重点在于讲解易错点

[传送门](https://www.luogu.com.cn/problem/P5684)

这是一道考细心的题目。

Update : $\LaTeX$ 与汉字之间补充空格，完善公式
### 正文
**题目描述**

给定一个字符串，求此字符串的字符一共可以组成多少非回文字符串（全部用上）

**坑点1**:每一个字符都有对应的名称及编号，说明**数值相同的字符也是不同的**

**思路**

非回文字符串数量 = 全部字符串数量 - 回文字符串数量

全部字符串数量很简单，就是一个全排列: $n!$

而回文字符串数量可以这么理解：

挑选完左边一半数量的字符，在生成时向右对称即可。

所以，我们把每一个字符取一半数量在左边排列即可。

如果记对于每一个字符 $c$ ,它的出现次数为 $sum_c$

则回文串次数为:

$$C_{len/2}^{sum_{s[1]}} \times C_{len/2 - sum_{s[1]}}^{sum_{s[2]}} \times C_{len/2 - sum_{s[1]}- sum_{s[2]}}^{sum_{s[3]}}$$
$$...$$
$$C_{len/2 - sum_{s[1]}- sum_{s[2]}- sum_{s[3]} -...-sum_{s[n-1]}}^{sum_{s[n]}}$$

(以上 " $/2$ " 均代表下取整)

**坑点2**: $sum_c$ 的值有可能不为偶数。

当有一个 $sum_c$ 的值为奇数时，就把多出来的放在中间。

但是当有大于等于2个的 $sum_c$ 的值时，就没有足够的位置了，无法构造回文式，直接特判输出 $n!$ 。

**坑点3**: 与坑点1相似，每一个字符都是本质不同的，所以应该将上式改为:

$$A_{len/2}^{sum_{s[1]}} \times A_{len/2 - sum_{s[1]}}^{sum_{s[2]}} \times A_{len/2 - sum_{s[1]}- sum_{s[2]}}^{sum_{s[3]}}$$
$$...$$
$$A_{len/2 - sum_{s[1]}- sum_{s[2]}- sum_{s[3]} -...-sum_{s[n-1]}}^{sum_{s[n]}}$$

然后答案就是 $n!$ 减去上式的值了。

**坑点4**: 由于题目有取模操作，所以取模后的数大小关系可能发生改变。

话句话说， $n!$ 取模后的值可能比上式还小。

还需要特判小于的情况（没判断是50分）。

### Code

$A$ 运算用[逆元](https://www.luogu.com.cn/problem/P3811)实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9 + 7;
const int maxn = 2e3 + 5;

int len;
string s;
int sum[30];
int num;
int nn;
int fac[maxn];

int pow(int x,int y)
{
	int cnt = 1;
	while(y)
	{
		if(y & 1)
		{
			cnt *= x;
			cnt %= mod;
		}
		x *= x;
		x %= mod;
		y >>= 1;
	}
	return cnt;
}

int C(int n,int m)
{
	if(n == 0)
		return 1;
	int ans = 1;
	for(int i = m;i >= m - n + 1;i--)
		ans *= i,ans %= mod;
	return ans * pow(fac[n],mod - 2) % mod;
}

signed main()
{
	cin >> len;
	cin >> s;
	fac[0] = fac[1] = 1;
	for(int i = 2;i <= len;i++)
		fac[i] = fac[i - 1] * i % mod;
	for(int i = 0;i < len;i++)
		sum[(s[i] - 'a') + 1]++;
	for(int i = 1;i <= 26;i++)
	{
		if(sum[i] % 2 == 1)
			num++;
	}
	if(num >= 2)
	{
		cout << fac[len];
		return 0;
	}
	nn = len / 2;
	num = 1;
	for(int i = 1;i <= 26;i++)
	{
		if(nn == 0)
			break;
		num *= C(sum[i] / 2,nn);
		num %= mod;
		num *= fac[sum[i]];
		num %= mod;
		nn -= sum[i] / 2;
	}
	cout << (fac[len] - num < 0 ? fac[len] - num + mod : fac[len] - num);
	return 0;
}
```

---

## 作者：Monkey_Dog (赞：2)

**整体思路**：
   - 首先计算所有可能的排列数，即 $n$ 个字符的全排列数。
   - 然后分析能构成回文串的排列数，从总的排列数中减去回文串的排列数，就得到非回文串的排列数。
对于回文串，先统计每个字符出现的个数，因为回文串两边相同，出现个数为奇数的字符只能有一个。所以当出现个数为奇数的字符大于一个时，非回文串的排列数就是全排列数。

对于第 $i$ 种字符，其出现次数为 $a_i$。因为回文串是对称的，所以对于每个字符，我们只考虑其一半的排列情况。计算其一半（$a_i / 2$）的排列数，根据多重集的排列公式，其排列数为：
$$\frac{(\frac{a_i}{2})!}{b_1!b_2!...b_m!}$$
其中 $b_j$ 是将 $\frac{a_i}{2}$ 个元素分成 $m$ 组的不同分组方式，在此题中，因为是两两配对，所以这里 $m = 1$，公式可简化为 $(\frac{a_i}{2})!$。

我们需要对所有字符都进行这样的计算，并将它们相乘，即：
$$\prod_{i=0}^{25} (\frac{a_i}{2})!$$

但是，我们还需要考虑一种字符多次出现的情况。最终即可得出：
$$ans=(\frac{n}{2})! \times\prod_{i=0}^{25} \frac{a_i!}{(\frac{a_i}{2})!}$$

 **代码实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[30],Mod=1e9+7,sum;
char c;
int A(int x){
	int num=1;
	for(int i=1;i<=x;i++)num*=i,num%=Mod;
	return num;
}
int B(int m){
	int num=1;
	for(int i=m/2+1;i<=m;i++)num*=i,num%=Mod;
	return num;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>c,a[c-'a']++;
	for(int i=0;i<26;i++)if(a[i]&1)sum++;
	if(sum>1){cout<<A(n)%Mod;return 0;}
	else{
		int num=A(n),m=A(n/2);
		for(int i=0;i<26;i++)m*=B(a[i])%Mod,m%=Mod;
		cout<<(num-m+Mod)%Mod;
	}
}
```
时间复杂度：计算全排列数的时间复杂度为 $O(n)$，统计字符出现次数的时间复杂度为 $O(n)$，计算回文串排列数的时间复杂度也为 $O(n)$，所以总的时间复杂度为 $O(n)$。

---

## 作者：GoldenSTEVE7 (赞：1)

## 题目大意
给定一个字符串，求有多少种方式将其排列为一个不是回文串的字符串。

## 思路
首先暴力枚举显然是不行的。我们考虑算出回文串的个数，再用总个数减去回文串的个数就能得到非回文串的个数。

那我们就来想想回文串的个数怎么求。

1. 我们要把每个字母的出现次数统计出来，对于第 $i$ 个字符，我们用 $cnt_i$ 表示。

2. 接下来我们要对某个字符去分配它的位置。令 $t = \lfloor n \div 2 \rfloor$，由于回文串的对称性，我们需要分配 $\lfloor cnt_i \div 2 \rfloor$ 个位置给这个字符。（即为只考虑字符个数的一半）而可供分配的位置数量有 $t-\displaystyle\sum_{k=1}^{i} \lfloor cnt_k \div 2 \rfloor$，因为前面的位置已被分配，就会减少一些位置，需要减掉。那么对于第 $i$ 个字符，方案数就是 $\displaystyle\binom{t-\sum_{k=1}^{i} \lfloor cnt_k \div 2 \rfloor}{\lfloor cnt_i \div 2 \rfloor} \times cnt_i$。

3. 但是我们要注意一个问题，如果有 $2$ 个以上的 $cnt_i$ 满足 $2 \nmid cnt_i(1 \le i \le 26)$，那么无论如何它都无法形成回文串。这一部分特判即可。

综上我们就能求出题目所求。

## 代码实现
组合数求法就用组合数的递推公式即可。其他部分直接摸拟即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;

int c[2005][2005];
int cnt[2005];

int main()
{
	int n;
	cin >> n;
	string s;
	cin >> s;
	long long ans = 1;
	int t = n / 2;
	for(int i = 0; i < n; i++)
	{
		cnt[s[i]-'a']++;
	}
	for(int i = 0; i <= 2000; i++)
    {
		for(int j = 0; j <= i; j++)
		{
			if(i == j || j == 0)
				c[i][j] = 1;
			else
				c[i][j] = c[i-1][j]+c[i-1][j-1];
			c[i][j] %= mod;
		}
	}//组合数递推
	int sum = 0;
	for(int i = 0; i < 26; i++)
	{
		sum += cnt[i]%2;
		ans = ans * c[t][cnt[i]/2] % mod;
		for(int j = 1; j <= cnt[i]; j++)
		{
			ans = 1ll * ans * j % mod;
		}
		t -= cnt[i]/2;
	}//求解
	if(sum >= 2) ans = 0;
	long long a = 1;
	for(int i = 1; i <= n; i++)
	{
		a = 1ll * a * i % mod;
	}
	cout << ((a - ans)%mod+mod)%mod;//减法的取模要注意符号问题
	return 0;
}
```

---

## 作者：lcfollower (赞：1)

一下默认字符串下标从 $1$ 开始。

---

正难则反，即所有的方案数去除回文串的方案数即为答案，明显所有方案数为 $n$ 个字符全排列为 $A_{n}^{n}$。

~~一眼动规，但是直接没思路。~~

前 $2$ 个子任务是搜索，光搜索可以通过子任务 $1$，而子任务 $2$ 给予了我们提示：

把字符串长度设为 $n$，分为如下两种情况：

- $n$ 为奇数，那么确定第 $\frac{n+1}{2}$ 个字符左右两边相反。

- $n$ 为偶数，前 $\frac{n}{2}$ 个字符和剩下的字符相反。

也就是说，确定了前 $\frac{n}{2}$ 个字符，就能分情况确定回文串个数。这样就能用搜索通过子任务 $2$。

---

通过上面的提示，容易想到排列组合。

先判断无解的情况，需要知道的是，所有字符个数（若 $n$ 为奇数则去除 $s_{\frac{n+1}{2}}$ 的统计）一定是偶数。

然后根据这个判断无解，即存在 $sum_{s_i}\ne 0$，这时候答案为 $A_{n}^{n}$。

然后考虑计算回文串的数量。

- $n$ 为偶数，每次选出 $\frac{sum_{s_i}}{2}$ 进行全排列，根据乘法原理乘起来，方案数即为 $\prod\limits_{ch\in s} C_{sum_{ch}}^{sum_{\frac{ch}{2}}}\times A_{sum_{ch}}^{sum_{\frac{ch}{2}}}$，其中 $ch$ 表示字符。

- $n$ 为奇数，去除最中间的，剩余的和偶数一样，最后乘上最中间的字符的个数即可。

然后减去不合法数量即为答案。

注意**取模**。

---

```cpp
#include <bits/stdc++.h>

#define int long long
#define rint register int

using namespace std;

const int P = 1e9 + 7;
int n ,fact[2005] ,inv[2005] ,sum[30];
string s;
bool mp[2005][2005];

inline void fre(){
  freopen("palace.in" ,"r" ,stdin);
  freopen("palace.out" ,"w" ,stdout);
} inline int Qmul(int a, int b){
  int res = 0;
  for( ; b > 0 ; b >>= 1ll , a = (a + a) % P)
    if(b & 1) res = (res + a) % P;
  return res; 
}inline int Qpow(int a, int b){
  int res = 1;
  for( ; b > 0 ; b >>= 1ll , a = Qmul(a ,a))
    if(b & 1) res = Qmul(res ,a);
  return res;
} inline int C(int m ,int n){
  return fact[n] * Qpow(fact[n - m] ,P - 2) % P * Qpow(fact[m] ,P - 2) % P;
} signed main(){
  scanf("%lld" ,&n);
  fact[0] = 1;
  for(rint i = 1;i <= 2000 ;i ++) fact[i] = fact[i - 1] * i % P;
  for(rint i = 1;i <= 2000 ;i ++) inv[i] = Qpow(i ,P - 2);//预处理阶乘和阶乘逆元。

  cin >> s; 
  s = '@' + s;
  for(rint i = 1;i <= n; i ++)
    sum[s[i] - 'a'] ++;
/*判无解。这里我分了奇偶两种情况判断。*/
  int s = 0;
  for(rint i = 0;i <= 25; i ++){
  	if(!(n & 1)){
  	  if(sum[i] & 1){
  	    printf("%lld\n" ,fact[n]);
		exit(0);	
	  }	
	} else{
	  s += (sum[i] & 1);
	}
  } if((n & 1) && s != 1){
  	printf("%lld\n" ,fact[n]);
  	exit(0);
  }
/*统计回文串数量。*/
  if(n % 2 == 0){
  	int half = (n / 2) ,ans = 1;
  	for(rint i = 0 ;i <= 25;i ++)
  	  if(sum[i]) ans = ans * C(sum[i] / 2 ,sum[i]) % P * fact[sum[i] / 2] % P;
	ans = ans * fact[half] % P;
	printf("%lld\n" ,(fact[n] - ans + P) % P);//注意减去是结果可能为负数，在模 P 意义下要加上 P 再取模。
  } else{
  	int t = 1;
  	for(rint i = 0 ;i <= 25;i ++)
  	  if(sum[i] & 1){
  	    t = sum[i];//中间字母出现的个数。
		sum[i] --;
		break;
	  }
	int ans = t ,half = (n / 2);
  	for(rint i = 0 ;i <= 25;i ++)
  	  if(sum[i]) ans = ans * C(sum[i] / 2 ,sum[i]) % P * fact[sum[i] / 2] % P;
	ans = ans * fact[half] % P;
	printf("%lld\n" ,(fact[n] - ans + P) % P);	
  }
  return 0;
}
```

---

## 作者：yanxu_cn (赞：0)

题目要求求解非回文串。显然不太好求，于是我们正难则反，求解回文串数量。

首先，总的串的数量是 $n\hspace{.02cm}{!}$ 。这个应该不用证明。

显然，在任何情况下均只能接受至多一个字符的数量为奇数，如果奇数数目严格大于 $1$，那么自然没有回文串的情况。

对于剩下的情况，需要分奇偶性讨论。

以下我们记 $m=\left ⌊ \displaystyle{\large\frac{n}{2}} \right ⌋$。

对于 $1\sim m$ 的位置，我们直接在可以满足后面的情况下随机填充。容易想到存在的情况为 $m\hspace{.02cm}{!}$。然后，对于剩下的位置，对于一个个数为 $k$ 的字符，其情况为 $\frac{\normalsize{k\hspace{.02cm}\large{!}}}{\left\lfloor\normalsize\displaystyle\frac{k}{2}\right\rfloor\large{!}}$ 种，原因在于总共的数目为 $k\hspace{.02cm}{!}$，而前面的 $\lfloor k\rfloor$ 的顺序已经计算过了，故将其除去。

乘法原理都乘起来就好了。

复杂度低于 $n^2$。显然暴力计算是可以接受的。

贴下代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr long long mod=1e9+7ull;
int cnt[31],p;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n;
	long long tt=1;
	cin>>n;
	string str;
	cin>>str;
	for(int i=0;i<str.length();i++)
	{
		cnt[str[i]-'a']++;
	}
	for(int i=1;i<=n;i++)
	{
		tt=tt*i%mod;
	}
	for(int i=0;i<26;i++)
	{
		if(__builtin_expect(!!(cnt[i]&1),0))
		p++;
	}
	while(p>1)
	{
		cout<<tt<<'\n';
		return 0;
	}
	long long ans=1;
	for(int i=(n>>1);i>=2;i--)
	ans=ans*i%mod;
	for(int i=0;i<26;i++)
	{
		for(int j=cnt[i]/2+1;j<=cnt[i];j++)
		{
			ans=ans*j%mod;
		}
	}
	cout<<(tt-ans+mod)%mod<<'\n';
	return 0;
}
```

---


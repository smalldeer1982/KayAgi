# [CSP-J 2021] 小熊的果篮

## 题目描述

小熊的水果店里摆放着一排 $n$ 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 $1, 2, \ldots, n$ 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。

## 说明/提示

**【样例解释 #1】**

这是第一组数据的样例说明。

所有水果一开始的情况是 $[1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0]$，一共有 $6$ 个块。

在第一次挑水果组成果篮的过程中，编号为 $1, 3, 5, 8, 9, 11$ 的水果被挑了出来。

之后剩下的水果是 $[1, 0, 1, 1, 1, 0]$，一共 $4$ 个块。

在第二次挑水果组成果篮的过程中，编号为 $2, 4, 6, 12$ 的水果被挑了出来。

之后剩下的水果是 $[1, 1]$，只有 $1$ 个块。

在第三次挑水果组成果篮的过程中，编号为 $7$ 的水果被挑了出来。

最后剩下的水果是 $[1]$，只有 $1$ 个块。

在第四次挑水果组成果篮的过程中，编号为 $10$ 的水果被挑了出来。

**【数据范围】**

对于 $10 \%$ 的数据，$n \le 5$。  
对于 $30 \%$ 的数据，$n \le 1000$。  
对于 $70 \%$ 的数据，$n \le 50000$。  
对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$。

**【提示】**

由于数据规模较大，建议 C/C++ 选手使用 `scanf` 和 `printf` 语句输入、输出。

## 样例 #1

### 输入

```
12
1 1 0 0 1 1 1 0 1 1 0 0
```

### 输出

```
1 3 5 8 9 11
2 4 6 12
7
10
```

## 样例 #2

### 输入

```
20
1 1 1 1 0 0 0 1 1 1 0 0 1 0 1 1 0 0 0 0
```

### 输出

```
1 5 8 11 13 14 15 17
2 6 9 12 16 18
3 7 10 19
4 20
```

## 样例 #3

### 输入

```
见附件中的 fruit/fruit3.in。```

### 输出

```
见附件中的 fruit/fruit3.ans。```

# 题解

## 作者：vegetable_king (赞：211)

在[博客](https://yjh965.github.io/post/csp-j-2021-xiao-xiong-de-guo-lan-ti-jie/)食用更佳。

# 思路

容易想到，可以把每一个块看成一个整体。

由于队列先进先出的特性，可以使用队列维护块。

需要注意的是，当两个块在队列里相邻且元素相同，就可以直接合并。

然后这道题就变成了一道模拟啦！

# 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>

using namespace std;

struct kuai{ // 块
	int st, ed, th;
}f, x, ad;
int n, cnt, t[200002];
queue<kuai> q, q2;
bool used[200001]; // 记录是否被取出
int main(){
	scanf("%d", &n);
	for (int i = 1;i <= n;i ++) scanf("%d", &t[i]);
	t[n + 1] = !t[n];
	for (int i = 2, si = 1;i <= n + 1;i ++){
		if (t[i] != t[i - 1]) q.push((kuai){si, i - 1, t[i - 1]}), si = i; // 把连续一段相同的元素合成一个块
	}
	cnt = n;
	while (cnt){
		while (q.size()){
			f = q.front();
			q.pop();
			while (used[f.st] && f.st <= f.ed) f.st ++; // 如果已经被取了
			if (f.st > f.ed) continue;
			printf("%d ", f.st), cnt --;
			used[f.st] = 1; // 将块的开头元素去掉并输出
			if (f.ed == f.st) continue; // 如果这个块被取完了
			f.st ++;
			q2.push(f); // 先临时存到 q2 里进行合并
		}
		putchar('\n');
		while (q2.size()){
			ad = q2.front();
			q2.pop();
			while (q2.size()){
				x = q2.front();
				if (x.th == ad.th){ // 能合并就合并
					ad.ed = x.ed;
					q2.pop();
				}
				else break;
			}
			q.push(ad); // 丢回 q 里
		}
	}
}
```

# 关于时间复杂度

原本，在这种做法里，每一个水果只会被删除一次，最多会删除 $n$ 次。但是，我的代码实现的可能不太好，最坏时间复杂度是 $O(n \sqrt n)$ 的，为了保留每个元素原本的位置，我使用了一个 `bool` 数组，对每块里的数进行类似于懒惰删除法的操作（见代码中“如果已经被取了”一行），构造 `00000000111111000011011000011111100000000` 这样的数据可以将这部分卡到移动 $O(n \sqrt n)$ 次。像这样的做法实现应该是可以做到 $O(n)$ 的，如果做到了，欢迎与作者讨论实现方式。

---

## 作者：_StarBird_ (赞：189)

看到99%的人都写了链表，我来说一个清新做法……

这题考场上想到了链表正解，结果写挂了还™没调出来，写了个暴力有70海星，CSP正解暴力区分度真是低，就因为这个导致我T3没判前导0直接65pts 哎

考完教练跟我们说了这种做法.

------------
大概就是先记录所有苹果和橘子的位置，然后轮流取，保证取的下标递增，取完就换行再从头开始。

以样例1为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/58xt9a3m.png)

然后找到两坨里的最小值，这里是1，然后把1取了

接下来就取0的这一坨大于之前所取数的最小值，这里是3

大概就是这样交替取，取到不能取为止

图就变成了这样

![](https://cdn.luogu.com.cn/upload/image_hosting/8696qjun.png)

我们发现，取的所有数就是第一轮中放到果篮里的数，所以对剩下的数这样继续做就行了。

易得在一堆取完后，另一堆会剩一个区间，一个一个输出就好了

我们发现这东西能用 set 维护，查找是 $\log n$ 的，删除 erase 是 $\log n$ 的，就能过了，复杂度 $O(n\log n)$ 。

$\mathfrak{m} \mathtt{y} \mathrm{c} \sigma \mathbf{d} \mathsf{e} :$ 


```cpp
#include<bits/stdc++.h>
#define INF 200010
using namespace std;
int n;
set<int>s1,s2;//把下标扔在两个set里 
int main()
{
	scanf("%d",&n);
	s1.clear();
	s2.clear();
	int q;
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&q);
		if (q) s1.insert(i);
		else s2.insert(i);
	}
	s1.insert(INF);//这里塞INF的原因是防止set空后的出错 
	s2.insert(INF);
	int nw=0;
	bool p=*s1.begin()<*s2.begin()?0:1;//这里是找两种东西最小下标的小值，p是当前删的东西 
	while(!p && s1.size()>1 || p && s2.size()>1)//因为有个INF，所以size要>1 
		if (!p)
		{
			nw=*s1.upper_bound(nw);//upper_bound找下一个 
			if (nw==INF)//找不完了就从头开始 
			{
				nw=0;
				p=*s1.begin()<*s2.begin()?0:1;//p要重新选 
				puts("");
				continue;
			}
			printf("%d ",nw);//取了，输出，删除 
			s1.erase(nw);
			p=!p;//取另外一坨 
		}
		else//同上 
		{
			nw=*s2.upper_bound(nw);
			if (nw==INF)
			{
				nw=0;
				p=*s1.begin()<*s2.begin()?0:1;
				puts("");
				continue;
			}
			printf("%d ",nw);
			s2.erase(nw);
			p=!p;
		}
	puts("");//最后一个果篮是没换行的 
	while(s1.size()>1) printf("%d\n",*s1.begin()),s1.erase(*s1.begin());//一坨取完以后，另外一堆是一个区间，一行一行输出 
	while(s2.size()>1) printf("%d\n",*s2.begin()),s2.erase(*s2.begin());//同上 
	return 0;
}
```

其他几点：

1. 这里塞INF是因为不塞INF而判end的话，后面再找upper_bound会找到end会炸
2. 不能删到底就从头开始，因为可能另外一堆还有东西要删
3. 这个做法在水果种类多的情况下前途很好，多开几个set轮流取就好了

大概就是这样了叭~

---

## 作者：lcyxds (赞：49)

# 题目描述
小熊的水果店里摆放着一排 $n$ 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 $1$、$2$、$3$、……、$n$ 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。
# 题解
首先对输入序列建双向链表，维护每一个“假块”头建双向链表，共维护两个链表。

这里的“假块”指每个“假块”中水果种类必定相同，但相邻“假块”中水果种类可能相同。

我们可以使用双向链表的删除元素来模拟吃一个水果。

不断循环遍历“假块”头链表，遍历过程中记录上一个被吃水果种类。遍历到某个块头时，若其指向的水果与上一个被吃水果种类相同，直接将这个块头删除，相当于合并块；若不同，吃掉这个水果，更新上一个被吃水果种类，将这个块头指向的水果变成被吃水果的下一个水果。

关于一个假块被吃完的处理方法，此时这个假块的块头一定会指向下一个块头。若这个块头的种类与被吃水果的种类不同，删掉这个块，因为遍历下一个块时将会吃掉这个水果；若相同，不动，因为接下来的过程将会把下一个块的块头删除。这样保证遍历时不会出现长度小于一的假块。若假块没有被吃完，其指向的下一个水果一定与吃掉的种类相同，同样不做任何处理。

每个水果被遍历一次，每个块被删除一次，时间复杂度 $\Theta(n)$。

代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>

using namespace std;

const int MAXN = 2e5+10;

struct Node{
  int prev;
  int val;
  int next;
};

int n;

int shuiguo[MAXN];
Node headList[MAXN];
Node shuiguoList[MAXN];
int cc;

void EatOne(int pos) {
  int prev = shuiguoList[pos].prev;
  int next = shuiguoList[pos].next;
  shuiguoList[prev].next = next;
  shuiguoList[next].prev = prev;
  printf("%d ", pos);
}

void Del(int pos) {
  int prev = headList[pos].prev;
  int next = headList[pos].next;
  headList[prev].next = next;
  headList[next].prev = prev;
}

void Chi() {
  int solo = headList[0].next;
  int nowcolor = shuiguo[headList[solo].val];
  while (solo!=cc+1) {
    if (shuiguo[headList[solo].val]!=nowcolor) {
      Del(solo);
      solo = headList[solo].next;
      continue;
    }
    EatOne(headList[solo].val);
    headList[solo].val = shuiguoList[headList[solo].val].next;
    if (shuiguo[headList[solo].val]!=nowcolor) {
      Del(solo);
    }
    solo = headList[solo].next;
    nowcolor^=1;
  }
  putchar('\n');
}

int main() {
  scanf("%d", &n);
  shuiguoList[0].next = 1;
  for (int i = 1; i <= n; i++) {
    scanf("%d", &shuiguo[i]);
    shuiguoList[i].prev = i-1;
    shuiguoList[i].next = i+1;
  }
  shuiguo[0] = 2;
  shuiguo[n+1] = 2;
  headList[0].next = 1;
  for (int i = 1; i <= n; i++) {
    if (shuiguo[i]!=shuiguo[i-1]) {
      cc++;
      headList[cc].prev = cc-1;
      headList[cc].next = cc+1;
      headList[cc].val = i;
    }
  }
  while (shuiguoList[0].next!=n+1) {
    Chi();
  }
  return 0;
}

```


---

## 作者：SSerxhs (赞：37)

考虑维护每个连续段的长度和颜色，每次枚举连续段并将长度减一。如果长度为 $0$，合并两侧连续段。一个容易的实现方式是将非空连续段放入栈内，每次入栈时与栈顶比较颜色。

但这种方法不好维护编号。考虑直接使用 pbds 的平衡树暴力维护还剩哪些编号，那每次查第 $k+1$ 小就知道编号了，$k$ 是前面连续段的总长。

举个例子，`1 1 0 1 1 0 0`，我们用 $(length,color)$ 表示长度与颜色，那么序列转化为 $(2,1),(1,0),(2,1),(2,0)$。

枚举这四个二元组，长度减一，$(2,1),(1,0),(2,1),(2,0)\to (1,1),(1,0),(2,1),(2,0)\to(1,1),(0,0),(2,1),(2,0)$

此时注意到第二个长度已经为 $0$，合并两侧二元组变为 $(3,1),(2,0)$。

继续长度减一（注意上一次枚举到的 $(1,0)$ 的下一个现在变为了 $(3,1)$），变为 $(2,1),(2,0)\to (2,1),(1,0)$。这样已经成功维护了所有连续段长度。

那么怎么知道编号呢？

初始状态编号集合为 $1,2,3,4,5,6,7$。删去 $(2,1)$ 最左侧元素时，前面没有元素，删去的是最小值 $1$。集合变为 $2,3,4,5,6,7$。

当删去 $(1,0)$ 的最左侧元素时，注意此时四个二元组分别为 $(1,1),(1,0),(2,1),(2,0)$，$(1,0)$ 之前有总长为 $1$ 个水果仍然存在，因此需要输出的是当前编号第 $1+1$ 小的元素，即为 $3$。

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
struct Q
{
	int len,v;
	Q(int a,int b):len(a),v(b){}
};
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);
	int n,i,x;
	tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> s;
	cin>>n;
	for (i=1;i<=n;i++) s.insert(i);
	vector<Q> a;
	for (i=1;i<=n;i++)
	{
		cin>>x;
		if (!a.size()||a.back().v!=x) a.emplace_back(1,x); else ++a.back().len;
	}
	while (a.size())
	{
		vector<Q> b;
		int t=0;
		for (auto &[x,y]:a)
		{
			int ans=*s.find_by_order(t);
			cout<<ans<<' ';
			s.erase(ans);
			if (--x)
			{
				if (!b.size()||b.back().v!=y) b.emplace_back(x,y); else b.back().len+=x;
			}
			t+=x;
		}
		cout<<'\n';
		a=b;
	}
}
```

---

## 作者：nydzsf_qwq (赞：33)

大家都用了队列，就我这个蒟蒻用了一个类似并查集的方法。

#### 解题思路

开一个数组表示每个块的大小，另一个数组存储每一个的开头。

每删除一个数的时候就将这个数和这个数减一相连，形成一些树。

显然一棵树上的数一定是一个区间内的所有数

每次连边的时候都让大的数作为父节点，这样一棵树的根一定是这棵树上最大的数。

这样就可以得出一个数之后下一个没有被删的数是什么。

可用启发式合并的方法降低复杂度。

#### 代码

``` c++
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],b[200005],t[200005],hd[200005],hd2[200005],nxt[200005],fa[200005],sum,cnt,c,ttt;
int find(int i) {
	if(fa[i]!=i) return fa[i]=find(fa[i]);
	return i;
}
void merge(int x,int y) {
	x=find(x),y=find(y);
	if(x>y) swap(x,y);
	fa[x]=y;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]),fa[i]=i;
	++cnt;
	b[1]=1,hd[1]=1;
	for(int i=2;i<=n;++i) {
		if(a[i]!=a[i-1]) ++cnt,hd[cnt]=i;
		++b[cnt];
	}
	while(sum<n) {
		for(int i=1;i<cnt;++i) printf("%d ",hd[i]),merge(hd[i]-1,hd[i]);
		printf("%d\n",hd[cnt]);
		merge(hd[cnt]-1,hd[cnt]);
		sum+=cnt;
		c=0;
		ttt=0;
		for(int i=1;i<=cnt;++i) {
			if(b[i]>1) {
				if(b[i-1]>1||c==0||ttt%2==0) ++c,hd2[c]=find(hd[i])+1,t[c]=0;
				t[c]+=b[i]-1;
				ttt=0;
			}
			else ++ttt;
		}
		cnt=c;
		for(int i=1;i<=cnt;++i) b[i]=t[i],hd[i]=hd2[i];
	}
	return 0;
}
```

---

## 作者：zhongchengsh (赞：28)

## 算法

每个块用一个`vector`记录。每次取完一个果篮后，如果需要合并块，则再扫一遍所有`vector`，然后暴力合并。

## 复杂度分析

设有$k$次取完果篮后需要合并，那时间复杂度是多少呢？取果篮的时间是$O(n)$，因为每个水果最多被取到一次。合并块的时间是$O(kn)$。于是，总的时间复杂度是$O(kn)$。

下面证明，$k≤O(\sqrt{n})$。
* 先看最后一次合并，合并以后至少有$1$块，那么合并前至少有$3$块，所以这次取的果篮里至少有$3$个水果。
* 再看倒数第二次合并，合并后至少有$3$块，那么合并前至少有$5$块，所以这次取的果篮里至少有$5$个水果。
* 再看倒数第三次合并，合并后至少有$5$块，那么合并前至少有$7$块，所以这次取的果篮里至少有$7$个水果。
* ……

依次类推，总共至少有$3+5+7+9+...(2k+1)=O(k^2)$个水果，所以$k$至多是$O(\sqrt{n})$，证毕。

因此，总的时间复杂度$O(kn)≤O(n\sqrt{n})$。而在最坏情况下，`010011000111000011110000011111…`能让本算法达到$O(n\sqrt{n})$的复杂度。

---

## 作者：wangzhiyuan123 (赞：20)

建立两个双向链表，一个是对于每一个数的链表，另一个是对于每一块的链表，后者顺便维护每一个块的开始和结束，如果在初始数列的时候这个数等于上一个数，就合并到上一个数所在的块。    
每一次操作，先枚举每一个块，删除第一个数，如果这个块删除之后就没了，就在块链表里面把这个块删了；如果删除后前后两个数可以合并，就合并这两个块。 
   
每一个数只需要枚举两次，枚举复杂度稳定 $ O(n) $。
```cpp

#include<bits/stdc++.h>
using namespace std;
struct lian{//数链表，同时维护数值 
	int lst,nxt;
	int num;
}a[200005];
struct kuai{//块链表，同时维护这个块的头和尾 
	int lst,nxt=0;
	int bg,ed;
}blk[200005];
int n;
int sumk,lshead=0;
void delnum(int x){
	printf("%d ",blk[x].bg);
	a[a[blk[x].bg].lst].nxt=a[blk[x].bg].nxt;
	a[a[blk[x].bg].nxt].lst=a[blk[x].bg].lst;
	blk[x].bg=a[blk[x].bg].nxt;
}
void delblock(int i){
	blk[blk[i].nxt].lst=blk[i].lst;
	blk[blk[i].lst].nxt=blk[i].nxt;
	sumk--;
}
signed main(){
	freopen("fruit.in","r",stdin);
	freopen("fruit.out","w",stdout);
	scanf("%d",&n);
	a[0].num=1919810;
	for(int i=1;i<=n;i++){//建立链表 
		scanf("%d",&a[i].num);
		a[i].lst=i-1,a[i].nxt=i+1;
		if(a[i].num!=a[i-1].num){
			blk[lshead].nxt=i;
			blk[i].lst=lshead;
			blk[i].bg=i;blk[lshead].ed=i-1;
			lshead=i;
			sumk++;
		}
	}
	blk[lshead].ed=n;
	while(sumk){
		for(int i=blk[0].nxt;i!=0;i=blk[i].nxt){//删除块 
			if(blk[i].bg>blk[i].ed){
				delblock(i);
			}else{//合并块 
				if(a[blk[i].bg].num==a[blk[blk[i].lst].ed].num){
					blk[blk[i].lst].ed=blk[i].ed;
					delblock(i);
				}
			}
		}
		for(int i=blk[0].nxt;i!=0;i=blk[i].nxt){//删数 
			delnum(i);
		}
		if(sumk)putchar('\n');
	}
}
```


---

## 作者：SunsetSamsara (赞：19)

## 分析

这道题我一眼看到：哇，珂朵莉树欸！

于是我就不使用正解的方式做了这道题。

代码呢，很像珂朵莉树的模板。主要就是维护 `set` 保存所有区间，每删除一个数就判断左右区间可不可以合并。注意要判断删空一个区间的情况。

## 代码
```cpp
// Author : Luogu Canstant0x5F3759DF
#include <bits/stdc++.h>
#define lld long long
using namespace std;
#define frein(x) freopen(x, "r", stdin)
#define freout(x) freopen(x, "w", stdout)
struct seg {
	int l, r;
};
bool operator < (const seg & a, const seg & b) {
	return a.r < b.r;
}
set<seg> s;
int n;
int a[300010];
bool del[300010];
void remove(set<seg>::iterator & it) {
	seg x = *it;
	if (!x.l || !x.r) return;
	s.erase(it ++);
	del[x.l] = 1;
	++ x.l;
	while (del[x.l] && x.l <= x.r) ++ x.l;
	if (x.r < x.l) return;
	if (it != s.begin()) {
		set<seg>::iterator jt = it;
		-- jt;
		if (a[jt->r] == a[x.l]) {
			seg t = *jt;
			s.erase(jt);
			t.r = x.r;
			s.insert(t);
			return;
		}
	}
	s.insert(x);
}
int main() {
	frein("fruit.in");
	freout("fruit.out");
	scanf("%d", &n);
	a[0] = -1;
	seg x;
	x.l = x.r = 0;
	for (int i = 1; i <= n; ++ i) {
		scanf("%d", a + i);
		if (a[i] == a[i - 1]) x.r  = i;
		else {
			if (x.l) s.insert(x);
			x.l = x.r = i;
		}
	}
 	s.insert(x);
	set<seg>::iterator it;
	while (s.size()) {
		for (it = s.begin(); it != s.end(); ++ it) 
			printf("%d ", it->l);
		puts("");
		for (it = s.begin(); it != s.end();)
			remove(it);
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```

---

## 作者：Rubidium_Chloride (赞：14)

第一眼看上去以为是神仙分块题/根号分治，没想到 $\mathcal{O}(n)$ 或者 $\mathcal{O}(n\log n)$ 就轻松解决了。

听说 hohodef 写了个类春节十二响的启发式合并还是啥，然后常数被我吊起来打了。

一开始以为是什么奇怪玄学复杂度，最后发现是 $\mathcal{O}(n\log n)$。

事实上可以稍作调整做到 $\mathcal{O}(n)$ 但是比较懒（

## 做法

大概就是说，找到每一个块的块头，然后和一个虚拟点建立“父子关系”，这些就是下次要删掉的点。同时用链表维护一下在序列中的前后继，以及这些点删的顺序。

删的话很方便，如果一个点没有儿子了，那么直接删掉就可以了。

如果这个点还有儿子那么把儿子接到下一次要删的点上。

然后这两个过程中都需要同时在链表上进行修改。

当你把一个块删完的时候判一下前后两个块颜色是不是一样，如果一样那么直接把后面那个块块头连到前面那个块块尾上面去。

只需要链表操作，速度快的一批（

所以为啥只有 $n=200000$ 啊。

## 代码

```
#include<bits/stdc++.h>
#define N 200009
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read(){
	ll x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0',c=getchar();}
	return x*f;
}
ll n,a[N],son[N],nxt[N],pre[N],Son[N],cnt,p[N],tot=1;
void init(){
	n=read();
	a[0]=a[n+1]=-1;
	for(int i=1;i<=n;i++) a[i]=read(),nxt[i]=i+1,pre[i]=i-1;
	for(int i=1;i<=n;i++)
		if(a[i]==a[i-1]) son[i-1]=i;
		else Son[++cnt]=i;
}
void get(){
	while(tot){
		tot=0;
		for(int i=1;i<=cnt;i++){
			if(Son[i]==0) continue;
			p[++tot]=Son[i];
			nxt[pre[Son[i]]]=nxt[Son[i]];
			pre[nxt[Son[i]]]=pre[Son[i]];
			if(son[Son[i]]!=0) Son[i]=son[Son[i]];
			else Son[i]=0;
		}
		for(int i=1;i<=cnt;i++)
			if(Son[i]==0) swap(Son[i],Son[cnt]),cnt--;
		for(int i=1;i<=cnt;i++){
			if(Son[i]==0) continue;
			if(a[pre[Son[i]]]==a[Son[i]]) son[pre[Son[i]]]=Son[i],Son[i]=0;
		}
		if(tot==0) break;
		sort(p+1,p+tot+1);
		for(int i=1;i<tot;i++) printf("%lld ",p[i]);
		printf("%lld\n",p[tot]);
	}
}
int main(){
	//freopen("fruit.in","r",stdin);
	//freopen("fruit.out","w",stdout);
	init();
	get();
	return 0;
}
```

## 复杂度分析

复杂度分析一下，令 $\sum\text{块数}=k$，复杂度是 $\mathcal{O}(k\log k)$（有一个排序），然后我们发现 $\sum\text{块数}=n$，所以复杂度是 $\mathcal{O}(n\log n)$

---

## 作者：山田リョウ (赞：14)

题外话：今年题是不是有点简单啊。。。

这题作为 T4 感觉真的有点简单，我们用一个链表把一个个块连起来，每个块内再用一个链表维护块内有哪些位置的，然后按照题目模拟就行了，由于每个水果最多被删除一次，所以时间复杂度是 $O(n)$ 的。

具体实现是这样的：
1. 遍历每个块，删掉第一个水果，然后判断删掉后是否还有水果，如果还有跳过第 $2$ 步
1. 把它前面还没删掉的那个块和它后面的那个块连在一起，但在连上之前后面那个块也要把第一个水果删掉（因为题目说是**同时**删掉），再把自己删掉。
1. 如果还有块的话，回到第 $1$ 步

考场代码：
```cpp
#include<stdio.h>
#include<ctype.h>
FILE *in=fopen("fruit.in","r"),*out=fopen("fruit.out","w");
namespace fasti{
	char buf[1<<15],*p1=buf,*p2=buf;
	#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,in),p1==p2)?EOF:*p1++)
	inline void read(int&x){
		char c=getc();
		for(;!isdigit(c);c=getc());
		for(x=0;isdigit(c);c=getc())x=(x<<1)+(x<<3)+(c^48);
	}
}
using fasti::read;
int nxt[200010];
struct{
	int nxt,b,e;
}list[200010];
int a[200001],n;
int main(){
	read(n);
	for(int i=1;i<=n;++i)read(a[i]);
	int head=0,tail=0;
	for(int i=1,j;i<=n;i=j){
		list[tail].b=list[tail].e=i;
		for(j=i+1;j<=n&&a[i]==a[j];++j)
			list[tail].e=nxt[j-1]=j;
		list[tail].nxt=tail+1,++tail;
	}
	for(;head!=tail;){
		int last=-1;
		for(int i=head;i!=tail;i=list[i].nxt){
			fprintf(out,"%d ",list[i].b),list[i].b=nxt[list[i].b];
			if(!list[i].b){
				if((~last)&&list[i].nxt!=tail){
					fprintf(out,"%d ",list[i=list[i].nxt].b),list[i].b=nxt[list[i].b];
					if(list[i].b)nxt[list[last].e]=list[i].b,list[last].e=list[i].e;
					list[last].nxt=list[i].nxt;
				}
				else if(~last)list[last].nxt=tail;
				else head=list[i].nxt;
			}else last=i;
		}
		fputc('\n',out);
	}
	fclose(in);
	fclose(out);
	return 0;
}
```

---

## 作者：言琢დ (赞：11)

**upd：加入 AC 代码及其必要注释。**

考虑每个相同的“块”，每次通过一个链表把不同颜色的块链接起来。

每次平推的时候暴力削去所有“块”的公共部分：

假如序列是 `0000011110000111111`，那么

$$a=5,4,4,6$$

我们就削去 $\min\{5,4,4,6\}=4$ 个部分。

容易观察到这样做的上界不高。

考虑两种极端的情况：

$$a=1,1,1,1,1,1,1,\dots$$

这样一次平推之后就可以削掉很多。

$$a=n/k,n/k,\dots$$

$k$ 很小。

这样一次平推之后至少有一个“块”被平推干净，效率也很高。

一种显而意见的让复杂度上去的构造是：

$$a=1,2,\dots,\sqrt{n}$$

这样本算法的时间复杂度就可以证明出是 $O(n\sqrt{n})$，足以通过本题。

---

官方数据出来之后更新一波 AC 代码。

**一个不错的建议是，看上面的题解自行实现，有细节不知道如何实现的再阅读下面的代码。**

事实上，根据一些基本的常识，$2\times10^5\times\log_2(2\times10^5)$ 约为 $3.5\times10^6$。

真实数据中好像没有特别构造这种数据，**因为最慢的点大约 10ms 就过了**。（在洛谷上 10ms 可以视作评测机波动）

```cpp
#include<cstdio>
#include<cstring>
int init(){
	char c = getchar();
	int x = 0, f = 1;
	for (; c < '0' || c > '9'; c = getchar())
		if (c == '-') f = -1;
	for (; c >= '0' && c <= '9'; c = getchar())
		x = (x << 1) + (x << 3) + (c ^ 48);
	return x * f;
}
void print(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int N = (int) 2e5 + 5;
int n, a[N], pos[N]; // pos[i] : 目前待在位置 i 上的水果是 pos[i]
struct Node{ int st, ed; } s[N]; // 记录每个连同块的相关信息（起点，终点）
int mn(int x, int y){ return x < y ? x : y; }
bool vis[N];
int main(){
	n = init();
	for (int i = 1; i <= n; ++i)
        pos[i] = i, a[i] = init();
    int pre = 1, m = 0; a[n + 1] = !a[n];
	for (int i = 2; i <= n + 1; ++i)
        if (a[i] != a[i - 1]) s[++m] = (Node) {pre, i - 1}, pre = i;
    int cnt = 0, nn = n;
    while (cnt < nn) { // 复杂度的保证：可以证明这个循环的总次数不超过 sqrt(n) 次
    	memset(vis, 0, sizeof(vis));
    	int min = N;
    	for (int i = 1; i <= m; ++i) min = mn(min, s[i].ed - s[i].st + 1);
    	for (int k = 0; k < min; ++k, putchar('\n'))
    		for (int i = 1; i <= m; ++i)
    			print(pos[s[i].st + k]), putchar(' '), vis[s[i].st + k] = 1, ++cnt;
    	int len = 0;
    	for (int i = 1; i <= n; ++i) if (!vis[i]) a[++len] = a[i], pos[len] = pos[i];
    	n = len, pre = 1, m = 0; a[n + 1] = !a[n];
    	for (int i = 2; i <= n + 1; ++i)
            if (a[i] != a[i - 1]) s[++m] = (Node) {pre, i - 1}, pre = i;
    }
}
```

---

## 作者：include_BM (赞：10)

建一棵线段树，每个节点存当前区间有多少个苹果/桔子，二分在当前点之后出现的第一个与当前点不同的水果。

若在当前点之后没有与当前点不同的水果，则这一轮已被选完，输出换行并找到整个序列中的一个出现的水果（苹果或桔子都行）。

复杂度稍大，但足以通过本题。

```cpp
//People who believe in miracles are as amazing as miracles themselves.
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}

#define ls  (x<<1)
#define rs  (x<<1|1)
#define mid ((l+r)>>1)
const int N=2e5+10;
int n,tmp,a[N],num[N<<2][2];
inline void pushup(int x){
	num[x][0]=num[ls][0]+num[rs][0],num[x][1]=num[ls][1]+num[rs][1];
}
void build(int x,int l,int r){
	if(l==r) return num[x][a[l]]=1,void();
	build(ls,l,mid),build(rs,mid+1,r);
	pushup(x);
}
void chg(int x,int l,int r,int p){
	if(l==r) return num[x][0]=num[x][1]=0,void();
	if(p<=mid) chg(ls,l,mid,p);
	else chg(rs,mid+1,r,p);
	pushup(x);
}
int que(int x,int l,int r,int p,int q,int k){
	if(p>q) return 0;
	if(l==p&&r==q) return num[x][k];
	if(q<=mid) return que(ls,l,mid,p,q,k);
	if(p>mid) return que(rs,mid+1,r,p,q,k);
	return que(ls,l,mid,p,mid,k)+que(rs,mid+1,r,mid+1,q,k);
}
int erfen(int x,int l,int r,int p,int q,int k){
	if(!num[x][k]) return n+1;

	if(l==r) return l;
	if(q<=mid) return erfen(ls,l,mid,p,q,k);
	if(p>mid) return erfen(rs,mid+1,r,p,q,k);

	if(que(1,1,n,p,mid,k)) return erfen(ls,l,mid,p,mid,k);
	else return erfen(rs,mid+1,r,mid+1,q,k);
}
signed main(){
	n=read();
	for(int i=1;i<=n;++i) a[i]=read();
	build(1,1,n);
	for(int i=1,now=1;i<=n;++i){
		printf("%d ",now),chg(1,1,n,now);
		if(!que(1,1,n,now+1,n,!a[now])){
			now=min(erfen(1,1,n,1,n,a[now]),erfen(1,1,n,1,n,!a[now]));
			putchar('\n');
		}
		else now=erfen(1,1,n,now+1,n,!a[now]);
	}
	return 0;
}
```

---

## 作者：Spasmodic (赞：10)

提供一个考场上的奇怪做法。

考虑维护所有块，在块之间用链表连，每一块也拉个链表维护块内的元素。

每次如果有一块没了就暴力合并，这个复杂度我算不来，大概过不去。

考虑优化成启发式合并，复杂度就变成最多 $O(n\log n)$，原因是每个元素至多被合并 $\log n$ 次，然后就过去了。

code：
```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define Rep(i,l,r) for(int i=(l);i>=(r);--i)
using namespace std;
typedef deque<int> vec;
const int N=200005;
int n,a[N],cnt,nxt[N],pre[N];
vec block[N];
void merge(int x,int y){
	if(block[x].size()<block[y].size()){
		while(!block[x].empty())block[y].push_front(block[x].back()),block[x].pop_back();
		pre[y]=pre[x];nxt[pre[x]]=y;
	}else{
		for(int t:block[y])block[x].push_back(t);
		nxt[x]=nxt[y];pre[nxt[y]]=x;
	}
}
int main(){
	scanf("%d",&n);
	rep(i,1,n)scanf("%d",&a[i]);
	rep(i,1,n){
		int t=a[i];cnt++;
		while(i<=n&&a[i]==t)block[cnt].push_back(i),i++;
		i--;
	}
	rep(i,1,cnt)pre[i]=i-1,nxt[i-1]=i;
	nxt[cnt]=0,pre[0]=cnt;
	while(nxt[0]){
		for(int i=nxt[0];i;i=nxt[i])printf("%d ",block[i].front()),block[i].pop_front();
		puts("");
		for(int i=nxt[0];i;i=nxt[i])if(!block[i].size()){
			bool domerge=0;int x=pre[i];
			while(i&&!block[i].size())domerge=1-domerge,i=nxt[i];
			if(!x){nxt[0]=i;pre[i]=0;continue;}
			if(!i){nxt[x]=0;pre[0]=x;continue;}
			if(!domerge)nxt[x]=i,pre[i]=x;
			else merge(x,i);
		}
	}
	return 0;
}
```

---

## 作者：Booksnow (赞：9)

# 小熊的果篮

## 题面

小熊的水果店里摆放着一排 $n$ 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 $1, 2, \ldots, n$ 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹-果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。

## 分析

显然，我们可以用一个队列封装一个“块”的状态。

先处理出一开始各个块的状态，然后对于每一轮遍历按照题意**模拟**，取出每个“块”的左端点，记录为答案，然后维护每个“块”的左端点右移一位。

接下来我们只需要考虑如何**维护**这些“块”。

首先，一个块出队的情况比较显然，如果这个“块”的左端点已经大于右端点，说明这个块中的值已经被我取完了，我们不再入队。

那么就会出现被一个 $1$ “块”分开的两个 $0$ “块”有可能拼合成一个“块”的情况。其实，我们没必要在队列里面将其合并，记录前一个“块”的值，如果当前块和前一个块的值相同，说明他们本质上是一个块，跳过即可。

## code

```
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') w*=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
struct node{ int l,r,opt; };
int n,t;
queue<node> q,temp;
vector<int> ans[N];
bool vis[N];
int main()
{
    n=read();
    int l=-1,r=-1,last=-1;
    for(register int i=1;i<=n;i++){
        int x=read();
        if(x!=last){
            if(last!=-1) q.push((node){l,r,last});
            l=i,r=i;
        }
        else r++;
        last=x;
    }
    q.push((node){l,r,last});
    while(!q.empty()){
        t++;
        int last=-1;
        int l,r; 
        while(!q.empty()){
            node now=q.front(); q.pop();
            if(now.opt!=last){
            	if(last!=-1&&l<=r) temp.push((node){l,r,last});
            //	cout<<l<<" "<<r<<endl;
            	while(vis[now.l]) now.l++;
            	vis[now.l]=true;
				ans[t].push_back(now.l),now.l++;
				l=now.l,r=now.r;
            }
            else r=now.r;
            last=now.opt;
    	}
		if(l<=r) temp.push((node){l,r,last});	
        while(!temp.empty()){
            node add=temp.front();
        //    cout<<add.l<<" "<<add.r<<"\n";
            temp.pop(),q.push(add);
        }
    }
    for(register int i=1;i<=t;i++){
        for(register int j=0;j<ans[i].size();j++)
            printf("%d ",ans[i][j]);
        puts("");
    }
    return 0;
}
```

---

## 作者：ylch (赞：7)

[Luogu - P7912](https://www.luogu.com.cn/problem/P7912)

考虑如何用链表维护每一个块的删除操作。

发现一个小规律：下一轮将会被删除的果子，一定是**这一轮被删除的果子的下一个果子**。

但仔细想发现，这一轮被删除的果子的下一个果子，下一轮不一定真的被删除，考虑如何去判断，

当满足以下两个条件的任意一个时，这一轮被删除的果子（假设为 $a[x]$）的下一个果子不会被删除：
1. 当前被删除的果子的下一个果子会在当前轮结束后被合并，成为前一个块的中间部分（这样不在块头，就不会被删除）。

   
   判断标准：当前被删除果子的前一个和后一个相同，说明删除当前果子后，当前果子的前、后两个不同的块会被合并。

   
   代码：`a[lst[x].pre]==a[lst[x].nxt]`
   
2. 当前被删除的果子的下一个果子会在当前轮被删除。

   判断标准：当前果子和下一个果子种类不一样，说明它们都是块（果篮）的开头，都会在这一轮被删掉。


   代码：`a[x]!=a[lst[x].nxt]`

有了上面的基础实现就很简单了。可以每一轮处理出下一轮会被删除的果子的下标，内层循环中，每次删除上一轮处理出的当前轮会被删除的数，同时根据性质继续处理当前轮可能被删除的数。

时间复杂度：这样因为每个数只会被删除一次，复杂度稳定 $O(n)$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct Node{
    int pre, nxt; // 当前节点的前一个节点下标、后一个节点下标
};

void solve()
{
    int n;
    cin >> n;
    vector <int> a(n + 2);
    vector <Node> lst(n + 2); // 模拟双向链表的数组
    vector <int> now; // 下一轮会被删除的果子的下标

    a[0] = a[n + 1] = INT_MAX; // 避免程序判断为a[0]==a[1]，a[n]==a[n+1]
    for(int i = 1; i <= n; i ++){
        cin >> a[i];
        if(a[i] != a[i - 1]){ // 和前一个不相等，说明是当前块的块头，会被删除
            now.push_back(i);
        }
        lst[i].pre = i - 1;
        lst[i].nxt = i + 1;
    }

    lst[0].nxt = 1; // 链接lst[0]和lst[1]
    // while(!now.empty()){ // 这样写也行，如果没有下一轮要被删除的元素了，也退出循环
    while(lst[0].nxt <= n){ // 如果lst[0].nxt > n，说明链表中没有元素了，外层循环自然就结束了
        vector <int> tmp; // 处理出的下一轮会被删除的果子的下标，是now的中继数组
        for(int x : now){
            cout << x << ' ';
            lst[lst[x].nxt].pre = lst[x].pre; // 删除节点x
            lst[lst[x].pre].nxt = lst[x].nxt;
            if(a[lst[x].pre] != a[lst[x].nxt] && a[x] == a[lst[x].nxt]){ // 当前被删除的果子的下一个果子不会在当前轮结束后被合并 且 当前被删除的果子的下一个果子不会在当前轮被删除
                tmp.push_back(lst[x].nxt); // nxt下一轮会被删除
            }
        }
        cout << "\n";
        now = tmp;
    }
}

signed main()
{
    ios :: sync_with_stdio(false), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```

## End

管理员大大辛苦啦~

谢谢大家！

---

## 作者：BreakPlus (赞：3)

## 一个与众不同的做法

感谢洛谷上的 dalao 们，帮我找到这题考场上的问题。

### 思路

线段树维护当前序列。我们把被删除的用 $2$ 来表示，这个序列就是 $[0,1,2]$ 序列。

维护一下区间 $0$ 的数量、$1$ 的数量、$2$ 的数量，然后按题意模拟时，能线段树+二分查找下一个。

在每次取水果时，会有一个查找第一个非 $2$ 元素的操作。考场误写成了 $O(n)$，可谓是大意失荆州。用 $O(log^2)$ 的话常数过大，也会死掉。利用这一元素位置的单调性可以做到这一子问题的总复杂度时 $O(n)$ 的。

### 代码

很丑……

考场代码改编。

```cpp
#include<cstdio>
using namespace std;
const int maxn=2e5+10;
int n,a[maxn],ls[maxn<<2],rs[maxn<<2],v0[maxn<<2],v1[maxn<<2],v2[maxn<<2];
struct Node{
	int n0,n1,n2;
};
inline int read(){
	int x=0; char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+ch-'0',ch=getchar();
	return x;
}
inline void pushup(int pos){
	v0[pos]=v0[pos<<1]+v0[pos<<1|1];
	v1[pos]=v1[pos<<1]+v1[pos<<1|1];
	v2[pos]=v2[pos<<1]+v2[pos<<1|1];
}
inline void build(int l,int r,int pos){
	ls[pos]=l,rs[pos]=r;
	if(l==r){
		if(a[l]==0) v0[pos]=1;
		else v1[pos]=1;
		return;
	}
	int mid=l+r>>1;
	if(l<=mid) build(l,mid,pos<<1);
	if(mid<r)  build(mid+1,r,pos<<1|1);
	pushup(pos);
}
inline void update(int l,int pos){
	if(ls[pos]==rs[pos]){
		v0[pos]=v1[pos]=0; v2[pos]=1;
		return;
	}
	int mid=ls[pos]+rs[pos]>>1;
	if(l<=mid) update(l,pos<<1);
	else update(l,pos<<1|1);
	pushup(pos);
}
inline Node Union(Node A,Node B){
	Node C;
	C.n0=A.n0+B.n0;
	C.n1=A.n1+B.n1;
	C.n2=A.n2+B.n2;
	return C;
}
inline Node query(int l,int r,int pos){
	if(l<=ls[pos]&&rs[pos]<=r) return (Node){v0[pos],v1[pos],v2[pos]};
	int mid=ls[pos]+rs[pos]>>1; Node ans=(Node){0,0,0};
	if(l<=mid) ans=query(l,r,pos<<1);
	if(mid<r){
		Node tmp=query(l,r,pos<<1|1);
		ans.n0+=tmp.n0,ans.n1+=tmp.n1,ans.n2+=tmp.n2;
	}
	return ans;
}
inline void Update(int s){
	a[s]=2; update(s,1);
} // 线段树板子

// 一定要加 inline，卡常数
bool all=1;
int main(){
 	freopen("fruit.in","r",stdin);
 	freopen("fruit.out","w",stdout);
	n=read();
	int prvi=1;
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=2;i<=n;i++){
		if(a[i]!=a[i-1]) all=0;
	}
	if(all){
		for(int i=1;i<=n;i++) printf("%d\n",i);
		return 0;
	} // 特判，最后一个点需要卡
    // 这是考场上写出来的，不写的话最后一个点洛谷测 1.01s
	build(1,n,1);
	int i=1,prvx=1;
	while(1){
		int too=prvx;
		while(too<=n && a[too]==2) too++;
        // 利用位置单调性找
		i=too; prvx=too;
		if(i==n+1) break;
		printf("%d ",i);
		while(1){
			if(i>n) break;
			int nowcol=a[i];
			int lft=i,rht=n,ans=-1;
			while(lft<=rht){
				int mid=lft+rht>>1;
				Node TMP=query(i,mid,1);
				if(nowcol==0){
					if(TMP.n0+TMP.n2==(mid-i+1)){
						ans=mid;
						lft=mid+1;
					}else rht=mid-1;
				}else{
					if(TMP.n1+TMP.n2==(mid-i+1)){
						ans=mid;
						lft=mid+1;
					}else rht=mid-1;
				}
			}
			if(ans==-1) break;
			Update(i), i=ans+1;
			if(i<=n) printf("%d ",i);
		}
		putchar('\n');
        // 线段树+二分
	}
	return 0;
}
```

---


# [AHOI2012] 树屋阶梯

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/1630.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/1631.png) 



## 说明/提示

- 对于 $40\%$ 的数据，满足 $1\le N\le 20$。
- 对于 $80\%$ 的数据，满足 $1\le N\le 300$。
- 对于 $100\%$ 的数据，满足 $1\le N\le 500$。


## 样例 #1

### 输入

```
3```

### 输出

```
5```

# 题解

## 作者：syksykCCC (赞：199)

发表一下自己关于这题是 **卡特兰数** 的观点。

我们用 $C_i$ 表示 $N = i$ 时的答案。

首先，显而易见，$C_0 = C_1 = 1$。

然后呢？我们画一张图:

![image.png](https://i.loli.net/2020/02/02/1suS8zd7ayCGJwO.png)

图中所示是 $N = 5$ 的情况。

然后我们看到阶梯的右侧是若干拐角，我们标一下号：

![image.png](https://i.loli.net/2020/02/02/eAr3yjZo5StXNHK.png)

很容易发现，这里有 $N$ 个拐角，而题目只允许我们放 $N$ 个矩形，也就是说，**每个矩形恰好覆盖一个拐角**。

为啥？如果一个矩形覆盖的拐角 $<1$，那必然有矩形覆盖的拐角 $>1$。那么比如你的矩形覆盖了两个拐角，你不妨画一画那个矩形长成什么样子，自然就明白是不可能的了。

我们把最左下角叫做 $o$ 点，它肯定要被一个矩形覆盖。

![image.png](https://i.loli.net/2020/02/02/Iro8hzcljpPEiD2.png)

现在，我们枚举一下，覆盖 $o$ 的矩形覆盖了哪一个拐角。

* 覆盖 $1$：

![image.png](https://i.loli.net/2020/02/02/2xksBinHCIXUWrg.png)

那么右边就是一个 $N = 4$ 的子问题！方案数自然是 $C_4$，但也可以认为是 $C_0 \times C_4$。

* 覆盖 $2$：

![image.png](https://i.loli.net/2020/02/02/RJmZdy1kc5qTEbF.png)

上边就是 $N = 1$ 的子问题，右边就是 $N = 3$ 的子问题，根据乘法原理，方案数就是 $C_1 \times C_3$。

* 覆盖 $3$：

![image.png](https://i.loli.net/2020/02/02/KXQ4GyxiBv1cOwz.png)

上边就是 $N = 2$ 的子问题，右边就是 $N = 2$ 的子问题，根据乘法原理，方案数就是 $C_2 \times C_2$。

* 覆盖 $4$：和覆盖 $2$ 同理。

* 覆盖 $5$：和覆盖 $1$ 同理。

于是，根据加法原理，我们就知道 $C_5 = C_0 \times C_4 + C_1 \times C_3 + C_2 \times C_2 + C_3 \times C_1 + C_4 \times C_0$。

更加的一般一点，我们就发现：

$$C_N = \sum_{i = 0}^{N - 1} C_i \times C_{N - i - 1}$$

这就是卡特拉数了，代码这里就不贴出了，求赞 QwQ。

---

## 作者：S_Gloria (赞：81)

## 卡特兰数新思路！
卡特兰数计算公式很多也很繁琐，今天就为大家展示一种很新颖的算法。

卡特兰数定义应该都懂，此处不做赘余。

#### 先讲一下已有的计算公式：
设h(n)为catalan数的第n+1项，令h(0)=1,h(1)=1，

1. catalan数满足递推式：h(n)= h(0) *  h(n-1)+h(1)   *  h(n-2) + ... + h(n-1) * h(0) (n>=2)

>例如：h(2)=h(0) * h(1)+h(1) * h(0)=1 * 1+1 * 1=2

>h(3)=h(0) * h(2)+h(1) * h(1)+h(2) * h(0)=1 * 2+1 * 1+2 * 1=5

2. 另类递推式：

 h(n)=h(n-1) * (4 * n-2)/(n+1);
 
>递推关系的解为：h(n)=C(2n,n)/(n+1) (n=0,1,2,...)

>递推关系的另类解为：h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...)

但是很多时候这些递推式都是不可行的，因为数很大时要涉及取余运算，这时就有x%p==0的情况，于是answer=0，~~就会很快乐的wa掉。~~

### 我自己的方法：
相信大家知道有很多例子都符合卡特兰数列，于是小编给大家带来了题型汇总。
![](https://cdn.luogu.com.cn/upload/pic/74891.png)

这样来说只要找出一个例子证明就好了，我选的是第二个，路径问题。

如图所示：

![](https://cdn.luogu.com.cn/upload/pic/74980.png)

我想从最上面的节点走下来，只能向下或者向右，也就是说某个点只能由上面或者左面延伸过来。很显然的dp（如果还不懂的话参考[数字三角形](https://www.luogu.org/problem/P1216)），那么到达某个点的方案数=左边点的方案数+右边点的方案数。

动态转移方程：
f[i]=f[i]+f[i-1];

f[i]表示到达每一行第i个点的方案数。

### 当然这个题需要高精：
奉上简单明了的代码叭：

```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
int f[550][500];//f[i][j]表示第i个数的第j位。 
int len=1;
void add(int u)
{
	for(int i=1;i<=len;i++)
		f[u][i]=f[u-1][i]+f[u][i];
	for(int i=1;i<=len;i++)
	{
		f[u][i+1]+=f[u][i]/10;
		f[u][i]%=10;
	}
	if(f[u][len+1])len++;
}
int main()
{
	int n,p;
	cin>>n;
	f[1][1]=1;
	for(int i=2;i<=n+1;i++)
		for(int j=1;j<=i;j++)
			add(j);
	for(int i=len;i>0;i--)
		cout<<f[n][i];
}
```




---

## 作者：Sooke (赞：34)

##思路概述

下面的题解都直接指出是卡特兰数，那么这题到底为什么是卡特兰数呢？我来解释下 2 种方法：

###1 . 玄学方法

看到样例输入 3 输出 5，索性想到卡特兰数，但还不能完全确定，先分别枚举大小为 1 和大小为 2 的树屋阶梯：

 ![](https://cdn.luogu.com.cn/upload/pic/9048.png) 

确实有点像卡特兰数，接下来再一一枚举大小为 4 的树屋阶梯所有的方案数，不要遗漏，就基本上能猜出是卡特兰数了。

不过这种方法过于玄学，缺少正确性，具体推理过程请看下一个方法。

###2 . 正常方法

我们发现对于任何大小为 $i$ 的树屋阶梯，都可以由左上角放一块大小为 $j$ 的以及右下角放一块大小为 $i - j - 1$ 的树屋阶梯，再在空缺的地方由单个大块的矩形填充即可构成，这个构成的树屋阶梯一共有 $(j) + (i - j - 1) + 1$ 个钢材，正好是 $i$ 个。因为 j 可以在 0 到 $i - 1$ 取且可以证明每一个构成的树屋阶梯一定各不相同，所以我们可以得到树屋阶梯方案与大小关系的递推式$f_i$ = $f_{i - 1}$ × $f_0$ + $f_{i - 2}$ × $f_2$ + ... + $f_0$ × $f_{i-1}$。同时，我们规定 $f_0$ = $f_1$ = 1。哦，这不就是卡特兰数的递推式吗？于是我们就可以安心将这道题当作卡特兰数的模板题食用了。

举个例子，我们可以怎么构成大小为 4 的树屋阶梯呢？首先有第 1 种构成方法：在左上角放上 1 个任意大小为 0 的树屋阶梯（唔，干脆说就是不放），在右下角放上 1 个任意大小为 3 的树屋阶梯，并在左下角的空缺用单个矩形填充。如图下所示：

 ![](https://cdn.luogu.com.cn/upload/pic/9050.png) 

这种构成方法下，我们能构成可行的树屋阶梯 $f_0$ × $f_3$ = 1 × 5 = 5 个。

第 2 种构成方法：在左上角放上 1 个任意大小为 1 的树屋阶梯，在右下角放上 1 个任意大小为 2 的树屋阶梯，并在左下角的空缺用单个矩形填充。如图下所示：

 ![](https://cdn.luogu.com.cn/upload/pic/9053.png) 

这种构成方法下，我们能构成可行的树屋阶梯 $f_1$ × $f_2$ = 1 × 2 = 2 个。

类似地，还有 2 种构成方法，本质上是和上面的 2 种构成方法是一样的。所有方案数加在一起，得 $f_4 = 14$，正是卡特兰数了。

###求答过程

如果我们按递推来求，复杂度可能会很大，因此，这里使用卡特兰数的通项公式：

$h(n)=\frac{(2n)!}{(n + 1)!\cdot n!}$

使用高精度，实现高精乘单精、高精除单精以及输出高精就可以啦！

##代码实现

```cpp
#include <cstdio>

struct HighPrec{
    int L , A[10001];
};
inline HighPrec Init(){
    // 函数作用： 返回一个初值为 1 的高精度 
    HighPrec H;
    H.L = 1 , H.A[1] = 1;
    return H;
}
HighPrec Mul(HighPrec A , int k){
    // 函数作用： 高精度乘上单精度
    HighPrec H;
    for(int i = 1 ; i <= A.L ; i++)
        H.A[i] = A.A[i] * k; // 乘
    for(int i = 2 ; i <= A.L ; i++)
        H.A[i] += H.A[i - 1] / 10,
        H.A[i - 1] %= 10; // 进位
    H.L = A.L;
    while(H.A[H.L] > 10) // 看原先最高位能不能进位 
        H.A[H.L + 1] = H.A[H.L] / 10,
        H.A[H.L] %= 10, // 进位 
        H.L++; // 增加长度
    return H; 
}
HighPrec Div(HighPrec A , int k){
    // 函数作用： 高精度除以单精度
    HighPrec H;
    int t = 0;
    for(int i = A.L ; i >= 1 ; i--)
        t = t * 10 + A.A[i], // 小学竖式
        H.A[i] = t / k , t %= k;
    H.L = A.L;
    while(H.A[H.L] == 0)
        H.L--; // 看原先最高位有没有被除为 0 并不断退位 
    return H;
}
void OutPut(HighPrec A){
    // 函数作用：输出高精度
    for(int i = A.L ; i >= 1 ; i--)
        printf("%d" , A.A[i]); // 正常套路，逆序输出 
}

HighPrec T;
int n;

int main(){
    scanf("%d" , &n);
    T = Init(); // 赋初值 1
    // 下面的乘除是原公式简化的结果，大家请手动去简化 
    for(int i = n + 2 ; i <= n * 2 ; i++)
        T = Mul(T , i);
    for(int i = 1 ; i <= n ; i++)
        T = Div(T , i);
    OutPut(T); // 输出 
    return 0;
}
```

---

## 作者：zcy2333 (赞：15)

蒟蒻重载运算符版高精，可以使高精数像一般的数一样进行加减乘除，代码附带注释！
```
#include<bits/stdc++.h>
using namespace std;
struct bignum
{
	int len,s[9000];//len为当前的长度，s数组记录当前的各位数字 
	bignum()//每次调用bignum初始化 
	{
		memset(s,0,sizeof(s));
		len=1;
	}
	bignum (int sum) {*this=sum;}//让this指针指向当前整形数字 
	bignum (const char *sum) {*this=sum;}//让this指针指向当前字符串
	bignum operator = (const int sum)//重载等号，方便赋值    ！！！！！注意等号必须在重载加减号之前，减号加号必须在重载乘除号之前， 
	{
		char s[9000];
		sprintf(s,"%d",sum);//将整形数组s映射到字符串当中去 
		*this=s;
		return *this; //将字符串转递到下面字符串赋值的函数中
	}
	bignum operator = (const char *sum) //字符串赋值函数 
	{
		for(int i=0;sum[i]=='0';sum++);
		len=strlen(sum);
		for(int i=0;i<len;i++)
		s[i]=sum[len-i-1]-'0';//方便计算反向存数 
		return *this;
	}
	bignum operator + (const bignum &b)//重载加法，按位相加，注意进位 
	{
		bignum c;
		c.len=0;
		for(int i=0,g=0;g||i<max(len,b.len);i++)
		{
			int x=g;
			if(i<len) x+=s[i];
			if(i<b.len) x+=b.s[i];
			c.s[c.len++]=x%10;
			g=x/10;
		}
		return c;
	}
	void clean()//在高精操作中，可能会出现前导0，需要删去 
	{
		while(len>1&&!s[len-1])
		len--;
	}
	bignum operator * (const bignum &b) //高精乘高精，竖式原理，不懂得话可以自己列个竖式看看 
	{
		bignum c;
		c.len=len+b.len;
		for(int i=0;i<len;i++)
		{
			for(int j=0;j<b.len;j++)
			{
				c.s[i+j]+=s[i]*b.s[j];
			}
		}
		for(int i=0;i<c.len;i++)//进位 
		{
			c.s[i+1]+=c.s[i]/10;
			c.s[i]=c.s[i]%10;
		}
		c.clean();
		return c;
	}
	bignum operator - (const bignum &b) //减法 
    { 
        bignum c;  
        c.len=0;  
        for(int i=0,g=0;i<len;i++)  
        {  
            int x=s[i]-g;  
            if(i<b.len) x-=b.s[i];  
            if(x>=0) g=0;  
            else  
            {  
                g=1;  
                x+=10;  
            }  
            c.s[c.len++]=x;  
        }  
        c.clean();  
        return c;   
    }
  	bool operator < (const bignum &b) //利用字符串来比较 
    {  
        if(len!=b.len) return len<b.len;  //如果字符串长度不一样，必定长度长更大 
        for(int i=len-1;i!=-1;i--)  
        {  
            if(s[i]!=b.s[i]) return s[i]<b.s[i];  //相等的话从字符串最后一位（相当于数的首位）开始逐位比较 
        }  
        return false;  
    }  
    bool operator > (const bignum &b)  //同理
    {  
        if(len != b.len) return len > b.len;  
        for(int i = len-1; i != -1; i--)  
        {  
            if(s[i] != b.s[i]) return s[i] > b.s[i];  
        }  
        return false;  
    }
    bool operator == (const bignum &b)  //不大于不小于肯定就是等于啦~~ 
    {  
        return !(*this>b)&&!(*this<b);  
    }    
	bignum operator / (const bignum &b) //高精除 ，实质上是利用减法的操作 
	{
		bignum c,f=0; 
   	 	for(int i=len-1;i>=0;i--) 
    	{ 
  	   	 	f=f*10;
     		f.s[0]=s[i];
    		while(f==b||f>b)
      	  	{
        		f=f-b;
        		c.s[i]++;
        	}
    	}
		c.len=len; 
		c.clean();
   	 	return c; 
	}
	string str() const 	//为下面的输出做准备 
    {  
        string temp="";  
        for(int i=0;i<len;i++) temp=char(s[i]+48)+temp;  
        return temp;
    } 
};
//下面的输入输出在本蒟蒻看来是玄学方法。。如果记不住就还是用一般的将字符串倒序输出的方式输出吧。。 
istream& operator >> (istream &in,bignum &x) //重载 >> 用cin输入 
{  
    string s;  
    in>>s;  
    x=s.c_str();  //string转化为char
    return in;  
}  
ostream& operator << (ostream &out,const bignum &x)  //重载 << 用cout输出 
{  
    out<<x.str();  
    return out;  
}
int main()
{
//	freopen("xxx.out","w",stdout);
	int n;
	bignum temp1=1;
	bignum temp2=1;
	bignum tmp3=1;
	bignum tmp2=1;
	bignum tmp1=1;
	bignum tmp4=1;
	cin>>n;
	for(int i=1;i<=2*n;i++)
	{
		temp2=i;
		temp1=temp1*temp2;
	}
	for(int i=1;i<=n;i++)
	{
		temp2=i;
		tmp3=tmp3*temp2;
	}
	for(int i=1;i<=n;i++)
	{
		temp2=i;
		tmp2=tmp2*temp2;
	}
	for(int i=1;i<=n-1;i++)
	{
		temp2=i;
		tmp1=tmp1*temp2;
	}
	for(int i=1;i<=n+1;i++)
	{
		temp2=i;
		tmp4=tmp4*temp2;
	}
	cout<<(temp1/(tmp2*tmp3)-(temp1)/(tmp1*tmp4));//回到catalan数，因为有卡特兰数公式catalan(n)=((2n!)/n!*n!) -((2n!)/((n-1)！*(n+1)!))
	cout<<endl;
	return 0;//优雅的结束 
}
```

---

## 作者：swhsz (赞：9)

~~卡特兰数的话打个表就发现了~~

但是显然要用到高精度。

这里用python2写了一发，

短小精悍
```python
a=input()
c=1
for num in range (a+2,a*2+1):
	c=c*num
for num in range (1,a+1):
	c=c/num
print (c)
```

---

## 作者：消失的海岸线 (赞：7)

关于卡特兰数的推导过程楼下说的很好了，在此给出一个比较机智，可读性较高且运行速度飞快的实现：

考虑卡特兰数的通项公式： $h_n = \frac {1}{n+1} \binom{2n}{n} $

其中，同时应用了高精乘除，太傻了。

考虑到答案一定是一个整数，所以将乘除部分按照质因数存储，乘法即答案的相应质因数 $+1$ ，除法则 $-1$ ，可以优化掉高精除低精这个过程。

同时，应用高精度压位技巧，即数组中的每一位存储多个数字，跑的飞起，$luogu$上 0ms AC。

    
    
    
```cpp
    #include <cmath>
    #include <queue>
    #include <cstdio>
    #include <iomanip>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define N 1010
    #define ll long long
    using namespace std;
    inline int read()
    {
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    int n;
    const int W=9;
    const int bit=1000000000;
    #define MAX_LEN 1000
    struct big
    {
        int len;
        ll x[MAX_LEN];
        ll& operator [](int a)
        {return x[a];}
        friend void operator *=(big &a,int b)
        {
            int len=a.len;
            for(int i=1;i<=len;i++)a[i]*=b;
            int now=1;
            while(now<=len)
            {
                if(a[now]>=bit)a[now+1]+=a[now]/bit,a[now]%=bit;
                if(now==len&&a[len+1])len++;
                now++;
            }
            a.len=len;
        }
        void print()
        {
            for(int i=len;i>=1;i--)
            if(i==len)printf("%lld",x[i]);
            else printf("%09lld",x[i]);
        }
    }ans;
    int c[N];
    void add(int x,int v)
    {
        for(int i=2;i*i<=x;++i)
        while(x%i==0)x/=i,c[i]+=v;
        if(x!=1)c[x]+=v;
    }
    int main()
    {
        n=read();
        for(int i=n+2;i<=n+n;++i)add(i,1);
        for(int i=1;i<=n;++i)add(i,-1);
        ans[1]=ans.len=1;
        for(int i=1;i<=n+n;++i)
        while(c[i])ans*=i,--c[i];
        ans.print();
        return 0;
    }

```

---

## 作者：qiianr (赞：4)

这是一道卡特兰数的裸题 [洛谷传送门 biubiu~~](https://www.luogu.org/problemnew/show/P2532)

一般见到阶梯状的图形就去想想卡特兰数~~（会有惊喜）~~

楼上lalao**们**有详细证明，蒟蒻我就不在赘述 [推荐一篇关于卡特兰数的博客](https://blog.csdn.net/duanruibupt/article/details/6869431)

这里告诉大家一种**超级超级快速**的求大整数卡特兰数的方法

怎么形容这个快速呢？大概就是n<=60000的点能在七八百毫秒里过掉~~（自家的评测平台上）~~

在洛谷上过这道题 25ms, 804KB

### 又快又准的秘诀~
```java
根据公式 f(n)=((n+2)*(n+3)*...*(n+n))/(1*2*3*...*n);

我们可以把分子分母都质因数分解，因为卡特兰数求出来一定是正整数，
所以可以预见到分母的质因数一定能被分子的抵消掉
然后就是快速幂+高精乘低精了~
```
### 关于质因数分解的技巧
```cpp
对a进行质因数分解
f[i]记录质因数i的累计总个数
for(int i=2;i*i<=a;i++){
	while(a%i==0)f[i]++,a/=i;
    //为什么可以这样做呢，比如一个8,在i=2的时候已经被约尽了
    //有点像线性筛质数，类比一下
} 
if(a>1) fz[a]++;//很重要，不要漏，也是重要优化
//这让本来要扫到a才结束的循环变为到根号a，大大优化了时间
//很好的针对了a为质数的情况，所以循环也不需要扫到a了
```
### AC代码 

```cpp
#include <cstdio>
#include <iostream>
#define maxn 120005
#define ll long long
using namespace std;
int n,g;
int a,b,fm[maxn],fz[maxn],ans[maxn*100];

int qpow(int a,int b){//快速幂
    int res=1;
    for(;b;b>>=1){
        if(b&1)res=res*a;
        a*=a;
    }
    return res;
}

//ans[0]存大整数的位数
void mul(int x){
    int k=0;//向前一步的进位
    for(int i=1;i<=ans[0];i++){
        ans[i]*=x;
        ans[i]+=k;
        k=ans[i]/10;
        ans[i]%=10;
    }
    while(k){
        ans[++ans[0]]+=k;
        k=ans[ans[0]]/10;
        ans[ans[0]]%=10;
    }
}

int main(){
    scanf("%d",&n);
    for(int i=2;i<=n;++i){
        a=n+i;//(n+2)*(n+3)*...*(2n) 分子
        for(int j=2;j*j<=a;j++){//质因数分解
            while(a%j==0)fz[j]++,a/=j;
        } 
        if(a>1) fz[a]++;
        b=i;//1*2*3*...*n 分母
        for(int j=2;j*j<=b;j++){
            while(b%j==0)fm[j]++,b/=j;
        }
        if(b>1) fm[b]++;
    }
    ans[0]=ans[1]=1;
    for(int i=2;i<=n*2;i++){
        if(fz[i]==0) continue;
        fz[i]=fz[i]-fm[i];
        if(fz[i]==0) continue;
        int x=qpow(i,fz[i]);
        if(x!=1) mul(x);
    }
    for(int i=ans[0];i>=1;--i) printf("%d",ans[i]);//注意要倒序输出
    return 0;
}
```

---

## 作者：Xie_BR (赞：3)

首先这道题是属于卡特兰数范围内的  
# 卡特兰数  
让我们先来分析一下：  
1、首先，这道题需要我们手写一下卡特兰数的初始化。  
2、但是然而却，最恶心的地方就是当你兴致勃勃地敲了20多行代码，交上去，满以为自己可以轻松A掉蓝题的时候，  
# 高精来了！！！  
3、于是我们开始了漫长的与高精搏斗的过程。。。  

本蒟蒻不会什么高级的高精，唯一会的就是重载高精运算符（主要的原因还是因为懒）  
于是我们来一起看一看如何重载高精运算符（附有简短的注释）：

```cpp
struct Bign
{
	int c[MK],len,sign;
	//初始化 
	Bign()
	{
		memset(c,0,sizeof(c));
		len = 1;
		sign = 0;
	}
	//清高位零
	void Zero()
	{
		while(len > 1 && c[len] == 0)
		{
			len--;
		}
		if(len == 1 && c[len] == 0)
		{
			sign = 0;
		}
	} 
	//压位读入 
	void Write(char *s)
	{
		int k = 1,l = strlen(s);
		for(register int i = l - 1;i >= 0;i--)
		{
			c[len] += (s[i] - '0') * k;
			k *= 10;
			if(k == base)
			{
				k = 1;
				len++;
			}
		}
	}
	void Read()
	{
		char s[MK] = {0};
		scanf("%s",s);
		Write(s);
	}
	//输出
	void Print()
	{
		if(sign)
		{
			printf("-");
		}
		printf("%d",c[len]);
		for(register int i = len - 1;i >= 1;i--)
		{
			printf("%04d",c[i]);
		}
		printf("\n");
	} 
	//重载 = 运算符，将低精赋值给高精 
	Bign operator = (int a)
	{
		char s[100];
		sprintf(s,"%d",a);
		Write(s);
		return *this;
	} 
	//重载 < 运算符
	bool operator < (const Bign &a)const
	{
		if(len != a.len)
		{
			return len < a.len;
		}
		for(register int i = len;i >= 1;i--)
		{
			if(c[i] != a.c[i])
			{
				return c[i] < a.c[i];
			}
		}
		return 0;
	}
	bool operator > (const Bign &a)const
	{
		return a < *this;
	}
	bool operator <= (const Bign &a)const
	{
		return !(a < *this);
	}
	bool operator >= (const Bign &a)const
	{
		return !(*this < a);
	}
	bool operator != (const Bign &a)const
	{
		return a < *this || *this < a;
	}
	bool operator == (const Bign &a)const
	{
		return !(a < *this) && !(*this < a);
	}
	bool operator == (const int &a)const
	{
		Bign b;b = a;
		return *this == b;
	}
	//重载 + 运算符
	Bign operator + (const Bign &a)
	{
		Bign r;
		r.len = max(len,a.len) + 1;
		for(register int i = 1;i <= r.len;i++)
		{
			r.c[i] += c[i] + a.c[i];
			r.c[i + 1] += r.c[i] / base;
			r.c[i] %= base; 
		}
		r.Zero();
		return r;
	} 
	Bign operator + (const int &a)
	{
		Bign b;
		b = a;
		return *this + b;
	}
	//重载 - 运算符
	Bign operator - (const Bign &a)
	{
		Bign b,c;// b - c
		b = *this;
		c = a;
		if(c > b)
		{
			Bign t;
			t = b;
			b = c;
			c = t;
			b.sign = 1;
		}
		for(register int i = 1;i <= b.len;i++)
		{
			b.c[i] -= c.c[i];
			if(b.c[i] < 0)
			{
				b.c[i] += base;
				b.c[i + 1]--;
			}
		}
		b.Zero();
		return b;
	} 
	Bign operator - (const int &a)
	{
		Bign b;b = a;
		return *this - b;
	}
	//重载 * 运算符 
	Bign operator * (const Bign &a)
	{
		Bign r;
		r.len = len + a.len + 2;
		for(register int i = 1;i <= len;i++)
		{
			for(register int j = 1;j <= a.len;j++)
			{
				r.c[i + j - 1] += c[i] * a.c[j];
				r.c[i + j] += r.c[i + j - 1] / base;
				r.c[i + j - 1] %= base;
			}
		} 
		r.Zero();
		return r;
	} 
	Bign operator * (const int &a)
	{
		Bign b;b = a;
		return *this * b;
	}
	//重载 / 运算符 
	Bign operator / (const Bign &b)
	{
		Bign r,t,a;
		a = b;
		if(a == 0)
		{
			return r;
		}
		r.len =len;
		for(register int i = len;i >= 1;i--)
		{
			t = t * base + c[i];
			int div,ll = 0,rr = base;
			while(ll <= rr)
			{
				int mid = (ll + rr) / 2;
				Bign k = a * mid;
				if(k > t)
				{
					rr = mid - 1;
				}else
				{
					ll = mid + 1;	
					div = mid; 
				} 
			}
			r.c[i] = div;
			t = t - a * div;
		}
		r.Zero();
		return r; 
	}
	Bign operator / (const int &a)
	{
		Bign b;b = a;
		return *this / b;
	}
	//重载 % 运算符
	Bign operator % (const Bign &a)
	{
		return *this - *this / a * a;
	}
	Bign operator % (const int &a)
	{
		Bign b;
		b = a;
		return *this % b;
	}
};
```

于是，这道题最最最恶心的地方就解决了！！！   
最后，我们来一起愉快的使用重载后的高精运算符吧~~~  
介于有一些嫌弃本蒟蒻粗鲁笨拙的方法的大佬不会使用重载后的高精运算符，所以我就来附上本蒟蒻的AC代码~~~  

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define int long long //懒人专用 
#define MK 510
const int base = 10000;
using namespace std;

struct Bign
{
	int c[MK],len,sign;
	//初始化 
	Bign()
	{
		memset(c,0,sizeof(c));
		len = 1;
		sign = 0;
	}
	//清高位零
	void Zero()
	{
		while(len > 1 && c[len] == 0)
		{
			len--;
		}
		if(len == 1 && c[len] == 0)
		{
			sign = 0;
		}
	} 
	//压位读入 
	void Write(char *s)
	{
		int k = 1,l = strlen(s);
		for(register int i = l - 1;i >= 0;i--)
		{
			c[len] += (s[i] - '0') * k;
			k *= 10;
			if(k == base)
			{
				k = 1;
				len++;
			}
		}
	}
	void Read()
	{
		char s[MK] = {0};
		scanf("%s",s);
		Write(s);
	}
	//输出
	void Print()
	{
		if(sign)
		{
			printf("-");
		}
		printf("%d",c[len]);
		for(register int i = len - 1;i >= 1;i--)
		{
			printf("%04d",c[i]);
		}
		printf("\n");
	} 
	//重载 = 运算符，将低精赋值给高精 
	Bign operator = (int a)
	{
		char s[100];
		sprintf(s,"%d",a);
		Write(s);
		return *this;
	} 
	//重载 < 运算符
	bool operator < (const Bign &a)const
	{
		if(len != a.len)
		{
			return len < a.len;
		}
		for(register int i = len;i >= 1;i--)
		{
			if(c[i] != a.c[i])
			{
				return c[i] < a.c[i];
			}
		}
		return 0;
	}
	bool operator > (const Bign &a)const
	{
		return a < *this;
	}
	bool operator <= (const Bign &a)const
	{
		return !(a < *this);
	}
	bool operator >= (const Bign &a)const
	{
		return !(*this < a);
	}
	bool operator != (const Bign &a)const
	{
		return a < *this || *this < a;
	}
	bool operator == (const Bign &a)const
	{
		return !(a < *this) && !(*this < a);
	}
	bool operator == (const int &a)const
	{
		Bign b;b = a;
		return *this == b;
	}
	//重载 + 运算符
	Bign operator + (const Bign &a)
	{
		Bign r;
		r.len = max(len,a.len) + 1;
		for(register int i = 1;i <= r.len;i++)
		{
			r.c[i] += c[i] + a.c[i];
			r.c[i + 1] += r.c[i] / base;
			r.c[i] %= base; 
		}
		r.Zero();
		return r;
	} 
	Bign operator + (const int &a)
	{
		Bign b;
		b = a;
		return *this + b;
	}
	//重载 - 运算符
	Bign operator - (const Bign &a)
	{
		Bign b,c;// b - c
		b = *this;
		c = a;
		if(c > b)
		{
			Bign t;
			t = b;
			b = c;
			c = t;
			b.sign = 1;
		}
		for(register int i = 1;i <= b.len;i++)
		{
			b.c[i] -= c.c[i];
			if(b.c[i] < 0)
			{
				b.c[i] += base;
				b.c[i + 1]--;
			}
		}
		b.Zero();
		return b;
	} 
	Bign operator - (const int &a)
	{
		Bign b;b = a;
		return *this - b;
	}
	//重载 * 运算符 
	Bign operator * (const Bign &a)
	{
		Bign r;
		r.len = len + a.len + 2;
		for(register int i = 1;i <= len;i++)
		{
			for(register int j = 1;j <= a.len;j++)
			{
				r.c[i + j - 1] += c[i] * a.c[j];
				r.c[i + j] += r.c[i + j - 1] / base;
				r.c[i + j - 1] %= base;
			}
		} 
		r.Zero();
		return r;
	} 
	Bign operator * (const int &a)
	{
		Bign b;b = a;
		return *this * b;
	}
	//重载 / 运算符 
	Bign operator / (const Bign &b)
	{
		Bign r,t,a;
		a = b;
		if(a == 0)
		{
			return r;
		}
		r.len =len;
		for(register int i = len;i >= 1;i--)
		{
			t = t * base + c[i];
			int div,ll = 0,rr = base;
			while(ll <= rr)
			{
				int mid = (ll + rr) / 2;
				Bign k = a * mid;
				if(k > t)
				{
					rr = mid - 1;
				}else
				{
					ll = mid + 1;	
					div = mid; 
				} 
			}
			r.c[i] = div;
			t = t - a * div;
		}
		r.Zero();
		return r; 
	}
	Bign operator / (const int &a)
	{
		Bign b;b = a;
		return *this / b;
	}
	//重载 % 运算符
	Bign operator % (const Bign &a)
	{
		return *this - *this / a * a;
	}
	Bign operator % (const int &a)
	{
		Bign b;
		b = a;
		return *this % b;
	}
};

Bign a[MK]; 
int n; //注意，n一定要用int型，因为n会作为下标，而高精数不可以当做下标！！！ 

signed main()
{
	scanf("%lld",&n);
	a[0] = 1;
	for(register int i=1;i<=n+1;i++)
	{
		for(register int j=0;j<=i;j++)
		{
			a[i] = a[i]+a[j]*a[i-j-1];
		}
	}
	a[n].Print();
	return 0;
}
```

# ：）

---

## 作者：Nero_Claudius (赞：3)

本题运用卡特兰数求解。

------------

卡特兰数有两种表达方式：

1）$h_i=\sum^{k=0}_{i-1}h_kh_{i-k-1}$

2）$h_i=\frac{1}{n+1}C^{n}_{2n}$

运用卡特兰数解题的一般步骤是：

1. 证明题目所求的数经过简化/变形后，可以表达为卡特兰数的第一种形式。

2. 通过卡特兰数的第二种形式简化计算。

------------

本题乍一看和卡特兰数关系不大。

但是考察之后，发现如下几个特点：

1. 本题所求解的问题是一般性问题。

2. 本题给出的信息其实很少。

因此可以想到用数学方法求解。

而显然本题与递推有关，因此猜测可能与卡特兰数有关。

现在具体说明如何求解。

对于大小为i的阶梯，我们可以把它拆成简单的情况。

比如放一个k大的阶梯，那么剩下的用i-k-1就可以了。

也就是$f_i=\sum^{k=0}_{i-1}f_kf_{i-k-1}$。

符合第一种形态。

因此套第二种就可以了。

需要注意的是这道题要打一个高精，这里贡献一个板子：

```cpp
	struct BigInteger {
	    typedef unsigned long long LL;
	
	    static const int BASE = 100000000;
	    static const int WIDTH = 8;
	    vector<int> s;
	
	    BigInteger& clean(){while(!s.back()&&s.size()>1)s.pop_back(); return *this;}
	    BigInteger(LL num = 0) {*this = num;}
	    BigInteger(string s) {*this = s;}
	    BigInteger& operator = (long long num) {
	        s.clear();
	        do {
	            s.push_back(num % BASE);
	            num /= BASE;
	        } while (num > 0);
	        return *this;
	    }
	    BigInteger& operator = (const string& str) {
	        s.clear();
	        int x, len = (str.length() - 1) / WIDTH + 1;
	        for (int i = 0; i < len; i++) {
	            int end = str.length() - i*WIDTH;
	            int start = max(0, end - WIDTH);
	            sscanf(str.substr(start,end-start).c_str(), "%d", &x);
	            s.push_back(x);
	        }
	        return (*this).clean();
	    }
	
	    BigInteger operator + (const BigInteger& b) const {
	        BigInteger c; c.s.clear();
	        for (int i = 0, g = 0; ; i++) {
	            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
	            int x = g;
	            if (i < s.size()) x += s[i];
	            if (i < b.s.size()) x += b.s[i];
	            c.s.push_back(x % BASE);
	            g = x / BASE;
	        }
	        return c;
	    }
	    BigInteger operator - (const BigInteger& b) const {
	        assert(b <= *this); // 减数不能大于被减数
	        BigInteger c; c.s.clear();
	        for (int i = 0, g = 0; ; i++) {
	            if (g == 0 && i >= s.size() && i >= b.s.size()) break;
	            int x = s[i] + g;
	            if (i < b.s.size()) x -= b.s[i];
	            if (x < 0) {g = -1; x += BASE;} else g = 0;
	            c.s.push_back(x);
	        }
	        return c.clean();
	    }
	    BigInteger operator * (const BigInteger& b) const {
	        int i, j; LL g;
	        vector<LL> v(s.size()+b.s.size(), 0);
	        BigInteger c; c.s.clear();
	        for(i=0;i<s.size();i++) for(j=0;j<b.s.size();j++) v[i+j]+=LL(s[i])*b.s[j];
	        for (i = 0, g = 0; ; i++) {
	            if (g ==0 && i >= v.size()) break;
	            LL x = v[i] + g;
	            c.s.push_back(x % BASE);
	            g = x / BASE;
	        }
	        return c.clean();
	    }
	    BigInteger operator / (const BigInteger& b) const {
	        assert(b > 0);  // 除数必须大于0
	        BigInteger c = *this;       // 商:主要是让c.s和(*this).s的vector一样大
	        BigInteger m;               // 余数:初始化为0
	        for (int i = s.size()-1; i >= 0; i--) {
	            m = m*BASE + s[i];
	            c.s[i] = bsearch(b, m);
	            m -= b*c.s[i];
	        }
	        return c.clean();
	    }
	    BigInteger operator % (const BigInteger& b) const { //方法与除法相同
	        BigInteger c = *this;
	        BigInteger m;
	        for (int i = s.size()-1; i >= 0; i--) {
	            m = m*BASE + s[i];
	            c.s[i] = bsearch(b, m);
	            m -= b*c.s[i];
	        }
	        return m;
	    }
	
	    int bsearch(const BigInteger& b, const BigInteger& m) const{
	        int L = 0, R = BASE-1, x;
	        while (1) {
	            x = (L+R)>>1;
	            if (b*x<=m) {if (b*(x+1)>m) return x; else L = x;}
	            else R = x;
	        }
	    }
	    BigInteger& operator += (const BigInteger& b) {*this = *this + b; return *this;}
	    BigInteger& operator -= (const BigInteger& b) {*this = *this - b; return *this;}
	    BigInteger& operator *= (const BigInteger& b) {*this = *this * b; return *this;}
	    BigInteger& operator /= (const BigInteger& b) {*this = *this / b; return *this;}
	    BigInteger& operator %= (const BigInteger& b) {*this = *this % b; return *this;}
	
	    bool operator < (const BigInteger& b) const {
	        if (s.size() != b.s.size()) return s.size() < b.s.size();
	        for (int i = s.size()-1; i >= 0; i--)
	            if (s[i] != b.s[i]) return s[i] < b.s[i];
	        return false;
	    }
	    bool operator >(const BigInteger& b) const{return b < *this;}
	    bool operator<=(const BigInteger& b) const{return !(b < *this);}
	    bool operator>=(const BigInteger& b) const{return !(*this < b);}
	    bool operator!=(const BigInteger& b) const{return b < *this || *this < b;}
	    bool operator==(const BigInteger& b) const{return !(b < *this) && !(b > *this);}
	};
	
	ostream& operator << (ostream& out, const BigInteger& x) {
	    out << x.s.back();
	    for (int i = x.s.size()-2; i >= 0; i--) {
	        char buf[20];
	        sprintf(buf, "%08d", x.s[i]);
	        for (int j = 0; j < strlen(buf); j++) out << buf[j];
	    }
	    return out;
	}
	
	istream& operator >> (istream& in, BigInteger& x) {
	    string s;
	    if (!(in >> s)) return in;
	    x = s;
	    return in;
	}
```

---

## 作者：斯德哥尔摩 (赞：3)

卡特兰数+高精乘是一定的，但是好像没有求卡特兰数用上 gcd 的，来一发。。。

公式：cal(n)=C(n,2n)/(n+1)=(2n)!/(n!×(n+1)!)=(n+2)(n+3)(n+4)...(2n)/(1×2×3×...×n)

将分子分母全部分别存入两个数组，一个一个求出 gcd，再化简，最后用高乘单求出结果，输出即可。。。

至于为什么是卡特兰数，几位大佬已经说的够清楚得了。。。

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 510//n的范围
using namespace std;
int n,a[MAXN],b[MAXN],ans[MAXN*10];//防止位数不够，开大一点。
int gcd(int x,int y){//最大公约数，应该都会吧。。。
    if(!y)return x;
    return gcd(y,x%y);
}
void mul(int x){//高乘单
    int c=0;//进位
    for(int i=1;i<=ans[0];i++){//ans[0]记录位数
        ans[i]*=x;ans[i]+=c;
        c=ans[i]/10;
        ans[i]%=10;//谅解本蒟蒻没有用压位高精
    }
    while(c){//处理开头进位
        ans[++ans[0]]=c%10;
        c/=10;
    }
}
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){a[i-1]=n+i;b[i-1]=i;}//记录分子分母
    for(int i=1;i<n;i++)
    for(int j=1;j<n;j++){//约分
        if(b[j]==1)continue;//分母为1跳过
        int g=gcd(a[i],b[j]);
        if(g!=1){a[i]/=g;b[j]/=g;}
        if(a[i]==1)break;//约分分子完毕跳出，约分下一个分子
    }
    ans[0]=ans[1]=1;//初始
    for(int i=1;i<n;i++){//开始高精
        if(a[i]==1)continue;//分子为1跳过
        mul(a[i]);
    }
    for(int i=ans[0];i>=1;i--)printf("%d",ans[i]);//倒序输出答案
	return 0;
}//紧紧凑凑41行。。。

```

---

## 作者：lhjy666 (赞：2)

### 裸的卡特兰数
### 方法：可以先手模几个，然后玄学的发现是卡特兰数.....
```python
a=int(input())#读入
b = [[0 for i in range(3000)] for i in range(3000)]#数组
b[0][0]=0;#初始化
for i in range(1,a+1):
    b[i][0]=1;#初始化
for i in range(1,a+1):
    for j in range(1,a+1):
        if(i==j) : b[i][j]=b[i][j-1]
        else : b[i][j]=b[i-1][j]+b[i][j-1]
        b[i][j]=b[i][j]#用暴力求卡特兰数
print(int(b[a][a]))
```

### 卡特兰数：
```cpp
           42
        14 42
      5 14 28
    2 5 9  14
  1 2 3 4  5
1 1 1 1 1  1 
看我代码应该能推出
```

---

## 作者：pupuvovovovovo (赞：1)

#include<bits/stdc++.h>

using namespace std;

部分分：

参见p1044栈。

dp思想完全相同。

f[i]代表i层阶梯的铺放方法。（不是前i层！）

那么，我们枚举总共i层阶梯中的第k层，使这一层阶梯的钢材接触左下角。

如，样例图1中左数第一个阶梯的钢材就是接触左下角的。

图3中间那个阶梯的钢材接触左下角。

枚举了k以后，处理k的上方的阶梯与左方的阶梯。

由于是分类里再分步，所以先用加法原理，再用乘法原理。

dp方程：f[i]=sigma(f[k]\*f[i-1-k])    0<=k<i    此时把k+1级的阶梯当做接触左下角的阶梯。

时间复杂度：O(n^2\*(高精度复杂度))，实测只能过100左右。

100分：另外的递推式。

百度百科”卡特兰数“，那就有。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct huge{
    int a[50001],len;
};
huge a;
int n,i;
huge times(huge x,int y){
    int i;
    huge z;
    z.len=x.len;
    for (i=1;i<=x.len;i++){
        z.a[i]+=x.a[i]*y;
        z.a[i+1]=z.a[i]/10;
        z.a[i]%=10;
    }
    while (z.a[z.len+1]>0){
        z.len++;
        z.a[z.len+1]=z.a[z.len]/10;
        z.a[z.len]%=10;
    }
    return z;
}
huge div(huge x,int y){
    int i,d=0;
    huge z;
    z.len=x.len;
    for (i=z.len;i>0;i--){
        d=d*10+x.a[i];
        z.a[i]=d/y;
        d%=y;
    }
    while (z.a[z.len]==0) z.len--;
    return z;
}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++){
        a=div(times(a,4*i-2),i+1);
    }
    return 0;
}//代码有删改。
```

---

## 作者：tututu (赞：1)

只有pascal来篇c++的吧

裸的卡特兰数

个人感觉我的程序应该最快了

一开始数组开小了不但慢还死循环

对于此题ans=C(2n,n)/(n+1),那么就是(2n)!/n!/n!/(n+1),化简后得到

(n+2)\*(n+3)\*....\*(2n)/n!

分解质因数统计每个质因数的个数，避免高精度除法，除就是数量-1；

最后高精度相乘输出

压位
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,k,j,a[30002],f[30002];
void t(int x){
    for(int i=1;i<=f[0];i++) f[i]*=x;
    for(int i=1;i<=f[0];i++){
        f[i+1]+=f[i]/10000;
        f[i]%=10000;
    }
    if(f[f[0]+1]>0) f[0]++;
}
void tt(int x){
    int i=2;
    while(x>1){
        while(x%i==0){
            x/=i;
          a[i]++;
        }
        i++;
        if(i*i>x){
            a[x]++;
            break;
        }
    }
}
void ttt(int x){
    int i=2;
    while(x>1){
        while(x%i==0){
            x/=i;
          a[i]--;
        }
        i++;
        if(i*i>x){
            a[x]--;
            break;
        }
    }
}
int main()
{
    cin>>n;
    f[0]=1;
    f[1]=1;
    for(i=n+2;i<=n+n;i++) tt(i);
    for(i=2;i<=n;i++) ttt(i);
    for(i=2;i<=n+n;i++) while(a[i]>0){
        a[i]--;
        t(i);
    }
  cout<<f[f[0]];
  for(i=f[0]-1;i>=1;i--){
      if(f[i]<1000) cout<<0;
      if(f[i]<100) cout<<0;
      if(f[i]<10) cout<<0;
    cout<<f[i];
  }
  return 0;
}
```

---

## 作者：时光 (赞：1)

典型的卡特兰数题目

卡特兰数可以用多种公式来说明，但每一个公式实现起来的代码复杂度（就是码起来方不方便）是不一样的；下面简述两种思路

方法一

使用公式 C（n，2n）/（n+1）;

使用这个公式的优点是可以约分 why？

C（n，2n）/（n+1）

=m!/(m-n!)\*n!\*(n+1)

=1\*2\*...\*m/1\*2\*...\*(m-n)\*1\*2\*..\*n\*(n+1)

这明显是可以约分的，先统计质因数，然后除号两边同时除去相同数量的质因数，最后再用高精度累乘剩余的质因数

不用担心除不净，卡特兰数都是整数，只要公式正确，是不会错的；

优点：容易想到 缺点：代码比较烦，容易码伪（比如我这种蒟蒻）；

方法二

公式：f（i）=f（i-1）\*（4\*i-2）/（i+1）

这就比较简单了，裸的高精乘除

这里用2维不会炸

但是还是用滚动数组比较好

优点：比较好码 缺点：不易想到

附上方法二的代码（方法一的我实在不想码）



```cpp
Var
x,i,j,n,m,len,len1,h1,h2:longint;
f1,f,c:array[0..5000] of longint;
Begin
readln(n);
f1[1]:=1;
f[1]:=1;//滚动数组
len1:=1;
len:=1;
for i:=2 to n do
begin
for j:=1 to len do
f[j]:=f1[j]*(4*i-2);//高精度乘
j:=1;
while j<=len do
begin
if (f[j]>=10)and(j=len) then inc(len);
if f[j]>=10 then
begin
f[j+1]:=f[j+1]+f[j] div 10;
f[j]:=f[j] mod 10;
end;
inc(j);
end;//进位
x:=0;
for j:=len downto 1 do
begin
c[j]:=(x*10+f[j]) div (i+1);
x:=(x*10+f[j]) mod (i+1);
end;//高精度除
j:=len;
while (c[j]=0)and(j>=1) do dec(j);//去除高位的0
f:=c;
len:=j;
f1:=f;
len1:=j;//滚动
end;
for i:=len  downto 1 do write(f[i]);
End.
```

---

## 作者：fighter_OI (赞：1)

由分析和计算可知，本题又是卡特兰数。

同样，用动归亦可。

标程：

```cpp
program stair;
type gj=array[0..400] of longint;
var a:array[0..500] of gj;
    i,n,j:longint;
function cf(x,y:gj):gj;
var jw,i,j:longint;
begin
 fillchar(cf,sizeof(cf),0);
 cf[0]:=x[0]+y[0]-1;
 for i:=1 to x[0] do
  for j:=1 to y[0] do
   cf[i+j-1]:=cf[i+j-1]+x[i]*y[j];
 jw:=0;
 for i:=1 to cf[0] do
  begin
   cf[i]:=cf[i]+jw;
   jw:=cf[i] div 10000;
   cf[i]:=cf[i] mod 10000;
  end;
 if jw>0 then begin inc(cf[0]); cf[cf[0]]:=jw; end;
end;
function add(x,y:gj):gj;
var i,jw:longint;
begin
 fillchar(add,sizeof(add),0);
 if x[0]>y[0] then add[0]:=x[0] else add[0]:=y[0];
 jw:=0;
 for i:=1 to add[0] do
  begin
   add[i]:=x[i]+y[i]+jw;
   jw:=add[i] div 10000;
   add[i]:=add[i] mod 10000;
  end;
 if jw>0 then begin inc(add[0]); add[add[0]]:=jw; end;
end;
begin
 read(n);
 fillchar(a[0],sizeof(a[0]),0);
 a[0][0]:=1;
 a[0][1]:=1;
 for i:=1 to n do
  begin
   fillchar(a[i],sizeof(a[i]),0);
   a[i][0]:=1;
   for j:=1 to i do
    a[i]:=add(a[i],cf(a[j-1],a[i-j]));
  end;
 write(a[n][a[n][0]]);
 for i:=a[n][0]-1 downto 1 do
  begin
   if a[n][i]<1000 then write(0);
   if a[n][i]<100 then write(0);
   if a[n][i]<10 then write(0);
   write(a[n][i]);
  end;
end.         
```

---

## 作者：B_1168 (赞：1)

~~容易证明，~~ 本题的本质是求卡特兰数；第n个卡特兰数可通过以下公式求出：

$C_n=\dfrac{(2n)!}{{n!}^2\times(n+1)}$

然后，按图索骥，随手写一个四行小程序，交上去：

```python
import math

n=int(input())

ans=((math.factorial(2*n))/(math.factorial(n)**2))/(n+1)

print(int(ans))
```
交上去，40！

就十分的迷惑……

~~其实也不是很迷惑啦~~

python对于这么大的数进行浮点除法还是有一定可能出现误差的，想必是过大的数据点超出了浮点运算的精度，导致除法时出现问题……

既然问题找到，便可以相应处理了；对于上面提及的公式，在此做了一些整理，整理成了以下形式：

$C_n=\dfrac{\prod\limits_{i=n+2}^{2\times n}i}{n!}$

对于这个算式，考虑到`math.factorial()`可能的精度问题，决定花$O(n)$的时间模拟算出----反正如果模拟算法T的话，`math.factorial()`不见得就不会，Python的高精并不自带FFT（极度大嘘）----何况$n\leq500$呢！

容易写出以下程序：

```python
import math

n=int(input())

ans=1

for i in range(n+2,2*n+1):
    ans*=i

for i in range(1,n+1):
    ans=ans//i;

print(ans)
```

然后就是自然而然的AC了！

~~其实这个程序跑10000以内的卡特兰数都不带喘气的，500纯属大材小用~~

~~你问我考场怎么办？才500个数，打个表都不行吗（滑稽）~~

感谢管理审核，感谢大佬阅读！

---

## 作者：谷民 (赞：0)

### 题解 P2532 【[AHOI2012]树屋阶梯】

样例给出第三项为5的数列，可以通过观察得出结论，本题要求输出[卡特兰数](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin)

由于是一道高精题目，我们考虑使用python3（我看有大佬用python2写，有一点不同）

卡特兰数公式如下

$f(n)=\dfrac{(2n)!}{(n+1)!×n!}$

通过阶乘化简得，代码即按推导公式运算

$\dfrac{\prod_{i=n+1}^{2n}}{\prod_{i=1}^{n}}$

本题代码难度不大，可以练习py3语法

```
n=int(input())#输入
num=1#赋初值
for i in range(n+2,n*2+1):#按卡特兰数公式循环
	num*=i
for i in range(1,n+1):
	num=num//i#这里和py2不一样，一定是num//i，否则不是整除，会有小数
print(num)#输出，自动换行
```


---


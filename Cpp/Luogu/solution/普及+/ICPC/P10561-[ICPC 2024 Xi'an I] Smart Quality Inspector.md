# [ICPC 2024 Xi'an I] Smart Quality Inspector

## 题目描述

Ella 有一家工厂。一天，她的工厂面临产品质量检查。  她的工厂有 $N$ 条生产线。在这 $N$ 条生产线中，有 $N-K$ 条是合格的，另外 $K$ 条是不合格的。第 $i$ 条（$1\leq i\leq K$）不合格生产线的罚款为 $i$ 元。  这里有 $M$ 名质量检查员。对于第 $j$ 名（$1\leq j\leq M$）质量检查员，他将检查从第 $l_i$ 条到第 $r_i$ 条的生产线，并在其中找到罚款最高的不合格生产线，然后将此罚款施加给 Ella。  Ella 不想收到太多罚款，所以她决定重新编号这 $N$ 条生产线以使收到的罚款最少。请帮助她。  简单来说：  你有一个长度为 $N$ 的序列 $A$，$A=[1,2,3,...,K,0,0,0,...,0]$。这里 $N,K$ 已知。  有 $M$ 对整数，每对由两个数字 $l_i,r_i$ 组成。  你需要重新排列序列 $A$ 以最小化以下值：  $$\sum_{i=1}^M \max_{j=l_i}^{r_i} (A_{j})$$

## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
4 4 3
1 2
3 4
1 4```

### 输出

```
10```

# 题解

## 作者：苏联小渣 (赞：3)

发现 $n,k$ 都很小，考虑状压。

由于我们要求 $\max$ 之和，所以肯定要枚举这个 $\max$，也就是要钦定加入顺序，不难想到应该从大往小加入，这样每次加入的数都会成为一些区间的 $\max$。

设 $f_{S}$ 表示已经加入了最大的 $|S|$ 个数，且位置集合为 $S$ 的最小值。考虑枚举最后一个加入的数，位置不妨记为 $p$，考虑它会成为哪些区间的 $\max$。容易发现，这些区间应该包含 $p$ 且不包含更先加入的数。设二进制下 $S$ 中 $p$ 左边第一个 $1$ 的位置为 $l-1$，右边第一个 $1$ 的位置为 $r+1$，也就是所有满足 $l' \in [l,p],r' \in [p,r]$ 的 $[l',r']$ 的最大值都是 $k-|S|+1$。求出贡献区间数，本质上就是子矩形求和，可以通过二维前缀和预处理和查询，然后 dp 的转移也就简单了：

设贡献到的区间数为 $x$，那么 $f_S=\min \{f_{S-2^p}+x \times (k-|S|+1)\}$。于是总时间复杂度 $O(n2^n)$。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
int n, k, m, l, r, ans=1e9, pre[25][25], f[2000010], lst[25], nxt[25];
int main(){
	scanf ("%d%d%d", &n, &k, &m);
	for (int i=1; i<=m; i++){
		scanf ("%d%d", &l, &r);
		pre[l][r] ++;
	}
	for (int i=1; i<=n; i++){
		for (int j=1; j<=n; j++){
			pre[i][j] = pre[i][j] + pre[i][j-1] + pre[i-1][j] - pre[i-1][j-1];
		}
	}
	for (int S=1; S<(1<<n); S++){
		int tot = 0;
		for (int i=0; i<n; i++){
			if ((S >> i) & 1) tot ++;
		}
		if (tot > k) continue;
		f[S] = 1e9, lst[0] = 0, nxt[n+1] = n+1;
		for (int i=0; i<n; i++){
			if ((S >> i) & 1) lst[i+1] = i+1;
			else lst[i+1] = lst[i];
		}
		for (int i=n-1; i>=0; i--){
			if ((S >> i) & 1) nxt[i+1] = i+1;
			else nxt[i+1] = nxt[i+2];
		}
		for (int i=0; i<n; i++){
			if (!((S >> i) & 1)) continue;
			int T = S - (1 << i);
			int st = lst[i], ed = nxt[i+2] - 2;
			int ad = pre[i+1][ed+1] - pre[st][ed+1] - pre[i+1][i] + pre[st][i];
			f[S] = min(f[S], f[T] + ad * (k - tot + 1));
		}
		if (tot == k) ans = min(ans, f[S]);
	}
	printf ("%d\n", ans);
	return 0;
}
```

---

## 作者：迟暮天复明 (赞：3)

状压 DP。

设 $f_s$ 表示最大的若干个数构成状态 $s$ 时的最小答案。

于是在枚举转移的时候，我们只需要知道当前数字放的位置 $p$ 对答案的贡献次数即可。

我们记 $s$ 中 $p$ 的前一个 $1$ 的位置是 $l$，$p$ 的后一个 $1$ 的位置是 $r$，同时预处理 $f_{i,j}$ 为同时包含 $i$ 和 $j$ 两个点的区间数。因为 $p$ 只能给 $s$ 中全是 $0$ 的区间产生贡献，所以这个贡献可以用容斥法算出是 $f_{p,p}-f_{l,p}-f_{p,r}+f_{l,r}$。这样就可以做到时间复杂度 $O(n2^n)$。因为现场赛的时候代码调的很痛苦所以赛后不想再写了。

---


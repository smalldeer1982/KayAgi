# [EC Final 2022] Chase Game 2

## 题目描述

庞教授和寿教授喜欢玩追逐游戏。

游戏地图由 $n$ 个房间和 $n-1$ 条双向通道组成。游戏地图是连通的。这意味着地图形成一棵树。

一开始，庞教授在房间 $u$，而寿教授在房间 $v$（$u\neq v$）。庞教授和寿教授轮流玩游戏，寿教授先开始。在自己的回合中，玩家知道自己所在的位置和另一个玩家的位置，可以决定留在当前房间或者移动到与当前房间直接通过通道相连的另一个房间。当庞教授和寿教授在同一个房间时，寿教授被庞教授抓住。

庞教授和寿教授足够聪明。庞教授希望在有限的回合内抓住寿教授。寿教授不希望在任何有限的回合内被庞教授抓住。

寿教授厌倦了每次都被抓住，找到了费教授寻求帮助。寿教授请求费教授添加一些通道，使得无论初始房间对 $(u,v)$ 如何，庞教授都无法在有限的回合内抓住他。费教授很懒，所以他希望尽可能少地添加通道。如果无论如何添加通道，总是存在一对房间 $(u,v)$，使得庞教授能够抓住寿教授，输出 $-1$。

## 样例 #1

### 输入

```
4
2
1 2
4
1 2
2 3
3 4
4
1 2
2 3
2 4
5
1 2
2 3
3 4
3 5
```

### 输出

```
-1
1
-1
2
```

# 题解

## 作者：HFanGDoDM (赞：6)

# 题意简述

给定一棵含有 $n$ 个结点的树。设有两人 A 和 B，初始位置分别为 $u$ 和 $v$ $(u\not=v)$。每一轮中，顺次执行以下两个操作：

- B **选择** 一个与 B 当前结点直接相邻的结点，或 B 当前所处的结点。设该结点为 $x$，则 B 会前往结点 $x$。

- A **选择** 一个与 A 当前结点直接相邻的结点，或 A 当前所处的结点。设该结点为 $x$，则 A 会前往结点 $x$。

过程中，A 和 B **互相清楚** 自己和对方的位置。若某一个操作结束后，A 和 B 位于同一个结点，则 B 被 A 捉住。A 希望 **在有限步数内** 捉住 B，B 希望 A **不能在有限步数内** 捉住 B。A 和 B 都足够聪明。

现可以对该树增加一些边。试求出 **最少的加边** 数量，使得对于所有 $(u,v)$，A 和 B 按照最优策略操作的情况下，A **不能在有限步数内** 捉住 B。若不存在这样的加边方案，输出 $-1$。

### 数据范围

**有多组测试数据**。测试数据组数 $T$ 满足 $1\leqslant T\leqslant 10^4$。对于每组测试数据，$2\leqslant n\leqslant 10^5,1\leqslant u_i,v_i\leqslant n$。对于所有测试数据，$\sum n\leqslant 2\times10^5$，保证输入是一棵树。

# 解题思路

### 做法

若树是 **菊花图**，则无解。否则：

设树上 **度数为 $1$** 的点的数量为 $a$（这里点 $u$ 的度数定义为与点 $u$ 直接相邻的点的数量），与点 $u$ **直接相邻** 的所有点中度数为 $1$ 的点的数量为 $num_u$，则答案为

$$ans=\max(\lceil \dfrac{a}{2}\rceil,\displaystyle\max_{i=1}^nnum_i)$$

### 正确性证明

**考虑加边后形成的图**。由于 $\forall (u,v)$，都有 A 不能在有限步数内捉住 B，且 B 先行动，因此 $\forall (u,v)$，B 必然会 **趋向于** 一个位置 $p$，使得 A 所处的位置与 $p$ 之间存在 **至少两条不完全重合的简单路径** $\implies$ 此时 A 与 B 所处的位置的一条简单路径上的一部分 **必然属于一个简单环**。

我们设一部分属于的 **极大简单环** 为 $C$。若 $|C|=3$，则 A 会从连接该环上某个点的路径上的一个点向该环逼近。

此时环 $C$ 上的 $3$ 个点向外连出的点集与边集会有以下几种情况：

- $3$ 个点中有向外的边的，只向外连出一条简单路径。此时 B 可以选择向环外走，但此后 A 不断逼近，由于 A 与 B 之间的路径数量变为 $1$ 条，因此最终 **B 必然被堵在“死角”而被 A 抓住**，只是延长了被抓住的时间而已。

- $3$ 个点中有向外的边的，属于另一个三元环，则另一个三元环的另两个点必然 **不属于** 环 $C$（否则环 $C$ **不是极大环**），或产生路径与三元环的复合结构或三元环套三元环（均满足两两三元环之间只有一个点重合）的结构。当 B 行动至无三元环或路径可继续远离 A 时，A **不断深入** 三元环与路径的复合结构。对于路径的情况，上文已经证明 B 一定会被 A 抓住。对于三元环的情况，**形似多叉树**，A 一定可以通过选择一个结点，满足该结点为几个三元环的 **交汇点**，锁定 B 的位置并堵住 B。若 B 尝试在一个 A 位于一个点的三元环上移动，尝试转移到其他三元环，则 A 一定能够 **在这一步之内抓住 B**。

注意，以下情况是不符合上述条件的：

- $3$ 个点中有向外的边，通向一个环 $C'$，满足 $|C'|\gt3$。则 B **不可能趋向** 环 $C$，B 必然趋向环 $C'$，使得自己尽可能不被 A 抓住。

综上，**若 B 趋向的环的大小为 $3$，则必然被 A 捉住**。

若这个环的大小 $|C|\geqslant4$，则一旦 B 进入这个环，由于 B 和 A 每次只能移动一步，**因此 B 不可能被 A 捉住**。若 A 在该环内走一步，B 也顺这一方向走一步；若 A 不动，B 也不动。

我们得证：**符合题意的图中，$\forall(u,v)$，B 总能成功到达一个环 $C$ 中，其中 $|C|\geqslant4$**。

对于原树上的一对度数为 $1$ 的点 $x$ 和 $y$，若有其一 **不属于** 一个环 $C$ 满足 $|C|\geqslant4$，设 $x$ 到 $y$ 的路径为 $path(x,y)=(x,p_1,p_2,\dots,y)$，不妨设 $x$ 不属于一个这样的环 $C$，则令 $u=p_1,v=x$，此时若 B 行动一步只能走到 $u$，**被 A 抓住**；否则，B 不动，则 A 行动一步到达 $v$，**抓住 B**。$x$ 或 $y$ 有属于三元环的情况，上述已经证明。因此 **B 一定被抓住**，不合题意。

得证：$\forall$原树上的一对度数为 $1$ 的点 $(x,y)$，都有 $x,y\in C,|C|\geqslant4$。即：**$\forall$ 原树上度数为 $1$ 的结点 $x$，都有 $x\in C,|C|\geqslant4$**。

对于菊花图，由于其 **直径（点数） $\leqslant3$**，因此无论如何对度数为 $1$ 的点加边，都无法使得这些点属于一个环 $C$，$|C|\geqslant4$。若不是菊花图，则其直径 $\geqslant4$，因此总有加边方案。所以 **菊花图无解，其他树有解**。

根据上述推理，存在这样一种符合题意的方案：$\exists x,y$，路径 $(x,y)$ 上的点数 $\geqslant3$，点 $x,y$ 各属于一个环 $C,|C|\geqslant4$，该路径上的其他点不属于任何一个环。但是，我们可以发现，该方案恰好加了 $2$ 条边。我们总能 **将这 $2$ 条边 $(u_1,v_1),(u_2,v_2)$ 断开，并连边 $(u_1,u_2),(v_1,v_2)$**，此时路径 $(x,y)$ 及原环上的所有点都能属于一个环 $C,|C|\geqslant4$。此时仍然只连接了 $2$ 条边，是不劣的。

因此得证：**必然存在一种最优方案，使得每个点都属于至少一个环 $C,|C|\geqslant4$**。

首先我们需要满足每个点至少属于一个 **简单环**。这是一个经典问题，将度数为 $1$ 的点 **两两配对**，因此需要增加至少 $\lceil \dfrac{a}{2}\rceil$ 条边。然后，对于每一个点，与其直接相邻的所有度数为 $1$ 的点之间 **不能直接连边（否则将形成三元环）**，每一个这样的点都需要与其他的 **到这个点距离 $\geqslant2$** 的点进行配对。因此，对于点 $u$，我们至少需要增加 $num_u$ 条边。

**得证**：至少需要的边数为 $\max(\lceil \dfrac{a}{2}\rceil,\displaystyle\max_{i=1}^nnum_i)$。

### 具体实现

读入每一条边 $(u,v)$，增加点 $u$ 和 $v$ 的度数，并将每条边存下来。再扫每条边 $(u,v)$，统计 $num_u$ 和 $num_v$。若 $u$ 的度数为 $1$，则将 $num_v$ 加 $1$，反之亦然。

判断是否有结点的度数为 $n-1$，若存在，则原图为菊花图，输出 $-1$。否则，扫一遍 $num$，并将其中最大值与 $\lceil \dfrac{a}{2}\rceil$ 取最大值，即为答案。

### 时间复杂度分析

求度数、统计 $num$、判断是否无解、统计答案，每一步的复杂度均为 $O(n)$。

总时间复杂度 $O(\sum n)$，可以通过本题。

### 参考核心代码

```cpp
for(i=1;i<n;i++){
    int u=R(),v=R();
    deg[u]++,deg[v]++;//统计度数
    edge.push_back({u,v});
}
for(i=0;i<n-1;i++){//计算每个点相邻的点中度数为1的点数
    if(deg[edge[i].first]==1)
        num1[edge[i].second]++;
    if(deg[edge[i].second]==1)
        num1[edge[i].first]++;
}
for(i=1;i<=n;i++)
    if(deg[i]==n-1){
        puts("-1");//菊花图则无解
        return;
    }
int num=0;
for(i=1;i<=n;i++)
    if(deg[i]==1)
        num++;
int ans=(num+1)>>1;//即为上述的a/2上取整
for(i=1;i<=n;i++)
    ans=max(ans,num1[i]);//求出答案
printf("%d\n",ans);
```

---

## 作者：Fgighkcgrfox (赞：5)

# [P9725 [EC Final 2022] Chase Game 2](https://www.luogu.com.cn/problem/P9725) 题解

## 题意翻译

有一棵树，A 和 B 在两个不同的节点上，双方都清楚对方的位置。B 先走，之后两人交替操作。每次可以走到相邻的节点，也可以待在原来的节点。A 走到 B 的节点上则 A 胜利。

要在树上加边，使得无论 A 和 B 在哪个节点上，A 都无法胜利。求最小边数。无解输出 `-1`。

## 思路

没有什么算法，一道黄题难度左右的思维题。

这篇文章可能没有[别的大神的题解](https://www.luogu.com.cn/blog/HFanGDoDM1265/solution-p9725)严谨，就是把蒟蒻赛时思考的过程记录了下来，可能会稍微容易理解一点。

建议自己那张草稿纸画一画，有利于理解。

+ $n\leq3$，显然无解。

+ $n>3$。

我们令度数为 $1$ 的为叶子节点。

B 如果在叶子节点上，那么 A 只要在它的父亲的位置，B就像一只可怜的小老鼠一样无路可逃，A 就可以胜利了。

所以每个叶子节点都需要连边。

同一个父亲节点的叶子之间连显然是没有用的。

因此所有的叶子节点都是同一个父亲的话（菊花图），是无解的（比如样例的第三组）。

边数尽量少，最好是叶子与叶子之间连，每次可以解决掉 $2$ 片叶子，但是要判断一下会不会同一个父亲下的叶子节点超过了一半，这样就有可能会有剩余。

也就是说，令叶子节点个数为 $sum$，与每个节点相连的叶子节点个数为 $tj_i$（与下面代码中一致）。那么答案就是 $\max(\lceil\frac{sum}{2}\rceil,\max_{i=1}^ntj[i])$。

这样的话，无论 A 和 B 在哪里，B 都可以找到一个节点个数大于 $3$ 的环。

简单的证明一下：假如存在大小为 $3$ 的环（如下图）。树中本来是没有环的，也就是说，环中的一条边一定是新加的，而另外两条边则就与一个共同的点相连，这与前文“不在同一个父亲节点之间的叶子间连边”相矛盾。证毕。

![](https://cdn.luogu.com.cn/upload/image_hosting/xwwehstv.png)

在环上沿着原离 B 的方向一直走，A 就不会被抓住了。

## CODE

```cpp
#include<cstdio>
#include<cstring>
const int N=1e5+5;
int T,n,du[N],u[N],v[N],tj[N],sum,ans;bool bb;
int main(){
    scanf("%d",&T);
    while(T--){
        memset(du,0,sizeof(du));memset(tj,0,sizeof(tj));sum=0;bb=1;//多测不清空，挂分两行泪。
        scanf("%d",&n);
        for(int i=1;i<n;i++)scanf("%d%d",&u[i],&v[i]),du[u[i]]++,du[v[i]]++;//du[x] 表示 x 的度数
        if(n<=3){puts("-1");continue;}
        for(int i=1;i<n;i++){
            if(du[u[i]]==1)tj[v[i]]++,sum++;
            if(du[v[i]]==1)tj[u[i]]++,sum++;//统计每一个父亲有的叶子节点数量
        }
        ans=((sum+1)>>1);//考试时因为没向上取整，吃了一发罚时 (record:127986514)。
        for(int i=1;i<=n;i++)
            if(tj[i]==sum){puts("-1");bb=0;continue;}//所有叶子节点的父亲都是同一个节点，无解。
            else if(tj[i]>ans)ans=tj[i];//有剩余的
        if(bb)printf("%d\n",ans);
    }
    return 0;
}
//不要作弊QAQ
```

完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：ltz761222 (赞：4)

## 题目传送器
  [偏思维题目](https://www.luogu.com.cn/problem/P9725)
    
## 简要分析
  归纳题意：询问最少添加几条边可以使得追逐的两人不可能相遇。
  
  刚开始看道题，很容易想到只要有节点不在环上就一定可以被捉住。于是我们很容易想到在叶子结点构造环，这一定可以成功。这就像是荆轲刺秦王时给秦王几个柱子，让秦王不管往哪里跑都一定可以对着柱子跑，这样荆轲一定捉不住秦王。

  我们设叶子结点有 $op$ 个，然后两两建隧道，得出结果。最后我们简单一交——直接 WA 了。

  WA 在哪个地方呢？试想这个场景：秦王和荆轲正在绕着一根小柱子跑，秦王一边跑一边听声辨位，结果荆轲两只手只接从柱子后伸过来把秦王按柱子上了……

  结果可想而知，但这是什么原因造成的呢？很明显是柱子太小了。对应到题上，也就是有两个叶子节点公用一个祖先，于是我们跑的时候从其中一个跑到另一个上，很容易被抓住。这就需要我们对于拥有同一个父亲的叶子节点分别向外建一条边。此方法的答案为所有父亲所接叶子结点的数量取 $\max$。并与刚开始的答案取 $\max$ 值。

## 总结
  思维性难度较高，但写起来简单，建议降黄。主要是对于特殊情况的判断，最后代码呈上。
  
```cpp
//Chase Game
#include <bits/std++.h>
typedef char int;
using namespace std;
const int N=2e5+10;
struct node{
	int v,ne;
}b[N];int h[N],idx;
int in[N],sum[N],op;
int t,n,ans;
void add(int u,int v)
{
	b[++idx]={v,h[u]},h[u]=idx,in[u]++;
}
void dfs(int w,int fa)
{
	if (in[w]==1)
		sum[fa]++;
	else
	{
		for (int i=h[w];i;i=b[i].ne)
			if (b[i].v!=fa)
				dfs(b[i].v,w);
	}
}
int main ()
{
	scanf ("%d",&t);
	
	int u,v; 
	while (t-->0)
	{
		scanf ("%d",&n),ans=op=idx=0;
		for (int i=1;i<=n;i++)
			in[i]=sum[i]=0,h[i]=0;
		for (int i=1;i<n;i++)
			scanf ("%d %d",&u,&v),add(u,v),add(v,u);//建树
		if (n<=2)//没有办法建隧道
			ans=-1;
		else
		{
			for (int i=1;i<=n;i++)
				if (in[i]>1)//从一个不是叶子的节点作为根出发搜索，防止疏漏
				{
					dfs(i,0);
					break;//搜索完结束
				}
			for (int i=1;i<=n;i++)
				if (in[i]==1)//是叶子结点
					op++;
			ans=(op+1)/2;//所有叶子结点除2为结果
			for (int i=1;i<=n;i++)
				ans=max[ans,sum[i]];//跟特殊情况取max
			if (ans==op)//如果所有节点都有一个父亲，没有办法建隧道
				ans=-1;
		}
		printf ("%d\n",ans);
	}
	
	return 0;
}
/*
4
2
1 2
4
1 2
2 3
3 4
4
1 2
2 3
2 4
5
1 2
2 3
3 4
3 5

-1
1
-1
2
```

---

## 作者：ycy1124 (赞：1)

### 题意
有一棵 $n$ 个节点的树，现在要在树上选任意两点 $u,v$ 做为两个人的起点。在 $u$ 的人先移动，在 $v$ 的人随后去抓他，每人每次可以移动到当前节点所连接的一个节点上或者不移动，试问最少要加多少条边才能使得在 $v$ 出发的人永远抓不到在 $u$ 出发的人。
### 思路
首先发现，菊花图是一定无解的。因为菊花图中有一个节点可以移动到所有的节点上，选择这个节点作为 $v$ 就一定可以抓到人。

接下来发现，当每个节点都处在一个大于等于二的环内的时候，貌似是满足题目条件的。此时的答案等于所有度为一的节点除以二在向上取整，即：$\lceil \frac{js}{2} \rceil$（$js$ 表示有多少个度为一的点）。

当写出来交上去之后发现它错了。此时我们手玩一些例子可以发现，当有一个点连了 $k$ 个度为一的点并且将这些点连成一个环是不符合条件的。为了避免这种情况，我们只需要将他们全部连到另外的一个节点上就可以了。此时答案为 $\max w_i (1 \le i \le n)$（$w_i$ 表示第 $i$ 个点连了多少个度为一的点）。最后为了答案的正确性，我们将这两种情况的答案取个 max 即可。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>a[100005];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        for(int i=1;i<=n;i++){
            a[i].clear();
        }
        for(int i=1;i<n;i++){
            int u,v;
            cin>>u>>v;
            a[u].push_back(v);
            a[v].push_back(u);
        }
        int js=0,ma=0,w;
        bool bj=0;
        for(int i=1;i<=n;i++){
            if(a[i].size()==n-1){
                bj=1;
            }
            w=0;
            for(auto it:a[i]){
                if(a[it].size()==1){
                    ++w;
                }
            }
            ma=max(ma,w);
            if(a[i].size()==1){
                ++js;
            }
        }
        if(bj){
            cout<<-1<<'\n';
            continue;
        }
        cout<<max((int)ceil(1.00*js/2),ma)<<'\n';
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/194943189)

---

## 作者：std_qwq (赞：0)

### 思路
对于任意一个连边方案，我们用最刁钻的方法分配 $(u,v)$。

不难发现连边后会出现若干个环，如果一个点在一个点数大于 $3$ 的环内，那么无论如何都不会被抓（读者可自行思考）。则对于 $n \le 3$，一定无解。现在讨论 $n>3$ 的情况。

考虑删去所有的点数大于 $3$ 的环，只要还有剩余（一定是一个森林，并且一定存在原树中的叶子），就可以通过把 $u$ 放在叶子的父亲，$v$ 放在叶子，这个方法就行不通了。这启发我们一定要**在叶子上连边。把它们放进点数大于 $3$ 的环**。

互为兄弟的叶子互相连边是无用的，因为是在三元环内。**每次连边均能消灭两个叶子（如果叶子本身已经被消灭就不作数）**。设叶子数为 $s$，理想情况需要 $\left \lceil \frac{s+1}{2}  \right \rceil $ 但是如果原本互为兄弟的叶子数的最大值 $c$ 超过了 $\left \lceil \frac{s+1}{2} \right \rceil $，此时无法适用一次操作消灭两个叶子的规律，它们只能其他叶子连边，$c$ 次操作后，其他的叶子也一定都被消灭了（在消灭这些叶子的时候尽可能找没用过的叶子），此时答案为 $c$。
综上，设每个节点 $u$ 直接相连的叶子数为 $c_{u}$，则答案为：
$$
 \max (\left \lceil \frac{s+1}{2}  \right \rceil,\max_{i=1}^{n}c_{u}  ) 。
$$
### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int h[N],e[N<<1],ne[N<<1],idx;
void add(int a,int b){
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
int d[N];
int cl[N],cm,s;
bool ilf[N];
void dfs(int u,int fa){
    ilf[u]=1;
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(j==fa)continue;
        ilf[u]=0;
        dfs(j,u);
        if(ilf[j])cl[u]++;
    }
    cm=max(cm,cl[u]);
    s+=cl[u];
}
int t,n;
int main(){
    cin>>t;
    while(t--){
        cin>>n;
        memset(h,-1,sizeof h);
        idx=cm=s=0;
        memset(d,0,sizeof d);
        memset(cl,0,sizeof cl);
        for(int i=1;i<n;i++){
            int u,v;
            cin>>u>>v;
            d[u]++,d[v]++;
            add(u,v),add(v,u);
        }
        if(n<=3){
            cout<<-1<<endl;
            continue;
        }
        //令每个点在一个>3元环内
        for(int i=1;i<=n;i++)
            if(d[i]>1){
                dfs(i,0);
                if(cl[i]==n-1)cout<<-1<<endl;
                else cout<<max((s+1)/2,cm)<<endl;
                break;
            }
    }
}
```

---


# [IOI 2000] 邮局（原始版）

## 题目描述

高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。

邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。

你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。

## 说明/提示

数据保证，$1 \le V \le 300$，$1 \le P \le 30$，$P \le V$，$1 \le X \le 10000$。

## 样例 #1

### 输入

```
10 5
1 2 3 6 7 9 11 22 44 50```

### 输出

```
9```

# 题解

## 作者：edward1346 (赞：8)

## DP

[题目传送门](https://www.luogu.com.cn/problem/P10967)

### 解题思路

我们先设 $f(i,j)$ 表示前 $i$ 个村庄放了 $j$ 个邮局的最小距离和。

然后，聪明的你可以很快地想出这个转移方程：

$f(i,j) = \min(f(k,j-1)+w(k+1,i))$

其中  $0<k<i$，$w(i,j)$ 表示 $i$ 到 $j$ 的区间内放一个邮局的最小距离之和。

这个转移方程的意思：可以先考虑少放一个邮局的状态，（也就是 $f(k,j-1)$），然后再加上在 $k+1$ 到 $i$ 这个区间内放一个邮局的距离。

**再来讲讲 $w(i,j)$ 怎么算。**

首先可以画个图，然后你就会发现：在一个区间内放一个邮局，最优的方案就是放在这个区间中间的村庄（也就是第 $ \frac{i+j} {2}$ 个村庄。

可以先不考虑这个区间内的最后一个村庄，那就是 $w(i,j-1)$。

然后我们再考虑这个区间内的最后一个村庄到邮局的距离，那就是 $a_j - a_\frac{(i+j)}{2}$。

（其中 $a_i$ 表示第 $i$ 个村庄的位置）

然后将两者相加即可。

最终的式子：

$w(i,j)=w(i,j-1)+a_j- a_\frac{(i+j)}{2}$

于是，直接 DP 就可以了。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m;
int a[3001];
int f[3001][301];
int w[3001][3001];
//前i个位置，放j个邮局
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            w[i][j]=w[i][j-1]+a[j]-a[(i+j)/2];
        }
    }
    memset(f,0x3f,sizeof(f));
    f[0][0]=0;
    for(int j=1;j<=m;j++)
    {
        for(int i=j;i<=n;i++)
        {
            for(int k=0;k<i;k++)
            {
                if(f[i][j]>f[k][j-1]+w[k+1][i])
                {
                    f[i][j]=f[k][j-1]+w[k+1][i];
                }
            }
        }
    }
    cout<<f[n][m]<<endl;
    return 0;
}
```

---

## 作者：Aoharu_shiroko (赞：6)

# P10967 解题报告
## 0x00 前言
终于不是数据加强的版本了，happy。
  
## 0x01 题意
在 $V$ 个村庄间建立 $P$ 个邮局，求每个村庄离它最近的邮局的距离总和。

## 0x02 解题思路
首先首选算法就是 DP，所以我们就以 DP 解出这题。

我们定义一个数组叫做 $f$，令 $f_{i,j}$ 的定义为 在前 $i$ 个村庄放置 $j$ 个邮局的最小距离和。

但是，光定义这个用来 DP 的还不够，也推不出状态转移方程，我们还需要定义一个 $dis$ 数组记录从第 $i$ 个村庄到第 $j$ 个村庄放置一个邮局的最小距离和。

$dis$ 可以通过预处理求出。非常的简单。

$$
dis_{i,j} = dis_{i,j-1} + \operatorname {abs}(a_\frac{i+j}{2}-a_k)
$$

注意 $i \le k \le j$。

预处理阶段结束了现在我们可以开始推导状态转移方程了！

由 $f$ 和 $dis$ 的定义可以推出 $f$ 该初始化为：

$$
f_{i,1} = dis_{1,i}
$$

最后可以轻松得出 $f$ 的转移方程为：

$$
f_{i,j} = \min(f_{i,j},f_{q,j-1} + dis_{q+1,i})
$$

整个题最难的地方就被解决了。

## 0x03 ac code
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, a[505], dis[505][505], dp[505][505];


int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
	sort(a+1,a+1+n);
    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j <= n; j++)
        {
            int p=(i+j)/2;
            for(int k=i;k<=j;k++){
            	dis[i][j]+=abs(a[p]-a[k]);
			}
        }
    }

    for (int i = 1; i <= n; i++)
    {
        dp[i][1] = dis[1][i];
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 2; j <= m && j <= i; j++)
        {
            dp[i][j] = INT_MAX;
            for (int q = j - 1; q < i; q++)
            {
                dp[i][j] = min(dp[i][j], dp[q][j - 1] + dis[q + 1][i]);
            }
        }
    }
    cout << dp[n][m] << endl;
    return 0;
}

```

---

## 作者：David_yang (赞：5)

[传送门](https://www.luogu.com.cn/problem/P10967)

我的第十二篇题解。

## 题目大意：

给定 $V$ 个村庄的位置，要求你建 $P$ 个邮局，使每个村庄到最近邮局的距离和最小。

## 算法或数据结构：

动态规划。

## 解析：

先讲讲准备工作，也就是预处理。我们设 $d_{i,j}$ 为在 $i$ 个村庄到第 $j$ 个村庄之间放置一个邮局的最小距离和。所以方程为：

$$
d_{i,j}=\sum_{k=i}^{j}|a_k-a_{\lfloor\frac{i+j}{2}\rfloor}|
$$

其中 $1\le i,j\le n$，$i\le k\le j$（我用 $n$ 代替 $V$，$m$ 代替 $P$）。

预处理好后，接下来就该推状态转移方程了。我们设 $f_{i,j}$ 为在前 $i$ 个村庄放置 $j$ 个邮局的最小距离和。所以状态转移方程也就是：

$$
f_{i,j}=\min\{f_{i-1,k}+d_{k+1,j}\}
$$

其中 $2\le i\le m$，$i\le j\le n$，$i-1\le k\le j-1$。

初始化为：$f_{1,i}=d_{1,i}$（$1\le i\le n$），注意在此之前先把 $f$ 数组里所有的值设为最大值。

答案就是：$f_{m,n}$。

至于为什么要这么做，需要自己去推，想了才有收获。下面我把代码摆出来，自己慢慢理解消化一下。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[305],f[305][305],d[305][305];
int main()
{
	memset(f,0x7f,sizeof(f));                 //初始化
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",a+i);
	}
	sort(a+1,a+n+1);                          //注意要先排序
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=i;k<=j;k++)
			{
				int p=(i+j)>>1;               //位运算，>>1相当于/2
				d[i][j]+=abs(a[k]-a[p]);      //注意要加绝对值
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		f[1][i]=d[1][i];
	}
	for(int i=2;i<=m;i++)
	{
		for(int j=i;j<=n;j++)
		{
			for(int k=i-1;k<=j-1;k++)
			{
				f[i][j]=min(f[i][j],f[i-1][k]+d[k+1][j]);
			}
		}
	}
	printf("%d",f[m][n]);
	return 0;
}
```

注：代码已 AC 过，请放心食用。

最后，浏览过看过也要赞过！

---

## 作者：woden (赞：3)

这是一道 DP 题目。

设 $f_{i,j}$ 为在前 $i$ 个村庄建 $j$ 个邮局的最小距离和，$dis_{i,j}$ 为第 $i$ 个村庄和第 $j$ 个村庄之间修一个邮局的最小距离和。

则：

$$
\large f_{i,j}=\min_{k=0}^{k<i} f_{k,j-1}+dis_{k+1,i}
$$

其中，

$$
\large dis_{i,j}=dis_{i,j-1}+a_j-a_{\lfloor\frac{i+j}{2}\rfloor}
$$

边界条件为：

$$
\large f_{i,1}=dis_{1,i}
$$

（很明显：在前 $i$ 个村庄只修一个邮局的最小距离就是第 $1$ 个村庄和第 $i$ 个村庄之间只修一个邮局的最小距离和）

所以代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define fst ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define endl '\n'
using namespace std;
const int N=399,M=40;
int n,m;
int a[N];
int f[N][M],dis[N][N];
signed main(){
	fst;
	cin>>n>>m;
	memset(f,0x3f,sizeof(f));//因为求的是最小值，所以初始化为最大值 
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			dis[i][j]=dis[i][j-1]+a[j]-a[(j+i)>>1];//求出每一对dis[i][j] 
		}
	}
	for(int i=1;i<=n;i++){
		f[i][1]=dis[1][i];//边界条件 
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=min(i,m);j++){ 
			//枚举i,j		
			for(int k=0;k<i;k++){//枚举修邮局的地点 
				f[i][j]=min(f[i][j],f[k][j-1]+dis[k+1][i]); //状态转移 
			}
		}
	}
	cout<<f[n][m];//输出，AC 
	return 0;
}
```

---

## 作者：StarsIntoSea_SY (赞：3)

# Solution

区间 dp。

记 $f_{i,j}$ 表示前 $i$ 个村庄放 $j$ 个邮局的最小距离和，$w(i,j)$ 表示在第 $i$ 个村庄到第 $j$ 个村庄放一个邮局的最小距离和。

$$
w(i,j)= (\sum_{t=i}^{mid} X_{mid}-X_{t})+(\sum_{t=mid+1}^{j} X_{t}-X_{mid})
$$

$w(i,j)$ 可以递推预处理：

$$
w(i,j)=w(i,j-1)+X_j-X_{\lfloor \frac{i+j}{2} \rfloor}
$$

$f_{i,j}$ 有如下状态转移方程：

$$
f_{i,j}=\min \{ f_{k,j-1}+w(k+1,i) \}
$$

显然 $f_{V,P}$ 为答案。

时间复杂度 $O(PV^2)$。

# Code

```cpp
#include <stdio.h>
#include <string.h>
#define min(a,b) a<b?a:b 
const int N=303;
int w[N][N],dp[N][N];
int v,p,x[N];
int main(){
	scanf("%d%d",&v,&p);
	for(int i=1;i<=v;++i) scanf("%d",&x[i]),w[i][i]=0;
	for(int i=1;i<=v;++i)
		for(int j=i+1;j<=v;++j)
			w[i][j]=w[i][j-1]+x[j]-x[(i+j)>>1];
	
	memset(dp,0x7f,sizeof dp);
	dp[0][0]=0;
	for(int i=1;i<=v;++i)
		for(int j=1;j<=p;++j)
			for(int k=0;k<i;++k)
				dp[i][j]=min(dp[i][j],dp[k][j-1]+w[k+1][i]);
	printf("%d\n",dp[v][p]);
}
```

---

## 作者：_IceCream_ (赞：2)

# Content

可以理解为在数轴上的 $V$ 个 村庄，需要你放 $P$ 个 邮局，使得这 $V$ 个点距离最近邮局总和最小。

# Solution

用 $a$ 来表示这 $V$ 个村庄的位置。

我们考虑现在有 $n$ 个村庄，$1$ 个邮局，那么肯定放的就是这 $n$ 个村庄在数轴上的中间部分。

* 若 $n \bmod 2 = 1$，即 $n$ 为奇数，此时直接放中间那个点就可以了；
* 若 $n \bmod 2 = 0$，即 $n$ 为偶数，此时放中间两个点之间。

不妨直接表示为 $\lceil \dfrac{n}{2} \rceil$。

我们可以依照这个思路来推。

---

很显然的，这是一个区间 dp，一个区间与它的子区间与邮局位置有关。不妨设 $f_{i,j}$ 为前 $i$ 个村庄中，设置 $j$ 个邮局的最小距离和。

考虑在 $k$ 这个位置新放一个邮局，那么它影响到的就是 $k$ 到 $i$ 这一段距离，转移也就是这样。

$$f_{i,j} = \min(f_{k,j-1} + \text{k 到 i 的最小距离和})$$

这个最小距离和~~看着不顺眼~~可以预处理出来，就根据我们前面推导的东西，可以设 $g_{i,j}$ 为第 $i$ 到第 $j$ 个村庄放一个邮局的最小距离和。以类似前缀和的方式很容易得到转移。

$$g_{i,j} = g_{i,j-1} + \lvert a_j - a_{\lceil \frac{i+j}{2} \rceil} \rvert \\ f_{i,j} = \min(f_{k,j-1} + g_{k+1,i})$$

因为只放一个邮局跟 $g$ 的定义是一样的，所以 $f$ 的初值 $f_{i,1} = g_{1,i}$。

于是我们以 $O(PV^2)$ 的复杂度通过了本题。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 300 + 5;
int n, m;
int a[N];

int f[N][N];
int g[N][N];

int main () {
	
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) scanf ("%d", &a[i]);
	
	sort (a + 1, a + n + 1);
	
	for (int i = 1; i <= n; ++i)
		for (int j = i; j <= n; ++j) 
			for (int k = i; k <= j; ++k) {
				int mid = ceil ((i + j) >> 1); // 第 i 个村庄到第 j 个村庄的中间部分，直接用绝对值减权值。
				g[i][j] += abs (a[mid] - a[k]);
			}
	
	// 除 f[i][1] 部分以外别忘赋最大值 
	memset (f, 0x3f3f3f3f, sizeof f);
	for (int i = 1; i <= n; ++i) f[i][1] = g[1][i];
	
	for (int i = 1; i <= n; ++i)
		for (int j = 2; j <= min (i, m) /*因为 i 个位置最多只能放 i 个邮局，所以要比最小值*/; ++j) 
			for (int k = 0; k < i; ++k)
				f[i][j] = min (f[i][j], f[k][j - 1] + g[k + 1][i]);
	
	printf ("%d", f[n][m]);
	
	return 0;
}
```

---

## 作者：xiezheyuan (赞：2)

> **摘要**：本文将介绍一种 **决策单调性分治** 做法。

首先有一个 dp，设 $f(i,j)$ 表示考虑到前缀 $[1,i]$ 已经放了 $j$ 个邮局的答案，则不难有转移：

$$
f(i,j)=\min_{k=0}^{i-1}f(k,j-1)+w(k+1, i)
$$

其中 $w$ 是一个可以 $O(V^2)$ 递推的一个玩意。

观察这个转移式，可以按照 $j$ 分层，$f(,j)$ 之间不会影响，而只有 $f(,j-1)$ 才会对 $f(,j)$ 产生直接的影响。于是可以考虑依次求出每一层的答案。

由于 $w$ 满足四边形不等式，所以我们可以分治求出每一层的 dp 值。

具体来说，假设现在分治到区间 $[l,r]$，设 $m$ 为区间中点，目前最优决策点位于 $[L,R]$，则我们可以暴力求出 $m$ 的决策点 $p$，然后 $[l,m-1]$ 的决策点一定位于 $[L,p]$，$[m+1,r]$ 的决策点一定位于 $[p,R]$，规模得到缩减，于是我们可以继续分治。

时间复杂度 $O(VP\log P)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 3e3 + 5;
int n, m, a[N], f[N], g[N], w[N][N];

void solve(int l, int r, int L, int R){
    if(l > r) return;
    int mid = (l + r) >> 1, s = L;
    auto wgt = [&](int k, int i){ return g[k] + w[k + 1][i]; };
    for(int i=L;i<=min(R, mid - 1);i++){
        if(wgt(i, mid) < wgt(s, mid)) s = i;
    }
    f[mid] = wgt(s, mid);
    solve(l, mid - 1, L, s);
    solve(mid + 1, r, s, R);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m;
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			w[i][j]=w[i][j-1]+a[j]-a[(i+j)>>1];
		}
	}
    for(int i=1;i<=n;i++) f[i] = w[1][i];
    for(int i=2;i<=m;i++){
        copy(f + 1, f + n + 1, g + 1);
        solve(1, n, 1, n);
    }
    cout << f[n] << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Lfz312g (赞：1)

# Solution
## 题目分析
可以使用区间 DP 求解。  
设 $f(i,j)$ 表示前 $i$ 个村庄装 $j$ 座邮局所需的费用，设 $dis(i,j)$ 表示第 $i$ 个村庄和第 $j$ 个村庄之间安装一座邮局的最小距离之和。  
枚举分割点 $k$，显然有状态转移方程:
$$
f(i,j)=\min\left\{f(k,j-1)+dis(k+1,i)\right\} 
$$
即 $f(i,j)$ 表示前 $i$ 个村庄，用 $j$ 个邮局的最短路径等于前 $k$ 个村庄用 $j-1$ 个邮局加上 $k+1$ 到 $i$ 之间安装一座邮局的最小路径。
其中对于 $dis$ 数组有递推方程：
$$
dis(i,j)=dis(i,j-1)+a_j-a_{(i+j)/2}
$$
对于奇数点，在中位数上建邮局距离最短，对于偶数点，在中间两点间的任意一点最短。  
最终答案即为 $f(n,m)$。  
时间复杂度为 $O(m \times n^2)$。其中 $n$ 为村庄数，$m$ 为邮局数。

```cpp
#include <bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
typedef long long ll;
ll a[305],f[305][305],dis[305][305];
int main()
{
	int n,m;
	cin>>n>>m;
	ffor(i,1,n) cin>>a[i];
	ffor(i,1,n) ffor(j,i+1,n) dis[i][j]=dis[i][j-1]+a[j]-a[(i+j)/2];
	memset(f,0x3f,sizeof f);
	f[0][0]=0;
	ffor(j,1,m) ffor(i,j,n) ffor(k,0,i-1) f[i][j]=min(f[i][j],f[k][j-1]+dis[k+1][i]);
	cout<<f[n][m];
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 思路

首先将坐标排序。

定义 $dp_{i,j}$ 为前 $i$ 个村庄放 $j$ 个邮局的前 $i$ 个村庄的最小距离总和，$f(i,j)$ 表示村庄区间 $[i,j]$ 内放一个村庄时该区间的总和。

转化式易得 $dp_{i}{j}=dp_{k}{j-1}+f(k+1,i),k\in [0,i)$。

则本题的难点就为求 $f(k-1,i)$。

基本的数学知识，若村庄数为奇数，放中位数处距离和最小。若村庄为偶数，放中间两个村庄之间任意一处均可。

于是就得到了一个 $O(PV^{3})$ 的做法。


```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=3010,N=310;
int V,P,X[MAXN],dp[MAXN][N];
int f(int l,int r) {
	int mid=l+r>>1,ans=0;
	for(int i=l;i<mid;i++) ans+=X[mid]-X[i];
	for(int i=mid+1;i<=r;i++) ans+=X[i]-X[mid];
	return ans;
}
int main() {
	cin>>V>>P;
	for(int i=1;i<=V;i++) cin>>X[i];
	sort(X+1,X+V+1);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int j=1;j<=P;j++) {
		for(int i=1;i<=V;i++) {
			for(int k=0;k<i;k++) {
				dp[i][j]=min(dp[k][j-1]+f(k+1,i),dp[i][j]);
			}
		}
	}
	cout<<dp[V][P]<<endl;
	return 0;
}
```

---


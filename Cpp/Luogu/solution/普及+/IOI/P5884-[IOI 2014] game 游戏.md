# [IOI 2014] game 游戏

## 题目描述

健佳是一个喜欢做游戏的小男生。当有人问问题时，他更喜欢通过玩游戏的方式作答，而不是直接回答。健佳碰到了他的朋友梅玉，跟她讲了台湾的航空网。在台湾有 $n$ 个城市（编号为 $0,\cdots,n−1$），其中有些城市之间有航线。每个航线连接两个城市，并且是双向的。

梅玉问健佳，是否任意两个城市之间都可以坐飞机互达（直接或间接），健佳不想直接回答，而是要通过做游戏的方式来告诉她。梅玉可以问"城市 $u$ 和 $v$ 之间有直接航线吗？"，健佳会立刻直接回答该问题。梅玉会询问每对城市恰好一次，因此总计会有 $r = \frac{n (n−1)}{2}$ 个问题。如果由前 $i$（$i<r$）个问题的答案可以推断出整个航空网是否连通，也就是说，是否任意一对城市之间都可以坐飞机互达（直接或间接），梅玉就获胜。否则意味着她需要知道全部 $r$ 个回答，此时健佳获胜。

为了让游戏更好玩，他们俩同意，健佳可以不要管台湾的真实航空网，而是可以随着游戏的进展而编造航空网，也就是根据梅玉此前的提问来决定此后如何作答。你的任务是，通过决定健佳如何回答，来帮助他赢得游戏。

## 说明/提示

**子任务及数据规模**

| 子任务 | 分值 | $n$ |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n=4$ |
| $2$ | $27$ | $4 \le n \le 80$ |
| $3$ | $58$ | $4 \le n \le 1500$ |


## 样例 #1

### 输入

```
4
0 3
1 0
0 2
3 1
1 2
2 3
```

### 输出

```
0
1
0
1
0
1
```

# 题解

## 作者：清平乐 (赞：8)

这是一道构造题

构造出来后巨水，但要是想不到就GG

不妨将这个图考虑成树，只有当树上的每条边都被询问后才知道这棵树是否联通

那我们现在尽量让树的边最后被询问到就行了

也就是说我们让每个点最后被询问到的边成为树边就ok了

比如下面这张图，红色的边为每个点最后被询问到的边，红边就构成了一棵生成树
![](https://cdn.luogu.com.cn/upload/image_hosting/rec88j5q.png)

下面考虑代码实现，$n$ 个节点的完全图中有 $\frac{n(n-1)}{2}$ 条边，考虑以 $0$ 为根，第 $i$ 个点的父亲规定只能是编号比 $i$ 小的点，显然这样的边有 $i$ 条，如此总边数依然是 $\frac{n(n-1)}{2}$

那么对于这 $i$ 条边，我们保留最后出现的那一条的端点为 $i$ 的父亲。这样的话，只有到第 $\frac{n(n-1)}{2}$ 
  个询问，我们才能知道最后一个点的父亲，才能确定图的联通性。
  
代码真的很短。。。
  
```cpp
#include<stdio.h>
#include<bits/stdc++.h>
using namespace std;

int n,r,u,v;
int deg[1005];

int main(void)
{
	scanf("%d",&n);
	r=n*(n-1)>>1;
	while(r--)
	{
		scanf("%d%d",&u,&v);
		if(u<v) swap(u,v);
		printf("%d\n",++deg[u]==u);
	}
	return 0;
}
```


---

## 作者：zzqDeco (赞：3)

这道题的思路在于，考虑生成树的过程，而这道题的过程就是在不断遍历边来考虑，那我们只要对于一个点在最后的边才让他相连

那么我们定义一下边的方向是从大到小，这样每个点就对应了一个边，那么当大的边没有其他的可以选择的时候，那就必须要选择

这样的话我们一定会留下一条边在最后他无法判断，这一点类似于生成树的特点

下面放代码

```cpp
#include <cstdio>

using namespace std;

int n;

int cnt[1000010];

int main()
{
  scanf("%d",&n);
  for(int i=1;i<=(n)*(n-1)/2;i++)
  {
    int a,b;
    scanf("%d%d",&a,&b);
    if(a<b) a=b;
    if(++cnt[a]==a)
    {
      printf("1\n");
    }
    else
    {
      printf("0\n");
    }
  }
}

---

## 作者：Happy_Orca (赞：2)

给一个详细的解释：

首先，使一张图连通所需的最小边数为 $n-1$ (就是一棵树)，我们将可以相互到达的城市看做一个连通块。

如果这张图本身不能够连通，因为每条路最多将两个连通块合并，想要将 $n$ 个连通块合并需要 $n-1$ 条路，所以梅玉能在剩余不知情的道路数无法使图连通时做出正确判断

如果这个图是连通的，那么梅玉在最后两个连通块合并之前是不可能判断出这张图是连通的。

根据以上两个判断，我们不难想出一种构造方法：保证整张图是连通的，但对于前 $\dfrac{n(n-1)}{2}-1$ 个询问，我们保证能且只能构造出两个连通块，并且最后的两个点不在同一连通块中。 

对于连通块之间的判断借助并查集就可以很好地解决，我们先将最后两个点默认连通，然后利用建树的想法，将不连通的点之间建边，一共建 $n-1$ 条边，这样就能保证在得知最后两个点之前无法判断图的连通

以下是我的代码，实现方法有很多种，选自己习惯的写就好了
```cpp
#include<bits/stdc++.h>
#define maxn 1124255
using namespace std;
int n,fa[maxn],x[maxn],y[maxn],ans[maxn];
inline int read(){
	int ret=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
inline int getfa(int x){
	return x==fa[x]?x:fa[x]=getfa(fa[x]);
}
int main(){
	n=read();n=n*(n-1)/2;
	for(int i=1;i<=n;i++){
		fa[i]=i;x[i]=read(),y[i]=read();
	}fa[x[n]]=y[n];ans[n]=1;
	for(int i=n-1;i>=1;i--){
		int fx=getfa(x[i]),fy=getfa(y[i]);
		if(fx==fy) ans[i]=0;
		else ans[i]=1,fa[fx]=fy;
	}
	for(int i=1;i<=n;i++) printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：DPair (赞：2)

提供一种略有不同的构造方法。

## 【思路】
我们不难发现，可以判断一幅图的连通性的情况只有一种：

**存在一个确定的连通块，且这个联通块的所有出边都确定是不连通的。**

（整幅图连通可以看做没有出边，自然这些不存在的出边都可以看做是不连通的）

于是我们考虑破坏这个条件。

于是我们只要使得这个确定的联通快总有一条出边是不确定的即可。

由于最后一个询问结束后答案一定就被知道了，因此我们要使得最后一条边不确定。

也就是使得最后一条边连接的两个点中的**任意一个**都没有出现在前面的任何一个连通块中即可。（这里我选择两个点中的后者，当然前者也是可以的）

然后为了防止前面出现一个 **所有出边都确定是不连通的** 的连通块，考虑使得最后一条边插入之前，前面的所有点是连通的（或者是不确定的），就可以保证在最后一条边加入之前，不会出现对方得出答案的情况。

还没看懂的看代码好了，我觉得我说的已经够清楚了。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int u[2250005], v[2250005];
int main(){
    scanf("%d", &n);
    for (register int i = 1;i <= ((n * (n - 1)) >> 1);i ++){
        scanf("%d%d", &u[i], &v[i]);
    }
    for (register int i = 1;i < ((n * (n - 1)) >> 1);i ++){
        if(u[i] == v[(n * (n - 1)) >> 1] || v[i] == v[(n * (n - 1)) >> 1]) printf("0\n");
        else printf("1\n");
    }
    printf("1\n");
}
```

---

## 作者：在想Peach (赞：2)

一种简单的构造方法

既然需要知道最后一个边才能下结论，那么在判断最后一个边之前必定只剩下两个联通块，且最后一个边可以连接这两个联通块。

所以我们先让最后一个边存在，倒着判联通建树（参考不排序的最小生成树），即可满足题意。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<vector>
#include<cmath>
#define int long long
using namespace std;
const int maxn=4000005;
int n,tx[maxn],ty[maxn],f[maxn];
int ans[maxn],mx;
int read(){
	char z=getchar();int x=0,y=1;
	while(z<'0'||z>'9'){if(z=='-')y=-1;z=getchar();}
	while(z<='9'&&z>='0'){x=x*10+z-'0';z=getchar();}
	return x*y;
}
int find(int x){return (f[x]==x)?x:f[x]=find(f[x]);}
signed main(){
	n=read();mx=n*(n-1)/2;
	for(int i=1;i<=mx;i++){
		tx[i]=read()+1;ty[i]=read()+1;
	}
	for(int i=1;i<=n;i++)f[i]=i;
	f[tx[mx]]=ty[mx];ans[mx]=1;
	for(int i=mx-1;i>=1;i--){
		int fx=find(tx[i]),fy=find(ty[i]);
		if(fx!=fy){f[fx]=fy;ans[i]=1;}
	}
	for(int i=1;i<=mx;i++)printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：D2T1 (赞：1)

# 题解 P5884

IOI 简单题……

如果要问出最后一个问题才能判断连不连通，那我们就把最后一个问题中连接的两个点其中一个孤立开，让这个点只靠最后一条边和其它点连通即可。

步骤：先读入所有问题，取最后一个问题中任意一点 $x$，再遍历所有问题回答。若一个问题中出现 $x$ 则回答 $0$ 否则 $1$。最后一个问题特殊处理回答 $1$。

```cpp
//P5884
#include <bits/stdc++.h>
using namespace std;

const int N = 1510;
int n, r, k, a[N*N/2], b[N*N/2];

int main(){
	scanf("%d", &n); r = n * (n-1) / 2;
	for(int i = 1; i <= r; ++ i) scanf("%d%d", &a[i], &b[i]);
	int k = a[r];
	for(int i = 1; i <= r-1; ++ i) putchar(a[i]==k||b[i]==k ? '0' : '1'), putchar('\n');
	puts("1");
	return 0;
}
```

---

## 作者：C3H5ClO (赞：1)

## [题目链接](http://uoj.ac/problem/26)

这种思维题评成绿题。。。

由于最后一次询问不影响结果，我们假设最后一次询问回答1。

考虑这样一个事情：回答1的边构成一棵树。

证明：对于不构成一棵树的情况，如果不连通，那么中途就可以直接判断整个不连通；否则，这些边必定会形成环，而对于环上的任意一条边，只要询问了环上其他边就可以直接判断出图连通，不需要询问这条边。

此时有两种解法：

1.将连通的点放入同一个并查集。对于一个询问，如果边的两个端点所属并查集之间只剩下这一条边，那么连，否则不连

2.给边定向，从编号大的连向编号小的。对于一个询问，如果这是其中一个端点的最后一条出边，那么连，否则不连。

容易证明，上述两种做法都能保证在最后一次询问前不被推测出结果。

1证明：如果得到的图不连通，则一定存在两个并查集之间只剩下一条边却没有连，与构造方法矛盾，因此不可能在中途判断出不连通；直到最后一次询问图才连通，因此不可能在中途判断出连通。

2证明：除了0号点，每个点都一定会向比自己编号小的点连一条边，必定直接或间接与0号点连通，因此不可能在中途判断出不连通；第i个点（不包括0号点）的全部出边被询问时连第i条边，则第n-1个点（不包括0号点）的全部出边被询问时连第n-1条边，因此直到最后一次询问图才连通，不可能在中途判断出连通。

---

## 作者：Schi2oid (赞：0)

一道神仙思维题。原题是交互题，所以我们来讲强制在线的做法，讲一些思路上的细节。
# 题意简述
给出 $n$ 个点，每两个点之间都可能会有一条边。以随机的顺序询问所有两点之间的连边情况，你需要回答这两点之间是否连边，保证询问者只能在得到所有的答案之后才能判断“任意两点之间都直接或间接联通”这一命题的真伪。

图不一定需要在一开始确定，$n \leq 1500$。
# 思路分析

设一条边是从较小数指向较大数的，那么容易发现，对于结点 $k$ ，应当有 $k$ 条待定的入边，$n-k-1$ 条待定的出边。

我们可以尝试构造一棵以结点 $0$ 为根的树，涵盖所有结点。即所有结点都从 $k$ 条入边中选且仅选一条，则每一个结点的连通性仅由其入边决定。这样设计构造方案保证了每一个结点与其他所有结点的连通性只与它的入边有关，因为最终每一个结点都将在这棵树当中。所以，结点 $k$ 的连通性被确定只有以下两种可能：
- 1）这 $k$ 条边都确定为断开；
- 2）这 $k$ 条边中有一个确定为连接。

所以，我们只需要保证这两条都不满足，直到这个结点的所有入边都已经被询问过。对于每一个结点都满足题目要求，自然全图满足题目要求。也就是说，除最后一条入边之外，每条边都设定为断开即可。

在最开始时初始化每一个结点的入度，在过程当中更新入度，直到询问中较小的点入度变为 $1$ 时输出 $1$ ，否则输出 $0$ 即可。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int d[1505]={0};
int main(){
	int n,u,v;
	cin>>n;
	for(int i=0;i<n;i++) d[i]=i;//入度初始化
	for(int i=1;i<=n*(n-1)/2;i++){
		scanf("%d%d",&u,&v);
		if(u>v) d[u]--;//更新入度
		else d[v]--;//更新入度
		if(u>v&&!d[u]||v>u&&!d[v]) cout<<"1\n";//判断入度是否恰为1
		else cout<<"0\n";
	}
	return 0;
}
```


---

## 作者：Aw顿顿 (赞：0)

因为没有交互，所以思维难度在一定程度上被降低了，但是依然很妙，不好想。

尝试去构造，这个构造还不好想。由于是连通性，考虑生成树，只有当生成树的每一条边都被询问到，才能判定连通，那我们为了让对方最后才能猜到，就要让生成树的边尽可能晚被确定。

考虑以当 $x$ 之前与其询问的点已经到达 $x$ 条，第 $x$ 条输出 $1$，使得连通性最后被判断。认真理解一下，代码很容易实现，若是不理解精髓而只看代码是没有益处的。

```cpp
#include<bits/stdc++.h>
#define N 1000001
using namespace std;
int n,f[N];
signed main(){
    std::ios::sync_with_stdio(false);
	cin>>n;
	for(register int i=1;i<=(n*(n-1)/2);i++){
		int x,y;cin>>x>>y;
		if(y>x){
			int t=x;
			x=y;
			y=t;
		}
		++f[x];
		if(x==f[x]){
			puts("1");
		}
		else{
			puts("0");
		}
	}
	return 0;
}
```

---

## 作者：lnwzy (赞：0)

看了一圈，没有和我的方法一样的，我的机会来了！

我的思路比较诡异，类似并查集却不一样。我只维护了一个联通块，利用一个$vis$变量，标记这个点是否在联通块里。整个联通块以最后一条边为中心，这样可以保证只有知道最后一条边联通才知道整个图联通。当两个点一个$vis$值为$1$,另一个$vis$值为$0$时连这条边，所以连出的这个图保证没有环，因为每两个点之间都会有一次询问，所以最后的图一定是联通的。综上，可以证明我的算法是正确的。

上代码：

```cpp
#include<cstdio>
int x[1125005],y[1125005],vis[1125005],ans[1125005];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n*(n-1)/2;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	vis[x[n*(n-1)/2]]=1;
	vis[y[n*(n-1)/2]]=1;
	ans[n*(n-1)/2]=1;//先把最后一条边连上
	for(int i=n*(n-1)/2-1;i>=1;i--)
	{
		if(vis[x[i]]==0&&vis[y[i]]==1)
		{
			vis[x[i]]=1;
			ans[i]=1;
		}
		if(vis[x[i]]==1&&vis[y[i]]==0)
		{
			vis[y[i]]=1;
			ans[i]=1;
		}//这些边也必须连
	}
	for(int i=1;i<=n*(n-1)/2;i++)
	{
		printf("%d\n",ans[i]);
	}
	return 0;
}
```

Thanks for your attention!

---


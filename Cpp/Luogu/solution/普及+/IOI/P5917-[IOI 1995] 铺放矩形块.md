# [IOI 1995] 铺放矩形块

## 题目描述

给定 $ 4 $ 个矩形块，找出一个最小的封闭矩形将这 $ 4 $ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

所有 $ 4 $ 个矩形块的边都与封闭矩形的边相平行。

可能存在满足条件且有着同样面积的各种不同的封闭矩形， 你应该输出所有这些封闭矩形的边长。


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5```

### 输出

```
40
4 10
5 8```

# 题解

## 作者：Zona (赞：7)

本题的主要思路是先画出矩形的几种基本布局，然后枚举每种情况，最后全排列输出，下面我将给大家逐一分析。

---------------------------

### $step1:$

先读题:"给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$个矩形块放入，但不得相互重叠。"

不得重叠好办，我们只要把$4$个矩形块摆放在不同的位置，再枚举情况就好了![](https://cdn.luogu.com.cn/upload/image_hosting/j9jf4tfz.png)

这时有人就要说了：那摆放位置这么多，你叫我枚举到昏天黑地啊
![](https://cdn.luogu.com.cn/upload/image_hosting/nq1wy6tk.png)

别急，我们只用找出这$4$个矩形块的**基本布局**，其他的则都由这种/些布局**旋转、翻转**而成，例如下面：
![](https://cdn.luogu.com.cn/upload/image_hosting/efpt5yd6.png)

经过这样一番操作，~~很快~~就得到了以下这$5$种：
![](https://cdn.luogu.com.cn/upload/image_hosting/meg1b1w7.png)

然后就开始进行下一步，模拟枚举各种情况。

---------------------------------

### $step2:$

先看第一种布局，是$4$个矩形块并排放，所以那个最小封闭矩形的水平边（以下简称$x$）就是$4$个矩形块的水平边，垂直的边（以下简称$y$）就是$4$矩形中最长矩形的垂直边。
```
//case1：
re.x=0; re.y=0;
for(int i=0;i<4;++i){
	re.x+=a[i].x;//累加每个矩形的x
	if(a[i].y>re.y)re.y=a[i].y;//如果有更长的就更新
}
```

第二种布局和第一种类似，但是要考虑横着的矩形，所以我们先处理后$3$个矩形的$x$和$y$，如果第$1$个矩形的$x$大于现有的$x$，就更新，然后再加上第$1$个矩形的$y$。
```
//case2:
re.x=0;re.y=0;
for(int i=1;i<4;++i){//处理后三个矩形
	re.x+=a[i].x;//累加x
	if(a[i].y>re.y)re.y=a[i].y;//更新长度
}
if(a[0].x>re.x)re.x=a[0].x;//如果第1个矩形的x大于现有的x，就更新
re.y+=a[0].y;//加上第1个矩形的y
```
第三种布局的方法就不同了,它直接找出$4$个矩形组合起来最大的$x$和$y$。
```
//case3:
re.x=max(a[0].x+a[1].x,a[2].x)+a[3].x;//第1个矩形+第2个矩形的x和第3个矩形的x相比较，谁大就和第4个矩形的x相加
re.y=max(max(a[0].y,a[1].y)+a[2].y,a[3].y);//首先第1个矩形的y和第2个矩形的y相比较，谁大，谁就加上第3个矩形的y，再和第4个矩形的y比较。
```

第四种与第三种相似，就不细说了。
```
//case4:
re.x=a[0].x+max(a[1].x,a[2].x)+a[3].x;
re.y=max(max(a[0].y,a[1].y+a[2].y),a[3].y);
//可以根据样例带入图比较
```

第五种布局比较麻烦，需要多次比较与更新$x$和$y$。
```
//case5:
re.x=a[0].x+a[1].x;//先初始x值为第1个矩形和第2个矩形的x之和
re.y=max(a[0].y+a[2].y,a[1].y+a[3].y);//判断这两个的y谁更长，具体可以带入图中看看
if(a[0].y<a[1].y)
	re.x=max(re.x,a[2].x+a[1].x);
if(a[0].y+a[2].y>a[1].y)
	re.x=max(re.x,a[2].x+a[3].x);
if(a[1].y<a[0].y)
	re.x=max(re.x,a[0].x+a[3].x);
//根据几条y的长度来更新x值
re.x=max(re.x,a[2].x);
re.x=max(re.x,a[3].x);
//再逐一比较x值是否大于每个矩形块的x
```

-------------------------------------
### $step3:$
经过艰辛的枚举，我们终于得到了这个最小封闭矩形的面积，可我们还要输出所有可能的边长，这时就要用到**全排列**了。
```
void dfs(int k){
    if(k==4){
        Calc();//如果k=4就继续枚举
    }else{
        for(int i=k;i<4;++i){
            dfs(k+1);swap(a[k].x, a[k].y);
            dfs(k+1);swap(a[k].x, a[k].y);
            //两次递归交换边长
            swap(a[k], a[i]);
            dfs(k+1);
            swap(a[k], a[i]);
            //经过一次次的循环递归最后得出结果
        }
    }
}
```
$PS:$不了解全排列的请自行搜索，我这里就不百科了。

------------------------------------

这三步完成之后，就剩下一些输入输出和更新面积之类的小问题，可以看下面的代码和注释。

$AC Code$:
```
#include<bits/stdc++.h>
using namespace std;
struct ret{
    int x,y;
}a[4],re;
int rec=10000,res[101];
void area(){
    if(re.x*re.y<rec){
        rec=re.x*re.y;//如果有更小的面积就更新
        memset(res,0,sizeof(res));//清空数组
    }
    if(re.x*re.y==rec){
        res[min(re.x,re.y)]=1;//如果刚好等于rec，则更小的边长重新赋值为1
    }
}
void Calc(){
    //case1:
    re.x=0; re.y=0;
    for(int i=0;i<4;++i){
		re.x+=a[i].x;//累加每个矩形的x
		if(a[i].y>re.y)re.y=a[i].y;//如果有更长的就更新
    }
    area();//更新面积

    //case2:
    re.x=0;re.y=0;
    for(int i=1;i<4;++i){//处理后三个矩形
		re.x+=a[i].x;//累加x
		if(a[i].y>re.y)re.y=a[i].y;//更新长度
    }
    if(a[0].x>re.x)re.x=a[0].x;//如果第1个矩形的x大于现有的x，就更新
    re.y+=a[0].y;//加上第1个矩形的y
    area();

    //case3:
    re.x=max(a[0].x+a[1].x,a[2].x)+a[3].x;//第1个矩形+第2个矩形的x和第3个矩形的
    x相比较，谁大就和第4个矩形的x相加
    re.y=max(max(a[0].y,a[1].y)+a[2].y,a[3].y);//首先第1个矩形的y和第2个矩形的
    y相比较，谁大，谁就加上第3个矩形的y，再和第4个矩形的y比较。
    area();

    //case4:
    re.x=a[0].x+max(a[1].x,a[2].x)+a[3].x;
    re.y=max(max(a[0].y,a[1].y+a[2].y),a[3].y);
    //可以根据样例带入图比较
    area();

    //case5:
    re.x=a[0].x+a[1].x;//先初始x值为第1个矩形和第2个矩形的x之和
    re.y=max(a[0].y+a[2].y,a[1].y+a[3].y);//判断这两个的y谁更长，具体可以带入图中看看
    if(a[0].y<a[1].y)
        re.x=max(re.x,a[2].x+a[1].x);
    if(a[0].y+a[2].y>a[1].y)
        re.x=max(re.x,a[2].x+a[3].x);
    if(a[1].y<a[0].y)
        re.x=max(re.x,a[0].x+a[3].x);
    //根据几条y的长度来更新x值
    re.x=max(re.x,a[2].x);
    re.x=max(re.x,a[3].x);
    //再逐一比较x值是否大于每个矩形块的x
    area();
}
void dfs(int k){
    if(k==4){
        Calc();//如果k=4就继续枚举
    }else{
        for(int i=k;i<4;++i){
            dfs(k+1);swap(a[k].x, a[k].y);
            dfs(k+1);swap(a[k].x, a[k].y);
            //两次递归交换边长
            swap(a[k], a[i]);
            dfs(k+1);
            swap(a[k], a[i]);
            //经过一次次的循环递归最后得出结果
        }
    }
}
int main(){
    for(int i=0;i<4;++i)
        cin>>a[i].x>>a[i].y;
    dfs(0);
    cout<<rec<<endl;
    for(int i=1;i<=100;++i)
	if(res[i]) cout<<i<<" "<<rec/i<<endl;
    return 0;
}
```


---

## 作者：ChampionCyan (赞：2)

# P5917 题解

## 前言


[闲话](https://www.luogu.com/paste/p11xf7jb)。

[更美观清晰的体验](https://www.luogu.com/paste/qsww0lv1)，必看！

[双倍经验](https://www.luogu.com.cn/problem/P1212)，题目完全一样，所以与[这篇题解](https://www.luogu.com.cn/article/20b9e0ci/)内容几乎一样。

## 思路与做法大纲

这题有 $6$ 种排列方式：


![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

为了接下来的操作，我们先定义一些东西：

```cpp
/*<==============函数定义==============>*/
inline void init();//输入
inline void part1();//排列方案1
inline void part2();//排列方案2
inline void part3();//排列方案3
inline void part4();//排列方案4
inline void part5();//排列方案5
inline void part6();//排列方案6
inline void update(int, int);//更新答案
inline void do_it();//工作
inline void work(int);//工作
inline void solve();//解答
```
主函数代码很简单了：

```cpp
/*<==============主函数==============>*/
int main() {
    init();
    solve();
    return 0;
}
```

然后我们用之前定义的 mp 判断输入是否重复，这样我们就得到了 update 函数的代码：

```cpp
inline void update(int length, int width) {
    if (length > width)
        swap(length, width);
    if (length * width > ans || mp.count(make_pair(length, width)) > 0)
        return;
    /*<================以上情况不用更新！================>*/
    //更新
    mp.insert(make_pair(length, width));
    if (length * width < ans) {
        ans = length * width;
        res.clear();
        mp.insert(make_pair(length, width));
    }
    res.push_back(make_pair(length, width));
}
```

再将工作的三个函数框架写出来：

```cpp
inline void do_it() {
    part1();
    part2();
    part3();
    part4();
    part5();
    part6();
}

inline void work(int depth) {
    if (depth == 5) {
        do_it();
        return;
    }
    for (int i = 0; i < 4; i++) {
        swap(rec[order[i]].length, rec[order[i]].width);//旋转
        work(depth + 1);//下一种排列
        swap(rec[order[i]].length, rec[order[i]].width);//回溯
        work(depth + 1);//下一种排列
    }
}

inline void solve() {
    do
        work(1);
    while (next_permutation(order, order + 4));
    printf("%d\n", ans);
    sort(res.begin(), res.end());
    for (int i = 0; i < res.size(); i++)
        printf("%d %d\n", res[i].first, res[i].second);
}
```

框架就写好了，然后就是最难的 part1~part6 函数了！

请读者看以下内容时先思考一会儿！

### Part1

$4$ 个并排放。

很简单，画图理解一下，长是和，宽是最短的宽。

```cpp
inline void part1() {
    update(rl(0) + rl(1) + rl(2) + rl(3), max(max(rw(0), rw(1)), max(rw(2), rw(3))));
}
```

### Part2

三竖一横。

```cpp
inline void part2() {
    update(max(rl(0) + rl(1) + rl(2), rl(3)), max(rw(0), max(rw(1), rw(2))) + rw(3));
}
```

### Part3

有些复杂，但也不难想。

```cpp
inline void part3() {
    update(max(rl(0) + rl(1), rl(2)) + rl(3), max(rw(3), max(rw(0), rw(1)) + rw(2)));
}
```

### Part4

两个夹两个。

```cpp
inline void part4() {
    update(rl(0) + max(rl(1), rl(2)) + rl(3), max(rw(3), max(rw(0), rw(1) + rw(2))));
}
```



### Part5

与第四种很像，区别在于第四种夹心，第五种两个矩形位于旁边。

```cpp
inline void part5() {
    update(max(rl(0), rl(1)) + rl(2) + rl(3), max(max(rw(0) + rw(1), rw(2)), rw(3)));
}
```

### Part6

有点像奥数题，仔细画图想想！

`length` 要分情况讨论，`width` 就是左边两个长的和与右边两个长的和的最小值。

```cpp
inline void part6() {
    //比较复杂，慢慢来
    int length;
    if (rw(2) >= rw(1) + rw(3))
        length = max(max(rl(0), rl(1) + rl(2)), rl(2) + rl(3));
    else if (rw(3) < rw(2))
        length = max(rl(0) + rl(1), max(rl(1), rl(3)) + rl(2));
    else if (rw(2) == rw(3))
        length = max(rl(0) + rl(1), rl(2) + rl(3));
    else if (rw(2) < rw(3) && rw(3) < rw(2) + rw(0))
        length = max(rl(0) + rl(1), max(rl(0), rl(2)) + rl(3));
    else if (rw(3) >= rw(0) + rw(2))
        length = max(rl(1), max(rl(0), rl(2)) + rl(3));
    update(length, max(rw(0) + rw(2), rw(1) + rw(3)));
}
```

这样就写完了。

## Code

```cpp
/*<=====头文件，命名空间和宏定义=====>*/
#include <bits/stdc++.h>
#define rl(i) rec[order[i]].length
#define rw(i) rec[order[i]].width
using namespace std;

/*<==============基础定义==============>*/
struct rectangle {
    int length, width;
} rec[4];//长方形们

int order[4] = {0, 1, 2, 3};//排列顺序，初始时有序
int ans = 2e9;//答案，初始时设为极大值
set<pair<int, int> > mp;
vector<pair<int, int> > res;

/*<==============函数定义==============>*/
inline void init();//输入
inline void part1();//排列方案1
inline void part2();//排列方案2
inline void part3();//排列方案3
inline void part4();//排列方案4
inline void part5();//排列方案5
inline void part6();//排列方案6
inline void update(int, int);//更新答案
inline void do_it();//工作
inline void work(int);//工作
inline void solve();//解答

/*<==============主函数==============>*/
int main() {
    init();
    solve();
    return 0;
}

inline void init() {
    for (int i = 0; i < 4; i++)
        scanf("%d%d", &rec[i].length, &rec[i].width);
}

inline void update(int length, int width) {
    if (length > width)
        swap(length, width);
    if (length * width > ans || mp.count(make_pair(length, width)) > 0)
        return;
    /*<================以上情况不用更新！================>*/
    //更新
    mp.insert(make_pair(length, width));
    if (length * width < ans) {
        ans = length * width;
        res.clear();
        mp.insert(make_pair(length, width));
    }
    res.push_back(make_pair(length, width));
}

inline void part1() {
    update(rl(0) + rl(1) + rl(2) + rl(3), max(max(rw(0), rw(1)), max(rw(2), rw(3))));
}

inline void part2() {
    update(max(rl(0) + rl(1) + rl(2), rl(3)), max(rw(0), max(rw(1), rw(2))) + rw(3));
}

inline void part3() {
    update(max(rl(0) + rl(1), rl(2)) + rl(3), max(rw(3), max(rw(0), rw(1)) + rw(2)));
}

inline void part4() {
    update(rl(0) + max(rl(1), rl(2)) + rl(3), max(rw(3), max(rw(0), rw(1) + rw(2))));
}

inline void part5() {
    update(max(rl(0), rl(1)) + rl(2) + rl(3), max(max(rw(0) + rw(1), rw(2)), rw(3)));
}

inline void part6() {
    //比较复杂，慢慢来
    int length;
    if (rw(2) >= rw(1) + rw(3))
        length = max(max(rl(0), rl(1) + rl(2)), rl(2) + rl(3));
    else if (rw(3) < rw(2))
        length = max(rl(0) + rl(1), max(rl(1), rl(3)) + rl(2));
    else if (rw(2) == rw(3))
        length = max(rl(0) + rl(1), rl(2) + rl(3));
    else if (rw(2) < rw(3) && rw(3) < rw(2) + rw(0))
        length = max(rl(0) + rl(1), max(rl(0), rl(2)) + rl(3));
    else if (rw(3) >= rw(0) + rw(2))
        length = max(rl(1), max(rl(0), rl(2)) + rl(3));
    update(length, max(rw(0) + rw(2), rw(1) + rw(3)));
}

inline void do_it() {
    part1();
    part2();
    part3();
    part4();
    part5();
    part6();
}

inline void work(int depth) {
    if (depth == 5) {
        do_it();
        return;
    }
    for (int i = 0; i < 4; i++) {
        swap(rec[order[i]].length, rec[order[i]].width);//旋转
        work(depth + 1);//下一种排列
        swap(rec[order[i]].length, rec[order[i]].width);//回溯
        work(depth + 1);//下一种排列
    }
}

inline void solve() {
    do
        work(1);
    while (next_permutation(order, order + 4));
    printf("%d\n", ans);
    sort(res.begin(), res.end());
    for (int i = 0; i < res.size(); i++)
        printf("%d %d\n", res[i].first, res[i].second);
}
```

---

## 作者：2021CHD (赞：1)

# 前言

**不用分类讨论。**

其实不知道为什么 [P1212](https://www.luogu.com.cn/problem/P1212) 和 [P5917](https://www.luogu.com.cn/problem/P5917) 两题现有的 $12+5=13$ 篇题解都是分六类（或五类）讨论做的。（可能和 P1212 题面上的那几幅图有关）

但是其实可以不用的，有一种**丝毫不用分类讨论**而且**可以拓展到任意数量矩形**的做法。

# 题意

给定 $n=4$ 个矩形，可以任意旋转平移，要求矩形之间不可以相互重叠，并且矩形的边必须与坐标轴平行，求面积最小的可以容纳给定矩形的矩形的面积和形状，矩形边长不超过 $V=50$。

# 思路

首先可以先想最优的矩形排列会长成什么样，给一张图：

![一种可能的最优解](https://cdn.luogu.com.cn/upload/image_hosting/di6yhwk5.png)

这个解看起来是最优的。（实际上也是）

那么这个解有什么特点呢？

**每个矩形都尽可能地向左下角靠拢。**

容易说明，如果一个矩形可以向左下方移动，那这个矩形移动以后这个解不会更劣，如果这个解已经是最优解，那这样做不会影响到这个解的形状，所以只需要统计每个矩形都尽可能地向左下角靠拢的情况就足以求出正确答案。

所以，可以考虑枚举**矩形放置的顺序**和每个矩形**是否旋转 $90^{\circ}$**，然后按顺序放置矩形，并保证所有矩形**不能向左下方移动**的方案都**被枚举到**。

具体地，如果矩形不能向左下方移动，那它的左边界一定紧贴某个矩形的右边界或者紧贴最左边，它的下边界一定紧贴某个矩形的上边界或者紧贴最下边。所以可以考虑枚举一个矩形的左边界在哪里，然后找到最靠下的一个下边界使得这个矩形的放置合法，然后尝试将这个矩形放在这个位置。

注意这样做只保证了矩形不能向下方移动，而没有保证矩形不能向左方移动，但是所有矩形不能向左下方移动的可能性都会被枚举到，所以这样做是可行的。

有一个小优化：第一个放置的矩形一定可以不旋转 $90^{\circ}$，因为只要把整个局面沿 $y=x$ 翻转就可以达到同样的效果，不过在这题的数据范围下是没有必要的。

然后就做完了，有什么细节问题可以看看代码，时间复杂度是 $O\left((n!)^22^nn^2+nV\right)$，空间复杂度是 $O(nV)$。

最后贴上 [AC 记录](https://www.luogu.com.cn/record/197427726)和代码。

```C++
#include<cstdio>
#include<cstdlib>
using namespace std;
const int n=4;
int x[10],y[10],i,j,pl[10],bj[10],rev[10],l[10],r[10],d[10],u[10],ans=100000000,wans[1000],tt[1000],top;
int min(int a,int b)
{
	if(a<b)
	return a;
	else
	return b;
}
int max(int a,int b)
{
	if(a>b)
	return a;
	else
	return b;
}
void dfs3(int w)
{
	int i,j,k,t1=0,t2=0;
	if(w>n)
	{
		for(i=1;i<=n;i++)
		if(r[i]>t1)
		t1=r[i];
		for(i=1;i<=n;i++)
		if(u[i]>t2)
		t2=u[i];
		if(t1>t2)
		{
			i=t1;
			t1=t2;
			t2=i;
		}
		if(t1*t2<ans)
		{
			ans=t1*t2;
			for(i=1;i<=top;i++)
			tt[wans[i]]=0;
			top=1;
			wans[1]=t1;
			tt[t1]=1;
		}
		else if(t1*t2==ans&&tt[t1]==0)
		{
			tt[t1]=1;
			top++;
			wans[top]=t1;
		}
		return;
	}
	for(i=0;i<w;i++)
	{
		l[w]=r[i];
		if(rev[w]==0)
		r[w]=l[w]+x[pl[w]];
		else
		r[w]=l[w]+y[pl[w]];
		t1=1000000;
		for(j=0;j<w;j++)
		if(u[j]<t1)
		{
			d[w]=u[j];
			if(rev[w]==0)
			u[w]=d[w]+y[pl[w]];
			else
			u[w]=d[w]+x[pl[w]];
			for(k=1;k<w;k++)
			if(max(d[k],d[w])<min(u[k],u[w])&&max(l[k],l[w])<min(r[k],r[w]))
			break;
			if(k>=w)
			t1=u[j];
		}
		d[w]=t1;
		if(rev[w]==0)
		u[w]=d[w]+y[pl[w]];
		else
		u[w]=d[w]+x[pl[w]];
		dfs3(w+1);
	}
}
void dfs2(int w)
{
	if(w>n)
	{
		dfs3(1);
		return;
	}
	rev[w]=1;
	dfs2(w+1);
	rev[w]=0;
	dfs2(w+1);
}
void dfs1(int w)
{
	int i;
	if(w>n)
	{
		dfs2(2);
		return;
	}
	for(i=1;i<=n;i++)
	if(bj[i]==0)
	{
		bj[i]=1;
		pl[w]=i;
		dfs1(w+1);
		bj[i]=0;
	}
}
main()
{
	for(i=1;i<=n;i++)
	scanf("%d%d",&x[i],&y[i]);
	dfs1(1);
	top=0;
	for(i=1;i<=n*50;i++)
	if(tt[i]>0)
	{
		top++;
		wans[top]=i;
	}
	printf("%d\n",ans);
	for(i=1;i<=top;i++)
	printf("%d %d\n",wans[i],ans/wans[i]);
}
```

# 后记

上面这个做法有**拓展性**，什么意思呢，就是不一定是 $4$ 个矩形，也可以是 $5$ 个甚至 $6$ 个矩形（时间限制需要开到 $3$ 秒），而更多矩形的情况也能在数组开到足够大、运行时间足够长的前提下得出答案，这只需要将代码开头的 `const int n=4;` 其中的 $4$ 改掉就可以实现，而不需要分更多情况讨论。

---

## 作者：Chiesl (赞：1)

~~本蒟蒻第一次写 IOI 的题，还是一遍过,有些些小激动 awa~~
# 解法&思路
这道题就是暴力搜索题，写一个 DFS 就可以完美解决了，主要是对于各种情况的处理，本蒟蒻将一一讲解。

其实本蒟蒻想不出来这些摆放的情况，但是[~~有一道一模一样的题目画了图awa~~](https://www.luogu.com.cn/problem/P1212)。

几种情况的图片：
![](https://cdn.luogu.com.cn/upload/pic/57.png)

接下来我们用 $a,b$ 来表示封闭矩阵的宽和长，$x1, x2, x3, x4$ 分别表示四个矩阵的宽，$y1, y2, y3, y4$ 分别表示四个矩阵的长。

不管这个矩阵怎么歪，我们只把对 $a$ 的值有贡献的边记作 $x_{i}$，对 $b$ 有贡献的记作 $y_{i}$。$(1 \le i \le 4)$。
### 第一种情况
四种并排放。
很容易可以看出：$a = x1 + x2 + x3 + x4$。

$b$ 的值就为他们中的最大值，所以 $b = \max(\max(y1, y2), \max(y3, y4))$。
### 第二种情况
三个并排，一个躺平。
也可以得出：$a = \max(x1 + x2 + x3, x4)$。

以及：$b = \max(y1,\max(y2,y3)) + y4 $。
### 第三种情况
显然：$a = \max(x1 + x2, x3) + x4$。

$b = \max(\max(y1, y2) + y3, y4)$。
### 第四种情况
看似更复杂，其实就是堆在一起的 2，3 号矩阵难以处理。但细想想也不难，堆在上面的那个的 $x$ 值一定小于等于下面那个，所以这两个矩阵对于 $a$ 的值的贡献为：$\max(x2, x3)$。

由此可得：$a = x1 + \max(x2, x3) + x4$。

$b = \max(y1, \max(y2 + y3, y4))$。
### 第五种情况
与第四种基本相同，区别在于第四种堆叠的矩阵位于中间，第五种位于旁边

显然：$a = \max(x1, x2) + x3 + x4$。

$b = \max(y1 + y2, \max(y3, y4))$。
### 第六种情况
最复杂的情况，看似复杂实则也很容易懂，要分情况讨论，想必各位神犇做数学题时没少遇到。

我们统一一下编号：右上角，左上角，右下角，左下角，按照这个顺序从 1 到 4 编号。
#### 情况一：$y4 + y2 \le y3$
各位不妨画个图，立刻就可以得出：$a = \max(\max(x1, x3 + x2), x3 + x4)$。
#### 情况二：在不满足情况一的条件下，$y4 < y3$
依然可以轻松得出：$a = \max(x1 + x2, \max(x2, x4) + x3)$。
#### 情况三：$y3 = y4$
这是所有情况中最直观的：$a = \max(x1 + x2, x3 + x4)$。
#### 情况四：$y3 < y4$，且不满足情况五
依然是画了图以后就可以轻松得出：$a = \max(x1 + x2, \max(x1, x3) + x4)$。
#### 情况五：$y1 + y3 \le y4$
动手画图后可以得出：$a = \max(x2, \max(x1, x3) + x4)$。

看到这可能有神犇会好奇，$b$ 咋求？

画图啊，画图一下子就出来了：$b = \max(y1 + y3, y2 + y4)$。
## 代码
具体应该怎么做呢？
先深搜枚举位置（也就是上文中编号），然后调用计算就行了。

非常的简单，就是很肝。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5][2], num[5]; //分别储存每个矩阵的长宽，顺序
int cnt, Min = INT_MAX;
bool vis[5], flag[402][402];
struct node {
	int p, q;
} ans[2050];//结构体排序完成子任务
void answer (int sx, int sy) {
	if (sx > sy) swap(sx, sy);//也是子任务	
	if (flag[sx][sy]) return;//防止重复
	flag[sx][sy] = true;
	if (sx * sy < Min) {
		Min = sx * sy;
		cnt = 1;
		ans[cnt].p = sx, ans[cnt].q = sy;
	} else if (sx * sy == Min) {
		ans[++cnt].p = sx;
		ans[cnt].q = sy;
	}
}
void f (int s1, int s2, int s3, int s4) {
	int x, y;
	x = a[s1][1] + a[s2][1] + a[s3][1] + a[s4][1], y = max(max(a[s1][0], a[s2][0]), max(a[s3][0], a[s4][0]));
	answer(x, y);
	x = max(a[s1][1] + a[s2][1] + a[s3][1], a[s4][1]), y = max(a[s1][0], max(a[s2][0], a[s3][0])) + a[s4][0];
	answer(x, y);
	x = max(a[s1][1] + a[s2][1], a[s3][1]) + a[s4][1], y = max(a[s4][0], max(a[s1][0], a[s2][0]) + a[s3][0]);
	answer(x, y);
	x = a[s1][1] + max(a[s2][1], a[s3][1]) + a[s4][1], y = max(a[s4][0], max(a[s1][0], a[s2][0] + a[s3][0]));
	answer(x, y);
	x = max(a[s1][1], a[s2][1]) + a[s3][1] + a[s4][1], y = max(max(a[s1][0] + a[s2][0], a[s3][0]), a[s4][0]);
	answer(x, y);
	if (a[s3][0] >= a[s2][0] + a[s4][0]) x = max(max(a[s1][1], a[s3][1] + a[s2][1]), a[s3][1] + a[s4][1]);
	else if (a[s4][0] < a[s3][0]) x = max(a[s1][1] + a[s2][1], max(a[s2][1], a[s4][1]) + a[s3][1]);
	else if (a[s3][0] == a[s4][0]) x = max(a[s1][1] + a[s2][1], a[s3][1] + a[s4][1]);
	else if (a[s3][0] < a[s4][0] && a[s4][0] < a[s3][0] + a[s1][0]) x = max(a[s1][1] + a[s2][1], max(a[s1][1], a[s3][1]) + a[s4][1]);
	else if (a[s4][0] >= a[s1][0] + a[s3][0]) x = max(a[s2][1], max(a[s1][1], a[s3][1]) + a[s4][1]);
	y = max(a[s1][0] + a[s3][0], a[s2][0] + a[s4][0]);
	answer(x, y);
}//上文有详细讲，这里不再赘述
void dfs (int k) {
	if (k == 5) {
		f(num[1], num[2], num[3], num[4]);
		return;
	}
	for (int i = 1; i <= 4; i++) {
		if (vis[i]) continue;
		vis[i] = true;
		num[k] = i;
		dfs(k + 1);
		swap(a[i][0], a[i][1]);//把矩阵转90°再搜
		dfs(k + 1);
		swap(a[i][0], a[i][1]);
		vis[i] = false;//回溯
	}
}
bool cmp (node a, node b) {return a.p < b.p;}
int main () {
	for (int i = 1; i <= 4; i++) scanf("%d%d", &a[i][0], &a[i][1]);
	dfs(1);
	sort(ans + 1, ans + 1 + cnt, cmp);
	printf("%d\n", Min);
	for (int i = 1; i <= cnt; i++) printf("%d %d\n", ans[i].p, ans[i].q);//完美的输出
	return 0;
}
```
这道题算是绿题中比较简单的了，而且还是一次水两道 awa。


---

## 作者：1010_ (赞：0)

![演示图](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)
这是这道题所有可能的情况，前五种情况可以看成矩形两两组合成一个大矩形然后将新生成的矩形在于其他矩形组合最后得到一个矩形，只有第六种是直接由四个矩形得到一个大矩形，所有可以分两种情况讨论。详见代码：
```C++
#include<bits/stdc++.h>
#define gc() getchar()
typedef long long ll;
using namespace std;
int read(){
	int x=0,f=1;char ch=gc();
	for(;ch<'0'||ch>'9';ch=gc())ch=='-'&&(f=-1);
	for(;ch>='0'&&ch<='9';ch=gc())x=(x<<1)+(x<<3)+ch-'0';
	return x*f;
}//快读 
int n,m,cnt,tot,minn=0x7fffffff;
bool bo[60];//答案去重
int zt[20];
int zz[30][20];
struct AC{int a,b;}e[20],ans[20];
void updata(int a,int b){
	if (a>b) swap(a,b);
	if (a*b<minn) minn=a*b,ans[cnt=1]=(AC){a,b},memset(bo,0,sizeof bo),bo[a]=1;
	else if (a*b==minn&&(!bo[a])) ans[++cnt]=(AC){a,b},bo[a]=1;
}//记录答案，答案考虑去重，避免sort爆炸（不太可能） 
void dfs(int s,int a,int b){
	if (s==(1<<n)-1){updata(a,b);return;}
	for (int i=0,p,q;i<n;++i)
		if (!((1<<i)&s)) {
			p=a+e[i].a;q=max(b,e[i].b);dfs(1<<i|s,p,q);			
			p=max(a,e[i].a);q=b+e[i].b;dfs(1<<i|s,p,q);			
			p=a+e[i].b;q=max(b,e[i].a);dfs(1<<i|s,p,q);			
			p=max(a,e[i].b);q=b+e[i].a;dfs(1<<i|s,p,q);
		}
}//处理前5种情况，前5种情况可以差分成矩形两两相加得到新矩形再用新矩形与剩下矩形相加得到最后的矩形 
void dfs2(int s,int q){
	if (q==n) {
		for (int i=0;i<n;++i) zz[tot][i]=zt[i];
		++tot;return;
	}
	for (int i=0;i<n;++i) 
		if (!((1<<i)&s)) zt[q]=i,dfs2(s|1<<i,q+1);
}//求全排列 
void get(int&a,int&b,int*z){
	a=max(e[z[0]].a+e[z[2]].a,max(e[z[0]].a+e[z[1]].a,e[z[2]].a+e[z[3]].a));
	b=max(e[z[1]].b+e[z[3]].b,max(e[z[1]].b+e[z[2]].b,e[z[3]].b+e[z[0]].b));
}//获得四个矩形拼出的大矩形的长和宽 
void swapab(int x){swap(e[x].a,e[x].b);}//将第x个矩形旋转90度 
void work(){
	for (int i=0,a,b;i<tot;++i){
		for (int j=0;j<=4;++j) {
			get(a,b,zz[i]);
			updata(a,b);
			if (j<4)swapab(zz[i][j]);
		}//考虑第六种情况是有0，1，2，3，4个矩形为颠倒的情况 
		for (int j=0;j<4;++j) swapab(zz[i][j]);//复原颠倒的矩形 
		swapab(zz[i][0]);swapab(zz[i][2]);
		get(a,b,zz[i]);
		updata(a,b);
		swapab(zz[i][0]);swapab(zz[i][2]);//2个矩形为颠倒时的特殊情况（不相邻时） 
	}
}//模拟第6种情况 
void init(){
	n=4;
	for (int i=0,a,b;i<n;++i) {
		a=read(),b=read();
		if (a>b) swap(a,b);
		e[i]=(AC){a,b};
	}
}
bool cmp(AC x,AC y){return x.a<y.a;}
void ouit(){
	printf("%d\n",minn);
	sort(ans+1,ans+cnt+1,cmp);
	for (int i=1;i<=cnt;++i) 
		printf("%d %d\n",ans[i].a,ans[i].b);
}
int main(){
	init();
	for (int i=0;i<n;++i)dfs(1<<i,e[i].a,e[i].b);
	dfs2(0,0);
	work();ouit();
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

这题和 P1212 完全一致，所以这篇文章和那题的一篇文章很相似。

思路：DFS 枚举四个矩形的顺序和方向，分别计算构成的大矩形面积。

实现：

`ch` 记录按顺序选择的四个矩形在横向和纵向上的长度，`ans` 记录最小面积的组成中大矩形的宽的可能的取值，输出答案时只需输出这些值和最小面积与它们的比。

```cpp
const ll n=4,inf=1e9,S=2e3;
pll a[n+10],ch[n+10];
ll min1=inf;
bool ans[S],used[n+10];
```

`upd` 函数用于对于已知的大矩形面积更新答案。

```cpp
void upd(ll x,ll y) {
	if(x*y==min1) ans[min(x,y)]=1;
	elif(x*y<min1) {
		min1=x*y;
		memset(ans,0,sizeof(ans));
		ans[min(x,y)]=1;
	}
}
```

`check()` 函数用于对于当前的摆放顺序计算大矩形长宽。本来这个部分挺复杂的，但 P1212 已经把所有需要考虑的情况都告诉你了。

第 $1$ 种情况：

```cpp
x=max(max(ch[1].fi,ch[2].fi),max(ch[3].fi,ch[4].fi));
	y=ch[1].se+ch[2].se+ch[3].se+ch[4].se;
```

第 $2$ 种情况：

```cpp
x=max(max(ch[1].fi,ch[2].fi),ch[3].fi)+ch[4].fi;
	y=max(ch[1].se+ch[2].se+ch[3].se,ch[4].se);
```

第 $3$ 种情况：

```cpp
x=max(max(ch[1].fi,ch[2].fi)+ch[3].fi,ch[4].fi);
	y=max(ch[1].se+ch[2].se,ch[3].se)+ch[4].se;
```

第 $4$ 种情况和第 $5$ 种情况：

```cpp
x=max(max(ch[1].fi,ch[2].fi+ch[3].fi),ch[4].fi);
	y=ch[1].se+max(ch[2].se,ch[3].se)+ch[4].se;
```

第 $6$ 种情况：

比较复杂，需要再分 $4$ 种子情况。可以想象把两堆矩形放在地上，其中一堆逐渐升高。

```cpp
y=max(ch[1].fi+ch[3].fi,ch[2].fi+ch[4].fi);
	
	if(ch[1].fi+ch[3].fi<=ch[4].fi)	x=max(ch[2].se,max(ch[1].se,ch[3].se)+ch[4].se);
	else if(ch[3].fi<=ch[4].fi&&ch[1].fi+ch[3].fi>=ch[4].fi) 
		x=max(ch[1].se+ch[2].se,max(ch[1].se,ch[3].se)+ch[4].se);
	else if(ch[3].fi>=ch[4].fi&&ch[3].fi<=ch[2].fi+ch[4].fi) 
		x=max(ch[1].se+ch[2].se,max(ch[2].se,ch[4].se)+ch[3].se);
	else if(ch[3].fi>=ch[2].fi+ch[4].fi) x=max(ch[1].se,max(ch[2].se,ch[4].se)+ch[3].se);
```

DFS 以及主函数：

```cpp
void dfs(ll no) {
	if(no==5) check();
	else {
		rep(i,1,4) {
			if(used[i]==0) {
				used[i]=1;
				ch[no]=a[i];
				dfs(no+1);
				ch[no]= {a[i].se,a[i].fi};
				dfs(no+1);
				used[i]=0;
			}
		}
	}
}

int main() {
	rep(i,1,4) cin>>a[i].fi>>a[i].se;

	dfs(1);
	cout<<min1<<'\n';

	rep(i,1,S-1) {
		if(min1/i<i) return 0;

		if(ans[i]) cout<<i<<' '<<min1/i<<'\n';
	}
}
```

---

## 作者：luuia (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P5917)

## 题意

有 $4$ 个长方形，$6$ 种不同的摆法，求所有的摆法中，能够覆盖 $4$ 个长方形的矩形的最小面积及对应的长宽，按照长宽中的较小值升序排列输出。

## 分析

下面对于每一种情况，给出对应的图和分析：

我们记 $i$ 号矩形的长为 $x_i$，宽为 $y_i$ ($1 \leq i \leq 4$)，最大矩形的长为 $x$，宽为 $y$，不论大小，横向为长，纵向为宽。

- ### 第一种情况

![图1](https://cdn.luogu.com.cn/upload/image_hosting/6phns4jd.png)

可以见得，因为 $4$ 个矩形是并列放置，总长 $x = x_1 + x_2 + x_3 + x_4$，总宽 $y = \max(y_1,\max(\max(y_2,y_3),y_4))$。

- ### 第二种情况

![图2](https://cdn.luogu.com.cn/upload/image_hosting/mnrcfakt.png)

我们将这个图形分为上下两部分看，上半部分的长为 $3$ 个之和，宽为 $3$ 个中的最大值，下半部分长为 $x_4$，宽为 $y_4$，总长为 $x = \max(x_1+x_2+x_3,x_4)$，总宽为 $y = \max(y_1,\max(y_2,y_3)) + y_4$。

- ### 第三种情况

![图3](https://cdn.luogu.com.cn/upload/image_hosting/3h9gu0md.png)

我们将这个图形分为左右两部分看，左半部分的长为 $\max(x_1+x_2,x_3)$，宽为 $\max(x_1,x_2)+x_3$，右半部分长为 $x_4$，宽为 $y_4$，总长为 $x = \max(x_1+x_2,x_3)+x_4$，总宽为 $y = \max(\max(x_1,x_2)+x_3,x_4)$。

- ### 第四种情况

![图4](https://cdn.luogu.com.cn/upload/image_hosting/y1fa5wr8.png)

我们将这个图形分为左、中、右三部分来看。

左半部分：长为 $x_1$，宽为 $y_1$；

中间部分：长为 $\max(x_2,x_3)$，宽为 $y_2+y_3$；

右半部分：长为 $x_4$，宽为 $y_4$。

总长为三部分之和，总宽为三部分的最大值。

总长 $x = x_1+\max(x_2,x_3)+x_4$，总宽 $y = \max(\max(y_1,y_2+y_3),y_4)$。

- ### 第五种情况

![图5](https://cdn.luogu.com.cn/upload/image_hosting/7s29mywe.png)

同样的，我们将这个图形分为左、中、右三部分来看。

左半部分：长为 $\max(x_1,x_2)$，宽为 $y_1+y_2$；

中间部分：长为 $x_3$，宽为 $y_3$；

右半部分：长为 $x_4$，宽为 $y_4$。

总长为三部分之和，总宽为三部分的最大值。

总长 $x = \max(x_1,x_2)+x_3+x_4$，总宽 $y = \max(\max(y_1+y_2,y_3),y_4)$。

- ### 第六种情况

这是最复杂的一种，这里主要分以下几种情况讨论，每种情况皆在不满足以上所有情况的前提下实现。

![图6](https://cdn.luogu.com.cn/upload/image_hosting/z27dfxzn.png)

- $y_1 + y_3 \leq y_4$

![图7](https://cdn.luogu.com.cn/upload/image_hosting/ivwyffaw.png)

总长 $x = \max(\max(x_1,x_3)+x_4,x_2)$

- $y_3 \leq y_4 $ 且 $y_4 < y_1 + y_3$

![图8](https://cdn.luogu.com.cn/upload/image_hosting/45t233t6.png)

总长 $x = \max(\max(x_1,x_3)+x_4,x_2)$

- $y_4 \leq y_3$ 且 $y_3 \leq y_2+y_4$

![图9](https://cdn.luogu.com.cn/upload/image_hosting/ewctt9jz.png)

总长 $x = \max(x_1+x_2,\max(x_2,x_4)+x_3)$

- $y_2+y_4 \leq y_3$

![图10](https://cdn.luogu.com.cn/upload/image_hosting/vjhn6alp.png)

总长 $x = \max(\max(x_2,x_4)+x_3,x_1)$

以上，我们就完成了每种情况的分析。

## 代码

我们考虑用一个数组 $\text{s}$ 表示答案，一个计数器 $\text{cnt}$ 表示答案的个数，一个变量 $\text{ans}$ 表示最小的面积，对于每一种可能的排列情况进行计算，如果结果小于最小面积，那么将数组清零，答案更新并存入此时的长和宽，最终升序排列输出即可。

看到很多大佬都用了 dfs，那么因为这个题只有四个矩形，可以直接暴力循环解决。

[AC 代码](https://www.luogu.com.cn/paste/64aails4)

[我的 AC 记录](https://www.luogu.com.cn/record/139450446)

---


# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# 题解

## 作者：皎月半洒花 (赞：1711)

$upd:$锅已补

## 一、何谓模式串匹配

模式串匹配，就是给定一个需要处理的文本串（理论上应该很长）和一个需要在文本串中搜索的模式串（理论上长度应该远小于文本串），查询在该文本串中，给出的模式串的出现有无、次数、位置等。

模式串匹配的意义在于，如果我是一个平台的管理员，我可以针对一篇文章或者一句话，搜索其中某个特定脏字或者不雅词汇的出现次数、位置——次数可以帮助我决定采取何种等级对于该用户的惩罚方式，而位置则可以帮助我给每一个脏词打上“*”的标记来自动屏蔽这些脏词。

## 二、浅析 $KMP$ 之思想

哦呵呵这个算法的名字比较诡异是因为有三位伟大的科学家共同设计完成……分别是$\mathcal{Knuth(D.E.Knuth) \& Morris(J.H.Morris)\& Pratt(V.R.Pratt)}$

~~然而我并不知道他们是谁~~

首先要理解，朴素的单模式串匹配大概就是枚举每一个文本串元素，然后从这一位开始不断向后比较，每次比较失败之后都要从头开始重新比对，大概期望时间复杂度在 $\Theta(n+m)$ 左右，对于一般的弱数据还是阔以跑的了滴。但是其实是可以被卡成$O(nm)$的。$emmmm$并且还是比较容易卡的。

而 $KMP$ 的精髓在于，对于每次失配之后，我都不会从头重新开始枚举，而是根据我已经得知的数据，从某个特定的位置开始匹配；而对于模式串的每一位，都有**唯一**的“特定变化位置”，这个在失配之后的特定变化位置可以帮助我们利用已有的数据不用从头匹配，从而节约时间。

比如我们考虑一组样例：

```cpp
模式串：abcab
文本串：abcacababcab
```

首先，前四位按位匹配成功，遇到第五位不同，而这时，我们选择将$abcab$向右移三位，或者可以直接理解为移动到模式串中与失配字符相同的那一位。可以简单地理解为，我们将两个已经遍历过的模式串字符重合，导致我们可以不用一位一位地移动，而是根据相同的字符来实现快速移动。

```cpp
模式串：   abcab
文本串：abcacababcab
```

但有时不光只会有单个字符重复：

```cpp
模式串：abcabc
文本串：abcabdababcabc
```

当我们发现在第六位失配时，我们可以将模式串的第一二位移动到第四五位，因为它们相同 $qwq$ .

```cpp
模式串：   abcabc
文本串：abcabdababcabc
```

那么现在已经很明了了， $KMP$ 的重头戏就在于用失配数组来确定当某一位失配时，我们可以将前一位跳跃到之前匹配过的某一位。而此处有几个先决条件需要理解：

1、**我们的失配数组应当建立在模式串意义下，而不是文本串意义下**。因为显然模式串要更加灵活，在失配后换位时，更灵活简便地处理。

2、如何确定位置呢？

首先我们要明白，基于先决条件$1$而言，我们在预处理时应当考虑当**模式串**的第 $i$ 位失配时，应当跳转到哪里.因为在文本串中，之前匹配过的所有字符已经没有用了——都是匹配完成或者已经失配的，所以我们的 $kmp$ 数组（即是用于确定失配后变化位置的数组，下同）应当记录的是：

**在模式串 $str1$ 中，对于每一位 $str1(i)$ ,它的 $kmp$ 数组应当是记录一个位置 $j$, $j \leq i$ 并且满足 $str1(i)=str1(j)$ 并且在 $j!=1$ 时理应满足 $str1(1)$至$str1(j-1)$ 分别与 $str(i-j+1)$~$str1(i-1)$ 按位相等**

上述即为移位法则

3、从前缀后缀来解释 $KMP$ :

首先解释前后缀(因为太简单就不解释了 $qwq$ )： 

```cpp
给定串：ABCABA
前缀：A,AB,ABC,ABCA,ABCAB,ABCABA
后缀：A,BA,ABA,CABA,BCABA,ABCABA
```

其实刚才的移位法则就是对于模式串的每个前缀而言，用 $kmp$ 数组记录到它为止的**模式串前缀的真前缀和真后缀最大相同的位置**（注意，这个地方没有写错，是真的有嵌套 $qwq$ ）。然而这个地方我们要考虑“**模式串前缀**的前缀和后缀最大相同的位置”原因在于，我们需要用到 $kmp$ 数组换位时，当且仅当未完全匹配。所以我们的操作只是针对模式串的前缀$--$毕竟是失配函数，失配之后只有可能是某个部分前缀需要“快速移动”。所以这就可以解释 $KMP$ 中前后缀应用的一个特点：

 $KMP$ 中前后缀不包括模式串本身,即**只考虑真前缀和真后缀**,因为模式串本身需要整体考虑，当且仅当匹配完整个串之后；而匹配完整个串不就完成匹配了吗 $qwq$ 

### 三、代码实现

1、$kmp[i]$ 用于记录当匹配到模式串的第 $i$ 位之后失配,该跳转到模式串的哪个位置，那么对于模式串的第一位和第二位而言，只能回跳到 $1$，因为是 $KMP$ 是要将真前缀跳跃到与它相同的真后缀上去（通常也可以反着理解），所以当 $i=0$ 或者 $i=1$ 时,相同的真前缀只会是 $str1(0)$ 这一个字符，所以 $kmp[0]=kmp[1]=1$。

2、对于如何和文本串比对，很简单：
```cpp
    int j;
    j=0;//j可以看做表示当前已经匹配完的模式串的最后一位的位置 
    //如果楼上看不懂，你也可以理解为j表示模式串匹配到第几位了 
    for(int i=1;i<=la;i++)
	   {
          while(j&&b[j+1]!=a[i])j=kmp[j];
		  //如果失配 ，那么就不断向回跳，直到可以继续匹配 
          if (b[j+1]==a[i]) j++;
          //如果匹配成功，那么对应的模式串位置++ 
          if (j==lb) 
		  {
		  cout<<i-lb+1<<endl;
		  j=kmp[j];
		  //继续匹配 
		  }
       }

```

3、那么我们该如何处理 $kmp$ 数组呢？我们可以考虑用模式串自己匹配自己

```cpp
    j=0;
    for (int i=2;i<=lb;i++)
	   {     
	   while(j&&b[i]!=b[j+1])
       //此处判断j是否为0的原因在于，如果回跳到第一个字符就不 用再回跳了
       j=kmp[j];    
        //通过自己匹配自己来得出每一个点的kmp值 
       if(b[j+1]==b[i])j++;    
       kmp[i]=j;
        //i+1失配后应该如何跳 
       }
```
那么这个“自己匹配自己”该如何理解呢？我们可以这么想：
首先，在单次循环只有一个 $if$ 来判断的原因在于每次至多向后多求一位的$next$；

并且 $j$ 是拥有可继承性的，由于 $j$ 是用于比对前缀后缀的，那么对于一组前后缀而言，第 $i-1$ 和第 $j-1$ 位之前均相同或者有不同，决定着 $i$ 和 $j$ 匹配的结果是从 $0$ 开始还是基于上一个 $j$ 继续$++$

贴标程：

```cpp
#include<iostream>
#include<cstring>
#define MAXN 1000010
using namespace std;
int kmp[MAXN];
int la,lb,j; 
char a[MAXN],b[MAXN];
int main()
{
    cin>>a+1;
    cin>>b+1;
    la=strlen(a+1);
    lb=strlen(b+1);
    for (int i=2;i<=lb;i++)
	   {     
	   while(j&&b[i]!=b[j+1])
        j=kmp[j];    
       if(b[j+1]==b[i])j++;    
        kmp[i]=j;
       }
    j=0;
    for(int i=1;i<=la;i++)
	   {
          while(j>0&&b[j+1]!=a[i])
           j=kmp[j];
          if (b[j+1]==a[i]) 
           j++;
          if (j==lb) {cout<<i-lb+1<<endl;j=kmp[j];}
       }

    for (int i=1;i<=lb;i++)
    cout<<kmp[i]<<" ";
    return 0;
}
```
那么时间复杂度为 $\Theta(m+n)$ ,比朴素算法有了极大的优化。

______

$Extra \ \ Knowledge$浅析复杂度证明

题外话：本来想扯摊还分析来着，但是$rqy$说的好像比较直接易懂，于是在这里就引用了$rqy$的话：

>每次位置指针$i++$时，失配指针$j$至多增加一次，所以$j$至多增加$len$次，从而至多减少$len$次，所以就是$\Theta(len_N + len_M) = \Theta(N + M)$的

总之很迷就对了（逃
____

其实我们也可以发现， $KMP$ 算法之所以快，不仅仅由于它的失配处理方案，更重要的是利用前缀后缀的特性，从不会反反复复地找，我们可以看到代码里对于匹配只有一重循环，也就是说 $KMP$ 算法具有一种“最优历史处理”的性质，而这种性质也是基于 $KMP$ 的核心思想的。


---

## 作者：frostime (赞：63)


超长警告，下篇文章原本是我以前发过的[博客](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/#more)，我顺手就给挪到这了。

前面主要是 KMP 的解释，题解在最后面。


Part 1. 解释 KMP 算法
------------

关于字符串的模式匹配问题，有许多算法，这里先介绍最简单著名的两个。

# 1.  暴力求解

一个简单粗暴的方法就是，从主串的第一个字符和模式串的第一个字符开始，一个一个字符匹配。一旦失配，就**从该次匹配开始时匹配的主串字符的下一个字符开始重新匹配**。

```cpp
int BruteForce(const string &src, const string &pattern)
{
    int srcPtr = 0, patPtr = 0;
    while (srcPtr < src.length() && patPtr < pattern.length())
    {
        //如果当前字符匹配，就指针后移
        if (src[srcPtr] == pattern[patPtr])
        {
            ++srcPtr;
            ++patPtr;
        }
        else
        {
            //srcPtr 回退到上一次的起始位的下一位, patternPtr重新归零
            srcPtr = srcPtr - patPtr + 1;
            patPtr = 0;
        }
    }
    //如果为 true，说明匹配成功，否则为失败
    //如果成功 srcPtr - pattern.length() 就是模式子串开始的位置
    return (patPtr == pattern.length())? srcPtr - patPtr : -1;
}
```

时间复杂度分析：

令主串长n，模式串长m。则：
- 最好：开头位置就匹配成功了，所以为 $O(m)$
- 最坏：根本匹配不成功，结果为 $O(m\times n)$

# 2. KMP算法

## 2.1 对蛮力算法的反思

以上的蛮力算法的低效的原因在于**对主串中每个字符都进行了大量的重复性比较**。最糟糕的情况下，主串中的任意一个字符可能会和模式串中的每一个字符都比较一次。就好比运用递归计算斐波那契数列一样，过多的重复计算比对大大拖慢了算法。
不妨来考察一下最坏的情况:

```
000000...001
0001
```

如果要匹配以上两个字符串的话，就会陷入到最坏的情况。但是为什么会这样呢？进过分析，我们可以看出，主要是**因为在模式串中存在大量与主串匹配的前缀**，所以大量地出现“在最后一个字符的位置失配导致不得不从头再来”的情况。

## 2.2 新算法的提出

事实上，大量重复的比较是可以避免的。首先我们要注意到一个问题：**在任何一个时刻，当前正在比对的模式串字符之前的前缀串和对应的主串中的子串是完全相等的**。所以我们要想法设法将这些信息“存储”起来，为后面的比对所用。

那么储存起来又该干什么用呢？

不妨这样来考虑，之前我们在蛮力求解的算法中，每次失配，都要重新移动主串指针和模式串的指针并进行重新比对。可是，我们不妨换条思路：**既然之前比对过的主串的信息已经知道了，不妨将主串的指针定住不动，只移动模式串的指针**。 

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/1.png)

以上图为例，我们让主串的比对字符仍为空格符，向右滑动模式串，使得模式串中的另外一个继任字符继续和空格符比对，在这里这个继任字符是 'C'。

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/2.png)

------

那么，如何找到这个字符呢？换而言之，如何确定模式串要向右滑动几个单位呢？注意到一点：**在这个继任字符之前的前缀子串必须和主串对应位置相配**。

譬如在这里我们就发现，**在移动前主串的部分匹配子串的后缀 `AB` 正好和模式串的前缀 `AB` 匹配，所以我们向右滑动模式串直到两组 `AB` 对齐**。

如何知道该滑动几位？这里就要借助到我们之前所说的储存起来了的主串的部分匹配的部分了。不过要注意到，**那部分匹配的区域是和模式串的部分匹配前缀相同的，所以与其说是存储了主串的信息，倒不如说是储存模式串信息并间接地分析出主串的信息**。

方法在于，我们要事先构造出一个 `next` 数组，**它记录了模式串的每个字符的某种信息**。每当适配的时候，通过执行 `patPtr = next[patPtr]` 来得到下一次应该匹配的继任字符，从而实现了模式串的右滑。



现在来讨论一下这个 `next` 数组有什么要求。根据我们之前的分析我们可以得出一个结论，`next[patPtr]` 必然满足这样以下条件：

> `next[patPtr]`所指向的字符之前的前缀子串必然与 `patPtr` 之前的子串的某个后缀是匹配的，这样他就能满足我们之前说的“继任字符之前的前缀子串必须和主串对应位置相配”的要求。

通俗地讲就是:2

1. 令 `pattern[0:patPtr]` 为 s1
2. 令 `pattern[0:next[patPtr]]` 为 s2
3. s1 的某个后缀子串 == s2


又因为 `pattern` 串的任何一个前缀子串必然从第一个字符开始，所以 `next[patPtr]` 所指向的字符的索引值一定等于该字符之前的前缀子串的长度。

也就是说，如果字符串的索引是从 0 开始的话，那么 `next[patPtr]` 值是代表着**字符 `pattern[patPtr]` 之前的子串**的**真前缀**与**真后缀**相同的最大长度（真前缀表示长度至少为 1 的前缀，因为空串也算前缀）。

不过还有一个小问题，如果在第一个字符就失配了怎么办？为此，**我们不妨令 `next[0]` 为 -1，也就是假设存在一个虚拟的哨兵头结点**，我们假设**这个哨兵结点是一个通配符**，这样就保持了逻辑的一致性。



![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/next%E6%95%B0%E7%BB%84%E7%9A%84%E7%94%A8%E6%B3%95.jpg)

## 2.3 KMP的初步框架
至此，我们已经可以构建出KMP算法的大体框架了:
```cpp
int KMPMatch(const string &src, const string &pattern)
{
    const int srcLen = src.length(), patLen = pattern.length();
    int srcPtr = 0, patPtr = 0;
    int next[patLen];
    ConstructNext(pattern, next);
    while (srcPtr < srcLen && patPtr < patLen)
    {
        //后面一个部分好理解，前面的 -1 主要是我们会把 next[0] 设置为 -1
        //这样即使在第一个字符就失配了，patPtr 也可以变成 0 然后继续和下一个字符进行比较
        if (patPtr == -1 || src[srcPtr] == pattern[patPtr])
        {
            ++srcPtr;
            ++patPtr;
        }
        else
            patPtr = next[patPtr];
    }
    return (patPtr == patLen)? srcPtr - patPtr : -1;
}
```
可以看出，算法在一个循环当中进行，每次有两种分支情况:
- 匹配
    - 正常的字符匹配  
    比较下一位字符
    - **虚拟的通配符匹配**  
    逻辑上是比较哨兵字符的下一位，实质上就是从新开始比较
- 不匹配  
将模式串右滑，一直滑到继任字符

**注意不要用 `size_t`，因为这里i是可以等于-1的**。

下面我们来考虑如何构造 `next` 数组。

## 2.4 构造 `next`

我们大可不必真的去对每个子串求最大匹配的真前缀和真后缀的长度，实际上，我们可以通过递推的方式来进行求取。

首先我们有如下结论：

$$
next[i] \leqslant i
$$

这当然是利索当然的了，`next[i]` 是在找前缀，所以肯定至少不会比 `i` 还大。

另外：

$$
next[j+1] \leqslant next[j] + 1
$$

对于 `j + 1`而言，最好的情况不过是 `pattern[j] == pattern[next[j]]`，也只有在这种情况下才能取等号。



现在我们开始讨论已知 $next[i]$ 如何求 $next[i+1]$

假设当前 `next[i]` 的值为 `t`，这就说明：

$$
p_{0}p_{1}\cdots p_{t-1} = p_{i-t}p_{i-t+1}\cdots p_{i-1}
$$

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E8%8C%83%E4%BE%8B.jpg)



现在分两种情况讨论：

### 2.3.1 Case 1:如果`p[i] == p[t]`

显然这就意味着:

$$
p_{0}p_{1}\cdots p_{t-1}p_{k} = p_{i-t}p_{i-t+1}\cdots p_{i-1}p_{i}
$$

稍加思考就可以看出，这种情况下`next[i+1] = t+1`

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E8%8C%83%E4%BE%8B2.jpg)

比如对于:

> a b b c a b a c  
> -1 0 0 0 0 1 2 1

第二个a的next为0，且`p[0]`也为a，所以第三个b的next一定为1

### 2.3.2 Case 2: 如果`p[i] != p[t]`

这种情况就较为复杂了，我们需要先仔细考虑一下我们需要干什么。正如前面分析过的，当我们求 `next[i+1]` 时我们希望找到一个继任字符 (令为k)，使这个字符前的长度为 k 的前缀子串和紧挨着 p[i+1] 前面的长度为 k 的后缀子串匹配。

不妨分两步考虑，令 `k` 前面那个字符为`tx`。则**必然有 `p[0, tx) == p[i-tx, i) `且 `p[tx] == p[i]`**。



- `p[0, tx) == p[i-tx, i)`

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E6%9E%84%E5%BB%BA.png)

我们仔细考虑一下就会发现，这和我们在KMP主算法中遇到的问题不正是样的吗？所以我们不妨**把求 `next` 数组的问题看作是另一个模式匹配的问题**，只不过在这里整个模式串既是主串又是模式串。更准确的而言，我们要**把当前需要匹配的 `p[i]` 附近当作是主串，`p[tx]` 附近当作是模式串**。

我们想找到 `i + 1` 对应的 `tx`，就类似地等价与 KMP 中 `p[i]` 在和 `p[tx]` 比较时失配的情况。很简单，只需要右移模式串，直到两个前缀相等时即可。符合要求的位置有哪些呢？显然，`next[i]`是符合这个要求的，**但同时需要注意，`next[next[i]]`也是符合这个要求的，以此类推`next[next[...next[i]]]`也都符合要求。唯一不同的是，随着层次的推移，相同前缀子串的长度也不断减少**。

总结以上的内容，我们可以得出一下结论:

令 `t = next[i]`，**通过不断的迭代 `t= next[t]` N次(N=0, 1, 2...)，我们可以得到 N+1 个位置 `t`，它们能都满足 `p[0, tx) == p[i-tx, i)`**。换而言之**如果存在一个 `tx` 满足 `p[0, tx] == p[i-tx, i]` 那么这个`tx` 必然在这N+1个 `t` 中产生**。



- `p[tx] == p[i]`

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/%E6%9E%84%E5%BB%BA2.png)

既然已经知道了`tx`的取样范围，那么剩下的就好办了。既然`i`是固定不变的，那我们可以使用一个额外的变量`lastNext`(原谅我的取名水平)，它记录的是上一个`next[]`的值。

通过**不断向前迭代**(`lastNext = next[lastNext]`)，**依次取得之前所说的 `tx` 值**并每次和`p[i]`进行比较。

1.  如果存在`p[lastNext] == p[i]`，那就恰好满足了我们的要求：

2. 如果不存在这样的字符，那么**我们同样依靠虚拟的通配符哨兵位，假设存在这样一个能与任何字符匹配的结点。**

在找到了我们的目标位置 `tx` 之后显然这就转化为了`p[i] = p[t]`的情况，因此我们就可以将next[i+1]填入 `k = tx + 1` 的值了。

## 2.4 `next`实现
```cpp
void ConstructNext(const string &pattern, int next[])
{
    const int len = pattern.length();
    //虚拟的通配符
    next[0] = -1;
    //这里的 ptr 就相当于分析中的 i, lastNext 就是 next[ptr]
    int ptr = 0, lastNext = -1;
    //在循环体中，当前为 ptr 意味着我们的任务是填充 next[ptr + 1] 的值
    //所以 ptr 要小于 len - 1，这样在 ptr = ptr - 2 时，我们就可以填充 next[len - 1] 了
    while (ptr < len - 1)
    {
        //Case 1: p[i] = p[t]，则 next[i + 1] = next[i] + 1
        if (lastNext == -1 || pattern[ptr] == pattern[lastNext])
            next[++ptr] = ++lastNext;
        else
            lastNext = next[lastNext];

    }
}
```

程序分析：

- 循环次数

可以看到我们在一开始先将 `next[0]` 填充，**因此后续程序的循环次数应该为`length - 1`次而非`length`次**。

- `ptr`

每一轮循环，`ptr` 都指向 `next` 数组已经填好了的部分的最后一位。换而言之**如果某次循环 `ptr` 的值为 `x`，那么本次循环的目的是求得 `next[x+1]`**。程序一直进行到 `ptr == p.length() - 2`，也就是指向倒数第二位，在这一组(注意并不是每次循环就填好一个数组位置，有些循环是用来计算 `lastNext` 的)循环中，我们将`next`的最后一位填好，退出程序。

- `lastNext`

相对的，`lastNext`指向的是“上一次”`next[]`数组的值。

- 条件分支
    - 若匹配  
    **匹配的情况有两种：一种是真匹配，一种是通配符匹配**。  
    巧妙的是，无论是哪种情况我们都可以用同一种语句来处理。
        - 对于前者，`next[++ptr] = ++lastNext;` 代表了 `next[ptr+1] = next[ptr] + 1`。注意原本 `lastNext` 代表的是 `next[ptr]` 的值，在执行后，它代表 `next[ptr+1]` 的值。
        - 对与后者，由于此时 `lastNext` 必定为 `-1`，所以执行操作后恰好为 `next[ptr+1] = 0`，即重新开始比对。
    - 若不匹配  
    此时就开始了我们之前分析过的跳转流程:`lastNext`在每进行一次循环后都向上一次的"`lastlastNext`" 跳转。  
    只沿着`next`跳转保证了前缀除了最后一个字符的部分必然匹配；  
    每次循环都做一次`pattern[ptr] == pattern[lastNext]`的判断是为了找出使前缀最后一个字符也匹配的位置。  
    等到找到了这个位置后(不管是真匹配还是通配符匹配)，**就跳入了`if`语句块，从而填写好`next[ptr+1]`的值。

## 2.5 再优化

事实上以上的KMP算法版本还是有缺陷的。不妨来考虑这个例子:

![](https://frostime.github.io/2019/06/18/%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B9%8BBF%E4%B8%8EKMP/x.png)

之前的KMP算法会怎么处理这种情况？显然它会先把 `j` 移到2，发现不匹配；再把 `j` 移到1，又不匹配···最后一只移到了-1，才结束对本次主串中的字符`1`的匹配。

但是我们仔细分析就会发现这是没有必要的！原因在于 `p[j] == p[next[j]] == p[next[next[j]]]...`，所以如果 `p[j]` 不和 `src[i]匹配`，那么`p[next[j]]`也必定不和`src[i]`匹配，模式串注定要继续后移。

通过以上的分析，我们就可以发现，要想优化算法，就需要**优化`next`表的构成**。

```cpp
void ConstructNext(const string &pattern, int next[])
{
    const int len = pattern.length();
    //虚拟的通配符
    next[0] = -1;
    //这里的 ptr 就相当于分析中的 i, lastNext 就是 next[ptr]
    int ptr = 0, lastNext = -1;
    //在循环体中，当前为 ptr 意味着我们的任务是填充 next[ptr + 1] 的值
    //所以 ptr 要小于 len - 1，这样在 ptr = ptr - 2 时，我们就可以填充 next[len - 1] 了
    while (ptr < len - 1)
    {
        //Case 1: p[i] = p[t]，则 next[i + 1] = next[i] + 1
        if (lastNext == -1 || pattern[ptr] == pattern[lastNext])
        {
            ++ptr;
            ++lastNext;
            //强制要求 pattern[i] != pattern[next[i]]
            next[ptr] = (pattern[ptr] == pattern[lastNext])? next[lastNext] : lastNext;
        }
        else
            lastNext = next[lastNext];

    }
}
```

注意在这里我们不再简单地`next[++ptr] = ++lastNext`。而是增加了判断`pattern[lastNext] == patern[ptr]`：不相等一切好说；**如果相等，就把它移到不相等的位置**。

等等，相等时为什么是`next[ptr] = next[lastNext]`？为什么这样的赋值可以保证`p[i] != p[next[pi]]`？这是因为 **`next` 表是从左到右建立的，所以如果其中一个位置 `k` 是已经建立好了的，那么必然满足`p[k] != p[next[k]]`**。考虑到`lastNext`必然在 `i` 的左侧，所以 `p[lastNext]` 必然满足以上性质。因此若 `p[i] == p[lastNext]`，则 `p[i]` 必然不等于 `p[next[lastNext]]`。(可以联想到我们在插入排序中，左侧的区间段必定是有序的这样一个考虑)


## 2.6 附：手工求`next`数组

1. 步骤一：求`pattern`的部分匹配表

比如对于这个模式串  
> a b b c a b a c

假设部分匹配表为 `pm`，那么 `pm[i]` 表示**以 `pattern[i]` 为结尾的子串和以 `pattern[0]` 为开头的子串相匹配的最大位数**，比如上述子串对应的部分匹配表如下

> a b b c a b a c  
> 0 0 0 0 1 2 1 0

2. 步骤二：将部分匹配表整体右移，首位用-1代替

> a b b c a b a c  
> -1 0 0 0 0 1 2 1

当然这是指索引从0开始的情况，如果索引从k开始，那最后结果整体加上k。


# 3. 小注意

并不是说有了KMP等高效算法就无需管BF算法了。

举个例子，事实上`Java`中`indexOf`方法就是用BF实现的。

JDK的编写者们认为**大多数情况下，字符串都不长，使用原始实现可能代价更低**。因为KMP和Boyer-Moore算法都需要预先计算处理来获得辅助数组，需要一定的时间和空间，**这可能在短字符串查找中相比较原始实现耗费更大的代价**。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。

所以也不是越快越好。


------
# 具体这道题

这道题和原始的 KMP 的不同点在于我们要求可以连续匹配。所以关键点在于**当某次匹配成功后下一步应该怎么做**。

我们仿照之前的思路，**假设在 `pattern` 末尾也有一个虚拟的哨兵字符，这个字符不论碰到什么其他字符都不匹配**。 这样只要把匹配成功后当作一次新的失配，就可以和以前的代码逻辑联通了。

为此，我们把 `next[]` 数组多加一位就可以了，代码如下:

```cpp
#include <iostream>
#include <string>
using namespace std;

void Construct(const string &pat, int next[])
{
    const int len = pat.length();
    next[0] = -1;
    int j = 0, lastNext = -1;
    //没错，只要把 len - 1 改成 len 就可以把最后一个也填进去了
    while (j < len)
    {
        if (lastNext == -1 || pat[j] == pat[lastNext])
        {
            ++j; ++lastNext;
            //这里不能优化，因为我们需要 next[i] 保存的就是 i-1 子串的最大匹配
            //next[j] = (pat[j] == pat[lastNext])? next[lastNext] : lastNext;
            next[j] = lastNext;
        }
        else
            lastNext = next[lastNext];
    }
}

void KMP(const string &src, const string &pat)
{
    const int slen = src.length();
    const int plen = pat.length();
    int i = 0, j = 0;
    //next 数组，next[i] 表示 pat[0~i] 的部分匹配数(即最长相匹配的真前缀后缀的长度)
    int next[plen + 1];
    Construct(pat, next);
    while (i < slen)
    {
        //匹配完了一次
        if (j == plen)
        {
            //题目是从 1 开始的(该死的!)
            cout << i - j + 1 << endl;
            //next[len] 存储了 pat 最长的匹配前后缀的长度
            //可以想象成 pat[len] 是一个和任何字符都不同的虚拟哨兵
            //这样情况就退化为 pat[len] 和 src[i] 失配的情况了
            j = next[plen];
        }
        else if (j == -1 || src[i] == pat[j])
        {
            ++i;
            ++j;
        }
        else
            j = next[j];
    }
    if (j == plen)
        cout << i - j + 1 << endl;
    //洛谷要求的 next 数组和我的不太一样...
    for (int i = 1; i <= plen; ++i)
    {
        //大爷的洛谷，居然末尾也可以有空格害得我白白查了半天不明白是怎么回事
        // if (i != 1)
        //     cout << " ";
        cout << next[i] << " ";
    }
}

int main()
{
    string src;
    string pat;
    //???谁跟我解释一下为什么 getline(cin, str) 就不行了?
    cin >> src >> pat;
    KMP(src, pat);
    return 0;
}
```








---

## 作者：一扶苏一 (赞：19)

## Algorithm

### Task

给定一个文本串 $S$ 和一个模式串 $T$，求 $T$ 在 $S$ 中出现的所有位置。

### Limitations

要求时空复杂度均为线性。

### Solution

回头重新学一遍~~看毛片~~ KMP 算法。

设 $X$  是一个字符串，则以下表述中，$X_u$ 代表 $X$ 的第 $u$ 个字符，$X_{u \sim v}$ 代表 $X$ 的从 $u$ 起到 $v$ 结束的字串。

首先定义一个字符串的公共前后缀为这个字符串的一个 $border$，最长公共前后缀称为最长 $border$。特别的，不认为字符串本身是自身的 $border$。

性质：字符串 $S$ 的 $border$ 的 $border$ 一定是 $S$ 的 $border$，正确性显然。因此不断地跳最长 $border$ 可以遍历字符串的所有 $border$

例如，对于字符串 $abaab$ 来说，其唯一的 $border$ 是 $ab$。

暴力匹配两个字符串，时间复杂度为 $O(|S||T|)$，考虑优化这个算法。

假设当前匹配时 $S$ 扫描到了第 $i$ 位， $T$ 扫描到了第 $j$ 位，且 $S$ 从 $i$ 向前 $j$ 位组成的字符串与 $T$ 的前 $j$ 位相同，而 $S_{i + 1} \neq T_{j+1}$，我们称为发生了失配。

考虑失配时，指针 $i$ 不变，只有将指针 $j$ 前移，才可能令下一位成功匹配。由于 $i$ 不变，所以下一个可能发生匹配的字符串一定是 $T_{1 \sim j}$ 的某个前缀 $T_{1 \sim k}$ 满足

 $$T_{1 \sim k} = S_{i - k + 1 \sim i}$$

其中由于 $T_{1 \sim k}$ 是 $T_{1 \sim j}$ 的字串，一定有 $k < j$。由于 $S_{1 \sim i}$ 的后 $j$ 位与 $T$ 的前 $j$ 位匹配，又有 $k < j$，因此 $T_{1 \sim j}$ 的后 $k$ 位一定与 $S_{1 \sim i}$ 的后 $k$ 位即 $S_{i - k + 1 \sim i}$ 匹配。得出 

$$T_{j - k + 1 \sim j} = S_{i - k + 1 \sim i}$$

上面两个式子等量代换得到 

$$T_{1 \sim k} = T_{j - k + 1 \sim j}$$

由 $border$ 的定义，我们发现 $T_{1 \sim k}$ 一定是 $T_{1 \sim j}$ 的 $border$。根据 $border$ 的性质，我们只需要不断的跳 $T_{1 \sim j}$ 的最长 $border$ 即可找到一个最长的可以与 $S_{1 \sim i}$ 的后几位匹配的字串。因此问题转化为了如何求一个字符串 $T$ 的所有前缀的最长 $border$。

显然 $border_1 = 0$。从第 $2$ 位开始，我们发现问题等价于用 $T$（模式串） 的一个前缀去匹配 $T_{1 \sim i}$ （文本串）的一个后缀，求这个后缀最长是多少，而这个问题的解决方法与上面那个问题的方法 **完 全 一 致**，都是不断跳 $border$ 即可。在 $i$ 与 $j$ 成功匹配时，记录 $border_i = j$。而在这个问题中，由于 $j$ 恒小于 $i$，正向扫描 $i$ 时，所用到的 $border$ 值都已经被计算出，因此可以得出正确的结果。

考虑时间复杂度：一个显然的事实是每次跳 $border$ 模式串指针 $j$ 都会至少减少 $1$，而当且仅当第 $S_{i+1}$ 与第 $T_{j+1}$ 匹配时，$j$ 才会自增，因此 $j$ 仅增加了 $O(|S|)$，因此 $j$ 只可能减少 $O(|S|)$ 次，所以跳 $border$ 的总次数不超过 $O(|S|)$，而扫描整个文本串需要 $O(|S|)$ 的时间，因此总时间复杂度 $O(|S|)$。

## Example

P3375 【模板】KMP字符串匹配

### Description

给定一个文本串 $S$ 和一个模式串 $T$，求 $T$ 在 $S$ 中出现的所有位置，同时要求输出 $T$ 的每个前缀的 $border$ 长度。

### Limitations

字符串长度不超过 $10^6$

### Solution

板板题

### Code

```cpp
#include <cstdio>
#include <cstring>

const int maxn = 1000006;

char S[maxn], T[maxn];
int nxt[maxn];

void KMP(char *A, char *B, int x, int y, const bool pt);

int main() {
  freopen("1.in", "r", stdin);
  scanf("%s\n%s", S + 1, T + 1);
  int x = strlen(S + 1), y = strlen(T + 1);
  KMP(T, T, y, y, false); KMP(S, T, x, y, true);
  for (int i = 1; i <= y; ++i) {
    qw(nxt[i], i == y ? '\n' : ' ', true);
  }
  return 0;
}

void KMP(char *A, char *B, int x, int y, const bool pt) {
  for (int j = 0, i = pt ? 1 : 2; i <= x; ++i) {
    while (j && (B[j+1] != A[i])) j = nxt[j];
    if (B[j+1] == A[i]) ++j;
    if (!pt) nxt[i] = j;
    if (j == y) {
      qw(i - y + 1, '\n', true);
    }
  }
}
```

---

## 作者：chu_yh (赞：8)

不得不承认，@皎月半洒花大佬讲的比我规范，但看不懂的话可以看看我的。

欢迎踩[博客](https://blog.csdn.net/Chu_yh/article/details/146869920?sharetype=blogdetail&sharerId=146869920&sharerefer=PC&sharesource=Chu_yh&spm=1011.2480.3001.8118)。

### 用途

在字符串初级算法里，而其中最经典的模型问题就是判断一个串是否是另一个串的子串。我们常用 KMP 算法解决这类问题。

### 题目描述

给定两个字符串 $s_1$ 和 $s_2$，求出 $s_2$ 在 $s_1$ 中所有出现的位置和 $s_2$ 的每个前缀 $s'$ 的最长 border 的长度。

在本题解中，我用 $n$ 代替 $|s_1|$（即 $s_1$ 的长度），用 $m$ 代替 $|s_2|$。

### 暴力匹配

枚举 $s_1$ 的每一个起始位置 $i(0\le i<n-m)$，看从 $i$ 位置开始往后长度为 $m$ 的子串是否是可以和 $s_2$ 匹配。

判断两个串匹配成功的条件是：两个串长度一致，两个串每一个对应位置字符都完全一样。

本做法时间复杂度为 $O(nm)$，只能得 70 分，~~比总司令高~~。

### 更优做法：KMP

#### 定义

定义一个字符串性质——前缀后缀最大值，即题目中要求的 border（~~让你求那多半要用~~）。

> 定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。

我将字符串 $s$ 的前缀 $s'$ 的最长 border 的长度称为 $next_{|s'|}$，~~别问我为啥~~。

换句话说，$next_i$ 就是**遍历到字符串 $s_2$ 的第 $i$ 位时，与已经匹配成功的部分的后缀相同的最大的长度**。我代码中的 `kmp[i]` 就是 $next_i$。

#### 匹配过程

举例说明，其中 $s_1$ 为 `ABACABACABD`，$s_2$ 为 `ABACABD`。

先将 $s_1$ 和 $s_2$ 的第一位对齐并看对应位是否相同，我们发现一路畅通，但最后一个匹配失败了。若这时对齐 $s_1$ 的第二位和 $s_2$ 的第一位将 $s_2$ 重新匹配一遍就成了暴力。

```
      i
ABACABACABD
ABACABD
      j
```

仔细回想 $next$ 定义发现：失配后，我们可以直接跳到 $next_j$，即与**已匹配部分相同的 $s_2$ 最大前缀的最后一位的下一位**，手动得出此时 $next_j=2$。然后就会变成这样：

```
      i
ABACABACABD
    ABACABD
      j
```

这样做，复杂度为 $O(n+m)$。

#### 求 $next$

将 $s_2$ 自己和自己匹配，过程和上面相仿。匹配到 $j$ 失败时，记录 $next_i$ 为 $j$。匹配时一个字符串不动，另一个向后移，$i$ 为匹配到不动的 $s_2$ 的位置，$j$ 为匹配到要动的 $s_2$ 的位置。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+2;
int kmp[N],la,lb,j;
//kmp即Next数组,表示相同前缀后缀最大值(不是对称的最大值)
string a,b,A,B;

int main(){
	cin>>A>>B;
	a='\0'+A,b='\0'+B;
	la=a.size()-1,lb=b.size()-1;
	for(int i=2;i<=lb;i++){//求kmp
		while(j&&b[i]!=b[j+1]) j=kmp[j];
		if(b[j+1]==b[i]) j++;
		kmp[i]=j;
	}
	j=0;
	for(int i=1;i<=la;i++){//匹配
		while(j>0&&b[j+1]!=a[i]) j=kmp[j];
		if(b[j+1]==a[i]) j++;
		if(j==lb){printf("%d\n",i-lb+1);j=kmp[j];}
	}
	for(int i=1;i<=lb;i++) printf("%d ",kmp[i]);
	return 0;
}
```

---

## 作者：cirnovsky (赞：8)

# 0x00 前言

本文和某播放软件KMPlayer没有一毛钱关系

# 0x01 引入问题

设想这样一个问题：

给你两个字符串，让你查找在文本串中模式串的位置。

暴力做法是显然的，举例来说：

文本串(text)：$a\ b\ c\ b\ c\ g\ l\ x$

模式串(pattern): $b\ c\ g\ l$

我们直接暴力枚举text中的每一个字符，并且依次与pattern中的字符从头开始匹配。时间复杂度为 $\Theta(nm)$

# 0x02 发现问题

这样做其实有很多冗余操作。比如说：$b\ c\ g\ l$ 与text中的 $b\ c\ b\ c$ 不匹配，又从第text的第五个字母 $c$ 开始匹配。这样做是显然不必要的。为什么呢？因为模式串是以  $b$ 开头的，对于text中第五个字母 $c$ 显然我们可以不去匹配。发现了什么吗？每次失配后我们只需要从两个字符串的最长公共部分开始匹配即可。这里看不懂没有什么关系，只要能理解后面的例子就可以了。

# 0x03 解决一部分问题

$\qquad\qquad\quad\ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5\ \ 6\ \ 7\ \ 8\ \ 9\ 10\ 11$

文本串(text)： $a\ \ b\ \ x\ \ a\ \ b\ \ c\ \ a\ \ b\ \ c\ \ a\ \ b\ \ y$

$\qquad\qquad\qquad\ \ \ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5$

模式串(pattern)： $a\ \ b\ \ c\ \ a\ \ b\ \ y$

我们有两个指针i和j，分别指向文本串和模式串。在i=0,j=0以及i=1,j=1的时候都匹配上了。但是在i=2,j=2时失配了。如果时朴素算法的话会令i=1,j=0重新开始匹配。然而我们发现我们完全可以令i=3,j=0来重新匹配。一直到i=8,j=5时，它们又失配了。我们令j等于模式串和文本串已经配对完成的部分(即pattern[0]~pattern[4])的最长公共前缀后缀(即pattern[0,1]和pattern[3,4])的前缀末尾部分+1(即1+1=2)的地方，此时的text[6,7]和pattern[0,1]都是ab也就是说我们可以直接从i=8,j=2开始匹配，就可以匹配到模式串了。这就是KMP玄妙的地方。

# 0x04 解决另一部分问题

那么问题来了：我们如何确定模式串最长公共前后缀的前缀末尾+1的位置呢？我们还是通过一个例子来感受。

$\qquad\qquad\qquad\ \ \ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5$

模式串(pattern)： $a\ \ b\ \ c\ \ a\ \ b\ \ y$ (没错就是上面那个我太懒了)

我们可以设数组$next_i$为以 $i$ 为结尾的模式串最长公共前后缀的前缀末尾+1的位置。

$next_0$显然为0。

我们依然设两个指针i和j，i初始化为0，即指向模式串的开头。j初始化1，即i后面一个。

pattern[i]不等于pattern[j]，令next[i]=0，j+=1

pattern[i]依然不等于pattern[j]，令next[i]=0，j+=1

此时pattern[i]等于pattern[j]，令next[i]=j+1=1，i+=1，j+=1

此时pattern[i]等于pettern[j]，令next[i]=j+1=2，i+=1,j+=1

此时pattern[i]不等于patter[j]，并且j不在模式串的开头，令j=next[j-1]=2

此时pattern[i]依然不等于pattern[j]，并且j不在模式串的开头，令j=next[j-1]=0

此时pattern[i]依然不等于pattern[j]，但是j已经跑到开头去了，令i+=1

此时pattern[i]依然不等于pattern[j]，并且i已经跑到了尽头，求解结束。

%出来next数组是这样的:$[0,0,0,1,2,0]$

# 0x05 解决所有问题

~~其实就是放一下代码~~

我自认为讲的还是比较清楚，~~至少比蓝书好~~。

代码虽然和网上其他人的不太一样，不太标准，但还算简洁，~~至少比蓝书好~~。

总之一句话，学KMP不要看书，不要看书，不要看书！！！会死人的！！！

对了还有一个坑点，我这份代码用std::string会RE，~~鬼知道我调了一下午发现是这个原因时心里有多傻逼~~


```cpp
/*
 * P3375【模板】KMP字符串匹配.cpp
 * Created by boringhacker(c20220233wgy)
*/
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

namespace MAIN {
    const int SIZE = 1000000 + 5;
    int next[SIZE], n, m;
    char Text[SIZE], Pattern[SIZE];
    // string Text, Pattern; 去你的std::string

    void GetNextVal() {
        int i = 1, j = 0;
        *next = 0;
        while (i < n) {
            if (Pattern[i] == Pattern[j])
                next[i] = j + 1, ++i, ++j;
            else if (j) j = next[j - 1];
            else ++i;
        }
    }

    void GetAnswers() {
        int st = 0, res = -1;
        int i = 0, j = 0, flag = 0;
        while (true) {
            j = st;
            if (Text[i] == Pattern[j]) {
            	if (!flag) res = i + 1 - st, flag = 1;
                if (j == n - 1) cout << res << endl, j = 0, flag = 0;
                else ++i, ++j;
                st = j;
                if (i >= m) return ;
            }
            else {
            	if (j) st = next[j - 1];
            	else ++i;
            	flag = 0;
			}
        }
    }

    void MAIN() {
        cin >> Text;
        cin >> Pattern;
        m = strlen(Text);
        n = strlen(Pattern);
        GetNextVal();
        GetAnswers();
        for (int i = 0; i < n; ++i) cout << next[i] << ' ';
    }
}

signed main() {
    MAIN::MAIN();
    return 0;
}
```

# 欢迎捉虫子

---

## 作者：kunkun127 (赞：6)

## 使用背景

给定两个字符串 $s_1$ 和 $s_2$，需要找到 $s_2$ 在 $s_1$ 中出现的所有位置。

## 暴力求解

我们很容易想到的就是匹配字符串时，我们从目标字符串 长度为 $n$ 的 $s_1$ 的第一个下标选取和长度为 $m$ 的 $s_2$ 长度一样的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取 $s_1$ 下一个下标，同样从 $s_2$ 选取长度为 $n$ 的字符串进行比较，直到 $s_1$ 的末尾。

显然，我们发现了许多不合理的操作：**比对失败时会从头开始匹配**，浪费了许多时间，时间复杂度为 $O(nm)$。

## KMP 算法

根据上述原因，我们可以进一步优化。

在比对失败之后，**如果可以向后移动多位，就可以减少不少时间**。

- ### next 数组
  此时可以建立一个 next 数组（或 nxt），作为一个**转移数组**。它的含义就是**一个固定字符串的最长前缀与最长后缀相同的长度**。
  
  如：  
  
  `abcdefgabc`
  
  不难发现，在这个样例下，相同的最长前缀与最长后缀就是 `abc`。
  
  此时要注意，**最长前缀是从第一个字符开始，但不包含最后一个字符**。  
  例如：
  
   `kkkk`
  
  他的最长前缀是 `kkk`。

  讲完上面的定义后，便进入正题。

  以字符串

  `ababaca`
  
  为例。  
  我们用 next 数组来计算字符串中相同的最长前缀与最长后缀。方便理解，next 数组下标从 $0$ 开始，分别计算 `a`，`ab`，`aba`，`abab`，`ababa`，`ababac`，`ababaca`。

  显然得出，其对应为
  
  0. 无。**`a` 只有一个字符，非相同，这是一个很重要的点**。
  1. 无。`ab` 中 `a` 与 `b` 无法匹配。
  2. `a`，`aba` 中。
  3. `ab`，`abab` 中开头结尾两个 `ab` 匹配。
  4. `aba`，`ababa` 中先取前三个字符 `aba`，再取后三个字符 `aba` 匹配。
  5. 无。`ababac` 显然无法匹配。
  6. `a`，`ababaca` 开头结尾的两个 `a` 匹配。  

  这时，next 数组已经赋值为了 `{0, 0, 1, 2, 3, 0, 1}`。

  我们想要用代码实现，可以用一张图来便于理解。
  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/ulh9urrq.png)
    
  上图中的 $A$ 是一样的。两个 $A$ 之间的也是一样的，我们发现 $a$ 和 $b$ 不一样。之前的算法是把下面的字符串往前移动一个距离，重新从头开始比较，那必然存在很多重复的比较。**现在的做法是，我把下面的字符串往前移动，使 $s_1$ 尾部的 $A$ 和 $s_2$ 对齐，直接比较 $a$ 和 $c$ 是否一样**。
  
  可以看到，匹配串每次往前移动，都是一大段一大段移动，假设匹配串里不存在重复的前缀和后缀，即 next 的值都是 $0$，那么每次移动其实就是一整个匹配串往前移动 $m$ 个距离。然后重新一一比较，这样就比较 $m$ 次，也就是，每次移动长度为 $m$ 的距离，比较 $m$ 次，移到末尾，就是比较 $n$ 次，时间复杂度为 $O(n)$。假设匹配串里存在重复的前缀和后缀，移动的距离相对小了，比较的次数也小了，但时间也是 $O(n)$。这就是 KMP 算法的好处。
  
## 代码实现


  1. 求 next 数组（**建议写成 nxt**）

      ```cpp
      int len1 = s1.size(), len2 = s2.size();
      int j = 0;
      for (int i = 1; i < len2; i++)
      {
          while (j > 0 && s2[i] != s2[j]) j = nxt[j - 1];
          if (s2[i] == s2[j]) j++;
          nxt[i] = j;
      }
      ```

      外围的循环就是遍历整个 $s_2$，从 $1$ 开始寻找的原因就是刚刚所说的，**单个字符无法构成最长前缀，直接从第二个字符开始查找**。  
      内层循环，**如果 $j$ 此时大于 $0$，并且 $s2_i$ 与 $s2_j$ 不匹配，那么就进行回溯（$j = nxt_{j-1}$）**。  
      进入到下面的判断，此时如果 $s2_i$ 等于 $s2_j$，$j$ 加一。  
      此时再将 $nxt_j$ 赋值为 $j$，**也就是相同的最长前缀和最长后缀的长**。

  2. 进行 KMP。
  
      ```cpp
      for (int i = 0; i < len1; i++)
      {
         while (j > 0 && s1[i] != s2[j]) j = nxt[j - 1];
         if (s2[j] == s1[i]) j++;
         if (j == len2) cout << (i + 1) - len2 + 1 << endl, j = nxt[j - 1]; 
      }
      ```

      其实跟求 nxt 数组的过程差不多。只是我们不需要再更改 nxt 数组，而是当 $j$ 等于 $s_2$ 的长度时输出匹配成功的第一个字符的位置即可，再更新 $j$。

这就是 KMP 算法的整个流程。

## 参考代码（模板）

```cpp
#include <bits/stdc++.h>
using namespace std;
int nxt[1000005];
 
int main()
{
    string s1, s2;
    cin >> s1 >> s2;
    int len1 = s1.size(), len2 = s2.size();
    int j = 0;
    for (int i = 1; i < len2; i++)
    {
        while (j > 0 && s2[i] != s2[j]) j = nxt[j - 1];
        if (s2[i] == s2[j]) j++;
        nxt[i] = j;
    }
    j = 0;
    bool flag = false;
    for (int i = 0; i < len1; i++)
    {
        while (j > 0 && s1[i] != s2[j]) j = nxt[j - 1];
        if (s2[j] == s1[i]) j++;
        if (j == len2) cout << (i + 1) - len2 + 1 << endl, j = nxt[j - 1], flag = true; 
    }
    for (int i = 0; i < len2; i++) cout << nxt[i] << ' ';
    return 0;
} 
```

## 时间复杂度

在预处理阶段，我们生成前缀函数这一步为 $O(n)$。后面搜索阶段，就算每次都不匹配，最坏情况下也只有 $O(m)$。因此，KMP 算法的时间复杂度为 $O(n + m)$。

---

## 作者：lmaz (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P3375)

## 一，浅谈 KMP 算法
KMP 算法，又称模式匹配算法，能够在线性时间内判定字符串 $p_1\sim p_N$ 是否为字符串 $s_1\sim s_M$ 的子串，并求出 $p$ 在 $s$ 中各次出现的位置。时间复杂度为 $O( N + M )$。
而值得一提的是：KMP 算法是由三个人名字的首字母拼起来的，他们分别是

Donald **K**nuth

James Hiram **M**orris

Vaughan **P**ratt
~~（与本题无关，仅作拓展）~~
## 二，算法实现 KMP 算法
![](https://pic1.imgdb.cn/item/681f27c158cb8da5c8eb3339.jpg)
求 $next$ 数组：以模式串 $p$ 为基础，以 $p_i$ 结尾最长真公共前后缀子串长度。
![](https://pic1.imgdb.cn/item/681f27b958cb8da5c8eb3338.jpg)

1. 初始化：$next_1=0$ , $j=0$, 假定 $next_1\sim next_i-1$已求出，下面求解 $next_i$ ;

2. 不断尝试扩展匹配长度 $j$ ，如果扩展失败，即下一个字符不相等，令 $j=next_j$，直至 $j$ 为 $0$，重新从头匹配；

3. 如果能够扩展成功，匹配长度增加 $1$ ，$next_i$ 的值就是 $j$ 。
（与代码一同使用更好~）


```cpp
for(i=2,j=0;i<=lenb;++i){//见上图
		while(j&&s2[i]!=s2[j+1])
		/*配不上时，j往前面找next数组的值，也就是归零*/	
			j=next[j];//和之前的比较有没有出现过 
		if(s2[i]==s2[j+1])++j;//计数：子串长度 
		next[i]=j;//存入长度j 
	}
```
同时，我们还可以求第二个字符串在第一个字符串所有出现的位置。
在 $next$ 数组里，其值相当于一个其子串的长度。所以，当 $next$ 记录的数等于第二个字符串的长度时，满足条件。（如下代码）
```C++
for(i=1,j=0;i<=lena;++i){
		while(j>0&&s2[j+1]!=s1[i])
			j=kmp[j];
		if(s2[j+1]==s1[i])++j;//与上同理 
		if(j==b){//和字符串s2进行比较，成立便输出 
			printf("%d\n",i-b+1);
			j=kmp[j];
		}
	}
```
## 三，回到本题
将问题分为两个小问题：
1. 输出位置
2. 输出 $next$ 数组
   
据上面，那便很容易解决了。
## 最后的源代码：
```C++
#include<cstdio>
#include<cstring>
const int N=1e6+10; 
char s1[N],s2[N];
int a,b,i,j;
int kmp[N];//结尾最长真公共前后缀子串长度 
int main(){
	scanf("%s\n%s",s1+1,s2+1);
	a=strlen(s1+1);b=strlen(s2+1);//长度
	for(i=2,j=0;i<=b;++i){
		while(j&&s2[i]!=s2[j+1])
		/*配不上时，j往前面找kmp数组的值，也就是归零*/	
			j=kmp[j];//和之前的比较有没有出现过 
		if(s2[i]==s2[j+1])++j;//计数：子串长度 
		kmp[i]=j;//存入长度j 
	}//处理问题二 
	for(i=1,j=0;i<=a;++i){
		while(j>0&&s2[j+1]!=s1[i])
			j=kmp[j];
		if(s2[j+1]==s1[i])++j;//与上同理 
		if(j==b){//和字符串s2进行比较，成立便输出 
			printf("%d\n",i-b+1);
			j=kmp[j];
		}
	}//处理完问题一
	for(int i=1;i<=b;++i)
		printf("%d ",kmp[i]);//处理问题二输出 
	return 0; 
}
```
~~完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。~~

---

## 作者：Zilljy258 (赞：5)

模式串和模板串我分不大清楚，但我们暂且记短串叫做模式串吧。

这个算法大概就是用来**判断能否在主串中匹配到子串**。

KMP 算法在入门阶段是一个很常考的字符串算法，后期高级阶段不知道还考不考，因为我菜。

下面就来讲一讲思想：


## 一、最长公共前后缀

这里提到了**最长公共前后缀**的概念。

### 什么是最长公共前后缀？


> 前缀：字符串中**不包含最后一个字符**，必须包含第一个字符的连续子串。
> 
> 后缀：字符串中**不包含第一个字符**，必须包含最后一个字符的连续子串。

那么一个字符串的最长公共前后缀，就是这个串中**长度最长的一对相同的前缀和后缀。**

举个例子：
```
abcab
ababab
abcba
```
它们的最长公共前后缀分别是：
```
ab
abab
a
```
**注意两个点：**

1. 前缀和后缀可以重叠，但是都不可以等于原串。
2. 不要自己想象着就把后缀倒过来！公共前后缀不是回文串。

## 二、失配数组

失配数组顾名思义就是在匹配失败的时候用到的数组。

我们记为 $fail$ 数组。

$fail_i$ 表示：**模式串长度为 $i$ 的前缀的最长公共前后缀。**

呃，好像有点绕，多读几遍理解一下。

所以 $fail$ 数组存的是最长公共前后缀的长度。

有什么用呢，当模式串和主传匹配失败的时候，我们需要跳到模式串的最长公共前后缀去继续匹配，这就是该数组在匹配失败时的作用。

这里后面会详细讲到，看不懂别着急，理解 $fail$ 的含义就好了。

## 三、算法流程

在程序的开始，我们遍历主串，同时与模式串进行匹配。

（不得不拿出经典套图了！）

![](https://cdn.luogu.com.cn/upload/image_hosting/h74u59xd.png)

$i$ 是遍历主串的变量，$p$ 是我们模式串的指针。

起初，匹配很平稳（两个指针共同向右移动）……直到：

![](https://cdn.luogu.com.cn/upload/image_hosting/d8vq88ke.png)

接下来这一位（画红叉号的位置）不一样！

此时，匹配失败！我们跳转至模式串 $fail_p$ 继续匹配。

### 为啥要跳 $fail_p$？

因为如果此时我们暴力退回去重新从零开始匹配实在是太慢了。

在我们失配之前，模式串和主串还是可以正常匹配的。仅仅是这一位不匹配了。从模式串的头重新开始岂不是前功尽弃了？

聪明的科学家们想到：既然之前都可以匹配，那之前的子串的**所有公共前后缀一定也可以匹配！**

如下图，三个绿色的串是完全相等的！

![](https://cdn.luogu.com.cn/upload/image_hosting/tj1pbk23.png)

查表可知，$fail_5$ 值为 $2$，那我们跳呗！

![](https://cdn.luogu.com.cn/upload/image_hosting/k85a1cja.png)

好的，跳完我们发现模式串的前两位和主串中$i$ 前面的两位果然是一样的。（都为“ab”）

可以继续进行下一位匹配了。（如果下一位还不匹配，就再调 $fail_2$，一直到跳到可以匹配或者 $p$ 归零）

继续匹配……直到结尾，$p=6$ 模式串跑完了。

![](https://cdn.luogu.com.cn/upload/image_hosting/rly7z3ry.png)

这时候我们知道：匹配成功！

---

代码放一下。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

char s[1000010];
char t[1000010];
int fail[1000010];

int main(){
	scanf("%s%s",s+1,t+1);
	
	int n=strlen(s+1);
	int m=strlen(t+1);
	int p;
	
	fail[0]=0;
	p=0;
	for(int i=1;i<m;++i){ //这里在求 fail 数组。
		while(t[p+1]!=t[i+1]&&p) p=fail[p]; //失配就跳 fail。
		if(t[p+1]==t[i+1]){ //下一位可以匹配，我们就前进一位。
			p++;
		}
		fail[i+1]=p;
	}
	
	p=0;
	for(int i=1;i<=n;++i){ //这里在进行文本串和模式串的匹配。
		while(t[p+1]!=s[i]&&p) p=fail[p]; //失配就跳 fail。
		if(t[p+1]==s[i]){
			p++;
		}
		if(p==m){ //匹配成功！
			printf("%d\n",i-m+1);
			p=fail[p];
          //这里注意一下，匹配成功以后也要跳 fail，具体原理和失配一样，都是前后缀相同嘛。
          //不过如果题目要求匹配的模式串不能重叠，这里就得 p=0 了。好像有个剪布条的题就得这么写。
		}
	}
	
	for(int i=1;i<=m;++i){
		printf("%d ",fail[i]);
	}
	
	
	return 0;
}
```

写模板题的题解就是累，还写不明白。欸。

---

### Update：

2025.4.6：@[Frielen](https://www.luogu.com.cn/user/1125685) 提醒我更正了一个错误的例子，感谢他的贡献。

---

## 作者：__youzimo2014__ (赞：4)

不说那么多废话啊我们直接上正题。

# border 的性质

至于 border 是什么，题目里面有。

我们接下来介绍一下 border 的两个性质：

性质一：如果把 $s$ 串最后一个字符去掉的结果记为 $s'$，把 $x$ 串的最后一个字符去掉的结果记为 $x'$ 那么如果 $x$ 是 $s$ 的 border，那么 $x'$ 也是 $s'$ 的 border（反过来不一定）。

很好理解：因为 $x$ 是 $s$ 的后缀，那么它们各自从末尾去掉一个字符，$x'$ 依然是 $s'$ 的后缀；而且 $x$ 是 $s$ 的前缀，同理 $x'$ 也一定是 $s'$ 的前缀，即使前缀也是后缀也不相等，那不就是 border 吗？

性质二：一个字符串 $s$ 的 border 的 border 也一定是 $s$ 的 border，至于为什么这里不再赘述了。

不过神奇的是，除了 $s$ 的最长 border，$s$ 的其他所有 border 都是 $s$ 的最长 border 的 border。

我知道这句话可能有点抽象，所以换句话说，我们一直令 $s$ 为 $s$ 的最长 border，那么这样遍历下去直到 $s$ 为空，就可以遍历完最开始 $s$ 所有的 border。

# KMP 过程

现在我们要对字符串 $s$ 进行 KMP。

我们令 $nxt_i$ 为 $s$ 的前 $i$ 个字符构成的前缀的最长 border 的长度，现在我们要依次求出 $nxt_1$ ~ $nxt_{|s|}$。

考虑现在已经求出了 $nxt_1$ ~ $nxt_{i - 1}$ ，现在要求 $nxt_i$。

根据 border 的性质一，我们可以得出：先找到 $s_{1...i - 1}$ 的一个长度为 $k$ 的 border，满足 $s_{k + 1} = s_i$。

形象一点，由于性质一反过来不一定成立，所以我们可以贪心地找到 $s'$ 的最长的 border 使得可以反过来满足性质一。

那么怎么寻找 $s'$ 地那个满足条件的 border 呢？这就要用到性质二了，由于上面已经说过怎么遍历这里不再赘述。

好的 KMP 的主要代码如下：

```cpp
nxt[1] = 0;
for (int i = 2; i <= len; i++) { // 依次求出 2...len 的border
  int p = nxt[i - 1];
  while (p >= 1 && s[p + 1] != s[i]) p = nxt[p];
  if (s[p + 1] == s[i]) nxt[i] = p + 1; 
}
```

最后有一个小细节：最长 border 是求出来了，那上面的字符串匹配呢？

我们考虑把 $s_2$ 和 $s_1$ 接起来，但是考虑到这样可能会有超过 $s_2$ 长度的最长 border，我们需要在它们中间加一个特殊字符，比如我这边加的就是井号 `#`，然后一旦发现一个前缀的最长 border 为 $s_2$ 那么就匹配成功了。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int nxt[N << 1];
char s1[N], s2[N], s[N << 1];
int main() {
	scanf("%s%s", s1 + 1, s2 + 1);
	int len1 = strlen(s1 + 1), len2 = strlen(s2 + 1);
	for (int i = 1; i <= len2; i++) s[i] = s2[i];
	s[len2 + 1] = '#';
	for (int i = 1; i <= len1; i++) s[len2 + i + 1] = s1[i];
	for (int i = 2; i <= len1 + len2 + 1; i++) {
		int p = nxt[i - 1];
		while (p >= 1 && s[p + 1] != s[i]) p = nxt[p];
		if (s[p + 1] == s[i]) nxt[i] = p + 1;
		if (nxt[i] == len2) cout << i - len2 - len2 << endl;
	}
	memset(s2, 0, sizeof s2);
	cout << "0 "; 
	for (int i = 2; i <= len2; i++) {
		int p = nxt[i - 1];
		while (p >= 1 && s[p + 1] != s[i]) p = nxt[p];
		if (s[p + 1] == s[i]) nxt[i] = p + 1; 
		cout << nxt[i] << ' ';
	}
	return 0;
}

```

---

## 作者：wangzifan1227 (赞：4)

## 一、算法介绍
KMP 算法是一种 **改进的字符串匹配算法**，用于在 **主字符串 $s$** 中快速查找 **模式字符串 $p$** 的位置。

---
### **核心思想**
通过 **预处理模式串**，避免在匹配失败时进行不必要的回溯，从而将时间复杂度优化到 $O(n+m)$（$n$ 是主串长度，$m$ 是模式串长度），显著优于暴力匹配算法的 $O(n \times m)$。
1. **利用已匹配信息**：当字符不匹配时，根据预生成的 **部分匹配表（Next 数组）**，跳过一定长度的重复比较。
2. **避免主串指针回退**：主串的指针始终向前移动，无需回溯，仅调整模式串的位置。

---
### **关键：部分匹配表（Next 数组）**
Next 数组记录**模式串**每个位置的 **最长公共前后缀长度**，用于确定匹配失败时模式串 **应跳转的位置**。

**示例**：模式串 `ABABC` 的 Next 数组构建。
| 下标 | 0 | 1 | 2 | 3 | 4 |
|------|---|---|---|---|---|
| 字符 | A | B | A | B | C |
| Next | 0 | 0 | 1 | 2 | 0 |

**注意：前缀后缀不包括原字符串（否则没有优化）。**

---
### **算法步骤**
1. **构建 Next 数组**：
   - 初始化 `Next[0]=0`。
   - 使用双指针（$i$ 遍历模式串，$j$ 记录公共前后缀长度）。
     - 若 `p[i]==p[j]`，则 `Next[i]=j+1`，`j++`。
     - 否则，若 `j>0`，回退 `j=Next[j-1]`；否则 `Next[i]=0`。

2. **匹配过程**：
   - 主串指针 $i$ 和模式串指针 $j$ 初始为 $0$。
   - 若 `s[i]==p[j]`，则 `i++`，`j++`。
   - 若 `j==m`，匹配成功，返回位置 `i-m`。
   - 若字符不匹配。
     - 若 `j>0`，令 `j=Next[j-1]`。
     - 否则 `i++`。

---
### **举例**
**主串 $s$**：`ABABABC`。  
**模式串 $p$**：”`ABABC`。  
**Next 数组**：`[0,0,1,2,0]`。
1. 第一次匹配到 `s[4]` 失败。
2. 查 `Next[3]=2`，模式串跳转到下标 $2$ 继续匹配。
3. 最终在主串位置 $2$ 找到完整匹配。

---
### **优势与局限**
- **优势**：避免重复匹配，适合处理含重复前缀的模式串（如 `AAAAA`）。
- **局限**：需额外空间存储 Next 数组，短模式串中优势不明显，属于 **空间换时间**。

## 二、代码实现
**注意：变量名不能用 next，所以可以首字母大写。**
```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N=1e6+5;
char s[N],p[N];
int Next[N],lens,lenp;
int main(){
    cin>>s+1;
    cin>>p+1;
    lens=strlen(s+1);
    lenp=strlen(p+1);
    for(int i=2,j=0;i<=lenp;i++){//构建Next数组  
		while(j&&p[i]!=p[j+1]) j=Next[j];    
    	if(p[j+1]==p[i]) j++;    
    	Next[i]=j;
    }
    for(int i=1,j=0;i<=lens;i++){//匹配 
        while(j>0&&p[j+1]!=s[i]) j=Next[j];
        if(p[j+1]==s[i]) j++;
        if(j==lenp){
			cout<<i-lenp+1<<endl;
			j=Next[j];
		}
    }
    for(int i=1;i<=lenp;i++){
    	cout<<Next[i]<<" ";
	}
    return 0;
}
```
$upd:$ 2025-04-05  
$upd:$ 2025-04-09  
$upd:$ 2025-04-13  
$upd:$ 2025-04-14

---

## 作者：Kexi_ (赞：2)

upd 2025.5.10 : 加入完整代码

有点难的东西，彻底理解大概需要一两天的思考。

接下来的讲解将会分为引子，正文，以及常见问题三部分。

## 引子

我们首先看暴力法。

这不需要任何脑子，就是使用 $i$ , $j$ 两个指针分别指向文本串和模式串进行比对，复杂度显然 $O(n^2)$。

考虑到底是哪里浪费了时间。每次的匹配我们其实已经知道了文本串的一些信息，因此我们应该避免获取重复的信息。

顺藤摸瓜，我们的主要目标明确了。即避免 $i$ 指针的回溯。

## 正文

介绍一下 KMP 算法的核心点：公共前后缀数组。

意思就是一个字符串的前缀串的最长公共前后缀的长度。记作 $next$。

```cpp
abbab 的 next 数组如下
0 0 0 1 2
```
这玩意有啥用呢？就是你匹配的时候模式串移动到的位置。

现在给出一个例子。

![a](https://cdn.luogu.com.cn/upload/image_hosting/3nvma3xk.png)

假设你已经求出了模式串的 $next$ 数组。那么 $next_3 = 2$，你就可以直接把整个模式串往右移动到下标为 2 的地方。

然后你再看现在移动完成后两个串的下一位能否匹配来决定是否要继续往前查 $next$。这个图里是相同的，所以 $i$, $j$ 都增加。

![a](https://cdn.luogu.com.cn/upload/image_hosting/4rgwmvjf.png)

此时 $i = 4,j = 3$。 

如果不相同，你就要继续往前找 $next$ 数组。在这个图里就是 $next_{next_i} = 1$。当然这只是假设。

概括一下我们干的事情其实就是找一个最长的可以接在文本串第 $i$ 位前面的模式串的前缀。这样一来就大大优化了比对的次数。

这部分的完整代码如下。

```cpp
j = 0;
	for(register int i = 1; i <= n; ++i) {
		while(s2[j + 1] != s1[i] && j >= 1) {
			j = phi[j]; //如果不相同就继续往前找更小的公共前后缀
		}
		if(s2[j + 1] == s1[i]) {
			++j; //相同就增加
		}
		if(j == m) {
			cout << i - j + 1 << '\n';
			j = phi[j]; //这里别忘了匹配也要跳
		}
	}
```

然后就是怎么求 $next$ 数组了。这个好理解，比上文简单些。

我们依然采用刚才的代码结构。我们可以发现 $next_i$ 一定是要比 $next_{next_i}$ 长的，因此可以直接暴力的比对，第一个找到的一定是最长的。

也就相当于是要找一个公共前后缀能接上新的这一位。听不懂没关系，看代码就懂了。

```cpp
int j = 0;
	for(register int i = 2; i <= m; ++i) { //phi[1]是 0，就不从 1 开始写了
		while(s2[j + 1] != s2[i] && j >= 1) {
			j = phi[j]; //不一样就往前找更小的
		}
		if(s2[j + 1] == s2[i]) {
			++j;//一样就增加
		}
		phi[i] = j; //记录
	}
```

## 常见问题

- 关于复杂度？

  这个好讲。在预处理 $next$ 的时候，可以发现 $j$ 一共增加不会超过 $m$ 次，你跳至少跳一个，所以也不会跳超过 $m$ 次。因此你的预处理复杂度是 $O(m)$。

  而匹配的时候，遍历整个文本串就需要 $O(n)$ 的时间，因此总复杂度是 $O(n + m)$ 的。

- 不会漏情况嘛？

  这算法看着很不靠谱。如果在你 $j$ 和 $next_j$ 之间还有能匹配的不就漏了吗？

    然而这是不会发生的。因为你 $i$ 是一位一位往右移的，因此漏掉的情况总会有一个 $i$ 给判断掉。不能只考虑一个 $i$，而是要全盘思考。我不认为除我会有人为这个简单的事情疑惑很久罢。


总结： KMP 其实本质上还是枚举文本串的每一位，只不过是跳过了前面已知的相同前缀的比对。是十分精妙的巧思。


```cpp
#include <bits/stdc++.h>
const int N = 1e6 + 7;
using namespace std;
string s1 , s2;
int phi[N];
int main() {
	ios :: sync_with_stdio(0) , cin.tie(0) , cout.tie(0);
	cin >> s1 >> s2; 
	int n = s1.size() , m = s2.size();
	s1 = '$' + s1 , s2 = '$' + s2;
	int j = 0;
	for(register int i = 2; i <= m; ++i) {
		while(s2[j + 1] != s2[i] && j >= 1) {
			j = phi[j];
		}
		if(s2[j + 1] == s2[i]) {
			++j;
		}
		phi[i] = j;
	}
	
	j = 0;
	for(register int i = 1; i <= n; ++i) {
		while(s2[j + 1] != s1[i] && j >= 1) {
			j = phi[j];
		}
		if(s2[j + 1] == s1[i]) {
			++j;
		}
		if(j == m) {
			cout << i - j + 1 << '\n';
			j = phi[j];
		}
	}
	
	for(register int i = 1; i <= m; ++i) {
		cout << phi[i] <<' ';
	}
	return 0;
}
```

---

## 作者：江湖午餐票 (赞：2)

> 刚好最近学完 $\mathcal{KMP}$ 算法，写一篇题解记录一下，学习过程。
>
> 大量参考了网络上的相关内容，侵权自删。

# 1. 前缀函数

要讲 $\mathcal{KMP}$ 算法必然离不开前缀函数，除了模式串匹配以外，前缀函数还有其他应用，大家可以上 [OI Wiki](https://oi-wiki.org/string/kmp/) 详细了解。

## 1.1 前缀函数的定义

[OI Wiki](https://oi-wiki.org/string/kmp/) 上的定义非常简洁明了，这里直接引用。

对于一个长度为 $n$ 的字符串 $s$，其前缀函数被定义为一个长度为 $n$ 的数组 $\pi$。其中 $\pi[i]$ 为子串 $s[0\dots i]$ 最长的、相等的真前缀与真后缀的长度，即**最大公共前后缀长度**。

用数学语言描述如下：

$$
\pi[i] = \max_{k = 0 \dots i}\{k: s[0 \dots k - 1] = s[i - (k - 1) \dots i]\}
$$
特别地，规定 $\pi[0]=0$。

## 1.2 前缀函数的求解

假设已知 $\pi[0\dots i-1]$，则已知前 $i−1$ 个字符的最长公共前后缀长度为 $k^{(1)}=π[i−1]$，考虑 $\pi[i]$ 的转移。易得若 $s[k^{(1)}]=s[i]$ 则 $\pi[i] = \pi[i-1]+1$。

考虑不相等的情况，则需寻找子串 $s[0\dots i-1]$ 中比 $k^{(1)}$ 更短的最长公共前后缀 $k^{(2)}$。

此时子串 $s[0\dots i-1]$ 最长公共前后缀 $s[0\dots k^{(1)}-1]$ 自身的最长公共前后缀长度为 $\pi[k^{(1)}-1]$。

根据前缀函数的定义， $s[0\dots \pi[k^{(1)}-1]-1] $ 和 $s[k^{(1)}-\pi[k^{(1)}-1]\dots k^{(1)}-1]$ 必然相等。

由于前缀$s[0 \dots k^{(1)-1}]$和后缀 $s[i-k^{(1)}\dots i-1]$ 相等，因此 $s[i-\pi[k^{(1)}-1]\dots i-1]$ 也与 $s[0\dots \pi[k^{(1)}-1]-1]$ 相等，易发现这就是第二长度的公共前后缀。

故可推出 $k^{(j)}=\pi[k^{(j-1)}-1],j>1$，则前缀函数的伪代码如下：

```python
k = pi[i-1]
while k>0 && s[i]!=s[k]:
    k = pi[k-1]
if s[k] == s[i]:
    pi[i] = k+1
```

# 2. 应用

## 2.1 字符串匹配算法

$\mathcal{KMP}$ 算法是前缀函数蛮经典的应用了，它能在 $O(n+m)$ 的时间复杂度完成字符串匹配。

在上文了解了前缀函数的相关内容后，我们不难发现将模式串和主串用一个分割符（需保证在模式串和主串中**均未出现**）连接起来，求解这个新字符串的前缀函数，若有 $\pi[i]$ 等于模式串长度则 $i$ 为模式串在主串的一个成功匹配的位置。

那为什么一定要用分隔符呢？

这里简单举一个例子，模式串 `aa`，主串 `abaaab`，直接连接为 `aaabaaab`，这时 $\pi=\{0,1,2,0,1,2,3 ,4\}$ 。

你会发现受到主串中 $s[0] = \text a$  的影响，最长公共前后缀长度不能**永远小于等于**模式串长度，导致匹配出的位置少甚至错误。

参考代码：

```c++
#include <bits/stdc++.h>
using namespace std;
int pi[2000005];
string s1,s2,s3;
int main(){
	cin >> s1 >> s2;
	s3 += s2;
	s3 += " ";
	s3 += s1; 
	pi[0] = 0;
	for(int i=1;i<s3.size();i++)
	{
		int len = pi[i-1];
		while(len!=0&&s3[i] != s3[len])
		{
			len = pi[len-1];
		}
		if(s3[i] == s3[len])
		{
			pi[i] = len+1;
		}
		if(pi[i] == s2.size())
		{
			cout << i-2*s2.size()+1 << "\n";
		}
	}
	for(int i=0;i<s2.size();i++)
	{
		cout << pi[i] << " ";
	}
	return 0;
} 
```

---

## 作者：niuzh (赞：1)

**此题解下标统一从 $1$ 开始。**

#### 前置芝士
 - [字符串](https://oi-wiki.org/string/basic/)
### 思路
先定义一个长为 $n$ 的字符串 $s$ 的**前缀函数**是一个长为 $n$ 的数组 $a$。其中 $a_i$ 是 $s$ 的前缀 $s[1...i]$ 中最长的相等的真前缀与真后缀的长度。特别的，$a_1$ 等于 $0$，因为没有真前缀。

举个栗子，对于字符串 `abcabcd`：

$a[1]=0$，因为规定为 $0$。

$a[2]=0$，因为 `ab` 无相等的真前缀和真后缀。

$a[3]=0$，因为 `abc` 无相等的真前缀和真后缀。

$a[4]=1$，因为 `abca` 相等的真前缀和真后缀最长为 `a`，长度为 $1$。

$a[5]=2$，因为 `abcab` 相等的真前缀和真后缀最长为 `ab`，长度为 $2$。

$a[6]=3$，因为 `abcabc` 相等的真前缀和真后缀最长为 `abc`，长度为 $3$。

$a[7]=0$，因为 `abcabcd` 无相等的真前缀和真后缀。

同理，字符串 `aabaaab` 的前缀函数为 `[0,1,0,1,2,2,3]`。

根据定义，我们可以写一个朴素做法，直接暴力求：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N];
int main()
{
	string s;
	cin>>s;
	int n=s.size();
	s=" "+s;
	for (int i=1; i<=n; i++)
	{
		for (int j=i-1;j>=0;j--)
		{
			if (s.substr(1,j)==s.substr(i-j+1,j))
			{
				a[i]=j;
				break;
			}
		}
	}
	for (int i=1; i<=n; i++)
	{
		cout<<a[i]<<" ";
	}
	return 0;
}
```

可是显然，此代码时间复杂度为 $O(n^3)$，特别慢。

考虑进行优化：

对栗子中的前缀函数进行观察，可以发现，**相邻的前缀函数最多增加 $1$**。并且只在 $s_{i+1}=s_{a_i}$ 时 $a_{i+1}=a_i+1$。

  优化后的代码：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int N=1e6+10;
  int a[N];
  int main()
  {
  	string s;
  	cin>>s;
  	int n=s.size();
  	s=" "+s;
  	for (int i=1; i<=n; i++)
  	{
  		for(int j=min(a[i-1]+1,i-1); j>=0; j--)
  		{
  			if (s.substr(1,j)==s.substr(i-j+1,j))
  			{
  				a[i]=j;
  				break;
  			}
  		}
  	}
  	for (int i=1; i<=n; i++)
  	{
  		cout<<a[i]<<" ";
  	}
  	return 0;
  }
  ```
  时间复杂度为 $O(n^2)$。
  
在上一个优化中，我们知道了在且只在 $s_{i+1}=s_{a_i}$ 时前缀函数才会增加 $1$，接下来，我们考虑其他情况时的取值。

![](https://cdn.luogu.com.cn/upload/image_hosting/vwxfp74u.png)
举个栗子，上图中 $a_n=5$，我们加入第 $n+1$ 位：
![](https://cdn.luogu.com.cn/upload/image_hosting/mfh7ii2n.png)
首先，我们先让 $s_{n+1}$ 与 $s_{a_n}$ 进行比较，发现不相等。

接下来，我们肯定要考虑仅次于 $a_n$ 的第二长度 $tmp$，使其满足前缀性质，也就是 $s[1...tmp]=s[n-tmp+1...n]$。
![](https://cdn.luogu.com.cn/upload/image_hosting/1sgri8fj.png)
如果找到了这样的 $tmp$，就比较 $s_{tmp+1}$ 与 $s_{a_n}$。如果相等，那么$a_{n+1}=tmp$，否则再重复上面的操作。
![](https://cdn.luogu.com.cn/upload/image_hosting/hkymcvtr.png)
我们可以发现，其实 $tmp$ 就是 $a_{a_n}$。因为 $s[a[n]-tmp+1...a[n]]=s[n-tmp+1...n]$，所以只在 $tmp=a_{a_n}$ 时，才有最大的 $tmp$ 使 $s[1...tmp]=s[a[n]-tmp+1...a[n]]=a[n-tmp+1...n]$。

因此，我们可以对代码再次进行优化：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N];
int main()
{
	string s;
	cin>>s;
	int n=s.size();
	s=" "+s;
	for (int i=2; i<=n; i++)
	{
		int tmp=a[i-1]+1;
		while(tmp>1&&s[i]!=s[tmp])
		{
			tmp=a[tmp-1]+1;
		}
		if(s[i]!=s[tmp])
		{
			tmp--;
		}
		a[i]=tmp;
	}
	for (int i=1; i<=n; i++)
	{
		cout<<a[i]<<" ";
	}
	return 0;
}
```
此时代码时间复杂度已经来到了 $O(n)$。

~~好的所以这跟 kmp 有什么关系呢？~~

设我们想在长度为 $m$ 的字符串 $s_1$ 中找到长度为 $n$ 的字符串 $s_2$ 的所以出现位置。

我们考虑构造一个字符串 $s_2+$`#`$+s_1$，其中 `#` 是一个不出现在 $s_1$ 也不出现在 $s_2$ 的字符。现在对此字符串跑一边前缀函数。可以发现，如果有 $k$ 使 $a_k=n$，$s_2$ 就在 $s_1$ 的 $k-(n+1)-n+1$ 处出现了一次。这样我们就在 $O(n+m)$ 的时间内解决该问题了。
![~~用一下oiwiki的图~~](https://oi-wiki.org/string/images/strstr_kmp_indices.svg)
### 代码
```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N<<1];
vector<int> ans;
int main()
{
	string s1,s2;
	cin>>s1>>s2;
	int n=s2.size();
	string k=s2+'#'+s1;
	int t=k.size();
	s1=" "+s1;
	s2=" "+s2;
	k=" "+k;
	for (int i=2; i<=t; i++)
	{
		int tmp=a[i-1]+1;
		while(tmp>1&&k[i]!=k[tmp])
		{
			tmp=a[tmp-1]+1;
		}
		if(k[i]!=k[tmp])
		{
			tmp--;
		}
		a[i]=tmp;
		if(a[i]==n)
		{
			ans.push_back(i-2*n);
		}
	}
	for(auto x:ans)
	{
		cout<<x<<'\n';
	}
	for(int i=1; i<=n; i++)
	{
		cout<<a[i]<<' ';
	}
	return 0;
}
```
其实因为 kmp 是在线算法，我们可以省去 $k$ 的空间。
```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
string s2,s1;
int a[N];
int main()
{
	int n,m;
	cin>>s1>>s2;
	n=s2.size();
	m=s1.size();
	s2=' '+s2;
	s1=' '+s1;
	for(int i=2,tmp;i<=n;i++)
	{
		tmp=a[i-1]+1;
		while(tmp>1&&s2[i]!=s2[tmp])
		{
			tmp=a[tmp-1]+1;
		}
		if(s2[i]!=s2[tmp])
		{
			tmp--;
		}
		a[i]=tmp;
	}
	for(int i=1,tmp=1;i<=m;i++)
	{
		while(tmp>1&&s1[i]!=s2[tmp])
		{
			tmp=a[tmp-1]+1;
		}
		if(s1[i]!=s2[tmp])
		{
			tmp--;
		}
		if(tmp==n)
		{
			cout<<i-n+1<<"\n";
			tmp=a[tmp];
		}
		tmp++;
	}
	for(int i=1;i<=n;i++)
	{
		cout<<a[i]<<" ";
	}
	return 0;
}
```

---

## 作者：ssy666666 (赞：1)

# KMP
## 算法介绍

KMP 是一种解决字符串单串匹配的算法。

KMP 主要运用了递归的思想。

在介绍 KMP 之前，先说一下朴素算法。我们可以枚举右端点，不断检查当前结点结尾的连续字串是否和匹配串相同，但这样的时间复杂度高达 $O(nm)$，会直接爆炸。

但我们发现这样做在检查上的时间复杂度就高达 $O(m)$，可以尝试优化。

KMP 的思路就是贪心的求当前结点为结尾的字符串可以对应的匹配串的最大前缀字串。

可以考虑递归求解。我们可以先处理匹配串如果匹配失败应跳转到哪里，以便进行下一次匹配，这被称为 Fail 指针。跳转的结点也应该是匹配串的最大前缀字串。但我们强行寻找以新的字符开头的字串在时间、空间上都没有优势，因此我们考虑能否从前一个字符的最大匹配字串转移过来。

首先，如果前一个字符的最大匹配字串的下一个字符和本字符相同，则已经找到最大匹配子串。

如果不同，则说明最大匹配子串在更前面，又因为前一个字符的 Fail 指针对应的前缀字串一定是比当前的前一个字符更小，但在所有可行的前缀字串中最大的，所以贪心地往前跳转 Fail 指针。

随后，我们再对原字符串进行匹配，找到它与匹配串的前缀相同的部分，并使它最大（这一步可以使用匹配串的 Fail 指针来寻找）。当这个前缀与匹配串相同，说明已经找到了符合条件的子串。

## 正确性证明
首先，由于我们寻找的字符串长度依次递减，每次都寻找比当前字串小的最大字串，所以不会重复、遗漏。

其次，当同时有多个前缀串匹配时，我们优先选择长度最长的串。这是因为更长的字串能更有机会匹配成功，且即使在多次向前推的过程中，短的串也是长的串的后缀。因为在当前状态下，短的子串是长的字串的后缀，而后续只是在两个串尾添加相同的字符，所以不会影响短串是长串的后缀。

在时间复杂度上，匹配串 Fail 指针初始化中，因为每次 Fail 指针最少向前跳一个，所以最多跳 $m$ 次，匹配时同理，所以时间复杂度为 $O(n+m)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

int fail[1000005];

int main()
{
	char a[1000005],b[1000005];
	scanf("%s",&a);
	scanf("%s",&b);
	
	int j=0;
	
	int e=0;

	int i;
	for(i=1,e=1;b[i]!=0;i++,e++)
	{
		while(j and b[j]!=b[i])
			j=fail[j-1];
			
		if(b[j]==b[i])
			j++;
		fail[i]=j;
	}
	
	j=0;
	for(i=0;a[i]!=0;i++)
	{
		if(a[i]==b[j])
			j++;
		else
		{
			while(j and a[i]!=b[j])
				j=fail[j-1];
				
			if(b[j]==a[i])
				j++;
		}
		
		if(j==e)
		{
			printf("%d\n",i-j+2);
			j=fail[j-1];
		}
	}
	for(int i=0;b[i]!=0;i++)
		cout<<fail[i]<<" ";
	return 0;
}
```

---

## 作者：liangbob (赞：0)

# KMP 字符串匹配算法

> 一个人最可悲的地方不在于失败，而在于失败后，不去尝试找回曾经的自己而是直接推倒重来。—— KMP

## 定义

- $s(i)$ 为字符串 $s$ 从左往右第 $i$ 个字符，$s(l,r)$ 为 $s$ 从左往右第 $l$ 个字符到从左往右第 $r$ 个字符所构成的子串。

  例：设 `s="abcdefg"`，则 $s(2)$ 为 `b`，$s(3,5)$ 为 `cde`。

- $t$（长度为 $m$）的最长前后缀长度的定义：使得 $t(1,k)$ 与 $t(m - k + 1, m)$ 相等的最大 $k$ 值（$k \neq m$）。前后缀也称为 border。

- 长度为 $j$ 的前缀指 $s(1,j)$，假设 $s$ 长度为 $k$，则长度为 $j$ 的后缀指 $s(k - j + 1, k)$。

- 本文代码如无特殊说明，默认已经执行过：

  ```cpp
  cin >> (a + 1) >> (b + 1);
  n = strlen(a);
  m = strlen(b);
  ```

## 算法介绍

### 引入：抽象的暴力算法形式

KMP 所解决的问题非常简单：给定主串 $A$，模式串 $B$，问 $B$ 在 $A$ 中：

- 出现了多少次？
- 出现在什么位置上？

这个问题暴力做非常简单，上代码：

```cpp
for(int i = 1;i + m - 1 <= n;i++)
{
    bool ok = 1;
    for(int j = i;j <= i + m - 1;j++)
    {
        if(a[i] != b[j])
        {
            ok = 0;
            break;
        }
    }
    if(ok) /*在位置 i 上匹配到，进行处理*/
}
```

这个暴力做法很显然，接下来我们对它进行一些改动，以便于为下文的 KMP 算法做铺垫。

改动一：把 $i$ 改成指针的形式，并修改定义。

我们定义 $i$ 不再是子串的第一个字符的位置，而是子串最后一个字符的位置。

```cpp
int i = 0;
while(i <= n)
{
    if(i - m + 1 < 1) continue;
    bool ok = 1;
    for(int j = i - m + 1;j <= i;j++)
    {
        if(a[i] != b[j])
        {
            ok = 0;
            break;
        }
    }
    if(ok) /*在位置 i 上匹配到，进行处理*/
    i++;
}
```

改动二：把 $j$ 也改成指针的形式，并修改定义

$j$ 代表：$a(i - j + 1,i)$ 与 $b(1,j)$ 完全相等。

注意到此时我们就需要让 $i$ 和 $j$ 同步变化，也就是说，当 $a(i + 1)$ 等于 $b(j + 1)$ 时，$i$ 和 $j$ 各加上 $1$，这样子才能保持 $i$ 和 $j$ 的定义，建议手推一下以更好的理解。

```cpp
int i = 0, j = 0;
while(i < n && j < m)
{
    if(a[i + 1] == b[j + 1])
    {
        i++;
        j++;
    }
    else
    {
        i = i + 2 - j;
        j = 0;
    }
    if(j == m)
    {
        /*在 i + 1 - m 上匹配到*/
        j = 0;
    }
}
```

算法流程大致如下：

- 如果 $a(i + 1)$ 和 $b(j + 1)$ 相等，说明可以继续匹配下去，各加上 $1$。
- 如果不相等，说明匹配不下去了，$j$ 直接跳回 $0$，$i$ 回到最开始的地方的下一位（也就是 $i - j +1 +1 = i-j+2$，因为你现在匹配了 $j$ 位，跳回去就是 $i -j + 1$，它的下一位就是 $i - j + 1+ 1$）。
- 如果 $j=m$，说明匹配成功，将 $j$ 设为 $0$，从当前的 $i$ 开始继续匹配（因为很可能会匹配多次，从 $i$ 开始是因为前面都已经匹配过了）。

这个算法的复杂度为 $O(nm)$，有点慢，慢在哪呢？

### 优化：KMP 算法

这个时候 K、M、P 三个人站了出来：慢在让 $i$ 直接跳回去！

他们说，本来前面就已经匹配了那么多，现在一匹配不下去就要舍弃前面所有的匹配成果重新再来，这也太浪费了！

怎么办？他们提出了一个大胆的想法：**让 $i$​ 不跳**。

你可能会说，$i$ 不跳？那这样不就无法保证匹配了吗？

别急，你想想，$i$ 动不了，我们是不是可以通过调整 $j$，来使得在 $i$ 不变的前提下，其依旧满足呢？注意，$j$ 调整后要尽量大哦。（如果小的话跟直接调成 $0$ 就没啥区别了）

显然可以，这就是 KMP 算法的核心：**通过调整 $j$，使得在 $i$ 不变的前提下，$i$ 和 $j$ 依旧满足定义**。

显然，$j$ 一定是变小的，因为变大的话，无法保证匹配。（本来下一位就无法保证匹配了，现在你还变大，相当于给后面可能无法匹配的位置强行搞成匹配）

KMP 提出了一个 $\text{next}(i)$ 数组，他发现，这个数组与 $A$ 无关，它的基本定义为：

> 当第 $i$ 位可以匹配，第 $i + 1$ 位无法继续匹配时，在 $j$ 继续符合定义，即 $a(i - j + 1,i)$ 与 $b(1,j)$ 完全相等的情况下，能调整到的最大的 $j$ 是多少？

KMP 算法和上面所讲的暴力算法非常类似，过程如下：

- 如果 $a(i + 1)$ 和 $b(j + 1)$ 相等，说明可以继续匹配下去，各加上 $1$。
- 如果不相等，说明匹配不下去了，$j$ **跳回 $\text{next}(j)$**，$i$ **不变**。
- 如果 $j=m$，说明匹配成功，将 **$j$ 设为 $\text{next}(j)$**（因为很可能会匹配多次）。

这里无非就是把“跳回 $0$”这个动作改成了“跳回 $\text{next}(j)$”，并让 $i$ 保持不变，这样的好处就在于，匹配失败一个位不会立刻推倒重来，而是会跳到先前的一部继续匹配。

代码实现时需要注意：由于第二步 $i$ 不变，因此可以进行一个小小的改动：

- 如果 $a(i +1)$ 和 $b(j + 1)$ 不相等，一直让 $j=\text{next}(j)$，直到 $j = 0$ 或相等为止。

下文的代码、论述都称 $\text{next}$ 数组为 $p$ 数组。

由于不相等时总是会回到第二步，相当于一个循环，因此这个改动是正确的，代码如下：

```cpp
while(j > 0 && b[j + 1] != a[i + 1]) j = p[j];
```

综合其它两步，实现如下：

``` cpp
while(j > 0 && b[j + 1] != a[i + 1]) j = p[j];
if(a[i + 1] == b[j + 1])
{
    i++;
    j++;
}
if(j == m)
{
    /*i - m + 1 上可以匹配到*/
    j = p[j];
}
```

是不是和暴力很相似？没错，KMP 和暴力的唯一不同就在于**使用了 $\text{next}$ 数组避免了反复推倒重来所带来的无谓的时间消耗**。

最后注意到 `i++` 可以放到代码的末尾，这样子我们就可以把代码简化成 for 循环了，但需要注意：$j=m$ 时，匹配位置的 $i$ 改之后会少掉一，因此答案就需要加上一个一，具体看代码：

```cpp
int j = 0;
for(int i = 0;i < n;i++)
{
    while(j > 0 && b[j + 1] != a[i + 1]) j = p[j];
    if(a[i + 1] == b[j + 1]) j++;
    if(j == m)
    {
        /*i - m + 2 上可以匹配到*/
        j = p[j];
    }
}
```

问题又来了，$\text{next}$ 数组怎么求呢？

### $\text{next}$ 数组的新定义

看图说话：

![如果看到这行字，请私信我。](https://cdn.luogu.com.cn/upload/image_hosting/ag9wlwgz.png)

### $\text{next}$ 数组的计算方式

下文代码默认已经执行过：

```cpp
strcpy(s, b);
```

并在下文中令 $s=b$。

我们不妨来举个例子：

$$\large{\mathtt{ABACABAB}}$$

我们刚刚已经证明，$p_i$ 的定义为：

> $p_i$ 代表 $s(1,i)$ 的最长前后缀的长度。

也就是说，我们要去获取 $1\le i \le n$ 中 $s(1,i)$ 这个子串的最长前后缀长度。

怎么求？我们可以一位一位地去求。具体地，不妨假设 $s(1,i-1)$ 的最长前后缀长度为 $j$，也就是说当前匹配了 $j$ 位的前后缀，那么如果 $s(i) = s(j + 1)$，$s(1,i)$ 的最长前后缀的长度就是 $j+1$，如下图：

![如果看到这行字，请私信我。](https://cdn.luogu.com.cn/upload/image_hosting/mzf3a0l6.png)

为了防止 $i-1$ 下标越界，在写代码时，我们可以将上面的话换一种表达方式：设 $s(1,i)$ 的最长前后缀长度为 $j$，那么如果 $s(i + 1) = s(j + 1)$ ，$s(1,i+1)$ 的最长前后缀的长度就是 $j+1$。写成代码大概长这样：

```cpp
for(int i = 1;i < m;i++)
{
    if(s[i + 1] == s[j + 1]) j++;
    p[i + 1] = j;
}
```

那么如果不同呢？如果 $s(i + 1) \neq s(j+1)$ ，那么是不是意味着我们就要重头再次开始匹配，也就是让 $j = 0, i = 1$ 呢？

当然不是！前面匹配了那么多肯定不能白费，既然前后缀长度为 $j$ 无法继续匹配，那么我们就去找 $s(1,j)$ 的最长前后缀。由于 $s(1,j) = s(i - j + 1,i)$，那么这个最长前后缀其实就是 **$s(1,j)$ 的前缀与 $s(i - j + 1,i)$ 的后缀的不包括它们本身的最长公共串！**（你可以把 $s(i - j + 1,i)$ 的后缀看成是 $s(1,j)$ 的后缀）

那么既然它们是公共的，也就是说它就是前后缀，只不过不是最长的而已，是第二长，第一长是 $s(1,j)$。

那么让 $j$ 等于它继续匹配即可，因为它刚好是第二长，而又由于第一长匹配不下去，那么它继续匹配下去必然是最长前后缀。

当然，如果第二长的也匹配不下去，那就换成第二长的最长前后缀，也就是第三长的继续匹配，理由同上。

那么我们就只需要当下一位（$s(i + 1)$  和 $s(j+1)$）匹配不上时，不断地使 $j=p(j)$，找到可以匹配的那个 $j$ 就可以啦！写成代码就是：

```cpp
for(int i = 1;i < m;i++)
{
    while(j > 0 && s[i + 1] != s[j + 1]) j = p[j];
    if(s[i + 1] == s[j + 1]) j++;
    p[i + 1] = j;
}
```

然后 $p$ 数组就被求出来啦！注意，$j$ 的初值是 $0$ 哦！

## 正确性证明

我们需要证明这个算法两方面的正确性：答案正确和时间复杂度正确。

关于答案正确，我们在上面的叙述中天然地体现了算法的答案正确，这里不再赘述。

接下来我们分析这个算法的时间复杂度。这里先给出结论：$O(n+m)$。

考虑匹配操作的复杂度。观察到 $i$ 只会增加 $n$ 次 $1$，因此单看 $i$ 的操作复杂度为 $O(n)$。

现在我们来看 $j$，其实 $j$ 只会被进行两种操作：

- $j = p_j$，不妨设这种操作被执行了 $p$ 次。
- $j = j + 1$，不妨设这种操作被执行了 $q$ 次。

设操作完之后 $j=r$。显然此时 $0 \le r \le n$。

第一种操作，每次必然让 $j$ 减少至少 $1$，因此 $r \le q-p$。

第二种操作，至多进行 $n$ 次，因此 $0 \le q \le n$​。

假设 $q-r > n$，此时 $q>r+n\ge n$，$q>n$，矛盾。

因此，$q-r \le n$，即 $p\le q-r \le n$。

$j$ 总共会进行 $p+q \le 2n$ 次操作，因此单看 $j$ 的操作复杂度为 $O(n)$，因此匹配操作的复杂度为 $O(n)$。

由于计算 $p$ 数组的代码本质上相当于自己和自己匹配，因此同理，复杂度为 $O(m)$。

综上，算法的总复杂度为 $O(n+m)$。

## 代码实现

```cpp
//计算 b 的 p 数组
for(int i = 1;i < m;i++)
{
    while(j > 0 && b[i + 1] != b[j + 1]) j = p[j];
    if(b[i + 1] == b[j + 1]) j++;
    p[i + 1] = j;
}

int j = 0;
for(int i = 0;i < n;i++)
{
    while(j > 0 && b[j + 1] != a[i + 1]) j = p[j];
    if(a[i + 1] == b[j + 1]) j++;
    if(j == m)
    {
        /*i - m + 2 上可以匹配到*/
        j = p[j];
    }
}
```

---


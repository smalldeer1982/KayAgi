# [CERC2019] ABB

## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[ABB](https://contest.felk.cvut.cz/19cerc/solved/abb.pdf)」**

## 题目描述

Fernando 受雇于滑铁卢大学，负责完成该大学不久前开始的一个开发项目。在校园外，该大学希望为重要的外国游客和合作者建造具有代表性的平房街。

目前，这条街只建了一部分，它从湖岸开始，一直延伸到森林尽头。Fernando 的任务是通过在森林尽头建造更多的平房来完成这条街。所有现有的平房都坐落在街道的一侧，新的平房应该建在同一侧。这些平房有各种各样的类型，漆成各种各样的颜色。

在 Fernando 看来，整条街的布局有点混乱。他担心增加新平房后，它会看起来更加混乱。所以他想通过为新平房选择合适的颜色来增加一些排列顺序。当项目完成时，平房的整个颜色序列将是对称的，也就是说，从街道的两端观察时，颜色序列是相同的。

在其他问题中，Fernando 想知道，在满足平房颜色限制的情况下，他最少需要用来建造和适当染色才能完成项目的新平房数量。

### 简要题意

求使给定小写字母字符串成为回文串需在字符串末尾加入字母的最少数量。

## 样例 #1

### 输入

```
3
abb
```

### 输出

```
1
```

## 样例 #2

### 输入

```
12
recakjenecep
```

### 输出

```
11
```

## 样例 #3

### 输入

```
15
murderforajarof
```

### 输出

```
6
```

# 题解

## 作者：ZHR100102 (赞：18)

# 哈希

## 思路

显然正着做一遍哈希，倒着做一遍哈希，然后枚举回文中心即可。

时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;
const int N=400005;
const ull base=13331;
ull phash[N],shash[N],pw[N];
int n,ans;
char s[N];
void dohash()
{
    pw[0]=1;
    for(int i=1;i<N;i++)pw[i]=pw[i-1]*base;
    for(int i=1;i<=n;i++)phash[i]=phash[i-1]*base+s[i];
    for(int i=n;i>=1;i--)shash[i]=shash[i+1]*base+s[i];
}
ull gethash(int op,int l,int r)
{
    if(op==0)return (phash[r]-phash[l-1]*pw[r-l+1]);
    return (shash[l]-shash[r+1]*pw[r-l+1]);
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>s+1;
    ans=n-1;
    if(n==1)
    {
        cout<<0;
        return 0;
    }
    dohash();
    for(int i=1;i<=n;i++)
    {
        if(i-1>=n-(i+1)+1)
        {
            int len=n-(i+1)+1;
            if(gethash(0,i-1-len+1,i-1)==gethash(1,i+1,i+1+len-1))
            {
                ans=min(ans,i-1-len);
            }
        }
        if(i>=n-(i+1)+1)
        {
            int len=n-(i+1)+1;
            if(gethash(0,i-len+1,i)==gethash(1,i+1,i+1+len-1))
            {
                ans=min(ans,i-len);
            }
        }
    }
    cout<<ans;
    return 0;
}
```

哈希的代码又臭又长，肯定不是这题的最优解。

# KMP

## 思路

我们考虑这题要求的本质是什么，显然是求字符串 $s$ 最长的回文后缀的长度 $l$，那么答案就是 $n-l$。因为剩下的那些必须对称过去。

那么如何求最长的回文后缀呢？我们可以先把字符串 $s$ 反转为 $s'$，把后缀转化为前缀便于处理。

由于回文串正着读和反着读都一样，可以发现回文后缀满足**是字符串 $s'$ 的一段前缀，也是字符串 $s$ 的一段后缀**。

因此如果字符串 $s'$ 的一段前缀与字符串 $s$ 的一段后缀相等，就说明这是一个合法的回文后缀。

如果要让这个后缀最长，那么显然是 KMP 的 $next_n$，就求出来了。

实现上，我们可以将最后的主串设置为 $s'$ 与任意一个分隔符与 $s$ 拼接起来的字符串，然后做一遍 KMP 即可。


时间复杂度 $O(n)$。

## 代码

非常简短，注意字符串开两倍的长度。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=800005;
int n,ne[N];
char s[N];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>s+n+2;
    s[n+1]='%';
    for(int i=1,j=2*n+1;i<=n;i++,j--)s[i]=s[j];
    int now=0;
    for(int i=2;i<=2*n+1;i++)
    {
        while(now&&s[now+1]!=s[i])now=ne[now];
        if(s[now+1]==s[i])now++;
        ne[i]=now;
    }
    cout<<n-ne[2*n+1];
    return 0;
}
```

---

## 作者：llxsmy_forever (赞：8)

## 题目描述
给定一个字符串，问至少要在字符串末加多少个字符，使原串变成回文串。

## Solution
看完题后再分析一下样例，很容易想到一个贪心策略，就是找出包含最后一个字符的最长回文子串，再在字符串末加字符以匹配不包含在最长回文子串的字符，这样便可以使所加字符数最少了。

那怎么求最长回文子串呢？注意这里的最长回文字串是要包含最后一个字符的，说明右端点已经确定了，那我们只需要枚举左端点，再判定这是否是一个回文子串就好了。这里用哈希来判定回文子串。

## Code
```cpp
#include<bits/stdc++.h>
//unsigned long long 自动溢出，不用手动取模
#define ull unsigned long long
using namespace std;
const int N=4e5+100;
const ull base=13331;
ull h1[N],h2[N],p[N];
char s[N];
ull get1(int l,int r){return h1[r]-h1[l-1]*p[r-l+1];}
ull get2(int l,int r){return h2[l]-h2[r+1]*p[r-l+1];}
int main(){
	int n;scanf("%d",&n);
	scanf("%s",s+1);
	h1[0]=h2[0]=0,p[0]=1;
	for(int i=1,j=n;i<=n;i++,j--){
    //正着求一次，反着求一次
		h1[i]=h1[i-1]*base+s[i]-'a';
		h2[j]=h2[j+1]*base+s[j]-'a';
		p[i]=p[i-1]*base;
	}
	for(int i=1;i<=n;i++){
		int m1=i+n>>1,m2=(i+n&1)?m1+1:m1;
        //从小到大枚举，第一个符合的一定是最长的回文子串
		if(get1(i,m1)==get2(m2,n)){
			printf("%d",i-1);
			break;
		}
	}
	return 0;
}
```


---

## 作者：CNCAGN (赞：8)

## 题目描述
给定一个字符串，问至少要在字符串末加多少个字符，使原串变成回文串。

## Solution
首先分析一个回文的情况，有两种情况：

1. 以一个字符为中心，左右对称。
2. 以两个相同字符为中心，左右对称。

而最终字符串的对称中心肯定位于原串，所以我们分别考虑这两种情况，枚举对称中心，判断是否合法即可，图解如下:

情况1：![](https://cdn.luogu.com.cn/upload/image_hosting/xofwj2f2.png)

情况2：![](https://cdn.luogu.com.cn/upload/image_hosting/3w51k8kt.png)

可以看到，从对称中心到末尾这一段的长度必然为原有的回文子串长度的一半（在前半段和后半段合起来为回文的情况下），所以我们就可以使用哈希判断选择位置 $i$ 是否合法。对于程序，我的解法是建了一个反串的哈希数组。

## code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<stack>
#include<cstring>
#include<string>
#include<functional>
#include<map>
using namespace std;
int red() {
	int op = 1, x = 0;
	char ch = getchar();
	while(!isdigit(ch)) {
		if(ch == '-') {
			op = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)) {
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * op;
}
typedef unsigned long long ull;
const int maxn = 4e5 + 10;
ull power[maxn];
ull hh[maxn];
ull rehh[maxn];
char s1[maxn];
ull base = 131;
ull get_hash(int l, int r) {
	return hh[r] - hh[l - 1] * power[r - l + 1];
}
ull get_hash2(int l, int r) {
	return rehh[r] - rehh[l - 1] * power[r - l + 1];
}
int len;
bool check(int i) {
	if(i < 1 || i > len) {
		return true;
	}
	return false;
}
int main() {
	red();
	cin>> s1 + 1;
	len = strlen(s1 + 1);
	power[0] = 1;
	int n = len;
	
	for(int i = 1; i <= n; ++i) {
		power[i] = power[i - 1] * base;
		hh[i] = hh[i - 1] * base + s1[i];
	}
	for(int i = n; i >= 1; --i) {
		rehh[n - i + 1] = rehh[n - i] * base + s1[i];
	}
	int minans = 0x3f3f3f3f;
	for(int i = 1; i <= n; ++i) {
		int tlen = n - i;
		int l1 = i - tlen, r1 = i - 1;
		int l2 = 1, r2 = tlen;
		if(check(l1) && check(l2) && check(r1) && check(r2)) {
			continue;
		}
		if(l2 > r2 || l1 > r1) {
			continue;
		}
		if(get_hash(l1, r1) == get_hash2(l2, r2)) {
			minans = min(minans, n - (tlen * 2 + 1));
		}
	}
	for(int i = 2; i <= n; ++i) {
		int tlen = n - i + 1;
		int r1 = i - 1;
		int l2 = 1;
		int r2 = tlen;
		int l1 = i - tlen;
		if(check(l1) && check(l2) && check(r1) && check(r2)) {
			continue;
		}
		if(l2 > r2 || l1 > r1) {
			continue;
		}
		if(get_hash(l1, r1) == get_hash2(l2, r2)) {
			minans = min(minans, n - (tlen * 2));
		}
	}
	if(minans == 0x3f3f3f3f) {
		minans = n - 1;
	}
	
	cout << minans << endl;
	return 0;
}

```


---

## 作者：封禁用户 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P9606)

# 题意

给你一个字符串，让你添加字符，让他变成回文串，求至少添加几个。

# 思路

正常来讲，把原字符串反转后拼接，就是回文串，比如样例

```
3
abb
```
在 `abb` 后面拼接 `bba` 就可以成为回文串，但是中间有部分回文串重复了，于是就要求最长回文串，这不就是 `Manacher` 吗？

但其实这题没卡 `hash` 和 `KMP`，所以也可以做，只不过我第一个想到 `Manacher`。

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
char s[2000005], st[2000005];
ll n, m, T, h[2000005], kkk, mid, mr;
int main(){
	scanf ("%lld", &n);
	scanf ("%s", st);
	n = strlen(st);
	for (int i = n; i >= 1; i--) st[i] = st[i - 1];
	for (int i = 1; i <= n; i++) s[i * 2] = st[i], s[i * 2 + 1] = '#';
	s[0] = s[1] = '#';
	s[2 * n + 2] = '\0';
	mid = 0;
	mr = -1;
	n = 2 * n + 1;
	for (int i = 1; i <= n; i++) h[i] = 0;
	for (int i = 2; i <= n; i++){
		if (mr > i) h[i] = min(h[2 * mid - i], mr - i);
		else h[i] = 1;
		while (s[i - h[i]] == s[i + h[i]]) h[i]++;
			if (i + h[i] > mr)
			mr = i + h[i], mid = i;
	}
	ll ans = 0;
	n = (n - 1) >> 1;
	for (int i = 1; i <= n; i++)
		if (i + (h[2 * i] >> 1) - 1 >= n)
			ans = max(ans, h[2 * i] - 1);
	for (int i = 1; i < n; i++)
		if (i + (h[2 * i + 1] >> 1) >= n)
			ans = max(ans, h[2 * i + 1] - 1);
	printf ("%lld", n - ans);
	return 0;
}
```

---

## 作者：2018g20 (赞：4)

## [传送门](https://www.luogu.com.cn/problem/P9606)

## 题面简述：

给定一个字符串，问至少要在字符串末加多少个字符，使原串变成回文串。

## 思路：

### 为什么找后缀的回文：

显然，加的字符数量不会超过原串的长度（任何串倒序复制一遍以合法的）。

由于最后的字符串是回文的，所以回文中心要么在原串中，要么在原串和添加串之间。

![](https://cdn.luogu.com.cn/upload/image_hosting/ftv2se44.png)

如图，因为回文中心在原串中，所以它在原串中必定会有回文串（用绿色表示），这就是后缀的回文。

---

### 为什么找最长的回文：

黄色和绿色部分表示回文串

![](https://cdn.luogu.com.cn/upload/image_hosting/6hbhrsqq.png)

如图，找的回文越长，修改后的串越短。而且我们还知道了，问题的答案就是$黑色串的长度=原串长度-最长后缀回文长度$。于是问题就变成了求最长后缀回文长度。

---

### 怎么找最长回文：

考虑到 manacher 记录的是到当前最长的回文串长度，用 $f(i)$ 表示，并没有保证是后缀。

_~~**最妙的来了**~~_

我们把字符串倒序（相当于从后往前做 manacher），这时，$f(i)=i+1$ 是**目前最长回文是后缀的**的充要条件（$i$ 从 $0$ 开始）。这是因为如果 $f(i)=i+1$ 则说明目前最长回文是从 $0$ 开始到 $i$ 的，由于是倒序的，所以它是后缀的。

---

## 献上代码：

```cpp
#include<iostream>
using namespace std;
int n,len,maxx;
int f[4000005];
string ss;
char s[8000005];
int main()
{
	cin>>len>>ss;
	n=(len<<1)+1;
	for(int i=0,j=len-1;i<n;i++) s[i]=i&1?ss[j--]:'#';
	for(int i=0,c=0,r=0;i<n;i++)
	{
		f[i]=r>i?min(f[(c<<1)-i],r-i):1;
		while(i-f[i]>=0&&i+f[i]<n&&s[i-f[i]]==s[i+f[i]]) f[i]++;
		if(i+f[i]>r) r=i+f[i],c=i;
		if(f[i]==i+1) maxx=f[i]-1;
	}
	cout<<len-maxx;
}
```
完结撒花~

---

## 作者：翟翟 (赞：3)

题目可以转化为求最长回文子串，答案就是长度减去最长回文子串的长度。看到是求最长回文子串，一眼就容易想到马拉车。但对于这种有固定起点的求最长回文子串，我们可以使用哈希。

对于字符串哈希，见 P3370。

哈希的过程就是从后往前，记录两个哈希变量，正反方式一样，若数值相同则为回文串。

```
#include<cstdio>
const int b=100039,mod=1e9+7;
int n,ans;
long long x,y,f=1;
char s[400001];
int main(){
	scanf("%d%s",&n,s);
	for(int i=n-1;~i;--i){
		(f*=b)%=mod;
		(x+=f*(s[i]-'a'))%=mod;//从后往前
		((y+=(s[i]-'a'))*=b)%=mod;//从前往后
		if(x==y)ans=i;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Liyuqiao11 (赞：2)

这道题是个很经典的题，但是它卡模数，如果被卡了可以把 base 换成 $ 13331 $ ,把模数换成自然溢出。首先我们看到此题要我们求使给定小写字母字符串成为回文串需在字符串末尾加入字母的最少数量，不难发现最多加 $ | s | $ 个字符，其中 $| s | $ 是字符串的长度。所以我们会很自然的想到枚举加 $ x $ 个字符。然而怎么判断加了几个字符后是不是回文串呢？这个时候我们发现如果后 $ |s-x| $ 个字符构成回文串的话，那这个字符串就是回文串。此时我们可以想到用哈希来判断这个字符串是不是回文串。我们先从头到尾算一遍哈希值，再反过来求一遍哈希值。这样就可以判断它是不是回文串了。码风可能不是很好，请大家见谅。
```c
#include<bits/stdc++.h>
using namespace std;
const int N = 4e5+10,B = 13331;
#define int unsigned long long
int n,h[N],p[N],h2[N],ans;
char s[N];
signed main(){
    cin>>n;
    p[0]=1;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        h[i]=h[i-1]*B+s[i];
        p[i]=p[i-1]*B;
    }
    for(int i=1;i<=n;i++){
        h2[i]=h2[i-1]*B+s[n-i+1];
    }
    for(int i=n;i>=1;i--){
        int dc=n-i;
        int l=h[n]-h[dc]*p[i];
        int len=i/2;
        int f=h[dc+len]-h[dc]*p[len];
        int q=h2[len];
        if(f==q){
            ans=i;
            break;
        }
    }
    cout<<n-ans<<endl;
    return 0;
}
```


---

## 作者：Camellia_Spoil (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9606)
# 题意
给你一个字符串，求最少在末尾添加多少个字符使得这个字符串是回文的。
# 思路
此题使用 Manacher 算法！

此题只需在求出回文半径的基础上储存回文串的右端点，将求出的右端点排序，只要右端点不在最后的字符就结束（不能补），如果在最后的字符就取原字符串长度与当前回文子串的差值的最小值（需要补的字符个数）。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 41111111
char a[N],s[N];
struct node{
	int x,re;
}d[N]; 
int cmp(node a,node b){
	return a.re>b.re;
}
int main(){
	int len,k=0;
	cin>>len;
	scanf("%s",a);//读入 
	s[0]='$';//边界 
	s[++k]='#';
	for(int i=0;i<len;i++){
		s[++k]=a[i];s[++k]='#';
	}//修改字符串                        
	int n=k,l,r=1,mi=1e9;
	d[1].x=1;//赋初值 
	for(int i=2;i<=n;i++){
		if(i<=r) d[i].x=min(d[r-i+l].x,r-i+1);
		while(s[i-d[i].x]==s[i+d[i].x]) d[i].x++;
		if(i+d[i].x-1>r){l=i-d[i].x+1;r=i+d[i].x-1;}
		d[i].re=r;
   }//求回文半径，并记录右端点 
	sort(d+1,d+n+1,cmp);//按右端点以大到小排序 
	for(int i=1;i<=n;i++){
		if(d[i].re!=n) break;                               
		mi=min(mi,len-(d[i].x));//求需要补的字符的最小值 
	}
	cout<<mi+1;//输出 
	return 0;
}
```


---

## 作者：fangzichang (赞：2)

题意：给一个长度为 $n$ 的全小写字母组成的字符串 $s$，你需要在 $s$ 的最后加上尽量少的小写字母使得 $s$ 成为回文串，求最少加上多少字母。  

---
简单题，为了让它评分下降而写了这样一篇题解。  
假设最后答案为 $k$，先给出结论：$k=n-len$，其中 $len$ 表示 $s$ 的最长回文**后缀**的长度。  
然后简单证明这个结论。  

先证明充分性。  
考虑一个简单的事实：一个字符串 $str$ 后连上一个回文串，在这个回文串后连上 $str$ 前后反转后的字符串 $str'$，显然最终结果还是回文字符串。  
然后假设我们找到了字符串 $s$ 的一个回文后缀，假设这个后缀长度为 $len'$，则将 $s$ 的前 $n-len'$ 个字符组成的字符串反转后放到 $s$ 的末尾，最终结果为回文字符串。  
显然 $len'$ 大的时候 $n-len'$ 小，$len'=len$ 即该回文后缀为最长回文后缀的时候 $n-len'$ 取到最小值。  
因此 $k \le n-len$。  

再证明必要性。  
假设存在比 $n-len$ 更小的答案 $k'$，由上面的简单事实可以发现，将 $s$ 的前 $k'$ 个字符去掉后的字符串为回文串。这样这个回文串长度为 $n-k'$ 且这个回文串为 $s$ 的后缀。  
然而我们刚刚的定义是 $len$ 为 $s$ 的最长回文后缀的长度，在这种情况下易得 $n-k'>len$，矛盾。  

因此原命题得证。  

然后就很简单了。枚举所有后缀，直接哈希判定是不是回文后缀，若是则刷新最长回文后缀长度，然后计算即可。  
```cpp
int n;
char ch[N];
ull h[2][N],d[N];
ull get(int l,int r,bool flg){
	if(!flg) return h[0][r]-h[0][l-1]*d[r-l+1];
	else return h[1][l]-h[1][r+1]*d[r-l+1];		
}
bool check(int l,int r){
	if(l>r) return 0;
	else if((r-l+1)&1) return get(l,((l+r)/2)-1,0)==get(((l+r)/2)+1,r,1);
	else return get(l,(l+r)/2,0)==get(((l+r)/2)+1,r,1);
}
int main(){
	d[0]=1;
	for(int i=1;i<N;i++) d[i]=d[i-1]*base;
	cin(n);
   	scanf("%s",ch+1);
	ch[0]='#';
	for(int i=1;i<=n;i++) h[0][i]=h[0][i-1]*base+ch[i];
	for(int i=n;i>=1;i--) h[1][i]=h[1][i+1]*base+ch[i];
	f[1]=1;
	int ans=0;
	for(int i=n;i>=1;i--){
		if(check(i,n)) ans=max(ans,(n-i+1));
	}
	print(n-ans);
	putchar(endl);
	return 0;
}
```




---

## 作者：FallingFYC_ (赞：1)

[原题](https://www.luogu.com.cn/problem/P9606)

Manacher 算法！

---
### 分析&思路

由于只能在最后添加，那么如果字符串的最后一个字符包括在最长回文子串中，只需要将最长回文子串前的字符添加到后面即为最优方案。否则就需要将除最后一个字符意外的所有字符都添加到最后。

看到回文串，就能想到 Manacher 算法，如下是我写的模版代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
char c[22000005];
string s;
int len , p[22000005] , maxx , maxid , ans;
int main()
{
    cin >> s;
    
    len = s.length();
    c[0] = '@'; 
    for (int i = 0 ; i <= len ; i++)
    {
        c[2 * i + 2] = s[i];
        c[2 * i + 1] = '#';
    }
    
    for (int i = 0 ; i <= 2 * len + 1 ; i++)
    {
    	p[i] = (maxx > i ? min(p[2 * maxid - i] , maxx - i) : 1);
    	while (c[i - p[i]] == c[i + p[i]]) p[i]++;
		if (i + p[i] > maxx) {maxx = i + p[i]; maxid = i;}	
        ans = max(ans , p[i] - 1);
	}
	cout << ans;
    return 0;
}
```

其中，变量 `maxid` 存储的是 `maxx` 最大时的位置。而 `maxx` 表示 `p` 数组下标在 `i` 之前的最大值。

因此若字符串的最后一个字符包括在最长回文子串中，`maxid` 存储的就是最长回文子串的中点。否则就是最后一个字符的下标（可以自己试试）。

用两个变量分别从 `maxid` 两边遍历字符，如果两边的字符相同，就不用添加到右边，否则或者遍历到最右边了，那么就需要添加到最右边。这刚好和如上的最优方案相同。

---
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 4e5;
char c[MAXN << 1 + 5];
string s;
int n , p[MAXN << 1 + 5] , maxx , maxid , ans;
int main()
{
    cin >> n >> s;
    
    c[0] = '@'; 
    for (int i = 0 ; i <= n ; i++)
    {
        c[2 * i + 2] = s[i];
        c[2 * i + 1] = '#';
    }
    
    for (int i = 0 ; i <= 2 * n + 1 ; i++)
    {
    	p[i] = (maxx > i ? min(p[(maxid << 1) - i] , maxx - i) : 1);
    	while (c[i - p[i]] == c[i + p[i]]) ++p[i];
		if (i + p[i] > maxx) {maxx = i + p[i]; maxid = i;}	
	}
    for (int i = maxid - 1 , j = maxid + 1 ; i >= 1 ; i-- , j++)
        if (j > 2 * n + 1 || c[i] != c[j]) ++ans;
    cout << (ans >> 1); //由于要把奇回文变成偶回文，在每个字符前都加上了一个占位的字符，需要除去。
    return 0;
}
```

---

## 作者：Union_Find (赞：0)

题意是说，在一个字符串后面加上一些字符，使得这个字符串是回文串，求至少添加几个字符。

其实这道题就是求最大后缀回文串，可以用 `Manacher` 直接做，但是这题可以用 `hash` 做。

我们先求出正的 `hash` 值，再倒着求一遍，枚举半径长度，再用 $O(1)$ 的时间判断是否可行，总共 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll unsigned long long
#define il inline
char s[800005];
ll n, h[400005], base = 137, f[400005], hh[400005];
il ll hashh(ll l, ll r){
	return h[r] - h[l - 1] * f[r - l + 1];
}
il ll hashhh(ll l, ll r){
	return hh[l] - hh[r + 1] * f[r - l + 1];
}
il bool check(ll x){
	if (hashh(n - 2 * x, n - x - 1) == hashhh(n - x + 1, n)) return 1;
	return 0;
}
il bool cc(ll x){
	if (hashh(n - 2 * x + 1, n - x) == hashhh(n - x + 1, n)) return 1;
	return 0;
}
int main(){
	scanf ("%lld %s", &n, s + 1);
	f[0] = 1;
	for (int i = 1; i <= n; i++) f[i] = f[i - 1] * base;
	for (int i = 1; i <= n; i++) h[i] = (h[i - 1] * base + s[i]);
	for (int i = n; i >= 1; i--) hh[i] = (hh[i + 1] * base + s[i]);
	for (int i = (n >> 1); i >= 0; i--){
		if (check(i)) return printf ("%d", n - i * 2 - 1) & 0;
		if (cc(i)) return printf ("%d", n - i * 2) & 0;
	}
	return 0;
}

```

---

## 作者：zhangxiao666 (赞：0)

### 前言：
好久没写题解了，来水一发，希望能过。

### 题意：
[题目传送门](https://www.luogu.com.cn/problem/P9606)

给定一个字符串，求最少添加几个字符才能使整个字符串回文。

### 思路：
首先如果把这个字符串画成图，它大概长这个样子（有点丑）：

![](https://cdn.luogu.com.cn/upload/image_hosting/zu9dpvlr.png)


可以发现，黑色部分和蓝色部分长度相等相等（回文串的性质），也就是说，只要求出最长回文后缀，剩下的部分即为添加的长度。

求最长回文后缀（会的大佬可以跳过）：

可以枚举左端点，求出中点后判断左右是否相等，可以用字符串哈希解决。

### 代码：

请勿抄袭。

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N = 4e5 + 10;
const int base = 13331;

int n;
char s[N];
ull p[N];
ull ha1[N], ha2[N];

void init_hash()//字符串哈希，由于求回文串，要正反哈希一次。
{
	p[0] = 1;
	for(int i = 1; i <= n; i++)
	{
		p[i] = p[i - 1] * base;
		ha1[i] = ha1[i - 1] * base + s[i] - 'a';
	}
	for(int i = n; i >= 1; i--)
	{
		ha2[i] = ha2[i + 1] * base + s[i] - 'a';
	}
}

ull get_hash(int l, int r, bool f)
{
	if(f == 0) return ha1[r] - p[r - l + 1] * ha1[l - 1];
	else return ha2[l] - p[r - l + 1] * ha2[r + 1];
}

int check(int x)
{
	int r = (x + n) >> 1;
	int l = r + ((x + n) & 1);
    //求中点，需要考虑长度的奇偶性质
	return get_hash(x, r, 0) == get_hash(l, n, 1);
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	cin >> s + 1;
	init_hash();
	for(int i = 1; i <= n; i++)//枚举左端点，最先找到的一定是最长的
	{				
		if(check(i))
		{
			cout << i - 1;
			return 0;
		}
	}
}
```


---


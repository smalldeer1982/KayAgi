# 黑匣子

## 题目描述

Black Box 是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量 $i$。最开始的时候 Black Box 是空的．而 $i=0$。这个 Black Box 要处理一串命令。

命令只有两种：

- `ADD(x)`：把 $x$ 元素放进 Black Box;

- `GET`：$i$ 加 $1$，然后输出 Black Box 中第 $i$ 小的数。

记住：第 $i$ 小的数，就是 Black Box 里的数的按从小到大的顺序排序后的第 $i$ 个元素。

我们来演示一下一个有11个命令的命令串。（如下表所示）

| 序号 | 操作 | $i$ | 数据库 | 输出 |
| :--: | :--- | :------: | ------ | :----: |
|   1  | `ADD(3)`     |   $0$    |  $3$  | / |
|   2  | `GET` |   $1$    |  $3$  | $3$ |
|   3  |`ADD(1)`|$1$|$1,3$|/|
|   4  |`GET`|$2$|$1,3$|$3$|
|   5  |`ADD(-4)`|$2$|$-4,1,3$|/|
|   6  |`ADD(2)`|$2$|$-4,1,2,3$|/|
|   7  |`ADD(8)`|$2$|$-4,1,2,3,8$|/|
|   8  |`ADD(-1000)`|$2$|$-1000,-4,1,2,3,8$|/|
|   9  |`GET`|$3$|$-1000,-4,1,2,3,8$|$1$|
|  10  |`GET`|$4$|$-1000,-4,1,2,3,8$|$2$|
|  11  |`ADD(2)`|$4$|$-1000,-4,1,2,2,3,8$|/|

现在要求找出对于给定的命令串的最好的处理方法。`ADD` 命令共有 $m$ 个，`GET` 命令共有 $n$ 个。现在用两个整数数组来表示命令串：

1. $a_1,a_2,\cdots,a_m$：一串将要被放进 Black Box 的元素。例如上面的例子中 $a=[3,1,-4,2,8,-1000,2]$。

2. $u_1,u_2,\cdots,u_n$：表示第 $u_i$ 个元素被放进了 Black Box 里后就出现一个 `GET` 命令。例如上面的例子中 $u=[1,2,6,6]$ 。输入数据不用判错。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n,m \leq 10^{4}$。
- 对于 $50\%$ 的数据，$1 \leq n,m \leq 10^{5}$。
- 对于 $100\%$ 的数据，$1 \leq n,m \leq 2 \times 10^{5},|a_i| \leq 2 \times 10^{9}$，保证 $u$ 序列单调不降。

## 样例 #1

### 输入

```
7 4
3 1 -4 2 8 -1000 2
1 2 6 6
```

### 输出

```
3
3
1
2
```

# 题解

## 作者：Sooke (赞：167)

## 平衡树是什么？初一党无法理解！
~~（然而现在已经是一个初二了，只能说略懂平衡树）~~

本题使用 两种优先队列：大顶堆和小顶堆 即可解决，比平衡树好理解但不能保证比平衡树快，具体思路和楼下某篇题解类似，但是这里我只将 ADD 函数的参数存在数组里，而 GET 函数输入就当即处理。阐明一下思路吧：用小顶堆维护第 i 大的值，那么第 i 大以前的数呢？存在大顶堆里，与小顶堆独立。GET 函数的数量决定了大顶堆限制的大小。第一次 GET，大顶堆不开放，数直接放入小顶堆，因此第 i 大（即第 1 大）的值就是那个数；第二次 GET，大顶堆的大小增加一，数进入小顶堆前先看看能不能被大顶堆容下，push 进大顶堆，将大顶堆的队首移入小顶堆（切勿忘记 pop 掉大顶堆的队首），此时小顶堆队首是第 2 大的。依此类推。因此，第 i 次 GET，大顶堆的大小为 i - 1，一旦大顶堆的大小超过 i - 1，队首就移入小顶堆，这样一来，此时小顶堆的队首就是第 i 大的数。

```cpp
#include <cstdio>
#include <queue>
#define Qmax priority_queue<int>
#define Qmin priority_queue<int,vector<int>,greater<int> >
#define f(i , a , b) for(int i=(a) ; i <= (b) ; i++)
using namespace std;
inline int Input(){
    char C=getchar();
    int N=0 , F=1;
    while(('0' > C || C > '9') && (C != '-')) C=getchar();
    if(C == '-') F=-1 , C=getchar();
    while('0' <= C && C <= '9') N=(N << 1)+(N << 3)+(C - 48) , C=getchar();
    return F*N; 
} //骗时间的读入优化 QAQ
int main(){
    int a[200001];
    Qmax A;
    Qmin B;
    int n=Input() , m=Input() , r=1 , q;
    f(i , 1 , n) a[i]=Input();
    f(i , 1 , m){
        q=Input();
        f(j , r , q){
            A.push(a[j]);
            if(A.size() == i) B.push(A.top()) , A.pop(); //超过大小，移除元素
        }
        r=q+1;
        printf("%d\n" , B.top()); //输出每次 GET 的答案
        A.push(B.top()) , B.pop(); //为下一次的 GET 作准备，填满小顶堆的空间
    }
    return 0;
}
```

---

## 作者：sxb_201 (赞：124)

没有翻到优美的堆的代码，特意写了一份

要点是开两一个大根堆一个小根堆，看下代码实现应该就能懂了

 
 

```
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstdio>
using namespace std; 
const int MAXN = 500000+10;
priority_queue<int,vector<int>,greater<int> >s; // 小根堆 
priority_queue<int,vector<int>,less<int> >b;// 大根堆
 
int a[MAXN],u[MAXN];
int main()
{
	int m,n;
	cin>>m>>n;
	for(int i=1;i<=m;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&u[i]);
	int p=0;
	for(int i=1;i<=n;i++)
	{
		while(p<u[i])
		{
			p++;
			b.push(a[p]);
			s.push(b.top());
			b.pop();
		}
		printf("%d\n",s.top());
		b.push(s.top());
		s.pop();
	}
	return 0;
} 
```

---

## 作者：zhylj (赞：105)

楼下好多dalao QAQ

我的方法是用堆解

当然普通的堆排序暴力模拟是无法通过的（30分）

便有一种思路

有两个堆h1、h2

h2储存整个序列的前i个最小值，保证h2的大小永远等于i，大根堆，根即为每次需要Get的值

h1储存序列剩下部分的值，小根堆

每一次操作就是先按照u(i)（在我的代码里用的是b[i]）Put(a[j])进到h1

然后因为有u的存在，所以往h2 Put一个数，即为h1的最小值

但是这时候有可能h1中会有比h2任何一个节点小的节点，这样的h2是不符合规定的，于是反复判断h1和h2的根节点（一个是h1最小，一个是h2最大），如果h1的根节点小于h2的根节点，则取出h1和h2的根节点，然后将h1的根节点Put进h2，h2的根节点Put进h1，直到h2的根节点小于h1为止

输出h2

下面的代码我用的是自己手写的堆模板（无聊写的），不是STL的。

Heap<typename,size>代表定义一个typename为类型，大小为size的堆

h1.Put(x);代表往h1这个堆里面Put进x这个数

h1.(1);代表取出h1的根节点，返回这个节点的值。

h1[i];就代表h1的第i个数，根节点是1。

h1.size代表h1的大小，没有节点为0,1个节点为1……

该代码耗时360ms，空间3566KB

（感觉这题难度没有那么大）


Heap<int,5000005> h1,h2(1);  //定义h1为小根堆，h2为大根堆

```cpp
int a[200005],b[200005];  //定义输入用的数组
int main()
{
    ios::sync_with_stdio(false);  //关闭同步，优化
    int m,n;
    cin>>m>>n;//输入就不说了
    for(int i=0;i<m;i++)
        cin>>a[i];//读入a[i]
    for(int i=0;i<n;i++)
        cin>>b[i];//读入u[i]
    int c,t;
    for(int i=0,j=0;i<n;i++)
    {
        for(;j<b[i];j++)  //Put进a的前几个数
            h1.Put(a[j]);
        c=h1.Get(1);  //在h2里面放入h1的根节点，为了保证h2的大小永远等于i
        h2.Put(c);
        while(h1.size>0&&h1[1]<h2[1])  //如果h1有节点并且h1的根节点小于h2的根节点，那么就要“交换”
        {
            t=h2.Get(1);  //取出h2的根节点
            c=h1.Get(1);  //取出h1的根节点
            h1.Put(t);  //放入节点
            h2.Put(c);
        }
        cout<<h2[1]<<endl;  //输出第i小的节点
    }
    return 0;
}
```

---

## 作者：7KByte (赞：87)

这道题目可以用两种方法很好地解决  

------------------

## 1.对顶堆  
顾名思义，对顶堆是两个堆组成的特殊的数据结构  
![](https://cdn.luogu.com.cn/upload/pic/50110.png)  
~~手画有点丑~~  
如果说上面是个小根堆，下面是个大根堆，小根堆的元素都大于大根堆的元素，那么我们可以发现：  
**每一层节点从上往下逐层递减**  
所以对于$add$操作，我们先将元素放入下面的大根堆内，从堆顶不断取出元素放到小根堆直到大根堆元素个数为$i$,这样大根堆的根就是第i小的元素，同时可以保证对顶堆的性质  
同理，对于$get$操作，我们先输出大根堆的根，然后将小根堆的根移到大根堆（因为i每次加一，要始终保证大根堆有i个元素），这样仍保证对顶堆的性质不变  
时间复杂度$O(nlog_2n)$  
代码（使用了$SLT$,常数较大）：
```cpp
#include<cstdio>
#include<queue>
using namespace std;
int a[200005];
int main(){    
    priority_queue<int>A;
    priority_queue<int,vector<int>,greater<int>>B;
    int n,m,r=1,q;scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=m;i++){
        scanf("%d",&q);
        for(int j=r;j<=q;j++){
            A.push(a[j]);
            if(A.size()==i)B.push(A.top()),A.pop();
        }
        r=q+1;
        printf("%d\n",B.top());
        A.push(B.top()),B.pop();
    }
    return 0;
}
```

![](https://cdn.luogu.com.cn/upload/pic/50112.png)  




-------------

## 2.平衡树  
对于插入和查找，每个学过的平衡树的OIer都会首先想到平衡树，鉴于BST极易退化，效率不高，所以我们用平衡树来解决  
~~（如果哪位神犇用不加优化BST做出来在下只能orz了~~  

简单的插入和查找操作，Treap能够很优雅的跑完这道题，如果说大佬什么splay啊，什么AVL树啊，什么红黑树啊，都可以如果不嫌麻烦  
$STL set$应该也可以，没有试（这个人太懒了


代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r,data,size,val,cnt;
}a[200010];
int pop=0,root,n,INF=(1<<30)-1+(1<<30);
int New(int data){
	pop++;
	a[pop].val=rand();
	a[pop].data=data;
	a[pop].size=1;
	a[pop].cnt=1;
	a[pop].l=a[pop].r=0;
	return pop;
}
void updata(int p){
	a[p].size=a[a[p].l].size+a[a[p].r].size+a[p].cnt;
}
void build(){
	root=New(-INF);a[root].r=New(INF);
	a[0].cnt=a[0].data=a[0].size=a[0].val=0;
	updata(root);
}
void zig(int &p){
	int q=a[p].l;
	a[p].l=a[q].r;
	a[q].r=p;p=q;
	updata(a[p].r);
	updata(p);
}
void zag(int &p){
	int q=a[p].r;
	a[p].r=a[q].l;
	a[q].l=p;p=q;
	updata(a[p].l);
	updata(p);
}
void insert(int &p,int data){
	if(p==0){
		p=New(data);
		return;
	}
	if(data==a[p].data){
		a[p].cnt++;
		updata(p);
		return;
	}
	if(data<a[p].data){
		insert(a[p].l,data);
		if(a[a[p].l].val>a[p].val)zig(p);
		else updata(p);
		return;
	}
	if(data>a[p].data){
		insert(a[p].r,data);
		if(a[a[p].r].val>a[p].val)zag(p);
		else updata(p);
		return;
	}
}
void remove(int &p,int data){
	if(p==0)return;
	if(a[p].data==data){
		if(a[p].cnt>1){
			a[p].cnt--;
			updata(p);
			return;
		}
		if(a[p].l||a[p].r){
			if(a[p].r==0||a[a[p].l].val>a[a[p].r].val)
			  zig(p),remove(a[p].r,data);
			else zag(p),remove(a[p].l,data);
			updata(p);return;
		}
		p=0;return;
	}
	if(data<a[p].data)remove(a[p].l,data);
	else remove(a[p].r,data);updata(p);
}
int getpre(int data){
	int ans=1;
	int p=root;
	while(p){
		if(data>a[p].data){
			if(a[p].data>=a[ans].data)
			  ans=p;
			p=a[p].r;
		}
		else p=a[p].l;
	}
	return a[ans].data;
}
int getnext(int data){
	int ans=2;
	int p=root;
	while(p){
		if(data<a[p].data){
			if(a[p].data<=a[ans].data);
			  ans=p;
			p=a[p].l;
		}
		else p=a[p].r;
	}
	return a[ans].data;
}
int getrankbyval(int p,int val){
	if(p==0)return 0;
	if(val==a[p].data)return a[a[p].l].size+1;
	if(val<a[p].data)return getrankbyval(a[p].l,val);
	return getrankbyval(a[p].r,val)+a[a[p].l].size+a[p].cnt;
}
int getvalbyrank(int p,int rank){
	if(p==0)return -INF;
	if(a[a[p].l].size>=rank)return getvalbyrank(a[p].l,rank);
	if(a[a[p].l].size+a[p].cnt>=rank)return a[p].data;
	return getvalbyrank(a[p].r,rank-a[p].cnt-a[a[p].l].size);
}
int u[200005],b[200005];
int main()
{
	build();
	int n,m;scanf("%d%d",&n,&m);
	int top=0,s=1;
	for(int i=1;i<=n;i++)
	  scanf("%d",&u[i]);
	for(int j=1;j<=m;j++)
	{
		scanf("%d",&b[j]);
		while(s<=b[j])insert(root,u[s]),s++;
		top++;
		printf("%d\n",getvalbyrank(root,top+1));
	}
	return 0;
}
```   

![](https://cdn.luogu.com.cn/upload/pic/50115.png)  


平衡树跑得好像快一点……

---

## 作者：浅色调 (赞：46)

### 思路：

$\quad$本题是一道对顶堆的题目，话说没人写权值线段树的题解啊！于是安利一波**权值线段树**。。。

　　权值线段树其实很简单，故名思义它的每个叶子节点都有权值(即每个叶子节点维护的是某个确定的数)，它可以很轻松的求出整个区间中的第$k$小的数（**注意是整个区间**，不是一段区间，权值线段树其实就是弱化的主席树，或者说主席树就是多棵权值线段树）。

　　拿本题做例题。

　　首先，我们对原数组离散化(因为数太大，空间开不下)，这样离散后最多有$200000$个数，就能建树用叶子节点维护每个数了。

　　再讲讲插入操作，其实就是单点修改，对于离散后的数每次找到它所在的叶子节点，使其权值$+1$（说明这个数出现了一次），并维护一段区间的数出现的个数（即区间求和）。

　　然后询问第$k$小的数时，从整个区间$[1,n]$开始递归，当左儿子区间$[l,mid]$中出现的数个数大于等于$k$时，查询左儿子，否则查询右儿子中的第$k-sum[l,mid]$小的数(即左儿子中已有$sum[l,mid]<k$个数，那么整个区间第$k$小的数在右儿子里，且是右儿子中的第$k-sum[l,mid]$小的数)，当查询到$l==r$时返回$l$，
  那么答案就是离散前$l$所代表的数$a[l]$。输出就$OK$了。
  
$\quad$欢迎来踩博客[five20](http://www.cnblogs.com/five20/p/8952347.html)（蒟蒻写博客不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
const int N=2e5+7;
int tr[N<<2],n,m,u[N],s[N],cnt=1;
struct numm{
    ll v;int id;
    bool operator < (numm a){return v<a.v;}
}a[N];
il ll gi(){
    ll a=0;char x=getchar();bool f=0;
    while((x>'9'||x<'0')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
    return f?-a:a;
}
il void pushup(int rt){tr[rt]=tr[rt<<1]+tr[rt<<1|1];}
il void update(int u,int l,int r,int rt){
    if(l==u&&r==u){tr[rt]++;return;}
    tr[rt]++;
    int m=l+r>>1;
    if(u<=m)update(u,lson);
    else update(u,rson);
    pushup(rt);
}
il int query(int k,int l,int r,int rt){
    if(l==r)return l;
    int m=l+r>>1;
    if(tr[rt<<1]>=k)return query(k,lson);
    else return query(k-tr[rt<<1],rson);
}
int main()
{
    n=gi(),m=gi();
    for(int i=1;i<=n;i++)a[i].v=gi(),a[i].id=i;
    for(int i=1;i<=m;i++)u[i]=gi();
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)s[a[i].id]=i;
    for(int i=1;i<=n;i++){
        update(s[i],1,n,1);
        while(i==u[cnt]){
            printf("%lld\n",a[query(cnt,1,n,1)].v);
            ++cnt;
        }
    }
    return 0;
}
```

 

---

## 作者：陈曦 (赞：29)

蒟蒻来发题解了。我仔细看了一下其他题解，各位巨佬用了堆，红黑树，splay,treap之类的强大算法，表示蒟蒻的我只会口胡这些算法，所以我决定用一种极其易理解的算法————fhq treap，作为treap的升级版，它不仅好理解，好用，还能做到可持久化，真是神级算法（~~不知道为什么会fhq treap的我，不会一般treap~~）

进入正题，首先我先讲讲fhq treap的主要思想，它是一种非旋转的平衡树，不用考虑左旋右旋等~~麻烦情况~~，它很暴力，直接靠拆树，合并来实现，有点二分的感觉，其实它很多操作就有二分思想。

好了，看图，我们有一颗二叉树
![](https://cdn.luogu.com.cn/upload/pic/25865.png)

当我们插入6号，发现它失衡了
![](https://cdn.luogu.com.cn/upload/pic/25867.png )

多西太？大丈夫

我们不用旋转，不用交换，直接拆。

第一个重要操作：拆树（split），我们先把树分为x,y两部分，x的节点权值≤k， y的节点的权值＞k，要插入一个数a的话，就把新的节点a看做是一棵树，先与x合并，合并完之后将合并的整体与y合并

上代码
```cpp
inline void split(int &x,int &y,int k,int pos)
{
    if(!pos)x=y=0;//root=0时（即第一次split） 此时的x=?,y=?很明显要给他们初始化 即x=0,y=0
    else
    {
        if(val[pos]<=k)
        {x=pos;split(son[pos][2],y,k,son[pos][2]);}
        else
        {y=pos;split(x,son[pos][1],k,son[pos][1]);}
        update(pos);
    }
}
```

第二个重要操作：合并（merge）
还是两棵树x,y。如果rand[x]<rand[y] 我们就把y接在x的右儿子上 你想如果接在左儿子 那左儿子的权值就大于父亲的权值了 不符合二叉搜索树的性质

反之同理

其实merge 要理解的话自己画两颗treap 然后模拟一下。

上代码
```cpp
inline int merge(int x,int y)
{
    if(x==0||y==0) return x+y;//第一次合并的情况
    if(rnd[x]<rnd[y]) 
    {
        son[x][2]=merge(son[x][2],y);
        update(x);return x;
    }
    else
    {
        son[y][1]=merge(x,son[y][1]);
        update(y);return y;
    }
}
```

至于查排名（find），就是easy的操作了，根据堆的性质，直接找右子树大小，再去遍历就好了，不知道的可以先去学习二叉搜索树的操作（~~各位巨佬肯定都会了~~）

ac代码
```cpp
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define maxn 200010
using namespace std;
int n,val[maxn],rnd[maxn],son[maxn][3],size[maxn],sum_p,m;
//val记录权值，son记录左右子树大小，size[i]记录以i为根节点的树的大小
int X1[maxn];
int flag[maxn];
inline void read(int &x)//快读
{
    x=0;int f=1; 
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9')
    {x=x*10+ch-'0';ch=getchar();}
    x*=f;
}
inline int newnode(int x)
{
    ++sum_p;size[sum_p]=1;
    val[sum_p]=x;rnd[sum_p]=rand();
    return sum_p; 
}
inline void update(int x)
{
    size[x]=size[son[x][1]]+size[son[x][2]]+1;//加上自己
}
inline void split(int &x,int &y,int k,int pos)//x,左子树的根(权值较小的),y,右子树的根,pos为现在的节点 
{
    if(!pos)x=y=0;//root=0时（即第一次split） 此时的x=?,y=?所以初始化x=0,y=0
    else
    {
        if(val[pos]<=k)
        {x=pos;split(son[pos][2],y,k,son[pos][2]);}
        else
        {y=pos;split(x,son[pos][1],k,son[pos][1]);}
        update(pos);
    }
}
inline int merge(int x,int y)//保证y子树权值大于x子树 
{
    if(x==0||y==0) return x+y;//第一次合并的情况
    if(rnd[x]<rnd[y]) //比rand大小
    {
        son[x][2]=merge(son[x][2],y);
        update(x);return x;
    }
    else
    {
        son[y][1]=merge(x,son[y][1]);
        update(y);return y;
    }
}
inline int find(int pos,int rank)
{
    while(1)
    {
        if(size[son[pos][1]]>=rank)
        {
            pos=son[pos][1];
        }
        else 
        if(size[son[pos][1]]+1==rank)return pos;//由于是儿子 要加上自己 
        else
        {
            rank-=size[son[pos][1]]+1;
            pos=son[pos][2];
        }
    }
}
int main()
{
    srand((unsigned)time(NULL));
    int a,b,x,y,z,op,root=0,pos=0;
    read(n),read(m);
    for(register int i=1;i<=n;i++)
    read(X1[i]);
    for(register int i=1;i<=m;i++)
    {read(op);flag[op]++;}//记录查询点
    for(register int i=1;i<=n;i++)
    {
        split(x,y,X1[i],root);
        root=merge(merge(x,newnode(X1[i])),y);
        while(flag[i]>=1)//可能一个位置不止一次查询
        {
            pos++;flag[i]--;
            printf("%d\n",val[find(root,pos)]);
        }
    }
}
```

最后我再给没学过fhq treap的同学补充一点基础操作

1、求a的排名：我们只需要split成一颗≤a-1,一颗≥a的就行了 a的排名就是第一棵treap的size+1；

2、求a前驱：以a-1为界限拆树就好了，a的前驱肯定就是第一个treap里最大的 ，就在find操作的基础上，在x里找排名为size[x]的

3、求a后继：以a为界限拆树，a的后继是第二个treap里最小的；

4、delete和区间反转就留给大家自己思考了，无论如何，fhq treap的操作基本上都建立在拆树与合并上。

~~最后强烈安利一波fhq treap~~

---

## 作者：小手冰凉 (赞：20)

setの奇技淫巧


没人用set水过这道题么？（set大法好）


首先这题可能有重复数字，所以用multiset


在维护第K大时直接维护指针指向，如果当前插入元素比指针指向的第K个小就前移指针


没输出一个就后移一次指针


复杂度O(nlogn)


```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-48;
    return x*f;
}
const int N=200005;
multiset<int>q;//可能有重复数字
int a[N],s[N],n,m;
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=m;i++)s[i]=read();
    int k=1;q.insert(a[1]);
    multiset<int>::iterator it=q.begin();//一定要读入第一个在指向
    if(s[k]==1)printf("%d\n",a[1]),k++;
    for(int i=2;i<=n;i++){
        q.insert(a[i]);
        if(a[i]<*it)it--;//如果比当前小就指向前一个
        while(s[k]==i){
            if(k!=1)it++;//指针指向后一个
            printf("%d\n",*it),k++;
        }
    }
    return 0;
}
```

---

## 作者：神之右大臣 (赞：13)

什么对顶堆，平衡树，本蒟蒻表示均不会
来一篇不同的算法

离线处理；

大体思路就是将数组排序，然后对于第k次询问把不可行的数打上标记，然后从头开始寻找第k个没打标记的点的值
(排序后的数组保证了它是第k小的)。
Q:这不超时吗？
A：no no no,实现是有技巧的！

实现方法：
首先离散化原始数组，得到数组find[],find[i]=j表示原位置为i的数从小到大排序后的位置是j。

a[]数组表示原数组,b[]数组存每次询问到第几个位置。n个数，m个询问。

由于询问的b[]是递增的，所以仅仅需要排序1~b[m]即可；(因为不可能输出b[m]以后的数，所以可以忽略b[m]以后的数对答案的影响)

排序后，倒着处理每次询问,设bo[i]=1表示*排序后*位置是i的这个数不在某次询问的范围内(对于一次询问q,询问的范围就是1~b[q])；

设一个指针now，它所指向的是排序后数组的某一个位置，对于第k次询问now的值就是排序后数组从头开始数第k个没打标记的点的位置。

初始化now指向b[m]，然后枚举由于该次询问所额外添加的点j,并把它们打上标记(bo[find[j]]=1)。
PS1:比如说上次询问是1~3区间，这次询问是1~5区间，那么额外添加的点j就是4和5.
PS2:由于4,5指的是原数组a[]中位置，所以应该给find[4],find[5]打标记;


设cnt=0，对于每次枚举，如果find[j]<now,那么就cnt++;

假设当前你求第k小值，如果cnt=0,就表示find[q[k-1]+1~q[k]]都不在now的前边，
因为参与第k-1小比较的值都在now的前面，所以这种情况对于回答第k-1小的值不存在影响
第k-1小的值就是从now往前数第1个没打标记的点u，并将now更新为u

当cnt=1时，这意味着now前面有一个点在求第k-1小的值时是不可以使用的!这代表now这个点从原来的第k小变味了第k-1小。所以now不更新。
但要注意，由于我们是find[j]<now时++cnt，所以可能存在now这个点被标记的情况。在这种情况下now要向后移到第一个没打标记的点。


当cnt>1时，就代表前面的数有很多都不能使用了，这意味着now需要向后移动来保证now所指的位置是第k-1小；
如果bo[now]=1,那么将now向右移动,直到经过了cnt个未标记的点。否则，将now向右移动,直到经过了(cnt-1)个未标记的点；

对于每次询问，ans[i]=排序后now这个位置的值;

时间复杂度是排序的(nlogn)+打标记的O(n)加上改变now的值的O(n)(如果你用链表结构的话便是O(n)，不用的话时间复杂度也很优美)外加一些常数;


```cpp
#include <bits/stdc++.h>
using namespace std;
int a[200010];
int b[200010];
int n,m;
struct haha{
	int pos;
	int v;
}lala[200010];
bool cmp(haha x,haha y)
{
	return x.v<y.v;
}
int fin[200010];
int ans[200010];
int bo[200010];
int main ()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(register int i=1;i<=m;i++){
		scanf("%d",&b[i]);		
	}
	for(register int i=1;i<=b[m];i++){
		lala[i].pos=i;
		lala[i].v=a[i];
	}
	sort(lala+1,lala+1+b[m],cmp);
	for(register int i=1;i<=b[m];i++){
		fin[lala[i].pos]=i;
	}
	int now=m;
	for(register int i=m;i>=1;i--){		
		ans[i]=lala[now].v;
		int cnt1=0;
		for(register int j=b[i-1]+1;j<=b[i];j++){
			if(fin[j]<now) ++cnt1;
			bo[fin[j]]=1;
		}
		if(cnt1>1){
			while(bo[now]) ++now;
			int tmp=cnt1-1;
			int cnt=0;
			for(register int j=now+1;j<=n;j++){
				if(bo[j]) continue;
				++cnt;
				if(cnt==tmp){
					now=j;
					break;
				}
			}
		}
		else if(cnt1==1&&bo[now]){
			for(register int j=now+1;j<=n;j++){
				if(bo[j]) continue;
				now=j;
				break;
			}
		}
		else if(cnt1==0){
			--now;
	        while(bo[now]){
	        	--now;
	        }
		}
	}
	for(register int i=1;i<=m;i++){
		printf("%d\n",ans[i]);
	}
}
```


---

## 作者：zhz小蒟蒻 (赞：12)

### 这个题是无意间发现的，然后看了一下数据范围，主席树可以过,于是我就无聊的打了一个主席树……  
下面均为主席树讲法：  
  事实上，我们可以将所有的点全部插入到主席树中，然后，设 $num$ 表示当前已经访问了多少次, $step$ 为当前输入的 $u(j)$，那么我们可以输出 $1-step$ 区间的第 $num$ 小，至于主席树部分就可以直接套模板
  
  $Code:$  
  ```
  #include <bits/stdc++.h>
#define N 200005
using namespace std;
inline int read() //快读
{
	char ch=getchar();
	int f=0,w=1;
	while(ch<'0' || ch>'9') 
	{
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		f=(f<<3)+(f<<1)+ch-'0';
		ch=getchar();
	}
	return f*w;
}
inline void write(register int x) //快写
{
    if(!x)putchar('0');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int a[N],b[N],cnt;
int sum[N<<5],ls[N<<5],rs[N<<5],T[N];
inline int build(register int l,register int r) //建一颗主席树
{
	int root=++cnt; //这是最开始的主席树
	sum[root]=0;
	int mid=(l+r)>>1;
	if(l<r) 
	{
		ls[root]=build(l,mid),rs[root]=build(mid+1,r);
	}
	return root;
}
inline int update(register int pre,register int l,register int r,register int x) // 对于每一颗主席树,根节点肯定是不一样的，但它有可能与上一颗主席树有重复节点
{
	int root=++cnt;
	ls[root]=ls[pre];rs[root]=rs[pre];sum[root]=sum[pre]+1; //一开始的时候，我们假设左右节点都没有改动
	int mid=(l+r)>>1;
	if(l<r)
	{
		if(x<=mid) ls[root]=update(ls[pre],l,mid,x); //如果这个改动的点小于等于mid，说明左区间被修改了
		else rs[root]=update(rs[pre],mid+1,r,x);	//否则就是有区间被修改了
	}
	return root;
}
inline int query(register int u,register int v,register int l,register int r,register int k)
{
	if(l>=r) return l;
	int x=sum[ls[v]]-sum[ls[u]];  //主席树查询的精髓，运用了前缀和的思想，如果1~r区间减去1~(l-1)的值，那么就是l~r区间的值
	int mid=(l+r)>>1;
	if(x>=k) return query(ls[u],ls[v],l,mid,k);
	else return query(rs[u],rs[v],mid+1,r,k-x);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);		
	int n,k,m;
	n=read(); k=read();
	for(register int i=1;i<=n;++i)
		b[i]=a[i]=read();
	sort(b+1,b+n+1);
	m=unique(b+1,b+n+1)-b-1;
	T[0]=build(1,m);
	for(register int i=1;i<=n;++i)
	{
		int t=lower_bound(b+1,b+1+m,a[i])-b;
		T[i]=update(T[i-1],1,m,t);
	}
	int num=0;
	for(register int i=1;i<=k;++i)
	{
		int step=read();
		++num;
		int t=query(T[0],T[step],1,m,num);
		write(b[t]);puts("");
	}
	return 0;
}
  ```

---

## 作者：The_clear_pool (赞：11)

/\*
思路:

先s,代表题目中的i

再设两个堆,一个大根堆,一个小根堆,

大根堆里放目前s个最小的数,

小根堆里放剩下的数

具体过程:

那么可知大根堆里必定有s个数,

那么小根堆里的第一个数就是s+1也就是下一个get所需要的值

那么就不断地往大根堆里添加值,当超过s时就移到小根堆里去,

碰到get是就不断输出,再不断把输出的值在返还到大根堆里重新在按上面来一遍即可,

代码如下：

\*/
```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <queue>
using namespace std;
int a[200001],u[200001];
priority_queue<int,vector<int>,greater<int> >c;//小根堆 
priority_queue<int> b;//大根堆 
int main(){
    int m,n;
    int s,k=1;
    cin>>m>>n;
    for(int i=1;i<=m;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        cin>>u[i];
    }
    for(int i=1;i<=m;i++){
        b.push(a[i]);
        if(b.size()>s){
            c.push(b.top());//如果b堆中堆数大于目前应取的总共i个元素,就把多余的放入c堆中,也就是把更大的放入c堆中 
            b.pop();//在b堆中把它删掉 
        }
        while(u[k]==i){
            s++;
            cout<<c.top()<<"\n";
            b.push(c.top());//如果有多次就把它多高到另一个数组里,之后再重新来一遍
            //这样就能保证第n..n+m都不重复,因为a[n]>a[n+1]>a[n+2]>...>a[n+m] 
            c.pop();
            k++;
        }
    }
    return 0;
}
```

---

## 作者：引领天下 (赞：5)

看到这个题面，不断加入元素，每次查询第k大，我就立刻想到了平衡树……

然后又不会手码，于是想到了pbds的tree

然后就轻松的码出了30分的代码……

问了别人才知道原来有重复元素，而且pbds的tree是不能插入重复元素的

那么，我们怎么解决呢？

我想到了hash。

我们对每个元素维护一个二元组$\left(x,h\right)$，$x$表示元素本来的值，而$h$是我们通过hash搞出的一个唯一的随机值。

然后对每个u把没加进tree的元素加进去，然后直接利用tree求kth。

代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
struct User{
    int x,h;
    inline bool operator < (const User&p)const{return x!=p.x?x<p.x:h<p.h;}
}a[200005];//我们的二元组，注意，一定要满足单升，即：必须对任意两个元素的大小定义死
tree<User,null_type,less<User>,rb_tree_tag,tree_order_statistics_node_update> t;//定义一个pbds的红黑树
map<int,bool> mp;//判断一个hash值是否出现过了
int m,n,i,u[200005],last=1,hh;
inline int Hash(int x){
    while(mp[x])x=x+rand();
    return x;
}//对每个x生成一个唯一的值h
int main(){
	scanf("%d%d",&m,&n);
    for (int j=1;j<=m;j++){
        scanf("%d",&a[j].x);
        hh=Hash(a[j].x);
        a[j].h=hh,mp[hh]=1;
    }//读入的同时预处理好每个二元组
    for (int j=1;j<=n;j++)scanf("%d",&u[j]);//读入的u实际上已经拍好序了
    for (int j=1;j<=n;j++){
        for (;last<=u[j];last++)t.insert(a[last]);//插♂入
        printf("%d\n",(*t.find_by_order(i++)).x);//直接查kth，返回的是地址，我们要先取*再加.
        //注意！tree中查第k个元素实际上是find_by_order(k-1)
    }
}
```

---

## 作者：爷，无限霸气 (赞：4)

# 这里我们提供一种fhq-treap的做法！

无旋平衡树在这里不细讲，详情见[小菊若的博客](https://www.luogu.org/blog/Treapcjoier/solution-p3391)

这是无旋平衡树的时间：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ydmlvxe.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

用一个变量top记录现在到了第几次

然后从上一次插入到这一次中的每个数一个一个插入。

之后在输出一下排名为top的数就可以啦！！！

（~~感觉咋这是一道平衡树模板~~）

（~~Ctrl C+Ctrl V！！！~~）

```cpp
#include<bits/stdc++.h>
#define ll long long
//不开long long见祖宗 
using namespace std;
const int N=400010;
struct trnode
{
    ll l,r,v,rnd,size,qz;
    #define l(x) tr[x].l
    #define r(x) tr[x].r
    #define v(x) tr[x].v
    #define rnd(x) tr[x].rnd
    #define size(x) tr[x].size
    #define qz(x) tr[x].qz
    //进一步简化代码 
}tr[N]; 
ll tot=0,root=0,n;
void update(ll x)//计算 
{
    size(x)=size(l(x))+size(r(x))+1;//用儿子更新父亲   
}
ll New(ll v)
{
    tot++;
    size(tot)=1; v(tot)=v; rnd(tot)=rand(); qz(tot)=0;//比较平常的新建节点工作，初始化弄起来！ 
    return tot;
}
ll build(ll l,ll r)//建立 fhq-treap 
{
    if(l>r) return 0;//这左儿子比右儿子大return没问题吧 
    ll mid=(l+r)/2,v=mid-1,now=New(v);//总感觉有点像线段树的建树 
    l(now)=build(l,mid-1);
    r(now)=build(mid+1,r);
    update(now);//计算一下 
    return now;
}
ll merge(ll x,ll y)//默认x<y 
{
    if(!x||!y) return x+y;
    update(x),update(y);//准备合并？ 
    if(rnd(x)<rnd(y))//用rand值来维护堆进而维护平衡性 
    {
        r(x)=merge(r(x),y);//右儿子的树合并 
        update(x);//计算一波 
        return x;
    }
    else
    {
        l(y)=merge(x,l(y));//和前文一样 
        update(y);
        return y;   
    }
}
void split(ll now,ll k,ll &x,ll &y)
{
    if(!now) x=y=0;
    else
    {
        update(now);
        if(v(now)<=k) x=now,split(r(now),k,r(now),y);
        else y=now,split(l(now),k,x,l(now));
        update(now);
    }
}
void rev(ll l,ll r)//这里进行旋转操作 
{
    ll a,b,c,d;
    split(root,r+1,a,b);
    split(a,l,c,d);
    qz(d)^=1;
    root=merge(merge(c,d),b);
}
ll read()
{
    ll r=0,f=1;char c=getchar();
    while((c<'0'||c>'9')&&(c!='-')) c=getchar();
    if(c=='-') f=-1,c=getchar();
    while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
    return r*f;
}
ll pri[N],len=0;
void print(ll x)
{
    if (!x) return;
    update(x);
    print(l(x));//就输出左儿子 
    if (v(x)>=1 &&v(x)<=n) printf("%lld ",v(x));
    print(r(x));//再来右儿子 
}
ll kth(ll now,ll k)
{
    while(1)
    {
        if(k<=size(l(now))) 
            now=l(now);
        else
        {
            if(k==size(l(now))+1) return now;
            else 
            {
                k-=size(l(now))+1;
                now=r(now);
            }
        }
    }
}
ll a[N],b[N];
int main()
{
    ll n,m;
    n=read(),m=read();
    build(1,n+2);
    ll top=0,s=1,x,y,z;
    for(int i=1;i<=n;i++) a[i]=read(); 
    for(int j=1;j<=m;j++)
    {
        b[j]=read();
        while(s<=b[j])
		{
			split(root,a[s],x,y);
			root=merge(merge(x,New(a[s])),y);
			s++;
		}
        top++;
    	printf("%lld\n",v(kth(root,top)));
    }
    return 0;
}
```

想说一句：貌似STL~~好写一点~~

---

## 作者：origin_star (赞：4)

~~大家好，我是陈独秀同学，今天我给大家带来一种奇怪的方法~~

首先，这一道题既然是要求第k小值，我们就可以使用STL库中的set来实行自动排序，每次用迭代器求第k小值

代码：

```
#include<cstdio>
#include<cctype>
#include<set>
using namespace std;
const int N=200001;
multiset<int>s;
int n,m,k,top=1,a[N],x;
template <typename _Tp> inline _Tp read(_Tp&x){
    char c11=getchar(),ob=0;x=0;
    while(c11^'-'&&!isdigit(c11))c11=getchar();if(c11=='-')c11=getchar(),ob=1;
    while(isdigit(c11))x=x*10+c11-'0',c11=getchar();if(ob)x=-x;return x;
}
int main()
{
    n=read(n);m=read(m);
    for(int i=1;i<=n;++i){
        a[i]=read(a[i]);
    }
    for(int i=1;i<=m;++i){
        x=read(x);
        ++k;
        for(;top<=x;++top){
            s.insert(a[top]);
        }
        auto j=s.begin();
        int xx=1;
        while(xx!=k){
            ++j,++xx;
        }//从开头枚举第k小值
        printf("%d\n",*j);
    }
    return 0;
}
```

[提交记录](https://www.luogu.org/recordnew/show/14848850)

但是提交上去发现T了两个点，要进行优化

读一下代码，发现在使用迭代器的过程中重复得跑了很多遍

实际上，我们可以使用一个变量存储每次的第k小值的位置，然后判断后来插入的数是否小于当前的第k小值，然后从后往前推。

```cpp
#include<cstdio>
#include<cctype>
#include<set>
using namespace std;
const int N=200001;
multiset<int>s;
int n,m,k,top=2,a[N],x,minc;
template <typename _Tp> inline _Tp read(_Tp&x)
{
    char c11=getchar(),ob=0;
    x=0;
    while(c11^'-'&&!isdigit(c11))c11=getchar();
    if(c11=='-')c11=getchar(),ob=1;
    while(isdigit(c11))x=x*10+c11-'0',c11=getchar();
    if(ob)x=-x;
    return x;
}
int main()
{
    n=read(n);
    m=read(m);
    for(int i=1; i<=n; ++i) {
        a[i]=read(a[i]);
    }
    s.insert(a[1]);
    auto j=s.begin();
    for(int i=1; i<=m; ++i) {
        x=read(x);
        minc=0;
        for(; top<=x; ++top) {
            s.insert(a[top]);
            if(a[top]<(*j)) ++minc;
        }
        if(i!=1)++j;
        while(minc>0) {
            --j,--minc;
        }//(敲黑板)从后往前推可以降低时间复杂度
        printf("%d\n",*j);
    }
    return 0;
}
```
AC记录：https://www.luogu.org/record/show?rid=14852583

---

## 作者：autoint (赞：4)

###看到各路dalao用平衡树的做法，表示本人不才，并不会。

###然而我会优先队列\_huaji\_，并且发现用堆解题的dalao们并没有基于**在线**的做法

于是我的showtime到了

评测结果：<https://www.luogu.org/record/show?rid=4645103>

#先讲一下思路：

题干所描述的** i **的实际值并不重要，他只是作为堆的一个位置

当然如果你暴力模拟的话肯定会超时

- 为此我们考虑维护**两个堆**，一个是大根堆，一个是小根堆，且满足小根堆中的数比大根堆中的数大

- 用bool变量flag来表示当前所操作的是大根堆还是小根堆

- 首先是ADD(x)，按flag和x分为四种情况

- 然后是GET，按flag分为两种情况

- 具体操作见以下代码：







            
            


```cpp
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<ctime>
#include<iostream>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<map>
#include<set>
#include<algorithm>
#pragma GCC optimize(3)//STL必带
using namespace std;
#define ll long long
const int maxn=2e5+10;
const int INF=0x7fffffff;
inline void read(int&x){//卡常的输入
    int data=0,w=1;
    char ch=getchar();
    while(ch!='-'&&!isdigit(ch))
        ch=getchar();
    if(ch=='-')
        w=-1,ch=getchar();
    while(isdigit(ch))
        data=10*data+ch-'0',ch=getchar();
    x=data*w;
}
void write(int x){//卡常的输出
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar('0'+x%10);
}
int a[maxn],u[maxn]={0};
priority_queue <int,vector<int>,less<int> > lrh;//大根堆，large root heap
priority_queue <int,vector<int>,greater<int> > srh;//小根堆，small root heap
int main()
{
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
    int m,n;
    read(m);read(n);
    for(int i=1;i<=m;++i)
        read(a[i]);
    int t;
    for(int i=1;i<=n;++i){
        read(t);
        ++u[t];
    }
    /*clog<<"u:"<<endl;
    for(int i=1;i<=m;++i)
        clog<<i<<" "<<u[i]<<endl;
    clog<<"uend"<<endl;*/
    bool flag=1;
    srh.push(INF); //这个细节很重要，INF的值对此题没有影响，但是如果不加对第一个数的操作会RE的
#define x a[i]
#define y u[i]
    for(int i=1;i<=m;++i){
        if(flag)//ADD(x)
            if(x<srh.top()){
                lrh.push(x);
                flag=0;
            }
            else
                srh.push(x);
        else
            if(x<lrh.top()){//这一步是ADD的精华所在，对两个对做了等价变换
                srh.push(lrh.top());//i值前移，因而大根堆要把最大数给小根堆
                lrh.pop();
                lrh.push(x); 
            }
            else
                srh.push(x); 
        while(y--){//GET
//            clog<<"once in "<<i<<endl;
            if(flag){//这一步是GET的精华所在，对两个对做了等价变换
                write(srh.top());putchar('\n');
                lrh.push(srh.top());//i值后移，因而小根堆要把最小数给大根堆
                srh.pop();
            }
            else{
                write(lrh.top());putchar('\n');
                flag=1;
            }
        }
    }
//    fclose(stdin);
//    fclose(stdout);
    return 0;
}

```

---

## 作者：陈国凯 (赞：4)

算法：线段树+map+二分查找

首先强调一下这不是常规解法！时间复杂度O（nlognlogn），此外真是无知者无畏，不知道这是一道平衡树/堆的题目，直接上线段树乱搞竟然AC。


首先读入数据后先排序（学长有言，不知道干什么的时候先排序），然后用map记录一下排序好的数组中每个数字的位置（若有相同的元素将其压缩为1个位置，避免产生歧义，代码中的temp数组就是干这个的），之后就以压缩并去除重复元素的数组下标为基准构建线段树！线段树初始化时每个节点管理的数字和都是0（因为并没有插入进去任何数），然后每次需要GET时，先将前面尚未插入线段树的数据插入（插入位置问map），然后二分！由于排好序的线段树底层是单调递增的，因此每次以logn的时间复杂度查询从1到mid区间内已经有的数字个数之和，如果比要求的数字大，向左边的区间找，否则向右边的区间找，时间复杂度也是logn，故总体复杂度O(NlogNlogN)，可以在Linux下以接近800ms的擦边复杂度AC此题目，而Windows的Cena下TLE。。。另外洛谷抽风，cin会RE


```cpp
#include<iostream>
#include<map>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int m,n,ask[200010],addpos=1,mids,ans,l,r,realpos,counts=0;
long long a[200010],orin[200010],temp[200010],pre;
map<long long,int>mp;
struct rec{
    int l,r,sum;
}tree[200010<<2];
void build(int l,int r,int arrnum){
    if (l==r){
        tree[arrnum].l=tree[arrnum].r=l;
        tree[arrnum].sum=0;
        return;
    }
    tree[arrnum].l=l,tree[arrnum].r=r;
    tree[arrnum].sum=0;
    build(l,(l+r)>>1,arrnum<<1);
    build(((l+r)>>1)+1,r,(arrnum<<1)|1);
}
void add(int arrnum){
    if (tree[arrnum].l==tree[arrnum].r){
        ++tree[arrnum].sum;
        return;
    }
    int mid=(tree[arrnum].l+tree[arrnum].r)>>1;
    if (realpos<=mid) add(arrnum<<1);
    else add((arrnum<<1)|1);
    tree[arrnum].sum=tree[arrnum<<1].sum+tree[(arrnum<<1)|1].sum;
}
void ques(int arrnum){
    if (tree[arrnum].l>=1&&tree[arrnum].r<=mids){
        ans+=tree[arrnum].sum;
        return;
    }
    int mid=(tree[arrnum].l+tree[arrnum].r)>>1;
    if (mids<=mid) ques(arrnum<<1);
    else{
        ques(arrnum<<1);
        ques((arrnum<<1)|1);
    }
}
int main(){
    //ios::sync_with_stdio(false);
    //cin>>m>>n;
    scanf("%d%d",&m,&n);
    for (int i=1;i<=m;++i) scanf("%lld",&a[i]); //cin>>a[i];
    for (int i=1;i<=n;++i) scanf("%d",&ask[i]);//cin>>ask[i];
    memcpy(orin,a,sizeof(a));
    sort(ask+1,ask+1+n);
    sort(a+1,a+1+m);
    pre=1e18;
    for (int i=1;i<=m;++i){
        if (a[i]!=pre) temp[++counts]=a[i],pre=a[i];
    }
    memset(a,0,sizeof(a));
    memcpy(a,temp,sizeof(temp));
    m=counts;
    for (int i=1;i<=m;++i){
        mp.insert(make_pair(a[i],i));
    }
    
    build(1,m,1);
    for (int i=1;i<=n;++i){
        for (;addpos<=ask[i];++addpos){
            realpos=mp.find(orin[addpos])->second;
            add(1);
        }
        l=1,r=m;
        while (l<r){
            mids=(l+r-1)>>1;
            ans=0;
            ques(1);
            if (ans>=i) r=mids;
            else l=mids+1;
        }
        printf("%d\n",a[l]);
        //cout<<a[l]<<"\n";
    }
    return 0;
}

```

---

## 作者：YanYou (赞：3)

在机房被虐了一天，回家下定决心把这道刚刚炸掉的题 $A$ 掉。~~（学校测试此题拿了20分，结果从第二掉到了第七）~~

**好了，回归正题。**

## Solution

本题我是用堆做的。

建两个堆，大顶堆 $a$ 和 小顶堆 $b$ 。

读入每一步 ADD 操作，然后每读一步 GET 操作就往 $b$ 里插入 $(u[i]-u[i-1])$ 个节点。

### 重点： 
**再把 b 的根节点弹出并插入 a 中，接着把 a 中的根节点弹出并插入 b 中。**

**这样就使 a 中始终保持前 i 小的节点，那么 b 的根节点就是 i+1 后的 GET 操作应输出的数。**

完成一次 GET 后，再把 b 根节点弹出并插入 a 中，使 a 中节点数始终保持在 i 个。

大体思路就是这样，最好先自己写一遍代码哦。

## Code

```cpp
#include<cstdio>
using namespace std;

int n, m, cnt, x, t[200010];

struct Heap1{    //为了读者更容易理解，我手写的堆结构体。
    int len; int heap[200010];
    void put(int x){
        int fa, son; int t;
        len++; heap[len] = x; son = len;
        while (son!=1 && heap[son>>1]<heap[son]){
            t = heap[son]; heap[son] = heap[son>>1]; heap[son>>1] = t;
            son >>= 1;
        }
    }
    int get(){
        int ret=heap[1], t; int fa, son;
        heap[1] = heap[len]; len--; fa = 1; 
        while (fa<<1<=len){
            if ((fa<<1)+1>len || heap[fa<<1]>heap[(fa<<1)+1]) son = fa<<1;
            else son = (fa<<1)+1;
            if (heap[fa]<heap[son]){
                t = heap[fa]; heap[fa] = heap[son]; heap[son] = t;
                fa = son;
            } else break;
        }
        return ret;
    }
}a;

struct Heap2{
    int len; int heap[200010];
    void put(int x){
        int fa, son; int t;
        len++; heap[len] = x; son = len;
        while (son!=1 && heap[son>>1]>heap[son]){
            t = heap[son]; heap[son] = heap[son>>1]; heap[son>>1] = t;
            son >>= 1;
        }
    }
    int get(){
        int ret=heap[1], t; int fa, son;
        heap[1] = heap[len]; len--; fa = 1; 
        while (fa<<1<=len){
            if ((fa<<1)+1>len || heap[fa<<1]<heap[(fa<<1)+1]) son = fa<<1;
            else son = (fa<<1)+1;
            if (heap[fa]>heap[son]){
                t = heap[fa]; heap[fa] = heap[son]; heap[son] = t;
                fa = son;
            } else break;
        }
        return ret;
    }
}b;

int main(){
    scanf("%d%d",&n,&m);
    for (int i=1; i<=n; i++) scanf("%d",&t[i]);
    for (int i=1; i<=m; i++){
        scanf("%d",&x);
        while (cnt<x){ //这是重点
            cnt++;
            b.put(t[cnt]);
            a.put(b.get());
            b.put(a.get());
        }
        printf("%d\n",b.heap[1]);
        a.put(b.get());
    }
    return 0;
}
```


---

## 作者：zhengrunzhe (赞：3)

最近树题做多了一看题目：平衡树裸题

结果点开题解一看怎么全是堆…

分享一发splay题解

维护一棵Splay，支持插入，查k小

太裸了不多讲
```cpp
#include<cstdio>
class Splay
{
	private:
		struct tree
		{
			int value,cnt,size; //可能有重复数字 用cnt存重复个数 
			tree *fa,*son[2];
			inline tree(int key)
			{
				size=cnt=1;
				value=key;
				fa=son[0]=son[1]=NULL;
			}
			inline void pushup()
			{
				size=cnt;
				if (son[0])size+=son[0]->size;
				if (son[1])size+=son[1]->size;
			}
		}*root;
	public:
		inline bool relation(tree *p)
		{
			if (p&&p->fa)return p->fa->son[1]==p;
		}
		inline void connect(tree *&p,tree *&fa,bool which)
		{
			if (p)p->fa=fa;
			if (fa)fa->son[which]=p;
		}
		inline void rotate(tree *&p)
		{
			tree *fa=p->fa;
			bool lr=relation(p);
			connect(p,fa->fa,relation(fa));
			connect(p->son[lr^1],fa,lr);
			connect(fa,p,lr^1);
			fa->pushup();p->pushup();
		}
		inline void splay(tree *&p)
		{
			for (tree *fa;fa=p->fa;rotate(p))
				if (fa->fa)
					rotate(relation(fa)==relation(p)?fa:p);
			root=p;
		}
		inline void insert(int insertion)
		{
			if (root==NULL)
			{
				root=new tree(insertion);
				return;
			}
			tree *p=root;
			while (1)
			{
				if (p->value==insertion)
				{
					p->cnt++;
					p->pushup();
					if (p->fa)p->fa->pushup();
					splay(p);
					return;
				}
				tree *fa=p;
				bool direction=p->value<insertion;
				p=fa->son[direction];
				if (p==NULL)
				{
					p=new tree(insertion);
					connect(p,fa,direction);
					fa->pushup();
					splay(p);
					return;
				}
			}
		}
		inline int find_rank(int ranking)  //第k小
		{
			tree *p=root;
			while (1)
				if (p->son[0]&&ranking<=p->son[0]->size)
					p=p->son[0];
				else
				{
					ranking-=(p->son[0]?p->son[0]->size:0)+p->cnt;
					if (ranking<=0)return p->value;
					p=p->son[1];
				}
		}
}splay;
const int M=200001;
int n,m,a[M],j=1;
int main()
{
	scanf("%d%d",&m,&n);
	for (int i=1;i<=m;i++)scanf("%d",&a[i]);
	for (int i=1;i<=n;i++)
	{
		int u; //这里u不开数组，每读一个u就插入lastU和u之前的所有数字
		scanf("%d",&u);
		for (;j<=u;j++)splay.insert(a[j]); //j开全局变量，记录lastU
		printf("%d\n",splay.find_rank(i));
	}
	return 0;
}
```

---

## 作者：Jesselrj (赞：3)

### 前言
这道题真的水...

哪里有蓝题的难度...

### 题目描述
`Black Box`是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。

命令只有两种：

`ADD(x)`:把x元素放进`BlackBox`;

`GET`:i加1，然后输出`Blackhox`中第i小的数。

### 解题思路
首先，这道题，看到题目所说取第i小的数，首先想到的是平衡树，但是，只要稍加思考，就可以想到——我们可以用一个`vector`来维护这个有序的数列。

#### 具体操作
```cpp
arr.insert(lower_bound(arr.begin(), arr.end(), a[i]), a[i]);//lower_bound是找到一个当前这个数组内第一个小于等于x的位置。
```

### 完整代码
```cpp
#include <bits/stdc++.h>
#define SIZE 200100
using namespace std;

vector <int> arr; 
int n, m, a[SIZE], u[SIZE], k = 1;

int main() {
	arr.clear();
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> u[i];
	sort(u + 1, u + 1 + m);//有几个点的查询是无序的，卡了我20分钟.
	for (int i = 1; i <= n; i++) {
		arr.insert(lower_bound(arr.begin(), arr.end(), a[i]), a[i]);
		while (u[k] == i) cout << arr[k - 1] << endl, k++;
		if(k > m) break;//小小的优化，如果它没有查询了，后面的插入也是无价的了。
	}
	return 0;
}
```

---

## 作者：Ciyang (赞：3)

### 此题可以用优先队列,二叉堆,二叉排序树,平衡树来做. 我用了手写二叉排序树,然后过了...
#### 其实我本来想学平衡树的,结果自己写了一上午,最后写成二叉排序树了,而且还和别人写的不一样.
#### 所以我本来是按照[【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369) 的操作要求来写的,不过那个题TLE了第12个点,~~因此只能科学特判通过~~.但这个题完全可以用,毕竟数据不毒. 
#### 对于[二叉排序树](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91)极其简单,看定义就能理解,但写起来还是需要一些思考.在我的代码实现中,不是严格的二叉排序树,因为树中有键值相等的节点.
### 以下讲解:
#### 既然是个树,那么肯定有父节点和子节点,我用了指针思想实现,因此可能写起来较为麻烦,但没有多余空间.
#### 先放本题中二叉排序树的完整代码(已省去平衡树题目的部分操作):
```cpp
struct Tree {
	struct node {
		int _num, _tot;
		node *children[2];
		node(int _new_num) {
			_num= _new_num;
			_tot= 1;
			children[0]= children[1]= NULL;
		}
	} * mainnode;
	void push(int _new_num) {
		struct node *now_node= mainnode, *last_node= NULL;
		int w= -1;
		while(now_node != NULL) {
			++now_node->_tot;
			last_node= now_node;
			if(_new_num < now_node->_num) {
				w= 0;
				now_node= now_node->children[0];
			}
			else {
				w= 1;
				now_node= now_node->children[1];
			}
		}
		now_node= new node(_new_num);
		if(w != -1) {
			last_node->children[w]= now_node;
		}
		else {
			mainnode= now_node;
		}
		return;
	}
	int rank_num(int _last_rank) {
		struct node *now_node= mainnode;
		int lchildren_size;
		while(now_node != NULL) {
			if(now_node->children[0] != NULL)
				lchildren_size= now_node->children[0]->_tot;
			else
				lchildren_size= 0;
			if(_last_rank <= lchildren_size) {
				now_node= now_node->children[0];
			}
			else if(_last_rank == lchildren_size + 1) {
				return now_node->_num;
			}
			else {
				now_node= now_node->children[1];
				_last_rank-= lchildren_size + 1;
			}
		}
		return -1;
	}
	Tree() {
		mainnode= NULL;
	}
};
```
#### 我在树的结构体中,写了节点的子结构体.具体讲解如下:
```cpp
	struct node {
		int _num, _tot;
        //_num表示节点的键值,_tot表示此节点的所有子节点的数量(包括自己)
		node *children[2];
        //两个最近的子节点,childre[0]表示左节点
		node(int _new_num) {
        //构造函数,初始化节点使用
			_num= _new_num;
			_tot= 1;
			children[0]= children[1]= NULL;
           	//初始没有子节点,要把指针设为NULL
		}
	} * mainnode;
    //mainnode表示根节点,注意它也是个指针
```
#### 节点已经写完了,接下来就是操作
#### 此题有一个ADD操作,就是给树加节点,但树必须要满足二叉排序树的性质,因此要写一个push,或者叫insert,这个既可以用递归,也可以用循环.
```cpp
	void push(int _new_num) {
    //_new_num就是新插入的数
		struct node *now_node= mainnode, *last_node= NULL;
        //两个指针,now_node指向插入位置,last_node指向插入位置的父节点
		int w= -1;
        //w代表插入位置是左还是右
		while(now_node != NULL) {
        //插入位置是空指针就停止循环
			++now_node->_tot;
            //父节点的_tot都+1
			last_node= now_node;
            //因为now_node要变,所以last_node指向now_node当前指向的位置
			if(_new_num < now_node->_num) {
            //插入的数比节点的值小
				w= 0;
				now_node= now_node->children[0];
                //插入位置改为当前插入位置的左节点
			}
			else {
            //插入的数比节点的值相等或大
				w= 1;
				now_node= now_node->children[1];
                //插入位置改为当前插入位置的右节点
			}
		}
        //找到位置
		now_node= new node(_new_num);
		if(w != -1) {
			last_node->children[w]= now_node;
		}
		else {
        //w是-1代表插入位置是根节点
			mainnode= now_node;
		}
		return;
	}
```
#### 此题还有一个GET操作,查找排名为x的数,这就需要用到每个节点的_tot的值了
#### 这个操作大家可以画一个二叉排序树的图来理解,我给出一个标准的
![二叉排序树](https://cdn.luogu.com.cn/upload/pic/40056.png)
#### 根节点的_tot为8,就是树的所有节点个数.值为5的节点的_tot为4,值为15的节点的_tot为3.
#### 如果要找排行为5的数,那肯定是10.因此排行<=4的数一定就在10的左边,排行5的数一定是10,排行>5的数一定在10的右边,这样依次这样向下搜就行了.代码与push(insert)较相同.
```cpp
	int rank_num(int _last_rank) {
		struct node *now_node= mainnode;
		int lchildren_size;
        //记录当前节点的左节点的_tot值
		while(now_node != NULL) {
			if(now_node->children[0] != NULL)
				lchildren_size= now_node->children[0]->_tot;
			else
				lchildren_size= 0;
            //如果左节点是空指针那代表_tot为0
			if(_last_rank <= lchildren_size) {
				now_node= now_node->children[0];
			}
			else if(_last_rank == lchildren_size + 1) {
				return now_node->_num;
			}
			else {
				now_node= now_node->children[1];
				_last_rank-= lchildren_size + 1;
			}
		}
		return -1;
	}
```
#### 这就是此题的两个操作,二叉排序树的大部分操作都类似.如果想写更多的操作,可以照着[【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369) 这题来写(已经提到过了).
### 下面是本题完整代码:
### 评测状态(未开启O2):
### Accepted  100
### 用时: 494ms / 内存: 7608KB
```cpp
#include <iostream>
#include <stdio.h>
#include <time.h>
using namespace std;
namespace Cy {
	struct q_outstream {
		template < typename classT >
		inline q_outstream operator<<(const classT &e) const {
			if(e < 0) {
				putchar('-');
				(*this) << -e;
			}
			else {
				if(e > 9) (*this) << (e / 10);
				putchar(e % 10 + '0');
			}
			return (*this);
		}
		inline q_outstream operator<<(const char &c) const {
			putchar(c);
			return (*this);
		}
	} qout;
	struct q_int_instream {
		inline q_int_instream operator>>(int &e) const {
			e= 0;
			int f= 1, c= 0;
			while(c < '0' || c > '9') {
				if(c == '-') f= -1;
				c= getchar();
			}
			while(c >= '0' && c <= '9') e= e * 10 + c - '0', c= getchar();
			e= e * f;
			return (*this);
		}
	} qin_int;
}  // namespace Cy
struct Tree {
	struct node {
		int _num, _tot;
		node *children[2];
		node(int _new_num) {
			_num= _new_num;
			_tot= 1;
			children[0]= children[1]= NULL;
		}
	} * mainnode;
	void push(int _new_num) {
		struct node *now_node= mainnode, *last_node= NULL;
		int w= -1;
		while(now_node != NULL) {
			++now_node->_tot;
			last_node= now_node;
			if(_new_num < now_node->_num) {
				w= 0;
				now_node= now_node->children[0];
			}
			else {
				w= 1;
				now_node= now_node->children[1];
			}
		}
		now_node= new node(_new_num);
		if(w != -1) {
			last_node->children[w]= now_node;
		}
		else {
			mainnode= now_node;
		}
		return;
	}
	int rank_num(int _last_rank) {
		struct node *now_node= mainnode;
		int lchildren_size;
		while(now_node != NULL) {
			if(now_node->children[0] != NULL)
				lchildren_size= now_node->children[0]->_tot;
			else
				lchildren_size= 0;
			if(_last_rank <= lchildren_size) {
				now_node= now_node->children[0];
			}
			else if(_last_rank == lchildren_size + 1) {
				return now_node->_num;
			}
			else {
				now_node= now_node->children[1];
				_last_rank-= lchildren_size + 1;
			}
		}
		return -1;
	}
	Tree() {
		mainnode= NULL;
	}
};
using namespace Cy;
Tree tree;
int m, n, tmpx, lptr, sptr;
int num[200000];
int main() {
	qin_int >> m >> n;
	for(int i= 0; i < m; i++) qin_int >> num[i];
	while(n--) {
		qin_int >> tmpx;
		for(; lptr < tmpx; lptr++) {
			tree.push(num[lptr]);
		}
		qout << tree.rank_num(++sptr) << '\n';
	}
	return 0;
}
```
### 前面很多是快读入快输出(为了好看+方便使用),主程序还是很简单的


---

## 作者：Beauty_Moon (赞：2)

## 惯例 虽然我只有一篇题解但是还是要做宣传
[Alex Mondes' home](https://mark32.blog.luogu.org/)
## 作为一个蒟蒻，在课上被老师要求手写堆
老师调到了这道题，我一看。WOW蓝题。  
突然就害怕了。  
况且老师让我手写大小两根堆。  
结果题解里根本就没有QAQ.  
所以我自己来写一个。  
帮助像我一样的蒟蒻来理解堆（优先队列）的函数的真实面貌。  
## ~~拒绝CV~~
```
#include <iostream>
#include <cstdio>

int top1=0,top2=0;///用来记录每个堆中数的个数
using namespace std;
const int MAXN = 500000+10;
int s[MAXN],b[MAXN];///s 小根堆 b 大根堆
int a[MAXN],u[MAXN];///用来记录原数的数组
int gettop(int m){///取顶 在题中为GET
    if(m==1) return s[1];
    else return b[1];
}
void push(int m,int n){///压入堆 在题中为ADD
    /**有很多小伙伴和我说这题正常要写两个push函数。
    然而我在里面加了一个 n 这是用来控制这个函数到底是控制大根堆还是小根堆**/
    int now,next;///当前位置和下一位置
    if(n==1){///手动控制
    s[++top1]=m;
    now=top1;
    while(now>1){
        next=now>>1;
        if(s[now]>=s[next]) return;
        swap(s[now],s[next]);
        now=next;
        }
    }
    if(n==2){
    b[++top2]=m;
    now=top2;
    while(now>1){
        next=now>>1;
        if(b[now]<=b[next]) return;
        swap(b[now],b[next]);
        now=next;
        }
    }
}
void pop(int m){///pop函数也是一样手动控制
    int now,next;
    if(m==1){
    s[1]=s[top1--];
    now=1;
    while(now*2<=top1){
        next=now*2;
        if(next<top1&&s[next+1]<s[next])next++;
        if(s[now]<=s[next]) return;
        swap(s[now],s[next]);
        now=next;
        }
    }
    else{
    b[1]=b[top2--];
    now=1;
    while(now*2<=top2){
        next=now*2;
        if(next<top2&&b[next+1]>b[next])next++;
        if(b[now]>=b[next]) return;
        swap(b[now],b[next]);
        now=next;
        }
    }
    return ;
}
int main()
{
    int m,n;
    scanf("%d %d",&m,&n);
    for(int i=1;i<=m;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) scanf("%d",&u[i]);
    int p=0;
    for(int i=1;i<=n;i++)
    {
        while(p<u[i]&&i==1){
            p++;
            push(a[p],1);
        }
        while(p<u[i]&&i!=1)
        {
            p++;
            push(a[p],2);
            push(gettop(2),1);
            pop(2);
        }
        printf("%d\n",gettop(1));
        push(gettop(1),2);
        pop(1);
    }
    return 0;
}

```
 

---

## 作者：Trinity (赞：2)

# P1801 黑匣子_NOI导刊
## 题目描述
有一整数数组有一特殊变量 $i$ ，初始为 $0$。  
有两操作：$ADD(x)$ : 把 $x$ 加入数组。  
$~~~~~~~~~~~~~~~~GET$ : $i++$ , 输出数组中第 $i$ 小的数。  
数据读入方式：$M$ 个数，表示将要加入数组的数；$N$ 个数 $u$ ，**表示第** $u$ **个元素放入数组后启动$GET$命令。**
## 分析
$1$ . 你可以把这道题想的很简单，$STL$ 大法就可以拿部分分（亲测加氧气$50$），优化一下想一想方法就可以正解秒掉 ($132ms$) ；你也完全可以把这当作数据结构题，线段树或平衡树维护即可暴力求答案 （奇慢，$1000ms$) 。  
$2$ . 题目的读入方法很奇怪，暗示你在线处理（ 当然没必要 ）。
## 解答
暴力：思想就简单粗暴，系统的优先队列priority_queue就很好，每次 $GET$ 取出前$i-1$个堆中的数，输出堆顶后，再加回去，很显然数据毒瘤的话，一次查询就相当于要遍历两遍数组，$TLE$，代码就算了。  

正解（by [huzujun](https://blog.csdn.net/huzujun/article/details/49470135)）：双堆乱搞。来个大根堆和小根堆，在线处理，小根堆充当题目中的那个黑匣子，加入数据。但一旦到达要$GET$之时，将任务交给大根堆。把堆顶传递给大根堆，那么大根堆中就存着小根堆中最小的 $i$ 个数。然后我们继续读数 $a$ ，如果 $a$ 比大根堆堆顶还要大，那它进入小根堆继续处理；但如果小，那么我们会知道 $a$ 属于数组前 $i$ 小，那么堆顶就没有它存在的意义（就像队列一样，被挤出去了），回到小根堆。整个程序就以这种形式运行，避免不必要的枚举，还能在线解决问题。  

杂技写法：很多同学都使用平衡树来暴力维护我们的暴力做法，很显然，时间上能过，但不优秀。现在贴一个线段树维护的链接（反正我不会）[520的堕落园](https://www.luogu.org/blog/five20/solution-p1801)。  

上代码，前方神奇小根堆（懒得打小根堆，直接负数处理），极难看清。
```cpp
    //p大根堆，q小根堆。
	m=read(),n=read();
    for(int i=1;i<=m;i++)a[i]=read();
    for(int i=1;i<=n;i++)
    {
        u=read();
        while(cnt<u)
        {
            ++cnt;
            if(!p.empty()&&a[cnt]<p.top())//一定要判空，否则RE等着你。
            {
                //cout<<a[cnt]<<' ';
                q.push(-p.top());//负数使人头皮发麻。
                p.pop();
                p.push(a[cnt]);//代替。
            }
            else q.push(-a[cnt]);//直接加入小根堆。
        }
        printf("%lld\n",-q.top());
        p.push(-q.top());
        q.pop();
    }
    return 0;
```
平衡树，看看就好。
```cpp
inline int _search(int x,int w)
{
    if(a[x]==w)return x;
    while(a[x]!=w)
    {
        if(a[x]>w){if(son[x][0])x=son[x][0];else break;}
        if(a[x]==w)return x;
        if(a[x]<w){if(son[x][1])x=son[x][1];else break;}
    }
    return x;
}
inline void rotate(int x)
{
    int y=father[x],z=father[y];
    if(son[z][0]==y)son[z][0]=x;else son[z][1]=x;
    father[x]=z;
    if(son[y][0]==x)son[y][0]=son[x][1],father[son[x][1]]=y,son[x][1]=y;
    else son[y][1]=son[x][0],father[son[x][0]]=y,son[x][0]=y;
    father[y]=x;
    many[y]=many[son[y][0]]+many[son[y][1]]+num[y];
    many[x]=many[son[x][0]]+many[son[x][1]]+num[x];
}
inline void splay(int x)
{
    while(father[x])
    {
        int y=father[x],z=father[y];
        if(z==0)rotate(x);
        else
        {
            if((y==son[z][0])^(x==son[y][0]))rotate(x);else rotate(y);
            rotate(x);
        }
    }
    root=x;
}
inline LL _find(int x)
{
    int pos=root;
    while(!(x>=many[son[pos][0]]+1&&x<=many[son[pos][0]]+num[pos])&&pos!=0)
    {
        if(x>many[son[pos][0]]+num[pos])x-=many[son[pos][0]]+num[pos],pos=son[pos][1];
        else pos=son[pos][0];
    }
    return a[pos];
}
inline void _insert(int x)
{
    if(sum==0){a[1]=x,num[1]=1,many[1]=1,father[1]=0,root=1,sum=1;return ;}
    int pos=_search(root,x),e=0;
    if(a[pos]==x){num[pos]++,e=pos;}
    else
    {
        ++sum,a[sum]=x,many[sum]=1,num[sum]=1,father[sum]=pos;
        if(x<a[pos])son[pos][0]=sum;
        else son[pos][1]=sum;
    }
    while(pos)many[pos]++,pos=father[pos];
    if(e)splay(e);else splay(sum);
}//Splay维护平衡树，我不解释。
int main()
{
    m=read(),n=read();
    memset(a,-0x7f,sizeof(a));
    for(int i=1;i<=m;i++)data[i]=read();
    for(int i=1;i<=n;i++)u[i]=read();
    for(int i=1;i<=n;i++)
    {
        while(cnt<u[i])_insert(data[++cnt]);//多么暴力。
        idx++;
        printf("%lld\n",_find(idx));//输出第idx大。
    }
    return 0;
}
```
## 总结
$1$ . $STL$ 练手题。  
$2$ . 暴力出奇迹。  
不喜勿喷。

---

## 作者：PrimoPan (赞：2)

看到没人写SB Tree 我来贴个

其实就是平衡树的模板题啊

离线做 每次把a[i]插进去 读到b[top]=i的时候查一下再top++一下即可

```cpp
#include <bits/stdc++.h>
using namespace std;
struct s  
{  
    int key,left,right,size;  
}tree[200000+5];  
int top;  
void left_rot(int &x)// 左旋  
{  
    int y=tree[x].right;  
    tree[x].right=tree[y].left;  
    tree[y].left=x;  
    tree[y].size=tree[x].size;  
    tree[x].size=tree[tree[x].left].size+tree[tree[x].right].size+1;  
    x=y;  
}  
void right_rot(int &x)//右旋  
{  
    int y=tree[x].left;  
    tree[x].left=tree[y].right;  
    tree[y].right=x;  
    tree[y].size=tree[x].size;  
    tree[x].size=tree[tree[x].left].size+tree[tree[x].right].size+1;  
    x=y;  
}  
void maintain(int &x,bool flag)//维护SBT状态  
{  
    if(flag==false)//左边  
    {  
        if(tree[tree[tree[x].left].left].size>tree[tree[x].right].size)//左孩子的左孩子大于右孩子  
            right_rot(x);  
        else  
            if(tree[tree[tree[x].left].right].size>tree[tree[x].right].size)//左孩子的右孩子大于右孩子  
            {  
                left_rot(tree[x].left);  
                right_rot(x);     
            }  
            else  
                return;  
    }  
    else//右边  
    {  
        if(tree[tree[tree[x].right].right].size>tree[tree[x].left].size)//右孩子的右孩子大于左孩子  
            left_rot(x);  
        else  
            if(tree[tree[tree[x].right].left].size>tree[tree[x].left].size)//右孩子的左孩子大于左孩子  
            {  
                right_rot(tree[x].right);  
                left_rot(x);  
            }  
            else  
                return;  
    }  
    maintain(tree[x].left,false);  
    maintain(tree[x].right,true);  
    maintain(x,true);  
    maintain(x,false);  
}  
void insert(int &x,int key)//插入  
{  
    if(x==0)  
    {  
        x=++top;  
        tree[x].left=0;  
        tree[x].right=0;  
        tree[x].size=1;  
        tree[x].key=key;  
    }  
    else  
    {  
        tree[x].size++;  
        if(key<tree[x].key)  
            insert(tree[x].left,key);  
        else  
            insert(tree[x].right,key);//相同元素可插右子树  
        maintain(x,key>=tree[x].key);  
    }  
}  
int remove(int &x,int key)//利用后继删除  
{  
    tree[x].size--;  
    if(key>tree[x].key)  
        remove(tree[x].right,key);  
    else  
        if(key<tree[x].key)  
            remove(tree[x].left,key);  
        else  
            if(tree[x].left!=0&&tree[x].right==0)//有左子树，无右子树  
            {  
                int temp=x;  
                x=tree[x].left;  
                return temp;  
            }  
            else  
                if(!tree[x].left&&tree[x].right!=0)//有右子树，无左子树  
                {  
                    int temp=x;  
                    x=tree[x].right;  
                    return temp;  
                }  
                else  
                    if(!tree[x].left&&!tree[x].right)//无左右子树  
                    {  
                        int temp=x;  
                        x=0;  
                        return temp;  
                    }  
                    else//左右子树都有  
                    {  
                        int temp=tree[x].right;  
                        while(tree[temp].left)  
                            temp=tree[temp].left;  
                        tree[x].key=tree[temp].key;  
                        remove(tree[x].right,tree[temp].key);  
                    }  
} 
int select(int &x,int k)//选第k小的数  
{  
    int r=tree[tree[x].left].size+1;  
    if(r==k)  
        return tree[x].key;  
    else  
        if(r<k)  
            return select(tree[x].right,k-r);  
        else  
            return select(tree[x].left,k);  
}   
void read(int &x)
{
    char c;
    int num=0;
    int f=1;
    c=getchar();
    while (c<'0' || c>'9')
    {
        if (c=='-') f=f*-1;
        c=getchar();
    }
    while (c>='0' && c<='9')
    {
        num=num*10+c-'0';
        c=getchar();
    }
    x=num*f;
    return ;
}
int main()
{
    int n,m;
    read(m);
    read(n);
    int a[200000];
    int b[200000];
    for (int i=1;i<=m;i++)
      read(a[i]);
    for (int i=1;i<=n;i++)
      read(b[i]);
    //for (int i=1;i<=n;i++)
     /// cout<<b[i]<<" ";
    int top=1;
    //int num=-1;
    int x=0;
    for (int i=1;i<=m;i++)
    {
        num++;
        insert(x,a[i]);
        while (b[top]==i)
        {
            cout<<select(x,top)<<endl;
            top++;
        }
    }
}
```

---

## 作者：Camber (赞：2)

蒟蒻第一次发题解......还请各位神犇多多包涵


难道stl就那么不吃香嘛

于是懒得手打的我找到了algorithm的heap操作（两眼放光）

懒惰推动科技的进步

思路还是参照楼下的

>开两个堆，一个大根堆维护1——i-1小的数，一个小根堆维护i——N小的数，当每次查询时，输出小根堆顶，从小根堆取最小数到大根堆；如果更新时小根堆顶小于大根堆顶，交换两堆顶，维护大根堆。

输入的u[]好像是无序的 直接导致卡5个点WA 从昨晚看到现在才发现..


```cpp
//LP1801/Blackbox.cpp
//by Stannum
//不想手打堆啊
//发现stl里有堆操作! 
#include<algorithm>
#include<cstdio>
#include<vector>
#include<queue>
#include<iostream>
#include<functional>
#include<cstring>
using namespace std;
long long M,N,queryi=1;
long long A[200005],u[200005];
vector<long long> heap1;
vector<long long> heap2;
void query(){
    long long tem1,tem2;
    for(int i=1;i<=M;i++){
        heap1.push_back(A[i]);
        push_heap(heap1.begin(),heap1.end(),greater<int>());
        if(!heap1.empty()&&!heap2.empty()&&heap1.front()<heap2.front()){
            swap(heap1[0],heap2[0]);
            pop_heap(heap2.begin(),heap2.end());
            push_heap(heap2.begin(),heap2.end());
        }
        while(u[i]){
            cout<<heap1[0]<<endl;
            heap2.push_back(heap1.front());
            pop_heap(heap1.begin(),heap1.end(),greater<int>());
            heap1.pop_back();
            push_heap(heap2.begin(),heap2.end());
            u[i]--;
        }
    }
}
void read_in(){
    for(int i=1;i<=M;i++)cin>>A[i];
    memset(u,0,sizeof(u));
    for(int i=1;i<=N;i++){
        int x;cin>>x;
        u[x]++;
    }
}
int main(){
    cin>>M>>N;
    read_in();
    query();
}
```

---

## 作者：hanzhongtlx (赞：1)

## [更好的阅读体验点这里](https://www.cnblogs.com/tlx-blog/p/12354465.html)   
虽然题解很多，也有权值线段树，但我的和他们似乎**不尽相同**，跑的也挺快。   
所谓权值线段树，就是用线段树来存储权值。   
那什么是权值呢？似乎小学~~初中~~学统计的时候了解到，他是**描述数在数据中比例大小的量**，这里用作**此数出现的次数**。  
### 建树  
~~做法显然~~。   
我们用$cnt_i$表示第$i$个数出现的次数，那么可以这样：
```
void update(int k){a[k].sum=a[k<<1].sum+a[k<<1|1].sum;}
void build(int k,int l,int r)
{
	a[k].l=l,a[k].r=r;
	int mid=(l+r)>>1;
	if(l==r)
	{
		a[k].sum=cnt[l];//赋值
		return;
	}
	build(k<<1,l,mid),build(k<<1|1,mid+1,r);、、向下递归
	update(k);//动态更新点区间和
}
```
### 之后  
你是不是还在疑问这是在回答什么问题？  
对这就是询问所有数中第$x$小值。  
#### 分析  
如何运用权值线段树呢？   
很简单，我们每次查询下左儿子的权值和$sum$，如果$x\geqslant sum$,就向右儿子递归询问第$x-sum$小，否则向左儿子递归找第$x$值就好了。  
有没有发现纰漏？  
这个数组必须有单调性。    
那就排序啊......   
反正排序是$O(n\log n)$的，线段树也是$O(n\log n)$的，不会成为瓶颈。    
这里先不给代码了，下面再说。
### 其他的东西   
我们想到线段树是单调数组，而使用是非常不便。  
这就需要一种给力的**映射关系**。  
~~其实就是离散化了~~。
这里就有代码了：
```
struct Node
{
	int val,id;
}t[MAXN];
bool cmp(Node n,Node m)
{
	return n.val<m.val;
} 
int b[MAXN],num[MAXN],cnt[MAXN],c=0;
void hash(int n)
{
	sort(t+1,t+n+1,cmp);//结构体排序
	for(int i=1;i<=n;i++)
	{
		if(num[c]!=t[i].val) b[t[i].id]=++c,num[c]=t[i].val;//如果和上一个不同
		else b[t[i].id]=c;
		cnt[c]++;
	}
}
```
慢慢来，比较绕。   
$b[]$是原数组到离散化数组的映射，而$num[]$反之。  
举个栗子：  
数据：$5,12,-6,7,5$中，    
$b[1](t[1].val=5)=2,b[2](t[2].val=12)=4$;   
$ps$:这里给出的下标是未排序的。      
$num[1]=-6,num[3]=7$;   
$cnt[2]=2(num[2]=num[3]=5)$。  
### 回到上题  
这样就可以求第$x$小值了。   
用上面的思想解决：
```
int query(int k,int x)
{
	if(a[k].l==a[k].r) return num[a[k].l];//找到了
	else if(a[k<<1].sum>=x) return query(k<<1,x);//在左儿子中
	else return query(k<<1|1,x-a[k<<1].sum); //在右儿子中，记得减一下
}
```
### 题解  
你基本已经学会了权值线段树树了，现在来看这个题：   
题目链接：[P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)   
考虑权值线段树，加点并不好实现，不如**强制离线**，倒着试试。  
删除一个数就十分简单了，我们只需用原数到离散化数组的映射关系，将此数对应的$cnt--$就好了，把答案存一下，逆序输出来即可。
下面是简单的单点修改：
```
void modify(int k,int x,int y)//现在在k点，目标是将x号搞成y
{
	int mid=(a[k].l+a[k].r)>>1;
	if(a[k].l==a[k].r)//找到目标
	{
		a[k].sum=y;
		return;
	}
	else if(x<=mid) modify(k<<1,x,y);
	else modify(k<<1|1,x,y);
	update(k);//仍然记得更新
}
```  
总的说，这样的复杂度是$O((n+m)\log n)$的，可已通过此题。   
下面放上$AC$代码：
## $Code$:
```
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int MAXN=2e5+5;
struct Node
{
	int val,id;
}t[MAXN];
bool cmp(Node n,Node m)
{
	return n.val<m.val;
} 
int b[MAXN],num[MAXN],cnt[MAXN],c=0;//num是hash数组到原数组的映射。
/*num[2]=12,指原数组第二大的值为12*/ 
void hash(int n)
{
	sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		if(num[c]!=t[i].val) b[t[i].id]=++c,num[c]=t[i].val;
		else b[t[i].id]=c;
		cnt[c]++;
	}
}
struct node
{
	int l,r,sum,val;
	node()
	{
		l=r=sum=0;
	}
}a[MAXN<<2];
void update(int k){a[k].sum=a[k<<1].sum+a[k<<1|1].sum;}
void build(int k,int l,int r)
{
	a[k].l=l,a[k].r=r;
	int mid=(l+r)>>1;
	if(l==r)
	{
		a[k].sum=cnt[l];
		return;
	}
	build(k<<1,l,mid),build(k<<1|1,mid+1,r);
	update(k);
}
int query(int k,int x)
{
	if(a[k].l==a[k].r) return num[a[k].l];
	else if(a[k<<1].sum>=x) return query(k<<1,x);
	else return query(k<<1|1,x-a[k<<1].sum); 
}
void modify(int k,int x,int y)
{
	int mid=(a[k].l+a[k].r)>>1;
	if(a[k].l==a[k].r)
	{
		a[k].sum=y;
		return;
	}
	else if(x<=mid) modify(k<<1,x,y);
	else modify(k<<1|1,x,y);
	update(k);
}
int n,m,l[MAXN],now,ans[MAXN];
int main()
{
	scanf("%d%d",&n,&m);
	now=m;
	for(int i=1;i<=n;i++) scanf("%d",&t[i].val),t[i].id=i;
	for(int i=1;i<=m;i++) scanf("%d",&l[i]);
	hash(n);
	build(1,1,c);
	for(int i=n;i>=1;i--)
	{
		while(i==l[now]) ans[now]=query(1,now),now--;//此时有询问，查询第now小值，并更新now
		,modify(1,b[i],--cnt[b[i]]);//将数对应的点权值减一
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);//将存储的答案输出
	return 0; 
}
```
这个版本的权值线段树会跑$900\;ms$，翻翻记录，还挺快呢。

---

## 作者：wmy_goes_to_thu (赞：1)

看到了一堆写 Treap 和 Heap 的 dalao，蒟蒻我发一篇树状数组吧。

很简单，先离散化一下（元素太大），然后把所有的 $1 \sim m$ 的数都放到一个维护出现次数前缀和的树状数组中。每次如果插入元素，就把这个元素以后的数都加 $1$，如果查询，则二分即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005],b[200005],g[200005],ff[200005],xn;
int mp1[1000005],mp2[1000005];
int c[200005];
void insert(int p)
{
	while(p<=xn)c[p]++,p+=p&-p;
}
int query(int p)
{
	int ans=0;
	while(p)ans+=c[p],p-=p&-p;
	return ans;
}
int rank(int x)
{
	int l=1,r=xn;
	while(l<=r)
	{
		int mid=l+r>>1;
		if(query(mid)<x)l=mid+1;
		else r=mid-1;
	}
	return l;
}
int main()
{
	int n,m,snake=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i],ff[i]=a[i];
	for(int i=1;i<=m;i++)cin>>b[i],g[b[i]]++;
	sort(ff+1,ff+n+1);
	xn=unique(ff+1,ff+n+1)-ff-1;
	for(int i=1;i<=n;i++)
	{
		int r=lower_bound(ff+1,ff+xn+1,a[i])-ff;
		mp1[i]=r,mp2[r]=a[i];
	}
	for(int i=1;i<=n;i++)
	{
		insert(mp1[i]);
		for(int j=1;j<=g[i];j++)cout<<mp2[rank(++snake)]<<endl;
	}
	return 0;
}
```


---

## 作者：11223344w (赞：1)

权值树状数组

离线后用倍增的方法求第K大

时间复杂度只有一个log

详见蓝书

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N=2e5+5;
int n,m,b[N],d[N],c[N],cnt;
struct A{int x,id; }a[N];
bool cmp(A i,A j) {
	return i.x<j.x;
}

inline void add(int x) {
	for(int i=x;i<=cnt;i+=i&-i) c[i]++;
}

inline int kth(int x) {
	int ret=0;
	for(int i=18;i>=0;i--) {
		if(ret+(1<<i)<=cnt&&c[ret+(1<<i)]<x) {
			ret+=(1<<i),x-=c[ret];
		}
	}
	ret++;
	return ret;
}


int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i].x),a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) {
		if(i==0||a[i].x!=a[i-1].x) {
			d[++cnt]=a[i].x;
		}
		b[a[i].id]=cnt;
	}
	int l=1;
	for(int i=1;i<=m;i++) {
		int t; scanf("%d",&t);
		while(l<=t) {
			add(b[l]),l++;
		}
		printf("%d\n",d[kth(i)]);
	}
	return 0;
} 
```


---

## 作者：LordLeft (赞：1)

首先，我们来看看这个题目要我们干什么：

>GET:i加1，然后输出Blackhox中第i小的数。

可以，这很划分树。

但是这道题并不是裸的第$K$大，它还要插入一些数字。我们考虑一下，它只要求我们求出整体第$K$大，那么我们完全可以把所有操作离线下来，构造出一个长度为插入操作总次数的序列，那么每次询问其实就是求区间$[1,x]$的第$K$大，其中$x$是该询问之前的插入总次数。

然后你发现这个题目的输入已经帮你离线好了(好良心啊

之后套个划分树的板子就好了

时空复杂度均为$O(n \log n)$

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
int read(){
	int w=0;
	bool s=0;
	char c=getchar();
	while(!isdigit(c)){
		s=(c=='-');
		c=getchar();
	}
	while(isdigit(c)){
		w=w*10+c-'0';
		c=getchar();
	}
	return s?-w:w;
}
const int N=200005,M=20;
int n,m,q;
struct Tree{
	#define mid ((le+ri)>>1)
	#define lson le,mid,dep+1
	#define rson mid+1,ri,dep+1
	struct Node{
		int num[N],toleft[N];
	};
	Node t[M];
	int sorted[N];
	void build(int le,int ri,int dep){
		if(le==ri){
			return;
		}
		int key=sorted[mid];
		int equ=mid-le+1;
		for(int i=le;i<=ri;i++){
			if(t[dep].num[i]<key){
				equ--;
			}
		}
		int tl=0;
		int it1=le-1,it2=mid;
		for(int i=le;i<=ri;i++){
			int now=t[dep].num[i];
			if(now<key||(now==key&&equ)){
				if(now==key){
					equ--;
				}
				tl++;
				t[dep+1].num[++it1]=now;
			}
			else{
				t[dep+1].num[++it2]=now;
			}	
			t[dep].toleft[i]=tl;	
		}
		build(lson);
		build(rson);
	}
	int query(int le,int ri,int dep,int x,int y,int z){
		if(le==ri){
			return t[dep].num[le];
		}
		int tl=0,del=t[dep].toleft[y];	
		if(le!=x){
			tl=t[dep].toleft[x-1];
			del-=tl;
		}	
		int nx,ny;	
		if(del>=z){
			nx=le+tl;
			ny=nx+del-1;
			return query(lson,nx,ny,z);
		}
		else{	
			nx=mid+1+x-tl-le;
			ny=nx+y-x-del;
			return query(rson,nx,ny,z-del);
		}	
	}	
	#undef lson
	#undef rson
	#undef mid
};
Tree T;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		T.sorted[i]=read();
		T.t[0].num[i]=T.sorted[i];
	}
	sort(T.sorted+1,T.sorted+1+n);
	T.build(1,n,0);
	int x,tmp=0;
	for(int i=1;i<=m;i++){
		x=read();
		tmp++;
		int ans=T.query(1,n,0,1,x,tmp);
		printf("%d\n",ans);
	}
	return 0;
}
```
GL~

---

## 作者：Accoty_AM (赞：1)

# 平衡树 Treap

~~最简单的平衡树~~

每一个点rand一个值，在保证二叉搜索树性质的基础上保证堆性质

值得一说的是旋转
son[p][0] 是左儿子 son[p][1] 是右儿子

为了同时满足堆性质（小根堆），需要把rand值小的转上来

拿左儿子为例 

根右儿子变成左儿子的右儿子

左儿子的右儿子变成根

根的父亲连到根的左儿子上

这样就完成了旋转

下面这份代码可同时完成左旋和右旋（切记 &p 代表 son[f][p] 也就是根父亲的指向根的"指针"）

```cpp
#define ls son[p][0]
#define rs son[p][1]
void ros(int &p,int x){
	int tt=son[p][x];
	son[p][x]=son[tt][x^1];
	son[tt][x^1]=p;
	up(p);up(tt);
	p=tt;
}
```

完全代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
inline  int read (){
	rg char ch=getchar();
	rg int x=0,f=0;
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
} 
int n,m;
int u[200020],a[200020];
namespace Tree{
	int son[200020][2],rote;
	int poe[200020],sz[200020],tot,w[200020];
	#define ls son[p][0]
	#define rs son[p][1]
	void up(int p){
		sz[p]=sz[ls]+sz[rs]+1;
	}
	void ros(int &p,int x){
		int tt=son[p][x];
		son[p][x]=son[tt][x^1];
		son[tt][x^1]=p;
		up(p);up(tt);
		p=tt;
	}
	void add(int x,int &p){
		if(!p){
			p=++tot;w[p]=x;poe[p]=rand(),sz[p]=1;
			return;
		}
		++sz[p];
		if(x<=w[p]){
			add(x,ls);
			if(poe[ls]<poe[p]) ros(p,0);
		}else{
			add(x,rs);
			if(poe[rs]<poe[p]) ros(p,1);
		}
	}
	int  rank(int x,int p){
		if(sz[ls]==x-1) return w[p];
		if(x<=sz[ls]) return rank(x,ls);
		return rank(x-sz[ls]-1,rs);
	}
}
using namespace Tree;
int main(){
	srand(time(NULL));
	m=read(),n=read();
	for(int i=1;i<=m;++i) a[i]=read();
	for(int i=1;i<=n;++i) u[i]=read();
	int l=1;
	for(int i=1;i<=n;++i){
		while(l<=u[i]){
			add(a[l],rote);
			++l;
		}
		printf("%d\n",rank(i,rote));
	}
	return 0;
}
```
time 667ms



---

## 作者：汇文客 (赞：1)

来看一看pbds库里的红黑树吧：

```cpp
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>//这是两个头文件
#include<bits/stdc++.h> 
using namespace  __gnu_pbds;//与std类似的用法
using namespace std; 
tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update>t;//红黑树的定义
inline long long read()//C++若是IO量大的话，必须加读入优化
{
    long long x=0,f=1;
    char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())
    if(ch=='-')f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())
    x=x*10+ch-48;
    return x*f;
}
int main()
{
    long long n,m,i,j,u[200001],v[200001];
    v[0]=0;u[0]=0;
    m=read();n=read();
    for(i=1;i<=m;i++)u[i]=read();
    for(i=1;i<=n;i++)v[i]=read();
    sort(v,v+n+1);
    for(i=0;i<n;i++)
    {
        for(j=v[i]+1;j<=v[i+1];j++)t.insert((u[j]<<20)+j);//考虑到有可能重复，给每个数放大后加个小尾巴
        printf("%d\n",(*t.find_by_order(u[0])>>20));//一步到位！哈哈
        u[0]++;
    }
    return 0;
}
pbds库的玩法可不止这个，愿与大家共同探索。
```

---

## 作者：wzhhahah (赞：1)

这道题可以用两个堆解决(没学过Splay的蒟蒻):


data数据堆,其堆顶元素为黑匣子第i个数

back处理堆,每次ADD加入一个数据需先进入这个堆(如果这个数比堆顶小的话),从堆顶取出更新的黑匣子的第i个数


原理:data堆存储的其实是黑匣子中i指针及其后面的元素,而ADD加入的数可能会修改整个堆

如果这个数比堆顶小,他可能会取代堆顶的元素,如果他更小的话,可能会把i下标前的数挤进去

back堆就是用来解决这个操作的,它维护了已由于GET而从堆顶上取出的数据

那么back的堆顶一定是仅比data堆顶小一点的那个会被挤上去的数

如果这个数比堆顶大,那就在i下标后面了,就尽管入堆了

那么整体的入堆条件就是:

如果ADD比back堆顶小,则入back堆

否则,则入data堆


```cpp
#include <cstdio>
#include <queue>

using namespace std;

//基础数据
int m, n;
int a[200001];

//数据处理
struct Greater        //不知道怎么回事VS就是没有greater,只能手写qwq
{
    bool operator () (const int& a, const int& b)
    {
        return a > b;
    }
};
priority_queue<int, vector<int>, Greater> _data;
priority_queue<int, vector<int> > back;

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= m; i++)
        scanf("%d", &a[i]);
    for (int i = 0, k = 1, t; i < n; i++)
    {
        scanf("%d", &t);
        for (; k <= t; k++)
        {
            if (back.empty() || a[k] > back.top())
                _data.push(a[k]);
            else
            {
                back.push(a[k]);
                _data.push(back.top());
                back.pop();
            }
        }
        printf("%d\n", _data.top());
        back.push(_data.top());
        _data.pop();
    }

    return 0;
}
```

---

## 作者：SNiFe (赞：1)

这道题其实就是个splay裸题，而且只用写insert，findx，clear，update，rotate，splay这几个函数，加起来不到100行代码。

思路很简单，for（lef->u[i]）insert（a[++lef]）。然后查找排名为i的就好了。

#CODE
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=300000+10;
int n,m,add=0,a[N],u[N],fa[N],ch[N][2],size[N],sz=0,cnt[N],key[N],root;
void clear(int x)
{
    cnt[x]=fa[x]=key[N]=size[N]=ch[x][1]=ch[x][0]=0;
}
bool get(int x)
{
    return ch[fa[x]][1]==x;
}
void update(int x)
{
    if(!x)return;
    size[x]=cnt[x];
    if(ch[x][1])size[x]+=size[ch[x][1]];
    if(ch[x][0])size[x]+=size[ch[x][0]];
}
void rotate(int x)
{
    int old=fa[x],oldfa=fa[old],son=get(x);
    ch[old][son]=ch[x][son^1],fa[ch[x][son^1]]=old;
    fa[old]=x,ch[x][son^1]=old,fa[x]=oldfa;
    if(oldfa)ch[oldfa][ch[oldfa][1]==old]=x;
    update(x),update(old);return;
}
void splay(int x)
{
    for(int f;f=fa[x];rotate(x))
    if(fa[f])rotate(get(x)==get(f)?f:x);
    root=x;
}
void insert(int x)
{
    if(!root)
    {
        root=++sz;
        cnt[root]=size[root]=1;
        ch[root][1]=ch[root][0]=0;
        key[root]=x;return;
    }
    int now=root,father=0;
    while(1)
    {
        if(x==key[now])
        {
            cnt[now]++;
            update(now),update(father);
            splay(now);return; 
        }
        father=now,now=ch[now][key[now]<x];
        if(!now)
        {
            now=++sz;
            cnt[now]=size[now]=1;
            ch[now][1]=ch[now][0]=0;
            key[now]=x;fa[now]=father;
            ch[father][key[father]<x]=now;
            update(father);splay(now);return;
        }
    }
}
int findx(int x)
{
    int now=root;
    while(1)
    {
        if(ch[now][0]&&x<=size[ch[now][0]])now=ch[now][0];
        else
        {
            int tmp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now];
            if(x<=tmp)return key[now];
            x-=tmp;now=ch[now][1];
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&u[i]);
    }
    int lef=0;
    for(int i=1;i<=m;i++)
    {
        while(lef<u[i])
        {
            insert(a[++lef]);
        }
        printf("%d\n",findx(i));
    }
}
```

---

## 作者：lwhllw (赞：1)

数结渣表示不会平衡树，不知道怎么用堆处理。

然后用数组模拟双向链表弄了一下。

正难反易，把加节点过程当成删点就很容易了。

1.离线处理，先读入所有数据。

2.排序并维护每一个节点排序后的位置。

3.最开始指向最后一个访问节点，然后用双向链表删除操作删除节点，判断一下删除的节点和当前查找的（第i小）的节点的大小关系，如果删除节点小的话，将当前查找节点指针指向更大的下一个节点(有点抽象，看代码也可以)，倒序保存答案。


```cpp
const maxn=200010;
var i,j,k,l,m,n,now,link:longint;
    del,dx,d:array[1..maxn]of longint;
    a,next,pre:array[0..maxn]of longint;
    v,sp:array[1..maxn]of int64;
procedure swap(i,j:longint);
var k:int64;
begin
    k:=dx[i];dx[i]:=dx[j];dx[j]:=k;
    k:=v[i];v[i]:=v[j];v[j]:=k;
end;
procedure qsort(l,r:longint);
var i,j,x:longint;
begin
    i:=l;j:=r;x:=v[(l+r)shr 1];
    repeat
      while v[i]<x do inc(i);
      while v[j]>x do dec(j);
      if(i<=j)then
      begin
        swap(i,j);
        inc(i);
        dec(j);
      end;
    until(i>j);
    if i<r then qsort(i,r);
    if j>l then qsort(l,j);
end;
procedure init;
begin
    readln(n,m);
    for i:=1 to n do
    begin
      read(v[i]);
      dx[i]:=i;
      pre[i]:=i-1;
      next[i]:=i+1;
    end;
    for i:=1 to m do read(del[i]);
    qsort(1,n);
    for i:=1 to n do d[dx[i]]:=i;
end;
procedure work;
var i,j,k,l,r,p:longint;
begin
    now:=n;link:=m;
    for i:=m downto 1 do
    begin
      j:=del[i];
      for k:=now downto j+1 do
      begin
        l:=d[k];
        next[pre[l]]:=next[l];
        pre[next[l]]:=pre[l];
        if(v[l]<v[link])and(l<link) then link:=next[link];
        if(v[l]=v[link])and(l=link) then link:=next[link];
      end;
      now:=j;
      sp[i]:=v[link];
      link:=pre[link];
    end;
    for i:=1 to m do writeln(sp[i]);
end;
begin
    init;
    work;
end.

```

---

## 作者：Marvin (赞：1)

/\*
楼下的楼下那位说的很对，开两个堆，一个大根堆维护1——i-1小的数，一个小根堆维护i——N小的数，当每次查询时，输出小根堆顶，从小根堆取最小数到大根堆；如果更新时小根堆顶小于大根堆顶，交换两堆顶，维护大根堆。


用这个东西可以解决求中位数的问题


记得开始时要把大根堆初始化成很小的值或者开一个布尔值记录大根堆里有没有数字，否则的话在第一次询问前某一次更新时的的最小值是负数，那就会直接和大根堆堆顶交换了。


尽管不初始化也能过……

\*/



















```cpp
var
a,b:array[1..1000000]of longint;
c,d:array[1..200000]of longint;
j,k,i,m,n,ans,tot,xtot,now:longint;
bo:boolean;
procedure put(ss:longint);
var
ii,jj,kk:longint;
begin
if ss=1 then exit;
if a[ss]<a[ss div 2] then
begin
kk:=a[ss];
a[ss]:=a[ss div 2];
a[ss div 2]:=kk;
end;
put(ss div 2);
end;
procedure get(ss:longint);
var
ii,jj,kk:longint;
begin
if 2*ss>tot then exit;
if (a[ss]>a[ss*2]) and (a[ss*2]<a[ss*2+1]) then
begin
kk:=a[ss];
a[ss]:=a[ss*2];
a[ss*2]:=kk;
get(ss*2);
end
else if (a[ss]>a[ss*2+1]) and (a[ss*2]>=a[ss*2+1]) then
begin
kk:=a[ss];
a[ss]:=a[ss*2+1];
a[ss*2+1]:=kk;
get(ss*2+1);
end
end;
procedure xput(ss:longint);
var
ii,jj,kk:longint;
begin
if ss=1 then exit;
if b[ss]>b[ss div 2] then
begin
kk:=b[ss];
b[ss]:=b[ss div 2];
b[ss div 2]:=kk;
end;
xput(ss div 2);
end;
procedure xget(ss:longint);
var
ii,jj,kk:longint;
begin
if 2*ss>xtot then exit;
if (b[ss]<b[ss*2]) and (b[ss*2]>b[ss*2+1]) then
begin
kk:=b[ss];
b[ss]:=b[ss*2];
b[ss*2]:=kk;
xget(ss*2);
end
else if (b[ss]<b[ss*2+1]) and (b[ss*2]<=b[ss*2+1]) then
begin
kk:=b[ss];
b[ss]:=b[ss*2+1];
b[ss*2+1]:=kk;
xget(ss*2+1);
end
end;
begin
readln(n,m);
for i:=1 to n do
read(c[i]);
for i:=1 to m do
read(d[i]);
for i:=1 to n do
begin
tot:=tot+1;
a[tot]:=c[i];
put(tot);
if (a[1]<b[1]) and (bo=true) then
begin
k:=a[1];
a[1]:=b[1];
b[1]:=k;
xget(1);
end;
while d[now+1]=i do
begin
bo:=true;
xtot:=xtot+1;
b[xtot]:=a[1];
xput(xtot);
writeln(b[1]);
a[1]:=a[tot];
tot:=tot-1;
get(1);
now:=now+1;
end;
end;
end.

```

---

## 作者：风格EX (赞：1)

咳咳  这个  小白痴什么数据结构都没用

思想 ：离线做

先都读进来 排个序 然后查询时 依次把那次之后的删掉（这样比插排快吧........）

注意：每次查询第几大都是上次加一，我完全可以搞一个光标，确定当前第k大啊，输出后dec（i）；就好了

于是乎。上代码。。。。。。

[/color][codep ]

```cpp
program project1;
var a,rank,b,weizhi:array[1..200000]of longint;
    i,n,m,k,j,hehe:longint;
procedure kuaipai(z,y:longint);
var zz,yy,mid,jiaohuan:longint;
begin
  mid:=a[(z+y)shr 1];
  zz:=z;yy:=y;
 repeat
  while a[zz]<mid do inc(zz);
  while a[yy]>mid do dec(yy);
  if zz<=yy then begin jiaohuan:=a[zz];a[zz]:=a[yy];a[yy]:=jiaohuan;
    jiaohuan:=rank[zz];rank[zz]:=rank[yy];rank[yy]:=jiaohuan;
  inc(zz);dec(yy); end;
  until zz>yy;
  if zz<y then kuaipai(zz,y);
  if z<yy then kuaipai(z,yy);
end;
procedure shanchu(yy:longint);
var hehe:longint;
begin
  hehe:=weizhi[yy];
  a[hehe]:=200001;
  if hehe<=k then begin inc(k);while a[k]=200001 do inc(k);end;
end;
begin
  readln(n,m);
  for i:=1 to n do begin read(a[i]);rank[i]:=i;end;  readln;
  for i:=1 to m do read(b[i]); readln;
  kuaipai(1,n);
  for i:=1 to n do weizhi[rank[i]]:=i;
  k:=m;  j:=m;
  for i:=m downto 1 do begin
    for hehe:=n downto (b[i]+1) do shanchu(hehe); rank[m]:=a[k];dec(m);
    dec(k);while a[k]=200001 do dec(k);
    n:=b[i];
  end;
  for i:=1 to j do writeln(rank[i]);
end.
[/codep ]
```

---

## 作者：zhan8822 (赞：1)

看到还没有用堆的题解，我来放一篇^\_^


开两个堆，一个大根堆维护1——i-1小的数，一个小根堆维护i——N小的数，当每次查询时，输出小根堆顶，从小根堆取最小数到大根堆；如果更新时小根堆顶小于大根堆顶，交换两堆顶，维护大根堆。


别被代码长度吓到，很大一部分是复制粘贴的。


```cpp

#include <cstdio>
#include <algorithm>

using namespace std;

int heap1[500000],heap2[500000],g[500000];
int i,k,m,n,t,sum_node1,sum_node2;

void buildheap2(int node)
{
    if ((node>1) && (heap2[node]>heap2[node/2]))
    {
        swap(heap2[node],heap2[node/2]);
        buildheap2(node/2);
    }
    return;
}

void insertheap2(int node)
{
    bool left=false,right=false;
    if ((node*2<=sum_node2) && (heap2[node]<heap2[node*2]))
        left=true;
    if ((node*2+1<=sum_node2) && (heap2[node]<heap2[node*2+1]))
        right=true;
    if ((left) && (right))
        if (heap2[node*2]>heap2[node*2+1])
            right=false;
        else
            left=false;
    if (left)
    {
        swap(heap2[node],heap2[node*2]);
        insertheap2(node*2);
    }
    if (right)
    {
        swap(heap2[node],heap2[node*2+1]);
        insertheap2(node*2+1);
    }
    return;
}

void buildheap1(int node)
{
    if ((node==1) && (heap1[1]<heap2[1]))
    {
        swap(heap1[1],heap2[1]);
        insertheap2(1);
        return;
    }
    if ((node>1) && (heap1[node]<heap1[node/2]))
    {
        swap(heap1[node],heap1[node/2]);
        buildheap1(node/2);
    }
    return;
}

void insertheap1(int node)
{
    bool left=false,right=false;
    if ((node*2<=sum_node1) && (heap1[node]>heap1[node*2]))
        left=true;
    if ((node*2+1<=sum_node1) && (heap1[node]>heap1[node*2+1]))
        right=true;
    if ((left) && (right))
        if (heap1[node*2]<heap1[node*2+1])
            right=false;
        else
            left=false;
    if (left)
    {
        swap(heap1[node],heap1[node*2]);
        insertheap1(node*2);
    }
    if (right)
    {
        swap(heap1[node],heap1[node*2+1]);
        insertheap1(node*2+1);
    }
    return;
}

int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
        scanf("%d",&g[i]);
    k=1,scanf("%d",&t);
    for (i=1;i<=n;i++)
    {
        sum_node1++;
        heap1[sum_node1]=g[i];
        buildheap1(sum_node1);
        while (t==i)
        {
            printf("%d\n",heap1[1]);
            sum_node2++;
            heap2[sum_node2]=heap1[1];
            buildheap2(sum_node2);
            heap1[1]=heap1[sum_node1];
            sum_node1--;
            if (sum_node1>0)
                insertheap1(1);
            if (k<m)
                k++,scanf("%d",&t);
            else
                t=0;
        }
    }
    return 0;
}

```

---

## 作者：yy1695651 (赞：1)

# 主席树解决
### 主席树主要用于对一个数组中任意一段，求它的第k大/小的值
## 所以此问题可以用主席树轻松解决
### 主席树是一种可持久化线段树，对于每一个数组中值（i），都有一颗属于它的线段树
### 学过线段树的都知道，线段树上每个点都对应着一个区间，每个点都有一些功能值（eg：sum，minv，maxv……）
### 在属于点i主席树上，每个点的功能值sum所记录的是【1，i】中所有数值，在这个点线段上的出现个数。
## 还要用到Hash，即在数组上不同值的对应值不同
#### 如   3 1 1 2 5 排序后 1 1 2 3 5
#### 对应 Hash[1] = 1, Hash[2] = 2, Hash[3] = 3, Hash[4] = 5;
#### 线段树总长度为Hash的最大值 4![主席树解释](https://cdn.luogu.com.cn/upload/pic/23710.png)
### 如图左边的树为【1,4】的线段树（4就是Hash对应数值最大的）
### 右图树为对于i=3时，每一段所对应的sum值
3属于【1，4】，【1,4】sum +1

3属于【3，4】，【3,4】sum +1
### 对于后面每一个数，随着i的递增，都会造一颗新的树
### 但有些有些树枝要更新，有些不用，如i=0到i=1这两棵树，就只更新了右边的树枝而左边的没有发生变化，故沿用上次的树![图的沿用](https://cdn.luogu.com.cn/upload/pic/23714.png)
### 如图，左边为历史的树，右边为新创建的树，绿色的数字为sum值，被红色圈住的点都为这次新创建树所更新的点，而没有圈的，都沿用上次树的点，这样既可以节约空间，又不必重新建整棵树。
# AC代码如下
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 200000 + 10;
int n, m;
int Hash[N], A[N], T[N], tot;
//Hash即对应数字， A为输入数组储存，T为对于不同i有不同的根节点，tot为所有节点计数器

//对树上每个点的数据
struct node
{
    int left, right, sum;
}tree[N * 50];

int build_tree(int l, int r)
{
//与线段树建树相同
    int root = ++tot;
    //初始状态下，没有数值出现，sum值故为0
    tree[root].sum = 0;
    if (l < r)
    {
        int mid = (l + r) / 2;
        tree[root].left = build_tree(l, mid);
        tree[root].right = build_tree(mid + 1, r);
    }
    return root;
}

int update(int pre, int l, int r, int x)
{
    int root = ++tot;
    //沿用历史节点
    tree[root].left = tree[pre].left;
    tree[root].right = tree[pre].right;
    //对于新的树节点，如果遍历到了，说明x的Hash值一定属于这个节点的范围中的，所以sum记录数值出现次数增多一次
    tree[root].sum = tree[pre].sum + 1;
    
    if (l < r)
    {
        int mid = (l + r) / 2;
        //判断x属于左子点范围还是右子点范围
        if (x <= mid) tree[root].left = update(tree[pre].left, l, mid, x);
        else tree[root].right = update(tree[pre].right, mid + 1, r, x);
    }
    return root;
}

int query(int old_tree, int new_tree, int l, int r, int k)
{
    if (l == r) return l;
    //计算出左边一共有多少数，用询问的树(new_tree)sum减去初始状态(old_tree)的树sum（初始状态值都是0）
    int left_num = tree[tree[new_tree].left].sum - tree[tree[old_tree].left].sum;
    int mid = (l + r) / 2;
    //判断第k小数字在左儿子还是右儿子
    if (left_num >= k)
        return query(tree[old_tree].left, tree[new_tree].left, l, mid, k);
    else
        return query(tree[old_tree].right, tree[new_tree].right, mid + 1, r, k - left_num);
}

int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &A[i]);
        Hash[i] = A[i];
    }
    //先对原数组进行排序
    //如 5 1 1 2 5
    //排序后 1 1 2 5 5
    sort(Hash + 1, Hash + n + 1);
    //再对排序后的数组进行去重，去掉重复的数值
    //即 1 2 5
    //所以对应的Hash值为Hash[1] = 1, Hash[2] = 2, Hash[3] = 5
    //d表示的是Hash值总长度，如上例数组总长度为d=3
    int d = unique(Hash + 1, Hash + n + 1) - Hash - 1;
    //对长度为【1，d】的线段，建一颗线段树
    T[0] = build_tree(1, d);
    for (int i = 1; i <= n; i++)
    {
    	//x为数值A[i]所对应的Hash值，用系统自带二分搜索得到
        int x = lower_bound(Hash + 1, Hash + n + 1, A[i]) - Hash;
        //对于每个i，都建一棵树
        T[i] = update(T[i - 1], 1, d, x);
    }
    for (int i = 1; i <= m; i++)
    {
        int r;
        scanf("%d", &r);
        //query所返回的是答案所对应的Hash值
        int x = query(T[0], T[r], 1, d, i);
        printf("%d\n", Hash[x]);
    }
    return 0;
}

```
### 讲的不够详细，仅供参考


---

## 作者：acranker (赞：1)

这相当于就是求区间【1，i】的第k小值问题---主席树经典题

主席树详解：http://blog.csdn.net/creatorx/article/details/75446472 （两天前我看这个学的）

主席树模板题（第k小数）：https://www.luogu.org/problemnew/show/P3834

下面是这道题的ac代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N_zx 4000000//nlogn的复杂度，其实要开n*（floor（log（2，n））+2），否则会RE
#define M 200050
struct zxseg//主席树又叫可持久化线段树，所以我写z（主）x（席）seg（线段树)
{
    int lef,rig,sum;//lef,rig是左右区间，这里存的是离散化后的数字大小范围，sum是这个范围内数的个数
    zxseg(){lef=rig=sum=0;}
}tre[N_zx];
struct node{int id,x;}num[M];
bool cmp(node a,node b){return a.x<b.x;}
int dank[M],root[M];
int m,n,cnt_zx=0,term;
//核心的思想有点复杂，看上面的博客链接吧
void insert(int val,int &rt,int l=1,int r=m)
{
    tre[++cnt_zx]=tre[rt];
    rt=cnt_zx;
    tre[rt].sum++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(val<=mid) insert(val,tre[rt].lef,l,mid);
    else insert(val,tre[rt].rig,mid+1,r);
}
int query(int i,int j,int py,int l=1,int r=m)
{
    if(l==r) return l;
    int mid=(l+r)>>1,num=tre[tre[j].lef].sum-tre[tre[i].lef].sum;
    if(num>=py) return query(tre[i].lef,tre[j].lef,py,l,mid);
    else return query(tre[i].rig,tre[j].rig,py-num,mid+1,r);
}
int main(int argc, char const *argv[])
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&num[i].x);
        num[i].id=i;
    }
    sort(num+1,num+m+1,cmp);
    for(int i=1;i<=m;i++)
        dank[num[i].id]=i;//离散化，另外rank在洛谷会被河蟹（ToT）
    root[0]=0;
    for(int i=1;i<=m;i++)
    {
        root[i]=root[i-1];
        insert(dank[i],root[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&term);
        printf("%d\n",num[query(root[0],root[term],i)].x);
    }
    return 0;
}
```

---

## 作者：LightningUZ (赞：0)

### 题意简述

给定一个序列，支持插入一个数，或者查询第i小的数。i随着询问不断$+1$，初始为$0$。查询会给定一个序列$u$，表示当你插入到第$u_i$个数的时候就要来一次询问。$u$珂能有重复。那么你就要重复询问多次。

### 思路

首先考虑最基础的问题：如何插入

写一颗平衡树（vector）即珂。插入的时候，就用$lowerbound$。

那么如何处理重复的询问呢？

再写一颗平衡树（map），维护每个位置需要询问多少次。

然后对于一个位置，用一个for循环不断询问即珂。

注意我们还要用一个整形内存块（int）来维护那个随着询问不断$+1$的变量$i$。

还要写两个随机线性表（数组）来维护插入的数，和序列$u$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 255555
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define Tra(i,u) for(int i=G.Start(u),__v=G.To(i);~i;i=G.Next(i),__v=G.To(i))
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    int n,m;
    int a[N],q[N];//随机线性表
    void R1(int &x)
    {
        x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        x=(f==1)?x:-x;
    }
    void Input()
    {
        R1(n),R1(m);
        F(i,1,n) R1(a[i]);
        F(i,1,m) R1(q[i]);
    }

    map<int,int> cnt;//平衡树1
    vector<int> T;//平衡树2
    #define LB(x) lower_bound(T.begin(),T.end(),x)
    #define UB(x) upper_bound(T.begin(),T.end(),x)
    void Soviet()
    {
        F(i,1,m) cnt[q[i]]++;
        int k=0;//整形内存块
        F(i,1,n)
        {
            T.insert(LB(a[i]),a[i]);//插入操作
            //你以为我是O(n)，其实我是O(1)哒！
            F(j,1,cnt[i])
            //你以为我是O(n^2)，其实我是均摊O(n)哒！
            {
                printf("%d\n",T[k]);
                ++k;
            }
        }
    }

    #define Flan void
    Flan IsMyWife()
    {
        Input();
        Soviet();
    }
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---

## 作者：yangyujia18 (赞：0)

~~一看这道题~~我就举的是优先队列，然而优先队列并不支持随机访问 
~~聪明伶俐的~~我想到要用两个优先队列，一个从小到大（box2），另一个从大到小（blbox）  
每次输入一个提取要求，并将提取之前加入的数加入小根堆  
之后将小根堆的第一个（也就是最小的）加入大根堆并输出大根堆队首（也就是最大的）就是结果  
但是（一有这俩字就没好事）  
有一个漏洞，如果小根堆的数比大根堆的数大就会出问题  
所以我们每次向小根堆中插入元素时，比较两对首若大根堆队首较大则交换它们  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005],tmp;
int main()
{
	int m,n,w=0,q;
	cin>>m>>n;
	priority_queue<int> blbox;
	priority_queue<int,vector<int>,greater<int> > box2;
	for(int i=1;i<=m;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		cin>>q;
		while(w<q)
		{
			w++;
			box2.push(a[w]);
			if(!blbox.empty()&&blbox.top()>box2.top())
			{
				tmp=blbox.top();
				blbox.pop();
				blbox.push(box2.top());
				box2.pop();
				box2.push(tmp);
			}
		}
		blbox.push(box2.top());
		box2.pop();
		cout<<blbox.top()<<endl;
	}
	return 0;
}
```


---

## 作者：白木偶君 (赞：0)

### 首先约定： 
1. 以下n指代的数的数量，不是题目所指的n

2. 以下m指代询问的数量，不是题目所指的m

~~（不好意思，这是本人习惯）~~
##  分块+堆  $O(m*\sqrt n*\log n)$~~(自己yy出来的)~~
**堆一次只能输出堆顶的一个元素，如果我要找第k小的元素， 理论上复杂度是 $O（k*n）,这样肯定会TLE$**

**那么我们能不能，把这些数排序后分成几段连续的数在几个堆里,没次查找先去找在哪个堆，再去找在堆里的排名**

**这样做的话，就可以跳过一些数了**

**如果你学过分块的话，你就可以反应过来了,分成根号n段理论上是最好的，因为平摊了两个步骤的复杂度**

### **查找的时候通过$O(\sqrt n)$来找到在哪个堆，再用$O(\sqrt n* \log n)$在堆里来找到它的具体数值**

### **插入值与查找类似，先找到所处的堆，再加入到堆**

还有细节问题，请看代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
#define int long long
using namespace std;
const int N=3e5+10,M=N;
int A[N],B[N],belong[N];
priority_queue<int>q[M];
int m,n;
inline void add(int x){
	int op=lower_bound(B+1,B+1+m,x)-B;
	int blo=belong[op];
	q[blo].push(-x);
}
int size,all;
inline int ask(int x){
	int op;
	for(int i=0;i<=m;i++){
		if(x>q[i].size())
		x-=q[i].size();
		else{
			op=i;
			break;
		}
	}
	vector<int>p;
	int ans=0;
	while(q[op].size()){
		int u=-q[op].top();q[op].pop();
  		//弹出
		p.push_back(u);
		x--;
		if(x==0){
			ans=u;
			break;
		}
	}
	for(int i=0;i<p.size();i++)
	q[op].push(-p[i]);//把弹出的数再放回去
                             
	return ans;
}
signed main(){
	cin>>m>>n;
	size=pow(m,1.0/3.0);
	all=ceil((double)m/size);
	for(int j=1;j<=all;j++)
	for(int i=(j-1)*size+1;i<=j*size;i++)
	belong[i]=j;
  	//初始化块
	for(int i=1;i<=m;i++){
		scanf("%lld",&A[i]);
		B[i]=A[i];
	}
	sort(B+1,B+1+m);
   //排序方便判断排名，选择堆
	int num=1;
	for(int i=1,x;i<=n;i++){
		scanf("%lld",&x);
		for(int j=num;j<=x;j++)add(A[j]);
		num=x+1;
		printf("%lld\n",ask(i));
	}
}
```
## 最后宣传一下我的[博客](https://www.cnblogs.com/naruto-mzx/) 

---

## 作者：Ireliaღ (赞：0)

## 我看这么多题解没有人写指针版的无旋Treap，我来写一个  

*如果不会FHQTreap可以看我的[博客](https://www.cnblogs.com/Juruo1103/p/10281403.html)*

**指针版FHQ又好写又好调跑的还快，墙裂推荐**  

题面无需多讲，插入数值和查询第$k$小，平衡树模板操作  

无旋$Treap$由于有按照$size$来$Split$的功能，所以我们可以按照二叉搜索树的性质写一个$Rank$函数，然后这两种操作都可以基于$Rank$完成  

#### 插入数值

查$Rank$，分裂出$size$为$Rank - 1$的子树，把新节点放入中间合并，代码如下  

```cpp
void Insert(int val) {
    int rank = Rank(root, val);
    Node *temp1, *temp2;
    Split(root, rank, temp1, temp2);
    Node *nod = new Node(val);
    root = Merge(temp1, nod);
    root = Merge(root, temp2);
}
```

#### 查询第k小

按照需要的$k$值分裂出$size$为$k - 1$的子树，在剩余部分分裂出$size$为$1$的节点，输出节点权值，然后原样拼回去，代码如下  

```cpp
int FindKth(int k) {
    Node *x1, *x2, *y1, *y2;
    Split(root, k - 1, x1, x2);
    Split(x2, 1, y1, y2);
    Node *now = y1;
    root = Merge(x1, Merge(now, y2));
    return now ? now->val : 0;
}
```   

### 完整代码

```cpp
#include <cstdio>
#include <algorithm>

using std::min;
using std::max;

const int MAXM = 2e5 + 5;

int add[MAXM], get[MAXM];

int n, m;

int Rand() {
    static int seed = 39444;
    return seed = (((seed ^ 1433223) + 810872ll) * 19260817ll) % 2147483647;
}

struct Node{
    Node *child[2];
    int val, key, size;
    
    Node(int val):val(val), size(1), key(Rand()) {
        child[0] = NULL; child[1] = NULL;
    }
    
    void Update() {
        size = 1;
        if (child[0]) size += child[0]->size;
        if (child[1]) size += child[1]->size;
    }
};

Node *root = NULL;

Node* Merge(Node* a, Node* b) {
    if (!a || !b) return a ? a : b;
    if (a->key < b->key) {
        a->child[1] = Merge(a->child[1], b);
        a->Update();
        return a;
    } else {
        b->child[0] = Merge(a, b->child[0]);
        b->Update();
        return b;
    }
}

void Split(Node *now, int k, Node *&t1, Node *&t2) {
    if (!now) {
        t1 = t2 = NULL; return;
    } 
    if (!k) {
        t1 = NULL; t2 = now; return;
    }
    if (k >= now->size) {
        t1 = now; t2 = NULL; return;
    }
    int ls = now->child[0] ? now->child[0]->size : 0;
    if (ls >= k) {
        Node *temp;
        Split(now->child[0], k, t1, temp);
        t2 = now; t2->child[0] = temp; 
        t2->Update(); return;
    } else {
        Node *temp;
        Split(now->child[1], k - ls - 1, temp, t2);
        t1 = now; t1->child[1] = temp;
        t1->Update(); return;
    }
}

int Rank(Node *now, int k) {
    if (!now) return 0;
    int ls = now->child[0] ? now->child[0]->size : 0;
    if (now->val <= k) return ls + 1 + Rank(now->child[1], k);
    else return Rank(now->child[0], k);
}

int FindKth(int k) {
    Node *x1, *x2, *y1, *y2;
    Split(root, k - 1, x1, x2);
    Split(x2, 1, y1, y2);
    Node *now = y1;
    root = Merge(x1, Merge(now, y2));
    return now ? now->val : 0;
}

void Insert(int val) {
    int rank = Rank(root, val);
    Node *temp1, *temp2;
    Split(root, rank, temp1, temp2);
    Node *nod = new Node(val);
    root = Merge(temp1, nod);
    root = Merge(root, temp2);
}

int main() {
    scanf("%d %d", &m, &n);
    for (int i = 1; i <= m; i++) {
        scanf("%d", add + i);
    }
    int ii = 0, cur = 1;
    for (int i = 1; i <= n; i++) {
        scanf("%d", get + i);
        while (cur <= get[i]) {
            Insert(add[cur]); cur++;
        }
        printf("%d\n", FindKth(++ii));
    }
    return 0;
}
```

---

## 作者：Jμdge (赞：0)

发现这道题有主席树的做法...（毕竟可以离线）

不过最后我还是没有打主席树（懒）

于是乎 FHQ treap 水过去了...


都是FHQ 的常规操作...没什么好讲的，板子题了。。。

```cpp
//by Judge
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int M=2e5+111;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
	int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
int n,m,A[M],B,now,cnt,root;
struct Node { int val,key,siz,ch[2]; } t[M];
inline int Rand() { static int seed=703; return seed=int(seed*48271LL%(~0u>>1)); }
inline void update(int now){ t[now].siz=t[t[now].ch[0]].siz+t[t[now].ch[1]].siz+1; }
int merge(int u,int v) {
    if(!u || !v) return u|v;
    if(t[u].key<t[v].key) { t[u].ch[1]=merge(t[u].ch[1],v),update(u); return u; }
	else { t[v].ch[0]=merge(u,t[v].ch[0]),update(v); return v; }
}
void split_val(int now,int k,int& x,int& y) {
    if(!now) return (void)(x=y=0);
    if(t[now].val<=k) split_val(t[x=now].ch[1],k,t[now].ch[1],y);
    else split_val(t[y=now].ch[0],k,x,t[now].ch[0]); update(now);
}
void split_k(int now,int k,int& x,int& y) { 
    if(!now) return (void)(x=y=0);
    if(t[t[now].ch[0]].siz>=k) split_k(t[y=now].ch[0],k,x,t[now].ch[0]);
    else split_k(t[x=now].ch[1],k-t[t[now].ch[0]].siz-1,t[now].ch[1],y);
    update(now);
}
inline void ins(int x) { int u,a,b; t[u=++cnt].key=Rand(),t[u].val=x,t[u].siz=1,split_val(root,x,a,b),root=merge(merge(a,u),b); }
inline int get_val(int x) { int a,b,c,d,e; split_k(root,x-1,a,b),split_k(b,1,c,d),e=t[c].val,root=merge(a,merge(c,d)); return e; }
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i) A[i]=read();
	for(int i=1;i<=m;++i){
		B=read(); while(now<B) ins(A[++now]); print(get_val(i));
	} Ot(); return 0;
}
```




于是乎口胡一通主席树做法：

首先我们对于读入的数存入 A、B 数组，对 B 排序，以此离散。

然后我们每次插入的时候 update 一下，询问的时候查询当前版本就好了。

具体查询的时候，我们采用平衡树的类似思想：

	如果当前节点的左半边部分值域有的数 >= 查询排名就进入左子树，
    否则查询的排名减去左子树 siz ，然后进入有字数查询

主席树做，同样是板子题...

---

## 作者：Fortitude (赞：0)

这题是平衡树裸题，这里我用的是Treap

这道题只需要支持插入和第k大查询

先读入Add和Get，将Get从小到大排序

按顺序插入Add，每到Get时输出第k大即可



    
    
    







```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int MaxN = 200005;
int Add[MaxN],Get[MaxN];
int M,N,k;
struct Node{
    Node* ch[2];
    int priority;
    int v,size,cnt;
    inline int cmp(const int &x) const{
        if(x == v) return -1;
        return x < v ? 0 : 1;
    }
    Node() : priority(1<<30), v(0), size(0), cnt(0){
        ch[0] = ch[1] = this;
    }
    Node(int v);
};
Node* Null(new Node);
Node* Root = Null;
inline Node :: Node(const int v) : priority(rand()), v(v), size(1), cnt(1){
    ch[0] = ch[1] = Null;
}
inline int read(){
    int s = 0,f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
        s = s*10+ch-'0',ch = getchar();
    return s*f;
}
inline void maintain(Node* &o){
    o->size = o->ch[0]->size+o->ch[1]->size+o->cnt;
}
inline void rotate(Node* &o,const int &d){
    Node* k = o->ch[d^1];
    o->ch[d^1] = k->ch[d];
    k->ch[d] = o;
    maintain(o);
    maintain(k);
    o = k;
}
inline void Insert(Node* &o,const int &x){
    if(o == Null)
        o = new Node(x);
    else{
        int d = o->cmp(x);
        if(d == -1){
            ++o->cnt;
            maintain(o);
            return;
        }
        Insert(o->ch[d],x);
        if(o->ch[d]->priority > o->priority)
            rotate(o,d^1);
    }
    maintain(o);
}
inline int kth(Node* &o,const int &K){
    if(o == Null || K <= 0 || K > o->size) return 0;
    int s = (o->ch[0] == Null ? 0 : o->ch[0]->size);
    if(K >= s+1 && K <= s+o->cnt) return o->v;
    else if(K <= s) return kth(o->ch[0],K);
    return kth(o->ch[1],K-s-o->cnt);
}
int main(){
    int i,j;
    M = read(),N = read();
    for(i = 1;i <= M;i++)
        Add[i] = read();
    for(i = 1;i <= N;i++)
        Get[i] = read();
    sort(Get+1,Get+N+1);
    for(i = 1,j = 1;i <= M;i++){
        Insert(Root,Add[i]);
        while(Get[j] == i){
            printf("%d\n",kth(Root,++k));
            j++;
        }
    }
    return 0;
}

```

---

## 作者：Mychael (赞：0)

我用的splay

这代码还算好简洁的吧

将Get操作排序，然后将Add按顺序插入，每到达一个Get就查询一次第k大

所以这是一棵只有插入和第k大查询的splay




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define isr(u) (e[e[u].f].ch[1]==u)
using namespace std;
const int maxn=200005,INF=200000000;
inline int read(){
    int out=0,flag=1;char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57) {out=out*10+c-48;c=getchar();}
    return out*flag;
}
class node{
```
public:







```cpp
        int v,siz,ch[2],f,cnt;
        node() {siz=0;ch[0]=ch[1]=f=0;}
}e[2*maxn];
int nodei=0,root=0;
inline void up(int u){e[u].siz=e[e[u].ch[0]].siz+e[e[u].ch[1]].siz+e[u].cnt;}
void spin(int u){
    int fa=e[u].f,s=isr(u);
    e[u].f=e[fa].f;
    if(e[fa].f) e[e[fa].f].ch[isr(fa)]=u;
    e[fa].ch[s]=e[u].ch[s^1];
    if(e[u].ch[s^1]) e[e[u].ch[s^1]].f=fa;
    e[fa].f=u;
    e[u].ch[s^1]=fa;
    up(fa);up(u);
}
inline void splay(int u){
    while(e[u].f){
        if(!e[e[u].f].f) spin(u);
        else if(isr(u)^isr(e[u].f)) spin(u),spin(u);
        else spin(e[u].f),spin(u);
    }
    root=u;
}
void insert(int& u,int v,int fa){
    if(!u) {u=++nodei;e[u].v=v;e[u].f=fa;e[u].cnt=1;e[u].siz=1;splay(u);}
    else if(e[u].v>v) e[u].siz++,insert(e[u].ch[0],v,u);
    else if(e[u].v<v) e[u].siz++,insert(e[u].ch[1],v,u);
    else e[u].cnt++,e[u].siz++;
}
int kth(int u,int k){
    if(e[e[u].ch[0]].siz<k&&e[e[u].ch[0]].siz+e[u].cnt>=k) {splay(u);return e[u].v;}
    else if(e[e[u].ch[0]].siz>=k) return kth(e[u].ch[0],k);
    else return kth(e[u].ch[1],k-e[e[u].ch[0]].siz-e[u].cnt);
}
int Add[maxn],Get[maxn];
int main()
{
    int m=read(),n=read();
    for(int i=1;i<=m;i++) Add[i]=read();
    for(int i=1;i<=n;i++) Get[i]=read();
    sort(Get+1,Get+1+n);
    int p=0;
    for(int i=1;i<=n;i++){
        while(p<Get[i]) insert(root,Add[++p],0);
        printf("%d\n",kth(root,i));
    }
    return 0;
}

```

---

## 作者：revenger (赞：0)

看到下面都是各种堆的题解【好像还有大神发的treap

我想既然这道题用的是平衡树，有一个很重要的平衡树没有出现，我就发一个题解，权当抛砖引玉了。

没错，就是splay。splay作为一个非常重要的平衡树，使用频率比treap要高不少。

当然本人不才，如有大神，不喜勿喷。

基本思路：没有delete的splay，只需要写插入和查找第K大。

size表示节点和它的子树的大小，cnt表示当前节点的数有几个，value表示当前节点的数。

ch[0],ch[1]分别表示左右儿子（这样可以用异或运算，比较方便）

pre表示当前节点的父亲。

null是一个空节点，它的size，cnt都是0，是为了避免使用NULL导致各种奇怪的RE。

其余的就是splay的基本操作 包括旋转和splay等 看不懂的可以自行百度。

本splay使用的是非递归写法，也可以使用递归的写法。

【吐槽：本题数据略弱。

不啰嗦了，上代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct splaynode{
    int size,value,cnt;
    splaynode *pre,*ch[2];
    inline void update()//更新 
    {
        size=ch[0]->size+ch[1]->size+cnt;//注意不是+1 
    } 
    inline int getwh()
    {
        return pre->ch[0]==this?0:1;//找到当前节点是它父亲的哪个儿子 
    }
    inline void setch(int wh,splaynode *child);
}pool[400010],*null,*root;
int n,a[200010],b[200010],top,m,x;
inline splaynode *getnew(int value)//申请新节点 
{
    splaynode *now=pool + ++top;
    now->value=value;
    now->size=now->cnt=1;
    now->pre=now->ch[0]=now->ch[1]=null;
    return now;
}
inline void splaynode::setch(int wh,splaynode *child)//设置儿子 
{
    ch[wh]=child;
    if(child!=null)
    child->pre=this;
    update();
}
inline void rotate(splaynode *&now)//旋转 
{
    splaynode *oldfa=now->pre,
    *grand=now->pre->pre;
    int wh=now->getwh();
    oldfa->setch(wh,now->ch[wh^1]);
    now->setch(wh^1,oldfa);
    now->pre=grand;
    if(grand!=null)
    grand->setch(grand->ch[0]==oldfa?0:1,now);
}
inline void splay(splaynode *now,splaynode *aim)//splay的大招：splay 
{
    for(;now->pre!=aim;rotate(now))
    {
        if(now->pre->pre!=aim)
        now->getwh()==now->pre->getwh()?rotate(now->pre):rotate(now);
    }
    if(aim==null)
    root=now;
}
inline void insert(int value)//插入 
{
    splaynode *last=null,*now=root;
    splaynode *newone=getnew(value);
    while(now!=null)
    {
        last=now;
        if(newone->value==now->value)
        {
            now->size++,now->cnt++;
            splay(now,null);
            return;
        }
        if(newone->value<now->value)
        now=now->ch[0];
        else
        now=now->ch[1];
    }
    if(last==null)
    root=newone;
    else
    {
        if(newone->value<last->value)
            last->setch(0,newone);
        else
            last->setch(1,newone);
        splay(newone,null);
    }
}
inline int kth(int k)//查找第K大 
{
    splaynode *now = root;
    int leftsize=0;
    while(now!=null)
    {
        int left=leftsize+now->ch[0]->size;
        if(left+1<=k&&k<=left+now->cnt)
        {
            splay(now,null);
            return now->value;
        }
        if(k<=left)
        now=now->ch[0];
        else
        leftsize=left+now->cnt,now=now->ch[1];
    }
    return -1; 
}
int main()
{
    null=pool;
    null->ch[0]=null->ch[1]=null;
    null->size=null->cnt=null->value=0;
    root=null;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        b[x]++;
    }
    x=0;
    for(int i=1;i<=m;i++)
    {
        insert(a[i]);
        while(b[i])
        {
            x++;
            b[i]--;
            printf("%d\n",kth(x));
        }
    }
 } 

```

---

## 作者：Jack_Homes_Huang (赞：0)

**坚决不用STL！**


------------

首先，这道题让我们求每次的第i大值，而i是会移动的——那我们就可以理解为，我们需要知道第i大值和第i+1大值（请撕烤）。那用什么数据结构呢？

- 首先，要确定第i大值，就可以知道i-1~1是从大到小的；

- 相似的，i+1~n的元素是从小到大的。

- 什么操作可以完美的完成这一点？**HEAP！HEAP！HEAP！**


我们用一个大根堆来保存前i-1大数，大根堆确定了其中的元素是从大到小的；再用一个小根堆来存剩下的数，小根堆堆顶就是第i大数。

##### 步骤如下：

1. 全部读入

1. 对于第i个询问，我们要再大根堆里维护的就是前i-1个数，所以就先扫描到操作进行到的值（有可能我语言表述不好，那就看代码吧...），如果这时候大根堆的元素个数大于了i-1，那么就把大根堆堆顶不断弹出，塞到小根堆里。

1. 这些操作进行完了，那么直接输出小根堆的堆顶。~~（因为它是答案）~~然后因为这个答案已经贡献完了，把它弹出，再塞入大根堆里。

下面奉上代码：


```cpp
#include<bits/stdc++.h>

using namespace std;

int n,m;
int a[200005],to[200005];

class Max_Heap {
    private:
        int size,h[8000005];
        void exchange(int &x,int &y) {
            int t;
            t=x,x=y,y=t;
        }
        void Max_Heapify(int i) {
            int l=i << 1;
            int r=i << 1 | 1;
            int largest;
            if (l<=size && h[l]>h[i])
                largest=l;
            else
                largest=i;
            if (r<=size && h[r]>h[largest])
                largest=r;
            if (largest!=i) {
                exchange(h[i],h[largest]);
                Max_Heapify(largest);
            }
        }
    public:
        void Heap_Inc(int i,int key) {
            h[i]=key;
            while (i>1 && h[i >> 1]<h[i]) {
                exchange(h[i],h[i >> 1]);
                i>>=1;
            }
        }
        int top() {
            return h[1];
        }
        void pop() {
            h[1]=h[size];
            size--;
            Max_Heapify(1);
        }
        void push(int key) {
            size++;
            h[size]=key;
            Heap_Inc(size,key);
        }
        bool empty() {
            return size==0;
        }
        int length() {
            return size;
        }
} max_h;

class Min_Heap {
    private:
        int size,h[8000005];
        void exchange(int &x,int &y) {
            int t;
            t=x,x=y,y=t;
        }
        void Min_Heapify(int i) {
            int l=i << 1;
            int r=i << 1 | 1;
            int smallest;
            if (l<=size && h[l]<h[i])
                smallest=l;
            else
                smallest=i;
            if (r<=size && h[r]<h[smallest])
                smallest=r;
            if (smallest!=i) {
                exchange(h[i],h[smallest]);
                Min_Heapify(smallest);
            }
        }
    public:
        void Heap_Inc(int i,int key) {
            h[i]=key;
            while (i>1 && h[i >> 1]>h[i]) {
                exchange(h[i],h[i >> 1]);
                i>>=1;
            }
        }
        int top() {
            return h[1];
        }
        void pop() {
            h[1]=h[size];
            size--;
            Min_Heapify(1);
        }
        void push(int key) {
            size++;
            h[size]=key;
            Heap_Inc(size,key);
        }
        bool empty() {
            return size==0;
        }
        int length() {
            return size;
        }
} min_h;
//以上是日常HEAP操作，不解释。
int main() {
    scanf("%d%d",&m,&n);
    for (int i=1; i<=m; i++)
        scanf("%d",&a[i]);
    for (int i=1; i<=n; i++)
        scanf("%d",&to[i]);
    int it=1,now=1; /*it表示当前扫描到第几个操作，now表示当前加入到堆里的元素下标*/
    for (int it=1; it<=n; it++) {
        for (now; now<=to[it]; now++) {
            max_h.push(a[now]); //压入大根堆里
            if (max_h.length()>it-1) {
                min_h.push(max_h.top());
                max_h.pop(); /*把大根堆堆顶压入小根堆里*/
            }
        } //以上如同步骤表述
        printf("%d\n",min_h.top());
        max_h.push(min_h.top());
        min_h.pop(); //同上
    }
    return 0;
}
```
如果你看懂的这道题解并真正理解了，那么请去A掉[P1168](https://www.luogu.org/problemnew/show/1168)吧，~~个人认为比这道题还要简单点。。。~~


---


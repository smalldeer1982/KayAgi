# 易语言

## 题目描述

老师近段时间正在研究易语言，这是一款 Windows 下的可视化编程系统，由大连大有吴涛软件开发公司开发的、具有中国知识产权的系统。为了更好地学习该套系统，老师总是有意识地在实践中运用这套系统来开发程序。

这不，今天老师碰到了一个问题，那就是“当把数据放置到 KOJ 上去时，需要把测试数据改成相应的文件名”。举个例子说，如果原始测试数据文件名是 $\text{e0.in,\,e1.in\;...\;e9.in}$ 和 $\text{e0.out,\,e1.out\;...\;e9.out}$，则老师需要把文件全部改为 $\text{data1.in,\,data2.in\;...\;data10.in}$ 和 $\text{data1.out,\,data2.out\;...\;data10.out}$。程序界面如下图所示：

*（注：此处似乎缺少一张图片，但不影响对题意的理解）*

当然了，老师是编程的菜鸟，比起你可是差多了，所以他的程序不是很好，现在想请你帮老师改进这个程序。

事先，老师会告诉你所需要生成的目标文件名格式，比如，他告诉你 $\text{enger0.in}$ 和 $\text{ans}$ ，则表示目标文件中输入文件的主名是 $\text{enger}$，扩展名是 $\text{in}$，编号从 $0$ 开始而且跟在主名后面，当然了，输出文件名就依次是 $\text{enger0.ans,\,enger1.ans\;...\;enger}x\text{.ans}$，其中的 $x$ 你可以统计老师告诉你的原始文件名的个数来确定。另外，老师也会告诉你原始的所有输入数据的文件名全称，比如 $\text{a1.txt,\,a2.txt\;...\;a}x\text{.txt}$。但老师是一个粗心的人，你不要期望老师给你的文件名是按照编号从小到大给出的，但给出的文件名肯定是正确的而且满足一般输入输出文件名的规律的(编号数字肯定出现在文件主名末尾或者扩展名末尾，而且除了这个编号数字外，在原始文件名和生成的目标文件名其他的任何地方都不会出现数字)。

有些原始的输入输出文件名并不需要改变主名和扩展名，而只需改变文件编号即可，此时，老师首先会告诉你一个数字 $1$（或者 $0$），表示最终生成的目标文件的主名和扩展名不必改变，而只需把编号改为从 $1$（或者 $0$）开始即可。


## 样例 #1

### 输入

```
enger0.in ans
abc1.in abc1.out
abc2.in abc2.out
abc3.in abc3.out
abc4.in abc4.out
```

### 输出

```
enger0.in enger0.ans
enger1.in enger1.ans
enger2.in enger2.ans
enger3.in enger3.ans
```

## 样例 #2

### 输入

```
1
aa.in0 aa.ou0
aa.in1 aa.ou1
aa.in2 aa.ou2
```

### 输出

```
aa.in1 aa.ou1
aa.in2 aa.ou2
aa.in3 aa.ou3
```

# 题解

## 作者：JJA_ (赞：18)

[题目链接](https://www.luogu.com.cn/problem/P1953)

## 题目大意：

输入第一行有可能是格式，也有可能是数字。若是格式，之后的所有输入都被替换。若是数字，之后的输入只需加上序号（零或一）。

# 大体思路：

监测输入是数字还是字符串，再分别进行解题。

## 前置代码：

### 判断是不是数字：
```cpp
bool isnum(char c){return c>='0'&&c<='9';}
```

### 获取一个字符串中的数字

```cpp
string str;
stringstream ss;
int num=0;
```
```cpp
for(int i=0;i<str.size()&&isnum(str[i]);i++){
	int n;
	ss<<str[i];
	ss>>n;
	ss.clear;
	num+=n;
	num*=10;
}
num/=10;
```

## 判断输入

这里使用一个`cin`的特性，若是整形变量却流入了字符串，则`cin`会锁住。所以，可以使用`cin.clear`来继续输入字符串，整形变量会变成，$0$ 。代码：
~~~cpp
if(!(cin>>f)){
	cin.clear();
	cin>>in>>out; 
}
~~~
然后判断`f in out`和初始值一不一样就行。~~没错我的初始值是`114514`~~

~~~cpp
if(in!="114514"&&out!="114514"){
    //do something
｝
else if(f!=114514){
    //do something
}
~~~

## 一.调整格式

如果输入字符串，就判断是 `.` 前输入了数字，还是结尾处输入数字，然后将 `.` 前的部分录入一个字符串 `in_for` ， `.` 后的部分录入一个字符串 `in_back` ， 输出 `in_for<<number<<"."<<in_back` 或 `in_for<<"."<<in_back<<number` ，视数字位置情况而定。

这种情况中之后输入的所有字符都不重要，因为格式已经被调整过了。

**注意** 如果数字是在字符串末尾要倒序录入 `number` 。

代码中有注释。~~不要管这些奇怪的变量名~~
~~~cpp
bool midnum=0,backnum=0;//判断数字位置
	int bp,ffff=0;
	string b_in="",b_back="";
	if(isnum(in[in.size()-1])){//如果是末尾有数字
		backnum=1;
	}
	for(bp=0;in[bp]!='.';bp++){ 
		if(in[bp]>='0'&&in[bp]<='9'){
			for(int i=bp;in[i]>='0'&&in[i]<='9';i++){//用字符串流录入数字
				ss<<in[i];
				ss>>ffff;
				ss.clear();//血的教训
				number+=ffff;
				number*=10;
				IAKIOI++;//数字的位数
				bp++;
			}
			number/=10;//由于多乘了一个10，记得除回去
			ss.clear();
			midnum=1;//中间有数字
			break;
		}
	}
	for(int i=0;i<bp-IAKIOI;i++)b_in+=in[i];
	if(backnum==0)//如果末尾无数字
	for(int i=bp+1;i<in.size();i++)b_back+=in[i];
	else{
		int jja=0;
		for(int i=in.size()-1;isnum(in[i]);i--){//奇怪的倒序录入数字qaq
			int n;
			ss<<in[i];
			ss>>n;
			ss.clear();
			n=n*pow(10,jja);
			number+=n;
			jja++;
		}
		for(int i=bp+1;i<in.size()-jja;i++)b_back+=in[i];
	}
	string sin,sout;
	int ti=number+1;
	while(cin>>sin>>sout&&ti++){
		if(midnum==1)
		cout<<b_in<<ti-2<<"."<<b_back<<" "<<b_in<<ti-2<<"."<<out<<endl;
		else if(backnum==1)
		cout<<b_in<<"."<<b_back<<ti-2<<" "<<b_in<<"."<<out<<ti-2<<endl;
	}
}//愉快地收尾
~~~

## 二.调整序号

这种情况是输入一个数字，但数字位置仍不知道，所以还是要判定一下。

大体思路和第一种情况差不多，但是每次输入输出都要获取格式。

代码：
```cpp
else if(f==1||f==0){
	string sin,sout;
	while(cin>>sin>>sout){
		string b_in="",b_out="";
		string f_in="",f_out="";
		int pin,pnum=0,pout;
		bool backnum=0,midnum=0;
		if(isnum(sin[sin.size()-1]))backnum=1;
		for(pin=0;sin[pin]!='.'&&(!isnum(sin[pin]));pin++)b_in+=sin[pin];
		pout=pin;
		if(isnum(sin[pout])){
			while(isnum(sin[pout])){
				pout++;
			}
			midnum=1;
		}
		pout++;
		for(pout;!isnum(sin[pout])&&pout<sin.size();pout++)b_out+=sin[pout];
		for(pin=0;sout[pin]!='.'&&(!isnum(sout[pin]));pin++)f_in+=sout[pin];;
		pout=pin;
		if(isnum(sout[pout])){
			while(isnum(sout[pout])){//并不需要录入，只需要记录位数。
				pout++;
			}
		}
		pout++;
		for(pout;!isnum(sout[pout])&&pout<sout.size();pout++)f_out+=sout[pout];
		if(midnum==1&&backnum==0){//由于不知道数字位置所以有三种情况
			cout<<b_in<<f<<"."<<b_out<<" ";
			cout<<f_in<<f<<"."<<f_out<<endl; 
		}
		else if(midnum==0&&backnum==1){
			cout<<b_in<<"."<<b_out<<f<<" ";
			cout<<f_in<<"."<<f_out<<f<<endl; 
		}
		else if(midnum==0&&backnum==0){//可能没有数字。
			cout<<b_in<<"."<<b_out<<" ";
			cout<<f_in<<"."<<f_out<<endl;
		}
		f++;
	}
}
```
所以大体思路就是这样，只有代码完成稍需要细心。

## 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool isnum(char c){return c>='0'&&c<='9';}
#define MAXN 50005
int main(){
	int IAKIOI=0;
	int f;
	stringstream ss;
	int number=0;
	string in="114514",out="114514";
	if(!(cin>>f)){
		cin.clear();
		cin>>in>>out; 
	}
	if(in!="114514"&&out!="114514"){
		bool midnum=0,backnum=0;
		int bp,ffff=0;;
		string b_in="",b_back="";
		if(isnum(in[in.size()-1])){
			backnum=1;
		}
		for(bp=0;in[bp]!='.';bp++){ 
			if(in[bp]>='0'&&in[bp]<='9'){
				for(int i=bp;in[i]>='0'&&in[i]<='9';i++){
					ss<<in[i];
					ss>>ffff;
					ss.clear();
					number+=ffff;
					number*=10;
					IAKIOI++;
					bp++;
				}
				number/=10;
				ss.clear();
				midnum=1;
				break;
			}
			else backnum=1;
		}
//		cout<<number<<endl;
//		cout<<bp<<endl;
		for(int i=0;i<bp-IAKIOI;i++)b_in+=in[i];
		if(backnum==0)
		for(int i=bp+1;i<in.size();i++)b_back+=in[i];
		else{
			int jja=0;
			for(int i=in.size()-1;isnum(in[i]);i--){
				int n;
				ss<<in[i];
				ss>>n;
				ss.clear();
				n=n*pow(10,jja);
				number+=n;
				jja++;
			}
			for(int i=bp+1;i<in.size()-jja;i++)b_back+=in[i];
		}
		string sin,sout;
		int ti=number+1;
		while(cin>>sin>>sout&&ti++){
			if(midnum==1)
			cout<<b_in<<ti-2<<"."<<b_back<<" "<<b_in<<ti-2<<"."<<out<<endl;
			else if(backnum==1)
			cout<<b_in<<"."<<b_back<<ti-2<<" "<<b_in<<"."<<out<<ti-2<<endl;
		}
	}
	else if(f==1||f==0){
		string sin,sout;
		while(cin>>sin>>sout){
			string b_in="",b_out="";
			string f_in="",f_out="";
			int pin,pnum=0,pout;
			bool backnum=0,midnum=0;
			if(isnum(sin[sin.size()-1]))backnum=1;
			for(pin=0;sin[pin]!='.'&&(!isnum(sin[pin]));pin++)b_in+=sin[pin];
			pout=pin;
			if(isnum(sin[pout])){
				while(isnum(sin[pout])){
					pout++;
				}
				midnum=1;
			}
			pout++;
			for(pout;!isnum(sin[pout])&&pout<sin.size();pout++)b_out+=sin[pout];
			for(pin=0;sout[pin]!='.'&&(!isnum(sout[pin]));pin++)f_in+=sout[pin];;
			pout=pin;
			if(isnum(sout[pout])){
				while(isnum(sout[pout])){
					pout++;
				}
			}
			pout++;
			for(pout;!isnum(sout[pout])&&pout<sout.size();pout++)f_out+=sout[pout];
			if(midnum==1&&backnum==0){
				cout<<b_in<<f<<"."<<b_out<<" ";
				cout<<f_in<<f<<"."<<f_out<<endl; 
			}
			else if(midnum==0&&backnum==1){
				cout<<b_in<<"."<<b_out<<f<<" ";
				cout<<f_in<<"."<<f_out<<f<<endl; 
			}
			else if(midnum==0&&backnum==0){
				cout<<b_in<<"."<<b_out<<" ";
				cout<<f_in<<"."<<f_out<<endl;
			}
			f++;
		}
	}
}
```
望通过。

---

## 作者：Ryo_Yamada (赞：16)

这是我的第一道紫色的大模拟呢qwq

此题分别处理2种情况：有一个1或0（只需要改文件编号） 或者 只需要改文件名。

模拟没什么好说的，需要注意，**文件编号可能不止一位数**。

1. （只需要改文件编号）：将`cnt`赋值为1或0（输入的数字），每次输入一个文件名之后把编号替换成`cnt`，循环的最后`cnt++`。

2. （只需要改文件名）：扫一遍文件名，找出前缀、文件编号和后缀，变量`cnt`赋值为文件编号。

输入后，输出一遍初始名称，数字部分替换成`cnt`。输出第二个名称时检测到`.`时输出后缀名，然后`break`，每次循环结束时`cnt++`。

但是这样会有一个漏洞：如果编号在后缀的末尾，在第二个文件名输出时会直接`break`。这时，用一个`bool`变量记录是否输出过`cnt`。如果没有，输出一遍。

代码：最慢的点389ms，2.17KB。

~~压行是不可能压行的，这辈子都不可能压行的~~

Code：

```cpp
#include <bits/stdc++.h>

using namespace std;

string s1, s2;//前缀，后缀
string fname1, fname2;//文件名

int main() {
    cin >> s1;
    if(s1[0] == '0' || s1[0] == '1') { //如果更换序号
        int cnt = s1[0] - '0';
        while(cin >> fname1 >> fname2) {
            bool flag = true;
            for(int i = 0; i < fname1.size(); i++) {
                if(isdigit(fname1[i])) { //cnt记录编号
                    if(flag) { //防止有多位数字，只在第一位输出一次
                        cout << cnt;
                        flag = false;
                    }
                }
                else cout << fname1[i];
            }
            cout << " ";
            flag = true;
            for(int i = 0; i < fname2.size(); i++) {//同上，处理文件2
                if(isdigit(fname2[i])) {
                	if(flag) {
                        cout << cnt;
                        flag = false;
                    }
				}
                else cout << fname2[i];
            }
            cout << endl;
            cnt++;
        }
    }
    else { //如果要改文件名
        cin >> s2; 
        int cnt = 0;
        for(int i = 0; i < s1.size(); i++) { 
            if(isdigit(s1[i])) {//处理多位编号
                cnt *= 10;
                cnt += s1[i] - '0';
            }
        }
        while(cin >> fname1 >> fname2) {
            bool flag = true;
            for(int i = 0; i < s1.size(); i++) { 
                if(isdigit(s1[i])) {
                    if(flag) {
                        cout << cnt;
                        flag = false;             
                    }
                }
                else cout << s1[i];
            }
            cout << " ";
            flag = true;
            for(int i = 0; i < s1.size(); i++) { 
                if(isdigit(s1[i])) {
                	if(flag) {
                        cout << cnt;
                        flag = false;             
                    }
				}
                else {
                    cout << s1[i];
                    if(s1[i] == '.') {// '.'后面的替换成后缀 
                        cout << s2;
                        break;
                    }
                }
            }
            if(flag) cout << cnt; //还没输出过数字，输出 
            cout << endl;
            cnt++;
        }
    }
    return 0;
} 
```


---

## 作者：HNYLMS_MuQiuFeng (赞：14)

啊……这道大模拟……智障的我写了4个半小时，下面我来讲讲我的做法。

纯数字比较简单，在这里不再讨论，等下会在代码中体现。

看到这道题，我的第一反应是：
#### 对于第一行修改文件名部分，先找到数字，然后在前后扫描弄出他的前后缀，然后输出的时候，对于前缀我们不改动它，对于后缀代替原串的后缀输出， 又因为保证文件中的数字是从1-n，并且要求我们按字典序输出，所以我们直接输出当前数据的组数就好了。

但是！当我们愉快地打完了以后，一交上去，发现只有50pts！修改了一些小bug之后仍然只有60pts。我困惑了，为什么？？？

直到我看见了题目中的一句话：

### 但给出的文件名肯定是正确的而且满足一般输入输出文件名的规律的(编号数字肯定出现在文件主名末尾或者扩展名末尾

## 扩展名末尾
# 末尾

然后我手出了一组样例：

```cpp
lalala0.in out
ans.in1 ans.out1
```

因为我之前没有看见那一句话，所以导致我的判断中，会将ans.in判成前缀，而后缀为空，这样出来的答案就会是:


```cpp
lalala.in1.in lalala.out1.out
```


然后我就想在我的原程序上稍加修改，然后发现太麻烦了，~~一怒之下~~再三思索之后全删掉了2333。

（在这里告诫各位OIER**请认真读题**）

好了，下面言归正传。那么我们知道了这个条件后，我们就会想到：

**对于一个文件名部分，我们要首先找到那一个 '.' ，然后再处理数字，数字分为在“文件主名末尾”或者“扩展名末尾”两种情况，也就是在那一个'.'前面或在字符串末尾。**

那么这样就好办了。

**我们只要先找到那一个'.'，然后如果它前面有数字的话，就是前一种情况，否则数字就在字符串末尾。**

有了这个思路，我们就可以愉快地开始写正解了。下面附上代码，详细注释附在代码中。

```cpp
//Code by muq
#include<set>
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define fi first
#define se second
#define mp make_pair
#define inf 214748364
#define lll long long
#define pii pair<int,int>
#define me(a,b) memset(a,b,sizeof(a))
#define reph(i,a,b) for(i=a;i<=b;++i)
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rap(i,a,b) for(int i=a;i>=b;--i)
#define repp(i,a,b,c) for(int i=a;i<=b;i+=c)
#define lrep(i,a,b) for(long long i=a;i<=b;++i)
#define reg(i,d,head,a) for(int i=head[d];i;i=a[i].next)
//请无视
using namespace std;

inline void File() {
    freopen("muq.in.txt", "r", stdin);
}

string st;

int mian(void) {

    File();

    ios::sync_with_stdio(0);

    cin >> st;
    if (st.size() == 1) {
    //如果读入进来的字符串的长度为一，那么它一定是纯数字
        int num = st[0] - 48;//num即为题中要求的开始的数字，
        //表示是第几组文件
        string a, b;
        while(cin >> a) {
            int pos = 0;
            //pos表示现在我们扫描到的这一个字符串的位置
            while(a[pos] != '.')//寻找'.'所在的位置
                ++pos;
            if (a[pos - 1] >= '0' and a[pos - 1] <= '9') {
            //如果在'.'之前是数字
                int cpos = pos - 1;
                //cpos表示从头开始的不为数字的字符串结束的位置
                while(a[cpos] >= '0' and a[cpos] <= '9')
                //如果这一位是数字
                    --cpos;//cpos前移
                rep(j, 0, cpos) {//直接输出前缀
                    cout << a[j];
                }
                cout << num << '.';//输出这一组文件组数
                int len = a.size();
                ++pos;//因为上面输出了'.'所以pos要+1，
                //当然，你也可以上面不输出点，这里不加
                for(; pos < len; ++pos) 
                    cout << a[pos];//输出后缀
            }
            else {//如果在'.'之前不是数字则数字在字符串末尾
                rep(j, 0, pos - 1) {//输出前缀
                    cout << a[j];
                }
                for(; (a[pos] < '0' or a[pos] > '9'); ++pos)
                    cout << a[pos];//因为这种情况下不会改变文件名
                    //所以当a不是数字时一直输出
                cout << num;
            }
            cout << " ";//可别忘了空格，我们才处理完第一个字符串

            cin >> b;//以下同上
            pos = 0;//别忘了清零，我们正在处理第二个字符串啦！
            while(b[pos] != '.')
                ++pos;
            if (b[pos - 1] >= '0' and b[pos - 1] <= '9') {
                int cpos = pos - 1;
                while(b[cpos] >= '0' and b[cpos] <= '9')
                    --cpos;
                rep(j, 0, cpos) {
                    cout << b[j];
                }
                cout << num << '.';
                int len = b.size();
                ++pos;
                for(; pos < len; ++pos) {
                    cout << b[pos];
                }
            }
            else {
                rep(j, 0, pos - 1)
                    cout << b[j];
                for(; (b[pos] < '0' or b[pos] > '9'); ++pos)
                    cout << b[pos];
                cout << num;
            }
            ++num;//文件组数+1
            cout << endl;
        }
    }
    else {//如果要支持修改文件名操作
        int pos = 0, num = 0;
        while(st[pos] != '.')//仍然是先找到'.'
            ++pos;
        if (st[pos - 1] >= '0' and st[pos - 1] <= '9') {
        //如果前面是数字
            while(st[pos - 1] >= '0' and st[pos - 1] <= '9') 
                --pos;
            while(st[pos] != '.') {
            //把数字处理出来，表示题目要求从哪一个数字开始
                num *= 10;
                num += st[pos++] - 48;
            }
        }
        else {//否则数字在末尾
            int cpos = st.size();
            while(st[cpos - 1] >= '0' and st[cpos - 1] <= '9')
                --cpos;//找到数字的开始位置
            while(cpos < st.size()) {//处理出数字，意义同上
                num *= 10;
                num += st[cpos++] - 48;
            }
        }
        string cc;
        cin >> cc;//输入相应的要修改的输出文件的文件名
        string a, b;
        while(cin >> a) {
            int pp = 0;//仍然是处理到的这一个字符串的位置
            while(st[pp] != '.')//以下大致同前，不再赘述
                ++pp;
            if (st[pp - 1] >= '0' and st[pp - 1] <= '9') {
                int cpos = pp - 1;
                while(st[cpos] >= '0' and st[cpos] <= '9')
                    --cpos;
                rep(j, 0, cpos) 
                    cout << st[j];
                cout << num << '.';
                int len = st.size();
                //之前手贱把st写成a改了我1h啊TAT
                ++pp;
                for(; pp < len; ++pp)
                    cout << st[pp];
            }
            else {
                for(int j = 0; (st[j] < '0' or st[j] > '9'); ++j) 
                    cout << st[j];
                cout << num;
            }
            cout << " ";

            cin >> b;
            pp = 0;
            while(st[pp] != '.')
                ++pp;
            if (st[pp - 1] >= '0' and st[pp - 1] <= '9') {
                int cpos = pp - 1;
                while(st[cpos] >= '0' and st[cpos] <= '9')
                    --cpos;
                rep(j, 0, cpos)
                    cout << st[j];
                cout << num << "." << cc;
            }
            else {
                rep(j, 0, pp)
                    cout << st[j];
                cout << cc << num;
            }
            ++num;
            cout << endl;
        }
    }
    return 0;
}//written by muq(防伪标识)
```

请不要尝试复制题解，可能会有一些玄学错误QWQ。

# 祝大家NOIP 2018 RP++！
## (and认真读题+细心做题)（严肃脸）（超认真的）
**（也祝自己省一，希望留在这个优秀的班集体QWQ）** 

---

## 作者：HanPi (赞：7)

## 读题
这道题分为两种情况:

1. 给出指定的输入文件名和输出文件后缀
2. 给出文件序号从0或1开始

对于第一种情况,分析完主文件名,后缀名和数字位置后不管输入什么文件名,直接按要求输出.

第二种情况,将文件名的序号改了就直接输出.
(不需要改名,~~我就煞笔的以为要改名,只拿了50分)~~

#### 一些变量的说明
```c
// 存储输入的字符串及其长度
str1, str2;
len1, len2;
// 主文件名,输入文件扩展名,输出文件扩展名
mainname, inexname, outexname;
// flag : 数字是在 '.' 前还是后
// startnumber : 从哪个数字开始
flag, startnumber;
```
### 分析文件名
```c
// str为要分析的字符串,mainStr存主文件名,exStr存扩展名
void caifen(char* str, char* mainStr, char* exStr)
{
    int finddot = strchr(str, '.') - str;
    // 以 '.' 分隔
    
    int len = strlen(str);
    for (int i = 0; i < finddot; i++) // 取出主文件名
    {
        if ('0' <= str[i] && str[i] <= '9')
        {
            startnumber = startnumber * 10 + str[i] - '0';
            flag = 0;
        }
        else
        {
            mainStr[i] = str[i];
        }
    }
    mainStr[finddot] = 0;

    for (int i = finddot + 1; i < len; i++) // 取出扩展名
    {
        if ('0' <= str[i] && str[i] <= '9')
        {
            startnumber = startnumber * 10 + str[i] - '0';
            flag = 1;
            // 因为题目已说明数字要么在主文件名,要么在扩展名,所以不用考虑两边同时出现数字
        }
        else
        {
            exStr[i - finddot - 1] = str[i];
        }
    }
    exStr[len - finddot - 1] = 0;
}
```

### 读入
```c
scanf("%s", &str1);

int len1 = strlen(str1);

if (len1 == 1 && (str1[0] == '0' || str1[0] == '1'))
{
    int tmp = str1[0] - '0';
    while (scanf("%s%s", str1, str2) != EOF)
    {
        caifen(str1, mainname, inexname);
        if (!flag)
        {
            printf("%s%d.%s ", mainname, tmp, inexname);
        }
        else
        {
            printf("%s.%s%d ", mainname, inexname, tmp);
        }
        caifen(str2, mainname, outexname);
        if (!flag)
        {
            printf("%s%d.%s\n", mainname, tmp, outexname);
        }
        else
        {
            printf("%s.%s%d\n", mainname, outexname, tmp);
        }
        tmp++;
    }
    return 0;
}
else
{
    caifen(str1, mainname, inexname);
    scanf("%s", &outexname);
}

while (scanf("%s%s", str1, str2) != EOF)
{
    if (!flag)
    {
        printf("%s%d.%s %s%d.%s\n", mainname, startnumber, inexname, mainname, startnumber, outexname);
    }
    else
    {
        printf("%s.%s%d %s.%s%d\n", mainname, inexname, startnumber, mainname, outexname, startnumber);
    }
    startnumber++;
}
```
就不贴完整代码了


------------
PS:
#### 第二种情况下可以进行以下优化:

1. 读入后在要输出数字时输出序号(1次),可以提速大概1ms

2. 直接边读入边处理,原理同上.可以淦到92ms(要注意'\r'和'\n'的问题,洛谷的环境是linux的,不太明白的可以用洛谷的[在线IDE](https://www.luogu.com.cn/ide)测试一下)

可以看一下我写的优化:

[优化I不进行拆分(94ms)](https://www.luogu.com.cn/paste/dywu745v)

[优化II单个字符读入(92ms)](https://www.luogu.com.cn/paste/ddtn2yzy)

###### 我突然发现好像第一种情况也可以优化 ~~(但不想写了,逃)~~
###### 乌拉乌拉~~

---

## 作者：Dirt、 (赞：5)

题意似乎描述不太清楚？（也可能是我理解问题）：

对于输入
```
enger0.in ans
abc.in1 abc.out1
```
应该输出
```
enger0.in enger0.ans
```
而不是
```
enger.in0 enger.ans0
```

思路：针对第一行的两种情况分别处理。

上代码

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<string>
using namespace std;
string x,in,out,a,b,name;
int cnt;
bool flag,pos;
bool num(char c){return c>='0'&&c<='9';}//判断是否是数字
bool word(char c){return (c>='a'&&c<='z');}//判断是否是字母
int main()
{
	cin>>x;
	if(x.size()==1)//如果是数字
	{
		cnt=x[0]-'0';//存下数字
		while(cin>>a)
		{
			cin>>b;
			for(int i=0;i<a.size();i++)
			{
				if(num(a[i]))
				{	
					if(!num(a[i+1])) printf("%d",cnt);
                    //如果是数字就先跳过，到最后一位的时候输出序号
				}
				else printf("%c",a[i]);
			}
			putchar(' ');
			for(int i=0;i<b.size();i++)
			{
				if(num(b[i]))
				{
					if(!num(b[i+1])) printf("%d",cnt);
				}
				else printf("%c",b[i]);
			}
			putchar('\n');
			cnt++;//序号递增
		}
		return 0;
	}
	cin>>out;//输出文件扩展名
	for(int i=0;i<x.length();i++)
	{
		if(x[i]=='.') flag=true;//flag代表当前是否出现过'.'
		else if(num(x[i])) 
		{
			if(flag) pos=true;//数字出现在'.'之后
			else pos=false;//在'.'之前
			cnt=cnt*10+x[i]-'0';//一位一位读数字
		}
		else if(!flag) name+=x[i];//'.'之前的是主名
		else if(flag) in+=x[i];//之后的是输入文件扩展名
	}
	while(cin>>a)
	{
		cin>>b;
		if(pos)
		{
			cout<<name;
			putchar('.');
			cout<<in;
			printf("%d ",cnt);
			cout<<name;
			putchar('.');
			cout<<out;
			printf("%d",cnt);
		}
		else
		{
			cout<<name;
			printf("%d",cnt);
			putchar('.');
			cout<<in;
			putchar(' ');
			cout<<name;
			printf("%d",cnt);
			putchar('.');
			cout<<out;
		}//直接按照给定的输入格式输出
		cnt++;
		putchar('\n');
	}
	return 0;
}
```
~~OI生涯首个不看题解过的正常的紫题还是个大模拟可真是丢人~~

---

## 作者：WanderingTrader (赞：3)

社区里都说是大模拟，不过自己感觉还好，我自己写的就1.28k。写这题时我正陷入某杀的泥潭中，在好友的建议下决定先把这题切了涨了点信心。~~结果先A了某杀才A了这题~~

### 题目分析
操作流程：
1. 读入一个字符串`IN`。如果`IN`是文件名而不是`0`或`1`（直接看`IN[0]`即可），读入一个字符串`ANS`，为目标文件名的格式。

2. 读入两个字符串`in`,`out`，为格式。剩下的全部读进垃圾内存，但注意要记录文件名的数量`n`。令整数`st`为文件的起始编号

3. 如果`IN`是文件名的话，将`in`和`out`全部改成`IN`，从其中提取数字，处理出`st`，然后将`out`中的后缀改为`ANS`。

4. 如果`IN`不是文件名，直接将`st`设为`IN`代表的数字。

5. 输出

### 代码
首先有一些功能函数：

`del(s,u)`：将字符串`s`的第`u`位删除
```cpp
void del(char* s,int u){for(int i=u;s[i];++i) s[i]=s[i+1];} 
```
~~精准覆盖~~

`find(s,l,r)`：在字符串`s`中找到第一个介于`[l,r]`之间的字符，没找到返回-1。如果找单个字符`c`可以`find(s,c,c)`。
```cpp
int find(char* s,char l,char r)
{
	for(int i=0,sz=strlen(s);i<sz;++i)
		if(s[i]>=l&&s[i]<=r) return i;
	return -1;
}
```
`output(s,n)`：将代表文件名的字符串`s`中的编号修改为`n`，并输出。
```cpp
void output(char* s,int n)
{
	int p=find(s,'0','9');
	while(isdigit(s[p+1])) del(s,p+1);
	for(int i=0;i<p;++i) putchar(s[i]);
	printf("%d",n);
	for(int i=p+1,sz=strlen(s);i<sz;++i) putchar(s[i]);
}
```
于是代码就很简单了。

根据上面的步骤，1&2：
```cpp
	scanf("%s",IN); 
	if(IN[0]!='1'&&IN[0]!='0') scanf("%s",ANS);
	scanf("%s%s",in,out);
	while(~scanf("%s%s",tmp,tmp)) ++n;
```
3：
```cpp
void solve()
{
	memcpy(in,IN,sizeof(IN));
	memcpy(out,IN,sizeof(IN));
	int p1,p2=find(out,'0','9'),x=out[p2]-'0';
	while(isdigit(out[p2+1])){x=x*10+out[p2+1]-48;del(out,p2+1);}//计算st 留下p2作为数字标识符
	p1=find(out,'.','.');//找到分隔点
	for(int i=p1+1,sz=strlen(out);i<sz;++i) out[i]=0;//先清空
	for(int i=0,sz=strlen(ANS);i<sz;++i) out[i+1+p1]=ANS[i];//再拷贝
	if(p2>p1) out[strlen(out)]='0';//数字在扩展名 补上已被清除的数字标识符
	st=x;
}
//in main()
if(IN[0]!='1'&&IN[0]!='0') solve();
```
4：
```cpp
	else st=IN[0]-'0';
```
5：
```cpp
void output(char* s,int n)
{
	int p=find(s,'0','9');//找到数字标识符
	while(isdigit(s[p+1])) del(s,p+1);//删除多余数字 留p标识
	for(int i=0;i<p;++i) putchar(s[i]);
	printf("%d",n);
	for(int i=p+1,sz=strlen(s);i<sz;++i) putchar(s[i]);
}
// in main()
	for(int i=0;i<n;++i)
	{
		//输出两个文件名 别忘了编号+st
		output(in,i+st); 
		putchar(' ');
		output(out,i+st);
		puts("");
	}
```
全部代码就不放了。

后记：此文写于切掉某棋后不久。感觉此题相比某杀和某棋这种大型模拟，或是某复杂度这种中型模拟，真是小巫见大巫了。只能算是和龙虎斗一个级别的小型模拟。（毕竟我这std才49行）

$$\texttt{The End.}$$

---

## 作者：AFOier (赞：3)

这算不上大模拟吧……我只用了30min

也没有什么细节，主要就是看懂题目就行了

题目应该不是很难理解吧，就是把输入的字符串改成指定的字符串输出，这里对题意不过多叙述了

 673ms /  0.79MB 
代码：1.88KB C++.(不会压行~)

一堆废话之后来讲解一下题目吧：

①我们先挑简单的做[手动滑稽],所以先做**只输入了一个数字的情况**：我们只需在每一行的输入后遍历输入的两个字符串，把其中的数字改成正确的数字（我的代码中用num表示），其它照原样输出

②**然后是输入两个字符串的情况**：通过字符串的操作提取出文件名，输入后缀和输出后缀以及数字的位置（在文件名后面还是后缀名后面）。然后在接下来的n行中并不需要鸟那些输入的字符串，只需要按照要求直接输出即可。

看完整代码比较好理解：
```
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;
char sum;
string a,b;
int num;
int main(){
    cin>>sum;//输入第一个字符（注意不是字符串）
    if(sum=='1'||sum=='0'){//情况①
        num=sum-'0';//第一个数字
        while(cin>>a>>b){
            for(int i=0;i<a.size();i++){
                if(a[i]>='0'&&a[i]<='9'){
                    if(i==a.size()-1||a[i+1]<'0'||a[i+1]>'9')cout<<num;//数字的最后一位数，输出num
                }
                else cout<<a[i];//不是数字
            }
            cout<<" ";
            for(int i=0;i<b.size();i++){
                if(b[i]>='0'&&b[i]<='9'){
                    if(i==b.size()-1||b[i+1]<'0'||b[i+1]>'9')cout<<num;
                }
                else cout<<b[i];
            }//同上
            cout<<endl;
            num++;//记得要num++
        }
    }
    else{//情况②
    	a="";a+=sum;//因为先前输入了sum,所以要把sum放在文件名的最前面
    	cin>>b;a+=b;//a此刻是完整的文件名+输入后缀
    	cin>>b;//输出后缀
    	int num1=0;//num1在这里等同于上面的num
    	bool p1=false,p2=false,p=false;//p是判断现在处于文件名还是后缀名中，p1表示数字在文件名后，p2表示数字在后缀名后
    	for(int i=0;i<a.size();i++){
            if(a[i]>='0'&&a[i]<='9'){
            	num1=num1*10+a[i]-'0';//求第一个输出的数字
            	if(p==false)p1=true;
            	else p2=true;
            }
            if(a[i]=='.')p=true;//改变p
        }
        for(int i=0;i<b.size();i++){
            if(b[i]>='0'&&b[i]<='9')p1=true;
        }//同上
       	string m1,m2,wjm="",tzsr="",tzsc="";
       	int i;
       	for(i=0;i<a.size();i++){
       		if(a[i]=='.')break;
       		if(a[i]>'9'||a[i]<'0')wjm+=a[i];
		}
		for(i;i<a.size();i++){
			if(a[i]!='.'&&(a[i]>'9'||a[i]<'0'))tzsr+=a[i];
		}
		for(int j=0;j<b.size();j++)
		if(b[j]>'9'||b[j]<'0')tzsc+=b[j];
        //以上为分解文件名，输入后缀和输出后缀
       	while(cin>>m1>>m2){
       		cout<<wjm;
       		if(p1==true)cout<<num1;//文件名后数
       		cout<<"."<<tzsr;
       		if(p2==true)cout<<num1;//后缀名后数
       		cout<<" "<<wjm;
       		if(p1==true)cout<<num1,num1++;//同上，注意num1++
       		cout<<"."<<tzsc;
       		if(p2==true)cout<<num1,num1++;//同上，注意num1++
       		cout<<endl;
		}
	}
}
```

---

## 作者：囧仙 (赞：2)

## 题解

容易发现，本题是个二合一。由于第二问比第一问略微简单（指码量上），因此本文先从子任务 $2$ 讲起。

### 子任务 $2$

观察发现，我们要做的就是把每行里面，**所有数字替换为当前应该标的标号**。考虑到每行必然有两个数字要被替换，我们按照下面流程操作：

1. 从头开始跳过所有非数字字符，直到碰到第一个数字字符。可以使用 $\verb!isdigit!$ 函数判断一个字符是否是数字字符。对于非数字字符，直接输出。

2. 输出当前应该标的标号。

3. 跳过接下来的所有数字字符，不输出这些字符。

4. 再执行一次 $1\sim 3$ 操作，接着输出剩下来的所有字符。

对于每一行输入都执行这样的操作，那么子任务 $2$ 就做完了。

### 子任务 $1$

考虑将子任务 $2$ 转化为子任务 $1$。具体而言，我们根据给定的第一个文件名，以及应有的后缀名补全出一对完整的文件名。（例如，题面上的文件名补全后就是 $\verb!eager0.in eager0.ans!$）。具体操作起来就是把小数点 $\verb!.!$ 后面的非数字字符替换成题目给定的后缀。类似于子任务 $2$，不再赘述。

然后我们发现，对于每一行输入都对我们补全的这对文件名执行子任务 $2$ 的操作，就完工了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
using namespace std;
int rdl(char *S){
	int l=0;
	while(!isprint(S[l]=getchar())) if(S[l]==EOF) return 0; ++l;
	while( isprint(S[l]=getchar())) ++l; S[l]=0;  return l;
}
const int MAXN =100+3;
int n,l,g,p=1,q; char F[MAXN],G[MAXN];
void cng(char *S){
	int t=0; up(0,1,i){
		for(;!isdigit(S[t]);++t) putchar(S[t]);
		printf("%d",n);
		for(; isdigit(S[t]);++t);
	}
	++n;for(;S[t];++t) putchar(S[t]); puts("");
}
int main(){
	scanf("%s",F),l=strlen(F); if(l==1){
		n=F[0]-'0'; while((l=rdl(G))>1) cng(G);
	} else {
		up(0,l-1,i) if(isdigit(F[i])) n=n*10+F[i]-'0';
		scanf("%s",G),g=strlen(G); F[l++]=' ';
		for(;F[p-1]!='.';++p) F[l++]=F[p];
		for(;isalpha(F[p]);++p); memcpy(F+l,G,g),l+=g;
		for(;F[p  ]!=' ';++p) F[l++]=F[p];
		while((l=rdl(G))>1) cng(F);
	}
	return 0;
}
```

---

## 作者：钾肥 (赞：2)

## 题面

https://www.luogu.com.cn/problem/P1953

## 基本思路

很显然就是一个字符串处理的模拟题, 说到字符串, ~~就想到美国人的算法, 就想到今年下半年,~~ **正则表达式** 是一个常用工具, 而 **C++ 11** 中引入了对正则表达式的支持(在 ```<regex>``` 中), 我们可以用正则表达式进行匹配与替换.

## 原生字符串

这是 **C++11** 中引入的语法糖, 格式为 ```R"(A_String)"``` , A_String 的字面值会被原封不动的保存, 这样我们的正则表达式中就不用每次都用 **\\\\** 来转义了.

## regex的使用

出门右拐 CppReference: 

https://zh.cppreference.com/w/cpp/header/regex

网络上也有很多介绍, 在此就不赘述了.

**注意:**

**smatch** 的 **str()** 函数, 参数为 **0** 时返回的是匹配的整个串.


## 本题的坑点

不要看到样例就简单的以为首行两个字符串和一个数字和接下来文件名的格式绑定在一起, 下方文件名的格式需要先判断一下, 再处理.

## 解题

### 正则表达式

既然我们要用正则来做这题, 怎么写正则表达式就很关键了.

根据题目所述, 我们很自然的想到用字母, 数字以及点来分别匹配文件的主名, 编号, 扩展名.

所以我们就有如下的表达式: 

```cpp
	regex e(R"(([a-zA-Z]{1,})([0-9]{1,})([a-zA-Z\.]{1,}))");//主名 编号 后缀名, abc123.def
	regex E(R"(([a-zA-Z]{1,})([a-zA-Z\.]{1,})([0-9]{1,}))");//主名 后缀名 编号, abc.def123
```

接下来就是语法题了, 请看完整代码.

## 完整AC代码

```cpp
#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <iomanip>
#include <iostream>
#include <map>
#include <regex> 
#include <sstream>
#include <string>
#include <vector> 

using namespace std;

#ifdef LOCAL
#define debug(format, args...) \
printf(format, ##args)
#define dbg(args...) __f(args)
template <typename Arg1>
void __f(const Arg1& arg1){
	cout << arg1;
}
template <typename Arg1, typename... Args>
void __f(const Arg1& arg1, const Args&... args){
	cout << arg1;
	__f(args...);
}
#else
#define debug(format, args...)
#define dbg(...)
#endif

using ll = long long;
using ld = long double;

int x;

string s, h, num, in, out, s1, s2;

int main(){
	#ifndef LOCAL
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	#endif 
	cin >> s;
	regex e(R"(([a-zA-Z]{1,})([0-9]{1,})([a-zA-Z\.]{1,}))");
	regex E(R"(([a-zA-Z]{1,})([a-zA-Z\.]{1,})([0-9]{1,}))");
	if (s.length() == 1 && (s[0] == '1' || s[0] == '0')){
		x = atoi(s.c_str());
		cin >> s1 >> s2;
		smatch m;
		regex_search(s1, m, e);
		if (m.size()){
			cout << m.str(1) << x << m.str(3) << ' ';
			regex_search(s2, m, e);
			cout << m.str(1) << x << m.str(3) << '\n';
			for (int i = 1; ; i++){
				if (cin >> s1 >> s2){
					regex_search(s1, m, e);
					cout << m.str(1) << i + x << m.str(3) << ' ';
					regex_search(s2, m, e);
					cout << m.str(1) << i + x << m.str(3) << '\n';
				}
				else{
					return 0;
				}
			}
		}
		else{
			regex_search(s1, m, E);
			cout << m.str(1) << m.str(2) << x << ' ';
			regex_search(s2, m, E);
			cout << m.str(1) << m.str(2) << x << '\n';
			for (int i = 1; ; i++){
				if (cin >> s1 >> s2){
					regex_search(s1, m, E);
					cout << m.str(1) << m.str(2) << i + x << ' ';
					regex_search(s2, m, E);
					cout << m.str(1) << m.str(2) << i + x << '\n';
				}
				else{
					return 0;
				}
			}
		}
	}
	else{
		cin >> out;
		smatch m;
		regex_search(s, m, e);
		if (m.size()){
			h = m.str(1);
			num = m.str(2);
			in = m.str(3);
			x = atoi(num.c_str());
			for (int i = 0; ; i++){
				if (cin >> s1 >> s2){
					cout << h << i + x << in << ' ';
					cout << h << i + x << '.' + out << '\n';
				}
				else{
					return 0;
				}
			}
		}
		else{
			regex_search(s, m, E);
			h = m.str(1);
			num = m.str(3);
			in = m.str(2);
			x = atoi(num.c_str());
			for (int i = 0; ; i++){
				if (cin >> s1 >> s2){
					cout << h << in << i + x << ' ';
					cout << h << '.' + out << i + x << '\n';
				}
				else{
					return 0;
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：Durancer (赞：1)

### 前言

认真读题就没啥问题的说，$\text{40min}$ 绰绰有余。

### 读题

首先要明确，我们要解决，输入扩展名，输出扩展名，文件名，文件数字后缀，以及起始数字，这些量。

下面就说说一些需要注意的点。

1、数字在哪里？

>编号数字肯定出现在文件主名末尾或者扩展名末尾。

由这句话我们可以知道，数字编号只会出现在两个地方，所以在处理的时候我们需要判断以下。

2、起始数字

> 你不要期望老师给你的文件名是按照编号从小到大给出的

这句话并没有什么用处，用来迷惑你的，我们只需要看一看一开始给的是什么，然后按着那个顺序递增输入就行了，**不用担心前导零**

3、文件名

文件名不会出现不同的，输入输出文件都是相同的。

4、输入扩展名，输出扩展名

这些没啥好说的，这些都是唯一的并不会出现多个。

### 框架构建

虽然我的代码貌似更长一些，但是可以说是特别清晰的那种，在写大模拟的时候最好把相同的功能都放到一个函数中进行操作，不要在主函数中形成一堆。

一、两个用一个空格分隔的字符串，分别表示最终生成的目标文件名的格式（第一个表示生成的目标文件中的第一个输入文件的名字）。

这种情况下，对第一个字符进行存储 `文件名`，`起始数字`，`输入扩展名`，`数字位置`。第二个字符进行储存 `输出扩展名`。

最重要的是判断数字的位置，按照是先出现点，后出现数字，还是先出现数字后出现点来判断即可。

至于需要输出多少，简单记录即可。

代码下放 $↓$。

```cpp
void work1()
{
	//不需要看顺序了。
	//cin>>issue; 
	cin>>out;
	int len=issue.length();
	underwin=true;//先预先预测在文件名后面 
	for(int i=0;i<len;i++)
	{
		if(issue[i]=='.')
		{
			dot=true;
			continue;
		}
		if(dot and issue[i]>='0' and issue[i]<='9')//如果在.后面出现数字
		{
			underwin=false;
			underkuo=true;
		} 
		if(issue[i]<'0' or issue[i]>'9' and !dot)//文件名 
			win+=issue[i];
		if(issue[i]>='0' and issue[i]<='9' and i<=len-1)//找数字 
			num=(num<<1)+(num<<3)+(issue[i]^'0');
		if(issue[i]<'0' or issue[i]>'9' and dot)//扩展名in 
			in+=issue[i];
	} 
	//cout<<num<<" "<<win<<" "<<in<<" "<<" "<<out<<endl;
	string s;
	while(cin>>s) cnt++;
	cnt/=2;
	if(underwin) output_win();
	else if(underkuo) output_kuo();
}
```

二、只有一个数字1（或者0）

这种情况解决了 `起始数字` 的问题，对于其他的，我们只需要对接下来输入的第一对文件进行处理 `输入扩展名`，`输出扩展名`，`数字位置`，`文件名` 即可。

代码下放 $↓$。

```cpp
void work2()
{
	string iue; 
	if(issue[0]=='0') num=0;
	else if(issue[0]=='1') num=1;
	cnt+=2;
	cin>>issue>>iue;
	int len=issue.length();//进行输入的处理 
	underwin=true;//先预先预测在文件名后面 
	for(int i=0;i<len;i++)
	{
		if(issue[i]=='.')
		{
			dot=true;
			continue;
		}
		if(dot and issue[i]>='0' and issue[i]<='9')//如果在.后面出现数字
		{
			underwin=false;
			underkuo=true;
		} 
		if(issue[i]<'0' or issue[i]>'9' and !dot)//文件名 
			win+=issue[i];
		if(issue[i]<'0' or issue[i]>'9' and dot)//扩展名in 
			in+=issue[i];
	} 
	len=iue.length();
	dot=false;
	for(int i=0;i<len;i++)
	{
		if(iue[i]=='.')
		{
			dot=true;
			continue;
		}
		if(iue[i]<'0' or iue[i]>'9' and dot)//扩展名in 
			out+=iue[i];
	} 
	string s;
	while(cin>>s) cnt++;
	cnt/=2;
	if(underwin) output_win();
	else if(underkuo) output_kuo();
}
```

### 完整代码

[Here！！！](https://www.luogu.com.cn/paste/0boudcn9)

---

## 作者：wzf2000 (赞：1)

本题较基础，主要是程序实现上有一些困难。此题需分两种情况，一种第一行纯数字，第二种需改文件名。

纯数字较简单，不附代码，以下是修改文件名部分的代码：

```delphi

      a:=pos(' ',s1);
      s2:=copy(s1,1,a);
      s3:=copy(s1,a+1,length(s1)-a);
      j:=1;
      while s2[j]<>'.' do
        j:=j+1;
      s3:=copy(s2,1,j)+s3;
      j:=1;
      while not (s2[j] in ['0'..'9']) do
        j:=j+1;
      f:=j;
      while s2[f] in ['0'..'9'] do
        f:=f+1;
      val(copy(s2,j,f-j),g);
      for k:=1 to i do
        begin
          s[k]:=s2+' '+s3;
          d:=j;
          c:=0;
          while s[k,d] in ['0'..'9'] do
            begin
              d:=d;
              c:=c;
            end;
          val(copy(s[k],j,d-j));
          if (e<10) and (g<10) then
            s[k,j]:=chr(g+48)
          else
            begin
              str(g,s4);
              s[k]:=copy(s[k],1,j-1)+s4+copy(s[k],j+c,length(s[k])-j-c+1);
            end;
          d:=j;
          c:=0;
          while s[k,d] in ['0'..'9'] do
            begin
              d:=d;
              c:=c;
            end;
          val(copy(s[k],j,d-j),e);
          if (e<10) and (g<10) then
            s[k,j+length(s2)+1]:=chr(g+48)
          else
            begin
              str(g,s4);
              l:=1;
              while not (s[k,l] in ['0'..'9']) do
                l:=l;
              m:=l;
              while s[k,m] in ['0'..'9'] do
                m:=m;
              n:=m;
              while not (s[k,n] in ['0'..'9']) do
                n:=n;
              o:=n;
              while s[k,o] in ['0'..'9'] do
                o:=o;
              s[k]:=copy(s[k],1,l-1)+s4+copy(s[k],m,n-m)+s4+copy(s[k],o,length(s[k])-o+1);
            end;
          g:=g+1;
        end;

```sy（邵逸）同学的方法速度更快一些，而且不用数组。
也可参考一下：

```delphi

var    
  s,s1:string;    
  n:longint;    
    
procedure f(s1:string);    
var    
  l,p,i:longint;    
  s2,a1,a2,b1,b2:string;    
begin    
  l:=length(s1);    
  p:=pos(s1,' ');    
  s2:=copy(s1,p,l-p);    
  delete(s1,p,l-p);    
  p:=pos(s1,'.');    
  l:=length(s1);    
  if s1[p-1] in ['0'..'9'] then    
    begin    
      for i:=1 to p do    
        if s1[i] in ['0'..'9'] then break;    
      dec(i);    
      a1:=copy(s1,1,i);    
      a2:=copy(s1,p,l-p);    
      if length(s)=1 then    
        begin    
          p:=pos('.',s2);    
          l:=length(s2);    
          for i:=1 to p do    
            if s2[i] in ['0'..'9'] then break;    
          dec(i);    
          b1:=copy(s2,1,i);    
          b2:=copy(s2,p,l-p);    
          val(s,l);    
        end    
        else    
          begin    
            b1:=a1;    
            b2:=s2;    
            val(copy(s1,i+1,p-i),l);    
          end;    
      for i:=l to n-1+l do writeln(a1,i,'.',a2,' ',b1,i,'.',b2);    
    end    
      else    
        begin    
          for i:=p+1 to l do    
            if s1[i] in ['0'..'9'] then break;    
          a1:=copy(s1,1,p);    
          a2:=copy(s1,p+1,i-p);    
          if length(s)=1 then    
            begin    
              p:=pos('.',s2);    
              l:=length(s2);    
              for i:=p+1 to l do    
                if s2[i] in ['0'..'9'] then break;    
              b1:=copy(s2,1,p);    
              b2:=copy(s2,p,i-p);    
              val(s,l);    
            end    
        else    
          begin    
            b1:=a1;    
            b2:=s2;    
            val(copy(s1,i,l-i+1),l);    
          end;    
          for i:=l to n-1+l do writeln(a1,'.',a2,i,' ',b1,'.',b2,i);    
        end;    
end;    
    
begin    
  readln(s);    
  while not eof do    
    begin    
      n:=n+1;    
      readln(s1);    
    end;    
  if length(s)=1 then f(s1)    
    else f(s);    
end.   

```ps.不要直接copy代码


---

## 作者：CSP_Sept (赞：0)

一道大模拟（悲

## $\text{Part 1}$ 前置知识

1. `isdigit` 函数，原型是 `bool isdigit(char c)`，若 $c\in[\tt 0,9]$，则返回 $1$，否则返回 $0$。
2. 基础的 string 类字符串操作。

## $\text{Part 2}$ 操作方式 $\&$ 细节

### 2.1 第一类

单个字符（`0` / `1`），使用变量 $cnt$ 记录每次文件的编号，如果读到输入字符串的数字部分，就直接输出 $cnt$ 走人。

### 2.2 第二类

输入 $s1,s2$，首先分离出 $s1$ 中起始的编号，也用 $cnt$ 记录。

- （2.2.1）然后先输出第一个字符串，方法与 2.1 类似。
- （2.2.2）再输出第二个字符串，先按照 2.2.1 的方法输出 `.` 前的部分，然后再输出 $s2$。

___

这样就容易得到代码。

## $\text{Part 3}$ 代码

[$\text{Link}$](https://paste.ubuntu.com/p/XzGWZDYwWP/)

---


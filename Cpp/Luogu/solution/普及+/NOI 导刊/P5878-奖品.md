# 奖品

## 题目描述

学校刚开完运动会，准备为尽可能多的同学评奖，并为每个人颁发一份奖品。一份奖品包括 $N$ 个物品，如：$5$ 支铅笔、$10$ 本练习薄等。每份奖品完全一样。虽然学校的保管室里还有一些办去年运动会后剩余的物品。在商店里，每种物品都有很多，但是，只有两种包装：大盒或小盒，并且不拆开买。

现在的问题是，充分利用这 $M$ 元钱，最多可准备多少分这样的奖品？


## 说明/提示

对于全部的数据，满足：

$1 \le N \le 100$，$1 \le M \le 10^5$。

$10 \le x, pm \le 100$，$1 \le y, sm \le 100$，$sm < sv \le 100$，$pm<pv\le 100$。

## 样例 #1

### 输入

```
2 100
10 8 10 10 13 11
12 20 6 10 17 24
```

### 输出

```
5```

## 样例 #2

### 输入

```
3 65
10 5 7 10 13 14
10 5 8 11 14 15
10 5 9 12 15 16
```

### 输出

```
2```

# 题解

## 作者：AKPC (赞：10)

### 思路
可以准备的奖品数量是单调的，即如果能准备 $x$ 个，那么一定能准备 $x-1$ 个，如果不能，那么 $x+1$ 个更不能准备。所以本题具有单调性。

考虑二分。将 $l$ 设为 $0$，$r$ 设为 $m$（不可能有一份奖品低于一块钱），$mid=\dfrac{l+r}{2}$。每次二分判断 $mid$ 件是否可行。如果可行，$mid\to l$，表示继续搜可不可以买更多件，反之 $mid+1\to r$，从前面找答案。

在判断函数中，假设只有 $1$ 种物品，那么我们可以用 $f_i$ 表示花 $i$ 元钱，最多买多少个物品，这类似于背包状态转移。枚举 $i$，当 $f_i\geq x\times mid - y$ 就退出循环，比较 $i$ 和 $m$ 的大小，如果的话就返回否。

如果是不止一件物品的话，我们只要将上述过程重复 $n$ 次，每次循环得到的 $i$ 累加进 $ans$，与 $m$ 比较就行了。如果 $ans\leq m$，就说明 $mid$ 件是可行的。

搜完之后得到的答案即为最终答案。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m,a[101][6],f[100001],l,r;
bool check(int mid){
	int ans=0;
	for (int i=1;i<=n;i++){
		memset(f,0,sizeof(f));bool tmp=0;
		for (int j=0;j<=m;j++){
			if (j>=a[i][3]) f[j]=max(f[j],f[j-a[i][3]]+a[i][2]);
			if (j>=a[i][5]) f[j]=max(f[j],f[j-a[i][5]]+a[i][4]);
			if (f[j]>=a[i][0]*mid-a[i][1]){
				ans+=j,tmp=1;
				break;
			}
		}
		if (!tmp) return 0;
	}
	return ans<=m;
}
signed main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++) cin>>a[i][0]>>a[i][1]>>a[i][2]>>a[i][3]>>a[i][4]>>a[i][5];
	l=0,r=m;
	while (l<r){
		int mid=(l+r+1)/2;
		if (check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
	return 0;
}
```


---

## 作者：风急风也清 (赞：7)

直接进入正题。

看完题，发现这道题如果 $k$ 合法，$k-1$ 一定合法。
如果 $p$ 不合法，$p+1$ 一定不合法。

所以这道题目具有单调性，由此自然而然的想到了二分答案。

如何二分在这不重点讲了，因为是老模板题了。

**check 函数写法**。  

假设当前可以买 $mid$ 件奖品，下标为 $i$。

这里有一个特判，如果原来剩下的够你多需要的就可以直接跳过。否则，我们就需要买。

那么，我们应该如何去买呢？

这里有一个老师所讲的经典的题目，百元买百鸡。

你有 $n$ 元，每只公鸡需要 $x$ 元，每只母鸡 $y$ 元，每一种鸡都必须买一只，问有多少种方案（可以自己思考一下这一小学奥数题与这题有什么关系）。

在计算机中，我们只需枚举小件奖品的数量，然后算出大件奖品的数量，最后计算总和就行了。

附上代码：
```c
#include <bits/stdc++.h>
using namespace std;
int n, m;
int x[105], y[105], sm[105], pm[105], sv[105], pv[105];
bool check(int mid)
{
    int zm = 0;
    for (int i = 1; i <= n; i++)
    {
        int money = 1000000, need = 0, sn = 0;
        if (x[i] * mid - y[i] > 0)
            need = x[i] * mid - y[i]; //特判
        if (need % sm[i] == 0)
            sn = need / sm[i];
        else
            sn = need / sm[i] + 1;    //小件奖品的数量
        for (int j = 0; j <= sn; j++) //枚举小件奖品数量
        {
            int bn = 0;
            if (need - j * sm[i] > 0)
                bn = need - j * sm[i]; //注意特判（划重点这里被坑了!!!!）
            if (bn % sv[i] == 0)
                bn = bn / sv[i];
            else
                bn = bn / sv[i] + 1;                    //计算大件奖品数量
            money = min(money, j * pm[i] + bn * pv[i]); //更新
        }
        zm += money;
    }
    return zm <= m;
}
int find(int lo, int hi) //模板二分
{
    while (lo + 1 < hi)
    {
        int mid = (hi + lo) / 2;
        if (check(mid))
            lo = mid;
        else
            hi = mid;
    }
    return lo;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> x[i] >> y[i] >> sm[i] >> pm[i] >> sv[i] >> pv[i];
    cout << find(0, m); //边界为0~m
    return 0;
}
```


---

## 作者：syksykCCC (赞：6)

正着发现很难求解，于是很自然的想到二分答案。

比如现在在检验准备 $mid$ 件是否可行。假设只有 $1$ 种物品，那么我们可以用 $f_i$ 表示花 $i$ 元钱，最多买多少个物品，类似背包转移，当 $f_i \ge x \times mid - y$ 就退出，比较 $i$ 和 $m$ 的大小。如果永远买不到那么多件物品的话就可以直接返回失败。

如果是不止一件物品的话，我们只要将上述过程重复 $n$ 次并求和，与 $m$ 比较就行了。

时间复杂度 $O(nm\log m)$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105, M = 1e5 + 5;
int n, m, x[N], y[N], sm[N], pm[N], sv[N], pv[N];
int f[M];
inline bool check(int mid)
{
	int cst = 0;
	for(int i = 1; i <= n; i++)
	{
		memset(f, 0, sizeof f);
		bool found = false;
		for(int j = 0; j <= m; j++)
		{
			if(j >= pm[i]) f[j] = max(f[j], f[j - pm[i]] + sm[i]);
			if(j >= pv[i]) f[j] = max(f[j], f[j - pv[i]] + sv[i]);
			if(f[j] >= x[i] * mid - y[i]) { cst += j; found = true; break; } 
		}
		if(!found) return false;
	}
	return cst <= m;
}
int main()
{
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; i++)
		scanf("%d %d %d %d %d %d", &x[i], &y[i], &sm[i], &pm[i], &sv[i], &pv[i]);
	int lb = 0, rb = m, mid;
	while(lb < rb)
	{
		mid = lb + rb + 1 >> 1;
		if(check(mid)) lb = mid;
		else rb = mid - 1;
	}
	printf("%d\n", lb);
	return 0;
}
```

---

## 作者：Genius_Star (赞：4)

### 题意：

打模拟赛过来的……

有一个奖品中有 $n$ 个物品，第 $i$ 个物品需要有 $x_i$ 个，学校初始有 $y_i$ 个，第 $i$ 个物品有两种购买方式，数量分别为 $a_1,a_2$，价格分别为 $b_1,b_2$，你有 $m$ 块钱，问最多能准备多少份奖品。

### 思路：

先来想想如果我们知道要准备多少份奖品，怎么求出花费的最小价钱。

设要准备 $x$ 份奖品，那么对于第 $i$ 个物品，需要的数量应该为 $t=x_i \times x - y_i$，如果 $t \le 0$ 了，那么本身就有这么多份，不需要要花钱了。

否则，我们还需要 $t$ 份第 $i$ 件物品，有两种购买方式，每种方式有无限种，这是不是很熟悉，没错，这个像一个弱化的完全背包，那么我们可以用动态规划来做，定义 $dp_j$ 为花费 $j$ 元能得到的最大物品个数，状态转移方程为：

$$dp_j=\max(dp_{j-b_1}+a_1,dp_{j-b_2}+a_2)$$

我们需要找到一个最小 $j$，使得 $dp_j \ge t$，这个 $j$ 就是我们花的价钱。

最后我们将每一份物品的需要花的最小价钱加在一起，判断是不是大于了 $m$ 就可以了。

现在来确定奖品的份数，因为如果能准备 $k$ 份奖品，那么肯定能准备 $k-1$ 份奖品，所以奖品的份数是符合二分性的，所以我们可以二分奖品的份数。

时间复杂度：$O(n \times m \times \log m)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=505,M=100100;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	int x,y;
	int a1,b1;
	int a2,b2;
}a[N];
int n,m;
int dp[M];
bool check(int x){
	int k=m;
	for (int i=1;i<=n;i++){
		memset(dp,0,sizeof(dp));
		int t=a[i].x*x-a[i].y;
		bool f=0;
		for (int j=0;j<=k;j++){
			if(j>=a[i].b1) 
			  dp[j]=max(dp[j],dp[j-a[i].b1]+a[i].a1);
			if(j>=a[i].b2) 
			  dp[j]=max(dp[j],dp[j-a[i].b2]+a[i].a2);
			if(dp[j]>=t){
				k-=j;
				f=1;
				break;
			}
		}
		if(!f||k<0) 
		  return 0;
	}
	return (k>=0);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i].x=read(),a[i].y=read();
		a[i].a1=read(),a[i].b1=read();
		a[i].a2=read(),a[i].b2=read();
	}
	int l=0,r=m;
	while(l<r){
		int mid=(l+r+1)>>1;
		if(check(mid))
		  l=mid;
		else
		  r=mid-1;
	}
	write(l);
	return 0;
}
```


---

## 作者：信息向阳花木 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5878)


### 二分
二分答案。对于每一次 `check(mid)`，计算买 $mid$ 份这样的奖品最少需要多少钱，最后返回钱数和 $M$ 的大小。

于是，问题转换为：

* 买 $mid$ 份礼品最少需要多少钱？

### 枚举
1. 计算还需买多少份物品 $num$，方法：`m * x - y`。
2. 若 $num<=0$，跳过，否则继续。
3. 枚举大包装买的个数 $i$，和小包装买的个数 $j$。范围：
	$0 \leq i \leq \lceil \frac{num}{sv}\rceil$，$j=\lceil \frac{num-i*sv}{sm}\rceil$。
4. 花的钱：`tmp=min(i*pv+j*pm)`。
5. 拿去跟 $M$ 比较的数 $ans$：`ans+=tmp`。

------------

### Code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,M,ans;
int x[110],y[110],sm[110],pm[110],sv[110],pv[110]; 
bool check(int m){
	ans=0;
	for(int k=1;k<=n;k++){
		int tmp=1000010,r,j,num=x[k]*m-y[k];
		if(num<=0) continue;
		for(int i=0;i<=(num+sv[k]-1)/sv[k];i++){
			r=num-i*sv[k];
		
			if(r<=0) j=0;
			else j=(r+sm[k]-1)/sm[k];
		
			tmp=min(tmp,pm[k]*j+pv[k]*i);
		}
		ans+=tmp;
	}
	return ans<=M;
}

int main(){
	cin>>n>>M;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i]>>sm[i]>>pm[i]>>sv[i]>>pv[i];
	}
	int l,r=M;
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)) l=mid+1;
		else r=mid-1;
	}
	cout<<l-1;
	return 0;
}
```

---

## 作者：Cambridge (赞：2)


蒟蒻又来发题解了！

快速进入话题，这道题我用的方法是二分答案。如果不知道二分答案是什么，我就简单说一下：从答案出发，将可能的答案进行二分查找，将中间值假设为答案并进行验证，根据结果挪动左右指针。那么是什么题可以用二分答案呢？就是当答案有单调性时。说人话就是中间答案范围中某个点前的答案都可以符合题意，后面的答案都不可以符合题意，他自己可不可以要看情况。

普及完二分答案，接下来我开始正式讲这道题目的解法。二分可能的份数，再进行验证，如果当前的份数需要的钱数大于共有的钱，右指针向左挪动，反之，左指针向右挪动。如果看不懂文字解释，看一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstdlib>
#include<algorithm>//文件头不解释 
using namespace std;
long long n,m;
int an;
struct Cambridge
{
	int x,y,sm,pm,sv,pv;	
}a[110];
int one_work(int nd,int j)//分配
{
	int mins=21000000;
	int ans1=0,ans2=0;
	if(nd<=0)return 0;
	for(int i=0; (i-1)*a[j].sm<=nd; i++)
	{
		ans1=nd-i*a[j].sm;
		ans2=i*a[j].pm;
		if(ans1<0)ans1=0;
		else
		{
			ans1=ans1/a[j].sv+(ans1%a[j].sv!=0);
			ans1*=a[j].pv;
		}
		mins=min(mins,ans1+ans2);
	}
	return mins;
}
int er_find_work(int kn)//计算所需要的钱数 
{
	int xy=0,mq=0;
	for(int i=1; i<=n; i++)
	{
		xy=a[i].x*kn-a[i].y;
		mq+=one_work(xy,i);
		if(mq>m)return 0;
	}
	if(mq>m)return 0;
	return 1;
}
void er_find()//二分
{
	int ll=0,rr=m,mid;
	while(ll+1<rr)
	{
		mid=(ll+rr)/2;
		if(er_find_work(mid)==1)ll=mid;
		else rr=mid;
	}
	cout<<ll;
	return ;
}
int main()
{
cin>>n>>m;
for(int i=1; i<=n; i++)//输入 
{
	cin>>a[i].x>>a[i].y>>a[i].sm>>a[i].pm>>a[i].sv>>a[i].pv;
}
er_find();
return 0;
}
```

好了，本蒟蒻就讲到这里，希望对读者有所帮助。

---

## 作者：wsdyz2010 (赞：1)

### 蒟蒻的第一篇题解，若有错误之处，请指出


------------
#### 思路
本题的答案具有单调性，因为若能购买 $x$ 份奖品，那么 $x-1$ 份肯定也能购买；若不能购买 $x$ 份奖品，那么也不能购买 $x+1$ 份奖品。

 有了单调性，很自然就能想到二分(~~本蒟蒻花了半个小时~~)，$mid= \dfrac{l+r}{2}$。若 $mid$ 可行，则 $l=mid+1$，否则 $r=mid-1$。



------------
下面是蒟蒻的二维 DP 代码。
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
int n,m,ans,x[105],y[105],sm[105],pm[105],sv[105],pv[105],f[101][320005];
bool pd(int tot);
signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>x[i]>>y[i]>>sm[i]>>pm[i]>>sv[i]>>pv[i];
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;++i){
		f[i][0]=0;
		for(int j=1;j<=m;++j){
			if(j>=sm[i])f[i][j]=min(f[i][j],f[i][j-sm[i]]+pm[i]);//选择购买小包装 
			if(j>=sv[i])f[i][j]=min(f[i][j],f[i][j-sv[i]]+pv[i]);//选择购买大包装
			if(f[i][j]>m&&f[i][j]!=0x3f3f3f3f)break;
		}
		for(int j=m;j>=1;--j)f[i][j]=min(f[i][j],f[i][j+1]);
	}
	int l=1,r=m,mid;
	while(l<=r){
		mid=(l+r)/2;
		if(pd(mid)){
			l=mid+1;
			ans=max(ans,mid);
		}
		else r=mid-1;
	}
	cout<<ans;
	return 0;
}
bool pd(int tot){
	int tem=0;	
	for(int i=1;i<=n;++i){
		tem+=f[i][max(0,tot*x[i]-y[i])];
		if(tem>m)return 0;
	}
	if(tem<=m)return 1;
	else return 0;
}
```


------------

然而，我在测试后发现了一个问题——这题的空间限制是 125MB......于是，我花了一个小时写的程序成功废了，又花了一个小时写了一个一维的程序。

#### 代码

```cpp
#include<bits/stdc++.h>
#define int long long //别问我为什么开long long,问就是一个悲伤的故事 
#define oo 101
#pragma G++ optimize(1,2,3,"Ofast","inline")
using namespace std;
struct data{
	int x,y,sm,pm,sv,pv;
}a[oo];
int n,m,ans; 
bool pd(int t);
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//cin,cout优化,能加快读入输出速度 
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y>>a[i].sm>>a[i].pm>>a[i].sv>>a[i].pv;
	int l=1,r=m,mid;
	while(l<=r){//二分购买的奖品份数 
		mid=(l+r)/2;
		if(pd(mid)){
			l=mid+1;
			ans=max(ans,mid);//求最大能购买份数 
		}
		else r=mid-1;
	}
	cout<<ans;
	return 0;
}
bool pd(int mid){
	int tot=0;
	int cnt,small,sum,k;
	for(int i=1;i<=n;i++){//枚举每种奖品 
		cnt=1e9;
		sum=a[i].x*mid-a[i].y;//还要购买几份奖品 
		if(sum>0){
			for(int j=0;j<=(sum+a[i].sv-1)/a[i].sv;j++){//枚举大包装的个数 
				small=sum-j*a[i].sv;//求小包装的个数 
				if(small<=0)k=0;//防止乘以负数 
				else k=(small+a[i].sm-1)/a[i].sm;
				if(cnt>a[i].pm*k+a[i].pv*j)
					cnt=a[i].pm*k+a[i].pv*j;//算出当前奖品份数的最小钱数 
			}
			tot+=cnt;
		}
	}
	if(tot<=m)return 1;//若钱数购买t份奖品,返回1,反之亦然 
	else return 0;
}
```


---

## 作者：ILLENIUM_DOOR (赞：1)

### ~~十年OI一场空，不打括号见祖宗~~

这道题之所以和机房的 gzy 大佬调了半个小时，是因为一个括号 QWQ。

回到正题。

首先，题意应该比较容易理解（虽然变量很多）。

然后，对于二分答案单调性的介绍，前面的题解已经有了，还是同校大佬写的，就不多说了。

这篇题解着重讲一下 $check$ 函数的写法。

假设当前枚举的答案为 $k$，当前下标为 $i$。

这里有个特判是原来剩下的是否大于你需要的。如果是，可以直接跳过。

否则，我们假设要买 $sum$ 份东西。

那这里就有一个经典的租车问题了：一共有 $M$ 元，大巴可以坐 $SV$ 个人，需要 $PV$ 元；小巴 $SM$ 人，$PM$ 元。

现在问，有 $sum$ 个人要坐，怎样安排才可以？

在数学上，这个问题很耐人寻味（~~小五数学题~~）。

然而在计算机上，我们只需要枚举坐 $x$ 辆小巴，然后计算需要几辆大巴，最后计算总和就可以了。

那最优解，自然就是总和里的最小值。

于是，$check$ 函数就愉快地写完了。

还有不懂的详见代码及注释。

当然还有一些注意事项：

+ 答案的边界需要仔细斟酌。

+ 用三元运算符记得打括号 QWQ！

附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int N,M;
struct wp{
	int X,Y,SM,PM,SV,PV;
	void print(){
		cin>>X>>Y>>SM>>PM>>SV>>PV;
	}	
}f[110];
int deal(int sum,int xb){
	int mins=2e9;//计算所有方案里钱数的最小值 
	int i=0;//小盒数量 
	int n=sum%f[xb].SM==0?sum/f[xb].SM:(sum/f[xb].SM+1);//打括号！ 
	while(i<=n){
		int temp=0;
		if(sum-f[xb].SM*i>0) temp=sum-f[xb].SM*i;
		int l=temp%f[xb].SV==0?temp/f[xb].SV:(temp/f[xb].SV+1);//打括号！
																//l 为大盒数量 
		mins=min(mins,f[xb].PM*i+f[xb].PV*l);
		i++;
	}
	return mins;
}
bool check(int x){
	int cost=0;
	for(int i=1;i<=N;i++){
		int sum=f[i].X*x-f[i].Y; 
		if(sum) //判断要不要花钱买 
			cost+=deal(sum,i);
	}
	return cost<=M;
}
int find(){
	int lo=0,hi=M;//二分答案（注意边界） 
	while(lo+1<hi){
		int mid=(lo+hi)/2;
		if(check(mid)) lo=mid;
		else hi=mid;
	}
	return lo;
}
int main(){
	cin>>N>>M;
	for(int i=1;i<=N;i++)
		f[i].print();	
	cout<<find();
	return 0;
}
```

---

## 作者：Chouquet (赞：0)

可能有的人对本题的二分+背包的做法不理解（~~也许只有我吧~~），这篇题解会对[syksykCCC的题解](https://www.luogu.com.cn/blog/syksykCCC/solution-p5878)做补充说明。

### 1.为什么用二分

其实这道题正着也是可以求解的，但是由于~~我太弱了~~正着写背包太复杂，而二分又符合正向思考，所以可以用二分。

### 2.为什么可以用二分

本题具有单调性：

**若礼品份数 $=$ i，所花的钱数 $\le$ m。则对于礼品分数 j $\le$ i ,所花的钱数也一定 $\le$ m 。**

### 3.如何二分

记 $l$ 与 $r$表示边界，显然 $l=0$ ，$r$ 为一个很大的数（亲测r=50000时能过）。

每次记 $mid=(l+r)/2$ 。检查 $mid$ 是否可行，如果可以则继续在大的区间找（$r=mid+1$），否则找小的区间 （$l=mid-1$）。

最后答案是 $l$ **或 $l-1$** ，本题答案为 $l-1$。

### 4.如何检查 $mid$ 是否可行

类似背包的思路，具体的代码可以看别人的题解。

**注意：每枚举到一个新的物品时一定要清空！！！**

### 5.部分代码：

```cpp
//二分部分
int l=0,r=50000,mid;
while(l<=r){
    mid=l+r>>1;
    if(check(mid)) l=mid+1;
    else r=mid-1;//这两段应该很好懂吧
}
printf("%d\n",l-1);
//check函数：
bool check(int &mid){
    int money=0;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++) f[j]=0;//注意清空
        bool ok=1;//ok表示是否找到
        for(int j=0;j<=m;j++){
            if(j>=pm[i])//这个判断很重要，不加可能会越界
            	f[j]=max(f[j],f[j-pm[i]]+sm[i]);
            if(j>=pv[i])//这个也是
            	f[j]=max(f[j],f[j-pv[i]]+sv[i]);
            if(f[j]>=x[i]*mid-y[i]){
            //根据题意，买的物品不能低于x[i]*mid-y[i]，取最少的钱，所以只要一找到满足条件的就记录并退出
            	money+=j；
                ok=0;
                break;
            }
        }
        if(ok) return 0;
    }
    return money<=m;
}
```


---


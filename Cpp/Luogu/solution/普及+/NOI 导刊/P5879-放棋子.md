# 放棋子

## 题目描述

小虎刚刚上了幼儿园，老师让他做一个家庭作业：首先画 $3$ 行格子，第一行有三个格子，第二行有 $2$ 个格子，第三行有 $1$ 个格子。每行的格子从左到右可以放棋子，但要求除第一行外，每行放的棋子数不能超过上一行的棋子。第一行的棋子数不能为 $0$，但剩下行可以为空。玩了一会儿，小虎对哥哥大虎说：”这个作业有很多种摆放法，我想找到，但我不知道有多少种方案，你能帮助我吗？”

大虎是学校信息学集训队的，立刻想到用计算机来解决这个问题，并很快有了解答：$13$。

第二天他把问题拿到学校，并说如果第一行有 $N$ 个格子，第二行有 $N-1$ 个格子，……，第 $N$ 行有 $1$ 个格子，怎么办？现在请你一块来帮助他解决这个难题。

## 说明/提示

样例 1 说明：$N=2$ 时，有如下 $4$ 种摆放棋子法（`*` 表示棋子，`_` 表示空格）：
|  方案数| 1 | 2 | 3 | 4 |
| :----------- | :----------- | :----------- | :----------- | :----------- |
| **第一行** | `*_` | `**` | `*_` | `**` |
| **第二行** | `_` | `_` | `*` | `*` |


对于 $30\%$ 数据：$1\le N\le 12$。

对于 $50\%$ 数据：$1\le N\le 30$。

对于 $100\%$ 数据：$1\le N\le 100$。


## 样例 #1

### 输入

```
2```

### 输出

```
4```

## 样例 #2

### 输入

```
3```

### 输出

```
13```

# 题解

## 作者：Blunt_Feeling (赞：12)

## P5879 放棋子 题解

这道题的状态转移方程有点难推。首先看一张状态表：

|  | 4 | 3 | 2 | 1 | 0 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **4** | 14 | 14 | 9 | 4 | _1_ |
| **3** |  | 5 | 5 | 3 | _1_ |
| **2** |  |  | 2 | 2 | _1_ |
| **1** |  |  |  | 1 | _1_ |

### 1. 这张表表示什么？

在这个表中，行数 $i$ 从下往上递增，列数 $j$ 从右往左递增，$f_{i,j}$ 表示在第 $i$ 行摆 $j$ 个棋子时的方案数，且想求摆 $i$ 行的方案数，只要算出 $f_{i,1}+f_{i,2}+f_{i,3}+…+f_{i,i}$ 即可。

------------

### 2. 怎么推？

首先，对于所有 $i$，$f_{i,0}$ 都为 $1$，因为什么都不放也是一种放法；还要把 $f_{1,1}$ 设为 $1$。——以上为初始化。接下来：

**第二行**
1. 在第二行放一个的时候，第一行可以放一个也可以不放，有 $2$ 种放法，于是 $f_{2,1}=2$；
2. 在第二行放两个的时候，第一行可以放一个也可以不放，有 $2$ 种放法，于是 $f_{2,2}=2$。

**第三行**
1. 在第三行放一个的时候，第二行可以放一个也可以不放，有 $f_{2,1}+f_{2,0}=3$ 种放法，于是 $f_{3,1}=3$；
2. 在第三行放两个的时候，第二行可以放两个、一个也可以不放，有 $f_{2,2}+f_{2,1}+f_{2,0}=5$ 种放法，于是 $f_{3,2}=5$；**但是在这里**，$f_{2,1}+f_{2,0}$ 刚好是 $f_{3,1}$，所以 $f_{3,2}=f_{2,2}+f_{3,1}=5$；
3. 在第三行放三个的时候，第二行可以放两个、一个也可以不放，所以 $f_{3,3}=f_{3,2}=5$。

**第四行**
1. 在第四行放一个的时候，第三行可以放一个也可以不放，有 $f_{3,1}+f_{3,0}=4$ 种放法，于是 $f_{4,1}=4$；
2. 在第四行放两个的时候，第三行可以放两个、一个也可以不放，有 $f_{3,2}+f_{3,1}+f_{3,0}=9$ 种放法，于是 $f_{4,2}=9$；**但是在这里**，$f_{3,1}+f_{3,0}$ 刚好是 $f_{4,1}$，所以 $f_{4,2}=f_{3,2}+f_{4,1}=9$；
3. 在第四行放三个的时候，第三行可以放三个、两个、一个也可以不放，有 $f_{3,3}+f_{3,2}+f_{3,1}+f_{3,0}=14$ 种放法，于是 $f_{4,3}=14$；**但是在这里**，$f_{3,2}+f_{3,1}+f_{3,0}$ 刚好是 $f_{4,2}$，所以 $f_{4,3}=f_{3,3}+f_{4,2}=14$；
4. 在第四行放四个的时候，第三行可以放三个、两个、一个也可以不放，所以 $f_{4,4}=f_{4,3}=14$。

如果你耐心地看到这里，那么恭喜你，此题的状态转移方程已经一目了然了：

$$ f_{i,j} = f_{i-1,j} + f_{i,j-1} $$

------------

### 3. 高精度
此题输出的结果非常大，当 $n=100$ 时，输出的答案居然有 $58$ 位之长。你可以乖乖写高精，也可以像我一样，把一个数用两个`__int128`压位存储，偷个懒。

------------

### 4. Code
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
const int maxn=110;
inline void write(__int128 x) { //用来输出__int128
    if(x<0) { putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int n;
__int128 M=1,f[maxn][maxn][2],ans[2]; //把一个数用两个__int128压位存储
int main()
{
	cin>>n;
	For(i,1,n) f[i][0][0]=1;
	For(i,1,30) M*=10; //构造一个30位的取模数，方便压位
	For(i,1,n)
		For(j,1,i)
		{
			f[i][j][0]=(f[i][j-1][0]+f[i-1][j][0])%M; //压位，状方在前文已经讲过了
			f[i][j][1]=f[i][j-1][1]+f[i-1][j][1]+(f[i][j-1][0]+f[i-1][j][0])/M;
		}
	For(i,1,n) ans[0]+=f[n][i][0];
	ans[1]=ans[0]/M; //处理进位（很容易写错）
	ans[0]%=M;
	For(i,1,n) ans[1]+=f[n][i][1];
	if(ans[1]!=0)
	{
		write(ans[1]);
		if(ans[0]<=M/10) cout<<0; //用一个比较讨巧的方法处理首位是0的情况
	}
	write(ans[0]);
	cout<<endl; //可省
	return 0;
}
```

------------

### 5. 后话
- 关于`__int128`的使用，可以参考我的[这篇文章](http://luogu.com.cn/blog/219866/guan-yu-int128-de-shi-yong)。
- 十分感谢 @[No_Rain](https://www.luogu.com.cn/user/235855) 对本篇题解的帮助！
- 因为`__int128`在正式比赛中不能使用，所以你可以先用`__int128`打表，再把打表程序交上去。限于篇幅，**想看打表程序请阅读[这篇文章](https://www.luogu.com.cn/blog/219866/p5879-fang-qi-zi-da-biao-fang-fa)**。

---

## 作者：syksykCCC (赞：7)

使用 **记忆化搜索** 求解，定义一个状态 $f_{k, maxx}$，表示当前搜到了第 $k$ 行，该行最多可以放 $maxx$ 个棋子的方案数。显然，如果 $N = 1$，答案为 $1$；否则，这题的答案就是：

$$ \left(\sum_{i = 1}^{N - 1} f_{2, i}\right) + f_{2, N - 1}$$

前一项对应第一行放 $1 \sim N-1$ 个棋子的答案，后一项对应第一行放 $N$ 个棋子的答案（因为第二行总共只有 $N - 1$ 个格子）。

如果 $k = N$，则 $f_{N, maxx}$ 的值显然为 $maxx + 1$，即：

* $maxx = 0$ 时只有「不放」一种方案
* $maxx = 1$ 时有「不放」和「放一个」两种方案

否则就枚举该行方几个就行了，注意 `long long` $50$ pts，`__int128` $70$ pts，**高精** 才能 $100$ pts。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct bigint
{
	int len, num[1000];
	bigint() { len = 0; memset(num, 0, sizeof num); }
	bigint operator + (const bigint &oth) const
	{
		bigint res;
		int p = 0;
		res.len = max(len, oth.len);
		for(int i = 1; i <= res.len; i++)
		{
			res.num[i] = p + num[i] + oth.num[i];
			p = res.num[i] / 10;
			res.num[i] %= 10;
		}
		if(p) res.num[++res.len] = p;
		return res;
	}
	friend ostream &operator << (ostream &out, bigint &oth)
	{
		for(int i = oth.len; i; i--) out << oth.num[i];
		return out;
	}
};
bigint one, two;
bigint ans, f[105][105];
int n;
bigint dfs(int k, int maxx)
{
	if(k == n) return maxx == 0 ? one : two;
	if(f[k][maxx].len) return f[k][maxx];
	for(int i = 0; i <= maxx; i++) f[k][maxx] = f[k][maxx] + dfs(k + 1, min(n - k, i));
	return f[k][maxx];
}
int main()
{
	one.len = 1; two.len = 1; // 偷懒没写赋值函数，以适应 int => bigint 的转化
	one.num[1] = 1; two.num[1] = 2;
	cin >> n;
	if(n == 1) return puts("1") && 0;
	for(int i = 1; i <= n; i++) ans = ans + dfs(2, min(n - 1, i));
	cout << ans << endl;
	return 0;
}
```

---

## 作者：林聪 (赞：4)

本题的题意很好理解，这里不再赘述。

当我看到此题是让我求方案总数时，我的第一反应是观察找规律，看看能不能推导出递推公式。

首先观察一下N=0、1、2、3时的方案总数，分别为0、1、4、13。

一时半会确实没看出什么规律。

不过在我计算的过程中，我注意到题目中特意强调了第一行不能为空，因此少计算了一种每行均为0的情况，而如果我们补上这种情况，会发现方案总数变为了1、2、5、14。

如果你对卡特兰数比较熟悉的话，你会迅速地反应出来，这玩意...不就是**卡特兰数**么？（不知道卡特兰数的可以[百度一下](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin)）

接着，我写了个暴力，证明了我的想法是正确的。

正当我为此沾沾自喜时，我发现数据范围虽然不大，但是由于卡特兰数的递增速度是相当快的，因此用long long绝对是存不下的。

然而我上上下下翻看了几遍，都没找到想象中的模数，这意味着...要写高精！

由于我很懒，不想写高精，于是写一篇python代码好了（~~于是本题最短代码诞生~~）：

```python
n=int(input())+1
c=[[0 for i in range(205)]for i in range(205)]
#开一个二维数组c[205][205]
c[1][1]=1
for i in range(2,2*n+2):
    for j in range(1,i+1):
        c[i][j]=c[i-1][j]+c[i-1][j-1]
print(c[2*n+1][n+1]-c[2*n+1][n]-1)
```

这里用的是卡特兰数的组合数公式计算的：$f_n$ = $C^n_{2n}$ + $C^{n-1}_{2n}$。

由于担心越界问题，我将数组全部向右向下偏移了一格，也就是说，代码中的
```python
c[m+1][n+1]
```
才代表组合数$C^n_m$。

最后，别忘记还要-1就好了（一开始加了1种情况才变成卡特兰数的）！

---

## 作者：Genius_Star (赞：2)

### 题意：

打模拟赛过来的……

第 $1$ 行有 $n$ 个格子，第 $2$ 行有 $n-1$ 个格子，以此类推，在第 $n$ 行，只有一个格子。

对于每行棋子，我们可以从左到右依次放置棋子，除去第 $1$ 行，第 $i$ 行的棋子数量不能大于上一行的棋子数量。

求放置棋子的方案数。

### 思路：

~~感觉思路挺简单的，不知道为什么是个绿题……~~

首先暴力是不可能的，复杂度 $O(N!)$。

看数据范围 $O(n^3)$ 可过，所以考虑动态规划，定义 $dp_{i,j}$ 表示在第 $i$ 行放置 $j$ 个棋子的方案数，显然我们的初始状态是 $dp_{1,i}=1$，答案就是 $dp_{n,0}+dp_{n,1}$（因为最后一行只有一个格子，要么放，要么不放）。

现在想想怎么推状态转移方程，如果当前在第 $i$ 行放置 $j$ 个棋子的话，那么上一行需要的棋子数量肯定是 $\ge j$ 的，即上一行可得的棋子数量在 $j \sim n-i+2$ 之间。

所以得到状态转移方程：

$$dp_{i,j}=\sum\limits_{k=i}^{k \le n - i + 2}dp_{i-1,k}$$

这个状态因为当前行的状态只和上一行的状态有关，那么可以滚一下第一维。

然后你会发现这会爆 ``long long``，写一个高精度差不多了。

**注意滚的时候要清空一下。**

**算出答案之后，你会发现，答案是卡特兰数 $-1$，因为空的不算。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,sum=0;
class A{
    public:
        short v[N];
        int size;
        A(){
            memset(this->v,0,sizeof(this->v));
        }
        friend ostream& operator<<(std::ostream &os,A x){
            for(register int i=x.size-1;i>=0;i--)
			  os<<x.v[i];
            return os;
        }
        void operator=(A b){
            for(register int i=0;i<b.size;i++)
			  this->v[i]=b.v[i];
			for(register int i=b.size;i<this->size;i++)
			  this->v[i]=0;
            this->size=b.size;
        }
        A operator+(A b){
            A t=b;
            short w=0;
            for(register int i=0;i<=max(this->size,t.size)+1;i++){
                t.v[i]=this->v[i]+b.v[i]+w;
                w=t.v[i]/10;
                t.v[i]%=10;
            }
            t.size=max(this->size,t.size)+1;
            while(t.v[t.size-1]==0&&t.size>1)
			  t.size--;
            return t;
        }
}dp[2][N];
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		dp[1][i].v[0]=1;
		dp[1][i].size=1;
	}
	for(int i=2;i<=n;i++){
		for(int j=0;j<=(n-i+1);j++){
			memset(dp[i&1][j].v,0,sizeof(dp[i&1][j].v));
			dp[i&1][j].size=0;
			for(int k=j;k<=(n-i+2);k++)
			  dp[i&1][j]=dp[i&1][j]+dp[i&1^1][k];
		}
	}
	cout<<(dp[n&1][0]+dp[n&1][1])<<'\n';
	return 0;
}
```


---

## 作者：linxuanrui (赞：2)

### 思路

一道 DP 题，但是我的状态转移方程似乎和别人不一样。

令 $dp_{i,j}$ 为第 $i$ 行放了 $j$ 枚棋子的方案数。因为题目要求每一行摆的棋子一定要比上一行多，因此状态转移方程就是 $dp_{i,j}=\sum\limits_{k=0}^{j-1}dp_{i-1,k}$。

边界条件：当 $1\le i\le n$ 时，$dp_{1,i}=0$。

最后的结果是 $dp_{n,0}+dp_{n,1}$，因为最后一行可以摆一个或不摆棋子。

注意，这题没有说要取模，得用高精度。

### 代码

```cpp
#include<bits/stdc++.h>
#define endl '\n'
typedef long long ll;
using namespace std;
const int N = 105;
int n;
struct Int{int a[1005];Int(){memset(a,0,sizeof(a));}}dp[N][N];
Int operator +(Int a,Int b){
	Int c;c.a[0] = max(a.a[0],b.a[0]) + 1;
	int jw = 0;
	for(int i = 1;i <= c.a[0];i++){
		c.a[i] = (a.a[i] + b.a[i] + jw) % 10;
		jw = (a.a[i] + b.a[i] + jw) / 10;
	}
	while(!c.a[c.a[0]] && c.a[0] > 1)c.a[0]--;
	return c;
}
signed main(){
	cin >> n;
	for(int i = 1;i <= n;i++)dp[1][i].a[0] = 1,dp[1][i].a[1] = 1;; 
	for(int i = 2;i <= n;i++){
		for(int j = 0;j <= n + 1 - i;j++){
			for(int k = j;k <= n + 2 - i;k++)dp[i][j] = dp[i][j] + dp[i - 1][k];
		}
	}
	Int ans = dp[n][0] + dp[n][1];
	for(int i = ans.a[0];i >= 1;i--)cout << ans.a[i];
}
```

---

## 作者：npucfy (赞：2)

首先看题目感觉可以试试推出递推的式子，那么我们定义
$f\left[n\right]\left[k\right]$为第$n$行放$k$个棋子的方法总数(从下往上放棋子)，那么方法总数为：
$$\sum_{i=1}^n{f\left[n\right]\left[i\right]}$$
接下来我们推一下$f\left[n\right]\left[i\right]$和
$f\left[n-1\right]\left[i\right]$的关系，可以看出：
$$f\left[n\right]\left[1\right]=f\left[n-1\right]\left[1\right]+1$$
$$f\left[n\right]\left[2\right]=f\left[n-1\right]\left[1\right]+f\left[n-1\right]\left[2\right]+1$$ 
$$f\left[n\right]\left[n\right]=f\left[n-1\right]\left[1\right]+f\left[n-1\right]\left[2\right]+\cdots+f\left[n-1\right]\left[n-1\right]+1$$
其中$1$代表$n-1$行放$0$个棋子，并且$f\left[n\right]\left[i\right]$用到了$f\left[n\right]\left[i-1\right]$的结果，我们总结一下，可以得到如下递推式：
$$\left\{ \begin{array}{l}
f[i][0] = 1\\
f[n][k] = f[n][k - 1] + f[n - 1][k]
\end{array} \right.$$
注意用高精就行了。
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,a[500],b[500],res[500];
string f[105][105],ans;

string add(string s1,string s2) {
    int l1=s1.size(),l2=s2.size(),i=0,cnt=0,c=0;
    string tmp="";
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(res,0,sizeof(res));
    for(i=0;i<l1;i++) a[l1-1-i]=s1[i]-48;
    for(i=0;i<l2;i++) b[l2-1-i]=s2[i]-48;
    i=0;
    while (i<l1 || i<l2) {
        res[cnt]=a[i]+b[i]+c;
        c=res[cnt]/10;
        res[cnt]%=10;
        cnt++;
        i++;
    }
    if (c) res[cnt]=c;
    else cnt--;
    for(i=cnt;i>=0;i--) tmp+=to_string(res[i]);
    return tmp;
}

int main() {
    cin>>n;
    for(int i=1;i<=n;i++) f[i][0]="1";
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=i;j++) {
            f[i][j]=add(f[i][j-1],f[i-1][j]);
        }
    }
    for(int i=1;i<=n;i++) ans=add(ans,f[n][i]);
    cout<<ans;
    return 0;
}

```



---

## 作者：liangbob (赞：1)

### P5879 题解

简单的 DP 题目。

DP 的话，首先你要弄明白怎么转移。

当时我是在某场模拟赛看到了这道题，我就去枚举了一下当 $n$ 为 $3$ 时的所有情况。

这里明确一下，第 $x$ 行代表有 $x$ 个格子的那一行。

我们是怎么枚举的呢？小学的时候老师告诉过我们，枚举要有序。放到这题来讲，我们先枚举第三行放三个，再枚举第三行放二个，最后再枚举第三行放一个和不放。如果第三行放三个，那么还要继续枚举第二行放二个、一个和不放。

一般化地来讲，当我们枚举第 $i$ 行放 $j$ 个时，我们就要枚举第 $i-1$ 行放 $0$ 到 $j$ 的情况。当然，有时候由于第 $i-1$ 行只有 $i - 1$ 个格子，所以事实上放不到 $j$ 个。也就是说，实际上要枚举的是 $i-1$ 行放 $0$ 到 $\min(i - 1,j)$ 的情况。

于是递推式先出来了：

$$f(i,j)=f(i-1,0)+f(i-1,1)+f(i-1,2)+\ldots+f(i-1,k)$$

其中 $k = \min(i - 1,j)$。

此时还要注意，当我们枚举到最后一个的时候，也就是第 $1$ 格的时候，只有两种情况：放一个和不放，这个时候不用枚举，直接就是一种情况，即 $f(1,1)=f(1,0)=1$。

直接按式子推就可以了。

最后的答案是 $f(n,0)+f(n,1)+\ldots+f(n,n)$。

代码如下：

```cpp
int n;
cin >> n;
f[1][1] = f[1][0] = 1;
for(int i = 2;i <= n;i++)
{
    for(int j = 0;j <= i;j++)
    {
        for(int k = 0;k <= min(j, i - 1);k++)
        {
            f[i][j] += f[i - 1][k];
        }
    }
}
int sum = 0;
for(int i = 0;i <= n;i++)
{
    sum += f[n][i];
}
cout << sum - 1 << endl;
```

但是需要注意，这题高精度。

由于我不想写高精度，于是写了一个打表的 Python 程序，如下：

```python
for n in range(1,101):
    f=[]
    for i in range(0,211):
        q=[]
        for j in range(0,211):
            q.append(0)
        f.append(q)
    f[1][1] = f[1][0] = 1
    for i in range(2, n + 1):
        for j in range(i + 1):
            for k in range(min(j, i-1)+1):
                    f[i][j] += f[i - 1][k]
    sum = 0
    for i in range(n + 1):
        sum += f[n][i]
    print('"'+str(sum - 1)+'",',end='')
```

这个本质上就是计算 $1$ 到 $100$ 的答案，由于 Python 自带高精度，所以该程序可以得到正确的答案。

然后把这个打出来的表写进去就可以了。

```cpp
#include <iostream>
#include <string>
using namespace std;
const int N = 2e2 + 10;

string t[N] = /*表见https://www.luogu.com.cn/paste/4u4gehh1*/;

int main()
{
    int n;
    cin >> n;
    cout << t[n] << endl;
    return 0;
}
```





---

## 作者：lizhous (赞：1)

**怎么又是魔怔高精！！！！！！**

~~难怪是绿题。~~
# 分析
计数题+数据范围小，显然可以动规。

设 $f_{i,j}$ 表示第 $i$ 行放 $j$ 个棋子的方案数，$num_i$ 表示第 $i$ 行最多放的棋子数。根据题意，$num_i=n-i+1$。因为每行放的棋子数不能超过上一行的棋子，所以可以枚举上一行的棋子数 $k(j \le k \le num_{i-1})$，则有转移方程 $f_{i,j}=\sum\limits^{num_i}_{k=j}f_{i-1,k}$。边界为 $f_{1,j}=1$，答案为 $f_{n,0}+f_{n,1}$ (最后一行可以放一个也可以不放)。

$O(n^3)$ 可过，轻松获得五十分！

尝试极限数据 $n=100$，发现精度爆了，加个高精就可以了。~~然后写挂了。~~

# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#define int long long
using namespace std;
int a[100], b[100], res[100];
string add(string s1, string s2) {//高精加
	int n = s1.length(), m = s2.length(); //记录长度
	for (int i = 0; i < n; i++)a[i] = s1[n - 1 - i] - '0'; //转换为数组
	for (int i = 0; i < m; i++)b[i] = s2[m - 1 - i] - '0';
	int len = max(n, m) + 1;
	for (int i = n; i < len; i++)a[i] = 0; //初始化
	for (int i = m; i < len; i++)b[i] = 0;
	for (int i = 0; i < len; i++)res[i] = 0;
	for (int i = 0; i < len; i++) {
		res[i] += a[i] + b[i]; //加
		if (res[i] >= 10) { //进位
			res[i + 1] += res[i] / 10;
			res[i] %= 10;
		}
	}
	int i = len - 1;
	while (res[i] == 0 && i > 0)i--;
	string s = "";
	for (; i >= 0; i--)s += (char)(res[i] + '0'); //转换字符串
	return s;
}
int n;
string f[101][101]/*第i行选j个棋子的方案数*/;
signed main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++) {
		f[1][i] = "1";
	}
	for (int i = 2; i <= n; i++) { //枚举行
		for (int z = 0; z <= n - i + 1; z++) { //枚举此行棋子数
			for (int k = z; k <= n - i + 2; k++) { //枚举上行棋子数
				f[i][z] = add(f[i][z], f[i - 1][k]);
			}
		}
	}
	cout << add(f[n][0], f[n][1]); //输出最后一行的结果
}
```


---

## 作者：编程客 (赞：1)

## 本题解做法： 记忆化搜索
- 步骤大致有两步，分别是搜索和高精度。
- 有些题解是用动态规划做的，但自认为记忆化搜索会更加简单易懂。
### 记忆化搜索
#### 搜索：
- 定义函数 `dfs(int x,int d)` 。 `x` 表示上一行内放的棋子个数（即规定此行棋子个数的上限），d表示当前的层次（规定边界和棋子上限）。
- `dfs` 内循环如果`d==n`，则从1开始，否则从0开始。循环到`min(x,d)`结束。
- 定义一个计数变量`sum`，每次计算`sum+dfs(i,d-1)`的值，存储下来。
- 最后函数返回值即为`sum`。
#### 记忆化：
- 因为要用记忆化搜索，所以事先定义一个数组`f[i][j]`，表示当 x=i，d=j 时函数返回值。
- 在`dfs`函数内定义： 如果`f[x][d]!=0`就返回`f[x][d]`，否则就接着往下搜索。
- 可以在最后把`sum`的值赋值给`f[x][d]`，也可以一开始就把`f[x][d]`当做sum用。
### 高精度
- 本题只需要用到高精度加法，相信各位都会。个人建议最好压位，进行各种操作都会比用字符串好的多。
## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int N=4,M=10000;
struct high
{
	int len,flag;
	int num[205];
	high()			// 初始化 
	{
		flag=1;
		len=1;
		memset(num,0,sizeof(num));
	}
	void out()		// 输出 
	{
		if(flag!=1&&(!(len==1&&num[1]==0))) printf("-");
		printf("%d",num[len]);
		for(int i=len-1;i>=1;i--)
		{
			if(num[i]==0) printf("0000");
			else
			{
				for(int j=10;j*num[i]<M;j*=10) printf("0");
				printf("%d",num[i]);
			} 
		}
		printf("\n");
	}
}; 
bool operator >=(high a,high b)			//高精度 比较大小 
{
	if(a.len>b.len) return 1;
	if(a.len<b.len) return 0;
	for(int i=a.len;i>=1;i--)
	{
		if(a.num[i]>b.num[i]) return 1;
		if(a.num[i]<b.num[i]) return 0;
	}
	return 1;
}
high operator +(high a,high b)			// 高精度加法 
{
	high ans;
	if(!(a>=b))
	{
		return (b+a);
	}
	ans.len=a.len;
	for(int i=1;i<=ans.len;i++)
	{
		ans.num[i]+=a.num[i]+b.num[i];
		ans.num[i+1]=ans.num[i]/M;
		ans.num[i]%=M;
	}
	if(ans.num[ans.len+1]!=0) ans.len++;
	return ans;
}
int n;
high f[105][105];
high dfs(int x,int d)					// 递归 
{
	high ls;
	ls.num[1]=1;
	if(d==0) return ls;
	if((f[x][d].len!=1||f[x][d].num[1]!=0)) return f[x][d];		// 记忆化 
	int st=0;
	if(d==n) st=1;
	for(int i=st;i<=min(x,d);i++)								// 搜索 
	{
		f[x][d]=(f[x][d]+dfs(i,d-1));
	}
	return f[x][d];												// 返回 
}
int main()
{
	scanf("%d",&n);						// 读入 
	high ans=dfs(n,n);					// 搜索获取答案 
	ans.out();							// 输出 
	return 0;
}
```

---

## 作者：copper_ingot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5879)

明显 DP。先推个公式。

令 $f_{i,j}$ 为第 $i$ 行放 $j$ 个棋子的方法数量。

首先我们数数 $f_{4,2}$ 是多少（以下数字表示每行放的棋子的数量）：

$$2\ 2\ 2\ 1,2\ 2\ 2\ 0,2\ 2\ 1\ 1,2\ 2\ 1\ 0,2\ 2\ 0\ 0,2\ 1\ 1\ 1,2\ 1\ 1\ 0,2\ 1\ 0\ 0,2\ 0\ 0\ 0$$

有 $9$ 种。

然后数数 $f_{3, 2}$：

$$2\ 2\ 1,2\ 2\ 0,2\ 1\ 1,2\ 1\ 0,2\ 0\ 0$$

有 $5$ 种。

而 $f_{4, 1}$：

$$1\ 1\ 1\ 1,1\ 1\ 1\ 0,1\ 1\ 0\ 0,1\ 0\ 0\ 0$$

只有 $4$ 种。

我们发现：$f_{4,2}$ 的前面 $4$ 个都是 $f_{3,2}$ 对应的数列前面加个 $2$，后 $5$ 个都是 $f_{4,1}$ 对应的数列的第一个数加上 $1$ 后的结果。

因为当第 $4$ 位是 $2$ 时，第三位可能是 $2$、$1$ 或者 $0$，也就是说

$$f_{4,2} = f_{3,0} + f_{3,1} + f_{3,2}$$

然后 $f_{4,1}$ 里面各数列去掉开头的 $1$ 之后正好就是 $f_{3,0}$ 和 $f_{3,1}$。

所以猜想递推公式：$f_{i,j} = f_{i - 1,j} + f_{i,j - 1}$。

又多算了几组数验证，都可以这么推出来。

第二步，初始化。

这步比较好理解，把 $f_{1,0}$ 和 $f_{1,1}$ 都设为 $1$ 就可以了。

（注：根据题意 $f_{1,0}$ 应当设为 $0$ 但是为了方便设为 $1$）

最后把所有 $f_{n,j}$ 加起来之后减 $1$ （排除全 $0$ 的方案）就是答案。

这题最后答案可能会很大，因为本人不会 Python，所以只能悲催地写高精力（

最后减 $1$ 给我调了好久 QAQ

代码贴上

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, f[101][101][101], ans[101];
int main(){
	cin >> n;
	f[1][0][1] = f[1][1][1] = 1;
	for (int i = 2; i <= n; i++)
		for (int j = 0; j <= i; j++){
			for (int k = 1; k <= 99; k++){
				f[i][j][k] += f[i - 1][j][k];
				f[i][j][k + 1] += f[i][j][k] / 10;
				f[i][j][k] %= 10;
			}
			for (int k = 1; k <= 99; k++){
				f[i][j][k] += f[i][j - 1][k];
				f[i][j][k + 1] += f[i][j][k] / 10;
				f[i][j][k] %= 10;
			}
		}
   //处理、递推
	for (int i = 0; i <= n; i++)
		for (int j = 1; j <= 100; j++){
			ans[j] += f[n][i][j];
			ans[j + 1] += ans[j] / 10;
			ans[j] %= 10;
		}//加和
	int x = 1;
	while (ans[x] == 0) ans[x] = 9, x++;
	ans[x]--;//减1（悲
	int flag = 0;
	for (int i = 100; i >= 1; i--){
		if (ans[i]){cout << ans[i]; flag = 1;}
		else if (!ans[i] && flag) cout << 0; 
	}//输出
	return 0;
}

```

---


# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# 题解

## 作者：Jack_Homes_Huang (赞：725)

## 题目大意
> 有一个$n \times m$的矩阵，对于第$i$行，每次**取走**边缘的值$A_{i,j}$，增加这一行的得分$x$~~(自行看题目规则)~~，求$n$行的最大得分总和。

## 分析一下
- 求$n$行最大得分和，每一行取数又不会影响到其他行，那么只要确保每一行得分最大，管好自家孩子就行了。（这个在动规中叫**最优子结构**）
- 每次取数是在边缘取，那么每次取数完剩下来的元素一定是在一个完整的一个区间中，又是求最优解，**区间DP**应运而生。

## DP流程
(每次DP仅针对第$T$行)
### 状态
- 我们用$f_{i,j}$表示区间**变为**$[i,j]$时，获得的最大分数。

### 转移
- 当区间变为$[i,j]$时，上一次取数的时候区间一定是$[i-1,j]$或$[i,j+1]$，从这两个状态转移即可。在第$m-j+i-1$次(这个请自行模拟)取走了$A_{i-1,j}$或$A_{i,j+1}$即：$$f_{i,j}=max\{f_{i-1,j}+A_{i-1,j} \cdot 2^{m-j+i-1},f_{i,j+1}+A_{i,j+1} \cdot 2^{m-j+i-1}\}$$

### 终值（答案）
- 啊这个终值超级讨厌，状态不明确的话还真想不出来。
- 因为题目中说要取完，但是空区间是DP不出来的，然后就得手动模拟每个长度为$1$的区间。即：
$$Ans=max_{i \leq m}\{f_{i,i}+A_{i,i} \cdot 2^m\}$$
-----
## 一些~~(超级烦的)~~事情
- 我就不说为什么要用**高精度**了$\cdots$
- 啊高精度好烦的$\cdots$
- 烦归烦我又有什么办法呢，我又不会$int128 \cdots$

#### 总结一下要用的所有高精度
1. 高精$+$高精

2. 高精$\times$单精

3. $max\{$高精$,$高精$\}$(手动调皮)

#### 好了我不管你们想粘板子就粘板子吧$\cdots$
*****
## 代码君
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

const int MAXN = 85, Mod = 10000; //高精四位压缩大法好 
int n, m;
int ar[MAXN];

struct HP {
	int p[505], len;
	HP() {
		memset(p, 0, sizeof p);
		len = 0;
	} //这是构造函数，用于直接创建一个高精度变量 
	void print() {
		printf("%d", p[len]);  
        for (int i = len - 1; i > 0; i--) {  
            if (p[i] == 0) {
				printf("0000"); 
				continue;
			}
            for (int k = 10; k * p[i] < Mod; k *= 10) 
				printf("0");
            printf("%d", p[i]);
        }
	} //四位压缩的输出 
} f[MAXN][MAXN], base[MAXN], ans;

HP operator + (const HP &a, const HP &b) {
	HP c; c.len = max(a.len, b.len); int x = 0;
	for (int i = 1; i <= c.len; i++) {
		c.p[i] = a.p[i] + b.p[i] + x;
		x = c.p[i] / Mod;
		c.p[i] %= Mod;
	}
	if (x > 0)
		c.p[++c.len] = x;
	return c;
} //高精+高精 

HP operator * (const HP &a, const int &b) {
	HP c; c.len = a.len; int x = 0;
	for (int i = 1; i <= c.len; i++) {
		c.p[i] = a.p[i] * b + x;
		x = c.p[i] / Mod;
		c.p[i] %= Mod;
	}
	while (x > 0)
		c.p[++c.len] = x % Mod, x /= Mod;
	return c;
} //高精*单精 

HP max(const HP &a, const HP &b) {
	if (a.len > b.len)
		return a;
	else if (a.len < b.len)
		return b;
	for (int i = a.len; i > 0; i--)
		if (a.p[i] > b.p[i])
			return a;
		else if (a.p[i] < b.p[i])
			return b;
	return a;
} //比较取最大值 

void BaseTwo() {
	base[0].p[1] = 1, base[0].len = 1;
	for (int i = 1; i <= m + 2; i++){ //这里是m! m! m! 我TM写成n调了n年... 
		base[i] = base[i - 1] * 2;
	}
} //预处理出2的幂 

int main(void) {
	scanf("%d%d", &n, &m);
	BaseTwo();
	while (n--) {
		memset(f, 0, sizeof f);
		for (int i = 1; i <= m; i++)
			scanf("%d", &ar[i]);
		for (int i = 1; i <= m; i++)
			for (int j = m; j >= i; j--) { //因为终值是小区间，DP自然就从大区间开始 
				f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
				f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
			} //用结构体重载运算符写起来比较自然 
		HP Max;
		for (int i = 1; i <= m; i++)
			Max = max(Max, f[i][i] + base[m] * ar[i]);
		ans = ans + Max; //记录到总答案中 
	}
	ans.print(); //输出 
	return 0;
}
```

---

## 作者：zhylj (赞：168)

我的转移方程似乎和楼下的都不太一样

首先，可以发现每行怎么取并不会有什么影响，只要算出这些然后加起来就可以了。

然后对于每行，有$f[i][j]$代表取区间$[i,j]$的最大值

然后转移方程我们考虑，对于每一个新的$f[i][j]$，有两种情况（下面定义$a[i]$代表该行的每个数）：

先取前面的（$a[i]$），再取剩下的$f[i+1][j]$即$[i+1,j]$的最大值：$2f[i+1][j]+2a[i]$即把接下来取的所有数乘上2，也就是把接下来取的所有数从$x2^{i}$变为$x2^{i+1}$即每次取都把之前的翻一倍，然后当前取的值$a[i]$要乘上$2^1$即$2$

先取后面的（$a[j]$），再取剩下的$f[i][j-1]$即$[i,j-1]$的最大值：$2f[i][j-1]+2a[j]$同理

故转移方程为$$f[i][j]=max(2f[i+1][j]+2a[i],2f[i][j-1]+2a[j])$$

所以程序就很好写了

主要部分如下
```cpp
int n, m;
__int128 game[MAXN][MAXN];

__int128 f[MAXN][MAXN];
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
    	for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}
```

注意用int128或高精，不然会爆longlong

AC程序（0ms/2.13MB），应该是比较快的了：
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN=81;

inline void input(__int128 &s)
{
    s=0;
    char c=' ';
    while(c>'9'||c<'0') c=getchar();
    while(c>='0'&&c<='9')
    {
        s=s*10+c-'0';
        c=getchar();
    }
}

inline void output(__int128 x)
{
    if(x>9)
        output(x/10);
    putchar(x%10+'0');
}

int n, m;
__int128 game[MAXN][MAXN];

__int128 f[MAXN][MAXN];
__int128 solve(__int128 a[])
{
    memset(f,0,sizeof(f));
    for(int len=0;len<=m;++len)
    	for(int i=1;i+len<=m;++i)
            f[i][i+len]=max(2*f[i+1][i+len]+2*a[i],2*f[i][i+len-1]+2*a[i+len]);
    return f[1][m];
}

__int128 ans=0;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            input(game[i][j]);
    for(int i=1;i<=n;i++)
        ans+=solve(game[i]);
    output(ans);
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：52)

一行一行的处理，最后加起来

f[i][j]表示取i~j这一段能获得的最大分数（i~j这部分最后取）

初始化：$f[i][i]=a[i]*2^m$

转移方程：

$$f[i][j]=max(f[i+1][j])+a[k][i]*2^{m+i-j},f[i][j-1]+a[k][j]*2^{m+i-j})$$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,lc;
char ch[100];
int d[100];
int a[100][100][100];
int er[81][100];
int A[100];
int B[100];
int ans[200];
int f[81][81][100];
inline void Add(int *b,int *c)//b=b+c
{
    memset(d,0,sizeof(d));
    d[0]=max(b[0],c[0])+1;
    for (int I=1;I<=d[0];I++)//加法 
    {
        d[I]+=b[I]+c[I];
        d[I+1]+=(d[I]/10);
        d[I]%=10;
    }
    while (d[d[0]]==0) d[0]--;//去掉0 
    for (int I=0;I<=d[0];I++) b[I]=d[I];
    return;
}
inline void CF(int *b,int *c)//高精度乘法 
{
    memset(d,0,sizeof(d));//清空 
    d[0]=b[0]+c[0];
    for (int k=1;k<=b[0];k++)//乘 
        for (int l=1;l<=c[0];l++)
        {
            d[k+l-1]+=b[k]*c[l];
        }
    for (int k=1;k<=d[0];k++)//进位 
    {
        d[k+1]+=d[k]/10;
        d[k]%=10;
    }
    while (d[d[0]]==0) d[0]--;//去掉前面的0 
    for (int k=0;k<=d[0];k++) b[k]=d[k];
}
inline bool Max(int *b,int *c)//比较b数组和c数组哪个大 
{
    while (b[b[0]]==0&&b[0]>0) b[0]--;
    while (c[c[0]]==0&&c[0]>0) c[0]--;
    if (b[0]>c[0]) return true;
    if (c[0]>b[0]) return false;
    for (int i=b[0];i>=1;i--)
        if (b[i]>c[i]) return true; else
        if (b[i]<c[i]) return false;
    return false;
}
bool flag;
int main()
{
    scanf("%d%d",&n,&m); 
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            scanf("%s",ch+1);//读入 
            lc=strlen(ch+1);
            a[i][j][0]=0;
            for (int k=lc;k>=1;k--)
            {
                a[i][j][++a[i][j][0]]=ch[k]-'0';
            }
        }
    er[0][0]=1;er[0][1]=1; 
    for (int i=1;i<=m;i++)//预处理2^1~2^m 
    {
        for (int j=0;j<=er[i-1][0];j++)
        {
            er[i][j]=er[i-1][j];
        }
        Add(er[i],er[i-1]); 
    }
    for (int k=1;k<=n;k++)//行 
    {
        memset(f,0,sizeof(f));
        for (int i=1;i<=m;i++)
        {//f[i][i]=a[k][i]*2^m;
            Add(f[i][i],a[k][i]);
            CF(f[i][i],er[m]);
        }
        for (int l=1;l<m;l++)
        {
            for (int i=1,j=i+l;j<=m;i++,j=i+l)
            {//这就是dp转移的过程 
                memset(A,0,sizeof(A));
                Add(A,a[k][i]);
                CF(A,er[m+i-j]);
                Add(A,f[i+1][j]);
                memset(B,0,sizeof(B));
                Add(B,a[k][j]);
                CF(B,er[m+i-j]);
                Add(B,f[i][j-1]);    
                flag=Max(A,B);
                if (flag)
                {
                    for (int l=0;l<=A[0];l++)
                        f[i][j][l]=A[l];
                } else
                {
                    for (int l=0;l<=B[0];l++)
                        f[i][j][l]=B[l];
                }
            }
        }
        Add(ans,f[1][m]);
    }
    while (ans[ans[0]]==0&&ans[0]>0) ans[0]--;//去掉0 
    if (ans[0]==0) ans[0]++;//特判0 
    for (int i=ans[0];i>=1;i--)//倒着输出 
        printf("%d",ans[i]);
    return 0;
}
```

---

## 作者：qhr2023 (赞：23)

## solution

经典区间 dp。

首先明确每行怎么取是没关联的，所以可以看成 $n$ 行每行跑一次区间 dp。对于每行，设 $f_{l, r}$ 表示取区间 $l$ 到 $r$ 的最大值，这明显从大区间向小区间转移，但这里说一下从小区间向大区间转移。

对于一个区间，它乘的 $2^i$ 的这个 $i$ 是第 $i$ 次取数，就应等于区间长度，一个长度为 $len$ 的区间从 $len-1$ 转移得到，所以每次转移乘 $2$ 就可以解决答案乘 $2^i$ 的问题。这里要好好体会。

记 $a_i$ 表示这一行的第 $i$ 个数，对于区间 $l$ 到  $r$，可以先取 $a_l$，可以先取 $a_r$，转移是 $f_{l, r} = \max(f_{l+1, r}+a_l, f_{l, r-1}+a_r) \times 2$。

答案就是 $n$ 次 $f_{1, m}$ 之和。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[90][90];
__int128 f[90][90], ans;
void out (__int128 x) {
    if(x>9) out(x/10);
    putchar(x%10+'0');
}
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=m; ++j)
			cin >> a[i][j];
	for (int i=1; i<=n; ans+=f[1][m], memset(f, 0, sizeof f), ++i) 
		for (int len=1; len<=m; ++len) 
			for (int l=1, r=l+len-1; r<=m; ++l, ++r)
				f[l][r]=max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r])*2;
	out(ans);
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：7)

一道考试中的题，来写篇题解。

我们首先发现每行是独立的，于是可以一行一行的处理。

又发现贪心有后效性，遂准备 dp。

对于每行，设 $dp_{l,r}$ 为除了区间 $[l,r]$，其它数都取完的最大得分。

所以这一行的最大得分为 $\max_{1\le x\le m}dp_{x,x-1}$。

转移也很好想了，设 $s=r-l+1$，$a$ 数组为该行的数字。

$dp_{l,r}=\max(dp_{l-1,r}+a_{l-1}\times 2^{n-s},dp_{l,r+1}+a_{r+1}\times 2^{n-s})$

此式转移一个是取左边一个是取右边，所以显然成立。

最后就是注意 $dp$ 的转移顺序了，还有要开 `__int128`。

一道水绿就这样的切了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[110];
__int128 dp[110][110];
__int128 sum=0;
void write(__int128 x){
	if(x>=10) write(x/10);
	putchar(x%10+'0');
}
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>a[j];
		dp[1][m]=0;
		for(int j=1;j<=m;j++)
			for(int k=m;k>=j-1;k--)
				dp[j][k]=max(dp[j-1][k]+a[j-1]*(__int128(1)<<(j-1+m-k)),dp[j][k+1]+a[k+1]*(__int128(1)<<(j-1+m-k)));
		__int128 ans=0;
		for(int j=1;j<=m;j++) ans=max(ans,dp[j][j-1]);
		sum+=ans;
	}
	write(sum);
	return 0;
}
```

---

## 作者：tuntunQwQ (赞：5)

对于每一行，设 $f_{l,r}$ 表示剩下 $[l,r]$ 范围内的数未取的最大得分。

转移方程就是 $f_{l,r}=\max(f_{l-1,r}+a_{l-1}\times 2^{m-(r-l+1)},f_{l,r+1}+a_{r+1}\times 2^{m-(r-l+1)})$。

最后将每行的答案加起来即可，注意 $2^{80}$ 的数据要使用 `__int128` 存储。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100;
__int128 ct=1,n,m,a[N][N],f[N][N],ans;
__int128 read(){
	__int128 k=0,f=1;
    char c=getchar();
    while(!isdigit(c)){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(isdigit(c)){
    	k=(k<<3)+(k<<1)+(c^48);
		c=getchar();
	}
    return k*f;
}
void write(__int128 x){
	if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x^48);
    else write(x/10),putchar(x%10^48);
}
signed main(){
	n=read();m=read();
	for(__int128 i=1;i<=n;i++){
		for(__int128 j=1;j<=m;j++){
			a[i][j]=read();
		}
	}
	for(__int128 i=1;i<=n;i++){
		for(__int128 len=m-1;len>=0;len--){
			for(__int128 l=1;l+len-1<=m;l++){
				__int128 r=l+len-1;
				f[l][r]=max(f[l-1][r]+a[i][l-1]*(ct<<m-len),f[l][r+1]+a[i][r+1]*(ct<<m-len));
			}
		}
		__int128 ret=0;
		for(__int128 j=1;j<=m;j++)ret=max(ret,f[j][j-1]);
		ans+=ret;
	}
	write(ans);
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：3)

# P1005 [NOIP 2007 提高组] 矩阵取数游戏 题解
观察数据范围，$1000 \times 2^{80}$ 的数据显然需要开高精，这里就不多讲高精的部分。  
### 解题思路  
通过思考（~~标签~~），发现这题可以用区间动态规划来做。  
由于不同行的结果互不干扰，所以只要把所有行的结果分别处理再加起来就行了。  
由于只能从左右端点选，所以有转移方程 $dp_{i,j}=\max(dp_{i,i}+dp_{i+1,j}\times 2,dp_{j,j}+dp_{i,j-1}\times2)$。每一行的答案就是 $dp_{1,m}$。  
然后显然有 $dp_{i,i}=2a_i$。
### AC 代码  

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
string ans="0";
int n,m;
string dp[85][85];
string mul(string a,string b){//高精乘（其实没必要）
	int lena=a.size(),lenb=b.size();
	reverse(a.begin(),a.end());
	reverse(b.begin(),b.end());
	int len=lena+lenb;
	vector<int> c(len);
	for(int i=0;i<lena;i++){
		for(int j=0;j<lenb;j++){
			c[i+j]+=(a[i]-'0')*(b[j]-'0'); 
		}
	}
	for(int i=0;i<len-1;i++){
		c[i+1]+=c[i]/10;
		c[i]%=10;
	}
	while(c[len-1]>9){
		c.push_back(c[len-1]/10);
		c[len-1]%=10;
		len++;
	}
	while(len>1 && c[len-1]==0){
		len--;
	}
	string res="";
	for(int i=len-1;i>=0;i--){
		res=res+" ";
		res[len-1-i]=char(c[i]+'0');
	}
	return res;
}
string add(string a,string b){//高精加
	reverse(a.begin(),a.end());
	reverse(b.begin(),b.end());
	int len=max(a.size(),b.size());
	vector<int> c(len);
	int d=0;
	for(int i=0;i<len;i++){
		if(i<a.size())d+=(a[i]-'0');
		if(i<b.size())d+=(b[i]-'0');
		c[i]=d%10;
		d/=10;
	}
	if(d){
		len++;
		c.push_back(d);
	}
	string res="";
	for(int i=len-1;i>=0;i--){
		res=res+" ";
		res[len-1-i]=char(c[i]+'0');
	}
	return res;
}
string mmax(string a,string b){//比较大小
	if(a.size()>b.size())return a;
	if(b.size()>a.size())return b;
	if(a>b)return a;
	return b;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>dp[j][j];
			dp[j][j]=mul(dp[j][j],"2");//显然
		}
		for(int len=2;len<=m;len++){
			for(int j=1;j+len-1<=m;j++){
				int k=j+len-1;
				dp[j][k]=mmax(add(dp[j][j],mul(dp[j+1][k],"2")),add(dp[k][k],mul(dp[j][k-1],"2")));//转移方程
			}
		}
		ans=add(ans,dp[1][m]);
	}
	cout<<ans;
}
```

---

## 作者：lihongru (赞：3)

### 题目分析

本题每行独立，所以可以对每一行分别处理。对于每一行，其实就是区间动态规划。比较注意的是动态规划的顺序问题。

本题的区间动态规划中与以往不同的一点是，我们是从 $dp_{1, n}$（即最大区间）开始转移的。

对于一行 $k$，记 $dp_{k, i, j}$ 为这一行**还剩** $[i, j]$ 未取的情况，所获得的最大得分，我们的转移方程是：

$$dp_{k, i, j} = \text{max}(dp_{k, i, j+1} + a_{k, j+1} \times 2 ^ {m - j + i - 1}, dp_{k, i-1, j} + a_{k, i-1} \times 2 ^ {m - j + i - 1})$$

此处需要特别注意：分数的倍率 $2 ^ x$ **取决于取了多少个数，而不是目前转移区间的长度**。取了多少数就是整个区间的长度减去目前转移区间的长度。

接下来我们分析转移。行号转移从 $1 \to n$ 即可，左端点 $l$ 也可以升序，但是列号右端点转移从 $l \to m$ 就会出现取的值还没有算过的情况。我们可以将其逆转过来，即从 $m \to l$ 就可以了。常见的方法有翻转循环顺序，调整两个循环的顺序。

最终统计答案时，每一个最小 $1$ 区间都可能作为转移终点，我们需要对每一个最小区间求最终的答案，即最大值。

比较需要注意的一点是，本题常数较大，**需要使用高精度**。不过现在可以偷懒的办法是使用 `__int128`。但要注意，`cout` 无法直接输出 `__int128`，需要写函数输出。

### 题目总结与参考代码

本题是一个区间动态规划好题，要注意递推顺序与常数的问题带来的影响。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, a[85][85];
__int128 dp[85][85][85], ans, k1 = 1;

void out(__int128 t){
	if (t > 9) out(t / 10);
	putchar(t % 10 + 48); 
}

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            cin >> a[i][j];
        }
    }
    for (int k = 1; k <= n; k++){
        for (int i = 1; i <= m; i++){
            for (int j = m; j >= i; j--){
            	int len = j - i + 1;
                dp[k][i][j] = max(dp[k][i][j], dp[k][i][j+1] + a[k][j+1] * (k1 << m - len));
                dp[k][i][j] = max(dp[k][i][j], dp[k][i-1][j] + a[k][i-1] * (k1 << m - len));
            }
        }
    }
    for (int i = 1; i <= n; i++){
    	__int128 mx = 0;
    	for (int j = 1; j <= m; j++){
    		mx = max(mx, dp[i][j][j] + a[i][j] * (k1 << m));
		}
        ans += mx;
    }
    out(ans);
    return 0;
}
```

---

## 作者：AK_400 (赞：2)

注意到矩阵的每一行都互不影响，所以我们对每一行求解，再将结果相加即可。

设 $f_{i,j}$ 表示矩阵当前的行取到只剩区间 $[i,j]$ 的最大得分。

那么有

$$
f_{i,j} = \max(f_{i-1,j}+a_{x,i-1}\times 2^{m-j+i-1}, f_{i,j+1}+a_{x,j-1}\times 2^{m-j+i-1})
$$

其中 $a_{x,i-1}$ 表示第 $x$ 行的第 $i$ 列的数。

该行答案就是 $\max_{i=1}^mf_{i,i-1}$。

最后将每一行的答案相加即可。

注意 long long 类型会溢出，所以要用 int128 类型。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
__int128_t n,m,a[100][100],ans,ans1,dp[100][100];
template<typename T>
void read(T &x){
    char c=getchar();
    x=0;
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return;
}
template<typename T>
void write(T x){
    if(x>=10)write(x/10);
    putchar(x%10+'0');
    return;
}
__int128_t qp(__int128_t x,int y){
    __int128_t res=1;
    for(int i=0;i<32;i++){
        if(y>>i&1)res*=x;x*=x;
    }
    return res;
}
int main(){
    read(n),read(m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            read(a[i][j]);
    for(int i=1;i<=n;i++){
        memset(dp,0,sizeof(dp));
        for(int j=1;j<=m;j++){
            for(int k=m;k>=j;k--){
                dp[j+1][k]=max(dp[j+1][k],dp[j][k]+qp(2,m-k+j)*a[i][j]);
                dp[j][k-1]=max(dp[j][k-1],dp[j][k]+qp(2,m-k+j)*a[i][k]);
            }
        }
        ans=0;
        for(int i=0;i<m;i++)ans=max(ans,dp[i+1][i]);
        ans1+=ans;
    }
    write(ans1);
    return 0;
}
```

---

## 作者：Motonic_queues (赞：2)

## 题目大意

有 $n$ 行每行 $m$ 个数的矩阵，每回合从每一行的左边或右边取一个数，并获得这个数乘以 $2^i$（$i$ 为当前回合数）的分数，求最大的分数。

## 思路分析

首先不难发现，**每一行的取数是互不干扰的**，也就是说对于每一行同时取和分开取没有区别，那么为了方便分析，我们可以将每一行分开，这样问题就转化为了对一个数列进行操作（不然后面 dp 还要多一维，~~虽然空间也够开~~）。

既然取数是对一个连续的区间进行操作，我们可以考虑区间 dp，那么状态就是区间的左右端点（$l,r$）了，值自然就是取到这个区间时的最大分数了。

根据这个状态，可以考虑对于 $dp_{l,r}$ 从 $dp_{l-1,r}$ 和 $dp_{l,r+1}$ 转移过来，至于分数计算，可以推出当前回合数应该是 $m-r+l-1$，转移方程由此出：

$$
dp_{l,r}=\max\{dp_{l-1,r}+a_{l-1} \times 2^{m-r+l-1},dp_{l,r+1}+a_{r+1} \times 2^{m-r+l-1}\}
$$

~~至此，一锤定音~~\
~~尘埃，已然落定~~

## 细节问题

这个 $0\leq a_{i,j}\leq 1000$ 属实是把我骗到了，回合数能到 $80$ 就显然要开高精，需要支持高精加，高精乘单精，高精比大小，高精输出。

处理转移完的 dp 数组时，要得到的答案应该是 $\max\{dp_{i,i}+a_i \times 2^m\}$。

## Talk is cheap,show me the code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

struct BI{ //高精结构体
	int num[505],ll;
	BI(){
		memset(num,0,sizeof num);
		ll=0;
	}
	void debug(){
		for(int i=1;i<=ll;i++){
			if(num[i]>=1000){
				int p=num[i]%1000,k=num[i]/1000;
				num[i]=p;
				num[i+1]+=k;
				if(i==ll)ll++;
			}
		}
	}
	BI(int k){
		num[1]=k;ll=1;
		debug();
	}
	BI operator+(const BI b)const{
		BI res;
		res.ll=max(ll,b.ll);
		for(int i=1;i<=res.ll;i++)
			res.num[i]=num[i]+b.num[i];
		res.debug();
		return res;
	}
	BI operator*(const int b)const{
		BI res;
		res.ll=ll;
		for(int i=1;i<=res.ll;i++)
			res.num[i]=num[i]*b;
		res.debug();
		return res;
	}
	void WoW(){
		cout<<num[ll];
		for(int i=ll-1;i>=1;i--){
			printf("%03d",num[i]);
		}
	}
};

BI max(BI a,BI b){
	if(a.ll!=b.ll)return a.ll<b.ll?b:a;
	for(int i=a.ll;i>=1;i--)
		if(a.num[i]!=b.num[i])
			return a.num[i]<b.num[i]?b:a;
	return a;
}

int n,m;
long long line[100][100];
BI dp[100][100],pow2[100];
BI ans;

signed main(){
	cin>>n>>m;
	pow2[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>line[i][j];
	for(int i=1;i<=m;i++){
		pow2[i]=pow2[i-1]*2;//预处理2的幂次
	}
	for(int i=1;i<=n;i++){//逐行处理，滚掉dp一维
		memset(dp,0,sizeof dp);
		BI afl;
		for(int l=1;l<=m;l++){
			for(int r=m;r>=l;r--){
				dp[l][r]=max(dp[l][r],dp[l-1][r]+pow2[m-r+l-1]*line[i][l-1]);
				dp[l][r]=max(dp[l][r],dp[l][r+1]+pow2[m-r+l-1]*line[i][r+1]);
			}
		}
		for(int l=1;l<=m;l++){
			afl=max(afl,dp[l][l]+pow2[m]*line[i][l]);//获得答案
		}
		ans=ans+afl;
	}
	ans.WoW();
	return 0;
}
```

---

## 作者：Tomwsc (赞：1)

# P1005 [NOIP 2007 提高组] 矩阵取数游戏 题解

## 题意

给定一个 $n\times m$ 的矩阵，可以进行 $m$ 次取数，每次只能取走每一行的第一个数或最后一个数。设第 $i$ 次取出的数是 $b_1$，$b_2$，$\cdots$，$b_n$，则第 $i$ 次取数的得分是 $\sum_{j=1}^{n}b_j\times 2^i$。问取完 $m$ 次后的每次取数得分之和最大是多少？

## 思路

开始看着题目，可能感觉没有什么头绪。但不难发现，其实行与行之间不会相互影响，所以可以将每一行在输入时单独处理，这样可以把 $a$ 数组压成一维。同时，每行取数之后总是剩余一个区间，所以令人很自然的联想到区间 dp。

设 $dp_{i,j}$ 表示剩下 $[i,j]$ 这个区间时的最大得分。

接下来开始推方程。

$[i,j]$ 区间只能从 $[i-1,j]$ 或 $[i,j+1]$ 区间转移而来。同时，可以得到在转移到 $[i,j]$ 区间时是第 $m-j+i-1$ 次。

所以便能得到转移方程：

$$dp_{i,j}=\max(dp_{i-1,j}+a_{i-1}\times 2^{m-j+i-1},dp_{i,j+1}+a_{j+1}\times 2^{m-j+i-1})$$

此时只需要把 $2^1$ 到 $2^m$ 都用快速幂预处理出来便可将转移的复杂度压缩到 $O(1)$。（用位运算的话似乎会 wa 后四个点）

由 dp 数组的定义可知长度为一的区间不会被计算，所以最终答案为：

$$\sum_{i=1}^{n}\max\limits_{1\le j\le m}(dp_{j,j}+a_j\times 2^m)$$

注意到此题的转移过程是从大区间到小区间的，所以我们的枚举顺序要改一下。即 $i$ 从小到大，$j$ 从大到小。

时间复杂度：$O(nm^2)$。

## 代码

数据范围会爆 ```long long```，可以写高精，但我这里用了 ```__int128```。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int __int128
#define inf 1ll << 62
#define max(a , b) a > b ? a : b
#define min(a , b) a < b ? a : b
using namespace std;
const int MAXN = 85;
int n , m;
int a[MAXN] , poww[MAXN];
int dp[MAXN][MAXN] , ans;

inline int read() {
	char c = getchar();
	int x = 0 , s = 1;
	while(c < '0' || c > '9') {
		if(c == '-')
			s = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * s;
}

inline int ksm(int base , int x) {
	int result = 1;
	while(x) {
		if(x & 1)
			result *= base;
		x >>= 1;
		base *= base;
	}
	return result;
}

void write(int x) {
	if(x < 0) {
		putchar('-');
		x = -x;
	}
	if(x >= 10)
		write(x / 10);
	putchar(x % 10 + '0');
	return;
}

signed main() {
	n = read();
	m = read();
	for(register int i = 1;i <= m;i ++)
		poww[i] = ksm(2 , i);
	while(n --) {
		for(register int i = 1;i <= m;i ++)
			a[i] = read();
		memset(dp , 0 , sizeof(dp));
		for(register int i = 1;i <= m;i ++)
			for(register int j = m;j >= i;j --)
				dp[i][j] = max(dp[i - 1][j] + a[i - 1] * poww[m - j + i - 1] , dp[i][j + 1] + a[j + 1] * poww[m - j + i - 1]);
		int maxn = -inf;
		for(register int i = 1;i <= m;i ++)
			maxn = max(maxn , dp[i][i] + a[i] * poww[m]);
		ans += maxn;
	}
	write(ans);
	return 0;
}
```

---

## 作者：jinminghao (赞：1)

我们可以发现，这个矩阵的每行都是独立的，于是我们可以分别计算每一行的最大得分。

考虑区间 DP。

对于每一行，我们设 $f_{l,r}$ 表示将 $[l,r]$ 取完后，所获得的最大得分。

因为每次只能取行首或行尾，所以我们可以推出状态转移方程：

$f_{l,r} = \max (f_{l,r-1} +  2^{n - len + 1} \times a_r , f_{l+1,r} + 2^{n-len+1} \times a_l)$

总时间复杂度：$O(nm^2)$。

要注意本题需要开`__int128`。

代码：

```cpp
#include<cstdio>
#define max(a,b) (a>b?a:b)
using namespace std;
const int N=90,mod=2,mod10=10;
__int128 f[N][N],v[N],ans;
__int128 power(__int128 a,__int128 b){
	__int128 ans=1;
	while(b){
		if(b%mod) ans=ans*a;
		b/=mod;
		a=a*a;
	}
	return ans;
}
__int128 read(){
	__int128 x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+(c^48);
		c=getchar();
	}
	return x*f;
}
void write(__int128 x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
}
int main(){
	int m,n;//这里的 n 和 m 与原题相反
	scanf("%d%d",&m,&n);
	while(m--){
		for(int i=1;i<=n;i++){
			v[i]=read();
			f[i][i]=power(2,n)*v[i];
		}
		for(int len=2;len<=n;len++){
			for(int i=1;i+len-1<=n;i++){
				int j=i+len-1;
				f[i][j]=max(f[i][j-1]+power(2,n-len+1)*v[j],f[i+1][j]+power(2,n-len+1)*v[i]);
			}
		}
		ans+=f[1][n];
	}
	write(ans);
	return 0;
}

---

## 作者：O_v_O (赞：1)

# P1005 题解

## 题意

给定一个 $n \times m$ 的矩阵，对于每一行，你可以取这一行中最右边的元素和最左边的元素，每个元素取出来会获得 被取走的元素值 $\times 2 ^ i$ 这么多的得分，每一行都是独立的，你需要求出这 $n \times m$ 的矩阵最大能获得多少的得分。

## 思路

这道题因为每一行都是独立的，所以我们可以对每一行单独处理。

而我们每一行都可以用区间dp来解决，所以我们就可以定义一个状态 $dp_{i, j}$ 表示吧区间 $[i, j]$ 这里面的所有的元素拿完最大可以获得多少分数。

**状态转移方程：** $dp_{i, j} = \max(dp_{i + 1, j} + a_{k, i} \times 2^{m + i - j},dp_{i, j - 1} + a_{k, j} \times 2^{m + i - j})$。

**初始状态：** $dp_{i, i} = a_{k, i} \times 2$ （可能你的写法不需要初始化）。

这里还要注意一个点，就是这道题会爆 long long，所以要用高精度或者 __int128（这个点真的很无聊）。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 100;

int n, m;
__int128_t a[N], dp[N][N], ans, p[N];

void read(__int128_t &x) { // __int128 需要用快速读入
  x = 0;
  int f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = x * 10 + ch - '0';
    ch = getchar();
  }
}

void print(__int128_t x) { // __int128 输出也要特殊处理下
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) print(x / 10);
  putchar(x % 10 + '0');
}

__int128_t solve() { // dp
  memset(dp, 0, sizeof(dp));
  for (int i = 1; i <= m; i++) {
    for (int j = m; j >= i; j--) {
      dp[i][j] = max(dp[i - 1][j] + p[m - j + i - 1] * a[i - 1], dp[i][j + 1] + p[m - j + i - 1] * a[j + 1]); // 状态转移
    }
  }
  __int128_t res = 0;
  for (int i = 1; i <= m; i++) {
    res = max(res, dp[i][i] + p[m] * a[i]);
    // 枚举最后一个取的是哪个数，求出最大值
  }
  return res;
}

int main() {
  p[0] = 1;
  for (int i = 1; i <= 90; i++) p[i] = p[i - 1] * 2;
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      read(a[j]); // 读入
    }
    ans += solve();
  }
  if (ans == 0) printf("0");
  else print(ans);
  return 0;
}
```

---

## 作者：x11223344 (赞：1)

首先，可以发现每一行取数是互不影响的。  
因此，可以考虑对每一行分别做一次 dp。  
假设现在在第 $i$ 刚做 dp，设 $dp_{l, r}$ 代表取完第 $i$ 行的 $[l, r]$ 区间。  
初始化：$dp_{l,l} = 2^{m} \times a_{i,l}$。  
转移方程：  
考虑以下两种方案：
1. 先取 $a_{i,l}$，就有 $dp_{l,r}=dp_{l+1,r}+2^{m+l-r} \times a_{i,l}$。
2. 先取 $a_{i,r}$，就有 $dp_{l,r}=dp_{l,r-1}+2^{m+l-r} \times a_{i,r}$。

综上，$dp_{l,r}=\max(dp_{l+1,r}+2^{m+l-r} \times a_{i,l}, dp_{l,r}=dp_{l,r-1}+2^{m+l-r} \times a_{i,r})$。  
最后答案就是每一行的 $dp_{1,m}$ 之和。  
注意：要用 `__int128`，需要手写输出函数。

---


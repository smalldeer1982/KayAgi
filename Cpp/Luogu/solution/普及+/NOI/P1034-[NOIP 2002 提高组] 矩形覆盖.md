# [NOIP 2002 提高组] 矩形覆盖

## 题目描述

在平面上有 $n$ 个点，每个点用一对整数坐标表示。例如：当 $n=4$ 时，$4$ 个点的坐标分别为：$p_1(1,1)$，$p_2(2,2)$，$p_3(3,6)$，$p_4(0,7)$，见图一。

![](https://cdn.luogu.com.cn/upload/image_hosting/dxc1c5k9.png)

这些点可以用 $k$ 个矩形全部覆盖，矩形的边平行于坐标轴。当 $k=2$ 时，可用如图二的两个矩形 $s_1,s_2$ 覆盖，$s_1,s_2$ 面积和为 $4$。问题是当 $n$ 个点坐标和 $k$ 给出后，怎样才能使得覆盖所有点的 $k$ 个矩形的面积之和为最小呢？  
约定：覆盖一个点的矩形面积为 $0$；覆盖平行于坐标轴直线上点的矩形面积也为 $0$。各个矩形必须完全分开（边线与顶点也都不能重合）。


## 说明/提示

对于 $100\%$ 数据，满足 $1\le n \le  50$，$1 \le k \le 4$，$0 \le x_i,y_i  \le 500$。

**【题目来源】**

NOIP 2002 提高组第四题

## 样例 #1

### 输入

```
4 2
1 1
2 2
3 6
0 7
```

### 输出

```
4```

# 题解

## 作者：_Life_ (赞：17)

### 题意
平面上有 $n$ 个点，将其包含在 $k$ 个矩形中（不相交），求矩形的最小面积和。

$n \le 50,1\le k \le 4$

### 题解
我们看到 $n \le 50$，并且结合 NOIP 早期题目的数据特水的尿性，自然而然地想到深搜，所以**大力深搜**即可。

深搜流程：
```cpp
//伪代码
void dfs(int u)
{
	if(u==n+1)
	{
		更新答案;
		return;
	}
	for(int i=0;i<k;i++)
	{
		将第u个点加入第i个矩形;
		if(矩形间不相交)
			dfs(u+1);
		将第i个矩形恢复成加入第u个点前的状态;
	}
}
```

不出意外，代码交上去之后跑得飞快！然后这道题就做完了！[AC记录](https://www.luogu.com.cn/record/52166733)

将点加入矩形/判断矩形间是否相交较为繁琐，代码实现细节见示例代码。

### 代码
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,k,x[55],y[55],ans=0x3f3f3f3f;
struct square
{
	int empty=1,x1,x2,y1,y2;//x1<=x2 y1<=y2
	void join(int u)//将第u个点加入矩形
	{
		if(empty)
			x1=x2=x[u],y1=y2=y[u];
		empty=0;
		x1=min(x1,x[u]),x2=max(x2,x[u]);
		y1=min(y1,y[u]),y2=max(y2,y[u]);
	}
	int area(){return (x2-x1)*(y2-y1);}//计算矩形面积
}squ[4];
int is_intersect(int a,int b,int c,int d)//ab/cd四条边分属两个矩形，判断是否有其他边夹在ab/cd之间
{
	return (a<=c&&c<=b)||(a<=d&&d<=b)||(c<=a&&a<=d)||(c<=b&&b<=d);
}
int is_intersect(int num)//判断矩形之间是否相交
{
	for(int i=0;i<k;i++)
		if(num!=i&&is_intersect(squ[num].x1,squ[num].x2,squ[i].x1,squ[i].x2)&&is_intersect(squ[num].y1,squ[num].y2,squ[i].y1,squ[i].y2))
			return 1;
	return 0;
}
void dfs(int u)
{
	if(u==n+1)
	{
		int sum=0;
		for(int i=0;i<k;i++)sum+=squ[i].area();
		ans=min(ans,sum);
		return;
	}
	for(int i=0;i<k;i++)
	{
		square t=squ[i];
		squ[i].join(u);
		if(!is_intersect(i))
			dfs(u+1);
		squ[i]=t;
	}
}
int main()
{
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d %d",&x[i],&y[i]);
	dfs(1);
	printf("%d",ans);
}
```

---

## 作者：ShineEternal (赞：9)

## 题目链接：
https://www.luogu.org/problem/P1034

这道题调了半天，纪念一下。

## 分析：

**搜索**。

~~总结一下其实发现早些年搜索题目挺多，主要是因为评测机不发达只能手工读入之类而能在工作人员承受之内的大概就是搜索极高的一般非正解的时间复杂度从而得到较小的数据~~

从第一个点往最后搜,在搜索中都有以下可以进入下一个分支的：

- 当前点包含在一个矩形内

- 当前点由一个矩形扩展过来

- 当前点自成一个矩形

**注意三条都要进行，因为题目说必须要弄出k个矩形，所以不存在搜索中贪心的相关思想**


## $code:$

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
struct ben
{
	int x1,y1,x2,y2;//记录矩形的左下角和右上角
}jx[10];
int ans=2147483647;
int n,k;
int x[55],y[55];

int check(int x,int cnt)//判断第x个矩形与其他是否重，=0有重，四种重复情况
{
	for(int i=1;i<=cnt;i++)
	{
		if(i!=x)
		{
			if(jx[i].x1<=jx[x].x1&&jx[i].x2>=jx[x].x1&&jx[i].y1<=jx[x].y1&&jx[i].y2>=jx[x].y1)
			return 0;
			if(jx[i].x2<=jx[x].x2&&jx[i].x2>=jx[x].x2&&jx[i].x2<=jx[x].y2&&jx[i].x2>=jx[x].y2)
			return 0;
			if(jx[i].y1<=jx[x].y1&&jx[i].y2>=jx[x].y1&&jx[i].x2<=jx[x].x2&&jx[i].x2>=jx[x].x2)
			return 0;
			if(jx[i].y1<=jx[x].y2&&jx[i].y2>=jx[x].y2&&jx[i].x2<=jx[x].x1&&jx[i].x2>=jx[x].x1)
			return 0;
		}
	}
	return 1;
}	
int mj(int i)//矩形面积
{
	return (jx[i].x2-jx[i].x1)*(jx[i].y2-jx[i].y1);
}
void dfs(int now,int s,int cnt)
{
	if(s>ans)return ;
	if(now==n+1)
	{
		//printf("%d\n",s);
		if(cnt==k)
		ans=min(ans,s);
		return ;
	}
	
	
	for(int i=1;i<=cnt;i++)//判断能不能放在之前的 
	{
		if(jx[i].x1<=x[now]&&jx[i].x2>=x[now]&&jx[i].y1<=y[now]&&jx[i].y2>=y[now]) //now是否包含在第i个矩形里 
		{
			dfs(now+1,s,cnt);
		
		}
		else
		{
			int tmp1,tmp2,tmp3,tmp4;
			tmp1=jx[i].x1;
			tmp2=jx[i].x2;
			tmp3=jx[i].y1;
			tmp4=jx[i].y2;
			int stmpf=mj(i);
			if(x[now]<jx[i].x1)
			{
				
				jx[i].x1=x[now];
			}
			else
			if(x[now]>jx[i].x2)
			{
				jx[i].x2=x[now];
			}
			if(y[now]<jx[i].y1)
			{
				jx[i].y1=y[now];
			}
			else
			if(y[now]>jx[i].y2)
			{
				jx[i].y2=y[now];
			}
			int stmp=mj(i);
			if(check(i,cnt))
				dfs(now+1,s+stmp-stmpf,cnt);//扩大一个矩形 
			jx[i].x1=tmp1;
			jx[i].x2=tmp2;
			jx[i].y1=tmp3;
			jx[i].y2=tmp4;
		}
	}
	
	//if(flag==1)return ;
	if(cnt==k)return ;
	
	cnt++;
	
	jx[cnt].x1=x[now];
	jx[cnt].x2=x[now];
	jx[cnt].y1=y[now];
	jx[cnt].y2=y[now];
	dfs(now+1,s,cnt);//新增一个矩形 
	jx[cnt].x1=0;
	jx[cnt].x2=0;
	jx[cnt].y1=0;
	jx[cnt].y2=0;
	cnt--;
	return;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	dfs(1,0,0);
	printf("%d\n",ans);
	return 0;
} 
```


---

## 作者：wangjue1629 (赞：3)

# P1034 矩形覆盖

先把所有点按 $x$ 坐标从左到右排成一列，想象自己拿着 $k$ 把尺子去把它们围成 $k$ 个小堆。

如果最优方案里出现“左边这块砖的右边缘伸进了右边那块砖的腹地”这种交叉情况，说明它俩在 $y$ 方向已经完全错开，否则早就撞到一起了。既然 $y$ 方向有空隙，我们完全可以把它们在 $y$ 方向对调一下顺序，让它们在 $x$ 方向也彻底分开，而且面积一点都不会变大。

所以一定能找到一种最优摆法，使得所有矩形在 $x$ 轴上是按顺序一段一段排开的；同理也可能是在 $y$ 轴上排开。既然 $n$ 才 $50$，干脆两条轴都各算一次，最后挑更小的那个值就行。

### 综上，这道题可以用动态规划解决。
***

$f_{t} ^ {i}$ 表示 用 $t$ 段覆盖前 $i$ 个点的最小面积。


* 初始：

  $f_{t} ^ {1} \gets \mathrm{area_{i,1}}$
  
* 转移方程：  

  $
  f_{t} ^ {i}\gets \min_{j<t}\Bigl(f_{t-i} ^ {j}+\mathrm{area_{j+1} ^ {i}}\Bigr)
  $

* 如果分割点 $j$ 满足  

  $
  p_{j} ^ {x} = p_{j+1} ^ {x}
  $

  就代表两段会在同一条竖线上“挤”在一起，必须跳过这条 $j$。
* 最后，把所有点的 $x$ 和 $y$ 对调，再完整跑一遍上面四步。  

* 最终答案为两次结果中的较小值。

## AC CODE
```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn = 55;
const ll INF = (1LL << 60);
struct Node { int x, y; } a[maxn], p[maxn];
ll area[maxn][maxn], f[5][maxn];
int n, k;
bool cmp(Node u, Node v){
    return (u.x < v.x) || (u.x == v.x && u.y < v.y);
}
ll solve(bool byx){
    for(int i = 1; i <= n; ++i){
        p[i] = a[i];
        if(!byx) swap(p[i].x, p[i].y);
    }
    sort(p + 1, p + n + 1, cmp);
    for(int i = 1; i <= n; ++i){
        int xmin = p[i].x, xmax = p[i].x;
        int ymin = p[i].y, ymax = p[i].y;
        for(int j = i; j <= n; ++j){
            xmin = min(xmin, p[j].x); xmax = max(xmax, p[j].x);
            ymin = min(ymin, p[j].y); ymax = max(ymax, p[j].y);
            ll dx = xmax - xmin, dy = ymax - ymin;
            area[i][j] = (dx == 0 || dy == 0) ? 0 : dx * 1LL * dy;
        }
    }
    for(int t = 0; t <= k; ++t)
        for(int i = 0; i <= n; ++i)
            f[t][i] = INF;

    for(int i = 1; i <= n; ++i) f[1][i] = area[1][i];
    for(int t = 2; t <= k; ++t){
        for(int i = t; i <= n; ++i){
            for(int j = t - 1; j < i; ++j){
                if(p[j].x == p[j + 1].x) continue;
                f[t][i] = min(f[t][i], f[t - 1][j] + area[j + 1][i]);
            }
        }
    }
    return f[k][n];
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for(int i = 1; i <= n; ++i) cin >> a[i].x >> a[i].y;
    ll ans = min(solve(true), solve(false));
    cout << ans << '\n';
    return 0;
}
```
时间复杂度：$\mathcal{O}\!\bigl(k\,n^{2}\bigr)$ 可以通过此题。

---

## 作者：uncle_steve (赞：1)

看到数据范围是很水的 $n\le50$，$k\le4$，可以简单的想到应该有个 $O(n^4)$ 的正常算法。

## 解题思路：

关键是怎么利用矩形的问题。

对于矩形的确定，不能简单地看成是“覆盖”了。其实换个角度想，矩形的覆盖可以看做矩形的“划分”。

比如用 $k$ 个矩形覆盖所有点，就是 $k-1$ 次划分整个图形，使其成为 $k$ 个矩形。

想到划分的话就很容易想到可以有状态转移方程的设计：

> 令 $f_{d1,d2.e1,e2,k}$ 为横坐标上下界分别为 $d1,d2$。纵坐标上下界分别为 $e1,e2$ 的点集划分 $k$ 次的矩形覆盖面积最小值，则：
> 
> $$
> f_{d1,d2.e1,e2,k}= \min(
> \min_{
> \begin{subarray}{l}
>    i\in[d1,d2],j\in[0,k)
> \end{subarray}}(f_{d1,i,e1,e2,k-j-1}+f_{i+1,d2,e1,e2,j}),
> \min_{
> \begin{subarray}{l}
>    i\in[e1,e2],j\in[0,k)
> \end{subarray}}(f_{d1,d2,e1,i,k-j-1}+f_{d1,d2,i+1,e2,j})
> )
> $$
> 
> 边界：$f_{d1,d2,e1,e2,0}=\displaystyle d1,d2,e1,e2$ 内的点集的面积。
> 
> 目标：$f_{min_x,max_x,min_y,max_y,k-1}$，这里的 $k$ 是矩形数。

关于 $x_i,y_i\in[0,500]$ 可以离散化一下，这样就成功将复杂度化为 $O(n^4)$。

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	for(;!isalnum(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isalnum(ch);ch=getchar()) x=x*10+ch-'0';
	return x*f;
}
const int xx=52;
struct point
{
	int x,y;
}d[xx],e[xx];
int ans=0x7fffffff,n;
inline bool cmp1(point a,point b){return a.x<b.x;}
inline bool cmp2(point a,point b){return a.y<b.y;}
inline int div(int d1,int d2,int e1,int e2,int k)
{
	int res=ans;
	if(k)
	{
		for(register int i=d1;i<d2;++i)
			for(register int j=0;j<k;++j)
				res=min(res,div(d1,i,e1,e2,k-j-1)+div(i+1,d2,e1,e2,j));
		for(register int i=e1;i<e2;++i)
			for(register int j=0;j<k;++j)
				res=min(res,div(d1,d2,e1,i,k-j-1)+div(d1,d2,i+1,e2,j));
		return res;
	}
	int mxx=0,mnx=ans,mxy=0,mny=ans;
	for(register int i=1;i<=n;++i)
		if(d[i].x>=d[d1].x&&d[i].x<=d[d2].x)
			if(d[i].y>=e[e1].y&&d[i].y<=e[e2].y)
				mxx=d[i].x,mnx=min(mnx,d[i].x),mxy=max(mxy,d[i].y),mny=min(mny,d[i].y);
	return (mxy-mny)*(mxx-mnx);
}
int main()
{
	n=read();int k=read();
	for(register int i=1;i<=n;i++) d[i]=e[i]=(point){read(),read()};
	sort(d+1,d+n+1,cmp1);
	sort(e+1,e+n+1,cmp2);
	ans=div(1,n,1,n,k-1);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：dashabi35 (赞：0)

想作一下绿题，看了一下标签，于是就进来了。

这道题的思路其实挺简单的，也很自然。

绿题的难度还是比较大的，不明所以的我决定先写出 $k=1$ 的特殊情况，简单的思考后知道 $S=(x_{\max}-x_{\min})(y_{\max}-y_{\min})$ ，然后思路就突然来了。

首先，我想先给这几个点按 $x$ 的大小从小到大排序，然后将其分为 $k$ 个连续的部分，再分别求出面积，随后相加。

至于如何分割，直接搜索，复杂度 $O(n\log n+n^k)$ 可以通过此题。

参考代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
struct point{
    int x,y;
    bool operator<(const point &b)const
    {
    	return this->x<b.x;
	}
}a[55];
int n,k;
int ans=2e9;
int q[10];
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
void dfs(int qt,int step)
{
	if(qt>=k)
	{ 
		int tot=0;
		for(int i=0;i<k;++i)
		{
			int y_max=0,y_min=2e9;
			for(int j=q[i];j<q[i+1];++j)
			{
				y_max=max(y_max,a[j].y);
				y_min=min(y_min,a[j].y);
			}
			tot+=(a[q[i+1]-1].x-a[q[i]].x)*(y_max-y_min);
		}
		ans=min(ans,tot);
		return ;
	}
	for(int i=step+1;i<=n;++i)
	{
		q[qt]=i;
		dfs(qt+1,i);
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	q[0]=1;
	q[k]=n+1;
	for(int i=1;i<=n;++i) 
	{
		scanf("%d%d",&a[i].y,&a[i].x);
	}
	sort(a+1,a+n+1);
	dfs(1,1);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：CRH_Beijingzhan (赞：0)

[P1034 [NOIP 2002 提高组] 矩形覆盖](https://www.luogu.com.cn/problem/P1034)

该题使用的是 ```DFS``` 搜索，自定义了矩阵数据结构，通过矩阵离原点最近和最远的两个点确定了唯一矩阵。事实上矩阵的实现并不难。

### DFS 逻辑

类似装球问题，将每个点当作球，矩阵当作盒子，我们要做的其实就是遍历所有的装球的可能情况，从而找到最好的一种。（所以这不是搜索，而是遍历）。

不过为了降低时间复杂度，需要进行一些简单的剪枝。

### 问题与思考

主要遇到的问题在 ```DFS``` 函数的处理上，应该如何理解 ```void dfs``` 的 ```return```。

应该注意是否是递归：

- 如果是，```void``` 是不能递归的，因为无返回值。
- 如果不是，应注意 ```void``` 的 ```return``` 其实起到了剪枝的作用。

虽然很多人都说是直接暴力搜索，但事实上如果没用好这个 ```return``` 还是会超时的。

最后的这个覆盖问题真的很像聚类诶。

### CODE


```
#include<bits/stdc++.h>
using namespace std;
int n,k,ans=0x7f7f7f7f;
struct rectangle{
	int x1=0x7f7f7f7f,x2,y1=0x7f7f7f7f,y2;
	int cnt=0;
	int calcu_area(){
		if(!cnt){
			return 0;
		}else{
			return (x2-x1)*(y2-y1);
		}
	}void add_node(int x,int y){
		x1=min(y1,x);
		y1=min(y1,y);
		x2=max(x2,x);
		y2=max(y2,y);
		cnt+=1;
	}bool inter_each(rectangle t){
		if(y1>t.y2 or t.y1>y2 or x1>t.x2 or t.x1>x2){
			return 0;
		}return 1;
	}
}rects[5];
bool check(){
	for(int i=0; i<k-1; ++i){
		for(int j=i+1; j<k; ++j){
			if(rects[i].inter_each(rects[j])){
				return 0;
			}
		}
	}return 1;
}void dfs(int num,int area,vector<vector<int> >& nodes){
	if(area>=ans){
		return ;
	}if(num<n){
		for(int i=0; i<k; ++i){
			rectangle temp=rects[i];
			rects[i].add_node(nodes[num][0],nodes[num][1]);
			dfs(num+1,area+rects[i].calcu_area()-temp.calcu_area(),nodes);
		}
	}else if(check()){
		ans=min(ans,area);
	}
}int main(){
	cin>>n>>k;
	vector<vector<int> >nodes(n+1);
	for(int i=0; i<n; ++i){
		int x,y;
		cin>>x>>y;
		nodes[i].push_back(x);
		nodes[i].push_back(y);
	}dfs(0,0,nodes);
	cout<<ans<<endl;
	return 0;
}
```

---


# [NOIP 2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

## 样例 #1

### 输入

```
5
5 7 1 2 10
```

### 输出

```
145
3 1 2 4 5
```

# 题解

## 作者：冒泡ioa (赞：614)

一道入门的区间dp，当然，根据写法不同你还可以把它归类为树形dp或者记忆化搜索，其实都无所谓啦。  
作为一道入门题，我们完全可以“显然”地做出来，但是在这里还是想和大家回顾下动态规划以及区间动规。  

Q：dp特点是什么？  
A：dp把原问题视作若干个**重叠**的子问题的逐层递进，每个子问题的求解过程都会构成一个“阶段”，在完成一个阶段后，才会执行下一个阶段。  
Q：dp要满足无后效性，什么叫无后效性？  
A：已经求解的子问题不受后续阶段的影响。

有人觉得dp很抽象，那是因为没有一步一步来想，直接听别人的结论，我们在这里以这道题为例，一步一步来推导。

首先，我们要做的就是**设计状态**，其实就是设计dp数组的含义，它要满足无后效性。  
关注这个  _左子树*右子树+根_ 我只要知道左子树分数和右子树分数和根的分数（已给出），不就可以了吗？管他子树长什么样！  
所以，我们$f$数组存的就是最大分数，怎么存呢？  
我们发现：子树是一个或多个节点的集合。  
那么我们可不可以开一个$f[i][j]$来表示节点i到节点j成树的最大加分呢？可以先保留这个想法（毕竟暂时也想不到更好的了）。 

如果这样话，我们就来设计状态转移方程。  
按照刚刚的设计来说的话，我们的答案就是$f[1][n]$了，那么我们可以从小的子树开始，也就是len，区间长度。有了区间长度我们就要枚举区间起点，i为区间起点，然后就可以算出区间终点j。  
通过加分二叉树的式子我们可以知道，二叉树的分取决于谁是根，于是我们就在区间内枚举根k。  
特别的，$f[i][i]=a[i]$其中a[i]为第i个节点的分数。    
因为是要求最大值，所以我们就可以设计出
$$f[i][j]=MAX(f[i][k-1]*f[k+1][j]+f[k][k])$$
于是乎，我们就自己设计出了一个dp过程，因为是顺着来的，所以很少有不成立的。  

至于输出前序遍历，我们再设计一个状态$root[i][j]$来表示节点i到节点j成树的最大加分所选的根节点。  
所以我们按照$根->左->右$的顺序递归输出即可。

## 代码
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN = 50;
typedef long long ll;
ll n;
ll f[MAXN][MAXN], root[MAXN][MAXN];

void print(ll l, ll r) {
	if (l > r)return;
	printf("%lld ", root[l][r]);
	if (l == r)return;
	print(l, root[l][r] - 1);
	print(root[l][r]+1,r);
}

int main() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++)scanf("%lld", &f[i][i]),f[i][i-1]=1, root[i][i] = i;
	for (int len = 1; len < n; ++len) {
		for (int i = 1; i + len <= n; ++i) {
			int j = i + len;
			f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解
			root[i][j] = i;//默认从起点选根
			for (int k = i + 1; k < j; ++k) {
				if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
					f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
					root[i][j] = k;
				}
			}
		}
	}
	cout << f[1][n] << endl;
	print(1, n);
	return 0;
}
```

---

## 作者：winmt (赞：279)

这题是一道比较简单的**树形DP**。我们可以分成3个任务分别解决，如下：（包含CPP及Pascal代码片段）


**【任务一】采用动态规划方法计算最大分值**

本题可以采用动态规划方法来解决，具体如下：

设f[i, j]为顶点i . . 顶点j所组成的子树的最大分值。若f[i, j] = -1，则表明最大分值尚未计算出。

**f(i,j)={1 (i>j) ; 顶点i的分数 (i=j) ; max(f{i,k-1}\*f{k+1,j}+顶点i的分数 (i<j) 『k取i～j』)**

root[i, j]——顶点i..顶点j所组成的子树达到最大分值时的根编号。当i = j时，root[i, i] := i。

由于问题没有明显的阶段特征，而是呈现为非线性的树形结构，因此，我们采用后序遍历的顺序来计算状态转移方程。计算过程如下：


**【参考程序片段】{cpp版}**

   

   

```cpp
long long search(int L, int r)    // 递归计算f[L][r]
{
int  k;
long long  now, ans;    // 当前分值
if (L > r) return 1;
if (f[L][r]== -1)     // 若尚未计算出顶点L..顶点r对应子树的最高分值
   for(k=L; k<=r; k++) {     // 穷举每一个可能的子根k
      now = search(L, k-1) * search(k+1, r) + f[k][k];  
// 计算以k为根的子树的分值
      if(now > f[L][r])  {
//若该分值为目前最高，则记入状态转移方程，并记下子根}
          f[L][r] = now; 
root[L][r] = k;
      }
}
return  f[L][r];   {返回顶点L..顶点r对应子树的最高分值}
}
```
**【参考程序】{Pascal版}**
function search(L, r: integer) : int64;    {递归计算f[L. r]}

```cpp
var
  i: integer;
  now: int64;   {当前分值}
begin
  if L > r then search := 1
  else 
begin
      if f[L, r] = -1 then {若尚未计算出顶点L..顶点r对应子树的最高分值}
        for i := L to r do  {穷举每一个可能的子根i}
          begin
            now := search(L, i-1) * search(i+1, r) + f[i, i];  {计算以i为根的子树的分值}
            if now > f[L, r] then  {若该分值为目前最高，则记入状态转移方程，并记下子根}
              begin
                f[L, r] := now; way[L, r] := i;
              end;
        end;  {for}
        search := f[L, r];   {返回顶点L..顶点r对应子树的最高分值}
    end;   {else}
end;  {search}
```
显然，主程序可以通过递归调用search(1, n)来计算最高分值。算法的时间复杂度为O(n^2)。

**【任务二】输出加分二叉树的前序遍历**

递归调用search(1, n)后得出的way给出了加分二叉树的结构，其中way[i, j]为该树中顶点i..顶点j的根序号。由于二叉树中序遍历的顺序为1..n，因此，1..way[i, j]-1为左子树，way[i, j] + 1 .. j为右子树。现按照根→左子树→右子树的顺序对加分二叉树进行前序遍历。

注意：由于数字之间用空格隔开，而第一个数字前没有空格，因此，设firstwrite为首数字标志。一旦输出了第一个数字，firstwrite设为false，表明在输入新的数字前需要加空格。

由此，得出前序遍历加分二叉树的算法：


**【参考程序片段】{CPP版}**




```cpp
// 前序遍历顶点L..顶点r对应的子树
void  preorder(int L, int r)
{
if (L > r)  return;
if (firstwrite)
firstwrite = false;
else
  cout<<‘ ‘;      // 顶点间用空格分开
cout << root[L][r];             // 输出子树的根
preorder(L, root[L][r]-1);     // 前序遍历左子树
preorder(root[L][r]+1, r);     // 前序遍历右子树
}
```
**【参考程序片段】{Pascal版}**

```cpp
procedure  preorder(L, r: integer);
// 前序遍历顶点L..顶点r对应的子树
begin
   if L > r then exit;
   if firstwrite then
       firstwrite := false
   else
       write(‘ ‘);   {顶点间用空格分开}
   write(way[L, r]);   {输出子根}
   preorder(L, way[L, r] - 1);   {前序遍历左子树}
   preorder(way[L, r] + 1, r);   {前序遍历右子树}
end;
```
**【任务三】主程序**
有了search函数和preorder过程，就不难得出主程序了：


**『Cpp』**


   
   
   

   

```cpp
int main()
{
int n, i;
bool  firstwrite;
cin >> n;    // 读顶点数
for(i=1; i<=n; i++)      // 状态转移方程初始化
  for(j=i; j<=n; j++)
    f[i][j] = -1;
for (i=1; i<=n; i++) {
  cin >> f[i][i];       // 读顶点i的分值
  root[i][i] = i;        // 顶点i单独成一棵子树
   }
cout << search(1, n) << endl;      // 计算和输出最高加分
firstwrite = true;                   // 设立首顶点标志
preorder(1, n);                       // 前序遍历二叉树
return 0;
}
```
**『Pascal』**




```cpp
read(n);  {读顶点数}
for i := 1 to n do   {状态转移方程初始化}
  for j := i to n do
    f[i j] := -1;
for i := 1 to n do
  begin
    read(temp);   {读顶点i的分值}
    f[i, i] := temp;  way[i, i] := i;   {顶点i单独成一棵子树}
  end;
writeln(search(1, n));   {计算和输出最高加分}
firstwrite := true;     {设立首顶点标志}
preorder(1, n);    {前序遍历二叉树}
writeln;
```
以上算法采用了自上而下的**记忆化方法**，即程序流程基本按照**原问题的递归定义**，不同的是，它专门设置了一张表way，用来记忆在求解过程中得出的所有子树的根，以便在前序遍历中使用。
另外，当在递归过程中第一次遇到一个子问题（f[L, r]=-1）时，计算其解，以后每遇到该子问题时，就不重复计算f[L, r]了。记忆化方式有着只解那些肯定要解的子问题的优点。\_**在应用动态规划方法求解非线性结构问题时，一般采用自上而下的记忆化方法**\_。


---

## 作者：噬月 (赞：49)

[P1040加分二叉树](https://www.luogu.com.cn/problem/P1040)

 _**猜想**_ ：此题可以用DP来做。

首先我们想，符合条件的二叉树是加分最高的二叉树，它的总分依题意得 ```总分 = 左子树分数 * 右子树分数 + 根节点分数``` ，不难看出，欲使总分最高，左右子树的分数应当也分别取最高。 而子树的最高分怎么求呢？自然也是 ```子树总分 = 子树左子树分数 * 子树右子树分数 + 子树根节点分数``` 由此我们得到此题具有**最优子结构**性质。

又，分数计算公式只和左子树分数，右子树分数和根节点分数有关，与如何得到这两个子树分数的方法和路径无关，易得此题的解具有**无后效性**。

故猜想可行。

---
 _**设计状态**_ ：设计DP数组的含义，使其满足无后效性。

题目中给出的节点序号根据二叉树的中序遍历排列，可以想见，任取两个下标$i,j,(i<j)$，可以表示从节点$i$到节点$j$所构成的子树的最高加分（由无后效性可知，**当区间之外还有子树时**，此最高分叠加了区间$[i, j]$之外的节点的最高分）。并设$k(i \le k \le j)$为该子树的根节点，通过枚举根的不同位置来取得不同的左右子树和根节点分数，进而得出最大值。

特别地，我们约定①，当下标相等时，$f_{x, x}$ 的**初始值**为序号为x的节点的初始分数。

由此我们写出 _**状态转移方程**_ ：

$f_{i, j} = max(f_{i, k - 1} \times f_{k + 1, j} + f_{k, k})$

因为题目要求前序遍历输出，我们再使用一个二维数组$root$来记录从节点$i$到节点$j$的最高分子树的根。

 _**代码**_ 
```cpp
#include<iostream>
#include<cstdio>


long long n;
long long f[50][50], root[50][50];
//f[i][j] showes the max scroe from i to j
//f[i][j] = max(f[i][k - 1] * f[k + 1][j] + f[k][k])
//root[i][j] showes the root of the max scroe picked

using namespace std;

void print(long long l, long long r) {
    if (l > r) {
    	return;
    }
    printf("%lld ", root[l][r]);
    if (l == r) {
		return;
    }
	print(l, root[l][r] - 1);
    print(root[l][r] + 1, r);
}

int main() {
	
	cin >> n;
	for (int i = 1; i <= n; ++ i ) {
		
		cin >> f[i][i];//node
		f[i][i - 1] = 1;//left subtree error handling②
		f[i + 1][i] = 1;//right subtree error handling
		root[i][i] = i;
	}
	
	for (int range = 1; range <= n; ++ range ) {
	//enumerate length of range, 
		for (int i = 1; i + range <= n; ++ i ) {
	//then enumerate the start point of range
			int j = i  + range;//end point
			
			//enumerate possible root from start point by default
			for (int k = i ; k <= j; ++ k ) {
				
				if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
					
					f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
					root[i][j] = k;
				}
			}
		}
	}
	
	cout << f[1][n] << endl;
	print(1, n);
	
	
	return 0;
}
```


 _**注**_ ：

①：按照约定之前的定义思路，下标相等时，由无后效性可知，当节点有子树时，此```f[x][x]```叠加了子树的最高分。而我们希望它表示序号为$x$的节点的初始分数，因此称为约定。并且我们强调初始值，因为之后是有可能会更新成更大值的。

②：当$k$取$i$时，会出现```f[i][k - 1]```这种下标相反的情况；$k$取$j$时则在另一端```f[k + 1][j]```出现同样的状况。此时的根节点$k$超出了区间的处理范围；映射到图上，则可以认为是一种左（右）子树为空的状态。由于题目给出空子树默认分数为1，我们令```f[i][k - 1] = 1```。

---
 _**关于等号的讨论：**_ 
```cpp
if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
	
	f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
   	root[i][j] = k;
}
```
其中的不等号改为等号是否有影响？

修改之后对于同一组输入，输出最高分不变，但前序遍历发生了改变：
```
输入：
5
5 7 1 2 10
输出（修改前）：
145
3 1 2 4 5
输出（修改后）：
145
3 2 1 5 4
```
若画出树，可以发现是末端度为1的单叶节点和其叶节点发生了互换；

使用另一组数据：
```
10
5 4 8 9 19 2 1 40 20 22
```
可以得到同样的实验结果（节点互换）。

结合枚举根节点的思路，我们可以发现，枚举根的过程反映到图上是在枚举不同的树型。

 _**关于边界的讨论：**_ 

上述第一组数据生成的最高分树是：
```
     3
    / \
   1    4
    \   \
    2    5
```
现在我们假设枚举过程中到了这样一个情形：

$range = 2, i = 1, j = 3,k = 3$; 

这种情形生成的树型（显然还不是完整的树）如下：
```
     3    或     3
    /          /
   2          1
  /            \
 1              2
```
我们知道，由于$k = 3$，根处于区间的右端，```f[k + 1][j]```显然出现了注②中下标相反的情况，而我们的处理方法是将它默认当作右子树为空来处理。

此处需要强调，如果节点3在之前的遍历中已经被计算过，则```f[3][3]```的数据显然已经被更新为目前为止的最高分，但**可能不全面**。可能出现不全面的情况是：计算的时候节点3刚好在区间端点，受到了我们的默认处理。我们接下来要讨论的部分就是这种不全面是否会影响最终答案。

回到上述情形，现在需要考虑三种情况：

1. 节点3真的没有右子树；
1. 节点3存在右子树，但还未计算过；
1. 节点3存在右子树，且```f[3][3]```的数值已经被更新，但由于处理右子树时节点3处于区间的左端点，因此```f[3][3]```忽略了左子树而计算不全。

分析：

- 情况1的结果是显然的，没有右子树自然不会影响后续计算。

- 情况2，若节点3存在右子树但还未计算过，我们的程序默认认为它没有右子树，计算并更新了```f[3][3]```的值，就出现了我们所说的**不全面**。 然而，当枚举的下一阶段到来（由于右子树存在，区间的长度肯定还未枚举完毕），区间长度+1，且根节点k再次取3时，由于节点3不再处于端点，```f[k + 1][j]```未出现下标相反，右子树就可以被程序所识别。此时对分值进行比较：```f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]```显然的，这个表达式恒真。因此我们可以得出重要的结论：**情况2的计算将造成不全面，但这种不全面是局部的，不会影响整体的运算结果。**

- 情况3，由于我们的枚举是从小到大的，所以其实并不存在忽略左子树的情况；忽略左子树的情况只有从大到小枚举才有可能发生。而如果这样，如2所述，也将在下一次枚举中被更新为正确的值。

综上，对边界的默认处理不会影响最终答案。

---
参考博客：

[大佬冒泡ioa的题解](https://bubbleioa.blog.luogu.org/solution-p1040)


---

## 作者：封禁用户 (赞：16)

### 题目描述
给定一棵二叉树，每个节点都有一个权值。

规定二叉树的加分规则如下：

- 叶子节点的加分就是其本身的权值。

- 非叶子节点的加分是其左子树的加分乘以右子树的加分，再加上该节点自身的权值。

- 空树的加分是 $1$。

题目要求根据给定的 $n$ 个节点的权值，构造一棵二叉树，使得这棵二叉树的加分最大，并输出最大加分以及该二叉树的前序遍历序列。

### 大体思路
是一道区间动规。

状态定义：
- 定义 $dp_{i,j}$ 来表示由节点编号从 $i$ 到 $j$ 所构成的二叉树的最大加分。这里的 $i$ 和 $j$ 代表节点编号的区间，$dp$ 数组用于存储不同区间节点构成二叉树的最优结果。
- 定义 $g_{i,j}$ 用于记录在区间 $[i, j]$ 内构成最大加分二叉树时根节点的编号。通过这个数组，我们可以在后续回溯得到最大加分二叉树的具体结构。

### dp 过程
- 外层循环控制区间长度 $l$，从 $2$ 开始逐渐增加到 $n$，因为长度为 $1$ 的区间已经在初始化时处理过了。

- 中层循环确定区间的起始位置 $i$，根据 $i$ 和 $l$ 可以计算出区间的结束位置 $j = i + l - 1$。

- 内层第一个循环枚举区间 $[i, j]$ 内所有可能的根节点 $k$。

- 对于每个 $k$，计算以 $k$ 为根节点时该区间构成二叉树的加分，即 $a_k + dp_{i,k - 1} \times dp_{k + 1,j}$。这里 $dp_{i, k - 1}$ 表示左子树的最大加分，$dp_{k + 1, j}$ 表示右子树的最大加分，再加上根节点自身的权值 $a_k$ 就是当前以 $k$ 为根节点的二叉树加分。通过不断比较更新，找到这个区间内的最大加分 $ma$。

- 内层第二个循环再次枚举 $k$，找到使得加分等于 $ma$ 的第一个 $k$，将其记录在 $g_{i,j}$ 中，以此确定该区间构成最大加分二叉树时的根节点。

前序遍历一下就行了。
### 参考代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, dp[55][55], g[55][55];
int a[55];

// 前序遍历打印节点
void print (int l, int r) {
    if (l > r) return;
    printf ("%lld ", g[l][r]);
    print(l, g[l][r] - 1);
    print (g[l][r] + 1, r);
}

signed main () {
    // 读取节点数量
    scanf ("%lld", &n);
    for (int i = 1; i <= n; i++) {
        // 读取每个节点的权值
        scanf ("%lld", &a[i]);
        // 初始化长度为 1 的区间的最大加分
        dp[i][i] = a[i];
        // 初始化空树的加分
        dp[i + 1][i] = 1;
        // 记录长度为 1 的区间的根节点
        g[i][i] = i;
    }
    // 外层循环控制区间长度
    for (int l = 2; l <= n; l++) {
        // 中层循环确定区间的起始位置
        for (int i = 1; i <= n - l + 1; i++) {
            int j = i + l - 1;
            int ma = 0;
            // 内层第一个循环枚举区间 [i, j] 内所有可能的根节点
            for (int k = i; k <= j; k++)
                ma = max (ma, a[k] + dp[i][k - 1] * dp[k + 1][j]);
            // 更新该区间的最大加分
            dp[i][j] = ma;
            // 内层第二个循环找到使得加分等于 ma 的第一个 k
            for (int k = i; k <= j; k++) {
                if (a[k] + dp[i][k - 1] * dp[k + 1][j] == ma) {
                    g[i][j] = k;
                    break;
                }
            }
        }
    }
    // 输出最大加分
    printf ("%lld\n", dp[1][n]);
    // 输出最大加分二叉树的前序遍历序列
    print(1, n);
    return 0;
}
```

---

## 作者：wjl1100 (赞：6)

## [原题传送门](https://www.luogu.com.cn/problem/P1040)

## 思路

首先二叉树的中序遍历具有左孩子遍历序列一定在根结点的左边，右孩子遍历序列一定在根结点的右边的性质。

因此我们假设一颗二叉树的根为 $k$，中序遍历为 $(1,2,3,\ldots,n)$ 则它的左儿子为 $(1,2,3,\ldots,k-1)$ 右儿子为 $(k+1,k+2,k+3,\ldots,n)$。

所以我们令 $dp_{i,j}$ 表示中序遍历为 $(i,i+1,i+2,\ldots,j)$ 的二叉树的最大加分，那么我们很容易就可以推出 $dp_{i,j}=\max(dp_{i,k-1} \times dp_{k+1,j}+d_{k})$ 这个式子。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int dp[50][50] , n , val[50] , root[50][50];
inline int dfs(int l , int r) {
	if(l == r) {
		root[l][r] = r;
		dp[l][r] = val[l];
		return dp[l][r];
	}
	if(l > r) {
		root[l][r] = 0;
		dp[l][r] = 1;
		return dp[l][r];
	}
	if(dp[l][r]) return dp[l][r];
	for(int i = l; i <= r; i++) {
		int tl = dfs(l , i - 1) , tr = dfs(i + 1 , r);
		if(tl * tr + val[i] > dp[l][r]) dp[l][r] = tl * tr + val[i] , root[l][r] = i;
	}
	return dp[l][r];
}
inline void bl(int l , int r) {
	if(!root[l][r]) return ;
	cout << root[l][r] << " ";
	bl(l , root[l][r] - 1);
	bl(root[l][r] + 1 , r);
}
signed main() {
	n = read();
	for(int i = 1; i <= n; i++) val[i] = read();
	cout << dfs(1 , n) << endl;
	bl(1 , n);
	return 0;
}
```

---

## 作者：majingxuan123 (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P1040)
# 分析
容易发现，一个子树对应着一个区间。

对于一个区间 $(l,r)$，可以分为三部分 $(l,k-1)$（左子树），$k$（根节点），$(k+1,r)$（右子树）。

我们可以发现，区间 $(l,r)$ 所需要的部分都比自己的规模小，有着动态规划的性质。

于是，我们可以考虑动态规划。

- 状态设计，因为一个子树对应着一个区间，所以设状态 $f_{l,r}$，表示区间 $(l,r)$ 的最大得分。
- 状态转移，由题意得，$f_{l,r}=\max_{f_{l,k-1}\times f_{k+1,r}+d_k}$。
- 边界处理,当 $l>r$ 时，$f_{l,r}=1$；当 $l=r$ 时，$f_{l,r}=d_l$。

当然，因为本题需输出具体方案，所以还应记录路径 $g_{l,r}$，记录 $f_{l,r}$ 是由哪个根节点转移过来的。

时间复杂度：$O(n^3)$。
# 代码
```cpp
#include<iostream>
using namespace std;
int n;
int d[40];
int g[40][40];
long long f[40][40];//开 long long
long long dfs(int l,int r){
	if(f[l][r]>0)return f[l][r];
	if(l>r)return 1;//边界
	if(l==r)return d[l];
	for(int i=l;i<=r;i++){
		int t=dfs(l,i-1)*dfs(i+1,r)+d[i];
		if(f[l][r]<t){
			f[l][r]=t;
			g[l][r]=i;
		}//更新路径
	}
	return f[l][r];
}//记忆化搜索
void print(int l,int r){
	if(l>r)return ;
	if(l==r){
		printf("%d ",l);
		return ;
	}
	printf("%d ",g[l][r]);
	print(l,g[l][r]-1);
	print(g[l][r]+1,r);//前序遍历
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&d[i]);
	printf("%lld\n",dfs(1,n));
	print(1,n);
	return 0;
}
```
不开 `long long` 见祖宗。

---

## 作者：香风智乃 (赞：5)

https://www.luogu.org/problemnew/show/P1040

~~全场唯一写三维数组的蒟蒻（逃~~

硬是把树形dp写成了区间dp

对于每个 $f[i][l][r]$
- $i$：以$i$为根
- $l$：以$l$为左端点
- $r$：以$r$为右端点
- $f[i][j][k]$：可以得到的最大值

每次枚举（按嵌套顺序）：
- $len$：枚举的长度( $0$~$n-1$)
- $i$：枚举的树根
- $l$：左端点（右端点$r=l+len$）
- $j$：子树的树根

状态转移方程：$f[i][l][r]=max(f[j][l][i-1],(l<=j<=i-1)) * max(f[j][i+1][r],(i+1<=j<=r))+a[i]$

前序遍历：开一个$ld[i][l][r]$和$rd[i][l][r]$把该状态下的左右儿子存起来即可~~反正空间够大随便开~~

复杂度：$O(n^4)$
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#define ll long long
#define rint register int
#define rll register long long
using namespace std;

inline int getint()
{
	register char c=getchar(); rint x=0;
	while(!isdigit(c)) c=getchar();
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}
int wt[30];
inline void outint(int x)
{
	if(!x)
	{
		putchar(48); return ;
	}
	rint l=0;
	while(x) wt[++l]=x%10,x/=10;
	while(l) putchar(wt[l--]+48);
}

const ll maxl(const ll &a,const ll &b) {return a>b ?a:b;}
const int max(const int &a,const int &b) {return a>b ?a:b;}
const int min(const int &a,const int &b) {return a<b ?a:b;}

//------上面的优化可无视-------
const int maxn=32;
ll f[maxn][maxn][maxn];
int a[maxn],n,ld[maxn][maxn][maxn],rd[maxn][maxn][maxn];

inline void first_travel(int x,int l,int r)//前序遍历
{
	outint(x),putchar(' ');
	if(ld[x][l][r]) first_travel(ld[x][l][r],l,x-1); 
	if(rd[x][l][r]) first_travel(rd[x][l][r],x+1,r);
}
int main()
{
	n=getint();
	for(rint i=1;i<=n;++i) a[i]=getint();

	for(rint len=0;len<n;++len)
		for(rint i=1;i<=n;++i)
			for(rint l=max(1,i-len);l<=min(i,n);++l) //防止超出范围
			{
				rint r=l+len;
				rll lc=0,rc=0;
				for(rint j=1;j<i;++j) //左子树查找
					if(lc<f[j][l][i-1])
					{
						lc=f[j][l][i-1];
						ld[i][l][r]=j;
					}
				for(rint j=i+1;j<=r;++j) //右子树查找
					if(rc<f[j][i+1][r])
					{
						rc=f[j][i+1][r];
						rd[i][l][r]=j;
					}
				if(!ld[i][l][r]) lc= rd[i][l][r] ? 1:0;//如果左右子树都为空就是叶子节点，lc*rc应为0
				if(!rd[i][l][r]) rc=1;
				f[i][l][r]=lc*rc+a[i];
			}
	rll ans=0; rint root=0;
	for(rint i=1;i<=n;++i)
		if(ans<f[i][1][n])
		{
			ans=f[i][1][n];
			root=i;
		}
	printf("%lld\n",ans);
	first_travel(root,1,n);
	return 0;
}
```

---

## 作者：piano_pei (赞：3)

### [题目传送门](https://www.luogu.com.cn/problem/P1040)

### 思路

先考虑中序遍历是如何遍历的：显然是左->根->右。

我们设 $i$ 为树根，发现由于中序遍历的遍历方式，导致左子树肯定由 $[1,i-1]$ 中的点组成，右子树肯定由 $[i+1,n]$ 中的点组成。同样的，对于左子树中的 $1\leq j\leq i-1$为该左子树的树根，则该左子树的左子树由 $[1,j-1]$ 中的点组成，该左子树的右子树由 $[j+1,i-1]$ 中的点组成；$[i+1,n]$ 同理。通过上述我们发现，**子树向根状态转移实质上是小区间向大区间状态转移**，所以考虑区间 dp。

状态定义：$dp_{l,r}$ 表示区间 $[l,r]$ 组成的子树产生的最大分数。

转移的时候跟区间 dp 的板子差不多，枚举一个根节点 $l\leq k\leq r$，以节点 $k$ 为根的子树产生的分数是 $a_k+dp_{l,k-1}×dp_{k+1,r}$，打擂求得最大值即可。即状态转移方程为：

$$dp_{l,r}=\max_{k=l}^r\{a_k+dp_{l,k-1}×dp_{k+1,r}\}$$

最大分数算出来了，接下来该考虑如何输出前序遍历了。设 $id_{l,r}$ 表示 $dp_{l,r}$ 的分数是以哪个节点为根的时候计算出的子树分数，显然 $id_{l,r}$ 可以在状态转移时计算，然后在 dfs 正常做一遍前序遍历即可。

该算法的瓶颈在于区间 dp，故时间复杂度为 $O(n^3)$。

并没有什么挂点，需要注意的是空子树的分数为 $1$。

### $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
const int N = 30;
ll dp[N][N], a[N];
int id[N][N], n;
il void dfs(int l, int r, int rt)
{
	if(l > r || !rt)
		return;
	cout << rt << " ";
	dfs(l, rt - 1, id[l][rt - 1]);
	dfs(rt + 1, r, id[rt + 1][r]);
}
int main()
{
	cin >> n;
	for(int i = 1;i <= n;++i)
		cin >> a[i];
	for(int i = 1;i <= n;++i)
		for(int j = 1;j <= n;++j)
			dp[i][j] = 1; // 空子树分数为1
	for(int i = 1;i <= n;++i)
		dp[i][i] = a[i], id[i][i] = i;
	for(int len = 2;len <= n;++len)
	{
		for(int l = 1;l + len - 1 <= n;++l)
		{
			int r = l + len - 1;
			for(int k = l;k <= r;++k)
			{
				ll v = a[k] + dp[l][k - 1] * dp[k + 1][r];
				if(v > dp[l][r])
				{
					dp[l][r] = v;
					id[l][r] = k;
				}
			}
		}
	}
	cout << dp[1][n] << "\n";
	dfs(1, n, id[1][n]);
	return 0;
}

```

---

## 作者：穼柗° (赞：3)

注意到，这棵树的中序遍历是 $(1,2,3,\dots,n)$，所以可以区间 DP，但是原理上是树形 DP。

设 $sc_i$ 表示结点 $i$ 的分数，设 $dp_{l,r}$ 为结点 $l$ 到 $r$ 形成的子树中最高的加分，当 $l>r$ 时表示空树的加分。

如果已知**结点 $l$ 到 $r$ 形成的子树的根**是结点 $i$，那么显然最大加分就是 $dp_{l,i-1}\times dp_{i+1,r}+sc_i$。

于是有转移方程
$$
dp_{l,r}=
\begin{cases}
\max\limits_{i=l}^r\{dp_{l,i-1}\times dp_{i+1,r}+sc_i\},l<r;\\
sc_l,l=r;\\
1,l>r
\end{cases}
$$

目前时间复杂度 $O(n^3)$，第一行答案就是 $dp_{1,n}$。

再次注意到，这棵树的中序遍历是 $(1,2,3,\dots,n)$，并且 $dp_{1,n}$ 是由 $\max\limits_{i=1}^n\{dp_{1,i-1}\times dp_{i+1,n}+sc_i\}$ 推出的。可以枚举树根 $i$，根据 $dp_{1,i-1}$、$dp_{i+1,n}$ 和 $sc_i$ 这三个值判断出树根为 $i$ 时这棵树的加分是否为 $dp_{1,n}$。所以可以在 $O(n)$ 的时间复杂度内求出树根，然后它的两颗子树的加分和它们覆盖结点的范围也就确定了。接下来就可以像求树根一样得出两颗子树的树根，按照这个逻辑递归，就可以得到整颗树的结构。不过不用真的存储整颗树，在求二叉树结构的过程中可以顺便输出答案。

具体看代码。
```cpp
#include <iostream>
using namespace std;
int n,sc[30],dp[31][31];
void bui(const int l,const int r) { // 输出结点 l~r 对应的子树的先序遍历
	if(l>r) return;
	else if(l==r) {cout<<l<<' ';return;}
	for(int i=l;i<=r;i++)
		if(dp[l][i-1]*dp[i+1][r]+sc[i]==dp[l][r]) { // 找到这颗子树的树根了
			cout<<i<<' '; // 根结点
			bui(l,i-1); // 左子树
			bui(i+1,r); // 右子树
			return;
		}
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false),
	cout.tie(nullptr);
	cin>>n;
	for(int i=dp[1][0]=1;i<=n;i++)
		cin>>sc[i],dp[i+1][i]=1;
	for(int len=0;len<=n;len++) // 生成 dp[][]
		for(int l=0,r=len-1;r<=n;l++,r++)
			if(l==r) dp[l][r]=sc[l];
			else for(int i=l;i<=r;i++)
				dp[l][r]=max(dp[l][r],dp[l][i-1]*dp[i+1][r]+sc[i]);
	cout<<dp[1][n]<<'\n';
	bui(1,n);
	return 0;
}
```

---

## 作者：egg_boy (赞：3)

[原题跳转](https://www.luogu.com.cn/problem/P1040)  

## 思路
  首先很容易想到这题是用 $dp$ 做的，所以可以按 $dp$ 步骤顺下来。  

---

### $dp$ 的状态定义：

  稍加考虑发现一维 $dp$ 肯定是不行了，那不妨尝试定义 $dp[i][j]$ 为树上 $i$ 点到 $j$ 点的最大得分，因为这个很容易就能想到。

---

### $dp$ 状态转移方程的设计：
  
  我们可以先两层循环枚举 $i$ 点与 $j$ 点 $(i \leq  j)$，这个很容易想因为要枚举两个维度，因为这个题会分左子树与右子树，所以第三层循环枚举 $i$ 到 $j$ 中的根节点 $k$。
   
  这时就容易得到状态转移方程:  
  $dp[i][j]=dp[i][k-1] \times dp[k+1][j]+a[k]$。

  至于叶子结点或子树为空这些特殊情况加个特判就行。   这里有个重点，因为我们的状态转移方程需要知道       $dp[k+1][j]$，所以我们的 $i$ 需要从大到小枚举。

---

### 输出答案：  
  首先是最高得分，直接输出 $dp[1][n]$。

  接下来要输入这棵二叉树的前序遍历，因此我们可以在更新 $dp[i][j]$ 时顺便让 $root[i][j]=k$ 记录 $i$ 与 $j$ 区间内的根节点，最后再递归输出即可。

  
  还有些细节请参考代码与注释。

## code

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;

const int N = 40;
int n, a[N], dp[N][N], root[N][N];

// 递归输出前序遍历 
void read(int l, int r)
{
	if(l > r) return;
	
	cout << root[l][r] << " ";
	read(l, root[l][r] - 1);
	read(root[l][r] + 1, r);
}

signed main()
{
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	
	// 枚举左端、右端与根节点
	for(int i = n; i >= 1; i--) 
		for(int j = i; j <= n; j++)
			for(int k = i; k <= j; k++)
			{
				// l表示左子树得分，r表示右子树得分，cnt为总得分 
				int l, r, cnt;
				
				// 计算左子树得分并判断是否有左子树。 
				if(i == k) l = 1;
				else l = dp[i][k - 1];
				
				// 计算右子树得分并判断是否有右子树。
				if(j == k) r = 1;
				else r = dp[k + 1][j];
				
				// 计算总得分并判断是否为叶子节点。
				if(i == j) cnt = a[k];
				else cnt = l * r + a[k];
				
				// 更新dp[i][j]与root[i][j]。 
				if(cnt > dp[i][j])
				{
					dp[i][j] = cnt;
					root[i][j] = k;
				}
			}
			
	cout << dp[1][n] << "\n";
	read(1, n);
	return 0;
}

// 十年oi一场空，不开(     )见祖宗。 
```

---

## 作者：Sooke (赞：3)

已知中序遍历，那么可得出存在的树是连续的节点 x~y 构成的，又根据以上描述，可知使用的算法是区间动态规划（区间的连续的），类似的题目还有合并石子。但还是需要先特判没有左子树或右子树的情况，再枚举目前区间表示的子树的根节点是什么。具体的步骤楼下的大佬们已经讲得很详细了。不过我习惯将目前子树的前序遍历直接用 string 存着，等到再次调用直接相加即可，可以代替麻烦的递归步骤。缺点是，如果 n 过大，使用 string 就可能会爆（此时使用递归就绰绰有余了）。

首先，需要码出一份数字转化为字符串的表（不要忘了数字后还要多一个空格，字符串相接的时候无需再额外加上空格了）：

```cpp
string c[31]={"0 ","1 ","2 ","3 ","4 ","5 ","6 ","7 ","8 ","9 ","10 ","11 ","12 ","13 ","14 ","15 ","16 ","17 ","18 ","19 ","20 ","21 ","22 ","23 ","24 ","25 ","26 ","27 ","28 ","29 ","30 "};
```
这是比较辛苦的步骤，但是为快速求答作了铺垫。

设 s[x][y] 表示 区间 x~y 最大加分树的前序遍历，首先，先为每个节点 i 对应的 s[i][i] 赋值 c[i]。

如果需要得到更大的区间 x~y 最大加分树的前序遍历，已知根节点的编号，只需要 根结点 对应的 s[p][p] 加 左子树 对应的 s[x][p-1] 加 右子树 对应的 s[p+1][y] 即可。最后，输出最终的前序遍历，也就是 s[1][n]。简化了递归。如果左子树、右字数为空，表明对应的 s[x][y] 也为空字符串，即不用管。

具体代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#define f(i , a , b) for(int i = (a) ; i <= (b) ; i++)
using namespace std;
unsigned int v[32][32];
string c[31]={"0 ","1 ","2 ","3 ","4 ","5 ","6 ","7 ","8 ","9 ","10 ","11 ","12 ","13 ","14 ","15 ","16 ","17 ","18 ","19 ","20 ","21 ","22 ","23 ","24 ","25 ","26 ","27 ","28 ","29 ","30 "};
string s[32][32];
int main(){
    int n;
    scanf("%d" , &n);
    f(i , 1 , n) scanf("%d" , &v[i][i]) , s[i][i] = c[i];
    f(k , 1 , n-1)
        f(i , 1 , n-k){
            if(v[i][i+k] < v[i][i] + v[i+1][i+k])
            v[i][i+k]=v[i][i] + v[i+1][i+k] , s[i][i+k]=s[i][i]+s[i+1][i+k]; //枚举没有左子树的情况
            if(v[i][i+k] < v[i+k][i+k] + v[i][i+k-1])
            v[i][i+k]=v[i+k][i+k] + v[i][i+k-1] , s[i][i+k]=s[i+k][i+k]+s[i][i+k-1]; //枚举没有右子树的情况
            f(p , i+1, i+k-1)
                if(v[i][i+k] < v[p][p] + v[i][p-1] * v[p+1][i+k])
                v[i][i+k] = v[p][p] + v[i][p-1] * v[p+1][i+k] , s[i][i+k] = s[p][p]+s[i][p-1]+s[p+1][i+k];
        }
    printf("%d\n" , v[1][n]);
    cout << s[1][n];
    return 0;
}
```

---

## 作者：Swordmaker (赞：2)

# P1040 [NOIP 2003 提高组] 加分二叉树

# 前置知识

动态规划的思想与设计，二叉树的遍历原则。

# 思路分析

看到这道题目要求出最大值，可以想到运用 DP 来解题。

在设计 DP 状态时，我们钦定 $f_{i,j}$ 表示中序遍历为 $i$ 到 $j$ 的最大得分。

那么，我们就可以写出如下的转移式

$f_{i,j}=\max(f_{i,k-1} \times f_{k+1,j}+d_k)$ 

其中 $f_{k,k}$ 的初始值为 $d_k$。

又由于中序遍历的顺序是左子树，根，右子树，所以不断递归求解左右子树即可。

至于输出前序遍历的顺序也不难，只需要多加一个数组，例如我们钦定 $rt_{i,j}$ 表示 $i$ 到 $j$ 中的根，在递归分治的过程中更新。

# code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e2+5;
int n;
int f[N][N],rt[N][N];
int dfs(int i,int j)
{
	if(i>j) return 1;
	if(f[i][j]==-1)
	{
		for(int k=i;k<=j;k++)
		{
			int ans=dfs(i,k-1)*dfs(k+1,j)+f[k][k];
			if(ans>f[i][j])
			{
				f[i][j]=ans;
				rt[i][j]=k;
			}
		}
	}
	return f[i][j];
}
void out(int i,int j)
{
	if(i>j) return;
	cout<<rt[i][j]<<" ";
	out(i,rt[i][j]-1);
	out(rt[i][j]+1,j);
	return;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	memset(f,-1,sizeof(f));
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		f[i][i]=x;
		rt[i][i]=i;
	}
	dfs(1,n);
	cout<<f[1][n]<<"\n";
	out(1,n);
	return 0;
}
/*
f[i][j]表示中序遍历为i~j的树的最大加分 
*/
```

---

## 作者：YZren (赞：2)

# 题目大意
给定一个中序遍历为（$1,2,3,\ldots,n$）的二叉树，每个结点有一个权值，定义二叉树的加分规则为：左子树的加分 $\times$ 右子树的加分 $+$ 根的分数，求最大加分，并输出起前序遍历。
# 题目分析
- 首先中序遍历的顺序是：左儿子，根，右儿子。因为可能没有左儿子或右儿子，所以（$1,2,3,\ldots,n$）都可以为根。这样我们就令 $k \in (1,2,3,\ldots,n)$，左儿子的中序遍历就为（$1,2,3,\ldots,k-1$），右儿子的中序遍历就为（$k+1,k+2,k+3,\ldots,n$）。
- 然后，令 $root_{i,j}$ 为从节点 $i$ 到节点 $j$ 的根，$dp_{i,j}$ 为从节点 $i$ 到节点 $j$ 的最大加分，明显当 $dp_{l,k-1}\times dp_{k+1,r}+val_k>dp_{l,r}$ 时更新答案。
- 最后是输出答案，按前序遍历遍历即可。
## Code

```cpp
inline void PreOrderTraversal(int l,int r){
	if(!root[l][r]) return ;
	write(root[l][r]); putchar(' ');
	PreOrderTraversal(l,root[l][r]-1);
	PreOrderTraversal(root[l][r]+1,r);
}
```
这样这个题就结束了。
# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=3e2+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),dp[maxn][maxn],root[maxn][maxn],val[maxn];
inline int dfs(int l,int r){
	if(l==r){root[l][r]=l;return dp[l][r]=val[l];}
	if(l>r){root[l][r]=0;return dp[l][r]=1;}
	if(dp[l][r]) return dp[l][r];
	f(i,l,r){
		int tl=dfs(l,i-1),tr=dfs(i+1,r);
		if(tl*tr+val[i]>dp[l][r]) root[l][r]=i,dp[l][r]=tl*tr+val[i];
	}
	return dp[l][r];
}
inline void PreOrderTraversal(int l,int r){
	if(!root[l][r]) return ;
	write(root[l][r]); putchar(' ');
	PreOrderTraversal(l,root[l][r]-1);
	PreOrderTraversal(root[l][r]+1,r);
}
inline void work(){
	f(i,1,n) val[i]=read();
	write(dfs(1,n)); puts("");
	PreOrderTraversal(1,n);
}
signed main(){work();return 1^1;}
```

---

## 作者：uncle_steve (赞：1)

## 解题思路：

这题的思路还是很明显的，但有很多细节需要注意。

首先我们注意到权值都是正整数，那么这棵树的加分最高当且仅当左右子树的加分最高，所以问题满足最优性原理，可以使用 DP 求解。

记 $f(i,j)$ 为中根序 $[i,j]$ 对应子树的最高加分，成立状态转移方程：

$f(i,j)=\max(w_{k}+f(i,k-1)\times f(k+1,j))，i<k<j$

上面式子还有个小问题，没有考虑左右子树为空的情况。注意空子树的加分记作 1，且叶节点的加分就是它的权值，不考虑它的空子树。

上面的方程直接写成递归肯定会 TLE 的，究其原因是递归要自顶向下把经过的点都算出来，那这个过程中有很多点被重复计算了。

采用记忆化搜索来优化，即开一个数组 $f$，计算 $f(i,j)$ 时查看 $f[i][j]$，如果它还没有被算过，就把它算出来，并存到 $f[i][j]$ 中；如果 $f[i][j]$ 已经有值了，也就是被算过了，那就直接返回，不用向下再算了。

这样每个点都被算了恰好一次，时间复杂度 $O(n^2)$。

## AC代码：

```cpp
#include<stdio.h>
#include<queue>
using namespace std;
#pragma warning(disable:4996)
int f[30][30];//中序遍历[i,j]对应的最优子树的加分，初始化为-1
int root[30][30];//中序遍历[i,j]对应的最优子树的根编号
int tree[30][2];//tree[i][0]=i的左儿子，tree[i][1]=i的右儿子,空子树为0
int w[30];//w[i]=i号节点权值
int n;
queue<int>q;
void dfs(int i,int j)//计算f[i][j],root[i][j]
{
	if (f[i][j] != -1)return ;
	if (i == j)//是叶节点
	{
		f[i][j] = w[i];
		root[i][j] = i;
		return;
	}
	for (int k = i+1;k <j;k++)//两子树都不空
	{
		dfs(i, k - 1);dfs(k + 1, j);
		if (f[i][j] < w[k] + f[i][k - 1] * f[k + 1][j])
		{
			f[i][j] = w[k] + f[i][k - 1] * f[k + 1][j];
			root[i][j] = k;
		}
	}
	dfs(i + 1, j);
	if (f[i][j] < w[i] + 1 * f[i + 1][j])
	{
		f[i][j] = w[i] + 1 * f[i + 1][j];
		root[i][j] = i;
	}
	dfs(i, j-1);
	if (f[i][j] < w[j] + f[i][j - 1] * 1)
	{
		f[i][j] = w[j] + f[i][j - 1] * 1;
		root[i][j] = j;
	}
}
void buildtree(int i, int j)
{
	int r = root[i][j];
	if (i == j) 
	{ 
		tree[r][0] = 0; 
		tree[r][1] = 0;
		return;
	}
	if (r == i)
	{
		buildtree(r + 1, j);
		tree[r][0] = 0;
		tree[r][1] = root[r + 1][j];
		return;
	}
	if (r == j)
	{
		buildtree(i, r-1);
		tree[r][0] = root[i][r-1];
		tree[r][1] = 0;
		return;
	}
	buildtree(i, r - 1);
	tree[r][0] = root[i][r - 1];
	buildtree(r + 1, j);
	tree[r][1] = root[r + 1][j];
}
void pre(int r)
{
	q.push(r);
	if (tree[r][0]!=0)pre(tree[r][0]);
	if (tree[r][1]!=0)pre(tree[r][1]);
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &w[i]);
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= n;j++)
			f[i][j] = -1;	
	dfs(1, n);
	printf("%d\n", f[1][n]);
	buildtree(1, n);
	pre(root[1][n]);
	while (!q.empty())
	{
		printf("%d", q.front());
		if (q.size() > 1)printf(" ");
		q.pop();
	}
}
```

---

## 作者：DrDuck (赞：1)

### 前置芝士：区间 DP
~~应该不会有人像我一样一开始用树形 DP 做的吧。~~

首先这道题树形 DP 是肯定不行的，我们根本无法确定树的结构。

再次读题，这棵树有一个特殊性质——它是一棵二叉树，不是左子树就是右子树，答案就是它们的合并。可以利用区间 DP 解决。

记 $f_{i,j}$ 为区间 $[i,j]$ 所构成的二叉树的最大得分。每次枚举断点 $k$ 作为区间 $[i,j]$ 所构成的二叉树的根节点。记节点 $i$ 的分数为 $a_i$，不难得出状态转移方程：
$$
f_{i,j} = \max(f_{i, k - 1} \times f_{k + 1, j} + a_k),k \in [i, j]
$$
注意当 $k = i$ 的时候上面的式子中的 $f_{i, k - 1}$ 不要乘， $k = j$ 时同理。

至此，第一问顺利完成。

第二问让我们在满足得分最大的情况下，输出一种合理的构造方案。我们新开一个数组 $rt$，记录当 $f_{i,j}$ 取得最大时区间 $[i,j]$ 所构成的二叉树的根节点。每次当 $f_{i,j}$ 被成功更新时，置 $rt_{i, j} \gets k$ 即可。最后递归输出即可。
# CODE

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 32;
int n, ans, man;
int a[maxn], f[maxn][maxn], rt[maxn][maxn];
void print(int l, int r)
{
    if (l > r)
    {
        return;
    }
    cout << rt[l][r] << " ";
    if (l == r)
    {
        return;
    }
    print(l, rt[l][r] - 1);
    print(rt[l][r] + 1, r);
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        f[i][i] = a[i];
        rt[i][i] = i;
    }
    for (int l = 2; l <= n; l++)
    {
        for (int i = 1; i + l - 1 <= n; i++)
        {
            int j = i + l - 1;
            for (int k = i + 1; k < j; k++)
            {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + a[k])
                {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + a[k];
                    rt[i][j] = k;
                }
            }
            if (f[i][j] < f[i + 1][j] + a[i])
            {
                f[i][j] = f[i + 1][j] + a[i];
                rt[i][j] = i;
            }
            if (f[i][j] < f[i][j - 1] + a[j])
            {
                f[i][j] = f[i][j - 1] + a[j];
                rt[i][j] = j;
            }
        }
    }
    cout << f[1][n] << '\n';
    print(1, n);
    return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

一道区间 dp。

由于本题给出中序遍历，其顺序是左根右，设 $l<k<r$，若 $l$ 到 $r$ 构成了一颗以 $k$ 为根的树，那么 $k$ 的左右子树就是 $l$ 到 $k-1$ 和 $k+1$ 到 $r$，这样就将问题转化到区间上，这样大区间的最优解就可以由小区间得到，这就成区间 dp 了。

设 $f_{l, r}$ 表示从 $l$ 到 $r$ 构成的树的最大加分，枚举 $k$ 作为根，转移是 $f_{l, r}$ 就是最大的 $f_{l, k-1} \times f_{k+1, r} + a_k$，$a_i$ 表示第 $i$ 个点的加分，我输入时直接用 $f_{i, i}$ 代替了，省了一个数组。

题目还求前序遍历，相当于求一种方案，我们需要额外维护一个 $rt_{l, r}$ 表示从 $l$ 到 $r$ 构成的树的加分最大时这个树的根，最后输出前序遍历，即根左右的顺序递归输出。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, f[35][35], rt[35][35];
void out (int l, int r) {
	if (l<=r)
		cout << rt[l][r] << ' ',
		out(l, rt[l][r]-1),
		out(rt[l][r]+1, r);
} 
int main () {
	cin >> n;
	for (int i=1; i<=n; i++)
		cin >> f[i][i],
		rt[i][i]=i;
	for (int len=1; len<=n; len++) 
		for (int l=1, r=len; r<=n; l++, r++) {
			f[l][r]=f[l+1][r]+f[l][l];
			rt[l][r]=l;
			for (int k=l+1; k<r; k++)
				if (f[l][r]<f[l][k-1]*f[k+1][r]+f[k][k])
					f[l][r]=f[l][k-1]*f[k+1][r]+f[k][k],
					rt[l][r]=k;
		}
	cout << f[1][n] << '\n';
	out(1, n);
	return 0;
}
```

---

## 作者：wuenzi (赞：1)

这个题目是一个区间 dp 的模板题。

### 什么是区间 dp

顾名思义，就是以区间为一个维度的 dp。

### 区间 dp 的转移过程

首先，对于区间 $[l,r]$，我们可以枚举一个中间点 $k$，随后 $dp_{l,r}$ 的可以从 $dp_{l,k}$ 和 $dp_{k,r}$ 中转移而来。

### 注意

区间 dp 中，一定要先从区间长度小的枚举到区间长度大的。

### 本题状态定义

定义 $dp_{i,j}$ 为结点 $i$ 到结点 $j$ 子树的最大加分。


### 本题的转移

显然地，我们确定子树根节点 $k$，根据题意本题转移方程为 $dp_{l,r}=\max(dp_{l,k-1} \times dp_{k+1,r} + a_k)$，表示枚举左子树的点数，计算出右子树的点数，求最大值，这是一个简单的定一求一的过程。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1000][1000];
int a[10000];
int n;
int path[1000][1000];
void pt(int i,int j){//输出答案
	if(i>j){
		return;
	}
	cout<<path[i][j]<<' ';
	pt(i,path[i][j]-1);
	pt(path[i][j]+1,j);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int l=1;l<=n;l++){//因为要从区间长度小的枚举到区间长度大的，所以先枚举长度
		for(int i=1;i+l-1<=n;i++){//左端点
			int j=i+l-1;//右端点
			if(i==j){
				dp[i][j]=a[i];
				path[i][j]=i;
			}else{
				for(int k=i;k<=j;k++){
					//边界
					if(k==i){
						dp[i][k-1]=1;
					} else if(k==j){
						dp[k+1][j]=1;
					}
				if(dp[i][j]<dp[i][k-1]*dp[k+1][j]+a[k]){
					dp[i][j]=dp[i][k-1]*dp[k+1][j]+a[k];
					path[i][j]=k;//决策
				}
			}
			}
			
		}
	}
	cout<<dp[1][n]<<endl;
	pt(1,n);
	return 0;
}
```

---

## 作者：chrispang (赞：1)

给定一个含有 $n$ 个结点的二叉树的**中序遍历**序列中每个节点的**权值**。

定义一棵子树的分数为左子树的分数 $\times$ 右子树的分数 $+$ 根节点的权值。

额外规定**空树**的分数为 $1$，**叶子**的分数为该点的权值。

求一种满足该中序遍历的建树方案，使得整棵树的分数最大。

---

- **定义**：$f(i,j)$ 表示中序遍历是 $w_{i\sim j}$ 的所有二叉树的得分的最大值。
- **状态转移方程**：$f(i,j) = \max\{f(i,k-1) \times f(k+1,j) + w_k\}$，即将 $f_{i\ j}$ 表示的二叉树集合按根节点分类，则根节点在 $k$ 时的最大得分即为 $f(i,k-1) \times f(k+1,j) + w_k$，则 $f(i,j)$ 即为遍历 $k$ 所取到的最大值。

- **初始化**：$f_{i\ i}=0$。

- **答案**：$f_{1\ n}$。

在 DP 的过程中，一边 DP 一边记录最大分数的根节点。之后再递归输出先序遍历即可。

```cpp
#include <bits/stdc++.h>
#define maxn 35
using namespace std;

int n, w[maxn], f[maxn][maxn], root[maxn][maxn];
void dfs(int l, int r) {
    if(l > r) return; //越界了，返回
    int k = root[l][r]; //根节点
    cout << k << " ";
    dfs(l, k - 1); //递归左子树
    dfs(k + 1, r); //递归右子树
}

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    for (int l = n; l >= 1; l--) //枚举左端点
        for (int r = l; r <= n; r++) { //枚举右端点
            for (int k = l; k <= r; k++) { //枚举根节点
                int left = l == k ? 1 : f[l][k - 1]; //左子树
                int right = r == k ? 1 : f[k + 1][r]; //右子树
                int score = left * right + w[k]; //分数
                if(l == r) score = w[k]; //叶子节点
                if(f[l][r] < score) {
                    f[l][r] = score; //更新 DP
                    root[l][r] = k; //记录根节点
                }
            }
        }
    cout << f[1][n] << endl; //最后的答案
    dfs(1, n); //递归输出先序遍历
    return 0;
}
```

##

---

## 作者：Tighnarri (赞：1)

[原题在这](https://www.luogu.com.cn/problem/P1040)

本题可视为区间 dp 的良好练手题。

因为题目给出的为中序遍历，所以对于一个由我们钦定的节点，它的左右区间就是他的左右子树。那么可以设置 $dp$ 数组的意义为：区间 $l$ 到 $r$ 的最大得分。

那么接下来遍历区间 $l$ 到 $r$ ，寻找一个断点 $k$ ，使得 $dp{_l}{_,}{_{k-1}} \times dp_{k+1}{_,}{_{r}}+a_k$ 最大。

预处理 $l=r$ 的情况（将其视为叶子节点）为 $dp{_l}{_,}{_r}=a_l$ 与 $l=r-1$ 的情况（空子树为1）为 $dp{_l}{_,}{_r}=1$。

接下来就是对于前序遍历，这个就很简单了。在对上述区间做 dp 时，记录 $l$ 到 $r$ 区间的根节点，最后递归输出即可。

AC code：
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
#include<vector>
#define int long long
using namespace std;
int n,a[40];
int f[40][40];
int root[40][40];
void print(int l,int r){
	if(l>r) return ;
	cout<<root[l][r]<<' ';
	if(l==r) return ;
	print(l,root[l][r]-1);
	print(root[l][r]+1,r);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i][i]=a[i];
		f[i][i-1]=1;
		root[i][i]=i;
	}
	for(int len=2;len<=n;len++){
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			f[i][j]=f[i+1][j]+a[i];
			root[i][j]=i;
			for(int k=i+1;k<j;k++){
				if(f[i][j]<f[i][k-1]*f[k+1][j]+a[k]){
					f[i][j]=f[i][k-1]*f[k+1][j]+a[k];
					root[i][j]=k;
				}	
			}
		}
	}
	cout<<f[1][n]<<endl;	
	print(1,n);
	return 0;
}
```

---

## 作者：_WA自动机 (赞：1)

DP。先考虑暴力，枚举每个可能排列，肯定TLE。但发现每棵子树的加分出现重复计算，且子树的中序遍历为连续的，故
设$f(i,j)$为中序遍历为$(i,i+1,..,j)$的树的最大权值，则
$f(i,j)=max\lbrace{f(i,k)*f(k+2,j)+w(k+1)}\rbrace$  
边界为$f(i,i)=w(i)$  
然后我特判了左右子树为空。输出方案可记录每个子树的根即当转移时记录$root(i,j)=k+1$.递归输出前序遍历。
上代码：  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50;
int g[maxn][maxn];
void printans(int l,int r)
{
	if (l<=r)
	{
		printf("%d ",g[l][r]);
		if (l<r)
			printans(l,g[l][r]-1),
			printans(g[l][r]+1,r);
	}
}
int main()
{
	//f[i][j]=max{f[i][k]*f[k+2][j]+f[k+1][k+1]}
	static unsigned f[maxn][maxn],w[maxn];
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;++i)
		scanf("%d",w+i);
	for (int i=1;i<=n;++i)
		f[i][i]=w[i],g[i][i]=i;
	for (int i=n;i;--i)
		for (int j=i+1;j<=n;++j)
		{
			if (f[i][j]<f[i+1][j]+w[i]) f[i][j]=f[i+1][j]+w[i],g[i][j]=i;
			if (f[i][j-1]+w[j]>f[i][j]) f[i][j]=f[i][j-1]+w[j],g[i][j]=j;
			for (int k=i;k<j-1;++k)
				if (f[i][k]*f[k+2][j]+w[k+1]>f[i][j]) f[i][j]=f[i][k]*f[k+2][j]+w[k+1],g[i][j]=k+1;
		}
	printf("%d\n",f[1][n]);
	printans(1,n);
}
```

---

## 作者：Eason_cyx (赞：0)

题意很明确。

不难发现这个分数的形式和数据范围很像区间啥的，那么考虑区间 DP。状态就好定义，$f_{i,j}$ 表示前序遍历里 $[l,r]$ 这段能得到的最大得分。转移方程也很显然，根据题目来就好了：

$$f_{i,j}=\max_{k=i}^{j}f_{i,k-1}\times f_{k+1,j}+d_k$$

最初状态为 $f_{i,i}=d_i$，最终答案显然为 $f_{1,n}$。

注意一个问题：由于这里 $k$ 的范围是 $i$ 到 $j$，那么可能会出现类似 $f_{i,i-1}$ 或 $f_{i+1,i}$ 的东西，而这东西默认是 $0$，那么此时我们应当将这些东西当作题目中的“空结点”来算，也就是 $f_{i,i-1}=f_{i+1,i}=1$。这样就可以算出最大值了。

前序遍历也好算：对于一个区间 $[l,r]$，记 $mx_{l,r}$ 为在对 $f_{l,r}$ 找最大值的时候找到最大值对应的 $k$。那么最后从 $mx_{1,n}$ 一层层递归回去，就能得到前序遍历了。时间复杂度 $O(n^3)$，可以通过。

```cpp
int n; cin >> n;
for(int i = 1;i <= n;i++) cin >> d[i], f[i][i] = d[i];
for(int i = 1;i <= n;i++) f[i][i-1] = 1, f[i][i+1] = 1;
for(int len = 2;len <= n;len++) {
  for(int i = 1;i + len - 1 <= n;i++) {
    int j = i + len - 1; for(int k = i;k <= j;k++) {
      if((f[i][k-1] * f[k+1][j]) > (f[i][j] - d[k])) {
        f[i][j] = (f[i][k-1] * f[k+1][j]) + d[k]; mx[i][j] = k;
      }
    }
  }
}
```

---

## 作者：cqsunny (赞：0)

观察到 $n \le 30$，求最高加分，因此考虑到 DP。

设 $f_{i, j}$ 表示 $i$ 到 $j$ 的最大加分。

转移时枚举中转点 $k$，把 $k$ 当作根，计算左右子树的加分的乘积和该节点的加分之和，即 $f_{i, j} = f_{i, k - 1} \times f_{k + 1, j} + a_i$。注意左右子树为空的情况要特判。

如何求这棵树呢？

在转移时，如果能更新 $f_{i, j}$，就用一个 $d$ 数组记录区间 $[i, j]$ 的根（也可以记录 $k - i$）。输出方案时，进行 dfs。dfs 记录区间 $[l, r]$，每次找出根 $t$ 输出，然后继续递归 $[l, t - 1]$ 和 $[t + 1, r]$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[40];
int f[40][40];
int d[40][40];
void dfs(int x, int y){//输出方案
	if(x > y){
		return;
	}
	printf("%d ", x + d[x][y]);
	dfs(x, x + d[x][y] - 1);
	dfs(x + d[x][y] + 1, y);
}
int main(){
	memset(f, 0, sizeof(f));
	memset(d, 0, sizeof(d));
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i){
		scanf("%d", &a[i]);
	}
	for(int i = 1; i <= n; ++ i){//初始化
		f[i][i] = a[i];
		d[i][i] = 0;
	}
	for(int k = 2; k <= n; ++ k){
		for(int i = 1; i <= n - k + 1; ++ i){
			int j = i + k - 1, t1, t2;
			for(int u = i; u <= j; ++ u){
				if(u == i){
					t1 = 1;
				}
				else{
					t1 = f[i][u - 1];
				}
				if(u == j){
					t2 = 1;
				}
				else{
					t2 = f[u + 1][j];
				}
				int t = t1 * t2 + a[u];
				if(f[i][j] < t){
					f[i][j] = t;
					d[i][j] = u - i;
				}
			}
		}
	}
	printf("%d\n", f[1][n]);
	dfs(1, n);
	return 0;
}
```

---

## 作者：xz001 (赞：0)

- 由于中序遍历连续，所以相邻两个元素 $(i,i+1)$ 也为连续的，故可以转化为序列问题。
- 考虑区间动态规划。
- 设立 $f_{i,j}$ 表示 $[i,j]$ 这一段区间的最大加分，我们枚举根 $k$，转移即为：

$$
f_{i,j}=\max(f_{i,j},f_{i,k - 1}\times f_{k + 1, j}+a_i)
$$

- 其中 $a_i$ 为每个点的得分。
- 由于还需要输出前序遍历，故可以在以上转移过程中求出贡献最大的根 $g_{i,j}$。
- 然后递归输出前序遍历即可。
- 时间复杂度 $O(n^3)$，代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

// define
#define re register
#define fi first
#define se second
#define il inline
#define co const
#define ls (u << 1)
#define rs (u << 1 | 1)
#define fup(x, l, r) for (re int x = (l), eNd = (r); x <= eNd; ++ x )
#define fdw(x, r, l) for (re int x = (r), eNd = (l); x >= eNd; -- x )
#define int long long

// typedef
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

// const
const int N = 1e6 + 10, M = 2e6 + 10;
const int INF = 2e9, P = 998244353;
const double eps = 1e-6;

// debug
const bool DeBug = true;
int db_cnt;
il void db() { if (DeBug) puts("--------------"); return; }
il void db(auto a) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << '\n'; return; }
il void db(auto a, auto b) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << '\n'; return; }
il void db(auto a, auto b, auto c) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << '\n'; return; }
il void db(auto a, auto b, auto c, auto d) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << '\n'; return; }
il void db(auto a, auto b, auto c, auto d, auto e) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : " << a << ", " << b << ", " << c << ", " << d << ", " << e << '\n'; return; }
il void db(auto *a, auto len) { if (DeBug) { ++ db_cnt; cout << "-- | t" << db_cnt << " : {"; if (!len) cout << "empty";else { cout << a[1]; for (int i = 2; i <= len; ++ i ) cout << ", " << a[i]; } cout << "}\n"; } return; }
il void db(pair<auto, auto> a) { if (DeBug) ++ db_cnt, cout << "-- | t" << db_cnt << " : <" << a.first << ", " << a.second << ">\n"; return; }

// common functions
il int Max(co int a, co int b) { return a > b ? a : b; }
il int Min(co int a, co int b) { return a < b ? a : b; }
il int read() { re int x = 0; re bool f = true; re char c = getchar(); while (c < 48 || c > 57) { (c == '-') ? f = false : 0; c = getchar(); }while (c > 47 && c < 58) x = (x << 3) + (x << 1) + c - 48, c = getchar(); return f ? x : -x; }
il void write(re auto x) { (x < 0) ? putchar('-'), x = -x : 0; (x > 9) ? write(x / 10) : void(); putchar(x % 10 + 48); return; }
il void wel(co auto x) { write(x), putchar('\n'); return; }
il void wel(co auto x, co int y) { write(x), putchar(' '), write(y), putchar('\n'); return; }
il void wel(co auto x, co int y, co int z) { write(x), putchar(' '), write(y), putchar(' '), write(z), putchar('\n'); return; }
il void wsp(co auto x) { write(x), putchar(' '); return; }

int n, a[1005], f[1005][1005], g[1005][1005];

int dfs (int i, int j) {
	if (i == j) {
		g[i][j] = i;
		return a[i];
	}
	if (f[i][j] != -1) return f[i][j];
	int ans = 0;
	for (int k = i; k <= j; ++ k) {
		if ((k - 1 < i ? 1 : dfs (i, k - 1)) * (k + 1 > j ? 1 : dfs (k + 1, j)) + a[k] > ans) {
			g[i][j] = k;
			ans = (k - 1 < i ? 1 : dfs (i, k - 1)) * (k + 1 > j ? 1 : dfs (k + 1, j)) + a[k];
		}
	}
	return f[i][j] = ans;
}

void qp (int i, int j) {
	if (j < i) return;
	printf("%lld ", g[i][j]);
	if (g[i][j] - 1 >= i) qp (i, g[i][j] - 1);
	if (g[i][j] + 1 <= j) qp (g[i][j] + 1, j);
	return; 
}

signed main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; ++ i) scanf("%lld", a + i);
	memset(f, -1, sizeof(f));
	printf("%lld\n", dfs (1, n));
	qp (1, n);
	return 0;
}


```

---


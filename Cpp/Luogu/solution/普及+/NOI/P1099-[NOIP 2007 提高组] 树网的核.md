# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径称为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)

## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# 题解

## 作者：StudyingFather (赞：296)

在讨论本题的做法前，有必要先分析一下问题的一些特殊性质。

题解区部分题解在性质分析等方面存在一定欠缺，一定程度上可能会影响读者理解做法。

## 分析

先给出一些记号：

- $P(s,t)$：代表树上两点 $s,t$ 之间的路径（的长度）。
- $D(s,t)$：代表树上两点 $s,t$ 之间的路径（的长度），且这条路径是树的最长简单路径（即树的直径）。

另外，为了方便理解，并使得表意清晰，原题中提到的「树的核」均称为「路径」。

以下引理和定理基于**图上所有边权均为正**这一前提推出。

**引理 1**：对于一棵所有边权均为正的树，如果其存在多条直径，则树上必存在一点 $p$，使得所有直径均经过该点（简单来说，所有直径必交于至少一点）。

**证明**：用反证法。

如果存在两条直径 $D(s,t),D(s^\prime,t^\prime)$ 不相交，则 $\exists a \in D(s,t), b \in D(s^\prime,t^\prime)$，且 $\forall p \in P(a,b) - \{a, b\}$，$p \notin D(s, t)$，$p \notin D(s^\prime, t^\prime)$（即，$P(a,b)$ 除了 $a,b$ 两点之外，其他点均不在这两条直径上）。设 $d_1 = \max \{P(s,a), P(a,t)\}$，$d_2 = \max \{P(s^\prime,b), P(b,t^\prime)\}$，易知 $d_1,d_2 \geq \dfrac{1}{2}D(s, t)$，于是 $d_1 + d_2 + P(a,b) > D(s,t)$，即 $d_1,d_2,P(a,b)$ 这三段拼接成了一条比 $D(s,t), D(s^\prime,t^\prime)$ 这两条直径更长的简单路径，出现了矛盾。$\square$

（啥，你说可能有三条直径两两相交，但不交于一点的情况？画图后马上就发现有环了。）

**定理 1**：对于一棵所有边权均为正的树，如果其存在多条直径，则各直径的中点（不一定恰好是某个节点，可能在某条边的内部）是唯一的。

**证明**：还是用反证法。

设树的两条直径分别为 $D(s, t), D(s^\prime,t^\prime)$，它们的中点分别为 $m, m^\prime$，且两个中点不重合。可以推出，$m^\prime \in D(s, t)$（否则由 **引理 1**，两直径必定存在一个交点 $p$。设 $d_1 = \max \{P(s,p), P(p,t)\}$，$d_2 = \max \{P(s^\prime,p), P(p,t^\prime)\}$，则 $d_1, d_2 > \dfrac{1}{2}D(s, t)$，$d_1 + d_2 > D(s,t)$，与 $D(s,t)$ 是直径矛盾）。

于是实际情况大致如下图所示（略去了树上的其他不必要点，不妨设 $m^\prime$ 位于更靠近 $t$ 的一侧）。

![](https://cdn.luogu.com.cn/upload/image_hosting/oaiyl6ql.png)

则 $P(s,s^\prime) = P(s, m^\prime) + P(m^\prime + s^\prime) > \dfrac{1}{2}D(s, t) + \dfrac{1}{2}D(s^\prime, t^\prime) = D(s,t)$，与 $D(s,t)$ 是直径矛盾。$\square$

**引理 2.1**：若两条直径有重叠的部分，则于重叠部分同一端点引出的两条直径的非重叠的部分的长度相等。

**证明**：设两条直径分别为 $D(a, c)$，$D(b, d)$，重叠部分为 $P(s,t)$，如下图所示（$P(s,t)$ 可能是一个点，即 $s = t$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/f587t21u.png)

如果 $P(a,s) \neq P(b,s)$（此时容易得到 $P(c,t) \neq P(d,t)$），则取 $P(a, s)$ 和 $P(b,s)$ 中较长的一条（长度设为 $d_1$），$P(c, t)$ 和 $P(d,t)$ 中较长的一条（长度设为 $d_2$），则由于 $d_1$ 和 $d_2$ 不在同一条直径上（否则推出 $D(a,c) > D(b,d)$，出现矛盾）则 $d_1 + P(s,t) + d_2 > D(a,c)$，出现了矛盾。$\square$

**引理 2.2**：若路径存在不位于直径上的部分，这条路径对应的偏心距一定不会比全部位于直径上的路径的偏心距的**最小值**更小。

**证明**：原命题等价于，对于任意一条不完全位于（或者完全不位于）直径上的路径 $F$，都存在一条完全位于直径上的路径 $F^\prime$，使得 $\operatorname{ECC}(F) \geq \operatorname{ECC}(F^\prime)$。下面是一个构造性的证明。

简单来说，我们采用如下方法构造：对于一条不完全位于（或者完全不位于）直径上的路径 $F$，找到该路径与直径的一个交点 $m$（必要时通过延长 $F$ 来找到交点），然后再证明 $P(m,m)$ 这条路径至少不会比 $F$ 更劣。

沿用 **引理 2.1** 中出现的记号，构建下图（树上的部分节点略去）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9iwxoi6p.png)

注：

1. 加粗的点一定位于树的某条直径上，未加粗的点一定不位于树的任意一条直径上，即 $P(p,v)$ 这条路径不是树的直径。
2. 其实原图有多少条直径对本引理证明没有影响，~~图上保留多条直径只是忘记删了~~。

现在开始讨论。

1. 考虑 $P(p,u)$ 这条路径。距离 $P(p,u)$ 最远的点是哪个点，是 $v$ 吗？因为，$P(b,m) + P(m,v) < P(b,m) + P(m,d) = D(b,d)$，即 $P(m,v) < P(m,d)$，因此距离 $u$ 最远的点，是直径的端点，不是 $v$ 这样一个不在直径上的点。
2. 现在考虑 $P(u,v)$ 这条路径。距离 $P(u,v)$ 最远的点是哪个点，是 $p$ 吗？如果 $P(p,u) \geq P(a,m)$（其余情况同理），则 $D(a,c) = P(a,m) + P(m,c) \leq P(p,u) + P(m,c) < P(p,u) + P(u,m) + P(m,c) = P(p,c)$，与 $D(a,c)$ 是直径矛盾。因此距离 $P(u,v)$ 最远的点，仍然是直径的端点。
3. 最后考虑 $P(m,m)$ 这条路径。距离 $P(m,m)$ 最远的点是哪个点，是 $p$ 或者 $v$ 吗？注意到 $p,v$ 均不在直径上，于是 $P(b,m) + P(m,p) < P(b,m) + P(m,d) = D(b,d)$，即 $P(m,p) < P(m,d)$（这里只举了 $p$ 的情况，$v$ 同理），因此距离 $P(m,m)$ 最远的点，仍然是直径的端点。

（由于直径是树上最长简单路径这一性质，距离上述三条路径最远的点一定不会在从直径上 $m$ 之外的其他点引出的支链上取得，因此这些支链没有画出。）

对于 2 和 3 两种情况，偏心距显然为 $\max\{P(a,m), P(m,c)\}$，对于 1 这种情况，偏心距为 $\max\{P(a,m), P(m,c)\} + P(u,m)$。综上，1 和 2 这两种路径完全不位于（或者不完全位于）直径上的方案，不会比 3 这种完全位于直径上的方案更优。$\square$

因此，虽然原题限制路径只能在直径上取得，但可以忽略这一限制考虑所有满足长度限制的路径，而求得的最小偏心距不变。

**定理 2**：设在所有满足长度限制的路径中，取得最小偏心距的路径得到的偏心距为 $\textrm{minBCC}$，则对于任意一条直径，都存在一条长度不超过 $s$ 的路径 $F$，使得 $\operatorname{BCC}(F) = \mathrm{minBCC}$。

**证明**：

沿用 **引理 2.1** 中出现的记号，构建下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mjb8pfen.png)

注：加粗的点一定位于树的某条直径上，未加粗的点一定不位于树的任意一条直径上，即 $P(p,z)$ 这条路径不是树的直径。

如果我们取 $P(c,y)$ 这条路径，距离该路径最远的点，容易发现不是 $p$。可能是 $z$ 吗？定理 1 告诉我们，$P(t,z) < \dfrac{1}{2}D(a,c)$，从而得到 $P(x,z) < \dfrac{1}{2}D(a,c)$。而 $P(a,y) \geq \dfrac{1}{2} D(a,c)$，因此排除 $z$ 是最远点的可能性。

（$d$ 是最远点时，$P(c,d)$ 也是树的直径，为了不影响 $P(s,t)$ 是直径重合部分这一前提，这里假定 $P(c,d)$ 不是树的直径。）

综上，这条路径的偏心距 $\operatorname{ECC}(P(c,y)) = P(a,y)$。简单比较后容易发现，$P(t,t)$ 这条路径偏心距（容易看出是 $P(a,t)$）一定会更小。

由此得出，当所选路径不包含直径的重合部分时，这条路径一定不是最优路径。

现在考虑所选路径包含直径重合部分的情况。以 $P(s,t)$ 为例，这时候的偏心距 $\operatorname{ECC}(P(s,t)) = \max\{P(m,p), P(s,a), P(t,c)\}$，如果将 $P(s,t)$ 延伸成 $P(s,y)$ 或者 $P(s,q)$，偏心距的表达式没有发生变化（仍然存在 $P(t,c)$ 项）。因此，在所选路径包含直径重合部分的时候，直径的选择对答案没有影响。$\square$

由 **定理 2**，我们不用在树上的每条直径上都找到取得最小偏心距的路径，只需要在其中一条直径上找即可。

## 解法

### 解法一：枚举

先求出树的任意一条直径，然后在直径上枚举路径的端点。 

（由 **引理 2.2**，也可以不用求出树的直径，直接枚举树上的所有路径。）

接下来 DFS 遍历整棵树，按定义求出其他点到路径的距离，从而得到该路径的偏心距。

枚举的时间复杂度 $O(n^2)$，遍历的时间复杂度为 $O(n)$，总时间复杂度为 $O(n^3)$，已经可以通过本题。

### 解法二：双指针优化枚举

注意到，在固定路径的一端 $s$ 的前提下，随着路径长度的增加，偏心距不会变大。

于是可以考虑枚举路径的一端 $s$，用双指针的技巧找到距离 $s$ 最远，且不超过路径长度上限的点 $t$，从而减少候选的最优路径数量。

枚举的过程时间复杂度降到了 $O(n)$，总时间复杂度为 $O(n^2)$。

### 解法三：二分

考虑二分偏心距，将最优化问题变成存在性问题。

定义一端是直径上的点，且只有该点在直径上，其他点都不在直径上的一条链为直径的**支链**。设 $d_i$ 为从 $i$ 点引出的最长支链的长度。

分析偏心距的可能情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/pzx0c11u.png)

以路径 $P(2,4)$ 为例，距离该路径最远的点，可能是 $1$，$5$，$p$。由于 $P(1,5)$ 是直径，$q$ 到 $P(2,4)$ 的距离一定不会比 $1$ 到 $P(2,4)$ 更远，因此在计算偏心距的时候不用考虑 $q$ 点。$1,5$ 是直径的端点，而 $p$ 是路径上的点（除了路径端点）引出的支链的最远点。

归纳一下，设直径上的点分别为 $a_1,a_2,\ldots,a_k$，取的路径为 $P(a_i,a_j)$（$i \leq j$），则所求的偏心距为：$\max \{\max_{i < p < j} d_{a_p}, P(a_1,a_i), P(a_j, a_k)\}$。

$d_i$ 可以在求出直径后通过一次 DFS 求出。在二分偏心距 $e$ 后，先找到直径的两端点 $i$，$j$，使得 $P(a_1,a_i), P(a_j,a_k) \leq e$，再判断路径长度是否超过限制，以及 $\max_{i < p < j} d_{a_p} < e$ 是否满足。如果以上条件均满足，则找到一条可行的路径。

时间复杂度 $O(n \log \sum w)$。可以通过 [P2491](https://www.luogu.com.cn/problem/P2491)。

### 解法四：双指针+前缀和

考虑将解法二的双指针引入解法三。

解法二低效的原因主要在于每次双指针求出最优区间后都要 DFS 一遍，在解法三分析了偏心距的组成后，我们发现没有必要再进行重复的 DFS，只需要在双指针过程中，动态更新 $\max_{i < p < j} d_{a_p}, P(a_1,a_i), P(a_j, a_k)$ 即可。

第一项区间最大值是经典的滑动窗口，可以用单调队列计算，其余两项前缀和即可。

时间复杂度 $O(n)$。

到这里就完了吗？时间复杂度确实到达了下限（输入就需要同样的时间复杂度），但是代码实现还能更简单。

注意到一个性质：$\forall l \in [1,i]$，$d_{a_l} \leq P(a_1, a_i)$，同样地，$\forall l \in [j,k]$，$d_{a_l} \leq P(a_j, a_k)$。

**证明**：由直径是树上最长简单路径的性质，可以得到 $d_{a_j} + P(a_j, a_i) \leq P(a_1,a_i)$，再结合 $P(a_j, a_i) > 0$，从而原命题得证。$\square$

于是我们将偏心距的表达式替换为 $\max \{\max_{1 \leq p \leq k} d_{a_p}, P(a_1,a_i), P(a_j, a_k)\}$，这一过程中我们加入的项都是不大于 $P(a_1,a_i), P(a_j, a_k)$ 的项，在取 $\max$ 后不会影响结果。

$\max_{1 \leq p \leq k} d_{a_p}$ 是定值，因此不必再使用单调队列！实现难度也相应简单了不少。

## 参考实现

把四个解法的代码都贴了出来，不同解法之间使用 `namespace` 进行隔离，可以通过对比阅读以观察优化点。

```cpp
// Problem: P1099 [NOIP2007 提高组] 树网的核
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1099
// Memory Limit: 128 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
struct edge {
  int v, w;
  edge(int v = 0, int w = 0) {
    this->v = v;
    this->w = w;
  }
};
const int maxn = 300000 + 5;
vector<edge> e[maxn];
int dep[maxn], f[maxn], c;
int dia[maxn], cnt, pres[maxn], posts[maxn];
bool vis[maxn];
int n, s;
void dfs(int u, int fa) {
  f[u] = fa;
  for (auto ed : e[u]) {
    if (ed.v == fa || vis[ed.v]) continue;
    dep[ed.v] = dep[u] + ed.w;
    if (dep[ed.v] > dep[c]) c = ed.v;
    dfs(ed.v, u);
  }
}
void get_diameter() {
  dfs(1, 0);
  dep[c] = 0;
  dfs(c, 0);
  for (int u = c; u; u = f[u]) {
    dia[++cnt] = u;
    pres[cnt] = dep[u];
  }
  reverse(dia + 1, dia + cnt + 1);
  reverse(pres + 1, pres + cnt + 1);
  for (int i = cnt; i > 0; i--) posts[i] = pres[cnt] - pres[i];
}
namespace sub1 {
void solve() {
  int minecc = 1 << 30;
  for (int i = 1; i <= cnt; i++)
    for (int j = i; j <= cnt; j++) {
      if (pres[j] - pres[i] <= s) {
        memset(vis, 0, sizeof(vis));
        for (int k = i; k <= j; k++) vis[dia[k]] = true;
        int ecc = 0;
        for (int k = i; k <= j; k++) {
          dep[dia[k]] = 0, c = 0;
          dfs(dia[k], 0);
          ecc = max(ecc, dep[c]);
        }
        minecc = min(minecc, ecc);
      }
    }
  cout << minecc << endl;
}
}  // namespace sub1
namespace sub2 {
void solve() {
  int minecc = 1 << 30;
  int l = 1, r = 1;
  for (; l <= cnt; l++) {
    while (r <= cnt && pres[r + 1] - pres[l] <= s) r++;
    memset(vis, 0, sizeof(vis));
    for (int k = l; k <= r; k++) vis[dia[k]] = 1;
    int ecc = 0;
    for (int k = l; k <= r; k++) {
      dep[dia[k]] = 0, c = 0;
      dfs(dia[k], 0);
      ecc = max(ecc, dep[c]);
    }
    minecc = min(minecc, ecc);
  }
  cout << minecc << endl;
}
}  // namespace sub2
namespace sub3 {
int maxd[maxn];
bool check(int ecc) {
  int l = 1, r = cnt;
  while (l < cnt && pres[l + 1] <= ecc) l++;
  while (r > l && posts[r - 1] <= ecc) r--;
  if (pres[r] - pres[l] > s) return false;
  int d = 0;
  for (int i = l + 1; i < r; i++) d = max(d, maxd[i]);
  return d <= ecc;
}
void solve() {
  for (int i = 1; i <= cnt; i++) vis[dia[i]] = true;
  for (int i = 1; i <= cnt; i++) {
    dep[dia[i]] = 0, c = 0;
    dfs(dia[i], 0);
    maxd[i] = dep[c];
  }
  int l = 0, r = 1 << 30, ans = 0;
  while (l <= r) {
    int mid = (l + r) >> 1;
    if (check(mid))
      ans = mid, r = mid - 1;
    else
      l = mid + 1;
  }
  cout << ans << endl;
}
}  // namespace sub3
namespace sub4 {
void solve() {
  for (int i = 1; i <= cnt; i++) vis[dia[i]] = true;
  int maxd = 0;
  for (int i = 1; i <= cnt; i++) {
    dep[dia[i]] = 0, c = 0;
    dfs(dia[i], 0);
    maxd = max(dep[c], maxd);
  }
  int l = 1, r = 1;
  int minecc = 1 << 30;
  for (; l <= cnt; l++) {
    while (r <= cnt && pres[r + 1] - pres[l] <= s) r++;
    minecc = min(max(maxd, max(pres[l], posts[r])), minecc);
  }
  cout << minecc << endl;
}
}  // namespace sub4
int main() {
  ios::sync_with_stdio(false);
  cin >> n >> s;
  for (int i = 1; i < n; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    e[u].emplace_back(v, w);
    e[v].emplace_back(u, w);
  }
  get_diameter();
  sub4::solve();
  return 0;
}
```

---

## 作者：Mosklia (赞：202)

发布一篇时间复杂度为$O(n)$的题解
***
# $\text{Prev 1}$：读懂题意  
什么树网啊，明明就是普通的**无根树**么……  
一直到偏心距（$\text{E CCF}$（为什么去不掉这个空格？））以前相信大家都能看懂……  
然后题目要求**直径**上的一段路径，使其在**长度**$\leq s$的前提下偏心距最小。  
把题目从$\text{CCF}$语言翻译成现代汉语，就是：  

> 给定一棵带边权无根树，在其直径上求出一段长度不超过$s$的路径$F$，使得离路径距离最远的点到路径的距离最短。  

# $\text{Prev 2}$：直径的定义与性质及其引发的思考  
首先，明白一件事：对于**直径上任意一个点**，到它本身的距离最远的点一定是**直径的某个端点**。理由很简单：如果存在某个点$P$使得直径上的点$A$到其的距离超过点$A$到直径的两端距离的最大值，那么我们可以将直径的一个端点与$A$分离开，并且接上$AP$得到一条比直径更长的路径。但是根据定义，直径应该是整棵树上的最长路径，因此，之前的那条直径是一条*假的直径*。换句话说，假设不成立。  
然后考虑对于直径上的一条路径$F$，有哪些因素会对其偏心距造成影响。    
为了方便描述，
```cpp
using 直径::路径;
```  
首先，肯定会有路径两端点分别到直径两端点对答案造成影响。并且设路径端点、直径端点分别为$A_1,A_2,P_1,P_2$，如果对答案造成影响的是$A_1,P_1$或者$A_2,P_2$，那么$A_1P_1$路径$F$的交点只有$A_1$，$A_2P_2$与路径$F$的交点只有$A_2$。  
那么，路径$F$的长度越长答案一定越优吗？  
~~显然~~不是这样的。  
因为刚刚只考虑了$A_1,A_2$对答案的贡献。但是路径上的其它点对答案其实也有贡献。比如说对于下面的这幅图：  
![](https://cdn.luogu.com.cn/upload/pic/32613.png)  
当$s=18$时答案应该为$3$，但是如果只考虑$A_1,A_2$的贡献，计算结果则会变成$0$。  
从上图不难看出，路径上其它点$Q$对答案的贡献为：**不经过路径上任何其它点所能到达的最远点的距离**。~~不难~~发现实际计算答案时即使把路径端点的这种“贡献”计入总贡献也不会产生影响（因为端点的第一种贡献更大，“掩盖住了”这种贡献）。  
那么如果一棵树有多条直径怎么办呢？没关系，**任选一条**即可。首先，两条直径不可能不相交。把相交的那一部分看成一个点，剩下的直径部分就会**关于这个点对称**。而如果选择的路径包含了分叉点，其偏心距就是恒定的（这个分叉点到直径末端的距离），所以可以任选一条直径求解。  
# $\text{Main}$：解题过程  
本题可以使用邻接矩阵存图，但是为了修改方便，也为了降低空间间复杂度（[$\text{BZOJ}$上这道题的数据规模被增强到了$n \leq 5 \times 10^5$](https://www.lydsy.com/JudgeOnline/problem.php?id=1999)）此处仍然使用邻接表存图。  
```cpp
struct Point { //点
	int dist = 0, head = 0;
	int fa = 0, fa_dist = 0; //以直径一个端点为根，父节点编号及到其距离
	int cur_dist = 0; //后面用来降低时间复杂度
	bool vis = false;
} pt[305];
struct Path { //边
	int end = 0, weight = 0;
	int next = 0;

	Path(int __end = 0, int __cost = 0, int __next = 0) :
		end(__end), weight(__cost), next(__next) {}
} ph[605];
```
```cpp
void set_path(int u, int v, int w) {
	ph[++ptr] = Path(v, w, pt[u].head), pt[u].head = ptr;
	ph[++ptr] = Path(u, w, pt[v].head), pt[v].head = ptr;
}//这个连边函数的写法来自panda_2134大爷
```
接下来是两次$\text{DFS}$求出直径。  
```cpp
void dfs1(int p) { //p表示正在访问哪个点
	if(pt[p].vis) return;
	pt[p].vis = true; //做好标记
	for(int i = pt[p].head; i; i = ph[i].next) {
		int s = ph[i].end;
		if(pt[s].vis) continue;
		pt[s].fa = p,
		pt[s].fa_dist = ph[i].weight,
		pt[s].dist = pt[p].dist + ph[i].weight;
		dfs1(s); //注意要在访问子节点前维护好子节点信息！
	}
}
```
（这是主函数中对应部分）  
```cpp
dfs1(1);
int rt, tempx = 0; //tempx保存已经找到的最远点
for(int i = 1; i <= n; ++i) {
	pt[i].vis = false;
	if(pt[i].dist > pt[tempx].dist)
		tempx = i;
}
rt = tempx, tempx = 0;
for(int i = 1; i <= n; ++i)
	pt[i].dist = pt[i].fa =
	pt[i].fa_dist = 0;

dfs1(rt);
for(int i = 1; i <= n; ++i) {
	pt[i].vis = false;
	if(pt[i].dist > pt[tempx].dist)
		tempx = i;
}
int dist1 = 0, dist2 = 0, tot;
while(pt[tempx].fa) //将直径按照从叶子到根的顺序打印到数组del中
	dist2 += pt[tempx].fa_dist,
	del[++m] = tempx,
	pt[tempx].vis = true,
	tempx = pt[tempx].fa;
pt[rt].vis = true, del[++m] = tempx;
tot = dist2;
```  
然后预处理出每个点**以第二种方式产生的贡献值**（通过一次$DFS$，主函数中的调用过程~~比较简单，~~留给读者自己思考）  
```cpp
int dfs2(int p) {
	pt[p].vis = true;
	int temp = 0;
	for(int i = pt[p].head; i; i = ph[i].next) {
		int s = ph[i].end;
		if(pt[s].vis) continue;
		pt[s].dist = pt[p].dist + ph[i].weight;
		dfs2(s);
		temp = std::max(temp, pt[s].dist);
	}
	return temp;
} 
```
显然，上面的所有过程都是$O(n)$的。那么为什么会有其它的$O(n^2)$的写法呢？  
（**个人认为本题的主要时间复杂度来自以下过程：**）  
接着是枚举所选路径的两个端点并且计算答案。这个过程的时间复杂道是$O(n^2)$，所以，算法总时间复杂度为$O(n^2)$。对于官方数据$n \leq 300$轻松通过。  

## 完结撒花？

可是最后面一部分代码呢？不存在的！**本题解是$O(n)$的题解**，怎么可能有$O(n^2)$的代码？  
仔细看一下写出的$O(n^2)$的代码（没写完的请自觉写完）。这不就是一个线性的动态规划嘛！  
把记录下来的直径序列看成区间，本题变成了**求一个长度不超过$s$的区间，使得其中所有元素的贡献值的最大值最小**。  
这种动态规划想到什么？没错，**单调队列**！  
用单调队列维护一下区间元素的第二种贡献值，第一种贡献可以在左/右端点移动的同时计算。具体写法见以下代码。  
```cpp
std::deque<int> q; //需要#include <deque>（<queue>行）
int ans = 2147483647; //正无穷
for(int i = 1, j = 1; i <= m; dist2 -= pt[del[i]].fa_dist, ++i) {
//dist1是到起始端点的距离，初始化为0
//dist2是到终止端点的距离，初始化为直径长度
	pt[del[i]].cur_dist = dist2; //cur_dist成员表示这个点离终点的距离（没写好，dist最后用来保存第二种贡献值了）
	while(!q.empty() && pt[q.front()].cur_dist - s > pt[del[i]].cur_dist)
		q.pop_front();
	while(j < i && tot - dist1 - dist2 > s)
		dist1 += pt[del[j++]].fa_dist;
	while(!q.empty() && pt[q.back()].dist < pt[del[i]].dist)
		q.pop_back();
	q.push_back(del[i]);
	int temp = std::max(dist1, dist2);
	temp = std::max(temp, pt[q.front()].dist);
	ans = std::min(temp, ans); //状态转移
}
```  
# $\text{End}$：总结
	1、我是真的没看出来那个“中心”的概念有什么用……
    2、即使原始的数据范围很水，也要尽力优化。AC不是我们的终极目标，我们的终极目标是获得经验。

以上就是我要说的全部内容。由于水平所限，如果大家有什么不满意的地方或是什么建议想要提出，欢迎随时私信我！

---

## 作者：天泽龟 (赞：66)

虽然本题题解已有很多，但基本上是$O(N^3)$的暴力或$O(N)$的递推做法，而仍有一种$O(N·logN)$的做法没人提及，但仍可通过$Vijos$上$N=400000$的大数据。

### 没错，他就是二分。

本文将从**二分的正确性，二分的具体实现过程，二分边界**等多个方面详细阐述这种解法，希望您在观看过后也能对**二分答案**有一个更为详细的理解。

顺便，$bzoj$的加强版挂了，我把数据贴到了洛谷可供给大家验题，[戳这。](https://www.luogu.org/problem/U89620)

## $1. ~$二分的正确性/单调性的证明

众所周知，一道题如果能通过二分求解，那么他一定具有**单调性**。

对于本题而言，如果我们对偏心距进行二分答案，在$check$函数的变化，那么很显然的是，当你设定的偏心距越大，可满足的核就会越向**树的中心**集中，$s$自然也就越小了，所以这是满足单调性的。

然而又由于涉及到边界问题，导致其**并非严格单调**，关于这个细节部分等到第三节再来细谈。

## $2.~$二分的具体实现过程/$check$函数

既然我们已经确定了偏心距的范围，那么问题就转化成 **“对于一条直径是否存在一个核，长度小于$s$且偏心距不超过定值$mid$？”**

那我们知道**对于树上的任意点，他到其他点的最大距离即为他到某直径端点的距离**。从而我们可以推断出，某一核的偏心距实质上也就是 **核的端点到直径端点的距离最值**。如果我们设直径两端点为$A,B$，核$F$的两端点为$p,q$，那么以上结论就可以表述为：
$$ECC(F)=\max(dis[p,A],dis[q,B])$$
对于上式，$p,q$是我们要求的**未知范围**，而$A,B$是我们**已知的**直径端点，易想到去通过$A,B$去反推$p,q$。

具体的说，我们可以 ~~以A,B为圆心，以mid为半径画圆~~ 以$A,B$端点分别**向直径内部递推，找到与端点距离不超过$mid$的最远节点，** 此时的两点即为所求的$p,q$。

最终我们判断$p,q$两点距离是否小于$s$，作为我们二分答案的判断标志。**注意，这里不用考虑绝对值！！** 如果距离为负，标志着两点范围已经互相越过去到达了对面，那么这时候在范围内随便取一个点都应该是满足的。

对于具体的操作来说，可以先以直径某一端点（如$A$）为根节点，以此不断向下递归同时记录已走的距离，找到最远满足条件的节点$p$；对于另一端$B$可以直接往上不断跳，找到最远满足节点$q$。

放上$check$的部分代码：
```cpp
ll drop(ll u,ll fa,ll x)  //从高往下掉
{
	for (ll i=fir[u];i;i=e[i].nex)
	if (v[e[i].u]) {
		if (e[i].u==fa) continue;
		l1+=e[i].w; if (l1>x) return u;
		else return drop(e[i].u,u,x);
	}
}

ll up(ll u,ll x)  //从低往上爬
{
	while (u!=A&&l2+w[u]<=x) l2+=w[u],u=f[u][0]; 
	return u;
}

bool check(ll x)
{
	l1=l2=0; p=drop(A,0,x); q=up(B,x); 
	return (d[q]-d[p]<=s);
}

```

算上主函数里的二分，应该是$O(N·logN)$的时间复杂度。

## $3.~$二分的边界判断

所谓二分边界，就是指放在主程序中的$l,r$。普遍的来说，二分答案是可以从$0$取到$INTMAX$的，但对于本题，情况发生了改变。

我们不妨从一个例子引入：

	6 6 
	1 2 5 
	2 3 3 
	3 4 3 
	4 5 5 
	3 6 6 
    错解：5  正解：6
    
~~恩？？为什么会这样呢？~~ 我们来看一下这棵树长什么样：
![](https://cdn.luogu.com.cn/upload/image_hosting/c7ljywx4.png)

当我们取${2,3,4}$作为核的点集时，按上面的做法，据直径端点的距离应为$5$，但很显然答案应该是由$6$号节点造成的$6$！

相信你肯定恍然大悟了：**我们全程没有考虑支链对答案的影响！！**

如果放在考场上，相信如果换做我的一位朋友，他一定会心态崩溃，疯狂怀疑二分的正解性，开始胡乱打暴力骗分，最后惨遭爆炸 ~~（你说的这个朋友到底是不是你自己）（这题好像骗分就能AC）~~。 但是在平常做题，有较多时间的情况下，我们不妨详细探讨一下这个问题。

---

1. 很明显的是，在众多支链中，仅会有**最长支链**对答案造成影响（由偏心距的定义可推出）。当**核的左右两端点 到直径端点的距离**比**最长支链到核的距离**短的时候，偏心距就不受直径的影响了。

由第一章的证明，在达到边界前仍是满足单调性的，于是我们就大胆猜想：**二分边界的上界是树的直径，下界就是最长支链到直径的距离！** 

我们对其证明：

- 上界应该很好理解，当你假定$A$这个端点为树的核，那么他的偏心距显然就是树的直径$D$了。

- 下界我们想要证明的是，会不会出现最长支链到核的距离，小于最长支链到直径距离的情况。

由定义可知，核是直径的一段路径，设最长支链与该直径交于$F$点，最长支链的叶节点为$C$，如果$F\in \text{核的点集}$，那么偏心距必然$\geq FC$。

如果$f\notin \text{核的点集}$，那么设核到F的距离为$d$，由于支链必然小于到直径端点$A,B$的距离，则亦满足：$d+FB\geq d+FC$，，取等条件是$C$是另一直径的端点。上式表明若核不包含$F$，偏心距仍在直径端点处取得，最长支链无贡献。

形象地说，如果以$A$为端点找核的话，偏心距应该满足这么一个样子：
![](https://cdn.luogu.com.cn/upload/image_hosting/lhv7k44i.png)

$FC$即为直径的最长支链，所以单调性也该限制于此。

---

2. 现在我们来想想如何求最长支链。

我们不妨用暴力的思想，考虑每一个不在直径上的点，用$LCA$求出与直径的交点$F$，然后再利用简单的树上两点公式算出最大支链即可。

枚举每个点是$O(N)$的，算LCA是$O(logN)$的，合起来是$O(N·logN)$，依然是在时限内的。

至此，我们算出了二分的下界，整篇题解就结束了。

## $4.$日 后谈
从写这道题，到写完这篇题解，共花了我7个小时（下午4时~晚上11时），主要是期间有很多钻牛角尖的地方，这告诉我们没事千万别死磕题，智商会下降的。

期间一直在想能不能通过类比树的重求出树的中心，然后类似洪水填充向直径扩散求最小偏心距，最终码量有点大，没能实现，期望有后人能帮我验证这一想法可行性。

最后的最后，还是上我丑陋的代码：
```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
#define mp make_pair
#define pr pair<int,int>
#define maxn 500010
#define ll long long
using namespace std;
//1. 搞出一条直径O(N)，可证明上面必有最优核。
//2. 对于不在直径AB的点， 算LCA，比较与直径关系求最长支链 
//3. 二分答案，A,B两端点以mid为半径画圆，标记核范围p,q
//4. 判断p,q距离是否小于s， 

struct ed{
	ll u,nex,w;
}e[maxn*2];
ll n,s,st,fir[maxn];
ll ans,A,B,D,l,r,d[maxn];//树的重心D信息
ll f[maxn][21],dd[maxn],v[maxn],w[maxn],F,minn;//树的中心F信息
ll p,q,l1,l2;

void add(ll x,ll y,ll w)
{
	e[++st].u=y; e[st].nex=fir[x]; e[fir[x]=st].w=w;
	e[++st].u=x; e[st].nex=fir[y]; e[fir[y]=st].w=w;
}

void dfs(ll u,ll fa,ll w)
{
	d[u]=d[fa]+w; if (d[u]>ans) ans=d[u],l=u;
	for (ll i=fir[u],ax=0;i;i=e[i].nex)
	{
		ll v=e[i].u,w=e[i].w;
		if (v==fa) continue;  dfs(v,u,w);
	}
}

void dfsl(ll u,ll fa)
{
	f[u][0]=fa; dd[u]=dd[fa]+1; 
	for (ll i=1;i<=20;i++) f[u][i]=f[f[u][i-1]][i-1];
	for (ll i=fir[u];i;i=e[i].nex) if (e[i].u!=fa) dfsl(e[i].u,u),w[e[i].u]=e[i].w;
}

void Fdis(ll u) { while (u) v[u]=1,u=f[u][0]; }  //标记直径

ll lca(ll x,ll y)
{
	if (dd[x]>dd[y]) swap(x,y);
	for (ll i=20;i>=0;i--)
		if (dd[y]-(1<<i)>=dd[x]) y=f[y][i];
	if (x==y) return x;
	for (ll i=20;i>=0;i--)
		if (f[y][i]!=f[x][i]) y=f[y][i],x=f[x][i];
	return f[x][0];
}

ll dismin()  //找最大支链 
{
	dfsl(A,0); Fdis(B); 
	for (ll i=1;i<=n;i++)
	if (!v[i])
	{
		ll L=lca(i,B); 
		minn=max(minn,d[i]-d[L]);
	}
	return minn;
}

ll drop(ll u,ll fa,ll x)
{
	for (ll i=fir[u];i;i=e[i].nex)
	if (v[e[i].u]) {
		if (e[i].u==fa) continue;
		l1+=e[i].w; if (l1>x) return u;
		else return drop(e[i].u,u,x);
	}
}



ll up(ll u,ll x)
{
	while (u!=A&&l2+w[u]<=x) l2+=w[u],u=f[u][0]; 
	return u;
}

bool check(ll x)
{
	l1=l2=0; p=drop(A,0,x); q=up(B,x); //极短的核心内容
	return (d[q]-d[p]<=s);
}

int main()
{
	scanf("%lld%lld",&n,&s);
	for (ll i=1,x,y,w;i<n;i++)
	scanf("%lld%lld%lld",&x,&y,&w),add(x,y,w);
	dfs(1,0,0); ans=0; r=l; dfs(l,0,0); 
	A=r; B=l; D=ans;//1.
	l=dismin(); r=D; //2. l即为最大支链长
	while (l<r)
	{
		ll mid=(l+r)/2; 
		if (check(mid)) r=mid; else l=mid+1;
	}
	printf("%lld\n",l);
} 

```

写这东西真心累，~~字数我觉得都能上洛谷日报~~。

---

## 作者：qhr2023 (赞：13)

## solution

题面写得很晦涩，就是给定一个无根树，找任意直径上一条长度不超过 $s$ 的路径，使图上最远的点到这条路径的距离最小。

这里不需要找直径，直接枚举路径即可，若路径存在不位于直径上的部分，这条路径对应的偏心距一定不优，第一篇题解有证明。

先求出图上任意两点的距离，这里用了 Floyd，然后枚举路径 $i$ 到 $j$，对于每对 $(i, j)$，再枚举结点 $k$ 找偏心距。考虑求偏心距。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)

偏心距的重点在求点到路径的距离。拿样例举例，此时的 $i$ 和 $j$ 分别是 $D$ 和 $G$，枚举 $k$ 时枚举到了 $B$，此时 $B$ 到这条路径的距离是路径 ```BF``` 的长度，而 $B$ 到 $D$ 的路径 ```BFED```，加上 $B$ 到 $G$ 的路径 ```BFG```，再减去 $D$ 到 $G$ 的路径 ```GFED``` 正好是 $2$ 个 ```BF```，所以 $B$ 到路径两端点的距离和减去路径长度即 $B$ 到路径距离的二倍。

设 $f_{i, j}$ 表示 $i$ 到 $j$ 的距离，路径 $(i, j)$ 对应的偏心距就是 $\frac{f_{i, k}+f_{j, k}-f{i, j}}{2}$ 的最大值，答案就是每条路径对应偏心距的最小值。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, s, f[305][305], ans=1e9;
int main () {
	cin >> n >> s;
	memset(f, 0x3f, sizeof f);
	for (int i=1, u, v, w; i<n; ++i)
		cin >> u >> v >> w,
		f[u][v]=f[v][u]=w;
	for (int i=1; i<=n; ++i)	
		f[i][i]=0;
	for (int k=1; k<=n; ++k)
		for (int i=1; i<=n; ++i)
			for (int j=1; j<=n; ++j)
				f[i][j]=min(f[i][j], f[i][k]+f[k][j]);
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=n; ++j)
			if (f[i][j]<=s) {
				int mx=0;
				for (int k=1; k<=n; ++k)	
					mx=max(mx, (f[i][k]+f[j][k]-f[i][j])/2);
				ans=min(mx, ans);
			}
	cout << ans;
	return 0;
}
```

---

## 作者：Firsry (赞：6)

# 题解 P1099 【树网的核】

## 一、题意

> 设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为**无根树**），每条边都有**正整数的权**，我们称 $T$ 为树网（`treenetwork`）。

1. 其实是一个无根树，从哪里开始找树的直径都可以。
2. 保证边权为正整数，这个极其关键，在后面的推论中有用到。
3. 关于 $(V,E,W)$ 其实并不重要，只是为了严谨性。

> 路径：树网中任何两结点 $a$，$b$ 都存在**唯一的一条简单路径**，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上**各边长度之和**。我们称 $d(a, b)$ 为 $a, b$ 两结点间的距离。$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

1. 存在唯一简单路径，也就是说一棵树非常标准，不会有重边。而只有一条路，方便了求最后的偏心距。
2. 对于 $d(a,b)$ 比较简单，在后面其他的定义中看得懂就行了。
3. $D(v,P)$ 这个比较毒瘤，指的是一条路径 $P$ 上各个节点 $u$ 到某一节点 $v$ 的距离的最小值。也就是说把这条路径看作一个整体（分量），$D(v,P)$ 其实就是 $v$ 到这个节点的最短距离。

> 树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

1. 这句话也就是树的直径的定义（他不会希望不知道算法的 OIer 能够现场推出树的直径的算法吧？）。
2. 那个证明挺有意思，在求出树网的核的时候有用。

> 偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即
>
> $$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$
>
> 对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

1. 树网的核首先是一段路径，他有他的长度，也有它包含的节点。
2. 这段路径在树网的直径上，长度小于等于要求的长度 $s$。把他的节点看成一个集合，然后看树上其他的节点到这段路的最短距离的最大值。树的直径的不同子路可能会有不同的 $\mathrm{ECC}$，而 `core` 就是在不同的路径中让 $\mathrm{ECC}$ 最小的那么 一条 / 多条 / 某个节点。
3. 最小偏心距唯一可以保证唯一，因为如果不唯一，更小的那一个所在路径就是核，而其他的就不是。

## 二、推论

> stO StudyingFather %%%%

这部分题解主要是针对 StudyingFather 题解当中 **分析** 部分的 **定理引理证明** 的更加通俗化的描述，也会有不同的证明方法，建议也去他的题解中看看数学语言描述的证明。
如果有看不懂或者发现证明不严谨的，欢迎在评论区发言，本蒟蒻会及时更正。

为了简洁以及易懂，以下证明过程中用的是简化的树，只画出了关键的路径以及节点。
下文中 $AB$ 的形式代表 $A$ 到 $B$ 之间的路径的长度，类似于线段的表示方式。图片中也有比较简洁的证明过程，可以考虑优先看图。
大部分的证明都是通过反证法，而反证的一个重点就是推出原本设定的直径在该情况下并不是真正的直径，从而推出矛盾。推荐同学们自己推一推。

> **引理 1**：对于一棵所有边权均为正的树，如果其存在多条直径，则树上必存在一点 *p*，使得所有直径均经过该点（简单来说，所有直径必交于至少一点）。

![](https://cdn.luogu.com.cn/upload/image_hosting/icn4c8sj.png)

这个还是很显然的，即使 $C_1$、$C_2$ 是两条直径各自的中点（当然这个后面我们也会证明处理其不可能），也有在正权树上 $C_1$ $C_2$ 之间的距离可以保证比所谓 “直径” 更长，也就出现了矛盾，反证法证明成立。

> **定理 1**：对于一棵所有边权均为正的树，如果其存在多条直径，则各直径的中点（不一定恰好是某个节点，可能在某条边的内部）是唯一的。

![](https://cdn.luogu.com.cn/upload/image_hosting/mjr89r04.png)

这个证明建立在 引理 1 的基础上。
首先有两条直径，假设为 $A_1B_1$ 和 $A_2B_2$，则 $A_1B_1$ 的长度和 $A_2B_2$ 的长度是一致的，否则仅有长度较长的那一条直径。
其次有交点 $C$，则有在两条直径上找到一条形如 $A_1-C-A_2$ 的路径。如果说中点不重合而交点位置是重合的，则有在两直径交点的两侧长度是不同的。如图所示，蓝笔标注的中点偏向于一侧。
然后通过 $C$，访问两个比直径一半更长的部分，会得到一个比 $A_1B_1$ 更长的路径，那么直径的假设就被推翻了。

> **引理 2.1**：若两条直径有重叠的部分，则于重叠部分同一端点引出的两条直径的非重叠的部分的长度相等。

![](https://cdn.luogu.com.cn/upload/image_hosting/3xgfr0xh.png)

这个的证明和 定理 1 的证明非常相似。如果说 $C_2B_1>C_2B_2$，则有 $A_1C_1<A_2C_1$，那么就可以找到一条 $A_2-C_1-C_2-B_1$ 比直径 $A_1B_1$ 更长的路径，而这个推翻了直径的假设。

>  **引理 2.2**：若路径存在不位于直径上的部分，这条路径对应的偏心距一定不会比全部位于直径上的路径的偏心距的**最小值**更小。

![](https://cdn.luogu.com.cn/upload/image_hosting/7gakkckx.png)

这一段证明还是写的比较详细的，而从这个定理开始就不是很好证明了。
这里用的不是反证法，而是找到了一个存在。其中只有蓝色的部分是直径，红色部分是一个 $ECC$ 来源的可能。如果说 $f_1f_2$ 并不是直径的一部分，则有 $C-f_2-f_1$ 的路径比 $C-B$ 的路径更短。$ECC$ 来源于直径，那么不在直径上的部分并不会影响结果，所以有 $C$ 点和 $st$ 一整段路径的作用是一致的。

这里是一个经典的错误，也是我最开始只有 70 分的原因：贪心的只去找直径上的距离其实是有问题的。如果说 $s>diameter$ 则有整个直径是一个核，这个时候用贪心的策略 $\operatorname{ECC}=0$，处理方法在解法部分讲解。  

> **定理 2**：设在所有满足长度限制的路径中，取得最小偏心距的路径得到的偏心距为 $\operatorname{minECC}$，则对于任意一条直径，都存在一条长度不超过 $s$ 的路径 $F$，使得 $\operatorname{ECC}(F)$=$\operatorname{minECC}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4ebxtfhm.png)

定理 2 推出之后，可以不用处理多条直径，因为对于任意一条直径都有答案。
首先是这里有多条直径，由 引理 2.2 可以得到答案来源于直径上，而包含直径的重合部分一定会是更好的情况，也就是说没有哪一条直径会有单独的更好的选择，所以只用处理一条直径了。

## 三、代码

对于贪心策略错误的问题，我们找到每个节点不经过当前找到的直径上节点能够到达的最远的距离。
方法其实就是标记直径上的节点“已访问”，然后通过跑一遍深搜，保存在 $dia$ 数组里面。

这里借鉴的是小蓝书的最优解。其他部分在其他题解中有详细的讲解，这里就不赘述了。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 300 + 5;
struct Edge {
	int to, weight;
	Edge(int to = 0, int weight = 0) {
		this->to = to;
		this->weight = weight;
	}
};
int n, s;
vector<Edge> e[MAXN];

int c;
int dep[MAXN], f[MAXN];

int cnt;
int dia[MAXN], pres[MAXN], posts[MAXN];
bool vis[MAXN];

void in() {
	int from, to, weight;
	scanf("%d%d", &n, &s);
	for (int i = 1; i < n; i++) {
		scanf("%d%d%d", &from, &to, &weight);
		e[from].emplace_back(to, weight);
		e[to].emplace_back(from, weight);
	}
	return;
}
void dfs(int from, int fa) {
	f[from] = fa;
	for (auto edge : e[from]) {
		if (edge.to == fa || vis[edge.to])
			continue;
		dep[edge.to] = dep[from] + edge.weight;
		if (dep[edge.to] > dep[c]) 
			c = edge.to;
		dfs(edge.to, from);
	}
	return;
}
void get_diameter() {
	dfs(1, 0);
	dep[c] = 0;
	dfs(c, 0);
	for (int from = c; from; from = f[from]) {
		cnt++;
		dia[cnt] = from;
		pres[cnt] = dep[from];
	}
	reverse(dia + 1, dia + cnt + 1);
	reverse(pres + 1, pres + cnt + 1);
	for (int i = cnt; i > 0; i--)
		posts[i] = pres[cnt] - pres[i];
	return;
}
void solve() {
	for (int i = 1; i <= cnt; i++)
		vis[dia[i]] = true;
	int maxD = 0;
	for (int i = 1; i <= cnt; i++) {
		dep[dia[i]] = 0, c = 0;
		dfs(dia[i], 0);
		maxD = max(dep[c], maxD);
	}
	int minECC = 1 << 30;
	for (int l = 1, r = 1; l <= cnt; l++) {
		while (r <= cnt && pres[r + 1] - pres[l] <= s)
			r++;
		minECC = min(max(maxD, max(pres[l], posts[r])), minECC);
	}
	cout << minECC;
	return;
}

int main() {
	in();
	get_diameter();
	solve();
	return 0;
}
```

---

## 作者：tangzirui1016 (赞：4)

发现 $O(n^3)$ 的复杂度可以通过。

我的思路：枚举路径上的两个端点，然后以这条简单路径上的点为当前子树的根节点 $x$，然后搜索，注意，如果搜到了这条路径上的某一个点，这个分支就需要停下。找到 $ECC(x)$，取这条路径上最大的 $ECC(x)$ 作为这条路径的答案，找到所有路径中的最小值，时间复杂度 $O(n^3)$。 

如何找到这条路径上的点呢？我是先记录一个以节点 $1$ 为树的根节点，该节点的深度，同时记录该节点的父节点。对于两个路径的端点 $x,y$，向上一直走，直到找到 $x,y$ 的最近公共祖先，经过的点都是该路径上的点。
 
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int id,len;
};
vector<node>v[305];
int n,s,root,dis[305][305],c[305],ft[305],ans,ANS=1e9;
bool f[305];
void Dis(int x,int fa){//计算两点之间的距离
	for(auto i:v[x]){
		int to=i.id,e=i.len;
		if(to==fa) continue; 
		dis[root][to]=dis[root][x]+e;
		Dis(to,x);
	}
}
void make_c(int x,int fa){ //计算深度
	for(auto i:v[x]){
		int to=i.id;
		if(to==fa) continue;
		c[to]=c[x]+1;
		ft[to]=x;
		make_c(to,x);
	}
}
void make_f(int x,int y){ //给路径上的每一个点打上标记
	f[x]=f[y]=1;
	while(x!=y){
		if(c[x]>=c[y]) f[x=ft[x]]=1;
		else f[y=ft[y]]=1;
	}
}
void dfs(int x,int fa,int len){ //找到当前路径的ECC的最大值
	ans=max(ans,len);
	for(auto i:v[x]){
		int to=i.id;
		if(to==fa||f[to]) continue;
		dfs(to,x,len+i.len);
	}
}
int main(){
	cin>>n>>s;
	for(int i=1,x,y,z;i<n;i++){
		cin>>x>>y>>z;
		v[x].push_back({y,z});
		v[y].push_back({x,z});
	}
	for(int i=1;i<=n;i++){
		root=i;
		Dis(root,0);
	}
	make_c(1,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(dis[i][j]>s) continue;
			ans=0;
			memset(f,0,sizeof(f));
			make_f(i,j);
			for(int i=1;i<=n;i++){
				if(f[i]) dfs(i,0,0);
			}
			ANS=min(ANS,ans);
		}
	}
	cout<<ANS;
	return 0;
}
```

---

## 作者：JXR_Kalcium (赞：3)

## 题目大意

给定一棵有 $n$ 个结点的无根树，在树上找一条路径，使得路径长不超过 $s$ 且**任意一点到这条路径的距离最大值最小**，数据范围 $n\le 300$。

## 解题思路

这一题可以使用**最短路**。注意到 $n\le 300$，所以直接跑一遍 Floyd 即可求出任意两点的距离。然后再枚举路径，用两层循环 $i,j$ 枚举路径的两个端点，再用一层循环枚举剩下的“任意一点”$k$。对于 $k$ 到路径 $i\rightarrow j$ 的距离可推导公式，若 $k\rightarrow w$ 与 $i\rightarrow j$ 交于点 $w$，则

$$
\begin{aligned}
iw+kw+jw+kw&=ik+jk\\
ij+2kw&=ik+jk\\
kw&=\frac{ik+jk-ij}{2}
\end{aligned}
$$

最后在 $k$ 的循环里求 $p=\max(kw)$，答案即为 $\min(p)$。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define endl putchar(10)
#define spc putchar(32)
#define R register
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(x) cerr << #x << " = " << x, endl
#endif

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    static ll sta[41]; ll top=0;
    if(x<0) putchar('-'), x=-x;
    do sta[top++]=x%10, x/=10; while(x);
    while(top) putchar(sta[--top]+48);
}

ll n,s,a[301][301],x,y,z,mx,ans=1e18;

int main()
{
    n=read(); s=read();

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=n; ++j)
        {
            if(i!=j) a[i][j]=1e18;
        }
    }

    for(R int i=1; i<n; ++i)
    {
        x=read(); y=read(); z=read();
        a[x][y]=z; a[y][x]=z;
    }

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=n; ++j)
        {
            for(R int k=1; k<=n; ++k)
            {
                if(i!=j && i!=k && j!=k)
                a[j][k]=min(a[j][k],a[j][i]+a[i][k]), a[k][j]=a[j][k];
            }
        }
    }

    for(R int i=1; i<=n; ++i)
    {
        for(R int j=1; j<=n; ++j)
        {
            if(a[i][j]<=s)
            {
                mx=0;
                for(R int k=1; k<=n; ++k)
                mx=max(mx,a[i][k]+a[j][k]-a[i][j]>>1);
                ans=min(ans,mx); 
            }
        }
    }

    write(ans);
    return 0;
}
```

---

## 作者：hairenxu (赞：2)

# 前言
这篇题解将会解释一种贪心的方法，至于时间复杂度，希望各位巨佬能提供证明。
# 题意
给定一颗无根树，在其直径上选取一段长度不超过 $s$ 路径 $F$，使得离此路径最远的节点的距离最短。
# 分析
题意就是这么短，但题目却讲了很长。尤其是，它专门定义了树网的中心这个概念，可在定义完后却再也没有出现，那它的意义究竟是什么呢？这就是我们分析的突破点！

看一下题干中的例子，发现在 $s$ 较小时，其选择了离中心 $W$ 最近的点 $F$，而在 $s$ 足够大时，其选择了通过中心的一条路径。

这给我们一个启发：中心及中心所在的最短的那一条路径是要优先选择的。

下面，让我们来证明一下。首先，从最简单的情况开始。如果中心 $W$ 正好**是**某个结点而 $s$ 为零，是否就应当选取 $W$ 作为 $F$，答案是肯定的。如果我们不选 $W$，那必然会有一端与 $F$ 的距离大于直径的一半，而又因为 $W$ 在直径上，所以没有任何一点与 $W$ 的距离会大于直径的一半，故而选取 $W$ 就是最优解。接着，如果 $W$ **不在**结点上，而 $s$ 仍为零，我们应当选取离中心最近的点（显然这个点会在直径上）。假设中心与其最近的结点距离为 $d$，直径长为 $R$，则，偏心距 $ECC = d + \frac{R}{2}$。显然，离其最远的结点必然在直径上。若不选它，直径上肯定会有一端使得 $ECC$ 更大。继续扩展，如果 $s > 0$ 且可以覆盖中心所在的最短的那一条路径但又不足以继续覆盖其他路径，我们应当选取这条路径。假设先选取一个点，由上可知，选离中心最近的点，然后扩展，自然应向中心扩展，因为这是一棵树，如果不向另一端扩展的话，$ECC$ 绝不会减小。

现在，我们已经确定了开始的几个点应该怎么选，而且，有着明显的贪心思想。在最后一步中，我们采取了扩展的方法，自然想到是否可以继续扩展。有一个很容易想的贪心策略是，哪个结点离路径最远，就往哪里扩展。这个策略是对的，因为这是一棵树，如果你不向那里扩展，那距离就再也不会减少了，而且，这样的点是唯一的。

至此，算法已经完成，接下来开始实现。
# 代码
这是一颗无根树，我们也不需要让它有边，所以用 vector 直接建双向边即可。

在代码实现中，我们需要找直径，找中心，找离路径最远的结点，这些都离不开结点之间的距离，所以我们直接用 $n$ 次 DFS 找到全源最短路存进数组即可。

直径很好找，两层循环搜一遍任意一个结点到另一个结点的距离不断取最大值并记录两个结点即可。一个重点在于找中心的过程。想法很好想，从两端开始不断向中心靠拢。我采用的是不断迭代的方法，但这有一个必须注意的问题——零边权的存在。这可能会让你的迭代死循环或提前退出。如果你第十三个测试点错误，可以检查一下是否是这个原因。

在得到中心 $W$ 后，可以判断一下 $s$ 是否能覆盖中心所在的最短的那一条路径，如果不能，那可以直接输出了。还要判断一下中心是否在结点上，如果在，直接进入扩展程序，如果不在，先扩展中心所在的最短的那一条路径，再进入扩展程序。

值得注意的是，如果采用这种贪心的想法，一定要要求扩展的路径在直径上，否则只能拿 44 分。至于原因，希望各位大佬解释一下。这样，就会牵出另一个问题，怎么标记直径？同机房大佬给出了一个方法：先随意选取一条直径的两端，记为 $x$ 和 $y$，接着，遍历结点，若当前节点与 $x$ 的距离，当前节点与 $y$ 的距离之和为直径，那么，当前结点在直径上。

最后，就是扩展过程了。在得到中心后，我们不是要先进行一次可能的扩展么，我们将一端记为 $l$ 另一端记为 $r$。如果当时不扩展，那么令 $l = r = W$。然后遍历每个结点，取其距 $l$ 的距离与距 $r$ 的距离并取最小值记录在一个数组里，数组的下标即为结点编号。随后，遍历其并取最大值，记录其结点编号。然后，对与 $l$ 连接的结点进行一次遍历，如果有一个结点与 $l$ 的距离小于最大值且 $s$ 大于其边权，那么扩展它，$l$ 变为它，$s$ 减去边权。$r$ 端同理。如果两端遍历完后，没有找到可扩展的路径，那么可以退出循环返回答案了。如果找到了，那么进入下一轮循环，直到 $s$ 变为零。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>G[310];
int dis[310][310],ECC[310],vis[310];//vis数组标记其是否在直径上
int n,s,zj,zjx,zjy,l,r;//zj是直径,zjx,zjy是直径两端,l,r是扩展路径两端
double bzj;
void dfs(int x,int u,int fa,int d){
	dis[x][u]=d;
	for(int i=0;i<G[u].size();i++){
		if(G[u][i]!=fa)dfs(x,G[u][i],u,d+dis[u][G[u][i]]);
	}
}
int solve(){
	int ans=0;
	while(s){
		int maxx=0,maxxid,ok=0;
		for(int i=1;i<=n;i++){
			if(ECC[i]>maxx){maxx=ECC[i];maxxid=i;}
		}
		for(int i=0;i<G[l].size();i++){
			if(dis[G[l][i]][maxxid]<maxx and dis[l][G[l][i]]<=s and vis[G[l][i]]){
				s-=dis[l][G[l][i]];
				l=G[l][i];
				ok=1;
				for(int j=1;j<=n;j++)ECC[j]=min(ECC[j],dis[l][j]);
			}
		}
		for(int i=0;i<G[r].size();i++){
			if(dis[G[r][i]][maxxid]<maxx and dis[r][G[r][i]]<=s and vis[G[r][i]]){
				s-=dis[r][G[r][i]];
				r=G[r][i];
				ok=1;
				for(int j=1;j<=n;j++)ECC[j]=min(ECC[j],dis[r][j]);
			}
		}
		if(!ok)return maxx;
	}
	for(int i=1;i<=n;i++)ans=max(ans,ECC[i]);
	return ans;
}
int main(){
	cin>>n>>s;
	for(int i=1;i<n;i++){
		int u,v,d;
		cin>>u>>v>>d;
		G[u].push_back(v);
		G[v].push_back(u);
		dis[u][v]=d;
		dis[v][u]=d;
	}
	for(int i=1;i<=n;i++)dfs(i,i,i,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(dis[i][j]>zj){zj=dis[i][j];zjx=i;zjy=j;}
		}
	}	
	for(int i=1;i<=n;i++){
		if(dis[i][zjx]+dis[i][zjy]==zj)vis[i]=1;
	}
	bzj=zj*0.5;
	int d,id,nzjx,temp;
	while(1){
    //迭代找中心
		for(int i=0;i<G[zjx].size();i++){
			nzjx=G[zjx][i];
			if(vis[nzjx] && nzjx!=temp){
				d=dis[zjx][nzjx];
				bzj-=d;
				break;
			}
		}
		if(bzj<=0)break;
		temp=zjx;
		zjx=nzjx;
	}

	if(bzj!=0){
		l=zjx;r=nzjx;
		if(s<dis[zjx][nzjx]){
			cout<<(int)(zj*0.5+min(-bzj,d+bzj));
			return 0;
		}
		s-=dis[zjx][nzjx];
	}
	else l=r=nzjx;
	for(int i=1;i<=n;i++)ECC[i]=dis[i][l];
	for(int i=1;i<=n;i++)ECC[i]=min(ECC[i],dis[i][r]);
	cout<<solve();
	return 0;
} 
```
# 结语
其实，我认为这个代码时间复杂度很劣，但运行速度又不慢，一共只用了 50ms。希望各位大佬能帮忙算一下时间复杂度。

水平有限，如有错误，望您斧正。

---

## 作者：Peiyuan (赞：2)

## 题目大意
给定一棵带边权无根树，在任意直径上找出一段长度不超过 $s$ 的路径 F，使得离路径距离最远的点到路径的距离（偏心距）最短。
## 思路
以任意点作为根，跑两遍dfs算出树上的一条直径。
1. 在直径上滑动长度不超过 $s$ 的窗口（F），利用双指针枚举，计算直径两端点的贡献；
2. 对于每个直径路径上的节点再 dfs，计算所有不在直径上的点到路径 F 的最远距离。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const ll N=5e5+5;
struct edge{ll v,w;};
vector<edge>g[N];
ll n,m,s,fa[N],dis[N],ans=1e18;
bool vis[N];
void dfs(ll u){
	for(auto e:g[u]){
		ll v=e.v,w=e.w;
		if(vis[v]||fa[u]==v)continue;
		fa[v]=u;
		dis[v]=dis[u]+w;
		dfs(v);
	}
}
int main(){
	cin>>n>>s;
	for(ll i=1,u,v,w;i<n;i++){
		cin>>u>>v>>w;
		g[u].emplace_back(edge{v,w});
		g[v].emplace_back(edge{u,w});
	}
	dis[1]=0;dfs(1);
	ll x=1,y=1;
	for(ll i=1;i<=n;i++)if(dis[i]>dis[x])x=i;
	memset(fa,0,sizeof fa);
	dis[x]=0;dfs(x);
	for(ll i=1;i<=n;i++)if(dis[i]>dis[y])y=i;
	for(ll i=y,j=y;i;i=fa[i]){
		while(fa[j]&&dis[i]-dis[fa[j]]<=s)j=fa[j];
		ans=min(ans,max(dis[j],dis[y]-dis[i]));
	}
	for(ll i=y;i;i=fa[i])vis[i]=1;
	for(ll i=y;i;i=fa[i])dis[i]=0,dfs(i);
	for(ll i=1;i<=n;i++)ans=max(ans,dis[i]);
	cout<<ans<<'\n';
	return 0;    
}
```

---

## 作者：時空 (赞：2)

[In Luogu](https://www.luogu.com.cn/problem/P1099)

前言：本篇题解并不会对结论做证明，第一篇题解已经有极其严谨的证明了。笔者在此不再赘述。本篇题解主要是分享一下是怎么一步步优化算法的。

题目写的有些繁琐，简化一下题意：

>给定一个无根树，找任意直径上一条长度不超过 $s$ 的路径，使图上最远的点到这条路径的距离最小。求出这个最小距离。

下文中，对于直径上某个点 $x$，它的子树中与 $x$ 距离最远的点 $p$，定义 $x$ 到 $p$ 这条链为 $d_x$。同时，记 $P(x,y)$ 表示 $x,y$ 间的简单路径的长度。

直接暴力是很困难的，复杂度也很高，考虑观察一下性质。

考虑先找到树上的任意一条直径 $D$。那么容易证明，最优的核 $F$ 必定在 $D$ 上。

那么把直径上的所有点存起来，记其的个数为 $k$，分别为 $D_1,D_2,\cdots D_k$，枚举其中的某个路径作为 $F$，判断是否合法（即路径是否 $\le s$）。按照题目要求计算最优答案即可。这样时间复杂度 $\mathcal{O(n^3)}$。已经可以通过本题。

我们当然不满足于此。思考给定的限制 $s$ 可以帮助我们什么。

注意到对于一个合法 $F$，如果它的长度变大且仍然合法，那么答案不会更劣。那么考虑让 $F$ 的长度尽量大后再去判断其是否合法。

具体地，可以使用双指针。每次固定左端点，右移右端点使得路径的长度尽量大但合法，再计算答案就好。时间复杂度降为 $\mathcal{O(n^2)}$。

继续优化。考虑二分最终的答案 $R$。

注意到对于直径上的某个路径 $D_x,D_y(1 \le x \le y \le k)$，它能够作为 $F$ 当且仅当满足 $p \in [x,y]$ 的 $d_p$ 的最大值 $\le R$ 且 $P(D_x,D_y)\le s$。

由于 $D$ 为直径，那么 $d_x$ 即为 $P(D_1,D_x)$，$d_y$ 即为 $P(D_y,D_k)$，很好理解。

那么从前往后找到第一个满足 $P(D_1,D_l) > R$ 的 $l$，从后往前找到第一个满足 $P(D_r,D_k) > R$ 的 $r$。若此时 $l > r$，满足要求。若 $l \le r$，检查 $P(D_l,D_r) \le s$ 且 $p \in [l,r]$ 的 $d_p$ 的最大值 $\le R$ 即可。时间复杂度 $\mathcal{O(n \log \sum w)}$。

```cpp
#include <bits/stdc++.h>

#define FstIO ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define pii pair <ll, ll>
#define pb push_back
#define mem(a, v) memset(a, v, sizeof a)

using namespace std;

using ll = long long;
using ull = unsigned long long;
using ld = long double;

const ll N = 3e5 + 5, M = 1e4;
const ld eps = 1e-6;

ll n, s;

vector <pii> G[N];
vector <ll> D;

// dis
ll dis[N], rt, rt2, mxp; 
void dfs(ll u, ll fa)
{
	for (auto x : G[u])
	{
		ll ver = x.first, w = x.second;
		if (ver == fa) continue;
		dis[ver] = dis[u] + w;
		dfs(ver, u);
	}
}
// mxd
ll mxd[N], mxr; bool vis[N];
void dfs3(ll u, ll wc)
{
	vis[u] = true; mxr = max(mxr, wc);
	for (auto x : G[u])
	{
		ll ver = x.first, w = x.second;
		if (vis[ver]) continue;
		dfs3(ver, wc + w);
	}
}
void Getmxd()
{
	for (ll i = 0; i < D.size(); ++ i ) vis[D[i]] = true;
	for (ll i = 0; i < D.size(); ++ i )
	{
		mxr = 0; dfs3(D[i], 0); mxd[i] = mxr;
	} 
}

// tree's D
bool chkt = false;
void dfs2(ll u, ll fa, ll target)
{
	if (chkt) return ;
	D.pb(u); // cout << u << ' ' << fa << ' ' << chkt << '\n';
	if (u == target) return chkt = true, void();
	
	for (auto x : G[u])
	{
		ll ver = x.first;
		if (ver == fa) continue;
		dfs2(ver, u, target);
	}
	if (!chkt) D.pop_back();
}

// solve
ll pre[N], suf[N];
map <pii, ll> Mp;

bool chk(ll x)
{
	ll l = 0, r = D.size() - 1;
	while (l <= r && pre[l + 1] <= x) ++ l;
	while (r >= l && suf[r - 1] <= x) -- r;
	if (l > r) return true;
	if (pre[r] - pre[l] > s) return false;
	for (ll i = l + 1; i < r; ++ i )
		if (mxd[i] > x) return false;
	return true;
}

signed main()
{
	FstIO;
	
	cin >> n >> s;
	for (ll i = 1; i < n; ++ i )
	{
		ll u, v, w; cin >> u >> v >> w;
		G[u].pb({v, w}), G[v].pb({u, w});
		Mp[{u, v}] = Mp[{v, u}] = w;
	}
	dfs(1, 0);
	for (ll i = 1; i <= n; ++ i )
	{
		if (mxp < dis[i]) mxp = dis[i], rt = i; 
		dis[i] = 0;
	}
	dfs(rt, 0); mxp = 0;
	for (ll i = 1; i <= n; ++ i )
	{
		if (mxp < dis[i]) mxp = dis[i], rt2 = i;
	}
	
	for (ll i = 1; i < D.size(); ++ i )
	{
		ll w = Mp[{D[i - 1], D[i]}];
		pre[i] = pre[i - 1] + w;
	}
	for (ll i = D.size() - 2; i; -- i )
	{
		ll w = Mp[{D[i + 1], D[i]}];
		suf[i] = suf[i + 1] + w;
	}
	Getmxd();
	
	ll l = 0, r = 1e18, R = 1e18;
	while (l <= r)
	{
		ll mid = l + r >> 1;
		if (chk(mid)) r = mid - 1, R = mid;
		else l = mid + 1;
	}
	cout << R << '\n';
}
```

---

## 作者：Hyvial (赞：1)

## 思路
树的直径有如下性质：**对于树上的任意节点 $x$，满足距离 $x$，最远的点位于直径的两端点之一**。

令直径上的点为 $u_{1..t}$，$d_x$ 表示不经过直径能达到的最远的距离。

为了使偏心距更小，显然核的两端点距离在不超过 s 的情况下越长越好，所以可以得出，核在直径上。

可以枚举在直径上（$u_1$ 到 $u_t$）的核的两端点 $u_i$ 和 $u_j$（$i < j$，$\operatorname{dist}(i, j) \le s$），对于这一个核，偏心距就是 $\max(\max_{i \le k \le j}{d_{u_k}}, \operatorname{dist}(u_1, u_j), \operatorname{dist}(u_i, u_t))$。

因为只需要求 距离 $d_{u_1}$ 和 $d_{u_t}$ 的距离，所以可以使用前缀/后缀和，记录直径上每一个点距离两段的距离。

又因为 $\forall k1 \in  [1, i], d_{u_{k1}} \le \operatorname{dist}(u_1, u_j)$，$\forall k2 \in  [j, t], d_{u_{k2}} \le \operatorname{dist}(u_i, u_t)$，所以可以直接将 $k$ 的范围调整为 $1 \le k \le t$，这样用双指针就可以做了。

复杂度：$O(N)$。

## 代码
```
#include <bits/stdc++.h>
#define PII pair <int, int>
#define LL long long
#define x first
#define y second

using namespace std;

const int N = 500010;
int n, s;
bool vis[N];
vector <PII> v[N];

// 求出树上各点距离指定节点的距离并维护最远点
int d[N], fa[N], p;
void dfs(int x)
{
    if(d[x] > d[p])
        p = x;
    for(PII to : v[x])
    {
        if(to.x == fa[x] || vis[to.x]) continue;
        
        d[to.x] = d[x] + to.y;
        fa[to.x] = x;
        dfs(to.x);
    }
}

vector <int> path;
int lst[N], nxt[N];
int query_mx()
{  
    // 处理前后缀和
    for(int i = p; i; i = fa[i])
    {
        path.push_back(i);
        nxt[i] = d[i];
        lst[i] = d[p] - nxt[i];
        vis[i] = 1;
    }
    
    // 计算 d[u[i]] 和 max(d[u[k]])
    int mx = 0;
    for(int i : path)
    {
        d[i] = 0;
        dfs(i);
        mx = max(mx, d[p]);
    }
    
    return mx;
}

int work()
{
    dfs(1);
    d[p] = fa[p] = 0;
    dfs(p);
    
    int ans = 2e9, mx = query_mx();
    // 双指针
    for(int i = 0, j = 0; i < path.size(); i ++ )
    {
        int idi = path[i];
        // 核越长越好
        while(j + 1 < path.size() && lst[path[j + 1]] - lst[idi] <= s)
            j ++ ;
        // 计算最小偏心距
        ans = min(ans, max({mx, lst[idi], nxt[path[j]]}));
    }
    
    return ans;
}

signed main()
{  
    scanf("%d%d", &n, &s);
    for(int i = 1, x, y, z; i < n; i ++ )
    {
        scanf("%d%d%d", &x, &y, &z);
        v[x].push_back({y, z});
        v[y].push_back({x, z});
    }
    
    printf("%d\n", work());
    
	return 0;
}
```

---


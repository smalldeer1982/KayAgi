# [NOISG 2023 Finals] Topical

## 题目描述

兔子 Benson 正在上飞行员学校！

他需要完成 $n$ 场测试，由 $1\sim n$ 编号。对于每场测试，有 $k$ 个科目。对于每个科目，Benson 有一个能力值 $p_j$。由于 Benson 还是一名新手，他对于每个科目的初始能力值均为 $0$。

对于每场测试的每个科目，均有一个能力值下限 $r_{i, j}$。而为了完成第 $i$ 场测试，需要满足他每个科目的能力值都不低于这个下限。

若成功完成第 $i$ 场测试，他的能力值将获得提升，且第 $j$ 个科目的能力值将提升 $u_{i, j}$。

**形式化地**：初始，对于所有 $j$，有 $p_j=0$。Benson 能完成一场测试，当且仅当对于所有 $j$，都有 $r_{i, j}\leq p_j$；完成该场测试后，对于所有 $j$，$p_j$ 的值将增加 $u_{i, j}$。

他可以任意选择完成测试的顺序，但每场测试只能完成一次。请帮助他计算他最多能完成多少场测试。

## 说明/提示

#### 样例 #1 解释

Benson 只能完成第一场测试，其要求为 $[0, 0, 0]$。完成后，他的能力值将变为 $[7, 8, 2]$。此时他不能完成任何一场其余的测试，故答案为 $1$。

#### 数据范围

| Subtask | 分值 | 特殊限制 |
| :-----------: | :-----------: | :-----------: |
| $0$ | $0$ | 样例 |
| $1$ | $12$ | $n=1$ |
| $2$ | $28$ | $n,k\leq 100$ |
| $3$ | $21$ | $k=1$ |
| $4$ | $39$ | 无 |

对于 $100\%$ 的数据：

- $1\leq n, k\leq 10^6$
- $n\cdot k\leq 10^6$
- $0\leq u_{i, j}, r_{i, j}\leq 10^9$，其中 $1\leq i\leq n$ 且 $1\leq j\leq k$。

注：由于洛谷限制，数据不完全按照原题分配子任务。

## 样例 #1

### 输入

```
3 3
0 0 0
7 9 2
7 8 9
7 8 2
7 7 7
8 10 9
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 3
5 1 0
0 1 5
0 0 0
7 7 7
0 5 6
1 1 1
8 2 0
8 1 4
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5 5
14 11 15 7 15
0 0 0 0 0
9 9 14 2 13
4 3 6 1 0
2 4 7 0 0
5 5 0 0 13
4 4 7 1 0
4 1 0 2 1
2 5 0 2 1
4 0 7 2 12
```

### 输出

```
4
```

# 题解

## 作者：lzt415 (赞：1)

## 解题思路
第一眼看到 $1\leq n, k\leq 10^6$ 时心中一颤，感觉不妙，结果第二眼一看，看到 $n\cdot k\leq 10^6$ 就明白这题大概要干什么了。

考虑维护一个 $n$ 行 $k$ 列的 $01$ 矩阵，维护当前的 $p_{j}$。矩阵中，如果 $r_{i,j} \leq p_{j}$，则 $a_{i,j}$ 赋值为 $1$，否则为 $0$。并且对于矩阵的每一行，维护这一行的和 $sum_{i}$。

怎样降低时间复杂度呢？我们先把矩阵每一列按值排序。

那么注意到，当 $p_{j}$ 增大时，会修改矩阵中的第 $j$ 列上前面一段连续的元素的值，把 $0$ 改为 $1$。当然，这个修改暴力一下即可。

好，为什么复杂度是正确的呢？很明显，$p_{j}$ 单调不降，我们已经先把每一列按值排序过了，所以每一个元素我们只会修改一次，故复杂度是可行的。

修改的同时维护 $s_{i}$ 也是简简单单，每次将此处元素的值从 $0$ 修改到 $1$，$s_{i}$ 就加上 $1$。当 $s_{i}$ 变为 $k$，意味着这场考试可以被完成，那么按照我刚刚说的方式更新 $p_{j}$，再更新 $s_{i}$ 然后在更新 $p_{j}$，以此类推。直到不再有 $s_{i}$ 变为 $k$。

不难发现刚刚的过程实现需要用到 ```while``` 循环和一个布尔变量判断是否有有 $s_{i}$ 变为 $k$，来决定循环是否终止。

好了，讲完了，这道题代码很短，就懒得呈现了，或者可以参考其他题解的代码，当然，推荐自己手写。

---

## 作者：StayAlone (赞：1)

首先注意到，若此刻能完成一些测试，以任意顺序完成它们，不影响答案。

考虑在过程中维护新的能够完成的测试。

维护一个 $n\cdot k$ 的 0/1 矩阵、维护当前的 $p_j$。矩阵中，$a_{i, j}=[p_j\geq r_{i, j}]$。对于矩阵的每一行，维护这一行的和 $s_i$。

那么当 $p_j$ 增大时，会修改矩阵中第 $j$ 列上一段值域连续的位置，由 $0$ 变成 $1$。由于 $p_j$ 单调不降，只需要将每一列提前按照值排序，保证每个位置只被修改一次，复杂度就是正确的。修改的同时也很容易维护 $s_i$。若 $s_i$ 变为 $k$，意味着这个测试可以被完成，则更新 $p$。

时间复杂度 $\mathcal O(nk\log n)$。

[AC record](https://www.luogu.com.cn/record/197489046)

```cpp
int n, k, ans, cnt[MAXN], id[MAXN]; ll p[MAXN];
vector <pii> r[MAXN]; vector <int> u[MAXN];

il void upd(int x) {
	rep1(i, 1, k) p[i] += u[x][i];
}

int main() {
	read(n, k);
	rep1(i, 1, k) r[i].resize(n + 1);
	rep1(i, 1, n) {
		u[i].resize(k + 1);
		rep1(j, 1, k) r[j][i] = {read(), i};
	}
	rep1(i, 1, n) rep1(j, 1, k) read(u[i][j]);
	rep1(i, 1, k) sort(begin(r[i]) + 1, end(r[i]));
	for (bool flg = 1; flg; ) {
		flg = 0;
		rep1(i, 1, k) {
			while (id[i] < n && r[i][id[i] + 1].fst <= p[i]) {
				if (++cnt[r[i][++id[i]].snd] == k) flg = 1, ++ans, upd(r[i][id[i]].snd);
			}
		}
	} printf("%d", ans);
	return 0;
}
```

---


# [NOIP 2010 提高组] 关押罪犯

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？


## 说明/提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。


## 样例 #1

### 输入

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884```

### 输出

```
3512```

# 题解

## 作者：梦回还 (赞：688)

淳朴的并查集~但因为它们带有权值，因此排序是必须的，我们要尽可能让危害大的罪犯在两个监狱里。

那么，再结合敌人的敌人和自己在一个监狱的规律合并。

当查找时发现其中两个罪犯不可避免地碰撞到一起时，只能将其输出并结束。

还有一点很重要，就是没有冲突时一定输出0！！！








```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct data {int x,y,z;};//结构体便于排序的变换
data f[100005];
int n,m,a[20005],b[20005],i;
inline bool cmp(data a,data b)//重写cmp函数
{
    return a.z>b.z;
}
inline int find(int x)
{
    if(a[x]==x) return x;
    a[x]=find(a[x]);
    return a[x];
}
inline void ad(int x,int y)//合并
{
    x=find(a[x]);
    y=find(a[y]);
    a[x]=y;
}
inline bool check(int x,int y)//查找
{
    x=find(x);
    y=find(y);
    if(x==y) return true;
    return false;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++) a[i]=i;
    for(i=1;i<=m;i++)
        scanf("%d%d%d",&f[i].x,&f[i].y,&f[i].z);
    sort(f+1,f+m+1,cmp);//c党的优越感~
    for(i=1;i<=m+1;i++)//为什么m+1呢？如果运行到m+1会输出0，想想为什么。
    {
        if(check(f[i].x,f[i].y)) {printf("%d",f[i].z);break;}//如果两个罪犯已经在同一监狱就输出 ，并退出
        else
        {
            if(!b[f[i].x]) b[f[i].x]=f[i].y;//标记“敌人”
                else {ad(b[f[i].x],f[i].y);}//将敌人的敌人合并
            if(!b[f[i].y]) b[f[i].y]=f[i].x;
                else {ad(b[f[i].y],f[i].x);}
        }
    }
    return 0;
}
```

---

## 作者：_Weslie_ (赞：72)

这篇文章主要介绍**拓展域并查集**。

拓展域并查集，主要用于一种状态表示无法解决问题的题目。例如本题，一个开关有两种状态，用和不用。

本文主要介绍二倍拓展域的拓展域并查集。

## 什么是拓展域并查集？

拓展域并查集是一种数据结构，用于解决具有多个相互关系集合的问题。它是传统并查集的扩展，能够处理集合间的不同关系，如相互排斥或相互独立的关系。

## 拓展域并查集有什么用？
只看定义是不可以的，我们来看一个应用场景：

$n$ 个点有 $m$ 对关系，把 $n$ 个节点放入**两个集合**里，要求**每对**存在关系的两个节点**不能**放在同一个集合。问能否成功完成？

这个问题我们直接用普通并查集是无法通过的，我们必须换一个更加高级的办法。

在原本的并查集中，$i$ 号点在并查集中对应的点正好为 $i$，而在拓展域并查集中对应的是 $i$ 和 $i+n$ 等。当然这个题只需要 $i$ 和 $i+n$ 就够了，有些需要 $i+2n$ 之类的。

例如：对于以下样例，如果我们使用普通并查集，建出来的图是这样的：

```
4 6
1 2
2 3
3 4
4 5
5 6
6 1
```

![](https://cdn.luogu.com.cn/upload/image_hosting/kefslj3p.png)

但是如果我们对于下面的样例，结果是这样的：

```
4 7
1 2
2 3
3 4
4 5
5 6
6 7
7 1
```

![](https://cdn.luogu.com.cn/upload/image_hosting/frpvpe0i.png)

这张图除了比上面这张多了一个点之外，与上面一张基本没有什么区别，如果我们仅仅只使用并查集的话，是看不出什么区别的。

所以这个使用普通并查集是不可取的。

我们使用拓展域并查集，$u$ 和 $u+n$ 分别表示点 $u$ 的两个相反状态，将 $(u,v+n)$ 连边表示 $(u,v)$ 不应该在一个集合里（也可以看做 $u$ 和 $v$ 的反状态在一个集合里）。当然 $(u,v+n)$ 存在边了，相反地，$(v,u+n)$ 也理应右边。

那么就好办了，判断不可以的方式是存在 $u$ 的正反状态在一个集合里。

附上上面两个样例的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/elgn7s5c.png)

等效图：

![](https://cdn.luogu.com.cn/upload/image_hosting/57800r5i.png)

可以看到这张图明显没有任何 $u$ 的正反状态在一个集合里。

但是第二组的样例就不一样了。

![](https://cdn.luogu.com.cn/upload/image_hosting/126xhjev.png)

不够直观？看看这张等效图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gjnau3e0.png)

可以看出点 $1$ 的正反两个状态在一个集合里，所以不行。

## 拓展域并查集怎么写？

拓展域并查集在写法上仅有初始化与两点连边与普通并查集不同。

初始化：

```
for(int i=1;i<=2*n;i++)fa[i]=i;//2 倍点
```

查询父亲和合并函数与普通并查集一样。

```
int findd(int now){
    if(fa[now]==now)return now;
    return fa[now]=findd(fa[now]);
}
void vnion(int u,int v){
    u=findd(u);v=findd(v);
    if(u==v)return;
    fa[u]=v;
}
```

连边：

```
int u,v;
vnion(u,v+n);
vnion(v,u+n);
```

如果需要集合大小，集合内包含的元素等，直接与普通并查集相同写即可。


## 例题

### P1525 [NOIP2010 提高组] 关押罪犯

[题目传送门。](https://www.luogu.com.cn/problem/P1525)

我们贪心，对影响力从大到小排序。

每遇到一个事件，因为如果让这两个囚犯 $(u,v)$ 在一个监狱内，答案就是这个事件的影响力了。我们尽量尝试让最大影响力发生在后面的时间上，所以我们将 $u$ 与 $v$ 的反状态关在一个监狱里。

当你发现 $u$ 与 $u$ 的反状态关在一个监狱里时，这说明已经没救了，无论如何你都避免不了打架，那么就输出当前影响力即可（显然你可以操控使得影响力最小的事件在一个监狱内发生）。

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int u,v,w;
}e[100005];
bool cmp(node _,node __){
	return _.w>__.w;
}
int fa[40005];
int findd(int now){
	if(fa[now]==now)return now;
	return fa[now]=findd(fa[now]);
}
void vnion(int u,int v){
	u=findd(u),v=findd(v);
	if(u==v)return;
	fa[u]=v;
}
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=2*n;i++)fa[i]=i;
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	}
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=m;i++){
		vnion(e[i].u+n,e[i].v);
		vnion(e[i].u,e[i].v+n);
		if(findd(e[i].u)==findd(e[i].u+n)||findd(e[i].v)==findd(e[i].v+n)){
			printf("%d",e[i].w);
			return 0;
		}
	}
	printf("0");
	return 0;
}
```

### CF776D The Door Problem

[题目传送门。](https://www.luogu.com.cn/problem/CF776D)

这题最难的是状态设计。也因此这题是蓝。

每个钥匙都有动或不动两种状态，分别设为 $i$ 和 $i+m$。

那么我们对于每个门，看看它初始开不开。设控制它的两把钥匙为 $(u,v)$：

- 如果门初始开，$(u,v)$ 只能同时选或不选，合并 $(u,v)$ 及 $(u+m,v+m)$。
- 如果门初始关，$(u,v)$ 只能二选其一，合并 $(u+m,v)$ 及 $(u,v+m)$。

```
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
vector<int>g[N];
int fa[N],n,a[N],m;
int findd(int now){
    if(fa[now]==now)return now;
    return fa[now]=findd(fa[now]);
}
void vnion(int u,int v){
    u=findd(u);v=findd(v);
    if(u==v)return;
    fa[u]=v;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=2*m;i++)fa[i]=i;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1,k,x;i<=m;i++){
        scanf("%d",&k);
        for(int j=1;j<=k;j++){
            scanf("%d",&x);
            g[x].push_back(i);
        }
    }
    for(int i=1;i<=n;i++){
        if(a[i]==1){
            vnion(g[i][0],g[i][1]);
            vnion(g[i][0]+m,g[i][1]+m);
        }
        else{
            vnion(g[i][0],g[i][1]+m);
            vnion(g[i][0]+m,g[i][1]);
        }
    }
    for(int i=1;i<=m;i++){
        if(findd(i)==findd(i+m)){
            printf("NO");
            return 0;
        }
    }
    printf("YES");
    return 0;
}
```

---

## 作者：fy0123 (赞：32)

好吧，发个二分图题解QAQ..


做法：二分答案+二分图

1.要求最大的影响力最小 -> 想到二分答案

2.将罪犯关押在两个监狱里 -> 想到二分图


具体，将所有罪犯的关系按照影响力大小从大到小排序，二分答案mid（此处的mid是数组的下标，需要用到具体值时再代入到数组中即可，具体见代码）。check函数即是判断该图是否是二分图，首先将a[mid].v大于答案的关系都连边，由于我们已经将所有关系按照影响力排序，所以直接从mid + 1到m循环，m是关系总数，将这些关系都连边即可。然后就是黑白染色判断是否是二分图，是的就返回true，反之返回false。


代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;

const int N = 20010;
const int M = 100010;

int n, m, color[N];
bool flag;

vector<int> e[N];

struct Node{
    int x, y, v;
    bool operator < (const Node &other) const{
        return v < other.v;
    }
}a[M];

inline void dfs(int u, int c)//染色判断是否是二分图，u是当前节点，c是当前需要染的颜色，color[]记录每个点的颜色
{
    color[u] = c;
    for (int i = 0; i < e[u].size(); i ++){
        int v = e[u][i];
        if (!color[v]) dfs(v, c ^ 1);//相邻的点还没染过色，就将它染成与自己不同的颜色
        else
        if (color[v] == c) flag = false;//有冲突就把标志标为false，该图不是二分图
    }
}

inline bool check(int pos)//检查是否为二分图
{
    for (int i = 1; i <= n; i ++) e[i].clear();//注意初始化
    for (int i = pos + 1; i <= m; i ++){//连边，pos+1开始的关系的影响力都是大于答案的，需要在两个监狱内
        e[a[i].x].push_back(a[i].y);
        e[a[i].y].push_back(a[i].x);
    }
    flag = true;
    memset(color, 0, sizeof color);//注意初始化
    for (int i = 1; i <= n; i ++)//dfs黑白染色
        if (!color[i]){
            dfs(i, 0);
            if (!flag) return false;
        }
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i ++)
        scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].v);
    sort(a + 1, a + 1 + m);  //结构体按v排序
    int l = 0, r = m, mid; //二分答案
    while (l + 1 < r){
        mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    if (m == 1) puts("0");  //特判，如果只有一个关系直接输出0
    else printf("%d\n", a[r].v);
    return 0;
}
```

---

## 作者：ClV_Csy (赞：20)

# P1525 [NOIP2010 提高组] 关押罪犯
## 题意
有 $n$ 个罪犯和三个序列 $a, b, c$，其中 $a_i$ 与 $b_i$ 两名罪犯之间有大小为 $c_i$ 的冲突。先要将这些罪犯分配到两个监狱中，只有在同一个监狱时两名罪犯才会发生冲突。要求能分配出的最小的最大冲突值。
## 思路
### 一、种类并查集
很显然的并查集，并且还是种类并查集。本文重点阐述种类并查集的做法，如果普通并查集不会的可以去 [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) 补习后再来做此题。

种类并查集，顾名思义，是把并查集分成了若干个种类。本题中就是仇人和好友的关系，并查集有两个集合，相同集合之间是暂时的好友（之所以是暂时的，是因为后面的数据可能与目前情况相冲突），不同集合之间是敌人。  
例如以下测试样例：
```
3 2
1 2 1
1 3 1
```
我们可以推知 $2$ 与 $3$ 是好友关系。但是如何让计算机知道呢？并查集，基本操作只有并、查，所以我们只能用“并”操作来完成。  
我们可以**建立一个假想敌**，即**编号为 $a$ 的假想敌为 $a + n$。**  
这样，在处理此样例第二行时，我们可知此时两个集合分别是 $\{1, 5\}$ 和 $\{2, 4\}$。  
再处理此样例第三行，又可知两个集合分别是 $\{1, 5, 6\}$ 和 $\{2, 3, 4\}$。  
此时 $2$ 和 $3$ 处于同一集合，所以他们是好友。可以发现，我们通过了他们的一个共同的假想友 $4$，得知他们是好友。这个点很重要，也是种类并查集的核心，可以仔细理解一下。

-----
### 二、主体思路
我们可以采取以下策略：  
先对怨气值进行从大到小排序，先处理怨气值大的。如果两个罪犯 $x$ 和 $y$ 之间是敌人，则把他们分配到不同的监狱（合并 $x$ 的假想敌和 $y$ 以及 $x$ 和 $y$ 的假想敌）。如果在分配过程中发生了矛盾，即 $x$ 与 $y$ 已经在同一个监狱，但是他们又有矛盾，那么停止处理，直接输出此时 $x$ 与 $y$ 的怨气值。这样分配到的最大怨气值就是所有分配方案中最小的，即题目所求。
## 代码
**注意：**  
分两类（敌人和朋友）的种类并查集需要开两倍空间。
> $N \le 20000$
```cpp
#include <iostream>
#include <algorithm> 
using namespace std;
int n, m;
int f[40010]; //20000*2,分两类的种类并查集开两倍空间

struct node {
	int x, y, v;
}a[100010];

bool cmp(node x, node y) {
	return x.v > y.v;
}

int find(int x) { //查
	if (f[x] == x) {
		return x;
	}
	return f[x] = find(f[x]);
}
void merge(int x, int y) { //并
	int fx = find(x), fy = find(y);
	if (fx != fy) {
		f[fy] = fx;
	}
}

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> a[i].x >> a[i].y >> a[i].v;
	}
	sort(a + 1, a + m + 1, cmp);
	for (int i = 1; i <= n * 2; i++) {
		f[i] = i;
	}
	for (int i = 1; i <= m; i++) {
		if (find(a[i].x) == find(a[i].y)) {
			cout << a[i].v; //如果矛盾，则输出此时的怨气值
			return 0;
		}
		merge(a[i].x + n, a[i].y); //合并x的假想敌和y
		merge(a[i].x, a[i].y + n); //合并x和y的假想敌
	}
	cout << 0;
	return 0;
}
```

---

## 作者：KrOX (赞：13)

### 并查集
这道题乍一看求最小最大值，想想又不知如何下手，经一位大佬指点，知道该用并查集，顺便度娘了一下并查集，就是两个最基本的函数，这里不多讲了，参见 **P3367【模板】并查集** 。
```cpp
int find(int x){
    if(fa[x]!=x) fa[x]=find(fa[x]);
    return fa[x];
}
void unite(int x,int y){
    fa[find(x)]=find(y);
}
```

### 反人类
这是那位大佬告诉我的名词，应该是便于理解用的。举个栗子：如果A和B是敌人，那么A和B的反人类就是好友，B和A的反人类就是好友，接下来，我们考虑怎么表示B的反人类，可以另开一个数组，更方便的方法便是用i+n来表示i的反人类

### 贪心
接下来就用贪心的思路了。开个结构体，把几对cp按照怒气值排排序，从怒气值最大的一对cp开始，从大到小入手，咱们的目的就是把这几对最狠的cp拆散（也就是俩人分别和对方的反人类相连）。如果出现一对cp拆散了，会让前面的cp又冤家路窄，那么凶手就是你们这对cp！输出，任务结束。

### 警告
不要拆散了所有cp就太兴奋，别忘了输出个**0**

#### 上一下我丑陋的代码～
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int fa[40008];//为了存放反人类，所以开两倍
struct cp{
    int a,b,anger;
}c[100008];//结构体放cp
bool cmp(const cp &x,const cp &y){
    return x.anger>y.anger;
}//按照怒气值大小排序，先拆散狠cp
int find(int x){
    if(fa[x]!=x) fa[x]=find(fa[x]);
    return fa[x];
}
void unite(int x,int y){
    fa[find(x)]=find(y);
}
//并查集模版
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=2*n;i++) fa[i]=i;
    for(int i=1;i<=m;i++) scanf("%d%d%d",&c[i].a,&c[i].b,&c[i].anger);
    sort(c+1,c+m+1,cmp);
    for(int i=1;i<=m;i++){
        if(find(c[i].a)==find(c[i].b)){
            printf("%d",c[i].anger);
            return 0;
        }
        unite(c[i].a,c[i].b+n);
        unite(c[i].b,c[i].a+n);
        //互相连结对方的反人类
    }
    puts("0");//全部拆散输出0
    return 0;
}
```
PS：第一次写题解，大佬勿喷～

---

## 作者：IGpig (赞：11)

### 题解：P1525 [NOIP2010 提高组] 关押罪犯
题意：对于一个图，把点分成两个集合，删去跨集合的边后让最大边权最小。\
看到这里可以明显的想到二分图。
### 二分图
定义：\
二分图，又称二部图，英文名叫 Bipartite graph。**指节点由两个集合组成，且两个集合内部没有边的图**。
    
观察发现，与本题的要求刚好相反，那么自然可以想到：
- 设答案为 ans。
- 对于边权小于 ans 的边在同一个集合内，则在二分图中可以不考虑。
- 只考虑边权大于 ans 的边，则图一定是一个二分图。
- 
![](https://oiwiki.com/graph/images/bi-graph.svg)

现在我们知道，要判断一个答案是否合法，**只要把大于答案的边连起来，判断是否为一个二分图**。\
介绍一个 dfs 判断二分图的方法：

```cpp
bool dfs(LL v, LL c){
    color[v] = c;    //将当前顶点涂色
    for(int i = 0; i < n; i++){    //遍历所有相邻顶点，即连着的点
        if(edge[v][i] == 1){    //如果顶点存在
            if(color[i] == c)    //如果颜色重复，就返回false
                return false;
            if(color[i] == 0 && !dfs(i,-c))    //如果还未涂色，就染上相反的颜色-c,并dfs这个顶点，进入下一层
                return false;   //返回false
        }
    }
    return true;   //如果所有顶点涂完色，并且没有出现同色的相邻顶点，就返回true
}

```
至于答案的话，采用二分答案的方法：

```cpp
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>e[i].x>>e[i].y>>e[i].w;//按边存，方便排序
    }
    sort(e+1,e+m+1);
    LL l=0,r=m,mid;
    while(l<r-1){
        mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    if(m==1) cout<<0;//特判
    else cout<<e[r].w;
    return 0;
}
```
### 代码
怕大家看不懂，参考了 @fy0123 大佬的代码重写了一遍，自己的码风不太好。
```
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
LL n,m,col[500005];
bool flag;
struct node{
    LL x,y,w;
    bool operator < (const node &p)const{
        return p.w>w;
    }
}e[500005];
vector<LL> v[500005];
void dfs(LL x,LL c){
    col[x]=c;
    for(auto i : v[x]){
        if(!col[i]) dfs(i,c^1);
        else if(col[i]==c) flag=0;
    }
}
bool check(LL x){
    for(int i=1;i<=n;i++) v[i].clear();
    memset(col,0,sizeof(col));flag=1;
    for(int i=x+1;i<=m;i++){
        v[e[i].x].emplace_back(e[i].y);
        v[e[i].y].emplace_back(e[i].x);
    }
    for(int i=1;i<=n;i++){
        if(!col[i]){
            dfs(i,0);
            if(!flag) return 0;
        }
    }
    return 1;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>e[i].x>>e[i].y>>e[i].w;
    }
    sort(e+1,e+m+1);;
    LL l=0,r=m,mid;
    while(l<r-1){
        mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    if(m==1) cout<<0;//特判
    else cout<<e[r].w;
    return 0;
}
```

---

## 作者：Ray_yi (赞：6)

#### 题目大意：

共有 $2$ 座监狱，要把 $n$ 名罪犯分别分在 $2$ 座监狱中，而在 $n$ 名罪犯中，每当 $a$ 和 $b$ 在同一个监狱内时，会产生怨气值 $c$，现在要求怎么分配使怨气值最小，如果本年内监狱中未发生任何冲突事件，则输出 $0$。 

#### 思路：

从题目就可以看出，可以用并查集做。

我们先把怨气值从大到小排序，优先处理怨气值大的。如果两个罪犯 $x$ 和 $y$ 是敌人，则把他们分配到不同的监狱去。如果在这个过程中，发现两个罪犯不可避免不在一个监狱，那么输出怨气值，并结束，此时的怨气值一定是最小的。

最后，别忘了输出 $0$。

#### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu{
	int x,y,val;
}a[100005];
bool cmp(stu a,stu b){
	return a.val>b.val;//把怨气值从大到小排序 
}
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}//查 
int n,m,f[100005];
//分两类，敌人和朋友，所以开两倍空间 
int main(){
	cin>>n>>m;
	for(int i=1;i<=2*n;i++) f[i]=i;
	for(int i=1;i<=m;i++) cin>>a[i].x>>a[i].y>>a[i].val;
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++){
		int x=a[i].x,y=a[i].y;
		if((find(x+n)==find(y+n))||(find(x)==find(y))){
			cout<<a[i].val;
			return 0;
		}//发现两个罪犯不可避免不在一个监狱，那么输出怨气值，并结束 
		f[find(x)]=find(y+n);
		f[find(y)]=find(x+n);
	}
	cout<<0;
	return 0;
}
```

---

## 作者：ClaudeHsu (赞：5)

学了好久并查集，这次来写个题解。

# **思路**

先将怨气值 $c$ 从大到小排序。

每一条边都标明敌人，合并敌人的敌人。

如果敌人已在同一个集合内，输出。

别忘了最后输出 $0$。

# **代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,e[20005],f,ff=0;
struct node{
	int a;//罪犯1号
	int b;//罪犯2号
	int c;//怨气值
}d[100005];//结构体，便于以后排序
bool cmp(node x,node y){
	return x.c>y.c;//先处理怨气值大的,所以从大到小排序
}
int find(int x){
    if(e[x]==x) return x;
    e[x]=find(e[x]);
    return e[x];
}//查询x所在的集合（顺便路径压缩）
void marge(int x,int y){
	int u=find(x),v=find(y);
	if(u==v)return;
	e[u]=v;
}//合并x、y所在的集合
bool check(int x,int y){
	int u=find(x),v=find(y);
	if(u==v)return 1;
	return 0;
}//检查x、y在不在同一个集合
vector<int>g[20005];
int main(){
	for(int i=1;i<=20000;i++)
	e[i]=i;//初始化
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	cin>>d[i].a>>d[i].b>>d[i].c;//输入
	sort(d+1,d+m+1,cmp);
	for(int i=1;i<=m;i++){
		if(check(d[i].a,d[i].b)==1){
			cout<<d[i].c;
      ff=1;
			break;
		}//直接输出
		g[d[i].a].push_back(d[i].b);
		g[d[i].b].push_back(d[i].a);//标明敌人
		for(int j=0;j<g[d[i].b].size();j++)
		marge(d[i].a,g[d[i].b][j]);
		for(int j=0;j<g[d[i].a].size();j++)
		marge(d[i].b,g[d[i].a][j]);//合并敌人的敌人
	}
	if(ff=0)cout<<0;
	return 0;
}
```

---

## 作者：JCT_addyi (赞：5)

### 题意：

有 $n$ 个罪犯，有 $m$ 对仇人，后给你每对仇人中的两个罪犯和他们之间的怨气值，现有两个监狱，要你分配罪犯，每对仇人在同一个监狱才会有怨气值，问你怎么分配发生的怨气值最小，最小值是多少。

### 思路：

这个题用并查集很好做，也很好理解，因为要求最小怨气值，所以我们先把每对仇人的怨气值按从大到小排序，先把怨气值大的仇人分配了，然后再用并查集，查找如果我的朋友也是敌人的朋友或我的敌人也是敌人的敌人，这就是最小值，否则把敌人的敌人放进自己的朋友中，把敌人的朋友放进自己的敌人中。

### 代码如下：

详细看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,val;
}a[100005];
bool cmp(node x,node y){
	return x.val>y.val;
}//从大到小排序 
int n,m;
int f[100004];
int find(int x){
	if(f[x]==x)	return x;
	return f[x]=find(f[x]); 
}//查（模板）
int main(){
	cin>>n>>m;
	for(int i=1;i<=n*2;i++) f[i]=i;//赋值根节点 *2是因为敌人和朋友分两类 
	for(int i=1;i<=m;i++) cin>>a[i].x>>a[i].y>>a[i].val;//输入两个罪犯和他们之间的怨气值 
	sort(a+1,a+m+1,cmp);//怨气值从大到小 先把怨气值大的分了来 
	for(int i=1;i<=m;i++){//遍历 
		int x=a[i].x,y=a[i].y;
		if(find(x)==find(y)||find(x+n)==find(y+n)){//如果我的朋友也是敌人的朋友或我的敌人也是敌人的敌人
			cout<<a[i].val;
			return 0;
		}
		f[find(x)]=find(y+n);//把敌人的敌人放进自己的朋友中 
		f[find(x+n)]=find(y);//把敌人的朋友放进自己的敌人中 
	}
	cout<<0;
	return 0;
}
```

谢谢大家！

---

## 作者：Gary0504 (赞：3)

# P1525 [NOIP2010 提高组] 关押罪犯

## 题目大意
有 $ n $ 个人，有 $ m $ 对人之间存在仇恨，怨气值为 $ c $ 。使怨气值最大的一组怨气值最小。

## 解题思路
看一眼题就会发现这是一个贪心：尽量把怨气大的两个人分开。
先将数组排序（由大到小），再结合敌人的敌人和自己在一个监狱的规律合并。
那么答案是什么时候呢？显然，当两个囚犯不得不合并到一起时，输出答案。

丑陋的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int fa[500005];//并查集

int get(int x)
{
    if (x == fa[x])
        return x;
    return fa[x] = get(fa[x]);
}

void merge(int x, int y)//合并
{
    fa[get(x)] = get(y);
}

struct node
{
    int x, y, v;
} a[1000005];

bool cmp(node x, node y) { return x.v > y.v; }//重写结构体排序(从大到小)

int n, m;

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int x, y, v;
        cin >> x >> y >> v;
        a[i] = {x, y, v};
    }
    for (int i = 1; i <= n*2; i++)
    {
        fa[i] = i;
    }//初始化并查集

    sort(a + 1, a + m + 1, cmp);

    for (int i = 1; i <= m; i++)
    {
        if (get(a[i].x) == get(a[i].y)) // 不得不合并到一起
        {
            cout << a[i].v;
            return 0;
        }
        merge(a[i].x, a[i].y + n);
        merge(a[i].x + n, a[i].y); // 结合敌人的敌人和自己在一个监狱的规律合并。
    }
    cout << 0;//重要！不要忘记输出0！（否则90pts）
    
    return 0; //完美结尾！
}
```


tips：

- 前置知识：并查集。不会的可以参考这篇[文章](https://oi.wiki/ds/dsu/)
- **重要！！！** 不要忘记程序结束时要 `cout << 0 ;`（90pts的悲惨事故）

附并查集模板

```cpp
int fa[500005];//并查集

int get(int x)//查找
{
    if (x == fa[x])
        return x;
    return fa[x] = get(fa[x]);
}

void merge(int x, int y)//合并
{
    fa[get(x)] = get(y);
}
```

---

## 作者：Rainbow_qwq (赞：3)

第一次写提高历练地的题解^_^

---

[P1525原题链接](https://www.luogu.org/problemnew/show/P1525)

这道题是一个经典的**并查集**题目。

思路：先按照怨气值从大到小排序，

然后将怨气值最大的放到不同监狱里，最后碰到

这个并查集有一点变化，就是要合并反集。

举个例子：
```cpp
若a与b相反，b与c相反，
则a与c就在一起。
```
这种情况，就将并查集开到2倍，用a+n表示a的反面，将b与a+n合并，a与b+n合并。

事实证明这是可行的。

参考题目：

[P1892 [BOI2003]团伙](https://www.luogu.org/problemnew/show/P1892)

[P2024 [NOI2001]食物链](https://www.luogu.org/problemnew/show/P2024)

---
下面分步展示AC 代码(注释在代码中)：

1.并查集：我手写了一个模板~,初始化在模板中自带。
```cpp
const int wlxsq=2e4+6;
template<int SIZE>
class Union{
    private:
		int fa[SIZE];
    public:
        void clear(){for(int i=0;i<SIZE;i++)fa[i]=i;}
        Union(){clear();}
        int getf(int x){return x==fa[x]?x:fa[x]=getf(fa[x]);}
        inline void merge(int x,int y){fa[getf(x)]=getf(y);}
        inline bool check(int x,int y){return getf(x)==getf(y);}
};
Union< wlxsq<<1 >un;//并查集必须开到2倍
```
2.定义囚犯关系的结构体。
```cpp
int n,m;//n名囚犯，m对关系
struct node{
	int u,v,w;//表示u,v两个犯人之间怨气值为w
	bool operator <(const node &q)const{return w>q.w;}
		//按怨气值升序排序
}e[wlxsq<<3];
```
3.主函数中的处理部分(输入就不说了),注意必须先排序。
```cpp
sort(e+1,e+m+1);
for(int i=1;i<=m;i++)
{
	if(un.check(e[i].u,e[i].v))
		return printf("%d",e[i].w),0;
		//两个犯人在一起，必然会冲突，输出并结束
	un.merge(e[i].u,e[i].v+n);//u与v的反面合并
	un.merge(e[i].v,e[i].u+n);//v与u的反面合并
}
puts("0");//没有冲突输出0 
```
---
最后是完整 **AC 代码**(去注释)：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    char c=getchar();int x=0;bool f=0;
    while(!isdigit(c))f^=!(c^45),c=getchar();
    while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
    if(f)x=-x;return x;
}
const int wlxsq=2e4+6;
template<int SIZE>
class Union{
    private:
		int fa[SIZE];
    public:
        void clear(){for(int i=0;i<SIZE;i++)fa[i]=i;}
        Union(){clear();}
        int getf(int x){return x==fa[x]?x:fa[x]=getf(fa[x]);}
        inline void merge(int x,int y){fa[getf(x)]=getf(y);}
        inline bool check(int x,int y){return getf(x)==getf(y);}
};
Union< wlxsq<<1 >un;
int n,m;
struct node{
	int u,v,w;
	bool operator <(const node &q)const{return w>q.w;}
}e[wlxsq<<3];
int main()
{
	n=read(),m=read();
    for(int i=1;i<=m;i++)
    	e[i].u=read(),e[i].v=read(),e[i].w=read();
    sort(e+1,e+m+1);
    for(int i=1;i<=m;i++)
    {
    	if(un.check(e[i].u,e[i].v))
    		return printf("%d",e[i].w),0;
    	un.merge(e[i].u,e[i].v+n);
    	un.merge(e[i].v,e[i].u+n);
	}
	puts("0")
    return 0;
}
```

---

## 作者：zhaocs123456 (赞：2)

### 主体思路：
1. 读入。
2. 排序（因为有权值）。
3. 双倍存储并查集（$A$ 与 $B$ 有矛盾，将 $A$ 与 $B + N$ 归为一组，$B$ 与 $A+N$ 归为一组，若 $A$ 与 $B$ 在同一组或 $A+N$ 与 $B+N$ 在同一组，则无法避免，输出当前冲突值）。
### 代码：

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
struct bcj{                    //并查集
	int len;                   //长度
	int q[40005];              //存储，q[i]代表i的老大
	void init(int lenn){       //初始化一个长度为lenn的并查集
		len=lenn;
		for(int i=1;i<=len;i++)
			q[i]=i;
	}
	int Find(int t){           //找t的顶级老大
		if(q[t]==t) return t;
		else return Find(q[t]);
	}
	void in(int a,int w){      //将a及a的老大团加入w团
		if(q[a]!=a) in(q[a],w); 
		q[a]=w;
	} 
	void add(int a,int b){     //合并a和b所在老大团
		int a_1=Find(a),b_1=Find(b);
		q[a_1]=b_1;
		in(a,b_1);
	}
	int num(){                 //求老大团数
		int ans;
		for(int i=1;i<=len;i++)
			if(q[i]==i)
				ans++;
		return ans;
	}
	bool same(int a,int b){    //a和b是否在一个集合中
		int a_1=Find(a),b_1=Find(b);
		return a_1==b_1;
	}
}a;
struct Pair{
	int a,b,c;
}p[100005];
bool cmp(Pair q,Pair w){
	return q.c>w.c;
}
int n,m;
int main(){
	scanf("%d %d",&n,&m);
	a.init(n*2);
	for(int i=1;i<=m;i++)
		scanf("%d %d %d",&p[i].a,&p[i].b,&p[i].c);
	sort(p+1,p+m+1,cmp);
	for(int i=1;i<=m;i++){
		if(!a.same(p[i].a,p[i].b) && !a.same(p[i].a+n,p[i].b+n)){
			a.add(p[i].a,p[i].b+n);a.add(p[i].a+n,p[i].b);
		}else {
			printf("%d",p[i].c);
			return 0;
		}
	}
	printf("0");
	
	return 0;
}
```
~~码风不好，还请见谅。~~

---

## 作者：player_1_Z (赞：0)

### 先来理解题目
这题需要用并查集（[并查集](https://blog.csdn.net/sqm_C/article/details/143710084)）。

### 思路
因为要确保冲突最小，所以优先把冲突大的人安放好，所以按冲突从大到小排序并按此顺序处理。处理时判断这次安放后会不会和之前的人有冲突冲突，如果有，为了能保住乌纱帽，所以让这次被看见，就输出这次的怒气值，否则，直接安放。最后，如果一直没有冲突就**输出 $0$！**

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct A{
	int x,y,val;
}a[100005];
bool cmp(A x,A y){ 
	return x.val>y.val;
}
int n,m,f[100005];
int find(int x){//并查集查找 
	if(f[x]==x)	return x;
	return f[x]=find(f[x]);//路径压缩 
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n*2;i++) f[i]=i;//并查集初始化 
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].val);
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++){
		int x=a[i].x,y=a[i].y;
		if(find(x)==find(y)||find(x+n)==find(y+n)){
			cout<<a[i].val;//有冲突 
			return 0;
		}
		f[find(x)]=find(y+n);//目前没有冲突，可以直接安放 
		f[find(x+n)]=find(y);
	}
	cout<<0;//不存在冲突 
	return 0;
}
```

---

## 作者：foglake (赞：0)

## P1525 [NOIP2010 提高组] 关押罪犯
芜湖~

身为机房大雾之神，当然要在题解补充计划中出力啦。

### 思路
看完题目很显然有一个贪心：尽量将两个冲突值大的两个罪犯分开。那么什么是我们的答案呢？我们先将关系从大到小排序，当我们遇到两个罪犯却发现他们已经被分到同一组时，这就是我们的答案（显然，如果强行将他们分开，结果一定更劣，因为他被分到的另一组一定有一个比当前与他仇更大的人）。当然，当我们完~ 美 ~的将所有的关系处理好后（即不产生冲突），要输出零哦。

### 代码

```
//处理罪犯关系用并查集处理
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;
const int maxn = 2e5 + 10;
struct Creminal {
	int x, y, val;
}p[maxn / 2];
int ans, f[maxn], a[maxn];
bool cmp(Creminal a, Creminal b){return a.val > b.val;}//排序预处理
int Find(int x) {
	if (f[x] == x) return x;
	return f[x] = Find(f[x]);
}
int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++)
		scanf("%d%d%d", &p[i].x,  &p[i].y, &p[i].val);
	for (int i = 1; i <= n; i++) f[i] = i;
	sort(p + 1, p + 1 + m, cmp);
	for (int i = 1; i <= m; i++) {
		if (Find(p[i].x) == Find(p[i].y)) {
			ans = p[i].val;
			break;
		}//已经出现不可避免的冲突
		if (!a[p[i].x]) a[p[i].x] = p[i].y;
		else f[Find(p[i].y)] = Find(a[p[i].x]);
		if (!a[p[i].y]) a[p[i].y] = p[i].x;
		else f[Find(p[i].x)] = Find(a[p[i].y]);
	}
	printf("%d", ans);
}
```

---

## 作者：thegranddesigner (赞：0)

类似食物链的做法，带权值的并查集。

边权为0表示同监狱，为1的表示要放在不同的监狱。


处理的时候，我们先排序，从冲突值最大的先处理。

判断的时候：

如果两人在同一个并查集，就看它们各自到祖先节点的距离，如果相等，则说明它们事先已经被安排在同一个监狱，那么冲突不可避免，直接输出。

如果距离不等，则说明不会有冲突。

如果不在同一个并查集，则合并。




    
    
    
        
        
        
    
    
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct hen{
    int a;
    int b;
    long long int c;
};
hen data[100005];
int n,m;
int dis[20005];
int father[20005];
void anc(int node){
    if (node==father[node])return;
    else {
        anc(father[node]);
        dis[node]=(dis[node]%2+dis[father[node]]%2)%2;//这条语句必须先于下一行的语句 
        father[node]=father[father[node]];
        return;
    }
}
bool cmp(hen d,hen e){
    return d.c>=e.c;
}
int main(){
    cin>>n>>m;
    for (int i=1;i<=m;i++){
        cin>>data[i].a>>data[i].b>>data[i].c;
    }
    sort(data+1,data+(m+1),cmp);
    for (int i=1;i<=n;i++)father[i]=i;
    for (int i=1;i<=m;i++){
        int a,b,c;
        a=data[i].a;
        b=data[i].b;
        c=data[i].c;
        if (a==b){
            cout<<c;
            return 0;
        }
//        cout<<endl;
//        cout<<a<<"  "<<b<<"  ";
        int dada,dadb,lena,lenb,z;
        anc(a);
        anc(b);
        dada=father[a];
        dadb=father[b];
        lena=dis[a];
        lenb=dis[b];
        if (dada==dadb){
            if (lena%2==lenb%2){
                cout<<c;
                return 0;
            }
            else continue;
        }
        z=(lenb+1)%2-lena;
        while (z<0)z+=2;
        while (z>=2)z-=2;
        father[dada]=dadb;
        dis[dada]=z;
    } 
    cout<<0;
    return 0;
}
```

---


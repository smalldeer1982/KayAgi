# [NOIP 2010 提高组] 乌龟棋

## 题目背景

NOIP2010 提高组 T2

## 题目描述

小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。


游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。


很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。


现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？


## 说明/提示

每个测试点 1s。

小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。


对于 $30\%$ 的数据有 $1≤N≤30,1≤M≤12$。


对于 $50\%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。


对于 $100\%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。


## 样例 #1

### 输入

```
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1
```

### 输出

```
73
```

# 题解

## 作者：吃瓜群众syc (赞：437)


[P1541 乌龟棋](https://www.luogu.org/problemnew/show/P1541)

这个题可以说运用了背包的思想:

开的主要变量：

1.F[a][b][c][d]:表示你出了a张爬行牌1，b张爬行牌2，c张爬行牌3，d张爬行牌4时的得分

2.g[x]:表示牌x一共有多少张

题干中说如何出牌,那我们就不妨DP一下每一种牌的出牌张数

初始化：

```
F[0][0][0][0]=num[1];
```

显然,乌龟开始时在num[1],题中说乌龟棋子自动获得起点格子的分数,故未出牌时（F[0][0][0][0]）分数为num[1]

之后边输入边存每一种牌的张数（输入数据第3行:M个整数，b1b2……bM，表示M张爬行卡片上的数字,故卡1~卡4张数一定）:

```cpp
for(int i=1;i<=m;i++)
{
	cin>>x;
	g[x]++;
}
```

之后便可以开始DP了:

起始状态F[0][0][0][0]=num[1]，即不出任何爬行卡;之后对于每一张卡片，我都可以选择放与不放，
E:设当前放的卡1数量为a，卡2数量为b，卡3数量为c，卡4数量为d（以下出现a~d均为这个意思），则对于卡一:

比较卡一的放与不放,只需决策卡一的放与不放，即取F[a][b][c][d],F[a-1][b][c][d]+num[r]的最大值。又由于a有一定数量,所以我们可以得出关于a的转移方程:

```cpp
	F[a][b][c][d]=max(F[a][b][c][d],F[a-1][b][c][d]+num[r])
```
其中r=1+a+b*2+c*3+d*4(至于r在a+b*2+c*3+d*4加一原因见后)

DP 数量a：

```cpp
for(int a=0;a<=g[1];a++)
{
	int r=1+a+b*2+c*3+d*4;
	if(a!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a-1][b][c][d]+num[a+b*2+c*3+d*4])
}
```
这不就是个“物品占的空间”为1，“价值”为num[r]的多重背包嘛！！
 
 至于这个(a!=0)，显然，你要是调用F[a-1][b][c][d]，肯定得保证a-1>=0吧。a显然作为卡1个数不可能<0,故取(a!=0)即可
    
根据多维背包的思想，背包DP几个“价值”（即爬行牌种类）开几维即可,故
转移方程为:
```cpp
		F[a][b][c][d]=max(F[a-1][b][c][d],F[a][b-1][c][d],F[a][b][c-1][d],F[a][b][c][d-1])+num[1*a+2*b+3*c+4*d]
```

最后DP出来的F[g[1]][g[2]][g[3]][g[4]]即为答案。


DP代码如下：
```cpp
	for(int a=0;a<=g[1];a++)
		for(int b=0;b<=g[2];b++)
			for(int c=0;c<=g[3];c++)
				for(int d=0;d<=g[4];d++)
				{
					int r=1+a+b*2+c*3+d*4;//千万千万别忘了加一,因为乌龟从num[1]出发,设前进i步，则到达num[i+1],我就是因为这调了一个小时死活没找出毛病 
					if(a!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a-1][b][c][d]+num[r]); //a!=0原因见上
					if(b!=0)    F[a][b][c][d]=max(F[a][b][c][d],F[a][b-1][c][d]+num[r]);
					if(c!=0)    F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c-1][d]+num[r]);
					if(d!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c][d-1]+num[r]);
				}	
```

在for循环中将F[a][b][c][d]与F[a-1][b][c][d]+num[1*a+2*b+3*c+4*d],F[a][b-1][c][d]+num[1*a+2*b+3*c+4*d],F[a][b][c-1][d]+num[1*a+2*b+3*c+4*d],F[a][b][c][d-1]+num[1*a+2*b+3*c+4*d]逐个比较，实现了转移方程的更新(c++中max函数貌似只能比较两个数)

当然，我们知道总牌数n和每种卡的张数，则实际写代码时我们完全可以考虑减一维,可我至今还是没想起来。。。。。。（我还是个蒟蒻）

AC代码:

```
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=41;
int F[MAXN][MAXN][MAXN][MAXN],num[351],g[5],n,m,x;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>num[i];
    F[0][0][0][0]=num[1];
    for(int i=1;i<=m;i++)
    {
        cin>>x;
        g[x]++;
    }
    for(int a=0;a<=g[1];a++)
        for(int b=0;b<=g[2];b++)
            for(int c=0;c<=g[3];c++)
                for(int d=0;d<=g[4];d++)
                {
                    int r=1+a+b*2+c*3+d*4;
                    if(a!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a-1][b][c][d]+num[r]);
                    if(b!=0)    F[a][b][c][d]=max(F[a][b][c][d],F[a][b-1][c][d]+num[r]);
                    if(c!=0)    F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c-1][d]+num[r]);
                    if(d!=0)	F[a][b][c][d]=max(F[a][b][c][d],F[a][b][c][d-1]+num[r]);
                }	
    cout<<F[g[1]][g[2]][g[3]][g[4]];
    return 0;
}
```




---

## 作者：Time_Rune (赞：137)

### 想了想还是来写一发题解吧

首先说一下思路，一开始我觉得这题用搜索+回溯再配个记忆化直接就能A，毕竟题目中有要求 “每张卡片只能使用一次”，每次搜索需要用哪一张卡片就可以解决。

结果事实证明我还是太天真了，如果用搜索的话，就算不WA也会T。

~~所以说乖乖动规吧这题的状态转移方程还算好推~~

**对于如何写题，我也就不多说了，前面已经有很多dalao把动规和另一种递归求解的方法发了，我就主要说一下状态转移方程怎么推吧，毕竟这种dp题最重要的部分就是要会推出状态转移方程**


首先，我们要弄懂题目，想清楚求解过程 ~~(废话题目都不懂拿头写吗~~

看完题目后，我们注意以下几个关键点：

### ①：从起点走到终点，每次只会前进不会后退

### ②：所有卡片一定用完且用完后正好到达终点

### ③：卡片只有四种，且数量最多也只有40

### ④：知道使用哪几张卡片后，我们就能推出现在到了哪一个位置

好，把这几个关键地方注意到了，就可以向下推方程了

首先第一个条件：它告诉我们是在用前面的条件推后面，也就是说你写for循环时，是从1到n而不是从n到1，每次状态转移也是类似f[i]=max(f[i-1],f[i])的形式而不是f[i+w[i]]+=f[i]的形式

然后第二个条件，告诉你推到最后，直接输出f[n]就可以了，某些问题没有这个条件你可能还要在f[1~n]中找一个最大值输出

第三个条件和第四个条件一起用，推出解此问题的核心：四维dp。因为卡片都是相同的，所以题中

#### “每张卡片仅能使用一次”

这个~~让人以为是搜索回溯的毒瘤~~条件就可以转化为

#### “每种卡片最多使用k次”

这样的与动态规划相接近的条件

毕竟对于一种只需要统计次数就可以了，而对于单独的一张你需要每次都开一个bool数组


（注：虽然这题是个四维dp，初学者可能会有些害怕，觉得维度上升到了四层一定非常难，其实这题的难度和某些一维dp是很接近的 ）

如果上面的都理解了，那下面我们就可以一步步写代码

首先，准备和框架

```cpp
/*
全局变量：
int f[50][50][50][50];
用来储存各种牌用到某个张数时得到的最大分数
*/

//然后用s1,s2,s3,s4(个人习惯)存各个牌的数目
for(int i=0;i<m;i++)
{...}

//根据第一条，开始写框架
	for(int i1=0;i1<=s1;i1++){
		for(int i2=0;i2<=s2;i2++){
			for(int i3=0;i3<=s3;i3++){
				for(int i4=0;i4<=s4;i4++){
                	...//下一步写主要内容
				}
			}
		}
	}
//每种状态都要涉及到，所以应该为四重循环
```
这里就体现到了①，③，④，使用四维dp并依次从前向后推

下一步，写核心：转移方程

由于有四个维度，所以每一个维度都要向前推

因为当前的状态可以由四个状态转移而来，这里就要用到一些逆推的思想：

### 平时我们都是想从这个状态可以变成什么，而在dp里却要想从什么状态可以变成这个状态

简单的推理可以得到，从每种张牌少一个的情况就加一张牌可以得到当前情况，所以我们来用前四个状态中最大的那一个来更新

得到中间代码：

```
if(i1==0&&i2==0&&i3==0&&i4==0)continue;
maxx=0;now=1+i1+2*i2+3*i3+4*i4;
if(i1!=0)maxx=max(maxx,f[i1-1][i2][i3][i4]+a[now]);
if(i2!=0)maxx=max(maxx,f[i1][i2-1][i3][i4]+a[now]);
if(i3!=0)maxx=max(maxx,f[i1][i2][i3-1][i4]+a[now]);
if(i4!=0)maxx=max(maxx,f[i1][i2][i3][i4-1]+a[now]);
f[i1][i2][i3][i4]=max(maxx,f[i1][i2][i3][i4]);
```

这样，这题也就差不多了

但还要最后的一个细节要处理一下，就是边界的问题

题目中明确地说了，一开始默认在第一格，获得第一格的分数

所以要加上 

f[0][0][0][0]=a[1];

并跳过零张牌的情况，因为对于零张牌到达它的状态是会改变的

（这一点在上面的代码中已经有体现了，注意观察）

关于目前格子的求法吗...想一下也就能写出式子了吧

### 最后，希望大家看完这篇题解并不只是会写这道题了，而是对于动态规划题状态方程的求解步骤有了新的理解，进而在其他的题目中也可以通过题意准确地退出状态转移方程，我认为这才是我写这篇题解的目的。

最后扔下AC代码，可以结合整个代码再想想过程

~~已经尽力让它看起来不丑了...~~
```
#include<iostream>
#include<cstdio>
#define il inline 
#define rg register
#define N 130
using namespace std;
int n,m;
int f[N][N][N][N];
int a[400];
int s[6];
int main(){
	scanf("%d%d",&n,&m);
	for(rg int i=1;i<=n;i++)
	scanf("%d",a+i);
	int xx;
	for(rg int i=1;i<=m;i++)
	scanf("%d",&xx);s[xx]++;
	f[0][0][0][0]=a[1];
	int maxx;
	int now;
	for(int i1=0;i1<=s[1];i1++){
		for(int i2=0;i2<=s[2];i2++){
			for(int i3=0;i3<=s[3];i3++){
				for(int i4=0;i4<=s[4];i4++){
					if(i1==0&&i2==0&&i3==0&&i4==0)continue;
					maxx=0;now=1+i1+2*i2+3*i3+4*i4;
					if(i1!=0)maxx=max(maxx,f[i1-1][i2][i3][i4]+a[now]);
					if(i2!=0)maxx=max(maxx,f[i1][i2-1][i3][i4]+a[now]);
					if(i3!=0)maxx=max(maxx,f[i1][i2][i3-1][i4]+a[now]);
					if(i4!=0)maxx=max(maxx,f[i1][i2][i3][i4-1]+a[now]);
					f[i1][i2][i3][i4]=max(maxx,f[i1][i2][i3][i4]);
				}
			}
		}
	}
	cout<<f[s[1]][s[2]][s[3]][s[4]]<<endl;
	return 0;
}
```

---

## 作者：xzlhxc_ed (赞：15)

[博客里食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p1541)   
[题目链接（洛谷1541）](https://www.luogu.org/problem/P1541)   
（如本题解有错或不理解的地方请评论或私信笔者！）  
**前置cheese：线性dp基础**    
$upd:2019.10.27$更新了滚动数组的内容。

------------
## ①题意
一个$n(0<n \le 350) $个格子的长条形棋盘，你在第1格，当你跳到第$i$个格子上就能获得大小为$a_i$的分数（你自动获得第1格的分数）。你有$m$张牌，每张牌上的数字$q$表示使用了这张牌可以跳$q$格（$1\le q \le 4$），每张牌只能使用一次，每种牌最多40张，保证能跳到第$n$格，求此过程中能得到的最大分数。

## ②动态规划思路
这种题一看很像搜索题，但搜索又太慢了，要用dp，从下面几点来考虑原因：  

1. 始终从左向右跳，你**当前许多选择跳的步数不会影响到过去的答案**。  （反过来想，如果可以往回跳，则可能存在一种打牌方法使得在某几个格子上来回跳，答案就不断增加，这就会对过去的答案产生影响） **所以满足无后效性。**

1. **跳到当前最优解的方案一定包容先前的最优解。**    
反证法：在使用相同的牌的情况下，如果存在另外一种方案跳到当前格子的分数更大，那么采用这种方法就会使答案变大，与“最优解”矛盾。   
**故满足最优子结构性质**


## ③状态转移方程
首先我们可以把所有的状态都扔进状态转移方程里去，得到：

$f(x,i,j,k,l)=max\{ f(x+1,i-1,j,k,l),f(x+2,i,j-1,k,l),f(x+3,i,j,k-1,l),f(x+4,i,j,k,l-1) \}$

其中$f(x,i,j,k,l)$表示（不考虑边界）跳到第$x$个格子，剩下$i$张走1格牌，$j$张走2格牌，$k$张走3格牌，$l$张走4格牌能得到的最大分数。

然而这样子，数组大小为$size=350*40*40*40*40>10^9$，$MLE+TLE$

所以我们要**消除冗余状态！**

由于$x$的大小可以由 $i+j*2+k*3+l*4$推出，所以没必要保存。这样的话，数组大小就变成了$40^4$，可以接受。

**枚举顺序以及边界条件由状态定义方式而定。**  需参考（第一个方程）$x$的大小变化，以及你定义的$i,j,k,l$为“剩余的卡牌数”还是“已用的卡牌数”。综合这2点，结合自己定义的状态，推一推当前状态需要从哪些状态转移过来即可得到枚举顺序。

## ④滚动数组优化
滚动数组是递推或者动态规划中的一个很常用的技巧。    

由于递推顺序固定，如果某一个状态的信息只会被使用“一轮”（不是一次），且在下一轮乃至之后都不会用到，那么**存储这个信息的内存则可能可以被再次利用，达到节省空间的目的**。   

 _以上是笔者对滚动数组的理解。_ 
 
在本题中，$f(i,j,k,l)$可以由每一维减一转移来，那么我们可以用滚动数组压掉一维。    

如果你要压掉的一维是第一维，在实现中，你可以定义为：
```cpp
int f[2][41][41][41],now=0,pre=1;
```
然后**将方程里的所有$i$替换成$now$，所有的$i-1$替换成$pre$**。    

最后在枚举$i$的循环的最后加上```swap(now,pre);```**把$now$与$pre$交换，接下来使用的就是刚才$pre$代表的空间了**。    

观察代码可得，由于```f[i-1][...][...][...]```在之后都用不到了，所以**将它覆盖掉不会影响答案**。
## ⑤AC！  
觉得好就点个赞呗！

---

## 作者：ikunTLE (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P1541)

### 思路

定义 $f_{a,b,c,d}$ 为用 $a$ 张第 $1$ 种卡片，$b$ 张第 $2$ 种卡，$c$ 张第 $3$ 种卡，$d$ 张第 $4$ 种卡所能获得的最大分值。定义 $t_i$ 为数字 $i$ 在卡片中出现的次数。由于一张卡片都没用时能获得的最大分值为 $w_1$，故初始化 $f_{0,0,0,0}=w_1$。

然后推导转移方程，每一次都会向前要一张牌的得分，故分别找 $a-1$，$b-1$，$c-1$，$d-1$。然后需要加上第 $a+2b+3c+4d+1$ 个格子的分数。

枚举 $a$ 从 $0$ 到 $t_1$，$b$ 从 $0$ 到 $t_2$，$c$ 从 $0$ 到 $t_3$，$d$ 从 $0$ 到 $t_4$。转移方程为：

$$\large f_{a,b,c,d}=\max
\begin{cases}
  f_{a-1,b,c,d}+w_{a+2b+3c+4d+1}&a\ge1\\
  f_{a,b-1,c,d}+w_{a+2b+3c+4d+1}&b\ge1\\
  f_{a,b,c-1,d}+w_{a+2b+3c+4d+1}&c\ge1\\
  f_{a,b,c,d-1}+w_{a+2b+3c+4d+1}&d\ge1
\end{cases}$$

最终答案为 $f_{t_1,t_2,t_3,t_4}$。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=4e2+10,M=50;
int w[N],d[N],dp[M][M][M][M],a[5];
int main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i)
		w[i]=read();
	for(int i=1;i<=m;++i)
		++a[read()];
	dp[0][0][0][0]=w[1];
	for(int _=0;_<=a[1];++_) for(int __=0;__<=a[2];++__) for(int ___=0;___<=a[3];++___) for(int ____=0;____<=a[4];++____){
		if(_>0) dp[_][__][___][____]=max(dp[_][__][___][____],dp[_-1][__][___][____]+w[_+__*2+___*3+____*4+1]);
		if(__>0) dp[_][__][___][____]=max(dp[_][__][___][____],dp[_][__-1][___][____]+w[_+__*2+___*3+____*4+1]);
		if(___>0) dp[_][__][___][____]=max(dp[_][__][___][____],dp[_][__][___-1][____]+w[_+__*2+___*3+____*4+1]);
		if(____>0) dp[_][__][___][____]=max(dp[_][__][___][____],dp[_][__][___][____-1]+w[_+__*2+___*3+____*4+1]);
	}
	printf("%d",dp[a[1]][a[2]][a[3]][a[4]]);
	return 0;
}
```

---

## 作者：zjy111 (赞：7)

题目是明显的动规题~~想做这题的应该都知道动规是什么的吧,不知道的可以见[OI Wiki](https://oi-wiki.org/dp/)~~

~~我这么弱,才不会告诉你我是看到这题的标签没有什么区间dp,费用流之类的东西才做这题的~~

好了言归正传,我们先来看一下动规的本质应用:(By OI Wiki,大佬自行跳过此部分)

- 动态规划应用于子问题重叠的情况：
- 1 要去刻画最优解的结构特征；
- 2 尝试递归地定义最优解的值（就是我们常说的考虑从i-1转移到i）；
- 3 计算最优解；
- 4 利用计算出的信息构造一个最优解。

我自己觉得其中最重要的是第二条,因为从i-1的最优解推到i的最优解关系到状态转移方程,也就是一个关于某一状态最优解的通式(往往是从前一个状态推出的),如果转移方程想不出来,那么再怎么做也没用。

我们来看一下这一题  [题目传送门](https://www.luogu.org/problem/P1541)

具体思路就是开一个四维数组dp a,b,c,d,对应四种卡片的张数,并记录此时的得分, 最优解分别为比当前卡片少一张的情况加上当前分数的最大值,即
```
cnt=i+j*2+k*3+l*4-9; 
dp[i][j][k][l]=dp[i][j][k][l]=max(dp[i][j][k][l],max(dp[i-1][j][k][l]+arr[cnt],max(dp[i][j-1][k][l]+arr[cnt],max(dp[i][j][k-1][l]+arr[cnt],dp[i][j][k][l-1]+arr[cnt]))));
```

我自己找了些要点和细节上注意的点:
## 尤其注意第4点(边界处理)!!!!!!

- 1: 4种卡片分别会使你前进1,2,3,4格,所以不能从前一个格子的最优解直接推后一个格子
- 2: 输入数据保证到达终点时刚好用光M张爬行卡片,不存在卡片多余的情况
- 3: 每个卡片最多使用1次,而不是每种卡片
- 4: 著名的[hehezhou](https://www.luogu.org/space/show?uid=67371)巨佬曾云: "有一种 OIer 是 for 从 1 开始的，还有一种 OIer 是 for 从 0 开始的。我是第 1 种。请问我 for 从多少开始？"  在动规的循环中,我们从1开始的会在细节上吃不少亏(比如我), 因为一开始时四张卡片均为0, 存的值应该是起点时的分值,所以上面的代码中cnt是-9而不是-10

要讲的也差不多了,献上码风奇特的代码
```
#include <bits/stdc++.h>
using namespace std;
int dp[45][45][45][45],n,m,a,b,c,d,cnt,arr[355]; //dp数组如上，arr数组记录每个点的分数,a,b,c,d分别记录4种卡牌的个数
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++)scanf("%d",&arr[i]);
	for(int i=1;i<=m;i++){
		int x;
		scanf("%d",&x);
		if(x==1)a++;
		if(x==2)b++;
		if(x==3)c++;
		if(x==4)d++;
	}  
	dp[1][1][1][1]=arr[1]; //初始化(从1开始的我调了好久......)
	for(int i=1;i<=a+1;i++){ //循环进行动规核心(从1开始的我调了好久......)
		for(int j=1;j<=b+1;j++){
			for(int k=1;k<=c+1;k++){
				for(int l=1;l<=d+1;l++){
					cnt=i+j*2+k*3+l*4-9; //边界处理(从1开始的我调了好久......)
					dp[i][j][k][l]=max(dp[i][j][k][l],dp[i-1][j][k][l]+arr[cnt]);
					dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j-1][k][l]+arr[cnt]);
					dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k-1][l]+arr[cnt]);
					dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l-1]+arr[cnt]);  //状态转移,我觉得1行太长就分4行了,其实是一样的
				}
			}
		}
	}
	cout<<dp[a+1][b+1][c+1][d+1]<<endl;  //输出(从1开始的我调了好久......)
	return 0;
}
```

---

## 作者：multiverse_ (赞：6)

数组定义解释：
		 
	1.maxn[a][b][c][d]表示使用a张第一种爬行
    牌，b张第二种爬行牌，c张第三种爬行牌，d张第四种爬行牌
	（即走到第a*1+b*2+c*3+d*4格）时所能得到的最多的分数 	
	2.vis[a][b][c][d]用来判重，表示使用a张第一种爬行牌，b张第二种爬行牌，c张第三种爬行牌，d张第四种爬行牌
	（即走到第a*1+b*2+c*3+d*4格）有没有走过 （0没走过，1走过）	
	3.p[i]（1<=i<=4）记录总共有多少张i种爬行牌	
	4.val[i] 记录第i格上的分数 
	
	做法：
	
	动规：
	从后往前（当然也可以从前往后）进行递归式的dp，到一个点：[a][b][c][d]，
	即到第a*1+b*2+c*3+d*4格 的前一步只可能是
	
		a-1,b,c,d	
		a,b-1,c,d 
		a,b,c-1,d
		a,b,c,d-1	
        
	这四种走过来的（前提是a,b,c,d不为0），所以继续递归这四种情况，
	在这四种中取最大值 ，存入maxn[a][b][c][d]。 
	
	边界条件：
	1.如果使用过a,b,c,d张这四种牌，来到过这个点，就不用做了。
	2.如果a,b,c,d都为0，即站在起点，则返回起点价值。（因为乌龟棋子自动获得起点格子的分数）
	
	答案：
	dp最后一个点的最大值（从后往前调用递归）
	dp(p[1],p[2],p[3],p[4])
  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int maxn[45][45][45][45]; 
int vis[45][45][45][45];
int p[5],val[400]; 
int dp(int a,int b,int c,int d){
	if(a==0&&b==0&&c==0&&d==0)return val[1];//返回起点价值 
	if(vis[a][b][c][d])return maxn[a][b][c][d];
	
	if(a) maxn[a][b][c][d]=max(maxn[a][b][c][d],dp(a-1,b,c,d));
	if(b) maxn[a][b][c][d]=max(maxn[a][b][c][d],dp(a,b-1,c,d));
	if(c) maxn[a][b][c][d]=max(maxn[a][b][c][d],dp(a,b,c-1,d));
	if(d) maxn[a][b][c][d]=max(maxn[a][b][c][d],dp(a,b,c,d-1));
	//四种情况 
	vis[a][b][c][d]=1;//打标记 
	maxn[a][b][c][d]+=val[a*1+b*2+c*3+d*4+1];//加一是因为：数组的起点是从1开始记录的，而不是0 
	return maxn[a][b][c][d];
}
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>val[i];
	}
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		p[x]++;//当前这一种牌的总个数加一 
	}
	cout<<dp(p[1],p[2],p[3],p[4])<<endl;
	return 0;
}
```

---

## 作者：Redamancy_Lydic (赞：4)

基础动态规划。

这道题的题目条件显然满足阶段性和无后效性，那么有一个直观的思路就是把当前所处格子和四种卡片的使用次数作为状态。

但是如果按照上面的想法，数组空间是无法开下的，所以我们稍微变一下思路，把四种卡片的使用数量作为状态，对于当前所处格子的话可以直接计算出来，这样数组空间是 $40^4\approx 2e6$ 的，可以满足。

那么思路就明确了，我们设 $dp_{i,j,k,c}$ 表示四种卡片分别使用 $i,j,k,c$ 张时所能获得的最大分数，然后用四重循环分别枚举四种卡片的使用数量，计算当前到达的位置 $x$，那么有转移方程：

$$dp_{i,j,k,c}=\max(dp_{i-1,j,k,c},dp_{i,j-1,k,c},dp_{i,j,k-1,c}，dp_{i,j,k,c-1})+a_x$$

转移的时候判断一下数组下标是否越界即可。

因为题目保证刚好用光所有卡片，那么如果设 $f_i$ 表示数字为 $i$ 的卡片的数量，答案显然为 $dp_{f_1,f_2,f_3,f_4}$。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=400;
const int inf=2e9+10;
const double eps=1e-10;
int n,m,a[maxn],b[5];
int dp[42][42][42][42];
signed main(){
#ifdef Lydic
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif
	cin>>n>>m;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)b[read()]++;
	dp[0][0][0][0]=a[1];
	for(int i=0;i<=b[1];i++){
		for(int j=0;j<=b[2];j++){
			for(int k=0;k<=b[3];k++){
				for(int c=0;c<=b[4];c++){
					int x=1+i+j*2+k*3+c*4;
					if(i)dp[i][j][k][c]=max(dp[i][j][k][c],dp[i-1][j][k][c]+a[x]);
					if(j)dp[i][j][k][c]=max(dp[i][j][k][c],dp[i][j-1][k][c]+a[x]);
					if(k)dp[i][j][k][c]=max(dp[i][j][k][c],dp[i][j][k-1][c]+a[x]);
					if(c)dp[i][j][k][c]=max(dp[i][j][k][c],dp[i][j][k][c-1]+a[x]);
				}
			}
		}
	}
	cout<<dp[b[1]][b[2]][b[3]][b[4]];
	return 0;
}

```

---

## 作者：suzhikz (赞：4)

比较简单的 dp。

考虑什么东西对答案有影响，一个是位置，一个是剩的张数。

所以我们 dp 可以直接以使用的张数为下标，位置可以直接反推，然后答案取 max 即可。


```cpp
for(int i=1;i<=m;i++){
	cin>>a;
	sum[a]++;
}
for(int i=0;i<=sum[1];i++){
	for(int j=0;j<=sum[2];j++){
		for(int k=0;k<=sum[3];k++){
			for(int l=0;l<=sum[4];l++){
				int noww=i*1+j*2+k*3+l*4+1;
				if(i!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i-1][j][k][l]);
				if(j!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j-1][k][l]);
				if(k!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k-1][l]);
				if(l!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l-1]);
				dp[i][j][k][l]+=wei[noww];
			}
		}
	}
}
```

---

## 作者：Kexi_ (赞：3)

本想打一发暴力 dp 却一发过了？

可以看到他这个卡牌的数量是特别的小，小到我们甚至可以开四维数组存储。

那么直接枚举每种卡牌使用次数即可。

细节代码中有注释。


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[400],c[5];
int dp[45][45][45][45];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=m;i++)
	{
		int k;
		cin>>k;
		c[k]++;
	}
	dp[0][0][0][0]=a[1];//题意可得，小乌龟自动获得首格分数
	for(int i=0;i<=c[1];i++)
	{
		for(int j=0;j<=c[2];j++)
		{
			for(int k=0;k<=c[3];k++)
			{
				for(int l=0;l<=c[4];l++)
				{
					int now=i+j*2+k*3+l*4+1;//这是现在到的格子

            //如果不特判不等于零就会越界
            //唐诗转移
					if(i!=0)	dp[i][j][k][l]=max(dp[i][j][k][l],dp[i-1][j][k][l]+a[now]);
					if(j!=0)	dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j-1][k][l]+a[now]);
					if(k!=0)	dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k-1][l]+a[now]);
					if(l!=0)	dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l-1]+a[now]);
				}	
			}
		}
	}
	cout<<dp[c[1]][c[2]][c[3]][c[4]];
	return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

典型的动态规划。

设 $f_{a, b, c, d}$ 表示每种卡片分别用了 $a$ 张、$b$ 张、$c$ 张、$d$ 张时所得最大分数，那么此时应在第 $a + 2b + 3c + 4d +1$ 个格子，当前由 $f_{a-1, b, c, d}, f_{a, b-1, c, d}, f_{a, b, c-1, d}, f_{a, b, c, d-1}$ 转移得到，再加上当前格子的分数。

设 $g_i$ 表示第 $i$ 种卡片的数量，答案就是 $f_{g_1, g_2, g_3, g_4}$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, x, s[355], g[5], f[41][41][41][41];
int main(){
	cin >> n >> m;
	for(int i=1; i<=n; i++) cin >> s[i];
	for(int i=1; i<=m; i++) cin >> x, g[x]++;
	for(int a=0; a<=g[1]; a++)	
		for(int b=0; b<=g[2]; b++)
			for(int c=0; c<=g[3]; c++)
				for(int d=0; d<=g[4]; d++){
					if(a) f[a][b][c][d]=max(f[a][b][c][d], f[a-1][b][c][d]);
					if(b) f[a][b][c][d]=max(f[a][b][c][d], f[a][b-1][c][d]);
					if(c) f[a][b][c][d]=max(f[a][b][c][d], f[a][b][c-1][d]);
					if(d) f[a][b][c][d]=max(f[a][b][c][d], f[a][b][c][d-1]);
					f[a][b][c][d]+=s[a+b*2+c*3+d*4+1];
				}
	cout << f[g[1]][g[2]][g[3]][g[4]];
}
```

---

## 作者：kuaiCreator (赞：2)

## 题目大意
给 $n$ 个格子，每个格子上都有一定的分数。再给 $m$ 张数值为 $1$ 到 $4$ 的卡片，卡片上的数值代表前进的步数，每张卡片只能用一次。每到达一个格子就可以拿走该分数，问所有卡片用光时能够获得的最大分数。

## 解题思路
一眼动态规划，上动态规划**六步分析法**。
### 一、定义问题状态
题目中共计四种卡片，每种卡片的数量与得分之间有联系，状态非常好设计。

$f(a,b,c,d)$ 表示第 $1$ 种卡片使用 $a$ 张，第 $2$ 种卡片使用 $b$ 张，第 $3$ 种卡片使用 $c$ 张，第 $4$ 种卡片使用 $d$ 张时的最大分值。
### 二、分解子问题
分解子问题的目的是将问题拆分为相似的规模更小的问题，从而得到，子问题与原问题之间的**状态转移方程**。分解子问题时需要考虑，决策与约束条件。

$$f(a,b,c,d)=\max\begin{cases}f(a-1,b,c,d) + sc[step] & a\ge 1\\ f(a,b-1,c,d) + sc[step] & b\ge 1\\ f(a,b,c-1,d) + sc[step] & c\ge 1\\f(a,b,c,d-1) + sc[step] & d\ge 1\end{cases}$$

其中 $ step=a+2\times b+3\times c+4\times d+1$

### 三、初始化边界状态
边界状态即为不需要计算就能直接分析出的状态。这里是一张卡片都没有用时得分为在第 $1$ 格处的分数。

$$f(0,0,0,0)=sc[1]$$

### 四、计算顺序
从小到大依次枚举卡片 $1$ 至 $4$ 的张数。
### 五、最终答案
$$ans=f(cnt1,cnt2,cnt3,cnt4)$$

其中 $cnt1$ 至 $cnt4$ 表示第 $1$ 至第 $4$ 张卡片的总数量。

### 六、效率分析
时间复杂度和空间复杂度度都为 $O(n^4)$ 这里 $n$ 代表每种卡片的最大数量为 $40$ 没有超时和超空间。


## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 10005;
int n, m, a[maxn], b, cnt[5], f[52][52][52][52];

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	for(int i = 1; i <= m; i++){
		cin >> b;
		cnt[b]++;
	}
	f[0][0][0][0] = a[1];
	for(int i = 0; i <= cnt[1]; i++)
		for(int j = 0; j <= cnt[2]; j++)
			for(int k = 0; k <= cnt[3]; k++)
				for(int l = 0; l <= cnt[4]; l++){
					int step = i+2*j+3*k+4*l+1;
					if(i) f[i][j][k][l] = max(f[i][j][k][l], f[i-1][j][k][l] + a[step]);
					if(j) f[i][j][k][l] = max(f[i][j][k][l], f[i][j-1][k][l] + a[step]);
					if(k) f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k-1][l] + a[step]);
					if(l) f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k][l-1] + a[step]);
				}
	cout << f[cnt[1]][cnt[2]][cnt[3]][cnt[4]];
	return 0;
}
```

---

## 作者：yuxinrui0618 (赞：1)

# 题解：P1541 [NOIP2010 提高组] 乌龟棋
## 1. 题目大意
- 玩家每次需要从所有的卡片中选择一张**之前没有使用过**的卡片，控制乌龟棋子前进相应的格子数，**每张卡片只能使用一次**；
- 每到达一个格子，就得到该格子相应的分数。要使总分数最高。

## 2. 思路
- 用 $f _ {i,j,k,l}$ 表示每种卡片分别用了 $i$ 张、$j$ 张、$k$ 张、$l$ 张所能得到的最大分数；
- $f _ {i,j,k,l}$ 可以从 $f _ {i-1,j,k,l}$，$f _ {i,j-1,k,l}$，$f _ {i,j,k-1,l}$，$f _ {i,j,k,l-1}$ 推过来，再分别加上该位置（即 $a _ {i+j\times2+k\times3+l\times4+1}$），取最大值。

## 3. 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[400],b[150],f[41][41][41][41],c[5];
int main(){
    int n,m;
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        cin>>a[i];
    for (int i=1;i<=m;i++)
    {
        cin>>b[i];
        c[b[i]]++;
    }
    f[0][0][0][0]=a[1]; //设置初始值
    for (int i=0;i<=c[1];i++)
        for (int j=0;j<=c[2];j++)
            for (int k=0;k<=c[3];k++)
                for (int l=0;l<=c[4];l++)
                {
                	if (i)
                		f[i][j][k][l]=max(f[i][j][k][l],f[i-1][j][k][l]+a[i+j*2+k*3+l*4+1]);
                	if (j)
                		f[i][j][k][l]=max(f[i][j][k][l],f[i][j-1][k][l]+a[i+j*2+k*3+l*4+1]);
                	if (k)
                		f[i][j][k][l]=max(f[i][j][k][l],f[i][j][k-1][l]+a[i+j*2+k*3+l*4+1]);
                	if (l)
                		f[i][j][k][l]=max(f[i][j][k][l],f[i][j][k][l-1]+a[i+j*2+k*3+l*4+1]);
                }
                    
    cout<<f[c[1]][c[2]][c[3]][c[4]];
    return 0;
}
```

## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：glass_goldfish (赞：1)

比较简单的动规。

我们记 $f_{i,j,k,p}$ 为使用了 $i$ 张走 $1$ 步的卡牌，使用了 $j$ 张走 $2$ 步的卡牌，使用了 $k$ 张走 $3$ 步的卡牌，使用了 $p$ 张走 $4$ 步的卡牌之后，能获得的最大分数。边界条件很简单：$f_{0,0,0,0}=a_1$，因为在没有使用卡牌的时候乌龟棋子就在起点，获得了起点的分数。  

以下是转移主过程：  
首先，计算出当前到达的格子的编号（记为 $now$）：$1+i+2\times j+3\times k+4\times p$（别忘了加上 $1$，因为起点是 $1$ 号格子）。接着，开始转移：  
如果 $i>0$（即使用了至少 $1$ 张走 $1$ 步的卡牌），那么 $f_{i,j,k,p}$ 可能为 $f_{i-1,j,k,p}+a_{now}$；  
如果 $j>0$（即使用了至少 $1$ 张走 $2$ 步的卡牌），那么 $f_{i,j,k,p}$ 可能为 $f_{i,j-1,k,p}+a_{now}$；  
如果 $k>0$（即使用了至少 $1$ 张走 $3$ 步的卡牌），那么 $f_{i,j,k,p}$ 可能为 $f_{i,j,k-1,p}+a_{now}$；  
如果 $p>0$（即使用了至少 $1$ 张走 $4$ 步的卡牌），那么 $f_{i,j,k,p}$ 可能为 $f_{i,j,k,p-1}+a_{now}$。  
最终的 $f_{i,j,k,p}$ 的值就是所有可能值中最大的一个。

先统计一下有四种爬行卡片分别有多少张（走 $1$ 步的爬行卡片数量记为 $c_1$，以此类推），然后输出答案：$f_{c_1,c_2,c_3,c_4}$。

代码（有些变量可能和题解中不相同，请勿在意）：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int n,m,a[501],x,b[11];
int f[41][41][41][41];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++)
		cin>>x,b[x]++;//统计
	f[0][0][0][0]=a[1];//边界
	for(int i1=0;i1<=b[1];i1++)
	for(int i2=0;i2<=b[2];i2++)
	for(int i3=0;i3<=b[3];i3++)
	for(int i4=0;i4<=b[4];i4++){
		int now=1+i1+i2*2+i3*3+i4*4;
		if(i1)f[i1][i2][i3][i4]=max(f[i1][i2][i3][i4],f[i1-1][i2][i3][i4]+a[now]);
		if(i2)f[i1][i2][i3][i4]=max(f[i1][i2][i3][i4],f[i1][i2-1][i3][i4]+a[now]);
		if(i3)f[i1][i2][i3][i4]=max(f[i1][i2][i3][i4],f[i1][i2][i3-1][i4]+a[now]);
		if(i4)f[i1][i2][i3][i4]=max(f[i1][i2][i3][i4],f[i1][i2][i3][i4-1]+a[now]);//转移
	}
	cout<<f[b[1]][b[2]][b[3]][b[4]];//输出
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

卡片张数不大，考虑存卡片张数直接 dp。设 $dp_{i_1,i_2,i_3,i_4}$ 表示目前用了 $i_k$ 张标有 $k$ 的卡片，现在在第 $i_1+2i_2+3i_3+4i_4+1$ 个格子。那么 $dp_{i_1,i_2,i_3,i_4}$ 就可以由 $dp_{i_1-1,i_2,i_3,i_4}$ 等转移过来。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rp(k) for(i[k]=0; i[k]<=t[k]; i[k]++)
#define nw a[i[0]+i[1]*2+i[2]*3+i[3]*4+1]
#define dpnw dp[i[0]][i[1]][i[2]][i[3]]

const int MAXN=352,N=42;
int a[MAXN];
int dp[N][N][N][N];
int t[4],i[4];

int main(){
	int n,m;cin>>n>>m;
	for(int c=1; c<=n; c++) cin>>a[c];
	for(int c=1; c<=m; c++){int b;cin>>b;t[b-1]++;}
	dp[0][0][0][0]=a[1];
	rp(0) rp(1) rp(2) rp(3){
		if(i[0]) dpnw=max(dpnw,dp[i[0]-1][i[1]][i[2]][i[3]]+nw);
		if(i[1]) dpnw=max(dpnw,dp[i[0]][i[1]-1][i[2]][i[3]]+nw);
		if(i[2]) dpnw=max(dpnw,dp[i[0]][i[1]][i[2]-1][i[3]]+nw);
		if(i[3]) dpnw=max(dpnw,dp[i[0]][i[1]][i[2]][i[3]-1]+nw);
	}
	cout<<dp[t[0]][t[1]][t[2]][t[3]];
	return 0;
}
```

---

## 作者：Eason_cyx (赞：1)

不难的线性 DP。

-----

考虑 $f_{a,b,c,d}$ 表示用了 $a$ 张爬行 $1$ 格的牌，$b$ 张爬行 $2$ 格的牌，以此类推。那么答案就是 $f_{ca,cb,cc,cd}$，其中这四个数分别是四种牌的数量。至于状态转移方程？也简单，从当前状态中任意删掉一张牌，然后在四种情况中取最大值即可。注意如果某种牌目前一张都没用，那么是不计算他的。整体方程较长，可以看代码。

时间复杂度为 $O(n^4)$，而且最劣情况下运算量也大约是 $\dfrac{n^4}{256}$，实际上一般情况完全比最劣情况的运算量还要少，因此可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[41][41][41][41];
int a[355];
int main() {
	int n,m; cin >> n >> m;
	int sa = 0,sb = 0,sc = 0,sd = 0;
	for(int i = 1;i <= n;i++) {
		cin >> a[i];
	}
	for(int i = 1,x;i <= m;i++) {
		cin >> x;
		if(x == 1) sa++;
		if(x == 2) sb++;
		if(x == 3) sc++;
		if(x == 4) sd++;
	}
	f[0][0][0][0] = a[1];
	for(int i = 0;i <= sa;i++) {
		for(int j = 0;j <= sb;j++) {
			for(int k = 0;k <= sc;k++) {
				for(int l = 0;l <= sd;l++) {
					if(i) f[i][j][k][l] = max(f[i][j][k][l],f[i-1][j][k][l]+a[i+2*j+3*k+4*l+1]);
					if(j) f[i][j][k][l] = max(f[i][j][k][l],f[i][j-1][k][l]+a[i+2*j+3*k+4*l+1]);
					if(k) f[i][j][k][l] = max(f[i][j][k][l],f[i][j][k-1][l]+a[i+2*j+3*k+4*l+1]);
					if(l) f[i][j][k][l] = max(f[i][j][k][l],f[i][j][k][l-1]+a[i+2*j+3*k+4*l+1]);
				}
			}
		}
	}
	cout << f[sa][sb][sc][sd] << endl;
	return 0;
}
```

---

## 作者：WsW_ (赞：1)

### 思路
先设计状态，$dp_{i,j,k,l}$ 表示用了 $i$ 张 $1$、$j$ 张 $2$、$k$ 张 $3$、$l$ 张 $4$ 所能得到的最大分数。  
为什么状态中没有当前格子呢？因为从 $1$ 出发，消耗固定的牌必定到达一个确定的格子。例如消耗 $i$ 张 $1$、$j$ 张 $2$、$k$ 张 $3$、$l$ 张 $4$，必定第 $1+i+j\times2+k\times3+l\times4$ 个格子。 

根据题意可知 $dp_{0,0,0,0}=a_1$。  
直接从小到大枚举每种牌消耗了多少张即可，非常好转移。$dp_{i,j,k,l}$ 就从 $dp_{i-1,j,k,l},dp_{i-1,j,k,l},dp_{i,j,k-1,l},dp_{i,j,k,l-1}$ 转移过来。  
时间复杂度为 $O\left(M^4\right)$，而且带有 $\frac{1}{4^4}$ 的常数。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
int n,m;
int a[355],b,cnt[5];
int dp[43][43][43][43];

int g(int i,int j,int k,int l){
	return i+j*2+k*3+l*4+1;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++){
		cin>>b;
		cnt[b]++;//统计每种牌的数量
	}
	dp[0][0][0][0]=a[1];//初始
	for(int i=0;i<=cnt[1];i++)
	for(int j=0;j<=cnt[2];j++)
	for(int k=0;k<=cnt[3];k++)
	for(int l=0;l<=cnt[4];l++){
		int x=g(i,j,k,l);//计算当前位置
		if(i!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i-1][j][k][l]+a[x]);
		if(j!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j-1][k][l]+a[x]);
		if(k!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k-1][l]+a[x]);
		if(l!=0)dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l-1]+a[x]);
	}
	cout<<dp[cnt[1]][cnt[2]][cnt[3]][cnt[4]];
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

题解：[P1541 \[NOIP2010 提高组\] 乌龟棋](https://www.luogu.com.cn/problem/P1541)

### 思路

感觉这道题并没有绿题的难度。

首先看到数据范围，可以发现这里的数据范围都非常小，且每一种卡牌的数量均不会超过 $40$，那么这道题就非常简单了。

考虑使用动态规划算法。

1. 状态定义\
   我们定义 $f_{i, j, k, l}$ 为使用了 $i$ 张 $1$ 号牌，$j$ 张 $2$ 号牌，$k$ 张 $3$ 号牌，$l$ 张 $4$ 号牌所能获得的最大价值。
2. 状态转移 \
   我们采用四重循环来解决状态转移的问题，四重循环分别枚举使用了这四种牌的数量，$i$，$j$，$k$，$l$ 分别表示使用了 $i$ 张 $1$ 号牌，$j$ 张 $2$ 号牌，以此类推。

则每一种转移的代码如下：

```cpp
int dsj = 1 + i + j * 2 + k * 3 + l * 4; // 走到了哪里
if (i) {
  f[i][j][k][l] = max(f[i][j][k][l], f[i - 1][j][k][l] + a[dsj]); // 1号牌
}
if (j) {
  f[i][j][k][l] = max(f[i][j][k][l], f[i][j - 1][k][l] + a[dsj]); // 2号牌
}
if (k) {
  f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k - 1][l] + a[dsj]); // 3号牌
}
if (l) {
  f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k][l - 1] + a[dsj]); // 4号牌
}
```

3. 答案 \
   最后的答案就非常明显了，就是 $f_{k1, k2, k3, k4}$，$k_{i}$ 表示每一种牌的数量。

### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 355 + 4, kMaxM = 40;

int n, m, b[kMaxN], a[kMaxN], f[kMaxM][kMaxM][kMaxM][kMaxM];

map<int, int> K;

int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= m; i++) {
    cin >> b[i], K[b[i]]++;
  }
  f[0][0][0][0] = a[1];
  for (int i = 0; i <= K[1]; i++) {
    for (int j = 0; j <= K[2]; j++) {
      for (int k = 0; k <= K[3]; k++) {
        for (int l = 0; l <= K[4]; l++) {
          int dsj = 1 + i + j * 2 + k * 3 + l * 4;
          if (i) {
            f[i][j][k][l] = max(f[i][j][k][l], f[i - 1][j][k][l] + a[dsj]);
          }
          if (j) {
            f[i][j][k][l] = max(f[i][j][k][l], f[i][j - 1][k][l] + a[dsj]);
          }
          if (k) {
            f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k - 1][l] + a[dsj]);
          }
          if (l) {
            f[i][j][k][l] = max(f[i][j][k][l], f[i][j][k][l - 1] + a[dsj]);
          }
        }
      }
    }
  }
  cout << f[K[1]][K[2]][K[3]][K[4]] << '\n';
  return 0;
}

```

---


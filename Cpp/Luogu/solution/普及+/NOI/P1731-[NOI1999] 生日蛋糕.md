# [NOI1999] 生日蛋糕

## 题目背景

[数据加强版 link](https://www.luogu.com.cn/problem/T148457)

## 题目描述

7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 $N\pi$ 的 $M$ 层生日蛋糕，每层都是一个圆柱体。

设从下往上数第 $i$（$1 \leq i \leq M$）层蛋糕是半径为 $R_i$，高度为 $H_i$ 的圆柱。当 $i \lt M$ 时，要求 $R_i \gt R_{i+1}$ 且 $H_i \gt H_{i+1}$。

由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 $Q$ 最小。

请编程对给出的 $N$ 和 $M$，找出蛋糕的制作方案（适当的 $R_i$ 和 $H_i$ 的值），使 $S=\dfrac{Q}{\pi}$ 最小。

（除 $Q$ 外，以上所有数据皆为正整数）

## 样例 #1

### 输入

```
100
2
```

### 输出

```
68```

# 题解

## 作者：Zcus (赞：508)

[题面传送门](https://www.luogu.org/problem/show?pid=1731)

###如果不懂DFS，请自觉睡觉；

###如果不懂剪枝，请自觉睡觉；


啊哈，大家的思路一定和我一样——DFS，找个数组存储半径和高，可是如单单使用DFS不加剪枝的话，10分——20分。

所以，我们来想一想如何剪枝

###1.当前的奶油面积+之后的最小奶油面积>现在已求出的的最小奶油面积——果断return；

###2.当前的体积>n,return;

###3.当前的体积+之后的最大体积<体积总数，果断return；

###4.发现每次枚举半径和高时，是从上一个的半径和高，***到还剩下的层数***。为什么呢，是因为每一层的半径和高都要比下一层的小1，所以你得每一层都留一个1，so，是从上一个的半径和高，***到还剩下的层数***；

OK，现在我们加上剪枝之后就可以A了

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
int r[30],h[30],minn=2147483647,n,m;
void dfs(int x,int y,int k,int z)
{  if(y<0) return;
    if(x>m+1) return;
     if(k>=minn) return;
    if(y==0&&x==m+1)
    {  k+=r[1]*r[1];
         if(k<minn) minn=k;
         return;
    }
    if(k+z+r[1]*r[1]>minn) return;
   if(y-(r[x-1])*(r[x-1])*(h[x-1])*z>0) return;
    for(int i=r[x-1]-1;i>=z;i--)
      for(int j=h[x-1]-1;j>=z;j--)
      {
            if(y-i*i*j>=0&&x+1<=m+1)
             {     r[x]=i;
                   h[x]=j;
                    dfs(x+1,y-i*i*j,k+(i*2*j),z-1);
                   h[x]=0;
                   r[x]=0;
             }
      }
}
int main()
{
    scanf("%d%d",&n,&m);
    r[0]=(int)sqrt(n);
    h[0]=(int)sqrt(n);
    dfs(1,n,0,m);
    if(minn==2147483647) printf("%d",0);
      else printf("%d",minn);
    return 0;
}
```
记得，顶一下


---

## 作者：碳六灵 (赞：119)

这道搜索水题 有点干燥

几百年前的全国赛怎么比现在的容易这么多 虽然我就是个普及蒟蒻 但是居然做出来了

···
/**************************

Name:1731 birthday cake

How to get:luogu.org

By:Shine\_Sky

**************************/

/*******************************

这道题一看就是用骗分神器--深搜!

我们从下层往上层搜,并且记录上一次的h和r

枚举这一层的h和r 到了最上面一层

判断是否答案合法 如果合法就取最小保存

但是如果不剪枝肯定会T的 所以我们得剪枝

如果只有两重 那么经过测试也是T所以还得一层

就是这三层①要是剩下体积除以最大(虽然取不到)半径所得到的表面积+累计表面积大于答案退出

② 要是剩下来的体积已经小于该层最小体积了就退出

③
还有 为了剪枝,我们要起先预处理某一层的最大不可的表面积和体积

要注意的是 如果ans没有更新那么就说明不解 可以用flag判断

但是我就不 要是最小面积+当前累计表面积已经比已知答案大了就退出

*******************************/




    

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define f(i,a,b)    for(register int i=a;i<=b;++i)
#define fd(i,a,b)    for(register int i=a;i>=b;--i)
using namespace std;
const int N=20000+7;
int ans=987654321,n,m,Minv[N],Mins[N];
inline int read()//读入优化
{
      int num=0;
      char c;
      while(isspace(c=getchar()));
      while(num=num*10+c-48,isdigit(c=getchar()));
      return num;
}
bool flag=1;
inline void dfs(int now,int S,int V,int lasth,int lastr)
{
    if(now==0)//要是已经到了第一层就退出 
    {
        if(V==n)    ans=min(ans,S);//是否为合法答案 
        return;
    }
    //三重恶心的剪枝 
    if(S+2*(n-V)/lastr>ans)    return;
    //要是剩下体积除以最大(虽然取不到)半径所得到的表面积+累计表面积大于答案 退出 
    if(V+Minv[now]>n) return;//要是剩下来的体积已经小于该层最小体积了就退出 
    if(S+Mins[now]>ans)    return;//要是最小面积+当前累计表面积已经比已知答案大了就退出 
    fd(i,lastr-1,now)//从大到小枚举该层半径 
    {
        if(/*flag*/ now==m)    S=i*i;//要是现在是第一层那么就直接加上最小表面积 
    //    flag=0;
        int Maxh=min(lasth-1,(n-V-Minv[now-1])/(i*i));
        fd(j,Maxh,now)//从大到小枚举该层高度 
            dfs(now-1,S+2*i*j,V+i*i*j,j,i);
    }
}
int main()
{
    n=read();m=read();
    f(i,1,m)
        Minv[i]=Minv[i-1]+i*i*i,//cout<<Minv[i]<<endl,
        Mins[i]=Mins[i-1]+2*i*i;//cout<<Mins[i]<<endl;
    int MaxR=sqrt(n);
    dfs(m,0,0,n,MaxR);
    printf("%d",ans==987654321 ? 0 :ans);
    return 0;
}
···
```

---

## 作者：pyyyyyy (赞：109)

## [博客食用效果更佳,求赞╮(╯_╰)╭](https://www.cnblogs.com/pyyyyyy/p/11123220.html)

# 题目链接

[P1731 [NOI1999]生日蛋糕](https://www.luogu.org/problemnew/show/P1731)

# 思路

搜索+**剪枝**


用$mins[i]$表示第$i$层最小的表面积$minv[i]$表示第$i$层最小体积，设最底层为第$n$层，枚举每一层的高和半径。

不过复杂度这样复杂度上天

所以要加上优化（剪枝）

我们先来看一下下题目中的几个细节：

>当$i<M$时，要求$R_i>R_{i+1}且H_i>H_{i+1}$

这句好就告诉我们一个事情，当我们**枚举半径和高度时是可以确定上下界**的，这就是剪枝一

第二个细节：

![](https://cdn.luogu.com.cn/upload/pic/524.png)

看一下这个图就会发现最下面那一层的底面积是不是就是上面的上表面积之和(也就是下图涂黑的地方)

![](https://i.loli.net/2019/07/02/5d1b57d58b31e11394.png)

这么看来我们只要枚举到最下层是记录一下$i \times i$就不用考虑涂黑的部分了，简化了程序


再看其他的剪枝:

>1.如果当前搜索到的最小表面积已经大于了已知的最小表面积直接退出

>2.如果当前搜索到的体积已经超过题目限制，则退出

>3.如果由体积推出来当前的表面积已经不优直接退出


# 总结：
1.枚举半径和高度时是可以确定上下界

2.如果当前搜索到的最小表面积已经大于了已知的最小表面积直接退出

3.如果当前搜索到的体积已经超过题目限制则退出

4.如果由体积推出来当前的表面积已经不优直接退出


# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
//体积公式:v=piRH
//侧面积:2piRH
//底面积:piR^2
const int MAXN=0x3f3f3f;
const int N=20007;
int ans=MAXN;
int mins[N],minv[N],n,m;
void dfs(int now,int r,int h,int s,int v) {
	//  当前层数 半径  高度 面积  体积
	int MAXN_high=h;
	if(now==0) {
		if(v==n) {
			ans=min(ans,s);
		}
		return ;
	}
	if(s+mins[now-1]>=ans) return ;//如果面积已经大于了目前的最优值ans就可以退出了
	if(v+minv[now-1]>n) return;//如果当前搜到的体积已经大于了题目给定的体积就可以退出了
	if(2*(n-v)/r+s>=ans)  return; //由体积推出的表面积已经大于最大值了就可以退出了
	for(int i=r-1; i>=now; --i) {//枚举半径
		if(now==m) s=i*i;//此处是处理最下面的那个面其实也就是上面的那个，可以看一下解释
		MAXN_high=min(h-1 ,(n-minv[now-1]-v)/i/i);//求出最大的高度来
		for(int j=MAXN_high; j>=now; --j) {
			dfs(now-1,i,j,s+2*i*j,v+i*i*j);
		}
	}
}
int main() {
	cin>>n>>m;
	/*初始化每层成最小的表面积和体积*/
	for(int i=1; i<=m; ++i) {
		mins[i]=mins[i-1]+2*i*i;//计算面积
		minv[i]=minv[i]+i*i*i;//计算体积
	}
	dfs(m,n,n,0,0);//开始dfs喽
	if(ans==MAXN) cout<<0<<'\n';
	else cout<<ans<<'\n';
	return 0;
}
```




---

## 作者：Fellyhosn (赞：102)

###  第一步：预处理
定义 a,b数组，存储第i层最多能用的表面积和体积，便于优化

### 第二步：深度优先搜索
定义search函数，负责搜索

递归结束条件是：

1：蛋糕已完成，即层数p==m

2：体积超过了预定的值，或者表面积超过了之前存储的最小值ans

## 第三步：寻找优化方案！
这步尤为重要，没有合适的优化方案会导致超时

##### 1：对于体积
在第一步已经完成了对最大体积的预处理，所以只需要用当前体积加上b[i-1],判断是否大于了规定体积n即可

即： if(v+b[p-1]>n) return ;//体积超出
##### 2：对于表面积

如果 当前的表面积+余下的侧面积>当前最优值ans （这个应该很简单证明）

但是，如何实现呢？？？

于是就有了接下来的公式推理
~~~
设已经做了i层蛋糕,则还需做m-i层, 

Si’：为第i层蛋糕的侧面积,       
FSi：余下的侧面积

根据定义：
     V=π*R*R*H（在这里统一删掉π）
     则有：
      2Vi= 2R[i+1] * R[i+i] * H[i+1] + ...+ 2Rm * Rm * Hm
                      （每一层的体积之和）
         = R[i+1] *  S[i+1]’ + ...+ Rm * Sm’
         ≤ R[i+1] * (S[i+1]’+ ...+ Sm’)    放缩法
         = R[i+1]*FSi (剩余侧面积)
 所以:
               FSi ≥ 2Vi / Ri+1 
  ~~~
因此，剪枝条件变为了
###  2*(n-v)/r+s>=ans 
于是前面预处理的a数组就可以去掉了

第三步完成

## 综合这三步编写代码，愉快的AC
~~~
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int a[21],b[21],m,n,ans;//a存储表面积,b存储体积 
void search(int v,int s,int p,int r,int h)//v为已用体积，s为已有表面积，p为剩余层数，r为半径，h为高 
{
	int i,j,hh;
	if (p==0)//蛋糕已完成
		{
	    if (v==n&&s<ans)//判断是否符合要求并得到更优解
				ans=s;//更新最优解
	    return ;
		}
		if(v+b[p-1]>n) return ;//体积超出 
		//if(s+a[p-1]>ans) return ;//表面积超出 
		if(2*(n-v)/r+s>=ans)  return; //重点：当前的表面积+余下的侧面积>当前最优值
		//剩余表面积FS>=2*V剩/r   
		//若FS+s>=ans 则不符合 
         for(i=r-1;i>=p;i--)//枚举上一层的半径
         {
         	if(p==m) s=i*i;
         	hh=min((n-v-b[p-1])/(i*i),h-1);
         	for(j=hh;j>=p;j--)//枚举上一层的高
         	search(v+i*i*j,s+2*i*j,p-1,i,j);
		 }
}
int main()
{
	  cin>>n>>m;
	  ans=2147483647;
	  a[0]=b[0]=0;
	  for(int i=1;i<21;i++)
	  {
	   //a[i]=a[i-1]+2*i*i;//第i层使用的最大表面积 
	    b[i]=b[i-1]+i*i*i;//第i层使用的最大体积 
	  }
	  search(0,0,m,n+1,n+1);
	  if(ans==2147483647) cout<<'0';
	  else cout<<ans;
	  return 0;
}
~~~

---

## 作者：DEVILK (赞：23)

更好的阅读体验点这里：[博客传送门](https://www.cnblogs.com/devilk-sjj/p/9090470.html)

[算法分析：]

就是搜索啊搜索啊搜索，但是要剪枝啊剪枝啊剪枝啊

~~像我这么弱连这道题的搜索都要调试的人应该是没有几个了~~..

观察一个蛋糕的俯视图，上表面的面积其实就是最下面那一层的底面积，所以在第一次搜索的时候加入这个底面积，之后就只用考虑侧面积就好啦.

就是每次枚举r和h，如何选取上下界呢？

将上一层的高度记作lh，上一层的半径记作lr，则上界很好判断，就是$lh-1$和$lr-1$，

底层应该是选取$\sqrt[3]{20000}$约为28的范围

现在考虑下界：

~~自然选取1是会T得很惨的~~，下界就是最小值嘛，最上面一层的$r$和$h$的最小值都是$1$啊，那还有几层下界就是几啦！

然后来~~愉快~~地剪枝：

比较好想的剪枝是这两个：

1.    当当前的面积总和已经超过之前的答案时，$return$

2.    当当前体积超过了要求的体积时，$return$

还有一些剪枝，思维难度也不算高：

*    当现在的已有体积加上之后的最大~~（并不是真正的最大，会比最大还要大一些）~~体还要小于要求的体积时，$return$

*    当当前的已有面积加上之后的最小~~（自然也是比真正的最小还要小一些）~~面积比已有答案还要大时，$return$

关于搜索顺序的选择：

这个东西..就是一个玄学...一共有$A_2^2\ A_2^2$种选择自己试试就好啦（雾

$[Code:]$

```cpp
#include<iostream>
#include<cstdio>
#define re register
using namespace std;

int ans = 2e9;
int n, m;

void dfs(int t, int s, int v, int lr, int lh) {
	if(s >= ans) return;
	if(t == m+1 && v == n) {
		ans = min(ans, s);
		return;
	}
	if(v >= n) return;
	int k = m - t + 1;
	if(k * lr * lr * lh + v < n) return;
	if(k * 2 + s > ans) return;
	if(t == 1) {
		for(re int r=lr; r>=m; --r) {
			for(re int h=m; h<=lh; ++h) {
				dfs(t + 1, s + r * r + 2 * r * h, v + r * r * h, r, h);
			}
		}
	}
	else for(re int r=lr-1; r>=m-t+1; --r) {
		 	for(re int h=m-t+1; h<lh; ++h) {
			 	dfs(t + 1, s + 2 * r * h, v + r * r * h, r, h);
		 	}
		}
}

int main() {
	scanf("%d%d", &n, &m);
	dfs(1, 0, 0, 28, 28);
	if(ans == 2e9) puts("0");
	else printf("%d\n", ans);
}
```

---

## 作者：租酥雨 (赞：19)

果断DFS，所以怎么去搜呢？

我们先要解决一个问题：表面积怎么算？数学好的同学已经看出来了，就是每一层的侧面积（S=2pi\*r\*h）加上最下面一层的底面积（S=pi\*r^2），消去pi就好了

首先建立整体的框架：dfs函数从下往上搜，标记当前的层数、已使用过的总表面积和体积（这个是便于剪枝）、下方一层的半径和高度（因为上面一层需要使用）。从第M层开始搜，到第0层时判断已使用体积是否等于总体积。

整体框架出来了，但这么打肯定TLE。所以我们要去剪枝。

因为蛋糕要上小下大，我们假设第一层（最上面一层）的半径为1，高度为1（不能再小了），那么第二层高度就要为2，半径也至少为2，以此类推...那么我们自然可以得出自上而下前n层的最小体积、最小表面积。那么我们每次dfs时就可以判断：

如果当前已使用总体积+上方层数的最小体积>输入要求的体积，就直接剪掉；

如果当前已使用总表面积+上方层数的最小表面积>最优解，就直接剪掉（最优化剪枝）。

应用上述剪枝可以跑过7个点（3个TLE）

因为我们只对表面积和体积进行了分别判断，而这二者明显是有内在联系的。

体积V=pi\*r\*r\*h，侧面积S=2\*pi\*r\*h，可推证出若体积一定，半径越大表面积就越小（相对）

所以我们可以假设剩余的体积全部以当前层的半径做成蛋糕，因为当前的半径的最大的，所以得出的表面积是最小的，根据这个“最小表面积”判断表面积是否超过最优解，超出则剪掉（最优化剪枝）

代码




```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define oo 2147483647
using namespace std;
int NN,M,N,ans=oo;
int ss[21],sv[21];
inline void dfs(int t,int S,int V,int lR,int lH)//层数，已用总面积，已用总体积，上一层半径 ，上一层高度
{
    if (t==0)
    {
        if (V==N) ans=min(ans,S);
        return ;
    }
    if (V+sv[t]>N) return ;//分别对应上述3个剪枝，其中2、3是最优化剪枝 
    if (S+ss[t]>ans) return ;
    if (S+2*(N-V)/lR>ans) return ;
    for (int r=lR-1;r>=t;r--)
    {
        if (t==M) S=r*r;
        int maxh=min((N-V-sv[t-1])/(r*r),lH-1);
        for (int h=maxh;h>=t;h--)
        {
            dfs(t-1,S+2*r*h,V+r*r*h,r,h);
        }
    }
}
int main()
{
    scanf("%d %d",&N,&M);
    for (int i=1;i<=M;i++)
    {
        ss[i]=2*i*i;//计算出每一层的最小侧面积 
        ss[i]+=ss[i-1];//要求前缀和 
        sv[i]=i*i*i;//最小体积 
        sv[i]+=sv[i-1];//要求前缀和 
    }
    dfs(M,0,0,sqrt(N),N);//第一层的高度最小为1，所以半径最大就是根号N 
    if (ans==oo) printf("0");
    else printf("%d",ans);
    return 0;
}
```

---

## 作者：Indigo_Boy (赞：16)

# 自己想出这题的大佬蒟蒻在这儿%您了
我实在是太弱了，~~搜索这种辣鸡算法都不会~~（逃
 
这题真的是想了好久，每次都会T三个点，我以为我的剪枝已经堆了够多了，结果后来才知道是一个关键剪枝没想到OTZ
 
## 先贴代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rint register int 
int n, m, ans = 99999999;
int ini1[20], ini2[20];
inline void init( void ){
	for( rint i = 1; i <= m; i++ ){
		ini1[i] = pow( i, 3 ) + ini1[i - 1];
		ini2[i] = 2 * i * i + ini2[i - 1]; 
	}
	return ;
}
inline void dfs( int nowv, int nows, int r, int h, int t ){
	if( t == 0 ){
		if( nows == n ) ans = min( ans, nowv );
		return ;
		//cout << 1;
	}
	if( nowv + ini2[t - 1] >= ans ) return ;
	//cout << 1;
	if( nows + ini1[t - 1] >= n ) return;
	//cout << 1;
	if( 2 * ( n - nows ) / r + nowv >= ans ) return ;
	for( rint i = r - 1; i >= t; i-- ){
		//cout << 1;
		if( t == m ) nowv = i * i;
		int hh = min( h - 1, ( n - nows - ini1[t - 1] ) / ( i * i ) );
		for( rint j = hh; j >= t; j-- ){
			//cout << t << endl;
			dfs( nowv + 2 * i * j, nows + i * i * j, i, j, t - 1 );
		}
	}
	return ;
}
int main( void ){
	scanf( "%d%d", &n, &m );
	init();
	int temp = sqrt( n );
	//for( int i = 1; i <= m; i++ ) cout << ini[i] << ' ';
	dfs( 0, 0, temp + 1, n + 1, m );
	if( ans == 99999999 ){
		cout << 0;
		return 0;
	}
	cout << ans;
	return 0;
}
```

看这输出的1就知道我错了多少次，结果发现把一个t打成了 $t - 1$  	qwq	

## 关键剪枝

```cpp
if( 2 * ( n - nows ) / r + nowv >= ans ) return ;
```

这里详细推一下

1 到 $dep - 1$的体积为

$n - v = \sum_{k = 1}^{dep - 1}h[k] * r[k] ^ 
2$

表面积为

 
$2\sum_{k = 1}^{dep - 1}h[k] *r[k] $

又臭又长警告

$\because2\sum_{k = 1}^{dep - 1}h[k] *r[k] = \frac{2}{r[dep]} * \sum_{k = 1}^{dep - 1}h[k]*r[k]*r[dep]\geqslant \frac{2}{r[dep]} *\sum_{k = 1}^{dep - 1}h[k]*r[k]^2\geqslant \frac{2(n - v)}{r[dep]}$
$\therefore$当$ \frac{2(n - v)}{r[dep]} + s \geqslant ans$时说明已经不是最优，即可return

这是对前$dep - 1$层侧面积的估计，很多人忽略了这一维度，其实，这一维度已经在我们预处理$ini$
（别激动，$init$删去$t$而已23333）时已经有所涉及，只是我们没有太在意而已

这告诉我们在设计剪枝条件的时候一定要全方面考虑
，每个维度都有所思考，尽可能到达上下界

```cpp
return 0；//功德圆满
```


---

## 作者：EmpyreanCz (赞：15)

主要思路：

这道题刚拿到就知道要用dfs，但是dfs肯定会T，

所以我们要用剪枝来优化搜索的方案数量。

1 要是剩下体积除以最大(虽然取不到)半径所得到的表面积+累计表面积大于答案退出

2 要是剩下来的体积已经小于该层最小体积了就退出

3 还有为了剪枝,我们要起先预处理某一层的最大不可的表面积和体积

4 要是最小面积+当前累计表面积已经比已知答案大了就退出

```cpp

#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define INF 2147483647 
using namespace std;
int a[201],b[201],m,n,ans;//a存储表面积,b存储体积
void dfs(int v,int s,int p,int r,int h) { //v为已用体积，s为已有表面积，p为剩余层数，r为半径，h为高
	int i,j,yy;
	if(p==0) { //如果已经搜到了顶层
		if (v==n&&s<ans)//判断是否符合要求并得到更优解
			ans=s;
		return ;
	}
	//各种剪枝
	if(v+b[p-1]>n) return ;//体积超出
	if(s+a[p-1]>ans) return ;//表面积超出
	if(2*(n-v)/r+s>=ans)  return; //当前的表面积+余下的侧面积>当前最优值 
	for(i=r-1; i>=p; i--) { //枚举半径
		if(p==m) s=i*i;
		yy=min((n-v-b[p-1])/(i*i),h-1);
		for(j=yy; j>=p; j--) //枚举高
			dfs(v+i*i*j,s+2*i*j,p-1,i,j);
	}
}
int main() {
	cin>>n>>m;
	ans=INF;//用于输出
	a[0]=b[0]=0;
	for(int i=1; i<21; i++) {
		a[i]=a[i-1]+2*i*i;//第i层使用的最大表面积
		b[i]=b[i-1]+i*i*i;//第i层使用的最大体积
	}
	dfs(0,0,m,n+1,n+1);
	if(ans==INF) cout<<0;
	else cout<<ans;
	return 0;
}
```

---

## 作者：yybyyb (赞：14)

//剪枝1:如果接下来每一层都按照最小的来算，依然大于了总体积则可以剪去

//剪枝2:如果接下来每一层都按照最小的来算，结果已经大于了求出的最优值，可以剪去

//剪枝3:通过变形公式，如果接下来的体积用完所需的最小表面积已经大于了最优值，可以剪去

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,sv[21],sa[21],ans=2147483647;
void DFS(int deep,int tov,int tos,int lr,int lh)//从上往下第deep层,当前以用体积tov，以用表面积tos
                                                //上一层的半径lr,上一层的高度lh 
{
     if(deep==0)
     {
            if(tov==n)
              ans=min(ans,tos);
            return;
     }
     if(tov+sv[deep-1]>n)return;       
     if(tos+sa[deep-1]>ans)return;    
     if(tos+2*(n-tov)/lr>=ans)return; 
     for(int i=lr-1;i>=deep;--i)
     {
            if(deep==m)
               tos=i*i;
            int maxh=min(lh-1,(n-tov-sv[deep-1])/(i*i));  //当前高度所允许的最小值是上一层的高度减一和剩余体积
                                                         //与当前表面积的较小值 
            for(int h=maxh;h>=deep;--h)
               DFS(deep-1,tov+i*i*h,tos+2*i*h,i,h);
     }
}
int main()
{
    cin>>n>>m;
    memset(sv,0,sizeof(sv));
    memset(sa,0,sizeof(sa));
    for(int i=1;i<=m;++i)//提前预处理如果接下来i层都按照最小的计算所需的最表面积和体积 
    {
        sv[i]=sv[i-1]+i*i*i;
        sa[i]=sa[i]+i+i;
    }
    DFS(m,0,0,sqrt(n),n);
    if(ans!=2147483647)
       cout<<ans<<endl;
    else
       cout<<0<<endl;
    return 0;
    
}
```

---

## 作者：cyborg (赞：14)

首先确定半径和高的最大值，20000的三次方约等28，也就是说半径和高最大能取到28了，如楼下所说，要剪枝。

当前体积大于目前答案时剪枝不多说。

当前层数y之后最小表面积等于1^3+2^3+...+（y-1）^3，我们可以存个数组。

而萌新表示看不懂是怎么求最大体积，所以想到了用数组maxv[r][h]（r>h（r<=h同理）不管层数）表示1^2\*(h-r+1)+2^2\*(h-r+2)+...+(r-1)^2\*(h-1).

假设是是从上往下（注意！）数第y层，设定半径为r，高为h，之后的最大体积就等于(r-y)^2\*(h-y)+(r-y+1)^2\*(h-y+1)+...+(r-1)^2\*(h-1).就可以表示为maxv[r-1][h-1]-maxv[r-y][h-y]。

至于maxv[r][h]=maxv[r-1][h-1]+r\*r\*t，所以一个28\*28次的循环就够了。代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int ans=100000,minv[16],maxv[29][29];
void dfs(int y,int v,int s,int r,int h)//y是还有多少层要铺，v是已求表面积，s是剩余体积，r、h是上一层的高 
{
    //cout<<y<<' '<<v<<' '<<s<<' '<<r<<' '<<h<<endl;
    if(s>=ans)return ;                //表面积大于已求答案 
    if(v==0&&y==0)ans=s;            //判断，存答案 
    if(v==0||y==0)return ;
    for(int i=y;i<r&&v-i*i>=minv[y-1];i++)        //i求半径 ，h求高 
    for(int t=y;t<h;t++)
    {
        if(s>=ans)return ;                        //判断表面积 
        if(v-t*i*i<minv[y-1])break;                //判断最小体积 
        if(maxv[i-1][t-1]-maxv[i-y][t-y]<v-i*i*t)continue;//判断最大体积 
        if(s!=0)dfs(y-1,v-i*i*t,s+2*i*t,i,t);else
        dfs(y-1,v-i*i*t,i*i+2*i*t,i,t);            //铺最下面一层时加上俯视图的面积 
    }
}
int main()
{
    int i,t;
    for(i=1;i<=15;i++)
    minv[i]=minv[i-1]+i*i*i;        //minv[i]=1^3+2^3+...+i^3，minv[y]表示（从上往下数 ）1到y-1层最小体积 
    for(i=1;i<=28;i++)
    for(t=1;t<=28;t++)
    {
        maxv[i][t]=maxv[i-1][t-1]+i*i*t;//1^2*(h-r+1)+2^2*(h-r+2)+...+(r-1)^2*(h-1)，maxv[r-1][h-1]-maxv[r-y][h-y]表示（从上往下数）1到y-1层当y层半径r，高h时的最大体积 
    }
    int n,m;
    cin>>n>>m;
    dfs(m,n,0,28,28);
    cout<<ans;
}
```

---

## 作者：东方澂 (赞：7)

&emsp;&emsp;这是一道搜索+剪枝的经典题，DFS想必大家都会，而重点便是如何剪枝。

## 总述
&emsp;&emsp;首先搜索序应该是从下往上搜索，这样一来，最下层的R与H确定下来之后，因为题目要求$R_i>R_{i+1}$且$H_i>H_{i+1}$，上面的各层的R与H的上界也就相应确定了，而又易知第i层(从上往下)的R与H$\geqslant$i,那么下一层搜索的范围就确定了下来。  
&emsp;&emsp;在计算表面积时，因为各层上底面的面积之和即为第一层的底面面积，所以在搜索过程中只需计算各层的侧面积。

## 剪枝
1.上下界剪枝  
在第i层(从上往下)时，易知R∈[i，$R_{i+1}-1$]，H∈[i，$H_{i+1}-1$]，  
这个范围能否进一步缩小呢？  
设底层到第i+1层的体积之和为v，第i-1层到顶层的最小体积为minv，则第i层的体积最大为n-v-minv，  
$πR^2H=π(n-v-minv)$，  
$∴R=\sqrt{\frac{n-v-minv}{H}}$，  
$H=\frac{n-v-minv}{R^2}$。  
综上，R∈[i，min{$\sqrt{\frac{n-v-minv}{H}}$，$R_{i+1}-1$}]，  
H∈[i，min{$\frac{n-v-minv}{R^2}$，$H_{i+1}-1$}]。  
我们在这里选择先枚举R再枚举H(由于我太菜了，这里我并无法证明先枚举还是先枚举H更优；我拿这个问题去问过我的数学老师和一位南开大学的学长，也没有解决。)，所以  
R∈[i，min{$\sqrt{n-v-minv}$，$R_{i+1}-1$}]，  
H∈[i，min{$\frac{n-v-minv}{R^2}$，$H_{i+1}-1$}]。

2.优化搜索顺序  
在上面确定的范围中，从大到小枚举R与H。

3.显然，当第1到i层(从上往下)的半径分别取1，2，3……i，高分别取1,2,3……i时，当第1到i层的体积与侧面积最小。所以我们可以预处理出前m层的最小体积与侧面积，如果当前体积v加上剩余层的最小体积大于n，cut；如果当前表面积s加上剩余层最小侧面积大于已经搜索到的结果，cut。

4.设底层到第i层(从上往下)的体积之和为v,表面积之和为s，  
则第1到i-1层的体积为  
n-v=$\sum_{n=1}^{i-1}H_n·R_n^2$，  
第1到i-1层的侧面积为  
2$\sum_{n=1}^{i-1}H_n·R_n$，  
2$\sum_{n=1}^{i-1}H_n·R_n$=$\frac{2}{R_i}\sum_{n=1}^{i-1}H_n·R_n·R_i$>$\frac{2}{R_i}\sum_{n=1}^{i-1}H_n·R_n^2$=${\frac{2(n-v)}{R_i}}$，  
所以当${\frac{2(n-v)}{R_i}}$+s大于已经搜索到的结果时，cut。  
(这个剪枝我是看了《信息学奥赛一本通·提高篇》之后才明白的，但这里我也想指出《一本通》的一个错误：《一本通》上此处写的是$\geqslant$，但是∀n∈[1，i-1]，都有$R_n$<$R_i$，等号是取不到的)  
(如果是本蒟蒻搞错了请指出QAQ)

## 细节
&emsp;&emsp;然而，虽然思路已经清晰了，在上手编写代码的时候却还是有一些细节上的问题.

&emsp;&emsp;1.我们DFS时一般step都是从1到m，然而此题如果这么做，第step层到顶层的最小体积与侧面积就得表示为minv[m-step+1]和mins[m-step+1]，当下层的R与H的下届就得表示为m-step+1，非常烦人，而让step从m到0，就会更加便利(先前我们剪枝的分析也是层数从上到下的)。

&emsp;&emsp;2.会发现，当前层的R与H只有在下一层递归时会用到，所以我们无需~~像《一本通》所说的一样~~开一个数组来存储各层的R和H，浪费空间存储一些无用的数据，以作为DFS的参数传入下一层递归。
 
代码如下  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=2000000000;
int mins[25]={0},minv[25]={0};//从上往下前i层的最小侧面积与体积

void pre(){
    for(int i=1;i<=20;i++){
        mins[i]=mins[i-1]+2*i*i;
        minv[i]=minv[i-1]+i*i*i;
    }
}
//为了方便，step从m到0
void dfs(int step,int r,int h,int s,int v){
    if(step==0){
        if(v==n) ans=min(ans,s);
        return;
    }
    if(v+minv[step]>n) return;//如果当前体积v加上剩余层的最小体积大于n，cut
    if(s+mins[step]>ans) return;//如果当前表面积s加上剩余层的最小侧面积大于已搜索到的结果，cut
    if(2*(n-v)/r+s>ans) return;
    int t=sqrt(n-v-minv[step-1]);
    int maxr=min(t,r-1);
    for(int i=maxr;i>=step;i--){//枚举r
        if(step==m) s=i*i;
        int maxh=min((n-v-minv[step-1])/(i*i),h-1);
        for(int j=maxh;j>=step;j--){//枚举h
            dfs(step-1,i,j,s+2*i*j,v+i*i*j);
        }
    }
}

int main(){
    scanf("%d %d",&n,&m);
    pre();
    dfs(m,n,n,0,0);
    printf("%d",ans==2000000000 ? 0 : ans);
    return 0;
}
```

---

## 作者：三氯甲硅烷 (赞：7)



------------
本来没想着要发题解的，今天刚好又重交了一遍代码，原来TLE6个点的代码换个语言（没改源码）就AC了！？~~（大雾）~~



------------
### 先来说一下剪枝：
~~1.你需要会搜索~~

~~2.你要有一颗优化代码的心~~


所谓剪枝，首先要有“枝”可剪。枝桠生于树间，所以，要先有一个树，从粗壮的树干向上漫溯，沿着这一根根弯曲的枝桠走到绿油油的常青叶上，记录下这难得一见的美景，挪动脚步，转身，向着下一根未知的枝桠走去，当你再次走到一个枝干分叉的路口，你想到了你曾经在这里所见到的美景，也许甜蜜，也许痛苦，但你都毫不犹豫的转生离去，因为你知道，继续前进，不过是重复历史，已知的探险毫无意义……
#### 说人话


剪枝就是把搜索时的边界根据各种条件从叶子结点提高到"枝"节点

### 再简要讲一下本题思路：

第一把大剪刀：表面积妥妥的太大了，return

第二把大剪刀：体积妥妥的超了，return


------------
贴代码（可直接食用，选错语言导致TLE后果自负）


```python

a=[0 for fff in range(1000)]
n,m=int(input()),int(input())
ans,est=210322666,25 #这玩意开50会T一个点
def DFS(t,s,v,p,q):
    global ans,n,m,a
    if t==m+1 and v==n:
        ans=min(ans,s)
        return
    k=m-t+1
    if k*2+s>ans or k*p**2*q+v<n or s>=ans or v>=n:
        return
    if t==1:
        for r in range(p,m-1,-1):
            for h in range(m,q+1):
                DFS(t+1,s+r*r+2*r*h,v+r**2*h,r,h)
    else:
        for r in range(p-1,m-t,-1):
            for h in range(m-t+1,q):
                DFS(t+1,s+2*r*h,v+h*r**2,r,h)
DFS(1,0,0,est,est)
if ans==210322666:
    print(0)
else:
    print(ans)
    
```


------------
 _~~不嫌我菜可以加我好友~~_ 



---

## 作者：徐熙凯 (赞：6)

# ~蒟蒻来写题解了~

~~这是一道简单的dfs水题~~

输入的是它的体积和层数，不用多想，那就是枚举它每一层的半径（从大到小）。一层一层地往下做（求侧面积），直到体积==0时，在加上它的上下面积，跳出，得到最小的面积。

问题是它有至多有15层，体积至大有20000，这样枚举肯定会超时的！

那么，就轮到剪枝出场了(' > == < ')

```

	if(s[x]>b) return ;//剪枝 当 当前最小体积小于剩余体积  跳出 结束 
	if(b/(2*y)+a>ans) return ;//剪枝 当前总面积大于最优解  跳出 结束 
```


直接贴代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int s[10101];
int n,m,i,j,k,h,ans=1000000001;
void dfs(int x,int y,int z,int a,int b)
//x代表还剩x层,y代表前一层的半径,z代表前一层的高度,a代表当前总面积,b代表当前剩余体积
{
    int i,j,k,h;
	if(x==0)
	{
		if(b==0&&a<ans) ans=a;//判断是否符合题意再然后寻找最优解 
		return ;
	}
	if(s[x]>b) return ;//剪枝 当 当前最小体积小于剩余体积  跳出 结束 
	if(b/(2*y)+a>ans) return ;//剪枝 当前总面积大于最优解  跳出 结束 
	for(i=y-1;i>=x;--i)//枚举半径 
	{
		if(x==m) a=i*i;//生日蛋糕的上下总表面积等于最底层蛋糕的上下表面积 
		for(j=z-1;j>=x;--j)//枚举高度 
		    dfs(x-1,i,j,a+2*i*j,b-i*i*j);
	}
} 
int main()
{
	cin>>n>>m;
	for(i=1;i<=m;++i) s[i]=s[i]+i*i*i;//第i层最小体积 
	dfs(m,sqrt(n/m),n/(m*m),0,n);
	if(ans==1000000001) cout<<0;
	else cout<<ans;
	return 0;
}
```


---

## 作者：秋日私语 (赞：4)

[链接](https://blog.csdn.net/a_comme_amour/article/details/77684970)


借这道题来谈谈剪枝：

生日蛋糕这道题的优化方法有如下几种： 

1、前缀和优化。用vmin[i]和smin[i]记录前i层及其自身的体积（侧面积）最小情况（即第一层r=1,h=1，第二层r=2,h=2…）的总和，用于后面的剪枝。 

2、v+r*r*h+vmin[i+1]<=n 如果当前的总体积+该层往上的所有的总体积的最小和>给定蛋糕的体积，剪掉。（可行性剪枝） 

3、s+2*r*h+smin[i+1]< best 如果当前的总表面积+该层往上的所有的表面积的最小和>目前最优解,剪掉。（最优化剪枝） 

4、v+r*r*h*(m-i+1)>=n 如果后面的所有层均以当前表面积做成
蛋糕，如果此时的体积仍然小于蛋糕的体积，就要剪掉。（可行性
剪枝） 

这种剪枝方法等价于：假设剩余的体积全部以当前层的半径做成蛋
糕，因为当前的半径的最大的，所以得出的表面积是最小的，根据
这个“最小表面积”判断表面积是否超过最优解，超出则剪掉。 

5、搜索的顺序:r从大往小循环，h从小往大循环。由侧面积
s=2*r*h,体积v=r*r*h得：在s中r的增长是线性的，在v中r的增
长是平方的。r从大往小，h从小往大，可以更快的到达目标
（best）即最优解，之后越多不必要的搜索就会被剪枝，从而提高
效率。

代码

```
#include<cstdio>
#include<cmath>
using namespace std;
int n,m,best=0x7fffff,vmin[25],smin[25];

void dfs(int i,int ri,int hi,int s,int v)//i当前层数，ri,hi上一层的半径和高，s,v之前的面积，体积总和 
{
    for (int r=m-i+1; r<=ri-1; r++) //最小状态，第i层（从上往下）的半径和高度均为i 
        for (int h=hi-1; h>=m-i+1; h--)
        {
            if (i==1) s=r*r;
            if (s+2*r*h+smin[i+1]<best&&v+r*r*h+vmin[i+1]<=n&&v+r*r*h*(m-i+1)>=n)
            {
                if (i==m) best=s+2*r*h;
                else dfs(i+1,r,h,s+2*r*h,v+r*r*h);
            }
        }
}
int main()
{
    scanf("%d%d",&n,&m);
    vmin[0]=0; //第0层的体积和表面积都是0(前缀和技巧？) 
    smin[0]=0;
    for (int i=1; i<=m; i++)//从下往上，m层为最上面的一层 
    {
        vmin[m-i+1]=vmin[m-i+2]+i*i*i;//min[i]表示前i层及其自身的体积（侧面积）的总和，用于剪枝 
        smin[m-i+1]=smin[m-i+2]+2*i*i;//smin只记录侧面积 
    }
    dfs(1,sqrt((n-vmin[2])/m)+1,(n-vmin[2])+1,0,0);//最下面那层的上一层的半径为本层半径+1（高同理）
    printf("%d\n",best);
    return 0;
}
```


---

## 作者：zqiceberg (赞：3)

### 算法
dfs( )

### 分析

搜索框架：从下往上搜索，枚举每层的半径和高度作为分支。

### 剪枝

1.上下界剪枝

2.优化搜索顺序

3.可行性剪枝

4.最优性剪枝

搜索过程中的剪枝，其实就是针对“维度”与该维度的边界条件，加以缩放、推导，得出一个相应的不等式，来减少所搜书分支的扩张。

### 代码


```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 25, INF = 1e9;

int n, m;
int minv[N], mins[N];
int R[N], H[N];
int ans = INF;

void dfs(int u, int v, int s)//从第u层开始，当前体积v，当前面积s
{
    if (v + minv[u] > n) return ;  //体积大于n，剪枝
    if (s + mins[u] >= ans) return ; //面积比当前ans大，剪枝
    if (s + 2 * (n - v) / R[u + 1] >= ans) return ; //最优性剪枝 算法进阶指南P108
    
    if (!u)
    {
        if (v == n) ans = s;
        return ;
    }
    
    for (int r = min(R[u + 1] - 1, (int)sqrt(n - v)); r >= u; r--)
        for (int h = min(H[u + 1] - 1, (n - v) / r / r); h >= u; h--)
        {
            int t = 0;
            if (u == m) t = r * r; //最后一层，算一下封盖的面积
            
            R[u] = r, H[u] = h;
            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);//从第u-1层开始，当前体积v+r*r*h，当前面积s+2*r*h+t
        }
}

int main()
{
    cin >> n >> m;
    
    //打表处理每一行最小的体积和面积，自底向上，每一层严格小于上一层的半径和高度
    for (int i = 1; i <= m; i++)
    {
        minv[i] = minv[i - 1] + i * i * i;    //体积：i*i  *i
        mins[i] = mins[i - 1] + 2 * i * i;    //面积：2*i  *i
    }
    
    R[m + 1] = H[m + 1] = INF;
    
    dfs(m, 0, 0);//从第m层开始，当前体积和面积都是0
    
    cout << ans << endl;
    
    return 0;
}
```


---

## 作者：LevenKoko (赞：3)

##[戳我获得更好的观看效果](https://www.cnblogs.com/zhenglw/p/9528140.html)

## 主要是剪枝的问题，见代码，讲的很详细
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
inline int read(){
	char chr = getchar();	int f = 1,ans = 0;
	while(!isdigit(chr)) {if(chr == '-') f = -1;chr = getchar();}
	while(isdigit(chr))  {ans = (ans << 3) + (ans << 1);ans += chr - '0';chr = getchar();}
	return ans* f ;
}
void write(int x){
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

int r[50],h[50];//上一次的半径、高
int N,M; 
int ans=0x3f3f3f3f;
void dfs(int x,int V,int S,int kk){//当前第x层,当前总共体积为V，当前总侧面积为S，还有kk层没有处理
	if(S+r[1]*r[1]+kk>=ans) return;//最优化剪枝，如果当前总侧面积+底面积（三视图角度理解）>=当前记录的答案
	if(x>M+1) return;//超出M层
	if(N-V-r[x-1]*r[x-1]*h[x-1]*kk>0) return;//同上最优化剪枝,（假设之后每一层的底面积都是上一层的半径与高）
	if(V==N && x==M+1){//如果可以记录进答案
		ans=min(ans,S+r[1]*r[1]);
		return;
	}
	for(int H=h[x-1]-1;H>=kk;H--)
	for(int R=r[x-1]-1;R>=kk;R--){//枚举L,R,（上下界剪枝）
		h[x]=H;
		r[x]=R;
		V+=r[x]*r[x]*h[x];
		S+=2*r[x]*h[x];
		dfs(x+1,V,S,kk-1);
		V-=r[x]*r[x]*h[x];
		S-=2*r[x]*h[x];//回溯
	}
} 
int main(){
	N=read(),M=read();
	h[0]=(int)sqrt(N);
	r[0]=(int)sqrt(N);
	dfs(1,0,0,M);
	if(ans==0x3f3f3f3f)
		cout<<-1;//答案没有更新过的话，输出-1
	else
		cout<<ans;
	return 0;
}
```

---

## 作者：我找不着西www (赞：2)

这个题不得不说还是有点意思的
## 可能我是个菜 鸡
对于各位大佬可能就是一个十分朴素的深搜  然后加几个条件罢了
但前提是  你得会dfs    然后你得有数学基础  把所有能减掉的东西
# 一剪梅
因为  搜索里面  剪枝是最重要的·  好比去一棵树上摘苹果
你顺着枝条走  结果走了半天发现

这*树干居然从最开始就是坏的  哈哈哈绝望吧

所以  先一览众山小  然后把能减的都剪了   再去搜索这个树

那么对于本题来说  有哪些不必要的搜索呢

### 1、当前已有表面积，加上之后层的预估最小表面积，若大于最优解，减掉。

### 2、当前已有体积，加上之后层的预估最小体积，若大于最优解，减掉。

### 3、从半径=n+1开始搜

```
if((v+min_v[stp-1]>VV)||(s+min_s[stp-1]>=minn)||(s+2*(VV-v)/r>=minn))
return ;//剪枝 
```

这就是上述的三个条件



然后  这个题还有一个核心部分  就是你r 和 h在枚举时的开端

记住  你的每一层的r是递减的·
```
for(int i=r-1;i>=stp;--i)
	{
		if(stp==cen)
		s=i*i;
		int tep=min((VV-v-min_v[stp-1])/(i*i),h-1);
		for(int j=tep;j>=stp;--j)
			dfs(i,j,v+i*i*j,s+2*i*j,stp-1);
	}
```
//循环里面dfs别忘了增加面积  体积  和步骤-1   因为从第n步开始的

最后  主函数dfs的r和h是从层数加一开始的

而后  附上源代码

```
#include<bits/stdc++.h>
using namespace std;
int min_s[20];
int min_v[20];
int minn = 0xfffffff;
int VV,cen;
inline void dfs(int r,int h,int v,int s,int stp)
{
	if((v+min_v[stp-1]>VV)||(s+min_s[stp-1]>=minn)||(s+2*(VV-v)/r>=minn))
	return ;//剪枝 
	if(stp==0)
	{
		if(v==VV)
		minn=s;
		return ;//satisfied and return.
	}
	for(int i=r-1;i>=stp;--i)
	{
		if(stp==cen)
		s=i*i;
		int tep=min((VV-v-min_v[stp-1])/(i*i),h-1);
		for(int j=tep;j>=stp;--j)
			dfs(i,j,v+i*i*j,s+2*i*j,stp-1);
	}
}
int main()
{
	scanf("%d%d",&VV,&cen);	
	for(int i=1;i<=cen;++i)
	{
		min_s[i]=min_s[i-1]+i*i;
	}
	for(int i=1;i<=cen;++i)
	{
		min_v[i]=min_v[i-1]+i*i*i;
	}
	dfs(VV+1,VV+1,0,0,cen);
	if(minn==0xfffffff)
	printf("0");
	else
	printf("%d",minn);
	return 0;
}
```


我看了下大家的AC   好多人都是4、500+ ms  过的
这个差不多48ms   0.78mb   

这是没有经过洛谷自带氧化加速的答案
还是比较满意的


告诉你们一个秘密

这题里面的测试点没有无解的情况

---

## 作者：转身、已陌路 (赞：2)

首先要把题意读懂 π是完全没用的 一层一层进行枚举

然后要进行剪枝（程序注释中已经解释的很清楚了）

```cpp
#include<bits/stdc++.h>
#define oo 1000000000
using namespace std;
int ans,a[20],b[20];
int minn[20];
int n,m;
void dfs(int k,int r,int h,int s,int v)//分别存层数 当前层的半径 高度 表面积 剩下的体积 
{
    if (s+2*v/r>ans) return;//我们知道剩余的体积，能不能根据体积，估算一个剩余的侧面积，如果（ 当前的表面积+余下的侧面积的最小值）比最优值还大，那么当前层的搜索就没有意义。
    if (v-minn[m-k]<0) return;//如果剩余的体积按最少的标准，都不能让蛋糕都做不了m层
    if (k==m)//边界情况 
    {
        if (v==0) if (ans>s) ans=s;
        return;
    }
    for (int tr=r-1;tr>=m-k;tr--)
    for (int th=h-1;th>=m-k;th--)//不断缩小半径和高度 进行枚举 
    {
        int ts,tv;
        ts=s+2*tr*th;
        tv=v-tr*tr*th;
        dfs(k+1,tr,th,ts,tv);
    }
}
int main()
{
    cin>>n>>m;
    ans=oo;
    int j=1;
    for (int i=1;i<=m;i++)//预处理一个数组将最小的存起来 等会剪枝 
    {
        minn[i]+=i*i*j;
        j++;
    }
    for (int r=m;r*r<=int(double(n)/m);r++)//因为半径是越来越小的 所以r的大致范围可以确定 
    for (int h=n/(r*r);h>=m;h--)//高度的大致范围也可以确定
    {
        int s,v;//表面积和剩下的体积
        s=r*r+2*r*h;//第一层的侧面积+总顶面积（可以通过平移使所有顶面积拼成第一层的顶面积）
        v=n-r*r*h;
        dfs(1,r,h,s,v);
    } 
    if (ans==oo) ans=0;
    cout<<ans;
    return 0;
}
```

---

## 作者：slyzzsc (赞：2)

**//感谢二楼大哥提供了思路，加上自己的理解真的很巧妙，也很好理解，希望对大家有帮助**

//这道题可以通过一般的搜索找到思路，但是很显然会超时所以需要优化

//其中需要三重优化：第一重是如果已用面积+最小面积仍然超过最优答案就返回

//第二重是如果已用体积+最小体积仍然超过要求体积就返回

//第三重剪枝是假设剩余所有的体积都用来做下一层那么此时下一层的体积是最大，而半径会最大，从而表面积最小

//根据这个最小表面积判断是否超过最优解能够省很多时间

//如果只优化前两个会TLE3个点，很显然，体积一定的情况下表面积与半径相对来说是有关系的

```cpp
//可以根据这个点进行优化 
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int nn,m,n,ans=2147483647;
int ss[21],sv[21];
void dfs(int t,int s,int v,int lr,int lh)//层数，已用面积。已用体积，上层半径，上层高度 
{
    int r,h,maxh,i;//本层半径，高度，最大高度 
    if (t==0)//如果到顶层 
      {
            if (v==n) ans=min(ans,s);//检验体积是否符合要求并更新答案 
            return;
      }
    if (s+ss[t]>ans) return;//如果已用面积+最小面积仍然超过最优答案就返回 
    if (v+sv[t]>n) return;//如果已用体积+最小体积仍然超过要求体积就返回 
    if (s+2*(n-v)/lr>ans) return;//第三重剪枝：假设剩余所有的体积都用来做下一层那么此时下一层的体积是最大，而半径会最大，从而表面积最小
                                 //根据这个最小表面积判断是否超过最优解能够省很多时间 
    for (r=lr-1; r>=t; r--)//从下一层最小半径开始枚举寻找合适的半径 
      {
            if (t==m) s=r*r;//如果是最底层就用最大半径 
            maxh=min((n-v-sv[t-1])/(r*r),lh-1);//高度选择总体积-已用体积-上层体积除以半径可以得到然后与lh-1比较 
            for (h=maxh; h>=t; h--)
              dfs(t-1,s+2*r*h,v+r*r*h,r,h);//下一层搜索 
      }
}
int main()
{
    freopen("cake.in","r",stdin);
    freopen("cake.out","w",stdout);
    int i;
    cin>>n>>m;
    for (i=1; i<=m; ++i)//按照最小初始化 
      {
            ss[i]=2*i*i+ss[i-1];//最小侧面积 
            sv[i]=i*i*i+sv[i-1];//最小体积 
      }
    dfs(m,0,0,sqrt(n),n);//sqrt(n)是所能达到最大半径，n是最大高度，m是层数 
    if (ans==2147483647)//如果ans值未改变那么说明做不成这样的蛋糕，就输出0 
      {
           cout<<'0';
           fclose(stdin);
         fclose(stdout);
           return 0;
      }
    cout<<ans<<endl;
    fclose(stdin);
    fclose(stdout);//输出答案 
    return 0;    
}
```

---

## 作者：Victorique (赞：2)

看了楼下那么多代码，优化的方法比较一致，其实这个题还有一些其他的优化方法。

比如搜索时把高倒过来搜，由于数学规律，会比正着搜快。

下面是代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>//蒟蒻的我一直担心头文件不够用。。
using namespace std;
int minn=10000000,p,q,n,m,mj,tj;//minn来储存最优解，由于需要存放最小值，所以定的大。
int vmin[1001],smin[1001];
void search(int,int,int,int,int);
int main()
{
    //freopen("cake.in","r",stdin);
    //freopen("cake.out","w",stdout);请无视掉这两行。。。。。
    cin>>n>>m;
    smin[m+1]=0;
    vmin[m+1]=0;
    for(int i=1;i<=m;i++)
    {
        smin[m-i+1]=smin[m-i+2]+2*i*i;
        vmin[m-i+1]=vmin[m-i+2]+i*i*i;//存入每一层可能得到的最优解，为后面剪枝做准备。
    }
    search(1,sqrt((n-vmin[2])/m)+1,(n-vmin[2])/m/m+1,0,0);第一次进入搜索时为了确定最优的边界，用sqrt((n-vmin[2])/m)+1求出可能得到的最大的半径，用(n-vmin[2])/m/m+1求出可能得到的最大的高，提高部分效率。
    cout<<minn;
}
void search(int i,int ri,int hi,int s,int v)
{
    int r,h,vmax,j;
    for(r=m-i+1;r<=ri-1;r++)
     {
        if (i==1)
         s=r*r;//数学好的都能算出来，无论这个蛋糕长啥样表面积都会是最下层的底面积加上n层的侧面积。。。
         for(h=hi-1;h>=m-i+1;h--)//优化，据大佬说，高的变化是线性的，从大到小搜索高的值要比从小到大快的多。
         {
         if (s+2*r*h+smin[i+1]<minn&&(v+r*r*h+vmin[i+1])<=n&&(v+r*r*h+(r-1)*(r-1)*(m-i)*(h-1))>=n)//剪枝，楼下的都已经说过了原因，这里不再写。最后一个判断条件代表当前一层之上的所有层能有的一个最大的体积。
         {
             if (i==m)
             minn=s+2*r*h;//如果已经找到了最上层，保存最优值。
             else
             search(i+1,r,h,s+r*h*2,v+r*r*h);//递归搜索
         }
         }
     }
}
```

---

## 作者：ZRX114514 (赞：2)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
int r[30],h[30],minn=2147483647,n,m;
void dfs(int x,int y,int k,int z)
//x代表现在枚举第几层y是剩余体积还有多少k为当前得到表面积，z是层数
{  
	if(y<0) return;//首先剩余体积小与0很显然不用继续下去了
    if(x>m+1) return;//已经超过m层了是不是也不用了
     if(k>=minn) return;//当前的表面积就已经超过了之前算过的最小表面那么就不用再做了
    if(y==0&&x==m+1)//搜索完毕
    {  k+=r[1]*r[1];//这个是代表 要加上最低下的表面积
         if(k<minn) minn=k;//如果小于当前的最小值，那么我们minn的值更新为minn
         return;
    }
    if(k+z+r[1]*r[1]>minn) return;
    //当前的表面积就已经超过了之前算过的最小表面那么就不用再做了,每一个只放半径为1的，放z个都比最小值大
   if(y-(r[x-1])*(r[x-1])*(h[x-1])*z>0) return;//我后面还要放z个最大是跟这个一样大的还小于y
    for(int i=r[x-1]-1;i>=z;i--)//枚举半径，因为下一层的蛋糕必须上一层大且至少大1
      for(int j=h[x-1]-1;j>=z;j--)//枚举高度，i为什么z
      {
            if(y-i*i*j>=0&&x+1<=m+1)//i*i*j这个是体积
             {     r[x]=i;
                   h[x]=j;
                    dfs(x+1,y-i*i*j,k+(i*2*j),z-1);//i*2*j实际上是表面积
                   h[x]=0;
                   r[x]=0;
             }
      }
}
int main()
{
    scanf("%d%d",&n,&m);//n是代表有n*pi吧
    //先规定两个上界
    r[0]=(int)sqrt(n);//如果体积是n那么h=1那么底面的半径是sqrt(n)
    h[0]=(int)sqrt(n);//因为r[0]最小是sqrt(n),那么如果h超过了sqrt(n),那么是不是r^2*h明显超过了n
    dfs(1,n,0,m);
    if(minn==2147483647) printf("%d",0);
      else printf("%d",minn);
    return 0;
}

```


---

## 作者：Kelin (赞：2)

http://blog.csdn.net/BeNoble\_/article/details/53201146

详细的剪枝


---

## 作者：yyyxy (赞：1)

搜索加剪枝

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int m,n,Minv[21],Best;
void Read()
{  int i;
   cin>>n>>m;
   Minv[0]=0;
   for(i=1;i<=m;i++)Minv[i]=Minv[i-1]+i*i*i;  //初始化最小体积和
}
void search(int floor,int r,int h,int s,int v)//对每层蛋糕进行搜索
{  int i,j,Maxv;
   if(floor==0&&v==0){if(s<Best)Best=s;return;}
   if(s+2*v/r>=Best)return;//剪枝1,最优性剪枝
   if(v<Minv[floor])return;//剪枝2,根据下界进行可行性剪枝
   Maxv=0;
   for(i=floor;i>=1;i--)Maxv+=(r-i)*(r-i)*(h-i);//最大方式做蛋糕
   if(Maxv<v)return; //剪枝3,根据上界进行可行性剪枝
   for(i=r-1;i>=floor;i--) //枚举floor层蛋糕的半径
      for(j=h-1;j>=floor;j--) //枚举floor层蛋糕的高度
         search(floor-1,i,j,s+2*i*j,v-i*i*j);
}
int main()
{  int r,h,s,v;
   Read();
   Best=0x7fffffff/2;
   for(r=m;r<=sqrt(n);r++)//枚举最底层蛋糕的半径
      for(h=n/(r*r);h>=m;h--)//枚举最底层蛋糕的对应高度
      {  s=r*r+2*r*h;
         v=n-r*r*h;
         search(m-1,r,h,s,v);
      }   
   cout<<Best<<endl;
}

```

---

## 作者：SteinsGate0 (赞：1)

深搜+加剪纸。有很多可以捡的地方。

1.最优化剪纸。当前的已经大于ans.

2.可行性剪纸。当前v+最小剩下v任然大于n，或加最大v仍小于n。

3.注意hi与ri限制

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int inf=0x3f3f3f3f;
int n,m,s,minv[25],mins[25],ans=inf;
void dfs(int sumv,int sums,int cur,int r,int h){
    int i,j,temp;
    if(cur==0){
        if(sumv==n)ans=min(sums,ans);
        return;
    }
    if(sumv+minv[cur]>n)return;
    if(sums+mins[cur]>ans)return;
    if(2*(n-sumv)/r+sums>=ans)return;
    for(i=r-1;i>=cur;i--){
        if(cur==m)sums=i*i; 
        temp=min((n-minv[cur-1]-sumv)/i/i,h-1);
        for(j=temp;j>=cur;j--)
            dfs(sumv+i*i*j,sums+2*i*j,cur-1,i,j);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        minv[i]=minv[i-1]+i*i*i;
        mins[i]=mins[i-1]+2*i*i;
    }
    dfs(0,0,m,n+1,n+1);
    printf("%d",ans==inf?0:ans);
}
```

---

## 作者：远航之曲 (赞：1)

搜索题

朴素的会炸

所以,剪枝是必要的:

最优化剪枝

k层蛋糕的最小表面积可知(h,r都为整数)

当前s可知

那么,s+剩下层数最小表面积>=min最无需再往下搜了

可行性剪枝

k层蛋糕的最小体积minv可知

k层蛋糕的最大体积maxv可知

那么,剩下的体积v不在minv至maxv的范围内,即可停止搜索

#include<cstdio>

#include<cmath>

#include<cstring>

using namespace std；

 
 
```cpp
int ans=999999;
int n,m,temp;
int min[50];
inline int max(int r,int h,int k)
{
    int i,p=0;
    for (i=1;i<=k;i++) p+=(r-i)*(r-i)*(h-i);
    return p;
}
void dfs(int v,int k,int r,int h,int s)
{
    int ss=s,sss=s,vv=v;
    for (int i=r-1;i>0;i--)
    {
        if (k==1) ss=s+i*i;
        for (int j=1;j<h && i*i*j<=v;j++)
        {
            sss=ss+2*i*j;
            vv=v-i*i*j;
            if (vv<min[m-k]) break;
            if (vv>max(i,j,m-k)) continue;
            double tmp;
            tmp=3*pow((double)vv,2.0/3.0)-(i-1)*(i-1);
            if (tmp+sss>ans) continue;
            if (k<m) dfs(vv,k+1,i,j,sss);
                else if (sss<ans) ans=sss;
        }
    }
}
int main()
{
    //freopen("cake.in","r",stdin);
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) min[i]=min[i-1]+i*i*i;
    temp=sqrt((double)n)-m*(m-1)/2+1;
    dfs(n,1,temp,temp,0);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：远山淡影 (赞：0)

```
#include<cmath>
#include<cstdio>
#include<cstring>
using  namespace  std;
int n,m,ans=999999999;
int a[20000],b[20000],c[20000],alen;//平方
inline int mymin(int x,int y) {return x<y?x:y;}
void dfs(int x1,int x2,int x3,int x4,int x5)
/*
x1表示剩余体积，x2表示表面积，x3表示到第几层，x4与x5表示上一层的高和半径 
*/
{
	if(x3==0)
	{
		if(x1==n && x2<ans) ans=x2;
		return ;
	}
	if(x2+2*(n-x1)/x4>ans) return ;
	if(x2+b[x3]>=ans || a[x3]>n-x1) return ;
	int ed=mymin(x4-1,sqrt((n-x1)-c[x3-1]));
	for(int i=ed;i>=x3;i--) //枚举上一层的半径
	{
		if(x3==m) x2=i*i;
		int edd=mymin(x5-1,(n-x1)/(i*i));
		for(int j=edd;j>=x3;j--) //枚举上一层的高
			dfs(x1+i*i*j,x2+2*i*j,x3-1,i,j);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		a[i]=a[i-1]+i*i*i;
		b[i]=b[i-1]+2*i*i;
		c[i]=c[i-1]+i;
	}
	dfs(0,0,m,sqrt(n)+1,n+1);
	if(ans==999999999) ans=0;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Undefined_Myth (赞：0)

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
#define MAXN 20005
#define MAXM 16
int n,m;
int Vmin[MAXM+1];
int ans=999999999;//记得初始化一个特别大的值 
void dfs(int dep,int r,int h,int s,int v)//还剩下x层，之前一层半径r，高度h，s 为到了这里时的表面积  v 为剩余的体积 
{
    //剪枝 
    if(Vmin[dep] > v)    return;     //最小都不能构造完 cut 
    // r h 为之前的数据  r-1 h-1 是现在的最大值 
    if(dep*(r-1)*(r-1)*(h-1) < v)    return;//如果剩余的体积太大的话，连之后的每层的体积较这一层都没有少都不能用完则 cut 
    //本来剪枝要更细的  但是由于复杂度高  而且难算难想 所以我们把界限可以放宽一点 
    //v == 0其实可以不加 因为当 dep = 0 则Vmin[dep] = 0  dep*(r-1)*(r-1)*(h-1) = 0 那么v >（或者<0） 0 不满足 所以v = 0
    if(dep == 0 && v == 0){
        if(s < ans) ans = s;            
        return ;
    }
    //枚举r 和 h 
    /*for(int i=dep;i*i*dep<=v;i++){
        if(s + 2 * v / i > ans)    continue;
        for(int j=dep;i*i*j<=v;j++)
                dfs(dep-1,i,j,s+2*i*j,v-i*i*j);
    }*/
    //枚举当前一层的半径 
    for(int i=dep;i<r;i++){//不写上面的那种 是因为 <r <h  更优，而且不满足的话 在上面的if一定会被cut  v 会变负数  
        if(s + 2 * v / i > ans)        continue;    //可行性剪枝 
        for(int j=dep;j<h;j++)                //枚举当前一层的高度 
            dfs(dep-1,i,j,s+2*i*j,v-i*i*j);
    }    
}
```
/\*
//注意下面的字母有些地方时有下划线的 

怎样求剩余部分侧面积下限？

V=Ri+12\*Hi+1+Ri+22\*Hi+2+…+Rm2\*Hm

2V=Ri+1\*Si+1+Ri+2\*Si+2+…+Rm\*Sm

2V＜Ri+1\*S总min

即S总min＞2V/Ri+1

\*/
```cpp
int main()
{
    scanf("%d%d",&n,&m);
    //枚举底层的r和h 
    //记得初始化Vmin数组
    Vmin[0] = 0; 
    for(int i=1;i<=m;i++)//Vmin是这一层最小的体积        1~m   是从上到下 
        Vmin[i]=Vmin[i-1]+i*i*i;
    //i*i*m == n 是可以的  即只有一层 
    for(int i=m;i*i*m<=n;i++)//i*i*m<n 代表的是如果最底下那层的体积都>n  那么肯定不用考虑了 其他的情况后面有考虑和剪枝
        for(int j=m;i*i*j<=n;j++)
            dfs(m-1,i,j,i*i+2*i*j,n-i*i*j);//注意到这里已经用了一层了  所以是m-1 
    //特别注意: 由于是总共的表面积，那么除了侧面积之外还有每一层的上表面 把它们平移往上则是底层的底面积 而底层是不用涂的
    //所以只需要 也必须要+i*i 
    //由于圆周率是相同的    所以同时约去是没有影响的 
    printf("%d",ans);
        return 0;
}
```

---


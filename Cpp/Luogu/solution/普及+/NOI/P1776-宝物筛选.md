# 宝物筛选

## 题目描述

终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。

这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。

小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。

## 说明/提示

对于 $30\%$ 的数据，$n\leq \sum m_i\leq 10^4$，$0\le W\leq 10^3$。

对于 $100\%$ 的数据，$n\leq \sum m_i \leq 10^5$，$0\le W\leq 4\times 10^4$，$1\leq n\le 100$。

## 样例 #1

### 输入

```
4 20
3 9 3
5 9 1
9 4 2
8 1 3```

### 输出

```
47```

# 题解

## 作者：ezoiHQM (赞：204)

为什么都没有人用单调队列？	
那就补一发单调队列优化多重背包吧。
w表示物品重量，v表示价值，c表示数量，我们知道朴素状态转移方程： 	
```
f[i][j]=max(f[i−1][j−w∗k]+v∗k);(k<=c)
```	
现在我们要把这个方程变成一个单调队列可以优化的形式，于是我们假设:d=j mod w[i],s=⌊j/w[i]⌋ 	
```
f[i][j]=max(f[i−1][d+w∗k]−v∗k)+v∗s(s-k<=c) 
```
之后我们枚举余数d，然后对于每个余数d都用单调队列优化即可。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,V,ans,head,tail,q[40010],q2[40010],dp[40010];
int main(){
	scanf("%d%d",&n,&V);
	for(int i=1;i<=n;i++){
		int v,w,c;
		scanf("%d%d%d",&w,&v,&c);
		if(v==0){
			ans+=w*c;
			continue;
		}
		int k=V/v;
		c=min(c,k);
		for(int d=0;d<v;d++){
			head=tail=0;
			k=(V-d)/v;
			for(int j=0;j<=k;j++){
				while(head<tail&&dp[d+j*v]-j*w>=q2[tail-1])
					tail--;
				q[tail]=j;
				q2[tail++]=dp[d+j*v]-j*w;
				while(head<tail&&q[head]<j-c)
					++head;
				dp[d+j*v]=max(dp[d+j*v],q2[head]+j*w);
			}
		}
	}
	printf("%d",ans+dp[V]);
	return 0;
}
  ```

---

## 作者：檀黎斗·神 (赞：156)

很明显的一道多重背包问题

状态转移方程也很常规

唯一的问题就是数量实在是太多了

直接写模板的话肯定会超时

那么就需要用到优化了

这里用到的是二进制优化

首先我们要知道二进制优化的原理

以19为例，如果我们拆分成1,2,4,8,3

我们就可以用之前的五个数表示出1~19的所有数

那么五个数是怎么来的呢

其实就是相加小于等于该数的2的幂次方（1,2,4,8）和那个数与和的差值（3）

如果我们对于每个物品进行二进制优化就可以增加空间复杂度而减低时间复杂度了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ans,cnt=1;
int f[1000005];
int w[1000005],v[1000005];//记得将数组开大
int main()
{
    int a,b,c;
    scanf("%d%d",&n,&m);
    
    for(int i=1;i<=n;++i)
    {
        scanf("%d%d%d",&a,&b,&c);
        for(int j=1;j<=c;j<<=1)
        {
            v[++cnt]=j*a,w[cnt]=j*b;
            c-=j;
        }
        if(c) v[++cnt]=a*c,w[cnt]=b*c;
        //二进制优化,拆分 
    }
    
    for(int i=1;i<=cnt;++i)
     for(int j=m;j>=w[i];--j)
      f[j]=max(f[j],f[j-w[i]]+v[i]);
    //简单的多重背包 
    printf("%d\n",f[m]);
    return 0;
}
```

---

## 作者：maomao9173 (赞：78)

看图吧qwq，自以为讲的还算清晰![](https://cdn.luogu.com.cn/upload/pic/32074.png)
```cpp
#include<cstdio>
inline int max(int x,int y){return x>y?x:y;}
inline int min(int x,int y){return x<y?x:y;}
int n,sz,ans,tmp,f[40010],que[40010],num[40010];
int main(){
    scanf("%d%d",&n,&sz);
    for(int i=1;i<=n;i++){
        int v,w,m;
        scanf("%d%d%d",&w,&v,&m);
        if(v==0){ans+=m*w;continue;}//避免除数为0的情况 
        int can_use=min(m,sz/v);//can_use 表示最大可用数量
        for(int j=0;j<v;j++){//枚举每一个余数 
            //注意这里要保证转移到所有可以转移点
            int all_=(sz-j)/v,head=1,tail=0;//找到区间内这个余数下有机会转移到的所有点 
            //每次重置队列 
            for(int k=0;k<=all_;k++){//转移数量从0到all_不等 
                int push_in=f[j+k*v]-k*w;
                while(head<=tail&&push_in>=que[tail])tail--;tail++;//维护队列取最大 
                que[tail]=push_in;
                num[tail]=k;
                while(head<=tail&&num[head]+can_use<k)head++;//已经无法实现转移的话
                f[j+k*v]=max(f[j+k*v],que[head]+k*w);
                tmp=max(tmp,f[j+k*v]);
            } 
        } 
    }
    printf("%d",tmp+ans);
    return 0;
} 
```

---

## 作者：FlashHu (赞：62)

为了学习单调队列优化DP奔向了此题。。。

基础的多重背包就不展开了。设$f_{i,j}$为选前$i$个物品，重量不超过$j$的最大价值，$w$为重量，$v$为价值（蒟蒻有强迫症，特别不喜欢把$v$和$w$反着搞，$weight$和$value$嘛！），直接给转移方程

$$f_{i,j}=\max\{f_{i-1,j-kw_i}+kv_i\},k\in[0,min\{m,\lfloor \frac j{w_i}\rfloor\}]$$

显然，$f_i$都是从$f_{i-1}$转过来的，所以第一维可以滚掉，得到每次转移的更简化的方程

$$f_j=\max\{f_{j-kw}+kv\}$$

这样是$O(nmW)$的，还是要想办法优化。

众所周知，DP优化的根本原则是去掉无用的状态、利用重复转移的状态。可是这方程一眼根本看不出什么可优化的地方啊。。。。。。

我们要像这位Dalao一样善于发现，[他的blog](https://blog.csdn.net/flyinghearts/article/details/5898183)

所以，不管这个想法是怎么来的，我们先把$j$按模$i$意义下分组，设$j=k_1w+d$，那么一组里的$d$都是同一个值。

然后方程就变成了这样

$$f_j=\max\{f_{k_1w+d-kw}+kv\}$$

$$\qquad\qquad\qquad\quad=\max\{f_{(k_1-k)w+d}-(k_1-k)v\}+k_1v$$

突然看到了$k_i-k$的重复出现！这也就意味着，在每一组中，有意义的状态只有$\lfloor\frac{W-d}w\rfloor$种！（$W$是最大载重）每次总的状态也就只有$O(W)$了。

设$g_k=f_{kw+d}-kv$。那么因为有$m$的限制，所以对于每个$k_1$，我们需要且只能从$max\{g_k|k\in[\max\{0,k_1-m\},k_1]\}$转移。对于这样的转移，可以形象地和[滑动窗口](https://www.luogu.org/problemnew/show/P1886)联系一下，相当于有一个宽度为$m$的窗口从一边一步步往另一边移动，每移一次都要取出窗口内的最大值。这个就上单调队列维护。

首先枚举$d$。接着，为了方便滚动，我们从大到小枚举$k$和$k_1$，用一个单调队列维护下标在$[k_1-m,k_1]$范围内的依次递减的若干个$g$值，因为显然如果有$g_x\geq g_y,x<y$的话$g_y$是没有用的。枚举$k_1$时，每次队首元素超出了范围就把它出队。用现在的队首更新$f_j$即$f_{k_1w+d}$。接着下一个元素$g_{k_1-m-1}$要入队了，把队尾$g$比这个小的全出队，再让它进来。最后输出$f_W$即可。

这样就是$O(nW)$的了，比二进制拆分难理解些但是更优秀了。

结合代码理解会更轻松哦
```cpp
#include<cstdio>
#define RG register
#define R RG int
#define G c=getchar()
const int N=1e5+9;
int f[N],g[N],q[N];
inline int in(){
	RG char G;
	while(c<'-')G;
	R x=c&15;G;
	while(c>'-')x=x*10+(c&15),G;
	return x;
}
inline int max(R x,R y){return x>y?x:y;}
inline void chkmx(R&x,R y){if(x<y)x=y;}
int main(){
	R n=in(),maxw=in(),maxk,lim,v,w,m,d,i,k,k1,h,t,now;
	for(i=1;i<=n;++i){
		v=in();w=in();m=in();
		for(d=0;d<w;++d){//枚举余数
			maxk=(maxw-d)/w;lim=max(maxk-m,0);//先确定最初的范围
			for(t=0,k=maxk-1;k>=lim;--k){//窗口先扩大宽度到m
				now=f[k*w+d]-k*v;
				while(t&&g[t]<=now)--t;//维护单调性
				g[++t]=now;q[t]=k;
			}
			for(h=1,k1=maxk;~k1;--k1,--k){//可以开始转移了
				if(h<=t&&q[h]>=k1)++h;//接着移动
				if(h<=t)chkmx(f[k1*w+d],g[h]+k1*v);//转移
				if(k<0)continue;//注意窗口可能已经出正数范围了
				now=f[k*w+d]-k*v;
				while(h<=t&&g[t]<=now)--t;//维护单调性
				g[++t]=now;q[t]=k;
			}
		}
	}
	printf("%d\n",f[maxw]);
	return 0;
}
```

---

## 作者：Owen_codeisking (赞：32)

## 引言

本蒟蒻在$wzms$的机房中听教练讲用单调队列优化dp没听懂，所以特地来刷一刷裸的多重背包。

多重背包与01背包和完全背包不一样的地方在于，它处于一个两者之间的境地，所以多重背包注定需要一些神奇的数据结构优化。

若你单调队列没学过，请你看一看 $P1886$ 滑动窗口

## 正文

首先声明，我的变量名与题中不一样。我定义$N$为物品个数，$M$为背包总量，$V_{i}$是第$i$件物品的重量，$W_{i}$是第$i$件物品的价值，$C_{i}$是第$i$件物品的可放总量，$F_{i}$表示在$i$重量下能收获的最大价值。


可知当$k\in[0,C_{i}],u\in[0,v[i])$时，有

$$F[u+k*v[i]]=max(F[u+k*v[i]],F[u]+k*w[i])$$

那么在已知$F[u]$是由$F[u+t*v[i]]-t*w[i]$这个状态转移过来时

$$F[u+k*v[i]]=max(F[u+k*v[i]],F[u+t*v[i]]-t*w[i]+k*w[i])$$

那么定义能放下的最大当前物品个数为$maxp$，易得

$$maxp=(m-u)/v[i]$$

而$t\in[max(maxp-j-c[i],0),maxp-j],j\in[0,maxp]$时

$$F[u+t*v[i]]$$

这一状态会被重复计算，这个时候单调队列就能排上用场了。

再定义$calc(i,u,k)=F[u+k*v[i]]-k*w[i]$，单调队列首尾为$l,r$,那么可知状态转移方程

$$F[u+k*v[i]]=max(F[u+k*v[i]],calc(i,u,q[l])+k*w[i])$$

有且仅当在$l<=r$时发生转移。

那么我们理一下思路

（0）预处理时$F[0]=0,F[i]=-INF(i\in[1,m])$

（1）每次读进来一组$V_{i}$ ,$W_{i}$ ,$C_{i}$ 时,将$m$重量进行模$V_{i}$分组，先将物品个数$maxp$到$max(maxp-c[i],0)$之间进入单调队列，其维护放入物品个数$k$单调递减，所对应的$calc$也单调递减。只要当$l<=r$且$calc(i,u,q[r])<=calc(i,u,k)$时,$r--$。否则将$k$压入队列

（2）逐一枚举$k$从$maxp$到$0$，只要当$l<=r$且$q[l]>k-1$时,$l++$。但若$k-C_{i}-1>=0$，则将新的物品个数在满足（1）条件下压入队列以保证下一轮的状态转移

（3）在$F_{i}(i\in[1,m])$中取出最大值$ans$，输出$ans$

$Code\quad Below:$

```cpp
#include <bits/stdc++.h>
#define maxn 110
#define maxm 100010
using namespace std;
int n,m;
int v[maxn],w[maxn],c[maxn];
int f[maxm],q[maxm];

int calc(int i,int u,int k){
	return f[u+k*v[i]]-k*w[i];
}

int main()
{
	memset(f,0xcf,sizeof(f));
	scanf("%d%d",&n,&m);
	f[0]=0;
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&w[i],&v[i],&c[i]);
		for(int u=0;u<v[i];u++){
			int l=1,r=0;
			int maxp=(m-u)/v[i];
			for(int k=maxp-1;k>=max(maxp-c[i],0);k--){
				while(l<=r&&calc(i,u,q[r])<=calc(i,u,k)) r--;
				q[++r]=k;
			}
			for(int k=maxp;k>=0;k--){
				while(l<=r&&q[l]>k-1) l++;
				if(l<=r) f[u+k*v[i]]=max(f[u+k*v[i]],calc(i,u,q[l])+k*w[i]);
				if(k-c[i]-1>=0){
					while(l<=r&&calc(i,u,q[r])<=calc(i,u,k-c[i]-1)) r--;
					q[++r]=k-c[i]-1;
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++)
		ans=max(f[i],ans);
	printf("%d\n",ans);
	return 0;
}
```

补充：正常$476ms$，开了$O_{2}\quad 84ms$，可能还有些神奇的优化能让正常的时间快一些，留给读者自己思考。

---

## 作者：Diaоsi (赞：31)

## 题目链接：[传送门](https://www.luogu.com.cn/problem/P1776)
## 思路：

这道题是一道多重背包问题，我们可以把每一组物品都按照一个个地拆开存到数组里，这样就把问题转换成一个01背包问题了

### 时间复杂度：

$$O(NW\sum_{}m_i)$$

**但是**，这样会超时，只能拿到30pts,开$0_2$可以得到80pts

$30/80pts Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int n,m,x,y,z,cnt,f[N],w[N],v[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&x,&y,&z);
		for(int j=1;j<=z;j++)v[++cnt]=x,w[cnt]=y;
	}
	for(int i=1;i<=cnt;i++)
		for(int j=m;j>=w[i];j--)
			f[j]=max(f[j],f[j-w[i]]+v[i]);
	printf("%d\n",f[m]);
	return 0;
}
```

上面那种方法的时间主要是浪费在枚举每一个物品取$0 \thicksim m_i$种的情况上，那我们现在就要优化这个过程，减少枚举的次数就可以直接降低时间复杂度

下面引入一种优化方法：**二进制拆分**

以$34$为例

$34$可以拆分成$1+2+4+8+16+3$

也就是$1_{(2)}+10_{(2)}+100_{(2)}+1000_{(2)}+10000_{(2)}+3_{(10)}$

按上面的方式拆分后，我们可以用前五个数组合出$(1 \thicksim 34-3)$的正整数

显然易见$(32 \thicksim 34)$也可以通过之前组合出的数加上差值$3$得出

这样我们就可以通过枚举二进制拆分出来的方案得出每一个物品取$0 \thicksim m_i$种的情况了，不会超时

### 时间复杂度：

$$O(NW\sum_{}log~m_i)$$

### 二进制拆分的代码:

$Code:$

```cpp
for(int i=1;i<=n;i++){
		scanf("%d%d%d",&x,&y,&z);
		for(int j=1;j<=z;j<<=1)v[++cnt]=x*j,w[cnt]=y*j,z-=j;
		if(z)v[++cnt]=x*z,w[cnt]=y*z;//差值
	}
```
## 代 码 放 送：

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int n,m,x,y,z,cnt,f[N],w[N],v[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&x,&y,&z);
		for(int j=1;j<=z;j<<=1)v[++cnt]=x*j,w[cnt]=y*j,z-=j;
		if(z)v[++cnt]=x*z,w[cnt]=y*z;//差值
	}
	for(int i=1;i<=cnt;i++)
		for(int j=m;j>=w[i];j--)
			f[j]=max(f[j],f[j-w[i]]+v[i]);
	printf("%d\n",f[m]);
	return 0;
}
```


---

## 作者：mrsrz (赞：22)

多重背包问题。


然而貌似直接枚举k是会超时的，所以需要加上优化。


我们把每个k拆成1+2+4+8+...+2^n+x的形式，然后进行背包。


容易知道，这样拆分出的物品能保证选取其中若干个相加可以的到0~k的所有数量，且原来有k件物品，现在只有log k件，大大减少运算量。

```cpp
#include<cstdio>
#include<cstring>
int n,w,f[40005]={0};
int main(){
    scanf("%d%d",&n,&w);
    while(n--){
        int i,p,v,k;
        scanf("%d%d%d",&p,&v,&k);
        for(i=0;((1<<(i+1))-1)<=k;++i){
            for(int j=w;j>=(v<<i);--j)
            if(f[j-(v<<i)]+(p<<i)>f[j])
            f[j]=f[j-(v<<i)]+(p<<i);
        }
        v=v*k-(v<<i)+v;
        p=p*k-(p<<i)+p;
        if(v)
        for(int j=w;j>=v;--j)
        if(f[j]<f[j-v]+p)f[j]=f[j-v]+p;
    }
    printf("%d\n",f[w]);
    return 0;
}
```

---

## 作者：joe19025 (赞：20)

##  [题目链接](https://www.luogu.org/problemnew/show/P1776)


------------

## 解法
### 直观做法

是不是很眼熟？

没错，就是开始学DP时，天天出现的[背包问题](https://wenku.baidu.com/view/cf9f0f8ecc22bcd126ff0c73.html)（这里不做过多解释，不会的话点背包问题，查看相关论文）。

#### 状态转移方程（很显然）：

$f[i][j]=max(f[i-1][j-k*w[i]]+k*v[i])(0<=k<=m[i])$

那么这个的时间复杂度一看就很暴力，肯定是AC不了的。
那么该怎么办呢？


### 正解
#### 闲着没事干瞎推
设$j=k_1*w[i]+d$

$f[i][j]=max(f[i-1][(k_1*w[i]+d)-k*w[i]]+k*v[i])$

合并同类项

$$f[i][j]=max(f[i-1][(k_1-k)*w[i]+d]-(k_1-k)*v[i]+k_1*v[i])$$

由于$k_1$只和j有关，可以提出：
$$f[i][j]=max(f[i-1][(k_1-k)*w[i]+d]-(k_1-k)*v[i])+k_1*v[i]$$

#### 这都什么乱七八糟的，有卵用？！接着往下看

我们设$g[i][k]=f[i-1][k*w[i]+d]-k*v[i]$

所以问题就可以就变成下面的了：

$f[i][k_1*w[i]+d]=max(g[i-1][k])+k_1*v[i](max(k_1-m,0)<=k<=k_1)$

#### 这可以上单调队列了！
所以每层只需要逐个枚举$d$，然后再枚举$k$，一个单调队列优化一下，就好啦！分层分块思想。

最后加一个滚动数组优化，要不会爆内存。

这就AC啦！妙哉~

### 分析
这个题利用的是单调队列的性质，但是单调队列不能处理形如:$max(f[i-k*x]+k*y)$的问题，因为其中又加了一个变量$k*y$, $i-k*x$会随i改变对应位置,这样对于每个$f[j]$在计算不同的$f[i]$时会要有不同的增量。

我们对于这个问题的解决方法是将状态转移方程进行一定的转化，转化成单调队列能解决的形式，用单调队列进行加速。


------------
## Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>
#define eps 1e-12
#define MAXN 100005
#define INF 0x3f3f3f3f
using namespace std;

int main()
{
    long long f[40004][2];
    long long now=1;
    long long pre=0;
    long long w[105];
    long long v[105];
    long long m[105];
    long long n,W;
    scanf("%lld%lld",&n,&W);
    for(int i=1;i<=n;i++)
        scanf("%lld%lld%lld",&v[i],&w[i],&m[i]);
    memset(f,0,sizeof(f));
    long long q[40005][2];
    for(int i=1;i<=n;i++)
    {
        for(int d=0;d<w[i];d++)
        {
            int head=0,tail=0;
            for(int k=0;k*w[i]+d<=W;k++)
            {
                while(head<tail&&q[head][0]<k-m[i])head++;
                while(head<tail&&q[tail-1][1]<f[k*w[i]+d][pre]-k*v[i])tail--;
                q[tail][0]=k;
                q[tail][1]=f[k*w[i]+d][pre]-k*v[i];
                tail++;
                f[k*w[i]+d][now]=q[head][1]+k*v[i];
            }
        }
        swap(now,pre);
    }
    printf("%lld",f[W][pre]);
    return 0;
}
```

---

## 作者：M_yuxuan2004 (赞：12)

主要是采用2进制的优化，不然可能会爆WOC

2进制优化的基本思路：

exp.:用1,2,4,8可以表示从1~15中的所有的数

每一个物品有m[i]个，所以这道题可以转化为01背包解决

我们可以把每一个物品复制成m[i]份，每一份的特征和原数一样

但是单纯的展开可能会爆空间WOC

所以我们可以采用二进制优化，及每一个物品只展开为n个物品

n|2^0+2^1+2^2...+2^n<=m[i]

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+8;
int n,w;
int v[MAXN],c[MAXN],m[MAXN];
int f[MAXN];
int main()
{
	cin>>n>>w;
	int cnt=0;
	for(int i=1;i<=n;i++)
	{
		int a,b,m;
		cin>>a>>b>>m;
		for(int j=1;j<=m;j*=2)
		{
			v[++cnt]=j*a,c[cnt]=j*b;
			m-=j;
		}
		if(m)
			v[++cnt]=m*a,c[cnt]=m*b;
	}
	for(int i=1;i<=cnt;i++)
		for(int j=w;j>=c[i];j--)
			f[j]=max(f[j],f[j-c[i]]+v[i]);
	cout<<f[w];
	return 0;
}
```


---

## 作者：pidan (赞：11)

```
题目描述

终于，破解了千年的难题。小FF找到了王室的宝物室，里面堆满了无数价值连城的宝物……这下小FF可发财了，嘎嘎。但是这里的宝物实在是太多了，小FF的采集车似乎装不下那么多宝物。看来小FF只能含泪舍弃其中的一部分宝物了……小FF对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小FF有一个最大载重为W的采集车，洞穴里总共有n种宝物，每种宝物的价值为v[i]，重量为w[i]，每种宝物有m[i]件。小FF希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。

输入输出格式

输入格式：
第一行为一个整数N和w，分别表示宝物种数和采集车的最大载重。

接下来n行每行三个整数，其中第i行第一个数表示第i类品价值，第二个整数表示一件该类物品的重量，第三个整数为该类物品数量。

输出格式：
输出仅一个整数ans，表示在采集车不超载的情况下收集的宝物的最大价值。

输入输出样例

输入样例#1:
4 20
3 9 3
5 9 1
9 4 2
8 1 3
输出样例#1：
47
说明

对于30%的数据：n≤∑m[i]≤10^4；0≤W≤10^3。

对于100%的数据：n≤∑m[i]≤10^5；

0 <w≤4*10^4：1≤n<100。
```

------------

~~突然发现这道题好水啊orz~~

实际上，这是一道多重背包。**后排有人偷偷笑了**。

然鹅，这道题必须要优化，摆脱O(n^3)的束缚（看数据范围就知道了嘛）！

本蒟蒻在刚学时，教练教的是二进制优化，这种方法可以直接把O(n^3)变成O(n^2log(n))。在数据不是很大时，是可能水过的。

单调队列就不讲了，主要介绍一下二进制优化的思想：

众所周知，用1,2,4,8……2^(n-1)是可以凑出1~2^n-1之间的所有数的

那么，同理，当我有n个物品时，可以将它拆分成1,2,4,8……2^k(2^k<=n<2^(k+1))个独立的物品堆，来凑出1~n之间的所有数量。

但是，不是每个数都一定正好是2的正整数次幂啊，因此1+2+4+8+……+2^k不一定等于n

这时，只需要把剩下的再作为一堆物品就行了

则当小FF需要选择x件该物品时，可以用2的幂件物品来凑成x

上代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[505],b[505],c[505],dp[60001];
void pidan(int p,int q){//哈哈，我的用户名
    for(int j=m;j>=p;j--){
        dp[j]=max(dp[j],dp[j-p]+q);//01背包
    }
    return;
}
void nadip(int p,int q){//哈哈，我的用户名反过来
    for(int j=p;j<=m;j++){
        dp[j]=max(dp[j],dp[j-p]+q);//完全背包
    }
    return;
}
void multiplepack(int mon,int p,int num){
    if(mon*num>=m){
        nadip(mon,p);
    }//小优化：如果该物品的总数乘以重量大于能承载的总重量，
    //即认为该物品无限供应
    else {
        int k=1;
        while(k<=num){
            pidan(k*mon,k*p);
            num-=k;
            k*=2;
        }
        pidan(num*mon,num*p);
    }//二进制拆分
    return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];//输入
    for(int i=1;i<=n;i++){
        multiplepack(b[i],a[i],c[i]);//多重背包
    }
    cout<<dp[m];//输出
    return 0;
}
```
在while循环中，如果调用的01背包选择了这件物品，则我们可以认为小FF选择了2^k件该物品。之前说过，如果小FF需要x件该物品，他可以选择2的幂件物品来凑成x，这样就可以不用枚举小FF选择的件数了。

教练还给我们出了一道很恶心的多重背包（可我做了满分哈哈哈）：


------------


```
【问题描述】
小 z 准备举办一个比赛。他需要提供一些甜点给参赛者来补充能量。每种甜品有一定的
能量 ti 和大小 ui，且每种甜点最多有 vi 个。
小 z 准备用箱子来包装甜点。箱子可以容纳一定体积的甜点且需要一定的费用。小 z
有一种魔法，可以将一个甜点分成多份装在箱子里，最后再合在一起（但合成之后必须是完
整的一个）。
小 z 想知道准备能量至少为 P 的甜点的最小大小和最少需要多少费用来购买箱子，如果
最少费用超过小 z 所拥有的钱数 k 则输出 FAIL。
【输入格式】
第一行为 4 个正整数 n,m,p, k( 1 ≤ n ≤ 200,1 ≤ m ≤ 200,0 ≤ p ≤ 50000, k <=
50000)分别代表甜点种类，箱子种类和参赛者比赛所需要补充的能量和小 z 所拥有的钱数。
接下来的 n 行，每行包含 3 个整数 ti, ui, vi ( 1 ≤ ti ≤ 100,1 ≤ ui ≤ 100,1 ≤
vi ≤ 100) , 代表第 i 类甜点可以提供 ti 的能量，它的大小为 ui 并且小明最多有 vi 个该
种类的甜点。
接下来又有 m 行，每一行包含 3 个整数 xi, yi, zi ( 1 ≤ xj ≤ 100,1 ≤ yj ≤ 100,1
≤ zj ≤ 100), 代表第 i 类箱子可以容纳 xi 大小的甜点，该类箱子的单价 yi,并且小 z 最
多可以使用 zi 个该类的箱子。
【输出格式】
第一行请输出最小的甜点大小。
第二行请输出最小的箱子费用，并且费用不能超过 k。否则，输出 FAIL。
【样例输入】
5 3 34 34
1 4 1
9 4 2
5 3 3
1 3 3
5 3 2
3 4 5
6 7 5
5 3 8
【样例输出】
19
12
【数据范围与约定】
对于每个测试点。 本题第一行正确得 4 分， 第二行正确得 6 分， 两行都正确得 10 分。
30%: n, m <= 15, p, k <= 1000
60%: n, m <= 50, p, k <= 5000
100%: n, m <= 200, p <= 50000, k <= 50000
```

这个大家可以多想一想，同样需要优化。

---

## 作者：Celebrate (赞：5)

点击这里：

[我的博客](https://blog.csdn.net/zsyzClb/article/details/84582792)

这一道题又两种做法，一种是被倍增，另一种是单调队列

前者相信大家都会，我就不讲了，后者我看了很多博客，他们都写的我一脸懵逼

我研究了好久，终于知道怎么做了

首先定义一个dp数组

dp[i]表示到达i重量时的最大值

枚举1-n

对于当前的宝物，它的意义就是更新数组，所以我们至少要用到一个

举个栗子，假设当前的宝物重量为3，数量为3，价值不说（在这个栗子中没有意义）

用一个指针j从1一直到W，假设现在指到W-1，那么就是这样继承的

![undefined](https://img-blog.csdnimg.cn/20181128135251373.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzeXpDbGI=,size_16,color_FFFFFF,t_70)

我们给这些格子分一个组，按照每w个为一组，这个继承的状态就十分的明显了

dp[j]=max(dp[j-k*w]+k*v)  (1<=k<=w)

因为分了组，每一组中相同位置的继承有几分相似，感觉就可以用单调队列了

可是因为公式k*v的阻碍，所以现在还不能用单调队列

所以我们可以考虑把公式改一改

假如当前的位置是r，要继承l

那么需要找出（r-l)有多少个v，我们本来想的是先把（r-l）算出，然后再算v

利用整式乘法，可以先找出r中v的个数，再减去l中v的个数

所以我们就可以巧妙的把r消去，从而进行单调队列的优化

代码就是先把所有位置除以w以后，余数相同的取出来一起算

我后面可能讲的不是很明白，但是你们看图就能明白是什么意思了

更加清晰详细的代码在后面

```
#include<cstdio>
#include<iostream>
using namespace std;
inline int read(){
    int x=0,f=0;char s=getchar();
    while(!isdigit(s))f|=s=='-',s=getchar();
    while( isdigit(s))x=(x<<1)+(x<<3)+s-48,s=getchar();
    return !f?x:-x;
}
inline void print(int x){
    if(x/10>0)print(x/10);
    putchar(x%10+'0');
}
const int N=4e4+10;
int n,W;
int ans,maxx,dp[N];
int head,tail;
struct node{
    int x,p;//x表示值，p表示位置 
}list[N];
int main(){
    int v,w,m;
    n=read();W=read();
    for(int i=1;i<=n;i++){   
        v=read();w=read();m=read();//读入 
        if(w==0){ans+=m*v;continue;}//如果w是0，就不用在算了 
        for(int j=0;j<w;j++){
            int t=(W-j)/w;//枚举所有的余数 
            head=1;tail=0;//一开始队列里面没有任何数 
            for(int k=0;k<=t;k++){//t表示W个格子可以分成的组数 
                int now=dp[j+k*w]-k*v;//将队列改为这种样子能够保证单调队列的正确性 
//这个地方要先入队列，否则队列里将会没有数，又因为以前用过所以可能导致计算结果出现错误 
                while(head<=tail&&now>=list[tail].x)tail--;//入队 
                list[++tail]=(node){now,k};
                while(head<=tail&&list[head].p<k-m)head++;//如果对头超过了这个范围，就head++ 
                dp[j+k*w]=max(dp[j+k*w],list[head].x+k*v);// 算出dp[j+k*w] 
                maxx=max(maxx,dp[j+k*w]);//记录最大值 
            } 
        } 
    }
    print(maxx+ans);//不要忘记加上ans哦 
    return 0;
} 

```


---

## 作者：李若谷 (赞：4)

### 倍增优化DP

题解有很多，但是很少详细讲的。这里详细的讲一下倍增优化多重背包。


------------
首先，我们要考虑的是如何把多重背包变成01背包。

一种很简单的想法是把一种宝物分为m种，然后在这上面做01背包。

比如

7可以分为1 1 1 1 1 1 1

01背包对应的是每一个数选0次或者1次，所以01背包这7个1，便可以枚举出0-7的最大值了。

但是如果这样做的话时间复杂度会到 $O(n*w*m)$ 肯定无法过本题。


------------


一种比较聪明的想法是用二进制来优化。首先，我们知道任何一个数都可以用2的幂次方之和来表示。

比如说 $9 = 2^0 + 2^3$ 

根据二进制其实就是 $9 = 1*2^0 + 0*2^1 + 0*2^2 + 1*2^3$

那么，事实上我们可以不用把一个数分为若干个1，可以分为2的幂次，大大的减少了时间复杂度。


------------


举个例子

比如说一个宝物的 $m = 7$

代表着这个宝物可以选0-7次。

那么事实上用 $2^0, 2^1, 2^2$ 中选若干个的和表示出来。

0-7中，4 可以表示为 $2^2$ ，5可以表示为 $2^2 + 2^0$ 一次类推。

所以$2^0, 2^1, 2^2$可以加起来变为0-7中任意一个数。（事实上如果知道二进制，这就是显然的）。

其实7是一个特殊的栗子，因为它刚好是 $2^3-1$。

举一个不特殊的栗子

0-12 可以表示为 $2^0,2^1,2^2,5$的和。

为什么最后一个是5呢？首先单靠$2^0,2^1,2^2$肯定是无法加起来成0-12。如果再用 $2^3$的话 那么总和就可以拼成 0-15了。这样会超过12，使得m不正确。但是如果选5的话就可以拼成且仅能拼成0-12中任意一个数。

证明：因为根据二进制，$2^0,2^1,2^2$ 可以拼成0-7。

那么0-7中任意一个数+5就可以变成5-12。既然又能拼成0-7，又能拼成5-12，所以能够拼成0-12。


------------

好了，现在说一下具体怎么求。

（这里用s代表宝物的数量不是题目中的m）

对于一个s，我们可以以次试 $2^0 + 2^1 + 2^2 ....$是否小于s。如果大于s的话，就舍去最后一个幂，然后把最后一项变成，$s- 2^0 + 2^1 + 2^2 ....2^k$。

这样拆分就可以凑成1-s中每一个数，然后用01背包求解就行了。

因为是2的幂次。所以总时间复杂度为 $O(n*w*log_2{m})$。

代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 45000;
int n,m;
long long v[N],f[N],w[N];
inline int read()
{
	int ans = 0;
	char ch = getchar();
	short f = 1;
	while(ch<'0'||ch>'9')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans = ans * 10 + ch-'0';
		ch = getchar();
	}
	return ans * f;
}
int main()
{
	n = read(), m = read();
	int cnt = 0;
	for(register int i=1;i<=n;i++)
	{
		int a,b,s;
		a=read(),b=read(),s=read();
		int k = 1;
		while(k<=s)
		{
			cnt++;
			v[cnt] = a*k;
			w[cnt] = b*k;
			s-=k;
			k*=2;
		}
		if(s>0) 
		{
			cnt++;
			v[cnt] = a*s;
			w[cnt] = b*s;
		}
	}
	n = cnt;
	for(int i=1;i<=n;i++)  //01背包
		for(int j=m;j>=w[i];j--)
			f[j] = max(f[j],f[j-w[i]]+v[i]);

	cout<<f[m]<<endl;
	return 0;
}
```



---

## 作者：谬悠 (赞：4)

这题唯一的坑点就在于数组大小，RE*3，用的二进制优化，大佬们讲的很清楚了，我最多带一下，主要分析一下数组应该开多大QAQ

刚开始我盲开开错了，后来瞎调成10W才过的

那么明明n<=100，为什么要开这么大呢？

~~其实我也不知道~~

分析：首先我们可以看到数量mi<=10^5，折合2^19?再加上1，那么一个物品最多被分割成20份

总共有100份，辣么我们的种类最多2000种，v与w开到2000多就差不多了，而我们的m，只有在分解阶段有用，所以开100就可以惹，但我们做的是01背包，所以dp数组要开大，因为他的下标表述的是背包容量，最高只有4*10^4；

虽然这题不需要卡空间，但想明白每个数组要开多大是很重要的事情，就像我们要弄明白我们的家里有什么一样

下面就是卡空间AC代码//交了好多次，求管理员原谅QAQ

等我没那么蒟蒻且做的题多了写一写卡空间的艺术吧QWQ

其实这也不是坑，我也是看到一个小可爱问那个数组要开多大才写的，祝大家CSP RP++！

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int a[2005],b[2005],c[105],dp[40005],v,n;
int main() {
	cin>>n>>v;
	for(int i=1; i<=n; i++) {
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
	}
	int k=n;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=c[i]; (j=j<<1)) {
			c[i]-=j;
			a[++k]=a[i]*j;
			b[k]=b[i]*j;
		}
		if(c[i]) {
			a[++k]=a[i]*c[i];
			b[k]=b[i]*c[i];
		}
	}
	for(int i=n+1; i<=k; i++) {
		for(int j=v; j>=b[i]; j--) {
			dp[j]=max(dp[j],dp[j-b[i]]+a[i]);
		}
	}
	cout<<dp[v]<<endl;
	return 0;
}
```


---

## 作者：little_Aiz (赞：3)

## 背包？

v[i]，重量为w[i]，每种宝物有m[i]件

一看到这个好像就是的样子

然后试了一下

听取WA声一片

哦哦哦，是不是要加优化？

玄学AC了

一道很经典的dp+二进制优化题

AcCode:
```cpp
#include<bits/stdc++.h>
using namespace std;
int c[100005];
int v[100005];
int dp[400005];
int n,w;//外面定义多好，不用初始化
int main(){
	cin>>n>>w;
	int count=1;//一开始赋值为1
	for(int i=1;i<=n;i++){
		int x,y,z;
		cin>>x>>y>>z;//循环输入xyz
		for(int j=1;j<=z;j<<=1){
			c[count]=j*x;
			v[count++]=j*y;
			count++;
			z=z-j;
		} 
		if(z>0){
			c[count]=z*x;
			v[count]=z*y;
			count++;
		}
	} 
	for(int i=1;i<=count;i++){
		for(int j=w;j>=v[i];j--){
			dp[j]=max(dp[j],dp[j-v[i]]+c[i]);//关键
		}
	}
	cout<<dp[w]<<endl;
	return 0;
}
```
感觉没有蓝题的难度，绿题差不多啊

---

## 作者：i_cookie (赞：2)


> $\text{蒟蒻在DP之路上求索着}$
---

~~羞羞脸打广告~~来获得[更好的阅读体验](https://www.cnblogs.com/i-cookie/p/11556158.html)

这是一道裸的多重背包,也就是给出若干种物品,每种物品的价格是$v_i$,每种物品的代价是$w_i$,每种物品有$c_i$件的背包问题.

## 思路
当我们在看到这种题的时候,首先想到可以直接把每种物品视为$c_i$件不同的物品,然后做01背包.这原则上是正确的.但是,题目显然不会这么放你$AC$.数据范围往往会让你的01背包TLE.

这样来看,当我们把需要做的事完全拆分碎,就造成了大量时间的花费.那么我们可以联想到我们曾重点讨论的**倍增**的思想.

在这道题中,我们不必把很多件物品拆分成一个一个的单件物品,而可以通过二进制的方法,使得不管你打算取其中的多少件,都可以表示的出来.也就是通过将同种物品分组,使得选择其中不同的组合能够等价于选择各种数量的单件.具体操作是这样的:

我们将$c_i$二进制分解,但是要求每一位二进制位都必须是1.这显然是无法适应所有数据的.毕竟不是所有数据都满足$c_i=2^k-1$.即便如此我们也要尽量做到这一点.因此我们要找到最大的$k$,使得$t=\sum_{i=0}^{k}2^i$满足$t\le c_i$.也就是找到最大的,小于$c_i$的二的各个次幂和.到目前为止我们可以通过不重复且有选择地使用$2^0$到$2^k$来表示出$1$到$t$所有的数.但是剩下的咋办呢?我们将剩下的$c_i-t$单独分为一组.因为$1$到$t$都可以表示,那么有了这个$c_i-t$组就可以表示出所有数了.例如我们会把21分为$1,2,4,8,6$,这样就可以从中不重复地选择来表示出$1$到$c_i$的所有数了.

这时候,问题已然变成了一个01背包问题.时空间复杂度均得到了优化.

题解代码:
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

int n, v, p[10005], w[10005], f[40005];

int main() {//f数组为常规01背包数组,
    cin >> n >> v;//w是重量数组
    int tot = 0;//p是价值数组,tot是物品数量
    for (int i = 1; i <= n; i++) {//二进制拆分
        int a, b, c;
        cin >> a >> b >> c;
        for (int j = 1; j <= c; j <<= 1) {
            p[++tot] = j * a;//循环2的0到k次方
            w[tot] = j * b;//每件物品相当于若干
            c -= j;//单件的捆绑
        }
        if (c > 0) {//此时c只剩下没分解的部分了
            p[++tot] = c * a;
            w[tot] = c * b;
        }
    }
    for (int i = 1; i <= tot; i++)//平凡的01背包
        for (int j = v; j >= w[i]; j--)
            f[j] = max(f[j], f[j - w[i]] + p[i]);
    cout << f[v] << endl;
    return 0;
}
```


---

## 作者：Celebrate (赞：2)

这一道题我就用了倍增+背包来做，因为这样常数较小，可能比单调队列要快，解释就不多说了，直接上代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<vector>
#include<queue>
#define ll long long
using namespace std;
int n,m;
int v[100001];
int w[100001];
int dp[40001];
int main(){
    int k;
    scanf("%d %d",&k,&m);
    for(int i=1;i<=k;i++){
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        int now=1;
        while(z-now>=0){
            n++;
            z-=now;
            v[n]=x*now;
            w[n]=y*now;
            now*=2;
        }
        if(z){
            n++;
            v[n]=x*z;
            w[n]=y*z;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=m;j>=w[i];j--){
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
    printf("%d",dp[m]);
    return 0;
}
```

装载至：
https://blog.csdn.net/stone41123/article/details/77934104


---

## 作者：lych (赞：2)

本题属于有限背包的数据加强版，需要用到一个优化。

首先对于每一个1~n，都可以用1,2,4,8等2的幂以及一个整数完成。因此使用二进制的算法，可以将个数拆分为log(m[i])个物品，从而加快速度

```delphi
var
  n,m,i,j:longint;
  w,p,s:int64;
  a,b,c,f:array[0..1000000] of int64;
begin
  read(n,m);
  for i:=1 to n do read(c[i],a[i],b[i]);
  for i:=1 to n do
    begin
      s:=1;
      while s shl 1-1<=b[i] do
        begin
          w:=a[i]\*s;
          p:=c[i]\*s;
          for j:=m downto w do
            if f[j-w]+p>f[j] then
              f[j]:=f[j-w]+p;
          s:=s shl 1;
        end;//拆分二进制
      s:=b[i]-s+1;//取出剩下的物品个数
      if s=0 then continue;//没有剩余，直接跳过
      w:=a[i]\*s;
      p:=c[i]\*s;
      for j:=m downto w do
        if f[j-w]+p>f[j] then
          f[j]:=f[j-w]+p;
    end;
  writeln(f[m]);
end.[codep/]

---

## 作者：S1gMa (赞：1)

#### 刚刚看题很明显 ---------01背包板子题
```
每种宝物的价值为v[i]，重量为w[i]，每种宝物有m[i]件。小FF希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大
```

心里暗想 ------又水了一道题

看到结果 $30pts$ ~~很惨~~

以为加点读入输出优化就好了   加上 $30pts$

行吧 都不行 吸氧大法好！！！~~千万不要学我 少用！！！！~~

$ 80 pts $

好吧，终  还是要好好写

#### 这道题运用 多重背包 + 二进制拆分优化 可解

题目不多解释了，其实这就是一道多重背包优化板子题（其实还可以用单调队列解）

##### 将每个物品的数量进行 二进制拆分


```
举个例子把 什么是二进制拆分呢 
**有两种方案可以选择 ：
*1. 
	也就是说限定物品选择的个数。

	vi ci ki  //对于第i个物品，体积为vi，价值ci，只能选择ki次。

	将 ki 分为 ki 个物品，然后用01背包解决。

*2. 
	采用类似lca的方法
    
	将k个物品分为 1,2,4,8,16，..... 2^n.
    
	这样对于每一个1-ki之间自然数i都可以被组合出来。然后再采用01背包。
```
## 注意！！！！ ：   二进制拆分一定要覆盖当前的点。

所以思路讲完 ； 上代码吧

```
#include <bits/stdc++.h>

using namespace std;

int n, f[100005], ans, cnt, m, w[100005], v[100005], W, V, t;

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}

inline void write(int x)
{
    char F[200];
    int tmp = x > 0 ? x : -x;
    if (x < 0)
        putchar('-');
    int cnt = 0;
    while (tmp > 0)
    {
        F[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while (cnt > 0)
        putchar(F[--cnt]);
}

int main()
{
    //  n = read(), t = read();
    cin >> n >> t;
    for (int i = 1; i <= n; i++)
    {
        //   V = read(), W = read(), m = read();
        cin >> V >> W >> m;
        for (int j = 1; j <= m; j <<= 1)
        {
            w[++cnt] = W * j;
            v[cnt] = V * j;
            m -= j;
        }
        if (m != 0)
        {
            w[++cnt] = W * m;
            v[cnt] = V * m;
        }
    }
    for (int i = 1; i <= cnt; i++)
    {
        for (int j = t; j >= w[i]; j--)
        {
            f[j] = max(f[j], f[j - w[i]] + v[i]);
        }
    }
    write(f[t]);
    return 0;
}
```

---

## 作者：jins3599 (赞：1)

多重背包模板。

由于我不会写单调队列，就写了个二进制拆分优化多重背包。

其实二进制拆分还是比较好理解的。

我们考虑每一个十进制的数，都是可以在二进制下被唯一表示的。

例如 $7_{(10)}=111_{(2)}\ ,\ 3_{(10)}=11_{(2)}$

其实结论就比较显然了，我们可以把每个物品拆成$log$个大物品，显然，该物品选择的所有可能性都可以被这$log$个物品组成。

然后拆分之后对拆分后的序列跑一遍01背包即可。

复杂度$O(\displaystyle \sum _{i=1}^nlog_2\ num[i]\ *n*V).$可以通过本题。

新的序列数组开大点，因为拆分出来的物品个数会大于maxn.

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e6 + 10;

int v[maxn] , w[maxn] , num[maxn];
int new_v[maxn] , new_w[maxn] , V , n , cnt;
int f[maxn] , ans;

int main () {
    cin >> n >> V;
    for(int i = 1 ; i <= n ; ++ i) cin >> w[i] >> v[i] >> num[i];
    for(int i = 1 ; i <= n ; ++ i) {
        for(int j = 1 ; j <= num[i] ; j <<= 1) {
            num[i] -= j;
            new_w[++ cnt] = j * w[i];
            new_v[cnt] = j * v[i];
        }
        if(num[i]) {
            new_v[++ cnt] = num[i] * v[i];
            new_w[cnt] = num[i] * w[i];
        }
    }
    for(int i = 1 ; i <= cnt ; i ++)
        for(int j = V ; j >= new_v[i] ; j --) 
            f[j] = max(f[j] , f[j - new_v[i]] + new_w[i]);
    cout << f[V];
    return 0;
}
```

---

## 作者：光太郎和健一 (赞：1)

idea来自于  崔添翼大佬的背包九讲哦 
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner cin = new Scanner(System.in);
        int N = cin.nextInt(), V = cin.nextInt();
        int[] C = new int[N];
        int[] W = new int[N];
        int[] M = new int[N];
        for (int i = 0; i < N; i++) {
            W[i] = cin.nextInt();
            C[i] = cin.nextInt();
            M[i] = cin.nextInt();
        }
        
        int ret = MultiPack(N, V, C, W, M);
        System.out.println(ret);
    }


    // 多重背包问题 多重背包问题建立在01背包和完全背包问题问题基础上
    public static int MultiPack(int N, int V, int[] C, int[] W, int[] M) {
        int[] dp = new int[V + 1];
        for (int i = 0; i < N; i++) {
            MultiplePack(C[i], W[i], M[i], dp, V);
        }
        return dp[V];
    }

    public static void MultiplePack(int ci, int wi, int mi, int[] dp, int V) {
        if (ci * mi >= V) {
            CompletePack(ci, wi, dp, V);
            return;
        }
        int s = 1;
        while (s < mi) {//条件：amount-s>0
            ZeroOnePack(s * ci, s * wi, dp, V);
            mi -= s;
            s *= 2;
        }
        ZeroOnePack(mi * ci, mi * wi, dp, V);
    }

    // 抽象化: 抽取01背包问题为处理一件物品
    public static int ZeroOnePack(int ci, int wi, int[] dp, int V) {
        for (int j = V; j >= ci; j--) {
            dp[j] = Math.max(dp[j], dp[j - ci] + wi);
        }
        return dp[V];// 返回的是容量为V时候,处理一件物品获取的最大值
    }

    // 抽象化: 对一种物品的处理过程
    public static int CompletePack(int ci, int wi, int[] dp, int V) {
        for (int j = 0; j <= V; j++) {
            if (j >= ci) dp[j] = Math.max(dp[j], dp[j - ci] + wi);
        }
        return dp[V];
    }
}
```


---

## 作者：Seanq (赞：1)

**P1776 宝物筛选_NOI导刊2010提高（02）题解**  
玄学二进制优化+01背包  
二进制优化：  
将k个同样的物品拆分成logk+1个物品  
分别为1、2、4、8...k-Σi 1->logk个物品之和  
std:  
```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
#include <cctype>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define frep(i,x,y) for(int i=x;i>=y;i--)
#define ll long long
struct bag
{
	int v;
	int w;
};
const int N=10000005;
int n;
ll t;
ll val[N],w[N];
int cnt=0;
bag a[N];
ll f[N];
ll ans=0;
int main()
{
	scanf("%d%lld",&n,&t);
	rep(i,1,n)
	{
		ll W;
		scanf("%lld%lld%lld",&val[i],&w[i],&W);
		for(ll j=1;j<=W;j<<=1)
		{
			cnt++;
			a[cnt].v=val[i]*j;
			a[cnt].w=w[i]*j;
			W-=j;
		}
		if(W)
		{
			cnt++;
			a[cnt].v=val[i]*W;
			a[cnt].w=w[i]*W;
		}
	}
	n=cnt;
	rep(i,1,n)
	{
		frep(j,t,a[i].w)
		{
			f[j]=max(f[j],f[j-a[i].w]+a[i].v);
		}
	}
	rep(i,0,t) ans=max(ans,f[i]);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：ljc20020730 (赞：1)

背包型dp，但是没有看清数据范围差点认为是水题了，（然后诡异的拿了20分）

标解是：2进制优化，比较简单把每一类物品看做若干个相互独立的物品，放在一个另外的数组里，然后全局跑一边01就可以。

主要思想是：将一种物品分成1、2、3..一份，然后跑01（01的复杂度低啊！）

如果难以理解的话不妨举个例子：如2=1+1;5=1+2+2;4=1+2+1；

就是说依次递增，当最后一次的次数太大了使前面所有的和加起来大于次数了那么我们就不继续递增拉

好理解的程序的话就是这样的但是跑的慢（最后一个点500多ms！）

```cpp
uses math;
var n,v,i,j,tc,tw,tt,cnt,pp:longint;
    w,c:array[0..1000000]of longint;
    f:array[0..1000000]of longint;
begin
 readln(n,v);
 cnt:=1;
 for i:=1 to n do begin
  readln(tc,tw,tt);//读入一种物品的价值、代价、次数
  pp:=1;//分解的第一种是1个分解
  while true do begin//死循环拉~~
   c[cnt]:=pp*tc;//加1个物品的物品
   w[cnt]:=pp*tw;
   inc(cnt);
   dec(tt,pp);//减去次数
   inc(pp);//下一种次数
   if tt-pp<0 then break;//不够了。。。
  end;
  if tt>0 then begin//如果还有剩余次数那么重新来一个把！
   c[cnt]:=tt*tc;
   w[cnt]:=tt*tw;
   inc(cnt);
  end;
 end;
 for i:=1 to cnt do//跑一组01就完事了；
  for j:=v downto w[i] do
   f[j]:=max(f[j],f[j-w[i]]+c[i]);
 writeln(f[v]);
end.//收工！
```
（虽然上面是AC程序但是时间效率太低最后一点500ms，其实上面我们是分解123，但是现在可以按照二进制来做124）

其实这道题的本质是二进制的算法，我们考虑把这个物品换成若干件物品，使得原问题中不论这种物品取多少件（0到最大件数p之间），都能等价于取若干件代换以后的物品。且超过x件的策略必定不能出现。就是说，将每个物品分成若干件01背包中的物品，其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。(假设有一种价值为v，重量为w，限购次数为x的物品)令这些系数分别为1,2,2^2,…,2^(k-1),x+1-2^k，且k是满足x+1-2^k>0的最大整数。由于加了位运算，解题的能力快速提高，时间比较快（虽然上面是可以AC但是下面更加优秀）

```cpp
uses math;
var n,v,i,j,aa,cc,bb,cnt:longint;
    w,c:array[0..1000000]of longint;
    f:array[0..1000000]of longint;
begin
 readln(n,V);//读入物品和背包体积
 cnt:=1;//分裂后待选的物品总数
 for i:=1 to n do begin
  readln(aa,bb,cc);//每一件物品的价值、体积、次数
  j:=1;
  while j<=cc do begin//分成若干个物品
   w[cnt]:=j*bb;//第cnt件物品的体积=体积*次数
   c[cnt]:=j*aa;//第cnt件物品的价值=价值*次数
   cc:=cc-j;//次数分解
   j:=j<<1;//j乘以2
   inc(cnt);
  end;
  if cc>0 then begin//如果次数还有多余那么一次性加
   w[cnt]:=cc*bb;
   c[cnt]:=cc*aa;
   inc(cnt);
  end;
 end;
 for i:=1 to cnt do
  for j:=v downto w[i] do
   f[j]:=max(f[j],f[j-w[i]]+c[i]);
 writeln(f[V]);
end.
```

---

## 作者：cxy004 (赞：1)

呐，经典多重背包

下面放《背包九讲》里的多重背包：（不要小看搬运工啊，搬运工也是很辛苦的啊）


#P03: 多重背包问题

##题目

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。


##基本算法

这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则有状态转移方程：



f[i][v]=max{f[i-1][v-k\*c[i]]+k\*w[i]|0<=k<=n[i]}

复杂度是O(V\*Σn[i])。


##转化为01背包问题

另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V\*Σn[i])。


但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。


方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种 物品分成系数分别为1,2,4,6的四件物品。


分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。


这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为<math>O(V\*Σlog n[i])的01背包问题，是很大的改进。


下面给出O(log amount)时间处理一件多重背包中物品的过程，其中amount表示物品的数量：


procedure MultiplePack(cost,weight,amount)

    if cost\*amount>=V

        CompletePack(cost,weight)

return
```cpp
    integer k=1
    while k<amount
        ZeroOnePack(k*cost,k*weight)
        amount=amount-k
        k=k*2
    ZeroOnePack(amount*cost,amount*weight)
```
希望你仔细体会这个伪代码，如果不太理解的话，不妨翻译成程序代码以后，单步执行几次，或者头脑加纸笔模拟一下，也许就会慢慢理解了。

##O(VN)的算法

多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片 上。


##小结

这里我们看到了将一个算法的复杂度由O(V\*Σn[i])改进到O(V\*Σlog n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并将完整的程序代码写出来。


---

## 作者：wangxuye (赞：1)

	看大家的题解都是二进制优化的，那我来一发单调队列的
	很明显是一道多重背包问题。二进制优化的时间复杂度为O(nΣlog m[i]),如果有卡常数的点就有可能TLE，那么就要用到单调队列优化了
	我最早接触到单调队列优化多重背包是在楼教主的男人八题里，但我觉得讲得太高深了（表示蒟蒻不懂），所以我来简单的讲一下
	多重背包的转移方程：
    dp[j]=max(dp[j-k*weight[i]]+k*value[i],dp[j])
               (1<=k<=num[i]）
    可以看出dp[j]只和dp[p](p==j(mod weight[i]),
    "=="为同余符号）有关
    所以我们只要维护与j同余于weight[i]的一个单调队列就可以了
    细节见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int sizen=100000,sizem=1000000;

int dp[sizem+10];
int weight[sizen+10],value[sizen+10],num[sizen+10];
int que[sizem+10];
int head,tail;

int calc(int i,int u,int k) //单调队列计算 
{
	return dp[u+k*weight[i]]-k*value[i];
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d%d",&value[i],&weight[i],&num[i]);
	memset(dp,0,sizeof(dp));  //-inf
	dp[0]=0;
	for(int i=1;i<=n;i++)
	{
		memset(que,0,sizeof(que));
		for(int u=0;u<weight[i];u++) //除以weight[i]的余数 
		{
			head=1,tail=0; //不要忘了初值（我不会告诉你我在这儿WA了好几次） 
			int maxp=(m-u)/weight[i];
			for(int k=maxp-1;k>=max(maxp-num[i],0);k--)
			{
				for(;head<=tail&&calc(i,u,que[tail])<=calc(i,u,k);tail--);
				//如果当前进队的点的值大于队尾的点的值，则队尾出队 
				que[++tail]=k;
			}
			for(int p=maxp;p>=0;p--)
			{
				for(;head<=tail&&que[head]>p-1;head++); //过时的出队 
				if(head<=tail)
					dp[u+p*weight[i]]=max(dp[u+p*weight[i]],calc(i,u,que[head])+p*value[i]); //状态转移 
				if(p-num[i]-1>=0)
				{
					for(;head<=tail&&calc(i,u,que[tail])<=calc(i,u,p-num[i]-1);tail--); //维护单调性 
					que[++tail]=p-num[i]-1;
				}
			}
		}
	}
	printf("%d\n",dp[m]);
	return 0;
} 
```

---

## 作者：attack (赞：1)

基本原理：

任意一个自然数都可以表示成二进制的形式


###1.
假设有一种价值为v，重量为w，限购次数为x的物品。

###2.
考虑二进制的思想，我们考虑把这个物品换成若干件物品，使得原问题中不论这种物品取多少件（0到x之间），都能等价于取若干件代换以后的物品。且超过x件的策略必定不能出现。

###3
将这个物品分成若干件01背包中的物品，其中每件物品有一个系数。这件物品的费用和价值均是原来的费用和价值乘以这个系数。令这些系数分别为1,2,2^2,…,2^(k-1),x+1-2^k，且k是满足x+1-2^k>0的最大整数。

###4
举个栗子：如果x=13，那么对应的k=3，系数分别为1,2,4,6。


###5.
状态：O(nm)；转移：O(logm)



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define lli long long int 
using namespace std;
const int MAXN=100001;
const int maxn=0x3f;
void read(int &n)
{
    char c='+';int x=0;bool flag=0;
    while(c<'0'||c>'9'){c=getchar();if(c=='-')flag=1;}
    while(c>='0'&&c<='9')
    x=(x<<1)+(x<<3)+c-48,c=getchar();
    flag==1?n=-x:n=x;
}
int n,m;
struct node
{
    int va,we,num;
}a[MAXN];
int dp[MAXN];
int  main()
{
    read(n);read(m);
    for(int i=1;i<=n;i++)
    {
        read(a[i].va);
        read(a[i].we);
        read(a[i].num);
    }
    for(int i=1;i<=n;i++)// 枚举每一个物品 
    {
        int left=(a[i].num);
        for(int k=1;left;k<<=1)// 将每一个物品以二进制表示 
        {
            if(k>left)
                k=left;// 处理最后不能表示成二进制的情况 
            left-=k;// 每次都减去 
            int w=a[i].we*k;
            int v=a[i].va*k;// 常数优化 
            for(int j=m;j>=w;j--)
                dp[j]=max(dp[j],dp[j-w]+v);//最基本的多重背包DP 
        }
    }
    printf("%d",dp[m]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

#include<bits/stdc++.h>//在多重背包的标准做法上加一个位运算优化即可

```cpp
using namespace std;
int dp[1000001],sb[1000001],wc[1000001];
int main()
{
    int a,b,c,n,w,i,j;
    int con=0;
    scanf("%d%d",&n,&w);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        for(j=1;j<=c;j<<=1)//位运算优化
        {
            sb[con]=j*b;
            wc[con++]=j*a;
            c-=j;
        }
        if(c>0)
        {
            sb[con]=c*b;
            wc[con++]=c*a;
        }
    }
    for(i=0;i<con;i++)
      for(j=w;j>=sb[i];j--)
          dp[j]=max(dp[j],dp[j-sb[i]]+wc[i]);
    cout<<dp[w]<<endl;
    return 0;
}
```

---

## 作者：蔡俊黠 (赞：0)

将每个物品的数量进行二进制拆分，例如13可以拆成1+2+4+6，将1,2,4,6当成一个个物品，拿4来说，这个物品的价值=单个物品的价值* 4，这个物品的重量=单个物品的重量* 4，这样的话我们就可以用01背包来做，来判断当前这个物品选还是不选

### AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w,cnt,f[400000];
struct node{
	int v;
	int w;
}a[1000000];
int main()
{
    scanf("%d%d",&n,&w);
    for (int i=1;i<=n;i++)
    {
    	int v,w,num;
    	scanf("%d%d%d",&v,&w,&num);
    	int j;
    	for (j=1;j<=num;j<<=1)
    	{
    		a[++cnt].v=j*v;
    		a[cnt].w=j*w;
    		num-=j;
		}
		if (num!=0) a[++cnt].v=num*v,a[cnt].w=num*w;
	}
	for (int i=1;i<=cnt;i++)
	  for (int j=w;j>=a[i].w;j--)
	     f[j]=max(f[j],f[j-a[i].w]+a[i].v);
	printf("%d\n",f[w]);
	return 0;
} 
```


---

## 作者：Azuree (赞：0)

题意简述  
给你$n$个物品，第$i$个物品的体积为$w_i$,价值为$v_i$,可以选$m_i$次。现在你可以选的物品总体积不超过$W$，求你能获得的最大的价值  

感觉把多重背包的问题模型重温了一遍有没有……
由于数据范围很大，所以我们直接将选$m$次拆成有$m$个物品可选这个暴力的方案是会超时的，所以我们要用二进制分解去优化多重背包。  
我们用$W_{i,j}$表示为由$2^j$个物品$i$捆绑而成的大物品。若$m$不是$2$的整数次幂，那么我们应将物品$i$进行二进制分解以后剩下的选取次数捆绑成一个大物品并单独储存。二进制分解完成后，我们再跑朴素的0/1背包求解即可。  
code：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register
#define qwq printf("qwq\n");

using namespace std;

int read()
{
	register int x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,f[100005],ans,cnt,m,w[100005],v[100005],W,V,t;

int main()
{
	n = read(); t = read();
	for(int i = 1; i <= n; i++)
	{
		V = read();
		W = read();
		m = read();
		for(int j = 1; j <= m; j <<= 1)
		{
			w[++cnt] = W * j;
			v[cnt] = V * j;
			m -= j;
		}
		if(m) w[++cnt] = W * m,v[cnt] = V * m;
	}

	for(int i = 1; i <= cnt; i++)
		for(int j = t; j >= w[i]; j--)
			f[j] = max(f[j],f[j - w[i]] + v[i]);
	cout << f[t];
    return 0;
}
```

---


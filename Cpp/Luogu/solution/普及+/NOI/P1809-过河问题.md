# 过河问题

## 题目描述

有一个大晴天，Oliver 与同学们一共 $N$ 人出游，他们走到一条河的东岸边，想要过河到西岸。而东岸边有一条小船。 

船太小了，一次只能乘坐两人。每个人都有一个渡河时间 $T$，船划到对岸的时间等于船上渡河时间较长的人所用时间。 

现在已知 $N$ 个人的渡河时间 $T$，Oliver 想要你告诉他，他们最少要花费多少时间，才能使所有人都过河。 

注意，只有船在东岸（西岸）的人才能坐上船划到对岸。

## 说明/提示

### 数据范围

对于 $40\%$ 的数据满足 $N\le8$。 

对于 $100\%$ 的数据满足 $N\le10^5,T\leq 10^7$。


### 样例解释

- 初始：东岸 $\{1,2,3,4\}$，西岸 $\{\}$；
- 第一次：东岸 $\{3,4\}$，西岸 $\{1,2\}$，时间 $7$；
- 第二次：东岸 $\{1,3,4\}$，西岸 $\{2\}$，时间 $6$；
- 第三次：东岸 $\{1\}$，西岸 $\{2,3,4\}$，时间 $15$；
- 第四次：东岸 $\{1,2\}$，西岸 $\{3,4\}$ 时间 $7$；
- 第五次：东岸 $\{\}$，西岸 $\{1,2,3,4\}$ 时间 $7$。

所以总时间为 $7+6+15+7+7=42$，没有比这个更优的方案。

## 样例 #1

### 输入

```
4
6
7
10
15
```

### 输出

```
42
```

# 题解

## 作者：L__A (赞：60)

### 培训时正巧讲到这题，以前一直不会，老师讲了一遍后也就豁然开朗了
#### 这题是一道纯粹的贪心，所以推出规律就是最重要的一点
不妨先对所有人按所需时间ai从小到大排序

对于河此岸人数n==2的情况，很显然，耗费时间为二者中最长的一个，两人即可全部到达对岸；对于n==3的情况，先让最快的人带一人去对岸，最快的人回来，再接另一人去对岸，总共花费时间为a1+a2+a3

那么对于n>3的情况怎么来呢？我们可以先运送此岸上用时最长的两人，那么最优秀的运送方法有两种

1.最快的1载最慢的n去对岸，1回此岸继续载次慢的n-1去对岸，a1最后再回到此岸，共用时2*a1+an+a(n-1)

2.最快的人1与次快的人2去对岸，最快的人1回到此岸，最慢的人n再与次慢的人n-1去对岸，次快的人2回到此岸，共用时a1+2*a2+an

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

int i,n,a[100010];
long long ans;

void re(int &x)//快读
{
    x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
}

bool cmp(const int x,const int y)
{
    return x<y;
}

int main()
{
    re(n);
    for(i=1;i<=n;i++)
        re(a[i]);
    sort(a+1,a+n+1,cmp);//按用时由小到大排序
    while(n>3)
    {
        ans+=min(a[1]*2+a[n]+a[n-1],a[1]+a[2]*2+a[n]);//根据公式累加
        n-=2;//每次此岸人数减少2人
    }
    if(n==2) ans+=a[2];//此岸人数n为2或3时
    if(n==3) ans+=a[1]+a[2]+a[3];
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：cs18 (赞：32)

我用dp做的，要寻找dp方程；
先按照时间从小到大排序，依次过河；
如果剩一个人，让最小的回来接他；
如果剩两个人，让最小的回来接，剩下的那两个人（即最大的两个人）过去，让次小的回来，最小的两个过去；
从这两个情况中选一个最短的情况，列出dp方程。
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int t[100005],dp[100005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)	
	cin>>t[i];
	sort(t+1,t+n+1);//排序 
	dp[1]=t[1],dp[2]=t[2];	
	for(int i=3;i<=n;i++)
	dp[i]=min(dp[i-1]+t[1]+t[i],dp[i-2]+t[1]+2*t[2]+t[i]);//dp方程，两种情况，认真想想； 
	cout<<dp[n];
}
```

---

## 作者：听取MLE声一片 (赞：11)

方法：贪心

第一步：快速排序（不赘述）

第二步：我们来解决一下人数小于4的情况

1.剩下3个人

最快的人带着第二快的人过去，然后最快的回来，最后带着最慢的过去（三个人的时间和）

2.剩下两个人

两个人一起过去（两个人的时间和）

第三步：我们处理一下三个人以上的情况

我们的计划是每一轮送过去两个人

两种情况：

①最快的人送两个最慢的人过去（2*最快+倒数第一+倒数第二）

②最快的人把第二快的和最慢的送过去（最快+2*第二+倒数第一）

只需要将这两个值取最小值就行了

注意：开long long保险

代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int i,n,a[100010];
long long ans;
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1);
    while(n>3)
    {
        ans+=min(a[1]*2+a[n]+a[n-1],a[1]+a[2]*2+a[n]);
        n-=2;
    }
    if(n==2)
		ans+=a[2];
    if(n==3)
		ans+=a[1]+a[2]+a[3];
    printf("%lld",ans);
    return 0;
}
```
谢谢大家！



---

## 作者：LSG_waterf (赞：5)

本体很明显的贪心，主要讨论两种情况：
1、让速度最快的往返接送，每次送两个人所用时间为两倍最快的人所用的时间加上两个最慢的人的所用的时间之和。即a[n]+a[1]+a[n-1]+a[1];

2、先让两个最快的人过河，再让第二快(谁将船送回都不影响)的人送回船，让两个岁慢的人过河，再将留在河对面的速度最快的人把船送回。所用时间为a[2]+a[2]+a[n]+a[1];

3、要求最小时间， 将两个去min值即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000100],ans=0;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    while(n>3)
    {
        if(a[2]*2+a[1]+a[n]>=a[1]*2+a[n-1]+a[n])
                //第(1)种情况是两个速度最快的过河，再由第一个人将船送回，再两个速度最慢的过河，由最快的将船送回，时间为a[2]+a[2]+a[n]+a[1]；第(2)种情况是最快的反复跑所用时间为a[1]*2+a[n-1]+a[n]；
        ans+=a[1]*2+a[n-1]+a[n];
        else ans+=a[2]*2+a[1]+a[n];
        n-=2;//每次加两个人的过河时间
    }
    if(n==3) ans+=a[1]+a[2]+a[3];//找关系可得最后三个人的时间为三者时间想加，可以自己推算。
    if(n==2) ans+=a[2];//最后两个人的时间即为速度慢的人所用的时间。
    if(n==1) ans+=a[1];// 最后一人过河时间就是他的过河时间。
    cout<<ans;
    return 0;
}
```


---

## 作者：说好不哭 (赞：5)

# 一个简洁的题解# 
**** 这是一道考思维的题****

拿到这道题，首先应该要用用DP或贪心的思维，毕竟它是求最值问题。

第一部要排序，想到这点的应该有不少，因为对于一道不知道方法的最值题来说，~~没思路就排个序吧~~.......假的，别次次都信！！！

拍完序后，可以自己枚举样例，样例还是比较良心的，给4个不大的数据，既不麻烦，也不是特殊情况干扰思想。

做出样例之后，下一步的思路就是两个类似DP，或者就是DP的简略方程。

dp[x]=dp[x-2]+a[x]+a[x-1]+2*a[1],a[1]+2*a[2]+a[x]

这个方程的总体思路就是先把最慢的人送到对岸，这应该不难想到，因为贪心动归题只能要么从最大要么从最小出发做。对于这题来说，由于最小的人需要不断地来回划船，所以从最大的开始做。   这一点想不到，我也没办法......

然后就是推方程，对于动态方程这个玄学的问题，只可意会不能言传，就靠你自己了。

下面放代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001],ans;
int jay(int x){
	if (x==1) return a[1];
	if (x==2) return max(a[1],a[2]);
	if (x==3) return a[1]+a[2]+a[3];
	return jay(x-2)+min(a[x]+a[x-1]+2*a[1],a[1]+2*a[2]+a[x]);
}      //个人觉得递归调用比较有意思
int main(){
	int n;
	cin>>n;
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	ans=jay(n);    //jay数组就是递归，猜猜为什么写jay？？？
	cout<<ans;
return 0;	
}

```
**
思维题我是觉得挺有趣的，无需任何算法，只需自己推导** 

---

## 作者：Harmony (赞：4)

纪念AC第101道题暨橙名发表这一篇题解。

不说废话了，不知道为什么，这道题明明是很经典的贪心，但是却只有那么少的人做。。。(另外，这道题中的主人公的名字和我的德语名一样。。。)

其实这道题有两种思路来贪心，我的培训老师曾经讲了一种方式，而当时我又想到了另一种思路，也实现了一下。。。

读完题之后，就会发现这道题的最优方案无非两种：
1.  最快的人一个一个送：a[0]带着a[i]去去来来，每一趟要花(a[i] + a[0])的时间
2.  两个最大的一起过去：先让a[1]带着a[0]过去，再让a[1]回来，再让a[i]和a[i - 1]过去，最后让a[0]回来，每一次要花(a[1] + a[1] + a[i] + a[0])的时间


方式一：枚举分界线。。。

我们会发现，上述的两种情况其实是被一个分界线分开的，也就是说存在这么一条线，它的左边(比他小的部分) 使用第一种方法过河，它的右边(比他大的一边)使用第二种方法过河，所以直接枚举这根线就可以了。。。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n, i, j, ans, ANS = 0x3f3f3f3f, a[100005];
	cin>>n;
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	for (i = 2; i <= n; i++)//枚举每一条分界线。。。
		if ((n - i) % 2 == 0)
		{
			ans = 0;
			for (j = i + 1; j <= n; j += 2)//求和，可以用前缀和优化。。。
				ans += a[2] + a[1] + a[j + 1] + a[2];
			for (j = 2; j <= i; j++)//同上。。。
				ans += a[j] + a[1];
			ANS = min(ANS, ans - a[1]);//求最小。。。
		}	 
	cout<<ANS;
	return 0;
}
```
但是这个代码有一个很大的问题：太慢了，不难发现，这个代码的时间复杂度是O(n ^ 2),因此在洛谷上交上去只有70分，其他的都TLE了。。。所以还是要下一个代码：
P.S.其实这里可以用前缀和优化哦，有兴趣可以自己试一试。。。我为了验证自己的想法，没有进行优化，做了下一种方法的代码发上来。。。(优化之后时间复杂度为O(n))

方法二：两个一组进行考虑。。。
其实在一开始，我们就可以直接从后向前扫一遍，看每两个是按照第一种方案还是第二种方案。。。应该比第一个简单。。。

代码如下：
```cpp
#include <bits/stdc++.h>
#define Max 100005
using namespace std;
int n, ans = 0, a[Max];
int main()
{
	cin>>n;
	for(int i = 0; i< n; i++)
		scanf("%d", &a[i]);
	for(int i = n; i > 3; i -= 2)//从后向前扫一遍。。。
        ans += min((a[0] + a[i - 1] +a[0] +  a[i - 2]), a[1] + a[0] + a[i - 1] + a[1]);//取最小。。。
	if(n % 2 == 1)//看看最后剩的是需要那一种情况。。。
		ans += a[1] + a[0] + a[2];
	else
		ans += a[1];
	cout<<ans<<endl;
	return 0;
}
```
这里的复杂度就只有O(n)了。。。

---

## 作者：ljc20020730 (赞：4)

blog：http://www.cnblogs.com/ljc20020730

原文：http://www.cnblogs.com/ljc20020730/p/6917861.html

本题非常的奇怪，一拿到题目首先想到的贪心方法就是以1号做中转，每次由1号送一个人到对岸，再从对岸送回氧气瓶。

典型的例子是这组数据： 1 2 9 9

最优的方法是1与2号过去，1号回来，3与4号过去，2号回来，1与2号过去。这个方案花费是16。如果按照原先的方案，花费是22。

但是，绝对的存在反例！

典型的例子是这组数据：1 9 9 9

原先的方案最佳（29），新方案反而差（37）。

经过仔细观察，我们发现一个事实，对岸的人只有两个过河时间最小的人有意义。

这里的意义实质上是由两个过河时间最小的人来决定最优解。

假定现在我们现在需要挨个过河，有2+2=4个人；

下标 分别是1 2 i-1 i

有两种方法：

①1号自己把两个人带过去。

1 i(1和i共用氧气筒) 1（1送还氧气筒） 1 i-1（1把i-1送到对岸） 1（再回来准备下一个）

用时为下标为 i 1 i-1 1的时间之和

②1号回来，两个人一起去对岸，2号回来以后再跟1号一起回去。

1 2(1 2一起去对岸) 1（1回来送氧气筒） i i-1（i和i-1自生自灭一起渡河） 2(2回来和1汇合准备下一次)

用时为下标为 2 1 i 2的时间之和

所以记t1=a[1]+a[2]+a[i-1]+a[i];t2=a[2]+a[1]+a[i]+a[2];

sum=sum+min(t1,t2);

接下来分奇偶讨论！

当渡河人数为偶数时，偶数-2=偶数

不妨设n恰好为4时，只需要渡河一次，

按照上诉2种方法，①可行，②扯淡，此时②必然会回到本岸，所以还要回去，sum=sum+a[2]

当渡河人数为奇数时，奇数-2=奇数

当n恰好为3时，就是1 2 3的渡河方法，最快的 1 3（1 3去） 1（回来送氧气筒） 1 2（1 2去）

时间是 3 1 2= a[1]+a[2]+a[3] sum=sum+a[1]+a[2]+a[3];

所以程序就非常简单：

```cpp
var t1,t2,n,sum,i:longint;
    a:array[1..1000000]of longint;
procedure qsort(l,r:longint);
var t,i,j,mid:longint;
begin
i:=l; j:=r;
mid:=a[(l+r)div 2];
while i<j do
begin
 while a[i]<mid do inc(i);
 while a[j]>mid do dec(j);
 if i<=j then begin
   t:=a[i]; a[i]:=a[j]; a[j]:=t;
   inc(i);dec(j);
 end;
end;
if l<j then qsort(l,j);
if r>i then qsort(i,r);
end;
begin
 readln(n);
 for i:=1 to n do read(a[i]);
 qsort(1,n);
 if n mod 2=1 then sum:=a[1]+a[2]+a[3]
 else sum:=a[2];
 i:=n;
 while i>3 do begin
 t1:=a[2]+a[1]+a[i]+a[2];
 t2:=a[i]+a[1]+a[i-1]+a[1];
  if t1>t2 then t1:=t2;
  sum:=sum+t1;
  i:=i-2;
 end;
 writeln(sum);
end.

```

---

## 作者：RainbowSain (赞：2)



        
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
const int INF=0x7fffffff;
using namespace std;
int read()
{
int f=1,p=0;char c=getchar();
while(c>'9'||c<'0')
{if(c=='-')f=-1;c=getchar();}
while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
return f*p;
}
int t[100010];
int main()
{
    int N;
    N=read();
    for(int i=0;i<N;i++)
        t[i]=read();
    sort(t,t+N);
    int sum=0;
    while(N>=4)
    {
        sum+=min((2*t[0]+t[N-1]+t[N-2]),2*t[1]+t[0]+t[N-1]);
        N-=2;
    }
    if(N==3)
        sum+=t[0]+t[1]+t[2];
    else if(N==2)
        sum+=t[1];
    else
    sum+=t[0];
    printf("%d",sum);
    return 0;
}######
```
当n==1或2时，所有人直接过河
当n==3时，用时最长的和用时最短的先过去，然后最短的人回来再和剩下的过去

当n>=4时，对time数组进行排序

t[0]代表用时最短的人，t[1]代表第二短的，t[n-1]代表最长的,t[n-2]代表第二长的

那么最优的过河方式就有两种

要么2\*t[0]+t[n-1]+t[n-2] 最短的带两个长的

要么2\*t[1]+t[0]+t[n-1] 最长的带两个短的

然后比较取min，且相当于每次通过两个人 n-=2，直到少于4人


---

## 作者：小明呵呵 (赞：2)

既然没人发题解，我来发一个吧，第一次写，可能不全面，请见谅



```cpp
//一道贪心题 
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MaxN=100002;
int t[MaxN];
int main()
{
    int N,ans=0;
    scanf("%d",&N);
    for(int i=1;i<=N;i++)
        scanf("%d",&t[i]);
    sort(t+1,t+N+1);
    while(N>3)
    {
        //N>3时最优情况有两种可能 
        if(t[2]*2<t[1]+t[N-1])
            ans+=(t[2]*2+t[N]+t[1]);//总是最快的带最慢的
        else
            ans+=(t[1]*2+t[N-1]+t[N]);//最快的两个先过,然后分别带最慢的两个
        N-=2;
    }
    if(N==3)
        ans=ans+t[1]+t[2]+t[3];//最后剩3人时最优情况 
    if(N==2)
        ans=ans+t[2];//最后剩2人 
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Talanton_Cerydra (赞：2)

## 别被这题的难度吓到，其实只要十几行代码

这是变了形式的小学奥数题，依然是求最优

这样我们可以开两个数组，一个存输入数据，一个表示第i个人到达对岸所花的最少时间

重点：样例排好序不代表测试点也这样！[谁说的](https://www.luogu.com.cn/discuss/show/26912)

#### 让我们实践一下：

```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int a[100005],t[100005];//t存输入数据，a表示每个人过河的最短时间
int n;//表示n（是不是废话）
int main()//主函数，很短
{
    scanf("%d",&n);//读入
    for(int i=1;i<=n;i++)//循环
    {
        scanf("%d",&a[i]);//循环读入
    }
    sort(a+1,a+n+1);//记得排序！样例排好序不代表测试点也这样！
    t[1]=a[1];
    t[2]=a[2];//前两快的人最短时间就是他们所需的时间
    t[3]=a[1]+a[2]+a[3];//1和2过去，1回来，1再和3过去
    for(int i=4; i<=n; i++)//从第四个人开始
    {
        t[i]=min(t[i-1]+a[i]+a[1],t[i-2]+a[i]+2*a[2]+a[1]);//数学公式，你们猜是什么原理
    }
    printf("%d\n",t[n]);//最后一个人的最短时间就是总的最短时间
    return 0;//结束
}
```


---

## 作者：Snow_Dreams (赞：0)

贪心策略：最快的来回送 或者 最慢2个走(最快和次快的过去）

举例发现2种情况都可能，怎么证明这个策略对

发现其他的策略都比这2个策略中某个差。

n个人，1 最快的送 2 ..

其他的策略比1 2中某个差。


这种问题，不断的把n问题减少，n问题变成n-1问题 n-2问题

数学归纳法,t1 t2 ...tn，排序了
- 1个 t1
- 2个 t2
- 3个t1+t2+t3
- 大于3贪心策略


最后贴代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,a[N],f[N];
int main()
{
    scanf("%d", &n);
    for(int i = 1;i <= n;i++) scanf("%d", &a[i]);
    sort(a+1,a+n+1);
    f[1] = a[1];
	f[2] = a[2];
	f[3] = a[1]+a[2]+a[3];
    for(int i = 4;i <= n;i++){
        f[i] = min(f[i-2]+a[1]+2*a[2]+a[i],f[i-1]+a[i]+a[1]);
    }
    printf("%d\n",f[n]);
    return 0;
}
```


---

## 作者：王力信 (赞：0)

其实P和C程序#核心#就是这段

```pascal
  if a[1]*2+a[n-1]+a[n]<a[1]+a[2]*2+a[n] then inc(ans,a[1]*2+a[n-1]+a[n])
                                                             else inc(ans,a[1]+a[2]*2+a[n]);
```
下面为全文

```pascal
var
  a:array [0..100000] of longint;
  n,i,ans:longint;
procedure qsort(l,r:longint);
  var
    i,j,mid,x:longint;
  begin
    i:=l;
    j:=r;
    mid:=a[(i+j) div 2];
    repeat
      while a[i]<mid do inc(i);
      while a[j]>mid do dec(j);
      if i<=j then
        begin
          x:=a[i];
          a[i]:=a[j];
          a[j]:=x;
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<r then qsort(i,r);
    if l<j then qsort(l,j);
  end;
begin
  readln(n);
  for i:=1 to n do readln(a[i]);
  qsort(1,n);
  ans:=0;
  while n>3 do
    begin
      if a[1]*2+a[n-1]+a[n]<a[1]+a[2]*2+a[n] then inc(ans,a[1]*2+a[n-1]+a[n])
                                                             else inc(ans,a[1]+a[2]*2+a[n]);
      dec(n,2);
    end;
  if n=2 then inc(ans,a[2])
         else if n=3 then inc(ans,a[1]+a[2]+a[3]);
  write(ans);
end.
```

---


# 数页码

## 题目描述

一本书的页码是从 $1\sim n$ 编号的连续整数：$1,2,3,\cdots,n$。请你求出全部页码中所有单个数字的和，例如第 $123$ 页，它的和就是 $ 1+2+3=6$。


## 说明/提示

$1\le n\le 10^9$

## 样例 #1

### 输入

```
3456789```

### 输出

```
96342015 ```

# 题解

## 作者：⚡LZSY01_XZY⚡ (赞：59)


### $\text{环顾整个题解区,都没有我写的简单}$ $QwQ$
[进我的博客浏览](https://www.luogu.org/blog/LZSY01-xzy-blog/solution-p1836)

我的想法是这样的：

$\text{分别考虑个位，十位，百位，千位，万位...}$

可以发现$sum($第$i$位$)$ $=10^i*(\sum_{i=1}^{9}*(n/10^i)+$ $\sum_{i=1}^{n\mod10^i/10^{i-1}-1})+(n\mod10^i/10^{i-1})*(n\mod10^i)+1$
### 故代码如下：
```cpp
#include <cstdio>
using namespace std;
long long n;
int sum[10]={0,1,3,6,10,15,21,28,36,45};

int get(int n)
{
	if(n<0)return 0;
	return n;
}

long long get_ans(long long n)
{
	long long res=0,a=1,b=0;	
	while(n>0)
	{
		res=res+a*(45*(n/10)+sum[get(n%10-1)])+(n%10)*(b+1);
		b=b+(n%10)*a;a*=10;
		n/=10;
	}
	return res;	
}

int main()
{
	scanf("%lld",&n);
	printf("%lld\n",get_ans(n));
	return 0;
}
```
我的代码里对$\sum_{i=1}^{k}$打了表

~~觉得不错的话点个赞欧~~

---

## 作者：什么叫中二呀 (赞：30)

## ~~楼下打表大法好……~~

我采用非打表做法。

时间复杂度：O(n的位数)

空间复杂度:O(1)

可以说~~快的一批~~。

[AC记录](https://www.luogu.org/record/show?rid=15115449)
## **进入正题**
假如n=999999,我们可以这么做:

1.像高斯一样将首项，尾项相加。(假设第一项是0)

2.因为不进位，所以和原来的和相等。

所以和为54(6个9)*500000(项数)。

那么，对于任意数，我们可以将其分成$a*10^n$+……+x*10+y的形式。

我们将每个式子分别计算:

得$a*10^n$的和是$n*9*a*10^n/2+a*(a-1)*10^n$

记住，还有剩下的一些东西，我们还要加上(剩下的$*(a+1)$)

接下来是代码
---
***
```cpp
#include<cstdio>
long long int a,b,t,x=1;
int main()
{
	scanf("%lld",&a);
	for(int i=a;i>0;i/=10)x*=10,t++;//计算位数和10^n
	while(a)
	{ b+=t*9*(a/x)*x/2+(a/x)*(a/x-1)/2*x+a/x*(a%x+1);
    	//加到一起
	  a%=x;t--;x/=10;}//修改
	printf("%lld",b);
	return 0;
}
```
***

---

## 作者：_zy_ (赞：25)

## [题目传送门](https://www.luogu.com.cn/problem/P1836)

从题目中不难看出：

其实就是求$1-n$的$[1,2,3,4,5,6,7,8,9]$的个数，最后再乘本身相加就好。

~~其实我是先做的2602（紫）~~

如何求digit呢？ 先来看一下一些小小的性质：

- 从某种意义上来说：

1~9其实是个一样的，比方n=99时

先只看前99的$1$：

``` cpp
1
11 12 13 14 15 16 17 18 19
21
31
41
51
61
71
81
91
```
$1-9$有一个，

$10-99$个位数上由有$9$个，十位数上有$9$个。

很显然我们就可以预处理出来1到$10,100,1000...$中$1,2,3..$的个数$f[]$.

和$0$的个数$zero[]$.

```cpp
zero[0]=1;	
for(int i=1;i<=N;i++) {
	f[i]=f[i-1]*10+zero[i-1];
	zero[i]=zero[i-1]*10;
}
```
-  于是
我们只需要处理每一位上的数字，然后在乘以相应的f和zero就可，最后再加上一些零碎的数字。

$ans=9f[1]+zero[1]+$零零碎碎的东西


1. $f$都要乘一手

2. $0$不要乘$zero$，而且枚举到$num i$


于是就有了核心代码:
```cpp
   int num[N]={0};
    int w=0;
    while(x){num[++w]=x%10;x/=10;}
    for(int i=w;i>=1;i--)
    {
        for(int j=0;j<=9;j++)
        	cnt[j]+=f[i-1]*num[i],cnt[j]%=MOD;
        for(int j=0;j<num[i];j++)
        	cnt[j]+=zero[i-1],cnt[j]%=MOD;
        int tmp=0;
      	for(int j=i-1;j>=1;j--)
            tmp=tmp*10+num[j];
        cnt[num[i]]+=tmp+1; cnt[num[i]]%=MOD;
        cnt[0]-=zero[i-1];
    } 
```
附上$AC$代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define MOD 1000000007
#define N 25
#define int unsigned long long 
using namespace std;
int a,b,w,A,B,t;
int f[N],zero[N];
int cnta[N],cntb[N];
void Solve(int x,int *cnt)
{
    int num[N]={0};
    int w=0;
    while(x){num[++w]=x%10;x/=10;}
    for(int i=w;i>=1;i--)
    {
        for(int j=0;j<=9;j++)
        	cnt[j]+=f[i-1]*num[i],cnt[j]%=MOD;
        for(int j=0;j<num[i];j++)
        	cnt[j]+=zero[i-1],cnt[j]%=MOD;
        int tmp=0;
      	for(int j=i-1;j>=1;j--)
            tmp=tmp*10+num[j];
        cnt[num[i]]+=tmp+1; cnt[num[i]]%=MOD;
        cnt[0]-=zero[i-1];
    } 
}
signed main()
{
	zero[0]=1;
	for(int i=1;i<=N;i++) {
		f[i]=f[i-1]*10+zero[i-1];
		zero[i]=zero[i-1]*10;
	}
	cin>>a;
	Solve(a,cnta);
	int ans=0;
	for(int i=0;i<=9;i++)
		ans+=(cnta[i])*i;
	printf("%lld\n",ans);
}
```


--------
写在最后：如有不理解或错误，欢迎指出。

### 多倍经验

[2602](https://www.luogu.com.cn/problem/P2602)

[1239](https://www.luogu.com.cn/problem/P1239)

[4999](https://www.luogu.com.cn/problem/P4999)

---

## 作者：Flokirie (赞：21)

**~~打表大法好~~**

Q1: 直接暴力能不能过？ A1: 不能，时间复杂度大到$O(10^9)$。

Q2: 多大规模的暴力能过？ A2: 1e7。洛谷在线IDE实测400ms（不开O2）。

Q3: 需要打多大的表？  A3: $\frac {10^9} {10^7}=100$。

明白了以上三点，就可以愉快地打表了。

----

我们先写一个最朴素的暴力：

```cpp
#include <bits/stdc++.h>

using namespace std;

long long sum(int i){//计算一个数字各数位上数字的和
	long long ret=0;
	while(i){
		ret+=i%10;
		i/=10;
	}
	return ret;
}

long long f(int l,int r){//计算[l,r]区间内所有数字sum值的和
	long long ret=0;
	for (int i=l;i<=r;i++){
		ret+=sum(i);
	}
	return ret;
}

int main(){
	for (int i=1;i<1000000000;i+=10000000){
    	printf("%d,",f(i,i+9999999));//每隔一千万打一个表
    }
    return 0;
}
```
运行结果如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/18331.png)

然后我们把它复制到程序里面，开始写正解：

----

分块打表其实很简单，就是先算整块再算零散。

```cpp
#include <bits/stdc++.h>

using namespace std;

long long sum(int i){
	long long ret=0;
	while(i){
		ret+=i%10;
		i/=10;
	}
	return ret;
}

long long f(int l,int r){
	long long ret=0;
	for (int i=l;i<=r;i++){
		ret+=sum(i);
	}
	return ret;
}

long long res[110]={0,315000001,325000001,335000001,345000001,355000001,365000001,375000001,385000001,
395000001,404999992,325000001,335000001,345000001,355000001,365000001,375000001,
385000001,395000001,405000001,414999992,335000001,345000001,355000001,365000001,
375000001,385000001,395000001,405000001,415000001,424999992,345000001,355000001,
365000001,375000001,385000001,395000001,405000001,415000001,425000001,434999992,
355000001,365000001,375000001,385000001,395000001,405000001,415000001,425000001,
435000001,444999992,365000001,375000001,385000001,395000001,405000001,415000001,
425000001,435000001,445000001,454999992,375000001,385000001,395000001,405000001,
415000001,425000001,435000001,445000001,455000001,464999992,385000001,395000001,
405000001,415000001,425000001,435000001,445000001,455000001,465000001,474999992,
395000001,405000001,415000001,425000001,435000001,445000001,455000001,465000001,
475000001,484999992,405000001,415000001,425000001,435000001,445000001,455000001,
465000001,475000001,485000001,494999983};//一个100大小的表

int main(){
	int n;
	cin>>n;
	long long s=0;//存放和
	int i;
	for (i=1;i*10000000<=n;i++){//按一千万算整块
		s+=res[i];
	}
	s+=f((i-1)*10000000+1,n);//然后暴力算一千万以下的小块
	printf("%lld",s);
	return 0;
}
```

不要忘开long long，10个点总共640ms愉快AC~

---

## 作者：Tenshi (赞：11)

题解区的聚聚们的方法都很简单QAQ，那么我来发一份自以为比较好懂的解答吧~

## 分析
我们以 $n=7264$ 为例。

因为我们的任务是求 $1-n$ 的数码之和，考虑对问题进行拆解：

+ 求出 $1-6999$ 的数码之和
+ 求出 $7000-7264$ 的数码之和

为什么这样拆？看下去就知道了。

对于**第一部分**：我们可以进行DP

约定 $f(i,j)$ 为 $i$ 位数，其中最高位是 $j$ 的， $1-\overline{j99...99}$（共 $i$ 位）数码之和。

比如例子中的 $1-6999$ 就对应着 $f(4,6)$ 。

那么我们有：
$f(i,j)=f(i,j-1)+(f(i,0)+10^{i-1}\times j)$，其中 $j>0$

比如 $1-6999$ 数码和可以拆分成 $1-5999$ 和 $6000-6999$ ，而 $6000-6999$ 的数码和等于 $1-999$ 的数码和**与** $1000$ 个 $6$ 的和。

$j=0$ 时，有 $f(i,j)=f(i-1,9)$ 

至此，我们解决了第一部分，主要的问题已经解决。

而 $7000-7264$ 的部分我们把最高位 $7$ 的贡献算上，然后问题就转化成了求 $1-264$ 的数码之和。

这意味着我们的问题从 $n=7624$ 变成了$n=264$ 相当于少了一位，那么类似地继续下去，就可以求出答案了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=15;
ll f[N][10];

ll fpow(ll x,ll p){
	ll res=1;
	for(;p;p>>=1,x=x*x) if(p&1) res=res*x;
	return res;
}
void init(){
	for(int i=1;i<=N-1;i++)
		for(int j=0;j<=9;j++){
			if(j==0){
				f[i][j]=f[i-1][9];
			}else{
				f[i][j]=f[i][j-1]+(f[i][0]+fpow(10,i-1)*j);
			}
		}	
}

ll dp(int n){
	ll res=0;
	vector<int> v;
	int num=n;
	while(num) v.push_back(num%10),num/=10;
	
	for(int i=v.size()-1;~i;i--){
		int x=v[i];
		if(x==0) continue;	
		
		res+=f[i+1][x-1];
		res+=(n%fpow(10,i)+1)*x;
	}
	
	return res;	
}

int main(){
	init();
	int n;
	cin>>n;
	cout<<dp(n)<<endl;
	
	return 0;
}
```

---

## 作者：本居小铃 (赞：6)

这道题和P2602几乎一样，统计出每个数的个数然后加到结果里就好了  
我们机房某dalao研究出来了模拟算法，跑得和数位DP板子一样快，快%[他](https://www.luogu.org/space/show?uid=59030)  
以下是数位DP板子  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
int a[20];
ll dp[20][2][20][2];
ll dfs(int pos,bool limit,int sum,bool lead,int d)
{
    //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了
    if(pos==0) return sum;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */
    //第二个就是记忆化
    if(dp[pos][limit][sum][lead]!=-1) return dp[pos][limit][sum][lead];
    int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了
    ll ans=0;
    //开始计数
    for(int i=0;i<=up;i++)//枚举，然后把不同情况的个数加到ans就可以了
    {
        ans+=dfs(pos-1,limit && (i==a[pos]),sum+((!lead || i) && (i==d)),/*状态转移*/lead && (i==0),d);//最后两个变量传参都是这样写的
        //当前数位枚举的数是i，然后根据题目的约束条件分类讨论去计算不同情况下的个数，还有要根据state变量来保证i的合法性
    }
    //计算完，记录状态
    dp[pos][limit][sum][lead]=ans;
    /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/
    return ans;
}
ll solve(ll x,ll d)
{
    int pos=0;
    while(x)//把数位都分解出来
    {
        a[++pos]=x%10;
        x/=10;
    }
    memset(dp, -1, sizeof(dp));
    return dfs(pos/*从最高位开始枚举*/,true,0,true,d);//刚开始最高位都是有限制并且有前导零的，而比最高位还要高的一位视为0
}
int main()
{
    ll le,ri,sum=0;
    le=1;
	scanf("%lld",&ri);
    for(int i=1;i<10;i++){
    	sum+=i*(solve(ri,i)-solve(le-1,i));
	}
	printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：math狂热者 (赞：6)

```txt
面对此类题目时，一般的想法是逐位递推,发现递推规律. 
假设推到了第i位，前i-1位都是0，第一种决策是第i位是0,于是便转化成了一个子问题，否则
    设num[i]表示n的最后i位所组成的数
 sum[x]表示1+…+x, (x=1,2,…9) 
 f[x]表示1+…+（10x-1）的数位和 
    f[x]=f[x-1]*10+45*10x-1 
    设n的第i位为pi,那么需要累加的值为: 
    pi*f[i-1]+pi*(num[i-1]+1) +sum[pi-1]*10 (i-1); 
其中sum[pi-1]*10(i-1)表示当前位取1..pi-1时第i位所要累加的值，pi*(num[i-1]+1)表示取pi时第i位需要累加的值，pi*f[i-1]表示第i位不为0时最后i-1位需要再累加的值。
对f值的处理： 
个位 十位 
0 1 2 3 4 5 6 7 8 9 1个 0 
10 1 2 3 4 5 6 7 8 9 
20 1 2 3 4 5 6 7 8 9 
30 1 2 3 4 5 6 7 8 9 
... 
90 1 2 3 4 5 6 7 8 9 9个 1个 
     100 1 2 3 4 5 6 7 8 9 
     110 1 2 3 4 5 6 7 8 9 
     120 1 2 3 4 5 6 7 8 9 
     … 
     990 1 2 3 4 5 6 7 8 9 90个 9个
  1000 1 2 3 4 5 6 7 8 9 
  1010 1 2 3 4 5 6 7 8 9 
  1020 1 2 3 4 5 6 7 8 9 
…. 9990 1 2 3 4 5 6 7 8 9 900 90个
以3456为例进行说明： 
Num [i]：6 56 456 3456 
sum[i]：1 3 6 10 15 21 28 36 45 
f[i]：45 900 13500 180000 
ans：21+ 360+4428+ 44871=49680 
1:处理个位（6）：1+2+3+4+5+6=21 
2:处理十位（56）：5*45+10*10+5*(6+1)= 360 
3:处理百位（456）: 4*900+6*100+4*(56+1)= 4428 
4:处理千位（3456）: 3*13500+3*1000+3*(456+1)= 44871 
下面奉上代码：
```
```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std ;
struct BigN 
{
  int l,num[50];
  BigN()
  {
    memset(num,0,sizeof(num));
    l=0;
  }     
  void output()
  {
     if(l==0)cout<<0;
     else 
     for(int i=l;i>=1;i--)cout<<num[i];
     cout<<endl;
  }  
  void change( )
  {
    for(int i=1;i<=l;i++)
     { 
       num[i+1]+=num[i]/10;
       num[i]%=10;
       if(i==l&&num[l+1]!=0)l++; 
     }   
  }
  BigN operator +(BigN tt)
   {
        BigN cc;    
        cc.l=max(tt.l,l);
        for(int i=1;i<=cc.l;i++)
         { 
            cc.num[i]+=num[i]+tt.num[i]; 
            cc.num[i+1]+=cc.num[i]/10;
            cc.num[i]%=10;
            if(i==cc.l&&cc.num[cc.l+1]!=0)cc.l++;
         }
      
       return cc;
  }
  BigN operator *(int tt)
   {
        BigN cc;
        if(tt==0)return cc;
        cc.l=l;
        int g=0;
        for(int i=1;i<=cc.l;i++)
         {
             cc.num[i]=num[i]*tt+g;       
             g=cc.num[i]/10;
             cc.num[i]%=10;
             if(i==cc.l&&g!=0)cc.l++;     
          }    
         return cc;
   }
 
}map[15],ans,root;
int t=1;
void read( void )
{
   int tot=0;
   map[1].l=2;map[1].num[1]=5;map[1].num[2]=4;  
   for(int i=2;i<root.l;i++)
    {
      map[i].l=i-2;
      tot=45*(9*i+1);
      while(tot)
       {
         
         map[i].num[++map[i].l]=tot%10;
         tot/=10;         
       }
       map[i]=map[i]+map[i-1];  
    } 
   
     
}
void dfs( void )
{
   
   if(root.l==0)return;
   if(root.l==1)
   {
    ans.num[1]+=(root.num[1]*(root.num[1]+1)/2);
    ans.change();return;
   }   
   else  
     {
        BigN tt1;
        tt1=map[root.l-1]*root.num[root.l]; 
        BigN tt2;
        tt2=root;
        tt2.num[tt2.l--]=0;
        tt2.num[1]++;
        tt2.change();
        tt2=tt2*root.num[root.l]; 
        ans=ans+tt1; ans=ans+tt2;
        ans.num[root.l]+=(root.num[root.l]*(root.num[root.l]-1)/2);
        ans.change();
        root.l--;root.num[root.l+1]=0;
        while(root.num[root.l]==0&&root.l>=1)root.l--;
        dfs();
     }
}
int main()
{
    freopen("count.in","r",stdin);
    freopen("count.out","w",stdout);
    int n;
    cin>>n;
    if(n<=9){cout<<n*(n+1)/2;return 0;}
    while(n)
    {
       root.num[++root.l]=n%10;
       n/=10;        
    }
    read( );
    dfs();
    ans.output();
}
```


---

## 作者：Playnext (赞：4)

看楼下dalao都是用规律，我这个蒟蒻只会暴力

~~暴力出奇迹（逃~~

思路就是打表2333

#### 简单来说，就是每1e7个数记录一次个位数个数。

#### 最后加起来即可。

------------
打表程序：
```cpp
int F[10];


AN void Count (REG int Num) {			//记录数据
	do {F[Num % 10]++;}		while (Num /= 10);
}

int main () {
	freopen ("Output.txt", "w",stdout);
	REG int MAX = 1e9;
	For (i,1,MAX) {
		Count (i);
		if (i % MAXN == 0)		For (i,0,9)		Write (F[i]), putchar (','), Space ();
		if (i % MOD == 0)		Enter ();
	}
    return 0;
}
```

------------
最后代码：
```cpp
#include <bits/stdc++.h>
using namespace std;	//BY Playnext
#define REG register
#define IN inline
#define AN __inline__ __attribute__ ((always_inline))
#define For(X,Y,Z) for (REG int X=Y; X<=Z; X++)
#define FOR(X,Y,Z) for (REG int X=Y; X<Z; X++)
#define Space()   putchar (32)
#define Enter()   putchar (10)
const int MAXN=1e4+1, INF=2147483647, MOD=1e9+7;

#define	FileSize 1<<15
char Buffer[FileSize], *Cur, *End;	
#define NextChar() (Cur == End && (End = (Cur = Buffer) + fread (Buffer, 1, FileSize, stdin), Cur == End) ? EOF : *Cur ++)
    	
AN void Read (REG int &Temp) {
    REG int Negative = 1;		Temp = 0;
    REG char Next = NextChar ();
    
    while (!isdigit (Next)) {
        if (Next == '-') 	Negative = -1;
        Next = NextChar ();
    }	
    
    while (isdigit (Next)) {
        Temp = Temp *10 + Next - 48;
        Next = NextChar ();
    }
    
    Temp*= Negative;
}

IN void Write (REG int Temp) {
    if (Temp < 0) 	Temp = -Temp, putchar('-');
    if (Temp > 9) 	Write (Temp /10);
    putchar (Temp %10 + '0');
}


int F[10];
int Sheet[MAXN] = 
{
	5888896, 7000001, 7000000, 7000000, 7000000, 7000000, 7000000, 7000000, 7000000, 7000000, 12888896, 24000000, 14000001, 14000000, 14000000, 14000000, 14000000, 14000000, 14000000, 14000000, 19888896, 31000000, 31000000, 21000001, 21000000, 21000000, 21000000, 21000000, 21000000, 21000000, 26888896, 38000000, 38000000, 38000000, 28000001, 28000000, 28000000, 28000000, 28000000, 28000000, 33888896, 45000000, 45000000, 45000000, 45000000, 35000001, 35000000, 35000000, 35000000, 35000000, 40888896, 52000000, 52000000, 52000000, 52000000, 52000000, 42000001, 42000000, 42000000, 42000000, 47888896, 59000000, 59000000, 59000000, 59000000, 59000000, 59000000, 49000001, 49000000, 49000000, 54888896, 66000000, 66000000, 66000000, 66000000, 66000000, 66000000, 66000000, 56000001, 56000000, 61888896, 73000000, 73000000, 73000000, 73000000, 73000000, 73000000, 73000000, 73000000, 63000001, 68888897, 80000001, 80000000, 80000000, 80000000, 80000000, 80000000, 80000000, 80000000, 80000000, 
	85888896, 97000002, 87000000, 87000000, 87000000, 87000000, 87000000, 87000000, 87000000, 87000000, 92888896, 124000001, 94000001, 94000000, 94000000, 94000000, 94000000, 94000000, 94000000, 94000000, 99888896, 141000001, 111000000, 101000001, 101000000, 101000000, 101000000, 101000000, 101000000, 101000000, 106888896, 158000001, 118000000, 118000000, 108000001, 108000000, 108000000, 108000000, 108000000, 108000000, 113888896, 175000001, 125000000, 125000000, 125000000, 115000001, 115000000, 115000000, 115000000, 115000000, 120888896, 192000001, 132000000, 132000000, 132000000, 132000000, 122000001, 122000000, 122000000, 122000000, 127888896, 209000001, 139000000, 139000000, 139000000, 139000000, 139000000, 129000001, 129000000, 129000000, 134888896, 226000001, 146000000, 146000000, 146000000, 146000000, 146000000, 146000000, 136000001, 136000000, 141888896, 243000001, 153000000, 153000000, 153000000, 153000000, 153000000, 153000000, 153000000, 143000001, 148888897, 260000000, 160000001, 160000000, 160000000, 160000000, 160000000, 160000000, 160000000, 160000000, 
	165888896, 267000001, 177000001, 167000000, 167000000, 167000000, 167000000, 167000000, 167000000, 167000000, 172888896, 284000000, 194000002, 174000000, 174000000, 174000000, 174000000, 174000000, 174000000, 174000000, 179888896, 291000000, 221000001, 181000001, 181000000, 181000000, 181000000, 181000000, 181000000, 181000000, 186888896, 298000000, 238000001, 198000000, 188000001, 188000000, 188000000, 188000000, 188000000, 188000000, 193888896, 305000000, 255000001, 205000000, 205000000, 195000001, 195000000, 195000000, 195000000, 195000000, 200888896, 312000000, 272000001, 212000000, 212000000, 212000000, 202000001, 202000000, 202000000, 202000000, 207888896, 319000000, 289000001, 219000000, 219000000, 219000000, 219000000, 209000001, 209000000, 209000000, 214888896, 326000000, 306000001, 226000000, 226000000, 226000000, 226000000, 226000000, 216000001, 216000000, 221888896, 333000000, 323000001, 233000000, 233000000, 233000000, 233000000, 233000000, 233000000, 223000001, 228888897, 340000000, 340000000, 240000001, 240000000, 240000000, 240000000, 240000000, 240000000, 240000000, 
	245888896, 347000001, 347000000, 257000001, 247000000, 247000000, 247000000, 247000000, 247000000, 247000000, 252888896, 364000000, 354000001, 274000001, 254000000, 254000000, 254000000, 254000000, 254000000, 254000000, 259888896, 371000000, 371000000, 291000002, 261000000, 261000000, 261000000, 261000000, 261000000, 261000000, 266888896, 378000000, 378000000, 318000001, 268000001, 268000000, 268000000, 268000000, 268000000, 268000000, 273888896, 385000000, 385000000, 335000001, 285000000, 275000001, 275000000, 275000000, 275000000, 275000000, 280888896, 392000000, 392000000, 352000001, 292000000, 292000000, 282000001, 282000000, 282000000, 282000000, 287888896, 399000000, 399000000, 369000001, 299000000, 299000000, 299000000, 289000001, 289000000, 289000000, 294888896, 406000000, 406000000, 386000001, 306000000, 306000000, 306000000, 306000000, 296000001, 296000000, 301888896, 413000000, 413000000, 403000001, 313000000, 313000000, 313000000, 313000000, 313000000, 303000001, 308888897, 420000000, 420000000, 420000000, 320000001, 320000000, 320000000, 320000000, 320000000, 320000000, 
	325888896, 427000001, 427000000, 427000000, 337000001, 327000000, 327000000, 327000000, 327000000, 327000000, 332888896, 444000000, 434000001, 434000000, 354000001, 334000000, 334000000, 334000000, 334000000, 334000000, 339888896, 451000000, 451000000, 441000001, 371000001, 341000000, 341000000, 341000000, 341000000, 341000000, 346888896, 458000000, 458000000, 458000000, 388000002, 348000000, 348000000, 348000000, 348000000, 348000000, 353888896, 465000000, 465000000, 465000000, 415000001, 355000001, 355000000, 355000000, 355000000, 355000000, 360888896, 472000000, 472000000, 472000000, 432000001, 372000000, 362000001, 362000000, 362000000, 362000000, 367888896, 479000000, 479000000, 479000000, 449000001, 379000000, 379000000, 369000001, 369000000, 369000000, 374888896, 486000000, 486000000, 486000000, 466000001, 386000000, 386000000, 386000000, 376000001, 376000000, 381888896, 493000000, 493000000, 493000000, 483000001, 393000000, 393000000, 393000000, 393000000, 383000001, 388888897, 500000000, 500000000, 500000000, 500000000, 400000001, 400000000, 400000000, 400000000, 400000000, 
	405888896, 507000001, 507000000, 507000000, 507000000, 417000001, 407000000, 407000000, 407000000, 407000000, 412888896, 524000000, 514000001, 514000000, 514000000, 434000001, 414000000, 414000000, 414000000, 414000000, 419888896, 531000000, 531000000, 521000001, 521000000, 451000001, 421000000, 421000000, 421000000, 421000000, 426888896, 538000000, 538000000, 538000000, 528000001, 468000001, 428000000, 428000000, 428000000, 428000000, 433888896, 545000000, 545000000, 545000000, 545000000, 485000002, 435000000, 435000000, 435000000, 435000000, 440888896, 552000000, 552000000, 552000000, 552000000, 512000001, 442000001, 442000000, 442000000, 442000000, 447888896, 559000000, 559000000, 559000000, 559000000, 529000001, 459000000, 449000001, 449000000, 449000000, 454888896, 566000000, 566000000, 566000000, 566000000, 546000001, 466000000, 466000000, 456000001, 456000000, 461888896, 573000000, 573000000, 573000000, 573000000, 563000001, 473000000, 473000000, 473000000, 463000001, 468888897, 580000000, 580000000, 580000000, 580000000, 580000000, 480000001, 480000000, 480000000, 480000000, 
	485888896, 587000001, 587000000, 587000000, 587000000, 587000000, 497000001, 487000000, 487000000, 487000000, 492888896, 604000000, 594000001, 594000000, 594000000, 594000000, 514000001, 494000000, 494000000, 494000000, 499888896, 611000000, 611000000, 601000001, 601000000, 601000000, 531000001, 501000000, 501000000, 501000000, 506888896, 618000000, 618000000, 618000000, 608000001, 608000000, 548000001, 508000000, 508000000, 508000000, 513888896, 625000000, 625000000, 625000000, 625000000, 615000001, 565000001, 515000000, 515000000, 515000000, 520888896, 632000000, 632000000, 632000000, 632000000, 632000000, 582000002, 522000000, 522000000, 522000000, 527888896, 639000000, 639000000, 639000000, 639000000, 639000000, 609000001, 529000001, 529000000, 529000000, 534888896, 646000000, 646000000, 646000000, 646000000, 646000000, 626000001, 546000000, 536000001, 536000000, 541888896, 653000000, 653000000, 653000000, 653000000, 653000000, 643000001, 553000000, 553000000, 543000001, 548888897, 660000000, 660000000, 660000000, 660000000, 660000000, 660000000, 560000001, 560000000, 560000000, 
	565888896, 667000001, 667000000, 667000000, 667000000, 667000000, 667000000, 577000001, 567000000, 567000000, 572888896, 684000000, 674000001, 674000000, 674000000, 674000000, 674000000, 594000001, 574000000, 574000000, 579888896, 691000000, 691000000, 681000001, 681000000, 681000000, 681000000, 611000001, 581000000, 581000000, 586888896, 698000000, 698000000, 698000000, 688000001, 688000000, 688000000, 628000001, 588000000, 588000000, 593888896, 705000000, 705000000, 705000000, 705000000, 695000001, 695000000, 645000001, 595000000, 595000000, 600888896, 712000000, 712000000, 712000000, 712000000, 712000000, 702000001, 662000001, 602000000, 602000000, 607888896, 719000000, 719000000, 719000000, 719000000, 719000000, 719000000, 679000002, 609000000, 609000000, 614888896, 726000000, 726000000, 726000000, 726000000, 726000000, 726000000, 706000001, 616000001, 616000000, 621888896, 733000000, 733000000, 733000000, 733000000, 733000000, 733000000, 723000001, 633000000, 623000001, 628888897, 740000000, 740000000, 740000000, 740000000, 740000000, 740000000, 740000000, 640000001, 640000000, 
	645888896, 747000001, 747000000, 747000000, 747000000, 747000000, 747000000, 747000000, 657000001, 647000000, 652888896, 764000000, 754000001, 754000000, 754000000, 754000000, 754000000, 754000000, 674000001, 654000000, 659888896, 771000000, 771000000, 761000001, 761000000, 761000000, 761000000, 761000000, 691000001, 661000000, 666888896, 778000000, 778000000, 778000000, 768000001, 768000000, 768000000, 768000000, 708000001, 668000000, 673888896, 785000000, 785000000, 785000000, 785000000, 775000001, 775000000, 775000000, 725000001, 675000000, 680888896, 792000000, 792000000, 792000000, 792000000, 792000000, 782000001, 782000000, 742000001, 682000000, 687888896, 799000000, 799000000, 799000000, 799000000, 799000000, 799000000, 789000001, 759000001, 689000000, 694888896, 806000000, 806000000, 806000000, 806000000, 806000000, 806000000, 806000000, 776000002, 696000000, 701888896, 813000000, 813000000, 813000000, 813000000, 813000000, 813000000, 813000000, 803000001, 703000001, 708888897, 820000000, 820000000, 820000000, 820000000, 820000000, 820000000, 820000000, 820000000, 720000001, 
	725888896, 827000001, 827000000, 827000000, 827000000, 827000000, 827000000, 827000000, 827000000, 737000001, 732888896, 844000000, 834000001, 834000000, 834000000, 834000000, 834000000, 834000000, 834000000, 754000001, 739888896, 851000000, 851000000, 841000001, 841000000, 841000000, 841000000, 841000000, 841000000, 771000001, 746888896, 858000000, 858000000, 858000000, 848000001, 848000000, 848000000, 848000000, 848000000, 788000001, 753888896, 865000000, 865000000, 865000000, 865000000, 855000001, 855000000, 855000000, 855000000, 805000001, 760888896, 872000000, 872000000, 872000000, 872000000, 872000000, 862000001, 862000000, 862000000, 822000001, 767888896, 879000000, 879000000, 879000000, 879000000, 879000000, 879000000, 869000001, 869000000, 839000001, 774888896, 886000000, 886000000, 886000000, 886000000, 886000000, 886000000, 886000000, 876000001, 856000001, 781888896, 893000000, 893000000, 893000000, 893000000, 893000000, 893000000, 893000000, 893000000, 873000002, 788888898, 900000001, 900000000, 900000000, 900000000, 900000000, 900000000, 900000000, 900000000, 900000000
};

AN void Count (REG int Num) {
	do {F[Num % 10]++;}		while (Num /= 10);
}

int main () {
//	freopen ("Input.txt", "r", stdin);
//	freopen ("Output.txt", "w",stdout);
	REG int n;		Read (n);
	REG int m = n / 1e7;
	if (m)		For (i,0,9)		F[i] = Sheet[10 * (m - 1) + i];			//预处理
	For (i,m * 1e7 + 1, n)		Count (i);
	REG long long Ans = 0;
	For (i,0,9)		Ans += (long long) F[i] * i;
	Write (Ans), Enter ();
    return 0;
}
```


---

## 作者：说好不哭 (赞：3)

本题总体思路为递推，也可以理解为简略的数位DP

~~总而言之就是找规律~~

记答案为ans

以下为简易总体思路：

 如样例3456789，先根据之前所得数组a，得出0-2999999中的答案ans，
 然后便可以忽略3；如之前算法，得出0-399999中的答案，累加ans；
 以此类推至最后一位。~~搞定！~~

之后发现样例都没过，原来是在3456789中的456789还需加456789个3，
所以继续累加：ans=ans+3*(456789+1);ans=ans+4*(56789+1).......

如上所示，继续数位累加，得到正确答案。


```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[11][11],n,sum,ans,x,b[11],i,j,now;
char str[11];
int main(){
	ans=0;
	sum=0;
	for (int k=1; k<=10; k++){
		a[k][0]=sum;
		x=1;
		for (i=1; i<=k-1; i++) x=x*10;
		for (i=1; i<=9; i++) {
		a[k][i]=a[k][i-1]+x;
		sum=sum+a[k][i];}
	}     //简易动归方程，也可以理解为前缀和    
	cin>>str;
	for (i=0; i<strlen(str); i++)
	b[i]=str[i];
	int len=strlen(str);

	for (i=0; i<strlen(str); i++){
		for (j=0; j<=b[i]-48-1; j++)
		ans=ans+a[len-i][j];
		now=0;
		x=1;
		for (int k=1; k<len-i-1; k++) x=x*10;
		for (int k=i+1; k<len; k++) {
		now=now+(b[k]-48)*x*(b[i]-48);
		x=x/10;
		}
		now=now+b[i]-48;
		ans=ans+now;
	}        //然后进行模拟。模拟时根据数位计算总和，模拟方法开始已说明
	printf("%lld\n",ans);
return 0;	
}
第一篇认真写的题解，管理员一定要通过啊QAQ
```

---

## 作者：beng (赞：3)

[食用链接味道更佳qwq](http://www.cnblogs.com/qbwhtc/p/7570978.html)

# 本题是让我们求1~n这n个数所有单个数字的和，我们可以试着把每一位所有出现过的数字的和先求出来，然后把每一位的答案加起来就是最终的答案了。

我们就看“3456789”这个例子，它的最高位（百万位）是两部分的和：

1. 1000000~1999999中的1和2000000~2999999中的2，这里的和为**1000000\*(1+2)**；

2. 3000000~3456789中的3，这里的和为**(456789+1)\*3**。

做到这里我们已经可以略微摸索出一些规律了，我们在来看一下十万位：

1. 100000~2999999中的1~9，每个数都轮了3次，这里的和为**100000\*(1+2+3+...+9)\*3**；

2. 3000000~3399999中的1~3，这里的和为**100000\*(1+2+3)**；

3. 3400000~3456789中的4，这里的和为**(56789+1)\*4**。

这里比最高位（百万位）的操作多了一个步骤（其实也可以看做没有，但我习惯分开来算qwq），我们再来看一下万位：

1. 10000~3399999中的1~9，每个数轮了34次，这里的和为**10000\*(1+2+3+...+9)\*34**；

2. 3400000~3449999中的1~4，这里的和为**10000\*(1+2+3+4)**；

3. 3450000~3456789中的5，这里的和为**(6789+1)\*5**。

规律已经很明显了，所以我们只需要将最高位两步处理，而其他位根据我们得出的规律三步处理就行了。

这里具体的规律就不说了，只要看上面的例子和下面的代码应该就可以差不多理解了。

——————分隔不完全的分割线——————

pascal代码如下：

```cpp
var s:string;
n,m,i,j,k:longint;
ans:qword;
begin
  readln(n);
  str(n,s);
  i:=1;
  for m:=1 to length(s)-1 do
  i:=i*10;
  j:=n div i;
  n:=n mod i;
  ans:=i*j*(j-1) div 2+(n+1)*j;
  for m:=2 to length(s) do
  begin
    i:=i div 10;
    k:=k*10+j;
    j:=n div i;
    n:=n mod i;
    ans:=ans+i*45*k+i*j*(j-1) div 2+(n+1)*j;
  end;
  writeln(ans);
end.
```

---

## 作者：Link_Space (赞：1)

一读题就知道是N倍经验了，数位DP很常见的题型，也是练习数位DP的很好的练手题，只要掌握了数位DP就可以很快想出来，其实这道题就是求一个区间内的所有数中出现的数码之和，很显然可以直接数位DP将0-9每一个数码出现的次数求出来，然后分别乘上他们自己的值，最后相加就是最终的答案，代码实现也不难，以下是本蒟蒻的代码，如果还有不懂的可以看一看代码里面的注释

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const int N = 100;
ll dp[N][100][100];//dp[i][j][k]表示的是以j为最高位的i位数中数码k出现的次数
ll ksm(ll a,ll b)
{
	ll res=1;
	while(b)
	{
		if(b&1)
			res*=a;
		a*=a;
		b >>= 1;
	}
	return res;
}//快速幂
void init()
{
	for (int i = 0; i <= 9;i++)
		dp[1][i][i] = 1;//一位数每一个出现的数字都是一次
	for (int i = 2; i < N;i++)
	{
		for (int j = 0; j <= 9;j++)
		{
			for (int k = 0; k <= 9;k++)
			{
				for (int r = 0; r <= 9;r++)
				{
					dp[i][j][r] += dp[i - 1][k][r] ;//初始化转移
             //第i位数的某个数码出现的次数由i-1位数转化而来
				}
			}
			dp[i][j][j] += ksm(10, i - 1);//加上最高位的数字出现的次数
		}
	}
}
ll make(ll n,ll search)//search为当前正在处理的数码
{
	ll digit[N];
	ll len = 0;
	memset(digit, 0, sizeof digit);
	while(n)
	{
		digit[++len] = n % 10;
		n/=10;
	}
	ll res = 0;
	for (int i =1;i<len;i++)
	{
		for (int j = 1; j <= 9;j++)
		{
			res += dp[i][j][search];
		}
	}//枚举位数不足len的数码中有多少个search数码
	for (int i = 1; i < digit[len];i++)
	{
		res += dp[len][i][search];//位数为len的数中search数码的个数
	}
	for (int i = len-1; i >= 1;i--)
	{
		ll x = digit[i];
		for (int j = 0; j < x;j++)
			res += dp[i][j][search];
		for (int j = len; j > i ;j--)
		{
			if(digit[j]==search)
				res += digit[i] * ksm(10, i - 1);
		}
	}//基本的数位DP，和上面预处理的基本思路相同
	return res;
}
int main()
{
	init();
	ll l,r;
	scanf("%lld", &r);
	l = 1;
	ll ans = 0;
	for (int i = 1; i <= 9; i++)
	{
		ans+=(make(r + 1, i) - make(l, i))*i;//分别加上每一个数码的出现次数与这个数码的值的乘积
	}
	printf("%lld", ans);
}
```


---

## 作者：nomonick (赞：0)

数学题

[P1836 数页码](https://www.luogu.com.cn/problem/P1836)

对于每一位上的数字，他都有属于自己的贡献：

对于该位前的数字，表示了从零到九，这位数字已经完整的跑过了 $num \div i \div 10 \times i \times \sum\limits_{k=1}^{9}k$ 次，除以 $i$ 再乘上 $i$ 是为了去除末尾（$i$表示这位是 $10^i$）。 


对于该位的数字，表示了从零到这个数字减一，这位数字已经完整的跑过了 $i \times \sum\limits_{k=1}^{num \div i \bmod 10 - 1}k$ 次 

最后还贡献了这个数值，对应计算了，其后的数字的值遍，即：$( num \div i \bmod 10 ) \times (num \bmod i + 1)$

所以诸位计算，每一位的贡献求和：

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int SIZE = 30;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,ans;
int pre[SIZE];

signed main()
{
	for (int i = 1; i <= 9; ++i)
	{
		pre[i] = pre[i-1] + i;
	}
	n = read();
	for (int i = 1e9; i ; i /= 10)
	{
		if (i > n) continue;
		int tmp = n / i,sum = 0;
		int x = tmp / 10;
		sum += x * i * 45;
		tmp %= 10;
		if (tmp != 0) sum += i * pre[tmp-1];
		sum += tmp * (n % i + 1);
		ans += sum;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Bruce__Lee (赞：0)

这题是一道简易的数位dp，那我就用数位的dp打了吧- -。
思路是这样的：
如果n为345，那么ans就等于ans（99）*（0 + 1 + 2）+ 3 * 100 + 3 * （45 + 1） + ans(45);
当然用数学语言可以描述为 ans(abcd) = ans(10^(位数 - 1) - 1) * （1 + 2 + … + a） + a * 10^(位数 - 1) + a * (bcd + 1) + ans(bcd);
下面就是解释一下这个式子的意义了，
很明显 第一个部分加上第二个部分就是首位数字取小于a时整个数字的贡献；第三个部分就是首位取a时， a自己的贡献，不包括小于 首位的位数 （即bcd）的贡献；第四部分就是首位取a时， 小于 首位位数（即bcd）的贡献。
当然，这个ans（10^n - 1）是可以预处理一下的。
接下来就是愉快的代码时间啦.
```
#include<iostream> 
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<set>
#include<queue> 
#include<algorithm>
#define ls (k << 1)
#define rs (ls | 1)
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const int N = 2e6 + 5;
struct node{
	int to, nxt;
}e[N << 1];
ll dp[15];
int n;
char s[15];
ll dfs(int cur, int len, int t) //dfs就是ans函数 s[cur] - '0'代表首位数字a len代表当前数字位数，t代表的是除了首位的其他数字 即bcd
{
	if (!len)	return 0;
	t %= (int)pow(10, len - 1);
	ll ans = 0;
	for (int i = 0; i < s[cur] - '0'; i++)
		ans += i * pow(10, len - 1) + dp[len - 1];
	return ans + dfs(cur + 1, len - 1, t) + (s[cur] - '0') * (t + 1ll); //
}
ll ans = 0;
int main()
{
	scanf("%s", s);
   // n 就是输入数字
	for (int i = 0; s[i]; i++)
		n = n * 10 + s[i] - '0'; 
     
   //这个就是预处理过程啦，ans(10^n - 1) = dp[n]
	dp[1] = 45;
	for (int i = 2; i <= 10; i++)
		for (int j = 0; j < 10; j++)
			dp[i] += dp[i - 1] + j * pow(10, i - 1);
            
	printf("%lld\n", dfs(0, strlen(s), n));
}
```
蒟蒻的第二篇题解，希望能过，求求了。~~~


---

## 作者：FjswYuzu (赞：0)

此题和数字统计一样，只需要统计出每个数在数位中出现了多少次，将其贡献乘上 $i$ 即可。

定义 $dp_{i,j}$ 为当前填到第 $i$ 个数，出现了 $j$ 次当前枚举的数。可以直接用数位 dp 去做。这道题甚至连技巧都不用，加个记忆化就过了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL dp[15][15],a[15],n;
/*填i位。有j个当前枚举的数*/
LL DP(LL pos,LL lead,LL limit,LL sum,LL prov)
{
	if(pos>n)	return sum;
	if(!lead && !limit && ~dp[pos][sum])	return dp[pos][sum];
	LL up=limit?a[n-pos+1]:9,ans=0;
	for(LL i=0;i<=up;++i)	ans+=DP(pos+1,lead && !i,limit && (i==up),sum+(prov==i && (i || (i==0 && !lead))),prov);
	if(!limit && !lead)	dp[pos][sum]=ans;
	return ans;
}
LL calc(LL d,LL up)
{
	n=0;
	memset(dp,-1,sizeof dp);
	memset(a,0,sizeof a);
	LL tmp=up;
	while(tmp)	a[++n]=tmp%10,tmp/=10;
	return DP(1,1,1,0,d);
}
int main(){
	LL l=1,r;
	scanf("%lld",&r);
	LL ans=0;
	for(LL i=1;i<=9;++i)	ans+=i*(calc(i,r)-calc(i,l-1));
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Demoe (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P1836)

典型数位dp，而且不用考虑 $0$ 的个数。

所以我们可以写一个只对于 $0$ 是**错误**的数位dp，对本题没有影响。

而且更好写。（

通过此题，宁就可以尝试 P2602 [ZJOI2010]数字计数 啦。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=20;
ll l,r,ans[10],lenl,lenr,col,cor,nin[N],tn[N],che[N],f[N][N][N];
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
void add(ll nw,ll len){
//	cout<<nw<<' '<<len<<endl;
	if(nw==0||len==0) return ; 
	ans[nw/tn[len-1]]+=nw%tn[len-1]+1;   //增加首位数字的个数
	ll en=(nw/tn[len-1]==0); 
	while(nw/tn[len-1]==0) len--;   //判掉0开头的
	if(en){add(nw,len);return ;}
	for(ll i=1;i<(nw/tn[len-1]);i++) ans[i]+=tn[len-1];   //增加首位数字个数 
	if(len==1) return ;   //最后一位返回 
//	cout<<nin[len-2]<<' '<<nw/tn[len-1]<<endl;
	for(ll i=0;i<10;i++) ans[i]+=nin[len-2]*(nw/tn[len-1]);   //对后面的所有数进行增加 
	add(nw%tn[len-1],len-1);   //继续 
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	nin[0]=tn[0]=1;
	for(ll i=1;i<N;i++) tn[i]=tn[i-1]*10,nin[i]=tn[i]*(i+1);
	rd(r);l=0;
	col=l;cor=r;
	while(cor){
		lenr++;
		cor/=10;
	}   //求l r的位数
	if(r) add(r,lenr);
	ll anss=0;
	for(ll i=1;i<10;i++) anss+=ans[i]*i;
	wr(anss),puts("");
	return 0;
}
```


---


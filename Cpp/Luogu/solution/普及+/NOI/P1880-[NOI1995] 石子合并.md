# [NOI1995] 石子合并

## 题目描述

在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。


## 说明/提示

$1\leq N\leq 100$，$0\leq a_i\leq 20$。

## 样例 #1

### 输入

```
4
4 5 9 4```

### 输出

```
43
54```

# 题解

## 作者：Hurricane、 (赞：336)

如果对于任意的a1≤a2< b1≤b2，有m[a1,b1]+m[a2,b2]≤m[a1,b2]+m[a2,b1]，那么m[i,j]满足四边形不等式。


所以这是一个求(xuan)骗(xue)的东西。

*******************

#定理

[](http://blog.163.com/dqx\_wl/blog/static/2396821452015111133052112/)


对方程$$m(i,j)=\min\{m(i,k-1),m(k,j)\}+w(i,j)          (i≤k≤j)$$

且s(i,j)表示m(i,j)取得最优值时对应的下标，有：


- 区间包含的单调性：如果对于i≤i'< j≤j'，有w(i',j)≤w(i,j')，那么说明w具有区间包含的单调性。

![区间包含的单调性](http://img.blog.csdn.net/20171220095805272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDEyNTI4OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 四边形不等式：如果对于i≤i'< j≤j'，有w(i,j)+w(i',j')≤w(i',j)+w(i,j')，我们称函数w满足四边形不等式。

![四边形不等式](http://img.blog.csdn.net/20171220100013699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDEyNTI4OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

蓝线长和≤红线长和

- 定理一：如果上述的w函数同时满足区间包含单调性和四边形不等式性质，那么函数m也满足四边形不等式性质。


- 定理二：假如m(i,j)满足四边形不等式，那么s(i,j)单调，即s(i,j)≤s(i,j+1)≤s(i+1,j+1)。


然后k的范围就从 [ i , j ] 变成了[ s(i,j-1) , s(i+1,j) ]，像这样：

![表](http://img2.ph.126.net/JuoBJNeFqkb342wbFNg3UA==/6631278871933975781.jpg)

m[1,3]取s[1,2]和s[2,3]，

m[2,5]取s[ 2,4]=3，s[3,5]=3，相当于直接取3。

（然后记s[2,5]=3）

少了一重循环！！！


**完美解释了OBST问题！！！**

~~（其实就是套定理）~~


#题目


[NOI 1995 石子合并](https://www.luogu.org/problemnew/show/1880)

(洛谷  P1880)

n<=100……如果n<=1000呢？

100的$O(n^3)$还能过，1000的就得$O(n^2)$了。


环形的……也不惧……

***但最大值不单调，不能用四边形不等式***

不过最大值可以两个端点的最大者取得。

![最大值不单调](http://img.blog.csdn.net/20171221171418185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfNDEyNTI4OTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

[详解](http://www.eefocus.com/chs4444/blog/11-12/235769\_83fc1.html)


题解 by myself


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[2005],sum[2005];
int fmi[2005][2005],fma[2005][2005],
    smi[2005][2005];

int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        a[i+n]=a[i];
        sum[i]=sum[i-1]+a[i];
        smi[i][i]=i;
        }
    for(int i=1+n;i<=(n<<1);i++){
        sum[i]=sum[i-1]+a[i];
        smi[i][i]=i;
        }
    for(int i=(n<<1)-1;i;i--)
        for(int j=i+1;j<=(n<<1);j++){
            int jc=0,tmp=0x3f3f3f3f;
            fma[i][j]=max(fma[i][j-1],fma[i+1][j])+sum[j]-sum[i-1];
            /*注意这句，
              求最大值不能用四边形不等式，
              因为最大值不满足单调性，
              但最大值有一个性质，
              即总是在两个端点的最大者中取到。
            */
            for(int k=smi[i][j-1];k<=smi[i+1][j];k++){
                int tt=fmi[i][k]+fmi[k+1][j]+(sum[j]-sum[i-1]);
                if(tt<tmp){
                    tmp=tt;
                    jc=k;
                    }
                }
            smi[i][j]=jc;
            fmi[i][j]=tmp;
            }
    int ama=0,ami=0x3f3f3f3f;
    for(int i=1;i<=n;i++){
        ama=max(ama,fma[i][i+n-1]);
        ami=min(ami,fmi[i][i+n-1]);
        }
    printf("%d\n%d",ami,ama);
    
    return 0;
    }
```

---

## 作者：FFF团 (赞：243)

本题如果要写动态规划的话，不仅要考虑推的顺序还要考虑边界与初始化的问题；

这时候不如记忆化搜索，因为搜索时可以避免顺序问题边界也非常容易设计；

但不管是记忆化还是动态规划都要考虑环的问题，这时不如直接将环拆为2\*n的链来考虑，因为2\*n的链已经足够考虑到所有情况了；

代码来一发

    
    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int INF=0x7fffffff;
int n,m,ans1,ans2;
int A[205],f1[205][205],f2[205][205];
int dfs1(int L,int R){                //求出最小得分 
    if(f1[L][R])return f1[L][R];    //已保存的状态不必搜索 
    if(L==R)    return f1[L][R]=0;    //L==R时返回0 
    int res=INF;                    //初始值赋为最大值以求最小值 
    for(int k=L;k<R;k++)            //枚举K搜索 
        res=min(res,dfs1(L,k)+dfs1(k+1,R)+A[R]-A[L-1]);
    return f1[L][R]=res;            //记录状态 
}
int dfs2(int L,int R){                //求出最大得分 
    if(f2[L][R])return f2[L][R];
    if(L==R)    return f2[L][R]=0;    //若初始值为0可省略该句 
    int res=0;                        //初始值设为0 
    for(int k=L;k<R;k++)
        res=max(res,dfs2(L,k)+dfs2(k+1,R)+A[R]-A[L-1]);
    return f2[L][R]=res;
}
int main(){
    std::ios::sync_with_stdio(false);//取消cin与stdin同步,加速读入 
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>A[i];
        A[i+n]=A[i];                //因为是环所以保存为长度为2n的链以保证不会漏解 
    }
    for(int i=1;i<=2*n;i++)            //求出前缀和 
        A[i]+=A[i-1];
    dfs1(1,2*n);dfs2(1,2*n);        //搜索出1-2n的最大得分与最小得分 
    ans1=INF;    ans2=0;
    for(int i=1;i<=n;i++){
        ans1=min(f1[i][n+i-1],ans1);//选出答案 
        ans2=max(f2[i][n+i-1],ans2);
    }
    cout<<ans1<<"\n"<<ans2;
    return 0;
}
```

---

## 作者：逆流之时 (赞：172)

这篇题目已经有四边形不等式的题解了，我就做一点补充吧。  
1.为什么长度为n的环可以看做长度为2n的链？  
因为n堆石子会合并n-1次，就像并查集一样，最后总会刚好有两端是没有连接的，所以计算最大值可以这样算，然后从中选取长度为n且分数最大的一段链。  
2.为什么最大值从可以两个端点的最大者取得？  
首先可以把最后一步看成两堆石子合并，倒数第二部看成三堆石子中的两堆合并，再与第三堆合并。  
那三堆中哪两堆合并呢？  
(用w[i]表示第i堆重量)  
前两堆:$w1=2w[1]+2w[2]+w[3]$    
后两堆:$w2=w[1]+2w[2]+2w[3]$（自行推导)  
所以应该将1号和3号中较大的一堆与第2堆合并，也就是把一堆合并得尽可能大，所以就有
```cpp
dp2[i][j]=max(dp2[i+1][j],dp2[i][j-1])+cnt[j]-cnt[i-1]; 
```
再贴上完整代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int cnt[210],s[210][210],dp[210][210],n,temp,te,dp2[210][210],maxn,minn;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&cnt[i]),cnt[i]+=cnt[i-1],s[i][i]=i,s[i+n][i+n]=i+n;
	for(int i=1;i<=n;i++)cnt[i+n]=cnt[i]+cnt[n];
	for(int i=n*2;i>=1;i--)
		for(int j=i+1;j<=n*2;j++)//参考第1点
		{
			temp=0x7fffffff;
			dp2[i][j]=max(dp2[i+1][j],dp2[i][j-1])+cnt[j]-cnt[i-1]; //参考第2点
			for(int k=s[i][j-1];k<=s[i+1][j];k++)
			{
				if(temp>dp[i][k]+dp[k+1][j]+cnt[j]-cnt[i-1])
				{
					temp=dp[i][k]+dp[k+1][j]+cnt[j]-cnt[i-1];
					te=k;
				}
			}
			dp[i][j]=temp;
			s[i][j]=te;
		}
	minn=0x7fffffff;
	for(int i=1;i<=n;i++)
	{
		minn=min(minn,dp[i][i+n-1]);
		maxn=max(maxn,dp2[i][i+n-1]);
	}
	printf("%d\n%d",minn,maxn);
	return 0;
}

```
由上面的推导可以得到：$w1<=w2$时，$w[1]<=w[3]$。  
其实这就是GarsiaWachs算法的思想。石子合并题解里没有大佬讲这个算法。貌似在《The Art of Computer Programming》上有。~~虽然我也没用看过~~  
这个算法可以将石子合并问题优化到$O(nlogn)$的规模，目前百度上关于这个算法的博客不多，绝大部分都以石子合并为例题，关于这个算法的其他用途我还在探索中。  
这个算法的具体思想是：设一个序列是$w[1..n]$（在这题里面就是当前n堆石子的质量），每次寻找最小的一个满足$w[k-1]<=w[k+1]$的$k$。  
那么我们就把$w[k]$与$w[k-1]$合并，之后找最大的一个满足$w[j]>w[k]+w[k-1]$的$j(j<k)$,把合并后的值$w[k]+w[k-1]$插入$w[j]$的后面。  
由于可以把从$w[j+1]$到$w[i-2]$的石子看成一个整体$w[mid]$,现在考虑三堆石子的情况：$w[j],w[mid],temp(w[i]+w[i-1])$, 因为$temp<w[j]$ ,因此不管怎样都是$w[mid]$和$temp$先合并, 所以$temp$值插入$w[j]$的后面后答案不会改变。  
本来这个算法的原复杂度是$O(n^2)$，加上了平衡树优化的时间复杂度是$O(nlogn)$。  
然而GarsiaWachs算法的常数十分小。FHQ在POJ上发了讲解这个算法的帖：http://poj.org/showmessage?message_id=146323 ，他就用这个算法的朴素O(n^2)过了POJ的n=50000的数据。     
（同时李煜东现身评论区）  

题外话：  
关于主流算法讲解书对动态规划、四边形不等式优化动态规划和GarsiaWachs算法的讲解与重视程度：  
目前就我买的几本书中，只有很少的几本提到了四边形不等式。  
信息学奥赛一本通：极少的讲解，大量例题与讲解内容抄袭，看过就知道。背包九讲不知道是不是抄的，不过例题有很多都是抄的，而且换到书里的题目背景还严重影响阅读体验。  
紫书（《算法竞赛入门经典》）：讲dp主要目的是锻炼思维，提到的动态规划优化方法极少。  
蓝书（《算法竞赛入门经典训练指南》）：没有dp专题。第一章略提到了四边形不等式。（本来我买这本书就是因为紫书第11章提到了蓝书讲过四边形不等式，结果买来一看，也没有详细的证明，四边形不等式的证明基本都被省略了）  
算法竞赛进阶指南：动态规划讲了15章，是我看的所有竞赛书里最详细的一本，四边形不等式有详细的证明，不过GarsiaWachs算法只是提到了一下。（毕竟是专门讲dp的章节，而GarsiaWachs算法并不属于dp）  
我列举这些信息的目的，是为了让大家意识到，动态规划的知识已经有很多，尽管有很多地方（而且包括很多讲解详细的书籍）都没有详细提及，但dp确实是OI很重要的一部分。洛谷的石子合并题解有40篇左右，但很多人的题解都停留在$O(n^3)$的算法上，少数人提到了四边形不等式，但全部没有四边形不等式的详细证明，而且也没有讲解GarsiaWachs算法的题解。所有希望大家能在学习OI的时候，一直保持着对新知识的求知精神。  

---

## 作者：跪下叫哥 (赞：122)

# 石子合并

## 分析

```
4 5 9 4
```

首先当然一条链来做，
那么最后一次合并（所有的石子合并成一堆）的时候的，得到是什么？

```
4+5+9+4
```

最后一次合并一定是两堆石子合并，关键是这两堆石子有可能的是：

第1种可能性:(4),(5,9,4) 4是一堆石子,(5,9,4)合并的一堆石子
第2种可能性:(4,5),(9,4)
第3种可能性:(4,5,9),(4)

所以,我们更加抽象一点来思考,设f(i,j)表示第i堆石子到第j堆石子合并成一堆石子的最大得分,sum(i,j)表示第i到第j的和:

f(i,j) = max{f(i,k)+f(k+1,j)} +sum(i,j) i<=k <j,

k表示把i和j从中间分开,边界f[i][i] = 0

所以一条链的石子合并就OK了,关键环形的怎么做

最简单的想法:从环每一个点拆成多条链,分别求每条链的最大值,然后从这些最大值中找一个最大的,就是答案,例如样例数据可以写成

4 5 9 4
5 9 4 4
9 4 4 5
4 4 5 9

可以写成4条链.

但是这样拆环,你会发现,你重复的计算了一些数据

4 [5 9 4]
[5 9 4] 4
9 4 4 5
4 4 5 9

你重复计算了(4,5,9) 合并的一堆石子的最大值.



**应该这样拆环成链**

4 5 9 4 4 5 9

包含了上面的所有的链,你要求的是

f(1,4) ==>4 5 9 4
f(2,5) ==>5 9 4 4
f(3,6) ==>9 4 4 5
f(4,7) ==>4 4 5 9

这样做的好处是:不会重复计算

因为:
你先算:f(1,2),f(2,3),f(3,4),f(4,5),f(5,6),f(6,7) 长度为2的
再算:f(1,3),f(2,4),f(3,5),f(4,6),f(5,7) 长度为3
最后算:f(1,4),f(2,5),f(3,6),f(4,7) 长度为4
边界:f(i,i) = 0

**状态转移方程：**

```math
f(i,j) = max{f(i,k) +f(k+1,j) } +sum(i,j)
```

**边界:**

```math
f(i,i) = 0
```

**推导过程**
f(1,2) = f(1,1) +f(2,2)+ sum(1,2)

f(1,3) = {
1: f(1,1)+f(2,3)
2: f(1,2)+f(3,3)
}



4 5 9 4
5 9 4 4
9 4 4 5
4 4 5 9

4 5 9 4 4 5 9



## 代码

```c
#include <cstdio>
#include <cstring>

int n;
int a[200];


int f[200][200] = {0}; //不用初始化边界了
int fx[200][200] = {0}; //不用初始化边界了,存最小值
int pre[200] = {0};
int ans_max = -1;
int ans_min = 0x7f7f7f7f;


int max(int a,int b){
    if( a >b ) return a;
    return b;
}

int min(int a,int b){
    if( a <b ) return a;
    return b;
}

int sum(int i,int j){
    return pre[j] - pre[i-1];
}

int main(){
    int i,j,k;
    scanf("%d",&n);
    for(i=1;i<=n;i++){
        scanf("%d",&a[i]);
        a[n+i] = a[i];
    }

    int len = (n<<1)-1;
    for(i=1;i<=len;i++){
        pre[i] = pre[i-1] +a[i];
    }
    
    memset(fx,0x7f,sizeof(fx));
    for(i=0;i<=200;i++) fx[i][i] = 0;



    for(i=2;i<=n;i++){ // 合并几堆石子
        for(j=1;j<=len-i+1;j++){
            for(k=j;k<j+i-1;k++){
             int m =  f[j][k] + f[k+1][j+i-1];

             int xiao = fx[j][k] +fx[k+1][j+i-1];

             if( f[j][j+i-1] < m) //求 max
                 f[j][j+i-1] = m;

             if( fx[j][j+i-1] > xiao) //求 max
                 fx[j][j+i-1] = xiao;
            }
            f[j][j+i-1] += sum(j,j+i-1);
            fx[j][j+i-1] += sum(j,j+i-1);
        }
    }

    for(i=1;i<=n;i++){
        if( ans_max < f[i][i+n-1])
            ans_max = f[i][i+n-1];

        if( ans_min > fx[i][i+n-1])
            ans_min = fx[i][i+n-1];
    }
    printf("%d\n",ans_min);
    printf("%d",ans_max);

    return 0;
}
```
做完这题,你可以尝试做做这题：


## [平行四边行优化](http://www.cnblogs.com/jiu0821/p/4493497.html)


---

## 作者：行者_Walker (赞：73)

## dp的for，状态转移看不懂的来看看我这一篇题解，准保刷新思路！

我是一个dp的蒟蒻，就是怎么也理解不了dp

#### 我换了一种思路：不会for但是可以递归呀，把一个大问题分解成若干个小问题再逐一解决

### 解释：

- 我定义函数doit（ x , y ）返回值是将区间[ x , y ]的石子合并后得到的**最小**值

- 相反，doit2 ( x , y )返回值是将区间[ x , y ]的石子合并后得到的**最大**值

- 再处理一个前缀和方便查询某个区间的和

- 因为石子是一圈一圈的，所以我们要把它展开

- 对于以上的详细解释，可以看其他题解，本题解主要提供一个新的**思路**！！

### 记忆化：
- 因为不停的递归会超时，于是我们可以加一个记忆化数组jy[205]（ji-yi记忆,音译而来）这样程序就可以跑得飞快了

到这听不懂没关系，代码里面有超详细解释（^.^）


```cpp
# include <iostream>
# include <cstdio>
# include <cmath>
# include <algorithm>
# include <queue>
# include <stack>
using namespace std;
int read();
int n;//这个还要解释，那还是去再读一边题吧
int a[205];//存a[i]这堆石子的数量
int add[205];//前缀和，方便查询
int jy[205][205];//记忆最小的合并值
int jy2[205][205];//记忆最大的合并值
int sum1,sum2;
int doit(int x,int y);//声明递归最小的合并值
int doit2(int x,int y);//声明递归最大的合并值
int main()//---------------------主函数----------------------
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		add[i]+=a[i]+add[i-1];//前缀和
	}
	for(int i=n+1;i<=n*2;i++)//展开
	{
		a[i]=a[i-n];//a[数组]重复来一波
		add[i]+=a[i]+add[i-1];//add继续加前缀和
	}
	int ans1=9999999,ans2=0;//用来更新区间最值的变量
	for(int i=1;i<n;i++)
	{
    		//枚举区间，更新区间最值
		ans1=min(ans1,doit(i,i+n-1));
		ans2=max(ans2,doit2(i,i+n-1));
	
	}
	printf("%d\n%d",ans1,ans2);//输出更新的值
	return 0;
}

int doit(int x,int y)//求最小合并值doit------------------------------
{//重点了，注意看！！！！！！！！！！！！！
	if(x==y)return 0;//跑到点上去了，返回0，因为要求的是区间和，和单个点权值无关
	if(jy[x][y])return jy[x][y];//记忆化，如果之前求过这个
    				//区间的值，直接返回，快得起飞
	int ans=9999999;//定义一个ans用来更新最小合并值
	int tes=add[y]-add[x-1];//这个是区间[x,y]的和
    //add[ ]是前缀和
	for(int k=x;k<y;k++)
	{
    //枚举k，更新区间[x,y]的最小合并值
		ans=min(ans,doit(x,k)+doit(k+1,y)+tes);	 
	}
	jy[x][y]=ans;//记忆这个值
	return ans;返回求到的这个区间最小合并值
}

int doit2(int x,int y)//求最大合并值doit2----------------------------
{
	//这里和doit差不多，只是min变成了max
   	//我就不重复解释了
	if(x==y)return 0;
	if(jy2[x][y])return jy2[x][y];
	int ans=0;
	int tes=add[y]-add[x-1];
	for(int k=x;k<y;k++)
	{
		ans=max(ans,tes+doit2(x,k)+doit2(k+1,y));
	}
	jy2[x][y]=ans;
	return ans;
}

//读入优化
int read()
{
	int ans=0,flag=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
		{
			flag=-1;
			ch=getchar();
			break;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
```


---

## 作者：Anubis (赞：53)


题目解析：

　　第一次做这种题型的大佬们应该不会把它当成贪心来做吧？？？反正小蒟蒻我是做错了啦！！！
  
后面有分析了几个手推数据，发现！！！ 这是一题动规，还是一题区间动规！！！

让我们先看看样例：
	这是最小值的求法，看起来好像和贪心很像勒！！！但其实只是样例数据给出的假象罢了！！！
  
　	　很多的大佬和蒟蒻做题时用了贪心结果只有30分！！！
  
　	　首先如何解决上图环的问题呢？？？
 　	当然很简单啦，我们把它存成一条链：即把T存成2*T
  
　	　如：2 3 4 6 5 4 2 3 4 6 5 4 这样每次枚举i到i+N-1就可以了是吧是不是很简单啊(^▽^ ) (i<=N)
  
　	　上文我们说到这是一题动规，那么我们来分析一下：
  
　　1.根据题意可知每次都是两堆石子合并成一堆，并且这两堆石子是相邻的！！
  
　　那么这两堆石子又是由另外的石子合并的，那么我们可以认为i到j堆石子是由F[i][k]和F[k+1][j]合成的。那么F[i][k]也是根据上面的规则求得到！！！
  
　　	2.那么合成的分数如何表示的呢？？？( -'`-)
    
　	　已知每个点的分数都是确定的，那么无论前面的数据如何合并的分数一定是由前面sum[j]-sum[i-1]的值，sum[i]=sum[i-1]+T[i];，
　　	因此得到F[i][j]=max(F[i][k]+[k+1][j]+sum[j]-sum[i-1],F[i][j]);
　　
　	　至此这题大水题已经解决了剩下的只是要考虑合并几次的问题而已
     
　　	因为第一次至少两堆合并，那么就有了L (L=2；L<=N;++L)j=i+L-1;
    
　　	最后就是求一下答案枚举一遍就行了！！
    
　　	下面正解代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
const int MAXN=0xfffff,MINN=0;
inline int read()//快读
{
    int x=0,w=0;
    char ch=0;
    while(!isdigit(ch))
    {
        w|=ch=='-',ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    }
    return w?-x:x;
}
int T[210],F1[210][210],F2[210][210],sum[210];//T为输入的石子堆，F1为第一问的答案求解，F2为第二问的答案求解，sum为求前ｉ堆石子的合总值
int main(void)
{
    int N=read();
    for(int i=1; i<=N; ++i) T[i]=read(),T[i+N]=T[i];／／变环为链
    for(int i=1; i<=2*N; ++i) sum[i]=sum[i-1]+T[i],F1[i][i]=0,F2[i][i]=0;//注意要把Ｆ［ｉ］［ｉ］＝０
    for(int L=2; L<=N; ++L)
    {
        for(int i=1; i<=2*N-L+1; ++i)
        {
            int j=i+L-1;
            F1[i][j]=MAXN,F2[i][j]=MINN;//初始化
            for(int k=i; k<j; ++k)
            {

                F1[i][j]=min(F1[i][k]+F1[k+1][j],F1[i][j]);//寻找最小值
                F2[i][j]=max(F2[i][k]+F2[k+1][j],F2[i][j]);//寻找最大值
            }
            F1[i][j]+=(sum[j]-sum[i-1]);//加上此次合并值
            F2[i][j]+=(sum[j]-sum[i-1]);
        }
    }
    int ANS1=MAXN,ANS2=MINN;
    for(int i=1; i<=N; ++i)
    {
        ANS1=min(ANS1,F1[i][i+N-1]);//求解答案１
        ANS2=max(ANS2,F2[i][i+N-1]);//求解答案２
    }
    printf("%d\n%d",ANS1,ANS2);//输出
    return 0;
}
```
 

 





---

## 作者：_wkjzyc (赞：40)

### 一、贪心

贪心只能处理“任取两堆”，而不能处理“相邻两堆”。任取两堆的题目就是 合并果子。

### 二、划分阶段

本题是区间DP的模板题（然而对蒟蒻还是很难）

很容易想到用f[i][j]表示i~j的最大（小）得分。

### 三、状态转移

在i~j这一区间内，枚举下标k进行拆分。拆分区间是区间DP的重要思想之一。

合并i~k与k+1~j的区间，会加上i~j之间所有石子个数之和。

故我们得到状态转移方程为f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1]) （最小值max改为min）

其中s为前缀和（不懂的自觉退役……自觉补习）。

### 四、环

dalao们可能会使用高级数据结构，但其实有一种更简单的方法：把原数组往后复制一遍。

以样例4 5 9 4为例，复制后得到：

4 5 9 4 4 5 9 4

i~j长度不能超过n

### 五、玄学40分

基础DP的代码比较简短，但麻烦的地方有很多，关键在于环。

```cpp
for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=2*n;j++)
        {
            if(j-i>=n)
                break;
            for(int k=i;k<j;k++)
            {
                ma[i][j]=max(ma[i][j],ma[i][k]+ma[k+1][j]+sum[j]-sum[i-1]);
                mi[i][j]=min(mi[i][j],mi[i][k]+mi[k+1][j]+sum[j]-sum[i-1]);
            }
        }
    }
```
这是之前的一份错误代码，它使用直接计算长度的方式来保证长度<=n。

但是这样的转移顺序会出现问题。如，外层循环i=1，第二层j=10，内层循环k=4时：

f[1][10]=max(f[1][10],f[1][4]+f[5][10]+s[10]-s[0])

可以发现f[5][10]还未转移，这也是玄学40分的原因。

 

解决方法倒是有不少，这里 借 鉴 了其他题解，用r=i+j-1来记录右边界，使r和i，j直接联系，完美避免了上述情况。

不过肉眼找bug可能有误，请dalao指正。详情见代码。

### 六、代码

码风丑陋勿喷，没有优化勿喷。

另外，以此题的数据范围完全用不到四边形不等式这类的高档算法。

以后如果想起来，还会再来更新O(n2)算法（咕）

```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
using namespace std;
int n,a[205],mi[205][205],ma[205][205],sum[205],ansmax,ansmin,r;
int main()
{
    memset(mi,0x3f,sizeof(mi));
    memset(ma,0,sizeof(ma));
    //初始化
    cin>>n;
    sum[0]=0;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        a[i+n]=a[i];
    //输入
    }
    for(int i=1;i<2*n;i++)
    {
        sum[i]=sum[i-1]+a[i];
        mi[i][i]=ma[i][i]=0;
        //维护前缀和，再次初始化数组
    }
    for(int i=2;i<=n;i++)
    {
        for(int j=1;i+j-1<2*n;j++)
        {
            r=i+j-1;
            for(int k=j;k<r;k++)
            {
                ma[j][r]=max(ma[j][r],ma[j][k]+ma[k+1][r]+sum[r]-sum[j-1]);
                mi[j][r]=min(mi[j][r],mi[j][k]+mi[k+1][r]+sum[r]-sum[j-1]);//状态转移
            }
        }
    }
    ansmin=0x7fffffff;
    ansmax=-1;
    for(int i=1;i<=n;i++)
    {
        ansmin=min(ansmin,mi[i][i+n-1]);
        ansmax=max(ansmax,ma[i][i+n-1]);
    //选择最大（小）值
    }
    cout<<ansmin<<"\n"<<ansmax;
    return 0;
}
```

---

## 作者：Kevin_Wa (赞：28)

本题初看以为可以使用贪心法解决问题，但是事实上因为有必须相邻两堆才能合并这个条件在，用贪心法就无法保证每次都能取到所有堆中石子数最多的两堆。例如下面这个例子：

    6
    3 4 6 5 4 2
   如果使用贪心法求最小得分，应该是如下的合并步骤：
    
        第一次合并 3 4 6 5 4 2    2,3合并得分是５
        第二次合并 5 4 6 5 4      5,4合并得分是9
        第三次合并 9 6 5 4        5,4合并得分是9
        第四次合并 9 6 9          9,6合并得分是15
        第五次合并 15 9           15,9合并得分是24
        总得分＝5＋9＋9＋15＋24＝62
        
    但是如果采用如下合并方法，却可以得到比上面得分更少的方法：
        第一次合并 3 4 6 5 4 2     3,4合并得分是7
        第二次合并 7 6 5 4 2       7,6合并得分是13
        第三次合并 13 5 4 2        4,2合并得分是6
        第四次合并 13 5 6          5,6合并得分是11
        第五次合并 13 11           13,11合并得分是24
        总得分＝7＋13＋6＋11＋24＝61
        
   由此我们知道本题是不可以使用贪心法求解的，上例中第五次合并石子数分别为$13$和$11$的相邻两堆。 这两堆石头分别由最初 的第$1$，$2$，$3$堆（石头数分别为$3$，$4$，$6$）和第$4$，$5$，$6$堆（石头数分别为$5$，$4$，$2$）经$4$次合并后形成的。于是问题又归结为如何使得这两个子序列的$N-2$次合并的得分总和最优。为了实现这一目标，我们将第$1$个序列又一分为二：第$1$、$2$堆构成子序列$1$，第$3$堆为子序列$2$。第一次合并子序列$１$中的两堆，得分$7$；第二次再将之与子序列$2$的一堆合并，得分$13$。显然对于第$1$个子序列来说，这样的合并方案是最优的。同样，我们将第$2$个子序列也一分为二；第$4$堆为子序列$1$，第$5$，$6$堆构成子序列$2$。第三次合 并子序列$2$中的$2$堆，得分$2$；第四次再将之与子序列$1$中的一堆合并，得分$13$。显然对于第二个子序列来说，这样的合并方案也是最优的。由此得出一个结论──$6$堆石子经过这样的$5$次合并后，得分的总和最小。
   
    动态规划思路：
    阶段i：石子的每一次合并过程，先两两合并，再三三合并，...最后N堆合并
    
    状态s：每一阶段中各个不同合并方法的石子合并总得分。
    
    决策：把当前阶段的合并方法细分成前一阶段已计算出的方法，选择其中的最优方案
    
    具体来说我们应该定义一个数组s[i,j]用来表示合并方法，i表示从编号为i的石头开始合并，j表示从i开始数j堆进行合并，s[i,j]为合并的最优得分。
    
    对于上面的例子来说，初始阶段就是s[1,1],s[2,1],s[3,1],s[4,1],s[5,1],s[6,1]，因为一开始还没有合并，所以这些值应该全部为0。
    
    第二阶段：两两合并过程如下，其中sum(i,j)表示从i开始数j个数的和
              s[1,2]=s[1,1]+s[2,1]+sum(1,2)
              s[2,2]=s[2,1]+s[3,1]+sum(2,2)
              s[3,2]=s[3,1]+s[4,1]+sum(3,2)
              s[4,2]=s[4,1]+s[5,1]+sum(4,2)
              s[5,2]=s[5,1]+s[6,1]+sum(5,2)
              s[6,2]=s[6,1]+s[1,1]+sum(6,2)
              
    第三阶段：三三合并可以拆成两两合并，拆分方法有两种，前两个为一组或后两个为一组
         s[1,3]=s[1,2]+s[3,1]+sum(1,3)或s[1,3]=s[1,1]+s[2,2]+sum(1,3)，取其最优
         s[2,3]=s[2,2]+s[4,1]+sum(2,3)或s[1,3]=s[2,1]+s[3,2]+sum(2,3)，取其最优
                             .
                             .
                             .
    第四阶段：四四合并的拆分方法用三种，同理求出三种分法的得分，取其最优即可。以后第五阶段、第六阶段依次类推，最后在第六阶段中找出最优答案即可。

    由此得到算法框架如下：
    For j←2 to n do    {枚举阶段，从两两合并开始计算}
      For i←1 to n do   {计算当前阶段的n种不同状态的值}
         For k←1 to j-1 do {枚举不同的分段方法}
           begin
             If i+k>n then t←(i+k) mod n else t←i+k {最后一个连第一个的情况处理}
             s[i,j]←最优{s[i,k]+s[t,j-k]+sum[1,3]} {sum[i,j]表示从i开始数j个数的和}
           end;
参考程序

```pascal
var
 n:integer;
 a:array[1..100] of longint;
 s:array[1..100,1..100] of longint;
 t:array[0..100,0..100] of longint;
 i,j,k,temp,max,min:longint;
begin
  readln(n);
  fillchar(t,sizeof(t),0);      {计算和数组}
  for i:=1 to n do
    read(a[i]);
  for i:=1 to n do
    for j:=1 to n do
      for k:=i to i+j-1 do
        begin
          if k>n then temp:=k mod n else temp:=k;
          t[i,j]:=t[i,j]+a[temp];
        end;
{动态规划求最大得分}
  fillchar(s,sizeof(s),0);
  for j:=2 to n do
    for i:=1 to n do
      for k:=1 to j-1 do
        begin
          if i+k>n then temp:=(i+k) mod n else temp:=i+k;  {处理环形问题}
          max:=s[i,k]+s[temp,j-k]+t[i,j];
          if s[i,j]<max then s[i,j]:=max;
        end;
  max:=0;        {在最后的阶段状态中找最大得分}
  for i:=1 to n do
    if max<s[i,n] then max:=s[i,n];

{动态规划求最小得分}
  fillchar(s,sizeof(s),0);
  for j:=2 to n do
    for i:=1 to n do
      begin
        min:=maxlongint;
        for k:=1 to j-1 do
          begin
            if i+k>n then temp:=(i+k) mod n else temp:=i+k;  {处理环形问题}
            s[i,j]:=s[i,k]+s[temp,j-k]+t[i,j];
            if min>s[i,j] then min:=s[i,j];
          end;
        s[i,j]:=min;
      end;
  min:=maxlongint;  {在最后的阶段状态中找最小得分}
  for i:=1 to n do
    if min>s[i,n] then min:=s[i,n];
 writeln(min);
  writeln(max);

end.

```


---

## 作者：GEM_IU_077 (赞：16)

###石子合并pascal版本！！！###

贪心**明显不行**：每次找两个合并代价最小的堆合并？那我们来举一个例子？

**8 4 6 3 5**

贪心的结果为62，而最优解为60。

那么如何动规呢？

**其实这是一道典型的环状线性dp**（注：**∈为包含**）

我们假设**f[l,r]**表示从第l堆合并到第r堆的最优方案，对于每一个**f[l,r]**，我们枚举每一个**k∈[l+1..r]**来比较，通过**f[l,k-1]**和**f[k,r]**合并到**f[l,r]**所产生的答案从而得出**f[l,r]**的最优解，最后的答案即为###**max/min(f[i,i+n-1]) (i∈[1..n])**

###不要忘了处理环###

下附代码：

'''pas
```cpp
var
  f,f1,q:array[0..201,0..201] of longint;
  a,sum:array[0..201] of longint;
  i,j,k,n,p,min,max,x:longint;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  a[0]:=a[n];
  for i:=1 to 2*n do sum[i]:=sum[i-1]+a[i mod n];
  for i:=1 to 2*n do q[i,i]:=i;
  for p:=1 to n-1 do
    for i:=1 to 2*n-p do
      begin
        j:=i+p;
        x:=sum[j]-sum[i-1];
        f[i,j]:=maxlongint;
        f1[i,j]:=-maxlongint;
        for k:=q[i,j-1] to q[i+1,j] do
```
if f[i,j]>f[i,k]+f[k+1,j]+x
```cpp
          then
            begin
              f[i,j]:=f[i,k]+f[k+1,j]+x;
              q[i,j]:=k;
            end;
        if f1[i+1,j]<f1[i,j-1]
          then
            f1[i,j]:=f1[i,j-1]+x
          else
            f1[i,j]:=f1[i+1,j]+x;
      end;
  min:=maxlongint;
  for i:=1 to n do
   if f[i,n+i-1]<min then min:=f[i,n+i-1];
  writeln(min);
  max:=-maxlongint;
  for i:=1 to n do
    if f1[i,n+i-1]>max then max:=f1[i,n+i-1];
  writeln(max);
end.
```
```cpp

---

## 作者：hfee (赞：15)

### 前置知识：基础dp

题解里各路神仙什么四边形不等式啊完全不会，但还是试图解释一下正常解法

题目就不复述了，看到这题肯定首先想到贪心，即每次取相邻中最小（大）的合并

#### ~~绿题怎么可能这么简单所以肯定是错的~~

这里借用[大源菌](https://www.luogu.org/space/show?uid=78709)的一张图~~懒得自己找了qwq~~

![](https://cdn.luogu.com.cn/upload/pic/63467.png)

好的，那么我们否决了贪心的解法

那怎么做呢？

# 区间DP

进入正题

设$f[i][j]$表示石子中合并$i$到$j$号石子的最小（大）值

每一堆肯定是由两堆合并而成的，而这两堆可能是哪些呢？

以上面的图片中的数据为例

合并到最后两堆只能是
```
3 与 4，6，5，4，2的和

3，4的和 与 6，5，4，2的和

3，4，6的和 与 5，4，2的和

......
```
可以发现，中间有一个断点，我们可以枚举这个断点，再在两端的和中取最小（大）值

于是我们就得到了这个公式

$f[i][j] =min(f[i][j],f[i][k]+f[k+1][j]+sum[i][j])$

$(max)$

其中，$k$是断点的位置，$sum$则是开始的数组中i到j的和

于是就可以得到第一份代码

```
#include<bits/stdc++.h>
using namespace std;
int n,a[105],f[105][105],f2[105][105],sum[105][105];
int main(){
	cin>>n;
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=i;k<=j;k++){
				sum[i][j]+=a[k];
			}
		}
	}//sum[i][j]存的是a[i]到a[j]的和
	for(int i=1;i<=n;i++) f[i][i]=f2[i][i]=0;//只有一堆就是0
	for(int l=1;l<=n;l++){ //l是长度
		for(int i=1;i<=n-l+1;i++){ 
			int j=i+l-1;//i是左端点，j是右端点
			for(int k=i;k<j;k++){//k是断点
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[i][j]);
				f2[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+sum[i][j]);
			}
		}
	}
	cout<<f[1][n]<<endl<<f2[1][n];//1到n中的最小（大）值
	return 0;
}
```
### 然而这题是一个环，所以这肯定不对

那么如何解决呢？

我们可以在输入时加上这句话

```
for(int i=1;i<=n;i++){
	cin>>a[i];
	a[i+n]=a[i];
}
```
这样，我们的答案就变成了

$f[1][n],f[2][n+1],f[3][n+2] ...... f[n][n+n-1]$中的最小（大）值

然后呢，计算和的时候和枚举左右端点的时候的边界都要改成2*n

愉快地解决了

# CODE:

```
#include<bits/stdc++.h>
#define inf INT_MAX 
using namespace std;
int n,a[205],f[205][205],f2[205][205],sum[205][205],ans1=inf,ans2=-inf;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(int i=1;i<=n*2;i++){
		for(int j=1;j<=n*2;j++){//要枚举到2*n
			for(int k=i;k<=j;k++){
				sum[i][j]+=a[k];
			}
		}
	}
	for(int i=1;i<=n;i++) f[i][i]=f2[i][i]=0;
	for(int l=1;l<n;l++){
		for(int i=1,j=i+l;i<n*2&&j<n*2;i++,j=i+l){
        //依旧是左端点和右端点，但是上限变成了2*n
			f[i][j]=inf; 
			for(int k=i;k<j;k++){
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[i][j]);
				f2[i][j]=max(f2[i][j],f2[i][k]+f2[k+1][j]+sum[i][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans1=min(ans1,f[i][i+n-1]);
		ans2=max(ans2,f2[i][i+n-1]);
	}//取所有中的最小值和最大值
	cout<<ans1<<endl<<ans2;
	return 0w0;//卖个萌求过
}

```



---

## 作者：一念之间 (赞：11)

典型的动归（合并果果）！！！！我比较辣鸡，不会写高科技，

简单的凑合：f1[i][j]表示从i到j的最小值，f2[i][j]表示最大值

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{  int n,a[205],w1,w2,s[205][205];//注意2*n应该开205，我被坑了
    int f1[205][205],f2[205][205];
    int ans1=100000,ans2=0;
    memset(f1,0x3f,sizeof(f1));
    memset(f2,0,sizeof(f2));//初始化
    cin>>n;
    for(int i=1;i<=n;i++)
    {cin>>a[i];
    a[i+n]=a[i];
    f1[i][i]=0;f2[i][i]=0;
    }
    for(int i=1;i<=2*n;i++)
    {f1[i][i]=0;
    for(int j=1;j<=i;j++)
    if(i==j) s[i][j]=a[i];
    else s[j][i]=s[j][i-1]+a[i];//从i到j的和
    }
    for(int i=1;i<=n-1;i++)
    for(int j=1;j<=2*n-i;j++)
    for(int k=j;k<j+i;k++)
    {
        w1=f1[j][k]+f1[k+1][j+i]+s[j][i+j];
        w2=f2[j][k]+f2[k+1][j+i]+s[j][i+j];
        if(w1<f1[j][j+i]) f1[j][j+i]=w1;
        if(w2>f2[j][i+j]) f2[j][i+j]=w2;//更新 
    }
    for(int i=1;i<=n;i++)
    { 
        if(f1[i][i+n-1]<ans1) 
        ans1=f1[i][i+n-1];
        if(f2[i][i+n-1]>ans2) ans2=f2[i][i+n-1];
    }
   printf("%d\n%d\n",ans1,ans2);
}
```

---

## 作者：Continue (赞：7)

//典型的环形动态规划，实质上和线型的石子合并无太大区别

//只是环形可以从任意两堆石子处分开，我的处理方案是将序列扩充一倍




```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int INF=0x7fffffff;
const int maxn=200+10;
int w[maxn],dp1[maxn][maxn],dp2[maxn][maxn];
//w[i]表示从第一堆到第i堆石子之和(前缀和)，则w[i]-w[j-1]表示从第j~i堆石子之和，方便状态转移 
//dp[i][j]存放的是从i~j的最值，1为最小值，2为最大值 
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&w[i]),w[i+n]=w[i];
    for(int i=1;i<n*2;i++) w[i]+=w[i-1];//预处理前缀和 
    for(int x=2;x<=n;x++)//最外层循环枚举区间长度，因为dp[i][j]={dp[i][k]+dp[k+1][r]+w[r]-w[l-1]}，转移的时候需要用到比当前区间小的区间 
        for(int l=1;l+x-1<n*2;l++) {
            int r=l+x-1;
            dp1[l][r]=INF;dp2[l][r]=-INF;
            for(int k=l;k<r;k++)
                dp1[l][r]=min(dp1[l][r],dp1[l][k]+dp1[k+1][r]+w[r]-w[l-1]),
                dp2[l][r]=max(dp2[l][r],dp2[l][k]+dp2[k+1][r]+w[r]-w[l-1]);
        }
    int ans1=INF,ans2=-INF;
    for(int i=1;i<=n;i++) ans1=min(ans1,dp1[i][i+n-1]),ans2=max(ans2,dp2[i][i+n-1]);
    //因为是环形的，可从任意两堆间分开，所以需要枚举一遍起点从1~n 
    printf("%d\n%d",ans1,ans2);
    return 0;
}
```

---

## 作者：八重樱 (赞：7)

/\*
闲来无事把第一问优化到了N^2

还是DP,新状态转移方程:

dp[i][l]=max(dp[i][l-1],dp[i+1][l-1])+sum(i,i+l-1)

个人感觉第二问优化不了

以下是代码

变量名定义得很鬼畜别介意

\*/
```cpp
#include<cstdio>
using namespace std;
inline long long llin(){char c=getchar();while(c<48||c>57)c=getchar();long long a=0;while(c>47&&c<58){a=(a<<1)+(a<<3)+c-48;c=getchar();}return a;}
inline void llot(long long a){if(a<0){putchar(45);a*=(-1);}if(a>9)llot(a/10);putchar(a%10+48);}
```
long long
```cpp
    rbq[233][111],//最大 
    wyf[233][233],//最小 
    xcs=9999999999,gc=0,//答案 
    zyx[233],//原数组 
    czh[233];//前缀和 
int main()
{
    long long cs=llin();
    if(cs<3)//特判,然而没有也能AK 
    {    
        gc=llin();
        if(cs>1)gc+=llin();
        llot(gc);
        return 0;
    }
    czh[0]=0;
    for(int i=1;i<=cs;i++)//环拆为链,两倍大小 
    {
        zyx[i]=llin();
        zyx[i+cs]=zyx[i];
    }
    for(int i=1;i<=(cs<<1)-1;i++)//各种预处理 
    {
        czh[i]=czh[i-1]+zyx[i];
        wyf[i][i]=0;
        rbq[i][2]=zyx[i]+zyx[i+1];
        wyf[i][i+1]=rbq[i][2];
    }
    wyf[cs<<1][cs<<1]=0;
    czh[cs<<1]=czh[(cs<<1)-1]+zyx[cs<<1];
    for(int j=3;j<=cs;j++)for(int i=1;i<=(cs<<1)-j+1;i++)
    {
        int l=i+j-1,mn=999999999;
        long long mmp=czh[l]-czh[i-1];//区间和
        if(rbq[i][j-1]<rbq[i+1][j-1])rbq[i][j]=rbq[i+1][j-1];//重点就在这三行 
        else rbq[i][j]=rbq[i][j-1];
        rbq[i][j]+=mmp;
        for(int k=i;k<l;k++)//第二问的通俗算法 
        {
            long long cnm=wyf[i][k]+wyf[k+1][l]+mmp;
            if(mn>cnm)mn=cnm;
        }
        wyf[i][l]=mn;
    }
    for(int i=1;i<=cs;i++)
    {
        if(rbq[i][cs]>gc)gc=rbq[i][cs];
        if(wyf[i][i+cs-1]<xcs)xcs=wyf[i][i+cs-1];
    }
    llot(xcs);
    putchar('\n');
    llot(gc);
    return 0;
}
//NOIplaay>>AK
```

---

## 作者：包子入侵 (赞：6)

典型的区间dp枚举断点即可不过这是一个环所以要开两倍数组变成一条链 a[n+i]=a[i];

若想知道n^2的方法请私信

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
long long ans1=0,ans2=9999999,n,a[2000],dis[1000][1000],f[1000][1000],pre[1000];
//f[i][j] dis[i][j]表示i堆合并到j堆的最大最小花费，pre表示前缀和
int main()
{
scanf("%lld",&n);
    for ( int i=1; i <=n; i++) 
    {
    scanf("%lld",&a[i]);
    a[i+n]=a[i];//把环断成链
}
for (int i=1;i<=2*n;++i)
pre[i]=pre[i-1]+a[i];//先预处理好前缀和
  for(int len=2;len<=n;len++)//这里用了个小技巧枚举区间长度而不是枚举起点和终点不然会报错
    for(int i=1;i<=2*n-len+1;i++)//枚举起点
    {
        int j=i+len-1;//终点就为起点+长度-1
         f[i][j]=99999,dis[i][j]=0;
        for(int k=i;k<j;k++)//枚举断点
            {
                f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+pre[j]-pre[i-1]);//断与不断相比较
                dis[i][j]=max(dis[i][j],dis[i][k]+dis[k+1][j]+pre[j]-pre[i-1]);
        }
    }
        for (int i=1;i<=n;++i)//要把长度为n的都比大小
        {
            ans1=max(ans1,dis[i][i+n-1]);
            ans2=min(ans2,f[i][i+n-1]);
        }
    printf("%lld\n%lld",ans2,ans1);
    return 0;
}
```

---

## 作者：junyaoren (赞：5)

可以用取余的方式利用上dp二维数组的左下一半来解决环的问题；
本来dp[i][j]只在 i <= j 时候有意义；
取余后，若是 i > j，就意味着实际上是绕了一圈过来的
例如：0 1 2 3 4
对于起点为3， 长度为4的区间，就是 3 - 4 - 0 - 1， 那么结果就放在dp[3][1] 中。


```java
import java.io.*;
import java.util.*;

class Main {
  public static void main(String[] args) {
    Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int n = in.nextInt();
    
    int[] a = new int[n];
    for (int i = 0; i < n; i++) {
      a[i] = in.nextInt();
    }

    int INF = (int) 1e9 + 7;

    int[][][] dp = new int[n][n][2];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        dp[i][j][1] = INF;
      }
    }

    for (int i = 0; i < n; i++) {
      dp[i][i][0] = dp[i][i][1] = 0;
    }

    int[] sum = new int[n];
    sum[0] = a[0];
    for (int i = 1; i < n; i++) {
      sum[i] = a[i] + sum[i - 1];
    }

    for (int len = 2; len <= n; len++) {
      for (int i = 0; i < n; i++) {
        int j = i + len - 1;
        int jj = j % n;
        for (int k = i; k < j; k++) {
          int kk = k % n;
          dp[i][jj][0] = Math.max(dp[i][jj][0], dp[i][kk][0] + dp[(kk + 1) % n][jj][0] + sum(i, jj, sum));
          dp[i][jj][1] = Math.min(dp[i][jj][1], dp[i][kk][1] + dp[(kk + 1) % n][jj][1] + sum(i, jj, sum));
        }
      }
    }

    int min = INF;
    int max = 0;

    for (int i = 0; i < n; i++) {
      min = Math.min(min, dp[i][(i + n - 1) % n][1]);
      max = Math.max(max, dp[i][(i + n - 1) % n][0]);
    }

    System.out.println(min);
    System.out.println(max);
  }

  static int sum(int i, int j, int[] sum) {
    if (i <= j) {return sum[j] - (i == 0 ? 0 : sum[i - 1]);}
    return (sum[sum.length - 1] - (i - 1 < j + 1 ? 0 : sum[i - 1] - sum[j]));
  }
}
```


---

## 作者：EarthGiao (赞：5)

## 【思路】
区间DP   

### 【核心思路】
又是围成一个圈     
所以处理方式很显然   
就是在原来的序列后面放一个和原来序列一样的序列就可以了   
这样2-n+1区间就是存在的   
而且是那1-n个数   
就是起点不同而已   
每次合并后的值等于原来合并的价值   
加上   
这次合并的石子数    
如果只用一个二维数组f[i][j]的话显然是没有办法保存的   
所以可以利用一个很优美的东西   
前缀和   
利用前缀和可以求出某个区间的石子数    
也就是可以知道每次石子合并可以新得到的值   
那么就可以只用f[i][j]来存i-j区间内   
合并石子的最值就好了   

### 【DP式】
DP方程式：    
 f1[i][j] = max(f1[i][j],f1[i][k] + f1[k + 1][j] + cost[i][j])   
 f2[i][j] = min(f2[i][j],f2[i][k] + f2[k + 1][j] + cost[i][j])   
（一个求区间最大值，一个求区间最小值）    
这个区间的最值就等于分成两个小区间合并起来之后的最值   

### 【最终结果】
最后结果    
自然是比较i-i + n - 1这个区间啦   
因为圈不同于一条线的就是可以任选起点    
所以要比较以每一个作为起点时的最值   
输出就好了     

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 206;
int f1[Max][Max];
int f2[Max][Max];
int a[Max];
int sum[Max];
int cost[Max][Max];
int main()
{
	int n;
	cin >> n;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i],a[i + n] = a[i];
	for(register int i = 1;i <= n * 2;++ i)
		sum[i] = sum[i - 1] + a[i];
	for(register int i = 1;i <= n * 2;++ i)
		for(register int j = i;j <= n * 2;++ j)
			cost[i][j] = sum[j] - sum[i - 1];
	for(register int len = 1;len <= n;++ len)
	{
		for(register int i = 1;i + len - 1 <= n * 2;++ i)
		{
			int j = i + len - 1;
			if(i != j)
			f2[i][j] = 999999999;
			for(register int k = i;k < j;++ k)
				f1[i][j] = max(f1[i][j],f1[i][k] + f1[k + 1][j] + cost[i][j]),
				f2[i][j] = min(f2[i][j],f2[i][k] + f2[k + 1][j] + cost[i][j]);
		}
	}
	int M = 0;
	int MM = 0x7fffffff;
	for(register int i = 1;i <= n;++ i)
		M = max(M,f1[i][i + n - 1]),
		MM = min(MM,f2[i][i + n - 1]);
	cout << MM << endl << M << endl;
	return 0;
}
```

---

## 作者：Dorbmon (赞：5)

因为我就是个渣渣，所以不会你们玩的那种DP。
我只会DFS“DP”记忆搜索。其实个人感觉差不多？？？
可能就是时间复杂度高那么一点点？？？
不过也过了。
```cpp
#include<bits/stdc++.h>
#define INF 1000000001
#define ll int
#define maxn 20002
using namespace std;
int a [500];
int f [1000][1000];
int fuck [1000][1000];
int sum [1000];
int fs(int l,int r) {
	if (l == r) {
		return 0;	//这里一定要写0 我之前脑抽调了半个小时才发现这里 日！！！！ 
	}
	if (f [l][r]) {
		return f[l][r];
	}
	//否则开始分 
	//枚举k
	int res = 0;
	for (int k = l;k + 1 <= r;k ++) {
		res = max (res,fs(l,k) + fs(k + 1,r));
	} 
	res += sum [r] - sum[l - 1]; 
	return f[l][r] = res;
}
int fs2(int l,int r) {
	if (l == r) {
		return 0;	//这里一定要写0 我之前脑抽调了半个小时才发现这里 日！！！！ 
	}
	if (f [l][r]) {
		return f[l][r];
	}
	//否则开始分 
	//枚举k
	int res = INF;
	for (int k = l;k + 1 <= r;k ++) {
		res = min (res,fs2(l,k) + fs2(k + 1,r));
	} 
	res += sum [r] - sum[l - 1]; 
	//cout << "f[" << l << "][" << r << "]=" << res << endl; 
	return f[l][r] = res;
}
int main() {
	int n;
	//memset (fuck,INF,sizeof(fuck));
	cin >> n; 
	for (int i = 1;i <= n;i ++) {
		cin >> a[i];
		a [i + n] = a [i];
	}
	for (int i = 1;i <= 2 * n;i ++) {
		sum [i] = sum [i - 1] + a[i];
		//cout << "sum[" << i << "]=" << sum[i] << endl; 
	} 
	int maxl = 0;
	for (int i = 1;i <= n;i ++) {
		maxl = max(maxl,fs (i,i + n - 1));
	}
	
	int minl = INF;
	memset (f,0,sizeof(f));
	for (int i = 1;i <= n;i ++) {
		minl = min(minl,fs2 (i,i + n - 1));
	}
	cout << minl << endl;
	cout << maxl << endl;
	return 0; 
}
```
要注意，如果r == l那么就一定要返回0，千万不能再返回一次石头的数量，否则会重复合并！！！！！注意这个坑，我在这里卡了半个小时（也可能我太菜了看不懂你们的DP
用时还是很短的（因为数据范围小
勉强够用吧。

---

## 作者：noionion (赞：4)

## 都好像没人用区间长度枚举的 
那我发一篇~~（本人的第一篇题解）~~吧

~~（**大佬轻喷**）~~

**《信息学奥赛一本通--提高篇》**给了一个非常优秀的O(8n3)的代码

~~作为**蒟蒻**我表示**看不懂**~~

**~~难受~~**

不过没关系

**蒟蒻有蒟蒻的dp方法**

淡定地枚举了区间长度,然后一层一层增加

一段一段地维护**~~（不懂的可以手动看代码模拟）~~**

然后，默默地祭出了O(2n3)的代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
int a[201],sum[201];
int Fmin[201][201],Fmax[201][201];
inline int read()//读入优化大法好！！！
{
	int res=0;
	char ch=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();
	return res;
}
int main()
{
	int n=read();
    //把环拉成一条2*n的线
	for(int i=1;i<=n;++i)a[i]=a[i+n]=read();
	for(int i=1;i<=2*n;++i)sum[i]=sum[i-1]+a[i];
	memset(Fmin,127/3,sizeof(Fmin));//取最小值需要一点放大的初值
	for(int i=1;i<=2*n;++i)Fmin[i][i]=0;//这个不改会炸的！！！
	for(int l=1;l<n;++l)//枚举区间长度1到n-1
		for(int i=1;i+l<=2*n;++i)//枚举左端点
			for(int k=i;k<i+l;++k)//这个就不用解释了吧~~~
			{
				Fmin[i][i+l]=min(Fmin[i][i+l],Fmin[i][k]+Fmin[k+1][i+l]+sum[i+l]-sum[i-1]);
				Fmax[i][i+l]=max(Fmax[i][i+l],Fmax[i][k]+Fmax[k+1][i+l]+sum[i+l]-sum[i-1]);
			}
	int ansmin=923917391,ansmax=0;
    //然后开个O(2n)求最终答案（因为把环拉成链了）
	for(int i=1;i<n;++i)ansmin=min(ansmin,Fmin[i][i+n-1]);
	for(int i=1;i<n;++i)ansmax=max(ansmax,Fmax[i][i+n-1]);
	printf("%d\n",ansmin);
	printf("%d\n",ansmax);
	return 0;
}
```
~~然后，常数其实也没有2那么大啦~~~时间复杂度具体怎么算我也不知道

~~估计一下时间复杂度差不多只有O(n3)~~

---

## 作者：Divinitist (赞：4)

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[201],f1[201][201],f2[201][201],w[201];//f1最小值，f2最大值，w前缀和
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        a[n+i]=a[i];//断环为链
    }
    for(int i=1;i<=2*n;i++)//前缀和预处理
    w[i]=w[i-1]+a[i];
    for(int len=2;len<=n;len++)
    for(int i=1;i<=2*n-len+1;i++)//i是合并段开头
    {
        int mn=0x7fffffff,mx=0,j=i+len-1;//j是合并段结尾
        for(int k=i;k<j;k++)
        {
            mn=min(mn,f1[i][k]+f1[k+1][j]+w[j]-w[i-1]);//把i~j从k切成两段，把两段总代价与此次合并代价相加，下同
            mx=max(mx,f2[i][k]+f2[k+1][j]+w[j]-w[i-1]);
        }
        f1[i][j]=mn;f2[i][j]=mx;
    }
    int mx=0,mn=1e+9;
    for(int i=1;i<=n;i++)//由于是环状，所以需要搜索所有可能满足条件的长度为n的段
    {
        mx=max(mx,f2[i][i+n-1]);
        mn=min(mn,f1[i][i+n-1]);
    }
    printf("%d\n%d",mn,mx);
    return 0;
}
```

---

## 作者：rentenglong (赞：4)

这个题算是基础的区间DP了。

主要是注意以下几个问题：

- DP数组的含义以及使用

- 状态转移方程的列出

- 原题是环，因此要注意对于环所具有的特殊性质进行处理。

- 不必要每次运算都清空DP数组，只在第一次时初始化就行了。


—————————————————————我是分割の线线———————————————————————




 




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define INF 99999999
int a[205],sum[205];//sum[i]:数组a[1]到a[i]的总和。 
int maxdp[205][205],mindp[205][205],n;//dp[i][j]:区间的左端=i，右端=j时的得分最值（max、min）。
int sumfrom(int i,int j)//计算a[i]+a[i+1]+a[i+2]+...+a[j]。 
{
    return sum[j]-sum[i-1];
} 
int maxDP(int i,int j)//计算最大值的DP 
{
    if(i==j) return maxdp[i][j]=0;//为什么是=0？因为i=j无法进行累加，因此并不是a[i]或a[j] 
    if(maxdp[i][j]) return maxdp[i][j];    //调用记忆 
    int nmax=-INF;//一个初始值，记录最大值。 
    for(int k=i;k<j;k++)
    {
        //核心。将区间[i,j]分成[i,k]和(k,j]两个部分，即先将k左侧的合并，再合并k右侧的。 
        nmax=max(nmax,sumfrom(i,j)+maxDP(i,k)+maxDP(k+1,j));
    }
    return maxdp[i][j]=nmax;//同时调用记忆化。 
}
int minDP(int i,int j)//计算最小值的DP，与最大值基本相同。 
{
    if(i==j) return mindp[i][j]=0;
    if(mindp[i][j]!=INF) return mindp[i][j];
    int nmin=INF;
    for(int k=i;k<j;k++)
    {
        //min(1->k,k+1->n)
        nmin=min(nmin,sumfrom(i,j)+minDP(i,k)+minDP(k+1,j));
    }
    return mindp[i][j]=nmin;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) a[i+n]=a[i];
    sum[1]=a[1];
    for(int k=1;k<=n*2;k++) for(int j=1;j<=n*2;j++) {mindp[k][j]=INF;maxdp[k][j]=0;}
    for(int i=2;i<=2*n;i++) sum[i]=sum[i-1]+a[i];
    int nmax=-INF,nmin=INF;
    for(int i=1;i<=n;i++)//因为是环，所以必须要考虑DP区间的左端点位于数组中不同位置的情况。 
    {    
        //这里不用每次重置两个DP数组，因为每个区间合并的最小值是不变的，只是如何调用的问题。 
        nmax=max(nmax,maxDP(i,i+n-1));
        nmin=min(nmin,minDP(i,i+n-1));
    }
    printf("%d\n%d",nmin,nmax);
    return 0;
}
```
—————————————————————我又是分割の线线———————————————————————

感谢读完我的题解（qwq）希望我的题解能够对你有帮助。


---

## 作者：loucasIII (赞：4)

//无论你是不是copy，你最起码先思考，并最终弄懂这题动态规划。这样才对得起你自己，你对信息学投入的精力和时间。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>                 //个人习惯，开很多库，以防要用，其实好像只需要头两个。 
#define ll long long                //防止答案过大溢出报错，用Long Long超长整型记录数据。 
#define LONGINF 0x7fffffffffffffff   //0x是十六进制的标志，紧接其后的是一个十六进制数。 
using namespace std;
ll a[210],f1[210][210],f2[210][210],s[210];//f1->minans;f2->maxans; 
//f1[i][j]或f2[i][j]是用来记录(i,j)区间石子合并的最优解（最小或最大）的。 
ll maxof (ll a,ll b)    //个人习惯，这样主要代码区看得简洁明了。但是注意返回值的类型也要是超长整型。 
{
    if (a>b) return a;
    return b;
}
ll minof (ll a,ll b) 
{
    if (a<b) return a;
    return b;
}
int main()
{
    int n;
    cin>>n;
    for (int i=1;i<=n;i++)     //*本题最大难点（个人认为）在于化“圈”为“线”。 
    {                          //即使本题N<=100，可能数据有点弱，但想到了该方法总比暴力枚举N种情况要强得多。 
        cin>>a[i];               //因为信息学不仅仅是暴力算法，还有人的思维与计算机的协作。 
        a[i+n]=a[i];
    }
    s[0]=0;
    for (int i=1;i<2*n;i++)    //Sn=a1+a2+..+an 省得后面要重复求很多次连续部分和。 
         s[i]=s[i-1]+a[i];
    for(int k=1;k<n;k++)       //最外层枚举合并的次数，最多n-1次。 
        for(int i=1;i<2*n-k;i++)  //i<2*n-k 只是为了省点if条件代码 
        {
            f1[i][i+k]=LONGINF; //This is very important!!! Otherwise, the answer will be wrong.
            f2[i][i+k]=0; 
            for (int j=i;j<i+k;j++)   //枚举合并成(i,i+k)的所有情况
            {
                f1[i][i+k]=minof(f1[i][i+k],f1[i][j]+f1[j+1][i+k]);
                f2[i][i+k]=maxof(f2[i][i+k],f2[i][j]+f2[j+1][i+k]);
            }
            f1[i][i+k]+=(s[i+k]-s[i-1]);   //最后不忘加上“得分”。 
            f2[i][i+k]+=(s[i+k]-s[i-1]);
        }
    ll ans1=f1[1][n],ans2=f2[1][n];     //找答案，注意输出的要求！！！ 
    for (int i=2;i<=n;i++)
    {
        ans1=minof(ans1,f1[i][i+n-1]);
        ans2=maxof(ans2,f2[i][i+n-1]);
    }
    printf("%lld\n%lld\n",ans1,ans2);
    return 0;
}
```

---

## 作者：Thinking (赞：4)

此题其实可以不用断环为链。（为了这个爆零TAT）

下面贴良心AC代码：

```pascal
var
  a:array[1..100] of longint;
  f,w:array[1..100,1..100] of longint;
  n,i,j,k,x,s:longint;
  //a数组存储原重量，w[i，j]表示从i开始的j堆的总重量，f[i，j]表示从i开始合并j堆的最小（最大）得分
function max(a,b:longint):longint;
  begin
    if a>b then exit(a)
    else exit(b)
  end;
function min(a,b:longint):longint;
  begin
    if a<b then exit(a)
    else exit(b)
  end;
  //max，min函数（自己动手丰衣足食）
begin
  readln(n);
  for i:=1 to n do read(a[i]);  //读入
  for i:=1 to n do begin
    w[i,1]:=a[i];
    for j:=2 to n do w[i,j]:=w[i,j-1]+a[(i+j-2) mod n+1]  //w数组初始化
  end;
  fillchar(f,sizeof(f),0);
  for j:=2 to n do
    for i:=1 to n do begin
      f[i,j]:=maxlongint;
      for k:=1 to j-1 do begin
        x:=(i+k-1) mod n+1;
        f[i,j]:=min(f[i,j],f[i,k]+f[x,j-k]+w[i,j])  //计算最小值（状态转移方程楼下许多大神已经讲过了，我就不讲了，自己理解）
      end;
    end;
  s:=maxlongint;
  for i:=1 to n do s:=min(s,f[i,n]);
  writeln(s);  //输出最小值
  fillchar(f,sizeof(f),0);
  for j:=2 to n do
    for i:=1 to n do begin
      f[i,j]:=-maxlongint;
      for k:=1 to j-1 do begin
        x:=(i+k-1) mod n+1;
        f[i,j]:=max(f[i,j],f[i,k]+f[x,j-k]+w[i,j])  //计算最大值（原理同上）
      end;
    end;
  s:=-maxlongint;
  for i:=1 to n do s:=max(s,f[i,n]);
  write(s)  //输出最大值
end.
```
谢绝Ctrl+c，营造美好洛谷！


---

## 作者：化学小哥 (赞：3)

典形的环形动归……

数据处理上要注意环！！的问题；


```cpp
program shizihebing;
var i,j,n,k,s,min1,max1,x:longint;
    a:array[1..100]of longint;
    sum,fmin,fmax:array[1..100,1..100]of longint;
function min(a,b:longint):longint;
begin
 if a>b then exit(b) else exit(a);
end;
function max(a,b:longint):longint;
begin
 if a<b then exit(b) else exit(a);
end;
begin
 read(n);
 for i:=1 to n do
  begin read(a[i]);sum[i,1]:=a[i];fmin[i,1]:=0;fmax[i,1]:=0;end;
 for j:=2 to n do
  for i:=1 to n do
   begin fmin[i,j]:=maxlongint;
         sum[i,j]:=a[i]+sum[i mod n +1,j-1];（i mod n + 1：避免环的干扰……）
   end;
 for j:=2 to n do
  for i:=1 to n do
   for k:=1 to j-1 do
    begin
     x:=(i+k-1) mod n +1;（！！注意，不能是 i+k mod n ！ 可能会是零）
     fmin[i,j]:=min(fmin[i,j],fmin[i,k]+fmin[x,j-k]+sum[i,j]);
     fmax[i,j]:=max(fmax[i,j],fmax[i,k]+fmax[x,j-k]+sum[i,j]);
    end;
 min1:=maxlongint;
 for i:=1 to n do
  begin min1:=min(min1,fmin[i,n]);
        max1:=max(max1,fmax[i,n]);
  end;
 writeln(min1);
 writeln(max1);
end.
```

---

## 作者：凯特琳 (赞：3)

首先提醒一下：有位叫难上加兰的他给出的题解是错误的，思路并没有问题，问题在于本题是环形区间DP,而他处理成了线性区间DP，需要加上一个改进就OK，题目说的明白：圆形操场嘛。还有小鄙视一下审核题解的负责人，是真的审核过么。提交他的代码会爆0啊，不信自己试试，要是以后改了的话，另当别论



题目描述 Description

在一个园形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.

输入输出格式 Input/output

输入格式：

数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.

输出格式：

输出共2行,第1行为最小得分,第2行为最大得分.

输入输出样例 Sample input/output

样例测试点#1

输入样例：

4
4 5 9 4

输出样例：

43
54



首先注意本题说的是圆形的操场上有N堆石子，所以是环形区间DP，如果交线性区间DP的话，爆零！数据还是可以的，一点水也没有

环形DP思路当然是开环，以编号为N的石子为中心，把左边的石子对称到右边去，前缀和什么的照写，完全没变化，

只是相当于搞了N次DP,分别是1..N;  2..N..1;  3..N..2;    ……N..1 .最后在从中找到最优解输出


代码：





```cpp
program exam1;
var a,sum:array[0..200]of longint;
var max,min:array[0..201,0..201]of longint;
var i,j,n,k:longint;
var ans:longint;
function da(aa,bb:longint):longint;
begin
if aa>bb then exit(aa)
else exit(bb);
end;
function xiao(cc,dd:longint):longint;
begin
if cc<dd then exit(cc)
else exit(dd);
end;
begin
read(n);
for i:=1 to n do
begin
read(a[i]);
sum[i]:=sum[i-1]+a[i];
end;
for i:=n+1 to 2*n-1 do
sum[i]:=sum[i-1]+a[i mod n];
for k:=1 to n-1 do//k是区间右端点比左端点大多少
for i:=1 to 2*n-k-1 do//枚举区间左端点，区间右端点即为i+k
begin
max[i,i+k]:=-100000000;//初始化
min[i,i+k]:=100000000;//初始化
for j:=i to i+k-1 do//枚举中间点
begin
max[i,i+k]:=da(max[i,i+k],max[i,j]+max[j+1,i+k]);//找到如何选择石子的左右堆使得解最优
min[i,i+k]:=xiao(min[i,i+k],min[i,j]+min[j+1,i+k]);//同上
end;
max[i,i+k]:=max[i,i+k]+sum[i+k]-sum[i-1];//加上本次得分
min[i,i+k]:=min[i,i+k]+sum[i+k]-sum[i-1];//同上
end;
ans:=100000000;
for i:=1 to n do
ans:=xiao(ans,min[i,i+n-1]);
writeln(ans);//寻找最优的最小值
ans:=-100000000;
for i:=1 to n do
ans:=da(ans,max[i,i+n-1]);
writeln(ans);//寻找最优的最大值
end.

```

---

## 作者：盧鋅 (赞：2)

## 标准区间DP题
但是我要说一下一些注意的点（~~听取WA声一片后，总结教训）~~

1.这是个环！！！不是链！！！区别很大，但是还是要转成链的(假如不转成链，需要枚举断点时间复杂度就成O（N^4）了，~~然后你去常数优化？？？？~~，很明显是不能的)。

我们先假设共ABCDE5堆，显而易见断点会有4个（无论怎么合并，总有一个两个点之间的不进行合并，我们定义它为断点）。所以就成了这个样子。
```
ABCDE
BCDEA
CDEAB
DEABC
EABCD
```
然后把他们对齐

```
ABCDE
_BCDEA
__CDEAB
___DEABC
____EABCD
```
然后压一下

```
ABCDEABCD

```
又成了一个链，真好


------------
2.注意端点！！！（WA了多次）


假如枚举长度len从2到n，那么r=l+len-1（自己手模可知）

假如用前缀和去求区间长度，i到j的距离为sum[i]-sum[j-1]（自己手模可知）

假如枚举分割点k，而且状态转移方程为f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+sum[i]-sum[j-1];
那么k应该从l到r-1取值（依然手模可知）

假如枚举一下l的话，l的范围应该是1到2n，因为n+1到2n的区间也是需要求的。

最后一点，假如求解要枚举的话，还是要注意是f[i][i+n-1]不是f[i][i+n];

这是一个蒟蒻血的教训，dalao请忽视


------------
3.注意一下赋值的问题，
最大值更新前赋值0，最小值赋值0x7fffffff；
然后假如最大值使用DP求的话,数组还是memset一下比较好，最小值数组memset（f，0x3f，sizeof（f））；


------------
最后还是放下AC的代码吧
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cctype>
#define maxn 200
using namespace std;
inline int read(){
	int x=0;bool y=0;char ch;
	while(!isdigit(ch)){
		if(ch=='-')y=1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return y?-x:x;
} 
signed main(){
	int a[maxn<<1],sum[maxn<<1];int n;
	int f1[maxn<<1][maxn<<1],f2[maxn<<1][maxn<<1];
	cin>>n;
	for(int i=1;i<=n;i++){
		a[i]=read();a[i+n]=a[i];}
//	memset(f1,0,sizeof(f1));
	memset(f2,0x3f,sizeof(f2));
	sum[0]=0;
	for(int i=1;i<=2*n;i++){
		f1[i][i]=0;
		f2[i][i]=0;
		sum[i]=sum[i-1]+a[i];
	}
	for(int len=2;len<=n;len++){
		for(int l=1;l<=2*n;l++){
			int r=l+len-1;
			if(r>2*n)continue;
			f1[l][r]=0;
			f2[l][r]=100000000;
			for(int k=l;k<r;k++){
				int suma=sum[r]-sum[l-1];
				f1[l][r]=max(f1[l][k]+f1[k+1][r]+suma,f1[l][r]);
				f2[l][r]=min(f2[l][k]+f2[k+1][r]+suma,f2[l][r]);
			}
		}
	}
	int MAX=0,MIN=0x7fffffff;
	for(int i=1;i<=n;i++)
	{
		MAX=max(MAX,f1[i][i+n-1]);
		MIN=min(MIN,f2[i][i+n-1]);
	}
	printf("%d\n",MIN);
	printf("%d\n",MAX);
	return 0;
}
```
### 最后说一句，DP要练，狠狠地练，练多了就习惯了。

---

## 作者：mc205610760 (赞：2)

基础的区间dp。。石子合并的强行升级版。。思路就是将一圈石子看成一个序列上的石子，序列为[1,2\*n]，至于为什么要这么做，画画图看看。。会发现选择长度为1～n的区间后就是一种选法，那么思路出来了：枚举左端点，计算长度为n的区间的最优汁，于是就可以了。


/\*
题目描述

    
在一个园形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.

规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

    
试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.

    
输入输出格式

    
输入格式：

数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.

    
输出格式：

输出共2行,第1行为最小得分,第2行为最大得分.

\*/
    
    
    
    
    
    
```cpp
    #include <iostream>
    #include <algorithm>
    #include <cstdio>
    #include <cstring>
    #include <cstdlib>
    using namespace std;
    int n;
    int a[300];
    int dp[300][300];
    int vis[300][300];
    int dp2[300][300];
    int vis2[300][300];
    int f(int i,int j){
        if(vis[i][j])return dp[i][j];
        if(i==j)return 0;
        vis[i][j]=1;
        dp[i][j]=0x3f3f3f3f;
        for(int k=i;k<j;k++){
            dp[i][j]=min(dp[i][j],f(i,k)+f(k+1,j)+a[j]-a[i-1]);
        }
        return dp[i][j];
    }
    int f2(int i,int j){
        if(vis2[i][j])return dp2[i][j];
        if(i==j)return 0;
        vis2[i][j]=1;
        dp2[i][j]=-0x3f3f3f3f;
        for(int k=i;k<j;k++){
            dp2[i][j]=max(dp2[i][j],f2(i,k)+f2(k+1,j)+a[j]-a[i-1]);
        }
        return dp2[i][j];
    }
    int main(){
        ios::sync_with_stdio(false);
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>a[i];
            a[i+n]=a[i];
        }
        for(int i=1;i<=2*n;i++)a[i]+=a[i-1];
        int ans1=0x3f3f3f3f;
        int ans2=-0x3f3f3f3f;
        for(int i=1;i+n-1<=2*n;i++)ans1=min(ans1,f(i,i+n-1)),ans2=max(ans2,f2(i,i+n-1));
        cout<<ans1<<endl<<ans2;
    }

```

---

## 作者：天狗的手帖 (赞：2)

线性DP中环状结构的经典问题。


通常处理环的方式就是在结束处复制和原来一样的数据使n的数列转化为2n的数列，合并石子的问题用动态规划解决，我们用f[l,r]表示从第l堆合并到第r堆的最小（大）方案，对于每一个f[l,r]，我们枚举每一个k∈[l+1..r]来比较通过f[l,k-1]和f[k,r]合并到f[l,r]所产生的答案从而得出f[l,r]的最优解，最后的答案即为max/min(f[i,i+n-1]) (i∈[1..n])


PASCAL代码


```delphi

    var n,i,j,k,ans:longint;  
        a:array[1..200] of longint;  
        b,f:array[1..200,1..200] of longint;  
      
    function min(a,b:longint):longint;  
      
    begin  
      
            if a<b then exit(a)  
      
                   else exit(b);  
      
    end;  
      
    function max(a,b:longint):longint;  
      
    begin  
      
            if a>b then exit(a)  
      
                   else exit(b);  
      
    end;  
      
    begin  
      
            readln(n);  
      
      
            for i:=1 to n do read(a[i]);  
      
            for i:=1 to n do a[i+n]:=a[i];  
      
            for i:=1 to n*2 do  
      
                for j:=1 to n*2 do  
      
                    for k:=i to j do b[i,j]:=b[i,j]+a[k];  
      
            fillchar(f,sizeof(f),63);  
      
            for i:=1 to 2*n do f[i,i]:=0;  
      
            for i:=2 to n do  
      
                for j:=1 to n*2-i+1 do  
      
                    for k:=j+1 to j+i-1 do  
      
                    f[j,j+i-1]:=min(f[j,j+i-1],f[j,k-1]+f[k,j+i-1]+b[j,j+i-1]);  
      
            ans:=maxlongint;  
      
            for i:=1 to n do ans:=min(ans,f[i,i+n-1]);  
      
            writeln(ans);  
      
            fillchar(f,sizeof(f),0);  
      
            for i:=2 to n do  
      
                for j:=1 to n*2-i+1 do  
      
                    for k:=j+1 to j+i-1 do  
      
                    f[j,j+i-1]:=max(f[j,j+i-1],f[j,k-1]+f[k,j+i-1]+b[j,j+i-1]);  
      
            ans:=0;  
      
            for i:=1 to n do ans:=max(ans,f[i,i+n-1]);  
      
            writeln(ans);  
      
    end.  

```

---

## 作者：CoolTeam (赞：2)

更详细的建议去看ACdreamer的博客http://blog.csdn.net/acdreamers/article/details/18039073

，我这里顺带总结下。

石子合并问题有三种，一是贪心(可移动任意石子)，二是直线上的石子合并，三是圆环上的石子合并。

如果是直线的问题的话，状态可以设为D(i,j)：第i到第j堆石子合并的最值得分。通过枚举i,j的中点k来得到所有决策并找到最优决策。【如果要进一步优化，求最大值时找最优决策中点k只有i或j-1两种可能；求最小值时可以用四边形不等式优化】

但圆环的问题不太一样，最优解中可能会将数组中头尾两个石子合并。于是可以引入求模(所以用数组要从0开始)，并且状态的意义变为：D(i,j)：以第i堆为起点，共j+1堆石子合并的最值得分。事实上(i+j+1)mod n就是最后一堆，所以DP方程跟直线上的问题基本一样了(只是求和会麻烦些，取中点k也麻烦些等等……)。


---

## 作者：Thaumaturge (赞：2)

显然，对于每一堆已经合并了的石子的阶段性分数，我们都可以将其拆分为来自两个子堆的分数值+它们的石子总和，这就是题目给出的定义。

因为只能合并相邻的两堆石子，所以我们在拆分石子堆时，相当于对它所涵盖的最初的石子堆进行枚举，从这个堆开始将其分成两半，取最大或最小值。

于是有状态转移方程:
dp(i~j)=(min/max)(dp(i~k)+dp(k+1~j)+a[i]+...+a[j]);


dp(i,j)是第i～j堆石子全部合并后的最大的或最小的分数
k是拆分石子堆的分界点，
这对于最大值或最小值均成立。

但这是不够的，因为我们目前的算法只适用于队列形式的石子合并，而题目中要求的是环状的，再对从合并了队末与队头的石子堆进行特判将会十分复杂。

我们的思想还可以更解放——高中物理必修2

其实我们把区间的长度拓宽一倍，就完全可以解决这个问题。此时我们的目的状态就不再是dp[1][m]了，而是(max/min)(dp[i][i+m-1]),i属于[1,m]中的正整数,初始化前缀和时也将前缀和数组的长度拓宽一倍即可。

代码如下：
```cpp
#include <bits/stdc++.h>

using namespace std;
//防止爆炸，全开LL
long long MAXN=(1LL<<60);
long long MAXX,MINN=MAXN;
long long f[212][212],dp[212][212];
long long a[212],qz[212];
long long qj;
int m,i,j,k;

long long max0(long long xx,long long yy){
	return xx>yy?xx:yy;
}

long long min0(long long xx,long long yy){
	return xx<yy?xx:yy;
}

int main(){
	scanf("%d",&m);
	for(i=1;i<=210;i++)
		for(j=i;j<=210;j++)
		{
			dp[i][j]=MAXN;//因为计算的是最小值，所以初始化最小值时一定要赋值为无穷大
		}
	for(i=1;i<=m;i++)
	{
		scanf("%lld",&a[i]);
		qz[i]=a[i]+qz[i-1];//前缀和
		dp[i][i]=0;//对于区间[i,i],它并不需要合并,因此赋值为0
	}
	for(i=m+1;i<=2*m;i++)//拓宽范围
	{
		qz[i]=qz[i-1]+a[i-m];
		dp[i][i]=0;
	}

	for(i=1;i<=m-1;i++)//枚举区间长度，这样才能保证拆分区间前，所有长度比它小的区间都以被处理完毕了
	{
		for(j=1;j<=2*m-1;j++)//枚举区间左端
		{
			if(j+i>2*m) break;//直接跳出去，因为接下来的循环是无意义的了
			qj=qz[i+j]-qz[j-1];//减少计算次数
			for(k=j;k<i+j;k++)
			{
				f[j][i+j]=max0(f[j][i+j],f[j][k]+f[k+1][i+j]+qj);//转移方程
			}
		}
	}
	for(i=1;i<=m-1;i++)//这里同上
	{
		for(j=1;j<=2*m-1;j++)
		{
			if(i+j>2*m) break;
			qj=qz[i+j]-qz[j-1];
			for(k=j;k<i+j;k++)
			{
				dp[j][i+j]=min0(dp[j][i+j],dp[j][k]+dp[k+1][i+j]+qj);
			}
		}
	}
	for(i=1;i<=m;i++)//取最大值
	MAXX=max0(MAXX,f[i][i+m-1]);
	for(i=1;i<=m;i++)//取最小值
	MINN=min0(MINN,dp[i][i+m-1]);
	printf("%lld\n%lld",MINN,MAXX);//输出
	return 0;
}
```


---

## 作者：wushundi (赞：2)

典型的区间类动态规划题，当然要用迪屁喽！


这是一道区间dp十分经典的模板题，让我们揣测一下，前辈们是如何得到这个状态转移方程的。

首先，要计算合并的最大值、最小值，既然是动态规划，我们需要洞悉其中一些关联且确定的状态。

以下以最大值为例。

既然是最大值，那么求得的结果是否满足每一区间都是该区间所能达得到的的最大值？

显然是这样的。反证法：倘若有一个区间不是，那么换做该区间取得最大值的方案，最终结果将比原得分大。显然必定满足任意区间得分一定是该区间内的最大值。

这样我们可以定义状态f[i][j]，表示i到j合并后的最大得分。其中1<=i<=j<=N。

既然这样，我们就需要将这一圈石子分割。很显然，我们需要枚举一个k，来作为这一圈石子的分割线。

这样我们就能得到状态转移方程：

f[i][j] = max(f[i][k] + f[k+1][j] + d(i,j));其中，1<=i<=<=k<j<=N。

d(i,j)表示从i到j石子个数的和。

那么如何编写更快的递推来解决这个问题？

在考虑如何递推时，通常考虑如下几个方面：

是否能覆盖全部状态？

求解后面状态时是否保证前面状态已经确定？

是否修改了已经确定的状态？

也就是说，在考虑递推顺序时，务必参考动态规划的适应对象多具有的性质，具体参考《算法导论》相关或百度百科或wiki。

既然之前说过我们需要枚举k来划分i和j，那么如果通过枚举i和j进行状态转移，很显然某些k值时并不能保证已经确定过所需状态。

如，i=1 to 10,j=1 to 10,k=1 to 9.当i=1,j=5,k=3时，显然状态f[k+1][j]没有结果。

那么，我们是不是应该考虑枚举k？

但这样i和j就难以确定了。

我们不难得到一个两全的方法：枚举j-i，并在j-i中枚举k。这样，就能保证地推的正确。 By TIMI_k 

上代码[cpp] By myself
`````cpp
#include<iostream>
using namespace std;
const int maxn=205,MAX=0x7fffffff/2; //MAX：可以看做无穷大
int f1[maxn][maxn],f2[maxn][maxn],s[maxn][maxn]={0};
int a[maxn],sum[maxn]={0},n,i,ans1,ans2;
void init()
{
	cin>>n;
	for(i=1;i<=n;i++){cin>>a[i];a[i+n]=a[i];}
	for(i=1;i<=n*2;i++){sum[i]=sum[i-1]+a[i];f2[i][i]=0;f1[i][i]=0;}
}
void dp()
{
	int j,k,L,ans;
	for(L=2;L<=n;L++)	//以合并的堆数为阶段 
	  for(i=1;i<=2*n-L+1;i++) //合并的起始位置 
	  {
	  	j=i+L-1; //合并的结束位置 
	  	f1[i][j]=0x7fffffff/2;f2[i][j]=0;
	  	for(k=i;k<j;k++)
	  	{
	  	   f1[i][j]=min(f1[i][j],f1[i][k]+f1[k+1][j]);
	  	   f2[i][j]=max(f2[i][j],f2[i][k]+f2[k+1][j]);
		}
		f1[i][j]+=sum[j]-sum[i-1];
		f2[i][j]+=sum[j]-sum[i-1];
	  }
	  ans1=0x7fffffff/2,ans2=0;
	  for(i=1;i<=n;i++) ans1=min(ans1,f1[i][i+n-1]);
	  for(i=1;i<=n;i++) ans2=max(ans2,f2[i][i+n-1]);
}
int main()
{
	init();
	dp();
	cout<<ans1<<endl<<ans2<<endl;
	return 0; 
}

````cpp

```

---

## 作者：zhaoyifan (赞：2)

每次合并相邻的石子，用搜索比较耗时，想想dp可不可以。

合并后的石子不会产生后效性，那么假设有两堆已经是最优的石子堆，合并它们的代价就是其石子数之和，

合并出来的一定是最优解，而你的目标是将所有石子合并成一堆，但问题是不知道其中最优的两堆是如何划分的

那么引入k作为你目前合并成一堆的分割点，枚举k由左端点到右端点，找出最优解。

但是本题要求石子放在圆形操场，即首位相连。

想象一下你合并石子的过程。

没错，我们可以把环形从你需要的左端点切开，展成一个线性，问题就迎刃而解了。

但是你不知道从哪里切开，所以每一个点都试一试。代码不加注释。

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,a[201],f[201][201],sum[201];int minn=99999999;
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    cin>>a[i];
    for(int i=n+1;i<=2*n;++i)
    a[i]=a[i-n];
    memset(sum,0,sizeof(sum));
    for(int i=1;i<=n*2;++i)
    sum[i]=sum[i-1]+a[i];
    for(int i=1;i<=n*2;++i)
     {
        for(int j=1;j<=n*2;++j)
          f[i][j]=99999999;
          f[i][i]=0;
     }
     for(int i=n*2-1;i>=1;--i)
      for(int j=i+1;j<=n*2;++j)
       for(int k=i;k<=j;++k)
       f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]);
    for(int i=1;i<=n;++i)
    if(f[i][i+n-1]<minn) minn=f[i][i+n-1];
    cout<<minn<<endl;
    int maxx=0;
    for(int i=1;i<=n*2;++i)
     {
        for(int j=1;j<=n*2;++j)
          f[i][j]=-99999999;
          f[i][i]=0;
     }
    for(int i=n*2-1;i>=1;--i)
      for(int j=i+1;j<=n*2;++j)
       for(int k=i;k<j;++k)
       f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]);
       for(int i=1;i<=n;++i)
    if(f[i][i+n-1]>maxx) 
    maxx=f[i][i+n-1];
    cout<<maxx;
    return 0;
}

```

---

## 作者：汪文慧 (赞：2)

uses math;//pascal函数资料库，min()找较小的数，max()找较大的数



```cpp
var 
    a,s:array[0..202]of longint;//两倍空间，用来将环变成线
    f1,f2:array[0..202,0..202]of longint;//f1找最大，f2找最小
    l,i,j,k,n,max1,min1:longint;
begin
  readln(n);
  for i:=1 to n do
  begin
    read(a[i]);
    a[i+n]:=a[i];//将4 9 5 4 变为4 9 5 4 4 9 5 4
  end;
  //for i:=1 to 2*n do write(a[i],' ');writeln;//测试
  for i:=1 to 2*n do s[i]:=s[i-1]+a[i];//把前i堆石子全加起来，存放在s[i]里，备用
  //for i:=1 to 2*n do write(s[i],' ');writeln;//测试
  for l:=2 to n do//l表示区间长度，从两个两个的试，最后到n个n个的试
   for i:=1 to 2*n-l+1 do//i为起点
   begin
     j:=i+l-1;//j为终点
     f1[i,j]:=-maxlongint;f2[i,j]:=maxlongint;//初始化，f1定得特别小，f2定得特别大
     for k:=i to j-1 do//k在i和j之间游走，把区间分成两份
     begin
       f1[i,j]:=max(f1[i,j],f1[i,k]+f1[k+1,j]+s[j]-s[i-1]);//比较原f1[i,j]与f1[i,k]+f1[k+1,j]+s[j]-s[i-1]的大小，存比较大的。f数组存之前算好的得分，s[j]-s[i-1]可以得出本次得分
       f2[i,j]:=min(f2[i,j],f2[i,k]+f2[k+1,j]+s[j]-s[i-1]);//类似上一条
     end;
   end;
  max1:=-maxlongint;min1:=maxlongint;//初始化
  for i:=1 to n do
  begin
    max1:=max(max1,f1[i,i+n-1]);//4 9 5 4 的环，可以分为4 9 5 4，9 5 4 4，5 4 4 9，4 4 9 5，现在是寻找这四种情况那个最大
    min1:=min(min1,f2[i,i+n-1]);//类似上一条
  end;
  writeln(min1);
  writeln(max1);//看清顺序，输出
end.

```

---

## 作者：WilliamPen (赞：2)

这道题目初看比较没思路啊。毕竟是圆形，想了半天，后来类比线段类石子合并，突然灵光一闪啊。但最开始想枚举每次切断（为了让他变成线段问题）的位置，发现时间复杂度会变高，而且特别麻烦，程序冗长。后来大神点拨，我仔细一想，觉得把他变成2倍的等效的。于是就有了以下的代码。尤其注意处理前缀和，和状态转移方程的理解，会比较难

以下代码。注意理解，代码中有同步解释。

\_抄袭可耻，理解至上\_

```cpp
#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
using namespace std;
const int Maxn=1000+10;
int t[Maxn],dp1[Maxn][Maxn],dp2[Maxn][Maxn];//dp1存最大，dp2存最小 
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;++i) {
    cin>>t[i];
    t[i+n]=t[i];//扩成2倍的线段问题 
    }
    for(int i=2;i<=2*n;++i) t[i]+=t[i-1];//处理前缀和，为了下面从i到j合并的初始花费作准备 
    memset(dp1,0,sizeof(dp1));
    for(int i=2*n-1;i>=1;--i)//从倒数第二个开始就可以 
        for(int j=i+1;j<=2*n;++j)//动态规划基本格式，不多解释 
        {    int b=2147483647;//这个是为了处理min出问题的 
            for(int k=i;k<j;++k){
                dp1[i][j]=max(dp1[i][j],dp1[i][k]+dp1[k+1][j]+t[j]-t[i-1]);//动态转移方程是关键，从i到k，从k+1到j，算每次细分的花费，而最后的t[j]-t[i-1]算初始花费 
                b=min(b,dp2[i][k]+dp2[k+1][j]+t[j]-t[i-1]);//和max同理 
            }
            dp2[i][j]=b;//再把b存到数组，如果不这么做，可能会炸，我之前炸了很多次。 
        }        
    int max0=0,min0=10000000;
    for(int i=1;i<=n;++i){
        max0=max(max0,dp1[i][i+n-1]);//简单比较最大值 
        min0=min(min0,dp2[i][i+n-1]);
    }
    cout<<min0<<endl<<max0<<endl;
    return 0;
}
```

---

## 作者：zj余能 (赞：2)

怎么没人用

##记忆化搜索？

明明记搜很好写，而且比较好理解啊；

那我就来一发我最擅长的记搜！


###核心思路：

为了思路清晰，最大值和最小值我分开来写：

\*用dfs1(l,r)表示合并区间[l,r]中所有石子能得到的最小得分；

\*用dfs2(l,r)表示合并区间[l,r]中所有石子能得到的最大得分；


因为两个过程极相似，故只讲dfs1吧；

首先合并中一定存在区间[l,r]中一点i，使得dfs1(l,i)+dfs1(i+1,r)最大，

然后再将这两堆石子合并，从而获得dfs1(l,r)的值。因为合并过程中所得的

分数只是两堆石子的数量和（用前缀和可以轻松实现），是不变的，故此算法

的正确性显然。


但是由于题中要求是个环，目前我们的假定是区间，所以通过将区间[1,n]扩大到

[1,2\*n]，每次枚举1到n中一个为起点，长度为n不变，就能模拟环了；


具体看程序：







    

    


    
    
    
```cpp
#include <iostream>
using namespace std;
int n;
bool f1[300][300],f2[300][300];//记录是否搜到过解
int  d1[300][300],d2[300][300];//记录搜到过的解
int sum[500],a[500];           
int maxi(int p,int q)
{
    if (p<q) p=q;
    return p; 
}
int mini(int p,int q)
{
    if (p>q) p=q;
    return p;
}
int dfs1(int l,int r)                 //搜最小值
{
    if (l==r) return 0;           //如果只有一堆石子，自然没得分了
    if (f1[l][r]) return d1[l][r];//如果搜到过了，直接返回解
    d1[l][r]=100000000;
    f1[l][r]=true;
    int tt;
    for (int i=l;i<=r-1;++i)       //枚举i，并比出最小的一个
    {
        tt=dfs1(l,i)+dfs1(i+1,r)+sum[r]-sum[l-1];
        d1[l][r]=mini(d1[l][r],tt);
    }
    return d1[l][r];
}
int dfs2(int l,int r)                  //道理与上相似，程序也相似
{
    if (l==r) return 0;
    if (f2[l][r]) return d2[l][r];
    f2[l][r]=true;
    int tt;
    for (int i=l;i<=r-1;++i)
    {
        tt=dfs2(l,i)+dfs2(i+1,r)+sum[r]-sum[l-1];
        d2[l][r]=maxi(d2[l][r],tt);
    }
    return d2[l][r];
}
int main()
{
    cin >>n;
    for (int i=1;i<=n;++i)
    {    
        cin >>a[i];
        a[i+n]=a[i];        //扩展为两倍
    }
    for (int i=1;i<=n*2;++i)
        sum[i]=sum[i-1]+a[i];       //前缀和处理
    int mama=0,mimi=100000000;
    for (int i=1;i<=n;++i)          //模拟环
    {
        mimi=mini(mimi,dfs1(i,i+n-1));
        mama=maxi(mama,dfs2(i,i+n-1));
    }
    cout <<mimi<<endl
         <<mama<<endl;
    return 0;
}
```

---

## 作者：MRZMRZ (赞：1)

区间DP用记忆化搜索，思路代码也很清晰。

以下是我的代码，变量名含义已经很清楚了。

$ff[i][j]$即区间$[i..j]$的答案

求$ff[i][j]$只要枚举在那个数之间断开即可。

$sum$维护前缀和

环形只用把数组开到$2\times n$即可

时间复杂度为$O(n^3)$
``` cpp
//ZJ_MRZ's Code
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#define N 301
#define INF 100000000009
using namespace std;
long long ffmax[N][N],ffmin[N][N],a[N],sum[N],n;
bool bmax[N][N],bmin[N][N];
long long fsum(int kl,int kr) {
    return sum[kr]-sum[kl-1];
}
long long workmax(int kl,int kr) {
    long long res=-INF;
    if(bmax[kl][kr]==1) return ffmax[kl][kr];
    for(int i=kl;i<kr;i++)  //枚举是哪两堆石子合并，核心代码。
        res=max(res,workmax(kl,i)+workmax(i+1,kr)+fsum(kl,kr));
    bmax[kl][kr]=1;
    ffmax[kl][kr]=res;
    return res;
}
long long workmin(int kl,int kr) {//min的写法与max异曲同工
    long long res=INF;
    if(bmin[kl][kr]==1) return ffmin[kl][kr];
    for(int i=kl;i<kr;i++)
        res=min(res,workmin(kl,i)+workmin(i+1,kr)+fsum(kl,kr));
    bmin[kl][kr]=1;
    ffmin[kl][kr]=res;
    return res;
}
int main() {
    memset(bmax,0,sizeof(bmax));
    memset(bmin,0,sizeof(bmin));
    memset(ffmax,0,sizeof(ffmax));
    memset(ffmin,0,sizeof(ffmin));
    memset(sum,0,sizeof(sum));
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) {
        scanf("%lld",&a[i]);
        a[i+n]=a[i];
        sum[i]=sum[i-1]+a[i];
    }
    for(int i=n+1;i<=2*n;i++) {//别忘了把前缀和也扩到2倍
        sum[i]=sum[i-1]+a[i];
    }
    for(int i=1;i<=n*2;i++) {
        bmax[i][i]=1;
        bmin[i][i]=1;
    }
    long long ansmax=-INF,ansmin=INF;//处理环形
    for(int i=1;i<=n;i++) {
        ansmax=max(ansmax,workmax(i,i+n-1));
        ansmin=min(ansmin,workmin(i,i+n-1));
    }
    printf("%lld\n%lld\n",ansmin,ansmax);
    return 0;
}
```

其实不难发现，在DP题中，如果你知道如何状态转移，但写for循环有些复杂或易错时，果断记忆化搜索。其实本质还是DP，只是方向不同罢了。

---

## 作者：Out_Land (赞：1)

------------

 看到一些大佬用的什么 **四边形不等式** ，蒟蒻表示一(huang)脸(ran)蒙(da) B (wu)。。。
  
于是我就替 P 党来波 **普通的区间 _dp_ ** 吧~
  
 ------------
 
   _fmax[i,j]_  表示  _[i,j]_  区间内合并石子的 **最大值**， _fmin[i,j]_  表示  _[i,j]_  区间内合并石子的 **最小值**。然后我们就可以枚举 **断点**   _k_  。
    
   因为只能合并 **相邻** 的石子，也就是分值只和连续几堆石子数量的和有关，很容易想到用 **前缀和** 来实现： _sum[i]_  表示前  _i_  堆石子数量和。
   
   于是就有: _fmax[i,j]=max(fmax[i,k]+fmax[k+1,j]+sum[j]-sum[i-1] (i<=k<j));_ 
   
   同理: _fmin[i,j]=min(fmin[i,k]+fmin[k+1,j]+sum[j]-sum[i-1] (i<=k<j));_ 
   
   这样就完了吗！？
   并不！！！
 

------------
  
此题有坑：
   题目说石子是摆在 **圆形操场上** 的，意味着什么你自己想。
   
   由于可以头尾合并，于是我们就要多开  n_个空间，也要多循环 _n_ 次。然后枚举 **区间头端** ，一个个区间地找 **最大值/最小值** ，最后输出即可。
   
代码中有很多细节要注意，下面会注明。

废话不多说，_Diu_ 代码！


------------

```pascal
var
        i,j,k,m,n,s,minn,maxx:longint;
        fmax,fmin:array[0..1001,0..1001] of longint;  
        //最少也要201
        sum,a:array[0..1000001] of longint;
```
~~此处省略求最大/最小值的函数~~~~~~~
```
begin
        readln(n);
        for i:=1 to 2*n do //多循环n次~
                for j:=1 to 2*n do
                begin
                        fmax[i,j]:=-maxlongint div 3;
                        fmin[i,j]:=maxlongint div 3;
                end;
        for i:=1 to n do
        begin
                read(a[i]);
                fmax[i,i]:=0;
                fmin[i,i]:=0;
                fmax[i+n,i+n]:=0; //考虑后n个空间
                fmin[i+n,i+n]:=0; 
                sum[i]:=sum[i-1]+a[i]; //前缀和
        end;
        readln;
        for i:=n+1 to 2*n do
                sum[i]:=sum[i-1]+a[i-n]; 
                //后n个空间也要求前缀和，否则无法dp~
                
        for j:=2 to 2*n do //多循环n次~
                for i:=j-1 downto max(1,j-n+1) do 
                //max(1,j-n+1)是为后n个空间考虑。
                //前n次循环max(1,j-n+1)是1，
                //后n次循环max(1,j-n+1)是j-n+1。
                //保证了后n次循环区间长度不超过n。
                        for k:=i to j-1 do //枚举断点
                        begin
                                fmax[i,j]:=max(fmax[i,j],fmax[i,k]+fmax[k+1,j]+sum[j]-sum[i-1]);
                        //[i,k]为两堆石子中左边一堆的分值
                        //[k,j]为两堆石子中右边一堆的分值
       //两堆分值和再加上[i,j]区间石子数量便是[i,j]区间分值

								fmin[i,j]:=min(fmin[i,j],fmin[i,k]+fmin[k+1,j]+sum[j]-sum[i-1]);
                        //同理
                        end;
        minn:=maxlongint; //初始化
        maxx:=-maxlongint;
        for i:=1 to n+1 do //枚举区间头端
        begin
                minn:=min(minn,fmin[i,i+n-1]); 
                //求所有区间最小值
                maxx:=max(maxx,fmax[i,i+n-1]);
                //求所有区间最大值
        end;
        writeln(minn); //输出
        writeln(maxx);
end. 完美结束！
```


------------


---

## 作者：wmxwmx (赞：1)

环变成线性:长度: 2n-1

a[1],a[2]......a[n],a[n+1].....a[2n-1];  a[n+i]=a[i]

f[i,j]:合并i到j堆的最小得分。


f[i,j]=min{f[i,k]+f[k+1,j]}+s[j]-s[i-1] .                          (i<=k<=j-1)

目标：ans=min{f[1,n],f[2,n+1],...,f[n,2n-1]}




```delphi

var fmin,fmax:array[1..199,1..199]of longint;
    a:array[1..199]of longint;
    s:array[0..199]of longint;
    n,i,j,amin,amax:longint;

function min(l,r:longint):longint;
var m,k:longint;
begin
    m:=fmin[l,l]+fmin[l+1,r];
    for k:=l+1 to r-1 do
    if m>fmin[l,k]+fmin[k+1,r] then m:=fmin[l,k]+fmin[k+1,r];
    exit(m);
end;

function max(l,r:longint):longint;
var m,k:longint;
begin
    m:=fmax[l,l]+fmax[l+1,r];
    for k:=l+1 to r-1 do
    if m<fmax[l,k]+fmax[k+1,r] then m:=fmax[l,k]+fmax[k+1,r];
    exit(m);
end;

begin
    readln(n);
    s[0]:=0;
    for i:=1 to 2*n-1 do
    if i<=n then
    begin
        fmin[i,i]:=0;
        fmax[i,i]:=0;
        read(a[i]);
        s[i]:=s[i-1]+a[i];
        for j:=i-1 downto 1 do
        begin
            fmin[j,i]:=min(j,i)-s[j-1]+s[i];
            fmax[j,i]:=max(j,i)-s[j-1]+s[i];
        end;
        if i=n then
        begin
            amin:=fmin[1,n];
            amax:=fmax[1,n];
        end;
    end
    else
    begin
        fmin[i,i]:=0;
        a[i]:=a[i-n];
        s[i]:=s[i-1]+a[i];
        for j:=i-1 downto 1 do
        begin
            fmin[j,i]:=min(j,i)-s[j-1]+s[i];
            fmax[j,i]:=max(j,i)-s[j-1]+s[i];
        end;
        if amin>fmin[i-n+1,i] then amin:=fmin[i-n+1,i];
        if amax<fmax[i-n+1,i] then amax:=fmax[i-n+1,i];
    end;
    writeln(amin);
    writeln(amax);
end.

time  O(n^3)}

```

---

## 作者：Ghost_lzy (赞：1)

很经典的环形动态规划：总结一下环形dp的代码结构：

   for 区间长度

     for 起点

{终点=(起点+长度）%n

       for  中间点

dp方程；

```cpp
     }
#include<bits/stdc++.h>
using namespace std;
int a[105],dp[105][105],n,sum[105][105];
int main()
{
    scanf("%d",&n);
    memset(dp,0x2f,sizeof(dp));
    for(int i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
        dp[i][i]=a[i];
        sum[i][i]=a[i];
    }
    for(int i=0;i<n;i++)
    {  for(int j=i+1;j!=i;j=(j+1)%n)
        {   j%=n;
            sum[i][j]=sum[i][(j-1+n)%n]+a[j];
        }
    }
    for(int l=1;l<n;l++)
    { for(int i=0;i<n;i++)
      {
          int j=(i+l)%n;
          for(int k=i;k!=j;k=(k+1)%n)
          {int r=(k+1)%n;      
          if(i!=k&&j!=r)
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[r][j]+sum[i][k]+sum[r][j]);
           else if(i!=k&&j==r)
             dp[i][j]=min(dp[i][j],dp[i][k]+dp[r][j]+sum[i][k]);
             else if(i==k&&j!=r)
               dp[i][j]=min(dp[i][j],dp[i][k]+dp[r][j]+sum[r][j]);
              else   
                  dp[i][j]=min(dp[i][j],dp[i][k]+dp[r][j]);
        }
      }
    }
      int ans=0x7ffffff;
    for(int i=0;i<n;i++) 
     {
         int j=(i+n-1)%n;
         ans=min(ans,dp[i][j]);
     }
     printf("%d\n",ans);
     memset(dp,0,sizeof(dp));
     for(int i=0;i<n;i++)
      {dp[i][i]=a[i];}
     for(int l=1;l<n;l++)
    { for(int i=0;i<n;i++)
      {
          int j=(i+l)%n;
          for(int k=i;k!=j;k=(k+1)%n)
          {int r=(k+1)%n;      
          if(i!=k&&j!=r)
            dp[i][j]=max(dp[i][j],dp[i][k]+dp[r][j]+sum[i][k]+sum[r][j]);
           else if(i!=k&&j==r)
             dp[i][j]=max(dp[i][j],dp[i][k]+dp[r][j]+sum[i][k]);
             else if(i==k&&j!=r)
               dp[i][j]=max(dp[i][j],dp[i][k]+dp[r][j]+sum[r][j]);
              else   
                  dp[i][j]=max(dp[i][j],dp[i][k]+dp[r][j]);
        }
      }
    }
     ans=-0x7ffffff;
    for(int i=0;i<n;i++) 
     {
         int j=(i+n-1)%n;
         ans=max(ans,dp[i][j]);
     }
     printf("%d\n",ans);
}/*
```
4
4 5 9 4

\*/

---

## 作者：Steven_Green (赞：1)

#### 又是一道简单的水题

这道题没有代码构思的难度，就只是一道模版题，只是连接成了一个环而已。

下面献上本蒟蒻的代码。

本蒟蒻用的是递推式和三重循环，时间复杂度为O(n^3)
```cpp
#include <cstdio>
#include <iostream>
/*头文件*/
using namespace std;
int a[210],f[210][210],s[210][210];
/*a数组是各堆的数量，f数组是最大值，s数组是最小值*/
int main(){
	int n,Max,Min;
	scanf("%d",&n);//输入
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[n+i]=a[i];//化线为链
	}
	for(int i=1;i<=2*n;i++)a[i]=a[i]+a[i-1];//前缀和
	for(int r=2;r<=n;r++){//枚举起始点
		for(int i=1;i<=2*n-r+1;i++){//左端点
			int j=i+r-1;右端点
			f[i][j]=f[i+1][j]+a[j]-a[i-1];
			s[i][j]=s[i+1][j]+a[j]-a[i-1];
            /*先给初始值*/
			for(int k=i;k<j;k++){
				f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+a[j]-a[i-1]);
				s[i][j]=min(s[i][j],s[i][k]+s[k+1][j]+a[j]-a[i-1]);
                /*动态转换方程*/
			}
		}
	}
	Max=f[1][n],Min=s[1][n];
	for(int i=2;i<=n;i++){
		if(f[i][i+n-1]>Max)Max=f[i][i+n-1];
		if(s[i][i+n-1]<Min)Min=s[i][i+n-1];
	}
    /*取n个表中的最大值*/
	printf("%d\n%d",Min,Max);
	return 0;
}
```

---


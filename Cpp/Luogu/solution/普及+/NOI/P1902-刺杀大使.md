# 刺杀大使

## 题目描述

某组织正在策划一起对某大使的刺杀行动。他们来到了使馆，准备完成此次刺杀，要进入使馆首先必须通过使馆前的防御迷阵。

迷阵由 $n\times m$ 个相同的小房间组成，每个房间与相邻四个房间之间有门可通行。在第 $n$ 行的 $m$ 个房间里有 $m$ 个机关，这些机关必须全部打开才可以进入大使馆。而第 $1$ 行的 $m$ 个房间有 $m$ 扇向外打开的门，是迷阵的入口。除了第 $1$ 行和第 $n$ 行的房间外，每个房间都被使馆的安保人员安装了激光杀伤装置，将会对进入房间的人造成一定的伤害。第 $i$ 行第 $j$ 列 造成的伤害值为 $p_{i,j}$（第 $1$ 行和第 $n$ 行的 $p$ 值全部为 $0$）。

现在某组织打算以最小伤害代价进入迷阵，打开全部机关，显然，他们可以选 择任意多的人从任意的门进入，但必须到达第 $n$ 行的每个房间。一个士兵受到的伤害值为他到达某个机关的路径上所有房间的伤害值中的最大值，整个部队受到的伤害值为所有士兵的伤害值中的最大值。现在，这个恐怖组织掌握了迷阵的情况，他们需要提前知道怎么安排士兵的行进路线可以使得整个部队的伤害值最小。

## 说明/提示

- $50\%$ 的数据，$n,m \leq 100$；
- $100\%$ 的数据，$n,m \leq 1000$，$p_{i,j} \leq 1000$。

## 样例 #1

### 输入

```
4 2
0 0 
3 5 
2 4 
0 0 
```

### 输出

```
3```

# 题解

## 作者：Social_Zhao (赞：178)

## Part 0 前言

这是你没有见过的船新解法。

请自动忽略算法标签。

------

## Part 1 考虑正解——二分+bfs

我们在题面中看到了**最大值最小** 这五个字。

很容易就想到了二分答案。

然鹅我的``dfs``挂了，所以我就写了``bfs``，阿掉了。

本来就是很裸的做法，限于篇幅，这里就无需赘述了。

```cpp
#include<bits/stdc++.h>
using namespace std;

int get()
{
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

const int MaxN = 1005;
const int inf = 0x3f3f3f3f;
const int dx[5] = {0, 1, 0, -1, 0};
const int dy[5] = {0, 0, 1, 0, -1};
int p[MaxN][MaxN], vis[MaxN][MaxN];
int n, m;
int l = inf, r = -inf, mid, ans, f; 

bool bfs(int x, int y, int maxn) //判断mid是否可行的bfs
{
	queue<pair<int, int> > q;
	q.push(make_pair(x, y)); //STL里的pair，个人认为要方便一些
	vis[x][y] = 1; 
	while(q.size()) { //以下就是bfs板子
		int xx = q.front().first; 
		int yy = q.front().second;
		q.pop();
		for(int i = 1; i <= 4; i++) {
			int nx = xx + dx[i];
			int ny = yy + dy[i];
			if(nx < 1 || nx > n || yy < 1 || yy > m || vis[nx][ny] || p[nx][ny] > maxn)
				continue; //不可行（越界、已访问、伤害过大）的直接跳过
			vis[nx][ny] = 1;
			if(nx == n) return 1; //到了，返回1
			else q.push(make_pair(nx, ny));
		}
	}
	return 0; //没有搜到，返回0
}

int main()
{
	n = get(), m = get();
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			p[i][j] = get();
			r = max(r, p[i][j]);
			l = min(l, p[i][j]);
		}
	}
	while(l <= r) { //二分答案模板
		mid = (l + r) >> 1;
		f = 0;
		memset(vis, 0, sizeof(vis)); //重置数组
		if(bfs(1, 1, mid)) r = mid - 1, ans = mid; //如果这个mid可行，说明可能还能再小，于是更新答案 + 缩小范围
		else l = mid + 1; //mid此不可行，说明不可能再小，也缩小范围，不更新答案
	}
	printf("%d", ans);
	return 0;
}

```

## Part 2 新解法

二分这种算法对题中的``p[i][j]``的依赖较严重。如果加强数据，改到$10^9$怎么办呢？

这样就需要一个靠``n``、``m``吃饭的算法了

在看这个解法前，您需要一些图论知识

让我们把样例画成一张图：（暂不带权）

![](https://cdn.luogu.com.cn/upload/pic/62443.png)

这个图得到的方法：

设点号为``k``，这个点是``x``行``y``列。

则有：$k=(x-1) \times m + y$

我们的任务是从第一行到第四行，求出经过的最大点权最小（有一点绕）

首先我们需要把点权转成边权：

仔细地钻研这句话：

> 最大点权最小

解读：

- 根据最大，我们可以想到如果我们要点转边，两点之间的边权应为两端点的点权最大值。

  - 根据这个边转点的原理，可以得到这一张图：

  ![](https://cdn.luogu.com.cn/upload/pic/62448.png)

- 根据最小，得出：我们需要选择一些边来使第一行和最后一行连通，这些边的权尽量小

现在我的思路就显而易见了：**MST（最小生成树）**

但是又不是裸的最小生成树。我们不需要选择``n-1``条边，只需要使首尾两行连通。

所以我们选择``Kruskal``算法，用并查集维护：

按照题面，第一行和最后一行的边权都是``0``，中间又不可能出现负权，所以我们的算法会首先选出这些边，因此可以认为这些点从**一开始就是连通**的，并且可以认为，将这两行都连通，就等价于将分别位于这两行上的任意两点连通。为了简便，我们将第一个点和第八个点连通。如图：红边表示已选边，黑边未选边

![](https://cdn.luogu.com.cn/upload/pic/62449.png)

现在按照生成树算法，开始选其他边

第一步，选择目前最小的未选边——在``5``和``7``之间，边权为``2``的边：

![](https://cdn.luogu.com.cn/upload/pic/62450.png)

第二步、第三步，选出目前边权最小的边，分别是——在``3``和``5``之间，边权为``3``的边、在``1``到``3``之间，边权为``3``的边（节约篇幅，一并画出）：

![](https://cdn.luogu.com.cn/upload/pic/62453.png)

这时候，我们愉快地发现，``1``号和``8``号已经连通了。算法结束，答案为``3``。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int get()
{
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

const int MaxN = 1005;
const int inf = 0x3f3f3f3f;
int p[MaxN][MaxN];
int n, m, maxn = -inf;
struct Edge {
	int u, v, w;
} edge[10000005];
int k = 0;
int fa[10000005];

int MAP(int x, int y) { return (x - 1) * m + y; } //此函数用于求（x，y）在图中的编号
int find(int x) { return (x == fa[x]? x : fa[x] = find(fa[x])); } //一行并查集
bool cmp(Edge a, Edge b) { return a.w < b.w; } //一行cmp

void kruskal() //克鲁斯卡尔算法:
{
	sort(edge + 1, edge + k + 1, cmp); //首先将边按权值排序
	int st = MAP(1, 1); //指定一个开始点：第一个
	int ed = MAP(n, m); //指定一个结束点：最后一个
	for(int i = 1; i <= k; i++) { //枚举边：
		int u = edge[i].u; 
		int v = edge[i].v;
		int x = find(u), y = find(v); //取出u、v所在连通块
		if(x != y) //若在同一连通块，我们就算去合并也没有多大意义，这样可以稍微节省时间
		{
			maxn = max(maxn, edge[i].w); //更新最大边权
			fa[x] = fa[y]; //将两边连通
			if(find(st) == find(ed)) return; //如果开始点和结束点连通了，说明可以退出了
		}
	}
}

int main()
{
	n = get(), m = get();
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			p[i][j] = get();
			fa[MAP(i, j)] = MAP(i, j); //在读入的时候顺便初始化并查集
		}
	}
    //重点：连边
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			int u = MAP(i, j); //这个点
			int v1 = MAP(i, j + 1); //向右连边
			int v2 = MAP(i + 1, j); //向下连边
            //因为是无向图，只用向两个方向连边
            //权值是两点权间的较小值
			if(j + 1 <= m) edge[++k] = {u, v1, max(p[i][j], p[i][j + 1])}; //注意判断越界。
			if(i + 1 <= n) edge[++k] = {u, v2, max(p[i][j], p[i + 1][j])};
		}
	}
	/*
	for(int i = 1; i <= k; i++) {
		printf("%d %d %d\n", edge[i].u, edge[i].v, edge[i].w);
	}
	*/
	kruskal(); //跑MST算法
	printf("%d", maxn); //输出解
	return 0;
}

```

## Part 3 后记

前者的时间：搜索的复杂度完全就是玄学（取决于数据）

关于后者的时间？

读入、连边、快排占据了绝大部分时间，克鲁斯卡尔是线性的（可以忽略不计）。稍微卡卡常还是能跑的很快的。

经过实测，后者比前者慢、空间大、代码长······那为什么还要这么做呢？

毕竟多思考一下总是好的。

注：因为是不按常理出牌的方法，可能会有锅（虽然正确性可以得到证明）。如果您发现了``HACK``的方法，或者有不懂的地方，请私信作者。

---

## 作者：lzpclxf (赞：43)

[题目](https://www.luogu.org/problem/P1902)

**主要来解释一下其他题解未详细解释的dfs部分**

读完题目之后，有一个比较明显的句子“ _整个部队的伤害值最小_ 。”
因为整个部队的伤害值是最大值那么这个题目就变成了最大值的最小值
所以我们考虑二分答案求解。

我们二分一个答案mid来表示一个界限，如果当前这个格子的伤害代价比mid小则可以走否则就不走，每次check函数只需判断能否从第一行走到最后一行即可，因为每一行的每个门都是相连的，所以只要有一个能到，那么我们再派m-1个人顺着这条路过去再沿着横向的门过去就好啦，因为第一行和最后一行的伤害值为零，所以这么做莫得问题。

解释一下我很久都没搞明白的问题：

为什么dfs时只要判断是否能到达即可，我们不是要找他的最大值来表示这一次的伤害值嘛？
因为我们二分的这个值，最后二分出来的一定是某个点产生的伤害值，也就是我们最后的答案（是最大值嘛，判断此点是否可行就是判断他是否是比mid小，所以mid就是此次的最大值就是答案）这也解释了为什么我们二分的是伤害值最后却可以输出二分的边界的问题。

部分代码解释：
```cpp
void dfs(int xx, int yy) {
	if(xx == n) {flag = 1;return;}
	for(int i = 0; i < 4; i++) {
		x = xx + dx[i], y = yy + dy[i];
		if(x >= 1 && x <= n && y >= 1 && y <= m && map[x][y] <= mid && !vis[x][y]) {
			vis[x][y] = 1;
			dfs(x, y);
			vis[x][y] = 0;
			if(flag) break;
		}
	}
}
```
也就是基本的搜索思路
每次走四个方向，只要还没有超出边界，并且这个点的伤害值在允许范围之内并且还没有走到过这个点，那就走他，继续往下搜索，回溯。

```cpp 
	while(l + 1 < r) {
		mid = (l + r) >> 1;
		if(check(mid)) r = mid;
		else l = mid;
	}
```
二分答案的边界问题很重要，有很多小细节需要注意。比如死循环、更掉最优解等问题。

```cpp
memset(vis, 0, sizeof(vis));
```
**一定一定一定要清空标记数组！**

The Last:
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 1010;
int n, m, map[N][N], l, r, mid, x, y;
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};
bool flag = 0, vis[N][N];
int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1;ch = getchar();}
	while(isdigit(ch)) {s = s * 10 + ch - '0';ch = getchar();}
	return s * w;
}
void dfs(int xx, int yy) {
	if(xx == n) {flag = 1;return;}
	for(int i = 0; i < 4; i++) {
		x = xx + dx[i], y = yy + dy[i];
		if(x >= 1 && x <= n && y >= 1 && y <= m && map[x][y] <= mid && !vis[x][y]) {
			vis[x][y] = 1;
			dfs(x, y);
			vis[x][y] = 0;
			if(flag) break;
		}
	}
}
bool check(int x) {
	flag = 0;
	memset(vis, 0, sizeof(vis));
	dfs(1, 1);
	if(flag) return 1;
	return 0;
}
int main() {
	n = read(), m = read();
	for(int i = 1; i <= n; i++) 
		for(int j = 1; j <= m; j++)
			map[i][j] = read(), r = max(r, map[i][j]);
	while(l + 1 < r) {
		mid = (l + r) >> 1;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%d\n", r);
	return 0;
}
```
谢谢收看， 祝身体健康！

---

## 作者：yeyyx (赞：32)

二分答案+dfs

每次=对于二分答案mi维护一个t[][]临时地图，把代价大于mi的标记为不可走，dfs搜索是否有一条第一行到第n行的通路，有表示答案大了即r=mi，反之小了l=mi。找到通路就可以退出dfs了，不需要考虑是否代价和最小（题意可知）

因为第一行和最后一行没有机关代价为零，所以从第一行任意位置开始搜索，跑到最后一行任意位置即可。

各种实现代码写得很清楚了，感觉还是比较简洁的qwq

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1005
using namespace std;
int n,m,ans,flag,a[N][N],t[N][N],l,r,mi,maxn,vis[N][N];

void change(int x){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j]<=x)t[i][j]=0;
            else t[i][j]=1;
        }
    }
}
void dfs(int x,int y){
    if(x==n){
        flag=1;
        return;
    }
    int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
    for(int k=0;k<4;k++){
        int tx=x+d[k][0];
        int ty=y+d[k][1];
        if(tx>0&&ty>0&&tx<=n&&ty<=m){
            if(!vis[tx][ty]&&!t[tx][ty]){
                vis[tx][ty]=1;
                dfs(tx,ty);
                if(flag==1)break;
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            maxn=max(maxn,a[i][j]);
        }
    }
    l=0;r=maxn;
    while(l+1<r){
        mi=(l+r)>>1;
        flag=0;
        change(mi);
        memset(vis,0,sizeof vis);
        dfs(1,1);
        if(flag)r=mi;
        else l=mi;
    }
    printf("%d\n",r);
    return 0;
    
}
```

---

## 作者：Mystery_Sky (赞：27)

# [刺杀大使](https://www.luogu.org/problemnew/show/P1902)



### 一道并不难的二分题，竟让我交了上20次，诶，果然还是我太弱了。



## 看完题目就基本想到要怎么做了：

### 只需要对最小伤害代价进行二分即可，check()函数里用搜索判断是否可以到达最后一行，这里的check()用深搜广搜都可以，两种的代码下面都会给出，而经过检验，这道题目用深搜会优于广搜。



如果你不像我一般手滑的话，此题基本就可以过了。

然而，导致我反复提交20遍的原因，不是二分答案时卡循环的问题，而是，，，

​                                 ***数组开小了***

这也给我提了个醒，不是所有的re都是二分循环的锅，有时候要考虑数组越界的问题。

#### 用汝佳julao的话说，就是 : 编写一个尽量**鲁棒**的程序！！！

------

## code:

### 深搜做法（更优）：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
//Mystery_Sky
//
#define M 2000
#define INF 0x7f7f7f7f
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};
int l, r, mid;
bool vis[M][M], flag;
int n, m, a[M][M];
void check(int x, int y, int ans)
{
	if(x == n)	{
		flag = true;
	}
	for(int i = 0; i <= 3; i++) {
		int xx = x + dx[i];
		int yy = y + dy[i];
		if(xx <= 0 || yy <= 0 || xx > n || yy > m || a[xx][yy] > ans || vis[xx][yy]) continue;
		vis[xx][yy] = 1;
		check(xx, yy, ans);
		if(flag) return;
	}

}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]), r = max(r, a[i][j]);
	l = 0;
	while(l <= r) {
		mid = (l+r)/2;
		memset(vis, 0, sizeof(vis));
		flag = 0;
		check(1, 1, mid);
		if(flag) r = mid - 1;
		else l = mid + 1;
	}
	printf("%d\n", l);
	return 0;
}
```



### 广搜做法：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
//Mystery_Sky
//
#define M 2000
#define INF 0x7f7f7f7f
struct node{
    int x, y;
};
int n, m, p[M][M];
int l, r, mid, maxx;
int vis[M][M];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int Ans;
inline bool check(int ans)
{
    memset(vis, 0, sizeof(vis));
    queue <node> q;
    q.push((node){1, 1});
    while(!q.empty()) {
        node top = q.front();
        q.pop();
        int x, y;
        for(int i = 0; i <= 3; i++) {
                x = top.x + dx[i];
                y = top.y + dy[i];
                if(x <= 0 || y <= 0 || x > n || y > m || p[x][y] > ans || vis[x][y]) continue;
                vis[x][y] = 1;
                q.push((node){x, y});
                if(x == n)	return true; 
        }
    }
    return false;
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) scanf("%d", &p[i][j]);
    l = 0, r = 1024;
    while(l < r) {
        mid = (l+r)>>1;
        if(check(mid)) {
            r = mid;
        }
        else l = mid+1;
    }
    printf("%d\n", l);
    return 0;
}
```

---

## 作者：_Atyou (赞：20)

**纯搜索**

大佬们基本都是用二分答案，我一开始写没有往这方面想（或许就是蒟蒻和大佬的差距吧）

一开始写完测了个大数据，不出意外的RE了，于是我居然谜一样的想到写一个栈模拟深搜过程

结果AC了？

题意大致就是找一条从第一行到第n行的路径使得路径上的最大值最小

具体的想法我写在代码里了，详见代码吧



```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() { //快速读入，不是重点
	int num=0, f=1; char c=0;
	while (!isdigit(c=getchar())) if (c == '-') f=-1;
	while (isdigit(c)) num=(num<<3)+(num<<1)+c-'0', c=getchar();
	return num*f;
}

const int dx[4]={0, 0, -1, 1};
const int dy[4]={1, -1, 0, 0}; //四个方向 对应上、下、左、右 

const int N = 1000 + 5;
int p[N][N], n, m, ans=0x3f3f3f3f; //答案初始为最大化 
int f[N][N]; //记录走到这个点所受伤害的最小值 
bool v[N][N]; //该点是否访问过了 

struct node {
	int x, y, maxdamage;
};

node s[N*N]; int top; //防爆栈

void dfs() {
	while (top) { 
		int x=s[top].x, y=s[top].y, maxdamage=s[top].maxdamage; 
		top--; v[x][y]=false; //出栈 
		if (maxdamage >= ans) continue; //如果当前受到的伤害大于答案的话，再往下搜伤害也不会变小了，于是果断剪枝 
		if (x == n) { //搜到最后一行则可记录答案 
			ans=maxdamage; //由于上面的剪枝，这里的答案一定是最优解了 
			continue;
		}
		for (int i=0; i<4; i++) {
			int nx=x+dx[i], ny=y+dy[i];
			if (nx < 1 || nx > n || ny < 1 || ny > m) continue; //检查是否越界 
			if (v[nx][ny]) continue; //检查是否访问过了 
			int nextdamage=max(maxdamage, p[nx][ny]); //求到下一个点后受到的伤害 
			if (f[nx][ny] <= nextdamage) continue;
			//如果到下一个点受到的伤害大于我记录过的所受伤害的最小值，可以直接跳过
			//因为我一定有另一条更优的路径到达下一个点 
			v[nx][ny]=true;  
			f[nx][ny]=nextdamage; //记录 
			s[++top]=(node){nx, ny, nextdamage}; //进栈 
		}
	}
}

int main() {
	memset(f, 0x3f, sizeof(f)); //初始化 
	n=read(); m=read();
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++) p[i][j]=read();
	for (int i=1; i<=m; i++) { //以第二行每一个点作为起点开始搜索
		v[2][i]=true;
		s[++top]=(node){2, i, p[2][i]};  
		dfs();
	}
	printf("%d\n", ans);
	return 0;
}

```

---

## 作者：顾z (赞：10)

题目描述--->[p1902 刺杀大使](https://www.luogu.org/problemnew/show/P1902)

## 广告： [安利blog](https://www.luogu.org/blog/RPdreamer/#)

**题意概括：**

找一条路径,使得从第1行到第n行路径的最大值最小。

**分析：**

题目概括出来,很容易想到**二分**.

求最大值最小,因此我们可以对最大伤害值进行二分。

如果某位置所受伤害值大于我们当前所限制的伤害值,我们肯定是不走这条路的.

**栗子：**

我们限制最大伤害为5

搜索到某一行发现伤害值是这样的--> 8 8 8 8。

这样我们是无法通过这一行的。

**做法：**

我们需要标记是否能以当前限制的伤害值走到最后一行,如果可以我们就去寻求更小伤害,如果不能我们只能去寻求较小伤害(实际上是更大了)。

**以标记作为更新边界的标准.**

所以很容易写出二分代码↓
```cpp
int l=0,r=1008;
//这里右边界赋为了极大值
//数据保证了每个位置伤害值不超过1000
//也可以把右边界赋值为当前图中最大伤害值.
	while(l<=r)//一般套路
	{
		int mid=l+r>>1;
		memset(vis,0,sizeof vis);
		flg=false;
		dfs(1,1,mid);
		if(flg==true)//flg为true视为能到达最后一行
			r=mid-1;//因此我们更新右边界,寻求更小值
		else l=mid+1;
	}
```

**搜索部分代码如何去写？**

没什么需要特别注意的地方。

需要判断:是否超出边界,是否遍历过,伤害值是否能满足限制条件.

我写出来是这个样子的↓
```cpp
IL void dfs(int x,int y,int mid)
{
    if(x==n)
    {
        flg=1;
        return;
    }
    vis[x][y]=true;
    for(RI i=0,xx,yy;i<4;++i)
    {
        xx=x+ax[i],yy=y+ay[i];
        //ax,ay数组为搜索的一般设置套路.代表四个方向
        //const int ax[]={0,1,0,-1};
        //const int ay[]={1,0,-1,0};
        if(xx<1 or xx>n or yy<1 or yy>m or vis[xx][yy] or p[xx][yy]>mid)//一连串判断
        //这里的 or 与 || 是一样的
            continue;
        dfs(xx,yy,mid);
        if(flg)
            return;
    }
}
```
**一点时间优化**

我们可以不必将vis数组重置,而去判断是第几次经过.

--------------------代码---------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define mod 100000
IL void read(int &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,p[1008][1008],tm;
const int ax[]={0,1,0,-1};
const int ay[]={1,0,-1,0};
bool flg,vis[1008][1008];
IL void dfs(int x,int y,int mid)
{
    if(x==n)
    {
        flg=1;
        return;
    }
    vis[x][y]=true;
    for(RI i=0,xx,yy;i<4;++i)
    {
        xx=x+ax[i],yy=y+ay[i];
        if(xx<1 or xx>n or yy<1 or yy>m or vis[xx][yy] or p[xx][yy]>mid)
            continue;
        dfs(xx,yy,mid);
        if(flg)
            return;
    }
}
int main()
{
	read(n),read(m);
	for(RI i=1;i<=n;i++)
		for(RI j=1;j<=m;j++)
			read(p[i][j]);
	int l=0,r=1008;
	while(l<=r)
	{
		int mid=l+r>>1;
		memset(vis,0,sizeof vis);
		flg=false;
		dfs(1,1,mid);
		if(flg==true)
			r=mid-1;
		else l=mid+1;
	}
	printf("%d",l);
}
```

---

## 作者：薛定愕的驴 (赞：8)

# 纯搜索
做法很简单枚举最小伤害，从小开始，进行搜索，遇到可以的就可以结束

思路很简单搜索中加几个判断就行了；

[结果](https://www.luogu.org/record/24993175)

关键搜索代码：
```cpp
	queue<node>que;         \\用队列进行
	que.push((node){1,1,0});
	while(que.empty()!=true)   \\判段队列是否空来确定搜索是否需要进行
	{
		node q=que.front();    \\每次清除一个空间
		if(q.x==n)  　　　　　	\\ 具体过程
		{
			return 1;
		}
		for(int i=0;i<=3;i++)
		{
			int tx=q.x+dx[i],ty=q.y+dy[i];
			if(tx>0&&ty>0&&tx<=n&&ty<=m&&c[tx][ty]==0&&a[tx][ty]<=op)
			{
			
				que.push((node){tx,ty,max(q.z,a[tx][ty])});
				c[tx][ty]=1;
			}
		}
		que.pop();		
	}
	return 0;
```

主程序和快读：


```cpp1
int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}

int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)	
		for(int j=1;j<=m;j++)
			a[i][j]=read();
	for(int i=1;i<=1000;i++)
	{
		memset(c,0,sizeof(c));
		if(bfs(i)){printf("%d\n",i);break;}
	}
	return 0;
}
```
就在我以为完美时打开题解看到大佬们的二分
才发现自己有多菜QWQ
于是改了代码
```cpp
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)	
		for(int j=1;j<=m;j++)
			a[i][j]=read();
	l=0,r=1000;
	int ans;
	while(l<=r)
	{
		memset(c,0,sizeof(c));
		int mid=(l+r)/2;
		if(bfs(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans<<endl;
	return 0;
}
```
~~快了接近1s~~

[哼](https://www.luogu.org/record/24996900)


---

## 作者：封禁用户 (赞：8)

# 思路：二分+宽搜+AC
此题的关键是最后的伤害是士兵伤害的最大值的最小值，所以就要用到二分答案，就是不断逼近最终答案，而宽搜就是写在check（）函数里，上代码。
```cpp
#include<iostream>
#include<queue> //队列STL标准库
#include<algorithm>
using namespace std;
int mapp[1010][1010],vis[1010][1010],n,m,l=0,r=0;
//mapp[][]记录每个房间的伤害值
//vis[][]记录这个房间是否访问过
struct node
{
	int x,y,pill;//目前的x,y坐标和伤害值
};
int dx[5]={0,0,1,0,-1};//x的4个方向
int dy[5]={0,1,0,-1,0};//y的4个方向
int check(int x)//二分答案，开始宽搜
{
    memset(vis,0,sizeof(vis));把所有的要访问的点清零
    queue<node>q;//定义为q队列，类型为node
    node start;
    start.x=1,start.y=1,start.pill=mapp[1][1];//赋初值
    vis[1][1]=1;
    q.push(start);
    while(!q.empty())
    {
	node now=q.front();
	q.pop();
	for(int i=1;i<=4;i++)
	{
	    int xx=dx[i]+now.x;//向低i个方向走
            int yy=dy[i]+now.y;
	    if(xx<=n&&yy<=m&&xx>=1&&yy>=1&&vis[xx][yy]!=1&&mapp[xx][yy]<=x)//一系列的判断可不可以走下一步
	    {
		node next;//下一步走到哪
		next.x=xx,next.y=yy;
                next.pill=max(mapp[now.x][now.y],mapp[xx][yy]);
                //下一步的伤害值
		vis[xx][yy]=1;//已走过了，标记为1
		q.push(next);//重新进队，等待下一轮操作
	    }
	 }
     }
    for(int i=1;i<=m;i++) if(vis[n][i]==0) return 0;
    return 1;//最关键的一步，看看能不能到达最后一排
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) 
    {
        for(int j=1;j<=m;j++) 
        {
            cin>>mapp[i][j]；
            r=max(r,mapp[i][j]);// 右端点为伤害最大值
        }
    }  
    
    while(l<=r)//开始二分答案（很模板化的玩意儿）
    {
        int mid=(l+r)/2;
        if(check(mid)) r=mid-1;
	else l=mid+1;
    }
    if(check(l)) cout<<l<<endl;别忘了最后还得再判断
    else cout<<r<<endl;
    return 0;
}
```
这道题还是挺水的，但我竟然爆零了n次（~~n==1~~)!

蒟蒻的第一篇题解，望通过。


---

## 作者：Celebrate (赞：5)

我的博客：

```cpp
https://blog.csdn.net/zsyzClb/article/details/84146000
```

因为每一位士兵收到的伤害为沿途中遇到机关的最大值，所以

我们不难想到用二分，但是我用了广度优先搜索，我觉得这样比较过瘾

用一个优先队列按照受到的最大伤害从小到大排序，那么第一个搜到n行的就是最优解

一开始给第二行每一个点放士兵，并且用bk[x][y]记录到达点（x,y)的最优解，防止出现重复

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
inline int read(){
    int x=0,f=0;char s=getchar();
    while(!isdigit(s))f|=s=='-',s=getchar();
    while( isdigit(s))x=(x<<1)+(x<<3)+s-48,s=getchar();
    return f==0?x:-x;
}
const int N=1e3+10;
struct node{
	int x,y,k;
	inline bool operator<(const node &a)const{//按照所受伤害从小到大排序 
		return k>a.k;
	}
};
priority_queue<node>q;
int n,m;
int map[N][N];//记录每一个点的机关伤害 
int bk[N][N];//记录每一个点的最优解 
int dx[4]={0,0,-1,1};//方向 
int dy[4]={-1,1,0,0};
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			map[i][j]=read();
	memset(bk,63,sizeof(bk));
	for(int i=1;i<=m;i++)bk[1][i]=0,bk[2][i]=map[2][i];//记录一下，并且保证士兵不会回到第1行 
	for(int i=1;i<=m;i++)q.push((node){2,i,map[2][i]});//给每一个点放士兵 
	int x,y,k,xx,yy,kk;
	bool bj=false;
	while(!q.empty()){
		x=q.top().x;//记录栈顶 
		y=q.top().y;
		k=q.top().k;
		q.pop();
		if(k>bk[x][y])continue;//如果不是最优解，就不搜 
		for(int t=0;t<4;t++){
			xx=x+dx[t];
			yy=y+dy[t];
			if(!(1<=xx&&xx<=n&&1<=yy&&yy<=m))continue;//判断边界 
			kk=max(k,map[xx][yy]);//更新最大值 
			if(kk>=bk[xx][yy])continue;//如果是当前的最优解 
			bk[xx][yy]=kk;//记录并入栈 
			if(xx==n){printf("%d\n",kk);bj=true;break;}//如果到达了第n行，就可以直接输出 
			q.push((node){xx,yy,kk});
		}
		if(bj==true)break;
	}
	return 0;
}

```

---

## 作者：naivekun (赞：5)

## 不同于二分答案的方法


可以使用并查集+（伪）最小生成树

先把每个房间存进一个struct里，用房间的值排序，然后从小到大枚举各个房间。

设枚举到第 [i，j]个房间，若它的周围某个房间被枚举过，就用并查集连在一起。

代码:

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

int n,p,fat[1000005];
inline void initun()
{
    for(int i=1;i<=n*p;++i)
        fat[i]=i;
}
inline int find(int x)
{
    if(fat[x]==x)return x;
    return fat[x]=find(fat[x]);
}

int pig[1005][1005];
struct ROOM
{
    int x,y,val;
}room[1000005];
int roomtop;

int compp(const ROOM &x,const ROOM &y)
{
    return x.val<y.val;
}

bool solve[1005][1005];
inline int getnum(int x,int y)   //便于并查集维护
{
    return (x-1)*p+y;
}
int main(int argc, char const *argv[])
{
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=p;++j)
    {
        scanf("%d",&pig[i][j]);
        if(i!=1&&i!=n)
        {
            room[++roomtop].x=i;
            room[roomtop].y=j;
            room[roomtop].val=pig[i][j];
        }
        
    }
    sort(room+1,room+roomtop+1,compp);
    initun();
    for(int i=1;i<=p;++i)
    {
        solve[1][i]=solve[n][i]=1;
    }
    for(int i=1;i<=p;++i)
    {
        fat[i]=1;
        fat[getnum(n,i)]=fat[getnum(n,1)];   //先把第一行以及最后一行连在一起
    }
    int xx,yy;
    int ans=0;
    for(int i=1;i<=roomtop;++i)
    {
        xx=room[i].x;yy=room[i].y;
        solve[xx][yy]=1;
        if(xx-1>=1&&solve[xx-1][yy]==1)
        {
            // solve[xx][yy]=1;
            ans=max(ans,pig[xx][yy]);
            fat[find(getnum(xx-1,yy))]=find(getnum(xx,yy));
        }
        if(xx+1<=n&&solve[xx+1][yy]==1)
        {
            // solve[xx][yy]=1;
            ans=max(ans,pig[xx][yy]);
            fat[find(getnum(xx+1,yy))]=find(getnum(xx,yy));
        }
        if(yy-1>=1&&solve[xx][yy-1]==1)
        {
            // solve[xx][yy]=1;
            ans=max(ans,pig[xx][yy]);
            fat[find(getnum(xx,yy-1))]=find(getnum(xx,yy));
        }
        if(yy+1<=p&&solve[xx][yy+1]==1)
        {
            // solve[xx][yy]=1;
            ans=max(ans,pig[xx][yy]);
            fat[find(getnum(xx,yy+1))]=find(getnum(xx,yy));
        }
        if(fat[find(1)]==fat[find((n-1)*p+1)])
            break;
    }
    printf("%d",ans);
    
    return 0;
}

```

---

## 作者：最喜欢saber了 (赞：3)

这道题原来刚开始做的时候忽略了这个条件（迷阵由 $n*m$个相同的小房间组成，每个房间与相邻四个房间之间有门可通行。），

然后我以为这个题是扫一下每列的值之和的最小值然后再找出这列中除0外的最小值，当然是错的，（反正我WA了），于是我开始想模拟与搜索，由于不会bfs，于是只能dfs了，但这道题从题面来看好像可以二分，于是我们可以二分所受到的伤害,如果某位置所受到的伤害值大于我们二分限制的伤害值，我们肯定是不走这条路的，而在代码实现方面我们可以标记我们能否以二分的伤害值走到最后一行，如果可以就找左端点（较少伤害），至于dfs部分我们可以判断一下是否超出边界，是否走过这个点,伤害值是否能满足限制条件。

于是献上的代码：

```cpp
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<cctype>
#include<cstdio>
#include<queue>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){
    x=0;T f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=f;
}
const int maxa = 1100,dx[]={0,0,1,-1},dy[]={-1,1,0,0};
int n,m,p[maxa][maxa];
bool flag,vis[maxa][maxa];
void dfs(int x,int y,int mid){
    if(x==n){
        flag=1;
        return;
    }
    vis[x][y]=true;
    for(int i=0;i<4;++i){
        int nx=x+dx[i],ny=y+dy[i];
        if(nx<1||ny<1||nx>n||ny>m||vis[nx][ny]||p[nx][ny]>mid)continue;
        dfs(nx,ny,mid);
        if(flag)return;
    }
}
int main(){
    read(n);read(m);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            read(p[i][j]);
        }
    }
    int l=0,r=maxa;
    while(l<=r){
        int mid=(l+r)>>1;
        memset(vis,0,sizeof(vis));
        flag=false;
        dfs(1,1,mid);
        if(flag)r=mid-1;
        else l=mid+1;
    }
    printf("%d",l);
    return 0;
}
```

谢谢观看，请记住，我太弱了。

---

## 作者：Crybl (赞：2)

分析题目不管杂七杂八的看得出来，只要有一个士兵能通过这个迷阵，n行所有房间就都能被到达。所以题目转化为了，存在一条从1->n行的道路，使得这条道路上(x,y)点处p[x][y]的最大值最小。于是想到二分答案，因为找最大值的最小值，所以套用往左寻找的模板????
```cpp
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```
安利一下yxc大佬的二分模板????https://www.acwing.com/blog/content/31/

那我们怎么找这条路呢？显然，BFS让人感到欣慰。我们需要的仅仅是一个BFS模板，一个judge函数，还有最后道路存在性的判断。
1.bfs模板...参考网上扒
2.judge函数：三个判断，一是询问是否越界；二是询问的点p值是否大于mid值，如果大于，显然不可以入队；三就是是否曾经询问过。
3.道路存在性：当枚举的一个点（dx，dy）可到达时，判断是否到达第n行，如果到达，那么ans在mid的左区间，如果队列已空且仍未到达n行，ans就在mid的右区间。
所以这样，代码就出来了????

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<iostream>
using namespace std;
const int MAXN = 1e3+10;
int p[MAXN][MAXN];
int n,m;
int l=1001,r=0,mid;
bool vis[MAXN][MAXN]= {false};
int nowans=0,ans;

struct Node
{
	int x,y;
};

Node node;

int cx[]= {0,1,-1,0};
int cy[]= {1,0,0,-1};

inline bool judge(int x,int y,int pd)
{
	if(x>n||x<1||y>m||y<1) return false;
	if(p[x][y]>pd) return false;
	if(vis[x][y]) return false;
	return true;
}

inline bool bfs(int check)
{
	memset(vis,0,sizeof(vis));
	queue<Node> q;
	//for(int i=1; i<=m; ++i)
	//{
	node.x=1,node.y=1;
	q.push(node);
	vis[1][1]=true;
	while(!q.empty())
	{
		Node top=q.front();
		q.pop();
		for(int i=0; i<4; ++i)
		{
			int dx=top.x+cx[i];
			int dy=top.y+cy[i];

			if(judge(dx,dy,check))
			{
				node.x=dx,node.y=dy;
				q.push(node);
				vis[dx][dy]=true;
				if(dx==n) return true;//第一次到达n行房间即成功
			}
		}
	}
	//}
	return false;//未到达房间不成功
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=m; ++j)
		{
			scanf("%d",&p[i][j]);
			l=min(l,p[i][j]);
			r=max(r,p[i][j]);
		}
	}

	while(l<r)
	{
		mid=l+r>>1;
		if(bfs(mid)) r=mid;//当前mid下存在到达n行的道路,答案在左区间
		else l=mid+1;//不存在道路，答案在右区间
	}

	printf("%d",l);

	return 0;
}
```
还要求教一下，为什么我注释掉的那行for写进去不影响时间...
虽然都很慢....
# 说实话，感谢yxc大佬的二分模板，真滴好用!

---

## 作者：hahalidaxin2 (赞：2)

【思路】

二分+BFS判定。

二分途径的最大伤害x，标记p大于x的点为不可行，BFS判断能否到达n行的m个点即可。

【代码】

```cpp

#include<cstdio>
#include<queue>
#include<cstring>
#include<iostream>
#define FOR(a,b,c) for(int a=(b);a<=(c);a++)
using namespace std;

const int maxn = 1000+10;
const int dx[]={0,0,-1,1};
const int dy[]={1,-1,0,0};
struct Node{
    int x,y;
};
int p[maxn][maxn];
int n,m;

queue<Node> q;
bool vis[maxn][maxn];
bool inside(int x,int y) {
    return x>0 && x<=n && y>0 && y<=m;
}
bool can(int P) {
    memset(vis,0,sizeof(vis));
    q.push((Node){1,1}); 
    vis[1][1]=1;
    while(!q.empty()) {
        Node u=q.front(); q.pop();
        int x=u.x,y=u.y;
        FOR(i,0,3) {
            int xx=x+dx[i],yy=y+dy[i];
            if(inside(xx,yy) && !vis[xx][yy] && p[xx][yy]<=P) {
                vis[xx][yy]=1;
                q.push((Node){xx,yy});
            }
        }
    }
    FOR(i,1,m) if(!vis[n][i]) return false;
    return true;
}

int main() {
    scanf("%d%d",&n,&m);
    int L=0,R=0;
    FOR(i,1,n) FOR(j,1,m) scanf("%d",&p[i][j]) , R=max(R,p[i][j]);
    R++;
    while(L<R) {
        int M=L+(R-L)/2;
        if(can(M)) R=M;
        else L=M+1;
    }
    printf("%d\n",L);
    return 0;
} 

```

---

## 作者：空彦 (赞：2)


非常经典的一道二分+bfs

思路见代码注释


```cpp
#include<bits/stdc++.h>
using namespace std;

//方向数组，分别指定四个方向 
int xx[4]={1,-1,0,0};
int yy[4]={0,0,1,-1};

int n,m,l,r,mid,ans;

//a数组储存地图上某点的激光值，d[i][j]为bfs过程中到达某点的最短距离 
int a[1010][1010];
int d[1010][1010];

bool check(int r)
{
	queue<int> X;queue<int> Y;	//STL队列X,Y分别模拟bfs过程中的横纵坐标 
	
	//由于第一行与最后一行均无激光，不影响最后结果，只需从第一行的某点出发，到达最后一行的任一点即可 
	//这里选取(1,1)为起始点并加入队列 
	X.push(1);Y.push(1);		 
	
	//初始化距离数组为一个相对大的值 
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) d[i][j]=1234567890;
	
	//(1,1)点为起始点，设置距离为1 
	d[1][1]=0;
	
	//标准bfs过程
	//限制条件中要注意判定下一点是否符合本次函数调用的最大激光值，此处为函数实参r 
	while(!X.empty()&&!Y.empty()){
		int x=X.front();
		int y=Y.front();
		X.pop();Y.pop();
		for (int p=0;p<4;p++){
			if (x+xx[p]>=1 && x+xx[p]<=n && y+yy[p]>=1 && y+yy[p]<=m && a[x+xx[p]][y+yy[p]]<=r && d[x][y]+1<d[x+xx[p]][y+yy[p]]){
				X.push(x+xx[p]);
				Y.push(y+yy[p]);
				d[x+xx[p]][y+yy[p]]=d[x][y]+1;
			}
		}
	}
	
	//判定本次函数调用的最大激光值能否使士兵走到最后一行（其实判定d[n][1]一点即可） 
	for (int i=1;i<=m;i++) if (d[n][i]==1234567890) return false;
	else return true;
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) for (int j=1;j<=m;j++) scanf("%d",&a[i][j]);
	
	//题中指定最大激光为1000，左右分别设为0和1000，开始二分
	//当然也可以在输出地图a[i][j]时记录最大最小激光值，合理减少运算 
	l=0;r=1000;
	while(l<=r){
		mid=(l+r)/2;
		if (check(mid)){
			//check通过表明该激光值能够使士兵走到最后一行
			//而我们想要的是使激光值尽可能的小
			//因此调整右值为mid-1 
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	
	//输出结果 
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：傅思维666 (赞：1)

## 题解：

矩阵求路径的题大多数都和搜索有关，建议大家以后做这种题的时候直接拿搜索做切入口。

最大值最小/最小值最大的题一般都和二分有关系，建议大家以后做这种题的时候直接用二分做实现途径。

好了，综上所述，正解应该是二分答案+搜索。

从某种意义来讲，这题的check()函数只是实现二分的一个预处理，真正判断mid可不可行的部分是搜索，用flag变量判断区间的二分移动。

直接上代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=1e3+10;
int n,m,l,r,flag;
int map[maxn][maxn],v[maxn][maxn],vis[maxn][maxn];
int dx[]={0,0,0,-1,1};
int dy[]={0,1,-1,0,0};
int read()
{
    int x=0,f=1;char ch;ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void check(int x)
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(map[i][j]<=x)
                vis[i][j]=1;
            else
                vis[i][j]=0;
        }
}
void dfs(int x,int y)
{
    if(x==n)
    {
        flag=1;
        return;
    }
    for(int i=1;i<=4;i++)
    {
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(xx>0 && xx<=n && yy>0 && yy<=m)
            if(v[xx][yy]==0 && vis[xx][yy]==1)
            {
                v[xx][yy]=1;
                dfs(xx,yy);
                if(flag==1)
                    break;
            }
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            map[i][j]=read();
            r=max(r,map[i][j]);
        }
    while(l<r)
    {
        int mid=(l+r)>>1;
        flag=0;
        memset(v,0,sizeof(v));
        check(mid);
        dfs(1,1);
        if(flag==1)
            r=mid;
        else
            l=mid+1;
    }
    printf("%d",l);
    return 0;
}
```


---

## 作者：万弘 (赞：1)

先简化一下题目,给出最大伤害值,判断是否可行

只要一个记忆化dfs,剪掉越界和超出伤害值的即可

由于记忆化数组vis至多被修改nm次,所以时间复杂度$O(nm)$

```cpp
typedef long long ll;
ll n,m;
ll a[1001][1001];//伤害值
bool vis[1001][1001];//访问标记

void dfs(ll x,ll y,ll k)
{
	if(x<1||y<1||x>n||y>m||vis[x][y]||a[x][y]>k)return;//剪枝
	vis[x][y]=1;
	dfs(x+1,y,k);dfs(x,y+1,k);
	dfs(x-1,y,k);dfs(x,y-1,k);
}
bool check(ll k)//最大伤害值为k是否可行
{
	memset(vis,0,sizeof vis);//清空vis
	dfs(1,1,k);//第一行都为0,所以可以在第一行任意走,为了方便,从(1,1)开始
	return vis[n][1];//最后一行都为0,所以可以在最后一行任意走,如果(n,1)能到达,最后一行每个点都能到达
}
```

接下来看此题:

题目中说:
>  整个部队受到的伤害值为所有士兵的伤害值中的最大值......使得整个部队的伤害值最小。

所以二分答案即可

```cpp
//by wh
//time O(nmlogA)
#include<iostream>
#include<cstdio>
#include<cstring>
typedef long long ll;
ll n,m;
ll a[1001][1001];//伤害值
bool vis[1001][1001];//访问标记

void dfs(ll x,ll y,ll k)
{
	if(x<1||y<1||x>n||y>m||vis[x][y]||a[x][y]>k)return;//剪枝
	vis[x][y]=1;
	dfs(x+1,y,k);dfs(x,y+1,k);
	dfs(x-1,y,k);dfs(x,y-1,k);
}
bool check(ll k)//最大伤害值为k是否可行
{
	memset(vis,0,sizeof vis);//清空vis(要使用多次,所以切勿遗忘)
	dfs(1,1,k);//第一行都为0,所以可以在第一行任意走,为了方便,从(1,1)开始
	return vis[n][1];//最后一行都为0,所以可以在最后一行任意走,如果(n,1)能到达,最后一行每个点都能到达
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;++i)
		for(ll j=1;j<=m;++j)scanf("%lld",&a[i][j]);
	ll l=1,r=1000,mid;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%lld",r);
	return 0;
}
```

---


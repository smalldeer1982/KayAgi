# [NOI2015] 程序自动分析

## 题目描述

在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如 $x_i=x_j$ 或 $x_i\neq x_j$ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

## 说明/提示

【样例解释1】

在第一个问题中，约束条件为：$x_1=x_2,x_1\neq x_2$。这两个约束条件互相矛盾，因此不可被同时满足。

在第二个问题中，约束条件为：$x_1=x_2,x_1 = x_2$。这两个约束条件是等价的，可以被同时满足。

【样例说明2】

在第一个问题中，约束条件有三个：$x_1=x_2,x_2= x_3,x_3=x_1$。只需赋值使得 $x_1=x_2=x_3$，即可同时满足所有的约束条件。

在第二个问题中，约束条件有四个：$x_1=x_2,x_2= x_3,x_3=x_4,x_4\neq x_1$。由前三个约束条件可以推出 $x_1=x_2=x_3=x_4$，然而最后一个约束条件却要求 $x_1\neq x_4$，因此不可被满足。

【数据范围】

所有测试数据的范围和特点如下表所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/6f34qrmu.png)

## 样例 #1

### 输入

```
2
2
1 2 1
1 2 0
2
1 2 1
2 1 1```

### 输出

```
NO
YES
```

## 样例 #2

### 输入

```
2
3
1 2 1
2 3 1
3 1 1
4
1 2 1
2 3 1
3 4 1
1 4 0
```

### 输出

```
YES
NO```

# 题解

## 作者：追梦_Chen (赞：235)

这道题呢，其实就是一个小小的并查集啦。
### # **并查集的Get操作**
```cpp
int get(int x){
	if(x==fa[x])	return x;
    return fa[x]=get(fa[x]);//路径压缩
}
```
### # 并查集的Merge操作
```cpp
void merge(int x,int y){
	fa[get(x)]=get(y);
} // 可以直接写在程序里
```
# 特别提醒

	并查集一定要初始化，即fa[i]=i，表示i的爹是它自己
    嗯！一定要记得啊！
先排序，**把所有e==1的操作放在前面，然后再进行e==0的操作**，**在进行e==1的操作的时候**，我们只要把它约束的两个变量放在同一个集合里面即可。**在e==0**，即存在一条不相等的约束条件，对于它约束的两个变量，如果在一个集合里面，那就不可能满足！如不相等的约束条件都满足，那就YES。

还有啊，**我们要关注一下数据范围**，是有10的9次方那么大，如果开一个10的9次方大的fa数组的话，空间肯定超限，超限就凉凉（**亲身经历，请勿模仿，谢谢配合！！！**）所以，各位亲爱的小伙伴们，我们需要用到[离！散！化！](https://www.cnblogs.com/cytus/p/8933597.html)。

总得来说离散化有三步走战略：

1.去重（可以用到unique去重函数）

2.排序

3.二分索引（可以用到lower_bound函数）

**放代码**
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <cstdlib>
using namespace std;
int t,n,f[1000007],book[1000007*3];  //t表示t组数据，n表示有n个操作，f[]是我们并查集的数字，book[]是离散化的数组 
struct node{
    int x,y,e;
}a[1000001];  
bool cmp(node a,node b){
    return a.e>b.e;
}//排 序将e==1的放在前面 
inline void first(int kkk){
    for(int i=1;i<=kkk;i++)  f[i]=i;
}//初 始 化 
int get(int x){
    if(x==f[x]) return x;
    return f[x]=get(f[x]);
}
int main(){
    scanf("%d",&t);
    while(t--){
      int tot=-1;
      memset(book,0,sizeof(book));
      memset(a,0,sizeof(a));
      memset(f,0,sizeof(f));
    int flag=1;
        scanf("%d",&n);
       
        for(int i=1;i<=n;i++){
            scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].e);
            book[++tot]=a[i].x;
            book[++tot]=a[i].y;
        }
        sort(book,book+tot);//排序 
        int reu=unique(book,book+tot)-book;  //去重 
        for(int i=1;i<=n;++i){
           a[i].x=lower_bound(book,book+reu,a[i].x)-book;
           a[i].y=lower_bound(book,book+reu,a[i].y)-book;   
        } 
        first(reu);   //初始化 
        sort(a+1,a+n+1,cmp);  //按e排序 
        for(int i=1;i<=n;i++){
            int r1=get(a[i].x);
            int r2=get(a[i].y);
            if(a[i].e){
                f[r1]=r2;  //就是我们的merge操作 
            }else if(r1==r2){
                printf("NO\n");
                flag=0;  //如果不满足条件，标记为否 
                break;
            }
        }
        if(flag)    printf("YES\n");   //都满足条件了 
    }
    return 0;
}
```
不懂的小伙伴可以私信我，感谢您的阅读！

---

## 作者：Virvan (赞：60)

# **#P1955 程序自动分析 题解**
**大家都在用algorithm头文件离散，这时有一个问题：单次映射查询O（logN），还想优化怎么办？O（1）可不可以？！** 


下面来介绍我的算法：利用Hash表维护映射
	
       了解哈希的dalao知道如果维护的好，可以实现O（1）查询
###    我来大概点一点Hash表(散列表）

	   它一般由Hash函数与邻接表（链表结构）共同实现，与离散
    化思想类似，与离散化不同的是：同样将值域、范围变小，哈希
    可能造成两个原始值不同的信息被Hash函数映射为相同的值
    
       所以我们主要处理“Hash函数”和“冲突情况”
       1. 一般Hash函数的构造需要一个mod数，通常定义为 不大于
    n的最大素数 ，这样随机数据可以均匀的映射在构建的链表里。
       2. 同一个链中可能出现多个数，有一种“开散列”的解决案
    是，将原始值映射后值相同的归为一类，构成一个链，接在表头
    （映射值）之后，每条链的节点可以保存一些数据（我这道题就
    是利用开散列），之后依次遍历即可，因为依赖于Hash函数，构
    造的越好越接近O（1）
    
 下面上代码：
 ```
#define Max 100010
#define mod 99991 
struct node{
	int real,map;//真实值，映射值（此映射非彼映射，我们需要map参与并查集运算，real%mod才是hash映射）
}
vector <node> hash[Max]; 
int tot;//即结构体中的map映射，后面运算你会发现我们只考虑一个数出现的时间++tot，而不需要依靠大小相对映射，这里没必要
int map(int i,int j,bool k)
{
	int x,y,ok=1;
	int a = i % mod, b = j % mod;
  以下即映射查询的过程，看不懂发评论
	if(!hash[a].empty()){
		for(int l = 0; l < hash[a].size(); l++)
			if(i==hash[a][l].real) x = hash[a][l].map,ok = 0;
		if(ok) hash[a].push_back((node){i,++tot}),x = tot;
	}
	else hash[a].push_back((node){i,++tot}),x = tot;
	ok = 1;
	if(!hash[b].empty()){
		for(int l = 0; l < hash[b].size(); l++)
			if(j==hash[b][l].real) y = hash[b][l].map,ok = 0;
		if(ok) hash[b].push_back((node){j,++tot}),y = tot;
	}
	else hash[b].push_back((node){j,++tot}),y = tot;
	return ask(x,y,k); 
}
```
#### 与其他题解区别主要就是离散方式
下面AC代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector> 
#define Max 100010
#define mod 99991 

using namespace std;

int fa[2*Max],d[2*Max];
struct node{
	int real,map;
}un[Max];
vector <node> hash[Max]; 
int tot,cnt;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int ask(int i,int j,bool k)
{
	if(find(i)==find(j)) return 1;
	else if(k){
		fa[find(j)] = find(i);
		return 0;
	}
	return 0;
}
int map(int i,int j,bool k)
{
	int x,y,ok=1;
	int a = i % mod, b = j % mod;
	if(!hash[a].empty()){
		for(int l = 0; l < hash[a].size(); l++)
			if(i==hash[a][l].real) x = hash[a][l].map,ok = 0;
		if(ok) hash[a].push_back((node){i,++tot}),x = tot;
	}
	else hash[a].push_back((node){i,++tot}),x = tot;
	ok = 1;
	if(!hash[b].empty()){
		for(int l = 0; l < hash[b].size(); l++)
			if(j==hash[b][l].real) y = hash[b][l].map,ok = 0;
		if(ok) hash[b].push_back((node){j,++tot}),y = tot;
	}
	else hash[b].push_back((node){j,++tot}),y = tot;
	return ask(x,y,k); 
}
int main()
{
	int n;
	cin >> n;
	
	for(int i = 1; i <= n; i++)
	{
		for(int i = 1; i <= 200010; i++)
			fa[i] = i;
		for(int i = 0; i < 100000; i++)
			hash[i].clear();
		memset(d,0,sizeof(d));
		memset(un,0,sizeof(un));
        //以上每步的初始化不能丢
		cnt = tot = 0;
		int num,now = 1;
		cin >> num;
		for(int i = 1; i <= num; i++)
		{
			int x,y,z;
			cin >> x >> y >> z;
			if(z) map(x,y,1);
			else un[++cnt].real = x, un[cnt].map = y;	
		}
		for(int i = 1; i <= cnt; i++)
			if(map(un[i].real,un[i].map,0)){
				now = 0;
				cout << "NO" <<endl;
				break;
			}
		if(now) cout << "YES" << endl;
	}
	return 0;
}
```
     对比其他题解AC代码：3.13s 27.50MB
                     我：1.45s 8.52MB
               加入读优：334ms！！！
下面还需注意初始化问题：

我因为for(int i = 1; i <= 200010; i++)
			fa[i] = i;

写成for(int i = 1; i <= n; i++)
			fa[i] = i;
            WA了4个点
          
写成for(int i = 1; i <= 100000; i++)
			fa[i] = i;
            WA了第二个点

         大家有意可以翻我的记录（公开的）
~~本蒟蒻仅浅懂一些数据结构dalao勿喷~~

---

## 作者：览遍千秋 (赞：58)

我作为一个蒟蒻居然A了QAQ，那就详细说一说

---

## 并查集

并查集实际上是一个森林。

令一数组$f$记录每一个结点的爸爸，第$i$个结点的爸爸是$f_i$，当$f_i=i$时，也就是说它的爸爸是自己，即没有爸爸时，它就是根结点。

并查集有两种基本操作：``find``和``merge``

### find

俗称找爸爸。

本人习惯于使用递归实现

```cpp
int find(int x)
{
	if(f[x]==x) return x;
    else return find(f[x]);
}
```

即可，比较简单请自行理解

### merge

合并两棵树，直接把第2棵树的最早的祖先的爸爸改为第1棵树的最早的祖先

代码很简单：

```cpp
void merge(int a,int b)
{
	f[find(a)]=find(b);
}
```

### 路径压缩

按照上面的代码，很快这棵树就会变成类链的东西，那么每一次``find``操作的耗时就不能接受了。

我们考虑在整个过程中，我们只需要利用一个结点的最早的祖先，那么只需要每次``find``操作过程中，把这个结点的爸爸改成它最早的祖先。

只需要把``find``操作的代码稍作修改即可。

```cpp
int find(int x)
{
	if(f[x]==x) return x;
    else return f[x]=find(f[x]);
}
```

---

## 离散化

> 离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

来自百度~~（反正我一开始没看懂）~~

讲通俗一点，就是把一个可以很大的数据排个序，去个重，放在新的数组里，每次用二分找它在新数组的位置。

---

## 并查集和离散化

把$x$离散化之后，对于每一个$x$进行并查集操作

---

## 将条件转化为并查集的基本操作

两个$x$相等，则相当于在一个集合里，否则不在一个集合。

---

## 细节

进行限制条件的判断前，先按$e$排个序，$1$在前面，$0$在后面，为什么请自己思考

---

## 代码

~~直接复制你会爆零的~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 100007
#define maxnt 1000000007
struct node{
    int a,b,e;
}a[maxn];
int ttttt,f[maxn*2],x[maxn*2],n,lsh[maxn*2],nn,wz[maxn*2];
bool flag;
void mak()
{
    for(register int i=1;i<=nn;i++)	f[i]=i;
}
int find(int x)
{
    return f[x]==x?x:f[x]=find(f[x]);
}
bool comp(int a,int b)
{
    return a<b;
}
bool cmp(node a,node b)
{
    return a.e>b.e;
}
int er(int zz)
{
    int l=1,r=nn,m;
    while(l<=r)
    {
        m=(l+r)/2;
        if(lsh[m]==zz) return m;
        if(zz>lsh[m]) l=m+1;
        else r=m-1;
    }
    return zz;
}
int mian()
{
    scanf("%d",&ttttt);
    while(ttttt--)
    {
        scanf("%d",&n);
        nn=0;
        flag=0;
        for(register int i=1;i<=n;i++)
        {
            scanf("%d%d%d",&a[i].a,&a[i].b,&a[i].e);
            x[i*2-1]=a[i].a,x[i*2]=a[i].b;
        }
        sort(x+1,x+2*n+1,comp);
        for(register int i=1;i<=2*n;i++)
        {
            if(x[i]!=x[i-1])
            {
                lsh[++nn]=x[i];
//				wz[i]=nn;
            }
//			else wz[i]=wz[i-1];
        }
        mak();
        sort(a+1,a+n+1,cmp);
        for(register int i=1;i<=n;i++)
        {
            if(a[i].e)
            {
                int aaa=find(er(a[i].a)),bbb=find(er(a[i].b));
                if(aaa!=bbb) f[aaa]=bbb;
            }
            else
            {
                int aaa=find(er(a[i].a)),bbb=find(er(a[i].b));
                if(aaa==bbb)
                {
                    printf("NO\n");
                    flag=1;
                    break;
                }
            }
        }
        if(!flag) printf("YES\n");
    }
    
    return 0;
}
```

---

## 作者：bobxie (赞：30)

这是一道我所认为的比较重要的题目（尽管对于很多人来说很简单）。  

首先，这是一道很容易识破的并查集裸题（也许我看完题解前不会这么说），按照题目要求我们可以先排个序，把合并操作（题目中数字表示为1，即两个变量相等）放在前面预先执行，再进行判断操作（数字表示为0，即两个变量不相等）。  

但是由于题目中x的数量级达到了10^9，随意开一个这样大小的并查集数组，那么MLE以及CE什么的都在前方欢迎您。这里就要用到本蒟蒻不会的比较高级 的离散化（因为只有10^6个操作，不可能1~10^9所有的变量都用到了）。

离散化以后一切就比较简单了（都是些基本操作）。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define R register int
using namespace std;
inline int read()
{
    int f=1,x=0; char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=getchar();
    return f*x;
}
const int maxn=100005;
struct data
{
	int x,y,e;
}a[maxn];
inline bool cmp(data x,data y)
{
	return x.e>y.e;
}
int t,n,f[maxn],b[maxn<<2];//b数组至少要开两倍大小（虽然我开了4倍），因为刚开始要同时记录两个值
inline int find(int x)
{
	return x==f[x]?x:f[x]=find(f[x]);
}
int main()
{
	t=read();
	while (t--)
	{
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(f,0,sizeof(f));
		n=read();int tot=0;
		for (R i=1;i<=n;++i)
		{
			a[i].x=read();a[i].y=read();a[i].e=read();
			b[++tot]=a[i].x;//记录这些值
			b[++tot]=a[i].y;
		}
		sort(b+1,b+1+tot);
		int tott=unique(b+1,b+1+tot)-b;//algorithm中的函数，把数组去重，然后返回末尾指针。这里减一个b就可以表示b现在的大小了
		for (R i=1;i<=n;++i)
		{
			a[i].x=lower_bound(b+1,b+1+tott,a[i].x)-b;//十分实用的lower_bound，寻找b中>=a[i].x的第一个数的指针（因为a[i].x在b中一定存在，所以是直接求出a[i].x离散化后对应的值），减去b就是它的位置。
			a[i].y=lower_bound(b+1,b+1+tott,a[i].y)-b;
		}
        //--------------以下为正常操作
		for (R i=1;i<=tott;++i) f[i]=i;
		sort(a+1,a+1+n,cmp);
		bool ff=true;
		for (R i=1;i<=n;++i)
		{
			if (a[i].e==1)
			{
				int f1=find(a[i].x),f2=find(a[i].y);
				if (f1!=f2)
				{
					f[f1]=f2;
				}
			}else {
				int f1=find(a[i].x),f2=find(a[i].y);
				if (f1==f2)
				{
					ff=false;//找到一个不合理就可以退出了
					break;
				}
			}
		}
		if (ff==true) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

---

## 作者：谁是鸽王 (赞：16)

 

## 【题解】程序自动分析

upd2020年07月29日22:47:40:改正了一个事实错误，总时间复杂度$O(n\log^2 n)$(我那时太菜了)

upd2019年09月30日21:15:42:改写了代码，之前代码太丑了

[更好的阅读体验](https://www.cnblogs.com/winlere/p/10603890.html)

[**P1955** [NOI2015\]程序自动分析](https://www.luogu.org/problemnew/show/P1955) 

看到大家都是离线做的，我来发发在线怎么做。

这篇题解不适合作为学习并查集的文章，适合深入理解它。

等号显然具有传递性:$a=b ,b=c\ \rightarrow a=c$


我们发现不等号不具有传递性
$a\not =b ,b\not = c \ \ \rightarrow c \ \ ?\  \ a$
但是发现在一种情况下具有传递性
$$
a=b ,b\not =c\rightarrow a\not=c
$$
那么我们同样是并查集，并查集维护元素的相等，然后每个节点套一个$set$，用来存这个不等于节点的节点是哪些，同时使用按秩合并和路径压缩，每次$query$的时候一边把路径压缩一边把$set$的内容全部移动到当前的根上。

并查集复杂度$O(n\log n)$，关于set的那一块复杂度是启发式合并的复杂度$O(n\log^2 n)$。

```cpp
#include <bits/stdc++.h>

using namespace std; typedef long long ll;
inline int qr(){
      register int ret=0,f=0;
      register char c=getchar();
      while(c<48||c>57)f|=c==45,c=getchar();
      while(c>=48&&c<=57) ret=ret*10+c-48,c=getchar();
      return f?-ret:ret;
}


map<ll, int> mp;
struct R {
      set<int> data;
      int f;
}r[200001];

inline int q(const int&x) {
      int t=x,i=x,temp;
      while(r[t].f^t) t = r[t].f;
      while(r[i].f^i){
	    if(r[i].data.size())
		  r[t].data.insert(r[i].data.begin(),r[i].data.end()),r[i].data.clear();
	    temp=r[i].f,r[i].f=t,i=temp;
      }
      return t;
}

inline void j(int t1, int t2) {
      if(r[t1].f==r[t2].f) return;
      if(r[t1].data.size()<r[t2].data.size())
	    swap(t1, t2);
      for(auto t:r[t2].data) r[q(t)].data.insert(t1);
      r[t1].data.insert(r[t2].data.begin(),r[t2].data.end());
      r[t2].data.clear();
      r[t2].f = t1;
}

int main(){
      int T=qr();
      while(T--){
	    int n=qr(),cnt=0,f=1;
	    mp.clear();
	    for(int t=1;t<=n*2;++t) r[t].f=t,r[t].data.clear();
	    for(int t=1,t0,t1,t2;t<=n;++t){
		  t1=qr();t2=qr();t0=qr();
		  if(!f)continue;
		  t1=mp.find(t1)==mp.end()?mp[t1]=++cnt:mp[t1];
		  t2=mp.find(t2)==mp.end()?mp[t2]=++cnt:mp[t2];
		  if (t1=q(t1),t2=q(t2),t0)
			if(r[t1].data.find(t2)!=r[t1].data.end()) f=0;
			else j(t1,t2);
		  else
			if (t1==t2) f=0;
			else r[t1].data.insert(t2),r[t2].data.insert(t1);
	    }
	    if(f) puts("YES");
	    else  puts("NO");
      }
      return 0;
}

```



---

## 作者：一只萌新 (赞：15)

[题目](https://www.luogu.org/problemnew/show/P1955)

题意很明显了，**并查集**基本操作

**我们把所有操作存下来，离线先处理合并（即要求相等），再对每个要求不相等判断根是否相同即可**

以上思路很好想，其他题解也有详细描述，这篇题解主要想说的是：

## 离散化

* **“离散化”是把无穷大集合中的若干个元素映射为有限集合以便于统计的方法**

首先由题目$i$，$j$的规模：**1<=i,j<=1e9**
可知需要离散化 

离散化一般有三种方法

## 1.map

这个相信大家都会，不过似乎容易被卡，这里不讨论

## 2.unique函数

**algorithm中的函数,把数组去重(不真正把重复的元素删除),然后返回末尾指针**（某题解）

这也是大多数题解使用的方法

我一开始是这样写的：（注释来自某题解）
```cpp
il void lsh(){						//离散化  
    sort(book+1,book+cnt+1);
    reu=unique(book+1,book+cnt+1)-book; 
    //algorithm中的函数,把数组去重,然后返回末尾指针.这里减一个b就可以表示b现在的大小了 
	for(re int i=1;i<=n;++i){
		a[i].x=lower_bound(book+1,book+reu+1,a[i].x)-book;	
        //十分实用的lower_bound,寻找b中>=a[i].x的第一个数的指针 
        //因为x在b中一定存在,所以是直接求出x离散化后对应的值,减去b就是它的位置  
        a[i].y=lower_bound(book+1,book+reu+1,a[i].y)-book;
	}
}

```

然后我wa了第三个点 测出我错误的数据是：
```cpp
2
4
8 2 0
2 9 1
2 7 1
9 7 0
3
9 2 0
1 3 1
2 3 1

NO
YES
```
我仔细对照题解，发现我加上（pre就是祖先数组）
```cpp
memset(pre,0,sizeof(pre));	

```
就AC了

但我想不明白啊
**按理说pre每次使用前会有初始化为自己的过程，需要使用的部分明明可以直接覆盖**
```cpp
 for(re int i=1;i<=reu;++i) pre[i]=i;
```

当我输出一些中间变量时发现
```cpp
对于
3
9 2 0
1 3 1
2 3 1

映射出来
1->1 2->2 3->3 9->6 （what？和自己想的不一样啊）
而此时reu=5
memset后询问时 一个数的根为0 才得到正确答案
```

那么关于**unique离散化的正确性？？**

网上各种博客看不懂，对unique完全不知道怎么用，它返回的到底是什么呢？？

**求dalao评论区解惑QAQ**

## 3.不使用map/unique

模板：
```cpp
il void lsh(){
    sort(book+1,book+cnt+1);
	for(re int i=1;i<=cnt;++i)
		if(i==1||book[i]!=book[i-1]) b[++m]=book[i];
}
il int query(int x){
	return lower_bound(b+1,b+m+1,x)-b;
}

```
不需要对pre初始化0 

中间数据
```cpp
2 -> 1
7 -> 2
8 -> 3
9 -> 4
NO
1 -> 1
2 -> 2
3 -> 3
9 -> 4
YES
```
嗯这才是我想要的映射

### AC代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define re register
#define il inline
#define ll long long
using namespace std;

inline int read(){
    int s=0,f=0;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-'),c=getchar();
    while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
    return f?-s:s;
}

const int N=1e5+5;
int t,n,pre[N],cnt;
struct no{
    int x,y,op;
}a[N];
il bool cmp(no x,no y){return x.op>y.op;}

int book[N<<2],b[N<<2],m;

il void init(){
    for(re int i=1;i<=m;++i) pre[i]=i;
}
int find(int x){
    return pre[x]==x?x:pre[x]=find(pre[x]);
}
bool fl;

il void lsh(){
    sort(book+1,book+cnt+1);
	for(re int i=1;i<=cnt;++i)
		if(i==1||book[i]!=book[i-1]) b[++m]=book[i];
}
il int query(int x){
	return lower_bound(b+1,b+m+1,x)-b;
}
int main(){
    t=read();
    while(t--){
        memset(book,0,sizeof(book));cnt=m=0,fl=1;
    	
        n=read();
        for(re int i=1;i<=n;++i){
            a[i].x=read(),a[i].y=read(),a[i].op=read();
            book[++cnt]=a[i].x,book[++cnt]=a[i].y;
        } 
        
        lsh();
        
        sort(a+1,a+n+1,cmp);
        init();
        for(re int i=1;i<=n;++i){
            int x=query(a[i].x),y=query(a[i].y);
            int fx=find(x),fy=find(y);
            if(a[i].op==1) pre[fx]=fy;
            else if(fx==fy){
                puts("NO");fl=0;break;
            } 
        }
        if(fl) puts("YES");
    }
    return 0;
}

```
**求解惑**

---

## 作者：Slr神龙人 (赞：11)

很普通的并查集，把相等的数合并，用不相等的条件来判断，如果已经合并的两个数却不相等则输出“No”。至于离散化我太菜了我也不清楚是什么，随便膜个数就可以了（可以试试你女朋友的生日），不多说了直接上代码

```cpp
#include<iostream>
using namespace std;
long long father[1000001];
long long w1[100001],w2[100001];
int find(int x)
{
    if(father[x]==x)return father[x];
    father[x]=find(father[x]);
    return father[x];
}
void unionn(int r1,int r2)
{
    father[r1]=r2;
}
int main()
{
    int g;
    cin>>g;
    for(int k=1;k<=g;k++)
    {
        long long n,x,y,e,tot=0,pd=0;
        cin>>n;
        for(int i=1;i<=1000001;i++)
            father[i]=i;
        for(int i=1;i<=n;i++)
        {
            cin>>x>>y>>e;
            x%=520817;
            y%=520817;
            if(e==1)
            {
                int r1=find(x);
                int r2=find(y);
                unionn(r1,r2);
            }
            else
            {
                w1[++tot]=x;
                w2[tot]=y;
            }
        }
        for(int i=1;i<=tot;i++)
            if(find(w1[i])==find(w2[i]))
                pd=1;
        if(pd==1)cout<<"NO"<<endl;
        else cout<<"YES"<<endl;
    }
    return 0;
}
```

---

## 作者：吃瓜群众syc (赞：10)

首先明确一点：相等具有传递性，不相等不具有传递性（Eg:若x1等于x2,x2等于x3时,显然x1=x3。但当x1不等于x2,x2不等于x3时,x1不一定不等于x3）。

因此，**所有ei相等的的约束条件之间互不冲突。**

所以，**只有在当ei=0的约束条件与已有的其他ei=1的约束条件发生冲突时，程序才会输出NO。**

大体思路：

开一个并查集，这个并查集维护的是一个或多个相等的数的集合:

1.将形似(xi,xj,ei(=1))的约束条件看做为一个将xi,xj两个数所属的集合合并为一个集合的操作（这个操作是个简单的并查集合并）；

2.将形似(xi,xj,ei(=0))的约束条件看做一个询问操作。如果fa[xi]=fa[xj],那么这些约束条件即为发生了冲突（fa[xi]=fa[xj]说明xi=xj，但当前的约束条件告诉你xi不等于xj，故冲突）。

**提醒：先执行ei=1的操作，再执行ei=0的操作（因为我们是拿ei=0的操作去和所有ei=1的操作去比较看是否冲突）。**

最后注意xi和xj的数据范围（1<=xi,xj<=1e9),所以离散化输入的xi,xj（不然并查集数组开不下）。

**Code：**### 

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
#define ri register int
using namespace std;

const int MAXN=200020;
int t,n,fa[MAXN],tot,cnt[MAXN],sum,sj,r1,r2;
struct node{
    int x1,x2,e;
}inf[MAXN];
map<int,int>hs;//借用map离散化x1,x2

inline int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')	ch=getchar();
    while('0'<=ch&&ch<='9')
    {
        x=(x << 3)+(x << 1)+(ch-'0');
        ch=getchar();
    }
    return x;
}

bool cmp(node a,node b)//将约束条件中ei=1的操作放到前面操作 
{
    return a.e > b.e;
}

int find(int x)//查询x所在集合的标号 
{
    if(x==fa[x])	return x;
    return fa[x]=find(fa[x]);//路径压缩
}

void work()
{
    tot=0;//tot:记录cnt数组的大小 
    //因为忘写这句话又调了将近一个小时啊啊啊
    n=read();
    for(ri i=1;i<=n;i++)
    {
        inf[i].x1=read(),inf[i].x2=read(),inf[i].e=read();
        cnt[++tot]=inf[i].x1,cnt[++tot]=inf[i].x2;//将x1,x2压倒cnt数组中，方便离散。 
    }
    
    sort(cnt+1,cnt+tot+1);
    hs[cnt[1]]=1,sum=1;
    for(ri i=2;i<=tot;i++)//离散化 
        if(cnt[i]!=cnt[i-1])	hs[cnt[i]]=++sum;
        
    for(ri i=1;i<=sum;i++)	fa[i]=i;
    sort(inf+1,inf+n+1,cmp);//注意先执行Ei=1的操作，再逐一判断Ei=0的操作是否与以前的相等关系互相冲突。 
    sj=n+1;//初始化sj（没这句话会执行work函数中最后的那一个for循环） 
    for(ri i=1;i<=n;i++)
    {
        if(!inf[i].e)	{ sj=i; break;}
        inf[i].x1=hs[inf[i].x1],inf[i].x2=hs[inf[i].x2];
        r1=find(inf[i].x1),r2=find(inf[i].x2);
        if(r1!=r2)	fa[max(r1,r2)]=min(r1,r2);
    }
    
    bool flag=0;
    for(ri i=sj;i<=n;i++)//查询ei=0的约束条件是否与之前ei=1的约束条件冲突 
    {
        inf[i].x1=hs[inf[i].x1],inf[i].x2=hs[inf[i].x2];
        r1=find(inf[i].x1),r2=find(inf[i].x2);
        if(r1==r2)	{ flag=1; break; }
        //fa[xi]=fa[xj]说明xi=xj，但当前的约束条件告诉你xi不等于xj，故冲突
    }
    if(flag)	cout<<"NO"<<'\n';
    if(!flag)	 cout<<"YES"<<'\n';
}

int main()
{
    t=read();
    for(ri i=1;i<=t;i++)	work();
    return 0;
}
```





---

## 作者：hawa130 (赞：10)

~~（看没有人写使用 vector 的题解，前来水一发）~~  

思路和大家都一样，就是离散化+并查集。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxN = 2e5 + 10;
struct node {
	int x, y, e;
	bool operator < (const node &rhs) const {
		return e > rhs.e;
	}
} data[maxN];
int n, T;
int par[maxN];
void init(int len) {
	for (int i = 1; i <= len; i++) par[i] = i;
}
int find(int x) {
	return par[x] == x ? x : par[x] = find(par[x]);
}
bool same(int x, int y) {
	return find(x) == find(y);
}
void unite(int x, int y) {
	if (!same(x, y)) par[find(y)] = par[x];
}
int main() {
	scanf("%d", &T);
	while (T--) {
		vector<int> vec;
		bool flag = true;
		memset(data, 0, sizeof(data));
		memset(par, 0, sizeof(par));
		scanf("%d", &n);
		for (int i = 1; i <= n; i++) {
			scanf("%d%d%d", &data[i].x, &data[i].y, &data[i].e);
			vec.push_back(data[i].x);
			vec.push_back(data[i].y);
		}
		sort(vec.begin(), vec.end());
		vec.erase(unique(vec.begin(), vec.end()), vec.end());	// vector 的去重
		for (int i = 1; i <= n; i++) {
			data[i].x = lower_bound(vec.begin(), vec.end(), data[i].x) - vec.begin();
			data[i].y = lower_bound(vec.begin(), vec.end(), data[i].y) - vec.begin();
		}
		init(vec.end() - vec.begin());	// 这里用新的 vector 的长度来初始化并查集
		sort(data + 1, data + n + 1);
		for (int i = 1; i <= n; i++)
			if (data[i].e) unite(data[i].x, data[i].y);
			else if (same(data[i].x, data[i].y)) flag = false;
		printf("%s\n", flag ? "YES" : "NO");
	}
}
```

---

## 作者：xyz32768 (赞：7)

首先将所有的$i$和$j$离散化。

先处理相等的条件。因为相等具有传递性，所以这里用并查集维护相等关系，在同一个连通块中的变量全部相等。即连边$(i,j)$。

然后处理不等的条件。可以发现，如果$i$和$j$在同一个连通块里，那么就同时存在$x_i=x_j$和$x_i\neq y_i$，这显然是矛盾的。所以对于所有的不等条件，如果存在一个条件的$i$和$j$在同一个连通块里，那么不可以被满足，否则可以被满足。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 2e5 + 5;
int n, m, fa[N], a[N];
struct cyx {
    int x, y, op;
} que[N];
int cx(int x) {
    if (fa[x] != x) fa[x] = cx(fa[x]);
    return fa[x];
}
void zm(int x, int y) {
    int ix = cx(x), iy = cx(y);
    if (ix != iy) fa[iy] = ix;
}
void work() {
    int i, tot = 0; n = read();
    for (i = 1; i <= n; i++) a[++tot] = que[i].x = read(),
        a[++tot] = que[i].y = read(), que[i].op = read();
    sort(a + 1, a + tot + 1); m = unique(a + 1, a + tot + 1) - a - 1;
    for (i = 1; i <= n; i++) {
        que[i].x = lower_bound(a + 1, a + m + 1, que[i].x) - a;
        que[i].y = lower_bound(a + 1, a + m + 1, que[i].y) - a;
    }
    for (i = 1; i <= m; i++) fa[i] = i;
    for (i = 1; i <= n; i++) if (que[i].op == 1)
        zm(que[i].x, que[i].y);
    for (i = 1; i <= n; i++) if (que[i].op == 0 && cx(que[i].x) == cx(que[i].y))
        return (void) (puts("NO")); puts("YES");
}
int main() {
    int T = read();
    while (T--) work();
    return 0;
}
```

---

## 作者：panyf (赞：5)

看到楼上各位都是用离散化，O(nlogn)的复杂度，我就来一发不用任何STL纯手写的哈希表，复杂度O(n)，优于离散化

离散化适用于数据之间需考虑大小关系的题目，此题不考虑大小关系，因此哈希表就可以了

首先，需要选一个1000000左右的模数

之后，每输入一行，若e=0，就用数组记录i,j，否则就将i,j存入哈希表，同时进行合并操作：
```cpp
inline int ins(ci&x){
	ri v=x%M;//M为模数
	if(he[v]==0){
		ne[++t]=0,to[t]=x,he[v]=t;
		st[++tp]=v,f[t]=t;//st数组是优化清空用的，f为并查集的数组
		return t;//这里返回值为对应的位置
	}
	for(ri i=he[v];i;i=ne[i]){
		if(to[i]==x)return i;//如果已经存入就直接返回
	}
	ne[++t]=he[v],to[t]=x,he[v]=t,f[t]=t;
	return t;
}
```
接下来判断所有e=0的情况，判断是否满足，此时需要用到哈希表查找操作：
```cpp
inline int qry(ci&x){
	ri v=x%M;
	for(ri i=he[v];i;i=ne[i]){
		if(to[i]==x)return i;//返回对应位置
	}
	return 0;//没找到就返回0
}
```
判断的部分：
```cpp
for(ri i=0;i<u;i++){
	if(a[i]==b[i]){//特判i,j相等的情况
		puts("NO");
		goto END;
	}
	p=qry(a[i]),q=qry(b[i]);
	if(p&&q&&getf(p)==getf(q)){//若p与q在同一集合中就退出
		puts("NO");
		goto END;
	}
}
puts("YES");//未退出就输出YES
END:;
```
注意多测要清空：
```cpp
void clr(){
	while(tp)he[st[tp--]]=0;//优化，把改变了he值的v全部存入栈，之后只需清空栈中的数
	t=u=0;
}
```
还要注意并查集需要路径压缩：
```cpp
inline int getf(ci&x){
	return f[x]==x?x:f[x]=getf(f[x]);
}
```
[AC记录，无O2仅301ms](https://www.luogu.org/record/23736258)

---

## 作者：rainygame (赞：4)

**STL 大法好！**

首先，注意到等式的传递性，可以考虑使用并查集维护。对于 $e=1$ 的直接合并，对于 $e=0$ 的存起来，到最后一起判断。一旦发现两个 $e=0$ 的在同一个集合，直接判 `NO`，否则就是 `YES`。

但是又可以发现，$i,j \le 10^9$。所以不可以直接使用并查集，所以考虑离线后离散化。我发现题解区都是先 `sort` 排序、再 `unique` 去重、最后 `lower_bound` 查找。

但是还有更加简单的方法。我们可以想到用 `set` 担任排序和去重的任务，然后用 `map` 建立映射以绑定原数据和离散化后数据：首先将需要离散化的数据塞进 `set` 里，再把它们一个个提出来（这样就是排序+去重的数据了），每个用 `map` 进行对离散化后下标的映射（具体看代码）。这种方法的好处是方便快捷，且非常好调试；缺点则是无法使用排序及去重后的数据，且每次调用离散化后的值都需要 $O(\log n)$ 的时间复杂度。

综上所述，我们可以以超大常数的 $O(Tn \log n)$ 来求出答案。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1000001

int t, n, flag, ind;
int x[MAXN], y[MAXN], e[MAXN];
vector<pair<int, int>> vec;
set<int> st;
map<int, int> ha;  // 自欺欺人 

struct dsu{  // 并查集模板 
	int f[MAXN<<1];  // 注意开两倍 
	dsu(int n){
		iota(f+1, f+(n<<1)+1, 1);
	}
	
	void unite(int x, int y){
		f[find(x)] = find(y);
	}
	
	int find(int x){
		if (f[x] == x) return x;
		return f[x] = find(f[x]);
	}
};

int main(){
    cin >> t;
    
    while (t--){
    	cin >> n;
    	dsu D(n);
    	vec.clear();  // 多测不清空，保龄两行泪 
    	st.clear();
    	ha.clear();  // 后面用到的都是最新的，所以不需要清空 
    	for (int i(1); i<=n; ++i){
    		cin >> x[i] >> y[i] >> e[i];
    		st.insert(x[i]);  // 插入 
    		st.insert(y[i]);
		}
		ind = 0;
		for (auto i: st) ha[i] = ++ind;  // 标记下标 
		
		for (int i(1); i<=n; ++i){
			if (e[i]) D.unite(ha[x[i]], ha[y[i]]);  // 合并 
			else vec.push_back(make_pair(ha[x[i]], ha[y[i]]));  // 存一下 
		}
		
		flag = 0;
		for (auto i: vec){
			if (D.find(i.first) == D.find(i.second)){  // 发现矛盾 
				flag = 1;
				break;  // 直接判错 
			}
		}
		
		cout << (flag ? "NO" : "YES") << endl;
	}

    return 0;
}

```

感谢 @xushuxin 提出编译问题，看起来是代码放错了。

---

## 作者：封禁用户 (赞：4)

思路是先把等号的两个数用并查集连起来。


再扫一遍不等号，如果这两个数在同一集合内，就NO，返回。


如果成功扫完了，输出YES。


但是这题数据这么大，必须离散化。


lower\_bound是个好东西啊，找到第一个不小于某个数的位置，这样就能方便我们进行离散化了。


楼下的dalao都说是普及组难度，本蒟蒻真是服了。


我拿普一的时候数据结构还没入门呢！


下面是代码，写的不算太丑吧

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <stack>
#include <ctime>
#include <cmath>
#include <map>
#include <set>
#include <queue>
#include <list>
#include <vector>
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int j=m;j>=n;j--)
#define lowbit(x) (x&(-x))
using namespace std;
const int maxn=100010;
long long f[2*maxn+100];
long long n,T,a[maxn],b[maxn],c[maxn],e[2*maxn];
void cch(){
    rep(i,1,2*n) f[i]=i;
}
int find(int x){
    return f[x]==x?x:f[x]=find(f[x]);
}
void merge(int x,int y){
    f[find(y)]=f[find(x)];
}
bool ask(int x,int y){
    return find(x)==find(y);
}
void Work(){
    int tmp=0;
    cin>>n;
    cch();
    memset(e,0,sizeof(e));
    rep(i,1,n){
       cin>>a[i]>>b[i]>>c[i];
       e[++tmp]=a[i];
       e[++tmp]=b[i];
    }
    sort(e+1,e+tmp+1);
    rep(i,1,n)
       if(c[i])
         merge(lower_bound(e+1,e+tmp+1,a[i])-e,lower_bound(e+1,e+tmp+1,b[i])-e);
    rep(i,1,n)
       if(!c[i])
         if(ask(lower_bound(e+1,e+tmp+1,a[i])-e,lower_bound(e+1,e+tmp+1,b[i])-e)){
           printf("NO\n");
           return ;
         }
    printf("YES\n");
    return ;
}
int main(){
    ios::sync_with_stdio(false);
    cout.tie(0);
    cin>>T;
    while(T--)
      Work();
    return 0; 
}
```

---

## 作者：immortalCO (赞：4)

普及组难度。

首先对变量编号进行离散化，这用sort、unique、lower\_bound函数可以轻松完成。

先对于所有相同的约束，把这些变量加入同一个并查集。

然后对于不同的约束，判断是否属于同一个集合，如果存在一个是，则NO。


---

## 作者：why_always_china (赞：3)

代码我就不写了，我是Pas党，记录里都是C++......

这道题是普及组难度没错，但并查集是高级数据结构，似乎并不是普及组的考查范围。

所以，在离散化之后，这道题可以用**图论**做（不过会比并查集麻烦，谁叫你不会并查集呢）。

具体方法就是，处理所有的式子，把等式关系建成一个图，x1,x2之类的就是顶点，相等就连一条边。

这样处理完之后，我们就可以使用floodfill算法，把互相连通的点都染上同一种颜色，各个连通分量之间颜色不同。

再比较所有不等式两边的顶点颜色，相同就不能成立。

这样普及组也可以做了。



---

## 作者：Linne (赞：3)

这道题其实是很水的QAQ

------------

并查集的思路已经很明显了:首先把“相等”的条件搞好，也就是用并查集并起来。之后遍历所有“不等”的条件，只要有一对在同一个集合里，就不可能满足。

------------

然而，数据范围中i,j<=1e9，这个条件非常的跳。我们要先用离散化搞一下。楼上的大佬们都是用的sort+unique，这里我换个方法：用map映射。具体实现方法是：每读到一个在Map里没有映射的i(或j)，我们就创建一个映射。最终，Map里的value都在[1,2n]这个区间里，接下来就很好搞了。

------------

啊，还有，上面那个2n很重要，我第一次开了n的空间，结果基佬紫了。

------------

附AC代码ORZ
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,x,y,e,fa[200005],flag,cnt;
vector<pair<int,int> >vec;
map<int,int>Map;
void init(){
    for(int i=1;i<=2*n;++i)fa[i]=i;
}
int fd(int x){
    return fa[x]==x?x:fa[x]=fd(fa[x]);
}
bool in_one(int x,int y){
    return fd(x)==fd(y);
}
void U(int x,int y){
    fa[fd(x)]=fd(y);
}
int main(){
    ios::sync_with_stdio(0);
    cin>>t;
    while(t--){
        Map.clear();
        cnt=0;
        cin>>n;
        vec.clear();
        init();
        flag=0;
        for(int i=1;i<=n;++i){
            cin>>x>>y>>e;
            if(Map.find(x)!=Map.end())x=Map[x];
            else {Map[x]=++cnt;x=cnt;}
            if(Map.find(y)!=Map.end())y=Map[y];
            else {Map[y]=++cnt;y=cnt;}
            if(e){
                U(x,y);
            }else{
                vec.push_back(make_pair(x,y));
            }
        }
        for(vector<pair<int,int> >::iterator it=vec.begin();it!=vec.end();++it){
            if(in_one(it->first,it->second)){
                cout<<"NO"<<endl;
                flag=1;
                break;
            }
        }
        if(!flag)cout<<"YES"<<endl;
    }
    return 0;
}

```


---

## 作者：Palace (赞：3)

[走你](https://www.luogu.org/problemnew/show/P1955)

## 思路：

按秩合并和路径压缩在这道题都能用，对那些用两种优化如同写板子的OIer们算是很友好了。这道题总体思路是把条件相等的合并，条件不等的则判断是否已经在一个集合中，如果是则不成立。具体的来说，离线来做是个不错的选择。先将数据都读入，使e为1的在前，e为0的在后，先全部合并在判断，这样做对最后结果是没有影响的，该矛盾还是要矛盾。这样可以省去记录条件不等的i和j这件麻烦事。因为有些i和j非常大，我们可以在读入的时候模一个大质数（这样其实就可以A掉这道题，但不是最好的办法→离散化）。


------------

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define clr(a) memset(a,0,sizeof(a))
using namespace std;
struct haha{LL x,y,e;}a[1000010];
LL n,m,mod=100000007;
LL fa[1000010],h[1000010],uni[1000010<<1];//uni是用来离散化的数组 
bool flag;
bool cmp(haha x,haha y){return x.e>y.e;}
LL get(LL x){return fa[x]==x?fa[x]:fa[x]=get(fa[x]);}//路径压缩 
void merge(LL x,LL y){//按秩合并 
	LL fx=get(x);
	LL fy=get(y);
	if(fx!=fy){
		if(h[fx]>=h[fy]){
			h[fx]+=h[fy];
			fa[fy]=fx;
		}
		else{
			h[fy]+=h[fx];
			fa[fx]=fy;
		}
	}
}
void first(LL k){//初始化 
	for(LL i=1;i<=k;i++){
		h[i]=1;
		fa[i]=i;
	}
}
int main(){
	scanf("%lld",&m);
	while(m--){
		LL cnt=0;
		clr(a);clr(uni);
		scanf("%lld",&n);
		for(LL i=1;i<=n;i++){
			scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].e);
			a[i].x%=mod;a[i].y%=mod;//避免过亿的数据，模大质数 
			uni[++cnt]=a[i].x;uni[++cnt]=a[i].y;
		}
		sort(uni+1,uni+1+cnt);//45~50：离散化，优化时空效率 
		LL len=unique(uni+1,uni+1+cnt)-uni-1;
		for(LL i=1;i<=n;i++){
			a[i].x=lower_bound(uni+1,uni+1+len,a[i].x)-uni-1;
			a[i].y=lower_bound(uni+1,uni+1+len,a[i].y)-uni-1;
		}
		first(len);
		flag=0;
		sort(a+1,a+1+n,cmp);
		for(LL i=1;i<=n;i++){
			LL xx=get(a[i].x);
			LL yy=get(a[i].y);
			if(a[i].e==1)
				merge(xx,yy);
			if(a[i].e==0)
				if(xx==yy){
					printf("NO\n");
					flag=1;
					break;
				}
		} 
		if(!flag) printf("YES\n");
	}
	return 0;
}

```

---

## 作者：xryjr233 (赞：2)

首先很容易想到并查集维护,将相等的数merge起来。但是我们很难维护不等的情况。

那怎么办?

我们发现我们可以查询两数不等是否成立,只是不能维护它而已,并且事实上,不等没有类似$a\ne b,b\ne c,\texttt{则}a\ne c$的性质。

所以我们可以变更维护顺序。

先在并查集里维护等于的关系(也就是先处理$e=1$的约束),然后对于每一个不等约束条件$a\ne b$,判断$a,b$是否在同一并查集里。

至于数据范围是$10^9$,开个map把每一个出现的未知数编号对应到$[1,n]$范围内的整数上就好了。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,u,v,cnt,tu,tv,op,ne[100010][2],sz,f[200010];
map<int,int>mp;
int getf(int x){
    return f[x]==x?x:f[x]=getf(f[x]);
}
void merge(int x,int y){
    if(getf(x)==getf(y))return;
    f[f[x]]=f[y];
}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=2*n;i++)f[i]=i;
        mp.clear();
        cnt=0;
        sz=0;
        for(int i=1;i<=n;i++){
            scanf("%d%d%d",&u,&v,&op);
            tu=mp[u];
            if(!tu)tu=mp[u]=++cnt;
            tv=mp[v];
            if(!tv)tv=mp[v]=++cnt;
            if(!op)ne[++sz][0]=tv,ne[sz][1]=tu;
            else merge(tu,tv);
        }
        for(int i=1;i<=cnt;i++)getf(i);
        for(int i=1;i<=sz;i++)
            if(f[ne[i][0]]==f[ne[i][1]]){
                puts("NO");
                goto END;
            }
        puts("YES");
        END:
        ;
    }
    return 0;
}
```

---

## 作者：人间凡人 (赞：2)

这道题是一道**并查集**的模板题目，其实还是比较简单的啦！

 $find$ 函数 用来查找x的父亲，相信大家也一定会的吧。

```cpp
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
```


 $merge$ 函数 可以做两个相等的约束条件i与j合并到一起的操作，话不多说，贴代码！！！

```cpp
void merge(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx==fy)return;
	fa[fx]=fy;
}
```

 本题大致思路：因为要读入$2n$个数 ， 我们可以将读入的数排序后再去重（简称离散化）。那是因为 输入的$i$与$j$都很大 但是$n$却很小 这也就是解题的一个突破口。

 然后我们需要知道读入的数 在离散化后数中的位置 因此就需要去遍历 如果采用暴力  那么时间便会巨长无比  可是 大家不要忘记了  离散化后的数是有顺序的  所以 我们可以采用二分查找 的 妙招 ！！！

 好，代码，走你！！！


```cpp
#include<bits/stdc++.h>
#define N 400005
using namespace std;
int n,T,x,y,tot,num,a[2N],b[N],c[N],d[2N],fa[N];
bool flag;
	int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void merge(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx==fy)return;
	fa[fx]=fy;
}
bool change(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx==fy)return false;
	return true;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d%d%d",&a[i2-1],&a[i2],&c[i]);
			d[i2-1]=a[i2-1];d[i2]=a[i2];
		}
		sort(d+1,d+2*n+1);num=tot=0;b[0]=-1;
		for(int i=1;i<=2*n;i++)
			if(d[i]!=b[tot])b[++tot]=d[i];
		for(int i=0;i<=tot;i++)fa[i]=i;
		for(int i=1;i<=n;i++){
			if(c[i]==0)continue;
			x=lower_bound(b+1,b+tot+1,a[i*2-1])-b;
			y=lower_bound(b+1,b+tot+1,a[i*2])-b;
			merge(x,y);
		}
		flag=true;
		for(int i=1;i<=n;i++){
			if(c[i]==1)continue;
			x=lower_bound(b+1,b+tot+1,a[i*2-1])-b;
			y=lower_bound(b+1,b+tot+1,a[i*2])-b;
			if(!change(x,y)){
				printf("NO\n");
				flag=false;
				break;
			}
		}
		if(flag)printf("YES\n");
	}
	return 0;
}
```

---

## 作者：ShawnZhou (赞：1)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

复习并查集。一开始还以为我写丑了卡我常数，总是TLE第二点，后来发现tot没清零。。。

使用了STL里面的unique函数和lower\_bound进行离散化，需要对数组进行排序以便于后续操作。

判断可行不可行的方法非常简单。我们首先把所有的相等关系合并，然后去看所有的不等关系，如果某个不等关系连接的两个数在相等关系的并查集里，那肯定就是矛盾的，要输出NO。如果一直都没有矛盾，最后就输出YES就好。

代码很直观。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 10000005
using namespace std;
struct quests{
    int x,y,e;
    bool operator<(const quests &rhs)const{
        return e > rhs.e;
    }
};
quests a[maxn];
int t,n;
int tot;
int tmp[maxn];
inline int read(){
    int num = 0;
    char c;
    while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
    num = c - '0';
    while (isdigit(c = getchar()))
        num = num * 10 + c - '0';
    return num;
}
int father[maxn];
int find(int x){
    if (father[x] == x)
        return father[x];
    return father[x] = find(father[x]);
}
int main(){
    t = read();
    while (t--){
        n = read();
        tot = 0;
        for (int i=1;i<=n;i++){
            a[i].x = read();
            a[i].y = read();
            a[i].e = read();
            tmp[++tot] = a[i].x;
            tmp[++tot] = a[i].y;
        }
        sort(a+1,a+n+1);
        sort(tmp+1,tmp+1+tot);
        tot = unique(tmp+1,tmp+tot+1) - (tmp+1);
        for (register int i=1;i<=tot;i++)
            father[i] = i;
        bool ok = true;
        for (int i=1;i<=n;i++){
            a[i].x = lower_bound(tmp+1,tmp+tot+1,a[i].x) - tmp;
            a[i].y = lower_bound(tmp+1,tmp+tot+1,a[i].y) - tmp;
            if (a[i].e)
                father[find(a[i].x)] = find(a[i].y);
            else if (find(a[i].x) == find(a[i].y)) {
                ok = false;
                break;
            }
        }
        if (ok)
            printf("YES\n");
        else
            printf("NO\n");
    }
    return 0;
}
```

---

## 作者：小小小朋友 (赞：1)

我的思路貌似和大家不一样哈……

**题面描述**：

很简单：

给出许多相等和不相等的条件，判断是否矛盾。

**思路**:

其实这道题连蓝题都不到……

使用并查集统计不同的关系，再枚举相同的，看是否矛盾即可。

发现i,j**极大**，冷静，**不要写哈希**！

记住，先看一下可不可以使用**map**。

发现可以，开两个map，一个用于存储并查集的数组，另一个则存储数组中有没有出现过这个数，再编写一个函数，用于返回这个数组上的数的引用，这样如果下面要改的话很方便。

这个函数：(unordered_map是啥看[我的文章](https://www.lijiaan.top/2019/08/05/C-STL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%87%BA%E9%97%A8/#more))
```cpp
long long n,nd,p,di[1000005],dj[1000005];
unordered_map<long long,long long> idm;
unordered_map<long long,bool> idb;
long long &id(long long x){ 
	if(idb[x]) return idm[x];//如果已经有了，就直接返回数组中的数
	else {//否则返回x
		idb[x]=1,idm[x]=x;
		return idm[x]; 
	}
}
```

下面贴出全篇代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,nd,p,di[1000005],dj[1000005];
unordered_map<long long,long long> idm;//存储并查集数组
unordered_map<long long,bool> idb;//存储是否出现过
long long &id(long long x){ //返回的是引用
	if(idb[x]) return idm[x];
	else {
		idb[x]=1,idm[x]=x;
		return idm[x]; 
	}
}
long long find(long long x){
	if(id(x)==x) return x;
	return id(x)=find(id(x));
}
void unite(long long x,long long y){
	long long xi=find(x),yi=find(y);
	id(xi)=yi;//因为是引用，所以可以直接这样写
}
int main(){
	ios::sync_with_stdio(false);//读入优化
	cin>>p;
	for(int np=0;np<p;np++){
		idm.clear();//清空map
		idb.clear();
		nd=0;
		bool flag=0;
		cin>>n;
		int i,j,e;
		for(int a=0;a<n;a++){
			cin>>i>>j>>e;
			if(e==0){//如果两者不相同，把它们存起来
				di[nd]=i,dj[nd]=j;
				nd++;
			}
			else unite(i,j);//否则将它们存入并查集
		}
		for(int a=0;a<nd;a++){
			if(find(di[a])==find(dj[a])){//如果两者本应相等，却不相等
				cout<<"NO\n";
				flag=1;
				break;
			}
		}
		if(!flag)cout<<"YES\n";
	}
	return 0;
}

```

再说一下，这个代码不开优化是不过的，必须开O2优化才能过。

---

## 作者：jins3599 (赞：0)

离散化+并查集。

还算是比较好写的。

首先观察题目，我们发现$i,j$的值过大，我们可以离散化一下。

其次，我们发现每组条件改变顺序不会影响结果，我们可以离线进行操作。

如果是在线的话，需要用到种类并查集，而离线的话，我们可以先处理所有相等的情况，把他们连到一个集合里面，然后再判断所有不等的情况，一旦发生矛盾立即停止输出。

对于离散化，我们可以开结构体记录下每个$i,j$，离散化后再按照编号排序回来，然后对于每个编号为$q$询问，它对应的离散化数组$a$中的$i,j$为$a[2p-1],a[2p].$

还有，要记得开两倍空间，因为每一个问题对应的是两个需要离散化的值，(因为这个我被坑了一次提交。)

代码的话写的应该是很清楚的，分组处理，注意初始化！

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 3e5 + 10;
int cnt;

struct Node {
	int num , val , w;
}a[N];

bool cmp1(Node a , Node b) {return a.val < b.val;}
bool cmp2(Node a , Node b) {return a.num < b.num;}

struct Qus {
	int x , y , num;
	bool flag;
	bool operator < (const Qus &a) const {
		return flag > a.flag;
	}
}q[N];

int bin[N];

int find(int x) {
	if(bin[x] == x) return x;
	return bin[x] = find(bin[x]);
}

void add(int x , int y) {
	int fx = find(x) , fy = find(y);
	if(fx != fy) bin[fx] = fy;
}

void Solve() {
	int n;
	cnt = 0;
	scanf("%d" , &n);
	for(int i = 1 ; i <= n ; ++ i) {
		bin[i] = i; bin[i + n] = i + n;
		scanf("%d %d %d" ,&q[i].x , &q[i].y , &q[i].flag);
		q[i].num = i;
		a[++ cnt].num = i , a[cnt].val = q[i].x;
		a[++ cnt].num = i , a[cnt].val = q[i].y;
	}
	sort(a + 1 , a + 1 + cnt , cmp1);
	int cur = 0;
	for(int i = 1 ; i <= cnt ; ++ i) {
		if(a[i].val != a[i - 1].val) a[i].w = ++ cur;
		else a[i].w = cur; 
	}
	sort(a + 1 , a + 1 + cnt , cmp2);
	sort(q + 1 , q + 1 + n);
	for(int i = 1 ; i <= n ; ++ i) {
		int num = q[i].num;
		if(q[i].flag == 1) {
			add(a[num * 2].w , a[num * 2 - 1].w);
		} else {
			if(find(a[num * 2].w) == find(a[num * 2 - 1].w)) {
				puts("NO"); return;
			}
		}
	}
	puts("YES");
}

int main () {
	int T;
	scanf("%d" , &T);
	while(T -- ) Solve(); 
	return 0;
}
```



---

## 作者：Yuyuanqi (赞：0)

# P1955 [NOI2015]程序自动分析


&nbsp;
# 分析~~废话~~

首先看到这道题，我们应该先思考怎样才能判断一个约束条件会导致整个问题矛盾。

**题目中的约束条件有两种，相等和不相等**

很显然，相等条件是不会互相冲突的（大家都相等）
不等条件也不会互相冲突（大家都不相等）
所以产生冲突的原因是不等关系和相等关系之间不能同时成立

**~~废话题干里都说了~~**

那么在顺序读入的过程中如何查看当前条件是否和已知条件矛盾呢？
由于等式的传递性所以我们可以把所有相等的元素抽象成一个集合，集合中每一个元素都相等

集合内每一个元素要满足快速的**合并到其它集合**和**查找该集合的代表元素**

我们就~~灵光一闪~~自然而然地想到了**并 查集**

所以我们的思路就是把所有相等的点并在一个集合里。判断不等时，如果约束条件里的两个元素已经属于同一个集合（根据已知条件这两个元素相等），那么该约束条件与其他条件矛盾，跳出即可。

&nbsp;

# 注意
&nbsp;
## 1.数据范围

注意i，j的数据规模是1e9，因为并查集的fa数组无法开到那么大~~即便内存给512M~~所以必须使用离散化把这些大得离谱的i，j缩到1-2m之间（m是变量的个数）

[离散化概述-百度百科](https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%8C%96/10501557) <--参考资料

&nbsp;

## 2.小细节

### 处理条件的顺序

由上文分析所述，可见先合并完所有相等的条件再判断不等的条件，所以在读入条件后应该对条件排序，代码中用了结构体排序 ，使得标记为1的条件排在标记为0的前面

### 数组的初始化

处理离散化需要用到的**inp**（记录输入的变量名称）和**b**（去重后的离散化数组）

并查集所用的fa数组

在每次询问前 **统统都要初始化**

不然各种REMLEWA...



好吧废话说到这里看代码吧 自认为注释说得很清楚（逃

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <functional>
using namespace std;
#define N 1000000
#define ll long long
#define re register
int T, n, cnt;
//循环次数 约束条件数量 变量数量（未去重）
int inp[N << 1], b[N], m, fa[N << 1];
//输入 去重数组 变量数量（已去重） 父亲数组（并查集）
inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}//快读

struct node //约束条件结构体
{
	int x, y, tp;
}a[N];//数字x和数字y的关系 tp表示类型

void discrete()
{
	sort(inp + 1, inp + 1 + cnt);
	for (int i = 1; i <= cnt; i++)
		if (i == 1 || inp[i] != inp[i - 1])
			b[++m] = inp[i];
}//去重

int query(int x) { return lower_bound(b + 1, b + 1 + m, x) - b; }//离散化
bool cmp(node a1, node a2) { return a1.tp > a2.tp; }//对约束条件进行排序

int getfather(int x) { return fa[x] = x == fa[x] ? x : getfather(fa[x]); }//并查集
bool check(int x, int y) { return getfather(x) == getfather(y); }
//查
void merge(int x, int y)
{
	int xx = getfather(x), yy = getfather(y);
	if (xx != yy) fa[xx] = yy;
}//并

int main()
{
	T = read();
	for (int tp = 0; tp < T; tp++)
	{
		memset(fa, 0, sizeof(fa));//一定不能忘记初始化 （其实可以记忆用了多少万一T大起来）
		memset(inp, 0, sizeof(inp));
		memset(b, 0, sizeof(b));
		bool flag = true;//是否成立（有矛盾）
		n = read();
		for (int i = 1; i <= n; i++) //读入关系
			a[i].x = read(), a[i].y = read(), a[i].tp = read(), inp[++cnt] = a[i].x, inp[++cnt] = a[i].y;
		discrete();//离散化
		for (int i = 1; i <= n; i++)
			a[i].x = query(a[i].x), a[i].y = query(a[i].y);//离散化
		for (int i = 1; i <= m; i++)
			fa[i] = i;//并查集初始化
		sort(a + 1, a + 1 + n, cmp);//将约束条件排序
		for (int i = 1; i <= n; i++)
		{
			if (a[i].tp == 1) merge(a[i].x, a[i].y);//若相等则并
			else if (check(a[i].x, a[i].y))//若不等则查
			{
				flag = false;
				break;
			}
		}
		if (flag) printf("YES\n");
		else printf("NO\n");//输出结果
	}
}
```

---

## 作者：lizitong (赞：0)

~~宣传一下自己的博客~~https://www.cnblogs.com/lizitong/

带权并查集。

由于蒟蒻理解力极其有限，并看不懂网上开二倍的方法，所以个人带权并查集的做

法全部都是取余做法。

我们用0和1代表这个数和根节点相同或者不同，当矛盾时即这句话是假话。

于是快乐地写完代码过样例，交了上去：
第三个点WA了。

黑人问号脸（？？？）

于是下载了数据，发现了这个问题：

如果按照正常的顺序处理，当给出这样的数据时：

**a≠b，b≠c，c≠a**

**根据我们的理论，0代表相同，1代表不相同，前两个数据可以得：a为0，b为1，c为0，那么当c≠a时，推出矛盾。**

**这样做显然是错误的。前两个条件并不是第三个结论的充要条件。轻易可以举出反例：**

**a = 1，b = 2，c = 3**

**那么我们最好的做法便是先把所有的相等条件加入到同一个并查集中，再去处理不相等的情况，如果a，b在同一个并查集中，那么显然不成立。如果不在，就可以满足。**

上代码：

PS：本人离散化方式奇特，三倍大小，一倍存x，二倍存y，三倍存相等关系。
```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#define N 1000005
using namespace std;
int n;
int f[N];
int g[N];
bool flag;
int find(int x)
{
    if(f[x]==x)
    {
        return f[x];
    }
    int fx = find(f[x]);
    g[x] = (g[f[x]]+g[x])%2;
    return f[x] = fx;
}
struct node
{
    int x;
    int y;
    int a;
    int num;
    int p;
}nd[N+N+N];
void uion(int x,int y,int a)
{
    int fx = find(x);
    int fy = find(y);
    if(fx!=fy)
    {
        f[fy] = fx;
        if(a==1)
        {
            g[fy] = (g[x]-g[y]+2)%2;
        }else
        {
            g[fy] = (g[x]-g[y]+2+1)%2;
        }    
    }
}
int cmp(node a,node b)
{
    return a.p<b.p;
}
void init()
{    
    memset(g,0,sizeof(g));
    memset(nd,0,sizeof(nd));
    flag = 0;
    scanf("%d",&n);
    for(int i = 1;i<=n;i++)
    {
        scanf("%d%d%d",&nd[i].p,&nd[i+n].p,&nd[i+n+n].a);
        nd[i].num = i;
        nd[i+n].num = i;
    }
}
void disperse()
{
    sort(nd+1,nd+1+n+n,cmp);
    int cnt = 1;
    for(int i = 1;i<=n+n;i++)
    {
        if(!nd[nd[i].num].x)
        {
            nd[nd[i].num].x = cnt;
        }else
        {
            nd[nd[i].num].y = cnt;
        }
        if(nd[i+1].p!=nd[i].p)
        {
            cnt++;
        }
    }
    for(int i = 1;i<=n;i++)
    {
        nd[i].a = nd[i+n+n].a;
    }
    for(int i = 1;i<=cnt;i++)
    {
        f[i] = i;
    }
}
void solve()
{
    for(int i = 1;i<=n;i++)
    {
        if(nd[i].a==1)
        {
            uion(nd[i].x,nd[i].y,nd[i].a);
        }
    }
    for(int i = 1;i<=n;i++)
    {
        if(nd[i].a==0)
        {
            int fx = find(nd[i].x);
            int fy = find(nd[i].y);
            if(fx==fy)
            {
                printf("NO\n");
                flag = 1;
                return ;
            }
        }
    }
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        init();
        disperse();
        solve();
        if(flag==0)
        {
            printf("YES\n");
        }
    }
}
/*
第三组数据奉上
9
234 1
1 1
78 0
1 1
977 0
76 1
877 0
987 0
987 0
*/
```


---

## 作者：renhr2002 (赞：0)

这道题实际就是个并查集，但是i和j的规模很大，这样，数组下角标没法存下。

这样，需要进行离散化。

发现没有用优先队列进行离散化的（*实际我这样是吸氧过的*）我就想来H2O一发。
对于每组数据，记录cnt，last两个变量，记录当前是第几小，上一个数的值是几。这样，用优先队列每次取出剩余最小的数，判断它和last是否相等。如果不相等，记录它离散化后的值。

### **注意！**
一定要对每组约束条件进行排序（**我因为这个WA了7个点，排序后就好了**）！先判断相等的，将它们所在集合排序；再判断要求不等的两个数是否在同一个集合里，如果在，就无法同时满足。

O2优化代码

```cpp
// luogu-judger-enable-o2
#include<map>
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 102400
int T;
int n;
struct node
{
    int x;
    int y;
    int val;
    friend bool operator < (node a,node b)
    {
        return a.val>b.val;
    }
}nd[maxn];
int f[2*maxn];
int cnt=2,last=0x8f8f8f8f;
void init()
{
    memset(f,0,sizeof(f));
    for(int i=1;i<=cnt;i++)
    {
        f[i]=i;
    }
    cnt=2;
    last=0x8f8f8f8f;
    return;
}
int find(int x)
{
    if(x==f[x])
    {
        return x;
    }else
    {
        return f[x]=find(f[x]);
    }
}
void merge(int x,int y)
{
    int fx=find(x);
    int fy=find(y);
    f[fx]=fy;
    return;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        map<int,int>m;
        priority_queue<int,vector<int>,greater<int> >p;
        for(int i=1;i<=n;i++)
        {
            scanf("%d%d%d",&nd[i].x,&nd[i].y,&nd[i].val);
            p.push(nd[i].x);
            p.push(nd[i].y);
        }
        while(p.size())
        {
            int x=p.top();
            p.pop();
            if(x==last)
            {
                continue;
            }else
            {
                m[x]=cnt;
                cnt++;
                last=x;
            }
        }
        sort(nd+1,nd+n+1);
        init();
        bool f=1;
        for(int i=1;i<=n;i++)
        {
            nd[i].x=m[nd[i].x];
            nd[i].y=m[nd[i].y];
            if(nd[i].val==1)
            {
                merge(nd[i].x,nd[i].y);
            }else if(find(nd[i].x)==find(nd[i].y))
            {
                printf("NO\n");
                f=0;
                break;
            }
        }
        if(f)
        {
            printf("YES\n");
        }
        memset(&nd,0,sizeof(nd));
    }
}
```

---

## 作者：cold_cold (赞：0)

[安利一波博客](https://www.cnblogs.com/cold-cold/p/10029969.html)

此题并查集和离散化这两种算法其实很好看出，但是本题的关键在于并查集的方式问题。

我的第一种思路其实是受 NOI2001食物链 这题所影响的，我将每一个x数分为两面，x和x+n，

　　如果操作为使x，y相等，就将x与y合并，x+n与y+n合并

　　如果操作为使x，y不等，就将x与y+n合并，x与y+n合并

　　如果任何时候x与x+n相连了就不成立

这似乎很正确，于是就过了90分.......数据水的。

错误代码如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
inline int read()
{
    register int p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=401000;
int t,x,y,n,bowl[N],cx[N],cy[N],fa[N],co[N],len,fla;
int getf(int u){return fa[u]==u?u:fa[u]=getf(fa[u]);}
void MERGE(int u,int v)
{
    int t1=getf(u),t2=getf(v);
    if(t1!=t2) fa[t1]=t2;
}
bool check(int u) {return getf(u)==getf(u+len);}
int main()
{
//    freopen("input","r",stdin);
//    freopen("output","w",stdout);
    t=read();
    while(t--)
    {
        n=read();fla=0;
        for(int i=(n<<2);i>=1;--i) fa[i]=i;
        for(int i=1;i<=n;++i)
        {
            cx[i]=read(),cy[i]=read(),co[i]=read();
            bowl[(i<<1)-1]=cx[i],bowl[i<<1]=cy[i];
        }
        sort(bowl+1,bowl+(n<<1)+1);
        len=unique(bowl+1,bowl+(n<<1)+1)-bowl-1;
        for(int i=1;i<=n;++i)
        {
            x=lower_bound(bowl+1,bowl+1+len,cx[i])-bowl,y=lower_bound(bowl+1,bowl+1+len,cy[i])-bowl;
            if(co[i]==1)
            {
                MERGE(x,y);
                if(check(x)||check(y)) {fla=1;break;}
            }
            else
            {
                MERGE(x,y+len);
                if(check(x)||check(y)) {fla=1;break;}
            }
        }
        if(fla) puts("NO");
        else puts("YES");
    }
    return 0;
}

```

但是我自己举出了反例。

```cpp
1
3
1 2 0
2 3 0
1 3 0
```

在我的方法的连接下，本应是三个互不相等的数却出现了冲突

为什么会出现错误呢，原因在于不等号不具备传递性，而等号具有传递性。a≠b和b≠c不能推出a≠c，由此造成了错误。

而正确的做法正是利用了不等号不具备传递性，我们将所有等号操作率先合并完了以后，再判断所有不等号是否成立，及两数是否在同一集合中，就可已完成此题

正确实现如下：
```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
inline int read()
{
    register int p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=401000;
int t,x,y,n,bowl[N],cx[N],cy[N],fa[N],co[N],len,fla;
int getf(int u){return fa[u]==u?u:fa[u]=getf(fa[u]);}
void MERGE(int u,int v)
{
	int t1=getf(u),t2=getf(v);
	if(t1!=t2) fa[t1]=t2;
}
bool check(int u,int v){return getf(u)==getf(v);}
int main()
{
//	freopen("input","r",stdin);
//	freopen("output","w",stdout);
	t=read();
	while(t--)
	{
		n=read();fla=0;
		for(int i=(n<<1);i>=1;--i) fa[i]=i;
		for(int i=1;i<=n;++i)
		{
			cx[i]=read(),cy[i]=read(),co[i]=read();
			bowl[(i<<1)-1]=cx[i],bowl[i<<1]=cy[i];
		}
		sort(bowl+1,bowl+(n<<1)+1);
		len=unique(bowl+1,bowl+(n<<1)+1)-bowl-1;
		for(int i=1;i<=n;++i)
			cx[i]=lower_bound(bowl+1,bowl+1+len,cx[i])-bowl,cy[i]=lower_bound(bowl+1,bowl+1+len,cy[i])-bowl;
		for(int i=1;i<=n;++i) if(co[i]==1) MERGE(cx[i],cy[i]);
		for(int i=1;i<=n;++i) if(co[i]==0) if(check(cx[i],cy[i])) {fla=1;break;}
		if(fla) puts("NO");
		else puts("YES");
	}
    return 0;
}
```

---

## 作者：COPPERTHIC (赞：0)

思路应该还是很容易想到的

并查集

如果两个数关系相等就加入一个集，不相等就检查之前的条件是不是在同一个集里……如果矛盾就输出NO，一直顺利地运行下去输出YES

但是如果你写一个裸的并查集……结果很惨\微笑

数据范围还是很大的……然后这里我们要用到离散化

“离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率”——这是百度的解释

对于这道题，我们可以把所有的i、j的值记录下来，排序，然后在新的数组里索引……就节省了很多空间

关于离散化可以参考这篇文章https://www.cnblogs.com/kevince/archive/2014/08/06/3893531.html

别的要是一定说有要注意的地方大概就是每次记得重新初始化fa数组、tmp和那个用于判断YES/NO的数了吧

代码就不贴了……楼下写得很清楚啦


---

## 作者：硫代硫酸钠 (赞：0)

算法描述：


对于所有的等式，将他们用并查集联合。


然后对于所有的不等式，判断他们是否已经在同一个祖先下。


**注意几个问题**


1.每一次要重置fa数组！


2.离散化一定要一起做，不能两边分开！


P.S. 我不会其他离散化的方式，所以我就用了最弱的一种。。。


代码当然要有
















    
      
      
       
            

```cpp
#include<bits/stdc++.h>
#define size 600010
using namespace std;
int fa[size],n;
typedef pair<long long,long long  > P;
void setup()
{
  for (int i=1;i<=500010;i++) fa[i]=i;
}
int find (int x)
{
  if (x==fa[x]) return x;
  return fa[x]=find(fa[x]);
}
void unite(int x,int y)
{
  fa[find(x)]=find(y);
}
bool query(int x,int y)
{
  return (find(x)==find(y));
}
bool cmp(P x,P y)
{
  return (x.first>y.first);
}
void lisan (P a[],int A[])
{
    int cnt=0;
  sort(a+1,a+n*2+1,cmp);
  for (int c=1;c<=n*2;c++)
  {
      if (c==1||a[c].first!=a[c-1].first) cnt++;
      A[a[c].second]=cnt;
  } 
} 
P a[size];
int  A[size],B[size],sgn[size],t;
int main()
{
    scanf("%d",&t);
  for (int i=1;i<=t;i++)
  {
      scanf("%d",&n);
      bool flag=0;
      setup();
      memset(sgn,0,sizeof(sgn));
      memset(A,0,sizeof(A));
      memset(a,0,sizeof(a));
      for (int j=1;j<=n;j++)
      {
        long long  ta,tb;
        scanf("%lld%lld%d",&ta,&tb,&sgn[j]);
        a[j]=make_pair(ta,j);
        a[j+n]=make_pair(tb,j+n);
      }
      lisan(a,A);
      for (int ii=1;ii<=n;ii++) B[ii]=A[n+ii];
      for (int ii=1;ii<=n;ii++)
      if (sgn[ii]) unite(A[ii],B[ii]);
      for (int ii=1;ii<=n;ii++)
      {
          if (!sgn[ii]) 
          {
            if (query(A[ii],B[ii]))
            {
                flag=1;break;
            }
          }
      }
      if (!flag)  printf("YES\n");else printf("NO\n");
  }
  return 0;
}

```

---

## 作者：McGrady (赞：0)

1.离散化：对所有出现的变量排序并重新编号，这样可以在logn时间内查找任意变量的新编号（用hash好像也可以，不过如果数据故意卡你就没办法了，所以我还是用了排序）

2.构造无向图：每个变量对应图中一个结点，每个相等约束条件对应图中一条边

3.Floodfill找出所有连通块，并标号

4.检查所有不等条件，若有属于同一连通块，输出No，否则输出Yes

时间复杂度nlogn

我可是pascal

代码：

```cpp
program prog(input,output);
type
  pointer=^nodetype;
  nodetype=record
     data:longint;
     next:pointer;
  end;
var
  i,j,k,t,n,x,y,e,an,bn,len:longint;
  ax,ay,bx,by:array[0..100010]of longint;
  f,g,q:array[0..200020]of longint;
  v:array[0..200020]of boolean;
  a,r:array[0..200020]of pointer;
  tt,p:pointer;
  flag:boolean;
procedure qsort(q,h:longint);
var
  i,j,x,t:longint;
begin
   i:=q;j:=h;x:=f[(i+j)>>1];
   repeat
       while f[i]<x do inc(i);
       while x<f[j] do dec(j);
       if i<=j then
           begin
              t:=f[i];f[i]:=f[j];f[j]:=t;
              inc(i);dec(j);
           end;
   until i>j;
   if j>q then qsort(q,j);
   if i<h then qsort(i,h);
end;
function fun(x:longint):longint;
var
  l,r,mid:longint;
begin
   l:=1;r:=len;
   while l<r-1 do
       begin
          mid:=(l+r)>>1;
          if f[mid]<x then l:=mid+1 else r:=mid;
       end;
   if f[l]=x then exit(l) else exit(r);
end;
procedure bfs(x:longint);
var
  h,t:longint;
begin
   h:=1;t:=1;q[1]:=x;v[x]:=true;inc(k);g[x]:=k;
   while true do
       begin
          p:=a[q[h]];
          while p^.next<>nil do
              begin
                 p:=p^.next;
                 if not v[p^.data] then
                     begin
                        g[p^.data]:=k;v[p^.data]:=true;
                        inc(t);q[t]:=p^.data;
                     end;
              end;
          inc(h);
          if h>t then break;
       end;
end;
begin
   //assign(input,'prog.in');assign(output,'prog.out');reset(input);rewrite(output);
   readln(t);
   for i:=1 to t do
       begin
          readln(n);
          an:=0;bn:=0;
          for j:=1 to n do
              begin
                 readln(x,y,e);
                 f[j<<1-1]:=x;f[j<<1]:=y;
                 if e=1 then begin inc(an);ax[an]:=x;ay[an]:=y; end
                 else begin inc(bn);bx[bn]:=x;by[bn]:=y; end
              end;
          qsort(1,n<<1);
          f[0]:=0;len:=0;
          for j:=1 to n<<1 do if f[j]<>f[j-1] then begin inc(len);f[len]:=f[j]; end;
          for j:=1 to len do begin new(a[j]);a[j]^.next:=nil;r[j]:=a[j]; end;
          for j:=1 to an do
              begin
                 x:=fun(ax[j]);y:=fun(ay[j]);
                 new(p);p^.data:=y;p^.next:=nil;r[x]^.next:=p;r[x]:=p;
                 new(p);p^.data:=x;p^.next:=nil;r[y]^.next:=p;r[y]:=p;
              end;
          fillchar(v,sizeof(v),false);
          k:=0;
          //for j:=1 to len do writeln(f[j],' ',j);writeln;
          for j:=1 to len do if not v[j] then bfs(j);
          //for j:=1 to len do writeln(j,' ',g[j]);
          flag:=true;
          //for j:=1 to bn do begin writeln(bx[j],' ',by[j]); end;
          for j:=1 to bn do
              begin
                 x:=fun(bx[j]);y:=fun(by[j]);
                 if g[x]=g[y] then begin flag:=false;break; end;
              end;
          if flag then writeln('YES') else writeln('NO');
          for j:=1 to len do
              begin
                 p:=a[j];
                 while p<>nil do begin tt:=p^.next;dispose(p);p:=tt; end;
              end;
       end;
   //close(input);close(output);
end.
```

---

## 作者：jinqiu (赞：0)

并查集加离散化，注意map的使用，没使用一次就加一次log，谨慎。。。之前就卡在这个map上了。。。


[codec]






```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
#define LL long long
using namespace std;
const int maxn=100010;
int t,n;
int father[2*maxn];
LL a[maxn],b[maxn],c[maxn];
map<LL,int>s;
int find(int);
LL read();
int main(){
    int i,j;
    cin>>t;
    while(t--){
        int cnt=0;
        bool flag=false;
        s.clear();
        n=read();
        for(i=1;i<=n*2;i++)father[i]=i;
        for(i=1;i<=n;i++){
            a[i]=read();b[i]=read();c[i]=read();
            //if(s.find(a[i])==s.end())s[a[i]]=++cnt;
            //if(s.find(b[i])==s.end())s[b[i]]=++cnt;
            if(c[i]){
                int ap=s[a[i]],bp=s[b[i]];
                if(!ap){
                    s[a[i]]=++cnt;
                    ap=cnt;
                }
                if(!bp){
                    s[b[i]]=++cnt;
                    bp=cnt;
                }
                int x=find(ap);
                int y=find(bp);
                if(x!=y)
                    father[x]=y;
            }
        }
        for(i=1;i<=n;i++){
            if(!c[i]){
                int ap=s[a[i]],bp=s[b[i]];
                if(a[i]==b[i]){
                    flag=true;
                    break;
                }
                if(!ap||!bp)continue;
                int x=find(ap);
                int y=find(bp);
                if(x==y){
                    flag=true;
                    break;
                }
            }
        }
        if(flag)cout<<"NO\n";
        else cout<<"YES\n";
    }
    return 0;
}
int find(int x){
    if(x!=father[x])
        return father[x]=find(father[x]);
    return x;
}
LL read(){
    LL ans=0,f=1;
    char tmp=getchar();
    while(tmp<'0'||tmp>'9'){
        if(tmp=='-')
            f=-1;
        tmp=getchar();
    }
    while(tmp>='0'&&tmp<='9'){
        ans=ans*10+tmp-'0';
        tmp=getchar(); 
    }
    return ans*f;
}
[/codec]
```

---


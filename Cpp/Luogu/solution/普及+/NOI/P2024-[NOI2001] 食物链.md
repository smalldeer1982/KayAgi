# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# 题解

## 作者：Sooke (赞：2184)

### 重写于 2018.9.13，并修改代码码风（以前的码风真是丑啊qwq）

本题解适合于并查集初学者，建议嫌文章冗长的巨佬们阅读其他题解。

-------------

### 引入

并查集能维护连通性、传递性，通俗地说，`亲戚的亲戚是亲戚`。

然而当我们需要维护一些对立关系，比如 `敌人的敌人是朋友` 时，正常的并查集就很难满足我们的需求。

这时，`种类并查集`就诞生了。

常见的做法是将原并查集扩大一倍规模，并划分为两个种类。

在同个种类的并查集中合并，和原始的并查集没什么区别，仍然表达`他们是朋友`这个含义。

考虑在不同种类的并查集中合并的意义，其实就表达 `他们是敌人` 这个含义了。

按照并查集美妙的 `传递性`，我们就能具体知道某两个元素到底是 `敌人` 还是 `朋友` 了。

至于某个元素到底属于两个种类中的哪一个，由于我们不清楚，因此两个种类我们都试试。

具体实现，详见 `P1525 关押罪犯`。

----------------

### 概念解释

再来看本题，每个动物之间的关系就没上面那么简单了。

对于动物 $x$ 和 $y$，我们可能有 $x$ 吃 $y$，$x$ 与 $y$ 同类，$x$ 被 $y$ 吃。

但由于关系还是明显的，$1$ 倍大小、$2$ 倍大小的并查集都不能满足需求，$3$ 倍大小不就行了！

类似上面，我们将并查集分为 $3$ 个部分，每个部分代表着一种动物种类。

设我们有 $n$ 个动物，开了 $3n$ 大小的种类并查集，其中 $1 \sim n$ 的部分为 $A$ 群系，$n + 1 \sim 2n$ 的部分为 $B$ 群系，$2n + 1 \sim 3n$ 的部分为 $C$ 群系。

我们可以认为 $A$ 表示中立者，$B$ 表示生产者，$C$ 表示消费者。此时关系明显：$A$ 吃 $B$，$A$ 被 $C$ 吃。

当然，我们也可以认为 $B$ 是中立者，这样 $C$ 就成为了生产者，$A$ 就表示消费者。（还有 $1$ 种情况不提及了）

联想一下 $2$ 倍大小并查集的做法，不难列举出：当 $A$ 中的 $x$ 与 $B$ 中的 $y$ 合并，有关系 $x$ 吃 $y$；当 $C$ 中的 $x$ 和 $C$ 中的 $y$ 合并，有关系 $x$ 和 $y$ 同类等等……

但仍然注意了！我们不知道某个动物属于 $A$，$B$，还是 $C$，我们 $3$ 个种类都要试试！

也就是说，每当有 $1$ 句真话时，我们需要合并 $3$ 组元素。

容易忽略的是，题目中指出若 $x$ 吃 $y$，$y$ 吃 $z$，应有 $x$ 被 $z$ 吃。

这个关系还能用种类并查集维护吗？答案是可以的。

若将 $x$ 看作属于 $A$，则 $y$ 属于 $B$，$z$ 属于 $C$。最后，根据关系 $A$ 被 $C$ 吃可得 $x$ 被 $z$ 吃。

既然关系满足上述传递性，我们就能放心地使用种类并查集来维护啦。

----------------------

### 图片解释

理论太难懂？那就结合数据和图片来解释吧！

假如我们有以下的输入数据：

```cpp
4 5
1 1 3
2 2 4
2 3 2
1 1 4
2 2 1
```
因为涉及 4 个动物（$n = 4$），所以构建初始并查集如下图：

 ![](https://cdn.luogu.com.cn/upload/pic/6104.png) 

先看第 $1$ 句话：动物 $1$ 和 $3$ 是同类的。

我们可以在 $3$ 个群系中分别给 $1$ 和 $3$ 的集合合并，以表示动物 $1$ 和 $3$ 是一定友好的。

 ![](https://cdn.luogu.com.cn/upload/pic/6105.png) 

再看第 $2$ 句话：动物 $2$ 吃 $4$。

显然这不是矛盾的。但我们不知道 $2$ 和 $4$ 对应 $A$， $B$，$C$ 中的哪个，所以我们只能根据 $A$ 吃 $B$，合并 $A$ 群系中的 $2$ 和 $B$ 群系中的 $4$；再根据 $B$ 吃 $C$ 和 $C$ 吃 $A$，作出对应的处理。结果如下所示：

 ![](https://cdn.luogu.com.cn/upload/pic/6106.png) 

接着看第 $3$ 句话：动物 $3$ 吃 $2$。这是句真话，具体的真假话判断方法看下面两句话。我们暂且先作出以下处理：

 ![](https://cdn.luogu.com.cn/upload/pic/6107.png) 

第 $4$ 句话中，表明 $1$ 和 $4$ 是同类动物。此时我再解释如何判断话的真假。

对于同类动物，我们转换一下，如果我们知道 $1$ 不吃 $4$ 且 $4$ 不吃 $1$，他们不就同类了吗？

好，那我们的任务就变成：如何判断动物 $x$ 吃动物 $y$？

反观第 $2$ 句话，我们知道如果要表示动物 $x$ 吃动物 $y$，只要根据 $A$ 吃 $B$，把 $A$ 群系中的 $x$ 和 $B$ 群系中的 $y$ 合并即可。另外 $2$ 次合并暂不讨论。

那反过来，如果 $A$ 群系中的 $x$ 已经和 B 群系中的 $y$ 在同一集合中了，不就表示了动物 $x$ 吃动物 $y$ 吗？

于是，我们看到上面那张图，$B$ 群系中的 $1$ 按照并查集的递归操作，找出自己的终极上级是 $A$ 群系中的 $4$。

分析其含义，属于 $B$ 群系的 $1$ 已经与 $A$ 群系的 $4$，应有 $4$ 吃 $1$，而非同类。第 $4$ 句话是假的。

那么第 $5$ 句话，$2$ 吃 $1$。我们需要判断 $2$ 和 $1$ 是否是同类并且 $2$ 是否被 $1$ 吃即可。

判断是否同类，我们同样可以反过来：判断在同个群系中的 $2$ 和 $1$ 的集合是否已经合并。

得出 $2$ 和 $1$ 不是同类后，我们再看 $1$ 是否吃 $2$。看图，$A$ 群系中的 $1$ 和 $B$ 群系中的 $2$ 在同一集合中。

得出 $1$ 吃 $2$。第 $5$ 句话也是假话。

因此，答案就是有两句假话。输出 $2$，问题完美解决。

---------------------------

### 注意事项

- 种类并查集求的并非具体种类，而是关系！

- 在代码过程中，不要忘了特判编号大于 $n$ 的情况！

---------------------------

### 代码实现

如果还没有理解，只能使用最终办法了，上程序！

（当然我还是希望各位摸清种类并查集的本质，灵活运用）

```cpp
#include <cstdio>

inline int read() {
	char c = getchar(); int n = 0;
	while (c < '0' || c > '9') { c = getchar(); }
	while (c >= '0' && c <= '9') { n = (n << 1) + (n << 3) + (c & 15); c = getchar(); }
	return n;
}

const int maxN = 100005;

int n, m, ans, fa[maxN * 3];

int find(int u) { return fa[u] == u ? u : fa[u] = find(fa[u]); }

int main() {
	n = read(), m = read();
	for (int i = 1; i <= n * 3; i++) { fa[i] = i; }
	for (; m; m--) {
		int opt = read(), u = read(), v = read();
		if (u > n || v > n) { ans++; continue; }
		if (opt == 1) {
			if (find(u + n) == find(v) || find(u) == find(v + n)) { ans++; }
			else {
				fa[find(u)] = find(v);
				fa[find(u + n)] = find(v + n);
				fa[find(u + n + n)] = find(v + n + n);
			}
		} else {
			if (find(u) == find(v) || find(u) == find(v + n)) { ans++; }
			else {
				fa[find(u + n)] = find(v);
				fa[find(u + n + n)] = find(v + n);
				fa[find(u)] = find(v + n + n);
			}
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

-----------------------------

### 撰文不易，不适轻喷！

---

## 作者：檀黎斗·神 (赞：619)

感觉的别人代码都好麻烦啊

于是自己写个比较短的代码

只有50行还加了读入优化有木有

这道题的思路别人都讲的差不多了

就是用3倍的并查积的存各种动物的关系

一倍存本身，二倍存猎物，三倍存天敌

唯一容易忽略的点就是：一的猎物的猎物 就是一的天敌

那么我们每次只要维护三个并查积的关系就可以了

详细的维护操作我写了注释就直接看代码吧

```cpp
#include<cstdio>
int fa[300005];
int n,k,ans;
inline int read()
{
    int sum=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') ch=getchar();
    while(ch>='0'&&ch<='9') sum=sum*10+ch-48,ch=getchar();
    return sum;
}//读入优化
int find(int x)
{
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}//查询
int unity(int x,int y)
{
    int r1=find(fa[x]),r2=find(fa[y]);
    fa[r1]=r2;
}//合并
int main()
{
    int x,y,z;
    n=read(),k=read();
    for(int i=1;i<=3*n;++i) fa[i]=i; //对于每种生物：设 x 为本身，x+n 为猎物，x+2*n 为天敌
    for(int i=1;i<=k;++i) 
    {
        z=read(),x=read(),y=read();
        if(x>n||y>n) {ans++; continue;} // 不属于该食物链显然为假
        if(z==1)
        {
            if(find(x+n)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的天敌或猎物，显然为谎言
            unity(x,y); unity(x+n,y+n); unity(x+2*n,y+2*n);
            //如果为真，那么1的同类和2的同类，1的猎物是2的猎物，1的天敌是2的天敌
        }
        else if(z==2)
        {
            if(x==y) {ans++; continue;} //其实是废话但是可以稍微省点时间
            if(find(x)==find(y)||find(x+2*n)==find(y)) {ans++; continue;}
            //如果1是2的同类或猎物，显然为谎言
            unity(x,y+2*n); unity(x+n,y); unity(x+2*n,y+n);
            //如果为真，那么1的同类是2的天敌，1的猎物是2的同类，1的天敌是2的猎物
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：天泽龟 (赞：240)

Update on 21.07.16: 修了挂掉的图


开三个并查集感觉太作弊了于是学了下**带权并查集**，写篇题解巩固一下_(:з」∠)_。

上网大概搜了下，对带权并查集的诠释是这样的：
		
>在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。

也就是说，权值代表着**当前节点与父节点的某种关系（即使路径压缩了也是这样）**，通过两者关系，也可以将同一棵树下两个节点的关系表示出来。
 

------------

 而P2024《食物链》这道题，又属于加权并查集下的分支：
 ### 种类并查集
 由题意得，动物一共只有 A,B,C 三种，**也就是说只要确定了一种动物的种类和他们的关系（即权值），其他的动物的种类也就知道了。**
 
 我们用 $re[x]$ 表示编号 $i$ 与父亲节点的权值关系，由于只有三种动物，所以权值也只有三种：
 
 - 0--> 同种动物，
 - 1--> 捕食关系，
 - 2--> 被捕食关系，
 
转移时便可以采用对 $3$ 取模来实现。**（初始化为 $0$ ，即自己与自己为同种动物）**
 
 ### 那么最大的问题，就是如何在查找与合并时转移这种权值？
 **1.合并**：并查集合并的本质就是一棵树认另一棵树做父亲，把树根相连即可，但是能否也把权值直接赋值呢（比如 1 操作就直接赋值为 $1$）？  **当然不行，因为给你的 $a,b$ 是树下节点，还有考虑各自与树根的关系。**
 也就说，推出 $A,B$ 各自与根的关系，就可以实现树根权值的连接了。

设 F1 与 F2 分别为 A 与 B 的根，两者权值关系为 $re[F1]$，A 与 F1 的权值关系是 $re[A]$，B 与 F2 的权值关系是 $re[B]$，A 与 B 的权值关系为 $x$。

![](https://cdn.luogu.com.cn/upload/image_hosting/obobq7t8.png)

由图得，$re[f1]=x+re[b]-re[a]$

由于可能会造成 $re[b]-re[a]<0$ 的情况，所以加 $3$ 再对三取模。又因为 $x$ 已知为 $0$ 或 $1$ （要么是同种动物，要么是捕食关系），所以最终结果为：

$$re[f1]=(re[b]-re[a]+3) \bmod 3$$

或
$$re[f1]=(1+re[b]-re[a]+3) \bmod 3$$


**2.查找（路径压缩）**：路径压缩就是在搜索的时候找到最远的祖先，然后将父亲节点赋值，对于权值而言，就是找出权值与最远祖先之前所有边权传递的过程，找出节点与父亲节点的关系，依次传递即可。

设在同一树内，$3$ 号节点父亲是 $2$ 号，$2$ 号父亲是根 $1$ 号。与父亲的关系依次为 $re[3],re[2]$ ，路径压缩后权值为 $re[3]'$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/73dkcdm0.png)

显然，$re[3]'=(re[3]+re[2]) \bmod3$，别忘了取模。

当然不会数学推得话**打表**也是好方法，本蒟蒻就是打完表水过题再数学证明的_(:з」∠)_。

关于打表，其他题解已经给出详细的过程，这里就不做赘述。


------------
这两式子一出来，题目就好做多了 ~~（我还是因为板子打错了改个近一小时）~~。

根据题目我们还可以确定：判断两点的关系是否正确必须要在同一棵树下，反之则一定正确。（因为如果是两棵树，两点的关系就不能确定了。）

然后一些小问题又没啥好说了，贴上丑陋的代码：
	
 ```cpp
 #include <iostream>  //带权并查集 题解 
using namespace std;
int f[100000],re[100000];  //0-->同种动物，1-->捕食关系，2-->被捕食关系。
int n,m,a,b,p,ans=0;

int find(int a)
{
	int fa=f[a];
	if (a!=fa) {
		f[a]=find(fa);
		re[a]=(re[a]+re[fa])%3;   
		return f[a];
	}
	else return fa;
}
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++) f[i]=i,re[i]=0;
	for (int i=1;i<=m;i++)
	{
		cin>>p>>a>>b;
		if ((a>n||b>n)||(p==2&&a==b)) {   //两种特殊情况 
			ans++; continue;
		}
		if (p==1)  //对关系1讨论 
		{
			int f1=find(a),f2=find(b);
			if (f1==f2&&re[a]!=re[b])  //判断是否在同一棵树及两者是否为同种动物。 
			{
				ans++; continue;
			}
			else if(f1!=f2)
			{
				f[f1]=f2; re[f1]=(3-re[a]+re[b])%3;   //合并 
			}
		}
		if (p==2)  //对关系2讨论 
		{
			int f1=find(a),f2=find(b);
			if (f1==f2) 
			{
				int rela=(re[a]-re[b]+3)%3;  //用两个节点与父亲的关系推出两者关系 

				if (rela!=1) {
//					cout<<"HERE?"<<endl;
					ans++; continue;
				}
			}
			else {
				int f1=find(a),f2=find(b);
				f[f1]=f2; re[f1]=(3-re[a]+re[b]+1)%3;   //合并 
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

大概就是这样了，如果我有啥理解错误的地方欢迎指正_(:з」∠)_

---

## 作者：zan18 (赞：91)

这道题的特殊之处在于对于任意一个并查集，只要告诉你某个节点的物种，你就可以知道所有节点对应的物种。

比如一条长为4的链 甲->乙->丙->丁 ，我们知道乙是A物种。那么甲一定是B物种，因为A只吃B物种，不吃C物种或是自己的同类。同样的丙一定是C物种，丁是B物种。

也就是说，每一条链上都是A、B、C物种循环，这也是我们寻找不合逻辑的假话的出发点。

我们可以定义数组d[i]表示节点i到根节点距离mod3的结果帮助解题。

我们统计谎话的数量，那么我们把谎话这样分类：

第一类叫弱智的谎话，包括

（1）自己吃自己的同类是谎话，表述为d==2&&x==y（其中x y是我们读入的量）；

（2）编号超出限制，表述为x>n||y>n。
第二类叫不弱智的谎话，包括d==1和d==2这样两类。

（1）d==1。

我们先要考虑x y是否在同一个并查集中，这是判断真假话的前提。

如果x y 不在同一个并查集中，那么关于他们的任何表述都可以是真的。

比如两条链：1->2->3->4->5     6->7->8->9

如果我说1和6是同类，那么自然地，2与7，3与8，4与9成为同类。

我们任意的选取两个数是同类都是符合的。

下面我们要做的就是把两个并查集合并。

d[f[x]]=(d[y]-d[x]+3)%3;//关于距离

f[f[x]]=f[y];//关于父亲

如果x y在同一个并查集中，那么违反距离关系的话一定是假话。

d[x]!=d[y]//关于距离

（2）d==2。

还是先看x y是否在一个并查集中，如果不在，那么合并并查集；如果在，那么根据距离关系找出假话。

下面是我的代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int f[50005],d[50005],n,k,d1,x,y,ans;
int find(int x)//寻找祖先的函数
{
    if(x!=f[x])
    {
        int xx=f[x];
        f[x]=find(f[x]);
        d[x]=(d[x]+d[xx])%3;
    }
    return f[x];
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {f[i]=i;d[i]=0;}
    for(int i=1;i<=k;i++)
    {
        scanf("%d%d%d",&d1,&x,&y);
        if((d1==2&&x==y)||(x>n||y>n))
        {ans++;continue;}//弱智的假话
        if(d1==1)
        {
            if(find(x)==find(y))//x y在一个并查集中，找假话
            {if(d[x]!=d[y]) ans++;}//关于距离
            else//x y不在一个并查集中，合并并查集
            {
                d[f[x]]=(d[y]-d[x]+3)%3;//关于距离
                f[f[x]]=f[y];//关于父亲
            }
        }
        if(d1==2)
        {
            if(find(x)==find(y))//x y在一个并查集中，找假话
            {if(d[x]!=(d[y]+1)%3) ans++;}//关于距离
            else//x y不在一个并查集中，合并并查集
            {
                d[f[x]]=(d[y]-d[x]+4)%3;//关于距离
                f[f[x]]=f[y];//关于父亲
            }
        }
    }
    printf("%d\n",ans);
}
```

---

## 作者：远航之曲 (赞：36)

这种解法下面大神都没有提到，来一篇题解

经典并查集

1.p[x]表示x根结点。r[x]表示p[x]与x关系。r[x]=0 表示p[x]与x同类；1表示p[x]吃x；2表示x吃p[x]。

2.怎样划分一个集合呢？

注意，这里不是根据x与p[x]是否是同类来划分。而是根据“x与p[x]能否确定两者之间关系”来划分，若能确定x与p[x]关系，则它们同属一个集合

3.怎样判断一句话是不是假话？

假设已读入D ,X ,Y ,先利用find()函数得到X,Y所在集合代表元素fx,fy,若它们在同一集合（即fx==fy）则可以判断这句话真伪：

若 D==1 而 r[X]!=r[Y] 则此话为假.（D==1 表示X与Y为同类，而从r[X]!=r[Y]可以推出 X 与 Y 不同类.矛盾.）

若 D==2 而 r[X]==r[Y]（X与Y为同类）或者r[X]==(r[Y]+1)%3（Y吃X）则此话为假。

4.上个问题中r[X]==(r[Y]+1)%3这个式子怎样推来？

假设有Y吃X，那么r[X]和r[Y]值是怎样？

       我们来列举一下:

                   r[X]=0&&r[Y]=2 

                           r[X]=1&&r[Y]=0

                           r[X]=2&&r[Y]=1

稍微观察一下就知道r[X]=(r[Y]+1)%3;

事实上，对于上个问题有更一般判断方法：

若(r[Y]-r[X]+3)%3!=D-1 ,则此话为假.

5.其他注意事项:

在unionn(d,x,y)过程中若将S(fy)合并到S(fx)上，则相应r[fy]必须更新为fy相对于fx关系。怎样得到更新关系式？


       r[fy]=(r[x]-r[y]+d+3)%3;

代码实现如下


```cpp
#include <cstdio>
using namespace std;
int p[50001],r[50001],n,k,ans,x,y,d;
int find(int x)
{
    if (x!=p[x])
    {
        int fx=find(p[x]);
        r[x]=(r[x]+r[p[x]])%3;
        p[x]=fx;
    }
    return p[x];
}
bool unionn(int d,int x,int y)
{
    int fx=find(x),fy=find(y);
    if (fx==fy)
        if ((r[y]-r[x]+3)%3!=d) return 1;
        else return 0;
    p[fy]=fx;
    r[fy]=(r[x]-r[y]+d+3)%3;
    return 0;
}
main()
{
    scanf("%d %d",&n,&k);
    for (int i=1;i<=n;i++) p[i]=i,r[i]=0;
    for (int i=1;i<=k;i++)
    {
        scanf("%d %d %d",&d,&x,&y);
        if(x>n||y>n||(x==y && d==2)){ans++;continue;}
        if (unionn(d-1,x,y)) ans++;
    }
    printf("%d",ans);
}

```

---

## 作者：Strong_Jelly (赞：23)

**题目描述**

动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B

吃 C，C 吃 A。

现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道

它到底是哪一种。

有人用两种说法对这 N 个动物所构成的食物链关系进行描述：

**第一种说法是“1 X Y”，表示 X 和 Y 是同类。**

**第二种说法是“2 X Y”，表示 X 吃 Y 。**

此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真

的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

• **当前的话与前面的某些真的话冲突，就是假话**

• **当前的话中 X 或 Y 比 N 大，就是假话**

• **当前的话表示 X 吃 X，就是假话**

你的任务是根据给定的 N 和 K 句话，输出假话的总数。



------------
思路：把x定义为同类，x+n定义为猎物，x+2*n定义为天敌。根据题目写代码。

code：
```cpp
#include <bits/stdc++.h> //万能头 
using namespace std;
int fa[300001];
//并查集 
int find(int x)//查找 
{
	if(x != fa[x])
	{
		fa[x] = find(fa[x]);
	}
	return fa[x];
}
int unity(int x, int y)//合并 
{
	int r1 = find(fa[x]);
	int r2 = find(fa[y]);
	fa[r1] = r2;
}
int main()
{
	int i, n, k, x, y, z;
	int ans = 0;
	scanf("%d %d", &n, &k);//输入 
	for(i = 1; i <= 3 * n; i++)//初始化 
	{
		fa[i] = i; 
	}
	// x是同类，x + n是猎物， x + 2 * n是天敌 
	for(i = 1; i <= k; i++)
	{
		scanf("%d %d %d", &z, &x, &y);
		if(x > n || y > n)//x和y不能大于n 
		{
			ans++;//假话++ 
		}
		else
		{
			if(z == 1)//x和y是同类 
			{
				if(find(x + n) == find(y) || find(x + 2 * n) == find(y))//如果是同类，x不能是y的猎物或天敌 
				{
					ans++;//假话++ 
				}
				else
				{
					unity(x, y);//x的同类是y的同类 
					unity(x + n, y + n);//x的猎物是y的猎物
					unity(x + 2 * n, y + 2 * n);//x的天敌是y的天敌 
				}
			}
			else//y是x的猎物 
			{
				if(x == y || find(x) == find(y) || find(x + 2 * n) == find(y))//如果y是x的猎物，x不能是y的猎物，x不能和y是同类，y不能是x的天敌 
				{
					ans++;//假话++ 
				}
				else
				{
					unity(x, y + 2 * n);//x的同类是y的天敌 
					unity(x + n, y);//x的猎物是y的同类
					unity(x + 2 * n, y + n);//x的天敌是y的猎物
				}
			}
		}
	}
	printf("%d", ans);//输出 
	return 0;
}
```
结束

---

## 作者：Eleveslaine (赞：19)

本题可以用十分简洁且好想的扩展域并查集求解，所以**这是一篇偏冷门的边带权并查集的题解**。

前置知识：普通并查集，路径压缩。

称最高祖先是并查集森林中一棵树的根节点。约定 $f_x$ 表示 $x$ 的父结点（最高祖先的 $f_x=x$），$\operatorname{find}(x)$ 函数返回 $x$ 所在集合中的最高祖先，$d_x$ 表示边 $(x,f_x)$ 的边权，$d_x \in \{0,1,2\}$：

- $d_x=0$，表示 $x,f_x$ 是同类；
- $d_x=1$，表示 $x$ 吃 $f_x$；
- $d_x=2$，表示 $f_x$ 吃 $x$。

容易发现对于任意两只动物 $x,f_x$，它们的关系有且仅有上述三种，因此 $d_x\in\{0,1,2\}$ 是可行的。显然最高祖先的 $d$ 值为 $0$。

## 路径压缩求 $\boldsymbol{d_x}$

显然，我们只需要求出如下情况即可归纳到任意情况，即求出 Graph \#2 中边 $(x,\mathrm{root})$ 的权 $d_x'$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2f3aj1wf.png)

枚举 Graph \#1 中 $d_x,d_{f_x}$ 的 $9$ 种情况，得

$$
d_x' \equiv d_x+d_{f_x} \pmod 3
$$

于是可以设计 $\operatorname{find}$ 函数如下：

$$
\begin{array}{r|l}
  & \operatorname{find}(x:\bold{Node}) \rightarrow \bold{Node}\\
\hline
1 & \bold{if}\ f_x=x \\
2 & \quad \bold{return}\ x \\
3 & \bold{else} \\
4 & \quad \mathrm{root} \gets \operatorname{find}(f_x) \\
5 & \quad d_x \gets \left(d_x+d_{f_x}\right) \bmod 3\\
6 & \quad f_x \gets \mathrm{root} \\
7 & \quad \bold{return}\ \mathrm{root} \\
\end{array}
$$

在 $\operatorname{find}(x)$ 的过程中，$x$ 到其最高祖先 $\mathrm{root}$ 路径上的所有结点会被路径压缩直接指向 $\mathrm{root}$，顺便更新这些结点的 $d$ 值。

## $\boldsymbol{x,y}$ 是同类

设 $X=\operatorname{find}(x),Y=\operatorname{find}(y)$，在此过程中将 $x,y$ 路径压缩至根。要求合并后 $X$ 是 $Y$ 的儿子。

当 $X \ne Y$ 时，如下图。显然目标是求 $d_X$。

![](https://cdn.luogu.com.cn/upload/image_hosting/a143j16w.png)

枚举 Graph \#3 中 $d_x,d_y$ 的 $9$ 种情况，得

$$
d_X \equiv d_y - d_x \pmod 3
$$

当 $X=Y$ 时，$x,y$ 的关系已知：$x,y$ 是同类，当且仅当 $d_x=d_y$，否则这句话为假话。枚举可得。

## $\boldsymbol x$ 吃 $\boldsymbol y$

同上，枚举 Graph \#3 中 $d_x,d_y$ 的 $9$ 种情况，得

$$
d_X \equiv d_y - d_x + 1\ (\bmod\ 3),X \ne Y
$$

当 $X=Y$ 时，$x,y$ 的关系已知：$x$ 吃 $y$，当且仅当 $d_y-d_x+1 \equiv 0 \pmod 3$，否则这句话为假话。枚举可得。

## 边权 $\boldsymbol d$ 的实质

~~事实上我写这题的时候也是先设计 $d$ 再发现其实质的。~~  
手动枚举 $9$ 种情况太麻烦了，有没有更简单的方法？  
我们知道，本题的食物链是一个 $A \to B \to C \to A$ 的三元环。  
边权 $d_x$ 的实质即：**三元环上，$\boldsymbol x$ 沿有向边走到 $\boldsymbol{f_x}$ 所经过的边数**。

应用边权的实质，便可以轻松得到我们经过枚举得出的式子。

代码就不给了喵，看完上面应该是能自己写出来的。要注意负数取模喵，可以把 `(d[y]-d[x])%3` 改成 `(d[y]+2*d[x])%3`（显然等价）。

---

## 作者：藕丝炖刺猬 (赞：14)


```cpp
//带权并查集    详细的看代码里的注释
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<cstring>
using namespace std;
int fa[50005],ran[50005];                                   //ran指种族 
int n,k;
int get_fa(int x)
{
    if(fa[x]==x) return x;
    int f=fa[x];
    fa[x]=get_fa(fa[x]);                                    //路径压缩 
    ran[x]=(ran[x]+ran[f])%3;
    return fa[x];                                    
}
bool judge(int c,int x,int y)                        
{
    int a=get_fa(x),b=get_fa(y);
    //cout<<a<<" "<<ran[x]<<" "<<b<<" "<<ran[y]<<endl; 
    if(a==b)                                                 //说明已经过确定关系了 
    {
        if(c==1)
        {
            if(ran[x]!=ran[y]) return false;
        }
        if(c==2)
        {
            if(ran[x]==1&&ran[y]!=0) return false;
            if(ran[x]==2&&ran[y]!=1) return false;
            if(ran[x]==0&&ran[y]!=2) return false;
        }
        return true;
    }
    else{                                                     //说明没有确定过关系 
        fa[a]=b;
        //cout<<c<<" "<<ran[x]<<" "<<ran[y]<<endl;
        if(c==2) ran[a]=(ran[y]-ran[x]+3+1)%3;
        if(c==1) ran[a]=(ran[y]-ran[x]+3)%3;
        //cout<<fa[a]<<ran[a]<<endl;
        a=get_fa(x); b=get_fa(y);
        //cout<<"changed:"<<a<<" "<<ran[x]<<" "<<b<<" "<<ran[y]<<endl;
        return true;
    }
}
int main()
{
    cin>>n>>k;
    int ans=0;
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=k;i++)
    {
        int c,a,b;
        scanf("%d %d %d",&c,&a,&b);
        if(a>n||b>n) ans++;
        else if(c==2 && a==b) ans++;
        else if(judge(c,a,b)) continue;
        else ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：倾尘 (赞：9)

考虑单一一种情况（A吃B），我们可以搜索能吃A的X1，能吃X1的X2...Xn，如果这些数中有B的话，便是假话。那么我们发现这样的搜索会重复很多搜索过的内容，浪费大量的时间，我们便需要优化，去除重复搜索的内容，这样，很容易想到并查集。


并查集：并查集主要分为一个找祖先和合并的过程。主要思想就是每个点的祖先先定义为自己。一旦需要合并，就把右边的点祖先改为左边的点（左边改右边也行），找祖先就看什么时候祖先为自身就是找到了最初的祖先，否则继续找上一代的祖先。


可以用深度优先搜索：


```cpp
Int ss(int k)
{
If(f[k]==k)
Return k;
Else
Return f[k]=ss(f[k]);
}
```
那样判断A和B的关系可以从判断f[A]和f[B]用O（1）的时间解决。 这道题有一些特殊，包含了三种类别（A\B\C）,认真思考一下可以通过建立几个并查集a,b,c来记录不同的关系，也可以通过 建立补集法（个人认为更加好理解并且代码更加精炼）。

建立补集法 就是建立三倍大小的集合，并可以分为三个部分。而每个部分代表着一种动物种类，里面的每个元素代表每个动物可能为这个动物种类。其中我们可以认为 1 ~ n 的部分是物种X，n+1 ~ 2n 的部分是生产者（被物种X吃），2n+1 ~ 3n 的部分是消费者（吃物种X）。当然，由于环状关系，我们可以认为 n+1 ~ 2n 的部分是物种X，2n+1 ~ 3n 的部分是被物种X吃，1 ~ n 的部分是吃物种X……这样一来，每有一句真话，我们需要分别给三组集合合并。


A[k]物种K A[k+n]吃K的物种 A[k+2n]K吃的物种


```cpp
X=1
a[f(y)]=f(z); // Y Z同类
a[f(y+n)]=f(z+n);//吃Y的 吃Z的同类
a[f(y+2*n)]=f(z+2*n);//Y吃的 Z吃的同类
X=2
a[f(y+n)]=f(z); //吃Y的 Z同类
a[f(y+2*n)]=f(z+n); //Y吃的 吃Z的同类
a[f(y)]=f(z+2*n);//Y Z吃的同类
```
我们可以通过建立如此的关系来简单判断X1，X2的关系，从而简单的判断是否说谎。 最终这道题就简单的解决了。

至于其他的小细节自己判断。


---

## 作者：封禁用户 (赞：8)

## P2024蒟蒻的题解
这道题是一道十分明显的并查集的题目，这点不难发现
但是容易进入一个误区，就是以动物的种类单独分并查集

对于这种题，我们需要开3倍空间的并查集
### 最基础的并查集操作
```
int pre()//初始化操作
{
	int i;
	for(i=1;i<=3*n;i++)
	{
		f[i]=i;//f[n]以后就用不存在的值代替，避免出现BUG（添加1~n的数也行）
	}
} 
int find(int x)//寻找和压缩操作
{
	if(f[x]==x)
	{
		return x;
	}else
	{
		return f[x]=find(f[x]);
	}
}
int fadd(int a,int b)//合并操作
{
    a=find(a);
    b=find(b);
    if(a!=b)
    {
        f[a]=b;
    }
}
```


在f[1]~[n]表示同意类 f[n+1]~[2*n]表示被它吃的 f[2*n+1]~f[3*n]表示吃它的
## 读入1
#### 读入原理
对于同类这句话，我们只用判断他们是不是有吃的关系就行了也就是判断A有没有吃B或被B吃，不用反过来判断，因为我们得到关系后会是双向添加的

#### 读入代码
```
void read1()
{
	int a,b;
	scanf("%d%d",&a,&b);
	if(a>n || b>n)//判断是否超出边界
	{
		sum++;//这个计数变量就开全局变量，方便叠加
		return;
	}
	if(find(a+n)==find(b) || find(a+2*n)==find(b))//判断是否有互吃的关系
	{
		sum++;
		return;
	}
	fadd(a,b);//添加同类
	fadd(a+n,b+n);//吃的关系也会是同类（设B1吃A1，现在知道了A1和A2同类，那么B1也会吃A2，所以这个也加入并查集）
	fadd(a+2*n,b+2*n);//被吃的关系同理
}
```
## 读入2
#### 读入原理
这个也只用判断2个东西.
1.是不是同类（或者自己吃自己）
2.是不是本来有A吃B，但输入是B吃A
同样的不用反向判断
#### 读入代码
```
void read2()
{
	int a,b;
	scanf("%d%d",&a,&b);
	if(a>n || b>n)
	{
		sum++;
		return;
	}
	if(a==b)
	{
		sum++;
		return;
	}
	if(find(a)==find(b) || find(a+2*n)==find(b))
	{
		sum++;
		return;
	}
	fadd(a+n,b);//吃的关系
	fadd(a,b+2*n);//被吃的关系
	fadd(a+2*n,b+n);//原谅我语文不好，循环一圈，像提前知道A吃C，读入C吃B，根据题意，那B就该吃A，所以被A吃的能吃B，所以有这个读入
}
```
## 总体
直接一个个读入，时间复杂度是在O(1)区间，不会超时，优化都不用

就是注意一下计数变量的开始值为0，还有并查集开总体的3倍空间就好了
#### 总体代码
```
#include "cstdio"
using namespace std;
const int N=5e4+7;
int f[N*3];//记住开三倍的并查集
int n,m;
int sum;
int pre()
{
	int i;
	for(i=1;i<=3*n;i++)
	{
		f[i]=i;
	}
} 
int find(int x)
{
	if(f[x]==x)
	{
		return x;
	}else
	{
		return f[x]=find(f[x]);
	}
}
int fadd(int a,int b)
{
    a=find(a);
    b=find(b);
    if(a!=b)
    {
        f[a]=b;
    }
}
void read1()
{
	int a,b;
	scanf("%d%d",&a,&b);
	if(a>n || b>n)
	{
		sum++;
		return;
	}
	if(find(a+n)==find(b) || find(a+2*n)==find(b))
	{
		sum++;
		return;
	}
	fadd(a,b);
	fadd(a+n,b+n);
	fadd(a+2*n,b+2*n);
}
void read2()
{
	int a,b;
	scanf("%d%d",&a,&b);
	if(a>n || b>n)
	{
		sum++;
		return;
	}
	if(a==b)
	{
		sum++;
		return;
	}
	if(find(a)==find(b) || find(a+2*n)==find(b))
	{
		sum++;
		return;
	}
	fadd(a+n,b);
	fadd(a,b+2*n);
	fadd(a+2*n,b+n);
}
int main()
{
	int i;
	scanf("%d%d",&n,&m);
	pre();
	for(i=1;i<=m;i++)
	{
		int pd;
		scanf("%d",&pd);
		if(pd==1)
		{
			read1();
		}else
		{
			read2();
		}
	}
	printf("%d",sum);
}
```
差不多就是这样

---

## 作者：nth_element (赞：6)

## 目录：

- 简介
- 例题简析

***

## 一、简介

普通的并查集只能维护联通性，即`朋友的朋友是朋友`；但当我们要维护对立性的时候，即`敌人的敌人是敌人`，就需要种类并查集了。

种类并查集指将元素分为两个并查集，若是联通的，即两者是朋友，我们就将其放入同一个并查集中；若是对立的，即两者是敌人，我们就将其放入两个不同的并查集中。

但这时我们并不知道这两个元素应该属于`A`群系还是`B`群系，故我们在放入之前先判断一下。一开始放入哪个群系都没有关系，但在第二次合并的时候，就应该判断一下，若是`朋友`，就将其放入同一个并查集中；若是`敌人`，就将其放入不同的并查集中。

***

## 二、例题简析

1. 三元种类并查集（[P2024 [NOI2001]食物链](https://www.luogu.com.cn/problem/P2024)）

   **Description**:

   给定 $n$ 个元素，有以下两种关系：

   - $x\sim y$ （即表示x和y是同类）
   - $x\rightarrow y$ （即表示x吃y）

   再给定 $m$ 条语句，确定 $n$ 个元素的关系，判断语句真假。

   **Mothod**:

   显然，我们可以发现，在x与y两个元素之间有三种关系：

   1. $x \sim y$
   2. $ x\rightarrow y$
   3. $x \leftarrow y$

   此时用上面介绍的二元种类并查集显然是不能实现的，因为这种并查集两种元素之间只有两种关系：联通与对立。

   但不能使用二元种类并查集，我们可以使用三元并查集啊。此时我们就将所有元素分为三个并查集，`A`群系表示最高级动物，`B`群系表示中间级动物，`C`群系表示最低级动物。此时恒有 $A \rightarrow B$，$B\rightarrow C$。

   那么如何合并元素呢？

   若是 $ x\sim y$ ，但我们不知道x和y到底属于哪个群系， 那么我们就将`A`,`B`,`C`群系中的每一个x与y都连接在一起。即 $x_A\eqcirc  y_A$  , $x_B \eqcirc  y_B$ , $x_C \eqcirc  y_C$ ( $x_C$ 表示 $x\in C$ , $\eqcirc  $ 表示将左右两边的元素合并)。

   若是 $x\rightarrow y$ ，我们同样不知道x和y到底属于那个群系，于是我们就按照先前定义的，群系`A`中的x与群系`B`中的y合并，另两者相似。即 $x_A \eqcirc y_B$ , $x_B \eqcirc y_C$ , $ x_C \eqcirc y_A$ 。

   有如何判断语句真假呢？首先可以确定一点，我们判断该语句为真很困难，即从正面判断很困难，正难则反，我们从反面来考虑。

   若是语句 $x\sim y$ ，我们从反面判断，即判断是否是 $x\rightarrow y$ 或者 $x\leftarrow y$ 。即判断 $x_A \eqcirc y_B$ 或者 $y_A \eqcirc x_B$ 。  

   若是语句 $x \rightarrow y$ ，我们就判断是否是 $x \sim y$ 或者 $x\leftarrow y$ 。即判断 $x_A \eqcirc y_A$ 或者 $y_A \eqcirc x_B$ 。

   最后就是简单的模板题了。

   **Code**:

   ```cpp
   #include<bits/stdc++.h>
   #define Maxn 50010
   using namespace std;
   inline void read(int &x)
   {
       int f=1;x=0;char ch=getchar();
       while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
       while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch-'0');ch=getchar();}
       x*=f;
   }
   int fa[Maxn*3];
   inline int findf(int x)
   {
       if(fa[x]==x) return x;
       return fa[x]=findf(fa[x]);
   }
   int n,m;
   int ans=0;
   signed main()
   {
       read(n),read(m);
       for(int i=1;i<=3*n;i++) fa[i]=i;
       while(m--)
       {
           int opt;read(opt);
           int x,y;read(x),read(y);
           if(x>n||y>n){ans++;continue;}
           if(opt==1)
           {
               if(findf(x)==findf(y+n)||findf(y)==findf(x+n)) ans++;
               else
               {
                   fa[findf(y)]=findf(x);
                   fa[findf(y+n)]=findf(x+n);
                   fa[findf(y+2*n)]=findf(x+2*n);
               }
           }else if(opt==2)
           {
               if(findf(x)==findf(y)||findf(y)==findf(x+n)) ans++;
               else
               {
                   fa[findf(y+n)]=findf(x);
                   fa[findf(y+2*n)]=findf(x+n);
                   fa[findf(y)]=findf(x+2*n);
               }
           }
       }
       printf("%d\n",ans);
       return 0;
   }
   ```

   **Warning**:
   
   - 一定要把`fa[i]`初始化为`i`，而不是`0`。若初始化为`0`，在第一种操作中很容易没有判两个数相等的情况，这样就会导致一个数的爸爸是他自己然后引起无限递归。……卡了一下午。
   - 一定记得加上`if(x>n||y>n){ans++;continue;}`,若编号大于`n`，直接跳出去。

---

## 作者：Y1shuiLi (赞：5)

拓展域并查集

对a

1ton是a的友好域

n+1ton*2是a的食物

第三个域是a的敌人

x>y>z

若x吃y

合并1与3 x的同类与y的敌人挂钩

合并2与1 x的食物与y的同类挂钩

合并3与2 x的敌人与y的食物挂钩

若x被y吃

把以上所有x替换成y，y替换成x；

若xy是同类

分别合并以下的112233

那x的敌人和y的敌人挂钩

x的食物和y的食物挂钩

x的同类和y的同类挂钩

判断：

x和y之间若不是同类只有吃与被吃

若同类是假话---x吃y或者y吃x就不成立

若x吃y是假话 则y吃x或y与x是同类

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[150005];
int find(int i) {
    if (f[i] != i) {
        f[i] = find(f[i]);
    }
    return f[i];
}
int main() {
    int n, k, d, x, y, ans = 0;
    // freopen("hh.in","r",stdin);
    // freopen("hh.out","w",stdout);
    cin >> n >> k;

    for (int i = 1; i <= n * 3; i++) f[i] = i;

    for (int i = 1; i <= k; i++) {
        cin >> d >> x >> y;
        if (d == 1)  //同类
        {
            if (find(y) == find(x + n) || find(x) == find(y + n)) {
                ans++;
            } else if (x > n || y > n) {
                ans++;
            } else {
                f[find(x)] = find(y);
                f[find(x + n)] = find(y + n);
                f[find(x + n + n)] = find(y + n + n);
            }
        }
        if (d == 2) {
            if (find(x) == find(y) || find(y + n) == find(x)) {
                ans++;
            }  //或者y吃x
            else if (x > n || y > n) {
                ans++;
            } else {
                f[find(x)] = find(y + n + n);
                f[find(x + n)] = find(y);
                f[find(x + n + n)] = find(y + n);
            }
        }
    }
    cout << ans;
}
```


---

## 作者：取名最烦 (赞：5)

##我来讲一下那个合并时计算原来两根距离表达式的推导方法。

#设合并后两根距离为a(即要求的量）

 ![](https://cdn.luogu.com.cn/upload/pic/14256.png) 

R[i]表示点i到他们原来祖先的距离，途中所有线段长都可以表示。

注意每条边的长度是不一样的，∴R[x]+a-R[y]≠R[x]，而等于x、y的距离即食物关系（大家可以往下翻，下面有关于这个的讲解）

设该距离为t

#方程：R[x]+a=t+R[y]，整理得a=t-R[x]+R[y],当然把x与y换一下也是成立的，这取决于你的程序。

剩下的前人都讲过了，再次我都不赘述了。


---

## 作者：George1123 (赞：5)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P2024 【食物链】传送门](https://www.luogu.org/problem/P2024)

### 此题算法:并查集

稍微有些复杂，题目条件一个都不能少看

总体思路简单：用并查集模拟一棵树，

$deep[i]$表示$i$节点的深度(食物链等级)

$f[i]$表示$i$的父亲节点

题目中说只有$ABC$三种动物并且互为天敌

所以deep[i]只能是$2,1,0$表示$A,B,C$

$A$吃$B$,$B$吃$C$,$C$吃$A$

1.构造同类

```cpp
void unity(int x,int y){
	int xn=find(x),yn=find(y);
	if(xn==yn) return;
	//已经是同类了
	f[yn]=xn;
	deep[yn]=(deep[x]-deep[y]+3)%3;
}
```
2.x吃y
```cpp
void eat(int x,int y){
	int xn=find(x),yn=find(y);
	if(xn==yn) return;
	f[xn]=yn;
	deep[xn]=(deep[y]-deep[x]+5)%3;
	//就是deep[x]=deep[y]+1;
	//从头修改,find()函数时x和y的深度会更新
} 
```
3.是否是同类和x是否吃y
```cpp
bool same(int x,int y){
	if(find(x)!=find(y))
		return 1;
	return deep[x]==deep[y];
} bool iseat(int x,int y){
	if(find(x)!=find(y))
		return 1;
	return (deep[x]+1)%3==deep[y];
}
```
4.小x找祖先
```cpp
int find(int x){
	if(f[x]==x) return x;
	int tmp=find(f[x]);
	deep[x]=(deep[x]+deep[f[x]])%3;
	//不忘更新深度
	return f[x]=tmp;
}
```
## 以下是代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
int n,k,a,b,c,ans;
struct Un{
	int f[N],deep[N];
	void build(int x){
		for(int i=1;i<=x;i++){
			f[i]=i;
			deep[i]=0;
		}
	} int find(int x){
		if(f[x]==x) return x;
		int tmp=find(f[x]);
		deep[x]=(deep[x]+deep[f[x]])%3;
		return f[x]=tmp;
	} void unity(int x,int y){
		int xn=find(x),yn=find(y);
		if(xn==yn) return;
		f[yn]=xn;
		deep[yn]=(deep[x]-deep[y]+3)%3;
	} void eat(int x,int y){
		int xn=find(x),yn=find(y);
		if(xn==yn) return;
		f[xn]=yn;
		deep[xn]=(deep[y]-deep[x]+5)%3;
	} bool same(int x,int y){
		if(find(x)!=find(y))
			return 1;
		return deep[x]==deep[y];
	} bool iseat(int x,int y){
		if(find(x)!=find(y))
			return 1;
		return (deep[x]+1)%3==deep[y];
	}
}BCJ;
int main(){
	scanf("%d%d",&n,&k);
	BCJ.build(n);
	for(int i=1;i<=k;i++){
		scanf("%d%d%d",&a,&b,&c);
		if(a==1){
			if(b>n||c>n||!BCJ.same(b,c)){
				ans++;
				continue;
			} BCJ.unity(b,c);
		} else {
			if(b>n||c>n||b==c||!BCJ.iseat(b,c)){
				ans++;
				continue;
			} BCJ.eat(b,c);
		}
	} printf("%d\n",ans); 
	return 0;
}
```
每句话,要判断动物是否存在$(>n)$,

要判断关系是否与之前矛盾,并计算假话数

最后的$ans$就是答案了

谢谢大家! !










---

## 作者：KaisuoShutong (赞：5)

### 没有看懂楼下任何一个大佬对合并操作的分析
**~~（一定是我太菜了QwQ）~~**

于是自己推了推，发现用“数学的语言”很好懂。（为什么其他题解都把简单的东西讲得特别详细啊啊啊）

Method：带权并查集不解释。

对**合并并查集操作**的解释：

```cpp
对于第二种操作，判完合法以后，就一定知道f[x]一定是x那一个并查集的根节点了（因为进行了GetFather操作路径压缩），那么f[x]的d肯定为0。
d值其实可以理解为这个是什么生物（在默认根节点为0号生物时）。
但现在它要接到y上去，又因为我们规定0吃2，2吃1，1吃0，且此时x吃y为合法，不妨用real(x)表示x真正是什么生物。
所以（以下均省略取模）可得real(x)=real(y)+1，那么f[x]和f[y]的距离就有关系real(f[x])+d[x]=real(f[y])+d[y]+1。
合并得real(f[x])-real(f[y])=d[y]-d[x]+1。
将根节点接到y的下面，就非常好办了。
第一种操作同理，只是不加1。
```

至于其他的地方，其他题解已经讲得非常清楚了，这里就不再赘述。  
还是放一下代码吧。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n,k;
int f[50001],d[50001];
int Find(int x)
{
	if(x==f[x]) return x;
	int X=f[x];
	f[x]=Find(f[x]);
	d[x]=(d[X]+d[x])%3;
	return f[x];
}
int main()
{
	int opt,x,y,ans=0;
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++) f[i]=i,d[i]=0;
	for(int i=1;i<=k;i++)
	{
		scanf("%d %d %d",&opt,&x,&y);
		if(((--opt)&&x==y)||(x>n||y>n)) {ans++;continue;}
		if(opt)
		{
			if(Find(x)==Find(y))
				{if(d[x]!=(d[y]+1)%3) ans++;}
			else
			{
				d[f[x]]=(d[y]-d[x]+1+3)%3;
				f[f[x]]=f[y];
			}
		}
		else
		{
			if(Find(x)==Find(y))
				{if(d[x]!=d[y]) ans++;}
			else
			{
				d[f[x]]=(d[y]-d[x]+3)%3;
				f[f[x]]=f[y];
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

可以通过所有数据。

---

## 作者：Priori_Incantatem (赞：4)

### 题目大意

动物王国中有三类动物$A,B,C$，一共有$n$个动物和$m$条信息  
要求判断这$m$条信息里有多少条信息是假的

这题是比较经典的种类并查集题，对于本题，我们需要开$3\times n$大小的并查集维护每个动物为以上三类的情况

对于每个动物$x$，在$A,B,C$类中的情况分别用 $x,x+n,x+n+n$表示

#### 对于操作$1$（合并同类）：  
若 $x,y$ 已经给出过了互吃的关系，假话！
否则，合并 $(x,y)$，$(x+n,y+n)$，$(x+n+n,y+n+n)$

#### 对于操作$2$ （$x$ 吃 $y$）:
若已经有了$y$ 吃 $x$ 的关系或者已经 $x,y$ 已经为同类，假话！
否则合并 $(x,y+n)$，$(x+n,y+n+n)$，$(x+n+n,y)$

**代码：**

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int Maxn=150000+23,inf=0x3f3f3f3f;
int f[Maxn],n,m,ans;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int find(int x)
{
	if(f[x]==x)return x;
	return f[x]=find(f[x]);
}
inline void uni(int x,int y)
{
	f[find(x)]=find(y);
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=n*3;++i)
	f[i]=i;
	for(int i=1;i<=m;++i)
	{
		int opt=read(),x=read(),y=read();
		if(x>n ||y>n || x==y && opt==2){ans++;continue;}
		if(opt==1)
		{
			if(find(x)==find(y+n) || find(x+n)==find(y))
			{ans++;continue;}
			uni(x,y);
			uni(x+n,y+n);
			uni(x+n+n,y+n+n);
		}
		else
		{
			if(find(x)==find(y) || find(y)==find(x+n))
			{ans++;continue;}
			uni(x,y+n);
			uni(x+n,y+n+n);
			uni(x+n+n,y);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：songhn (赞：4)

# 带权并查集题解
PS：题解参考了许多dalao的文章所以难免有既视感，请见谅

一般普通的并查集只能确定节点与父节点的关系，但比如像是
食物链这种类型的题目，给定了ABC的关系，这个时候就需要给并查集加权，这个权一般用来表示两个节点之间的关系，由于三种动物之间是吃与被吃的关系，所以我们不妨用模运算来表示节点之间的关系。
## 1.权值确定
0-节点与父节点是同类
1-节点被父节点吃
2-节点吃父节点
这样定义关系以后正好可以与题目中输入1-x与y同类 2-x吃y相对应。
## 2.节点关系确定
### 节点间的关系
首先我们定义两个两个数组fa[],rank[]，fa用来维护并查集，而rank则是用来表示当前节点与父节点的关系。

下面我们通过穷举推导出通过AB关系表示一节点与父节点关系的关系式。

| 节点A与父关系 | 节点A与B关系 |  节点B与父关系|
| :----------: | :----------: | :----------: |
|0  |  0|  0|
|0  | 1 |  1|
|  0| 2 |  2|
|  1|  0|  1|
|  1|  1|  2|
|  1|  2|  0|
|  2|  0|  2|
|  2|  1|  0|
|  2|  2|  1|
由此不难得出关系式:**rank[B]=(rank[B]+rank[A])%3**这个公式可以用来更新并查集

这样就可以通过节点与之前父节点的关系和之前父节点到当前节点的关系来维护当前节点与现在父节点的关系
### 集合间的关系
我们可以通过当前节点的关系反推出两集合间的关系。两集合分别是X所在集合和Y所在集合，设A=findx(X),B=findx(Y),首先我们来看一下推导出的公式 :（p为判断XY是同类还是互吃）

**rank[A]=(rank[X]-rank[Y]+3+(p-1))%3**

p-1：这是XY之间的关系，
3-rank[Y]:父节点与Y的关系

所以两集合合并的过程是这样的：先把X与Y相关联，这样X是Y的父亲，那原来Y的父亲便变成了Y的子节点，再把Y的父节点与X关联，最后把Y的父节点从X移动到X的父节点上，通过之前的关系式**rank[B]=(rank[B]+rank[A])%3**不难推导：

|  Y与现在父节点X的关系|+  | Y原来父节点与Y的关系 |
| :----------: | :----------: | :----------: |
|  p-1| + | 3-rank[Y] |

这便是Y父节点与X的关系，之后再加上X与X父节点的关系，就不难得到两集合合并的关系式了，不妨自己举几个例子来验证正确性。
## 3.判断真假
要想证明是否正确的，首先要把两个元素合并到同一集合中，假如两个元素不在同一集合的话，除非违背了规则，否则就是真的
我们可以通过之前推导的公式来进行判断

首先判断1 x y是不是假
```cpp
int a=findx(x),b=findx(y);
if(a==b)
	{
	if(d==1)
    if(rank[x]!=rank[y]) return false;
    }
```
然后判断2 x y是不是假
```cpp
if(d==2)
if((3-rank[x]+rank[y])%3!=2) return false;
//通过公式计算出两个元素之间是不是吃与被吃关系
```
## 4.AC代码
```cpp
#include<bits/stdc++.h> //万能头 
using namespace std;
const int maxn=200000;
int n,m,fa[maxn],rank[maxn],ans=0;//定义见上文 
int findx(int x) //建立并查集 
{
	if(x==fa[x]) return fa[x];
	int t=fa[x]; //获取x的父节点 
	fa[x]=findx(fa[x]);
	rank[x]=(rank[x]+rank[t])%3;
	return fa[x];
}
bool pan(int d,int x,int y)
{
	int a=findx(x),b=findx(y);
	if(a==b)
	{
		if(d==1)
			if(rank[x]!=rank[y]) return false;
		if(d==2)
			if((3-rank[x]+rank[y])%3!=2) return false;
	}
	fa[a]=b;
	if(d==1)
	rank[a]=(3+rank[y]-rank[x])%3;
	else 
	rank[a]=(3+1+rank[y]-rank[x])%3;
	return true;
} 
int main()
{
	int d,x,y;
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=m;i++)
    {
    	cin>>d>>x>>y;
    	if(x>n||y>n||(d==2&&x==y))//筛选情况 
    	{
    		ans++;
    		continue;
		}
		if(!pan(d,x,y)) ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：sqc1999 (赞：4)

这题显然要用并查集。因为只有3种动物，我的方法是对每个动物x建立3个集合：x表示与x同类的动物，x+n表示要x吃的动物，x+2\*n表示吃x的动物。

对于每个读入的描述D X Y，做以下处理：

\* 如果X或Y不再区间[1,n]中，这句是假话。

\* D为1

如果x+n或x+2\*n与y在同一个集合中说明已知x和y不是同一种动物，这句是假话；

否则，分别将x与y，x+n与y+n，x+2\*n与y+2\*n合并。

\* D为2

如果x与y在同一个集合中，说明已知x和y是同一种动物，这句是假话；

如果x+2\*n与y在同一个集合中，说明已知y吃x，这句是假话；

否则，分别将x与y+2\*n，x+n与y，x+2\*n与y+n合并。

<hr>
说起来很复杂，实现起来其实很简单，代码见下：

```cpp

#include<iostream>
#include<algorithm>
using namespace std;
int p[150001];
int Find(int x) { return x == p[x] ? x : p[x] = Find(p[x]); }
void Init(int n) { for (int i = 1; i <= 3 * n; i++) p[i] = i; }
void Union(int x, int y)
{
    int xx = Find(x), yy = Find(y);
    if (xx != yy) p[xx] = yy;
}
int main()
{
    int n, k, ans = 0;
    cin >> n >> k;
    Init(n);
    for (int i = 1; i <= k; i++)
    {
        int a, x, y;
        cin >> a >> x >> y;
        if (x > n || y > n || x < 1 || y < 1) { ans++; continue; }
        if (a == 1)
        {
            if (Find(x + n) == Find(y) || Find(x + 2 * n) == Find(y)) { ans++; continue; }
            Union(x, y);
            Union(x + n, y + n);
            Union(x + 2 * n, y + 2 * n);
        }
        else
        {
            if (Find(x) == Find(y) || Find(x + 2 * n) == Find(y)) { ans++; continue; }
            Union(x, y + 2 * n);
            Union(x + n, y);
            Union(x + 2 * n, y + n);
        }
    }
    cout << ans;
}

```

---

## 作者：vivarock (赞：4)

第一道提高加的题目

为此,写一个题解
## 并查集的操作 有 合并与查找 而本题正好用到这些






------------
一的猎物的猎物 就是一的天敌

知道这一点

所以本题就是维护三个并查集

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 300005
#define For(i,j,n) for(int i=(j);i<=(n);++i)
int fa[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	else return x;
}
#define un_i_on(x,y) fa[find(x)]=find(y);
int main(){
	int n,m,ans=0;
	cin>>n>>m;
	//读入
	For(i,1,n*3)fa[i]=i;
    //初始化
	For(i,1,m){
		int a,b,c;
		cin>>a>>b>>c;
		if(b>n||c>n){++ans;continue;}
        //如果标号大于n,则定是假话
		if(a==1){
			if(find(b+n)==find(c)||find(b+2*n)==find(c)){++ans;continue;}
            //如果1是2的天敌或猎物，显然为谎言
			else{un_i_on(b,c);un_i_on(b+n,c+n);un_i_on(b+2*n,c+2*n);}
			//同类合并
        }
		else{
			if(b==c){++ans;continue;}
			if(find(b)==find(c)||find(b+2*n)==find(c)){ans++;continue;}
			else {un_i_on(b,c+2*n);un_i_on(b+n,c);un_i_on(b+2*n,c+n);}
		}
        //与上面类似
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：tharong (赞：3)

这道题核心是维护**A吃B，B吃C，C吃A这个~~奇妙的~~环形关系**，普通的单倍并查集显然维护不了这个关系，但是我们可以开多倍并查集来维护这个关系。  
  首先我们可以尝试一下开**两倍并查集**，开两倍我们可以在同层并查集内维护同类关系，在两层并查集间维护捕食关系，例如我们认为第一层并查集的动物捕食第二层并查集的动物，但是当我们维护**A吃B，B吃C，C吃A这个~~奇妙的~~环形关系**时我们会发现，**当我们已经维护了A吃B，B吃C之后，A和C~~奇妙的~~变为了同类**，但很显然这是错误的，所以二倍并查集并不能维护**A吃B，B吃C，C吃A这个~~奇妙的~~环形关系**。  
  那二倍并查集失败了，我们还可以尝试一下开**三倍并查集**，和二倍并查集的思想一样，同层维护同类，在不同层并查集间维护捕食关系，例如我们可以认为第一层并查集的动物捕食第二层并查集的动物，第二层并查集的动物捕食第三层并查集的动物，第三层并查集的动物捕食第一层并查集的动物,这时我们会发现**当我们已经维护了A吃B，B吃C之后，C与A的关系就会~~奇妙的~~变成C捕食A**，所以我们开三倍并查集就可以维护**A吃B，B吃C，C吃A这个~~奇妙的~~环形关系**。  
 **下面是本蒟蒻的代码：**
  ```cpp
#include<cstdio>

using namespace std;

const int N = 5 * 1e4 * 3;

int n,k;
int fa[N],ans;

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

int main() {
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n * 3; i++) fa[i] = i;
    for(int i = 1; i <= k; i++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        if(y > n || z > n) {
            ans++;
            continue;
        }
        if(x == 1) {
            if(find(y) == find(z + n) || find(z) == find(y + n)) ans++;
            else {
               fa[find(y)] = find(z);
               fa[find(y + n)] = find(z + n);
               fa[find(y + n + n)] = find(z + n + n);
            }
        }
        else {
            if(find(y) == find(z) || find(z) == find(y + n)) ans++;
            else {
                fa[find(y)] = find(z + n);
                fa[find(y + n)] = find(z + n + n);
                fa[find(y + n + n)] = find(z);
            }
        }
    }
    printf("%d", ans);
    return 0;
}
```
**~~看AC后真是爽快啊！就像是穿着新内裤迎接新年来到的早晨一样爽呢~~**


------------

 **这是本蒟蒻的第一篇题解，意在加强下自己的理解，仅供参考，如果有什么理解偏差还请各路大神指正，蟹蟹!**

---

## 作者：maomao9173 (赞：3)

逻辑各位都能理清楚，关键是怎么维护这个逻辑。

#### 对于并查集这样一个数据结构来说，维护相同类型的数据比维护对立类型的数据要更加容易，所以我们需要考虑把对立关系转换成同类关系，也就是给并查集分组。

举个例子，看一下这句话：
	
    A的天敌是B。
 
这句话用并查集维护的话，我们需要把它转化成：
	
    A的天敌与B是同类。
    
同理的，对猎物关系也是这么处理。

为了更方便地表示A的天敌与B的同类关系，我们选择把数组开到三倍，来表示不同的关系映射。

这里我的定义是x+n为食物，x+2n为天敌。

注意在处理这三倍的关系的时候方式要一样（也就是说三个空间里的对应数据关系是一致的）。注意每次关系处理的时候三种关系都要对应上。

仔细思考，思路很好懂的。

```cpp
//对一个并查集来说，同类关系比对立关系更易于维护。
		scanf("%d%d%d",&t,&x,&y);
		if(x>n||y>n){ans++;continue;}
		if(t==1){
			if(find(x+n)!=find(y)&&find(y+n)!=find(x)){
				//x+n表示x的食物
				//y+n表示y的食物
				//这里用三倍空间记录 
				fa[find(x)]=fa[find(y)];
				fa[find(x+n)]=fa[find(y+n)];
				fa[find(x+n+n)]=fa[find(y+n+n)];
			}else ans++;
		}else{
			if(find(x)!=find(y)&&find(x)!=find(y+n)){
				//x不是y的食物而且x也不是y的同类。 
				fa[find(x+n)]=find(y);//y与x的食物同类
				fa[find(y+n+n)]=find(x);//x与y的敌人同类
				fa[find(x+n+n)]=find(y+n);//x的敌人与y的食物同类 
			}else ans++; 
		} 
```

---

## 作者：花开依然爱Qu (赞：2)

这个题本人用了加权并查集，思路很简单就是把它们分为三类，分别为0,1,2,。先进行判断，若为正确的，则跳过，错误的，数量加1，没有记录的则连接，将所有点都链接在同一个并查集内，再通过其与父节点的权值判断种类。

```cpp
//#include<iostream>
//#include<cstdio>
using namespace std;
int f[1000001],v[10000001];
int find(int x)//并查集链接
{
    if(x==f[x]) return x;
    int root=find(f[x]);
    v[x]=(v[x]+v[f[x]])%3;//根据权值进行分类
    f[x]=root;
    return f[x];
}
int unn(int x,int y,int op)//op表示关系
{
    int f1=find(x),f2=find(y);//搜索其父节点以便直接用父节点判断
    if(f1==f2)
    {
        if((v[x]-v[y]+3)%3!=op) return 1;//若已经存在这两者的关系，通过权值来判断他们之间的类别是否正确。
    }
    else//若没有存在这两者的关系，根据这个关系进行连接
    {
        f[f1]=f2;
        v[f1]=(v[y]-v[x]+op+3)%3;
    }
    return 0;
}
int main()
{
    int n,k,ans=0;
    cin>>n>>k;
    for(int i=1;i<=n;++i) f[i]=i;//并查集初始化
    for(int i=1;i<=k;++i)
    {
        int x,y,c;
        cin>>c>>x>>y;
        if(x>n||y>n||(c==2&&x==y)) 
        {
        ans++;continue;
        }
        ans+=unn(x,y,c-1);
    }
    cout<<ans;
}
```

---

## 作者：March (赞：2)

该题目可使用并查集：

给动物:a、b,还有关系c（1是同类，2是吃）

设a和b的根分别为Ra和Rb；

value数组里面：(V=0同类，V=1吃，V=2被吃)

如果Ra和Rb是同类则：Ra成为Rb的儿子（VRa=0）

如果Ra吃Rb则：Ra成为Rb的儿子（VRa=1）

如果Ra被Rb吃则：Ra成为Rb的儿子（VRa=2）

[/color][codec ]

```cpp
#include<iostream>//code by a young Feminist
#include<cstdio>
#define maxn 50100
using namespace std;
int set[maxn],val[maxn],N,M,ans=0;
int fa(int id){
    if(set[id]==id)
        return id;
    //
    int f=set[id];
    set[id]=fa(f);
    val[id]=(val[id]+val[f])%3;
    return set[id];
}
int main(){
    int a,b,c;
    scanf("%d%d",&N,&M);
    for(int i=1;i<=N+5;i++)
        set[i]=i, val[i]=0;
    for(int i=1;i<=M;i++){
        scanf("%d%d%d",&a,&b,&c);
        //
        if(b>N || c>N){ans++; continue;}
        //
        if(a==1){
            if(fa(b)==fa(c))
                if(val[b] != val[c])
                    ans++;
                else;
            else{
                val[set[b]]=(val[c]-val[b]+3)%3;
                set[set[b]]=set[c];
            }
        }else{
            if(b==c){ans++; continue;}
                if(fa(b)==fa(c))
                    if(val[b] != (val[c]+1)%3)
                        ans++;
                    else;
                else{
                    val[set[b]]=(val[c]-val[b]+4)%3;
                    set[set[b]]=set[c];
                }
        }
    }
    printf("%d\n",ans);
    return 0;
}
[/codec ]
```

---

## 作者：shzr (赞：2)

先说一下思路，用的是加权并查集，同一个集合里的动物可以确定相互关系（吃与被吃）。

%的巧妙运用，如果ab同类，v[b]=0,b吃a，=1，a吃b，=2；且压缩路径等操作时只需%3，因为abc形成环，2层吃的关系等于没关系（重点！）

------------



首先，读入一句话时，如果它犯了最基本的错误（自己吃自己，y或z>n等），计数器加一；

现在来判断一下：

操作1，且在一个集合中，显然，y，z相对于集合基准的值相同，不同则为假话；

操作1，不在同一集合，就没有理由认为他是错的，此时，z可以继承y在集合中的值，然而！！此处一定要注意，不是把z直接连接到y上！见下（因为并不会插入图片）

##    F[y]---- a------  F[z]

##    |(v[y])--------(v[z])|
##     y  -----0---------z

(⊙o⊙)…能看懂吧，就是说如果把z直接连到了y的祖先上，z的祖先就与z失去了联系，而其实，y祖先与z祖先此时已经可以确定关系了，所以我们列一个方程：a+v[y]=v[z]

解得a=v[z]-a[y],为了防止%负数，就+3，不影响结果；


------------


同理，操作二大致如此，方程为a=v[z]-a[y]+1；


    
    
    
    
    
    
    
    
```cpp
    # include <cstdio>
    # include <iostream> 
    using namespace std;
    int f[50005]={0},v[50005]={0}; //f数组保存祖先，v表示集合内关系值，0,1,2分别是同类，吃，被吃；
    int n,k,x,y,z,S=0;
    int father(int x)//路径压缩
    {
        if (x!=f[x])
        {
            int aa=father(f[x]);
            v[x]=(v[x]+v[f[x]])%3;
            f[x]=aa;
        }
        return f[x];
    }
    bool Ya(int x,int y,int z) 
    {
        int a=father(y);
        int b=father(z);
        if (a==b) // 在同一集合
        {
            if(x==1) 
            {
                if(v[y]==v[z]) return true; //值相同为真
                return false;    
            }
            if (x==2)
            {
                if(v[z]-v[y]!=-2&&v[z]-v[y]!=1) return false;  //值相差-2或1为真
                return true;
            }    
        }
        if (a!=b)
        {
            if(x==1)
            {
                v[b]=(v[y]-v[z]+3)%3; //前面讲过的方程
                f[b]=a;                
            }
            if (x==2)
            {
                v[b]=(v[y]-v[z]+4)%3;
                f[b]=a;
            }
            return true;
        }
    }
    int main()
    {
        scanf("%d%d",&n,&k);
        for (int i=1;i<=n;i++)
        {
            f[i]=i;
            v[i]=0;
        }
        for (int i=1;i<=k;i++)
        {
            scanf("%d%d%d",&x,&y,&z);
            if (z>n||y>n)//越界
                S++; //计数器
            else 
            if (y==z&&x==2) S++; //自己吃自己
            else
            if (Ya(x,y,z)==false) S++;
        }
        printf("%d",S);
        return 0;
    }
`
```

---

## 作者：Kelin (赞：2)

```cpp
#include<cstdio>
#define re register int
const int N=5e4+50;
int f[N],rank[N],n,ans,k,x,y,d;
int gf(int x){
    if(x==f[x])return x;
    int fx=gf(f[x]);
    rank[x]=(rank[x]+rank[f[x]])%3;
    return f[x]=fx;
}
void link(int r,int x,int y){
    int fx=gf(x),fy=gf(y);
    if(fx==fy)return;
    f[fx]=fy;
    rank[fx]=(rank[y]+r+(3-rank[x]))%3;//加上一个3是为了防止出现负数，用%会得到意外的结果
}
int nottrue(int d,int x,int y){
    if(x>n||y>n||(x==y&&d==2))return 1;
    int fx=gf(x),fy=gf(y);
    if(fx!=fy)return 0;
    if(rank[x]==((d-1)+rank[y])%3)return 0;
    else return 1;
}
int main(){
    scanf("%d%d",&n,&k);
    for(re i=1;i<=n;i++)f[i]=i,rank[i]=0;
    while(k--){
        scanf("%d%d%d",&d,&x,&y);
        if(nottrue(d,x,y))ans++;
        else link(d-1,x,y);
    }
    printf("%d\n",ans);
return 0;
}
```
/\*
在处理此类集合绝对数量少但集合之间关系复杂的并查集，比如（1182，A吃B，B吃C，C吃D，那么A.D是同类。）

状态存储，只需要在新加一个记录偏移量的数组offset [ MAX ] ，如果只有两个状态，可以直接开bool数据类型。

在预处理的时候，加上如下


```cpp
void makeset ( )
{
        int i ;
        for ( i = 1 ; i <= n ; ++ i )
        {
                father [ i ] = i ;
                offset[ i ] = 0 ;//新加的
        }
}
```
在查集函数中，
```cpp
int findset ( int x )
{
        int t ; 
        if ( father [ x ] == x ) return x ;
        else t = findset( father [ x ] ) ;
        offset [ x ] = ( offset [ x ] + offset [ father [ x ] ] ) % DEPTH ;//DEPTH表示几个状态量
//如果1182中，DEPTH=3；
        father [ x ] = t ;
        return t ;
```
}//使用函数递归调用查找父亲在处理上优于循环。
在并集函数中，

```cpp
void unionset ( int x , int y )
{
        int fx , fy ;
        fx = findset ( x ) ;
        fy = findset ( y ) ;
        if ( fx == fy ) return ;
        father [ fx ] = fy ;
        offset [ fx ] = ( offset [ y ] - offset [ x ] + d +DEPTH ) % DEPTH ;
}//d表示x与y的状态偏移量，如1182中，偏移量可能是食物1，或是天敌2；1703中只有反面就是1。
offset [ x ] = ( offset [ x ] + offset [ father [ x ] ] ) % DEPTH ;
offset [ fx ] = ( offset [ y ] - offset [ x ] + d +DEPTH ) % DEPTH ;
```
在查集函数中，向量转移方程表示儿子与祖先的偏移量＝(儿子与父亲的偏移量＋父亲和祖先的偏移量)%状态量。
（这里的父亲和祖先可能是同一人，但没有关系，因为自己和自己的偏移量为0。）

在并集函数中，由于要将两个原本不相干的集合合并，d表示在两个集合交汇的地方的最深层的偏移量。

offset[y]表示y与y祖先的偏移量，offset[x]便是x与x祖先的偏移量。

加上一个DEPTH是为了防止出现负数，用%会得到意外的结果。

\*/

---

## 作者：封禁用户 (赞：2)

用并查集来做所以想到了代码就不困难

最核心的就是要存三倍分别代表Ni是哪个种类，然后每个并查集里的话同时成立或不成立

还有就是注意特判一些比如超出N范围的信息肯定是假的 直接

ans++
下面看代码吧





```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int f[150010],n,T,k,x,y,fx,fy,ans=0;
int getf(int x){
    if(x==f[x]) return f[x];
    f[x]=getf(f[x]);
    return f[x]; 
}
void merge(int a,int b){
    f[a]=getf(b);
}
int main(){
    scanf("%d%d",&n,&T);
    for(int i=1;i<=n*3;i++) f[i]=i;
    while(T--){
        scanf("%d%d%d",&k,&x,&y);
        if(x>n||y>n){
            ans++; continue;
        }
        fx=getf(x),fy=getf(y);
        if(k==1){
            if(fx==fy) continue;
            if(fx==getf(x+n)||fx==getf(x+n+n)||fy==getf(x+n)||fy==getf(x+n+n)){
                ans++; continue;
            }
            merge(fx,fy); merge(getf(x+n),y+n); merge(getf(x+n+n),y+n+n);
        }
        if(k==2){
            if(x==y){
                ans++; continue;
            }
            if(fx==fy||getf(x+n)==fy||getf(x+n+n)==getf(y+n)||fx==getf(y+n+n)){
                ans++; continue;
            }
            merge(fx,y+n); merge(getf(x+n),y+n+n); merge(getf(x+n+n),fy);
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：MoonPie (赞：1)

## 本人蒟蒻，来分享一种 ~~不是很快，不是很短~~ 但比较容易理解的做法（大佬勿喷）
基本思路：每个动物属于不同的结点，初始时每个结点都各为一棵树，然后，根据动物的食物链关系**将结点合并**，最终得到一棵树。合并结点的过程中，就用到了**并查集**


------------

### 这棵树的特点：
孩子结点表示的动物被父亲结点所表示的动物吃。所以，
###### 推论1：
若两个结点的深度**对3取模**的结果相等，则两结点属于同类动物
###### 推论2：
若结点A的深度%3==结点B的深度%3+1，则A结点表示的动物被B结点表示的动物吃
然后，根据以上两条推理和原先建造的树，就可以很快地判断一句话的真假了！


------------

##### PS：
由于一个结点的深度表示着结点上动物的种类，所以这里的并查集不能压缩，所以程序运行速度较慢~~不过还是可以AC的~~


------------

话不多说，上AC代码：
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
int n,nn,k,d,x,y,ans=0,par[100005];
int find(int x)  //查找结点深度
{
	if(par[x]==x) return 1;
	return find(par[x])+1;
}
int getpar(int x)  //查找祖先结点，用于判断两结点是否属于一棵树
{
	if(par[x]==x) return par[x];
	return getpar(par[x]);
}
int main()
{
	scanf("%d%d",&n,&k);
	nn=n;  //由于后面n会发生变化（充当父亲结点来合并两棵树），所以用一个变量存下n的初始值
	for(int i=1;i<=100005;i++) par[i]=i;  //初始化
	for(int i=1;i<=k;i++)
	{
		scanf("%d%d%d",&d,&x,&y);
		if(x>nn || y>nn)
		{
			ans++;
			continue;
		}
		if(d==1)
		{
			if(x==y) continue;
			int xx=find(x),yy=find(y);
			if(getpar(x)!=getpar(y))  //若两个结点不属于同一棵树，则合并两树
			{
				int tmp;
				if(xx<yy)
				{
					tmp=y;
					for(int j=1;j<=xx-1;j++) tmp=par[tmp];
					par[getpar(x)]=par[tmp];
				}
				if(xx>yy)
				{
					tmp=x;
					for(int j=1;j<=yy-1;j++) tmp=par[tmp];
					par[getpar(y)]=par[tmp];
				}
				if(xx==yy) par[getpar(x)]=par[getpar(y)]=++n;
			}
			else if(xx%3!=yy%3) ans++; //根据推理1，判断是否为一种动物（判断这句话的真假）
		}
		if(d==2)
		{
			if(x==y)
			{
				ans++;
				continue;
			}
			int xx=find(x),yy=find(y);
			if(getpar(x)!=getpar(y))  //不为同一树，合并
			{
				int tmp;
				if(xx<yy-1)  //减1是因为x是y的父亲结点，所以下移一个
				{
					tmp=y;
					for(int j=1;j<=xx;j++) tmp=par[tmp];
					par[getpar(x)]=par[tmp];
				}
				if(xx>yy-1)
				{
					tmp=x;
					for(int j=1;j<=yy-1;j++) tmp=par[tmp];
					par[getpar(y)]=tmp;
				}
				if(xx==yy-1) par[getpar(x)]=par[getpar(y)]=++n;
			}
			else if(yy%3!=(xx%3+1)%3) ans++;  //根据推理2，判断x是否吃y（判断这句话的真假）
		}
	}
	printf("%d",ans);  
	return 0;
}
```

大概就是这样了，如果各位大佬发现我的错误or可以改进的地方欢迎指正o(*￣▽￣*)ブ

---

## 作者：TEoS (赞：1)

一道并查集的好题，思路比较灵活

本文代码比较清晰，看不懂大佬的代码可以来看本蒟蒻的代码

对于并查集的基本操作，不懂的可以[点击食用](https://www.cnblogs.com/TEoS/p/11331317.html)

------------

根据题目描述，只有三类动物，而其捕食关系构成一个环形，即，若$a$捕食$b$，$b$捕食$c$，则$c$捕食$a$。因此对于任意两个动物$x,y$，$x$对于$y$的关系只可能有三种可能：

- x是y的同类
- x是y的天敌（即x捕食y）
- x被y捕食

因此我们可以将每个动物$k$分为三个元素$k1,k2,k3$，分别表示k的同类，被k捕食的动物和k的天敌，将三个元素都放入并查集中。

根据题目描述，对于每句话执行操作之前，必须判断每句话的真假。第2、3个条件的判定非常简单，这里就不再赘述了，主要讲一下第1个条件的判定。

1. 若输入x和y是同类，则当满足以下条件的任何一个时就是假话：
- 若$x1$和$y2$在一个集合，说明y捕食x
- 若$x2$和$y1$在一个集合，说明x捕食y
2. 若输入x捕食y，则当满足以下条件的任何一个时就是假话：
- 若$x1$和$y1$在一个集合，说明x和y是同类
- 若$x1$和$y2$在一个集合，说明y捕食x

判定为假话则将答案自加，否则执行操作。

显然，对于操作1和操作2，分别有以下的操作：
1. 若输入x和y是同类，显然x和y的同类、捕食的动物和天敌都相同，则合并$x1,y1$、$x2,y2$、$x3,y3$
1. 若输入x捕食y，显然y是x捕食的动物，x是y的天敌，则合并$x2,y1$、$x1,y3$；同时由于三类动物的捕食情况构成一个环形，因此x的天敌就是y捕食的动物，所以合并$x3,y2$

掌握这些之后，代码实现就很简单了。

代码：
```cpp
#include<iostream>
#define x1 x
#define x2 x+n
#define x3 x+2*n
#define y1 y
#define y2 y+n
#define y3 y+2*n//对于所有节点，将并查集分成三份，分别存储同类、捕食的动物和天敌
using namespace std;
const int N=1e5;
int n,k,ans=0,fa[3*N];//因为拆成了三倍节点，并查集数组要开三倍大
int get(int a)
{
	return fa[a]==a?a:fa[a]=get(fa[a]);
}//并查集查找操作
void mg(int a,int b)
{
	fa[get(a)]=get(b);
}//并查集合并操作
bool p1(int x,int y)
{
	if(x>n || y>n || get(x1)==get(y2) || get(x2)==get(y1))
		return false;
	return true;
}//判定x和y是同类这句话的真假
bool p2(int x,int y)
{
	if(x>n || y>n || x==y || get(x1)==get(y1) || get(x1)==get(y2))
		return false;
	return true;
}//判定x捕食y这句话的真假
int main()
{
	cin>>n>>k;
	for(int i=1;i<=3*n;i++)
		fa[i]=i;//初始化
	while(k--)
	{
		int a,x,y;
		cin>>a>>x>>y;
		if(a==1)
			if(p1(x,y))
			{
				mg(x1,y1),mg(x2,y2),mg(x3,y3);
			}
			else
				ans++;
		else
			if(p2(x,y))
			{
				mg(x2,y1),mg(x1,y3),mg(x3,y2);
			}
			else
				ans++;
	}//不断判定，判定成功则执行操作，判定失败则答案自加
	cout<<ans;
	return 0;
}
```

---

## 作者：luoxiao233 (赞：1)

## Q5食物链

这到题的物种有三种关系（环形食物链），即同类，猎物，天敌，物种i，j的关系
只有这三种。这里我将1到n表示同类，1+n到2n表示猎物，2n+1到3n表示天敌。对于操作1，只要物种i，j就没有猎物关系也没有天敌关系就是真话（先不管后两个条件），同类关系的建立需要：

```cpp
  f[find(x)] = find(y);
  f[find(x+n)] = find(y+n);
  f[find(x+2*n)] = find(y+2*n);
```
也就是同类之间具有相同的同类，相同的猎物，相同的天敌，更新三种关系（同类，猎物，天敌）。对于操作2，只要XY既不是同类也没有X是Y的猎物关系，那就是真话。既然X吃Y，关系建立只需要建立X的猎物是Y，X的天敌是Y的猎物，X的同类是Y的天敌，即三种关系都更新一下（同类，猎物，天敌）。

```cpp
f[find(x + n)] = find(y);//X的猎物是Y
f[find(x + 2 * n)] = find(y + n);//X的天敌是Y的猎物
f[find(x)] = find(y + 2 * n);//X的同类是Y的天敌
```
这就是这道题的核心，剩下的细节看代码吧

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int MAX = 3*(5e4 + 1);
int n, m;
int f[MAX];//并查集
int find(int x)
{
    return (f[x] == x) ? x : (f[x] = find(f[x]));
}
int main()
{
    ios::sync_with_stdio(false);//
    cin >> n >> m;
    int ans = 0;//假话数
    for (int i = 1; i <= 3*n; i++)
        f[i] = i;
    int op, x, y;
    for (int i = 1; i <= m; i++)
    {
        cin >> op >> x >> y;
        if (x > n || y > n) { ans++; continue; }//条件2
        if (op == 2 && x == y) { ans++; continue; }//条件3
        if (op == 1)
        {//如果X的猎物时Y或X的天敌时Y，就是假话
            if (find(x+n) == find(y) || find(x+2*n) == find(y)) { ans++; continue; }
            f[find(x)] = find(y);
            f[find(x+n)] = find(y+n);
            f[find(x+2*n)] = find(y+2*n);
        }
        if (op == 2)
        {//如果X的同类时Y或X的天敌是Y，就是假话
            if (find(x) == find(y) || find(x + 2 * n) == find(y)) { ans++; continue; }
            f[find(x + n)] = find(y);
            f[find(y + n)] = find(x+2*n);
            f[find(x)] = find(y + 2 * n);
        }
    }
    cout << ans;//输出答案
    return 0;
}

```



---

## 作者：jtzhang (赞：1)

我认为所有题解都少提到了这道题的隐含条件：
------------

#### 1，有共同天敌的动物是同一种动物

#### 2，有共同食物的动物是同一种动物

#### 3，天敌的天敌是食物，（食物的食物是天敌【实际操作时可以只维护其中一个】）

其实完全可以像 团伙 一题一样维护一个 enemy 和 food 数组分别指向它们的天敌和食物，其本质就是种类并查集， 但是由于维护enemy 和 food 数组需要先判断是否为空，不如我们先给他装上一个无关的元素（装入n到3*n），于是便有了种类并查集。

## 一个常见的疑惑：

比如说，我判断了a的天敌是b，我会
~~~cpp
union_(a, b+num*2);
或者
union_(a, enemy[b]);
~~~

那么是不是任何一个b的敌人都是a的同类呢。

根据题目分析，这是正确的，如果不是，这个三角形关系显然错误，事实上，上面给出的所有隐含条件就是在解释为什么可以直接合并，刚才的例子属于  **隐含条件2**


那么，为了证明**建立 enemy 和 food 数组** 与 **种类并查集**等效，这里我用换元法为大家题给一个本质相同，但使用了**建立 enemy 和 food 数组**方法的程序：
~~~cpp
#include<bits/stdc++.h>
using namespace std;

#define ri register int
typedef long long ll;
int read_int();

#define Maxn 100003
int num, numh;
int fa[Maxn*3];//本身，天敌，猎物 
int ans=0;
int *en, *pre;

void init() {
	for(ri i=1; i<=num*3; i++)
		fa[i]=i;
		
	en= &fa[num];
	pre= &fa[num<<1];
}

int find(int x) {
	if( x!=fa[x] ) fa[x]=find( fa[x] );
	return fa[x];
} 

void union_(int a, int b)
{
	a=find(a);
	b=find(b);
	if( a==b ) return;
	fa[a]=fa[b];
}

int main()
{
	freopen("in.txt", "r", stdin);
	num=read_int();
	numh=read_int();
	
	init();
	
	int type, a1, a2;
	for(ri i=1; i<=numh; i++)
	{
		type=read_int();
		a1=read_int();
		a2=read_int();
		
		if( type==1 ) {
			
			if( a1>num || a2>num ) ans++;
			else if( find(en[a1])==find(a2) || find(pre[a1])==find(a2) ) ans++;
			else {
				union_( a1, a2 ); 
				union_( en[a1], en[a2]);
				union_( pre[a1], pre[a2] );
			}
			
		}
		
		else {//a1 eat a2
			if( a1==a2 || a1>num || a2>num ) ans++;
			else if( find(en[a1])==find(a2) || find(a1)==find(a2) ) ans++;
			else {
				union_( pre[a1], a2 );
				union_( en[a2], a1 );
				union_( en[a1], pre[a2] );
				union_( pre[a2], en[a1] );
			}
		}
		
		//printf("%d\n", ans);
	}
	
	printf("%d", ans);

	return 0;
}


int read_int()
{
	int ret=0, minus=1;
	char ch=getchar();
	while( ch<'0' || '9'<ch ) {
		if( ch=='-' ) minus=-1;
		ch=getchar();
	}
	while( '0'<=ch && ch<='9' )
	{
		ret= ret*10+ch-'0';
		ch=getchar();
	}
	return ret*minus;
}











~~~



---

## 作者：dessert (赞：1)

# 思路
其实分为三个群系： **共生群，捕食群，天敌群**。

只要判断一下输入的共生和捕食是否符合要求，就把它们合并！

反之，ans++。

~~So easy~~（强撑，其实模拟考写错了QWQ）

------------


# 奉上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[200001],x,y,n,m,t,ans=0;
int find(int x)                   //并查集
{
	if(f[x]!=x) f[x]=find(f[x]);
	return f[x];
}
int uni(int x,int y)              //开始合并
{
	int r1=find(x);
	int r2=find(y);
	if(r1!=r2)
	f[r2]=r1; 
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=3*n;i++)         //之所以开n*3是因为有三个群系
	f[i]=i;
	for(int i=1;i<=m;i++)
	{
		cin>>t>>x>>y;
		if(x>n||y>n)
		ans++;
		else if(t==1)               //如果是共生
		{
			if(find(x)==find(y+n)||find(x)==find(y+n+n))   //判断是不是捕食，天敌关系
			ans++;
			else
			{
				uni(x,y);           //共生群
				uni(x+n,y+n);       //捕食群
				uni(x+n+n,y+n+n);   //天敌群
			}
		}
		else                        //如果是捕食
		{
			if(x==y||find(x)==find(y)||find(x)==find(y+n))   //判断是不是相同，共生，捕食关系
			ans++;
			else
			{
				uni(x,y+n+n);
				uni(x+n,y);
				uni(x+n+n,y+n);
			}
		}
    }
	cout<<ans;                       //输出答案
	return 0;
}                                    //撒花
```
**好不容易打出来，大大求过**

---

## 作者：SSL_lzx (赞：1)

思路：本题是并查集

&#8195;&#8195;&#8195;本题中的三种动物是不同种族的，一种的动物与其他动物有亲戚、吃、被吃的关系。

&#8195;&#8195;&#8195;如果要分开处理的话要分别开3个数组和3个不同的find。所以在此处我将3个数组合并在一起，在find中用+0、+n、+2\*n来分开三种关系


    
```cpp
&#8195;&#8195;&#8195;并查集函数
    function find(x:longint):longint;//找爸爸+压缩路径
    var
     y,r:longint;
    begin
     y:=x;
     while f[y]<>y do y:=f[y];
     r:=f[y];
     while f[x]<>x do
      begin
       x:=f[x];
       f[x]:=r;
      end;
     exit(r);
    end;
    function check:boolean;
    var
     q,w,e,a,s,d:longint;
    begin
     q:=find(x);//找出x集合的亲戚
     w:=find(x+n);//x集合的捕食者
     e:=find(x+2*n);//x集合的食物
     a:=find(y);//以此类推
     :=find(y+n); d:=find(y+2*n);
     if z=1 then
      if (f[q]=f[s]) or (f[a]=f[w]) then exit(true)
```
判断补充：如果y吃x或y被x吃，就不是同类，就不是真话。

```cpp
    else
         begin
          f[q]:=f[a];//合并
          f[w]:=f[s];
          f[e]:=f[d];
          exit(false);
         end
            else
       if (f[w]=f[s]) or (f[e]=f[s]) then exit(true)
```
判断补充：如果它们吃得一样(亲戚)或y吃x(捕食关系反了)，就不符合"x吃y"的题意，就不是真话

```cpp
        else
         begin
          f[q]:=f[s];
          f[a]:=f[e];
          f[d]:=f[w];
          exit(false);
         end;
    end;
```
主程序就不透露了，主要是输入，再去判断假话的三种情况
“
• 当前的话与前面的某些真的话冲突，就是假话(需要进函数)


• 当前的话中 X 或 Y 比 N 大，就是假话(可以直接判断的啦╮(╯▽╰)╭)


• 当前的话表示 X 吃 X，就是假话(同上)

”

---

## 作者：yegcjs (赞：1)

这题因为只涉及到3个类的关系 所以其实写个普通的并查集也能过 每次分别考虑a b和他们吃和被吃关系的合并就好。


也就是对每次将a b所涉及的2\*3个集合间的关系分别进行维护、合并：a集，a的吃集，a的被吃集；b集，b的吃集，b被吃集。

为了方便，我们每次都把标号大的往标号小的合并。



```cpp
#include<cstdio>
#include<algorithm>
#define foru(i,x,y) for(int i=x;i<=y;i++)
#define skip {fal++;continue;}
#define N 50010
using namespace std;
int fa[N],n,k,fal;
int eat[N],eaten[N];
int find(int x)
{
    if(x==fa[x]) return x;
    return fa[x]=find(fa[x]);
}
void unite(int a,int b,int u,int v,int x,int y)
{
    int A=min(a,b),B=max(a,b),U=min(u,v),V=max(u,v),X=min(x,y),Y=max(x,y);
    if(!A)if(B) A=B; if(A&&B) fa[B]=A;
    if(!U)if(V) U=V; if(U&&V) fa[V]=U;
    if(!X)if(Y) X=Y; if(X&&Y) fa[Y]=X;
    if(A&&X){eaten[A]=X;eat[X]=A;}
    if(A&&U){eat[A]=U;eaten[U]=A;}
    if(X&&U){eat[U]=X;eaten[X]=U;}
}
int main()
{
    scanf("%d %d",&n,&k);
    foru(i,1,n)
        fa[i]=i;
    foru(i,1,k)
    {
//        printf("%d ",fal);
        int f,a,b;
        scanf("%d %d %d",&f,&a,&b);
        if(a>n || b>n) skip
        a=find(a),b=find(b);
    //    EATA=eat[a],EATB=eat[b],EATENA=eaten[a],EATENB=eaten[b];
        if(f==1)
        {
            if(a==eat[b]||a==eaten[b]||b==eat[a]||b==eaten[a]) skip
            unite(eaten[a],eaten[b],a,b,eat[a],eat[b]);
        }
        else
        {
            if(a==b||eat[b]==a||eaten[a]==b) skip
            unite(eaten[b],a,b,eat[a],eat[b],eaten[a]);
        }
    }
    printf("%d",fal);
    return 0;
}
```

---

## 作者：Hydra_ (赞：1)

## 分析 ##

这里，三种动物有三种关系，1、吃；2、被吃；3、同类。所以我们怎样表示这些关系就是这道题目解题关键。我们仔细观察题目的读入格式，发现题目是用1和2来代表两个动物之间的关系的。这样我们是不是就有思路了？？？？对对对，我们就是用带权值的并查集来代表动物之间的关系。就是这样。我们用0代表同类1代表被吃2代表吃。如果A吃B，我们就用A指向B，并且权值为2，如果要求两个没有直接联系的动物之间的关系，只要把代表这两个动物的结点之间的所有边的权值加起来再%3就可以了。比如A吃B，B吃C，权值是2+2=4，然后%3得1，刚好代表A被C吃。

下面上代码


代码
--

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans=0;
struct animal
{
    int father,relation;
}a[60000]={};
/*以上是变量说明阶段，a结点用来存所有的动物，
father代表他的父节点是哪个，relation用来代表他和他的父节点的关系
0表示同类，2表示吃，1表示被吃;*/
int getfather(int k)
{
    if(a[k].father!=k)//如果k的父节点不是自己 
    {
        int temp=a[k].father;
        //先用temp来暂存下k的直接父亲 
        a[k].father=getfather(a[k].father);
        //k的父亲追溯到祖先那里去 
        a[k].relation=(a[k].relation+a[temp].relation)%3;
        //k跟祖先的关系，就是k跟祖先之间所有的边权值之和%3 
    }
    return a[k].father;//返回 
}
//求根结点和压缩路径。 
void read()
{
    scanf("%d%d",&n,&k);

    for(int i=1;i<=n;i++)
    {
        a[i].father=i;
        a[i].relation=0;
    }
}
//初始化和读入，父节点默认是自己，关系默认是同类 

void work()
{
    for(int i=1;i<=k;i++)
    {
        int pattern,x,y;
        scanf("%d%d%d",&pattern,&x,&y);
        //pattern，关系类型 
        if(x>n||y>n)
        {
            ans++;
            continue;
        }//题目要求 
        if(pattern==1)//如果是同类的关系的话 
        {
            if(getfather(x)==getfather(y))
            {
                if(a[x].relation!=a[y].relation)
                ans++;
                /*如果在同一个集合里面，
                 并且，他们跟祖先的关系不一样
                 那就是假话
                 （如果是同类，跟祖先的关系应该是一样的）*/ 
            }
            else//如果不在同一个集合，就不存在矛盾 
            {
                a[a[x].father].relation=(a[y].relation-a[x].relation+3)%3;
                //这里加三是为了防止负数的出现 
                a[a[x].father].father=a[y].father;
                /*这里是把x的父亲作为了y的父亲的儿子结点，这样我们就完成了并的操作。x的父亲和y的父亲的关系为什么是这样呢？。既然x和y是同类，那么他们合并后和祖先的关系应该是一样的。也就是说x与y的父亲的关系和y与y的父亲的关系是一样的。也就是说x到y的父亲的权值和，与y到y的父亲的权值和是一样的*/ 
            }
        }
        if(pattern==2)//如果是吃的关系 
        {
            if(x==y)
            {
                ans++;
                continue;
            }//题目要求 
            if(getfather(x)==getfather(y))
            {
                if(a[x].relation!=(a[y].relation+1)%3)
                //这里+1代表被吃的关系。和同类稍有不同 
                ans++;
            }
            else//同上一种情况 
            {
                a[a[x].father].relation=(a[y].relation-a[x].relation+4)%3;
                //这里和上面略有不同，是因为吃的关系，权值不是0；需要+1； 
                a[a[x].father].father=a[y].father;
            }
        }
    }
}
int main()
{
    read();
    work();
    printf("%d",ans);
    return 0;
}
```


---

## 作者：LoganC (赞：1)


//不懂得可以先去做关押罪犯，一样的思想，但在转移的时候要注意b,b+n,b+2n.三种状态要一起进行转移

思路：将n数组扩大到三倍，一个表示x吃y，一个表示x被y吃，然后基本的并查集操作就可以了。







    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 50000 + 10;
int ans=0,n,k;
int fa[maxn*3];
int read(){
    int n=0;char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c<='9'&&c>='0')    {
        n=n*10+c-'0';    c=getchar();
    }    return n;
}
int find(int x){
    if(fa[x]==x)    return x;
    else            return fa[x]=find(fa[x]);
}
int main(){
    n=read();    k=read();
    for(int i=1;i<=n*3;i++)    fa[i]=i;
    for(int kase=1;kase<=k;kase++)
    {
        int a,b,c;
        a=read();    b=read();    c=read();    
        if(b>n||c>n){
            ans++;    continue;
```
}//超范围；
        if(a==2&&b==c){

            ans++;  continue;

}//自己吃自己；

        
```cpp
        int fx=find(b);
        int fy=find(c); 
        if(a==1){//同类学说； 
            if(fx==fy)    continue;
            if(fx==find(c+n)||fx==find(c+2*n)||fy==find(b+2*n)||fy==find(b+n)){
                ans++;    continue;
            }        
        fa[find(b)]=find(c);
        fa[find(b+n)]=find(c+n);
        fa[find(b+2*n)]=find(c+2*n);
        }    
        if(a==2){//捕食学说； 
            if(fx==fy||fx==find(c+2*n)||fy==find(b+n)){
                ans++;    continue;
            }
            fa[fx]=find(c+n);
            fa[fy]=find(b+2*n);
            fa[find(b+n)]=find(c+2*n);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Kwork (赞：1)

挑战程序设计竞赛 的例题。~~偶尔来洛谷发个题解~~

我们用并查集来维护这些逻辑关系。由于涉及多个关系，我们需要将普通的并查集的大小3倍。

i表示他属于的种族，i+n表示他捕食的种族，i+n\*2表示他被那个种族吃。

那么，每次读入一条信息，如果是1，就比较x，y+n和x，y+n\*2，有一个相同就表示与前面的相悖。ans++。

同理，对于2的情况也用类似的方法来经行逻辑判断。

------------------------------------------------------------------------------------------------------------------------------------------

输入输出优化大法好，强行把代码长度撑到100+行。而且快。而且快。而且快。而且快。非常重要的事情比重要的事情多说一遍

不要吐槽我的solve只有输出ans，因为我发现读完就做完了。

------------------------------------------------------------------------------------------------------------------------------------------

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <iostream>
```
------------------------------------------------------------------------------------------------------------------------------------------
using namespace std;

------------------------------------------------------------------------------------------------------------------------------------------

const int maxn=50000+20;

const int maxk=100000+20;

------------------------------------------------------------------------------------------------------------------------------------------

int n,ans=0,p[maxn<<2],k,rank[maxn<<2];

------------------------------------------------------------------------------------------------------------------------------------------

```cpp
void read(int &data){
    char ch=getchar();
    data=0;
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        data=data*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    return;
}
void write(int data){
    if(data>9) write(data/10);
    putchar((data % 10)+'0');
    return;
}
int find(int x){
    return x==p[x] ? x:p[x]=find(p[x]);
}
void Union(int a,int b){
    int x=find(a);
    int y=find(b);
    if(x==y) return;
    if(rank[x]<rank[y]){
        p[x]=y;
    }
    else{
        p[y]=x;
        if(rank[x]==rank[y]) rank[x]++;
    }
    return;    
}
bool same(int a,int b){
    int x=find(a);
    int y=find(b);
    if(x==y) return true;
    return false;
}
void init(){
    read(n);read(k);
    for(int i=1;i<=((n<<1)+n);i++) p[i]=i;
    for(int i=1;i<=n;i++) rank[i]=0;
    int sign,x,y;
    for(int i=1;i<=k;i++){
        read(sign);read(x);read(y);
        if(sign==1){
            if(x>n || y>n){
                ans++;
                continue;
            }
            if(same(x,y+n) || same(x,y+(n<<1))){
                ans++;
                continue;
            }else{
                Union(x,y);
                Union(x+n,y+n);
                Union(x+(n<<1),y+(n<<1));
            }
        }
        else{
            if(x>n || y>n){
                ans++;
                continue;
            }
            if(x==y){
                ans++;
                continue;
            }
            if(same(x,y) || same(x,y+n)){
                ans++;
                continue;
            }else{
                Union(x+n,y);
                Union(x,y+(n<<1));
                Union(x+(n<<1),y+n);
            }
        }
    }
    return;
}
void solve(){
    write(ans);
    return;
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：Skywalker_David (赞：1)

对于每个点，除去记录并查集中的根节点外，还要记录下该点与父节点的关系：

               r[x]=0  表示x与其根节点为同类

               r[x]=1  表示x的父节点吃x

               r[x]=2  表示x吃x的父节点

而对于并查集的合并操作中，要进行以下操作

```delphi

var
  f,r:array[0..50001]of longint;//f[i]表示节点i的祖先的序号，r[i]表示i与他的祖先的关系
  n,k,i,ans:longint;
function find(x:longint):longint;//找到祖先，路径压缩，但是路径压缩时，要把关系转换一下
var
  qian:longint;
begin
  if f[x]=x then exit(x);
  qian:=f[x];//这是x上次的祖先
  f[x]:=find(f[x]);
  r[x]:=(r[qian]+r[x])mod 3;//用他和他上次的祖先的关系and他上次的祖先和现在的祖先的关系推出现在他和他现在的祖先的关系
  exit(f[x]);
end;
procedure hebing(x,y,z:longint);
var
  fx,fy:longint;
begin
  fx:=find(x);
  fy:=find(y);
  f[fy]:=fx;
  r[fy]:=(2+z+r[x]-r[y]) mod 3;//推出fy与fx的关系
end;
procedure main;
var
  x,y,z,fx,fy:longint;
begin
  read(z,x,y);
  if (x>n)or(y>n) then begin inc(ans); exit; end;
  if (x=y)and(z=2) then begin inc(ans); exit; end;
  fx:=find(x);
  fy:=find(y);
  if fx<>fy then hebing(x,y,z);
  if (fx=fy)and(((r[x]-r[y]+2+z)mod 3)<>0) then begin inc(ans); exit; end;
end;
begin
  read(n,k);
  for i:=1 to n do
    f[i]:=i;
  for i:=1 to k do
    main;
  write(ans);
end.

             f[fy]=fx;

             r[fy]=(3+(z-1)+r[x]-r[y]) mod 3；（fx为x的根节点  fy为y的根节点  z为x、y之间的关系）

```

---

## 作者：Isprime (赞：1)

## 题解P2024 [NOI2001]食物链

[原题传送门](https://www.luogu.org/problem/P2024)

[配合Blog食用更佳](https://www.luogu.org/blog/149815/solution-p2024)

~~话说NOI好多并查集啊~~

这不是并查集裸题吗……

开个三倍数组，分别存自己、猎物、天敌

Code（详细注释在代码里）↓
```cpp
#include<cstdio>
#define MAXN 50001
#define il inline 
using namespace std;
int n,k,ans,fa[MAXN*3];//开3倍不能忘
il int find(int x){//并查集查找
  if(fa[x]==x) return x;
  return fa[x]=find(fa[x]);//路径压缩
}
signed main(){
  scanf("%d%d",&n,&k);
  for(register int i=1;i<=n*3;i++) fa[i]=i;//初始化
  int o,x,y;
  while(k--){
    scanf("%d%d%d",&o,&x,&y);
    if(x>n||y>n) {ans++;continue;}//如果动物不存在就假
    if(o==1){
      if(find(x+n)==find(y)||find(x+n+n)==find(y)) {ans++;continue;}//如果y是x的猎物或天敌肯定是骗你的
      fa[find(x)]=find(y);
      fa[find(x+n)]=find(y+n);
      fa[find(x+n+n)]=find(y+n+n);
    }
    else{
      if(x==y) {ans++;continue;}//题目里有说
      if(find(x)==find(y)||find(x+n+n)==find(y)) {ans++;continue;}//如果y是x的同类或天敌，还是骗你的
      fa[find(x)]=find(y+n+n);
      fa[find(x+n)]=find(y);
      fa[find(x+n+n)]=find(y+n);
    }
  }
  printf("%d\n",ans);
  return 0;
}
```



---

## 作者：wxy2005 (赞：1)

# 高能预警：代码极其的长，请做好心理准备。
#### 首先我们要感谢这道题的出题人，因为只出现了3种动物，这就意味着可以浪了。
## 大体思路：并查集
#### 我们可以想这样一个事情：如果A吃B，还知道A吃D，那么就可以知道B和D是同类。同理，如果A被B吃，并且A被D吃，则B和D也是同类。
##### 这样我们就讲两种情况转化为了一种情况。
### 我们都知道，并查集里每一个单独的集合都以一个代表元，所以我们不需要进行繁琐的对比，只需要对比代表元就行了。
#### 我们先来看一下寻找代表元的代码：

```cpp
int dfs(int k)
{
	if(k==same[k])
		return k;
	int l=dfs(same[k]);
	same[k]=l; 
	return l;
}

```
### 找到代表元之后，我们要进行一系列的才做和合并，合并的代码如下
```
void hb(int x,int y)
{
	int l=dfs(x),h=dfs(y);	
	if(rank[l]>rank[h])
		swap(l,h);
	same[l]=h;
	if(rank[l]==rank[h])
		rank[h]++;
	if(eat[l]!=0)
		eat[h]=eat[l];
	if(beeat[l]!=0)
	beeat[h]=beeat[l];
}
```
##### 顺便解释一下，rank是为了防止合并复杂度掉回O(nlogn),beeat是用来存谁被谁吃，eat用来存谁吃谁（温馨提示：别忘了dfs一遍）。
### 仔细想想：只有合并这么简单吗？  当然不是，两个东西是同类可以引出一大坨信息，那么我们是不是可以写一个函数来完成这件事呢？答案是：必须的。
为了和hb区分一下，我们将这种运算叫做dabao（打包）
### 代码如下：
```
void dabao(int y,int z)
{
	int j=0,k=0,l=0;
	if(eat[dfs(y)]!=0&&eat[dfs(z)]!=0)
	{
		hb(eat[dfs(y)],eat[dfs(z)]);
	}
	if(beeat[dfs(y)]!=0&&beeat[dfs(z)]!=0)
	{
		hb(beeat[dfs(y)],beeat[dfs(z)]);
	}
	hb(y,z);
	j=dfs(y);
	if(eat[dfs(y)]!=0)
		k=dfs(eat[dfs(y)]);
	else if(eat[dfs(z)]!=0)
		k=dfs(eat[dfs(z)]);
	if(beeat[dfs(y)]!=0)
		l=dfs(beeat[dfs(y)]);
	else if(beeat[dfs(z)]!=0)
		l=dfs(beeat[dfs(z)]);
	eat[k]=l;
	beeat[l]=k;
	eat[j]=k;
	beeat[k]=j;
	eat[l]=j;
	beeat[j]=l;	
	eat[0]=0;
	beeat[0]=0;	
}
```
### 进行完了打包，同类情况就基本完成
## 为啥基本呢？因为还没有判断假话
# 判断假话代码如下：
```cpp
bool pd(int y,int z)
{
	if( (eat[dfs(y)]==dfs(z)   &&  eat[dfs(y)]!=0)
    ||(beeat[dfs(y)]==dfs(z) &&  beeat[dfs(y)]!=0))
	{
		return false;
	}
	return true;
}

```
#### 于是我可以开心的宣布程序的一半已经完成了，可能不带一半
### 我们先来总结一下x==1,就是同类时的代码：
```cpp
if(x==1)
{
	if(pd(y,z)==false)
	{
		fa++; 
		continue;
	}
	dabao(y,z);
}

```
## fa是用来存假话的数量的。
### 第二类A吃B有一种很容易被看出是假话的话那就是：
```cpp
if(dfs(y)==dfs(z)||beeat[dfs(y)]==dfs(z))
{
	fa++;
	continue;
}

```
### 接下来，就是恶心人的四种情况，在此之前，我们先来在添加一个函数
```cpp
void sec(int y,int z)
{
	if(eat[dfs(z)]!=0&&beeat[dfs(y)]!=0)
	{
		dabao(eat[dfs(z)],beeat[dfs(y)]); 
	}
	else if(eat[dfs(z)]!=0)
	{
		eat[dfs(eat[dfs(z)])]=dfs(y);
		beeat[dfs(y)]=eat[dfs(z)];
	}
	else if(beeat[dfs(y)]!=0)
	{
		beeat[dfs(beeat[dfs(y)])]=dfs(z);
		eat[dfs(z)]=beeat[dfs(y)];
	}	
}

```
### 准确的说，这个函数干了两件事：一种是y的前项和z的后项是一类（不难理解吧？这就是为什么我要感谢出题人）
### 第二件就是y的前项的前项是z，z的后项的后项是x。
## 疑问来了：就没有五项连在一起的吗？答：没有！
### 为啥呢？只要前面合并了，就不存在5项！
## 函数介绍完了，该介绍恶心四项了
### 第一项：eat[dfs(y)]!=0&&beeat[dfs(z)]!=0
```cpp
if(eat[dfs(y)]!=0&&beeat[dfs(z)]!=0)
{
	if(pd(y,beeat[dfs(z)])==true&&pd(eat[dfs(y)],z)==true)
	{
		dabao(y,beeat[dfs(z)]);
		dabao(eat[dfs(y)],z);
		sec(y,z);
	}
	else
		fa++;	
}

```
### 第二项：eat[dfs(y)]!=0&&beeat[dfs(z)]==0
```cpp
else if(eat[dfs(y)]!=0&&beeat[dfs(z)]==0)
{
	if(pd(eat[dfs(y)],z)==true)
	{
		dabao(eat[dfs(y)],z);
		beeat[dfs(z)]=dfs(y);
		sec(y,z);
	}
	else
		fa++;
}

```
### 第三项：eat[dfs(y)]==0&&beeat[dfs(z)]!=0
```cpp
else if(eat[dfs(y)]==0&&beeat[dfs(z)]!=0)
{
	if(pd(y,beeat[dfs(z)])==true)
	{
		dabao(y,beeat[dfs(z)]);
		eat[dfs(y)]=dfs(z);
		sec(y,z);
	}
	else
		fa++;
}

```
### 第四项：eat[dfs(y)]==0&&beeat[dfs(z)]==0
```cpp
else if(eat[dfs(y)]==0&&beeat[dfs(z)]==0)
{
	eat[dfs(y)]=dfs(z);
	beeat[dfs(z)]=dfs(y);
	sec(y,z);
}

```
# 结束！完整代码如下
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<stdlib.h>
#include<algorithm>
#include<cstring>
#include<vector>
#define MAXN 100005
#define NEXT(x) (eat[dfs(x)])
#define LAST(x) (beeat[dfs(x)]) 
using namespace std;
int m,n,same[MAXN],eat[MAXN],beeat[MAXN],fa,rank[MAXN];
int dfs(int k)
{
	if(k==same[k])
		return k;
	int l=dfs(same[k]);
	same[k]=l; 
	return l;
}
void hb(int x,int y)
{
	int l=dfs(x),h=dfs(y);	
	if(rank[l]>rank[h])
		swap(l,h);
	same[l]=h;
	if(rank[l]==rank[h])
		rank[h]++;
	if(eat[l]!=0)
		eat[h]=eat[l];
	if(beeat[l]!=0)
	beeat[h]=beeat[l];
}
void dabao(int y,int z)
{
	int j=0,k=0,l=0;
	if(eat[dfs(y)]!=0&&eat[dfs(z)]!=0)
	{
		hb(eat[dfs(y)],eat[dfs(z)]);
	}
	if(beeat[dfs(y)]!=0&&beeat[dfs(z)]!=0)
	{
		hb(beeat[dfs(y)],beeat[dfs(z)]);
	}
	hb(y,z);
	j=dfs(y);
	if(eat[dfs(y)]!=0)
		k=dfs(eat[dfs(y)]);
	else if(eat[dfs(z)]!=0)
		k=dfs(eat[dfs(z)]);
	if(beeat[dfs(y)]!=0)
		l=dfs(beeat[dfs(y)]);
	else if(beeat[dfs(z)]!=0)
		l=dfs(beeat[dfs(z)]);
	eat[k]=l;
	beeat[l]=k;
	eat[j]=k;
	beeat[k]=j;
	eat[l]=j;
	beeat[j]=l;	
	eat[0]=0;
	beeat[0]=0;	
}
bool pd(int y,int z)
{
	if( (eat[dfs(y)]==dfs(z)   &&  eat[dfs(y)]!=0)
		||(beeat[dfs(y)]==dfs(z) &&  beeat[dfs(y)]!=0))
	{
		return false;
	}
	return true;
}
void sec(int y,int z)
{
	if(eat[dfs(z)]!=0&&beeat[dfs(y)]!=0)
	{
		dabao(eat[dfs(z)],beeat[dfs(y)]); 
	}
	else if(eat[dfs(z)]!=0)
	{
		eat[dfs(eat[dfs(z)])]=dfs(y);
		beeat[dfs(y)]=eat[dfs(z)];
	}
	else if(beeat[dfs(y)]!=0)
	{
		beeat[dfs(beeat[dfs(y)])]=dfs(z);
		eat[dfs(z)]=beeat[dfs(y)];
	}	
}
int main()
{
	//freopen("chain.in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=0;i<MAXN;i++)
		same[i]=i;
	int x,y,z;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if((y>n||z>n)||(x==2&&y==z))
		{
			fa++;
			continue;
		}
		if(x==1)
		{
			if(pd(y,z)==false)
			{
				fa++; 
				continue;
			}
			dabao(y,z);
		}
		else
		{
			if(dfs(y)==dfs(z)||beeat[dfs(y)]==dfs(z))
			{
				fa++;
				continue;
			}
			if(eat[dfs(y)]!=0&&beeat[dfs(z)]!=0)
			{
				if(pd(y,beeat[dfs(z)])==true&&pd(eat[dfs(y)],z)==true)
				{
					dabao(y,beeat[dfs(z)]);
					dabao(eat[dfs(y)],z);
					sec(y,z);
				}
				else
					fa++;	
			}
			else if(eat[dfs(y)]!=0&&beeat[dfs(z)]==0)
			{
				if(pd(eat[dfs(y)],z)==true)
				{
					dabao(eat[dfs(y)],z);
					beeat[dfs(z)]=dfs(y);
					sec(y,z);
				}
				else
					fa++;
			}
			else if(eat[dfs(y)]==0&&beeat[dfs(z)]!=0)
			{
				if(pd(y,beeat[dfs(z)])==true)
				{
					dabao(y,beeat[dfs(z)]);
					eat[dfs(y)]=dfs(z);
					sec(y,z);
				}
				else
					fa++;
			}
			else if(eat[dfs(y)]==0&&beeat[dfs(z)]==0)
			{
				eat[dfs(y)]=dfs(z);
				beeat[dfs(z)]=dfs(y);
				sec(y,z);
			}
		}
	}
	printf("%d",fa);
    return 0;
}

```
#### 希望管理员大大能放过







---

## 作者：king_kb (赞：0)

看了上面各位大佬的题解，虽然打出了代码但在逻辑上仍有一定问题，因此发一篇题解来巩固一下。

本题唯一特殊的地方在于要开三倍的并查集，并且在第一维存储他的同类，第二维存储他的猎物，第三维存储它的天敌。

另一个难点在于判断两个物种之间的关系以及合并时的联系。合并和查询的具体说明在代码中写有标注。查询的逻辑有点小乱，目前仍有点懵的状态，如果有不对的地方，请各位大佬在私信上指点一下。

代码如下
```cpp
#include<cstdio>
using namespace std;
#define kb 500010

inline int read()
{
	int ans=0, w=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-')	w=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*w;
}

int fa[kb], ans;
int Find(int x)
{
    if(x!=fa[x]) fa[x]=Find(fa[x]);
    return fa[x];
}
void Union(int x, int y)
{
    fa[y]=x;
}

int main()
{
    int n=read();int k=read();
    for(int i=1; i<=3*n; i++) fa[i]=i;//一倍存x的同类，二倍存x的猎物，三倍存x的天敌
    //若a集合和b集合合并，说明a的________是b的_________ 
    //若a集合等于b集合，说明b是a的________ 
	for(int i=1;i<=k;++i) 
    {
        int z=read();int x=read();int y=read();
        if(x>n || y>n) ans++;
        else if(z==1)
        {
            if(Find(x+n)==Find(y) || Find(x+2*n)==Find(y)) {ans++; continue;}//如果y是x的天敌或猎物，所以是谎话 
            Union(Find(x), Find(y)); Union(Find(x+n), Find(y+n)); Union(Find(x+2*n), Find(y+2*n));
        	//x的同类也是y的同类，x的猎物也是y的猎物，x的天敌也是y的天敌 
		}
        else if(z==2)
        {
            if(Find(x)==Find(y) || Find(x+2*n)==Find(y)) {ans++; continue;}//如果x是y的同类或天敌 
            Union(Find(x), Find(y+2*n)); Union(Find(x+n), Find(y)); Union(Find(x+2*n), Find(y+n));
        	//x的同类是y的天敌，x的猎物是y的同类，x的天敌是y的猎物 
		}
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：FREEH (赞：0)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/29639.png)

### 【解题思路】
- 由于动物只有三类，且各种同类和食用关系会影响同类，因此考虑使用并查集。
- 设编号[1,n]表示动物本身的编号，$[n+1,2*n]$表示可以吃的编号，$[2*n+1,3*n]$表示被吃的编号。

- 在每次增加指令的时候判断一下：
	- 同类：判断两只动物的祖先是否存在于另一动物的吃或被吃编号的并查集里。
    - 食用：同理，判断两只动物的关系是否矛盾。
- 如果是假话，就累计答案；如果是真话，就把新的指令加入相应的并查集里。

### 【参考程序】
```cpp
#include<cstdio>
int father[150005],k,n,m,ans;
int findA(int i)
{
	if (father[i]==i) return i;
	return father[i]=findA(father[i]);
}
void Merge(int a,int b)
{
	int aA=findA(a),bA=findA(b);
	if (aA!=bA) father[aA]=bA;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=3*n;i++)
		father[i]=i;
	for (int i=1;i<=m;i++)
	{
		int zl,a,b;
		scanf("%d%d%d",&zl,&a,&b);
		if (a>n||b>n){ans++;continue;}
		if (zl==1)
		{
			if (findA(a+n)==findA(b)||findA(a+2*n)==findA(b)){ans++;continue;}
			Merge(a,b);
			Merge(a+n,b+n);
			Merge(a+2*n,b+2*n);
		}else
		{
			if (findA(a)==findA(b)||findA(a)==findA(b+n)){ans++;continue;}
			Merge(a+n,b);
			Merge(b+2*n,a);
			Merge(b+n,a+2*n);
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Sol1 (赞：0)

~~Sooke的太高深了，不是我等蒟蒻可以理解的，我来一发易懂一点的~~

# 并查集
题目已经给出了有$3$种动物，所以对于$N$种动物中的任意一个$i$，对其定义三个变量：$i_A,i_B,i_C$。

所以我们对于每一句话就可以执行如下操作：

```1 x y```：合并$x_A$和$y_A$ , $x_B$和$y_B$ , $x_C$和$y_C$。

判断是否为假话：如果```father[x_A]==father[y_B]或father[y_C]```，或者```father[x_B]==father[y_A]或father[y_C]```，再或者```father[x_C]==father[y_A]或father[y_B]```，则为假话。

```2 x y```：合并$x_A$和$y_B$ , $x_B$和$y_C$ , $x_C$和$y_A$。

判断是否为假话：如果```father[x_A]==father[y_A]或father[y_C]```，或者```father[x_B]==father[y_A]或father[y_B]```，再或者```father[x_C]==father[y_B]或father[y_C]```，则为假话。

最后说一下维护方法：$f[i]=i_A$,$f[i+5\times10^4]=i_B$,$f[i+10^5]=i_C$。

## Talk is cheap,look at my code

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;
int f[150005];
//初始化
void init(int N)
{
	for (int i = 1;i <= 150000;i++)
		f[i] = i;
}
//寻找祖先结点
int getf(int v)
{
	if (f[v] == v)
		return v;
	f[v] = getf(f[v]);
	return f[v];
}
//合并
bool merge(int c, int x, int y)
{
	if (c == 1)
	{
    	//xA,xB,xC,yA,yB,yC
		int u1 = getf(x), v1 = getf(y), u2 = getf(x + 50000), v2 = getf(y + 50000),
		u3 = getf(x + 100000), v3 = getf(y + 100000);
        //假话
		if (u1 == v2 || u1 == v3 || u2 == v1 || u2 == v3 || u3 == v1 || u3 == v2)
			return false;
		f[u1] = v1;
		f[u2] = v2;
		f[u3] = v3;
		return true;
	}
	else
	{
		int u1 = getf(x), v1 = getf(y), u2 = getf(x + 50000), v2 = getf(y + 50000),
		u3 = getf(x + 100000), v3 = getf(y + 100000);
		if (u1 == v1 || u2 == v2 || u3 == v3 || u3 == v2 || u2 == v1 || u1 == v3)
			return false;
		f[u1] = v2;
		f[u2] = v3;
		f[u3] = v1;
		return true;
	}
}
int main()
{
	int N, K;
	scanf("%d%d", &N, &K);
	init(N);
	int sum = 0;
	for (int i = 1;i <= K;i++)
	{
		int t, x, y;
		scanf("%d%d%d", &t, &x, &y);
		if (x > N || y > N)//假话
		{
			sum++;
			continue;
		}
		sum += !merge(t, x, y);
	}
	printf("%d", sum);
	return 0;
}
```
欢迎找bug

---

## 作者：01190220csl (赞：0)

提供一种全新的思路。
算法：并查集、有向图。
把可以确定属于同类的放在同一并查集内，若确定A吃B，则在A、B间连一有向线段建图。
在同一并查集内，用某一编号V代替其中全部动物。
操作（这里出现的字母代表一个并查集）：
1.合并A、B。
	（1）把以A为端点的边（不论方向）的A头全部接在B上；
    （2）用合并并查集的方法把A接在B上。
    （3）标记B为可化简端点。
2.标记A吃B。
	（1）在A、B间连一条从A出发的有向线段。
    （2）把A、B都标记为可化简端点。
3.化简可化简端点。
	令这一点为A。
    （1）若A的出度>=2，令A->B,A->C,...,A->N，合并B、C、...、N（不标记可化简端点）。
    （2）若A的入度>=2，操作同上。
    （3）若A的出度、入度均为1，设B->A,A->C，则标记C吃A（不标记可化简端点）。
    （4）取消A为可化简端点。
附：
操作1中，若A、B位于同一并查集，则什么也不做；若A、B间有有向线段，则假话+1，然后退出。
操作2中，若A、B间有从A出发的有向线段，则什么也不做；若A、B位于同一并查集或有从B出发的有向线段，则假话+1，然后退出。
操作3递归产生的操作，不可能是假话。
无需考虑无意义有向线段，如连接两叶节点的线段。
编写时注意细节。
代码（实在不懂细节可以看）：
```
#include<bits/stdc++.h>
using namespace std;
struct edge
{
    unsigned short e;
    bool w;
    edge(){};
    edge(int a,bool b){e=a,w=b;};
};
vector<edge> e[50001];//有向线段用邻接表存储
unsigned short fa[50001];
int find( int n )
{
    if( fa[n] == n )
        return n;
    return fa[n] = find( fa[n] );
}
int check( int a , int b )//判断两端点间是否有有向线段及其方向
{
    for( int i = 0 ; i < e[a].size() ; i++ )
        if( e[a][i].e == b )
            return e[a][i].w ? 1 : -1;
    return 0;
}
void make_all( int , int );
void make_line( int , int );
void check_point( int y )//操作3，细节很多
{
    bool m = 0 , n = 0 , third = 0;
    int m0 , n0;
    for( int i = 0 ; i < e[y].size() ; i++ )
    {
        if( e[y][i].w )
        {
            if( m )
            {
                if( e[y][i].e != m0 )
                    make_all( e[y][i].e , m0 );
                e[y].erase( e[y].begin() + i );
                for( int j = 0 ; j < e[m0].size() ; j++ )
                    if( e[m0][j].e == y )
                    {
                        e[m0].erase( e[m0].begin() + j );
                        break;
                    }
                i--;
            }
            else
            {
                m = 1;
                m0 = e[y][i].e;
            }
        }
        else
        {
            if( n )
            {
                if( e[y][i].e != n0 )
                    make_all( e[y][i].e , n0 );
                e[y].erase( e[y].begin() + i );
                for( int j = 0 ; j < e[n0].size() ; j++ )
                    if( e[n0][j].e == y )
                    {
                        e[n0].erase( e[n0].begin() + j );
                        break;
                    }
                i--;
            }
            else
            {
                n = 1;
                n0 = e[y][i].e;
            }
        }
        if( m && n )
        {
            if( !third )
            {
                if( !check( m0 , n0 ) )
                    make_line( m0 , n0 );
                third = 1;
            }
        }
    }
}
void make_all( int x , int y )//操作1
{
    for( int i = 0 ; i < e[x].size() ; i++ )
    {
        for( int j = 0 ; j < e[e[x][i].e].size() ; j++ )
            if( e[e[x][i].e][j].e == x )
            {
                e[e[x][i].e][j].e = y;
                break;
            }
        e[y].push_back( e[x][i] );
        e[x].erase( e[x].begin() + i );
        i--;
    }
    fa[x] = y;
}
int ma( int x , int y )//带附注的操作1
{
    if( x == y )
        return 0;
    if( check( x , y ) )
        return 1;
    make_all( x , y );
    check_point( y );
    return 0;
}
void make_line( int x , int y )//操作2
{
    e[x].push_back( edge( y , 1 ) );
    e[y].push_back( edge( x , 0 ) );
}
int ml( int x , int y )//带附注的操作2
{
    if( check( x , y ) == 1 )
        return 0;
    if( x == y || check( y , x ) )
        return 1;
    make_line( x , y );
    check_point( x );
    check_point( find( y ) );
    return 0;
}
int main()
{
    int n , k , ans = 0;
    cin >> n >> k;
    for( int i = 1 ; i <= n ; i++ )
        fa[i] = i;
    for( int i = 1 ; i <= k ; i++ )
    {
        int x , a , b;
        cin >> x >> a >> b;
        if( a > n || b > n )
        {
            ans++;
            continue;
        }
        if( x == 1 )
            ans += ma( find( a ) , find( b ) );
        else
            ans += ml( find( a ) , find( b ) );
    }
    cout << ans;
}
```

---

## 作者：Mark_ZZY (赞：0)

/\*开3\*n的并查集，其中x用来连接与x同类的，x+n用来连接x吃的，x+2\*n用来连接x被吃的。


1 x y时，如果 x吃y 或 x被y吃，那么为假话，


否则x与y同类，x吃的y也吃，x被吃的y也被吃；


2 x y时，如果 x与y同类（x与x自然也是同类） 或 y吃x，那么为假话，


否则x吃y，y被x吃，y吃x被吃的.\*/


```cpp
#include<cstdio>
    int a[150001];
    int n,k,d,x,y,ans=0;
int find(int x)
{
    if(x!=a[x]) a[x]=find(a[x]);
    return a[x];
}
void go(int x,int y)
{
    x=find(x);
    y=find(y);
    a[x]=y;
}
int main()
{
    scanf("%d %d",&n,&k);
    for(int i=1;i<=3*n;i++)
        a[i]=i;
    for(int i=1;i<=k;i++)
    {
        scanf("%d %d %d",&d,&x,&y);
        if(x>n||y>n)
        {
            ans++;
            continue;
        }
        if(d==1)
        {
            if(find(x+n)==find(y)||find(x+n*2)==find(y))
            {
                ans++;
                continue;
            }
            go(x,y);
            go(x+n,y+n);
            go(x+2*n,y+2*n);
        }
        else
        {
            if(find(x)==find(y)||find(x+2*n)==find(y))
            {
                ans++;
                continue;
            }
            go(x+n,y);
            go(y+2*n,x);
            go(y+n,x+2*n); 
        }
    }
    printf("%d",ans);
}

```

---


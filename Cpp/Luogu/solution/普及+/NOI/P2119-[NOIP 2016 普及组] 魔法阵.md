# [NOIP 2016 普及组] 魔法阵

## 题目背景

NOIP2016 普及组 T4

## 题目描述

六十年一次的魔法战争就要开始了，大魔法师准备从附近的魔法场中汲取魔法能量。

大魔法师有 $m$ 个魔法物品，编号分别为 $1,2,\ldots,m$。每个物品具有一个魔法值，我们用 $X_i$ 表示编号为 $i$ 的物品的魔法值。每个魔法值 $X_i$ 是不超过 $n$ 的正整数，可能有多个物品的魔法值相同。

大魔法师认为，当且仅当四个编号为 $a,b,c,d$ 的魔法物品满足 $X_a<X_b<X_c<X_d,X_b-X_a=2(X_d-X_c)$，并且 $X_b-X_a<(X_c-X_b)/3$ 时，这四个魔法物品形成了一个魔法阵，他称这四个魔法物品分别为这个魔法阵的 $A$ 物品，$B$ 物品，$C$ 物品，$D$ 物品。

现在，大魔法师想要知道，对于每个魔法物品，作为某个魔法阵的 $A$ 物品出现的次数，作为 $B$ 物品的次数，作为 $C$ 物品的次数，和作为 $D$ 物品的次数。

## 说明/提示

【样例解释 $1$】

共有 $5$ 个魔法阵，分别为：

- 物品 $1,3,7,6$，其魔法值分别为 $1,7,26,29$；
- 物品 $1,5,2,7$，其魔法值分别为 $1,5,24,26$；
- 物品 $1,5,7,4$，其魔法值分别为 $1,5,26,28$；
- 物品 $1,5,8,7$，其魔法值分别为 $1,5,24,26$；
- 物品 $5,3,4,6$，其魔法值分别为 $5,7,28,29$。

以物品 $5$ 为例，它作为 $A$ 物品出现了 $1$ 次，作为 $B$ 物品出现了 $3$ 次，没有作为 $C$ 物品或者 $D$ 物品出现，所以这一行输出的四个数依次为 $1,3,0,0$。

此外，如果我们将输出看作一个 $m$ 行 $4$ 列的矩阵，那么每一列上的 $m$ 个数之和都应等于魔法阵的总数。所以，如果你的输出不满足这个性质，那么这个输出一定不正确。你可以通过这个性质在一定程度上检查你的输出的正确性。

【数据规模】

![](https://cdn.luogu.com.cn/upload/image_hosting/nozwrvut.png)

## 样例 #1

### 输入

```
30 8
1
24
7
28
5
29
26
24```

### 输出

```
4 0 0 0
0 0 1 0
0 2 0 0
0 0 1 1
1 3 0 0
0 0 0 2
0 0 2 2
0 0 1 0```

## 样例 #2

### 输入

```
15 15
1 
2 
3 
4 
5
6 
7 
8 
9
10
11
12
13
14
15```

### 输出

```
5 0 0 0
4 0 0 0
3 5 0 0
2 4 0 0
1 3 0 0
0 2 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 0 1 0
0 0 2 1
0 0 3 2
0 0 4 3
0 0 5 4
0 0 0 5```

# 题解

## 作者：henry_y (赞：284)

[博客阅读效果更佳qwq](https://www.cnblogs.com/henry-1202/p/9403914.html)

很好的一道数学推导题

45分做法

$O(N^4)$暴力枚举四个材料

55分做法

从第一个约束条件可得到所有可行答案都是单调递增的，所以可以排序一遍，减少枚举量，可以拿到55分

100分做法

首先可以发现每个$x$都小于n，而$n$最大值只是$15000$，所以可以开一个桶来存每个魔法值出现的次数

回忆一下3个约束条件

$xa<xb<xc<xd$ ①

$xb-xa=2(xd-xc)$ ②

$xb-xa<(xc-xb)/3$ ③

现在魔改一下这三个式子

设$t=xd-xc$

所以②可化为$xb-xa=2t$ ④

将④代入③

$2t<(xc-xb)/3$

移项一下，就变成

$6t<xc-xb$ ⑤

再魔改一下

设$6t+k=xc-xb$（就是把差的部分补上去）

于是可以画出来一个图

![](https://i.loli.net/2018/08/01/5b61a76bf30ff.png)

显然，$A$的最小值为$1$，$D$的最大值为$n$

由图可得$AD=9t+k$

所以我们可以尝试着枚举t，用t来表示各个魔法值的值

由上易得t的范围为$1<=t<=(n-1)/9$

在代码中为了避免除法写成$t*9<n$

再枚举D，因为我们已经枚举出了t，所以C的值是可以直接算出来的

$C=D-t$

又因为使$A,B,C,D$满足条件的k的最小值为1，所以对于当前的C和D，最大的A和B为$A=D-9t-1,B=D-7t-1$

那么如果A和B更小怎么办？

观察到在其他条件不变的情况下，只要$C$和$B$满足$Xc-Xb>6t$，那么这个魔法阵就一定成立，所以当$(a1<a2,b1<b2)$时，只要$a2$和$b2$能够和$C,D$组成魔法阵，$a1,b1$也一定能和$C,D$组成魔法阵，所以可以使用前缀和优化

然后又由乘法原理可得，当前魔法值作为$D$物品的个数为$SumD=SumA*SumB*SumC$

所以我们利用前缀和优化$SumA*SumB$

C的情况可以顺便在算D的时候算出来

那么还有一个问题是，我们枚举的D的范围是多少？

因为要统计前缀和，所以一定是要顺推下去的，由上面那张图我们可以知道，D的最大值为n，最小值则为当k=1且A=1的时候，所以D的最小值为$9*t+2$，再小是无法组成魔法阵的

同理可以枚举A

但是这个的情况又和枚举D的情况有一点不同

在其他条件不变的情况下，只要$C$和$B$满足$Xc-Xb>6t$，那么这个魔法阵就一定成立，所以当$(c1<c2,d1<d2)$时，只要$c1$和$d1$能够和$A,B$组成魔法阵，$c2,d2$也一定能和$A,B$组成魔法阵，所以可以使用后缀和优化

因为需要统计后缀和，所以需要逆推

枚举的范围：A的最大值为$(n-t*9-1)$(因为当k=1，D=n的时候A才最大)，A的最小值则为1

所以就可以算出每个魔法值作为$A,B,C,D$物品的次数了，输出时直接输出当前魔法物品的魔法值的次数就可以了

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    return x*f;
}
#define N 50010
int n,m;
int a[N],b[N],c[N],d[N];
int x[N],vis[N];
int main(){
	n=read();m=read();
	for(int i=1;i<=m;i++)
		x[i]=read(),vis[x[i]]++;
	for(int t=1;t*9<n;t++){
		int sum=0;
		for(int D=9*t+2;D<=n;D++){
			int A=D-9*t-1;
			int B=A+2*t;
			int C=D-t;
			sum+=vis[A]*vis[B];
			c[C]+=vis[D]*sum;
			d[D]+=vis[C]*sum;
		}
		sum=0;
		for(int A=n-9*t-1;A;A--){
			int B=A+2*t;
			int C=B+6*t+1;
			int D=A+9*t+1;
			sum+=vis[C]*vis[D];
			a[A]+=vis[B]*sum;
			b[B]+=vis[A]*sum;
		}
	}
	for(int i=1;i<=m;i++){
		printf("%d %d %d %d\n",a[x[i]],b[x[i]],c[x[i]],d[x[i]]);
	}
	return 0;
}
```

---

## 作者：⊱⋛赫宇⋚⊰ (赞：14)

[题目](https://www.luogu.com.cn/problem/P2119)。
[博客](https://blog.csdn.net/yhhy666/article/details/109190601)
## 40pts
我们可以考虑暴力枚举出这四个点，然后对这四个点进行条件判断复杂度O(n^4)期望得分40
```cpp
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)
for(int k=1;k<=n;k++)
for(int z=1;z<=n;z++)
if(a[i].x<a[j].x&&a[j].x<a[k].x&&a[k].x<a[z].x)
if(a[j].x-a[i].x==2*(a[z].x-a[k].x))
if(a[j].x-a[i].x<(a[k].x-a[j].x)/3.0)
{
	 vis[i][1]++;
	 vis[j][2]++;
	 vis[k][3]++;
	 vis[z][4]++;
}
```
## 55pts
思考还是四重循环的情况，最四重循环进行简化。我们可以发现第一个组成魔法阵的条件是Xa<Xb<Xc<Xd。所以可以先排个序，保证是上升的，那么就可以从上一重循环+1开始枚举

```cpp
for(int i=1;i<=n;i++)
for(int j=i+1;j<=n;j++)
for(int k=j+1;k<=n;k++)
for(int z=k+1;z<=n;z++)
if(a[i].x<a[j].x&&a[j].x<a[k].x&&a[k].x<a[z].x)
if(a[j].x-a[i].x==2*(a[z].x-a[k].x))
if(a[j].x-a[i].x<(a[k].x-a[j].x)/3.0)
{
	 vis[i][1]++;
	 vis[j][2]++;
	 vis[k][3]++;
	 vis[z][4]++;
}
```
## 85pts
想要降低时间复杂度，那么肯定要减少循环的次数，所以我们先想想把四重循环怎么降到三重观察条件

我们假设Xc和Xd之间的距离为t ，那么（Xd-Xc）就是t

因为 Xb-Xa=2(Xd-Xc)
所以 Xb-Xa=2t

Xb-Xa<(Xc-Xb)/3 两边同时3
3（Xb-Xa)<Xc-Xb
所以 6t<Xc-Xb
Xc-Xb=6t+k (k>0)
![图](https://img-blog.csdnimg.cn/20201020222333514.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loaHk2NjY=,size_16,color_FFFFFF,t_70#pic_center)

然后我们发现了我们可以枚举A的位置，然后枚举t的大小，k的大小就可以算出其它的值，然后我们确定枚举的范围

A:(1<=i<=n)
因为当k为1时整个魔法阵的长度最小并且最右端要<=n所以
9t+i+1<=n
t<=(n-1-i)/9
k和t也是同样的道理
9t+i+k<=n
k<=(n-i-9*t)

确定了循环，那么开始确定点的位置

A就是枚举的i
B:A+2t
C:B+6t+k
D:C+t

最后就是累加答案：
如果一个数有好几个，那么可以和其它进行组合，所以答案就是和其他有几个数相乘
```cpp
#include<bits/stdc++.h>
#define maxn 15010
using namespace std;
inline int read()
{
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){res=(res<<1)+(res<<3)+(ch&15);ch=getchar();}
    return res*f;
}
int n,m,a[maxn*4];
int vis[maxn];
int ans[maxn*4][5];//表示i魔法值作为第j的个数
int p[maxn];
int main()
{
     n=read();m=read();
     for(int i=1;i<=m;i++)a[i]=read(),vis[a[i]]++;
     
     for(int i=1;i<=n;i++)
     {
     	 if(vis[i])
     	 for(int j=1;9*j+i+1<=n;j++)
     	 {
     	    if(vis[i+2*j])
			 {
			 	for(int k=1;k+9*j+i<=n;k++)
			 	{
			 		
			 		int B=i+2*j;
			 		int C=B+6*j+k;
			 		int D=C+j;

			 		ans[i][1]+=vis[B]*vis[C]*vis[D];//统计
			 		ans[B][2]+=vis[i]*vis[C]*vis[D];
			 		ans[C][3]+=vis[i]*vis[B]*vis[D];
			 		ans[D][4]+=vis[i]*vis[B]*vis[C];
					 
				 }
			 }	
		 }
	 }
	 for(int i=1;i<=m;i++)
	 {
	 	for(int j=1;j<=4;j++)
	 	cout<<ans[a[i]][j]<<' ';
	 	cout<<endl;
	 }
	 return 0;
}

```
## 100pts
既然三重循环还要超时，好，那么继续压一压，两重循环
我们回到那张图

![](https://img-blog.csdnimg.cn/20201020222333514.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loaHk2NjY=,size_16,color_FFFFFF,t_70#pic_center)

如果把k都当成1，然后D在可行的范围内移动，那么就可以算出ABC的值了，并且可以求出在第三四个的答案

同理，A在可行的范围内移动，那么就可以算出BCD的值了，并且可以求出在第一二个的答案

因为答案数=其他三个的个数相乘，所以我们可以把其中两个先用前缀和维护，然后直接求

```cpp
核心代码
	for(int t=1;t*9<n;t++){
		int sum=0;
		for(int D=9*t+2;D<=n;D++){//枚举D找第三四个的值
			int A=D-9*t-1;
			int B=A+2*t;
			int C=D-t;
			sum+=vis[A]*vis[B];//前缀和维护
			c[C]+=vis[D]*sum;
			d[D]+=vis[C]*sum;
		}
		sum=0;
		for(int A=n-9*t-1;A>=1;A--){//枚举A找第一二个的值
			int B=A+2*t;
			int C=B+6*t+1;
			int D=A+9*t+1;
			sum+=vis[C]*vis[D];
			a[A]+=vis[B]*sum;
			b[B]+=vis[A]*sum;
		}
	}

```


---

## 作者：chrispang (赞：7)

### 题目大意

给定 $m$ 种材料，选出其中四种材料，按照题目描述构建成一个魔法阵，魔法阵中的材料分别称：$A$ 物品、$B$ 物品、$C$ 物品和 $D$ 物品。求每种材料作为一个魔法阵中的四种物品的次数是多少。

### 题目思路

先打出暴力，分别枚举四种物品，时间复杂度 $O(m^4)$（能拿 $50$ 分）。

```cpp
#include <bits/stdc++.h>
#define int long long //好习惯
#define maxn 40010
using namespace std;

int read() { //快读
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, m, x[maxn], ans[maxn][5]; //答案数组
signed main() {
	n = read(), m = read();
	for (int i = 1; i <= m; i++) x[i] = read();
	for (int a = 1; a <= m; a++) {
		for (int b = 1; b <= m; b++) {
			if(a == b || x[a] >= x[b]) continue; //剪枝
			for (int c = 1; c <= m; c++) {
				if(c == a || c == b || x[b] >= x[c]) continue; //剪枝
				for (int d = 1; d <= m; d++) {
					if(d == a || d == b || d == c || x[c] >= x[d]) continue; //剪枝
					if(x[b] - x[a] == 2 * (x[d] - x[c]) && (x[b] - x[a]) * 3 < (x[c] - x[b])) ans[a][1]++, ans[b][2]++, ans[c][3]++, ans[d][4]++; //计算
				}
			}
		}
	}
    //输出
	for (int i = 1; i <= m; i++) {
		write(ans[i][1]), putchar(' ');
		write(ans[i][2]), putchar(' ');
		write(ans[i][3]), putchar(' ');
		write(ans[i][4]), putchar('\n');
	}
	return 0;
}
```

我们可以发现，题目中有这么一个条件：

> $X_a<X_b<X_c<X_d$。

这样我们就可以先进行排序，可以减少一些不必要的枚举（能拿 $60$ 分）。

```cpp
#include <bits/stdc++.h>
#define maxn 40010
using namespace std;

int read() { //快读 
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写 
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, m, ans[maxn][5];
struct node {
	int id, val; //这里需要记录id号了，因为我们需要知道这个数的下标 
}x[maxn];

bool cmp(node x, node y) {
	return x.val < y.val;
}

int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; ++i) x[i].id = i, x[i].val = read();
	sort(x + 1, x + m + 1, cmp); //排序 
	for (int a = 1; a <= m; ++a) {
		for (int b = a + 1; b <= m; ++b) {
			if(x[b].val == a[x].val) continue; //不能等于 
			for (int c = b + 1; c <= m; ++c) {
				if(x[c].val == x[b].val) continue; //不能等于
				for (int d = c + 1; d <= m; ++d) {
					if(x[d].val == x[c].val) continue; //不能等于
					if(x[b].val - x[a].val == (x[d].val - x[c].val) * 2 && (x[b].val - x[a].val) * 3 < (x[c].val - x[b].val))
						ans[x[a].id][1]++, ans[x[b].id][2]++, ans[x[c].id][3]++, ans[x[d].id][4]++; //id号的作用 
				}
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		write(ans[i][1]), putchar(' ');
		write(ans[i][2]), putchar(' ');
		write(ans[i][3]), putchar(' ');
		write(ans[i][4]), putchar('\n');
	}
	return 0;
}
```

接着进行优化，我们想想能否把四重循环换成三重循环。

我们发现题目中有这些话：

> $X_b−X_a=2(X_d−X_c)$，并且 $X_b−X_a<(X_c-X_b)\div3$。

换算一下可得：

> $X_b−X_a=2(X_d−X_c)$，并且 $(X_b−X_a)\times3<(X_c-X_b)$。

从而可以画出这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1m7yxbz7.png)

也就是说，我们只需要枚举 $a,t,k$ 就行了，时间复杂度 $O(n^3)$（能拿 $85$ 分）。

```cpp
#include <bits/stdc++.h>
#define maxn 40010
#define N 100010 //开的大一点没有害处 
using namespace std;

int read() { //快读
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, m, cnt[N], ans[maxn][5], x[maxn];
int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; ++i) x[i] = read(), cnt[x[i]]++; //记录数量 
//	sort(x + 1, x + m + 1); //注意这里不能排序 
	for (int a = 1; a <= n; ++a) { //注意这里枚举的a不是下标 
		if(!cnt[a]) continue; //剪枝 
		for (int t = 1; t <= n; ++t) {
			if(!cnt[a + 2 * t]) continue; //剪枝 
			for (int k = 1; k <= n; ++k) {
				if(!cnt[a + 2 * t + 6 * t + k]) continue; //剪枝 
				int b = a + 2 * t, c = b + 6 * t + k, d = c + t; //计算b、c、d 
				ans[a][1] += cnt[b] * cnt[c] * cnt[d]; //要加上倍数 
				ans[b][2] += cnt[a] * cnt[c] * cnt[d];
				ans[c][3] += cnt[a] * cnt[b] * cnt[d];
				ans[d][4] += cnt[a] * cnt[b] * cnt[c];
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		write(ans[x[i]][1]), putchar(' '); //这里不是ans[i][1]，因为我们在上面计算的时候计算的不是下标而是魔法值 
		write(ans[x[i]][2]), putchar(' ');
		write(ans[x[i]][3]), putchar(' ');
		write(ans[x[i]][4]), putchar('\n');
	}
	return 0;
}
```

我们可以接着进行优化，还是这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1m7yxbz7.png)

我们可以缩小 $a,t,k$ 的数据范围，由于 $t\ge1,k\ge 1$，而 $a+9t+k\le n$，可得 $a \le n-10$。

接着计算 $t$ 的范围，由于 $a\ge1,k\ge1$，而 $a+9t+k\le n$，可得 $t \le \frac{n-2}{9}$。

而 $k$ 也同理，$k\le n-10$。

所以我们可以写出以下优化代码，时间复杂度 $O(n^3)$（能拿 $90$ 分）：

```cpp
#include <bits/stdc++.h>
#define maxn 40010
#define N 100010 //开的大一点没有害处 
using namespace std;

int read() { //快读
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, m, cnt[N], ans[maxn][5], x[maxn];
int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; ++i) x[i] = read(), cnt[x[i]]++; //记录数量 
//	sort(x + 1, x + m + 1); //注意这里不能排序 
	for (int a = 1; a <= n - 10; ++a) { //注意这里枚举的a不是下标 
		if(!cnt[a]) continue; //剪枝 
		for (int t = 1; t * 9 <= n - 2; ++t) {
			if(!cnt[a + 2 * t]) continue; //剪枝 
			for (int k = 1; k <= n - 10; ++k) {
				if(!cnt[a + 2 * t + 6 * t + k]) continue; //剪枝 
				int b = a + 2 * t, c = b + 6 * t + k, d = c + t; //计算b、c、d 
				ans[a][1] += cnt[b] * cnt[c] * cnt[d]; //要加上倍数 
				ans[b][2] += cnt[a] * cnt[c] * cnt[d];
				ans[c][3] += cnt[a] * cnt[b] * cnt[d];
				ans[d][4] += cnt[a] * cnt[b] * cnt[c];
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		write(ans[x[i]][1]), putchar(' '); //这里不是ans[i][1]，因为我们在上面计算的时候计算的不是下标而是魔法值 
		write(ans[x[i]][2]), putchar(' ');
		write(ans[x[i]][3]), putchar(' ');
		write(ans[x[i]][4]), putchar('\n');
	}
	return 0;
}
```

既然三重循环还要超时，好，那么继续压一压，两重循环 我们回到那张图。

![img](https://cdn.luogu.com.cn/upload/image_hosting/1m7yxbz7.png)

如果把 $k$ 都当成 $1$，然后 $d$ 在可行的范围内移动，那么就可以算出 $a,b,c$ 的值了，并且可以求出在第三四个的答案。

同理，$a$ 在可行的范围内移动，那么就可以算出 $b,c,d$ 的值了，并且可以求出在第一二个的答案。

因为答案数 $=$ 其他三个的个数相乘，所以我们可以把其中两个先用前缀和维护，然后直接求。

上代码，时间复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define maxn 40010
#define N 100010 //开的大一点没有害处 
using namespace std;

int read() { //快读
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}

int n, m, cnt[N], ans[maxn][5], x[maxn];
int main() {
	n = read(), m = read();
	for (int i = 1; i <= m; ++i) x[i] = read(), cnt[x[i]]++; //记录数量
	for (int t = 1; t * 9 <= n - 2; t++) {
		for (int d = 9 * t + 2, sum = 0; d <= n; d++) {
			int a = d - 9 * t - 1, b = a + 2 * t, c = d - t; //计算a、b、c
			sum += cnt[a] * cnt[b]; //注意这里有可能不同的t组成相同的d，所以要+= 
			ans[c][3] += sum * cnt[d];
			ans[d][4] += sum * cnt[c];
		}
		for (int a = n - 9 * t - 1, sum = 0; a >= 1; a--) { //注意这里要逆推 
			int b = a + 2 * t, c = b + 6 * t + 1, d = c + t; //计算b、c、d 
			sum += cnt[c] * cnt[d];
			ans[a][1] += sum * cnt[b];
			ans[b][2] += sum * cnt[a];
		}
	}
	for (int i = 1; i <= m; ++i) {
		write(ans[x[i]][1]), putchar(' '); //这里不是ans[i][1]，因为我们在上面计算的时候计算的不是下标而是魔法值
		write(ans[x[i]][2]), putchar(' ');
		write(ans[x[i]][3]), putchar(' ');
		write(ans[x[i]][4]), putchar('\n');
	}
	return 0;
}
```
制作不易，点个赞吧！球球啦！

---

## 作者：crh1272336175 (赞：5)

注：本题解非原创，参考了本蒟蒻的教练的题解

首先肯定有一个大概的思路：对于读入的每个数v[i]，可以统计这个值出现了多少次，用cnt[i]统计i这个值出现的次数,由条件$xa<xb<xc<xd, xb-xa=2(xd-xc), xb-xa<(xc-xb)/3$，可知道枚举的四个数之间的大小关系。

不妨设xc与xd距离为t(t<n/9)，那么xa与xb距离为2t，xb与xc距离>=6t+1。

这样，我们可以不用暴力枚举4个值，只要枚举xa,t,xc，就可以推出xb和xd，这样做的复杂度为$O(n^3/9)$，还是太高。

考虑到枚举$xa$和$t$时，在离xa点向右$8*t+1$的$xc,xd$
点对， 都可以 跟xa,xb凑成答案，我们可以预处理距离为t的点对数量的后缀和，表示为
$sumcd[i] = sumcd[i+1] + cnt[i]*cnt[i+t]$，

这样枚举完xa和t时,xa可以成为a点的次数为$cnt[xa+2*t]*sumcd[xa+8*t+1]$;

同时，$xa+2*t$可以成为b点的次数为$cnt[xa]*sumcd[xa+8*t+1]$;

类似的，我们可以预处理距离为2*t的点对数量的前缀和，表示为$sumab[i] = sumab[i-1] + cnt[i]*cnt[i-2*t]$，这样枚举$xd$和$t$时，xd可以成为d点的次数为$cnt[xd-t]*sumab[xd-7*t-1]$;

同时，$xd-t$可以成为$c$点的次数为$cnt[xd]*sumcd[xd-7*d-1]$;

so，我们就可以统计每个数值作为a,b,c,d点符合条件的次数，时间复杂度为$O(n^2/9)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=15005;
int n,m;
int v[40005],a[M],b[M],c[M],d[M],cnt[M];
int sumab[M],sumcd[M];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++)
	{
        scanf("%d",&v[i]); 
		cnt[v[i]]++;
    }
    for(int t=1; t<=n/9; t++)
	{
        for(int i=0; i<=n+1; i++) sumab[i]=sumcd[i]=0;
        for(int i=n-t; i>=1; i--) 
            sumcd[i]=sumcd[i+1]+cnt[i]*cnt[i+t];
        for(int i=1+2*t; i<=n; i++) 
            sumab[i]=sumab[i-1]+cnt[i]*cnt[i-2*t];
        for(int i=1; i+8*t+1<=n; i++)
		{
            a[i]+=cnt[i+2*t]*sumcd[i+8*t+1];
            b[i+2*t]+=cnt[i]*sumcd[i+8*t+1];
        }
        for(int i=n; i-7*t-1>=1; i--)
		{
            d[i]+=cnt[i-t]*sumab[i-7*t-1];
            c[i-t]+=cnt[i]*sumab[i-7*t-1];
        }
    }
    for(int i=1; i<=m; i++)
        printf("%d %d %d %d\n",a[v[i]],b[v[i]],c[v[i]],d[v[i]]);
    return 0;
}
```




---

## 作者：Thaumaturge (赞：4)

看了一下，大家好像全是桶排序后再枚举点对的位置。。但我太蒟蒻了，只会枚举Xb-Xa（所以这道题耗了我几个小时的时间）

首先，看到15000这个神奇的数字，我们就可以理所应当地想到以魔法值为下标(bj)，先全部读进来再说

再看，如果一个个枚举Xa,Xb,Xc的话，Xd虽然可以直接得出来，但也远远超时，所以不可行

再考虑：看一下空间限制，我们能发现：512MB！也就是说，我们可以考虑把两个魔法值下标对应的差记下来（即Xa-Xb,Xc-Xd），如果他们对应的物品数都不为0，说明这个组合与其他符合条件的组合能产生的法阵对数就为他们的物品之积，这个时间为O(n^2),远远超出了范围。。。

但是，我们可以发现，有很多状态是不需要的，看这个简陋的图：

 (Xa) L L (Xb) | L L L L L L | (Xc) L (Xd)
 
对于每一对Xa,Xb,如果它们之间的距离为2L，那么Xc与Xb至少相距6L+1,Xc,Xd至少相距L,L还是个整数

也就是说，即使对于15000，枚举Xa，也至多只会产生（15000+1）* 15000 * 1/9 * 1/2种情况（不可靠估计），这下就在可控范围之内了，开个19000000完全没事

再看：我们把Xa,Xb距离对与Xc,Xd距离对分开储存，并对于距离对相同的距离对与另外一组符合要求的魔法值能产生的法阵数记录一次前缀和(qzh),具体来说：如果魔法值为2的物品有n个，魔法值为3的物品有m个，那么他们与任意一组Xc在6以上的，Xd-Xc=2能产生的魔法阵数就为m * n ，如果(2,3)点对的序号为k,那么它的前缀和就是：m * n+qzh(k-1);   特别地，对于一组点对，若它之前没有距离与它相等的点对，那么它的前缀和就是m * n,由于我们枚举的是距离，因此判断时只需与上一个点对进行判断即可

接下来，就可以通过枚举L和储存的点（也就是Xa与Xc）来验证，如果存在Xa-Xb<(Xc-Xb)/3,就说明若目前Xc不越界,这个式子对于以后的Xc都成立,因为我们记录相同距离的点对是从小到大枚举的。因此我们可以把每个距离的最后一组点对的下标(bk,下标为点对距离)也记录下来，那么对于Xa，Xb，每个魔法物品的Xa,Xb,就是所有使(Xc-Xb)/3>Xa-Xb成立的最和一组点对(Xc,Xd)的前缀和减去上一组点对的前缀和

(qzh[bk[i]]-qzh[mc-1]) * bj[lka[cm]+i2]; (Xa)

(qzh[bk[i]]-qzh[mc-1]) * bj[lka[cm]]; (Xb)

其中i2=2 * i,i为距离，mc是Xc，Xd点对的序号，cm是Xa，Xb点对的序号

对于Xc，Xd，我们可以再枚举一遍（反正总运算次数不会超1e8）,反过来思考，每个魔法物品的Xc，Xd就是条件成立时以下式子的和：

qzq[cm] * bj[lja[mc]+i];

qzq[cm] * bj[lja[mc]];

qzq是Xa，Xb的前缀和，其余无异

最后，对于输入的每个数，输出其对应的魔法值的Xa,Xb,Xc,Xd个数即可

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[45000],m,bj[20000],lja[19000000],qzh[19000000],bk[30000],qzq[19000000],lka[19000000],b0[30000],i,j,k,n,cc,numa,num0,Begin,sl,ok;
//lja是储存a的，qzh用来快速计算可形成魔法阵个数，由于每个长度中每个数都要搜一遍，存好的数在该区间内一定是单调递增的
//所以直接遍历过去几乎和二分一样优越，
//由于空间占用过大，因此不能使用longlong存储，因此前缀和必须只对当前长度的进行存储，bk就起到了一个长度的队尾的作用来保证qzh不越界
//lja,qzh均为c,d的存储,a,b的存储为lka,qzq
int cm,mc,ans[20000][4],ss,xhcs;//储存答案
int i8,i2;//一些神奇的东西，尽可能压低运算次数吧。。

int main(){
	//freopen("appl.in","r",stdin);
	//freopen("appl.out","w",stdout);
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		scanf("%d",&a[i]);
		bj[a[i]]++;
	}
		
	ss=(n-1)/9;

	for(i=1;i<=ss;i++)
	{
		cc=n-i;
		Begin=8*i+1;
		while(Begin<=cc)
		{
			if(bj[Begin]!=0)
			if(bj[Begin+i]!=0)
			{
				lja[++numa]=Begin;
				qzh[numa]=bj[Begin]*bj[Begin+i];
				break;
			}
			Begin++;
		}

		if(Begin<cc)
		for(int g=Begin+1;g<=cc;g++)
		{
			if(bj[g]!=0)
			if(bj[g+i]!=0)
			{
				lja[++numa]=g;
				qzh[numa]=qzh[numa-1]+bj[g]*bj[g+i];
			}
		}
		bk[i]=numa;
	}

	for(i=1;i<=ss;i++)
	{
		cc=n-9*i-1;
		Begin=1;
		i2=2*i;
		while(Begin<=cc)
		{
			if(bj[Begin]!=0)
			if(bj[Begin+2*i]!=0)
			{
				lka[++num0]=Begin;
				qzq[num0]=bj[Begin]*bj[Begin+i2];
				break;
			}
			Begin++;
		}

		if(Begin<cc)
		for(int g=Begin+1;g<=cc;g++)
		{
			if(bj[g]!=0)
			if(bj[g+2*i]!=0)
			{
				lka[++num0]=g;
				qzq[num0]=qzq[num0-1]+bj[g]*bj[g+i2];
			}
		}
		b0[i]=num0;
	}

	for(i=1;i<=ss;i++)
	{
		mc=bk[i-1]+1;
		cm=b0[i-1]+1;
		i8=8*i;
		i2=2*i;
		if(bk[i-1]!=bk[i] && b0[i-1]!=b0[i])
		{
			while(lja[mc]-lka[cm]<=i8)
			mc++;

			while(mc<=bk[i] && cm<=b0[i])
			{
				while(lja[mc]-lka[cm]<=i8 && mc<=bk[i])
				mc++;

				if(mc>bk[i]) break;

				if(mc==bk[i-1]+1)
				{
					ans[lka[cm]][0]+=qzh[bk[i]]*bj[lka[cm]+i2];
					ans[lka[cm]+i2][1]+=qzh[bk[i]]*bj[lka[cm]];
				}
				else
				{
					ans[lka[cm]][0]+=(qzh[bk[i]]-qzh[mc-1])*bj[lka[cm]+i2];
					ans[lka[cm]+i2][1]+=(qzh[bk[i]]-qzh[mc-1])*bj[lka[cm]];
				}
				cm++;
			}
		}
	}

	for(i=1;i<=ss;i++)
	{
		mc=bk[i];
		cm=b0[i];
		i8=8*i;
		if(bk[i-1]!=bk[i] && b0[i-1]!=b0[i])
		{
			while(lja[mc]-lka[cm]<=i8)
			cm--;

			while(mc>bk[i-1] && cm>b0[i-1])
			{
				while(lja[mc]-lka[cm]<=i8 && cm>b0[i-1])
				cm--;

				if(cm<=b0[i-1]) break;
				ans[lja[mc]][2]+=qzq[cm]*bj[lja[mc]+i];
				ans[lja[mc]+i][3]+=qzq[cm]*bj[lja[mc]];

				mc--;
			}
		}
	}

	for(i=1;i<=m;i++)
	printf("%d %d %d %d\n",ans[a[i]][0],ans[a[i]][1],ans[a[i]][2],ans[a[i]][3]);
	return 0;
}
```

额，确实挺麻烦啊。。。

---

## 作者：qhr2023 (赞：2)

## solution

一道数学推导优化枚举的题。

容易写出暴力枚举，考虑通过缩小枚举范围优化枚举。

知道 $X_a<X_b<X_c<X_d$ 且 $X_b-X_a=2(X_d-X_c)<(X_c-X_b) \div 3$。

设一个参数 $k=X_d-X_c$，对原式变形得 $X_b-X_a=2k$ 和 $6k<X_c-X_b$，即 $X_b=X_a+2k$ 和 $X_c>X_b+6k$。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ljy7dlu.png)

对于每个 $k$，$X_a$ 到 $X_b$、$X_c$ 到 $X_d$ 的距离都是定值，而 $X_b$ 到 $X_c$ 的距离是个区间。

首先要了解这点。若 $X_{c_1}<X_{c_2}$ 且$X_{d_1}<X_{d_2}$，并且 $X_{c_1}-X_b > 6k$，即 $X_{c_1}$ 和 $X_{d_1}$ 可以组成魔法阵，那么 $X_{c_2}-X_b > 6k$，也就是 $X_{c_2}$ 和 $X_{d_2}$ 一定可以组成魔法阵。

类似的，若 $X_{a_1}<X_{a_2}$ 且$X_{b_1}<X_{b_2}$，并且 $X_c-X_{b_2} > 6k$，即 $X_{a_1}$ 和 $X_{b_1}$ 可以组成魔法阵，那么 $X_c-X_{b_1} > 6k$，也就是 $X_{a_2}$ 和 $X_{b_2}$ 一定可以组成魔法阵。

我们从后往前枚举 $X_a$，记 $S_{x_i}$ 表示 $x_i$ 出现次数，乘法原理得当前可以作为 $X_a$ 的个数为 $S_{X_b} \times S_{X_c} \times S_{X_d}$，用一个后缀和维护 $S_{X_c} \times S_{X_d}$ 变枚举边算，这样就可以 $O(n^2)$ 做了。

从前往后枚举 $X_d$，维护前缀和，同样可以算出贡献。

那就得到了做法，先枚举 $k$，再分别枚举 $X_a$ 和 $X_d$ 的范围计算贡献。

$X_a$ 的范围是 $1$ 到 $n-9k-y$。当 $y=1$ 且 $X_d=n$ 时 $X_a$ 最大。

$X_d$ 的范围是 $9k+2$ 到 $n$。当 $y=1$ 且 $X_a=1$ 时 $X_d$ 最小。

这道题还是有点抽象，不太好描述，可以结合代码体会。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, A[50005][4], x[50005], num[50005];
int main () {
	cin >> n >> m;
	for (int i=1; i<=m; ++i)
		cin >> x[i],
		num[x[i]]++;
	for (int k=1, a, b, c, d, s; 9*k<=n; ++k) {
		for (a=n-9*k-1, s=0; a>=1; --a) // 枚举a，确定bcd 
			b=a+2*k, c=b+6*k+1, d=c+k,
			s+=num[c]*num[d],
			A[a][0]+=num[b]*s,
			A[b][1]+=num[a]*s;
		for (d=9*k+2, s=0; d<=n; ++d) // 枚举d，确定abc 
			a=d-9*k-1, b=a+2*k, c=d-k,
			s+=num[a]*num[b],
			A[c][2]+=num[d]*s,
			A[d][3]+=num[c]*s;
	}
	for (int i=1; i<=m; ++i, cout << '\n')
		for (int j=0; j<4; ++j)
			cout << A[x[i]][j] << ' ';
	return 0;
}
```

---

## 作者：songyuteng (赞：1)

# **P2119 魔法阵 题解**
## **题目分析**
这道题要求我们找出所有满足特定条件的四元组 $(X_a,X_b,X_c,X_d)$，并统计每个物品作为 $A$，$B$，$C$，$D$ 出现的次数。题目给出了三个条件：

$$X_a < X_b < X_c < X_d$$

$$X_b - X_a = 2(X_d - X_c)$$

$$X_b - X_a < (X_c - X_b)\div3$$ 
## **暴力骗分**

我相信大部分人为了骗分，用了最简单的暴力。用四个循环枚举所有可能的组合。应该是这样的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=4e4+10;
int n,m,x[M],a[M],b[M],c[M],d[M];
int main(){
    cin>>n>>m;
    for(int i=0;i<m;i++) cin>>x[i];
    for(int ia=0;ia<m;ia++){
        for(int ib=0;ib<m;ib++){
            if(x[ia]>=x[ib]) continue;//判断大小，尽量减少暴力，虽然好像也过不了。
            for(int ic=0;ic<m;ic++){
                if(x[ib]>=x[ic]) continue;
                for(int id=0;id<m;id++){
                    if(x[ic]>=x[id]) continue;
                    int ba=x[ib]-x[ia];//存储差值，这个应该不用讲。
                    int dc=x[id]-x[ic];
                    int cb=x[ic]-x[ib];
                    if(ba==2*dc && ba*3<cb){
                        a[ia]++;     //记录物品数。
                        b[ib]++;
                        c[ic]++;
                        d[id]++;
                    }
                }
            }
        }
    }
    for(int i=0;i<m;i++){
        cout<<a[i]<<" "<<b[i]<<" "
            <<c[i]<<" "<<d[i]<<endl;
    }
    return 0;
}

```
只要是人，看到这 $O(n^4)$ 复杂度，都知道过不了，下面讲讲如何优化。
## **优化**
在打完暴力后，聪明的人肯定能想到用排序来优化。将输入的数组进行排序，后续循环就可以减小一些复杂度，但仍然于事无补。复杂度仍然高得离谱（排序也很简单，用 sort 即可，这就不给代码了，不然太长了）。
### **数学优化**
众所周知，没有什么优化，能比数学优化更节省时间复杂度了。

好，现在下面讲的就要抽象一些了。用数学来减小复杂度。相信应该很多人能想到吧，但可能想不出来怎么优化。下面来看一看推导。

为了减少时间复杂度，我们就想，能不能有一个数表示其它多个数，直接减少时间复杂度。

我们就用一个 $t$ 这个天选之子来表示 $D - C‌$ （就是他俩的距离）。

那么根据条件 $2$：

$$X_b - X_a = 2t‌$$ 

可得 

$$X_b = X_a + 2t$$ 

根据条件 $3$：

$$2t < (X_c - X_b)\div3‌$$ 

整理得 

$$X_c > X_b + 6t‌$$ 

细细一看，可以表示为 

$$X_c > X_a + 8t$$ 

因为 

$$X_d = X_c + t$$ 

所以可以得到 

$$‌X_d > X_a + 9t‌$$ 

聪明的人一看，太棒了，这不是只用枚举 $X_a$ 和 $t$ 就可以了。

至于枚举的边界问题，这个您就自己思考思考，实在想不出来，代码里我会给解释的。

```cpp
for (int i = 0; i < m; ++i) {
        cin >> x[i];
        cnt[x[i]]++;   //这里是为了后面不需要在统计某个物品的出现次数。
}
for (int ia = 1; ia <= n; ++ia) {
//这里是优化计算，t的取值范围：1≤t≤(n-1)/9（因为 X_a≥1 且 Xd≤n）。
        for (int t = 1; ia + 9 * t + 1 <= n; ++t) {‌
            int ib = ia + 2 * t;
            int ic = ia + 8 * t + 1;
            int id = ic + t;
            
            if (ib <= n && ic <= n && id <= n) {
                int sum = cnt[a] * cnt[b] * cnt[c] * cnt[d];//用cnt快速计算。
                a[ia] += sum;//加起来。
                b[ib] += sum;
                c[ic] += sum;
                d[id] += sum;
            }
        }
    }
```
这只是重点代码。
## **完整代码**
看到这里，你应该可以把完整代码写出来了，这里，我可以给你们看看我的完整代码。

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 15010;

int main() {
    int n, m;
    cin >> n >> m;
    vector<int> x(m), cnt(MAXN, 0);
    for (int i = 0; i < m; i++) {
        cin >> x[i];
        cnt[x[i]]++;
    }

    vector<int> A(MAXN, 0), B(MAXN, 0), C(MAXN, 0), D(MAXN, 0);

    // 枚举差值t = Xd - Xc
    for (int t = 1; 9 * t + 1 <= n; t++) {
        int sum = 0;
        // 枚举D的位置
        for (int d = 9 * t + 2; d <= n; d++) {
            int a = d - 9 * t - 1;
            int b = a + 2 * t;
            int c = d - t;
            
            sum += cnt[a] * cnt[b];
            D[d] += sum * cnt[c];
            C[c] += sum * cnt[d];
        }
        
        sum = 0;
        // 枚举A的位置
        for (int a = n - 9 * t - 1; a >= 1; a--) {
            int b = a + 2 * t;
            int c = b + 6 * t + 1;
            int d = c + t;
            
            sum += cnt[c] * cnt[d];
            A[a] += sum * cnt[b];
            B[b] += sum * cnt[a];
        }
    }

    // 输出结果
    for (int i = 0; i < m; i++) {
        cout << A[x[i]] << " " << B[x[i]] << " " 
             << C[x[i]] << " " << D[x[i]] << endl;
    }

    return 0;
}

```
## **结语**
这道题不知可以这样优化，你还可以用前缀和，还可以加上哈希表。牛逼的还用多线程。各种优化层出不穷，所以，好好看看世界优化极限的广阔吧。

---

## 作者：lijingshu_304775 (赞：1)

原题链接：<https://www.luogu.com.cn/problem/P2119>。

## 分析

这道题目要求我们找到满足特定条件的四个魔法物品，称为魔法阵。

魔法阵具体条件是：

1. 四个物品的魔法值严格递增：$X_a < X_b < X_c < X_d$。

2. $X_b - X_a = 2 \times (X_d - X_c)$。

3. $X_b - X_a < (X_c - X_b) / 3$。

首先统计每个魔法值出现的次数，这样可以方便后续的计算。

再遍历可能的 $t$：对于每个可能的 $t$，使得 $9\times t < n - 1$。这个 $t$ 是一个关键参数，用于确定四元组的范围。

然后遍历可能的 $a$：对于每个 $a$，使得 $a \times 9 \times t + 1 < n$。这个 $a$ 是四元组中的最小值。

最后统计满足条件的四元组，在内层循环中，统计满足条件的四元组数量，并更新答案数组。

用这样的思路，这道题写代码就非常简单了。

下面是按照上面的步骤写出的代码。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, cnt[16000], x[41000], ans[40000][5];
int main(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		cin >> x[i];
		cnt[x[i]]++; // 统计每个魔法值出现的次数
	}
	for(int t = 1;9 * t <= n;t++){ // 遍历可能的 t
		int res = 0, a, b, c, d;
		for(a = n - 9 * t - 1;a > 0;a--){ // 遍历可能的 a
			b = a + 2 * t; // 计算对应的 b
			c = a + 8 * t + 1; // 计算对应的 c
			d = a + 9 * t + 1; // 计算对应的 d
			res += cnt[c] * cnt[d]; // 统计满足条件的四元组数量
			ans[a][0] += cnt[b] * res; // 更新答案
			ans[b][1] += cnt[a] * res; // 更新答案
		}
		res = 0;
		for(d = 9 * t + 2;d <= n;d++){ // 第二次操作，同上
			a = d - 9 * t - 1; 
			b = d - 7 * t - 1;
			c = d - t;
			res += cnt[a] * cnt[b];
			ans[c][2] += cnt[d] * res;
			ans[d][3] += cnt[c] * res;
		}
	}
	for(int i = 1;i <= m;i++){
		for(int j = 0;j < 4;j++){
			cout << ans[x[i]][j] << ' ';
		}
		cout << endl;
	}
	return 0;
}
```

AC 记录：<https://www.luogu.com.cn/record/218437099>。

---

## 作者：cwxcplh (赞：1)

很考验思维能力的一道数学题。

为了各位读者能高度理解，我们先从最基础的方法开始讲，请各位大佬耐心观看。

## 40pts 做法

直接暴力枚举四个物品，看看能否成立，时间复杂度 $O(n^4)$，预计得分 40 分。

伪代码：

```cpp
for(int a=1; a<=n; a++) {
	for(int b=1; b<=n; b++) {
		for(int c=1; c<=n; c++) {
			for(int d=1; d<=n; d++) {
				if(x[a]<x[b]&&x[b]<x[c]&&x[c]<x[d]&&x[b]-x[a]==2*(x[d]-x[c])&&x[b]-x[a]<(x[c]-x[b])/3.0) {
					num[1][a]++;
					num[2][b]++;
					num[3][c]++;
					num[4][d]++;
				}
			}
		}
	}
}
```

## 85pts 做法

要想提高分数，我们就要想想怎样把循环次数压下来。

观察题目中给的三个式子：

$$\begin{cases}
X_a\lt X_b\lt X_c\lt X_d\textcircled{1}\\
X_b-X_a=2(X_d-X_c)\textcircled{2}\\
X_b-X_a\lt(X_c-X_b)/3\textcircled{3}
\end{cases}$$

不难发现，$X_b-X_a$ 这个式子一直在反复出现，所以我们把 $X_b-X_a$ 看成一个整体（换元法），这里需要一点点数感，如果你看不出来，那就先去做点代数题再回来看。

但有个问题：如果我们把 $X_b-X_a$ 设成一个未知数，那么 $X_d-X_c$ 就会被表示成一个分数，为了方便，我们在这里设 $t=X_d-X_c$，所以 $X_b-X_a$ 就可以被表示为 $2t$。

我们把 $2t=X_b-X_a$ 这个式子带入式子 $\textcircled{3}$ 中得：

$$2t<(X_c-X_b)/3$$

把右边变成一个整数，那么就成了：

$$6t\lt X_c-X_b$$

因为不等式不太好解，所以我们转化一下，就成了：

$$6t+k=X_c-X_b$$

其中 $k$ 是少了的那一部分。

那么我们就可以得到这样三个式子：

$$\begin{cases}
X_d-X_c=t\\
X_b-X_a=2t\\
X_c-X_b=6t+k
\end{cases}$$

我们把 $X_a,X_b,X_c,X_d$ 看做主元，那么一共就有四个未知数，但只有三个方程，所以我们要拿一个未知数表示出其他未知数，这里我用的是 $X_a$。

$$\therefore\text{解得}\begin{cases}X_b=X_a+2t\\X_c=X_a+8t+k\\X_d=X_a+9t+k\end{cases}$$

那么我们只需要循环 $X_a,t,k$ 就行了。

时间复杂度：比 $O(n^3)$ 低。预计得分 85 分。

伪代码：

```cpp
for(int a=1; a<=n; a++) {
	if(bb[a]) {
		for(int t=1; 9*t+a+1<=n; t++) { //防止越界
			if(bb[a+2*t]) {
				for(int k=1; k+9*t+a<=n; k++) {
					int b=a+2*t;
					int c=a+8*t+k;
					int d=a+9*t+k;
					ans[a][1]+=bb[b]*bb[c]*bb[d]; //乘法原理
					ans[b][2]+=bb[a]*bb[c]*bb[d];
					ans[c][3]+=bb[a]*bb[b]*bb[d];
					ans[d][4]+=bb[a]*bb[b]*bb[c];
				}
			}
		}
	}
}
```

## 100pts 做法

为了达到满分，我们需要再压循环。

题目中要我们求总的方案数，那我们求出它的最优解再加上，我们其实就算出总方案了。那什么时候最优呢？

这里我们把上面的三个式子转化成一根数轴：

![](https://cdn.luogu.com.cn/upload/image_hosting/98og1u0o.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

那么只要我们让这根数轴上同一个点能出现尽可能多次，那么我们就找到了最优解，那要让一个点出现尽可能多次，我们就需要让两个点的距离尽可能近，而 $t$ 的系数太大了，我们不好确定，那我们就可以确定 $k$ 的值，同时我们又要让 $6t+k=X_c-X_b$ 这个式子成立，所以 $k$ 最小可以取 $1$。

在 $k=1$ 这个条件下，我们再来算 $X_a,X_b,X_c,X_d$ 的值就简单多了。

我们前面说过：我们要把最优解加在一起，这里只需要先枚举 $X_d$，再枚举 $X_a$ 就行了，同时一个正序，一个倒序，至于具体原因各位可以参考[这篇题解](https://www.cnblogs.com/henry-1202/p/9403914.html)。

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x[40006],b[40006],num[6][40006];
signed main() {
	cin>>n>>m;
	for(int i=1; i<=m; i++) {
		cin>>x[i];
		b[x[i]]++;
	}
	for(int t=1; 9*t+1<=n; t++) {
		int sum=0;
		for(int D=9*t+2; D<=n; D++) {
			int A=D-9*t-1;
			int B=D-7*t-1;
			int C=D-t;
			sum+=b[A]*b[B];
			num[3][C]+=sum*b[D];
			num[4][D]+=sum*b[C];
		}
		sum=0;
		for(int A=n-9*t-1; A>=1; A--) {
			int B=A+2*t;
			int C=A+8*t+1;
			int D=A+9*t+1;
			sum+=b[C]*b[D];
			num[1][A]+=sum*b[B];
			num[2][B]+=sum*b[A];
		}
	}
	for(int i=1; i<=m; i++) {
		for(int j=1; j<=4; j++) {
			cout<<num[j][x[i]]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：zhuangjinning (赞：1)

## 分析

![](https://cdn.luogu.com.cn/upload/image_hosting/dewfetkf.png)

设 $X_d-X_c=t$，根据题意，则 $X_b-X_a=2t$，$X_c-X_b=6t+k\ (k \ge 1)$。

## 解题思路

统计一个 $cnt$ 数组表示每个数都出现了几次。

**以下操作都是在值域上进行的**

枚举 $t$，对于每个 $t$ 都开一个 $l$ 数组，$l_{i}$ 表示在 $i$ 及以前有多少对合规的 $A$、$B$。开一个 $r$ 数组，$r_i$ 表示在 $i$ 及之后有多少对合规的 $C$、$D$。

计算即可。
时间复杂度小于 $O(n^{2})$。本题的数据范围可以通过。

## AC 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
ll m;
ll x[40002];
ll cnt[15002];
ll left1[40002];
ll right1[40002];
ll ans[15002][4];
int main(){
	cin>>n>>m;//读入
	for(int i=1;i<=m;i++){
		cin>>x[i];
		cnt[x[i]]++;
	}//读入
	for(int t=1;t*9<n;t++){//枚举t
		memset(left1,0,sizeof left1);//养成好习惯，一定要清空
		memset(right1,0,sizeof right1);//养成好习惯，一定要清空
		for(int i=2*t+1;i<=n;i++){
			left1[i]=left1[i-1]+cnt[i]*cnt[i-2*t];//l数组
		}
		for(int i=n-t;i>=1;i--){
			right1[i]=right1[i+1]+cnt[i]*cnt[i+t];//r数组
		}
//计算
		for(int i=1;i<=n;i++){
			if(i+8*t+1<=n){
				ans[i][0]+=cnt[i+2*t]*right1[i+8*t+1];
			}
			if(i-2*t>=1 and i+6*t+1<=n){
				ans[i][1]+=cnt[i-2*t]*right1[i+6*t+1];
			}
			if(i+t<=n and i-6*t-1>=1){
				ans[i][2]+=cnt[i+t]*left1[i-6*t-1];
			}
			if(i-t*7-1>=1){
				ans[i][3]+=cnt[i-t]*left1[i-7*t-1];
			}
		}
	}
//输出
	for(int i=1;i<=m;i++){
		for(int j=0;j<=3;j++){
			cout<<ans[x[i]][j]<<" ";
		}
		cout<<'\n';
	}
	return 0;
}

```

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18876653)

数学推导加暴力统计。

注意到 $m$ 比 $n$ 大，于是先把所有数装进值域为 $[1,n]$ 的桶里。

首先这两个式子显然不太好做，于是先来推一波式子：

$$\begin{equation}\begin{aligned}b-a&<\frac{c-b}{3}\\4b-3a&<c\\b+3(b-a)&<c\end{aligned}\end{equation}$$

因为 $b-a=2(d-c)$，于是考虑**枚举 $b-a$ 的值**，这样 $d-c$ 的值也能确定了。

接下来就是容易的了，考虑继续枚举 $b$，进而能直接求出 $a$ 的值与 $c$ 的下界，而当 $d-c$ 为定值且 $c$ 要满足大于某个值的情况是好做的，直接在确定 $d-c$ 之后跑**后缀和**即可。由此就可以在枚举 $b$ 后快速统计 $a,b$ 的方案数，**乘法原理**乘起来即可。

$c,d$ 的方案数也是同理，此处不再赘述。

时间复杂度 $O(n^2)$，实际跑不满。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=40005,V=15005;
int n,m,a[N],tot[V],ansa[N],ansb[N],ansc[N],ansd[N],pre[V],suf[V];
void solve(int cz)
{
    int hcz=cz/2;
    memset(pre,0,sizeof(pre));
    memset(suf,0,sizeof(suf));
    for(int i=1;i<=n;i++)
    {
        pre[i]=pre[i-1];
        if(i-cz>0)pre[i]+=tot[i]*tot[i-cz];
    }
    for(int c=n;c>=1;c--)
    {
        int mxb=c-3*cz-1;
        if(mxb<=0)break;
        if(c+hcz<=n&&tot[c]&&tot[c+hcz])
        {
            ansc[c]+=pre[mxb]*tot[c+hcz];
            ansd[c+hcz]+=pre[mxb]*tot[c];
        }
    }
    for(int i=n;i>=1;i--)
    {
        suf[i]=suf[i+1];
        if(i+hcz<=n)suf[i]+=tot[i]*tot[i+hcz];
    }
    for(int b=1;b<=n;b++)
    {
        int mnc=b+3*cz+1;
        if(mnc>n)break;
        if(b-cz>=1&&tot[b]&&tot[b-cz])
        {
            ansa[b-cz]+=suf[mnc]*tot[b];
            ansb[b]+=suf[mnc]*tot[b-cz];
        }
    }
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i];
        tot[a[i]]++;
    }
    for(int cz=2;cz<=n;cz+=2)solve(cz);
    for(int i=1;i<=m;i++)
        cout<<ansa[a[i]]<<" "<<ansb[a[i]]<<" "<<ansc[a[i]]<<" "<<ansd[a[i]]<<'\n';
    return 0;
}
```

---

## 作者：xy_mc (赞：1)

这道题很容易想到 $O(n^4)$ 和 $O(n^3)$ 的做法，但是太慢了，就数据而言，最多最多也要 $O(n^2)$ 的做法。那么正解怎么做呢？

### 正解：

前面超时的两种方法都是枚举 $A$ 物品或 $B$ 物品或 $C$ 物品或 $D$ 物品，既然枚举这些不行，便可以更换枚举对象。通过观察 $X_b-x_a=2(X_d-X_c)$ 和 $6(X_d-X_c) < X_c-X_b$（本式稍作修改，请读者自行补充过程），发现：$X_d-X_c$ 是式子中最小的一部分，那我们不妨使用换元法，将其换为字母 $t$，那么式子各部分就变成了：

$$ X_d-X_c=t$$

$$ X_b-X_a=2t$$

$$ X_c-X_b > 6t$$

根据 $X_a < X_b <X_c<X_d$，我们可以将其整理到数轴上，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xxpqqqe6.png)

由于 $ X_c-X_b > 6t$，所以对于一对固定的 $a$ 点和 $b$ 点，$c$ 点右侧的所有的 $c$ 点和 $d$ 点显然都是符合条件的，同理，若有固定的的 $c$ 点和 $d$ 点，$b$ 点左侧所有的 $a$ 点和 $b$ 点也是都符合条件的。

若每个点都代表一个数，这个数出现了若干次，根据乘法原理，可知：

![](https://cdn.luogu.com.cn/upload/image_hosting/vec3lfo1.png)

题目让我们求某个数作为某个物品出现了多少次，我们不妨先求出合法的 $c$ 和 $d$，$a$ 和 $b$ 有多少对。这时就可以对 $c$ 和 $d$ 作后缀和，$a$ 和 $b$ 作前缀和。

这时便可知某个数作为某个物品出现了多少次了，为什么呢？假设我们要知道 $p$ 作为 $A$ 物品出现了多少次，通过 $p$ 可以算出 $B$ 物品所代表的数是几，通过 $B$ 又可以算出最小的 $C$ 和 $D$，已经统计后缀和，根据乘法原理可得：

$p$ 作为 $A$ 物品出现的次数 $=$ $B$ 物品所代表的数出现的次数 $\times$ 到 $C$ 为止合法的 $(C,D)$ 的数量。

其余同理。用数组记录下来即可。

### code：

```cpp
#include<bits/stdc++.h>
#define inl inline
#define rep(i,x,y) for(int i=x;i<=(y);++i)
#define per(i,x,y) for(int i=x;i>=(y);--i)
#define fst ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
typedef long long ll;
using namespace std;
const int INF=INT_MAX;
const int N=1.5e4+10,M=4e4+10;
int n,m,s[M],t[N];
int a[M],b[M],c[M],d[M],sumb[M],sumc[M];
int main(){
	fst;
	cin>>n>>m;
	rep(i,1,m){
		cin>>s[i];
		t[s[i]]++;  //统计出现次数可以用桶。
	}
	for(int i=1;9*i<=n;i++){   //请仔细思考一下枚举边界以及数组的下标，不做解释。
		memset(sumc,0,sizeof(sumc));
		memset(sumb,0,sizeof(sumb));
		for(int xc=n-i;xc>8*i;xc--){
            int xd=xc+i;
			sumc[xc]=sumc[xc+1]+t[xc]*t[xd];
		}
		for(int xb=2*i;xb<n-7*i;xb++){
            int xa=xb-2*i;
			sumb[xb]=sumb[xb-1]+t[xb]*t[xa];
		}
		for(int xa=1;xa<n-8*i;xa++){
            int xb=xa+2*i,xc=xa+8*i+1;
			a[xa]+=t[xb]*sumc[xc];
			b[xb]+=t[xa]*sumc[xc];
		}
		for(int xd=n;xd>1+7*i;xd--){
            int xc=xd-i,xb=xd-7*i-1;
			d[xd]+=t[xc]*sumb[xb];
			c[xc]+=t[xd]*sumb[xb];
		}
	}
	rep(i,1,m){
		cout<<a[s[i]]<<" "<<b[s[i]]<<" "<<c[s[i]]<<" "<<d[s[i]]<<"\n";
	}
	return 0;
}
```

建议多看几遍，自己画一画图理解一下，主播调的时候也是被循环边界和数组下标折磨了好长时间 QwQ。不得不说，这是一道好~~毒瘤~~题。

---

## 作者：uncle_steve (赞：0)

### 算法知识点：前缀和，数学，组合计数，乘法原理，加法原理。

复杂度：$O(n^2)$。

## 解题思路：

一个魔法阵如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/gsv3j5wy.png)

$A$ 和 $B$ 之间的距离是 $2t$，$B$ 和 $C$ 之间的距离是 $6t+k$，$C$ 和 $D$ 之间的距离是 $t$，其中 $t$，$k$ 均为正整数。

左边红色部分框出的 $A$ 和 $B$ 是绑定的，右边绿色部分框出的 $C$ 和 $D$ 也是绑定的。

因此整个系统共有三个自由度：$t$、红色部分、绿色部分。

同时枚举三个自由度的计算量过大。在 1 秒内，我们只能枚举其中两个自由度。

首先枚举 $t$。接下来并列枚举绿色部分和红色部分：

- 从左到右枚举绿色部分，当绿色部分固定后，则 $C$ 应该累加的次数是所有满足要求的 $A$ 和 $B$ 的 $cnt[A]\times cnt[B]$ 的和，再乘以 $cnt[D]$。其中 $cnt[A]$，$cnt[B]$，$cnt[D]$ 是 $A$，$B$，$D$ 出现的次数。所有满足要求的 $A$ 和 $B$ 就是整个线段左边的某个前缀，因此可以利用来加速计算。$cnt[D]$ 同理可得。
- 从右到左枚举红色部分可做类似处理。

## 代码：


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15010, M = 40010;

int n, m;
int cnt[N];
int a[N], b[N], c[N], d[N], x[M];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i ++ )
    {
        scanf("%d", &x[i]);
        cnt[x[i]] ++ ;
    }

    for (int t = 1; t * 9 + 2 <= n; t ++ )
    {
        int sum = 0;
        for (int D = t * 9 + 2; D <= n; D ++ )
        {
            int A = D - t * 9 - 1;
            int B = A + t * 2;
            int C = D - t;
            sum += cnt[A] * cnt[B];
            c[C] += sum * cnt[D];
            d[D] += sum * cnt[C];
        }
        sum = 0;
        for (int A = n - t * 9 - 1; A; A -- )
        {
            int B = A + t * 2;
            int D = A + t * 9 + 1;
            int C = D - t;
            sum += cnt[C] * cnt[D];
            a[A] += sum * cnt[B];
            b[B] += sum * cnt[A];
        }
    }

    for (int i = 1; i <= m; i ++ ) printf("%d %d %d %d\n", a[x[i]], b[x[i]], c[x[i]], d[x[i]]);
    return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P2119)

---

# 思路：

这题用暴力特别好写。但时间复杂度会炸。所以我们要考虑优化。

首先，想想 $n$ 是干什么的？我们可以用桶排。用 $d_i$ 记录 $i$ 魔法值为 $i$ 的物品个数。

然后，再考虑一下解法：先看下图：
 ![](https://cdn.luogu.com.cn/upload/image_hosting/h2ez7e20.png)
当 $d-c$ 等于 $t$ 时，各点之间的距离就如上图。

所以，确定 $d$ 的位置后，$c$ 的位置也就确定了。

而对于一对确定的 $c,d$，能够于它们组成魔法阵的 $a,b$ 的组数为 $\sum_{i=1}^{n} d_{a_i}\times d_{b_i}$（$a_i,b_i$ 为满足条件的魔法值）。

因此，我们还能用前缀和优化。因为当 $t$ 一定时，若一对 $(a,b)$ 满足条件，则 $a,b$ 之前的所有差值为 $2\times t$ 的魔法值都一定满足条件。

最后，$c$ 的组数就等于 $a,b$ 的组数乘魔法值为 $d$ 的物品个数（$d$ 也一样）。

于是我们枚举 $d$ 的值，再一边递推就行了。

最后，同理，枚举 $a$ 的位置，计算满足条件的 $c,d$ 组数，就可以过了。（注意，$a$ 要倒着枚举，因为 $c,d$ 是从后往前递推的）

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
int n,m,A[N],B[N],C[N],D[N],magic[N],h[N];
vector<int> magic2;
signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>magic[i];
        h[magic[i]]++;
    }
    for(int i=1;i<=N;i++){
        if(h[i]>0){
            magic2.push_back(i);
        }
    }
    for(int t=1;9*t+2<=n;t++){
        int sum_ab=0;
        for(int Xd=9*t+1;Xd<=n;Xd++){
            int Xa=Xd-9*t-1,Xb=Xa+2*t,Xc=Xd-t;
            sum_ab+=h[Xa]*h[Xb];
            C[Xc]+=h[Xd]*sum_ab;
            D[Xd]+=h[Xc]*sum_ab;
        }
        int sum_dc=0;
        for(int Xa=n-9*t-1;Xa>=1;Xa--){
            int Xb=Xa+t*2,Xd=Xa+9*t+1,Xc=Xd-t;
            sum_dc+=h[Xc]*h[Xd];
            A[Xa]+=sum_dc*h[Xb];
            B[Xb]+=sum_dc*h[Xa];
        }
    }
    for(int i=1;i<=m;i++){
        cout<<A[magic[i]]<<" "<<B[magic[i]]<<" "<<C[magic[i]]<<" "<<D[magic[i]]<<endl;
    }
    return 0;
}
```
完结撒花~

---

## 作者：patrickwen (赞：0)

### 题意：

有  $𝑚$  个物品，每个物品有一个魔法值  $𝑋_𝑖$  。当且仅当四个魔法物品  $𝑎, 𝑏, 𝑐, 𝑑$  满足  $𝑋_𝑎 < 𝑋_𝑏 < 𝑋_𝑐 < 𝑋_𝑑$ , 并且 $ 𝑋_𝑏 − 𝑋_𝑎 = 2(𝑋_𝑑 − 𝑋_𝑐)$，$ 𝑋_𝑏 −𝑋_𝑎 < (𝑋_𝑐 − 𝑋_𝑏) /3$ 时称这四个魔法物品形成了一个魔法阵。现在，大魔法师想要知道，对于每个魔法物品，作为某个魔法阵的  $𝐴$  物品出现的次数，作为  $𝐵$  物品的次数，作为  $𝐶$  物品的次数，和作为  $𝐷$  物品的次数。


### 解法：

• 直接考虑 $ 𝑂(𝑁^4)$  暴力枚举四个物品，可以获得  45~55  分。

• 考虑优化枚举。通常我们都会尝试将限制融入枚举过程中，以减少复杂度。此处我们注意到  $𝑋_𝑏 − 𝑋_𝑎 = 2(𝑋_d − 𝑋_𝑐)$  的限制，我们记 $ 𝑡 = (𝑋_𝑑 − 𝑋_𝑐) $ ，则有  $𝑋_𝑏 − 𝑋_𝑎 = 2𝑡$  ，于是只需枚举 $𝑋_𝑎 , 𝑋_𝑐,𝑡 $ 即可，复杂度 $ 𝑂(𝑁^3)$。

• 更进一步的，由   $𝑋_𝑏 − 𝑋_𝑎 <\displaystyle \frac{𝑋_𝑐−𝑋_𝑏  }{3}$ 得  $𝑋_𝑐 − 𝑋_𝑏 > 6𝑡$ 。于是，我们发现对于一对固定的  $𝑋_𝑎$  与  $𝑡$  ，能确定 $𝑋_𝑐 − 𝑋_𝑑 = t$  且  $𝑋_𝑐 >𝑋_𝑎 + 8𝑡$  ，这样我们先枚举 $ 𝑡$  ，便可从后往前累计每对  $𝑋_𝑐, 𝑋_𝑑$ 的贡献，从而计算每个数作为  $𝑋_𝑎, 𝑋_𝑏$  的出现次数，反之同理。时间复杂度 $𝑂(𝑁^2)$ 。

### 代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
	ll n,m,cnt[50000],ans[50000][4],x[50000];
	cin>>n>>m;
	for(ll i=1;i<=m;i++){
		cin>>x[i];
		cnt[x[i]]++;
	}
	for(ll t=1;9*t<=n;t++){
		ll a,b,c,d,res=0;
		for(a=n-9*t-1;a>=1;a--){
			b=a+2*t,c=b+6*t+1,d=c+t;
			res+=cnt[c]*cnt[d];
 			ans[a][0]+=cnt[b]*res;
 			ans[b][1]+=cnt[a]*res;
		}
		res=0;
		for(d=9*t+2;d<=n;d++){
			a=d-9*t-1;b=a+2*t;c=d-t;
			res+=cnt[a]*cnt[b];
 			ans[c][2]+=cnt[d]*res;
 			ans[d][3]+=cnt[c]*res;
		}
	}
	for(ll i=1;i<=m;i++){
		for(ll j=0;j<=3;j++){
			cout<<ans[x[i]][j]<<" ";
		}
		cout<<endl;
	}
}
```

--思路借鉴于洛谷网校基础衔接提高计划吾王美如画老师

---

## 作者：hnczy (赞：0)

经过观察很容易想出 $O(m^4)$ 的方法：进行排序再枚举，获得 `65pts`。

他给了你这几个数的数据范围 $n$，且 $n$ 较小，尝试使用计数。

当然可以进行优化，由题设 $d-c=len,b-a=2 \times len,c-b>6\times len$。

$ \because len \in\mathbb{Z},\therefore (b-a) |2 $。

所以我们可以写出终极暴力的代码：
```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[100005][5],x[100005],cnt[100005];
int main(){
	freopen("magic.in","r",stdin);
	freopen("magic.out","w",stdout);
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x[i]);
		cnt[x[i]]++;
	}
	for(int a=1;a<=n;a++){
		if(!cnt[a])continue;
		for(int b=a+2;b<=n;b+=2){
			if(!cnt[b])continue;
			int len=(b-a)/2;
			for(int c=b+6*len+1;c<=m-len;c++){
				int d=c+len;
				if(!cnt[d]||!cnt[c])continue;
				ans[a][1]+=cnt[b]*cnt[c]*cnt[d];
				ans[b][2]+=cnt[a]*cnt[c]*cnt[d];
				ans[c][3]+=cnt[a]*cnt[b]*cnt[d];
				ans[d][4]+=cnt[a]*cnt[b]*cnt[c];
			}
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d %d %d %d\n",ans[x[i]][1],ans[x[i]][2],ans[x[i]][3],ans[x[i]][4]);
	return 0;
}
```
时间复杂度 $O(m^3)$ （喜提`90pts`）。

当然这肯定不是正解，（不然这题还是绿题？）

换一个思路：假设固定 $a$，$b$，那么类似一个滑动的区间，$a$ 越大那么 $c$ 的取值越小。

那么是不是可以使 $a$ 从最大开始枚举，维护一个后缀和？

答案是肯定的，用代码实现：
```c++
int sum=0;
		for(int a=m-9*len-1;a>=1;a--){//处理c d,的后缀和 
			int b=a+2*len,c=b+6*len+1,d=c+len;
			sum+=cnt[c]*cnt[d];
			ans[a][1]+=cnt[b]*sum;
			ans[b][2]+=cnt[a]*sum;
		}
```

聪明的你可能会问：哎，那 $3$，$4$ 的 $ans$ 怎么办呢？

其实很简单，你用 $a$ 维护一个后缀和，那你能否用 $c$ 维护一个前缀和不就行了？

附代码：

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,ans[100005][5],x[100005],cnt[100005];
int main(){
	freopen("magic.in","r",stdin);
	freopen("magic.out","w",stdout);
	scanf("%d%d",&m,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x[i]);
		cnt[x[i]]++;
	}
	for(int len=1;len*9<m;len++){
		int sum=0;
		for(int a=m-9*len-1;a>=1;a--){//处理c d,的后缀和 
			int b=a+2*len,c=b+6*len+1,d=c+len;
			sum+=cnt[c]*cnt[d];
			ans[a][1]+=cnt[b]*sum;
			ans[b][2]+=cnt[a]*sum;
		}
		sum=0;
		for(int c=2+8*len;c<=m-len;c++){//反之，处理a,b的前缀和 
			int b=c-6*len-1,d=c+len,a=b-2*len;
			sum+=cnt[a]*cnt[b];
			ans[c][3]+=cnt[d]*sum;
			ans[d][4]+=cnt[c]*sum;
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d %d %d %d\n",ans[x[i]][1],ans[x[i]][2],ans[x[i]][3],ans[x[i]][4]);
	return 0;
}
```

---


# [NOI2015] 荷马史诗

## 题目背景

> 追逐影子的人，自己就是影子 —— 荷马

## 题目描述

Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》 组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。

一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_i$。Allison 想要用 $k$ 进制串 $s_i$ 来替换第 $i$ 种单词，使得其满足如下要求：

对于任意的 $1\leq i, j\leq n$ ，$i\ne j$ ，都有：$s_i$ 不是 $s_j$ 的前缀。

现在 Allison 想要知道，如何选择 $s_i$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_i$ 的最短长度是多少？

一个字符串被称为 $k$ 进制字符串，当且仅当它的每个字符是 $0$ 到 $k-1$ 之间（包括 $0$ 和 $k-1$ ）的整数。

字符串 $str1$ 被称为字符串 $str2$ 的前缀，当且仅当：存在 $1 \leq t\leq m$ ，使得 $str1 = str2[1..t]$。其中，$m$ 是字符串 $str2$ 的长度，$str2[1..t]$ 表示 $str2$ 的前 $t$ 个字符组成的字符串。

## 说明/提示

#### 【样例解释】

#### 样例 1 解释

用 $X(k)$ 表示 $X$ 是以 $k$ 进制表示的字符串。

一种最优方案：令 $00(2)$ 替换第 $1$ 种单词， $01(2)$ 替换第 2 种单词， $10(2)$ 替换第 $3$ 种单词，$11(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 2 + 1 × 2 + 2 × 2 + 2 × 2 = 12$

最长字符串 $s_i$ 的长度为 $2$ 。

一种非最优方案：令 $000(2)$ 替换第 $1$ 种单词，$001(2)$ 替换第 $2$ 种单词，$01(2)$ 替换第 $3$ 种单词，$1(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 3 + 1 × 3 + 2 × 2 + 2 × 1 = 12$

最长字符串 $s_i$ 的长度为 $3$ 。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。

#### 样例 2 解释

一种最优方案：令 $000(3)$ 替换第 $1$ 种单词，$001(3)$ 替换第 $2$ 种单词，$01(3)$ 替换第 $3$ 种单词， $02(3)$ 替换第 $4$ 种单词， $1(3)$ 替换第 5 种单词， $2(3)$ 替换第 $6$ 种单词。

#### 【数据规模与约定】

所有测试数据的范围和特点如下表所示（所有数据均满足 $0 < w_i \leq 10^{11}$）：

| 测试点编号 |  $n$ 的规模  | $k$ 的规模 |            备注            |
| :--------: | :----------: | :--------: | :------------------------: |
|    $1$     |    $n=3$     |   $k=2$    |                            |
|    $2$     |    $n=5$     |   $k=2$    |                            |
|    $3$     |    $n=16$    |   $k=2$    |     所有 $w_i$ 均相等      |
|    $4$     |  $n=1\,000$  |   $k=2$    | $w_i$ 在取值范围内均匀随机 |
|    $5$     |  $n=1\,000$  |   $k=2$    |                            |
|    $6$     | $n=100\,000$ |   $k=2$    |                            |
|    $7$     | $n=100\,000$ |   $k=2$    |     所有 $w_i$ 均相等      |
|    $8$     | $n=100\,000$ |   $k=2$    |                            |
|    $9$     |    $n=7$     |   $k=3$    |                            |
|    $10$    |    $n=16$    |   $k=3$    |     所有 $w_i$ 均相等      |
|    $11$    |  $n=1\,001$  |   $k=3$    |     所有 $w_i$ 均相等      |
|    $12$    | $n=99\,999$  |   $k=4$    |     所有 $w_i$ 均相等      |
|    $13$    | $n=100\,000$ |   $k=4$    |                            |
|    $14$    | $n=100\,000$ |   $k=4$    |                            |
|    $15$    |  $n=1\,000$  |   $k=5$    |                            |
|    $16$    | $n=100\,000$ |   $k=7$    | $w_i$ 在取值范围内均匀随机 |
|    $17$    | $n=100\,000$ |   $k=7$    |                            |
|    $18$    | $n=100\,000$ |   $k=8$    | $w_i$ 在取值范围内均匀随机 |
|    $19$    | $n=100\,000$ |   $k=9$    |                            |
|    $20$    | $n=100\,000$ |   $k=9$    |                            |

#### 【提示】

选手请注意使用 64 位整数进行输入输出、存储和计算。

#### 【评分方式】

对于每个测试点：

- 若输出文件的第 $1$ 行正确，得到该测试点 $40\%$ 的分数；
- 若输出文件完全正确，得到该测试点 $100\%$ 的分数。

## 样例 #1

### 输入

```
4 2
1
1
2
2
```

### 输出

```
12
2```

## 样例 #2

### 输入

```
6 3
1
1
3
3
9
9
```

### 输出

```
36
3
```

# 题解

## 作者：_Sein (赞：175)

### 此题本体为Huffman树  
   （下文均将huffman树讲为哈夫曼树）
- 哈夫曼树的定义
	
   哈夫曼树：带权路径长度WPL最短的多叉树（最优多叉树）构造这种树的算法最早是由哈夫曼(Huffman)1952年提出，这种树在信息检索中很有用。
   
  下面以二叉哈夫曼树为例
  给n个点，每个点都有权值，构造一棵哈夫曼树。每次选剩下的两棵根权值最小的树合并成一棵新树，新树的根权值等于两棵合并前树的根权值和。（一开始一个点也看成一棵树，只不过这棵树没有孩子节点）
  
	例1：4个点，a、b、c、d，权值分别为7、5、2、4。
	
    构树过程：因为4个点，所以合并3次（n个点，合并n-1次）
    
    第一步：选根权值最小的两棵树2（c）和4（d）合并，新树的根节点为6，如图(b)；
    
    第二步：选根权值最小的两棵树5（b）和6合并，新树的根节点为11，如图(c)；
    
    第三步：选根权值最小的两棵树7（a）和11合并，新树的根节点为18，如图(d)；
    
    
   ![例一](https://cdn.luogu.com.cn/upload/pic/47027.png)
   - 基本概念
    
    树的路径长度PL：从树根到树的每个节点的路径长度（每条边长度为1）之和（完全二叉树为这种路径长度最短的二叉树）。
    
   	树的带权路径长度WPL：树的所有叶子节点的带权路径长度（该节点到根节点路径长度与节点上权的乘积）之和。

	透彻理解树的路径长度和树的带权路径长度这两个概念非常重要。
   - 关于k叉哈夫曼树
   
   	以下选自lyd大佬的话：
    
    对于k叉哈夫曼树的求解,直观的想法是在贪心的基础上,改为每次从堆中去除最小的k个权值合并。然而，仔细思考可以发现，如果在执行最后一次循环时，堆的大小在（2~k-1）之间（不足以取出k个），那么整个哈夫曼树的根的子节点个数就小于k。这显然不是最优解————我们任意取哈夫曼树中一个深度最大的节点，改为树根的子节点，就会使$∑w_i*l_i$变小。
   
   因此，我们应该在执行上述贪心算法之前，补加一些额外的权值为0的叶子节点，使叶子节点的个树满足(n-1)%(k-1)=0。
   
   
    ![例二](https://cdn.luogu.com.cn/upload/pic/47030.png)
   - 重中之重：哈夫曼编码
   
   哈夫曼编码原则： n个节点的哈夫曼树含有2n-1个节点，没有度为1的节点 编码从叶子节点到根节点，译码从根节点到叶子节点。

	从哈夫曼树根节点开始，对左子树分配码“0”，右子树分配码“1”，一直到达叶子节点为止，然后将从树根沿每条路径到达叶子结点的代码排列起来，便得到了哈夫曼编码。
    
    例子
    
    一篇电文，原文为：AMCADEDDMCCAD。现在要把原文转换成01串发送给对方。为了节省资源，我们当然希望翻译好的01串长度尽量的短。怎么办？
    
	研究发现：1、只有5个字母E,M,C,A,D； 2、这5个字母的使用频度分别为｛E,M,C,A,D｝= ｛1,2,3,3,4｝。
	用频度为权值生成哈夫曼树，并在叶子上标注对应的字母，在树枝上标注分配码“0”或“1”（注：分配码不是边的长度，而是区分左右孩子代表方向）:

	![](https://cdn.luogu.com.cn/upload/pic/47029.png)
    ![](https://cdn.luogu.com.cn/upload/pic/47031.png)
    
    各字母的编码即为哈夫曼编码： EMCAD 所有编码长度和为12位，即PL=12，此时的PL并不是最小的，但此时的WPL一定是最小的。WPL最小才能使得密报翻译的01串长度最短。
    
   - 回归本体
    
    本题所构造的编码其实就是huffman编码（~~这还用说吗~~），我们可以把单词的次数作为哈夫曼树叶子节点的权值，求出k叉哈夫曼树就行了。
    答案就为所有叶子节点的wpl，最深叶子节点的深度了
   - 代码
```
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define ll long long
using namespace std;
struct node
{
    ll w,h;
    node(){w=0,h=0;}
    node(ll w,ll h):w(w),h(h){}
    bool operator <(const node &a)const{return a.w==w?h>a.h:w>a.w;}
};
ll ans;
priority_queue<node>q;
int main()
{
    ll n,k;ans=0;scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++)
    {
        ll w;scanf("%lld",&w);
        q.push(node(w,1));
    }
    while((q.size()-1)%(k-1)!=0)q.push(node(0,1));
    while(q.size()>=k)
    {
        ll h=-1;ll w=0;
        for(int i=1;i<=k;++i)
        {
            node t=q.top();q.pop();
            h=max(h,t.h);
            w+=t.w;
        }
        ans+=w;
        q.push(node(w,h+1));
    }
    printf("%lld\n%lld\n",ans,q.top().h-1);
    return 0;
}
   ```
    
    
   
    
    


---

## 作者：crazydave (赞：78)


# 思路

首先介绍一下哈夫曼树，哈夫曼树也叫最优二叉树，是一种带权路径（叶子节点权值乘该节点到根节点路径长度）之和最短的二叉树。通过哈夫曼树可以构造出哈夫曼编码，可以用于数据压缩和数据加密。


哈夫曼编码的原理是，利用哈夫曼树中权值越高（数据出现频率越高）的节点到根节点的距离越小（对应哈夫曼编码越短）的性质，将数据压缩成哈夫曼编码。正是由于每一个数据对应于树上的每一个叶子节点，而对应的编码为根到该叶子节点的路径，所以一串哈夫曼编码才能对应惟一的一串原码（即题目中所说si不是sj的前缀。），解码时才不会产生混淆。


依据题意和题目背景里面的一些暗示，思路可以明确，就是要求构造一个K进制的哈夫曼编码。平时我们所说的哈夫曼编码为2进制的，构造的方法也很容易（类似于NOIP2004 合并果子），本题也可以使用相同的思想。


首先明确需要维护什么。转换一下题意，不难知道我们需要维护的是最短的带权路径之和和该哈夫曼树的高度。然后便是如何维护，由于不需要知道哈夫曼树的具体形态，我们便可以按照哈夫曼树的构造方式，将当前最小的K个节点合并为1个父节点，直至只有一个父节点。看到“将最小K个节点合并”便可以明确使用优先队列（二叉堆）进行维护。


最后，我们需要注意一个细节。因为每次都是将k个节点合并为1个（减少k-1个），一共要将n个节点合并为1个，如果（n-1）%（k-1）！=0 则最后一次合并时不足k个。也就表明了最靠近根节点的位置反而没有被排满，因此我们需要加入k-1-（n-1）%（k-1）个空节点使每次合并都够k个节点（也就是利用空节点将其余的节点挤到更优的位置上）。

# 代码#


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <ext/pb_ds/priority_queue.hpp> //pb_ds库
#define LL long long 
using namespace std;
struct node{
    LL w,h;
    node(LL W, LL H){
        w=W,h=H;
    }
};
bool operator<(node a, node b){
    if(a.w!=b.w) return a.w>b.w; 
    return a.h>b.h;  //如果长度相等，高度小的优先
} //构造小根堆的操作。
__gnu_pbds::priority_queue <node, std::less<node>, __gnu_pbds::pairing_heap_tag> q; //优先队列
int n,k,cnt;
LL temp,maxh,ans;

int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1; i<=n; i++){
        scanf("%lld",&temp);
        q.push(node(temp,1));
    }
    if((n-1)%(k-1) != 0) cnt=k-1-(n-1)%(k-1);  //判断是否要补空节点
    for (int i=1; i<=cnt; i++)
        q.push(node(0,1)); //补空节点
    cnt+=n;     //cnt为根节点个数(最初每个根节点都为其本身）
    while(cnt>1){
        temp=maxh=0;
        for(int i=1; i<=k; i++){
            temp+=q.top().w;
            maxh=max(maxh,q.top().h);
            q.pop();
        }
        ans+=temp; //维护带权路径长度之和
        q.push(node(temp, maxh+1)); //合并，高度为最高子树高度+1
        cnt-=k-1; //减少根节点
    }
    printf("%lld\n%lld\n",ans,q.top().h-1);
    return 0;
}

```

---

## 作者：无咕_ (赞：64)

## 本题解引导
1. **题目大意**
2. $Solution$
3. $AC code$
4. **类似题型**

代码类型：$C++$

是否吸氧：否

不压行代码长度：36

------------

## 题目大意
题面：[<传送门>](https://www.luogu.com.cn/problem/P2168)

题意：给出$n$个值，并给出$k$，求编码后总长度及所有编码中最短k进制编码长度

~~术语理解：k叉Huffman板子~~

## $Solution$
不懂$Huffman$是什么的走这里[<传送门>](https://www.luogu.com.cn/blog/wugu-2333/shu-di-ji-ben-zhi-shi)

（接下来讲的传送门里都有，因为是板子题）

首先讲**数据结构**，因为$Huffman$每次合并都要排序，所以使用堆（直接用$priority$_$queue$更方便）。

再来讲$k$叉$Huffman$，及由两个分叉变为$k$个分叉（$k$叉树）。

但真正去跑的时候你才发现，最后一次合并之后，堆中剩下$m$个值。但如果$1<m<k$，即没有达到「堆中只剩一个值」却不能「合并」。

所以我们使用「补点」这个方法，以达到「堆中只剩一个值」这个目的。

介绍一下「补点」：首先，我们每次合并用掉$k$个值又合并出$1$个值，那么按每次合并来算，我们每次用掉了$k-1$个值。然后，我们最终需要只剩$1$个值，即需要合并$n-1$个值。那么我们只需要让$(n-1)$%$(k-1)=0$成立不就行了吗？但要使$(n-1)$%$(k-1)=0$成立，我们还需要补$(n-1)-((n-1)$%$(k-1))$个点（自己好好思考下为什么），但要使答案不受影响，我们就用权值为$0$的点来补。

下面针对每个问题讲解一下：

1. 
```
《荷马史诗》经过重新编码以后的最短长度。
```
全文的最短长度，那么不就是经过处理后的总和吗？也就是说我们把每个值都加一遍就是了。

2. 
```
为保证最短总长度的情况下，最长字符串s_i的最短长度。
```
这个更简单了，就是说经过处理后，每个值都跑一边找出最小值就是了。


## $AC code$
首先说下，具体的代码注释我都写在里面了。拒绝抄袭，从我做起（主要懂了就能写出来，没必要抄代码，不然还拿个棕名）

```cpp
#include<iostream>//标准输入输出流
#include<cstdio>//c语言标准输入输出
#include<cmath>//c数学运算
#include<cstring>//c语言字符串
#include<queue>//队列
using namespace std;//调用命名空间
typedef long long ll;//将"long long"用"ll"代替
struct Tree{//定义结构体"Tree"
    ll w,h;//注意是long long类型，第一个w表示权值，第二个h表示高度（也可以说是长度，因为一层就是一个字符长度）
    bool operator<(const Tree &x)const{//重载运算符
        if(w!=x.w)return w>x.w;//优先考虑权值大
        return h>x.h;//其次考虑长度
    }
};priority_queue<Tree>tree;//类型为"Tree"的优先队列"tree"
ll n,k,ans1=0,ans2,x;//单词数量、进制、答案1、答案2、替死鬼"x"（啥都干，无具体意义，但出于懒就定义了全局变量）
int main(){
    scanf("%lld %lld",&n,&k);//注意是"%lld"，以防RE
    for(int i=1;i<=n;i++){
        scanf("%lld",&x);//读入替死鬼（权值）
        tree.push((Tree){x,1});//默认高度为1（这里的强制类型转换有点麻烦）
    }if((n-1)%(k-1)){//先检测，如果不是0才进入判断
        x=k-1-(n-1)%(k-1);//求出要补的结点个数
        for(int i=1;i<=x;i++)tree.push((Tree){0,1});//「补点」操作
    }ll sumw,maxh;//ans1和ans2的临时值
    while(tree.size()!=1){//因为不可能是负数，所以只要大于1个点就跑
        sumw=0,maxh=-2147483647;//初始值要在循环定义
        for(int i=1;i<=k;i++){//每次选出k个值
            sumw+=tree.top().w;//取出队首加到总和里
            maxh=max(tree.top().h,maxh);//找最小长度
            tree.pop();//队头出队
        }tree.push((Tree){sumw,maxh+1});//加上合并的值，这里不直接用ans1、ans2的好处就体现出来了（加1是因为合并后的长度是要增加1的）
        ans1+=sumw;//然后才是存储数据
        ans2=max(maxh,ans2);//存储数据
    }printf("%lld\n%lld",ans1,ans2);//这时候一口气输出
    return 0;//好习惯养成
}
```
$AC$记录[<传送门>](https://www.luogu.com.cn/record/list?pid=P2168&user=359422)

## 类似题型
暂无，因为某谷中$Huffman$的题就很少，别说是$k$叉$Huffman$了。

---

## 作者：immortalCO (赞：29)

k叉哈夫曼树的构造模板题。

如果k=2，左转NOIP合并果子。堆维护即可。

如果k>2，当(n-1)%(k-1)!=0的时候会出现最后一次少于k个，通过增加w=0的单词解决。

为了最小化每个单词的长度，在struct里面不仅要记录当前的w，还要记录深度，并以他们作为小根堆的关键字即可。

每次取出堆头k个合并后加入即可。贪心思想想一想就明白了。


---

## 作者：devout (赞：13)

**description**

现在有一棵有 $n$ 个叶子节点 $k$ 叉树，每个叶子节点有一个权值 $s_i$，该节点到根的距离为 $l_i$，现在要最小化 $\sum s_il_i$

**solution**

一个 $k$ 叉哈夫曼树的板子题

显然我们要把权值大的尽量往上面放，把权值小的尽量往下面放。

所以我们可以用一个堆来维护，每次取出堆顶的 $k$ 个元素，求出他们的和 $sum$，累加到 $ans$ 中，然后再向堆中推入一个权值为 $sum$ 的数，以此类推。

但是这样会有一个问题，我们最后取到不足 $k$ 个的时候，我们的根节点的度数可能会不足 $k$，这个时候显然不优，因为我们希望上半部分的数尽量是满的。

解决方法是初始的时候往里面补 $0$

我们发现每次我们要把点的数量减少 $k-1$，一共要消掉 $n-1$ 个点，所以我们只需要补到 $n-1\bmod k-1=0$ 时即可

注意此题第二问要求最长的字符串尽量的短，所以我们应该记录每个点的深度，在权值相同的时候优先取出深度低的点。

```cpp
# include <bits/stdc++.h>

using namespace std;

# define Rep(i,a,b) for(register int i=a;i<=b;i++)
# define _Rep(i,a,b) for(register int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=3e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,k;
ll ans;

struct misaka{
	ll val;
	int dep;
	bool operator < (const misaka &cmp)const{
		if(val!=cmp.val)return val>cmp.val;
		return dep>cmp.dep;
	}
};

priority_queue<misaka> q;

int main()
{
	read(n),read(k);
	Rep(i,1,n){
		ll x;
		read(x);
		q.push((misaka){x,0});	
	}
	int qwq=(k-1-(n-1)%(k-1))%(k-1);
	Rep(i,1,qwq)q.push((misaka){0,0});
	while(q.size()>1){
		ll val_new=0;
		int dep_new=0;
		Rep(i,1,k){
			misaka u=q.top();q.pop();
			val_new+=u.val;
			dep_new=max(dep_new,u.dep);
		}
		ans+=val_new;
		q.push((misaka){val_new,dep_new+1});
	} 
	printf("%lld\n%d\n",ans,q.top().dep);
	return 0;
}
```


---

## 作者：Deny_小田 (赞：10)

好久没发题解了。


这题就是基本的huffman+堆，如果(n-1)是(k-1)的倍数，那么ok，我们可以合并，否则我们需要补充虚拟节点——权值为0的结点（对结果无影响），再进行合并即可。


···cpp








    
    
    
        


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long LL;
const int inf = 1 << 26;
struct trees {
    LL v, h;
};
bool operator<(trees a, trees b){
    if(a.v != b.v) return a.v > b.v;
    return a.h > b.h;    
}
priority_queue<trees> q;
int n, k;
int main(){
    scanf("%d %d", &n, &k);
    for ( int i = 1; i <= n; i ++ ) {
        trees a;
        scanf("%lld", &a.v);
        a.h = 1;
        q.push(a);
    }
    LL top = 0;
    if((n-1)%(k-1) != 0) top += k-1-(n-1)%(k-1);    // 需要补为 0 的结点的个数
    for ( int i = 1; i <= top; i ++ ) {
        trees need;
        need.v = 0; need.h = 1;
        q.push(need);
    } 
    top += n;
    LL ans = 0;
    while(top != 1) {
        trees a;
        LL temp = 0, mx = 0;
        for ( int i = 1; i <= k; i ++ ) {
            a = q.top(); temp += a.v;
            mx = max(mx, a.h); q.pop();
        }
        ans += temp;
        a.v = temp; a.h = mx+1;
        q.push(a);
        top -= k-1;
    }
    printf("%lld\n%lld\n", ans, q.top().h-1);
    return 0;
}
···
```

---

## 作者：落寞音箫 (赞：9)


##题解by：落寞音箫

##看到很多大佬都用优先队列啊，堆啊什么的，但是我有一个O（N）的算法。。。有一些局限的双队列。。。。

- 其实ylsoi[https://www.luogu.org/space/show?uid=20059]大佬早在7月就在合并果子里发了这种题的最优做法——双队列，但是似乎并没有引起什么关注，所以我现在看到这道题，就又想来发一发，介绍一下这种算法。

- 我们来看看这个算法：

---------------


```cpp
    For(i,1,top){
        c=0,maxx=0;
        For(j,1,k){
                if((a[nua].w<b[nub].w||a[nua].w==b[nub].w&&a[nua].h<=b[nub].h)&&a[nua].w!=-1||b[nub].w==-1){
                sum+=a[nua].w;
                maxx=Max(maxx,a[nua].h);
                c+=a[nua++].w;
            }
            else if((a[nua].w>b[nub].w||a[nua].w==b[nub].w&&a[nua].h>b[nub].h)&&b[nub].w!=-1||a[nua].w==-1){
                sum+=b[nub].w;
                maxx=Max(maxx,b[nub].h);
                c+=b[nub++].w;
            }
        }
        b[++note].w=c;
        b[note].h=maxx+1;
    }
```

-------------------------------

在这个代码块中，我用**nua**来存**原结构体a**进行到哪里了，用**nub**来存**合成的数的结构体b**进行到的位置。从1开始，进行top次（即Huffman树里要合并多少次），这样我们就可以跳出模拟题意的桎梏，通过这种方式保证找到最优解。

**那么为什么是这样呢？**

既然我们已经将a排过序了，那么是不是a是从大到小，从高价值到低价值以此排列的？既然如此，且合成的b是由a从前到后依次加上来的，那么b是不是也是递增的？解决了b为什么是单调递增的了吗？

那么a递增，b递增，为什么就可以用O（n）的时间合并呢？

在代码块中，只要**a【nua】**价值大于等于**b【nub】**或者没有**b【nub】**了，我们就加入它；只要**a【nua】**价值小于等于**b【nub】**或者没有**a【nua】**了，我们就加入它。

加完一轮后再加到**b结构体**里面。这样是不是就可以既保持跑的最优，又可以保证**b**始终单调递增。


--------------

##代码如下：（请务必观察前面的宏定义！）

```cpp
//这是代码
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define MAXN 100005
#define re register
#define ll long long
#define For(i,a,b) for(re ll i=a;i<=b;++i)
#define Max(a,b) ((a)>(b)?(a):(b))
#define Min(a,b) ((a)<(b)?(a):(b))
ll n,k,top;
ll nua=1,nub=1,sum;
struct node{
    ll w,h;//h计算已经加了多少次，其实a结构体始终是1
}a[MAXN],b[MAXN];//原结构体数组与合成的结构体数组
int cmp(node aa,node bb){
    if(aa.w<bb.w)return 1;
    if(aa.h<bb.h)return 1;
    return 0;
}//处理sort；
ll read(){
    ll x=0,f=1;char ch=getchar();
    for(;ch<48||ch>57;ch=getchar())if(ch=='-')f=-f;
    for(;ch>=48&&ch<=57;x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
    return x*f;
}
int main(){
    ll note=0;//note用于计算已经合成的结构体
    n=read(),k=read();
    For(i,1,n)a[i].w=read(),a[i].h=1;
    top=(n-1)%(k-1);//用来检测是否需要加入虚拟节点
    if(top)top=(k-1)-top;//如果要加的话，加多少
    For(i,1,top)a[++n].w=0,a[n].h=1;//加入节点
    sort(a+1,a+1+n,cmp);//排序
    a[n+1].w=-1;//把a结构体的最后一个标记为不能继续加
    For(i,1,n+1)b[i].w=-1;//先把b结构体都标记一下
    ll c=0,maxx=0;
    top=(n-1)/(k-1);//需要加入的次数
    For(i,1,top){
        c=0,maxx=0;//每次记录一下
        For(j,1,k){
            if((a[nua].w<b[nub].w||a[nua].w==b[nub].w&&a[nua].h<=b[nub].h)&&a[nua].w!=-1||b[nub].w==-1){//如果a结构体更优
                sum+=a[nua].w;
                maxx=Max(maxx,a[nua].h);//找加的次数最多的节点
                c+=a[nua++].w;
            }
            else if((a[nua].w>b[nub].w||a[nua].w==b[nub].w&&a[nua].h>b[nub].h)&&b[nub].w!=-1||a[nua].w==-1){//将上一个再判断一次
                sum+=b[nub].w;
                maxx=Max(maxx,b[nub].h);
                c+=b[nub++].w;
            }
        }
        b[++note].w=c;//合成的节点
        b[note].h=maxx+1;//已经又加过这一次了。
    }
    printf("%lld\n%lld",sum,b[note].h-1);//输出加过的sum与最多加过的次数。
    return 0;
}
```

---

## 作者：Sor4 (赞：8)

//此题是哈夫曼树模板，加上堆优化，然后其中注意记录每次的值和当前层数，有个小技巧，可以用pair+优先队列方便排序，比结构体加重载更加方便。


代码仅供参考。








    
```cpp
#include <cstdio>
#include <algorithm>
#include <utility>
#include <queue>
using namespace std;
typedef pair<long long,long long> aii;//定义pair，第一位放节点的值，第二位放它的层数 
priority_queue< aii,vector<aii>,greater<aii> > que;//小根堆，哈夫曼树从小到大合并 
int n,k,Num = 0;
long long  Length = 0,Ans = 0,x;//注意10^14要开long long 
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&x);
        que.push(aii(x,1));
```
}//初始时每个结点是第一层
    
if((n-1)%(k-1)!=0) Num=k-1-(n-1)%(k-1);//！！！注意，当结点不够时，插入值为零的虚节点，不然算出来可能不是最优解

    
        
    
        
        
```cpp
    for(int i=1;i<=Num;i++)
        que.push(aii(0,1));//插入虚节点 
    Num+=n;//Num代表一共有多少元素 
    while(Num!=1)//Num=1时，所有元素已经合并，退出 
    {
        aii a;
        long long Temp = 0,Max_h = 0;//Temp算合并后的值，Max_h代表最大层数 
        for(int i=1;i<=k;i++)
        {
            a = que.top();
            Temp+=a.first;
            Max_h=max(Max_h,a.second);
            que.pop(); 
```
}//将前k个元素合并
        
Ans+=Temp;//根据哈夫曼树的性质，易证最短长度是每次合并后的值之和

        
que.push(aii(Temp,Max\_h+1));//把合并后的元素放入，记得层数要加一

        
    
    
    
```cpp
        Num-=k;//少了k个 
        Num++;//多了一个 
    }
    Length = que.top().second - 1;//最长字串，有k层时第一层不算，第二层s=1，第三层s=2，第n层s=n-1 
    printf("%lld\n%lld",Ans,Length);//输出long long 
    return 0;
}
```

---

## 作者：TheShadow (赞：5)

# 闲扯

忘开 $long\ long$ 调了半天。。。

# 题面

[题面](https://www.luogu.org/problem/P2168)

# Solution

每一个单词的出现次数看做权值。

因为两个单词对应的字符串不能有包含，所以如果我们对所有的字符串建一颗 $Trie$ 树，那么每个字符串的结尾一定是位于叶节点的。

我们可以把每个单词的权值付给每一个对应的叶节点，那么问题就变成了：建立一颗 $Trie$ 树，最小化 $\sum val_i*l_i$ 。其中 $val$ 表示叶节点的权值， $l$ 表示单词长度（即在树中的深度）。

又因为是 $k$ 进制，所以我们建出的一定是一个 $k$ 叉树。

总结一下上面的转化，我们可以发现这道题就是要我们求一个 $k$ 叉的 $Huffman$ 树。

同时我们还要保证字符串的长度最大值最小，所以我们每次合并时，尽量选择长度短的来合并。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
ll n,k,sum,val,res,cnt;
struct Node{
	ll val,st;
	Node(){}
	Node(ll val,ll st):val(val),st(st){}
	bool operator <(const Node &t) const{
		return val==t.val?st>t.st:val>t.val;
	}
};
priority_queue<Node> q;
int main()
{
//	freopen("testdata.in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(k);
	for(ri i=1;i<=n;++i) read(val),q.push(Node(val,0));
	while((n-1)%(k-1)) q.push(Node(0,0)),++n;
	while(q.size()>=k){
		sum=0;rl s=0;
		for(ri i=1;i<=k;++i){
			Node tmp=q.top();q.pop();
			sum+=tmp.val,s=max(s,tmp.st);
		}
		res+=sum,q.push(Node(sum,s+1));
	}
	Node ans=q.top();
	print(res),puts(""),print(ans.st);
	return 0;
}
```

# 总结

很巧妙的一道题。

只要想到了问题转化，就变得很简单了。

---

## 作者：lindongli2004 (赞：2)

简化题意：

构造一棵包含n个叶子节点的 $k$ 叉树 , 第 $i$ 个叶子节点深度为 $dep[i]$ , 权值为 $w[i]$ 。

$1.$ 最小化 $\sum_{i=1}^n w[i] \times dep[i]$ .

$2.$ 在满足此条件下 , 最小化 $max_{i=1}^n{dep[i]}$ .

先来说明简化后的题意与原问题等价：设每个字母代表树中的一个结点，又因为每个单词都以一个叶子结束，所以保证了单词互不相同。

考虑条件$1$ , 满足此条件的树叫 **最优二叉树** , 别称 **Huffman** 树 。

先考虑 $k=2$ 的情况，我们可以贪心让权值小的叶子深度尽量大。

自下而上建树，具体步骤如下：

	    1. 将 n 个叶子节点插入一个小根堆。
    
        2. 取出2个权值最小的叶子 a, b ，新建一个结点 c ，则：
           - c为Huffman树上点a,b的父亲
           - w[c]=w[a]+w[b]
       
        3. 将c插入小根堆，重复执行 2 操作直至 n=1 。
    
至此，$k=2$ 的情况已经得到解决，下面考虑 $k>2$ 的情况。

上述贪心不能解决 $k>2$ 的情况，是因为最后一次 $2$ 操作可能 $n<k$ 导致此时从任意一层取一个叶子节点到该层都比此方案优。

解决这个问题的方案为：虚拟添加若干个权值为 $0$ 的叶子结点，使得 $(n-1) \mod (k-1)=0$ ，上述问题得以解决。

再考虑条件$2$：记录每个结点子树的深度，在权值相等的结点中，选择子树深度较小的结点合并即可。

下面贴 [[NOI2015]荷马史诗](https://www.luogu.com.cn/problem/P2168) 的代码

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int N=1002019;
#define int long long
int n,k,ans,mxd,tot,val[N],v[N];
struct Edge{int to,next;}e[N<<1];
void add(int x,int y){
    e[++tot].to=y; e[tot].next=v[x]; v[x]=tot;
}
struct node{
    int id,w,dep;
    // id :编号, w :权值, dep :子树深度 . 
    node(int a,int b,int c){id=a;w=b;dep=c;};
    bool operator >(const node &rhs)const{
    	return rhs.w==w?rhs.dep<dep:rhs.w<w;
    }
};
priority_queue<node,vector<node>,greater<node> > q;
void dfs(int x,int d){ // 统计答案 
    if(x<=n)ans+=val[x]*d,mxd=max(mxd,d);
    for(int p=v[x];p;p=e[p].next)dfs(e[p].to,d+1);
}
int read(){
    int x=0,f=1; char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
#undef int
int main()
{
    #define int long long
    n=read(); k=read();
    for(int i=1;i<=n;i++)
    	q.push(node(i,val[i]=read(),0));
    while((n-1)%(k-1)!=0)q.push(node(++n,0,0));
    // 插入若干虚拟结点
    int id=n,n1=n;
    while(n1-=k-1,n1>=1){
    	int th=0,mx=0; ++id; // 新建编号为 id 的点 th 
        for(int i=1;i<=k;i++,q.pop()){ // 取出 k 个最优元素
	    node nw=q.top(); th+=nw.w;
	    mx=max(mx,nw.dep); add(id,nw.id);
	} q.push(node(id,th,mx+1)); // 插入该结点 
    } dfs(id,0); // 统计答案 
    printf("%lld\n%lld",ans,mxd);
    return 0;
}
```


---

## 作者：霞客88 (赞：2)

# <font color=red>线性构建一颗哈夫曼树讲解</font>
哈夫曼树都最优的构建方法应该是线性的，但是由于这道题数据较水，nlogn也是能通过此题的，虽然复杂度不是最优的
实际上，不需要堆，双队列就可以完成哈夫曼树的构建
下面是证明:（更加详细的，全面的，请看[<font color=green>我的博客</font>](https://thewalker88.com/?p=173)）
Leeuwen在1976年的《On the construction of Huffman tree》中提出了一种**线性时间复杂度**的双队列构建哈夫曼树的方法
我们令in为刚开始按照频率升序给出的节点，Q为辅助的队列
我们假定已经完成了k-1步，现在要进行第k步，我们要考虑的是第k+1步时是否仍旧合法
#### Case I
![](https://thewalker88.com/wp-content/uploads/2018/05/case1-300x130.png)
在w(i)+w(i+1)，w(i)+q(1),q(1)+q(2)中，w(i)+w(i+1)最小，把它们的和加入Q的尾部
现在看第k+1步
第k+1步中，我们从w(i+2)+w(i+3),w(i+2)+q(1)，q(1)+q(2)中选一个最小的加入Q，注意到由于三个的大小关系不确定，我们必须能够确保w(i)+w(i+1)小于他们三个
首先，in是单增的，w(i)+w(i+1)<=w(i+2)+w(i+3)
其次，w(i)+w(i+1)<=w(i)+q(1)<=w(i+2)+q(1)  (in单调递增)
最后，w(i)+w(i+1)<=q(1)+q(2)，证毕
#### Case II
![](https://thewalker88.com/wp-content/uploads/2018/05/case2-256x300.png)
在w(i)+w(i+1)，w(i)+q(1),q(1)+q(2)中，w(i)+q(1)最小，把它们的和加入Q的尾部
现在看第k+1步
第k+1步中，我们从w(i+1)+w(i+2)，w(i+1)+q(2),q(2)+q(3)中选一个最小的加入Q，注意到由于三个的大小关系不确定，我们必须能够确保w(i)+q(1)小于他们三个
首先，由于在w(i)+w(i+1)，w(i)+q(1),q(1)+q(2)中，w(i)+q(1)最小，所以q(1)<=w(i+1)，又因为in单增，所以w(i)<=w(i+1)，所以w(i)+q(i)<=w(i+1)+w(i+1)<=w(i+1)+w(i+2)
其次，in和Q都是单增的，所以w(i)+q(1)<=w(i+1)+q(1)<=w(i+1)+q(2)
最后，w(i)+q(1)<=q(1)+q(2)<=q(2)+q(3)
#### Case III
![](https://thewalker88.com/wp-content/uploads/2018/05/case3-300x138.png)
在w(i)+w(i+1)，w(i)+q(1),q(1)+q(2)中，q(1)+q(2)最小，把它们的和加入Q的尾部
第k+1步中，我们从w(i)+w(i+1)，w(i)+q(3),q(3)+q(4)中选一个最小的加入Q，注意到由于三个的大小关系不确定，我们必须能够确保q(1)+q(2)小于他们三个
首先，由于Q是单增的，所以q(1)+q(2)<=q(3)+q(4)
其次，由于在w(i)+w(i+1)，w(i)+q(1),q(1)+q(2)中，q(1)+q(2)最小,所以q(1)+q(2)<=w(i)+w(i+1)
最后，q(1)+q(2)<=w(i)+q(1)<=w(i)+q(3)
至此，证毕，只需两个队列即可完成哈夫曼树的构建
接下来是代码
```cpp
#include<bits/stdc++.h>
#define MAXN 100010
#define MAXM 300010
#define ll long long
#define inf (0x7fffffff)
#define base 1048575

using namespace std;
#define fastcall __attribute__((optimize("-O3")))
#define IL __inline__ __attribute__((always_inline))
fastcall IL char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline ll read(){
    ll x=0,f=1;char ch=nc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=nc();}
    return x*f;
}
struct node{
    ll w,h;
};
node in[MAXN],Q[MAXN],b[MAXN];
int head_in,head_Q,tail_Q;
int cnt[base+1];
int n;
int k;
int ex_point;
ll sum;
int num;
ll temp,maxh;
fastcall IL void RadixSort(){
    for(register ll i=1;i<=n;++i) ++cnt[in[i].w&base];
    for(register ll i=1;i<=base;++i) cnt[i]+=cnt[i-1];
    for(register ll i=n;i;--i) b[cnt[in[i].w&base]--]=in[i];
    memset(cnt,0,sizeof(cnt));
    for(register ll i=1;i<=n;++i) ++cnt[(b[i].w>>20)&base];
    for(register ll i=1;i<=base;++i) cnt[i]+=cnt[i-1];
    for(register ll i=n;i;--i) in[cnt[(b[i].w>>20)&base]--]=b[i];
}

fastcall int main(){
    n=read();k=read();
    ex_point=(n-1)%(k-1);
    if(ex_point)ex_point=(k-1)-ex_point;
    for(register int i=1;i<=n;++i){
        in[i].w=read();in[i].h=1;
        Q[i].w=-1;
    }
    for(register int i=1;i<=ex_point;++i)in[++n].w=0,in[n].h=1,Q[n].w=-1;//补充节点
    RadixSort();//使in有序
    in[n+1].w=Q[n+1].w=-1;
    num=(n-1)/(k-1);
    head_in=1;head_Q=1;tail_Q=0;
    for(register int i=1;i<=num;++i){
        temp=maxh=0;
        for(register ll j=1;j<=k;++j){
            if((((in[head_in].w<Q[head_Q].w)||(in[head_in].w==Q[head_Q].w&&in[head_in].h<=Q[head_Q].h))&&in[head_in].w!=-1)||Q[head_Q].w==-1){
                sum+=in[head_in].w;
                maxh=max(maxh,in[head_in].h);
                temp+=in[head_in++].w;
            }
            else {
                sum+=Q[head_Q].w;
                maxh=max(maxh,Q[head_Q].h);
                temp+=Q[head_Q++].w;
            }
        }
        Q[++tail_Q].w=temp;
        Q[tail_Q].h=maxh+1;//将取出来的重新入队
    }
    printf("%lld\n%lld\n",sum,Q[tail_Q].h-1);
}
```

---

## 作者：XiaQiang (赞：2)

/\*
刚刚题解发错了，麻烦管理员修改一下。。。。。

依旧没用队列 堆排序

\*/




```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
int k;
const int M=200001;
struct node{
    ll id,data;
    ll lenth;
}temp,s[M],x;
int r,l;
ll n,all;
ll asize,size,w[100001],fa[200001][10];
bool cmp(node a,node b)
{ return a.data<b.data||(a.data==b.data&&a.lenth<b.lenth);}
void swapx(int i, int j){
    node tmp;
    tmp=s[i]; s[i]=s[j]; s[j]=tmp;
}
/*void out (){
    for(int i=0;i<=r;i++){
        printf("%lld ",s[i].data);
    }
    cout<<endl;
```
}\*/用于调试
    
```cpp
void insert(node x){    //将数x插入堆中
    r++;s[r]=x; l=r;
    while ((l>1)&&(cmp(s[l],s[l>>1]))){
        swapx(l,l>>1); l=l>>1;
    }
}
void change(node x){  //调整小根堆
    int rc,lc;
    node min=x; lc=2*x.id; rc=2*x.id+1;
    if ((lc<=r)&&(cmp(s[lc],s[min.id]))) min.id=lc;
    if ((rc<=r)&&(cmp(s[rc],s[min.id]))) min.id=rc;
    if (min.id!=x.id){
        swapx(x.id,min.id); change(min);
    }
}
node get(){    // 取堆顶元素并从堆中删除
    node res,a1;
    a1.data=1,a1.id=1,a1.lenth=1;
    res=s[1];  s[1]=s[r]; r--;
    if (r>1) change(a1);
    return res;
}
void init(){
    cin>>n>>k;
    temp.lenth=0;
    for(int i=1;i<=n;i++){
        cin>>w[i];
        fa[i][k]=1;
        temp.id=i;
        temp.data=w[i];
        l++;
        insert(temp);
        //out();
    }
    if(k!=2){
        while(n%(k-1)!=1){
            n++;
            temp.id=n;
            temp.data=0;
            fa[n][k]=1;
            insert(temp);
        }
    }
    all=n+1;
    while(r){
        temp.data=0;
        temp.lenth=0;
        temp.id=all++;
        for(int i=0;i<k;i++){
            temp.lenth=max((s[1].lenth)+1,temp.lenth);
            temp.data+=(s[1]).data;
            fa[temp.id][i]=(s[1]).id;
            get();
        }
        if(!r)break;
        fa[temp.id][k]=1;
        insert(temp);
    }
}
void dfs(ll x){
    if(x<=n)return;
    for(int i=0;i<k;i++){
        fa[fa[x][i]][k]+=fa[x][k];
        dfs(fa[x][i]);
    }
}
int main(){
    //freopen("P2168.in","r",stdin);
    //freopen("P2168.in","w",stdout);
    init();
    dfs(all-1);
    for(int i=1;i<=n;i++){
        asize+=fa[i][k]*w[i];
        size=max(size,fa[i][k]);
    }
    cout<<asize<<endl<<size;
    //fclose(stdin);
    //fclose(stdout);
}
```

---

## 作者：Kelin (赞：2)

介绍一下优先队列的Huffman树

http://blog.csdn.net/benoble\_/article/details/59703062


---


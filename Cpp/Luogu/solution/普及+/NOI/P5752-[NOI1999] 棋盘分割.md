# [NOI1999] 棋盘分割

## 题目描述

将一个 8 $\times$ 8 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘。 (每次切割都只能沿着棋盘格子的边进行)


![](https://cdn.luogu.com.cn/upload/image_hosting/ivf3ggl3.png)


原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的均方差最小。


均方差 $\sigma = \sqrt{ \frac{ \sum_{i=1}^n (x_i - \bar x)^2 } { n }}$                ，其中平均值 $\bar x = \frac{\sum_{i=1}^n x_i}{n}$ ,  $x_i$ 为第 $i$ 块矩形棋盘的分。


请编程对给出的棋盘及 $n$ ，求出 $\sigma$ 的最小值。


## 样例 #1

### 输入

```
3
1 1 1 1 1 1 1 3
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 0
1 1 1 1 1 1 0 3
```

### 输出

```
1.633
```

# 题解

## 作者：zhangboju (赞：33)

Update: 感谢 [zhangtianhan](https://www.luogu.com.cn/user/226176) 指出的错误（将方差与标准差混淆），已纠正。

[$\LaTeX$ 有点锅，请在 blog 查看](https://www.luogu.com.cn/blog/zhangboju/solution-p5752)

题目传送门：[Link](https://www.luogu.com.cn/problem/P5752)

这个题目很重要的条件就是：

> 每次切割都只能沿着棋盘格子的边进行。

关于这个条件的解释，题面中已经写的很清楚了，我就不赘述了。

考虑使均方差 $\sigma=\sqrt{\dfrac{\sum\limits_{i=1}^{n}(x_i-\bar{x})^2}{n}}$ 最小

则考虑使**方差** $\sigma^2=\dfrac{\sum\limits_{i=1}^{n}(x_i-\bar{x})^2}{n}$ 最小

分析得到 $\bar{x}=\dfrac{\sum\limits_{i=1}^nx_i}{n}$ 无论 $x_i$ 的取值 ，$\bar{x}$ 恒等于 $\dfrac{\sum\limits_{i=1}^8\sum\limits_{j=1}^8w_{i,j}}{n}$，**其中 $w_{i,j}$ 代表每一个格子上的数**。

所以可以预处理 $\bar{x}$。

此时可以发现将每个 $x_i$ 分开考虑，使得 $\dfrac{(x_i-\bar{x})^2}{n}$ 最小，即考虑使用动态规划。

由于此题是一个比较明显的区间分割问题，考虑使用区间 DP。

令 $f_{x_1,y_1,x_2,y_2,k}$ 表示将以 $(x_1,y_1)$ 为左上角，以 $(x_2,y_2)$ 为右下角的子矩阵划分为 $k$ 个子矩阵的最小**方差** $\sigma^2$，则最终答案为 $\sqrt{f_{1,1,8,8,n}}$。

-----------

此时我们发现要计算子矩阵的和，则考虑二维前缀和。定义 $s_{i,j}=\sum\limits_{q=1}^{i}\sum\limits_{w=1}^{j}w_{q,w}$。

二位前缀和写法这里不赘述。

利用 $s_{i,j}$，可 $O(1)$ 求出子矩阵的和。

-----------

首先定义 ${get}(x_1,y_1,x_2,y_2)=\dfrac{((\sum\limits_{i=x_1}^{x_2}\sum\limits_{j=y_1}^{y_2}w_{i,j})-\bar{x})^2}{n}$ 

边界 $k=1$ 时，$f_{x_1,y_1,x_2,y_2,1}={get}(x_1,y_1,x_2,y_2)$。

在状态转移时，分类讨论水平切还是竖直切，枚举在哪里切，再分类讨论是要哪一块。

----------

若横向切割：

![1.jpg](https://i.loli.net/2020/04/08/sKL27TqBCnzPG5Q.jpg)

枚举 $i \in [x_1,x_2)$ 表示将第 $i$ 行和第 $i+1$ 行分开，则新的到的两个矩阵左上角和右下角坐标如上图所示。

若选取上半部分进行再次划分，则 $f_{x_1,y_1,x_2,y_2,k}=f_{x_1,y_1,i,y_2,k-1}+{get}(i+1,y_1,x_2,y_2)$。

若选取下半部分进行再次划分，则 $f_{x_1,y_1,x_2,y_2,k}=f_{i+1,y_1,x_2,y_2,k-1}+{get}(x_1,y_1,i,y_2)$。

----------

若纵向切割：

![2.jpg](https://i.loli.net/2020/04/08/SWRt1o2JP76CyOH.jpg)

枚举 $i \in [y_1,y_2)$ 表示将第 $i$ 列和第 $i+1$ 列分开，则新的到的两个矩阵左上角和右下角坐标如上图所示。

若选取上半部分进行再次划分，则 $f_{x_1,y_1,x_2,y_2,k}=f_{x_1,y_1,x_2,i,k-1}+{get}(x_1,i+1,x_2,y_2)$。

若选取下半部分进行再次划分，则 $f_{x_1,y_1,x_2,y_2,k}=f_{x_1,i+1,x_2,y_2,k-1}+{get}(x_1,y_1,x_2,i)$。

----------

令 $f_{x_1,y_1,i,y_2,k-1}+{get}(i+1,y_1,x_2,y_2)$ 为 $(1)$；

$f_{i+1,y_1,x_2,y_2,k-1}+{get}(x_1,y_1,i,y_2)$ 为 $(2)$；

 $f_{x_1,y_1,x_2,i,k-1}+{get}(x_1,i+1,x_2,y_2)$ 为 $(3)$；

 $f_{x_1,i+1,x_2,y_2,k-1}+{get}(x_1,y_1,x_2,i)$ 为 $(4)$。

则可得出状态转移方程：
$$
f_{x_1,y_1,x_2,y_2,k}=\min(\min\limits_{x_1\leq i<x_2}((1),(2))\ \ ,\min\limits_{y_1\leq i< y_2}((3),(4)))
$$

----------

总时间复杂度 $O(8^5n)$。

由于循环太多，采用记忆化搜索写。

代码中 `X` 即为 $\bar{x}$。

注意 `X` 计算时别忘了强制转换 `s` 数组的类型。

```cpp
#include<bits/stdc++.h>
using namespace std;
double f[9][9][9][9][15];
int s[9][9];
double X;
int n;
double get(int x_1,int y_1,int x_2,int y_2)
{
    double sum=s[x_2][y_2]-s[x_2][y_1-1]-s[x_1-1][y_2]+s[x_1-1][y_1-1]-X;
    return sum*sum/n;
}
double dp(int x_1,int y_1,int x_2,int y_2,int k)
{
    if(f[x_1][y_1][x_2][y_2][k]>=0) return f[x_1][y_1][x_2][y_2][k];
    if(k==1) return f[x_1][y_1][x_2][y_2][k]=get(x_1,y_1,x_2,y_2);
    f[x_1][y_1][x_2][y_2][k]=1e9;
    for(int i=x_1;i<x_2;i++)
    {
        f[x_1][y_1][x_2][y_2][k]=min(f[x_1][y_1][x_2][y_2][k],dp(x_1,y_1,i,y_2,k-1)+get(i+1,y_1,x_2,y_2));
        f[x_1][y_1][x_2][y_2][k]=min(f[x_1][y_1][x_2][y_2][k],dp(i+1,y_1,x_2,y_2,k-1)+get(x_1,y_1,i,y_2));
    }
    for(int i=y_1;i<y_2;i++)
    {
        f[x_1][y_1][x_2][y_2][k]=min(f[x_1][y_1][x_2][y_2][k],dp(x_1,y_1,x_2,i,k-1)+get(x_1,i+1,x_2,y_2));
        f[x_1][y_1][x_2][y_2][k]=min(f[x_1][y_1][x_2][y_2][k],dp(x_1,i+1,x_2,y_2,k-1)+get(x_1,y_1,x_2,i));
    }
    return f[x_1][y_1][x_2][y_2][k];
}
int main()
{
    cin>>n;
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++)
        {
            scanf("%lf",&s[i][j]);
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    memset(f,-1,sizeof f);
    X=(double)s[8][8]/n;
    printf("%.3lf\n",sqrt(dp(1,1,8,8,n)));
}
```

这个 `memset` 是一个很玄学的东西，害的我调了半天。

于是我还是写了一份循环的：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define x1 x_1
#define x2 x_2
#define y1 y_1
#define y2 y_2
double f[9][9][9][9][15];
int s[9][9];
double X;
int n;
inline double get(int x1,int y1,int x2,int y2)
{
    double sum=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]-X;
    return sum*sum/n;
}
int main()
{
    cin>>n;
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++)
        {
            cin>>s[i][j];
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    X=(double)s[8][8]/n;
    for(int k=1;k<=n;k++)
    {
        for(int x1=1;x1<=8;x1++)
        {
            for(int y1=1;y1<=8;y1++)
            {
                for(int x2=1;x2<=8;x2++)
                {
                    for(int y2=1;y2<=8;y2++)
                    {
                        f[x1][y1][x2][y2][k]=1e9;
                        if(k==1)
                        {
                            f[x1][y1][x2][y2][k]=get(x1,y1,x2,y2);
                            continue;
                        }
                        for(int i=x1;i<x2;i++)
                        {
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[x1][y1][i][y2][k-1]+get(i+1,y1,x2,y2));
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[i+1][y1][x2][y2][k-1]+get(x1,y1,i,y2));
                        }
                        for(int i=y1;i<y2;i++)
                        {
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[x1][y1][x2][i][k-1]+get(x1,i+1,x2,y2));
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[x1][i+1][x2][y2][k-1]+get(x1,y1,x2,i));
                        }
                    }
                }
            }
        }
    }
    printf("%.3lf\n",sqrt(f[1][1][8][8][n]));
}
```

再次强调 $f_{x_1,y_1,x_2,y_2,k}$ 是存储的将子矩阵 $(x_1,y_1)(x_2,y_2)$ 划分为 $k$ 个子矩阵的最小**方差** $\sigma^2$，**所以最后还要开根号！**

------------

当然，这个题还可以采用其他方法。

同样考虑使**方差** $\sigma^2=\dfrac{\sum\limits_{i=1}^{n}(x_i-\bar{x})^2}{n}$ 最小。

拆开平方：$\sigma^2=\dfrac{1}{n}[\sum\limits_{i=1}^n(x_i^2-2x_i\bar{x}+\bar{x}^2)]$。

拆开括号：$\sigma^2=\dfrac{1}{n}(\sum\limits_{i=1}^nx_i^2-2\bar{x}\sum\limits_{i=1}^nx_i+n\bar{x}^2)=\dfrac{\sum\limits_{i=1}^nx_i^2}{n}-2\bar{x}\dfrac{\sum\limits_{i=1}^nx_i}{n}+\bar{x}^2$。

而我们知道：$\bar{x}=\dfrac{\sum\limits_{i=1}^nx_i}{n}$。

所以：$\sigma^2=\dfrac{\sum\limits_{i=1}^nx_i^2}{n}-\bar{x}^2$。

要使 $\sigma^2$ 最小，由于 $\bar{x}^2$ 为定值，则使 $\dfrac{\sum\limits_{i=1}^nx_i^2}{n}$ 最小。

--------------

此时改变 $f_{x_1,y_1,x_2,y_2,k}$ 的意义，表示将以 $(x_1,y_1)$ 为左上角，以 $(x_2,y_2)$ 为右下角的子矩阵划分为 $k$ 个子矩阵的最小的 $\dfrac{\sum\limits_{i=1}^kx_i^2}{n}$。

改变 ${get}(x_1,y_1,x_2,y_2)=\dfrac{(\sum\limits_{i=x_1}^{x_2}\sum\limits_{j=y_1}^{y_2}w_{i,j})^2}{n}$。

则最后答案为 $\sqrt{f_{1,1,8,8,n}-\bar{x}^2}$。

状态转移方程不变。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define x1 x_1
#define x2 x_2
#define y1 y_1
#define y2 y_2
double f[9][9][9][9][15];
int s[9][9];
double X;
int n;
inline double get(int x1,int y1,int x2,int y2)
{
    double sum=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1];
    return sum*sum/n;
}
int main()
{
    cin>>n;
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++)
        {
            cin>>s[i][j];
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    X=(double)s[8][8]/n;
    for(int k=1;k<=n;k++)
    {
        for(int x1=1;x1<=8;x1++)
        {
            for(int y1=1;y1<=8;y1++)
            {
                for(int x2=1;x2<=8;x2++)
                {
                    for(int y2=1;y2<=8;y2++)
                    {
                        f[x1][y1][x2][y2][k]=1e9;
                        if(k==1)
                        {
                            f[x1][y1][x2][y2][k]=get(x1,y1,x2,y2);
                            continue;
                        }
                        for(int i=x1;i<x2;i++)
                        {
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[x1][y1][i][y2][k-1]+get(i+1,y1,x2,y2));
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[i+1][y1][x2][y2][k-1]+get(x1,y1,i,y2));
                        }
                        for(int i=y1;i<y2;i++)
                        {
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[x1][y1][x2][i][k-1]+get(x1,i+1,x2,y2));
                            f[x1][y1][x2][y2][k]=min(f[x1][y1][x2][y2][k],f[x1][i+1][x2][y2][k-1]+get(x1,y1,x2,i));
                        }
                    }
                }
            }
        }
    }
    printf("%.3lf\n",sqrt(f[1][1][8][8][n]-X*X));
}
```


---

## 作者：SunnyYuan (赞：10)

这个题解思路虽然与其他人的思路相同，

但力求使用清晰易懂的图片和文字，讲解最简洁的道理。

请大家耐心地看完，注意要结合图片一起哦~~

**2022-8-24 更改了格式与错别字。**

**2022-8-28 更改了数学公式格式。**

**这是本蒟蒻第一次写题解，不足之处请多包涵。**

---

**题目大意：**

 ~~读完题的可以跳过这一部分。~~

 给定一个矩阵，每个位置上都有数字。

 可以分割 $n-1$ 次，每次分割为 $2$ 个矩形，然后把一半放在一旁，然后在另外一半继续割。

 像这样：
 
![](https://cdn.luogu.com.cn/upload/image_hosting/olfoxgd8.png)

 可以横切也可以纵切。
 

![](https://cdn.luogu.com.cn/upload/image_hosting/7ude3f62.png)

 样例给的很好。

![](https://cdn.luogu.com.cn/upload/image_hosting/n326l7yi.png)

 然后就分为 $n$ 块（因为割了 $n-1$ 次）。
 
 记 $X=\dfrac{s}{n}$，$s$ 为矩阵中所有的数字之和。
 
 设第 $i$ 块的和为 $x_i$，那么求出怎样割才能使 $\sum_{i=1}^{n}(x_i-X)^2 $ 更小。

---

**分析问题：**

 我们看到这种分割问题，最后组合起来求总体最优值，便可以立马联想到区间 DP。这叫~~望梅止渴~~做 DP 问题的复杂反射。
 
 ~~毕竟区间 DP 的主要思想就是大区间包含小区间，~~
 
 ~~小区间汇集成大区间。~~
 
 好了，废话不多说，我们先从如下几个角度思考：

* 状态表示
* 状态含义
* 目标状态
* 状态转移

 一、状态表示：$f(x1,y1,x2,y2,k)$。
 
 二、状态含义：$f(x1,y1,x2,y2,k)$ 表示求解子矩阵 $(x1,y1)\sim(x2,y2)$ 割了 $k$ 刀得来的最优解（即下图框住区域的最优解）。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/k8v1jwde.png)

 三、目标状态：$f(1,1,8,8,n)$，即求解整个矩阵被割了 $n$ 刀的最优解。
 
 四、状态转移：
 
 我们以下图为例，讲解 $f(x1,y1,x2,y2,k)$ 是如何被拆分的。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/pzrrgkgq.png)

 ①：考虑选择上面继续割（如下图），丢掉下面的，其分界线为第 $i$ 行。
 
 所以应该取上面的最优值，同时少割一刀：$f(x1,y1,i,y2,k-1)$，
 
 而下面的部分为定值：$\dfrac{(sum-X)^2}{n}$。
 
 $sum$ 为下面的部分所有格子的和。
 
 这两个部分合起来就是 $f(x1,y1,x2,y2,k)$。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/mfsueevy.png)

---

 ②：考虑选择下面继续割（如上图）。
 
 上面部分的定值：$\dfrac{(sum-X)^2}{n}$。
 
 下面的最优值：$f(i+1,y1,x2,y2,k-1)$。
 
 $sum$ 为上面的部分所有格子的和。
 
---

 下面考虑纵切。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/1ei13car.png)

 ③：考虑选择左边继续割（如上图），分界线为第 $i$ 列。
 
 取左边的最优值：$f(x1,y1,x2,i,k-1)$，
 
 右边的部分为定值：$\dfrac{(sum-X)^2}{n}$。
 
 $sum$ 为右边的部分所有格子的和。
 
 ---

 ④：考虑选择右边继续割（如上图）。
 
 取右边的最优值：$f(x1,i+1,x2,y2,k-1)$，
 
 左边的部分为定值：$(sum-X)\times(sum-X)/n$，
 
 $sum$ 为左边的部分所有格子的和。
 
---

 我们每次取一个值，其实都是在将问题规模缩小。
 
 情况考虑清楚了，那怎么从一个 $f$ 到另一个 $f$ 呢，如果是用普通的区间 DP，那估计要使用 $5$ 层甚至更多的循环，所以，我们使用~~万能的~~记忆化搜索，免去繁琐的循环结构。

---
 综上所述，
 
 我们便实现了对大区间的拆分。
 
 而我们不断提到 $sum$，是一块区域的和，那么，我们可以使用二维前缀和来维护。~~相信大家一定会。~~

 好了，上 AC 代码。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=15;
const double INF=1e10;				//因为要求min,所以要定义INF

int n;
int m=8;
double X;							//平均值
double s[N][N];						//记录每个格子的值
double f[N][N][N][N][N];			//状态

double GetSum(int x1,int y1,int x2,int y2)//求[x1,y1]~[x2,y2]的和,为下文的GetX服务
{
    return s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
}

double GetX(int x1,int y1,int x2,int y2)// 计算上文的(sum−X)×(sum−X)/n。
{
    return (GetSum(x1,y1,x2,y2)-X)*(GetSum(x1,y1,x2,y2)-X)/n;
}

double DFS(int x1,int y1,int x2,int y2,int k)//使用记忆化搜索进行递归调用
{
    double& v=f[x1][y1][x2][y2][k];//因为太难写了，所以给f[x1][y1][x2][y2][k]建立引用
    if(v>=0)return v;				//已经访问过该点了，直接返回
    if(k==1)return v=GetX(x1,y1,x2,y2);//最后一块，不可能再割了
    
    v=INF;							//为求最小值做准备
    
    for(int i=x1;i<x2;i++)			//下面是刚刚讨论的结果
    {
        v=min(v,DFS(x1,y1,i,y2,k-1)+GetX(i+1,y1,x2,y2));
        v=min(v,DFS(i+1,y1,x2,y2,k-1)+GetX(x1,y1,i,y2));
    }
    
    for(int i=y1;i<y2;i++)
    {
        v=min(v,DFS(x1,y1,x2,i,k-1)+GetX(x1,i+1,x2,y2));
        v=min(v,DFS(x1,i+1,x2,y2,k-1)+GetX(x1,y1,x2,i));
    }
    
    return v;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=m;j++)
        {
            double x;
            scanf("%lf",&x);
            s[i][j]=s[i-1][j]+s[i][j-1]+x-s[i-1][j-1];						//建立前缀和
        }
    }
    X=s[m][m]/n;					//求平均值
    memset(f,0x80,sizeof f);		//初始化
    printf("%.3f\n",sqrt(DFS(1,1,m,m,n)));//注意，一定要根号啊啊啊!!!
    return 0;
}
```

---

## 作者：一只书虫仔 (赞：9)

#### Description

> 给定一个 $8 \times 8$ 的矩阵 $a_{i,j}$，求将其分为 $n$ 块，第 $i$ 块的数总和为 $x_i$，求 $x_i$ 的标准差的最小值。

具体分割方法题面有详细叙述，本题解的 Description 只是简述。

#### Solution

标准差 $S$ 为：

$$S=\sqrt{\frac{\sum\limits_{i=1}^n(x_i-\overline x)^2}{n}}$$

如果 $S$ 要求最小，可以直接让方差 $S^2$ 最小：

$$S^2=\frac{\sum\limits_{i=1}^n(x_i-\overline x)^2}{n}$$

$n$ 是固定的，我们只需要让下面这个东西最小即可：

$$v=\sum\limits_{i=1}^n(x_i-\overline x)^2$$

又因为 $\overline x$ 是固定的，恒等于：

$$\overline x=\frac{\sum\limits_{i=1}^n x_i}{n}=\frac{\sum\limits_{i=1}^8\sum\limits_{j=1}^8 a_{i,j}}{n}$$

所以我们只需要改变 $x_i$ 使得 $v$ 最小即可，因为矩阵大小是 $8$，暴力 dp 即可。

设 $f_{x_1,y_1,x_2,y_2,k}$ 为左上角为 $(x_1,y_1)$ 右下角为 $(x_2,y_2)$ 的矩阵分为 $k$ 块这一子矩阵的 $v$ 的最小值。

考虑“分块”，如果这么分：

![](https://cdn.luogu.com.cn/upload/image_hosting/nnl9u2pm.png)

假设竖着那一刀分成了左右两列 $m,m+1$，则：

- 左边留为一个子矩阵，右边继续切：$f_{x_1,y_1,x_2,m,1}+f_{x_1,m+1,x_2,y_2,k-1}$；
- 右边留为一个子矩阵，左边继续切：$f_{x_1,y_1,x_2,m,k-1}+f_{x_1,m+1,x_2,y_2,1}$。

还可以这么分：

![](https://cdn.luogu.com.cn/upload/image_hosting/64fj6bly.png)

假设横着那一刀分成了上下两行 $m,m+1$，则：

- 上边留为一个子矩阵，下边继续切：$f_{x_1,y_1,m,y_2,1}+f_{m+1,y_1,x_2,y_2,k-1}$；
- 下边留为一个子矩阵，上边继续切：$f_{x_1,y_1,m,y_2,k-1}+f_{m+1,y_1,x_2,y_2,1}$。

初值：

- $$f_{x_1,y_1,x_2,y_2,1}=\left(\sum\limits_{x=x_1}^{x_2}\sum\limits_{y=y_1}^{y_2}a_{x,y} - \frac{\sum\limits_{i=1}^8\sum\limits_{j=1}^8 a_{i,j}}n{}\right)$$
- 其他全部设为 $\infty$ 即可。

注意亿些细节，比如说强制类型转换，先枚举 $k$，不能直接使用 memset 之类的，放一下代码。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
int a[10][10];
int sum[10][10];
double ave; // 平均值 
double dp[10][10][10][10][16];

int main () {
	scanf("%d", &n);
	for (int i = 1; i <= 8; i++)
		for (int j = 1; j <= 8; j++)
			scanf("%d", &a[i][j]);
	for (int i = 1; i <= 8; i++)
		for (int j = 1; j <= 8; j++)
			sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + a[i][j];
	ave = ((1.0 * sum[8][8]) / (1.0 * n));
	for (int k = 1; k <= n; k++)
		for (int x1 = 1; x1 <= 8; x1++)
			for (int y1 = 1; y1 <= 8; y1++)
				for (int x2 = 1; x2 <= 8; x2++)
					for (int y2 = 1; y2 <= 8; y2++)
						if (k == 1) {
							int s = sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] + sum[x1 - 1][y1 - 1];
							double S = 1.0 * s;
							dp[x1][y1][x2][y2][k] = (S - ave) * (S - ave);
						} else {
							dp[x1][y1][x2][y2][k] = 1e9;
							for (int m = x1; m < x2; m++)
								dp[x1][y1][x2][y2][k] = min(dp[x1][y1][m][y2][1] + dp[m + 1][y1][x2][y2][k - 1], min(dp[x1][y1][m][y2][k - 1] + dp[m + 1][y1][x2][y2][1], dp[x1][y1][x2][y2][k]));
							for (int m = y1; m < y2; m++)
								dp[x1][y1][x2][y2][k] = min(dp[x1][y1][x2][m][1] + dp[x1][m + 1][x2][y2][k - 1], min(dp[x1][y1][x2][m][k - 1] + dp[x1][m + 1][x2][y2][1], dp[x1][y1][x2][y2][k]));
						}
	double ans = dp[1][1][8][8][n];
	printf("%.3f", sqrt(ans / (1.0 * n)));
	return 0;
}
```

---

## 作者：RemiliaScar1et (赞：5)


先来看看我们要最小化的这个均方差(其实就是标准差) $\sigma=\sqrt{\frac{\sum_{i=1}^n(x_i-\overline{x})^2}{n}}$。

显然我们要最小化这个东西就要最小化它的方差 $S=\sigma^2=\frac{\sum_{i=1}^n(x_i-\overline{x})^2}{n}$

然后推下柿子：
$$
\begin{aligned}
S&=\frac{\sum_{i=1}^n(x_i-\overline{x})^2}{n}\\
&=\frac{1}{n}\cdot \sum_{i=1}^n(x_i^2-2x_i\overline{x}+\overline{x}^2)\\
&=\frac{1}{n}\cdot(\sum_{i=1}^nx_i^2-2\overline{x}\sum_{i=1}^nx_i+n\overline{x}^2)\\
&=\frac{1}{n}\cdot(\sum_{i=1}^nx_i^2-2\overline{x}\cdot n\overline{x}+n\overline{x}^2)\\
&=\frac{1}{n}\cdot(\sum_{i=1}^nx_i^2-n\overline{x}^2)\\
&=\frac{\sum_{i=1}^nx_i^2}{n}-\overline{x}^2\\
\end{aligned}
$$

最终的 $\overline{x}$ 是固定的，我们的目标是最小化 $\sum_{i=1}^nx_i^2$。

也就是说，我们要让每一部分的价值(即格子数)的平方和最小。

题目中给的方法是将一个大方格图分成几个方格图，这个过程是二维区间分割的过程。我们可以试着使用区间 DP 解决问题。

下面我们定义 $[a,b,c,d]$ 表示一个二维区间，它对应方格图中左上角在 $(a,b)$，右下角在 $(c,d)$ 的子矩阵。

- 状态设计：设状态 $f(a,b,c,d,k)$ 表示分割区间 $[a,b,c,d]$ 为 $k$ 块能得到的最大平方和。

- 状态计算：
    考虑一个区间怎么分割。

    首先我们可以任意将这个区间一分为二，然后分别处理两个区间。

    ![](https://img.imgdb.cn/item/6081485c563420b647d3e70c.png)

    对于上面这个特例，我们此时可以选择分割左区间或右边区间。

    - 若是选择分割右边区间，那么当前区间的答案 $f(1,1,8,8,k)=f(3,1,8,8,k-1)+sum(1,1,3,8)^2$
    - 若是选择分割左边区间，那么当前区间的答案 $f(1,1,8,8,k)=f(1,1,3,8,k-1)+sum(3,1,8,8)^2$

    两个答案取最小值即可。

    我们将上面的情况扩展，枚举分界点 $t$，状态转移方程如下：

    $f(l_1,r_1,l_2,r_2,k)=\min\{f(l_1,r_2,t,r_2,k-1)+sum(t+1,r_1,l_2,r_2)^2,f(t+1,r1,l2,r2)+sum(l_1,r_1,t,r2)^2\}$

    这只是竖着割的情况，横着割也同理。

    $f(l_1,r_1,l_2,r_2,k)=\min\{f(l_1,r_1,l_2,t)+sum(l_1,t+1,l_2,r_2)^2,f(l_1,t+1,l_2,t_2)+sum(l_1,r_1,l_2,t)^2\}$

    - 注意，当 $k=1$ 时，$f(a,b,c,d,1)=sum(a,b,c,d)^2$。
    
DP 得到最小平方和之后整体代入到上面的式子算即可

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const ll N=30,INF=1e10;

int n;
ll a[N][N],s[N][N];
ll f[N][N][N][N][N];

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
		scanf("%lld",&a[i][j]);
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
		s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
	for(int l1=1;l1<=8;l1++)
	for(int r1=1;r1<=8;r1++)
	for(int l2=l1;l2<=8;l2++)
	for(int r2=r1;r2<=8;r2++)
	{
		ll sum=s[l2][r2]-s[l1-1][r2]-s[l2][r1-1]+s[l1-1][r1-1];
		f[l1][r1][l2][r2][1]=sum*sum;
	}
	for(int k=2;k<=n;k++)
	for(int l1=1;l1<=8;l1++)
	for(int r1=1;r1<=8;r1++)
	for(int l2=l1;l2<=8;l2++)
	for(int r2=r1;r2<=8;r2++)
	{
		f[l1][r1][l2][r2][k]=INF;
		for(int t=l1+1;t<=l2;t++)
		{
			ll tmp=min(f[l1][r1][t-1][r2][k-1]+f[t][r1][l2][r2][1],f[t][r1][l2][r2][k-1]+f[l1][r1][t-1][r2][1]);
			f[l1][r1][l2][r2][k]=min(f[l1][r1][l2][r2][k],tmp);
		}
		for(int t=r1+1;t<=r2;t++)
		{
			ll tmp=min(f[l1][r1][l2][t-1][k-1]+f[l1][t][l2][r2][1],f[l1][t][l2][r2][k-1]+f[l1][r1][l2][t-1][1]);
			f[l1][r1][l2][r2][k]=min(f[l1][r1][l2][r2][k],tmp);
		}
	}
	ll ans=f[1][1][8][8][n];
	long double S=(long double)1.0*ans/n - (long double)(1.0*s[8][8]*s[8][8])/n/n;
	printf("%.3Lf",sqrt(S));
	return 0;
}
```

---

## 作者：gesong1234 (赞：3)

题目传送门：[P5752 [NOI1999] 棋盘分割](https://www.luogu.com.cn/problem/P5752)。
# 思路
题目告诉我们：

$
\begin{aligned}
\sigma&=\sqrt{\frac{\sum_{i=1}^{n}(x_i-\overline x)^2}{n}}\\
\sigma ^2&=\frac{\sum_{i=1}^{n}(x_i-\overline x)^2}{n}\\
&=\frac{\sum_{i=1}^{n}(x_i^2-2x_i\overline x+\overline x^2)}{n}\\
&=\frac{(\sum_{i=1}^nx_i^2)-2n\overline x^2+n\overline x^2}{n}\\
&=\frac{(\sum_{i=1}^n x_i^2)-n\overline x^2}{n}\\
&=\frac{\sum_{i=1}^n x_i^2}{n}-\frac{n\overline x^2}{n}\\
&=\frac{\sum_{i=1}^nx_i^2}{n}-\overline x^2
\end{aligned}
$ 

由于 $\overline x$ 一直等于 $\frac{\sum_{i=1}^n x_i}{n}=\frac{\sum_{i=1}^8\sum_{j=1}^8a_{i,j}}{n}$，$a_{i,j}$ 为棋盘每个点的分值，最后我们就要最小化 $\sum_{i=1}^nx_i^2$，马上考虑 **dp**。

**状态表示**：

1. $f_{x1,y1,x2,y2,s} $ 表示在左上角的坐标为 $(x1,y1)$，右下角的坐标为 $(x2,y2)$,在割了 $n-s$ 次后，能得到的最大价值。
2. $get$ 函数，求的是 $\frac{((\sum_{i=x1}^{x2}\sum_{i=y1}^{y2}a_{i,j})-\overline x)^2}{n}$。

**状态初始化**：

$f_{x1,y1,x2,y2,n-1}=get(x1,y1,x2,y2)$ 只割一次，就是自己总价值。

**方程转移**：

由于是切割，就要分为两种：

1. 竖着切，枚举 $i$ 把这个矩形切成 $(x1,y1,x2,i)$ 和 $(x1,i+1,x2,y2)$ 所以方程就是 $f_{x1,y1,x2,y2,s}=\min(f_{x1,y1,x2,y2,s},f_{x1,y1,x2,i,s+1}+ get(x1,i+1,x2,y2),f_{x1,i+1,x2,y2,s+1}+get(x1,y1,x2,i))$。
2. 横着切，枚举 $i$ 把这个矩形切成 $(x1,y1,i,y2)$ 和 $(i+1,y1,x2,y2)$ 所以方程就是 $f_{x1,y1,x2,y2,s}=\min(f_{x1,y1,x2,y2,s},f_{x1,y1,i,y2,s+1}+ get(i+1,y1,x2,y2),f_{i+1,y1,x2,y2,s+1}+get(x1,y1,i,y2))$。

综上方程就是 $f_{x1,y1,x2,y2,s}=\min(\text{横着切},\text{竖着切})$。

最后用**记忆化搜索**即可。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
double f[20][20][20][20][20];
int k,a[20][20],n=8;
double get(int x1,int y1,int x2,int y2){
	double t=a[x2][y2]+a[x1-1][y1-1]-a[x1-1][y2]-a[x2][y1-1]-a[n][n]*1.0/k;
	return t*t*1.0/k;
}
double dfs(int x1,int y1,int x2,int y2,int s){
	if (f[x1][y1][x2][y2][s]) return f[x1][y1][x2][y2][s];
	if (s-1==k-1) return f[x1][y1][x2][y2][s]=get(x1,y1,x2,y2);
	double ans=1e18;
	for (int i=x1;i<x2;i++){
		ans=min(ans,dfs(x1,y1,i,y2,s+1)+get(i+1,y1,x2,y2));
		ans=min(ans,dfs(i+1,y1,x2,y2,s+1)+get(x1,y1,i,y2));
	}
	for (int i=y1;i<y2;i++){
		ans=min(ans,dfs(x1,y1,x2,i,s+1)+get(x1,i+1,x2,y2));
		ans=min(ans,dfs(x1,i+1,x2,y2,s+1)+get(x1,y1,x2,i));
	}
	return f[x1][y1][x2][y2][s]=ans;
} 
main(){
	cin>>k;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++){
			int x;
			cin>>x;
			a[i][j]=x+a[i-1][j]+a[i][j-1]-a[i-1][j-1];
		}
	printf("%.3lf",sqrt(dfs(1,1,n,n,1)));
    return 0;
}
```


---

## 作者：45dino (赞：3)

**前言**

这一题一开始记忆化搜索少写了一点东西（退化成普通搜索），导致疯狂卡常，但还是没有过最后一个点，补上记忆化搜索后就成了本题时间rk1（呲牙

![](https://cdn.luogu.com.cn/upload/image_hosting/nva840fm.png)

同时也说明了记忆化搜索和朴素的搜索之间是天差地别的。

**算法分析**

看到这种分割题，感觉十有八九是 dp。但是在 dp 之前，要先找到最好的状态和这个状态的一些特性。

平均值是一个定值，可以先求出来，根号不便于 dp 的转移，先提出来，最后再加上，除以 $n$ 也可以提出来，这样可以更好地保留精度，同时也是一个常数的小优化。这样就变成求 $\sum_{i=1}^n(x_i-\overline x)$ 的最小值。这个东西在统计学上有个专门的名称，叫 [离均差平方和](https://baike.baidu.com/item/%E7%A6%BB%E5%9D%87%E5%B7%AE%E5%B9%B3%E6%96%B9%E5%92%8C/12022298?fr=aladdin)。

令 $f(x_1,x_2,y_1,y_2,num)$ 代表把左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$ 的矩形分成 $num$ 块时离均差平方和的最小值。

转移的时候枚举切下来的矩形，一共有四种大类，如下所示（灰色部分代表切除部分）：

![](https://cdn.luogu.com.cn/upload/image_hosting/7d16iggx.png)

状态数为 $8^4\times n$，单次转移的常数为 32，总时间复杂度为 $\Theta(n)$。（其实这一题时间复杂度不能说明什么，关键是带了一个 1e5 左右的超大常数）

就此，这一题已经结束了，想看代码的往下翻翻就到了。

**常数优化**
>此部分仅供娱乐，与正解关系不大。另外，本蒟蒻并不是卡常带师，欢迎真正的卡常带师在评论区发表高见。

正如前言中所说，一开始搜索写错促使我开始卡常，使转移的常数降为 8。

发现在转移的时候，有些枚举的矩形是不可能得到最小值的。

设当前枚举的矩形面积为 $A$。根据离均差平方和的定义，只有两种可能才需要转移。
- $A\le\overline x$ 且 $A$ 取最大值。
- $A\ge\overline x$ 且 $A$ 取最小值。

这样在循环的时候判断当前的 $A$ 是否满足条件，这样就可以降低转移的复杂度。

参考代码
```cpp
//#pragma GCC optimize("Ofast")
//#include<bits/stdc++.h>
#include<iostream>
#include<math.h>
#define int long long
using namespace std;
int n;
double ave,a[9][9],f[9][9][9][9][15];
double p2(double x)
{
	return x*x;
}
double A(int x,int xx,int y,int yy)
{
	return a[x-1][y-1]+a[xx][yy]-a[x-1][yy]-a[xx][y-1];
}
double solve(int x,int xx,int y,int yy,int num)
{
	if(num==1)
		return p2(A(x,xx,y,yy)-ave);
	if(f[x][xx][y][yy][num]!=0)
		return f[x][xx][y][yy][num];
	double ans=1000000000.0;
	for(int i=x;i<xx;i++)
	{
		if(i<xx&&A(x,i+1,y,yy)<ave)
			continue;
		int m=A(x,i,y,yy);
		ans=min(ans,p2(m-ave)+solve(i+1,xx,y,yy,num-1));
		if(m>=ave)
			break;
	}
	for(int i=y;i<yy;i++)
	{
		if(i<yy&&A(x,xx,i+1,yy)<ave)
			continue;
		int m=A(x,xx,y,i);
		ans=min(ans,p2(m-ave)+solve(x,xx,i+1,yy,num-1));
		if(m>=ave)
			break; 
	}
	for(int i=xx;i>x;i--)
	{
		if(i>x&&A(i-1,xx,y,yy)<ave)
			continue;
		int m=A(i,xx,y,yy);
		ans=min(ans,p2(m-ave)+solve(x,i-1,y,yy,num-1));
		if(m>=ave)
			break;
	}
	for(int i=yy;i>y;i--)
	{
		if(i>y&&A(x,xx,i-1,yy)<ave)
			continue;
		int m=A(x,xx,i,yy);
		ans=min(ans,p2(m-ave)+solve(x,xx,y,i-1,num-1));
		if(m>=ave)
			break;
	}
	return f[x][xx][y][yy][num]=ans;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=8;i++)
		for(int l=1;l<=8;l++)
		{
			cin>>a[i][l];
			a[i][l]+=a[i-1][l]+a[i][l-1]-a[i-1][l-1];
		}
	ave=a[8][8]/n;
	printf("%.3lf",sqrt(solve(1,8,1,8,n)/n));
	return 0;
}
```

---

## 作者：Push_Y (赞：3)

 _这题我就把思路讲一下，代码就不贴了（自己改错可以提高自己的水平）_
 
动态规划需要注意什么？
## 要计算什么东西？
此题需要计算的是均方差的最小值

一个关键点在于挖掘“均方差最小值”的本质，对于均方差σ，我们平方一下(除以n无关紧要，先省略，X就是平均数）

![](https://cdn.luogu.com.cn/upload/image_hosting/s6tm7qwl.png)

显然其中后两项固定，只需要求 

![](https://cdn.luogu.com.cn/upload/image_hosting/p60kaaj7.png)
的最小值

## 表示出状态
由于是矩形，我们取左上角端点和右下角端点

f(x1,y1,x2,y2)

但是还需要考虑切几刀，多一维k表示切刀数

f(x1,y1,x2,y2,k)
## 怎么转移方程
分别考虑x坐标和y坐标，分别写一个循环，for i=x1~x2-1和for i=y1~y2-1

i表示切在xi和xi+1之间(或yi和yi+1之间)

状态转移方程就很好想了，我就不把长代码贴上来了
### 循环还是递归
f维数太多了循环太麻烦了，我们用递归并且运用记忆化搜索。
## 预处理
输入后直接维护sum[x][y]表示从(1,1)到(x,y)之间的前缀矩阵和

 _望管理过审核_ 

---

## 作者：Xu_brezza (赞：2)

## 题意：
给你一个  $8 \times 8$  的棋盘，每个格子上都有一个值，要求你切  $n - 1$   刀，每一刀都在当前剩下的棋盘上切，也就是不能交叉切，然后得到 $n$ 个棋盘，规定棋盘的分值为该棋盘格子的点数之和，均方差为每个棋盘的分值减去 $8 \times  8$ 棋盘的平均值的平方，均方差公式： $\sigma = \sqrt{ \frac{\sum_{i=1}^{n}({x_{i}-\bar{x})^{2}}}{n}}$ 其中 $x_{i}$ 就是划分出来的棋盘的分值。

## 分析：
我们首先来看让方差最小等价于什么，因为肯定不能枚举方差对吧。把     $({x_{i}-\bar{x})^{2}}$  这个式子给展开，其余的都是常数先忽略。我们得到的是一个完全平方式 $x_{i}^{2}-2x_{i}\bar{x}+\bar{x}^{2}$ 那么就可以看出来，有影响的只是这个 $x_{i}^{2}$ 所以我们求出他的最小值即可。

到此，我们可以引出区间动态规划了，不过是二维的，可以抽象理解一下。
状态是怎么样的呢？考虑考虑有哪些因素会对这个 $dp$ 有影响，首先区间 $dp$ 矩形的大小肯定是一个，还有什么？那自然是切了几刀。所以我们的状态就是 $f[x_{1}][y_{1}][x_{2}][y_{2}][k]$ 分别代表矩形的左上角 $(x_{1},y_{1})$  右下角  $(x_{2},y_{2})$ 还有该矩形切的刀数 $k$ 
状态设计出来了，转移的方法就很好想了，一个矩形我们可以横着切，可以竖着切，这一刀会把原来的矩形分成两部分，一部分肯定是切了 $0$ 刀的，一部分肯定是切了 $k-1$ 刀的，我们只需要枚举切割的行列，记忆化搜索就行。至于求和，我们用二维前缀和来维护即可。

具体的细节请看代码来理解。

```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cctype>
#include<vector>
#include<string>
using namespace std;
double f[10][10][10][10][20];
double sum[10][10],ave;
int a[10][10];
int n;
inline double query(int x1,int y1,int x2,int y2){
	double a = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1];	
	return (a-ave)*(a-ave);//二维前缀和访问顺便求个方差 
}
double ff(int x1,int y1,int x2,int y2,int k){
	if(f[x1][y1][x2][y2][k])return f[x1][y1][x2][y2][k];//记忆化 
	if(k == 0)return query(x1,y1,x2,y2);//该矩形不切，就直接返回 (分值-平均数)^2 
	f[x1][y1][x2][y2][k] = 0x3f3f3f3f3f;//否则正无穷 
	for(int i=x1;i<x2;++i){//横着切，枚举切断的地方 
		f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k],ff(x1,y1,i,y2,0)+ff(i+1,y1,x2,y2,k-1));//下半部分切k-1刀 
		f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k],ff(x1,y1,i,y2,k-1)+ff(i+1,y1,x2,y2,0));//上半部分切k-1刀 
				
	}
	for(int j=y1;j<y2;++j){//竖着切 
		f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k],ff(x1,y1,x2,j,0)+ff(x1,j+1,x2,y2,k-1));//右半部分切k-1刀 
		f[x1][y1][x2][y2][k] = min(f[x1][y1][x2][y2][k],ff(x1,y1,x2,j,k-1)+ff(x1,j+1,x2,y2,0));//左半部分切k-1刀（人类本质） 
	}
	return f[x1][y1][x2][y2][k];
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=8;++i){
		for(int j=1;j<=8;++j)scanf("%d",&a[i][j]);
	}
	for(int i=1;i<=8;++i)
		for(int j=1;j<=8;++j)
			sum[i][j] = sum[i][j-1] + a[i][j];
	for(int j=1;j<=8;++j)
		for(int i=1;i<=8;++i)
			sum[i][j] += sum[i-1][j];//前缀和处理 
	ave = sum[8][8] / n;//平均数 
	printf("%.3lf",sqrt(1.0*ff(1,1,8,8,n-1)/n));
}

```


---

## 作者：Kalium (赞：2)

# P5752 [NOI1999] 棋盘分割题解

## 前言：

[双倍经验](https://www.luogu.com.cn/problem/P1436)奉上。

## 题意：

自己看，这个题意我也不知道如何简化了[题意](https://www.luogu.com.cn/problem/P5752)。

## 思路：

这边先化简化简这个奇奇怪怪的式子：

$\sigma = \sqrt{\dfrac{\sum_{i = 1}^n(x_i - \overline{x}) ^ 2}{n}}$。

求这玩意最小值，就是求 $\min\left(\dfrac{\sum_{i = 1}^n(x_i - \overline{x}) ^ 2}{n}\right)$。

很好，接下来，先展开这玩意：

$\dfrac{\sum_{i = 1}^n(x_i^2 - 2x_i\overline{x} + \overline{x} ^ 2)}{n}$

$ = \dfrac{\sum_{i = 1}^nx_i^2 - 2\overline{x}\sum_{i = 1}^nx_i + \sum_{i = 1}^n\overline{x} ^ 2}{n}$。

$As$ $we$ $know$，$\overline{x} = \dfrac{\sum_{i = 1}^nx_i}{n}$，那么由这个不就是可以得到：

$n\overline{x} = \sum_{i = 1}^nx_i$ 和 $\sum_{i = 1}^n\overline{x} = n\overline{x}$。

那么原式 $ = \dfrac{\sum_{i = 1}^nx_i^2 - 2n\overline{x}^2 + n \overline{x}^2}{n}$

$ = \dfrac{\sum_{i = 1}^nx_i^2}{n} - \overline{x}^2$。

很明显，$\overline{x}$ 不会变，相当于只需要求 $x_i^2$ 的最小值即可。

式子化简完了，接下来就是求这玩意了。

这很明显是二维的区间 dp。

设 $dp_{i, x1, x2, y1, y2}$ 表示切了 i 次后，坐标在 $(x1, y1)$ 与 $(x2, y2)$ 之前的最大值。

很明显，我们有两种切法：

1.横着切，那么我们如果横着切完后，将上半部分拿去切，那么所获得的价值为:

$dp_{i - 1, x1, y1, k, y2} + sum_{k + 1, y1, x2, y2} ^2$。

若是将下半部分再拿去切，那么所获得的价值为：

$sum_{x1, x2, k, y2} ^ 2 + dp_{i - 1, k + 1, y1, x2, y2}$。


2.竖着切，这玩意和横着切差不多，这里不再赘述。

这边这直接给出整理完的方程：

横着切：

$dp_{i, x1, y1, x2, y2} = \min(dp_{i, x1, y1, x2, y2}, dp_{i - 1, x1, y1, k, y2} + sum_{k + 1, y1, x2, y2} ^2, sum_{x1, x2, k, y2} ^ 2 + dp_{i - 1, k + 1, y1, x2, y2})$。

竖着切：

$dp_{i, x1, y1, x2, y2} = \min(dp_{i, x1, y1, x2, y2}, dp_{i - 1, x1, y1, x2, k} + sum_{x1, k + 1, x2, y2}, sum_{x1, y1, x2, k} ^ 2 + dp_{i - 1, x1, k + 1, x2, y2})$。

## 细节：

注意一下开 long double 即可。

输出用 %Lf。

## 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#define ll long long
#define lb long double
#define inf 0x3f3f3f3f

using namespace std;

int n;

ll a[10][10];

ll sum[10][10];

ll dp[22][10][10][10][10];

inline ll mina(ll a, ll b) {
	if (a < b)
		return a;
	return b;
}

int main() {
	scanf("%d", &n);
	
	for (int i = 1; i <= 8; i ++) {
		for (int j = 1; j <= 8; j ++)
			scanf("%d", &a[i][j]);
	}
	
	for (int i = 1; i <= 8; i ++) {
		for (int j = 1; j <= 8; j ++)
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];
	}
	
	memset(dp, inf, sizeof(dp));				 
	
	for (int i = 1; i <= 8; i ++) {
		for (int j = 1; j <= 8; j ++) {
			for (int x = i; x <= 8; x ++) {
				for (int y = j; y <= 8; y ++)
					dp[0][i][j][x][y] = (sum[x][y] - sum[i - 1][y] - sum[x][j - 1] + sum[i - 1][j - 1]) * (sum[x][y] - sum[i - 1][y] - sum[x][j - 1] + sum[i - 1][j - 1]); 
			}
		}
	}
	
	for (int i = 1; i < n; i ++) {
		for (int x1 = 1; x1 <= 8; x1 ++) {
			for (int y1 = 1; y1 <= 8; y1 ++) {
				for (int x2 = x1; x2 <= 8; x2 ++) {
					for (int y2 = y1; y2 <= 8; y2 ++) {
						
						//cout << dp[i][x1][y1][x2][y2] << endl;
						
						for (int k = x1; k < x2; k ++) {
							dp[i][x1][y1][x2][y2] = mina(dp[i][x1][y1][x2][y2], mina(dp[i - 1][x1][y1][k][y2] + dp[0][k + 1][y1][x2][y2], dp[0][x1][y1][k][y2] + dp[i - 1][k + 1][y1][x2][y2]));
							
							//printf("%d %d %d %d %d %d %d\n",i, x1, y1, x2, y2, k, dp[i][x1][y1][x2][y2]);
						} 
							
						for (int k = y1; k < y2; k ++) {
							dp[i][x1][y1][x2][y2] = mina(dp[i][x1][y1][x2][y2], mina(dp[i - 1][x1][y1][x2][k] + dp[0][x1][k + 1][x2][y2], dp[0][x1][y1][x2][k] + dp[i - 1][x1][k + 1][x2][y2]));
							
							//printf("%d %d %d %d %d %d %d\n",i, x1, y1, x2, y2, k, dp[i][x1][y1][x2][y2]);
						}
					} 
				}
			}
		}
	}
	
	ll tmp = dp[n - 1][1][1][8][8];
	
	lb ans = (lb)1.0 * tmp / n - (lb)(1.0 * sum[8][8] * sum[8][8]) / n / n;
	
	printf("%0.3Lf\n", sqrt(ans));
	
	return 0;
}
```

$Atlantis.$

---

## 作者：djh123 (赞：1)

考虑均方差 
$$\sigma=\sqrt {\frac{\sum_{i=1}^n(x_i-\overline x)^2}{n}}$$
其中
$$
\overline x=\frac{\sum_{i=1}^n x_i}{n}
$$
我们有
$$
\sum_{i=1}^n x_i = \sum_{i=1}^8\sum_{j=1}^8 a_{i,j}
$$
代入原式
$$
\overline x = \frac{\sum_{i=1}^8\sum_{j=1}^8 a_{i,j}}{n}
$$
所以 $\overline x$ 是一个常数。

我们把均方差平方展开

$$
\sigma=\sqrt {\frac{\sum_{i=1}^n x_i^2-2x_i\overline x+\overline x^2}{n}}
$$

$$
=\sqrt {\frac{\sum_{i=1}^n x_i^2}{n}-2\overline x^2+\overline x^2}
$$

$$
=\sqrt {\frac{\sum_{i=1}^n x_i^2}{n}-\overline x^2}
$$

因为 $\overline x$ 是一个常数，所以我们只要求最小化 $\sum_{i=1}^n x_i^2$ 即可。

设 $f_{i,ax,ay,ax,by}$ 表示当前分割成 $i$ 块，当前一块的矩形的左上角是 $(ax,ay)$，右下角是 $(bx, by)$ 时的最下平方和。

转移时只需要枚举是横着切还是竖着切，具体切在哪里就行。维护一个前缀和就可以快速转移了。

复杂度$O(8^5n)$

```cpp
#include <bits/stdc++.h>
using namespace std;

#define rep(i, x, y) for(int i = (x); i <= (y); ++ i)
#define rop(i, x, y) for(int i = (x); i <  (y); ++ i)
#define per(i, x, y) for(int i = (x); i >= (y); -- i)
#define por(i, x, y) for(int i = (x); i >  (y); -- i)

const int inf = 0x3f3f3f3f;

int S[10][10];
int a[10][10];
int f[20][10][10][10][10];

int get(int ax, int ay, int bx, int by) {
	return S[bx][by] - S[ax - 1][by] - S[bx][ay - 1] + S[ax - 1][ay - 1];
}

int get2(int ax, int ay, int bx, int by) {
	return get(ax, ay, bx, by) * get(ax, ay, bx, by);
}

int main() {
	int n; scanf("%d", &n);
	rep(i, 1, 8) rep(j, 1, 8) scanf("%d", &a[i][j]), S[i][j] = a[i][j] + S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1];
	memset(f, inf, sizeof(f)); int fans = inf;
	f[1][1][1][8][8] = get2(1, 1, 8, 8);
	rep(i, 2, n) rep(ax, 1, 8) rep(ay, 1, 8) rep(bx, ax, 8) rep(by, ay, 8) {
		rop(cx, ax, bx) {
			f[i][ax][ay][cx][by] = min(f[i][ax][ay][cx][by], f[i - 1][ax][ay][bx][by] - get2(ax, ay, bx, by) + get2(ax, ay, cx, by) + get2(cx + 1, ay, bx, by));
			f[i][cx + 1][ay][bx][by] = min(f[i][cx + 1][ay][bx][by], f[i - 1][ax][ay][bx][by] - get2(ax, ay, bx, by) + get2(ax, ay, cx, by) + get2(cx + 1, ay, bx, by));
		}
		rop(cy, ay, by) {
			f[i][ax][ay][bx][cy] = min(f[i][ax][ay][bx][cy], f[i - 1][ax][ay][bx][by] - get2(ax, ay, bx, by) + get2(ax, ay, bx, cy) + get2(ax, cy + 1, bx, by));
			f[i][ax][cy + 1][bx][by] = min(f[i][ax][cy + 1][bx][by], f[i - 1][ax][ay][bx][by] - get2(ax, ay, bx, by) + get2(ax, ay, bx, cy) + get2(ax, cy + 1, bx, by));
		}
	}
	rep(ax, 1, 8) rep(ay, 1, 8) rep(bx, ax, 8) rep(by, ay, 8) fans = min(fans, f[n][ax][ay][bx][by]);
	printf("%.3f\n", sqrt(1.0 * fans / n - 1.0 * S[8][8] * S[8][8] / n / n));
}
```











---

## 作者：glorious_dream (赞：0)


### 算法分析：

看到这是一个 $8 * 8$ 的矩阵，然后结合给你的式子，很容易想到这是一个二维区间 DP。

先看一下式子：要使 $\sigma = \sqrt{\frac{\sum_{i=1}^{n} \left ( xi -\bar{x}\right ) ^{2}}{n}}$ 最小， $\frac{\sum_{i=1}^{n} \left ( xi -\bar{x}\right ) ^{2}}{n}$  就要最小。把括号展开：

## $\frac{\sum_{i=1}^{n} \left ( xi -\bar{x}\right ) ^{2}}{n}$ =  $\frac{\sum_{i=1}^{n} \left ( xi^{2} - 2\bar{x}xi + \bar{x}^{2}\right )}{n}$ = $\frac{\sum_{i=1}^{n} xi^{2} }{n} - \bar{x}^{2}$

由于 $\bar{x}^{2}$ 是定值，所以只要满足 ${\sum_{i=1}^{n} xi^{2} }$ 最小，也就是平方和最小即可。

设 $dp[lx][ly][rx][ry][k]$ 表示在以 $(lx,ly)$ 为左上角，$(rx,ry)$ 为右下角的矩形切 $k$ 刀的最小平方和。

状态转移方程：

$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],dp[x1][y1][k][y2][i-1]+sum(k+1,y1,x2,y2));$

$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],sum(x1,y1,k,y2)+dp[k+1][y1][x2][y2][i-1]);$

$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],dp[x1][y1][x2][k][i-1]+sum(x1,k+1,x2,y2));$

$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],sum(x1,y1,x2,k)+dp[x1][k+1][x2][y2][i-1]);$

来看什么意思：

$sum(x1,y1,x2,y2)$ 表示 $(x1,y1)$ 为左上角，$(x2,y2)$ 为右下角的矩形的均值

于是有如下求 $sum$ 函数代码：

```cpp
double sum(int x1,int y1,int x2,int y2){ //一定注意用double
    double res = s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
    return res*res/n;
}
```

这时候我们就会想到，在主函数里面应该用一个二维前缀和，求出矩形的前缀和。

```cpp
for(register int i(1) ; i<=8 ; i=-~i){
    for(register int j(1) ; j<=8 ; j=-~j){
        a[i][j] = read();
        s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
    }
}
```


------------


$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],dp[x1][y1][k][y2][i-1]+sum(k+1,y1,x2,y2));$

$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],sum(x1,y1,k,y2)+dp[k+1][y1][x2][y2][i-1]);$

表示横切，分两类考虑，第一类是从 $k$ 切完了要 $k$ 上面部分，第二类是要下面部分，两个部分加上 $sum$ 求出该次操作的均值，取最小值。


------------


$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],dp[x1][y1][x2][k][i-1]+sum(x1,k+1,x2,y2));$

$dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],sum(x1,y1,x2,k)+dp[x1][k+1][x2][y2][i-1]);$

表示纵切，同样分两类考虑，和上面的横切类似。

最后要注意细节：$dp[x1][y1][x2][y2][1]$ 要先等于 $sum(x1,y1,x2,y2) $；转移前先把 $dp$ 数组的值设为正无穷。

------------


最后贴上总代码

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
inline int read(){ //快速不解释
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
    return x*f;
}
const int M = 10;
const int inf = 0x7f7f7f; //正无穷
double dp[M][M][M][M][15]; //别忘了要用double
int s[M][M],a[M][M];
int n;
double x;
double sum(int x1,int y1,int x2,int y2){ //如上文说的
    double res = s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];
    return res*res/n;
}
int main(){
    n=read();
    for(register int i(1) ; i<=8 ; i=-~i){
        for(register int j(1) ; j<=8 ; j=-~j){
            a[i][j] = read();
            x+=a[i][j];
            s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]; //前缀和
        }
    }
    x/=n;
    for(register int x1=1 ; x1<=8 ; x1=-~x1){
        for(register int y1=1 ; y1<=8 ; y1=-~y1){
            for(register int x2=x1 ; x2<=8 ; x2=-~x2){
                for(register int y2=y1 ; y2<=8 ; y2=-~y2){
                    dp[x1][y1][x2][y2][1] = sum(x1,y1,x2,y2); //先赋初值
                }
            }
        }
    }
    for(register int i=2 ; i<=n ; i=-~i){
        for(register int x1=1 ; x1<=8 ; x1=-~x1){
            for(register int y1=1 ; y1<=8 ; y1=-~y1){
                for(register int x2=x1 ; x2<=8 ; x2=-~x2){
                    for(register int y2=y1 ; y2<=8 ; y2=-~y2){
                        dp[x1][y1][x2][y2][i] = inf; //初值正无穷
                        for(register int k(x1) ; k<=x2-1 ; k=-~k){ //开始dp
                            dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],dp[x1][y1][k][y2][i-1]+sum(k+1,y1,x2,y2));
                            dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],sum(x1,y1,k,y2)+dp[k+1][y1][x2][y2][i-1]);
                        }
                        for(register int k(y1) ; k<=y2-1 ; k=-~k){
                            dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],dp[x1][y1][x2][k][i-1]+sum(x1,k+1,x2,y2));
                            dp[x1][y1][x2][y2][i] = min(dp[x1][y1][x2][y2][i],sum(x1,y1,x2,k)+dp[x1][k+1][x2][y2][i-1]);
                        }
                    }
                }
            }
        }
    }
    printf("%.3lf",sqrt(dp[1][1][8][8][n]-x*x));//别忘了减x*x
    return 0;
}

```


---

## 作者：Coros_Trusds (赞：0)

终于从 y 总那里听懂了，于是赶快来写篇题解。

一道区间 DP。

设平均值 $\bar x = \dfrac{\sum_{i=1}^{n}x_i}{n}$，

方差 $\sigma = \sqrt{\dfrac{\sum_{i=1}^{n}\times (x_i-\bar x)^2}{n}}$

由于我们要使方差 $\sigma$ 最小，那么不妨将方差平方后再进行化简（过程我会写的有些繁琐，可以跳着看）：

$\sigma^2=\dfrac{\sum_{i=1}^{n}\times (x_i-\bar x)^2}{n}$

$\sigma^2=\dfrac{1}{n}\times (\sum_{i=1}^{n}\times({x_i}^2 +{\bar x}^2 - 2\times x_i\times \bar x))$

$\sigma^2 = \frac{1}{n}(\sum_{i=1}^n{x_i}^2 - 2\sum_{i=1}^nx_i\times\bar{x} + \sum_{i=1}^n\bar{x}^2)$

$\sigma^2 = \frac{1}{n}\sum_{i=1}^nx_i^2 - 2\bar{x}\times\frac{1}{n}\sum_{i=1}^nx_i + \frac{1}{n}\times n\bar{x}^2$

发现第二项的 $\frac{1}{n}\sum_{i=1}^nx_i$ 正好就是 $\bar x$，于是：

$\sigma^2 = \frac{1}{n}\sum_{i=1}^nx_i^2 - 2\overline{x}^2 + \bar{x}^2$

$\sigma^2 = \frac{1}{n}\sum_{i=1}^nx_i^2 - \bar{x}^2$

$\bar x$ 很明显是一个可以马上求出的数，并且我们需要频繁地求矩阵和，所以考虑使用二维前缀和 $O(1)$ 查询矩阵和，大大加快了效率。

在这篇题解中，我们采用 $(x1,y1,x2,y2)$ 的方式表示一个矩阵，其右上角为 $(x1,y1)$，右下角为 $(x2,y2)$。

令 $dp[a][b][c][d][k]$ 表示划分到 $k-1$ 个的子矩阵，是以 $(a,b)$ 为左上角，$(c,d)$ 为右下角。

我们可以采用记忆化方法来完成此过程。

```cpp
//2021/8/9

#include <iostream>

#include <cstdio>

#include <cmath>

#include <cstring>

#include <algorithm>

#define debug(c) cerr<<#c<<"="<<c<<endl

using namespace std;

const int ma=10,maxn=16;

const double INF=1e9;

int n;

int sum[ma][ma];

double dp[ma][ma][ma][ma][maxn];

double bar;//平均值 

//如果是C++11可以这样，但是有些编译器因为这里又有cmath又有y1 y2，会CE 
//当然就算报错，换个名就好了
 
inline double getsum(int x1,int y1,int x2,int y2)
{
	double res=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]-bar;
	
	return res*res;
}

inline double dfs(int x1,int y1,int x2,int y2,int k)//记忆化方法 
{
	double &tmp=dp[x1][y1][x2][y2][k];
	
	if(tmp>=0)
	{
		return tmp;
	}
	
	if(k==1)
	{
		return getsum(x1,y1,x2,y2);
	}
	
	tmp=INF;
	
	//横着去切 
	
	for(register int i=x1;i<x2;i++)
	{
		tmp=min(tmp,dfs(x1,y1,i,y2,k-1)+getsum(i+1,y1,x2,y2));
		
		tmp=min(tmp,dfs(i+1,y1,x2,y2,k-1)+getsum(x1,y1,i,y2)); 
	}
	
	//竖着去切 
	
	for(register int i=y1;i<y2;i++)
	{
		tmp=min(tmp,dfs(x1,y1,x2,i,k-1)+getsum(x1,i+1,x2,y2));
		
		tmp=min(tmp,dfs(x1,i+1,x2,y2,k-1)+getsum(x1,y1,x2,i));
	}
	
	return tmp;
}

int main(void)
{
	scanf("%d",&n);
	
	for(register int i=1;i<=8;i++)
	{
		for(register int j=1;j<=8;j++)
		{
			scanf("%d",&sum[i][j]);
			
			sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		}
	}
	
	memset(dp,-1,sizeof(dp));
	
	bar=(double)sum[8][8]/n;
	
	printf("%.3lf\n",sqrt(dfs(1,1,8,8,n)/n));
	
	return 0;
}
```

---

## 作者：CodingJellyfish (赞：0)

本题解是由水母哥编写的低常数代码，可以拿到最优解的第一名。基本思路和其他题解大致相同。

-----

本题和 [P1436](https://www.luogu.com.cn/problem/P1436) 基本一致。可以通过区间 dp 先算出小区间的最优方案，再通过将大区间横切或纵切成两个小区间，从这些小区间算出大区间的最优方案。

然而本题的结果输出和 P1436 不完全相同。不过可以证明 方差的平方 等于 每个子区间的平方和的平均数 - 整个矩阵平均数的平方。

所以只需要计算 整个矩阵平均数 和 每个子区间的平方和的最小值。

每个子区间的平方和的最小值就是 P4419 的答案，所以两题别无二致。

常数优化将在代码注释中讲述。

下面贴出代码：

```c
#include <math.h>
#include <stdio.h>
#include <string.h>
#define MAXM 9
#define MAXN 16
#define MIN(a,b) ((a)<(b)?(a):(b))
int dp[MAXM][MAXM][MAXM][MAXM][MAXN];
int a[MAXM][MAXM], sum[MAXM][MAXM];

int main(void)
{
	memset(dp, 0x63, sizeof(dp));
	int n, leni, lenj, i, j, k, l, t, cut;
	scanf("%d", &n);
	for (i = 1; i < MAXM; i++) {
		for (j = 1; j < MAXM; j++) {
			scanf("%d", &a[i][j]);
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] -
						sum[i - 1][j - 1] + a[i][j]; // 计算前缀和，便于快速计算子矩阵元素和。
		}
	}
	for (i = 1; i < MAXM; i++) {
		for (j = 1; j < MAXM; j++) {
			for (k = i; k < MAXM; k++) {
				for (l = j; l < MAXM; l++) {
                	// 计算不分割时的分数。
                    // 把和存起来再求平方，可以减少计算次数。
					int sum1 = sum[k][l]
							 - sum[i - 1][l]
							 - sum[k][j - 1]
							 + sum[i - 1][j - 1];
					dp[i][j][k][l][0] = sum1 * sum1;
				}
			}
		}
	}
    
    // 非递归求解
    
	for (leni = 1; leni < MAXM; leni++) {
		for (lenj = 1; lenj < MAXM; lenj++) {
			for (i = 1, k = leni + i - 1; k < MAXM; i++, k++) {
				for (j = 1, l = lenj + j - 1; l < MAXM; j++, l++) {
                	// 横切。
					for (cut = i; cut < k; cut++) {
                    	// 在循环外求前缀和。减少计算次数。
						int sum1 = sum[k][l]
								 - sum[cut][l]
								 - sum[k][j - 1]
								 + sum[cut][j - 1];
						int sum2 = sum[cut][l]
								 - sum[i - 1][l]
								 - sum[cut][j - 1]
								 + sum[i - 1][j - 1]; 
						int sq1 = sum1 * sum1;
						int sq2 = sum2 * sum2;
						for (t = 1; t < n; t++) {
                            // 转移。
							int val1 = dp[i][j][cut][l][t - 1] +
									   sq1;
							int val2 = dp[cut + 1][j][k][l][t - 1] +
									   sq2;
							int now = MIN(val1, val2);
							dp[i][j][k][l][t] = MIN(dp[i][j][k][l][t], now);
						}
					}
                    // 纵切
					for (cut = j; cut < l; cut++) {
						int sum1 = sum[k][l]
								 - sum[k][cut]
								 - sum[i - 1][l]
								 + sum[i - 1][cut];
						int sum2 = sum[k][cut]
								 - sum[k][j - 1]
								 - sum[i - 1][cut]
								 + sum[i - 1][j - 1];
						int sq1 = sum1 * sum1;
						int sq2 = sum2 * sum2;
						for (t = 1; t < n; t ++) {
							int val1 = dp[i][j][k][cut][t - 1]
									 + sq1;
							int val2 = dp[i][cut + 1][k][l][t - 1]
									 + sq2;
							int now = MIN(val1, val2);
							dp[i][j][k][l][t] = MIN(dp[i][j][k][l][t], now);
						}
					}
				}
			}
		}
	}
    // 计算方差。
	double ans = (double)dp[1][1][MAXM - 1][MAXM - 1][n - 1] / (double)n;
	printf("%.3lf", sqrt(ans - (double)sum[8][8] * (double)sum[8][8]/ (double)n/(double)n));
	return 0;
}

```

----


今天的讲解就到这里，是不是觉得收获满满呢，别忘了消化吸收知识点哦。 我是水母哥，下次见哦！


---

## 作者：ListenSnow (赞：0)

## 题意
给定一个 $8*8$ 的棋盘，棋盘上的每一个位置都有一个数。将棋盘水平或竖直切一刀，将**剩下**的一部分继续分割（也就是不能在两个子棋盘里面**同时**分割），直至棋盘被分成 $n$ 个部分，每一个部分的分值为其中的数字之和。求出**最小**的均方差值。

均方差 $\sigma=\sqrt{\dfrac{ {\textstyle \sum_{i=1}^{n}} (x_i-\overline{{x}} )^2\ }{n} } $，其中 $\overline{x}=\dfrac{ {\textstyle \sum_{i=1}^{n}}x_i }{n}  $，$x_i$ 表示第 $i$ 个棋盘内的数字之和。

## 思路

首先可以发现对于 $\overline{x}$ 的计算，${\textstyle \sum_{i=1}^{n}}x_i$ 一定为一个定值，也就是棋盘中所有数之和。也就是说，$\overline{x}$ 的值是确定的，可以先预处理出来。

定义 $s[i][j]$ 表示左上角为 $(1,1)$ 右下角为 $(i,j)$ 的棋盘中的数之和，也就是**二维前缀和**，这样就可以先预处理出一遍 $s$ 数组，之后就可以在 $O(1)$ 的时间内求出一个子棋盘的数字和。

定义 $f[x1][y1][x2][y2][k]$ 表示将左上角坐标为 $(x1,y1)$ ，右下角坐标为 $(x2,y2)$ 的子棋盘分割成 $k$ 个棋盘的最小值。这里的最小值定义为 $min(\dfrac{\sum (x_i-\overline{x} )^2}{n} )$ ，最终只要在输出答案的时候开平方就可以了。

考虑状态转移方程。这个比较简单。可以枚举分割线的位置，同时为了满足题目中不能同时分割本次分割后的两个子棋盘。所以一定是一边继续分割，另一边只能当一个棋盘，即：

$f[x1][y1][x2][y2][k]=min(f[x1][y1][i][y2][k-1]+get(i+1,y1,x2,y2),f[i+1][y1][x2][y2][k-1]+get(x1,y1,i,y2))$ $(x1 \leq i \leq x2-1)$ 。

其中 $get$ 函数用来求出**一个**子棋盘的 $\dfrac {(x-\overline{x})^2}{n}$。
这里给出的是枚举竖直方向分割棋盘，水平方向分割与此同理。

蒟蒻用的是记忆化搜索，因为比较好处理出子矩阵的值，同时也可以减少码量（
~~其实就是懒~~）。

最终别忘了特判 $k=1$ 的情况，只要返回 $get$ 函数就行了。

## code：
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int N=20;
const int M=10;
const double INF=1e18;
double s[M][M],X,f[M][M][M][M][N],n;
double min(double a,double b){return a<b?a:b;}
double NLC(int x1,int y1,int x2,int y2)
{
	double sum=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]-X;
	return (double)sum*sum/n;
}
double dfs(int x1,int y1,int x2,int y2,int k)
{
	double &now=f[x1][y1][x2][y2][k]; //用一个值来代表f[x1][y1][x2][y2][k]比较方便
	if(now>=0) return now;
	if(k==1) return now=NLC(x1,y1,x2,y2);
	now=INF;
	for(int i=x1;i<x2;i++)
	{
		now=min(now,dfs(x1,y1,i,y2,k-1)+NLC(i+1,y1,x2,y2));
		now=min(now,NLC(x1,y1,i,y2)+dfs(i+1,y1,x2,y2,k-1));
	}
	for(int j=y1;j<y2;j++)
	{
		now=min(now,dfs(x1,y1,x2,j,k-1)+NLC(x1,j+1,x2,y2));
		now=min(now,NLC(x1,y1,x2,j)+dfs(x1,j+1,x2,y2,k-1));
	}
	return now;
}
int main()
{
	scanf("%lf",&n);
	for(int i=1;i<=8;i++)
		for(int j=1;j<=8;j++)
	        {
	        	scanf("%lf",&s[i][j]);
	        	s[i][j]=s[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
			} 
	memset(f,-1,sizeof(f));// double类型数组，如果memset中写1会赋值成一个很奇怪的数值 
	X=s[8][8]/n; 
	printf("%.3lf\n",sqrt(dfs(1,1,8,8,n)));
	return 0;
}
```

[双倍经验](https://www.luogu.com.cn/problem/P1436)。（这道蓝题其实更水。。）

---

## 作者：pengyule (赞：0)

**upd:之前公式中有个小细节写反了，已更正，望管理通过**

**upd2:之前公式炸了，现在已调整**

本题解可视作 @zhangboju 题解的补充和简化。

$\sigma=\sqrt \dfrac{\sum_{i=1}^n(x_i-\overline{x})}{n},\sigma^2= \dfrac{\sum_{i=1}^n(x_i-\overline{x})}{n}=\dfrac{\sum_{i=1}^nx_i^2}{n}-\overline{x}^2$，发现 $\overline{x}=\dfrac{\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i,j}}{n}$，故 $\sigma^2$ 随 $x_i$ 的减小而减小。

算法：区间 DP

状态：$F_{x1,y1,x2,y2,i}$ 表示对于左上角、右下角坐标分别为 $(x1,y1),(x2,y2)$ 的子矩阵且 $n=i$ 时的子问题的解

转移：

$$
F_{x1,y1,x2,y2,i}=
\min \begin{cases}
\min\limits_{k\in[x1,x2)}\begin{cases}F_{x1,y1,x2,y2,i},F_{x1,y1,k,y2,i-1}+S_{k+1,y1,x2,y2}\\F_{x1,y1,x2,y2,i},S_{x1,y1,k,y2}+F_{k+1,y1,x2,y2,i-1}\end{cases}\\
\min\limits_{k\in[y1,y2)}\begin{cases}F_{x1,y1,x2,y2,i},F_{x1,y1,x2,k,i-1}+S_{x1,k+1,x2,y2}\\F_{x1,y1,x2,y2,i},S_{x1,y1,x2,k}+F_{x1,k+1,x2,y2,i-1}\end{cases}
\end{cases}
$$

$S_{x1,y1,x2,y2}$ 表示左上角、右下角坐标分别为 $(x1,y1),(x2,y2)$ 的子矩阵的分值。上面的转移方程说白了就是横向和纵向分割，每一次分割考虑取哪半边为要继续分割的子问题，并转移。

代码：（代码中的 `get()` 就是 $S$）

```cpp
#include <bits/stdc++.h>
#define rep(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
int a[10][10],s[10][10];
double f[10][10][10][10][20];
int n;
double av=0;
double get(int x1,int y1,int x2,int y2){
	return (s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1])*(s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1])/(double)n;
}
int main()
{
	cin>>n;
	rep(i,1,8) rep(j,1,8){
		cin>>a[i][j]; av+=a[i][j];
		s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
	}
	av/=n;
	rep(x1,1,8) rep(y1,1,8) rep(x2,x1,8) rep(y2,y1,8) f[x1][y1][x2][y2][1]=get(x1,y1,x2,y2);
	rep(i,2,n) rep(x1,1,8) rep(y1,1,8) rep(x2,x1,8) rep(y2,y1,8){
	    f[x1][y1][x2][y2][i]=1e9;
		rep(k,x1,x2-1){
			f[x1][y1][x2][y2][i]=min(f[x1][y1][x2][y2][i],f[x1][y1][k][y2][i-1]+get(k+1,y1,x2,y2));
			f[x1][y1][x2][y2][i]=min(f[x1][y1][x2][y2][i],get(x1,y1,k,y2)+f[k+1][y1][x2][y2][i-1]);
		}
		rep(k,y1,y2-1){
			f[x1][y1][x2][y2][i]=min(f[x1][y1][x2][y2][i],f[x1][y1][x2][k][i-1]+get(x1,k+1,x2,y2));
			f[x1][y1][x2][y2][i]=min(f[x1][y1][x2][y2][i],get(x1,y1,x2,k)+f[x1][k+1][x2][y2][i-1]);
		}
	}
	printf("%.3lf\n",sqrt(f[1][1][8][8][n]-av*av));
	return 0;
}
```

多嘴一句，之前我写的 `memset(f,0x3f,sizeof(0x3f))` 并不能达到赋正无穷的效果，具体为啥（不知道），长个记性吧……

---

## 作者：vеctorwyx (赞：0)

闲话：

算了半天才推出来/kk，巩队爆切，实在太强辣！

### $SOL$

先看数据范围，$n\le 15$，矩阵大小为8，大概是~~暴力~~搜索或$dp$，再看题面，区间划分，考虑$dp$。

矩阵+小数据范围，我们可以多设几维的状态，这里提供5维的做法：

1. 存什么？（我一开始把式子拆成了好几个可以转移部分，但明显不好dp）

	对均方差操作：
    
    $\Large \sigma = \sqrt{ \frac{ \sum_{i=1}^n (x_i - \bar x)^2 } { n }}$
    
    可以先求方差再开平方：
    
    $\Large \sigma^2 =  \frac{ \sum_{i=1}^n (x_i - \bar x)^2 } { n }$
    
    ~~众所周知~~（其实我在这里卡了很久，我太菜了），$\large\bar x$ 可以表示为
    
    $\Large\bar x= \frac{ \sum_{i=1}^n x_i}{n}$
    
    也就是说无论怎么分割，最后$\large \bar x$一定为所以格点上的值的和除以$n$，是一个定值，用公式表示：
    
    $\Large\bar x=\frac{\sum_{i=1}^8\sum_{j=1}^8 a_{i,j}}{n}$
    
    所以可以提前求出来$\large\bar x$，算的时候直接用。
    
    这样$\large\sigma^2$也就很好求了，也可以不去除$n$，最后再除$n$，~~常数小~~，也就是先求$n\large\sigma^2$；
    
    得到状态：$dp_{i,j,k,l,o}$表示以$(i,j)$为左上角，以$(k,l)$为右下角的矩阵割$o$次的最小方差乘n。
    
2. 怎么转移？

	考虑把以$(i,j)$为左上角，以$(k,l)$为右下角的矩阵分成两部分进行转移，这两部分可能是上下分的，也可能是左右分的。
    
    那就枚举中间断点，进行转移，一部分分割了$o-1$次，另一部分分割了$1$次。
    
    特别的，如果$o=1$，直接求$(x_i-\bar x)^2$就好了。
		求$x_i$的时候可以用前缀和优化，~~暴力枚举应该也能卡过去~~。
    
最后答案就是$\large\sqrt{\frac{dp_{1,1,8,8,n}}{n}}$，时间复杂度$O(8^5n)$。


code：

```
#include<bits/stdc++.h>
#define fo(i , j , k) for(int i = j ; i <= k ; i++)
#define go(i , j , k) for(int i = j ; i >= k ; i++)
using namespace std;
int read(){
	int x= 0,y = 1;char c = getchar();
	while(c < '0'||c > '9'){if(c == '-')y = -1;c = getchar();}
	while(c >= '0'&&c <= '9'){x = (x << 1) + (x << 3) + c - '0';c = getchar();}
	return x * y;
}
int n , a[10][10],pre[10][10];
double ave;
double dp[10][10][10][10][17];
int main(){
	n = read();
	fo(i , 1 , 8)
		fo(j , 1 , 8)
			a[i][j] = read() , pre[i][j] = pre[i][j - 1] + pre[i - 1][j] - pre[i - 1][j - 1] + a[i][j];//前缀和
	ave = pre[8][8] * 1.0 / n;//平均值
	fo(t , 1 , n){
		fo(i , 1 , 8){
			fo(j , 1 , 8){
				fo(k , 1 , 8){
					fo(l , 1 , 8){
						dp[i][j][k][l][t] = 10000010;//初值赋为极大
						if(t == 1){//特殊处理
							dp[i][j][k][l][t] = pre[i - 1][j - 1] + pre[k][l] - pre[i - 1][l] - pre[k][j - 1] - ave;
							dp[i][j][k][l][t] *= dp[i][j][k][l][t];
							continue;
						}
						fo(x1 , i , k - 1){//枚举纵向断点
							dp[i][j][k][l][t] = min(dp[i][j][x1][l][t - 1] + dp[x1 + 1][j][k][l][1] , dp[i][j][k][l][t]);
							dp[i][j][k][l][t] = min(dp[i][j][x1][l][1] + dp[x1 + 1][j][k][l][t - 1] , dp[i][j][k][l][t]);
						}
						fo(y1 , j , l - 1){//枚举横向断点
							dp[i][j][k][l][t] = min(dp[i][j][k][y1][t - 1] + dp[i][y1 + 1][k][l][1] , dp[i][j][k][l][t]);
							dp[i][j][k][l][t] = min(dp[i][j][k][y1][1] + dp[i][y1 + 1][k][l][t - 1] , dp[i][j][k][l][t]);
						}
					}
				}
			}
		}
	}
	printf("%.3lf" , sqrt(dp[1][1][8][8][n]*1.0/n));
}
```

---

## 作者：LittleMoMol (赞：0)

## P5752 [NOI1999] 棋盘分割

### 前言

[_来这儿食用效果更好哦_](https://www.cnblogs.com/LittleMoMol-kawayi/p/solution-LuoGu-P5752.html)

看大部分题解里面都是多层循环，看着太壮观啦！我来提供一个不需要循环的方法，用记忆化搜索！

什么？数学公式不会推？这篇题解的方法，根本不用推数学公式！

### 思路

要使 $\sqrt{\dfrac{\sum\limits_{i=1}^{n}(x_1-\overline{x})^2}{n}}$ 最小，也就是使 $\dfrac{\sum\limits_{i=1}^{n}(x_1-\overline{x})^2}{n}$ 最小，考虑怎么快速计算 $\overline{x}$，很显然，可以用二维前缀和计算。

我们令 $f[x_1][y_1][x_2][y_2][k]$ 表示在左上角坐标为 $(x_1,y_1)$ 右下角坐标为 $(x_2,y_2)$ 的矩形中切 $k-1$ 刀分割成了 $k$ 个小矩形后所得的均方差的最小值，那么答案就为 $f[1][1][8][8][n]$。

考虑状态转移方程，由于刀可以横切也可以竖切，而对于横切或者竖切，又有取那一块的选择，所以有四种情况，分别对应下图的甲乙丙丁。

![](https://cdn.luogu.com.cn/upload/image_hosting/c0k5np7s.png)

那么状态转移方程就可以得到了，详见代码注释。

### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

using namespace std;

const int N = 15, M = 9;
const double INF = 1e9;

int n, m = 8;
int s[M][M];
double f[M][M][M][M][N];
double X;

//求块内均方差
double get(int x1, int y1, int x2, int y2)
{
	double sum = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] - X;
	return sum * sum / n;
}

//重点：记忆化搜索
double dp(int x1, int y1, int x2, int y2, int k)
{
	double &v = f[x1][y1][x2][y2][k];
	if (v >= 0) return v;
	if (k == 1) return v = get(x1, y1, x2, y2);
	
    //状态转移方程 始
	v = INF;
	for (int i = x1; i < x2; i ++ ) //枚举纵向切的位置
	{
		v = min(v, dp(x1, y1, i, y2, k - 1) + get(i + 1, y1, x2, y2));//对应图乙
		v = min(v, dp(i + 1, y1, x2, y2, k - 1) + get(x1, y1, i, y2));//对应图甲
	}
	for (int i = y1; i < y2; i ++ ) //枚举横向切的位置
	{
		v = min(v, dp(x1, y1, x2, i, k - 1) + get(x1, i + 1, x2, y2));//对应图丁
		v = min(v, dp(x1, i + 1, x2, y2, k - 1) + get(x1, y1, x2, i));//对应图丙
	}
    //状态转移方程 收
	
	return v;
}

int main()
{
	cin >> n;
    //求二维前缀和
	for (int i = 1; i <= m; i ++ )
		for (int j = 1; j <= m; j ++ )
		{
			cin >> s[i][j];
			s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
		}
	
	memset(f, -1, sizeof f);
	X = (double) s[m][m] / n; //平均数
	
	printf("%.3lf\n", sqrt(dp(1, 1, 8, 8, n)));
	
	return 0;
}
```

---


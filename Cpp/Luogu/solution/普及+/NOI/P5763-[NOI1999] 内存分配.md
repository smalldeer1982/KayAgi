# [NOI1999] 内存分配

## 题目描述

内存是计算机重要的资源之一，程序运行的过程中必须对内存进行分配。

经典的内存分配过程是这样进行的：
1. 内存以内存单元为基本单位，每个内存单元用一个固定的整数作为标识，称为地址。地址从 $0$ 开始连续排列，地址相邻的内存单元被认为是逻辑上连续的。我们把从地址 $i$ 开始的 $s$ 个连续的内存单元称为首地址为 $i$ 长度为 $s$ 的地址片。 
2. 运行过程中有若干进程需要占用内存，对于每个进程有一个申请时刻 $T$ ，需要内存单元数 $M$ 及运行时间 $P$。在运行时间 $P$ 内（即 $T$ 时刻开始，$T+P$ 时刻结束），这 $M$ 个被占用的内存单元不能再被其他进程使用。 
3. 假设在 $T$ 时刻有一个进程申请 $M$ 个单元，且运行时间为 $P$ ，则：

$\qquad$ 1)	若 $T$ 时刻内存中存在长度为 $M$ 的空闲地址片，则系统将这 $M$ 个空闲单元分配给该进程。若存在多个长度为 $M$ 个空闲地址片，则系统将首地址最小的那个空闲地址片分配给该进程。 

$\qquad$ 2)    如果 $T$ 时刻不存在长度为 $M$ 的空闲地址片，则该进程被放入一个等待队列。对于处于等待队列队头的进程，只要在任一时刻，存在长度为 $M$ 的空闲地址片，系统马上将该进程取出队列，并为它分配内存单元。注意，在进行内存分配处理过程中，处于等待队列队头的进程的处理优先级最高，队列中的其它进程不能先于队头进程被处理。 

现在给出一系列描述进程的数据，请编写一程序模拟系统分配内存的过程。


## 样例 #1

### 输入

```
10
1 3 10
2 4 3
3 4 4
4 1 4
5 3 4
0 0 0
```

### 输出

```
12
2
```

# 题解

## 作者：gcwixsxr (赞：51)

#### 似乎这道题没有什么题解,
~~本蒟蒻来水题解啦~~

### ~~~~~~~ 大量文字警告 ~~~~~~~~~

这道题其实可以用链表加上模拟做出来

不妨先看看样例吧

题意可用下列表格表示(大致就这个意思)

![](https://cdn.luogu.com.cn/upload/image_hosting/3c4iv5qw.png)

### **大致思路:**
模拟即可(~~模拟大法好!模拟大法好!模拟大法好!~~)

### **实现过程:**

#### 1.一个队列queue,一个动态数组vector,分别表示等待的队列,和内存条中的状态
```cpp
vector<data> p;//内存条
queue<data> q;//等待队列
```

#### 2.一个结构体data

```cpp
struct data{
    int t,m,p,s;//时刻t,内存占用大小m,运行时间p,以及该数据占用的内存开始的位置s
    bool operator <(const data& x)const{
        return s<x.s;//重载运算符
    }
}x; //定义一个x
```


#### 3.三个函数

(1)work函数:对新输入的数进行操作,在其中分别进行work_in和work_out两个子函数的操作,以及更新最早结束的进程w,同时判断能否推入内存,再推入等待数列的作用

```cpp
void work(int t, int m, int p) {
    while (t >= w) work_out();//如果t已经大于最早可以结束的进程的时刻,那么进入work_out子函数
    x.t = t;
    x.m = m;
    x.p = p;//对x进行更新
    if (work_in(t)) w = min(w, t + p);//如果可以装入内存,则进入子函数work_in,并且更新最早可以结束的进程的时刻
    else q.push(x);//否则推入等待队列
}
```
(2)work_in子函数:判断能否进入内存,并且进行插入内存的操作
分别从第一个进程和内存条最开始之间、相邻两个进程之间、最后一个进程和内存条末之间判断内否插入内存
```cpp
bool work_in(int t) {
    if (p.empty() || p[0].s >= x.m) {//如果p队列为空,或者队列首个进程的开始位置已经比x的占用空间大了,则有机可乘
        x.s = 0;//从内存条第0位开始占用
        x.t = t;//储存时刻t
        p.push_back(x);//推入内存条
        sort(p.begin(), p.end());//排序,将开始位置靠前的放在前面
        return 1;//返回值:可以插入
    }
    for (register int i = 1; i < p.size(); i++)
        if (p[i].s - (p[i-1].s + p[i-1].m) >= x.m) {//判断队列中是否两个进程间的内存大于x的内存(有机可乘)
            x.s = p[i-1].s + p[i-1].m;//从内存条第i-1个进程的下一位开始占用
            x.t = t;//储存时刻t
            p.push_back(x);//推入内存条
            sort(p.begin(), p.end());//排序,将开始位置靠前的放在前面
            return 1;//返回值:可以插入
        }
    int sz = p.size();
    if (n - (p[sz-1].s + p[sz-1].m) >= x.m) {//判断内存条末和最后一个进程之间的内存是否大于x的内存(有机可乘)
        x.s = p[sz-1].s + p[sz-1].m;//从最后一个进程的下一位开始占用
        x.t = t;//储存时刻t
        p.push_back(x);//推入内存条
        sort(p.begin(), p.end());//排序,将开始位置靠前的放在前面
        return 1;//返回值:可以插入
    }
    return 0;//返回值:没有地方可以插入(进入等待队列)
}
```
(3)work_out子函数:将等待队列中的数弹出
```cpp
void work_out() {
    int nw = INF;//将nw定为最大值
    for (register int i = 0; i < p.size(); i++)
        if (p[i].t + p[i].p == w) p.erase(p.begin() + i--);//删除这个进程
        else nw = min(nw, p[i].t + p[i].p);//更新nw为最小值
    while (q.size()) {
        x = q.front();
        if (work_in(w)) {//判断能否进入内存条
            nw = min(nw, q.front().t + q.front().p);//更新
            q.pop();//弹出首位
            cnt++;//计数,统计进入了等待队列的进程
        } else break;
    }
    w = nw;//更新w
}
```
## 下面是完整代码
~~抄代码者看这里~~
```cpp
#include<bits/stdc++.h>
#define INF 0x3fffffff
using namespace std;
int n,w=INF,cnt=0;
struct data{
    int t,m,p,s;
    bool operator <(const data& x)const{
        return s<x.s;
    }
}x; 
vector<data> p;
queue<data> q;
bool work_in(int t) {
    if (p.empty() || p[0].s >= x.m) {
        x.s = 0;
        x.t = t;
        p.push_back(x);
        sort(p.begin(), p.end());
        return 1;
    }
    for (register int i = 1; i < p.size(); i++)
        if (p[i].s - (p[i-1].s + p[i-1].m) >= x.m) {
            x.s = p[i-1].s + p[i-1].m;
            x.t = t;
            p.push_back(x);
            sort(p.begin(), p.end());
            return 1;
        }
    int sz = p.size();
    if (n - (p[sz-1].s + p[sz-1].m) >= x.m) {
        x.s = p[sz-1].s + p[sz-1].m;
        x.t = t;
        p.push_back(x);
        sort(p.begin(), p.end());
        return 1;
    }
    return 0;
}
void work_out() {
    int nw = INF;
    for (register int i = 0; i < p.size(); i++)
        if (p[i].t + p[i].p == w) p.erase(p.begin() + i--);
        else nw = min(nw, p[i].t + p[i].p);
    while (q.size()) {
        x = q.front();
        if (work_in(w)) {
            nw = min(nw, q.front().t + q.front().p);
            q.pop();
            cnt++;
        } else break;
    }
    w = nw;
}
void work(int t, int m, int p) {
    while (t >= w) work_out();
    x.t = t;
    x.m = m;
    x.p = p;
    if (work_in(t)) w = min(w, t + p);
    else q.push(x);
}
int main()
{
    scanf("%d",&n);
    int t0,m0,p0;
    while(scanf("%d%d%d",&t0,&m0,&p0)==3 &&!(t0==0&&m0==0&&p0==0))
        work(t0,m0,p0);
    while(q.size()) work_out();
    int ans=w;
    for(register int i=0;i<p.size();i++)
        ans=max(ans,p[i].t+p[i].p);//统计答案
    printf("%d\n%d\n",ans,cnt);
    return 0;
}
```
本蒟蒻写题解很用心,点个赞再走吧

---

## 作者：KAMIYA_KINA (赞：10)

## 本文提要
文中有许多笔者写题解时口嗨的做法，很多地方需要自己个人认真思考实现的理由与正确性（虽然本题是个模拟），如果说某些地方不太明白，可以私信笔者以得到解答，尽量不要在评论区发有关膜拜一类的话语，以打扰正常的学术交流。

提要到此为止。

## 正文

本题是一道非常好的模拟题，模拟题需要的就是细节的处理和思维的严谨以及大脑的清醒，请不要学习某些同学天天打模拟把脑子给打坏了（甚至拿个小积木到机房模拟立体图）。

我们需要完成的操作。

### 一、模拟地址格
我们可以选择链表来完成这样一个操作，由于数据是 $10^9$，所以我们需要离散化来存储。

具体代码如下:
~~~cpp
struct node{
	int StartPosition,EndPosition;//前者表示开始位置，后者表示结束位置。
	int id;//存储id以用后来的遍历操作做准备
	node() {}
	node(const int x,const int y,const int z) {StartPosition = x,EndPosition = y,id = z;}
};
vector<node> List;//用vector来实现链表，但是插入操作是 O(len) 的，所以会链表的同学还是建议直接用链表来操作。
~~~

### 二、时间轴
时间轴我们可以用一个优先队列来实现，直接把时间优先的放在前面，其他的放在后面搞。

代码如下：
~~~cpp
struct TimeTable{
	int EndTime,id;//前者表示结束时间，后者表示id以干掉前面所提到的链表中的元素
	TimeTable(){}
	TimeTable(const int x,const int y) {EndTime = x,id = y;}	
	bool operator<(const TimeTable&tem)const{return EndTime > tem.EndTime;}//重载运算符用以排序
};
priority_queue<TimeTable>Time_Queue;
~~~

### 三、等待队列
由于等待队列是不要求用时间排序的，而且后进队的元素就算有足够的内存格也不能搞，所以说我们只用在意第一个就可以了。

代码如下：
~~~cpp
struct element { 
	int M,P;//如题意。
	element(){}
	element(const int x,const int y) {M = x,P = y;}
};
deque< element > Wait_Queue;
~~~

### 四、访问函数

然后就是 `solve` 函数的实现了，有了上面的定义，完成下面的代码就不是很难了。

**需要注意细节**

~~~cpp
inline void solve(const int x,const int y,const int z) {
	while(!Time_Queue.empty()) {
		TimeTable tem = Time_Queue.top();
		if(tem.EndTime <= x) slote();//slote函数表示处理应该释放的内存格
		else break;
	}
	tim = x;
	bool flag = true;
	for(int i = 1; i <= l && flag; i++) {
		if(List[i].StartPosition - List[i - 1].EndPosition - 1 >= y) {
			List.insert(List.begin() + i,node(List[i - 1].EndPosition + 1,List[i - 1].EndPosition + y,++tot));//有关这一段，是因为我在开始的时候在 vector 的头部和尾部插入了两个标杆，在下面的完整代码中有解释。
			Time_Queue.push(TimeTable(tim + z,tot));
			l++,flag = false;
		}
 	}
 	if(flag) Wait_Queue.push_back(element(y,z)),ans++;
 	return ;
}
~~~

### 整体代码
~~~cpp
#include<bits/stdc++.h>
#define F(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
using namespace std;
const int N = 1e5 + 1;
struct TimeTable{
	int EndTime,id;
	TimeTable(){}
	TimeTable(const int x,const int y) {EndTime = x,id = y;}	
	bool operator<(const TimeTable&tem)const{return EndTime > tem.EndTime;}
};
priority_queue<TimeTable>Time_Queue;
struct element { 
	int M,P;
	element(){}
	element(const int x,const int y) {M = x,P = y;}
};
deque< element > Wait_Queue;
struct node{
	int StartPosition,EndPosition;
	int id;
	node() {}
	node(const int x,const int y,const int z) {StartPosition = x,EndPosition = y,id = z;}
};
vector<node> List;
int n,tim,ans,l;
int tot;
inline void input() {
	scanf("%d",&n);
	return ;
}
inline bool AskForWaitQueue() {//访问等待队列的元素
	if(Wait_Queue.empty()) return false;
	element tem = Wait_Queue.front();
	for(int i = 1; i <= l; i++) {
		if(List[i].StartPosition - List[i - 1].EndPosition - 1 >= tem.M) {
			Wait_Queue.pop_front();//找到就直接弹出
			List.insert(List.begin() + i,node(List[i - 1].EndPosition + 1,List[i - 1].EndPosition + tem.M,++tot));
			Time_Queue.push(TimeTable(tim + tem.P,tot));
			l++;
			return true;//如果说可以塞得话就再看看能不能再塞。
		}
	}
	return false;
}
inline void slote() {//这里是可以直接弹出的
	TimeTable tem = Time_Queue.top();Time_Queue.pop();
	tim = tem.EndTime;
	for(int i = 1; i <= l; i++) {
		if(List[i].id == tem.id) {
			List.erase(List.begin() + i);
			l--;
			break;
		}
	}
	if(Time_Queue.empty()) goto D;//如果说当前的时间轴直接空了就跳向D点，goto的用法类似于windows中的goto
	tem = Time_Queue.top();
	if(tem.EndTime == tim) slote();//同一时间点的内存格全部一起搞出来，如果没有的话很有可能会因为出优先队列的顺序原因导致插入等待队列中的内存格的时候位置不对。
	D:;//这里就是跳向的地方。
	while(AskForWaitQueue());//一直往里塞
	return ;
}
inline void solve(const int x,const int y,const int z) {
	while(!Time_Queue.empty()) {
		TimeTable tem = Time_Queue.top();
		if(tem.EndTime <= x) slote();
		else break;
	}
	tim = x;
	bool flag = true;
	for(int i = 1; i <= l && flag; i++) {
		if(List[i].StartPosition - List[i - 1].EndPosition - 1 >= y) {
			List.insert(List.begin() + i,node(List[i - 1].EndPosition + 1,List[i - 1].EndPosition + y,++tot));
			Time_Queue.push(TimeTable(tim + z,tot));
			l++,flag = false;
		}
 	}
 	if(flag) Wait_Queue.push_back(element(y,z)),ans++;
 	return ;
}
inline void work() {
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	List.push_back(node(-1,-1,-1));//头部
	List.push_back(node(n,n,-1));//尾部
	l = 1;//长度，由于vector的长度还要写个函数的话会慢一点（虽然无所谓啦）
	while(true) {
		if(x == 0 && y == 0 && z == 0) break;
		solve(x,y,z);
		scanf("%d%d%d",&x,&y,&z);
	}
	while(!Time_Queue.empty())slote();
	return ;
}
inline void print() {
	printf("%d\n%d",tim,ans);
	return ;
}
int main() {
	F("memory");
	input();
	work();
	print();
	return 0;
} 
~~~

## 题外话
个人的码风可能不适合很多人，但是希望各位记住看题解只是为了看一个思路，真正的实现是自己的事情，这样才能够提升，而不是一味地直接抄袭他人的题解。

希望我写的代码和思路能够给大家带来做题的启示。

---

## 作者：crh1272336175 (赞：7)

本题是一个完全考察数据结构的模拟题

用到的数据结构:队列，堆，链表

本人更喜欢用STL，手写党请忽略

代码（有详细注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
queue<PII> waiting;//等待队列,存储 内存长度 和 占用时间
set<PII> running;//链表，存储  起始下标 和 长度
priority_queue<PII,vector<PII>,greater<PII> > endtimes;//小根堆，存储 结束时间 和 起始下标
int n,t,m,p,ans_cnt,last_out_time;
bool assign(int t,int m,int p)
{
    set<PII>::iterator it;
    for(it=running.begin(); it!=running.end(); it++)//遍历链表
    {
        set<PII>::iterator jt=it; 
        jt++;//jt指向it所指的下一个空间
        if(jt!=running.end())
        {
            if(m<=jt->first-(it->first+it->second))//如果m小于等于两段区间之间的空隙,那么可以分配
            {
                int start=it->first+it->second;
                running.insert({start,m});
                endtimes.push({t+p,start});
                return true;
            }
        }
    }
    return false;
}
void release(int t)//释放所有结束时间小于等于t的内存
{
    while(!endtimes.empty() && endtimes.top().first<=t)
    {
        int tmp=endtimes.top().first;//暂时存储一下这个堆顶元素的结束时间，以便于把所有这个时间的都删掉
        last_out_time=tmp;
        while(!endtimes.empty() && endtimes.top().first==tmp)//处理小根堆
        {
            PII tmpp=endtimes.top(); endtimes.pop();
            set<PII>::iterator it=running.lower_bound({tmpp.second,0});
            running.erase(it);
        }
        while(!waiting.empty())//处理等待队列
        {
            PII tmpp=waiting.front();
            if(assign(tmp,tmpp.first,tmpp.second))//如果当前空间可以分配给队首
                waiting.pop();
            else break;//一旦不能分配就break，因为队首优先级最高
        }
    }
}
int main()
{
    scanf("%d",&n);
    running.insert({-1,1});//左边界 
    running.insert({n,1});//右边界
    while(cin>>t>>m>>p,t || m || p)//读入3个0结束
    {
        release(t);//释放所有结束时间小于等于t的内存
        if(!assign(t,m,p)) //如果不能分配，就加入等待队列
        {
            waiting.push({m,p});
            ans_cnt++;
        }
    }
    release(1e9+5);//只有把所有内存都释放了，才能够计算最后一个内存释放的时间
    printf("%d\n%d",last_out_time,ans_cnt);
    return 0;
}
```


---

## 作者：aimat (赞：5)

这是一篇时间复杂度 $O(k\log k)$，空间复杂度 $O(k)$ 的做法，应该是目前的理论最优解。在本题时空限制下应该可以跑过 $k=10^6$。（此处 $k$ 指行数）

将每个空闲单元视为 $1$，被占用的单元视为 $0$，那么我们就得到了一些 $01$ 连续段。考虑用平衡树维护。（经过摊还分析可知这是对的）。我此处只维护了连续 $1$ 段。

我们需要用平衡树实现：

1. 找到第一个长度 $\ge m$ 的连续 $1$ 段；
2. 将一个区间改为 $0$ 或 $1$。

寻找过程可以维护最长段，采用平衡树上二分。

修改可以简单地增删节点维护。

对于在队列中的单元直接开一个队列维护。

对于停止占用的节点开一个按结束时间的小根堆维护。

具体不太好实现，平衡树可以节点回收，这样可能会好写一点。

另外注意特判一个时间点有多个进程同时结束。

以下是我用 fhq_treap 的实现：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<chrono>
#include<random>
#include<queue>
using namespace std;
char *p1,*p2,buf[10010];
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++)
int read(){
	int x=0;
	char c=gc();
    while(c<48)c=gc();
	while(47<c)x=(x<<3)+(x<<1)+(c&15),c=gc();
	return x;
}
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
struct node{
	int l,r,L,R,mx,rd;
}t[10010];
struct SEG{
	int t,l,r;
	SEG(int tt=0,int ll=0,int rr=0){
		t=tt;
		l=ll;
		r=rr;
	}
	bool operator<(SEG _)const{
		return _.t<t||_.t==t&&_.l<l;
	}
};
priority_queue<SEG>q1;
pair<int,int>q[10010];
int new_node(int l,int r);
int tot,stk[10010],top,rt=new_node(0,read()-1),hh=1,tt,ans;
int new_node(int l,int r){
	if(top){
		int x=stk[top--];
		t[x].mx=(t[x].R=r)-(t[x].L=l)+1;
		return x;
	}
	t[++tot].rd=rnd();
	t[tot].mx=(t[tot].R=r)-(t[tot].L=l)+1;
	return tot;
}
void update(int now){
	t[now].mx=max(t[now].R-t[now].L+1,max(t[t[now].l].mx,t[t[now].r].mx));
}
void split(int now,int k,int&x,int&y){
	if(!now)x=y=0;
	else{
		if(t[now].L<=k){
			x=now;
			split(t[now].r,k,t[now].r,y);
		}else{
			y=now;
			split(t[now].l,k,x,t[now].l);
		}
		update(now);
	}
}
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(t[x].rd<t[y].rd){
		t[x].r=merge(t[x].r,y);
		update(x);
		return x;
	}
	t[y].l=merge(x,t[y].l);
	update(y);
	return y;
}
int queryl(int now){
	while(t[now].l)now=t[now].l;
	return now;
}
int queryr(int now){
	while(t[now].r)now=t[now].r;
	return now;
}
int query(int now,int k){
	if(t[t[now].l].mx>=k)return query(t[now].l,k);
	if(t[now].R-t[now].L+1>=k)return now;
	return query(t[now].r,k);
}
void add(int m,int p){
	int x,y,k=query(rt,m);
	split(rt,t[k].L,x,y);
	split(x,t[k].L-1,x,k);
	q1.emplace(p,t[k].L,t[k].L+m-1);
	if(t[k].mx==m){
		stk[++top]=k;
		rt=merge(x,y);
	}else{
		t[k].L+=m;
		t[k].mx=t[k].R-t[k].L+1;
		rt=merge(merge(x,k),y);
	}
}
void del(SEG seg,unsigned char fl){
	int L=seg.l,R=seg.r,x,y,l,r;
	ans=max(ans,seg.t);
	split(rt,L,x,y);
	l=queryr(x);
	r=queryl(y);
	if(l&&t[l].R==L-1){
		L=t[l].L;
		split(x,L-1,x,l);
		stk[++top]=l;
	}
	if(r&&t[r].L==R+1){
		R=t[r].R;
		split(y,R,r,y);
		stk[++top]=r;
	}
	rt=merge(merge(x,new_node(L,R)),y);
	if(fl)while(hh<=tt&&t[rt].mx>=q[hh].first){
		add(q[hh].first,q[hh].second+seg.t);
		++hh;
	}
}
int main(){
	int t,m,p;
	SEG seg;
	while(1){
		t=read();
		m=read();
		p=read();
		if(!t&&!m&&!p){
			while(!q1.empty()){
				seg=q1.top();
				q1.pop();
				del(seg,q1.empty()||!q1.empty()&&q1.top().t!=seg.t);
			}
			printf("%d\n%d",ans,tt);
			return 0;
		}
		while(!q1.empty()&&q1.top().t<=t){
			seg=q1.top();
			q1.pop();
			del(seg,q1.empty()||!q1.empty()&&q1.top().t!=seg.t);
		}
		if(::t[rt].mx>=m)add(m,p+t);
		else q[++tt]=make_pair(m,p);
	}
}
```

---

## 作者：MornStar (赞：4)

# P5763 [NOI1999] 内存分配题解
## 题面
[link](https://www.luogu.com.cn/problem/P5763)

## 思路

非常好模拟，这使我调了一下午。

### 操作的有序化

首先，对于每个进程有两个操作关于其，插入和删除。

所以我们可以想到实时记录两个操作的执行时间（实时是因为进入等待队列的进程需要重新计算删除时间）。

剩余的工作就交给优先队列了。

需要注意的是，尝试插入等待队列里的进程时，需要先完成当前时刻所有的删除操作，同时，应先处理等待队列的进程，然后再处理新进程，所以应在按时间排序的基础上，将删除操作提前。让已完成的进程让出空间再处理。

代码如下：

```cpp
struct node{
	int num,t,opt;//num:进程编号,t:执行时间,opt:操作类型，1为插入，2为删除
	friend bool operator<(node a,node b){return	(a.t==b.t?a.opt<b.opt:a.t>b.t);} 
};
```
```cpp
while(!q.empty()){
	st:
	node now=q.top();
	q.pop();
	ans1=max(ans1,now.t);//记录时间
	if(now.opt==1)	ins(now.num);
	else	del(now.num);
	if(!q.empty()&&q.top().t==now.t&&q.top().opt==2)	goto st;//如果当前时刻仍有删除操作就回去。
	wating_ins(now.t);//处理等待队列
}
```
### 空间分配

注意到题目中空间上限为 $10^9$，纯模拟肯定不行，但是进程分配的空间是连续的，所以我们可以想到链表。

代码中定义了头尾两个链表以方便操作。

```cpp
struct List{int l,r,pre,nxt;}now_using[10005];
```
```cpp
now_using[1]={-1,-1,-1,2,0},now_using[2]={n,n,1,-1,0};
```
接下来，就剩下几个操作了。

#### 1. 寻找是否有满足条件的空间

从表头开始遍历链表计算两个进程中间剩余的空间，判断能否放入。

```cpp
int find(int mr){
	int now=1;
	while(now_using[now].nxt!=-1){
		if(now_using[now_using[now].nxt].l-now_using[now].r-1>=mr)	return now;
		now=now_using[now].nxt;
	}
	return -1;
}
```

#### 2. 插入

用 find 函数查询是否能插入，如果能，则用正常链表操作，否则加入等待队列。

```cpp
void ins(int num){
	int pos=find(program[num].mr);
	if(pos==-1){
		wating.push(num);
		ans2++;
	}else{
		int st=now_using[pos].r+1;
		cnt++;
		now_using[cnt]={st,st+program[num].mr-1,-1,-1};
		now_using[cnt].pre=pos,now_using[cnt].nxt=now_using[pos].nxt;
		now_using[now_using[pos].nxt].pre=cnt,now_using[pos].nxt=cnt;
		to[num]=cnt,q.push({num,program[num].mal+program[num].ti,2});
        //注意这里操作类型为2。to是一个映射,在删除时有用。
	}
}
```

#### 3. 删除

正常删除即可。

```cpp
void del(int num){
	int now_del=to[num];
	now_using[now_using[now_del].pre].nxt=now_using[now_del].nxt;
	now_using[now_using[now_del].nxt].pre=now_using[now_del].pre;
}
```

#### 4. 处理等待队列

跟插入差不多，也是先判再插入，注意重新计算时间。

```cpp
void wating_ins(int now_time){
	while(!wating.empty()){
		int now=wating.front(),pos=find(program[now].mr);
		if(pos!=-1){
			int st=now_using[pos].r+1;
			cnt++;
			now_using[cnt]={st,st+program[now].mr-1,-1,-1};
			now_using[cnt].pre=pos,now_using[cnt].nxt=now_using[pos].nxt;
			now_using[pos].nxt=now_using[now_using[cnt].nxt].pre=cnt;
			to[now]=cnt,q.push({now,now_time+program[now].ti,2});
			wating.pop();
		}else	break;
	}
}
```

合起来就是本题的代码了。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,program_num,ans1,ans2,cnt=2,to[10005];
struct List{int l,r,pre,nxt;}now_using[10005];
struct wating_program{int mal,ti,mr;}program[10005];
struct node{
	int num,t,opt;
	friend bool operator<(node a,node b){return (a.t==b.t?a.opt<b.opt:a.t>b.t);} 
};
queue<int>wating;
priority_queue<node>q;
int find(int mr){
	int now=1;
	while(now_using[now].nxt!=-1){
		if(now_using[now_using[now].nxt].l-now_using[now].r-1>=mr)	return now;
		now=now_using[now].nxt;
	}
	return -1;
}
void ins(int num){
	int pos=find(program[num].mr);
	if(pos==-1){
		wating.push(num);
		ans2++;
	}else{
		int st=now_using[pos].r+1;
		cnt++;
		now_using[cnt]={st,st+program[num].mr-1,-1,-1};
		now_using[cnt].pre=pos,now_using[cnt].nxt=now_using[pos].nxt;
		now_using[now_using[pos].nxt].pre=cnt,now_using[pos].nxt=cnt;
		to[num]=cnt,q.push({num,program[num].mal+program[num].ti,2});
	}
}
void del(int num){
	int now_del=to[num];
	now_using[now_using[now_del].pre].nxt=now_using[now_del].nxt;
	now_using[now_using[now_del].nxt].pre=now_using[now_del].pre;
}
void wating_ins(int now_time){
	while(!wating.empty()){
		int now=wating.front(),pos=find(program[now].mr);
		if(pos!=-1){
			int st=now_using[pos].r+1;
			cnt++;
			now_using[cnt]={st,st+program[now].mr-1,-1,-1};
			now_using[cnt].pre=pos,now_using[cnt].nxt=now_using[pos].nxt;
			now_using[pos].nxt=now_using[now_using[cnt].nxt].pre=cnt;
			to[now]=cnt,q.push({now,now_time+program[now].ti,2});
			wating.pop();
		}else	break;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	now_using[1]={-1,-1,-1,2,0},now_using[2]={n,n,1,-1,0};
	program_num=1;
	while(cin>>program[program_num].mal>>program[program_num].mr>>program[program_num].ti&&program[program_num].mr){
		q.push({program_num,program[program_num].mal,1});
		program_num++;
	}
	while(!q.empty()){
		st:
		node now=q.top();
		q.pop();
		ans1=max(ans1,now.t);
		if(now.opt==1)	ins(now.num);
		else	del(now.num);
		if(!q.empty()&&q.top().t==now.t&&q.top().opt==2)	goto st;
		wating_ins(now.t);
	}
	cout<<ans1<<"\n"<<ans2;
}
```


---

## 作者：Tenshi (赞：4)

有点~~毒瘤~~的模拟。

我用 $\texttt{set}$​ ~~乱搞~~编写了一个数据结构来维护，发现比很多人的代码跑得快，甚至在洛谷最优解前列，但是码量大了不少。



## 分析

实现的思路比较明显：

> 记一共有 $m$ 个进程。

- 我们从 $1\to m$ 枚举每个进程并进行处理。
- 在处理到第 $i$​​ 个进程前，我们先进行**结算**（$\texttt{account}$​​​​），就是将在第 $i$​​ 个进程所在的**申请时刻**之前能够结束的进程全部清除，并将**等待队列**中能够被加入的进程加入内存中。
- 然后对于当前进程：如果有足够的空间，那么就丢进去；反之，将其加入**等待队列**中。



可以发现，上面的模拟过程涉及对区间的赋值：当内存被占用的时候记为 $1$，反之为 $0$。

对此，可以使用一个 $\texttt{set}$ 来维护区间：

区间有三个属性：左右端点 $l, r$，值 $val(0/1)$。

维护两种操作：

- $\texttt{find(len):}$​​ 直接对 $\texttt{set}$​ 的元素（即区间）进行遍历，当区间值为 $0$​​ 且长度 $\geq len$ 时，返回该区间的左端点，如果没有则返回 $-1$。
- $\texttt{eval(l, r, val):}$ 即区间赋值操作，当 $val=0$ 时，也就是原来的区间从 $1\to 0$，故检查该区间左、右区间是否也是 $0$，如果是则需要进行合并再插入 $\texttt{set}$；当 $val=1$ 直接进行值的修改即可。​​



## 实现

```cpp
#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()

#define x first
#define y second
using pii = pair<int, int>;
using ll = long long;

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=10010;

int n, m, ts, res;

struct Event{
    int t, m, p;
}e[N];

struct Cmd{
    int t, l, r; // 结束的时间, [l, r]
    bool operator < (const Cmd &o)const{
        return t>o.t;
    }
};
priority_queue<Cmd> clk;

queue<pii> q;

struct Seg{
    int l, r;
    mutable bool val;

    bool operator < (const Seg &o)const{
        return l<o.l;
    }

    int len(){
        return r-l+1;
    }
};
set<Seg> st;

int find(int len){
    for(auto i: st) if(!i.val && i.len()>=len) return i.l; 
    return -1;
}

void eval(int l, int r, bool val){
    auto it=--st.upper_bound({l, 0, 0});
    if(val){
        int L=it->l, R=it->r;
        st.erase(it);

        if(L<=l-1) st.insert({L, l-1, 0});
        if(r+1<=R) st.insert({r+1, R, 0});
        st.insert({l, r, 1});
    }
    else{
        auto L=it, R=it;
        if(it!=begin(st)) L--;
        if(it!=end(st)) R++;

        auto seg=*it;
        if(it!=L && L->val==0) seg.l=L->l, st.erase(L);
        if(R!=end(st) && R->val==0) seg.r=R->r, st.erase(R);
        seg.val=0;

        st.erase(it);
        st.insert(seg);
    }
}

void account(int lim){
    while(clk.size() && clk.top().t<=lim){
        auto tmp=clk.top(); clk.pop();
        ts=tmp.t;

        int l=tmp.l, r=tmp.r;
        eval(l, r, 0);
        if(clk.size() && clk.top().t==tmp.t) continue; // 同一时刻的需要全部清除

        int k;
        while(q.size() && (k=find(q.front().x))!=-1){
            auto [x, y]=q.front(); q.pop();
            eval(k, k+x-1, 1);
            clk.push({ts+y, k, k+x-1});
        }
    }
}

int main(){
    cin>>n;
    int a, b, c;
    while(cin>>a>>b>>c, a || b || c) e[++m]={a, b, c};

    st.insert({1, n, 0});
    rep(i,1,m){
        account(e[i].t);

        int k=find(e[i].m);
        ts=e[i].t;

        if(~k){
            int l=k, r=k+e[i].m-1;
            eval(l, r, 1);
            clk.push({ts+e[i].p, l, r});
        }
        else{
            q.push({e[i].m, e[i].p});
            res++;
        }
    }
    account(2e9+5);

    cout<<ts<<endl<<res<<endl;

    return 0;
}

```



---

## 作者：Mars_Dingdang (赞：4)

感觉这道题和 CSP-S2021 的 T1 有异曲同工之妙，只是两者的侧重点不同，一个是弱化数据范围的普适情况，一个是强化数据范围的特殊情况（即本题中 $m=1$）。

## 题目大意
有一个长度为 $n$ 的内存条，下标为 $0\sim n-1$。现在有若干个进程，按开始时刻排序，用 $(t, m, p)$ 表示进程开始的时刻，需要占用的**连续**内存长以及持续的时间。

- 若 $t$ 时刻内存中存在长度为 $m$ 的空闲地址片，则系统将这 $m$ 个空闲单元分配给该进程。若存在多个长度为 $m$ 个空闲地址片，则系统将**首地址最小**的那个空闲地址片分配给该进程。

- 如果 $t$ 时刻不存在长度为 $m$ 的空闲地址片，则该进程被放入一个等待队列。对于处于等待队列队头的进程，只要在任一时刻，存在长度为 $m$ 的空闲地址片，系统**马上**将该进程取出队列，并为它分配内存单元。注意，在进行内存分配处理过程中，**处于等待队列队头的进程的处理优先级最高，队列中的其它进程不能先于队头进程被处理**。

现在给出一系列描述进程的数据，请编写一程序模拟系统分配内存的过程，求出运行所有进程需要的时间以及**进入过**等待队列的进程数。

## 大体思路
本题是一道大模拟，首先考虑使用哪些数据结构。

对于等待队列，显然使用 STL 中的 queue 进行实现。由于进入等待队列的进程的实际开始时刻不等于其本身的 $t$，queue 中只需要储存两个变量 $(m, p)$。

对于内存的使用情况，我们需要知道每一段占用的内存的起始下标、长度和释放时间。其需要支持线性扫描、插入删除的操作，最好能自动按起始下标排序，考虑用 set 实现。

由于本题中 $n\le 10^9$，无法直接枚举时间，因此需要一个数据结构从小到大记录释放时间对应 set。考虑用小根堆维护变量 (释放时间，起始下标)，其中释放时间作为关键字排序，起始下标用于对应 set。

这样，set 中可以不用记录释放时间，三个数据结构（队列、set、小根堆）均是基于二元变量，用 pair 即可。

```cpp
queue <PII> waits;   // first: length M, second: time P
set<PII> st;         // first: begin   , second: length M
priority_queue <PII, vector<PII>, greater<PII> > q; // first: time to release, second: begin
int n, tim, cnt;
```

具体流程如下：对于一组 $(t, m, p)$，

1. 释放所有释放时间 $\le t$ 的进程，并判断等待队列中是否有可以加入的。

```cpp
inline void release(int t) {
	while(!q.empty() && q.top().first <= t) { // 从小根堆中找出释放时间 <=t 的进程
		int T = q.top().first;
		while(!q.empty() && q.top().first == T) { // 将相同释放时间的进程同时释放
			PII x = q.top(); 
			q.pop();
			auto it = st.lower_bound({x.second, 0});
			st.erase(it);
		}
		tim = T; // 更新完成所有进程的最晚时刻
		while(!waits.empty()) { // 查看等待队列中的进程能否获得内存
			PII x = waits.front();
			if(give(T, x.first, x.second)) waits.pop();
			else break;
		}
	}
}
```

2. 尝试插入 $(t, m, p)$，若满足则占用内存，若不满足则插入等待队列，并累加到“进入过等待队列的进程数”。

```cpp
inline bool give(int t, int m, int p) {
	for(auto it = st.begin(); it != st.end(); it ++) {
		auto j = it;
		j ++; // 相邻两个占用区间
		if(j != st.end()) {
			if(m <= j->first - (it->first + it->second - 1) - 1) { // 空余长度不小于m
				st.insert({it->first + it-> second, m});
				q.push({t + p, it->first + it->second});
				return 1;
			}
		}
	}
	return 0;
}
```

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <set>
#include <algorithm>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e4 + 5, inf = 1e9 + 7;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
queue <PII> waits; // first: length M, second: time P
set<PII> st;   // first: begin   , second: length M
priority_queue <PII, vector<PII>, greater<PII> > q; // first: time to release, second: begin
int n, tim, cnt;
inline bool give(int t, int m, int p) {
	for(auto it = st.begin(); it != st.end(); it ++) {
		auto j = it;
		j ++; // 相邻两个占用区间
		if(j != st.end()) {
			if(m <= j->first - (it->first + it->second - 1) - 1) { // 空余长度不小于m
				st.insert({it->first + it-> second, m});
				q.push({t + p, it->first + it->second});
				return 1;
			}
		}
	}
	return 0;
}
inline void release(int t) {
	while(!q.empty() && q.top().first <= t) { // 从小根堆中找出释放时间 <=t 的进程
		int T = q.top().first;
		while(!q.empty() && q.top().first == T) { // 将相同释放时间的进程同时释放
			PII x = q.top(); 
			q.pop();
			auto it = st.lower_bound({x.second, 0});
			st.erase(it);
		}
		tim = T; // 更新完成所有进程的最晚时刻
		while(!waits.empty()) { // 查看等待队列中的进程能否获得内存
			PII x = waits.front();
			if(give(T, x.first, x.second)) waits.pop();
			else break;
		}
	}
}
int main () {
	read(n);
	st.insert({-1, 1});
	st.insert({n, 1});// 防越界
	while(1) {
		int t, m, p;
		read(t); read(m); read(p);
		if(!t && !m && !p) break;
		release(t);
		if(!give(t, m, p)) {
			waits.push({m, p});
			cnt ++;
		}
	}
	release(inf); // 完成所有进程
	writeln(tim), writeln(cnt);
	return 0;
}
```

---

## 作者：Tenil (赞：2)

# Solution

这里是博客：[Tenil](https://www.cnblogs.com/tenil)，有更好的看题体验哦~

直接模拟的各种方法可以参考其他题解，复杂度大概为 $O(k^2)$，本篇不详讲，只做引入。蒟蒻做题时想到了，但是一看 $k\leq 9998$，感觉有点不妥，万一有个常数直接 T 掉，于是用一天调了一个 $O(k\log^2 k)$（好像是，已经分析不懂了），详见下文。

## 题意
[原题链接](https://www.luogu.com.cn/problem/P5763)

有 $N$ 个连续编号的单元，$k$ 条指令，每条指令占用 $M_i$ 个编号尽可能小的连续单元 $P_i$ 时间，在 $T_i$ 时刻执行。若 $T_i$ 时刻无法执行则进入等待队列，队头指令一旦可以执行立刻执行（除 $k\leq 9998$ 外，其他数据均小于 $10^9$）。

求所有指令**完成**的时刻和进入过等待序列的指令数。

有几个细节：

1. 等待队列的指令优先于输入指令执行；
2. 占用时间是（开始时间 $t_i$）：$[t_i,t_i+P_i)$；
3. 最终要求的是**完成时间**，相当于 2 中的 $t_i+P_i$；
4. 时间可以从 $0$ 开始。

## 分析 & 实现

### 1. 直接模拟

可以发现，题目的描述都是清晰的流程，且所求正是按流程操作过程中可以得到的值，而且数据范围可接受，自然可以想到直接模拟：一个 vector 当内存条，每次取最左的可行段拆开，更新时间标记；一个 queue 作等待队列，直接按照流程操作即可。

### 2. 堆优化

依据 1 的大体思路，我们现在有一个存 $(l_i,r_i,st_i)$ 的 vector 当内存条（$st_i$ 即内存释放时间），一个存 $(M_i,P_i)$ 的 queue 作等待队列，现在考虑怎么优化。

#### 第一个问题：如何在 $T_i$ 满足条件的同时，更低代价最小化 $l$

先不考虑合并问题，思考如何在 $T_i$ 满足条件的同时，最小化连续单元左端点编号 $l$。由于我们需要改点，理应需要能够动态维护、随机访问。如果做双关键字排序的话，其实也可以干：众所周知，STL set 可以满足动态维护和随机访问的要求，而且其内置的二分查找可加速查询；或者手写一个二叉堆亦可满足需求。但是这比较标新立异，容易出错，蒟蒻这里用的是比较常规的分离参数。

先建一个内存条依据 $T_i$ 排序的小根堆，筛选对应满足 $T_i$ 条件的当前内存段，将其时间标记统一更新为 $-\text{INF}$ 后（由于 $T_i$ 单调递增，**现在已经满足的之后一定也满足**），转移到一个依据 $l_i$ 排序的小根堆中，其堆顶就是满足 $T_i$ 条件且 $l$ 最小的一个。这样做相当于消去了 $T_i$ 后继续比较，自然可以求得 $l$ 最小段。需要使用时，取第二个堆的堆顶（假设够长），用的一段更新时间标记后丢回第一个堆，省的一段留在原堆。这样做，一段区间不会被过多次数地进行排序，从而降低了复杂度，大体 $O(n\log n)$。

#### 第二个问题：如何合并可用段

一个显然的结论是：连续的两段内存，左边一段的 $r$ 等于右边一段的 $l$ 减一。所以直接根据这个性质在上文所述的第二个堆中合并即可。但是这样其实是不行的，问题又回到了随机访问。所以考虑把 STL priority_queue 换成 STL vector，每次新元素加入时，sort 一下，或者直接二分插入，依然能够维护单调性。

当要占用单元时，先把整个 STL vector 扫一遍，合并相邻内存段，再找到第一个长度不小于 $M_i$ 的内存段，直接用它。这里还可以再跑一个二分查找，不过本蒟蒻就直接扫了。

#### 第三个问题：如何解决等待队列

这个其实就比较简单了，每次先考虑等待队列中的元素即可。但是需要注意一点：等待队列中的指令执行不止可能在新指令执行前，还可能是任何内存释放时，所以说需要记录一下所有使用中的内存的释放时间，考虑开一个时间队列。由于等待队列中的指令是一有机会就执行，所以说应该用小根堆存。**注意：STL priority_queue 默认大根堆！**

大方向上就是这些，其他的一些细节问题在代码里。

## Code


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <queue>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long ll;

inline ll fr() {
	ll x=0,f=1;char c=getchar();
	while(!isdigit(c)) {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(isdigit(c)) {
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

struct qus{
	ll l,r,st;
	qus (ll _l,ll _r,ll _st) {
		l=_l,r=_r,st=_st;
	}
	bool operator <(const qus &q1) const &{
		return q1.st<st;//注意：这样的小于其实返回的是大于的结果，但是对上大根堆就正好
	}
};	

bool cmp(qus q1,qus q2) {
	return q1.l<q2.l;//这个才是正常的
}

struct wait{
	ll m,p;
	wait (ll _m,ll _p) {
		m=_m,p=_p;
	}
};

const int maxn=1e4+100;
ll n,anst,ansn;
priority_queue<qus> Q;//上文“第一个堆”
priority_queue<int,vector<int>,greater<int> > tq;//时间队列，小根堆
deque<wait> q;//等待队列
vector<qus> v;//上文“第二个堆”

int main() {
	n=fr();
	Q.push(qus(1,n,-1145141919810));
	ll t=fr(),m=fr(),p=fr(),tt=0,mm=0,pp=0;//tt,mm,pp表示本次使用的t,m,p的值
	bool flag=true;
	while(m||!q.empty()) {//正常输入不可能占用0个单元
		bool wt=false;//是否使用等待队列元素
		if(!q.empty()&&!tq.empty()) {
			if(tq.top()<=t||!m) {
				tt=tq.top();
				mm=q.front().m;
				pp=q.front().p;
				q.pop_front();
				wt=true;
			}
			else {
				tt=t;mm=m;pp=p;
			}
		}
        else {
			tt=t;mm=m;pp=p;
		}
//上文“第一个问题”
		if(!Q.empty()) {
			while(Q.top().st<tt) {
				v.push_back(qus(Q.top().l,Q.top().r,-1145141919810));
				Q.pop();
				if(Q.empty()) break;
			}
		}
//上文“第二个问题”
		sort(v.begin(),v.end(),cmp);	
        int lim=(int)v.size();
        for(register int i = 0; i < lim; i++) {
			if(v[i].l>v[i].r) {//非法判断
				v.erase(v.begin()+i);
				lim--;i--;//erase的时候删除点后面的都会减一，如果i++了反而跳过一个
			}
		}
		for(register int i = 1; i < lim; i++) {
			if(v[i-1].r==v[i].l-1) {
				v[i].l=v[i-1].l;
				v.erase(v.begin()+i-1);
				lim--;i--;
			}
		}
		bool vis=false;
		for(register int i = 0; i < (int)v.size(); i++) {
			qus x=v[i];
			if(x.r-x.l+1>=mm) {
				Q.push(qus(x.l,x.l+mm-1,tt+pp-1));//这里减一，所以上面“第一个问题”处不能取等
				v[i].l+=mm;
				tq.push(tt+pp);//第三个问题：时间队列赋值的时候取的等，所以这里不能减
				vis=true;
				break;
			}
		}
		if(!vis) {
			if(!wt) {
				q.push_back(wait(mm,pp));
				ansn++;
			}
			else {
				q.push_front(wait(mm,pp));//等待队列中的不可行，要扔回去
				tq.pop();
			}
		}
		if(!wt) {
			if(m) {
				if(!tq.empty()) {
					while(tq.top()<t) {
						tq.pop();
						if(tq.empty()) break;//小于当前时间的一定不行了（可行的话之前就用了），剪掉
					}
				}
				t=fr(),m=fr(),p=fr();
			}
		}
	}
	while(!Q.empty()) {
		anst=Q.top().st;
		Q.pop();//小根堆，最后一个最大
	}
	printf("%lld\n%lld\n",anst+1,ansn);//上面减了一，这里要加回来
	return 0;
}
```

## 闲话

如果觉得有用，点个赞吧！（调了一上午加一中午，写了一下午，蒟蒻尽力了）

---

## 作者：ltl0825 (赞：2)

# P5763 [NOI1999] 内存分配题解：
[原题链接](https://www.luogu.com.cn/problem/P5763)


---

题意有些长，可以看样例来想。  
具体样例其实可以看这张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/tqhtzu9e.png)  
是不是一目了然。

---
### 具体思路：
其实，我们可以看这张图（设红色为已经占用的内存空间，蓝色为未占用的内存空间）。
![](https://cdn.luogu.com.cn/upload/image_hosting/cxw73des.png)  
我们可以瞬间发现，每个蓝色块的长度是上一个红色块的尾和下一个红色块的头之差。  
那么，我们可以用一个集合来维护红色块即可。  
`set<pair<int,int>> s;//first:占内存的起始位置,second:占用内存长度`  
我们还要一个优先队列来维护最早被结束掉的进程。  
`priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;//first:进程结束时间，second:占内存的起始位置`  
但是题目中还有一个等待队列要怎么处理呢？  
当然用我们最常见的普通队列。  
`queue<pair<int,int>> waitq;//first:占用内存时间，second:占用内存长度`  
接着，我们就用这三个东西来维护整个过程即可。 

---
#### 具体求法：
添加进程：  
1. 枚举类似图中每个红色块。
2. 判断相邻的红色块能不能塞下。
3. 能塞下，相当于添加一个新的红色块，加入集合和优先队列。
4. 如果都不行，加入等待队列，同时维护被放入等待队列的元素个数。

释放内存：
1. 看当前的优先队列顶部。
2. 结束时间比当前小
3. 释放，并释放结束时间相同的进程，同时维护最晚释放时间。
4. 删除这些进程所对应的红色块
5. 判断等待队列能否加入。

---
### Tips:
1. 开始时要在 `set` 中加入 $-1$ 和 $n$（内存是 $0 \sim n-1$）的，这样才能保证把开始的红色块算上。
2. 先释放内存，在加入新进程。
3. 释放内存时，要记得释放相同时间的进程。
4. 记得等待队列的优先级比新进程高。

---
# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
set<pair<int,int>> s;//first:占内存的起始位置,second:占用内存长度
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;//first:进程结束时间，second:占内存的起始位置
queue<pair<int,int>> waitq;//first:占用内存时间，second:占用内存长度
int mx,cnt;
bool fang(int t,int x,int y)//在第t个时刻放入占内存长度x，持续时间y
{
	for(auto it=s.begin();it!=s.end();it++)//枚举每一个红色块
	{
		auto j=it;
		j++;
		if(j!=s.end())//细节判断
		{
			if(j->first-it->first-it->second>=x)//两个相邻的红色块的缝隙可以塞下当前进程
			{
				s.insert({it->first+it->second,x});//放入
				q.push({t+y,it->first+it->second});
				return 1;
			}
		}
	}
	return 0;
}
void free(int t)//在时间为t时释放内存
{
	while(!q.empty()&&t>=q.top().first)
	{
		int tt=q.top().first;
		while(!q.empty()&&q.top().first == tt)//有多个进程同时弹出
		{
			auto tmp=q.top();
			q.pop();
			s.erase(s.lower_bound({tmp.second,0}));//记得把set中也删掉（删除这些进程随对应的红色块）
		}
		mx=tt;//记录最晚进程
		while(!waitq.empty())
		{
			if(fang(tt,waitq.front().second,waitq.front().first))//判断等待队列的头能不能加入
			{
				waitq.pop();//能，弹出
			}
			else
			{
				break;//后面的元素不能提前加入
			}
		}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	s.insert({-1,1});//细节
	s.insert({n,1});
	int t,m,p;
	while(cin>>t>>m>>p&&(t+m+p))
	{
		free(t);//先释放
		if(!fang(t,m,p))//后加入
		{
			waitq.push({p,m});//放不下，加入等待队列
			cnt++;//题目的第二个要求
		}
	}
	free(2e9+10);//可以认为将进程全释放
	cout<<mx<<'\n'<<cnt<<'\n';
	return 0;
}
```

---

## 作者：Macesuted (赞：2)

[题面](https://www.luogu.com.cn/problem/P5763)

## 题意

按照时间顺序给你 $n$ 个申请，每个申请会给出申请发起时间，占用空间大小，占用时间三个参数，程序会尝试在申请发起时分配内存，分配的内存必须是一段连续的，大小满足条件的空间，如果无法在申请发起时直接分配出内存，询问将进入等待队列，在之后的任意时刻一旦空间满足条件队头会直接出队并且程序会分配给队头询问足够的空间。问将所有申请处理完所需要的时间和所有进入过等待队列的申请数量。

## 分析

按题意模拟，代码题目较难，需要会熟练使用一些常用数据结构。

这里直接结合代码分析。

---
1.首先我们需要有数据结构来记录内存中的占用情况，这里直接使用`list`实现
```cpp

struct saveQ  //记载在内存中的询问占用情况
{
    int begin, end, finish;  //在内存中的起始位置，终止位置，结束时间
};

list<saveQ> id;  //存放内存的中的询问占用情况
```
---
2.我们还需要有数据结构来存放等待队列，这里直接用`queue`实现
```cpp
struct ques  //记录待处理询问
{
    int m, p;  //需要的内存数量，占用时间
};

queue<ques> que;  //存放询问的缓存序列
```
3.由于我们发现询问的结束时间可能很大，这里使用`priority_queue`来存放当前内存中所有询问的结束时间，在接下来的操作中可以通过直接取出堆顶的方式来获知当前所有内存中的询问中最早的结束时间。
```cpp
priority_queue<int, vector<int>, greater<int> > prQue;  //记录每一个询问的结束时间
```

---
4.这里写一个函数，用来查询当前内存中是否有大小为 $m$ 的空间，如果有，返回 true 并插入`list`中，否则返回 false 。
```cpp
bool work(int m, int p) {  //查询内存中是否有连续长度为m的空间，占用时长为p
    list<saveQ>::iterator ed = id.end();
    ed--;
    for (list<saveQ>::iterator i = id.begin(); i != ed; i++) {  //i来遍历出一个占用块
        list<saveQ>::iterator nxt = i;
        nxt++;                               //用nxt来确定i占用块之后的下一个占用块
        if (nxt->begin - i->end - 1 >= m) {  //若两个占用块之间空余可以放下这个新块
            id.insert(nxt, (saveQ){i->end + 1, i->end + m, Time + p});
            prQue.push(Time + p);  //将新加入的询问的信息计入优先队列中
            return true;
        }
    }
    return false;
}
```
---
5.在程序中我们维持一个变量`int Time`表示当前时间，在一个新询问加入时，我们需要先将当前时间推到询问开始时间，然后再处理询问的问题，所以这里提供一个函数来帮我们将时间推移。
```cpp
void timeSet(int tim) {
    while (!prQue.empty() && prQue.top() <= tim)  //如果当前将最早完成的占用块将在t之前结束，则处理
    {
        Time = prQue.top();  //将时间推到该占用块结束的时刻
        prQue.pop();
        for (list<saveQ>::iterator i = id.begin(); i != id.end(); i++)
            while (i != id.end() && i->finish == Time)  //将在当前时间结束的占用块都清除
                i = id.erase(i);
        while (!que.empty()) {  //尝试给在队列中等待的块分配内存空间
            ques cac = que.front();
            if (work(cac.m, cac.p))  //成功分配
                que.pop();           //块出队
            else
                break;
        }
    }
    return;
}
```
不过这里有一个细节，由于我最开始的不注意，我在这份代码的第7行中并没有写`while`而是写了一个`if`，毕竟优先队列里的每一个数对应的是一个询问，但是我后来发现这样的操作会使得原本同一时间结束的询问一个一个结束，在部分询问结束，而部分询问还未结束的情况下可能部分询问已经从队列中出来并且取到了非最优的位置。所以这里应该写`while`，一次性结束完所有该时刻结束的询问。

---
6.最后就是主程序了，有一些细节，在代码中已注明
```cpp
int main() {
    int n;
    scanf("%d", &n);
    id.push_back((saveQ){-1, -1, 0x7fffffff}), id.push_back((saveQ){n, n, 0x7fffffff});
    //链表内插入头和尾节点以防止越界
    int t, m, p, num = 0;
    while (true) {
        scanf("%d%d%d", &t, &m, &p);
        if (!m)
            break;
        timeSet(t);
        Time = t;         //因为如果等待队列为空会有提早结束的情况，所以重复赋值一遍
        if (!work(m, p))  //如果放不进这一个新块，则加入等待队列
            que.push((ques){m, p}), num++;
    }
    timeSet(0x7ffffffe);  //将时间往后推直至最后一个块也解除占用
    printf("%d\n%d\n", Time, num);
    return 0;
}
```

---

## 作者：THUPOST_REMAKE (赞：1)

提供一种和题解区现有的全部题解均不同的做法。

我们设进程数为 $k$，现有题解区的“纯 STL/链表模拟做法”的时间复杂度上界均为 $O(k^2\log k)$ 或 $O(k^2)$。本题解可以保证在时间复杂度 $O(k\log N)$ 内完成。在现有时空限制（1s，125MB）下，将 $k$ 从 $10^4$ 提到 $10^5$ 一样可以完成。

### 优化复杂度的关键点：内存的查找/分配/释放

注意到题解区其他做法的复杂度上限的瓶颈主要是在判断是否可以分配内存，以及查找可以分配时的最小地址。我们可以重新审视一下这一部分操作的本质。

首先我们将整个内存当做一个 $a_0,a_1,...,a_{N-1}$ 的序列，设内存地址 $i$ 被占用时 $a_i=0$，未占用时 $a_i=1$。由于单次内存分配必须是连续的，那么每当我们试图分配一段长度为 $M$ 的内存时，**就需要这个序列的最大连续子段和 $\ge M$**。

至此，我们的内存分配过程以及释放过程利用以下功能就可以完成了：

- 区间赋 $1$ 或者区间赋 $0$；
- 查找全局的最大连续子段和；
- 查找满足最大连续子段和大于等于某值的最小地址。

考虑到本题有 $N\le 10^9$，我们需要使用动态开点线段树来完成，需要的节点个数上限为 $2k\log N$。

线段树维护最大子段和信息可以参考 [luogu P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)，但是本题序列单点的值只有 $0/1$ 两种，且需要区间赋值，所以可以参考 [luogu P2572 [SCOI2010] 序列操作](https://www.luogu.com.cn/problem/P2572) 的方式进行维护。

接下来考虑如何在单 $\log$ 时间内完成最小合法地址的查找。我们回顾一下线段树上维护的信息，分别包括区间的最大前缀和 $(\text{lms})$，最大后缀和 $(\text{rms})$，最大连续子段和 $(\text{mcs})$。而我们每个节点在 pushup 合并信息的时候有：$\text{mcs}_u=\max(\text{mcs}_l,\text{mcs}_r,\text{rms}_l+\text{lms}_r)$。故我们将合并的信息拆解回原始的 3 个信息进行判断。

- 递归底层：当前节点区间长度为 $1$ 时，返回左端点。
- 如果当前节点的区间左半段满足 $\text{mcs}_l\ge M$，则前往左半区间继续查找；
- 否则，如果当前节点满足 $\text{rms}_l+\text{lms}_r\ge M$，那么横跨左右两半区间的这一段即为起始地址最小的合法解。设当前节点对应的内存区间为 $[L,R]$，则返回地址为 $\lfloor \frac{(L+R)}{2}\rfloor-\text{rms}_l+1$；
- 否则，需要在右半区间查找。

通过线段树上二分，我们可以将查找最小地址的时间复杂度也保持在 $O(\log N)$。

### 其他流程

模拟的其他流程和其他题解说的差不多，用一个优先队列将正在进行的任务按照时间从小到大存储，用一个普通队列存储等待中的任务。

每次输入一个新的任务时，将所有结束时间小于等于新任务起始时间 $T$ 的运行中任务结束，并释放对应内存。结束这些任务的过程需要在每结束掉若干个结束任务时间相同的任务之后，立刻判断等待队列是否有能开始运行的任务。有就分配内存。

然后再判断当前输入任务能否分配内存，能就分配不能就推入等待。

所有任务输入完成之后，执行剩余未结束任务即可。

### 复杂度分析

时间和空间复杂度均为 $O(k\log N)$。由于现有数据较弱卡不满上界，所以性能表现并不比其他做法优秀。即便是在 $k\le 10^5$ 的范围下的随机数据也不一定能卡掉其他做法，因为分配/释放/查找内存的本质上就是区间段推平。如果要加强的话，需要专门的 Hack 数据。

### 代码

```c++
const int INF = 2000020000;
namespace dyna_seg
{
    const int max_op = 10010, log_V = 30;
    struct info
    {
        int lms, rms, mcs;
        char tag; // 1 : set 1, -1 : set 0, 0 : none
        void modify(int l, int r, char flag)
        {
            lms = rms = mcs = ((flag == 1) ? (r - l + 1) : 0);
            tag = flag;
        }
    };
    struct node
    {
        int lc, rc;
        info in;
    } tr[2 * max_op * log_V];
    int rt, cnt;
    int LO, HI;
    void init(int L, int R) { LO = L, HI = R, rt = cnt = 1; }
    void alloc_childs(int u) { tr[u].lc = (!tr[u].lc) ? (++cnt) : tr[u].lc, tr[u].rc = (!tr[u].rc) ? (++cnt) : tr[u].rc; }
    void pushup(int u, int l, int r)
    {
        int m = (l + r) >> 1;
        info& lc = tr[tr[u].lc].in, & rc = tr[tr[u].rc].in, & f = tr[u].in;
        f.lms = lc.lms + ((lc.lms < (m - l + 1)) ? 0 : rc.lms);
        f.rms = rc.rms + ((rc.rms < (r - m)) ? 0 : lc.rms);
        f.mcs = std::max({ lc.mcs, rc.mcs, lc.rms + rc.lms });
    }
    void pushdown(int u, int l, int r)
    {
        alloc_childs(u);
        int m = (l + r) >> 1;
        if (tr[u].in.tag)
            tr[tr[u].lc].in.modify(l, m, tr[u].in.tag), tr[tr[u].rc].in.modify(m + 1, r, tr[u].in.tag), tr[u].in.tag = 0;
    }
    void _modify(int u, int L, int R, int l, int r, char val)
    {
        if (R < l || L > r)
            return;
        if (l <= L && R <= r)
        {
            tr[u].in.modify(L, R, val);
            return;
        }
        pushdown(u, L, R);
        int M = (L + R) >> 1;
        _modify(tr[u].lc, L, M, l, r, val), _modify(tr[u].rc, M + 1, R, l, r, val);
        pushup(u, L, R);
    }
    void modify(int l, int r, bool val) { _modify(rt, LO, HI, l, r, val ? 1 : -1); }
    int mcs_whole() { return tr[rt].in.mcs; }
    int _find(int u, int L, int R, int mcs_len)
    {
        if (L == R)
            return L;
        pushdown(u, L, R);
        int M = (L + R) >> 1;
        if (tr[tr[u].lc].in.mcs >= mcs_len)
            return _find(tr[u].lc, L, M, mcs_len);
        else if (tr[tr[u].lc].in.rms + tr[tr[u].rc].in.lms >= mcs_len)
            return M - tr[tr[u].lc].in.rms + 1;
        else
            return _find(tr[u].rc, M + 1, R, mcs_len);
    }
    int find(int mcs_len) { return mcs_whole() >= mcs_len ? _find(rt, LO, HI, mcs_len) : -1; }
}
struct task_info
{
    int l, r, edtime;
    task_info(int _l = 0, int _r = 0, int t = 0) : l(_l), r(_r), edtime(t) {}
    bool operator<(const task_info& o) const { return o.edtime < edtime; }
};
struct wait_info
{
    int need_len, runtime;
    wait_info(int len = 0, int t = 0) : need_len(len), runtime(t) {}
};
std::priority_queue<task_info> run_task;
std::queue<wait_info> wait_task;
int max_runtime, wait_cnt;
void finish_before_time(int t)
{
    while (run_task.size() && run_task.top().edtime <= t)
    {
        int edtime = run_task.top().edtime;
        while (run_task.size() && run_task.top().edtime == edtime)
            dyna_seg::modify(run_task.top().l, run_task.top().r, 1), run_task.pop();
        max_runtime = edtime;

        while (wait_task.size())
        {
            int pos = dyna_seg::find(wait_task.front().need_len);
            if (pos < 0)
                break;
            dyna_seg::modify(pos, pos + wait_task.front().need_len - 1, 0);
            run_task.push(task_info(pos, pos + wait_task.front().need_len - 1, edtime + wait_task.front().runtime));
            wait_task.pop();
        }
    }
}
int main()
{
    int n = rd();
    dyna_seg::init(0, n - 1), dyna_seg::modify(0, n - 1, 1);
    int T = 0, M = 0, P = 0;
    while (T = rd(), M = rd(), P = rd(), (T | M | P))
    {
        finish_before_time(T);
        int pos = dyna_seg::find(M);
        if (pos < 0)
            wait_task.push(wait_info(M, P)), ++wait_cnt;
        else
            dyna_seg::modify(pos, pos + M - 1, 0), run_task.push(task_info(pos, pos + M - 1, T + P));
    }
    finish_before_time(INF);
    printf("%d\n%d", max_runtime, wait_cnt);
}
```

---

## 作者：YuzhenQin (赞：1)

## 题意

有 $N$ 个内存单元。

有 $\le 10^4$ 个进程，每个进程有三个整数 $T, M, P$。**数据已按 $T$ 从小到大排序**。$T, M, P < 10^9$。

对于一个进程，$T$ 表示申请内存的时刻，$M$ 表示申请内存的长度，$P$ 表示占用内存的时间。如果当前存在长度为 $M$ 的空内存，就分配给它，否则放入等待队列。注意，在进行内存分配处理过程中，处于等待队列队头的进程的处理优先级最高，**队列中的其它进程不能先于队头进程被处理**。

输出**全部进程运行完毕的时刻**和**被放入过等待队列的进程总数**。

## 做法

题目中有两种操作：**分配**内存操作和**释放**内存操作。

显然，只有**新的进程申请内存**或者**已有的进程释放内存**时，才会分配新的内存。在已有的进程释放内存时只会分配给等待队列里的进程。

我们可以使用一个 `std::set` 来维护内存。

```cpp
queue<pair<int /* 内存长度 M */, int /* 占用时间 P */> > waits;
set<pair<int /* 左端点 L */, int /* 内存长度 M */> > runs;
```

当出现一个新的内存申请时，遍历 `runs`，如果找到足够长的内存就立即分配，如果无法找到就放入 `waits`。

```cpp
bool assign(int t, int m, int p) {
    // 遍历 `runs`
    for(auto it = runs.begin(); it != runs.end(); it++) {
        // 找到下一块被分配的内存
        auto jt = it;
        jt++;

        if(jt != runs.end()) {
            // 空闲内存区间的左端点就等于
            // 前面分配了的内存区间的左端点加分配的内存长度
            int start = it -> first + it -> second;
            // 求出空闲区间的长度，如果需要分配的长度
            // 小于等于空闲区间的长度，就立即分配
            if(m <= jt -> first - start) {
                runs.insert({start, m});
                // 将分配插入到维护内存释放信息的堆里
                // 见下文
                endts.push({t + p, start});

                return true;
            }
        }
    }

    return false;
}
```

当新的内存申请时间是 $T$ 时，应该释放 $T$ 及 $T$ 之前释放的内存。

释放的时候应该检查能否分配给等待队列队头的内存申请。

可以使用一个堆（`std::priority_queue`）来维护内存释放的信息。

```cpp
priority_queue<pair<int, int>,
               vector<pair<int, int> >,
               // 小根堆
               greater<pair<int, int> > > endts;
```

写一个函数 `void release(int t)`，代表释放时刻 $\le T$ 时应该释放的内存。

```cpp
void release(int t) {
    // 时刻 <= T
	while(!endts.empty() && endts.top().first <= t) {
        // 同一时刻释放的内存一起释放
		int f = endts.top().first;
		while(endts.size() && endts.top().first == f) {
			auto top = endts.top();
			endts.pop();
			auto it = runs.lower_bound({top.second, 0});
			runs.erase(it);
		}

        // 记录已经运行的时间
		ans = f;

        // 考虑等待队列里的进程
		while(waits.size()) {
			auto front = waits.front();
			if(assign(f, front.first, front.second))
				waits.pop();
			else
				break;
		}
	}
}
```

写 `main` 函数时需要注意：

1. 需要插入内存边界

   ```cpp
   runs.insert({-1, 1});
   runs.insert({ n, 1});
   ```
2. 等待所有内存分配请求处理完之后，应该把所有进程运行结束

   ```cpp
   release(2e9);
   ```

## 完整代码（无注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, cnt, t, m, p, ans;
queue<pair<int, int> > waits;
set<pair<int, int> > runs;
priority_queue<pair<int, int>,
               vector<pair<int, int> >,
			   greater<pair<int, int> > > endts;
			   
bool assign(int t, int m, int p) {
	for(auto it = runs.begin(); it != runs.end(); it++) {
		auto jt = it;
		jt++;
		if(jt != runs.end()) {
			int start = it -> first + it -> second;
			if(m <= jt -> first - start) {
				runs.insert({start, m});
				endts.push({t + p, start});
				return true;
			}
		}
	}
	return false;
}

void release(int t) {
	while(!endts.empty() && endts.top().first <= t) {
		int f = endts.top().first;
		while(endts.size() && endts.top().first == f) {
			auto top = endts.top();
			endts.pop();
			auto it = runs.lower_bound({top.second, 0});
			runs.erase(it);
		}

		ans = f;

		while(waits.size()) {
			auto front = waits.front();
			if(assign(f, front.first, front.second))
				waits.pop();
			else
				break;
		}
	}
} 

int main(void) {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr); 

	cin >> n;

	runs.insert({-1, 1});
	runs.insert({n, 1});

	while(cin >> t >> m >> p, t || m || p) {
		release(t);
		if(!assign(t, m, p)) {
			waits.push({m, p});
			cnt++;
		}
	}

	release(2e9);

	cout << ans << endl << cnt << endl;

	return 0;
}
```

---

## 作者：paper_ (赞：1)

## 思路：

​		由于本题输入行数不超过 $10000$，所以任何时刻占用了内存的块至多会将块整个内存划分成 $20000$ 个相间的 **空块与实块**。因为还要支持空实块的插入与删除，自然而然可以想到 **链表**。

​		起始时只有一个长度为 $n$ 的空块，每一次先将能弹出的块先释放内存，合并连续的空块，同时按题目要求尽早把等待队列中的块放入内存，最后尝试放入当前块。没有块加入后，直接把等待队列处理完即可。

​		处理的过程中，每次记录释放块时时间的最大值，同时暂时无足够内存的放入等待队列后记录数量，最后输出答案即可。

​		具体实现见代码，有详细批注。
## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef pair<int, int> PII;
const int N = 20010;
struct P {
	int s, t, f;	// 起始地址，块的长度，是否为空（0/1）
	int l, r; 	// 该块的左右指针
}p[N];
priority_queue<PII, vector<PII>, greater<PII> > q1;		// 已匹配内存的块的释放空间队列：{释放时间，块编号} 。 
queue<PII> q2;	// 等待队列：{块长度，块存在时间}。
int n, idx, ans1, ans2;
void add(int k, int u) {	// 添加块 
	p[u].r = p[k].r;
	p[p[k].r].l = u;
	p[k].r = u;
	p[u].l = k;
}
void D(int k) {		// 删除块 
	p[p[k].r].l = p[k].l;
	p[p[k].l].r = p[k].r;
}
bool work(int s, int len, int t) {	// 尝试将：起始时间为 s，长度为 len，占用时间为 t，的块匹配内存。 
	int la = 0;
	for (int i = p[0].r; i != N - 1 && i; i = p[i].r) {
		if (!p[i].f && p[i].t >= len) {		// 该块可以放入 
			int u = ++ idx;		// 建立一个新块
			p[u].s = p[i].s, p[u].t = len, p[u].f = 1;	// 初始该块信息
			p[i].s += len, p[i].t -= len;	// 当该实块占用了空块的一部分时，优先会占用靠前的一部分，所以空块会右移。
			add(la, u);
			q1.push({t + s, u});
			return true;	// 匹配成功
		}
		la = i;
	}
	return false;	//匹配失败
}
void merge() {	// 合并分开的空块 
	for (int i = p[0].r; i != N - 1 && i; i = p[i].r) {
		if (!p[i].f && !p[p[i].r].f) {
			p[i].t += p[p[i].r].t;	//将后一个空块的长度累加到前一个上
			D(p[i].r);	// 删除两空块中后一个。
			i = p[i].l;		//  注意！！！这里一定要向前缩一下，这样才能处理完多个连续的空块 
		}
	}
}
void Work() {	// 通过释放空间来尝试放入后来的块 
	int T = q1.top().first;	// 释放时间
	while (q1.size() && q1.top().first == T) {	// 同一时间释放的要一起释放然后在尝试能否加入块
		int u = q1.top().second;
		p[u].f = 0;		// 更改为空块
		q1.pop();
	}
	merge();	// 释放空间后需要合并空块 
	// 若等待队列不为空，且可以成功占用内存
    while (q2.size() && work(T, q2.front().first, q2.front().second))
		ans1 = max(ans1, T + q2.front().second), q2.pop();	// 记录答案
}
signed main() {
	cin >> n;
	p[0] = {0, 0, 1, 0, N - 2};	// 左哨兵
	p[N - 1] = {n + 1, 0, 1, N - 2, 0};	//右哨兵
	p[N - 2] = {0, n, 0, 0, N - 1};		// 初始空块
	while (1) {
		int a, b, c; //申请时刻、长度、时间。 
		cin >> a >> b >> c;
		if (!a && !b && !c) break;
		while (q1.size() && q1.top().first <= a) Work();	// 尝试放入等待队列中的块
		merge();
		if (!work(a, b, c)) q2.push({b, c}), ans2 ++;	// 尝试放入当前块
	}
	while (q2.size()) Work();	// 最后处理等待队列中的剩余
	while (q1.size()) ans1 = max(ans1, q1.top().first), q1.pop();	// 记录释放队列剩余答案
	cout << ans1 << '\n' << ans2;
	return 0;
}
/*
内部核心步骤：
1：将到时间的块弹出。
2：合并空时间块。
3：检查当前是否有可以等待队列中的可放入的。
4：尝试放入当前块，若不可，将其放入等待队列。
*/
```

求指出问题，求赞，求管理员通过。

---

## 作者：JackWei (赞：1)

## 这是一个没有 log 的方法

蒟蒻[参考自这篇题解](https://www.luogu.com.cn/blog/goucw/solution-p5763)

---

### 题目大意

或许可以放一张图（样例解释）：

![](https://www.acwing.com/media/article/image/2019/01/15/19_42f2e01618-%E5%86%85%E5%AD%98.png)

---


### 需要用到的数据结构：

链表（维护内存空间），队列（维护等待进程），vector（维护已分配内存的进程）

---


### 具体思路：

将整个内存空间按照**分成若干块**，

若空间**被进程占用**，则单独为一块代表进程；

若空间空闲，则将**连续**的空闲的内存单元**看作一整块**，

块与块之间**用链表串起来**。

链表起初为整个空的内存，之后有进程申请分配 $M$ 的内存时，

从头到尾扫描链表，寻找第一块**空闲且长度足够**的内存块（设长度为 $len$ )

将这一块**分割**成前后长度为 $M$ 与 $len - M$ 的两块，

如果没有就丢进等待队列中；

若有进程结束释放内存，则找到它在链表中分配内存的位置，**变成一块空闲**的，

并与前后有**相连**的空闲内存块**合并**

这样我们可以保证 **空闲块的个数** 不多于 **进程块的个数 + 1**

所以每次扫描最多需要 $O(T)$ ， $T$ 是输入的行数的时间，

vector用于存已分配内存的进程在链表的位置和结束的时间，

总的时间复杂度约为 $O(T^2)$ ，可通过本题。

---

### 实现看代码：

**主框架：**

w 记录的是目前最早结束的进程结束的时间，在 task_out 的过程中会持续更新

task_out() 用于结束进程，释放内存，并给等待队列中的进程分配内存（因为可以在任意时刻分配，所以要在 t 时刻之前分配内存，达到一有空间就分配的目的）

task_in() 给当前进程分配，如果不行，丢队列里。

tot 统计进入队列的进程个数

len 是持续的时间

```cpp
while(1)
{
	read(t); read(m); read(len);
	if(!t && !m && !len) break;
	while(t >= w) task_out();  //释放时刻 t 之前的结束进程
	if(!task_in(t, m, len, w)) q.push({m, len}), tot ++ ;
}
```

**定义这么一个链表：**

```cpp
struct Node
{
	int value;  //记录块长
	bool tag;  // 0 为空闲，1 为占用
	Node *Prev, *Next;
};

inline void insert(Node *p, int val, bool op)  //在 p 后添加节点，op（0/1）表示是否空闲
{
	Node *q = new Node();
	q->value = val; q->tag = op;
	p->Next->Prev = q;
	q->Next = p->Next;
	p->Next = q; q->Prev = p;
}

inline void remove(Node *p)  //删除节点 p 
{
	p->Prev->Next = p->Next;
	p->Next->Prev = p->Prev;
	delete p;
}

```

**vector:**

用以维护被分配内存的进程的相关信息，


第一维记录结束时间，第二维记录在链表中的位置。

```cpp
vector<pair<int, Node*>> p;
```

**等待队列**

第一维是要分配的大小，第二维是持续的时间。

```cpp
queue<pair<int, int>> q;
```


**task_in()函数：**



```cpp
inline bool task_in(int t, int m, int len, int &w)
{
	for(Node *it = head->Next; it != tail; it = it->Next)  //扫描链表
	{
		if(it->tag == 0 && it->value >= m)  //空闲 && 空间足够
		{
			int val = it->value; val -= m;  //分割
			Node *last = it->Prev; remove(it);
			insert(last, m, 1); last = last->Next;
			if(val != 0) insert(last, val, 0);  //如果刚好占满就不用分成两块了
			p.push_back({t + len, last}); w = min(w, t + len);  //进入vector中，记录结束时间和位置，更新结束时间最小值
			return true; //分配成功，推出循环
		}
	}
	return false;
}
```

**get_blank()函数：**

用来合并空闲的块

```cpp
inline void get_blank(Node *p)
{
	int val = p->value;
	if(p->Prev != head && p->Prev->tag == 0) val += p->Prev->value, remove(p->Prev);  //向前合并
	if(p->Next != tail && p->Next->tag == 0) val += p->Next->value, remove(p->Next);  //向后合并
	Node *last = p->Prev; remove(p);
	insert(last, val, 0);  //合并成一大块
}
```


**task_out()函数：**

```cpp
inline void task_out()
{
	int wzs = INF;
	for(int i = 0; i < p.size(); i ++ )
	{
		if(p[i].first == w) get_blank(p[i].second), p.erase(p.begin() + i -- );  //释放当前最早结束的，合并，从vector中删除
		else wzs = min(wzs, p[i].first);  //记录其他进程中最早结束的
	}
	while(!q.empty())
	{
		pair<int, int> x = q.front();
		if(!task_in(w, x.first, x.second, wzs)) break; //wzs需要更新其他进程中最早结束的
		q.pop();
	}
	w = wzs;  //释放后最早结束的
} 
```

---

### 呼，最后放一下代码吧：

```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;

const int N = 10010;
const int INF = 2e9;

struct Node
{
	int value;
	bool tag;
	Node *Prev, *Next;
};

int n, t, m, len, res, tot, w = INF;
vector<pair<int, Node*>> p;
queue<pair<int, int>> q;
Node *head, *tail;

inline void read(int &x)
{
	int sgn = 1; x = 0;
	char ch = getchar();
	while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
	if(ch == '-') sgn = -1, ch = getchar();
	while(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3), x += (ch ^ '0'), ch = getchar();
	x *= sgn;
}

inline void insert(Node *p, int val, bool op)
{
	Node *q = new Node();
	q->value = val; q->tag = op;
	p->Next->Prev = q;
	q->Next = p->Next;
	p->Next = q; q->Prev = p;
}

inline void remove(Node *p)
{
	p->Prev->Next = p->Next;
	p->Next->Prev = p->Prev;
	delete p;
}

inline void get_blank(Node *p)
{
	int val = p->value;
	if(p->Prev != head && p->Prev->tag == 0) val += p->Prev->value, remove(p->Prev);
	if(p->Next != tail && p->Next->tag == 0) val += p->Next->value, remove(p->Next);
	Node *last = p->Prev; remove(p);
	insert(last, val, 0);
}

inline bool task_in(int t, int m, int len, int &w)
{
	for(Node *it = head->Next; it != tail; it = it->Next)
	{
		if(it->tag == 0 && it->value >= m)
		{
			int val = it->value; val -= m;
			Node *last = it->Prev; remove(it);
			insert(last, m, 1); last = last->Next;
			if(val != 0) insert(last, val, 0);
			p.push_back({t + len, last}); w = min(w, t + len);
			return true;
		}
	}
	return false;
}

inline void task_out()
{
	int wzs = INF;
	for(int i = 0; i < p.size(); i ++ )
	{
		if(p[i].first == w) get_blank(p[i].second), p.erase(p.begin() + i -- );
		else wzs = min(wzs, p[i].first);
	}
	while(!q.empty())
	{
		pair<int, int> x = q.front();
		if(!task_in(w, x.first, x.second, wzs)) break;
		q.pop();
	}
	w = wzs;
} 

int main()
{
	read(n);
	head = new Node(); tail = new Node();
	head->Next = tail; tail->Prev = head;
	insert(head, n, 0);
	while(1)
	{
		read(t); read(m); read(len);
		if(!t && !m && !len) break;
		while(t >= w) task_out();
		if(!task_in(t, m, len, w)) q.push({m, len}), tot ++ ;
	}
	while(!q.empty()) task_out();
	for(int i = 0; i < p.size(); i ++ ) w = max(w, p[i].first);
	printf("%d\n%d\n", w, tot);
	return 0;
}
```
---

 _**END.**_ 


---

## 作者：lg_zhou (赞：1)

非常有思维的一道模拟题，没有想清楚直接写很容易被绕进去。

这道题无非有三种让我们实现的操作：

1. 维护若干个**进程**
2. 进行**占用**内存
3. 进行内存的**释放**

维护进程、占用内存、内存释放这三个操作环环相扣。维护进程需要之前的释放，释放后又立马影响等待队列里的下一步占用…… 如何弄清楚这三者的关系,是解题的关键。

- 首先，对于每一个进程，想要判断他是否进入等待队列，之前所有结束时间小于当前进程开始时间的占用必须全部被释放。
- 很显然，若 $i<j$ 且在时间 $i$ 时等待队列队头不可占用，时间 $j$ 时可以占用，当且仅当在 $i-j$ 时间内，有内存被释放。所以，释放内存是等待队列队头可以占用的充分条件。因而，一个小贪心，我们只用在每次释放内存时判断队头是否可以进行占用即可。

所以流程就是：对于每一个进程，释放所有结束时间小于当前进程开始时间的占用。每释放一个内存，循环判断是否可以占用等待队列队头，能则占用。判断进程能否占用，能则占用，不能则加入等待队列。

实现也很简单，等待队列可以直接用 ``queue`` 。而被占用的内存用 ``set`` 即可，等待释放的队列可以用自带的 ``priority_queue`` 。

代码如下： 

```cpp
#include<iostream>
#include<queue>
#include<set>
#define int long long
using namespace std;
struct pro{ //process 进程
    int t,m,p;
};
struct rel{// release 释放
    int l,r,t;
    bool operator < (const rel &a) const{
        if (a.t == t) return a.l < l;
        return a.t < t;
    }
};
struct occ{ // occupy 占用
    int l,r;
    bool operator < (const occ &a) const{
        return a.l > l;
    }
};
queue<pro> q;
set<occ> s; 
priority_queue <rel> pq;
int ans,ans2,tm;
int n;
bool fd(pro pr, int t){// 判断能不能进行一次占用
    set<occ>::iterator it = s.begin();
    it++;
    for (;it != s.end(); it++){
        set<occ>::iterator lst = it;
        lst--;
        if ( (*it).l-(*lst).r-1 >= pr.m){ //两个占用之间的间隙如果大于等于进程长度，就可以占用。
            s.insert((occ){(*lst).r+1,(*lst).r+pr.m});
            ans = max(ans,t+pr.p);
            pq.push((rel){(*lst).r+1,(*lst).r+pr.m, t + pr.p});
            return 1;
        }
    }
    return 0;
}
void release(int t){//释放
    while(!pq.empty() && pq.top().t <= t){
        rel t = pq.top();
        s.erase(s.lower_bound((occ){t.l,t.r}));
        pq.pop();
        while(!pq.empty() && pq.top().t == t.t){//注意要一次把结束时间一样的占用一起释放
            s.erase(s.lower_bound((occ){pq.top().l,pq.top().r}));
            pq.pop();
        }
        while(!q.empty()){
            if (fd(q.front(),t.t)) q.pop(); //队头能占就继续
            else break;//不行就停，因为队头优先级最大
        }
    }
}
signed main(){
    cin >> n;
    s.insert((occ){-1,-1});
    s.insert((occ){n,n});
    for (int i = 1;; i++){
        int T,M,P;
        cin >> T >> M >> P;
        if (!T && !M && !P){
            break;
        }
        release(T);
        if (!fd((pro){T,M,P},T)){
            ans2++;
            q.push((pro){T,M,P});
        }
    }
    release(1e9+5);//最后全部释放，不能有未结束的进程
    cout << ans << endl << ans2 << endl;
    return 0;
}
```


---

## 作者：乐哥 (赞：1)

### 队列+堆+链表（用set实现）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
const int MAXN=10005;
queue<PII> wait; //内存长度，占用时间
set<PII> run; //起始下标，内存长度
priority_queue<PII,vector<PII>,greater<PII> > q; //结束时间，起始下标
int ans,cnt;
bool check(int t,int m,int p) //检查可否插入新进程
{
    set<PII>::iterator it;
    for(it=run.begin();it!=run.end();it++)
    {
        set<PII>::iterator jt=it; jt++;
        if(jt!=run.end())
        {
            int st=it->first+it->second;
            if(jt->first-st>=m)
            {
                run.insert(make_pair(st,m));
                q.push(make_pair(t+p,st));
                return true;
            }
        }
    }
    return false;
}
void free(int t) //释放到t时间为止已结束的进程
{
    while(q.size()&&q.top().first<=t)
    {
        int f=q.top().first;
        while(q.size()&&q.top().first==f)
        {
            PII top=q.top();
            q.pop();
            set<PII>::iterator it=run.lower_bound(make_pair(top.second,0));
            run.erase(it);
        }
        ans=f;
        while(wait.size())
        {
            PII ft=wait.front();
            if(check(f,ft.first,ft.second))
                wait.pop();
            else break;
        }
    }
}
int main()
{
    int n,t,m,p;
    scanf("%d",&n);
    run.insert(make_pair(-1,1));
    run.insert(make_pair(n,1));
    while(scanf("%d%d%d",&t,&m,&p)&&(t||m||p))
    {
        free(t);
        if(!check(t,m,p))
            wait.push(make_pair(m,p)),cnt++;
    }
    free(2e9);
    printf("%d\n%d",ans,cnt);
    return 0;
}
```


---

## 作者：xuyuesen (赞：0)

# P5763 题解

## 简略题意：

给你内存大小，若干个进程，对于每个进程,用三个整数 $t$、$m$、$p$ 表示申请时刻，进程大小和持续时间。  
  
- 如果在时刻 $t$ 存在长度大于 $m$ 的空闲地址片，将其放在这个地址片的左端，持续至时刻 $t+p$。
- 如果在时刻 $t$ 不存在长度大于 $m$ 的空闲地址片，将其放进等待队列中。

对于等待队列,
-   如果在时刻 $t$ 存在长度大于 $m$ 的空闲地址片，将其放在这个地址片的左端，持续至时刻 $t+p$，并将其从等待队列中删除。
-   等待队列队头的进程的优先级高于其他进程。

## 思路及实现：

使用一个队列，一个堆，一个 set（也可以是链表、数组）。队列用作等待队列，堆用来计算最早结束的进程，set 维护空闲地址片。直接按题意模拟即可。

代码中结构体 seg 用来维护空闲地址片，qu 是等待队列，pq 是优先队列（详见代码）。

代码中，meg 函数用来合并连续段（s2 为合并连续段之后的 set）：

```cpp
  void meg(){
      	s2.clear();
      	set<nd>::iter it;
      	nd x=*s.begin();
      	it=++s.begin();
      	while(it!=s.end()){
      		if((it->l)<=x.r+1){
      			x.r=max(x.r,it->r);
  			}else{
  				s2.insert(x);
  				x=*it;
  			}
  			it++;
  		}
  		s2.insert(x);
  		s.clear();
  		s=s2;
  	}
```
ck 函数用来检验长度为 $m$ 的进程是否有对应的空闲地址片，有就放入，并返回对应地址片的开头：

```cpp
  int ck(ll m){
    	set<nd>::iter it;
    	it=s.begin();
    	ll ans=0;
    	while(it!=s.end()){
    		if((it->r)-(it->l)+1>=m){
    			x=*it;
    			s.erase(it);
    			ans=x.l;
    			x.l+=m;
    			if(x.l<=x.r)s.insert(x);
    			break;
			}
    		it++;
		}
		return ans;
    }
```
del 函数用来撤销区间 $[l,r]$ 的操作：

```cpp
  void del(ll l,ll r){
    	s.insert({l,r});
        meg();    	
    }
```
psh 函数用于将等待队列的队头进程放入内存中：

```cpp
  void psh(int st){
  	while(!qu.empty()){
  	    z=qu.front();
  	    l[z.i]=x.ck(z.m);	    
  	    if(l[z.i]!=0){
  	        r[z.i]=l[z.i]+z.m;
  	        pq.push({z.p+st,z.i});
  	        qu.pop();
  	    }else break;
  	}
  }
```

pp 函数用于将到期的进程从内存中扔掉：

```cpp
  void pp(ll st){
  	ll tm;
  	while(!pq.empty()&&(pq.top().p)<=st){
          d=pq.top();
          tm=d.p;
          while(!pq.empty()&&(pq.top().p)==tm){
  			d=pq.top();
  	        x.del(l[d.i],r[d.i]-1);
  	        pq.pop();  	
  		}              
          ans=max(ans,tm);
          psh(d.p);
  	//	x.wr();
      }	
  }
```

没了。

---

## 作者：Ag2WO4 (赞：0)

这是一篇 PyPy 题解！~~主要是因为代码比较慢 Python 过不了（参考：北京大学 openjudge 上用 Python 交这个代码用时 1.4 秒多一点）~~

考虑带“合并同类项”的模拟。“合并同类项”指不按时间和单块的内存模拟（因为时间跨度可能很大，模拟内存数可能很多），转为模拟连续可合并的内存块和有限数量的事件。这需要做到合并闲置内存块和事件发生时间的记录和排序。

按题意，令旧进程结束和新进程到来都算事件，对于任何有事件发生的时间，处理顺序如下：
1. 旧进程结束，释放内存（此时若左右有闲置内存，在表示上尚未合并）；
2. 合并连续的闲置内存块；
3. 逐一判定等待队列中的进程能否进入内存并使可以者进入；
4. 最后判定新加入的进程能否进入内存并使之进入内存或等待对列。

使用列表逐一模拟即可。
### 代码
```Python
cpu=[[int(input()),-1]]#内存
event=[1<<99]#事件时间存储，垫一个数防止运行时错误
rec=now=top=0#记录
wait=[]#等待队列
t,m,p=map(int,input().split())
while t+m+p:
    while event[-1]<=t:#没轮到新进程
        for i in cpu:#释放
            if i[1]==event[-1]:
                i[1]=-1
        for i in range(len(cpu)-1,0,-1):
            if-1==cpu[i][1]==cpu[i-1][1]:#合并
                cpu[i-1][0]+=cpu[i][0]
                cpu.pop(i)
        while 1:
            flag=1
            if now==top:#等待队列是空的
                break
            for i in range(len(cpu)):
                if-1==cpu[i][1]and cpu[i][0]>=wait[now][0]:#按题意在最靠前的点插入进程
                    chk=1
                    if cpu[i][0]>wait[now][0]:
                        cpu[i][0]-=wait[now][0]
                        cpu.insert(i,wait[now][:])
                        now+=1
                        cpu[i][1]+=event[-1]
                    else:
                        cpu[i][1]=event[-1]+wait[now][1]
                        now+=1
                    for j in range(len(event)):#记录下次轮到它释放内存的时间
                        if event[j]<=cpu[i][1]:
                            chk=0
                            event.insert(j,cpu[i][1])
                            if j==1:
                                rec=max(rec,event[1])
                            break
                    if chk:
                        event.append(cpu[i][1])
                        rec=max(rec,event[1])
                    flag=0
                    break
            if flag:
                break
        event.pop()#释放事件结束
    flag=1
    for i in range(len(cpu)):#释放结束后考虑新进程
        if-1==cpu[i][1]and cpu[i][0]>=m:
            chk=1
            if cpu[i][0]>m:
                cpu[i][0]-=m
                cpu.insert(i,[m,t+p])
            else:
                cpu[i][1]=t+p
            for j in range(len(event)):
                if event[j]<=cpu[i][1]:
                    chk=0
                    event.insert(j,cpu[i][1])
                    if j==1:
                        rec=max(rec,event[1])
                    break
            if chk:
                event.append(cpu[i][1])
                rec=max(rec,event[1])
            flag=0
            break
    if flag:#进入等待队列
        wait.append([m,p])
        top+=1
    t,m,p=map(int,input().split())
while top-now:#没有新进程了，只考虑释放事件即可，直至等待队列进入完毕
    for i in cpu:
        if i[1]==event[-1]:
            i[1]=-1
    for i in range(len(cpu)-1,0,-1):
        if-1==cpu[i][1]==cpu[i-1][1]:
            cpu[i-1][0]+=cpu[i][0]
            cpu.pop(i)
    while 1:
        flag=1
        for i in range(len(cpu)):
            if-1==cpu[i][1]and cpu[i][0]>=wait[now][0]:
                chk=1
                if cpu[i][0]>wait[now][0]:
                    cpu[i][0]-=wait[now][0]
                    cpu.insert(i,wait[now][:])
                    now+=1
                    cpu[i][1]+=event[-1]
                else:
                    cpu[i][1]=event[-1]+wait[now][1]
                    now+=1
                for j in range(len(event)):
                    if event[j]<=cpu[i][1]:
                        chk=0
                        event.insert(j,cpu[i][1])
                        if j==1:
                            rec=max(rec,event[1])
                        break
                if chk:
                    event.append(cpu[i][1])
                    rec=max(rec,event[1])
                flag=0
                break
        if flag or now==top:
            break
    event.pop()
print(rec)#由于事件列表是按顺序插入（手动插排）的，每次事件列表第一项变化都意味着最后一次释放事件时间变化
print(top)#其实就是等待列表的总长度
```

---

## 作者：InversionShadow (赞：0)

## P5763 [NOI1999] 内存分配 题解

### 大模拟，主要是思路要清晰。我也是听了 y 总的讲解后才明白的。

先来分析样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/ct9a1qmv.png)

当进行到进程 A，申请 $3$ 格内存，成功，将在时间 $11$ 分结束。来到 $2$ 分钟，进程 B 申请 $4$ 格，成功，将在时间 $5$ 分结束，**进程 C 申请失败，进入等待队列。**$4$ 分钟，进程 D 成功，将在 $8$ 分钟结束。$5$ 分钟时，进程 $B$ 结束，此时进程 C 从等待队列中弹出，成功插入，剩下 $2$ 格内存进程 E 分配，**进程 E 申请失败，进入等待队列**。第 $8$ 分钟，进程 D 结束，进程 E 从等待队列中成功插入，将在 $12$ 分钟时结束，$9$ 分钟，进程 C 结束，$11$ 分钟时，进程 A 结束，$12$ 分钟，进程 E 结束，此时全部进程都运行完毕的时刻为第 $12$ 分钟，分别有 C 和 E 两个进程进入过等待队列。

### 分析

由样例分析知我们要完成两个函数。

+ 检查是否能插入的函数 

+ 释放函数 

### 检查是否能插入的函数 

用 `set` 维护，实现线性检查，如果 $a_i-a_{i-1}\ge m$，表示在 $i-1$ 和 $i$ 之间可以插入长度为 $m$ 的进程。

### 释放函数

+ 进程。假如进程在 $i$ 分钟插入，枚举前面的进程，如果在第 $i$ 时刻结束，且当前进程可以插入，则插入到第一个可以插的地方。

+ 等待队列。如果当前队头可以插入，则直接插入，因为题目规定队头的优先级高于当前插入的进程。

### Code:

代码是 y 总的，orz。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, t, m, p, ans2, ans1;

priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > q;  // 小根堆 
queue<pair<int, int> > dd; // 等待队列 
set<pair<int, int> > a;  // set 可以线性查找，删除 

bool add(int t, int m, int p) { // 检查是否能插入的函数 
  for (auto it = a.begin(); it != a.end(); it++) {
    auto l = it;              // it 的下一个元素 
    l++;
    if (l != a.end()) {    
      if (m <= l->first - it->first - it->second) { // 两个元素间的空隙可以让当前长 m 的进程插进 
        a.insert(pair<int, int> {it->first + it->second, m}); // 插入 
        q.push(pair<int, int> {t + p, it->first + it->second});
        return 1;
      }
    }
  }
  return 0;
}

void sf(int t) { // 释放函数 
  while (!q.empty() && q.top().first <= t) {          
    int tmp1 = q.top().first;                                
    while (!q.empty() && q.top().first == tmp1) { // 枚举前面的进程，看是否在当前结束，如果结束了，就可以判断是否能插入 
      auto k = q.top();
      q.pop();
      a.erase(a.lower_bound(pair<int, int> {k.second, 0})); // 找到第一个可以插入的地方插入 
    }
    ans1 = tmp1; // 记录答案，全部进程都运行完毕的时刻一定是最大的进程的结束时间 
    while (!dd.empty()) { // 等待队列 
      auto tmp = dd.front();  
      if (add(tmp1, tmp.first, tmp.second)) { // 如果队头可以插入，等待队列是严格按照进队时间确定的优先级 
        dd.pop(); // 插入，队头弹出 
      } else {
        break;
      }
    }
  }
}

int main() {
  cin >> n;
  a.insert(pair<int, int> {-1, 1}); 
  a.insert(pair<int, int> {n, 1}); // 两行是边界 
  while (1) {
    cin >> t >> m >> p;
    if (!t && !m && !p) {
      break;
    }
    sf(t); 
    if (!add(t, m, p)) { // 如果插不进去，放入等待队列 
      dd.push(make_pair(m, p));
      ans2++; // 同时进入等待队列的数量 +1 
    }
  }
  sf(2e9); // 结束所有进程，统计答案 
  cout << ans1 << endl << ans2 << endl;
  return 0;
}
```


---


# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# 题解

## 作者：MakotoTSK (赞：101)


算法：广度优先搜索

思路：每次字符串入队列后找可以执行的操作（即看一下有没有可以修改的串），把修改之后的字符串入队列，记录修改的次数。

注意：每次找可以修改的串处理完之后要从这个位置继续往后找看这个字符串后面有没有可以修改的子串。

技巧：这个题使用STL可以大幅减少码量。
```cpp
#include <iostream>
#include <string>
using namespace std;
string a,b;
string ra[7],rb[7];
struct node{
    string cur;//当前字符串
    int cs;//当前已修改次数
}q[2000000];
int main()
{
    cin>>a>>b;
    int i=1;
    while(cin>>ra[i]>>rb[i])
    {
        i++;
    }
    i-=1;
    
    int head=0,tail=1;
    q[tail].cur=a;      //原字符串入队列
    q[tail].cs=0;
    while(head<tail)
    {
        head++;
        if(q[head].cs>10)    //次数大于10输出无解后结束程序
        {
            cout<<"NO ANSWER!"<<endl;
            return 0;
        }
        for(int j=1;j<=i;j++)
        {
            int pos=q[head].cur.find(ra[j],0);
            while(1)//寻找可以修改的子串
            {
                if(pos==-1)//找不到退出
                {
                    break;
                }
                else    //找到之后把字符串修改之后塞进队列，再继续往下找
                {
                    tail++;
                    q[tail].cur=q[head].cur;
                    q[tail].cs=q[head].cs+1;
                    q[tail].cur.replace(pos,ra[j].size(),rb[j]);
                    if(q[tail].cur==b)
                    {
                        cout<<q[tail].cs;
                        return 0;
                    }
                    pos=q[head].cur.find(ra[j],pos+1);
                }
            }
        }
    }
    return 0; 
}
```

---

## 作者：lym2022 (赞：20)

Update 2025.7.18：replace 函数用法中的第一个，替换下标写成了替换下表，感谢评论区大佬指正！

蒟蒻看到这道题的题面就想到了 bfs。

前置知识：

find 函数，在字符串中查找一个子串是否存在，存在返回子串首位的下标，不存在返回 $-1$，用法 
`s.find(子串)`。




replace 函数，替换字符串中的子串
用法 `s.replace(替换下标，要替换的长度，替换的字符串)`。

思路：

可以用 map 来标记当前字符串有没有走过，~~因为蒟蒻不会其他方法~~，队列的类型可以开 pair，first 开  string 表示当前字符串，second 开 int 表示当前变化过的次数，每次枚举每一个可以变化的方案进行尝试，其他的就是 bfs 模板了，需要注意的是，在变换过程中，每次替换掉子串后需要将替换的位改为别的字符，避免在同一位置已经变换后再次变换。

Code


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 20;

int n = 1;

map<string,bool> vis;  //标记数组 

string a[N],b[N],s,t;

void bfs() {
	queue<pair<string,int> > q; 
	q.push({s,0});             //将初始状态进队，步数为0 
	while(!q.empty()) {
		string now = q.front().first;
		string nown = now;                      //存一下未变换时的初始状态 
		int step = q.front().second;
		q.pop();                                //一定要记得删掉！ 
		if(vis[now]) continue;                  //走过了就continue 
		vis[now] = true;
		if(step > 10) continue;                 //超过10步不管走没走到直接continue 
		if(now == t) {                          //走到了，输出当前步数（bfs首解最优） 
			cout << step;
			return;
		}
		for(int i = 1;i<=n;i++) {
			now = nown;                         //每次尝试能否变换为新的字符串前前需要重置当前字符串
			while(true) {
				int p = now.find(a[i]);
				if(p == -1) break;              //找不到就break 
				string str = nown;
				str.replace(p,a[i].size(),b[i]);//替换 
				q.push({str,step+1});           //新状态入队 
				now[p] = ' ';                   //将已经变换的位换成其他字符 
			}
		}
	}
	cout << "NO ANSWER!";                       //s变换不到t，输出无解 
}

int main() {
	cin >> s >> t;
	while(cin >> a[n] >> b[n]) n++;
	n--;
	if(n == 0 && s != t) {             //特判，如果没有可以变换的方案，并且两个字符串不相等，输出无解 
		cout << "NO ANSWER!";
		return 0;
	}
	bfs();
	return 0;
}
```
这是本蒟蒻的第一篇题解，有什么不足多多指教！

---

## 作者：songyouyi (赞：11)

这题没啥难的，其实就一个爆搜而已。

蒟蒻一开始试了下 dfs，超时了~~可能是因为我太菜写不出正解~~，于是就想到了 bfs。大概就是每次枚举每条规则，看看能不能改，把更改后的状态入队就可以了。

注意：

1. 一定要判重！不判重可能字串变换时会在一个环里一直绕。这里推荐使用 map 可以判重，这里相当于一个映射数组，如果没学过，可以理解成一个下标是任意类型的数组。

2. 超过一定次数就退出，因为有可能一直可以变，也会卡死循环，比如当前是 $\texttt a \texttt a \texttt a \texttt a$，有规则 $\texttt a$ 可以变到 $\texttt a \texttt a$，这样就会一直往下变。
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
string bian[1010][2];
int tot;
map<string,bool> mp;
struct node
{
	string s;
	int d;
};//s代表当前字符串，d代表修改次数
void bfs()
{
	mp[s]=1;
	queue<node> q;
	q.push({s,0});
	while (!q.empty())
	{
		node ss=q.front();
		q.pop();
		if (ss.d>10)
		{
			continue;
		}//超过一定次数就退出
		if (ss.s==t)
		{
			printf("%d",ss.d);
			exit(0);
		}
		if (ss.d==10)
		{
			continue;
		}
		int sz=ss.s.size();
		for (int i=1;i<=tot;i++)
		{
			int sz0=bian[i][0].size(),sz1=bian[i][1].size();
			int last=-1;
			while (1)
			{
				int fd=ss.s.find(bian[i][0],last+1);//第一个开头字母位置
				if (fd==-1)
				{
					break;
				}
				int j=fd;
				last=fd;
				string tt;
				for (int k=0;k<j;k++)
				{
					tt+=ss.s[k];
				}
				for (int k=0;k<sz1;k++)
				{
					tt+=bian[i][1][k];
				}
				for (int k=j+sz0;k<sz;k++)
				{
					tt+=ss.s[k];
				}
				if (mp[tt])//判重
				{
					continue;
				}
				mp[tt]=1;
				q.push({tt,ss.d+1});
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>s>>t;
	tot=0;
	while (cin>>bian[++tot][0])
	{
	//	getchar();
		cin>>bian[tot][1];
		//cout<<bian[tot][0]<<' '<<bian[tot][1]<<endl;
	}
	bfs();
	cout<<"NO ANSWER!";
	return 0;
}
```

---

## 作者：ssxzhang (赞：10)

~~本蒟蒻只会 STL~~

思路：每次输入字符串都用 map 记录一下，接着 BFS 时，如果在现在正在遍历的字符串中有咱们记录 map 里有的，那就直接变。

注意：必须把此字符串遍历完不然就会 WA !!!


最后放上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string be,en;
set<string> st;
map<string,vector<string>> mp;
map<string,bool> mp1;
int minn=0x3f3f3f3f;
int n=0;
struct node{
    string sss;
    int cs;
};
inline void bfs()
{
	queue<node> q;
    q.push(node{be,0});
    mp1[be]=1;
    while(!q.empty())
    {
        string s=q.front().sss;
        int i=q.front().cs;
        q.pop();
        if(i>=10)continue;
    	if(s==en)
    	{
    		minn=min(minn,i);
    		break;
    	}
    	for(auto x:st)
    	{
            for(int k=0;k+x.size()-1<s.size();k++)
    		{
    			string ss=s;
                if(s.substr(k,x.size())!=x)continue;
    			int tmp=k;
    			ss.erase(tmp,x.size());
    			for(auto t:mp[x])
    			{
    				string ssss=ss;
    				ssss.insert(tmp,t);
    				if(mp1[ssss])continue;
                    // if(i==0)cout<<sss<<endl;
    				mp1[ssss]=1;
                    q.push(node{ssss,i+1});
    			}
    		}
    	}
    }
}
int main()
{
	cin>>be>>en;
	string x,y;
	while(cin>>x>>y)
	{
		n++;
		st.insert(x);
        mp[x].push_back(y);
	}
	bfs();
	if(minn==0x3f3f3f3f)cout<<"NO ANSWER!";
	else cout<<minn;
	return 0;
 } 
```

---

## 作者：lyc1109 (赞：9)

### 题目大意
有两个个字符串 $a,b$，有至多 $6$ 个规则，可以把一个子字符串变换为另一个字符串。求至少多少次可以将 $a$ 变成 $b$。
#### 补充一下字符串的几个内置函数
```string s;```
1. ```s.begin()``` 返回字符串 $s$ 第一位下标的迭代器。
2. ```s.end()``` 返回字符串 $s$ 最后一位的下一个迭代器。
3. ```s.substr(pos,len)``` 返回从下标 $pos$ 开始 $len$ 个字符构成的字符串。
4. ```s.erase(pos_st,pos_nd)``` 删除从迭代器 $pos_{st}$ 到迭代器 $pos_{nd}$ 之间的所有字符。
#### 输入部分 while(cin)
```cpp
cin>>a>>b;
while(cin>>s[++tot].u){
  cin>>s[tot].v;
  maxl=max(maxl,int(s[tot].u.length()-s[tot].v.length()));
}
tot--;
```
### 思路一：纯 dfs 暴力
```cpp
#include<iostream>
#include<string>
using namespace std;
string a,b;
string u[10],v[10];
string etr;
int tot,ans=0x7fffffff;
void dfs(string now,int step){
	if(now==b){
		ans=min(ans,step);
		return;
	}
	if(step>=10){
		return;
	}
	string nown;
	for(int i=1;i<=tot;i++){
		int lenu=u[i].length(),lenn=now.length(),lenv=v[i].length();
		for(int j=0;j+lenu-1<lenn;j++){
			if(now.substr(j,lenu)==u[i]){
				nown=now;
				nown.erase(nown.begin()+j,nown.begin()+j+lenu);
				nown=nown.substr(0,j)+v[i]+nown.substr(j,lenn-lenu-j);
				dfs(nown,step+1);
			}
		}
	}
}
int main(){
	cin>>a>>b;
	while(cin>>u[++tot]){
		cin>>v[tot];
	}
	tot--;
	dfs(a,0);
	if(ans>=0x7fffffff) printf("NO ANSWER!");
	else printf("%d",ans);
	return 0;
}
```
**60pts,TLE**
### 思路二：
输入后对字符串从短到长排序，可以减少一部分复杂度。
```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
string a,b;
int tot,ans=0x7fffffff,maxl=0;
struct node{
	string u,v;
	bool operator<(const node& tmp){
		return v.length()<tmp.v.length();
	}
}s[10];
inline void dfs(string now,int step){
	if(now.length()>b.length()+maxl*10) return;
	if(now==b){
		ans=min(ans,step);
		return;
	}
	if(step>=10 || step>=ans){
		return;
	}
	string nown;
	for(int i=1;i<=tot;i++){
		int lenu=s[i].u.length(),lenn=now.length();
		for(int j=0;j+lenu-1<lenn;j++){
			if(now.substr(j,lenu)==s[i].u){
				nown=now;
				nown.erase(nown.begin()+j,nown.begin()+j+lenu);
				nown=nown.substr(0,j)+s[i].v+nown.substr(j,lenn-lenu-j);
				dfs(nown,step+1);
			}
		}
	}
}
int main(){
	cin>>a>>b;
	while(cin>>s[++tot].u){
		cin>>s[tot].v;
		maxl=max(maxl,int(s[tot].u.length()-s[tot].v.length()));
	}
	tot--;
	sort(s+1,s+tot+1);
	dfs(a,0);
	if(ans>=0x7fffffff) printf("NO ANSWER!");
	else printf("%d",ans);
	return 0;
}
```
**80pts,TLE**
### 思路三
最后，使用 map 对字符串去重，大大减少了从不同方式求得相同字符串而占用的时间。\
**给出 AC 代码**
```cpp
#include<iostream>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
string a,b;
int tot,ans=0x7fffffff,maxl=0;
struct node{
	string u,v;
	bool operator<(const node& tmp){
		return v.length()<tmp.v.length();
	}
}s[10];
map<string,int>mp;
void dfs(string now,int step){
	if(mp[now]==1) return;
	mp[now]=1;
	if(now.length()>b.length()+maxl*10) return;
	if(now==b){
		ans=min(ans,step);
		return;
	}
	if(step>=10 || step>=ans){
		return;
	}
	string nown;
	for(int i=1;i<=tot;i++){
		int lenu=s[i].u.length(),lenn=now.length();
		for(int j=0;j+lenu-1<lenn;j++){
			if(now.substr(j,lenu)==s[i].u){
				nown=now;
				nown.erase(nown.begin()+j,nown.begin()+j+lenu);
				nown=nown.substr(0,j)+s[i].v+nown.substr(j,lenn-lenu-j);
				dfs(nown,step+1);
			}
		}
	}
}
int main(){
	cin>>a>>b;
	while(cin>>s[++tot].u){
		cin>>s[tot].v;
		maxl=max(maxl,int(s[tot].u.length()-s[tot].v.length()));
	}
	tot--;
	sort(s+1,s+tot+1);
	dfs(a,0);
	if(ans>=0x7fffffff) printf("NO ANSWER!");
	else printf("%d",ans);
	return 0;
}
```
**100pts,AC!**

---

## 作者：BeansKing (赞：5)

这个题我发现大家都在用 BFS，那我们就试一下 DFS，经本蒟蒻尝试，DFS 经过一些奇奇怪怪的剪枝之后还是会 A 的。

# 步入正题

## 题目大意：

给出两个字符串 $$a$$，$$b$$。

和 $$n$$ 个规则，例如：
```cpp
string a="LO";
string b="DA";
stirng c="LODA";
c->"DADA";
```
## 具体思路：

我们分块来看。

- ### 输入：
```cpp
string x,y;
string a[1000],b[1000];
cin>>x>>y;
n=1;
while(cin>>a[n]>>b[n])
{
	n++;
}
```
- ### 搜索：

我们只需依照板子每种规则试一下即可定两个 map，一个存上一次用没用过，另一个存上一次是第几次变换用，以防死循环。
```cpp
dfs(string xx,long long cnt)//变换后的字符串和变换次数
{
  if(cnt>cntt)
	{
		return ;
	}
   if(xx==y)
	{
		ans=min(ans,cnt);//当然，ans 赋极大值，我赋的是 1000000
		return ;
	}
   for(int i=1;i<=n;i++)
    {
    long long cnt;//存上一次在哪里找到规则的第一个字符
    string s;//变换后的字符串
    while(1)
    {
      ...//找不到就退出(这里用到了 find()，不了解的请查看注释一)
      s=xx;
      s.erase(cnttt,a[i].size());
      s.insert(cnttt,b[i]);//这里参考了曾经的一片题解，可以用其他办法，这里不予展示这里用到了 erase()，insert() 不了解的请查看注释二
      dfs(s,cnt+1); 
    }
   }
}
```
- ### 优化
可以减少 cnt 的极大值以及判断 ans。
```cpp
long long cntt;
while(ans==1000000)// ans 变化则退出
{
  dfs(x,0);
  ...清空两个 map（这里用到了 clear() 不了解参考注释三)
  cntt++;
  if(cntt>10)//在 while 循环中判断，若 >10 直接退出
  {
    break;
  }
}
```

看 dfs 部分
```if(cnt>10)``` 改为 ```if(cnt>cntt)```。

再加上判进入死循环的判定(用到了前面说的两个 map)。
```cpp
dfs(string xx,long long cnt)
{
 
  if(vis[xx]&&dis[xx]<=cnt)
  {
    return ;
  }
   vis[xx]=1;
  dis[xx]=cnt;
}
```
- ### 输出

*我们的程序已经进入了尾声*
 ^_^。

```cpp
if(ans==10000000)
{
	cout<<"NO ANSWER!";
}
else
{
	cout<<ans;
 }
```
·注释

1.[find()](https://blog.csdn.net/shujh_sysu/article/details/52026108)

2.[insert() 和 erase()](https://blog.csdn.net/wang1997hi/article/details/78364755)

3.[map](https://blog.csdn.net/m0_56494923/article/details/123239292?ops_request_misc=%257B%2522request%255Fid%2522%253A%25228d162b1a0f90fce8a08f79fc24aab2d7%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=8d162b1a0f90fce8a08f79fc24aab2d7&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-123239292-null-null.142^v102^pc_search_result_base6&utm_term=c%2B%2B%20map%20clear%28&spm=1018.2226.3001.4187)

---

## 作者：Swordmaker (赞：4)

# 字串变换

# 思路分析
题目中要求最小的变换步数，不难想到如下的过程：

首先，暴力扫一遍每个字符串。

再循环枚举一个长度，循环枚举剩下的字符串，看当前截取的子字符串是否能与外层循坏的字符串匹配。如果可以，就入队，再继续判断。
重复以上步骤，直至找出匹配完成的串或无法匹配的串，并舍弃旧的无用状态。

最后，运用搜索暴力判断进行求解。如果当前的步数小于 $10$ 步且是要求的最终状态，就输出步数并结束程序。 

于是兴致勃勃地打了个广搜。

然而……

# 初次尝试
``` 
struct node
{
	string x;
	int cnt;
};
queue<node> q;
void bfs()
{
	q.push(node{a,0});
	while(!q.empty())
	{
		node now=q.front();
		q.pop();
		int len=now.x.size();
		if(now.cnt>10)
		{
			cout<<"NO ANSWER!"<<"\n";
			return;
		}
		if(now.x==b)
		{
			cout<<now.cnt<<"\n";
			return;
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=len;j++)
			{
				string cur=now.x.substr(j,ra[i].size());
				if(cur==ra[i])
				{
					string next=now.x;
					next.replace(j,ra[i].size(),rb[i]);
					q.push(node{next,now.cnt+1});
				}
			}
		}
	}
	cout<<"NO ANSWER!"<<"\n";
	return;
}
```

这份子函数的代码只有 $80$ 分。

空间超限制。

# 优化改进

那么应该如何处理这一问题呢？

以上这份代码超空间的主要原因显然是因为出队和入队太多次了。

所以，我们需要一个容器来记录当前已经存在过的状态，避免重复。

既然如此，就可以使用 map 来存储并判断当前的状态了。

完整代码如下。

# AC CODE
```cpp
#include<bits/stdc++.h>
#define inf INT_MAX
using namespace std;
string a,b,ra[10],rb[10];
int n=1,ans=inf; 
map<string,bool> mp;//去重降低空间复杂度 
struct Mipha
{
	string x;//当前字符串 
	int cnt;//当前步数 
};
queue<Mipha> Link;
void Zelda()
{
	Link.push(Mipha{a,0});
	while(!Link.empty())
	{
		Mipha now=Link.front();
		Link.pop();
		if(mp[now.x]==true) continue;//如果当前的情况已经出现过，跳过 
		mp[now.x]=true;//标记当前的情况 
		int len=now.x.size();
		if(now.cnt>10)//如果当前步数已经超过了10步 
		{
			cout<<"NO ANSWER!"<<"\n";//输出 
			return;
		}
		if(now.x==b)//完成了变换 
		{
			cout<<now.cnt<<"\n";//BFS第一个结果一定是最小步数 
			return;
		}
		for(int i=1;i<=n;i++)//遍历n种情况 
		{
			for(int j=0;j<=len;j++)
			{
				string cur=now.x.substr(j,ra[i].size());//截取对应长度的一段 
				if(cur==ra[i])//如果截取的长度的字符串可以被变换 
				{
					string next=now.x;
					next.replace(j,ra[i].size(),rb[i]);//那就将它代替成修改后的字符串 
					if(now.cnt<=9)//如果当前的步数没到10步，那就还可以继续 
					{
						Link.push(Mipha{next,now.cnt+1});//这种情况入队 
					}
				}
			}
		}
	}
	cout<<"NO ANSWER!"<<"\n";//别忘了无解的情况 
	return;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>a>>b;
	while(cin>>ra[n]>>rb[n])//输入变化的字串
	{
		n++;
	}
	n--; 
	Zelda();
	return 0;
} 
```

---

## 作者：Qianmo_su (赞：4)

本题采用双向 BFS 来解决。

首先分析一下时间复杂度：变换规则数 $R \leq 6$ ，字符串长度 $L \leq 20$，操作数在 10 次以内，用朴素 BFS 的时间复杂度为 $O((L\cdot R)^{10})$ ，完全爆炸；采用双向 BFS 的时间复杂度为 $O((L\cdot R)^{5})$ ，相对于朴素做法降低了很多的时间复杂度。

但对于本题，可能出现以下情况：**每次变换可能在字符串的多个位置替换、变换规则可能形成“无限繁殖”的状态**等，导致搜索空间飞速增长。双向 BFS 并不能保证通过本题的数据，但也是一种优化搜索的方法。

双向 BFS 的具体步骤：

+ 开两个队列 $qa,qb$，一开始分别把起点和终点丢入队列中。
+ 每次选择较小的队列进行扩展，将队头其可能经过变换规则得到的字符串丢入队列中（注意假如扩展 $qb$ ，那么需要将规则反向）。扩展的时候注意判断：假如扩展后的字符串在本队列中，则不用入队；若在另外一个队列中，说明双向搜索会合了，直接返回距离之和即可；否则更新一下距离并入队。
+ 若一直没有会合，说明没有找到。

以扩展 $qa$ 为例，设 $da[i],db[i]$ 为状态 $i$ 在 $qa,qb$ 中的操作数，假如发现扩展后的字符串在 $qb$ 中出现过，则直接返回 $da[i]+db[j]+1$ ，其中 $j$ 是由状态 $i$ 扩展得到的新状态。

我使用 `unordered_map` 处理映射关系，具体代码见下：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 6;

int n;
string A,B;
string a[N],b[N];

int extend(queue<string>& q,unordered_map<string,int>& da,unordered_map<string,int>& db,string a[],string b[])
{
    int d = da[q.front()];
    while(!q.empty() && da[q.front()] == d)
    {
        auto t = q.front();
        q.pop();
        for(int i=0;i<n;i++)
            for(int j=0;j<t.size();j++)
                if(t.substr(j,a[i].size()) == a[i])
                {
                    string r = t.substr(0,j)+b[i]+t.substr(j+a[i].size());
                    if(db.count(r)) return da[t]+db[r]+1;
                    if(da.count(r)) continue;
                    da[r] = da[t]+1;
                    q.push(r);
                }
    }
    return 11;
}

int bfs()
{
    if(A == B) return 0;
    queue<string> qa,qb;
    unordered_map<string,int> da,db;
    qa.push(A);qb.push(B);
    da[A] = db[B] = 0;
    int step = 0;
    while(!qa.empty() && !qb.empty())
    {
        int t;
        if(qa.size()<qb.size()) t = extend(qa,da,db,a,b);
        else t = extend(qb,db,da,b,a);
        if(t<=10) return t;
        if(++step == 10) return -1;
    }
    return -1;
}

int main()
{
    cin >> A >> B;
    while(cin >> a[n] >> b[n]) n++;
    int t = bfs();
    if(t == -1) puts("NO ANSWER!");
    else cout << t << endl;
    return 0;
}
```

---

## 作者：0Io_oI0 (赞：4)

竟然还可以提交题解！

为了高效地解决这道题目，我们考虑使用双向搜索解决。

我们从 $A$ 和 $B$ 同时开始搜索，要是中间有相遇，那么就说明 $A$ 能变成 $B$ 这样我们就结束搜索，在搜索的过程中，我们还需要记录 $A$ 变成 $B$ 的步数，如果步数小于等于 $10$ 那么就说明这样可以。其他情况就都输出 `NO ANSWER!` 就行了。

在双向搜索的过程中，我们每次选取长度短的字符进行单向搜索判断是否可以和另外一个字符串重合。

大体思路就这些，接下来上代码：

```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
#define i_will signed
#define ak main
#define IMO ()
I AK IOI;
string A,B;
vector<pair<string,string> >front,back;
queue<string>st,en;
unordered_map<string,int>sts,ens;
vector<string> ff(const string&s,const string&a,const string&b){
    vector<string>res;
    if(a.empty())return res;
    size_t pos=0;
    while(pos<=s.size()-a.size()){
        size_t found=s.find(a,pos);
        if(found==string::npos)break;
        string new_=s.substr(0,found)+b+s.substr(found+a.size());
        res.push_back(new_);
        pos=found+1;
    }
    return res;
}
int f(queue<string>&q,unordered_map<string,int>&step,unordered_map<string,int>&step2,vector<pair<string,string>>&r){
    int len=q.size();
    for(int i=0;i<len;i++){
        string s=q.front();
        q.pop();
        int step_=step[s];
        if(step_>=10)continue;
        for(auto&it:r){
            vector<string>next=ff(s,it.first,it.second);
            for(string&it_:next){
                if(!step.count(it_)){
                    step[it_]=step_+1;
                    q.push(it_);
                    if(step2.count(it_)){
                        int tot=step_+1+step2[it_];
                        if(tot<=10)return tot;
                    }
                }
            }
        }
    }
    return -1;
}
void bfs(){
    st.push(A);
    sts[A]=0;
    en.push(B);
    ens[B]=0;
    int ans=-1;
    while(!st.empty()&&!en.empty()){
        if(st.size()<=en.size()){
            int step=f(st,sts,ens,front);
            if(step!=-1){
                ans=step;
                break;
            }
        }
		else{
            int steps=f(en,ens,sts,back);
            if(steps!=-1){
                ans=steps;
                break;
            }
        }
    }
    if(ans!=-1&&ans<=10)cout<<ans;
	else puts("NO ANSWER!");
}
i_will ak IMO{
    cin>>A>>B;
    if(A==B){
        puts("0");
        i_ak ioi;
    }
    string a,b;
    while(cin>>a>>b){
        front.push_back({a,b});
        back.push_back({b,a});
    }
	bfs();
    i_ak ioi;
}
```

亲测可过，请勿抄袭！

---

## 作者：__Deng_Rui_Song__ (赞：4)

# presafe

~~远古题都没人写题解吗？~~

# problem

[题目传送门](/problem/P1032)

# solution

这题一眼看上去，晕，但一看数据范围，活过来了，裸的搜索啊！

既然是最优性问题，那肯定是 bfs。

不过还有复杂度更优的双向 bfs，但是，*既然近路能走，为什么要绕远路呢？*

# code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
string s, t;
vector<pair<string, string> > v;
set<string> st;
void bfs() {
  queue<pair<string, int> > q;
  q.push({s, 0});
  while (!q.empty()) {
    string x = q.front().first;
    int y = q.front().second;
    q.pop();
    if (x == t) {
      cout << y;
      return;
    }
    if (y > 10) {
      cout << "NO ANSWER!";
      return;
    }// 步数超过 10，无解
    for (int i = 0; i < v.size(); i++) {
      int pos = x.find(v[i].first);
      while (pos != -1) {
        string nxt = x.substr(0, pos) + v[i].second + x.substr(pos + v[i].first.size());
        if (!st.count(nxt)) {
          q.push({nxt, y + 1});
          st.insert(nxt);
        }
        pos = x.find(v[i].first, pos + 1);
      }//转移可以用 while + find 来写，简便一点
    }
  }
  cout << "NO ANSWER!";// 没有找到，无解
}
signed main() {
  cin >> s >> t;
  string a, b;
  while (cin >> a >> b) v.push_back({a, b});// while (cin) 太简便了
  bfs();
  return 0;
}
```

# postscript

~~建议降黄~~

---

## 作者：租酥雨 (赞：3)

蒟蒻不会打STL，不想用string类型，这里发一个最最朴素的用char数组存储的字串变换，用的是双向BFS，只是为了证明这道题可以打char数组。大家可以参考一下。

用char数组就要手动模拟字串变换的过程，过程分三个阶段：1、把变换前的字符复制到新字符串中；2、把被替换的部分忽略，把替换字符放入字符串；3、再把变换后的字符复制到字符串中。注意时刻留意字符串长度。

一定要用到的是关于字符串，定义在<cstring>中的一些函数，比如strcmp（用于字符串判等），strncmp（字符串部分判等），strlen（求字符串长度）等等。用法简单，适合蒟蒻（本人）。

双向BFS的思路很简单，就是两头轮流扩展节点，当两个head节点的步数之和大于等于10时break，输出NO ANSWER!。

这里注意一点，由于是双向，就说明目标节点应该是反着搜，所以字串变换的规则也要反过来。这里就不用A和B了，直接开二维数组，方面统一调用。

至于判断相遇（得解），我选择了每生成一个新节点，就对另一队列从头到尾扫一遍，有相同的就输出答案return 0。好在洛谷神机跑得比较快（2333）...

以上算法或许不是最优解，但也是一种新的策略，或者说一种新的尝试。

以下代码。



    
    
    
      
    


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct duilie{
    char s[400]={0};
    int len;
    int g;
}h[2][200000];//手动模拟队列 
int head[2],tail[2]={1,1};//双向BFS 
struct change{
    char a[2][400];
    int len[2];
}l[10];//这里是变换规则 
int n=1;
bool key;
void new_born(int x,int start,int num)//某一队列新生成节点，变化初位置，变换规则编号 
{
    tail[x]++;
    h[x][tail[x]].len=h[x][head[x]].len-l[num].len[x]+l[num].len[1-x];//计算出新生成节点的字符串长度 
    h[x][tail[x]].g=h[x][head[x]].g+1;
    for (int i=0;i<start;i++)
      h[x][tail[x]].s[i]=h[x][head[x]].s[i];//先拼变换之前的位置 
    for (int i=0;i<l[num].len[1-x];i++)
      h[x][tail[x]].s[i+start]=l[num].a[1-x][i];//变换的位置
    for (int i=start+l[num].len[1-x];i<h[x][tail[x]].len;i++)
      h[x][tail[x]].s[i]=h[x][head[x]].s[i+l[num].len[x]-l[num].len[1-x]];//再拼变换之后的位置
    //printf("%d队列扩展，head=%d  tail=%d g=%d 字串 ",x,head[x],tail[x],h[x][tail[x]].g);
    //for (int i=0;i<h[x][tail[x]].len;i++)
       //printf("%c",h[x][tail[x]].s[i]);
    //printf("\n\n");
    //上面这一段可以用于检验BFS过程 
    for (int k=1;k<=tail[1-x];k++)
      if ( strcmp( h[x][tail[x]].s , h[1-x][k].s ) ==0 ) //字符串判等 
      {
          printf("%d\n",h[x][tail[x]].g+h[1-x][k].g);
          key=1;
          break;
      }
}
void BFS(int x)//双向BFS 
{
    head[x]++;
    for (int i=0;i<h[x][head[x]].len;i++)//枚举待变换字串位置 
    {
        for (int j=1;j<=n;j++)//枚举变换规则 
        {       //如果变换规则的字符串和原字符串的部分相同，则可替换
            if ( strncmp( l[j].a[x] , h[x][head[x]].s+i , l[j].len[x] ) ==0 )
              new_born(x,i,j);//x队列新生成节点，变化初位置在i，变换规则j 
            if (key) return ;
        }
    }
}
int main()
{
    //freopen("zcbh.in","r",stdin);
    //freopen("zcbh.out","w",stdout);
    scanf("%s%s",h[0][1].s,h[1][1].s);
    h[0][1].len=strlen(h[0][1].s);
    h[1][1].len=strlen(h[1][1].s);
    while ( scanf("%s%s",l[n].a[0],l[n].a[1])==2 )
    {
        l[n].len[0]=strlen(l[n].a[0]);
        l[n].len[1]=strlen(l[n].a[1]);
        n++;
    }
    n--;
    while (head[0]<tail[0]&&head[1]<tail[1])
    {
        if (h[0][head[0]].g+h[1][head[1]].g>=10) break;//10步内未出解退出 
        BFS(0);
        if (key) break;
        BFS(1);
        if (key) break;
    }
    if (!key) printf("NO ANSWER!");
    return 0;
}
```

---

## 作者：TuringTime (赞：0)

## P1032 字串变换
考虑搜索，枚举所有可能通过变换得到的字串。

由于要求的是最少的变换步数，使用广度优先搜索。

```cpp
/*
补充一些字符串内置函数：
对于字符串 str
str.size() 返回 str 的长度
str.substr(pos,len) 返回从第 pos 位开始连续 len 位构成的子串，其中 pos 和 len 均为 int 类型
str.replace(pos,len,ss) 将从第 pos 位开始连续 len 位构成的子串更换为 ss，其中 pos 和 len 均为 int 类型，ss 为 string 类型
*/
#include<iostream>
#include<utility>
#include<queue>
using namespace std;
queue<pair<string,int> >q;//搜索用的队列，pair 的第一项为当前状态的字串，第二项为已经变换了多少次
pair<string,string>pr[7];//存储变换规则的数组，表示 pair 的第一项可以直接变换为 pair 的第二项
string st,ed;//分别表示初始字串和目标字串
int tot;//表示一共有多少条变换规则
void bfs()//广度优先搜索函数
{
	q.push(make_pair(st,0));
	while (!q.empty())
	{
		pair<string,int>s=q.front();
		q.pop();
		if (s.first==ed)//已经变换为目标字串
		{
			cout<<s.second<<endl;
			exit(0);
		}
		if (s.second==10)//已超过步数限制，无需再搜
			continue;
		int sz=s.first.size();
		for (int c=1;c<=tot;c++)
		{
			int tsz=pr[c].first.size();
			for (int i=0;i+tsz<=sz;i++)
			{
				string sub=s.first.substr(i,tsz);
				if (sub==pr[c].first)
				{
					q.push(s);
					q.back().first.replace(i,tsz,pr[c].second);
					q.back().second++;
				}
			}
		}
	}
}
int main()
{
	cin>>st>>ed;
	string pra,prb;
	while (cin>>pra>>prb)
		pr[++tot]=make_pair(pra,prb);
	bfs();
	puts("NO ANSWER!");
	return 0;
}
```

然而以上代码在第五个测试点会超内存。

优化：加入判重，如果一个字串被搜到过，就不再进队列。

满分代码：

```cpp
#include<iostream>
#include<utility>
#include<queue>
#include<map>
using namespace std;
queue<pair<string,int> >q;
pair<string,string>pr[7];
map<string,bool>mp;//判重
string st,ed;
int tot;
void bfs()
{
	q.push(make_pair(st,0));
	mp[st]=1;//标记为已被搜到
	while (!q.empty())
	{
		pair<string,int>s=q.front();
		q.pop();
		if (s.first==ed)
		{
			cout<<s.second<<endl;
			exit(0);
		}
		if (s.second==10)
			continue;
		int sz=s.first.size();
		for (int c=1;c<=tot;c++)
		{
			int tsz=pr[c].first.size();
			for (int i=0;i+tsz<=sz;i++)
			{
				string sub=s.first.substr(i,tsz);
				if (sub==pr[c].first)
				{
					string ps=s.first;
					ps.replace(i,tsz,pr[c].second);
					if (!mp[ps])//如果已被搜到，不再进队列
					{
						q.push(make_pair(ps,s.second+1));
						mp[ps]=1;//标记为已被搜到
					}
				}
			}
		}
	}
}
int main()
{
	cin>>st>>ed;
	string pra,prb;
	while (cin>>pra>>prb)
		pr[++tot]=make_pair(pra,prb);
	bfs();
	puts("NO ANSWER!");
	return 0;
}
```

---


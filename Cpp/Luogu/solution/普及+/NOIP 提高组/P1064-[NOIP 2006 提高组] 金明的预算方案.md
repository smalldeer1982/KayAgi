# [NOIP 2006 提高组] 金明的预算方案

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件 | 附件 |
| :----------: | :----------: |
| 电脑 | 打印机，扫描仪 |
| 书柜 | 图书 |
| 书桌 | 台灯，文具 |
| 工作椅 | 无 |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。

NOIP 2006 提高组 第二题

## 样例 #1

### 输入

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

### 输出

```
2200```

# 题解

## 作者：Anguei (赞：269)

### 这道题看起来比较难，但是如果整理好思路，非常简单。
-----
## 基本思路
既然物品分为主件和附件两类，且每个主件最多包含两个附件，那么我们不妨枚举所有的主件。那么，对于每次枚举，会有五种情况：
+ 什么都不买
+ 只买主件
+ 买主件和第一个附件
+ 买主件和第二个附件
+ 买主件和两个附件

只要把这五种情况最终的价值算出来，取最大值就可以了。

-----
## 如何开数组？
建立两个二维数组 $V_{65,3}$ 和 $P_{65,3}$，含义如题目描述。$V_{i, j}$ 和 $P_{i, j}$ 分别表示第 $i$ 个物品的第 $j$ 个附件的价格和重要度（当 $j = 0$ 时，表示主件）。

-----
## 如何预处理数组？
+ 如果是主件，则令 $V_{i, 0}, P_{i, 0} = \_v, \_p$。
+ 如果是物品 $\_q$ 的第 $j$ 个附件，则令 $V_{q,j}, P_{q,j} = \_v, \_p$。

-----
## 动态转移方程
我们可以用 $F_j$ 表示花费钱数为 $j$ 时，价格与重要度乘积的最大值。
易知：
+ 当 $F_j \geqslant V_{i, 0}$ 时，$F_j = \max\{F_j, F_{j - V{i, 0}} + V_{i, 0} \times P_{i, 0}\}$
+ 当 $F_j \geqslant (V_{i, 0} + V_{i, 1})$ 时，$F_j = \max\{F_j, F_{j - V{i, 0} - V_{i, 1}} + V_{i, 0} \times P_{i, 0} + V_{i, 1} \times P_{i, 1}\}$
+ 当 $F_j \geqslant (V_{i, 0} + V_{i, 2})$ 时，$F_j = \max\{F_j, F_{j - V{i, 0} - V_{i, 2}} + V_{i, 0} \times P_{i, 0} + V_{i, 2} \times P_{i, 2}\}$
+ 当 $F_j \geqslant (V_{i, 0} + V_{i, 1} + V_{i, 2})$ 时，$F_j = \max\{F_j, F_{j - V{i, 0} - V_{i, 1} - V_{i, 2}} + V_{i, 0} \times P_{i, 0} + V_{i, 1} \times P_{i, 1} + V_{i, 2} \times P_{i, 2}\}$

列出了状态转移方程，套背包公式就好了

-----
## 代码简化
**难道你真的要在 $\texttt{for}$ 循环内部写如此麻烦的数组下标吗？不怕写晕自己吗？**

对于这种数组下标很乱的状态转移方程，最好把下标写短一点。怎么写短呢？

观察一下刚才列出的状态转移方程，发现 $V_{i, j1} + V_{i, j2}$ 等下标被写了很多遍。不妨使用函数来计算这些值，在下标里面写函数调用。不妨：
+ 定义 $\texttt{cost2(int x, int y)}$ 计算 $V_{i, x} + V_{i, y}$、
+ 定义 $\texttt{cost3(int x, int y, int z)}$ 计算 $V_{i, x} + V_{i, y} + V_{i, z}$、
+ 定义 $\texttt{rpp(int x)}$ 计算 $V_{i, x} \times P_{i, x}$

于是，状态转移方程可以简化成这样：
+ 当 $F_j \geqslant V_{i, 0}$ 时，$F_j = \max\{F_j, F_{j - V{i, 0}} + \texttt{rpp(0)}\}$
+ 当 $F_j \geqslant \texttt{cost2(0, 1)}$ 时，$F_j = \max\{F_j, F_{j - \texttt{cost2(0, 1)}} + \texttt{rpp(0)} + \texttt{rpp(1)}\}$
+ 当 $F_j \geqslant \texttt{cost2(0, 2)}$ 时，$F_j = \max\{F_j, F_{j - \texttt{cost2(0, 2)}} + \texttt{rpp(0)} + \texttt{rpp(2)}\}$
+ 当 $F_j \geqslant \texttt{cost3(0, 1, 2)}$ 时，$F_j = \max\{F_j, F_{j - \texttt{cost3(0, 1, 2)}} + \texttt{rpp(0)} + \texttt{rpp(1)} + \texttt{rpp(2)}\}$

这样就显得好多了。

-----
## 完整 AC 代码
```cpp
//【P1064】金明的预算方案 - 洛谷 - 100
#include <iostream>
#include <algorithm> 

const int kMaxN = 32000, kMaxM = 60; // 常量名前带 k，符合命名规范
int v[kMaxM + 5][3], p[kMaxM + 5][3];
int f[kMaxN + 5];

int main() {
	int n, m;
	std::cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		int _v, _p, _q;
		std::cin >> _v >> _p >> _q;
		if (!_q) { // 是主件 
			v[i][0] = _v;
			p[i][0] = _p;
		} else {
			if (v[_q][1] == 0) { // 是第一个附件 
				v[_q][1] = _v;
				p[_q][1] = _p;
			} else { // 是第二个附件 
				v[_q][2] = _v;
				p[_q][2] = _p;
			}
		}
	}
	
	for (int i = 1; i <= m; ++i)
		for (int j = n; j >= 0; --j) {
        	// 用 lambda 表达式代替函数定义（C++11 偷懒专用)
			auto cost2 = [v, p, i](int x, int y) { return v[i][x] + v[i][y]; };
			auto cost3 = [v, p, i](int x, int y, int z) { return v[i][x] + v[i][y] + v[i][z]; };
			auto rpp = [v, p, i](int x) { return v[i][x] * p[i][x]; };
			
			if (j >= v[i][0]) // 够买主件 
				f[j] = std::max(f[j], f[j - v[i][0]] + rpp(0));
			if (j >= cost2(0, 1)) // 还够买第一个附件 
				f[j] = std::max(f[j], f[j - cost2(0, 1)] + rpp(0) + rpp(1));
			if (j >= cost2(0, 2)) // 还够买第二个附件 
				f[j] = std::max(f[j], f[j - cost2(0, 2)] + rpp(0) + rpp(2));
			if (j >= cost3(0, 1, 2)) // 还够买两个附件 
				f[j] = std::max(f[j], f[j - cost3(0, 1, 2)] + rpp(0) + rpp(1) + rpp(2));
		}
		
	std::cout << f[n] << std::endl;
}
```

---

## 作者：tuntunQwQ (赞：33)

每个主件最多有 $5$ 种情况：不选主件和附件、选主件但不选附件、选附件和第一个附件、选附件和第二个附件、选主件和两个附件。

对于编号为 $i$ 的主件，可以用 $v_{i,0}$ 表示其价格，$v_{i,1}$ 表示其第一个附件的价格，$v_{i,2}$ 表示其第二个附件的价格。$p$ 数组记录物品的重要度，表示方法同 $v$ 数组。

设 $f_{i,j}$ 表示只考虑前 $i$ 个物品，总价格为 $j$ 的价格与重要度的乘积总和的最大值。那么 $f_{i,j}$ 就等于以下 $5$ 种情况的最大值：

- $f_{i-1,j}$
- $f_{i-1,j-v_{i,0}}+v_{i,0}\times p_{i,0}$
- $f_{i-1,j-v_{i,0}-v_{i,1}}+v_{i,0}\times p_{i,0}+v_{i,1}\times p_{i,1}$
- $f_{i-1,j-v_{i,0}-v_{i,2}}+v_{i,0}\times p_{i,0}+v_{i,2}\times p_{i,2}$
- $ f_{i-1,j-v_{i,0}-v_{i,1}-v_{i,2}}+v_{i,0}\times p_{i,0}+v_{i,1}\times p_{i,1}+v_{i,2}\times p_{i,2}$

答案即为 $f_{m,n}$，代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v1,p1,q1,v[65][3],p[65][3],f[65][32005];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>v1>>p1>>q1;
		if(q1){if(v[q1][1])v[q1][2]=v1,p[q1][2]=p1;else v[q1][1]=v1,p[q1][1]=p1;}
		else v[i][0]=v1,p[i][0]=p1;
	}
	for(int i=1;i<=m;i++){
		for(int j=0;j<=n;j++){
            f[i][j]=f[i-1][j];
			if(v[i][0]<=j)f[i][j]=max(f[i][j],f[i-1][j-v[i][0]]+v[i][0]*p[i][0]);
			if(v[i][0]+v[i][1]<=j)f[i][j]=max(f[i][j],f[i-1][j-v[i][0]-v[i][1]]+v[i][0]*p[i][0]+v[i][1]*p[i][1]);
			if(v[i][0]+v[i][2]<=j)f[i][j]=max(f[i][j],f[i-1][j-v[i][0]-v[i][2]]+v[i][0]*p[i][0]+v[i][2]*p[i][2]);
			if(v[i][0]+v[i][1]+v[i][2]<=j)f[i][j]=max(f[i][j],f[i-1][j-v[i][0]-v[i][1]-v[i][2]]+v[i][0]*p[i][0]+v[i][1]*p[i][1]+v[i][2]*p[i][2]);
		}
	}
	cout<<f[m][n];
	return 0;
}
```

---

## 作者：封禁用户 (赞：21)

### 题目分析
本题是一个典型的有依赖的背包问题，在购买附件时必须先购买其对应的主件，且每个主件最多有两个附件。我们的目标是在不超过总预算的前提下，使得购买物品的价格与重要度乘积的总和最大。
### 思路
一道背包

- 定义状态 $ dp_{ij} $ 表示前 $ i $ 件物品在预算为 $ j $ 时能获得的最大价值。

- 对于每个主件，考虑五种购买情况：不买、只买主件、主件 $ + $ 附件 1、主件 $ + $ 附件 2、主件 $ + $ 附件 1 $ + $ 附件 2，取其中价值最大的情况。

- 对于附件，直接继承前 $ i - 1 $ 件物品的状态。

- 输出结果：最终结果为 $ dp_{mn}$，即前 $ m $ 件物品在预算为 $ n $ 时能获得的最大价值。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
// n 表示总钱数，m 表示物品个数，dp[i][j] 表示前 i 件物品在预算为 j 时能获得的最大价值
int n, m, dp[65][32005];
// 定义物品结构体，v 表示价格，w 表示重要度，q 表示所属主件编号，f1 和 f2 分别表示该主件的两个附件编号
struct node {
    int v, w, q, f1, f2;
} a[65];

int main () {
    // 读取总钱数 n 和物品个数 m
    scanf ("%d%d", &n, &m);
    // 读取每件物品的信息
    for (int i = 1; i <= m; i++) {
        scanf ("%d%d%d", &a[i].v, &a[i].w, &a[i].q);
        // 初始化附件编号为 -1
        a[i].f1 = -1;
        a[i].f2 = -1;
        // 如果该物品是附件
        if (a[i].q != 0) {
            // 如果主件的第一个附件已经存在，则将该附件作为主件的第二个附件
            if (a[a[i].q].f1 > 0)
                a[a[i].q].f2 = i;
            // 否则将该附件作为主件的第一个附件
            else
                a[a[i].q].f1 = i;
        }
    }
    // 动态规划过程
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            // 如果该物品是附件，直接继承前 i - 1 件物品的状态
            if (a[i].q > 0)
                dp[i][j] = dp[i - 1][j];
            else {
                // 获取主件的两个附件编号
                int f1 = a[i].f1, f2 = a[i].f2;
                // 初始化当前状态为前 i - 1 件物品的状态
                int t = dp[i - 1][j];
                // 情况1：只买主件
                if (j >= a[i].v)
                    t = max (t, dp[i - 1][j - a[i].v] + a[i].v * a[i].w);
                // 情况2：主件 + 附件1
                if (f1 > 0 && j >= a[i].v + a[f1].v)
                    t = max (t, dp[i - 1][j - a[i].v - a[f1].v] + a[i].v * a[i].w + a[f1].v * a[f1].w);
                // 情况3：主件 + 附件2
                if (f2 > 0 && j >= a[i].v + a[f2].v)
                    t = max (t, dp[i - 1][j - a[i].v - a[f2].v] + a[i].v * a[i].w + a[f2].v * a[f2].w);
                // 情况4：主件 + 附件1 + 附件2
                if (f1 > 0 && f2 > 0 && j >= a[i].v + a[f1].v + a[f2].v)
                    t = max (t, dp[i - 1][j - a[i].v - a[f1].v - a[f2].v] + a[i].v * a[i].w + a[f1].v * a[f1].w + a[f2].v * a[f2].w);
                // 更新当前状态
                dp[i][j] = t;
            }
        }
    }
    // 输出最终结果
    printf ("%d", dp[m][n]);
    return 0;
}
```

---

## 作者：wangkaiwei (赞：9)

金明啊金明，你是开心了，~~我是不会告诉你我交了三遍。~~

# 思路
我看到题的第一反应是按照主件进行分组，组内进行 $\texttt{01}$ 背包。但是，这只是一道 $\color{green}绿题$ 啊，不可能这么麻烦。注意到题目中说

> 每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。

所以对于每组只有 $5$ 种情况：  

- 什么都不买
- 只买主件
- 买主件和第一个附件（前提是有第一个附件）
- 买主件和第二个附件（前提是有第二个附件）
- 买主件和两个附件（前提是有两个附件）

然后对以上方案产生的价值取最大值。

状态转移方程和基础的背包一样，这里不再赘述。

# 代码实现
可以建一个结构体，里面包含 $v,p,q,lc,rc$，分别表示物品的价格、重要度以及它对应的的主件、第一个附件、第二个附件。边读入边处理，如果这件物品是附件，找到它的主件，并判断是第几个主件。


```cpp
	for(int i=1;i<=m;i++){
		cin>>a[i].v>>a[i].p>>a[i].q;
		if(a[i].q!=0){
			if(a[a[i].q].lc==0) a[a[i].q].lc=i;
			else a[a[i].q].rc=i;
		}
		a[i].s=a[i].v*a[i].p;
	}
```

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct thing{int v,p,q,lc,rc,s;}a[70];
int dp[50005];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i].v>>a[i].p>>a[i].q;
		if(a[i].q!=0){
			if(a[a[i].q].lc==0) a[a[i].q].lc=i;
			else a[a[i].q].rc=i;
		}
		a[i].s=a[i].v*a[i].p;
	} 
	for(int i=1;i<=m;i++){
		if(a[i].q==0){
			for(int j=n;j>=1;j--){
				if(j>=a[i].v) dp[j]=max(dp[j-a[i].v]+a[i].s,dp[j]);
				if(a[i].lc!=0&&j>=a[i].v+a[a[i].lc].v){
					dp[j]=max(dp[j-a[i].v-a[a[i].lc].v]+a[i].s+a[a[i].lc].s,dp[j]);
				}
				if(a[i].rc!=0&&j>=a[i].v+a[a[i].rc].v){
					dp[j]=max(dp[j-a[i].v-a[a[i].rc].v]+a[i].s+a[a[i].rc].s,dp[j]);
				}
				if(a[i].lc!=0&&a[i].rc!=0&&j>=a[i].v+a[a[i].lc].v+a[a[i].rc].v){
					dp[j]=max(dp[j-a[i].v-a[a[i].rc].v-a[a[i].lc].v]+a[i].s+a[a[i].rc].s+a[a[i].lc].s,dp[j]);
				}
			}	
		}
	}
	cout<<dp[n];
	return 0;
}
```
~~我觉得可以降黄~~

---

## 作者：pipilong2024 (赞：7)

# P1064 题解报告

[题目链接](https://www.luogu.com.cn/problem/P1064)\
首先我们针对于每一件物品我们定义其 ***价值*** 为 $c_i=w_i \times v_i$。\
其次针对于每一组物品，我们有以下五种选择：\
1\. 只买主件\
2\. 买主机加附件 1\
3\. 买主件加附件 2\
4\. 全买\
5\. 都不买\
以上五种选择对应的代价和价值是（此处我们令当前这组主件为 $mc$，附件 1 为 $c_1$，附件 2 为 $c_2$）：

|  编号 |   购买情况   |            代价            |            价值           |
| :-: | :------: | :----------------------: | :----------------------: |
|  1  |   只买主件   |         $v_{mc}$         |            $w_{mc}$            |
|  2  | 买主机加附件 1 |     $v_{mc}+v_{c_1}$     |     $w_{mc}+w_{c_1}$     |
|  3  | 买主件加附件 2 |     $v_{mc}+v_{c_2}$     |     $w_{mc}+w_{c_2}$     |
|  4  |    全买    | $v_{mc}+v_{c_1}+v_{c_2}$ | $w_{mc}+w_{c_1}+w_{c_2}$ |
|  5  |    都不买   |            $0$           |            $0$           |

然后考虑存储问题，不妨定义一个二维数组 $c$，其中第一维度存储主件，第二维度存储附件。\
其中**第 $i$ 维度下标为 $1$ 的元素**表示**第 $i$ 个物品的第 $1$ 个附件**，同理，**第 $i$ 维度下标为 $2$ 的元素**表示**第 $i$ 个物品的第 $2$ 个附件**，特别地，为了存储每个主件分别有多少个附件，我们定义**第 $i$ 维度下标为 $0$ 的元素 $c_{i,0}$** 表示**第 $i$ 个物品有 $c_{i,0}$ 个附件**（显然，如果第 $i$ 个物品为附件，那么 $c_{i,0}$ 一定为 $0$），且**所有主件均属于编号为 $0$ 的物品的附件。**\
为了方便理解，接下来我们用样例来举例二维数组 $c$ 的存储情况。

|表头|0|1|2|3|
|:-:|:-:|:-:|:-:|:-:|
|**0**|$3$|$1$|$4$|$5$|
|**1**|$2$|$2$|$3$|空|
|**2**|$0$|空|空|空|
|**3**|$0$|空|空|空|
|**4**|$0$|空|空|空|
|**5**|$0$|空|空|空|

见上，$c_{0,0}$ 表示一共有 $3$ 个主件，$c_{1,0}$ 表示第 $1$ 个物品一共有 $2$ 个附件，其中第 $2$ 个附件（即 $c_{1,2}$）是编号为 $3$ 的物品。
___
最后我们只需将每组看做一个物品跑个采药（即 P1048）即可：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, m, f[32001], c[32001][61];
int v[32001], w[32001];
int update(int i, int k) { //update意为更新
	int tmp = f[k], mc = c[0][i], c1 = c[mc][1], c2 = c[mc][2]; //mc是main component（主件）
	int vmc = v[mc], v1 = v[c1], v2 = v[c2];
	//!!!重要部分--状态转移方程
	//上面讲的五种情况，第五种情况就是f[k]，所以直接放第7行上了（tmp初始化） 
	if (k - vmc >= 0) tmp = max(f[k - vmc] + w[mc], tmp);
	if (k - vmc - v1 >= 0) tmp = max(f[k - vmc - v1] + w[mc] + w[c1], tmp);
	if (k - vmc - v2 >= 0) tmp = max(f[k - vmc - v2] + w[mc] + w[c2], tmp);
	if (k - vmc - v1 - v2 >= 0) tmp = max(f[k - vmc - v1 - v2] + w[mc] + w[c1] + w[c2], tmp);
	//
	return tmp;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int q;
		cin >> v[i] >> w[i], w[i] *= v[i]; //见文末给出的链接(开心的金明 题解，里面有详讲)，此处主要是对价值重新定义了一遍 
		cin >> q, c[q][++c[q][0]] = i; //添加附件
	}
	for (int i = 1; i <= c[0][0]; i++) for (int k = n; k >= v[i]; k--) f[k] = update(i, k); //01背包模板（除了状态转移不同）
	cout << f[n];
	return 0;
}
```
[推销同类题](https://www.luogu.com.cn/article/qqdk1egl)

---

## 作者：ClV_Csy (赞：5)

# P1064 [NOIP2006 提高组] 金明的预算方案
## 前言
- 01 背包  
如果不会，可以先解决 [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)（01 背包模板题），熟悉 01 背包后再来尝试解决此题。
## 题意
给出 $m$ 个物品，每个物品要么是主件，要么是附件，并且每个物品都有一个**价格** $v_i$ 和一个**重要度** $w_i$，要求出使用不超过 $n$ 元能买到物品的最大价值。
## 思路
每个物品要么是主件要么是附件，因此可以建立结构体，每个结构体元素 $a_i$ 有 $6$ 个成员，分别是：
$$v_1, v_2, v_3, s_1, s_2, s_3$$
其中，  
$v_1$ 表示序号为 $i$ 的主件的**价格**，$v_2$ 表示序号为 $i$ 的第一个附件的**价格**，$v_3$ 表示序号为 $i$ 的第二个附件的**价格**；  
我们将物品的**价格与重要度的乘积**称为**价值**。  
$s_1$ 表示序号为 $i$ 的逐渐的**价值**，$s_2$ 表示序号为 $i$ 的第一个附件的**价值**，$s_3$ 表示序号为 $i$ 的第二个附件的**价值**。

依次输入 $m$ 个物品的价格 $v$、重要度 $p$ 以及它对应的主件 $q$。
- 若 $q = 0$，即该物品自身为主件，则 $v_1 \gets v$，$s_1 \gets v \times p$。
- 若 $q \ne 0$，即该物品自身为附件，且 $a_q$ 的 $v_2 \ne 0$（现在还没有序号为 $i$ 的第一个附件，所以当前物品成为第一个附件），则 $v_2 \gets v$，$s_2 \gets v \times p$。
- 若 $q \ne 0$，即该物品自身为附件，且 $a_q$ 的 $v_2 = 0$（现在已经有了序号为 $i$ 的第一个附件，由于每个主件最多有 $2$ 个附件，所以当前物品成为第二个附件），则 $v_3 \gets v$，$s_3 \gets v \times p$。

```cpp
#include <iostream>
using namespace std;
struct node {
	int v1 = 0, v2 = 0, v3 = 0;
	int s1 = 0, s2 = 0, s3 = 0;
}a[70];
int n, m;
int v, p, q;
int dp[32010];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> v >> p >> q;
		if (q == 0) {
			a[i].v1 = v;
			a[i].s1 = v * p;
		} else {
			if (a[q].v2 == 0) {
				a[q].v2 = v;
				a[q].s2 = v * p;
			} else {
				a[q].v3 = v;
				a[q].s3 = v * p;
			}
		}
	}
	return 0;
}
```

-----
完成上述操作后，再进行 01 背包，$dp_j$ 表示花 $j$ 元可以买到的最大总**价值**。  
以 01 背包标准代码为范例，其中 $w_i$ 表示花费，$v_i$ 表示价值。

```cpp
for (int i = 1; i <= n; i++)
	for (int j = W; j >= 1; j--)
		if (w[i] <= j)
			f[j] = max(f[j], f[j - w[i]] + v[i]);
cout << f[W];
```

Q & A：  
Q：为什么要判断 $w_i \le j$？  
A：防止数组 `f` 下标为负导致越界。

深入思考 Q 提出的问题，可以发现本题也有相似之处。
现先给出代码，再进行分析。

```cpp
if (a[i].v1 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1] + a[i].s1);
if (a[i].v1 + a[i].v2 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2] + a[i].s1 + a[i].s2);
if (a[i].v1 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v3] + a[i].s1 + a[i].s3);
if (a[i].v1 + a[i].v2 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2 - a[i].v3] + a[i].s1 + a[i].s2 + a[i].s3);
```

我们进行逐步拆解分析：
```cpp
if (a[i].v1 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1] + a[i].s1);
```
和 01 背包标准代码对照，可以发现此时 `a[i].v1` 就是花费，`a[i].s1` 就是价值。与前文 Q & A 相似，判断语句是为了防止数组越界。此时的操作是只考虑主件的。
```cpp
if (a[i].v1 + a[i].v2 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2] + a[i].s1 + a[i].s2);
```
类比，可以发现此时 `a[i].v1 + a[i].v2` 是花费，`a[i].s1 + a[i].s2` 是价值。此时的操作考虑的是主件与第一个附件搭配的情况。
```cpp
if (a[i].v1 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v3] + a[i].s1 + a[i].s3);
```
类比，可以发现此时 `a[i].v1 + a[i].v3` 是花费，`a[i].s1 + a[i].s3` 是价值。此时的操作考虑的是主件与第二个附件搭配的情况。
```cpp
if (a[i].v1 + a[i].v2 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2 - a[i].v3] + a[i].s1 + a[i].s2 + a[i].s3);
```
类比，可以发现此时 `a[i].v1 + a[i].v2 + a[i].v3` 是花费，`a[i].s1 + a[i].s2 + a[i].s3` 是价值。此时的操作考虑的是主件与第一个附件和第二个附件搭配的情况。

这样全部考虑一遍后即可得到最终答案。
## 代码

```cpp
#include <iostream>
using namespace std;
struct node {
	int v1 = 0, v2 = 0, v3 = 0;
	int s1 = 0, s2 = 0, s3 = 0;
}a[70];
int n, m;
int v, p, q;
int dp[32010];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> v >> p >> q;
		if (q == 0) {
			a[i].v1 = v;
			a[i].s1 = v * p;
		} else {
			if (a[q].v2 == 0) {
				a[q].v2 = v;
				a[q].s2 = v * p;
			} else {
				a[q].v3 = v;
				a[q].s3 = v * p;
			}
		}
	}
	for (int i = 1; i <= m; i++) {
		if (a[i].v1 == 0) continue;
		for (int j = n; j >= 1; j--) {
			if (a[i].v1 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1] + a[i].s1);
			if (a[i].v1 + a[i].v2 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2] + a[i].s1 + a[i].s2);
			if (a[i].v1 + a[i].v3 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v3] + a[i].s1 + a[i].s3);
			if (a[i].v1 + a[i].v2 + a[i].v3 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2 - a[i].v3] + a[i].s1 + a[i].s2 + a[i].s3);
		}
	}
	cout << dp[n];
	return 0;
}
```

---

## 作者：LeavingAC (赞：3)

**begin**

[P1064 [NOIP 2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

# 题目大意

给你一堆物品的价格和重要程度，这些物品分为主件和附件，其中每个主件最多有两个附件，求在给定价格内每件物品的价格与重要程度的乘积的总和最大是多少。

# 分析

这题看起来挺唬人的，其实扒了外皮就是个背包，只不过多了个主件附件的问题。

# 思路

既然买了附件就必须买主件，那我们不妨将它们绑定在一起，然后枚举每一个主件的购买方式。

对于每一次购买，只会出现以下 $5$ 种购买方式：

- 什么都不买。
- 只买主件。
- 买主件和第一个附件。
- 买主件和第二个附件。
- 买主件和全部两个附件。

我们只要把这五种情况的价值套一下背包板子算出来，取一下最大值即可。

至于如何绑定主件和附件，我们可以定义一个数组 $son_{i,3}$，其中 $son_{i,0} $ 表示其附件的个数（其实也可以不要，~~但是我太懒~~），$son_{i,1} $ 表示其第一个附件的编号，$son_{i,2} $ 同理。

# 动态转移方程

我们设 $dp_j$ 为花费 $j$ 元所能得到的最大答案，那么有：

$dp_j=\max(dp_j,dp_{j-v_i}+v_i\times w_i)$

$i$ 表示物体编号，从 $1$ 枚举到 $m$。  
$j$ 表示此时背包的容积（价格），从 $n$ 倒着枚举到 $0$。

不难发现，这玩意实际上就是一个 01 背包板子。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll n,m,v[70],w[70],c[70],dp[32010],son[70][3],q[70];
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for (ll i=1;i<=m;i++)
    {
        cin>>v[i]>>w[i]>>q[i];
        c[i]=v[i]*w[i]; // 只是因为我懒得写乘号
        if (q[i]) son[q[i]][++son[q[i]][0]]=i; // 绑定
    }
    for (ll i=1;i<=m;i++) // 背包板子
    {
        for (ll j=n;j>=0;j--)
        {
            if (q[i]) continue; // 我们只考虑主件
            if (j>=v[i]) // 够买主件
                dp[j]=max(dp[j],dp[j-v[i]]+c[i]);
            if (son[i][1] && j>=v[i]+v[son[i][1]]) // 够买主件和附件1
                dp[j]=max(dp[j],dp[j-v[i]-v[son[i][1]]]+c[i]+c[son[i][1]]);
            if (son[i][2] && j>=v[i]+v[son[i][2]]) // 够买主件和附件2
                dp[j]=max(dp[j],dp[j-v[i]-v[son[i][2]]]+c[i]+c[son[i][2]]);
            if (son[i][0]>=2 && j>=v[i]+v[son[i][1]]+v[son[i][2]]) // 够买主件和全部附件
                dp[j]=max(dp[j],dp[j-v[i]-v[son[i][1]]-v[son[i][2]]]+c[i]+c[son[i][1]]+c[son[i][2]]);
        }
    }
    cout<<dp[n];
    return 0;
}
```

**end**

---

## 作者：RyanLi (赞：3)

传送门：[P1064 [NOIP 2006 提高组] 金明的预算方案](https://www.luogu.com.cn/problem/P1064)

更佳的阅读体验：[洛谷 P1064 题解](https://blog.ryanli.top/index.php/archives/256/)

---

**简要题意**：共有 $n$ 元钱和 $m$ 个物品，每个物品有价格 $v$ 和重要度 $w$。物品分为主件和附件，每个主件拥有 $0 \sim 2$ 个附件，购买附件时必须同时购买主件。设计一个购买方案，使得所有物品的价格与重要度的乘积总和（即 $\sum \limits_{i = 1}^{m} v_i \times w_i$）最大，并输出这个总和。

如果我们将每件物品的单价看作体积，价格与重要度的乘积看作价值，共有 $n$ 元钱看作最大容积，那么可以发现这是一个 0-1 背包问题。但是似乎与朴素的 0-1 背包不太一样，因为有主件与附件之分。

因为如果要买附件，就一定要买它对应的主件，也就是说，**不会存在单独购买附件的情况**。同时，**附件不再有从属于自己的附件**，那么当购买主件和某些附件时，我们就可以将主件与附件视作一个整体。

此时问题就变得简单起来。我们仍然可以套用 0-1 背包的模板，只需要多加几次状态转移即可，用来判断应该只购买主件、购买主件和其中一个附件，还是购买主件和它的两个附件。

为了方便转移，我们需要提前对每个附件进行预处理。把存储每个物品的价格 $v$ 和重要度 $w$ 的数组开成二维数组，$v_{i, 0}$ 与 $p_{i, 0}$ 表示物品 $i$ 的价格和重要度，$v_{i, 1}$ 和 $p_{i, 1}$ 表示物品 $i$ 的第 $1$ 个附件的价格和重要度，$v_{i, 2}$ 和 $p_{i, 2}$ 表示物品 $i$ 的第 $2$ 个附件的价格和重要度。

```cpp
#include <iostream>
using namespace std;
using ll = long long;

const int N = 3.2e4 + 10, M = 70, P = 4;
int n, m, x, y, z, v[M][P], p[M][P], f[N];

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> x >> y >> z;
        if (!z) v[i][0] = x, p[i][0] = y;
        else if (!v[z][1]) v[z][1] = x, p[z][1] = y;
        else v[z][2] = x, p[z][2] = y;
    } for (int i = 1; i <= m; ++i)
        for (int j = n; j; --j) {
            if (v[i][0] <= j) f[j] = max(f[j], f[j - v[i][0]] + v[i][0] * p[i][0]);
            if (v[i][0] + v[i][1] <= j)
                f[j] = max(f[j], f[j - v[i][0] - v[i][1]] + v[i][0] * p[i][0] + v[i][1] * p[i][1]);
            if (v[i][0] + v[i][2] <= j)
                f[j] = max(f[j], f[j - v[i][0] - v[i][2]] + v[i][0] * p[i][0] + v[i][2] * p[i][2]);
            if (v[i][0] + v[i][1] + v[i][2] <= j)
                f[j] = max(f[j], f[j - v[i][0] - v[i][1] - v[i][2]] + v[i][0] * p[i][0] + v[i][1] * p[i][1] + v[i][2] * p[i][2]);
        }
    cout << f[n] << '\n';
    return 0;
}
```

---

## 作者：jackgdn (赞：3)

每一个主件最多带有 $2$ 个附件，所以每一个主件都有五种情况，每种情况与其所对应的价格-期望分别为

* 啥都不选，$(0,0)$；
* 只选主件，$(v_{main}, v_{main}\times p_{main})$；
* 选主件和附件一（如果存在），$(v_{main}+v_{attach1}, v_{main}\times p_{main}+v_{attach1}\times p_{attach1})$；
* 选主件和附件二（如果存在），$(v_{main}+v_{attach2}, v_{main}\times p_{main}+v_{attach2}\times p_{attach2})$；
* 选主件和两个附件（如果存在），$(v_{main}+v_{attach1}+v_{attach2}, v_{main}\times p_{main}+v_{attach1}\times p_{attach1}+v_{attach2}\times p_{attach2})$；

以上五种情况相互冲突，只能选则一种。此时，这道依赖背包问题就被转换成了分组背包问题。

另外由于题目给出的金额都是 $10$ 的倍数，因此可以在处理时将所有金额都除以 $10$，最后再乘回去以降低时空消耗。

下面是使用滚动数组优化过的代码：

```python
from collections import defaultdict

n, m = map(int, input().strip().split(" "))
n //= 10

main = list()
attach = defaultdict(list)
for i in range(1, m + 1):
    v, p, q = map(int, input().strip().split(" "))
    v //= 10
    if q == 0:
        main.append((v, p, i))
    else:
        attach[q].append((v, p))

dp = [0] * (n + 1)
for m in main:
    v_main, p_main, idx = m
    atch = attach[idx]
    comb = list()
    comb.append((0, 0))
    comb.append((v_main, v_main * p_main))
    if len(atch) >= 1:
        v_atch, p_atch = atch[0]
        comb.append((v_main + v_atch, v_main * p_main + v_atch * p_atch))
    if len(atch) == 2:
        v_atch, p_atch = atch[1]
        comb.append((v_main + v_atch, v_main * p_main + v_atch * p_atch))
    if len(atch) == 2:
        v_atch1, p_atch1 = atch[0]
        v_atch2, p_atch2 = atch[1]
        comb.append((v_main + v_atch1 + v_atch2, v_main * p_main + v_atch1 * p_atch1 + v_atch2 * p_atch2))

    for j in range(0, n + 1)[::-1]:
        for v, val in comb:
            if j >= v:
                dp[j] = max(dp[j], dp[j - v] + val)

print(dp[-1] * 10)

```

在输入数据中某些附件的数据可能先于其主件数据输入，故需要使用 `defaultdict` 存储附件信息，否则会 RE。

---

## 作者：Walrus (赞：2)

**这道题看起来比较难，但是如果整理好思路，非常简单。**

## Solution

有依赖的背包。

这个题的难点大概在依赖这个地方，观察到一个主件最多有两个附件，考虑暴力枚举选择附件的方案，然后这个复杂度是指数级别的。

然后考虑给主件做 dp，很显然我们按照 0/1 背包的套路定义 $dp_i$ 表示容量为 $i$ 时的最大价值，转移方法与 0/1 背包相同，是

$$dp_j=\max\limits_{j\geq weight_i}(dp_{j-weight_i}+value_i)$$

注意不要转移附件，复杂度是 $O(2^K\times NM)$，这个 $K$ 是一个主件最多有多少个附件数，由于这个题 $K=2$ 其实没必要写个 dfs 啥的。

代码几年前写的有点丑。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr)
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define pb push_back
#define PII pair<int, int>
#define fi first
#define se second

using namespace std;

const int N = 4e4 + 5;
int n, m, v, p, q, w1[N], c1[N], w2[N][3], c2[N][3], dp[N];

void read() {
	cin >> m >> n;
	rep(i, 1, n) {
		cin >> v >> p >> q;
		if (!q) w1[i] = v, c1[i] = v * p;
		else w2[q][0]++, w2[q][w2[q][0]] = v, c2[q][w2[q][0]] = v * p;
	}
}

signed main() {
	FASTIO;
	read();
	
	rep(i, 1, n) {
		pre(j, m, w1[i]) {
			if(!w1[i]) break;//不要转移附件
			dp[j] = max(dp[j], dp[j - w1[i]] + c1[i]);
			if (j >= w1[i] + w2[i][1])
				dp[j] = max(dp[j], dp[j - w1[i] - w2[i][1]] + c1[i] + c2[i][1]);
			if (j >= w1[i] + w2[i][2])
				dp[j] = max(dp[j], dp[j - w1[i] - w2[i][2]] + c1[i] + c2[i][2]);
			if (j >= w1[i] + w2[i][1] + w2[i][2])
				dp[j] = max(dp[j], dp[j - w1[i] - w2[i][1] - w2[i][2]] + c1[i] + c2[i][1] + c2[i][2]);
		}
	}
	cout << dp[m];
	return 0;
}
```

---

## 作者：Starry_Sky_135 (赞：2)

**思路**

读一遍题目就会发现，这其实是一个较为复杂的背包问题。再仔细思考一下会发现，只需要分出几种情况，代码实现就会变得很简单。


---


**五种情况（核心部分，即状态转移方程）**


```cpp
//数组名称说明：mainc[i]为主件i的价格,mainp[i]为主件i的重要度,annexc[i][k]为属于主件i的k号附件的价格,annexp[i][k]为属于主件i的k号附件的重要度
dp[j]=max(dp[j],dp[j-mainc[i]]+mainp[i]);//这里包含了两种情况，分别是什么都不买和只买主件
if(j>=mainc[i]+annexc[i][1]) dp[j]=max(dp[j],dp[j-mainc[i]-annexc[i][1]]+mainp[i]+annexp[i][1]);//买主件和1号附件
if(j>=mainc[i]+annexc[i][2]) dp[j]=max(dp[j],dp[j-mainc[i]-annexc[i][2]]+mainp[i]+annexp[i][2]);//买主件和2号附件
if(j>=mainc[i]+annexc[i][1]+annexc[i][2]) dp[j]=max(dp[j],dp[j-mainc[i]-annexc[i][1]-annexc[i][2]]+mainp[i]+annexp[i][1]+annexp[i][2]);//买主件、1号附件和2号附件
```


---

**完整AC代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=32010;
int n,m;
int mainp[MAXN],mainc[MAXN];
int annexp[MAXN][3],annexc[MAXN][3];
int temp[MAXN];
int dp[MAXN];
int main()
{
    cin>>n>>m;
    for(int i=1,v,p,q;i<=m;i++)
    {
        cin>>v>>p>>q;
        if(q==0)
        {
            mainc[i]=v;
            mainp[i]=v*p;
        }
        else
        {
            temp[q]++;//计数，计算当前为几号附件
            annexc[q][temp[q]]=v;
            annexp[q][temp[q]]=v*p;
        }
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=n;mainc[i]!=0&&j>=mainc[i];j--)
        {
            dp[j]=max(dp[j],dp[j-mainc[i]]+mainp[i]);
            if(j>=mainc[i]+annexc[i][1]) dp[j]=max(dp[j],dp[j-mainc[i]-annexc[i][1]]+mainp[i]+annexp[i][1]);
            if(j>=mainc[i]+annexc[i][2]) dp[j]=max(dp[j],dp[j-mainc[i]-annexc[i][2]]+mainp[i]+annexp[i][2]);
            if(j>=mainc[i]+annexc[i][1]+annexc[i][2]) dp[j]=max(dp[j],dp[j-mainc[i]-annexc[i][1]-annexc[i][2]]+mainp[i]+annexp[i][1]+annexp[i][2]);
        }
    }
    cout<<dp[n]<<endl;
    return 0;
}
```

---

## 作者：O_N_N (赞：1)

动态规划有一点特点是它有很好的性质，且它的性质只有很质朴的一句或几句数学公式，之前的题解已经提到了上述公式。 作为菜鸟我只能在原有的数学公式上补充一下我的标准库的数据结构的做法。

显然，因为有附件的存在，这道题不能用简单的背包问题来解决，而是对背包问题的价值判断有了分类讨论。准确来说，原来的背包问题就是一个物品只有一个价值和代价。但是这里的一个物品并非可以直接使用，因为主件和附件的存在，附件必须在主件被选择后才能选择，那么如何转化为背包问题呢？

我们可以将原有的许多物品先分为主件和附件，然后把附件依附在主件上，附件因此消失，使得主件并非只有一个代价和价值，根据它附件的多少我们可以分为可选择的多种价值和代价。

如果没有附件，那么这个主件的价值和代价就是它自己。

如果有一个附件，那么这个主件的价值和代价有两种情况，一种是不选择附件的情况；另一种是选择附件的情况，代价和价值转变为了主件和附件的和。

如果有两个附件，那么一共有四种情况，一种是不选择附件的情况；另一种是选择第一个附件的情况，代价和价值转变为了主件和第一个附件的和；另一种是选择第二个附件的情况，代价和价值转变为了主件和第二个附件的和；最后一种情况是选择所有附件的情况，代价和价值为它们的总和。

那么，在只考虑主件的情况下，这个问题就转变为了背包问题。

同时要注意，附件可能先于主件输入，于是它可能不会有一个良好的输入的数据结构。于是在我们发现这玩意没有主件的情况下先插入一组数据，在后续主件来时再解决主件晚于附件输入的情况。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
void p1064(){
    ll n,m;
    cin>>n>>m;
    vector<ll> dp(n+1,0);
    vector<vector<ll> > vs(m,vector<ll>()),ps(m,vector<ll> ());
    //                                  价格 重要程度
    for (int i = 0; i < m; ++i) {
        ll v,p,q;
        cin>>v>>p>>q;
        if(q==0){
            if(!vs[i].empty()){
                vs[i][0]=v;
                ps[i][0]=p*v;
                continue;
            }
            vs[i].push_back(v);
            ps[i].push_back(p*v);
        }else{
            if(vs[--q].empty()){
                vs[q].push_back(0);
                ps[q].push_back(0);
                vs[q].push_back(v);
                ps[q].push_back(p*v);
                continue;
            }
            vs[q].push_back(v);
            ps[q].push_back(p*v);
        }
    }
    for (int i = 0; i < m; ++i) {
        ll v1,v2=0,v3=0,v4=0,p1,p2=0,p3=0,p4=0;
        if(!vs[i].empty()){
            v1=vs[i][0];
            p1=ps[i][0];
        }else continue;
        if(vs[i].size()>=2){
            v2=v1+vs[i][1];
            p2=p1+ps[i][1];
        }
        if(vs[i].size()==3){
            v3=v1+vs[i][2];
            p3=p1+ps[i][2];
            v4=v2+vs[i][2];
            p4=p2+ps[i][2];
        }
        for (ll j=n;j>=0;j--) {
            if(v1<=j)dp[j]=max(dp[j],dp[j-v1]+p1);
            if(v2<=j)dp[j]=max(dp[j],dp[j-v2]+p2);
            if(v3<=j)dp[j]=max(dp[j],dp[j-v3]+p3);
            if(v4<=j)dp[j]=max(dp[j],dp[j-v4]+p4);
        }
    }
    cout<<dp[n];
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    p1064();
    return 0;
}
```

---

## 作者：Eric1030 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P1064)

## 样例解释

买第 $4$ 和第 $5$ 个商品，花费 $400\times3+500\times2=2200$ 元，它是最大的结果，因此输出 $2200$。

## 思路
因为我们不能单独买配件，所以我们将主件作为 DP 阶段。

如果我们把一个物品的主件命名为 $i$，第一个配件为 $j$，第二个配件为 $k$，那么对于每个主件，我们有以下几种选择：

- 什么也不买。
- 只买主件 $i$。
- 买主件 $i$ 和配件 $j$。
- 买主件 $i$ 和配件 $k$。
- 买主件 $i$ 和配件 $j$、$k$。

把这些确定好后我们再进行一次分组背包来求出最大值然后输出就结束了。

## [AC](https://www.luogu.com.cn/record/205241207) 代码

```cpp
//我们把主件命名为i，第一个配件为j，第二个配件为k
#include <bits/stdc++.h>
using namespace std;
int n, m, k, s, t, f[32005], b[65], p[65], q[65], v[65];
vector< pair<int, int> > a[65];//存放一组中的物品
int main()
{
    cin >> m >> n;
    for (int i = 1;i <= n;i++)
    {
        cin >> v[i] >> p[i] >> q[i];
        p[i] *= v[i];
    }
    for (int i = 1;i <= n;i++)
    {
        if (q[i] == 0)//是主件
        {
            a[i].push_back({ v[i],p[i] });//单独买主件i
        }
        else if (b[q[i]] == 0)//只有一个配件
        {
            a[q[i]].push_back({ v[i] + v[q[i]],p[i] + p[q[i]] });//同时买主件i和配件j
            b[q[i]] = i;//b数组来记录之前是否有配件出现
        }
        else//有两个配件
        {
            int j = b[q[i]];//配件k
            a[q[i]].push_back({ v[i] + v[q[i]],p[i] + p[q[i]] });//同时买主件i和配件k
            a[q[i]].push_back({ v[i] + v[q[i]] + v[j],p[i] + p[q[i]] + p[j] });//同时买主件i和配件j、k
        }
    }
    //分组背包
    for (int i = 1;i <= n;i++)
    {
        if (q[i] == 0)//是主件
        {
            for (int j = m;j >= 0;j--)
            {
                for (auto [v, w] : a[i])//取出动态数组a[i]每个元素
                {
                    if (j >= v)
                    {
                        f[j] = max(f[j], f[j - v] + w);
                    }
                }
            }
        }
    }
    cout << f[m];
    return 0;//结束！
}
```

---

## 作者：lzh301 (赞：1)

## Solution
$n$ 元钱买 $m$ 个物品，每个物品有价值 $v_j \times w_j$，这显然是一个背包题。

发现对于每组主件和附件只有不买，只买主件，买主件和部分附件三种选择。因为在这几种选择中只能选一个，所以考虑分组背包实现。
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
struct bb{
	int v[66],w[66];
	int cn;
}b[66];
int a[66];
int dp[35000];
int cnt;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int v,p,q;
		cin>>v>>p>>q;
		if(q==0){
			if(b[i].cn==0)b[i].cn=1;
			b[i].v[1]=v*p;
			b[i].w[1]=v;
		}else{
			if(b[q].cn==0)b[q].cn++;
			b[q].cn++;
			b[q].v[b[q].cn]=v*p;
			b[q].w[b[q].cn]=v;
		}
	}
	for(int i=1;i<=m;i++){
		if(b[i].cn<=1)continue;
		if(b[i].cn==3){
			b[i].cn++;
			b[i].v[4]=b[i].v[2]+b[i].v[3];
			b[i].w[4]=b[i].w[2]+b[i].w[3];
		}
		for(int j=2;j<=b[i].cn;j++){
			b[i].v[j]+=b[i].v[1];
			b[i].w[j]+=b[i].w[1];
		}
	}
	for(int i=1;i<=m;i++){//分组背包 
		if(b[i].cn==0)continue;
		for(int mm=n;mm>=0;mm--){
			for(int j=1;j<=b[i].cn;j++){
				if(mm>=b[i].w[j]){
					dp[mm]=max(dp[mm],dp[mm-b[i].w[j]]+b[i].v[j]);
				}
			}
		}
	}
	cout<<dp[n];
}
```

---

## 作者：wurang (赞：0)

本题是分组背包的变形，我们要先理解分组背包。

分组背包其实就是在每个组里至多选一样物品，我们的循环第一重枚举每一组，第二重枚举容量，第三重枚举一组中的每一件物品。下面是一份模板代码。

```cpp
for (int k = 1; k <= ts; k++)          // 循环每一组
  for (int i = m; i >= 0; i--)         // 循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      if (i >= w[t[k][j]])             // 背包容量充足
        dp[i] = max(dp[i],dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```

对于这题而言，对于每一件主件来说，之多有五种情况。

- 什么都不买
- 只买主件
- 买主件和第一个附件
- 买主件和第二个附件
- 买主件和两个附件

恰好，在这些情况中之能选择一种。

那么经过处理后即为分组背包了。

```cpp
#include<iostream>  
using namespace std;  
int n,W;
int v,p,q;
int mw[40000],mv[40000],fw[40000][3],sum[40000],fv[40000][3];
int dp[40000];
//mw,mv为主件，fw,fv为附件
//sum用于记录主件有几件附件 
int main()  
{  
    cin>>W>>n;  
    for(int i=1;i<=n;i++)
	{  
		cin>>v>>p>>q;//简单读入 
		if(q)//附件 
		{
			sum[q]++;
			fw[q][sum[q]]=v;
			fv[q][sum[q]]=v*p;   
		}  
		else//主件 
		{  
			mw[i] = v; 
			mv[i] = v*p;
		}  
    }  
    for(int i = 1; i <= n;i++)  
    {
        for(int j = W; j >= 0;j--)
        {
			//枚举所有情况 
            if(j >= mw[i]) dp[j] = max(dp[j], dp[j - mw[i]] + mv[i]);     
            if(j >= mw[i] + fw[i][1])dp[j] = max(dp[j], dp[j-mw[i] - fw[i][1]]+mv[i]+fv[i][1]);
            if(j >= mw[i] + fw[i][2])dp[j] = max(dp[j], dp[j-mw[i] - fw[i][2]]+mv[i]+fv[i][2]);  
            if(j >= mw[i] + fw[i][1] + fw[i][2])dp[j] = max(dp[j], dp[j - mw[i] - fw[i][1]-fw[i][2]]+mv[i]+fv[i][1]+fv[i][2]);  
        }    
    }
    cout<<dp[W]<<endl;  
    return 0;  
}
```

---


# [春季测试 2023] 幂次

## 题目描述

小 Ω 在小学数学课上学到了“幂次”的概念：$\forall a, b \in \N^+$，定义 $a^b$ 为 $b$ 个 $a$ 相乘。

她很好奇有多少正整数可以被表示为上述 $a^b$ 的形式？由于所有正整数 $m \in N^+$ 总是可以被表示为 $m^1$ 的形式，因此她要求上述的表示中，必须有 $b \geq k$，其中 $k$ 是她事先选取好的一个正整数。

因此她想知道在 $1$ 到 $n$ 中，有多少正整数 $x$ 可以被表示为 $x = a^b$ 的形式，其中 $a, b$ 都是正整数，且 $b \geq k$？

## 说明/提示

**【样例 2 解释】**

以下是全部 $7$ 组符合题意的正整数及对应的一种合法的表示方法。

$1 = 1^3, 8 = 2^3, 16 = 2^4, 27 = 3^3, 32 = 2^5, 64 = 4^3, 81 = 3^4$

注意某些正整数可能有多种合法的表示方法，例如 $64$ 还可以表示为 $64 = 2^6$。

但根据题意，同一个数的不同的合法表示方法只会被计入一次。

**【样例 3 解释】**

以下是全部 $12$ 组符合题意的正整数及对应的一种合法的表示方法。

$1 = 1^2, 4 = 2^2, 8 = 2^3, 9 = 3^2, 16 = 4^2, 25 = 5^2, 27 = 3^3, 32 = 2^5, 36 = 6^2, 49 = 7^2, 64 = 8^2, 81 = 9^2$

**【样例 4】**

见选手目录下的 power/power4.in 与 power/power4.ans。

**【样例 5】**

见选手目录下的 power/power5.in 与 power/power5.ans。

**【样例 6】**

见选手目录下的 power/power6.in 与 power/power6.ans。


**【数据范围】**

对于所有数据，保证 $1 \leq n \leq 10^{18}$，$1 \leq k \leq 100$。

|测试点编号|$n \le$|$k$|
|:-:|:-:|:-:|
|1|$10^2$|$=1$|
|2|$10^2$|$\ge 2$|
|3|$10^4$|$\ge 3$|
|4|$10^4$|$\ge 2$|
|5|$10^6$|$\ge 3$|
|6|$10^6$|$\ge 2$|
|7|$10^8$|$\ge 3$|
|8|$10^8$|$\ge 2$|
|9|$10^{10}$|$\ge 3$|
|10|$10^{10}$|$\ge 2$|
|11|$10^{12}$|$\ge 3$|
|12|$10^{12}$|$\ge 2$|
|13|$10^{14}$|$\ge 3$|
|14|$10^{14}$|$\ge 2$|
|15|$10^{16}$|$\ge 3$|
|16|$10^{16}$|$\ge 2$|
|17|$10^{18}$|$\ge 3$|
|18|$10^{18}$|$\ge 2$|
|19|$10^{18}$|$\ge 2$|
|20|$10^{18}$|$\ge 2$|


## 样例 #1

### 输入

```
99 1```

### 输出

```
99```

## 样例 #2

### 输入

```
99 3```

### 输出

```
7```

## 样例 #3

### 输入

```
99 2```

### 输出

```
12```

# 题解

## 作者：zgy_123 (赞：66)

鸣谢@[ivy_uu](https://www.luogu.com.cn/user/20562) ，我的老师。

[机房大佬的题解](https://645010.blog.luogu.org/sol-p9118)

首先，显而易见，当 $k\ge 3$ 时，是可以通过枚举底数的暴力来解决的，附上 $45$ 分代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
map <ll,bool> mp;
ll cnt;
void solve(ll n,ll k){
	for(ll i=2;i*i*i<=n;i++){//枚举底数，只看3次方就够了
		ll t=i*i,m=2;//表示i^m=t
		while(t<=n/i){
			t*=i,m++;
			if(m<k) continue;//次数不够
			if(mp[t]) continue;//已经有了
			mp[t]=1,cnt++;
		}
	}
}
int main(){
	ll n,k;
	cin>>n>>k;
	solve(n,k);
	if(k==1) cout<<n;
	else if(k>=3) cout<<cnt+1;//加1，因为1没有被判断过
	return 0;
}
```
（说句闲话，如果这样提交会获得[link](https://www.luogu.com.cn/record/104359435)）

接下来处理平方的判断。

我们知道，$n$ 以内的完全平方数一共有 $\sqrt n$ 个，但是其中有些数字已经被标记过了。

如果一个一个去判断，显然不可行。这时候，我们可以在标记时判断是否为完全平方数。

接下来附上最短 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
map <ll,bool> mp;
ll x,cnt;
void solve(ll n,ll k){
	for(ll i=2;i*i*i<=n;i++){
		ll t=i*i,m=2;
		while(t<=n/i){
			t*=i,m++;
			if(m<k) continue;
			if(mp[t]) continue;
			if((ll)sqrtl(t)*sqrtl(t)==t) x++;//是完全平方数
			mp[t]=1,cnt++;
		}
	}
}
int main(){
	ll n,k;
	cin>>n>>k;
	solve(n,k);
	if(k==1) cout<<n;
	else if(k>=3) cout<<cnt+1;
	else cout<<(ll)sqrtl(n)+cnt-x;//不用加一，因为在sqrtl里算上了
	return 0;
}
```
[加一些压行后21行](https://www.luogu.com.cn/paste/q4labl9n)

良心提供 $2$ 组 hack 数据：
```
imput:576460752303423488 2
output:760085356

imput:99 100
output:1
```

再说句闲话，数据里好像只有 $1\le k \le 3$ 的数据点。

- 2023.3.11 过审
- 2023.3.12 添加压行部分，修改语病
- 2023.3.22 添加 hack 数据

---

## 作者：Kreado (赞：64)

[题目传送门](https://www.luogu.com.cn/problem/P9118)。

Update 2023/10/16 修改了代码和一些笔误。

#### 思路

我们令 $f(i)$ 表示 $x=a^i(x\le N,x_p\not=x_q)$ 的个数。

令 $g(i)$ 表示 $x=a^i(x\le N)$ 的个数。

很容易得到 $g(i)=f(i)+f(2i)+\cdots+f(li),(li\le 100)$。

易知 $g(i)=\sqrt[i]n$。

所以 $f(i)=g(i)-f(2i)-f(3i)-\cdots-f(li)$。

从后往前容斥即可。

当 $a=1$ 时，$a^i$ 恒等于 $1$，我们要在容斥过程中减去这部分，统计答案的时候加上 $1$ 的贡献即可。

#### Code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=110;
const double eps=1e-9;
ll f[Maxn],n,k,ans=1;
int main(){
	scanf("%lld%lld",&n,&k);
	for(ll i=100;i>=k;i--){
		f[i]=pow<long double>(n,1.0/i)+eps-1;
		for(ll j=i<<1;j<=100;j+=i) f[i]-=f[j];
		ans+=f[i];
	}
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：jijidawang (赞：24)

首先特判 $k=1$，令 $f(n)$ 表示 $[1,n]$ 能表示为 $x=a^b$ 形式的整数 $x$ 个数，其中 $a\ge 1,b\ge 2$，那么答案可以简单表述为
$$f(n)-\sum_{i=2}^{k-1}f(\lfloor\sqrt[i]{n}\rfloor)$$
于是只需要快速计算 $f$，也就是 $k=2$ 的情况 .

考虑对指数容斥，首先如果一个指数不是 square-free 的，那么可以直接忽略它产生的贡献，那么只需要考虑 square-free number 作为指数的情况 .

有 $a^{pq}=(a^p)^q=(a^q)^p$，于是如果指数 $e$ 有 $k$ 个不同的素因子，那么其容斥系数就是 $(-1)^{k+1}$ .

综合上述内容，即可得出容斥系数即为 $-\mu(e)$，则可以写出 $f$ 的表达式：
$$f(n)=1-\sum_{i\ge 2}\mu(i)(\lfloor\sqrt[i]{n}\rfloor-1)$$

直接计算即是 $\Theta(k\log n)$，可以轻松通过，需要注意精度问题 .

---

## 作者：苏联小渣 (赞：23)

这个题一看就很普及。我们分情况考虑：

## $k=1$

显然直接输出 $n$ 即可。

## $k\ge 3$

发现 $\sqrt[k]{n} \le 10^6$，那么我们可以枚举底数。对于每个底数 $a$，看一下 $a^k$ 是否 $\le n$。如果不是，那么就可以直接停止枚举。如果是，那么我们暴力乘找到最小的 $k'$ 满足 $a^{k'}>n$。那么，$\sum k'-k$ 就是答案？

错了。注意到不同底数的不同次幂可能相同，所以需要判重。这里我使用了 map 判重。令 $c=\sqrt[k]{n}$，时间复杂度 $O(c \log^2 n)$。事实上远远跑不满。

看起来很暴力，但可以通过，并且并不需要用容斥什么的动脑子。

## $k=2$

为什么要单独讲 $k=2$？因为 $\sqrt[2]{n} \le 10^9$，用上面的方法妥妥的超时。

思考我们枚举的本质是什么？统计答案？不是，如果只是统计答案的话，那么二分或者其他方法肯定更快。那为什么要一个个枚举？是因为要**判重**。那么，如果我们对完全平方数能找到一个更好的性质用于判重，就可以避免对于指数为 $2$ 的数的枚举了。

这个时候就要思考完全平方数的性质了，最常用的一点就是，分解质因数后所有指数都是偶数。那么，我们先把 $n$ 以内的完全平方数个数计入答案（$\sqrt{n}$ 个），然后，从 $2$ 到 $\sqrt[3]{n}$ 枚举 $a$。如果 $a$ 为完全平方数，那么直接跳过（因为这样的话，$a$ 的任意次幂肯定是完全平方数），否则，看 $a^k$ 是否 $\le n$。如果不是，停止枚举；如果是，暴力乘找到最小的 $k'$ 满足 $k' \ge n$。对于每个 $k \le j \le k'$，如果 $a^j$ 已经出现过，或者 $j \bmod 2=0$，那么不计入答案；否则计入答案。时间复杂度 $O(c \log^2 n)$。

好想好写，适合做一道普及组的题。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, k, ans=1, pf[1000010];
map <int, int> mp;
int sqrt(int x){
	int l = 0, r = 1e9;
	while (l <= r){
		int mid = l + r >> 1;
		if (mid * mid <= x) l = mid + 1;
		else r = mid - 1; 
	}
	return l - 1;
}
signed main(){
	scanf ("%lld%lld", &n, &k);
	if (k == 1) return printf ("%lld\n", n), 0;
	if (k == 2){
		ans = sqrt(n);
		for (int i=1; i<=1000; i++) pf[i*i] = 1;
		if (k == 2) k = 3;
		for (int i=2; i; i++){
			if (mp.find(i) != mp.end() || pf[i]) continue;
			int now = 1, flag = 0;
			for (int j=1; j<=k; j++){
				if (now > n / i){
					flag = 1;
					break;
				}
				now *= i;
			}
			if (flag) break;
			for (int j=k; j; j++){
				if (mp.find(now) == mp.end() && j % 2 == 1) ans ++;
				mp[now] = 1;
				if (now > n / i) break;
				now *= i;
			}
		}
	}
	if (k >= 3){
		for (int i=2; i; i++){
			if (mp.find(i) != mp.end()) continue;
			int now = 1, flag = 0;
			for (int j=1; j<=k; j++){
				if (now > n / i){
					flag = 1;
					break;
				}
				now *= i;
			}
			if (flag) break;
			for (;;){
				if (mp.find(now) == mp.end()) ans ++;
				mp[now] = 1;
				if (now > n / i) break;
				now *= i;
			}
		}
	}
	printf ("%lld\n", ans);
	return 0;
}
```

---

## 作者：tongziyu (赞：17)

## Description

给定 $n$，$k$，求 $[1,n]$ 范围内能被表示为形如 $a^b$ 的数的个数，其中 $a \ge 1$，$b \ge k$。

------------

## Solution

考虑一个比较简单的暴力，枚举 $[1,n]$ 中的每个数作为 $a$，然后枚举 $b$，直到 $a^b \ge n$ 就让 ```a++``` 然后重新枚举 $b$，每个没出现过的数使 ```ans++```。

先不考虑去重，我们来思考如何优化这个暴力。注意到当我们枚举的 $b$ 增加时，使 $a^b$ 首次 $\ge n$ 的 $a$ 会越来越小，由此我们可以对每个 $b$ 二分求出一个 $a$ 的上界，此时 $a$ 的上界是 $n$ 次根号级别的。

因为 $2^{60} \ge 10^{18}$ ，所以 $b$ 实际的范围并不大。对于 $k \ge 3$ 的情况我们都可以枚举 $b$ 求出 $a$ 的上界然后直接暴力求所有快速幂做了。剩下的情况中，$k = 1$ 时答案显然为 $n$，那么 $k = 2$ 时如何做？

此时回来考虑去重，因为笔者太菜了赛时没想到容斥怎么做，所以求完快速幂后再枚举每个 $\le b$ 的 $x$ 作为新的指数。然后对当前求得的 $a^b$ 开 $x$ 次方根，看是否有正整数解，就可以判定是否与之前计算过的重复了。

此时 $k = 2$ 的情况就迎刃而解了，我们直接令初始 ```ans``` 为 $\sqrt{n}$ 即可。

还要注意 $a$ 为 $1$ 的情况，在初始答案上略作修改就行。 

时间复杂度比较抽象，我不会表示，算了算可过。

------------

## Code
```cpp
#include <bits/stdc++.h>
#define e118 1000000000000000000ll
//#define __int128 long long
using namespace std;
inline long long read()
{
	long long r = 0, c = getchar(), f = 1;
	while (c < '0' || c > '9')
	{
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') r = (r << 1) + (r << 3) + (c ^ 48), c = getchar();
	return r * f;
}
long long qpow(__int128 a, int b)
{
	__int128 res = 1;
	while (b)
	{
		if (a > e118) return e118 + 1;
		if (b & 1) res = res * a;
		a = a * a;
		b >>= 1;
	}
	return res > e118 ? e118 + 1 : res;
}
long long get_sqrt(long long n, int x)
{
	long long l = 1, r = n, ans;
	while (l <= r) 
	{
		long long mid = l + r >> 1;
		if (qpow(mid, x) <= n) l = mid + 1, ans = mid;
		else r = mid - 1;
	}
	return ans;
}
int main()
{
//	freopen("power.in", "r", stdin);
//	freopen("power.out", "w", stdout);
	long long n = read(), ans = 1;
	int k = read();
	if (k == 1) printf("%lld\n", n), exit(0);
	if (k == 2) ans += (long long)get_sqrt(n, 2) - 1;
	for (int i = max(k, 3); i <= 60; ++i)
	{
		int lim = get_sqrt(n, i);
		for (int j = 2; j <= lim; ++j)
		{
			long long now = qpow(j, i);
			bool flag = 1;
			for (int l = max(k, 2); l < i; ++l) 
			{
				 long long rt = get_sqrt(now, l);
				 if (qpow(rt, l) == now) flag = 0;
			}
			ans += flag;
		}
	}
	printf("%lld\n", ans);
	return 0;
}

```

---

## 作者：lalaouye (赞：12)

这是一个从暴力到正解的过程。

## 暴力

从 $1$ 枚举到 $\sqrt n$，枚举每一个 $x$，进行累乘，顺便用一个map数组判重，时间复杂度$\mathcal{O}(\sqrt n\log n\log n)$，直接T飞。


## 改善1

此时我们抛开复杂度的 $\log n\log n$ 不谈，发现当枚举的 $i$ 大于 $n^{\frac{1}{3}}$ 小于等于 $\sqrt n$ 时，只能够算它的二次方，没有必要枚举。

故如果 $k=2$，我们在枚举时，如果当前指数为 $b$，则当 $b$ 为双数时（因为就是 $(a^{\frac{b}{2}})^2$，同样也是某数的方），故意不加答案，等最后令答案加上 $\sqrt n$ 就行，这样复杂度降至 $\mathcal{O}(n^{\frac{1}{3}}\log n\log n)$。


##  改善2

试着不用map数组判重，可以发现，重复时会有 $a^b=c^d$ ，而这种情况会有 $x^e=a,x^f=c$。这样，$a^b=c^d=x^n$，在枚举 $x$ 时这加上就行。所以在枚举的时候，将自己筛到的打上标记。当 $a^b\leq10^6$ 时，$vis[a^b]=1$。

如果 $x$ 为非整数呢？则 $a$ 和 $c$ 也是非整数（指数得是整数），所以不必担心。

这样在枚举底数时，如果自己已经被 $vis$ 标记，直接下一个，既不会有重复，又优化了复杂度。复杂度 $\mathcal{O}(n^{\frac{1}{3}}\log n)$，可过此题。


##  上代码

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
bool vis[2000000];

int ll=0; 
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void print(__int128 x){
    if(x<0){putchar('-');x=-x;}
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
signed main(){
//	freopen("power.in","r",stdin);
//	freopen("power.out","w",stdout);
	long long n,k;
	cin>>n>>k;
	if(k==1){
		print(n);return 0;
	}
	if(k>log2(n)){
		cout<<1;return 0;
	}
	int ans=1;
	int b=0;
	for(int a=2;a<=1000000;a++){
		int res=a;b=1;
		if(vis[res])continue;
		while(1){
			b++;
			res=res*a;
			if(b>=k&&res<=n){
				if(k==2&&res<=n&&b%2==0){//只有k=2时才不加 
					if(res<=1000000)vis[res]=1;//标记 
					continue;//不加答案 
				}
				ans++;
			}
			if(res<=1000000)vis[res]=1;//注意不管符不符合答案就会标记上 
			if(res>=n)break;
		}
	}
	if(k==2)ans+=(int)sqrtl(n)-1;//因为ans初值为1，表示1也符合答案，所以在这里sqrtl(n)也包含了1，需减去 
	print(ans);
	return 0;
}
```


---

## 作者：BeyonDimension (赞：9)

题目大意：求1~n范围内能够表示成形如$a^b$的数字个数

类似于$NOI2010$能量采集的容斥原理：
\
\
首先数字1可以写成1的任意次方，暂不处理；先考虑对于固定$b$时$2～n$的范围内可以表示成形如$a^b$的数字:$2^b, 3^b, ... x^b$
\
\
显然有$x^b \leq n$ 且 $(x+1)^b > n$,于是$x = \lfloor n^{\frac{1}{b}} \rfloor$
\
\
对于每一个确定的b，则可以求出2～n范围内能够表示成$a^b$的数字个数为$f(b) = \lfloor n^{\frac{1}{b}} \rfloor - 1$
\
\
接下来考虑重复计算的部分,容易想到$a^{i\cdot j}$可以写成$(a^j)^i$，即在$f(i)$统计的所有方案中包含了$f(i\cdot j)$中的方案，即为重复计算的方案数，于是从大到小枚举每一个$i$，将$f(i)$中重复计算的$f(i\cdot j)$的方案数去掉，此时的$f(i)$中剩余的方案数即为能且仅能表示为$a^i$的数字个数，最后答案$ans = 1 + \sum_k^{60} f(i)$


```cpp
#include <iostream>
#include <math.h>
#include <algorithm>
using namespace std;
#define LL long long
LL n, k, ans, f[70];

int main(){
    cin >> n >> k;
    f[1] = n-1;

    //f[i] = n^(1/i) - 1
    for (LL i = 2; i < 64; i ++){
        //求2～n之间有多少个数字可以写成a^i
        //二分求i次根号下的n  
        //即求x x^i <= n 且 (x+1)^i > n
        LL low = 1, high = n;
        while (low < high - 1){
            LL mid = (low + high) / 2;
            bool flag = true;
            __int128 num = 1;
            for (int j = 1; j <= i; j ++){
                num *= mid;
                if (num > n){
                    flag = false;
                    break;
                }
            }
            if (flag)
                low = mid;
            else    
                high = mid;
        }
        //low = n^(1/i) = x
        f[i] = low - 1;
    }

    
    
    for (int i = 63; i > 0; i --)
        for (int j = 2; j * i < 64; j ++)
            //f[i*j]   a^(ij) = (a^j)^i
            f[i] -= f[i*j];
            //f[i]中只保留能且仅能写作a^i的数字的个数  
    
    for (int i = k; i < 64; i ++)
        ans += f[i];

    cout << ans+1;
    return 0;
}
```



---

## 作者：船酱魔王 (赞：9)

# P9118 [春季测试 2023] 幂次 题解

## 题意回顾

求在 $ 1 \sim n $ 中，有多少正整数 $ x $ 可以表示为一个正整数的幂次方的形式且次数大于等于 $ k $。

$ 1 \le n \le 10^{18}, 1 \le k \le 100 $。

## 部分分

### case1（5pts）

我们发现，每个数 $ m $ 可以表示为 $ m^1 $，因为 $ k = 1 $，满足次数大于等于 $ k $ 的要求，所以输出 $ n $ 即可。

### case2~6 (25pts)

根号枚举因数，判断是否为 $ k $ 次及以上即可。

### case7~8（10pts）

改造埃式筛法，把每次内层循环加 $ i $ 改为乘 $ i $，求出每个数的最大幂次数，再判断是否大于等于 $ k $ 即可。

### case9~17（45pts）

我们对于 $ 2 \sim 61 $ 的每个次数都考虑对应范围内的底数（例如 $ 2 $ 次是 $ 1 \sim 10^8 $ ，$ 3 $ 次是 $ 1 \sim 10^6 $。其实我们不用算出所有次数对应的底数范围，我们只用在发现已经超过 $ 10^{18} $ 时 ```break``` 掉即可。注意判断两个数乘积是否大于 $ 10^{18} $ 时，为防止爆 ```long long``` 可以用 $ 10^{18} $ 除以一个数再比较和另一个数的大小关系。）再将底数的次数次幂存入 ```set```。最后判断是否小于等于 $ n $ 再统计入答案即可。

注意这个部分分段分了很多小档，写得不太好可能会挂一些点，因为本人在考场上是直接打正解的所以不太确定 case16 用这种方法能不能过。

## 正解

在 case9~17 的基础上，我们发现 $ 4 $ 次幂的底数已经小于 $ 10^5 $ 了，并且 $ 5 $ 次幂底数小于 $ 10^4 $ ，我们认为，当 $ k \ge 4 $ 时，枚举的量级是不超过 $ 2 \times 10^5 $ 的。

所以，对于 $ 4 $ 次幂及以上，我们枚举即可。对于 $ 2,3 $ 次幂，我们可以算出符合要求的个数，但要注意减去重复算的 $ 6 $ 次幂个数，在最终的答案里在减去已经是 $ 2 $ 或 $ 3 $ 次幂的个数。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <set>
using namespace std;
const long long inf = 1e18 + 5;
long long n;
int k;
bool check(long long a, int b) {
    long double tmp = (long double)inf / b;
    return a < tmp;
}
long long getpow(int a, int p) {
    long long res = 1;
    for(int i = 1; i <= p; i++) {
        res *= a;
    }
    return res;
}
int sqrtx(long long a, int x) {
    int l, r, mid;
    //11111111[1]0000
    //[l,r)
    l = 1;
    if(x == 2) {
        r = 1e9 + 1;
    } else if(x == 3) {
        r = 1e6 + 1;
    } else if(x == 6) {
        r = 1e3 + 1;
    }
    while(l + 1 < r) {
        mid = (l + r) >> 1;
        if(getpow(mid, x) <= a) {
            l = mid;
        } else {
            r = mid;
        }
    }
    return l;
}
bool checksqrt(long long a, int x) {
    int res = sqrtx(a, x);
    if(getpow(res, x) == a) {
        return true;
    }
    return false;
}
set<long long> se;
int main() {
    //freopen("power.in", "r", stdin);
    //freopen("power.out", "w", stdout);
    cin >> n >> k;
    if(k == 1) {
        cout << n << endl;
        return 0;
    }
    int ans = 1;
    if(k == 2) {
        ans = sqrtx(n, 2) + sqrtx(n, 3) - sqrtx(n, 6);
    } else if(k == 3) {
        ans = sqrtx(n, 3);
    } else {
        ans = 1;
    }
    long long tmp = 1;
    for(int pi = max(k, 4); pi <= 61; pi++) {
        for(int i = 2; i <= 1e5; i++) {
            tmp = 1;
            for(int j = 1; j <= pi; j++) {
                if(!check(tmp, i)) {
                    tmp = -1;
                    break;
                }
                tmp *= i;
            }
            if(tmp != -1) {
                se.insert(tmp);
            }
        }
    }
    for(set<long long>::iterator it = se.begin(); it != se.end(); it++) {
        tmp = *it;
        if(tmp > n) {
            continue;
        }
        if(k == 2) {
            if(checksqrt(tmp, 2) || checksqrt(tmp, 3)) {
                continue;
            }
        } else if(k == 3) {
            if(checksqrt(tmp, 3)) {
                continue;
            }
        }
        ans++;
    }
    cout << ans << endl;
    return 0;
}
/*
a*b<c
a<c/b
*/
```

## 总结与评价

本题难度建议：绿题。

放在提高 T2 略显简单，又因为非常简单的 T1 和 T3 的超丰富部分分导致这场比赛大众分很高。

---

## 作者：xhabc66 (赞：7)

# 思路
有一个显然的暴力做法：对于每个 $a$，标记所有可能的 $a^b$。期望得分 $30$。

考虑“反其道而行之”，求出 $b<k$ 的 $a^b$ 的个数。

对于这个思路，只需求出**只能用** $a^1$ 表示的数、**只能用** $a^2$ 表示的数......**只能用** $a^k$ 表示的数即可。

求出**能用** $a^b$ 表示的数并不难，只需写一个二分函数或者调用 `pow` 函数即可。

关键是要把 $a^{2b}$、$a^{3b}\dots$ 的除去。

除了写个容斥外，还有一个更简单的方法：先把**只能用** $a^{2b},a^{3b}\dots$ 表示的数先给求出来即可。

那么最大要求的 $b$ 是多少呢？由于 $2^{70}>10^{18}$，所以随便找一个 $\ge70$ 的数即可。
# AC code
```
#include<bits/stdc++.h>
using namespace std;

long long mi[210];

int check(long long a,long long b,long long p)
{
	long long ans=1;
	for(int i=0;i<b;i++)
	{
		if(p/ans<a)return 1;
		ans*=a;
	}
	if(ans==p)return 0;
	else return -1;
}

long long kf(long long n,long long k)
{
	long long l=1,r=n;
	while(l+1<r)
	{
		long long mid=(l+r+1)/2;
		if(check(mid,k,n)<0)l=mid;
		else r=mid;
	}
	if(check(r,k,n)==0)return r;
	return l;
}

int main()
{
	long long n,k;
	cin>>n>>k;
	for(int i=200;i>0;i--)
	{
		long long tp=kf(n,i)-1;//自写开方函数
		
		for(int j=i;j<=200;j+=i)tp-=mi[j];
		mi[i]=tp;
	}
	long long ans=n-1;
	for(int i=1;i<k;i++)ans-=mi[i];
	cout<<ans+1;
	return 0;
}
```

---

## 作者：MarchKid_Joe (赞：4)

# [P9118](https://www.luogu.com.cn/problem/P9118)

## 题意

统计满足以下所有条件的 $a^b$ 的个数：

- $a^b\leqslant{n}$
- $a,b\in{N^*}$
- ${b}\geqslant{k}$

## 思路

不考虑题目中 $k$ 的限制，仅看 $a^b$。

对于 $b=1$ 的：有 $n$ 个。

对于 $b=2$ 的：发现有 $\sqrt{n}$ 个。

对于 $b\gt2$ 的：

$$
\sum_{i=3}^{100}\lfloor\sqrt[i]{10^{18}}\rfloor=1037650
$$

发现卡到极限的数据规模才约为 $10^6$，随便用一个 $\operatorname{STL}$ 去重即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, k, ans;
unordered_map<ll, bool> v;
ll ksm(ll x, ll y)
{
    ll res;
    for (res = 1; y > 0; y--)
        if ((res *= x) > n)
            return n + 1;
    return res;
}
signed main()
{
    cin >> n >> k;
    if (ksm(2, k) > n) {cout << 1; return 0;}
    if (k == 1) {cout << n; return 0;}
    if (k == 2) {ans += sqrtl(n);}
    for (ll i = max(k, 3ll); i < 60; i++)
        for (ll j = 1, g; (g = ksm(j, i)) <= n; j++)
            if (k != 2 || (ll)sqrtl(g) * (ll)sqrtl(g) != g)
                v[g];
    cout << v.size() + ans;
    return 0;
}
```

## 后言

写此篇嘲讽笔者自己，仅此而已，嘲讽在春联场上脑子热了自创神奇筛质数做法挂掉了 $90$ 分，也希望各位在赛场上别创新，能保守就保守。

挂着这张图自嘲：

![](https://cdn.luogu.com.cn/upload/image_hosting/j02ldy9y.png)

---

## 作者：MoyunAllgorithm (赞：3)

**题意**

给你 $N$ 和 $K$。求有多少 $x \in [1,N]$ 满足 $x=a^b(b \le K)$。
$N \le 10^{18}$。

**分析**

对于 $K \ge 3$，暴力求解。

**为什么呢？** 因为当 $K \ge 3$，那么满足条件的 $\text{max} (x) \le \sqrt[K]{N}$。当 $K=3,N=10^{18}$，右式为 $10^6$，完全能够进行暴力。具体而言，遍历 $a \in [1,\sqrt[3]{N}]$ （有时 $K>3$，但直接取立方根更为方便）。对于每个 $a$，枚举 $b \in [1,\log_{K} N]$，累计结果即可。可以用 `unordered_map` 较为快速的判断是否重复。经过简单的剪枝，时间复杂度为 $O(\sqrt[K]{N} \log N) $，可以通过。如果 $K=2$ 时也套用此算法，可以得到 $75$ 的分数。

**对于 $K=2$，要怎么办？**

你会发现，求出 $[1,N]$ 中的平方数数量等于 $\lfloor \sqrt{N} \rfloor $。这点可以 $O(1)$ 解决。现在你的问题在于如何解决重复统计问题。

容易想到~~其实我考试时并没有想到~~，使用 $K \ge 3$ 的暴力算法，但是**只有暴力算法发现的 $x$ 不是完全平方数时**才纳入统计，就可以解决重复统计问题。时间复杂度为 $O( \sqrt[3]{N})$。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
unordered_map<LL,bool>mp;
LL cnt=0;//K>=3时的计数
int K;
LL N;
LL tot=0;//K==2时，统计非完全平方数
int main()
{
    scanf("%lld %d",&N,&K);
    if(K==1)
    {
        printf("%lld\n",N);
        return 0;
    }
    cnt++;//1=1^b,先行统计
    for(LL i=2;i*i*i<=N;i++)//暴力算法
    {
        int j=1;//b
        __int128 cur=(__int128)i;//目前的a^b
        //if(i%100000==0) printf("%lld\n",i);
        while(1)//当目前的 a^b<=N时
        {
            cur*=i;
            j++;
            //printf("%d\n",j);
            if(cur>(__int128)N)//超了停
            {
                if(j<=K) i=N;//剪枝：如果a^K>N，后面的a都不可能对答案产生贡献，适用于K>=4的情况
                break;
            }
            if(j>=K)
            {
                if(mp[(LL)cur]==0) cnt++;//如果没被统计过
             //   printf("%lld %lld\n",(LL)cur,(LL)sqrtl((LL)cur));
                if(mp[(LL)cur]==0&&(LL)sqrtl((LL)cur)*(LL)sqrtl((LL)cur)!=(LL)cur) tot++;//非完全平方数。注意sqrtl解决精度问题
                mp[(LL)cur]=1;//标记
            }
        }
    }
    if(K==3) 
    {
        printf("%lld\n",cnt);
        return 0;
    }
    //printf("%lld\n",tot);
    printf("%lld\n",(LL)sqrtl(N)+tot);
    return 0;
}
```




---

## 作者：CQ_Bab (赞：3)

# 思路
容斥原理，我们发现对于 $b=i$ 时满足的数在 $b=i\times 2,i\times 3,i\times 4$ 时都会出现所以我们就可以利用这种性质来打，那么我们应如何定义呢?只需要定义 $f_i$ 为 $k=i$ 时的总方案数，那对于每一个 $f_i$ 初始化就为 $\sqrt[i]n$ 只不过要注意 $i$ 要倒着枚举因为我们的倍数是一定比 $i$ 大的所以为了正确性我们就需要倒着枚举 $i$，并枚举它的倍数并将 $f_i$ 减去 $f_j$。最后我们可以发现答案就是从 $k$ 枚举到 $63$（因为 $10^{18}$ 最多为 $2^{63}$） 并将 $f_i$ 相加。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define rep(i,x,y,k) for(int i=x;i<=y;i+=k)
#define rep1(i,x,y,k) for(int i=x;i>=y;i-=k)
#define fire signed
#define int long long
int n;
int k;
fire main() {
	cin>>n>>k;
	if(k==1) {
		cout<<n<<endl;
		return false;
	} else {
		int f[100]={0} ;
		for(int i=1; i<=100; i++) f[i]=pow((long double)n,(long double)1/i)-1; //初始化并减去a=0时的 
		rep1(i,100,1,1) {
			rep(j,i*2,63,i) {
				f[i]-=f[j]; //按照公式 
			}
		}
		int res=1; //a^0=1
		rep(i,k,63,1) res+=f[i]; //相加 
		cout<<res<<endl;
	}
	return false;
}

```


---

## 作者：GeorgeAAAADHD (赞：3)

## P9118 [春季测试 2023] 幂次 题解

------------
本题作者采用分类讨论法。

题目大意：给定两个数 $n$ 和 $k$，求 $1$ 至 $n$ 内所有能表示成 $a^b$ 形式的数字的总数，其中 $b \ge k$。

------------
1. $k = 1$ 的情况。

此时只需输出 $n$ 即可，因为每个数都能表示成该数的一次方。

------------
2. $k > 59$ 的情况。

~~（这种情况作者只是想骗分结果一分没骗到）~~

此时输出 $1$ 即可，因为取最小满足条件的 $k = 60$ 时， $2 ^ {60} = 1152921504606846976 > 10 ^ {18}$，因此只有 $1$ 符合条件。

------------
3. $3 \le k \le 59$ 的情况。

该情况下，最坏情况时 $n = 10 ^ {18},k = 3$，此时取 $b = 3$ 时 $\sqrt[3]{10 ^ {18}}$ 的结果 $ = 10 ^ 6$，当 $b > 3$ 时的结果作为零头可以忽略不计。

因此该种情况可以使用暴力枚举+去重的方式通过。

------------
4. $k = 2$ 的情况。

考虑枚举优化。因为最坏情况下 $n = 10^{18}$ 时，结果至少为 $\sqrt{10^{18}} = 10^9$，超过了暴力枚举的最大枚举量。

实际上，我们可以先枚举出所有 $a^{2b-1}$ (即 $b$ 为奇数)时的所有情况，因为$a^{2b}$ (即 $b$ 为偶数)的所有情况都可以表示成 $a^{b^2}$ 的形式，可以放在最后 $b = 2$ 的情况一起讨论。

其次，在枚举所有可表示成 $a^{2b-1}$ 的所有数中剔除掉所有完全平方数，因为这些数也可以放在 $b = 2$ 时讨论。

最后对整个数组用 `unique` 函数去重，加上 $\lfloor \sqrt{n} \rfloor$ 就是这道题的答案。

于是我们就愉快地 AC 了本题。

------------
总结：

1. 本题需要自写快速幂和二分开根的函数；

2. 使用 `unique` 函数之前需先对数组进行升序排序;

3. 二分开根的右端点应取 $\min(a, \sqrt{10^{18}}=10^9)$，不然以作者的程序会超时 0.02 秒左右。~~（作者太蒟了)~~

4. 枚举 $k=2$ 时指数上限应为 $\log_2 n$，可以减少运算量。

------------
结语：

用枚举法固然可以通过本题，但是有没有更优的解法呢？留给大家思考。

------------
Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[1500000]={0},x=1;
long long poww(long long a,long long b){//快速幂函数
	long long c=a,sum=1;
	while(b){
		if(b%2)sum*=c;
		b>>=1;
		c*=c;
	}
	return sum;
}
long long rt(long long a,long long b){//开方函数，二分
	long long l=1,r=min(a,1000000000LL);//注意min函数两边数据类型要一致
	while(l+1<r){
		long long mid=(l+r)/2;
		double m=pow(mid,b);
		if(m>1e18)r=mid;//先用double做一遍，如果大了直接改右端点
		else{
			long long num=poww(mid,b);//否则用自制乘方函数再算一遍
			if(num==a)return mid;
			else if(num<a)l=mid;
			else r=mid;
		}
	}
	return l;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);//输入输出优化，实际上没什么用
	cin>>n>>k;
	if(k==1)cout<<n;
	else if(k>59)cout<<1;
	else if(k>=3&&k<=59){
		long long s=log(n)/log(2);//求以2为底的log n，在cmath库里
		for(int i=k;i<=s;i++){
			long long ss=rt(n,i);
			for(int j=1;j<=ss;j++){
				a[x++]=poww(j,i);
			}
		}
		sort(a+1,a+x);//升序排序
		long long su=unique(a+1,a+x)-a-1;//求数组不重复的值的个数
		cout<<su;
	}
	else if(k==2){
		long long s=log(n)/log(2);
		for(int i=3;i<=s;i+=2){//只枚举b为奇数时的情况
			long long ss=rt(n,i);//求出当前b值的枚举量
			for(int j=2;j<=ss;j++){
				long long aaa=poww(j,i);
				long long nu=rt(poww(j,i),2);
				if(poww(nu,2)!=aaa)a[x++]=poww(j,i);//判断是否为完全平方数
			}
		}
		sort(a+1,a+x);
		long long su=unique(a+1,a+x)-a-1;
		cout<<su+rt(n,2);//加上 b = 2 的个数
	}
	return 0;
}
```

最后一个点 600 多毫秒。

---

## 作者：封禁用户 (赞：3)

### 题目传送门

[P9118](https://www.luogu.com.cn/problem/P9118)

### 分析

首先，对于 $k \ge 3$ 的数据点，由于 $n \le 10^{18}$ 而 $\sqrt[3]{10^{18}} = 10^6$，满足条件的数字大约只有 $10^6$ 个，事实上，如果我们看一下大样例，实际上当 $n = 10^{18}$ 同时 $k = 3$ 时，只有 $1036002$ 个符合条件的数。

所以，我们只需要从 $2$ 枚举到 $\sqrt[k]{n}$，枚举该数字的若干次幂，丢进一个 set 中去重，知道大于 $n$ 时结束，注意最后还要加上 $1$ 的情况。

时间复杂度 $O(N \log{N})$，其中 $N$ 是符合条件数字的个数。

比较复杂的是当 $k = 2$ 的情况。

我们分析，当 $l = p^6$ 时，$l = ({p^2})^3 = ({p^3})^2$，利用这个性质，我们进行容斥原理。

仍然把 $1$ 单独计算，根据容斥原理的表达式：

![](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jcHBibG9nLmNvbS9pbWFnZXMvY3BwYmxvZ19jb20vdmljaS8wMDAucG5n?x-oss-process=image/format,png)

我们对于答案加上质数（如 $2$）次幂的答案，减去两不同质数乘积（如 $3$）的答案，再加上三个不同质数乘积的答案（如 $30$）。而 $n \le 10^{18} < 2^{60} = 1152921504606846976$，所以最高取到 $59$ 次幂即可。

我们定义 $\mathrm{calc}(x)$ 为满足 $k^x \le n$ 且 $k \ge 2$ 的正整数 $k$ 的个数，答案可以写成：

$\mathrm{calc}(2)+\mathrm{calc}(3)+\mathrm{calc}(5)+\mathrm{calc}(7)+\mathrm{calc}(11)+\mathrm{calc}(13)+\mathrm{calc}(17)+\mathrm{calc}(19)+\mathrm{calc}(23)+\mathrm{calc}(29)+\mathrm{calc}(31)+\mathrm{calc}(37)+\mathrm{calc}(41)+\mathrm{calc}(43)+\mathrm{calc}(47)+\mathrm{calc}(53)+\mathrm{calc}(59)$

$-\mathrm{calc}(6)-\mathrm{calc}(10)-\mathrm{calc}(14)-\mathrm{calc}(15)-\mathrm{calc}(21)-\mathrm{calc}(22)-\mathrm{calc}(26)-\mathrm{calc}(33)-\mathrm{calc}(34)-\mathrm{calc}(35)-\mathrm{calc}(38)-\mathrm{calc}(39)-\mathrm{calc}(46)-\mathrm{calc}(51)-\mathrm{calc}(55)-\mathrm{calc}(57)-\mathrm{calc}(58)$
    
$+\mathrm{calc}(30)+\mathrm{calc}(42)+1$

最后加一是由于考虑 $1$ 的情况。

注意 $\mathrm{calc}(x)$ 直接使用 pow 函数计算 $\sqrt[x]{n}$ 容易爆精度，这里本人使用 $1$ 的偏移量进行类似二分的求法。

时间复杂度可以看成 $O(1)$ 的。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(register T &x)
{
	register T p = 1,num = 0;
	char c = getchar();
	while(c < '0'||c > '9')
	{
		if(c == '-') p = -p;
		c = getchar();
	}
	while('0' <= c&&c <= '9')
	{
		num = (num<<3)+(num<<1)+(c^48);
		c = getchar();
	}
	x = p * num;
}
template<typename T>inline void write(register T x)
{
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x/10);
	putchar(x%10+48);
}
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define ll long long
#define pii pair<int,int>
__int128 n;
int k;
inline __int128 Pow(__int128 x,int y)
{
	__int128 ret = 1;
	while(y)
	{
		if(y & 1) ret = ret * x;
		x = x * x;
		y >>= 1;
	}
	return ret;
}
inline int calc(int x)
{
	int t = pow(n,1.0/x);
	int l = max(1,t - 1),r = t + 1,mid; 
	while(l <= r)
	{
		mid = (l + r) >> 1;
		if(Pow(mid,x) > n) r = mid - 1;
		else l = mid + 1;
	}
	return r-1;
}
set<__int128> s;
int main()
{
	read(n),read(k);
	if(k == 1) write(n);
	else if(k == 2) 
	write(1ll+calc(2)+calc(3)+calc(5)+calc(7)+calc(11)+calc(13)+calc(17)+calc(19)+calc(23)+calc(29)+calc(31)+calc(37)+calc(41)+calc(43)+calc(47)+calc(53)+calc(59)
	-calc(6)-calc(10)-calc(14)-calc(15)-calc(21)-calc(22)-calc(26)-calc(33)-calc(34)-calc(35)-calc(38)-calc(39)-calc(46)-calc(51)-calc(55)-calc(57)-calc(58)
	+calc(30)+calc(42)); 
	else
	{
		s.insert(1);
		F(i,2,1e6)
		{
			__int128 x = Pow(i,k);
			if(x > n) break;
			while(x <= n)
			{
				s.insert(x);
				x *= i;
			}
		}	
		write(s.size());
	}
	return 0;
}
```

---

## 作者：ReTF (赞：3)


题目大意是说，给定 $n$ 和 $k$，求 $[1,n]$ 中，能表示为 $a^b$ 的数有多少。其中 $b\ge k$。$1\le n\le 1\times 10^{18},1\le k \le 100$。

我们不妨来枚举幂次 $i$，$[1,n]$ 中能表示成 $a^i$ 的数 $A_i$ 的个数 $|A_i|$ 显然是 $\lfloor\log_in\rfloor$。显然 $\sum |A_i|$ 不是答案，会有重复。考虑容斥。发现对于每一个 $A_i$，它会被所有满足 $2\le j< i,j|i$ 的 $A_j$ 包含。令 $w_i$ 表示所有的 $A_i$ 在之前统计 $2\sim i-1$ 的答案时已经被重复算了 $-w_i+1$ 次，也就是答案加上 $|A_i|\times w_i$ 后，所有的 $A_i$ 会被算恰好一次。容易发现 $w_i=1-\sum_{j\ge 2,j|i}^{i-1}w_j$，答案为 $\sum_{i=2}|A_i|\times w_i$。统计一下即可。

时间复杂度为 $O(\log^2n)$。 

附上简陋的[代码](https://www.luogu.com.cn/paste/hylba72n)。


---

## 作者：littleone (赞：3)

提供一个搜索的解法。

首先对于 $k = 1$ 的情况，直接特判输出 $n$。

对于 $k \ge 2$ 的情况，记 $ans_{i,j}$ 为在 $1$ 到 $i$ 中，有多少个正整数可以被表示为 $a^b$ 的形式，其中 $a,b$ 都是正整数，且 $b \ge j$。

考虑如何计算 $ans_{99,2}$。显然，当底数大于 $1$ 时，指数最多为 $\lfloor log_2 \ i \rfloor$（此处为 $\lfloor log_2 \ 99 \rfloor = 6$）。首先我们列一个表格表示所有候选的答案。（$1$ 在这里先不考虑）

| $2^2$ | $2^3$ | $2^4$ | $2^5$ | $2^6$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $3^2$ | $3^3$ | $3^4$ | $3^5$ | $3^6$ |
| $4^2$ | $4^3$ | $4^4$ | $4^5$ | $4^6$ |
| $5^2$ | $5^3$ | $5^4$ | $5^5$ | $5^6$ |
| $6^2$ | $6^3$ | $6^4$ | $6^5$ | $6^6$ |
| $7^2$ | $7^3$ | $7^4$ | $7^5$ | $7^6$ |
| $8^2$ | $8^3$ | $8^4$ | $8^5$ | $8^6$ |
| $9^2$ | $9^3$ | $9^4$ | $9^5$ | $9^6$ |

我们发现有很多数超出了 $i$ 的范围。具体地，以 $2$ 为指数时，底数最多为 $\lfloor \sqrt[2]{99} \rfloor = 9$；以 $3$ 为指数时，底数最多为 $\lfloor \sqrt[3]{99} \rfloor = 4$；……

由此可得，计算 $ans_{i,j}$ 时，若以 $x$ 为指数，则底数最多为 $\lfloor \sqrt[x]{i} \rfloor$。

根据这一点，我们重新列出 $ans_{99,2}$ 的所有候选答案。

| $2^2$ | $2^3$ | $2^4$ | $2^5$ | $2^6$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $3^2$ | $3^3$ | $3^4$ |  |  |
| $4^2$ | $4^3$ |  |  |  |
| $5^2$ |  |  |  |  |
| $6^2$ |  |  |  |  |
| $7^2$ |  |  |  |  |
| $8^2$ |  |  |  |  |
| $9^2$ |  |  |  |  |

我们发现有很多数重复了，例如 $2^4 = 4^2 = 16$。更进一步地，我们发现，所有以满足 $y = a^b$（其中 $a,b$ 都是正整数，且 $b \ge 2$）的 $y$ 作为底数的数都与上方某些行中的数重复了。这些数也需要删掉。

| $2^2$ | $2^3$ | $2^4$ | $2^5$ | $2^6$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $3^2$ | $3^3$ | $3^4$ |  |  |
| $5^2$ |  |  |  |  |
| $6^2$ |  |  |  |  |
| $7^2$ |  |  |  |  |

这样，当计算 $ans_{i,j}$ 且指数为 $x$ 时，可以作为底数的数只有满足 $2 \le y \le \lfloor \sqrt[x]{i} \rfloor$ 且不能被表示为 $a^b$（其中 $a,b$ 都是正整数，且 $b \ge 2$）的 $y$。我们发现符合条件的 $y$ 的总数恰为 $\lfloor \sqrt[x]{i} \rfloor - ans_{\lfloor \sqrt[x]{i} \rfloor,2}$。因此我们得出以下式子（由于之前没有考虑 $1$，所以要额外多加 $1$）：

$$ ans_{i,j} = (\sum_{x = j}^{\lfloor log_2 \ i \rfloor} (\lfloor \sqrt[x]{i} \rfloor - ans_{\lfloor \sqrt[x]{i} \rfloor,2})) + 1$$

根据上式进行搜索计算出答案即可。（记忆化或不记忆化似乎都可以过）

注意开根号最好是手写，不要用`pow`函数。

代码：

```cpp
#include <cstdio>
#include <map>
using namespace std;
long long n,k;
map <long long,long long> ans;
bool check(long long x,long long y,long long z){
    long long p = 1;
    for(long long i = 1;i <= y;i++){
        if(p > z / x){
            return false;
        }
        p *= x;
    }
    return true;
}
long long cal(long long x,long long y){
    long long l = 1,r = x,mid,ret;
    while(l <= r){
        mid = l + r >> 1;
        if(check(mid,y,x)){
            ret = mid;
            l = mid + 1;
        }
        else{
            r = mid - 1;
        }
    }
    return ret;
}
void dfs(long long x,long long y){
    ans[x] = 1;
    for(long long i = y;cal(x,i) > 1;i++){
        long long tmp = cal(x,i);
        if(ans.find(tmp) == ans.end()){
            dfs(tmp,2);
        }
        ans[x] += tmp - ans[tmp];
    }
}
int main(){
    scanf("%lld%lld",&n,&k);
    if(k == 1){
        printf("%lld",n);
        return 0;
    }
    dfs(n,k);
    printf("%lld",ans[n]);
    return 0;
}
```

---

## 作者：BFSDFS123 (赞：3)

比较简单的一道题，考试的时候是从 3 而不是 k 开始枚举的，寄了。但是 CCF 给我了 95（因为没写 ``__int128`` 而是直接快速乘神奇哈希），我爱 CCF！

容易发现 $k=1$ 的时候答案为 $n$，直接输出即可。

$k\ge3$ 的时候，容易发现直接暴力枚举最多会枚举 $10^6$，直接暴力枚举即可。

所以我们只需要思考一下 $k=2$ 的时候的计算方法。

我们可以预处理出所有 $k\ge 3$ 的时候满足条件的数。

容易发现直接枚举 $k=2$ 的时候是 $10^9$，会死的很惨，于是考虑正难则反。

我们只需要考虑计算出预处理出所有的数中是完全平方数的个数，用小于等于 $n$ 的所有完全平方数的个数减去这个数，就是可以加入答案个数的平方数个数。

代码很好写，但是因为可能会炸 ``long long``，所以要使用 ``__int128``。考场上使用了快速乘并对 $n+1$ 取模再除是不是与前面相同，不知道为什么挂了 5 分。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-') w=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		s=s*10+ch-'0';
		ch=getchar();
	}
	return w*s;
}
void print(int x)
{
	if(x<0)
	{
		x=-x;
		putchar('-');
	}
	
	if(x<10)
	{
		putchar(x%10+'0');
		return ;
	}
	print(x/10);
	putchar(x%10+'0');
}
// Max log2(n):60
__int128 qmul(__int128 a,__int128 b,__int128 mod)
{
    __int128 res=0;
    while(b)
    {
        if(b&1)
        {
            res=(res+a)%mod;
        }
        a=(a+a)%mod;
        b>>=1;
    }
    return res;
}
__int128 Sqrt(__int128 a)
{
	__int128 l=1,r=a;
	__int128 ans=0;
	while(l<=r)
	{
		__int128 mid=(l+r)/2;
		if(mid*mid<=a)
		{
			l=mid+1;
			ans=mid;
		}else{
			r=mid-1;
		}
	}
	return ans;
}
signed main()
{
    int n,k;
    n=read();
    k=read();
    if(k==1)
    {
    	print(n);
    }else{
        //
        map<__int128,int> mp;
        mp[1]=1;
        for(__int128 i=2;i<=n;i++)
        {
            if(i*i*i>n)
            {
                break;
            }
            __int128 now=i*i*i;
            __int128 lst=i*i;
            int cnt=3;
            while(now<=(__int128)n)
            {
            	if(cnt>=k)
                	mp[now]=1;
                cnt++;
                //cout<<now<<endl;
                lst=now;
                now=qmul(now,i,n+1);
                if(now%i==0 && now/i==lst)
                {
                	continue;
				}
				break;
            }

            //cout<<i<<endl;

        }
        if(k>=3)
        {
        	print((int)mp.size());
        }else{
            int ans=mp.size();
            int cnt=0;
            int tmp=Sqrt(n);
            for(auto i:mp)
            {
                __int128 num=(i.first);
                auto sqr=Sqrt(num);
                if(sqr*sqr==num)
                {
                    cnt++;
                }
            }
			print(ans+tmp-cnt);
			
        }
    }
    return 0;
}
```

---

## 作者：Yh0326 (赞：2)

# #1
对于 $k = 1$，任意正整数可能满足，随意答案为 $n$。

# #2

对于 $k = 2$。

显然 $a$ 最大是 $10^9$ 的。

当 $b = 2$ 时，答案为 $\sqrt n$。

我们先不管这一部分，结合 #3 的做法再加上 $\sqrt n$ 即为答案。

当然，在算 #3 的时候需要特判是平方数的情况。

# #3

当 $k \ge 3$ 时，

因为 $a$ 最大只有 $10^6$，我们可以直接暴力。

枚举 $b$，记录 $n$ 的 $b$ 次根方。

用 set 存数，答案为 set 的大小。

在开放时注意不要用 `pow`，会被卡精度。

用 `powl`！！！

~~~cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n;
int k;
ll ans = 0;
set <ll> s;
ll aa;
#define pow powl
#define sqrt sqrtl
inline ll kpow(ll a, int nn){
	aa = 1;
	while(nn){
		if(nn & 1) aa *= a;
		a *= a;
		nn >>= 1;
	}
	return aa;
}
int main(){
	scanf("%lld%d", &n, &k);
	if(k == 1) return cout << n, 0;
	int p;
	if(k == 2){
		ll t;
		for(int i = 3;i <= 64;++ i){//从3开始算
			p = pow(n, 1.000 / i);
			if(p == 1) break;
			for(int j = 2;j <= p;++ j){
				t = kpow(j, i);
				if(fmod(sqrt(t), 1.0) != 0) s.insert(kpow(j, i));//特判掉平方数
			}
		}
		cout << (ll(sqrt(n))) + s.size() << '\n';
		return 0;
	}
	for(int i = k;i <= 64;++ i){
		p = pow(n, 1.000 / i);
		if(p == 1) break;
		for(int j = 2;j <= p;++ j){//不计算1，最后再加上
			s.insert(kpow(j, i));
		}
	}
	cout << s.size() + 1 << '\n';
}

~~~

---

## 作者：whdywjd (赞：2)

分享一个 $O(\log^3n)$ 的做法。

考虑容斥。

首先设 $v_i$ 为可以被表示成 $a^i$ 的数数量（$1$ 除外），显然 $v_i=\lfloor^i\sqrt{n}\rfloor-1$。

设 $dp_i$ 为可以被表示成 $a^i$ ，且不存在 $j>i$ 使得 $a^i=b^j$ 的数的数量。也就是说，如果一个数最多可以表示成 $i$ 次幂，那么它就只对 $dp_i$ 有贡献。

如果一个数 $x$ 最多可以表示成 $i$ 次幂，那么它只能被表示成 $i$ 的因数次幂。

因此，对于 $dp_i$，我们要删掉 $i$ 的倍数，即：

$dp_i=v_i-dp_{2i}-dp_{3i}-dp_{4i}-dp_{5i}\dots$。

另外可以发现，$i>64$ 时 $v_i=0$，所以只需存储 $[1,64]$ 的 $dp$ 值即可。

答案即 $1+\sum_{i=k}^{64} dp_i$（还要再算上 $1$）。

Code：

```cpp
#include <cstdio>
#include <algorithm>
#include <set>
#include <vector>
#define ll long long
#define _pb push_back
#define MAX_N 1353
#define inf (1ll << 62)

using namespace std;

ll read(){ll x = 0;char c = 0, v = 0;do{c = getchar();if(c == '-')v = 1;} while(c < '0' || c > '9');do{x = (x << 3) + (x << 1) + c - '0';c = getchar();} while(c >= '0' && c <= '9');return v ? -x : x;}
void write(ll p){if(p < 0)putchar('-'), write(-p);else if(p < 10)putchar(p + '0');else write(p / 10), putchar(p % 10 + '0');}

ll n, k, dp[MAX_N];

ll pow(ll x, ll k)
{
    if(!k)
        return 1;
    ll ans = pow(x, k - 1);
    if(ans == -1 || ans > inf / x)
        return -1;
    return ans * x;
}

ll qrt(ll x, ll k)
{
    ll l = 1, r = x;
    while(l < r)
    {
        ll mid = (l + r + 1) >> 1;
        ll c = pow(mid, k);
        if(c == -1 || c > x)
            r = mid - 1;
        else
            l = mid;
    }
    return l;
}

int main()
{
    freopen("power.in", "r", stdin);
    freopen("power.out", "w", stdout);
    n = read();
    k = read();
    for(int i = 1; i <= 64; i++)
        dp[i] = qrt(n, i) - 1;
    for(int i = 64; i; i--)
        for(int j = 2 * i; j <= 64; j += i)
            dp[i] -= dp[j];
    ll ans = 1;
    for(int i = k; i <= 64; i++)
        ans += dp[i];
    write(ans);
    return 0;
}
```

---

## 作者：2018ljw (赞：2)

整点花的。虽然 $k=2$ 的情况存在原题，但由于本题没有多测，所以实际上只需要跑点暴力就能过了。

- $k=1$

由于一定有 $x^1=x$，所以答案为 $n$。

- $k=3$

不难发现可能产生贡献的底数不超过 $\sqrt[3]n$。我们先把 $1$ 丢掉，只考虑 $[2,\sqrt[3]n]$ 内的所有底数。

由于 $2^{60}>10^{18}$，所以可以猜测有用的数其实没那么多。不妨暴力枚举底数和幂次，暴力算出结果后去重。

数的个数最多为 $\sum\limits_{i=3}\left(\log_in-1\right)$，其中减一是为了刨掉每次的 $1^i=1$。

无论是从 $\log_in$ 的函数上看，还是写个程序暴力跑一遍，都不难发现这个式子值很小，大约为 $O(\sqrt[3]n)$ 级别。

于是我们开个哈希表，暴力枚举底数指数，暴力去重即可。

- $k\ge 4$

$k=3$ 的时候有用的数的个数为 $O(\sqrt[3]n)$ 级别，$k$ 越大数的个数只会越少，因此跑遍暴力即可。

- $k=2$

不能暴力枚举所有底数了，但思考一下去重部分，考虑如何计算 $a^b=c^d$ 且 $a\neq 1$ 的点对数。

假设 $a<c$，则一定有 $b>d$。对于一个重复对，$d$ 至少为 $2$，因此 $b\ge 3$。

$b\ge3$，因此我们可以仿照 $k=3$ 的部分分，暴力跑出这部分数，然后考虑有哪些数对满足 $a^b=c^d$。

对于 $d\ge 3$ 的部分，以及 $d=2$ 且 $c\le \sqrt[3]n$ 的部分，会在暴力过程中顺带被去重掉。

那么唯一的问题，就是 $d=2$ 且 $\sqrt[3]n<c\le \sqrt[2]n$ 的部分了。

先暴力把这 $\sqrt[2]n-\sqrt[3]n$ 个数的二次方作为贡献统计答案，再考虑如何去重。由于这些数的三次方一定大于 $n$，因此重复只能是与先前暴力筛出来的部分有重复。所以我们观察暴力筛出的每个数 $x$，若存在整数 $y$ 使得 $x=y^2$ 且 $\sqrt[3]n<y\le \sqrt[2]n$，则说明 $y^2$ 被重复计算了，因此答案要减一。

总复杂度 $O(\sqrt[3]n)$。

- $k=2$，多测

先暴力把 $k=3,n=10^{18}$ 时所有数跑出来，再把这些数中的完全平方数单独存出来。

分析 $k=2$ 的流程，并尝试在其上做些手脚。

1. 求出 $k=3$ 时的结果以及这些数。只需要在我们最后得到的数组内排序后二分一下即可。
2. 将 $\sqrt[3]n<c\le\sqrt[2]n$ 的数加入贡献。暴力开根就行，不放心的话可以手写二分开根。
3. 求 $k=3$ 的结果里有多少完全平方数，使得其算术平方根在 $(\sqrt[3]n,\sqrt[2]n]$ 区间内。因为预先处理了其中的完全平方数，所以就等价于在这个数组内找到开根内结果在一个区间内数的个数。显然可以做两次二分处理。

这是强制在线的情况。如果允许离线的话，把询问按 $n$ 排序后双指针代替二分即可做到 $O(q\log q+\sqrt[3]N)$，其中 $N=\max\{n\}$。

赛时代码：

```
#include<cstdio>
#include<cmath>
#include<unordered_map>
const int m=1e6;
using namespace std;
long long n;
int k;
unordered_map<long long,bool>w;
bool slr(long long v){
	long long x=n;
	int i;
	for(i=1;i<=k;i++){
		x/=v;
		if(!x)return 0;
	}
	return 1;
}
long long ksm(long long x,int y){
	long long res=1;
	while(y){
		if(y&1)res=res*x;
		y>>=1;
		if(y)x=x*x;
	}
	return res;
}
int main(){
	int i,j;
	long long ans=1;
	scanf("%lld%d",&n,&k);
	long long sq2,sq3;
	if(k==1||n==1){
		printf("%lld",n);
		return 0;
	}
	if(k>=3){
		long long l=1,r=1e6,res=0;
		while(l<=r){
			long long mid=l+r>>1;
			if(!slr(mid))r=mid-1;
			else l=mid+1,res=mid;
		}
		for(i=2;i<=res;i++){
			long long mul=ksm(i,k);
			for(j=1;j;j++){
				if(!w[mul])w[mul]=1,ans++;
				if(n/mul/i>=1)mul*=i;
				else break;
			}
		}
		printf("%lld",ans);
		return 0;
	}
	long long l=1,r=1e9,res=0;
	while(l<=r){
		long long mid=l+r>>1;
		if(mid*mid>n)r=mid-1;
		else l=mid+1,res=mid;
	}
	sq2=res;
	l=1,r=1e6,res=0;
	while(l<=r){
		long long mid=l+r>>1;
		if(mid*mid*mid>n)r=mid-1;
		else l=mid+1,res=mid;
	}
	sq3=res;
	ans+=sq2-sq3;
	for(i=2;i<=sq3;i++){
		long long mul=1ll*i*i;
		for(j=1;j;j++){
			if(!w[mul]){
				w[mul]=1;ans++;
				long long d=sqrt(mul);
				if((d+1)*(d+1)==mul)d++;
				if((d-1)*(d-1)==mul)d--;
                //防 sqrt 开根掉精度
				if(d*d==mul)if(d>sq3&&d<=sq2)ans--;
			}
			if(n/mul/i>=1)mul*=i;
			else break;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：zzx0102 (赞：2)

# 法0：

输出 $n$。

期望得分 $5$ 分。

# 法1：

从 $1$ 到 $n$ 搜索每一种情况，判断能不能满足 $x=a^i$

复杂度 $O(62n)$。

期望得分 $30$ 分。

# 法2：

当 $x=a^i$ 时，$i$ 显然是质数，否则一定有一样的方案。

反证：假设 $i=jk$。

那么 $x=a^i=a^{jk}=({a^j})^k$。

显然有另一组解。

那么对于每一个 $i$，将所有满足 $a^i\leq n$ 的情况计算一遍，开 set 去重即可。

注意：当 $k>62$ 时，输出 $1$。

最坏复杂度 $O(\sqrt n)$。

期望得分 $80$ 分。

# 法3：

特判：当 $k=2$ 时。

所有 $\lfloor{\sqrt{i}^2}\rfloor=i$ 的情况忽略。

那么答案就是 set 的长度加 $\lfloor \sqrt n\rfloor$。

期望得分 $100$ 分。

---

## 作者：Tsawke (赞：2)

# [LG-P9118 [春季测试 2023] 幂次](https://www.luogu.com.cn/problem/P9118) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.tsawke.com?t=LG-P9118-Solution)

## [游记戳此进入](https://www.luogu.com.cn/blog/tsawke/spring-test)

### 题面

给定 $ n $，$ k $，求在 $ [1, n] $ 中有多少数可以表示为 $ a^b $，其中 $ b \ge k $。

### Solution

感觉差不多是绿题的难度，不卡精度的话应该算黄题难度，赛时的阴间思路在游记里了，这里说一下正解。

不难发现对于任意的合法的 $ b $，一定满足 $ a \le {^k\sqrt{n}} $，则对于 $ k \ge 3 $ 的情况，$ a $ 最大也是在 $ 10^6 $ 的范围，那么我们直接枚举所有的 $ a $，并枚举其所有合法的 $ a^b $，然后将其全部丢到 `unordered_set` 里，最后直接输出其 `size()` 即可，考虑这样的复杂度，显然枚举 $ a $ 是 $ O(n^{\frac{1}{k}}) $ 的，枚举幂次是 $ O(\log n) $ 的，则复杂度 $ O(n^{\frac{1}{k}} \log n) $，对于 $ k \ge 3 $ 的情况是随便过的。

考虑对于 $ k = 2 $ 的情况，不难发现这东西也是很显然的，枚举一下 `unordered_set` 中的所有数，若其为完全平方数的话贡献 $ -1 $，然后最后在答案中加上 $ \lfloor \sqrt{n} \rfloor $ 即可。不难发现此时复杂度为 $ O(n^{\frac{1}{3}} \log n) $，可以通过。

同时不难发现对于 $ \sqrt{n} $，这个东西如果直接朴素的用 `double` 的 `sqrt()` 函数的话会丢失精度，所以此时需考虑使用二分或 `long double` 或 `__float128`，前者会多一个 $ \log $，对于上述 $ k = 2 $ 的理论复杂度也是正确的。而用 `__float128` 会多一个十分巨大的甚至高于 $ \log $ 的常数，不建议使用。当然我们也可以朴素地使用 `sqrt()` 然后取其返回值一段较小的邻域进行验证，一般 $ \pm 1 $ 就够用了。

### Code

```cpp
#define _USE_MATH_DEFINES
#include <bits/stdc++.h>

#define PI M_PI
#define E M_E
#define npt nullptr
#define SON i->to
#define OPNEW void* operator new(size_t)
#define ROPNEW void* Edge::operator new(size_t){static Edge* P = ed; return P++;}
#define ROPNEW_NODE void* Node::operator new(size_t){static Node* P = nd; return P++;}

using namespace std;

mt19937 rnd(random_device{}());
int rndd(int l, int r){return rnd() % (r - l + 1) + l;}
bool rnddd(int x){return rndd(1, 100) <= x;}

typedef unsigned int uint;
typedef unsigned long long unll;
typedef long long ll;
typedef long double ld;

template < typename T = int >
inline T read(void);

ll N, K;
unordered_set < ll > legal;
ll ans(0);

int main(){
    auto qpow_with_lim = [](ll a, ll b)->ll{
        ll ret(1), mul(a);
        while(b){
            if(b & 1)
                ret = (__int128_t)ret * mul > N ? N + 1 : ret * mul;
            b >>= 1;
            mul = (__int128_t)mul * mul > N ? N + 1 : mul * mul;
        }return ret;
    };

    N = read < ll >(), K = read();
    if(K == 1)printf("%lld\n", N), exit(0);
    legal.insert(1);
    for(ll i = 2; i <= (ll)1e6; ++i){
        auto cur = (__int128_t)qpow_with_lim(i, K == 2 ? 3 : K);
        while(cur <= N)
            legal.insert(cur), cur *= i;
    }ans += legal.size();
    if(K == 2){
        for(auto v : legal)
            if((ll)sqrt((ld)v) * (ll)sqrt((ld)v) == v)--ans;
        ans += (ll)floor(sqrt((ld)N));
    }printf("%lld\n", ans);
    fprintf(stderr, "Time: %.6lf\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}

template < typename T >
inline T read(void){
    T ret(0);
    int flag(1);
    char c = getchar();
    while(c != '-' && !isdigit(c))c = getchar();
    if(c == '-')flag = -1, c = getchar();
    while(isdigit(c)){
        ret *= 10;
        ret += int(c - '0');
        c = getchar();
    }
    ret *= flag;
    return ret;
}
```

## UPD

update-2023_03_06 初稿

---

## 作者：二叉苹果树 (赞：2)

本题的数据范围实际上并不大。对于题目中的 $a^b$，当 $b = 3$ 时，$a ^ b = a ^ 3 \le 10 ^ {18}$，此时有 $a \le 10^6$ 完全可以接受。当 $b$ 增大时，$a$ 会更小。所以本题我们可以用最朴素的暴力去做。

注意到 $k = 1$ 时，任何数 $x$ 都可以被表示成 $x ^ 1$ 的形式，故对于 $1 \le x \le n$，满足题意的数有 $n$ 个。

$k > 2$ 时，我们对于每个数 $x$ 都枚举其的 $k \sim \log_x10^{18}$ 次幂并将其中符合题意的数加入一个集合 $A$，最后的答案即为该集合元素的个数。

而 $k = 2$ 时，与 $k > 2$ 时的情况不同，因为此时有 $b = 2$ 的情况。而这种情况下则有 $a \le 10^9$，需要特殊处理这一部分。

可以表示为 $a^2(a \in \mathbb{N^+})$ 的数被称为完全平方数，对于 $1 \sim n$，显然有 $\sqrt{n}$ 个数是完全平方数。那么最终的答案就是这个完全平方数的集合 $B$ 与集合 $A$ 的并集的元素个数。

但是关于完全平方数的集合的元素个数非常多，两个集合显然不方便直接取并集。那么我们可以将集合 $A$ 中去除掉完全平方数，再将两个集合直接相加即可。

对于集合 $A$ 中的数 $x = a ^ {2k},k \in \mathbb{N^+}$，这个数一定是一个完全平方数，因为这个数也一定可以表示成 $x = (a ^ k) ^ 2$ 的形式。此外，对于这个集合中的数 $x = a ^ {2k - 1},k \in \mathbb{N^+}$，我们需要判断其底数 $a$ 是否为完全平方数。若 $a$ 是完全平方数，无论指数是奇数还是偶数，这个数都一定是一个完全平方数。

也就是说，我们需要在集合 $A$ 中去掉这样两种数。将这些数表示为 $x = a ^ b$。

- $b$ 是偶数。
- $a$ 是完全平方数。

此外，$\rm{andyli} $指出还有一些值得注意的点。

- 为了避免溢出，最好将类似 ```if (x * i <= n) ``` 的语句写成 ```if (x <= n / i) ``` 。

- 对于大数开平方，最好使用 $\rm{sqrtl}$ 而不是 $\rm{sqrt}$。

这两点在我的代码中均有体现。

```cpp
#include <bits/stdc++.h>

const long long MAXN = 1000000;
const long long INF = 1000000000000000000;
std::unordered_set<long long> s;

int main()
{
    long long n, k;
    std::cin >> n >> k;
    if (k == 1)
        std::cout << n << std::endl;
    else if (k == 2)
    {
        for (long long i = 2; i <= std::min(n, MAXN); i++)
        {
            long long x = i * i * i;
            if (x > n)
                break;
            double q = sqrtl(x);
            if (q != (long long)q)
                s.insert(x);
            while (x <= n / (i * i))
            {   
                x *= i * i;
                q = sqrtl(x);
                if (q != (long long)q)
                    s.insert(x);
            }
        }
        std::cout << s.size() + (long long)(sqrtl(n)) << std::endl;
    }
    else
    {
        for (long long i = 2; i <= std::min(n, MAXN); i++)
        {
            bool flag = 0;
            long long x = 1;
            for (int j = 1; j <= k; j++)
            {
                if (x > n / i)
                {
                    flag = 1;
                    break;
                }
                x *= i;
            }
            if (!flag)
            {
                s.insert(x);
                while (x <= n / i)
                {   
                    x *= i;
                    s.insert(x);
                }
            }
            else
                break;
        }
        std::cout << s.size() + 1 << std::endl;
    }
}
```



---

## 作者：bmatrix (赞：1)

首先 $b=1$ 显然直接输出 $n$。

剩下的考虑枚举指数，用 `set` 去重。

枚举指数 $i$ 至 $2^i > n$，这样可以做到 $O(n^{\frac 1k} + n^{\frac 1{k+1}} + n^{\frac 1{k+2}}\dots)$ 的复杂度，虽然我不会算，但是肉眼观察当 $k=2$ 时只比根号稍微高一点。

容易发现 $k=3$ 时，即使 $n=10^{18}$ 也只有大约 $10^6$ 的计算量，可以考虑先把指数 $\ge 3$ 的数先算出来，再处理指数为 $2$ 的。

显然如果不考虑重复的话能表示为 $a^2,a\in\mathbb N^*$ 的数有 $\sqrt n$ 个，从已经算出来的数中把平方数删掉即可。

这题有几个坑点，一个是如果要用快速幂要开 int128，还有一个是开根要用 `sqrtl`，否则会炸精度 WA。

```cpp
#include<bits/stdc++.h>
#define rep(i, s, t) for(int i = s; i <= t; ++i)
#define per(i, s, t) for(int i = s; i >= t; --i)
#define int ll
#define endl '\n'
#define F first
#define S second
typedef long long ll;
typedef __uint128_t u128;
constexpr int N = 1e5 + 5;
using namespace std;
int n, k;
u128 pw(u128 a, int b) {
    u128 res = 1;
    for(; b; b >>= 1) {
        if(b & 1) res *= a;
        a *= a;
    }
    return res;
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n >> k;
    if(k == 1) {
        cout << n << endl;
        return 0;
    }
    set<uint64_t> st;
    for(int i = max(k, 3ll); 1; ++i) {
        u128 tmp; int j = 1;
        if(i == 2) for(; (tmp = (u128)j * j) <= n; ++j) st.emplace(tmp);
        else for(; (tmp = pw(j, i)) <= n; ++j) st.emplace(tmp);
        if(j == 2) break;
    }
    if(k == 2) {
        int res = sqrtl(n);
        for(auto i : st) {
            int r = sqrtl(i);
            if(r * r == i) --res;
        }
        cout << st.size() + res << endl;
    }
    else cout << st.size() << endl;
    return 0;
}
```

---

## 作者：GI录像机 (赞：1)

## 思路：

看到这道题的数据范围，可以知道依次判断每个数是否符合要求是不可取的。我们应该用 $a$ 和 $b$ 去寻找符合要求的数。

当 $k=1$ 时，显然所有数字都是符合要求的。

当 $k>2$ 时，符合条件的数字数量最多是（由于有重复，如 $16=2^4=4^2$，实际上是达不到的） $\sqrt[k]{n}+\sqrt[k+1]{n}+\cdots$ 个，是 $\sqrt[k]{n}$ 级别的，可以分别枚举 $a$ 和 $b$，再用 map 判重。复杂度为 $\sqrt[k]{n} \log \sqrt[k]{n}$。

当 $k=2$ 时，发现 $\sqrt{n}$ 可以达到 $10^9$，显然不能同 $k>2$ 时一样直接暴力枚举。容易发现小于 $n$ 的符合 $a^2=x$ 的 $x$ 数量为 $\lfloor \sqrt{n}\rfloor$。因此可以在 $k>2$ 的基础上增加一个是否为平方数的判断条件。复杂度为 $\sqrt[3]{n} \log \sqrt[3]{n}$。

## 细节：

$a=1$ 时不能枚举 $b$，否则会直接死循环，应提前加入答案。

sqrt 函数返回值是 double 类型，不能准确处理大小为 $10^{18}$ 的数，应该使用 sqrtl。 

在判断大小中移项用除法判断，否则会爆。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
int read() {
	int f = 1, x = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f * x;
}
void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 2e5 + 10, MOD = 1e9 + 7, INF = 0x3f3f3f3f;
int n = read(), k = read(), ans = 1;
map<int, bool>mp;
int qpow(int a, int b) {
	int r = 1;
	while (b) {
		if (b & 1)r *= a;
		a *= a;
		b >>= 1;
	}
	return r;
}
signed main() {
	if (k == 1)ans = n;
	else if (k == 2) {
		ans = sqrtl(n);
		for (int j = 2; j * j * j <= n; j++)
			for (int p = j * j * j; p <= n; p *= j)
				if (!mp[p] && (int)(sqrtl(p)) * (int)(sqrtl(p)) != p) {
					mp[p] = 1;
					ans++;
				}
	} else {
		for (int j = 2; qpow(j, k) <= n; j++)
			for (int p = qpow(j, k); p <= n; p *= j)
				if (!mp[p]) {
					mp[p] = 1;
					ans++;
				}
	}
	write(ans);
	return 0;
}
```


---

## 作者：Unnamed114514 (赞：1)

首先考虑到 $1$ 点，在 $n=10^{18}$ 时，容易发现完全平方数有 $10^9$ 个，但是完全立方数就只剩 $10^6$ 个了，所以我们可以考虑先求平方数，然后在暴枚剩下的数。

我们来考虑一下枚举的上界：当 $p>\log_2 n$ 时，可以发现 $2^p>n$，此时底数只能是 $1$，所以我们枚举次方最多就 $\log n$ 个。

然后，我们在暴枚的时候，可以考虑直接拿 `map` 标记，然后对于平方数的判断，直接打个函数判断即可。

注意到 $k=2$ 时平方数其实只有 $\lfloor\sqrt{n}\rfloor$ 个，所以可以直接求。

$k=1$ 的时候特判即可，答案为 $n$。

$1$ 肯定是可以的，初始化的时候算一下就行了。

注意到 `pow` 和 `sqrt` 都会被卡精度，要手写二分。


时间复杂度应该是 $O(\sqrt[3]{n}\log^2n\log\log n)$。

其实这个复杂度远远地跑不满，在 $\sqrt[4]{n}$ 的时候其实就只剩下 $3\times10^4$ 左右了，所以其实时间复杂度大概就是只有 $O(\sqrt[3]{n}\log n\log \log n)$。（好像快速幂改成普通的循环还会快一点？）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxk=1e6+5;
int n,k,res[60],p[maxk];
map<int,bool> vis;
inline int qpow(int a,int b){
	int s=1;
	while(b){
		if(b&1){
			if(s>1e18/a)
				return 9e18;
			s*=a;
		}
		if(b>1&&a>1e18/a)
			return 9e18;
		a*=a,b>>=1;
	}
	return s;
}
inline int get(int n,int x){
	int l=1,r=(x==2?1e9:1e6);
	while(l<r){
		int mid=l+r+1>>1;
		if(qpow(mid,x)>n)
			r=mid-1;
		else
			l=mid;
	}
	return r;
}
inline bool check(int n){
	int p=get(n,2);
	if(p*p==n)
		return 1;
	return 0;
}
signed main(){
	cin>>n>>k;
	if(k==1){
		cout<<n<<endl;
		return 0;
	}
	int res,tot;
	if(k==2)
		res=get(n,2),tot=3;
	else
		res=1,tot=k;
	vis[1]=1;
	while(1){
		int x=get(n,tot);
		if(x==1)
			break;
		for(int i=2;i<=x;++i){
			int val=qpow(i,tot);
			if(!vis.count(val)){
				if(k==2&&check(val))
					continue;
				vis[val]=1;
				++res;
			}
		}
		++tot;
	}
	cout<<res<<endl;
	return 0;
}
```

---

## 作者：wwz1428572008 (赞：1)

# 思路

## 部分分解法（暴力）

看到题目，想到枚举所有可能的 $b$。考虑当 $a\ge 2$ 时，由于 $n\le 10^{18}$，所以 $b\le 64$。然后，通过观察数据点，可以先想 $b \ge 3$ 时的情况。这时，$a\le 10^6$，所以可以直接枚举所有可能的 $a$，找出所有满足条件的 $x=a^b$ 的个数。

难点在 $b=2$ 时。此时，$a \le 10^9$，直接枚举会超时（如果这种情况暴力枚举，理论上可以至少得75分）。

## 正确解法

首先，对于确定的 $b$，不超过 $n$ 的 $b$ 次方数应当有 $\lfloor \sqrt[b]{n} \rfloor$ 个。但题目中说，同一个数的不同的合法表示方法只会被计入一次。所以有一个十分重要的引理：当 $a>1$ 时，**如果 $x$ 可以表示为 $a^b$ 的形式，其中 $b \ge k$，则它有且仅有一种表示方式，使得 $a$ 不是一个整数的大于1次方。** 这条引理很明显是正确的，那么只需要计算 $1$ 到 $\lfloor \sqrt[b]{n} \rfloor$ 中，不能表示为一个整数的大于1次方的整数的个数。再将所有的 $b$ 所对应的结果相加，就是最终答案。但是，同暴力解法，当 $b=2$ 时，直接枚举也会超时。

如果实在想不到更好的方法，可以分段打表，每一百万个数就放进表里。这样应该不会超时。但是，的确有更好的方法。

设 $m$ 为 $\lfloor \sqrt[b]{n} \rfloor$。我们再反向思考，考虑 $1$ 到 $m$ 中可以表示为一个整数的大于1次方的整数的个数。所以，此类数的个数最多有 $\sum_{i=2}^{64}{\lfloor \sqrt[i]{m} \rfloor}$ 个。由于 $m\le 10^9$，所以此类数的个数可以用写程序或数学的方法验证，其小于 $10^5$。于是，我们可以处理出这类数的数组，再对于每个 $b$，通过二分搜索找出此类数的个数，用 $m$ 减去它，便得到当前 $b$ 的结果。把所有结果求和，就是题目要求的答案。

浮点数精度问题：在求 $\lfloor \sqrt[b]{n} \rfloor$ 时，可以先用 `cmath` 库中的 `pow` 函数，加上 $eps$ 后向下取整，如果答案的 $b$ 次方比 $n$ 大，则将答案减一。


# 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
const double eps=1e-9;
int pw[100002];
int rt(long long x,int y)
{
    int z=pow(x,1.0/y)+eps;
    long long t=1;
    for(int i=1;i<=y;i++)
        t=t*z;
    if(t>x)
        z--;
    return z;
}
int main()
{
    freopen("power.in","r",stdin);
    freopen("power.out","w",stdout);
    long long n;
    cin>>n;
    int k;
    cin>>k;
    if(k==1)
    {
        cout<<n;
        return 0;
    }
    pw[++pw[0]]=1;
    for(long long i=2;i*i<=1000000000;i++)
    {
        for(long long j=i*i;j<=1000000000;j*=i)
            pw[++pw[0]]=j;
    }
    sort(pw+1,pw+pw[0]+1);
    int tp=unique(pw+1,pw+pw[0]+1)-pw,ans=1;
    pw[0]=tp-1;
    for(int i=k;i<=60;i++)
    {
        int x=rt(n,i);
        ans+=x-(upper_bound(pw+1,pw+tp,x)-pw-1);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：南阳刘子骥 (赞：1)

首先我们有一个暴力的解法。

对于一个数字，如果我们可以用多种方法将其表示成 $a^b$ 的形式，那么假设对于两组表示方法 $a1^{b1}$ 和 $a2^{b2}$ 且 $a1 < a2$，那么 $a2$ 总是可以表示为 $a1^c$，其中 $c$ 是一个大于 $1$ 的正整数。

那么我们可以套用欧拉筛的思想，把每一个符合要求的数字唯一地表示为一个底数最小的形式，这样每一个符合要求的数字只会被标记一次。  
那么对于 $n \leq 10^{18},k \geq 3$ 的情况，我们只需要筛 $10^6$ 内的数字即可，复杂度是 $O(\min(\sqrt[k]{n},ans))$ 的。  
同时，我们这样也可以通过 $n \leq 10^{12},k \geq 2$ 的情况，毕竟我们枚举到了 $10^6$。

参考代码如下：
``` cpp
ll ans = 1;
for(ll i = 2; i <= min<ll>(n, 1e6); i++)
{
	if(vis[i])continue;
	ll x = i * i;
	for(int j = 2; x <= n; j++)
	{
		if(x <= 1e6)vis[x] = true;
		if(j >= k)ans++;
		if(n / i < x)break;
		x = x * i;
	}
}
printf("%lld\n", ans);
```

通过观看给出的样例，我们发现当 $n=10^{18}$ 且 $k=3$ 的时候，答案是 $1036002$，只比 $10^6$ 稍微大一点。至于答案为什么只有这种级别的大小的证明放在[这里](https://www.luogu.com.cn/paste/xdpkgezq)，此处就不再赘述了。  
这样可以通过 $75$ 分的数据，剩下的部分是 $10^{12} \leq n \leq 10^{18}$ 且 $k=2$ 的。

考虑为什么我们无法通过这些数据。  
其根本原因就在于，我们需要枚举 $10^9$ 范围以内的每个数才能覆盖上 $10^{18}$ 内的所有平方数。  
需要解决的目标确定了，我们着手来解决。  
我们可以直接进行统计——毕竟 $n$ 以内平方数的数量是 $\sqrt{n}$。  
剩下的数字我们继续用筛，但是需要注意避让已经统计过的平方数，而方法就是忽略所有偶数次方的数字，毕竟 $a^{2b} = (a^b)^2$。

到此，我们就已经可以完成整道题目了。无论怎样的数据都可以通过。

完整代码如下：

``` cpp
#define _CRT_SECURE_NO_WARNINGS
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1000010;
ll n;
int k;
bool vis[N];
int main()
{
	scanf("%lld%d", &n, &k);
	if(k <= 1)
	{
		printf("%lld\n", n);
		return 0;
	}
	if(k == 2)
	{
		ll ans = sqrtl(n);
		for(ll i = 2; i <= min<ll>(n, 1e6); i++)
		{
			if(vis[i])continue;
			ll x = i * i;
			for(int j = 2; x <= n; j++)
			{
				if(x <= 1e6)vis[x] = true;
				if((j >= k) && (j & 1))ans++;
				if(n / i < x)break;
				x = x * i;
			}
		}
		printf("%lld\n", ans);
	}
	else
	{
		ll ans = 1;
		for(ll i = 2; i <= min<ll>(n, 1e6); i++)
		{
			if(vis[i])continue;
			ll x = i * i;
			for(int j = 2; x <= n; j++)
			{
				if(x <= 1e6)vis[x] = true;
				if(j >= k)ans++;
				if(n / i < x)break;
				x = x * i;
			}
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---


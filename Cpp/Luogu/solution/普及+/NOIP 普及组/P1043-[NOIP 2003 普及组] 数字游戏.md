# [NOIP 2003 普及组] 数字游戏

## 题目描述

丁丁最近沉迷于一个数字游戏之中。这个游戏看似简单，但丁丁在研究了许多天之后却发觉原来在简单的规则下想要赢得这个游戏并不那么容易。游戏是这样的，在你面前有一圈整数（一共 $n$ 个），你要按顺序将其分为 $m$ 个部分，各部分内的数字相加，相加所得的 $m$ 个结果对 $10$ 取模后再相乘，最终得到一个数 $k$。游戏的要求是使你所得的 $k$ 最大或者最小。


例如，对于下面这圈数字（$n=4$，$m=2$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gy407k49.png)

要求最小值时，$((2-1)\bmod10)\times ((4+3)\bmod10)=1\times 7=7$，要求最大值时，为 $((2+4+3)\bmod10)\times (-1\bmod10)=9\times 9=81$。特别值得注意的是，无论是负数还是正数，对 $10$ 取模的结果均为非负值。

丁丁请你编写程序帮他赢得这个游戏。


## 说明/提示

**【题目来源】**

NOIP 2003 普及组第二题

## 样例 #1

### 输入

```
4 2
4
3
-1
2
```

### 输出

```
7
81
```

# 题解

## 作者：徐振羽 (赞：58)

一看到这道题，我感觉是个深搜

但我们看一数据大量，也就循环个5000亿次而已，于是果断放弃

我们决定用DP，不要问为什么，因为我们可以从几个已知数据得出未知数据

这里要注意了，因为题目中数字构成一个环，所以我们要先化环为链

我们看看我们怎样DP，我们需要一个三维数组f[i][j][l]，i和j表示我们取第i个数字到第j个数字，l表示我们将第i个数字到第j个数字分为l段（f存最大值）

我们明白了动态规划中数组的含义，就能较容易的推出动态规划转移方程了

我们用一个4重循环，第1,2重i,j表示第i个数字到第j个数字，l表示我们将第i个数字到第j个数字分为l段，k表示我们在i,j中取得中间值，将第i个数字到第j个数字拆成第i个数字到第k个数字和第k+1个数字到第j个数字。

明白了动态规划中数组的含义和动态规划转移方程，我们只需要进行一个初始化就行了，通过动态规划转移方程，我们发现无法推出f[i][j][1]，所以我们要做的就是在动归开始前，将全部f[i][j][1]赋值

至于f[i][j][1]的初始值怎么赋，就是枚举i,j，再将第i个数字到第j个数字全部加起 mod 10 就行了

### 代码附上

```
#include<iostream>
using namespace std;
long long a[1001],x[1001],n,m,max1,min1=1000000000000000;
//x为一开始读入的数据，a为便于计算一段之和的前缀和 
long long f[101][101][11],f1[101][101][11]; 
//f数组存最大值，f1数组存最小值 
int main(){
	cin>>n>>m;
	for (int i=1;i<=100;i++)
		for (int j=1;j<=100;j++)
			for (int k=1;k<=10;k++)
				f1[i][j][k]=10000000000;
	//先给f1数组赋上巨大的值，便于计算之和的最小值 
	for (int i=1;i<=n;i++)
	{
		cin>>x[i];//读入 
		a[i]+=a[i-1]+x[i];//前缀和 
	}
	//化环为链 
	for (int i=n+1;i<=n*2;i++) a[i]+=a[i-1]+x[i-n];//前缀和 
	for (int i=1;i<=n*2;i++)
		for (int j=1;j<=n*2;j++)
		{
			f[i][j][1]=(a[j]-a[i-1]+100000000000)%10;//前缀和求一段数的和 
			f1[i][j][1]=(a[j]-a[i-1]+100000000000)%10;//前缀和求一段数的和 
			//因为输入有负数，所以a[j]可能会小于a[i-1],所以我们给他加上巨大值 
		}
	//赋初始值	
	for (int i=1;i<=n*2;i++)//枚举开始的数字位置 
	{
		for (int j=i+1;j<=n*2;j++)//枚举结束的数字位置 
		{
			for (int l=2;l<=m;l++)//枚举分段的数量 
			{
				for (int k=i;k<j;k++)//枚举中间数的位置 
				{
					f[i][j][l]=max(f[i][j][l],f[i][k][l-1]*f[k+1][j][1]);//动态规划转移方程
					f1[i][j][l]=min(f1[i][j][l],f1[i][k][l-1]*f1[k+1][j][1]);//动态规划转移方程 
				}
			}
		}
	}
	for (int i=1;i<=n;i++) 
	{
		max1=max(max1,f[i][i+n-1][m]);//求一段的最大值 
		min1=min(min1,f1[i][i+n-1][m]);//求一段的最小值  
	}
	cout<<min1<<endl<<max1<<endl;//输出
	return 0; 
}
```


---

## 作者：Error_666 (赞：44)

我们先来分析题目：（~~帮你读题~~）
   1. 是个环
   	- 推出需要断环成链
   2. 分成m段，并且不满足贪心思路
   	- 算法可采用dp
   3. 数据范围n(1≤n≤50)和m(1≤m≤9)
   	- dp转移方程应该为二或三维

---

思考转移方程：  
- 先将环断成n条链，存储到一个数组中
- 我们需要用一个式子表示出所有的状态。因为是个环，我们用区间dp的思路试试：
	- dp[i][j][k][0]: 表示区间i - j被分成k个部分时的最小解  
    - dp[i][j][k][1]: 表示区间i - j被分成k个部分时的最大解  
- 仔细think一下发现这样是可以表达出所有状态的。至于转移，~~凭借我的多年刷题经验~~，先枚举断点，再枚举断点左边的区间被分成kk部分，则右边区间被分成k - kk部分。然后两区间相乘转移到新区间即可。  
- 我猜你看完上面那一段话，如果对dp不是很熟练的选手，可能已经懵了。
- 那么这篇题解就是给你提供一个新的思路，可能会更容易理解些

---

思考转移方程Again：
- dp1[i][j]: 表示前i个数字被分成j份的最小解
- dp2[i][j]: 表示前i个数字被分成j份的最大解
- （是不是很眼熟，没错，是2000TG真题T2）
- 那么这个转移方程就非常容易想了：
	- dp[i][j] = max(dp[k][j - 1] + sum[k + 1][i])
    - (j <= k <= i - 1)
    - sum[l][r]: 表示l-r区间的数字之和
- 解释一下这个转移：当前需要找前i个中分成j份的最x解，那么只需要从前1 - i-1个中找（已经分成j-1份的最x解*它后面的那一段数）的最x解

---

优化之处：
1. 将四维dp降到了三维，再通过开俩个数组可降到二维~~（并无卵）~~
2. 编程复杂度降低。由原四五个循环直接降到了三个循环
3. 思维的提升：将模型进一步转化

---

- 代码：
- 代码中一些小细节就写了点注释，~~我太懒了~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define maxn 55
using namespace std;

int n, k, ans1, ans2 = 0x7fffffff;
int c[maxn * 2], a[maxn], sum[maxn];
int dp[maxn][maxn];

int mod(int k) {
    return ((k % 10) + 10) % 10;
}

int main()
{
	freopen("P1043.in", "r", stdin);
	freopen("P1043.out", "w", stdout);
	
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        cin >> c[i];
        c[i + n] = c[i];//断环成链处理
    }
    
    for(int s = 1; s <= n; s++)
    {
        int t = 0;
        for(int i = s; i <= s + n - 1; i++)
        {
            a[++t] = c[i];//每次a数组获得断好的一条链
            sum[t] = sum[t - 1] + a[t];//前缀和
        }
        
        //dp[i][j] = dp[k][j - 1] * sum[k + 1][i] (j <= k <= i - 1)
        for(int i = 1; i <= n; i++) dp[i][1] = mod(sum[i]);
        for(int i = 1; i <= n; i++)
            for(int j = 2; j <= k && j <= i; j++)
                for(int k = j; k < i; k++)
                    dp[i][j] = max(dp[i][j], dp[k][j - 1] * mod(sum[i] - sum[k]));
        ans1 = max(ans1, dp[n][k]);
                
        memset(dp, 0x3f, sizeof(dp));
        for(int i = 1; i <= n; i++) dp[i][1] = mod(sum[i]);
        for(int i = 1; i <= n; i++)
            for(int j = 2; j <= k && j <= i; j++)
                for(int k = j; k < i; k++)
                    dp[i][j] = min(dp[i][j], dp[k][j - 1] * mod(sum[i] - sum[k]));
        ans2 = min(ans2, dp[n][k]);
    }
    
    cout << ans2 << endl << ans1;
    return 0;
}
```


至此，希望对你们有帮助。

---

## 作者：九思 (赞：18)

总结一下(加上一点扩展)
1.	经典区间DP： (一加四重循环) 1. 区间左节点d(因为有环，要循环n次)；2. 区间长度r=l+len；3. 区间个数k；4. 区间断点m；5. 左段区间数s。  
`dp[l+d][r+d][k]=max(dp[l+d][m+d][s]*dp[m+d+1][r+d][k-s]);`

2.	压缩线性DP：（一加三重循环）1. 区间左节点d(需要对每个dp数组单独处理)；2. 区间个数k；3. 当前区间长度i；4. 区间断点j。(因为区间连续可以压掉s)  
`dp[i][k]=max(dp[j][k-1]*sum(j+1,i));`

标准版可以一次处理所有情况易上手但耗时耗空间，压缩版需重复初始化但省时，dp数组利用率更高。

Q1：如果把取模结果从非负改成可负怎么做？  
A1：那么最大值可能由正$\times$正或负$\times$负得到，最小值同，所以多加一个判断条件就好了。

Q2：若答案亦取模，大$\times$大$\mod mod <$ 小$\times$小$\mod mod$导致答案错误怎么办？  
A2：那么我们多加一维表示答案(一般这个答案不会让你数组爆掉)，dp数组改为bool类型，将得到的答案推向下一个可以由此达到的答案，以此类推（建议用线性dp） 
```
线性DP版(区间DP题解里面有一堆大佬写，貌似想法都差不多)
f(i,a,b)即for(i=a;i<=b;i++)
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
const int N = 55;
using namespace std;
int n,m,dmax[15][N],dmin[15][N];
int sum[N],a[N],ans,anss=1e9;
int mian() {
	scanf("%d%d",&n,&m);
	f(i,1,n) scanf("%d",&a[i]);
	f(l,0,n-1) {
		memset(dmax,0,sizeof dmax);
		memset(dmin,0,sizeof dmin);
		f(i,1,n)dmin[1][i]=dmax[1][i]=sum[i]=
		(sum[i-1]+a[(i+l-1)%n+1]+10000)%10;
		//cout<<l<<endl;f(i,1,n)cout<<sum[i]<<' ';cout<<endl;
		f(k,2,m) f(i,1,n-m+k) {
			dmin[k][i]=1e9;
			f(j,1,i-1) if(dmin[k-1][j]<1e9) {
				dmax[k][i]=max(dmax[k][i],
				dmax[k-1][j]*((sum[i]-sum[j]+10000)%10));
				dmin[k][i]=min(dmin[k][i],
				dmin[k-1][j]*((sum[i]-sum[j]+10000)%10));
			}
		}
		//f(k,1,m) {f(i,1,n) cout<<dmin[k][i]<<' ';puts("");}
		ans=max(ans,dmax[m][n]);
		anss=min(anss,dmin[m][n]);
	}
	cout<<anss<<endl<<ans;
    return 0;
}
```

---

## 作者：NewbieZZZ (赞：17)

你说得对，但是这是 T2。（

## 解法

区间 DP or 划分 DP。

### 前置部分

（都是小问题，相信你喵。）

首先，又是一圆圈，怎么办？当然是破环成链，把数组复制……等等，可以用队列模拟一个环！每次需要用到队首的时候，取出 Ta，再放回队尾就可以了。~~方便又快捷。~~

维护环的起点，要在**每次循环后，将队首弹出再重新加入队列。**

本题需要用到区间和进行得分计算，所以自然而然地想到维护前缀和。（由于我用了队列模拟环，所以代码里我直接对原数组进行原地前缀和计算，不额外使用空间。）

注：为了防止出现模运算后得到负数得分，我们可以在前缀和计算时利用模运算的性质，去除负数（显然此推论成立）：

> **推论** 若 $a\equiv c\pmod n,b \equiv d\pmod n$，则 $a+c \equiv b+d\pmod n $。

题中要求将总和模 $10$，我们可以给原数加上一个模 $10$ 得 $0$ 的较大值，如加上 $10^8$：`a[i] = (a[i]+100000000) % 10`，这样不影响任何绝对值小于等于 $10^8$ 的整数的得分计算。

### dp 部分

我们可以想到，这道题应该是一个区间 dp。这种 dp 一般是这样解决的：

> 令状态 $f_{i,j}$ 表示将 $[i,j]$ 的所有元素合并能获得的价值的最值，那么 $f_{i,j}=\max / \min\{f_{i,k}+f_{k+1,j}+val\}$，其中 $val$ 为将这两组元素合并起来的价值。

但在这题中，这种状态较难设计。我们不妨直接设 $dp_{i,j}$ 表示将前 $i$ 个数分成 $j$ 个部分，所能达到的最**大**得分。（最小得分为 $f_{i,j}$，同理。）

这样设计状态，我们要先枚举 $j$，后枚举 $i$。这样才能保证无后效性。

（要开始推状态转移方程了哟。）

区间 dp 还有一个思想：枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最值，得到原问题的最值。

在这题中，我们可以将分割点设在第 $j-1$ 个区间与第 $j$ 个区间之间，这样可以方便递推实现。（将前面 $j-1$ 个小区间的得分先计算，再合并到第 $j$ 个区间）

我们可以从小数字中试图寻找普遍规律。（其中 $k(1\le k<i)$ 表示分割点）

$$ \begin{aligned}
dp_{i, 1} = & \max\left\{s_{i} \bmod 10\right\} \\
dp_{i, 2}=&\max\left(dp_{k, 1}\times(s_{i} - s_{k}) \bmod 10 \right)\\
dp_{i, 3}=&\max\left(dp_{k, 2}\times(s_{i} - s_{k}) \bmod 10 \right)\\
\cdots
\end{aligned}$$

我们发现，分成 $j$ 段的价值等价于分成 $j-1$ 段的价值和分割出的第 $j$ 个区间 $[k, i]$ 的价值之和。

即： 

$$dp_{i, j} = \max \left\{dp_{k, j-1} \times\left(s_{i} - s_{k}\right)\bmod 10 \right\}$$

$f_{i,j}$ 同理。

其实，上文的状态表示和方程，主要与划分 dp 有关。我们用区间 dp 的思想，一步一步推出了划分 dp 的一般方程（把模数去掉就是了），可以看出很多类型的 dp 之间是有内在关联的。

---

（啊，推出来了，算你厉害。但你一定忘了什么！）

首先，我们要求最大（小）得分，所以我们要把 dp 数组全部初始化为一个极小（大）值。

$1$ 段的情况怎么办？\
只有一段，得分显然是这一段的和模 $10$ 的绝对值。即 $f_{i,1}=dp_{i,1}=|sum_i \bmod 10|$。（代码里我用了上文处理的方法）

最后，别忘了统计每次 $dp_{n, m}$ 和 $f_{n,m}$ 的最值。

### 代码

（考察你码力的时候到了，操起键盘吧。一切伟大的思想，都有一个微不足道的开始。）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long // 防人之心不可无

int dp[2025][20], a[2025], f[2025][20]; 
int n, m, ans = -1e9, now = 2e9;

signed main(){
    queue<int> q;
    cin >> n >> m;
    for(int i=1; i<=n; ++i){
        cin >> a[i];
        q.push(a[i]);
    }
    for(int _=1; _<=n; ++_){ // 用队列模拟要进行 n 次操作
        for(int i=1; i<=n; ++i) {
            int x = q.front();
            q.pop();
            a[i] = x; // 更新数组
            q.push(x);
        }
        for(int i=0; i<=n; ++i) {
            for(int j=0; j<=m; ++j){
                dp[i][j] = -1e9, f[i][j] = 1e9;
            }
        }
        for(int i=1; i<=n; ++i) { 
            a[i] += a[i-1]; // 原地前缀和
            a[i] = (a[i]+1000000000) % 10;
            f[i][1] = dp[i][1] = (a[i]+1000000000) % 10;
        }
        for(int j=2; j<=m; ++j){
            for(int i=j; i<=n; ++i){
                for(int k=1; k<i; ++k){
                    dp[i][j] = max(dp[i][j], dp[k][j-1] * ((a[i] - a[k] + 1000000000) % 10));
                    f[i][j] = min(f[i][j], f[k][j-1] * ((a[i] - a[k] + 1000000000) % 10));                    
                } // 转移
            }
        }
        ans = max(ans,dp[n][m]);
        now = min(now, f[n][m]); // 统计答案
        int x = q.front();
        q.pop();
        q.push(x); // 更新这个环的状态
    }
    cout << now << '\n' << ans;
    return 0;
}
```

时间复杂度约为 $\Theta(n^3 m)$，空间复杂度为 $\Theta(nm)$。

（唔，写完了，懂了。赶紧给作者点个赞吧。）

### 鸣谢

感谢所有管理大大的审核。

管理员 @[Acoipp](https://www.luogu.com.cn/user/674469) 巨佬指出了本文一处概念性错误！

End.

---

## 作者：YoungNeal (赞：17)

题解从博客看效果更佳~[YoungNeal](www.cnblogs.com/YoungNeal/p/8509976.html)

## Solution

啊这道题好有水平=.=

第一眼看到这题以为是和石子合并一样水的题，但是蛮多细节要注意的(我也是看题解才知道)

定义 $f[0/1][i][j][k]$ 表示左端点在 i，右端点在 j，分成了 k 个部分的最大/最小乘积

最开始做这题开了五层循环，内层枚举了一下断点和断点两侧分别分成了多少个部分...

后来(抄题解)发现了其实不用枚举两侧分成了多少个部分，因为这会被之前或之后的循环枚举到，打个比方：如果枚举到了左端点是 i，右端点是 j，断点是 k，左边分成了p 个部分，右边分成了 q 个部分。                                                                                                   

先明确一下，在合并时，我们只是关注 k+1~j 的前缀和再乘上左边已经乘好的部分， 即   
$f[i][j][p+q]=max{f[i][j][p+q-1]*(qzh[j]-qzh[k])}$    
所以是不用管右边分成了几个部分的，直接假设右边分成了一个部分，然后用左边的区间去“吃”右边的区间就好。
## Code
```
// By YoungNeal 
#include<cstdio>
#include<iostream>
using namespace std;

int n,m;
int qzh[105];
int val[105];
int f[2][105][105][15];

int mod(int x){
    return (x%10+10)%10;
}

signed main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&val[i]),val[i+n]=val[i];
    for(int i=1;i<=(n<<1);i++) qzh[i]=qzh[i-1]+val[i];
    for(int i=1;i<=(n<<1);i++){
        for(int j=i;j<=(n<<1);j++)
            f[0][i][j][1]=f[1][i][j][1]=mod(qzh[j]-qzh[i-1]);
    }
    /*愚蠢的五层循环
　　for(int len=2;len<=(n<<1);len++){
        for(int i=1;i<=(n<<1);i++){
            int j=i+len-1;
            if(j>(n<<1)) break;
            for(int p=i;p<=j;p++){
                for(int k=1;k<=min(m,j-i+1);k++){
                    for(int q=1;q<k;q++){
                        if(q<=p-i+1&&k-q<=j-p)
                            f[i][j][k]=max(f[i][j][k],f[i][p][q]+f[p+1][j][k-q]+(qzh[p]-qzh[i-1])*(qzh[j]-qzh[p]));
                    }
                }
            }
        }
    }*/
    for(int i=2;i<=m;i++){
        for(int l=1;l<=(n<<1);l++){
            for(int r=l+i-1;r<=l+n-1;r++){
                //f[l][r][i]
                f[1][l][r][i]=0x3f3f3f3f;
                for(int k=l+i-2;k<r;k++){  //k不能=r！ 
                    f[0][l][r][i]=max(f[0][l][r][i],f[0][l][k][i-1]*mod(qzh[r]-qzh[k]));
                    f[1][l][r][i]=min(f[1][l][r][i],f[1][l][k][i-1]*mod(qzh[r]-qzh[k]));
                }
            }
        }
    }
    int maxn=0,minn=0x3f3f3f3f;
    for(int i=1;i<=n;i++) maxn=max(maxn,f[0][i][i+n-1][m]),minn=min(minn,f[1][i][i+n-1][m]);
    printf("%d\n%d",minn,maxn);
    return 0;
}
```

---

## 作者：Tomwsc (赞：5)

# P1043 [NOIP 2003 普及组] 数字游戏 题解

建议先完成[能量项链](https://www.luogu.com.cn/problem/P1063)再来做此题。

## 思路

明显的区间 dp。

首先，对于这类环上问题需考虑断环为链，即把原有数组在末尾重新复制一遍，然后进行区间 dp 即可。

区间 dp 必须有的状态为区间的边界，但对于这道题目，这种状态似乎还不够。因为该题要求要把原数组分成 $m$ 个部分，所以不妨再引入一个状态，表示现在这个区间里一共有多少个部分。于是，现在 dp 数组的状态设计出来了。

设 $dp_{l,r,i}$ 表示现在 dp 到的区间的左右边界为 $l$ 与 $r$ 并且该区间被分成了 $i$ 个部分。

接下来开始推状态转移方程：

对于这类区间 dp 问题，有一个很常用的转移方程：

$$dp_{l,r}=\min(dp_{l,r} , dp_{l,k - 1} + dp_{k,r} + val)$$

$$dp_{l,r}=\max(dp_{l,r} , dp_{l,k - 1} + dp_{k,r} + val)$$

其中，$val$ 是贡献，但在这题并不需要，$k$ 则是区间 $l$ 到 $r$ 之间的一个点，是用来合并区间的。不过，此题还要再引入一个状态，所以还需要枚举此时区间由多少个部分组成，并且枚举的中间点又把区间分割成了两个区间，所以还要枚举那两个区间分别又是由多少个部分组成的。于是得到状态转移方程为：

$$dp_{l,r,i} = \min(dp_{l,r,i},dp_{l,k-1,j}\times dp_{k,r,i-j})$$

$$dp_{l,r,i} = \max(dp_{l,r,i},dp_{l,k-1,j}\times dp_{k,r,i-j})$$

$j$ 便是枚举的被合并的两个区间被分成的份数。

不难发现，对于 $i=1$ 的情况，不好在循环中处理（因为是加法），所以不妨在枚举中间转折点时单独拿出来处理。即：

$$dp_{l,r,1}=\min(dp_{l,r,1},(dp_{l,k-1,1}+dp_{k,r,1})\bmod 10)$$

$$dp_{l,r,1}=\max(dp_{l,r,1},(dp_{l,k-1,1}+dp_{k,r,1})\bmod 10)$$

最后，讲一下 dp 数组的初始化，对于每个长度为 $1$ 的区间，进行单独赋值即可。

## 代码

时间复杂度：$O(n^3\times m^2)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf (1ll << 62)
#define regint register int
#define pb push_back
#define mp make_pair
#define PII pair<int , int>
using namespace std;
const int MAXN = 105 , MAXM = 10 , c = 1e4 + 10;
int n , m;
int a[MAXN] , dp1[MAXN][MAXN][MAXM] , dp2[MAXN][MAXN][MAXM];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	memset(dp1 , 0x7f , sizeof(dp1));
	memset(dp2 , 0xcf , sizeof(dp2));
	cin >> n >> m;
	for(regint i = 1;i <= n;i ++) {
		cin >> a[i];	
		dp1[i][i][1] = dp2[i][i][1] = (a[i] + c) % 10;
	}
	for(regint i = n + 1;i <= 2 * n - 1;i ++) {
		a[i] = a[i - n];
		dp1[i][i][1] = dp2[i][i][1] = (a[i] + c) % 10; 
	}
	for(regint len = 1;len <= n;len ++)
		for(regint l = 1;l + len - 1 <= 2 * n - 1;l ++) {
			int r = l + len - 1;
			for(regint k = l + 1;k <= r;k ++) {
				dp1[l][r][1] = min(dp1[l][r][1] , (dp1[l][k - 1][1] + dp1[k][r][1] + c) % 10);
				dp2[l][r][1] = max(dp2[l][r][1] , (dp2[l][k - 1][1] + dp2[k][r][1] + c) % 10);
				for(regint i = 2;i <= m;i ++)
					for(regint j = 1;j < i;j ++) {
						if(dp1[l][k - 1][j] < 1e9 && dp1[k][r][i - j] < 1e9)
							dp1[l][r][i] = min(dp1[l][r][i] , dp1[l][k - 1][j] * dp1[k][r][i - j]);
						if(dp2[l][k - 1][j] > -1e9 && dp2[k][r][i - j] > -1e9)
							dp2[l][r][i] = max(dp2[l][r][i] , dp2[l][k - 1][j] * dp2[k][r][i - j]);
					}
				
			}	
		}
	int ans1 = inf , ans2 = -inf;
	for(regint i = 1;i <= n;i ++) {
		ans1 = min(ans1 , dp1[i][i + n - 1][m]);
		ans2 = max(ans2 , dp2[i][i + n - 1][m]);
	}
	cout << ans1 << '\n' << ans2 << '\n';
	return 0;
}
```

---

## 作者：chrispang (赞：3)

## 题目大意

将给定的 $n$ 个整数按顺序分为 $m$ 个部分，计算每部分数字之和并对 $10$ 取模，然后将这些模值相乘，得到一个结果 $k$。目标是求出 $k$ 的最大值和最小值。

## 题目分析

本题需要使用区间 DP 解决。

但是，这是一个环，因此我们首先断环为链。

```cpp
for (int i = 1; i <= n; i++) cin >> a[i];
for (int i = n + 1; i <= 2 * n - 1; i++) a[i] = a[i - n];
```

由于我们的答案要输出两个值，因此我们要搞两个 DP 数组。其中，`dp1` 表示最小值，`dp2` 表示最大值。

- 状态：`dp1[i][j][k]` 表示区间 $i\sim j$ 中，分割为 $k$ 个区间，得到的答案最小值。`dp2[i][j][k]` 同理。

- 状态转移方程：

> 枚举区间长度 $len$，接着枚举区间右端点 $r$，通过区间长度与区间右端点算出区间左端点 $l$。
>
> 在 $l\sim r$ 中枚举区间分割点 $k$，接着枚举分割区间总数 $q$，在枚举区间总数的基础上继续枚举 $k$ 左边被分割了 $j$ 个区间。
>
> 因此，可得 $dp1_{i,j,q}=\min\{dp1_{l,k-1,j}\times dp1_{k,r,q-j}\}$，`dp2` 同理。
>
> 但是，因为 $q=1$ 的情况需要加法，不好在上述的方程中进行处理。因此，我们把 $q=1$ 的情况进行单独处理即可。

- 初始化：$dp1_{i,i,1}=dp2_{i,i,1}=a_i\bmod 10$。
- 答案：$\min\{dp1_{i,i+n-1,m}\},\max\{dp2_{i,i+n-1,m}\}$。

## 代码实现

```cpp
#include <bits/stdc++.h>
#define int long long // 养成好习惯
#define maxn 110
#define maxm 15
#define lsy 100000 // 为了防止负数 % 10 还是负数的情况，需要加上一个相对题目数据来说较大的一个 10 的倍数的数
using namespace std;

int n, m;
int ans1 = 1e9, ans2 = -1e9;
int a[maxn], dp1[maxn][maxn][maxm], dp2[maxn][maxn][maxm];
signed main() {
	memset(dp1, 0x3f, sizeof(dp1)); // 初始化为正无穷
	memset(dp2, -0x3f, sizeof(dp2)); // 初始化为负无穷
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];	
		dp1[i][i][1] = dp2[i][i][1] = (a[i] + lsy) % 10; // 初始化 DP
	}
	for (int i = n + 1; i <= 2 * n - 1; i++) {
		a[i] = a[i - n]; // 断环为链
		dp1[i][i][1] = dp2[i][i][1] = (a[i] + lsy) % 10; // 初始化 DP
	}
	for (int len = 1; len <= 2 * n - 1; len++) // 枚举区间长度
		for (int r = len; r <= 2 * n - 1; r++) { // 枚举右端点
		    int l = r - len + 1; // 算出左端点
			for (int k = l + 1; k <= r; k++) {
                // 单独处理 q = 1 的情况
				dp1[l][r][1] = min(dp1[l][r][1], (dp1[l][k - 1][1] + dp1[k][r][1] + lsy) % 10);
				dp2[l][r][1] = max(dp2[l][r][1], (dp2[l][k - 1][1] + dp2[k][r][1] + lsy) % 10);
				for (int q = 2; q <= m; q++) // 从 2 开始枚举
					for (int j = 1; j < q; j++) { // 枚举左区间分到的区间数
						if (dp1[l][k - 1][j] < 1e9 && dp1[k][r][q - j] < 1e9)
							dp1[l][r][q] = min(dp1[l][r][q] , dp1[l][k - 1][j] * dp1[k][r][q - j]);
						if (dp2[l][k - 1][j] > -1e9 && dp2[k][r][q - j] > -1e9)
							dp2[l][r][q] = max(dp2[l][r][q] , dp2[l][k - 1][j] * dp2[k][r][q - j]);
					}
			}	
		}
    // 找答案
	for (int i = 1; i <= n; i++) {
		ans1 = min(ans1, dp1[i][i + n - 1][m]);
		ans2 = max(ans2, dp2[i][i + n - 1][m]);
	}
	cout << ans1 << endl;
	cout << ans2 << endl;
	return 0;
}
```

## 总结

这次的区间 DP 其实不同于往常，比较新颖，状态的思考有点难度，是一道不错的题目。

最后只有一句话：点个赞吧！球球啦！

---

## 作者：ryderyang (赞：2)

经过本蒟蒻无数次的提交，我用深搜 AC 这道题了！
# 解题思路
我们可以把写 $2$ 个深搜，分别用来求最大值和最小值。设 $dfs(id,last)$ 表示现在要处理第 $id$ 个数，上一个数字是放在第 $last$ 个区块里面。那么，我们就可以很轻松地写出程序了。但是有个细节，如果 $step=n$，他也可以放在第 $1$ 个区块，因为他是一个环形的。

这个程序虽然会超时，但是只有第 $4$ 个数据超时了，也能获得 $80$ 分的好成绩。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[51],sum[10],ans_max=INT_MIN,ans_min=INT_MAX;
bool flag[10];
int mod10(int x)
{
	return ((x%10)+10)%10;
}
void dfs1(int id,int last)
{
	int ans=1;
	for(int i=1;i<=m;i++)
	{
		if(flag[i])
		{
			ans*=mod10(sum[i]);
		}
	}
	if(id==n+1)
	{
		if(sum[m]!=0)
		ans_min=min(ans_min,ans);
		return;
	}
	if(id==1)
	{
		flag[1]=true;
		sum[1]=a[1];
		dfs1(2,1);
	}
	else
	{
		sum[last]+=a[id];
		dfs1(id+1,last);
		sum[last]-=a[id];
		if((last+1)<=m)
		{
			sum[last+1]+=a[id];
			flag[last+1]=true;
			dfs1(id+1,last+1);
			sum[last+1]-=a[id];
			flag[last+1]=false;
		}
		if(id==n)
		{
			sum[1]+=a[n];
			dfs1(n+1,1);
			sum[1]-=a[n];
		}
	}
}
void dfs2(int id,int last)
{
	int ans=1;
	for(int i=1;i<=m;i++)
	{
		if(flag[i])
		{
			ans*=mod10(sum[i]);
		}
	}
	if(id==n+1)
	{
		if(sum[m]!=0)
		ans_max=max(ans_max,ans);
		return;
	}
	if(id==1)
	{
		flag[1]=true;
		sum[1]=a[1];
		dfs2(2,1);
	}
	else
	{
		sum[last]+=a[id];
		dfs2(id+1,last);
		sum[last]-=a[id];
		if((last+1)<=m)
		{
			sum[last+1]+=a[id];
			flag[last+1]=true;
			dfs2(id+1,last+1);
			sum[last+1]-=a[id];
			flag[last+1]=false;
		}
		if(id==n)
		{
			sum[1]+=a[n];
			dfs2(n+1,1);
			sum[1]-=a[n];
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	dfs1(1,0);
	for(int i=1;i<=m;i++)
	{
		sum[i]=0;
		flag[i]=false;
	}
	dfs2(1,0);
	printf("%d\n%d",ans_min,ans_max);
	return 0;
}
```

最优性剪枝：求最大值时，如果当前的最优可能，也不如 $ansmax$，直接返回。最优可能是什么呢？就是把不确定的算出 $9$。要注意的是，第 $last$ 个要算成 $9$，因为它还没结束，只是开始了。第 $1$ 个区块也要算成 $9$，因为它后面可能因第 $n$ 个数字而变化。当然，我们可以用同样的方法来对求最小值的深搜剪枝。

$100$ 分代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[51],sum[10],ans_max=INT_MIN,ans_min=INT_MAX;
bool flag[10];
int mod10(int x)
{
	return ((x%10)+10)%10;
}
void dfs1(int id,int last)
{
	int ans=1,cnt=1;
	for(int i=1;i<=m;i++)
	{
		if(flag[i])
		{
			if(i!=1&&i!=last)
			cnt*=mod10(sum[i]);
			ans*=mod10(sum[i]);
		}
	}
	if(cnt>=ans_min)
	return;
	if(id==n+1)
	{
		if(sum[m]!=0)
		ans_min=min(ans_min,ans);
		return;
	}
	if(id==1)
	{
		flag[1]=true;
		sum[1]=a[1];
		dfs1(2,1);
	}
	else
	{
		sum[last]+=a[id];
		dfs1(id+1,last);
		sum[last]-=a[id];
		if((last+1)<=m)
		{
			sum[last+1]+=a[id];
			flag[last+1]=true;
			dfs1(id+1,last+1);
			sum[last+1]-=a[id];
			flag[last+1]=false;
		}
		if(id==n)
		{
			sum[1]+=a[n];
			dfs1(n+1,1);
			sum[1]-=a[n];
		}
	}
}
void dfs2(int id,int last)
{
	int ans=1,cnt=1;
	for(int i=1;i<=m;i++)
	{
		if(flag[i])
		ans*=mod10(sum[i]);	
	}
	for(int i=1;i<=m;i++)
	{
		if(i==1||flag[i]==false||i==last)
		cnt*=9;
		else
		cnt*=mod10(sum[i]);
	}
	if(cnt<=ans_max)
	return;
	if(id==n+1)
	{
		if(sum[m]!=0)
		ans_max=max(ans_max,ans);
		return;
	}
	if(id==1)
	{
		flag[1]=true;
		sum[1]=a[1];
		dfs2(2,1);
	}
	else
	{
		sum[last]+=a[id];
		dfs2(id+1,last);
		sum[last]-=a[id];
		if((last+1)<=m)
		{
			sum[last+1]+=a[id];
			flag[last+1]=true;
			dfs2(id+1,last+1);
			sum[last+1]-=a[id];
			flag[last+1]=false;
		}
		if(id==n)
		{
			sum[1]+=a[n];
			dfs2(n+1,1);
			sum[1]-=a[n];
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	dfs1(1,0);
	for(int i=1;i<=m;i++)
	{
		sum[i]=0;
		flag[i]=false;
	}
	dfs2(1,0);
	printf("%d\n%d",ans_min,ans_max);
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

一道区间 dp。

题意：将一个环中的所有数分成 $m$ 份，每份对 $10$ 取模后（结果要为正），求相乘后的最小值和最大值。

对于环的处理，将环变成两倍的链枚举起点。这样对于每个起点都有一个长度为 $n$ 的序列。

设 $f_{i, j}$ 表示将这 $j$ 个数分成 $i$ 份的最大值。

先从小到大枚举起点 $i$，再从小到大枚举划分的组数 $j$，然后从小到大枚举个数 $k$，最后枚举一个分界点 $l$，从 $1$ 到 $l$ 和 $l+1$ 到 $k$ 这两个区间转移，此时 $1$ 到 $l$ 的取值就是 $f_{j-1, l}$，$l+1$ 到 $k$ 的取值就是序列上这个区间的和，可以用前缀和预处理。

那么转移就是 $f_{i, j}=\max(f_{i, j}, (S_{k+i}-S_{l+i}) \times f_{j-1, l})$。$S$ 是前缀和数组。

最小值是完全一样的。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, mx, mi=1e9, a[105], s[55], f1[55][55], f2[55][55];
int mod (int x) { return (x%10+10)%10; }
int main () {
    cin >> n >> m;
    for (int i=1; i<=n; ++i)
    	cin >> a[i],
    	a[i+n]=a[i];
    for (int i=1; i<n*2; ++i)
    	s[i]=s[i-1]+a[i];
    for (int i=0; i<n; ++i) {
		memset(f1, 1, sizeof f1);
		memset(f2, 0 ,sizeof f2);
    	for (int j=1; j<=n; ++j)
			f1[1][j]=f2[1][j]=mod(s[j+i]-s[i]);
		for (int j=2; j<=m; ++j)
			for (int k=j; k<=n; ++k)
				for (int l=1; l<=k-1; ++l)
					f1[j][k]=min(f1[j][k], mod(s[k+i]-s[l+i])*f1[j-1][l]),
					f2[j][k]=max(f2[j][k], mod(s[k+i]-s[l+i])*f2[j-1][l]);
		mi=min(mi, f1[m][n]);
		mx=max(mx, f2[m][n]);
	}
    cout << mi << '\n' << mx;
    return 0;
}
```

---

## 作者：__czh__ (赞：2)

本题是一道较为简单的区间 dp 题，不过要多一维有关于 $m$ 的统计。下面附上正文：

题目中将一个圆中的数化划为 $m$ 块，求各区间和取模 $10$ 后的乘积最大值及最小值。实际上就是将一个数环上的数分为 $m$ 个区间后求值。我们可以断环为链，用区间 dp 求解。用数组 $dp_{i,j,k}$ 递推，表示当前 $i$ 到 $j$ 的区间内分为 $k$ 段数时的最值。递推公式为：$dp_{i,j,k} \gets \max( dp_{i,j,k} , dp_{i,l,k-1} + dp_{l+1,j,1} )$。即枚举 $i$ 到 $j$ 区间中 $1$ 到 $l$ 区间分 $k-1$ 段的最值并上 $l+1$ 到 $j$ 的区间和的最值。

下附代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1055,M=15;
long long n,m,a[N],dp[N][N][M],dp2[N][N][M],mod=10,sum[N],ans1,ans2=INT_MAX;//记得开long long
//dp统计最大值，dp2统计最小值
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}//快读
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=a[i+n]=read();
		sum[i]=sum[i-1]+a[i];//前缀和
	}
	for(int i=n+1;i<=(n<<1);i++)sum[i]=sum[i-1]+a[i];//前缀和
	for(int i=1;i<=(n<<1);i++){
		for(int j=i;j<=(n<<1);j++){
			for(int k=1;k<=m;k++){
				dp2[i][j][k]=1000000000;//赋最大值
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j-i+1<=n;j++){
			dp[i][j][1]=(sum[j]-sum[i-1]+1000000000)%mod;
			dp2[i][j][1]=(sum[j]-sum[i-1]+1000000000)%mod;//赋初值
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j-i+1<=n;j++){
			for(int k=2;k<=m;k++){
				for(int l=i;l<j;l++){
					dp[i][j][k]=max(dp[i][j][k],dp[i][l][k-1]*dp[l+1][j][1]);
					dp2[i][j][k]=min(dp2[i][j][k],dp2[i][l][k-1]*dp2[l+1][j][1]);//递推
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans1=max(dp[i][i+n-1][m],ans1);
		ans2=min(dp2[i][i+n-1][m],ans2);//统计答案
	}
	cout<<ans2<<'\n'<<ans1;
	return 0;
}
```

---

## 作者：Noah03 (赞：1)

### 题意

---

有一个圆圈，在圆圈上首尾相接的放着 $n$ 个数，现在让你按顺序将这些数分成 $m$ 个部分，把每个部分内的数字相加，将这 $m$ 个结果相乘并模 $10$，得到最终结果 $k$，现在给你 $n,m$ 和 $n$ 个整数，求最大和最小的 $k$。

### 分析

---

看到题目，先想到了 DFS，但是对于题目的数据范围会直接爆炸。可以使用**动态规划，DP** 的方法来做这道题。

但是题目中的数字是一条环，怎么办呢？我们可以把这条环拉直，形成一条长为 $2 \times n$ 的**链**。那我们令 $dp_{i,j,len}$ 为从第 $i$ 个数开始，第 $j$ 个数结束，分成了 $len$ 段。当然，结合题目要求，我们把 $dp$ 数组拆成 $Max$ 数组和 $Min$ 数组（$Max$ 表示最大，$Min$ 表示最小）。我们在枚举 $i,j,len$ 后还要枚举一个变量 $k$，表示我们在哪里分割。所以动态转移方程为：
$$Max_{i,j,len}=\max\{Max_{i,j,len},Max_{i,k,len-1} \times Max_{k+1,j,1}\}
$$

$$Min_{i,j,len}=\min\{Min_{i,j,len},Min_{i,k,len-1} \times Min_{k+1,j,1}\}$$

边界条件呢？当 $len=1$ 时，只分成一段，也就是 $dp_{i,j,1}=\sum_{k=j}^{i}a_k \ \bmod 10$。

### 代码

---

下面给出代码。

Code:
```cpp
//The Code is From @Noah03(Luogu User Name),Do Not Copy!!!
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll a[60],s[110],Max[110][110][15],Min[110][110][15];
int main(){
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		s[i]=s[i-1]+a[i]; //前缀和
	}
	for(int i=n+1;i<=(n<<1);i++) s[i]=s[i-1]+a[i-n]; //化环为链
	for(int i=1;i<=110;i++) for(int j=1;j<=110;j++) for(int k=1;k<=10;k++) Min[i][j][k]=1e12; //初始化 
	for(int i=1;i<=(n<<1);i++)
		for(int j=1;j<=(n<<1);j++)
			Max[i][j][1]=Min[i][j][1]=(s[j]-s[i-1]+1000000000)%10;
    //负数取模可能会出现负数，先加上一个极大值
	for(int i=1;i<=(n<<1);i++)
		for(int j=i+1;j<=(n<<1);j++)
			for(int len=2;len<=m;len++)
				for(int k=i;k<j;k++){
					Max[i][j][len]=max(
					Max[i][j][len],
					Max[i][k][len-1]*
					Max[k+1][j][1]);
					Min[i][j][len]=min(
					Min[i][j][len],
					Min[i][k][len-1]*
					Min[k+1][j][1]);
                    //动态转移方程
				}
	ll ans1=0,ans2=1e18;
	for(int i=1;i<=n;i++){
		ans1=max(ans1,Max[i][i+n-1][m]); //取最大值
		ans2=min(ans2,Min[i][i+n-1][m]); //取最小值
	}
	printf("%lld\n%lld\n",ans2,ans1);
	return 0; //结束
}
```

---

## 作者：lkjlkjlkj2012 (赞：0)

### 思路
看到这题，本蒟蒻立马想到了深搜。首先断环成链。我们设 $dp_{i,j,sum}$ 表示考虑第 $i$ 部分，起点为 $j$，前 $i-1$ 部分的答案为 $sum$。如果 $i = m$，我们必须选剩余所有数字，更新答案即可；如果 $i \ne m$，我们可以枚举第 $i$ 部分的结束点，并统计进答案。

但是这样还是过不去，我们考虑剪枝：如果当前答案大于等于当前最小答案；且如果就算后面部分和都是 $9$，当前答案也小于等于当前最大答案，那么就没有考虑的必要了。最后注意我们还要枚举第一部分的起点。这样就做完了。

但是，为什么这个剪枝是正确的呢，比如后面有一部分和为 $0$，“当前答案大于等于当前最小答案”不就错了吗？其实不是，我们在枚举第 $1$ 部分起点时，一定能枚举到这一个和为 $0$ 的部分的起点，这样就能统计到这个 $0$ 的答案，正确性得到保证
### 代码

```cpp
// Problem: P1043 [NOIP2003 普及组] 数字游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1043
// Memory Limit: 125 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
using namespace std;
const int p9[10] = {1,     9,      81,      729,      6561,
                    59409, 531441, 4782969, 43046721, 387420489};
int n, m, a[105], ansmin = 0x3f3f3f3f, ansmax = 0;
int m10(int x) { return (x % 10 + 10) % 10; }
void dp(int i, int j, int num) {
  if (num >= ansmin && num * p9[m - i + 1] <= ansmax) return;
  int sum = 0;
  if (i == m) {
    for (int k = j; k <= (n - m + i); k++) sum += a[k];
    ansmin = min(ansmin, num * m10(sum));
    ansmax = max(ansmax, num * m10(sum));
    return;
  }
  for (int k = j; k <= (n - m + i); k++) {
    sum += a[k];
    dp(i + 1, k + 1, num * m10(sum));
  }
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i], a[i + n] = a[i];
  for (int i = 1; i <= n; i++) {
    dp(1, 1, 1);
    for (int j = 1; j <= 2 * n; j++) a[j] = a[j + 1];
  }
  cout << ansmin << endl << ansmax;
  return 0;
}
```

---


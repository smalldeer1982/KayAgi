# [NOIP 2012 普及组] 文化之旅

## 题目背景

本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。

本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

## 题目描述

有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。

现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。

## 说明/提示

### 输入输出样例 1 说明

由于到国家 $2$ 必须要经过国家 $1$，而国家 $2$ 的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。


### 输入输出样例 2 说明

路线为 $1\to 2$。

### 数据范围

对于 $100\%$ 的数据，有：

- $2 \le N \le 100$
- $1 \le K \le 100$
- $1 \le M \le N^2$
- $1 \le k_i \le K$
- $1 \le u,v \le N$
- $1 \le d \le 1000$
- $1 \le S,T \le N$
- $S \ne T$

NOIP2012 普及组第四题

## 样例 #1

### 输入

```
2 2 1 1 2 
1 2 
0 1 
1 0 
1 2 10 
```

### 输出

```
-1```

## 样例 #2

### 输入

```
2 2 1 1 2 
1 2 
0 1 
0 0 
1 2 10 ```

### 输出

```
10```

# 题解

## 作者：Created_equal1 (赞：136)

感觉许多题解都是依靠数据水才过的。。

我觉得正解应该是启发式搜索

首先跑一遍无视文化排斥的最短路。容易证明，无视文化排斥最短路的答案一定不大于考虑文化排斥的答案。

这样就可以用一个很强的剪枝了。

如果当前到的这个点的花费加上从这个点出发到终点的无视文化排斥的最短路的花费比答案还要大，那么就没有继续往下搜索的意义了——剪枝。










    
    


    
    
        
    

        
        
    
    
    
    
    
```cpp
#include <set>
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const size_t Max_NK(105);
const size_t Max_M(20050);
size_t N;
size_t K;
unsigned int M;
size_t Total;
size_t S, T;
unsigned int u, v, d;
unsigned int Head[Max_NK];
unsigned int To[Max_M];
unsigned int Weight[Max_M];
unsigned int Next[Max_M];
unsigned int C[Max_NK];
bool A[Max_NK][Max_NK];//A[i][j]若为true表示i排斥j 
unsigned int Dist[Max_NK];
bool In_Q[Max_NK];
void Spfa()
{
    memset(Dist, 0X7F, sizeof(Dist));
    queue<unsigned int> Q;
    Q.push(S);
    In_Q[S] = true;
    Dist[S] = 0;
    unsigned int Top;
    while (Q.size())
    {
        Top = Q.front();
        Q.pop();
        In_Q[Top] = false;
        for (size_t i = Head[Top];i;i = Next[i])
            if (Dist[To[i]] > Dist[Top] + Weight[i])
            {
                Dist[To[i]] = Dist[Top] + Weight[i];
                if (!In_Q[To[i]])
                {
                    In_Q[To[i]] = true;
                    Q.push(To[i]);
                }
            }
    }
}
unsigned int Ans(0X7F7F7F7FU);
bool Went[Max_NK];
set<unsigned int> culture;
bool check(const unsigned int &cl)
{
    for (set<unsigned int>::const_iterator iter = culture.begin();
        iter != culture.end();++iter)
        if (A[*iter][cl])
            return false;
    return true;
}
void Dfs(const size_t &Now, const unsigned int &D)
{
    Went[Now] = true;
    culture.insert(C[Now]);
    if (Now == S)
    {
        Ans = min(Ans, D);
        return;
    }
    if (D + Dist[Now] > Ans)
        return;
    for (size_t i = Head[Now];i;i = Next[i])
        if (!Went[To[i]] && check(C[To[i]]))
            Dfs(To[i], D + Weight[i]);
    Went[Now] = false;
    culture.erase(C[Now]);
}
int main()
{
    scanf("%u%u%u%u%u", &N, &K, &M, &S, &T);
    for (size_t i = 1;i <= N;++i)
        scanf("%u", C + i);
    for (size_t i = 1;i <= K;++i)
        for (size_t j = 1;j <= K;++j)
            scanf("%d", &A[i][j]);
    while (M--)
    {
        scanf("%u%u%u", &u, &v, &d);
        ++Total;
        To[Total] = v;
        Weight[Total] = d;
        Next[Total] = Head[u];
        Head[u] = Total;
        ++Total;
        To[Total] = u;
        Weight[Total] = d;
        Next[Total] = Head[v];
        Head[v] = Total;
    }
    Spfa();
    if (Dist[T] == 0X7F7F7F7FU)
    {
        printf("-1");
        return 0;
    }
    Dfs(T, 0);
    if (Ans == 0X7F7F7F7FU)
        printf("-1");
    else
        printf("%u", Ans);
    return 0;
}
```

---

## 作者：wjyyy (赞：40)

这个题是普及组少见的图论题，因为数据范围是$n\le100$，所以求最短路时可以用Floyd，比较方便。

一开始我做这个题时感觉这个排斥可以用并查集处理，因为访问过的文化不会再访问一遍，也相当于排斥了。但是题目中提到了i文化排斥j但j文化不一定排斥i，这样并查集的方法就无效了。

所以我们要在最短路上找突破口，就是对在路上经过的点所拥有的文化进行标记。加上几种判断并转移，我做的方法是复杂度$<O(N^4)$的，因此这个题$N\le100$的数据基本是能过的，~~（Floyd的常数当然是1了）当然了，if判断惩罚另说~~，实际上跑了52ms。



------------

### 对Floyd插点做标记的解释

因为Floyd是插点找最短路，所以每次状态都会被记录，插的点的文化就会被记录在这条路里，比如若在i，j中插入k时没有矛盾且满足最短路，那么

```cpp
for(int t=1;t<=n;t++)
    used[i][j][t]=used[i][k][t]||used[k][j][t];//任意一个为1则值为1
        used[i][j][c[k]]=true;
            f[i][j]=f[i][k]+f[k][j];
```

将两条路上的信息合并并更新k的信息，就可以得到新路径的值。

## Code：

```cpp
#include<cstdio>
#include<cstring>
int min(int x,int y){return x<y?x:y;}

int c[105],n;//c数组存文化种类
int a[105][105];//a数组存是否排斥
int f[105][105];//f数组存路径长度
bool used[105][105][105];//i,j,k表示i向j的边经过了文化k
void floyd()//求最短路并判断是否排斥或重复
{
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(!a[c[k]][c[i]]&&!a[c[j]][c[k]]&&!used[i][k][c[j]]&&!used[k][j][c[i]]&&f[i][k]+f[k][j]<f[i][j])
                {
                    for(int t=1;t<=n;t++)
                        used[i][j][t]=used[i][k][t]||used[k][j][t];//有一个式子为真则表达式值为真
                    used[i][j][c[k]]=true;
                    f[i][j]=f[i][k]+f[k][j];
                }
}
int main()
{
    memset(f,0x3f,sizeof(f));
    int k,m,s,t,u,v,w;
    scanf("%d%d%d%d%d",&n,&k,&m,&s,&t);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&c[i]);
        f[i][i]=0;//最短路初始化
    }
    for(int i=1;i<=k;i++)
        for(int j=1;j<=k;j++)
            scanf("%d",&a[i][j]);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        if(!a[c[v]][c[u]]&&c[u]!=c[v])//如果两个点排斥或文化相同则不能连边
            f[u][v]=min(w,f[u][v]);//两个点之间不止一条路
        if(!a[c[u]][c[v]]&&c[u]!=c[v])
            f[v][u]=min(w,f[v][u]);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            used[i][j][c[i]]=true;//初始化条件
            used[i][j][c[j]]=true;
        }
    floyd();
    if(f[s][t]==0x3f3f3f3f)
        printf("-1\n");//不能到达
    else
        printf("%d\n",f[s][t]);
    return 0;
}

```

---

## 作者：赵晨洋 (赞：24)

/\*
深搜，倒着跑一遍spfa，用于最优解剪枝，不用倒着搜或者特殊处理，倒着搜不是也是看了数据 才发现倒着要快些的吗

\*/
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,k,m,s,t,ans=100000000,cnt=0;
int c[200];
int vis[200][200];
int visit[200];
struct node{
    int to,next,value;
}e[20000];
int head[200];
int que[100000],qh=0,qt=0;
bool inq[1000];
int dist[1000];
void add(int u,int v,int w)
{
    e[++cnt].to=v;
    e[cnt].value=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}
void spfa()
{
    memset(dist,0x7f7f7f,sizeof(dist));
    dist[n]=0;
    que[++qt]=n;
    while(qh<qt)
    {
        int p=que[++qh];
        inq[p]=false;
        for(int i=head[p];i;i=e[i].next)
        {
            if(dist[e[i].to]>dist[p]+e[i].value)
            {
                dist[e[i].to]=dist[p]+e[i].value;
                if(!inq[e[i].to])
                {
                    inq[e[i].to]=true;
                    que[++qt]=e[i].to;
                }
            } 
        }
    }
}
void dfs(int u,int step)
{
    bool pp=false;
    if(u==t)
    ans=min(ans,step);
    if(step>=ans)
    return;
    visit[c[u]]=true;
    for(int i=1;i<=k;i++)
    if(vis[i][c[u]]) visit[i]=true;
    for(int i=head[u];i;i=e[i].next)
    {
        if(!visit[c[e[i].to]]&&!vis[c[t]][c[e[i].to]]&&((e[i].to!=t&&c[e[i].to]!=c[t])||e[i].to==t)&&step+e[i].value+dist[e[i].to]<ans)//最后一个剪枝很重要，如果当前的值加上以后不考虑文化冲突到达终点的最短路比答案大的话就不搜索了 
        pp=true,dfs(e[i].to,step+e[i].value);
    }
    if(!pp)
    visit[c[u]]=false;
    for(int i=1;i<=k;i++)
    if(vis[c[u]][i]) visit[i]=false;
}
int main()
{
    scanf("%d%d%d%d%d",&n,&k,&m,&s,&t);
    for(int i=1;i<=n;i++)
    scanf("%d",&c[i]);
    for(int i=1;i<=k;i++)
    for(int j=1;j<=k;j++)
    scanf("%d",&vis[i][j]);
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w),add(v,u,w);
    }
    spfa();
    dfs(s,0); 
    if(ans==100000000) printf("-1");
    else printf("%d",ans);
}
```

---

## 作者：fishfree88 (赞：14)

作为一个蒟蒻（第一次在题解里发帖哈，多多包涵），表示这道题目其实（应该）没有想象中的难，一个DFS加简单的剪枝应该就能过。
首先说一下剪枝。对于国家i、j间的多条路径，可以在输入时就直接取其中距离最短的路径，把其它路径直接扔掉。显然这种方法对于求最优解无影响，且得到的总距离也较小。接下来假设一条路径可经过国家i到达终点t（且该路径距离最短），很显然s到i的路径也是最短的，i到t的路径也是最短的，故建立一数组sum[i]来表示到达国家i的最短路径，当dfs到国家i时若此时的总距离>=sum[i]，则直接结束递归，这样可以大幅减小时间复杂度（相应的，也不用单独建立数组确认国家i是否已走过）。
然后是判断部分。这一部分很烦，需要慢慢来。首先建立一个数组存储旅行者已经学习过的所有文化（我太弱了，于是手写了vector），然后再准备前往国家i前进行检测就行了。注意国家i的文化不能与已学习的任何一种文化相同或排斥。
显然任和一条路径的长度均>0，故只要查看路径长度就能判断两个国家间是否有路径。
下面是我的代码，写的不怎么样，大佬们轻喷~
（注：p数组为国家i、j间的（最短）路径长度，h数组为文化i排斥文化j（注意，排斥是单向的），c数组为国家i的文化，bag数组为旅行者已学习的文化，sum数组为到达国家i的最短路径长度。）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,s,t,u,v,d,flag,flag2,cnt;
int c[105],h[105][105],p[105][105],sum[105],bag[105];
int dfs(int l,int dis){
	if(dis>=sum[l])return 0;
	sum[l]=dis;
	if(l==t){
		flag=1;
		return 0;
	}
	for(int i=1;i<=n;i++){
		if(p[l][i]>0){
			flag2=1;
			for(int j=1;j<=cnt;j++)if(h[c[i]][bag[j]]==1||c[i]==bag[j])flag2=0;
			if(flag2==1){
			    cnt++;bag[cnt]=c[i];
			    dfs(i,dis+p[l][i]);
			    cnt--;
			}
		}
	}
	return 0;
}
int main(){
    for(int i=1;i<=100;i++)sum[i]=100000000;
	cin>>n>>k>>m>>s>>t;
	for(int i=1;i<=n;i++)cin>>c[i];
	for(int i=1;i<=k;i++)for(int j=1;j<=k;j++)cin>>h[i][j];
	for(int i=1;i<=m;i++){
		cin>>u>>v>>d;
		if(u>v)swap(u,v);
		if(p[u][v]==0||d<p[u][v])p[u][v]=d;
		p[v][u]=d;
	}
	cnt=1;bag[1]=c[s];
	dfs(s,0);
	if(flag==1)cout<<sum[t]<<endl;
	else cout<<-1<<endl;
	return 0;
}
```

---

## 作者：tommymio (赞：12)

这是本蒟蒻第一篇题解。~~因为本蒟蒻从来没有过好的想法。~~

言归正传，在我看来，这道题就是道模板题，不知道为什么被划为绿题

~~（可能因为我太强了吧）~~

数据很水，~~我刚开始没加相同文化不能走的判断还A了10个点~~

本题有几个坑点，存图时要正反存两遍，因为是无向图。还有，i文化排斥j

文化，但j文化不一定排斥i文化，所以并查集~~（冰茶几）~~是不可行的。。。

思路很简单，就是边跑dijistra边记录跑过的路径，用一个前继数组pre来

维护，然后每次松弛下一个点之前，就判断pre数组里的城市文化是否和下

一个城市文化相同或者排斥，最后跑出来的dis[t]就是到终点国家t的最短

距离了。用这个思路，最后跑了32ms。

献上丑陋的代码~~~（我用的是greater优先队列优化，你也可以试试不加

优化的）


```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=707406378;//最大值 
int cnt=0;
bool vis[105];
int a[105][105],c[105],head[105],dis[105],pre[105];//pre[i]存储i点的前一个点，形成链表 
priority_queue<pair<int,int>,
               vector<pair<int,int> >,
               greater<pair<int,int> > > Q;
struct edge{
    int to;
    int val;
    int next;
}e[10005];
int read(){//读入优化 
    int x=0;int f=1;char s=getchar();
    while(s<'0'||s>'9'){
        if(s=='-')	f=-1;
        s=getchar();
    }
    while(s>='0'&&s<='9'){
        x=x*10+s-'0';
        s=getchar();
    }
    return f*x;
}
void addEdge(int u,int v,int val){//邻接表建图 
    e[++cnt].to=v;
    e[cnt].val=val;
    e[cnt].next=head[u];
    head[u]=cnt;
}
bool judge(int u,int v){
    int tmp=u;
    while(tmp){
    	//如果V国家的文化排斥所有走过的国家之一的文化
		//或所有走过的国家的文化之一与V国家相同
		//那么就不能走，返回false 
        if(a[c[v]][c[tmp]]!=0||c[v]==c[tmp]){
            return false;
        }
        //否则继续向前扫，找前一个国家是否符合要求 
        tmp=pre[tmp];
    }
    //没有找到不符合要求的说明所有的国家都符合要求，返回true 
    return true;
}
void dijistra(int u){//dijistra+greater堆优化，不再赘述 
    memset(dis,127/3,sizeof(dis));//开始为正无穷 
    dis[u]=0;
    Q.push(make_pair(0,u));
    while(Q.size()){
        int k=Q.top().second;
        Q.pop();
        if(vis[k])	continue;
        vis[k]=1;
        for(int i=head[k];i;i=e[i].next){
        	//如果该点可以被松弛，且该国家的文化不排斥所有走过的国家之中的文化且不相同，那么就松弛 
            if(dis[e[i].to]>dis[k]+e[i].val&&judge(k,e[i].to)){
                pre[e[i].to]=k;//储存路径 即当前国家的前一个点 
                dis[e[i].to]=dis[k]+e[i].val;
                Q.push(make_pair(dis[e[i].to],e[i].to));
            }
        }
    }
}
int main(){
//	freopen("culture.in","r",stdin);
//	freopen("culture.out","w",stdout);
    int n,k,m,s,t;
    scanf("%d%d%d%d%d",&n,&k,&m,&s,&t);
    for(int i=1;i<=n;++i){
        c[i]=read();
    }
    for(int i=1;i<=k;++i){
        for(int j=1;j<=k;++j){
            a[i][j]=read();	
        }
    }
    for(int i=1;i<=m;++i){
        int u,v,d;
        u=read();v=read();d=read();
        addEdge(u,v,d);//无向图！！ 
        addEdge(v,u,d);
    }
    dijistra(s);
    if(dis[t]==MAXN){//如果dis[t]仍等于正无穷，说明无法到达目的国家，输出-1 
        printf("-1\n");
        return 0;
    }
    printf("%d\n",dis[t]);//否则输出最短距离 
    return 0;
}
```

---

## 作者：Charles_with_wkc (赞：5)

# 声明：
本题，看了题解区发现只有 $1$ 篇 dijkstra 的算法，于是有了这篇题解。

因为本题不一定存在正确的解法~~换句话说：就是错题~~，所以有 hack 也很正常吧。

# 思路：
本题使用的是 **dijkstra** 算法求最短路，但是这道题不同的一点是，这里面出现了文化歧视，文化不重复学习等。我们可以加入标记来让本题可以愉快地使用 dijkstra 算法。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N=105;
struct node{
	int v,w;
};
struct nodee{
	int u,d;
	int used[N];//哪种语言使用过了 
	bool operator<(const nodee &A)const{
		return A.d<d;
	}
};
vector<node>edge[N];
bool vis[N],qs[N][N];
int dis[N],c[N];
int n,f,t,w,m,u,st,en,k,v;
void dijkstra(int st){
	priority_queue<nodee>q;
	nodee ccf;
	ccf.u=st;
	ccf.d=0;
	for(int i=1;i<=k;i++) ccf.used[i]=0;
	q.push(ccf);//封装存储 
	fill(dis,dis+1+n,1e9);//最大值初始化 
	dis[st]=0;
	while(!q.empty()){
		u=q.top().u;
		nodee us=q.top();
		q.pop();
		if(vis[u]||us.used[c[u]]) continue;
		vis[u]=1;
		us.used[c[u]]=1;
		for(int i=1;i<=k;i++)
			if(qs[c[u]][i]) us.used[i]=1;//歧视 
		for(node e:edge[u]){
			v=e.v;
			w=e.w;
			if(us.used[c[v]]) continue; 
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				if(!vis[v]){
					ccf.d=dis[v];
					ccf.u=v;
					for(int j=1;j<=k;j++) ccf.used[j]=us.used[j];
					q.push(ccf);
				}
			}
		}
	}
	if(dis[en]!=1e9) cout<<dis[en];
	else cout<<-1;
	return ;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k>>m>>st>>en;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=k;i++)
		for(int j=1;j<=k;j++) cin>>qs[i][j];
	while(m--){
		cin>>f>>t>>w;
		edge[f].push_back(node{t,w});
		edge[t].push_back(node{f,w});
	}
	dijkstra(st);
	return 0;
}
```
# 尾言：
本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。  
本题为错题。**不建议尝试或提交本题**。[关于此类题目的详细内容](https://www.luogu.com.cn/problem/P1078)

所以，我的代码没有过样例，但是 AC 了。

如果是我代码的问题，希望大佬指出。

# 玄学合集：
[玄学1 Floyd 92pts](https://www.luogu.com.cn/discuss/922467)  
[玄学2 dijkstra+A* 没过样例，但是 AC 了](https://www.luogu.com.cn/discuss/759092)  
[玄学3 正搜对 4 个，逆搜对 3 个](https://www.luogu.com.cn/discuss/707541)  
[玄学4 第 10 个点，本地 RE，洛谷神速](https://www.luogu.com.cn/discuss/642742)  
[玄学5 没有判断条件 AC](https://www.luogu.com.cn/discuss/565698)  
[玄学6 dfs 对 4 个点，删掉回溯 AC](https://www.luogu.com.cn/discuss/557215)  
[玄学7 样例没过 AC](https://www.luogu.com.cn/discuss/517289)  
[玄学8 倒搜没有该判断 AC 了](https://www.luogu.com/discuss/31823)  
[玄学9 不合理的 AC，加了 vis 直接卡到 0ms](https://www.luogu.com/discuss/22638)  
[玄学10 第 10 个点 1008ms](https://www.luogu.com/discuss/32744)  
以上是作者翻阅讨论区得到的玄学合集。

---

## 作者：Clare613 (赞：3)

~~**[题目传送门](https://www.luogu.com.cn/problem/P1078)**~~
## 前置知识：
dijstra 是一个非常典型的最短路，相信大家有所了解，也就是 SPFA 的升级版，但是不能处理待负环的问题，主要优化就在于优先队列。如果不知道 SPFA，那么[到这](https://www.luogu.com.cn/article/6dx4r2lw)。
## 思路：
这道题目测是一个普通的最短路，但是有几处地方需要判断是否可以建边。
1. 如果下一步的文明对当前文明排斥，那么就不能建边。
2. 如果下一步的文明和当前文明相同，那么就不能建边。
3. 如果下一步的文明和原始文明相同，那么就不能建边。
4. 如果原始文明对下一步的文明排斥，那么就不能建边。\
否则的话，就是可以建边了，因为数据范围不大，所以就可以直接建边了。
## 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int v,w;
	bool operator < (const node & a) const {
		return w > a.w;
	}
};
int n,k,m,s,t;
int a[105][105],b[105],c[105];
bool f[105];
vector<node> g[105];
void dij(){
	priority_queue<node> q;
	q.push({s,0});
	while(!q.empty()){
		node t=q.top();
		q.pop();
		if(f[t.v]) continue;
		f[t.v]=1;
		for(auto i:g[t.v]){
			if(!f[i.v]){
				c[i.v]=c[t.v]+i.w;
				q.push({i.v,c[i.v]});
			}
		}
	}
}
signed main(){
	cin>>n>>k>>m>>s>>t;
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		if(a[b[v]][b[u]]||b[u]==b[v]||b[v]==b[s]||a[b[s]][b[v]]) continue;
		g[u].push_back({v,w});
	}
	dij();
	if(!f[t]) cout<<-1;
	else cout<<c[t];
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/206486906)

---

## 作者：tuboshu666 (赞：1)

## 前言：
由于本题是错题，因此本题解可能存在 hack。

## 思路：
最短路+正边权，不难想到 dijistra。本题与传统最短路问题的区别在于文化互斥关系。

那么我们要如果处理这种互斥关系呢？首先来回顾一下传统的堆优化 dijistra 算法：在每次加点时，我们选择距离起点最近的点，更新与其相连节点的最短距离，并再将这些点加入优先队列。

在这个过程中，我们不仅将距离加入优先队列，连带的还有该节点的信息，即：节点编号。那么对于本题，我们的节点信息不光有节点的编号，还应包括走到该节点时，学习文化的状态。

我们该如果存储学习文化的状态呢？不难想到状态压缩：记一个 $01$ 字串的第 i 位为 $1$ 时，表示已经学习过文化 i。同样，我们也可以通过状态压缩表示某个文化对其他文化的排斥关系。

有了状态压缩，在跑最短路过程中就可以处理文化互斥关系了。

观察以下例子：

```cpp
某文化对其他文化的互斥状态　01010
　　　　节点的文化学习状态  01100
　　　　　两状态进行与操作  01000
```

可以发现，若这两个二进制状态进行与操作后，存在某位为 $1$，则表示学习过的文化与该文化冲突，则该路径不可走。


## Solution：
通过以上分析，我们得到了 dijistra+状态压缩的做法。

关于状态压缩，可以使用 STL 中的 ```bitset``` ，因为其支持两个 ```bitset``` 的位运算操作。特别地，我们需要用到 ```any()``` 函数来判断是否存在某位为 $1$。

 ```bitset``` 在此不多赘述，详细可见[扶苏的bitset浅谈](https://www.luogu.com.cn/article/osrhh40p)。

 ## Code：

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <bitset>
using namespace std;

const int N = 110;

struct node
{
    int v,w;
};

struct pos //节点信息
{
    int id; //节点编号
    bitset<N> bit; //该节点所学文化的状态
};

typedef pair<int,pos> PII; //距离与节点信息

//由于PII中使用到了bitset，因此优先队列的比较关系需要重载
struct cmp
{
    bool operator()(PII a , PII b)
    {
        return a.first > b.first;
    }
};

vector<node> g[N]; //邻接表
priority_queue<PII, vector<PII>, cmp> q; //小根堆
bitset<N> v[N]; //排斥关系
int c[N]; //国家对应文化
int d[N]; //距起点距离
bool vis[N]; //节点是否访问过
int n,k,m,s,t;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> k >> m >> s >> t;
    for (int i = 1 ; i <= n ; i++) cin >> c[i]; //读入国家对应文化
    for (int i = 1 ; i <= k ; i++)
    {
        for (int j = 1 ; j <= k ; j++)
        {
            int x;
            cin >> x;
            v[i][j] = x; //读入文化互斥关系
        }
    }

    for (int i = 1 ; i <= m ; i++)
    {
        int u,v,w;
        cin >> u >> v >> w;
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }

    memset(d,0x3f3f3f3f,sizeof(d)); //距起点距离初始化为无穷大
    bitset<N> bit_s;
    bit_s[c[s]] = 1; //起点文化标记为1
    d[s] = 0; //起点距离初始化0
    q.push({0,{s,bit_s}});
    while (!q.empty())
    {
        PII t = q.top();
        q.pop();
        int pos = t.second.id;
        if (vis[pos]) continue; //节点访问过就跳过
        vis[pos] = true;
        
        for (int i = 0 ; i < g[pos].size() ; i++)
        {
            int to = g[pos][i].v; //去向
            int val = g[pos][i].w; //边权
            bitset<N> temp = t.second.bit;
            bitset<N> b = v[c[to]] & temp; //下一节点的排斥关系“与”上当前学过的文化
            if (b.any()) continue; //如果排斥就跳过
            if (t.second.bit[c[to]] == 1) continue; //如果学习过就跳过

            temp[c[to]] = 1; //该文化标记为学过
            if (d[to] > d[pos]+val)
            {
                d[to] = d[pos] + val;
                q.push({d[to],{to,temp}});
            }
        }
    }

    if (d[t] == 0x3f3f3f3f) cout << -1 << endl; //终点距离为无穷大则无解
    else cout << d[t] << endl;

    return 0;
}
```

---

## 作者：grard4 (赞：1)

事实证明，A* 是可以草过这题的，而且跑的还很快。是可以通过更强一点的数据的。

将某个点的估价定义为当前的代价加上这个点到 $t$ 的最短路的长度，这个可以建反向边然后对 $t$ 跑一遍单源最短路。每次扩展的时候取出估价最小的状态即可。

同时可以发现，图上的某一些边，对于任意一种可行方案是都不会经过的，这里给出具体的情况：

1.由于起点 $s$ 的文化必须学习，因此对于除 $s$ 以外其它与 $s$ 文化相同的国家，必定不会经过。因此这些点是无用的，在建边的时候就不去建与这些点相关的边。

2.如果存在 $u$ 排斥 $v$，且存在边 $(u,v)$ 的时候，$u\rightarrow v$ 的边是一定走不通的。因此建边的时候也只需建 $v\rightarrow u$ 的边。

3.如果 $u$ 和 $v$ 的文化相同，则 $(u,v)$ 这条边是一定走不通的。因此若存在连接 $(u,v)$ 的边时不去建边。

这样就通过去除无用的边，可优化跑最短路的复杂度，也可加快搜索的效率。

判断是否已经学习被排斥的文化时，直接用 bitset 合并一下即可，不需要逐一进行枚举。这样能够进一步优化时间复杂度。

代码在此：

```cpp
#include<bits/stdc++.h>
#define MAXN 105
using namespace std;
int n,m,k,s,t,tot1,tot2,c[MAXN],h1[MAXN],h2[MAXN],dis[MAXN];
bool no[MAXN],vis[MAXN];
bitset<MAXN> a[MAXN];
struct edge{
    int nxt,to,val;
}e1[MAXN*MAXN*2],e2[MAXN*MAXN*2];
//e1 连接的是正向边,e2 连接的是反向边
void add(int u,int v,int w){
    e1[++tot1]={h1[u],v,w},h1[u]=tot1;
    e2[++tot2]={h2[v],u,w},h2[v]=tot2;
    return;
}
struct node{
    int u,w;bitset<MAXN> ok;
    friend bool operator<(const node &x,const node &y){
        //估价小的优先
        return 1ll*x.w+dis[x.u]>1ll*y.w+dis[y.u];
    }
};
priority_queue<node> q;
void spfa(){           //对终点跑一遍最短路
    memset(dis,0x7f,sizeof(dis));
    queue<int> Q;
    dis[t]=0;Q.push(t);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        vis[u]=false;
        for (int i=h2[u];i;i=e2[i].nxt){
            int v=e2[i].to,w=e2[i].val;
            if (dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if (!vis[v]) vis[v]=true,Q.push(v);
            }
        }
    }
    return;
}
int main(){
    cin>>n>>k>>m>>s>>t;
    for (int i=1;i<=n;i++) cin>>c[i];
    for (int i=1;i<=k;i++)
      for (int j=1;j<=k;j++){
        bool op;cin>>op;
        if (op) a[i].set(j);
      }
    for (int i=1;i<=n;i++)
      if (i!=s&&c[i]==c[s]) no[i]=true;    //判断哪些点是无用的
    if (no[t]) {puts("-1");return 0;}      //如果终点也是无用的,则必定无解
    while(m--){
        int u,v,w;cin>>u>>v>>w;
        if (!no[u]&&!no[v]&&c[u]!=c[v]){   //只连接文化不同且有用的点
            if (!a[c[u]].test(c[v])) add(v,u,w);  //如果不排斥就连接
            if (!a[c[v]].test(c[u])) add(u,v,w);
        }
    }
    spfa();
    if (dis[s]==dis[0]) {puts("-1");return 0;}  //如果起点到终点的最短路不存在则无解
    bitset<MAXN> p;p.set(c[s]);
    q.push({s,0,p});
    while(!q.empty()){
        int u=q.top().u,w=q.top().w;
        if (u==t) {cout<<w<<endl;return 0;}
        bitset<MAXN> ok=q.top().ok;
        q.pop();
        for (int i=h1[u];i;i=e1[i].nxt){
            int v=e1[i].to,w1=e1[i].val;
            p=ok&a[c[v]];
            if (p.any()) continue;   //如果 p 中存在 1,则说明学过已被排斥的文化
            p=ok,p.set(c[v]);
            q.push({v,w+w1,p});
        }
    }
    puts("-1");
    return 0;
}
```

---

## 作者：yedalong (赞：1)

## 前言
由于是错题，本人的代码可能存在 hack，请见谅。
## 思路
看到这么小的数据范围，我就直接上搜索了。用的是深搜。主要做法是用一个数组做标记，表示这个国家能否走，在从一个国家走向另一个国家时加个判断，如果数组上此国家的标记为 $0$，就可以走。  
但是单纯的深搜会超时，这时候我们再加上优化。主要加了两个，一个是记忆化，另一个是删掉重复的边，优化后跑得飞快，大家可以看一下[这个](https://www.luogu.com.cn/record/201192772)。  
进食一下后人，在做标记时不能直接赋值，需要加 $1$ 或减 $1$，不然回溯时它会把标记直接覆盖掉，因为这个我调了一个多小时。。。
## AC code:

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
    int x,y;
};
int n,k,m,s,t,u,v,d,a[105][105],c[105],ans[105],e[105][105],pd[105];
vector<node> edge[105];
vector<int> cult[105];
void dfs(int now){
    if(now==t) return;
    for(auto tmp:cult[c[now]]) pd[tmp]++;
    for(int i = 1;i<=k;i++) if(a[i][c[now]]) for(auto tmp:cult[i]) pd[tmp]++;
    for(auto to:edge[now]) if(!pd[to.x]&&ans[to.x]>ans[now]+to.y) ans[to.x]=ans[now]+to.y,dfs(to.x);
    for(auto tmp:cult[c[now]]) pd[tmp]--;
    for(int i = 1;i<=k;i++) if(a[i][c[now]]) for(auto tmp:cult[i]) pd[tmp]--;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>k>>m>>s>>t;
    for(int i = 1;i<=n;i++) if(i!=s) ans[i]=1e9;
    for(int i = 1;i<=n;i++) for(int j = 1;j<=n;j++) e[i][j]=1e9;
    for(int i = 1;i<=n;i++) cin>>c[i],cult[c[i]].push_back(i);
    for(int i = 1;i<=k;i++) for(int j = 1;j<=k;j++) cin>>a[i][j];
    for(int i = 1;i<=m;i++) cin>>u>>v>>d,e[u][v]=e[v][u]=min(e[u][v],d);
    for(int i = 1;i<=n;i++) for(int j = 1;j<=n;j++) if(e[i][j]!=1e9) edge[i].push_back({j,e[i][j]});
    dfs(s);
    if(ans[t]==1e9) cout<<-1;
    else cout<<ans[t];
    return 0;
}
```

---

## 作者：_Weslie_ (赞：1)

提示：由于测试数据过水，可以通过此题的程序不一定完全正确。如果我的程序出现问题，欢迎 hack。

## Solution P1078

### Idea

看到最少，就想到使用 dijstkra 算法。

但是这道题不同的一点是，这里面出现了文化歧视，文化不重复学习等。我们一定需要在算法内加入状态的标记，才有可能满足条件。

于是我们在算法中加入一个数组 $use$，记录这种文化的点是否可以被遍历。

$use$ 的更新非常简单：当我们走到点 $u$ 的时候，点 $u$ 的文化与与点 $u$ 文化歧视的文化的点都不可以被遍历。我们直接暴力打标记即可。

代码细节较多，具体问题看代码具体分析。

### Code

开头一堆定义，这个没什么好说的。

```
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int u,v,w,nxt;
}e[10005];
int head[105],cnt,cul/*culture-文化*/[105],qs/*歧视*/[105][105];
long long dis[105];
bool vis[105];
int n,m,s;
int k,t;
void add(int u,int v,int w){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
long long read() {
	int f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}
```

dijstkra 的前置准备部分。

```
struct node{
	int dis,pos;
	int use[105];//use[i] 表示 i 这一种文化的点是否可以被遍历
	bool operator <(const node &x)const{
		return x.dis<dis;
	}//优先队列重载运算符
};
priority_queue<node>q;
node p;
```

dijstkra 部分。

```
void dj(){
	p.dis=0;
	p.pos=s;
	for(int i=1;i<=k;i++)p.use[i]=0;
	q.push(p);
	while(!q.empty()){
		node tmp=q.top();
		q.pop();
		int x=tmp.pos,y=tmp.dis;
		if(vis[x]||tmp.use[cul[x]])continue;
		vis[x]=1;
		tmp.use[cul[x]]=1;
		for(int i=1;i<=k;i++){
			if(qs[cul[x]][i])tmp.use[i]=1;//歧视的打上标记
		}
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].v;
			if(tmp.use[cul[v]])continue;
			if(dis[v]>dis[x]+e[i].w){//松弛
				dis[v]=dis[x]+e[i].w;
				if(!vis[v]){//状态更新，塞进优先队列里
					p.dis=dis[v];
					p.pos=v;
					for(int j=1;j<=k;j++){
						p.use[j]=tmp.use[j];
					}
					q.push(p);
				}
			}
		}
	}
}
```

主函数部分。

```
int main(){
	n=read();
	k=read();
	m=read();
	s=read();
	t=read();
	for(int i=1;i<=n;i++){
		cul[i]=read();
		dis[i]=1145141919810;//初始设成极大值
	}
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			qs[j][i]=read();
		}
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		u=read();
		v=read();
		w=read();
		add(u,v,w);
		add(v,u,w);
	}
	dis[s]=0;
	dj();
	if(dis[t]!=1145141919810)printf("%lld",dis[t]);
	else printf("-1");
	return 0;
}
```

---

## 作者：xingsunderen (赞：0)

一道 dijkstra 加一点点特判的板子题。
## 题意
感觉没什么好说的。

储存文化是否相斥，我们可以使用一个类似存边的方法，用 $di$ 向量存储，有边就代表排斥，那么下面就很简单了。
## 思路
总体就是一个 dijkstra。

因为我们可以看到题目中说国家数量很少，因此在原有判断 $vis=1$ 的基础上，只需要在松弛操作中判断 $di$ 中两个点间是否有边，说起来可能有点模糊，放个局部代码：

```cpp
//这个就是上面说的特判。
bool pan(int u,int v){
	for(auto i:di[v]){ 
		if(i==u) return false;
	}
	return true;
}
//以下是 dijkstra 内部松弛操作。
for(auto i:e[no]){
    if(!pan(c[no],c[i.v])) continue;
    int v=i.v,w=i.w;
    if(dis[v]>dis[no]+w){
      dis[v]=dis[no]+w;
      q.push({v,dis[v]});
    }
}
```
总体来说还是比较简单的，中黄的难度吧。
## 代码
给个代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int v,w;
};
struct P{
	int no,dis;
	bool operator < (const P & a)const{
		return dis>a.dis;
	}
};

const int N=105;
vector<edge> e[N];
vector<int> di[N];
int dis[N],c[N],a[N][N];
bool vis[N],visc[N][N];
priority_queue<P> q;
int n,k,m,s,t;

bool pan(int u,int v){
	for(auto i:di[v]){
		if(i==u) return false;
	}
	return true;
}
void add(int u,int v,int w){
	e[u].push_back({v,w});
}
void dijkstra(int st){
	memset(dis,0x3f,sizeof dis);
	dis[st]=0;
	q.push({st,0});
	while(!q.empty()){
		P t=q.top();
		q.pop();
		int no=t.no;
		if(vis[no]) continue;
		vis[no]=1;
		for(auto i:e[no]){
			if(!pan(c[no],c[i.v])) continue;
			int v=i.v,w=i.w;
			if(dis[v]>dis[no]+w){
				dis[v]=dis[no]+w;
				q.push({v,dis[v]});
			}
		}
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k>>m>>s>>t;
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++){
			cin>>a[i][j];
			if(a[i][j]==1) di[i].push_back(j);
		}
	}
	for(int i=1;i<=m;i++){
		int u,v,d;
		cin>>u>>v>>d;
		if(!a[u][c[v]]) add(v,u,d);
		if(!a[v][c[u]]) add(u,v,d);
	}
	dijkstra(s);
	if(!vis[t]||c[s]==c[t]) cout<< -1;
	else cout<<dis[t];
	return 0;
}
```

---

## 作者：Little_duck_GGG (赞：0)

### 题目意思
有一名使者，要在各个国家旅行，每个国家有一种文化，文化之间会互相排斥，使者不能到达排斥他以前去过国家的文化的其他国家，也不能到达与他以前去过的国家文化一样的国家。
求从起点到终点，最少要走多远。
### 题目思路
#### 第一步我们先处理一下文化相互排斥的问题。
我们用一个二维数组表示两种文化是否互斥。我们可以看到，数据范围只有一百，所以我们直接用弗洛伊德去算。这是模板，不多讲，给出代码。

```cpp
void floyd()
{
	for(int o=1;o<=k;o++)
	{
		for(int i=1;i<=k;i++)
		{
			for(int j=1;j<=k;j++)
			{
				if(i!=j&&i!=k&&j!=k) lj[i][j]=min(lj[i][j],lj[i][o]+lj[o][j]);
			}
		}
	}
}
```
#### 接下来我们来处理一下使者行走的过程，同样的，数据范围小，我们直接用深搜来做。
深搜只有一个参数，就是当前走到哪个国家，我们每次找到与此国家有路径的其他国家并判断是否能去那些国家。

#### 那么，如何判断呢？
判断无非就是一个条件，如果学习了以前的文化能否学习当前的文化。

但在这道题中，我们会发现，有的国家会重复经过，所以我们定义一个变量表示从起点到当前国家的最小距离，如果当前再次经过了这个国家，则**将当前到这个国家的距离与此数组取最小**。
### 最后给出我的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,uu[100005],c[100005],ans=INT_MAX,u,vv[10005],v,lj[105][105],l,k,m,s,t;
vector<int> x[10005];
vector<int> len[10005];
void floyd()//floyed模板，类似于传递闭包 
{
	for(int o=1;o<=k;o++)
	{
		for(int i=1;i<=k;i++)
		{
			for(int j=1;j<=k;j++)
			{
				if(i!=j&&i!=k&&j!=k) lj[i][j]=min(lj[i][j],lj[i][o]+lj[o][j]);
			}
		}
	}
}
void dfs(int y)
{	
	if(y==t)//到达终点，返回 
	{
		ans=min(ans,vv[t]);
		return;
	}
	for(int i=0;i<x[y].size();i++)
	{
		if(uu[c[x[y][i]]]==0)//如果以前已经学习过了这种文化，则不能到当前国家 
		{
			if(lj[c[x[y][i]]][c[y]]!=INT_MAX)//判断是否互斥，因为已经floyed过了，所以我们只要判断上一个国家的文化与当前国家的文化是否互斥就行了 
			{
				if(vv[x[y][i]]>vv[y]+len[y][i]||vv[x[y][i]]==0)//判断找最小距离 
				{
					uu[c[x[y][i]]]=1;//标记此文化已学习过了 
					vv[x[y][i]]=vv[y]+len[y][i];//更新 
					dfs(x[y][i]);
                    uu[c[x[y][i]]]=0;
				}	
			}
		}
		
	}
}
int main(){
    cin>>n>>k>>m>>s>>t;
    for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=k;i++)
	{
		for(int j=1;j<=k;j++)
		{
			cin>>lj[i][j];
			if(lj[i][j]==1) lj[i][j]=INT_MAX;//表示互斥 
		} 
	}    
	floyd();
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>l;
		x[u].push_back(v);//注意是双向路径 
		x[v].push_back(u);
		len[u].push_back(l);
		len[v].push_back(l);
	}
	uu[c[s]]=1;//起点的文化 
	dfs(s);
	if(ans==INT_MAX) ans=-1; //注意输出-1 
	cout<<ans;
    return 0;
}
```

---


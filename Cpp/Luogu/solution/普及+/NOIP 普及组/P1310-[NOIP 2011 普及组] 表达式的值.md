# [NOIP 2011 普及组] 表达式的值

## 题目描述

对于 $1$ 位二进制变量定义两种运算：

$$
\begin{array}{|c|c|} \hline
\qquad\qquad\quad\textsf{运算符}\qquad\qquad\quad & \qquad\qquad\quad\textsf{运算规则}\qquad\qquad\quad \\ \hline
\oplus &
\begin{aligned}
0 \oplus 0 &= 0 \\
0 \oplus 1 &= 1 \\
1 \oplus 0 &= 1 \\
1 \oplus 1 &= 1 \\
\end{aligned} \\ \hline
\times &
\begin{aligned}
0 \times 0 &= 0 \\
0 \times 1 &= 0 \\
1 \times 0 &= 0 \\
1 \times 1 &= 1 \\
\end{aligned} \\ \hline
\end{array}
$$

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

  2. “$\times$”运算优先于“$\oplus$”运算，即计算表达式时，先计算“$\times$”运算，再计算“$\oplus$”运算。例如：计算表达式 $A\oplus B \times C$ 时，先计算 $B \times C$，其结果再与 $A$ 做“$\oplus$”运算。

现给定一个未完成的表达式，例如 $\_+(\_ * \_)$，请你在横线处填入数字 $0$ 或者 $1$，请问有多少种填法可以使得表达式的值为 $0$。

## 说明/提示

【输入输出样例说明】

  给定的表达式包括横线字符之后为：$\_+(\_ * \_)$。 

  在横线位置填入 $(0,0,0)$ $(0,1,0)$ $(0,0,1)$ 时，表达式的值均为 $0$，所以共有 $3$ 种填法。 

【数据范围】

对于 $20\%$ 的数据有 $ 0 \le L \le 10$。

对于 $50\%$ 的数据有 $0 \le L \le 1,000$。

对于 $70\%$ 的数据有 $ 0 \le L \le 10,000$ 。

对于 $100\%$的数据有 $ 0 \le L \le 100,000$。

对于$50\%$ 的数据输入表达式中不含括号。

## 样例 #1

### 输入

```
4
+(*)
```

### 输出

```
3
```

# 题解

## 作者：神犇的蒟蒻 (赞：102)

**本题难点在于：1.有优先级**

**2.有括号**


**我们先分析一下**


这是一道表达式计算的扩展题，对选手最基本的要求就是表达式计算。在一般的表达式计算中，存放结果的栈都是记录计算到某一步的结果，而在这道题中，结果只可能为2个（0或者1），且是知道的，而运算的数字是不一定的，所以在栈中只需存放算到0或者1时的方案数，最后输出到最后算出0的方案数即可。


**算法实现**


一、  首先粗略地说一下表达式计算的方法：  需要使用两个栈，一个存放结果，另一个存放符号。每次读入一个数据，就进入结果栈，如果是符号，则按以下方法：  1、 如果是左括号，就直接进栈；  2、 如果是右括号，就一直弹栈并加以计算，直到弹到左括号；  3、 如果是运算符，则弹栈，直到这个运算符的优先级大于符号栈栈顶的符号的优先级 或是左括号或栈空，然后将运算符进栈；      最后再将栈中残余的符号和结果一直弹到只剩一个结果，这个就是最后的结果。 二、  此题算法的框架整体上是和表达式计算相同的，有以下几个方面不同： 1、需要添加数字的地方应该满足不在右括号的后面或者左括号的前面 2、优先级：“\*”的优先级比“+”高  3、运算方法，每一步计算为0或1的方法数：设两个步骤的运算结果经过每个符号到一个结果时，第一个运算结果算出0的方案数为t1,1的方案数为t2,第二个算出0的方案数为t3，算出1的方案数为t4，则有：  当符号是“⊕”时，得到0的方案数为t1\*t3,1的方案数：t1\*t4+t2\*t3+t2\*t4    当符号是“×”时，得到0的方案数为t1\*t3+t1\*t4+t2\*t3,1的方案数：t2\*t4 用一个栈记录下来即可


**参考代码：**

```cpp
#include<stdio.h>
const int M=10007,N=100005;
int n,i,u[N],v[N],top,k;
char c[N],sta[N],ans[2*N];
int main()
{
    freopen("exp.in","r",stdin);
    freopen("exp.out","w",stdout);
    scanf("%d\n%s",&n,c);
    ans[++k]='.';
    for(i=0;c[i];i++)
    {
        if(c[i]=='('||c[i]=='*')
            sta[++top]=c[i];
        if(c[i]=='+')
        {
            while(sta[top]=='*')
                ans[++k]=sta[top--];
            sta[++top]=c[i];
        }
        if(c[i]==')')
        {
            while(sta[top]!='(')
                ans[++k]=sta[top--];
            top--;
        }
        if(c[i]!='('&&c[i]!=')')
            ans[++k]='.';
    }
    while(top>0)
        ans[++k]=sta[top--];
    for(i=1;i<=k;i++)
    {
        if(ans[i]=='.')
        {
            u[++top]=1;
            v[top]=1;
        }
        if(ans[i]=='*')
        {
            top--;
            u[top]=(u[top+1]*v[top]+u[top]*v[top+1]+u[top]*u[top+1])%M;
            v[top]=v[top]*v[top+1]%M;
        }
        if(ans[i]=='+')
        {
            top--;
            v[top]=(u[top+1]*v[top]+u[top]*v[top+1]+v[top]*v[top+1])%M;
            u[top]=u[top]*u[top+1]%M;
        }
    }
    printf("%d",u[1]);
}
```

---

## 作者：Drinkkk (赞：66)

- **NOIP普及组 2011 第四题**

## 题目描述

对于 1 位二进制变量定义两种运算：

![](https://cdn.luogu.com.cn/upload/pic/99.png)

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

2. “ $×$ ”运算优先于“ $⊕$ ”运算，即计算表达式时，先计算× 运算，再计算 $⊕$ 运算。例如：计算表达式 $A ⊕ B × C$ 时，先计算 $B × C$，其结果再与 $A$ 做 $⊕$ 运算。

现给定一个未完成的表达式，例如 ``_+(_*_)``，请你在横线处填入数字 $0$ 或者 $1$ ，请问有多少种填法可以使得表达式的值为 $0$ 。

## 输入输出格式

- ### 输入格式

共 $2$ 行。

第 $1$ 行为一个整数 $L$，表示给定的表达式中除去横线外的运算符和括号的个数。

第 $2$ 行为一个字符串。包含 $L$ 个字符，其中只包含’``（``’、’``）``’、’``+``’、’``*``’这 $4$ 种字符，其中’``（``’、’``）``’是左右括号，’``+``’、’``*``’分别表示前面定义的运算符“ $⊕$ ”和“ $×$ ”。这行字符按顺序给出了给定表达式中除去变量外的运算符和括号。

- ### 输出格式：
共 $1$ 行。

包含一个整数，即所有的方案数。注意：这个数可能会很大，请输出方案数对``10007``取模后的结果。

## 输入输出样例

```
Input:
4
+(*)
Output:
3
```

## 样例解释

- ### 输入输出样例说明

  给定的表达式包括横线字符之后为：``_+(_*_)`` 

  在横线位置填入``(0 、0 、0) ``、``(0 、1 、0)`` 、``(0 、0 、1) ``时，表达式的值均为 $0$ ，所以共有 $3$ 种填法。 

## 数据范围

对于 $20\%$ 的数据有 $0 ≤ L ≤ 10$ 。

对于 $50\%$ 的数据有 $0 ≤ L ≤ 1,000$ 。

对于 $70\%$ 的数据有 $0 ≤ L ≤ 10,000$ 。

对于 $100\%$ 的数据有 $0 ≤ L ≤ 100,000$ 。

对于 $50\%$ 的数据输入表达式中不含括号。

## 题解

在这里我们将用**栈**来解决这个问题。

首先我们有一个符号栈 $t$ ，用来存储操作符。

接下来我们有两个数字栈 $a$ 和 $b$ ，分别表示当前运算结果为 $0$ 和为 $1$ 的方案数。

这三个栈的栈顶分别为 $topt,topa,topb$ 。

- $E.g.1$

```
*+
```

当前的栈 $t,a,b$ 都是空的，如图。

![无标题.png](https://i.loli.net/2019/01/05/5c30bfc9c141b.png)

接下来我们弹入了一个乘号，由于乘号是除括号外最高级的，所以我们要先把它前面的乘号算完（但是要注意如果一个乘号的右边是一个左括号就不能够直接算了）。但是由于它前面已经没有乘号了，所以我们先不管它。

对于每一个字符，我们要判断它的前面和后面是否能够放数字，及样例解释中为下划线的地方。

如果能放，就在 $a$ 栈和 $b$ 栈的栈顶各放入一个 $1$ 。

此时状态：

$t:\times$

$a:$

```
1
1
```

$b:$

```
1
1
```

接下来我们把一个加号放进来。由于加号优先级比乘号低，所以我们要把这个加号前面的乘号给消掉。消之前的图是长这样的。

![无标题2.png](https://i.loli.net/2019/01/05/5c30bfc9b8b30.png)

下面是消的方法。

![无标题3.png](https://i.loli.net/2019/01/05/5c30bfc9c2ff3.png)

这就是消完后的图啦。

![无标题4.png](https://i.loli.net/2019/01/05/5c30bfc9a2c2f.png)

加号的话还是差不多。

$$e=a*c$$

$$f=a*d+b*c+b*d$$

左括号的话就直接把它丢到符号栈里面就可以了。

如果是右括号的话就一直消，直到消到左括号为止。

注意右括号左边可能是乘号，也要把它算进去。

然后两个括号之间乘号基本上都被消掉了，大部分都是加号，可以放心算。

最后 $a$ 栈的栈底（顶）就是答案。

为了防止消不尽可以在式子的两边加括号qwq。

例如样例加了括号就变成这样了。

```
（+(*)）
```

如果还有不理解的可以尝试联系代码来理解qaq，最好是自己动手写。

## 代码（仅供参考）

```
#include <cstdio>
char st[1000001],t[1000001];
int a[1000001],b[1000001];
int main()
{
	int topt=0,topa=0,topb=0,n=0;
	scanf("%d",&n);
	scanf("%s",st+2);
	st[1]='(',st[n+2]=')';
	for(int i=1;i<=n+2;i++)
	{
		if((st[i]=='+' || st[i]=='*') && st[i-1]!=')' && st[i-1]!='+' && st[i-1]!='*')
		{
			a[++topa]=b[++topb]=1;
		}
		if(st[i]=='(')
		{
			t[++topt]=st[i];
		}
		if(st[i]=='*')
		{
			if(st[i+1]=='(')
			{
				t[++topt]=st[i];
				continue;
			}
			while(true)
			{
				if(t[topt]!='*')
				{
					break;
				}
				int aa=a[topa],ab=b[topb];
				int ac=a[topa-1],ad=b[topb-1];
				int e=aa*ac+aa*ad+ab*ac;
				int f=ab*ad;
				e%=10007,f%=10007;
				topa--,topb--;
				a[topa]=e,b[topb]=f;
				topt--;
			}
			t[++topt]=st[i];
		}
		if(st[i]=='+')
		{
			while(true)
			{
				if(t[topt]!='*')
				{
					break;
				}
				int aa=a[topa],ab=b[topb];
				int ac=a[topa-1],ad=b[topb-1];
				int e=aa*ac+aa*ad+ab*ac;
				int f=ab*ad;
				e%=10007,f%=10007;
				topa--,topb--;
				a[topa]=e,b[topb]=f;
				topt--;
			}
			t[++topt]=st[i];
		}
		if(st[i]==')')
		{
			while(true)
			{
				if(t[topt]=='(')
				{
					break;
				}
				if(t[topt]=='+')
				{
					int aa=a[topa],ab=b[topb];
					int ac=a[topa-1],ad=b[topb-1];
					int e=aa*ac;
					int f=aa*ad+ab*ac+ab*ad;
					e%=10007,f%=10007;
					topa--,topb--;
					a[topa]=e,b[topb]=f;
					topt--;
				}
				else if(t[topt]=='*')
				{
					int aa=a[topa],ab=b[topb];
					int ac=a[topa-1],ad=b[topb-1];
					int e=aa*ac+aa*ad+ab*ac;
					int f=ab*ad;
					e%=10007,f%=10007;
					topa--,topb--;
					a[topa]=e,b[topb]=f;
					topt--;
				}
			}
			topt--;
		}
		
		if((st[i]=='+' || st[i]=='*') && st[i+1]!='(')
		{
			a[++topa]=b[++topb]=1;
		}
	}
	printf("%d",a[1]%10007);
	return 0;
}
```

---

## 作者：zy_turtle (赞：17)

### [永遠の記憶 ~ Precious Memories]施工D12  
  

###### 2020.3.22  
  
#### P1310 表达式求值  
  
##### Noip2011 T4  
  
[题目传送门](https://www.luogu.com.cn/problem/P1310)  
  
  


------------
  
  
我先承认，我这道题是真的不太会做  
dp没什么有用的思路  
~~看起来dp并不亲民的样子~~  
  
###### 不过呢，还是得硬上  


------------

一看到这道题，我想到的不是个 **dp**  
是一个类似于**排列组合**或者**乘法原理**的东西  
总之思路是这样的  
先**按照加号**的顺序**分块**，  
然后按照分出来的再算**乘法**的可能个数  
就得出了答案  
~~(五分钟敲出来的，所以有很多没用的变量~~  
代码如下:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	string str;
	int init;
} let;
int n;
vector<node> add;
long long ans; 

int divide_add(node s) {
	node temp;
	if (s.str.find('+') == string::npos) {
		return -1;
	}
	else {
		for (int i = 0; i < s.str.size(); ++i) {
			if (i == s.str.size() - 1) {
				temp.init = 0;
				add.push_back(temp);
				return 0;
			} // 读完 
			else if (s.str[i] == '(') {
				while (s.str[i] != ')') {
					temp.str += s.str[i];
					++i;
				}
			} // 括号看做一个整体 
			else if (s.str[i] == '+') {
				temp.init = 0;
				add.push_back(temp);
			} // 加号分前面 
			else {
				temp.str += s.str[i];
			} // 往后读 
		}
	}
}

int main() {
	cin >> n >> let.str;
	int flag = divide_add(let);
	if (!flag) {
		for (vector<node>::iterator it = add.begin(); it != add.end(); ++it) {
			int cnt = 0;
			for (int i = 0; i < it->str.size(); ++i) {
				if (it->str[i] == '*') {
					cnt++;
				}
			}
			ans += cnt * 3;
		}
	} // 有加号，分块算  
	else {
		int cnt = 0;
		for (int i = 0; i < let.str.size(); ++i) {
			if (let.str[i] == '*') {
				cnt++;
			}
		}
		ans += cnt * 3;
	} // 没有加号  
	cout << ans % 10007 << endl;
	return 0;
}

```
  
  
结果出了 **MLE**  
说明这个解法是肯定不能AC的  
而且题目也说了，这是一道dp，所以不能用~~投机取巧的~~**排列组合或者乘法原理**来做  
~~其实最后的答案也跟乘法原理差不多(汗~~    


------------
  
  
题目说，给定一个**符号**序列  
那熟悉的朋友可能会想到用树去分这个序列，然后两个变量一组去**枚举**  
但是这么实现的代码会**格外的复杂**，时间复杂度也会**过高**，可能会T  
##### 所以我们要换一种思路  
题目现在给的是一个**中序表达式**  
我们可以考虑用栈去把它转换成**逆波兰表达式**，也就是**后缀表达式**  
~~其实应该不能叫转换，应该是存储~~  
具体模拟的方法可以参考[这道题](https://www.luogu.com.cn/problem/P1449)  
  


------------
  
  
##### 这是一道**dp**，我们考虑去推出它的**递推式**  
先对一个表达式进行分析，表达式的左边的值叫 x，右边的值叫 y  
>那么，当 x + y = 0 时，  
x = 0 且 y = 0;  
当 x * y = 0 时，  
x = 0 且 y = 1 或  
x = 1 且 y = 0 或  
x = 0 且 y = 0;  
  
>当 x + y = 1 时，  
x = 0 且 y =  1或  
x = 1 且 y = 0 或  
x = 0 且 y = 0; 
当 x * y = 1 时，  
x = 1 且 y = 1;  
  
##### 我们推出了以上的规律，后面就会方便很多  


------------
  
  
我们先把**栈的实现**写出来  
用**一个栈**来存**运算符**  
另外**两个栈**用来存**可能的数字情况的个数**  
~~其实就是跟dp数组差不多~~  
###### 表示出来就是这样:  
```cpp
const int maxn = 1e5 + 10;
char stackop[maxn];
int topop;
int stacknum1[maxn];
int stacknum0[maxn];
int topnum;

void push_op(char op) {
	stackop[++totop] = op;
}

void push_num() {
	stacknum1[++topnum] = 1;
    stacknum0[topnum] = 1;
}

```
  


------------

  
###### 再将前面推出来的式子用代码实现出来:  
```cpp
for (ll i = 0; i < let.size(); ++i) {
	if (let[i] == '(') {
		push_op(let[i]); // 处理不了，先放着
		if (let[i + 1] != '(') {
			push_num();
		} // 后面的空，括号中间不能夹数
	} else if (let[i] == ')') {
		while (stackop[topop] != '(') {
			int res0 = 0, res1 = 0;
			if (stackop[topop] == '+') {
				res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
			} else {
				res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
			}
			topop--, topnum--;
			stacknum0[topnum] = res0;
			stacknum1[topnum] = res1; // 推出来的
		} // 直接压到匹配的左括号
		topop--; // 右括号
	} else if (let[i] == '+') {
		while (stackop[topop] != '(') {
			int res0 = 0, res1 = 0;
			if (stackop[topop] == '+') {
				res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
			} else {
				res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
			}
			topop--, topnum--;
			stacknum0[topnum] = res0;
			stacknum1[topnum] = res1; // 同理
		} // 同上，加号优先级低，可以无脑压左操作数
		push_op(let[i]);
		if (let[i + 1] != '(') {
			push_num();
		} // 同理
	} else if (let[i] == '*') {
		while (stackop[topop] == '*') {
			int res0 = 0, res1 = 0;
			if (stackop[topop] == '+') {
				res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
			} else {
				res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
			}
			topop--, topnum--;
			stacknum0[topnum] = res0;
			stacknum1[topnum] = res1; // 同理
		} // 只能先压同一级的
		push_op(let[i]);
		if (let[i + 1] != '(') {
			push_num();
		} // 同理
	}
}

```
  
  


------------


最后综合**前面两步**的代码，  
再将原来的字符串做一点**细微**的处理就好啦~  
##### 完整代码如下，注释里有一些前面没讲到的东西的解释  
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 10007;
const ll maxn = 1e5 + 10;
char stackop[maxn];
ll topop;
ll stacknum1[maxn];
ll stacknum0[maxn];
ll topnum;
ll len;
string let;

void push_op(char op) {
	stackop[++topop] = op;
}

void push_num() {
	stacknum1[++topnum] = 1;
	stacknum0[topnum] = 1;
}

int main() {
	scanf("%lld", &len);
	cin >> let;
	let = '(' + let + ')';
	// 这里需要处理一下，不然要特判，太麻烦了  
	for (ll i = 0; i < let.size(); ++i) {
		if (let[i] == '(') {
			push_op(let[i]); // 处理不了，先放着 
			if (let[i + 1] != '(') {
				push_num();
			} // 后面的空，括号中间不能夹数 
		}
		else if (let[i] == ')') {
			while (stackop[topop] != '(') {
				int res0 = 0, res1 = 0;
				if (stackop[topop] == '+') {
					res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
					res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				}
				else {
					res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
					res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				}
				topop--, topnum--;
				stacknum0[topnum] = res0;
				stacknum1[topnum] = res1; // 推出来的 
			} // 直接压到匹配的左括号 
			topop--; // 右括号 
		}
		else if (let[i] == '+') {
			while (stackop[topop] != '(') {
				int res0 = 0, res1 = 0;
				if (stackop[topop] == '+') {
					res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
					res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				}
				else {
					res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
					res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				}
				topop--, topnum--;
				stacknum0[topnum] = res0;
				stacknum1[topnum] = res1; // 同理 
			} // 同上，加号优先级低，可以无脑压左操作数 
			push_op(let[i]);
			if (let[i + 1] != '(') {
				push_num();
			} // 同理 
		}
		else if (let[i] == '*') {
			while (stackop[topop] == '*') {
				int res0 = 0, res1 = 0;
				if (stackop[topop] == '+') {
					res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
					res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				}
				else {
					res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
					res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				}
				topop--, topnum--;
				stacknum0[topnum] = res0;
				stacknum1[topnum] = res1; // 同理 
			} // 只能先压同一级的 
			push_op(let[i]);
			if (let[i + 1] != '(') {
				push_num();
			} // 同理 
		}
	}
	printf("%lld\n", stacknum0[topnum] % mod); // 压到最后的就是答案 
	return 0;
}

```
  
这道题目作为一道**压轴**的 dp，其难度**不言而喻**  
这篇题解也拖了**三天**才写出来~~可能是我太鸽了~~  
总之，这是一道很有**学习价值**的题目  
近年来的 **dp** 都放在了**第三题**，也就是说**难度下降**了  
~~摆渡车忽略~~  
幸好出生得晚啊（笑）  
不过以后还是得多多加油，争取今年省一啊  
那就先写到这里吧
  
~~看来写题解的能力也需要提升(捂脸~~  
~~话说，dp果然还是不太亲民啊~~  


---

## 作者：Walrus (赞：5)

一眼是建树之后在树上 dp，问题是如何建树。首先联系 CSP-2020 的一道题可知依靠运算优先级建表达式树，朴素的建树法是 $O(N^2)$ 暴力建，也就是递归建树，但可以发现这显然是没必要的，我们完全可以给每个点设置一个优先级建笛卡尔树。

由于括号的优先级是最高的，所以括号里的东西需要优先运算，人话版理解就是这个式子外面套的括号越多其优先级就越高。

每有一对括号相当于给括号内的区间优先级加上了一个值，相当于区间加，故考虑差分，大概是这么写的：
```cpp
stack<int> ss;
rep(i, 1, n) {
	if(s[i] == '(') ss.push(i);
	if(s[i] == ')') b[ss.top()] += 2, b[i + 1] -= 2, ss.pop();
}
rep(i, 1, n) b[i] += b[i - 1], a[i] = b[i] + (s[i] == '*' ? 2 : 1); 
```

然后建笛卡尔树，由于用单调栈维护所以复杂度是 $O(N)$ 的，然后跑 dp。

令 $dp_{x,0/1}$ 表示以 $x$ 为根运算结果为 $0/1$ 的方案数，根据位与和位或的性质可以得出表达式：

- 位与
$$dp_{x,1}=dp_{ls,1}\times dp_{rs,1}$$
$$dp_{x,0}=dp_{ls,0}\times dp_{rs,1}+dp_{ls,1}\times dp_{rs,0}+dp_{ls,0}\times dp_{rs,0}$$

- 位或
$$dp_{x,0}=dp_{ls,0}\times dp_{rs,0}$$
$$dp_{x,1}=dp_{ls,0}\times dp_{rs,1}+dp_{ls,1}\times dp_{rs,0}+dp_{ls,1}\times dp_{rs,1}$$

注意取模。

附建树代码：
```cpp
void init(int *a) {
	rep(i, 1, n) {
		if(s[i] == '(' || s[i] == ')') continue;
		while(top && a[st[top]] > a[i]) ch[i][0] = st[top--];
		if(top) ch[st[top]][1] = i;
		st[++top] = i;
	} 
}
```

---

## 作者：junxis (赞：5)

# 1.部分分
[题目传送门](https://www.luogu.com.cn/problem/P1310)

我们先来看八十分怎么拿,正解也不过只是这个算法的小优化。
看到题，表达式？你联想到了什么？
~~放弃！~~

表达式树。
	
考虑递归建树，递归参数分别为 $l$,$r$。
有两个核心变量 $x$,$y$ （初值为 0）。
1. 若 $l$ $>$ $r$，说明当前节点不存储操作符，而是题中的“横线”，将节点总数加一，并直接将左右孩子编号设为0，返回当前节点编号即可。
2. 找到第一个在当前区间且不被括号包裹的“+”，若有，则将它的位置赋值给变量 $x$。
3. 再找到第一个在当前区间且不被括号包裹的“$\ast$”，若有，则将它的位置赋值给变量 $y$。 
4. 结束用于确定 $x$,$y$ 的循环后，若 $x$,$y$ 均为0，则说明当前区间左右端点构成一对括号，返回递归区间 $\left[l+1,r-1\right]$。
5. 若 $x$ 为0，则将 $y$ 赋值给 $x$ 。
6. 将总结点数加一，当前节点的左孩子编号为递归区间 $\left[l,x-1\right]$，右孩子编号为递归区间 $\left[x+1,r\right]$，操作符为输入字符串中的第 $x$ 个字符，返回当前节点编号。

然后呢？如何求答案？

显然的树形 dp。

令 $f(u,x)$ 表示表达式树上节点 $u$ 所表示的表达式取值为 $x$ 的情况有多少种。

根据两种运算的定义，易得转移方程。

+ 若 $u$ 处存储的运算符为"+"

	$f(u,1)=f(lc,0)f(rc,1)+f(lc,1)f(rc,0)+f(lc,1)f(rc,1)$

	$f(u,0)=f(lc,0)f(rc,0)$

+ 若 $u$ 处存储的运算符为"$\ast$"

	$f(u,0)=f(lc,0)f(rc,1)+f(lc,1)f(rc,0)+f(lc,0)f(rc,0)$
   
	$f(u,1)=f(lc,1)f(rc,1)$

其中 $lc$,$rc$ 分别指 $u$ 的左右孩子编号。答案为 $f(rt,0)$。($rt$ 为根节点）

八十分到手。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,mod=10007,INF=0x7fffff;
int n,rt,f[N][2],tot;

char s[N];

struct point{
	int lc,rc;//分别表示左孩子，右孩子 
	char op;//存储的符号 
}Exp[N];//表达式树节点 
int expTree(int l,int r)//建表达式树 
{
	int x=0,y=0,u;
	if(l>r)
	{
		u=++tot;
		Exp[u].lc=Exp[u].rc=0;
		return u;
	}//无符号，存储横线 
	for(int i=l;i<=r;i++)
	{
		if(s[i]=='(') tmp++;
		if(s[i]==')') tmp--;
		if(s[i]=='+') if(!tmp&&!x) x=i;
		if(s[i]=='*') if(!tmp&&!y) y=i;
	}
	if(!x&&!y) return expTree(l+1,r-1);
	if(!x) x=y;
	u=++tot;
	Exp[u].lc=expTree(l,x-1);
	Exp[u].rc=expTree(x+1,r);
	Exp[u].op=s[pos];
	return u;//这部分参考对表达式树的分析 
}
void dp(int u)//树形dp 
{
	if(Exp[u].lc==0&&Exp[u].rc==0)//若遍历到存储数值的节点， 直接触发边界条件 
	{
		f[u][0]=f[u][1]=1;
		return ;
	}
	int x=Exp[u].lc,y=Exp[u].rc;
	dp(x);dp(y);//先递归，再dp 
	if(Exp[u].op=='+')
	{
		f[u][0]=f[x][0]*f[y][0]%mod;
		f[u][1]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][1]*f[y][1])%mod;
	}
	if(Exp[u].op=='*')
	{
		f[u][1]=(f[x][1]*f[y][1])%mod;
		f[u][0]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][0]*f[y][0])%mod;
	}
	return ;//参照转移方程理解，别忘了取膜 QAQ 
}
int main()
{
	int tmp=0;
	scanf("%d\n%s",&n,s+1);
	int rt=expTree(1,n);
	dp(rt);
	cout<<f[rt][0]%mod;
    return 0;
}
```

# 2. AC
其实想要让你的屏幕发绿光，只要对上面的代码用数据结构优化即可。

这个时候你说：“都已经是一种数据结构了，还能用啥优化？”

~~爱与勇气~~

先分析为什么会 TLE，是那个万恶的 n 方建树。~~（n 方过百万，暴力碾标算）~~

看到建树的 2,3,4 操作，其实它们目的就是找出区间 $\left[l,r\right]$ 里优先级最小的。

看到这几个字眼：“区间”，“最小”。

想到了什么？

线段树！

形式化地，令 $priority(x)$ 表示字符串中第 $x$ 位的优先级，
括号的优先级为无穷大，动态记录当前操作符被包裹在几对括号里。设当前需处理的操作符为第 $x$ 个，它被包裹在 $K$ 对括号里。

+ 当第$x$位是“+”

	$priority(x)=2K+1$。

+ 当第$x$位是"$\ast$"
	
	$priority(x)=2K+2$。

预处理 $priority$ 数组，用线段树维护 $[l,r]$ 里优先级最小的字符的位置即可将复杂度优化为 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,mod=10007,INF=0x7fffff;
int n,rt,f[N][2],tot,priority[N];
#define lson p<<1
#define rson p<<1|1 
struct treePoint{
	int l,r,v,pos;
}sgt[N<<2];

void pushUp(int p)
{
	sgt[p].v=min(sgt[lson].v,sgt[rson].v);
	sgt[p].pos=(sgt[lson].v<sgt[rson].v ? sgt[lson].pos : (sgt[lson].v==sgt[rson].v ? min(sgt[lson].pos,sgt[rson].pos) : sgt[rson].pos));
}

void build(int p,int l,int r)
{
	sgt[p].l=l;sgt[p].r=r;
	if(l==r)
	{
		sgt[p].v=priority[l];
		sgt[p].pos=l;
		return ;
	}
	int mid=(l+r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	pushUp(p);
}

int query(int p,int l,int r)
{
	if(sgt[p].l==l&&sgt[p].r==r) return sgt[p].pos;
	int mid=(sgt[p].l+sgt[p].r)>>1;
	if(r<=sgt[lson].r) return query(lson,l,r);
	if(l>sgt[lson].r) return query(rson,l,r);
	int x=query(lson,l,mid);
	int y=query(rson,mid+1,r);
	return priority[x]<priority[y] ? x : (priority[x]==priority[y] ? min(x,y) : y);
}

char s[N];

struct point{
	int lc,rc;
	char op;
}Exp[N];
int expTree(int l,int r,int cnt)//cnt表示当前区间被包裹在几对括号里 
{
	int x=0,y=0,u;
	if(l>r)
	{
		u=++tot;
		Exp[u].lc=Exp[u].rc=0;
		return u;
	} 
	int pos=query(1,l,r);//优先级最小的操作符的位置 
	if(priority[pos]-2*cnt>2) return expTree(l+1,r-1,cnt+1); //没有一个运算符在括号外面 cnt加1 
	u=++tot;
	Exp[u].lc=expTree(l,pos-1,cnt);
	Exp[u].rc=expTree(pos+1,r,cnt);
	Exp[u].op=s[pos];
	return u;
}
void dp(int u)
{
	if(Exp[u].lc==0&&Exp[u].rc==0)
	{
		f[u][0]=f[u][1]=1;
		return ;
	}
	int x=Exp[u].lc,y=Exp[u].rc;
	dp(x);dp(y);
	if(Exp[u].op=='+')
	{
		f[u][0]=f[x][0]*f[y][0]%mod;
		f[u][1]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][1]*f[y][1])%mod;
	}
	if(Exp[u].op=='*')
	{
		f[u][1]=(f[x][1]*f[y][1])%mod;
		f[u][0]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][0]*f[y][0])%mod;
	}
	return ;
}
int main()
{
	int tmp=0;
	scanf("%d\n%s",&n,s+1);
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='(')tmp++,priority[i]=INF;
		if(s[i]==')')tmp--,priority[i]=INF;
		if(s[i]=='+') priority[i]=2*tmp+1;
		if(s[i]=='*') priority[i]=2*tmp+2;
	}//预处理 
	build(1,1,n);//建树
	int rt=expTree(1,n,0);
	dp(rt);
	cout<<f[rt][0]%mod;
    return 0;
}
```
 AC 啦！！！

这是我认为这道题最自然的思路，目前可以说是全新的思路，望管理员通过，也感谢每一个看到这里的 OIer 们。

---

## 作者：sjh0626 (赞：4)

## 思路分析
一道树形动规，根据题意 `*` 为与运算，`+` 为或运算，我们可以过一遍样例（`+(*)`）：

首先，我们先往一个编号栈里压入一个空节点，因为 $n$ 个操作符会有 $n+1$ 操作数。

遇到了 `+`，我们再压入一个空节点，因为前面没有 `+`，所以无法处理，直接压入符号栈。

随后，又进来了一个 `(`，因为 `(` 的优先级最低，直接压入符号栈。

遇到了 `*`，同理，压入空节点，因为前面没有比它优先级大或等于的，直接压入符号栈。

最后，到了 `)`，我们直接把前面的都处理一遍，直到左括号。

因为现在已经压入了 $3$ 个空节点，空节点为 $0$ 和 $1$ 的可能都为 $1$，直接处理 `*`，我们把栈上面两个空节点弹出，因为它们与起来的结果为 $0$ 有三种可能，与起来为 $1$ 有一种可能，所以压入一个为 $0$ 可能为 $3$，为 $1$ 可能为 $1$ 的节点。

因为符号栈里还有符号，所以我们继续处理，处理到了 `(`，不用计算，处理到了 `+`，继续弹出，它们或起来的结果为 $0$ 有 $3$ 种可能，结果为 $1$ 有 $5$ 种可能。

最终答案为 $3$。

根据样例，我们可以建一棵树，设这个节点为 $i$，左儿子为 $l$，右儿子为 $r$，推出方程，当符号为 $*$ 时，方程为：

```
dp[i][0] = dp[l][1] * dp[r][0] + dp[l][0] * dp[r][1] + dp[l][0] * dp[r][0]
dp[i][1] = dp[l][1] * dp[r][1]
```

其中 `dp[i][0]` 指编号为 $i$ 的节点为 $0$ 的可能，其他同理。

符号为 $+$ 时，方程为：

```
dp[i][1] = dp[l][1] * dp[r][0] + dp[l][0] * dp[r][1] + dp[l][1] * dp[r][1]
dp[i][0] = dp[l][0] * dp[r][0]
```

最后答案就是根节点为 $0$ 的可能性。

注意：

1. 要边运算边取模。
2. 只有为 `)` 或者符号栈顶比自己的的优先级大或等于才可以处理，计算可能性。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
#define ll long long
using namespace std;
const int P=10007;
const int N=100005;
stack<int>id;
stack<char>sta;
int n,cnt,f[N<<2][2];
void work(){
    int r=id.top();id.pop();
    int l=id.top();id.pop();
    char type=sta.top();sta.pop();
    ++cnt;
    if(type=='+')f[cnt][0]=f[l][0]*f[r][0]%P,f[cnt][1]=(((f[l][1]*f[r][1]%P)+(f[l][0]*f[r][1]%P)%P)+(f[l][1]*f[r][0]%P))%P;
    else f[cnt][1]=f[l][1]*f[r][1]%P,f[cnt][0]=(((f[l][0]*f[r][0]%P)+(f[l][0]*f[r][1]%P)%P)+(f[l][1]*f[r][0]%P))%P;
    id.push(cnt);
}
string t;
map<char,int>great; //优先级
signed main(){
    great['(']=-1,great['+']=0,great['*']=1; //处理优先级
    cin>>n>>t;
    id.push(++cnt); //插入空节点
    f[cnt][0]=f[cnt][1]=1; //初始化
    for(int i=0;i<n;i++){
        if(t[i]=='(')sta.push('(');
        else if(t[i]==')'){
            while(sta.top()!='(')work();
            sta.pop(); //处理左括号
        }
        else{
            while(sta.size()&&great[sta.top()]>=great[t[i]])work(); //遇到比自己优先级大或等于的就处理
            id.push(++cnt); //插入空节点
            f[cnt][0]=f[cnt][1]=1; //初始化
            sta.push(t[i]);
        }
    }
    while(sta.size())work(); //处理剩余
    cout<<f[cnt][0]; //输出答案
    sjh0626s code;
}
```

---

## 作者：ZHR100102 (赞：3)

[Blog](https://www.cnblogs.com/zhr0102/p/18876873)

这题就差把用表达式树树形 DP 写脸上了。

首先肯定是要**建表达式树**的。建出表达式树后，定义 $dp_{i,0/1}$ 表示节点 $i$ 取值为 $0/1$ 的方案数，分三种情况讨论即可：
- 该节点为叶子，$dp_{i,0/1}=1$。
- 该节点为与操作，$dp_{i,0}=dp_{l,0}\times dp_{r,0}+dp_{l,1}\times dp_{r,0}+dp_{l,0}\times dp_{r,1},dp_{i,1}=dp_{l,1}\times dp_{r,1}$。
- 该节点为或操作，$dp_{i,1}=dp_{l,1}\times dp_{r,1}+dp_{l,1}\times dp_{r,0}+dp_{l,0}\times dp_{r,1},dp_{i,0}=dp_{l,0}\times dp_{r,0}$。

其中 $l,r$ 分别代表 $i$ 的两个儿子。

注意几个建表达式树的细节：
- 当该字符为乘或加，且前一个字符为左括号时，需要添加一个叶子节点。
- 当该字符为乘或加，且后一个字符为左括号时，**不需要**添加叶子节点；否则添加叶子节点。
- 建表达式树可以在 `cal()` 函数中实现。
- 一个操作入栈后，只有**优先级大于等于它的操作**会被操作掉，**之后**这个操作才入栈（也就是说该操作目前并不执行）。
- 为了让所有操作都被执行，要在**表达式前后加括号**。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=1000005,mod=10007;
char s[N];
int n,stk1[N],tp1,stk2[N],tp2,cnt,a[N],dp[N][2];
vector<int>g[N];
void cal()
{
    g[++cnt].push_back(stk1[tp1--]);
    g[cnt].push_back(stk1[tp1--]);
    stk1[++tp1]=cnt;
    a[cnt]=stk2[tp2];
    tp2--;    
}
void dfs(int u)
{
    if(a[u]==0)
    {
        dp[u][0]=dp[u][1]=1;
        return;
    }
    int s1=g[u][0],s2=g[u][1];
    dfs(s1);
    dfs(s2);
    if(a[u]==1)
    {
        dp[u][0]=(dp[s1][0]*dp[s2][0]%mod);
        dp[u][1]=((dp[s1][0]*dp[s2][1]%mod)+(dp[s1][1]*dp[s2][0]%mod)+(dp[s1][1]*dp[s2][1]%mod))%mod;
    }
    else
    {
        dp[u][1]=(dp[s1][1]*dp[s2][1]%mod);
        dp[u][0]=((dp[s1][0]*dp[s2][1]%mod)+(dp[s1][1]*dp[s2][0]%mod)+(dp[s1][0]*dp[s2][0]%mod))%mod;
    }
}
int main()
{
    // freopen("P1310.in","r",stdin);
    // freopen("P1310.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>s+1;
    s[0]='(',s[n+1]=')';
    for(int i=0;i<=n+1;i++)
    {
        if((s[i]=='+'||s[i]=='*')&&(s[i-1]=='('))
            stk1[++tp1]=++cnt;
        if(s[i]=='+')
        {
            while(stk2[tp2]>=1)cal();
            stk2[++tp2]=1;
            if(s[i+1]!='(')stk1[++tp1]=++cnt;
        }
        else if(s[i]=='*')
        {
            while(stk2[tp2]>=2)cal();
            stk2[++tp2]=2;
            if(s[i+1]!='(')stk1[++tp1]=++cnt;
        }
        else if(s[i]=='(')
            stk2[++tp2]=-1;
        else
        {
            while(stk2[tp2]!=-1)cal();
            tp2--;
        }
    }
    dfs(cnt);
    cout<<dp[cnt][0]%mod;
    return 0;
}
```

---

## 作者：LINYUHENG2 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1310)
## 思路
首先说一下表达式计算的方法：   
需要使用两个栈，一个存放结果，另一个存放符号。  
每次读入一个数据，就进入结果栈，如果是符号，则按以下方法：   
1. 如果是左括号，就直接进栈；
2. 如果是右括号，就一直弹栈并加以计算，直到弹到左括号；  
3. 如果是运算符，则弹栈，直到这个运算符的优先级大于符号栈栈顶的符号的优先级。或是左括号或栈空，然后将运算符进栈；最后再将栈中残余的符号和结果一直弹到只剩一个结果，这个就是最后的结果。

此题算法的框架整体上是和表达式计算相同的，有以下几个方面不同：
1. 需要添加数字的地方应该满足不在右括号的后面或者左括号的前面；
2. 优先级：“$\times$”的优先级比“$\oplus$”高；
3. 运算方法，每一步计算为 $0$ 或 $1$ 的方法数：  
设两个步骤的运算结果经过每个符号到一个结果时，第一个运算结果算出 $0$ 的方案数为 $t1$，算出 $1$ 的方案数为 $t2$，第二个算出 $0$ 的方案数为 $t3$，算出 $1$ 的方案数为 $t4$，则有：  
当符号是“$\oplus$”时，得到 $0$ 的方案数为 $t1 \times t3$，得到 $1$ 的方案数为 $t1 \times t4 + t2 \times t3 + t2 \times t4$。当符号是“$\times$”时，得到 $0$ 的方案数为 $t1 \times t3 + t1 \times t4 + t2 \times t3$，得到 $1$ 的方案数为 $t2 \times t4$，用一个栈记录下来即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define 10007 MAXM
#define 100005 MAXN
using namespace std;

int n,i,u[MAXN],v[MAXN],top,k;
char c[MAXN],sta[MAXN],ans[2*MAXN];

int main(){
    scanf("%d\n%s",&n,c);
    ans[++k]='.';
    for(i=0;c[i];i++){
        if(c[i]=='('||c[i]=='*'){
        	sta[++top]=c[i];
		}
        if(c[i]=='+'){
            while(sta[top]=='*') ans[++k]=sta[top--];
            sta[++top]=c[i];
        }
        if(c[i]==')'){
            while(sta[top]!='(') ans[++k]=sta[top--];
            top--;
        }
        if(c[i]!='('&&c[i]!=')'){
        	ans[++k]='.';
		}
    }
    while(top>0){
		ans[++k]=sta[top--];
	}
    for(i=1;i<=k;i++){
        if(ans[i]=='.'){
            u[++top]=1;
            v[top]=1;
        }
        if(ans[i]=='*'){
            top--;
            u[top]=(u[top+1]*v[top]+u[top]*v[top+1]+u[top]*u[top+1])%MAXM;
            v[top]=v[top]*v[top+1]%MAXM;
        }
        if(ans[i]=='+'){
            top--;
            v[top]=(u[top+1]*v[top]+u[top]*v[top+1]+v[top]*v[top+1])%MAXM;
            u[top]=u[top]*u[top+1]%MAXM;
        }
    }
    printf("%d",u[1]);
}
```

---

## 作者：hzxphy (赞：2)

## 题目大意
给定一个中缀表达式（所有数均为未知数），求填出未知数使得表达式的值为 $0$ 的方案数。
## 思路
对于中缀表达式，有如下想法：
1. DFS 遍历直接做运算
2. 转为后缀表达式用栈运算。

由于枚举方案数时间复杂度为 $O(2^n)$，其中 $n$ 为需要填空的数量。且方案一没有中间过程，无法对其进行优化。我们排除方案一。果断转为后缀表达式。

假如找到了一种算法求得了答案，倒过来推会发现，运算位置在后，就越能够决定答案的值。可以联系到树的依赖关系。

在考虑方案二的中间过程后缀表达式，显然是能够转化为表达式树，这样对树的叶子节点进行填充就可以了。

对于树的计数，有三种方法：
1. 暴力，时间复杂度为 $O(2^n)$，同上，可排除此方案。
2. 排列组合，当然这个没有任何排列组合可以判定这个式子的值是否为 $0$，排除此方案。
3. 树形计数 DP，由于有子结构最优且父亲的值本身有子节点推导而来，所以这个方法可能可行。

由上述过程可知，我们应该在表达式树上树形计数 DP，由于节点值只有可能为二进制，即可能性较小，我们可以将其设为状态中的一维。考虑只有左右子树影响了本节点，所以定义时应当把一个子树看作一个整体作 DP。

这个时候我们可以定义出来 $dp_{i,0/1}$ 为以 $i$ 为节点的子树，计算值为 $0/1$ 时候的总方案数。

转移时可以用子树进行递推，下表为题目中的表格：
$$
\begin{array}{|c|c|} \hline
\qquad\qquad\quad\textsf{运算符}\qquad\qquad\quad & \qquad\qquad\quad\textsf{运算规则}\qquad\qquad\quad \\ \hline
\oplus &
\begin{aligned}
0 \oplus 0 &= 0 \\
0 \oplus 1 &= 1 \\
1 \oplus 0 &= 1 \\
1 \oplus 1 &= 1 \\
\end{aligned} \\ \hline
\times &
\begin{aligned}
0 \times 0 &= 0 \\
0 \times 1 &= 0 \\
1 \times 0 &= 0 \\
1 \times 1 &= 1 \\
\end{aligned} \\ \hline
\end{array}
$$
即运算符也应当影响计算值，分类讨论左子树为多少，右子树为多少时转移给该节点的 $0$ 状态还是 $1$ 状态即可。

最后答案输出因为根节点包含一切节点和自己，所以最终答案一定在根节点的 DP 值上，又问有多少种填法可以使得表达式的值为 $0$，所以答案应该为 $ans=dp_{1,0}$。

**注意：树形 DP 的时候，应该将子树看为一个叶子节点，不要管它的内部运算，你只需要知道现在它是多少即可。**

综上，此题得解。
## Code（含注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
int l;
string s;
int mp[200001],hp[200001],mpc,hpc;//中缀表达式位置和后缀表达式位置，定位表达式树。
struct Prior{
	char op;
	int id;
	int prior(){//运算符优先级（特别的，左括号为 0）。
		if(op=='(')return 0;
		else if(op=='+')return 1;
		else if(op=='*')return 2;
		return -1;
	}
	Prior(char c,int idx){
		op=c;id=idx;
	}
};
stack<Prior>stk;
struct Node{
	char op;
	int lc,rc;
}tree[200001];
int pntc;
void Getexp(void){//求得后缀表达式
	for(int i=1;i<=l;i++){
		if(s[i]=='('){//左括号直接入栈。
			stk.push(Prior('(',i));
		}
		else if(s[i]=='+'){
			while(!stk.empty()&&stk.top().prior()>=1){//把所有的加号和乘号都弹走。
				hp[++hpc]=stk.top().id;
				stk.pop();
			}
			stk.push(Prior('+',i));
		}
		else if(s[i]=='*'){//把所有的乘号都弹走。
			while(!stk.empty()&&stk.top().prior()>=2){
				hp[++hpc]=stk.top().id;
				stk.pop();
			}
			stk.push(Prior('*',i));
		}
		else{//一直弹一直爽，弹出第一个左括号时停止弹出。
			while(!stk.empty()&&stk.top().op!='('){
				hp[++hpc]=stk.top().id;
				stk.pop();
			}
			stk.pop();
		}
	}
	while(!stk.empty()){
		hp[++hpc]=stk.top().id;
		stk.pop();
	}
}
int zh[100001];
int BuildTree(int lm,int rm,int lh,int rh){//建立表达式树，我用的是中缀后缀确定唯一的树。
	if(lm>rm||lh>rh)return 0;
	int rt=hp[rh],mrt=zh[rt];
	tree[++pntc].op=s[rt];
	int rid=pntc;
	tree[rid].rc=BuildTree(mrt+1,rm,rh-(rm-mrt),rh-1);//右子树
	tree[rid].lc=BuildTree(lm,mrt-1,lh,rh-(rm-mrt)-1);//左子树
	return rid;
}
int dp[100001][2];//i节点为0/1的可能数
void DP(int u){
	if(u==0){
		dp[0][0]=dp[0][1]=1;
		return;
	}
	DP(tree[u].lc);
	DP(tree[u].rc);
//下面的转移方程根据表格可以得到。
	if(tree[u].op=='+'){
		dp[u][0]=dp[tree[u].lc][0]*dp[tree[u].rc][0]%10007;
		dp[u][1]=(dp[tree[u].lc][1]*dp[tree[u].rc][0]%10007+dp[tree[u].lc][0]*dp[tree[u].rc][1]%10007+dp[tree[u].lc][1]*dp[tree[u].rc][1]%10007)%10007;
	}
	else{
		dp[u][1]=dp[tree[u].lc][1]*dp[tree[u].rc][1]%10007;
		dp[u][0]=(dp[tree[u].lc][1]*dp[tree[u].rc][0]%10007+dp[tree[u].lc][0]*dp[tree[u].rc][1]%10007+dp[tree[u].lc][0]*dp[tree[u].rc][0]%10007)%10007;
	}
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
//	freopen("exp.in","r",stdin);
//	freopen("exp.out","w",stdout);
	cin>>l>>s;
	s=' '+s;
	//中序遍历
	for(int i=1;i<=l;i++){
		if(s[i]=='+'||s[i]=='*'){
			mp[++mpc]=i;zh[i]=mpc;
		}
	}
	Getexp();
	BuildTree(1,mpc,1,hpc);
	DP(1);
	cout<<dp[1][0];//根节点即为总值，由题可知。
	return 0;
}
```

---

## 作者：Kingna (赞：2)

## [[NOIP2011 普及组] 表达式的值](https://www.luogu.com.cn/problem/P1310)

### 题目描述

现给定一个未完成的表达式，例如 `_+(_*_)`，请你在横线处填入数字 $0 $ 或者 $1$，请问有多少种填法可以使得表达式的值为 $0 $。

### 思路

此题用 **笛卡尔树解决**。首先括号只需要用来解决优先级问题，比如当前的一个 `*` 被 $p$ 个括号包含，那么此优先级为 $2p+2$。如果一个 $+$ 被 $p$ 个括号包含，那么此优先级为 $2p+1$。我们用优先级的值来建立笛卡尔树。

比如表达式 `_+(_*_)`，其中 `+` 优先级为 $1$，`*` 优先级为 $4$，则笛卡尔树上 `*` 是 `+` 的右子节点。因为在递归计算方案数时，先算优先级高的，即深度高的。那么可以对此笛卡尔树开始 dp 了。定义 $f_{u,0/1}$ 表示笛卡尔树的 $u$ 子树，当前节点计算的答案为 $0/1$ 的方案数。

转移也是十分显然：对当前节点的运算符进行分类讨论即可：

![](https://cdn.luogu.com.cn/upload/image_hosting/1nxhiymb.png)

注意边界条件：$f_{u,0}=f_{u,1}=1$。因为在笛卡尔树建树的过程中，叶子节点的两个儿子被忽略了。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 3e5 + 5, mod = 10007;

int n, ls[N], rs[N], op[N], val[N], cnt, root, top, stk[N];
int f[N][2];
char a[N];

void dfs(int u) { // 树形 dp
	if (u == 0) return;
	dfs(ls[u]); dfs(rs[u]);
	if (op[u] == 1) {
		f[u][0] = f[ls[u]][0] * f[rs[u]][0] % mod;
		f[u][1] = (f[ls[u]][0] * f[rs[u]][1] % mod + f[ls[u]][1] * f[rs[u]][0] % mod + f[ls[u]][1] * f[rs[u]][1] % mod) % mod;
	}
	else {
		f[u][0] = (f[ls[u]][0] * f[rs[u]][1] % mod + f[ls[u]][1] * f[rs[u]][0] % mod + f[ls[u]][0] * f[rs[u]][0] % mod) % mod;
		f[u][1] = f[ls[u]][1] * f[rs[u]][1] % mod;
	}
}

signed main() {
	cin >> n >> (a + 1);
	int p = 0;
	_for(i, 1, n) { // 对运算符计算对应的优先级
		if (a[i] == '(') p++;
		if (a[i] == ')') p--;
		if (a[i] == '*') {
			val[++cnt] = 2 * p + 2;
			op[cnt] = 2;
		}
		if (a[i] == '+') {
			val[++cnt] = 2 * p + 1;
			op[cnt] = 1;
		}
	}
	_for(i, 1, cnt) { // 建立笛卡尔树
		int k = top;
		while (val[stk[k]] >= val[i] && k) k--;
		if (k) rs[stk[k]] = i;
		if (k < top) ls[i] = stk[k + 1];
		stk[++k] = i;
		top = k;
	}
	while (top) root = stk[top], top--;
	f[0][0] = f[0][1] = 1;
	dfs(root);
	cout << f[root][0] << endl;
}
```

---

## 作者：xmy201315 (赞：2)

[前置芝士](https://oi-wiki.org/dp/tree/)

在题目中，`*`号其实为`&`，`⊕`号其实为`|`。

对于这种表达式的题目，我们一般都要建一棵表达式树。这道题我也用到了树形 DP。其实大家应该都接触到过，在题目中叫你求这颗二叉树的大小，在某种意义上也是树形 DP。怎么整呢？我们在每个子树的空格处填入 $0$ 和 $1$，得到结果 $0$ 和 $1$ 的方案数分别是多少。以下图片中的 $L_0,L_1,R_0,R_1$ 分别表示左右子树算出来为 $0$ 和 $1$ 的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/na6oo1yq.png)

这个算出来为 $0$ 的方案数为 $L_0\cdot R_0+L_0\cdot R_1+L_1\cdot R_0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/x02o9bf5.png)

这个算出来为 $0$ 的方案数为 $L_0\cdot R_0$。

**AC code：**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 10007;
const int N = 101000;
struct info {
	int s0, s1;
};
int n, l1[N], l2[N], c1[N], c2[N];
char s[N];
info f(int l, int r) {
	info ans;
	if (l > r) {
		ans.s0 = 1;
		ans.s1 = 1;
		return ans;
	}
	if (l1[r] >= l) {
		info ansl = f(l, l1[r] - 1);
		info ansr = f(l1[r] + 1, r);
		ans.s0 = ansl.s0 * ansr.s0 % mod;
		ans.s1 = (ansl.s0 * ansr.s1 + ansl.s1 * ansr.s0 + ansl.s1 * ansr.s1) % mod;
		return ans;
	}
	if (l2[r] >= l) {
		info ansl = f(l, l2[r] - 1);
		info ansr = f(l2[r] + 1, r);
		ans.s1 = ansl.s1 * ansr.s1 % mod;
		ans.s0 = (ansl.s0 * ansr.s1 + ansl.s1 * ansr.s0 + ansl.s0 * ansr.s0) % mod;
		return ans;
	}
	if (s[l] == '(' && s[r] == ')')return f(l + 1, r - 1);
//	assert(false);
	return ans;
}
int main() {
	scanf("%d", &n);
	if (n == 0) {
		printf("1\n");
		return 0;
	}
	scanf("%s", s + 1);
	int x = 0;
	for (int i = 1; i <= n; i++) {
		if (s[i] == '(')x += 1;
		else if (s[i] == ')')x -= 1;
		else if (s[i] == '+')c1[x] = i;
		else if (s[i] == '*')c2[x] = i;
		l1[i] = c1[x];
		l2[i] = c2[x];
	}
	info ans = f(1, n);
	printf("%d", ans.s0);
} 
```

---

## 作者：Alex866 (赞：1)

## 题意分析

给定一个表达式，题目让我们求使得该表达式的值为 0 的方案数。

## 算法选取

由于~~我的注意力惊人~~这题涉及表达式和计数，所以我们可以先把表达式建树，再做一遍树形 DP 即可（好像有的题解比这简单的多）。

那如何建树呢？可以 ~~BDFS~~ 参考中缀表达式计算的过程，只不过把计算变成了创建节点。

然后就是树形 DP 了，这个式子很好想，只需要小学数学。

这里先把运算规则贴上：

$$
\begin{array}{|c|c|} \hline
\qquad\qquad\quad\textsf{运算符}\qquad\qquad\quad & \qquad\qquad\quad\textsf{运算规则}\qquad\qquad\quad \\ \hline
\oplus &
\begin{aligned}
0 \oplus 0 &= 0 \\
0 \oplus 1 &= 1 \\
1 \oplus 0 &= 1 \\
1 \oplus 1 &= 1 \\
\end{aligned} \\ \hline
\times &
\begin{aligned}
0 \times 0 &= 0 \\
0 \times 1 &= 0 \\
1 \times 0 &= 0 \\
1 \times 1 &= 1 \\
\end{aligned} \\ \hline
\end{array}
$$

其实这里的 $\oplus$ 是 `+` 而不是 `^`。我们设 $f_i$ 是当前树上结点的子树运算结果为 0 的方案数，$g_i$ 是当前树上结点的子树运算结果为 1 的方案数，为了方便描述，我们后面称 $l_i$ 为 $i$ 的左儿子，$r_i$ 为 $i$ 的右儿子。

先看加法，该节点的运算结果为 0 时，当且仅当左右子树均为 0，即 $f_i=f_{l_i}\times f_{r_i}$；结果为 1 时，当且仅当左右子树有一个为 1，即 $g_i=g_{l_i}\times f_{r_i}+f_{l_i}\times g_{r_i}+g_{l_i}\times g_{r_i}$。

再看乘法，该节点的运算结果为 0 时，当且仅当左右子树有一个 0，即 $f_i=g_{l_i}\times f_{r_i}+f_{l_i}\times g_{r_i}+f_{l_i}\times f_{r_i}$；结果为 1 时，当且仅当左右子树都为 1，即 $g_i=g_{l_i}\times g_{r_i}$。

## code

~~有点小压行，别介意。~~

```cpp
#include<bits/extc++.h>
using namespace std;
using namespace chrono;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
#define _FF(_Name,_Begin,_End) for(auto _Name=(_Begin);_Name<(_End);_Name++)
int n,cnt=0,opt[100005],dp[100005][2],r;
stack<int> st1,st2;
vector<int> g[100005];
string s;
function<void(void)> calc=[](){int r=st1.top();st1.pop();int l=st1.top();st1.pop();int op=st2.top();st2.pop();cnt++;g[cnt].push_back(l);g[cnt].push_back(r);opt[cnt]=op;st1.push(cnt);};
void dfs(int u){
	if(opt[u]==0){
		dp[u][0]=1;
		dp[u][1]=1;
		return;
	}
	int l=g[u][0],r=g[u][1];
	dfs(l);
	dfs(r);
	if(opt[u]==1){
		dp[u][0]=dp[l][0]*dp[r][0]%10007;
		dp[u][1]=((dp[l][0]*dp[r][1]%10007+dp[l][1]*dp[r][0])%10007+dp[l][1]*dp[r][1])%10007;
	}else{
		dp[u][1]=dp[l][1]*dp[r][1]%10007;
		dp[u][0]=((dp[l][0]*dp[r][1]%10007+dp[l][1]*dp[r][0])%10007+dp[l][0]*dp[r][0])%10007;
	}
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	cout.tie(0);
	cin>>n>>s;
	s="("+s+")";
	_FF(i,0,s.length()){
		if(s[i]=='+'||s[i]=='*'){
			if(i>0&&s[i-1]=='('){
				cnt++;
				opt[cnt]=0;
				st1.push(cnt);
			}
			if(s[i]=='+'){
				while(!st2.empty()&&st2.top()>=1){
					calc();
				}
				st2.push(1);
				if(i+1<s.length()&&s[i+1]!='('){
					cnt++;
					opt[cnt]=0;
					st1.push(cnt);
				}
			}else if(s[i]=='*'){
				while(!st2.empty()&&st2.top()>=2){
					calc();
				}
				st2.push(2);
				if(i+1<s.length()&&s[i+1]!='('){
					cnt++;
					opt[cnt]=0;
					st1.push(cnt);
				}
			}
		}else if(s[i]=='('){
			st2.push(-1);
		}else if(s[i]==')'){
			while(st2.top()!=-1){
				calc();
			}
			st2.pop();
		}
	}
	while(!st2.empty()&&st2.top()!=-1){
		calc();
	}
	r=st1.top();
	dfs(r);
	cout<<dp[r][0];
	return 0;
}
```

---

## 作者：xiaoyunhao (赞：1)

# 题目传送门
[题目](https://www.luogu.com.cn/problem/P1310)


---

这道题可以理解为升级版的表达式求值，先说一下普通的表达式求值：首先需要用到两个栈，一个记录答案，一个记录符号。


1.  碰到左括号，入符号栈。

2.  碰到运算符号，弹出优先级比自己高或相等的符号，再加以计算。

3.  碰到右括号，不断弹出并计算，直到碰到左括号。

这道题与表达式求值不同点在于，它~~更难~~没有数字参与运算，需要我们自己加入，计算也和正常运算有区别。

#### 怎样运算
如果为乘号 $s0=a0 \times b0+a0\times b1+a1\times b0$，$s1=a1\times b1$。如果为加号，$s0=a0\times b0$，$s1=a1\times b1+a1\times b0+a0\times b1$。

如果还有不清楚的，请看代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int p=10007;
string s;
stack<char>f;
struct node {
	int a0,a1;
};
stack<node>j;
signed main() {
	cin>>n;
	cin>>s;
	n+=2;
	s=" ("+s+")";
	for(int i=1; i<=n; i++) {
		if((s[i]=='+'||s[i]=='*')&&s[i-1]=='('){
			j.push((node){
				1,1
			});
		}
		if(s[i]=='(') {
			f.push('(');
		} else if(s[i]=='*') {
			int ans1=j.top().a1,ans0=j.top().a0;
			j.pop();
			while(f.top()=='*') {
				f.pop();
				int s0=j.top().a0,s1=j.top().a1;
				int ss0=ans0*s0+ans0*s1+ans1*s0,ss1=ans1*s1;
				ans0=ss0;
				ans1=ss1;
				ans0%=p;
				ans1%=p;
				j.pop();
			}
			f.push('*');
			j.push((node) {
				ans0,ans1
			});
		} else if(s[i]=='+') {
			int ans1=j.top().a1,ans0=j.top().a0;
			j.pop();
			while(f.top()!='(') {
				int s0=j.top().a0,s1=j.top().a1;
				j.pop();
				int ss0,ss1;
				if(f.top()=='*') {
					ss0=ans0*s0+ans0*s1+ans1*s0,ss1=ans1*s1;
				} else if(f.top()=='+') {
					ss0=ans0*s0,ss1=ans1*s0+ans1*s1+ans0*s1;
				}
				ans0=ss0;
				ans1=ss1;
				ans0%=p;
				ans1%=p;
				f.pop();
			}
			f.push('+');
			j.push((node) {
				ans0,ans1
			});
		} else if(s[i]==')') {
			int ans1=j.top().a1,ans0=j.top().a0;
			j.pop();
			while(f.top()!='(') {
				int s0=j.top().a0,s1=j.top().a1;
				j.pop();
				int ss0,ss1;
				if(f.top()=='*') {
					ss0=ans0*s0+ans0*s1+ans1*s0,ss1=ans1*s1;
				} else if(f.top()=='+') {
					ss0=ans0*s0,ss1=ans1*s0+ans1*s1+ans0*s1;
				}
				ans0=ss0;
				ans1=ss1;
				ans0%=p;
				ans1%=p;
				f.pop();
			}
			j.push((node) {
				ans0,ans1
			});
			f.pop();
		}
		if((s[i]=='+'||s[i]=='*')&&s[i+1]!='(')
		{
			j.push((node){
				1,1
			});
		}
	}
	cout<<j.top().a0;
	return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P1310)

---

# 思路：

首先这道题目，我们要先搞清楚我们如何从前往后推出答案。可以肯定的是，在出现某个特定符号的时候，我们要知道如何从已知答案中推出之后的答案。这其实就是一个用公式递推的过程。每一步计算下一步答案为 $0$ 或 $1$ 的方法数：设两个步骤的运算结果经过每个符号到一个结果时，第一个运算结果算出 $0$ 的方案数为 $t1$，$1$ 的方案数为 $t2$。第二个算出 $0$ 的方案数为 $t3$，算出 $1$ 的方案数为 $t4$，则有：当符号是“$\oplus$”时，得到 $0$ 的方案数为 $t1 \times t3$，$1$ 的方案数：$t1\times t4+t2\times t3+t2\times t4$，当符号是“$\times$”时，得到 $0$ 的方案数为 $t1\times t3+t1\times t4+t2\times t3$，$1$ 的方案数：$t2\times t4$。用一个栈记录下来即可。

然后按以下方法计算：

1. 如果是左括号，就直接进栈；
2. 如果是右括号，就一直弹栈并加以计算，直到弹到左括号；
3. 如果是运算符，则弹栈，直到这个运算符的优先级大于符号栈栈顶的符号的优先级或是左括号或栈空，然后将运算符进栈；
4. 最后再将栈中残余的符号和结果一直弹到只剩一个结果，这个就是最后的结果。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
const int mod=10007;
char val[N];
stack<char>fu;
string s;
int len,len1,len3,ans0[N],ans1[N];
signed main(){
    val[len1]='.';
    len1++;
    cin>>len>>s;
    for(int i=0;i<len;i++){
        if(s[i]=='('){
            fu.push(s[i]);
        }
        if(s[i]=='+'||s[i]=='*'){
            if(fu.empty()){
                fu.push(s[i]);
            }else if(fu.top()=='('){
                fu.push(s[i]);
            }else{
                while(!fu.empty()&&fu.top()=='*'){
                    val[len1]='*';
                    len1++;
                    fu.pop();
                }
                fu.push(s[i]);
            }
        }
        if(s[i]==')'){
            while(!fu.empty()&&fu.top()!='('){
                val[len1]=fu.top();
                len1++;
                fu.pop();
            }
            if(!fu.empty()&&fu.top()=='('){
                fu.pop();
            }
        }
        if(s[i]!=')'&&s[i]!='('){
            val[len1]='.';
            len1++;
        }
    }
    while(!fu.empty()){
        val[len1]=fu.top();
        fu.pop();
        len1++;
    }
    for(int i=0;i<len1;i++){
        if(val[i]=='.'){
            len3++;
            ans0[len3]=1;
            ans1[len3]=1;
        }else if(val[i]=='+'){
            len3--;
            ans1[len3]=(ans1[len3]*ans1[len3+1]%mod+ans1[len3]*ans0[len3+1]%mod+ans1[len3+1]*ans0[len3]%mod)%mod;
            ans0[len3]=(ans0[len3]*ans0[len3+1])%mod;
        }else{
            len3--;
            ans0[len3]=(ans0[len3]*ans0[len3+1]%mod+ans1[len3]*ans0[len3+1]%mod+ans0[len3]*ans1[len3+1]%mod)%mod;
            ans1[len3]=(ans1[len3]*ans1[len3+1])%mod;
        }
    }
    cout<<ans0[1]%mod<<endl;
    return 0;
}
```
完结撒花

---

## 作者：MMXIandCCXXII (赞：0)

## Solution

做这种题的一个技巧就是把他当作普通的表达式求值，维护你需要的东西，根据运算规则对其操作。知道逻辑之后，代码就一目了然了。

  这道题我们维护两个东西：结果是 0 的方案数和结果是 1 的方案数。当我们遇到与的时候 0 的方案就是 00 01 10 三种情况，或的时候就是 00 一种，1 同理。乘法原理和加法原理。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 10007;
struct node
{
	int x, y;
};
stack <node> num;
stack <char> op;

void get()
{
	node b = num.top ();
	num.pop ();
	node a = num.top ();
	num.pop ();
	char c = op.top ();
	op.pop ();
	node newn;
	if (c == '+')
	{
		newn.x = a.x * b.x % mod;
		newn.y = (a.y * b.x + a.x * b.y + a.y * b.y) % mod;
	}
	else
	{
		newn.y = a.y * b.y % mod;
		newn.x = (a.y * b.x + a.x * b.y + a.x * b.x) % mod;
	}
	num.push (newn);
}

signed main()
{
	int n;
	cin >> n;
	char last = ' ';
	for (int i = 1; i <= n; i++)
	{
		char c;
		cin >> c;
		if (c == '(') op.push (c);
		else
		{
			if (last != ')') num.push ({1, 1});
			if (c == ')')
			{
				while (op.top () != '(')
					get ();
				op.pop ();
			}
			if (c == '+')
			{
				while (op.size () && op.top () != '(')
					get ();
				op.push (c);
			}
			else if (c == '*')
			{
				while (op.size () && op.top () == '*')
					get ();
				op.push (c);
			}
		}
		if (i == n && c != ')') num.push ({1, 1});
		last = c;
	}
	while (op.size ())
		get ();
	cout << num.top ().x % mod << endl;
	return 0;
}
```

---


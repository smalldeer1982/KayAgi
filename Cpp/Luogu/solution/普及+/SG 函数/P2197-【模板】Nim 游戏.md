# 【模板】Nim 游戏

## 题目描述

甲，乙两个人玩 nim 取石子游戏。

nim 游戏的规则是这样的：地上有 $n$ 堆石子（每堆石子数量小于 $10^4$），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这 $n$ 堆石子的数量，他想知道是否存在先手必胜的策略。


## 样例 #1

### 输入

```
2
2
1 1
2
1 0```

### 输出

```
No
Yes```

# 题解

## 作者：Tarsal (赞：262)

最近学了一点博弈论。

来写写blog造福人民(~~怕自己忘了~~)希望可以写出一篇比较好懂的文章,这里没有一些绕口的定义，也没有什么麻烦的代码，只有思维上的火花：

---

## 先来讨论讨论什么是博弈论:

博弈论就是指有若干个人进行一些对弈，并且窝们默认每个人都是最聪明的，不会失误，都可以找到当前的最优解，然后来寻找有没有哪个人有必胜/必败的的策略。

---

## 前置芝士：

窝们可以把一场博弈看成一颗树，以第一步为根，引出多叉。

感谢 [$Mital$](https://www.luogu.org/space/show?uid=30036) 的指出，这里并不可以当成一颗树，需要当成一张有向无环图，但是为了方便在文字中区分它连向的边和连向它的边，所以还是用颗树来表示(~~其实是我懒~~

对于每个节点，它的子树表示它可以如何递归下去；

比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/eu4j39wt.png)

0这个状态可以向1这个状态递推过去，也可以向2这个状态递推过去。

窝们考虑什么时候0这个状态是必胜的？

># 必胜是对于当前这个状态是必胜的，与是谁无关，赢的人只是处于一个胜的状态而已；

这句话，我觉得是博弈论的灵魂，窝们每个必胜的状态都是从对手的上个必败状态推来的，必败也是同理。

如上图，窝们当前是出于0这个状态，窝们想必胜，那么在下一个状态(对手选择)时，别人时必败的，这样窝们才能必胜。

所以，窝们只要在当前这个节点的子树中寻找它的子节点是否存在子节点必败。

如果，它的子节点中不存在必败的，那么这个状态就没有必胜的对策。

反过来一样是成立的：如果它的子节点都是必胜的，那么当前这个状态就显然是必败的。

>## 结论：
###如果当前状态必输，那么这个人可以转换到的局面一定必赢；
###如果一种状态必赢，那么一定可以转换到一种必输的状态。

---

## 最基础的博弈——巴什博弈：

先讲讲什么是巴什博弈，有n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取 $m$ 个。最后取光者得胜。

>### 窝们先不看这道题，窝们先考虑 $m = 2$ 的情况，每次只能取$1/2$，那么应该怎么做？这个应该还是很好想；

窝们先考虑什么情况是必胜：

显然，当你取完后还剩 $0$ 个是必胜的，这个总不会有问题吧。这个时候在你取之前还剩 $1/2$ 个。

然后，什么情况是必败：

当你取完还剩 $1/2$ 的时候，别人是必胜的，你是必败的。这个时候在你取之前还剩 $3$ 个。

必胜：

当你取完后还剩 $3$ 个是必胜的，这个可以由前面的必败状态可以推出来(就换了个对象，我前面说过必胜是对于当前这个状态是必胜的，与是谁无关，赢的人只是处于一个胜的状态而已)，这个时候在你取之前还剩 $4/5$ 个。

必败：

当你取完还剩 $4/5$ 的时候，别人是必胜的，你是必败的。这个时候在你取之前还剩 $6$ 个，这也可以从前面那个必胜状态推出来。

到这里窝们就可以找到规律了，这个结果是不断递归的。窝们每个必胜的状态都是从对手的上个必败状态推来的，必败也是同理。

#### 所以，当取前的数值为 $3 * k$ 的时候为先手必败。

#### 其余的都是先手必胜。

>### 窝们再来分析分析 $m = 3$ 的情况，只能取 $1/2/3$ 的情况，同理我们还是来分析什么时候先手必胜，什么时候先手必败。

必胜：

当你取完后还剩 $0$ 个是必胜的，这个总不会有问题吧。这个时候在你取之前还剩 $1/2/3$ 个。

必败：

当你取完还剩 $3/2/1$ 的时候，别人是必胜的，你是必败的。这个时候在你取之前还剩 $4$ 个。

必胜：

当你取完后还剩$4$个是必胜的，这个不多BB。这个时候在你取之前还剩 $5 / 6 / 7$ 个。

必败：

当你取完还剩$7/6/5$的时候，别人是必胜的，你是必败的。这个时候在你取之前还剩$8$个，这也可以从前面那个必胜状态推出来。

#### 所以，当取前的数值为 $4 * k$ 的时候为先手必败。

#### 其余的都是先手必胜。

>### 再来看原题，窝们是不是可以大胆猜测：

#### 当取前的数值为 $(m + 1) * k$ 的时候为先手必败。

#### 其余的都是先手必胜。

这个就是正确的结论，接下来是理性的证明：

窝们考虑对于每个状态，可以推向那里？

显然，当你取完是 $0$ 的时候是必胜的，此时你取之前的 $1$~$m$

当你取完是 $1,2,3……m$ 的时候是必败的，此时你取之前的 $m + 1$

当你取完是 $m + 1$ 的时候是必胜的，此时你取之前的 $(m + 2)$ ~ $(2 * m + 3)$

当你取完是 $m + 2,m + 3, m + 4 …… 2 * m + 3$ 的时候是必败的，此时你取之前的 $2 * m + 4$；

到这里，窝们就可以找到规律了；

>### 当$n = (m + 1) * k$的时候先手是必败的
### 其他的都是先手必胜状态

---


## [nim游戏](https://www.luogu.org/problem/P2197)


这是个比较经典的博弈论的~~板子~~题，题目大概的意思是：有 $n$ 堆数，每堆有 $s_i$ 个，每次可以且仅可以取一堆中的若干个数，求问先手有没有必胜策略。

这是窝做博弈论的题的一些小技巧：先研究一些比较显然的必胜/必败策略，比如说，我们要得到$0$这个数，那么当你取完时还剩0个，你就显然是胜的。

然后再通过最后的这个显然的必胜状态，往前递推找出其余的必胜状态。

显然博弈论是必然会出现循环节的，因为它是一种不断递归求解的过程，每次都可以取到当前这个循环节上的必胜状态，并且让你的对手能达到的下个状态全部都是必败状态，那样你就可以稳了。

窝们来分析nim游戏这道题，窝们还是先考虑什么状态下是必胜的：

先讲结论，如果 $s_1$ ^ $s_2$ ^ $s_3$ ^ …… ^ $s_n$ == $0$ 就是先手必败；其余都是先手必胜。


>### 还是先考虑他的子问题：当 $n == 1$ 的时候:这个显然是先手必胜，因为直接全部取掉就好。


这里是不是 $s_1$ != 0，也可以理解为 $s_1$ ^ 0 = s;


>### 当 $n == 2$ 的情况：窝们就考虑一堆的石头和另一堆相不相等


如果一堆的石头和另一堆相等，那么不论先手取什么，后手都只需要跟着先手取相同的个数就行了。这是先手必输。

此时窝们可以考虑为： $s_1$ ^ $s_2$ = $0$ ;

如果一堆的石头和另一堆不相等，那么先手就在多的那一堆里面取出两堆直接的差值；

然后就转移到了上面那个状态，不过对象换了，这也符合窝的想法：必胜是对于当前这个状态是必胜的，与是谁无关，赢的人只是处于一个胜的状态而已。这是先手必胜。

此时可以理解为 $s_1$ ^ $s_2$ = $s$ ( $s$ 为非零数)；


>### 现在，窝们再来把这个问题扩展到 $n$：


显然，当我取完后每堆石头的数量都为 $0$ 的时候，我是胜的。

窝们可以得出最终获胜式子为: $0$ ^ $0$ ^ $0$ ^ $0$ ^ $0$ ^ $0$ = $0$ ;

窝们再来看看它的最初的状态: $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$ ;

窝们下一步期望达到的状态应该是 $news_1$ ^ $news_2$ ^ $news_3$ ^ $news_4$ = $0$ ;

窝们再来想想，如果任意的一个状态 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$ 可以转移成 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $0$ ;

那么它的下一个状态一定会是 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $ss$ ；

因为取一堆数的异或和为0，并且窝们修改且只修改其中的一个元素，是无法维持 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $0$ 的。

所以你的对手(下一个状态)肯定又会变成一个 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $news$ 的形式；

如果你可以继续把 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $news$ 变成这个 $news_1$ ^ $news_2$ ^ $news_3$ ^ $news_4$ = $0$。

那是不是就可以把这一次一次操作当一个以2为循环周期的循环节，每次前者取到的值为 $x$ (注意这里的 $x$ 并不是一个固定的数，$x$ 是一个抽象的概念，你们可以理解为非零数)，后者取到的值为 $0$ 。

最后取到 $0$ ^ $0$ ^ $0$ ^ $0$ ^ $0$ ^ $0$ = $0$ 这个式子的一定就是你，因为你的对手根本就没有取到过异或和为0的状态，所以你是必胜的。

接下来，来讲一下为什么对于任意的一个状态 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$ 可以转移成 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $0$ ;

窝们再会过来分析这个等式：$s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$；

窝们来分析 $s$ 这个数的由来，窝们肯定可以找到 $s$ 这个数的最高位(第 $k$ 位)为 $1$ 是吧， $0$ 是做不了第一位的。

既然窝们可以找到数 $s$ 的第 $k$ 位为 $1$ ，那么这一位是怎么来的？在异或运算中是不存在进位的，所以这个 $1$ 肯定是第 $k$ 位这一位上面算出来的，又因为它是异或，所以在前面的 $s_1$ 到 $s_n$ 中必然存在奇数个 $1$ ;

而我们只需要找到一个数这一位(第 $k$ 位)为 $1$ 就行了，多个的话只需要其中一个就行了，另外几个也是可行的方案。

现在，窝们找到了 $s_i$ 的第 $k$ 为 $1$ ，窝们的目的是要使 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$ 转移成 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $0$ ;那么在异或的意义下如何把 $s$ 变成 $0$ 嘞?

窝们都知道一个数异或上它自己，答案肯定是 $0$ ;那么窝们就把等式两边同时异或上 $s$ ，等式右边不就是 $0$ 了吗？

等式化成了这个亚子: $s$ ^ $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$ ^ $s$ = $0$.

我接下来要做的是不是把等式左边的 $s$ 与一个 $s_i$ 相融合，因为这个问题窝一次只可以变小一堆，所以 $s$ ^ $s_i$ 要得到一个小于 $s_i$ 的新数。

那么，窝们在这之前是不是找到了一个数在 $s$ 的最高位(第 $k$ 位)等于 $1$ ，可以设它位 $s_k$ ，它的第 $k$ 位为 $1$ 。

如果 $s$ ^ $s_k$ 是不是会对他们的每一位进行异或运算?

 如果 $s_k$ 的位数要高于 $s$ 那么它前面高出的那几位是不会变的，在第 $k$ 位上，$s_k$ ^ $s$ 得到的答案应该是 $0$ ；
 
 又因为 $s_k$ 的前几位不变，第 $k$ 位从 $1$ 变成了 $0$ ，所以它是变小了的，这满足了窝们每次从一堆数中取出部分(将原数减小)的要求。也满足了将任意 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $s$ 转移成 $s_1$ ^ $s_2$ ^ $s_3$ ^ $s_4$ = $0$ 。

 如何，你不断的将异或和变成 $0$ ，别人只能被动的把异或和变成 $s$ ，又因为最后获胜的时异或和要为 $0$ ，所以不断取 $0$ 的时必胜的。

 >### 如果将每堆数相互异或得到的和为 $0$ ，则先手必败。
### 如果将每堆数相互异或得到的和不为 $0$ ，则先手必胜。

这个代码也很好写：

```
#include<bits/stdc++.h>

using namespace std;

const int dx[5] = {0, 1, -1, 0, 0};
const int dy[5] = {0, 0, 0, 1, -1};

//#define XRZ
//#define int long long
#define maxn 10010
#define maxm
#define ll long long
#define mian main
#define inf 0x3f3f3f3f
#define debug(x) printf("now here is %d\n", x);
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout);
#define Rep(x, a, b) for(int x = a; x <= b; ++ x)
#define Dep(x, a, b) for(int x = a; x >= b; -- x)
#define Next(x, u) for(int i = head[u]; i ; i = e[i].nxt)
int t, n, a[maxn];
signed mian(){
	scanf("%d", &t);
	while(t --){
		scanf("%d", &n); int ans = 0;
		Rep(i, 1, n) scanf("%d", &a[i]), ans ^= a[i];//维护其异或和
		if(ans == 0) puts("No"); else puts("Yes");
	}
    return 0;
}
```

---

ps:都是一些最近学的时候的理解。蒟蒻刚开始学如有错误，请各位大佬指出。还会在自己学的同时放一些自己的理解上来。如有什么不懂，可以私信我，我在对其进行更改。


---

## 作者：曦行夜落 (赞：126)

## 结论大家都讲过了，这里来重点研究$SG$函数的所以然

（看到这里大都直接感性理解或者上结论决定来写写）

[参考资料](https://zhuanlan.zhihu.com/p/20611132)

### 【Part1——策梅洛定理】

我们考虑对于一个游戏，他满足以下的特点

- 两人单挑，轮流操作

- 信息公开透明

- 没有随机因素

- 有限步内必然结束

- 不存在平局

#### 策梅洛定理：对于这样的一个游戏，任何一个局面先手或者后手其中之一必然存在必胜策略

证明：

- 如果已经到了最终状态，按照游戏规则，必然有一方已经获胜

- 如果当前状态**所有**后继都导向先手必胜，那么本状态先手必败

- 如果当前状态**可以**导向先手必败，那么本状态先手必胜

所以每一个状态的胜负都可以被确定

所以这些游戏可以使用记忆化搜索暴力解决

#### 举例：报数游戏

显然这符合上述五项要求

一个数字初始为$0$，甲乙两人每次加上$1,2,3$中其中一个，达到$21$的人立刻获胜

设$S[x]$表示数字为$x$时胜负确定情况，$1$先手必胜，$0$先手必败

那么$S[21]=0$，因为此时先手没得报，无子可动判负

根据上述证明过程，可以发现

$18,19,20$均可以通过一次报数转移到必败状态$21$，所以他们全都是必胜态，以此类推，可以得出本游戏先手有必胜策略，$S[0]=1$

### 【Part2——状态的组合I】

参见[题面](https://www.luogu.com.cn/problem/P2197)

对于Nim游戏来说，无论几堆石子，我们都可以把石子一堆一堆拉出来讨论

像Nim游戏这样的可拆分游戏，满足两个条件

- 双方操作对等，操作集合只和局面有关

- 双方游戏目标相同

这样的情况下，双方不需要考虑这一步走完以后下一个人操作集合不同的情况，是一个公平游戏

这样的情况下，把游戏拆分成子游戏（比如把每一堆石子单拉出来讨论，或把某几堆单拉出来讨论）不会有任何影响，因为子游戏中操作和目标依然对等，所以这样的游戏是可拆分的

#### 那么进一步讨论胜负状态的组合

如果一个游戏满足五项要求和公平游戏原则，比如Nim游戏，那么他的胜负状态不仅可以确定，而且可以随着子游戏的组合而组合

这里考虑两个子游戏的组合，因为一旦实现了两个子游戏之间的组合，就可以实现任意个的组合

（这里的游戏规定无子可动判负）

- **假如我面前摆着两个必败的游戏，实际上我必败**

	必败的走一步必然走到必胜的（证明过程）

	等会对面再把另一个变成必败的，我又收到了两个必败游戏

	最后我会收到两个无子可动的终盘游戏，我败了

- **假如我面前摆着一败一胜的游戏，实际上我必胜**

	必胜的走一步能走到必败的（证明过程）

	对面会收到两个必败，对面一定会输

- **假如我面前摆着两个必胜游戏，我不能确定**

	随便举个例子，对于Nim游戏，随便拉出来一堆，先手肯定必胜，因为直接取光就好

	但如果面前放着两堆呢？

	这时候就要讨论了吧？

但是Nim游戏不是可以确定的吗？

我们先前的努力，並不是全部白费的，因为我们发现，必胜局面和必胜局面是不可以相提并论的——

### 【Part3——SG函数的登场】

考虑一堆石子的情况

$0$是必败态，显然

$1$是必胜态，直接拿掉就好

$2$是必胜态，但是特殊情况出现了

$2$可以转移到$1$这个必胜态，也可以转移到$0$这个必败态

显然你要赢往必败态转移就好，但是实际情况中，肯定不止这一堆，上面已经说明了两个局部的必胜无法达成总体的必胜

这时候引入一个概念——**状态的阶数**

对于必败态，阶数为$0$

对于$1$这样的只能转移到必败态的必胜态，阶数为$1$

而对于$2$这样的，既可以转移到必败态，也可以转移到$1$阶状态的必胜态，阶数为$2$

同样，对于$3$，他可以转移到$0,1,2$，所以是$3$阶状态

**阶数的定义：能转移到$0$至$n-1$中任一阶状态的状态，称为$n$阶状态**

接下来找主角出来：

**定义状态$x$的阶数为$SG(x)$**

由此可见，$SG(x)>0$时$x$为必胜态，$SG(x)=0$时$x$为必败态

同时根据上述原则，还可以观察出$SG(x)$的计算方法

$SG(x)=mex \{ SG(y)|x->y \} $

其中$mex$表示集合中未出现的最小的整数，$x->y$表示$y$是$x$的后继状态

这就很好理解了，这个整数以下的所有阶数都可以被取到，那么这个整数就是状态的阶

所以$mex$是这样出现的哦

### 【Part4——状态的组合II】

回过头来看放在我们面前的两个必胜态

- 如果二者同阶，那么不管我怎么动，对面总能反手丢给我两个同阶状态，最后我会面对两个零阶状态然后输掉

- 如果二者不同阶，那么我可以丢给对面两个同阶状态，他输定了

观察出来，不难发现两个同阶状态放一起必败，不同阶必胜，再回去看看两个必败和一胜一败的分析，更加证实了我们的观点

### 【Part5——SG定理】

那么我们来探究一下对于$x$和$y$的组合状态$z$即$x+y=z$，$SG(x),SG(y),SG(z)$的关系吧

先找规律

$SG(x)=0,SG(y)=0$，两必败组合为必败,$SG(z)=0$

$SG(x)=1,SG(y)=0$，一个一阶态和一个必败态，后继只能是两个必败态，所以$SG(z)=1$

$SG(x)=1,SG(y)=1$，同阶状态必败，$SG(z)=0$

又因为每个子游戏之间地位平等，$SG$组合满足**交换律**，**结合律**

那么推广到一个$SG(x)=k,SG(y)=0$呢？

那么只有$x$可以被降阶到$0$至$k-1$阶，所以$SG(z)=k$

初步总结一下，$SG$数的组合运算满足以下规律

- 交换律，结合律

- 单位元是$0$，也就是和零阶组合阶数不变

- 逆元是自己，也就是和同阶组合必败

**到这里我们根据性质初步猜测$SG$按照异或组合**

再考虑$SG(x)=1,SG(y)=2$

那么后继状态存在下面的阶数组合

$SG(x')=0,SG(y)=2,SG(z_1)=2$

$SG(x)=1,SG(y'_1)=1,SG(z_2)=0$

$SG(x)=1,SG(y'_2)=0,SG(z_3)=1$

根据计算法则，$SG(z)=3$，诶，对了

再来几组：

$SG(x)=1,SG(y)=3$

那么后继状态存在下面的阶数组合

$SG(x')=0,SG(y)=3,SG(z_1)=3$

$SG(x)=1,SG(y'_1)=2,SG(z_2)=3$

$SG(x)=1,SG(y'_2)=1,SG(z_3)=0$

$SG(x)=1,SG(y'_3)=0,SG(z_4)=1$

根据计算法则，$SG(z)=2$

$SG(x)=2,SG(y)=3$

同理

$SG(x'_1)=1,SG(y)=3,SG(z_1)=2$

$SG(x'_2)=0,SG(y)=3,SG(z_2)=3$

$SG(x)=2,SG(y'_1)=2,SG(z_3)=0$

$SG(x)=2,SG(y'_2)=1,SG(z_4)=3$

$SG(x)=2,SG(y'_3)=0,SG(z_5)=2$

故$SG(z)=1$

由此观察得到，当$x+y=z$的时候$SG(z)=SG(x) \ xor\ SG(y)$

**注意，这里的$x+y$指的是局面上的组合而非数量加和！$SG(2)$和$SG(4)$的组合应该是$SG(2,4)$，此处意义下$2+4=(2,4)$**

由结合律可以推广：

$SG(x)=SG(x_1+x_2+...+x_n)=SG(x_1)\ xor\ SG(x_2)\ xor \ ...  \ xor \ SG(x_n) $

### 【Part6——对SG定理的严格证明】

由计算方法，$SG(z)=mex \{ SG(w)|z->w \} $

由上面的设定，$z=x+y$

又因为$w$是$z$的后继，**那么$w=u+y$或者$w=x+v$**，也就是每次只能改变其中一个

展开得

$SG(x+y)=mex \{ \{SG(u+y)|x->u\}∪\{SG(x+v)|y->v\} \}$

接下来是精彩的一点，利用**数学归纳**法：

假定我们之前已经证明了$SG(u+y)=SG(u)\ xor\ SG(y)$和$SG(x+v)=SG(x)\ xor\ SG(v)$，因为$u+y,x+v$是$x+y$的后继，所以必然**更加靠近终局状态**

对于终局状态的$SG(x)=0,SG(y)=0$时候的结论已经证明

所以可以展开得到

$SG(x+y)=mex \{ \{SG(u)\ xor\ SG(y)|x->u\}∪\{SG(x)\ xor\ SG(v)|y->v\} \}$

下面利用$SG(u+y)=SG(u)\ xor\ SG(y)$和$SG(x+v)=SG(x)\ xor\ SG(v)$推出$SG(x+y)=SG(x)\ xor\ SG(y)$

**证明：**

设$X=SG(x),Y=SG(y),U=SG(u),V=SG(v),A=\{SG(u+y)|x->u\},B=\{SG(x+v)|y->v\}$

**第一部分：$X\ xor\ Y∉A∪B$**

因为$x->u$，故$X≠U$,同理$Y≠V$

所以$U\ xor \ Y≠X\ xor \ Y$，也就是说$SG(x)\ xor\ SG(y)∉A$

同理$SG(x)\ xor\ SG(y)∉B$

所以$SG(x)\ xor\ SG(y)∉A∪B$

**第二部分：证明对于所有$W<X\ xor\ Y$，都有$W∈A∪B$**

设$Z=X\ xor\ Y\ xor\ W$

可以发现$Z$异或上$X,Y,W$其中的至少一个时，会使其减小

但是由于$Z\ xor\ W=X\ xor\ Y>W$，所以排除$W$

因为$X,Y$平等，所以不妨设是$X$吧

也就是说$Z\ xor\ X=W\ xor\ Y<X$

展开

$W\ xor\ SG(y)<SG(x)$

则$x$必然存在一个后继状态$u$使得$U=SG(u)=W\ xor\ SG(y)$

也就是存在$u$使得$W=SG(u)\ xor\ SG(y)$

那么同理，上面如果设$Y$

就会得到存在$v$使得$W=SG(x)\ xor\ SG(v)$

因为$Z$至少能够使$X,Y$之一变小，上述两个条件至少有一个成立

所以对于所有$W<SG(x)\ xor\ SG(y)$，都有$W∈A∪B$

所以根据定义：

$SG(x+y)=mex\{ A∪B \}=SG(x)\ xor\ SG(y)$

**【证毕】**

### 【Part7——Nim游戏题解】

之前已经讲到，本题中$SG(0)=0,SG(1)=1,SG(2)=2,SG(3)=3$

因为可以取任意多石子，所以对于某一堆，$SG(n)=n$，因为可以转移到$0$到$n-1$任意阶的状态

然后本题中几堆石子可以组合，组合方式为按照$SG$定理异或

所以$SG(x_1,x_2,...,x_n)=SG(x_1)\ xor\ SG(x_2)\ xor\ ... \ xor\ SG(x_n)$

按照定义，直接把所以数字异或起来，大于$0$先手必胜，等于$0$则后手必胜

谢谢阅读，谢谢大家

---

## 作者：hbzdqq (赞：6)

**[原题链接](https://www.luogu.com.cn/problem/P2197)**

***

## [博弈论](https://baike.baidu.com/item/%E5%8D%9A%E5%BC%88%E8%AE%BA/81545)

Nim 游戏是一种经典的博弈游戏，其规则是：有若干堆石子，每堆石子的数量都是有限的，双方轮流从某一堆中取走至少一个石子，取走最后一个石子的人获胜。在 Nim 游戏中，可以通过异或和来判断胜负。

[异或](https://baike.baidu.com/item/异或/10993677)运算有这几条性质：
+ 交换律：$a \oplus b = b \oplus a$。
+ 结合律：$(a \oplus b) \oplus c = a \oplus (b \oplus c)$。
+ 自反性：$a \oplus a = 0$。
+ 零律：$a \oplus 0 = a$。

这些性质使得异或运算在处理 Nim 游戏中的石子堆数量关系时非常方便。  
先来定义平衡状态与非平衡状态平衡状态：
+ 平衡状态：当所有石子堆数量的异或和为 $0$ 时，称游戏处于平衡状态。
+ 非平衡状态：异或和不为 $0$ 时，游戏处于非平衡状态。

## 原因分析

在 Nim 游戏中，玩家的目标是通过合理的取石子操作，使游戏从非平衡状态转变为平衡状态，并尽量让对手面对平衡状态。

### 开始状态

假设游戏开始时有 $n$ 堆石子，数量分别为 $a_1, a_2, \cdots, a_n$。如果 $a_1 \oplus a_2 \oplus \cdots \oplus a_n = 0$，即初始状态是平衡的。根据异或运算的性质，无论第一个玩家从哪一堆取走多少石子，都会打破这种平衡，使异或和不为 $0$，即变为非平衡状态。

### 中间过程

在游戏过程中，假设当前玩家面对的是一个非平衡状态，即 $a_1 \oplus a_2 \oplus \cdots \oplus a_n \neq 0$。根据异或运算的性质，可以证明一定存在一种取石子的方法，使得取完后异或和变为 $0$，即达到平衡状态。反之，若当前是平衡状态，那么无论怎么取石子，异或和都会变为非 $0$，即变为非平衡状态。  

### 结束状态

当游戏结束时，所有堆的石子数都为 $0$，此时异或和为 $0$，是平衡状态。  
所以，如果游戏开始时异或和为 $0$，那么第一个玩家取石子后会使异或和不为 $0$，第二个玩家可以通过合理操作使异或和再次为 $0$，如此循环，最后面对所有石子都被取完的平衡状态的是第一个玩家，即第二个玩家获胜。如果游戏开始时异或和不为 $0$，那么第一个玩家可以通过一次操作使异或和变为 $0$，之后第二个玩家取石子会打破平衡，第一个玩家再通过操作使异或和为 $0$，这样第一个玩家可以保证自己最终获胜。

因此这个题目的核心代码就是异或：
```cpp
ans ^= x;
```

## Code

```cpp
#include <bits/stdc++.h> //万能头
using namespace std;

int t, n, x, ans;

int main()
{
    cin >> t;
    while(t--)
    {
        ans = 0;
        cin >> n;
        for(int i = 0; i < n; i++)
        {
            cin >> x;
            ans ^= x; //异或
        }
        if(ans)
        {
            printf("Yes\n");
        }
        else
        {
            printf("No\n");
        }
        //也可以用三目运算符 printf(ans ? "Yes\n" : "No\n");
    }
    return 0;
}
```
**以上就是 P2197 的题解啦，谢谢阅读！**

---

## 作者：3_14 (赞：3)

[**题目传送门**](https://www.luogu.com.cn/problem/P2197)

# 思路

~~**先说结论吧：**~~

对于 Nim 游戏，先手必胜当且仅当所有堆石子数量的异或和不为 $0$。

~~**证明：**~~

设当前所有堆石子数量为 $a_1,a_2,\dots,a_n$，它们的异或和 $s=a_1\oplus a_2\oplus \dots \oplus a_n\ne 0$。

由于 $s\ne 0$，那么在二进制表示下，$s$ 必然存在至少一位为 $1$。假设 $s$ 的二进制表示中最高位为 $1$ 的是第 $k$ 位（从右往左，从 $0$ 开始计数），即 $s$ 在第 $k$ 位的值为 $1$。

因为 $s=a_1\oplus a_2\oplus \dots \oplus a_n$，根据异或运算的性质，要使得某一位异或结果为 $1$，那么参与异或的数中该位上 $1$ 的个数必须为奇数个。所以在 $a_1\oplus a_2\oplus \dots \oplus a_n$ 中，必然存在至少一个数，不妨设为 $a_i$，它的第 $k$ 位的值也为 $1$。

此时，我们可以通过对 $a_i$ 进行操作（即从第 $i$ 堆中取走一些石子），使得 $a_i$ 变为 $a_i^\prime $，且满足 $a_1\oplus a_2\oplus \dots \oplus a_{i-1}\oplus a_i^\prime \oplus a_{i+1}\oplus \dots\oplus a_n=0$。

具体的操作方式是：将 $a_i$ 的第 $k$ 位以及所有使得异或和 $s$ 不为 $0$ 的位进行翻转（因为异或运算中 $1 \oplus 1 = 0$，$0 \oplus 1 = 1$），这样就可以得到 $a_i^\prime$。也就是说，从第 $i$ 堆中取走 $a_i - a_i^\prime$ 个石子，此时所有堆石子数量的异或和就变为了 $0$。

这样就证明了，当异或和不为 $0$ 时，先手玩家一定能够通过某种取石子的操作，使得操作之后所有堆石子数量的异或和变为 $0$。

~~按思路来就很简单。~~

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5,mod=1e9+7,MOD=998244353;
int T,n;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>T;
    while(T--){
        cin>>n;
        int xs=0,s;
        for(int i=0;i<n;i++){
            cin>>s;
            xs^=s;
        }
        if(xs!=0)cout<<"Yes\n";
        else cout<<"No\n";
    }
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/206147476)

---

## 作者：yzm0325 (赞：3)

最近刚好学到博弈论，一看这题居然清题解了，那必须写一篇好吧。

## 算法介绍：博弈论与 Nim 游戏

博弈论，简单来说就是若干名玩家进行一个游戏，每名玩家都是绝顶聪明的，会按自己能走出的最优策略进行游戏，问存不存在必胜的策略。

这道题属于经典的 **Nim 游戏**。规则正如题面所说，有 $n$ 堆石子，两人轮流，每次可以从一堆石子里取出任意多颗扔掉，但不能跨堆，没石子可取的人就输了。

首先了解一些基本定义：

- 我们把现在场上的局面称为**状态**。
- 若一个状态可以通过此时先手的一步操作变为另一个状态，则称后者为前者的**后继状态**。
- 先手必胜的状态称为**必胜状态**，反之为**必败状态**。

根据定义，我们可以得到以下几个关于必胜必败状态的结论：

- 没有后继状态的状态是必败状态。很显然，此时先手无法操作，就输了。
- 至少一个后继状态为必败状态的状态为必胜状态。此时的先手可以通过操作使当前状态变为这个必败状态，这样对手必败，所以自己必胜。
- 所有后继状态都为必胜状态的状态为必败状态。显然此时先手无论怎么操作，都会走到一个必胜状态，使对手必胜，此时自己必败。

那么在 Nim 游戏中，我们如何定义必胜必败状态呢？

先下结论：定义当前状态的 **Nim 和**为所有堆石子的数量的异或和，即 $S=a_1 \oplus a_2 \oplus \cdots \oplus a_n$。那么**当且仅当 $S=0$ 时，当前状态为必败状态；反之为必胜状态。**

接下来我们来证明上面的结论。

## 正确性证明

要证明上述结论，只需要证明其符合必胜必败状态的那三个结论即可。

### 1. 没有后继状态的状态是必败状态。

在 Nim 博弈中，没有后继状态的状态只有一种：$a_1=a_2=\cdots=a_n=0$，此时显然有 $S=0$。

### 2. 至少一个后继状态为必败状态的状态为必胜状态。

即证明，对于一个 $S \neq 0$ 的状态，一定能通过一次操作使其变为一个 $S=0$ 的状态。

我们只需要让其中一个 $a_i$ 变为 $S \oplus a_i$ 且操作合法即可。设 $k$ 为 $S$ 的二进制下最高位，则根据异或定义，$a_1 \sim a_n$ 中必定有奇数个数在二进制下第 $k$ 位为 $1$。从其中任取一个数 $a_i$，则因为 $S$ 和 $a_i$ 的二进制下第 $k$ 位都为 $1$，所以异或后第 $k$ 位为 $0$，所以有 $a_i>S \oplus a_i$，此次操作合法。

所以原命题成立，结论成立。

### 3. 所有后继状态都为必胜状态的状态为必败状态。

即证明，对于一个 $S=0$ 的状态，一定不存在合法的操作使操作后的状态仍满足 $S=0$。

考察二进制下的某一位 $k$，因为 $S$ 的第 $k$ 位为 $0$，所以 $a_1 \sim a_n$ 中有偶数个数在二进制下第 $k$ 位为 $1$。而若操作后的状态仍然满足 $S=0$，则操作后需满足 $a_1 \sim a_n$ 中仍有偶数个数在二进制下第 $k$ 位为 $1$，此时至少需改变两个数的第 $k$ 位，与 Nim 游戏的规则矛盾，所以操作一定不合法。

所以原命题成立，结论成立。

自此，这三个结论都满足了，所以原结论是正确的。

## 代码实现

有了上面的基础，代码非常简单，对于每组询问算一下异或和，判断输出即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int T, n, a;
int main() {
    cin >> T;
    while(T--) {
        cin >> n;
        int chaor = 0;
        for(int i = 1; i <= n; i++) {
            cin >> a;
            chaor ^= a;
        }
        if(chaor) cout << "Yes\n";
        else cout << "No\n";
    }
    return 0; // 完结撒花！！！
}
```

---

## 作者：_H17_ (赞：3)

## 题目分析

首先，这是一个先后手问题，所以它大概率是博弈论问题。

考虑必胜状态、必败状态是什么。显然全是 $0$ 的时候是必败的。考虑将所有数进行某种运算，结果是 $0$ 必败，否则必胜。

考虑这个运算的性质：任何更改一个数必然修改它的运算后的值，比如加减法。

第二个性质：可以有这样的变化 $0\to x(x\ne 0)\to 0$。

考虑一个类似加减法但是可以很快变出 $0$ 的运算。显然二进制不进位加减法异或很符合这个性质，我们考虑尝试。

首先 $0$ 异或若干次还是 $0$。

当 $x\ne y$ 时，显然 $x\operatorname{xor} z\ne y\operatorname{xor} z$。同理，该性质可以推广到 $n$ 个数改变一个（把剩下 $n-1$ 个数异或之后就变成推广之前的了）。

显然，我们也可以通过修改，把异或和变为 $0$。显然假设修改 $a_i$，当前异或和是 $x$。我们应该把 $a_i$ 改为 $x \operatorname{xor} a_i$。

问题所在是为什么一定有可能的修改方案是**减小**。

显然 $x\ne 0$，所以 $x$ 存在最高位（最高是 $1$ 的位，我们假设是第 $j$ 位），显然也存在一个 $a_i$ 在这一位是 $1$。此时 $a_i \operatorname{xor} x$ 在第 $j$ 位比 $a_i$ 小，$j+1\sim +\inf$ 不变，所以这次操作是减法。

也就是异或和不是 $0$ 的那一方必然胜，因为下一次必然可以把异或和搞到 $0$，又因为每次总数都会减少，最终可以变为全 $0$。

所以当异或和是 $0$ 先手必败，否则必胜。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,ans,tmp;
int main(){
    for(cin>>T;T;--T){
        ans=0;
        for(cin>>n;n;--n){
            cin>>tmp;
            ans^=tmp;
        }
        cout<<(ans?"Yes\n":"No\n");
    }
    return 0;
}
```

---

## 作者：GNAQ (赞：3)

`Rust` 版代码


一些引理：

$ a \oplus b = s \Leftrightarrow a \oplus s = b$。

- 证明：

- $ a \oplus b = s \Leftrightarrow a \oplus b \oplus s \oplus b = s \oplus s \oplus b \Leftrightarrow a \oplus s = b$。

若 $ a_1 \oplus a_2 \oplus a_3 \oplus \cdots \oplus a_n = p \neq 0$，则必存在一个 $k$ 使 $ a_k \oplus p < a_k$。

- 证明：因为 $p \neq 0$ 所以 $p$ 的最高位一定是 $1$，设 $p$ 的最高位是第 $q$ 位，至少存在一个 $k$ 使 $a_k$ 的第 $q$ 位也是 $1$，则 $ a_k \oplus p$ 的第 $q$ 位是 $0$，因此 $ a_k \oplus p < a_k$。

若 $ a_1 \oplus a_2 \oplus a_3 \oplus \cdots \oplus a_n = p = 0$，则不存在一个 $a_k$ 使得将 $a_k$ 减去一个数变为 $a_k'$ 后仍满足 $ a_1 \oplus a_2 \oplus a_3 \oplus \cdots \oplus a_n = p = 0$。

- 证明

- 若 $ a_1 \oplus a_2 \oplus \cdots \oplus a_k \oplus \cdots \oplus a_n = a_1 \oplus a_2 \oplus \cdots \oplus a_k' \oplus \cdots \oplus a_n$，则由异或运算的消去律可得 $a_k = a_k'$，故不存在所求的 $a_k$。

由此我们可得：

对于终结局面 $T$，$f(T) = 0$。

 若 $f(S) \neq 0$，则必存在一种操作使 $S \rightarrow T$，且 $f(T)= 0$。

- 证明：

- 设 $S = \{a_1, a_2, \cdots, a_n\}, p = f(S) \neq 0$，因为 $p \neq 0$， 则必然存在 $k$ 使 $ a_k \oplus p < a_k$。因为集合中元素是无序的，所以不妨设 $ k = 1, a_1 \oplus p = x$；由引理 1 得$ p = a_1 \oplus a_2 \oplus \cdots \oplus a_n \Leftrightarrow a_2 \oplus \cdots \oplus a_n = a_1 \oplus p = x$。

- 先手将 $a_i$ 变成 $x$ 后局面变为 $T$，$ f(T) = x \oplus (a_2 \oplus \cdots \oplus a_n) = x \oplus x = 0$。

若 $f(S) = 0$，则所有使得 $S \rightarrow T$ 的合法操作都满足 $f(T) \neq 0$。

- 证明：由引理 3 易得。

对比我们之前归纳的判断一个局面是 P-position 还是 N-position 的方法：

- 无法进行任何移动的局面（即终结局面，terminal position）为 P-position；

- 能转移到 P-position 的局面为 N-position；

- 所有合法移动都转移到 N-position 的局面为 P-position。


我们可以发现，这三条方法与刚刚得到的三条结论是一一对应的。

因此在“判断一个局面的类型”这个问题上，我们找到了一种时间复杂度可以接受的判断方式，即对该局面的集合表示 $S$ 求 $f(S)$ 的值：当 $S$ 为 P-position 时 $f(S) = 0$，否则 $f(S) \neq 0$。

于是，对于一个 NIM 游戏的局面，我们只需要把每堆石子的数量异或起来，就可以判断这个局面的类型了。

```rust
use std::io::*;

fn main()
{
    let t: i32;
    let mut inp_str = String::new();
    
    stdin().read_line(&mut inp_str).unwrap();
    
    t = inp_str.trim().parse().unwrap();
    
    for _q in 1..t+1
    {
        let n: i32;
        let mut seq: Vec<i32> = Vec::new();
        
        inp_str.clear();
        stdin().read_line(&mut inp_str).unwrap();
        n = inp_str.trim().parse().unwrap();
        
        inp_str.clear();
        stdin().read_line(&mut inp_str).unwrap();
        let mut inp_div = inp_str.trim().split(' ');
        for _i in 1..n+1
        {
            seq.push(inp_div.next().unwrap().parse().unwrap());
        }
        
        let mut ans: i32 = 0;
        for i in seq
        {
            ans ^= i;
        }
        
        if ans!=0 
        {
            println!("Yes");
        }
        else
        {
            println!("No");
        }
    }
}
```

---

## 作者：ghj1222 (赞：3)

地上有n堆石子，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。

我们设第i堆棋子的数量为$a_i$

有一个定理，就是当所有棋子数量的异或和为0时先手必败，否则后手必胜。

我们假设所有棋子数量的异或和为0时候是一个N局面，否则就是一个P局面。

当所有的$a_i=0$的时候，就输了，此时是一个N局面。

当所有棋子数量的异或和不为0时，也就是一个P局面时候，假设x为所有棋子数量的亦或和，也就是：$a_1\oplus a_2\oplus ...\oplus a_n=x$，那么必定存在i使得$a_i\ge x$，这时候我们让这个$a_i$变为$a_i \oplus x$，这样会使得$a_1\oplus a_2\oplus ...\oplus a_n=0$，局面变成了一个N局面。
这句话想说明的就是**一个P局面一定有可能转化为N局面**。

当所有棋子数量异或和为0时，也就是一个N局面，无论怎么操作，操作后异或和都不会为0。假设操作将$a_i$转化为了$a'_ i$，那么有：，$a_1\oplus a_2\oplus ...\oplus a_i \oplus ... \oplus a_n=0$，$a_1\oplus a_2\oplus ...\oplus a'_ i \oplus ... \oplus a_n=0$，两个式子亦或会得到：$a_i\oplus a'_ i=0$，也就是$a_i=a'_ i$，那么与题意不符。
这句话意思就是一个**N局面在操作之后一定会转化成一个P局面**。

对于先手，如果拿到了P局面，那么他可以把P局面转化成N局面，对方一定只能把N局面转化回P局面。而由于棋子数目是递减的，最后对方一定会拿到了一个所有棋子数目全部为0的局面，对方输。

如果拿到了N局面，那么对手一定会拿到P局面，如果对手聪明他一定胜。

所以对于nim游戏，当所有棋子数量的异或和为0时先手必败，否则后手必胜。

代码略



---

## 作者：粥2414 (赞：2)

~~博弈论，顾名思义就是两个人之间的博弈。~~
# 博弈论简介
## 公平组合游戏
oi 中的博弈论主要研究先手是否拥有必胜策略，其中的一个重要模型是**公平组合游戏**（ICG），满足以下三点的博弈可以被称为公平组合游戏：

> - 游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息。
> - 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关。
> - 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

摘自 [oi-wiki](https://oi-wiki.org/math/game-theory/intro/)。

任意的一个公平组合游戏都可以转换为一个有向无环图，但对于 Nim 博弈来说，没有必要进行转换。
## Nim 博弈
Nim 博弈就是一类公平组合游戏。它有两种可能的状态：先手必败态和先手必胜态。必胜态和必败态在 Nim 博弈中的定义如下：

- 当前没有石子可取时为必败态。
- 能够到达必败态的状态为必胜态。
- 只能够到达必胜态的状态为必败态。

### 定理
定义 Nim 和为 $a_1\oplus a_2\oplus\dots\oplus a_n$，当且仅当 Nim 和等于 $0$ 时，先手必败。
### 证明
下面我们来尝试证明一下：

设 Nim 和为 $nim$。

要证明上述结论，需要证明 $nim=0$ 时为必败态，$nim\neq 0$ 时为必胜态。

显然当所有石子取完时，$nim=0$，此时为必败态。

当 $nim=0$ 时，设被取的石子堆在取前有 $x$ 枚石子，取走后有 $y$ 枚石子。显然 $\exists t\oplus x=y,t\neq 0$，于是取走之后 $nim=t$。所以 $nim=0$ 的状态**只能**导向 $nim\neq 0$ 的状态。如果 $nim\neq 0$ 为必胜态，那么 $nim=0$ 的状态即为必败态。

当 $nim\neq 0$ 时，设 $nim$ 的最高位为第 $i$ 位，那么一定存在至少一个 $a_j$ 的最高位也为第 $i$ 位。此时令 $a_j\gets a_j\oplus nim$，即可令新的 $nim$ 为 $0$，同时保证新的 $a_j$ 比原来更小。

显然如此循环往复，最后导向所有石子全取完的必败态的，一定是 $nim\neq 0$ 的状态，运用数学归纳法可得上述结论。

然后就可以愉快地 AC 啦！
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,ans;
ll t;
int main(){
	cin>>t;
	while(t--){
		ans=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			ll x;
			cin>>x;
			ans^=x;
		}
		puts(ans==0?"No":"Yes");
	}
	return 0;
}
```

---

## 作者：chentianmiao (赞：1)

## 题目大意
有 $n$ 堆石子，A、B 两人轮流执行操作，两人都取最优策略，无法操作的人输（即取走最后一颗石子的人胜）。操作为：每次在某堆中取任意数量的石子。

***注意:***

* 不可以不取。
* 不可以跨堆取。
## 思路分析
首先，这道题是经典 Nim 游戏的模板，可以根据异或和判断游戏胜负。


令 $
S=x_1 \oplus x_2 \oplus x_3 \oplus \cdots \oplus x_n$ 。

若 $S=0$ 先手必败；反之先手必胜。
### 证明
若最初石子总数为 $0$ ，先手必败，显然此时 $S=0$ 。

若游戏进行时，某一刻处于 $S=0$ 的状态，无论玩家如何操作，局面都将变为 $S \ne 0$ 的状态；同时，若某一刻处于 $S \ne 0$ 的状态，玩家必定有一种操作能将局面变为 $S=0$ 的状态。

于是我们就能证明前面的结论。
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+9;
int T,n;
int main(){
    cin>>T;
    while(T--){
        cin>>n;
        int S=0;
        for(int i=1;i<=n;i++){
            int x;
            cin>>x;
            S^=x;
        }
        if(S==0){
            cout<<"No"<<endl;
        }else{
            cout<<"Yes"<<endl;
        }
    }
    return 0;
}
```

---

## 作者：ZZA000HAH (赞：1)

Nim 游戏是博弈论经典模版题，代码非常简洁，但是合理的做法从零开始思考是比较困难的。这个游戏的变式也非常之多，本题算是博弈论的入门。

题目背景比较简单，这里不再赘述。这道模版题用到的两点结论，与异或运算[基础知识可以参见此](https://oi-wiki.org/math/bit/)（附上两个链接）[异或运算性质可以参见此](https://blog.csdn.net/m0_74051652/article/details/141094529)相关，在这里先给出。

> 如果各堆中个数相异或起来为 $0$，则先手必输（对方选最优策略），即本题中的没有必赢策略。

> 如果各堆中个数相异或起来不为 $0$，则先手必赢（选最优策略），即本题中的有必赢策略。

这两个结论如何证明，这里我们用直观的思维和数学方法相辅地证明一下。（说明：在两方都一直选择最优策略的情况下有选择策略可使自己赢的称为必赢，没有策略使自己赢的称为必输，下面论述中包含许多以此作为默认条件的。“该操作一方”指要进行还未进行操作的一方）

1. 这个游戏怎么算赢与输呢，根据题目来说，不能操作为输，既在该操作一方要操作时石子个数为零时，该操作一方为输，既对方为胜，那么也就是能使对方必输的，自己必赢；使对方必赢的，自己必输。

2. 在这个过程中是不是每次双方操作后都保持与原来相同的状态呢（也就是必赢的还必赢，必输的还必输），如果是的话，那么也就是说从一开始就能确定结果。一开始石子个数相异或为零，那么最后相异或也为零，也就是没有石子了，代表着该操作的一方输了，那么我们上述的两点结论就是正确的了。【可实现证明的一种数学方法：第一归纳法。我们知道在石子数为零时，异或为零，该操作一方输；在中间操作过程中，操作一次后原来异或为零的现在还是异或为零，即可证明（其实就是状态保持不变）】那么我们现在只需要证明这个过程中，状态保持不变即可。

（一）
> 如果各堆中个数相异或起来为 $0$，且存在石子，那么在拿一次操作后，余下的个数相异或起来一定不为零。

如果 $a_1\operatorname{xor}a_2\operatorname{xor}a_3\operatorname{xor}a_i\operatorname{xor}...\operatorname{xor}a_n = 0$ 那么从一个数中去除一部分后的值一定不为 $0$，这是比较显然的，但也可以用反证法证明：如果存在 $y > 0$ 使 $a_1\operatorname{xor}a_2\operatorname{xor}a_3\operatorname{xor}(a_i - y)\operatorname{xor}...\operatorname{xor}a_n = 0$，那么$a_1\operatorname{xor}a_2\operatorname{xor}a_3\operatorname{xor}a_i\operatorname{xor}...\operatorname{xor}a_n = a_1\operatorname{xor}a_2\operatorname{xor}a_3\operatorname{xor}(a_i - y)\operatorname{xor}...\operatorname{xor}a_n$ 即 $a_i = a_i - y$，则 $y = 0$ 与 $y > 0$ 相违背，不成立，即证明。

（二）
> 如果各堆中个数相异或起来不为 $0$，那么在拿一次操作后，可以使余下的个数相异或起来为零。

如果 $a_1\operatorname{xor}a_2\operatorname{xor}a_3\operatorname{xor}a_i\operatorname{xor}...\operatorname{xor}a_n = x$ 那么假设 $x$ 的二进制中的最高的 $1$ 位为第 $k$ 位，在 $a_1,a_2,a_3...a_n$ 中至少有一个数的第 $k$ 位为 $1$，（可以根据异或的定义用反证法证明）假设这个数为 $a_i$，那么 $a_i\operatorname{xor}x < a_i$（异或使第 $k$ 位变成了零）由此说明 $a_i - (a_i\operatorname{xor}x) > 0$，那么我们取 $a_i - (a_i\operatorname{xor}x)$，原始式子也就变成了 $a_1\operatorname{xor}a_2\operatorname{xor}a_3\operatorname{xor}(a_i - (a_i - (a_i\operatorname{xor}x))\operatorname{xor}...\operatorname{xor}a_n = 0$，即证明。

最后附上 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while (t--)
	{
		int n,y=0,x;
		scanf("%d",&n);
		while (n--)
		{
			scanf("%d",&x);
			y^=x;
		}
		if (y!=0) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---

## 作者：YBJ1006 (赞：1)

先说结论，**如果石子个数异或起来的和不为零，则先手必胜。反之必败。**

考虑证明：如果先手，异或和不为零，那么一定存在一种方法拿石子，让异或和为零。

设异或和为 $x$，$x$ 二进制表示下最高的 $1$ 的位置为 $k$ ，那么一定至少有一堆石子的二进制表示下第 $k$ 位为 $1$。 那假设一个 $a_i$ 的第 $k$ 位为 $1$，显然有 $a_i \oplus x < a_i$ 那么我们可以拿走 $a_i - (a_i \oplus x )$ 个石子(在 $a_i$ 中拿)。那么 $a_i$ 中还剩下 $a_i \oplus x$ 个石子此时异或和变成 $a_1 \oplus a_2 \oplus a_3 \oplus \cdots \oplus a_i \oplus x \oplus \cdots \oplus a_n$ 也就是 $x \oplus x = 0$。

再考虑，先手异或和为 $0$ 的，显然无论如何拿，异或和就不为 $0$ 了。

又有，每次拿石子都会减少，最终每堆石子都为 $0$ 的时候，异或和为 $0$，此时先手必输。

两人都是最优策略，那么先手异或和不为 $0$ 的可以让异或和变为 $0$，下一回合的人拿到的是异或和为 $0$ 的状态，只能让异或和变得不为 $0$，那么如此循环，石子数量又一直在减少，所以先手异或和不为 $0$ 的必胜，反之必败。

代码就非常容易了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        int n;
        scanf("%d", &n);
        int ans = 0, x;
        for (int i = 1; i <= n; i++)
            scanf("%d",&x), ans ^= x;
        if (ans == 0)
            puts("No");
        else
            puts("Yes");
    }
    return 0;
}
```

---

## 作者：A_chicken_boy (赞：1)

# NIM 博弈

这显然是一个**博弈游戏**，而此题的这种博弈被称为 **NIM 博弈**。

## NIM 博弈定理

NIM 博弈中，先手必胜，当且仅当所有堆的石子数的异或和不为零，即：

$$
A_1 \oplus A_2 \oplus \dots \oplus A_n \ne 0
$$

其中 $\oplus$ 表示**异或**。

### 证明：

1. 考虑**终止局面**：
    当所有堆的石子数为零时，显然这是一个必败局面（对于先手），此时异或和为：
     $$
     A_1 \oplus A_2 \oplus \dots \oplus A_n = 0
     $$

2. 再考虑**非零异或和**的局面：
    假设当前局面的异或和为 $x \ne 0 $，设 $ x $ 在二进制表示下最高位的 $ 1 $ 在第 $ k $ 位。
    则至少存在一个 $A_i$，其二进制表示的第 $k$ 位为 $1$。
    我们可以将 $A_i$ 修改为 $A_i \oplus x$，此时：
     $$
     A_1 \oplus A_2 \oplus \dots \oplus (A_i \oplus x) \oplus \dots \oplus A_n = 0
     $$
    于是，我们可以通过操作将对手置于必败局面。

3. 接着考虑**零异或和**的情况：
    假设当前局面的异或和为 $0$，即有：
     $$
     A_1 \oplus A_2 \oplus \dots \oplus A_n = 0
     $$
    如果我们将某个 $ A_i $ 修改为 $ B $，则新的异或和为：
     $$
     A_1 \oplus A_2 \oplus \dots \oplus B \oplus \dots \oplus A_n = 0
     $$
    根据异或运算的性质，可以推出 $ B = A_i $，这与“必须取石子”的规则矛盾。
    因此，任何操作都会使异或和变为非零，对手可以通过策略将你再次置于必败局面。

***

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define ll long long
#define ull unsigned long long

int t;
int n;

int main() {
    IOS;
    cin >> t;
    while (t--) {
        cin >> n;
        int sum = 0;
        for (int i = 1; i <= n; ++i) {
            int a;
            cin >> a;
            sum ^= a; // 计算异或和
        }
        // 根据 NIM 博弈定理判断
        if (sum != 0) {
            cout << "Yes\n"; // 先手必胜
        } else {
            cout << "No\n"; // 先手必败
        }
    }
    return 0;
}
```
本人juluo,有不严谨的地方请见谅.

---

## 作者：sbno333 (赞：1)

# 博弈论公平组合游戏从入门到入土。

sbno333 手把手教你 sg 函数。

## 前言

不是所有游戏都要用到博弈论知识，很多游戏递推解决即可，但有些游戏需要用到，具体按情况而论，一般的，看着像 Nim 游戏的都是递推（诈骗），看着和 Nim 半毛钱没有的是博弈论。

## 前置知识

异或，$\text{mex}$，可以上 [OI 维基](https://oi.wiki)自主学习。

## 一般公平组合游戏

两个人轮流操作，没有平局，每个人每次能进行的操作与人无关，并且能结束。比如国际象棋就不是这类游戏，因为它有平局，而且你只能动自己的棋子，不能动对方的，无法操作的一方输。

### sg 函数

在这之前，我们应当学习 Nim 游戏，这个游戏在博弈论学习中起到**极其重要**的地位。

#### Nim 游戏

[如题](https://www.luogu.com.cn/problem/P2197)，有 $n$ 堆石子，每堆石子有若干个石子，不能不取，每次可以选取一堆石子，取走若干石头。

下文中用 $\oplus$ 代替按位异或。

这道题有一个必胜策略就是当石子堆石子数量异或和为 $0$ 时，先手必败，否则必胜。

##### 正确性证明

具体的，当异或和为 $0$ 时，显然我们操作后肯定改变了某个石堆，设其它石堆异或和为 $x$，这个石堆原本也一定为 $x$，改变后为 $y<x$，对于两个不同的数，其异或和一定不为 $0$，因此取完后为异或和不为 $0$。

对于不为 $0$，设这个值为 $x$，其最高位为 $1$，显然存在一个石堆，其和异或和的最高位对应也是 $1$，设其有 $y$ 个石子，此时其他石子堆异或和为 $x\oplus y$，由于 $x,y$ 在 $x$ 最高位都是 $1$，因此 $x\oplus y$ 那一位为 $0$。

我们此时只需要将 $y$ 变得使 $x=0$，即 $x\oplus y=y$，显然 $x\oplus y$ 不会随操作 $y$ 而改变（操作当前不会改变其他石子），可以这么操作当且仅当原来的 $y$ 比 $x\oplus y$ 大，这样才能将 $y$ 取到 $x\oplus y$。 

问题变成了 $y$ 异或上一个没有 $y$ 位数多，且那个数最高位 $y$ 对应位也是 $1$ 的数（上述提到的 $x$ 具有的性质）与其异或后能否比 $y$ 小。

对于比 $x$ 最高位高的位，显然异或后不改变，不考虑。

对于 $x$ 最高位，异或后 $y$ 对应位减少（从 $1$ 到 $0$)，其他位怎么增加也比不上，所以正确，即可以将异或和从 $\not=0$ 变为 $0$。

一个人输的时候显然石子堆异或和为 $0$，所以 $\not=0$ 时不为输的状态。

所以如果先手时异或和 $\not=0$，总是可以给到对方 $=0$，而对方又只能返回 $\not=0$，这样下先手必胜。

如果先手为 $0$，则只能把 $\not=0$ 给到对方，对方再采用上述策略，先手必败。

所以结论就是判断异或和是否为 $0$。

##### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
void _main(){
	int n;
	cin>>n;
	int a;
	a=0;
	for(int i=1;i<=n;i++){
		int b;
		cin>>b;
		a^=b;
	}
	cout<<(a==0?"No":"Yes")<<endl;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		_main();
	}
	return 0;
} 
```

#### 从 Nim 升级开始代入 sg 定理

我们不妨升级 Nim 游戏，每次不但可以取走，还可以放入，但不能不操作，为了游戏的有限，每次放入后如果满足某个条件，之后双方将无法放入，而且每次放入对放入的数量有限制。

对于异或和 $\not=0$，显然可以看作只能减少，然后显然可以把异或和变为 $0$。

对于 $=0$，显然还是要改变，因此还是会重新变为 $\not=0$ 给对方。

因此这个游戏与上述普通 Nim 游戏必胜策略一致，**与放入的条件之类无关**，但当**减少有限制时，游戏结果或受到影响**。

####  sg 函数及定理

对于公平组合游戏，可以分成若干**互不影响**的子游戏，每次选取一个子游戏进行操作，比如 Nim 取石子可以分成 $n$ 个子游戏，每个子游戏都是一堆石子，显然取走这堆石子不会影响其他石子堆。

我们可以将每个子游戏抽象成有向无环图，一个节点表示当前子游戏状态，比如 Nim 游戏中可以表示当前石子堆石子数量。而每个节点的每个后继边表示一个可以选择的操作，比如在 Nim 游戏的子游戏中，有 $3$ 个石子的节点的后继为 $0,1,2$ 三个石子可能数量的节点，但 $3$ 不是，因为操作后不能变会自己，所以自己不是自己的后继。

我们对于任意公平组合游戏，都可以绘图，我们设一个子游戏的结束节点的 sg 值为 $0$，比如在 Nim 中某一堆取完的状态其 sg 值为 $0$。

于是有个有趣的想法：对于每个状态的 sg 值，我们可以将其抽象成 Nim 中的石子数量，我们考虑如何通过后继来转移。

为了保证不能不取，显然 sg 值不能与后继中任何一个相等我们假设当前 sg 值为 $x$，则可以操作后让 $x$ 增加或减少，上述 Nim 中说与增大无关，为了可以仿照 Nim 游戏的策略，根据上述 Nim 升级版的黑体字，其下降不能受到影响，而 Nim 游戏中下降不受到影响定义为可以在自己操作时在堆数不是 $0$ 时随时下降并且能下降到任意小于原值的自然数。

这个 sg 值非 $0$ 时下降显然是自然的，不需要维护，如果后继不得不上升，记当前 sg 为 $0$ 即可。对于可以下降到任意小于当前值的自然数这个条件，我们倒推，即后继出现过比当前小的所有自然数，考虑到没出现过，所以 sg 值为后继 sg 中未出现过的最小自然数（因为不是最小就不满足可以去任意比自己小的自然数，可以去最小），我们对这个很熟悉啊，就是 $\text{mex}$！而且前面的情况也可以证明符合这一条。

假设分成了 $n$ 个子游戏，根据 Nim 游戏，所以就是判断每个子游戏起点的 sg 值异或和是否为 $0$ 即可。

我们梳理一下，游戏分成若干子游戏，每个子游戏为一个有向无环图，终点 sg 值为 $0$，每个节点为其后继的 $\text{mex}$，如果所有子游戏的起点 sg 值异或和为 $0$，先手必败，否则必胜。

这里给出一个性质：有 mex 得出某个状态的 sg 值一定在 $O(\sqrt m)$ 以内，其中 $m$ 为状态所在子游戏构成的图的边数。

## 一些套路

### 翻格子游戏的性质

我们设每次选择一个白色的格子 $i$，选择一个满足条件的 $k$，翻转 $S_{i,k}$ 集合内的格子，保证当前格子一定被翻转，且游戏能结束。

我们可以将游戏转化为每个格子有一个数，原游戏中白色初始是 $1$，黑色初始为 $0$。

每次可以选择一个非 $0$ 的数进行操作，当前数的值减一 ，$S_{i,k}$ 的其他数加一。

游戏中，显然白色对应奇数，黑格对应偶数，我们只需要证明这个游戏与原游戏等价（必胜判定相同）。

设原游戏先手为必胜方，显然可以按照原游戏策略进行，只翻转奇数，监督必败方是否也只反转奇数，如果翻转偶数，将其变为奇数，则先手再次对那个格子进行翻转，可以证明奇偶性可以与后手操作前一样，使得后手在奇偶性上操作无效，重新变回自己，而先手由于前提是必生，所以总有奇数可以翻，$0$ 是偶数，于是可以证明新游戏也是必胜方。

如果原先后手必胜，仿照上述，易证。

所以等价。

结论就是可以分成 $w$ 个子游戏，第 $i$ 个子游戏只有第 $i$ 原来的白格是 $1$ 其他都是 $0$。

而我们每次都是在一个子游戏上进行的，你可以能认为这仍然会互相影响，但其实不是，这个序列在现实中表现为每个子问题的序列对应位置的和，如果这个位置是 $0$，则子游戏都为 $0$，不能操作。否则一定能看作一个子游戏进行的一次操作，因此可以分解。

### 这道题目求 sg 的具体方法

于是这样我们就将其分解成了若干子游戏，并且始终存在分解方案，这时候我们不妨设 $sg(x)$ 表示只有 $x$ 为白格，我们考虑列式子。

我们选择 $k=1$，此时得到游戏结束状态，sg 为 $0$。

选择 $k=2$，此时转化为只有 $2x$ 为白色，为 $sg(2x)$。

选择 $k=3$，此时转化为 $2x,3x$ 为白色，不妨再次按照刚刚的结论分解，分解为只有 $2x$ 和只有 $3x$ 为白色两个子游戏，按照 sg 定理，答案为起点 sg 的异或和，所以此时为 $sg(2x)\oplus sg(3x)$。

以此类推。

于是我们得到了 $sg(x)=\text{mex}(0,\text{mex}_{i=2}^{\frac n x}\oplus_{j=2}^i sg(j))$，即 $sg(x)=\text{mex}(0,sg(2x),sg(2x)\oplus sg(3x),sg(2x)\oplus sg(3x)\oplus sg(4x)\dots)$。

我们可以从 $n$ 枚举到 $1$，暴力求出 $sg(i)$，可以做到 $O(w)$ 处理询问，但预处理时间复杂度高达 $O(n^2)$，不能接受。

于是考虑优化。

有一些 $sg(i)$ 可能是相同的，我们考虑这段优化。

[题目](https://www.luogu.com.cn/problem/P3179)。

---

## 作者：kunkun127 (赞：1)

## 题目描述
有 $ n $ 堆石子，每堆石子的数量为 $ a_i $。两名玩家轮流进行操作，每次可以从一堆石子中取走任意数量的石子（至少取走一个），取走最后一个石子的人获胜。假设双方都采取最优策略，问先手是否必胜。


## 博弈论基础
这道题属于经典的 **Nim 游戏**，是博弈论中的一个经典问题。Nim 游戏的核心思想是通过**异或和**来判断游戏的胜负。

### 1. 游戏规则
- 有 $ n $ 堆石子，每堆石子的数量为 $ a_i $。
- 两名玩家轮流操作，每次可以从一堆石子中取走任意数量的石子（至少取走一个）。
- 取走最后一个石子的人获胜。

### 2. 胜负判断
- 定义所有堆石子的数量的异或和为 $ S = a_1 \oplus a_2 \oplus \dots \oplus a_n $。
  - 如果 $ S = 0 $，当前局面是**必败态**（后手必胜）。
  - 如果 $ S \neq 0 $，当前局面是**必胜态**（先手必胜）。

### 3. 证明
- **必败态**：如果 $ S = 0 $，无论当前玩家如何操作，都会将局面转移到 $ S \neq 0 $ 的状态。
- **必胜态**：如果 $ S \neq 0 $，当前玩家可以通过一次操作将局面转移到 $ S = 0 $ 的状态，从而迫使对手处于必败态。

---

## 思路
1. 计算所有堆石子数量的异或和 $ S $。
2. 如果 $ S = 0 $，输出 `No`（先手必败）。
3. 如果 $ S \neq 0 $，输出 `Yes`（先手必胜）。

---

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve()
{
	int n, ans = 0;
	cin >> n;
	for (int i = 1; i <= n; i++) 
	{
		int x; cin >> x;
		ans ^= x;
	}
	if (!ans) cout << "No" << endl;
	else cout << "Yes" << endl;
}

int main()
{
	int t, ans = 0;
	cin >> t;
	while (t--) solve();
	return 0;
}
```

---

## 作者：Chase12345 (赞：0)

# 引入
最近感觉估值要掉了，赶紧写多几篇模板题题解。

这道题你看了看题解，发现代码怎么这么简单，咋评绿的？于是你赶紧发帖：建议降红。不过肯定有人反驳，这道题代码是简单，但是证明结论似乎并不那么容易。所以评绿十分合理。

这是一个 Nim 游戏的模板题，给你初始状态，求谁必胜。在这里，公平组合游戏的定义，摘自 [OI-wiki](https://oi-wiki.org/math/game-theory/intro/):
> 公平组合游戏（Impartial Game）的定义如下：
> * 游戏有两个人参与，二者轮流做出决策，双方均知道游戏的完整信息；
> * 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关；
> * 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。

所以 Nim 游戏就是公平组合游戏。

# 结论
设有 $n$ 堆石子，每堆石子有 $a_1,a_2,\dots,a_n$，设
$$
S=a_1 \oplus a_2 \oplus \dots \oplus a_n
$$
若 $S \neq 0$，则先手必胜，否则后手必胜。
# 证明
这也是所有博弈论中最重要的部分。

设当前异或和 $S=a_1 \oplus a_2 \oplus \dots \oplus a_n \neq 0$。这 $S$ 的最高有效位为第 $k$ 位。那么至少存在一个 $a_i$ 的第 $k$ 位为 $1$。

假设对于所有石子总数 $K'<K$ 的状态，上面的结论成立。则考虑石子总数 $=K$ 的情况。

## 情况1：$S \neq 0$
设 $S$ 的最高有效位为第 $d$ 位，则根据异或的性质，必定存在一堆 $a_i$ 满足 $a_i$ 的第 $d$ 位为 $1$。选择这堆，将其移动成为 $a_i \oplus S$。那么新的 $S \to S'$ 变为：
$$
S'=(a_1 \oplus a_2 \oplus \dots \oplus(a_i \oplus S) \oplus \dots \oplus a_n)=S \oplus S=0
$$
则由于 $a_i$ 和 $S$ 的第 $d$ 位均为 $1$，$a_i \oplus S$ 的第 $d$ 位为 $0$，则更高位必定不变，那么 $a_i \oplus S<a_i$，所以移动方法合法。

新的异或和 $S'=S \oplus a_i \oplus (a_i \oplus S)=0$。新的石子总数 $K'=K-(a_i-(a_i \oplus S))<K$，因为移除了至少一个棋子。那么当前为必胜态。
## 情况2：$S=0$
假设玩家选择一堆 $a_i$ 改为 $a_i'<a_i$，则新异或和 $S'=0 \oplus a_i \oplus a_i'=a_i \oplus a_i' \neq 0$，新石子总数为 $K'=K-(a_i-a_i')<K$。所以当前状态是必败态。
## 完结
所有情况均枚举完毕。通过强归纳法证明完毕。结论成立。
# 最终代码
感谢您认真看到了这里。附上最终的简单的代码。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
	int T;
	cin >> T;
	while (T--) {
		int n, s = 0;
		cin >> n;
		for (int i = 1, x; i <= n; i++)
			cin >> x, s ^= x;
		cout << (s ? "Yes\n" : "No\n");
	} 
	return 0;
}
```

---


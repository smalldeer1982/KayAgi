# [JRKSJ R2] 01 序列

## 题目描述

给你一个长度为 $n$ 的 $01$ 序列 $a_{1\sim n}$，接下来有两种询问共 $m$ 次：

- `1 l r`，表示询问 $l$ 到 $r$ 区间的最长不下降子序列的长度。
- `2 l r`，表示询问 $l$ 到 $r$ 区间的最长上升子序列的长度。

## 说明/提示

本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | $m\le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $\text{1}$ | $10^6$ | $10^6$ | 所有 $a_i$ 均相等 | $5$ |
| $\text{2}$ | $10^3$ | $10^3$ | 无 | $10$ |
| $\text{3}$ | $10^4$ | $10^4$ | 无 | $15$ |
| $\text{4}$ | $10^5$ | $10^5$ | 无 | $30$ |
| $\text{5}$ | $10^6$ | $5\times10^6$ | 无 | $40$ |
| $\text{6}$ | $10^6$ | $5\times10^6$ | hack 数据 | $0$ |

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le m\le 5\times10^6$，$0\le a_i\le 1$。

本题输入输出量极大，请使用较为快速的输入输出方法。

#### 样例解释:
对于第一个询问，满足的序列有：$\{0,1,1,1,1\},\{0,0,0,0,1\}$。\
对于第二个询问，满足的序列有：$\{0,1\}$。\
对于第三个询问，满足的序列有：$\{0,0\},\{0,1\},\{1,1\}$。\
对于第四个询问，满足的序列有：$\{0\},\{1\}$。

$\text{Upd 2021.8.16}$：增加两组 Hack 数据。

## 样例 #1

### 输入

```
8 4
0 1 1 0 1 0 0 1
1 1 8
2 1 8
1 3 6
2 5 6```

### 输出

```
5
2
2
1```

# 题解

## 作者：cyffff (赞：28)

[$\text{Link}$](https://www.luogu.com.cn/problem/P7809)
### 算法 1
针对 $\text{Subtask 1}$。

显然对于询问 $1$，答案为 $r-l+1$，对于询问 $2$，答案为 $1$。

时间复杂度 $O(n+m)$。期望得分 $5\text{pts}$。
### 算法 2
暴力求区间最长不降/上升子序列，时间复杂度 $O(mn^2)$。期望得分 $10\text{pts}$，结合算法 $1$ 可得 $15\text{pts}$。
### 算法 3
设 $pre_{x,i}=\sum_{j=1}^i[a_i=x]$，（$0\le x\le1$，$1\le i\le n$）。

第一问：

其实本质是求 $\max_{i=l}^r pre_{0,i}-pre_{0,l-1}+pre_{1,r}-pre_{1,i}$。

怎么理解这个柿子呢？显然 $pre$ 是前缀和的形式，所以 $pre_{0,i}-pre_{0,l-1}$ 即 $\sum_{j=l}^i[a_i=0]$，$pre_{1,r}-pre_{1,i}$ 即 $\sum_{j=i+1}^r[a_i=1]$。我们可以理解 $i$ 为分界线，分界线前选 $0$，分界线后选 $1$，枚举所有 $l\le i\le r$，显然可以取到最大值，时间复杂度 $O(mn)$。

还需要特判只选 $1$ 的情况，当然你也可以看为求 $\displaystyle\max_{i=l-1}^rpre_{0,i}-pre_{0,l-1}+pre_{1,r}-pre_{1,i}$。

第二问：

显然有答案为 $1$ 或 $2$，答案为 $2$ 时只有在有 $0$ 在最后一个 $1$ 前面，否则为 $1$。

于是我们考虑维护 $bef_i$ 为 $a_i=1$ 时 $i$ 前最后一个 $0$ 所在的位置，否则为 $0$。

答案显然为 $1+[(\max_{i=l}^r bef_i)\ge l]$，暴力枚举，时间复杂度 $O(mn)$。

总时间复杂度 $O(mn)$。期望得分 $25\text{pts}$。

### 算法 4

上面那个东西可以套路ST表处理，时间复杂度 $O(n\log n+m)$，期望得分 $100\text{pts}$。

当然开 $2$ 个ST表常数较大。

用 `+1-1RMQ` 可以做到严格 $O(n+m)$，常数较大，不做为本题最优做法。

这里还有一个后来发现的一个减小常数方法：

发现第二问只有 $1$ 和 $2$ 两种答案，要有 $2$ 则区间中必须出现连续的 $0-1$，于是我们维护 $0-1$ 出现次数的前缀和，如果左端点前缀和等于右端点前缀和，则答案为 $1$，否则为 $2$。可以大大减小常数，如果实现优秀，则可以所有点进 1s。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{//by cyffff
	
}
const int N=1e6+10;
int n,m,st[20][N],lg[N],a[N],pre[N],pp[N];
inline int query(int l,int r){
	int q=lg[r-l+1];
	return max(st[q][l],st[q][r-(1<<q)+1]);
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++){
    	a[i]=read();
	}
	a[0]=2;
	int sum=0,o=0,z=0;
	for(int i=1;i<=n;i++){
		if(a[i]) sum--,o++;
		else sum++,z++;
		st[0][i]=z-o;
		pp[i]=o;
		pre[i]=pre[i-1]+(a[i]==1&&a[i-1]==0);
	}
	for(int i=2;i<=n;i++)
	    lg[i]=lg[i>>1]+1;
	for(int i=1;i<=19;i++)
		for(int j=1;j+(1<<i)-1<=n;j++)
			st[i][j]=max(st[i-1][j],st[i-1][j+(1<<i-1)]);
	for(int i=1;i<=m;i++){
		int opt=read(),l=read(),r=read();
		if(opt==1)
			write(max(pp[r]-pp[l-1],query(l,r)-(l-1-pp[l-1])+pp[r]));
		else
			write(1+!(pre[l]==pre[r]));
		putc('\n');
	}
	flush();
    return 0;
}
```
再见 qwq~

upd：好像赛时还被线段树过了，考虑加入主题库后缩小时限。

---

## 作者：Mars_Dingdang (赞：18)

比赛的时候口胡了一下，赛后写一发题解。感觉题目还是蛮好的。

## 题目大意
给定一个长度为 $n$ 的 01 序列，有 $m$ 次问询，每次询问 $[l, r]$ 的最长上升子序列或者最长不下降子序列。

## 大体思路
首先，一般的序列多次问询显然无法做到题目要求的时间复杂度。所以，我们从 01 序列的特殊性质进行分析。

显然，01 序列的最长上升子序列必然是由单个 $0$，单个 $1$ 或一个连续的子串 $01$ 组成。否则，子序列中就会出现若干个连续的 $0$ 或 $1$，与单调递增的要求不符。所以，这一小问的答案必为 $1$ 或 $2$。进一步，答案为 $2$ 当且仅当存在一个 $01$。所以，我们可以统计 $01$ 这样一个长度为 $2$ 的连续子串出现次数的前缀和 $sum$，然后判断问询区间左右端点的 $sum$ 是否相等即可。时间复杂度 $O(n+m)$。

对于最长不下降子序列，必然先是若干个 $0$，再是若干个 $1$，所以我们可以枚举分割点，即从哪个位置开始是 $1$。具体地，我们记元素 $0$ 出现次数的前缀和为 $pre$，元素 $1$ 出现次数的后缀和为 $lst$。则在位置 $i\in [l, r]$ 进行分割的答案为 $pre_i-pre_{l-1}+lst_i-lst_{r+1}$。所以要求的答案就是 
$$\max_{i\in [l, r]}\{pre_i+lst_i\}-pre_{l-1}-lst_{r+1}$$

求 $\max$ 部分可以使用 ST 表，因此时间复杂度为 $O(n\log n+m)$。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef double db;
const int maxn = 1e6 + 5;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, a[maxn], f[maxn][25], L[maxn], pre[maxn], lst[maxn], sum[maxn];
inline void init() {// ST表预处理
	L[0] = -1;
	rep(i, 1, n) f[i][0] = pre[i] + lst[i], L[i] = L[i >> 1] + 1;
	rep(j, 1, 22)
		for(int i = 1; i + (1 << j) - 1 <= n; i ++)
			f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
}
inline int Max(int x, int y) {// 处理问询 
	int k = L[y - x + 1];
	return max(f[x][k], f[y - (1 << k) + 1][k]);
}
int main () {
	read(n); read(m);
	rep(i, 1, n) {
		read(a[i]);
		pre[i] = pre[i - 1] + (a[i] == 0);
		if(i > 1) sum[i] = sum[i - 1] + (a[i] == 1 && a[i - 1] == 0);
	}
	Rep(i, n, 1) lst[i] = lst[i + 1] + (a[i] == 1);// 统计前、后缀和 
	init();
	while(m --) {
		int op, x, y;
		read(op); read(x); read(y);
		if(op == 1) {//调用 Max 
			writeln(Max(x, y) - pre[x - 1] - lst[y + 1]);
		} else writeln((sum[y] == sum[x] ? 1 : 2));// 判断有无 01 
	}
	return 0;
}
```

---

## 作者：言琢დ (赞：6)

考虑先预处理这些信息：

1. $lstOne_i$ 表示 $1\sim i$ 中最后一个 $1$ 的位置。
2. $firZero_i$ 表示 $i\sim n$ 中第一个 $0$ 的位置。

考虑这些信息有什么用：

对于第一问，最长不下降子序列至多有下列三种情况：

1. `0 0 0 .. 0`
2. `1 1 1 .. 1`
3. `0 0 .. 1 1`

第二种情况直接统计区间中 $1$ 的个数，前缀和即可。

第一种情况直接 **（区间长度-第二种情况）** 即可。

第三种情况，考虑枚举一个断点 $k$。

$k$ 之前的 $0$ 的个数和 $k$ 之后的 $1$ 的个数计算方式如上。

暴力枚举断点是 $O(n)$ 的，考虑使用 ST 表优化这一过程，可以做到 $O(1)$ 查询。

---

对于第二问，如果有形如 `.. 0 .. 1 ..` 的子序列，则答案为 $2$，反之为 $1$。

直接利用上文统计的 $lstOne_i$ 和 $firZero_i$，如果第一个 $0$ 出现在最后一个 $1$ 之前，则代表存在这样的子序列。

详见代码：

```cpp
#include<cstdio>
inline int in();
inline void wr(int);
const int N=(int)3e6+5;
int a[N],Log[N],rmq[N][20],firZero[N],lstOne[N];
inline int mx(int,int);
inline int Query(int,int);
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("A.in","r",stdin);
	freopen("A.out","w",stdout);
#endif
	register int n=in(),m=in();
	for(register int i=1;i<=n;++i){
		a[i]=in();
		if(a[i])lstOne[i]=i;
		else lstOne[i]=lstOne[i-1];
	}
	firZero[n+1]=n+1;
	for(register int i=n;i>=1;--i){
		if(!a[i])firZero[i]=i;
		else firZero[i]=firZero[i+1];
	}
	for(register int i=1;i<=n;++i)
		a[i]+=a[i-1];
	for(register int i=1;i<=n;++i)
		rmq[i][0]=i-2*a[i];
	for(register int j=1;j<20;++j)
		for(register int i=1;i<=n;++i)
			rmq[i][j]=mx(rmq[i][j-1],rmq[i+(1<<(j-1))][j-1]);
	register int j=0;
	for(register int i=1;i<=n;++i)
		if(1<<(j+1)<=i)
			Log[i]=++j;
		else
			Log[i]=j;
	for(register int i=1;i<=m;++i){
		register int tp=in(),l=in(),r=in();
		register int cnt1=a[r]-a[l-1];
		register int cnt0=r-l+1-cnt1;
		if(tp==1){
			register int ans=mx(cnt0,cnt1);
			//第一种：0 0 0 0 0 ... 0
			//第二种：1 1 1 1 1 ... 1
			//第三种：0 0 0 ... 1 1 1
			register int s1=Query(l,r-1)-l+1+a[l-1]+a[r];
			wr(mx(ans,s1)),putchar('\n');
		}
		else
			wr(firZero[l]<=lstOne[r]?2:1),putchar('\n');
	}
}
inline int Query(int l,int r){
	register int ch=r-l+1;
	register int j=Log[ch];
	return mx(rmq[l][j],rmq[r-(1<<j)+1][j]);
}
inline int mx(int x,int y){
	return x>y?x:y;
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

---

## 作者：Superiority (赞：5)

# 思路
我们先看第二个询问，求 $l \sim r$ 中**最长上升子序列的长度**，我们不难发现，答案只能为 $1$ 或 $2$，因为这是个 $01$ 序列，想要是上升子序列只能为 $01$，要么就是 $0$ 或 $1$ 的序列。所以我们可以用前缀和进行预处理，表示 $i$ 前面的出现 $01$ 序列的次数。用一个数组 $s$ 来进行预处理，如果 $s_l - s_r = 0$ 代表 $l \sim r$ 之间没有 $01$ 序列，答案就为 $1$，否则输出 $2$。

接着我们来看第一个询问，求 $l \sim r$ 中**最长不下降子序列的长度**，我们可以试着将 $l \sim r$ 中不下降子序列分成两部分，$i \sim l_0$ 都为 $0$，$i \sim r_1$ 都为 $1$，也即是 $i$ 前的连续 $0$ 和 $i$ 后的连续 $1$，依旧可以使用前缀和实现这一操作，用 $sum0$ 表示 $i$ 前连续 $0$ 的个数，$sum1$ 表示 $i$ 后连续 $1$ 的个数。现在只要记录 $sum0_i -sum0_{l-1} + sum1_i - sum1_{r+1} $ 的最大值就可以了。因为 $sum0_{l-1} + sum1_{r+1}$ 是不会随着 $i$ 改变的，所以我们可以直接使用 st 表来记录 $sum0_i + sum1_i$ 的最大值最后输出时减去 $sum0_{l-1} + sum1_{r+1}$ 就可以了。

- 尽量使用出题人给的快读快写，不然容易超时。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=3e6;
const int N=31;
namespace IO{//by cqbzzjj
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;
int n,T;
int sum[MAXN],cnt[MAXN];
int a[MAXN],s[MAXN];
int st[MAXN][N];
int RMQ(int l,int r){
	int k=1;
	while((1<<k)<r-l+1) k++;
	k--;
	return max(st[l][k],st[r-(1<<k)+1][k]);
}
int main(){
	n=read();
	T=read();
//	cin>>n>>T;
	for(int i=1;i<=n;i++){
		a[i]=read();
//		cin>>a[i]; 
		sum[i]=sum[i-1]+!a[i];
	}
	for(int i=n;i>=1;i--){
		cnt[i]=cnt[i+1]+a[i];
	}
	for(int i=2;i<=n;i++){
		s[i]=s[i-1];
		if(a[i]==1&&a[i-1]==0) s[i]++;
	}
	for(int i=1;i<=n;i++){
		st[i][0]=sum[i]+cnt[i];
	}
	for(int j=1;j<=N-1;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
	while(T--){
		int x,l,r;
		x=read();
		l=read();
		r=read();
//		cin>>x>>l>>r; 
		if(x==1) write(RMQ(l,r)-sum[l-1]-cnt[r+1]);
		else if(s[r]-s[l]==0) write(1);
		else write(2);
		putc('\n');
	}
	flush();
}
```
###### 制作不易，点个赞再走吧。

---

## 作者：Terraria (赞：5)

~~学了线段树就忘了 ST 表的屑来发题解了。~~

## 题目大意

给定一个长度为 $n$ 的 $01$ 序列。有 $m$ 个询问：

`1 l r` 询问区间 $[l,r]$ 的最长**不降**子序列的长度。

`2 l r` 询问区间 $[l,r]$ 的最长**上升**子序列的长度。

$1 \leq n \leq 10^6,1 \leq m \leq 5 \times 10^6$。

## 分析

从这个数据范围就可以得知，每个询问应该是 $\text{O(1)}$ 查询。

首先考虑第一个问。我们可以考虑每一个位置 $i(l \leq i \leq r)$，那么答案就是 $i$ 前面的 $0$ 的个数加上 $i$ 后面的 $1$ 的个数。我们记：

- $sum0[i]$ 为区间 $[i,n]$ 中 $0$ 的个数；

- $sum1[i]$ 为区间 $[i,n]$ 中 $1$ 的个数。

那么对于一个询问 `1 l r`，其答案就是 `sum0[l]-sum0[i+1]+sum1[i]-sum1[r+1]` 的最大值。

由于对于每次询问，`sum0[l]-sum1[r+1]` 是定值，所以我们只需要探索 `sum1[i]-sum0[i+1]` 的最大值即可。这个可以用 ST 表 $\text{O}(n \log n)$ 预处理，$\text{O}(1)$ 查询。~~然后考场上脑抽写了线段树卡常卡半天没过。~~

接下来是第二问。显然答案为 $2$ 或者 $1$。

可以考虑维护 $01$ 前缀和。具体的就是记：

`pre[i]` 为区间 $[1,i]$ 出现串 $01$ 的个数。对于查询的区间，如果 `pre[l]=pre[r]`，则说明在这个区间中没有出现串 $01$，因此答案为 $1$。否则为 $2$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO{//by cyffff
	int len=0;
	char ibuf[(1<<29)+1],*iS,*iT,out[(1<<29)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;

int n,m;
int a[1000009];
int sum[1000009];
int sum0[1000009];//sum[i]表示区间 [i,n] 中0的个数
int sum1[1000009];//sum[i]表示区间 [i,n] 中1的个数
int lg[1000009];
int f[25][1000009];
int pre[1000009];

signed main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=2;i<=n;i++){
		pre[i]=pre[i-1]+(a[i]==1&&a[i-1]==0);
	}
	sum1[n]=a[n];
	for(int i=n-1;i>=1;i--) sum1[i]=sum1[i+1]+a[i];
	sum0[n]=(!a[n]);
	for(int i=n-1;i>=1;i--){
		if(a[i]==0) sum0[i]=sum0[i+1]+1;
		else sum0[i]=sum0[i+1];
	}
	for(int i=1;i<=n;i++) sum[i]=sum1[i]-sum0[i+1];
	lg[0]=-1;
	for(int i=1;i<=n;i++){
		f[0][i]=sum[i];
		lg[i]=lg[i>>1]+1;
	}
	for(int j=1;j<=20;j++){
		for(int i=1;i+(1<<j)-1<=n;i++) f[j][i]=max(f[j-1][i],f[j-1][i+(1<<j-1)]);
	}
	while(m--){
		int op,l,r;
		op=read();
		l=read();
		r=read();
		if(op==1){
			int lo=lg[r-l+1];
			int maxn=max(f[lo][l],f[lo][r-(1<<lo)+1]);
			write(maxn+sum0[l]-sum1[r+1]);
			putc('\n');
		}
		else{
			write((pre[l]==pre[r]?1:2));
			putc('\n');
		}
	}
	flush();
}
```
## 后记

~~上面的代码需要一定的运气成分才能通过：~~ 从[这个记录](https://www.luogu.com.cn/record/56908148)可以看出即使是正解代码，加上 IO 优化，最大点也用了 $1.2s$（差点超时！）。~~所以在一个人少的时候做这道题或许可以跑得更快。~~

---

## 作者：crn1 (赞：3)

## 题外话
之前校内模拟赛做了一道 $01$ 最长不下降子序列带区间修改的 [题目](https://www.luogu.com.cn/problem/CF145E)，想起之前在洛谷比赛中看到了一道类似的，也就是本题，就过来做了。

## 题意
给出一个长度为 $n$ 的 $01$ 序列 $a$，有两种询问：
1. 区间最长不下降子序列
2. 区间最长上升子序列

先看比较简单的第二种询问，显而易见，答案只可能为 $1$ 或 $2$。前缀和 $s$ 统计 $2\sim i$ 中 $a_{i-1}=0$ 且 $a_i=1$ 的个数，对于区间 $[l,r]$，如果 $s_l=s_r$ 说明在区间 $[l,r]$ 中不存在 $01$，则输出 $1$，否则输出 $2$。

接着看第一种询问，看到区间询问，第一反应就是线段树，但是一看数据范围 $1\leq m\leq 5\times10^6$，发现询问次数太多了，普通线段树的 $\mathcal{O}(\log n)$ 查询会 TLE。所以需要一种支持更低复杂度的区间查询的数据结构。

## 猫树
猫树是线段树的拓展，是一种不支持修改，但支持快速区间询问的一种静态线段树。以最简单的区间和为例，建树复杂度为 $\mathcal{O}(n\log n)$，单次询问复杂度仅为 $\mathcal{O}(1)$。

### 原理
设线段树中 $l$ 对应节点和 $r$ 对应节点的 LCA 为 $x$，则 $x$ 节点代表的区间 $[L,R]$ 一定包含 $[l,r]$，且 $[L,R]$ 的中点 $mid$ 一定在区间 $[l,r]$ 中。

仍然以区间和为例，建树时对于每个节点 $x$ 和其代表的范围 $[l,r]$ 及区间中点 $mid$，记录 $l\sim mid$ 的后缀和及 $mid+1\sim r$ 的前缀和。对于每次询问区间 $[l,r]$ 的和，先找到 $l,r$ 对应节点的 LCA，答案可分为两部分：$l$ 到 LCA 代表区间的中点的和还有中点到 $r$ 的和。

### LCA

但现在仍有一个问题，如何快速求出线段树中两个节点的 LCA ？

注意到父节点和左右儿子的节点编号，左儿子节点编号为父亲的编号乘 $2$，右儿子节点编号为父亲的编号乘 $2$ 再加 $1$。如果从位运算的角度看此过程，左儿子编号为父亲的编号左移 $1$，而右儿子编号为父亲编号左移 $1$ 再或 $1$。

如果将序列长度补成大于等于原序列长度且最小的二的幂，则树中所有叶子节点的深度相同，也就是说序列中的每个 $i\ (1\leq i\leq n)$ 对应的节点的编号在二进制下，最高的 $1$ 的位置相同，且最高的 $1$ 的位置为节点深度。此外，节点编号中的每个 $0/1$ 都表示着是左儿子还是右儿子。

有了这个性质，很容易发现 $l$ 对应的节点 $x$ 和 $r$ 对应的节点 $y$ 的 LCA，
$$lca(x,y)=x >> (\log_{2}{(x\ xor\ y)}+1)$$

## 建树
考虑最长上升子序列可以由哪几种情况组成

1. 全是 $0$
2. 全是 $1$
3. LCA 代表区间中点左边是以 $1$ 结尾的最长不下降子序列，右边全是 $1$
4. LCA 代表区间中点右边是以 $0$ 开头的最长不下降子序列，左边全是 $0$

对于 $1,2$ 两种情况，可以直接由前缀和得出，$3,4$ 两种情况的全是 $0/1$ 也可以由前缀和得出，所以线段树中只需维护区间中点左边的以 $1$ 结尾的最长不下降子序列和右边以 $0$ 开头的最长不下降子序列即可。

以上两个信息都可以通过 DP 求出，设 DP 状态为 $f[dep][i]$（其中 $dep$ 表示节点深度），对于 $i\leq mid$（$mid$ 为区间中点），表示的是以 $0$ 开头的最长不下降子序列的长度，对于 $i>mid$，表示的是以 $1$ 结尾的最长不下降子序列的长度，可以得出转移  
当 $i\leq mid$：
$$f[dep][i]=
\begin{cases}
f[dep][i+1]\ (a_i\neq0)\\
max(f[dep][i+1], \sum_{j=i+1}^{mid}[a_j=1])+1\ (a_i=0)
\end{cases}$$
当 $i> mid$：
$$f[dep][i]=
\begin{cases}
f[dep][i-1]\ (a_i\neq1)\\
max(f[dep][i-1], \sum_{j=mid+1}^{i-1}[a_j=0])+1\ (a_i=1)
\end{cases}$$

## 询问
在四种情况中取最大值即可，注意 $l=r$ 的时候需要特判。

## 代码
时间复杂度为 $\mathcal{O}(n\log n+m)$
```cpp
#include <algorithm>
#include <cstdio>

namespace IO{//by cyffff
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;

const int N = 2000005;
int lg[N << 2], a[N];
struct node {
	int l, r;
} tr[N << 2];
int f[23][N << 2], s1[N], s2[N], s3[N], id[N]; 
// f 为 dp 数组，s1 为 0 的个数个前缀和，s2 为 1 的个数的前缀和
// s3 为 a[i - 1] = 0 且 a[i] = 1 的个数的前缀和

#define dep lg[x]
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)

void build(int l, int r, int x) {
	tr[x].l = l, tr[x].r = r;
	int mid = l + r >> 1;
	if (l == r) return id[l] = x, void(); // 记录序列中元素对应的叶子节点
	f[dep][mid] = !a[mid], f[dep][mid + 1] = a[mid + 1];
	for (int i = mid - 1; i >= l; i--)
		if (a[i]) f[dep][i] = f[dep][i + 1];
		else f[dep][i] = std::max(f[dep][i + 1], s2[mid] - s2[i]) + 1;
	// dp 维护 i <= mid 以 0 开头的最长不下降子序列
	for (int i = mid + 2; i <= r; i++)
		if (a[i]) f[dep][i] = std::max(f[dep][i - 1], s1[i - 1] - s1[mid]) + 1;
		else f[dep][i] = f[dep][i - 1];
	// dp 维护 i > mid 以 1 结尾的最长不下降子序列
	build(l, mid, ls(x)), build(mid + 1, r, rs(x));
}

int query(int l, int r) {
	if (l != r) {
		int x = id[l] >> lg[id[l] ^ id[r]] + 1, mid = tr[x].l + tr[x].r >> 1;
		return std::max(std::max(s1[r] - s1[l - 1], s2[r] - s2[l - 1]), std::max(s1[mid] - s1[l - 1] + f[dep][r], f[dep][l] + s2[r] - s2[mid]));
	}
	return 1;
}

#undef dep

int main(void) {
	int n = read(), m = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	int len = 1; while (len < n) len <<= 1; n = len;
	for (int i = 2; i <= n << 2; i++) lg[i] = lg[i >> 1] + 1;
	for (int i = 1; i <= n; i++)
		s1[i] = s1[i - 1] + !a[i], s2[i] = s2[i - 1] + a[i];
	for (int i = 2; i <= n; i++)
		s3[i] = s3[i - 1] + (a[i] && !a[i - 1]);
	build(1, n, 1);
	for (int i = 1, op, l, r; i <= m; i++) {
		op = read(), l = read(), r = read();
		if (op == 1) write(query(l, r));
		else if (op == 2) write(s3[l] != s3[r] ? 2 : 1);
		putc('\n');
	}
	flush();
	return 0;
}
```

---

## 作者：critnos (赞：3)

以 P7809 作为例题。

这题的第二问 simple，我们关注第一问。

> 求 $01$ 序列区间最长不下降子序列。

第一问所需的信息显然是半群信息。维护区间中 $0$ 的个数 $s_0$，$1$ 的个数 $s_1$ 和区间最长不下降子序列的长度 $ans$。合并两个信息的时候，区间最长不下降子序列的长度为 $\max(s_{0_x}+ans_y,ans_x+s_{1_y})$。

这时候我们已经有一个可以维护半群信息的数据结构了：猫树（二区间合并）。一个 $O(n\log n)-O(1)$ 的方法。

考虑序列分块，令块长 $b=\Theta(\log n)$。对每块内求出该块内的信息并，并用猫树维护这 $\dfrac n b$ 个信息并，复杂度为 $O(\dfrac n b\log(\dfrac n b))=O(n)$。再对每块内求出前缀、后缀的信息并。此时一个查询操作可以分为三部分：$l$ 所在块的，从 $l$ 到该块尾的后缀信息并，猫树所维护的中间多块的信息并的并，和 $r$ 所在块的，从该块头到 $r$ 的前缀信息并。

然而还没有处理 $l,r$ 在同一块的情况。

所以下面就是四毛子的精髓：

重新令块长为 $b=k\log n,0<k<1$。这并不影响上面的猫树的复杂度。由于序列为 $01$ 序列，所以共有 $2^b=n^k$ 个本质不同的块。对每个块求出该块内所有可能的询问的答案。时间复杂度为 $O(n^k b^2)$，渐近低于 $O(n)$。

那么就可以 $O(1)$ 回答每个 $l,r$ 同块的询问。故而我们对这题做到了 $O(n)-O(1)$ 的复杂度。

不过这题有另一种更简单的做法。

令块长为 $b=\log n$。

一个 $01$ 区间可以被压缩成一个整数，$[0,2^b)$ 范围内。

对于每个整数，提出他在最高位的 $1$ 及以前的 bit，作为一个 $01$ 序列。低位在前。

如 $10\rightarrow 0101$。

求出该 $01$ 序列的最长不下降子序列长度。对于 $10$，答案显然为 $3$。

这一步容易做到 $O(2^b b)=O(n \log n)$，考虑做到 $O(n)$。

递推。设递推数组为 $ans$。

考虑从 $i$ 减去最高位的 $1$ 的数 $j$ 递推而来。

以上面的 $10$ 为例，从 $01\rightarrow 2$ 递推而来。

加上这个  $1$ 后，有两种可能：

* 在 $j$ 的最长不下降子序列后面加上这个 $1$，$ans_i=ans_j+1$。

* 以这个 $1$  新开一个，即前面全是 $0$，后面加上这个 $1$。为什么要考虑这种情况？因为在最高位和次高位的 $1$ 之间可能有一些 $0$。

特别的，令 $ans_0=0$。

```cpp
for(i=2;i<(1<<b);i++)
	lg[i]=lg[i>>1]+1;
for(i=1;i<(1<<b);i++)
	ans[i]=max(ans[i-(1<<lg[i])]+1,lg[i]-__builtin_popcountll(i)+2);	
```
不过在询问的时候我们不能直接将区间提取出来！因为这样会有一个问题，就是在这个最高位的 $1$ 后还有一些 $0$。

不过解决方法也很简单：如果要用到这些 $0$，那么前面选的也必须都是 $0$。那么这个的答案就是这个区间中 $0$ 的个数。和 $ans$ 取个 $\max$ 就行。

code：

```cpp
#include<bits/stdc++.h>
#define Misaka namespace
#define Mikoto std
using Misaka Mikoto;
namespace IO{//by cyffff
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;
const int mxn=1e6+5;
const int b=20;
const int mxb=1<<b;
int presum[mxn]; 
int a[mxn];
struct node
{
	int ze,on,ans;
	friend node operator +(const node &x,const node &y)
	{
		return node({x.ze+y.ze,x.on+y.on,max(x.ze+y.ans,x.ans+y.on)});
	}
}p[mxn],bls[mxn/b*2+5],pre[mxn],nxt[mxn];
node ct[25][mxn/b*2+5];
int L[mxn/b+5],R[mxn/b+5];
int be[mxn];
int ans[1<<b];
int lg[1<<b];
int wordb[mxn/b+5];
int n,d2;
void build(int l,int r,int deep)
{
	if(l==r) return;
	int mid=l+r>>1,i;
	ct[deep][mid]=bls[mid],ct[deep][mid+1]=bls[mid+1];
	for(i=mid-1;i>=l;i--)
		ct[deep][i]=bls[i]+ct[deep][i+1];
	for(i=mid+2;i<=r;i++)
		ct[deep][i]=ct[deep][i-1]+bls[i];
	build(l,mid,deep+1),build(mid+1,r,deep+1);
}
node ask_cat(int pl,int pr)
{
	if(pl>pr) return node({0,0,0});
	if(pl==pr) return bls[pl];
	int d=lg[pl+d2-1]-lg[pl+d2-1^pr+d2-1]-1;
	return ct[d][pl]+ct[d][pr];
}
void init()
{
	int i,j,cnt=0;
	for(i=1;i<=n;i+=b)
		L[++cnt]=i,R[cnt]=min(n,i+b-1);
	for(i=1;i<=cnt;i++)
	{
		for(j=L[i];j<=R[i];j++)
			be[j]=i,bls[i]=bls[i]+p[j],wordb[i]+=a[j]?1<<j-L[i]:0;
		pre[L[i]]=p[L[i]];
		for(j=L[i]+1;j<=R[i];j++)
			pre[j]=pre[j-1]+p[j];
		nxt[R[i]]=p[R[i]];
		for(j=R[i]-1;j>=L[i];j--)
			nxt[j]=p[j]+nxt[j+1];
	}
	for(d2=1;d2<cnt;d2<<=1);
	for(i=2;i<mxb;i++)
		lg[i]=lg[i>>1]+1;
	build(1,d2,0);
	for(i=1;i<mxb;i++)
		ans[i]=max(ans[i-(1<<lg[i])]+1,lg[i]-__builtin_popcountll(i)+2);	
}
int ask(int l,int r)
{
	int bl=be[l],br=be[r];
	if(bl==br) 
	{
		int c=(wordb[bl]>>l-L[bl])&((1<<r-l+1)-1);
		return max(ans[c],r-l+1-__builtin_popcountll(c));
	} 
	return (nxt[l]+ask_cat(bl+1,br-1)+pre[r]).ans;
}
int main()
{
	n=read();
	int m=read(),i,opt,l,r;
	for(i=1;i<=n;i++)
		a[i]=read(),presum[i]=presum[i-1]+(a[i]&&!a[i-1]),a[i]?p[i].on=1:p[i].ze=1,p[i].ans=1;
	init();
	for(;m--;putc('\n'))
	{
		opt=read(),l=read(),r=read();
		if(opt==1) write(ask(l,r));
		else write((presum[l]<presum[r])+1);
	}
	flush();
} 
```


---

## 作者：Binaerbaka (赞：2)

## 题面
对一个长度为 $n$ 的 $01$ 序列进行 $m$ 次询问，每次询问有两种操作

1. 查询 $l,r$ 的最长不下降子序列
2. 查询 $l,r$ 的最长上升子序列

## 过程

优先考虑询问二，最长上升子序列只会有两种可能，

$0$ 或者 $1$ 或者 $01$。

其他情况都无法满足上升子序列的要求，也就是说它的长度不是 $1$ 就是 $2$。

如果实现此询问呢 只需要利用一个前缀和数组 $sum$ 来保存每一个 $i$ 下标所满足的 $a_{i-1}=0$ 和 $a_i=1$ 之后查询区间是否相等即可解决。


其次考虑询问一，最长不下降子序列则有三种可能。

$00$ 或者 $11$ 或者 $01$。

这次我们可以用一个前缀和数组 $sum0$ 和一个后缀和数组 $sum1$ 来记录当前位置 $i$ 上，连续的 $0$ 和连续的 $1$ 的数量。 之后记录**每个** $l,r$ 区间 $sum0+sum1$ 的最大值。

当前 $l,r$ 区间的 $sum0_i+sum1_i$ 长度最大值，减去 $sum0_{i-1}$ 再减去 $sum1_{i+1}$ 即为答案所求。

维护区间最大值可以用线段树跟st表，但前者相比后者多了个对数，在本题极限范围无法通过，所以给出后者 std。

本题卡常 要记得用快读跟取消宏定义。

## std
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
const int inf=2147483647;
int n,m,a[maxn],lg[maxn];
int f[maxn][21];
int sum[maxn],sum1[maxn],sum0[maxn];//pre:0 of front lst:1 of back sum:0&1pre	
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void init(){
	for(int i=1;i<=n;i++)f[i][0]=sum0[i]+sum1[i];;
	for(int j=1;j<=20;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
}
int maxx(int l,int r){
	int k=lg[r-l+1];
	return max(f[l][k],f[r-(1<<k)+1][k]);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	n=read(),m=read();
	lg[1]=0;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)sum0[i]=sum0[i-1]+(a[i]==0);
	for(int i=n;i>=1;i--)sum1[i]=sum1[i+1]+(a[i]==1);
	for(int i=2;i<=n;i++)sum[i]=sum[i-1]+(a[i]==1&&a[i-1]==0),lg[i]=lg[i>>1]+1;
	init();
	while(m--){
		int op,l,r;
		op=read(),l=read(),r=read();
		if(op==1)cout<<(maxx(l,r)-sum0[l-1]-sum1[r+1]);
		else cout<<(sum[l]==sum[r]?1:2);
		cout<<"\n";
	}
	return 0;
}
```


---

## 作者：billtun (赞：2)

[传](https://www.luogu.com.cn/problem/P7809) [送门。](https://www.luogu.com.cn/blog/546730/solution-p7809)
### 正解：

把一个题分为两个提来考虑：
对于每一个询问，有两种情况：$opt=1$（最长不下降子序列），$opt=2$（最长上升子序列）。

#### 当 opt=1 时（最长不下降子序列）：

最优解（子序列）有 $3$ 种情况，分别是。
  $$
  \begin{cases}
  00000\cdots000 \\
  11111\cdots111\\
  0000\cdots1111
  \end{cases}
  $$
我们可以用前缀和求出前两个，而后一个可以分为两部分（前一部分全是 $0$ ，后一部分全是 $1$ ），求法如前两个（可以用 ST 表优化）。

#### 当 opt=2 时（最长上升子序列）：

答案无非是 $1$ 或 $2$ ，这时我们可以预处理两个数组 $sum0$ 和 $sum1$：

 $sum1_i$ 用来记录第 $i$ 个元素之前的第一个 $1$ 的**下标**。

 $sum0_i$ 用来记录第 $i$ 个元素之后的第一个 $0$ 的**下标**。

所以当这个区间内第一个 $0$ 在最后一个 $1$ 的前面（即存在 $\cdots0\cdots1\cdots$），就输出 $2$ ，否则输出 $1$。

AC Code:
```cpp
#include<stdio.h>
#include<iostream>
using namespace std;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
} // 快读 

int n, m, opt, l, r;
bool a[3000005];
int log[3000005], sum[3000005], f[3000005][25]; // sum前缀和（求 L~R 中 1 的个数)
int sum0[3000005], sum1[3000005]; // 详解见上 

int get_ans1(int l, int r){ // 最长不下降子序列 
	int tmp=log[r-l+1];
	return max(max(sum[r]-sum[l-1], (r-l+1)-(sum[r]-sum[l-1])), max(f[l][tmp], f[r-(1<<tmp)+1][tmp])-l+1+sum[l-1]+sum[r]);
}

int get_ans2(int l, int r){ // 最长上升子序列 
	return (sum0[l]<sum1[r] ? 1 : 0)+1;
}

int main()
{
	n=read(), m=read();
	log[0]=-1;
	for(int i=1;i<=n;i++){
		a[i]=read();
		sum[i]=sum[i-1]+a[i];
		log[i]=log[i>>1]+1;
		if(a[i]) sum1[i]=i;
		else sum1[i]=sum1[i-1];
		f[i][0]=i-2*sum[i];
	}
	
	sum0[n+1]=n+1;
	for(int i=n;i>=1;i--){
		if(!a[i]) sum0[i]=i;
		else sum0[i]=sum0[i+1];
	} // write it for "get_ans2(){ ... }" 
	
	for(int j=1;j<=20;j++){
		for(int i=1;i<=n;i++){
			f[i][j]=max(f[i][j-1], f[i+(1<<j-1)][j-1]); // "-" 优先级比 "<<" 高
		}
	}
			
	for(int i=1;i<=m;i++){
		opt=read(), l=read(), r=read();
		if(opt==1) printf("%d\n", get_ans1(l, r));
		else printf("%d\n", get_ans2(l, r));
	}
	
	return 0;
}
```

---

## 作者：tder (赞：1)

本来切 ST 表的时候正好看见了一道月赛题，以为能板子秒了，但这题的卡常简直比 noip 还毒瘤。

---

对于 01 序列求区间最长（严格）递增子序列。

首先考虑最长严格递增子序列，显然严格递增最长为 $\tt01$，即长度最长为 $2$，当且仅当区间中含有 $\tt01$ 子串时。可以用前缀和递推 $\tt01$ 子串的出现次数，则最长严格递增子序列长度为 $2$ 当且仅当区间两端点的出现次数相同。

最长递增子序列必定形如 $\tt00\cdots0011\cdots11$。对于 $\tt0$ 和 $\tt1$ 中间的位置，其左 $\tt0$ 的个数及其右 $\tt1$ 的个数均可预处理，用 ST 表维护即可。

这里主要分享一些卡常小技巧，包括但不限于：

- 快读快写；
- ST 表实现预处理 $\log k$；
- 不要用 class 等花哨类；
- 位运算；
- `inline` 与 `register`；
- 多循环合一。

不过真的觉得时限应开到 $1.4s$ 会比较合适。

---

```cpp
cin>>n>>m;
for(int i = 1; i <= n; i++) {
    cin>>a[i];
    l[i] = l[i - 1] + !a[i];
    s[i] = s[i - 1] + (a[i] && !a[i - 1]);
}
for(int i = n; i >= 1; i--) r[i] = r[i + 1] + (bool)a[i];
build();
while(m--) {
    int q, x, y;
    cin>>q>>x>>y;
    if(q == 1) cout<<get(x, y) - l[x - 1] - r[y + 1]<<endl;
    else cout<<(s[x] != s[y]) + 1<<endl;
}
```

---

## 作者：fuwei123 (赞：1)

### 分析

首先，这道题用一般的最长上升或是最长不下降子序列求法都是不行的，只能从序列只有 $0$ 或 $1$ 这个特点下手。

- 对于操作二，我们其实就是要找到序列中有没有形如 $01$ 这样的子序列，只要有，那么就输出 $2$，如果没有就输出 $1$。

- 对于操作一，我们就要找到最长的形如 $00111$ 这样的子序列，输出它的长度。

### 做法

先考虑操作二。我们发现，最朴素的办法，就是看这个区间**左端点右边**的第一个 $0$ 是否在**右端点左边**的第一个 $1$ 的前面。我们可以预处理出 $lft_i$ 表示 $i$ 左边的第一个 $1$ 的下标（也考虑自己），$rgt_i$ 表示 $i$ 右边第一个 $0$ 的下标（也考虑自己），直接判断即可。

那么具体怎么预处理呢？分两种情况讨论。
- 若 $a_i=0$，则 $lft_i=lft_i-1$，$rgt_i=i$。
- 若 $a_i=1$，则 $lft_i=i$，$rgt_i=rgt_i-1$。

预处理复杂度 $O(n)$，查询复杂度 $O(1)$。

再考虑操作一。可以记 $cnt0_i$ 表示 $i$ 左边 $0$ 的个数，$cnt1_i$ 表示 $i$ 右边 $1$ 的个数。注意这里 $cnt0_i$ 和 $cnt1_i$ 都是**包含** $i$ 的。查询时，答案就是  $\max\limits_{i=l}^r(cnt0_i+cnt1_i)-cnt0_{l-1}-cnt1_{r+1}$。

而括号中的部分，我们可以使用 **ST 表**预处理，时间复杂度 $O(\log n)$，查询的复杂度为 $O(1)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 1000005
int st[21][MAXN], n, m, a[MAXN], cnt0[MAXN], cnt1[MAXN], g[MAXN];//左边0的个数，右边1的个数 
int lft[MAXN], rgt[MAXN];//i左边第1个1,i右边第1个0（下标 
//168 000 000

namespace IO{
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;


void get_cnt(){ 
	for(int i = 1;i <= n;i++){
		cnt0[i] = cnt0[i - 1];
		if(a[i] == 0)cnt0[i]++;
	}
	for(int i = n;i >= 1;i--){
		cnt1[i] = cnt1[i + 1];
		if(a[i] == 1)cnt1[i]++;
	}
}
void get_st(){
	for(int i = 1;i <= n;i++){
		st[0][i] = cnt0[i] + cnt1[i];
	} 
	for(int k = 1;(1 << k) <= n;k++){
		for(int i = 1;i + (1 << k) - 1 <= n;i++){
			st[k][i] = max(st[k - 1][i], st[k - 1][i + (1 << (k - 1))]);
			//当前区间的最大值就是，左区间的最大值和右区间的最大值的最大值 
		}
	}
}
void get_lr(){
	for(int i = 1;i <= n;i++){
		if(a[i] == 1)lft[i] = i;
		else lft[i] = lft[i - 1];
	}
	for(int i = n;i > 0;i--){
		if(a[i] == 0)rgt[i] = i;
		else rgt[i] = rgt[i + 1];
	}
}
void get_log2(){ //预处理每个长度n 对应的log2(n) 
	g[1] = 0;
	for(int i = 2;i <= n;i++){
		g[i] = g[i / 2] + 1;
	}
}

void pre(){
	get_cnt();
	get_st();
	get_lr();
	get_log2();
}//预处理所有需要的数组 

int main(){
	n = read();
	m = read();
	for(int i = 1;i <= n;i++){
		a[i] = read(); 
	}
	
	pre();
	for(int i = 1;i <= m;i++){
		int opt, l, r;
		opt = read();
		l = read();
		r = read();
		if(opt == 1){
			int l_log = g[r - l + 1];
			int ans = max(st[l_log][l], st[l_log][r - (1 << l_log) + 1]);
			write(ans - cnt0[l - 1] - cnt1[r + 1]);
			putc('\n');
		}else{
			if(rgt[l] < lft[r] && rgt[l] != 0 && lft[r] != 0){ //区间左端点右边第一个0比右端点左边第一个1的下标小，那么就能构成01，即一个长度为2的最长上升子序列
				write(2);
				putc('\n');
			}
			else{
				write(1);
				putc('\n');
			}
		}
	}
	flush();
	return 0;
}
```
代码中 $g_i$ 表示 $\log i$，用 $O(n)$ 时间预处理，保证查询的时间复杂度为 $O(1)$。

---

## 作者：billzd (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P7809)

___
题意很明确，这里就不再重复了。

首先，我们对这个 $01$ 序列进行如下预处理，维护前缀和和前缀 $0$ 和，即

$sum1[j]=\sum^{j}_{i=1}a[i]$ 和 $sum0[j]=j-\sum^{j}_{i=1}a[i]$ 。

考虑这些东西有什么用，对于操作 $2$ ，可以维护 $\_01[i]$ 统计区间 $[1,n]$ 出现过多少 $01$ 串。如果 $\_01[l]=\_01[r]$ , 答案为 $1$ ，否则为 $2$ 。

操作 $1$ ，由于是 $01$ 串组成，所以最长不下降子序列必然是一个这样的子序列。

```
0,0,0,...0,1,1,...1
```

我们可以找到断点 $i$ ，在 $i$ 的左侧所选数全为 $0$ ，右侧全为 $1$ 。

那么 $ans=\max^{r}_{i=l}(sum1[r]-sum[i-1]+sum0[i]-sum0[l-1])$ 。

我们发现 $sum1[r]-sum0[l-1]$ 为定值，剩下的部分用 $st$ 表维护便可以了。

**本题读入量较大，记得优化读入方式。**
___

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
class generals{
	#define flush() fwrite(obuf,1,oS-obuf,stdout),oS=obuf
	#define SIZE 10000000
	char ibuf[SIZE],obuf[SIZE],*iS,*iT,*oS,*oT,qu[55],c;
	int qr;
	bool f;	
	inline char getchar(){return iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,SIZE,stdin),(iS==iT?EOF:*iS++)):*iS++;}
	inline void putchar(const char&x){*oS++=x,oS==oT?flush():0;}
public:	
	generals(){oS=obuf,oT=oS+SIZE-1;}
	~generals(){flush();}	
	template<typename T>
	generals&operator>>(T&x){
		for(f=1,c=getchar();!isdigit(c);c=getchar())
			f^=c=='-';
		for(x=0;isdigit(c);c=getchar())
			x=(x<<1)+(x<<3)+(c&15);
		x=f?x:-x;
		return*this;
	}
	generals&operator>>(char&ch){
		ch=getchar();
		while(ch==' '||ch=='\n'||ch=='\r')
			ch=getchar();
		return*this;
	}
	generals&operator>>(char*s){
		int cnt(0);
		char ch=getchar();
		while(ch==' '||ch=='\n'||ch=='\r')
			ch=getchar();
		while(ch==' '&&ch=='\n'&&ch=='\r'){
			s[cnt++]=ch;
			ch=getchar();
		}
		s[cnt]='\0';
		return*this;
	}
	template<typename T>
	generals&operator<<(T x){
		if(!x) putchar(48);
		else{
			if(x<0) putchar('-'),x=-x;
			while(x) qu[++qr]=x%10^48,x/=10;
			while(qr) putchar(qu[qr--]);
		}
		return*this;
	}
	generals&operator<<(const char&ch){
		putchar(ch);
		return*this;
	}
	generals&operator<<(const char*s){
		for(int i=0;s[i];++i)
			putchar(s[i]);
		return*this;
	}
	#undef flush
	#undef SIZE
}in,out;
inline int max(int a,int b){
    return a>b?a:b;
}
const int N = 5e6+5;
int _01[N],st[N][31],sum1[N],sum0[N],lg[N];
short a[N];
inline int query(int l,int r){
    int k=lg[r-l+1];
    return max(st[l][k],st[r-(1<<k)+1][k]);
}
int main(){
    int n,m;
    in>>n>>m;
    a[0]=514;
    for(int i=1;i<=n;i++){
        in>>a[i];
        sum1[i]=sum1[i-1]+a[i];
        sum0[i]=sum0[i-1]+(!a[i]);
        _01[i]=_01[i-1]+(a[i]==1&&!a[i-1]);
    }
    lg[0]=-1;
    for(int i=1;i<=n;i++){
        lg[i]=lg[i>>1]+1;
        st[i][0]=sum0[i]-sum1[i-1];//sum1[r]-sum0[l-1]+sum0[i]-sum1[i-1]
    }
    for(int j=1;j<=21;j++)
        for(int i=1;i+(1<<j)-1<=n;i++)
            st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
    for(int i=1;i<=m;i++){
        int op,l,r;
        in>>op>>l>>r;
        if(op==1){
            int ans=sum1[r]-sum0[l-1]+query(l,r);
            out<<ans<<'\n';
        }
        else out<<(_01[l]==_01[r]?"1\n":"2\n");
    }
    return 0;
}
```


---

## 作者：ZBH_123 (赞：1)

## 题目分析

如果是一个普通的序列，那这道题可能确实难以下手。但是，本题给出的序列是 $01$ 序列。既然题目给的序列特殊，那就必定有特殊性的应用。我们看到第二个询问：求区间内最长上升子序列的长度。因为序列只有 $0$ 和 $1$，所以最长上升子序列的长度只能是 $1$ 或 $2$。下面分情况进行讨论：

1. 如果区间内存在形如 $\{0,1\}$ 的子序列，那么长度为 $2$。
2. 否则长度为 $1$。

这样，第二问就解决了。

接下来是第一个询问：求区间内最长不下降子序列的长度。同样，因为序列只有 $0$ 和 $1$，所以最长不下降子序列会有一条明显的分界线：分界线前全是 $0$，分解线后全是 $1$。定义 $sum_{x,0}$ 表示前 $x$ 个数中 $0$ 的个数，$sum_{x,1}$ 表示前 $x$ 个数中 $1$ 的个数，则当分界点为 $i$ 时，能得到的区间 $[l,r]$ 的最长不下降子序列为 $sum_{i,0}-sum_{l-1,0}+sum_{r,1}-sum_{i,1}$。因为 $sum_{r,1}-sum_{l-1,0}$ 是定值，所以我们只需要找到 $\max_{i=l}^{r}{(sum_{i,0}-sum_{i,1})}$，就可以得到最长不下降子序列的长度为 $sum_{r,1}-sum_{l-1,0}+\max_{i=l}^{r}{(sum_{i,0}-sum_{i,1})}$ 了。

## 代码实现

对于第一问求 RMQ，可以使用 ST 表，线段树等数据结构进行维护。对于第二问，我们只需要维护每一个 $a_i=1$ 的前面的最后一个 $0$ 的位置 $p_i$。判断区间 $[l,r]$ 是否存在 $\{0,1\}$，只需要判断 $\max_{i=l}^{r}{p_i}$ 是否大于等于 $l$ 就行了。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;

const int maxn=1e6;
int n,m,a[maxn+5],p[maxn+5],s[maxn+5][2],f1[maxn+5][30],f2[maxn+5][30];

int RMQ(int l,int r,int op){
	int k=__lg(r-l+1);
	if(op==1) return max(f1[l][k],f1[r-(1<<k)+1][k]);
	else return max(f2[l][k],f2[r-(1<<k)+1][k]);
}

void solve(){
	cin>>n>>m;
	int pos=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s[i][0]=s[i-1][0],s[i][1]=s[i-1][1];
		if(a[i]==1) p[i]=pos,s[i][1]++;
		else pos=i,s[i][0]++;
	}
	
	for(int i=1;i<=n;i++) f1[i][0]=s[i][0]-s[i][1],f2[i][0]=p[i];
	for(int j=1;j<=25;j++){
		for(int i=1;i+(1<<j)-1<=n;i++){
			f1[i][j]=max(f1[i][j-1],f1[i+(1<<(j-1))][j-1]);
			f2[i][j]=max(f2[i][j-1],f2[i+(1<<(j-1))][j-1]);
		}
	}
	
	while(m--){
		int op,x,y;
		cin>>op>>x>>y;
		if(op==1){
//			cerr<<RMQ(x,y,1)<<' '<<s[y][1]<<' '<<s[x-1][0]<<'\n';
			int ans=RMQ(x,y,1)+s[y][1]-s[x-1][0];
			ans=max(ans,max(s[y][1]-s[x-1][1],s[y][0]-s[x-1][0]));
			cout<<ans<<'\n';
		}
		else cout<<1+(RMQ(x,y,2)>=x)<<'\n';
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：__Creeper__ (赞：1)

###  题意

对一个长度为 $n$ 的 $01$ 序列进行 $m$ 次询问，每次询问有两种操作：
- `1 l r` 查询 $l$，$r$ 的最长**不下降**子序列。
- `2 l r` 查询 $l$，$r$ 的最长**上升**子序列。

### 思路

优先考虑询问二，满足最长上升子序列的方案只会有两种可能：$0$，$1$，$01$，长度为 $1$ 或者 $2$ 可以考虑维护 $01$ 前缀和。具体的就是记：`s[i]` 为区间 $[1,i]$ 出现串 $01$ 的个数。对于查询的区间，如果 `s[l] = s[r]`，则说明在这个区间中没有出现串 $01$，因此答案为 $1$，否则为 $2$。

再考虑询问一，我们可以考虑每一个位置  $i (l \le i \le r)$ 这次我们可以用一个前缀和数组 $s0$ 和一个后缀和数组 $s1$ 来记录当前位置 $i$ 上，连续的 $0$ 和连续的 $1$ 的数量。之后记录每个 $[l,r]$ 区间 $s0 + s1$ 的最大值。维护区间最大值可以用 st 表来维护。

### Code
```cpp

#include <bits/stdc++.h>
//#define int long long
using namespace std;

namespace IO{//by cyffff
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;

const int N = 1e6 + 10;
const int inf = 2e9;
int n, m, a[N];
int st[N][40], s[N], s1[N], s0[N];

signed main()
{
	n = read();
	m = read();
	for ( int i = 1; i <= n; i++ ) a[i] = read(), s0[i] = s0[i-1] + ( a[i] == 0 );
	for ( int i = n; i >= 1; i-- ) s1[i] = s1[i+1] + ( a[i] == 1 );
	for ( int i = 1; i <= n; i++ ) s[i] = s[i-1] + ( a[i] == 1 && a[i-1] == 0 ), st[i][0] = s0[i] + s1[i];
	
	for ( int j = 1; j <= 20; j++ )
	{
		for ( int i = 1; i + ( 1 << j ) - 1 <= n; i++ )
		{
			st[i][j] = max ( st[i][j-1], st[i + ( 1 << ( j - 1 ) )][j-1] );
		}
	}
	
	for ( int i = 1; i <= m; i++ )
	{
		int op, l, r;
		op = read();
		l = read();
		r = read();
		if ( op == 1 )
		{
			int k = 0, y = 0;
			while ( ( 1 << k ) <= r - l + 1 ) k++;
			if ( st[l][k-1] > st[r - ( 1 << ( k - 1 )) + 1][k-1] ) y = st[l][k-1];
			else y = st[r - ( 1 << ( k - 1 )) + 1][k-1];
			write ( y - s0[l-1] - s1[r+1] );
		}
		else 
		{
			if ( s[l] == s[r] ) write ( 1 );
			else write ( 2 );
		}
		putc('\n');
	}
	flush();
	return 0;
}
```
- 注意：本题卡常，要用快速读写，用 `cin`，`cout`，$\textup{Subtask 5}$,$\textup{Subtask 6}$ 会 TLE。

---

## 作者：Light_Star_RPmax_AFO (赞：1)

## 前言

[传送门](https://www.luogu.com.cn/problem/P7809)

[blog](https://www.luogu.com.cn/blog/JJL0610666/solution-p7809)

# 思路

## Problem 1

问题一问的是最长不下降子序列的长度，在一个 $01$ 串中的最长不下降子序列，总共有三种 $000\dots$，$000\dots111\dots$ 和 $111111\dots$。

可以把找到以上三种最长不下降子序列问题变为：

$$\max^r_{i =l}(\sum_{j = l}^i[a_j=0])+(\sum_{j = i + 1}^r[a_j=1])$$

可以看做以 $i$ 分界，$l$ 到 $i$ 为 $0$，$i + 1$ 到 $r$ 为 $1$。

那么我们又可以使用前缀和优化，设 $sumfront_y$ 为从 $1$ 到 $y$ 的 $0$ 的个数，$sumback_y$ 为从 $n$ 到 $y$ 的 $1$ 的个数，上式可以简化为：

$$\max^r_{i =l}sumfront_i-sumfront_{l-1}+sumback_i-sumback_{r + 1}$$

### 再次优化

上式中 $sumfront_{l-1}$ 与 $sumback_{r + 1}$ 已经固定，所以我们要求的就是 $\max^r_{i =l}sumfront_i+sumback_i$

算区间最大值的我们使用 **st 表**优化。

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;


inline int read(){
	int x = 0,f = 1;char ch = getchar();
	while (ch < '0' || ch > '9'){if(ch == '-') f = -1;ch = getchar();}
	while (ch >= '0' && ch <= '9'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,m;
bool a[1000010];
int sum[1000010],sum_front[1000010],sum_back[1000010];
int LOG2[1000010],st[1000010][21];

void init(){
    for(int i = 2;i <= n;++i)
        LOG2[i] = LOG2[i >> 1] + 1;
    for(int i = 1;i <= n;++i)
        st[i][0] = sum_front[i] + sum_back[i];
    int k = LOG2[n];
    for(int i = 1;i <= k;++i)
        for(int j = 1;j + (1 << i) - 1 <= n;++j)
            st[j][i] = max(st[j][i - 1],st[j + (1 << i - 1)][i - 1]);
}

int get(int l,int r){
    int s = LOG2[r - l + 1];
    return max(st[l][s],st[r - (1 << s) + 1][s]);
}

int main(){
    n = read(),m = read();
    for(int i = 1;i <= n;++i){
        a[i] = read();
        sum_front[i] = sum_front[i - 1] + (a[i] == 0);
        if(i > 1)sum[i] = sum[i - 1] + (a[i] == 1 && a[i - 1] == 0);
    }
    for(int i = n;i >= 1;--i)
        sum_back[i] = sum_back[i + 1] + (a[i] == 1);
    init();
    for(int i = 1;i <= m;++i){
        int problem,l,r;
        problem = read(),l = read(),r = read();
        if(problem == 1)
            printf("%d",get(l,r) - sum_front[l - 1] - sum_back[r + 1]);
        else 
            printf("%d",1 + !(sum[l] == sum[r]));
        puts("");
    }
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

简单题。

令 $s_{0/1,i}$ 表示前缀 $i$ 个数字中 $0/1$ 的个数，$pre_i$ 表示当 $a_i=1$ 时前一个为 $0$ 数的位置。

第一问求的是：

$$\sum_{i=l}^r (s_{0,i}-s_{0,l-1}) + (s_{1,r} - s_{1,i-1})$$

注意到 $(s_{1,r} - s_{0,l-1})$ 是一个定值，故我们只需要求 $(s_{0,i} - s_{1,i-1})$ 的最大值。

第二问求的是：

$$1 + [\max\limits_{i=1}^ r pre_i \ge l]$$

那么分别维护两个 ST 表即可。

时间复杂度为 $O(N \log N + M)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef long long ll;
typedef double db;
const int N=1e6+10,M=20;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
int n,m,x,op,l,r;
int a[N],s1[N],s2[N];
int F[2][N][M];
inline int query(int l,int r,bool f){
    int k=log2(r-l+1);
    return max(F[f][l][k],F[f][r-(1<<k)+1][k]);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		if(a[i]){
			s2[i]++;
			F[0][i][0]=x;
		}
		else{
			s1[i]++;
			x=i;
		}
		s1[i]+=s1[i-1];
		s2[i]+=s2[i-1];
		F[1][i][0]=s1[i]-s2[i-1];
	}
	for(int f=0;f<2;f++)
	  for(int k=1;(1<<k)<=n;k++)
	    for(int i=1;i+(1<< k)-1<=n;i++)
	      F[f][i][k]=max(F[f][i][k-1],F[f][i+(1<<(k-1))][k-1]);
	for(int i=1;i<=m;i++){
		op=read(),l=read(),r=read();
		if(op==1)
		  write(s2[r]-s1[l-1]+query(l,r,1));
		else
		  write(1+(query(l,r,0)>=l));
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：xpsroc (赞：0)

#  _Solution_ 
###   本题要静态维护两个量——即最长不下降子序列长度和最长上升子序列长度
### 一、最长不下降子序列
一眼 $st$ 表。首先用前缀和的思想转换变量。由于本题序列只有 $0$ 和 $1$ 两个取值，因此求最长不下降子序列就是要在区间中找一个“断点”，断点及以前的都取 $0$ ，断点之后的都取 $1$ 。因此我们用 $st$ 表维护一个点及以前 $0$ 的个数与 $1$ 的个数之差。
### 二、最长上升子序列
依然由于本题序列只有 $0$ 和 $1$ 两个取值这个特殊性质，最长
上升子序列只能为 $1$ 或 $2$ 。考虑在读入时就建立一个标记数组把 $0$ 和 $1$ 交替（**注意是 $0$ 和 $1$ 交替，不能是 $1$ 和 $0$ 交替，因为本题求的是最长上升子序列**）的位置标记上。然后再将这个标记数组前缀和处理。在询问时只需要判断当前序列中有没有 $01$ 交替位置，用前缀和作差即可（**此时需要注意 $01$ 交替位置不能在询问区间的右端点**）。
# Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
inline int read(){
	int n=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		n=n*10+c-'0';
		c=getchar();
	}
	return n*f;
}
int a[1000100];
bool vis[1000100];
int sum[1000100];
int gs[10001000][3];
int nd[1000100][20];
int n,m;
int main(){
	n=read();m=read();
	a[0]=2;sum[0]=0;
	for(int i=1; i<=n; i++){
		a[i]=read();
		if(a[i]==1)gs[i][1]=gs[i-1][1]+1,gs[i][0]=gs[i-1][0];
		else gs[i][0]=gs[i-1][0]+1,gs[i][1]=gs[i-1][1];
		nd[i][0]=gs[i][0]-gs[i][1]; 
		if(a[i]==1&&a[i-1]==0)vis[i-1]=1;
		else vis[i-1]=0;
		if(i>1)sum[i-1]=sum[i-2]+vis[i-1];
	}
	sum[n]=sum[n-1];
	int h=log(n)/log(2)+1;
	for(int i=1; i<=h; i++){
		for(int j=1; j+(1<<i)-1<=n; j++){
			nd[j][i]=max(nd[j][i-1],nd[j+(1<<(i-1))][i-1]);
		}
	}
	for(int i=1; i<=m; i++){
		int opt;opt=read();
		int lk;lk=read();int rk;rk=read();
		if(opt==2){
			int opq=sum[rk-1]-sum[lk-1];
			if(opq==0)printf("%d\n",1);
			else printf("%d\n",2);
		}
		else{
			int kxl=log(rk-lk+1)/log(2); 
			int uv=max(0,rk-(1<<kxl)+1);
			int kzy=max(nd[lk][kxl],nd[uv][kxl])+gs[rk][1]-gs[lk-1][0];
			kzy=max(kzy,gs[rk][1]-gs[lk-1][1]);
			printf("%d\n",kzy);
		}
	}
}
```


---

## 作者：Scorilon (赞：0)

对于第二种操作，很容易想到只有 $1$ 或 $2$ 两种答案，若该区间内存在 $01$ 这个子序列，那么答案为 $2$ 反之为 $1$.可以通过对该 $01$ 串做一个前缀和，若出现 $01$ 这个子序列就累加，最后判断左右端点是否相等即可，时间复杂度 $O(n)$.

对于第一种操作，$\text{Subtest 1}$ 很明显答案为 $r-l+1$.

然后考虑正解，很明显该最长不下降子序列形如 $0,0,0,\dots,1,1,1$，即由若干个连续的 $0$ 和若干个连续的 $1$ 构成，基于这一点，我们可以做一个前缀和，统计到 $i$ 时 $[1,i]$ 中 $0$ 和 $1$ 的数量，那么答案就是 $\max^r_{i=l} sum_{i,0}-sum_{l-1,0}+sum_{r,1}-sum_{i-1,1}$，而 $sum_{r,1}-sum_{l-1,0}$ 很明显是定值，那么只需要求最大的 $sum_{i,0}-sum_{i-1,1}$ 即可，可用 ST 表维护，时间复杂度为 $O(n\log n)$.

因此总时间复杂度为 $O(n \log n+m)$，足以通过本题。

```cpp
#include <cstdio>
#include <iostream>
//#include<bits/stdc++.h>

using namespace std;

namespace IO{//by cyffff
	int len=0;
	char ibuf[(1<<20)+1],*iS,*iT,out[(1<<26)+1];
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#define reg register
	inline int read(){
		reg char ch=gh();
		reg int x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
	inline void putc(char ch){
		out[len++]=ch;
	}
	template<class T>
	inline void write(T x){
		if(x<0)putc('-'),x=-x;
		if(x>9)write(x/10);
		out[len++]=x%10+48;
	}
	inline void flush(){
		fwrite(out,1,len,stdout);
		len=0;
	}
}
using IO::read;
using IO::write;
using IO::flush;
using IO::putc;

const int N=1e6;
const int M=5e6;
const int Log=20;

int n,m;
int sum[N+5][2];
int sum2[N+5];
int f[N+5][Log];
int log[N+5];

void init() {
	log[0]=log[1]=0;
	for(int i=2;i<=n;i++) log[i]=log[i>>1]+1;
}

int query(int l,int r) {
	int s=log[r-l+1];
	return max(f[l][s],f[r-(1<<s)+1][s]);
}

int main() {
	n=read();m=read();
	init();
	int lst=-1,a;
	for(int i=1;i<=n;i++) {
		a=read();
		sum[i][0]=sum[i-1][0];
		sum[i][1]=sum[i-1][1];
		sum[i][a]++;
		sum2[i]=sum2[i-1]+(lst==0&&a==1);
		lst=a;
	}
	for(int i=1;i<=n;i++) f[i][0]=sum[i][0]-sum[i-1][1];
	for(int j=1;j<=Log;j++) {
		for(int i=1;i+(1<<j)-1<=n;i++) {
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
	int op,l,r;
	while(m--) {
		op=read();l=read();r=read();
		int ans=0;
		if(op==1) {
			ans=max(1,sum[r][1]-sum[l-1][0]+query(l,r));
			write(ans);putc('\n');
		} else {
			int x;
			if(sum2[l]==sum2[r]) x=1;
			else x=2;
			write(x);putc('\n');
		}
	}
	flush();
	return 0;
}
```

---


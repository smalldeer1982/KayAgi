# [蓝桥杯 2022 省 A] 选数异或

## 题目描述

给定一个长度为 $n$ 的数列 $A_{1}, A_{2}, \cdots, A_{n}$ 和一个非负整数 $x$, 给定 $m$ 次查询, 每次询问能否从某个区间 $[l, r]$ 中选择两个数使得他们的异或等于 $x$ 。


## 说明/提示

**【样例说明】**

显然整个数列中只有 2,3 的异或为 1 。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $1 \leq n, m \leq 100$;

对于 $40 \%$ 的评测用例, $1 \leq n, m \leq 1000$;

对于所有评测用例, $1 \leq n, m \leq 10^5,0 \leq x<2^{20}, 1 \leq l_{i} \leq r_{i} \leq n$ ， $0 \leq A_{i}<2^{20}$ 。

蓝桥杯 2022 省赛 A 组 D 题。

## 样例 #1

### 输入

```
4 4 1
1 2 3 4
1 4
1 2
2 3
3 3```

### 输出

```
yes
no
yes
no```

# 题解

## 作者：Aurora_Borealis_ (赞：70)

首先根据异或性质可得出：

 $$a \oplus b = x \Leftrightarrow a \oplus x = b$$
 
也就是说，对于已经给出的 $a$ 数组，可以求出每一个 $a_i$ 对应的异或值。

这是考虑设 $f_i$ 表示当i为右端点时，$[1,i]$ 中所有的合法异或值对中最大的左端点。当询问区间 $[l,r]$ 时，只需检验 $f_r$ 是否在区间内即可。

复杂度 $O(n+m)$。

## upd 2023.1.21：

#### @ lyc1001 问题：

> 把 ```lst[a[i]]=i``` 放到 ```f[i]=max(f[i-1],lst[a[i]^x]);``` 上面去，否则就有 hack 如下：```1 1 0 1 1 1```，应输出 yes 实际输出 no，原因是忽略了可以自己跟自己组


#### 回应：

题面中有原文：

> 选择**两个数**使得他们的异或等于 $x$。

在下默认不能重复取。

代码：


```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
#define ll long long
#define pb push_back
#define pii pair<int,int>
#define vi vector<int>
#define imp map<int,int>
using namespace std;
const int N =100005;
int n,m,x; 
int a[N],f[N];
imp lst;
int main(){
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i]=max(f[i-1],lst[a[i]^x]);
		lst[a[i]]=i;
	}
	for(int i=1;i<=m;i++){
		int l,r;
		cin>>l>>r;
		if(f[r]<l){
			cout<<"no"<<endl;
		}else{
			cout<<"yes"<<endl;
		}
	}
	return 0;
}
```


---

## 作者：liangbowen (赞：51)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P8773)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17032762.html)

一道有趣的题目。

## 思路

对于一个数 $a_i$，如果有 $a_i \oplus t = x$，显然 $t = a_i \oplus x$。

设 $loc_i$ 表示上一个 $t$ 出现的位置。这个是很容易维护的。

那么对于一组询问 $[l, r]$，如果存在，必然是有一个 $l \le i \le r$ 满足 $loc_i \ge l$。

换种说法，$[l, r]$ 存在，当且仅当 $\max\limits_{l \le i \le r} loc_i \ge l$。

这玩意显然可以用线段树维护。然后就做完了。

但是也是可以用 ST 的，并且更优，~~但是我肯定不会再打一份代码啊~~。

## 代码

这个是模拟赛时候的代码。因为赛时降智就写了线段树，每组询问一只 $\log$。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n, q, x, loc[1919810];
namespace SegmentTree {
	int mx[400005];
	#define ls pos << 1
	#define rs pos << 1 | 1
	void build(int l, int r, int pos)
	{
		if (l == r)
		{
			int a;
			scanf("%d", &a);
			loc[a] = l, mx[pos] = loc[a ^ x];			
			return;
		}
		int mid = (l + r) >> 1;
		build(l, mid, ls), build(mid + 1, r, rs);
		mx[pos] = max(mx[ls], mx[rs]);
	}
	int query(int l, int r, int pos, int L, int R)
	{
		if (L <= l && r <= R) return mx[pos];
		int mid = (l + r) >> 1, ans = 0;
		if (L <= mid) ans = max(ans, query(l, mid, ls, L, R));
		if (mid < R) ans = max(ans, query(mid + 1, r, rs, L, R));
		return ans;
	}
}; using namespace SegmentTree;

int main()
{
	scanf("%d%d%d", &n, &q, &x);
	build(1, n, 1);
	while (q--)
	{
		int l, r;
		scanf("%d%d", &l, &r);
		if (query(1, n, 1, l, r) >= l) puts("yes"); else puts("no");
	}
	return 0;
}
```

希望能帮助到大家！

---

## 作者：Surge_of_Force (赞：30)

注意到 $x$ 是提前给出的，所以可以考虑预处理

对于每一个 $i$ 我们预处理一个 $ans_i$ 代表 $i$ 前面的最后一个与 $A_i$ 的异或等于 $x$ 的数的下标，这个可以开个桶，边扫边统计。

预处理出这个后，不难发现对于区间 $[l,r]$，有解的充要条件是存在至少一个 $i\in[l,r]$ 使得 $ans_i\ge l$，所以只需要对 $ans_l$ 到 $ans_r$ 取个最大值与 $l$ 比较就行了，这个可以线段树 $O(n)-(m\log n)$ 或者 ST 表 $O(n\log n)-O(m)$ 解决，这里用的是 ST 表。

```cpp
int n,m,x,t[(1ll<<20)+1],ans[MAX],lg[MAX],st[MAX][20];
int ask(int l,int r){
	int len=lg[r-l+1];
	return max(st[l][len],st[r-(1ll<<len)+1][len]);
}
signed main(){
	n=read(),m=read(),x=read();
	for(int i=1;i<=n;i++){
		int xx=read();
		ans[i]=t[xx^x];
		t[xx]=i;
	}
	for(int i=1;i<=n;i++) st[i][0]=ans[i];
	lg[0]=-1;
	for(int i=1;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(int i=1;i<=20;i++)
		for(int j=1;j+(1ll<<i)-1<=n;j++)
			st[j][i]=max(st[j][i-1],st[j+(1ll<<(i-1))][i-1]);
	while(m--){
		int l=read(),r=read();
		if(ask(l,r)>=l) puts("yes");
		else puts("no"); 
	}
	return 0;
}
```

---

## 作者：Zaku (赞：23)

异或有一个性质：
$$a\oplus b=x\Leftrightarrow b=x\oplus a$$
也就是说，只要我们确定了 $a$ ，那么 $b$ 的数值也就自然确定了。
我们对区间进行查询，枚举区间内的每一个数 $a$,只需要确定 $a\oplus x$ 存在，那么就直接输出 ```yes``` 即可。
### 解法（DP):
注意到我们是对一个区间 $[L,R]$ 进行询问，那么我们的 $f$ 数组就可以用类似前缀和的思想，将 $f_i$ 定义的范围设定为 $[1,R]$。

如果 $a\oplus b=x$,那么我们称 $a$ 和 $b$  是一对满足条件的数对，并且较小的那个称为该数对的下界。

那么，$f_i$ 所表示的集合为：所有 $[1,i]$ 范围内满足条件的数对的下界的下标，属性为所有下标当中的最大值。

因此当我们查询区间 $[L,R]$ 时，只需要判断**区间左端点 $L$ 是否在最大下界的左边**即可，因为这可以保证在区间内**至少**存在一个数对是满足条件的。

在实现上，我们定义一个哈希表来存储每个数所对应的下标，考虑当前遍历到的元素为 $a_i$ ，与其对应的数为 $a_i\oplus x$。

如果 $a_i\oplus x$ 在前面出现过，那么我们需要取它的下标与前 $i-1$ 个数中满足集合条件的下标之间的较大值，即
$$f_i=\max(f_{i-1},Hash_{a_i\oplus x})$$

这样时间复杂度大约为 $\Theta(m+n)$。~~很快啊~~
#### 贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],f[100005];
map<int,int> Hash;//记录每一个a[i]^x的最近的位置
int main(){
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	f[i]=max(f[i-1],Hash[a[i]^x]);
    	Hash[a[i]]=i;//哈希一下~
    }
    while(m--){
        int l,r;
        cin>>l>>r;
        if(f[r]>=l)cout<<"yes\n";//左端点在最大下界的左边
        else cout<<"no\n";
    }
    return 0;
}
```

---

## 作者：Sternenlicht (赞：9)

思路：

因 $x$ 已给定，所以可以想到预处理。

用一个桶来统计，$ansp_i$ 记录 $i$ 前的数与 $A_i$ 的异或值等于 $x$ 的下标。

由于是区间问题，容易想到用 ST 表解决。在 $[l,r]$ 中，若有 $ansp_i \ge l$，则有解。所以在 $ansp_l$ 到 $ansp_r$ 之间，取最大值，与 $l$ 相比即可。

```cpp
#include <bits/stdc++.h>
namespace IO{
	#define LL long long
	inline LL read(){
		LL x=0,f=1;char c=getchar();
		for (;!isdigit(c);c=getchar())if (c=='-')f=-1;
		for (;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
		return x*f;
	}
	inline void write(LL x,char c='\n'){
		if (x){
			if (x<0)x=-x,putchar('-');
			char a[30];short l;
			for (l=0;x;x/=10)a[l++]=x%10^48;
			for (l--;l>=0;l--)putchar(a[l]);
		}else putchar('0');putchar(c);
	}
}using namespace IO;
using namespace std;

const int N = 1e5+10;
const int LogN = 2e1;
int tong[1<<LogN],ansp[N],lg[N],f[N][LogN],n,m,x;
int query(int l,int r)//查询区间值 
{return max(f[l][lg[r-l+1]],f[r-(1<<lg[r-l+1])+1][lg[r-l+1]]);}
int main(){
	n=read(),m=read(),x=read();lg[0]=-1;
	//读入，用tong数组记录标号
	//ansp数组记录 i前的最后一个数与a的异或值等于x 的数的下标 
	for (int i=1,a;i<=n;i++)a=read(),ansp[i]=tong[a^x],tong[a]=i;
	//将ST表数组初始化，log数组初始化 
	for (int i=1;i<=n;i++)f[i][0]=ansp[i],lg[i]=lg[i>>1]+1;
	for (int j=1;j<=LogN;j++)//ST表维护区间最大值 
		for (int i=1;i+(1<<j)-1<=n;i++)
			f[i][j]=max(f[i][j-1],f[i+(1<<j-1)][j-1]);
	for (int i=1,l,r;i<=m;i++){
		l=read(),r=read();
		if (query(l,r)>=l)
			puts("yes");
		else
			puts("no");
	}
	return 0;
}
```

Update：感谢 @fervency 指正错误。

---

## 作者：xueruo (赞：6)

[题目](https://www.luogu.com.cn/problem/P8773)大意应该很清楚了，这里介绍一下**异或**。  
 $1 \oplus 1 = 0$  
 $1 \oplus 0 = 1$  
 $0 \oplus 1 = 1$  
 $0 \oplus 0 = 0$  
这是异或计算的四条规则，在多位二进制下异或就要把每一位都进行异或。  
另外还有一个结论:  
如果 $a \oplus b=x$  
那么 $a \oplus x=b$    
这个结论是解决这道题的关键。  

起决定因素的是子集，越小的子集决定度越精准。问题就可以转换为，求以一个数为右端口时最大的区间左端口。  

这里很容易想到动态规划，不然会重复很多无用计算，因为数据很大。(~~当然你也可以使用 $\text{ST}$ 表~~)  

那么把每一个数的最大左端口算出来，用 $dp[r]$ 数组来存它**最大的左端口**。首先让每一个数与 $x$ 异或一下，就找到了符合条件的数字，而且需要存那个更小子集的左端口。  

那么就能得到状态转移方程:求 $a \oplus x$ 得到数 $b$。$dp[i]= \max (dp[i-1],mp[data \oplus x]);$  
其中 $mp[b]$ 就是数 $b$ 的序号。

最后说一下，因为数据过于庞大，用数组是过不了的。我这里用了 $\text{STL}$ 的 $\text{map}$。  

## code:  
```cpp
#include<iostream>
#include<map>
#include<algorithm>
#define int unsigned long long
using namespace std;
const int N=1e6+10;
int n,m,x,dp[N];//a^b=x  a,b中早出现的数字位置
map<int,int>mp;
signed main() {
	ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>x;
	for(int i=1; i<=n; i++) {
		int data;
		cin>>data;
		dp[i]=max(dp[i-1],mp[data^x]);//mp存放另一个数的位置
		mp[data]=i;
	}
	while(m--) {
		int l,r;
		cin>>l>>r;
		if(dp[r]>=l) cout<<"yes\n";
		else cout<<"no\n";
	}
	return 0;
}
```

---

## 作者：caiwen (赞：4)

竟然没有题解，那么本蒟蒻就随手写一个......  
首先有一个很常见的结论： 如果 $a \otimes b=x$ 那么 $a \otimes x=b$ 。  
根据这个结论，我们可以对 $A$ 数列中每一项异或上一个数 $x$ 得到 $B$ 数列。即： `b[i]=a[i]^x;` 。  
然后题意就转化为：给定一个区间 $[l,r]$ ，问数组 $a$ 和数组 $b$ 在这个区间内是否有相同的数。  
这个问题看起来很简单，应该有非常简单又巧妙的解法。但是本蒟蒻一眼就想拿莫队来做，是目前的最**劣**解。  

先离散化，再开两个桶，每次移动指针的时候判断是否影响答案。  

时间复杂度：$O(n \log n+n\sqrt{n})$ （不知道对不对）。

代码：  
```cpp
#include<iostream>
#include<algorithm>
#include<cmath> 
#define int long long
#define _ 100005
using namespace std;

int blo,bl[_],a[_],b[_],uni[_<<1],tot,n,m,x;
struct Query{int l,r,id,ans;} q[_];

//注意开两倍数组 
int l=1,r,ans,bu1[_<<1],bu2[_<<1];
inline void add(int x){
	bool st=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));
	bu1[a[x]]++;
	bu2[b[x]]++;
	bool ed=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));
	if(!st&&ed) ans++;//判断是否对答案产生影响 
}
inline void del(int x){
	bool st=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));
	bu1[a[x]]--;
	bu2[b[x]]--;
	bool ed=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));
	if(st&&!ed) ans--;
}

signed main(){
	ios::sync_with_stdio(false);
	//读入数据 
	cin>>n>>m>>x;
	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i]^x,uni[++tot]=a[i],uni[++tot]=b[i];
	for(int i=1;i<=m;i++) cin>>q[i].l>>q[i].r,q[i].id=i;
	//离散化 
	sort(uni+1,uni+tot+1);
	tot=unique(uni+1,uni+tot+1)-uni-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(uni+1,uni+tot+1,a[i])-uni,b[i]=lower_bound(uni+1,uni+tot+1,b[i])-uni;
	//分块 
	blo=sqrt(n);
	for(int i=1;i<=n;i++) bl[i]=(i-1)/blo+1;
	sort(q+1,q+m+1,[](Query qa,Query qb){return bl[qa.l]==bl[qb.l]? qa.r<qb.r:qa.l<qb.l;});
	//处理询问 
	for(int i=1;i<=m;i++){
		while(l<q[i].l) del(l++);
		while(l>q[i].l) add(--l);
		while(r<q[i].r) add(++r);
		while(r>q[i].r) del(r--);
		q[i].ans=ans;
	}
	//输出答案 
	sort(q+1,q+m+1,[](Query qa,Query qb){return qa.id<qb.id;});
	for(int i=1;i<=m;i++) cout<<(q[i].ans? "yes":"no")<<endl;
	return 0;
}
```


---

## 作者：lfxxx (赞：3)

首先，看到 `1e5` 的数据范围和允许离线，我们首选的是一个方便快捷的数据结构——莫队。

不会莫队出门左转模板区。

那么我们考虑，假设加入了一个数，$v$，那么根据异或的性质，$(v\land x) \land v = x$ 所以，它的贡献是 $v \land x$ 个异或为 $x$ 的数对，删除的时候减去这些贡献即可。

那么我们就能求出区间内异或为 $x$ 的数对数量，自然能判断这样的数对是否存在。

另外，由于本题值域较大我们有两种方案。

1. 将每个数以及其异或 $x$ 的结果离散化。

2. 哈希。

这里我选用的是哈希法，请务必手写哈希，STL 的哈希我已经试过毒了，会 TLE 。

那么总复杂度就是 $O(q \sqrt n)$ 。

然后就是喜闻乐见的代码时间了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
struct q{
	int id;
	int l;
	int r;
	int anser;
}y[100001]; 
int a[100001];
int t[20000001];
int sq;
inline int Hash(int x){
	return x%1145141;
}
bool cmp(q a, q b)
{
    return (a.l/sq)==(b.l/sq) ? a.r<b.r : a.l<b.l;
}
bool cmp1(q a,q b)
{
	return a.id<b.id;
}
int k;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>m>>k;
	sq=sqrt(n);
	for(int i=1;i<=n;i++)
	cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		cin>>y[i].l>>y[i].r;
		y[i].id=i;
	}
	sort(y+1,y+m+1,cmp);
	int L=1;
	int R=0;
	int ans=0;
	for(int i=1;i<=m;i++)
	{
	//	cout<<ans<<endl;
		while(L<y[i].l)
		{
			t[Hash(a[L])]--;
			ans-=t[Hash(k^a[L])];
			L++;
		}
		while(L>y[i].l)
		{
			L--;
			ans+=t[Hash(k^a[L])];
			t[Hash(a[L])]++;
			
		}
		while(R>y[i].r)
		{
		t[Hash(a[R])]--;
		ans-=t[Hash(k^a[R])];
		R--;
		}
		while(R<y[i].r)
		{
			R++;
			ans+=t[Hash(k^a[R])];
			t[Hash(a[R])]++;
			
		}
	 	y[i].anser=ans;
	}
	sort(y+1,y+m+1,cmp1);
	for(int i=1;i<=m;i++)
	cout<<(y[i].anser==0 ? "no" : "yes")<<endl;
}
```


---

## 作者：0xFF (赞：2)

#### 题目大意


------------
给定长度为 $n$ 的序列，$m$ 次询问 $[l_i,r_i]$ 内有无两数异或和为 $x$。

#### 思路分析


------------
$$a \oplus b=x \Rightarrow a \oplus b \oplus x=x\oplus x= 0$$

令 $c = a\oplus x$

$$\Leftrightarrow c \oplus  b=0$$

$$\Leftrightarrow c\oplus(c\oplus b)=0\oplus c\Rightarrow b=c$$

综上，可以由 $a\oplus b=x\Rightarrow a\oplus x = b$

原题就转化成了给定一个区间 $[l_i,r_i]$ 对于 $a$ 有无 $a\oplus x$ 与之对应。

考虑莫队求解即可。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#include<deque>
#include<queue>
#include<map>
#include<vector>
#define int long long//
using namespace std;
const int INF = 2e15;
const int mod = 1e9 + 7;
const int N = 1e5 + 10;
const int M = (1<<20) + 10;

inline int read(){
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
struct Node{
	int id,l,r;
}q[N<<1];
int a[N],cnt[M],ans[N],belong[N];
bool cmp(Node x,Node y){
	if(belong[x.l] == belong[y.l]) return x.r < y.r;
	else return belong[x.l] < belong[y.l];
}
int n,m,x,res = 0;
void Add(int t){
	if(a[t] > M) return;
	cnt[a[t]]++;
	res += cnt[a[t] ^ x];
}
void Del(int t){
	if(a[t] > M) return;
	cnt[a[t]]--;
	res -= cnt[a[t] ^ x];
}
signed main(){
	n = read() , m = read() , x = read();
	int siz = sqrt(n);
	for(int i=1;i<=n;i++) a[i] = read() , belong[i] = i / siz;
	for(int i=1;i<=m;i++){
		q[i].l = read() , q[i].r = read() , q[i].id = i;
	}
	sort(q+1,q+m+1,cmp);
	int L = 1 , R = 0;
	for(int i=1;i<=m;i++){
		while(L > q[i].l) Add(--L);
		while(L < q[i].l) Del(L++);
		while(R < q[i].r) Add(++R);
		while(R > q[i].r) Del(R--);
		ans[q[i].id] = res;
	}
	for(int i=1;i<=m;i++){
		if(ans[i] > 0) cout<<"yes\n";
		else cout<<"no\n";
	}
	return 0;
}
```


---

## 作者：Asimplename (赞：1)

此题可以预处理出每个数前面是否有和它异或值等于 $x$ 的值并记录位置，根据异或的性质可以直接开一个桶记录前面是否有 $A_i$ 异或 $x$ 和它的位置即可。然后就可以求出区间的最大值，查看它是否在这个区间里就行了。

```cpp
#include<iostream>
using namespace std;
int n,m,x;
int a[100010];
int tong[1048586];
int corr[100010];
int tree[400010];
void Pushup(int node){
	tree[node] = max(tree[node << 1] , tree[node << 1 | 1]);
}
void init(){
	for(int i = 1; i <= n; i ++){
		if(tong[a[i] ^ x] != 0){
			corr[i] = tong[a[i] ^ x];
		}
		tong[a[i]] = i;
	}
}
void Build(int l, int r, int node){
	if(l == r){
		tree[node] = corr[l];
		return;
	}
	int mid = (l + r) / 2;
	Build(l, mid, node << 1);
	Build(mid + 1, r, node << 1 | 1);
	Pushup(node);
}
int Query(int ml, int mr, int l, int r, int node){
	if(ml <= l && r <= mr){
		return tree[node];
	}
	int mid = (l + r) / 2;
	int res = 0;
	if(ml <= mid){
		res = max(res, Query(ml, mr, l, mid, node << 1));
	}
	if(mr > mid){
		res = max(res, Query(ml, mr, mid + 1, r, node << 1 | 1));
	}
	return res;
}
int main (){
	cin >> n >> m >> x;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
	}
	init();
	Build(1, n, 1);
	int lb, rb;
	while(m --){
		cin >> lb >> rb;
		int dis = Query(lb, rb, 1, n, 1);
		if(dis >= lb && dis <= rb){
			cout << "yes" << endl;
		}
		else{
			cout << "no" << endl;
		}
	}
	return 0;
}
```

---


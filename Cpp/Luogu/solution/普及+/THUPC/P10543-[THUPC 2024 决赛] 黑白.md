# [THUPC 2024 决赛] 黑白

## 题目描述

小 I 和小 J 又在玩游戏。

游戏在一个 $n \times m$ 的网格上进行，我们用二元组 $(x,y)$ 描述第 $x$ 行第 $y$ 列的格子，其中 $1 \le x \le n, 1 \le y \le m$。初始时，网格上有至少一个格子是白色的，其他格子是黑色的。

小 I 和小 J 轮流操作，小 I 先手。每次操作时，操作方必须选择恰好一个白色的格子并将其染黑。

称两个格子相邻当且仅当它们共用一条边。若某次操作后，格子 $(1,1)$ 不是白的，或者格子 $(n,m)$ 不是白的，或者无法从 $(1,1)$ 出发，每次经过相邻的白色格子，最终到达 $(n,m)$（即 $(1,1)$ 和 $(n,m)$ 不在同一个白色格子构成的四连通块内），则当前操作方输，另一方胜利。

你作为游戏的观众，想知道在小 I 和小 J 绝顶聪明的情况下，谁会获胜。

## 说明/提示


对于第一组测试数据，小 I 只能染黑 $(2,1)$，但染黑 $(2,1)$ 会导致无法仅通过每次移动到相邻的白色格子从 $(1,1)$ 移动到 $(2,2)$，因此无论小 I 如何操作都将失败，故输出 `J`。

对于第二组测试数据，小 I 可以染黑 $(1,2)$，然后无论小 J 如何操作都将失败，故输出 `I`。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>

## 样例 #1

### 输入

```
2
2 2
WB
WW
2 2
WW
WW
```

### 输出

```
J
I
```

# 题解

## 作者：Genius_Star (赞：8)

### 思路：

若 $(1,1)$ 初始就无法到达 $(n,m)$，则先手必败。

否则，令白色的个数为 $sum$；到最后一个人无法操作时，肯定是仅存在一条白色路径，注意有这样一个性质：

- 任意一条从 $(1,1)$ 到达 $(n,m)$ 的路径长度，都与 $n+m-1$ 模 $2$ 意义下同余。

可以用染色法证明，这里不再阐述。

那么我们判断 $sum-n-m$ 的奇偶性即可。

时间复杂度为 $O(\sum NM)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef double db;
typedef long long ll;
const ll N=1010;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
inline char get(){
	char c;
	while(1){
		c=getchar();
		if(c=='W'||c=='B')
		  break;
	}
	return c;
}
ll T,n,m,s;
bool f[N][N],dis[N][N],F[N][N];
ll dx[]={0,0,1,-1},dy[]={1,-1,0,0};
void bfs(ll sx,ll sy){
	queue<pair<ll,ll>> Q;
	Q.push({sx,sy});
	dis[sx][sy]=1;
	while(!Q.empty()){
		ll x=Q.front().first,y=Q.front().second;
		Q.pop();
		if(F[x][y])
		  continue;
		F[x][y]=1;
		for(int i=0;i<4;i++){
			ll zx=x+dx[i],zy=y+dy[i];
			if(zx<1||zx>n||zy<1||zy>m)
			  continue;
			if(f[zx][zy])
			  continue;
			if(dis[zx][zy])
			  continue;
			dis[zx][zy]=1;
			Q.push({zx,zy});
		}
	}
}
void solve(){
	s=0;
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(get()=='W'){
				f[i][j]=0;
				s++;
			}
			else
			  f[i][j]=1;
			dis[i][j]=F[i][j]=0;
		}
	}
	if(f[1][1]||f[n][m]){
		puts("J");
		return ;
	}
	bfs(1,1);
	if(!dis[n][m]){
		puts("J");
		return ;
	}
	if((s-n-m)&1ll)
	  puts("J");
	else
	  puts("I");
}
int main(){
	T=read();
	while(T--)
	  solve();
	return 0;
}

```

---

## 作者：ChampionCyan (赞：6)

# P10543题解

首先判定是否有路径从 $(1,1)$ 到 $(n,m)$，若没有，后手必胜。

否则计算有几个选择后仍有路径的点（两个人一共还能选几个点），若数量为奇数则先手胜，否则后手胜。

随后我们发现最初可能有不止一条路径，他们可能长短不同！

没关系，请看：

$\square\blacksquare\square\blacksquare\square\blacksquare$  
$\blacksquare\square\blacksquare\square\blacksquare\square$  
$\square\blacksquare\square\blacksquare\square\blacksquare$  
$\blacksquare\square\blacksquare\square\blacksquare\square$  
$\square\blacksquare\square\blacksquare\square\blacksquare$  
$\blacksquare\square\blacksquare\square\blacksquare\square$  


可以通过染色法得出图中：

标记（或者说颜色）相同的两个点无论怎样“绕路”，最终距离一定为偶数。

标记（或者说颜色）不同的两个点无论怎样“绕路”，最终距离一定为奇数。

因此最终路径长度的奇偶性一定不会发生改变，为了方便，我们直接 BFS 求最短路长度的奇偶性就能得出答案。

code（马蜂自认为好看）：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1001;
const int inf = 0x3f3f3f3f;
const int dx[4] = {-1, 0, 1, 0};
const int dy[4] = {0, -1, 0, 1};

inline int read() {
	int ret = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-')
			f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		ret = (ret << 1) + (ret << 3) + ch - '0';
		ch = getchar();
	}
	return ret * f;
}

int n, m, dis[MAXN][MAXN];
char s[MAXN][MAXN];
bool vis[MAXN][MAXN];
queue<pair<int, int> > q;

inline bool bfs() {
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			dis[i][j] = inf, vis[i][j] = s[i][j] == 'B';
	if (vis[1][1])
		return false;
	dis[1][1] = 1, q.push(make_pair(1, 1));
	while (!q.empty()) {
		int x = q.front().first, y = q.front().second;
		q.pop();
		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i], ny = y + dy[i];
			if (nx < 1 || ny < 1 || nx > n || ny > m || vis[nx][ny])
				continue;
			q.push(make_pair(nx, ny)), dis[nx][ny] = dis[x][y] + 1, vis[nx][ny] = true;
		}
	}
	return dis[n][m] != inf;
}

int main() {
	int t = read();
	while (t--) {
		n = read(), m = read();
		int w = 0;
		for (int i = 1; i <= n; i++)
			scanf("%s", s[i] + 1);
		if (!bfs()) {
			puts("J");
			continue;
		}
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= m; j++)
				if (s[i][j] == 'W')
					w++;
		if ((w - dis[n][m]) & 1)
			puts("I");
		else
			puts("J");
	}
	return 0;
}
```

---

## 作者：WrongAnswer_90 (赞：6)

## [My Blogs](https://www.cnblogs.com/WrongAnswer90/p/18224705)

### [P10543 [THUPC2024] 黑白](https://www.luogu.com.cn/problem/P10543)

签到题。

首先要判联通性。判完之后，统计全局的白格子个数 $s$。

因为删到最后，一定会留下一条白色路径，然后路径的长度在 $\bmod\;2$ 意义下和 $n+m-1$ 同余。而我们只关心能操作次数的奇偶性，所以只需要判断 $s-n-m$ 的奇偶性即可。

```cpp
	int T,n,m,s;
	bitset<1010> v[1010],v2[1010];
	char c[1010];
	const int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
	void dfs(int x,int y)
	{
		v2[x][y]=1;
		for(int i=0;i<4;++i)
		{
			int xx=dx[i]+x,yy=dy[i]+y;
			if(xx>0&&yy>0&&xx<=n&&yy<=m&&v[xx][yy]&&!v2[xx][yy])
			dfs(xx,yy);
		}
	}
	inline void mian()
	{
		cin>>T;
		while(T--)
		{
			cin>>n>>m,s=0;
			for(int i=1;i<=n;++i)
			{
				v2[i].reset(),scanf("%s",c+1);
				for(int j=1;j<=m;++j)
				v[i][j]=c[j]=='W',s+=v[i][j];
			}
			dfs(1,1);
			if(!v2[n][m]){puts("J");continue;}
			if((s-n-m)&1)puts("J");
			else puts("I");
		}
	}
```

---

## 作者：封禁用户 (赞：5)

好题。

### 题意

$n\times m$ 的网格图初始每个格子有黑有白，两人轮流操作，每次选择一个白格染黑。操作后不能存在一条 $(1,1)$ 到 $(n,m)$ 的路径，否则本次操作者输，另一人赢。

### 思路

首先判断是否一上来就输了。

易发现到最后一定会操作到只剩一条道路，设路径长度为 $s$，那么 $s$ 的奇偶性一定和 $n+m-1$ 奇偶性一样，而我们只要知道 $s$ 的奇偶性就可求出答案。

### AC Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,s;
string c;
bitset <1010>v[1010],w[1010];
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};
void dfs(int x,int y){
	w[x][y]=1;
	for(int i=0;i<4;i++){
		int xa=dx[i]+x,ya=dy[i]+y;
		if(xa>0&&ya>0&&xa<=n&&ya<=m&&v[xa][ya]&&!w[xa][ya])dfs(xa,ya);
	}
}
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		s=0;
		for(int i=1;i<=n;i++){
			w[i].reset();
			cin>>c;
			for(int j=1;j<=m;j++)v[i][j]=c[j-1]=='W',s+=v[i][j];
		}
		dfs(1,1);
		if(!w[n][m]){cout<<"J\n";continue;}
		if((s-n-m)&1)cout<<"J";
		else cout<<"I";
		puts("");
	}
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：4)

# [ P10543 [THUPC 2024 决赛] 黑白](https://www.luogu.com.cn/problem/P10543) 题解

不错的 BFS 题目

## 思路：

首先，要先判断 $(1,1)$ 和 $(n,m)$ 是否联通，因为如果不连通的话，小 I 的第一步无论涂黑哪个， $(1,1)$ 和 $(n,m)$ 还是不连通，无法从 $(1,1)$ 走到 $(n,m)$ 。

其次，要得出一个结论：当 $(1,1)$ 和 $(n,m)$ 联通时，由于小 I 和小 J 都绝顶聪明，所以最后剩下的图一定是 $(1,1)$ 到 $(n,m)$ 的最短路。

那么两人为了让对手输，就必然会依次涂黑不在最短路径上的方格，直到所有不在最短路径上的方格都被涂完了，此时操作的那个人就不得不切断最短路径，这样 $(1,1)$ 和 $(n,m)$ 就又不再联通了，对手胜利。

说了这么多，实现到代码的就是判断出初始白格数量减去最短路长度的奇偶性，是奇数则小 J 获胜，是偶数则小 I 获胜。

那么最短路怎么求呢，本题就是用 BFS 来求最短路，从 $(1,1)$ 逐层扩展即可。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int x,y;
char m[8005][8005];//存图 
bool flag[8005][8005];//判重数组 
int sx=0;
int sy=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		int us=0;//初始白格数量 
	    for(int j=1;j<=x;j++){
		    for(int k=1;k<=y;k++){
			    cin>>m[j][k];
			    if(m[j][k]=='W') us++;
	    	}
	    }
	    for(int j=1;j<=sx;j++){
	    	for(int k=1;k<=sy;k++){
	    		flag[j][k]=false;
			}
		}//多测一定一定要清空 flag 判重数组 
		queue< pair<int,int> >q;//利用二元组存坐标 
		queue<int>tim;//最短路长度 
		q.push(make_pair(1,1));
		tim.push(0);
		int f=0;//判断是否联通 
		int da=0;//存下最短路长度 
		while(1){
			if(q.empty()==true){
				f=1;//不连通 
				break;
			}
			int mqx=q.front().first;
			int mqy=q.front().second;
			//访问二元组 
			int mqtime=tim.front();
			q.pop();
			tim.pop();
			if(flag[mqx][mqy]==true) continue;
			if(m[mqx][mqy]=='B') continue;
			if(mqx<=0||mqy<=0||mqx>x||mqy>y) continue;
			//边界条件 
			if(mqx==x&&mqy==y){
				da=mqtime;//找到最短路 
				break;
			}
			flag[mqx][mqy]=true;
			q.push(make_pair(mqx+1,mqy));
			tim.push(mqtime+1);
			q.push(make_pair(mqx,mqy+1));
			tim.push(mqtime+1);
			q.push(make_pair(mqx-1,mqy));
			tim.push(mqtime+1);
			q.push(make_pair(mqx,mqy-1));
			tim.push(mqtime+1);
			//向四个方向走，即逐层扩展
			sx=x;
			sy=y;
		}
		if(f==1) cout<<"J\n";//不连通则后手胜 
		else if((us-da)%2==1) cout<<"J\n";//奇数则后手胜 
		else cout<<"I\n";//偶数则先手胜 
	}
	return 0;
}

```
有 O2 跑了 192 ms

没 O2 跑了 762 ms

---

## 作者：tuget (赞：3)

好题，放前几年估计有蓝。

首先钦定最后剩下的连通路径长度为 $l$，白色格子个数为 $w$，那么这种情况下，因为只能选白色格子，并且不能选路径上的点，所以胜负和 $w-l$ 的奇偶性相关。

假设我们钦定的路径是最短路，那么其他路径必然是先走出最短路径，再走回来，其中一部分对应原最短路径上的点，另一部分增加的是走出最短路再走回来的，方向上刚好抵消，路径长度的增量为偶数，所以所有路径的长度一定是同奇或同偶的，所以钦定任意一条路径，对于 $w-l$ 的奇偶性不产生改变，故我们求出最短路径长度即可。

实现时注意要先判断初始局面不连通的状态。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1005
#define frp freopen
#define fio(in,out) frp(in,"r",stdin),frp(out,"w",stdout)
void bug(){cout<<endl;}
template<typename T,typename ... Ts>
void bug(T x,Ts ... y){cout<<x<<" ";bug(y...);}
int read()
{
	int res=0,f=1;char c;
	for(;(c=getchar())<'0'||c>'9';c=='-'?f=-f:0);
	while(c>='0'&&c<='9')res=(res<<3)+(res<<1)+c-'0',c=getchar();
	return res*f;
}
const int inf=0x3f3f3f3f,dx[]={-1,0,1,0},dy[]={0,-1,0,1};
#define px first
#define py second
int n,m,dis[maxn][maxn];
char s[maxn][maxn];
bool vis[maxn][maxn];
queue<pair<int,int> >q;
inline bool bfs()
{
	int i,j,x,y,nx,ny;
	for(i=1;i<=n;++i)for(j=1;j<=m;++j)dis[i][j]=inf,vis[i][j]=s[i][j]=='B';
	if(vis[1][1])return 0;
	dis[1][1]=1,q.push({1,1});
	while(q.size())
	{
		x=q.front().px,y=q.front().py,q.pop();
		for(i=0;i<4;++i)
		{
			nx=x+dx[i],ny=y+dy[i];
			if(nx<1||ny<1||nx>n||ny>m||vis[nx][ny])continue;
			q.push({nx,ny}),dis[nx][ny]=dis[x][y]+1,vis[nx][ny]=1;
		}
	}
	return dis[n][m]!=inf;
}
int main()
{
	int i,j,t,w;t=read();
	while(t--)
	{
		n=read(),m=read();
		w=0;
		for(i=1;i<=n;++i)scanf("%s",s[i]+1);
		if(!bfs()){puts("J");continue;}
		for(i=1;i<=n;++i)for(j=1;j<=m;++j)if(s[i][j]=='W')++w;
		if((w-dis[n][m])&1)puts("I");
		else puts("J");
	}
	
	return 0;
}
```

---

## 作者：Accepetd (赞：2)

## P10543 [THUPC 2024 决赛] 黑白 题解

这是一道好玩的 BFS 题目。

### 大致思路：

~在小 I 和小 J 绝顶聪明的情况下。~

就是判断出初始白格数量减去最短路长度的奇偶性，是**奇数则后手获胜**，是**偶数则先手获胜**。

那么最短路怎么求呢？？本题就是**用 BFS 来求最短路，从** $(1,1)$ **逐层扩展即可**。

---

### 代码：

```cpp
#include<bits/stdc++.h>
#define ad(k) (k=-~k)
#define F(i,a,b) for(register int i=a;i<=b;i=-~i)
using namespace std;const int N=8002;
int n,x,y,ax,ay;char m[N][N];bool f[N][N];
main(){
	cin>>n;
	F(i,1,n){
		cin>>x>>y;
		int us=0;//初始白格数量 
	    F(j,1,x){F(k,1,y){cin>>m[j][k];if(m[j][k]=='W')ad(us);}}
	    F(j,1,ax)F(k,1,ay)f[j][k]=0;
		//要清空f!!!!!!!!!!!!!!!!!!!
		queue< pair<int,int> >q;/*存坐标*/queue<int>zz;//最短路径长度 
		q.push(make_pair(1,1));zz.push(0);
		int fg=0,da=0;//判断是否联通,存下最短路长度 
		while(1){
			if(q.empty()==1){fg=1;break;}//不连通 
			int mqx=q.front().first,mqy=q.front().second;
			/*访问*/int mqtime=zz.front();q.pop();zz.pop();
			if(f[mqx][mqy]==1) continue;
			if(m[mqx][mqy]=='B') continue;
			if(mqx<=0||mqy<=0||mqx>x||mqy>y)continue;
			//边界条件
			if(mqx==x&&mqy==y){da=mqtime;break;}//找到
			f[mqx][mqy]=1;
			q.push(make_pair(mqx+1,mqy));zz.push(mqtime+1);
			q.push(make_pair(mqx,mqy+1));zz.push(mqtime+1);
			q.push(make_pair(mqx-1,mqy));zz.push(mqtime+1);
			q.push(make_pair(mqx,mqy-1));zz.push(mqtime+1);
			/*即逐层扩展*/ax=x;ay=y;
		}if(fg)cout<<"J\n";//不连通则后手胜 
		else if((us-da)%2)cout<<"J\n";//奇数则后手胜 
		else cout<<"I\n";//偶数则先手胜 
	}
}//——Walkzz
```

---

## 作者：Fiendish (赞：2)

首先，我们要判断小 I 是不是一上来就输了。

显然，如果 $(1,1)$ 为黑色或者 $(n,m)$ 为黑色或者从 $(1,1)$ 出发只走白色格子到不了 $(n,m)$，小 I 无论怎么操作都无力回天了。

下面考虑如果没有上述情况如何判断胜负。

考虑胜者最后一步走完一定只在图中留下唯一一条从 $(1,1)$ 到 $(n,m)$ 的白色路径，然后下一步对方必输。设最后剩下的白色路径长度为 $s$。设白色格子数量为 $a$，则 $a-s$ 的奇偶性会影响胜负。若为奇数，则小 J 胜，否则小 I 胜。显然 $s\equiv (n+m-1)\bmod2$，所以考虑 $a-n-m+1$ 的奇偶性即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s[5010];
int n,m,T,vis[5010][5010],dx[4]={0,-1,0,1},dy[4]{-1,0,1,0};
void dfs(int x,int y){//判断是否连通
	vis[x][y]=1;
	if(x==n-1&&y==m-1) return;
	for(int i=0;i<4;i++){
		int x1=x+dx[i],y1=y+dy[i];
		if(x1>=0&&y1>=0&&x1<n&&y1<m&&s[x1][y1]=='W'&&!vis[x1][y1]) dfs(x1,y1);
	}
}
int main(){
	cin>>T;
	while(T--){
		cin>>n>>m;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++) vis[i][j]=0;
		long long tot=0;
		for(int i=0;i<n;i++) cin>>s[i];
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++) tot+=(s[i][j]=='W');
		if(s[0][0]=='B'||s[n-1][m-1]=='B'){//起点或终点为黑色
			cout<<"J\n";
			continue;
		}
		dfs(0,0);
		if(!vis[n-1][m-1]) cout<<"J\n";//不连通
		else{
			if((tot-n-m+1)&1) cout<<"I\n";//判断奇偶性
			else cout<<"J\n";
		}
	}
	
}
```

---

## 作者：junee (赞：2)

# P10543 题解

## 前置知识

$bfs$。

## 题目分析

首先思考如果刚开始 $(1,1)$ 和 $(n,m)$ 不连通那么就直接输了，这提示我们需要用 $bfs$ 判断连通性。

为了不输，如果当前存在一条路从 $(1,1)$ 到 $(n,m)$，那么我们不应该去变路上的白点，那么总共可操作的次数就为 $tot_w-path_w$，$tot_w$ 指总白块个数，$path_w$ 指路上白块的个数，在 $bfs$ 过程中我们可以顺便求出路径长。

最后判断一下操作次数奇偶性即可。

## Code

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<random>
#include<chrono>
#include<queue>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
using namespace std;
typedef long long LL;
typedef pair<int,int>PII;
const int N=1010;
int T;
int n,m;
int mp[N][N];
int dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};
int dist[N][N]; 
int ans=0;
queue<PII>q;
bool bfs(){
	memset(dist,0x3f,sizeof dist);
	if(mp[1][1]||mp[n][m])return 0;
	dist[1][1]=1,q.push({1,1});
	while(q.size()){
		auto ver=q.front();q.pop();
		int x=ver.first,y=ver.second;
		for(int i=1;i<=4;i++){
			int xx=x+dx[i],yy=y+dy[i];
			if(xx<1||xx>n||yy<1||yy>m||mp[xx][yy])continue;
			q.push({xx,yy});
			dist[xx][yy]=dist[x][y]+1;
			mp[xx][yy]=1;
		}
	}
	return dist[n][m]!=0x3f3f3f3f;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--){
		ans=0;
		cin>>n>>m;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				char x;
				cin>>x;
				mp[i][j]=(x=='B');
				ans+=(x=='W');
			}
		}
		if(!bfs())cout<<"J"<<'\n';
		else cout<<(((ans-dist[n][m])%2==1)?"I":"J")<<'\n';
	}
	return 0;
}

```

---

## 作者：tanzexiaodezhonghao (赞：0)

## 思路
先判断是否联通，不连通后手胜。接下来因为两人都采用最优策略，所以接下来是左上角到右下角的最短路。

考虑最优策略了，最优策略是涂黑最短路径外的方格。那么接下来判断奇偶性即可。可以用 BFS。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+1;
const int dx[4]={-1,0,1,0};
const int dy[4]={0,-1,0,1};
int n,m,T;
char s[N][N];
bool vis[N][N];
void getT(){
    cin>>T;
}
bool init(int x,int y){
    if(x<1||y<1||x>n||y>m) return 0;
    else return 1;
}
int v;
void readmap(){
    cin>>n>>m;
    v=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>s[i][j];
            if(s[i][j]=='W') v++;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            vis[i][j]=0;
        }
    }
}
void bfs(){
    queue<pair<int,int>> Q;
    queue<int> a;
    a.push(0);
    Q.push(make_pair(1,1));
    int flag=0,l=0;
    while(1){
        if(Q.empty()==1){
            flag=-1;
            break;
        }
        int x=Q.front().first,y=Q.front().second,d=a.front();
        Q.pop();a.pop();
        if(vis[x][y]==1||s[x][y]=='B'||init(x,y)==0) continue;
        if(x==n&&y==m){
            l=d;
            break;
        }
        vis[x][y]=1;
        for(int i=0;i<4;i++){
            Q.push(make_pair(x+dx[i],y+dy[i]));
            a.push(d+1);
        }
    }
    if(flag==-1||abs(v-l)%2==1) cout<<"J\n";
    else  cout<<"I\n";
}
void input(){
    while(T--){
        readmap();
        bfs();
    }
}
int main(){
    getT();
    input();
    return 0;
}
```

---

## 作者：_Epsilon_ (赞：0)

# 题意
你有一个 $n \times m$ 的表格，每个格子有一个颜色。两个人轮流操作这个表格，每次操作是指：将一个白色格子涂成黑的。每次操作要保证：操作完之后的表格可以只走白色的格子从 $(1,1)$ 去到 $(n,m)$。

你需要判断：这两个人谁先违反规定。
# 思路
可以从结果入手反推。

根据题意，一人一次的操作，判断谁先违规。我们先计算出总共可以合法操作多少次，然后通过判断奇偶性算得结果。

那么怎么来计算可操作次数呢？我们考虑先计算出来最短的一条路径，我们可以把它理解为永远不能毁灭的路径。它可能有多种，但是长度是一定的。所以我们叫它的长度为必要长度。除开所谓的必要长度之外，所有白色格子都可以操作。

由于本题数据不强，我们用 `bfs` 就可以实现。建图跑 `dij` 反而要慢一些。
# 实现代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,m,n,mm,w,mi;
string s[1005],ss;
bool vis[1005][1005]={},done=0;
void bfs(int now,int x,int y)
{
    if(done||now>mi||x<0||y<0||x>n-1||y>m-1||s[x][y]=='B'||vis[x][y]==1)
    {
        return;
    }
    if(x==n-1&&y==m-1)
    {
        mi=min(now,mi);
        done=1;
        return;
    }
	vis[x][y]=1;
    bfs(now+1,x+1,y);bfs(now+1,x-1,y);bfs(now+1,x,y+1);bfs(now+1,x,y-1);
}
int main()
{
    cin>>T;
    while(T--)
    {
    	for(int i=0;i<1005;++i)
    	{
    		for(int j=0;j<1005;++j)
    		{
    			vis[i][j]=0;
			}
		}
        w=0;mi=11451419;done=0;
        cin>>n>>m;
        for(int i=0;i<n;++i)
        {
            cin>>ss;
            for(int j=0;j<m;++j)
            {
                if(ss[j]=='W')
                {
                    ++w;
                }
            }
            s[i]=ss;
        }
        if(s[0][0]=='B'||s[n-1][m-1]=='B')
        {
            cout<<'J'<<endl;
            continue;
        }
        bfs(1,0,0);
        if(!done)
        {
            cout<<'J'<<endl;
            continue;
        }
        if((w-mi)%2==0)
        {
            cout<<'J'<<endl;
        }
        else cout<<'I'<<endl;
    }
    return 0;
}
```

---


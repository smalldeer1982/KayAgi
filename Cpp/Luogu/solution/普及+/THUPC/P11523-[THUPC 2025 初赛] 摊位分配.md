# [THUPC 2025 初赛] 摊位分配

## 题目描述


T 大学拥有数不胜数的优秀社团，例如核心成员达到 118 人的酸协（Students' Association of Acid），刚成立就饱受关注的篹协（Students' Association of Bamboo Basket），当然还有名扬四海的蒜协（Students' Association of Garlic）。每学期伊始，T 大学都会统一举办全校性的社团招新活动。招新活动因规模庞大，故又被称为“百团大战”。如何把有限的场地像希尔伯特旅馆一般分配给各个社团，总是百团大战的负责人最头疼的问题。今年的负责人看中了蒜协将一整头大蒜干净利落地拆解成瓣的能力，因此找到了蒜协，希望可以用蒜法来解决分配摊位的问题。

具体而言，今年一共有 $T$ 个社团希望参加百团大战，而可供百团使用的场地可以看成沿着学堂路排成一条直线的 $H$ 个格子。为了鼓励社团之间的良性竞争，负责人决定根据每个社团上个学年对学校的贡献进行分配。按照提交参加申请的顺序，第 $i$ 个社团上个学年对 T 大学的贡献为 $u_i$。负责人希望根据以下规则将所有的 $H$ 个格子分配给每个社团：

- 对于每个社团，计算序列 $u_i, u_i/2, u_i/4, \cdots,u_i/2^{H-1}$；

- 对于计算得到的 $T\times H$ 个数值，每次从中删去一个最大的，并将一个格子分配给相应社团的摊位，直到所有 $H$ 个格子都分配完毕；如果出现多个最大值，
  
  - 若有社团尚未分到格子，则优先分配给这样的社团，否则优先分配给原始的 $u_i$ 最大的社团；
  
  - 如果仍有多个社团可以分配，则按提交参加申请的顺序分配。

因为蒜协大部分成员都去播种过冬的大蒜了，所以需要在烹饪和炼丹部打蒜蓉的你协助负责人计算一下每个社团能分到几个格子的摊位。

## 说明/提示

#### 题目来源

来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。

题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。

## 样例 #1

### 输入

```
4 7
2 1 4 3```

### 输出

```
1 1 3 2
```

## 样例 #2

### 输入

```
9 27
801 919 210 101 417 713 304 613 921```

### 输出

```
4 4 2 1 3 4 2 3 4
```

# 题解

## 作者：lailai0916 (赞：4)

## 原题链接

- [洛谷 P11523 [THUPC2025 初赛] 摊位分配](https://www.luogu.com.cn/problem/P11523)

## 解题思路

序列 $u_i, \frac{u_i}{2}, \frac{u_i}{4}, \cdots, \frac{u_i}{2^{H-1}}$ 是单调递减的，显然只有取到 $\frac{u_i}{2^k}$ 后，才能取到 $\frac{u_i}{2^{k+1}}$。因此，可以维护一个大顶堆，初始时将每个社团的权值都放入堆中。

枚举每个格子，每次从大顶堆中取出权值最大的社团，将该格子分配给该社团，并将其权值减半后重新放回堆中。这种方法的时间复杂度为 $O(H \log T)$，还可能因浮点运算产生精度问题，无法通过此题。

考虑优化，注意到任意权值 $u_i$ 都可以表示为 $a_i \times 2^{n_i}$，其中 $1 \leq a_i < 2$ 且 $n_i \in \mathbb{N}$。当大顶堆中堆顶元素小于 $2$ 时，堆内所有元素均位于区间 $[1, 2)$。

此时有个很好的性质，即对于任意 $a_i < a_j,k\in\mathbb{N}$，满足：

$$
\frac{a_i}{2^{k+1}} < \frac{a_j}{2^{k+1}} < \frac{a_i}{2^k} < \frac{a_j}{2^k}
$$

设还剩 $h$ 个待分配的格子，每个社团会先被分配 $\left\lfloor \frac{h}{T} \right\rfloor$ 个格子，剩下的 $h \bmod T$ 个格子将优先分配给权值 $a_i$ 最大的 $h \bmod T$ 个社团。

显然，对于每个 $u_i$，其 $n_i \sim \log u_i$，因此时间复杂度 $O(T \log u_i)$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int N=100005;
struct Node
{
	int id,cnt;
	double val,st;
	bool operator<(const Node &rhs) const
	{
		if(val!=rhs.val)return val<rhs.val;
		if(cnt==0^rhs.cnt==0)return cnt;
		if(st!=rhs.st)return st<rhs.st;
		return id>rhs.id;
	}
}a[N];
int ans[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n,k;
	cin>>n>>k;
	priority_queue<Node> q;
	for(int i=1;i<=n;i++)
	{
		double x;
		cin>>x;
		q.push({i,0,x,x});
	}
	while(!q.empty()&&k)
	{
		Node u=q.top();
		if(u.val<2)break;
		q.pop();
		u.cnt++;
		u.val/=2;
		q.push(u);
		k--;
	}
	while(!q.empty())
	{
		Node u=q.top();
		q.pop();
		a[u.id]=u;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		ans[a[i].id]=a[i].cnt+k/n+(i>n-k%n);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<ans[i]<<' ';
	}
	return 0;
}
```

---

## 作者：251Sec (赞：4)

如果你像我一样没有观察到循环节，该如何通过这个题？

一个自然的想法是二分拿到席位的人里的 $u_i/2^t$ 的最小值，记为 $K$，然后看此时有多少人拿到了席位。最后的边界情况需要手动模拟 $O(n)$ 轮。这个算法听上去非常有道理，但是仔细一想就会发现，我们的二分需要极其逆天的精度，这样复杂度就倒闭了。

然后我们考虑这样一件事：实际上，由于除掉 $2^t$ 的影响很大，我们的席位分配方案几乎是均分的！具体地，记 $L=\left\lceil\frac{H}{n}\right\rceil$，我们可以发现，最终取到最小值 $K$ 的那个人，至少会拿到 $L$ 个席位，至多会拿到 $L+\log_2 V$ 个席位。

此时，我们就会发现我们的二分变得非常有道理了：我们改为二分 $K$ 是 $\frac{1}{2^{L+\log_2 V}}$ 的多少倍，这样 $K$ 的值域就被限制在了 $V^2$ 级别。总复杂度就成为了 $O(n \log V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int K = 30;
int n;
ll H, L, a[100005];
ll f[100005];
ll Calc(ll k) {
	ll s = 0;
	for (int i = 1; i <= n; i++) {
		f[i] = L;
		if (a[i] >= k) f[i] += __lg(a[i] / k);
		else f[i] -= ceil(log2l(1.0l * k / a[i]));
		f[i] = max(f[i], 0ll);
		s += f[i];
	}
	return s;
}
struct Dat {
	ll x, y;
	int u;
	bool operator<(const Dat &o) const {
		if (y - o.y >= 32) return true;
		if (y - o.y <= -32) return false;
		if (y >= o.y) {
			ll tx = o.x << (y - o.y);
			if (x != tx) return x < tx;
		}
		else {
			ll tx = x << (o.y - y);
			if (tx != o.x) return tx < o.x;
		}
		if (!y != !o.y) return !y < !o.y;
		if (x != o.x) return x < o.x;
		return u > o.u;
	}
};
priority_queue<Dat> q;
int main() {
	scanf("%d%lld", &n, &H);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i);
	L = (H + n - 1) / n + K;
	ll l = 1, r = 1e18, res;
	while (l <= r) {
		ll mid = l + r >> 1;
		if (Calc(mid) <= H) {
			res = mid, r = mid - 1;
		}
		else {
			l = mid + 1;
		}
	}
	Calc(res);
	for (int i = 1; i <= n; i++) H -= f[i], q.push({ a[i], f[i], i });
	while (H--) {
		auto [x, y, u] = q.top(); q.pop();
		f[u]++, y++;
		q.push({ x, y, u });
	}
	for (int i = 1; i <= n; i++) printf("%lld ", f[i]);
	return 0;
}
```

---

## 作者：Tachanka233 (赞：2)

目前最优解。

### 题意

给出一个长度为 $T$ 的数列，进行 $H$ 次操作，每次操作选择一个最大的数 $\div2$，问每个数被操作了多少次。若有多个最大的数，依次按是否被操作、原来的数、数的编号排序进行操作。

### 思路

#### 暴力

每次对最大值进行操作，可以用优先队列维护。时间复杂度 $O(H\log T)$。

#### 优化

对每个初始的数取以 $2$ 为底的对数，于是可以把操作由 $\div2$ 变为 $-1$，方便处理，并且能解决多次操作后数接近 $0$ 的精度问题。  
考虑对于整个数列，若极差 $<1$ 且该数列最少被完整操作 $1$ 次，则其完整操作部分的操作顺序一定是按倒序排序后顺序操作，即从大到小依次操作。证明是显然的：

>先假设不出现相同的数。对最大数操作后，最大数的值 $-1$，变为最小数，原来次大的数变为最大数。设最大值为 $x$，次大值为 $y$。则有 $0< x-y<1$。所以 $0<y-(x-1)<1$。而其他数相对顺序不改变。于是递归得证。
>
>若出现相同的数，因为每个数均被操作一次，所以可以将相同的数同时操作，于是转化为上面的形式，得证。

所以对原数列从大到小排序，每次操作就可以在最大值所在的，极差小于 $1$ 的段上同时进行操作。在最大值减小的期间，若有新的元素能加入当前的段，则将其加入。那么如何知道一个元素合适加入当前段呢？我们可以在操作时一次性地将最大值操作成下一个即将加入的数 $+1$ 的范围内。因为一开始的数的对数差不超过 $\log H$，所以这样的操作次数最多为 $\log H$ 次。对于每次操作，暴力执行即可。总时间复杂度 $O(T\log T+T\log H)$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
const double delta=1e-8;
pair<double,int>a[N];
pair<pair<double,bool>,pair<int,int>>c[N];  //当前值、是否操作过、原始值、编号
bool operator<(pair<pair<double,bool>,pair<int,int>>x,pair<pair<double,bool>,pair<int,int>>y){
    if(x.first.first-y.first.first<delta&&x.first.first-y.first.first>-delta){  //处理精度
        if(x.first.second==y.first.second){
            if(x.second.first==y.second.first){
                return x.second.second<y.second.second;
            }
            return x.second.first<y.second.first;
        }
        return x.first.second<y.first.second;
    }
    return x.first.first<x.first.first;
}
int n,m,ans[N],b[N];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>b[i];  //原数组
        a[i].first=log2(b[i]);  //转对数
        a[i].second=i;  //记录编号
    }
    sort(a+1,a+1+n);//排序
    int l=1;
    for(int i=n;i>=1;i--){
        if(a[n].first-a[i].first>=1){
            l=i+1;  //初始化左端点
            break;
        }
    }
    while(m>=(n-l+1)*floor(a[n].first-a[l-1].first)){
        for(int i=l;i<=n;i++){
            ans[a[i].second]+=floor(a[n].first-a[l-1].first);//对[l,n]进行操作
        }
        m-=(n-l+1)*floor(a[n].first-a[l-1].first);
        for(int i=l;i<=n;i++){
            a[i].first-=floor(a[n].first-a[l-1].first);
        }
        while(a[n].first-a[l-1].first<1&&l>1)l--;   //更新左端点
        if(l==1){
            break; //特判a[l-1]不合法
        }
    }
    for(int i=l;i<=n;i++){  //对[l,n]进行操作
        ans[a[i].second]+=m/(n-l+1);
        a[i].first-=m/(n-l+1);
    }
    m%=(n-l+1);
    for(int i=l;i<=n;i++){
        c[i].first.first=a[i].first;
        c[i].first.second=(ans[a[i].second]==0);
        c[i].second.first=b[a[i].second];
        c[i].second.second=-a[i].second;
    }
    sort(c+l,c+n+1);
    for(int i=n;i>=n-m+1;i--){//最后一次不完全的操作直接暴力
        ans[-c[i].second.second]++;
    }
    for(int i=1;i<=n;i++)cout<<ans[i]<<" ";
}
```

---

## 作者：ARIS2_0 (赞：2)

### 前言

赛时没切出来，赛后缺席队友一眼秒，甚至队友还是目前最优解，糖丸了。

### 思路

考虑一个很好写的 $O(H\log T)$ 暴力：

按题目的优先级要求维护一个 `set`，其中有社团编号、**当前社团最大数字**与当前社团有没有被分到过摊位。

每次循环，取出最大值，分配一个摊位给这个社团，然后将数值除以 $2$ 后放回去，直到 $H$ 个摊位分完。

考虑优化。

发现一个非常有用的性质：

> 设当前 `set` 中**社团最大数字的最大值**为 $p$，最小值为 $q$，则当 $p<q\times 2$，且所有社团都分配过摊位时，**接下来所有摊位分配的顺序都是按 `set` 中的顺序进行分配**。
>
> 因为最大值 $p$ 分配摊位后会变为 $\frac{p}{2}$，而 $\frac{p}{2}<q$，则 $p$ 在 `set` 中是劣于 $q$ 的，所以 $p$ 的第二次分配摊位会在 $q$ 的第一次分配摊位之后，递归得证。

那么，我们记 $cnt$ 为分配过摊位的社团的个数。在 $H$ 次循环中，若我们在某次循环发现有 $p<q\times 2$ 且 $cnt=n$ 时，就可以直接跳出循环，然后按 `set` 中的顺序分配剩下的摊位即可。

因为数字一直在除以 $2$，所以循环实质上最多会执行 $\log\max (u_i)+T$ 次，其中 $+T$ 是因为要保证每个社团都有摊位。

则总复杂度是 $O((T+\log\max(u_i))\log T)$，完全够用。

但是有个问题：数字是不大的，除以 $2$ 多次后会非常接近 $0$，精度根本不够用。

那我们可以不维护社团最大数字的最大值，转而去维护其**以 $2$ 为底的对数的值**，这样就对精度要求低了很多。

注意维护以 $2$ 为底的对数的值时，上文的所有 $\times2$ 要变为 $+1$，$\div2$ 变为 $-1$。

### 实现

注意两个细节：

1. 虽然对精度要求低了很多，但还是有点的，实测 `eps` 要开到 $10^{-12}$，开 $10^{-6}$ 会 `WA` on #1。

2. 如果你的 $H$ 次循环是这么实现的：

```cpp
while(H--){
    //something
}
```

注意，当其减小到 $0$ 而退出循环时，$H$ 的值是 $-1$ 而不是 $0$！

建议使用如下实现：

```cpp
while(1){
    if(!H)break;
    int pos=/*something*/;
    ans[pos]++;
    H--;
}
```

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9,maxn=1e5+10;
const double eps=1e-12;
struct node{int u;double log;int id;bool have;}a[maxn];
bool operator < (node a,node b){
    if(fabs(a.log-b.log)>eps)return a.log>b.log;
    if(a.have^b.have)return !a.have;
    if(a.u!=b.u)return a.u>b.u;
    return a.id<b.id;
}
set<node>s;
int ans[maxn];
bool b[maxn];
node q[maxn];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i].u;
		a[i].id=i;
        a[i].log=log2(a[i].u);
        s.insert(a[i]);
	}
    int cnt=0;
    while(1){
        if(!m)break;
        node p=(*s.begin());
        s.erase(p);
        m--;
        ans[p.id]++;
        if(!b[p.id])b[p.id]=1,cnt++;
        s.insert(node{p.u,p.log-1,p.id,1});
        node p1=(*s.begin()),p2=(*(--s.end()));
        if(p1.log<p2.log+1 and cnt==n)break;
    }
    for(int i=1;i<=n;i++)ans[i]+=m/n;
    m%=n;
    for(node p:s){
        if(!m)break;
        ans[p.id]++;
        m--;
    }
    for(int i=1;i<=n;i++)cout<<ans[i]<<" ";
	return 0;
}
```

---

## 作者：WorldMachine (赞：1)

如果 $H$ 很小，直接大力 $T$ 路归并即可。

发现更新的方式很特殊，是折半，那么经过 $\mathcal O(T\log V)$ 次操作后，最大值不会超过最小值的 $2$ 倍，此时分配摊位就是轮流进行的了，直接统计即可。

时间复杂度为 $\mathcal O(T\log T\log V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 100005;
int n, h, a[N], s[N];
struct node { int u, v, i; };
bool operator<(const node &a, const node &b) {
	if (a.u * b.v != a.v * b.u) return a.u * b.v > a.v * b.u;
	if ((!s[a.i]) ^ (!s[b.i])) return !s[a.i];
	if (a.u != b.u) return a.u > b.u;
	return a.i < b.i;
}
bool operator<=(const node &a, const node &b) { return a.u * b.v <= b.u * a.v; }
node operator*(const node &a, const int k) { return (node){a.u * k, a.v, a.i}; }
node operator/(const node &a, const int k) { return (node){a.u, a.v * k, a.i}; }
set<node> Q;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> h;
	for (int i = 1; i <= n; i++) cin >> a[i], Q.insert({a[i], 1, i});
	while ((*--Q.end()) * 2 <= *Q.begin()) {
		node p = *Q.begin();
		Q.erase(Q.begin());
		s[p.i]++, h--;
		Q.insert(p / 2);
		if (!h) break;
	}
	if (!h) {
		for (int i = 1; i <= n; i++) cout << s[i] << ' ';
		return 0;
	}
	for (int i = 1; i <= n; i++) s[i] += h / n;
	h %= n;
	for (auto it = Q.begin(); h; it++, h--) s[it->i]++;
	for (int i = 1; i <= n; i++) cout << s[i] << ' ';
}
```

---

## 作者：ty_mxzhn (赞：0)

# [THUPC2025 初赛] 摊位分配

## 题目描述

T 大学拥有数不胜数的优秀社团，例如核心成员达到 118 人的酸协（Students' Association of Acid），刚成立就饱受关注的篹协（Students' Association of Bamboo Basket），当然还有名扬四海的蒜协（Students' Association of Garlic）。每学期伊始，T 大学都会统一举办全校性的社团招新活动。招新活动因规模庞大，故又被称为“百团大战”。如何把有限的场地像希尔伯特旅馆一般分配给各个社团，总是百团大战的负责人最头疼的问题。今年的负责人看中了蒜协将一整头大蒜干净利落地拆解成瓣的能力，因此找到了蒜协，希望可以用蒜法来解决分配摊位的问题。

具体而言，今年一共有 $T$ 个社团希望参加百团大战，而可供百团使用的场地可以看成沿着学堂路排成一条直线的 $H$ 个格子。为了鼓励社团之间的良性竞争，负责人决定根据每个社团上个学年对学校的贡献进行分配。按照提交参加申请的顺序，第 $i$ 个社团上个学年对 T 大学的贡献为 $u_i$。负责人希望根据以下规则将所有的 $H$ 个格子分配给每个社团：

- 对于每个社团，计算序列 $u_i, u_i/2, u_i/4, \cdots,u_i/2^{H-1}$；

- 对于计算得到的 $T\times H$ 个数值，每次从中删去一个最大的，并将一个格子分配给相应社团的摊位，直到所有 $H$ 个格子都分配完毕；如果出现多个最大值，
  
  - 若有社团尚未分到格子，则优先分配给这样的社团，否则优先分配给原始的 $u_i$ 最大的社团；
  
  - 如果仍有多个社团可以分配，则按提交参加申请的顺序分配。

因为蒜协大部分成员都去播种过冬的大蒜了，所以需要在烹饪和炼丹部打蒜蓉的你协助负责人计算一下每个社团能分到几个格子的摊位。

$T\le 10^5,u_i,H\le 10^9$。

## 题解

合理猜测，在进行了不多次操作以后分配是循环的。

原因其实很简单，因为如果最大值比最小值的两倍要小的话这一次分配最大值会变成最小的，而第二个会再次变成最小的，依次变成最小值。

于是我们暴力模拟 $O(T\log V)$ 遍后 $O(1)$ 算出最后的分配情况即可通过。

浮点数要用分数表示，如果 $k$ 够大了就提前结束模拟，因为这个时候显然已经可以循环移动了。

---

## 作者：I_will_AKIOI (赞：0)

赛时队友薄纱了此题，所以特地来补题了。

给出一个定义：对于一个正整数 $x$，一定存在一个整数 $i$ 使得 $2^i\ge x\land x<2^{i+1}$，我们称 $x$ 是 $2^i$ 级别的数字。发现如果所有数字都是同一级别的，并且都被分配过，那么就可以按照原始 $u_i$ 大小排序然后依次分配，分配一轮之后还没分配完的话就再分配一轮，直到分配完为止。

接着发现当所有 $u_i$ 都为 $2^{-1}$ 级别的数字时，由于初始 $u_i\ge 1$，所以此时每个社团肯定都被分配过一次了，并且还在同一个级别，因此这个时候就可以统一分配。

于是当 $u_i\ge 1$ 时，把每个社团插入堆中，通过重载运算符取最优社团，当最优的社团的 $u_i<1$ 时，就统一分配。

由于把 $u_i$ 一直除以 $2$ 可能出现浮点数精度问题，所以使用分数来表示。

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
struct Data
{
  int num,x,y;//社团编号，原始的贡献和被选择了几次，那么当前的贡献就是x/(1<<y)
  bool operator<(const Data &w)const//重载运算符比较社团优先级
  {
    long long u=((long long)w.x*(1ll<<y)),v=((long long)x*(1ll<<w.y));//通分后的分子
    if(u!=v) return u>v;//如果贡献不同，贡献大的在前面
    if(bool(y)!=bool(w.y)) return w.y<y;//有社团没贡献过，没贡献的排前面
    if(x!=w.x) return w.x>x;//原始ui不同，大的排前面
    return w.num<num;//否则编号排前面
  }
};
int n,m,a[N],b[N];
priority_queue<Data>q;
int main()
{
  ios::sync_with_stdio(0);
  cin>>n>>m;
  for(int i=1;i<=n;i++) cin>>a[i],q.push(Data{i,a[i],0});
  while(1)
  {
    Data w=q.top();
    if(w.x<(1<<w.y)) break;
    m--;
    q.pop();
    b[w.num]++;
    w.y++;
    q.push(w);
    //更新一下当前的贡献
    if(m==0) break;
  }
  for(int i=1;i<=n;i++) b[q.top().num]+=m/n+(((m-1)%n+1)>=i),q.pop();//统一分配
  for(int i=1;i<=n;i++) cout<<b[i]<<" ";
  return 0;
}
```

---

## 作者：Kendieer (赞：0)

一种非常骚的做法。

## 思路构筑

可以注意到，每次操作都会改变对应数字，所有到最后数字必定会越来越小。

又因为本题最小的正整数为 $1$，也就是说如果当前最大值 $0\lt u_i\lt 1$，那么说明不再有摊位没有分到过位置了，并且还能得到一个性质：

小于 $1$ 的所有顺序后续无论如何操作，分到格子的顺序必然是固定的。证明如下：

对于任何一个操作完后为 $0\lt u_i\lt 1$ 的数，那么要使得操作前的数不变，那么值为 $1\le u_i \lt 2$，且操作完后的值必然为 $0.5\le u_i \lt 1$，并且这区间所有的数操作完后下一个区间为 $0.25\le u_i \lt 0.5$，以此类推，不会影响到原有序列。

所以我们只需暴力用堆模拟 $u_i \ge 1$ 的时候，然后按规则排序，集中处理剩余的 $H$ 即可。

处理所有 $u_i$ 小于 $1$ 至多只需 $31$ 次即可。

时间复杂度为 $O(T\log V)$，其中 $V = 10^9$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define rep(i,a,b) for(ll i = (a);i < (b);i++)
#define repr(i,a,b) for(ll i = (b) - 1;i>= (a);i--)
#define elif else if
#define Code_by_Kendieer return 0
typedef long long ll;
typedef unsigned long long ull;
const ll inf = 0x3f7f7f7f7f7f7f7f;

ll qread();
char readChar();
void qwrite(ll x,int t = 10);

const int maxn = 1e5 + 7;
const int mod = 998244353;
struct Node {
    int id;
    int val,dv = 1;
    int org;
    int flag = 0;
    double op(){
        return (double)val/dv;
    }
    bool operator()(Node a,Node b){
        if (a.op() == b.op()) {
            if (a.flag == b.flag){
                if (a.org == b.org) return a.id > b.id;
                else return a.org < b.org;
            }
            else return a.flag > b.flag;
        }
        return a.op() < b.op();
    }
    Node(int id = 0,int val = 0):id(id),val(val),org(val){}
};

priority_queue<Node,vector<Node>,Node> pq;
vector<Node> arr;
int cnt[maxn];

void solve(){
    int n = qread(),h = qread();
    rep(i,1,n+1){
        int val = qread();
        pq.push(Node(i,val));
    }
    while(h&&pq.size()){
        auto tmp = pq.top();
        pq.pop();
        cnt[tmp.id]++;
        tmp.dv *= 2;
        tmp.flag = 1;
        h--;
        if (tmp.val < tmp.dv){
            arr.push_back(tmp);
        } else {
            pq.push(tmp);
        }
    }
    sort(arr.begin(),arr.end(),[](Node a,Node b)->bool{
        if (a.op() == b.op()){
            if (a.org == b.org) return a.id < b.id;
            return a.org > b.org;
        }
        return a.op() > b.op();
    });
    rep(i,0,arr.size()){
        cnt[arr[i].id] += h/arr.size() + (h%arr.size() > i);
    }
    rep(i,1,n+1) cout << cnt[i] << " \n"[i==n];
}

int main(){
    // cin.tie(0),cout.tie(0);
    // ios::sync_with_stdio(0);
    int n = 1;
    // n = qread();
    while(n--) solve();
    Code_by_Kendieer;
}

// =====================================================
ll qread(){
    ll r = 0,s = 1,ch = getchar();
    while (ch == ' ' || ch == '\r' || ch == '\n') ch = getchar();
    if (ch == '-') ch = getchar(),s = -1;
    while (ch >= '0' && ch <= '9') r = r * 10 + ch - '0',ch = getchar();
    return r * s;
}
char readChar(){
    int ch = getchar();
    while (ch == ' ' || ch == '\r' || ch == '\n') ch = getchar();
    return ch;
}
void qwrite(ll x,int t){
    if (x<0) putchar('-'),x=-x;
    if (x>=t) qwrite(x/t,t);
    putchar(x%t<10?'0'+x%t:'A'-10+x%t);
}
// =====================================================
```

---


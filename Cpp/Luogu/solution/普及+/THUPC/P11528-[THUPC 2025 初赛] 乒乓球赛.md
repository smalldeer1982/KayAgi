# [THUPC 2025 初赛] 乒乓球赛

## 题目描述

Menji 喜欢看乒乓球比赛，但由于观赛的人太多，他只能听到一部分的信息。

乒乓球赛一共包含 $T$ 局，一局乒乓球的过程如下：

两位选手分别有得分，用 $s_A$ 和 $s_B$ 表示，初始 $s_A=s_B=0$。

接下来会进行若干个回合，在第 $i$ 个回合，会有一个获胜者 $win_i(win_i\in\{\texttt{A},\texttt{B}\})$，若 $win_i=\texttt{A}$ 则 $A$ 的得分 $+1$，即 $s_A=s_A+1$，否则 $B$ 的得分 $+1$，即 $s_B=s_B+1$。当任意一名选手达到 $11$ 分，且领先另一名选手至少 $2$ 分时（即 $\max(s_A,s_B)\geq 11$, $\max(s_A,s_B)-\min(s_A,s_B)\geq 2$），该局**立刻结束**。

对于每一局比赛，Menji 听到了最终该局进行的回合数 $n$，以及一部分时刻结束时的比分，例如 Menji 可能在第 $5$ 回合结束时听到比分是 $3:2$，**但 Menji 并不知道哪一名选手获得了 $3$ 分，只知道其中一名选手获得了 $3$ 分，另外一名选手获得了 $2$ 分**。

具体的，Menji 的信息可以被表示为一个非负整数 $n$，表示该局**恰好**进行了 $n$ 个回合，以及 $2$ 个长为 $n$ 的序列 $a_1\cdots a_n,b_1\cdots b_n$。对于每一个 $i(1\leq i\leq n)$，若 $a_i=b_i=-1$，则 Menji 没有听到任何第 $i$ 个回合结束时的信息，否则保证 $0\leq a_i,b_i\leq n$，表示在第 $i$ 个回合结束时，一定满足 $s_A=a_i,s_B=b_i$ 或 $s_A=b_i,s_B=a_i$。

显然，很多时候 Menji 的信息并不能还原比赛每一局每一回合的获胜者，甚至有时候 Menji 的信息会是错误的。Menji 想要知道，有多少个获胜者序列 $win_1\cdots win_n$ 满足他已知的所有信息？

由于答案可能很大，请输出答案对 $998244353$ 取模的结果。

## 说明/提示

### 样例解释

比赛总共进行了 $6$ 局。

- 对于第一局，恰好进行了 $11$ 个回合结束，一定是某一选手连胜了 $11$ 回合，所以获胜者序列一定是全 $\texttt{A}$ 或是全 $\texttt{B}$，故答案为 $2$。
- 对于第二局，恰好进行了 $11$ 个回合结束，但第二回合结束的比分是 $1:1$，最终至多只能达到 $10:1$ 的比分，因此不存在合法的获胜者序列使得恰好 $11$ 回合结束，故答案为 $0$。
- 对于第三局，显然不可能在 $11$ 个回合内达到 $1:11$ 的比分，故答案为 $0$。
- 对于第四局，若第 $20$ 个回合的比分达到 $11:9$，则该局会立刻结束，不会进行到第 $22$ 个回合，故答案为 $0$。
- 对于第五局，双方的得分一定是先达到 $10:10$，之后其中一名选手连胜 $2$ 局，故答案为 $\dbinom{20}{10}\times 2 = 369512$。
- 对于第六局，容易发现不可能恰好进行 $23$ 个回合时结束，故答案为 $0$。
- 对于第七局，我有一个完美的解释，可惜写不下了。

### 题目来源

题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。

## 样例 #1

### 输入

```
7
11
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
11
-1 -1
1 1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
11
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
1 11
22
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
11 9
-1 -1
-1 -1
22
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
23
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
-1 -1
22
-1 -1
1 1
-1 -1
3 1
-1 -1
4 2
-1 -1
2 6
-1 -1
-1 -1
5 6
-1 -1
-1 -1
7 7
-1 -1
-1 -1
9 8
-1 -1
9 10
-1 -1
11 10
-1 -1```

### 输出

```
2
0
0
0
369512
0
864```

# 题解

## 作者：lllyyykkk (赞：1)

来一篇记忆化搜索的题解。  
注：下文中加赛指的是有一个人分数超过 $11$ 分的情况。
### [题目传送门](https://www.luogu.com.cn/problem/P7590)

首先先判断不合法的情况。

对于总局数，如果还没打到 $11$ 局或加赛之后总局数为奇数，则不合法。  
对于比赛过程，比如得分与局数不符，分数倒退，已经获胜但比赛仍然进行，这些情况也不合法。

~这些信息有点离谱了。~

接下来，分讨两类。

### $n \le 20$
直接记搜，为了方便，可以将最终的分数减一统计，不用判边界条件。

### $n > 20$
参考样例提示的方法，我们先暴力记搜出两人十平的情况，接下来的对局因为必定是一分一分涨，套一个快速幂即可。

记搜时不要忘记判断不合法情况。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define W return cout <<"0\n",void()
using ll=long long;
const int N=1e5+10,mod=998244353;
int n,T;
int a[N],b[N];
int f[20][20];
inline int ksm(int p,int q){
	int res=1;
	while(q){
		if(q&1) res=1ll*res*p%mod;
		q>>=1;p=1ll*p*p%mod;
	}
	return res;
}
inline bool J(int x,int y,int r){
	if((x==a[r]&&y==b[r])||(x==b[r]&&y==a[r])) return 0;
	return 1;
}
int dfs(int x,int y){
	if(!x&&!y) return 1;
	if(f[x][y]!=-1) return f[x][y];
	if(a[x+y]!=-1) if(J(x,y,x+y)) return f[x][y]=0;
	int res=0;
	if(x) res+=dfs(x-1,y);
	if(y) res+=dfs(x,y-1);
	return f[x][y]=res%mod;
}
inline void solve(){
	if(n<11||n>20&&(n&1)) W;
	for(int i=1,la=0,lb=0;i<n;i++){
		if(a[i]==-1) continue;
		if(max(a[i],b[i])<la||max(a[i],b[i])<lb||a[i]+b[i]!=i||(max(a[i],b[i])>=11&&abs(a[i]-b[i])>=2)) W;
		la=a[i],lb=b[i];
	}
	memset(f,-1,sizeof(f));
	if(n<=20){
		if(a[n]!=-1) if(J(11,n-11,n)) W;
		return cout <<(dfs(10,n-11)+dfs(n-11,10))%mod<<'\n',void();
	}
	else{
		if(a[n]!=-1) if(J((n>>1)+1,(n>>1)-1,n)) W;
		return cout <<1ll*dfs(10,10)*ksm(2,n-20>>1)%mod<<'\n',void();
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
		solve();
	}	
	return 0;
}
``````

---

## 作者：luqyou (赞：1)

## 思路

提供一个比较无脑的思路。

一个比较直接的思路是令 $f_{i,j,k}$ 表示进行了 $i$ 局比赛，两个人得分分别为 $j,k$ 的方案数。

然后你发现 $\max |j-k| \le 11$。然后你就可以把状态优化为 $f_{i,j}$ 表示进行了 $i$ 局比赛，两个人得分差为 $j$ 的方案数。

转移就是看两个人谁得分，然后 $f_{i,j}$ 转移到 $f_{i+1,j+1}$ 和 $f_{i+1,j-1}$。但是注意 $j=0$ 时需要转移两次 $f_{i+1,1}$。

其次还有细节就是要把不合法的局面 dp 值设为 $0$。

具体不合法局面即：

- 不符合输入 $a_i,b_i$ 比分要求的局面。

- $20$ 局以后分差 $\ge 2$ 的局面。

- $i \ge 11$ 局以后分差位于 $[22-i,11]$ 之间的局面。 


## code

```cpp
void solve(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
    if(n<=10) return cout<<0<<endl,void();
    for(int i=1;i<=n;i++) if(a[i]+b[i]>=0&&a[i]+b[i]!=i) return cout<<0<<endl,void();
    for(int i=1;i<n;i++) if(abs(a[i]-b[i])>=2&&max(a[i],b[i])>=11) return cout<<0<<endl,void();
    dp[0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=11;j++) dp[i][j]=0;
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<11;j++) add(dp[i][j+1],dp[i-1][j]);
        for(int j=1;j<=11;j++) add(dp[i][j-1],dp[i-1][j]);
        add(dp[i][1],dp[i-1][0]);
        if(a[i]!=-1){
            int c=abs(a[i]-b[i]);
            for(int j=0;j<=11;j++) if(j!=c) dp[i][j]=0;
        }
        if(i!=n&&i>=20){
            for(int j=2;j<=11;j++) dp[i][j]=0;
        }
        else if(i!=n&&i>=11){
            for(int j=22-i;j<=11;j++) dp[i][j]=0;
        }
    }
    if(n<=20) cout<<dp[n][22-n]<<endl;
    else cout<<dp[n][2]<<endl;
}
```

---

## 作者：2021AC (赞：1)

提供一个自我感觉比较好想的思路~

首先还是先分类讨论：

- 当 $ n < 11 $ ：显然是不可能，因为要赢得比赛至少需要 $ 11 $ 分。
- 当 $ 11 \leq n \leq 20 $ ：这个时候可以在 $ 11 $ 分之内解决战斗。
- 当 $ n > 20 $：
  - 如果 $ n $ 为奇数：因为最后赢得人要连赢两分，所以两人最终比分的奇偶性一样，所以显然不可能。
  - 如果 $ n $ 为偶数：两人必然在第 $ 20 $ 个回合打成 $ 10:10 $，才会进入这个可能，而后边两人的比分会以每两个回合一组上升（你得分我追平），直到有人连赢两局，这部分的可能性数是 $ 2^{\frac{n - 20}{2}} $。

现在我们考虑第 2 个分类，当 $ 11 \leq n \leq 20 $ 时，我们可以直接使用动态规划来解决问题。设 $ dp(a, b) $ 为 A 得 $ a $ 分且 B 得 $ b $ 分的可能性，则 $ dp(a, b) = dp(a - 1, b) + dp(a, b - 1) $，即上个回合 A 得分还是 B 得分。当然还需考虑当前状态与输入是否相符，不相符直接返回 $ 0 $。因为最后一个回合才会到达 $ 11 $ 分，为了写起来简单点可以从 $ dp(10, n - 11) $ 和 $ dp(n - 11, 10) $ 开始转移。

考虑第 3 个分类，当 $ n $ 为偶数时，前边还有到达 $ 10:10 $ 的可能性，也就是 $ dp(10, 10) $，再乘以后来的可能性就是答案。

最后还需要考虑，输入数据的合法性问题，这可能是最麻烦的。用 $ la $ 和 $ lb $ 记录上一个得分，当前回合的得分不能低于上一个得分，否则不合法；当前回合的得分相加应该等于当前回合，否则不合法；当前回合如果没到最后一个回合不能提前达到胜利条件。还有最后一个回合，其实 $ n $ 一定，最终比分已经是确定的，如果不相等也是不合法的。

至此就可以愉快地 AC 了~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 100010, Mod = 998244353;
int _, n, A[N], B[N], f[11][11], ans;

int qpow(int a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = a * a % Mod)
        if (b & 1) res = res * a % Mod;
    return res;
}

int dp(int a, int b) {
    if (!a && !b) return 1;
    int &res = f[a][b], i = a + b;
    if (~res) return res;
    res = 0;
    if (~A[i] && (a != A[i] || b != B[i]) && (a != B[i] || b != A[i]))
        return f[b][a] = 0;
    if (a) res += dp(a - 1, b);
    if (b) res += dp(a, b - 1);
    return f[b][a] = res %= Mod;
}

void work() {
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> A[i] >> B[i];
    // 检查数据合法性
    if (n < 11 || n > 20 && n & 1) return cout << "0\n", void();
    for (int i = 1, la = 0, lb = 0; i < n; ++i) {
        if (A[i] < 0) continue;
        if (max(A[i], B[i]) < max(la, lb) || 
            min(A[i], B[i]) < min(la, lb) ||
            A[i] + B[i] != i ||
            max(A[i], B[i]) >= 11 && max(A[i], B[i]) - min(A[i], B[i]) >= 2)
            return cout << "0\n", void();
        la = A[i], lb = B[i];
    }
    // 分类讨论
    memset(f, -1, sizeof f);
    if (n <= 20) {
        int a = 11, b = n - 11;
        if (~A[n] && (a != A[n] || b != B[n]) && (a != B[n] || b != A[n]))
            return cout << "0\n", void();
        ans = (dp(10, n - 11) + dp(n - 11, 10)) % Mod;
    } else {
        int a = (n >> 1) + 1, b = (n >> 1) - 1;
        if (~A[n] && (a != A[n] || b != B[n]) && (a != B[n] || b != A[n]))
            return cout << "0\n", void();
        ans = (dp(10, 10) * qpow(2, n - 20 >> 1)) % Mod;
    }
    cout << ans << '\n';
}

signed main() {
    cin.tie(0)->sync_with_stdio(0);
    for (cin >> _; _--;) work();
    return 0;
}
```

---

## 作者：ty_mxzhn (赞：1)

## 题目描述

Menji 喜欢看乒乓球比赛，但由于观赛的人太多，他只能听到一部分的信息。

乒乓球赛一共包含 $T$ 局，一局乒乓球的过程如下：

两位选手分别有得分，用 $s_A$ 和 $s_B$ 表示，初始 $s_A=s_B=0$。

接下来会进行若干个回合，在第 $i$ 个回合，会有一个获胜者 $win_i(win_i\in\{\texttt{A},\texttt{B}\})$，若 $win_i=\texttt{A}$ 则 $A$ 的得分 $+1$，即 $s_A=s_A+1$，否则 $B$ 的得分 $+1$，即 $s_B=s_B+1$。当任意一名选手达到 $11$ 分，且领先另一名选手至少 $2$ 分时（即 $\max(s_A,s_B)\geq 11$, $\max(s_A,s_B)-\min(s_A,s_B)\geq 2$），该局**立刻结束**。

对于每一局比赛，Menji 听到了最终该局进行的回合数 $n$，以及一部分时刻结束时的比分，例如 Menji 可能在第 $5$ 回合结束时听到比分是 $3:2$，**但 Menji 并不知道哪一名选手获得了 $3$ 分，只知道其中一名选手获得了 $3$ 分，另外一名选手获得了 $2$ 分**。

具体的，Menji 的信息可以被表示为一个非负整数 $n$，表示该局**恰好**进行了 $n$ 个回合，以及 $2$ 个长为 $n$ 的序列 $a_1\cdots a_n,b_1\cdots b_n$。对于每一个 $i(1\leq i\leq n)$，若 $a_i=b_i=-1$，则 Menji 没有听到任何第 $i$ 个回合结束时的信息，否则保证 $0\leq a_i,b_i\leq n$，表示在第 $i$ 个回合结束时，一定满足 $s_A=a_i,s_B=b_i$ 或 $s_A=b_i,s_B=a_i$。

显然，很多时候 Menji 的信息并不能还原比赛每一局每一回合的获胜者，甚至有时候 Menji 的信息会是错误的。Menji 想要知道，有多少个获胜者序列 $win_1\cdots win_n$ 满足他已知的所有信息？

由于答案可能很大，请输出答案对 $998244353$ 取模的结果。

$\sum n\le 5\times 10^5$，多测。

## 题解

给个好写好调好过做法。

设计状态为第 $i$ 轮比分情况是 $(a,b)$ 的方案数。转移直接枚举，显然无法通过所有数据。

注意到对于增加回合的情况显然只有很少的情况。因为首先 $b=i-a$，然后 $|a-b|<1$。如此我们只需要拿 `map` 记录所有合法状态暴力转移即可通过。

时间复杂度可以认为是 $O(n)$ 的。当然如果你的 `map` 没用好成 $O(n\log n)$ 的了也可以通过。

---

## 作者：ztlh (赞：0)

## Solution

首先，不妨 $a_i < b_i$。

其次，对于给定的 $n$，我们容易得到双方最终的比分：

- 若 $n \le 10$，显然比赛并没有结束，输出 $0$。
- 若 $11 \le n \le 20$，最终比分一定是一方 $11$ 分一方 $n-11$ 分，且前者胜。
- 若 $n=21$，要使某一方满足取胜条件，分差至少为 $3$，而此时比分为 $12:9$，比赛早已结束，输出 $0$。
- 若 $n \ge 22$，则由双方分差为 $2$ 知 $n$ 只能为偶数（若为奇数则输出 $0$），比分一定是一方 $n/2-1$ 分一方 $n/2+1$ 分。

然后我们分别考虑上面的第二类和第四类情况。

在分类之前，注意到若 $a_i \ne -1$ 且 $a_i+b_i \ne i$，即第 $i$ 回合后双方的总分不为 $i$，可直接输出 $0$。

先考虑 $n \ge 22$ 的情况（遵循下面赛时代码的分讨顺序）。下面会有一系列对 $a_i$ 和 $b_i$ 的赋值，若与输入给定的值冲突则直接输出 $0$ 即可。

- $a_1=0$，$b_1=1$ 显然。
- 上面的分类中 $a_n$ 与 $b_n$ 的值已给出。
- 第 $n-1$ 和 $n$ 回合一定是胜者连续得分，于是 $a_{n-2}$，$b_{n-2}$，$a_{n-1}$，$b_{n-1}$ 确定。
- 再往前推,只要当前双方打平（$a_i=b_i$）且得分大于 $10$，就此时而言的最后两个回合一定是两人各胜一回合（$a_{i-2} = b_{i-2} = a_i-1$）。

再考虑 $11 \le n \le 20$ 的情况。此时除了 $1$ 处和 $n$ 处的比分外，可得的只有 $n-1$ 处的比分——$b_{n-1}=10$，并依此算出 $a_{n=1}$。

现在我们可以在不考虑获胜条件的前提下计算答案了。

假设 $a_i$ 和 $b_i$ 不为 $-1$ 且下一个不为 $-1$ 的位置是 $j$，则两者间共有 $j-i$ 个回合需要确定。

显然，若给定信息合法，则对任何 $i$ 和 $j$，一定有 $a_i \le a_j$ 且 $b_i \le b_j$，否则输出 $0$。

若合法，考虑以下情况：

- $b_i > a_j$，则 $a_i$ 和 $a_j$ 一定是同一人的分数，即 $j-i$ 个回合中此人赢了 $a_j-a_i$ 回合。答案为 $\binom{j-i}{a_j-a_i}$。
- $b_i \le a_j$ 且 $a_j \ne b_j$，此时较上一类而言还存在一种情况：$a_j$ 和 $b_i$ 是同一人的分数。答案为 $\binom{j-i}{a_j-a_i}+\binom{j-i}{a_j-b_i}$。
- $b_i \le a_j$ 且 $a_j = b_j$，此时上一类答案的两部分本质上相同。答案为 $\binom{j-i}{a_j-a_i}$。

最后将每一对 $i$ 和 $j$ 的答案相乘即得最终答案，别忘了取模。

## Code


```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
#define N 100005
#define Md 998244353
using namespace std;
int T,n;
struct node{
	int a,b;
}c[N],cl,cr;
int s[N],tp;
ll ans,tmp;
ll fac[N];
ll inv[N];
inline ll C(ll n_,ll m_){
	return fac[n_]*inv[m_]%Md*inv[n_-m_]%Md;
}
int main(){
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=100000;i++) fac[i]=fac[i-1]*i%Md;
	for(int i=2;i<=100000;i++) inv[i]=(Md-Md/i)*inv[Md%i]%Md;
	for(int i=1;i<=100000;i++) inv[i]=inv[i-1]*inv[i]%Md;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		c[0].a=c[0].b=0; tp=0;
		for(int i=1;i<=n;i++){
			scanf("%d%d",&c[i].a,&c[i].b);
			if(c[i].a>c[i].b) swap(c[i].a,c[i].b);
		}
		bool f=1;
		for(int i=1;i<=n;i++){
			if(c[i].a!=-1&&c[i].a+c[i].b!=i){
				f=0; break;
			}
		}
		if(!f){
			printf("0\n");
			continue;
		}
		if(c[1].a==-1) c[1].a=0,c[1].b=1;
		if(n>=22){
			if(n&1){
				printf("0\n");
				continue;
			}
			if(c[n].a!=-1&&abs(c[n].a-c[n].b)!=2){
				printf("0\n");
				continue;
			}
			if(c[n-1].a!=-1&&c[n-1].a!=n/2-1){
				printf("0\n");
				continue;
			}
			if(c[n-2].a!=-1&&c[n-2].a!=n/2-1){
				printf("0\n");
				continue;
			}
			c[n].a=n/2-1; c[n].b=n/2+1;
			c[n-1].a=c[n].a; c[n-1].b=c[n].b-1;
			c[n-2].a=c[n-1].a; c[n-2].b=c[n-1].b-1;
			if(c[n-2].a>10){
				bool f=1;
				for(int i=n-4;;i-=2){
					if(c[i].a!=-1&&c[i].a!=c[i+2].a-1){
						f=0; break;
					}
					c[i].a=c[i].b=c[i+2].a-1;
					if(c[i].a==10) break;
				}
				if(!f){
					printf("0\n");
					continue;
				}
			}
		}
		else{
			if(n==21||n<11){
				printf("0\n");
				continue;
			}
			if(c[n].a!=-1&&c[n].a!=11&&c[n].b!=11){
				printf("0\n");
				continue;
			}
			c[n].b=11; c[n].a=n-11;
			if(c[n-1].a!=-1&&c[n-1].b!=10){
				printf("0\n");
				continue;
			}
			c[n-1].a=c[n].a; c[n-1].b=10;
		}
		ans=1; f=1;
		for(int i=0;i<=n;i++)
			if(c[i].a!=-1) s[++tp]=i;
		for(int i=2;i<=tp;i++){
			cl=c[s[i-1]]; cr=c[s[i]];
			if(cl.a>cr.a||cl.b>cr.b){
				f=0;
				break;
			}
			tmp=C(s[i]-s[i-1],cr.a-cl.a);
			if(cr.a>=cl.b&&cr.a!=cr.b) tmp=(tmp+C(s[i]-s[i-1],cr.a-cl.b))%Md;
			ans=ans*tmp%Md;
		}
		if(!f) printf("0\n");
		else printf("%lld\n",ans);
	}
	return 0;
}
```

---


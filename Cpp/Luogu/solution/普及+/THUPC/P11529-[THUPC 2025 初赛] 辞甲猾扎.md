# [THUPC 2025 初赛] 辞甲猾扎

## 题目描述

给你一棵 $n$ 个点的无根树，有 $k$ 个点初始为黑色，其余点初始为灰色，你可以在一开始将一些**灰色**点染成白色。染完后，现在进行如下操作，直到树上不存在灰色点。    

每一轮对所有灰色点**同时**进行如下操作：

1. 检查与该灰色点 $u$ 直接相连的点有没有黑色或白色点，如果没有，则 $u$ 保持灰色。
2. 如果与 $u$ 直接相连的点有白色点，则 $u$ 变为白色。
3. 如果与 $u$ 直接相连的点有黑色点，则 $u$ 变为黑色。

这个顺序说明同时与白色和黑色相邻时会被染成白色。  

注意此处对所有灰色点同时进行操作，也就是说在这一轮被染上颜色的点不能作为其它点改变颜色的根据。  

现在求一开始最少染几个点为白色，可以使树最终黑色点不超过 $k$ 个。

## 说明/提示

- 对于第一组样例，一开始将 $2$ 号点染白即可
- 对于第二组样例，一开始将 $3,4,9$ 号点染白为满足条件且数量最小一组方案

#### 题目来源

来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。

题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。

## 样例 #1

### 输入

```
5 2
3 5
1 2
1 3
2 4
2 5```

### 输出

```
1```

## 样例 #2

### 输入

```
10 3
1 6 8
1 2
2 3
3 4
4 5
4 6
5 7
5 8
6 9
7 10```

### 输出

```
3```

# 题解

## 作者：lichenxi111 (赞：6)

## 前言

没场切的题。

THUPC 2024 对队伍的贡献为 $0$ ！！！

## 思路

看完题面，可以想到[保安站岗](https://www.luogu.com.cn/problem/P2458)这道题，但我们照样设计状态有点问题，对于本题，有一些点是不与黑点相邻的，他们的邻点****可以****没有白色，注意，是可以，不是一定邻点没有白色。

设计状态：设 $dp_{0/1/2/3}$ 为自己染白/需要儿子染白/需要父亲染白/不需要儿子也不需要父亲染白。

转移方程：

$$dp_{x,0} = dp_{x,0} + \min\{dp_{i,0},dp_{i,1},dp_{i,2},dp_{i,3}\}$$。

自己染白了儿子可以随便选。

$$dp_{x,1} = \min\{dp_{x,1} + \min\{dp_{i,0},dp_{i,1},dp_{i,3}\},dp_{x,3} + dp_{i,0}\}$$。

如果自己还没有儿子染白，那么需要儿子染白，否则儿子只需要不用自己染白，其他随便选。

$$dp_{x,2} = dp_{x,2} + \min\{dp_{i,1},dp_{i,3}\}$$。

只有儿子不需要自己的帮助时，自己可以求助父亲的父亲。如果儿子染白，但自己仍求助父亲，那一定是不优于 $dp_{x,1}$ 的。

$$dp_{x,3} = dp_{x,3} + \min\{dp_{i,0},dp_{i,1},dp_{i,3}\}$$。

只需要儿子不求助自己。

注意，$dp_{x,0/1/2}$ 需要当前节点不为黑，$dp_{x,3}$ 需要对所有节点转移。

如果当前节点为灰点且与黑点相邻，那么他的邻点需要白色，那么 $dp_{x,3} = \inf$。

初始化：如果当前节点为黑，那么 $dp_{x,0/1/2} = \inf$。否则，$dp_{x,0} = 1,dp_{x,1} = \inf$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read()
{
	char c;
	int num = 0,f = 1;
	c = getchar();
	while(c < '0' || '9' < c)
	{
		if(c == '-')
		{
			f = -1;
		}
		c = getchar();
	}
	while('0' <= c && c <= '9')
	{
		num = num * 10 + (c - '0');
		c = getchar();
	}
	return num * f;
}
bool f[1000005],ff[1000005];
vector<int> v[1000005];
int dp[1000005][4];
void dfs(int x,int fa)
{
	if(f[x])
	{
		dp[x][0] = 2e9;
		dp[x][1] = 2e9;
		dp[x][2] = 2e9;
	}
	else
	{
		dp[x][0] = 1;
		dp[x][1] = 2e9;
	}
	for(auto i : v[x])
	{
		if(i == fa)
		{
			continue;
		}
		dfs(i,x);
		if(!f[x])
		{
			dp[x][0] += min({dp[i][0],dp[i][1],dp[i][2],dp[i][3]});
			dp[x][1] = min(dp[x][3] + dp[i][0],dp[x][1] + min({dp[i][0],dp[i][1],dp[i][3]}));
			dp[x][2] += min({dp[i][1],dp[i][3]});
		}
		dp[x][3] += min({dp[i][0],dp[i][1],dp[i][3]});
	}
	if(!f[x] && ff[x])
	{
		dp[x][3] = 2e9;
	}
}
signed main()
{
	int n,k;
	n = read(),k = read();
	for(int i = 1;i <= k;i++)
	{
		int x;
		x = read();
		f[x] = 1;
	}
	for(int i = 1;i < n;i++)
	{
		int x,y;
		x = read(),y = read();
		v[x].push_back(y);
		v[y].push_back(x);
	}
	for(int i = 1;i <= n;i++)
	{
		if(f[i])
		{
			for(auto j : v[i])
			{
				ff[j] = 1;
			}
		}
	}
	dfs(1,0);
	cout << min({dp[1][0],dp[1][1],dp[1][3]});
	return 0;
}
```

---

## 作者：abruce (赞：6)

出题人题解。题目名来源：名字竞技场 辞甲猾扎@昀澤。  
考虑最终黑点只有 $k$ 个，于是黑点不能拓展，即每个与黑点相邻的灰点要么自身染白，要么与其相邻的点至少染一个白。  
考虑树形 dp，对于黑点不考虑，对于白点，定义 $f_{u,0/1/2/3}$ 分别为点 $u$ 自己染白/儿子染白/需要祖先染白/自己和儿子没有染，也不需要祖先染（显然其不能和黑点相邻），转移如下：  
$f_{u,0}=f_{u,0}+\min\{f_{v,0},f_{v,1},f_{v,2},f_{v,3}\}$（自己染白儿子随便）。  
$f_{u,1}=\min\{f_{u,1}+\min\{f_{v,0},f_{v,1},f_{v,3}\},f_{u,3}+f_{v,0}\}$（之前的儿子已染白这个只用不是要求祖先染白即可，否则需要这个儿子染白）。  
$f_{u,2}=f_{u,2}+\min\{f_{v,1}+f_{v,3}\}$（类似，但是儿子如果染白前一种情况一定更优）。  
$f_{u,3}$ 类似，注意一些初始情况以及可能导致的爆 int 即可。  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int read() {
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
namespace tokido_saya {
	const int maxn=1e6+5;
	struct edge
	{
		int next,to;
	}e[maxn*2];
	int h[maxn],cnt,f[maxn][4],n,k,b[maxn],nr[maxn],ans;
	void addedge(int x,int y)
	{
		e[++cnt].next=h[x],e[cnt].to=y,h[x]=cnt;
	}
	void dfs(int u,int fa)
	{
		if(b[u])f[u][0]=f[u][1]=f[u][2]=1e9;
		else f[u][0]=1,f[u][1]=1e9;
		for(int i=h[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(v==fa)continue;
			dfs(v,u);
			if(!b[u])f[u][0]+=min(min(f[v][0],f[v][1]),min(f[v][2],f[v][3])),f[u][0]=min(f[u][0],(int)1e9);
			if(!b[u])f[u][1]=min(f[u][3]+f[v][0],f[u][1]+min(min(f[v][0],f[v][1]),f[v][3])),f[u][1]=min(f[u][1],(int)1e9);
			if(!b[u])f[u][2]+=min(f[v][1],f[v][3]),f[u][2]=min(f[u][2],(int)1e9);
			f[u][3]+=min(min(f[v][0],f[v][1]),f[v][3]),f[u][3]=min(f[u][3],(int)1e9);
		}
		if(nr[u]&&!b[u])f[u][3]=1e9;
	}
	int main() {
		int x,y;
		n=read(),k=read();
		for(int i=1;i<=k;i++)x=read(),b[x]=1;
		for(int i=1;i<n;i++)
		{
			x=read(),y=read();
			addedge(x,y),addedge(y,x);
		}
		for(int u=1;u<=n;u++)
			if(b[u])for(int i=h[u];i;i=e[i].next)
			{
				int v=e[i].to;
				nr[v]=1;
			}
		dfs(1,0);
		printf("%d",min(min(f[1][0],f[1][1]),f[1][3]));
		return 0;
	}
}
int main() {
	return tokido_saya::main();
}

```

---

## 作者：happy_zero (赞：5)

稍微转换一下题目，由于所有灰点都不被变成黑色，所以等价于与黑色相邻的点最后都是白色（相邻都被变成后白色黑色就“扩散”不出去了），也就是其要么本身为白色，要么其还和一个白点相邻。

原图是一棵树，考虑树形 dp。稍微分讨一下可以得出一下定义：

- $f_{i,0}$ 表示 $i$ 是灰点，不需要与白色相邻，其子树内最少要染白的个数
- $f_{i,1}$ 表示 $i$ 是灰点，需要与白色相邻且已与白色相邻，其子树内最少要染白的个数
- $f_{i,2}$ 表示 $i$ 是灰点，需要与白色相邻且未与白色相邻，其子树内最少要染白的个数
- $f_{i,3}$ 表示 $i$ 是白点，其子树内最少要染白的个数
- $f_{i,4}$ 表示 $i$ 是黑点，其子树内最少要染白的个数


设当前有 $f_j$ 向 $f_i$ 转移（$j\in son_i$），分三种情况：

1. $i$ 是黑点：
   - $f_{i,0/1/2/3}=+\infty$
   - $f_{i,4}=\sum \min(f_{j,1},f_{j,3},f_{j,4})$（$f_{j,0}$ 不存在，$f_{j,2}$ 的 $j$ 不满足条件）
2. $i$ 是灰点且未与黑点相邻：
   - $f_{i,1/2/4}=+\infty$
   - $f_{i,0}=\sum \min(f_{j, 0},f_{j,1},f_{j,3})$（$f_{j,4}$ 不存在，$f_{j,2}$ 的 $j$ 不满足条件）
   - $f_{i,3}=\sum \min(f_{j, 0},f_{j,1},f_{j,2},f_{j,3})$（除了 $f_{j,4}$ 不存在其它随便转）
3. $i$ 是灰点且与黑点相邻：
   - $f_{i,0/4}=+\infty$
   - $f_{i,2}=\sum \min(f_{j, 0},f_{j,1},f_{j,4})$（$f_{j,2}$ 的 $j$ 不满足条件，$f_{j,3}$ 的 $i$ 矛盾）
   - $f_{i,3}=\sum \min(f_{j, 0},f_{j,1},f_{j,2},f_{j,3},f_{j,4})$（这个真没任何限制了）
   - $f_{i,1}$ 先对于每个子树求随便染（$w_j=\min(f_{j, 0},f_{j,1},f_{j,3},f_{j,4}$）的方案数和，然后选其中染白代价（$f_{j,3}-w_j$）最小的一个换成 $f_{j,3}$


答案即为 $\min(f_{rt, 0}, f_{rt, 1}, f_{rt, 3}, f_{rt, 4})$。

感觉做得有些复杂了，不过状态定义清楚了就很好做了 ~~（但不好说是谁想状态想了 2h 吃了三发罚时）~~。所以为什么这题过得比 I 和 D 还多啊。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5;
const int INF = 1e9;
bool vis[N], f1[N];
int f[N][5];
vector <int> p[N];
void dfs(int k, int fa) {
	f[k][3] = 1; 
	for (auto i : p[k])
		if (i != fa) dfs(i, k);
	if (vis[k]) {
		f[k][0] = f[k][1] = f[k][2] = f[k][3] = INF;
		for (auto i : p[k])
			if (i != fa)
				f[k][4] += min({f[i][1], f[i][3], f[i][4]});
	} else if (!f1[k]) {
		f[k][1] = f[k][2] = f[k][4] = INF; 
		for (auto i : p[k]) {
			if (i == fa) continue;
			f[k][0] += min({f[i][0], f[i][1], f[i][3]});
			f[k][3] += min({f[i][0], f[i][1], f[i][2], f[i][3]}); 
		}
	} else {
		f[k][0] = f[k][4] = INF; int t = INF; 
		for (auto i : p[k]) {
			if (i == fa) continue;
			f[k][2] += min({f[i][0], f[i][1], f[i][4]});
			f[k][3] += min({f[i][0], f[i][1], f[i][2], f[i][3], f[i][4]});
			int w = min({f[i][0], f[i][1], f[i][3], f[i][4]});
			if (!vis[i]) t = min(t, f[i][3] - w); f[k][1] += w; 
		}
		f[k][1] += t; 
	}
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, k; cin >> n >> k;
	for (int i = 1, x; i <= k; i++) 
		cin >> x, vis[x] = true;
	for (int i = 1, u, v; i < n; i++) {
		cin >> u >> v;
		p[u].push_back(v);
		p[v].push_back(u); 
		f1[u] |= vis[v], f1[v] |= vis[u];
	}
	dfs(1, 0); cout << min({f[1][0], f[1][1], f[1][3], f[1][4]});
	return 0;
}
```

---

## 作者：cwxcplh (赞：0)

~~一道一点都不简单的绿题……~~

**题目简化：** 在一颗树上有 $n$ 个点，初始给你 $k$ 个黑色点，剩余的全是灰色点，灰色点的变色方式如下：

1. 如果其父节点与子节点中有白色，则先变为白色。
2. 如果其父节点与子节点中没有白色但有黑色，则变成黑色。
3. 如果上面两项都没有，则不变色。

请问最开始最少需要染几个灰色点为白色，才能使得所有灰色点最终都会变成白色。

# 解析

这道题其实看一眼就知道是树形 DP，关键在于怎么去设置这个状态和状态转移方程。

首先我们能肯定的是这个 DP 肯定要先设置成 $dp_u$，表示搜寻到每个节点时染白的个数。

其实题目中最重要的信息是第一条规则：如果其父节点与子节点中有白色，则先变为白色。

这说明了什么？这说明我们的第二维应该讨论当前的点、它的儿子节点、它的父亲节点是否被染白，那么我们的 DP 可以设置成 $dp_{u,0/1/2/3}$，表示让当前节点染白/让其子节点染白/让其父节点染白/它、其子节点、其父节点都不变的最少染白的节点数。

那么我们就可以开始写状态转移方程了。

不过在此之前，我们需要先初始化。

对于当前节点讨论：当前节点为黑色还是灰色。

**如果是黑色：** $dp_{u,0}=dp_{u,1}=dp_{u,2}=+\infty$，原因：当前节点为黑色，那么就肯定不可能染白了，所以 $dp_{u,0}=+\infty$，而其子节点或父节点染白了又不会让它变白，再说了你也不知道你的父节点和子节点是黑色还是灰色，如果是灰色它们会自己纠正的，所以 $dp_{u,1}=dp_{u,2}=+\infty$，而它们三个都不然白的个数就是 $0$，所以就不需要初始化 $dp_{u,3}$ 了。

**如果是灰色：** $dp_{u,0}=1,dp_{u,1}=+\infty$，原因：当前节点为灰色，那么就把当前节点给染成白色，而这需要的次数正好是一次。

有人会问：为什么要染当前节点而不是子节点呢？首先，你不知道子节点是灰色还是黑色，莫名其妙就给染个颜色很容易出错。其次，如果子节点是灰色循环到子节点的时候它也会自己改正过来的。所以就直接赋了个 $+\infty$，而它的父节点就不需要变白了，所以 $dp_{u,2}=0$。

然后我们就可以开始写状态转移方程了。因为这个 DP 只算灰色变色的情况，所以直接忽略黑色，于是状态转移方程如下（$v$ 表示 $u$ 的子节点）：

$$\begin{cases}dp_{u,0}=dp_{u,0}+\min\{dp_{v,0},dp_{v,1},dp_{v,2},dp_{v,3},+\infty\}\\dp_{u,1}=\min\{dp_{u,3}+dp_{v,0},dp_{u,1}+\min\{dp_{v,0},dp_{v,1},dp_{v,3}\},+\infty\}\\dp_{u,2}=dp_{u,2}+\min\{dp_{v,1},dp_{v,3},+\infty\}\\dp_{u,3}=dp_{u,3}+\min\{dp_{v,0},dp_{v,1},dp_{v,3},+\infty\}\end{cases}$$

特别提醒：$dp_{u,3}$ 是不受节点颜色限制的，即如果当前节点为黑色，同样要写 $dp_{u,3}$ 的状态转移方程。

最后注意一点：如果当前节点为灰色，但与之连边的点中有黑色，那么当前节点就不能“摆烂”了，所以 $dp_{u,3}=+\infty$。

[提交记录，完美 AC。](https://www.luogu.com.cn/record/212903278)

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
#define INF (int)(0x3f3f3f3f)
namespace io
{
    using namespace std;
    int kd()
    {
        int z=0,f=1;
        char c=getchar();
        while(c<'0'||c>'9')
        {
            if(c=='-')
            {
                f=-1;
            }
            c=getchar();
        }
        while(c>='0'&&c<='9')
        {
            z=z*10+c-'0';
            c=getchar();
        }
        return z*f;
    }
    void ks(int x,int k)
    {
        if(x<0)
        {
            putchar('-');
            ks(-x,k+1);
            return;
        }
        if(x==0)
        {
            if(k==0)
            {
                putchar('0');
            }
            return;
        }
        ks(x/10,k+1);
        putchar(char(x%10+'0'));
    }
}
using namespace io;//注意快读
int n,k,b[1000006],bb[1000006],dp[1000006][6];
vector<int>v[1000006];
void dfs(int x,int fa)
{
    if(b[x])
    {
        dp[x][0]=dp[x][1]=dp[x][2]=INF;
    }
    else
    {
        dp[x][0]=1,dp[x][1]=INF;
    }
    for(auto i:v[x])
    {
        if(i==fa)
        {
            continue;
        }
        dfs(i,x);
        if(!b[x])
        {
            dp[x][0]=min(dp[x][0]+min({dp[i][0],dp[i][1],dp[i][2],dp[i][3]}),INF);
            dp[x][1]+=min({dp[i][0],dp[i][1],dp[i][3]});
            dp[x][1]=min({dp[x][1],dp[x][3]+dp[i][0],INF});
            dp[x][2]=min(dp[x][2]+min({dp[i][1],dp[i][3]}),INF);
        }
        dp[x][3]=min(dp[x][3]+min({dp[i][0],dp[i][1],dp[i][3]}),INF);
    }
    if(!b[x]&&bb[x])
    {
        dp[x][3]=INF;
    }
}
signed main()
{
    n=kd(),k=kd();
    for(int u,i=1;i<=k;i++)
    {
        u=kd();
        b[u]=1;
    }
    for(int x,y,i=1;i<n;i++)
    {
        x=kd(),y=kd();
        v[x].emplace_back(y);
        v[y].emplace_back(x);
    }
    for(int i=1;i<=n;i++)
    {
        if(b[i])
        {
            for(auto j:v[i])
            {
                bb[j]=1;
            }
        }
    }
    dfs(1,0);
    ks(min({dp[1][0],dp[1][1],dp[1][3]}),0);
    return 0;
}
```

---

## 作者：IGpig (赞：0)

## P11529

### Solution

题意已经给的很清楚了，稍微推一下就可以发现这题是一个树上动态规划，考虑状态 $f_{i,j}$ 表示在第 $i$ 个节点状态为 $j$ 的情况下**子树内**需要染白的个数，因为只要染一定数量的白色，那么黑色的数量就可以被限制住，也就是不能改变其他的点变成黑色。

考虑状态，灰色的点有三种情况：

- 不会被黑色染，也就是不用白色相邻，$j=0$。

- 需要白色的保护，是否与白色相邻，$j=1/2$。

  

而如果是白色或者黑色的，就不需要讨论，$j=3/4$。

现在考虑转移，最好想的是黑色的点，只用考虑 $f_{i,4}=\sum \min(f_{j,1},f_{j,3},f_{j,4})$，因为可以是不用或者已经与白色相邻的灰点，白点，或者黑点。

然后就是白点，不用管，$f_{i,3}=1$，因为子树是不会被影响到的，即黑色无法向下传递。

灰点我们在定义的时候考虑了白点，但是我们还要考虑与黑色相邻的情况。

---



与黑点相邻时，必须与白点相邻，所以 $f_{i,0/4}$ 不用考虑。然后就是 $f_{i,0}$ 这个地方~~我原来用了一种复杂的方法实现，后来在题解中~~找到了一个简单的做法，如下：

~~~cpp
for(auto i : g[x]){//遍历儿子
	if(i!=fa){
		LL mn=min(f[i][0],min(f[i][1],min(f[i][3],f[i][4])));//找到所有情况里最小的
		f[x][1]+=mn;//加上去
		if(!vis[i]){//如果是黑点
			tmp=min(tmp,f[i][3]-mn);//最小的一个差
		}
	}
}
f[x][1]+=tmp;//补上
~~~

那么这样的原理是有一个儿子我们必须要选到 $f_{j,3}$ 但是不知道是哪一个，就先加上 $mn$，然后记录一下最小的 $f_{j,3}-mn$，最后把这个最小的再补上去，就是最小的答案。

然后是 $f_{i,2}=\sum \min(f_{i,0},f_{i,1},f_{i,4})$，不选 $f_{i,3}$ 是因为本来定义就不能和白点相邻，$f_{i,2}$ 是因为已经和黑点相邻了，不能不和白点相邻。$f_{i,3}$ 就是所有最小值的和，因为自己就是白点，不用考虑儿子的颜色。

---



现在如果这个点是灰色且不与黑色相邻，那么它也不需要与白色相邻，所以 $f_{i,0}=\sum \min(f_{j,0},f_{j,1},f_{j,3})$，不与黑色相邻就不需要考虑儿子是黑点，儿子是灰点也不需要与白色相邻。如果本来就是白点，那么 $f_{i,3}=\sum \min(f_{j,0},f_{i,2},f_{j,1},f_{j,3})$，只需要满足不与黑色相邻的条件就好了。

答案即为根的最小值。

以上难免有思维不严谨的地方，见谅。

### Code

~~~cpp
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
const LL inf=1e12;
LL n,k,f[1000005][5];
vector<LL> g[1000005];
bool vis[1000005],flag[1000005];
void dfs(LL x,LL fa){
    f[x][3]=1;
    for(auto i : g[x]){
      	if(i!=fa) dfs(i,x);
    }
    if(vis[x]){
      	f[x][0]=f[x][1]=f[x][2]=f[x][3]=inf;
      	for(auto i : g[x]){
        if(i!=fa) f[x][4]+=min(f[i][1],min(f[i][3],f[i][4]));
      }
    }else if(flag[x]){
		f[x][0]=f[x][4]=inf;
		LL tmp=inf;
		for(auto i : g[x]){
			if(i!=fa){
				f[x][2]+=min(f[i][0],min(f[i][1],f[i][4]));
				f[x][3]+=min({f[i][0],min(f[i][1],f[i][4]),min(f[i][2],f[i][3])});
				LL mn=min(f[i][0],min(f[i][1],min(f[i][3],f[i][4])));
				f[x][1]+=mn;
				if(!vis[i]){
					tmp=min(tmp,f[i][3]-mn);
				}
			}
		}
		f[x][1]+=tmp;
    }else{
		f[x][1]=f[x][2]=f[x][4]=inf;
		for(auto i : g[x]){
			if(i!=fa){
				f[x][0]+=min(f[i][0],min(f[i][1],f[i][3]));
				f[x][3]+=min(f[i][0],min(f[i][1],min(f[i][3],f[i][2])));
			}
		}
		
	}
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    cin>>n>>k;
    for(int i=1,x;i<=k;i++){
        cin>>x;vis[x]=1;
    }
    for(int u,v,i=1;i<n;i++){
        cin>>u>>v;
        g[u].push_back(v);g[v].push_back(u);
        flag[u]|=vis[v];flag[v]|=vis[u];
    }
    dfs(1,0);
	cout<<min(f[1][0],min(f[1][1],min(f[1][3],f[1][4])));
	return 0;
}

~~~

---


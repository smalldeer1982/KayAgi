# [THUPC 2025 决赛] 排列与质数

## 题目描述

给定正整数 $n$，构造一个 $1$ 至 $n$ 的排列 $p_1,p_2,\dots,p_n$ 满足以下条件：

对于 $1 \le i \le n$，设 $c_i = \lceil \frac{p_1+p_2+\dots +p_i}{i} \rceil$，则在 $c_1,c_2,\dots,c_n$ 中至少有 $\lfloor \frac{n}{3} \rfloor - 1$ 个质数。

## 说明/提示

### 样例 #1 解释

对于第一组测试数据，我们有 $c_1 = \lceil \frac{2}{1} \rceil = 2$ 和 $c_2 = \lceil \frac{2+1}{2} \rceil = 2$。两个都是质数。

对于第二组测试数据，$c_1 = c_2 = c_3 = 2$。


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。

## 样例 #1

### 输入

```
2
2
3
```

### 输出

```
2 1
2 1 3
```

# 题解

## 作者：tallnut (赞：4)

我太菜了，一道绿题想不出来。还是 @zhikang 大神教我的。~~虽然他也看了官方题解。~~

首先锐评一下，这个构造题完全不同于正常的和出题人对脑电波的题，完全是个数学题，知道定理就一定会做，反之一定不会做。并且这个质数个数误导性也很强，差评。
# 思路
引理：**[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)**：对于任意 $n\ge 2$ 且 $n$ 为正整数，在 $(n,n\times 2)$ 中必至少存在一个质数。

那么先把 $n\le 5$ 判掉，这个随便输出就行。令 $k=\lfloor\dfrac{n}{3}\rfloor$，根据定理，在 $(k,k\times 2)$ 中必存在一个质数，令该质数 $=x$。按照如下方式构造：
$$p=x,x-1,x+1,x-2,x+2,\dots,x-m,x+m$$
直到 $x-m\le 0$ 或 $x+m>n$ 为止。显然这些项全部 $=x$，为质数。剩下的项乱填。

因此此题结论可以加强成 $c_i$ 中至少存在 $2\times\lfloor\dfrac{n}{3}\rfloor$ 个质数。
# 代码
代码实现非常简单。[AC 记录](https://www.luogu.com.cn/record/212626494)。

```cpp
// NOTE: "[EDIT]" means you should edit this part by yourself
#include <bits/stdc++.h>
#define MULTITEST
using namespace std;
typedef long long ll;
#define rep1(i,x,y) for (int i = (x);i <= (y);i++)
#define rep2(i,x,y) for (int i = (x);i >= (y);i--)
#define rep3(i,x,y,z) for (int i = (x);i <= (y);i += (z))
#define rep4(i,x,y,z) for (int i = (x);i >= (y);i -= (z))
#define cl(a) memset(a,0,sizeof(a))
const int N = 1e5 + 10;
int n,cnt,k,pos;
bool visited[N];
int ans[N];
bool prime(int x)
{
	for (int i = 2;i * i <= x;i++)
		if (x % i == 0)
			return false;
	return true;
}
void solve()
{
    cin >> n;
    if (n <= 5)
    {
    	rep1(i,1,n)
    		cout << i << ' ';
    	cout << '\n';
    	return;
	}
    k = n / 3;
    cl(visited);
    rep1(i,k,k * 2)
    {
    	if (prime(i))
    	{
    		pos = i;
    		break;
		}
	}
	cnt = 0;
	ans[++cnt] = pos;
	visited[pos] = true;
	rep1(i,1,min(pos - 1,n - pos))
	{
		ans[++cnt] = pos - i;
		ans[++cnt] = pos + i;
		visited[pos - i] = true;
		visited[pos + i] = true;
	}
	rep1(i,1,n)
		if (!visited[i])
			ans[++cnt] = i;
	rep1(i,1,n)
		cout << ans[i] << ' ';
	cout << '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t;
#ifdef MULTITEST
    cin >> t;
#else
    t = 1;
#endif
    while (t--)
        solve();
}
```

---

## 作者：_lone10124_ (赞：1)

构造题，可以把 $c_i$ 的前缀都变为一个相同的质数 $p$。

可以进行如下构造 $p$，$p-1$，$p+1$，$p-2$，$p+2$ 等。

质数 $p$ 可以先预处理，后暴力枚举，可 $O(1)$ 算出 $c_i$ 中包含 $p$ 的数量。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int t,n,p[N],cnt;
bool jl[N];
bool pd(int x)
{
	for(int i=2;i<=sqrt(x);i++) if(x%i==0) return 0;
	return 1;
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	for(int i=2;i<=100000;i++) if(pd(i)) p[++cnt]=i;
	cin>>t;
	while(t--)
	{
		int zs;
		memset(jl,0,sizeof(jl));
		cin>>n;
		for(int i=1;i<=cnt;i++)
		{
			int zj=n-p[i],js=p[i]-1;
			int hh=min(zj,js);
			int zg=1+hh*2;
			if(zg>=n/3-1)
			{
				zs=p[i];
				break;
			}
		}
		cout<<zs<<" ";
		jl[zs]=1;
		for(int i=1;;i++)
		{
			int q=zs+i,w=zs-i;
			if(q<=n&&w>0)
			{
				cout<<w<<" "<<q<<" ";
				jl[q]=jl[w]=1;
			}
			else break;
		}
		for(int i=1;i<=n;i++) if(!jl[i]) cout<<i<<" ";
		cout<<"\n";
	}
	return 0;
}
```

---


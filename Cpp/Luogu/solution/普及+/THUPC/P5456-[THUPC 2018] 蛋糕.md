# [THUPC 2018] 蛋糕

## 题目描述

最近，菲菲学会了做蛋糕，她做了一个 **4D** 的蛋糕送给牛牛，这个蛋糕的大小是： $a \times b \times c \times d$。

蛋糕所有的表面都抹着奶油，牛牛想把蛋糕沿着与表面平行的超平面，切成 $1 \times 1 \times 1 \times 1$ 的小块。

现在，牛牛想知道，在这些小块蛋糕中，有 $0$ 个、$1$ 个、$2$ 个……$8$ 个表面抹着奶油的有分别有多少块。

## 说明/提示

### 样例解释

对于第一组数据，把 $2 \times 2 \times 2 \times 3$ 的蛋糕切成小块后，共形成了 $24$ 个小立方体，其中有 $16$ 个小块分别与其他 $4$ 个小块相邻，因此它们有 $4$ 个面涂有奶油，而另外 $8$ 个小块分别与其他 $5$ 个小块相邻，因此它们有 $3$ 个面涂有奶油。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
5
2 2 2 3
7 7 8 8
9 9 9 9
3 3 5 6
9 7 5 2```

### 输出

```
0 0 0 8 16 0 0 0 0
900 1320 724 176 16 0 0 0 0
2401 2744 1176 224 16 0 0 0 0
12 62 108 72 16 0 0 0 0
0 210 284 120 16 0 0 0 0```

# 题解

## 作者：HenryHuang (赞：15)

**P5456 「THUPC2018」蛋糕 题解**

这个题目退化成三维就是我们小学时经常做的题目，应该都可以背结论了

我们先从三维开始嘶烤，设三维空间的大小为 $a*b*c$

如果涂了0面，就相当于三个方向上都没有碰到边界，答案为 $(a-2)*(b-2)*(c-2)$

如果涂了1面，就相当于有一个方向碰到了边界，答案为 $2*((a-2)*(b-2)+(b-2)*(c-2)+(a-2)*(c-2))$

如果涂了2面，就相当于有两个方向碰到了边界

如果涂了3面，就相当于有三个方向碰到了边界

以此类推，四维也挺好做的，直接DFS即可

贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=2148473648;
ll f[10],a[10];
void dfs(ll now,ll tot,ll num){
	if(now==5){
		f[tot]=(f[tot]+num)%mod;//枚举完毕 
		return ;
	}
	if(a[now]==1){
		dfs(now+1,tot+2,num);
		return ;
	}//如果是1特殊处理 
	dfs(now+1,tot+1,(num+num)%mod);//不选 
	dfs(now+1,tot,(num*(a[now]-2))%mod);//选 
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		memset(f,0,sizeof f);
		for(int i=1;i<=4;++i) scanf("%lld",&a[i]);
		dfs(1,0,1);
		for(int i=0;i<=8;++i)
			printf("%lld ",f[i]);
		printf("\n");
	}
}
```



---

## 作者：莫奈的崖径 (赞：13)

一开始做这道题的时候有点懵，在网上能找到的题解几乎都是$dfs$，蒟蒻不太懂这种做法，于是摸索半天推了个规律。

这道题放在了组合计数专题的例题中，开始的时候其实我没感觉这道题跟组合数有多大关系，后来想想，如果把四维换成$n$维，就是标准的组合计数了。


------------


## 分析
这道题求的是四维的情况，直接做似乎不可行？不妨先考虑三维的情况，那么这道题就退化成了一个小学数学题：有一个由$1*1*1$的小立方体构成的$a*b*c$的大立方体，给这个大立方体的表面涂上颜色，求被涂了$0,1,2,3,4$面的小立方体各有多少个。

Ⅰ.考虑$a,b,c$都$>=2$的情况（三维物体中$0$个维度为$1$），那么就不存在被涂了$4$面的小正方体，用$ans[i]$表示被涂了$i$面的小立方体数量，那么三维规律即为:
 
$ans[0]=(a-2)*(b-2)*(c-2)$

$ans[1]=2*((a-2)*(b-2)+(a-2)*(c-2)+(b-2)*(c-2))$

$ans[2]=4*((a-2)*(b-2)*(c-2))$

$ans[3]=8$

其余皆为$0$。

Ⅱ.如果$a,b,c$中就有那么个不开眼的为$1$呢（三维物体中$1$个维度为$1$）？假设$c=1$，那么规律即为:

$ans[2]=(a-2)*(b-2)$

$ans[3]=2*(a+b-4)$

$ans[4]=4$

其余皆为$0$。

Ⅲ.如果$a,b,c$中有两个不开眼的为$1$呢（三维物体中$2$个维度为$1$）？我们假设$b=c=1$，那么规律即为：

$ans[4]=a-2$

$ans[5]=2$

其余皆为$0$。

Ⅳ.如果$a,b,c$皆为$0$呢（三维物体中有$3$个维度为$1$）？

$ans[6]=1$

其余皆为$0$。

**以上我们推出了三维物体的全部规律。**

那么四维怎么办呢？仍然按照有$0,1,2,3,4$个维度为$1$来分类讨论。

先$define$一波。

```cpp
#define A (a-2)%mod
#define B (b-2)%mod
#define C (c-2)%mod
#define D (d-2)%mod
```


Ⅰ.四维物体有$0$个维度为$1$

```cpp
ans[0]=A*B*C*D;
ans[1]=2*(A*B*C+A*B*D+A*C*D+B*C*D)%mod;
ans[2]=4*(A*B+A*C+A*D+B*C+B*D+C*D)%mod;
ans[3]=8*(A+B+C+D)%mod;
ans[4]=16;
```
Ⅱ.四维物体有$1$个维度为$1$，相当于三维物体有$0$个维度为$1$，那么可以进行规律转换，只不过要注意，**$ans[i]$的下标要加上$2$**，因为我们增加了一维。

```cpp
ans[2]=A*B*C%mod;
ans[3]=2*(A*B+A*C+B*C)%mod;
ans[4]=4*(A+B+C)%mod;
ans[5]=8;
```
Ⅲ.四维物体有$2$个维度为$1$，相当于三维物体有$1$个维度为$1$

```
ans[4]=(a-2)*(b-2)%mod;
ans[5]=2*(a+b-4)%mod;
ans[6]=4;
```
Ⅳ.四维物体有$3$个维度为$1$，相当于三维物体有$2$个维度为$1$

```cpp
ans[6]=(a%mod-2%mod)%mod;
ans[7]=2;
```
Ⅴ.四维物体有$4$个维度为$1$，相当于三维物体有$3$个维度为$1$

```cpp
ans[8]=1;
```
直到这里，我们就推导出了完整的规律。

本质上跟$dfs$差不多...

## AC代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long 
const int mod=2148473648;
#define A (a-2)%mod
#define B (b-2)%mod
#define C (c-2)%mod
#define D (d-2)%mod
int ans[9],a,b,c,d,cnt,f[5];
signed main()
{
//	freopen("data.in","r",stdin);
//	freopen("my.out","w",stdout);
	int T;
	scanf("%lld",&T);
	while(T--)
	{
		memset(ans,0,sizeof ans);
		memset(f,0,sizeof f);
		cnt=0;
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		if(a!=1)f[++cnt]=a;
		if(b!=1)f[++cnt]=b;
		if(c!=1)f[++cnt]=c;
		if(d!=1)f[++cnt]=d;
		if(cnt==4)
		{
			ans[0]=A*B*C*D;
			ans[1]=2*(A*B*C+A*B*D+A*C*D+B*C*D)%mod;
			ans[2]=4*(A*B+A*C+A*D+B*C+B*D+C*D)%mod;
			ans[3]=8*(A+B+C+D)%mod;
			ans[4]=16;
			for(int i=0;i<=8;i++)
			printf("%lld ",ans[i]);		
			continue;	
		}
		if(cnt==3)
		{
			a=f[1],b=f[2],c=f[3];
			ans[2]=A*B*C%mod;
			ans[3]=2*(A*B+A*C+B*C)%mod;
			ans[4]=4*(A+B+C)%mod;
			ans[5]=8;
			for(int i=0;i<=8;i++)
			printf("%lld ",ans[i]);
			continue;	
		}
		if(cnt==2)
		{
			a=f[1],b=f[2];
			ans[4]=(a-2)*(b-2)%mod;
			ans[5]=2*(a+b-4)%mod;
			ans[6]=4;
			for(int i=0;i<=8;i++)
			printf("%lld ",ans[i]);
			continue;			
		}
		if(cnt==1)
		{
			a=f[1];
			ans[6]=(a%mod-2%mod)%mod;
			ans[7]=2;
			for(int i=0;i<=8;i++)
			printf("%lld ",ans[i]);
			continue;
		}
		if(cnt==0)
		{
			ans[8]=1;
			for(int i=0;i<=8;i++)
			printf("%lld ",ans[i]);
			continue;
		}
	}
	return 0;
}
```
## 扩展
其实这道题过水了，完全可以扩展到$N$维的情况，规律都是相同的，只有转换到$N$维，才能体现出这道题的组合数思想，大家可以思考一下通解&更优解法，反正我只会暴力$qwq$。

组合计数$txdy!$


---

## 作者：ycy1124 (赞：7)

前言：写了 $5h$ 才写出来，最后发现没开 ```__int128```。
### 题意简述
有一个四维的 $a\times b\times c\times d$ 的蛋糕，将其表面全部染色，将其切成许多个 $1\times 1\times 1\times 1$ 的小蛋糕，求有 $0 \sim 8$ 面染色的小蛋糕分别有多少个。
### 思路
第一眼看到题目肯定是蒙的，但是进一步观察后就很容易发现，一个小蛋糕只有在某一维到达了最大值或者最小值就会染上一面色。

然后我们发现，在大多数情况下，染色的面最多的小蛋糕只染了 $4$ 面。考虑分讨：
1. 当蛋糕所有维度的最大值都大于等于 $2$ 的时候，染色面数最多的小蛋糕只有四面。我们用 $ans_i$ 表示有 $i$ 面染色的小蛋糕的个数。此时可以对于每个 $ans_i$ 去推它的式子。一个小蛋糕没有染一面色的情况只有其所有维度都为达到最大值与最小值，其个数就为 $(a-2)\times (b-2)\times (c-2) \times(d-2)$。其余同理，将会在代码中给出式子（建议自己先推一下）。
2. 当只有一维小于 $2$ 时，当它为 $2$ 时，所有的小蛋糕都会被染上 $2$ 面，否则就没有蛋糕。此时就可以降维，最后将答案的维数加上 $2$ 就行。对于有 $i$ 维小于 $2$ 的情况同理。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define md 2148473648
using namespace std;
inline char fgc(){
    static char buf[1<<17],*p=buf,*q=buf;
    return p==q&&(q=buf+fread(p=buf,1,1<<17,stdin),p==q)
    ?EOF:*p++;
}
inline int rint(){
    int x=0,s=fgc(),f=1;
    for (;s<'0'||'9'<s;s=fgc())f=s=='-'?-f:f;
    for (;'0'<=s&&s<='9';s=fgc())x=x*10+(s^'0');
    return x*f;
}
inline void write(__int128 x){
    if(x<0){
        putchar('-'),x=-x;
	}
    if(x>9){
        write(x/10);
	}
    putchar(x%10+'0');
    return;
}
__int128 ans[9];
signed main(){
	int t=rint();
	while(t){
		--t;
		__int128 n=2,m=0;
		int A=rint(),B=rint(),C=rint(),D=rint();
		__int128 a=A,b=B,c=C,d=D;
		int sum=(a<2)+(b<2)+(c<2)+(d<2);
		for(int i=0;i<=8;i++){
			ans[i]=0;
		}
		if(a<=0||b<=0||c<=0||d<=0){
		}else if(sum==0){
			ans[4]=min(a,n)*min(b,n)*min(c,n)*min(d,n);//每一维都取到极端，可以直接写16
			ans[3]=min(a,n)*min(b,n)*min(c,n)*max(m,(d-n))+min(d,n)*min(b,n)*min(c,n)*max(m,(a-n))+min(a,n)*min(d,n)*min(c,n)*(b-n)+min(a,n)*min(b,n)*min(d,n)*max(m,(c-n));//有1维没取到极端，可以将其它维取不到极端的个数乘上8（其它维都取到极端）
			ans[2]=min(a,n)*min(b,n)*max(m,(c-n))*max(m,(d-n))+min(a,n)*min(c,n)*max(m,(b-n))*max(m,(d-n))+min(a,n)*min(d,n)*max(m,(b-n))*max(m,(c-n))+min(b,n)*min(c,n)*max(m,(a-n))*max(m,(d-n))+min(b,n)*min(d,n)*max(m,(a-n))*max(m,(c-n))+min(c,n)*min(d,n)*max(m,(a-n))*max(m,(b-n));//此时有两位取不到极端，同上组合计数即可
			ans[1]=min(a,n)*max(m,(b-n))*max(m,(c-n))*max(m,(d-n))+min(b,n)*(a-n)*(c-n)*(d-n)+min(c,n)*(a-n)*(b-n)*(d-n)+min(d,n)*(a-n)*(b-n)*(c-n);
			ans[0]=max(m,(a-n))*max(m,(b-n))*max(m,(c-n))*max(m,(d-n));
		}else if(sum==1){//有一个小于2的情况
			ans[2]=max(max(a-2,m)*max(b-2,m)*(max(c-2,m)),max(max(a-2,m)*max(b-2,m)*max(d-2,m),max(max(a-2,m)*max(c-2,m)*max(d-2,m),max(b-2,m)*max(c-2,m)*max(d-2,m))));//有余最终答案而外加上了2个面，所以这里与取到0个类似，并且降了一维后变成了3维计数
			ans[3]=2*max(max(a-2,m)*max(b-2,m)+max(c-2,m)*max(a-2,m)+max(b-2,m)*max(c-2,m),max(max(a-2,m)*max(b-2,m)+max(d-2,m)*max(a-2,m)+max(b-2,m)*max(d-2,m),max(max(a-2,m)*max(d-2,m)+max(c-2,m)*max(a-2,m)+max(d-2,m)*max(c-2,m),max(d-2,m)*max(b-2,m)+max(c-2,m)*max(d-2,m)+max(b-2,m)*max(c-2,m))));
			ans[4]=4*(max(a-2,m)+max(b-2,m)+max(c-2,m)+max(d-2,m));
			ans[5]=8;
		}else if(sum==2){//2维计数
			ans[6]=4;
			ans[4]=max(max(a-2,m)*max(b-2,m),max(max(a-2,m)*max(c-2,m),max(max(a-2,m)*max(d-2,m),max(max(b-2,m)*max(c-2,m),max(max(d-2,m)*max(b-2,m),max(c-2,m)*max(d-2,m))))));
			ans[5]=2*max(max(a-2,m)+max(b-2,m),max(max(a-2,m)+max(c-2,m),max(max(a-2,m)+max(d-2,m),max(max(c-2,m)+max(b-2,m),max(max(d-2,m)+max(b-2,m),max(d-2,m)+max(c-2,m))))));
		}else if(sum==3){//1维
			ans[6]=max(a-2,max(b-2,max(c-2,d-2)));
			ans[7]=2;
		}else{//0维
			ans[8]=a*b*c*d;
		}
		for(int i=0;i<=8;i++){
			write(max(ans[i]%md,(__int128)0));
			putchar(' ');
		}
		putchar('\n');
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/184556761)。

---

## 作者：dinghongsen (赞：4)

## P5456 「THUPC2018」蛋糕 题解

### [题目传送门](https://www.luogu.com.cn/problem/P5456)
### [在我的个人博客食用效果更佳](https://www.luogu.com.cn/blog/DHS--2010/p5456-thupc2018-dan-gao-ti-xie)


乍一看，一道搜索题。

找找规律就能推出来。

如果涂了 0 面，就相当于三个方向上都没有碰到边界，答案就是 
$(a − 2) \times (b − 2) \times (c − 2) = 0$ 

如果涂了 1 面，就相当于有一个方向碰到了边界，答案就是 $2 \times ((a − 2) \times (b − 2) + (b − 2) \times (c − 2) + (a − 2) \times (c − 2)) = 1$ 


以此类推：

如果涂了 2 面，就相当于有 2 个方向碰到了边界。

如果涂了 3 面，就相当于有 3 个方向碰到了边界。

......

上代码
```cpp
// 小清新码风
# include <bits/stdc++.h>
using namespace std;
const long long MOD = 2148473648;
long long a[10], b[10];
void dfs(long long now, long long tot, long long num) {
    // 剪
	if (now == 5) {
		a[tot] = (a[tot] + num) % MOD;
		return;
	}
    // 剪
	if (b[now] == 1) {
		dfs(now + 1, tot + 2, num);
		return;
	} 
	dfs(now + 1, tot, (num * (b[now] - 2)) % MOD); // 选
	dfs(now + 1, tot + 1, (num + num) % MOD); // 不选
}
int main() {
	int T;
	scanf("%d", &T);
	while (T--) {
		memset(a, 0, sizeof(a));
		for (int i = 1; i <= 4; i++) {
            scanf("%lld", &b[i]);
        }
		dfs(1, 0, 1);
		for (int i = 0; i <= 8; i++) {
			printf("%lld ", a[i]);
        }
		printf("\n");
	}
    return 0；
    // 完结撒花
}
```

本蒟蒻的第一篇题解，求官方大大通过。

如本篇题解有误，请在下方评论指出。

---

## 作者：pitiless0514 (赞：4)

## 题意
懒得写了

## 题解

先膜拜神仙 $\textcolor{red}{\text{d}} \textcolor{black}{\text{ead\_x}}$
  。

这里我们考虑的是 $n$ 维的情况 。

你考虑将每个小立方体写成 $(b_1, b_2, b_3, b_4  ,... ,b_n)$ 的维度形式。

首先，每个维度之间是互相独立的，从这一点下手。

由于抹着奶油的蛋糕只有可能是在表面，所以对于一个维度，只有 $b_i = 1$ 或者 $b_i = a_i$ 的时候会有 $1$ 的贡献，而中间的 $a_i - 2$ 个贡献都为 $0$ 。

如果 $a_i = 1$ 的情况那就是全部贡献整体加 $2$ 。

然后就可以根据这个进行 dp 。

设 $dp_{i,j}$ 表示的是 $i$ 维度以前答案为 $j$ 的个数。

当 $a_i$ 不为 $1$ 时方程如下：

$$ dp _{i+1,j} = dp_{i+1,j} + dp_{i,j} \times (a_i - 2 )$$

$$
dp _{i+1,j+2} = dp_{i+1,j+2} + dp_{i,j+1} \times  2
$$

当 $a_i$ 为 $1$ 的时方程如下：

$$
dp_{i+1,j+2} = dp_{i+1,j+2} + dp_{i,j}
$$

然后复杂度就是 $n^2$ 的， $n$ 为维度大小。

可以滚动数组进行空间的优化。

目前是最优解。

看看 $\textcolor{red}{\text{d}} \textcolor{black}{\text{ead\_x}}$ 打不打算水题解，否则我就交了。

```cpp
const int mod = 2148473648;
int t, a[10], ans[10], y ,s;
int dp[10][10];
signed main() {
  t = read();
  while(t--){
    for(int i = 1; i <= 4; i++) a[i] = read();
    memset(dp, 0, sizeof(dp));
    dp[1][0] = 1;
    for(int i = 1; i <= 4; i++) {
      if(a[i] == 1){
        for(int j = 0; j <= 8; j++){
          dp[i+1][j+2] += dp[i][j];
          dp[i+1][j+2] %= mod;
        }
      }
      else{
        for(int j = 0; j <= 8; j++){
          dp[i+1][j] += dp[i][j] * (a[i] - 2) % mod;
          dp[i+1][j] %= mod;
          dp[i+1][j+1] += dp[i][j] * 2;
          dp[i+1][j+1] %= mod;
        }
      }
    }
    for(int i = 0; i <= 8; i++){
      write(dp[5][i]),putc(' ');
    }
    putc('\n');
  }
  flush();
  return 0;
}
```

---

## 作者：BIG_CUTE_BUG (赞：3)

## 思路
一道十分有趣的数学题。

显然我们无法想象四维物体，所以自然就想到尝试将其转化为零至三维进行思考。因为我们可以想象三维物体，所以可以先考虑如何将三维转化为零至二维，然后推广到四维。

现在我们思考对于一个大小为 $3 \times 3 \times 2$的三维蛋糕。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/w4e0hg84.png)

而这个立方体实际一个大小为 $3 \times 3$ 的二维平面图形沿着一根长度为 $2$ 的线段平移后所得到的。（如下图：蓝色正方形沿着红色线段平移后得到立方体）

![](https://cdn.luogu.com.cn/upload/image_hosting/lnbfiure.png)

接着就可以找**立方体染色后分别有 $0$ 个、$1$ 个、$2$ 个……$6$ 个染色面的小立方体数量**（后文将这一长串文字简称三维染量），和蓝色正方形，红色线段之间的关系。既然是染色问题，那二维和一维自然也有相应的染色方法，因此也有对应的二维染量和一维染量。所以会考虑找三者间的关系。

那么二维和一维该怎么染色呢？

因为**立体染色**染的是面，同理推出**面染色**染的是线，线则染点。所以可以将一、二维染量求出。

对于大小为 $3 \times 3$ 的正方形的二维染量：

（下图红色表示染色。）

![](https://cdn.luogu.com.cn/upload/image_hosting/5xm7gnqz.png)

* 染了 $0$ 个边的有 $5$ 号（$1$ 个）。

* 染了 $1$ 个边的有 $2$ 号、$4$ 号、$6$ 号、$8$ 号（$4$ 个）。

* 染了 $2$ 个边的有 $1$ 号、$3$ 号、$5$ 号、$7$ 号（$4$ 个）。

* 染了 $3$ 个边的有 $0$ 个。

* 染了 $4$ 个边的有 $0$ 个。
对于大小为 $2$ 的线段的一维染量：

![](https://cdn.luogu.com.cn/upload/image_hosting/mcgqo41y.png)

* 染了 $0$ 个点的没音（$0$ 个）。

* 染了 $1$ 个点的有 $1$ 号、$2$ 号（$2$ 个）。

而对于大小为 $3 \times 3 \times 2$ 的立方体的三维染量：（分析略）

* 染了 $0$ 个面的有 $0$ 个。

* 染了 $1$ 个面的有 $2$ 个。

* 染了 $2$ 个面的有 $8$ 个。

* 染了 $3$ 个面的有 $8$ 个。

* 染了 $4$ 个面的有 $0$ 个。

* 染了 $5$ 个面的有 $0$ 个。

* 染了 $6$ 个面的有 $0$ 个。

不难发现，对于三维染量中的染了 $n$ 个面的数量，就等于二维染量中染了 $i$ 条线的数量，乘以一维染量中染了 $j$ 个点的数量，其中当 $i + j = n$ 时，所有乘积之和。数学公式为：
$$ c_n = \sum ({a_i} \times {b_j}),i + j = n $$

自此，我们就推出了三维染量与一、二维染量之间的关系。

然后推广到四维：

其实一个三维体除了理解为一个二维图形沿着一根一维线段平移得到，也可以理解为**一个一维线段垂直于这个二维平面插满这个二维图形**而得到。

因此，一个四维体也就可以理解为一个三维体沿着一根一维线段平移得到，或一根一维线段通过某种方式沿着一个三维体得到，亦或一个二维体 ~~（通过宇宙射线）~~ 沿着另一个二维体得到。~~（十分抽象）~~

而我最初做题时就选的一个二维体 ~~（通过宇宙射线）~~ 沿着另一个二维体得到四维体来做的。

令四维染量为 $sum3$，二维染量为 $sum2$，另一个二维染量为 $sum1$，那么由上文公式可推出：
$$ sum3_n = \sum (sum1_i \times sum2_j),i + j = n $$

转化为代码也就是：
```cpp
for(int k= 0; k<= 8; k++)
	for(int i= 0; i<= k; i++)
		sum3[k]+= sum1[i]* sum2[k- i];
```
最后在这个循环前面把两个二维染量预处理出来，输出就行了。

~~个人感觉评黄不太合理~~


## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int m= 2148473648;
int t, a, b, c, d;
signed main()
{
	scanf("%lld", &t);
	while(t--)
	{
		int sum1[5]= {}, sum2[5]= {};
		scanf("%lld%lld%lld%lld", &a, &b, &c, &d);
		//保证a，b，c，d的大小顺序，方便下面判断
		if(a> b) swap(a, b);
		if(c> d) swap(c, d);

		if(a== 1 && b== 1) sum1[4]= 1;
		else if(a== 1)
		{
			sum1[3]= 2, sum1[2]= (b- 2)% m;
		}
		else
		{
			sum1[0]= (a- 2)* (b- 2)% m;
			sum1[1]= ((a- 2)* 2+ (b- 2)* 2)% m;
			sum1[2]= 4;
		}

		if(c== 1 && d== 1) sum2[4]= 1;
		else if(c== 1)
		{
			sum2[3]= 2, sum2[2]= (d- 2)% m;
		}
		else
		{
			sum2[0]= (c- 2)* (d- 2)% m;
			sum2[1]= ((c- 2)* 2+ (d- 2)* 2)% m;
			sum2[2]= 4;
		}

		for(int k= 0; k<= 8; k++)
		{
			int s= 0, mx= k;
			if(k> 4) mx= 4;
			for(int i= mx; i>= 0 && k- i<= mx; i--)
			{
				//因为我sum1，sum2开的小，为了避免越界就处理了一下循环
				s+= sum1[i]* sum2[k- i] %m;
				s%= m;
			}
			printf("%lld ", s);//即算即输
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：pengziyippp (赞：1)

## 题目大意  
给出一个 4D 的蛋糕的各边长 $a,b,c,d$。  
求出有 $0\sim8$ 面为外层涂有奶油的 $1\times1\times1\times1$ 小蛋糕各有多少个。  
## 思路简述  
实话说这个题目我看了好几遍都没能抽象地理解 4D。  
既然理解不了，那我们就先考虑将四维转换为我们熟悉的三维探究。  
可以将蛋糕抽象的想象成一个魔方。  
容易得出结论，在大多数情况下，小蛋糕最多被覆盖 $3$ 面，最少被覆盖 $0$ 面。$3$ 面即为角块，$2$ 面即为棱块，$1$ 面即为中心块，$0$ 面即为最中间里面的部分。  
由此可推出，  
$ans[0] = (a - 2)\times(b - 2)\times(c - 2);$  
$ans[1] = 2\times((a - 2)\times(b - 2) + (a - 2)\times(c - 2) + (b - 2)\times(c - 2));$  
$ans[2] = 4\times((a - 2) + (b - 2) + (c - 2));$  
$ans[3] = 8;$  
当然，以上只存在于 $a,b,c \ge 2$ 的情况下。  
其他的情况如 $a,b,c$ 有其中一个为 $1$ 时，我们可以视为物体由三维降到二维，由此不难类推出满足 $a,b,c<2$ 有 $1$ 个，$2$ 个，$3$ 个时的公式，均与上述相似。  
而题目所要求的四维情况，相当于如上再加上一个维度。  
看看代码中的实现就不难理解其中的规律了 $!$  
最后要记得模，不然容易爆炸。   
结束撒花。
## 代码实现  
马蜂良好。  

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 2148473648
using namespace std;
const int N = 10;
int f[N], ans[N];
int a, b, c, d, tot; 
void solve () {
	memset (ans, 0, sizeof (ans));
	memset (f, 0, sizeof (f)); // 初始化很重要！
	tot = 0;
	cin >> a >> b >> c >> d;
	if (a >= 2) f[++tot] = a; if (b >= 2) f[++tot] = b;
	if (c >= 2) f[++tot] = c; if (d >= 2) f[++tot] = d; // 统计
	if (tot == 0) {
		ans[8] = 1;
	} else if (tot == 1) {
		int t1 = f[1] - 2;
		ans[7] = 2;
		ans[6] = t1 % mod;
	} else if (tot == 2) {
		int t1 = f[1] - 2, t2 = f[2] - 2;
		ans[6] = 4;
		ans[5] = 2 * (t1 + t2) % mod;
		ans[4] = (t1 * t2) % mod;
	} else if (tot == 3) {
		int t1 = f[1] - 2, t2 = f[2] - 2, t3 = f[3] - 2;
		ans[5] = 8;
		ans[4] = 4 * (t1 + t2 + t3) % mod;
		ans[3] = 2 * ((t1 * t2) % mod + (t1 * t3) % mod + (t3 * t2) % mod) % mod;
		ans[2] = (((t1 * t2) % mod) * t3) % mod;
	} else {
		int t1 = f[1] - 2, t2 = f[2] - 2, t3 = f[3] - 2, t4 = f[4] - 2;
		ans[4] = 16;
		ans[3] = 8 * (t1 + t2 + t3 + t4) % mod;
		ans[2] = 4 * ((t1 * t2) % mod + (t1 * t3) % mod + (t1 * t4) % mod + (t2 * t3) % mod + (t2 * t4) % mod + (t3 * t4) % mod) % mod;
		ans[1] = 2 * (((t1 * t2) % mod * t3) % mod + ((t1 * t2) % mod * t4) % mod + ((t1 * t3) % mod * t4) % mod + ((t4 * t2) % mod * t3) % mod) % mod;
		ans[0] = (((t1 * t2) % mod * t3) % mod * t4) % mod;
	}
	for (int i = 0; i <= 8; i ++ ) {
		cout << ans[i] % mod << " ";
	}
	cout << "\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
    int T; cin >> T;
    while (T --) {
    	solve();
	}
}
```

---

## 作者：jidao_wansui (赞：1)

### P5456 [THUPC 2018] 蛋糕 题解

#### 题意简述

给一个四维的大小为 $a \times b \times c \times d$ 蛋糕，将其切成若干个大小为 $1$ 的小蛋糕，问有多少个小蛋糕有 $0, 1, 2, 3, 4, 5, 6, 7, 8, 9$ 个面涂上奶油。

#### 思路

很显然，我们不是四维人，自然无法直接想象四维的蛋糕，所以要先把问题退化成三维思考 $(A = a - 2, B = b - 2, C = c - 2, D = d - 2)$：

- 涂上 $0$ 面的蛋糕数就是 $A \times B \times C$。

- 涂上 $1$ 面的蛋糕数就是 $2 \times (A \times B + B \times C + A \times C)$。

- 涂上 $2$ 面的蛋糕数就是 $4 \times (A \times B \times C)$。

- 涂上 $0$ 面的蛋糕数就是 $8$。

接下来只需将三维的结论推广到四维上去：

- 涂上 $0$ 面的蛋糕数就是 $A \times B \times C \times D$。

- 涂上 $1$ 面的蛋糕数就是 $2 \times (A \times B \times C + A \times B \times D + A \times C \times D + B \times C \times D)$。

- 涂上 $2$ 面的蛋糕数就是 $4 \times (A \times B + A \times C + A \times D + B \times C + B \times D + C \times D)$。

- 涂上 $3$ 面的蛋糕数就是 $8 \times (A \times B \times C \times D)$。

- 涂上 $4$ 面的蛋糕数就是 $16$。

~~接下来将以上结论写下即可。~~ ~~然后发现你一分不得。~~

原因在于没有**分类讨论四个量是否为 $1$**。

我们又发现，**每有一个量为 $1$，那么就相当于将蛋糕的维数减一，也就是~~像二向箔一样~~降一维**。

那么就再推出 $0, 1, 2$ 维蛋糕的结论，在代码中判断有几个量为 $1$，再进行分类讨论输出每一种的结果，就可以 A 了这道题！

$AC$ $CODE$

```cpp
#include <bits/stdc++.h>
#define int long long
const int kh = 2148473648;
#define a (a1[0] - 2) % kh
#define b (a1[1] - 2) % kh
#define c (a1[2] - 2) % kh
#define d (a1[3] - 2) % kh
using namespace std;

int t, a1[5], b1[5];

void zero(int n)
{
    while (n--)
        cout << 0 << " ";
}

signed main()
{
    cin >> t;
    while (t--)
    {
        int jsq = 0, ind = 0;
        for (int i = 0; i < 4; i++)
        {
            cin >> a1[i];
            if (a1[i] == 1)
                jsq++;
            else
                b1[ind++] = a1[i];
        }
        if (jsq == 0)
        {
            cout << a * b * c * d << " ";
            cout << 2 * (a * b * c + a * b * d + a * c * d + b * c * d) % kh<< " ";
            cout << 4 * (a * b + a * c + a * d + b * d + b * c + c * d) % kh<< " ";
            cout << 8 * (a + b + c + d) % kh << " ";
            cout << 16 << " ";
            zero(4);
            cout << endl;
        }
        else if (jsq == 1)
        {
            a1[0] = b1[0];
            a1[1] = b1[1];
            a1[2] = b1[2];
            zero(2);
            cout << a * b * c % kh << " ";
            cout << 2 * (a * b + a * c + b * c) % kh << " ";
            cout << 4 * (a + b + c) % kh << " ";
            cout << 8 << " ";
            zero(3);
            cout << endl;
        }
        else if (jsq == 2)
        {
            a1[0] = b1[0];
            a1[1] = b1[1];
            zero(4);
            cout << a * b % kh << " ";
            cout << 2 * (a1[0] + a1[1] - 4) % kh << " ";
            cout << 4 << " ";
            zero(2);
            cout << endl;
        }
        else if (jsq == 3)
        {
            a1[0] = b1[0];
            zero(6);
            cout << (a1[0] % kh - 2) % kh << " ";
            cout << 2 << " ";
            zero(1);
            cout << endl;
        }
        else
        {
            zero(8);
            cout << 1 << endl;
        }
    }
    return 0;
}
```

---

## 作者：Bismuth_Sulfate (赞：1)

## 可能出现的专有名词解释

胞：四维长方体的三维面称作“胞”。

超立方体：即四维正方体。

单位超立方体：即边长为 $1$ 的超立方体。

## 题意解释

给一个四维长方体的四边长，并且给它裸露在外的部分染色，接着把它切成一些单位超立方体，统计每个单位超立方体有几胞被染色。

## 分析

由于我们是三维生物，直接思考四维是很困难的，但思考三维则很简单。如果将四维长方体改成三维，这题直接变成一道小学就学过的数学题了（至多橙）。
![](https://cdn.luogu.com.cn/upload/image_hosting/d6too9hp.png)
不过现在是四维。我们发现，当一个维度长为 $1$ 时会很特殊（因为这样会使一些单位超立方体相对的两胞被染色），不妨分类讨论。

1. $a=b=c=d=1$

不难看出这时只有一个单位超立方体（下文简称“立方体”），这个立方体八胞均被染色。

实现代码：`printf("0 0 0 0 0 0 0 0 1")`

2. $a=b=c=1$，$d\ge2$

这时所有立方体被排成了一排。除了两端的两个立方体七胞被染色，其余（即 $d-2$ 个）立方体均有六胞被染色。

实现代码：`printf("0 0 0 0 0 0 %lld 2 0",(d-2)%mod)`

3. $a=b=1$，$c,d\ge2$

这时所有立方体被排成了一个二维面。四角的四个立方体六胞被染色，边上的立方体五胞被染色，其余立方体有四胞被染色。

实现代码：`printf("0 0 0 0 %lld %lld 4 0 0",(c-2)*(d-2)%mod,2*((c-2)+(d-2))%mod)`

4. $a=1$，$b,c,d\ge2$

这时，会发现问题其实变成了三维空间的染色问题，只不过每个立方体有两胞恒被染色。用三维空间中的解题方法即可。注意最后的结果是有 $2 \sim 5$ 面被染色的立方体，不是有 $0 \sim 3$ 面被染色的立方体。

实现代码：`printf("0 0 %lld %lld %lld 8 0 0 0",(b-2)*(c-2)*(d-2)%mod,2*((b-2)*(c-2)+(d-2)*(c-2)+(b-2)*(d-2))%mod,4*((b-2)+(c-2)+(d-2))%mod)`

5. $a,b,c,d\ge2$

此时，我们就要思考四维的长方体了。这可能比较难想，但我们类比三维空间的解题方式，就可以轻松解出此题。

首先，四维长方体切成的正方体有至少四个胞与其它立方体相接，因此这些正方体至多有四胞被染色。

实现代码：`printf("%lld %lld %lld %lld %lld 0 0 0 0",face0,face1,face2,face3,face4)`

然后，我们就要思考每种正方体具体有多少个了。

四胞被染色的正方体肯定位于大长方体的顶点上，而四维长方体共有 $16$ 个顶点（为什么？四维长方体是由三维长方体在四维移动形成，三维长方体原本就有 $8$ 个顶点，四维长方体就有 $8 \times 2 = 16$ 个顶点，棱、面、胞的数量也可以以类似的理由乘 $2$），因此 `face4` 恒等于 $16$。

三胞被染色的正方体位于大长方体的棱上，而一个四维长方体有 $8$ 组棱，所以 `face3` 等于 $8((a-2)+(b-2)+(c-2)+(d-2))$。

两胞被染色的正方体位于大长方体的面上，一个四维长方体有 $4$ 组面，所以 `face2` 等于 $4((a-2)(b-2)+(a-2)(c-2)+(a-2)(d-2)+(b-2)(c-2)+(b-2)(d-2)+(c-2)(d-2))$。

一胞被染色的正方体位于大长方体的的胞上，一个四维长方体有 $2$ 组胞，所以 `face1` 等于 $2((a-2)(b-2)(c-2)+(a-2)(b-2)(d-2)+(a-2)(c-2)(d-2)+(b-2)(c-2)(d-2))$。

没有被染色的正方体位于大长方体的内部，也就是一个棱长更小的大长方体。`face0` 等于 $(a-2)(b-2)(c-2)(d-2)$。

最后写代码的时候，记得 $\operatorname{mod} 2147483648 $ 即可。

咦？没过？

---
### 坑点1

再读一遍题干：

为了防止答案过大，你只需要输出答案除以 $214\textup{\textbf{847}}3648$ 的余数。

这个数不是 $2^{31}$ ，因此不能使用 int 自然溢出的特性，不开 long long 见祖宗。

改一下不就行了吗！

```cpp
#define mod 2148473648ll
```
咦？又没过？

---
### 坑点2

测试了一下，发现程序输出没有被染色的正方体数量时有时会有问题。

hack：

```
input: 191981 191981 191981 191981
output: -2010668463 1941123192 --省略--
```

这哪来的负数呢？只可能是爆 long long 了。

看数据范围：

一行 $4$ 个正整数 $a$、$b$、$c$、$d$。（四个正整数都在 $10^6$ 以内）

那么，$a\times b\times c\times d$ 在极端情况下会到 $10^{24}$ 去，爆 long long 了。

这也不是啥大问题，修改一下就行了。

AC代码：
```cpp
#include <bits/stdc++.h>
#define mod 2148473648ll //这个数不是2^31
using namespace std;
long long t,a,b,c,d;
void sorted(){//改成数组会好一点。不过懒得优化了。
	long long tmp;
	if(a>b){
		tmp = a;
		a = b;
		b = tmp;
	}
	if(a>c){
		tmp = a;
		a = c;
		c = tmp;
	}
	if(a>d){
		tmp = a;
		a = d;
		d = tmp;
	}
	if(b>c){
		tmp = b;
		b = c;
		c = tmp;
	}
	if(b>d){
		tmp = b;
		b = d;
		d = tmp;
	}
	if(c>d){
		tmp = c;
		c = d;
		d = tmp;
	}
}
long long face0,face1,face2,face3;
int main(){
	cin >> t;
	while(t--){
		cin >> a >> b >> c >> d;
		sorted();//保证a最小，d最大
		if(a==b&&b==c&&c==d&&d==1)printf("0 0 0 0 0 0 0 0 1");
		else if(a==b&&b==c&&c==1)printf("0 0 0 0 0 0 %lld 2 0",(d-2)%mod);
		else if(a==b&&b==1)printf("0 0 0 0 %lld %lld 4 0 0",(c-2)*(d-2)%mod,2*((c-2)+(d-2))%mod);
		else if(a==1)printf("0 0 %lld %lld %lld 8 0 0 0",(b-2)*(c-2)*(d-2)%mod,2*((b-2)*(c-2)+(d-2)*(c-2)+(b-2)*(d-2))%mod,4*((b-2)+(c-2)+(d-2))%mod);
		else{
			face0 = ((a-2)*(b-2)%mod)*((c-2)*(d-2)%mod)%mod;//先乘起来再取模会爆long long
			face1 = 2*((a-2)*(b-2)*(c-2)%mod+(a-2)*(b-2)*(d-2)%mod+(a-2)*(c-2)*(d-2)%mod+(b-2)*(c-2)*(d-2)%mod)%mod;
			face2 = 4*((a-2)*(b-2)+(a-2)*(c-2)+(a-2)*(d-2)+(b-2)*(c-2)+(b-2)*(d-2)+(c-2)*(d-2))%mod;
			face3 = 8*((a-2)+(b-2)+(c-2)+(d-2))%mod;
			printf("%lld %lld %lld %lld 16 0 0 0 0",face0,face1,face2,face3);
		}
		cout << endl;
	}
	return 0;
} 
```

[提交记录](https://www.luogu.com.cn/record/149017102)

---

## 作者：SDNetFriend (赞：1)

## P5456 [THUPC2018]蛋糕 题解

### 整体情况

采用了类似状压的实现方式，降低了代码难度。

### 题意这里不再赘述

[P5456 [THUPC2018]蛋糕](https://www.luogu.com.cn/problem/P5456)

### 朴素分析

首先想到这个题，显然以面或者说在边上的体为切入点有点困难，所以尝试转换角度，干脆从那些 $1\times 1\times 1\times 1$ 的小四维立方体切入来分析这个问题。

### 深入分析

我们发现，假设一个四维立方体在某一维的体上被染了色，那么它在这一维一定是在边界的。那如果我们给这些立方体一个坐标，形如 $(x,y,z,w)$ 这种形式，那么如果它第一维的体被染了色，说明 $x=1$ 或 $x=a$，如果 $a>1$ 那么就有一侧被染色，如果 $a=1$ 就会有两侧被染色，剩下的维同理。

那我们就可以枚举四维，每一维是否在边界来得到答案。假设每一维长度都 $>2$ 的话，那现在假设只有第一维对应的方向被染色，剩下的维都没有被染色，那么这样的小四维立方体个数是 $2\times (b-2)\times (c-2)\times (d-2)$，因为边界有两个所以要乘二，这个会对有一个面被染色的答案产生贡献。

那如果第一维是 $1$ 呢？那前面的 $2$ 就不用乘了，并且对染色的面数产生 $2$ 的贡献。那如果 $bcd$ 有 $\leq 2$ 的呢，那就不用统计，说明不存在不在那一维边界上的块，直接继续即可。

### 实现细节

大多数题解是 $a,b,c,d$ 分开来写，这里方便一点直接开数组就可以。而且我们发现在不在边界实际上是个二进制状态，那么干脆枚举从 $0-15$，对应位是 $1$ 说明在边界，否则不在边界，分别计算答案即可。

### 最后

这个题以这种做法，在 $T\leq 10^4$ 的情况下开到十维是完全没有问题的，只需要数组开大然后改下循环边界就可以了。

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint p=2148473648;
lint a[4],T,b[9];
int main(){
	T=read();
	while(T--){
		memset(b,0,sizeof b);
		for(rint i=0;i<4;++i)
			a[i]=read();
		for(rint i=0;i<16;++i){
			lint upd=1,cnt=0;
        	//upd统计符合条件的四维立方体个数
        	//cnt统计被染色的体数
			for(rint j=0;j<4;++j)
				if(i>>j&1){
					if(a[j]==1)cnt+=2;
					else upd=upd*2%p,++cnt;
				}else{
					if(a[j]<=2)goto ep;
					else upd=upd*(a[j]-2)%p;
				}
			b[cnt]=(b[cnt]+upd)%p;
			ep:continue;
		}
		for(rint i=0;i<=8;++i)
			printf("%lld ",b[i]);
		puts("");
	}
	return 0;
}


```


---

## 作者：Frozen_Ladybug (赞：0)

### 题意

将一个超平面上的立方体（最外层涂着奶油）分成 $a\times b\times c\times d$ 个小立方体，问面数涂上奶油的立方体个数。

### 思路

如果一个方块被涂了 $0$ 面，相当于恰好 $0$ 个维度碰到了边界；如果一个方块被涂了 $1$ 面，相当于恰好 $1$ 个维度碰到了边界，等等。

如果一个方块被涂了 $i$ 面，相当于恰好 $i$ 个维度碰到了边界。

那么设 $f_{i,j}$ 表示只考虑前 $i$ 个维度，被涂了 $j$ 面的方块的个数。

考虑第 $i$ 个维度，有 $2$ 个位置会碰到这个维度的边界，而其他 $a_i-2$ 个位置则没有碰到边界。所以：

$$f_{i,j}=2f_{i−1,j−1}+f_{i−1,j}(a_i−2)$$

注意到当 $a_i=1$ 时，这个唯一的位置的方块会同时碰到上下边界。相当于多染了 $2$ 面。所以此时：

$$f_{i,j}=f_{i−1,j−2}$$

之后就可以递推了。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=2148473648;
ll a[5];
ll f[5][9];
void solve(){
	memset(f,0,sizeof(f)); 
	f[0][0]=1;
	for(ll i=1;i<=4;++i){
		for(ll j=0;j<=8;++j){
			if(a[i]==1) 
				if(j>=2) f[i][j]=f[i-1][j-2]%mod;
			else{
				f[i][j]=f[i-1][j]*(a[i]-2)%mod;
				f[i][j]%=mod;
				if(j){
					f[i][j]+=f[i-1][j-1]*2%mod;
					f[i][j]%=mod;
				}	
			}
		}
	}
	for(ll i=0;i<=8;++i) cout<<f[4][i]<<" ";
	cout<<"\n"; 
}
int main(){
	ll T; cin>>T;
	while(T--){
		for(ll i=1;i<=4;++i) cin>>a[i];
		solve();
	}	
	return 0;
}
```

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

给出一个 $a\times b\times c\times d$ 的超立方体，求露出表面为 $0$ 至 $8$ 个的小立方体的数量。

### 2. 思路

（一大早起来写一道规律题是不是不太好。）

先推三维的情况。

记 $a-2=A,b-2=B,c-2=C$。

- $a,b,c$ 都不为 $1$ 的情况。

简单推算后可以知道$\begin{cases}ans_0=ABC\\ans_1=2(AB+AC+BC)\\ans_2=4(A+B+C)\\ans_3=8\end{cases}$。

- $a,b,c$ 有一个为 $1$ 的情况。

不妨设 $c=1$。

仍然简单推算后可以知道$\begin{cases}ans_2=AB\\ans_3=2(A+B)\\ans_4=4\end{cases}$。

- $a,b,c$ 有两个为 $1$ 的情况。

不妨设 $b=c=1$。

继续推算后可以知道$\begin{cases}ans_4=A\\ans_5=2\end{cases}$。

- $a=b=c=1$ 的情况。

显然的，有 $ans_6=1$。

推完三维再看四维规律就很明显了。

为方便书写，记 $a-2=A,b-2=B,c-2=C,d-2=D$。

- $a,b,c,d$ 都不为 $0$ 的情况。

对比三维可以容易知道$\begin{cases}ans_0=ABCD\\ans_1=2(ABC+ABD+ACD+BCD)\\ans_2=4(AB+AC+AD+BC+BD+CD)\\ans_3=8(A+B+C+D)\\ans_4=16\end{cases}$。

- $a,b,c,d$ 有一个为 $0$ 的情况。

对比三维可以容易知道$\begin{cases}ans_2=ABC\\ans_3=2(AB+AC+BC)\\ans_4=4(A+B+C)\\ans_5=8\end{cases}$。

- $a,b,c,d$ 有两个为 $0$ 的情况。

对比三维可以知道$\begin{cases}ans_4=AB\\ans_5=2(A+B)\\ans_6=4\end{cases}$。

- $a,b,c,d$ 有三个为 $0$ 的情况。

对比三维可以知道$\begin{cases}ans_6=A\\ans_7=2\end{cases}$。

- $a=b=c=d=1$ 的情况。

对比三维可以知道 $ans_8=1$。

代码不放了，写得很清楚了。

（话说楼下怎么全是 DFS。）

---

## 作者：Genius_Star (赞：0)

### 思路：
我们发现，如果这鬼东西是一维的那显然好做啊。

就是给定两个 $01$ 串，问存不存在一个起点使得把第二个串和第一个串上的起点对齐使得第二个串每个有 $1$ 的位置在第一个串上都是 $0$。

这就那 FFT 搞一搞就好了。

详细点就是：

第一个多项式 $A$ 中的 $A_i$ 表示第一个串的第 $i+1$ 个字符是什么，$B$ 多项式对应第二个。

翻转之后卷一起成了 $C$ 就变成了：

$$C_i=\sum\limits_{j=0}^{i-1}A_j \times B_{R,i-1-j}$$

只有两个都是 $1$ 的位置 $C_i$ 才不是 $0$ 所以扫一遍判一下就好了。

现在考虑二维的怎么办，其实也非常简单就是把下一列首尾相接接到上一列后面就好了。

这样就转化成了第一个问题。

至于第二个串怎么求呢，那就暴力按照它给的方向扫一扫就好了。

只有走到的位置是 $1$ 其余的是 $0$。

之后就像上面说的一样 FFT，扫一扫就好了嘛。

**FFT：快速傅里叶变换。**

我都说的这么详细了，你现在肯定会了吧，自己试试看吧~（~~我的代码写的丑，还是不拿出来丢人现眼了吧！~~）

---


# [THUPC 2017] 母亲节的礼物

## 题目描述

小 B 喜欢图，尤其是边数不太多的无向简单图。

母亲节快到了，小 B 在纸上画了一张有 $n$ 个节点、$m$ 条边的无向简单图（即，不存在重边、自环），保证每个点只和**最多 $7$ 个点**相邻。接着，他想用 $4$ 种不同的颜色给图中的节点进行染色，作为妈妈的母亲节礼物送给她。

小 B 希望染色之后的图尽量漂亮，他觉得相同颜色的点连成一片不好看。所以，他希望能给每对相邻的节点染上不同的颜色。遗憾的是，小 B 很快发现，在有些图中，这是不可能做到的。他不得不降低要求：每个点相邻的点中，**至多**有一个点和它的颜色相同。

限制条件放松了，问题也就变得简单了；但是小 B 忙着做大作业，所以来找你帮忙。现在，请你告诉小 B，是否能给图中每个点染上一个恰当的颜色，恰好满足小 B 的要求？如果可以，请你给他指出一种染色方案；否则，只好残忍地告诉小 B：`impossible`。

## 说明/提示

#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
1
8 28
1 2
1 3
1 4
1 5
1 6
1 7
1 8
2 3
2 4
2 5
2 6
2 7
2 8
3 4
3 5
3 6
3 7
3 8
4 5
4 6
4 7
4 8
5 6
5 7
5 8
6 7
6 8
7 8```

### 输出

```
abcdabcd```

# 题解

## 作者：happy_dengziyue (赞：8)

### 1 思路

注：本题的解法正确性并未得到证明，但是能过。

我们一看题目，发现题目还有重点突出每个点最多和 $7$ 个点相邻。那么，我们就可以知道，最复杂最可能无解的图，就是 $8$ 个点的完全图。

然鹅，哪怕是这样，都有解，即样例。

所以我们可以得出结论：没有无解的情况。~~可能是因为 `小 B` 的孝心感天动地。~~

那么怎么构造呢？深搜是明显不行的。我们可以使用一种奇技淫巧。

首先，将颜色编号为 $0-3$，然后，找出所有不满足要求的点，加入队列。

每次从队首取一个点。如果这个点已经满足要求就不去动它，否则，将它的颜色改成所有与它直接相连的点的中最稀有的颜色。

依据容斥原理，我们可以证明，这个颜色在周围只有 $1$ 个或者 $0$ 个点拥有。

当然了，改完颜色后，又要判断所有与之相连的点有哪个或哪些不满足要求，压入队列。

队列为空时，答案就出来了。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define max_n 25000//最大点数
#define max_m 200000//最大边数
int t;//测试数据组数
int n;//点数
int m;//边数
struct E{
	int v,nx;
}e[max_m+2];//边
int ei;//下标
int fir[max_n+2];//开始路径
int micnt,micol;//周围最少的颜色的数量与那个颜色
int col[max_n+2];//颜色
queue<int>q;//队列
inline void addedge(int u,int v){
	e[++ei]=(E){v,fir[u]}; fir[u]=ei;
}
int asksame(int u,int x){
	int res=0;
	for(int i=fir[u];i;i=e[i].nx){
		if(x==col[e[i].v])++res;
	}
	return res;//在点u周围有res个颜色为x的点
}
inline int mi(int a,int b){
	return a<b?a:b;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P7428_1.in","r",stdin);
	freopen("P7428_1.out","w",stdout);
	#endif
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		ei=0;
		memset(fir,0,sizeof(fir));
		for(int i=1,u,v;i<=m;++i){
			scanf("%d%d",&u,&v);
			addedge(u,v);
			addedge(v,u);
		}
		memset(col,0,sizeof(col));
		while(!q.empty())q.pop();
		for(int i=1;i<=n;++i){
			if(asksame(i,col[i])>1)q.push(i);
		}
		while(!q.empty()){
			int u=q.front();
			q.pop();
			if(asksame(u,col[u])<=1)continue;
			micnt=8;
			for(int i=0,k;i<4;++i){
				k=asksame(u,i);
				if(k<micnt){
					micnt=k;
					micol=i;
				}
			}
			col[u]=micol;//此时必定有micnt<=1
			for(int i=fir[u],v;i;i=e[i].nx){
				v=e[i].v;
				if(col[v]==micol&&asksame(v,micol)>1)q.push(v);
			}
		}
		for(int i=1;i<=n;++i)putchar(col[i]+'a');
		puts("");
	}
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/59312250)

By **dengziyue**

---

## 作者：Rosick (赞：2)

## 证明：本题一定有解
### 对于完全图
已知以下条件：
1. 要求一个点最多只能有一个相同颜色的邻接点。
2. 对于一个完全图，图上的点一定两两相接。

那么一个完全图上对于一种颜色，相同的一定只有两个。

题目给出了四种颜色，那么一个完全图上最多有四对点，也就是八个点，题目要求的一个点最多只与七个点直接相接，也就是完全图最多有八个点，符合要求。

因此，完全图一定有解。
### 对于非完全图
我们假设它是由一个完全图或多个完全子图删边得来的。

点数小于等于 $8$ 时：由一个点数在八以内完全图删边得来。
1. 此时，假设的图一定有解。
2. 而删边是在减少约束，那么删完边后的实际图也一定有解。

点数大于 $8$ 时：由多个点数在八以内完全子图删边得来。
1. 此时，对于假设的每个完全子图来说，内部肯定有解。
2. 则内部删边后也一定有解。
3. 至于每个完全子图连接处的点的问题：
	- 一个完全子图内部的情况除去连接处的点，其他点是对其他完全子图内的点没有影响的。
   - 因此固定了连接处的点，其他点也是一定有解的。
   - 那么不同完全子图连接处的点可以相同，且保证其他地方有解。则整个图有解。
   
因此，非完全图也一定有解。

**综上，得证**

---

## 作者：Hoks (赞：2)

## 前言
[题目链接](https://www.luogu.com.cn/problem/P7428)，[个人博客](https://www.luogu.com.cn/blog/Hok/solution-p7428)内食用也许不会更佳。

首先我所食用的思路的时间复杂度并不能保证，只是在本题目前的数据下跑过去了，总体而言更多的是猜想而没有准确的证明（求大佬证明）。
## 思路分析
首先观察题目样例发现给的样例的 $n$ 刚好是可以满足出现最多和 $7$ 个点相连的 $8$。说明其有一定的一般性。

再开一眼样例并没有无解，手搓几组小样例发现好像并不存在无解的情况，所以大胆猜想无解的情况并不存在。

如何制造有解情况呢？

尝试随机给每个点染色。接着调整点的颜色使冲突的情况得以解决。

如果说一个点和周围的点之间的颜色有冲突，优先考虑是否有周围点没有的颜色。然后再考虑冲突最少的情况。

将这个点的颜色调整之后考虑他周围的点如果有冲突以及没放入队列就扔进去。因为（猜测）肯定存在有解情况，所以经过有限次调整一定能满足要求。

每个点的调整次数应该不会太多，大概最多只能有 $10$ 次左右吧（雾）。所以也就是相当于加了一个稍微大一点的常数，是能过的。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{int v,nxt;}e[200010];
int t,n,m,tot;
int color[25010],head[25010],d[25010],num[25010];
queue<int> q;
int read()
{
	char c=getchar();int x=0;
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
void add(int u,int v){e[++tot].v=v,e[tot].nxt=head[u],head[u]=tot;}
signed main()
{
	srand(time(NULL));
    t=read();
    while(t--)
    {
        n=read(),m=read();tot=0;
        for(int i=1;i<=n;i++) color[i]=-1,d[i]=0,head[i]=0;
        for(int i=1,u,v;i<=m;i++) u=read(),v=read(),add(u,v),add(v,u);
        for(int i=1;i<=n;i++) color[i]=rand()%4;
        while(!q.empty()) q.pop();
        for(int x=1;x<=n;x++)
        {
            for(int i=head[x];i;i=e[i].nxt) if(color[x]==color[e[i].v]) d[x]++;
            if(d[x]>1) q.push(x);
        }
        while(!q.empty())
        {
            int x=q.front();q.pop();
            for(int i=head[x];i;i=e[i].nxt) if(color[x]==color[e[i].v]) d[x]--,d[e[i].v]--;
            for(int i=0;i<=3;i++) num[i]=0;
            for(int i=head[x];i;i=e[i].nxt) num[color[e[i].v]]++;
            int tt=8,cl;for(int i=0;i<=3;i++) if(tt>num[i]) tt=num[i],cl=i;color[x]=cl;
            for(int i=head[x];i;i=e[i].nxt)
            {
                if(color[x]==color[e[i].v]) d[x]++,d[e[i].v]++;
                if(d[e[i].v]>1) q.push(e[i].v);
            }
        }
        for(int i=1;i<=n;i++) printf("%c",'a'+color[i]);
        puts("");
    }
	return 0;
}
```


---

## 作者：Thunder_S (赞：1)

## Solution

本文最好感性理解。

样例给出了最复杂的，$8$ 个点的完全图的染色方案，因此猜测不存在无解情况。

考虑暴力染色然后调整。先给每个点打上一个随机的颜色，然后将所有不合法的点丢进队列。

对于队列中的点，找到与它相连的点中，存不存在没用过的颜色或者只用过一次的颜色，将其颜色改变，然后用当前点去更新与它相连的点，并把不合法的丢进队列，只到队列为空。

每个点的颜色调整不超过 $10$ 次（吧），所以复杂度是可以过的。

## Code
```cpp
#include<queue>
#include<cstdio>
#include<time.h>
#include<stdlib.h>
#define N 25005
#define M 100005
using namespace std;
int T,n,m,tot,col[N],d[N],num[N];
struct node {int to,next,head;}a[M<<1];
queue<int> q;
void add(int x,int y)
{
    a[++tot].to=y;a[tot].next=a[x].head;a[x].head=tot;
    a[++tot].to=x;a[tot].next=a[y].head;a[y].head=tot;
}
int main()
{
    srand(time(NULL));
    scanf("%d",&T);
    while (T--)
    {
        scanf("%d%d",&n,&m);
        tot=0;
        for (int i=1;i<=n;++i)
            col[i]=-1,d[i]=0,a[i].head=0;
        for (int i=1;i<=m;++i)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            add(x,y);
        }
        for (int i=1;i<=n;++i)
            col[i]=rand()%4;
        while (!q.empty()) q.pop();
        for (int x=1;x<=n;++x)
        {
            for (int i=a[x].head;i;i=a[i].next)
            {
                int y=a[i].to;
                if (col[x]==col[y]) ++d[x]; 
            }
            if (d[x]>1) q.push(x);
        }
        while (!q.empty())
        {
            int x=q.front();q.pop();
            for (int i=a[x].head;i;i=a[i].next)
            {
                int y=a[i].to;
                if (col[x]==col[y]) d[x]--,d[y]--;
            }
            for (int i=0;i<=3;++i)
                num[i]=0;
            for (int i=a[x].head;i;i=a[i].next)
            {
                int y=a[i].to;
                num[col[y]]++;
            }
            int tt=8,nxtc;
            for (int i=0;i<=3;++i)
                if (tt>num[i]) tt=num[i],nxtc=i;
            col[x]=nxtc;
            for (int i=a[x].head;i;i=a[i].next)
            {
                int y=a[i].to;
                if (col[x]==col[y]) d[x]++,d[y]++;
                if (d[y]>1) q.push(y);
            }
        }
        for (int i=1;i<=n;++i)
            printf("%c",'a'+col[i]);
        printf("\n");
    }
    return 0;
}
```

---


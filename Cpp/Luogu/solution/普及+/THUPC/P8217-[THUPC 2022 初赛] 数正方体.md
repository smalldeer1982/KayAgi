# [THUPC 2022 初赛] 数正方体

## 题目描述

小 E 有一块面积为 $n\times m$ 的矩形区域，上面有 $n\times m$ 个边长为 $1$ 的格子，第 $i$ 行 $j$ 列的格子上堆了 $ A_{i,j}$ 个同样大小的正方体积木。小 E 做了某道题之后，突发奇想把这些正方体画成了字符画，然后让你帮他数一数他一共有多少个正方体。我们定义每个正方体为如下格式，并且不会做任何旋转，只会严格以这一种形式摆放：

```
..+---+
./   /| 高
+---+ |
|   | +
|   |/.宽
+---+..
长
```

每个顶点用 $1$ 个 + 表示，长用 $3$ 个 - 表示，宽用 $1$ 个 / 表示，高用两个 | 表示。字符 . 作为背景。中间的空白是空格（ASCII 码为 $32$ ）。

若两个正方体左右相邻，图示为

```
..+---+---+
./   /   /|
+---+---+ |
|   |   | +
|   |   |/.
+---+---+..
```

若两个正方体积木上下相邻，图示为

```
..+---+
./   /|
+---+ |
|   | +
|   |/|
+---+ |
|   | +
|   |/.
+---+..
```

若两个正方体前后相邻，图示为

```
....+---+
.../   /|
..+---+ |
./   /| +
+---+ |/.
|   | +..
|   |/...
+---+....
```

位于前面的正方体的面会遮挡住位于后面的正方体的面。为了让你看得清楚，没有整列正方体被挡在后面，小E保证了 $1\le A_{ij} \le A_{i-1,j}$，$1\le A_{ij}\le A_{i,j-1}$。并且图中没有整行或者整列的 . 。所以，一个字符画对应唯一的矩阵 $A$，一个矩阵 $A$ 也对应一个唯一的字符画。

## 说明/提示

【样例解释】

此时 $A$ 矩阵为 

$$\begin{bmatrix}3 & 3 & 2 \\ 3 & 2 & 1\end{bmatrix}$$

，因为 $3+3+3+2+2+1=14$，所以图中共有 $14$ 个正方体。

【数据范围】

保证 $1\le n,m \le 50$，$1\le A_{ij}\le 100$。（注意这里是 $n$ 和 $m$ 不是 $r$ 和 $c$）

保证 $\forall 1<i\le n$, $A_{ij}\le A_{i-1,j}$。

保证 $\forall 1<j<m$, $A_{ij}\le A_{i,j-1}$。

保证字符画中没有一整行或者一整列是 . 。

小 E 的话：做出这题并不难。不过还是建议在 AC 本题之后看一看题解。

## 样例 #1

### 输入

```
14 17
....+---+---+....
.../   /   /|....
..+---+---+ |....
./   /|   | +---+
+---+ |   |/   /|
|   | +---+---+ |
|   |/   /|   | +
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....```

### 输出

```
14```

# 题解

## 作者：E.Space (赞：31)

看了一下大家的题解，这里出题人还是写一下最简单的官方题解吧。

首先 $n$ 和 $m$ 可以通过输入的最后一行得出。由于 $A_{ij}>0$，最后一行一定是一堆非 `.` 字符加上一堆 `.` 组成，其中非 `.` 字符的个数是 $4m+1$，`.` 的个数是 $2n$。

得到 $n$ 和 $m$ 以后考虑计算每一列有多少个正方体。这个值可以通过顶面高度减去底面高度的差（或者说底面行号减去顶面行号）除以 $3$ 得到。甚至我们不必考虑哪个顶面和哪个底面对应，我们只需要求出所有顶面的行号和和所有底面的行号和就可以了。

由于顶面不会被遮挡，我们可以用字符串 `/   /`（两个斜杠之间三个空格）匹配顶面。这样顶面的行号和就能求了。

底面呢？在 $r-1,r-3,r-5,\cdots,r-2n+1$ 行均分别有 $m$ 个底面，所以所有底面的行号和为 $m\sum\limits_{i=1}^n(r-2i+1)=mn(r-n)$。

匹配顶面可以用 `strstr` 函数。然后这题就做完了。不需要任何的 DFS 或者 Check 函数。

代码：

```cpp
#include<bits/stdc++.h>
char map[555][444];
int main()
{
	int r,c;
	scanf("%d%d\n",&r,&c);
	for(int i=1;i<=r;++i,getchar())
		for(int j=1;j<=c;++j)
			map[i][j]=getchar();               //输入
	int p=strstr(map[r]+1,".")-map[r];
	int m=p-2>>2,n=c-p+1>>1;                           //计算m和n
	int ans=m*n*(r-n);                                 //计算底面行号和
	for(int i=2;i<=r;++i)
	{
		int now=1;
		char* tmp;
		while(tmp=strstr(map[i]+now,"/   /"))
			ans-=i,now=tmp-map[i]+4;           //计算每行有多少个顶面
	}
	printf("%d\n",ans/3);
	return 0;
}
```


---

## 作者：Danno0v0 (赞：14)

非常简单，~~我们甚至可以用视频里的教程做（猝不及防）~~

视频里怎么说的的？

> 学霸题

> 数正方体

> 头顶标数法

OK ，那么我们就用头顶标数法来做就好了（

首先是找头顶：遍历整个图找到所有的顶层（这个：

```
  +---+
 /   /
+---+

```

)

然后标数：判断一下这个顶层是第几层；

然后累计答案就可以了。

然后怎么判断第几层呢？

```
假设我们在这
 ->  +---+
    /   /
   +---+
  /   /
 +---+ 
 |   |

```

```
尝试沿棱向南方移动
     +---+
    /   /
-> +---+
  /   /
 +---+ 
 |   |

```

```
继续尝试沿棱向南方移动
    	 +---+
    	/   /
       +---+
      /   /
  -> +---+ 
     |   |
     |   |
     +---+

```

```
发现不能向南方移动，发现可以向下一层移动，同时这个块的高度+1，接下来继续尝试向南方移动
    	 +---+
    	/   /
       +---+
      /   /
     +---+ 
     |   |
     |   |
  -> +---+

```

然后一直移动到不能动就好了。

先以为是个大模拟，结果只有30行（

```
#include<bits/stdc++.h>
using namespace std;
int r,c,ans;
char mmp[2000][2000];
bool check(int x,int y){
	if(x+2>r||y-2<1||y+4>c||mmp[x+2][y-2]!='+'||mmp[x][y+4]!='+'||mmp[x+2][y+2]!='+'||mmp[x][y+1]!='-'||mmp[x][y+2]!='-'||mmp[x][y+3]!='-')
		return false;
	else
		return true;
}
int main(){
	cin>>r>>c;
	getchar();
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c+1;j++)
			mmp[i][j]=getchar();
	}
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++){
			int x,y;
			if(mmp[i][j]=='+'&&check(i,j)){
				x=i,y=j;
				while(x+2<=r){
					while(mmp[x+2][y-2]=='+')
						x=x+2,y=y-2;
					while(mmp[x+3][y]=='+')
						x=x+3,ans++;
				}
			}
		}
	cout<<ans;
}
```


---

## 作者：PrincessQi (赞：6)

根据小兔老师教我们的方法，我们应该从上往下数。

但是发现找不到头顶，怎么办呢？

考虑底层很容易找，于是我们可以从下往上数。

具体地，考虑每一层底边必然是由 ``+---+`` 和 ``+/+`` （此处无法斜着，大家感性理解一下）构成。所以我们可以容易地在每一层从前往后数。记录一个 $x$ 表示当前横排的正方体数。若下一条边是 ``+---+``，则 $x$ 的值加一。若下一条边是 ``+/+``，则答案加上 $x$。记得在搜索每一层的时候记录上一层的起点和终点。

代码：

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,p,q,ans;
char mp[1005][1005];
void dfs(int x,int y){
	int qwq=0,f=0;
	while(1){
		while(mp[x][y+4]=='+'&&mp[x][y+3]=='-'&&mp[x][y+2]=='-'&&mp[x][y+1]=='-'&&(!(mp[x-2][y+2]=='+'&&mp[x-1][y+1]=='/'))){
			if(f==0)f=1,p=x-3,q=y;
			y+=4,qwq++;
		}
		if(!(mp[x-2][y+2]=='+'&&mp[x-1][y+1]=='/'))break;
		ans+=qwq;
		x-=2;
		y+=2;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("\n");
		for(int j=1;j<=m;j++)
			scanf("%c",&mp[i][j]);
	}
	p=n,q=1;
	while(p>=0&&q>=0){
		int x=p,y=q;
		p=q=-1;
		dfs(x,y);
	}
	printf("%d",ans);
	return 0;
}

```

---

## 作者：Rubidium_Chloride (赞：5)

队伍做出的唯一一道题。我还是太菜了。

WYXkk：这题的难点在于你要看出这是一道可做题。

首先大概算一下 $r,c$ 的范围发现都 $\le 1000$。

观察性质：没有立方体被挡住，则每列立方体数不减。

考虑一列一列计算，列与列的分割：四个 `-`。

如果你看上面一格字符看到了 `|`，说明这一列这一行有这个箱子，继续爬高。

如果你没有看见，看到的是 `/`，说明这一列这一行结束了，累加，换到下一行。

感觉代码写的非常小清新，接下来看代码吧。

```
ll r,c,t,ans;
char ch[N][N];
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    r=read(),c=read();
    for(int i=1;i<=r;i++){
        for(int j=1;j<=c;j++){
            ch[i][j]=getchar();
            while(ch[i][j]!='-'&&ch[i][j]!='+'&&ch[i][j]!='.'&&ch[i][j]!=' '&&ch[i][j]!='/'&&ch[i][j]!='|') ch[i][j]=getchar();
        }
    }
    for(int i=1;i<=c;i+=4){
        t=0;ll y=i,x=r;
        while(x>=1&&y<=c){
            //cout<<x<<' '<<y<<endl;
            if(x-1>=1&&y+1<=c&&ch[x-1][y+1]=='/'){x-=2,y+=2;ans+=t;continue;}
            if(x-1>=1&&ch[x-1][y]=='|'){x-=3;t++;continue;}
            x-=2,y+=2;
        }
        //cout<<ans<<endl;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：罗小菜 (赞：3)

好的，一个普及组的蒟蒻发现自己会做清华校赛的题目，于是满怀激动的写下了这一篇题解（求通过）

其实这道题特别的简单，我们使用一种小学数学最常用的数正方体的方法——头顶标数法！我们其实只需要找出头顶，然后数出它是第几层，然后将所有头顶相加就好了！

1.那么我们该如何去找出这一个头顶呢？我的方法是去定位它的右下角，因为每一个头顶的顶面的右下角它的上面是没有顶点'+'的
并且它的右边有一个顶点'+',右上角有一个顶点'+'这样就可以找出头顶了。

2.我们该如何去数出这个顶面在第几层呢？其实很简单，往下三格如果有'+'号说明它下面还有，就可以继续往下搜索，如果没有'+'号在判断是不是被遮挡了，怎么判断？只要判断它的左下角有没有顶点'+'号就可以了，因为如果没有被遮住的话，顶面的右下角顶点的左下角是没有'+'号的。

于是我们就解决了这一道题，上代码！

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int MAXN=1e4;
int MAP[MAXN][MAXN];
int n,m;
string s;
int ans;
int DFS(int x,int y)
{
	if(MAP[x+3][y]=='+') return DFS(x+3,y)+1;//如果下面有一层
	if(MAP[x+2][y-2]=='+') return DFS(x+2,y-2);//如果是被遮住了
	return 0;//最底层
}
int main()
{
	cin>>n>>m;
	getline(cin,s);//吸掉换行
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			MAP[i][j]=getchar();
		}
		getline(cin,s);//吸掉换行
	}
	for(int i=3;i<=n;i++)
	{
		for(int j=5;j<=m;j++)
		{
			if(MAP[i][j]=='+' && MAP[i][j-4]=='+' && MAP[i-3][j]!='+' && MAP[i-2][j+2]=='+')//判断顶层
			{
				ans+=DFS(i,j);//加上这个顶层及其下面的正方体数量
			}
		}
	}
	cout<<ans;//完美输出
	return 0;
}

---

## 作者：I_am_Accepted (赞：2)

### Preface

[本题の逆（make_data）](https://www.luogu.com.cn/problem/P1058)

学霸题，数正方体，头顶~~浇筑~~标注法！

### Analysis

通过首行前缀 `.` 个数可知从前往后的层数 $layer$。

通过末行后缀 `.` 个数可知从左往右的层数 $n$（好像与题面变量名重了 qwq）。

由于不存在中间凹的情况，存在一种 simple 的做法：

```
......+---+........
...../   /|........
....+---+ |........
....|   | +---+....
....|   |/   /|....
....+---+---+ |....
.../   /|   | +---+
..+---+ |   |/   /|
..|   | +---+---+ |
..|   |/   /   /| +
..+---+---+---+ |/|
./   /   /|   | + |
+---+---+ |   |/| +
|   |   | +---+ |/.
|   |   |/   /| +..
+---+---+---+ |/...
|   |   |   | +....
|   |   |   |/.....
+---+---+---+......
```

![解法](https://cdn.luogu.com.cn/upload/image_hosting/rc5ojrk5.png)

（其实就是差分转原序列）

这样就得到了头顶标注，加起来即可。

### Code

```cpp
//Said no more counting dollars. We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(int i=j;i<=k;i++)
#define gc getchar
#define pc putchar
inline int read(){
	int x=0;char c=gc();bool f=0;
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){x=(x<<3)+(x<<1)+c-48;c=gc();}
	if(f)x=-x;return x;
}
inline void write(int x){if(x<0){pc('-');x=-x;}if(x>9)write(x/10);pc(x%10+'0');}
#define G 450
#define N 55
int r,c,ans=0,layer=0;
char mp[G][G];
int a[N],n,xx[N],yy[N];
int upward(int& x,int& y){
	int res=0;
	while(mp[x-1][y]=='|' || mp[x-1][y]=='+'){
		x--;
		res++;
	}
	return res/3;
}
void calc(){
	For(i,1,n) a[i]+=upward(xx[i],yy[i]);
	For(i,1,n) ans+=a[i];
	For(i,1,n) xx[i]-=2;
	For(i,1,n) yy[i]+=2;
}
signed main(){
	r=read();
	c=read();
	For(i,1,r){
		For(j,1,c) mp[i][j]=gc();
		gc();
	}
	while(mp[1][layer+1]=='.') layer++;
	layer>>=1;
	while(mp[r][n+1]!='.') n++;
	n=(n-1)>>2;
	For(i,1,n) xx[i]=r;
	For(i,1,n) yy[i]=i*4+1;
	For(i,1,layer) calc();
	write(ans);
return 0;}
```

---

## 作者：_⁢　 (赞：2)

题意：给出正方体字符画，求出有多少正方体。

换种思路，从侧面数。

如果我们知道每个侧面的位置 $(x, y)$（图中 `#`）以及与侧面那一**排**（左右相邻）正方体对应的字符 `.` 的数量 $c$，就可以求出这一排正方体的数量 $=\dfrac{y-c}{4}$。（侧面如图中 `#` 所示，相对应的字符 `.` 如图中 `@` 所示）

在第一幅图中，与被统计的侧面对应的 `.` 的个数为 $0$。

```plain
..+---+---+
./   /   /|
+---+---+#|
|   |   |#+
|   |   |/.
+---+---+..
```

```plain
....+---+........
.../   /|........
..+---+ |........
..|   | +---+---+
..|   |/   /   /|
@@+---+---+---+#|
./   /   /|   |#+
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....
```

但是，有时 `.` 会被正方体挡住，这时如何数呢？

```plain
....+---+---+....
.../   /   /|....
..+---+---+ |....
./   /|   | +---+
+---+ |   |/   /|
@@  | +---+---+#|
|   |/   /|   |#+
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....
```

由于重力，在每个 $1 \times m$ 的区域，最左侧的 $A_{i, 1}$ 个正方体一定是左对齐的，因此只要找到没有被挡住的、和被统计这排正方体左对齐的 `.` 就行了。（没有被挡住的、对齐的 `.` 如图中 `%` 所示）

```plain
....+---+---+....
.../   /   /|....
%%+---+---+ |....
./   /|   | +---+
+---+ |   |/   /|
@@  | +---+---+#|
|   |/   /|   |#+
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....
```

如何统计呢？由于重力，在每个 $1 \times m$ 的区域，正方体是像图中这样排列的，因此只要不断向左向上找 `.` 就行了。

```plain
..+---+........
./   /|........
+---+ |........
|   | +---+....
|   |/   /|....
+---+---+ |....
|   |   | +---+
|   |   |/   /|
+---+---+---+ |
|   |   |   | +
|   |   |   |/.
+---+---+---+..
```

时间复杂度：$O(\text{能过})$。

代码：

```cpp
int r, c;
char s[maxn][maxn];
int A;

bool isx(int x, int y) { return x >= 0 && x < r && y >= 0 && y < c && s[x][y] == '|'; }

int main()
{
    scanf("%d%d", &r, &c);
    for (int i = 0; i < r; ++i) {
        char ch = getchar();
        while (ch != '.' && ch != '+' && ch != '|' && ch != '-') ch = getchar();
        for (int j = 0; j < c; ++j) s[i][j] = ch, ch = getchar();
    }
    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            if (isx(i, j) && isx(i + 1, j) && isx(i - 1, j + 2) && isx(i - 1, j + 2)) {
                int x = i - 1, y = j;
                while (y && s[x][y - 1] != '.') {
                    if (s[x][y - 1] == '-') y -= 4;
                    else x -= 3;
                }
                A += (j - y) / 4;
            }
        }
    }
    printf("%d", A);
    return 0;
}
```

---

## 作者：MiRaciss (赞：1)

首先按照宽$\times$高分层，每层从下往上数，当目前往上走就往上走，同时让当前层的高度加1；如果不能往上走就往后走，也就是走 `/` ，每走一次就把总答案加上当前层的高度。

注意细节，按照每一个正方体的右下角的点作为一层的开始。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[6005][6005];
string gsc;
int r,c;
int n,m;

bool Check(int x,int y){ return 1<=x&&x<=n&&1<=y&&y<=m; }
struct zz{ int x,y; };
int f[1005][1005];
vector<zz> q;
int ans=0,sum=0;
bool flag;

void F__k(int i,int j){	// 《关于西西弗强迫我改函数名这件事》 
	if(!Check(i,j)) return ;
	if(Check(i-3,j)&&s[i-3][j]=='+') sum++, F__k(i-3,j);
	else if(Check(i-2,j+2)&&s[i-2][j+2]=='+') ans+=sum,F__k(i-2,j+2);
}

int main(){
	getline(cin,gsc);
	r=0;
	int po;
	for(int i=0;i<gsc.size();i++) if(gsc[i]>='0'&&gsc[i]<='9') r=r*10+(gsc[i]-'0'); else{ po=i+1; break;}
	c=0;
	for(int i=po;i<gsc.size();i++) if(gsc[i]>='0'&&gsc[i]<='9') c=c*10+(gsc[i]-'0'); else break;
	for(int i=1;i<=r;i++){
		getline(cin,gsc);
		for(int j=1;j<=c;j++) s[i][j]=gsc[j-1];	
	}
	n=r,m=c;bool flag=0;
	bool faf=0;
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			sum=0;
			if(s[i][j]!='+') continue;
			if(!flag){flag=1;continue; }
			F__k(i,j);
			faf=1;
		}
		if(faf) goto  FFF;
	}
	FFF:;
	printf("%d\n",ans);
}
```



---


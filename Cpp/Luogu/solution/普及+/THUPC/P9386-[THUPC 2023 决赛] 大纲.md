# [THUPC 2023 决赛] 大纲

## 题目描述

小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。

ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。

知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。**依赖关系不具有传递性。**

你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：

- 每个知识点的难度都是非负整数；
- 对于每个依赖其他知识点的知识点 $x$，设 $\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\max_x$，否则为 $\max_x+1$。**对于不依赖其他知识点的知识点，没有其他限制。**

## 说明/提示

### 样例 1 解释

对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。

对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。

### 数据规模与约定

对于所有测试数据，$1 \le T \le 10^5$，$2 \le n \le 10^5$，$-1 \le a_i \le 10^9$，$1 \le u,v \le n$。  
保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。

### 后记

大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
2
3
0 -1 0
1 2
2 3
3
0 -1 0
1 2
1 3
```

### 输出

```
Reasonable
Unreasonable
```

# 题解

## 作者：Larryyu (赞：6)

## _Description_
给定一棵有 $n$ 个点的树和数列 $a_1,a_2\dots a_n$，若 $a_i=-1$ 表示点 $i$ 的值不确定，否则点 $i$ 的值为非负整数 $a_i$。

你需要给每一个值不确定的点赋一个非负整数，使得该树满足以下条件：
- 设 $maxn_x$ 表示点 $x$ 的儿子中的最大值，若有多个儿子都为 $maxn_x$，则 $x$ 的值为 $maxn_x+1$，否则 $x$ 为 $maxn_x$。

问是否存在一组解，存在输出 ```Reasonable```，不存在输出 ```Unreasonable```。
## _Solution_
对于一个点 $i$，如果其不确定，则它的初始取值下界为 ```0```，上界为 ```1e9```，如果确定，上界为 $a_i$，下界为 $a_i$，设 $u_i$ 表示 $i$ 的上界，$b_i$ 表示 $i$ 的下界。

遍历整棵树，对于点 $x$，求出儿子中最大的 $b_{son_x}$（也就是 $maxn_x$）以及数量 $cnt$ 和最大的 $u_{son_x}$（设为 $maxx_x$，其实只有 ```1e9```和 $a_{son_x}$ 两种，也可以特判是否有不确定的点）。

$b_{son_x}$ 取最大是由 $maxn_x$ 的定义得出的，因为 $b$ 是下界，下界取最大才是 $maxn_x$ 啊，这一点很关键，我在这卡了很久。

由 $maxn_x$ 的定义得出，此时的 $maxn_x$ 还要再加上 $[cnt>1]$。

若 $a_x=-1$，更新上下界，满足条件，记住一定要更新上下界，第三个测试点 ```WA``` 的可能是因为这个。

若 $a_x\ne-1$，分类讨论：
- $a_x=maxn_x$，满足条件。
- $a_x<maxn_x$，下界都比当前大，绝对不满足条件。
- $a_x>maxn_x\ and\ a_x\le maxx_x$，虽然已经确定的儿子的下界取不到，但是儿子中还有不确定的，将其改为 $a_x$ 就满足条件了。
-  $a_x>maxn_x\ and\ a_x>maxx_x$，不满足条件，因为儿子都确定了，所以无法改。

如此 ```dfs``` 即可。
## _Code_
```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 2000000000
int t;
int n;
int tot,head[100010];
int a[100010],b[100010],u[100010];  //a原数值，b下界，u上界
struct edge{
	int to,next;
}e[200010];
void add(int x,int y){
	e[++tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
void clean(){  //多测清空
	tot=0;
	for(int i=1;i<=n;i++){
		head[i]=0;
	}
}
bool dfs(int x,int fax){
	int maxn=-10,cnt=0,maxx=-10;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(y==fax) continue;
		if(!dfs(y,x)) return 0;   //儿子都已经不满足条件了，可以直接退出
		if(b[y]>maxn){
			maxn=b[y];
			cnt=1;
		}else if(b[y]==maxn){
			cnt++;
		}
		maxx=max(maxx,u[y]);
	}
	if(maxn==-10){  //叶子节点
		return 1;
	}
	maxn=maxn+(cnt>1);
	if(a[x]!=-1){
		if(a[x]<maxn) return 0;
		else if(a[x]==maxn) return 1;
		else if(a[x]<=maxx) return 1;
		else return 0;
	}
	if(a[x]==-1){
		u[x]=maxx;
		b[x]=maxn;
		return 1;
	}
}
void solve(){
	clean();
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==-1) u[i]=inf,b[i]=0;
		else b[i]=u[i]=a[i];
	}
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	if(dfs(1,0)) cout<<"Reasonable"<<endl;
	else cout<<"Unreasonable"<<endl;
}
int main(){
	cin>>t;
	while(t--){
		solve();
	}
	return 0;
}
```

---

## 作者：y_kx_b (赞：4)

好题为啥没人做（甚至没人写题解）？难不成真有题号歧视？qwq

题目大意：给出一棵以 $1$ 为根的外向树（一棵只有一个节点（根）入度为 $0$ 其余节点入度均为 $1$ 的有向树）和每个点的点权，若干个点权可能待定（输入时用 `-1` 表示）。问有没有一种给待定点权赋权的方案使得：

- 每个点点权非负。
- 如果结点 $x$ 有儿子，设点 $x$ 的儿子中点权最大值为 $\max_x$。如果点 $x$ 的儿子中恰好有一个点点权为 $\max_x$，那么 $x$ 点点权为 $\max_x$；否则 $x$ 点点权为 $\max_x+1$。如果 $x$ 没有儿子，没有其他限制。

---
~~一看是个绿题，马上想到~~树形 dp。

考虑叶子节点点权待定的情况。此时显然点权取值范围是 $[0,+\infty)$ （如果不考虑其祖先节点）。

那么我们可以令其点权为 $0$ 算出其父亲节点的点权的取值范围（如果待定）。一般地，当一个点点权待定时，我们可以令其儿子的点权都取最小值（如果待定），这样算出来的就是该点点权最小值（易证点权随其儿子点权是单调不减的）。

容易发现如果一个点点权待定，那么其点权取值范围一定没有上界（前提是其至少一个儿子点权取值范围没有上界）。

那么用 $a$ 数组存储当前点权，用另一个 `bool` 数组记录当前节点点权是否有上界（是否固定），我们可以 dfs 这棵树：

- 设当前节点为 $u$。
- 首先把所有儿子都 dfs 一遍，记录儿子节点点权（可能是待定点权的最小值）的最大值和最大值出现次数，用来计算当前节点点权最小可能值，设其为 $x$。同时记录儿子是否有点权取值范围没有上界的点，设为 $flag$：如果有，$flag \gets \text{true}$。
- 当该节点没有儿子时：如果 $a_u=-1$ 那么直接令 $a_u\gets0$（最小值）且点权没有上界；忽略以下步骤，直接返回。
- 当 $a_u\not=-1$ 时：如果 $a_u<x$ 显然不合法（无解）。如果 $flag = \text{false}$ 且 $a_u\not=x$ 也是不合法的（因为儿子点权动不了，$x$ 动不了）。若无上述两种情况则无事发生。
- 当 $a_u=-1$ 时：直接令 $a_u\gets x$，该节点点权是否固定需要用 $flag$ 来判断。

AC code：
```cpp
#include<bits/stdc++.h>
int read() {int x; scanf("%d", &x); return x;}
const int DUST = 327, N = 114514, M = -1;
int head[N], to[N], ne[N], idx1 = 0;
void add(int u, int v) {
    to[idx1] = v, ne[idx1] = head[u], head[u] = idx1++;
}
int a[N];
bool ub[N];//ub[u] = true 代表该点点权未确定（即取值范围上不封顶）
bool dfs(int u) {
	int mx = -1, cnt = 0;
	bool flag = 0;
	for(int i = head[u]; ~i; i = ne[i]) {
		int &v = to[i];
		if(dfs(v) == 0) return 0;
		if(a[v] > mx) mx = a[v], cnt = 1;
		else if(a[v] == mx) cnt++;
		flag |= ub[v];
	}
	if(cnt == 0 && a[u] == -1) a[u] = 0, ub[u] = 1;//叶子节点
	else /**/if(cnt) {
		int x = mx + (cnt > 1);//minimum possible
		if(a[u] != -1) {
			if(a[u] < x) return 0;
		/**/if(!flag && a[u] != x) return 0;
			return 1;
		}
		//a[u] == -1
		if(a[u] == -1 && flag) ub[u] = 1;
		a[u] = x;
	}
	return 1;
}
int main() {
	int T = read();
	while(T--) {
		int n = read();
		idx1 = 0;
		for(int i = 1; i <= n; i++) head[i] = -1, ub[i] = 0;
		for(int i = 1; i <= n; i++) a[i] = read();
		
		for(int i = 1; i < n; i++)
		{
			int u = read(), v = read();
			add(u, v);
		}
		puts(dfs(1) ? "Reasonable" : "Unreasonable");
	}
}
```

呜呜，细节有点多，这题卡了我一天 qwq。

感谢阅读！

---

## 作者：SIXIANG32 (赞：3)

这题没想出来，属实有点丢脸(*/ω＼*)

感觉现在完全成了打板人了/ll

---
观察一下这道题，很容易发现一件事情，那就是叶子节点全确定以后，整棵树也就随之确定了。所以我们现在先从叶子节点开始考虑，观察一下树的下面。

[![pP1CDZF.png](https://s1.ax1x.com/2023/08/17/pP1CDZF.png)](https://imgse.com/i/pP1CDZF)

如果 $a$ 点没有被确定。$b, c$ 已经确定了就相当于 $a$ 点也确定了。如果有一个确定了，另一个没有确定，假设确定了的是 $val$，那么我 $a$ 点可以等于 $val$（另一个权值为 $val - 1$）也可以是大于 $val$ 的任意一个数（另一个权值大于等于 $val$）

如果我 $a$ 确定了那就没什么好说的了。多个点的情况同理。

结合题目我们不难发现两条很有用的性质——

1. 从叶子到根点权单调不降
2. 每个点的点权具有一个单调性，具体来说 $u$ 点没有确定的话，我们记 $u$ 点点权下界为 $f(u)$，那么大于等于 $f(u)$ 的点权都是可以构造出来的。

---
结合上面两条性质，我们容易得到下面一个方法，用树形 dp 维护 $f(u)$ 为一个大框架。然后对于每个点 $u$，统计一下它最小难度应该是什么，记为 $maxn$。如何求 $maxn$？首先算出儿子里面最大的 $f$，然后如果这些最大 $f$ 出现了不止 $1$ 次，那么 $maxn$ 还要加一。

我们用一个数组 $Right_u$ 记录 $u$ 点有没有被确定，这很重要，比如说我 $u$ 的儿子们的 $Right$ 都被确定了，那么 $u$ 点也会被确定。

- 对于 $u$ 所有儿子都被确定（$u$ 被确定）的情况
	- $a(u) = -1$，那么 $f(u) = maxn$
   - $a(u) \not= -1$，那么就判断 $f(u)$ 是否等于 $maxn$，如果不等于就输出 Unreasonable，否则就 $f(u) = maxn$。
   最后把 $Right_u$ 设成 $1$。
- 对于 $u$ 的有些儿子没有被确定（$u$ 没被确定）的情况
	- $a(u) = -1$，此时 $f(u) = maxn$
   - $a(u) \not= -1$，此时要判断 $a(u)$ 是否大于等于 $f(u)$。如果成立，那么 $f(u)= maxn$，同时 $u$ 点也被确定了，$Right(u) = 1$。如果不成立，那么就输出 Unreasonable
   
---
   
细节还是蛮多的……反正我很菜，调了很久，最崩溃的是对拍然后每次第一个点就错了呜哇 QAQ。比如我一开始没考虑到要开一个 $Right$ 记录每个点是否有确定……

所以强烈推荐大家不要看题解代码自己写一遍毕竟我看到隔壁有很多人好像都是面向题解编程，当然这样就体会不到这道题的细节之处了 qwq

我们最后来总结总结这道题，首先是观察一下性质——对于权值有一个“单调性”，这个单调性不难通过手玩小样例得到。然后我们就可以设一个 $f(u)$。我们要将 $u$ 分成已经确定和没有确定两种情况讨论，这样做是必要的。因为如果 $u$ 无法被确定那么只要满足大于等于 $maxn$，但是如果被确定就必须满足 $maxn$。有了这个后面应该就很简单了 qwq

代码，欢迎大家用来对拍~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5;
vector <int> gra[MAXN + 10];
bool ans = 1, Right[MAXN + 10];
int a[MAXN + 10], f[MAXN + 10], n;
void dfs(int u, int fa) {
	if(gra[u].size() == 0 && u == 1) {//一个点的特判
		return ;
	}
	if(gra[u].size() == 1 && u != 1) {//叶子
		if(a[u] != -1) f[u] = a[u], Right[u] = 1;
		else f[u] = 0;
		return ;
	}
	int maxn = -1, cnt = 0, cc = 0;
	for(int p = 0; p < gra[u].size(); p++) {
		int v = gra[u][p];
		if(v == fa) continue;
		dfs(v, u);
		maxn = max(maxn, f[v]);
	}
	for(int p = 0; p < gra[u].size(); p++) {
		int v = gra[u][p];
		if(v == fa) continue;
		if(f[v] == maxn) cnt++;
		if(!Right[v]) cc++;
	}
	if(cnt > 1) maxn++;

	if(!cc) {
		if(a[u] != -1) {
			if(a[u] != maxn) ans = 0;
			else f[u] = a[u], Right[u] = 1;
		}
		else f[u] = maxn, Right[u] = 1;
		return ;
	}
	if(a[u] == -1)
		f[u] = maxn;
	else {
		Right[u] = 1;
		if(a[u] >= maxn) f[u] = a[u];
		else ans = 0;
	}
}
void init() {
	ans = 1;
	cin >> n;
	for(int p = 1; p <= n; p++) gra[p].clear(), f[p] = Right[p] = 0;

	for(int p = 1; p <= n; p++) cin >> a[p];
	for(int p = 1; p < n; p++) {
		int x, y; cin >> x >> y;
		gra[x].push_back(y);
		gra[y].push_back(x);
	}
	dfs(1, 0);
	if(ans == 1) cout << "Reasonable" << endl;
	else cout << "Unreasonable" << endl;
}
int main() {
	int T; cin >> T;
	while(T--) init();
}
```

---

## 作者：船酱魔王 (赞：3)

# P9386 [THUPC 2023 决赛] 大纲 题解

## 题意回顾

扶苏在写 NOI 大纲，有 $ n $ 个知识点，扶苏规定了一些知识点的难度但是一些没有规定，有一些知识点构成依赖关系，依赖关系有向且构成一棵**外向树**，$ 1 $ 是根节点。指向谁代表依赖谁。当一个点依赖的所有点的难度最大值出现一次时，难度为最大值，否则为最大值加一。请判断能否构造出合理的难度。

**多测**，$ \sum n \le 2 \times 10^5 $，$ a_i \le 10^9 $。

## 分析

乍一看题意很复杂。

但是想一想，一个子树的信息该如何表示呢？其实一个子树作为一个整体对其他结点的影响只和他的根节点的取值集合有关。

我们发现每个点的难度越高，他的父节点的难度一定不降，因此有单调性，且每个结点难度加一要不然最大值加一，要不然最大值个数加一，要不然不影响最大值的值和个数，因此对于答案的影响只有一。所以如果一个结点的所有子结点的取值范围是连续自然数，则这个结点也是连续自然数。因为未知结点取值范围是所有自然数，已知结点是固定数，所以所有结点的取值范围是连续的一段自然数。

我们记录每个结点的取值范围的最小和最大值，因为父节点难度随任意子结点难度提升而不降，所以一个结点的最小值即为所有子结点取到最小值的情况，最大值即为所有子结点取到最大值的情况。每个结点算完后判定是否符合要求即可。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 2e5 + 5;
int T;
int n;
int a[N];
vector<int> g[N];
int l[N], r[N];
bool dfs(int u, int fath) {
	if(g[u].size() == 0 || (g[u].size() == 1 && u != 1)) {
		if(a[u] == -1) {
			l[u] = 0;
			r[u] = 1e9 + 1e6;
		} else {
			l[u] = r[u] = a[u];
		}
		return true;
	}
	for(int i = 0; i < g[u].size(); i++) {
		if(g[u][i] != fath) {
			if(!dfs(g[u][i], u)) {
				return false;
			}
		}
	}
	int mx = -1;
	int ct = 0;
	for(int i = 0; i < g[u].size(); i++) {
		if(g[u][i] != fath) {
			if(l[g[u][i]] > mx) {
				mx = l[g[u][i]];
				ct = 1;
			} else if(l[g[u][i]] == mx) {
				ct++;
			}
		}
	} 
	if(ct > 1) {
		mx++;
	}
	l[u] = mx;
	mx = -1;
	ct = 0;
	for(int i = 0; i < g[u].size(); i++) {
		if(g[u][i] != fath) {
			if(r[g[u][i]] > mx) {
				mx = r[g[u][i]];
				ct = 1;
			} else if(r[g[u][i]] == mx) {
				ct++;
			}
		}
	}
	if(ct > 1) {
		mx++;
	}
	r[u] = mx;
	if(a[u] != -1 && (l[u] > a[u] || r[u] < a[u])) {
		return false;
	}
	if(a[u] != -1) {
		l[u] = r[u] = a[u];
	}
	return true;
}
int main() {
	scanf("%d", &T);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d", &n);
		for(int i = 1; i <= n; i++) {
			g[i].clear();
		}
		for(int i = 1; i <= n; i++) {
			scanf("%d", &a[i]);
		}
		int x, y;
		for(int i = 1; i < n; i++) {
			scanf("%d%d", &x, &y);
			g[x].push_back(y);
			g[y].push_back(x);
		}
		if(dfs(1, 0)) {
			printf("Reasonable\n");
		} else {
			printf("Unreasonable\n");
		}
	}
	return 0;
}
```

---

## 作者：Linge_Zzzz (赞：1)

题意不再赘述。

容易想到对于每个点维护其可能取到的权值的上下界 $mn$ 和 $mx$。

对于叶子结点 $u$，如果 $a_u=-1$，那么 $mn_u=0,mx_u=\inf$，否则，$mn_u=mx_u=a_u$。这是显然的。

对于不是叶子结点的结点 $u$，要通过其儿子的 $mn,mx$ 来计算出它的 $mn,mx$。统计儿子中 $mx$ 的最大值 $vmx$，如果有多个相同的最大值，那么 $mx_u=vmx+1$，否则 $mx_u=vmx$。$mn_u$ 同理。

计算出每个结点的 $mn_u$ 和 $mx_u$ 后，如果 $a_u\neq -1$，检查是否满足 $mn_u\leq a_u\leq mx_u$，不满足则不合法。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
typedef long long ll;
typedef pair<int,int> pii;
#define fi first
#define se second
const ll INFL=0x3f3f3f3f3f3f3f3f,mod=1e9+7;
const int N=1e5+10,INF=0x3f3f3f3f;
int n,a[N];
struct edge{
	int v,nxt;
}e[N];
int head[N],cnt=2;
void add(int u,int v){
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
}
bool ans;
int mn[N],mx[N];
void dfs(int u){
	if(!ans)return;
	bool leaf=1;
	int mxx=-1,mnn=-1;
	int cmx=0,cmn=0;
	for(int i=head[u];i;i=e[i].nxt){
		leaf=0;
		dfs(e[i].v);
		if(!ans)return;
		if(mx[e[i].v]>mxx)mxx=mx[e[i].v],cmx=1;
		else if(mx[e[i].v]==mxx)cmx++;
		if(mn[e[i].v]>mnn)mnn=mn[e[i].v],cmn=1;
		else if(mn[e[i].v]==mnn)cmn++;
	}
	mxx+=cmx>1;
	mnn+=cmn>1;
	if(leaf){
		if(a[u]==-1)mn[u]=0,mx[u]=INFL;
		return;
	}
	if(a[u]==-1)mn[u]=mnn,mx[u]=mxx;
	else if(a[u]<mnn||a[u]>mxx)ans=0;
}
void solve(){
	ans=1;
	cin>>n;
	cnt=2;
	memset(head,0,sizeof(int)*(n+10));
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]!=-1)mn[i]=mx[i]=a[i];
		else mn[i]=INFL,mx[i]=0;
	}
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		add(u,v);
	}
	dfs(1);
	cout<<(ans?"Reasonable":"Unreasonable")<<'\n';
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int t;cin>>t;
	while(t--)solve();
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：1)

这题我交了 11 发才过啊 qwq……

考虑 dp，求解出每个知识点可能的最小和最大难度。如何由子树转移到当前点，只需要模拟题目中的方法即可。

**注意：**

1. 题面中的“恰依赖一个难度为 $\text{max}_ x$ 的知识点”，意思是：当前知识点依赖的知识点中，只有一个难度为 $\text{max}_ x$。而不是当前知识点只依赖一个知识点（我就是这里看错了）。
2. 不要用 memset。

```cpp
#include<iostream>
#include<vector>
#include<cstdio>
#include<cstring>
using namespace std;
int t,a[100010],f[100010],g[100010];
vector<int>v[100010];
bool flag;
void dfs(int x)
{
    int maxf=0,maxg=0;
    for(auto y:v[x])
    {
        if(!flag)return;
        dfs(y);
        maxf=max(maxf,f[y]);
        maxg=max(maxg,g[y]);
    }
    int cnt1=0,cnt2=0;
    for(auto y:v[x])
    {
        if(f[y]==maxf)cnt1++;
        if(g[y]==maxg)cnt2++;
    }
    if(a[x]!=-1)
    {
        if(v[x].size()==0)f[x]=a[x];
        else if(cnt1==1)
        {
            if(maxf<=a[x])f[x]=a[x];
            else flag=0;
        }
        else if(cnt1>1)
        {
            if(maxf+1<=a[x])f[x]=a[x];
            else flag=0;
        }
    }
    else
    {
        if(v[x].size()==0)f[x]=0;
        else if(cnt1==1)f[x]=maxf;
        else if(cnt1>1)f[x]=maxf+1;
    }
    if(a[x]!=-1)
    {
        if(v[x].size()==0)g[x]=a[x];
        else if(cnt2==1)
        {
            if(maxg>=a[x])g[x]=a[x];
            else flag=0;
        }
        else if(cnt2>1)
        {
            if(maxg+1>=a[x])g[x]=a[x];
            else flag=0;
        }
    }
    else
    {
        if(v[x].size()==0)g[x]=1e9;
        else if(cnt2==1)g[x]=maxg;
        else if(cnt2>1)g[x]=maxg+1;
    }
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        int n;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
            v[i].clear();
            f[i]=g[i]=0;
        }
        for(int i=1;i<n;i++)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            v[x].push_back(y);
        }
        flag=1;
        dfs(1);
        printf(flag?"Reasonable\n":"Unreasonable\n");
    }
    return 0;
}
```

---


# [THUPC 2024 初赛] 前缀和

## 题目描述

小兰很喜欢随机数。

TA 首先选定了一个实数 $0 < p < 1$，然后生成了 $n$ 个随机数 $x_1,\dots,x_n$，每个数是独立按照如下方式生成的：

- $x_i$ 有 $p$ 的概率是 $1$，有 $(1-p)p$ 的概率是 $2$，有 $(1-p)^2p$ 的概率是 $3$，以此类推。

生成完这些随机数之后，小艾对这个数列求了前缀和，得到了数列 $y_1,\dots,y_n$。

给定 $1\leq l\leq r\leq n$，小兰想知道，期望有多少 $y_i$ 落在 $[l, r]$ 内？


## 说明/提示

### 样例 \#1 解释

有 $1/4$ 的概率，$x_1=1$ 而 $x_2>1$，此时只有 $y_1$ 落在 $[1, 2]$ 内。

有 $1/4$ 的概率，$x_1=1$ 且 $x_2=1$，此时 $y_1,y_2$ 落在 $[1, 2]$ 内。

有 $1/4$ 的概率，$x_1=2$，此时只有 $y_1$ 落在 $[1, 2]$ 内。

所以期望是 $1/4\cdot (1 + 2 + 1) = 1$。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。

## 样例 #1

### 输入

```
3 0.5 1 2
```

### 输出

```
1.000000
```

# 题解

## 作者：tobie (赞：29)

对于此题的式子，有一个非常有趣的想法：

考虑有一排灯，其中每个灯都有 $p$ 的概率点亮。

然后我们惊喜地发现，两个点亮灯之间的距离正好就是题目中说的 $x_i$。

然后我们又惊喜地发现，点亮的第i盏灯的位置正好就是 $x_i$ 的前缀和。因为 $l,r\le n$，我们甚至不需要考虑 $[l,r]$ 之间没有灯被点亮的情况。

于是对于每盏灯，都有 $p$ 的概率对答案造成 $1$ 的贡献，所以答案就是 $(r-l+1)p$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double n,p,l,r;
signed main()
{
	scanf("%lf%lf%lf%lf",&n,&p,&l,&r);
	printf("%0.7lf",(r-l+1)*p);
}
```

---

## 作者：WYXkk (赞：15)

题意：假设一列随机变量 $\{x_n\}$ 独立同分布，其分布为 $P[x=n]=p(1-p)^{n-1}(n\ge 1)$，记 $\{y_n\}$ 为 $\{x_n\}$ 的前缀和，求 $y_n$ 中落在 $[l,r]$ 之间的数的数量的期望。$1\le l\le r\le n$。

假设有一列独立同分布的随机变量 $\{X_n\}$，其分布为 $P[X=1]=p,P[X=0]=1-p$。那么 $x$ 和 $\{X_n\}$ 中第一个 $1$ 的出现位置同分布。

设 $z_n$ 为第 $n$ 个 $1$ 的出现位置。第二个 $1$ 的出现位置，等价于在第一次 $1$ 出现后再计数一次，因此 $z_2-z_1$ 与 $x_2$ 同分布。继续下去可以得到 $\{z_n\}$ 构成的联合分布与 $\{y_n\}$ 构成的联合分布相同。

如果 $\{X_n\}$ 的第 $m$ 位是 $1$，那么它要么是第一个，要么是第二个，……，要么是第 $m$ 个。于是 $p=P[X_m=1]=\sum\limits_{i=1}^mP[z_i=m]=\sum\limits_{i=1}^mP[y_i=m]$。

显然对于 $a>b$ 有 $P[y_a=b]=0$。题目中有 $r\le n$，于是：

$\sum\limits_{i=1}^nP[l\le y_i\le r]=\sum\limits_{i=1}^n\sum\limits_{j=l}^rP[y_i=j]=\sum\limits_{j=l}^r\sum\limits_{i=1}^nP[y_i=j]=\sum\limits_{j=l}^r\sum\limits_{i=1}^jP[y_i=j]=\sum\limits_{j=l}^rp=p(r-l+1)$

所以答案为 $p(r-l+1)$。

---

## 作者：Hadtsti (赞：11)

## 题意简述

给出实数 $p(0<p<1)$，再生成 $n$ 个随机数 $x_1,x_2,\cdots,x_n(1\le n\le 10^9)$。这些随机数都是按照如下方式随机生成的：$x_i$ 为 $1$ 的概率是 $p$，为 $2$ 的概率是 $(1-p)p$，为 $3$ 的概率是 $(1-p)^2p$，以此类推。然后对 $x_i$ 求前缀和 $\displaystyle y_i=\sum_{j=1}^ix_j$，问期望有多少个 $y_i$ 落在给定的 $[L,R]$ 内。

## 题目分析

~~作为我场上唯一一个独立做出的题，我就分享一下我的思路，不一定是最优的（比如显然不如官方题解的直观，也不够简洁）。~~

首先可以看出来的是，由期望的可加性，$[L,R]$ 内 $y_i$ 的个数期望实质上就是 $[L,L+1),[L+1,L+2),\cdots,[R-1,R)$ 内 $y_i$ 的期望个数和落在 $R$ 上的 $y_i$ 的期望个数之和。由于 $y_i$ 一定是整数，这一结果实际上也就是 $y_i$ 落在 $L,L+1,\cdots,R-1,R$ 上的期望个数之和。由于这些期望直接是独立的，可以分别求解。

我们设 $f_j$ 为落在 $j$ 上的 $y_i$ 个数期望，则有初始值 $f_0=1$（因为 $y_0=0$，且 $\forall i>0,y_i>0$），以及递推式：

$$f_j=\sum_{k=1}^j((1-p)^{k-1}p\times f_{j-k})$$  

那么我们就会得到 $f_1=p$，再推一项发现 $f_2=p$。事实上，$\forall j>0,f_j=p$。

考虑使用第二数学归纳法证明：

> **命题：$\forall j\in\mathbb{N_+},f_j=p$**

> 由 $f_1=p\times f_0=p$ 可知，命题对 $j=1$ 成立。

> 若命题对 $\forall j\le k(k\in \mathbb{N_+})$ 成立，则有：

> $\displaystyle f_{k+1}=\sum_{j=1}^{k+1}((1-p)^{j-1}p\times f_{k+1-j})$

> $\displaystyle \ \ \ \ \ \ \ \ =\sum_{j=1}^{k}((1-p)^{j-1}p\times f_{k+1-j})+(1-p)^kp$

> $\displaystyle \ \ \ \ \ \ \ \ =\sum_{j=1}^{k}(1-p)^{j-1}p^2+(1-p)^kp$

> $\displaystyle \ \ \ \ \ \ \ \ =p^2(\sum_{j=1}^{k}(1-p)^{j-1})+(1-p)^kp$

> $\displaystyle \ \ \ \ \ \ \ \ =p^2\times\frac{1-(1-p)^k}{1-(1-p)}+(1-p)^kp$

> $\displaystyle \ \ \ \ \ \ \ \ =p(1-(1-p)^k)+(1-p)^kp$

> $\displaystyle \ \ \ \ \ \ \ \ =p$

> 即命题对 $j=k+1$ 成立。因此命题对 $\forall j\in\mathbb{N_+}$ 均成立。

说了这么多，其实我们就是得到了这样一个结论：对于任意的 $j\in\mathbb{N_+}$，落在 $j$ 上的 $y_i$ 期望个数为 $p$。因此原问题答案就是 $p(R-L+1)$。程序过于简单就不给了。

最后说一下官方给的题解：

> 考虑有无穷多个灯，编号从 $1$ 开始一字排开，每个灯独立有 $p$ 的概率亮起，$1-p$ 的概率是灭的. 

> 我们从左往右数，第一次找到一个灯的编号，这就是 $x_i$ 的分布，所以序列 $\{y_i\}$ 就是第 $i$ 个亮起的灯的位置. 

> 所以问题就是在问：$[L,R]$ 之间，期望有多少亮起的灯？

> 答案就是 $(R-L+1)p$.

> ——官方题解

~~官方题解两三句话就能说明白的东西，我硬是整了这么一堆有的没的，还是我水平不够啊。~~

---

## 作者：rui_er (赞：9)

注意到，$x_i$ 取 $k$ 的概率是 $p(1-p)^{k-1}$，是和为 $1$ 的等比数列，下面考察数列前缀和的性质。

不难想到，概率每次乘以 $1-p$ 像是概率的分步乘法，每一步正是加一的操作。于是可以得到如下转化：初始时 $S=0$，每一时刻 $S$ 先增加一，再以 $p$ 的概率被观测（否则不观测），如果观测到 $S\in[l,r]$ 就将答案加一。于是答案显然为 $(r-l+1)p$。

```cpp
ll n, l, r;
double p;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> p >> l >> r;
    cout << fixed << setprecision(10) << (r - l + 1) * p << endl;
    return 0;
}
```

---

## 作者：Special_Judge (赞：4)

# P9963 [THUPC 2024 初赛] 前缀和 题解

来讲一个和所有题解都不一样的证法。

## 结论

答案即为：$p(r-l+1)$。

## 证明

首先我关注的是每个 $x_i$ 的期望。

引理：每个 $x_i$ 的期望均为 $\dfrac{1}{p}$。

感性理解：我们可以把 $x_i$ 取值的过程看成不断进行成功概率为 $p$ 的判定，一直判定直至判定成功，总共进行的判定次数即为 $x_i$ 的值，因此 $x_i$ 的值的期望即为概率为 $p$ 的事件多少次后发生的期望。那么根据我们的直觉，这个东西就是 $\dfrac{1}{p}$。

严格证明：

注意到 $x_i$ 是 $1$ 的概率为 $p \cdot (1-p)^0$，为 $2$ 的概率为 $p \cdot (1-p)^1$...

所以有：
$$
\begin{aligned}
E(x_i)&=\sum_{i=1}^{\infty}(i\cdot p \cdot (1-p)^{i-1})\\
&=p\sum_{i=1}^{\infty}(i \cdot (1-p)^{i-1})\\
\end{aligned}
$$
设 $s=\sum \limits _{i=1}^{\infty}(i \cdot (1-p)^{i-1})$。

那么：
$$
s=1 + 2 \cdot (1-p) + 3 \cdot (1-p)^2 + \dots \\
(1-p)s=(1-p) + 2 \cdot (1-p)^2+3 \cdot (1-p)^3+ \dots\\
\text{由第一式减第二式可得} \\
s-(1-p)s=1 + (1-p) + (1-p)^2 + (1-p)^3+ \dots
$$
分别化简左右两边。

左边：
$$
s-(1-p)s=s-s+p \cdot s=p \cdot s
$$
右边：
$$
1 + (1-p) + (1-p)^2 + (1-p)^3 \dots=\frac{1}{1-(1-p)}=\frac{1}{p}
$$
所以：
$$
s=\frac{1}{p^2}
$$
故：
$$
\begin{aligned}
E(x_i)&=p \times s\\
&=\frac{1}{p}
\end{aligned}
$$
得证。

---

有了这个结论就很简单了，有多少个 $y_i$ 落在 $[l,r]$ 内可以理解成需要用多少个 $x_i$ 才能覆盖 $[l,r]$，于是：
$$
\begin{aligned}
Ans&=\frac{r-l+1}{\frac{1}{p}}\\
&=p(r-l+1)

\end{aligned}
$$
做完了。


---

## 作者：Vidoliga (赞：3)

直接推就可以了，需要知道的是：

$$E(y\in [l,r])=\sum_{i=l}^{r}\sum_{j=1}^{n}P(y_j= i)$$

设 $f_{i,j}$ 表示 $y_i=j$ 的概率，设生成函数 $[x^j]F_i(x)=f_{i,j}$

状态转移：

$$f_{i,j}=pf_{i-1,j-1}+p(1-p)f_{i-1,j-2}+p(1-p)^2f_{i-1,j-3}+\dots$$

$$f_{i,j}=(1-p)f_{i,j-1}+pf_{i-1,j-1}$$

生成函数递推式：

$$F_i(x)=(1-p)xF_{i}(x)+pxF_{i-1}(x)$$

$$F_{i}(x)=\dfrac{px}{1-(1-p)x}F_{i-1}(x)$$

$$F_{i}(x)=\left(\dfrac{px}{1-(1-p)x}\right)^iF_{0}(x)$$

由于 $F_0(x)=1$，所以不太用管 $F_0(x)$。

$$F_{i}(x)=\dfrac{p^ix^i}{\left(1-(1-p)x\right)^i}$$

下边分母的那个封闭形式展开一下就是：

$$\dfrac{1}{\left(1-(1-p)x\right)^i}=
\left(\sum_{i \geq 0} (1-p)^jx^j\right)^i$$

考虑这个次幂的组合意义，就是 $n$ 不区分球分成 $i$ 分可以空的组，插板法得：

$$
\left(\sum_{i \geq 0} (1-p)^jx^j\right)^i=\sum_{j \geq 0}\dbinom{j+i-1}{i-1}(1-p)^jx^j$$

$$\therefore F_{i}(x)=p^ix^i\sum_{j \geq 0}\dbinom{j+i-1}{i-1}(1-p)^jx^j$$

所以答案即为：

$$E(y\in [l,r])=\sum_{i=l}^{r}\sum_{j=1}^{n}f_{j,i}=E(y\in [l,r])=\sum_{i=l}^{r}\sum_{j=1}^{n}[x^i]F_j(x)$$


$$\sum_{i=l}^{r}\sum_{j=1}^{n}[x^i]F_j(x)=\sum_{j=l}^{r}\sum_{i=1}^{n}[x^j]\left(p^ix^i\sum_{k \geq 0}\dbinom{k+i-1}{i-1}(1-p)^kx^k\right)$$

$$=\sum_{j=l}^{r}\sum_{i=1}^{n}[x^{j-i}]p^i\left(\sum_{k \geq 0}\dbinom{k+i-1}{i-1}(1-p)^kx^k\right)=\sum_{j=l}^{r}\sum_{i=1}^{n}p^i\dbinom{j-1}{i-1}(1-p)^{j-i}$$

因为 $l \leq r\leq n$：

$$=\sum_{j=l}^{r}p\sum_{i=1}^{j}p^{i-1}\dbinom{j-1}{i-1}(1-p)^{j-i}=\sum_{j=l}^{r}p=(r-l+1)p$$

---

## 作者：0x3F (赞：3)

考虑生成函数。

我们发现对于求前缀和之前的序列，每一项的 PGF 为：

$$px+(1-p)px^2+(1-p)^2px^3+\cdots=\frac{px}{px-x+1}$$

因此，对于前缀和后的序列，$y_i$ 的 PGF 为 $(\frac{px}{px-x+1})^i$。

我们将 $y_1$ 到 $y_n$ 加起来，得到生成函数：

$$\sum_{i=1}^{n}(\frac{px}{px-x+1})^i=\frac{1-(\frac{px}{px-x+1})^{n+1}}{1-\frac{px}{px-x+1}}$$

~~于是在这里卡了好久~~

我们注意到 $1\le l\le r\le n$，所以必有 $y_i\ge i$，因此将 $i\ge n+1$ 的项也加入和式中对答案没有影响。

$$\sum_{i=1}^{\infty}(\frac{px}{px-x+1})^i=\frac{1}{1-\frac{px}{px-x+1}}=\frac{px}{1-x}$$

对其系数求前缀和，得到 $F(x)=\frac{px}{(1-x)^2}=p(x+2x^2+3x^3+4x^4+5x^5+\cdots)$。

答案即为 $[x^r]F(x)-[x^{l-1}]F(x)=p(r-l+1)$。

（就这？）

至于它的组合意义是什么？我也不知道。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, l, r;
long double p;
int main() {
	cin >> n >> p >> l >> r;
	cout << fixed << setprecision(10) << p*(r-l+1) << endl;
}
```

---

## 作者：zyn_ (赞：2)

# P9963 [THUPC 2024 初赛] 前缀和

## 题目大意

给定 $n,p,l,r$。对于任意 $i$，$x_i$ 有 $(1-p)^{k-1}p$ 的概率为 $k$。令 $y_i=\sum_{j=1}^{i}x_j$，求落在 $[l,r]$ 中的 $y_i$ 的个数的期望。

## 题目分析

尝试刻画 $y_i$。

假设有一根数轴，一枚棋子初始在 $0$ 处。这枚棋子进行 $n$ 次移动，每次移动如下：

1. 向前走 $1$ 单位长度。

2. 有 $p$ 的概率结束移动。若未结束，则回到操作 $1$。

一次移动后，将目前所在位置做标记。

可以发现，第 $i$ 次移动的步数，与 $x_i$ 的随机方法一致。

那么因为 $y_i$ 为 $x_i$ 的前缀和，故 $y_i$ 即代表第 $i$ 次移动后标记的位置。

故本题化为求 $[l,r]$ 中被标记的点的期望个数。

由于题目保证了 $1\le l\le r\le n$，故 $n$ 次移动后棋子停在的位置代表的数不小于 $n$。

观察移动方法，可以得到，对任意 $[1,n]$ 中的整点位置，其被标记的概率均为 $p$。由期望的线性性，$[l,r]$ 中被标记的点的期望即为 $(r-l+1)p$。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace zyn_{
    int n,l,r;
    double p;
    void solve(){
        cin>>n>>p>>l>>r;
        printf("%.7lf\n",(r-l+1)*p);
    }
}
int main(){
    return zyn_::solve(),0;
}

```

---

## 作者：cosf (赞：1)

## [P9963](https://www.luogu.com.cn/problem/P9963)

众所周知，蒙题大法好。此为考场“做法”。

一眼看过去，也许你可以想到 dp。我们令 $dp_i$ 表示，从期望上来看，$y_{dp_i} = i$。我们可以推出它的递推公式：

$$
\begin{cases}
dp_0 = 0\\
dp_i = \sum_{j = 1}^ip(1-p)^{j - 1}(dp_{i - j} + 1)\\
\end{cases}
$$

于是，我们尝试手推一下，结果：

$$
\begin{cases}
dp_1 = p\\
dp_2 = p(p + 1) + p(1-p) = 2p\\
dp_3 = p(2p + 1) + p(1 - p)(p + 1) + p(1-p)^2 = 3p
\end{cases}
$$

可以猜测，$dp_i = ip$。于是，输出 $p(r - l + 1)$ 就通过了本题。

---

这个为什么是对的呢？

看了一眼官解后豁然开朗。事实上，我们通过 $x$ 来推 $y$ 相当于绕了远路。

这是什么意思呢？就是我们在算 dp 的时候是在枚举上一个 $x$ 为多少。

这样不如，我们假定我们枚举的是上一个数是否存在于 $y$ 之中。

那么，我们令 $dp_i$ 表示 $[1, i]$ 中期望有多少个 $y$，则：

$$
dp_i = p + dp_{i - 1} = ip
$$

这为什么？因为你可以理解为，每一个数都有 $p$ 的概率存在于 $y$ 之中。如果你无法直观地理解，可以这样想：假设对于一个 $x$，如果在随机过程中，它当前中了 $1-p$ 的概率，那么相当于又重新开始了随机，并且从当前数字 $+1$ 开始。如果中了 $p$ 的概率，相当于从下一个数重新开始随机。每一次开始随机影响的 $y$ 的值都是 $+1$ 递增的。所以这个方程是对的。

那么，$p(r - l + 1)$ 这个式子就是完全正确的了。

代码比较简单，不放了。记得保留小数。


---

## 作者：0xyz (赞：0)

我在比赛开始 27 分 29 秒后切掉了，主要是推式子。

首先，不难发现由于 $x_i\ge 1$，所以 $y_i\ge i$，从而 $y_r\ge r$。又由于 $n\ge r$，所以 $n$ 没有用。

由于期望具有可加性，我们可以把问题转化为求 $y_1,y_2,…,y_a$ 中期望有 $f(a)$ 个数 $\le a$。

我们考虑每个 $y_i\le a$ 的概率，枚举每个 $y_i$ 的取值 $b$：

$$\begin{aligned}f(a)&=\sum\limits_{1\le i\le a}\sum\limits_{i\le b\le a}P(y_i=b)\\&=\sum\limits_{1\le i\le a}\sum\limits_{i\le b\le a}\sum\limits_{x_1+x_2+…+x_i=b}\prod\limits_{1\le j\le i}p(1-p)^{x_j-1}\\&=\sum\limits_{1\le i\le a}\sum\limits_{i\le b\le a}\sum\limits_{x_1+x_2+…+x_i=b}p^i(1-p)^{b-i}\\&=\sum\limits_{1\le i\le a}\sum\limits_{i\le b\le a}p^i(1-p)^{b-i}\sum\limits_{x_1+x_2+…+x_i=b}1\\&=\sum\limits_{1\le i\le a}\sum\limits_{i\le b\le a}p^i(1-p)^{b-i}C_{b-1}^{i-1}\\&=p\sum\limits_{1\le i\le a}\sum\limits_{i\le b\le a}p^{i-1}(1-p)^{b-i}C_{b-1}^{i-1}\\&=p\sum\limits_{1\le b\le a}\sum\limits_{1\le i\le b}p^{i-1}(1-p)^{b-i}C_{b-1}^{i-1}\\&=p\sum\limits_{1\le b\le a}(p+1-p)^{b-1}\\&=pa\end{aligned}$$

从而，答案就是 $f(r)-f(l-1)=p(r-l+1)$。

时间复杂度 $O(1)$，空间复杂度 $O(1)$。[代码](https://loj.ac/s/1958337)。

---


# 【模板】缩点

## 题目描述

给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。

允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。


## 说明/提示

对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，$0\le a_i\le 10^3$。

- 2024-11-1 添加了 [hack 数据](https://www.luogu.com.cn/discuss/964940)；

## 样例 #1

### 输入

```
2 2
1 1
1 2
2 1```

### 输出

```
2```

# 题解

## 作者：星星之火 (赞：1458)

缩点，就是把一张有向有环图中的环缩成一个个点，形成一个有向无环图。

首先我介绍一下为什么这题要缩点（有人肯定觉得这是放屁，这不就是缩点的模板题吗？但我们不能这么想，考试的时候不会有人告诉你打什么板上去吧）

根据题目意思，我们只需要找出一条点权最大的路径就行了，不限制点的个数。那么考虑对于一个环上的点被选择了，一整条环是不是应该都被选择，这一定很优，能选干嘛不选。很关键的是题目还允许我们重复经过某条边或者某个点，我们就不需要考虑其他了。因此整个环实际上可以看成一个点（选了其中一个点就应该选其他的点）

那么就正式开始缩环为点了。当然了，首先肯定是找环，为大家推荐两篇博客（不是我宣传，这两篇博客也只是我找的[]
(http://blog.csdn.net/acmmmm/article/details/16361033)）[](http://blog.csdn.net/sentimental_dog/article/details/53790582)

希望博客被我转载的博主不要介意。

看看这两篇博客，我觉得大家就有了一个基本认识了。在缩点操作中，最重要的是维护三个东西，它们在我代码里分别是stac（栈）（ps：之所以不加k是因为万能头文件的荼毒），dfn（时间戳），low(够追溯到的最早的栈中节点的次序号)，详细的解释在代码注释里。

下面就是考虑对这三个东西的运用。详细参考博客（博客带图），需要注意的是，当dfn[u]==low[u]时，表明u一定是环上的一点，且环上的其他点就是u的子树。为什么呢？看代码  
low[x]=dfn[x]=++tim;
           
low[x]=min(low[x],low[v]);

我截取了两句代码，第一句是对点x的low，dfn的初始化。在之后的操作中,low[x]始终取自己子树low[v]的较小值，那么什么情况会使得dfn[u]又“重新”和low[u]相等呢，就是在u的子树中有一条边（就是博客1中的后向边）直接指回了u。这样不就是形成了一个环了吗？

之后就是把环上所有的点的sd都变成这个u，即用u代替整个环，并把权值集中在u上

还有值得注意的，这个栈表示的究竟是什么？（这个在博客1中也有），根据我的理解表示的是当前搜索的一条链上的一个个点吧。

下面我附上代码先

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=10000+15;
int n,m,sum,tim,top,s;
int p[maxn],head[maxn],sd[maxn],dfn[maxn],low[maxn];//DFN(u)为节点u搜索被搜索到时的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号 
int stac[maxn],vis[maxn];//栈只为了表示此时是否有父子关系 
int h[maxn],in[maxn],dist[maxn];
struct EDGE
{
	int to;int next;int from;
}edge[maxn*10],ed[maxn*10];
void add(int x,int y)
{
	edge[++sum].next=head[x];
	edge[sum].from=x;
	edge[sum].to=y;
	head[x]=sum;
}
void tarjan(int x)
{
	low[x]=dfn[x]=++tim;
	stac[++top]=x;vis[x]=1;
	for (int i=head[x];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if (!dfn[v]) {
		tarjan(v);
		low[x]=min(low[x],low[v]);
	}
	    else if (vis[v])
	    {
	    	low[x]=min(low[x],low[v]);
		}
	}
	if (dfn[x]==low[x])
	{
		int y;
		while (y=stac[top--])
		{
			sd[y]=x;
			vis[y]=0;
			if (x==y) break;
			p[x]+=p[y];
		}
	}
}
int topo()
{
	queue <int> q;
	int tot=0;
	for (int i=1;i<=n;i++)
	if (sd[i]==i&&!in[i])
	{
		q.push(i);
        dist[i]=p[i];
	 } 
	while (!q.empty())
	{
		int k=q.front();q.pop();
		for (int i=h[k];i;i=ed[i].next)
		{
			int v=ed[i].to;
			dist[v]=max(dist[v],dist[k]+p[v]);
			in[v]--;
			if (in[v]==0) q.push(v);
		}
	}
    int ans=0;
    for (int i=1;i<=n;i++)
    ans=max(ans,dist[i]);
    return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	scanf("%d",&p[i]);
	for (int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
	}
	for (int i=1;i<=n;i++)
	if (!dfn[i]) tarjan(i);
	for (int i=1;i<=m;i++)
	{
		int x=sd[edge[i].from],y=sd[edge[i].to];
		if (x!=y)
		{
			ed[++s].next=h[x];
			ed[s].to=y;
			ed[s].from=x;
			h[x]=s;
			in[y]++;
		}
	}
	printf("%d",topo());
	return 0;
}
```

在处理了环后，我们就重新建立一张图，以每个环为节点（孤立一个点也算也算环的，其实也就是强联通分量了）。在这张图中我们要dp，显然对于任意边<u,v>,dp[v]=max(dp[v],dp[u]+p[v])，p[v]是v是这个环的总权值。

那么怎么解决无后效性问题呢？答案就是拓扑排序，至于为什么，在我的另一篇题解里我有提及。这下我有安利嫌疑了，但我还是希望大家去看一看，下面我附上链接。

[](https://www.luogu.org/blog/xxzh2425/p1137-lv-xing-ji-hua-ti-xie)
这也是一篇题解，其实主要讲的就是拓扑排序解决DP的无后效性问题了

那么就讲完了，如果有帮助，希望大家不要吝啬自己的赞。

---

## 作者：csxx601cjy (赞：38)

# 题解：[P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387)

upd：
- 2025/5/31：修复挂掉的图，完善文章细节。

**可能更好的阅读体验：[https://0xcjy.github.io/oi/graph/suodian](https://0xcjy.github.io/oi/graph/suodian)。**

## 算法介绍

### 概念

**缩点**（Contraction of Strongly Connected Components）是图论中对有向图进行简化的重要操作，其核心是将图中的强连通分量（SCC）合并为单个节点。

**强连通分量**定义：在有向图中，若任意两个节点 $u$ 和 $v$ 之间存在双向路径，则这些节点构成强连通分量。该分量是满足此条件的极大节点集合。

**Tarjan 算法**由计算机科学家 Robert Tarjan 于 1972 年提出，是一种基于深度优先搜索（DFS）的图论算法，主要用于求解有向图的强连通分量、无向图的割点、无向图的桥。

**拓扑排序**是对有向无环图（DAG）顶点的一种线性序列化方法，使得对于任何的顶点 $u$ 到 $v$ 的有向边, 都可以有 $u$ 在 $v$ 的前面。

### 流程

#### Tarjan（参考 [OI-wiki](https://oi-wiki.org/)）

Tarjan 算法基于对图进行深度优先搜索。我们视每个连通分量为搜索树中的一棵子树，在搜索过程中，维护一个栈，每次把搜索树中尚未处理的节点加入栈中。

在 Tarjan 算法中为每个结点 $u$ 维护了以下几个变量：

1. $dfn_u$ 深度优先搜索遍历时结点 $u$ 被搜索的次序。
2. $low_u$ 在 $u$ 的子树中能够回溯到的最早的已经在栈中的结点。
   设以 $u$ 为根的子树为 $Subtree_u$。 定义为以下结点的最小值：
   - $Subtree_u$ 中的结点
   - 从通过一条不在搜索树上的边能到达 $Subtree_u$ 的结点

按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索，维护每个结点的 $dfn$ 与 $low$ 变量，且让搜索到的结点入栈。每当找到一个强连通元素，就按照该元素包含结点数目让栈中元素出栈。在搜索过程中，对于结点 $u$ 和与其相邻的结点 $v$（$v$ 不是 $u$ 的父节点）考虑三种情况：

1. $v$ 未被访问：继续对 $v$ 进行深度搜索。在回溯过程中，用 $low_v$ 更新 $low_u$。因为存在从 $u$ 到 $v$ 的直接路径，所以 $v$ 能够回溯到的已经在栈中的结点，$u$ 也一定能够回溯到。
2. $v$ 被访问过，已经在栈中：根据 $low$ 值的定义，用 $dfn_v$ 更新 $low_u$。
3. $v$ 被访问过，已不在栈中：说明 $v$ 已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。

这么说不是很直观，用一个例子演示：

```txt
12 21
1 2 3 4 5 6 7 8 9 10 11 12
1 2
2 3
3 4
4 1
5 6
6 5
7 8
8 9
9 7
4 5
6 7
9 10
10 11
11 12
12 11
12 9
3 7
1 5
5 7
7 10
10 12
```

下面这张动图演示了 Tarjan 算法的流程，其中黑色数字是结点编号（为了方便，$dfn$ 和点权也是同样的数字），红色数字是 $low$，被彩色笔圈起来表示出栈了，不同颜色代表不同强连通分量。这个例子中，一共有三个强连通分量（绘制不易，点个赞不过分吧）。

![](https://0xcjy.github.io/assets/demo-BUZdpiMs.gif)

对于一个连通分量图，我们很容易想到，在该连通图中有且仅有一个 $u$ 使得 $dfn_u=low_u$。该结点一定是在深度遍历的过程中，该连通分量中第一个被访问过的结点，因为它的 $dfn$ 和 $low$ 值最小，不会被该连通分量中的其他结点所影响。

因此，在回溯的过程中，判定 $dfn_u=low_u$ 是否成立，如果成立，则栈中 $u$ 及其上方的结点构成一个强连通分量。

#### 缩点

看标题就知道，这是本题的关键。为什么要缩点呢？因为这张图不是 DAG（有向无环图），无法通过 DP 的方式求出答案。仔细思考一下，既然一个强连通分量里所有的点都可以互相到达，我们就可以不用管它的内部结构，直接把它当作成一个点，不就行了吗。这就是缩点。别忘了融合后的点权值是所在强连通分量里所有点的权值之和。缩点之后，这张图变成了一个 DAG，就可以求了。

至于怎么缩点，可以建一个新图，把融合后的点和连接两个不同强连通分量的边加入新图就可以了。

缩好点后的图长这样，是一个 DAG：

![](https://cdn.luogu.com.cn/upload/image_hosting/u4d5ydbp.png)

用肉眼就能很容易看出来，这幅图答案为 $78$。

#### 拓扑排序

有人可能不知道为什么拓扑排序可以求 DAG 的最大权值路径的权值。它其实是和 DP 有关的，用类似 Bellman-Ford 的松弛，写出状态转移方程：

$$dp_v=\max(dp_v,dp_u+a_v)$$

而 DP 执行的顺序，就是拓扑排序的顺序。

答案就是 $\max_{i=1}^n dp_i$。

拓扑排序的流程想必大家都会，不会可以看 [OI-wiki](https://oi.wiki/graph/topo/)，我就不过多介绍了。

## 正确性证明

### 强连通分量（SCC）缩点的正确性

- 性质：一个强连通分量内的所有节点可以互相到达。因此，若路径经过该分量中的任意节点，总能调整路径使其访问分量内所有节点（从而权值总和固定为该分量的权值之和）。
- 权值合并：将每个 SCC 的权值设为内部所有节点权值之和。无论路径如何经过该分量，权值贡献最大化为该总和，重复访问不会增加权值。
- 路径映射：原图中的路径对应缩点后 DAG 中的路径。例如，原路径 `A→B→C`（B、C 属于同一 SCC）会被映射为 `A→SCC_B`，而 SCC_B 的权值包含 B、C 的权值总和。

### DAG 构造的正确性

- 无环性：SCC 之间不存在循环依赖，否则这些 SCC 会被合并为一个更大的 SCC。因此，缩点后的图是 DAG。
- 拓扑序的可行性：DAG 的拓扑排序能保证处理节点时，所有前驱节点的状态已计算完成，为动态规划提供基础。

### tarjan

有关 tarjan 算法的证明，可以参考一篇[博客](https://www.cnblogs.com/ycx-akioi/p/Tarjan-algorithm-solve-SCC.html#正确性证明)。

### 时间复杂度证明

#### Tarjan

Tarjan 算法通过 DFS 遍历所有节点和边，每个节点入栈、出栈各一次，每条边被访问一次，因此为 $O(n+m)$。

#### 缩点构建 DAG

1.  合并 SCC 权值：遍历每个节点，累加其所属 SCC 的权值，复杂度 $O(n)$。
2.  建立 DAG 边：遍历原图所有边，若两端点属于不同 SCC，则在对应 SCC 间添加边，复杂度 $O(m)$。

#### 拓扑排序和 DP

时间复杂度 $O(k+e)$（$k$ 为 SCC 数量，$e$ 为 DAG 边数）

基于入度队列实现，每个 SCC 节点和边处理一次，复杂度 $O(k+e)$。

#### 总复杂度

$O(n+m)+O(n+m)+O(k+e)=O(n+m)$，因为 $k\le n,e\le m$。

## 代码

### 有注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 10, M = 1e5 + 10; //点数和边数
int n, m, a[N], u[M], v[M];
vector<int> g[N], g2[N]; //vector存图
int dfn[N], low[N], cnt = 0, stk[N], top=0, instk[N], belong[N];
//cnt记录访问次序，stk是栈，top栈顶，instk是否在栈里，belong属于哪个强连通分量
int in[N], dp[N], ans=0; //in入度，dp动态规划，ans答案
void tarjan(int u) { //tarjan算法
	dfn[u] = low[u] = ++cnt, stk[++top] = u, instk[u] = 1;
	for(auto i : g[u]) { //遍历下一个点
		if(!dfn[i]) { //没有访问过
			tarjan(i); //去递归它
			low[u] = min(low[u], low[i]); //更新low值
		}
		else if(instk[i]) //访问过且在栈中
			low[u] = min(low[u], dfn[i]); //更新low值
	}
	if(dfn[u] == low[u]) { //找到一个SCC
		do {
			instk[stk[top]] = 0; //出栈
			belong[stk[top]] = u; //这个结点属于u代表的SCC
			if(stk[top] != u) a[u] += a[stk[top]]; //缩点累加权值
		}while(stk[top--] != u); //循环直到栈顶是自己
	}
}
void topo() { //拓扑排序
	queue<int> q;
	for(int i = 1; i <= n; i++) {
		if(i == belong[i] && !in[i]) { //找到一个入度为零的点且代表SCC
			q.push(i); //入队
			dp[i] = a[i]; //初始化dp
		}
	}
	while(!q.empty()) {
		int s = q.front(); q.pop(); //类似广搜
		for(auto i : g2[s]) { //枚举下一个点
			dp[i] = max(dp[i], dp[s] + a[i]); //状态转移
			if(--in[i] == 0) q.push(i); //入度为零就入队
		}
	}
}
int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	for(int i = 1; i <= m; i++) {
		cin >> u[i] >> v[i];
		g[u[i]].push_back(v[i]);
	}
	for(int i = 1; i <= n; i++)
		if(!dfn[i]) tarjan(i); //tarjan
	for(int i = 1; i <= m; i++) { //缩点
		int x = belong[u[i]], y = belong[v[i]];
		if(x != y) { //边的两个顶点不同才被放进新图中
			g2[x].push_back(y);
			in[y]++; //统计入度
		}
	}
	topo(); //拓扑排序
	for(int i = 1; i <= n; i++)
		ans = max(ans, dp[i]); //统计dp答案
	cout << ans; //输出答案
	return 0; //好习惯
}
```

### 高清无注释

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+10,M=1e5+10;
int n,m,a[N],u[M],v[M];
vector<int>g[N],g2[N];
int dfn[N],low[N],cnt=0,stk[N],top=0,instk[N],belong[N];
int in[N],dp[N],ans=0;
void tarjan(int u){
	dfn[u]=low[u]=++cnt,stk[++top]=u,instk[u]=1;
	for(auto i:g[u]){
		if(!dfn[i]){
			tarjan(i);
			low[u]=min(low[u],low[i]);
		}
		else if(instk[i])
			low[u]=min(low[u],dfn[i]);
	}
	if(dfn[u]==low[u]){
		do{
			instk[stk[top]]=0;
			belong[stk[top]]=u;
			if(stk[top]!=u)a[u]+=a[stk[top]];
		}while(stk[top--]!=u);
	}
}
void topo(){
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(i==belong[i]&&!in[i]){
			q.push(i);
			dp[i]=a[i];
		}
	}
	while(!q.empty()){
		int s=q.front();q.pop();
		for(auto i:g2[s]){
			dp[i]=max(dp[i],dp[s]+a[i]);
			if(--in[i]==0)q.push(i);
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++){
		cin>>u[i]>>v[i];
		g[u[i]].push_back(v[i]);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=m;i++){
		int x=belong[u[i]],y=belong[v[i]];
		if(x!=y){
			g2[x].push_back(y);
			in[y]++;
		}
	}
	topo();
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
}
```

## 后记

此题解法不唯一，你也可以用其他算法实现。

这是我第一次写这么长的题解，也是第一次写模板题题解，希望大家可以支持。

---

## 作者：一叶知秋。 (赞：30)

~~用什么DP，网络流无敌！~~

------------
其实这题和 [P3627](https://www.luogu.org/problem/P3627) 挺像的，都是求最长路，只是那题有起点与终点的限制罢了。

然而因为先写的 $P3627$ 的题解，所以关于 $trajan$ 的详细解释我放在 [P3627 [APIO2009]抢掠计划的题解](https://www.luogu.org/blog/wyz598085788/solution-p3627) 里了（~~其实是不想复制进来了~~），要了解 $trajan$ 怎么实现的 $O(N)$ 找环的及其思想的，可以去看看（~~顺便点个赞吧~~）（不过建议初学者组合阅读）

这篇题解我们主要是将后面的部分，求一条最长路，很多人用的 $DP$ 做的（因为题面写着嘛），然而，并不需要那么麻烦，稍微借助一下网络流的思想，多建几条边就出来了。

------------

这道题怎么运用网络流的思想这里讲一下吧，虽然与真正的网络流有些出入，但对以后网络流的学习也有帮助。（已学的大佬可跳过）

对于没有限定起点与终点的求一条最长路（其实真正意义上的网络流（费用流）是可以求多条，但此题只要求求一条，就可以摒弃流量），我们可以创一个超级源点（起点）（后面简称为 $S$ ）与一个超级汇点（终点）（后面简称为 $T$ ）。

然后将 $S$ 向图中每一个点建立一条边权为点权的单向边，将图中每一个点向 $T$ 建一条边权为 $0$ 的单向边。为什么边权会等于点权呢？

其实缩完点后，我们会将每一条边的边权都等于这条边指向的点的点权。因为此时已经没有环了，并不会再走回来，所以同一个点不可能走两次，也就是说同一条边不会走两次，也就不会陷入死循环了，至于使边权等于点权的正确性是显然的（单向边又不能走回去）。

然后直接从 $S$ 跑 $SPFA$ 跑出到 $T$ 的最长路即可。

虽然正确性显然，但此处还是证明一下该算法的正确性（~~因为过了嘛，所以正确~~）：（非正确格式）

反证法。假设 $S$ 到 $T$ 的最长路并不是整个图的最长路。

即 $S$ 到 $T$ 之间的路径中并不包含图中最长路所在的路径。

设图中最长路的路径为 $A->B->C$ （ $A、B、C$ 都是指一段路径，不一定是一个点）那么有我们前面建的边可得：必有一段路径是 $S->A$ ，也必有一段路径是 $C->T$ 。

所以 $S$ 到 $T$ 之间的路径中并不包含图中最长路所在的路径，假设不成立，所以原结论成立。

------------

贴上我丑陋的代码：

```cpp
#include<cstdio>
#define maxn 500005
#define maxm 500005
#define INF 0x3f3f3f3f
inline int read(){
    int r=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){r=(r<<3)+(r<<1)+c-'0';c=getchar();}
    return r*f;
}
int s,t,n,m,N,head[maxn],dis[maxn],q[maxn],uu[maxn],vv[maxn];
bool vis[maxn];
int s_e;
struct E{
    int v,w,nxt;
}e[maxm];
struct E1{
    int v,nxt;
}e1[maxm];
int head1[maxn],s_e1;
int sd[maxn],dfn[maxn],low[maxn];
int cnt,stac[maxn*10],top,s_dfn;
bool ins[maxn];
int d[maxn],c[maxn],diss[maxn];
struct Max_fei{
    inline void a_e(int u,int v,int w){
        e[++s_e]=(E){v,w,head[u]};
        head[u]=s_e;
    }
    inline int spfa(){//SPFA跑最长路
        for(int i=0;i<=N;i++){
            dis[i]=-INF;
            vis[i]=false;
        }
        dis[s]=0;
        vis[s]=true;
        q[0]=s;
        int hd=0,tl=1;
        while(hd^tl){
            int u=q[hd++];
            hd%=maxn;
            for(int i=head[u];i;i=e[i].nxt){
                int v=e[i].v;
                if(dis[v]<dis[u]+e[i].w){
                    dis[v]=dis[u]+e[i].w;
                    if(vis[v])continue;
                    vis[v]=true;
                    q[tl++]=v;
                    tl%=maxn;
                }
            }
            vis[u]=false;
        }
        return dis[t]; //s到t的最长路即是答案
    }
}Flow;
inline void a_e(int u,int v){
    e1[++s_e1]=(E1){v,head1[u]};
    head1[u]=s_e1;
}
inline int min(int a,int b){
	return a<b?a:b;
}
inline int max(int a,int b){
	return a>b?a:b;
}
void tarjan(int u){//trajan缩点
	dfn[u]=low[u]=++s_dfn;
	stac[++top]=u;
  	ins[u]=1;
	for(int i=head1[u];i;i=e1[i].nxt){
		int v=e1[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])low[u]=min(low[u],dfn[v]); 
	}
	if(low[u]==dfn[u]){
		cnt++;
		int v=0;
		while(v!=u){
			v=stac[top--];
			d[v]=cnt;
			ins[v]=0;
			c[cnt]+=diss[v];
		}
	}
}
inline void work(){
    n=read();m=read();
    for(int i=1;i<=n;i++)
    	diss[i]=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        uu[i]=u,vv[i]=v;
        if(u==v)continue;
        a_e(u,v);
    }
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
    s=0;t=cnt+1;//s:超级源点，t:超级汇点
    N=cnt+1;
    for(int i=1;i<=cnt;i++){
    	Flow.a_e(s,i,c[i]);//s向每个点建单向边，边权等于点权
    	Flow.a_e(i,t,0);//每个点向t建单向边，边权等于0
    }
	for(int i=1;i<=m;i++){
		if(d[uu[i]]==d[vv[i]])continue;
        Flow.a_e(d[uu[i]],d[vv[i]],c[d[vv[i]]]);//点权转化为边权
	}
    printf("%d\n",Flow.spfa());//最长路
}
int main(){
    work();
    return 0;
}
```

~~完结偷偷撒花~~ ✿✿ヽ(°▽°)ノ✿

---

## 作者：Colinxu2020 (赞：13)

# 算法介绍

在一个有向图上，**定义一个强连通分量（SCC）是指其的一个子图，使得从这个子图中的任意一个点出发，能够到达其他所有点**，定义一个极大的强连通分量，是指在这个强连通分量的基础上，任意添加一个点，其全部不是强联通分量。

所谓缩点，是指：将一个有向图中，所有极大的强联通分量用一个点表示，将原图中的边，只保留 SCC 间的边，所得的新的有向图，容易发现新的图是一个 DAG。关于这一步正确性的严格证明，请见结论一与结论二。

这里介绍两种求极大强连通分量的算法，Tarjan 和 Kosaraju，他们具有不同的特点，Tarjan 算法扩展性更强，而 Kosaraju 算法更好理解与记忆。

## Tarjan

首先，对于一个联通有向图，我们定义**他的 DFS 生成树是指：从连通有向图上任意一点开始遍历，不断 DFS 遍历整个图，但是不经过重复点，途中经过的边所构成的树**。对于一个任意的有向图，我们可以对于每个连通块分别求出 DFS 生成树，将所得结果成为 DFS 生成树森林。

由 DFS 生成树森林，我们可以将图中的边分为四类：

1. 树边：顾名思义，在生成树森林中的边；
2. 返祖边：由某一点指向他的祖先的边；
3. 横叉边：搜索过程中遇到的已经访问过的点的边，但祖先除外。
4. 前向边：搜索过程中遇到子树中的点所产生的边。

如果不考虑跨树边，图中所有边都属于这四类之一。但跨树边实际上是可能存在的，不过，跨树边必然是单向的，否则会合并成为一个树，而这种单向的边是不可能在 SCC 中的，因此对答案没有影响。

在此给出一个结论：**如果点 $u$ 是在 DFS 搜索过程中，遇到的某个 SCC 的第一个节点，那么这个强连通分量的所有节点一定都在搜索树上 $u$ 的子树中**，证明见结论三。

那么，我们可以把每个 SCC 视为搜索树中某个节点的一个子树的一部分，不妨在搜索过程中维护一个栈，存储 SCC 还不确定的点。

Tarjan 算法会对每个点维护两个值，它的 DFS 序和在它的子树中能够回溯到的最早的已经在栈中的结点的 DFS 序，将这两个分别称为 $dfn_i$ 和 $low_i$。

采用深度优先搜索遍历整棵树，假设 $u$ 是搜索树上的一个点，$v$ 是和它有连边的另一个点，维护可能遇到的几种情况：

1. $v$ 未被遍历过，此时直接搜索 $v$ 的子树，并令 $low_u \gets \min(low_u,low_v)$ 即可。
2. $v$ 已被遍历过，且在栈中，此时直接令 $low_u \gets \min(low_u,dfn_v)$ 即可；
3. $v$ 已被遍历，且不在栈中，此时没有任何影响。

对于一个 SCC，容易发现只有第一个被访问过的结点满足 $dfn_u=low_u$，原理是其他点的 $low$ 都会被这个点影响，因而更小。因此只需要在回溯时判定如果 $dfn_u=low_u$，弹出栈中 $u$ 上方所有点，并组成一个 SCC 即可。

复杂度为严格线性。

## Kosaraju

不妨逆向考虑最后得到的 DAG，假设我们可以通过某种方法求得这个 DAG 的拓扑序，那么显然我们可以按照逆拓扑序逐个遍历每个 SCC，从其中任意一个点开始 DFS，将所有能到达且没有被访问过的点扔到一个 SCC 里，因为不能访问到其他没有被访问过的 SCC 的点。

但我们实际上是做不到这个事情的，考虑一个弱化的版本，我们设其中所有入度为 $0$ 的 SCC 构成的集合为 $S$，出度为 $0$ 的集合是 $T$，不妨只考虑求 $T$，之后再基于 $T$ 更新新产生的 $T$，但 $T$ 也是很难求的，再次将问题转化，$S$ 是很好求的，如果我们把这个图的 DFS 搜索树的后缀遍历拿出来，那么最后一个点显然一定是在 $S$ 中的。

那么我们只要能把 $S$ 变成 $T$ 就都做完了，考虑建立反图，显然原图的 $S$ 就是反图的 $T$ 然后就做完了。

总结一下算法实现，先 DFS 一遍整个图，求出后缀遍历的反序列，之后对于每个点，在反图上 DFS 一下，将所有点加入当前 SCC 即可。

## 扩展：SCC 标号与拓扑排序

### Tarjan

考察 Tarjan 中被最优先处理的是什么样的点，发现显然就是那些没有出度的点，而这和拓扑排序反全是反过来的。而又因为我们的 SCC 编号是按顺序排的，所以本质上相当于把拓扑序反了过来。

**因此，SCC 编号等于逆拓扑序。**

### Kosaraju

考察我们上面提到的算法流程，因为我们最先访问的点是 $S$ 中的点，也就是没有入度的点，这和拓扑序完全相同，因此当使用 Kosaraju 算法时：

**SCC 编号等于拓扑序编号。**


# 正确性证明

因为是模板题所以对于一些比较显然的结论也写了证明 qwq。

## 结论一

### 结论

一个有向图中，所有极大强连通分量不交。

### 证明

反证，假设第一个极大强连通分量包含的点集为 $S$，第二个包含的点集为 $T$，由条件可得 $S \cap T \neq \emptyset$，从 $S \cap T$ 中任选出一个节点 $x$，由定义可得 $S$ 中的所有点都能到达 $x$，$x$ 也能到达所有点，$T$ 具有相同的性质。

由此，对于 $S$ 中的一个点 $u$ 和 $T$ 中的一个点 $v$，必然存在路径 $u \rightarrow x \rightarrow v$ 和 $v \rightarrow x \rightarrow u$，因此，$S \cup T$ 也是一个强连通分量，且比 $S$ 更大，证毕。

## 结论二

### 结论

一个有向图中，如果将所有强连通分量缩成一个点，则这个图一定无环。

### 证明

反证，假设这个图中有环，环上的点代表的 SCC 组成的集合为 $S$，则从 $S$ 中任取两个集合，从这两个集合中分别取一个元素 $x,y$，必然存在一个先从 $x$ 到环上，绕环一周，再到 $y$ 所在 SCC，最后到达 $y$ 的路径，因此 $S$ 应在同一个 SCC 中，证毕。

## 结论三

### 结论

如果点 $u$ 是在 DFS 搜索过程中，遇到的某个 SCC 的第一个节点，那么这个强连通分量的所有节点一定都在搜索树上 $u$ 的子树中

### 证明

反证，假设存在一个节点 $v$ 在 SCC 中，但不在 $u$ 的子树中，由定义可得必然存在 $u$ 到 $v$ 的路径，而又因为 $v$ 不在 $u$ 的子树中，所以这条路径一定经过了离开 $u$ 子树的边，考察这个边可能是哪些种类，显然不可能是树边，因为树边只能指向儿子节点，同理也不能是前向边，因此只能是返祖边或横叉边，而对于这两种情况，通过定义可得这条边的另一端已经被访问过了，由边的类型，$v$ 一定在 $u$ 之前被访问，所以 $u$ 不是最早被访问的节点，矛盾。

# 代码实现

Tarjan:

```cpp
#include<iostream>
#include<vector>
#include<stack>
#include<set>
using namespace std;

const int maxn=1e4+10;
int n,m,ai[maxn],dfn[maxn],low[maxn],instk[maxn],tim,pri[maxn],dp[maxn],scccnt,scc[maxn];
vector<int> grp[maxn],newgrp[maxn]; stack<int> stk;
set<pair<int,int>> antidup;

void tarjan(int x){
    dfn[x]=low[x]=++tim; instk[x]=true; stk.push(x);
    for(auto y:grp[x]){
        if(!dfn[y])tarjan(y),low[x]=min(low[x],low[y]); // 题解情况一
        else if(instk[y])low[x]=min(low[x],dfn[y]); // 题解情况二
    }
    if(low[x]==dfn[x]){
        scccnt++;
        while(stk.top()!=x)pri[scccnt]+=ai[stk.top()],scc[stk.top()]=scccnt,instk[stk.top()]=false,stk.pop();
        pri[scccnt]+=ai[x]; scc[x]=scccnt; stk.pop(); instk[x]=false;
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>ai[i];
    for(int i=1;i<=m;i++){
        int u,v; cin>>u>>v;
        grp[u].push_back(v);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    for(int u=1;u<=n;u++)for(auto v:grp[u])if(scc[u]!=scc[v]){
        if(antidup.count({scc[u],scc[v]}))continue; // 防止重边
        antidup.insert({scc[u],scc[v]});
        newgrp[scc[u]].push_back(scc[v]); // 建新图
    }
    for(int i=1;i<=scccnt;i++)dp[i]=pri[i];
    for(int i=scccnt;i>=1;i--){
        for(auto x:newgrp[i])dp[x]=max(dp[x],dp[i]+pri[x]); // 拓扑序上 DP
    }
    int ans=0;
    for(int i=1;i<=scccnt;i++)ans=max(ans,dp[i]);
    cout<<ans<<endl;
}
```

Kosaraju：

```cpp
#include<iostream>
#include<vector>
#include<stack>
#include<set>
using namespace std;

const int maxn=1e4+10;
int n,m,ai[maxn],pri[maxn],dp[maxn],scccnt,vis[maxn],scc[maxn];
vector<int> grp[maxn],rgrp[maxn],newgrp[maxn]; stack<int> stk;
set<pair<int,int>> antidup;

void dfs1(int x){
    vis[x]=true;
    for(auto y:grp[x])if(!vis[y])dfs1(y);
    stk.push(x);
}
void dfs2(int x, int no){
    scc[x]=no; pri[no]+=ai[x];
    for(auto y:rgrp[x])if(!scc[y])dfs2(y, no);
}
void kosaraju(){
    for(int u=1;u<=n;u++)for(auto v:grp[u])rgrp[v].push_back(u);
    for(int i=1;i<=n;i++)if(!vis[i])dfs1(i);
    for(int i=1;i<=n;i++,stk.pop())if(!scc[stk.top()])dfs2(stk.top(),++scccnt);
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>ai[i];
    for(int i=1;i<=m;i++){
        int u,v; cin>>u>>v;
        grp[u].push_back(v);
    }
    kosaraju();
    for(int u=1;u<=n;u++)for(auto v:grp[u])if(scc[u]!=scc[v]){
        if(antidup.count({scc[u],scc[v]}))continue; // 防止重边
        antidup.insert({scc[u],scc[v]});
        newgrp[scc[u]].push_back(scc[v]); // 建新图
    }
    for(int i=1;i<=scccnt;i++)dp[i]=pri[i];
    for(int i=1;i<=scccnt;i++){
        for(auto x:newgrp[i])dp[x]=max(dp[x],dp[i]+pri[x]); // 拓扑序上 DP
    }
    int ans=0;
    for(int i=1;i<=scccnt;i++)ans=max(ans,dp[i]);
    cout<<ans<<endl;
}
```

# 例题

## [P2341 受欢迎的牛](https://www.luogu.com.cn/problem/P2341)

考察什么样的牛可能成为受欢迎的，考虑把图缩点，缩点后的 DAG 必须是联通的，之后，在 DAG 上找到所有入度为 $0$ 的 SCC，这些 SCC 里的所有点都可以，因为他们能通向所有点，注意特判有 $\geq 2$ 个入度为 $0$ 的点即可。

## [P3387 [模板]缩点](https://luogu.com.cn/problem/P3387)

先考虑 DAG 上的情况，可以在拓扑序上 DP，设 $f_i$ 代表 $i$ 开始的最长路，答案为 $\max f_i$，转移为 $f_i=\max\{f_j\}+a_i$，其中 $i$ 和 $j$ 有连边。、

考虑优化，注意到一个 SCC 内走一个就会把所有的都走了，于是考虑缩点，在缩点得到的 DAG 上 DP 即可，特别的，将每个新点的权值赋为所有其中的点的权值和即可。

[P3627](https://www.luogu.com.cn/problem/P3627) 和这题本质相同。

## [P2194 HXY 烧情侣](https://www.luogu.com.cn/problem/P2194)

显然对于 SCC 只需要烧一次，而且一定会回来，而对于不同 SCC，烧了就回不来了，因此不符合题意，综上所述，只需要缩点后对于每个 SCC 求出其中最小点权，再求和即可。

---

## 作者：2023nsty04 (赞：7)

- Update on 2025.6.10：修改了一张错误的图片。

~~题解优势：~~ 本身作者的水平有限，所以语言会相对通俗。

### 一些概念

1. 强连通分量：\
   若一个有向图 $G$，各个点之间互相连通，我们则称图 $G$ 是强连通的；强连通分量就是指一个强连通的子图。
2. 缩点是什么：\
   缩点用于将有向图的强连通分量缩成一个结点，并构造一个新的有向无环图。这个新的图中的每个结点代表原图的一个强连通分量。

下图就是一个缩点的示例。

![](https://cdn.luogu.com.cn/upload/image_hosting/m83y7n3z.png)

### 为什么要用缩点

通过缩点算法，可以**将有向图中的强连通分量收缩为单个节点**，从而将原图转化为一个**有向无环图**，这使得图的结构**更简单（无环）**，更容易进行后续的处理和优化。

回到这道题，根据强连通分量的定义，强连通分量内的点互相连通，所以如果走到强连通分量中的一个点，那么走完整个强连通分量就是最优的。

### 怎么缩点

#### **Tarjan**

使用 **Tarjan** 算法找出强连通分量。

前情提要：

我们在 **Tarjan** 的过程中会维护三个数组 $dfn$、$low$ 和 $vis$、一个变量 $times$、一个栈。

- $dfn_i$ 表示点 $i$ 是第几个被访问到的。

- $low_i$ 记录的是如果下一个点被访问过，那么会将当前的 $low$ 改为下一个点的 $dfn$ 以此标记是不是一个环。

- $vis_i$ 表示该点是否在栈中。

- $times$ 每到一个点都会自加，方便记录 $dfn$。

接下来，使用 dfs 遍历整个图。

每到一个点都会先将当前点压入栈中，更新 $vis_i$，并将 $dfn_i$ 和 $vis_i$ 更新为自增后的 $times$。

若下一个将要遍历到的点不是上一个点（不走回头路），先将当前的那么考虑：

1. 若下一个点未被访问过，即 `if(!dfn[v])`，那么继续访问，并在回来的时候更新 $low$。
2. 若下一个点被访问过了。
   - 下个点在不栈中，那么就是已经访问完了，不用理他。
   - 下一个点还在栈中，更新 $low$。

#### Tarjan 正确性证明

证明：从 $u$ 出发的 DFS 全部结束回到 $u$ 时，若 `dfn[u] == low[u]`, 此时将栈中 $u$ 及其上方的节点弹出，就找到了一个强连通分量？

我们可以将其拆为两部分进行证明。

1. **为什么 DFS 生成树中的强连通分量必然连续**

> **证明**
>
> 假设节点 $u$ 是一个强连通分量的根，并且存在节点 $v$ 与 $u$ 同属于强连通分量但不在 $u$ 的子树中。由于强连通分量内节点互相可达，$v$ 到 $u$ 的路径必然存在。根据 DFS 的性质：
>
> - 若 $v$ 在 $u$ 之前被访问：$u$ 应在 $v$ 的子树中被访问，与 $u$ 是根矛盾。
>
> - 若 $v$ 在 $u$ 之后被访问：$u$ 到 $v$ 的路径会使 $v$ 在 $u$ 的子树中。

所以我们可以直接将栈中 $u$ 及其上方的节点弹出得到一个强连通分量。

2. **为什么当 `dfn[u] == low[u]` 时弹出栈的节点能构成一个强连通分量**

> **证明**
>
> `low[u] == dfn[u]` 说明 $u$ 无法到达更早的祖先节点。栈中位于 $u$ 之上的节点 $w$ 均满足：
>
> $$
> dfn_u \le low_w \le dfn_w
> $$
>
> 这表明 $w$ 只能到达 $u$ 或 $u$ 的子孙节点，即所有 $w$ 与 $u$ 互相可达。
>
> 若 $u$ 是一个强连通分量的根，根据两个数组的定义，则它的 $low$ 和 $dfn$ 必定，不会被更新，保持为初始的 `low[u]=dfn[u]=++times`，其子孙节点最多只能回溯到 $u$，故当 `low[n] == dfn[n]` 时，$n$ 必定为一个强连通分量的根。

#### 缩点

缩点，将每一个强连通分量缩为一个权值为强连通分量内点的权值总合的点并构造一个新的图。

以一个例子来演示一下。

```
6 7
5 3 8 2 4 5
1 2
2 3
3 4
4 5 
5 3
2 6
6 2
```

![](https://i1.go2yd.com/image.php?url=YD_cnt_177_01jW8PsNDM9q)

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k=0,ans=0,d[100010],vis[100010],dp[100010],head1[100010],head2[100010],times=0,dfn[100010],low[100010],w[100010],sccw[100010],id[100010],cnt=0;
stack<int>s;
queue<int>q;
struct Edge
{
	int u,v,next;
}edg[200010];
void addedge(int u,int v,int head[])
{
	edg[++k].u=u;
	edg[k].v=v;
	edg[k].next=head[u];
	head[u]=k;
} 
void dfs(int x)
{
	s.push(x);
	vis[x]=1;
	dfn[x]=low[x]=++times;
	for(int i=head1[x];i!=0;i=edg[i].next)
	{
		int v=edg[i].v;
		if(!dfn[v])
		{
			dfs(v);
			low[x]=min(low[x],low[v]);
		}
		else if(vis[v])low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		int t;
		do
		{
			t=s.top();
			s.pop();
			vis[t]=0;
			sccw[cnt]+=w[t];
			id[t]=cnt;
		}while(t!=x);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>w[i];
	for(int i=1,u,v;i<=m;i++)
	{
		cin>>u>>v;
		addedge(u,v,head1);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])dfs(i);
	for(int i=1,u,v;i<=m;i++)
	{
		u=id[edg[i].u],v=id[edg[i].v];
		if(u!=v)
		{
			addedge(u,v,head2);
			d[v]++;
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		dp[i]=sccw[i];
		if(!d[i])q.push(i);
	}
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		for(int i=head2[t];i!=0;i=edg[i].next)
		{
			int v=edg[i].v;
			dp[v]=max(dp[v],dp[t]+sccw[v]);
			d[v]--;
			if(!d[v])q.push(v);
		}
	}
	for(int i=1;i<=cnt;i++)ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
} 
```

---

## 作者：langmouren (赞：5)

# STL 版缩点
## 前言
本篇题解为你带来了酣畅淋漓的 STL 体验，我们使用了 vector、queue 和 stack 完成了本篇代码。

~~愿世界都使用 vector 存图。~~

## 缩点介绍
在学习缩点之前，你应该学习了[强连通分量](https://www.luogu.com.cn/problem/B3609)。

我们知道，在有向图中，强连通分量指的是可以相互到达的一些点，那么，如果像本题一样，边可以重复经过，但点权不重复计算，正常对图进行搜索就会导致点权重复统计等意外情况。所以，缩点就出现了。

缩点的本质不是对图的搜索进行了修改，而是对图进行了修改——它建立了一张新的图，这张新的图是**有向无环图**。

它在原来的图上统计所有处于一个强连通分量的点，计算它们的点权和，然后将其作为一个新的点添加到新的图中，并把原图的边重新连接。

接下来我们对缩点的代码进行分析。

## 变量约定
在 Tarjan 的基础上，我们约定以下变量：
- $belong$ 数组：记录旧图中的点在新图中的点的编号。
- $tot$ 数组：记录新图中点的点权。
- $s$ 数组：记录旧图中点的点权。
- vector 类型的 $v1、v2$ 数组：分别存储旧图、新图。
- queue 类型的 $q$：拓扑排序用的队列。
- $in$ 数组：为拓扑排序记录入度。
- $dp$ 数组：为拓扑排序记录答案。

## Tarjan 代码分析

```cpp
if(low[x]==dfn[x]){
    cnt++;
    int tmp;
    do{
        tmp=stk.top();
        stk.pop();

        instack[tmp]=false;
        tot[cnt]+=s[tmp];//记录缩点后的价值
        belong[tmp]=cnt;
    }while(tmp!=x);
}
```
在 Tarjan 代码的基础上，我们对统计强连通分量做出略微修改。

使用 $tot$ 对强连通分量中所有的点权进行统计，$belong$ 记录强连通分量中的所有点在新图中的编号。

## 建新图代码分析

```cpp
for(int i=1;i<=n;i++){
    for(int j=0;j<v1[i].size();j++){//遍历所有记录的点
        int y=v1[i][j];
        if(belong[i]==belong[y]) continue;
        //如果他俩缩完是一个点
        v2[belong[i]].push_back(belong[y]);
        //加入到新的一张图中
        in[belong[y]]++;//入度+1 方便拓扑
    }
}
```

对原图的点遍历其所有边，如果两点在新图中属于一个点，说明他们同处一个强连通分量，那么就跳过。

**注意**，这一步实际上**删去了所有强连通分量内部的连边**，正是这个操作使得新图变成了一张有向无环图。

之后在新图中进行连边，把两个旧点所指向的新点的编号进行连接。

最后，因为本题搜索最长路的方法是拓扑排序，所以记录了新点的入度，如果你使用了如 dijkstra、SPFA 其他算法，请忽略这一步。

## 拓扑代码分析
我们对新图进行正常的拓扑排序：

```cpp
void topo(){
    for(int i=1;i<=cnt;i++){
        if(in[i]==0) q.push(i);//所有入度为0的加入队列
        dp[i]=tot[i];//记录最开始的权值
    }

    while(!q.empty()){
        int x=q.front();
        q.pop();

        for(int i=0;i<v2[x].size();i++){
            int y=v2[x][i];

            dp[y]=max(dp[y],dp[x]+tot[y]);
            in[y]--;
            if(in[y]==0) q.push(y);//等到y的入度为0就加入队列
        }
    }
}
```

当入度为 $0$ 时入队，对自己的连边进行遍历，使用 `dp[y]=max(dp[y],dp[x]+tot[y])` 保证是最优解。

最后对 $dp$ 数组进行遍历取最大值即可。

## 完整代码：
请见[洛谷剪切板](https://www.luogu.com.cn/paste/8ac8wlhq)。

如果你无法访问剪切板，可以使用[洛谷保存站](https://www.luogu.me/paste/8ac8wlhq)。

---

## 作者：夏色祭 (赞：5)

##11篇居然居然没有一个P。。

##来补一发吧

边表存边，tarjan缩点，dfn[u]为节点u搜索的次序编号(时间戳)，low[u]为u或u的子树能够追溯到的最早的栈中节点的次序号。。。

然后根据染色重新建图。。。

对于每个路径的起点跑一边SPFA。。。

主要看代码

今天刚学tarjan的蒟蒻 （滑稽

点这里：[luogu](https://www.byvoid.com/zhs/blog/scc-tarjan/)

丑陋的代码：

```cpp
uses math;
var
  q,dfn,low,b,a,last,next,x,y,c,color,rd,dis,f:array[0..100001]of longint;
  vis:array[0..100001]of boolean;
  n,m,top,tot,i,ans,d,sum:longint;
procedure add(x,y:longint);
begin
  inc(tot);
  a[tot]:=y;
  next[tot]:=last[x];
  last[x]:=tot;
  inc(rd[y]);
end;
procedure tarjan(k:longint);
var
  i,t:longint;
begin
  inc(d); inc(top);
  dfn[k]:=d;low[k]:=d;
  q[top]:=k;vis[k]:=true;
  i:=last[k];
  while i>0 do 
    begin
      t:=a[i];
      if dfn[t]=0 then //如果节点v未被访问过
        begin
          tarjan(t); //继续向下找
          low[k]:=min(low[k],low[t]);
        end
        else
          if vis[t] then low[k]:=min(low[k],dfn[t]); //如果节点t还在栈内
      i:=next[i];
    end;
  if low[k]=dfn[k] then  //如果节点k是强连通分量的根
    begin
      inc(sum);
      while q[top+1]<>k do 
        begin
          color[q[top]]:=sum;
          inc(b[sum],c[q[top]]);
          vis[q[top]]:=false;
          dec(top);
        end;//更新新的一个强连通分量
    end;
end;//tarjan
procedure spfa(start:longint);
var
  i,h,t,x,y:longint;
begin
  fillchar(vis,sizeof(vis),0);
  fillword(dis,sizeof(dis) >> 1,0);// writeln(start);
  h:=0;t:=1;
  f[1]:=start;
  dis[start]:=b[start];
  while h<t do 
    begin
      inc(h);
      x:=f[h];
      vis[x]:=false;
      i:=last[x];
      while i>0 do 
        begin
          y:=a[i];
          if dis[x]+b[y]>dis[y] then
            begin
              dis[y]:=dis[x]+b[y];
              if not vis[y] then 
                begin
                  vis[y]:=true;
                  inc(t);
                  f[t]:=y;
                end;
            end;
          i:=next[i];
        end;
    end;
  for i:=1 to sum do ans:=max(ans,dis[i]); 
end;//SPFA不想多说
begin
  readln(n,m);
  for i:=1 to n do read(c[i]);
  for i:=1 to m do 
    begin
      readln(x[i],y[i]);
      add(x[i],y[i]);//存边
    end;
  for i:=1 to n do 
    if color[i]=0 then tarjan(i);//如果当前点没有染色则去跑一趟tarjan
  //for i:=1 to n do writeln(color[i]);
  fillword(a,sizeof(a) >> 1,0);
  fillword(next,sizeof(next) >> 1,0);
  fillword(last,sizeof(last) >> 1,0);
  fillword(rd,sizeof(rd) >> 1,0);//清空边
  tot:=0;
  for i:=1 to m do 
    if color[x[i]]<>color[y[i]] then add(color[x[i]],color[y[i]]);//重新建图，注意缩点后每个点的新下表是color[i]
  for i:=1 to sum do 
    if rd[i]=0 then spfa(i);//对于每个入度为0的点去跑SPFA
  writeln(ans);
end.

```

---

## 作者：ZZA000HAH (赞：4)

# 缩点

### 缩点（Contraction of Strongly Connected Components）

是图论中对有向图进行简化的重要操作，其核心是将图中的强连通分量（SCC）合并为单个节点。

### 强连通分量（Strongly Connected Component, SCC）


在有向图中，如果两个顶点 $v$ 和 $u$ 之间有一条从 $v$ 到 $u$ 的有向路径，同时也有一条从 $u$ 到 $v$ 的有向路径，即两个顶点 $v$ 和 $u$ 之间存在双向路径，则称这两个顶点强连通，这些强连通的顶点之间构成强连通分量。有向图的极大强连通子图称为强连通分量。

本题做法是将一张有向图的强连通分量缩成一个点，这个点的点权为原来环上点的点权之和。

强连通分量和有向图相关基础知识可见 [OI-WiKi](https://oi-wiki.org/graph/)。

缩点大致过程如下图。
![](https://cdn.luogu.com.cn/upload/image_hosting/r93azpyt.png)

### 缩点步骤

1. 使用动态数组正反存图。
2. 正向 dfs 遍历图并存到存点数组里（图不一定联通；dfs 递归得到的数组顺序是从后往前）
3. 倒序 dfs 遍历存点数组，$ccnum $ 计组数（单点算一组，一个环算一组），$c_i = ccnum$ 表示编号为 $i$ 的点属于 $ccnum $ 组，$w_{ccnum} = w_{ccnum} + val_i$ 将每组中的点求和，其中 $val_i$ 表示点 $i$ 的点权，$w_{ccnum}$ 表示 $ccnum$ 组的组权。
4. 创建新图：循环遍历每个点的边，如果 $c_i \ne c_j$ 就存下这条点 $j$ 到点 $i$ 的有向边，其中 $i,j$ 为原图一条从点 $j$ 到点 $i$ 的有向边的两个顶点，$c_i,c_j$ 分别存的是 $i,j$ 的组数，如果它们不在同一组中，说明它们不是一个环中的两点，那么留着它们之间的边，反正，去掉这条边。


### 正确性证明

（实则一个点也是一个强连通分量，但在下述描述中未特殊标注的地方认为强连通分量是一个环，一个点不能构成环。或者说下述所说的强连通分量是比一个点构成的强连通分量更大一级的强连通分量）

根据上述强连通分量的概念可知，在有向图中，一点 $v$ 到一点 $u$ 的路径有正反两条，而根据有向图性质，两个相连的点之间的路径是单向的。

- 能正确找到强连通分量：对于有向图，根据上述强连通分量的性质，按一定顺序遍历后，将它的边反向，按原来顺序遍历时，如果一个点不在一个强连通分量中，那么从这个点进行 dfs 时就不能到达其他任何一未标记的点（遍历后就标记），而在同一个强连通分量中的所有点，不论从哪个点进行 dfs，最后都能遍历到在此强连通分量中的任意一点，但也不能遍历到在此强连通分量外的任意一未标记的点。这样所有的强连通分量就能够被找到了。
- 点权计算正确性：本题要找到一条路径，使路径经过的点权之和最大，在强连通分量中，无论一条路径如何经过该强连通分量，在该强连通分量中点权贡献最大值为该强连通分量中点权总和，所以将强连通分量缩成一点并赋值该点的点权为原来强连通分量中点权之和，对点权计算并无影响。

说明：为何要缩点，因为下面点权计算用到动态规划，而彼动态规划转移方程要求图中不存在环，要求有向图中强连通分量（包括点）之间不形成彼此依赖。

动态转移方程见下述。

### 模拟过程
下面，在这里模拟一下缩点过程。

给出一张有向图。
![](https://cdn.luogu.com.cn/upload/image_hosting/sn91s6cl.png)

vector 数组中存的点为 $5,3,1,2,4,6$，要倒序遍历数组才是遍历图的原序，即按 $6,4,2,1,3,5$ 的顺序遍历反图。

反图。

![](https://cdn.luogu.com.cn/upload/image_hosting/9k3hj1wb.png)

这个反图按上述顺序只需在 dfs 函数外循环遍历 4 次，点 $1,2,4$ 只需一次循环即可，那在这个过程中即可进行操作（操作见上述方法）。

最后得到新图。

![](https://cdn.luogu.com.cn/upload/image_hosting/i659nrmf.png)

下面给出模块代码和完整代码。

数组。
```cpp
const int maxn=10000+10;
vector<int>G[maxn];//正向存原图
vector<int>rG[maxn];//反向存原图
vector<int>xG[maxn];//存新图
vector<int>a;//存图中的点
```
存图。

```cpp
scanf("%d%d",&n,&m);
for(int i=1; i<=n; i++)
  scanf("%d",&val[i]);//存点权
for(int i=1; i<=m; i++)
{
  int x,y;
  scanf("%d%d",&x,&y);
  G[x].push_back(y);//正向存图
  rG[y].push_back(x);//反向存图
}
```
函数 dfs1。

```cpp
void dfs1(int x)
{
	vis[x]=1;
	for(int i=0; i<G[x].size(); i++)
	{
		int y=G[x][i];
		if(!vis[y]) dfs1(y);
	}
	a.push_back(x);//存点
}
```
函数 dfs2。

```
void dfs2(int x)
{
	vis[x]=1;
	c[x]=ccnum;//记录组数
	w[ccnum]+=val[x];//计算组权
	for(int i=0; i<rG[x].size(); i++)
	{
		int y=rG[x][i];
		if(!vis[y]) dfs2(y);
	}
}
```
找环。

```cpp
void scc_find()
{
	for(int i=1; i<=n; i++)
		if(!vis[i]) dfs1(i);
	memset(vis,0,sizeof(vis));//清零
	for(int i=a.size()-1; i>=0; i--)//正向遍历（数组 a 中是反向存的点）
		if(!vis[a[i]])
		{
			ccnum++;//组数自增
			dfs2(a[i]);
		}
}
```
建新图。

```cpp
void build()
{
	for(int i=1; i<=n; i++)
		for(int j=0; j<G[i].size(); j++)
		{
			int y=G[i][j];
			int a=c[i],b=c[y];
			if(a!=b)//不在同一环中
			{
				xG[a].push_back(b);//建图
				indegree[b]++;//记录点的入度
			}
		}
}
```
接下来按照题目要求求最大点权之和，这里用拓扑和动态规划。

本题主线任务【缩点】已经完成，其余就是求最值了，这里用拓扑和动态规划求，动态转移方程为

$$ dp_v = \max(dp_v , dp_u + w_v) $$

其中 $dp_v$ 表示从根节点到结点 $v$ 的最大点权和，$w_v$ 表示结点 $v$ 的点权，初始化将根节点的点权作为此结点的最大点权和。结点的最大点权和由父节点的最大点权和的集合中的最大项转移来。最后在每个结点的最大点权和中取最大值即可。

### 动态规划正确性证明

在有向图遍历中，对于一节点 $v$ 的 $dp$ 值，只能由其父节点 $u$ 转移而来，即 $dp_u + w_v$，但由于路径不只有一条，而要最大值，那么就需要从节点 $v$ 原本的 $dp$ 值与新转移来的值中取最大值。由动态转移的单一性和路径的多样性可以确定动态转移方程的正确性。



```cpp
int topo()
{
	queue<int>q;
	for(int i=1; i<=ccnum; i++)//由于不一定联通，循环遍历
		if(indegree[i]==0)//找入度为零的点
		{
			q.push(i);
			dp[i]=w[i];//数组 dp 存到这点的最大点权之和
		}
	while(q.size()>0)//经典拓扑遍历
	{
		int u=q.front();
		q.pop();
		int len=xG[u].size();
		for(int i=0; i<len; i++)
		{
			int v=xG[u][i];
			dp[v]=max(dp[v],dp[u]+w[v]);//动规方程，父节点最大值加到此点的距离与此点原值取最大值
			indegree[v]--;
			if(indegree[v]==0)
				q.push(v);
		}
	}
	int mx=0;
	for(int i=1; i<=ccnum; i++) mx=max(mx,dp[i]);//找最大点权之和
	return mx;
}
```
#### 以及最后完整 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=10000+10;
vector<int>G[maxn];//正向存原图
vector<int>rG[maxn];//反向存原图
vector<int>xG[maxn];//存新图
vector<int>a;//存图中的点
bool vis[maxn];
int c[maxn],val[maxn],indegree[maxn],w[maxn],dp[maxn];
int n,m,ccnum;
void dfs1(int x)
{
	vis[x]=1;
	for(int i=0; i<G[x].size(); i++)
	{
		int y=G[x][i];
		if(!vis[y]) dfs1(y);
	}
	a.push_back(x);//存点
}
void dfs2(int x)
{
	vis[x]=1;
	c[x]=ccnum;//记录组数
	w[ccnum]+=val[x];//计算组权
	for(int i=0; i<rG[x].size(); i++)
	{
		int y=rG[x][i];
		if(!vis[y]) dfs2(y);
	}
}
void scc_find()
{
	for(int i=1; i<=n; i++)
		if(!vis[i]) dfs1(i);
	memset(vis,0,sizeof(vis));//清零
	for(int i=a.size()-1; i>=0; i--)//正向遍历（数组 a 中是反向存的点）
		if(!vis[a[i]])
		{
			ccnum++;//组数自增
			dfs2(a[i]);
		}
}
int topo()
{
	queue<int>q;
	for(int i=1; i<=ccnum; i++)//由于不一定联通，循环遍历
		if(indegree[i]==0)//找入度为零的点
		{
			q.push(i);
			dp[i]=w[i];//数组 dp 存到这点的最大点权之和
		}
	while(q.size()>0)//经典拓扑遍历
	{
		int u=q.front();
		q.pop();
		int len=xG[u].size();
		for(int i=0; i<len; i++)
		{
			int v=xG[u][i];
			dp[v]=max(dp[v],dp[u]+w[v]);//动规方程，父节点最大值加到此点的距离与此点原值取最大值
			indegree[v]--;
			if(indegree[v]==0)
				q.push(v);
		}
	}
	int mx=0;
	for(int i=1; i<=ccnum; i++) mx=max(mx,dp[i]);//找最大点权之和
	return mx;
}
void build()
{
	for(int i=1; i<=n; i++)
		for(int j=0; j<G[i].size(); j++)
		{
			int y=G[i][j];
			int a=c[i],b=c[y];
			if(a!=b)//不在同一环中
			{
				xG[a].push_back(b);//建图
				indegree[b]++;//记录点的入度
			}
		}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)
		scanf("%d",&val[i]);//存点权
	for(int i=1; i<=m; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back(y);//正向存图
		rG[y].push_back(x);//反向存图
	}
	scc_find();
	build();
	int ans=topo();
	printf("%d\n",ans);
	return 0;
}
```
End。

---

## 作者：唔啊唔 (赞：4)

作为模板题，这道题的题解还真的有点多耶，但这道题卡了我足足一天，我认为不写一篇题解难解我心头之恨，希望管理员大大可以让我通过

这道题题解中有的大佬是用dp算法来求缩点后的最大点权值之和

而身为蒟蒻的我就只会用Dijkstra算法来跑几次最长路了

如果大家想要学习基本的tarjan模板，请看[这道题](https://www.luogu.org/problem/P2863)更适合初学者

再推荐给大家一篇[文章](https://blog.csdn.net/qq_34374664/article/details/77488976)，里面讲的很详细

解释就都写在代码中了吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,m,a[N],dfn[N],low[N],num,head[N],cnt,vis[N],tot,sum[N],bj[N],head2[N],dis[N];
//bj[]:标记该节点属于第几个强连通分量,sum[]:该强连通分量的总和
//dfn,low,vis:tarjan模板   dis[]:Dijkstra模板 
struct Edge{
	int from,to,next;
}edge[N],bian[N];
//edge[]:存最初的边   bian[]:存缩点后的边 
inline void add(int from,int to){
	num++;
	edge[num].to=to;
	edge[num].next=head[from];
	head[from]=num;
}
//基本的前向星存边 
stack<int>s;	//建栈 
inline void tarjan(int x){	//这下面就是我之所以卡了一天的原因了 
	cnt++;					//不知道为何我写一个tarjan模板都能出玄学错误 
	dfn[x]=low[x]=cnt;		//所以最后搬运了我一篇别的题目的代码才把这道题A掉 
	s.push(x);				
	vis[x]=1;
	for(register int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(dfn[y]==0){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(vis[y]==1){
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(low[x]==dfn[x]){
		int z;
		tot++;
		while(s.top()!=x){
			z=s.top();
			sum[tot]+=a[z];
			vis[z]=0;
			bj[z]=tot;
			s.pop();
		}
		z=s.top();
		sum[tot]+=a[z];
		vis[z]=0;
		bj[z]=tot;
		s.pop();
	}
	return;
}
inline void add2(int from,int to){
	num++;
	bian[num].from=from;
	bian[num].to=to;
	bian[num].next=head2[from];
	head2[from]=num;
}
inline int dij(int x){	//Dijkstra算法最长路模板 
	memset(vis,0,sizeof(vis));
	priority_queue<pair<int,int> >q;
	dis[x]=sum[x];
	q.push(make_pair(dis[x],x));
	while(!q.empty()){
		int tmp=q.top().second;
		q.pop();
		if(vis[tmp]==1)continue;
		vis[tmp]=1;
		for(int i=head2[tmp];i;i=bian[i].next){
			int k=bian[i].to;
			if(dis[k]<dis[tmp]+sum[k]){
				dis[k]=dis[tmp]+sum[k];
				q.push(make_pair(dis[k],k));
			}
		}
	}
	int maxn=0;
//由于我们无法知道终点在哪，所以需要都找一遍，即使最大值是原来跑最长路存下来的值也没有关系 	
	for(register int i=1;i<=tot;i++)	
		maxn=max(maxn,dis[i]);
	return maxn;
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	int x,y;
	for(register int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(register int i=1;i<=n;i++){
		if(dfn[i]==0)
			tarjan(i);
	}
	num=0;
	for(register int i=1;i<=n;i++){	//缩点即把每一个强联通分量看做一个点 
		for(register int j=head[i];j;j=edge[j].next){//再用这几个点来重建一张图来跑最长路 
			int y=edge[j].to;
			if(bj[i]!=bj[y]){
				add2(bj[i],bj[y]);
			}
		}
	}
	int ans=0;
	for(register int i=1;i<=tot;i++){//由于每一个点不一定都连通所以要跑多次最长路 
		ans=max(ans,dij(i));
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：lw393 (赞：2)

# tarjan 题解

**算法讲解**

写这道题，一定要会一个能求强连通分量（SCC）的算法！这里就介绍 tarjan。

~~我知道~~ tarjan 有很多，但是这里只讲在有向图中求强连通分量的一种。

先言 scc：scc（强连通分量）是指一个图中的某个子图。这个子图满足性质：任意两个节点可以通过子图中的边**互相**到达。

再谈 dfs 生成树（我们使用 tarjan 就是建立在这种生成树之上的）。

它是以图上 dfs 遍历走过的边建出来的一棵树。显然地，它并不唯一，但是任意图的任意 dfs 生成树对于 tarjan 的正确性并不影响分毫。

借助图来理解：

![](https://oi-wiki.org/graph/images/dfs-tree.svg)

一棵 dfs 生成树有这样几种边（不一定全都有，反正我给出来的全都有）（取名参照 oi-wiki）：

1. 树边（黑色）：是生成树上的边，每次 dfs 遍历到未访问的点时，就会建一条树边。
2. 返祖边（红色）：是生成树外原图中一个节点向它的祖先连的边。
3. 横向边（蓝色）：一样也是生成树外原图中的一条边。它由一个节点连向非自己在生成树上祖先的节点，
4. 前向边（绿色）：是一个节点连向其子树内的节点的边。

然后正式开始 tarjan。

我们寻找 dfs 生成树与 scc 的关系。

我们发现：如果某个节点是原图中某个 scc 的在 dfs 树中的 dfs 序最小的，则这一整个 scc 都在这个节点的子树内。

通过这个性质，我们可以将一个 scc 在这个树上的一棵子树，在 dfs 过程中维护一个栈，将未处理的节点在栈中处理。

我们在 tarjan 中需维护：
1. 每个节点的 dfs 序（命名为 dfn）；
2. 在这个节点能够回溯到的最早在栈中的节点（命名为 low）。

然后怎么判断是否有一个 scc 彻底遍历完了呢？简单！由于上文的发现，我们知道一个点的 dfn 值等于 low 值，则说明遍历完了。

**正确性分析**

将上面的性质做如下证明：

反证法：假设节点 $v$ 在一个强连通分量中，设这个 scc 中最早出现在 dfs 遍历中的节点为 $u$。若 $v$ 不在以 $u$ 为根的字数内，则 $u, v$ 之间必有一条离开子树的路径。这种路径中的边必有横叉边或返祖边，然而这两种边都要求指向的节点已访问过的，与 $v$ 不在 $u$ 为根的字数内矛盾。

**代码实现**

```cpp
const int N = 1e4 + 5;
vector<int>G[N];//邻接表
int dfn[N], low[N], ins[N], num; //ins 为处理节点是否在栈中的辅助数组。
stack<int>s;

int scc[N], scc_cnt;//记录 scc 编号

void tarjan(int u){
  dfn[u] = ins[u] = ++num, ins[u] = 1;
  s.push(u);
  for(auto v : G[u]){
    if(!dfn[v]) { tarjan(v); low[u] = min(low[v], low[u]); } //dfs 搜索
    else if(ins[v]) { low[u] = min(low[u], dfn[v]); } //更新 low 值
  }
  if(dfn[u] == low[u]){ //说明这个 scc 到头了
    int v; scc_cnt++;
    do{
      v = s.top();
      s.pop();
      scc[v] = scc_cnt, ins[v] = 0;
    }while(u != v);
  }
}
```

时间复杂度看得出来是 $O(n+m)$。

这就是一个完整的 tarjan 模板代码。

**本题做法**

然而对于这道题目不够。这道题目点带点权，要求最长路。我们还要处理一个 scc 中所有点的点权的和值。同时我们将一个 scc 看作一个点，重新建一个图，而这个图没有 scc，所以这个图上一定无环，是一个 DAG，我们直接在图上跑一遍拓补，利用它来进行 dp 即可。

参考代码（无注释）：

```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<stack>
#include<algorithm>
using namespace std;

const int N = 1e5 + 5;

vector<int>G[N], G_scc[N];

int val[N];

int dfn[N], low[N], ins[N], num;
int scc[N], w[N], scc_cnt;
stack<int>s;

void tarjan(int u){
    dfn[u] = low[u] = ++num;
    s.push(u);
    ins[u] = 1;
    for(auto v : G[u]){
        if(!dfn[v]){ tarjan(v); low[u] = min(low[u], low[v]); }
        else if(ins[v]){ low[u] = min(low[u], dfn[v]); }
    }
    if(dfn[u] == low[u]){
        int v;
        scc_cnt++;
        do{
            v = s.top();
            s.pop();
            ins[v] = 0, scc[v] = scc_cnt;
            w[scc_cnt] += val[v];
        }while(v != u);
    }
}

int in[N], dp[N];

void solve(){
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> val[i];
    }
    for(int i = 1; i <= m; i++){
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
    }
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i);
    }
    for(int u = 1; u <= n; u++){
        for(auto v : G[u]){
            if(scc[u] == scc[v]) continue;
            G_scc[scc[u]].push_back(scc[v]);
            in[scc[v]]++;
        }
    }
    queue<int>q;
    for(int i = 1; i <= scc_cnt; i++){
        if(in[i] == 0) q.push(i);
    }
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(auto v : G_scc[u]){
            dp[v] = max(dp[v], dp[u] + w[u]);
            in[v]--;
            if(in[v] == 0) q.push(v);
        }
    }
    int ans = 0;
    for(int i = 1; i <= scc_cnt; i++){
        ans = max(ans, dp[i] + w[i]);
    }
    cout << ans << '\n';
}

int main(){
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

---

## 作者：ddwqwq (赞：2)

大家都是用Tarjan缩点做的，然而本人并不会这种算法，用的是另一种不知姓名的方法。思路：首先dfs求拓扑排序，之后在转置图上以拓扑排序的顺序dfs，每次到达的点属于一个强连通分量（然而我不知道为什么不能在原图上逆序搜索）。搜索同时建立新图，最后dp求解。

```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>

using namespace std;

struct node {
    int aim;
    node *next;//邻接表
};

int stack[50005], stack_size;//栈
void push(int k)
{
    stack[stack_size++] = k;
}
int pop()
{
    stack_size--;
    return stack[stack_size];
}
int top()
{
    return stack[stack_size - 1];
}

void add(node *&head, int aim)//邻接表增加结点
{
    node *p = new(node);
    p->aim = aim;
    p->next = NULL;
    if (head == NULL)
        head = p;
    else
    {
        p->next = head;
        head = p;
    }
}

node *head[10005], *head1[10005], *head2[10005];//原图，转置图，无环分量图
int f[10005], time, N, M;//dfs完成时间，时间，点数，边数
int N1, mark[10005];//无环分量图结点数，给各个分量图打上不同标记
int w[10005], w1[10005];//原图点权，无环分量图点权

void dfs_visit(int i)
{
    node *p = head[i];
    f[i] = 1;
    while (p != NULL)
    {
        if (f[p->aim] == 0)
            dfs_visit(p->aim);
        p = p->next;
    }
    time++;
    f[i] = time;//其实不用记录时间，做个标记就行，这里有点画蛇添足
    push(i);
}

void dfs()//第一次搜索，拓扑排序
{
    for (int i = 1; i <= N; i++)
        if (f[i] == 0)
            dfs_visit(i);
}

void dfs_visit1(int i)
{
    mark[i] = N1;//在转置图上搜索
    node *p = head1[i];
    while (p != NULL)
    {
        if (mark[p->aim] == 0)
            dfs_visit1(p->aim);
        else if (mark[p->aim] != N1)
            add(head2[N1], mark[p->aim]);
        p = p->next;
    }
    w1[N1] += w[i];
}

void dfs1()//第二次搜索
{
    for (int i = 1; i <= N; i++)
    {
        int j = pop();
        if (mark[j] == 0)
        {
            N1++;
            dfs_visit1(j);
        }
    }
}
int d[10005];
int dfs2(int i)//最后的dp
{
    if (d[i] != 0)
        return d[i];

    int max = 0;
    node *p = head2[i];
    while (p != NULL)
    {
        if (dfs2(p->aim) > max)
            max = dfs2(p->aim);
        p = p->next;
    }
    return d[i] = max + w1[i];
}

int main()
{
    int i, u, v;

    scanf("%d %d", &N, &M);

    for (i = 1; i <= N; i++)
        scanf("%d", &w[i]);
    for (i = 0; i < M; i++)
    {
        scanf("%d %d", &u, &v);
        add(head[u], v);//原图
        add(head1[v], u);//转置
    }

    dfs();
    dfs1();

    int max = 0;
    for (i = 1; i <= N1; i++)
        if (dfs2(i) > max)
            max = dfs2(i);

    printf("%d", max);

    system("pause");
    return 0;
}
```

---

## 作者：wangjunyee (赞：2)

## Kosaraju 算法与 Garbow 算法
发现大部分题解都是 tarjan 算法的题解，这里介绍两种其他的求强联通分量的算法，作为扩展思路。其时间复杂度与 tarjan 算法相同，都为 $O(n+m)$。
### Kosaraju 算法
#### 原理
该算法依靠两次简单的 DFS 实现：

第一次 DFS，选取任意顶点作为起点，遍历所有未访问过的顶点，并在回溯之前给顶点编号，也就是后序遍历。

第二次 DFS，对于反向后的图，以标号最大的顶点作为起点开始 DFS。这样遍历到的顶点集合就是一个强连通分量。对于所有未访问过的结点，选取标号最大的，重复上述过程。

两次 DFS 结束后，强连通分量就找出来了，Kosaraju 算法的时间复杂度为 $O(n+m)$。

上述的过程基于以下两个原理。

- 一个有向图 $G$，把 $G$ 所有的边反向，建立反图 $rG$，反图 $rG$ 不会改变原图 $G$ 的强连通性。
- 对原图 $G$ 和反图 $rG$ 各做一次 DFS，可以确定强联通分量数量。

所以，在反图中，每次 DFS 都是从某强联通分量的一个点开始，且不会跳到其他强联通分量（这是因为被反向边阻断，可以自己手动模拟感性理解一下）。

#### 代码（请原谅我的变量名命名习惯）

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int s=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        s=s*10+c-'0';
        c=getchar();
    }
    return s*f;
}
int n,m;
vector<int> a[1000007],ra[1000007],d[1000007],b[1000007];
int w[1000007],col[1000007],jss;
int rd[1000007],vv[1000007],dp[1000007];
bool vis[1000007];
vector<int> too;

void dfs1(int u) {
    vis[u] = 1;
    for(int v : a[u])
        if(!vis[v]) dfs1(v);
    too.push_back(u);
}

void dfs2(int u, int c) {
    col[u] = c;
    vv[c] += w[u];
    for(int v : ra[u])
        if(!col[v]) dfs2(v, c);
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
        w[i]=read();
    
    for(int i=1;i<=m;++i){
        int u=read(),v=read();
        a[u].push_back(v);
        ra[v].push_back(u);
    }
    
    for(int i=1;i<=n;++i)
        if(!vis[i]) dfs1(i);
    reverse(too.begin(), too.end());
    
    for(int u : too)
        if(!col[u]) dfs2(u, ++jss);
    
    for(int u=1;u<=n;++u)
        for(int v : a[u])
            if(col[u] != col[v]) {
                b[col[u]].push_back(col[v]);
                rd[col[v]]++;
            }
    
    queue<int> q;
    for(int i=1;i<=jss;++i)
        if(!rd[i]) q.push(i);
    
    int ans = 0;
    while(!q.empty()){
        int u = q.front(); q.pop();
        dp[u] += vv[u];
        ans = max(ans, dp[u]);
        
        for(int v : b[u]){
            dp[v] = max(dp[v], dp[u]);
            if(--rd[v] == 0) q.push(v);
        }
    }
    
    printf("%d\n", ans);
    return 0;
}    
```

虽然 Kosaraju 算法与 Tarjan 算法的时间复杂度都为 $O(n+m)$，但 Kosaraju 算法需要进行两次 DFS，效率较劣于 Tarjan 算法。但 Kosaraju 算法实现简单，逻辑易懂（或许是吧...）。

### Garbow 算法
建议先学习关于 Tarjan 算法的知识再对照学习该算法。
#### 原理

Garbow 算法是 Tarjan 算法的另一种实现（但并不是优化），Tarjan 算法是用 $dfn$ 和 $low$ 来计算强连通分量的根，Garbow 维护两个栈：主栈存储当前遍历路径的节点，临时栈辅助确定强连通分量的根节点。从节点 $w$ 开始的 DFS 过程中，当一条路径显示这组节点都属于同一个强连通分量时，只要栈顶节点的访问时间大于根节点 $w$ 的访问时间，就从第二个栈中弹出这个节点，那么最后只留下根节点 $w$。在这个过程中每一个被弹出的节点都属于同一个强连通分量。

当回溯到某一个节点 $w$ 时，如果这个节点在第二个栈的顶部，就说明这个节点是强连通分量的起始节点，在这个节点之后搜索到的那些节点都属于同一个强连通分量，于是从第一个栈中弹出那些节点，构成强连通分量。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int s=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        s=s*10+c-'0';
        c=getchar();
    }
    return s*f;
}
int n,m;
vector<int> a[1000007],b[1000007];
int w[1000007],col[1000007],jss;
int rd[1000007],vv[1000007],dp[1000007];
int dfn[1000007],stk1[1000007],stk2[1000007],top1,top2,tot;

void garbow(int u) {
    dfn[u] = ++tot;
    stk1[++top1] = u;
    stk2[++top2] = u;
    for(int v : a[u]) {
        if(!dfn[v]) garbow(v);
        else if(!col[v])
            while(dfn[stk2[top2]] > dfn[v]) top2--;
    }
    if(stk2[top2] == u) {
        top2--;
        jss++;
        do {
            col[stk1[top1]] = jss;
            vv[jss] += w[stk1[top1]];
        } while(stk1[top1--] != u);
    }
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
        w[i]=read();
    
    for(int i=1;i<=m;++i){
        int u=read(),v=read();
        a[u].push_back(v);
    }
    
    for(int i=1;i<=n;++i)
        if(!dfn[i]) garbow(i);
    
    for(int u=1;u<=n;++u)
        for(int v : a[u])
            if(col[u] != col[v]) {
                b[col[u]].push_back(col[v]);
                rd[col[v]]++;
            }
    
    queue<int> q;
    for(int i=1;i<=jss;++i)
        if(!rd[i]) q.push(i);
    
    int ans = 0;
    while(!q.empty()){
        int u = q.front(); q.pop();
        dp[u] += vv[u];
        ans = max(ans, dp[u]);
        
        for(int v : b[u]){
            dp[v] = max(dp[v], dp[u]);
            if(--rd[v] == 0) q.push(v);
        }
    }
    
    printf("%d\n", ans);
    return 0;
}    
```

>注：以上部分内容参考[OI Wiki](https://oi-wiki.org/)。

---

## 作者：Tiger_Rory (赞：1)

第一次写模板题题解，如有不足还请指出。

本题解的解法可以拆分为两个部分，即为 tarjan 和拓扑排序。tarjan 先找出所有 SCC，然后把 SCC 缩成一个点，这样就巧妙地把图上的环处理掉了。随后建新图进行拓扑排序和 DP，就解决掉了本题。

## Part 1 - Tarjan 找 SCC

SCC 是强连通分量。

对于每个节点，我们需要记录以下几个值：

1. $dfn_u$，表示节点 $u$ 是第 $dfn_u$ 个被遍历到的。

2. $low_u$，在 $u$ 的子树中能够回溯到的最早的已经在栈中的结点。

3. 栈数组 $st$，表示可能构成 SCC 的点的集合。

4. $vis_u$，表示 $u$ 节点是否在栈中。

那么现在我们可以开始 tarjan 了，即进行 dfs 处理。令当前节点为 $u$。

首先，我们计算 $dfn_u$ 和 $low_u$ 的初始值（$low_u$ 初始为 $dfn_u$）并将 $u$ 节点入栈，$vis_u$ 自然设为 $1$。

随后，我们开始更新 $low_u$。我们遍历每个 $u$ 出发的边到达的节点 $v$ 进行如下操作。
- 如果 $v$ 没被遍历到，那么先 dfs 处理 $v$，再将 $low_u= \min(low_u,low_v)$。
- 如果遍历过 $v$ 且 $v$ 在栈中，那 $u,v$ 强连通，就将 $low_u=\min(low_u,dfn_v)$。
- 如果没在栈中，那么 $u$ 和 $v$ 无法形成 SCC。
  
如果处理完后 $dfn_u=low_u$，那说明什么呢？

说明一个 SCC 已经出现了！$u$ 及 $u$ 以下的所有子节点没有边指向 $u$ 前遍历的点，即 $u$ 与它的子孙节点构成了一个 SCC。

得到如此结果，直接弹栈直到把 $u$ 也弹掉即可，把 $vis$ 值全部改为 $0$。当然，本题要建新图，所以别忘了记录每个点对应的 SCC，这里弹出的点记录为以 $u$ 为代表的 SCC，用 $fa$ 数组表示。同时，我们需要更新 $u$ 节点的权值，即记录以 $u$ 为代表的 SCC 的权值，求和即可。

## Part 2 - 拓扑排序 & DP

得到了一张有向无环图后，就可以放心大胆地进行拓扑排序了。注意，起点不能是被缩的点，所以要是入度为 $0$ 且代表一个 SCC 的点。

我们考虑 DP 更新以新图每个节点为终点的路径中的最大权值路径的权值，于是有状态转移方程 $dp_v=\max(dp_u+a_v,dp_v)$。

最后答案就是 $dp$ 数组中的最大值。

这样，本题结束，时间复杂度为 $O(n+m)$。因为 SCC 的个数不超过 $n$，新图边数不超过 $m$，所以拓扑排序的时间复杂度不超过 tarjan 的 $O(n+m)$。

## 参考代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m; 
const int N=1e4+10,M=1e5+10; 
vector<int>g[N],ng[N]; 
//ng是新图 
int u[M],v[M],a[N];
int low[N],dfn[N],idx,st[N],top,fa[N];
bool vis[N]; 
int in[N],dp[N]; 

void Tarjan(int u){
	dfn[u]=low[u]=++idx;
	st[++top]=u;
	vis[u]=1; 
	for(int v:g[u]){
		if(!dfn[v]){
			Tarjan(v); 
			low[u]=min(low[u],low[v]);  
		}
		else if(vis[v])low[u]=min(low[u],dfn[v]); 
	}
	if(low[u]==dfn[u]){
		//find SCC! 
		do{ 
			vis[st[top]]=0; 
			fa[st[top]]=u; //标记所属SCC 
			if(u!=st[top])a[u]+=a[st[top]];//更新权值   
		}while(st[top--]!=u);        
	}return;
}

void toposort(){
	queue<int>q; 
	for(int i=1;i<=n;i++){
		if(!in[i]&&i==fa[i]){ //要入度为0且代表SCC 
			q.push(i); 
			dp[i]=a[i]; 
		}
	}
	while(!q.empty()){
		int u=q.front();q.pop(); 
		for(int v:ng[u]){
			dp[v]=max(dp[v],dp[u]+a[v]); 
			if(--in[v]==0){
				q.push(v); 
			}
		}
	}return;
}

int main() {
	cin.tie(0)->sync_with_stdio(0);cout.tie(0);
	cin>>n>>m; 
	for(int i=1;i<=n;i++){
		cin>>a[i]; 
	}
	for(int i=1;i<=m;i++){
		cin>>u[i]>>v[i]; 
		g[u[i]].push_back(v[i]); 
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i])Tarjan(i);  
	}//tarjan找SCC
	for(int i=1;i<=m;i++){
		int x=fa[u[i]],y=fa[v[i]]; 
		if(x!=y){
			ng[x].push_back(y); 
			in[y]++; 
		}
	}//建新图
	toposort();//拓扑排序DP
	int ans=0;  
	for(int i=1;i<=n;i++){
		ans=max(ans,dp[i]); 
	}
	cout<<ans; 
	return 0;
}
```


## 致谢

参考了[这篇讲解 tarjan 的题解](https://www.luogu.com.cn/article/xwq1ati3)和[这篇本题题解](https://www.luogu.com.cn/article/01jsk0i5)，写得很详细，感谢。

## 习题巩固

1. [P2746 校园网](https://www.luogu.com.cn/problem/P2746)
2. [P2812 校园网加强版](https://www.luogu.com.cn/problem/P2812)
3. [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)

以上是缩点的习题，tarjan 的习题还有很多。

希望这篇题解能给大家带来帮助。

---


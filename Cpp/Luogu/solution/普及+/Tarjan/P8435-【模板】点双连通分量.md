# 【模板】点双连通分量

## 题目描述

对于一个 $n$ 个节点 $m$ 条无向边的图，请输出其点双连通分量的个数，并且输出每个点双连通分量。

## 说明/提示

**样例四解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/huvwgbuo.png)

相同颜色的点为同一个分量里的结点。

**温馨提示：请认真考虑孤立点与自环（样例五）的情况。**

------------
**数据范围：**
对于 $100\%$ 的数据，$1 \le n \le 5 \times10 ^5$，$1 \le m \le 2 \times 10^6$。

| subtask | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1 \le n \le 100$ | $1 \le m \le 500$ | $25$ |
| $2$ | $1 \le n \le 5000$ | $1 \le m \le 5 \times 10^4$ | $25$ |
| $3$ | $1 \le n \le 2\times 10^5$ | $1 \le m \le 5\times 10^5$ | $25$ |
| $4$ | $1 \le n \le 5 \times10 ^5$ | $1 \le m \le 2 \times 10^6$ | $25$ |

本题不卡常，时间限制与空间限制均已开大，正确的解法均可通过。

------------

### 数据更新
- $2022/7/14$ 加强数据
- $2022/11/26$  新增 $10$ 组较小的数据（$1\le n, m \le 10$)，方便选手调试。
- $2022/12/31$ 重组 $subtask$，并加入若干组极端数据。
- $2023/1/1$ 发现昨天新加入的数据出了问题，已修改。
------------

惊喜：AC 后记得把鼠标放到测试点上看反馈信息，有惊喜哦。

## 样例 #1

### 输入

```
5 8
1 3
2 4
4 3
1 2
4 5
5 1
2 4
1 1```

### 输出

```
1
5 1 2 3 4 5```

## 样例 #2

### 输入

```
5 3
1 2
2 3
1 3```

### 输出

```
3
1 4
1 5
3 1 2 3```

## 样例 #3

### 输入

```
6 5
1 3
2 4
1 2
4 6
2 3```

### 输出

```
4
2 6 4
2 4 2
3 3 2 1
1 5```

## 样例 #4

### 输入

```
7 8
1 3
2 4
3 5
2 5
6 4
2 5
6 3
2 7```

### 输出

```
3
2 7 2
5 5 2 4 6 3
2 3 1```

## 样例 #5

### 输入

```
1 1
1 1```

### 输出

```
1
1 1```

# 题解

## 作者：Usada_Pekora (赞：188)

七月二十一号更新：更正了一处笔误。

先介绍几个概念：

连通分量：无向图中，满足任意两点之间都有路径相连的极大连通子图。也就是说，抽离出一些点以及它们之间的边，满足这些点任意两点之间，可以直接或间接到达对方，在这个前提下，满足抽离出的图越大越好，把抽离出的图叫做连通分量。

割点：无向图中，删除该点及与其相连的边后，图的连通分量数量增加，则称其为割点。换而言之，删除一个割点及相关边后，图中原来连通的两点不再连通，从而使得一个连通分量分裂成两个（或多个）连通分量。

点双连通：若对于一个无向图，其任意一个节点对于这个图本身而言都不是割点，则称其点双连通。也就是说，删除任意点及其相关边后，整个图仍然属于一个连通分量。

点双连通分量：无向图中，极大的点双连通子图。与连通分量类似，抽离出一些点及它们之间的边，使得抽离出的图是一个点双连通图，在这个前提下，使得抽离出的图越大越好。

先讲讲怎么求割点：

引入 Tarjan 算法。

我们把 DFS 遍历无向图过程中形成的图叫做搜索树，其中，从 $u$ 到一个未被搜索过的节点 $v$ 的一条边叫树边，回溯到一个祖先 $v$ 的边叫返祖边。

定义 $dfn_u$ 表示 $u$ 在搜索树中的访问时间戳（第几个搜到），$low_u$ 表示 $u$ 通过返祖边可回溯到的最小时间戳。

初始时，$low_u=dfn_u$。

对于一条树边 $(u,v)$，$low_u=\min\{low_v,low_u\}$，即：可以先下到 $v$，再回溯。 

对于一条返祖边 $(u,v)$，且 $v$ 不是 $u$ 的直系父亲，$low_u = \min\{dfn_v, low_u\}$，即：直接回溯。

对于树边 $(u,v)$，如果 $low_v\geq dfn_u$，即 $v$ 和其子树能够通过返祖边回溯到的时间戳最小只能是 $dfn_u$，那么要把它们的时间戳回溯到到 $dfn_u$ 之前就需要与 $u$ 相关的边。也就是说这时如果把 $u$ 去掉，与其有关的边全部消失，那么 $low_v$ 不可能小于等于 $dfn_u$，也就是不可能回溯到时间戳比 $u$ 更小的点，此时这个子树与其它点无法连通，$u$ 就是割点。

注意：一个连通分量的搜索树的根节点一定满足上面的条件，因为在这个搜索树中，不存在一个 $dfn$ 值比它小的节点，但是当且仅当其至少拥有两个以上的子树，它才能被称为割点。

画个图吧（红色代表根节点，圆角矩形代表一个子树）：

![111](https://cdn.luogu.com.cn/upload/image_hosting/dx4hgp7j.png)

显然如果这个图只存在根节点和其中一个子树时，由于根节点是第一访问的节点，它会被我们上面的判断条件误判为割点，但是它并不是一个割点，而当它有多个子树时，删除它会使得子树不再连通，这时它才是一个割点。

代码（核心部分）：

```cpp
inline void tarjan(int u, int fa) {
	int son = 0;//子树个数
	low[u] = dfn[u] = ++idx;//打上时间戳标记
	s[++top] = u;//u进入搜索树
	for(int i = fir[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!dfn[v]) {//树边
			son++;
			tarjan(v, u);
			low[u] = min(low[u], low[v]);
			if(low[v] >= dfn[u]) cut[u] = true;
		} else if(v != fa) low[u] = min(low[u], dfn[v]);//返祖边
	}
	if(fa == 0 && son < 2) cut[u] = false;//是根节点，且子树小于2，不是割点
}
```

知道了割点怎么求，点双连通分量（接下来简称点双）就很好求了：

两个点双最多只有一个公共点（即都有边与之相连的点）；且这个点在这两个点双和它形成的子图中是割点。

对于第一点，因为当它们有两个及以上公共点时，它们可以合并为一个新的点双（矩形代表一个点双，圆形代表公共点）：

![DIANSHUANG](https://cdn.luogu.com.cn/upload/image_hosting/4jhgyuqg.png)

当有两个及以上公共点时，删除其中一个点及其与两个点双相连的边后，这两个点双总是可以通过另一个公共点到达彼此，属于一个连通分量，所以这些公共点对于这个子图而言并不是一个割点，按照定义，这两个点双和这些公共点应该是一个更大的点双。

对于第二点，与第一点类似，当对于这个子图而言它不是一个割点时，这两个点双也可以合并为一个新的点双：

![DIANSHUANG2](https://cdn.luogu.com.cn/upload/image_hosting/96vpmuhw.png)

当这个公共点对于这个子图不是一个割点时，也就意味着这两个点双有着另外的边相连，而这些边相连的点同样也是两个点双的公共点，可以归到第一种情况里。

对于一个点双，它在 DFS 搜索树中 $dfn$ 值最小的点一定是割点或者树根。

当这个点是割点时，它所属的点双必定不可以向它的父亲方向包括更多点，因为一旦回溯，它就成为了新的子图的一个割点，不是点双。所以它应该归到其中一个或多个子树里的点双中。

当这个点是树根时，它的 $dfn$ 值是整棵树里最小的。它若有两个以上子树，那么它是一个割点；它若只有一个子树，它一定属于它的直系儿子的点双，因为包括它；它若是一个独立点，视作一个单独的点双。

换句话说，一个点双一定在这两类点的子树中。

我们用栈维护点，当遇到这两类点时，将子树内目前不属于其它点双的非割点或在子树中的割点归到一个新的点双。注意这个点可能还是与其它点双的公共点，所以不能将其出栈。

本题代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5, M = 4e6 + 5;
int cnt = 1, fir[N], nxt[M], to[M];
int s[M], top, bcc, low[N], dfn[N], idx, n, m;
vector<int> ans[N];
inline void tarjan(int u, int fa) {
	int son = 0;
	low[u] = dfn[u] = ++idx;
	s[++top] = u;
	for(int i = fir[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!dfn[v]) {
			son++;
			tarjan(v, u);
			low[u] = min(low[u], low[v]);
			if(low[v] >= dfn[u]) {
				bcc++;
				while(s[top + 1] != v) ans[bcc].push_back(s[top--]);//将子树出栈
				ans[bcc].push_back(u);//把割点/树根也丢到点双里
			}
		} else if(v != fa) low[u] = min(low[u], dfn[v]);
	}
	if(fa == 0 && son == 0) ans[++bcc].push_back(u);//特判独立点
}
inline void add(int u, int v) {
	to[++cnt] = v;
	nxt[cnt] = fir[u];
	fir[u] = cnt;
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
	}
	for(int i = 1; i <= n; i++) {
		if(dfn[i]) continue;
		top = 0;
		tarjan(i, 0);
	}
	printf("%d\n", bcc);
	for(int i = 1; i <= bcc; i++) {
		printf("%d ", ans[i].size());
		for(int j : ans[i]) printf("%d ", j);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：Jeremiahy (赞：66)

2022.7.28 更新：改正一处笔误。

# Tarjan 算法与割点

### 概念

给定无向图 $G=(V,E)$：

若对于 $x\in V$，从图中删去节点 $x$ 以及所有与 $x$ 关联的边之后，$G$ 分裂成两个或两个以上不相连的子图，则称 $x$ 为 $G$ 的**割点**。

一般无向图（不一定连通）的割点就是它的各个连通块的割点。

而由著名计算机科学家 Robert Tarjan 的名字命名的 Tarjan 算法能够在线性时间内求出无向图的割点，进一步可求出无向图的双连通分量。 Tarjan 算法基于无向图的深度优先遍历，下面介绍一些相关概念。

#### 时间戳

在图的深度优先遍历过程中，按照每个节点第一次被访问的时间顺序，依次给予 $N$ 个节点从 $1$ 到 $N$ 的整数标记，该标记称为**时间戳**，记为 $dfn_x$。

#### 搜索树

在无向图中任选一个节点出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 $(x,y)$（换言之，从 $x$ 到 $y$ 是对 $y$ 的第一次访问）构成一棵树。我们把它称为**无向连通图的搜索树**。当然，一般无向图（不一定连通）的各个连通块的搜索树构成无向图的搜索森林。

下图左侧展示了一张无向连通图，灰色节点是深度优先遍历的起点，加粗的边是发生递归的边（假设我们在遇到多个分支时，总是优先访问最靠左的一条）。右侧展示了深度优先遍历的搜索树，并标注了节点的时间戳。

![](https://cdn.luogu.com.cn/upload/image_hosting/ryswqep8.png)

#### 追溯值

除了时间戳之外， Tarjan 算法还引入了一个**追溯值** $low_x$。设 $subtree(x)$ 表示搜索树中以 $x$ 为根的子树。$low_x$ 定义为以下节点的时间戳的最小值：

1. $subtree(x)$ 中的节点。

1. 通过 $1$ 条**不在搜索树上的边**，能够到达 $subtree(x)$ 的节点。

以上图为例。为了叙述简便，我们用时间戳代表节点编号。$subtree(2)=\{2,3,4,5\}$。另外，节点 $1$ 通过不在搜索树上的边 $(1,5)$ 能够到达 $subtree(2)$。所以 $low_2=1$。

### 求法

根据定义，为了计算 $low_x$，应该先令 $low_x=dfn_x$，然后考虑从 $x$ 出发的每条边 $(x,y)$：

若在搜索树上 $x$ 是 $y$ 的父节点，则令 $low_x=\min(low_x,low_y)$。

若无向边 $(x,y)$ 不是搜索树上的边，则令 $low_x=\min(low_x,dfn_y)$。

下图中括号里的数值标注了每个节点的追溯值 $low$。

![](https://cdn.luogu.com.cn/upload/image_hosting/bt771s0u.png)

#### 割点判定法则

若 $x$ 不是搜索树的根节点（深度优先遍历的起点），则 $x$ 是割点当且仅当搜索树上存在 $x$ 的一个子节点 $y$，满足：

$\hspace{15.0em}$ $dfn_x\le low_y$

特别地，若 $x$ 是搜索树的根节点，则 $x$ 是割点当且仅当搜索树上存在**至少两个**子节点 $y1,y2$ 满足上述条件。

#### 证明：

根据定义，$dfn_x\le low_y$ 说明从 $subtree(y)$ 出发，无论如何也无法到达比 $x$ 更早访问的节点。换句话说，只有节点 $x$ 上有若干条边通向 $subtree(y)$，$x$ 便是它通向外界的唯一通道，$suntree(y)$ 中所有节点的 $dfn$ 都必须大于等于它， 而不能小于它。断开节点 $x$ 后，$subtree(y)$ 好像形成了一个封闭的环境，没有边与比 $x$ 更早的节点相连，图断开成了两部分，因此 $x$ 是割点。

反之，若不存在子节点 $y$，使得 $dfn_x\le low_y$，则说明每个 $subtree(y)$ 都能绕行其他边到达比 $x$ 更早访问的节点，$x$ 自然不是割点。

对于根节点 $x$，若想分为两个及以上不相连的子图，自然是需要两个及以上不相连的子树才能办到。

 _证毕。_ 

在上图中，共有两个割点，分别是时间戳为 $1$ 和 $6$ 的两个点。

下面的程序求出一张无向图中所有的割点。因为割点判定法则是小于等于号，所以在求割点时，不必考虑父节点和重边的问题，从 $x$ 出发能访问到的所有点的时间戳都可以用来更新 $low_x$。


```cpp

const int SIZE = 100010;
int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];
int dfn[SIZE], low[SIZE], stack[N];
int n, m, tot = 1, num, root;
bool cut[SIZE];
void add(int x, int y) { // 邻接表存图
	ver[++tot] = y, Next[tot] = head[x], head[x] = tot;
}
void tarjan(int x) { 
	dfn[x] = low[x] = ++num; //按照访问顺序初始化 x 节点的 dfn 与 low 值
	int flag = 0;
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
			if (low[y] >= dfn[x]) {
				flag++;
				if (x != root || flag > 1) cut[x] = true;//割点判定法则
			}
		} 
		else
			low[x] = min(low[x], dfn[y]);
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for (register int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		if (x == y)
			continue;
		add(x, y), add(y, x);//正反向存边
	}
	for (register int i = 1; i <= n; i++)
		if (!dfn[i])
			root = i, tarjan(i);
	return 0;
}

```



### 练习

[P3388 割点](https://www.luogu.com.cn/problem/P3388)

[P3469 [POI2008]BLO-Blockade](https://www.luogu.com.cn/problem/P3469)


# 点双连通分量
### 概念

若一张无向连通图不存在割点，则称它为**点双连通图**。

无向图的**极大**点双联通子图被称为**点双联通分量**，简记为 **v-DCC**。

在上面的定义中，我们称一个双连通子图 $G'=(V',E')$ “极大（其中 $V'\subseteq V, E'\subseteq E$），是指不存在包含 $G'$ 的更大的子图 $G''=(V'',E'')$，满足 $V'\subseteq V''\subseteq V$， $E' \subseteq E''\subseteq E$ 并且 $G''$ 也是双连通子图。

### 定理

一张无向图是点双连通图，当且仅当满足下列**两个条件之一**：

1. 图的顶点数不超过 $2$。

1. 图中任意两点都同时包含在**至少一个**简单环中。其中“简单环”指的是不自交的环，也就是我们通常画出的环。

#### 证明：
对于顶点数不超过 $2$ 的情况，定理显然成立，下面假设图中顶点数不小于 $3$。

先证充分性。若任意两点 $x$，$y$ 都同时包含在至少一个简单环中，则 $x$，$y$ 之间至少有两条不相交的路径。无论从图中删除哪个节点，$x$，$y$ 均能通过两条路径之一相连。故图中不存在割点，是点双连通图。

再证必要性。反证法，假设一张无向图是“点双连通图”，并且存在两点 $x$，$y$，他们不同时处于任何一个简单环中。

如果 $x$，$y$ 之间仅存在 $1$ 条简单路径，那么路径上至少有一个割点，与“点双连通”矛盾。

如果 $x$，$y$ 之间存在 $2$ 条或 $2$ 条以上的简单路径，那么容易发现，任意两条都至少有一个除 $x$，$y$ 之外的交点；进一步可推导出，$x$，$y$ 之间的所有路径必定同时交于除 $x$，$y$ 之外的某一点 $p$（不然就会存在两条没有交点的路径，形成一个简单环，如下图所示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/o9pt519w.png)

根据定义，$p$ 是一个割点，与点双连通矛盾。故假设不成立。

证毕。

### 性质

1. 除了仅包含两个点一条边的点双外，其他点双都满足：任意两点间都存在至少两条点不重复路径。

1. 图中任意一个割点都在至少两个点双。

1. 两个点双至多存在一个公共点——割点。

1. 任意一个不是割点的点都只存在于一个点双中，割点也一定属于两个及以上的点双。

#### 证明

对于第一点，可以用点双连通分量的定义来解释：因为点双内无割点，所以两个点间一定会有多条边互通（否则就会存在割点）。

对于第二点，因为删去割点后图会不连通，所以割点至少连接着图的两部分，而由于点双中不能有割点，所以这两部分肯定不在同一个点双中，所以割点至少存在于两个点双中。

对于第三点，用反证法，假设存在两个及以上的公共点，那这两个点双就可以通过两条及以上的边相连，那么这就变成一个点双了，与定义矛盾，故假设不成立。如果这个公共点不是割点，那么说明两个点双还有别的边相连，同样变成一个点双，所以公共点一定是割点。

对于第四点，若点在两个及以上点双中，那么删去它就可以分成两个及以上的点双，它就一定是割点；而割点如果只属于一个点双，删去它后图依然连通，这个点就不是割点了，所以割点一定属于两个及以上的点双。
### 求法

点双连通分量是一个极其容易误解的概念。它与删除割点后图中剩余的连通块是不一样的，请格外留意。

若每个节点为孤立点，则它自己单独构成一个 v-DCC。除了孤立点之外，点双连通分量的大小至少为 $2$。根据 v-DCC 定义中的“极大”性，虽然桥（割边）不属于任何 e-DCC（边双连通分量），但是割点可能属于多个 v-DCC。下面的无向图共有 $2$ 个割点，$4$ 个点双连通分量。


![](https://cdn.luogu.com.cn/upload/image_hosting/0m1veoit.png)

我们考虑使用上面的 $dfn$ 和 $low$ 来求，我们将深度优先遍历时遇到的所有边加入到栈里面，当找到一个割点的时候，就将这个割点往下走到的所有边弹出，而这些边所连接的点就是一个点双了。

具体来说，需要在 Tarjan 算法的过程中维护一个栈，并按照如下方法维护栈中的元素：

1. 当一个节点**第一次**被访问时，把该节点入栈。

1. 当割点判定法则中的条件 $\mathit dfn_x\leq \mathit low_y$ 成立时，此时 $x$ 是割点，$subtree(y)$ 为一个点双连通分量。为了得到 $subtree(y)$，**无论** $x$ **是否为根**，都要将 $subtree(y)$ 弹出，具体操作如下：
	
    （1）栈顶为 $subtree(y)$ 的最底端（最深处），从栈中不断弹出节点，直至节点 $y$ 被弹出（$y$ **要弹出**）。
    
    （2）刚才弹出的所有节点**与节点** $x$ **一起**构成一个 v-DCC。

下面的程序在求出割点的同时，计算出 vector 数组 $dcc$，$\mathit dcc_i$ 保存编号为 $i$ 的 v-DCC 中的所有节点。

### 代码

```cpp 
#include <iostream>
#include <vector>
using namespace std;
const int N = 1000010, M = 5000010;
int head[N], ver[M * 2], Next[M * 2];
int dfn[N], low[N], stack[N];
int n, m, tot = 1, num, root, top, cnt;
vector<int> dcc[N * 2];//dcc[i] 存储编号为 i 的 v-DCC 中的所有节点
void add(int x, int y) {//邻接表存图
	ver[++tot] = y, Next[tot] = head[x], head[x] = tot;
}
void tarjan(int x) {
	dfn[x] = low[x] = ++num;
	stack[++top] = x;
	if (x == root && head[x] == 0) { //孤立点
		dcc[++cnt].push_back(x);
		return;
	}
	int flag = 0;
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
			if (low[y] >= dfn[x]) {
				flag++;
				if (x != root || flag > 1)
					cut[x] = true;
				cnt++;
				int z;
				do {
					z = stack[top--];
					dcc[cnt].push_back(z);
				} while (z != y);
				dcc[cnt].push_back(x);
			}
		} 
		else
			low[x] = min(low[x], dfn[y]);
	}
}
int main() {
	ios::sync_with_stdio(false);//关闭与scanf的同步来提速
	cin >> n >> m;
	for (register int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		if (x == y)
			continue;
		add(x, y), add(y, x);
	}
	for (register int i = 1; i <= n; i++)
		if (!dfn[i])
			root = i, tarjan(i);
	cout << cnt << "\n";
	for (register int i = 1; i <= cnt; i++) { //输出
		cout << dcc[i].size();
		for (register int j = 0; j < dcc[i].size(); j++)
			cout << ' ' << dcc[i][j];
		cout << "\n";
	}
	return 0;
}
```
### 练习
[P8435 【模板】点双连通分量](https://www.luogu.com.cn/problem/P8435)。

[P8436 【模板】边双连通分量](https://www.luogu.com.cn/problem/P8436)。

注：本文大部分抄自 lyd 蓝书。



---

## 作者：World_Creater (赞：29)

### 0.前置知识
[割点](https://www.luogu.com.cn/problem/P3388)  
本题依赖此算法，建议通过此题后在食用~  
现在默认我们已经会求割点了。  
### 1.概念
若一个无向图中的去掉任意一个节点都不会改变此图的连通性，即不存在割点，则称作点双连通图。一个无向图中的每一个极大点双连通子图称作此无向图的点双连通分量。  
### 2.性质
点双连通分量有许多性质，可以帮助我们解决这道题。  
1. 图中任意一个割点都在至少两个点双联通分量中。  
因为割点连接了多个点双连通分量（这是由于删掉割点后图会分成多个，且根据定义，点双连通分量中不可能有割点）。  
同样的，点双连通分量之间以割点连接。  
（建议联系样例的图片食用~）

2. 图中任意一个非割点都在且只在一个点双连通分量之中   
这也标志了图中的孤立点也算一个点双连通分量  
（当然，一个点双连通分量中也可能只有割点，如下图中点$0$,$1$,$2$,$3$形成的点双连通分量）  
![](https://cdn.luogu.com.cn/upload/image_hosting/611t0dc2.png)

### 3.求法
~~当然要先求割点啦~~  
我们考虑在利用 Tarjan 求割点时，把遍历到的每个点都加入一个栈中（类似于有向图缩点时的操作）。  
当我们在找到一个缩点时，此时栈中，由它生出去的一个子树（虽然实际上不是树，但是请类比概念），便是一个点双连通分量。  

**注意：与有向图求缩点不同，我们在弹栈时，判断条件为是否到出点而不是是否为源点**   
我们以样例 $3$ 为例子，并加上 `6 5` 这条边 ~~（才不是因为我不小心把数据输错了呢）~~    
图中标黑的点为割点  
![](https://cdn.luogu.com.cn/upload/image_hosting/tl2avzn8.png)  
这个图的dfs序（入栈顺序）应为 `1 2 3 4 6 5`。  
依照回溯的思路，我们第一个处理的割点应为 $6$。  
此时 $5$ 是一个“子树”，弹栈，将 $6$ 也加入答案中，我们得到了一个点双 `5 6`。  

**此处重点：弹栈时不能弹出割点，因为割点属于多个点双**  

处理第二个割点$4$，它的“子树”（在栈中）应为 $6$，根据回溯的思维，在处理 $6$ 时，以它为割点的点双已经处理完毕，而与割点 $4$ 形成的点双是最后一个点双，可以将 $6$ 出栈，但不能将 $4$ 出栈。我们得到了第二个点双 `4 6`。 

现在处理 $2$，它有两个“子树”：`3 4`。

在处理 $4$ 时，我们不能将 $3$ 也出栈，因为他不在 $4$ 的“子树”上。 

最后是一个不同的地方，在处理根节点时，无论它是否为割点，一律出栈。

附代码  

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,low[500005],dfn[500005],ans,cnt;
int nxt[4000005],head[500005],go[4000005],k;
vector<int> dcc[500005];
stack<int>sta;
void add(int u,int v)
{
	nxt[++k]=head[u];
	head[u]=k;
	go[k]=v;
}
void tarjan(int x,int root)//求割点的改版（其实不需要root）
{
	dfn[x]=low[x]=++cnt;
	if(x==root&&!head[x])//孤立点判定
	{
		dcc[++ans].push_back(x);
	}
	sta.push(x);
	for(int i=head[x];i;i=nxt[i])
	{
		int g=go[i];
		if(!dfn[g])
		{
			tarjan(g,root);
			low[x]=min(low[x],low[g]);
			if(low[g]>=dfn[x])
			{
				ans++;
				int p;
				do{//弹栈
					p=sta.top();
					sta.pop();
					dcc[ans].push_back(p);
				}while(p!=g);//注意此处，因为要求是不到达出点
				dcc[ans].push_back(x);//别忘了加入源点！
			}
		}
		else
		low[x]=min(low[x],dfn[g]);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		if(x==y) continue;//重边
		add(x,y);
		add(y,x);
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i]) tarjan(i,i);//注意图可能不连通
	}
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++)
	{
		cout<<dcc[i].size()<<" ";
		for(int j=0;j<dcc[i].size();j++)
		cout<<dcc[i][j]<<" ";
		cout<<endl;
	}
}
```


---

## 作者：HHH6666666666 (赞：17)

**概念： 
点双连通分量（vertex double connected components)**

简称点双。在一个无向图的点双连通分量中，删除任意一点，剩下的所有点仍然互相连通。举个例子：

![TRUEVDCC](https://cdn.luogu.com.cn/upload/image_hosting/l1vkopne.png)

这是一个点双，删除其中任何一点，剩下的点依然联通。

![FALSEVDCC](https://cdn.luogu.com.cn/upload/image_hosting/9lltxqql.png)

而这就不是点双了，因为删除节点 $3$ 将把整张图分为两半。

**割点**

在无向连通图中，如果将其中一个点以及所有连接该点的边去掉，图就不再连通，那么这个点就叫做割点。因此点双中没有割点。

------------

**算法：Tarjan**

此算法的发明者为美国计算机科学家 Robert Tarjan。

核心思路：DFS ，当一个点往下无法到达之前搜过的点时，说明该点分割了图，如第二个样例中的点 $3$。

具体实现：记录每个点的搜索顺序 `dfn`，每个点不往之前走过的点走可以到达的 `dfn` 最小的点 `low`（表达能力极差QAQ）。

模拟这张图，从任意一点（图中为点 $1$）开始搜索：

![run1](https://cdn.luogu.com.cn/upload/image_hosting/or00ausw.png)

红色标记为每个点的 `dfn`，为其 DFS 到达的顺序。

![run2](https://cdn.luogu.com.cn/upload/image_hosting/yeu24ykq.png)

我们对于每一个点 $x$，将 `low[x]` 设置为 `dfn[x]` 并枚举它能到达的点 $y$（除了他的上一个点，如本图中在 dfs 到 $5$ 时，我们忽略了 $4$）：
	
- 如果 $y$ 未被搜索过即 `dfn[y]` $=$ $0$ ，我们对点 $y$ 进行 DFS，然后将 `low[x]` 与 `low[y]` 取 $\min$
- 而如果 $y$ 已被搜索，将 `low[x]` 与 `dfn[y]` 取 $\min$ ---**注意是 `dfn[y]` 而不是 `low[y]`**


图中点 $5$ 搜到了点 $3$ ，原本 `low[5]` = `dfn[5]` = $5$ ，`low[3]` = `dfn[3]` = $3$ ，取 $\operatorname{min}$ 后 `low[5]` = $3$ （`low` 用绿色标记)。

如此，全过程如下：

![run_fin](https://cdn.luogu.com.cn/upload/image_hosting/ve8sks12.png)

绿色箭头表示用 `low[y]` 更新 `low[x]` ，紫色箭头则表示用 `dfn[y]` 更新 `low[x]`。

不妨认为我们在 DFS 时建了一棵树，那么当一个节点的子节点在之前未被搜索且 `low[y]` $\geq$ `dfn[x]` 时，说明该子节点无法绕过该点前往该点上方的点。这个点就应该是一个割点（对于整个连通块来说）。这个割点显然属于所分割的两个连通块。

那么如何记录每个点双呢？开一个栈记录每一次 DFS 进入的点，满足条件时弹栈直到找到该点**的子节点**（毕竟该点在上方的点双还要被算一遍）。弹出的元素加上该点本身即为一个新的点双。

图中在 $3$、$1$ 点依次弹栈。

![stack](https://cdn.luogu.com.cn/upload/image_hosting/3c94kd4b.png)

------------

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define isdigit(x) ('0' <= x && x <= '9')
template<typename types>
inline void read(types &x){
    x = 0; int f = 1; char c;
    while ((c = getchar()) && !isdigit(c)) if (c == '-') f = -1;
    x = c ^ 48;
    while ((c = getchar()) && isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48);
    x *= f; return; 
}
template<typename types>
void write(types x){
    if (x < 0) putchar('-'), x = - x;
    types k = x / 10;
    if (k) write(k);
    putchar(x - (k << 3) - (k << 1) | 48);
    return;
}

const int MAXN = 500010;
const int MAXM = 4000010;

int n, m;
int head[MAXN], to[MAXM], nxt[MAXM], idx = 1;
int dfn[MAXN], low[MAXN], timecnt;    // timecnt 时间戳记录顺序 
vector<int> vdcc[MAXN];
int vdcc_cnt;
stack<int> s;

inline void addedge(int x, int y){
    nxt[++idx] = head[x];
    to[idx] = y;
    head[x] = idx;
    return;
}

void Tarjan(int x, int from){
    dfn[x] = low[x] = ++timecnt;
    s.push(x);
    int child = 0;
    int p;
    for (int i = head[x]; i; i = nxt[i]){
        if (i == (from ^ 1)) continue;    // 判断来路 
        child++;
        int y = to[i];
        if (!dfn[y]){
            Tarjan(y, i);
            low[x] = min(low[x], low[y]);
            if (low[y] >= dfn[x]){    // 找到点双 
                ++vdcc_cnt;
                do{
                    p = s.top(); s.pop();
                    vdcc[vdcc_cnt].push_back(p);
                } while (p != y);    // 弹到子节点 
                vdcc[vdcc_cnt].push_back(x);    // 记得把自己加进去 
            }
        }
        low[x] = min(low[x], dfn[y]);
    }
    if (!child && !from)    // 记得特判孤立点 
        vdcc[++vdcc_cnt].push_back(x);
    return;
}

int main(){
    read(n), read(m);
    int x, y;
    for (int i = 1; i <= m; ++i){
        read(x), read(y);
        if (x != y) addedge(x, y), addedge(y, x);
    }
    
    for (int i = 1; i <= n; ++i) if (!dfn[i]) Tarjan(i, 0); 
    
    write(vdcc_cnt), putchar('\n');
    for (int i = 1; i <= vdcc_cnt; ++i){
        write(vdcc[i].size()), putchar(' ');
        for (auto j = vdcc[i].begin(); j != vdcc[i].end(); ++j){
            write(*j), putchar(' ');
        }
        putchar('\n');
    }
    return 0;
}

```



---

## 作者：zac2010 (赞：11)

### 定义

* 割点：删了这个点使得连通图不连通了。
* 点双联通：这个无向图中不存在割点
* 点双联通分量：一个无向图中的极大点双联通子图。

这里还提一下 Tarjan 算法中的一些定义：

按照 dfs 经过的边生成的树叫做 dfs 树，树上的边称为**树边**，其余的边称为**非树边**。

非树边里又有**前向边**、**后向边**和**横叉边**。
* 前向边： dfs 树上祖先指向子孙的边。
* 后向边： dfs 树上子孙指向祖先的边。
* 横叉边：非树边中不是前向和后向的边。即两颗不同子树的没有祖孙关系的点连的边。

* $dfn_u$ ：即 dfs 序中 $u$ 的编号，按照 dfs 树的前序遍历得到的编号。
* $low_u$ ：即 $u$ 节点及其子树经过 $1$ 条返祖边得到的最小编号节点。

其中横叉边是对于有向图而言的，无向图不存在横叉边。

### 做法

* 性质 $1$ ：任意一个割点至少在两个点双连通分量内。

* 证明 $1$ ：首先，既然是割点，必定度大于等于 $2$ ，而左右两边的点双联通分量一定会包含他，因为这一个点删了不影响联通。

* 性质 $2$ ：除了根节点外，非割点最多只在一个点双连通分量内。

* 反证法，如果在多个点双联通分量内，那么其所处的点双连通分量必定可以合并成一个，而这就不符合点双联通分量的定义。

* 如果 $low_u \le dfn_u$ ，那么 $u$ 必定是一个点双联通分量的根节点，因为下面的点没法和其它点相连。而因此又能得出 $u$ 是割点。

好了，那么和有向图套路大同小异。

我们对于点 $u$ ，遍历邻接点 $v$ ，如果是树边，那么继续遍历，拿 $low_v$ 更新 $low_u$ ，并按性质 $3$ 判断（由于没有横叉边，所以这种情况下就可以知道其是一个点双联通分量）；是返祖边，直接拿 $dfn_v$ 更新 $low_u$。

因为中途我们会记录割点，所以最后记得判根节点的特殊情况。

---

## 作者：adolphshi (赞：11)

# P8435 点双连通分量 题解

## 0.前置知识&使用的算法

本题使用[链式前向星存无向图](https://www.csdn.net/tags/OtDaEg1sMjE4MjctYmxvZwO0O0OO0O0O.html)，[tarjan](https://www.csdn.net/tags/MtjaUgysNzc5OTYtYmxvZwO0O0OO0O0O.html) 与栈求[点双连通分量](https://blog.csdn.net/qq_39328456/article/details/101629977?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6-101629977-blog-120234132.pc_relevant_multi_platform_whitelistv1_exp2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6-101629977-blog-120234132.pc_relevant_multi_platform_whitelistv1_exp2&utm_relevant_index=7)。

## 1.分析题目

 [题目传送门](https://www.luogu.com.cn/problem/P8435)
 
 ~~模板好像没有什么可以分析的~~。
 
 读入一个**无向图**求出其点双连通分量的个数与每个点双连通分量所拥有的节点。
 
##  2.思路

- 当一个节点不与其他节点连通时，其自己形成一个点双连通分量（以下称点双），计数并把它存入答案数组中。

- 当一个节点为个割点时，它会存在于两个及以上点双中。如题目中的样例 $4$，其节点 $2$、$3$ 就是割点。

- 于是此题可以用 tarjan 来求，具体方法如下
 
  1. 每当新搜到一个节点时，将其压入栈中。
  1. 当发现 $x$ 的子节点 $y$ 不能通过其他方式到达 $x$ 的祖先，但可以到达 $x$ 。则弹出栈顶元素直至把 $y$ 弹出。
  1. 弹出的所有元素组成的集合 $E$ 加上 $x$，则为一个点双连通分量。
## 3.过程模拟
（如果不想观看，请跳至 全部代码 处）


如例 $1$，其描述的无向图如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/atqiay4u.png)

图 $1$-$1$。


**枚举第一个节点，把 $deep_1$ , $low_1$ 标上 $1$**
![](https://cdn.luogu.com.cn/upload/image_hosting/2lmdjkdf.png)
图 $2$-$1$。


**枚举第一个顶点的第一个出边，将其所指向的节点 $2$ 入栈，把时间戳标记成 $2$。**
![](https://cdn.luogu.com.cn/upload/image_hosting/ttk8km7g.png)
图 $2$-$2$。

**DFS 出边，把找到的未压入栈的节点压入栈，时间戳增加 $1$。**
![](https://cdn.luogu.com.cn/upload/image_hosting/g52nfp54.png)
图 $2$-$3$。

**同上所述**
![](https://cdn.luogu.com.cn/upload/image_hosting/n9ztmbrr.png)
图 $2$-$4$。

**找到节点 $1$ 发现已经被标记，则回溯**
![](https://cdn.luogu.com.cn/upload/image_hosting/mpq9825g.png)
图 $2$-$5$。

**回溯至节点 $3$ 用节点 $1$ 所能到达的最小时间戳 ($deep_1$) 去更新节点 $3$ 所能到达的最小时间戳 ($low_3$) 。** 
![](https://cdn.luogu.com.cn/upload/image_hosting/z5mvcoho.png)
图 $2$-$6$。

**同上，回溯至节点 $4$,更新节点 $4$ 所能到达的最小的的时间戳**
![](https://cdn.luogu.com.cn/upload/image_hosting/75inuzwe.png)
图 $2$-$7$。

**同图 $2$-$3$，发现并更新节点 $5$，压入栈中。**
![](https://cdn.luogu.com.cn/upload/image_hosting/khvb02aq.png)
图 $2$-$8$。

**发现节点 $1$ 已经被标记，回溯至节点 $5$ 并更新节点 $5$ 所能到达的最小时间戳。**
![](https://cdn.luogu.com.cn/upload/image_hosting/66ncd55x.png)
图 $2$-$9$。

**回溯至节点 $2$ 并更新节点 $2$ 所能到达的最小时间戳。**
![](https://cdn.luogu.com.cn/upload/image_hosting/p85jix67.png)
图 $2$-$10$。


**回溯至节点 $1$ 发现 $low_1 \geqslant deep_1$ 把栈内元素弹出至 $2$,再加上节点 $1$ 则构成一个点双连通分量。**
![](https://cdn.luogu.com.cn/upload/image_hosting/isrcnxnz.png)
图 $2$-$11$

### 注意
- 需要特判单个节点的点双连通分量
## 4.全部代码
### 由于此题数组较多，所以在此附上一个数组解释
- ${ins}_{i}$ 为标记数组，表示元素 $i$ 是否在栈中。
- ${deep}_{i}$ 表示访问到第 $i$ 个 节点的时间戳，若为 $0$ 表示其还没有遍历到。
- $low_{i}$ 表示第 $i$ 个节点能够通过另外一条边访问到的最早祖先节点的时间戳
- $s_{i}$ 为栈，$top$ 为栈顶指针
- $f_{i,j}$ 是 vector 数组,其第0个元素表示第 $i$ 个点双的个数，其余元素为第 $i$ 个点双的节点。
- $to_{i}$  $nex_{i}$  $head_{j}$ 为链式前向星的维护数组,其中 $i$ 为边的编号，$j$ 为节点编号。

```cpp
#include<bits/stdc++.h>
#define _for(x,y,z) for(int x=y;x<=z;x++)
#define for_(x,y,z) for(int x=y;x>=z;x--)

using namespace std;

typedef long long ll;
int low[500010],from[500010],deep[500010],ins[500010],s[500010];
int to[4000010],nex[4000010],head[500010];
int top,tot=1,ans,n,m,num，root;
vector <int> f[500010];
void add(int x,int y)//链式前向星加边
{
	to[++tot]=y;
	nex[tot]=head[x];
	head[x]=tot;
}
void tarjan(int x)
{
	ins[x]=1;deep[x]=low[x]=++num;
	s[++top]=x;
	if(x==root&&head[x]==0)//判断 x 是否为单独一个节点
	{
		ans++;
		f[ans][0]++;
		f[ans].push_back(x);
		return ;
	}
	for(int i=head[x];i;i=nex[i])//遍历出边
	{
		if(!deep[to[i]])//若其还没遍历
		{
			tj(to[i]);//遍历
			low[x]=min(low[x],low[to[i]]);
			if(low[to[i]]>=deep[x])//重点，to[i] 的子节点 y 不能通过其他方式到达 x 的祖先
			{
				ans++;
				int t;
				do
				{
					t=s[top--];
					f[ans].push_back(t);
					f[ans][0]++;
				}while(t!=to[i]);
				f[ans][0]++;
				f[ans].push_back(x);
				//弹出栈顶元素并记录再把 x 加进去
			}
		}
		else if(ins[to[i]])
		{
			low[x]=min(low[x],deep[to[i]]);
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	_for(i,1,m)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(x==y)
		{
			continue;
		}
		add(x,y);
		add(y,x);
	}
	_for(i,1,n)
	{
		f[i].push_back(0);
	}
	_for(i,1,n)//有些节点可能遍历不到，所以使用循环遍历。
	{
		if(!deep[i])
		{
			root=i;//设置根
			tarjan(i);
		}
	}
	printf("%d\n",ans);		
	_for(i,1,ans)
	{
		printf("%d ",f[i][0]);
		_for(j,1,f[i][0])//输出
		{
			printf("%d ",f[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```
(如果没过审可以详细告诉我哪里错误了吗？？)






---

## 作者：快斗游鹿 (赞：8)

## 概念

**割点**：在无向图中，若删除某个顶点后，这个图就不再连通，则称这个顶点为割点。例如，在下面的图中，点 $1$ 就是一个割点。

![](https://cdn.luogu.com.cn/upload/image_hosting/oiqgbe29.png)

**点双连通**：若无向连通图中不存在割点，则称它为点双连通图。

**点双连通分量**：即无向图中，极大的点双连通子图。

## Tarjan 算法

### 如何求割点

首先从任意一个点开始，使用深度优先搜索对图进行遍历。定义 $dfn_u$ 表示点 $u$ 的时间戳（即第几个被搜到的），$low_u$ 表示点 $u$ 在不经过其父顶点时，能够回到的最小时间戳。

若对于一个顶点 $u$，如果存在至少一个顶点 $v$（即点 $u$ 的儿子），使得 $low_v \ge dfn_u$，则点 $u$ 是割点。对于下面这个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/s2w6fb0l.png)

假设我们从点 $1$ 开始遍历，则 $dfn_1=1$，但对于其儿子点 $4$，$low_4=1$，即点 $4$ 在不经过点 $1$ 的情况下，能够回到的最小时间戳也就是 $1$。这时点 $1$ 就是割点。

开始，我们令所有 $low_u=dfn_u$，然后考虑从点 $u$ 出发的每条边 $(u,v)$。若点 $v$ 没有被访问过，则 $low_u=\min(low_u,low_v)$。若 $y$ 被访问过，则 $low_u=\min(low_u,dfn_v)$。

求割点核心代码：

```
void dfs(int u,int fa){
	dfn[u]=low[u]=++tot;
    int count=0;
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(dfn[v])low[u]=min(low[u],dfn[v]);//如果点v被访问过了
		else if(!dfn[v]){//点v还没被访问
			dfs(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
                count++;
                if(u!=fa||count>1)flag[u]=1;
            }
		}
	}
}
```

### 如何求点双连通分量

既然会求割点了，那求点双连通分量也就不是什么难事。定义一个二维数组 $ans$，存放每个点双连通分量中的点。

遍历时，将遍历到的顶点都扔到一个栈里。遇到割点时，令该点为点 $u$，我们就不断地从栈里弹出元素，并存入 $ans$ 数组中，直到弹出了点 $v$（即点 $u$ 的儿子），最后将点 $u$ 也存入。但注意不能弹出点 $u$，因为一个割点可能是两个及以上的点双连通分量的公共点。另外，对于根节点，无论它是不是割点，都要进行出栈操作。

## 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+5;
ll n,m,tot,cnt,dfn[N],low[N],d[N];
vector<ll>e[N],ans[N];
stack<ll>st;
void tarjan(ll u,ll fa){
	dfn[u]=low[u]=++tot;st.push(u);//将顶点扔到栈里
	if(!d[u]){//孤立点特殊处理
		ans[++cnt].push_back(u);
	}
	ll ct=0;
	for(int i=0;i<e[u].size();i++){
		ll v=e[u][i];//cout<<v<<" "<<fa<<endl;
		if(dfn[v])low[u]=min(low[u],dfn[v]);
		else{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
				++cnt;ll t;
				do{//出栈操作
					t=st.top();ans[cnt].push_back(t);st.pop();//cout<<st.top()<<endl;
				}
				while(t!=v);
				ans[cnt].push_back(u);
			}
		}
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		ll u,v;scanf("%lld%lld",&u,&v);
		if(u!=v){
			e[u].push_back(v);
			e[v].push_back(u);d[u]++;d[v]++;
		}
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]){
			tarjan(i,i);
		}
	}
	//for(int i=1;i<=n;i++)cout<<dfn[i]<<" "<<low[i]<<endl;
	printf("%lld\n",cnt);
	for(int i=1;i<=cnt;i++){
		printf("%lld ",ans[i].size());
		for(int j=0;j<ans[i].size();j++){
			printf("%lld ",ans[i][j]);
		}
		cout<<endl;
	}
	return 0;
}

```


---

## 作者：Lagerent (赞：5)

模板题。

[博客](https://www.luogu.com.cn/blog/477674/solution-p8435)

[传送门](https://www.luogu.com.cn/problem/P8435)

## 前置知识

### 割点：

在一个无向图中，如果有一个顶点集合，删除这个顶点集合以及这个集合中所有顶点相关联的边以后，图的连通分量增多，就称这个点集为割点集合。

如果某个割点集合只含有一个顶点 $X$，那么 $X$ 称为一个割点。

### 点双联通分量：

极大的不包含割点的连通块被称为点双连通分量。(以下简称点双。）

## 关于本题

两个数组 $dfn_i$ 和 $low_i$ 分别表示点 $i$ 的时间戳和 $i$ 及其子树能到达的最小时间戳。

### 结论

每个割点至少属于两个点双连通分量。(A)

图中的两个点双连通分量之间一定有割点。(B)

证明很简单：

如果该点不是割点，那么整个图就是一个点双，点与点之间可以相互到达。与两个点双不符，故两个点双之间一定有割点 (B) , 该割点至少属于两个点双 (A)。

### 做法

设 $v$ 为 $u$ 的孩子。

判断 $u$ 为割点的条件为 $low_v \ge dfn_u$。

可以用反证法证明。

设 $low_v < dfn_u$ 也就意味着通过这个子树可以搜索到点 $u$ 上面的节点，那么 $u$ 和 $v$ 必然在一个环里，可以相互到达，不满足 $u$ 为割点。

证毕。

因为结论 A，那么找到了割点也就意味着找到了点双。

由于单独的点也算点双，所以要加特判。即如果该点为根且没有孩子（当进行遍历时默认首次传入的点为根），那么也是点双。如下。
```
if(u == root && !hd[u]) {
	dcc[ ++ num].push_back(u);
	return;
}
```


### 注意：

因为结论 $A$ ，所以当 $u$ 为割点时，会属于两个及以上的点双中。当遍历 $u$ 的子孙节点时，弹栈时不会弹出 $u$ 点，只有遍历到 $u$ 的祖先节点时才会弹出 $u$。

晕了？来看图。

![](https://cdn.luogu.com.cn/upload/image_hosting/i82xu1w6.png?x-oss-process=image/resize,m_lfit,h_350,w_450)

$2$ 号点显然是个割点，设遍历顺序为 $1, 2, 3, 4$。

然后找到 $2$ 为割点，对 $3$ 进行出栈操作并统计答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/q5yph7am.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这里虽然 $2$ 号点没有出栈，**但也要记在这个点双中**。

对于 $4$ 号点的操作同理。

直到我们发现 $1, 2$ 号点也能构成点双时，才会顺次弹出 $2, 1$。

所以对于该图，三个点双分别为 $(3, 2) (4, 2)(2, 1)$。

### 关于数据

会出现自环的情况，在存图时要加个特判。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, M = 4e6 + 10;

int n, m;
int to[M], nt[M], hd[N], idx;
int root, dfn[N], low[N], stk[N], top, t, num;
vector<int> dcc[N];

void add(int u, int v) {
	to[ ++ idx] = v;
	nt[idx] = hd[u];
	hd[u] = idx;
}

void tarjan(int u, int root) {
	dfn[u] = low[u] = ++ t;
	stk[ ++ top] = u;
	if(u == root && !hd[u]) {
		dcc[ ++ num].push_back(u);
		return;
	}
	
	for(int i = hd[u]; i; i = nt[i]) {
		int v = to[i];
		if(!dfn[v]) {
			tarjan(v, root);
			low[u] = min(low[u], low[v]);
			if(low[v] >= dfn[u]) {
				++ num;
				int y;
				do {
					y = stk[top -- ];
					dcc[num].push_back(y);
				}while(y != v);
				dcc[num].push_back(u);
			}
		}
		else low[u] = min(low[u], dfn[v]);
	}
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i ++ ) {
		int u, v;
		scanf("%d%d", &u, &v);
		if (u == v) continue;
		add(u, v), add(v, u);
	}
	
	for(int i = 1; i <= n; i ++ ) {
		if(!dfn[i])
			tarjan(i, i);
	}
	
	printf("%d\n", num);
	for(int i = 1; i <= num; i ++ ) {
		printf("%d ", dcc[i].size());
		for(int j = 0; j < dcc[i].size(); j ++ ) {
			printf("%d ", dcc[i][j]);
		}
		printf("\n");
	}
	
	return 0;
}
```
The End.


---

## 作者：AlicX (赞：1)

### 前言
这道题考察的算法是点双连通分量，在此之前你需要学会割点，其实两者的区别还是比较大的：这道题求的是每个不含个点的连通块，另一个求的是割点，这道题的实现难度明显大多了，而且细节很多不好记，是边缘化算法，不常考。常考的算法一般是有向图的强连通分量，也比较简单。

## 思路
1. 什么是割点？割点表示在一个联通图中，一旦去除这个点，此图将会不连通，你可以发现一个割点是会被至少两个点双连通分量包含，所以割点连接了至少两个点双连通分量。那么我们怎么求出割点？这里首先要引入一个概念：时间戳。表示我们遍历整个图的时候这个点是在被多少时间遍历到的。那么我们用一个数组来记录时间戳，用一个数组来记录这个点所能遍历到的最小时间戳。你可能会有疑问，记录这些有什么用？考虑一个事实：如果这个点是割点，那么他的儿子节点所能遍历到的时间戳最小就为这个点的时间戳。如果这个点是中间节点，一旦出现这种情况就说明他是割点，但如果是祖先节点还不足以证明，所以我们要判断如果是祖先节点就需要至少两个这样的子树来证明它是一个割点。那么问题就迎刃而解了，看一下割点的代码理解一下：

```cpp
void tarjan(int u,int fa){
	dfn[u]=low[u]=++times;
	int cnt=0;
	for(int i=h[u];i!=-1;i=tr[i].ne){
		int to=tr[i].to;
		if(!dfn[to]){
			tarjan(to,u);
			low[u]=min(low[u],low[to]);
			if(low[to]>=dfn[u]&&u!=fa) st[u]=true;
			else if(u==fa) cnt++;
		}
		else low[u]=min(low[u],dfn[to]);
	}
	if(u==fa&&cnt>1) st[u]=true;
}
```

2. 知道了割点，就可以求点的双连通分量了。思路如下：先给每个点打上时间戳，如果这个点的儿子节点所能遍历到的最小时间戳是它，说明他是一个割点，而如果他是割点说明了它连接了至少两个点的双连通分量，而这个儿子节点就属于其中一个，所以我们一开始就可以用一个栈来记录遍历到的点，如果发生这种情况，弹出就可以了。聪明的同学可能会问：万一他的儿子节点已经主导了一个点的双连通分量了呢？你想，他的儿子节点的那个点的双连通分量是否已经被弹出了？那这样不就正确了吗？注意判自环。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=1e6+10,M=1e7+10;
int n,m;
int root;
int cnt=0;
bool st[N];
int times=0;
int h[N],idx=0;
int s[N],top=0;
vector<int> id[N];
int dfn[N],low[N];
struct Node{
	int to,ne;
}tr[M];
void add(int u,int v){
	tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;
}
void tarjan(int u){
	dfn[u]=low[u]=++times,s[++top]=u;
	if(u==root&&h[u]==-1){
		id[++cnt].push_back(u);
		return ;
	}
	int ans=0;
	for(int i=h[u];i!=-1;i=tr[i].ne){
		int to=tr[i].to;
		if(!dfn[to]){
			tarjan(to);
			low[u]=min(low[u],low[to]);
			if(low[to]>=dfn[u]){
				ans++;
				int key;
				cnt++;
				do{
					key=s[top--];
					id[cnt].push_back(key);
				}while(key!=to);
				id[cnt].push_back(u);
			} 
		}
		else low[u]=min(low[u],dfn[to]);
	}
}
signed main(){
	memset(h,-1,sizeof h);
	cin>>n>>m;
	while(m--){
		int u,v;
		cin>>u>>v;
		if(u==v) continue;
		add(u,v),add(v,u);
	}	
	for(root=1;root<=n;root++) if(!dfn[root]) tarjan(root);
	cout<<cnt<<endl;
	for(int i=1;i<=cnt;i++){
		cout<<id[i].size()<<" ";
		for(int j=0;j<id[i].size();j++) cout<<id[i][j]<<" ";
		cout<<endl;
	}
	return 0;
} 
```


---


# 【模板】边双连通分量

## 题目描述

对于一个 $n$ 个节点 $m$ 条无向边的图，请输出其边双连通分量的个数，并且输出每个边双连通分量。

## 说明/提示

**样例四解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/0bzdfzeq.png)

相同颜色的点为同一个连通分量。


------------

**数据范围：**
对于 $100\%$ 的数据，$1 \le n \le 5 \times10 ^5$，$1 \le m \le 2 \times 10^6$。

| subtask | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1 \le n \le 100$ | $1 \le m \le 500$ | $25$ |
| $2$ | $1 \le n \le 5000$ | $1 \le m \le 5 \times 10^4$ | $25$ |
| $3$ | $1 \le n \le 2\times 10^5$ | $1 \le m \le 5\times 10^5$ | $25$ |
| $4$ | $1 \le n \le 5 \times10 ^5$ | $1 \le m \le 2 \times 10^6$ | $25$ |

### 数据更新
- $2022/7/14$ 加强数据
- $2022/11/26$  新增 $10$ 组较小的数据（$1\le n, m \le 10$)，方便选手调试。
- $2022/12/31$ 重组 $subtask$，并加入若干组极端数据。
- $2023/1/1$ 发现昨天新加入的数据数据出了问题，已修改。
------------

本题不卡常，时间限制与空间限制均已开大，正确的解法均可通过。


------------

惊喜：AC 后记得把鼠标放到测试点上看反馈信息，有惊喜哦。

## 样例 #1

### 输入

```
5 8
1 3
2 4
4 3
1 2
4 5
5 1
2 4
1 1```

### 输出

```
1
5 1 5 4 2 3```

## 样例 #2

### 输入

```
5 3
1 2
2 3
1 3```

### 输出

```
3
3 1 3 2
1 4
1 5```

## 样例 #3

### 输入

```
6 5
1 3
2 4
1 2
4 6
2 3```

### 输出

```
4
3 1 2 3
1 4
1 5
1 6```

## 样例 #4

### 输入

```
7 8
1 3
2 4
3 5
2 5
6 4
2 5
6 3
2 7```

### 输出

```
3
1 1
5 2 5 3 6 4
1 7```

# 题解

## 作者：rainygame (赞：168)

## 前言

> 作为一个连链式前向星都不会写的蒟蒻，我决定写一篇 vector 存图的题解，以造福后人。

**前置学习内容：[强连通分量](https://oi-wiki.org/graph/scc/)。**

### 定义

- 连通图：任意两个结点都可以相互到达的**无向图**。
- 桥：一张连通图中，如果删去任意一条边会导致图不连通，则这条边就称为桥。
- 边双连通图：一个没有桥的连通图。
- 边双连通分量：极大的边双连通子图。

## 算法过程

这个边双连通分量和强连通分量十分类似，强连通分量其实就是把环缩起来，而边双连通分量也是一个环。（因为在环上，就算删去一条边，也一定还有另一条边可以连接）

求强连通分量的代码如下：

```cpp
int cnt, ssum;
int dfn[MAXN], low[MAXN], scc[MAXN];
vector<int> e[MAXN];
bitset<MAXN> ins;
stack<int> st;

void tarjan(int x){
    low[x] = dfn[x] = ++cnt;
    st.push(x);
    ins.set(x);
    for (auto i: e[x]){
        if (!dfn[i]){
            tarjan(i);
            low[x] = min(low[x], low[i]);
        }else if (ins.test(i)){
            low[x] = min(low[x], dfn[i]);
        }
    }
    if (dfn[x] == low[x]){
        scc[x] = ++ssum;
        while (st.top() != x){
            scc[st.top()] = ssum;
            ins.reset(st.top());
            st.pop();
        }
        st.pop();
        ins.reset(x);
    }
}
```

而边双连通分量其实更加简单，因为是无向图，所以不需要考虑横叉边，因此不需要 `ins` 来判断是否在栈中，而是直接 `else`。

然后，无向图的边我们一般看成是两条有向图的边，但是这样就会导致一个问题，就是这样会被看成是一个环。所以我们需要加一个判断：不能访问上一个被访问过的结点。

然后答案可以用一个二维 vector 存起来。

给个代码：

```cpp
int cnt;
int dfn[MAXN], low[MAXN];
set<int> e[MAXN];
vector<vector<int>> ans;
stack<int> st;

void tarjan(int x, int las){
	low[x] = dfn[x] = ++cnt;
	st.push(x);
	for (auto i: e[x]){
		if (i == las) continue;
		if (!dfn[i]){
			tarjan(i, x);
			low[x] = min(low[x], low[i]);
		}else low[x] = min(low[x], dfn[i]);
	}
	if (dfn[x] == low[x]){
		vector<int> vec;
		vec.push_back(x);
		while (st.top() != x){
			vec.push_back(st.top());
			st.pop();
		}
		st.pop();
		ans.push_back(vec);
	}
}
```

可是这个代码只能拿到 $50$ 分：[评测记录](https://www.luogu.com.cn/record/112742048)。为什么呢？

通过下载数据可以发现，数据是有**重边**的，而重边就可以往回走了。但是我们这个判断就直接把这个机会给“杀死”了。

因此，我们不能根据顶点来判断，而是要根据边来判断，条件是**不能走上一次走过的边**。我们为了判边，就需要给 vector 多绑上一个 `int` 保存边的编号以判断。

这样就可以 AC 本题了！代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 500001

int n, m, u, v, cnt;
int dfn[MAXN], low[MAXN];
vector<pair<int, int>> e[MAXN];
vector<vector<int>> ans;
stack<int> st;

void tarjan(int x, int las){
	low[x] = dfn[x] = ++cnt;
	st.push(x);
	for (auto i: e[x]){
		if (i.second == (las ^ 1)) continue;
		if (!dfn[i.first]){
			tarjan(i.first, i.second);
			low[x] = min(low[x], low[i.first]);
		}else low[x] = min(low[x], dfn[i.first]);
	}
	if (dfn[x] == low[x]){
		vector<int> vec;
		vec.push_back(x);
		while (st.top() != x){
			vec.push_back(st.top());
			st.pop();
		}
		st.pop();
		ans.push_back(vec);
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n >> m;
	for (int i(1); i<=m; ++i){
		cin >> u >> v;
		e[u].push_back(make_pair(v, i<<1));
		e[v].push_back(make_pair(u, i<<1|1));
	}
	for (int i(1); i<=n; ++i){
		if (!dfn[i]) tarjan(i, 0);
	}
	
	cout << ans.size() << '\n';
	for (auto i: ans){
		cout << i.size() << ' ';
		for (auto j: i) cout << j << ' ';
		cout << '\n';
	}
	
	return 0;
}
```

我本以为这个会跑得很慢，没想到居然比随机抽的一篇幸运题解还要快：[我的记录](https://www.luogu.com.cn/record/112755622)|[TA 的记录](https://www.luogu.com.cn/record/112757205)。

---

## 作者：郑朝曦zzx (赞：144)

# 一 解题思路
边双连通分量其实是割边的升级版，多几行代码，这里我就先介绍割边的求法，再介绍边双连通分量的求法。
## 求割边
求割边所用的是 tarjan 算法，其本质是根据“追溯值”来判断某一条边能割去图是否依然连通。

这里我们引入两个数组：
- $low_x$：追溯值数组，表示以 $x$ 为根的搜索树上的点以及通过**一条**不在搜索树上的边能达到的结点中的最小编号。

**简单来说，追溯值记录的是某节点通过一条不在子树上的边“向上”能到达的最小编号结点。**

- $dfn_x$：时间戳数组，表示 $x$ 号的编号（按照访问顺序编号）

在初始的情况下，$low_x = dfn_x$ 也就是某个点的追溯值最开始是自己。

比如这就是样例中图的 $low$、$dfn$ 的信息。
![](https://cdn.luogu.com.cn/upload/image_hosting/hmegouhv.png)

追溯值数组的更新有以下两种可能的情况（为了方便表示，我们令 $x$ 结点有一条边连向 $y$ 结点）：
- 如果 $y$ 是 $x$ 搜索树上的结点（还没有被标记时间戳）那么，$low_x = \min(low_x, low_y)$。
- 否则（$y$ 不是搜索树上的结点） $low_x = \min(low_x, dfn_y)$

**注意：后者是 $dfn_y$**

> 通过**一条**不在搜索树上的边

**只有一条!**

割边的判定:
	
如果 $x$ 到 $y$ 的无向边是割边，当且仅当（充要条件） $dfn_x \lt low_y$

解释：如果从 $x$ 经过一条“回边”到不了 $y$，那么显然这是一条割边。

请还是看上面那张图，画上红线的就是割边，把它切断后，就会使得某个点无法回到自己/上面的点，所以这一条边删去后，图就不再连通。

**注意：后者是 $dfn_y$**

代码实现时有一个小技巧，就是建图时边的编号从 2 开始标，这样就能以 $O(1)$ 的时间复杂度求出某边的逆向边（异或运算），并且标记割边。

## 求双联通分量
由于边双连通分量中去除任意一条边后，分量依然是连通的，所以边双连通分量中**没有割边**（与点双连通分量不同），因此我们就可以把所有割边“拆掉”，来求边双连通分量。

图片解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/7omwlai3.png)

请您看，把割边去掉后，不就剩下连通分量了吗？

当我们求出割边后，我们可以使用这样一个 dfs 来分离出所有边双连通分量：

```cpp
void dfs(int node, int ndcc)
{
	dcc[node] = ndcc;
	Ans[ndcc - 1].push_back(node);
	for (int i = head[node]; i; i = e[i].nxt)
	{
		int to = e[i].to;
		if (dcc[to] || b[i]) continue;
		// 如果这个点属于其他分量或者这条边是割边，就停止搜索。
		dfs(to, ndcc);
	}
}
```
# 二 代码
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int maxn = 500010, maxm = 4000010;
int n, m, cnt = 1, ans, id;
int dfn[maxn], low[maxn], head[maxn], dcc[maxn];
struct edge
{
	int to, nxt;
}e[maxm];
bool b[maxm];
vector <vector <int> > Ans;
void add(int f, int t)
{
	e[++cnt].to = t;
	e[cnt].nxt = head[f];
	head[f] = cnt;
}
void tarjan(int node, int in_edge)
{
	dfn[node] = low[node] = ++id;
	for (int i = head[node]; i; i = e[i].nxt)
	{
		const int to = e[i].to;
		if (dfn[to] == 0)
		{
			tarjan(to, i);
			if (dfn[node] < low[to])
				b[i] = b[i ^ 1] = 1;
			low[node] = min(low[node], low[to]);
		}
		else if (i != (in_edge ^ 1))
			low[node] = min(low[node], dfn[to]);
	}
}
void dfs(int node, int ndcc)
{
	dcc[node] = ndcc;
	Ans[ndcc - 1].push_back(node);
	for (int i = head[node]; i; i = e[i].nxt)
	{
		int to = e[i].to;
		if (dcc[to] || b[i]) continue;
		dfs(to, ndcc);
	}
}
int main()
{
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; ++i)
	{
		int f, t;
		scanf("%d %d", &f, &t);
		if (f == t) continue;
		add(f, t);
		add(t, f);
	}
	for (int i = 1; i <= n; ++i)
		if (dfn[i] == 0)
			tarjan(i, 0);
	for (int i = 1; i <= n; ++i)
		if (dcc[i] == 0)
		{
			Ans.push_back(vector <int>());
			dfs(i, ++ans);
		}
	printf("%d\n", ans);
	for (int i = 0; i < ans; ++i)
	{
		printf("%d", Ans[i].size());
		for (int j = 0; j < Ans[i].size(); ++j)
			printf(" %d", Ans[i][j]);
		printf("\n");
	}
	return 0;
}
```

# 三 说明
本题解中的部分内容引自《算法竞赛进阶指南》，而大部分内容为作者学习后自我归纳的产物。

# 四 提示（常见的错误）
说明：本部分部分内容总结自讨论区。

- 测试点 1、2 Wrong Answer：图可能有重边，请用合适的存图方式。

- 测试点 9、10 TLE/MLE：建议使用二维 vector，数据中存在某些分量只存在一个点，而分量很多的情况。

# 五 Hack 数据征集

我是题目提供者，如果您有 hack 数据，请在此处回复并 at 我，我将会把 hack 数据加入测试数据中。

反馈 hack 数据要求：

- 给出被 hack 的代码的链接

- 给出数据（如果数据过大可以提供生成器）

- hack 前自查数据是否符合数据范围

感谢您的贡献。

---

## 作者：东灯 (赞：34)

2022/8/20 修改：对于 SCC 部分的说明不严谨，已修正

#### Tarjan-E-DCC 求无向图边双联通分量(E-DCC)的算法

求解无向图的边双联通分量有两种方法，有一种很好理解的办法是：由于边双联通分量中不存在桥，所以实质上只需要把桥全部求出来再跑一遍不过桥的 dfs 即可求出边双联通分量。

```cpp
void tarjan(int x,int father){
	dfn[x]=low[x]=++nowtime;
	for(register int i=head[x];i;i=e[i].next){
		int v(e[i].to);
		if(!dfn[v]){
			tarjan(v,i);
			low[x]=min(low[x],low[v]);
			if(low[v]>dfn[x])bridges[i]=bridges[i^1]=true;
		}else if(i!=(father^1))low[x]=min(low[x],dfn[v]);
 	}
}
void dfs(int x){
    vis[x]=1;
    for(register int i=head[x];i;i=e[i].next){
        if(bridges[i])continue;
        int v(e[i].to);
        if(!vis[v])dfs(v);
    }
}
int main(){
	for(register int i=1;i<=n;++i)
		if(!dfn[i])tarjan(i,i);
    for(register int i=1;i<=n;++i)
        if(!vis[i]){
            dfs(i);
            ++dcccnt;
        }
}
```

第二种求解方法可以联系求解 SCC 时的知识理解：在求桥时限制了返回父亲的返祖边的情况下，在选定 root 节点之后，一张无向图已经变成了一张有向图（实际上这张有向图就是搜索树），往什么方向走，什么地方会在搜索树上形成有向环，都已经是固定下来的了。因此我们可以仿照求 SCC 时的思路，在一个强连通分量中的点可以互相到达，而处于两个不同强连通分量中的点不能相互到达，而边双联通分量恰好是没有桥的联通分量，我们引出一个非常容易想的结论：在无向图中只要一个分量中没有桥，那么该分量在 Tarjan-Bridge 算法抽象出的有向图中一定强连通，反过来说，被抽象为有向图的无向图中的一个强连通分量，在原图中是一定一个边双联通分量。因此在已经被抽象成有向图的无向图中，我们只需求出强连通分量就恰恰是边双联通分量。

对上述结论作一个简要但不严谨的说明：考虑 Tarjan-Bridge 算法实际上抽象出的有向图实际上就是一棵搜索树，而在该搜索树上构成环当且仅当出现返祖边，即在无向图中该分量内不会出现桥，容易发现的是搜索树最终可以被划分为类似环-桥-环的结构，与边双联通分量的定义实际上是相符的。关于其为什么是极大的，这点可以参照对于求 SCC 算法中解释“为什么环内路径不影响结果”的方法。

这样想的话，实际上这种方法是把无向图抽象为有向搜索树，通过搜索树的性质利用对于有向图求 SCC 的方法求出边双联通分量，这种抽象方式令人拍手称妙。

代码如下：

```cpp
void tarjan(int x,int father){
	dfn[x]=low[x]=++nowtime;
	s.push(x);
	for(register int i=head[x];i;i=e[i].next){
		int v(e[i].to);
		if(!dfn[v]){
			tarjan(v,i);
			low[x]=Min(low[x],low[v]);
		}else if(i!=(father^1))low[x]=Min(low[x],dfn[v]);
 	}
	if(dfn[x]==low[x]){
		++dcccnt;
		int k;
		do{
			k=s.pop();
			belong[k]=dcccnt;
		}while(k!=x);
	}
}
int main(){
	for(register int i=1;i<=n;++i)
		if(!dfn[i])tarjan(i,i);
}
```

---

## 作者：Jeremiahy (赞：32)

更新：2022.9.21 修正代码。

前置知识：[割边](https://www.cnblogs.com/ljy-endl/p/11595161.html)
# 边双连通分量
### 概念

若一张无向连通图不存在桥（割边），则称它为“边双连通图”。

无向图的极大边双联通子图被称为“边双联通分量”，简记为“e-DCC”。

在上面的定义中，我们称一个双连通子图 $G'=(V',E')$ “极大”（其中 $V'\subseteq V$, $E'\subseteq E$），是指不存在包含 $G'$ 的更大的子图 $G''=(V'',E'')$，满足 $V'\subseteq V''\subseteq V$, $E' \subseteq E''\subseteq E$ 并且 $G''$ 也是双连通子图。

### 定理

一张无向图时“边双连通图”，当且仅当任意一条边都包含在至少一个简单环中。

### 求法

只需求出无向图中所有的桥，把桥都删除后，无向图会分成若干个连通块，每一个联通块都是一个“边双连通分量”。

在具体的程序实现中，一般先用 Tarjan 算法标记出所有的桥边。然后，再对整个无向图执行一次深度优先遍历（遍历的过程中不访问桥边），划分出每个连通块。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2000010, M = 6000010;
int head[N], ver[M * 2], Next[M * 2];
int dfn[N], low[N], c[N];//c[x] 表示节点 x 所属的“边双连通分量”的编号。
int n, m, tot = 1, num, dcc;
bool bridge[N * 2];
vector<int> ans[N * 2]; //存储各个连通块及其内部节点编号
void add(int x, int y) {//邻接表存图
	ver[++tot] = y, Next[tot] = head[x], head[x] = tot;
}
void tarjan(int x, int in_edge) { //求割边
	dfn[x] = low[x] = ++num;
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (!dfn[y]) {
			tarjan(y, i);
			low[x] = min(low[x], low[y]);
			if (low[y] > dfn[x])
				bridge[i] = bridge[i ^ 1] = true;
		}
		else if (i != (in_edge ^ 1))
			low[x] = min(low[x], dfn[y]);
	}
}
void dfs(int x) {
	c[x] = dcc;
	if (x) //防止加入 0
		ans[dcc].push_back(x); 
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (c[y] || bridge[i]) continue;
		dfs(y);
	}
}
int main(){
	ios::sync_with_stdio(false); //关闭与 scanf 的同步来提速
    cin >> n >> m;
    for (register int i = 1; i <= m; i++) {
    	int x, y;
    	cin >> x >> y;
    	add(x, y), add(y, x);
	}
	for (register int i = 1; i <= n; i++)
		if (!dfn[i]) tarjan(i, 0);
	for (register int i = 1; i <= n; i++)
		if (!c[i]) {
			++dcc;
			dfs(i);
		}
	cout << dcc << "\n";
	for (register int i = 1; i <= dcc; i++) { //输出
		cout << ans[i].size();
		for (register int j = 0; j < ans[i].size(); j++)
			cout << ' ' << ans[i][j];
		cout << "\n";
	}
    return 0;
}
```

### 推荐

推荐联系配套的[点双连通分量](https://www.luogu.com.cn/problem/P8435)。

注：本文抄自 lyd 蓝书。

---

## 作者：Code_星云 (赞：18)

在进入本题之前，我们要先掌握几个定义


------------
### 1.时间戳 ###
在图的深度优先遍历过程中，按照每个节点第一次被访问的时间顺序，依次给予 $N$ 个节点 $1-N$ 的整数标记，该标记被称为“时间戳”，记为 $dfn_x$。

### 2.搜索树 ###
这个很好理解，搜索树就是指在无向图（本题为无向图）中，任选一个节点作为根，深度优先遍历整个图，每个点只访问一次所构成的的路径。它的性质与树一样，两点间有且仅有一条路径。（形成的森林除外）

### 3.追溯值 ###
追溯值用 $low_x$ 表示，令 $subtree_x$ 表示搜索树中以 $x$ 为根的子树。$low_x$ 定义为以下节点的时间戳的最小值：  
1. $subtree_x$ 中的节点；  
2. 通过 $1$ 条不在搜索树上的边，能够达到 $subtree_x$ 的节点。(可以画图理解一下)

### 4.桥（割边） ###
对于一个连通无向图，若存在一条边，使得去掉这条边后，连通块分为两个不连接的部分，则称改边该无向图的桥（割边）。（一张图可能不只有一个桥）

### 5.割边判定法则 ###
无向边 $(x,y)$ 是桥，当且仅当搜索树上存在 $x$ 的一个子节点 $y$ 满足: 
#### $dfn_x<low_y$ ####

证明：根据追溯值的定义，$low_y$ 表示 $y$ 的子节点中时间戳的最小值，或者是从 $y$ 的子树出发，通过一条非搜索树上的边能够到达的点的时间戳的最小值。若有 $subtree_y$ 中的节点 $v$，$dfn_v$ 必定大于 $dfn_x$，因为 $v$ 也必定是 $x$ 的孩子结点。那么考虑第二种情况。从 $subtree_y$ 出发，有如下几种情况：   
1. $subtree_y$ 封闭，即没有非搜索树上的边连接了 $subtree_y$，此时 $low_y$ 的最小值就是自己的时间戳，也必定大于 $dfn_c$。
2. 从 $subtree_y$ 出发，有至少一条非搜索树上的边通往 $x$ 的其他子树或 $x$ 的父节点（包括 $x$ 自己）。此时，由于 $x$、$y$ 间已经有一条搜索树上的边相连，现在又有一条路径相连，故 $x$、$y$ 在一个简单环上。则若切断 $x$、$y$ 间的这条路径，$x$ 、$y$ 仍然连通，则该边不符合桥的定义。

故若 $(x,y)$ 是桥，当且仅当满足条件一，既满足 $dfn_x<low_y$。  
证毕。

------------

根据以上内容，我们易得求一张无向图桥的求法：
```cpp
void tarjan(int x,int in){ //in 表示进入这个点所走的边，作用是便于后面判断
	dfn[x]=low[x]=++idx; //追溯值要先赋值为时间戳
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(!dfn[y]){ 
			tarjan(y,i);
			low[x]=min(low[x],low[y]);
			if(dfn[x]<low[y]) edge[i].fl=edge[i^1].fl=true; //标记桥
		}else if(i!=(in^1)) low[x]=min(low[x],dfn[y]); 
                //这条边不在搜索树上，但不是通往其父节点的边（因为根据追溯值的定义2，要求是 subtree 里的节点才能更新x）
	} 
}
```
我们继续看定义
### 7.边双连通分量 ###
若一张无向连通图不存在桥，则称为边双连通图。   
无向连通图的最大边双连通子图被称为边双连通分量，记为 $e-DCC$ 。


------------
那我们该如何求 $e-DCC$ 呢？其实很简单，只需要将无向图里的所有桥去掉，剩下的每一个连通块就是一个边双连通分量。

```cpp
#include<cstdio>
#include<vector>
using namespace std;
struct e{
	int next,to;
	bool fl;  //是不是桥
}edge[4000005];
int idx=0,low[2000005],dfn[2000005],n,m,cnt=1,head[2000005],dcc=0;
//友情提示：cnt 一定要从2开始存，这样才能成对变换
bool vis[2000005];
vector<int>d[2000005];
void add_edge(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].fl=false;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
void tarjan(int x,int in){ //Tarjan 求桥模板
	dfn[x]=low[x]=++idx;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].to;
		if(!dfn[y]){
			tarjan(y,i);
			low[x]=min(low[x],low[y]);
			if(dfn[x]<low[y]) edge[i].fl=edge[i^1].fl=true; //无向图要把两个方向的边都标记了
		}else if(i!=(in^1)) low[x]=min(low[x],dfn[y]);
	} 
}
void dfs(int x){
	d[dcc].push_back(x); vis[x]=true;
	for(int i=head[x];i;i=edge[i].next){
		int v=edge[i].to;
		if(vis[v]||edge[i].fl) continue; //不能走桥
		dfs(v);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v; scanf("%d%d",&u,&v);
		add_edge(u,v);
		add_edge(v,u);
	}
	for(int i=1;i<=n;i++) //最开始整个图可能不连通哦
	  if(!dfn[i]) tarjan(i,0);
	for(int i=1;i<=n;i++)
	  if(!vis[i]){
	  	dcc++;
	  	dfs(i);
       }
    printf("%d\n",dcc);
    for(int i=1;i<=dcc;i++){
    	printf("%d ",d[i].size());
    	for(int j=0;j<d[i].size();j++)
    	  printf("%d ",d[i][j]);
    	puts("");
	}
	return 0;
} 
```

---

## 作者：World_Creater (赞：17)

**修复了英文与中文间的空格**

orz 题解区的神犇已经将桥和边双的基本做法讲明白了，那本蒟蒻就写一种别的做法吧。  
### 利用栈存储答案  
这种做法与[点双](https://www.luogu.com.cn/problem/P8435) 十分类似，都是将遍历到的点依次加入栈，并在找到一个桥时，将栈中的存储的节点弹出作为一个边双的答案，仅在细节处理时有些变化。
1. 记录答案时（找到桥时）不再记录当前节点。  
这个很显然吧，毕竟这条桥就是用来区分边双的。
2. 若图中不存在桥时  
我们在求点双时，~~暴力地~~将割点的条件直接修改为  `low[v]>=dfn[u]` 而省略根节点的判断。这样我们可以将剩余的节点与根节点一起放入一个点双。  
但很显然，**如果图中不存在桥，就不可能使条件** `low[v]>dfn[u]` **成立**  
我们考虑在每一次搜索前，建立一个虚拟源点指向原来的根（单向双向均可，因为正常的 `Tarjan` 本来就不要求走回头路），让这个虚拟节点成为新的根。这样，原先我们新加的虚拟边就成为了虚拟桥。这样就使图中**至少存在一个桥**。也可以解决独立节点的问题。


下面是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,nxt[4100005],head[2000005],k=1,cnt,go[4100005],dfn[2000005],low[2000005],ans;
vector<int> dcc[500005];
void add(int x,int y)
{
	nxt[++k]=head[x];
	head[x]=k;
	go[k]=y;
}
stack<int>sta;
void tarjan(int x,int edge)
{
	dfn[x]=low[x]=++cnt;
	sta.push(x);
	for(int i=head[x];i;i=nxt[i])
	{
		int g=go[i];
		if(!dfn[g])
		{
			tarjan(g,i);
			low[x]=min(low[x],low[g]);
			if(low[g]>dfn[x])//非常正常的求桥
			{
				ans++;
				int p;
				do{
					p=sta.top();
					sta.pop();
					dcc[ans].push_back(p);
				}while(p!=g);//记录答案
           //这里不再需要加入当前节点了
			}
		}
		else if(i!=(edge^1))  //不走回头路
		low[x]=min(low[x],dfn[g]);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		if(u==v) continue;//重边
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i]) 
		{
			add(i+n,i);//虚拟点tarjan
			tarjan(i+n,0);
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=ans;i++)
	{
		printf("%d ",dcc[i].size());
		for(int j=0;j<dcc[i].size();j++)
		printf("%d ",dcc[i][j]);
		puts("");
	}
}
```

相对于割裂出来各个子图，在进行搜索的做法，省略了一次搜索和两个标记数组。但是导致了边数和点数的增多以及在原来的 `Tarjan` 需进行栈操作，也许互有优劣？

---

## 作者：老莽莽穿一切 (赞：16)

[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16838032.html)

---

这里介绍一种与众不同的写法。

> 前置知识：强联通分量

回忆强联通分量的算法过程，我们利用 **有向图** 的 dfn 树将图上的所有边分成四种：树边、前向边、后向边和横向边。

其中在原有树边的基础上，前向边不发挥作用，后向边一定发挥作用，横向边可能发挥作用，这个过程中我们维护了一个栈，用这个栈来确定一条边是否发挥作用（只有终点在栈里的边才会发挥作用）。

我们发现边双和强联通分量是类似的，所以可以将求强联通分量的算法拓展到无向图上，得到一个 **不需要求桥** 的边双算法。

首先一个重要的性质，在无向图除了树边就只有后向边，证明这里略过。

那么也就说明我们可以省去维护一个点是否在栈内的过程，栈内依然维护 **当前点的所有祖先点所属的边双中遍历过的所有点** 。

此时因为所有边都是后向边，即所有非树边都指向自己的祖先，可以直接转移更新 `low`。

这样就能做到甚至比普通的求强联通分量更加简单，但要注意一点，因为求的是无向图的边双，我们必须要将从父亲处过来的那条边（即树边）无视，可以直接像正常做 dfs 时那样将父亲特判掉，但因为可能出现重边，最好的办法是利用无向图相反边在链式前向星中相邻的特点直接得到需要特判掉的边的编号，如果没有重边则可以直接记录父亲编号。

你谷例题：[**P8436 【模板】边双连通分量**](https://www.luogu.com.cn/problem/P8436)。

代码比先求桥再分边双简单得多（老莽の代码头略大）。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define Reimu inline void // 灵梦赛高
#define Marisa inline int // 魔理沙赛高
#define Sanae inline bool // 早苗赛高
#define Reisen inline LL  // 铃仙赛高

typedef long long LL;
typedef unsigned long long ULL;
typedef __int128 Suika;

inline ostream &operator<<(ostream &cout, Suika x) {
	static const LL LIM = 1e18;
	return x < LIM ? cout << LL(x) : cout << LL(x / LIM) << setw(18) << setfill('0') << LL(x % LIM);
}

typedef pair<int, int> Pii;
typedef tuple<int, int, int> Tiii;
#define fi first
#define se second

#define all(vec) vec.begin(), vec.end()
#define TY(type) const type&

template<typename Ty>
Reimu clear(Ty &x) { Ty().swap(x); }

const int N = 500010, M = 2000010;

struct Edge { int y, nx; } E[M << 1];

int n, m, eCnt, tot, cnt, top;
int lnk[N], dfn[N], low[N], stk[N];
vector<int> cc[N];

Reimu addE(int x, int y) { E[eCnt] = {y, lnk[x]}; lnk[x] = eCnt++; }

Reimu Tar(int x, int fe) {
	dfn[x] = low[x] = ++tot;
	stk[++top] = x;
	for (int e = lnk[x], y; ~e; e = E[e].nx) if (e ^ fe) {
		if (dfn[y = E[e].y]) low[x] = min(low[x], dfn[y]);
		else Tar(y, e ^ 1), low[x] = min(low[x], low[y]);
	}
	if (low[x] < dfn[x]) return;
	++cnt; do cc[cnt].emplace_back(stk[top]); while (stk[top--] ^ x);
}

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	cin >> n >> m;
	memset(lnk + 1, -1, n << 2);
	for (int i = 1, x, y; i <= m; ++i) cin >> x >> y, addE(x, y), addE(y, x);
	for (int i = 1; i <= n; ++i) if (!dfn[i]) Tar(i, -1);
	cout << cnt << '\n';
	for (int i = 1; i <= cnt; ++i) {
		cout << cc[i].size() << ' ';
		for (int x: cc[i]) cout << x << ' ';
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：gan1234 (赞：11)

本题解介绍一下利用差分找桥的方法来做这道题，个人认为更好理解。

### 差分找割边

![](https://cdn.luogu.com.cn/upload/image_hosting/czgxi8ry.png)

#### 概念

* dfs 生成树：dfs 一个图得到的生成树
* 树边：示意图中实线表示的边。即在生成树上的边
* 非树边：示意图中虚线表示的边。即不在生成树上的边。
* 桥；也叫割边，如果删掉一条边后，图中联通分量增加，那么这条边就是桥

如果一个点可以直接或间接通过非树边到自己的祖先，那么我们称这个点被非树边覆盖。

观察无向图的 dfs 生成树，我们发现，如果一个节点被非树边覆盖（如图中的 $5,6$），那么就算删掉它与父结点的边，也依旧联通。相反，如果一个结点没有被非树边覆盖，那么删掉它与父结点的边，它的子树与其它部分就不再联通了。

也就是说，**找到没有被非树边覆盖的点，它与父结点的边就是桥。**
#### 做法
考虑最暴力的方法，先在 dfs 时找到所有非树边，
再对于每条非树边，将覆盖的点做标记。复杂度 $O(nm)$。

如何优化？将树上的一条路径打上标记，很明显，可以利用树上差分轻松解决这个问题。将非树边的一端 $+1$，另一端 $-1$。最后再 $O(n)$ 求和。如果一个点为 $0$，说明它没有被非树边覆盖。这样，$O(n+m)$ 就足以求出所有桥。

最后，我们根据桥的性质，将所有桥删去，剩下的联通块就是边双连通分量了，$O(n)$ 即可求出。

最终，总复杂度为 $O(n+m)$。

### 代码

本蒟蒻丑陋的代码。
代码的实现不是很好，常数很大，卡常调了很久。

[AC记录](https://www.luogu.com.cn/record/96108707)

```cpp
#include<bits/stdc++.h>
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define P(x,y) (long long)min(x,y)*500000ll+(long long)max(y,x)
using namespace std;
vector<int>G[500005];
vector<int>ans[500005];//答案。
int a[500005],vis[500005],dep[500005],s[500005];
//a：每个点打的标记。s：子树内标记之和。
//dep：每个点深度。vis：是否访问过某个点。
int n,m;
int cnt;
int mod=114511;
struct Hash{
//卡常，自己实现了哈希表，对时间空间比较卡得不紧可以用 map 或 unordered_map 。
    vector<long long>v1[200000];
    vector<short>v2[200000];
    short& operator[](long long k){
        int t=k%mod;
        int l=v1[t].size();
        for(int i=0;l>i;i++)
            if(v1[t][i]==k)return v2[t][i];
        v1[t].push_back(k);
        v2[t].push_back(0);
        return v2[t].back();
    }
}hash1,hash2;
//hash1 用来判断一条边是否是桥。
//hash2 用来判断是否是重边（如果数据没有可以直接去掉）
void dfs1(int x,int pre){
    if(dep[x]<dep[pre]){//如果回到祖先，说明是非树边
        a[x]++;a[pre]--;
    }
    if(dep[x]!=0)return ;
    dep[x]=dep[pre]+1;
    int l=G[x].size();
    for(int i=0;l>i;i++)
        dfs1(G[x][i],x);
}
int dfs2(int x,int pre){//差分
    if(vis[x]==1)return s[x];
    vis[x]=1;
    s[x]=a[x];
    int l=G[x].size();
    for(int i=0;l>i;i++)
        if(dep[G[x][i]]>dep[x]&&vis[G[x][i]]==0)
            s[x]+=dfs2(G[x][i],x);
    if(s[x]==0&&hash2[P(x,pre)]==1)hash1[P(x,pre)]=1;
    //如果没有被覆盖，且没有重边，说明是桥。
    return s[x];
}
void dfs3(int x){
    if(vis[x]!=0)return ;
    ans[cnt].push_back(x);
    vis[x]=cnt;
    int l=G[x].size();
    for(int i=0;l>i;i++){
        if(hash1[P(x,G[x][i])]!=1)//不经过桥。
            dfs3(G[x][i]);
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int x,y;
    cin>>n>>m;
    for(int i=0;m>i;i++){
        cin>>x>>y;
        G[x].push_back(y);
        G[y].push_back(x);
        hash2[P(x,y)]++;//统计重边。
    }
    for(int i=1;n>=i;i++)
        if(!dep[i])
            dfs1(i,0);
    for(int i=1;n>=i;i++)
        if(vis[i]==0)dfs2(i,0);
    memset(vis,0,sizeof(vis));
    for(int i=1;n>=i;i++){
        if(vis[i]==0){
            cnt++;
            dfs3(i);
        }
    }
    cout<<cnt<<endl;
    for(int i=1;cnt>=i;i++){
        int l=ans[i].size();
        cout<<l<<" ";
        for(int j=0;l>j;j++)
            cout<<ans[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}
```


---

## 作者：LittleMoMol (赞：10)

## P8436 【模板】 边双连通分量

### 前言
本文聊一聊边双连通分量是什么、如何求边双连通分量。

### 概念

割边（桥）：在一个联通的无向图中，若删掉某条边，使得这个无向图不连通，那么这条边就称为“割边（桥）”，一个无向图中可能有不止一条割边。

双联通子图：在原图的某个子图 $G'$ 中，不存在割边，那么 $G'$ 就为双联通子图。

边双连通分量：原图中的极大双联通子图就为边双连通分量。形式化地，若某个双联通子图 $G'$， 不存在其他的一个双联通子图 $G''$，使得 $G' \subsetneq G'' $，那么 $G'$ 就为边双连通分量，简称“e-DCC”。

### 找割边

找到边双连通分量的第一步是设法找到割边，颜值超级超级高的 tarjan 给出了很巧妙的求解方法。

不难发现，割边的两个端点，只有一条路径相连（这是定义嘛），也就是说，如果我们吧这个路径堵住，那么它们就不会联通。

代码该怎样写？

- 引入一个时间戳，表示对应节点在遍历时是第几个被访问到的，每到达一个点先给这个点附上时间戳的值，随后时间戳 +1，等待下一次赋值。

- 对于当前点 $u$ ，令上一次遍历时到达到它的有向边为 $e$，我们遍历其除了 $e$ 的反向边以外的所有连边，如果某条边是割边，那么这条边遍历的点一定到不了之前遍历过的点。对于每个能到达的点，我们更新对应点的时间戳，使其时间戳尽量小（取最小值操作），如果某个点更新完毕后的时间戳不大于更新前的对应点的时间戳，说明这两个点之间的边就是割边。

代码如下



```cpp
void tarjan(int u, int from)
{
	dfn[u] = low[u] = ++ timestamp; //timestamp为时间戳
	
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (!dfn[j])
		{
			tarjan(j, i);
			low[u] = min(low[u], low[j]);
			if (low[j] > dfn[u])
				is_bridge[i] = is_bridge[i ^ 1] = true; //is_bridge来维护i是否为桥
		}
		else if (i != (1 ^ from)) //不能走反向边
			low[u] = min(low[u], dfn[j]); //更新时间戳
	}
	return;
}
```

### 找边双连通分量

有上面的基础，这个就简单了。

如果经过一通更新发现它的时间戳没有变化，说明这个点已经是边界了。

维护一个栈来统计遍历的点数，到达边界后弹出直至弹到最初遍历节点，所弹的所有节点构成一个边双连通分量。

代码如下

```cpp
void tarjan(int u, int from)
{
	dfn[u] = low[u] = ++ timestamp;
	stk[ ++ top] = u;
	
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (!dfn[j])
		{
			tarjan(j, i);
			low[u] = min(low[u], low[j]);
			if (low[j] > dfn[u])
				is_bridge[i] = is_bridge[i ^ 1] = true;
		}
		else if (i != (1 ^ from))
			low[u] = min(low[u], dfn[j]);
	}
	
	if (dfn[u] == low[u])
	{
		dcc_cnt ++ ; //dcc_cnt为边双连通分量编号
		int y;
		do
		{
			y = stk[top -- ];
			id[y] = dcc_cnt; //id为某点的所在边双连通分量编号
		} while (y != u);
	}
	
	return;
}
```

### 统计答案

这个问题，对于总的边双连通分量个数，答案就为 dcc_cnt 的值；而对于每一个边双连通分量中的点的个数，我们开个数组 tot 来维护，这个很简单；对于节点编号，我们之前的 id 数组起到了至关重要的作用，在此基础上再用一个 vector 来存答案即可。（详见代码）

### Code

```cpp
#include <iostream>
#include <cstring>
#include <vector>

using namespace std;

const int N = 500010, M = 2000010 * 2;

int n, m;
int h[N], e[M], ne[M], idx;
int dfn[N], low[N], timestamp;
int stk[N], top;
int id[N], dcc_cnt;
bool is_bridge[M];
int tot[N];
vector <int> ans[N];

void add(int a, int b)
{
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx ++ ;
	return;
}

void tarjan(int u, int from)
{
	dfn[u] = low[u] = ++ timestamp;
	stk[ ++ top] = u;
	
	for (int i = h[u]; ~i; i = ne[i])
	{
		int j = e[i];
		if (!dfn[j])
		{
			tarjan(j, i);
			low[u] = min(low[u], low[j]);
			if (low[j] > dfn[u])
				is_bridge[i] = is_bridge[i ^ 1] = true;
		}
		else if (i != (1 ^ from))
			low[u] = min(low[u], dfn[j]);
	}
	
	if (dfn[u] == low[u])
	{
		dcc_cnt ++ ;
		int y;
		do
		{
			y = stk[top -- ];
			id[y] = dcc_cnt;
		} while (y != u);
	}
	
	return;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> m;
	memset(h, -1, sizeof h);
	for (int i = 1; i <= m; i ++ )
	{
		int a, b;
		cin >> a >> b;
		add(a, b);
		add(b, a);
	}
	
	for (int i = 1; i <= n; i ++ )
		if (!dfn[i]) tarjan(i, -1);
	
	cout << dcc_cnt << endl;
	
	for (int i = 1; i <= n; i ++ )
	{
		tot[id[i]] ++ ;
		ans[id[i]].push_back(i);
	}
	//统计答案
	int p = 1;
	while (tot[p])
	{
		cout << tot[p] << ' ';
		for (int i = 0; i < ans[p].size(); i ++ )
			cout << ans[p][i] << ' ';
		p ++ ;
		cout << endl;
	}
	
	return 0;
}
```

### 后语
应用练习 [P2860](https://www.luogu.com.cn/problem/P2860)

---

## 作者：pjykk (赞：9)

[OI-wiki 上的参考资料](https://oi-wiki.org/graph/bcc/)

看上去大家都使用的是 tarjan 算法来求边双连通分量。但其实对于边双连通分量，我们有其他的做法。下面介绍的做法（个人认为）码量不大，并且思想比 tarjan 算法简单一些。

考虑对无向图进行 dfs，得到一棵 dfs 树。

我们考虑每一条不在树上的边 $(u,v)$，很明显，这条边和 $u,v$ 在树上的路径构成了一个环。因此此时这条边和它在树上对应的路径都不会是割边。于是我们对于每条不在 dfs 树上的边标记好它在树上对应的路径，这样未被标记到的边就是割边。

放一张图以便理解。（图源 OI-wiki）

红色的边是不在 dfs 树上的边。对于每条红边我们将树上对应的路径打好标记（用绿色表示）。于是剩余的黑色的边就是割边。

![](https://oi-wiki.org/graph/images/bcc-1.svg)

接下来我们考虑如何快速地标记树上的路径。做树上差分即可。

注意到无向图上的 dfs 树有优秀的性质，非树边不会有横叉边，只会有儿子和祖先相连的边（否则我们可以继续沿横叉边 dfs，这违反了 dfs 树的定义）。

因此我们我们就省去了求 LCA 的步骤。对于每一条非树边，直接在深度较大的结点上加 $1$，在深度较小的结点减 $1$，就完成了树上差分。所有的非树边都处理完后，我们做一下子树和，此时结点值为 $0$ 的结点到它的父亲的边就是割边。

求出割边之后将割边删去，剩下的部分就是一个个边双连通分量了。

最后我们给出代码实现。更多细节见注释。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <vector>
using namespace std;
const int maxn=500010,maxm=2000010;
inline int read()
{
    int ret=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
    return ret*f;
}
//cnt=1是为了方便之后e[i^1]查反边
//treecnt是图中dfs树的数量（因为原图可能不连通），rt是每棵树的根
//bcccnt是图中边双连通分量的数量
//vis为访问标记，w是点权（做差分用），dep为结点在树中的深度，fa为结点在树中的父亲
//另外无向图记得两倍空间
int n,m,cnt=1,treecnt,bcccnt,h[maxn<<1],vis[maxn],w[maxn],dep[maxn],rt[maxn],fa[maxn];
vector<int> bcc[maxn];//存边双连通分量
struct edge{int to,nxt,val;}e[maxm<<1];//这里给边设置了一个标记，1为树边，0为非树边，-1为割边
void addedge(int u,int v,int val)
{
    e[++cnt]=(edge){v,h[u],val};
    h[u]=cnt;
}
void dfs1(int u)//第一次dfs求出dfs树及相关的值
{
    vis[u]=1;
    for(int i=h[u];i;i=e[i].nxt)
    {
        int p=e[i].to;
        if(!vis[p])
        {
            e[i].val=e[i^1].val=1;
            dep[p]=dep[u]+1;
            fa[p]=u;
            dfs1(p);
        }
    }
}
void dfs2(int u)//第二次dfs做子树和
{
    for(int i=h[u];i;i=e[i].nxt)
        if(e[i].val)
        {
            int p=e[i].to;
            if(p!=fa[u])
            {
                dfs2(p);
                w[u]+=w[p];
            }
        }
}
void dfs3(int u)//第三次dfs统计边双连通分量
{
    vis[u]=1;bcc[bcccnt].push_back(u);
    for(int i=h[u];i;i=e[i].nxt)
    {
        if(e[i].val==-1)continue;//遇到割边就跳过
        int p=e[i].to;
        if(!vis[p])dfs3(p);
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        int u=read(),v=read();
        addedge(u,v,0);addedge(v,u,0);
    }
    for(int i=1;i<=n;i++)
        if(!vis[i])
        {
            rt[++treecnt]=i;
            dfs1(i);
        }
    for(int u=1;u<=n;u++)
        for(int i=h[u];i;i=e[i].nxt)
            if(!e[i].val)//若该边为非树边则做差分
            {
                int p=e[i].to;
                if(dep[p]<dep[u]){w[p]--;w[u]++;}//上面已有对这样写的解释。
                //注意这里我们只考虑了dep[p]<dep[u]的情况，这是因为所有的边都是双向边，我们只需统计一次
            }
    for(int i=1;i<=treecnt;i++)dfs2(rt[i]);
    for(int u=1;u<=n;u++)
        if(!w[u])//点权为0则与父亲之间的边为割边
            for(int i=h[u];i;i=e[i].nxt)
                if(e[i].val&&e[i].to==fa[u])
                    e[i].val=e[i^1].val=-1;
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++)
        if(!vis[i])
        {
            ++bcccnt;
            dfs3(i);
        }
    printf("%d\n",bcccnt);
    for(int i=1;i<=bcccnt;i++)
    {
        printf("%d ",bcc[i].size());
        for(auto it:bcc[i])printf("%d ",it);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：hswfwkj_ (赞：6)

传送门：[模板题](https://www.luogu.com.cn/problem/P8436)

前置知识：[割边（桥）](https://www.cnblogs.com/ljy-endl/p/11595161.html)，Tarjan 算法在无向图上的应用

概念就不介绍了。~~不知道概念来做模板题干什么。~~

## 做法：

首先，我们可以知道，一个边双连通分量内部一定不含有桥边，换句话说，**内部不含有桥边的极大连通分量就是一个边双连通分量**。

同时结合 Tarjan 算法的性质，栈顶到栈中一定有一段序列形成一个不含桥边的极大连通分量，我们就有了针对此题的做法。

主流做法是寻找所有的桥边，将其标记，然后用 dfs 求连通块，但是我这里要提供一种全新做法，它可以省略一遍 dfs，直接在 Tarjan 算法中就求出边双。

首先，让我们思考一个问题，如果在原图中，我们找到了桥边，便将栈中的元素全部出栈，作为一个边双连通分量，有可能会出现什么问题呢？（建议有了答案再往下看）

显然，你有可能会忽略掉你开始 dfs 的那个点所处的边双连通分量，因为你在初始的边双连通分量里找不到桥边。

这时，我们有两种解决方案:
1. 建立一个超级点，将其与每个连通块相连，便可以保证原图中的每个边双连通分量都分配到一条桥边。连通块可以用并查集维护。

代码如下：
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5,M=5e6+5;
int n, m, q, tot, top, res, cnt;
int ver[M], nxt[M], head[M];
int dfn[N], stk[N], low[N];
int f[N], vis[N];
vector<int> g[N];
inline void add(int x,int y)
{
    ver[++tot] = y;
    nxt[tot] = head[x];
    head[x] = tot;
}
void tarjan(int x,int fa)
{
	bool f = 0;
    stk[++top] = x;
    dfn[x] = low[x] = ++res;
    for(int i = head[x]; i; i = nxt[i])
    {
        int y = ver[i];
        if(!dfn[y])
        {
            tarjan(y, x);
            low[x] = min(low[x], low[y]);
            if(dfn[x] < low[y])//说明这条边是桥边
            {
                cnt++;
                while(stk[top+1] != y)
                	g[cnt].push_back(stk[top--]);//与点双不同，一个点只能存在于一个边双连通分量中
            }
        }
        else if(y != fa || f) low[x] = min(low[x], dfn[y]);
        if(y == fa) f = 1;
    }
}
int find(int k){return f[k] == k ? k : f[k] = find(f[k]);} 
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) f[i] = i;
    for(int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        add(x, y);
        add(y, x);
        f[find(x)] = find(y);//统计连通块的代表
    }
    for(int i = 1; i <= n; i++)
    {
        int fi = find(i);
    	if(!vis[fi])
    		add(0, fi), vis[fi] = 1;//建立超级点
    }
 	tarjan(0, 0);
    cout << cnt << '\n';
    for(int i = 1;i <= cnt; i++)
    {
    	cout << g[i].size() << ' ';
    	for(int j = 0; j < g[i].size(); j++)
    		cout << g[i][j] << ' ';
    	cout << '\n';
	}
    return 0;
}
```

2. 每次 Tarjan 结束后，便将栈清空，以统计你忽略掉的那个边双连通分量。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5, M = 5e6 + 5;
int n, m, q, tot, top, res, cnt;
int ver[M], nxt[M], head[M];
int dfn[N], stk[N], low[N];
int vis[N];
vector<int> g[N];
inline void add(int x,int y)
{
    ver[++tot] = y;
    nxt[tot] = head[x];
    head[x] = tot;
}
void tarjan(int x,int fa)
{
	bool f = 0;
    stk[++top] = x;
    dfn[x] = low[x] = ++res;
    for(int i = head[x]; i; i = nxt[i])
    {
        int y = ver[i];
        if(!dfn[y])
        {
            tarjan(y, x);
            low[x] = min(low[x], low[y]);
            if(dfn[x] < low[y])
            {
                cnt++;
                while(stk[top+1] != y)
                	g[cnt].push_back(stk[top--]);
            }
        }
        else if(y != fa || f) low[x] = min(low[x], dfn[y]);
        if(y == fa) f = 1;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
	cin >> n >> m;
    for(int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        add(x, y);
        add(y, x);
    }
 	for(int i = 1; i <= n; i++)
        if(!dfn[i])
        {
            tarjan(i, 0);
            cnt++;
            while(top)
                g[cnt].push_back(stk[top--]);
        }
    cout << cnt << '\n';
    for(int i = 1;i <= cnt; i++)
    {
    	cout << g[i].size() << ' ';
    	for(int j = 0; j < g[i].size(); j++)
    		cout << g[i][j] << ' ';
    	cout << '\n';
	}
    return 0;
}
```


---

## 作者：accomplishment (赞：3)

[传送门](https://www.luogu.com.cn/problem/P8436)

大家也可以做做 @[Sol1](https://www.luogu.com.cn/user/61088) 大佬出的模板 [U119054](https://www.luogu.com.cn/problem/U119054)。

还是先看样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/231uo0av.png)

图中点 $2, 3, 4, 5, 6$ 形成了一个环，环一定是边双，而点 $1$ 和 $7$ 都是独立的，所以它们自己分别是边双，共有三个边双。 

思路：先用 Tarjan 预处理出所有的桥，因为边双不可能包括桥（根据边双定义任意两点间有两条不经过同一条边得出），然后 DFS 一遍，遇到桥就跳过。然后用一个二维 vector 存储答案，共有 $x$ 个边双，输出第 $i + 1$ 行的第一个数就是 vector 第 $i$ 行的大小 ```_resMap[i].size()```（$1 \le i \le x$）。

下面给出我的代码（不喜勿喷）：

$Code: $

```cpp


#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 5e5 + 9;
const int MAXM = 2e6 + 9;

struct Edge {
	
	int _to;
	int _next;
	
};

int _maxi = 0;
int _edge = 0;
Edge _edgeArray[MAXM << 1];
int _headArray[MAXN];
int _preArray[MAXN];
int _lowArray[MAXN];
int _bccCount = 0;
int _bccNoArray[MAXN];
bool _bridgeArray[MAXM << 1];
vector<int> _resMap[MAXN];

void AddEdge (int from, int to) {
	
	static int tot = 1;
	
	_edgeArray[++tot] = {to, _headArray[from]};
	_headArray[from] = tot;
	
	_edgeArray[++tot] = {from, _headArray[to]};
	_headArray[to] = tot;
	
}

void Tarjan (int cur, int father) {
	
	static int dfsTime = 0;
	
	_preArray[cur] = _lowArray[cur] = ++dfsTime;
	
	for (int i = _headArray[cur]; i; i = _edgeArray[i]._next) {
		int to = _edgeArray[i]._to;
		
		if (!_preArray[to]) {
			Tarjan(to, cur);
			_lowArray[cur] = min(_lowArray[cur], _lowArray[to]);
			
			if (_lowArray[to] > _preArray[cur]) {
				_bridgeArray[i] = 1;
				_bridgeArray[i ^ 1] = 1;
			}
		}
		
		else if (to != father) {
			_lowArray[cur] = min(_lowArray[cur], _preArray[to]);
		}
	}
	
}

void Dfs (int cur) {
	
	_bccNoArray[cur] = _bccCount;
	_resMap[_bccCount].push_back(cur);
	
	for (int i = _headArray[cur]; i; i = _edgeArray[i]._next) {
		if (_bridgeArray[i]) {
			continue;
		}
		
		int to = _edgeArray[i]._to;
		
		if (!_bccNoArray[to]) {
			Dfs(to);
		}
	}
	
}

int main () {
	
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	
	int from = 0;
	int to = 0;
	
	cin >> _maxi >> _edge;
	
	for (int i = 0; i < _edge; i++) {
		cin >> from >> to;
		
		AddEdge(from, to);
	}
	
	for (int i = 1; i < _maxi + 1; i++) {
		if (!_preArray[i]) {
			Tarjan(i, 0);
		}	
	}
	
	for (int i = 1; i < _maxi + 1; i++) {
		if (!_bccNoArray[i]) {
			_bccCount++;
			Dfs(i);
		}
	}
	
	cout << _bccCount << '\n';
	
	for (int i = 1; i < _bccCount + 1; i++) {
		cout << _resMap[i].size() << ' ';
		
		for (int m = 0; m < _resMap[i].size(); m++) {
			cout << _resMap[i][m] << ' ';
		}
		
		cout << '\n';
	}
	
	return 0;
	
}
```


---

## 作者：ningago (赞：0)

> 发现自己并不会写边双。为了 @lovely_seele 姐姐的精神传承，使用 LCT 维护。

介绍一下使用 LCT 直接维护桥边，简称大炮打蚊子，优点是在线。

根据桥的定义，如果把点双连通分量看作点，桥看作边，那么一个性质是构成的图是一颗树。

我们考虑在加边的过程中在线地维护每条边是不是桥。

将边拆成点，每条边有一个权值，表示它暂时是不是桥，原图上的点没有权值（代码中体现为权值为 $0$）。

首先，如果边的两个节点在同一连通块中，这个边自己肯定不是桥。而且，这两个节点树上路径上的边，因为形成的一个环，所以也不是桥了。放在 LCT 上就是路径赋值 $0$，维护懒标记即可。

否则，就是正常的连边。这条边初始时默认是桥边，也就是说权值为 $1$。

一个性质是所以桥边都会被保留到树上，而非桥边会被部分保留到树上（代表曾经是桥边）。

所以建完边之后即可查询出哪些边是桥边。建出新图（树）后遍历连通块即可得到题目所述问题的解。

时间复杂度 $O(m\log n)$，空间复杂度 $O(n)$，注意数组开 $2$ 倍。

其实似乎可以直接在 LCT 上 dfs，但我太懒了哈哈哈。

注意常数。

[代码。](https://www.luogu.com.cn/paste/39fjwrdc)

---


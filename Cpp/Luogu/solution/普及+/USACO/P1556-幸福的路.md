# 幸福的路

## 题目描述

每天，John 都要为了农场里 $n$（$1 \leq n\leq 10$） 头牛的健康和幸福四处奔波。

每头牛的位置可以描述为一个二维坐标，John 从坐标原点 $(0,0)$ 出发。为了使路径更有趣，John 决定只沿着平行于坐标轴的方向行走，这样只能沿着东西南北方向运动。而且只有到达某头牛的坐标后 John 才会改变行走的方向（当然，如果有必要，John 也会穿过某头牛的坐标而不改变行走的方向。）

如果 John 改变行走的方向，他会原地转 $90^\circ$ 或者 $180^\circ$。John 的路径必须保证检查完所有牛后返回原点。

John 可以穿过某头牛的坐标而不改变方向任意次，请计算出有多少条路径满足 John 能检查完 $n$ 头牛，在每头牛的坐标处恰好改变一次方向。同一条路径从不同方向经过要计算两次。

## 样例 #1

### 输入

```
4
0 1
2 1
2 0
2 -5```

### 输出

```
2```

# 题解

## 作者：ghj1222 (赞：18)

注意到$n\le10$，所以枚举经过的拐弯牛的所有排列。

注意到STL是一个好东西，所以我这里偷懒直接使用了`next_permutation`

枚举所有n的排列，对于每一个排列也就是经过拐弯牛的顺序，我们要判断两点：
- 一个是相邻的两个牛(以及从(0,0)到第一个牛，和从最后一个牛到(0,0))的路径是否平行坐标轴，这个直接判相等即可。
- 还有一个是要判断经过每一头牛是否拐弯了，对于第p头牛我们可以计算从第p-1头牛(当p=1就是原点)到第p头牛的路径向量，和第p头牛到第p+1头牛(当p=n就是远点)的路径向量，通过两个向量的点积就可以方便地判断是否转弯，由于我们已经判断了是否垂直平行坐标系，所以点积为0说明转弯90度，点积小于0说明掉头，点积大于0说明没有转弯。

然后答案就是合法的n的排列的个数

```
#include <bits/stdc++.h>
using namespace std;

struct coord
{
    int x, y;
}c[12];

int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int n, ans;

bool work()
{
    //上一次的坐标
    int lx = 0, ly = 0;
    for (int i = 0; i < n; i++)
    {
        int p = a[i];
        int x = c[p].x, y = c[p].y;//本次的坐标
        int nx = c[a[i + 1]].x, ny = c[a[i + 1]].y;//下一次的坐标
        //判断路径是否平行于坐标轴
        if(((lx == x) || (ly == y)) == 0)
            return false;
        if(((nx == x) || (ny == y)) == 0)
            return false;
        //1和2是两个向量
        int x1 = x - lx, y1 = y - ly;
        int x2 = nx - x, y2 = ny - y;
        if((x1 * x2 + y1 * y2 > 0))//计算点积
        {
            return false;
        }
        lx = x;//更新坐标
        ly = y;
    }
    return true;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d%d", &c[i].x, &c[i].y);
    a[n] = n;
    do
        ans += work();
    while (next_permutation(a, a + n));
    printf("%d\n", ans);
    return dou;
}
```
让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)

---

## 作者：QianianXY (赞：16)

题的本质不难，大概也就黄题的水平，dfs即可。~~（我是不会告诉你我提交了3次才AC）~~

到达下一只牛（dfs下一步)的条件：

1、与当前的牛的x轴或y轴坐标相等。

2、**需要转弯才能到达**。

3、此前未经过。

第一个重点在于第二个条件，如何判断是否存在转弯？这里使用一个函数，通过对起始点和目标点的判断，返回线路的方向：

```cpp
inline int dire(int x, int y, int x1, int y1) {
	// 因为条件1，所以只用判断不相同的轴的大小关系。
	if (x < x1) return 1;
	if (x > x1) return 2;
	if (y < y1) return 3;
	if (y > y1) return 4;
}
```

第二个重点是判断是否为一条路径。为所有点定义一个bool数组，记录是否已经经过。在dfs函数的开头判断是否所有点都已经经过，如果成立，判断**是否能在转弯后回到原点**。如果仍然成立，则计数器加1。

最后代码如下：（码风欠佳请见谅）

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
struct point {int x, y;} p[11];
int n, ans = 0;
bool b[11], c;
inline int dire(int x, int y, int x1, int y1) {
	if (x < x1) return 1;
	if (x > x1) return 2;
	if (y < y1) return 3;
	if (y > y1) return 4;
}
void dfs(int x, int y, int d) {
	c = true;
	for (register int i = 0; i < n; i++)
		if (b[i]) {
			c = false; break;
		} 
	if (c && (x == 0 || y == 0) && dire(x, y, 0, 0) != d)  {
		ans++; return;
	}
	for (register int i = 0; i < n; i++)
		if ((p[i].x == x || p[i].y == y) && b[i] && dire(x, y, p[i].x, p[i].y) != d) {
			b[i] = false;
			dfs(p[i].x, p[i].y, dire(x, y, p[i].x, p[i].y));
			b[i] = true;
		}
}
int main() {
	memset(b, true, sizeof(b));
	scanf("%d", &n);
	for (register int i = 0; i < n; i++) scanf("%d%d", &p[i].x, &p[i].y);
	dfs(0, 0, 0);
	printf("%d\n", ans);
	return 0;****
}
```

~~（没错，加黑的那两处正是我两次WA的原因）~~

看着小蒟蒻写得那么认真，不点个赞再走吗？

---

## 作者：翼德天尊 (赞：8)

**一道（不）普通的dfs……**


------------
### STEP 1 审题

1.起点为（ 0 ，0 ），终点为 （ 0 ，0）；

2.两次行走不能来自同一个方向；

3.求~~抓完~~所有奶牛的总方案数；

ps：n<=10；



------------
### STEP 2 思路

看到数据范围，~~嘻嘻~~深搜+剪枝妥妥没问题~

深搜，不撞南墙不回头，直到搜到合理的答案才将总方案数+1后返回。


------------
### STEP 3 剪枝
~~其实这道题也不用怎么剪~~

1.走过的点不能走（这好像不算剪枝~

2.如方向一样就进行下一个点

3.没有任何一个坐标一样就返回


------------
### STEP 4 90分代码及注释（没错，拒绝ctrl+c）
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,cx[11],cy[11],v[11],ans;
//分别记录总数，每个点的坐标，判断是否走过以及答案数
void dfs(int x,int y,int g,int f){//分别表示该点的x,y坐标，层数以及过来的方向
	if (g==n){//如果每个点都处理完了
		int w;//记录如果向终点走的方向
		if (cx[x]==0){
			if (0>cy[y]) w=4;
			else w=3;
		}else{
			if (0>cx[x]) w=2;
			else w=1;
		}
		if (w==f) return;//相同就返回
		ans++;
		return;
	}
	for (int i=1;i<=n;i++){
		if (!v[i]){//没有走过
			if (g==n-1&&cx[i]!=0&&cy[i]!=0) return;//如果是最后一个点并且x,y坐标都不是0就返回
			int w;
			if (cx[i]==x){
				if (cy[i]>y) w=4;
				else w=3; 
			}else if (cy[i]==y){
				if (cx[i]>x) w=2;
				else w=1;
			}else continue;//如上记录方向
			if (w==f) continue;
			v[i]=1;//标记
			dfs(cx[i],cy[i],g+1,w);//搜
			v[i]=0;//回阙
		}
	}
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d %d",&cx[i],&cy[i]);//输入
    dfs(0,0,0,0);//搜索
    printf("%d\n",ans);//输出
    return 0;//好习惯++
}
```


------------
### STEP 5 完结撒花！
90分代码只要稍微改一下就可以AC了哦！

思路上，如果还有不懂的地方可以在评论区问我，我会第一时间解答哒！

如果都明白了，就点个赞纪念一下你的成长吧！

---

## 作者：pzc2004 (赞：8)

[题目传送门](https://www.luogu.org/problem/P1556)

思路：dfs，因为要在每个奶牛处恰好转向一次，所以就遍历所有奶牛，遍历一次转一次向，每次走到一头奶牛就记录该奶牛已经遍历过，寻找下一个没有遍历过的且前往该奶牛需要转向的奶牛并继续遍历。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,x[11],y[11],ans;//asn记录答案
void dfs(int zt,int a,int b,int fx)//zt记录每个奶牛是否遍历过（状态压缩），a，b记录当前坐标，fx记录当前方向，令向下为1，向上为2，向左为3，向右为4
{
	if(zt==(1<<n)-1)//如果已遍历完所有奶牛
	{
		if(a==0 && b>0 && fx!=1)ans++;//如果前往原点的方向与当前方向不同就将ans+1
		if(a==0 && b<0 && fx!=2)ans++;
		if(a>0 && b==0 && fx!=3)ans++;
		if(a<0 && b==0 && fx!=4)ans++;
	}
	for(int i=1;i<=n;i++)//寻找下一个可以遍历的奶牛
	{
		if(zt&(1<<(i-1)))continue;//如果已被遍历过就continue
		if(a==x[i] || b==y[i])//如果可以到达该奶牛
		{
			if(a==x[i] && b>y[i] && fx!=1)dfs(zt|(1<<(i-1)),x[i],y[i],1);//如果前往该奶牛的方向与当前方向不同，就转向，往下遍历，并记录当前奶牛已遍历过
			if(a==x[i] && b<y[i] && fx!=2)dfs(zt|(1<<(i-1)),x[i],y[i],2);
			if(a>x[i] && b==y[i] && fx!=3)dfs(zt|(1<<(i-1)),x[i],y[i],3);
			if(a<x[i] && b==y[i] && fx!=4)dfs(zt|(1<<(i-1)),x[i],y[i],4);
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&x[i],&y[i]);
	dfs(0,0,0,-1);//开始dfs，一开始没有方向就随便设个方向
	printf("%d",ans);
}
```
![](https://www.luogu.org/images/congratulation.png)

---

## 作者：ouuan (赞：7)

直接dfs，就是要判断一下方向，来的方向和去的方向相同要剪枝，而且要注意最后要回到原点。

因为判断方向要用很多次，所以可以写成一个函数。用ifelse的话会稍微长一点，所以我直接return x1==x2?int(y1>y2):int(x1>x2)+2;
如果觉得这样可读性较差（其实我完全不觉得）ifelse也很好实现

顺便说一下我之前用邻接表写的，代码很长，浪费空间，而且因为数据比较小STL反而慢..所以用邻接表还是要注意数据大小

突然发现那些1000用不上了..那是之前我写邻接表用的，懒得删了，就这样吧..

```
#include <iostream>

using namespace std;

int x[20],y[20],n,ans;
bool vis[20];

void dfs(int c,int d,int dep);
int dir(int x1,int y1,int x2,int y2);

int main()
{
	int i;
	
	cin>>n;
	
	for (i=1;i<=n;++i)
	{
		cin>>x[i]>>y[i];
		x[i]+=1000;
		y[i]+=1000;
	}
	
	x[0]=y[0]=1000;
	
	dfs(0,4,0);
	
	cout<<ans;
	
	return 0;
}

void dfs(int c,int d,int dep)
{
	if (dep==n)
	{
		if ((x[c]==1000||y[c]==1000)&&dir(1000,1000,x[c],y[c])!=d)
		{
			++ans;
		}
		return;
	}
	
	vis[c]=true;
	
	for (int i=1;i<=n;++i)
	{
		if (!vis[i]&&(x[i]==x[c]||y[i]==y[c])&&dir(x[i],y[i],x[c],y[c])!=d)
		{
			dfs(i,dir(x[i],y[i],x[c],y[c]),dep+1);
		}
	}
	
	vis[c]=false;
}

int dir(int x1,int y1,int x2,int y2)
{
	return x1==x2?int(y1>y2):int(x1>x2)+2;
}
```

---

## 作者：JOHNKRAM (赞：4)

简简单单的全排列。

中间加一个小剪枝：判断是否能走到这个点（不过貌似没必要）。

换句话说，就是先把横坐标或纵坐标相同的点连边，再求有多少条哈密顿回路。


---

## 作者：AmuroRay (赞：3)

思路：全排列

剪枝：如果不在上一个的正东南西北方即横坐标和纵坐标都不相等时不用在接着搜索，与上一次方向相同时不用接着搜索：

...

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
using namespace std;
int sum=0,g[1000010];
struct node{
    int x,y;
}a[1000010];
int f[1000010],v[1000010],n=0;
void dfs(int x,int v1){//x:搜到第几个,v1:上次的方向
    if(x==n+1){
        int d=0;
        if(a[f[x-1]].x<0)d=1;
        if(a[f[x-1]].x>0)d=2;
        if(a[f[x-1]].y<0)d=3;
        if(a[f[x-1]].y>0)d=4;
        if(v1!=d)g[f[x-1]]=1;//判断方向是否相同
        for(int i=1;i<=n;i++)
           if(!g[i]){
                   if(v1!=d)g[f[x-1]]=0;
                   return ;
               }
        if(v1!=d)g[f[x-1]]=0;
        if(a[f[x-1]].x==0 || a[f[x-1]].y==0){sum++;}
        return ;
    }
    for(int i=1;i<=n;i++){
        if(!v[i]){
            if(a[i].x==a[f[x-1]].x || a[i].y==a[f[x-1]].y){//是否在正东南西北方向
                int d=0;
                if(a[i].x>a[f[x-1]].x)d=1;
                if(a[i].x<a[f[x-1]].x)d=2;
                if(a[i].y>a[f[x-1]].y)d=3;
                if(a[i].y<a[f[x-1]].y)d=4;
                if(d!=v1)g[f[x-1]]=1;
                else if(x!=n) continue;//剪枝
                v[i]=1;
                f[x]=i;
                dfs(x+1,d);//接着搜索
                v[i]=0;
                if(d!=v1)g[f[x-1]]=0;
            }
        }
    }
}
int main(){
    int i,j,k,m;
    scanf("%d",&n);
    for(i=1;i<=n;i++){
         scanf("%d%d",&a[i].x,&a[i].y);//输入
    }
    dfs(1,0);
    printf("%d\n",sum);//输出
    return 0;
}
...
```

---

## 作者：IcyFoxer_XZY (赞：2)

### 算法分析
暴力和枚举几乎是一个同义词，看到数据范围， $n$ 最大只有 10 ，这就几乎等于直接告诉你要进行枚举了。枚举就是正解......

提供了生成排列的思路。枚举出所有到达牛的顺序，这样对于每次移动，我们只需要关心当前牛和下一头牛之间的关系（如果不剪枝的话）再在必要的地方进行剪枝（剪枝显然是要剪的）。

通常解题时，如果正着做不好做，就反着做。如果条件不够，就发掘隐含条件。如果情境复杂，就建模转化。如果计算复杂，就分类计算。如果规模复杂，可以考虑分治。如果不好入手，可以先构造再判断。如果不好构造，可以暴力枚举所有情况再判断。

本题可以采用枚举，将 “ 解答题 ” 转化为 “ 判断题 ” 。判断时的方案如下：

要求所有路径都必须是（正东南西北），我们可以认为东南西北是一个 $xOy$ 坐标系，然后将两点坐标相减，得到一个方向向量，再将这个向量分别向 $x$ 轴和 $y$ 轴进行映射，也就是相当于将其移到原点再正交分解，同时转化为单位向量。如果两次映射的结果均不等于 0 ，则说明这个移动不是正向的，需要抛弃。

### code:
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=15;
int n;
int ans;
int posx[maxn];
int posy[maxn];//各个点的x和y坐标，读入了之后就不要再变动了 
int pl[maxn];//排列的可能，直接用next_permutation
void meijv(){
	int lst_dx=0;//上一个方向向量 
	int lst_dy=0;
	for(int i=-1;i<n;i++){
		int x,y,/*当前点*/dx,dy,/*方向向量*/xp,yp/*下一个点*/;
		if(i==-1){//起点 
			x=0;
			y=0;
		}else{
			x=posx[pl[i]];
			y=posy[pl[i]];
		}
		if(i==n-1){//最后一个点 
			xp=0;
			yp=0;
		}else{
			xp=posx[pl[i+1]];
			yp=posy[pl[i+1]];
		}
		dx=xp-x;
		if(dx!=0)dx/=abs(dx);
		dy=yp-y;
		if(dy!=0)dy/=abs(dy);
		if(dx&&dy)return;//如果不走四个正向
		if(i==-1){
			lst_dx=dx;
			lst_dy=dy;
			continue;
		}
		if(dx==lst_dx&&dy==lst_dy)return;
		lst_dx=dx;
		lst_dy=dy;
	}
	ans++;
}
int main(){
	cin>>n;
	for(int i=0;i<n;++i)cin>>posx[i]>>posy[i]; 
	for(int i=0;i<n;++i)pl[i]=i;//起始排列  
	do{//枚举所有可能，依次进行检查 
		meijv();
	}while(next_permutation(pl,pl+n));//next_permutation自带返回值，生成完所有排列后跳出 
	cout<<ans;
	return 0;
}
```
Bye！

---

## 作者：AOTO (赞：2)


题目描述

每天，John都要为了农场里N(1≤N≤10)头牛的健康和幸福四处奔波。

每头牛的位置可以描述为一个二维坐标，John从坐标原点(0,0)出发。为了使路径更有趣，John决定只沿着平行于坐标轴的方向行走，这样只能沿着东西南北方向运动。而且只有到达某头牛的坐标后John才会改变行走的方向（当然，如果有必要，John也会穿过某头牛的坐标而不改变行走的方向。）

如果John改变行走的方向，他会原地转90°或者180°。John的路径必须保证检查完所有牛后返回原点。

John可以穿过某头牛的坐标而不改变方向任意次，请计算出有多少条路径满足John能检查完N头牛，在每头牛的坐标处恰好改变一次方向。同一条路径从不同方向经过要计算两次。
输入输出格式
输入格式：

第一行，整数N。

第2行到第N+1行，第i+1行是两个用空格隔开的整数x和y，表示第i头牛的坐标（-1000 ≤x, y ≤1000）

输出格式：

一行个整数，表示路径的量如果没有满足要求则输出 0。

输入输出样例
输入样例#1： 

4
0 1
2 1
2 0
2 -5

输出样例#1： 

2

这其实是一道比较简单的dfs。
唯一的难点在于一个方向的问题，就是到达了一个点必须转弯。

具体做法就是只要dfs每一个奶牛的位置，因为只有四个方向，所以和当前位置在同一行或同一列的奶牛的位置还没有到过，且需要改变行走的方向就可以到达那一个奶牛的位置。

PS:每次做完还需判断到达（0,0）的位置是否需要改变方向，如果需要改变才算一条是路径。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,a[11],b[11];
bool f[11];
int pd(int t,int w,int x,int y)  //判断行进方向
{
	if(t==x)
	{
		if(w<y)return 1;else return 2; 
	}
	if(w==y)
	{
		if(t<x)return 3;else return 4;
	}
}
void sc(int t,int w,int fx,int h)
//当前位置t,w，方向fx，和将要到达了第h个奶牛
{
	if(h>n)  
	{
		if(((t==0)||(w==0))&&(pd(t,w,0,0))!=fx)sum++;
        //在0行或0列，且要改变方向
		return;
	}
	for(int i=1;i<=n;i++)
	if((f[i]==false)&&          //没有做过
      ((t==a[i])||(w==b[i]))&&  //在同行或同列
      (pd(t,w,a[i],b[i])!=fx))  //需要改变方向
	{
		f[i]=true;
		sc(a[i],b[i],pd(t,w,a[i],b[i]),h+1);
		f[i]=false;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i]>>b[i];
	sc(0,0,0,1);
	printf("%d",sum);
	return 0;
}
```


---

## 作者：_111_ (赞：1)

本题思路并不难，考虑到 $n \le 10 $，直接一遍 dfs 就可以了。看到下面有许多题解都是用全排列写的，其实并不需这么麻烦，况且直接全排列可能会有许多不必要情况，导致运行时间增加，事实上确实如此，全排列 200ms，而本做法只需要 40ms。

大致思路：从坐标原点 $(0,0)$ 出发，每到一个点，枚举每一头可以到达的奶牛，可以到达的条件：
- 横坐标或纵坐标相等
- 这个点到下一个点的方向和前一个点到达这个点的方向不同（题目中已说明）

最后，到达一个点，这时全部点已经走完，如果这个点可以返回原点，答案加一。

## code
```c
#include<bits/stdc++.h>
using namespace std;
int n,ans=0;
bool vis[11];
struct node{
	int x,y;
}a[11];
bool check1(int x1,int y1,int x2,int y2){//判断横坐标或纵坐标是否相等 
	if(x1==x2||y1==y2){
		return true;
	}
	return false;
}
int check2(int x1,int y1,int x2,int y2){//1、2、3、4 分别代表上下左右（相对位置） 
	if(y1==y2&&x1>x2) return 1;
	if(y1==y2&&x1<x2) return 2;
	if(x1==x2&&y1<y2) return 3;
	if(x1==x2&&y1>y2) return 4;
}
void dfs(int x,int y,int d,int sum){
	if(sum==n){
		if((x==0||y==0)&&check2(x,y,0,0)!=d) ans++;//别忘了最后还需会原点 
		return ; 
	}
	for(int i=1;i<=n;i++){
		if(vis[i]||!check1(x,y,a[i].x,a[i].y)){
			continue;
		}
		int D;
		if((D=check2(x,y,a[i].x,a[i].y))!=d){
			vis[i]=1;
			dfs(a[i].x,a[i].y,D,sum+1);
			vis[i]=0;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	dfs(0,0,0,0);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：wfycsw (赞：1)

对于数据$n<=10$,显然直接深搜shi没有问题的，但与其他搜索题不同的是，本题的筛选处理有些复杂。（具体见代码）

$n<=10$意味着可以用状压做标记，可以省去$bool$数组，再加上亿些卡常，可以轻松地拿下最优解。

现在开始——上代码！

```cpp
#include<bits/stdc++.h>
#define RI register int
inline int read(){//快读
    RI s=0;char c=getchar();
	register bool f=0;
    while(!isdigit(c)){if(c=='-') f=1;c=getchar();}
    while(isdigit(c)) s=(s<<1)+(s<<3)+c-48,c=getchar();
    return f?-s:s;
}
inline void write(int x){//快输
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int n,a[11],b[11],ans,lg[11],p;
inline void sch(int x,int y,int f,int w){
	if(w==p){//判断是否遍历完所有牛
		if(!x&&y>0&&f!=1||!x&&y<0&&f!=2||x>0&&!y&&f!=3||x<0&&!y&&f!=4)
			++ans;//统计答案
		return;
	}	
	for(RI i=1;i<=n;++i)//枚举所有牛
		if(!(w&lg[i])){//判断是否被遍历过
			if(x==a[i]&&y>b[i]&&f!=1) sch(a[i],b[i],1,w|lg[i]);//如果需改变方向，就继续往下搜
			if(x==a[i]&&y<b[i]&&f!=2) sch(a[i],b[i],2,w|lg[i]);
			if(x>a[i]&&y==b[i]&&f!=3) sch(a[i],b[i],3,w|lg[i]);
			if(x<a[i]&&y==b[i]&&f!=4) sch(a[i],b[i],4,w|lg[i]);
		}
}
int main(){
	n=read();
   	lg[1]=1;//第一头牛记为1
	for(RI i=1;i<=n;++i){
		a[i]=read();b[i]=read();
		if(i!=1) lg[i]=lg[i-1]<<1;//状压预处理
		p+=lg[i];//计算遍历完所有牛的总和
	}
	sch(0,0,0,0);
	write(ans);
	return 0;
}
```
### 26ms(目前是最优解)

---

## 作者：Zhou_Wingay (赞：1)

### dfs:
利用 dfs 遍历来进行移动。

这里注意题目要求在到达下一个点之前不能改变方向，所以，每个点都只能到达与它行或列相等的点。

```cpp
void dfs(int h,int l){
	int i,flag=0;
	for(i=1;i<=n;i++){
		if(b[i]==0){flag=1;break;}
	}
	if(flag==0&&(h==0||l==0)){sum++;return;}
	for(i=1;i<=n;i++){
		if(a[i][0]==h||a[i][1]==l){
			if(b[i]==0){
				b[i]=1;
				dfs(a[i][0],a[i][1]);
				b[i]=0;
			}
		}
	}
}
```
### 剪枝：
如果连续两次走相同的方向，那这种走法就不符合题意。（这似乎不算剪枝）

需添加一个判断方向的的函数：
```cpp
int check(int x1,int y1,int x2,int y2){
	if(x1>x2) return 1;
	else if(x1<x2) return 2;
	else if(y1>y2) return 3;
	else if(y1<y2) return 4;
}
```
如果这个方向与上一个点到此点的方向一样，那么退出即可。

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[15][2],b[15];
int sum;
int check(int x1,int y1,int x2,int y2){//判断方向
	if(x1>x2) return 1;
	else if(x1<x2) return 2;
	else if(y1>y2) return 3;
	else if(y1<y2) return 4;
}
void dfs(int h,int l,int f){
	int i,flag=0;
	for(i=1;i<=n;i++){
		if(b[i]==0){flag=1;break;}
	}
	if(flag==0&&(h==0||l==0)&&f!=check(h,l,0,0)){sum++;return;}
	for(i=1;i<=n;i++){
		int fx=check(h,l,a[i][0],a[i][1]);//记录方向
		if(a[i][0]==h&&a[i][1]==l)continue;
		if(a[i][0]==h||a[i][1]==l){
			if(b[i]==0&&f!=fx){//如果方向不一样，退出
				b[i]=1;
				dfs(a[i][0],a[i][1],fx);//递归
				b[i]=0;//回朔
			}
		}
	}
}
int main(){
	int i,j;
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>a[i][0]>>a[i][1];
		b[i]=0;
	}
	dfs(0,0,-1);//初始时随便设个方向
	cout<<sum;
	return 0;
}
```

---

## 作者：tianxuan (赞：1)

看了楼上大佬的题解

深感佩服

但我觉得这是真的过于复杂了

我有一种**小白**也听得懂的方法 ~~因为是蒟蒻想的啊~~

首先题目讲到每个地方都要转一下

我们就可以记录一下现在的方向

然后判断是否重复

然后顺便再结尾时判断一下

回溯结束

接下来附赠我有着Chinglish注释的代码

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

struct pt{
	int x,y;
};

int k[12][12]={0};//whether there is a way
bool a[12];//whether it's used 
pt b[12];//some information about points
int n,ans=0;

bool p(pt,pt);//solve the problem
void q(int,int,int);//queen

int main(){
	b[0].x=b[0].y=0;//O
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>b[i].x>>b[i].y;
		for(int j=i-1;j>=0;j--){//find a way
			if(p(b[i],b[j])){
				if(b[i].x==b[j].x){
					if(b[i].y>b[j].y){
						k[i][j]=2;//record the direction
						k[j][i]=1;
					}
					else{
						k[i][j]=1;
						k[j][i]=2;
					}
				}
				else{
					if(b[i].x>b[j].x){
						k[i][j]=3;
						k[j][i]=4;
					}
					else{
						k[i][j]=4;
						k[j][i]=3;
					}
				}
			}
		}
	}
	q(0,0,0);	
	cout<<ans;
	return 0;
}

bool p(pt p1,pt p2){
	return p1.x==p2.x||p1.y==p2.y;
}

void q(int cur,int num,int s){
	if(cur==n){//whether it's in the end
		if(k[num][0]!=0&&k[num][0]!=s)//whether there is a to the beginning
			ans++;//record
		return;//end the circle
	}
	for(int i=1;i<=n;i++){
		if(!a[i]&&k[num][i]!=0&&k[num][i]!=s){//Can I go there?
			a[i]=1;
			q(cur+1,i,k[num][i]);
			a[i]=0;
		}
	}
		
}
```



---

## 作者：Smg18 (赞：0)

相信各位大佬的全排列已经很牛了吧。

好的。

这题如果真写 dfs，没了解全排列的可以先去看
[全排列](https://www.luogu.com.cn/problem/P1706)。

这题和全排列很像，都是要枚举他的走法。

我们马上可以写出一个 dfs 的全排列。

```cpp
#include<iostream>//以前写的，用来解释说明。
#include<cstdio>
#include<queue>
using namespace std;
int a[20], judge[20],n;
void dfs(int deep)//深度优先
{
	if (deep > n)
	{
		for (int i = 1; i <= n; i++)
		{
			printf("%5d", a[i]);
		}
		printf("\n");
	}
	else
	{
		for (int i = 1; i <= n; i++)
		{
			if(!judge[i])
			{
				judge[i] = 1;
				a[deep] = i;
				dfs(deep + 1);
				judge[i] = 0;
			}
		}
	}
}
int main()
{
	scanf("%d", &n);
	dfs(1);
	return 0;
}

```

那么，这题和他的区别就是判断方向了。

我们可以用 $1$，$2$，$3$，$4$ 来判断他目前在那个方向。

但有特判，每次的 John 必须要转方向，所以如果下一只奶牛方向一致，下一次可能不能走，如下：

```cpp
if ((arr[i].x==x||arr[i].y==y)&&brr[i]&&dire(x,y,arr[i].x,arr[i].y)!=d) {
 	brr[i] = 0;
  	dfs(arr[i].x, arr[i].y, dire(x, y, arr[i].x, arr[i].y));
	brr[i] = 1;
}
```

再补上一个函数，判断下一次走那个方向。

```cpp
inline int cmp(int t,int w,int x,int y) //特判坐标1，2，3，4方向 
{
  	if(t==x){
    	if(w<y){
    		return 1;
    	}
    	else{
    		return 2; 
    	}
  	}
  	if(w==y){
    	if(t<x){
    	  return 3;
    	}
    	else{
    	  return 4;
    	}
  	}
}
```

特判完直接套全排列。

完整代码：
------------

```cpp
#include<bits/stdc++.h>
#include<ctime>
#define ll long long
//priority_queue<int,vector<int>,greater<int>>q1
using namespace std;
const int N = 1e5+10;
int n,sum,a[N],b[N];
bool used[N];
inline int cmp(int t,int w,int x,int y) //特判坐标1，2，3，4方向 
{
  	if(t==x){
    	if(w<y){
    	  	return 1;
    	}	
   		else{
    		return 2; 
    	}
  	}
  	if(w==y){
    	if(t<x){
    	  	return 3;
    	}
    	else{
    	  	return 4;
    	}
  	}
}
void dfs(int now,int last,int x,int y)
{
	if(y>n){//出口
    	if(((now==0)||(last==0))&&(cmp(now,last,0,0))!=x)sum++;
      	return;
  	}
  	for(int i=1;i<=n;i++){//全排列照搬
    	if((used[i]==0)&&((now==a[i])||(last==b[i]))&&(cmp(now,last,a[i],b[i])!=x)) {
      		used[i]=1;
      		dfs(a[i],b[i],cmp(now,last,a[i],b[i]),y+1);
      		used[i]=0;
    	}
  	}
}

int main()
{
  	cin>>n;
  	for(int i=1;i<=n;i++)
  	cin>>a[i]>>b[i];
  	dfs(0,0,0,1);
  	cout<<sum;
  	return 0;
}
```

~~完美。~~




---

## 作者：Del_Your_Heart (赞：0)

# 写在前面
[可在博客内阅读](https://www.luogu.org/blog/CreeperBatter/solution-p1556)

花了$1.5h$考虑除搜索以外的方法解决这题（~~我tcl~~）
- - -

# 题目大意：
### 给你$n$个点，求出从$(0,0)$不重复不遗漏地经过这些点并回到$(0,0)$的路径数量，要求每到达一个点换个方向，且在到达下一个点之前不能换方向。

- - -
# 思路分析：
注意到
> **在到达下一个点之前不能换方向**

也就是从一个点只能去到和它**横纵坐标相等**的点，为方便叙述，后文将这样一对点描述为**相互可达**，且**点$1$表示$(0,0)$**。

注意到
> $1 \leq N \leq 10$

考虑**在一个点和与其横纵坐标相等的点之间连边**，然后这个问题就简化到一个**哈密尔顿回路计数问题**，考虑用**状态压缩$DP$** 解决。

令$f[i][j]$表示状态为$i$时走到第$j$个点的路径数量，易得状态转移方程
> $f[i][j]=\sum f[i$ $xor$ $2^j][k]$（$k,j$之间相互可达）

答案即为$\sum f[2^n-1][i]$ ($1,i$之间相互可达)

时间复杂度为$O(2^n*n^2)$

**核心代码如下**：
```cpp
f[1][1]=1;
for(register int i=1;i<=(1<<n)-1;i+=2)
	for(register int j=1;j<=n;++j)
		if(i&(1<<j-1))
			for(register int k=1;k<=n;++k)
				if((i&(1<<k-1))&&e[k][j]&&k!=j)
					f[i][j]+=f[i^(1<<j-1)][k];
```
~~然后就没了~~怎么珂能，如果你按照这个思路写，你会发现你只有$60pts$。

原来是忽略了
> **要求每到达一个点换个方向**

考虑对于每一个点记录其**前驱点**，即用$f[i][j][k]$表示状态为$i$时**从第$k$个点**走到第$j$个点的路径数量，状态转移方程为
> $f[i][j][k]=\sum f[i$ $xor$ $2^j][k][l];$ ($j,k$和$k,l$之间相互可达，并且$j,k,l$三点不共线)

这时初始化就不能简单的$f[1][1][1]=1$了，~~然鹅我并不知道如何初始化~~，所以只好对于每个点$1$能到达的点，将其初始值赋值为$1$，但这样有一个弊端：**当只有一个点时输出为$0$，但答案为$1$**，这样会$WA$一个点。~~特判一下就好了~~。如有大家更好的初始化方法请发在评论区，谢谢。

时间复杂度为$O(n^3*2^n)$，多了一个$n$，~~但是看成一个大常数也珂以~~。实际用时$34ms$，常数大约为$\frac{1}{300}$，珂能是因为~~数据太水~~建边要求太苛刻了吧。

------------

# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=0;char ch=getchar();
    while(!isdigit(ch)){f|=ch=='-';ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return f?-x:x;
}
int n,ans,f[2050][12][12];bool e[12][12];
struct point{int x,y;}p[12];
inline int fx(int a,int b){if(p[a].x==p[b].x)if(p[a].y>p[b].y)return 1;else return 2;if(p[a].y==p[b].y)if(p[a].x>p[b].x)return 3;else return 4;}//判断方向
int main(){
	n=read()+1;p[1]={0,0};
	if(n==2)cout<<1,exit(0);
	for(register int i=2;i<=n;++i)
		p[i]={read(),read()};
	for(register int i=1;i<=n;++i)
		for(register int j=i+1;j<=n;++j)
			if(p[i].x==p[j].x||p[i].y==p[j].y)
				e[i][j]=e[j][i]=1;//建边
	int mx=1<<n;
	for(register int i=2;i<=n;++i)
		if(e[1][i])
			f[1^(1<<i-1)][i][1]=1;//初始化
	for(register int i=1;i<=mx-1;i+=2)
		for(register int j=1;j<=n;++j)
			if(i&(1<<j-1))
				for(register int k=1;k<=n;++k)
					if((i&(1<<k-1))&&e[j][k])
						for(register int l=1;l<=n;++l)
							if((i&(1<<l-1))&&e[k][l]&&fx(j,k)!=fx(k,l))	
								f[i][j][k]+=f[i^(1<<j-1)][k][l];//更新状态
	for(register int i=2;i<=n;++i)
		for(register int j=2;j<=n;++j)
			if(e[1][i]&&e[i][j]&&fx(1,i)!=fx(i,j))
				ans+=f[mx-1][i][j];//统计答案
	cout<<ans;
	return 0;
} 
```















---

## 作者：Y_B_Y (赞：0)

先在上下左右中与现方向不同的方向中寻找有无牛（不包括已经检查过的）有就走无就不走（有的都要走一遍，具体看代码），再将方向更新为找的方向，检查总数加一，当tot为n时用check函数检查是否能回原点（之前没看到卡了好久）

方向的定义（这里的x，y与平面直角坐标系中的横坐标，纵坐标是相反的 ~~（绝对不是搞错了）~~ ）

方向一 向下（x小）的地方走

方向二 向上（x大）的地方走

方向三 向左（y小）的地方走

方向四 向右（y大）的地方走

check函数定义如下
```
bool check(int i,int ii,int ff)//i为x值，ii为y值，ff为来最后一头牛的方向（因为时当tot为n时调用还未转头）
{
	if(i==0)
	{
		if(ii>0&&ff!=3) return 1;//因为这里ff是去最后一只牛的方向，所以还未转向，如果ff不等于3才能转向三【（0<ii）所以方向为3向左（y小）的地方走】
		if(ii<0&&ff!=4) return 1; //同理
	}
	if(ii==0)
	{
		if(i>0&&ff!=1) return 1;//同理
		if(i<0&&ff!=2) return 1;//同理
	}
	return 0;
}
```

代码

```
#include<bits/stdc++.h>
using namespace std;
struct cow
{
    int x,y;
}c[1000];//牛
int n,ans;
bool vis[2001];//判断是否走过
bool check(int i,int ii,int ff)
{
    if(i==0)
    {
        if(ii>0&&ff!=3) return 1;
        if(ii<0&&ff!=4) return 1; 
    }
    if(ii==0)
    {
        if(i>0&&ff!=1) return 1;
        if(i<0&&ff!=2) return 1;
    }
    return 0;
}
void dfs(int w,int fx,int tot)
{
    if(vis[w]==1) return;//好像没有用
    if(tot==n)
    {
        if(check(c[w].x,c[w].y,fx)) ans++;//可以走完
        return;
    }
    if(w>0) vis[w]=1;//原点不能判断为走过
    int a=c[w].x,b=c[w].y;//更方便表示
    if(fx!=1)//不等于就意味着可以转过去
    {
        for(int p=1;p<=n;p++)
        {
            if(c[p].y==b&&c[p].x<a)
            {
                if(!vis[p]) dfs(p,1,tot+1);
            }
        }
    }
    if(fx!=2)//不等于就意味着可以转过去
    {
        for(int p=1;p<=n;p++)
        {
            if(c[p].y==b&&c[p].x>a)
            {
                if(!vis[p]) dfs(p,2,tot+1);
            }
        }
    }
    if(fx!=3)//不等于就意味着可以转过去
    {
        for(int p=1;p<=n;p++)
        {
            if(c[p].x==a&&c[p].y<b)
            {
                if(!vis[p]) dfs(p,3,tot+1);
            }
        }
    }
    if(fx!=4)//不等于就意味着可以转过去
    {
        for(int p=1;p<=n;p++)
        {
            if(c[p].x==a&&c[p].y>b)
            {
                if(!vis[p]) dfs(p,4,tot+1);
            }
        }
    }
    vis[w]=0;//回溯
    return;
}
int main()
{
    cin>>n;
    for(int p=1;p<=n;p++) cin>>c[p].x>>c[p].y;
    c[0].x=0,c[0].y=0;//最开始的坐标
    c[n+1].x=0,c[n+1].y=0;//最后要返回原点
    dfs(0,0,0);//注意，最开始无方向
    cout<<ans;
    return 0;
}
```



---


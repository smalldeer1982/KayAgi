# [IOI 1998 ] [USACO5.5] 矩形周长Picture

## 题目背景

墙上贴着许多形状相同的海报、照片。它们的边都是水平和垂直的。每个矩形图片可能部分或全部的覆盖了其他图片。所有矩形合并后的边长称为周长。


## 题目描述

编写一个程序计算周长。

![](https://cdn.luogu.com.cn/upload/image_hosting/2eo4hzl6.png)

如图 $1$ 所示 $7$ 个矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/buk96amj.png)

如图 $2$ 所示，所有矩形的边界。所有矩形顶点的坐标都是整数。


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N<5000$，所有坐标的数值范围都在 $-10^4$ 到 $10^4$ 之间。

## 样例 #1

### 输入

```
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16```

### 输出

```
228```

# 题解

## 作者：wucstdio (赞：272)

# 线段树扫描线详解

## 基本思想

比如，对于下面的三个矩形：

![](https://cdn.luogu.com.cn/upload/pic/18006.png)

想象有一条扫描线，从下往上扫描完整个图案，每遇到一条上边或者下边就停下来：

![](https://cdn.luogu.com.cn/upload/pic/18007.png)

然后每次停下后对区间进行处理，用一个ans代表当前周长，最后ans就是答案。

## 代码实现

首先，要先把矩形拆成上边和下边，用1和-1分别代表下边和上边。然后按高度排序，这样数组从前往后处理就相当于扫描线从下往上扫描。如果是下边，就在对应区间上加1，如果是上边，就在对应区间上减1。

在整个区间上建一棵线段树：

```cpp
#define lson o<<1
#define rson o<<1|1
#define mid (l+r)/2
struct Tree
{
    int sum;//整个区间被整体覆盖了几次（类似lazytag，但不下传)
    int num;//整个区间被几条互不相交的线段覆盖（比如，[1,2],[4,5]则为2，[1,3],[4,5]则为1（我习惯用闭区间），[1,4],[2,2],[4,4]也为1）
    int len;//整个区间被覆盖的总长度
    bool lflag;//左端点是否被覆盖（合并用）
    bool rflag;//右端点是否被覆盖（合并用）
}//如果不懂也没有关系，接着往下看
```

那么pushup要怎么写呢？

```cpp
void pushup(int o,int l,int r)
{
	if(tree[o].sum)//此区间之前被一整个线段覆盖过
	{
		tree[o].num=1;
		tree[o].len=r-l+1;
		tree[o].lflag=tree[o].rflag=1;
	}
	else if(l==r)//这是一个叶节点
	{
		tree[o].num=0;
		tree[o].len=0;
		tree[o].lflag=tree[o].rflag=0;
	}
	else//一般情况
	{
		tree[o].num=tree[lson].num+tree[rson].num;
		if(tree[lson].rflag&&tree[rson].lflag)tree[o].num--;//flag的用处
		tree[o].len=tree[lson].len+tree[rson].len;
		tree[o].lflag=tree[lson].lflag;
		tree[o].rflag=tree[rson].rflag;
		//注意：sum不会被修改，只有当它被一整个线段覆盖时才会修改
	}
}
```

有了pushup，add函数就好写了：

```
void add(int o,int l,int r,int from,int to,int value)//此区间为[l,r],待修改区间为[from,to]，添加值为value。
{
    if(l>=from&&r<=to)//被整个覆盖
    {
        tree[o].sum+=value;
        pushup(o,l,r);
        return;
    }
    if(from<=mid)add(lson,l,mid,from,to,value);
    if(to>mid)add(rson,mid+1,r,from,to,value);
    pushup(o,l,r);
}
```

## 流程

Step 0：build

![](https://cdn.luogu.com.cn/upload/pic/18014.png)

Step 1：add(1,1,6,1,5,1)

![](https://cdn.luogu.com.cn/upload/pic/18008.png)

先递归处理：

![](https://cdn.luogu.com.cn/upload/pic/18015.png)

再pushup：

![](https://cdn.luogu.com.cn/upload/pic/18017.png)

Step 2:add(1,1,6,2,3,1)

Step 3:add(1,1,6,5,6,1)

(懒得分开写了）

![](https://cdn.luogu.com.cn/upload/pic/18009.png)

递归处理，pushup：

![](https://cdn.luogu.com.cn/upload/pic/18018.png)

Step 4:add(1,1,6,1,5,-1)

![](https://cdn.luogu.com.cn/upload/pic/18010.png)

![](https://cdn.luogu.com.cn/upload/pic/18019.png)

Step 5:add(1,1,6,2,3,-1)

Step 6:add(1,1,6,5,6,-1)

![](https://cdn.luogu.com.cn/upload/pic/18013.png)

![](https://cdn.luogu.com.cn/upload/pic/18020.png)

至此，总算说完了线段树的修改。

## 答案统计

突然想起一个很严肃的事情来：答案怎么统计？

对于横边，相邻两次修改的区间覆盖长度差（就是tree[root].len的差）加起来就是答案（不理解的自己想办法理解，反正我不理解）；

对于竖边，你可以再让扫描线从左到右扫一遍~~不过还是说简单法吧。我们需要记录整个区间有多少个端点（包含在线段内不算），然后用它乘上相邻两次修改的高度差。

怎么记录呢？

对了，就是$tree[root].num*2*(h2-h1)$（num的作用在这里）

好了，下面是完整代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define lson o<<1
#define rson o<<1|1
#define mid (l+r)/2
using namespace std;
struct Edge
{
	int left;
	int right;
	int height;
	int flag;
}e[10005];
struct Tree
{
	int sum;
	int num;
	int len;
	bool lflag;
	bool rflag;
}tree[100005];
int n,mx=-2147483647,mn=2147483647,edgenum,ans,last;
void add_edge(int l,int r,int h,int f)
{
	e[++edgenum].left=l;
	e[edgenum].right=r;
	e[edgenum].height=h;
	e[edgenum].flag=f;
}
bool cmp(Edge a,Edge b)
{
	return a.height<b.height||a.height==b.height&&a.flag>b.flag;
}
void pushup(int o,int l,int r)
{
	if(tree[o].sum)
	{
		tree[o].num=1;
		tree[o].len=r-l+1;
		tree[o].lflag=tree[o].rflag=1;
	}
	else if(l==r)
	{
		tree[o].len=0;
		tree[o].num=0;
		tree[o].lflag=tree[o].rflag=0;
	}
	else
	{
		tree[o].len=tree[lson].len+tree[rson].len;
		tree[o].num=tree[lson].num+tree[rson].num;
		if(tree[lson].rflag&&tree[rson].lflag)tree[o].num--;
		tree[o].lflag=tree[lson].lflag;
		tree[o].rflag=tree[rson].rflag;
	}
}
void add(int o,int l,int r,int from,int to,int value)
{
	if(l>=from&&r<=to)
	{
		tree[o].sum+=value;
		pushup(o,l,r);
		return;
	}
	if(from<=mid)add(lson,l,mid,from,to,value);
	if(to>mid)add(rson,mid+1,r,from,to,value);
	pushup(o,l,r);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		mx=max(mx,max(x1,x2));
		mn=min(mn,min(x1,x2));
		add_edge(x1,x2,y1,1);
		add_edge(x1,x2,y2,-1);
	}
	if(mn<=0)
	{
		for(int i=1;i<=edgenum;i++)
		{
			e[i].left+=-mn+1;
			e[i].right+=-mn+1;
		}
		mx-=mn;
	}
	sort(e+1,e+edgenum+1,cmp);
	for(int i=1;i<=edgenum;i++)
	{
		add(1,1,mx,e[i].left,e[i].right-1,e[i].flag);//注意这里！！！加边有学问！！！
		while(e[i].height==e[i+1].height&&e[i].flag==e[i+1].flag)
		{
			i++;
			add(1,1,mx,e[i].left,e[i].right-1,e[i].flag);
		}
		ans+=abs(tree[1].len-last);
		last=tree[1].len;
		ans+=tree[1].num*2*(e[i+1].height-e[i].height);
	}
	printf("%d\n",ans);
	return 0;
}
```

最后给两个卡死我的样例：

样例输入1：

```cpp
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16
```

样例输出1：

```cpp
228
```

样例输入2：

```cpp
2
0 0 4 4
0 4 4 8
```

样例输出2：

```cpp
24
```

---

## 作者：xiejinhao (赞：57)

# P1856 矩形周长Picture 题解 

### 部分大佬的图已经画的很清楚了，你们结合看一下

我看到很多人写的都是扫描一次，记录覆盖次数，然后再解决另一方向：比如说，平行于$y$轴扫描，然后记录覆盖的段数，最后段数$*$扫过的横坐标长度 $+$ 扫描过的线段长度即为答案。

但是有必要这么复杂吗？扫两次不就好了？

我们可以开一颗横向的树，再开一颗扫纵向的树，最后答案相加就行了，函数传一下存树的数组的地址可以减小一半码量。

然后就是离散化，虽然说不用离散化能过(我听说的)，但是真的没几个人写离散化？基本没有人写$unique+lower\_bound$离散化的。

于是下面给出我的代码，希望给那些看习惯函数离散化的人一些帮助，也为大家提供另一种实现稍简单一点的思路：

```cpp
#include<bits/stdc++.h>
#define ls(x) x<<1
#define rs(x) x<<1|1
using namespace std;

const int SIZE = 5010;

struct rec {
	int l, r, s;
	int is;
	bool operator < (const rec &a) const {
		return s == a.s ? is > a.is : s < a.s;
	}
}line1[SIZE << 1], line2[SIZE << 1];
//存线段,l为左端点(x1/y1),r为右端点(x2/y2)
//这么写看起来好受些,s为另一轴的坐标(y/x) 

void add(int l, int r, int s, int is, int k, rec *line) {
	//写个函数让初始化更加简洁 
	line[k].l = l, line[k].r = r;
	line[k].s = s, line[k].is = is;
	return;
}

struct SegmentTree {
	int l, r;
	int len, cnt;
}t1[SIZE << 3], t2[SIZE << 3];
//存树,由于每个矩形分别有两条竖边两条横边,故所有数组多开两倍 

int b1[SIZE << 1], b2[SIZE << 1];

void updata(int p, SegmentTree *t, int *b) { //更新信息 
	if(t[p].cnt) 
		t[p].len = b[t[p].r + 1] - b[t[p].l];
	else t[p].len = t[ls(p)].len + t[rs(p)].len;
}

void build(int p, int l, int r, SegmentTree *t) {
//传树的参数就行，减小码量，下同 
	t[p].l = l, t[p].r = r;
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(ls(p), l, mid, t);
	build(rs(p), mid + 1, r, t);
}

void change(int p, int l, int r, int d, SegmentTree *t, int *b) {
	//这里别忘记多传一个b1/b2数组的信息，更新要用，上面updata同 
	if(l <= t[p].l && r >= t[p].r) {
		t[p].cnt += d;
		updata(p, t, b);
		return;
	}
	int mid = (t[p].l + t[p].r) >> 1;
	if(l <= mid) change(ls(p), l, r, d, t, b);
	if(r > mid) change(rs(p), l, r, d, t, b);
	updata(p, t, b);
}


int main() { //下面是看着十分整洁的代码 
	int n;
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		int a, b, c, d, k = i << 1;
		scanf("%d %d %d %d", &a, &b, &c, &d);
		//左端点  右端点  x/y  哪条边  编号  横/竖 
		add(a, c, b, 1, k - 1, line1);
		add(a, c, d, -1, k, line1);
		add(b, d, a, 1, k - 1, line2);
		add(b, d, c, -1, k, line2);	
		b1[k - 1] = a, b1[k] = c;
		b2[k - 1] = b, b2[k] = d;
	}
	n <<= 1;
	sort(line1 + 1, line1 + n + 1);
	sort(line2 + 1, line2 + n + 1);
	sort(b1 + 1, b1 + n + 1);
	sort(b2 + 1, b2 + n + 1);
	int m1 = unique(b1 + 1, b1 + n + 1) - (b1 + 1);
	int m2 = unique(b2 + 1, b2 + n + 1) - (b2 + 1);
	build(1, 1, m1 - 1, t1), build(1, 1, m2 - 1, t2);
	int temp1 = 0, temp2 = 0; long long ans = 0;
	for(int i = 1; i <= n; i++) {
		int l1 = lower_bound(b1 + 1, b1 + m1 + 1, line1[i].l) - b1,
			r1 = lower_bound(b1 + 1, b1 + m1 + 1, line1[i].r) - b1,
			l2 = lower_bound(b2 + 1, b2 + m2 + 1, line2[i].l) - b2,
			r2 = lower_bound(b2 + 1, b2 + m2 + 1, line2[i].r) - b2;
		change(1, l1, r1 - 1, line1[i].is, t1, b1);
		change(1, l2, r2 - 1, line2[i].is, t2, b2);
		ans += abs(t1[1].len - temp1) + abs(t2[1].len - temp2);
		temp1 = t1[1].len, temp2 = t2[1].len;
	}
	printf("%lld", ans);
	return 0;
}
```

$END$
------------
(~~这貌似是我写的最短的一篇题解？~~)**不管了，要个赞好不好QAQ**

---

## 作者：彼岸归航 (赞：37)

详细的内容[这篇博客](/blog/user54214/solution-p1856)讲得非常好了，但是要注意**同层操作的顺序问题**。当我们处理同一高度的横线时（竖线同理），我们应该**先加边再删边**。  

为什么？

考虑一下这组数据：（来源见上）  
```
2
0 0 4 4
0 4 4 8
```
```
24
```
画出来大概是这样的：  
![1.png](https://i.loli.net/2019/11/07/DP1TyYI2MhRvWNl.png)  

这里CD是不计入答案的，但如果我们先删边再加边，CD就会被计入答案2次（相当于变成两个矩形不相邻的情况）。

------------

对于同一层来说，我们可以先加完所有加边再统计答案，而不是每次加一条边都再统计一次答案（删边同理）不过这优化似乎没什么用。  
但是我们**不能在同层的加边和删边都操作完了再统计答案**。我们把上面那张图稍微改一下：  
![1.png](https://i.loli.net/2019/11/07/oA84ECkYiHO2VWq.png)  

这一层中答案应该加上CF和DH两段。但是如果我们做完这一层所有操作再统计，它们就不会被计入（操作前覆盖长度为4，操作完了还是4）

---

## 作者：无妨 (赞：29)

此题其实数据完全不用线段树过。

当然我的算法还是可以线段树优化的，然而当我想先交个暴力时，莫明就a掉了，所以也不能怪我懒。

首先，我们把一个矩形抽象成4条边。

对于这4条边，我们分纵边和横边分别处理。

由于纵边横边做法完全一样，就直接只说一种了。

**********下面进入主体***********

对于每条纵边，我们记录它的x轴坐标以及y轴两个坐标并以x坐标排序。

然后从最左边开始处理，每遇到一条左边的边，就设置影响，比如覆盖数+1

每遇到一条右边的边，就消除影响，比如覆盖数-1

每条边对答案的贡献就是他在y轴映射的那一段中覆盖数为0的个数。

然后我就暴力了一下就...

***********************************

yyyyyy等是因为洛古不支持y1.y2,一怒之下就全换成了yyyyyyyyyy。

顺便也防直接抄题解。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
struct cxt{
    int x,yyyyyyy,yyyyyyyyyy,flag;
}s[800001],t[800001];
int comp(cxt a,cxt b){ return a.x==b.x?a.flag>b.flag:a.x<b.x;}
int n,m,x,y,xxxxxxx,yyyyyyy,z,tot,a[800001],b[800001],xb=400001,ans;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;++i)
    {
        scanf("%d%d%d%d",&x,&y,&xxxxxxx,&yyyyyyy);           
        s[++tot].x=x;s[tot].yyyyyyy=y;s[tot].yyyyyyyyyy=yyyyyyy;s[tot].flag=1;
        t[tot].x=y;t[tot].yyyyyyy=x;t[tot].yyyyyyyyyy=xxxxxxx;t[tot].flag=1;
        s[++tot].x=xxxxxxx;s[tot].yyyyyyy=y;s[tot].yyyyyyyyyy=yyyyyyy;
        t[tot].x=yyyyyyy;t[tot].yyyyyyy=x;t[tot].yyyyyyyyyy=xxxxxxx;
    }
    sort(s+1,s+tot+1,comp);
    sort(t+1,t+tot+1,comp);
    for (int i=1;i<=tot;++i)
    {
        if (s[i].flag) for (int j=s[i].yyyyyyy;j<s[i].yyyyyyyyyy;++j) {if (!a[j+xb]) ++ans;++a[j+xb];}
          else for (int j=s[i].yyyyyyy;j<s[i].yyyyyyyyyy;++j) {--a[j+xb];if (!a[j+xb]) ++ans;}
        if (t[i].flag) for (int j=t[i].yyyyyyy;j<t[i].yyyyyyyyyy;++j) {if (!b[j+xb]) ++ans;++b[j+xb];}
          else for (int j=t[i].yyyyyyy;j<t[i].yyyyyyyyyy;++j) {--b[j+xb];if (!b[j+xb]) ++ans;}
    }
    printf("%d",ans);
}
```

---

## 作者：Tweetuzki (赞：15)

其实这道题根本不需要什么覆盖层数，直接排序+暴力就能跑出0ms.

我们开一个数组highest，highest[i]存储[i, i+1)这条线段上所有已经搜过的矩形的最高的上边的高度。如果现在正在搜的矩形的最低边高于已经搜过的，则中间就会有一层没贴的，于是需要计入总周长。

怎么处理能使得搜到这个矩形时，所搜到的最高的上边的高度不再会覆盖掉这个矩形呢？其实只要根据矩形的下表面从下至上的顺序排序，这样就能保证以后搜到的矩形只会往上走，最高值只会越来越高，而不会突然又搜到下面的矩形，导致重复统计了。

时间复杂度O(n log n + n × (maxx - minx) + n × (maxy - miny))。如果加入离散，则最坏时间复杂度为O(n^2)。

详见代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

//每个矩形的数据
struct data {
    int lx,rx; //该矩形最左侧的横坐标与最右侧的横坐标
    int ly,ry; //纵坐标同理
};

const int maxn=5000, maxx=20000;
int n;
data a[maxn+1]; 
int highest[maxx+1]; //已搜到的最高矩形上边界的高度 

bool cmp_x(data x, data y) { return x.lx<y.lx; }

bool cmp_y(data x, data y) { return x.ly<y.ly; }

void kuaidu(int &p) {
    char c; int f=1; p=0;
    do { c=getchar(); if (c=='-') f=-1; } while (c<'0'||c>'9');
    do p=p*10+c-'0', c=getchar(); while (c>='0'&&c<='9');
    p*=f;
}

void init() {
    kuaidu(n);
    for (int i=1; i<=n; i++) {
        kuaidu(a[i].lx); kuaidu(a[i].ly); kuaidu(a[i].rx); kuaidu(a[i].ry);
        //使所有坐标变为正数
        a[i].lx+=10001; a[i].ly+=10001; a[i].rx+=10001; a[i].ry+=10001;
    }
}

int solve_x() {
    memset(highest,-1,sizeof(highest));
    int ans=0;
    //根据下底的高度，对所有矩形排序
    sort(a+1,a+1+n,cmp_x);
    for (int i=1; i<=n; i++)
        for (int j=a[i].ly; j<a[i].ry; j++) { //处理区间[j,j+1)
            //正在处理的矩形下边界高于已经搜到过的所有矩形的最高线
            //所以在这个区间中多了一个矩形，答案加上上下边的长度(2)
            if (highest[j]<a[i].lx) ans+=2;
            //更新已搜到的矩形区间[j,j+1)的最高的线的高度
            if (highest[j]<a[i].rx) highest[j]=a[i].rx;
        }
    return ans;
}

//y轴同理
int solve_y() {
    memset(highest,-1,sizeof(highest));
    int ans=0;
    sort(a+1,a+1+n,cmp_y);
    for (int i=1; i<=n; i++)
        for (int j=a[i].lx; j<a[i].rx; j++) {
            if (highest[j]<a[i].ly) ans+=2;
            if (highest[j]<a[i].ry) highest[j]=a[i].ry;
        }
    return ans;
}

int main() {
    init();
    printf("%d\n",solve_x()+solve_y());
    return 0;
}
```

---

## 作者：Lance1ot (赞：12)

如果我们要统计一个由多个矩形重叠组成的图形的面积。

暴力太麻烦，而计算机又不能想人一样计算，那怎么求解呢？

我们可以使用扫描线fa

想象一下，有一条线，按照一个顺序（从左到右呀，从上到下呀...）扫描一个图形。

我们很容易可以得到，两条最近的相邻线段间，所包含的这一个图形的面积是规整的矩形，又因为这些矩形的长or宽我们已经知道（就是数据中给定矩形的边），所以我们只需要统计另一条边就可以了。

维护线段，我们就可以使用西安段素了。

同一个矩形，在遇到他的第一条和扫描线（是一个线段树）平行的的边时，在这条边和扫描线重叠的部分上累加1（一定是累加），然后继续往后扫描，遇到其他矩形的第一条边时亦是。

知道碰到某个矩形的第二条边，在减去。

那在扫描中怎么算面积呢？  我们需要统计的是扫描线上有多少长度被覆盖，然后乘上两条线段之间的垂直距离就可以了。

那统计周长怎么算呢？ 

（现在都是从下往上扫）先来看平行于扫描线的边。

两次扫描后，扫描线上的被覆盖长度的差的绝对值就是所增加的长度。

为什么是差呢？又为什么是绝对值呢？

我们通过一张图来解释：

![](https://s1.ax2x.com/2018/06/20/gId1A.jpg)

可以看出，这是两个矩形嵌套，然后自己在宽扁的矩形的左边第一条边的扫描线上的被覆盖的长度，和另一个矩形的第一条边时的差就是第二个矩形延展出来的长度，然后绝对值的意思是当一个矩形结束时，他有可能会与他有重叠的矩形凹陷，然后绝对值就将这种情况的边取了出来。

那于扫描线垂直的呢？

我们可以发现，两次扫描中间的那些与扫描线垂直的线段，他的长度都是两次扫描之间的距离，然后我们就需要统计他的个数

可以发现，  两次扫描中，有多少个不相连的空隙，就有相同个数*2条如此线段

## ~~其实我感觉自己很意识流，我的锅~~

##### ~~还是看看上面大佬的吧~~

然后具体实现会从详解。请先从main（）看起

我的扫描线的线段树是存的两个节点之间的空隙
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
const int manx=5010;
struct Edge
{
	int x1,x2;
	int y;
	int f;
	void change()
	{
		if(x1>x2)
			swap(x1,x2);
		return ;
	}
};
struct node
{
	int f;//有多少条不想交的线段
	int ha;//是否被整体覆盖，不下传
	int len;//总共长度
	int fl,fr;//左右端点是否被覆盖，在合并时会用到
	int l,r;//实际左右端点
};
int te,tx,k;
Edge line[manx<<1];
int base[manx<<1];
int datx[manx<<1];
node t[manx<<5];
void add(int a,int b,int c,int d)
{
	if(b>d)	swap(b,d);
	int x1=min(a,c),x2=max(a,c);
	line[++te].x1=x1;
	line[te].x2=x2;//x1，x2为左右端点，y为横坐标
	line[te].y=b;
	line[te].f=1;//这里是精髓，下边是一个矩阵的开始，上边是一个矩阵的结束，如此处理，我们到时候就可以直接传进更新扫描线的函数里，就不用判断了
	line[++te].x1=x1;
	line[te].x2=x2;
	line[te].y=d;
	line[te].f=-1;
}
bool compare(const Edge &a,const Edge &b)
{
	return a.y==b.y ? a.f > b.f : a.y < b.y;
}
void make_base()
{
	int now=0x7fffffff;
	for(int i=1;i<=tx;i++)
		if(now!=datx[i])
		{
			now=datx[i];
			base[++k]=now;
		}//简简单单的去重
	return ;
}
void build(int root,int l,int r)
{
	t[root].f=0;t[root].len=0;
	t[root].fl=t[root].fr=0;
	t[root].l=base[l];t[root].r=base[r+1];//因为是存的是节点之间的间隙，而且离散化了，所以说在处理左右的时候一定要小心，至于为什么r要+1，因为我是第i个点后的间隙的标号为i
	if(l==r)	return ;//剩下的就很普通了
	int mid=(l+r)>>1;
	build(root<<1,l,mid);
	build(root<<1|1,mid+1,r);
	return ;
}
int check(int val)
{
	int l=1,r=k;
	int mid;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(base[mid]<val)	l=mid+1;
		else	r=mid;
	}
	return l;
}
void push_up(int root,int l,int r)
{
	if(t[root].ha)//如果这个节点被整体覆盖，ha永远也不会变成负数。为什么，可以自己小小的思考一下
	{
		t[root].len=t[root].r-t[root].l;//计算长度
		t[root].fl=t[root].fr=1;//左右端点都被覆盖
		t[root].f=1;//其中有一条线段
		return ;
	}//此处永远不会出现l==r的情况
	else//一般情况
	{
		t[root].len=t[root<<1].len+t[root<<1|1].len;//合并
		t[root].fl=t[root<<1].fl;//大区间的左端点
		t[root].fr=t[root<<1|1].fr;//大区间的右端点
		t[root].f=t[root<<1].f+t[root<<1|1].f-(t[root<<1].fr&t[root<<1|1].fl);//如果左儿子的右端点和右儿子的左端点都被覆盖，那条数就要减1
		return ;
	}
}
void updata(int root,int l,int r,int al,int ar,int k)
{
	if(l>ar||r<al)	return ;
	if(l>=al&&r<=ar)
	{
		t[root].ha+=k;//蛤呸，ha为被整体覆盖的次数，有可能被多次覆盖
		push_up(root,l,r);//更新
		return ;
	}
	int mid=(l+r)>>1;
	updata(root<<1,l,mid,al,ar,k);
	updata(root<<1|1,mid+1,r,al,ar,k);
	push_up(root,l,r);//合并，这里没有push_down
}
int main()
{
	int n;
	scanf("%d",&n);
	int a,b,c,d;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		add(a,b,c,d);//保存边，我们这里只需要存与我们扫描线平行的边，然后我是自下而上的。所以我存的是上下边，然后请仔细看add函数   -》add
		datx[++tx]=a,datx[++tx]=c;//用于离散化的数组，当然数据小的话可以不离散化
	}
	sort(line+1,line+1+te,compare);//排序，有重边一定要下边先被处理
	sort(datx+1,datx+1+tx);//离散化
	make_base();//真离散化
	build(1,1,k-1);//建树，注意k为离散化后的坐标个数，这里要建立k-1个叶子节点，线段树中存的是相邻两个坐标之间的间隙
	int ans=0; //周长
	int last=0;//用于记录两次扫描的被覆盖的长度的变量
	for(int i=1;i<=te;i++)
	{
		int pos1=check(line[i].x1),pos2=check(line[i].x2);//二分查找离散化后的位置
		updata(1,1,k-1,pos1,pos2-1,line[i].f);//更新，这里就体现出我们标记上下边的好处了
		int pas=t[1].len;//最近一次扫描的长度
		ans+=abs(last-pas);//处理平行边
		ans+=t[1].f*2*(line[i+1].y-line[i].y);//处理垂直边，一定要与后一个待扫描线之间的距离
		last=pas; //迭代
	}
	printf("%d",ans);
}

```

---

## 作者：skydogli (赞：8)

## 蒟蒻版扫描线讲解(没离散,太弱了QWQ)
#### 关于扫描线
首先,我们需要知道这是个什么玩意.以我的理解,就是在需要扫描整个二维平面的时候,用线段树维护一维中我们需要的答案,使时间复杂度降至nlogn级别.(没有离散化的扫描线和普通线段树没什么区别,普通线段树不也是动态维护吗?扫描线只是把问题分成一个一个坐标让你修改,最后回答而已)
#### 关于题目
这是扫描线的经典例题(其他的还有[算面积](https://www.luogu.org/problemnew/show/P2061),[算区间里点个数](https://www.luogu.org/problemnew/show/P1502)等,也可以刷刷来巩固一下),我们先计算横边的周长,如果用一条线,一个横坐标,一个横坐标地扫,我们会发现,当扫到的矩形被覆盖的点的个数发生变化时,就说明周长变化了!你们看看题目的两幅图应该能理解(刚换成ubuntu的操作系统,还没装画图)~~(别狡辩了你就是懒)~~所以我们可以记录当前区间内被最少矩形覆盖的点的个数,每次统计整个扫描线上没有被矩形覆盖的个数,与上一个坐标对比,变化量就是周长的一部分.

额,关于如何求竖边的周长嘛...swap横纵坐标再扫一次吧(逃
#### 关于数据
这一题数据也非常的良心,坐标只给到20000个点,n都有5000,俗话说得好,数据决定算法,这样的数据实在没有离散化的必要,所以代码真的和线段树模板差不多.
#### 编程细节
1.我们输入的两个坐标x1,x2都是一个点,但矩形的实际边长是这两个点的距离,即x2-x1,而由于我们的线段树是闭区间,如果写x1,x2的话边长就变成了x2-x1+1,所以计算时第二个点坐标要-1~~(感性理解下)~~
2.记得清零!!!尤其是懒标记!!!
3.最好不用y1,y2,我前面就因为这个导致报错,后面改的变量名有点奇葩,无所谓.
#### 代码&注释
```cpp
#include<bits/stdc++.h>
using namespace std;
#define Ls (nod<<1)
#define Rs (nod<<1|1)
#define mid ((l+r)>>1)
struct data{
    int x1,x2,y,kind;
}w[15005];
bool cmp(data a,data b){
    if(a.y!=b.y)return a.y<b.y;
    return a.kind>b.kind;
}//按纵坐标排序
struct Tree{
    int cnt,line,add;
    //line 当前区间最少有几个矩形覆盖;cnt 被最少矩形覆盖的点的个数;add 懒标记
}tree[400005];
int n,x1[15005],x2[15005],Y[15005],yLG[15005],ans;
void pushup(int nod){//维护
    tree[nod].line=min(tree[Ls].line,tree[Rs].line);
    if(tree[Ls].line==tree[Rs].line)
        tree[nod].cnt=tree[Ls].cnt+tree[Rs].cnt,tree[nod].line=tree[Ls].line;
    else
        tree[nod].cnt=(tree[Ls].line<tree[Rs].line)?tree[Ls].cnt:tree[Rs].cnt;
        //注意:cnt只记录被最少矩形覆盖的点数
}
void pushdown(int nod){//懒标记下传
    tree[Ls].line+=tree[nod].add;
    tree[Rs].line+=tree[nod].add;
    tree[Ls].add+=tree[nod].add;
    tree[Rs].add+=tree[nod].add;
    tree[nod].add=0;
}
void build(int nod,int l,int r){//建树(清零)
    tree[nod].add=0;//特别注意!!!懒标记不能在下面清空!
    if(l==r){tree[nod].line=0;tree[nod].cnt=1;return;}
    build(Ls,l,mid);
    build(Rs,mid+1,r);
    pushup(nod);
}
void pluss(int nod,int l,int r,int b,int e,int ad){//修改
    if(l>r||l>e||r<b) return;
    if(b<=l&&r<=e){tree[nod].add+=ad;tree[nod].line+=ad;return;}
    pushdown(nod);
    pluss(Ls,l,mid,b,e,ad);
    pluss(Rs,mid+1,r,b,e,ad);
    pushup(nod);
}
void solve(){
    for(int i=1;i<=n;i++){
        int before=tree[1].cnt*(tree[1].line==0);//如果所有点都被至少一个矩形覆盖,那么这个cnt就不能代表没有被覆盖的点
        pluss(1,-10000,10000,w[i].x1,w[i].x2-1,w[i].kind);
        int now=tree[1].cnt*(tree[1].line==0);//同上
        ans+=abs(now-before);//求变化量
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d%d",&x1[i],&Y[i],&x2[i],&yLG[i]);//
        w[i*2-1].x1=w[i*2].x1=x1[i];
        w[i*2-1].x2=w[i*2].x2=x2[i];

        w[i*2-1].y=Y[i];
        w[i*2].y=yLG[i];

        w[i*2-1].kind=1;
        w[i*2].kind=-1;
        //记录
    }
    n*=2;
    sort(w+1,w+1+n,cmp);
    build(1,-10000,10000);
    solve();//横边
    for(int i=2;i<=n;i+=2){
        w[i-1].x1=w[i].x1=Y[i/2];
        w[i-1].x2=w[i].x2=yLG[i/2];
        w[i-1].y=x1[i/2];
        w[i].y=x2[i/2];
        w[i-1].kind=1;
        w[i].kind=-1;
    }
    sort(w+1,w+1+n,cmp);
    build(1,-10000,10000);
    solve();//竖边
    cout<<ans;
    return 0;
}

```

---

## 作者：Seauy (赞：5)


正解：线段树+扫描线（又称离散化扫描）

一个优秀的数据结构和一个神奇算法，可惜我都不熟……相信正解其他大佬都已经讲足了，我就来分享一下本蒟蒻的玄学方法

分治+排序+二分

本题的麻烦之处就在于矩形与矩形之间有重叠区域，如果若干矩阵没有重叠区域，那么周长会比较好处理。

于是，先用矩形切割分治出若干互不重叠的矩阵……等等，矩形切割是什么？

![](https://cdn.luogu.com.cn/upload/pic/61023.png)

现在有一个矩形

![](https://cdn.luogu.com.cn/upload/pic/61024.png)

突然出现了另一个矩形与它相交了，则如之何？

![](https://cdn.luogu.com.cn/upload/pic/61025.png)

这样切成两个矩形就行了

同样，如果其它矩形也与切割后的矩形重叠了，还要再进行切割

```cpp
void Partition(int depth,Square now)
{
    if(now.Impossible()) return;//矩阵不可能存在
    if(depth>n)//最终不重叠部分
    {
        basic[++num]=now;//计入并保留
        return;
    }
    Square U=Uarea(now,paper[depth]);//公共部分
    if(U.Impossible() || !U.InArea(now)) {Partition(depth+1,now);return;}
	//没有公共部分或者公共部分不在矩形内就跳过
    Square rear[4];
    rear[0]={Point{now.lef_dow.x,U  .rig_up .y},Point{U  .rig_up.x,now.rig_up .y}};
    rear[1]={Point{U  .rig_up .x,U  .lef_dow.y},now.rig_up                       };
    rear[2]={Point{U  .lef_dow.x,now.lef_dow.y},Point{now.rig_up .x,U .lef_dow.y}};
    rear[3]={now.lef_dow                       ,Point{U  .lef_dow.x,U .rig_up .y}};
    for(int i=0;i<4;i++) Partition(depth+1,rear[i]);//分割成四块，当然有些到后面是会被舍弃的
}
```



------------

好了现在得到了很多不重叠的矩形了，接下来就要算周长了

如果要计算一个矩形一条边的边长，得找到所有跟这条边有重叠的其它矩形的边，然后进行线段分割（一维矩形分割），求出这条边不与其它边重合部分的总长，就行了

![](https://cdn.luogu.com.cn/upload/pic/61026.png)

### 但是！

以 O(n^2) 算法枚举每一条边的重叠情况肯定是会，超时的，所以得另加优化

现在想象你要求一个矩形的左边长有多少是计入总周长的，如果与其它边重合，它们的 x轴 坐标肯定是相等的。为了快速找到有哪些矩形的边是跟这条边重合的，考虑二分

矩形先按右边 x轴 坐标排序，如果相等，那么按下边 y轴 排序，因为如果这个矩形下边的 y轴 坐标比我的上边的 y轴 坐标还要大，可以判断后面一定再没有边与它重合了，可以提前退出递归加快速度

同样，对左边的处理方式也可以拓展到上边、右边、下边上，所以后面可以看见代码是很有规律的

```cpp
//                    遍历到的矩形编号           上面 y坐标 自己的编号
int Lef_Rig_SideLength(int depth,int dow,int up,int end,int self)
//                             垂直线段的下面 y坐标
{
    if(dow>=up) return 0;//线段不可能存在
    if(depth>end || up<=basic[depth].lef_dow.y) return up-dow;//没有再跟它重合的边了
    if(depth==self || dow>=basic[depth].rig_up.y) return Lef_Rig_SideLength(depth+1,dow,up,end,self);//没有交集或找到了自己，那就跳过
    return Lef_Rig_SideLength(depth+1,dow                           ,min(basic[depth].lef_dow.y,up),end,self)
           +
           Lef_Rig_SideLength(depth+1,max(basic[depth].rig_up.y,dow),up                            ,end,self);//分成两段
}

int Up_Dow_SideLength (int depth,int lef,int rig,int end,int self)//跟计算水平边的长度差不多
{
    if(lef>=rig) return 0;
    if(depth>end || rig<=basic[depth].lef_dow.x) return rig-lef;
    if(depth==self || lef>=basic[depth].rig_up.x) return Up_Dow_SideLength(depth+1,lef,rig,end,self);
    return Up_Dow_SideLength(depth+1,lef                  ,min(basic[depth].lef_dow.x,rig),end,self)
           +
           Up_Dow_SideLength(depth+1,max(basic[depth].rig_up.x,lef),rig                   ,end,self);
}
```
这是一维矩形分割的代码
```cpp
 //计算左边长
    sort(basic+1,basic+num+1,RigXorder);
    for(int i=1;i<=num;i++)
    {
        //找到 rig_up.x 与这个方块 lef_dow.x 一样的方块 
        int L=1,R=num;
        while(L<=R)//第一个 x坐标 相等的矩形
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.x>=basic[i].lef_dow.x) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)//最后一个
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.x<=basic[i].lef_dow.x) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Lef_Rig_SideLength(bef,basic[i].lef_dow.y,basic[i].rig_up.y,aft,i);
    }
    //计算右边长
    sort(basic+1,basic+num+1,LefXorder);
    for(int i=1;i<=num;i++)
    {
        //找到 lef_dow.x 与这个方块 rig_up.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.x>=basic[i].rig_up.x) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.x<=basic[i].rig_up.x) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Lef_Rig_SideLength(bef,basic[i].lef_dow.y,basic[i].rig_up.y,aft,i);
    }
    //计算上边长
    sort(basic+1,basic+num+1,DowYorder);
    for(int i=1;i<=num;i++)
    {
        //找到 lef_dow.x 与这个方块 rig_up.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.y>=basic[i].rig_up.y) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.y<=basic[i].rig_up.y) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Up_Dow_SideLength(bef,basic[i].lef_dow.x,basic[i].rig_up.x,aft,i);
    }
    //计算下边长
    sort(basic+1,basic+num+1,UpYorder);
    for(int i=1;i<=num;i++)
    {
        //找到 lef_dow.x 与这个方块 rig_up.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.y>=basic[i].lef_dow.y) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.y<=basic[i].lef_dow.y) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Up_Dow_SideLength(bef,basic[i].lef_dow.x,basic[i].rig_up.x,aft,i);
    }
```
这是排序+二分的部分

------------

最后上总代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*(
--------------------- 
作者：隐者_ 
来源：CSDN 
原文：https://blog.csdn.net/qq_31975227/article/details/51758461 
版权声明：本文为博主原创文章，转载请附上博文链接！
这个作者提供了我方便的debug方法……
*/

bool inseg(int bef,int ob,int aft)
{return bef<=ob && ob<=aft;}

struct Point
{
    int x,y;
    void Scan () {scanf("%d %d",&x,&y);}
    void Print() {cout<<x<<' '<<y     ;}
};

struct Square
{
    Point lef_dow,rig_up;
    void Scan () {lef_dow.Scan(),rig_up.Scan();}
    void Print() {lef_dow.Print(),cout<<"  ",rig_up.Print(),cout<<endl;}
    bool Impossible()
    {
        int L=rig_up.x-lef_dow.x;
        int W=rig_up.y-lef_dow.y;
        return (W<=0 || L<=0);
    }
    bool InArea(Square ob)
    {
        return inseg(ob.lef_dow.x,lef_dow.x,ob.rig_up.x)
               &&
               inseg(ob.lef_dow.x,rig_up .x,ob.rig_up.x)
               &&
               inseg(ob.lef_dow.y,lef_dow.y,ob.rig_up.y)
               &&
               inseg(ob.lef_dow.y,rig_up .y,ob.rig_up.y);
    }
}paper[5001],basic[100001];int num;

int n,ans;
/*
    从后往前遍历
    碰到重叠的就把它打散
*/

Square Uarea(Square a,Square b)
{
    Point LD=Point{max(a.lef_dow.x,b.lef_dow.x),max(a.lef_dow.y,b.lef_dow.y)};
    Point RU=Point{min(a.rig_up .x,b.rig_up .x),min(a.rig_up .y,b.rig_up .y)};
    return Square{LD,RU};
}

void Partition(int depth,Square now)
{
    if(now.Impossible()) return;
    if(depth>n)
    {
        basic[++num]=now;
        return;
    }
    Square U=Uarea(now,paper[depth]);
    if(U.Impossible() || !U.InArea(now)) {Partition(depth+1,now);return;}
    Square rear[4];
    rear[0]={Point{now.lef_dow.x,U  .rig_up .y},Point{U  .rig_up.x,now.rig_up .y}};
    rear[1]={Point{U  .rig_up .x,U  .lef_dow.y},now.rig_up                       };
    rear[2]={Point{U  .lef_dow.x,now.lef_dow.y},Point{now.rig_up .x,U .lef_dow.y}};
    rear[3]={now.lef_dow                       ,Point{U  .lef_dow.x,U .rig_up .y}};
    for(int i=0;i<4;i++) Partition(depth+1,rear[i]);
}

bool RigXorder(Square a,Square b)
{return (a.rig_up .x==b.rig_up .x ? a.lef_dow.y<b.lef_dow.y : a.rig_up .x<b.rig_up .x);}

bool LefXorder(Square a,Square b)
{return (a.lef_dow.x==b.lef_dow.x ? a.lef_dow.y<b.lef_dow.y : a.lef_dow.x<b.lef_dow.x);}

bool DowYorder(Square a,Square b)
{return (a.lef_dow.y==b.lef_dow.y ? a.lef_dow.x<b.lef_dow.x : a.lef_dow.y<b.lef_dow.y);}

bool UpYorder (Square a,Square b)
{return (a.rig_up .y==b.rig_up .y ? a.lef_dow.x<b.lef_dow.x : a.rig_up .y<b.rig_up .y);} 

int Lef_Rig_SideLength(int depth,int dow,int up,int end,int self)
{
    if(dow>=up) return 0;
    if(depth>end || up<=basic[depth].lef_dow.y) return up-dow;//2019 6 16 wrong: 线段交集判断 
    if(depth==self || dow>=basic[depth].rig_up.y) return Lef_Rig_SideLength(depth+1,dow,up,end,self);
    return Lef_Rig_SideLength(depth+1,dow                           ,min(basic[depth].lef_dow.y,up),end,self)
           +
           Lef_Rig_SideLength(depth+1,max(basic[depth].rig_up.y,dow),up                            ,end,self);
}

int Up_Dow_SideLength (int depth,int lef,int rig,int end,int self)
{
    if(lef>=rig) return 0;
    if(depth>end || rig<=basic[depth].lef_dow.x) return rig-lef;
    if(depth==self || lef>=basic[depth].rig_up.x) return Up_Dow_SideLength(depth+1,lef,rig,end,self);
    return Up_Dow_SideLength(depth+1,lef                  ,min(basic[depth].lef_dow.x,rig),end,self)
           +
           Up_Dow_SideLength(depth+1,max(basic[depth].rig_up.x,lef),rig                   ,end,self);
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) paper[i].Scan();
    for(int i=1;i<=n;i++) Partition(i+1,paper[i]);
    //for(int i=1;i<=num;i++) basic[i].Print();
    //计算左边长
    sort(basic+1,basic+num+1,RigXorder);
    for(int i=1;i<=num;i++)
    {
        //找到 rig_up.x 与这个方块 lef_dow.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.x>=basic[i].lef_dow.x) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.x<=basic[i].lef_dow.x) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Lef_Rig_SideLength(bef,basic[i].lef_dow.y,basic[i].rig_up.y,aft,i);
    }
    //计算右边长
    sort(basic+1,basic+num+1,LefXorder);
    for(int i=1;i<=num;i++)
    {
        //找到 lef_dow.x 与这个方块 rig_up.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.x>=basic[i].rig_up.x) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.x<=basic[i].rig_up.x) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Lef_Rig_SideLength(bef,basic[i].lef_dow.y,basic[i].rig_up.y,aft,i);
    }
    //计算上边长
    sort(basic+1,basic+num+1,DowYorder);
    for(int i=1;i<=num;i++)
    {
        //找到 lef_dow.x 与这个方块 rig_up.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.y>=basic[i].rig_up.y) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].lef_dow.y<=basic[i].rig_up.y) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Up_Dow_SideLength(bef,basic[i].lef_dow.x,basic[i].rig_up.x,aft,i);
    }
    //计算下边长
    sort(basic+1,basic+num+1,UpYorder);
    for(int i=1;i<=num;i++)
    {
        //找到 lef_dow.x 与这个方块 rig_up.x 一样的方块 
        int L=1,R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.y>=basic[i].lef_dow.y) R=mid-1;
            else L=mid+1;
        }
        int bef=L;
        R=num;
        while(L<=R)
        {
            int mid=(L+R)>>1;
            if(basic[mid].rig_up.y<=basic[i].lef_dow.y) L=mid+1;
            else R=mid-1;
        }
        int aft=R;
        ans+=Up_Dow_SideLength(bef,basic[i].lef_dow.x,basic[i].rig_up.x,aft,i);
    }
    printf("%d\n",ans);
    return 0;
}
/*
2
0 0 1 2
0 0 2 1

7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16

2
0 0 1 1
2 2 3 3

2
0 0 8 8
2 2 3 3
*/
```
本来感觉会 TLE 的，没想到效率其实还是挺高的（就怕是USACO数据水）

---

## 作者：qwaszx (赞：4)

看了一下发现自己的做法好像不太一样???

还是扫描线，然后计算答案的时候被覆盖的长度的变化值加到答案里.注意先入后出.

行列分开做.

然后线段树要维护的是非$0$的区间的长度，支持区间加

考虑线段树上每一个节点都作为一个真正的区间而不只是虚点，然后记录这个区间被完全覆盖的次数$num$. $pushup$的时候，分三种情况:

	1. num>0 这个区间的答案为区间长度
    2. num=0,叶子节点 这个区间的答案为0
    3. num=0,非叶子节点 这个区间的答案是两个子节点的答案之和
容易知道$num$不会小于$0$，标记不需要下传，因为num>0的时候子节点的修改无关紧要，num=0的时候相当于没修改过

离散化了一下 当然这题的数据充满了暴力的气息，不离散化也能过

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=200000;
struct Q{int x,l,r,w;}q[N];
struct JX{int xa,ya,xb,yb;}ja[N],jb[N];
int n,a[N],num[N],cnt,lsh[N];
int abs1(int x){return x>0?x:-x;}
void pushup(int rot,int lt,int rt)//分情况讨论一下
{
	if(num[rot])a[rot]=lsh[rt+1]-lsh[lt];
	else if(lt==rt)a[rot]=0;
	else a[rot]=a[rot<<1]+a[rot<<1|1];
}
void update(int rot,int lt,int rt,int lq,int rq,int w)
{
	if(lq>rq)return;
	if(lt>=lq&&rt<=rq){num[rot]+=w,pushup(rot,lt,rt);return;}
	int mid=(lt+rt)>>1;
	if(rq<=mid)update(rot<<1,lt,mid,lq,rq,w);
	else if(lq>mid)update(rot<<1|1,mid+1,rt,lq,rq,w);
	else update(rot<<1,lt,mid,lq,mid,w),update(rot<<1|1,mid+1,rt,mid+1,rq,w);
	pushup(rot,lt,rt);
}
void build(int rot,int lt,int rt)
{
	num[rot]=a[rot]=0;
	if(lt==rt)return;
	int mid=(lt+rt)>>1;
	build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);
}
int cmp(const Q &a,const Q &b){return a.x==b.x?a.w>b.w:a.x<b.x;}
int solve(JX jx[])
{
	int ans=0,lst=0,cnt=0,qn=0;
	for(int i=1;i<=n;i++)
	{
		q[++qn]=(Q){jx[i].xa,jx[i].ya,jx[i].yb,1};
		q[++qn]=(Q){jx[i].xb,jx[i].ya,jx[i].yb,-1};
		lsh[++cnt]=jx[i].ya,lsh[++cnt]=jx[i].yb;
	}
	sort(lsh+1,lsh+cnt+1);cnt=unique(lsh+1,lsh+cnt+1)-lsh-1;
	sort(q+1,q+qn+1,cmp);build(1,1,cnt);
	for(int i=1;i<=qn;i++)
	{
		int l=lower_bound(lsh+1,lsh+cnt+1,q[i].l)-lsh,r=lower_bound(lsh+1,lsh+cnt+1,q[i].r)-lsh-1;
		update(1,1,cnt,l,r,q[i].w);
		ans+=abs1(a[1]-lst),lst=a[1];
	}
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int xa,ya,xb,yb;
		scanf("%d%d%d%d",&xa,&ya,&xb,&yb);
		ja[i]=(JX){xa,ya,xb,yb},jb[i]=(JX){ya,xa,yb,xb};
	}
	cout<<solve(ja)+solve(jb)<<endl;
}
```

---

## 作者：Sangber (赞：3)

### 题目描述  
墙上贴着许多形状相同的海报、照片。它们的边都是水平和垂直的。每个矩形图片可能部分或全部的覆盖了其他图片。所有矩形合并后的边长称为周长。  

编写一个程序计算周长。  
![](https://cdn.luogu.com.cn/upload/pic/702.png)  
如图1所示7个矩形。  
![](https://cdn.luogu.com.cn/upload/pic/703.png)  
如图2所示，所有矩形的边界。所有矩形顶点的坐标都是整数。  

输入输出格式  

**输入格式:**

输入文件的第一行是一个整数$N(0<=N<5000)$，表示有多少个矩形。接下来$N$行给出了每一个矩形左下角坐标和右上角坐标（所有坐标的数值范围都在$-10000$到$10000$之间）。

**输出格式:**

输出文件只有一个正整数，表示所有矩形的周长。  

----

### 基本思路  
解决这一类平面矩形面积/周长并的方法，还是用最经典的方法(见下)吧。  
毕竟这是一道模板题。。。  
大佬们都解释了很多了，蒟蒻就不再赘述了(~~我才不会告诉你我不会讲~~)

----

### 扫描线$+$线段树  
大体模板应该都差不太多:  
扫描一次，从下往上，顺便记录路上的y轴方向的线段长,往$ans$中累加就好了。

----

### 细节注意事项  
第一次交的时候莫名WA最后一个点，很是不解，翻了翻大佬的题解，才发现:  
```cpp
    bool cmp(edge a,edge b){return a.h<b.h;}
```  
这是我第一次交时写的cmp函数。
```cpp
    bool cmp(edge a,edge b){return a.h<b.h||(a.h==b.h&&a.f>b.f);}  
```
这是AC时的cmp函数。  

对于遇到的重合的一条上边和一条下边(当然不会在同一个矩形内)，我们优先处理下边的信息。  

----

### 参考代码  
下面就是本蒟蒻的AC代码，有什么不当或可以改进的地方欢迎大佬来指教%%%  
```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define rg register
using namespace std;
const int MAXN=5010;
const int MAXM=20010;
const int INF=2147483647;
inline int read(){
	int s=0;bool f=false;char c=getchar();
	while(c<'0'||c>'9')f|=(c=='-'),c=getchar();
	while(c>='0'&&c<='9')s=(s<<3)+(s<<1)+(c^48),c=getchar();
	return (f)?(-s):(s);
}
struct node{
	int l,r,cnt;
	int numx,numy;
	bool lf,rf;
}c[MAXM<<2];
#define lson rt<<1
#define rson rt<<1|1
inline void pushup(int rt){
	if(c[rt].cnt){
		c[rt].numx=c[rt].r-c[rt].l+1;
		c[rt].lf=c[rt].rf=true;
		c[rt].numy=1;
	}
	else if(c[rt].l==c[rt].r){
		c[rt].numx=0;
		c[rt].numy=0;
		c[rt].lf=c[rt].rf=false;
	}
	else{
		c[rt].numx=c[lson].numx+c[rson].numx;
		c[rt].lf=c[lson].lf;
		c[rt].rf=c[rson].rf;
		c[rt].numy=c[lson].numy+c[rson].numy-(c[lson].rf&c[rson].lf);
	}
}
inline void build(int rt,int l,int r){
	c[rt].l=l;
	c[rt].r=r;
	c[rt].cnt=0;
	c[rt].numx=0;
	c[rt].numy=0;
	c[rt].lf=false;
	c[rt].rf=false;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
}
inline void update(int rt,int l,int r,int v){
	if(l<=c[rt].l&&c[rt].r<=r)
		return c[rt].cnt+=v,pushup(rt);
	int mid=(c[rt].l+c[rt].r)>>1;
	if(l<=mid)update(lson,l,r,v);
	if(r>mid) update(rson,l,r,v);
	pushup(rt);
}
struct edge{int l,r,h,f;}e[MAXN<<1];
bool cmp(edge a,edge b){
	return a.h<b.h||(a.h==b.h&&a.f>b.f);
}
int main(){
	int n=read(),tot=0;
	int maxl=INF,maxr=-INF;
	for(rg int i=1;i<=n;i++){
		int x1=read(),y1=read();
		int x2=read(),y2=read();
		maxl=min(maxl,min(x1,x2));
		maxr=max(maxr,max(x1,x2));
		e[++tot]=(edge){x1,x2,y1,1};
		e[++tot]=(edge){x1,x2,y2,-1};
	}
	sort(e+1,e+tot+1,cmp);
	long long ans=0,last=0;
	build(1,maxl,maxr-1);
	for(rg int i=1;i<=tot;i++){
		update(1,e[i].l,e[i].r-1,e[i].f);
		ans+=labs(c[1].numx-last);
		ans+=(e[i+1].h-e[i].h)*2*c[1].numy;
		last=c[1].numx;
	}
	printf("%lld\n",ans);
	return 0;
}
```
完结撒花 $qwq$

---

## 作者：Gumbo (赞：2)

上次做了矩形面积并之后，偶然看到了这个周长并，顺手做完后写了本文。

提示：如果你没有看过我的那篇 `算法学习笔记-扫描线`，那请先去看那个，里面讲了扫描线的基础和面积并的求法。

---

首先，我们需要明确扫描线矩形周长并的思想。

类比一下面积并：

面积并是将多边形切成一个个互不相交的矩形，然后将其面积简单加和。

那周长并可以怎么做呢？

由于这里是扫描线算法，所以这个方法一定与切割有关。

建议思考一下，下面是方法。

---

我们将多边形切成一个个面积交为 0 的矩形，然后将其周长加和，每次减去两个相邻矩形重叠的长度。

这个方法看上去完全可以，但是仔细想想，我们要如何实现呢？

我们的扫描线移动是依靠边的增减，也就是线段树的区间加减来实现的，因此我们可以这样处理：

首先，我们要算每个矩形的周长。

这里就遇到了一个问题。

之前的扫描线板子只能让我们知道整个数轴上被覆盖的总长度，这对于不需要管其内部形状的面积并是完全够用的。

但是现在是需要求周长，那么这样的信息就完全不够了，我们还需要知道覆盖的内部是什么情况。

这就需要维护一个新的信息：整个区间上的端点个数。

为什么？我们把一批底相同的矩形（也就是同一次切割产生的矩形）拿出来，看看它的周长由什么组成。

首先就是与扫描线平行的部分，我们只需要将整个数轴上的覆盖长度乘二即可。

然后是与扫描线垂直的部分，这里就用到了整个区间的端点个数。

想象一下，一条扫描线在移动，上面有几个点一起移动，然后看看这些点的轨迹。

算了，言传很难，我传个图吧。

![img](https://cdn.luogu.com.cn/upload/image_hosting/2vij78zl.png "动之前")

上面的是动之前的扫描线

![img](https://cdn.luogu.com.cn/upload/image_hosting/2hyk51e3.png "动之后")

这是动后的。

深灰色的是扫描线没有被覆盖的部分（参考线）

橙色的是扫描线上的点。

粉色的是点运动的轨迹。

浅灰色的是扫过的面积。

黄色的是扫描线被覆盖的区域。

我想这样应该就能明白我的意思了吧。

我们要求的矩形周长便是粉色的加上黄色的。

明白了吗？

前面说的与扫描线平行的部分，其实就是黄色的部分。

显然，就是被覆盖的长度的二倍。

然后与扫描线垂直的部分，就是粉色的部分。

只要用整个扫描线上端点的数目乘移动的距离，就是这部分的总长度。

这样，我们就能求出任何一批矩形的周长了。

---

然后就是如何减去重叠的部分了。

还是以图为例：

在处理某条边的变动之前，我们的矩形是这样的：

![img](https://cdn.luogu.com.cn/upload/image_hosting/2hyk51e3.png "处理前")

在处理完之后，我们的扫描线变成了右边的那样：

![img](https://cdn.luogu.com.cn/upload/image_hosting/rtirlwb8.png "处理完后")

这里我将处理后的扫描线和之前的扫描线分离开了，更方便观察，但是事实上这里没有任何扫描线的移动。

而绿色的那一条便是我们这次新覆盖的一段。

我们来找找哪一部分是重叠的。

显然，就是我们处理前的长度。

那如果我们是去掉了一段，会是怎么样呢？

看图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/s6ev2az9.png "去掉一段后")

红色的是这次实际去掉的覆盖区域。

显然，这时重叠的区域就是我们处理后的长度。

总而言之，重叠的区域长度就是我们处理前后较短的那个的长度。

因为我们减去的事实上是两条线重合的部分，所以我们减得时候要减二倍。

自此，我们就完成了具体的思路。

---

但是，很可能会有人疑惑：如果是有增有减，那怎么办呢？

确实，我们之前的结论只适合单独增或减的情况，而二者都有的情况十分复杂，我们没有办法处理。

但是，俗话说得好，解决不了问题，就解决提出问题的人。

换句话说，我们只要让它每次都是单独的增加或者是减少，那不就没有问题了吗？

所以，我们只需要每条需要处理的边单独视作一次操作，让同一条线上的两个边也分别进行切割，就能解决这个问题了。

但是，有的人可能要问了：这样不会多出来一个宽度为 0 的矩形吗？

首先，如果我们是求面积并，那我们就不用担心这种不会影响答案的矩形。

但我们是周长并，所以这个问题值得深思。

首先告诉你答案：不会影响。

自行思考一下为什么，下面会有解释。

---

有图有真相，放图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/b1tixnco.png "解释")

左边的线是我们处理前的，中间的是一个中间状态（也就是宽度为 0 的矩形，两条边重合了），右面是处理后的状态。

我们不妨设一开始覆盖长度为 $l_0$，增加的那一段设为 $\Delta l_1$，减少的那一段（长度）设为 $\Delta l_2$。

然后很容易得出，中间状态的长度就是 $l_0+\Delta l_1$，而处理完的那一段长度就是 $l_0+\Delta l_1-\Delta l_2$。

我们按照常识算一下这中间应该减去的长度：

$2(l_0-\Delta l_2)$

那么，根据我们的规律，看一下我们会减去多少：

$2\times \min(l_0,l_0+\Delta l_1)+2\times\min(l_0+\Delta l_1,l_0+\Delta l_1 - \Delta l_2)$

化简一下，也就是：

$2\times(2l_0+\Delta l_1-\Delta l_2)$

不一样？别急，还有一部分没算上。

我们多算的那一个宽度为 0 的矩形还没算上呢。

它的宽度是 0，所以我们只需要考虑它平行于扫描线的部分就行了。

$2\times(l_0+\Delta l_1)$

我们将减去的长度减去多算的长度（相当于负数加正数，也就是绝对值相减），得到这个：

$2(l_0-\Delta l_2)$

完美。

综上所述，这个中间状态不会影响我们的答案。

休息一下，接下来是代码。

---

由于我们需要维护区间内的端点个数，所以我们需要在我们的板子里面加上一些东西。

首先，我们仍然是利用标记永久化，这个不用动。

我们的 `pushup` 函数将会变成这样：

```cpp
void pushup(void) {
        if (cover > 0) {  // 完全覆盖
            length= R - L + 1;
            num= 0;
            lcover= rcover= true;
            return;
        }
        if (lc == nullptr || rc == nullptr) {  // 没有覆盖且没孩子
            length= 0;
            num= 0;
            lcover= rcover= false;
        } else {  // 一般
            length= lc->length + rc->length;
            num= lc->num + rc->num;
            if (lc->rcover != rc->lcover) {
                ++num;
            }
            lcover= lc->lcover;
            rcover= rc->rcover;
            if (lc->lc == rc->rc && lc->cover == 0&&rc->cover==0) {
                delete lc;
                delete rc;
                lc= rc= nullptr;
            }
        }
    }
```

这里面多了几个你没见过的变量，这里列一下它们的意义：

`cover`：实际上就是上次的 `time`。

`lcover`（`rcover`）：区间最左（右）端是否被覆盖。

`num`：区间内部的端点个数。

由于这个函数大变样了，我在这里梳理一下整个函数的思路：

首先，如果这个区间被覆盖了至少一次（不管祖先，祖先的事情用不到后代关心），那么这个点的总覆盖长度就是点的总长度，这一段内部自然也不会有端点，而左右两边自然都被覆盖了。

然后是没有被覆盖且没有孩子的情况，这表明这个点和我们的覆盖区域毫无关联，因此它的覆盖长度是 0，内部没有端点，两端也都没有被覆盖。

最后是一般情况：这个点没有被覆盖，但它有孩子，有可能参与到我们的统计中来。

这一段的总覆盖长度显然就是两个孩子的长度和。

这一段内部的端点包括这样三部分：

1. 左儿子里的
2. 右儿子里的
3. 两个儿子中间正好夹着一个点

这也就是处理方法。

首先，将总数设为两个儿子的数量和。

之后，如果左儿子的右边被覆盖了且右儿子的左边没有覆盖，或者左儿子的右边没有覆盖且右儿子的左边被覆盖了，那么中间就是夹着一个点。

人话：两个儿子临近对方的那一端，一个被覆盖，一个没有，那就说明中间有个端点。

如果符合上述，那么就将点数+1。

之后两端的覆盖处理和对应儿子一样，不必多言。

然后是上次的传统手艺，如果儿子没用了，就清理门户，腾出空间给其它想出生的儿孙祖先们。

下面我放一下我这次打的板子：

```cpp
struct node {
    int L, R;
    node *lc, *rc;
    int cover;
    int num;
    int length;
    bool lcover, rcover;
    void pushup(void) {
        if (cover > 0) {
            length= R - L + 1;
            num= 0;
            lcover= rcover= true;
            return;
        }
        if (lc == nullptr || rc == nullptr) {
            length= 0;
            num= 0;
            lcover= rcover= false;
        } else {  // 一般
            length= lc->length + rc->length;
            num= lc->num + rc->num;
            if (lc->rcover != rc->lcover) {
                ++num;
            }
            lcover= lc->lcover;
            rcover= rc->rcover;
            if (lc->lc == rc->rc && lc->cover == 0&&rc->cover==0) {
                delete lc;
                delete rc;
                lc= rc= nullptr;
            }
        }
    }
    void add(int l, int r, int x) {
        if (l <= L && r >= R) {
            cover+= x;
            pushup();
            return;
        }
        if (lc == nullptr || rc == nullptr) {
            lc= new node;
            rc= new node;
            lc->L= L;
            lc->R= (L + R) >> 1;
            rc->L= lc->R + 1;
            rc->R= R;
            lc->cover= rc->cover= 0;
            lc->num= rc->num= 0;
            lc->lcover= lc->rcover= rc->lcover= rc->rcover= false;
            lc->length= rc->length= 0;
            lc->lc= lc->rc= rc->lc= rc->rc= nullptr;
        }
        if (l <= lc->R) lc->add(l, r, x);
        if (r >= rc->L) rc->add(l, r, x);
        pushup();
    }
};
```

整体和上次差不多，就是 `pushup` 有些变化。

然后给大家提供一下例题：[P1856](https://www.luogu.com.cn/problem/P1856)。

这里是这道题的主函数（这种方法）：

```cpp

int main() {
    node* root= new node;
    root->L= -20000;
    root->R= 20000;
    root->num= root->cover= 0;
    root->lcover= root->rcover= false;
    root->lc= root->rc= nullptr;
    root->length= 0;
    int n;
    read(n);
    int a, b, c, d;
    for (int i= 0; i < n; ++i) {
        read(a, b, c, d);
        lines.push_back({a, {{b, d - 1}, 1}});
        lines.push_back({c, {{b, d - 1}, -1}});
    }
    sort(lines.begin(), lines.end());
    int ans= 0;
    int l1,l2;
    for (int i= 0; i < lines.size(); ++i) {
        if (i != 0) {
            ans+= root->num * (lines[i].first - lines[i - 1].first);
        }
        ans+=root->length*2;
        l1=root->length;
        root->add(lines[i].second.first.first, lines[i].second.first.second, lines[i].second.second);
        l2=root->length;
        ans-=2*min(l1,l2);
    }
    cout << ans;
}
```

`read` 是快读，可以换掉。

但是，这并不是我第一遍过的代码。

我第一遍过的代码长这样（主函数）：

```cpp

int main() {
    node* root= new node;
    root->L= -20000;
    root->R= 20000;
    root->num= root->cover= 0;
    root->lcover= root->rcover= false;
    root->lc= root->rc= nullptr;
    root->length= 0;
    int n;
    read(n);
    int a, b, c, d;
    for (int i= 0; i < n; ++i) {
        read(a, b, c, d);
        lines.push_back({a, {{b, d - 1}, 1}});
        lines.push_back({c, {{b, d - 1}, -1}});
    }
    sort(lines.begin(), lines.end());
    int ans= 0;
    for (int i= 0; i < lines.size(); ++i) {
        if (i != 0) {
            ans+= root->num * (lines[i].first - lines[i - 1].first);
        };
        ans+= lines[i].second.first.second - lines[i].second.first.first + 1;
        if (lines[i].second.second > 0) {
            ans-= root->ask(lines[i].second.first.first, lines[i].second.first.second);
            root->add(lines[i].second.first.first, lines[i].second.first.second, lines[i].second.second);
        } else {
            root->add(lines[i].second.first.first, lines[i].second.first.second, lines[i].second.second);
            ans-= root->ask(lines[i].second.first.first, lines[i].second.first.second);
        }
    }
    cout << ans;
}
```

这是我的思路：

我们先把这次的横向宽度算出来，然后直接处理和扫描线平行的部分。

如果这次是添加了一条边，那么这部分的长度就是我们新加入的实际长度（也就是在扫描线上多出的那一块），只要用这一条边的总长度减去增加前那个区域原本就被覆盖过的长度。

如果这次是删除了一条边，那么就是我们去掉的实际长度，只要用这一条边的总长度减去删掉这条边后那一部分还没有删掉的长度。

具体看某一部分的覆盖长度使用了结构体里的 `ask` 函数，长这样：

```cpp
int ask(int l, int r) {
    if (cover > 0) {
        return min(r, R) - max(l, L) + 1;
    }
    if (l <= L && r >= R) {
        return length;
    }
    if (lc == nullptr && rc == nullptr) return 0;
    if (r <= lc->R) return lc->ask(l, r);
    if (l >= rc->L) return rc->ask(l, r);
    return lc->ask(l, r) + rc->ask(l, r);
}
```

这两种方法都能通过此题，所以能记住哪种就用哪种吧。

好了，我要讲的就这么多了，如果我还有机会的话，可能会再给扫描线系列出续篇。

[The End](https://www.luogu.com.cn/blog/478861/)

---

## 作者：poorpool (赞：2)

看到一坨矩形就要想到扫描线。（poj atlantis）

我们把横边竖边分开计算，因为横边竖边其实没有区别，以下论述全为考虑竖边的。

怎样统计一个竖边对答案的贡献呢？答：把这个竖边加入线段树，当前的总覆盖长度 减去 加入前的总覆盖长度 **的绝对值** 即为这个竖边的贡献。

这样做有一个要求，横坐标相同的竖边，要先加进去入边再删掉出边。（为什么呢？考虑两个矩形，一个矩形的右边和另一个矩形的左边的横坐标相同但上下错落）

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int n, qwq1, pwp1, qwq2, pwp2, cnt, m, num[20005], ans;
struct Line{
	int uu, vv, ww, id;
}li1[10005], li2[10005];
bool cmp(Line x, Line y){
	if(x.uu!=y.uu)	return x.uu<y.uu;
	else	return x.id>y.id;
}
struct SGT{
	int sum[80005], len[80005];
	void update(int o, int l, int r, int x, int y, int k){
		if(num[l]>=x && num[r]<=y)	sum[o] += k;
		else{
			int mid=(l+r)>>1;
			int lson=o<<1;
			int rson=lson|1;
			if(x<num[mid])	update(lson, l, mid, x, y, k);
			if(num[mid]<y)	update(rson, mid, r, x, y, k);
		}
		if(sum[o]>0)	len[o] = num[r] - num[l];
		else if(l+1==r)	len[o] = 0;
		else	len[o] = len[o<<1] + len[(o<<1)|1];
	}
}sgt;
int main(){
	cin>>n;
	for(int i=-10000; i<=10000; i++)	num[++m] = i;
	for(int i=1; i<=n; i++){
		scanf("%d %d %d %d", &qwq1, &pwp1, &qwq2, &pwp2);
		cnt++;
		li1[cnt] = (Line){qwq1, pwp1, pwp2, 1};
		li2[cnt] = (Line){pwp1, qwq1, qwq2, 1};
		cnt++;
		li1[cnt] = (Line){qwq2, pwp1, pwp2, -1};
		li2[cnt] = (Line){pwp2, qwq1, qwq2, -1};
	}
	sort(li1+1, li1+1+cnt, cmp);
	sort(li2+1, li2+1+cnt, cmp);
	for(int i=1; i<=cnt; i++){
		int lst=sgt.len[1];
		sgt.update(1, 1, m, li1[i].vv, li1[i].ww, li1[i].id);
		ans += abs(sgt.len[1]-lst);
	}
	for(int i=1; i<=cnt; i++){
		int lst=sgt.len[1];
		sgt.update(1, 1, m, li2[i].vv, li2[i].ww, li2[i].id);
		ans += abs(sgt.len[1]-lst);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Star_Cried (赞：2)

## 前言
~~对于这道题线段树的写法请参见其他dalao题解~~

可能因为这道题的测试点都挺水，本人参照（膜拜）[3206583219sjw](https://www.luogu.com.cn/user/129601) 的想法来水了我的第一篇题解。

因为这个类似于扫描的思维和标程有~~异曲同工之妙~~可能会对像我这样的新手起一点指导作用以理解和应用其他更为高大上的方法吧~

###### 不知道数据会不会加强……

## 思路
观察这些个矩形，通过题意我们可以想到这个题只与矩形的周长有关（废话），所以我们自然而然地想到可以将矩形分为四条线分别进行计算。由于矩形的特性，我们可以分别将所有矩形的左边竖线和下边横线进行计算，并将答案乘2即可。这个做法的好处在于：

![](https://cdn.luogu.com.cn/upload/image_hosting/02homnyn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

比如上两个矩形（内含边用黄色标注），我们可以用平移的方法确保整体位于左边的竖边和右边的边一定一一对应。那么我们**先将每个矩形的左边从左往右排列一下**，讨论左边矩形时，对于内含的边，我们可以添加一个临时数组tag标记，即
```cpp
for(int i=1;i<=n;++i)					 //从左往右遍历矩形
	{
		for(int j=e[i].ly;j<e[i].ry ;++j)//从下倒上遍历标记每个构成边的点
		{
			if(tag[j]<e[i].lx )ans+=2;   //tag在遍历第二个矩形时在黄色的右竖边时遍历的点在第一个矩形内部，so不加，原来的黄边移到了最右边的粉边
            							 //ans+=2是连接的整个图形的左边+右边，保证两两配对
			if(tag[j]<e[i].rx )tag[j]=e[i].rx ;//更新整体图像的最右边界
		}
	}
```
用tag数组标记上一个（或之前右边最右的）矩形的位置，可以明确接下来的矩形是否相接。这里tag表示的是竖着的y轴。
对于横边也一样：
```cpp
for(int i=1;i<=n;++i)
	{
		for(int j=e[i].lx ;j<e[i].rx ;++j)
		{
			if(tag[j]<e[i].ly )ans+=2;
			if(tag[j]<e[i].ry )tag[j]=e[i].ry;
		}
	}
```
总的来说这个思路的流程和线段树做法是一样的（吧），~~但由于我太菜了而且线段树想不出来~~只能用这个稍微投机取巧的方法，线段树应该是比这个更优秀（我没比较过），时间复杂度~~不知道~~。这里再次膜拜提供方法思路（和标程）的[dalao](https://www.luogu.com.cn/user/129601)。
## 过程
我们可以建一个结构体存储矩形。
```cpp

int tag[21000],ans=0,n;
struct square
{
	int lx,ly,rx,ry;//lx，ly是左下坐标，rx，ry右上
}e[5005];

bool cmpx(edge a , edge b){return a.lx <b.lx ;}
bool cmpy(edge a , edge b){return a.ly <b.ly ;}
//讨论不同方向上用于sort的排序函数
```
主函数
```cpp
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d%d%d",&e[i].lx ,&e[i].ly ,&e[i].rx ,&e[i].ry );
		e[i].lx +=10001;
		e[i].ly +=10001;
		e[i].rx +=10001;
		e[i].ry +=10001;
	}                          //因为tag初始是0，而题目坐标有负数所以投下机
//////////////////////////////////////////////////////////////////////////
	memset(tag,-1,sizeof(tag));//可以一数组二用
	sort(e+1,e+n+1,cmpx);
	for(int i=1;i<=n;++i)
	{
		for(int j=e[i].ly ;j<e[i].ry ;++j)
		{
			if(tag[j]<e[i].lx )ans+=2;
			if(tag[j]<e[i].rx )tag[j]=e[i].rx ;
		}
	}
//////////////////////////////////////////////////////////////////////////
//	……横边代码请自行想象
	printf("%d",ans);
	return 0;
}
```
因为防刷题和~~版权原因~~不能发完整程序非常抱歉……但是基本思路应该都清楚了~~不清楚的请出门右转线段树【滑稽】~~

### 希望我的题解能帮到你
###### 第一篇题解留念

---

## 作者：Celebrate (赞：1)

# 扫描线了解一下

我们给把一个矩形变为四条边，a数组记录纵向边，b数组记录横向边，每个矩形可以给

a，b两数组分别贡献两条边，所以定义数组的时候要翻倍

按照边的x坐标从小到大排序a，再按照边的y坐标从小到大排序b

## 现在开始最主要的--扫描线（暴力，可以用线段树优化）

先说a数组吧（纵向边）

定义一个（y）数组

排好序以后，枚举每一条边：


------------


如果是矩形的第一条（左边）纵向边，就把这条边所覆盖的范围内的数+1（表示当前覆盖了的边

数，用刚才定义的数组来存），如果是0（没有被覆盖到），说明这个就是要找的周长

边，ans+1

------------

如果是矩形第二条（右边）纵向边，就把这条边所覆盖到的范围内的数-1，如果是

0（图形最右边的那条边），ans+1

------------

代码：

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
struct node
{
    int t,a1,a2;//t表示整条边所在的x（或y坐标），a1-a2表示所覆盖的范围 
    int bk;//bk为1表示第一条边，bk为2表示第二条边 
}a[11000],b[11000];int len;
inline int cmp(const void *xx,const void *yy)//排序 
{
    node x=*(node*)xx;
    node y=*(node*)yy;
    if(x.t==y.t)//如果所在位置相同 
    {
        if(x.bk>y.bk) return 1;//先找第一条边（放在前面，位置不变） 
        return -1;
    }
    if(x.t>y.t) return 1;//否则就按照前后顺序排序 
    return -1;
}
int x1,y1,x2,y2;
int x[21000],y[21000],key=10000;//x和y不解释，key是为了把负数变为非负数（c++数组不能存负数） 
int main()
{
    int n,i,j,ans=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        len++;//第一条边 
        a[len].t=x1;a[len].a1=y1;a[len].a2=y2;a[len].bk=1;
        b[len].t=y1;b[len].a1=x1;b[len].a2=x2;b[len].bk=1;
        len++;//第二条边 
        a[len].t=x2;a[len].a1=y1;a[len].a2=y2;a[len].bk=2;
        b[len].t=y2;b[len].a1=x1;b[len].a2=x2;b[len].bk=2;
    }
    qsort(a+1,len,sizeof(node),cmp);
    qsort(b+1,len,sizeof(node),cmp);
    for(i=1;i<=len;i++)//扫描线 
    {
        if(a[i].bk==1)//如果是第一条边 
        {
            for(j=a[i].a1;j<a[i].a2;j++)
            {
                if(y[j+key]==0) ans++;
                y[j+key]++;
            }
        }
        else//如果是第二条边 
        {
            for(j=a[i].a1;j<a[i].a2;j++)
            {
                y[j+key]--;
                if(y[j+key]==0) ans++;
            }
        }
        if(b[i].bk==1)//同上 
        {
            for(j=b[i].a1;j<b[i].a2;j++)
            {
            	if(x[j+key]==0) ans++;
            	x[j+key]++;
            }
        }
        else
        {
        	for(j=b[i].a1;j<b[i].a2;j++)
        	{
        		x[j+key]--;
        		if(x[j+key]==0) ans++;
        	}
        }
    }
    printf("%d\n",ans);//输出 
    return 0;
}
```

这里还有一个问题：

为什么查找范围里面要“j=a[i].a1;j< a[i].a2;j++”，

而不是。。。。。。。“j=a[i].a1;j<=a[i].a2;j++”

（相差了一个=号）

原因就是数组存的不是点，而是长度为1的边

（假如全部的点都是在第一象限，不打key了），那么

x[0]表示0-1当前所覆盖的次数，x[1]表示1-2当前所覆盖的次数，边的数量比点的少1，

所以就要将这个等号删去了

---

## 作者：feng_chengjie (赞：1)

//我上一个代码有点问题，改进了一下，麻烦管理员帮忙删掉上一个，留下这一个

我看先辈已经分析得十分透彻了，虽然此题数据可能很水，但还是想趁机学习一下扫描线，于是就来一发正宗的线段树之扫描线：

很明显扫描时可以先横再竖，但那样太费时，于是我们考虑一种更加简便的方法：

##按照横边的顺序扫描，顺便计算竖边：

这里有几个关键的变量：

l , r : 该节点代表的线段的左右端点坐标

2.len : 这个区间被覆盖的长度（即计算时的有效长度）

3.s : 表示这个区间被覆盖了几次

lc , rc : 标记这个节点的左右两个端点是否被覆盖（0表示没有，1表示有）

5.num :这个区间有多少条线段（这个区间被多少条线段覆盖）

##还要注意的是：如果有重叠的边，应当先加入边后加出边，否则会多算

##这个在洛谷上测不出来，但是在USACO上可以，我觉得大家还是做细一点比较吼

##这块具体看看代码的注释


详情请参考：http://blog.csdn.net/tomorrowtodie/article/details/52048323

（不要抄他的代码，有问题）

下面是参考代码：


/\*
ID: linda\_f1

PROG: picture

LANG: C++

\*/





```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define ls i<<1
#define rs i<<1|1
using namespace std;
const int N=10000+10;
const int X=20000+10;
const int inf=1<<29;
struct Edge
{
    int l,r;
    int h;
    int f,ff;
}e[N];
struct point
{
    int l,r;
    int len;
    int s;//having been lapped or not
    bool lc,rc;
    int num;//having been lapped how many times
}q[X*4];
int n,a1,b1,a2,b2,tot=0;
int mn=inf,mx=-inf;
bool comp(const Edge &a,const Edge &b)
{
    if(a.h!=b.h)
        return a.h<b.h;
    else
        return a.f>b.f;//就是这，让入边优先 
}
void push_up(int i)
{
    if(q[i].s) 
    {
        q[i].len=q[i].r-q[i].l+1;
        q[i].lc=1;
        q[i].rc=1;
        q[i].num=1;
    }
    else if(q[i].l==q[i].r)
    {
        q[i].len=0;
        q[i].lc=0;
        q[i].rc=0;
        q[i].num=0;
    }
    else//#1 这里就会使得q[1].len被更新  ==> 转到 #2
    {
        q[i].len=q[ls].len+q[rs].len; 
        q[i].lc=q[ls].lc;
        q[i].rc=q[rs].rc;
        q[i].num=q[ls].num+q[rs].num-(q[ls].rc&q[rs].lc);
    }
}
void build(int i,int l,int r)
{
    q[i].l=l;
    q[i].r=r;
    q[i].len=q[i].s=0;
    q[i].lc=q[i].rc=q[i].num=0;
    if(l==r)
        return;
    int mid=(q[i].l + q[i].r)>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
}
void update(int i,int l,int r,int xx)
{
    if(q[i].l==l && q[i].r==r)
    {
        //如果有重叠边先扫出边就会使得q[1].s=0 ==>转到 #1 
        q[i].s+=xx;//如果有重叠边先扫出边就会被认为成两条线，会多加 
        push_up(i);
        return;
    }
    int mid=(q[i].l + q[i].r)>>1;
    if(r<=mid)
        update(ls,l,r,xx);
    else if(l>mid)
        update(rs,l,r,xx);
    else
        {
            update(ls,l,mid,xx);
            update(rs,mid+1,r,xx);
        }
    push_up(i);
}
int main()
{
//    freopen("picture.in","r",stdin);
//    freopen("picture.out","w",stdout); 
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a1>>b1>>a2>>b2;
        mx=max(mx,max(a1,a2));
        mn=min(mn,min(a1,a2));
        Edge &t1=e[tot];
        Edge &t2=e[tot+1];
        t1.l=t2.l=a1;
        t1.r=t2.r=a2;
        t1.h=b1;
        t1.f=1;
        t2.h=b2;
        t2.f=-1;
        tot+=2;
    }
    sort(e,e+tot,comp);
    int ans=0;
    int last=0;
    build(1,mn,mx-1);
    for(int i=0;i<tot;i++)
    {
        update(1,e[i].l,e[i].r-1,e[i].f);
        ans+=abs(q[1].len-last);//#3 这里就会把和出边重叠的边再加一遍 
        ans+=(e[i+1].h-e[i].h)*2*q[1].num;
        last=q[1].len;//#2 这里更新了last,就会认为出边结束了 ==>转到 #3 
    }
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：TheShadow (赞：0)

# 闲扯

这题改了好久啊。。。

一直没有想到怎么维护现在空出来的边，结果卡了很久。

最后看题解之后才豁然开朗。

但是处理边排序的时候也是有一些问题，最后做了 $3$ 小时终于做出来了。。。

# 题面

[P1856 [USACO5.5]矩形周长Picture](https://www.luogu.org/problem/P1856)

# Solution

这种维护面积并，周长并的题都可以用扫描线来解决。

和维护面积并一样，我们还是将原图划分成一段一段的。

但是和面积并有差别的是，我们需要对横边和竖边分别计算他们对答案的贡献。（虽然好像可以只算一次，但没必要）

对于每一条线，它能产生的贡献肯定是它管辖的区间里面暂时没被其他矩形覆盖的长度。

但是我们要直接维护是很困难的，考虑换一种思路。

对于每一次加边，它的答案其实就是**新覆盖/撤销**的线段长度。（想一想，为什么）

那么我们每次记录一下上一次的被覆盖了多少，每一次更新后将答案加上当前覆盖和上一次覆盖的长度差的绝对值。

还有一个需要注意的点是对每一条线段排序是的顺序。

对于同一个位置，我们将加入的边排在前面，删除的边排在后面。这样我们就保证了一个左右都有矩形的边不会错误的加入答案中。（因为每一个删除，前面必然对应了一个添加，如果还有添加，那我们加上后，最后的一次删除结束，计数器还会有值，不会将它加入到总贡献。）

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 5e3+5;
int n,a,b,c,d,ans,s[MAXN<<1],s1[MAXN<<1],sz,tmp;
struct Node{
	int x,a,b,ty;
	Node(){}
	Node(int x,int a,int b,int ty):x(x),a(a),b(b),ty(ty){}
	bool operator <(const Node &t) const{
		return x==t.x?ty>t.ty:x<t.x;
	}
}node[MAXN<<1],node1[MAXN<<1];
it get_id(int x){return lower_bound(s+1,s+1+sz,x)-s;}
it get_id1(int x){return lower_bound(s1+1,s1+1+sz,x)-s1;}
#define lc (cur<<1)
#define rc (cur<<1|1)
struct Seg_Tree{
	int len,cnt;
}T[MAXN<<3];
il pushup(int cur,int l,int r,int ty){
	if(T[cur].cnt) T[cur].len=ty==1?s[r+1]-s[l]:s1[r+1]-s1[l];
	else{
		if(l==r) T[cur].len=0;
		else T[cur].len=T[lc].len+T[rc].len;
	}
}
il updata(int cur,int l,int r,int L,int R,int k,int ty){
	if(l>=L&&r<=R) T[cur].cnt+=k;
	else{
		if(mid>=L) updata(lc,l,mid,L,R,k,ty);
		if(R>mid) updata(rc,mid+1,r,L,R,k,ty);
	}
	pushup(cur,l,r,ty);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n);
	for(ri i=1;i<=n;++i){
		read(a),read(b),read(c),read(d);
		node[i*2-1]=Node(a,b,d,1),node[2*i]=Node(c,b,d,-1);
		s[2*i-1]=b,s[2*i]=d;
		node1[i*2-1]=Node(b,a,c,1),node1[2*i]=Node(d,a,c,-1);
		s1[2*i-1]=a,s1[2*i]=c;
	}
	sort(node+1,node+1+2*n),sort(s+1,s+1+2*n),sz=unique(s+1,s+1+2*n)-s-1;
	for(ri i=1;i<=2*n;++i){
		ri ty=node[i].ty,x=get_id(node[i].a),y=get_id(node[i].b)-1;
		updata(1,1,sz-1,x,y,ty,1);
		ans+=abs(tmp-T[1].len),tmp=T[1].len;
	}
	sort(node1+1,node1+1+2*n),sort(s1+1,s1+1+2*n),sz=unique(s1+1,s1+1+2*n)-s1-1,tmp=0;
	for(ri i=1;i<=2*n;++i){
		ri ty=node1[i].ty,x=get_id1(node1[i].a),y=get_id1(node1[i].b)-1;
		updata(1,1,sz-1,x,y,ty,2);
		ans+=abs(tmp-T[1].len),tmp=T[1].len;
	}
	print(ans);
	return 0;
}
```

# 总结

要注意细节，还有做题要多转换一下，将问题尽可能的简化，方便我们进行处理。

---

## 作者：ZQYZQY (赞：0)

# 方法：线段树+扫描线

说到扫描线，就是求覆盖面积了（蒻基我没做过╥﹏╥...）；而这道题是求周长，感觉不一样，其实差不多，也是模板；

我们可以，横竖扫一遍记录长度然后duang~在一起，但是显得不是很高端。

所以在求面积的时候会用到的高度差其实就等于竖边，再乘以竖边的个数num就可以得出竖边的总长度

然后细节：

1.注意两条边都在条线上刚好邻的时候

2.注意叶节点覆盖的是点不是线段

3.注意数据很水不用离散化Σ(っ °Д °;)っ

4.别算了竖边就忘了横着的（这次长度-上次的长度）

5.两个矩形重合的话，需要改变num值

6。最好不要在结构体中放构造函数，数据大容易MLE，当然这道题不会......
```cpp
#include<bits/stdc++.h>
using namespace std;
int const maxn=25000;
struct X{
int l,r,h,s;//l,r分别—>左端点和右端点，h=高度，s=标记；
/*X(){};
X(int l_,int r_,int h_,int s_):l(l_),r(r_),h(h_),s(s_){}//赋值函数 
bool operator <(const X &S) const {
	return h<S.h;
}//重载比较 */
}arr[maxn];
//最好不要在结构体中放构造函数，数据大容易MLE，当然这道题不会
bool cmp(X a,X b){
	  return a.h<b.h||a.h==b.h&&a.s>b.s;//最后一个点的精髓(ง •_•)ง
}
X Fu(int l_,int r_,int h_,int s_){
	X sh;
	sh.l=l_,sh.h=h_,sh.r=r_,sh.s=s_;
	return sh;
}//赋值函数
bool ln[maxn<<2],rn[maxn<<2];//标记左右端点是否被覆盖（合并用）
int num[maxn<<2],cnt[maxn<<2],len[maxn<<2]; //num=区间内线段数量，cnt=区间被覆盖次数，len=区间覆盖长度
void PushUp(int rt,int l,int r){
	if(cnt[rt]){//如果被覆盖【整个区间】 ,即>0 
		ln[rt]=rn[rt]=1;//左右端点都被覆盖
		 len[rt]=r-l+1;//更新长度
		 num[rt]=2;//每条线段有两个端点; 
	}
	else {
		if(l==r) len[rt]=num[rt]=ln[rt]=rn[rt]=0;//如果是叶节点，那么就是一个（l,l）/（r,r）的点而不是线段，那么全部都为0；
		else{//未被完全覆盖但是不是叶节点 
			ln[rt]=ln[rt<<1]; 	rn[rt]=rn[rt<<1|1];//和左右儿子共端点；
			len[rt]=len[rt<<1]+len[rt<<1|1];num[rt]=num[rt<<1]+num[rt<<1|1]; 
			if(ln[rt<<1|1]&&rn[rt<<1]) num[rt]-=2;//两点重合（右儿子左端点&&左儿子右端点）   
		} 
	}
} 
void Update(int L,int R,int l,int r,int n,int now){
	if(L<=l&&r<=R){
		cnt[now]+=n;
		PushUp(now,l,r);
		 return;                             }
	int mid=(l+r)>>1;
	if(L<=mid) Update(L,R,l,mid,n,now*2);
	if(R>mid) Update(L,R,mid+1,r,n,now*2+1);
	PushUp(now,l,r);
} 
int main(){
int N;
int nn=0,lnn=10000,rnn=-10000;
scanf("%d",&N);
for(int i=1;i<=N;i++){
	int a,b,c,d;
	scanf("%d%d%d%d",&a,&b,&c,&d);
	lnn=min(lnn,a),rnn=max(rnn,c);//整个图形的左右端点；
	arr[nn++]=Fu(a,c,b,1);//下边
	arr[nn++]=Fu(a,c,d,-1);//上边 
}
sort(arr,arr+nn,cmp);//按h排序 
int L=0;
long long int sum=0;
for(int i=0;i<nn;i++){
	if(arr[i].l<arr[i].r) Update(arr[i].l,arr[i].r-1,lnn,rnn-1,arr[i].s,1);
	sum+=num[1]*(arr[i+1].h-arr[i].h);//竖线
	sum+=abs(len[1]-L);
	L=len[1]; 
} 
printf("%lld",sum);//结束ε=ε=ε=(~￣▽￣)~
return 0; 
} 
```


---

## 作者：vinvor (赞：0)

算法一 离散化

把所有矩形离散化(就是将整个平面分成许多“竖条”或“横条”，对其操作），每个矩

形都由四条边组成，分为纵边和横边。对纵边和横边分别扫描一次，以横边为例：

每个矩形的两条横边中，称下面的为始边，上面的为终边。把每条横边以纵坐标从小到

大排序，如果纵坐标相同，则应把始边排到终边之前。

依次枚举每条横边。如果当前边为始边，则把这条边的横向的所有点j 的层数增加1，

即为level[j]++。如果层数由0 变为了1，则这一点一定是边缘点，总周长ans++。如果当前

边为终边，则把这条边的横向的所有点j 的层数减少1，即为level[j]--。如果层数由1 变为

了0，则这一点一定是边缘点，总周长ans++。

同理按此方法扫描纵边，即可得到最后结果。

算法二

总思路：离散+线段树(其实就是提高level[j]++的效率)

首先是离散：

显然，我们有2n 条纵线和2n 条横线。算法中，我们只考虑纵线，因为横线的做法同纵

线的做法是相同的。离散就是将这2n 条线段按照从左到右的顺序排序（也就是按照每条纵

线的横坐标从小到大排序），这里需要注意一点：如果出现两个相同横坐标的纵线段，属于

所在矩形左边的线段要排在属于所在矩形右边的线段的左边。（这两个线段属于不同的矩

形）。

然后是线段树：每个节点有6 个属性：s，t，l，r，c，m，分别表示左边界、右边界、

左子树、右子树、覆盖数、区间内线段总长度。

对于2n 条纵线段，属于矩形左边的线段添加该线段到线段树(覆盖数+1)，属于矩形右

边的线段则从线段树中删除该线段(覆盖数-1)。做添加、删除线段的同时，要维护m 属性。

规则如下：

如果该段线段覆盖数(c)>0，则M 即为线段长，

如果覆盖数(c)=0，则M 为左儿子的M+右儿子的M。(如果本身是叶子就为0）

每次操作线段后改变总长度（也可能不变），如果原来的长度为now，新的长度为new，

如果new>now，则new-now 算入答案ans。

下附线段树代码：（C++选手自行替换头文件吧...我是C）

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct Line {
    int x, y1, y2;
    bool in;
} *_a_, *_b_;
Line a[10000], b[10000];
int f[88888];
bool g[88888]; 
int i, n = 0, x1, y1, x2, y2;
long ans = 0;
inline int cmp_line(const void *a, const void *b) {
    _a_ = (Line *)a, _b_ = (Line *)b;
    if (_a_->x > _b_->x) return 1;
    if (_a_->x < _b_->x) return -1;
    return _a_->in ? -1 : 1;
}
void insert(const long t, const int l, const int r) {
    if (l >= y1 && r <= y2 && !g[t]) {
        if (!f[t]++) ans += r - l;
        return ;
    }
    long mid = (l + r) / 2, t1 = t << 1, t2 = t1 | 1;
    f[t1] += f[t], f[t2] += f[t], f[t] = 0; 
    if (mid >= y2) insert(t1, l, mid);
    else if (mid <= y1) insert(t2, mid, r);
    else insert(t1, l, mid), insert(t2, mid, r);
    g[t] = f[t1] || f[t2] || g[t1] || g[t2];
}
void erase(const long t, const int l, const int r) {
    if (l >= y1 && r <= y2 && !g[t]) {
        if (!--f[t]) ans += r - l;
        return ;
    }
    long mid = (l + r) / 2, t1 = t << 1, t2 = t1 | 1;
    f[t1] += f[t], f[t2] += f[t], f[t] = 0;
    if (mid >= y2) erase(t1, l, mid);
    else if (mid <= y1) erase(t2, mid, r);
    else erase(t1, l, mid), erase(t2, mid, r);
    g[t] = f[t1] || f[t2] || g[t1] || g[t2];
}
int main() {
    for (scanf("%d", &i); i; --i) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        a[n].x = x1, a[n].y1 = y1, a[n].y2 = y2, a[n].in = true;
        b[n].x = y1, b[n].y1 = x1, b[n].y2 = x2, b[n++].in = true;
        a[n].x = x2, a[n].y1 = y1, a[n].y2 = y2, a[n].in = false;
        b[n].x = y2, b[n].y1 = x1, b[n].y2 = x2, b[n++].in = false;
    }
    qsort(a, n, sizeof(Line), cmp_line);
    memset(f, 0, sizeof f);
    memset(g, 0, sizeof g);
    for (i = 0; i < n; ++i) {
        y1 = a[i].y1, y2 = a[i].y2;
        a[i].in ? insert(1, -10000, 10000) : erase(1, -10000, 10000);
    }
    qsort(b, n, sizeof(Line), cmp_line);
    memset(f, 0, sizeof f);
    memset(g, 0, sizeof g);
    for (i = 0; i < n; ++i) {
        y1 = b[i].y1, y2 = b[i].y2;
        b[i].in ? insert(1, -10000, 10000) : erase(1, -10000, 10000);
    }
    printf("%d\n", ans);
    return 0;
}
```

---


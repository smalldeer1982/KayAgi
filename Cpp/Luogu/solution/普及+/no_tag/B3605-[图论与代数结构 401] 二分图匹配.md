# [图论与代数结构 401] 二分图匹配

## 题目描述

给定一张左侧有 $nl$ 个点、右侧有 $nr$ 个点、$m$ 条边的二分图，求一组它的最大匹配。

## 说明/提示

对于所有数据，$1\leq nl,nr\leq 500$，$1\leq m\leq 2.5\times 10^5$。

## 样例 #1

### 输入

```
2 2 3
1 1
1 2
2 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
2 2 2
1 1
2 1
```

### 输出

```
1```

## 样例 #3

### 输入

```
15 15 30
4 14
6 1
14 7
7 8
1 12
15 8
8 10
6 10
6 2
6 12
5 1
5 14
11 10
9 9
7 12
11 13
5 9
6 9
9 1
5 8
10 13
1 13
10 3
11 7
10 8
9 5
12 13
11 6
12 15
14 4
```

### 输出

```
12```

## 样例 #4

### 输入

```
15 15 40
6 10
3 10
2 2
6 5
1 3
11 7
5 8
14 2
10 5
9 15
15 13
13 14
8 10
9 10
15 1
10 2
7 1
3 8
12 3
12 10
11 4
14 11
4 13
7 11
14 15
7 13
12 7
11 6
12 15
2 9
9 9
6 13
1 9
6 15
4 4
14 12
5 4
14 5
12 9
2 10
```

### 输出

```
15```

## 样例 #5

### 输入

```
15 15 2
14 1
14 2
```

### 输出

```
1```

# 题解

## 作者：Hamer_sans (赞：10)

# B3605的题解

### 本题算法：

本题是一道二分图的最大匹配，我们可以用匈牙利算法来解决这个问题。

### 什么是二分图？

二分图就是一种特殊的图，这张图中的节点可以分为两个集合，并且在同一集合内的节点没有边，也就是说要想从一个节点走到另一个在同一集合的节点，走的边的数量是偶数，如图这就是一张二分图，$t_{1}$，$t_{2}$，$t_{3}$，$t_{4}$ 属于一个集合，并且在这个集合内的节点之间都没有边。

![](https://cdn.luogu.com.cn/upload/image_hosting/6lz7q52k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

### 什么是匈牙利算法？

首先要了解什么是最大匹配，最大匹配就是在一张二分图中，在两集合间已有的边中，每个点只能连接另一集合的一个点，求最多有多少个连边，如果形象点说，你可以理解成左边的集合的点是男孩，右边的集合的点是女孩，两集合间的边就是这一对男孩和女孩之间有感情，最大匹配就是求最多能匹配上多少对情侣。

我们引入一个数组，$match_{x}=y$，这个数组的含义是 $x$ 与 $y$ 匹配，相当于 $x$ 这个男孩与 $y$ 这个女孩匹配成了一对情侣。

在引入一个概念叫做增广路径，就是一条连接两个未匹配的节点的路径，并且已匹配的边和待匹配的边交替在这条路径中出现，这就是一条增广路径。如图，在这幅图中，红色的边是已匹配边，黑色的边是待匹配边，所以 $A$ 到 $F$ 的路径就是一条增广路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/u4fgy9n1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

现在说明匈牙利算法是如何求二分图最大匹配的，首先我们先进行匹配，如果目标点未匹配，那么进行匹配，并返回匹配成功，如果该目标点已经被匹配过了，那么递归这个点，查看这个点是否能重新匹配另一个点，相当于问这个人能不能换一个伴侣，如果可以，返回匹配成功，否则返回匹配失败。对于整个过程相当于就是在消除增广路径。

### 代码
```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std;
inline int read(){ //快读优化
	int sum=0,h=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') h=-1;ch=getchar();}
	while(isdigit(ch)) sum=sum*10+ch-'0',ch=getchar();
	return sum*h;
}
const int N=3e5+5;
int ver[N],head[N],ne[N],tot;
int k,n,m;
int match[1005];
bool vis[1005];
void add(int x,int y){ //邻接表储存
	ver[++tot]=y;
	ne[tot]=head[x];
	head[x]=tot;
	return;
}
bool dfs(int x){ //匈牙利算法
	for(register int i=head[x];i;i=ne[i]){
		int y=ver[i];
		if(vis[y]) continue; //如果该点被访问过，就跳过
		vis[y]=1;
		if(!match[y] or dfs(match[y])){ //如果目标点未匹配或它可以换一个，就进行匹配
			match[y]=x;
			return 1; //返回匹配成功
		}
	}
	return 0; //返回匹配失败
}
int main(){
	k=read(),n=read(),m=read();
	for(register int i=1;i<=m;++i){
		int a,b;
		a=read(),b=read();
		add(a,b+k);
	}
	int ans=0;
	for(register int i=1;i<=k;++i){
		memset(vis,0,sizeof vis);
		if(dfs(i)) ++ans; //如果该点匹配成功，最大匹配数就加一
	}
	printf("%d",ans);
	return 0;
}
```

蒟蒻写题解不易，求点赞。

---

## 作者：EuphoricStar (赞：9)

## 思路

本题可转化为最大流问题。

设源点为 $1$，汇点为 $nl + nr + 2$，左侧点编号为 $2$ ~ $nl + 1$，右侧点编号为 $nl + 2$ ~ $nl + nr + 1$。

然后源点向每个左侧点连一条容量为 $1$ 的边，每个右侧点向汇点连一条容量为 $1$ 的边，左侧点和右侧点按照输入的边连一条容量为 $1$ 的边，然后跑一遍 Dinic，此时最大流便是答案。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1020, maxm = 511000, inf = 0x3f3f3f3f;

int n, nl, nr, m, s, t, head[maxn], len;
struct edge {
    int from, to, next, cap, flow;
} edges[maxm];

void add_edge(int u, int v, int c, int f) {
    edges[++len].from = u;
    edges[len].to = v;
    edges[len].next = head[u];
    edges[len].cap = c;
    edges[len].flow = f;
    head[u] = len;
}

struct Dinic {
    bool vis[maxn];
    int d[maxn], cur[maxn];

    void add(int u, int v, int c) {
        add_edge(u, v, c, 0);
        add_edge(v, u, 0, 0);
    }

    bool bfs() {
        memset(vis, 0, sizeof(vis));
        queue<int> q;
        d[s] = 0;
        vis[s] = 1;
        q.push(s);
        while (q.size()) {
            int u = q.front();
            q.pop();
            for (int i = head[u]; i; i = edges[i].next) {
                edge e = edges[i];
                if (!vis[e.to] && e.cap > e.flow) {
                    vis[e.to] = 1;
                    d[e.to] = d[u] + 1;
                    q.push(e.to);
                }
            }
        }
        return vis[t];
    }

    int dfs(int u, int a) {
        if (u == t || !a) {
            return a;
        }
        int flow = 0, f;
        for (int &i = cur[u]; i; i = edges[i].next) {
            edge &e = edges[i];
            if (d[u] + 1 == d[e.to] && (f = dfs(e.to, min(a, e.cap - e.flow))) > 0) {
                e.flow += f;
                edges[i ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (!a) {
                    break;
                }
            }
        }
        return flow;
    }

    int solve() {
        int flow = 0;
        while (bfs()) {
            for (int i = 1; i <= n; ++i) {
                cur[i] = head[i];
            }
            flow += dfs(s, inf);
        }
        return flow;
    }
} solver;

int main() {
    scanf("%d%d%d", &nl, &nr, &m);
    s = 1;
    t = n = nl + nr + 2;
    len = 1;
    for (int i = 1; i <= nl; ++i) {
        solver.add(s, i + 1, 1);
    }
    for (int i = 1; i <= nr; ++i) {
        solver.add(i + nl + 1, t, 1);
    }
    while (m--) {
        int u, v;
        scanf("%d%d", &u, &v);
        solver.add(u + 1, v + nl + 1, 1);
    }
    printf("%d", solver.solve());
    return 0;
}
```


---

## 作者：zmza (赞：7)

## 二分图介绍

学习二分图最大匹配，首先我们先来了解二分图。

二分图，就是像这样的一个图：
![](https://i.loli.net/2021/02/28/97q2gZpwTodCt4l.png)

一共有两堆东西，左边一堆，右边一堆，左边的点和左边的点不能连边，右边的点和右边的点不能连边，只有左边的点和右边的点可以连边。

像这样的就叫做完全二分图：![](https://i.loli.net/2021/02/28/IJWHnuz2SEMBYbN.png)
左边和右边每两个点连了一条边。

二分图最大匹配，指如果每个左边的点只能和右边的点连一次，求最多能让多少左边的点和右边的点连在一起。

## 算法讲解

求最大匹配的算法叫匈牙利算法。

>> 匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1965年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。设 $G=(V,E)$ 是一个无向图。如顶点集 $V$ 可分割为两个互不相交的子集 $V_1,V_2$ ，选择这样的子集中边数最大的子集称为图的最大匹配问题（maximal matching problem)。
如果一个匹配中， $|V_1| \leq |V_2|$ 且匹配数 $|M|=|V_1|$ ，则称此匹配为完全匹配，也称作完备匹配。特别的当 $|V_1|=|V_2|$ 称为完美匹配。

——选自百度百科。

比如说第一个图，最大匹配就是 $3$ 。因为 $(3,1)$ 相连， $(2,3)$ 相连， $(1,2)$ 相连，所以最大匹配是 $3$ 。

那么怎么求二分图最大匹配呢？

就拿第一个图来看吧。

首先，我们先假设 $(1,1)$ 相连。

就变成了这个样子：
![](https://i.loli.net/2021/02/28/sTRw1LyhYldmIQb.png)
图中的 $match$ 数组代表右边的第几个点和左边的哪个点匹配上了。如果 $match[i]$ 为 $0$ ，那么就代表没有点和它匹配上。图中的右边 $1$ 号点和左边的一号点匹配上了。

然后，我们继续。图：
![](https://i.loli.net/2021/02/28/iuO8AtbUl3rN9JW.png)

从右边的第 $1$ 个开始循环，循环到 $2$ 时就连了一条边， $match[2]$ 又为 $0$ ，所以就可以匹配。

继续。图：

![](https://i.loli.net/2021/02/28/EB4Pi5X9LN3HFzQ.png)

这时，左边的 $3$ 要和右边的 $1$ 匹配，但是右边的 $1$ 已经被左边的 $1$ 匹配了，所以最重要的来了：将左边的 $1$ 和右边的 $1$ 拆开，不匹配了。接着，将左边的 $1$ 与右边的 $2$ 匹配，但是右边的 $2$ 又被左边的 $2$ 匹配了，于是将左边的 $2$ 与右边的 $2$ 拆开。再接着，将左边的 $2$ 与右边的 $3$ 匹配，成功了。于是，左边的 $2$ 与右边的 $3$ 匹配，左边的 $1$ 与右边的 $2$ 匹配，左边的 $3$ 与右边的 $1$ 匹配。

继续，不画图了。因为右边的三个点都被匹配完了，左边的 $4$ 号点无论如何都不能匹配到点了，所以算法结束了，答案为 $3$ 。

## 算法总结

总结一下算法的过程。首先，将左边的点全部循环一遍。每次进入算法，看看这个点是否可以匹配到右边的点。然后，算法里就将右边的点从1开始不重复循环一遍，每次看看将左边的点匹配到右边的点后，原来左边匹配右边这个点的点是否可以匹配到右边新的点，一直递归。如果递归的最后的点可以匹配到右边的一个空点（即没有被匹配的点），就将左边所有递归的点都匹配到右边的新点上去。否则，不修改任何东西。

这个算法的复杂度最坏为：

邻接矩阵： $\Theta(n^3)$ 邻接表： $\Theta(nm)$ 。

空间复杂度为：

邻接矩阵： $\Theta(n^2)$ 邻接表： $\Theta(n+m)$ 。

## 算法证明

为什么这个算法是正确的呢？因为左边每个如果可以匹配到右边的点，就一定会匹配，将左边其他的点安排到右边其他的点上去。所以可以匹配到的数量一定是最大的。


## 代码

```c
#include<string.h>
#include<stdio.h>
#include<stdbool.h>
int read()
{
	int i = 0, f = 1;
	char ch;
	for(ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
	if(ch == '-')
	{
		f = -1;
		ch = getchar();
	}
	for(; ch >= '0' && ch <= '9'; ch = getchar())
	{
		i = (i << 3) + (i << 1) + (ch ^ 48);
	}
	return i * f;
}
void write(int a)
{
	if(a < 0)
	{
		putchar('-');
		a = -a;
	}
	int sta[100] = {}, cnt = 0;
	while(a)
	{
		cnt++;
		sta[cnt] = a % 10;
		a /= 10;
	}
	while(cnt)
	{
		putchar(sta[cnt] + '0');
		cnt--;
	}
}
int a[501][501],match[501],n,m,e,ans;//a是用来建图的，match是用来匹配的，ans是答案。
bool p[501];//p是用来dfs判重的。
bool dfs(int x)
{
	for(int i = 1; i <= m; i++)//将右边的点循环一遍，找可以匹配的点。
	{
		if(a[x][i] && !p[i])//如果两个点之间有一条边并且右边这个没有被左边的x匹配过。
		{
			p[i] = 1;//标记，防止死循环。
			if(match[i] == 0 || dfs(match[i]))//只要满足没有被任何点匹配过或者匹配它的点可以找到另外可以匹配的点，就匹配。
			{
				match[i] = x;//匹配。
				return 1;//记得要返回真。
			}
		}
	}
	return 0;//如果匹配不到，返回假。
}
int main()
{
	n = read(),m = read(),e = read();
	for(int i = 1; i <= e; i++)
	{
		int u = read(),v = read();
		a[u][v] = 1;//将u和v建一条边。
	}
	for(int i = 1; i <= n; i++)
	{
		memset(p,0,sizeof(p));
		if(dfs(i))ans++;//如果可以匹配，就匹配，答案加一。
	}
	write(ans);
	return 0;
}
```

---

## 作者：qfpjm (赞：5)

~~这题就是简单模板，为什么只有三人发题解~~

# 题意

- 题意十分简洁明了，就是求二分图最大匹配。

# 题解

- 解决二分图最大匹配的一种比较简单的算法是匈牙利算法，这里就讲一下。

### 匈牙利算法

#### 二分图

- 二分图是图论中的一种特殊模型。若能将无向图 $G=(V,E)$ 的顶点 $V$ 划分为两个交集为空的顶点集，并且任意边的两个端点都分属于两个集合，则称图 $G$ 为一个为二分图，如：

![](https://img-blog.csdnimg.cn/20200918200000653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbW9ueGlhb3hpYW8=,size_16,color_FFFFFF,t_70#pic_center)

#### 算法流程

- 我看网上的比喻比较……——所以我换一个比喻吧。

1. 有 $n$ 个小朋友，又有 $m$ 个玩具，每个小朋友都有自己喜欢的玩具，但每个小朋友只能选一件玩具，如：

```
一：2
二：1
三：1,3
```

2. 然后我们可以把其化为一张二分图，如：

![](https://img-blog.csdnimg.cn/20201028213943348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xldmlvcGt1,size_16,color_FFFFFF,t_70)

3. 我们从一号小朋友开始匹配，发现他喜欢 $2$ 号玩具，目前 $2$ 号玩具还没匹配到小朋友，就将一号小朋友和其匹配。

目前：

```
一：2
二：?
三：?
```

4. 接着我们来看二号小朋友，发现她喜欢 $1$ 号玩具，目前 $1$ 号玩具还没匹配到小朋友，就将二号小朋友和其匹配。

目前：

```
一：2
二：1
三：?
```

5. 最后是三号小朋友，~~它~~喜欢 $1$ 和 $3$ 号玩具，我们发现 $1$ 号玩具已被匹配，于是就匹配 $3$ 号玩具。

目前：

```
一：2
二：1
三：3
```

6. 可以全部匹配！所以这张二分图的最大匹配是 $3$。

- 以上方法可以通过递归实现，其它发现对象已被匹配情况都和三号的情况相似，可能就多回退几个小朋友。如果你从三号小朋友开始，那么到二号小朋友时就会递归遍历三号小朋友，然后三号小朋友重新选择 $3$ 号玩具即可继续匹配。

# 代码

- 代码十分简单。

```cpp
#include <bits/stdc++.h>

using namespace std;

int nl, nr, m, mp[1005][1005], p[100005]; // p数组录当前右侧元素所对应的左侧元素
bool vis[100005];

bool match(int i)
{
	for (int j = 1 ; j <= nr ; j ++)
	{
		if (mp[i][j] && !vis[j])
		{
			vis[j] = true;
			if (p[j] == 0 || match(p[j])) //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配
            {
                p[j] = i;    //当前左侧元素成为当前右侧元素的新匹配
                return true; //返回匹配成功
            }
		}
	}
	return false;
}

int Hungarian()
{
	int ans = 0;
	for (int i = 1 ; i <= nl ; i ++)
	{
		memset(vis, false, sizeof(vis));
		if (match(i))
		{
			ans ++;
		}
	}
	return ans;
}

int main()
{
	cin >> nl >> nr >> m;
	for (int i = 1 ; i <= m ; i ++)
	{
		int x, y;
		cin >> x >> y;
		mp[x][y] = 1;
	}
	cout << Hungarian();
	return 0;
}

```


---

## 作者：郑朝曦zzx (赞：2)

# 题目概述
这是一道**二分图最大匹配**的模板题，解法有两种，一种是匈牙利算法，一种是把问题转化为最大流问题，本题解介绍后一种方法。
# 转化思路（建图）
在网络流问题中，建图往往比打模板代码更难，建图的精髓就是**未知问题已知化**，那么本题中应该如何建图呢？

**1** 二分图左边的节点到二分图右边的节点建一条边权权一的边，右边到左边建一条边权为零的边。

**2** 从源点到到左边的节点建一条边权为一的正向边，和一条边权为零的反向边。

**3** 从右边的变到汇点建一条边权为一的变，和一条边权为零的反向边。

**样例解释：**
```cpp
2 2 3
1 1
1 2
2 1
```

![](https://cdn.luogu.com.cn/upload/image_hosting/rc2o3jzo.png)

网络最大流：我有一篇网络最大流的[题解](https://www.luogu.com.cn/blog/zhengzhaoxi/solution-b3607)，不了解最大流的同学可以看一看。

参考代码
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define maxn 1010
#define maxm 250010
using namespace std;
int n, m, F, T, cnt = 1, s = 0, t, E;
struct edge
{
	int to, next, f;
}e[maxm << 2];
int head[maxn];
int nlast[maxn];
void add_edge(int f, int t, int fl)
{
	e[++cnt] = (edge){t, head[f], fl};
	head[f] = cnt;
}
bool vis[maxn];
int dis[maxn];
bool bfs()
{
	memset(vis, 0, sizeof(vis));
	queue <int> q;
	vis[t] = 1; dis[t] = 1;
	q.push(t);
	while (!q.empty())
	{
		const int now = q.front();
		q.pop();
		for (int i = head[now]; i; i = e[i].next)
		{
			const int to = e[i].to;
			if (e[i ^ 1].f && vis[to] == 0)
			{
				vis[to] = 1;
				dis[to] = dis[now] + 1;
				q.push(to);
			}
		}
	}
	return vis[s];
}
int Dinic(int x, int f)
{
	if (x == t) return f;
	int now = f;
	for (int &i = nlast[x]; i; i = e[i].next)
	{
		const int to = e[i].to;
		if (dis[x] == dis[to] + 1 && e[i].f)
		{
			int a = Dinic(to, min(e[i].f, now));
			e[i].f -= a;
			e[i ^ 1].f += a;
			now -= a;
			if (now == 0) return f;
		}
	}
	return f - now;
}
int main()
{
	scanf("%d %d %d", &n, &m, &E);
	t = n + m + 1;
	for (int i = 1; i <= E; ++i)
	{
		scanf("%d %d", &F, &T);
		T += n;
		add_edge(F, T, 1);
		add_edge(T, F, 0);
	}
	for (int i = 1; i <= n; ++i)
	{
		add_edge(s, i, 1);
		add_edge(i, s, 0);
	}
	for (int i = 1; i <= m; ++i)
	{
		add_edge(i + n, t, 1);
		add_edge(t, i + n, 0);
	}
	int ans = 0;
	while (bfs())
	{
		for (int i = 0; i <= n + m + 1; ++i)
			nlast[i] = head[i];
		ans += Dinic(s, 1000000000);
	}
	printf("%d\n", ans);
//	for (int x = 1; x <= m; ++x)
//		for (int i = head[x]; i; i = e[i].next)
//			if (e[i].f == 0 && e[i].to >= m + 1 && e[i].to <= n)
//				printf("%d %d\n", x, e[i].to);
	return 0;
}
```


---

## 作者：eEfiuys (赞：2)

题目：[B3605](https://www.luogu.com.cn/problem/B3605)

这是一道二分图最大匹配的模板题，和 [P3386](https://www.luogu.com.cn/problem/P3386) 完全一致。使用**匈牙利算法**求解。

对于每个左部点 $u$，从与之相连的每条边出发，寻找右部点 $v$ 进行匹配。
- 没有左部点与 $v$ 匹配：
	- $u$ 直接与 $v$ 匹配。
   - 返回成功。
- 有左部点 $u1$ 与 $v$ 匹配：
	- 寻找**增广路**，寻找没有匹配的右部点 $v1$，也就是重复上面的和这个过程，可以**递归**。
		- 找到：$u1$ 与 $v1$ 匹配，$u$ 与 $v$ 匹配。
		- 找不到：返回失败，对于 $u$ 的下一条边进行此过程。

------------

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){/*快读*/}
void print(int x,char ch=0){/*快写*/}
const int N=1005;
int n,m,e,mat[N],vis[N],ans;
vector<int>g[N];
bool dfs(int u,int x){
	if(vis[u]==x)return 0; //u本来就已经因为x而寻找过增广路，不用再找了，防止死循环。
	vis[u]=x; //标记u因为x而寻找增广路。
	for(int i=0;i<g[u].size();i++){ //寻找每一条边
		int v=g[u][i];
		if(!mat[v]||dfs(mat[v],x)){ //v没有被匹配，或是找到增广路
			mat[v]=u; //u与v匹配
			return 1; //匹配或寻找增广路成功
		}
	}
	return 0; //最终失配或找不到增广路
}
signed main(){
	n=read(),m=read(),e=read();
	for(int i=1;i<=e;i++){
		int u=read(),v=read();
		g[u].push_back(v); //邻接表存图
	}
	for(int i=1;i<=n;i++)ans+=dfs(i,i); //匹配到就多一组
	print(ans,'\n');
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 二分图
首先来了解一下二分图是什么。

简而言之，就是顶点集 $V$ 可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。

## 思路
求二分图最大匹配可以用最大流或者匈牙利算法。
1. 从任意一个未被匹配的点 $u$ 开始，从点 $u$ 的变种选一条边配对。若点  $v$ 没有被匹配，则成功。
2. 从点 $u$ 的各边中再选择一条，知道成功或所有边都尝试过。
3. 继续一一配对。
4. 输出。

上代码(模板)
```cpp
#include<bits/stdc++.h>
using namespace std;
int e[101][101];
int match[101];
int book[101],m,n;
int dfs(int u)
{
    for(int i=1;i<=n;i++)
    {
        if(book[i]==0&&e[u][i])
        {
            book[i]=1;//点i已访问
            if(match[i]==0||dfs(match[i]))//点i未被配对或者找到了新的配对
            {
                match[i]=u;//更新配对关系
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    int i,j,t1,t2,sum=0;
    cin>>n>>m;
    for(i=1;i<=m;i++)//读入边
    {
        cin>>t1>>t2;
        e[t1][t2]=1;
    }
    for(i=1;i<=n;i++)
    {
        match[i]=0;
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            book[j]=0;//清空上次搜索时的标记
        }
        if(dfs(i))sum++;//寻找增广路，若找到，配对数加一
    }
    cout<<sum;
    return 0;
}
```



---

## 作者：Tenshi (赞：1)

众所周知，二分图的最大匹配可以用网络流来解，而且复杂度比匈牙利算法要优秀。

## 分析
建立虚拟源点 $S$，虚拟汇点 $T$，分别编号为 $0$,$n_1+n_2+1$。（只要是不重复的编号就行）
然后左半部的点连接虚拟源点 $S$，右半部的点连接虚拟汇点 $T$，容量都是 $1$。
再根据题意在左右部的点之间连容量为 $1$ 的边，图就建好了，最后我们在这张图跑一遍最大流即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int INF=0x3f3f3f3f;
const int N=1010;

struct node{
    int to, next, c;
}e[N*N+N<<1];

int h[N], tot;
void add(int u, int v, int cap){
    e[tot].to=v, e[tot].c=cap, e[tot].next=h[u], h[u]=tot++;
    e[tot].to=u, e[tot].c=0, e[tot].next=h[v], h[v]=tot++;
}

int S, T;

int q[N], d[N], cur[N];
bool bfs(){
    memset(d, -1, sizeof d);
    int tt=-1, hh=0;
    q[++tt]=S;
    d[S]=0, cur[S]=h[S];
    
    while(tt>=hh){
        int hd=q[hh++];
        for(int i=h[hd]; ~i; i=e[i].next){
            int go=e[i].to;
            if(d[go]==-1 && e[i].c){
                d[go]=d[hd]+1;
                cur[go]=h[go];
                if(go==T) return true;
                q[++tt]=go;
            }
        }
    }
    return false;
}

int find(int u, int limit){
    if(u==T) return limit;
    int flow=0;
    for(int i=cur[u]; ~i && limit>flow; i=e[i].next){
        int go=e[i].to;
        cur[u]=i;
        if(d[go]==d[u]+1 && e[i].c){
            int t=find(go, min(e[i].c, limit-flow));
            if(!t) d[go]=-1;
            flow+=t, e[i].c-=t, e[i^1].c+=t;
        }
    }
    return flow;
}

int dinic(){
    int res=0, flow;
    while(bfs()) while(flow=find(S, INF)) res+=flow;
    return res;
}
int main(){
    memset(h, -1, sizeof h);
    int n1, n2, m; cin>>n1>>n2>>m;
    S=0, T=n1+n2+1;
    
    while(m--){
        int u, v; cin>>u>>v;
        v+=n1;
        add(u, v, 1);
    }
    
    for(int i=1; i<=n1; i++) add(S, i, 1);
    for(int i=1; i<=n2; i++) add(i+n1, T, 1);
    
    cout<<dinic()<<endl;
    
    return 0;
}
```

---


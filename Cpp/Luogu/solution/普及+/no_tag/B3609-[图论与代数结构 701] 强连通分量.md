# [图论与代数结构 701] 强连通分量

## 题目描述

给定一张 $n$ 个点 $m$ 条边的有向图，求出其所有的强连通分量。

**注意，本题可能存在重边和自环。**

## 说明/提示

对于所有数据，$1 \le n \le 10000$，$1 \le m \le 100000$。

## 样例 #1

### 输入

```
6 8
1 2
1 5
2 6
5 6
6 1
5 3
6 4
3 4
```

### 输出

```
3
1 2 5 6
3
4
```

# 题解

## 作者：Daidly (赞：176)

### 定义

- `cnt`：当前有几个强连通分量。

- `belong[MAXN]`：$i$ 个点属于第几个强连通分量。

- `s[MAXN]`：手写栈。

- `len`：栈里面有几个点。

- `dfn[MAXN]`：$i$ 点是第几个被 `dfs` 到的。

- `low[MAXN]`：从 $i$ 出发可以走任意边，但走的最后一条边必须是回边的情况下，能够达到的所有点中 `dfn` 值最小的是多少。

- `tot`：当前 `dfs` 点数。

- `instack[MAXN]`：第 $i$ 个点在不在栈里面。

回边：从某个结点指向其某个祖先的边叫做回边。

横叉边：从某个结点指向树中的另一子树中的某结点的边。

一个环必定是由一个树连一些边变成的。

树边：在这棵树上的边。

非树边：即为回边或横插边。

考虑在图中的一个树上结合其他非树边构成一个强连通分量。

### 算法 Tarjan

结合代码讲解，建议看一步讲解，一步代码：

前部分代码：

```cpp
void dfs(int x){
	dfn[x]=low[x]=++tot;
	s[++len]=x;
	instack[x]=1;
    for(int i=head[x];i;i=e[i].next){
    	int y=e[i].to;
    	if(!dfn[y]){
    		dfs(y);
    		low[x]=min(low[x],low[y]);
		}else{
		    if(instack[y])low[x]=min(low[x],low[y]);
		}
	}
	...... 
	......
	...... 
}
```

从 $1$ 开始 `dfs`，把遍历到的节点加入栈中。

初始化：$1$ 是第一个 `dfs` 到的，从 $1$ 出发可以走任意边，能够达到的所有点中 `dfn` 值最小的是 $1$，$1$ 入栈，标记为栈中。

遍历 $1$ 的所有连边，找到连点，如果连点。

- 若 $y$ 还没有被遍历过，遍历连点，然后更新 `low` 值。

- 若 $y$ 已被遍历过，并且在栈中，由于 $x$ 也在栈中，并且根据 `low` 的特殊定义，那么可以通过回边回到 $x$，所以 $y$ 可以用来更新 $x$。

- 若 $y$ 已被遍历过，并且不在栈中，说明更新完毕，不能用来更新当前点，跳过。

由于 $y$ 是 $x$ 的连点，所有 $y$ 能走到的 $x$ 也能走到，用 $y$ 的 `low` 更新 $x$ 的 `low`。

进栈和更新处理过了，开始处理出栈。

- 发现一个性质：如果点 $i$ 的 `dfn` 值和 `low` 值一样，那么说明从 $i$ 出发可以走任意边，但走的最后一条边必须是回边的情况下，能够达到的所有点中 `dfn` 值最小就是他自己。

- 换句话说，点 $i$ 是这个强连通分量最上面的点，因为无法达到 `dfn` 值比它自己更小的点了。

- 该结点在遍历的过程中，为这个强连通分量中第一个被访问的结点，因为它的 `dfn` 值和 `low` 值比其他的点都小，不会被该连通分量中的其他结点所影响。

后部分代码：

```cpp
void dfs(int x){
	......
	......
	......
	if(dfn[x]==low[x]){
	    cnt++;
	    ans[cnt].push_back(x);
	    while(s[len]!=x){
	    	belong[s[len]]=cnt;
	    	instack[s[len]]=0;
	    	ans[cnt].push_back(s[len]);
	    	len--;
		}
		len--;
		instack[x]=0;
		belong[x]=cnt;
	} 
}
```

若 $dfn_i=low_i$：

将强连通分量数加一，因为有一个强连通分量的“头头”来了，然后记录这个连通块。

Q：为什么遍历到这一个强连通分量的“头头”，也就是第一个点，就要出栈之类的，不应该继续往下遍历吗？

A：那你就理解错了，部分的操作进行是从下往上的，发现前部分代码有一个 `dfs(y)`，就说明这一过程是从下往上回溯的，其实 $x$ 早已在栈中了。

- 不明白的同学可以看看前面的代码。

进行记录操作即可。

### 关于本题

对于每一个点，若没有遍历过，则跑一遍 `dfs`。

题目还要求要排序输出，可以用一个动态数组存答案排序输出。


### 代码

为了大家更好地理解各个变量，我将变量定义在代码中列成了一列。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=10005;
const int MAXM=100005;
struct node{
	int to,next;
}e[MAXM<<1];
int head[MAXN],num;
bool instack[MAXN];
int s[MAXN],len;
int low[MAXN];
int cnt;
int belong[MAXN];
int n,m;
int f[MAXN];
vector<int>ans[MAXN];
void add(int u,int v){
    e[++num].to=v;
    e[num].next=head[u];
    head[u]=num;
}
int dfn[MAXN],tot;
void dfs(int x){
	dfn[x]=low[x]=++tot;
	s[++len]=x;
	instack[x]=1;
    for(int i=head[x];i;i=e[i].next){
    	int y=e[i].to;
    	if(!dfn[y]){
    		dfs(y);
    		low[x]=min(low[x],low[y]);
		}else{
		    if(instack[y])low[x]=min(low[x],low[y]);
		}
	}
	if(dfn[x]==low[x]){
	    cnt++;
	    ans[cnt].push_back(x);
	    while(s[len]!=x){
	    	belong[s[len]]=cnt;
	    	instack[s[len]]=0;
	    	ans[cnt].push_back(s[len]);
	    	len--;
		}
		len--;
		instack[x]=0;
		belong[x]=cnt;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int u,v;
		cin>>u>>v;
		add(u,v);
	}
	for(int i=1;i<=n;++i){
		if(!dfn[i])dfs(i);
	}
	cout<<cnt<<endl;
	for(int i=1;i<=cnt;++i){
		sort(ans[i].begin(),ans[i].end());
	}
	for(int i=1;i<=n;++i){
		if(f[belong[i]])continue;
		f[belong[i]]=1;
		for(int j=0;j<ans[belong[i]].size();++j){
			cout<<ans[belong[i]][j]<<" ";
		}cout<<endl;
	}
	return 0;
}
```

如果你觉得这篇题解讲得还算好的话，可以点个赞支持一下呀，谢谢大家！

---

## 作者：KEBrantily (赞：26)

我来抢第一个啦！

以下内容部分摘自[我的博客](https://www.cnblogs.com/KnightL/p/14351657.html)。

本题要求求出全图中的强连通分量个数，并要维护其中的每个点。

## 定义一

什么叫强连通分量？

强连通分量的定义是：极大的强连通子图。又叫 SCC。

简单来说，在一个有向图中，若所有点之间两两互相直接可达，则将这个图成为强连通分量。

求一个图中的强连通分量可以使用 Tarjan，Kosaraju 或者 Garbow 算法。

这里使用 Tarjan 求解。

## 定义二

什么叫 dfs 序？

dfs 序是指深度优先搜索遍历时改结点被搜索的次序。

下文中，我们称点 $i$ 的 dfs 序为 $d_i$。

另外，我们还需要另一个变量 $l_i$，我们称其为 low 值。

$l_i$ 表示以下节点的 dfs 序的最小值：**以 $i$ 为根的子树中的结点**和**从该子树通过一条不在搜索树上的边能到达的结点**。



## 原理

找强连通分量，首先要在图中缩点。

缩点，简单说就是把一个图中所有的强连通分量缩成一个点，使之形成一个 DAG。

缩完点后的图中每个点会有一个新的编号，同处一个强连通分量中的点编号相同。

根据 dfs 的遍历原理可以发现：

- 一个结点的子树内结点的 dfs 序都大于该结点的 dfs 序；

- 从根开始的一条路径上的 dfs 序严格递增，low 值严格非降。

接下来看一下怎么找强连通分量。

主要分为两个部分：处理和归类。

处理是指处理每个节点 $i$ 的 $l_i$ 与 $d_i$，归类则是处理每个节点所属的强连通分量编号、大小等信息。

### 第一部分

我们先处理 $l_i$ 与 $d_i$。

我们需要用到一个栈，把每个处理过的元素放到栈中。

这么做是因为同一个强连通分量中的点肯定是连续被处理的，并且根据 dfs 的回溯等原理，使得先处理的要后操作。在第二部分的归类中也可以避免很多麻烦操作。

假设我们现在已经处理完了点 $u$，$u$ 指向 $v$。

然后分三种情况：

1. $v$ 未被处理

处理它！dfs 它！处理完后，用 $l_v$ 尝试更新 $l_u$。

因为存在从 $u$ 到 $v$ 的直接路径，所以 $v$ 能够回溯到的已经在栈中的结点， $u$ 也一定能够回溯到。

2. $v$ 已被处理且在栈中

即 $v$ 已经被访问过，根据 low 值的定义（能够回溯到的最早的已经在栈中的结点），则用 $d_v$ 更新 $l_u$ 。

3. $v$ 已被处理且不在栈中

$v$ 及其所在分量已经处理完毕，不管它。

```cpp
low[fr]=dfn[fr]=++cnt;vis[fr]=1;
for(int i=head[fr];i;i=e[i].nxt){
  int to=e[i].to;
  if(!dfn[to]) tarjan(to),low[fr]=min(low[fr],low[to]);
  else if(vis[to]) low[fr]=min(low[fr],dfn[to]);
}
```

### 第二部分

对于一个连通分量图，我们很容易想到，在该连通图中有且仅有一个点 $i$ 的 $d_i=l_i$。

该结点一定是在深度遍历的过程中，该连通分量中第一个被访问过的结点，因为它的 dfs 序和 low 值最小，不会被该连通分量中的其他结点所影响。

在回溯的过程中，判定 $d_i=l_i$ 的条件是否成立，如果成立，则从栈中取出一个点，处理它所在的强连通分量的编号以及大小，也可以处理其他的一些操作，这样直到把所有点处理完为止。

```cpp
zhan[++top]=u;
if(dfn[u]==low[u]){
  ++t;
  int pre=zhan[top--];
  vis[pre]=0;
  ...//相应操作
  while(pre!=u){
    pre=zhan[top--]; 
    vis[pre]=0;
    ...//相应操作
  }
}
```

至此，便可以处理出一个点所在的强连通分量，时间复杂度为 $\Theta(n+m)$。

## 别的

回到本题。

按上面所述，处理出图中所有的强联通分量。

对于每个强连通分量，我们使用 `vector` 存储其中的节点，并从小到大排序。

最后按题目要求输出就好了。

```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 10010
#define INF 0x3f3f3f3f
//#define int long long

using namespace std;

bool vis[maxn],flag[maxn];
int n,m,tot,top,cnt,t;
int head[maxn],num[maxn];
int zhan[maxn],dfn[maxn],low[maxn];
struct edge{int fr,to,nxt;}e[maxn*10];
vector<int> v[maxn];

int read(){
  int s=0,w=1;char ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
  while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
  return s*w;
}

void add(int fr,int to){
  e[++tot]=(edge){fr,to,head[fr]};
  head[fr]=tot;
}

void tarjan(int u){
  dfn[u]=low[u]=++cnt;
  zhan[++top]=u;vis[u]=1;
  for(int i=head[u];i;i=e[i].nxt){
    int to=e[i].to;
    if(!dfn[to]) tarjan(to),low[u]=min(low[u],low[to]);
    else if(vis[to]) low[u]=min(low[u],dfn[to]);
  }
  if(dfn[u]==low[u]){
    ++t;
    int pre=zhan[top--];
    num[pre]=t;vis[pre]=0;
    v[t].push_back(pre);
    while(pre!=u){
      pre=zhan[top--];
      num[pre]=t;vis[pre]=0;
      v[t].push_back(pre);
    }
  }
}

int main(){
  n=read();m=read();
  for(int i=1,fr,to;i<=m;i++)
    fr=read(),to=read(),add(fr,to);
  for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
  printf("%d\n",t);
  for(int i=1,pos;i<=n;i++){
    pos=num[i];
    if(flag[pos]) continue;flag[pos]=1;
    sort(v[pos].begin(),v[pos].end());
    for(int j=0;j<v[pos].size();j++) 
      printf("%d ",v[pos][j]);puts("");
  }
  return 0;
}
```

---

## 作者：Fido_Puppy (赞：18)

## Solution

求强连通分量最常用的就是 Tarjan 了。

Tarjan 的用途很广，可是对像本蒟蒻这种来说不太友好。

于是，我来推荐一个求强连通分量简单易懂的算法——Kosaraju。

Kosaraju 是神马？

首先，我们在原图中跑一遍 dfs。

我们可以发现每一个点都有一个开始搜索的时间和一个完成搜索的时间。

我们对于完成搜索的时间考虑从小到大加入到栈中。

这样从栈顶到栈底节点的完成搜索的时间是从大到小排的。

接下来我们在逆图（逆图就是把原图中的每一条边的方向反过来）中 dfs 时开始搜索的节点的顺序就是从栈顶到栈底。

为什么呢？其实完成时间最大的点，它就肯定时一个强连通分量中的第一个点。当出现大的强连通分量套一个小的强连通分量时，这样可以避免只把小的强连通分量给求出来。

接着在逆图中 dfs，能搜到的节点就是一个强连通分量（正着能搜到，反着也能搜到，肯定是一个强连通分量里的）。

还有一些细节的问题戳这 [传送门](https://www.cnblogs.com/shadowland/p/5876307.html)。

思路也是很简单的，就是求完强连通分量之再排个序就行了，因为题目说要从小到大输出。

然后呢？然后就没有然后了。

## Code

~~我知道你们最期待这个（逃~~

```cpp
    // ┏┛ ┻━━━━━┛ ┻┓  
    // ┃　　　　　　┃  
    // ┃　　　━　　　      ┃  
    // ┃　┳┛　  ┗┳　    ┃  
    // ┃　　　　　　       ┃  
    // ┃　　　┻　　　    ┃  
    // ┃　　　　　　      ┃  
    // ┗━┓　　　┏━━━┛  
      // ┃　　　┃   神兽保佑  
      // ┃　　　┃   代码无BUG！  
      // ┃　　　┗━━━━━━━━━┓  
      // ┃　　　　　　　    ┣┓  
      // ┃　　　　         ┏┛  
      // ┗━┓ ┓ ┏━━━┳ ┓ ┏━┛  
          // ┃ ┫ ┫   ┃ ┫ ┫  
          // ┗━┻━┛   ┗━┻━┛
#include"iostream"
#include"vector"
#include"algorithm"
#include"stack"
#include"memory.h"
using namespace std;
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)
#define N (int)(1e5+10)
vector<int>g1[N],g2[N];
vector<int>col[N];
int color[N],n,m,k=0;
stack<int>s;
bool vis[N];
inline void dfs1(int u) {
	vis[u]=false;
	for(int i=0;i<g1[u].size();i++) {
		int v=g1[u][i];
		if (vis[v]) dfs1(v);
	}
	s.push(u);
}
inline void dfs2(int u) {
	col[k].push_back(u); color[u]=k; vis[u]=false;
	for(int i=0;i<g2[u].size();i++) {
		int v=g2[u][i];
		if (vis[v]) dfs2(v);
	}
}
signed main() {
	IOS;
	cin>>n>>m;
	for(int i=1;i<=m;i++) {
		int x,y; cin>>x>>y;
		g1[x].push_back(y);
		g2[y].push_back(x);
	}
	memset(vis,true,sizeof(vis));
	for(int i=1;i<=n;i++) if (vis[i]) dfs1(i);
	memset(vis,true,sizeof(vis));
	while (!s.empty()) {
		int t=s.top(); s.pop();
		if (vis[t]) {
			++k; dfs2(t);
		}
	}
	for(int i=1;i<=k;i++) sort(col[i].begin(),col[i].end());
	cout<<k<<endl;
	memset(vis,true,sizeof(vis));
	for(int i=1;i<=n;i++)
		if (vis[color[i]]) {
			for(int j=0;j<col[color[i]].size();j++) cout<<col[color[i]][j]<<" ";
			cout<<endl;
			vis[color[i]]=false;
		}
	return 0;
}
```

完结撒花！ ^.^

---

## 作者：红尘仙 (赞：8)

### 前序 

---

恰好我发现我的博客强连通分量整理简直不是人看的，顺便整理了，结果发现洛谷越来越进步了，有这个板子题了。

不过第一遍挂了，没看顺序，因为是强连通分量嘛，你就直接给他排个序就过了。

### Solution 

是强连通分量的板子题。

无良商家推销博客 [【强连通分量】](https://www.cnblogs.com/Zmonarch/p/14355412.html)

我们就直接说一下强连通分量。

在求解强连通分量的时候，我们定义 $low_u$ , $dfn_u$ 这两个数组。

#### 我们先给定一些定义 ： 
$dfn_u$ 表示深度优先搜索遍历时结点 $u$ 被搜索的次序。

$low_u$ ： 设以 u 为根的子树为 sub(u) , $low_u$ 定义为以下节点的 dfn 最小值 ： sub(u) 中的所有节点，从 sub(u) 通过一条不在搜索树上的边能够到达的所有点。
 
$in_x$ 表示的$x$这一个节点隶属于哪一个连通块（也就是强连通分量）

stack 表示还没有划分成连通块的节点

scc 表示的联通块的大小

cnt 就表示总共有多少个联通块




#### Tarjan 求解。

然后结合一下图来说明： 从博客里拉出来的。

![](https://cdn.luogu.com.cn/upload/image_hosting/g49z84kq.png)

很显然，通过上帝视角，我们发现，其中的强连通分量是（我们用集合来表示一下） 
$(1 \to 2 \to5) ,(4\to 6 \to 7) , 3$这三个连通分量， 同样的，我们来手动模拟一下 Tarjan 算法的这个过程

首先，我们是进行了 DFS ，搜索（为了简述方便，我们规定这一个搜索的顺序是从左到右的） ，就可以得到这么一个手动模拟的过程

![](https://cdn.luogu.com.cn/upload/image_hosting/lplwra0j.png)
之后我们发现，再次从 7 这一个点，出发的时候，我们找到 4 这一个点，同时，也是在存储的时候我们也发现 4 这一个点已经在 stack 中了，所以我们也很容易理解，从$4 \to 7$这一个过程经历的必然是一个强连通分量（或者说，是一个环），相应的，很好理解， 如果我们不用 low 记录一下这个最小值，我们根本不知道这一个环是从什么时候开始的，所以 low 的重要性，也就可以体现了，我们找完了一个$(4 \to 6 \to 7)$这一个环

![](https://cdn.luogu.com.cn/upload/image_hosting/5pfqxjdg.png)

这里写一个代码，更深刻的理解一下，当找到一个环的时候，也就是我们的这个 low 的最小值和下一次搜索出来的是一样的时候，我们把栈中 low 之后的全部弹出去，就记录了$scc_i$（第 i 个连通分量的大小了） ，当然当求解 3 这一个连通分量也是一样的道理。

---

继续看一下求解$(1 \to 2 \to 5)$这一个连通分量
我们划去已经匹配了的节点，此时的 stack : 1 , 2 还是给图吧
![](https://cdn.luogu.com.cn/upload/image_hosting/8xvwsqbv.png)
我们继续寻找，略过找到 5 这个节点，我们还是发现，又回到原点了， 同上述的$(4 \to 6 \to 7)$这一个环，就行了。


#### 具体处理

我们已经处理完了 u, 将要处理 u 指向的点 v 

+ 当 v 没有被访问过，那么我们就继续 dfs , 令 $low_u$成为其连接的直接路径的 dfn 中最小的。

+ 当 v 被访问过了，但是还在栈中，那么我们就用 $dfn_v$ 来更新 $low_u$ , 使其成为 sub(u) 中最小的 。

+ 当 v 被访问过了，也不在栈中，那么我们就直接不用管了，它已经处理完了。


**最后处理强连通分量的时候，已经在上述图中给出了，就不再赘述了**



### Code

```
//
/*
Author : Zmonarch
Knowledge :
*/
#include <bits/stdc++.h>
#define inf 2147483647
#define qwq register
#define qaq inline
#define int long long
using namespace std ;
const int kmaxn = 1e6 + 10 ;
qaq int read() {
	int x = 0 , f = 1 ; char ch = getchar() ;
	while(!isdigit(ch)) {if(ch == '-') f = - 1 ; ch = getchar() ;}
	while( isdigit(ch)) {x = x * 10 + ch - '0' ; ch = getchar() ;}
	return x * f ;
}
struct node {
	int nxt , u , v ; 
}e[kmaxn << 1];
int n , m , cnt , top , tot , sum ; 
int h[kmaxn] , dfn[kmaxn] , low[kmaxn] , sta[kmaxn] , scc[kmaxn] , in[kmaxn]; 
bool f[kmaxn] ; 
vector<int> sc[kmaxn] ; 
qaq void add(int u , int v) {
	e[++tot].nxt = h[u] ; 
	e[tot].u = u ; e[tot].v = v ; 
	h[u] = tot ; 
}
qaq void Tarjan(int u) {
	dfn[u] = low[u] = ++ cnt ; 
	sta[++top] = u ; 
	for(qwq int i = h[u] ; i ; i = e[i].nxt) 
	{
		int v = e[i].v ; 
		if(!dfn[v]) {Tarjan(v) ; low[u] = min(low[u] , low[v]) ;}
		else if(!in[v])low[u] = min(low[u] , dfn[v]) ; 
	}
	if(low[u] == dfn[u]) 
	{
		in[u] = ++ sum ; ++ scc[sum] ; sc[sum].push_back(u) ; 
		while(sta[top] != u) 
		{
			++scc[sum] ; 
			in[sta[top]] = sum ;  
			sc[sum].push_back(sta[top]) ; 
			top-- ;
		}
		top-- ; 
	}
}
signed main() {
	n = read() , m = read() ; 
	for(qwq int i = 1 ; i <= m ; i++) 
	{
		int u = read() , v = read() ; 
		add(u , v) ; 
	}
	for(qwq int i = 1 ; i <= n ; i++) 
	 if(!dfn[i]) Tarjan(i) ; 
	printf("%lld\n" , sum) ; 
	for(qwq int i = 1 ; i <= sum ; i++) 
	sort(sc[i].begin() , sc[i].end()) ; 
	for(qwq int i = 1 ; i <= n ; i++) 
	{
		if(f[in[i]]) continue ; f[in[i]] = true ; 
		for(qwq int j = 0 ; j < sc[in[i]].size() ; j++) 
		 printf("%lld " , sc[in[i]][j]) ; 
		printf("\n") ; 
	}
	return 0 ;
}


```

---

## 作者：pldzy (赞：6)

### 一道强连通分量的板子题


------------

[更好阅读体验请点击此链接](https://469672.blog.luogu.org/solution-b3609)

先推荐几道综合性较强的题目，详细题解我写了，持续更新中。

[我的博客：整理 + 题解](https://469672.blog.luogu.org/qiang-lian-tong-fen-liang-jiao-nuo-li-ti-zheng-li)

[P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G](https://www.luogu.com.cn/problem/P2341)

[P2272 [ZJOI2007]最大半连通子图](https://www.luogu.com.cn/problem/P2272)


------------
 强连通分量（ strongly connected components ），可以理解为**存在一条回路使得初始点又能回到初始点。**
 
 有两种算法， 这里分享的是 Tarjan （我用前向星存图）。
 

------------

 
####  1. 基本概念：

 Tarjan 基于对图深搜的算法，每个强连通分量为搜索树中的一棵子树。 _搜索时把没处理的结点加入一个栈，回溯时判断当前结点能否与栈中结点构成一个强连通分量。_ （我用数组模拟的栈。）
 
 而我们要做的就是分别找到一条条回路，使得初始点又回到初始点（**对于该有向子图，任意两点 $G_u,_v$ 有一条从 u 到 v 的路径，亦有一条从 v 到 u 的路径**）。
 
 后面附了图，可以结合示例理解。
 
 
####  2. 数组、栈：

板子一般开两个数组以及一个栈， dfn 数组， low 数组， st 栈。

##### 定义如下：

- dfn 数组：定义 $dfn_u$ 为结点 u 的搜索次序编号（时间戳）；

- low 数组：定义 $low_u$ 表示结点 u 或者 u 的子树最多能够回溯（到达）到的结点 x ， 使得 $dfn_u$ 最小；
 
- st 栈：每找到一个点就把它压入栈中，这是为了之后找一个强连通分量里所有的子节点。

##### 用法、作用如下：

- dfn 数组：记录时间戳（编号）；

- low 数组：**当一个点最多能回溯（到达）到的点还是自己时，说明这条路径已经成环**，根据前面说过的两条定义，这个点以及路径上的节点形成了一个强连通分量。 

	同时，我们在找强连通分量的过程中，也要不断地用它能到达的节点的  dfn 值去松弛它自己的 dfn 值；

- st 栈：当我们从点 u 走完了所有可以到达的点后 ，满足 $low_u=dfn_u$ 时，我们将栈中的点逐一弹出，解释如下：

	我们在第一次找到点 u 时，已经将它入栈了。且我们在经过了若干节点并将它们按先后顺序并分别入栈后，发现从 u 和若干节点成一个强连通分量了。
    
    这时候我们想找到这个强连通分量内所有的节点，我们要怎么做？
    
    逐一从栈中弹出。从栈顶到栈中的 u ，都是我们要的当前强连通分量内的节点（从 u 开始我们都把它们压入栈中了），所以，我们只需要一直把栈顶从栈中弹出，直到弹出点 u 。

#### 3. 算法主要过程：

概述： _通过深度优先搜索和入栈出栈的操作来找到一条回路，使回路初始点又能回到初始点。_ 

1. 记录 $dfn_u$ 以及 $low_u$ ；

2. 将 u 入栈；

3. 前向星（ vector 当然也可以）枚举每一条边，更新 $low_u$ ：

- 如果结点 v （枚举到的点）没有被访问过：访问v，如果 $low_v$ 小于 $low_u$ ，就用前者更新后者；

- 如果结点 v 仍在栈内即 v 还不属于仍何强连通分量，并用 $dfn_v$ 来刷新 $low_u$ （在前者小于后者的情况下）。

4. 如果形成了一条回路，即边弹出栈边统计当前节点的强连通分量编号即可，直到弹出了 u ，此时被弹出的所有节点，就形成了一个强连通分量。

#### 4. 画图示例：

![示例](https://cdn.luogu.com.cn/upload/image_hosting/zou784id.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图所示，在经过如上所说的操作后，一幅图可以被分成若干强连通分量。

示例中就被分成了 3 个强连通分量，可结合强连通分量的定义理解。


------------


以上就是 Tarjan 算法，还是不明白可以见代码或私信问我。

此题其他的操作并不难，这里也不多阐述了。


------------


### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int maxn = 100005;
int n, m;
int cnt, hd[maxn];
struct node{
	int to, nxt;
}e[maxn * 2]; 
int dfn[maxn], low[maxn];
int tmp, top;
int st[maxn];
int co[maxn], col;

void add (int u, int v)
{
	e[++cnt].to = v;
	e[cnt].nxt = hd[u];
	hd[u] = cnt;
}

void tarjan (int u)
{
	dfn[u] = low[u] = ++tmp;//step 1
	st[++top] = u;//step 2
	for (int i = hd[u]; i; i = e[i].nxt)//step 3
	{
		int v = e[i].to;
		if (!dfn[v])//如果没有被访问过
		{
			tarjan (v);
			low[u] = min (low[u], low[v]);
		}
		else if (!co[v]) //如果它还不在一个强连通分量内
        low[u] = min (low[u], dfn[v]);
		
	}
	if (low[u] == dfn[u])//step 4
	{
		co[u] = ++col;
		while (st[top] != u)//弹栈操作
		{
			co[st[top]] = col;
			--top;
		} 
		--top;//最后记得把 u 也弹出去
	}
}

int vis[maxn];

signed main ()
{
	scanf ("%lld %lld", &n, &m);
	for	(int i = 1; i <= m; i++)
	{
		int u, v;
		scanf ("%lld %lld", &u, &v);
		add (u, v);
	}
	for (int i = 1; i <= n; i++)
	{
		if (!dfn[i]) tarjan (i);
	}
	printf ("%lld\n", col);
	for (int i = 1; i <= n; i++)
	{
		if (vis[i]) continue;
		printf ("%lld ", i);
		vis[i] = 1;
		for (int j = i + 1; j <= n; j++)
		{
			if (co[j] == co[i])
			{
				printf ("%lld ", j);
				vis[j] = 1;
			}
		}
		printf ("\n");
	}
	return 0;
}
```




------------


辛苦管理员看啦，如有排版格式错误麻烦帮我指出来，谢谢。

大佬们如果看到错误请帮我指出，可以私信我，谢谢。

---

## 作者：mango09 (赞：4)

**[B3609 [图论与代数结构 701] 强连通分量](https://www.luogu.com.cn/problem/B3609)**

**一些概念**：
1. 若一张有向图中任意两个节点 $x,y$，存在 $x$ 到 $y$ 的路径和 $y$ 到 $x$ 的路径，则称其为**强连通图**；
2. 有向图的**极大强连通子图**被称为**强连通分量**。

在上文中，一个强连通子图 $G'=(V',E')(V\subseteq V,E'\subseteq E)$ 极大，当且仅当不存在包含 $G'$ 的更大子图 $G''=(V'',E'')$ 满足 $V'\subseteq V''\subseteq V,E'\subseteq E''\subseteq E$。显然，**一个环一定是强连通图**，所以我们的思路就是找到能和某个点构成环的所有点。

正如本文的 URL，强连通分量简记为 $\text{SCC(Strongly Connected Component)}$。

求 $\text{SCC}$ 可以用 Tarjan，Kosaraju 或者 Garbow 算法，本文使用 Tarjan 算法。

**定义**：
- ($\operatorname{int}$)$Time$：当前时间戳；
- ($\operatorname{int}$)$tot$：$\text{SCC}$ 的个数；
- ($\operatorname{int}$)$dfn(u)$：点 $u$ 的 dfs 序；
- ($\operatorname{int}$)$low(u)$：以下节点的 $dfn$ 的最小值：$v\in subtree(u)$（$u$ 的子树） 及从 $v$ 出发通过一条不在搜索树上的边（非树边）能到达的节点；
- ($\operatorname{int}$)$c(u)$：记录点 $u$ 所在的 $\text{SCC}$；
- ($\operatorname{stack}$<$\operatorname{int}$>)$sta$：一个栈；
- ($\operatorname{bool}$)$ins(u)$：点 $u$ 是否在 $sta$ 中；
- ($\operatorname{vector}$<$\operatorname{int}$>)$scc(i)$：记录编号为 $i$ 的 $\text{SCC}$ 内的所有节点。

Tarjan 算法使用 dfs 实现：
1. 记录 $dfn,low$；
2. 当前节点进栈；
3. 更新 $low$：
	1. $dfn(v)=0$：说明 $v$ 是 $u$ 的直系儿子，$v$ 能到的 $u$ 都能到，先往下递归，再直接用 $low(v)$ 来更新 $low(u)$；
   2. $ins(v)=true$：说明 $v$ 是 $u$ 的祖先且 $u$ 可以通过一条非树边到达 $v$，根据定义可以用 $dfn(v)$ 来更新 $low(u)$。
4. 更新后，如果 $dfn(u)=low(u)$，说明从 $u$ 出发最终又能回到 $u$，即构成了环，是一个满足要求的 $\text{SCC}$。将 $tot\gets tot+1$，同时不停地弹栈直到弹到 $u$，则弹出的所有节点都在 $subtree(u)$ 内；记录其在第 $tot$ 个 $\text{SCC}$ 内；最后将其加入 $scc(tot)$ 中。

对于题目的特殊要求要求：

> 第一行输出 $1$ 号点所在强连通分量，第二行输出 $2$ 号点所在强连通分量，若已被输出，则改为输出 $3$ 号点所在强连通分量，以此类推。

开一个 ($\operatorname{bool}$)$vis$ 数组记录每个 $\text{SCC}$ 是否已经输出过即可。

> 每个强连通分量按节点编号大小输出

$\operatorname{sort}$ 一遍即可。

------------

$\text{Code}$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <vector>
#define re register
using namespace std;

inline int read()
{
	re int x = 0, f = 0;
	re char c = getchar();
	while (c < '0' || c > '9')
	{
		f |= c == '-';
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = (x << 3) + (x << 1) + (c ^ '0');
		c = getchar();
	}
	return f ? -x : x;
}

inline void write(int x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
	{
		write(x / 10);
	}
	putchar(x % 10 ^ '0');
}

inline int min2(int x, int y)
{
	return x < y ? x : y;
}
//-----------------------------------------------------------
const int MAXN = 1e4 + 5;
const int MAXM = 1e5 + 5;

int cnt, Time, tot;
int head[MAXN], dfn[MAXN], low[MAXN], c[MAXN];
bool ins[MAXN], vis[MAXN];
stack<int> sta;
vector<int> scc[MAXN];

struct edge
{
	int to, nxt;
}e[MAXM];

void add(int u, int v)
{
	e[++cnt] = edge{v, head[u]};
	head[u] = cnt;
}

void tarjan(int u)
{
	dfn[u] = low[u] = ++Time; //初始化
	sta.push(u); //进栈
	ins[u] = true; //标记
	for (re int i = head[u]; i; i = e[i].nxt)
	{
		int v = e[i].to; //更新
		if (!dfn[v])
		{
			tarjan(v);
			low[u] = min2(low[u], low[v]);
		}
		else if (ins[v])
		{
			low[u] = min2(low[u], dfn[v]);
		}
	}
	if (dfn[u] == low[u]) //构成了环
	{
		tot++;
		int v = 0;
		while (u != v)
		{
			v = sta.top(); //弹栈
			sta.pop();
			ins[v] = false; //取消标记
			c[v] = tot;
			scc[tot].push_back(v); //记录答案
		}
	}
}

int main()
{
	int n = read(), m = read();
	for (re int i = 1; i <= m; i++)
	{
		int u = read(), v = read();
		add(u, v);
	}
	for (re int i = 1; i <= n; i++)
	{
		if (!dfn[i]) //防止不连通
		{
			tarjan(i);
		}
	}
	write(tot);
	putchar('\n');
	for (re int i = 1; i <= n; i++)
	{
		int x = c[i];
		if (vis[x])
		{
			continue;
		}
		vis[x] = true; //已输出过
		sort(scc[x].begin(), scc[x].end());
		for (re int i = 0; i < scc[x].size(); i++)
		{
			write(scc[x][i]);
			putchar(' ');
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：4)

模板题，强连通分量在本文使用 `tarjan` 算法进行求解。

**首先是概念：**

1. 如果在有向图 $G$ 中的任意两个点都相互可达，则图 $G$ 是一个强连通图。

2. 在有向图 $G$ 的的所有子图 $G'$中，如果 $G'$ 是一个强连通图，则图  $G'$ 为图 $G$ 的**强连通子图**。如果一个强连通子图 $G'$ 不是任何一个强连通子图的**真子集**，则图 $G'$ 为图 $G$ 的**极大强连通子图**，也称为 **强连通分量**。


**然后是解决方法：**  

**注：** 以下用 `dfn` 数组记录访问每个点的时间，用一个 `low(u)` 来表示 $u$ 以及其后代最多经过一条反向边能回到的最早的时间戳。

若强连通分量中第一个被发现的点是 $u$，那么集合中的点必然满足任意两点相互可达，因此最关键的就是找出每个强连通分量中的第一个点。若结点 $u$ 的子结点出发，能到达某祖先 $w$，则 $w$ 为第一个点。不难发现，若有 `low[u] = dfn[u]`，则有 $w = u$。

用 `stack` 来压入元素记录，当再次找到一个强连通分量的第一个点  $u$ 时，则弹出元素直至 $u$。因 `dfs` 每次只能找到若干个强连通分量，所以需要不断弹出然后用 `set` 记录每一个强连通分量的元素后并删除【用一个数组记录是否已经被安放至某个强连通分量中即可】，直到找到所有强连通分量。

题目中说明需要按字典序输出，因此遍历 $1-n$，用布尔数组记录该点所在强连通分量是否已经输出，这样就能完美解决了！

**代码如下：**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <set>
#include <stack>
using namespace std;
const int MAX = 1e5 + 5
inline int read ();
int n,m,cnt,scc_cnt;
int to[MAX],nxt[MAX],head[MAX];
int dfn[MAX],scc[MAX],low[MAX];
bool vis[MAX];
stack <int> s;
set <int> scc_in[MAX];
void _add (int u,int v);
void dfs (int u);
int main ()
{
	n = read ();m = read ();
	for (int i = 1;i <= m;++i)
	{
		int u = read (),v = read ();
		_add (u,v);//有向图注意一下
	} 
	for (int i = 1;i <= n;++i)
		if (!dfn[i]) dfs (i);//遍历
	printf ("%d\n",scc_cnt);//个数输出
	for (int i = 1;i <= n;++i)
	{	
		int p = scc[i];//对应的强连通分量
		if (vis[p]) continue;//已经输出过
		vis[p] = 1;
		for (set <int> :: iterator it = scc_in[p].begin ();it != scc_in[p].end ();++it) printf ("%d ",*(it));//set 的输出与指针有关
		puts ("");
	}
	return 0;
}
inline int read ()
{
    int s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}
void _add (int u,int v)
{
	to[++cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt;
}
void dfs (int u)
{
	dfn[u] = low[u] = ++cnt;//时间戳
	s.push (u);//元素压入
	for (int i = head[u];i;i = nxt[i])
	{
		int v = to[i];
		if (!dfn[v])
		{
			dfs (v);
			low[u] = min (low[u],low[v]);
		}
		else if (!scc[v]) low[u] = min (low[u],dfn[v]);//已经进入某个强连通分量的话就删除
	} 
	if (low[u] == dfn[u])//第一个点
	{
		++scc_cnt;//个数加一
		while (1)//弹出
		{
			int x = s.top ();
			s.pop ();
			scc[x] = scc_cnt;
			scc_in[scc_cnt].insert (x);//记录
			if (x == u) break;
		}
	}
}
```

---

## 作者：Hamer_sans (赞：3)

## B3609题解

### 题意
对于一个有向图，求其中强连通分量的个数并排序后输出每一个强连通分量的所有节点，就是一个 Tarjan 求强连通分量的板子。

### 解法
首先，什么是强连通分量。说起强连通分量，就不得不说连通分量，连通分量是指在一个有向图的子图中，节点 $x$ 能到达 $y$，节点 $y$ 也能到达 $x$，称为可以互相到达，这个子图中，每一对点对都能互相到达，这就是一个强连通分量。

接下来对 Tarjan 算法的步骤进行讲解，首先我们需要用一个 $timestamp$ 也就是时间戳维护两个数组 $dfn_x$ 和 $low_x$，这两个数组的含义分别是：$dfn_x$ 表示在遍历这张图时到达 $x$ 节点时的时间戳，$low_x$ 表示当前节点 $x$ 能到达的节点的最小时间戳为多少。具体来说就是在在图中递归，然后边维护这两个数组，边用一个栈来记录强连通分量的节点。

对强连通分量的判定，因为 $low_x$ 记录的是能到达的节点的最小时间戳，所以如果当前的 $low_x$ 与 $dfn_x$ 相等时，也就是能到达的最小时间戳是自己时，当前点一定是有路径能回到当前节点，否则 $low_x$ 应该小于 $dfn_x$，所以这是一个强连通分量，这时就可以把栈中节点弹出，直到弹出节点为当前节点，在这个过程中就可以记录答案。

最后说一说对于 $dfn_x$ 数组和 $low_x$ 数组的维护，$dfn_x$ 数组很简单，对于每进去一个节点，就将时间戳加一，就跟搜索树的 dfs 序差不多，重点是对于 $low_x$ 的维护，对于每进去一个节点，和 $dfn_x$ 一样直接时间戳加一，然后对于每一个它能直接到达的节点 $y$，比较取更小值，也就是 $low_x=\min(low_x,low_y)$，原因也很简单，因为 $y$ 能到达的节点，$x$ 也一定能到达，所以 $y$ 的能到达最小时间戳，$x$ 也能到达，然后对于已经入栈的节点，也就是说明该节点已经遍历过了，所以就直接取 $low_x$ 和 $low_y$的最小值 $low_x=\min(low_x,low_y)$，原因也和上一条相同，$y$ 能到的节点，$x$ 也能到达。

### code
```cpp
#include<bits/stdc++.h>
inline int read(){
	int sum=0,h=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') h=-1;ch=getchar();}
	while(isdigit(ch)) sum=sum*10+ch-'0',ch=getchar();
	return sum*h;
}
const int N=1e4+5;
int n,m;
bool vis[N][N];
int ver[N*10],ne[N*10],head[N],tot;//存边
int dfn[N],low[N];
bool in[N],output[N];//是否在栈中，是否已经输出
int id[N],scc_num;//每个点对应强连通分量编号和强连通分量的数量
int stk[N],tt,timestamp;
std::vector<int> scc[N];//储存强连通分量中的点
void add(int x,int y){
	ver[++tot]=y;
	ne[tot]=head[x];
	head[x]=tot;
	return;
}
void tarjan(int x){
	dfn[x]=low[x]=++timestamp;//赋予一个新的时间戳
	stk[++tt]=x;//入栈
	in[x]=1;
	for(int i=head[x];i;i=ne[i]){
		int y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=std::min(low[x],low[y]);
		}else if(in[y]) low[x]=std::min(low[x],low[y]);
	}
	if(dfn[x]==low[x]){//是强连通分量的第一个节点
		++scc_num;
		int top;
		do{
			top=stk[tt--];
			in[top]=0;
			id[top]=scc_num;
			scc[scc_num].push_back(top);
		}while(top!=x);
	}
	return;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;++i){
		int x,y;
		x=read(),y=read();
		if(x==y) continue;//判自环
		if(vis[x][y]) continue;//判重边
		vis[x][y]=1;
		add(x,y);
	}
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	printf("%d\n",scc_num);
	for(int i=1;i<=n;++i){
		if(output[id[i]]) continue;
		output[id[i]]=1;
		std::sort(scc[id[i]].begin(),scc[id[i]].end());//记得一定要排序
		for(int j=0;j<scc[id[i]].size();++j) printf("%d ",scc[id[i]][j]);
		puts("");
	}
	return 0;
}
```

---

## 作者：ttq012 (赞：3)

## 1 强连通分量的定义

图上的强连通分量的定义：图 $G$ 上的子图 $G'$ 中点之间两两可达，那么 $G'$ 就是 $G$ 的强连通分量。

一个点也是强连通分量。

极大强连通分量：图 $G$ 的强连通分量 $G'$ 中点数最多的图是极大强连通分量。

## 2 Tarjan 算法

Tarjan 算法首先需要将图 $G$ dfs 一遍，形成了一棵树。

但是强连通分量是一个环，树是不会形成环的。

Tarjan 算法将图 $G$ 上所有的边分为树边，回边和横叉边。

其中回边一定是会形成环的。

因为回边从儿子节点连向祖父节点，一定会和儿子到祖父的这条边形成一个环。

原图：![image.png](https://s2.loli.net/2022/08/07/HXqKpOVTAfyw7Ul.png)

假设有一条 $5\to 2$ 的回边。

![image.png](https://s2.loli.net/2022/08/07/yqfhg8CFvemQV3j.png)

容易发现，$2$，$3$，$4$，$5$ 形成了一个环。

![image.png](https://s2.loli.net/2022/08/07/WP57dXYQq689sMb.png)

看起来形成了一个 $2$，$8$，$7$，$9$ 的环，但是 dfs 不撞南墙不回头，这种情况是不会出现的。

但是 ————————

![image.png](https://s2.loli.net/2022/08/07/GT3nRJKE4r2YImi.png)

$8\to 4$ 这一条边将 $2$，$8$，$4$，$5$ 放到了一个环里。

也就是，横叉边可以和回边一起配合组成更大的环。

## 3 代码实现

```cpp
int dfn[N], low[N], cnt;
bool instk[N];
stack <int> stk;
// dfn 代表 i 点是第几个被 dfs 到的
// low 代表 i 点沿着回边，向下的边和 **扩大环** 的横叉边中，走能走到的所有的点中 dfn 最小的是多少
// 也就是 i 所在的最大的强连通分量中最上面的点
void tarjan(int now) /* 对 now 点进行 tarjan */ {
    dfn[now] = ++ cnt; // 新的点
    low[now] = cnt;
    stk.push(now); // 入栈
    instk[now] = true;
    for (auto &p : z[now]) { // 枚举now出发的点
        if (!dfn[p]) {
            tarjan(p);
            low[now] = min(low[p], low[now]); // 儿子节点能走到的，自己也能走到。
        } else { // 回边或者横叉边
            // 需要用一个栈来记录点是否在栈里，如果在那么说明走了一个环，可以更新环，否则不可以更新
            if (instk[p]) {
                low[now] = min(low[now], dfn[p]); // 尽管是错误的但是仍然可以更新
            }
        }
    }
    if (dfn[now] == low[now]) { // 不能再走到更上面的点，那么必然是最上面的点
        tot ++;
        // now是强连通分量最上面的点
        // 其他这个强连通分量的点一定比now更厚入栈，一定在站里面且在now点的上面
        while (stk.top() != now) {
            int p = stk.top();
            scc[tot].push_back(p);
            stk.pop();
            instk[p] = false;
        }
        stk.pop();
        instk[now] = false;
        scc[tot].push_back(now);
    }
}
```

如何调用 Tarjan？

```cpp
signed main() {
    // 输入
    // 执行
    for (int i = 1; i <= n; i ++)
        if (!dfn[i])
            tarjan(i); // 图不一定连通
    // 执行
    // 输出
}

```

主函数完整代码：

```cpp
signed main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i ++) {
        int x, y;
        cin >> x >> y;
        z[x].push_back(y);
    }
    for (int i = 1; i <= n; i ++)
        sort (z[i].begin(), z[i].end());
    for (int i = 1; i <= n; i ++)
        if (!dfn[i])
            tarjan(i);
    cout << tot << '\n';
    for (int i = 1; i <= tot; i ++)
        sort (scc[i].begin(), scc[i].end());
    for (int i = 1; i <= tot; i ++)
        sort (scc + 1, scc + tot + 1, [&] (const vector <int> &lhs, const vector <int> &rhs) {
            return lhs[0] < rhs[0];
        });
    for (int i = 1; i <= tot; i ++) {
        for (auto &u : scc[i])
            cout << u << ' ';
        cout << '\n';
    }
}
```



---

## 作者：Erotate (赞：2)


前置芝士
---
**连通分量的定义：**

对于一个有向图 G，其中任意两个节点 x 和 y，如果既存在 x 到 y 的路径，也存在 x 到 y 的路径，那该有向图 G 就是一个“强连通图”。而G 的其中一个子图就是一个连通分量。

注意：强连通分量是对于有向图的，无向图没有强连通分量。

**如何求强连通分量：**

一般我们用 tarjan 算法去求强连通分量。而 tarjan 主要用到以下几个边：

1. 树枝边：DFS 时经过的边，即 DFS 搜索树上的边。

2. 前向边：与 DFS 方向一致，从某个结点指向其某个子孙的边。

3. 后向边：与 DFS 方向相反，从某个结点指向其某个祖先的边。（返祖边）

4. 横叉边：从某个结点指向搜索树中的另一子树中的某结点的边。

思想：

tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。

定义 $dfn[u]$ 为节点 u 搜索的次序编号(时间戳)，$low[u]$ 为 u 或 u 的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，
$$low[u]=\min {(low[u], low[v])}$$
若 $(u,v)$ 为树枝边，u 为 v 的父节点。
$$low(u)=\min{(low[u], dfn[v])}$$
$dfn[v]$,$(u,v)$ 为指向栈中节点的后向边(指向栈中结点的横叉边)。

当结点 u 搜索结束后，若 $dfn[u] = low[u]$ 时，则以 u 为根的搜索子树上所有还在栈中的节点是一个强连通分量。

------------
回到本题，题目让我们求强连通分量的个数以及每一个强连通分量包含的节点。
那我们需要记录下每一个节点所在的强连通分量和是否被输出过，再模板即可。
详细见代码注释。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,dep;
int dfn[10001],low[10001],vis[10001],scc[10001];//vis记录是否被输出过，scc记录每一个节点所在的强连通分量
vector<int>a[10001];
stack<int>s;//我们需要用一个栈来存当前强连通分量的节点
void tarjan(int u){//标准tarjan
	dfn[u]=low[u]=++dep;
	s.push(u);
	for(int i=0;i<a[u].size();++i){//递归求解孩子
		int v=a[u][i];
		if(!dfn[v]){//如果没被更新过，递归并更新
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(!scc[v]) low[u]=min(low[u],dfn[v]);//见“思想”部分
	}
	if(dfn[u]==low[u]){//最后把当前强连通分量的节点加入scc数组
		int v;
		cnt++;
		do{
			v=s.top();
			s.pop();
			scc[v]=cnt;
		}while(u!=v);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;++i){//建图，记住，是单向建图
		scanf("%d%d",&x,&y);
		a[x].push_back(y);
	}
	for(int i=1;i<=n;++i)//因为图有可能不连通，所以要循环判断每个点是否被求过强连通分量
		if(!dfn[i]) tarjan(i);
	printf("%d\n",cnt);
	for(int i=1;i<=n;++i){//输出每一个强连通分量的节点
		if(vis[scc[i]]) continue;//是否被输出了
		vis[scc[i]]=1;
		for(int j=1;j<=n;++j)//如果在同一强连通分量，就输出
			if(scc[j]==scc[i]) printf("%d ",j);
		printf("\n");
	}
	return 0;
}
```



---

## 作者：orz_z (赞：2)

[原题传送门](https://www.luogu.com.cn/problem/B3609)
# Tarjan 算法
 ## 1. 什么是 Tarjan 
Tarjan 算法是一种用于求解有向图的强连通分量的算法，时间复杂度为 $O(n + m)$。它可以求出每个强连通分量的大小、属于其的顶点和强连通分量的总数。
## 2. 认识 dfs 生成树
dfs 生成树处理强连通分量的一个有力的工具：在 dfs 时，每当通过某条边 $e$ 访问到一个新节点 $v$，就加入这个点和这条边，最后得到的便是 dfs 生成树。

例如下面这张有向图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/e23e5d863b02b5788e52e29c395bf7f4.png#pic_center)

它的 dfs 生成树可能是这样（黑色实线）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/d9ab6c79603db6f4d2619ce3177b50aa.png#pic_center)

有向图的 dfs 生成树主要有 $4$ 种边（不一定全部出现）：

 1. 树枝边（tree edge）：黑色实线，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。
 2. 前向边（forward edge）：灰色虚线，从某个点到它的某个子孙节点（注意不是子节点）的边。
 3. 后向边（back edge）（也称反祖边）：绿色虚线，也被叫做回边，即指向祖先结点的边。
 4. 横叉边（cross edge）：蓝色虚线，从某个点到一个已被访问过且既非它子孙节点、也非它祖先节点的边。
 
**定理 $1$：后向边和横叉边都有一个特点：起点的 dfs 序必然大于终点的 dfs 序。**

> 证：对于反向边，由于祖先节点的 dfs 序小于子孙节点，所以是显然的。对于横叉边 $u→v$，由于 $v$ 既不是 $u$ 的祖先，也不是 $u$ 的子孙，所以必然存在一个不同于 $u$、$v$ 的点 $w=lca(u,v)$，$u$ 和 $v$ 分别位于两个分支上。 $u→v$ 没有成为一条树边，这说明 $v$ 所在的分支一定在 $u$ 所在的分支之前被访问过，也就是说，分别在 $u$ 所在分支和 $v$ 所在分支上任取点 $p$ 和 $q$，前者的 dfs 序都一定比后者大，自然也有 $dfsn(u)>dfsn(v)$。得证。

这可以导出一个有用的结论：**对于每个强连通分量，存在一个点是其他所有点的祖先**。若不然，则可以把强连通分量划成 $n$ 个分支，使各分支的祖先节点互相不为彼此的祖先。这些分支间不能通过树边相连，只能通过至少 $n$ 条横叉边相连，但这必然会违背上一段讲的性质。

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/552f654f0f0be87e6d5c466591160f32.png#pic_center)

我们把这个唯一的祖先节点称为强连通分量的根。显然，根是强连通分量中 dfs 序最小的节点。

**定理 $2$：如果结点 $u$ 是某个强连通分量的根（也就是在在搜索树中遇到的第一个结点），那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。**


> 反证法：假设有个结点 $v$ 在该强连通分量中但是不在以 $u$ 为根的子树中，那么 $u$ 到 $v$ 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 $u$ 是第一个访问的结点矛盾了。得证。

## 3. Tarjan 的基本思想

在 Tarjan 算法中，每个结点 $u$ 维护了以下几个变量：

 - $dfsn[u]$：深度优先搜索遍历时结点 $u$ 被搜索的次序（也称为 dfs 序）。
 - $low[u]$：定义为 $u$ 所在子树的节点经过最多一条非树边 $u \to v$（其中 $v$ 必须可达 $u$）能到达的节点中最小的 dfs 序。
	
    根据这样的定义，某个点 $p$ 是强连通分量的根，等价于 $low[p]=dfsn[p]$。
	> 证明：如果 $low[p]=dfsn[p]$，说明 $p$ 不能到达 dfs 序比 $p$ 小的节点，或者说不存在一个强连通分量同时包含 $p$ 和某个 dfs 序比 $p$ 小的节点。因此，$p$ 只能是某个强连通分量的根。
	
	我们这里必须强调 $v$ 可达 $u$，否则在下图中，会使 $low[5]=2$，但它是一个强连通分量的根。
    
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/8616e31e12d4aa07a0046398378974c7.png#pic_center)

枚举图中的顶点 $v$，如果 $dfsn_{v} = 0$，说明 $v$ 属于一个新的强连通分量，从 $v$ 开始搜索。

接下来，按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索。在搜索过程中，对于以某个点 $p$ 为起点的边 $p \to q$：
 - 如果 $q$ 未访问过，则 $q$ 在 $p$ 所在的子树上，如果某节点 $r$ 从 $q$ 起可以经过最多一条后向边到达，则从 $p$ 起也可以（先从 $p$ 到 $q$，再到 $r$），于是先递归处理点 $q$，然后令 $low[p] = min(low[p], low[q])$。
 - 如果 $q$ 已访问过，且从 $q$ 可以到达 $p$，说明 $q$ 是 $p$ 的祖先且 $p$ 可以通过一条非树边到达 $q$，则令 $low[p] = min(low[p],dfsn[q])$。
 - 如果 $q$ 已访问过，且从 $q$ 不能到达 $p$，不做处理。（后两种情况都是非树边）。

但是我们怎么确认一个点能不能到达另一个点呢？因为反向边和横叉边都指向 dfs 序较小的节点，而前向边的存在又不影响状态转移方程，所以我们只需要确认比该点 dfs 序小的哪些点能到达该点即可，这可以用一个栈动态地维护：

* 每当搜索到新点，就令它入栈。

* 如果发现点 $p$ 满足 $low[p]=dfsn[p]$ ，则说明 $p$ 是某个强连通分量的根，它和栈中的子孙节点相互可达。但同时，它和栈中的子孙节点也无法到达 $p$ 的祖先节点，以及祖先节点其他尚未搜索的分支了，所以不断从栈顶弹出元素，直到弹出 $p$（注意这样维护的栈中节点的 dfs 序是单调增的），同时记录答案。

# 关于本题

对于每一个点，若没有遍历过，则跑一遍 dfs。

在弹出栈时，用 $id_i$ 记录点 $i$ 所处的强连通分量的编号。

题目还要求要排序输出，可以用一个动态数组存答案排序输出。

但笔者太懒了，就用了 $O(n^2)$ 输出。

# AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10005 * 2;

struct node
{
    int to, nxt;
} edge[maxn];

int n, m, mx = -1, cnt, cnt_node, cntn, head[maxn], dfn[maxn], low[maxn], id[maxn];
bool vis[maxn];
int opt[maxn];
stack<int> s;

inline void add_edge(int u, int v)
{
    edge[++cnt].to = v;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
}

inline void tarjan(int u)
{
    cnt_node++;
    dfn[u] = low[u] = cnt_node;
    s.push(u);
    vis[u] = 1;
    for (int &e = head[u]; e; e = edge[e].nxt)
    {
        if (!dfn[edge[e].to])
        {
            tarjan(edge[e].to);
            low[u] = min(low[edge[e].to], low[u]);
        }
        else if (vis[edge[e].to])
            low[u] = min(low[u], dfn[edge[e].to]);
    }
    if (low[u] == dfn[u])
    {
        cntn++;
        while (1)
        {
            int now = s.top();
            s.pop();
            vis[now] = 0;
            id[now] = cntn;
            if (now == u)
                break;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; i++)
    {
        scanf("%d%d", &u, &v);
        add_edge(u, v);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i);
    cout << cntn << endl;
    for(int i = 1; i <= n; ++i)
    {
    	if(vis[i]) continue;
    	cout << i << " ";
    	for(int j = 1; j <= n; ++j)
    	{
    		if(id[j] == id[i] && j != i)
    		{
    			cout << j << " ";
    			vis[j] = 1;
			}
		}
		cout << endl;
	}
    return 0;
}
```

---

## 作者：xiezihanAKIOI (赞：1)

一道 Tarjian 模板题，只是排序稍微有一亿点麻烦。

记忆化搜索，从点 1 开始每个点都用 Tarjian 跑一边。每次跑完用数组标记已经跑过了。对于找到的强连通分量，则用小根堆乘 −1，（和大根队同等效果，只要取出来的时候再乘一边即可）存起来。

和大家讲下怎么实现的。

首先我们要知道，强连通分量是什么。强连通分量指的是有向图的极大强连通子图称为 $G$ 的强连通分量，强连通图只有一个强连通分量，即其本身。非强连通图的有向图有多个强连通分量。

接下来，我们是怎么去寻找强连通分量的呢？

我们首先要明白三个点：

搜索树：
==

在连通图中，任选一个节点出发，进行深度优先搜索，每个点只访问一次。在深搜过程中所经过的点，以及所有发生递归的边 $xy$（也就是说，对于边 $xy$，从 $x$ 到 $y$，点 $y$ 是第一次访问），构成一棵树，我们把这棵树称为搜索树，记作 subtree。

时间戳：
==
在图的深度优先搜索过程中，按照每一个节点第一次被访问的时间顺序，依次给予 $N$ 个节点一到 $N$ 的顺序整数标记，第一个访问的节点记为 1，该标记被称为“时间戳”。记为 dfn，表示节点 $x$ 在搜索树中出现的次序为 $dfn_x$。

追溯值：
==
Tarjian 算法引入了追溯值 low 这一概念：low 定义为节点 $x$，能回溯到的，在同一搜索树上的，最早的节点 也就是能够回溯到的时间戳最小的节点。 也就是说 $low_x$ 记录着最小的时间戳。

如何回溯呢？
==
可以发现，一个环一定是强连通图，根据定义如果既存在 $x$ 到 $y$ 的路径，也存在从 $y$ 到 $x$ 的路径，那么显然 $x$，$y$ 在一个环中。

因此，Tarjian 算法的基本思路就是，对于每一个点，尽可能地找到与它能构成环的所有节点。该如何寻找？ 大家回想一下时间戳！

追溯值 low 可以帮助我们判断当前的搜索树是否能构成环，和谁构成环。

再架设存在一条边 $uv$，$v$ 已经被访问，但其子孙后代还没有全部访问完成， 说明节点 $v$ 在点 $u$ 之前已经访问过了，因此：节点 $v$ 是节点 $u$ 的父辈节点，我们再看边 $uv$，显然，节点 $u$ 好像也是节点 $v$ 的父节点，意味着什么？ 显然，如果存在后向边，表示此处形成了一个环。

追溯值的计算方式 当节点 $x$ 第一次被访问时，把 $x$ 入栈，初始化 $low_x$
 和 $dfn_x$ 扫描从 $x$ 出发的每条边 $xy$ 若 $y$ 没被访问过，则说明 $xy$ 是树枝边（父子关系）。

递归访问 $y$，从 $y$ 回溯之后，令 `low[x]=min(low[x],low[y])`；若点 $y$ 被访问过并且 $y$ 在栈中，说明点 $y$ 的后代还没有全部访问结束，说明 $xy$ 是后向边，可以形成环，令 `low[x]=min(low[x],dfn[y])`；从 $x$ 回溯之前，判断是否有 `low[x]==dfn[x]`；若成立，则不断从栈中弹出节点，直到 $x$ 出栈。

接下来上代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int dfn[100005], low[100005], ifcut[100005], Index, ans, n, m, a[100005];
stack <int> s;
priority_queue <int> y[100005];
vector <int> g[100005];
bool instack[100005];

void tarjan (int u)
{
//  cout << 'a';
    dfn[u] = low[u] = ++Index;
    s.push (u);
    instack[u] = true;
    for (int i = 0 ; i < g[u].size () ; i++)
    {
        int v = g[u][i];
        if (dfn[v] == -1)
        {
            tarjan (v);
            low[u] = min (low[u], low[v]);
        } else {
            if (instack[v])
            {
                low[u] = min (low[u], dfn[v]); 
            }
        }
    }
    if (dfn[u] == low[u])
    {
        ans++;
        int v;
        do{
            v = s.top();
            s.pop();
            instack[v] = false;
            y[ans].push (v * -1);
        } while (u != v);
    }
}

int main ()
{
    memset (dfn, -1, sizeof (dfn));
    memset (low, -1, sizeof (low));
    cin >> n >> m;
    for (int i = 1 ; i <= m ; i++)
    {
        int u, v;
        cin >> u >> v;
        g[u].push_back (v);
    }
    for (int i = 1 ; i <= n ; i++) if (dfn[i] == -1) tarjan (i);
    cout << ans << endl;
    for (int j = ans ; j >= 1 ; j--)
    {
        a[j] = y[j].top ();
    }
    sort (a + 1, a + 1 + ans);
    int k = ans;
    for (int i = 1 ; i <= ans ; i++)
    {
        for (int i = 1 ; i <= ans ; i++)
        {
            if (y[i].top () == a[k])
            {
                while (!y[i].empty ())
                {
                    cout << y[i].top () * -1 << ' ';
                    y[i].pop ();
                }
                cout << endl;
                k--;
                continue;
            }
        }
    }

    return 0;
}
```


---

## 作者：Jeremiahy (赞：1)

# 强联通分量与 Tarjan 算法

### 概念

在深度优先遍历的过程中，按照每个节点第一次被访问的时间顺序，依次给予流图中 $N$ 个节点 $1$ 到 $N$ 的整数标记，该标记被称为时间戳，记为 $dfn_x$。

流图中每条有向边 $(x,y)$ 必定是以下四种之一：

1. 树枝边，指搜索树中的边，即 $x$ 是 $y$ 的父节点。

1. 前向边，指搜索树中 $x$ 是 $y$ 的祖先节点。

1. 后向边，指搜索树中 $y$ 是 $x$ 的祖先节点。

1. 横叉边，指除了以上三种情况之外的边，它一定满足 $dfn_y<dfn_x$。

### 强联通分量

给定一张有向图。若对于图中任意两个节点 $x,y$，既存在 $x$ 到 $y$ 的路径，也存在 $y$ 到 $x$ 的路径，则称其为强连通图；

有向图的极大强连通子图被称为强连通分量，简记为 SCC。

在上文中，一个强连通子图 $G'=(V',E')(V\subseteq V,E'\subseteq E)$ 极大，当且仅当不存在包含 $G'$ 的更大子图 $G''=(V'',E'')$ 满足 $V'\subseteq V''\subseteq V,E'\subseteq E''\subseteq E$。

显然，一个环一定是强连通图，所以我们的思路就是找到能和某个点构成环的所有点。

为了找到环，Tarjan 算法在深度优先遍历的同时维护了一个栈。当访问到节点 $x$ 时，栈中需要保存以下两类节点：

1. 搜索树上 $x$ 的祖先节点，记为集合 $anc(x)$。设 $y\in anc(x)$。若存在后向边 $(x,y)$，那么 $(x,y)$ 与 $y$ 到 $x$ 的路径一起形成环。

1. 已经访问过，并且存在一条路径到达 $anc(x)$ 的节点。设 $z$ 是这样的一个点，从 $z$ 出发存在一条路径到达 $y\in anc(x)$。若存在横叉边 $(x,z)$，则 $(x,z)$、$z$ 到 $y$ 的路径、$y$ 到 $x$ 的路径形成一个环。

### 追溯值


设 $subtree(x)$ 表示流图的搜索树中以 $x$ 为根的子树。$x$ 的追溯值 $low_x$ 定义为满足以下条件的节点的最小时间戳：

1. 该点在栈中。

1. 存在一条从 $subtree(x)$ 出发的有向边，以该点为终点。

根据定义，Tarjan 算法按照以下步骤计算追溯值：

1. 当节点 $x$ 第一次被访问时，把 $x$ 入栈，初始化 $low_x=dfn_x$。

1. 扫描从 $x$ 出发的每条边 $(x,y)$。若 $y$ 没有被访问过，则说明 $x$ 是 $y$ 的父节点，递归访问 $y$，从 $y$ 回溯后，令 $low_x=\min(low_x,low_y)$；若 $y$ 被访问过且 $y$ 在栈中，则令 $low_x=\min(low_x,dfn_y)$。

1. 从 $x$ 回溯之前，判断是否有 $low_x=dfn_x$。若成立，则不断从栈中弹出节点，直至 $x$ 出栈。

### 强联通分量判定法则

在追溯值的计算过程中，若从 $x$ 回溯前，有 $low_x=dfn_x$ 成立，则栈中从 $x$ 到栈顶的所有节点一起构成一个强连通分量。

大致地证明：在计算追溯值的第 $3$ 步，如果 $low_x=dfn_x$，那么说明 $subtree(x)$ 中的节点不能与栈中其他节点一起构成环。另外，因为横叉边的终点时间戳必定小于起点时间戳，所以 $subtree(x)$ 中的节点也不可能直接到达尚未访问的节点（时间戳更大）。综上所述，栈中从 $x$ 到栈顶的所有节点不能与其他节点一起构成环。

又因为我们及时进行了判定和出栈操作，所以从 $x$ 到栈顶的所有节点独立构成一个强连通分量。

下面的程序实现了 Tarjan 算法，求出数组 $c$，其中 $c_x$ 表示 $x$ 所在的强连通分量的编号。另外，它还求出了 vector 数组 $scc$，$scc_i$ 记录了编号为 $i$ 的强连通分量中的所有节点（当然本题不需要这个 vector 数组）。整张图共有 $cnt$ 个强连通分量。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10005, M = 200005;
int head[N], ver[M], nxt[M], tot;
int dfn[N], low[N], c[N], s[N], n, m, num, top, cnt;
vector<int> scc[N];
bool ins[N], vis[N];

void add(int x, int y) {
    ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;
}

void tarjan(int x) {
    low[x] = dfn[x] = ++num;
    s[++top] = x; ins[x] = 1;
    for (int i = head[x]; i; i = nxt[i])
        if (!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[x] = min(low[x], low[ver[i]]);
        }
        else if (ins[ver[i]])
            low[x] = min(low[x], dfn[ver[i]]);
    if (dfn[x] == low[x]) {
        cnt++; // 找到了一个SCC
        int y;
        do {
            y = s[top--], ins[y] = 0, c[y] = cnt, scc[cnt].push_back(y);
        } while (x != y);
    }
}

signed main() {
    cin >> n >> m;
    for (register int i = 1, x, y; i <= m; i++) {
        cin >> x >> y;
        add(x, y);
    }
    for (register int i = 1; i <= n; i++)
        if (!dfn[i]) 
			tarjan(i);
	cout << cnt << '\n';
	for (register int i = 1; i <= n; i++)
		if (!vis[c[i]]) {
			vis[c[i]] = 1;
			for (register int j = 1; j <= n; j++)
				if (c[i] == c[j])
					cout << j << ' ';
			puts("");
		}
    return 0;
}
```


---

## 作者：Aw顿顿 (赞：1)

Update：改正了一部分标点使用不当的情况。

## 强连通分量

如果一个有向图任意两点 $x$ 与 $y$ 之间，都存在一条路径，那么这个图是一个强连通的图。我们所需要求的，便是一个给定有向图中的极大强连通子图。它被称为强连通分量 SCC，全称 Strongly Connected Component。

> **例题：[B3609 \[图论与代数结构 701\] 强连通分量](https://www.luogu.com.cn/problem/B3609)**

## 前置知识：DFS 序

给定一个图，从随意一个节点开始 DFS 会形成一棵树。

![](https://oi-wiki.org/graph/images/scc1.png)

图片来自 OI-Wiki。我们发现在正常搜索的过程中，会形成一些在图中绿色的边，这些边构成了一棵树——因此我们称之为树边。显然这个图在搜索过程中会形成环，因此我们要考虑另外三种边。

如果我们访问到一个已经访问过的节点，此时我们考虑三种情况：

- 该节点并不是当前节点及其祖先生成的：红色横叉边。
- 该节点在当前节点子树中：蓝色的前向边。
- 该节点是当前节点的祖先：黄色的回边（又名返祖边）。

显然，如果一个节点 $u$ 是某个 SCC 在搜索过程中遇到的第一个节点，那么这个 SCC 的所有其余节点一定都在以这个节点为根的搜索树当中，可用反证法证明，此处略去，读者自证不难。

## Tarjan 算法小引

考虑使用 Tarjan 算法，首先定义一些变量：

- $\text{dfn}(u)$ 表示 DFS 序，即 DFS 时搜索到的次序。
- $\text{low}(u)$ 表示 $u$ 所在 SCC 里 $\rm dfn$ 的最小值，按照定义来说是这样：

> 以下结点之中 $\text{dfn}(u)$ 最小的值：以 $u$ 为根节点所在子树的所有结点，和从其子树可以由一条不在搜索树中的边连向的结点。

同时，我们在代码实现中用 $in$ 数组来标示每一个节点属于哪一个强连通分量。我们还需要一个栈 $sta$ 来存储尚未确定所属强连通分量的节点（也需要一个 $is$ 数组判断当前是否在栈中）。由于我们需要记录每一个强连通分量的大小，因此我们还需要一个数组 $size$。

## 引理与思路

一个非常显然的事实是：节点 $u$ 的所有子树节点的 $\rm dfn$ 值都比 $u$ 本身的 $\rm dfn$ 值要大。因此从根开始的一条路径上，$\rm dfn$ 是严格递增的，而 $\rm low$ 则呈现出严格非下降。接下来考虑具体实现步骤。

对于一个从 $u$ 出发访问 $v$ 的节点，如果 $v$ 不是其父节点，考虑三种不同的状态：

- 如果 $v$ 尚未访问过，那么进一步深搜，在回溯过程中用 $\text{low}(v)$ 更新 $\text{low}(u)$。
- 如果 $v$ 被访问过且在栈中，那就可以用 $\text{dfn}(v)$ 去更新 $\text{low}(u)$ 了（考虑定义）。
- 如果 $v$ 被访问过且不在栈中，那可忽略（已经确定的节点无需考虑）。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define N 10005
#define M 100005 
using namespace std;
const int MAXN=10005;
const int MAXM=100005;
struct node{
	int v,nxt;
}e[M<<1];
int h[N],cnt,low[N],dfn[N],tot;
int in[N],f[N],n,m,ans;
bool is[N];
stack<int>s;
vector<int>vec[N];
void add(int u,int v){
    e[++cnt].v=v,e[cnt].nxt=h[u],h[u]=cnt;
}void dfs(int x){
	dfn[x]=low[x]=++tot;
	s.push(x);is[x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(!dfn[v])dfs(v),low[x]=min(low[x],low[v]);
		else if(is[v])low[x]=min(low[x],dfn[v]);
	}if(dfn[x]==low[x]){
	    ans++;vec[ans].push_back(x);
	    while(s.top()!=x){
	    	in[s.top()]=ans;
	    	is[s.top()]=0;
	    	vec[ans].push_back(s.top());
	    	s.pop();
		}s.pop();is[x]=0;in[x]=ans;
	}
}signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int u,v;cin>>u>>v;add(u,v);
	}for(int i=1;i<=n;++i)if(!dfn[i])dfs(i);
	cout<<ans<<'\n';
	for(int i=1;i<=ans;++i)sort(vec[i].begin(),vec[i].end());
	for(int i=1;i<=n;++i){
		if(f[in[i]])continue;
		f[in[i]]=1;
		for(int j=0;j<vec[in[i]].size();++j)
			cout<<vec[in[i]][j]<<' ';
		puts("");
	}
	return 0;
}
```





---

## 作者：eEfiuys (赞：1)

题目：[B3609](https://www.luogu.com.cn/problem/B3609)

这是一道**强连通分量**的模板题，我们使用 **Tarjan 算法**来做。

### 强连通分量：
- 在**有向图**中，若 $x$ 个点**两两可达**，则称这 $x$ 个点构成强连通分量。
- **一个点**也是一个强连通分量。

------------

### 计算：
- 存储：
	- $cnt$ 表示在**整个**搜索过程中，搜索了几个节点。
   - $nun$ 表示强连通分量的数量。
	- $ans_{i,j}$ 表示第 $i$ 个强连通分量中的第 $j$ 个节点。
		- 因为数量不一定，所以用 `vector` 存。
	- $dfn_i$ 表示节点 $i$ 在 `dfs` 的过程中被第几个搜索到，**为 $0$ 表示还未搜索到**。
   - $low_i$ 表示与节点 $i$ 相邻的节点中最小的 $dfn$。
   - $sta$ 为手写的栈，存储**搜索到但还没有进入 $ans$** 的节点。
   - $ins_i$ 表示节点 $i$ 所在的强连通分量，**已经搜索到且 $ins_i$ 为 $0$ 则节点 $i$ 在栈中**。
   - $out_i$ 表示第 $i$ 个强连通分量未输出。
   
- 因为是有向图，所以从第 $1$ 个节点搜索不一定全部搜到，因此**从 $1$ 到 $n$ 枚举，没有搜索到就从它再搜索**。

- 更新：
	- $u$ 为当前节点。
	- $cnt$ 加上 $1$。
	- $dfn_u$ 和 $low_u$ 都更新为 $cnt$。
	- 如果与 $u$ 相邻的节点 $v$ 还未搜索：
		- 搜索节点 $v$。
		- $low_u$ 为它和 $low_v$ 的最小值。
	- 如果与 $u$ 相邻的节点 $v$ 已搜索且 $v$ 在栈中：
		- $low_u$ 为它和 $dfn_v$ 的最小值。

- 增加强连通分量：
	- $u$ 为当前节点。
	- 当 $dfn_u$ 与 $low_u$ 相等时就更新。
	- $num$ 加上 $1$。
	- 从栈顶不断弹出元素，并加入 $ans_{num}$ 中，直到元素与 $u$ 相等为止。
		- 因为相等也要加入，所以我们先加入再判断。
   - 每个弹出的元素的 $ins$ 值为 $num$。

------------

下面是~~精心制作~~的图，括号内为 $dfn$、$low$、$ins$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8onloy01.png?x-oss-process=image/resize,m_lfit,h_300,w_397)

------------

### 输出：
- 对每个强连通分量的节点排序。
- 枚举每个节点，如果所在的强连通分量未输出，就输出这个强连通分量。

------------

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+1;
inline int read(){ //快读。
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		(x*=10)+=(ch-'0');
		ch=getchar();
	}
	return x*f;
}
int n,m;
vector<int>g[N];
int cnt;
int dfn[N],low[N];
int top;
int sta[N];
int ins[N];
int num;
vector<int>ans[N];
bool out[N];
void tarjan(int u){
	//更新。
	dfn[u]=low[u]=++cnt,sta[++top]=u;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!ins[v])low[u]=min(low[u],dfn[v]);
	}
	//增加强连通分量。
	if(dfn[u]==low[u]){
		num++;
		do{
			int x=sta[top];
			ans[num].push_back(x),ins[x]=num;
		}while(sta[top--]!=u);
	}
}
signed main(){
	n=read(),m=read();
	//存图。
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		g[u].push_back(v);
	}
   //枚举未搜索的点进行搜索。
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=num;i++)
		sort(ans[i].begin(),ans[i].end()); //排序。
	printf("%d\n",num);
	for(int i=1;i<=n;i++)
		if(!out[ins[i]]){ //还没有输出。
			out[ins[i]]=1; //标记为已输出。
			for(int j=0;j<ans[ins[i]].size();j++)
				printf("%d ",ans[ins[i]][j]);
			putchar('\n');
		}
	return 0;
}
```

---


# [图论与代数结构 801] 无向图的块

## 题目描述

在离散数学课程的学习中，大家学习了无向图中”割点“和“块”的定义，现在来检查一下大家的学习情况。

给定一张 $n$ 个点 $m$ 条边的无向图，点的编号从 $1$ 到 $n$ ，可能存在重边和自环，不保证是一张连通图。现在，请你求出这张图所有的块。

注意，我们不把一个没有任何与其相连边的点看成割点；因此，一个单独的点构成的连通块不被看成是块。你可以通过样例理解这个事情。

在输出的时候，我们规定这么一个输出的顺序：首先，对于一个块，我们把该块中所有点按照编号从小到大排序；然后，对于两个块，我们规定，把点按照顺序拿出来排成一个序列，字典序较小的排在前面。这样，我们就可以对所有块规定了一个顺序。最终输出就按照这样的顺序输出。

有关字典序的定义，可以在搜索引擎上查找，或者参考[维基百科_字典序](https://en.wikipedia.org/wiki/Lexicographic_order)。


## 说明/提示

本题没有部分分。

对于所有数据，满足 $1\leq n \leq 50000$，$1 \leq m \leq 300000$，保证输入的图合法且满足题目中的限制条件。


## 样例 #1

### 输入

```
7 7
5 6
1 2
3 5
1 4
3 1
4 5
2 5
```

### 输出

```
2
1 2 3 4 5
5 6```

# 题解

## 作者：Hamer_sans (赞：8)

$Update$

第一次修改：$10$ 月 $4$ 日调整代码

## 题目大意：

求点双连通分量有多少个，但是特别的，在每一个点双连通分量中的节点要按从大到小的去排序，对于每一个点双连通分量要按字典序进行排序，其他的就和一个板子任何的区别。

## 什么是点双连通分量？

首先我们要先知道什么是时间戳，时间戳就是深度优先遍历的过程中，给依次被访问的节点进行整数标记,这种标记就被称为时间戳，记为 $dfn$。

![图1](https://cdn.luogu.com.cn/upload/image_hosting/wmy10kd0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

就比如说这幅图，红箭头指的方向和顺序就是深度优先遍历的顺序，如果假设 $1$ 根节点，深度优先遍历从 $1$ 开始，所以我们按照其顺序就可以得到 $dfn$ 数组的值，如 $dfn_{1}=1$，$dfn_{4}=2$，$dfn_{5}=3$ ... $dfn_{3}=6$。

然后我们需要知道什么是搜索树，在无向连通图中任选一个节点进行深度优先遍历，每个点只访问一次。所有发生递归的边 $(x,y)$ 所构成的一棵树，我们把它称做“无向连通图的搜索树”。

最后还有一个东西，叫做追溯值 $low$，我们设 $subtree(x)$ 表示搜索树中以 $x$ 为根节点的子树，$low_{x}$ 定义为以下节点的时间戳的最小值:

1.$subtree(x)$ 中的节点。

2.通过 $1$ 条不在搜索树上的边，能够达到 $subtree(x)$ 的节点。

最后的最后还有一个东西，它的名字叫做割点，什么是割点呢？在无向连通图中，如果将这个节点和它与其它点的连删除后，这时无向连通图还会被分成若干个的无向连通图，于是我们就把这个点叫做割点。那如何来判断这个点是否是割点呢？首先，割点不能为搜索树的根节点，并且割点至少要有两个子节点。比如说这幅图： $x$ 就是割点。

![图2](https://cdn.luogu.com.cn/upload/image_hosting/ieiy2j5v.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

好的，现在终于可以开始正题了。点双连通分量，也就是 v-DCC ，它的定义是一张不存在割点的无向连通图，那我们怎么求点双连通分量呢？我们用一个栈来储存点双连通分量的节点，在用利用时间戳实现的 Tarjan 算法对这个栈进行维护。当一个元素第一次被访问时，就将这个元素进栈，当 $dfn_{x} \le low_{y}$ 成立时，就开始弹出之前进栈的元素，并且记录下来，直到将节点 $y$ 弹出为止，这些弹出的元素一起构成一个点双连通分量。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5,M=3e5+5;
int ver[M],head[N],ne[M],tot;
int n,m;
int dfn[N],low[N],timestamp;
bool cut[N];
int root;
int stk[N],tt;
int cnt;
vector<int> dcc[N];
void add(int x,int y){
	ver[++tot]=y;
	ne[tot]=head[x];
	head[x]=tot;
	return;
}
bool cmp(vector<int> x,vector<int> y){
	int len=min(x.size(),y.size());
	for(register int i=0;i<len;++i){
		if(x[i]<y[i]) return 1;
		else if(x[i]>y[i]) return 0;
	}
	return x.size()<y.size();
}
void tarjan(int x){
	dfn[x]=low[x]=++timestamp;
	stk[++tt]=x;
	for(register int i=head[x];i;i=ne[i]){
		int y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x]){
				cnt++;
				int d;
				do{
					d=stk[tt--];
					dcc[cnt].push_back(d);
				}while(d!=y);
				dcc[cnt].push_back(x);
			}
		}else low[x]=min(low[x],dfn[y]);
	}
	return;
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;++i){
		int x,y;
		scanf("%d%d",&x,&y);
		if(x==y) continue;
		add(x,y);
		add(y,x);
	}
	for(register int i=1;i<=n;++i){
		if(!dfn[i]) root=i,tarjan(i);
	}
	for(register int i=1;i<=cnt;++i) sort(dcc[i].begin(),dcc[i].end());
	sort(dcc+1,dcc+cnt+1,cmp);
	printf("%d\n",cnt);
	for(register int i=1;i<=cnt;++i){
		for(register int j=0;j<dcc[i].size();++j){
			printf("%d ",dcc[i][j]);
		}
		puts("");
	}
	return 0;
}
```
本题解参考资料书《算法竞赛进阶指南》，蒟蒻写题解不易，求点赞。

---

## 作者：KEBrantily (赞：5)

成为了本题中提交最多次才过的人。

这题并不难，写挂了怪我菜。

以下内容部分来自[我的博客](https://www.cnblogs.com/KnightL/p/14351657.html)。

# Description

求出一个图中的所有点双连通分量，对于每个分量中的点编号从小到大排序，再按排序后的字典序从小到大输出。

# Solution

求点双难度显然小于字典序排序难度（

首先我们要明确“块”是什么。bdfs 后发现是点双。

## 定义

### 点双连通分量

在一张连通的无向图中，对于两个点 $u$ 和 $v$ ，如果无论删去哪一个除自己之外的点都不能使它们不连通，我们就说 $u$ 和 $v$ 点双连通。

### 割点

如果在一个无向图中，删去某个点可以使这个图的极大连通分量数增加，那么这个点被称为这个图的割点，也叫割顶。

~~什么是极大连通分量就不说了吧，再说就套娃了。~~

很显然的是，割点就是两个点双连通分量之间的点，它同属于他们两个。

所以知道怎么求割点之后，求点双就比较容易了。

## 实现

### 求割点

先说说怎么求割点。

同缩点一样，用 Tarjan 求割点也需要处理出点的 dfs 序和 low 值。

每次枚举一个点，判断这个点是否为割点的依据是：

1. 如果它有至少一个儿子的 low 值大于它本身的 dfs 序，那么它就是割点；
1. 如果它本身被搜到且有不少于两个儿子，那么它就是割点。

对于第一个依据的说明是：若一个儿子的 low 值大于它本身的 dfs 序，说明删去它之后它的这个儿子无法回到祖先点，那么它肯定是割点。

对于第二个依据的说明是：若它的儿子小于两个，那么删去他不会造成任何影响，所以它不会是割点。

更新 low 值的方式与缩点相似，但是约束条件不同，放伪代码感性理解一下：

```cpp
如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);
否则 low[u] = min(low[u], num[v]);
```

### 求点双连通分量

在割点的基础上变通一下即可。

我们用栈来保存按照 dfs 序排序的目前还能进入新的点双里的非割点。

对于点 $u$ ，如果它的儿子 $v$ 满足 $low_v\ge dfn_u$，那么 $u$ 是割点，这时应不断退栈直到 $v$ 被弹出，那么弹出的所有点和 $u$ 形成一个点双。

具体来说也就是这样：

```cpp
void tarjan(int u){
  zhan[++Top]=u;dfn[u]=low[u]=++cnt;
  for(int i=head[u];i;i=e[i].nxt){
    int to=e[i].to;
    if(!dfn[to]){
      tarjan(to);low[u]=min(low[u],low[to]);
      if(low[to]>=dfn[u]){
        ++t;int pre;
        do{
          pre=zhan[Top--];
          ...//相应操作
        }while(pre!=to);
        ...//相应操作
      }
    }
    else low[u]=min(low[u],dfn[to]);
  }
}
```

## 别的

回到本题。

按照上面的方法，求是好求，但是还要排序输出。

我们可以用 `vector` 存储每个点双的点，然后想办法按字典序排序。

这里有几个错误做法，都是我犯的：

- $\Theta(n)$ 遍历每个点判断所在点双是否输出过，没有则输出。

因为割点存在于多个点中，所以可能被输出多遍。

- 存到 `string` 中排序。

`string` 是可以按字典序排序的，但是点的编号过大时它无法存到一个位置内，就会出现负数等奇怪的情况。

最好是写个自定义排序，按字典序大小排然后输出。

当然估计大家都比我强，应该不会犯这种问题。

# Code

```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 50010
#define INF 0x3f3f3f3f
//#define int long long

using namespace std;

bool flag[maxn];
int n,m,tot,t,cnt,Top;
int head[maxn],num[maxn],siz[maxn];
int zhan[maxn],dfn[maxn],low[maxn];
struct edge{int fr,to,nxt;}e[maxn*12];
vector<int> v[maxn];

int read(){
  int s=0,w=1;char ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
  while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
  return s*w;
}

void add(int fr,int to){
  e[++tot]=(edge){fr,to,head[fr]};
  head[fr]=tot;
}

void tarjan(int u){
  zhan[++Top]=u;dfn[u]=low[u]=++cnt;
  for(int i=head[u];i;i=e[i].nxt){
    int to=e[i].to;
    if(!dfn[to]){
      tarjan(to);low[u]=min(low[u],low[to]);
      if(low[to]>=dfn[u]){
        ++t;int pre;
        do{
          pre=zhan[Top--];
          num[pre]=t;++siz[t];
          v[t].push_back(pre);
        }while(pre!=to);
        num[u]=t;
        v[t].push_back(u);
        ++siz[t];
      }
    }
    else low[u]=min(low[u],dfn[to]);
  }
}

bool cmp(vector<int> x,vector<int> y){
  int len=min(x.size(),y.size());
  for(int i=0;i<len;i++){
    if(x[i]<y[i]) return true;
    else if(x[i]>y[i]) return false;
  }
  return x.size()<y.size();
}

int main(){
  n=read();m=read();
  for(int i=1,fr,to;i<=m;i++){
    fr=read();to=read();
    add(fr,to);add(to,fr);
  }
  for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
  printf("%d\n",t);
  for(int i=1,cnt=0;i<=t;i++)
    sort(v[i].begin(),v[i].end());
  sort(v+1,v+t+1,cmp);
  for(int i=1;i<=t;i++){
    int len=v[i].size();
    for(int j=0;j<len;j++){
      printf("%d ",v[i][j]);
    }
    puts("");
  } 
  return 0;
}
```


---

## 作者：Yun_Mengxi (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B3610)

[双倍经验](https://www.luogu.com.cn/problem/P8435)

## 题意

给定一个图，求点双连通分量数量（按字典序输出）和其中的节点（按从大到小输出）。

## 割点及点双连通分量的定义

### 割点的定义

对于一个连通图，如果一个点被删去后，图不连通，则称这个点为割点。

具体的解释可以看下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jc0bnphl.png)

### 点双连通分量的定义

如果一个连通图内，任意一个点都不是割点，那么称这个连通图为点双连通分量。

具体的解释可以看下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bs4xzij5.png)

## 题目分析

对于点双连通分量，可以用 Tarjan 算法求解，其中，判断割点的条件为 `u != root || son > 1`，其中，$u$ 代表需要判断的节点，$root$ 代表根，$son$ 代表子节点数量。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, M = 2e6 + 10;
int head[N], ver[2 * M], nxt[2 * M], tot = 1;
int n, m, dfn[N], low[N], num, rt;
int dcc, cut[N];     // 边双连通分量数量和是否为割点。
int stk[N], tp;      // 深搜栈和栈顶。
vector<int> DCC[N];  // 边双连通分量。

void addedge(int x, int y) {  // 建边。
  ver[++tot] = y;
  nxt[tot] = head[x];
  head[x] = tot;
}

void tarjan(int u) {  // 求强连通分量。
  dfn[u] = low[u] = ++num;    // 时间戳和回溯值赋值。
  int son = 0;               // 子节点数。
  stk[++tp] = u;              // 入栈
  for (int i = head[u]; i; i = nxt[i]) {  // 遍历子节点。
    int v = ver[i];
    if (!dfn[v]) {  // 没遍历过。
      tarjan(v);
      low[u] = min(low[u], low[v]);
      if (low[v] >= dfn[u]) {  // 满足条件。
        son++;
        if (u != rt || son > 1) cut[u] = 1;  // 满足是割点的条件。
        dcc++;                                // 把遍历到的点加入新的点双连通分量中。
        int z;
        do {
          z = stk[tp--];
          DCC[dcc].push_back(z);
        } while (z != v);
        DCC[dcc].push_back(u);
      }
    } else {
      low[u] = min(low[u], dfn[v]);  // 遍历过则只更新回溯值。
    }
  }
}

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1, u, v; i <= m; i++) {
    scanf("%d%d", &u, &v);
    if (u == v) continue;  // 自环。
    addedge(u, v);         // 建图。
    addedge(v, u);
  }
  for (int i = 1; i <= n; i++)  // 遍历图。
    if (!dfn[i]) {
      rt = i;
      tarjan(rt);
    }
  for (int i = 1; i <= dcc; i++) {  // 排序。
    sort(DCC[i].begin(), DCC[i].end());
  }
  sort(DCC + 1, DCC + dcc + 1);  // vector 自带比较器。
  printf("%d\n", dcc);           // 输出。
  for (int i = 1; i <= dcc; i++) {
    for (int j = 0; j < DCC[i].size(); j++) {
      printf("%d ", DCC[i][j]);
    }
    puts("");
  }
  return 0;
}
```

---

## 作者：scp020 (赞：2)

# B3610 [图论与代数结构 801] 无向图的块 题解

$2023$，再见。$2024$，你好！

## 解法

其实就是统计点双连通分量的个数。需要注意的是，孤立点在这里不被看作块。本文使用 tarjan 算法来解决这道题。

### 概念明晰

- 时间戳：这里记为 $dfn_i$，表示第一次深度优先搜索到节点 $i$ 的时间。时间 $time \in \mathbb{N}^+$ 且随这搜索依次递增。
- 搜索树：从选定的节点出发的深搜，每个节点仅搜索一次，把所有搜索路径组成一颗树，称为搜索树。如果给定的图不是一整个连通图，则称为搜索森林。
- 追溯值：这里记为 $low_i$，表示节点 $i$ 最多经过一条返祖边能走到搜索树中以 $i$ 的子树中的节点的最小 $dfn$ 为多少（简洁的定义出自东灯的博客）。
- 割点：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点。

### 追溯值的计算

首先根据定义，$low_i$ 的初始值应赋为 $dfn_i$。现在考虑怎么进一步更新 $low_i$。

- 如果在搜索树上 $i$ 是 $j$ 的父节点，则 $low_i = \min(low_i,low_j)$。
- 如果从 $i$ 到 $j$ 的连边不是搜索树上的边，则 $low_i= \min(low_i,dfn_j)$。

### 割点的判定方法

定义搜索树中节点 $i$ 的子树为 $son_i$。

- 如果 $i$ 不是搜索树的根，则当 $\exists dfn_i \le low_j,j \in son_i$ 时，$i$ 是割点。
- 如果 $i$ 是搜索树的根，则当有两个不同的 $j$ 满足上述条件时，$i$ 是割点。

### 判定方法的证明

如果 $dfn_i \le low_j$，则证明从 $j \in son_i$ 出发，不经过点 $i$ 无论如何也不能到达 $i$ 的祖先。所以如果把 $i$ 删去，则 $son_i$ 就会与原图分离。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Getchar() p1==p2 and (p2=(p1=Inf)+fread(Inf,1,1<<7,stdin),p1==p2)?EOF:*p1++
#define Putchar(c) p3==p4 and (fwrite(Ouf,1,1<<7,stdout),p3=Ouf),*p3++=c
char Inf[1<<7],Ouf[1<<7],*p1,*p2,*p3=Ouf,*p4=Ouf+(1<<7);
inline void read(int &x,char c=Getchar())
{
	bool f=c!='-';
	x=0;
	while(c<48 or c>57) c=Getchar(),f&=c!='-';
	while(c>=48 and c<=57) x=(x<<3)+(x<<1)+(c^48),c=Getchar();
	x=f?x:-x;
}
inline void write(int x)
{
	if(x<0) Putchar('-'),x=-x;
	if(x>=10) write(x/10),x%=10;
	Putchar(x^48);
}
struct my_stack
{
	int top,a[500010];
	inline int size()
	{
		return top;
	}
	inline int &operator[](const int &x)
	{
		return a[x];
	}
	inline int back()
	{
		return a[top];
	}
	inline void push_back(const int &x)
	{
		a[++top]=x;
	}
	inline void pop_back()
	{
		top--;
	}
	inline void clear()
	{
		top=0;
	}
};
my_stack v;
int n,m,head[500010],cnt,dfn[500010],low[500010],times,belong[500010],tot;
vector<int> ans[500010];
struct edge
{
	int to,next;
};
edge e[4000010];
inline void add(const int &x,const int &y) noexcept
{
	e[++cnt].to=y,e[cnt].next=head[x],head[x]=cnt;
}
inline void tarjan(const int &pos,const int &fa)
{
	int son=0;
	dfn[pos]=low[pos]=++times,v.push_back(pos);
	for(int i=head[pos];i;i=e[i].next)
		if(!dfn[e[i].to])
		{
			son++,tarjan(e[i].to,pos),low[pos]=min(low[pos],low[e[i].to]);
			if(low[e[i].to]>=dfn[pos])
			{
				tot++;
				while(v[v.top+1]!=e[i].to) ans[tot].push_back(v.back()),v.pop_back();
				ans[tot].push_back(pos);
			}
		}else if(e[i].to!=fa) low[pos]=min(low[pos],dfn[e[i].to]);
}
int main()
{
	read(n),read(m);
	for(int i=1,x,y;i<=m;i++) read(x),read(y),add(x,y),add(y,x);
	for(int i=1;i<=n;i++) if(!dfn[i]) v.clear(),tarjan(i,0);
	for(int i=1;i<=tot;i++) std::sort(ans[i].begin(),ans[i].end());
	std::sort(ans+1,ans+tot+1,[](std::vector<int> &lhs,std::vector<int> &rhs)
	{
		for(int i=0;i<std::min(lhs.size(),rhs.size());i++) if(lhs[i]!=rhs[i]) return lhs[i]<rhs[i];
		return lhs.size()<rhs.size();
	});
	write(tot),Putchar('\n');
	for(int i=1;i<=tot;i++,Putchar('\n'))
	{
		for(int j=0;j<ans[i].size();j++) write(ans[i][j]),Putchar(' ');
	}
	fwrite(Ouf,1,p3-Ouf,stdout),fflush(stdout);
	return 0;
}
```


---

## 作者：___w (赞：2)

### [B3610 [图论与代数结构 801] 无向图的块](https://www.luogu.com.cn/problem/B3610)

### 题意简述
给一个无向图，求每个点双连通分量，要求同一个双连通分量的点按照编号从小到大的顺序输出，每一个点双连通分量要按字典序进行排序。

### 题目分析
以下给出一些概念。
#### 时间戳
在图的深度优先遍历过程中，按照每个节点第一次被访问的时间顺序，依次给予 $N$ 个节点从 $1$ 到 $N$ 的整数标记，该标记称为时间戳，记为 $dfn_x$。

#### 搜索树
在无向图中任选一个节点出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 $(x,y)$（换言之，从 $x$ 到 $y$ 是对 $y$ 的第一次访问）构成一棵树。我们把它称为无向连通图的搜索树。当然，一般无向图（不一定连通）的各个连通块的搜索树构成无向图的搜索森林。

#### 追溯值
除了时间戳之外，Tarjan 算法还引入了一个追溯值 $low_x$。设 $subtree(x)$ 表示搜索树中以 $x$ 为根的子树。$low_x$ 定义为以下节点的时间戳的最小值：

1. $subtree(x)$ 中的节点。

2. 通过 $1$ 条不在搜索树上的边，能够到达 $subtree(x)$ 的节点。

#### 割点判定法则
若 $x$ 不是搜索树的根节点（深度优先遍历的起点），则 $x$ 是割点当且仅当搜索树上存在 $x$ 的一个子节点 $y$，满足：

$$dfn_x\le low_y$$

特别地，若 $x$ 是搜索树的根节点，则 $x$ 是割点当且仅当搜索树上存在至少两个子节点 $y1,y2$ 满足上述条件。

#### 点双连通分量
若一张无向连通图不存在割点，则称它为点双连通图。

无向图的极大点双联通子图被称为点双联通分量，简记为 v-DCC。

在上面的定义中，我们称一个双连通子图 $G'=(V',E')$ “极大（其中 $V'\subseteq V, E'\subseteq E$），是指不存在包含 $G'$ 的更大的子图 $G''=(V'',E'')$，满足 $V'\subseteq V''\subseteq V$ 也是双连通子图。

#### v-DCC 求法
若每个节点为孤立点，则它自己单独构成一个 v-DCC。除了孤立点之外，点双连通分量的大小至少为 $2$。根据 v-DCC 定义中的“极大”性，虽然桥（割边）不属于任何 e-DCC（边双连通分量），但是割点可能属于多个 v-DCC。

我们考虑使用上面的 $dfn$ 和 $low$ 来求，我们将深度优先遍历时遇到的所有边加入到栈里面，当找到一个割点的时候，就将这个割点往下走到的所有边弹出，而这些边所连接的点就是一个点双连通分量了。

具体来说，需要在 Tarjan 算法的过程中维护一个栈，并按照如下方法维护栈中的元素：

当一个节点第一次被访问时，把该节点入栈。

当割点判定法则中的条件 $\mathit dfn_x\leq \mathit low_y$ 成立时，此时 $x$ 是割点，$subtree(y)$ 为一个点双连通分量。为了得到 $subtree(y)$，无论 $x$ 是否为根，都要将 $subtree(y)$ 弹出，具体操作如下：

1. 栈顶为 $subtree(y)$ 的最底端（最深处），从栈中不断弹出节点，直至节点 $y$ 被弹出（$y$ 要弹出）。

2. 刚才弹出的所有节点与节点 $x$ 一起构成一个 v-DCC。

当然，本题不求孤立点，只需对 v-DCC 排个序即可，具体看代码。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e4+5, M = 5e5+5;
struct edge {
	int to, next;
} e[M];
int n, m, tot, num, top, cnt, root, dfn[N], low[N], cut[N], head[N], stk[N];
vector <int> dcc[N];
void add(int x, int y) {
	e[++tot] = (edge){y, head[x]};
	head[x] = tot;
}
void tarjan(int x) {
	dfn[x] = low[x] = ++num, stk[++top] = x;
	int flag = 0;
	for (int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
			if (low[y] >= dfn[x]) {
				++flag;
				if (x != root || flag > 1) cut[x] = 1;
				++cnt;
				int z = 0;
				do {
					z = stk[top--];
					dcc[cnt].push_back(z);
				} while (z != y);
				dcc[cnt].push_back(x);
			}
		}
		else low[x] = min(low[x], dfn[y]);
	}
}
bool cmp(vector <int> x, vector <int> y) {
	int len = min(x.size(), y.size());
	for (int i = 0; i < len; ++i) {
		if (x[i] < y[i]) return 1;
		if (x[i] > y[i]) return 0;
	}
	return x.size() < y.size();
}
int main() {
	cin >> n >> m;
	for (int u, v; m--; ) {
		cin >> u >> v;
		if (u == v) continue;
		add(u, v), add(v, u);
	}
	for (int i = 1; i <= n; ++i) if (!dfn[i]) root = i, tarjan(i);
	for (int i = 1; i <= cnt; ++i) sort(dcc[i].begin(), dcc[i].end());
	sort(dcc+1, dcc+cnt+1, cmp);
	cout << cnt << '\n';
	for (int i = 1; i <= cnt; ++i, puts(""))
		for (int j = 0; j < dcc[i].size(); ++j)
			cout << dcc[i][j] << ' ';
	return 0;
}
```
#### 注：参考书籍《算法竞赛进阶指南》。

---

## 作者：Mars_Dingdang (赞：2)

本题所说的块即点双连通分量。

## 题目大意
给定一张 $n$ 个节点 $m$ 条边的无向图，求出所有的点双连通分量，孤立点除外，并按字典序输出。

## 大体思路
前置定理：若一个点 $u$ 为割点，则 $\exists v\in son(u)$，满足 $low_v\ge dfn_u$。

若一张无向连通图不存在割点/边，则称其为点/边双连通图。无向图的极大点双连通子图被称为点双连通分量 v-DCC，即 vertex double connected component，无向图的极大边双连通子图被称为边双连通分量 e-DCC，即 edge DCC。

上述定义中，称一个双连通子图 $G'(V',E')$ 极大，其中 $V'⊆V,E'⊆E$，指不存在包含 $G'$ 的更大的子图 $G''$，使得 $V'⊂V''⊆ V,E'⊂E''⊆E$ 且 $G''$ 是双连通.
	
一个图是点双连通图，当且仅当图的结点数不超过 $2$，或图中任意两点都包含在一个简单环中。一个图是边双连通图，当且仅当图中任意一条边都包含在一个简单环中。当结点数不超过 $2$ 时，显然成立。因此不妨设结点数不小于 $3$ ，以下是定理的充要性证明。

1. 充分性：若任意两节点 $x,y∈V$ 都存在于一个简单环中，则删去图中任意其他节点，$x,y$ 均能从环的两条路径之一到达对方，因此图中不存在割点。同理，若任意一条边 $(x,y)∈E$ 都包含在一个简单环中，则该边所在环上的其他节点之间连通性不变，因此不存在割边。

2. 反证法证明必要性：假设一张图是点双连通图，且存在两节点 $x,y$ 不在同一个简单环中。若两节点路径唯一，则该路径上必然存在割点，与假设矛盾；若路径不唯一，必然任意两条路径交于 $x,y$ 以外的一点 $p$，否则构成简单环，此时 $p$ 是割点，与假设矛盾。

点双连通分量的求法较边双连通分量更难一点。若某个节点为孤立点，其为点双连通分量（**但本题不考虑**）；否则 v-DCC 的大小至少为 $2$。根据“极大”性，割点可能属于多个 v-DCC。

为了求出点双连通分量，需要在 tarjan 算法过程中维护一个栈，在每个节点第一次被访问时入栈；当满足 $dfn_x≤low_y$ 成立时，无论 $x$ 是否为根，都要将栈顶元素弹出直到节点 $y$ 被弹出，然后所有被弹出的节点和 $x$ 共同构成一个 v-DCC。

最后，本题还要求按照字典序输出，只需对每一个储存 v-DCC 的 vector 进行内部排序，再自定义比较函数对所有 vector 进行排序即可。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef double db;
const int maxn = 5e4 + 4, maxm = 6e5 + 5;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, head[maxn], ver[maxm], nxt[maxm], tot;
int cnt, Min[maxn];
vector <int> dcc[maxn];
int stk[maxn], top;
int dfn[maxn], timer, low[maxn], root;
inline void add(int u, int v) {
	ver[++tot] = v; nxt[tot] = head[u]; head[u] = tot;
	ver[++tot] = u; nxt[tot] = head[v]; head[v] = tot;
}
bool cut[maxn];
inline void dfs(int u) { // Tarjan
	dfn[u] = low[u] = ++timer;
	stk[top++] = u;
	if(u == root && head[u] == 0) return;
	int flag = 0; 
	for(int i = head[u]; i; i = nxt[i]) {
		int v = ver[i];
		if(!dfn[v]) {
			dfs(v);
			low[u] = min(low[u], low[v]);
			if(low[v] >= dfn[u]) {
				flag ++;
				if(u != root || flag > 1) cut[u] = 1;
				Min[++cnt] = u;
				while (1) {
					int x = stk[--top];
					dcc[cnt].push_back(x);
					Min[cnt] = min(Min[cnt], x);
					if(x == v) break;
				}
				dcc[cnt].push_back(u);
			}
		}
		else low[u] = min(low[u], dfn[v]);
	}
}
bool cmp(vector <int> &a, vector<int> &b) {// 比较函数
	for(int i = 0; i < min(a.size(), b.size()); i ++) {
		if(a[i] < b[i]) return 1;
		else if(a[i] > b[i]) return 0;
	}
	return a.size() < b.size();
}
int id[maxn];
int main () {
	read(n); read(m);
	rep(i, 1, m) {
		int u, v;
		read(u); read(v);
		if(u != v) add(u, v);
	}
	rep(i, 1, n)// Tarjan
		if(!dfn[i]) root = i, dfs(i);
	rep(i, 1, cnt) {
		id[i] = i;
		sort(dcc[i].begin(), dcc[i].end());
	}
	sort(dcc + 1, dcc + cnt + 1, cmp); // 排序
	writeln(cnt);
	rep(i, 1, cnt) {
		for(int j = 0; j < dcc[i].size(); j ++) {
			write(dcc[i][j]);
			putchar(' ');
		} putchar('\n');
	}// 输出
	return 0;
}
```

---

## 作者：hzoi_Shadow (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3610)

# 前言

本题解内容均摘自我的 [ Tarjan 学习笔记](https://www.cnblogs.com/The-Shadow-Dragon/p/17548536.html) 。

# 解法
## Tarjan 与无向图
### 无向图与割点（割顶）
- 在一个无向图中，不存在横叉边（因为边是双向的）。
- 一个无向图中，可能不止存在一个割点。
- 割点（割顶）：在一个无向图中，若删除节点 $x$ 以及所有与 $x$ 相关联的边之后，图将会被分成两个或者两个以上不相连的子图，那么称 $x$ 为这个图的割点（割顶）。
- 判定法则：
当遍历到一个节点 $x$ 时，这个点为割点的情况有两种：
    - 该节点为根节点且子节点的个数大于 $1$（易知此时对于 $x$ 的任意一个子节点 $y$ 都有 $dfn_x<low_y$），则删掉这个节点 $x$ 后必将导致子节点不连通，即该节点 $x$ 为图的一个割点。
    - 该节点不为根节点，且存在一个子节点 $y$ 使得 $dfn_x \le low_y$（子节点 $y$ 可回溯到的最早节点不早于 $x$ 点，即子节点 $y$ 无法回到 $x$ 的祖先节点），则删掉这个节点 $x$ 后必将导致 $x$ 的父节点与 $x$ 的子节点不连通，即该节点 $x$ 为图的一个割点。
    - 若不存在一个子节点 $y$ 使得 $dfn_x \le low_y$，说明子节点 $y$ 能绕行其他边到达比 $x$ 更早访问的节点，$x$ 就不是本图的割点，即环内的点割不掉。
- 应用：如图，节点 $(0,4,5,6,7,11)$ 为割点。

  ![](https://cdn.luogu.com.cn/upload/image_hosting/0at9rrb7.png)

### 无向图与双连通分量
- 若一个无向连通图不存在割点，则称它为点双连通图。
- 无向图中极大的点双连通子图叫点双连通分量，即 v-DCC。
- 在一张连通的无向图中，对于两个点 $x$ 和 $y$，如果删去哪个点（只能删去一个，且不能删去 $x$ 和 $y$ 自己）都不能使它们不连通，我们就说 $x$ 和 $y$ 点双连通。
### 点双连通分量
- 点双连通分量
    - 若某个点为孤立点，则它自己单独构成一个 v-DCC。
    - 除了孤立点之外，点双连通分量的大小至少为 $2$。
    - 性质
      - 点双连通分量之间以割点连接，且两个点双连通分量之间有且只有一个割点。
        - 证明：若两个点双连通分量之间共用两个点，则删除其中任意一个点，所有点依旧连通。如图

          ![](https://cdn.luogu.com.cn/upload/image_hosting/gwlpctns.png)

      - 每一个割点可任意属于多个点双连通分量，因此求点双连通分量时，可能包含重复的点。
      - 每一个割点都在至少两个点双连通分量中。
        - 证明：在一个非点双连通图中，删去割点后图会不连通，故割点至少连接着图的两部分。但是因为点双连通图中不存在割点，所以这两部分肯定不在同一个点双连通分量中。因此割点至少存在于两个点双连通分量中。
      - 只有一条边连通的两个点也是一个点双连通分量。如图
          
          ![](https://cdn.luogu.com.cn/upload/image_hosting/sket3kgn.png)

      - 除了上一条中的情况外，其他的点双连通分量都满足任意两点间都存在不少于两条点不重复路径。
      - 任意一个不是割点的点都只存在于一个点双连通分量中。
      - 点双连通不具有传递性，如图，$(1,3)$ 点双连通，$(1,7)$ 点双连通，但是 $(3,7)$ 不点双连通。

        ![](https://cdn.luogu.com.cn/upload/image_hosting/vo78orp3.png)

    - 应用：如图，存在 $(1,2,3),(3,4),(4,5,6)$ 这三个点双连通分量。

        ![](https://cdn.luogu.com.cn/upload/image_hosting/pzv255tj.png)

    - 算法
      - 用一个栈存点，若遍历回到 $x$ 时，发现割点判定法则 $dfn_x \le low_y$ 成立，则从栈中弹出节点，直到 $y$ 被弹出。那么，刚才弹出的节点和 $x$ 一起构成一个 v-DCC。
    - 例题
      - [luogu P8435 【模板】点双连通分量](https://www.luogu.com.cn/problem/P8435) 
        - 事实上在求割点的同时，同时可以顺便求出点双连通分量，维护一个栈在求割点的途中若有 $dfn_x>low_y$，则将 $(x,y)$ 入栈；而当 $dfn_x \le low_y$ 时，将栈中所有在 $(x,y)$ 之上的边全部取出，这些边所连接的点与 $x$ 构成了一个点双连通分量，显然割点是可以属于多个点双连通分量的。
        - 每当新搜到一个节点时，将其压入栈中。
        - 当发现 $x$ 的子节点 $y$ 不能通过其他方式到达 $x$ 的祖先，但可以到达 $x$（即 $dfn_x \le low_y$ 成立），则弹出栈顶元素直到 $y$ 弹出。
        - 弹出的所有元素组成的集合 $E$ 加上 $x$，则为一个点双连通分量。
            ```cpp
            #include<bits/stdc++.h>
            using namespace std;
            #define ll long long 
            #define endl '\n'
            struct node
            {
                int next,to;
            }e[4000001];
            vector<int>v_dcc[4000001];
            stack<int>s;
            int head[4000001],dfn[4000001],low[4000001],cnt=0,tot=0,ans=0;
            void add(int u,int v)
            {
                cnt++;
                e[cnt].next=head[u];
                e[cnt].to=v;
                head[u]=cnt;
            }
            void tarjan(int x,int fa)
            {
                int i,k=0;
                if(x==fa&&head[x]==0)//孤立点判定
                {
                    ans++;
                    v_dcc[ans].push_back(x);
                }
                tot++;
                dfn[x]=low[x]=tot;
                s.push(x);
                for(i=head[x];i!=0;i=e[i].next)
                {
                    if(dfn[e[i].to]==0)
                    {
                        tarjan(e[i].to,fa);
                        low[x]=min(low[x],low[e[i].to]);
                        if(low[e[i].to]>=dfn[x])
                        {
                            ans++;
                            v_dcc[ans].push_back(x);
                            while(e[i].to!=k)//弹栈时不能弹出割点，因为割点属于多个点双连通分量
                            {
                                k=s.top();
                                v_dcc[ans].push_back(k);
                                s.pop();
                            }                
                        }
                    }
                    else
                    {
                        low[x]=min(low[x],dfn[e[i].to]);
                    }
                }
            }
            int main()
            {
                int n,m,i,j,u,v;
                cin>>n>>m;
                for(i=1;i<=m;i++)
                {
                    cin>>u>>v;
                    if(u!=v)//重边会影响结果，记得特判
                    {
                        add(u,v);
                        add(v,u);
                    }
                }
                for(i=1;i<=n;i++)
                {
                    if(dfn[i]==0)//注意图可能不连通
                    {
                        tarjan(i,i);
                    }
                }
                cout<<ans<<endl;
                for(i=1;i<=ans;i++)
                {
                    cout<<v_dcc[i].size()<<" ";
                    for(j=0;j<v_dcc[i].size();j++)
                    {
                        cout<<v_dcc[i][j]<<" ";
                    }
                    cout<<endl;
                }
                return 0;
            }
            ```
      - [luogu B3610 [图论与代数结构 801] 无向图的块](https://www.luogu.com.cn/problem/B3610)
        - 此题中的块即为大小不为 $1$ 的点双连通分量，故不需要判断孤立点了。
        - 再按字典序排序一下就行。
        ```cpp
        #include<bits/stdc++.h>
        using namespace std;
        #define ll long long 
        #define endl '\n'
        struct node
        {
            int next,to;
        }e[4000001];
        vector<int>v_dcc[4000001];
        stack<int>s;
        int head[4000001],dfn[4000001],low[4000001],cnt=0,tot=0,ans=0;
        void add(int u,int v)
        {
            cnt++;
            e[cnt].next=head[u];
            e[cnt].to=v;
            head[u]=cnt;
        }
        void tarjan(int x,int fa)
        {
            int i,k=0;
            tot++;
            dfn[x]=low[x]=tot;
            s.push(x);
            for(i=head[x];i!=0;i=e[i].next)
            {
                if(dfn[e[i].to]==0)
                {
                    tarjan(e[i].to,fa);
                    low[x]=min(low[x],low[e[i].to]);
                    if(low[e[i].to]>=dfn[x])
                    {
                        ans++;
                        v_dcc[ans].push_back(x);
                        while(e[i].to!=k)
                        {
                            k=s.top();
                            v_dcc[ans].push_back(k);
                            s.pop();
                        }                
                    }
                }
                else
                {
                low[x]=min(low[x],dfn[e[i].to]);
                }
            }
        }
        bool cmp(vector<int> x,vector<int> y)
        {
            for(int i=0;i<min(x.size(),y.size());i++)
            {
                if(x[i]!=y[i])
                {
                    return x[i]<y[i];
                }
            }
            return x.size()<y.size();
        }
        int main()
        {
            int n,m,i,j,u,v;
            cin>>n>>m;
            for(i=1;i<=m;i++)
            {
                cin>>u>>v;
                if(u!=v)
                {
                    add(u,v);
                    add(v,u);
                }
            }
            for(i=1;i<=n;i++)
            {
                if(dfn[i]==0)
                {
                    tarjan(i,i);
                }
            }
            cout<<ans<<endl;
            for(i=1;i<=ans;i++)
            {
                sort(v_dcc[i].begin(),v_dcc[i].end());
            }
            sort(v_dcc+1,v_dcc+1+ans,cmp);
            for(i=1;i<=ans;i++)
            {
                for(j=0;j<v_dcc[i].size();j++)
                {
                    cout<<v_dcc[i][j]<<" ";
                }
                cout<<endl;
            }
            return 0;
        }
        ```

---

## 作者：Jeremiahy (赞：0)

无向图的块实际上就是点双连通分量，下面我们来介绍 Tarjan 算法，割点与点双连通分量及其求法。

# Tarjan 算法与割点

### 概念

给定无向图 $G=(V,E)$：

若对于 $x\in V$，从图中删去节点 $x$ 以及所有与 $x$ 关联的边之后，$G$ 分裂成两个或两个以上不相连的子图，则称 $x$ 为 $G$ 的**割点**。

一般无向图（不一定连通）的割点就是它的各个连通块的割点。

而由著名计算机科学家 Robert Tarjan 的名字命名的 Tarjan 算法能够在线性时间内求出无向图的割点，进一步可求出无向图的双连通分量。 Tarjan 算法基于无向图的深度优先遍历，下面介绍一些相关概念。

#### 时间戳

在图的深度优先遍历过程中，按照每个节点第一次被访问的时间顺序，依次给予 $N$ 个节点从 $1$ 到 $N$ 的整数标记，该标记称为**时间戳**，记为 $dfn_x$。

#### 搜索树

在无向图中任选一个节点出发进行深度优先遍历，每个点只访问一次。所有发生递归的边 $(x,y)$（换言之，从 $x$ 到 $y$ 是对 $y$ 的第一次访问）构成一棵树。我们把它称为**无向连通图的搜索树**。当然，一般无向图（不一定连通）的各个连通块的搜索树构成无向图的搜索森林。

下图左侧展示了一张无向连通图，灰色节点是深度优先遍历的起点，加粗的边是发生递归的边（假设我们在遇到多个分支时，总是优先访问最靠左的一条）。右侧展示了深度优先遍历的搜索树，并标注了节点的时间戳。

![](https://cdn.luogu.com.cn/upload/image_hosting/ryswqep8.png)

#### 追溯值

除了时间戳之外， Tarjan 算法还引入了一个**追溯值** $low_x$。设 $subtree(x)$ 表示搜索树中以 $x$ 为根的子树。$low_x$ 定义为以下节点的时间戳的最小值：

1. $subtree(x)$ 中的节点。

1. 通过 $1$ 条**不在搜索树上的边**，能够到达 $subtree(x)$ 的节点。

以上图为例。为了叙述简便，我们用时间戳代表节点编号。$subtree(2)=\{2,3,4,5\}$。另外，节点 $1$ 通过不在搜索树上的边 $(1,5)$ 能够到达 $subtree(2)$。所以 $low_2=1$。

### 求法

根据定义，为了计算 $low_x$，应该先令 $low_x=dfn_x$，然后考虑从 $x$ 出发的每条边 $(x,y)$：

若在搜索树上 $x$ 是 $y$ 的父节点，则令 $low_x=\min(low_x,low_y)$。

若无向边 $(x,y)$ 不是搜索树上的边，则令 $low_x=\min(low_x,dfn_y)$。

下图中括号里的数值标注了每个节点的追溯值 $low$。

![](https://cdn.luogu.com.cn/upload/image_hosting/bt771s0u.png)

#### 割点判定法则

若 $x$ 不是搜索树的根节点（深度优先遍历的起点），则 $x$ 是割点当且仅当搜索树上存在 $x$ 的一个子节点 $y$，满足：

$\hspace{15.0em}$ $dfn_x\le low_y$

特别地，若 $x$ 是搜索树的根节点，则 $x$ 是割点当且仅当搜索树上存在**至少两个**子节点 $y1,y2$ 满足上述条件。

#### 证明：

根据定义，$dfn_x\le low_y$ 说明从 $subtree(y)$ 出发，无论如何也无法到达比 $x$ 更早访问的节点。换句话说，只有节点 $x$ 上有若干条边通向 $subtree(y)$，$x$ 便是它通向外界的唯一通道，$suntree(y)$ 中所有节点的 $dfn$ 都必须大于等于它， 而不能小于它。断开节点 $x$ 后，$subtree(y)$ 好像形成了一个封闭的环境，没有边与比 $x$ 更早的节点相连，图断开成了两部分，因此 $x$ 是割点。

反之，若不存在子节点 $y$，使得 $dfn_x\le low_y$，则说明每个 $subtree(y)$ 都能绕行其他边到达比 $x$ 更早访问的节点，$x$ 自然不是割点。

对于根节点 $x$，若想分为两个及以上不相连的子图，自然是需要两个及以上不相连的子树才能办到。

 _证毕。_ 

在上图中，共有两个割点，分别是时间戳为 $1$ 和 $6$ 的两个点。

下面的程序求出一张无向图中所有的割点。因为割点判定法则是小于等于号，所以在求割点时，不必考虑父节点和重边的问题，从 $x$ 出发能访问到的所有点的时间戳都可以用来更新 $low_x$。


```cpp

const int SIZE = 100010;
int head[SIZE], ver[SIZE * 2], Next[SIZE * 2];
int dfn[SIZE], low[SIZE], stack[N];
int n, m, tot = 1, num, root;
bool cut[SIZE];
void add(int x, int y) { // 邻接表存图
	ver[++tot] = y, Next[tot] = head[x], head[x] = tot;
}
void tarjan(int x) { 
	dfn[x] = low[x] = ++num; //按照访问顺序初始化 x 节点的 dfn 与 low 值
	int flag = 0;
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
			if (low[y] >= dfn[x]) {
				flag++;
				if (x != root || flag > 1) cut[x] = true;//割点判定法则
			}
		} 
		else
			low[x] = min(low[x], dfn[y]);
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for (register int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		if (x == y)
			continue;
		add(x, y), add(y, x);//正反向存边
	}
	for (register int i = 1; i <= n; i++)
		if (!dfn[i])
			root = i, tarjan(i);
	return 0;
}

```



### 练习

[P3388 割点](https://www.luogu.com.cn/problem/P3388)

[P3469 [POI2008]BLO-Blockade](https://www.luogu.com.cn/problem/P3469)


# 点双连通分量
### 概念

若一张无向连通图不存在割点，则称它为**点双连通图**。

无向图的**极大**点双联通子图被称为**点双联通分量**，简记为 **v-DCC**。

在上面的定义中，我们称一个双连通子图 $G'=(V',E')$ “极大（其中 $V'\subseteq V, E'\subseteq E$），是指不存在包含 $G'$ 的更大的子图 $G''=(V'',E'')$，满足 $V'\subseteq V''\subseteq V$， $E' \subseteq E''\subseteq E$ 并且 $G''$ 也是双连通子图。

### 定理

一张无向图是点双连通图，当且仅当满足下列**两个条件之一**：

1. 图的顶点数不超过 $2$。

1. 图中任意两点都同时包含在**至少一个**简单环中。其中“简单环”指的是不自交的环，也就是我们通常画出的环。

#### 证明：
对于顶点数不超过 $2$ 的情况，定理显然成立，下面假设图中顶点数不小于 $3$。

先证充分性。若任意两点 $x$，$y$ 都同时包含在至少一个简单环中，则 $x$，$y$ 之间至少有两条不相交的路径。无论从图中删除哪个节点，$x$，$y$ 均能通过两条路径之一相连。故图中不存在割点，是点双连通图。

再证必要性。反证法，假设一张无向图是“点双连通图”，并且存在两点 $x$，$y$，他们不同时处于任何一个简单环中。

如果 $x$，$y$ 之间仅存在 $1$ 条简单路径，那么路径上至少有一个割点，与“点双连通”矛盾。

如果 $x$，$y$ 之间存在 $2$ 条或 $2$ 条以上的简单路径，那么容易发现，任意两条都至少有一个除 $x$，$y$ 之外的交点；进一步可推导出，$x$，$y$ 之间的所有路径必定同时交于除 $x$，$y$ 之外的某一点 $p$（不然就会存在两条没有交点的路径，形成一个简单环，如下图所示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/o9pt519w.png)

根据定义，$p$ 是一个割点，与点双连通矛盾。故假设不成立。

证毕。

### 性质

1. 除了仅包含两个点一条边的点双外，其他点双都满足：任意两点间都存在至少两条点不重复路径。

1. 图中任意一个割点都在至少两个点双中。

1. 两个点双至多存在一个公共点——割点。

1. 任意一个不是割点的点都只存在于一个点双中，割点也一定属于两个及以上的点双。

#### 证明

对于第一点，可以用点双连通分量的定义来解释：因为点双内无割点，所以两个点间一定会有多条边互通（否则就会存在割点）。

对于第二点，因为删去割点后图会不连通，所以割点至少连接着图的两部分，而由于点双中不能有割点，所以这两部分肯定不在同一个点双中，所以割点至少存在于两个点双中。

对于第三点，用反证法，假设存在两个及以上的公共点，那这两个点双就可以通过两条及以上的边相连，那么这就变成一个点双了，与定义矛盾，故假设不成立。如果这个公共点不是割点，那么说明两个点双还有别的边相连，同样变成一个点双，所以公共点一定是割点。

对于第四点，若点在两个及以上点双中，那么删去它就可以分成两个及以上的点双，它就一定是割点；而割点如果只属于一个点双，删去它后图依然连通，这个点就不是割点了，所以割点一定属于两个及以上的点双。
### 求法

点双连通分量是一个极其容易误解的概念。它与删除割点后图中剩余的连通块是不一样的，请格外留意。

若每个节点为孤立点，则它自己单独构成一个 v-DCC。除了孤立点之外，点双连通分量的大小至少为 $2$。根据 v-DCC 定义中的“极大”性，虽然桥（割边）不属于任何 e-DCC（边双连通分量），但是割点可能属于多个 v-DCC。下面的无向图共有 $2$ 个割点，$4$ 个点双连通分量。


![](https://cdn.luogu.com.cn/upload/image_hosting/0m1veoit.png)

我们考虑使用上面的 $dfn$ 和 $low$ 来求，我们将深度优先遍历时遇到的所有边加入到栈里面，当找到一个割点的时候，就将这个割点往下走到的所有边弹出，而这些边所连接的点就是一个点双了。

具体来说，需要在 Tarjan 算法的过程中维护一个栈，并按照如下方法维护栈中的元素：

1. 当一个节点**第一次**被访问时，把该节点入栈。

1. 当割点判定法则中的条件 $\mathit dfn_x\leq \mathit low_y$ 成立时，此时 $x$ 是割点，$subtree(y)$ 为一个点双连通分量。为了得到 $subtree(y)$，**无论** $x$ **是否为根**，都要将 $subtree(y)$ 弹出，具体操作如下：
	
    （1）栈顶为 $subtree(y)$ 的最底端（最深处），从栈中不断弹出节点，直至节点 $y$ 被弹出（$y$ **要弹出**）。
    
    （2）刚才弹出的所有节点**与节点** $x$ **一起**构成一个 v-DCC。

下面的程序在求出割点的同时，计算出 vector 数组 $dcc$，$\mathit dcc_i$ 保存编号为 $i$ 的 v-DCC 中的所有节点。

上述做法是点双连通分量模板的求法，对于本题有些变化：

1. 要求按字典序排列。写一个比较函数排下序就可以了。

1. 一个单独的点构成的连通块不算是块，这我们需要把孤立点去除。

然后就可以愉快地 ```AC``` 了。

### 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
#define int long long
const int N = 50005, M = 300005;
int head[N], ver[M], Next[M];
int dfn[N], low[N], c[N], stack[N];
int n, m, tot = 1, num, root, top, cnt;
bool cut[N];
vector<int> dcc[N];//dcc[i] 存储编号为 i 的 v-DCC 中的所有节点

void add(int x, int y) {//邻接表存图
	ver[++tot] = y, Next[tot] = head[x], head[x] = tot;
}

void tarjan(int x) {
	dfn[x] = low[x] = ++num;
	stack[++top] = x;
	//if (x == root && head[x] == 0) {//孤立点，不过本题不需要
		//dcc[++cnt].push_back(x);
		//return;
	//}
	int flag = 0;
	for (int i = head[x]; i; i = Next[i]) {
		int y = ver[i];
		if (!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x], low[y]);
			if (low[y] >= dfn[x]) {
				flag++;
				if (x != root || flag > 1)
					cut[x] = true;
				cnt++;
				int z;
				do {
					z = stack[top--];
					dcc[cnt].push_back(z);
				} while (z != y);
				dcc[cnt].push_back(x);
			}
		} else
			low[x] = min(low[x], dfn[y]);
	}
}

bool cmp(vector<int> x, vector<int> y){//字典序排序函数
  	for (register int i = 0; i < min(x.size(), y.size()); i++) {
    	if (x[i] < y[i]) 
			return true;
    	else if (x[i] > y[i]) 
			return false;
  	}
  	return x.size() < y.size();
}

signed main() {
	ios::sync_with_stdio(false);//关闭与scanf的同步来提速
	cin >> n >> m;
	for (register int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		if (x == y)
			continue;
		add(x, y), add(y, x);
	}
	for (register int i = 1; i <= n; i++)
		if (!dfn[i])
			root = i, tarjan(i);
	for (register int i = 1; i <= cnt; i++) 
		sort(dcc[i].begin(), dcc[i].end());//排序
	sort(dcc + 1, dcc + cnt + 1, cmp);
	cout << cnt << "\n";
	for (register int i = 1; i <= cnt; i++) {//输出
		for (register int j = 0; j < dcc[i].size(); j++)
			cout << dcc[i][j] << ' ';
		cout << "\n";
	}
	return 0;
}
```

### 练习
[P8435 【模板】点双连通分量](https://www.luogu.com.cn/problem/P8435)。

[P8436 【模板】边双连通分量](https://www.luogu.com.cn/problem/P8436)。

注：本文大部分抄自 lyd 蓝书。



---

## 作者：Eltaos_xingyu (赞：0)

这是一道模板题。

## 割点

割点指的是删除这个点和其相连的所有边之后，原图不再连通的点。

我们使用 Tarjan 算法求解割点。当一个点的 $dfn_i\leq low_i$ 时，该点为割点。

这很好证明。当这个点以下遍历到的点不能回溯到这个点以上的点，那么这个点以下的所有点在删掉这个点时一定无法连通到前面的点。故该点是割点。

## 点双连通分量

当一个图中没有割点，那么这个图点双连通。

称一个图中的**极大**点双连通子图是点双连通分量。

求解点双连通分量时，要先求割点。用栈维护当前点用 dfs 序排序过后的排列。当求到一个割点时，就把栈内的元素弹出到割点。注意割点本身不能弹出，要留着，下一个点双连通分量可能会用到这个割点。

可以自行画图理解一下该过程。

核心代码见下，打数字的地方是我错了的地方：

```cpp
void tarjan(int s,int fa){
	low[s]=dfn[s]=++dfncnt;
	int soncnt=0;
	temp.push(s);
	for(int i=head[s];i;i=E[i].link){
		if(E[i].to==fa)continue;
		if(!dfn[E[i].to]){
			tarjan(E[i].to,s);
			soncnt++;
			low[s]=min(low[s],low[E[i].to]);
			if(low[E[i].to]>=dfn[s]){//1
				if(temp.empty())continue;//3
				cnt++;
				int x=0;
				while(x!=E[i].to&&!temp.empty()){//2
					x=temp.top();
					temp.pop();
					ans[cnt].push_back(x);
				}
				ans[cnt].push_back(s);
                sort(ans[cnt].begin(),ans[cnt].end());
			}
		}
		else low[s]=min(low[s],dfn[E[i].to]);
	}
	return;
}
```


---

## 作者：快斗游鹿 (赞：0)

## 概念

**割点**：在无向图中，若删除某个顶点后，这个图就不再连通，则称这个顶点为割点。例如，在下面的图中，点 $1$ 就是一个割点。

![](https://cdn.luogu.com.cn/upload/image_hosting/oiqgbe29.png)

**点双连通**：若无向连通图中不存在割点，则称它为点双连通图。

**点双连通分量**：即无向图中，极大的点双连通子图。

## Tarjan 算法

### 如何求割点

首先从任意一个点开始，使用深度优先搜索对图进行遍历。定义 $dfn_u$ 表示点 $u$ 的时间戳（即第几个被搜到的），$low_u$ 表示点 $u$ 在不经过其父顶点时，能够回到的最小时间戳。

若对于一个顶点 $u$，如果存在至少一个顶点 $v$（即点 $u$ 的儿子），使得 $low_v \ge dfn_u$，则点 $u$ 是割点。对于下面这个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/s2w6fb0l.png)

假设我们从点 $1$ 开始遍历，则 $dfn_1=1$，但对于其儿子点 $4$，$low_4=1$，即点 $4$ 在不经过点 $1$ 的情况下，能够回到的最小时间戳也就是 $1$。这时点 $1$ 就是割点。

开始，我们令所有 $low_u=dfn_u$，然后考虑从点 $u$ 出发的每条边 $(u,v)$。若点 $v$ 没有被访问过，则 $low_u=\min(low_u,low_v)$。若 $y$ 被访问过，则 $low_u=\min(low_u,dfn_v)$。

求割点核心代码：

```
void dfs(int u,int fa){
	dfn[u]=low[u]=++tot;
    int count=0;
	for(int i=0;i<e[u].size();i++){
		int v=e[u][i];
		if(dfn[v])low[u]=min(low[u],dfn[v]);//如果点v被访问过了
		else if(!dfn[v]){//点v还没被访问
			dfs(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
                count++;
                if(u!=fa||count>1)flag[u]=1;
            }
		}
	}
}
```

### 如何求点双连通分量

既然会求割点了，那求点双连通分量也就不是什么难事。定义一个二维数组 $ans$，存放每个点双连通分量中的点。

遍历时，将遍历到的顶点都扔到一个栈里。遇到割点时，令该点为点 $u$，我们就不断地从栈里弹出元素，并存入 $ans$ 数组中，直到弹出了点 $v$（即点 $u$ 的儿子），最后将点 $u$ 也存入。但注意不能弹出点 $u$，因为一个割点可能是两个及以上的点双连通分量的公共点。另外，对于根节点，无论它是不是割点，都要进行出栈操作。

## 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+5;
ll n,m,tot,cnt,dfn[N],low[N],d[N];
vector<ll>e[N],ans[N];
stack<ll>st;
void tarjan(ll u,ll fa){
	dfn[u]=low[u]=++tot;st.push(u);//将顶点扔到栈里
	ll ct=0;
	for(int i=0;i<e[u].size();i++){
		ll v=e[u][i];//cout<<v<<" "<<fa<<endl;
		if(dfn[v])low[u]=min(low[u],dfn[v]);
		else{
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
				++cnt;ll t;
				do{//出栈操作
					t=st.top();ans[cnt].push_back(t);st.pop();//cout<<st.top()<<endl;
				}
				while(t!=v);
				ans[cnt].push_back(u);
			}
		}
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++){
		ll u,v;scanf("%lld%lld",&u,&v);
		if(u!=v){
			e[u].push_back(v);
			e[v].push_back(u);d[u]++;d[v]++;
		}
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i]){
			tarjan(i,i);
		}
	}
	//for(int i=1;i<=n;i++)cout<<dfn[i]<<" "<<low[i]<<endl;
	printf("%lld\n",cnt);
	for(int i=1;i<=cnt;i++){
		printf("%lld ",ans[i].size());
		for(int j=0;j<ans[i].size();j++){
			printf("%lld ",ans[i][j]);
		}
		cout<<endl;
	}
	return 0;
}

```


---


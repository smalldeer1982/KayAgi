# [信息与未来 2017] 加强版密码锁

## 题目描述

乌龟偶然获得了一个宝箱，宝箱上又有一把密码锁。密码锁由  $n$ 个拨盘组成，每个拨盘初始时有一个 $0$ 到
$99$ 之间的整数。向上拨使数字 $x$ 变为 $(x+1) \bmod 100$，
向下拨使数字 $x$ 变为 $(x+99) \bmod 100$。

因为密码锁年久失修，拨盘拨动的次数越多越费力。
如果一个拨盘被拨动 $k$ 次，需要花费 $k^2$ 单位时间。

密码锁只有在所有的拨盘上的数字形成一个从左到
右严格递增的数列时才会解开。乌龟再次请你帮忙，求
解解开密码锁的最少时间。

---

试题中使用的生成数列 $R$ 定义如下：整数 $0\leq R_1\lt 201701$ 在输入中给出。

对于 $i\gt 1,R_i=(R_{i−1}\times 6807+2831)\bmod 201701$。

## 说明/提示

$30\%$ 的数据满足 $n\leq3$，所有数据满足 $1\leq n\leq 100$。
>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
10 4```

### 输出

```
3338```

# 题解

## 作者：xw_qwq (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B3734)

下位绿，简单 dp 题。

#### 题目思路

题目中有填的数的位置和填什么数两个量，再根据较小的数据范围，我们设 $dp_{i,j}$ 为填到了第 $i$ 个数，这个数填 $j$ 的最小时间。

定义一个计算函数 $f(x,y)$，用来计算从 $x$ 转到 $y$ 所使用的体力值。我们可以往上转或往下转，仅需对这两种情况分类讨论出最小值，返回平方即可。即 $f(x,y) = \min(100 - |x-y|,|x-y|) \times \min(100 - |x-y|,|x-y|)$。

对于初始化，因为是求最小值，所以先全部设为极大值。我们枚举第一个数的所有情况，通过计算函数得出答案，即 $\forall i \in [0,99],dp_{1,i} = f(a_1,i)$，其中 $a_i$ 为题中所给原始序列。

三层循环枚举，分别为所填的位置 $i$，这个位置填的数 $j$，上个位置填的数 $k$。因为严格递增，所以 $k$ 的范围为 $[0,j]$。转移方程很易推出，为：

$$$
dp_{i,j} = \min(dp_{i,j},dp_{i-1,k} + f(a_i,j))
$$$

最后答案即为 $\min_{i=0}^{99} dp_{n,i}$。

---

## 作者：guoshengyu1231 (赞：2)

# 题意简述
有一个 $ n $ 个拨盘的密码锁，每个拨盘的初始数字由给定的伪随机数列 $ R $ 生成（第 $ i $ 个拨盘的初始数字为 $ R_i \bmod 100$）。每个拨盘的数字可以在 $ 0 $ 到 $ 99 $ 之间调整，调整规则如下：
- 向上拨‌：数字 $ x $ 变为 $ (x + 1) \bmod 100$（每次加 $1$，循环递增）。
- ‌向下拨‌：数字 $ x $ 变为 $ (x + 99) \bmod 100$（每次减 $1$，循环递减）。

每次拨动一个拨盘 $ k $ 次（无论是向上还是向下），需要花费 $k^2$ 单位时间。目标是让所有拨盘的数字从左到右形成一个‌严格递增的数列‌（即前一个数字严格小于后一个数字），求达成这一目标所需的最少时间。

## 输入：
- 两个整数 $ n$（拨盘数量）和 $R_1$（随机数列的首项）。
- 随机数列 $ R $ 的生成规则：$R_i = (R_{i-1} × 6807 + 2831)\bmod 201701，i>1$。
- 第 $ i $ 个拨盘的初始数字为 $ R_i \bmod 100$。
## 输出：
- 解开密码锁的最少时间（即拨动次数的平方和的最小值）。
## 关键点：
- ‌严格递增‌：必须满足 $a_1 < a_2 <\dots< a_n$。
- ‌拨动代价‌：拨动 $ k $ 次的花费是 $ k^2$，与方向无关。
- ‌数字范围‌：数字是模 $ 100 $ 循环的（如 $ 99+1=0$，$0-1=99$）。
- ‌随机数列‌：拨盘的初始数字由伪随机数列生成，需先计算出每个 $ R_i \bmod 100$。
# 思路
既然是要我们算出解开密码锁的最少时间，那大概可以知道应该是动态规划了，那具体怎么做呢？先别急，首先这是一道绿题，说明还是有点难度的。所以遇到这种大问题，我们应该将他分解成若干个小问题，再逐个击破。俗话说，大事化小，小事化了，尽量把复杂的问题分解成简单的问题，做题也是一样。既然这题比较难，那我们就逐个击破。
 $\\$ 

首先，我们既然是要通过拨动拨盘来让消耗的时间越少，那当务之急必然是算出拨动拨盘的代价。具体的，设 $cost_{i,j}$ 表示从数字 $i$ 拨到数字 $j$ 所需的代价。不难发现，从数字 $i$ 拨到数字 $j$，无非就是往上拨更优还是往下拨更优。根据题意模拟即可：

```cpp
const int maxn=100;
int mul(int x){return x*x;}
void init()
{
	for(int i=0;i<maxn;i++)
	 for(int j=0;j<maxn;j++)
	  if(j>i) cost[i][j]=min(mul(j-i),mul(100+i-j));
	  	 else cost[i][j]=min(mul(i-j),mul(100+j-i));
}
```
其次，既然是动态规划，那三要素可不能少。
## 状态
要想知道状态，我们得先知道那些因素是与答案有关系的。首先枚举到第几个拨盘一定是有关系的。因为想要知道是不是满足严格递增，你总得知道前一个是啥呀。
 $\\$ 

其次，要想知道是否单调递增，那具体的数是必须得知道的，所以我们可以总结出状态。
$dp_{i,j}$ 表示使前 $i$ 个拨盘单调递增，并且第 $i$ 个拨盘拨到 $j$ 时需要的最少时间。
## 边界
首先肯定要把 $dp$ 数组赋值为无穷大。接下来考虑只有一个拨盘的情况。很明显，当只有一个拨盘的时候，我们直接拨动这个拨盘即可。很容易写出代码：

```cpp
for(int i=0;i<maxn;i++)
 dp[1][i]=cost[a[1]][i];
```
## 转移
接下来便是动态规划中最难的一步——状态转移。考虑到所有数据满足 $1\le N\le 100$。所以即便时 $O(n^3)$ 的 dp 也依然能过。那接下来我们可以考虑枚举一个中间变量来实现状态转移，那到底怎么转呢？考虑到第 $i$ 个拨盘的状态依赖第 $i-1$ 个拨盘的状态，那这个中间变量肯定是跟第 $i-1$ 哥拨盘相关，那可以是什么呢？显然应该是第 $i-1$ 个拨盘拨的数，不妨设该变量为 $k$，接下来就该考虑怎么写状态转移方程了。
### 状态转移方程
首先枚举 $k\in[0,j-1]$，因为 $k$ 是第 $i-1$ 个拨盘拨的数，要想使数列单调递增，那 $k$ 必然小于 $j$，那接下来状态转移方程就很好想了。我们可以理解为先把前一个拨盘拨到 $k$，再将这一个拨盘拨到 $j$，可得状态转移方程：
$$dp_{i,j}=\min^{k=0}_{k<j}\{dp_{i-1,k}+cost_{a_i,j}\}$$
# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=100;
int cost[maxn+5][maxn+5];
int a[maxn+5],n,x;
int dp[maxn+5][maxn+5];
int mul(int x){return x*x;}
void init()
{
	for(int i=0;i<maxn;i++)
	 for(int j=0;j<maxn;j++)
	  if(j>i) cost[i][j]=min(mul(j-i),mul(100+i-j));
	  	 else cost[i][j]=min(mul(i-j),mul(100+j-i));
}
//初始化cost数组
signed main()
{
	init();
	cin>>n>>x;
	for(int i=1;i<=n;i++)
	 {
	 	a[i]=x%100;
	 	x=(x*6807+2831)%201701;
	 }
	memset(dp,0x3f,sizeof dp);
	for(int i=0;i<maxn;i++)
	 dp[1][i]=cost[a[1]][i];//初始化边界
	for(int i=2;i<=n;i++)
	 for(int j=0;j<maxn;j++)
	  for(int k=0;k<j;k++)
	   dp[i][j]=min(dp[i][j],dp[i-1][k]+cost[a[i]][j]);//状态转移
	int ans=1e18;
	for(int i=0;i<maxn;i++) ans=min(ans,dp[n][i]);//计算答案，应该不用我多说了吧
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B3734#ide)

只是一个刚出土的小萌新，题解写的不好，勿喷。
### 前言

这道题目要求我们调整密码锁上的 $n$ 个拨盘，使得最终每个拨盘显示的数字严格递增（后一个数字必须大于前一个），并且调整所需的总时间最少。每次拨动一个拨盘（向上或向下拨动一次）需要消耗 $1$ 单位时间，总时间是拨动次数的平方和。

### 思路
 首先用随机数生成器产生每个拨盘的初始数字，然后使用动态规划来计算调整拨盘的最少时间。我们可以定义一个二维数组 $dp[i][v]$ 表示前 $i$ 个拨盘调整好且第 $i$ 个拨盘显示数字 $v$ 时的最少时间。对于每个拨盘和每个可能的数字，计算从初始数字调整到该数字需要的时间（拨动次数的平方），然后找到前一个拨盘所有更小数字中的最小 $dp$ 值相加。最后取最后一个拨盘所有可能数字中的最小 $dp$ 值就是答案。
### 代码

```cpp
#include <bits/stdc++.h>
#define ie min_element
using namespace std;
const int AV = 100;
const int I = INT_MAX / 2;
int main() {
    int n, R1;
    cin >> n >> R1;
    vector<int> a(n);
    vector<int> R(n);
    R[0] = R1;
    a[0] = R[0] % 100; 
    for (int i = 1; i < n; ++i) {
        R[i] = (R[i-1] * 6807 + 2831) % 201701;
        a[i] = R[i] % 100;
    }
    vector<vector<int>> dp(n, vector<int>(AV, I));
    for (int v = 0; v < AV; ++v) {
        int d = min((v - a[0] + 100) % 100, (a[0] - v + 100) % 100);
        dp[0][v] = d * d; 
    }
    for (int i = 1; i < n; ++i) {
        for (int v = 0; v < AV; ++v) { 
            int d = min((v - a[i] + 100) % 100, (a[i] - v + 100) % 100);
            int st = d * d;
            for (int pv = 0; pv < v; ++pv) {
                dp[i][v] = min(dp[i][v], dp[i-1][pv] + st);
            }
        }
    }
    int it = *ie(dp[n-1].begin(), dp[n-1].end());
    cout << it << endl;
    return 0;
}
```

---

## 作者：CMWabc123 (赞：0)

# 第一部分 题目
[题目传送门](https://www.luogu.com.cn/problem/B3734)
# 第二部分 分析
首先生成数列 $R$，然后将数列 $R$ 中的每个元素对 $100$ 取模，得到每个拨盘的初始数字。这样做的目的是将数列 $R$ 中的值映射到 $0$ 到 $99$ 的范围内，以符合拨盘数字的取值范围。

我们定义 $dp[i][j]$ 来表示前 $i$ 个拨盘，且第 $i$ 个拨盘数字为 $j$ 时的最小花费。其中，$i$ 表示拨盘的编号，范围是从 $1$ 到 $n$，$j$ 表示拨盘上的数字，范围是从 $0$ 到 $99$。

对于第一个拨盘，我们需要计算将其拨到每个数字 $j$ 的最小花费，即 $dp[1][j]$。我们比较向上拨动和向下拨动所需的次数，并取较小的花费。

对于 $i>1$，我们需要枚举第 $i$ 个拨盘的数字 $j$ 和第 $i−1$ 个拨盘的数字 $k$（其中 $k<j$），并更新 $dp[i][j]$ 的值。具体来说，$dp[i][j]$ 的值为 $dp[i-1][k]+mc(a[i], j)$ 的最小值，其中 $mc(a[i],j)$ 表示将第 $i$ 个拨盘从初始数字 $a[i]$ 拨到数字 $j$ 的最小花费。

$dp[n][j]$ 的最小值便是答案。

时间复杂度 $O(n^3)$。
# 第三部分 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,r1,r[110],a[110],dp[110][110],ans=2e9;
int mc(int a,int b) {
	int up=(b-a+100)%100,down=(a-b+100)%100;
	return min(up*up,down*down);
}
int main() {
	cin>>n>>r1;
	memset(dp,0x3f,sizeof(dp)),r[1]=r1;
	for(int i=2; i<=n; i++)r[i]=(r[i-1]*6807+2831)%201701;
	for(int i=1; i<=n; i++)a[i]=r[i]%100;
	for(int i=0; i<100; i++)dp[1][i]=mc(a[1],i);
	for(int i=2; i<=n; i++)for(int j=0; j<100; j++)for(int k=0; k<j; k++)if(dp[i-1][k]!=2e9)dp[i][j]=min(dp[i][j],dp[i-1][k]+mc(a[i],j));
	for(int i=0; i<100; i++)ans=min(ans,dp[n][i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 解题思路
首先，输入 $n$ 和 $r_1$，并根据题目给的递推公式 $r$ 和数组 $a$。

然后，我们考虑用动态规划。

  - 我们设 $dp_{i,j}$ 表示在第 $1$ 到 $i$ 位中，把第 $i$ 位调成 $j$ 的最少时间。
  -  我们可以想到枚举上一位 $k$ 来进行状态转移，就有：

$$
dp_{i,j} = \min_{0 \leq k \leq j-1} \left\{ dp_{i-1,k} + \text{f}(j,a_i) \right\}
$$

其中 $\operatorname{f}(i,j)$ 表示从数字 $i$ 到数字 $j$ 至少需要多少次。$\operatorname{f}$ 函数怎么实现呢？

我们可以把调整转盘分成两种情况：

1. 直接调整，所用步数 $\lvert i-j \rvert$。
2. 反向调整，我们设 $i \lt j$，我们可以分成这样的 $3$ 步：

    - 从 $i$ 变到 $0$，所用步数：$i$。
    - 从 $0$ 变到 $99$，所用步数：$1$。
    - 从 $99$ 变到 $j$，所用步数：$99 - j$。

总步数：$i + 1 + 99 - j$，也就是 $100 + i - j$。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[101][101],r[101],ans=INT_MAX,a[101];
int f(int x,int y)
{
	int num=abs(x-y);
	return min(num,-num+100)*min(num,-num+100);
}
int main()
{
	scanf("%d%d",&n,&r[1]);
	a[1]=r[1]%100;
	for(int i=2;i<=n;i++)
	{
		r[i]=(r[i-1]*6807+2831)%201701;
		a[i]=r[i]%100;
	}
	memset(dp,0x3f,sizeof(dp));
	for(int i=0;i<=99;i++)
	dp[1][i]=f(a[1],i);
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=99;j++)
		{
			for(int k=0;k<j;k++)
			{
				dp[i][j]=min(dp[i][j],dp[i-1][k]+f(a[i],j));
			}
		}
	}
	for(int i=0;i<=99;i++)
	ans=min(ans,dp[n][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：ZinfI_Sh (赞：0)

[题目链接](https://www.luogu.com.cn/problem/B3734)

因为 $n\le 100$，所以就算是 $n^3$ 的 dp 都能过。

首先令 $\operatorname{cost}(a,b)$ 表示数字 $a$ 转到数字 $b$ 的费用，稍微模拟一下有：

```
int cost(int a, int b)
{
    if (b > a)
    {
        return min((b - a) * (b - a), (a + 1 + (99 - b)) * (a + 1 + (99 - b)));
    }
    else
    {
        return min((a - b) * (a - b), (b + 1 + (99 - a)) * (b + 1 + (99 - a)));
    }
}
```

即检查是往上转更优还是往下转更优。

dp 挺好想的，记 $a_{i}$ 表示第 $i$ 位的初始数字，$dp_{i,j}$ 表示第 $1\sim i$ 位中，第 $i$ 位转到数字 $j$ 的最优费用，那么有：

$$dp_{i,j}=\displaystyle\min_{0\le k\le j-1}\{dp_{i-1,k}+\operatorname{cost}(j,a_i)\}$$

$0\le k\le j-1$ 是为了保证严格单调上升。

初始时 $dp_{i,j}$ 赋值成一个超大值，而 $\forall dp_{1,i}=\operatorname{cost}(a_{1},i)$。

那么代码就出来了。

# AC 代码

```
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = {0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
const int HASHMOD = 9223372036854775783;
const int HASHBASE = 131;
const int HASHITEM = 999997;
int a[101], dp[101][101];
int cost(int a, int b)
{
    if (b > a)
    {
        return min((b - a) * (b - a), (a + 1 + (99 - b)) * (a + 1 + (99 - b)));
    }
    else
    {
        return min((a - b) * (a - b), (b + 1 + (99 - a)) * (b + 1 + (99 - a)));
    }
}
signed main()
{
    // cout<<cost(3,1)<<'\n';
    // return 0;
    int n, r1;
    cin >> n >> r1;
    a[1] = r1;
    for (int i = 2; i <= n; i++)
    {
        r1 = (r1 * 6807 + 2831) % 201701;
        a[i] = r1 % 100;
    }
    memset(dp, 0x3f, sizeof(dp));
    for (int i = 0; i <= 99; i++)
    {
        dp[1][i] = cost(a[1], i);
    }
    for (int i = 2; i <= n; i++)
    {
        for (int j = 0; j <= 99; j++)
        {
            for (int k = j + 1; k <= 99; k++)
            {
                dp[i][k] = min(dp[i][k], dp[i - 1][j] + cost(k, a[i]));
            }
        }
    }
    int ans = INT_MAX;
    for (int i = 0; i <= 99; i++)
    {
        ans = min(ans, dp[n][i]);
    }
    cout << ans;
    return 0;
}
```

---


# [信息与未来 2024] 图灵完备

## 题目背景

本题 SPJ 可能出现随机无法通过编译的情况，请多次尝试提交。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/88clj7mw.png)

（你不需要看懂这张图片；但如果你看懂了，会觉得它很有趣。）

JavaScript 是一种功能强大且灵活的编程语言，也是现代 Web 开发的三大支柱之一 (另外两个是 HTML 和 CSS)。灵活的 JavaScript 包含“自动类型转换”的语言特性。例如，JavaScript 认为`[]`（空数组）和 `0` 是可以比较且相等的。自动类型转换带来的一个后果是我们可以只用 `()+[]!` 这 $6$ 个字符编写任意功能的 JavaScript 程序，包括游戏和交互网页。

Dr. X 请你帮他为整数 $n$ 生成一段仅包含 `()+[]!` 字符的 JavaScript 代码,且代码的运行结果恰好为整数 $n$。解决这个题目不需要任何 JavaScript 语言知识。~~压缩包中提供了人工智能实现的 jsexplorer.html 小工具，双击打开可以运行 JavaScript 代码并检查运行结果。~~

~~搬题者注：我没有收到下发的压缩包。~~

搬题者注：感谢 @[Jorisy](/user/400269) 在机房电脑中找到了遗留的 jsexplorer.html。

## 说明/提示

对于 $60\%$ 的数据，有 $n \leq 1000$。

对于 $100\%$ 的数据，有 $0 \leq n \leq 10^9$。

输出超过 $5000$ 个字符将被判定为错误。~~注意源代码有  $100\text{KB}$ 的大小限制。~~

搬题者注：这里是洛谷。源代码有 $50\text{KB}$ 的限制。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
0```

### 输出

```
+[]```

# 题解

## 作者：lizeyuhello (赞：8)

翻了一下，其他题解都没有详细讲每个符号的具体作用，我来一发详细点的。

### 思路
先看各种符号代表的意思：

1. `+` 加号,自动类型转换后面的算式，转换成整数。
2. `[]` 空数组，加上加号后 `+[]` 表示 $0$。
3. `!` 逻辑运算符，比如 `![]` 代表 `True`，`+!+[]` 自动转换成 $1$。
4. `()` 括号，改变运算优先级。

既然 `+!+[]` 代表 $1$，就可以把它连接，比如 `+!+[]+!+[]` 代表 $2$。

在上面的介绍里，出现了整数类型和布尔类型，缺了一个字符类型。

根据经验，既然题目要求拼数字，那就应该是用字符拼成字符串。

再试一试，比如要拼 $12$，可以把数字连起来，就是 `(+!+[])+(+!+[])`，这是我们发现，通过了字符检查，但是通过不了数字检查。再加一个自动类型转换，`+(+!+[])+(+!+[])` 通过检查，返回 $12$。

我们就可以用拼数的方法A掉这道题。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

char s[40];

int main()
{
	scanf("%s", s);//输入数字，为了方便用字符串代替
	printf("+(");//先输出转换和括号
	for (int i = 0; s[i]; ++i)
	{
		if (i > 0)
			putchar('+');//如果不是第 1 位就转换
		s[i] ^= 48;//s[i] -= '0';
		putchar('(');
		for (int j = 1; j <= s[i]; ++j)
			printf("+!+[]");
		printf("+[])");//保险点，再加上 0
	}
	puts(")");//结尾的括号不能忘
 	return 0; //完结撒花
}

```

---

## 作者：沉石鱼惊旋 (赞：7)

这个 $5000$ 的限制就很烦，否则我们可以构造一个 $1$ 然后拼在一起。

但是这启发我们，答案一定是用什么东西拼起来的。正常的什么二进制不行，因为本题没有乘法操作，只能加法凑。

但是我们根据已有的 JavaScript 语法经验或者单纯对于给出的字符组合，发现 `+[]` 返回一个 Number，`[]+[]` 返回一个 String。执行 `+([]+[])` 对一个空字符串求值又得到了一个 $0$。也就是说，我们把 $n$ 的每一位用 String 表示出来拼接在一起，然后转成 Number 类型即可。一个 `+!![]` 就是 $1$，每一位最多拼接 $9$ 次。长度显然不会超过 $5000$。

Fun Fact：有一个为本题而生的网站 <https://jsfuck.com/>。也许下面的信息可以对于做这题给出一些启发。

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int main()
{
    cin >> s;
    cout << "+(";
    for (int i = 0; i < s.size(); i++)
    {
        if (i)
            cout << "+";
        s[i] ^= '0';
        cout << "(";
        for (int j = 1; j <= s[i]; j++)
            cout << string("+!![]").substr(!(j >= 1));
        cout << "+[])";
    }
    cout << ")";
    cout << endl;
    return 0;
}
```

---

## 作者：joe_zxq (赞：5)

# Part 1 - 算法思路

在浏览器中按 F12 进入控制台，在里面输入表达式即可求值。

![](https://pic.imgdb.cn/item/6677e0ccd9c307b7e9a6da17.png)

我们不难发现：

- `+` 将后面的表达式转化为整数。
- `[]` 如题目所示，表示空数组，`+[]` 就是 $0$。
- `!` 相当于逻辑运算里的非，`+!+[]` 就是 $1$。
- `()` 用来改变运算顺序。

以此类推，将两个 `+!+[]` 加起来，即 `+!+[]+!+[]` 就是 $2$。

那么为了构造出 $n$，只需要写出 $n$ 的每一位，用括号括起来，再拼接起来，整个括起来转为整数即可。

例如，$114514$ 就是 $1,1,4,5,1,4$ 拼接在一起，表达式就是 `+((+!+[]+[])+(+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+[]))`。

小技巧：用字符串读入 $n$，就不用整型拆位了。

# Part 2 - 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long

int main() {

	string s;
	cin >> s;
	cout << "+(";
	bool ok = 1;
	for (char c : s) {
		ll x = c - '0';
		if (!ok) {
			cout << "+";
		}
		ok = 0;
		cout << "(";
		while (x--) {
			cout << "+!+[]";
		}
		cout << "+[])";
	}
	cout << ")";

	return 0;
}
```

# Part 3 - 附赠数据

那这里就附赠两组数据帮助调试吧。~~对不起，我有点喜欢玩梗。~~

| Input | Output |
| :-----------: | :-----------: |
| `114514` | `+((+!+[]+[])+(+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+[]))` |
| `1919810` | `+((+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+[])+(+!+[]+[])+(+[]))` |

---

## 作者：fire_and_sweets (赞：2)

在比赛的时候通过了这题。

首先，不难想到 $60~\mathrm{pts}$ 做法：不断输出 `+!+[]`，即把 $0$ 取反变成 $1$。

满分做法就是把原数一位一位分别数出来。具体地，比如说 `145`，我们把 $1,4,5$ 分别用刚才的那种方法输出来就可以了。只需要正向输出即可。

另外还有一种情况：如果遇到了一个数 $0$，直接写 `[]` 的话输出为空，所以应写成 `+!!+[]`，这样把 $0$ 取反 $2$ 次，结果还是 $0$。

代码过于简短，此处便不再提供。

---

## 作者：遥遥领先 (赞：1)

# 题解：B3981 [信息与未来 2024] 图灵完备

## 思路

其实这题赛时应该是切了，纯属找规律。

题目给了 `+[]` 表示 $0$，那么 `!+[]` 应该就是 $1$。但是试了试发现输出是 `true`，所以要把它转换成整数类型，在前面加上一个 `+`，也就是 `+!+[]`，表示 $1$。

这时，数字 $0,1,2,\dots,9$ 都能表示了，但是题目要求输出不超过 $5000$ 个字符，而输入的最大数据为 $10^9$，所以不能一个一个叠加。

我们想到了数位拆解。经过我大量的尝试，发现 `+[]+` 可以把两个数字连接起来，形成多位数。比如：$12$ 可以表示为 `+((+!+[])+[]+(+!+[]+!+[]))`，为了保守，我加了很多括号，不过可以证明长度肯定小于 $5000$。

## 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;

string n;
void print(int x)
{
	if (x == 0)
	{
		cout << "(+[])";
		return ;
	}
	cout << '(';
	for (int i = 1;i <= x;i++)
		cout << "+!+[]";
	cout << ')';
}

void solve()
{
	cin >> n;
	cout << "+(";
	for (int i = 0;i < n.size();i++)
	{
		if (i) cout << "+[]+";
		print(n[i]-'0');
	}
	cout << ')';
}

signed main()
{
	solve();
	return 0;
}

```

---

## 作者：ggylz49 (赞：1)

## 思路分析
可以发现数 $0$ 是 `+([]+[])`，即对空字符串求值得到 $0$。

然后把 $0$ 加上一个 `!`，就是一个 $1$，即 `+!([]+[])`。

然后对 $n$ 逐位分解，用 `()+()` 的形式连接每一位。可以自行证明，即使是 $99999999$，也不会超过题目的限制。
## Code
```cpp
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string s;//使用string模拟整数更为方便
    cin>>s;
    for (int i=0;i<s.length();i++)
    {
        if (i!=0)cout<<"+";//如果不是第一位，输出一个+前导
        int n=s[i]-'0';//这一位的数
        cout<<"(";//左括号
        for (int j=0;j<n;j++)cout<<"+!([]+[])";//加上这个位上的数次1
        cout<<"+[])";//右括号
    }
    return 0;
}
```

---

## 作者：ZnPdCo (赞：1)

好玩。

没有乘法，一个一个加显然不现实。发现可以用字符串来拼接答案。

容易发现 `+[]` 是 `0`，而 `!+[]` 是 `true`，那么利用类型转换可以得到 `!+[]+(+[])` 是 `1`。

容易发现 `[]` 是 `''`，那么利用类型转换可以得到 `+[]+[]` 是 `'0'`。

现在就可以直接分解 $n$ 然后用字符串拼接了：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string ans = "[]";
int main() {
	scanf("%d", &n);
	if(n == 0) cout << "+[]";
	else {
		while(n) {
			int tmp = n % 10;
			n /= 10;
			
			string str = "(";
			for(int i = 1; i <= tmp; i ++) {
				str += "!+[]+";
			}
			str += "(+[])+[])+";
			
			ans = str + ans;
		}
		cout << ans;
	}
}
```

---

## 作者：Mike_L (赞：0)

直接字符串拼接。

真·解决这个问题不需要任何 Javascript 知识。

用 jsexplorer.html 尝试过之后，可以发现， `+!![]` 为 `1` ， `+!![]+[]` 或 `[+!![]]` 为 `'1'` 。

所以，在数字外面套一层方括号就可以了。

打表：
```c++
string s[] = {
	"([+[]])",                                                   // 0
	"(+!+[]+[])", 											// 1
	"(+!+[]+!+[]+[])", 										// 2	
	"(+!+[]+!+[]+!+[]+[])", 								// 3
	"(+!![]+!![]+!![]+!![]+[])", 							// 4
	"(+!+[]+!+[]+!+[]+!+[]+!+[]+[])",						// 5
	"(+!![]+!![]+!![]+!![]+!![]+!![]+[])",					// 6
	"(+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])",				// 7
	"(+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])",		// 8
	"(+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+!![]+[])"	// 9
};
```
~~核心代码都给了，别告诉我你还不会~~

Fun Fact：在浏览器中按 F12 （大多数），点击 `Console` 或 `控制台` ，即可在里面输入表达式求值，根本不用 jsexplorer.html 。

---

## 作者：huangzhixia (赞：0)

怎么说呢，有 spj，找规律吧。

---------------

看题意。

题目中说了 ```+[]``` 是 $0$，那么我们不难想到 ```!+[]``` 即为 $1$。整形即为 ```+!+[]```。

本来是这个题目做完了的，但就是多了一个 $5000$ 的限制，这个就不是很好解决，不是很一眼。构造题，题目要我们拼数字，虽然例如说把 $1$ 和 $2$ 拼起来可以直接赋值成 $1 \times 10 + 2$，但是如果拼起来的数字多了就比较难受。所以我可以用自带的 STL 里的 ```string```，直接拼数字。

按照题目中的数字表示，我们把分别对应的数字用字符串的表示拼在一起，中间加上一个 ```+```，我们就可以把两个数字拼在一起了。

因为本题有 spj，自由度较高，所以我们可以加上括号，保险起见。

--------------

会了如何拼数，我们就可以将此题做到。

[AC Record](https://www.luogu.com.cn/record/161766719)

---


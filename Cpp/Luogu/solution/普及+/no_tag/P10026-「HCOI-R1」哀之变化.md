# 「HCOI-R1」哀之变化

## 题目背景

哀喜欢数字。

她还喜欢变化。

## 题目描述

有一整数 $a$ 初始为 $1$。

哀想让 $a$ 进行恰好 $k$ 次变化，每次从以下两种变化中选择一个：

- $a\gets a - 1$；
- $a\gets a \times 2$。

哀很好奇，经过 **恰好** $k$ 次变化后 $a$ 能否变成 $n$。

## 说明/提示

### 样例解释 1

+ 若 $k = 2$，$n = 5$，可以证明无解。
+ 若 $k = 2$，$n = 4$，一种可能的操作方式如下：
	+ 第一步，$a \gets a\times 2 = 2$；
	+ 第二步，$a \gets a\times 2 = 4$。
+ 若 $k = 3$，$n = 3$，一种可能的操作方式如下：
	+ 第一步，$a \gets a\times 2 = 2$；
	+ 第二步，$a \gets a\times 2 = 4$。
	+ 第三步，$a \gets a-1 = 3$。

### 数据规模与约定

**本题采用捆绑测试。**

+ Subtask 0（10 pts）：$T \leq 10$，$k \leq 15$。
+ Subtask 1（25 pts）：$n, k \leq 2\times 10^3$。
+ Subtask 2（65 pts）：无特殊限制。

对于所有数据，$1 \leq T \leq 10^5$，$0 \leq n, k \leq 10^{18}$。

## 样例 #1

### 输入

```
3
2 5
2 4
3 3```

### 输出

```
No
Yes
Yes```

## 样例 #2

### 输入

```
5
4 869
48 69
8 328
66 114514
168 1919810
```

### 输出

```
No
Yes
No
Yes
Yes```

# 题解

## 作者：Wf_yjqd (赞：29)

官方题解。

自评难度介于黄和绿之间。

暂时没考虑到其他做法。

------------

## $\text{Subtask 0} $
对于每次询问暴搜。

## $\text{Subtask 1} $
考虑离线处理，将所有询问按 $k$ 从小到大排序，然后一次 dp 出所有答案。

或者直接记忆化搜索。

复杂度为 $\operatorname{O}(n^2)$。

##### 注：以上复杂度中的 $n$ 仅表示题面中 $n,k$ 的数量级。

## $\text{Subtask 2} $
考虑求出达到 $n$ 的最小次数，然后尝试在过程中浪费一些操作以达到 $k$ 次。

首先特判 $n=0,1$ 的情况。

当 $n\ge 1$ 时，我们可以通过 $1\times2-1=1$ 这样的操作浪费掉任意偶数次。

当 $n\ge 2$ 时，我们还可以通过 $2\times 2-1-1=2$ 这样的操作浪费掉 $3$ 次。

显然可以凑出大于 $1$ 的任意整数。

考虑能否浪费 $1$ 次，显然只有 $a\times2-1-1=(a-1)\times2$。

如果 $n$ 的最短操作中不包括 $(a-1)\times2$，以上方案就无法实现。

此时 $n$ 一定为 $2$ 的幂次或 $2$ 的幂次 $-1$（最多只允许最后有一次 $-1$ 操作）。

根据以上条件即可判断是否可行，复杂度 $\operatorname{O}(T\times\log{n})$。

------------

或许您会不知道如何求达到 $n$ 的最小次数，有一种较简单的思考方法。

转换此题为一个本质完全相同的问题（也是出题人最开始想到的问题）。

给定一个整数 $n$，进行 $k$ 次操作，问最终能否为 $1$。

每次操作从以下两种中选一个：

- $a\gets a+1$
- $a\gets\frac{a}{2}$（$a$ 为偶数时可选）

他们的最小次数也是一样的。

考虑尽可能多的 $a\gets\frac{a}{2}$ 即可。

------------
放一下代码吧。

$30pts$：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn=1e5+84,maxm=4e3+23;
struct Query{
    ll k,n,id;
    bool ans;
    inline void read(ll x){
        scanf("%lld%lld",&k,&n);
        id=x;
        return ;
    }
    friend bool operator<(Query xy,Query zb){
        return xy.k<zb.k;
    }
}q[maxn];
ll T,j;
bitset<maxn> ans,Next;
inline bool cmp(Query xy,Query zb){
    return xy.id<zb.id;
}
int main(){
    scanf("%lld",&T);
    for(ll i=1;i<=T;i++)
        q[i].read(i);
    sort(q+1,q+T+1);
    ans[1]=1;
    j=1;
    for(int i=1;i<=q[T].k+2;i++){
        while(j<=T&&i==q[j].k+1){
            q[j].ans=ans[q[j].n]==1;
            j++;
        }
        Next.reset();
        for(int i=ans._Find_first();i!=ans.size()&&i<=maxm;i=ans._Find_next(i)){
            if(i*2<=maxm)
                Next[i*2]=1;
            if(i>=1)
                Next[i-1]=1;
        }
        ans=Next;
    }
    sort(q+1,q+T+1,cmp);
    for(int i=1;i<=T;i++)
        puts(q[i].ans?"Yes":"No");
    return 0;
}
```

$100pts$：

```cpp
// 哀太可爱辣
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T,k,n,res,ans;
inline ll Q(ll x){
    res=0;
    while(x!=1){
        if(x&1)
            x++;
        else
            x>>=1;
        res++;
    }
    return res;
}
inline bool check(ll x){
    if(x&1)
        x++;
    return (x&(-x))==x;
}
int main(){
    scanf("%lld",&T);
    while(T--){
        scanf("%lld%lld",&k,&n);
        if(!k)
            puts(n==1?"Yes":"No");
        else if(!n)
            puts("Yes");
        else if(n==1)
            puts(k%2==0||k>=5&&k%2?"Yes":"No");
        else{
            ans=Q(n);
            puts(ans>k||ans+1==k&&check(n)?"No":"Yes");
        }
    }
    return 0;
}
```


---

## 作者：Xssion37_XY (赞：11)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P10026)

[更好的阅读体验](https://www.luogu.com.cn/blog/778802/solution-p10026)

### 题目大意

有一整数 $a$ 初始为 $1$。

让 $a$ 进行恰好 $k$ 次变化，每次操作都有以下两种操作方式：

- $a\gets a - 1$；

- $a\gets a \times 2$。

求经过 **恰好** $k$ 次变化后 $a$ 能否变成 $n$。

### 实际分析

~~最喜欢分类讨论的题了。~~

前面已经有很多大佬详细证明了，我这里就简化说明吧。

当然为了容易理解还是倒着推导。

- $a\gets a+1$

- $a\gets a\div2$

这里对 $k$ 进行 $3$ 种情况分类讨论。

当 $k<0$ 时，则不可能有负数的操作次数，直接输出  ```No``` 即可。

当 $k=0$ 时，如果 $n=1$，直接输出 ```Yes```，否则输出 ```No``` 即可。

当 $k>0$ 时，这个时候 $n$ 就会有 $2$ 种情况：

1. $n$ 为偶数时：

进行 $n\gets n \div2$ 操作，如果结果是奇数，只需要进行一次 $n\gets n+1$ 就可以变成偶数继续操作。

2. $n$ 为奇数时：

进行 $n\gets n+1$ 操作，如果结果是偶数，按照 $n$ 为偶数操作即可。

但......这就完了吗？

所以接下来我们来看看有没有特殊情况。

- 特殊情况 $1$

如果 $n=0$，又该怎么做？

我们不妨来模拟一下。

只有一次操作次数时，我们只需要加一即可：$0+1=1$。

当我们有两次操作次数时：$0\div2=0,0+1=1$。

三次操作次数时：$0\div2=0,0\div2=0,0+1=1$。

容易发现，只要我们有**至少一次**操作次数时，我们就可以在最后一次加上 $1$ 达到目标。

即：$k\ge1$ 时都有解。

- 特殊情况 $2$

当 $n=1$时，只要 $k\ne1$ 并且 $k\ne3$ 就一定会有解。

这个是比较好理解的，因为一开始就已经满足了要求，$k=1$ 时你就必须要进行一次操作，这必然会改变它的值，从而不能满足要求。

$k=2$ 时：$(1+1)\div2=1$ 是满足题目要求的。

当 $k=3$，两次操作过后又会面临 $n=1$ 时的情况，故不满足。

$k=4$ 时是满足的。

但是，这里 $k=5$ 时却依然是满足的。

你可能会觉得奇怪，不应该是奇数都不行吗？

其实并不是这样的。

因为操作种类只有两种，$k=3$ 时，因为必须要消耗 $2$ 次操作数，剩下的 $1$ 次是不够加起来的，但是当 $k=5$ 时，多出来的 $3$ 次却能够刚好加起来，即 $1+1=2,2+1=3,3+1=4,4\div2=2,2\div2=1$，可以说算是找规律了吧。

$k\ge5$ 以后的所有情况就都成立了。

### 代码部分

代码就不放了。

完结撒花！

---

## 作者：BIG_CUTE_BUG (赞：8)

[题传](https://www.luogu.com.cn/problem/P10026)

一道位运算题。

调了一上午。：(

提供一种正向找从 $1$ 达到 $n$ 的最小操作次数方法。

## 思路
首先记 $-1$ 操作为 $1$ 操作，$\times 2$ 操作为 $2$ 操作。

显然我们的操作可表示为

$$ (((1\times 2-1)\times2)\times2-1)\times2... $$

拆掉括号后可表示为

$$ 2^{cnt_2}-\sum\limits_{i=1}^{cnt_1}2^{a_i} $$

其中 $cnt_1$ 表示操作 $1$ 的总次数，$cnt_2$ 表示操作 $2$ 的总次数，$a_i$ 表示第 $i$ 次操作 $1$ 时，该次操作后，操作 $2$ 的次数。


因为我们是要操作使得在满足

$$ 2^{cnt_2}-\sum\limits_{i=1}^{cnt_1}2^{a_i}=n $$

且 $cnt_1,cnt_2,a$ 可以任意构造的条件下，$cnt_1+cnt_2$ 最小。

所以移项

$$ 2^{cnt_2}-n=\sum\limits_{i=1}^{cnt_1}2^{a_i} $$

其中不出现负数，且需使 $cnt_1,cnt_2$ 尽可能小，所以使 $2^{cnt_2}$ 恰好大于 $n$，此时便有 $cnt_2$ 最小取值。然后就可以求出 $\sum\limits_{i=1}^{cnt_1}2^{a_i}$。

显然有性质 $2^k+2^k=2^{k+1}$，那么上式一定可以表示为若干不同的 $2$ 的次幂之和，即 $a$ 序列一定可各不相同，也即 $a$ 序列表示 $\sum\limits_{i=1}^{cnt_1}2^{a_i}$ 在二进制下为 $1$ 的位。同时，此时的 $cnt_1$ 是一定比 $a$ 含重复元素时的 $cnt_1$ 更小，进而此时即 $cnt_1$ 的最小取值。

最终最小操作次数即 $cnt_1+cnt_2$。

实践是比较简单的，也就不展开了。顺带一提，写的优秀两行（调用 `builtin` 函数可），稍微劣一点也就三四行的样子。

`builtin` 大概是 $\text{O}(1)$ 的罢，所以跑的也比较快。（[record](https://www.luogu.com.cn/record/140938985)）

其余判断同官方 tj。

## 代码
就放个求最小操作次数的两行吧，其他部分各位照着官方 tj 打就可以了。

`q` 是 $cnt_1$，`p` 是 $cnt_2$，$rn$ 是 $\sum\limits_{i=1}^{cnt_1}2^{a_i}$。

朴素实现
```cpp
long long q= 0, p= 0, rn= 0; n--;
while(n) rn|= (((long long)!(n& 1))<< p), p++, n>>= 1;//求p以及rn
while(rn) q++, rn-= rn&-rn;//求q

```
`builtin` 实现
```cpp
long long q= 0, p= 0, rn= 0; n--;
p= 63^ __builtin_clzll(n); p++; rn= (long long)((1ull<< p)- 1) ^ n;
q= __builtin_popcountll(rn);
```

---

## 作者：cff_0102 (赞：7)

首先可以从 $n$ 倒退回 $1$，每次操作变成 $+1$ 或 $\div2$。当 $n$ 为 $0$ 时，可以一直 $\div2$，最后 $+1$ 得到 $1$，所以只要输入的 $k$ 不为 $0$ 就直接输出 `Yes`。当 $n$ 不为 $0$ 时，要最快到 $1$，那就肯定是奇数时 $+1$，偶数时 $\div2$。最后计算出来还多出 $k$ 步。

- 如果此时 $k<0$，那么直接输出 `No`。
- 如果 $k$ 是偶数，那么到最后可以一直 $+1$ 变成 $2$，再 $\div2$ 变成 $1$，重复若干次，刚好就在 $k$ 次之后到达 $1$。所以直接输出 `Yes`。
- 如果 $k$ 是奇数：
  - 因为 $x\div2+1=(x+1+1)\div2$，这样就能把 $2$ 步变成 $3$ 步，所以结合前面的第二点，只要在把 $n$ 变 $1$ 的过程中有 $x\div2+1$，就可以直接输出 `Yes`；
  - 因为（刚开始的 $n$ 不为 $1$ 时）最后一步必然是 $2\div2=1$（$0+1=1$ 的情况前面已经特判完了），而 $(2+1+1)\div2=2$，所以结合前面的第二点，只要 $n\ne1$ 且 $k\ge3$ 也可以直接输出 `Yes`。
  - 而刚开始的 $n=1$ 时，要消耗掉 $k$ 次操作再变回 $1$，需要 $(1+1+1+1)\div2\div2=1$，操作 $5$ 次，所以结合前面的第二点，只要 $k\ge5$ 就直接输出 `Yes`。
  - 如果在把 $n$ 变 $1$ 的过程中没有 $x\div2+1$，并且 $n\ne1$ 时 $k<3$，或者 $n=1$ 时 $k<5$，那么输入数据就成功避开了所有正确情况，输出 `No`。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	ios::sync_with_stdio(false);
	int t;cin>>t;
	while(t--){
		int k,n;cin>>k>>n;
        int tmpn=n;
        if(n==0){
            if(k)cout<<"Yes\n";
            else cout<<"No\n";
			continue;
		}
        bool tmp=0,tmp2=0;
		while(n!=1){
			if(n%2==0)n/=2,k--,tmp2=1;
			else n++,k--,tmp=tmp|tmp2,tmp2=0;
		}
        if(k<0)cout<<"No\n";
        else if(k%2==0)cout<<"Yes\n";
        else if(tmp)cout<<"Yes\n";
        else if(tmpn!=1&&k>=3)cout<<"Yes\n";
        else if(tmpn==1&&k>=5)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：lilong (赞：6)

看完题目后，发现直接对 $a$ 模拟操作的情况过多，不好处理。但如果对 $n$ 进行**逆向操作**，似乎可以在很少步数内就变为 $1$。我们大胆猜想，用最少的步数使 $n$ 变为 $1$，再考虑如何处理多余的次数（若次数不足则直接无解）。先列出转换后的操作：

- $n\gets n + 1$；
- $n\gets n \div 2$（注意，此处的 $n$ 必须为偶数）。

不难发现，若 $n$ 为偶数，则直接令 $n\gets n \div 2$；若 $n$ 为奇数，则令 $n \gets ( n + 1 ) \div 2$。显然这是最快的方法。在缩减过程中统计最少次数，时间复杂度 $O(\log_2 n)$。

接下来考虑如何处理剩余的次数。我们可以通过模拟小数据，发现以下的两种循环：

- $1\times2\div 2 = 1$；
- $2\times2-1-1=2$。

操作一以 $2$ 次操作为循环，操作二以 $3$ 次操作为循环。因此若剩余次数大于 $1$，则必定有解。下面讨论剩余次数为 $1$ 的情况。

前面已经证明了，$1$ 次操作无法保持不变。因此，我们尝试将其加入到缩减过程中。具体地，设 $n$ 为偶数（奇数进行一次操作会变成偶数），则有 $n \div 2 + 1 = ( n + 2 ) \div 2 = ( n + 1 + 1 ) \div 2 $。这样我们就成功地将 $2$ 次操作变为 $3$ 次操作。但是，观察式子可知，对于 $n$ 为 $2$ 的正整数次幂（或减一），这样做是不行的，读者可以根据**运算顺序**得到该结论。此时无解。

最后要注意 $k=0$ 的情况以及其它代码实现的细节。

总时间复杂度 $O(T\log_2 n)$。

```cpp
#include <iostream>
#include <cstdio>
#define int long long

using namespace std;

signed main()
{
	int T,n,m,k,flag,pd;
	cin >> T;
	while( T -- )
	{
		m = 0;
		flag = 0;
		pd = 0;
		cin >> k >> n;
		if( n == 0 )
		{
			if( k ) cout << "Yes" << endl;
			else cout << "No" << endl;
			continue;
		}
		if( n == 1 )
		{
			if( k == 1 || k == 3 ) cout << "No" << endl;
			else cout << "Yes" << endl;
			continue;
		} 
		while( n > 1 )
		{
			m ++;
			if( n % 2 )
			{
				if( m == 1 ) flag = 1;
				else flag = 0;
			}
			if( n % 2 ) n ++,pd = 1;
			else n /= 2;
		}
		if( m > k || ( k - m == 1 && ( !pd || flag )  ) ) cout << "No" << endl;
		else cout << "Yes" << endl; 
	}
	return 0;
} 
```


---

## 作者：operator_ (赞：4)

# P10026 「HCOI-R1」哀之变化

[题目传送门](https://www.luogu.com.cn/problem/10026)

## 题解

这么有趣的分类讨论题肯定要写一篇题解啦！

首先，感觉题目给出的两个操作很像二进制拆分，所以我们考虑倒着把 $n$ 变成 $1$，每次加一或除以二。

我们先把最少操作数给求出来，记为 $m$。直观来说，肯定是除以二的收敛速度比较快（~~废话~~），所以是偶数就除以二，是奇数就加一，模拟一下就可以得到最小操作次数，显然的，是 $O(\log n)$ 级别所以不会超时。

然后就要靠我们惊人的注意力了：注意到 $1\times 2-1=1$，所以一定有一个长为 $2$ 的周期。又注意到若 $n>1$，则第一步只能是 $1\times 2=2$，而 $2\times 2-1-1=2$，因此又有一个长为 $3$ 的周期。结合一下可以得到：

+ $n=0$：只要 $k\ge1$ 即有解，因为 $0\times 2=0$。

+ $n=1$：只要 $k\not=1 \operatorname{and} k\not=3$ 即有解。

+ $n>1$：$k\ge m\operatorname{and}k\not=m+1$ 则必定有解，$k<m$ 则必定无解。

但是 $k=m+1$ 是不能判定有无解的。比如 $n=5$，最小操作为 $(1\times 2\times 2-1)\times 2-1=5$，需 $m=5$ 次操作，然而存在 $1\times 2\times 2\times 2-1-1-1=5$，共 $6$ 次操作；而对于 $n=4$，有 $1\times 2\times 2=4$，故 $m=2$，但是可以发现没有操作次数为 $3$ 的序列，于是我们就挂了。

为什么会出现这种情况呢？其实是因为如果我们的操作序列中出现了**先减 $1$ 再 $\times 2$** 这种东西，那我们可以拆括号 $(x-1)\times 2=(x\times 2-1-1)$，就完成了从 $2$ 次操作扩展到 $3$ 次操作。

于是，满足 $k=m+1$ 无解的所有数都应该满足：使其取到 $m$ 的操作序列应为：$1\times 2\times 2\times\dots\times 2-1-1-\dots-1$。不过又由于我们在求 $m$ 时只有在奇数时才会使用第一种减一操作，因此最后的那一连串 $-1$ 实际最多只会有一项。

再细想一下，就不难发现所有 $2$ 的幂和 $2$ 的幂减一的 $k=m+1$ 是无解的，而其余均有解。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
	int s=0,m=0;char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
	while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return m?-s:s;
}
int t,n,k,s;
bool check(int x) {return (1ll<<(int)log2(x))==x; }
signed main() {
	cin>>t;
	while(t--) {
		k=rd(),n=rd(),s=0;
		if(n==0) {puts(k!=0?"Yes":"No");continue;}
		if(n==1) {puts(k!=1&&k!=3?"Yes":"No");continue;}
		for(int u=n;u!=1;s++)
			if(u%2) u++;
			else u/=2;
		if(k<s) puts("No");
		else if(k!=s+1) puts("Yes");
		else if(!check(n+(n%2))) puts("Yes");
		else puts("No");
	}
	return 0;
}
```

---

## 作者：maomao233 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10026)

我们可以倒推题意，将题面转换为：

给定非负整数 $n$，有以下两种操作：

操作一：$n\gets n+1$；  
操作二：若 $n\equiv0\pmod2$，$n\gets\dfrac{n}{2}$。

求是否可以经过恰好 $k$ 次操作将 $n$ 变为 $1$。

---

我们进行分类讨论：

- 当 $k=0$ 时：  
很明显若 $n$ 本身即为 $1$ 时有解，否则无解。
- 当 $n=0$ 时：  
很明显若 $k\ge1$ 可以：进行 $k-1$ 次操作二，然后进行一次操作一。否则 $k=0$ 时无解。
- 当 $n=1$ 时：  
在这里说明两个特性：

  特性一：  
$1+1=2$，$\dfrac{2}{2}=1$；  
$1+1=2$，$\dfrac{2}{2}=1\cdots$  
特性二：  
$1+1=2$，$2+1=3$，$3+1=4$，$\dfrac{4}{2}=2$，$\dfrac{2}{2}=1$；  
$1+1=2$，$2+1=3$，$3+1=4$，$\dfrac{4}{2}=2$，$\dfrac{2}{2}=1\cdots$

  可以发现特性一为进行 $2$ 次操作，特性二为进行 $5$ 次操作。我们令进行 $x$ 次特性一，$y$ 次特性二，此时若 $x$ 与 $y$ 都为非负整数则有解，否则无解。  
容易发现此时仅有 $k=1$ 与 $k=3$ 时无解，特判即可。
- 否则：  
若我们需要最快使得 $n=1$，不难发现，应在 $n\equiv1\pmod2$ 时进行操作一，$n\equiv0\pmod2$ 时进行操作二。  
我们令按如上操作使得 $n=1$ 需要 $m$ 次操作。  
分类讨论：

  - 当 $m>k$ 时，明显无解。
  - 当 $m=k$ 时，明显有解。
  - 当 $m<k$ 时：  
    由于我们已经特判 $n=1$ 时的情况，所以最后一步一定是 $\dfrac{2}{2}=1$。也就是说，在进行最后一次操作前一定满足 $n=2$。  
于是我们考虑一个特性：  
$2+1=3$，$3+1=4$，$\dfrac{4}{2}=2$；  
$2+1=3$，$3+1=4$，$\dfrac{4}{2}=2\cdots$  
令该特性为特性三，可以发现特性三为进行 $3$ 此操作。这样当 $k-m\ge2$ 时，可以通过进行若干次特性一和若干次特性三使得该情况有解。  
但若 $k-m=1$，也有可能有解。  
考虑一个特性，$\dfrac{n}{2}+1=\dfrac{n+1+1}{2}$。这样就把两次操作变为了三次操作。  
所以当 $n$ 倒推时中出现了 $\dfrac{n}{2}+1$ 的情况，该情况也有解，判断一下即可。  
否则无解。

至此，我们完成了本题。得代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
inline string its(int x){stringstream ss;string s;ss<<x;ss>>s;return s;}
inline int sti(string s){stringstream ss;int x;ss<<s;ss>>x;return x;}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
#define lb(x) x&-x
signed main()
{
	int t;
	rd(t);
	while(t--)
	{
		int k,n;
		rd(k,n);
		if(!n)
		{
			puts(k?"Yes":"No");
		}
		else if(!k)
		{
			puts(n==1?"Yes":"No");
		}
		else if(n==1)
		{
			puts(k!=1&&k!=3?"Yes":"No");
		}
		else
		{
			int ans=0;
			int chu=0,flag=0;
			while(n!=1)
			{
				if(n&1)
				{
					if(chu)
					{
						flag=1;
					}
					n++;
				}
				else
				{
					chu=1,n>>=1;
				}
				ans++;
			}
			puts(ans==k||ans<k&&(k-ans>=2||flag)?"Yes":"No");
		}
	}
	return 0;
}
```

五位数题目编号的题解还是头一回写 /kk。

---

## 作者：hgckythgcfhk (赞：3)

先打个暴力找规律，把前几步能走到的用 bfs 捜一遍，然后把每个数几步能走到存到 set 里去重排序输出来，实现很简单，这里我直接把输出的结果放出来。

[数据](https://www.luogu.com.cn/paste/agy11wk0)

我们可以发现几个规律：

1. 从最少步数开始，更多的步数最多有一个不数不行。

2. 当且仅当 $n$ 是 $2$ 的正整数幂或者 $2$ 的正整数幂减 $1$ 的形式时会出现比最少步数多但不行的情况。

3. 如果有这种情况，设最少步数为 $dis$ 则不行的一定是 $dis+1$。

这样我们可以得出一个做法，先计算出 $dis$ 把 $dis>k$ 的数据直接输出 ```No```，然后根据上述规律输出。

实现很简单，主要是证明。

先证明上述结论 $1$ 和结论 $3$ 的正确性。

$2$ 步或者 $5$ 可以走到 $1$ 是显然的，因为可以构造出来：

走 $2$ 步：

$$1 \times 2=2$$

$$2-1=1$$

走 $5$ 步：

$$1\times2=2$$

$$2\times2=4$$

$$4-1=3$$

$$3-1=2$$

$$2-1=1$$

这样，我们可以用 $2\times a+5\times b$ 步回到 $1$，显然，这个式子包括了所有大于 $3$ 的奇数，和所有偶数。

对于 $3$ 我们可以通过 $2$ 来构造：

$$2\times 2=4$$

$$4-1=3$$

$$3-1=2$$

这样，我们只要把 $n=1$ 特判掉就能实现处理其他的数了，结论 $1$ 和结论 $3$ 证毕。

再证明结论 $2$，显然我们不能浪费 $1$ 步走回 $2$ 的正整数幂，$2$ 的正整数幂减 $1$ 只能从 $2$ 的正整数幂走一步来达到最优，正确性显然。最后证明为什么别的数多 $1$ 步可以。

我们发现，除了从下往上，还可以从上往下走 $1$ 步或者 $2$ 步，除了 $2$ 的幂加 $1$ 的以外，由于步数是 $\log$ 级的，都差得不多，所以一定能找到，这个证明也许不太严谨，但对于理解这个题足够了。

然后的问题就是求 $dis$ 了。

```
inline unsigned dis(int ll x){return x==1?0:x&1?dis(x+1)+1:dis(x>>1)+1;}
```

对于奇数显然只有一种走法，正确性显然，对于偶数，要么向上走两步，要么向下走 $1$ 步，因为相邻的差得不多，显然后者不劣。

也许我证明的不够严谨，但是比起官方题解只提供做法的已经好理解很多了，事实上，证明的过于严谨反而不利于赛场发挥，重在理解。

注意，递归的求需要特判 $0$，否则会死循环。

```
#include<bits/stdc++.h>
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;constexpr unsigned N=4e5+1;
#define void inline void
#define int register unsigned
#define ge getchar_unlocked()
#define pu putchar_unlocked
#define ll long long
void rd(int ll&s){s=0;int char c=ge;while(c<48||c>58)c=ge;while(c<59&&c>47)s=s*10+(c&0b1111),c=ge;}
void wt(int x){if(!x){pu(48);return;}static unsigned char c[11];int char s=0;while(x)c[++s]=x%10|48,x/=10;while(s)pu(c[s--]);}
void wt(const char*c){for(int i=0;i<strlen(c);++i)pu(c[i]);}unordered_set<unsigned ll>_1;
inline unsigned dis(int ll x){return x==1?0:x&1?dis(x+1)+1:dis(x>>1)+1;}
signed main(){open;int ll t;rd(t);for(int ll i=1;i<63;++i)_1.insert(1ll<<i),_1.insert((1ll<<i)-1);while(t--){int ll n,k;rd(k),rd(n);
		if(n==1){
			if(k==1||k==3){wt("No\n");continue;}
			else{wt("Yes\n");continue;}}
		if(n==0){
			if(k==0){wt("No\n");continue;}
			else{wt("Yes\n");continue;}}
		if(k==0){
			if(n==1){wt("Yes\n");continue;}
			else{wt("No\n");continue;}}int d=dis(n);//cerr<<d<<' ';
		if(k<d){wt("No\n");continue;}
		k-=d;if(_1.count(n)&&k==1){wt("No\n");continue;}
		wt("Yes\n");continue;
	}
	
}

```


---

## 作者：wflhx2011 (赞：2)

# Solution

对于这道题，大体思路：

1. 求最少次数。

1. 考虑如何浪费次数 （最少次数小于规定次数并不意味一定能恰好用规定次数完成变化）。

1. 找出规律。

### 求最少次数

正着推似乎没有突破口，俗话说“正难则反”，考虑反向，即：

#### 整数 $n$ 能否进行 $k$ 次操作后变成 $1$ ，每次操作为 $+1$ 或$\div2$。

不难知道，$\div2$ 时必须为偶数，所以：

#### 为偶数 $\div2$ ，为奇数 $+1$。

这样就能求出最少次数。

### 浪费次数

浪费次数及通过更多次数得到相同结果。

不难想到，$1\times2-1=1$浪费 $2$ 次，$2\times2-1-1=2$ 浪费 $3$ 次，更大的就没必要找了因为都可以转化成上面 $2$ 种。

其中，在运算过程中还有 $(a-1)\times2=a\times2-1-1$ 可以浪费 $1$ 步。

但是，要想这一步能实现，$a$ 必须为 $2^{n}$ 或 $2^{n}-1$ 。

### 找规律

现在我们综合前两步，可以得到以下规律：

#### 如果 $k$ 为 $0$ , $n$ 必须为 $1$。

#### 如果 $k$ 不为 $0$ , $n$ 为 $0$，那么就符合条件（前面 $k-1$ 次都 $\times2$ ,最后 $+1$ ）。

#### 如果 $k$ 不为 $0$ ，$n$ 为 $1$ ，就根据浪费次数判断符不符合条件。

#### 如果 $k$ 不为 $0$ ，$n$ 不为特殊值，就先求出最少次数，然后判断能否浪费次数达成条件。

最后代码比较简洁：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long T;
	cin>>T;
	while(T--)
	{
		long long n,k;
		cin>>k>>n;
		long long m=n,sum=0;
		if(k==0)
		{
			if(m!=1)
				printf("No\n");
			else
				printf("Yes\n");
			continue;
		}
		if(m==0)
		{
			printf("Yes\n");
			continue;
		}
		if(m==1)
		{
			if(k%2==0||k>=5&&k%2==1)
				printf("Yes\n");
			else
				printf("No\n");
			continue;
		}
		while(n!=1)
		{
			if(n%2==1)
				n++;
			else
				n/=2;
			sum++;
		}
		long long x=m;
		if(x&1)
			x++;
		if(sum>k||(sum+1==k&&((x&(-x))==x)))
			printf("No\n");
		else
			printf("Yes\n");
	}
	return 0;
 } 
```

---

## 作者：封禁用户 (赞：2)

本来以为都是正推的，没想到一篇逆推

唯一一篇正推还是靠数学式子的

下面就仅仅给出一种不用任何数学式子的正推方法，因为得到最小步数后十分简单，$- 1 \times 2$ 改成 $\times 2 - 1 - 1$ 多一步，$1 \times 2 - 1 = 1$ 多两步，$2 \times 2 - 1 - 1 = 2$ 多三步，特判一下不能使用第一种和第三种操作的就行

考虑 $n$ 的二进制

1. 全 $0$，则 $n=0$，单独讨论掉，$k \ge 1$ 即可
2. 首位 $1$，其他全 $0$，则至少 $\log_2 n$ 步，注意 $n=1$ 时不能使用第三种操作
3. 前面全 $1$，后面全 $0$，设有 $s$ 个 $0$，与第二种情况类似，最后多 $-1$ 即可，$\log_2 (\frac{n}{2^s}+1)+1+s$ 步
4. 其他情况，从高位往低位，如果是 $1$ 就乘 $2$，如果是 $0$ 就乘 $2$ 减 $1$，注意末尾的 $0$ 可以第一个减 $1$ 乘 $2$，后面只要乘 $2$

结束了（

---

## 作者：chenly8128 (赞：2)

## 题目链接及简要题意
[P10026 「HCOI-R1」哀之变化](https://www.luogu.com.cn/problem/P10026)

简要题意：对于 $T(1 \leq T \leq 10^5)$ 个正整数 $n(1 \leq n \leq 10^{18})$，问是否能通过**恰好** $k(1 \leq k \leq 10^{18})$ 次操作，使得初始为 $1$ 的 $a$ 变成 $n$，操作包含
- $a\gets a - 1$；
- $a\gets a \times 2$。

## 思路
### STEP 1
预处理想不到可行的办法，~~或许可行，但是笔者不会~~。然后一看数据范围，显然对于单次查询，复杂度最多为 $O(\log n)$ 才能不超时。于是可以想到统计一下对于 $n$ 来说，至少需要多少次操作，记为 $rk$。
```cpp
int rk = 0;		// 存储操作的最少次数
while (n > 1) {
	if (n&1)n++;
	else n >>= 1;
	rk++;
}
```
如果 $k<rk$ ，则一定不能在 $k$ 步内使 $a$ 达到 $n$。

### STEP 2
考虑序列

1. $1 \times 2 = 2$
2. $2 - 1 = 1$
3. 重复以上步骤

得到结论 $1$：如果 $k-rk$ 为 $2$ 的倍数，一定可以通过初始时以上步骤的循环使得存在 $k$ 步使 $a$ 达到 $n$ 的方法。

再考虑序列

1. $2 \times 2 = 4$
2. $4 - 1 = 3$
3. $3 - 1 = 2$
4. 重复以上步骤

得到结论 $2$：如果 $k-rk$ 为 $3$ 的倍数，一定可以通过初始时以上步骤的循环使得存在 $k$ 步使 $a$ 达到 $n$ 的方法。

综合结论 $1$、$2$，**如果 $k > rk$，一定可以通过初始时以上步骤的循环使得存在 $k$ 步使 $a$ 达到 $n$ 的方法。**

最后考虑 $(a - 1) \times 2 = a \times 2 - 1 - 1$

得到结论 $3$：**只要在数字变化的过程中存在先减 $1$ ，再乘 $2$ 的过程，且 $rk \leq k$，则一定存在 $k$ 步使 $a$ 达到 $n$ 的方法。反之，如果不存这样的过程且 $rk < k$，则一定存在 $k$ 步使 $a$ 达到 $n$ 的方法。**

### STEP 3

特殊情况：

- 在 $n = 0$ 时，只要 $k > 0$ 均可满足条件。
- 在 $n = 1$ 时，只要 $k \neq 1$ 且 $k \neq 3$ 均可满足条件。

### STEP 4

上代码！

```cpp
#include <iostream>
using namespace std;
int main(void) {
    ios::sync_with_stdio(false);
    long long n,k;int t;
    cin >> t;
    while (t--) {
        cin >> k >> n;
        if (n == 0) {
            if (k >= 1) cout << "Yes\n";
            else cout << "No\n";
            continue;
        }
        if (n == 1) {
            if (k != 1 && k != 3) cout << "Yes\n";
            else cout << "No\n";
            continue;
        }
        int rk = 0;bool b = false;long long p = n;
        while (n > 1) {
            if (n&1) {
                if (n != p) b = true;
                n++;
            }
            else n >>= 1;
            rk++;
        }
        if (k-rk >= 2 || k == rk || (k-rk == 1 && b)) cout << "Yes\n";
        else cout << "No\n";
    }
    return 0;
}

```

---

## 作者：indream (赞：1)

## P10026 「HCOI-R1」哀之变化 题解
[P10026](https://www.luogu.com.cn/problem/P10026) | [AC](https://www.luogu.com.cn/record/142469431)
### 思路
分类讨论与逆向思维。

$-1$ 反过来是 $+1$，$\times2$ 反过来是 $\div2$。

#### 特判情况
1. $k=0,n=1$ 时，显然可以。
2. $k=0,n\ne1$ 时，显然不行。
3. $n=0,k\ne0$ 时，显然可以。
4. $n=1,k=1,3$ 时，显然不行。
5. $n=1,k\ne1,3$ 时，可以：
   - 显然 $k \bmod 2=0$ 时，成立（反复 $\times2-1$ 即可）
   - $k=5$ 时，可以 $\times2\times2-1-1-1$。
   - $k$ 为大于 $5$ 的奇数时，只需在 $k=5$ 的基础上进行一定的 $\times2-1$。
   
#### 其他情况
先考虑如何把 $n$ 以最少的步数降到 $1$。

- $n \bmod 2=0$，$n\div2$；
- $n \bmod 2\ne0$，$n+1$。

如果最少用的次数大于 $k$，显然不行。

现在考虑如何把剩余次数给耗掉。设剩余次数为 $a$：
- $a=1$
    - $n=2^b$ 或 $n=2^b-1$ 时，不行。
    - 否则可以。令 $n$ 为偶数，$n\div2-1=(n-1-1)\div2$ 这样即可多加这一次。
- $a\bmod2=0$ 或 $a\bmod2=1(a>3)$ 时显然可以，见特判。
- $a=3$，可以在 $n=2$ 时进行 $+1+1\div2$ 的操作。

于是，这道题就写完了。时间复杂度 $O(T \log n)$。

---

## 作者：封禁用户 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10026)

[博客观看](https://www.luogu.com.cn/blog/xiaomajiubu/solution-p10026)

~~这题虽说是`普及+/提高`，为啥我觉得像是`普及-`，就是数据有点大。~~

主要思路是**倒推**和**分治**。

1. $N\gets N+1$

2. $N\gets N\div 2$

~~是不是有人就想到了搜索或动态规划？~~

~~是可以这么做，但恭喜你只能得到部分分，毕竟数据太大，数组存不下，搜索时间和空间复杂度太高。~~

一直判断，如果 $N$ 是偶数，则将 $N\div 2$，反之则将 $N+1$。最终还剩下 $K$ 步。

- $K=0$，这不用说了，肯定输出 `Yes` 啦！

- $K$ 是偶数，可以将 $1+1$ 再 $\div 2$，结果仍然是 $1$，也输出 `Yes`。

- $K$ 是奇数，有点复杂。因为 $x\div 2+1=(x+1+1)\div 2$，两步变成三步，所以如果出现了 $N\div 2 + 1$ 这一操作，输出 `Yes` 就对了；否则如果 $N\ge 1$，最后一步绝对是 $N\div 2=1$，那么只要 $K\ge 3$，也输出 `Yes`；如果 $N=1$，因为 $(1+1+1+1)\div 2\div 2=1$，所以只要 $K\ge 5$，也能输出 `Yes`；如果正好避开以上所有情况，输出毋庸置疑，肯定是 `No`。

上代码：

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main() {
    ios::sync_with_stdio(false);//优化
    int T;//共 T 组数据
    cin >> T;
    while (T--) {
        long long k, n;// 不要忘记开 long long
        cin >> k >> n;// 读入顺序不能错，否则只能有 10 分
        if (!n) {//特判 N 等于 0 的情况
            if (k) cout << "Yes" << endl;
            else cout << "No" << endl;
            continue;
        }
        long long m = n;
        bool f1 = 0, f2 = 0;// f1 表示是否有除以 2 再加 1 的操作，f2 表示上一步是否是除以 2
        while (n != 1) {
            if (n % 2 == 0) {
                n /= 2;
                f2 = 1;
            } else {
                n++;
                f1 |= f2;//如果上一步为除以 2（即 f2 为 true），则 f1 会变为 true
                f2 = 0;
            }
            k--;
        }
        if (k < 0) cout << "No" << endl;//如果操作次数超过 K，输出 No
        else if (k % 2 == 0) cout << "Yes" << endl;//如果 K 为偶数输出 Yes       
        else if (f1) cout << "Yes" << endl;
        else if (m != 1 && k >= 3) cout << "Yes" << endl;
        else if (m == 1 && k >= 5) cout << "Yes" << endl;//如果 K 是奇数的三种输出 Yes 的情况
        else cout << "No" << endl;//完美避开正确答案则输出 No
    }
    return 0;//好习惯
}
```


---

## 作者：niuzh (赞：1)

### 思路

此题用倒退比正推简单。

- $a\gets a + 1$；
- $a\gets a \div 2$。

可先将 $n=1$ 的情况特判出来，让后面的分类讨论更简单。

先求出从 $n$ 推到 $1$ 的最少次数，设为 $cnt$。具体步骤为：若当前数为奇数，那么加一；若当前数为偶数，直接除2，以获得最少次数。

然后分类讨论即可：

- 若 $k < cnt$，则在 $k$ 次内无法完成，输出 `No`。

- 若 $k=cnt$，很明显，输出 `Yes`。

- 若 $k>cnt$，我们可以用 $(1+1) \div 2$ 和 $(2+1+1)\div 2$ 来填充剩余次数（由于已特判出 $n=1$ 的情况，所以最后一步一定是 $2 \div 2=1$），所以如果 $k-cnt \ge 2$，那么都能用 $2$ 和 $3$ 凑出来，输出 `Yes`。而 $k-cnt=1$ 的情况也不是不可能，由于 $x \div 2+1=x+1+1 \div 2$ 可以将 $2$ 步变 $3$ 步，直接填上 $1$，所以当倒退过程中出现了 $x \div 2+1$的话，也要输出 `Yes`。如果完美避开了所有正确可能性，输出 `No`。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while (T--)
	{
		long long k,n;
		cin>>k>>n;
		long long tn=n;
		if (n==0)//特判出0，否则会死循环
		{
			if (k!=0)
			{
				cout<<"Yes\n";
			}
			else
			{
				cout<<"No\n";
			}
			continue;
		}
		if(n==1)//1的特判
		{
			if(k!=1&&k!=3)
			{
				cout<<"Yes\n";
			}
			else
			{
				cout<<"No\n";
			}
			continue;
		}
		bool flag1=false,flag2=false;//是否有x/2+1
		while (n!=1)
		{
			if (n%2==0)
			{
				n/=2;
				flag2=true;
			}
			else
			{
				n++;
				flag1=flag2|flag1;
				flag2=false;
			}
			k--;
		}
		n=tn;
		if (k<0)
		{
			cout<<"No\n";
		}
		else if(flag1||k>=2||k==0)
		{
			cout<<"Yes\n";
		}
		else
		{
			cout<<"No\n";
		}
	}
	return 0;
}

```

---

## 作者：JackMerryYoung (赞：1)

# 前言

胡。

# 正文

先考虑怎么做出 $1 \to n$ 的最小步数。

倒着考虑一下 $n \to 1$，显然将 $n$ 一直整除以 $2$（若能除），不能除就加上 $1$。这样显然最优。

那么将过程倒回来，接着考虑“**恰好**”二字。我们尝试在原有的最小步数的基础上继续浪费一些步数。

先特判一些很唐的 corner，之后我们发现在做完 $n$ 时才浪费较为难考虑，而在做完这件事之前浪费较为简单，无外乎（$1, 2$ 都是必经之路，于是可以先考虑一下）：

- $1 \times 2 \to 2, 2 - 1 \to 1$（浪费 $2$ 次）

- $2 \times 2 \to 4, 4 - 1 \to 3, 3 - 1 \to 2$（浪费 $3$ 次）

看到 $2, 3$ 的步长，发现显然我们可以凑出大于 $1$ 的所有浪费次数。于是关键落到了能否进行 $1$ 次浪费的判定。

我们考虑以下恒等式：

$$
2(a - 1) = 2a - 2
$$

也就是：

$$
a - 1 \to (a - 1), (a - 1) \times 2 \to 2(a - 1)
$$

与

$$
a \times 2 \to 2a, 2a - 1 \to (2a - 1), (2a - 1) - 1 \to 2a - 2
$$

等价。

很显然第一个柿子与第二个柿子步数差一而结果相同，因此可视作为浪费了一次。这组柿子~~应该好像大概~~是唯一的。

但这个等效而步数不等的替换有条件。

即，在 $1 \to n$ 的最短过程中必须出现了第一个柿子所描述的过程 $a - 1 \to (a - 1), (a - 1) \times 2 \to 2(a - 1)$，才能将其换成第二个柿子的三步过程。

观察一下可知 $2$ 的幂次和 $2$ 的幂次减一都不可以，因为第一种过程中全是 $\times 2$，第二种过程中前面全是 $\times 2$ 后面只有一个 $-1$，无法构成第一个柿子。

注：$2$ 的幂次减二就可以了，因为相当于：$(2^k - 2) \div 2 \to 2^{k-1} - 1, (2^{k-1} - 1) + 1 \to 2^{k-1}, 2^{k-1} \div 2 \to 2^{k-2}, \cdots, 2 \div 2 \to 1$，倒过来就是前面一堆 $\times 2$，最后两步先 $-1$ 后 $\times 2$。其他也类似，这里不再赘述。

所以判断一下即可。复杂度 $\mathcal{O}(T \log_2 N)$，属于能过。

# 后言

太菜了我不会更好的做法（

~~这是水蓝甚至水绿吧。~~

---

## 作者：lucktains (赞：0)

### 暴力广度搜索 10pts

```cpp

#include <bits/stdc++.h>
#define int long long
using namespace std;
int k, n;
bool bfs() {
    queue<pair<int, int>>q;
    q.push({ 1,0 });
    while (1) {
        auto a = q.front();
        q.pop();
        if (a.first == n && a.second == k) {
            return 1;
        }
        q.push({ a.first - 1 ,a.second + 1 });
        q.push({ a.first * 2, a.second + 1 });
        if (a.second > k)return 0;
    }
    return 0;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        cin >> k >> n;
        cout << (bfs() ? "Yes\n" : "No\n");
    }
    return 0;
}
```

### 30pts

```dp``` 或递推。

# Solution

正向从 $1$ 变到 $n$ 不好找那就反向从 $n$ 变到 $1$。

 $ n $ 有两种情况。

 $ n=n+1 $，$ n=n\div2 $。

相当于 $ a=a\times2$，$a=a-1 $ 的反向。

求出次数为 $ cnt $。

因为 $ n\div2+1=(n+1+1)\div2 $ 所以在有 $ n\div2+1 $ 时可以凭空浪费一步。

定义 $ l1 $ 为是否有 $ n\div2+1 $。

```cpp
while (n != 1) {
         cnt++;
         if (n % 2 == 0)
         n /= 2, l = 1;
         else
         n += 1, l1 = l1 | l, l = 0;
}
```

显然 $ cnt>k $ 和 $ cnt=k $ 时输出 ```no``` 和 ```yes```。

可以通过 $ 1\times2-1=1 $ 浪费掉偶数步，

加上 $ l1 $ 浪费的一步直接输出 ```yes```。

否则可以用 $(1+1)\div2$ 和 $(2+1+1)\div2 $ 来浪费步数，

所以如果 $k-cnt\ge 2$ 输出 ```yes```。

如果避开所有正确答案输出 ```no```。

**cpp**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int k, n, cnt = 0;
        cin >> k >> n;
        bool l = 0, l1 = 0;
        if (n == 0) { //特判n==0
            if (k != 0)
                cout << "Yes\n";
            else
                cout << "No\n";
            continue;
        }
        if (n == 1) { //特判1
            if (k == 1 || k == 3)
                cout << "No\n";
            else
                cout << "Yes\n";
            continue;
        }
        while (n != 1) {
            cnt++;
            if (n % 2 == 0)
                n /= 2, l = 1;
            else
                n += 1, l1 = l1 | l, l = 0;
        }
        if (cnt > k)
            cout << "No\n";
        else if (cnt == k)
            cout << "Yes\n";
        else if ((k - cnt) % 2 == 0)
            cout << "Yes\n";
        else if (l1 == 1)
            cout << "Yes\n";
        else if (k - cnt >= 3)
            cout << "YES\n";
        else
            cout << "No\n";
    }
    return 0;
}

```

---

## 作者：wangzelin (赞：0)

# 题目链接
[题目链接](https://www.luogu.com.cn/problem/P10026)

# 解题思路
首先看到这种操作题，我们便考虑逆向操作，于是题目就变成了：

已知有两种操作，

-  $n \gets n/2$
-  $n \gets n+1$

其中第 $1$ 个操作要求 $n$ 为偶数，

问 $n$ 能否经过恰好 $k$ 次操作变成 $1$。

之后我们考虑特判，

当 $k=0$ 时，除 $n=1$ 都不可以。

当 $n=1$ 时，若 $k= 1,3$ 则不可以。

接下来想正解了，我们应先使 $n$ 变成 $1$，若 $n$ 为偶数，则执行操作 $1$，否则则执行操作 $2$。

令 $ans$ 为使 $n$ 变成 $1$ 所需的操作数，我们可以得到：

若 $ans=k$，则可以。

若 $ans>k$，则不可以。

若 $ans<k-1$，则不可以。

若 $ans=k-1$ 并且 $n$ 不是 $2$ 的整数次幂且 $n$ 不是 $2$ 的整数次幂减 $1$，则一定可以。

否则不可以。

接下来上代码。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int T;
long long k,n,ans,nn;

bool judge(long long x)
{
	return (1ll<<((int)log2(x)))!=x;
}
//判断是否是2的整数次幂，注意要使用long long

int main()
{
	cin>>T;
	while(T--)
	{
		scanf("%lld %lld",&k,&n);
		if(k==0)
		{
			if(n==1) printf("Yes\n");
			else printf("No\n");
		}
		else if(n==0) printf("Yes\n");
		else if(n==1)
		{
			if(k==1||k==3) printf("No\n");
			else printf("Yes\n");
			continue;
		}//特判
		else
		{
			nn=n;ans=0;
			while(n!=1)
			{
				if(n&1) n++;
				else n>>=1;
				++ans;
			}//求n变成1的操作数ans
			if(ans>k) printf("No\n");
			else if(ans==k||ans<k-1||judge(nn+(nn%2))) printf("Yes\n");
			else printf("No\n");
			//分类判断
		}
	}
	return 0;
}
```


---


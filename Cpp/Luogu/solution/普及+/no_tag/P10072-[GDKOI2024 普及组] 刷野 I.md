# [GDKOI2024 普及组] 刷野 I

## 题目描述

Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。

Zayin 率先使用一种攻击方式攻击，攻击过后所有血量小于等于 $0$ 的怪物死亡。在 Zayin 攻击一次后，所有存活的怪物对 Zayin 造成 $1$ 点伤害。以上步骤不断循环，直到 Zayin 击杀所有怪物为止。

Zayin 一共有三种攻击方式：

- 普通攻击: 消耗 $0$ 点能量值，选择一只怪物并使其血量减少一点。

- 天音波: 消耗 $1$ 点能量值，选择一只怪物并使其血量减少两点。

- 天雷破: 消耗 $1$ 点能量值，使所有怪物血量减少一点。

现在 Zayin 一共有 $m$ 点能量，现在他想知道在最优的策略下，击败 $n$ 只怪物所损失的最少血量。

## 说明/提示

对于 $30\%$ 的数据，$1 \leq n, m \leq 5$。

对于另外 $15\%$ 的数据，$m = 0$。

对于另外 $15\%$ 的数据，所有 $a_i$ 全部相等。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq m \leq 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3 4
2 4 4```

### 输出

```
6```

# 题解

## 作者：liuhongyang123 (赞：27)

## 题目大意
初始有 $n$ 只怪物，$m$ 点能量，Zayin 每回合可以选择一下三种情况其中一种来对怪物发起攻击：

- 普通攻击：消耗 $0$ 点能量值，选择**一只**怪物并使其血量减少**一点**。

- 天音波：消耗 $1$ 点能量值，选择**一只**怪物并使其血量减少**两点**。

- 天雷破：消耗 $1$ 点能量值，使**所有**怪物血量减少**一点**。

一开始是 Zayin 先攻击，每次攻击后剩余的**每只**怪物会对 Zayin 造成**一点**伤害。

求在**最优**的策略下，击败 $n$ 只怪物所损失的**最少**血量。

## 解法
其实不难发现这是一道**贪心**题，首先说一下贪心策略：

1. 只要**还有能量**（前提）剩的怪物数量**大于二**或者剩下的怪物数量**小于等于二**且剩下的怪物中**至少有一个血量为一**那么就使用**天雷破**。

2. 如果**不满足条件一**且**还有能量**那么就使用**天音波**。

3. 如果**没能量**了就只能使用**普通攻击**。

PS：如果用**个体伤害**那么要从剩下**血量最少**的怪开始打。

### 简单证明

其实我们用反证法可以很容易得出刚刚所说的结论。

1. 单体打要打血量最少的怪~~这不显而易见~~，因为少的打的快，后期打你的怪会少很多。

2. 怪物数大于二用范围攻击。反证 ：如果用天音波，单体的一个怪是可以打的比天雷破快，但是到后期一大堆怪毫发无损，你又要一个一个地打，要弥补之前任性的代价，而天雷破这时对怪物们的伤害会比天音波大得多的，但要注意如果怪物是小于三那么天雷破和天音波对怪物们的伤害是一样的，但天音波刷怪的速度会比天雷破快所以用天音波。

3. 有一滴血的怪时用天雷破，如果用天音波那岂不是用大炮打蚊子。

4. 如果没能量了那没得选只能用普通攻击。

## 最后

请允许我附上代码。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const long long MAXN=1E6+10;
long long n,m,cnt,a[MAXN],b[MAXN],nl,sum;
void solve(long long l,long long r,long long pa[],long long pb[]){
    if(r==l) return;
    long long mid=(l+r)>>1;
    solve(l,mid,pa,pb);
    solve(mid+1,r,pa,pb);
    long long id1=l,id2=mid+1;
    for(long long i=l;i<=r;i++){
        if(id2>r||(id1<=mid&&pa[id1]<pa[id2])) pb[i]=pa[id1],id1++;
        else pb[i]=pa[id2],id2++;
    }
    for(long long i=l;i<=r;i++) pa[i]=pb[i];
}
long long ans;
signed main(){
    scanf("%lld%lld",&n,&m);
    for(long long i=1;i<=n;i++) scanf("%lld",&a[i]);
    solve(1,n,a,b);
    while(m>0&&n-cnt>2){
        sum++;
        m--;
        while(a[cnt+1]-sum<=0&&cnt+1<=n) cnt++;
        ans+=n-cnt;
    }
    while(m>0&&cnt<n){
    	if(a[cnt+1]-sum==1){
    		m--;
	        cnt++;
	        if(a[cnt+1]-sum==1) cnt++,ans--;
	        else if(cnt+1>n) ans--;
	        sum++;
	        ans++;
	        continue;
		}
        a[cnt+1]-=2;
        m--;
        if(a[cnt+1]-sum>0) ans+=n-cnt;
        else cnt++,ans+=n-cnt;
    }
    while(cnt<n){
        ans+=(n-cnt)*(a[cnt+1]-sum-1)+(n-cnt-1);
        cnt++;
    }
    printf("%lld",ans);
    return 0;
}
```

## 完结散花
## 谢谢

---

## 作者：Down_syndrome (赞：23)

## 更新日志
2024年4月19日 修了一些 Latex，加了一些描述和写代码的思路。

## GDKOI2024 普及组] 刷野 I题解

偶然间发现该题目所有题解都被 [hack](https://www.luogu.com.cn/discuss/781641) 了，所以前来写一篇不会被 hack 的题解。以下把技能叫做群体攻击或单体暴击。

## 结论

对于 $n\le10^5$ 的数据范围，而且没那么容易 dp 的题目，容易想到贪心。下面是贪心结论：
1. 将 $a$ 从小到大排序，对于单体暴击或普攻，按血量从小到大打。
2. 有能量就放技能，否则放普攻。
3. 当前怪物数量大于 $2$ 且仍有能量时，释放群体攻击。
4. 当前怪物数量小于等于 $2$ 且仍有能量时，若有怪物血量剩余 $1$ 点，释放群体攻击，否则释放单体暴击。

## 贪心论证
不严谨，看看就好。

若 $m=0$，怪物 $1$ 会造成 $a_1-1$ 点伤害，怪物 $2$ 会造成 $a_1+a_2-1$ 点伤害。以此类推，怪物 $i$ 会造成 $(\sum\limits_{j=1}^ia_j)-1$ 点伤害。加起来可以得到，Zayin 总共会受到 $(\sum\limits_{i=1}^n(n-i+1)\times a_i)-n$ 的伤害。可以看到，在只用普攻的情况下，$a_1$ 的大小对伤害影响最大，其次是 $a_2$，显然在只使用单体暴击时也是如此，若 $m>0$ 把技能放完了也是这个结果，所以有了结论 $1$。

以此类推，假设在普攻前，Zayin 已经击败了 $k$ 只怪物，Zayin 总共还会受到 $(\sum\limits_{i=1}^n(n-i+1)\times a_i)-(n-k)$ 的伤害（被击败的怪物血量为 $0$）。令 $x$ 表示单次攻击内击败的怪物数量，可以发现，如果在普攻前 Zayin 对排序后第 $i$ 只怪物造成了伤害，Zayin受到的伤害减少 $n-i+1-x$ 点。因为 $n-i+1-x\ge0$，所以 Zayin 普攻前造成的伤害越多，受到的伤害越少。因此优先使用技能在普攻前造成更多伤害，就有了结论 $2$。

按以上假设和结论，Zayin 释放群体攻击总共对怪物 $k+1,k+2…n$ 造成了 $n-k$ 点伤害，让自己受到的伤害减少了 $(\sum\limits_{i=k+1}^nn-i+1)-x$ 点，也就是 $\dfrac{(n-k)(n-k+1)}{2}-x$ 点。在最差的情况下，也就是 $x=n-k$ 的情况下，也能让自己受到的伤害减少 $\dfrac{(n-k)(n-k-1)}{2}$ 点。如果释放单体暴击，如果第一只怪只有 $1$ 点血，则让自己受到的伤害减少了 $(n-k)-1$ 点，否则减少了 $2(n-k)$ 点。在第一种情况下，可以发现当 $n-k>2$ 时，$\dfrac{(n-k)(n-k-1)}{2}>(n-k)-1$，所以群体攻击更优。在第二种情况下，也可以发现当 $n-k>2$ 时，$\dfrac{(n-k)(n-k+1)}{2}\ge2(n-k)$。所以都是群体攻击更优，就有了结论 $3$。

当有怪物血量剩余 $1$ 点，且 $n-k\le 2$ 时，$\dfrac{(n-k)(n-k-1)}{2}=(n-k)-1$。所以在最劣也就是 $x=n-k$ 的情况下，群体攻击等于单体暴击。但在 $x<n-k$ 的情况下仍然是群体攻击更优，所以释放群体攻击。当没有怪物血量剩余 $1$ 点，且 $n-k\le 2$ 时，$\dfrac{(n-k)(n-k+1)}{2}<2(n-k)$，所以释放单体暴击。综上所述，就有了结论 $4$。

又或者，可以感性理解以上结论。结论 $1$ 是因为能尽快使怪物进行减员，结论 $2$ 是因为可以更快打出伤害，结论 $3$ 是因为此时用群体攻击打出的伤害更高，结论 $4$ 也是因为对应情况用对应技能伤害更高或者能更快使怪物进行减员。

## 代码实现

发现有些题解代码较长，这里运用以上公式和结论提供一种简短的方式。首先，枚举每一点能量的出手情况，分类讨论，如果释放群体攻击，就拿一个变量记录下目前群体攻击的伤害总值，否则就直接把对应怪物血量减 $2$，同时每次更新 $k$ 值和受到伤害的总值。等放完技能，就运用以上公式 $(\sum\limits_{i=1}^n(n-i+1)\times a_i)-(n-k)$ 计算普攻受到的伤害量。时间复杂度 $O(n+m)$。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,k,lei,a[N];
long long ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);//结论1：排序
	for(int i=1;i<=m&&k<n;i++){//结论2：先放技能
		if(n-k>2){//结论3
			lei++;
			while(a[k+1]<=lei&&k<n) k++;//更新被击败的怪物的数量，注意怪物的实际血量是要减去群体攻击造成的伤害的
		}
		else{//结论4
			if(a[k+1]-lei==1){
				lei++;
				while(a[k+1]<=lei&&k<n) k++;
			}
			else{
				a[k+1]-=2;
				if(a[k+1]<=lei&&k<n) k++;
			}
		}
		ans+=1ll*n-k;
	}
	for(int i=k+1;i<=n;i++) ans+=1ll*(n-i+1)*(a[i]-lei);//这里就是套公式了
	printf("%lld",ans-n+k);
	return 0;
} 
```

后记：有谁考场上会去想严格证明啊！！写这么多还换不来你的点赞吗？|ू･ω･` )

---

## 作者：Guizy (赞：9)

修改了第 $8$ 行，可以通过 [Hack](https://www.luogu.com.cn/discuss/782154)。

## 题目大意

给你 $n,m$ 和一个数列 $a_1,a_2,\ldots,a_{n-1},a_n$，分别代表怪物数量，使用技能的次数，每只怪物的血量。

- 技能 $1$：对每只怪物造成 $1$ 点血量伤害。

- 技能 $2$：对其中一只怪物造成 $2$ 点血量伤害。

- 普攻：对其中一只怪物造成 $1$ 点血量伤害。

每一次攻击后，会受到当前存活怪物数量的伤害。

求把它们全部打死的最小伤害。

## 思路

考虑贪心：

- 先打血量少的，先用技能。

应该很好理解，回合数不变，怪兽死的平均时间更早，受到伤害更小。

- 怪兽数大于 $2$ 时，优先使用 $1$ 技能。

$1$ 技能造成的伤害更多。

- 怪兽数等于 $2$ 时，优先使用 $2$ 技能。

回合数不变，有一只先死。

- 怪兽数等于 $1$ 时，优先使用 $2$ 技能。

显然。

- 特殊情况：怪兽数等于 $2$ 且有一只血量为 $1$ 时，优先使用 $1$ 技能。

打死一只的同时，还可以对另一只造成 $1$ 点伤害。

## 实现

受到[这位大佬](https://www.luogu.com.cn/blog/hxjismysontoo/solution-p10072)的题解的启发，我们可以循环能量值而不是当前打到的怪物数，有效减少很多码量！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,m,a[100001],temp,ans,wz=1;

void work(){
    while(a[wz]-temp==0&&wz<=n) wz++;
}

signed main(){

    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    sort(a+1,a+n+1);

    int num=n+1;
    for(int i=1;i<=m&&wz<=n;i++){//wz代表打的是第几只怪
        if((n-wz+1)>2) temp++,work();//2只以上先用AOE
        else if(a[wz]-temp==1) temp++,work();//否则判一下是否是1
        else{//否则暴击
            a[wz]-=2;
            if(a[wz]-temp==0) wz++;
        }
        ans+=n-wz+1;
    }
    for(int i=wz;i<=n;i++) ans+=(n-i+1)*(a[i]-temp)-1;
   //因为打最后一下的时候怪就会死，不会造成伤害所以-1
    printf("%lld",ans);
}
```

---

## 作者：WaterSky (赞：8)

# [P10072 [GDKOI2024 普及组] 刷野 I](https://www.luogu.com.cn/problem/P10072)

赛事想出正解，可是打挂了，有错误欢迎指出！

---
又出锅了，再再再次更改。

感谢 [潘德理2010](https://www.luogu.com.cn/user/572133) 的 hack。

感谢 [xiaosi4081](https://www.luogu.com.cn/discuss/781412) 的 hack。

感谢 [N_z_](https://www.luogu.com.cn/user/320087) 的 hack。

提供四组 hack 数据：

数据 $1$：

输入（由 潘德理2010 提供）：
```
2 10000
1 3

```
输出（由 潘德理2010 提供）：
```
1
```

数据 $2$：

输入（自造）：
```
2 10000
3 5

```
输出（自造）：
```
4
```

数据 $3$：

输入（由 xiaosi4081 提供）：
```
3 2
1 2 2
```
输出（由 xiaosi4081 提供）：
```
2
```

数据 $4$：

输入（由 N_z_ 提供）：
```
2 1
4 3
```
输出（由 N_z_ 提供）：
```
6
```

哈哈，被你们给 hack 笑辣！

哈哈，被野给刷傻辣！

---

## 算法：
贪心。

## 思路：
我们可以让 $n$ 不断增加，假设 $m$ 无限，然后想此时的最优解。

- 当 $n=1$ 时，肯定是不断用天音波，因为如果用天雷破，就只是相当于普通攻击。

- 当 $n=2$ 时，出现以下情况：

在正常情况下时使用天音波，因为我们的目的是让受到的伤害最小化，所以我们可以使用天音波先击败血量最小的，然后再继续使用天音波结束游戏。

当出现有一个怪物血量为 $1$，我们可以使用天雷破将它击杀，顺便扣除另一个一点血，因为这种情况时，天雷破，普通攻击和天音波对那只怪物的伤害都为 $1$，不妨使用对另一只额外能造成 $1$ 伤害的天雷破。

显而易见，出现这种情况时，这种策略是最优解。

- 当 $n=3$ 时，则是选择使用天雷破，将怪物击败到 $n$ 小于 $3$ 时改用天音波。

可以这样想：

设其中的最小值为 $x$。

那么三个数有以下几种情况： 

- $x,x+y,x+y+z$

那么使用以上策略则受到的伤害为 $3x+2(y \div 2+k_1)+z \div 2+k_2$，其中，$k_1$ 表示 $y \div 2$ 时的余数，$k_2$ 同理。

- $x,x,x+y$

那么使用以上策略则受到的伤害为 $3x+y \div 2+k_2$。

- $x,x,x$

- $x,x+y,x+y+z$

那么使用以上策略则受到的伤害为 $3x$。

可以证明以上策略为最优解，请读者自行思考！

- 当 $n > 3$ 时，与 $n=3$ 时的策略一样。

那么**总结**，我们可以持续使用天雷破，直到数量小于 $3$ 时，转用天音波，如果使用天音波的时候，有一只怪物的血量为 $1$ 时，用普通攻击，原因显而易见。当能量使用完了，则改用普通攻击。

## 实现（同上）：

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[100005],s,b[100005];
long long sum=0;
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        int j=i;
        while(1) {
            i++;
            if(a[i]!=a[i-1]) {i--;break;}
        }
        b[j]=i;
    }
    for(int i=1;i<=n;i++){
        a[i]-=s;
        if(a[i]<=0) continue;
        if(m>0) {
            if(n-i>=2 || (n==i+1 && a[i]==1)) {
				long long c=0;
                while(m>0 && a[i]>0) m--,s++,a[i]--,c++;
                if(a[i]==0) sum+=(c-1)*(n-i+1)+(n-b[i]);
                else sum+=c*(n-i+1)+(a[i]-1)*(n-i+1)+(n-i);
            }
            else { 
                long long c=0;
                while(m>0 && a[i]>0) {
                    if(a[i]==1) break;
                    m--,a[i]-=2,c++;
				}
                if(a[i]==0) sum+=(c-1)*(n-i+1)+(n-i);
                else if(a[i]==1 && m>0) sum+=c*(n-i+1)+(n-i),s++,m--;
                else sum+=(c+a[i]-1)*(n-i+1)+(n-i);
            }
            continue;
        }
        sum+=(a[i]-1)*(n-i+1)+(n-i);
    }
    cout<<sum;
    return 0;
} 
```
感谢管理员审核！

---

## 作者：0_lan_0 (赞：7)

## [题目传送门](https://www.luogu.com.cn/problem/P10072)
代码于 2024.2.23 进行了修改

代码于 2024.2.28 进行了修改

被 hack 几次了。

hack 数据：

in：
```
3 3
3 3 3
```

ans：
```
6
```

#    题目大意  
有 $n$ 个怪物，第 $i$ 个怪物血量为 $a_i$，有三种攻击方式：

普攻：$0$ 点能量，对一个怪物造成一点伤害。

天音波：$1$ 点能量，对一个怪物造成两点伤害。

天雷破：$1$ 点能量，对所有怪物造成一点伤害。

每轮所有存活的怪物对你造成 $1$ 点伤害。

问：$m$ 点能量击杀所有怪物最少损失血量。
#   思路
 当 $n \le 2$ 时，当你有能量，天音波和天雷破皆可造成 $2$ 点伤害，但为了损失更少血量，目标怪物血量大于 $1$ 时先使用天音波更佳，当目标怪物血量等于 $1$ 时，用天雷破。如：$1$，$3$ 先用天雷破再用天音波。
 
 当 $n > 2$ 时，当你有能量，假设有 3 只怪物 $a_1,a_2,a_3 (a_1 \le a_2 \le a_3)$，分两种情况。
 
 1、优先使用天音波，此时受到的伤害:
 $$
 w_1=x_1a_1+x_2a_2+x_3a_3-k(x_1,x_2,x_3 > 0,k \le 3)
 $$
 
 2、优先使用天雷破，此时受到的伤害：
 $$
 w_2=a_1+a_2+a_3-3
 $$
 
由于 $w_1\le w_2$，所以优先用天雷破使 $n \le 2$，其余同上。
#    Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int n,m,a[N],ans,f;
void play(){
    int x=a[n-1],y=a[n];
    while(x>0 || y>0){
        if(m>0){
            m--;
            if(x>2) x-=2,ans+=2;
            else if(x==2) x-=2,ans++;
            else if(x==1&&y>1) x--,y--,ans++;
            else if(x==1&&y==1) x--,y--;
            else if(y==2) y-=2;
            else if(y==1) y--;
            else y-=2,ans++;
        }
        else{
            if(x>0) ans+=2*x-1+y-1,x=0,y=0;
            else if(y>0) ans+=y-1,y=0;
        }
    }
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    sort(a+1,a+n+1);
    if(n==1){
    	if(a[1]<m*2){
    		printf("%lld",a[1]/2+(a[1]&1)-1);
    		return 0;
    	} 
    	a[1]-=m*2;
    	printf("%lld",m+a[1]-1);
    	return 0;
    }
    if(a[n-2]<=m){
        m-=a[n-2];
        for(int i=1;i<=n-2;i++) ans+=a[i]-1;
        a[n-1]-=a[n-2],a[n]-=a[n-2];
        ans+=2*a[n-2];
        if(a[n-1]==0) ans--;
        if(a[n]==0) ans--;
        if(a[n-1]>0||a[n]>0) play();
    }
    else{
        for(int i=1;i<=n;i++){
            ans+=f+a[i]-1;
            if(a[i]>=m) f+=a[i]-m;
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：shinzanmono (赞：6)

非常好题目，使题解审核志愿者手抽筋。

考虑如何将收益最大化。

显然，使用技能一定更优，所以要尽可能多使用技能。

设三种操作分别为 $1,2,3$。

- 情况一：$n\geq 3$
  
  这种情况显然操作三的收益更大。（操作二回合数增大，显然不优）

- 情况二：$n=2$

  这种情况又可以分为两种
  
  1. 序列中不存在 $1$，我们对较小者发动技能 $2$（回合数不变，一只先死）。
  2. 序列中存在 $1$，我们发动技能 $3$（发动技能二会导致白打伤害）。
  
- 情况三：$n=1$
 
  优先使用技能 $2$ 即可。

最终复杂度可以做到 $O(n+m)$，但是我懒，写的 $\log$ 做法。

```cpp
#include<iostream>
#include<algorithm>
#include<set>
const int sz=1e5+10;
int a[sz];
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n,m;
    std::cin>>n>>m;
    for(int i=1;i<=n;i++)std::cin>>a[i];
    std::sort(a+1,a+n+1);
    long long ans=0;
    if(m==0){
        long long tot=0;
        for(int i=1;i<=n;i++)tot+=a[i],ans+=tot-1;
        std::cout<<ans<<"\n";
        return 0;
    }
    if(n>=3){
        std::multiset<int>s;
        for(int i=1;i<=n;i++)s.insert(a[i]);
        int max=0;
        while(s.size()>=3&&*s.begin()<=m){
            int cnt=0;
            auto it=s.begin();
            while(it!=s.end()&&*it==*s.begin())cnt++,it++;
            ans+=s.size()*(*s.begin()-max)-cnt;
            max=std::max(max,*s.begin());
            s.erase(s.begin(),it);
        }
        n=s.size();
        if(n>=3)ans+=s.size()*(m-max),max=m;
        m-=max;
        for(int i=1;i<=n;i++)a[i]=*s.begin()-max,s.erase(s.begin());
    }
    if(m==0){
        long long tot=0;
        for(int i=1;i<=n;i++)tot+=a[i],ans+=tot-1;
        std::cout<<ans<<"\n";
        return 0;
    }
    if(n==2){
        while(m>0){
            m--;
            if(a[1]>=2)a[1]-=2;
            else a[1]--,a[2]--;
            if(a[1]>0)ans++;
            if(a[2]>0)ans++;
            if(a[1]==0){
                n=1,a[1]=a[2];
                if(a[1]==0)n=0;
                break;
            }
        }
    }
    if(m==0){
        long long tot=0;
        for(int i=1;i<=n;i++)tot+=a[i],ans+=tot-1;
        std::cout<<ans<<"\n";
        return 0;
    }
    if(n==1){
        if(2*m>=a[1])ans+=(a[1]-1)/2;
        else ans+=a[1]-m-1;
    }
    std::cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：MicroSun (赞：5)

**upd on 24.2.24：添加了代码，能通过所有已知hack。欢迎继续hack！**

贪心神题。

赛时脑子不好使，半天没想出来。以下为听完讲座后的思路。

先说结论:

- 在有能量时，普攻必然劣于技能攻击。

- 如怪物数量大于 $3$，或者怪物数量为 $2$ 且血量最小的怪物的血量为 $1$ 则使用群体攻击。

- 否则单体攻击，先攻击血量较低者。

考虑分类讨论证明。

下面为证明及详细做法。

1. $n=1$

很明显：

- 用群体攻击就是浪费能量

- 使用双倍伤害的单体攻击直到能量用完一定不劣于普攻。

2. $n=2$

持续对血量较低者进行攻击，直到 $\min(a_1,a_2)=1$，因为普攻劣于技能攻击且明显“双倍伤害”的技能无用，所以使用“群体攻击”。

因为普攻劣于技能，所以除了“双倍伤害”，只能使用“群体攻击”，否则更劣。

“群体攻击”和“双倍伤害”对总血量的贡献都是 $-2$，回合数相同。但是“双倍伤害”会使两只怪物中的一只先死亡，使主角在后面几个回合受伤更少。

由此得证。

3. $n=3$

如 $\min(a_1,a_2,a_3)=1$，可以进行一次全体攻击并转换为 $n=2$ 的情况。

否则令 $a_1\le a_2\le a_3$：

“双倍伤害”的伤害柿子比较长，但是可以感性化简成这样：

$$s_1=x_1a_1+x_2a_2+x_3a_3+k\space(x_1,x_2,x_3\ge1,k\ge-3)$$

“群体攻击”所耗费的血量为

$$\begin{aligned}s_2&= 3(a_1-1)+2(a_2-a_1)+(a_3-a_2)\\&=3a_1-3+2a_2-2a_1+a_3-a_2\\&=a_1+a_2+a_3-3\end{aligned}$$

明显 $s_1\ge s_2$，所以成立。

4. $n>3$

可以类比 $n=3$ 进行证明。

Code：
```cpp
// Problem: P10072 [GDKOI2024 普及组] 刷野 I
// LuoguUID: 514700 
// LuoguUserName: MicroSun
// 
// Powered by CP Editor (https://cpeditor.org)

#include<iostream>
#include<algorithm>
using namespace std;
#define endl '\n'
#define pb push_back
#define fst first
#define scd second
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define dep(i,s,e) for(int i=s;i>=e;i--)

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;

const int maxn=1e5+10;

ll a[maxn];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	ll n,m;
	cin>>n>>m;
	rep(i,1,n) cin>>a[i];
	ll aoe=0,die=0,cnt=0;
	//aoe是群攻标记，记得每次调用a[i]时都要减aoe
	sort(a+1,a+1+n);
	while(die<n){
		//群攻
		if((n-die>=3||(n-die==2&&a[die+1]-aoe==1))&&m){
			ll lstaoe=aoe;
			aoe+=min(a[die+1]-aoe,m);
			m-=aoe-lstaoe;
			ll lst=die;
			while(a[die]-aoe<=0&&die<=n) ++die;
			--die;
			cnt+=(n-lst)*(aoe-lstaoe)-(die-lst);
			//最后一次aoe会少受到(die-lst)的伤害
		}
		//单体暴击
		else if(m){
			if(a[die+1]-aoe==1){
				a[die+1]--;
				die++;
				cnt+=n-die;
			}//避免出现血量为一时的死循环
			else{
				ll k=min((a[die+1]-aoe)/2,m);
				//k是操作次数
				a[die+1]-=k*2;
				m-=k;
				cnt+=k*(n-die);
				if(a[die+1]-aoe==0){
					++die;
					--cnt;
				}
			}
		}
		else{
			ll k=a[die+1]-aoe;
			a[die+1]=aoe;//即0
			cnt+=k*(n-die)-1;
			++die;
		}
	}
	cout<<cnt;
    return 0;
}

```

---

## 作者：Wuyanru (赞：4)

听说好多人都被 hack 了？

我也来试试，欢迎 hack！

## 题意

现在有 $ n $ 只怪物，第 $ i $ 只血量是 $ a_i $，你要打这些怪物，流程是这样的：

打怪的方式是你先攻击，然后怪物攻击，一直轮换，直到怪物死绝。

其中怪物每次攻击的伤害是当前活着的怪物总数。

怪物的血量只要到 $ 0 $ 及以下，怪物就会死。

你的攻击方式有三种，具体可以看题面。

求你最少降低的血量。

数据范围是 $ 1\le n,m\le 10^5 $，且 $ 1\le a_i\le 10^9 $。

## 题解

这种题显然不能直接算答案，我们要先确定最优的打怪策略。

首先我们知道对于任意两个怪 $ x,y $，若 $ a_x\le a_y $，那么 $ x $ 一定不会比 $ y $ 死的更晚。

这个结论显然，因为如果我们先打了血量更高的 $ y $，就会承受更高的伤害。

那么我们就可以将所有怪按照血量从低到高排序，越前面的一定越早死。

其次，我们一定是先用技能，再用普通攻击，因为这样可以使得我们先打的怪更早死亡。

后面就很难看出其他策略了，不妨来进行分类讨论。

当 $ n=1 $ 时：

此时群体技能与普通攻击相等，显然不会使用群体技能。

所以此时我们会优先使用单体技能，其次使用普通攻击。

收到伤害的总数是容易计算的。

当 $ n=2 $ 时：

设剩下两个怪的血量分别是 $ a_1,a_2(a_1\le a_2) $。

首先如果没有能量了，那就是普通攻击一个一个打过去，不提了。

问题主要在于，如果我们有能量，是使用群体技能还是单体技能。

稍作思考会发现，此时两种技能造成的总伤害是相同的。

那么我们要做的，就是让血量更少的怪（即 $ a_1 $）更早死亡，所以我们应该优先对 $ u $ 使用单体技能。

特别地，若 $ a_1=1 $，那么单体技能伤害是 $ 1 $，此时使用群体技能，不仅可以将 $ a_1 $ 消灭，还可以将 $ a_2 $ 打掉一滴血，会更优。

当 $ n\ge 3 $ 时：

设血量最小的两只怪物，血量为 $ a_1,a_2(a_1\le a_2) $。

如果没有能量了，和上面一样，肯定是依次普攻打过去。

问题还是优先使用单体技能还是群体技能。

如果我们使用了单体技能，考虑把一次单体技能，换成一次群体技能和一次普攻（其余攻击顺序与目标不变）有什么效果？

首先，剩余能量值没有变，$ a_1 $ 最终血量没有变。

因为 $ a_1 $ 晚死了一回合，我们多受了 $ n $ 的伤害，所有的 $ a_2\sim a_n $ 各多受了 $ 1 $ 的伤害。

此时我们分类讨论一下

第一种情况是，因为我们使 $ a_2 $ 多受 $ 1 $ 点伤害，所以 $ a_2 $ 早死了一回合。

此时因为 $ a_2 $ 早死了一回合，我们又少受了 $ n-1 $ 的伤害，所以我们算回来，是以 $ 1 $ 的伤害攻击了 $ a_3\sim a_n $ 各一滴血，这显然是不劣的。

第二种情况是，因为 $ a_2 $ 最后使用了单体伤害，$ a_2 $ 死亡时间并没有变晚。

这个时候我们再把这个单体伤害改成群体伤害。

相当于是我们以 $ n $ 的代价，攻击了 $ a_3\sim a_n $ 各两次，这显然也是不劣的。

所以综上所述，此时用单体攻击一定是不优的，所以我们的策略优先使用群体攻击。

## 策略总结

1. 当 $ n=1 $ 时，优先用单体；
2. 当 $ n=2 $ 时，若剩 $1 $ 滴血，优先用群体，否则优先用单体；
3. 当 $ n\ge 3 $ 时，优先用群体。

## 代码

复杂度是 $ O(n\log n) $，瓶颈是排序。

感觉会被 hack 啊。

```c++
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f3f3f3f3fll
#define debug(x) cerr<<#x<<"="<<x<<endl
using namespace std;
using ll=long long;
using ld=long double;
using pli=pair<ll,int>;
using pi=pair<int,int>;
template<typename A>
using vc=vector<A>;
inline int read()
{
	int s=0,w=1;char ch;
	while((ch=getchar())>'9'||ch<'0') if(ch=='-') w=-1;
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int a[100001];
int n,m;
inline ll solve1()
{
	while(a[n]==0&&n) n--;
	if(n==0) return 0;
	if(n==1)
	{
		if(2*m>=a[1]) return (a[1]+1)/2-1;
		a[1]-=2*m;
		return a[1]+m-1;
	}
	else
	{
		assert(n==2);
		//先对小的用单体
		ll ans=0;
		int num=min(a[2]/2,m);
		ans=2*num,m-=num,a[2]-=2*num;
		if(a[2]<=0) ans--;
		//小的没死,补刀
		if(a[2])
		{
			if(m)
			{
				a[2]=0,a[1]--,m--;
				if(a[1]>0) ans++;
			}
			else
			{
				ans+=a[2]*2-1,a[2]=0;
			}
		}
		//打大的.
		if(a[1])
		{
			num=min((a[1]+1)/2,m);
			ans+=num,m-=num,a[1]-=2*num;
			if(a[1]<=0) ans--;
			else ans+=a[1]-1;
		}
		return ans;
	}
}
inline ll solve()
{
	if(n<=2) return solve1();
	int num=min(a[3],m);ll ans=0;
	for(int i=1;i<=n;i++)
	{
		ans+=min(num,a[i]-1);
		a[i]=max(a[i]-num,0);
	}
	m-=num;
	for(int i=n;i>=3;i--) if(a[i]) ans+=(ll)a[i]*i-1,a[i]=0;
	// printf("%lld %d\n",ans,m);
	// for(int i=1;i<=n;i++) printf("%d%c",a[i]," \n"[i==n]);
	return ans+solve1();
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1,[](int a,int b){ return a>b;});
	ll ans=solve();
	printf("%lld\n",ans);
	return 0;
}
```

感谢观看！

---

## 作者：xiaosi4081 (赞：3)

# P10072 题解

由于 [hack](https://www.luogu.com.cn/discuss/781412) 掉了很多人，所以决定写一篇题解。

## 结论

先给出结论：

如果当前存活人数 $\ge 3$，能用天雷破直接用天雷破。

如果当前存活人数 $=2$，当较小的一只怪血量 $=1$ 时，用天雷破，否则用天音波，这样可以防止伤害的浪费。

如果当前存活人数 $=1$，直接用天音波（如果可以的话）。

## 小小的证明

显然，如果人数大于等于 $3$ 用天雷破对怪物造成的伤害总数必然是大于用天音波造成的伤害的。这可能很奇怪，但可以看看下面的分析。

有人这么想：如果要用最快的速度减少人数，可以直接不断天音波攻击。

如果是全用天雷破，其对 Zayin 造成的伤害总共是 $\sum_{i=1}^n a_i-1$，而如果全用天音波，其对 Zayin 造成的伤害约为 $\dfrac {\sum_{i=1}^ns_i} 2$，甚至比这个数还大很多，其中 $s$ 数组是 $a$ 的前缀和数组。所以结论显然，用天雷破会更优。

## ACCODE

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[100005]; 
signed main(){
	cin>>n>>m;int alive=1;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n);int all=0;long long ans=0;
	for(int i=1;alive<=n;i++){
		if(i>m){
			while(a[alive]-all<=0&&alive<=n)++alive;
			ans+=(a[alive]-all)*(n-alive+1)-1;
			++alive;
			continue;
		}
		if(n-alive+1>2){
			++all;
			while(a[alive]-all<=0&&alive<=n)++alive;
			ans+=n-alive+1;
		}
		else if(n-alive+1>1){
			if(a[alive]-all==1){
				++all;
				while(a[alive]-all<=0&&alive<=n)++alive;
				ans+=n-alive+1;
			}
			else{
				a[alive]-=2;
				if(a[alive]-all<=0&&alive<=n)++alive;
				ans+=n-alive+1;
			}
		}
		else{
			a[n]-=2;
			if(a[n]-all<=0)break;
			if(a[alive]-all<=0&&alive<=n)++alive;
			ans+=n-alive+1;
		}
	}
	cout<<ans<<endl; 
	return 0;
}
```

---

## 作者：heaksicn (赞：2)

update: 被叉了，原因是在处理一个 $0$ 时贡献算成了 $-1$。

考虑贪心。

首先对于 $n\leq 2$ 特判。

- 当 $n=1$ 时：尽量使用天音波即可。

- 当 $n=2$ 时：优先对血量少的人使用天音波即可。注意当这个人的血量剩下 $1$ 的时候，天音波会溢出 $1$ 点伤害，此时改为使用天雷破。

对于 $n>2$ 的情况。

首先，无论如何，技能的效果都是强于普攻的，所以要先尽量用技能。

然后，我们会优先选取血量少的人攻击。证明类似于排队接水。

其次，我们尽量选取天雷破而非天音波。证明：在不使用技能的基础上，使用一次天音波会使得被伤害得怪提早 $1$ 回合死亡，但使用天雷破会使得其他 $n-1$ 个怪提早 $1$ 回合死亡，明显是后者更优。

模拟上述过程即可。

代码是听课的时候写的，有点幽默。看看就行。

```
//Man always remember love because of romance only!
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int a[100001];
int n,k;
int work(){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(a[i]==0) continue;
		ans+=(a[i]-1)*(n-i+1)+(n-i);
	}	
	return ans;
}
signed main(){
	n=read(),k=read();
	for(int i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1);
	if(n==1){
		int ans=0;
		if((a[1]+1)/2<=k) ans+=(a[1]+1)/2-1;
		else ans+=a[1]-k-1;	
		write(ans);
	}else if(n==2){
		int ans=0;
		if((a[1]+1)/2>k){
			ans+=2*k;
			a[1]-=2*k;
			ans+=work();
		}else{
			int tp=(a[1]+1)/2;
			k-=tp;
			if(a[1]%2){
				int x=(a[1]-1)/2;
				ans+=2*x;
				if(a[2]!=1) ans++;
				a[2]--;
			}else{
				int x=a[1]/2;
				ans+=(2*x-1);
			}
			if(a[2]){
				if((a[2]+1)/2<=k) ans+=(a[2]+1)/2-1;
				else ans+=a[2]-k-1;
			}
		}
		write(ans);
		return 0;
	}else{
		int ans=0,now=0;
		if(k<a[n-2]){
			for(int i=1;i<=n-2;i++){
				if(a[i]-now>k){
					ans+=k*(n-i+1);
					now+=k;
					k=0;
					break;
				}
				int l=i,r=i;
				while(r<n&&a[r+1]==a[l]) r++;
				ans+=(a[i]-1-now)*(n-i+1)+(n-r);
				k-=a[i]-now;
				now=a[i];
				i=r;
			}
			for(int i=1;i<=n;i++) a[i]=max(a[i]-now,0ll);
			ans+=work();
		}else{
			for(int i=1;i<=n-2;i++){
				int l=i,r=i;
				while(r<n&&a[r+1]==a[l]) r++;
				ans+=(a[i]-1-now)*(n-i+1)+(n-r);
				now=a[i];
				i=r;
			}
			a[1]=a[n-1]-now,a[2]=a[n]-now;
			n=2;
			k-=now;
//			cout<<ans<<" "<<k<<endl;
//			cout<<a[1]<<" "<<a[2]<<endl;
			if(a[2]==0){
				
			}else if(a[1]==0){
//				cout<<"0 "<<a[2]<<endl;
				a[1]=a[2];
				if((a[1]+1)/2<=k) ans+=(a[1]+1)/2-1;
				else ans+=a[1]-k-1;
			}else{
				if((a[1]+1)/2>k){
					ans+=2*k;
					a[1]-=2*k;
					ans+=work();
				}else{
					int tp=(a[1]+1)/2;
					k-=tp;
					if(a[1]%2){
						int x=(a[1]-1)/2;
						ans+=2*x;
						if(a[2]!=1) ans++;
						a[2]--;
					}else{
						int x=a[1]/2;
						ans+=(2*x-1);
					}
					if(a[2]){
						if((a[2]+1)/2<=k) ans+=(a[2]+1)/2-1;
						else ans+=a[2]-k-1;
					}
				}
			}	
		}
		write(ans);
		return 0;
	}
	return 0;
}


```


---

## 作者：dontwannacry (赞：2)

# [P10072](https://www.luogu.com.cn/problem/P10072)
## Re：从部分分开始的写题生活
一开始没什么思路的话，就考虑一下特殊情况吧：

对于 $m=0 $：不难看出是一个类似于[排队接水问题](https://www.luogu.com.cn/problem/P1223)的贪心。所以我们先对怪的血量从小到大排序（这样的打怪顺序能让扣的血量最少化），再求出把怪物一点一点刮死的过程中扣掉的血量即可。

#### 15 分代码（不开 `long long` 见祖宗）：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long N,M,num[100010],sum[100010],ANS;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin >> N >> M;
	for(int i = 1;i <= N;++i)cin >> num[i];
	sort(num+1,num+1+N);
	for(int i = 1;i <= N;++i){
		sum[i] = sum[i-1] + num[i];
		ANS += sum[i]-1;
	}
	cout << ANS;
	return 0;
}
```
## 从部分分到正解

让我们加入酷炫的**天音波**和**天雷破**吧！

从平常的~~摸鱼打游戏~~生活经验来看，天音波是单体高伤，适合在怪少的时候用；而天雷破是群伤，怪多的时候效果更好。

量化一下，用天音波可以让剩下的 $n$ 只怪每只都少活一回合（让剩余血量最少的怪多扣一滴血），能让主角少扣 $n$ 滴血；用天雷破能让打怪顺序外的 $n-1$ 只怪都多扣一滴血，相当于把天音波的效果计算 $n-1$ 次，能让主角少扣 $\sum\limits_{i=1}^{n-1}{i}=\frac{n\times(n-1)}{2}$ 滴血。计算可得，当 $n\le2$ 时用天音波更好，$n\ge3$ 时用天雷破更好。

### 小坑：
- 当怪物的血量还剩 $1$ 点时，天音波是无效的。跳过这只怪，或者使用天雷破。

#### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long N,M,num[100010],sum[100010],ANS;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin >> N >> M;
	for(int i = 1;i <= N;++i)cin >> num[i];
	sort(num+1,num+1+N);
	for(int i = 1;i <= N;++i){
		sum[i] = sum[i-1] + num[i];
		ANS += sum[i]-1;
	}
	for(int i = 1,t = 1,p = 0,k = 0;i <= M;++i){
		//p是使用了天雷破的次数，k是当前怪物被天音波消耗的血量数
		if(t > N)break;
		if(N-t+1 >= 3||num[t]-p-k == 1){
			ANS -= (N-t+1)*(N-t)/2;
			++p;
			while(num[t]-p-k == 0){++t;k = 0;}
		}else{
			k += 2;
			ANS -= (N-t+1);
			while(num[t]-p-k == 0){++t;k = 0;}
		}
	}
	cout << ANS;
	return 0;
}
```

---

## 作者：Vct14 (赞：1)

被 Hack 了四次，汗流浃背了。

死亡原因：判断顺序写错了。

------------


贪心题。

我们肯定需要先使用天音波或是天雷破来减少怪物数量，从而使得怪物的数量减少，也就是每轮怪物对 Zayin 造成的伤害减少。

我们首先需要明确，在面对多个怪物时，我们才会使用天雷破。因为当只剩下一个怪物时，天雷破与普通攻击无异，并且会多消耗 $1$ 点能量值。因此只有一个怪物时，我们选择尽量使用天音波，最后当怪物只剩下一滴血时使用普通攻击，节省能量值。

而在剩下两个怪物时，天音波和天雷破都可以使所有怪物的总血量减少两点，但是天音波可以使某一只怪物血量减少得更快。仅当怪物只剩下一滴血时，使用天雷破更优。我们先用天音波攻击血量较少的，这样就可以使得这只怪物对 Zayin 造成的伤害减少。

剩下大于或等于三个怪物时，对比普通攻击某一只怪物，天音波可以使其早一轮死亡，而天雷破可以使所有其他怪物早一轮死亡，天雷破更优。即相较于使用天音波，天雷破可以更多地减少怪物总血量。因此先使用天雷破，直到只剩下两个怪物在按照上文策略攻击。

如果在贪心过程中，能量值消耗完了，则只能使用普通攻击。

更多细节实现请看代码。可以通过目前为止[所有 Hack 数据](https://www.luogu.com.cn/paste/36nlwtpe)。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e5+2; 
int a[N];
int b[N];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n,m;cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    sort(a+1,a+n+1);

    for(int i=1; i<=n; i++){ // 统计同血量怪物，作用见第 67 行 
        int x=i;
        while(1){
            i++;
            if(a[i]!=a[i-1]){
                i--;
                break;
            }
        }
        b[x]=i;
    }

    int bld=0,sum=0; // bld 代表使用天雷破减少的血量，sum 表示总减少血量 
    for(int i=1; i<=n; i++){ // 从血量最少的怪物开始 
        a[i]-=bld;
        if(a[i]<=0) continue;
        if(!m){ // 没有能量只能普通攻击 
            sum+=a[i]*(n-i+1)-1;// 最后此怪物死亡后无法造成伤害，因此减 1 
            continue;
        } 
        bool tyb=false;
        if(n-i+1<3 && !(n-i+1==2 && a[i]==1)){
            long long cnt=0; // 使用天音波的次数 
            while(1){
                if(a[i]==0){ // 怪物死亡 
                    sum+=cnt*(n-i+1)-1;
                    break; 
                } 
                if(m==0){ // 能量耗尽 
                    sum+=(cnt/*天音波*/+a[i]/*剩余血量*/)*(n-i+1)-1; // 对单个怪物，不用像上文一样考虑其它同血量怪物 
                    break;
                }
                if(a[i]==1){
                    if(n-i+1==1) sum+=(cnt+1)*(n-i+1)-1; // 换普通攻击 
                    else sum+=cnt*(n-i+1); // （这里是第 50 行）有多只怪物，还需使用天雷破 
                    break; 
                } 
                m--;a[i]-=2;
                cnt++;tyb=true;
            }
        }
        if(!m) continue; // 没有能量只能普通攻击，以免能量耗尽且怪物剩余一滴血时影响判断 
        if(n-i+1>=3 || (n-i+1==2 && a[i]==1)){ // 还有三个怪物及以上，尽量使用天雷破 
            //有两个怪物且当前怪物血量为 1 时用天雷破更优，见第 50 行 
            long long cnt=0; // 使用天雷破的次数 
            while(1){
                if(a[i]==0){ // 怪物死亡 
                	if(tyb) sum+=cnt*(n-i+1)-1; // 使用过天音波后，原来与此怪物血量相同的现在血量不相同，因此会造成伤害 
                    else sum+=(cnt-1)*(n-i+1)/*用天雷破*/+(n-b[i])/*最后一次其它怪物（与此怪物血量相同的已经死亡，不会造成伤害）*/;//（这里是第 67 行）
                    bld+=cnt;
                    break; 
                } 
                if(m==0){ // 能量耗尽 
                    sum+=cnt*(n-i+1)/*用天雷破*/+(a[i]*(n-i+1)-1)/*普通攻击*/;
                    bld+=cnt;
                    break;
                }
                m--;a[i]--;
                cnt++;
            } 
        }
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：cheng2010 (赞：0)

# [GDKOI2024 普及组] 刷野 I
- ## 思路
这题是贪心，如何贪心呢？

先下个结论：
### 要先将能量用光！！！

首先，我们看，当怪物数量 $x \ge 3$ 时，集体攻击肯定是利润最大的，因为这肯定比一次打两滴血所打的血多。

其次，若打的只剩下两只，要先看有没有血量为一的，有就再用集体攻击。

现在，若还有能量，全部用在暴击（打两滴血）上。

最后，打一滴血。

- ## 实现
先将输入的序列**排序**。

再做以下规定：

$x$：当前打死了 $1 \sim (x-1)$ 的怪物，初值为一。

$sum$：当前用的能量。

$ans$：储存答案。

先进行第一步操作：

```cpp
while(m>0&&x<=n-2)//判断边界
{
	sum++;//所用能量加一
	m--;//剩下能量
	while(a[x]-sum<=0&&x<=n-2)//如果下一只怪物被打死
		x++;//就判断下一只
	ans+=n-x+1;//统计答案
}
```

再做特判（若打的只剩下两只，要先看有没有血量为一的）。

```cpp
if(m>0)
{
	if(a[n-1]==1)//若有
	{
		m--;//剩余能量减一
		sum++//记得加上
		x++;//记得x加一
		ans+=1;//答案加一
	}
	if(a[n]==1)
	{
		printf("%lld",ans);
		return 0;
	}
}
```

然后暴击它们！！！

```cpp
while(m>0)//若还有能量
{
	a[x]-=2;//暴击
	m--;
	if(a[x]-sum>0)//没杀死
		ans+=n-x+1;
	else//杀死
	{
		ans+=n-x;
		x++;
	}
}
```
最后打一滴血。
```cpp
while(x<=n)
{
	ans+=(n-x+1)*(a[x]-sum-1)+(n-x);//第x只的剩下贡献
	x++;
}
```

- ## 注意
本题 hack 很多，有一些特判要做。
- 一、还剩两个怪时：
```cpp
if(a[n-1]-sum==0&&(a[n]-sum==0||a[n]-sum==1))
{
	printf("%lld",ans);
	return 0;
}
if(a[n-1]-sum==1&&a[n]-sum==1&&m!=0)
{
	printf("%lld",ans);
	return 0;
}
```

- 二、暴击前的处理：
```cpp
if(x==n-1&&m>0)
{
	if((a[n]-sum)%2&&(a[n-1]-sum)%2&&m>2)
	{
		m--;
		a[n]--;
		a[n-1]--;
		ans+=2;
	}
}
```
- ## 愉快 AC ！
记得开 `long long`！
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans;
const int N=2e5+7;
int n,m,a[N],x=1,sum;
signed main()
{
//	freopen("jungle.in","r",stdin);
//	freopen("jungle.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+1+n);
	while(m>0&&x<=n-2)
	{
		sum++;
		m--;
		while(a[x]-sum<=0&&x<=n)
			x++;
		ans+=n-x+1;
	}
	if(a[n-1]-sum==0&&(a[n]-sum==0||a[n]-sum==1))
	{
		printf("%lld",ans);
		return 0;
	}
	if(a[n-1]-sum==1&&a[n]-sum==1&&m!=0)
	{
		printf("%lld",ans);
		return 0;
	}
	if(m>0)
	{
		if(a[n-1]==1)
		{
			sum++;
			m--;
			x++;
			ans+=1;
		}
		if(a[n]==1)
		{
			printf("%lld",ans);
			return 0;
		}
	}
	if(x==n-1&&m>0)
	{
		if((a[n]-sum)%2&&(a[n-1]-sum)%2&&m>2)
		{
			m--;
			a[n]--;
			a[n-1]--;
			ans+=2;
		}
	}
	while(m>0)
	{
		a[x]-=2;
		m--;
		if(a[x]-sum>0)
			ans+=n-x+1;
		else
		{
			ans+=n-x;
			x++;
		}
	}
	while(x<=n)
	{
		ans+=(n-x+1)*(a[x]-sum-1)+(n-x);
		x++;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：CarroT1212 (赞：0)

卑微 J 组 T1 单推人发现自己的赛场 shift mountain 代码居然可以过讨论区的所有 hack，来发一个。

------------

由于记不住名字，下文将分别用平 A、暴击、群伤代替题目的普通攻击、天音波、天雷破。

$m=0$ 时就是一路平 A，这个血量是好算的，即为 $(\sum\limits_{i=1}^n a_i\cdot (n-i+1))-n$。

但是如果 $m\neq 0$ 的话开场就平 A 肯定是没有前途的，我们要尽量把所有的群伤暴击都用完。所以现在的问题是这俩玩意到底要怎么用。

群伤的作用是快速使所有怪的血量下降而尽快结束战局，暴击的作用是快速干死一只怪防止它给我带来不必要的伤害。那怪很少的时候群伤就没有优势，怪很多的时候暴击也没有优势。分界点在哪呢？

于是我们来尝试弄懂样例在干什么。

```plain
3 4
2 4 4
（群伤）
1 3 3（血量-=3）
（群伤）
0 2 2（血量-=2）
（暴击）
0 0 2（血量-=1）
（暴击）
0 0 0
```

结合样例考虑一个结论：**怪不少于三个的时候用群伤更优，否则暴击更优**。

~~我赛场上用 C++ 通过对拍完成了证明~~。官方题解提供了一个稍微严谨点的证法，尝试复盘一下：

> 两只怪暴击更优是显然的。考虑有三只怪的情况。当它们血量最小值为 $1$ 时显然成立。
>
> 血量最小值为 $2$ 时：
>
> + $2\ 2\ 2$：成立。
> + $2\ 2\ x$：暴击 $2+1+\lfloor \frac{x}{2}\rfloor$，群伤 $3+1+\lfloor \frac{x-2}{2}\rfloor$，成立。
> + $2\ x\ y$：设解决血量为 $a,b$ 的两只怪会损失的血量为 $f(a,b)$，那么暴击 $2+f(x,y)$，群伤 $3+2+f(x-2,y-2)$。因为 $f(x-2,y-2)$ 相比 $f(x,y)$，损失 $2$ 点血量和 $1$ 点血量的回合都至少会少一个，所以也不劣。
>
> 再往上也同理。

重申一下策略：

+ 在怪不少于三个时反复使用群伤。
+ 如果还没杀到两只怪就没蓝了，启动平 A 杀完剩下的。
+ 如果一路把怪杀到了只剩两个，优先砍死血量少的那只怪。
+ 最后一只怪也尽量光速解决。

然后是喜闻乐见的 cornercase 环节。

+ 还剩两只怪时有一只还剩一滴血。

```plain
2 3
1 5
```

显然你不能把暴击浪费在这种东西上面。遇到这种情况需要上个群伤把最后一只怪也顺便削一点。像平 A 完再给另一边上个暴击这种操作都不会比它优了。

------------

把赛场的 shift mountain 打扫了一下。原版 2.5 个 K。

作为一个现场写了拍的人，我还是比较有信心保证我的代码是卡不掉的。

```cpp
ll n,m,a[N],ans=J;
void mian() {
	scanf("%lld%lld",&n,&m);
	for (ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1),ans=0;
	if (m<=a[max(n-2,0ll)]) {
		for (ll i=1,cnt=1;i<=m;i++) {
			while (cnt<=n&&a[cnt]<=i) cnt++;
			ans+=(n-cnt+1);
		}
		for (ll i=1;i<=n;i++) a[i]=max(a[i]-m,0ll);
		for (ll i=1;i<=n;i++) if (a[i]) {
			for (ll j=n;j>=i;j--) ans+=a[j]*(n-j+1);
			ans-=n-i+1;
			break;
		}
		cout<<ans;
	}
	else {
		ll mm=m;
		for (ll i=1,cnt=1;i<=m&&cnt<=n-2;i++) {
			while (cnt<=n&&a[cnt]<=i) cnt++;
			mm--,ans+=(n-cnt+1);
		}
		for (ll i=1;i<=n;i++) a[i]=max(a[i]-(m-mm),0ll);
		while (a[n-1]>1&&mm>0) a[n-1]=max(a[n-1]-2,0ll),ans+=1+(ll)(a[n-1]>0),mm--;
		if (a[n-1]==1) {
			if (mm*2>=a[n]) mm--,a[n]--;
			a[n-1]=0,ans+=a[n]>0;
		}
		while (a[n]>0&&mm>0) a[n]=max(a[n]-2,0ll),ans+=a[n]>0,mm--;
		for (ll i=1;i<=n;i++) if (a[i]>0) {
			for (ll j=n;j>=i;j--) ans+=a[j]*(n-j+1);
			ans-=n-i+1;
			break;
		}
		cout<<ans;
	}
}
```

---


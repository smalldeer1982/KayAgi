# [GDKOI2024 普及组] 读书

## 题目描述

Zayin 是一个热爱读书的学生。

最近，Zayin 收到了一本有 $n$ 个章节的书，其中每个章节 $i$ 都有一个限制：她必须至少阅读了其他 $a_i$ 个
章节，才能够获取足够的智慧来读懂该章节。

每天，Zayin 都会从头到尾开始阅读这本书。对于她还不能读懂的章节（由于限制）或是已经阅读过的章节，Zayin 会在那天跳过它们。

现在，Zayin 想要知道至少需要多少天才能阅读完所有的 $n$ 个章节。

## 说明/提示

**本题使用子任务捆绑测试。**

对于所有测试数据，保证 $1 \leq n \leq 5 \times 10^5
, 0 \leq a_i < n$。

- Subtask 1（10%）：$1 ≤ n ≤ 10$，$d = 1$。
- Subtask 2（10%）：$1 ≤ n ≤ 500$，$d = 2$。
- Subtask 3（20%）：$1 ≤ n ≤ 5000$，$3 \leq d \leq 4$。
- Subtask 4（20%）：$1 ≤ n ≤ 10^5$，$5 \leq d \leq 6$。
- Subtask 5（40%）：$1 ≤ n ≤ 5 \times 10^5$，$7 \leq d \leq 10$。

## 样例 #1

### 输入

```
1 10
3 4 0 6 1 1 0 8 6 3```

### 输出

```
2```

# 题解

## 作者：yzx3195 (赞：11)

# 题目描述

对于一个长度为 $n$ 序列 $A$，若 $A_i$ 之前未被取过，且在取出 $A_i$ 前已取出的数的个数不小于 $A_i$，就可以把 $A_i$ 取出，经过几次这样的取出操作，可以把序列取完。

# 做法

显然，**有零取零，有较小的取较小的**。

通过上面这句话，我们可以发现，现在问题似乎转化成了求一段区间内的最小值。这是什么？

#### **线段树！**

我们可以用一颗线段树去维护一个区间内的最小值，记为 $tree$，每次取数就把那个点赋为 $\texttt {INF}$，再记录一个 $g$，表示当前已经取了 $g$ 个数，然后再看有没有节点小于 $g$，当 $tree_1$ 为 $\texttt {INF}$ 时，就退出，并输出 $ans$。

问题来了，如何判断无解呢？

读题可知，一本书最多只有 $5 \times 10^5$ 章，在有解的情况下，我们每次都能读至少一章，至多也不会超过 $5 \times 10^5$ 章，那么，我们可以记录一个 $cnt$，若 $cnt$ 大于了 $5 \times 10^5$ 则无解，输出 $-1$。

时间复杂度为 $O(n \log n)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 5 * 1e05 + 7;

const int inf = 2147483647;

int n, d;

int a[MAXN];

int tree[MAXN * 4];

int g;

int cnt;

void Build(int l, int r, int p)
{
    if(l == r) 
    {
        tree[p] = a[l];
        return ;
    }
    int mid = (l + r) >> 1    ;
    Build(l, mid, p << 1);
    Build(mid + 1, r, p << 1 | 1);
    tree[p] = min(tree[p << 1], tree[p << 1 | 1]);
}

void Query(int p, int l, int r)
{
    if(l == r)
    {
        tree[p] = inf, ++g;
        return ;
    }
    int mid = (l + r) >> 1;
    if(tree[p << 1] <= g) Query(p << 1, l, mid);
    if(tree[p << 1 | 1] <= g) Query(p << 1 | 1, mid + 1, r);
    tree[p] = min(tree[p << 1], tree[p << 1 | 1]);
    return;
}

signed main()
{
//    freopen("book.in", "r", stdin);
//    freopen("book.out", "w", stdout);
    scanf("%d%d", &d, &n);

    for(int i = 1; i <= n; i++)
    	scanf("%d", &a[i]);

    Build(1, n, 1);

    int ans = 0;    

    for(;;)
    {
        ans++;
        cnt++;
        Query(1, 1, n);
        if(tree[1] == inf) break;
        if(cnt >= MAXN)
        {
            printf("-1");
            return 0;
        }
    }

    printf("%d", ans);
}
```

---

## 作者：This_Rrhar (赞：5)

考虑分块，块长 $\sqrt n$。

记当前读了 $s$ 本书，每个块内的最小值为 $mn_i$，则：

- 若 $s\ge mn_i$，则把整个块扫一遍，更新 $s$ 值和 $mn_i$ 值。

- 若 $s<mn_i$，无法更新答案，直接跳过。

此时还是过不了，继续优化。用滚动数组 $b_{0/1}$ 来记录还有章节未读的块的编号，这样就能用 $O(1)$ 的 `clear()` 代替 $O(n)$ 的 `erase()`。

时间复杂度 $O(n\sqrt n)$，证明先咕着。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define _r return*this
#define _o &operator
namespace IO
{
	const int _S=1<<21;
	char b[_S],*p1=b,*p2=b,pb[_S],*pp=pb;
	void fl(){fwrite(pb,1,pp-pb,stdout),pp=pb;}
	struct input
	{
		char gc(){if(p1==p2)p2=(p1=b)+fread(b,1,_S,stdin);return p1==p2?' ':*p1++;}
		input _o>>(char&num){do num=gc();while(num==' '||num=='\n'||num=='\r'||num=='\t');_r;}
		template<typename T>input _o>>(T&x)
		{
			char c=gc();T f=1;
			for(x=0;!isdigit(c);)(c=='-'?f=-1:1),c=gc();
			while(isdigit(c))x=(x*10)+(c^48),c=gc();
			x*=f;_r;
		}
		input(){}
	}in;
	struct output
	{
		void pt(char num){*pp++=num;if(pp-pb==_S)fl();}
		output _o<<(char num){pt(num);_r;}
		template<typename T>output _o<<(T x)
		{
			if(!x){pt(48);_r;}
			if(x<0)pt('-'),x=-x;
			int s[64],t=0;
			while(x)s[++t]=x%10,x/=10;
			while(t)pt(s[t--]+48);
			_r;
		}
		output _o<<(const char*s){int num=0;while(s[num])pt(s[num++]);_r;}
		output(){}
	}out;
	struct fe{~fe(){fl();}}fls;
}
using IO::in;
using IO::out;
using ll=int;

#define N 500001
#define LEN 707

const ll INF=numeric_limits<ll>::max();

ll d,n;

ll a[N];

ll B,L[LEN+3],R[LEN+3];
vector<ll>b[2];
ll mn[LEN+3];

ll s,ans;

inline void block()
{
	B=n/LEN+!!(n%LEN);
	for(int i=1;i<=B;i++)L[i]=R[i-1]+1,R[i]=R[i-1]+LEN,mn[i]=INF;
	R[B]=n;
}
int main()
{
	in>>d>>n,block();
	for(int i=1;i<=B;i++)
	{
		b[0].push_back(i);
		for(int j=L[i];j<=R[i];j++)
			in>>a[j],mn[i]=min(mn[i],a[j]);
	}
	for(bool T=0;s<n;T=!T)
	{
		bool f=false;
		ans++;
		for(ll i:b[T])
			if(s>=mn[i])
			{
				mn[i]=INF;
				for(int j=L[i];j<=R[i];j++)
					if(s>=a[j])s++,a[j]=INF,f=true;
				else mn[i]=min(mn[i],a[j]);
				if(mn[i]!=INF)b[!T].push_back(i);
			}
		else b[!T].push_back(i);
		b[T].clear();
		if(!f)return out<<"-1",0;
	}
	out<<ans;
}
```

---

## 作者：aaron0919 (赞：4)

# [P10077 の题解](https://www.luogu.com.cn/problem/P10077)

### 理性分析

很明显，我们可以循环扫，如果这本书可以读，就读。

考虑优化：维护一个当前可以读懂的集合，再维护 $n$ 个数组，第 $i$ 个表示读了 $i$ 本书能读懂的章节。这样每读一本书，就将新的能读的书全部加进去。

这样只用在集合中找大于某个数的位置即可，标准库已实现。

复杂度 $O(n)$。

### code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 5e5 + 10;
const int INF = 0x3f3f3f3f;
const int MOD = 1e9 + 7;

int d, n, ans, k, cnt;
int a[N];
vector<int> t[N];
set<int> s;

int main()
{
    d = read(), n = read();
    for (int i = 1; i <= n; i++)
    {
        t[a[i] = read()].push_back(i);
    }
    d = n;
    for (const int &x : t[0])
    {
        s.insert(x);
    }
    while (d--)
    {
        k = 1;
        while (1)
        {
            auto x = s.lower_bound(k);
            if (x == s.end())
            {
                break;
            }
            k = *x;
            s.erase(k);
            cnt++;
            for (const int &x : t[cnt])
            {
                s.insert(x);
            }
        }
        if (cnt == n)
        {
            printf("%d\n", n - d);
            return 0;
        }
    }
    puts("-1");

    return 0;
}
```

---

## 作者：dinghongsen (赞：4)

### [题目传送门](https://www.luogu.com.cn/problem/P10077)

#### 题目描述
简单来说就是一个长度为 $n$ 序列 $a$，如果 $a_{i}$ 之前没有被取过，并且在取出 $a_{i}$ 之前已经取出了的数的个数不小于 $a_{i}$，才可以把 $a_{i}$ 取出。问经过几次这样的操作，才能把序列的数全部取完，不能输出 `-1`。

#### 解题思路

很明显可以想到线段树（[不懂看这里](https://www.luogu.com.cn/problem/P3372)），我们可以用一颗线段树来维护区间内的最小值。

用一个变量记录取了多少数，在修改的过程中，如果该区间的最小值小于这个变量，那就递归进去将里面所有小于这个变量的数取出，并修改为 `INF`。最后，如果整棵树的最小值就是 `INF`，说明全部取完了，输出即可。

反之，输出 `-1`。

复杂度 $O(n  \operatorname{log}  n)$。

#### code
```cpp
# include <bits/stdc++.h>
# define int long long
using namespace std;
const int INF = 2147483647;
const int N = 5e5 + 10;
int v[N], cnt;
int a[4 * N];
void build(int now, int l, int r) {
	if (r == l) {
		a[now] = v[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(now << 1, l, mid);
	build(now << 1 | 1, mid + 1, r);
	a[now] = min(a[now << 1], a[now << 1 | 1]);
}
void update(int now, int l, int r, int x) {
	if (l == r) {
		a[now] = x;
		cnt++;
		return;
	}
	int mid = (l + r) >> 1;
	if (a[now << 1] <= cnt) {
		update(now << 1, l, mid, x);
	}
	if (a[now << 1 | 1] <= cnt) {
		update(now << 1 | 1, mid + 1, r, x);
	}
	a[now] = min(a[now << 1], a[now << 1 | 1]);
}
signed main() {
	int n, d;
	cin >> d >> n;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	int ret = 0;
	while (1) {
		ret++;
		update(1, 1, n, INF);
		if (a[1] == INF) {
			break;
		}
		if (ret >= n) {
			printf("-1");
			return 0;
		}
	}
	printf("%lld", ret);
	return 0;
}
```

---

## 作者：homo_snow (赞：4)

可以发现，每次优先取 $a_i$ 较为小的章节读，是我们的主要贪心思路。

然后就有了思路：

1. 找 $a_i$ 较小的章节
2. 把他读了
3. 不断重复以上步骤

由题可得，所花费的天数顶多是 $n$ 天，超出了这个天数就不可能读完。

然后以这个思路我们就可以打出一个优秀的 $O(n^2)$ 暴力，得到 $40pts$ 的好成绩。

然后考虑优化一下,哪里能优化呢？

> 1. 找 $a_i$ 较小的章节

每次找较小之后都需要修改，然后接着找...这不就是线段树吗？

通过线段树我们可以把找最小值这一步优化成 $O(\log n)$，总的复杂度为 $O(n\log n)$。

但是最小值可能很多，我们需要把线段树 update 部分修改一下。用一个变量 $cnt$ 记录读了多少书，在 update 递归的过程中，如果该区间的最小值小于 $cnt$，那就递归进去将里面所有 $a_i$ 小于 $cnt$ 的章节读了，修改为 INF。

最后，如果整棵树的最小值就是 INF，说明读完了，输出答案即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e6+10;
const int INF = 0x3f3f3f3f;
const int mod = 10081;

int d,n,a[N],tree[N],ans,cnt;

void build(int pos,int l,int r){
	if(l == r){
		tree[pos] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(pos<<1,l,mid);
	build(pos<<1|1,mid+1,r);
	tree[pos] = min(tree[pos<<1],tree[pos<<1|1]);
}

void update(int pos,int l,int r,int val){
	if(l == r) {
		tree[pos] = val,cnt++;
		return;
	}
	int mid = (l + r) >> 1;
	if(tree[pos<<1] <= cnt) update(pos<<1,l,mid,val);
	if(tree[pos<<1|1]<=cnt) update(pos<<1|1,mid+1,r,val);
	tree[pos] = min(tree[pos<<1],tree[pos<<1|1]);
}

signed main(){
	memset(tree,INF,sizeof(tree));
	scanf("%lld%lld",&d,&n);
	for(int i = 1; i <= n; i++)
		scanf("%lld",&a[i]);
	build(1,1,n);
	int ans = 0;
	while(1){
		ans++;
		update(1,1,n,INF);
		if(tree[1] == INF) break;
		if(ans >= n+10){
			puts("-1");
			return 0;
		}
	}
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：rainygame (赞：3)

首先考虑 $O(n^2)$ 暴力。

其实就是每次暴力找第一个可以读的，然后读，读完一次就回到开头。如果某次一个都没有读就输出 `-1`。显然最多读 $n$ 天。

我们可以发现如果可以读完，那么每本书会被读恰好一次，所以能不能用什么东西让我们快点找到第一本可以读的书。（当然还要支持单点修改为 $+\infty$）

考虑分块！（我考场上认为线段树不可以，不过还好最后卡过去了）

我们可以对每个块维护一个升序数组 $b$。那么对于一次查询，我们可以先暴力枚举左边的零散块，然后在枚举整块时，如果这个块的 $b$ 的第一个数小于等于已经读过的数量，就表示这个块内一定有答案，直接暴力找并返回即可。

对于一次修改，可以直接暴力 `swap` 而不是重排，这样复杂度就不会退化成 $O(\sqrt n \log n)$。

因为这个题标解不是 $O(n \sqrt n)$ 的，所以我们考虑一些常数优化。我们设 $v_i$ 表示第 $i$ 个块的 $+\infty$ 个数，那么对于一次单点修改，它可以只移动到 $r_i-v_i+1$ 处即可。同样的，对于一次块内查询，只需要查到 $r_i-v_i$ 位置即可。

考场代码：

```cpp
#include <bits/stdc++.h>
#define MAXN 500001
#define MAXM 710

int uread(){
	int x(0);
	char ch;
	while ((ch = getchar()) < 48);
	do{
		x = (x << 1) + (x << 3) + (ch ^ 48);
	}while ((ch = getchar()) > 47);
	return x;
}

int a[MAXN], bl[MAXN];
int L[MAXM], R[MAXM], v[MAXM];

struct Node{
	int val, ind;
}b[MAXN];

void modify(const int k){
	int id(bl[k]), ind;
	for (int i(L[id]); i<=R[id]; ++i){
		if (b[i].ind == k){
			ind = i;
			break;
		}
	}
	b[ind].val = a[k] = INT_MAX;
	for (int i(ind+1); i<=R[id]-v[id]; ++i) std::swap(b[i-1], b[i]);
	++v[id];
}

int query(int id, int k){
	int ans(INT_MAX);
	for (int i(L[id]); b[i].val<=k && i<=R[id]-v[id]; ++i) ans = std::min(ans, b[i].ind);
	return ans;
}

int query(int l, int r, const int k){
	const int p(bl[l]), q(bl[r]);
	if (p == q){
		for (int i(l); i<=r; ++i){
			if (a[i] <= k) return i;
		}
		return -1;
	}
	
	for (int i(l); i<=R[p]; ++i){
		if (a[i] <= k) return i;
	}
	for (int i(p+1); i<q; ++i){
		if (b[L[i]].val <= k) return query(i, k);
	}
	for (int i(L[q]); i<=r; ++i){
		if (a[i] <= k) return i;
	}
	return -1;
}

int main(){
	freopen("book.in", "r", stdin);
	freopen("book.out", "w", stdout);
	
	uread();
	const int n(uread());
	for (int i(1); i<=n; ++i) a[i] = uread();
	for (int i(1); i<=n; ++i) b[i] = {a[i], i};
	const int len(sqrt(n)), tot((n-1)/len+1);
	for (int i(1); i<=tot; ++i){
		L[i] = R[i-1]+1;
		R[i] = L[i]+len-1;
	}
	R[tot] = n;
	for (int i(1); i<=tot; ++i){
		for (int j(L[i]); j<=R[i]; ++j) bl[j] = i;
		std::sort(b+L[i], b+R[i]+1, [](Node a, Node b){
			return a.val < b.val;
		});
	}
	
	int now(0), las, ans(0);
	while (now ^ n){
		las = now;
		int l(1), rt;
		while (~(rt = query(l, n, now))){
			modify(rt);
			++now;
			if ((l = rt+1) > n) break;
		}
		if (now == las){
			puts("-1");
			return 0;
		}
		++ans;
	}
	printf("%d", ans);
	
	return 0;
}


```

Luogu 上最慢点跑了 $542$ ms，Luogu 机子太快了。

---

## 作者：MorLeaves (赞：2)

# **题意：**

有 $n$ 个数，第 $i$ 个数是 $a_i$。最开始你取了 $0$ 个数，每一轮你需要从前往后对于每个 $a_i$，若 $a_i \le $ 你总共取的数，则你会把 $a_i$ 这个数取走，经过若干次操作后你会取完所有数或永远取不完所有数，请问总共需要多少轮操作才能取完所有数，若永远取不完则输出 $-1$。

## **思路：**

大家应该都会打 $O(n^2)$ 的暴力分，但对于 $n \le 5 \times 10^5$，显然我们要进行优化。

先回忆一下 $O(n^2)$ 的思路，其实就是每次找到 $\le cnt$ 的 $a_i$，然后接着加 $cnt$ 即可，可以发现，每次找 $a_i$ 花费了我们大量时间，每次找完也需要修改 $a_i$。

通过这些特征，我们不然而然想到一种强大的数据结构——线段树。

线段树的每个节点存储该区间的最小值。对于每轮操作，我们需要找到所有 $\le cnt$ 的 $a_i$，然后将 $a_i$ 赋值为无穷大，这样表示 $a_i$ 这个数已经被取走了，再将 $cnt$ 自增 $1$。如果所有数中的最小值是无穷大，那么说明取完了；因为每轮至少会取 $1$ 个以上的数才能保证取得完，所以如果取数的次数 $\ge n+1$，那么说明永远取不完了，输出 $-1$。

## **CODE:**

最后奉上带注释的代码。

```cpp
#include<iostream>
#include<cstdio>
const int N=500005,inf=2147483647;
using namespace std;
int rp,n,a[N],ans=0,cnt=0;//ans表示操作轮数（即答案），cnt统计当前共取了多少个数 
struct node {
	int l,r,minn;// l 和 r 表示该节点维护的区间， minn 表示该区间的最小值 
}tr[N<<2];//4倍空间线段树 
void push_up(int p) {//合并操作 
	tr[p].minn=min(tr[p<<1].minn,tr[p<<1|1].minn);
}
void build(int s,int t,int p) {//建树 
	tr[p].l=s;
	tr[p].r=t;
	if (s==t) {
		tr[p].minn=a[s];
		return ;//此时该节点为叶子节点，记得 return 
	}
	int mid=s+((t-s)>>1);
	build(s,mid,p<<1);//递归左子树 
	build(mid+1,t,p<<1|1);//递归右子树 
	push_up(p);//合并 
}
void upd(int p) {//线段树核心部分 
	if (tr[p].l==tr[p].r) {//此时为叶子节点且该节点的最小值小于等于 cnt 
		tr[p].minn=inf;//将该节点所表示的数赋值为无穷大 
		cnt++;//统计 cnt 
		return ;
	}
	if (tr[p<<1].minn<=cnt) upd(p<<1);//如果左子树中的最小值小于等于 cnt ，则往左子树寻找 
	if (tr[p<<1|1].minn<=cnt) upd(p<<1|1);//右子树同理 
	push_up(p);//合并 
}
int main() {
	scanf("%d %d",&rp,&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	build(1,n,1);//建树 
	while(1) {
		ans++;//增加轮数 
		upd(1);//寻找合适的 a[i] 
		if (tr[1].minn==inf) break;//所有数都取完了 
		if (ans>=n+1) {//轮数超过了 n+1 
			printf("-1");
			return 0;
		}
	}
	printf("%d",ans);
	return 0;//完结撒花！！！ 
}
```

---

## 作者：Little_Cart (赞：2)

感觉，这道题挺像 CF 的，至少风格很像。

但是这道题也挺像[廊桥分配](https://www.luogu.com.cn/problem/P7913)的。

### 一句话题意

有一个长度为 $n$ 的序列 $a$，每轮扫描一遍这个序列，如果 $a_i$ 还未被取出且在扫描 $a_i$ 之前已经取出的个数不小于 $a_i$，那么把他取出，问几次能把这个这个序列取完，或是无法取完。

### 思路

首先考虑什么时候合法。

可以发现如果一个数被取出，那么比他小的数一定至少取出了这个数个。

所以如果排序后，比这个数小的数个数小于这个数，那么就不合法。

那么判断合法之后呢？

我们可以进行“假取出”，也就是两次取出，第一次取出记录信息，第二次才真正取出。

考虑第一次取出记录一下 $a$ 已经被取出的数的位置以及是第几轮被取出的。

给 $a$ 排一下序，从低向高枚举。

每次枚举从记录被取出的数组里找到轮数和位置（先比较轮数再比较位置）最靠前的那个（也就是最早被取出的那个），设这个数为 $x$。

如果 $a_i$ 大于真正取出的个数，那么真正取出 $x$，再执行上述操作，直到真正取出个数为 $a_i$。

如果 $a_i$ 小于等于真正取出的个数，那么可以从这个“假取出”的数进行转移。

如果 $x$ 的位置小于 $a_i$ 的位置，那么 $a_i$ 被取出的轮数为 $x$ 被取出的轮数加 $1$，否则恰好为 $x$ 被取出的轮数，然后把 $a_i$ “假取出”，进行下一次枚举。

但是寻找 $x$ 是 $O(n)$ 的，$n$ 次就是 $O(n^2)$ 的，又该怎么优化呢？

考虑 $\text{priority\_queue}$ 维护位置最小的“假取出”的数，这样就可以实现 $O(\log n)$ 寻找，这样 $n$ 次就是 $O(n\log n)$ 的，而 $n \leq 5 \times 10^5$，显然可过。

PS：这个代码建议只用于对拍。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mp make_pair
#define PII pair<int,int>
#define PIII pair<int,PII>
#define fi first
#define se second
const int N=500024,M=1000024;
int t,n,m,tot,ans,minn,limit;
int a[N],num[N],p[N];
struct node{
	int num,wei,need;
}b[N];
bool cmp(node x,node y){
	if(x.num==y.num) return x.wei<y.wei;
	return x.num<y.num;
}
priority_queue<PIII,vector<PIII>,greater<PIII> > q;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[i].num=a[i];
		b[i].wei=i;
	}
	sort(b+1,b+1+n,cmp);
	b[0].num=-1;
	limit=n+1;
	for(int i=1;i<=n;i++){
		b[i].need=b[i].num[b].num;
		if(b[i].need>=b[i].num){
			cout<<"-1";
			return 0;
		}
		if(b[i].num==0){
			PIII cur=mp(0,mp(b[i].wei,b[i].num));
			q.push(cur);
		}
		else{
			limit=min(limit,i);
		}
	}
	int cnt=1;
	while(limit<=n){
		int i=limit;
		PIII cur=q.top();
		int num=cur.se.se;
		if(cnt<b[i].num){
			q.pop();
			cnt++;
			continue;
		}
		num=cur.fi;
		limit++;
		if(b[i].wei<cur.se.fi){
			num++;
		}
		q.push(mp(num,mp(b[i].wei,b[i].num)));
	}
	while(!q.empty()){
		ans=max(ans,q.top().fi);
		q.pop();
	}
	cout<<ans+1;
	return 0;
}
```

---

## 作者：Loser_Syx (赞：2)

定义 $cnt$ 为当前已读的章节数，$now$ 为当前读到的章节。

容易发现，这一天下一个要读的章节，一定是 $a_x \in [0,cnt]$ 且是第一个 $x > now$ 的章节。  
由于 $cnt$ 是从 $0$ 开始一点一点增长的，所以可以让 $i \in [0,cnt]$ 的 $i$，都在 $cnt=i$ 时候将 $a_x = i$ 的 $x$ 插入某个数据结构。  
因为我们需要查找第一个满足要求且 $x > now$ 的章节，本质上实在此数据结构内二分一个 $x$，使得 $x > now$，可以使用 `set`。

于是每天开始时，令 $now=1$，进行 `set` 内二分 $x$ 的操作，表示今天我要读 $x$ 号章节，故 $now \gets x$，$cnt$ 自增 $1$，此时 `set` 扩充。当某天不存在 $x>now$ 的 $x$ 即为不读了。

停止条件为 `set` 为空。

```cpp
const int N=5e5+19;
vector<int> v[N];
int main() {
	read();
	int n=read();
	for (int i=1,x;i<=n;++i) {
		read(x);
		v[x].emplace_back(i);
	}
	int cnt=0,ans=0;
	set<int> s;
	for (int i:v[0]) s.insert(i);
	set<int>::iterator x;
	while (!s.empty()) {
		++ans; int now=1;
		while ((x = s.lower_bound(now)) != s.end()) {
			now = *x;
			s.erase(now);
			for (int i:v[++cnt]) s.insert(i);
		}
	}
	write(cnt^n?-1:ans,'\n');
	return 0;
}
```

---

## 作者：0_lan_0 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P10077)
# 题目大意  
一本有 $n$ 个章节的书，每天遍历 $1 \ldots n$ 个章节，每个章节有一个限制 $a_i$，要读完 $i$ 个章节才能读该章节，问：最少多少天才读完这本书？
# 思路
可用 $n$ 个 vector 来储存读了 $i$ 个章节后能读的章节，用 $now$ 代表现在读到的章节，每次把 $> now$ 的章节放在一个 set 里，把 $< now$ 的章节放在另一个 set 里，并取出第一个 set 里的数。当第一个 set 没有数时，代表要重新从第 $1$ 章开始读。当两个 set 都为空且还有未读完的章节，说明这本书读不完，输出 $-1$。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5;
int n,a[N],day,book,now,xnum,ynum;
vector<int>s[N];
set<int>x,y;
signed main(){
    scanf("%lld%lld",&n,&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        s[a[i]].push_back(i);
    }
    ++day;
    for(int i=1;;i++){
        for(int j=0;j<s[book].size();j++){
            if(s[book][j]>now) x.insert(s[book][j]),xnum++;//后面
            else y.insert(s[book][j]),ynum++;//前面
        }
        s[book].clear();
        if(xnum==0){
            ++day;
            now=1;
            if(ynum==0&&book!=n){
                printf("-1");return 0;
            }
            swap(xnum,ynum);
            swap(x,y);
        }
        else{
            now=*x.begin();
            x.erase(*x.begin());
            --xnum;
            ++book;
        }   
        if(book==n) break;
    }
    printf("%lld",day);
    return 0;
}
```


---

## 作者：wcy110614 (赞：1)

> 模拟赛 $B$ 题，赛时想的主席树优化二分，赛后发现复杂度会炸掉，而且代码极其难写，于是学长讲题的时候突然领悟了更简单的线段树做法。

一开始，考虑用线段树去掉最小数，直到没有小于 $0$ 的数。

在删除一个数的时候，把那个数改成 $+\infty$，避免重复选。然后后面的数集体 $-1$。既然你有了一个新的书，那么其他书所要的书的数量 $a_i$ 就会减少一。也就是序列后面的每个 $a_i:=a_i-1$。为了让线段树不会回头选，注意到之前的书的 $a_i\ge0$，所以直接不管就好了。

这样删书的顺序并不会影响最后能够取到的值。

而在第二轮的时候，所有书都会 $a_i:=a_i-cnt$。$cnt$ 是你前面的所有轮中取到的书的数量。

而原本就被减小的数还原回来，在第二轮的时候，还原线段树。

全局 $a_i:=a_i-cnt$ 就好了。

用栈记录每轮修改的数。

清栈显然是 $\mathcal{O(1)}$ 的。

这样一来，线段树需要记录：最小值 $\min$，最小值位置 $\text{pos}$，维护区间减法和全局查询。

由于每个数至多删去一次，$\mathcal{O(n)}$，线段树复杂度 $\mathcal{O(\log_2n)}$，总共复杂度 $\mathcal{O(n)O(\log_2n)}=\mathcal{O(n\log_2n)}$，足以通过本题。

不难注意到，如果已经操作到了 $n+1$ 轮，那一辈子都不可能选完了，输出 `-1`。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ls (u<<1)
#define rs (u<<1|1)
#define lson ls,l,mid
#define rson rs,mid+1,r
#define mid ((l+r)>>1)
#define file "book"
using namespace std;
const int N=5e5+10,inf=0x3f3f3f3f;
int n,d,cnt,a[N],st[N];
struct sgt{
	int mn[N],ps[N],tg[N];
	inline void pu(int u){if(mn[ls]>mn[rs])mn[u]=mn[rs],ps[u]=ps[rs];else mn[u]=mn[ls],ps[u]=ps[ls];}
	inline void p(int u,int x){mn[u]+=x,tg[u]+=x;}
	inline void pd(int u){if(tg[u])p(ls,tg[u]),p(rs,tg[u]),tg[u]=0;}
	inline void upd(int u,int l,int r,int L,int R,int k){
		if(R<L)return;
		if(L<=l&&r<=R)return p(u,k);pd(u);
		if(L<=mid)upd(lson,L,R,k);
		if(R> mid)upd(rson,L,R,k);pu(u);
	}
	inline void bd(int u,int l,int r){
		if(l==r)return ps[u]=l,mn[u]=a[l],void();
		bd(lson),bd(rson),pu(u);
	}
}t;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>d>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	t.bd(1,1,n);
	for(int i=1;i<=n+1;++i){
		int top=0;
		if(i==n+1)return cout<<-1<<"\n",0;
		for(;t.mn[1]<=0;){
			int p=t.ps[1];
			t.upd(1,1,n,p+1,n,-1),t.upd(1,1,n,p,p,inf),st[++top]=p,++cnt;
		}
		if(cnt==n)return cout<<i<<"\n",0;
		for(int j=1;j<=top;++j)t.upd(1,1,n,st[j]+1,n,1);
		t.upd(1,1,n,1,n,-top);
	}
	return 0;
}
```

---

## 作者：P_VICVIC_R (赞：1)

~~题面不解释，看别人的，我懒~~

下文中变量解释：

- $A$：输入的序列
- $A_i$：序列的第 $i$ 个元素
- $n$：序列长度
- $cnt$：已经看过的数量

---

### 思路：

先想一下暴力，只要 $A$ 不空，就一直从左往右扫，如果 $A_i\le cnt$ 就加 $cnt$，删掉 $A_i$，每过一轮答案加一。

复杂度不难想是 $O(n^2)$，那么我们考虑降低复杂度到 $O(n\log n)$ 或 $O(n\sqrt n)$。

~~毕竟暴力都有了，那么分块就顺理成章了。~~

我们先想一下为啥暴力会 $O(n^2)$，举个例子：

```
5
4 3 2 1 0
```

那么每跑一次是 $O(n)$，每次只删掉一个数，共计跑 $n$ 次，复杂度就上去了。

我们分块维护块内最小值（第 $i$ 块的块内最小值记为：$Min_i$）并且：

- 如果 $Min_i>cnt$，就直接下一块；
- 如果 $Min_i\le cnt$，就再跑一下这个块，更新 $Min_i$ 和 $cnt$；

那么分块后我们每次跑的复杂度只有 $O(\sqrt n)$，跑块内也是 $O(\sqrt n)$，不难发现我们跑的次数越多，每次会被更新的块就越少，反之跑的次数越少，每次会被更新的块就越多，均摊下来就算每次只删掉一个数，也就跑 $n$ 次，时间复杂度为 $O(n\sqrt n)$。

### 注意：

1. 卡常。
2. 当一个块里已经全部删完时，直接把该块从块的列表里删掉（删除别用 $\texttt{erase}$，这玩意 $O(n)$)

[代码](https://www.luogu.com.cn/record/161836039)加了一堆快读快写，就不放这里了，可以参考@This_Rrhar 的题解，写的很好。

---

## 作者：yanqijin (赞：1)

# 题目大意
有一个长度为 $n$ 的序列 _A_ ，每轮可以从序列中取出 $a_i$（$a_i$ 小于已经取出来的数的个数，且未被取出过），问可以取几轮？
# 思路
首先可以很容易的想到 $O(n^2)$ 的暴力模拟。$O(n)$ 查找并修改，循环 $n$ 轮。

那么我们可以尝试优化一下暴力模拟，尝试将查找并修改这个操作优化到 $O(\log n)$ 级别。

再观察一下，我们可以发现，每次找全局最小值并修改为 $\operatorname{INF}$ 就行了。那么我们可以想到一种数据结构——**线段树**。

**我们可以每次用线段树维护整个序列，记录一下已经取了的个数和取的轮数，每次取完后就把 $a_i$ 的数值修改为 $\operatorname{INF}$ 。**

那么，怎么退出呢？

**当最小值为 $\operatorname{INF}$ 时，退出并输出答案。**

**或者当轮数超过 $n$ 时，输出 $-1$。(因为如果有解，每轮至少取出一个数）**

由于查询并修改的操作是 $O(\log n)$ ，且循环 $n$ 轮。所以总时间复杂度为 $O(n \log n)$。
# $Code$
```cpp
#include<cstdio>
#define INF 1e8
using namespace std;
long long id, n, a[500005], d[2000005], sum = 0, ans = 0;
//线段树数组记得开4倍
long long min(long long a, long long b) {
	return a < b ? a : b;
}//手写比较大小函数
void build(long long l, long long r, long long o) {//建树
	if (l == r) {
		d[o] = a[l];
		return ;
	}
	long long mid = l + ((r - l) >> 1);
	build(l, mid, o * 2);
	build(mid + 1, r, o * 2 + 1);
	d[o] = min(d[o * 2], d[o * 2 + 1]);
	return ;
}
void update(long long l, long long r, long o) {//查询并修改
	if (l == r) {
		d[o] = INF;
		sum++;
		return ;
	}
	long long mid = l + ((r - l) >> 1);
	if (d[o * 2] <= sum) update(l, mid, o * 2);
	if (d[o * 2 + 1] <= sum) update(mid + 1, r, o * 2 + 1);
	d[o] = min(d[o * 2], d[o * 2 + 1]);
	return ;
}
int main() {
	scanf("%lld%lld", &id, &n);
	for (int i = 1; i <= n; i++) {//读入
		scanf("%lld", &a[i]);
	}
	build(1, n, 1);
	while (1) {
		ans++;
		update(1, n, 1);
		if (d[1] == INF) break;//判断是否取完
		if (ans > n) {//判断轮数是否超过n
			printf("-1");
			return 0;
		}
	}
	printf("%lld", ans);//输出
	return 0;
}
```

---

## 作者：Dream__Sky (赞：1)

记当前读书数量为 $cnt$，读到第 $i$ 本书。

根据题意得，我们下一次读的书需要满足，书的编号 $j\in[i+1,n]$ 且 $a_j\leq cnt$。根据贪心，我们还要使 $j$ 最小。

可以想到用线段树来维护。

我们先查询这本书，接着把这本书删去，相当于赋上一个很大的数。如果查询不到书，那么说明又要从头开始。

重复上述操作，如果在某一天一开始就找不到书，如果 $cnt=n$ 那么说明读完了，否则无解。


------------

查询操作实现：

我们用线段树维护最小值，从区间 $[i+1,n]$ 往下递归，优先左子树，再右子树，因为我们需要让 $j$ 更小。每次递归时，如果这个区间的最小值小于 $cnt$，那么说明这个区间一定存在可读的书，继续往下递归，直到到叶子节点。


------------
更改（删除）操作实现：

每次单点修改查询找到的那本书，把它赋值为极大值，别忘了上传最小值。


------------
代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int a[N],n,res;
struct info{int sum,minn;}t[N<<2];
void build(int p,int l,int r)
{
	if(l==r)
	{
		t[p].sum=t[p].minn=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	t[p].minn=min(t[p*2].minn,t[p*2+1].minn);
}
void change(int p,int l,int r,int k)
{
	if(l==r&&r==k) 
	{
		t[p].minn=2e9;
		return ;
	}
	int mid=(l+r)>>1;
	if(k<=mid) change(p*2,l,mid,k);
	if(k>mid) change(p*2+1,mid+1,r,k);
	t[p].minn=min(t[p*2].minn,t[p*2+1].minn);
}
void find(int p,int L,int R,int l,int r,int cnt)
{
	if(p==1) res=0;
	if(res) return ;
	if(t[p].minn>cnt) return ;
	if(l<r)
	{
		int mid=(l+r)>>1;
		if(L<=mid) find(p*2,L,R,l,mid,cnt);
		if(R>mid) find(p*2+1,L,R,mid+1,r,cnt);
	}
	else res=l;
}
int main()
{
	cin>>n>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	build(1,1,n);
	int ans=0,sum=0;
	while(1)
	{
		ans++;
		for(int pos=1;pos<=n;pos++)
		{
			find(1,pos,n,1,n,sum);
			if(pos==1&&res==0)
			{
				if(sum==n) cout<<ans-1,exit(0);
				else cout<<-1,exit(0);
			}
			if(res==0) break;
			change(1,1,n,res);
			sum++;
			pos=res;
		}
	}
	return 0;
}

```




---

## 作者：ty_xyz (赞：1)

## 40 分做法

直接暴力即可，每次扫一遍，读可以读的书。

有解的情况下最坏每次读一本书（数据如 `4 3 2 1 0`），因此时间复杂度为 $\Theta(n^2)$。

## 100 分做法

考虑转化题目。假设当前正在检查第 $now$ 本书是否可读，设当前已读了 $cnt$ 本书，则这一次读的书 $pos$ 必然满足 $pos\le i$ 且 $a_{pos}\le cnt$，在此条件下 $pos$ 取最小。

注意到可以以 $cnt$ 作为划分状态的关键。令初始时 $now=1$。我们将所有 $a_i\le cnt\forall1\le i\le n$ 且没有被放入过的 $i$ 放入从小到大排序的 `set` 中，那么这一次读的书必然是 `set` 中满足 $i\le pos$ 的 $\min(pos)$（可以用 `lower_bound` 实现）。读了这本书之后令 $cnt=cnt+1$，$now=pos+1$，将 $pos$ 从 `set` 中移除，并放入 $a_i$。当 $now>n$ 时，令 $now=1$，且将答案 $+1$ 即可。当 $cnt=n$ 时结束操作并输出答案，或如果找不到 $pos\le n$ 则报告无解。

因为每个数只会被加入一次，所以时间复杂度是 $\mathcal{O}(n\log_2n)$。赛时打了 $2.5h$ 的 $\mathcal{O}(n\log_2^2n)$，结果被 `set` 的巨大常数卡到 40。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int d,n,cnt,now=1,ans,las,pos;
set<int>s;
vector<int>g[500001];
int main()
{
	scanf("%d%d",&d,&n);
	for(int i=1,x;i<=n;i++)
	{
		scanf("%d",&x);
		g[x].push_back(i);
	}
	while(cnt<n)
	{
		++ans;
		for(las;las<=cnt;las++)for(int i=0;i<g[las].size();i++)s.insert(g[las][i]);
		auto it=s.lower_bound(now);
		if(it==s.end())//找不到
		{
			if(now==1)//整个 set 里都没有可以读的
			{
				printf("-1\n");
				return 0;
			}
			now=1;
			continue;
		}
		pos=*it;
		s.erase(pos);
		++cnt;
		--ans;//开头加上了这里减回去
		now=pos+1;
	}
	printf("%d\n",ans+1);//最后减了一次加回来
	return 0;
}
```

---

## 作者：251Sec (赞：1)

想了半天这题有啥高妙性质，然后完全没头绪，最后注意到这是道绿题，所以直接按照题意模拟就做完了。/cf

---

考虑直接按照题意模拟，则我们需要快速找到每次读一本书之后下一本被读的书的位置。直接用一个 set 存下来当前所有可以被读的书的下标，查询直接在上面二分就行了。对 set 的修改在于每次读完一本书之后这本书就不能再读了所以要在 set 里删掉，并且读完的书本数增加的时候要将新的可以读的书加进 set 里。这里的实现可以用 $n$ 个 vector 存下来每个 $a$ 值对应的所有下标。另外超过 $n$ 天没有读完所有的书就是无解。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, c, ans, a[500005];
vector<int> p[500005];
set<int> f;
int main() {
	scanf("%*d%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", a + i);
		p[a[i]].emplace_back(i);
	}
	for (int i : p[0]) f.insert(i);
	while (ans <= n && c < n) {
		int i = 0;
		while (true) {
			auto it = f.upper_bound(i);
			if (it == f.end()) break;
			c++, i = *it;
			f.erase(it);
			for (int j : p[c]) f.insert(j);
		}
		ans++;
	}
	printf("%d\n", ans > n ? -1 : ans);
	return 0;
}
```

---

## 作者：潘德理2010 (赞：1)

假设现在你已经读完了 $c$ 本书，今天之内刚刚读完的书位置为 $p$。如果今天还没读过就令 $p=0$。

那么下一本要读的书就是区间 $[p+1,n]$ 内最左边的小于等于 $c$ 的那一本。

我们找到这本书的位置，删去这本书（相当于把这本书的值设为无穷大），并令 $c$ 自加 $1$。如果找不到，说明这一天已经没法继续读了，开始下一天。

重复上述操作，直到在某一天开始时发现找不到书为止（注意这一天并不能算进答案），此时 $[1,n]$ 内都没有可读的书。如果读完了 $n$ 本书就输出天数，没读完就输出 $-1$。

我们考虑快速定位下一本能读的书。

考虑使用能维护以下操作的数据结构：

1.单点修改。

2.查询一个区间内最左边的小于等于 $x$ 的数的下标。

发现线段树可以维护这些操作。维护方式如下：

在线段树上的每个点存储其对应区间的最小值，修改时直接修改即可，查询时先查左子树，再查右子树。当发现当前区间已经无法满足答案，或是已经找到答案，就退出当前查询。因为每次都是先查左子树，所以找到的答案一定是最左边的。

时间复杂度 $O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[500050],c,ans;
int s[2000020];
void push_up(int x){
	s[x]=min(s[2*x],s[2*x+1]);
}
void init(int x,int le,int ri){// 初始化 
	if(le<ri){
		int mid=(le+ri)/2;
		init(2*x,le,mid);
		init(2*x+1,mid+1,ri);
		push_up(x);
	}
	else s[x]=a[le];
}
void upd(int x,int p,int le,int ri){// 将第 p 位设为无穷大 
	if(le<ri){
		int mid=(le+ri)/2;
		if(p<=mid) upd(2*x,p,le,mid);
		if(p>mid) upd(2*x+1,p,mid+1,ri);
		push_up(x);
	}
	else s[x]=1<<30;
}
int res;
void fd(int x,int v,int a,int b,int le,int ri){
	// 查询 a 到 b 中最靠左的小于等于 v 的数的下标，将答案存入 res 中 
	if(x==1) res=0;
	if(res) return ;
	if(s[x]>v) return ;
	if(le<ri){
		int mid=(le+ri)/2;
		if(a<=mid) fd(2*x,v,a,b,le,mid);
		if(b>mid) fd(2*x+1,v,a,b,mid+1,ri);
	}
	else{
		res=le;
	}
}
int main(){
	scanf("%d%d",&n,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	init(1,1,n);
	while(1){
		ans++;
		for(int i=1;i<=n;){
			fd(1,c,i,n,1,n);// 找下一本能读的书 
			if(i==1&&res==0){// 没有任何书可以读了 
				if(c==n){
					printf("%d",ans-1);
					// 这里要减 1，因为这个循环会多执行一次，最后一次没有读书 
				}
				else printf("-1");
				return 0;
			}
			if(res==0) break;// 读完了一天 
			upd(1,res,1,n);// 拿走这本书 
			c++;
			i=res;
		}
	}
}
```


---

## 作者：strcmp (赞：1)

**题目大意：**

每天会进行从 $1\dots n$ 的遍历，初始令 $w = 0$。

若 $w \ge a_i$，则 $w \leftarrow w + 1,\,a_i \leftarrow +\infty$。

否则若 $w < a_i$ 则跳过。

求最少花多少天能使得所有 $a_i$ 变为 $+\infty$。

------------

只想了 15min，这题其实并不需要什么高级数据结构。

每次我们是要找到当前数之后第一个 $\le w$ 的数，并跳到那个数上，把那个数变为 $+\infty$ 并使得 $w \leftarrow w + 1$。

先维护所有 $\le w$ 的数的下标 $s$。

如果初始 $s$ 为空显然无解，否则设当前位置是 $x$，则到达 $x$ 在 $s$ 的后继 $y$。

然后使得 $w \leftarrow w + 1$，把这个位置 $y$ 给删掉，暴力把数值是 $w + 1$ 的下标给加入到 $s$ 中。

每个东西都可以用个 `set` 简单维护，然后就做完了。

被卡常了可以换权值树状数组，但其实只要实现正常完全没有必要。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long int ll;
using pll = pair<ll, ll>;
const int maxn = 5e5 + 10;
const ll inf = 1145141919810LL;
using iter = set<int>::iterator;
set<int>s[maxn], t; int n, d, w = 0, a[maxn];
int main() {
    scanf("%d%d", &d, &n); 
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        s[a[i]].insert(i);
        if (a[i] == 0) t.insert(i);
    }
    if (t.empty()) puts("-1"), exit(0);
    int x = *t.begin() - 1, u = 0; s[0].clear();
    while (w < n) {
        if (t.empty()) puts("-1"), exit(0);
        iter now = t.upper_bound(x);
        if (now != t.end()) x = *now;
        else x = *t.begin(), ++u;
        ++w; t.erase(x);
        iter it = s[w].begin();
        while (it != s[w].end()) t.insert(*it), ++it;
        s[w].clear();
    }
    printf("%d\n", u + 1);
    return 0;
}

```

---

## 作者：coding_goat (赞：0)

前置知识：线段树。

我们用线段树维护区间最小值，每一天的读书等同于在线段树上找到节点大小小于等于已经读过的书的节点。

具体实现则是节点使用后将其变为无限大，每次查询记得 `push_up`。

至于判断无解，因为读 $n$ 本书的最坏情况的序列是 $n-1,n-2,\cdots,2,1,0$，每天只能读 $1$ 本书，用时 $n-1$ 天，因此当天数超过 $n-1$ 天时，即是无解的情况。

代码见下：

```cpp
/*
返せ！返せ！ボクの家族を
悪の手から未来の欠片を取返す
ボクの使命だ　この身の全てが滅びようとも
返せ！返せ！ボクの家族を
0419　必ず見
また幸せな温もりをこの鉄の肌で感じたい
*/
#include<bits/stdc++.h>
#define ll long long
#define mem(a,b) memset((a),(b),sizeof(a))
#define lb(x) ((x)&-(x))
#define lc(x) ((x)<<1)
#define rc(x) (((x)<<1)|1)
#define pb(G,x) (G).push_back((x))
using namespace std;
inline int read()
{
	int xx=0;int f=1;
	char c = getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f = -1;
		c = getchar();
	}
	while(c>='0'&&c<='9')
	{
		xx = (xx<<1)+(xx<<3)+(c^48);
		c = getchar();
	}
	return xx*f;
}
#define maxn 500050

int d,n,a[maxn];

int tree[maxn<<2];

int cnt,ans;

void build(int l,int r,int idx)
{
	if(l==r)
	{
		tree[idx]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,lc(idx));
	build(mid+1,r,rc(idx));
	tree[idx]=min(tree[lc(idx)],tree[rc(idx)]);
}

void query(int l,int r,int idx)
{
	if(l==r)
	{
		if(tree[idx]<=cnt)
		{
			tree[idx]=1e9;
			cnt++;
		}
		return ;
	}
	int mid=(l+r)>>1;
	if(tree[lc(idx)]<=cnt) query(l,mid,lc(idx));
	if(tree[rc(idx)]<=cnt) query(mid+1,r,rc(idx));
	tree[idx]=min(tree[lc(idx)],tree[rc(idx)]);
}

signed main()
{
	d=read(),n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	build(1,n,1);
	while(1)
	{
		ans++;
		query(1,n,1);
		if(cnt==n) break;
		if(ans>n)
		{
			return cout<<-1,0;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_Yonder_ (赞：0)

当时比赛线段树写挂了（悲），所以现在写这题我用的 ```set```。

很明显，我们需要一个可以快速查找大于某个数的下标且小于等于 Zayin 当前智慧的数的数据结构。考虑用 ```vector``` 储存不同的 $a_i$，每当智慧增加了一，就将全部等于当前智慧的 $a_i$ 的 $i$ 加入 ```set```，然后二分查找下一个元素就好了。

# Code
```cpp
#include<bits/stdc++.h>
#define S std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define per(i,l,r) for(int i=l;i>=r;i--)
#define ll long long
using namespace std;
template<typename P>inline void read(P&x){bool f=0;x=0;char c=getchar();while(!isdigit(c)) f|=c=='-',c=getchar();while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();x=f?~(x-1):x;}
template<typename P>inline void write(P x){if(x<0) putchar('-'),x=-x;if(x>9) write(x/10);putchar((x%10)^48);}
const int N=5e5+5;
int d,n,a[N],t;
vector<int> v[N];
set<int> s;
int main(){
    S;cin>>d>>n;s.insert(N);
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]) v[a[i]].push_back(i);
        else s.insert(i);
    }for(int i=1;i<=n;i++){
        auto it=s.begin();
        while(*it!=N){
            t++;int now=*it;
            for(int k:v[t]) s.insert(k);
            s.erase(it);
            it=s.upper_bound(now);
        }if(t==n) cout<<i,exit(0);
    }cout<<-1;
	return 0;
}
```

---


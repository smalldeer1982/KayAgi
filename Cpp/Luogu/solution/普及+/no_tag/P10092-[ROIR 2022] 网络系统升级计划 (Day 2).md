# [ROIR 2022] 网络系统升级计划 (Day 2)

## 题目背景

翻译自 [ROIR 2022 D2T3](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day2.pdf)。

某国有 $n$ 个城市，从 $1$ 到 $n$ 编号，首都编号为 $1$。

这个国家的计算机网络构建如下：每个城市都有一个连接中心，可以通过有线通信渠道与其他一些中心相连。对于任意两个城市之间存在着一条唯一的通信路径，换句话说，该网络形成一棵树。对于城市 $i(i > 1)$，我们把从城市 $i$ 到首都的路径上第一个城市记为 $p_i$。

计划对网络进行升级，用更先进的光学通信渠道替换一些现有有线渠道。光学通信渠道只能在现有有线通信渠道的位置上铺设。替换连接城市 $i$ 和 $p_i$ 的通信渠道的成本为 $w_i$。由于技术限制，任何连接中心最多可以直接连接到 $k$ 个其它中心。

## 题目描述

通信部希望制定一个升级计划，以提高光学通信渠道的其连通性。因此，需要选择尽可能多的通信渠道进行升级。但是，希望在相同数量的情况下尽量减少升级成本，因此，在相同数量的情况下，选择升级具有最小总成本的通信渠道。

帮助通信部专家选择要升级的通信渠道。

## 说明/提示

样例 $1$ 中的网络配置在升级前后如下图所示。需要升级的通信渠道以粗线表示。可以升级的最大通信渠道数量为 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wd46yiot.png)

样例 $2$ 中的网络配置在升级前后如下图所示。需要升级的通信渠道以粗线表示。可以升级的最大通信渠道数量为 $6$。升级通道的成本显示在边（通信渠道）的旁边，最优解决方案中升级通道的总成本为 $27$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z2mnb3ul.png)

本题原题分为 $13$ 个 Subtask，但是洛谷不支持设置 $10$ 个以上的 Subtask。本题原题分为 $321$ 个测试点，但是洛谷不支持设置 $100$ 个以上的测试点。所以本题只保留后 $100$ 个测试点，且不使用捆绑测试。

所有数据均满足 $2 \le n \le 10^5, 1 \le k \le 100$。

## 样例 #1

### 输入

```
8 2
1 0
1 0
1 0
2 0
2 0
2 0
1 0```

### 输出

```
4 0```

## 样例 #2

### 输入

```
8 3
1 5
1 2
1 4
2 6
2 7
2 2
1 6```

### 输出

```
6 27```

# 题解

## 作者：Nygglatho (赞：1)

这和[吉林 CPC ](https://codeforces.com/gym/105170/)的[ B 题](https://codeforces.com/gym/105170/problem/B)类似，考虑树形 DP。

令：

- $\mathit{dp}_{x,0}$ 表示节点 $x$ 选最多 $k$ 条边，以其为根的子树选择的边数最大值，$\mathit{val}_{x,0}$ 表示在 $\mathit{dp}_{x,0}$ 最大情况需要的最小成本。
- $\mathit{dp}_{x,1}$ 和 $\mathit{dp}_{x,0}$ 其他一样，但是只能选择最多 $k-1$ 条边，$\mathit{val}_{x,1}$ 表示在 $\mathit{dp}_{x,1}$ 最大情况需要的最小成本。

考虑当前节点 $\mathit{now}$ 选择连向其儿子的边，如果选择了 $(\mathit{now},v)$ 这条边，则 $v$ 对 $\mathit{dp}_\mathit{now}$ 的贡献为 $dp_{v,1}+1$。因为 $v$ 连向其父亲节点也算作一条边。同样，$v$ 对 $\mathit{val}_{\mathit{now}}$ 的贡献为 $\mathit{val}_{v,1}+d$，其中 $d$ 是该边的边权。而如果不选择这条边，则对 $\mathit{dp}_{\mathit{now}}$ 的贡献为 $dp_{v,0}$，对 $\mathit{val}_{\mathit{now}}$ 的贡献为 $\mathit{val}_{v,0}$。

显然你肯定要选择 $\mathit{dp}_{v,1}+1-\mathit{dp}_{v,0}$ 尽量大的，如果相同就选择 $\mathit{val}_{v,1}+d-\mathit{val}_{v,0}$（$d$ 为边权）尽量小的。这样可以保证答案尽量大。按照这种方式进行排序，然后直接选择即可。

```cpp
int n, k;
ll val[310000][2], dp[310000][2];
ll a[310000];
vector <pii> v[310000];
vector <pii> _v;

void dfs (int now) {
    ll s0 = 0ll, s1 = 0ll;
    ll vl0 = 0ll, vl1 = 0ll;
    ll mx = 0ll, mn = 0ll;
    _v.clear();
    for (auto [i, j] : v[now]) dfs (i);
    for (auto [i, j] : v[now]) _v.push_back({i, j}), vl0 += val[i][0], s0 += dp[i][0];
    sort (_v.begin(), _v.end(), [] (pii X, pii Y) {
        auto [x, _] = X; auto [y, __] = Y;
        if (dp[x][1] - dp[x][0] == dp[y][1] - dp[y][0]) return (_ + val[x][1] - val[x][0] < __ + val[y][1] - val[y][0]);
        return (dp[x][1] - dp[x][0] > dp[y][1] - dp[y][0]);
    });
    mx = s0, mn = vl0;
    dp[now][0] = dp[now][1] = mx;
    val[now][0] = val[now][1] = mn;
    int cnt = 0;
    for (auto [i, j] : _v) {
        ++ cnt;
        s0 -= dp[i][0], s1 += dp[i][1] + 1;
        vl0 -= val[i][0], vl1 += val[i][1] + j;
        mx = s0 + s1, mn = vl0 + vl1;
        if (cnt <= k) {
            if (mx > dp[now][0]) {
                dp[now][0] = mx; val[now][0] = mn;
            } else if (mx == dp[now][0] && mn < val[now][0]) {
                val[now][0] = mn;
            }
        }

        if (cnt <= k - 1) {
            if (mx > dp[now][1]) {
                dp[now][1] = mx; val[now][1] = mn;
            } else if (mx == dp[now][1] && mn < val[now][1]) {
                val[now][1] = mn;
            }
        }
    }
    _v.clear();
}

int main() {
    cin >> n >> k;
    F (i, 2, n) {
        int p;
        cin >> p >> a[i];
        v[p].push_back({i, a[i]});
    }
    dfs (1);
    cout << dp[1][0] << ' ' << val[1][0] << '\n';
}
```

---

## 作者：To_our_starry_sea (赞：1)

### Solution

不懂题解为啥都是 $O(nk)$ 的，实际上本题 $k$ 可以没有 $k \le 100$ 的限制。

设 $dp_{u, i}$ 表示节点 $u$ 与其子结点连了 $i$ 条边，所能连的最多边数，而 $dp'_{u, i}$ 为其对应的最小代价，转移是容易的，时间复杂度 $O(nk)$。

考虑到对于每一个点都维护 $dp_{u, 0}$ 到 $dp_{u, k}$ 是不必要的，因为每个点子结点数量之和是 $O(n)$，因此我们维护的上界为 $\min(k, son_u)$，其中 $son_u$ 表示 $u$ 的子结点个数。

我们发现，对于子结点个数不小于 $k$ 的节点，其真正有贡献的只有 $dp_{v, k - 1}$ 和 $dp_{v, k}$，不妨设其为 $dp_{v, 0}$ 与 $dp_{v, 1}$。初始时，我们先强制选 $dp_{v, 1}$，则 $u$ 与 $v$ 之间不能连边。我们发现，若一个节点从选 $dp_{v, 1}$ 变为选 $dp_{v, 0}$，则其边数变化值为 $dp_{v, 0} + 1 - dp_{v, 0}$，代价变化值为 $dp'_{v, 0} + val(u, v) - dp'_{v, 1}$。显然我们可以以前一个值为第一关键字，后一个值为第二关键字将所有 $dp_{v, 0}$ 和 $dp'_{v, 0}$ 排序，然后贪心地转移。

考虑对于这样的过程，每一对父子节点只会被计算一次贡献，而 $\sum son_u$ 显然是 $O(n)$ 的，故空间复杂度是 $O(n)$ 的，而时间复杂度是 $O(n \log n)$ 的，瓶颈在排序。

实现时需要一定的细节，具体参考代码。

所以 $k$ 为什么这么小啊？$k$ 和 $n$ 完全可以同阶的啊。

### Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define fi first
#define se second
const int MAXN = 100005;
const int MAXK = 105;
const ll INF = 1e18;
int n, k, cnt = 0, head[MAXN];
struct edge {
	int to, next, w;
} e[MAXN << 1];
pair<int, ll> now[MAXN][2]; //0:u has no more than k - 1 edges with son
inline bool comp(pair<int, ll> x, pair<int, ll> y) {
	if (x.fi != y.fi) return x.fi > y.fi;
	else return x.se < y.se;
}
inline void add(int u, int v, int w) {
	cnt++;
	e[cnt].to = v;
	e[cnt].w = w;
	e[cnt].next = head[u];
	head[u] = cnt;
}
inline void dfs(int u, int pre) {
	vector<pair<int, ll> > dp, nxt;
	int sum = 0;
	pair<int, ll> res = make_pair(0, 0);
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if (v == pre) continue;
		dfs(v, u);
		sum++;
		res.fi += now[v][1].fi, res.se += now[v][1].se;
		nxt.push_back(make_pair(now[v][0].fi + 1 - now[v][1].fi, now[v][0].se + e[i].w - now[v][1].se));
	}
	sort(nxt.begin(), nxt.end(), comp);
	dp.resize(min(k + 1, sum + 1));
	dp[0] = res;
	for (int i = 1; i <= min(k, sum); i++) dp[i] = make_pair(dp[i - 1].fi + nxt[i - 1].fi, dp[i - 1].se + nxt[i - 1].se);
	pair<int, ll> ans = dp[0];
	for (int i = 1; i <= min(k - 1, sum); i++) {
		if (ans.fi < dp[i].fi) ans = dp[i];
		else if (ans.fi == dp[i].fi && ans.se > dp[i].se) ans = dp[i];
	}
	now[u][0] = ans;
	if (k <= sum) {
		if (ans.fi < dp[k].fi) ans = dp[k];
		else if (ans.fi == dp[k].fi && ans.se > dp[k].se) ans = dp[k];
	}
	now[u][1] = ans;
	vector<pair<int, ll> > ().swap(dp);
	vector<pair<int, ll> > ().swap(nxt);
}
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-')
		   f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}
int main() {
	//freopen("unyielding.in", "r", stdin);
	//freopen("unyielding.out", "w", stdout);
	n = read(), k = read();
	for (int i = 2; i <= n; i++) {
		int fa = read(), w = read();
		add(fa, i, w), add(i, fa, w);
	}
	dfs(1, 0);
	printf("%d %lld\n", now[1][1].fi, now[1][1].se);
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

模拟赛原题。

$f_{x,i}$ 表示点 $x$ 为根，连了 $i$ 条边的最值（这里最值可以看成一个 pair）。可能有点卡空间。

发现只需要知道 $g_{x,0/1}$ 表示 $x$ 是/否和父亲连边子树内（及与父亲的边）的价值。把可能和父亲连边的作差排序贪心选取较小的改变量即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define fi first
#define se second
using namespace std;
bool f1;
const int N = 1e5 + 5;
int n, k, fa[N], w[N];
pii g[N][2], ans;
vector<int> G[N];
vector<pii> vec[N];
bool f2;
inline pii operator + (pii x, pii y){
    return {x.fi + y.fi, x.se + y.se};
}
inline pii operator - (pii x, pii y){
    return {x.fi - y.fi, x.se - y.se};
}
inline pii max(pii x, pii y){
    if(x.fi > y.fi) return x;
    if(x.fi < y.fi) return y;
    return x.se < y.se ? x : y;
}
inline bool operator < (pii x, pii y){
    if(x.fi ^ y.fi) return x.fi < y.fi;
    return x.se > y.se;
}
inline void dfs(int x){
    int sz = 0;
    for(int y : G[x]){
        dfs(y);
        if(g[y][1] < g[y][0]){
            g[x][0] = g[x][0] + g[y][0];
            g[x][1] = g[x][1] + g[y][0];
        }
        else{
            sz++;
            g[x][0] = g[x][0] + g[y][1];
            g[x][1] = g[x][1] + g[y][1];
            vec[x].push_back(g[y][1] - g[y][0]);
        }
    }
    sort(vec[x].begin(), vec[x].end(), [&](pii x, pii y){
        return y < x;
    });
    while(sz >= k){
        if(sz > k) g[x][0] = g[x][0] - vec[x].back();
        g[x][1] = g[x][1] - vec[x].back();
        vec[x].pop_back();
        sz--;
    }
    pii tmp = {1, w[x]};
    g[x][1] = g[x][1] + tmp;
    // printf("%lld {%lld, %lld}, {%lld, %lld}\n", 
    // x, g[x][0].fi, g[x][0].se, g[x][1].fi, g[x][1].se);
}
signed main(){
    // printf("%.2lfMB\n", (&f2 - &f1) / 1024.0 / 1024.0);
    // freopen("unyielding.in", "r", stdin);
    // freopen("unyielding.out", "w", stdout);
    scanf("%lld%lld", &n, &k);
    for(int i = 2; i <= n; i++){
        scanf("%lld%lld", &fa[i], &w[i]);
        G[fa[i]].push_back(i);
    }
    dfs(1);
    ans = g[1][0];
    printf("%lld %lld\n", ans.fi, ans.se);
    return 0;
}
```

---

## 作者：shinzanmono (赞：1)

考虑如果不求边权和最小怎么做。

设 $f_{u,i}$ 表示当前结点 $u$ 选至多 $i$ 条去往儿子的边的个数的最大值，转移 $f_{u,i}=\max(f_{u,i}+f_{v,k},f_{u,i-1}+f_{v,k-1}+1)$，跑树形背包即可。

现在我们定义二元组信息 $(a,b)$ 表示选边个数和边权和。定义乘法 $(a,b)\times(c,d)=(a+c,b+d)$，如果 $a=c$，那么加法 $(a,b)+(c,d)=(a,\min(b,d))$，否则 $(a,b)+(c,d)$ 的值为第一项较大者，$u$ 连向父亲的边的边权 $val_u=(1,w_u)$。现在转移方程为 $f_{u,i}=f_{u,i}\times f_{v,k}+f_{u,i-1}\times f_{v,k-1}\times val_v$。

答案就是 $f_{1,k}$。

时间复杂度 $O(nk)$，空间复杂度可以做到 $O(n)$。

```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
using piit=std::pair<int,ll>;
const int sz=1e5+10;
piit operator+(piit a,piit b){
    if(a.first==b.first)return std::make_pair(a.first,std::min(a.second,b.second));
    if(a.first>b.first)return a;
    return b;
}
piit operator*(piit a,piit b){
    return std::make_pair(a.first+b.first,a.second+b.second);
}
struct edge{
    int nxt,to;
    piit w;
}graph[sz];
int head[sz],hpp;
void addEdge(int from,int to,int w){
    graph[++hpp]=edge{head[from],to,std::make_pair(1,w)};
    head[from]=hpp;
}
int n,k;
piit f[sz][2],tmp[110];
void dfs(int u,int fau){
    for(int p=head[u];p;p=graph[p].nxt){
        int v=graph[p].to;
        if(v==fau)continue;
        dfs(v,u);
    }
    std::fill(tmp,tmp+k+1,std::make_pair(0,0));
    for(int p=head[u];p;p=graph[p].nxt){
        int v=graph[p].to;
        if(v==fau)continue;
        for(int i=k;i>=1;i--)tmp[i]=tmp[i]*f[v][1]+tmp[i-1]*f[v][0]*graph[p].w;
        tmp[0]=tmp[0]*f[v][1];
    }
    f[u][0]=tmp[k-1],f[u][1]=tmp[k];
}
int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cin>>n>>k;
    for(int i=2,f,w;i<=n;i++)
        std::cin>>f>>w,addEdge(f,i,w);
    dfs(1,0);
    std::cout<<f[1][1].first<<" "<<f[1][1].second<<"\n";
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

因为我们需要保证连的边数最大，因此我们的 dp 并不需要记录当前连了多少条边，也不需要记录价值。但是因为父节点转移的需要，我们需要记录是否向父亲连边。

定义 $f_{i,j}$ 为考虑子树 $i$，其中节点是否向父亲连边，此时子树中最大连边数，以及此条件下的最小代价（花费）。用 pair 存。

先考虑求 $f_{x,0}$。我们先假设每个子节点 $v$ 我们都取 $f_{v,0}$。这是一定可行的，但是不一定最优。所以我们需要贪心第加入 $K$ 个 $f_{v,1}$ 来替换。此时我们用堆维护 $v$ 取 $1$ 与取 $0$ 的差值，贪心保留最优且不劣的 $K$ 个即可。

求 $f_{x,1}$，我们只需要在我们保留的 $K$ 个中去掉最差的一个，选上其它 $K-1$ 个即可。

```c++
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// Challenger: Erica N
// ----
#include<bits/stdc++.h>

using namespace std;
#define rd read()
#define ull unsigned long long
#define int long long 
#define itn int
#define ps second 
#define pf first

inline int  read(){
	int x;
	cin>>x;
	return x;
}
#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() {
	cerr << endl;
}
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) {
	for (auto v: a) cerr << v << ' ';
	err(x...);
}
template<typename T, typename... A>
void err(T a, A... x) {
	cerr << a << ' ';
	err(x...);
}
#else
#define dbg(...)
#endif
const int N=3e5+5;
const ull P=137;
const int INF=1e13;
/*

策略
每个节点最多链k条
要求数量最多，且代价最小


*/

pair<int,int> f[N][2];//i子树中，且i是否选了父亲边的最大数量和最小代价
int fa[N];
int n,K;
int w[N];
vector<int> e[N];
void add(itn a,int b){
	// cdbg(a,b);
	e[a].push_back(b);
}


struct Node{
	int w,v,p;//op:1选择父亲边
	
	bool operator <(const Node b)const{//<代表大的在前
		if(w==b.w)return v<b.v;
		return w>b.w;
	}
};




void dfs(int x){
	
	priority_queue<Node> pq;
	for(auto v:e[x]){
		dfs(v);
		pq.push({f[v][1].pf-f[v][0].pf+1,f[v][1].ps-f[v][0].ps+w[v],v});
		if(pq.size()>K)pq.pop();
		//!!! 注意如果pq是通用的，那么这里的push会导致v的函数空间中pq有值
		
		
		//先把不和x连边的都加进来
		
		f[x][0].ps+=f[v][0].ps;
		f[x][0].pf+=f[v][0].pf;
		
		f[x][1].ps+=f[v][0].ps;
		f[x][1].pf+=f[v][0].pf;
	}
	
	while(pq.size()){
		if(pq.top().w<0||(pq.top().w==0&&pq.top().v>0))pq.pop();
		else break;
		//把加上一定劣的丢掉
	}
	
	// cdbg(x,pq.size());
	
	
	if(pq.size()==K){
		f[x][0].pf+=pq.top().w;
		f[x][0].ps+=pq.top().v;
		pq.pop();//把最差的给占满K的情况
	}
	while(pq.size()){
		f[x][0].pf+=pq.top().w;
		f[x][0].ps+=pq.top().v;
		f[x][1].pf+=pq.top().w;
		f[x][1].ps+=pq.top().v;
		pq.pop();
	}

	
}

void solve(){
	 n=rd,K=rd;
	for(int i=2;i<=n;i++){
		fa[i]=rd;
		add(fa[i],i);
		w[i]=rd;
	}
	
	dfs(1);
	
	cout<<f[1][0].pf<<' '<<f[1][0].ps<<endl;
	// cdbg(f[6][1].pf);
}


signed main(){
	
	
	
	// freopen("unyielding.in","r",stdin);
	// freopen("unyielding.out","w",stdout);
	
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	

	int T=1;
	while(T--){
		solve();
	}
	// fflush(0);
}



```

---

## 作者：panxz2009 (赞：0)

考虑没有边权和限制时怎么做。

设 $f_{x,i}$ 表示点 $x$ 上连了 $\le i$ 条边时，$x$ 的子树中最多能被选择的边数。儿子转移到父亲时考虑此边是否选择即可：
$$
f_{x,i}=\max_{y\in son_x}(f_{x,i}+f_{y,k},f_{x,i-1}+f_{y,k-1}+1)
$$
考虑加入边权和的限制。当一条边 $x\rightarrow y$ 被选择时，此边会给总边权和带来 $w_{x,y}$ 的贡献。那么用 $f_{x,i}$ 记录一个二元组 $(a,b)$ 表示答案。

定义广义加法：
$$
(a,b)+(c,d)=(a+c,b+d)
$$
定义广义 $\max$：
$$
\max((a,b),(c,d))=\begin{cases}
(a,\min(b,d))&\text{if }a=c\\
(a,b)&\text{if }a>c\\
(c,d)&\text{if }a<c
\end{cases}
$$
转移：
$$
f_{x,i}=\max_{y\in son_x}(f_{x,i}+f_{y,k},f_{x,i-1}+f_{y,k-1}+(1,w_{x,y}))
$$
这样就足以通过本题。但空间上还可以继续优化。观察转移，发现只有 $f_{y,k-1},f_{y,k}$ 被用到，考虑把状态改为 $f_{x,0/1}$ 表示点 $x$ 上连了 $k-1/k$ 条边时，$x$ 的子树的答案。同时再记一个临时数组 $F_{i}$ 表示当前点 $x$ 的 $f_{x,i}$。

转移就可以变为：
$$
F_{i}=\max_{y\in son_x}(F_{i}+f_{y,1},F_{i-1}+f_{y,0}+(1,w_{x,y}))
$$
转移完后记得把 $F_{k-1},F_{k}$ 赋值给 $f_{x,0/1}$。
```cpp
#include <bits/stdc++.h>
#define LL long long
#define PII pair <int, int>
using namespace std;
const int maxn = 1e5 + 10;
int n, k, fa[maxn], w[maxn];
vector <PII> G[maxn];
struct info {
	LL siz, sum;
	friend info operator + (info x, info y) {
		return {x.siz + y.siz, x.sum + y.sum};
	}
}f[maxn][2], F[110];
info max(info x, info y) {
	if(x.siz == y.siz) return {x.siz, min(x.sum, y.sum)};
	else if(x.siz > y.siz) return x;
	else return y;
}
void dfs(int x) {
	for(auto tmp : G[x]) {
		int y = tmp.first, z = tmp.second;
		dfs(y);
	}
	for(int i = 0; i <= k; i++) F[i] = {0, 0};
	for(auto tmp : G[x]) {
		int y = tmp.first, z = tmp.second;
		for(int i = k; i >= 0; i--) {
			F[i] = F[i] + f[y][1];
			if(i >= 1) F[i] = max(F[i], F[i - 1] + f[y][0] + (info){1, z});
		}
	}
	f[x][0] = F[k - 1], f[x][1] = F[k];
}
int main() {
	scanf("%d%d", &n, &k);
	for(int i = 2; i <= n; i++) {
		scanf("%d%d", &fa[i], &w[i]);
		G[fa[i]].push_back({i, w[i]});
	}
	dfs(1);
	printf("%lld %lld\n", f[1][1].siz, f[1][1].sum);
	return 0;
}

```

---


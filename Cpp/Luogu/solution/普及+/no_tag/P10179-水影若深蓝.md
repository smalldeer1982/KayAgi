# 水影若深蓝

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/e2h3lfb4.png)

帆帆爱明日方舟，更爱水月和深蓝之树。但在龙年，他想构建一棵独属于他的深蓝之树。

## 题目描述

在梦里，在朦胧的水影中，帆帆看见了这棵只属于他的深蓝之树。

当一切梦沉寂，他却遗忘了所有，只记得树上有 $n$ 个结点。

真的吗？似乎并没有，有 $m$ 件事情他一直牢记着，第 $i$ 件事情是：节点 $u_i$ 和 $v_i$ 在这棵深蓝之树上唯一的不重复经过某个点的路径恰好有两条边。

那么，你能否帮助帆帆想起来这棵深蓝之树的样子呢，如果有多个可能的，你只需要输出任意一种。

当然，帆帆也是会磨损的，因此当你发现无论如何都找不到满足帆帆这 $m$ 件事情的深蓝之树时，你需要报告无解。


## 说明/提示

### 样例 $1$ 解释

对于第一组数据，不难验证给出的树符合条件。

对于第二组数据，可以证明不存在符合条件的树。

### 测试点约束

对于 $100\%$ 的数据，$1\le T\le 10^5$，$n\ge 2$，$m\ge 0$，$1\le \sum n\le 3\times 10^5$，$0\le \sum m\le 3\times 10^5$，$1\le u_i,v_i\le n$，$u_i\neq v_i$。

本题采用捆绑测试。

| 子任务编号 | 特殊限制 | 分值 |
| :--------: | :-------------: | :--: |
| Subtask #1 |     $\sum n,\sum m\le 9$     | $10$ |
| Subtask #2 |    $\sum n,\sum m\le 50$     | $10$ |
| Subtask #3 |    $\sum n,\sum m\le 5000$    | $10$ |
| Subtask #4 |   $v_i=u_i+1$    | $10$ |
| Subtask #5 |   $u_i=1$    | $10$ |
| Subtask #6 |   $u_i\neq 1,v_i\neq 1$    | $10$ |
| Subtask #7 |   $T=1$    | $10$ |
| Subtask #8 |   无    | $30$ |



## 样例 #1

### 输入

```
2
4 2
1 2
3 4
3 3
1 2
2 3
3 1```

### 输出

```
Yes
1 3
2 4
2 3
No```

# 题解

## 作者：云浅知处 (赞：19)

考虑对每个限制 $(u_i,v_i)$ 连无向边 $(u_i,v_i)$。

- 若图中有至少两个连通块，任选两个连通块，在这两个连通块中各任取一点 $x,y$，考虑如下构造：称 $x$ 所在连通块中的所有点为黑点，剩余点为白点，将所有黑点向 $y$ 连边，所有白点向 $x$ 连边。这样，任意两个同一连通块中的点的距离均为 $2$。以下是一个图示：

- ![](https://cdn.luogu.com.cn/upload/image_hosting/e674q6wv.png)

- 若图中有且仅有一个连通块，我们证明此时无解：考虑将原树黑白染色，在所有同色点之间连边，则给出的图必定是该图的生成子图。由于原图有且仅有两个连通块，因此给出的图必然至少存在两个连通块；从而此时不存在这样的树。

算法的时间复杂度为 $O(n+m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;

int T, n, m, fa[N];

inline int getfa(int x) {return x == fa[x] ? x : fa[x] = getfa(fa[x]);}

int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d%d", &n, &m);
		for (int i = 1; i <= n; ++i) fa[i] = i;
		for (int i = 1, x, y; i <= m; ++i) {
			scanf("%d%d", &x, &y);
			assert(x != y);
			x = getfa(x); y = getfa(y);
			fa[x] = y;
		}
		int cnt = 0; int p[2];
		for (int i = 1; i <= n; ++i) {
			if (getfa(i) != i) continue;
			if (cnt < 2) p[cnt] = i;
			cnt++;
		}
		if (cnt == 1 && n > 1) {
			puts("No");
			continue;
		}
		if (cnt == 1 && n == 1) {
			puts("Yes");
			continue;
		}
		puts("Yes");
		printf("%d %d\n", p[0], p[1]);
		for (int i = 1; i <= n; ++i) {
			if (i == p[0] || i == p[1]) continue;
			if (getfa(i) == p[0]) printf("%d %d\n", i, p[1]);
			else printf("%d %d\n", i, p[0]);
		}
	}
	return 0;
} 
```

---

## 作者：A1234467 (赞：9)

- ### Step 1：简化题意
	
	有一棵节点数为 $n$ 的树，给出 $m$ 对关系，每对关系 $(u, v)$ 表示节点 $u$ 与节点 $v$ 间的路径上恰好有一个其他节点，构造出这棵树或者判断无解
    
- ### Step 2：分析题目

	- 首先我们尝试画出样例所给的树，每对关系用虚线表示
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/f5kn4cpv.png)
    
   - 按照样例输出连边
   
    ![](https://cdn.luogu.com.cn/upload/image_hosting/ras5zmb7.png)
    
   - 不难想到，对于每对关系都可以通过同时与另一个中转点建边解决
   
   - 注意到如果关系间发生重叠，对于第二对关系容易有以下两种方案
   
    ![](https://cdn.luogu.com.cn/upload/image_hosting/3nn91x8g.png)
    
   - 基于简化原则，我们尽可能不引入新点，因此我们只考虑绿色虚线的方案，由此我们可以得到关系间的传递性
   
   - 同时显然可以发现关系间的互异性，即对于有重叠的两对关系，我们不能将其中任意点作为与该点无关的关系的中转点
   
   - 基于前述的两个性质，我们考虑将重复的关系染色
   
    ![](https://cdn.luogu.com.cn/upload/image_hosting/y5fwp8ic.png)
    
   - 不难发现，如果整棵树被染成了一种颜色，那么我们无法给这种颜色找到中转点，此时无解，否则将每种颜色包含的点与任意不同颜色的点建边即可
   
- ### Step 3：代码实现

	- 用并查集染色，如果只有一种颜色则判断无解，否则将第一种颜色的所有点与一个不同颜色的点建边，其他颜色的所有点与点 $1$ 建边即可
    
    ```cpp
    #include <stdio.h>
    #include <stdlib.h>
    #include <vector>
    #include <utility>
    #include <numeric>

    #define K01 main

    #ifdef ONLINE_JUDGE
    char buf[1000000], *p1, *p2;
    #define getchar() ((p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 10000000, stdin), p1 == p2)) ? 0 : *p1++)
    #endif

    inline int read(){
        int res = 0;
        char ch = getchar();
        while(ch < '0' || ch > '9') ch = getchar();
        while(ch >= '0' && ch <= '9') res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
        return res;
    }
    void write(int x){
        if(x > 9) write(x / 10);
        putchar(x % 10 + 48);
    }

    int find(std::vector<int> &set, int x){
        int &tmp = set[x];
        return tmp == x ? x : tmp = find(set, tmp);
    }

    int K01(){
        int T = read();
        while(T--){
            int n = read(), m = read();
            std::vector<int> vec(n + 1);
            std::iota(vec.begin() + 1, vec.end(), 1);
            for(int i = 1; i <= m; ++i){
                int u = find(vec, read()), v = find(vec, read());
                if(u > v) std::swap(u, v);
                vec[v] = u;
            }
            std::vector<int> color(n + 1);
            int flag = 0, cnt = 0;
            for(int i = 1; i <= n; ++i){
                if(vec[i] == i) color[i] = ++cnt;
                else color[i] = color[vec[i]];
                if(cnt != 1 && !flag) flag = i;
            }
            if(cnt == 1){ printf("No\n"); continue;}
            printf("Yes\n");
            for(int i = 1; i <= n; ++i){
                if(i == flag) continue;
                else if(color[i] == 1) write(i), putchar(' '), write(flag), putchar('\n');
                else putchar('1'), putchar(' '), write(i), putchar('\n');
            }
        }
        return 0;
    }
    ```

   - 上述代码 $56ms$ 目前最优解第二
   
	  （第一的$5ms$提交记录只有一个测试点不算在内）
   
	  （目前，指 $2024.2.20-17:46$）
   
     ![](https://cdn.luogu.com.cn/upload/image_hosting/aklm81fo.png)
     
     
     
	- 加卡常头到最优解第一
    
	  （$upd:2024.2.23-11:35$）
    
	  ![](https://s11.ax1x.com/2024/02/23/pFNjhi6.png)

---

## 作者：gesong1234 (赞：8)

题目传送门：[P10179 水影若深蓝](https://www.luogu.com.cn/problem/P10179)。
# 思路
一种基于三层树的构造。

题目中要求节点 $u_i$ 和 $v_i$ 在这棵深蓝之树上唯一的不重复经过某个点的路径恰好有两条边，相当于 $u_i$ 和 $v_i$ 只有两种情况：

1. 在树中 $|dep_u-dep_v|=2$。
2. 在树中 $dep_u=dep_v$。

那我们先假设一个根，就将其设为 $1$ 号点，然后我们使用第 $1$ 种情况，把 $u_i=1$ 或者 $v_i=1$ 的另外的一个点加入第三层的节点，然后我们使用第二种情况，把与第三层的节点有直接或间接关系的 $u_i,v_i$，最后把剩下的点放入第二层。

判断不合法情况：

1. 第二层为空，第三层有节点。
2. $u_i,v_i$ 不合法。




# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+10;
vector<int>a,b;
int vis[N];
struct nord{
	int x,y;
}c[N];
inline int read(){
	char c=getchar();
	int f=1,ans=0;
	while(c<48||c>57) f=(c==45?f=-1:1),c=getchar();
	while(c>=48&&c<=57) ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
	return ans*f;
}
set<int>d[N];
void dfs(int u){
	vis[u]=3;
	b.push_back(u);
	for (auto v:d[u]) if (!vis[v]) dfs(v);
}
main(){
	int T=read();
	while(T--){
		int n=read(),m=read();
		if (n==1&&m==0){
			puts("Yes");
			continue;
		}
		for (int i=1;i<=n;i++) vis[i]=0,d[i].clear();
		for (int i=1;i<=m;i++) c[i]={read(),read()},d[c[i].x].insert(c[i].y),d[c[i].y].insert(c[i].x);
		a.clear(),b.clear();
		vis[1]=1;
		for (int i=1;i<=m;i++){
			int x=c[i].x,y=c[i].y;
			if (x==1) b.push_back(y),vis[y]=3;
			else if (y==1) b.push_back(x),vis[x]=3; 
		}
		for (int i=1;i<=n;i++)
			if (vis[i]==3) dfs(i);
		for (int i=1;i<=n;i++)
			if (!vis[i]) a.push_back(i),vis[i]=2;
		if (a.empty()&&!b.empty()){
			puts("No");
			continue;
		}
		bool flag=1;
		for (int i=1;i<=m;i++){
			int x=c[i].x,y=c[i].y;
			if (vis[x]==1&&vis[y]==2){
				flag=0;
				puts("No");
				break;
			}
			if (vis[x]==2&&vis[y]==1){
				flag=0;
				puts("No");
				break;
			}
			if (vis[x]==2&&vis[y]==3){
				flag=0;
				puts("No");
				break;
			}
			if (vis[x]==3&&vis[y]==2){
				flag=0;
				puts("No");
				break;
			}
		}
		sort(a.begin(),a.end());
		sort(b.begin(),b.end());
		a.erase(unique(a.begin(),a.end()),a.end());
		b.erase(unique(b.begin(),b.end()),b.end());
		if (flag){
			puts("Yes");
			for (auto i:a) printf("1 %lld\n",i);
			for (auto i:b) printf("%lld %lld\n",a[0],i);
		}
	}
    return 0;
}
```

---

## 作者：KingGojianOfYue (赞：7)

~~比Div2 T2水！~~

首先我们得了解题意。（节点 $u_i$ 和 $v_i$ 在这棵深蓝之树上唯一的不重复经过某个点的路径恰好有两条边的意思是节点 $u_i$ 和 $v_i$ 的距离恰好为 $2$ ）

嗯。我们都知道：一棵树肯定是一个二分图。所以我们可以把原题意理解为节点 $u_i$ 和 $v_i$ 在二分图的同一子集里。

我们也当然可以想到输出 `No` 的情况：$n$ 个节点都在同一子集里。

然后我们就可以。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[300001];
int s[300001];
int n,m,t,u,v;
int find(int x){
	if(f[x]==x)return x;
	return f[x]=find(f[x]);
}
vector<int>b[2];
vector<int>::iterator it;
int main()
{
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(m==0){//特判：因为好像有m=0的情况
			cout<<"Yes\n";
			for(int i=1;i<n;i++)cout<<i<<' '<<i+1<<'\n';
			continue;
		}
		for(int i=1;i<=n;i++)f[i]=i,s[i]=0;
		b[0].clear(),b[1].clear();
		while(m--){
			cin>>u>>v;
			f[find(u)]=find(v);//u与v为同一子集
		}
		for(int i=1;i<=n;i++)find(i);
		bool flag=true;
		for(int i=1;i<n;i++){
			if(f[i]!=f[i+1]){flag=false;break;}
		}
		if(flag){cout<<"No\n";continue;}//当这n个数都在同一子集里，不能分成两个子集时，无解
		cout<<"Yes\n";
		int r=0;
		for(int i=1;i<=n;i++)s[f[i]]++;
		for(int i=1;i<=n;i++)if(s[i]>1){r=i;break;}
		for(int i=1;i<=n;i++){//分成两个子集
			if(f[i]==r)b[0].push_back(i);//把与r为同一子集的数放在一起
			else b[1].push_back(i);//反之，把其他数放在一起
		}
		for(int i=0;i<b[1].size();i++)cout<<b[0][0]<<' '<<b[1][i]<<'\n';
		for(int i=1/*由于树的根没有父亲，故从1开始*/;i<b[0].size();i++)cout<<b[1][0]<<' '<<b[0][i]<<'\n';
	}
	return 0;
}

```

---

## 作者：luxiaomao (赞：3)

赛时把无解的 `continue` 写成了 `break` 竟然还得到了 70 pts 的好成绩，赛后被别人指出的时候无地自容。。QAQ

## [P10179](https://www.luogu.com.cn/problem/P10179) 并查集实现的构造好题

来提供一种跟标程不一样的思路，虽然也是靠并查集来维护。（~~竟然押韵了~~）

首先，大家应该都不难想到，对于限制条件 $(u_i,v_i)$，我们在 $u_i$ 和 $v_i$ 之间连一条无向边。这只是一种做题的直觉，那为什么这么做呢？

假设我们给构造出来的树进行黑白染色，那么任何 $(u_i,v_i)$ 肯定都是一个颜色的。因为它们之间的距离是二，只可能是 黑——白——黑 或者 白——黑——白。（这个不难理解吧）

那么出现了一个传递的关系。如果 $(u_i,v_i)$ 且 $(v_i,w_i)$，自然有 $(u_i,w_i)$。怎么维护这种合并关系呢？并查集嘛。

那我们先像开头说的那样，把所有限制条件都建边，进行并查集的合并，然后我们就得到了一些连通块，因为时限很宽松，所以我用了比较方便的 `vector`。

```cpp
tot = 0;
for(int i = 1;i <= n;i++)
	if(find(i)==i)color[i] = ++tot,a[tot].clear(); 
for(int i = 1;i <= n;i++)
	a[color[find(i)]].push_back(i);
```

这时候先进行特判：

- 如果 $n=1$，显然只有一个点，无需构造，输出 `Yes`。

- 如果 $n\not=1$ 且只有一个连通块，无解输出 `No`。证明：这些点之间肯定都要互相连边（点数大于一），但是同一个连通块内的点两两距离为 2（根据题意），任何一条连边都会使两个点的距离为 1，无法满足题意，故得证。（可以参考样例的无解情况。）

接下来就是有解的情况了。在找出连通块的情况下，我们怎么构造呢？

首先可以发现：一个连通块中的所有点，它们都向一个不属于这个连通块的点连边，那么就可以实现该连通块中的点两两距离为 2 了，那么对于每一个连通块，我们向他的上一个连通块连边。

大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/g1hmqkv7.png)

那可能有同学要问了：如果连通块一号不止一个点呢？

我们先把连通块按照节点数量排序，如果最小的连通块依然不止一个点，我们就把它往**第二个连通块的任意一个节点**连边。

![](https://cdn.luogu.com.cn/upload/image_hosting/jd02qzl7.png)

可以看到，依然符合题意，构造完毕。

## Code Time

感觉应该说得非常详细了，那么上代码，本题码量不大，但考思维，当做练练手的构造题还是挺好的。

```cpp

#include<bits/stdc++.h>
#define N 100005
using namespace std;

int T,n,m;
vector<int> a[N];
int fa[N],color[N];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
bool cmp(vector<int> x,vector<int> y)
{
	return x.size()<y.size();
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		int cnt = n;
		for(int i = 1;i <= n;i++)fa[i] = i;
		while(m--)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			if(find(u) != find(v))
				fa[find(v)] = find(u),cnt--;
		}
		if(cnt == 1 && n != 1){puts("No");continue;}
		if(cnt == 1 && n == 1){puts("Yes");continue;}
		puts("Yes");
		int tot = 0;
		for(int i = 1;i <= n;i++)
			if(find(i)==i)color[i] = ++tot,a[tot].clear(); 
		for(int i = 1;i <= n;i++)
			a[color[find(i)]].push_back(i);
		sort(a+1,a+1+cnt,cmp);
		for(int i = 2;i <= cnt;i++)
			for(int j = 0;j < (int)a[i].size();j++)
				printf("%d %d\n",a[i-1][0],a[i][j]);
		if(a[1].size() > 1)
			for(int i = 1;i < (int)a[1].size();i++)
				printf("%d %d\n",a[2][1],a[1][i]);
	}
	return 0;
}
```

---

## 作者：CoderMeow (赞：3)

# P10179 水影若深蓝 题解

## 前言

赛时感觉还算简单的一道有点意思的构造，个人感觉只有黄题难度（

## 题意简述

要求构造一棵有 $n$ 个结点的树，需满足 $m$ 个 $u_i$ 个 $v_i$ 在树上的唯一简单路径恰含两条边的条件。

## 条件转化

令树为有根树，则不难发现，一个条件等同于让 $u$ 和 $v$ 共父亲，或者其中一个为另一个的父亲之父亲。此处先假设 $u$ 和 $v$ 有同一个父亲，因为二种情况在无根树中是等价的。第二种情况在最后满足树根唯一时使用即可。

## 满足条件的构造

两个结点共父亲的关系显然是具有传递性的，可以考虑用并查集维护相同父亲的结点们。

在根据所有条件得到最终并查集后，根据共父亲的条件，$n$ 个结点可以分成几部分，这里将其称为“层”。

那么对于第 $i$ 和 $i + 1$ 层，可以让第 $i$ 层任一结点成为 $i+1$ 层所有结点的父亲。那么最终可能得到一个森林，因为除了第一层，其他层结点都有且仅有一个父亲。

此时再来考虑条件的第二种转化。不难想到可以让第二层的某个结点作为树根，此时其到其原先所在的层的路径中仍有两条边。但如果仅有一层且该层结点不止一个，是没有办法得到树的，那么判定为无解。至此构造结束。

## 代码

并查集在代码中采用路径压缩的优化，未使用启发式合并，处理条件的最坏时间复杂度 $O(m\log n)$。最终构造的方案可以 $O(n)$ 得到。

同时，对于此类传递关系也可以通过生成无向图并 dfs 寻找连通块维护，复杂度线性。该种方法可以参考我的另一篇题解 [P9869 三值逻辑 题解](https://www.luogu.com.cn/blog/coder-meow/P9869-solution)。

```cpp
# include <cstdio>
# include <vector>

using namespace std;

vector<int> father;  // 并查集

int find(int x) {
    return (x == father[x]) ? x : (father[x] = find(father[x]));  // 路径压缩的并查集
}

int main() {
    int T;
    scanf("%d", &T);

    for (int c1 = 0; c1 < T; ++c1) {
        int n, m;
        scanf("%d %d", &n, &m);

        father = vector<int>(n);
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }  // 并查集的初始化

        for (int c2 = 0; c2 < m; ++c2) {
            int u, v;
            scanf("%d %d", &u, &v);
            u -= 1;  // 个人习惯下标从 0 开始使用 QwQ
            v -= 1;

            father[find(v)] = find(u);
        }  // 对条件的维护

        int layerNum = 0;
        vector<vector<int>> layers1(n);  // layers1[x] 表示并查集中以 x 作为代表的集合（层）

        for (int i = 0; i < n; ++i) {
            layerNum += find(i) == i;
            layers1[father[i]].push_back(i);
        }

        if (layerNum <= 1) {
            printf("No\n");  
            continue;
        } else {
            printf("Yes\n");
        }

        // 为方便构造，将 layers1 根据代表编号的方式改为存储每一层的内含结点，从而数组中没有元素是空数组
        vector<vector<int>> layers2; 
        for (int i = 0; i < n; ++i) {
            if (layers1[i].empty()) {
                continue;
            }

            layers2.push_back(layers1[i]);
        }

        int root = layers2[1].back();
        layers2[1].pop_back();
        for (int node: layers2[0]) {
            printf("%d %d\n", root + 1, node + 1);
        }

        bool jump = layers2[1].empty();  // 特判一下如果第二层的结点被用来当根后第二层没有结点了，那么给出构造时跳过该层
        for (int i = 0; i < layerNum - 1; ++i) {
            if (jump && (i == 0) && (layerNum > 2)) {
                for (int j = 0; j < layers2[2].size(); ++j) {
                    printf("%d %d\n", layers2[0][0] + 1, layers2[2][j] + 1);
                }

                i += 1;
                continue;
            }
            for (int j = 0; j < layers2[i + 1].size(); ++j) {
                printf("%d %d\n", layers2[i][0] + 1, layers2[i + 1][j] + 1);
            }
        }
    }

    return 0;
}

```

---

## 作者：what_can_I_do (赞：2)

[传送门](https://www.luogu.com.cn/problem/P10179)

其实题目要求的就是随便定一个点为根，则所有的 $u_i$ 和 $v_i$ 要么为兄弟关系，要么为爷孙关系。

那么此时我们就有一个策略，如果有一个点在所有的限制条件当中都没有出现，那么就可以另它为根，所有的点都是它的儿子，这样子就可以满足所有限制条件的点为兄弟关系。

如果没有这样的一个在所有的限制条件都没有出现的点呢？只需要给每个限制条件连边建图，然后从点 $1$ 开始遍历点 $1$ 的连通块，然后选择没在连通块的随便一个点为根，$1$ 所在的连通块为这个点的儿子，其它的点为 $1$ 的儿子，这样就可以保证所有不包括根的限制条件都能是兄弟关系且根的连通块里的点都跟它是爷孙关系。如果没有能选得出来的根就输出 `No`。

# CODE:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t;
int n,m;
struct tree
{
	vector<int> son;
	int fa;
}tr[300010];
bool vis[300010]={0};
int uu[300010],vv[300010];
vector<int> g[300010];
queue<int> q;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		for(register int i=0;i<=n;i++) vis[i]=0,tr[i].fa=0,tr[i].son.clear(),g[i].clear();
		scanf("%d%d",&n,&m);
		if(!m)
		{
			for(register int i=1;i<=n-1;i++) printf("%d %d\n",i,i+1);
			continue;
		}
		for(register int i=1;i<=m;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			uu[i]=u,vv[i]=v;
			vis[u]=vis[v]=1;
		}
		int ff=0;
		for(register int i=1;i<=n;i++) if(!vis[i]) ff=i;
		if(ff)
		{
			for(register int i=0;i<=n;i++) tr[i].son.clear();
			for(register int i=1;i<=n;i++)
			{
				if(i!=ff) tr[ff].son.push_back(i);
			}
		}
		else
		{
			for(register int i=1;i<=n;i++) vis[i]=0;
			for(register int i=1;i<=m;i++)
				g[uu[i]].push_back(vv[i]),g[vv[i]].push_back(uu[i]);
			q.push(1);
			while(!q.empty())
			{
				int k=q.front();
				q.pop();
				if(vis[k]) continue;
				vis[k]=1;
				for(register int i=0;i<g[k].size();i++)
				{
					int x=g[k][i];
					if(vis[x]) continue;
					q.push(x);
				}
			}
			for(register int i=1;i<=n;i++) if(!vis[i]) ff=i;
			if(!ff){puts("No");continue;}
			for(register int i=2;i<=n;i++)
				if(vis[i]) tr[ff].son.push_back(i);
				else tr[1].son.push_back(i);
		}
		puts("Yes");
		for(register int i=1;i<=n;i++)
			for(register int j=0;j<tr[i].son.size();j++)
				printf("%d %d\n",i,tr[i].son[j]);
	}
	return 0;
}
```

---

## 作者：TimSwn090306 (赞：2)

#### [P10179 水影若深蓝 题目传送门](https://www.luogu.com.cn/problem/P10179)

## 0. 写在前面

用了 15 min 场切 Div 2 的 T3 开心捏。

我猜这道题应该会有很多种做法，因为光我们机房就已经研究出两种不同于官方题解的做法了（（

我的做法主要是简化答案树的形态，使得任意的给定的限制条件都能构造出某种特定形态的树或者判断无解。

## 1. 题目简述

有一棵 $n$ 个点的树，给定 $m$ 组限制条件 $(x,y)$ 满足树上 $x$ 与 $y$ 的距离是 $2$，问能否构造出满足所有限制条件的任意一棵树，或者判断无解。

$n,m \leq 3\times 10^5$

## 2. 思路分析

这题看起来就很构造（指几乎不需要数据结构的那种。

正着从限制条件推不好推（中间点未知一定程度上会影响树的形态），那我们可以反着从答案树的形态上去看有什么共性。

不妨假设一棵可能的答案树是这个形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/xmbc1ph2.png)

现在的目标是尝试把这棵树去化简，首先从深度入手。

既然想要去减少深度，那么必然是要将叶子节点的父亲设为深度更小的节点，分类讨论某个叶子节点参与的所有限制条件里的另一方是他的兄弟还是爷爷。是兄弟的话，将其也指向这个深度更小的节点同样能满足限制条件；是爷爷的话，只要这个深度较小的新节点是原叶子节点爷爷的父亲，那么这种情况也能满足。综上我们得到了一种移动节点的策略，即：若已有一棵满足所有限制条件的答案树 $S$，将某个叶子节点及其所有的相同父亲的兄弟，共同重新连向他们原来的爷爷的父亲，仍能满足新的树 $T$ 仍为一棵答案树。

例如将上图例子中的节点 $6,7$ 进行一次操作后，答案树变成了：

![](https://cdn.luogu.com.cn/upload/image_hosting/02ggqo0v.png)

这棵答案树再对节点 $8$ 做一次操作就能达到减少深度的目的了，这个过程可以递归地去做。

这样只要答案树的深度 $\ge \space 4$ 我们就一定可以对其进行操作使得深度逐渐变小（深度的限制是为了保证叶子节点的爷爷的父亲存在），最后得出结论：如果给定的限制条件有解，那么一定有一棵深度 $=3$ 的可行的答案树。

深度做完了，现在再在具体的父子关系上动一动手脚。

可以发现将所有叶子节点的父亲指向同一个父亲能够满足的限制条件是不弱于分散给很多个父亲的，将他们连向同一个父亲可以最大化能够满足的限制条件数目。

我们特殊化节点 $1$ 为根节点，现在树的形态就变成了：

![](https://cdn.luogu.com.cn/upload/image_hosting/mwgntkt3.png)


上图节点 $2$ 只是代表根节点的某一个儿子，并不代表实际节点 $2$，只是为了形容这样的一个树的形态。

现在给出的限制条件就有两种情况：

情况 1 ：$(1,x)$，因为已经特殊化节点 $1$ 是根节点，那么 $x$ 就一定是深度为 $3$ 的节点。

情况 2 ：$(x,y)$，如果 $x$ 和 $y$ 有一方深度为 $3$，那么将另一方深度同样设为 $3$。反之，如果双方都没有被确定为深度为 $3$ ，那么把他们深度设为 $2$。

最后如果存在一个点 $u$，使得 $u$ 的深度为 $2$，将所有的深度为 $3$ 的节点连向节点 $u$，深度为 $2$ 的节点连向节点 $1$，就能满足所有限制条件。不存在 $u$ 就是无解的情况。

代码实现上使用了并查集实现上文情况 2 中判断是否有一方深度已经设为 $3$。

## 3. 代码实现

复杂度应该是可以做到 $O(n+m\alpha(n))$，但是没写按秩合并严格上是 $O(n+m\log n)$。

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define mkp(x,y) make_pair(x,y)
#define fir first
#define sec second
using namespace std;
const int maxn=3e5+5;
int T,n,m,fa[maxn],flag[maxn];//节点是不是深度为 3 的标记
pii e[maxn];
inline int find(int x){
    if (fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}
inline void merge(int x,int y){
    int u=find(x),v=find(y);
    if (u!=v) fa[u]=v;
}
inline void solve(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){//初始化
        fa[i]=i;
        flag[i]=0;
    }
    for (int i=1;i<=m;i++){
        scanf("%d%d",&e[i].fir,&e[i].sec);
        if (e[i].fir>e[i].sec) swap(e[i].fir,e[i].sec);
    }
    for (int i=1;i<=m;i++) if (e[i].fir!=1) merge(e[i].fir,e[i].sec);//合并情况 2
    for (int i=1;i<=m;i++) if (e[i].fir==1) flag[find(e[i].sec)]=1;//按情况 1 标记必须深度为 3 的点
    for (int i=1;i<=m;i++){
        if (flag[find(e[i].fir)] || flag[find(e[i].sec)]){
            flag[e[i].fir]=flag[e[i].sec]=1;//按情况 2 打标记
        }
    }
    int rt=0;//寻找某个深度不要求为 3 的节点
    for (int i=1;i<=n;i++){
        if (!flag[i]){
            rt=i;
            break;
        }
    }
    if (!rt){//不存在就是无解
        printf("No\n");
        return ;
    }
    printf("Yes\n");
    for (int i=2;i<=n;i++){//依靠标记输出方案
        if (flag[i]) printf("%d %d\n",i,rt);
        else printf("%d 1\n",i);
    }
}
int main(){
    scanf("%d",&T);
    while (T--) solve();
    return 0;
}
```

欢迎各路大佬的讨论 TVT 。


---

## 作者：云雷心柠檬听 (赞：2)

[博客食用更佳](https://www.cnblogs.com/lemon-cyy/p/18022369)

### 题意简述
给定 $n$ 个点，要求构造出一棵树，同时有 $m$ 个事件，第 $i$ 个事件要求 $u_i$ 和 $v_i$ 用两条树边连接，即当中相隔一个点。若存在构造方案，输出 `Yes` 并输出其中一种方案，否则输出 `No`。

### 思维路径
首先简化问题，假如我们想让一堆点互相相隔一个点，我们的做法。考虑菊花图（如下图），所有绿色的点都恰好相隔一个点（中间的黑点），可以满足条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/gyn5an2b.png)

接下去考虑继续扩展，假如有很多像绿点这样的集团，都有求互相相隔一个点，我们可以对于每个集团选择一个首领，把首领串成一条链，剩下的集团连相邻的首领上。如图所示，同一种颜色位同一个集团。

![](https://cdn.luogu.com.cn/upload/image_hosting/xcmp80w2.png)

请注意，对于上面这种情况我的构造方案是将集团 $i$ 的点连在 $i+1$ 上，对于最后一个集团连在它的前一个上。

但是这与题目并非完全一致。我们将集团的定义改为对于任意集团内的点 $u$，必定存在集团内另一个点 $v$ 要求与 $u$ 相隔为 1 个点。

此时就需要证明，之前的构造对于这个定义能够得到正确答案。

- 假设当前点 $v$ 是首领，那么点 $u$ 连在旁边的首领上，可以满足条件。
- 假设当前点 $v$ 不是首领，已经连在了旁边的首领上，那么点 $u$ 也连在旁边的首领上，可以满足条件。

综上所述之前的构造方案是可以在这个定义的前提下得到正确答案的。

### 实现细节
寻找集团的方式可以用并查集，首领就自动为并查集最终找到的祖先即可。

假若最终只剩下一个集团就无解。

具体实现可以参考 AC 代码。

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300009;
int T;
int n,m,nC;
int fa[N],cn[N],t[N];

void init(){
	cin>>T;
}

void input(){
	cin>>n>>m;
}

int findfa(int u){
	if(fa[u]==u) return u;
	else return fa[u]=findfa(fa[u]);
}

void add(int u,int v){
	int fu=findfa(u);
	int fv=findfa(v);
	if(fu==fv) return;
	fa[fu]=fv;
}

void solve(){
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
	} 
	nC=0;
	for(int i=1;i<=n;i++){
		if(fa[i]==i){
			cn[++nC]=i;
			t[cn[nC-1]]=i;//记录相邻的下一个点
		}
	}
	if(nC==1){
		cout<<"No\n";
		return;
	}
	cout<<"Yes\n";
	t[cn[nC]]=cn[nC-1];//最后一个点连到上一个点
	for(int i=1;i<nC;i++){//连首领
		cout<<cn[i]<<" "<<cn[i+1]<<"\n";
	}
	for(int i=1;i<=n;i++){//连其他点
		if(fa[i]==i) continue;
		cout<<i<<" "<<t[findfa(i)]<<"\n";
	}
}

int main(){
	init();
	while(T--){
		input();
		solve();
	}
	return 0;
}
```

### 后记
和出题人给出的构造好像有些许不同，但本质是一样的。

---

## 作者：aCssen (赞：2)

### Solution
首先我们假设有这么一棵树，那么我们可以对它黑白染色，即选定一个根，并令根的深度为 $1$，点 $x$ 的深度为它的父亲的深度加 $1$。对于深度为奇数的层将其染成白色，否则染成黑色。

那么对于每一条限制 $(u,v)$，$u$ 的颜色一定与 $v$ 相同，如下图所示:

![](https://cdn.luogu.com.cn/upload/image_hosting/6hu5aipp.png)

假定我们以 $1$ 为根，加粗的点表示相同的颜色，那么距离为 $2$ 的路径有 $(u,v)$ 两种：

+ $\operatorname{LCA}(u,v)=u$ 或 $\operatorname{LCA}(u,v)=v$，如图中的 $(1,4)$，这样相当于这两个点间隔了一层，那么颜色显然相同。

+ 否则，如图中的 $(2,4)$，两个点位于同一层，那么颜色也相同。

因此，我们可以用并查集维护颜色相同的点，对于每条限制将 $u$ 与 $v$ 所在的集合合并即可。

最终有若干个颜色的联通块，我们可以随意划定一部分联通块由白点组成，另一部分为黑点组成，设白点集合为 $w$，黑点集合为 $b$,考虑这样一种构造：

> 从 $w$ 中任选一个点作为根，记为 $p$，对于 $b$ 中的任意节点 $x$，连边 $(p,x)$。再从 $b$ 中任选一个节点 $p'$，对于 $w$ 中所有不为 $p$ 的节点 $x'$，连边 $(p',x')$。

容易验证，这样的构造满足题意。

那么什么时候无解呢？观察样例可以发现，第二组样例无解是因为 $3$ 个点都为一种颜色，而根只有一个，想要加更多的同色节点必须有异色节点插在两层中间，可是没有。所以，如果 $w$ 为空且 $|b|>1$ 或 $b$ 为空且 $|w|>1$，无解。

关于 $w,b$ 是否可以随便选，答案是肯定的，验证可以分以下几种情况：

+ $w,b$ 均为空：不可能。

+ $w,b$ 有一个为空：已经在前文判断过了。

+ $w,b$ 均不空：那就没问题了，一定能从中选出一个根，剩下的构造就一定合法了。注意树的第三层可以是空的。

关于一些实现方式详见代码。
### Code
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int maxn=3e5+5;
vector<int>b,w;
int f[maxn],cnt[maxn],n,m;
int get(int x){
	return f[x]==x?x:f[x]=get(f[x]);
}
void merge(int u,int v){
	u=get(u),v=get(v);
	if(u!=v) f[u]=v;
}
void solve(){
	b.clear();
	w.clear();
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=n;i++) cnt[i]=0;
	while(m--){
		int u,v;
		scanf("%d%d",&u,&v);
		merge(u,v);
	}
	int now=0;
	for(int i=1;i<=n;i++)
		if(get(i)==i) now=i;
  	//选取 now 的同色节点作为白点集合
	for(int i=1;i<=n;i++){
		if(get(i)==now) b.push_back(i);
		else w.push_back(i);
	}
	if((w.empty()&&b.size()>1)||(b.empty()&&w.size()>1)){
		printf("No\n");
		return;
	}
	printf("Yes\n");
	if(b.empty()) swap(b,w);
	int p=b[0];
	for(int i=0;i<w.size();i++){
		printf("%d %d\n",p,w[i]);
		if(i==w.size()-1) p=w[i];
	}
	for(int i=1;i<b.size();i++)
		printf("%d %d\n",p,b[i]);
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--) solve();
	return 0;
}
```

---

## 作者：Tachibana_Kimika (赞：1)

### 题目解析

给定几个点对，要求构造一棵树，使得所有给定点对距离皆为 2.

首先我们发现，如果有一个点没被任何点对包含，我们直接把他拉出来当成根，做出一个菊花就可以了。

但是没有这么好的情况啊。我们随便钦定一个点当根，然后把其他的所有跟他在一个连通块里的，全部扔到这个树的第三层去。如果没有点了，那就是无解。

剩下所有点，就扔到第二层去，随便找一个第二层的点，作为第三层所有点的父亲即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;

struct node{
	int to,nxt;
}edge[N*2]; int head[N],cnt;
void add(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
}
void adde(int u,int v){
	add(u,v); add(v,u);
}

int ae[N][2];
int res;
int tmpdot[N],tot;

int vis[N];
void dfs(int u,int f,int hd){//找连通块，这个hd没用
	vis[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to; if(v==f||vis[v]) continue;
		dfs(v,u,hd); tmpdot[++tot]=v;//tmpdot为第三层的点
	}
}

void fake_main(){
	memset(head,0,sizeof head);
	cnt=0; res=0; tot=0;
	memset(vis,0,sizeof vis);
	
	int n,m; cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		adde(u,v);
	}
	dfs(1,0,1); int flag=0;
	for(int i=1;i<=n;i++){
		if(vis[i]==0){
			if(flag==0){
				for(int j=1;j<=tot;j++){
					ae[++res][0]=i;
					ae[res][1]=tmpdot[j];
				}
			}
			flag=1;
			ae[++res][0]=1;
			ae[res][1]=i;
		}
	}
	if(flag==0){
		cout<<"No\n"; return;
	}
	cout<<"Yes\n";
	for(int i=1;i<=res;i++){
		cout<<ae[i][0]<<" "<<ae[i][1]<<"\n";
	}
}

signed main(){
	ios::sync_with_stdio(false);
	int t; cin>>t;
	while(t--) fake_main();
}

/*
1
4 2
1 2
3 4
*/
```

---

## 作者：sbno333 (赞：1)

这道题是一道构造题。

我们考虑每一个事件都直接连边，发现为了让以后找到的方案仍能合法，可以设置一个种图，形如 $c_0\implies x_c,x_c\implies c_1,x\implies c_2\dots x\implies c_k$，其中 $x_c$ 表示用于 $c$ 中的一个不确定的点，可以看出这个图中**任意两个确定的点**距离为 $2$。

因此 $c$ 的顺序不重要，而有解当且仅当存在 $x\not\in c$。

由于顺序不重要并且 $c$ 中任意两点都合法，因此可以把 $c$ 看做一个集合。

那么我们可以通过并查集实现。

接着考虑 $x_c$，以及合并这些集合，显然可以在并查集后将时间全部处理后再次合并，并且仍然合法。

如果只剩一个集合，可以发现无法构造出 $x$，此时无解。

接着考虑两个集合，设第二个集合为 $d$，由于互不影响，因此可以使 $x_c=d_0,x_d=c_0$，该答案合法，即为解（此处其它构造方式也行，但这个方法做着认为会更好实现一些）。

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000009];
int getfa(int t){
	if(f[t]==t){
		return t;
	}
	return f[t]=getfa(f[t]);//此处压缩路径有大用
}
void merge(int u,int v){
	f[getfa(u)]=getfa(v);
}
void _main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){//初始化，如果 memset 可能会超时
		f[i]=i;
	}
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		merge(u,v);//并查集
	}
	int z;
	z=0;
	for(int i=1;i<=n;i++){
		getfa(i);//使得通过压缩路径让 f[i] 直接表示并查集中的根节点，可以不写，但后面的 f[x] 就要替换为 getfa(x)，
	}//我们将 f[i] 设为包含 i 的集合中编号为 0 的节点
	for(int i=1;i<=n;i++){
		if(f[i]!=f[n]){//f[n] 为其中一个集合的 0 号节点，寻找其它集合以求是否有解以及下一步操作
			z=f[i];//z 为某另一个集合的 0 号节点
			break;
		}
	}
	if(!z){//都是在一个集合，无法构造 x 无解
		cout<<"No"<<endl;
		return;
	}
	for(int i=1;i<n;i++){//将多余集合合并
		if(f[i]!=f[n]){
			merge(z,i);
		}
	}
	for(int i=1;i<=n;i++)
		getfa(i);
	z=f[z];//d[0]=f[z],c[0]=f[n]
	cout<<"Yes"<<endl;
	cout<<f[z]<<" "<<f[n]<<endl;
	for(int i=1;i<=n;i++){//输出答案
		if(i!=z&&i!=f[n]){
			if(f[i]==z){
				cout<<i<<" "<<f[n]<<endl;
			}else{
				cout<<i<<" "<<z<<endl;
			}
		}
	}
}
int main(){
	int t;
	cin>>t;
	while(t--){
		_main();//面对多组测试数据的好方法
	}
	return 0;
}
```

---

## 作者：Union_Find (赞：1)

# 题意

题意是说，给你 $m$ 对 $u,v$，求构造一棵树，满足 $u$ 到 $v$ 的最短路径为 $2$。

# 分析

由于是构造题，我们只考虑极端情况。树上距离为 $2$ 只有两种情况：父亲的父亲和兄弟。

我们尝试先将所有点往根上连，但是有些点要和根距离 $2$，所以将他们连到其他点上，成为根的孙子。但是又有些点要和孙子距离 $2$，所以可以和他成为兄弟。

这样一直下去，就可以满足了。

代码过丑，就不放了。

---

## 作者：_Flame_ (赞：1)

### $\text{solution}$

比较简单的构造题。

考虑点 $u_i$ 和点 $v_i$ 之间恰有两条边的限制意味着什么，发现这意味着点 $u_i$ 和点 $v_i$ 的父亲节点相同。

考虑用并查集将所有父节点相同的节点合并，这样可以得到若干个集合，显然，当只出现了一个集合时，构造无解。

接下来处理集合之间如何连边，发现对于一个集合 $S_i$ 我们将其中的点全部连向另一个集合 $S_j$ 中的一个点是合理的，于是对于所有不是 $S_j$ 的集合，我们都将其连到 $S_j$ 中的一个点上，对于 $S_j$ 中的其他点，将其连到任意点 $i$ 使得 $i$ 不在集合 $S_j$ 中即可。

### $\text{code}$

```cpp

int n,m;

int fa[maxn];
int siz[maxn];

int find(int a){
	if(fa[a]==a){
		return fa[a];
	}
	return fa[a]=find(fa[a]); 
}

void merge(int a,int b){
	int na=find(a),nb=find(b);
	if(na==nb){
		return ;
	}
	fa[na]=nb;
	siz[nb]+=siz[na];
}

map<int,int> mp;

int cnt[maxn],tot;

void solve(){
	for(int i=1;i<=n;i++){
		cnt[i]=0;
	}
	mp.clear();
	tot=0;
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		fa[i]=i;
		siz[i]=1;
	}
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		merge(u,v);
	}
	if(siz[find(1)]==n){
		puts("No");
		return ;
	}
	for(int i=1;i<=n;i++){
		if(!mp[find(i)]){
			mp[find(i)]=1;
			cnt[++tot]=find(i);
		}
	}
	puts("Yes");
	int flag=0;
	for(int i=1;i<=n;i++){
		if(find(i)!=cnt[1]){
			flag=i;
			break;
		}
	}
	for(int i=1;i<=n;i++){
		if(find(i)!=cnt[1]){
			printf("%lld %lld\n",i,cnt[1]);
		}
		else if(i==find(i)){
			continue ;
		}
		else{
			printf("%lld %lld\n",i,flag);
		}
	}
	return ;
}

```

---

## 作者：Lele_Programmer (赞：0)

# P10179 水影若深蓝 题解

一道非常不错的思维题！

## 题目分析

题目给出的若干组点，每一组点之间的简单路径必须刚好经过两条边，也就是说，在这条简单路径上，会经过另外一个点。

可以将给出的每一组点看作拥有同一个父节点的节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/v5fzn7ms.png)

所以，将每一组点进行连边，属于同一个连通块的节点放在同一层。对于每一个连通块，在下一个连通块中任选一个点，与当前连通块的全部点连边。对于最后一个连通块，即图中的红色节点，除去橙色节点已经选取的节点，其余节点向橙色的连通块的任意一个点连边，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/n2gtvem3.png)

## 代码实现

用前向星存图，比较方便快捷。

$v$ 数组用来记录每一个连通块里的点。

通过 `bfs` 获取每一个连通块的点。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=300005;
const int M=600005;

int T,n,m;
int e[M],ne[M],h[N],tot;

bool vis[N];
vector<int> v[N]; // 储存每一个连通块里的点
int cnt; // 连通块的数量

void add(int a,int b) {
    e[tot]=b,ne[tot]=h[a],h[a]=tot++;
}

void bfs(int s) { // find connected blocks
    queue<int> q;
    vis[s]=true;
    q.push(s);
    cnt++;
    v[cnt].push_back(s);
    while (!q.empty()) {
        int u=q.front(); q.pop();
        for (int i=h[u];~i;i=ne[i]) {
            if (!vis[e[i]]) {
                vis[e[i]]=true;
                q.push(e[i]);
                v[cnt].push_back(e[i]);
            }
        }
    }
}

int main() {
    scanf("%d",&T);
    while (T--) {
        scanf("%d %d",&n,&m);
        for (int i=1;i<=cnt;++i) v[i].clear();
        cnt=0;
        for (int i=1;i<=n;++i) h[i]=-1,vis[i]=0;
        while (m--) {
            int a,b;
            scanf("%d %d",&a,&b);
            add(a,b); add(b,a); // 无向图加双向边
        }
        for (int i=1;i<=n;++i) {
            if (!vis[i]) {
                bfs(i); // 没有查找过，就 bfs 一下
            }
        }
        if (cnt==1) { // 只有一个连通块，显然无解
            puts("No");
            continue;
        }
        puts("Yes"); // 否则有解
        for (int i=1;i<=cnt;++i) { // 枚举每一个连通块
            if (i!=cnt) { // 如果不是最后一个连通块
                for (int j=0;j<v[i].size();++j) { // 向下一个连通块的第一个点连边
                    printf("%d %d\n",v[i+1][0],v[i][j]);
                }
            } else { // 最后一个连通块
                for (int j=1;j<v[i].size();++j) { // 从第二个节点开始枚举，因为第一个已经被上一个连通块取走了
                    printf("%d %d\n",v[i][j],v[i-1][0]);
                }
            }
        }
    }
    return 0;
}
```

祝贺我赛时一遍 AC 此题！

---

## 作者：cppcppcpp3 (赞：0)

[Link](https://www.luogu.com.cn/problem/P10179)

构造题。

对于限制 $(u,v)$，不妨先收紧一点，认为是 $u,v$ 的父节点相同。于是对限制 $(u,v)$ 和限制 $(u,w)$，$v$ 和 $w$ 的父亲都与 $u$ 的相同，可以合并成一个集合 $S=\{u,v,w\}$，$S$ 中的点有相同的父节点。

这样最终会得到若干个集合 $S_i$。显然最终如果只有一个集合，不存在合法构造，因为没有点作为公共的父亲；否则考虑以下的构造方案：

- 先选出某个集合的某个点，不妨选择点 $1$，其所在集合为 $S_1$。把点 $1$ 作为这个公共的父亲。

- 将其它集合的每个点分别和点 $1$ 连边，这样其它集合的限制就满足了。

- 最后选出其它集合中的任意一点 $x$，把 $S_1$ 中除 $1$ 外的所有点分别和 $x$ 连边。这样满足了 $S_1$ 内所有点都通过 $x$ 互相联系。

最终形成的树如图所示：

![a](https://cdn.luogu.com.cn/upload/image_hosting/ivyltp5l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

实现上用并查集维护即可。

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int N=3e5+5;
const int inf=1e9+7;

inline int wrd(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1; c=getchar();}
	while(isdigit(c)){x=x*10+c-48,c=getchar();}
	return x*f;
}

int n,m,fa[N];
int find(int x){return x==fa[x] ? x : fa[x]=find(fa[x]);}
void unity(int x,int y){
	fa[find(x)]=find(y);	
}

vector<pii> as;

void solve(){
	n=wrd(),m=wrd(),as.clear();
	for(int i=1;i<=n;++i) fa[i]=i;
	for(int i=1;i<=m;++i){
		int u=wrd(),v=wrd();
		unity(u,v);
	}
	
	int c=0;
	
	for(int i=1;i<=n;++i) c+=(i==find(i));
	if(c<2) return puts("No"),void();
	
	c=0;
	
	for(int i=1;i<=n;++i){
		if(find(1)==find(i)) continue;
		as.push_back({1,i}),c=i;
	}
	for(int i=2;i<=n;++i){
		if(find(1)==find(i)) as.push_back({c,i});
	}
	puts("Yes");
	for(auto x:as) printf("%d %d\n",x.fi,x.se);
}

signed main(){
	int T=wrd();
	while(T--) solve();
	return 0;
}
```

---

## 作者：wangif424 (赞：0)

# 部分分

### Subtask5

$u_i=1$。

对于所有的 $v_i$，满足 $dis(1,v_i)=2$，那么考虑找一个点 $x$ 为中心建菊花图，如果存在可行的点 $x$，则有解，否则无解。

### Subtask6

$u_i \neq 1,v_i \neq 1$。

以 $1$ 为中心建菊花图即可。

~~剩下的部分分不会打~~。

# 正解

对每一组限制连边，跑`dfs`得出每个点所属于的连通块以及每个连通块大小。

因为每组限制 $(u_i,v_i)$ 满足在树上距离为 $2$，那么在我们建的图中属于一个连通块的点在树上的距离一定为偶数。

有上述结论可以得到 $(x,y),(y,z) \Leftrightarrow (x,y),(x,z)$。

于是所有的点被分成了两类：能和 $1$ 直接相连的以及不能的。

如果所有的点都不能与 $1$ 直接相连，那么此时无解。

对于能和 $1$ 直接相连的，则直接连 $1$。

对于不能的，在上面能和 $1$ 直接相连的点中任取一个相连就好。

# AC代码

```cpp
#include<bits/stdc++.h>
#define R(x) x=read()
using namespace std;
char pbuf[1<<20], *pp=pbuf;
void swap(int a,int b){a^=b^=a^=b;}
inline void push(const char &c){if(pp - pbuf == 1<<20)fwrite(pbuf, 1, 1<<20, stdout),pp = pbuf;*pp++ = c;}
class io{public:~io(){fwrite(pbuf, 1, pp - pbuf, stdout);}}_;
inline void write(int x) {
    if (x<0)x=-x,push('-');
    int sta[35],top=0;
    do{sta[top++]=x%10,x/=10;}while (x);
    while(top)push(sta[--top]^'0');
}
#ifndef LOCAL
    char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
    #define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
int t;
int n,m;
struct edge{
    int to,nxt;
}v[600100];
int len,fir[300100];
void add(int x,int y){
    ++len;
    v[len].to=y;
    v[len].nxt=fir[x];
    fir[x]=len;
}
int vis[300100];
int cnt[300100];
void clear(){
    len=0;
    memset(fir,0,sizeof(fir));
    memset(vis,0,sizeof(vis));
    memset(cnt,0,sizeof(cnt));
}
int x[300100],y[300100];
void dfs(int u,int fa,int c){
    if(vis[u])return;
    vis[u]=c;
    cnt[c]++;
    for(int i=fir[u];i;i=v[i].nxt){
        if(v[i].to==fa)continue;
        dfs(v[i].to,u,c);
    }
}
bool check(){
    for(int i=1;i<=n;i++){
        if(cnt[i]==n){
            push('N');
            push('o');
            push('\n');
            return 0;
        }
    }
    return 1;
}
signed main(){
    R(t);
    while(t--){
        clear();
        R(n);R(m);
        for(int i=1;i<=m;i++){
            R(x[i]);
            R(y[i]);
            add(x[i],y[i]);
            add(y[i],x[i]);
        }
        for(int i=1;i<=n;i++)if(!vis[i])dfs(i,0,i);
        if(check()){
            push('Y');push('e');push('s');push('\n');
            int pos=1;
            for(;pos<=n;pos++){
                if(vis[pos]!=1)break;
            }
            for(int i=1;i<=n;i++){
                if(vis[i]!=1){
                    write(1);push(' ');
                    write(i);push(' ');
                    push('\n');
                }
            }
            for(int i=2;i<=n;i++){
                if(vis[i]==1){
                    write(pos);push(' ');
                    write(i);push(' ');
                    push('\n');
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：是青白呀 (赞：0)

首先对于 $n=1$ 的情况，在题目限制下 $m$ 一定等于 $0$，此时直接输出 `Yes` 即可。（好像没有 $n=1$ 的数据？）

接下来考虑 $n\geq 2$ 的情况。考虑给一棵树黑白染色，则染色后的树上，所有距离为 $2$ 的点颜色一定相同，又当 $n\geq2$ 时，树上必定存在黑白两种不同颜色。

于是我们考虑建图，在 $u_i$ 和 $v_i$ 之间连边，则图上同一个连通块中的点在构造出来的树上的颜色一定相同。因此，我们可以得到一个有解的必要条件：建出的图中至少存在 $2$ 个连通块，否则所有的点在树上的颜色是一致的，显然构造不出这样的树。

接下来我们证明这个条件是充分的，也即给出在图中存在至少 $2$ 个连通块时的一组解。

我们发现在菊花中，两两叶子之间的距离都等于 $2$。于是我们任选一个点 $i$，对于所有与 $i$ 不在一个连通块内的点 $j$，都向 $i$ 连边，形成一朵以 $i$ 为中心的菊花。此时除 $i$ 所在连通块以外的所有连通块的限制都被满足。接下来任选一个与 $i$ 不在同一连通块内的点 $x$，将 $i$ 所在连通块内除 $i$ 以外的所有点都向 $x$ 连边，构成一朵以 $x$ 为中心的菊花。由于 $i$ 和 $x$ 之间的边已经存在，此时 $i$ 所在连通块内的限制也被满足。于是，我们成功构造出一组合法解。

因此我们直接判断连通块的个数，只有 $1$ 个连通块时无解，其余情况按照上文所述构造即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define lowbit(x) x&(-x)
#define mp make_pair
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;
typedef long long ll;
const int N=3e5+5,M=1e6+5,S=(1<<22)+5,mo=998244353,inf=1e9+7,bs=19491001;
const double eps=1e-8;
inline void read(int &p){
	int x=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
int T;
int n,m;
pii p[N];
struct edge{
	int to,nxt;
}e[2*N];
int fir[N],np,bel[N],cntb;
bool vis[N];
void add(int x,int y){
	e[++np]=(edge){y,fir[x]};
	fir[x]=np;
}
void dfs(int x){
	bel[x]=cntb,vis[x]=1;
	for(int i=fir[x];i;i=e[i].nxt){
		int j=e[i].to;
		if(vis[j])continue;
		dfs(j);
	}
}
void solve(){
	read(n),read(m);
    rep(i,1,n)
        vis[i]=0,fir[i]=bel[i]=0;
    np=cntb=0;
	rep(i,1,m){
	    int x,y;
	    read(x),read(y),add(x,y),add(y,x);
	}
	if(n==1){
		puts("Yes");
		return;
    }
	rep(i,1,n){
		if(vis[i])continue;
		cntb++,dfs(i);
	}
	if(cntb==1){
		puts("No");
		return;
	}
	puts("Yes");
	int oth=0;
	rep(i,1,n)
		if(bel[i]!=bel[1])oth=i,printf("%d %d\n",1,i);
	rep(i,2,n)
	    if(bel[i]==bel[1])printf("%d %d\n",oth,i);
}
signed main(){
	read(T);
	while(T--)
	    solve();
	return 0;
}
```

---

## 作者：yshpdyt (赞：0)

## 题意
对于一颗 $n$ 个点的树，给定 $m$ 条如下关系：对于给定的  $u,v$，满足 $u \to v$ 的树上唯一简单路径距离的为二，简单来说就是这两个结点之间隔了一个节点，构造出任意符合要求的树，或报告无解。

## Sol

对于每一条关系，用类似存无向图的方式记录，即 $u$ 连向所有与其隔一个点的结点。 

然后我们可以假设一个虚拟结点为 $t_1$，随便取一个结点 $u$，认为所有与 $u$ 存在关系的点 $v$，两点之间恰好相隔 $t_1$，也就是如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/l7bhex0b.png)

这样做的好处就是保证了 $u$ 的关系都得到满足，并且不会破坏 其余 $v$ 的关系。

接着我们考虑所有 $v$ 的关系，用与刚才类似的方法进行构造，不难得到下图。
![](https://cdn.luogu.com.cn/upload/image_hosting/247qovqb.png)

像这样类似拓扑排序的进行下去，用队列维护，每次取出队首，把所有与队首有关系的结点都让其与 $t_1$ 相连，然后加入队列，重复操作，直到队列为空，这样可以构造出一颗菊花图。

但是这样的操作还存在两个缺陷，有的关系还没有在图上体现， $t_1$ 结点还不确定。

如何解决？我们可以再构造多个菊花图，对于两个**不在同一个图上的点**，他们之间**没有关系，互不影响**：
![](https://cdn.luogu.com.cn/upload/image_hosting/kgdendyr.png)
 
注意加黑的点，我们可以让 $t_1$ 变成 $x$，让 $t_2$ 变成 $u$ 合并一下：
![](https://cdn.luogu.com.cn/upload/image_hosting/xqjjiz4g.png)

对于其他的虚拟结点，只需要让 $t_3,t_4,t_5$ 都等于 $t_1$ 即可，也就是图中的 $x$，这里不再放图，自行想象 $x$ 左右还连着若干对点。

没有任何关系的点也可以与 $x$ 相连。

这样的正确性显然，两个图之间的点不存在任何关系，合并图只是让虚拟结点变成实际的结点，选用一个毫不相干的点作为其核心结点，当然不受影响。

对于无解情况，如果所有点都与 $t_1$ 相连，那么无法找到 $t_2$ ，也就是另一个菊花图，从而导致没有点可以代替 $t_1$，导致无解。

**考虑一下代码如何实现。**

初始化所有 $res[u]=0$，认为所有结点都为孤立点。

取任意结点作为 $t_1$ ，设虚拟结点为 $t_2$，用类似拓扑排序的方式把所有有关结点都与 $t_2$ 相连，因为不知道 $t_2$，可以令 $res[u]=2$ 。

遍历所有结点，如果该结点还没有与 $t_2$ 相连，让该结点成为 $t_2$，重复刚才类似拓扑排序的操作，把所有有关结点都与 $t_1$ 相连，可以令 $res[u]=1$ 。

特别的，如果所有结点都与 $t_2$ 相连，那么无解。

最后输出，如果 $res[u]=2$，输出 $(u,t_2)$，如果 $res[u]\le 1$ 输出 $(u,t_1)$，特别的，注意到 $res[t_2]=1$ 且 $res[t_1]=2$，这样会输出两次，特判去掉即可，刚好 $n-1$ 次。 

本题的核心思路在于想到菊花图，并且进行合并。

单次时间复杂度 $O(n+m)$。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 400005
#define endl "\n" 
#define fi first
#define se second
using namespace std;
const ll mod=1e9+7;
const ll inf=1e18;
const double eps=1e-6;
ll n,m,res[N],tr[3];
bool vis[N];
vector<ll>v[N];
queue<ll>q;
void sol(){
    cin>>n>>m;
    tr[1]=tr[2]=0;
    for(int i=1;i<=n;i++){
        v[i].clear();
        vis[i]=0;
        res[i]=0;
    }
    while(!q.empty())q.pop();
    for(int i=1;i<=m;i++){
        ll x,y;
        cin>>x>>y;
        v[x].push_back(y);
        v[y].push_back(x);
    }
    bool fl=1;
    for(int i=1;i<=n;i++){
        if(!tr[1]){
            tr[1]=i;
            break;
        }
    }
    q.push(tr[1]);
    res[tr[1]]=2;
    while(!q.empty()){
        auto t=q.front();
        q.pop();
        vis[t]=1;
        for(auto y:v[t]){
            if(!vis[y]){
                q.push(y);
                res[y]=2;
            }
        }
    }
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            tr[2]=i;
            break;
        }
    }
    if(!tr[2]){
        cout<<"No\n";
        return ;
    }
    q.push(tr[2]);
    res[tr[2]]=inf;
    while(!q.empty()){
        auto t=q.front();
        q.pop();
        vis[t]=1;
        for(auto y:v[t]){
            if(!vis[y]){
                q.push(y);
                res[y]=1;
            }
        }
    }
    cout<<"Yes\n";
    for(int i=1;i<=n;i++){
        if(res[i]<=2){
            if(res[i]==0)res[i]=1;
            cout<<i<<" "<<tr[res[i]]<<endl;
        }
    }
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    ll ttt;
    cin>>ttt;
    while(ttt--)sol();
    return 0;
}

```

---

## 作者：Fantasy_Segment_Tree (赞：0)

## 题意

你要构造一颗 $n$ 个点的树，使得在树上所有输入的 $(u, v)$ 点对在树上的距离为 $2$。

## 思路

首先，我们可以先求出每一个点在哪一个点集合里，这一步可以使用并查集。

对于只有一个集合的情况，每相邻两个节点的距离都是2，不可能实现，输出 `No`。

其次，距离为 $2$ 的点只有爷爷和孙子或者兄弟。

所以我们可以先取出一个集合中的根节点，随后把其他集合的所有点都与这个点相连，这样就解决了其他集合（兄弟），随后找一个其他集合的点，把所有这个集合中的点全部与这个点相连，这样就解决了这个集合（爷爷和孙子）。

边连边输出即可。

## 代码

```cpp
#include <iostream>
using namespace std;

int T, n, m, fa[300005], cnt[300005], jl[300005], flag;

int find(int x) {
	if(fa[x] == x) return x;
	else return fa[x] = find(fa[x]);
}

void init() {
	for(int i = 1; i <= n; i++) fa[i] = i;
	for(int i = 1; i <= n; i++) jl[i] = 0;
}

int main() {
	cin >> T;
	while(T--) {
		cin >> n >> m;
		init();
		int flag = 0;
		for(int i = 1; i <= m; i++) {
			int u, v;
			cin >> u >> v;
			int x = find(u), y = find(v);
			if(x != y) {
				fa[x] = y;
			} else {
				flag = 1;
			}
		}
		for(int i = 1; i <= n; i++) jl[find(i)]++;
		int fla = 0, cnt = 0;
		for(int i = 1; i <= n; i++) {
			if(jl[i]) {
				fla = i;
				cnt++;
			}
		}
		if(cnt == 1) {
			cout << "No\n";
			continue;
		}	
		int flagg = 1;
		while (find(flagg) == find(fla)) flagg++;
		cout << "Yes\n";
		for(int i = 1; i <= n; i++) {
			if(find(i) != fla) {
				cout << fla << " " << i << endl;
			}
		}
		for(int i = 1; i <= n; i++) {
			if(find(i) == fla && i != fla) {
				cout << flagg << " " << i << endl;
			}
		}
	}
}
```

---


# [COCI 2023/2024 #4] Roboti

## 题目背景

**译自 [COCI 2023/2024 Contest #4](https://hsin.hr/coci/archive/2023_2024) T5「[Roboti](https://hsin.hr/coci/archive/2023_2024/contest4_tasks.pdf)」**

## 题目描述

Kile 是一个桌游爱好者，他最近发现了一个叫做 Robots 的游戏。这个游戏由一个 $n$ 行 $m$ 列的网格和一个机器人组成。位置 $(1, 1)$ 是棋盘的左上角，位置 $(n, m)$ 是右下角。

开始时，机器人位于某个位置 $(x, y)$（第 $x$ 行，第 $y$ 列），玩家可以将其朝上下左右之一的方向进行移动。根据选择的方向，它将沿着该方向移动，直到到达目标格或网格中的特殊格。如果在任何时候机器人想要离开棋盘，它将翻折到另一侧。例如，如果它位于位置 $(n, 3)$ 并希望向下移动，它将到达位置 $(1, 3)$。

棋盘上有三种类型的位置：

- 空格：机器人朝相同的方向继续移动；
- 左转格：当机器人进入此格时，它会左转 $90$ 度并继续移动；
- 右转格：当机器人进入此格时，它会右转 $90$ 度并继续移动。

网格中大部分位置都是空格，只有 $k$ 个位置是左转或右转格。

游戏由 $q$ 轮组成。在第 $i$ 轮中，机器人将被放置在位置 $(a_i, b_i)$。目标是使用最少的转弯次数到达位置 $(c_i, d_i)$，或判定这是不可能的。

在多次玩这个游戏后，Kile 意识到它比起初看起来要更具挑战性。这就是为什么他现在需要你的帮助。帮助他确定每一轮游戏所需的最小转弯次数！

**注意**：如果机器人路径的起点或终点位于左转或右转格上，则该格不起作用。

## 说明/提示

### 样例解释 2

第一轮：从 $(1, 1)$ 开始。如果初始机器人向左移动，它将在下一步到达 $(1, 3)$，因为它想要离开棋盘，所以会从另一侧进入。位置 $(1, 3)$ 是一个左转格，所以机器人将朝下方向移动。再经过两步，它将到达目标位置 $(3, 3)$​。

第二轮：从 $(3, 3)$ 开始。如果初始机器人向上移动，它将在两步后到达 $(1, 3)$，在那里由于左转格而向左转。再经过两步，它将到达位置 $(1, 1)$，这也是一个左转格，所以它将向下移动。在下一步中，它将到达目标位置 $(2, 1)$。

### 子任务

| 子任务编号 |       附加限制       | 分值 |
| :--------: | :------------------: | :--: |
|    $1$     |        $k=0$         | $10$  |
|    $2$     | $n,m\le 300,q\le 10$ | $13$ |
|    $3$     |     $n,m\le 300$     | $49$ |
|    $4$     |      无附加限制      | $38$ |

## 样例 #1

### 输入

```
2 2 2
1 1 L
2 2 R
5
1 1 2 2
2 1 1 2
1 1 1 2
2 1 1 1
2 2 2 1
```

### 输出

```
-1
1
0
0
0
```

## 样例 #2

### 输入

```
3 3 4
1 1 L
1 3 L
2 1 L
3 3 L
7
1 1 3 3
3 3 2 1
3 1 2 2
2 3 1 2
2 3 3 1
1 2 3 2
3 3 2 2
```

### 输出

```
1
2
1
1
1
0
3
```

## 样例 #3

### 输入

```
4 4 8
1 1 R
1 3 L
2 2 R
2 4 L
3 1 L
3 3 L
4 2 L
4 4 L
7
1 2 1 4
2 2 3 4
4 4 3 2
4 1 4 4
4 2 3 1
1 2 2 3
2 4 2 3
```

### 输出

```
2
1
1
0
-1
5
0
```

# 题解

## 作者：Add_Catalyst (赞：3)

# P10232 [COCI 2023/2024 #4] Roboti 题解

---

## 知识点

简单环，DFS。

---

## 题意分析

在 $n$ 行，$m$ 列的网格里，给定 $k$ 个转弯点，再给定 $Q$ 个询问，问每次从某个坐标到另一个坐标的最少转弯次数，或者判断不可能到达。

---

## 思路分析

我们发现在一个点坐标与方向确定的时候，到达的下一个点的坐标与方向一定确定，那我们把每个转弯点拆成四个方向不同的点，分别判断，那么整个图就变成了一堆简单环，那么两个点的距离就很容易得到，判断合法也只要看是不是在一个环里即可。

---

## CODE

```cpp
#include<bits/stdc++.h>
#define Fi first
#define Se second
#define endl '\n'
#define INF 0x3f3f3f3f
#define Pii pair<int,int>
#define All(a) begin(a),end(a)
#define tomax(a,b) ((a)=max((a),(b)))
#define tomin(a,b) ((a)=min((a),(b)))
#define FOR(i,a,b) for(register int i=(a);i<=(b);++i)
#define DOR(i,a,b) for(register int i=(a);i>=(b);--i)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0);return Main();}signed Main
using namespace std;
constexpr int N=1e5+10,M=1e6+10,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
bool ti[N];
bool vis[N][4];
int n,m,k,Q,cnt;
int x[N],y[N],siz[N<<2];
int id[N][4],dep[N][4];
Pii p[4][2],fa[N][4];
vector< Pii > X[M],Y[M];
int nxt(int x,int y,int d){
	Pii cur={d&1?x:y,d<2?INF:0};
	auto it=d&1?lower_bound(All(Y[y]),cur):lower_bound(All(X[x]),cur);
	auto it1=d&1?Y[y].begin():X[x].begin(),it2=d&1?Y[y].end():X[x].end();
	if(d<2)swap(it1,it2);
	if(it==it1)it=it2;
	if(it==it1)return -1;
	if(d>1)--it;
	return it->Se;
}
void dfs(int u,int d){
	Pii v=fa[u][d];
	vis[u][d]=1,id[u][d]=cnt,++siz[cnt];
	if(~v.Fi&&!vis[v.Fi][v.Se])dep[v.Fi][v.Se]=dep[u][d]+1,dfs(v.Fi,v.Se);
}
int dis(Pii a,Pii b){
	if(id[a.Fi][a.Se]!=id[b.Fi][b.Se])return INF;
	return (dep[b.Fi][b.Se]-dep[a.Fi][a.Se]+siz[id[a.Fi][a.Se]])%siz[id[a.Fi][a.Se]];
}
signed main(){
	cin>>n>>m>>k;
	FOR(i,1,k){
		char c;
		cin>>x[i]>>y[i]>>c,ti[i]=(c=='L'),X[x[i]].push_back({y[i],i}),Y[y[i]].push_back({x[i],i});
	}
	FOR(i,1,n)sort(All(X[i]));
	FOR(i,1,m)sort(All(Y[i]));
	FOR(i,1,k)FOR(d,0,3){
		int _d=ti[i]?(d+3)%4:(d+1)%4;
		fa[i][d]={nxt(x[i],y[i],_d),_d};
	}
	FOR(i,1,k)FOR(d,0,3)if(!vis[i][d])++cnt,dfs(i,d);
	cin>>Q;
	while(Q--){
		int xa,ya,xb,yb,ans=INF;cin>>xa>>ya>>xb>>yb;
		FOR(d,0,3)p[d][0]={nxt(xa,ya,d),d},p[d][1]={nxt(xb-dx[d],yb-dy[d],d),d};
		FOR(d,0,3)if(~p[d][0].Fi)FOR(_d,0,3)if(~p[_d][1].Fi)tomin(ans,dis(p[d][0],p[_d][1]));
		if(xa==xb&&X[xa].empty()||ya==yb&&Y[ya].empty())ans=0;
		cout<<(ans<INF?ans:-1)<<endl;
	}
	return 0;
}
/*
首先，拆点，把每个转折点拆成 4 个方向，然后我们发现，如果一个点有出入度，那么必定是一个出度和一个入度，
所以问题就转化为了一堆简单环上判断距离，直接求解即可。
*/
```

---

---

## 作者：hank0402 (赞：1)

被这题硬控 1.5h，写个题解纪念一下。

这个左转右转的套路应该是比较典的。尝试把每个点根据走出的方向拆成四个点，并尝试进行建图。根据题意，通过每一个方向进入一个点后会唯一对应一种出来的方向。从一个点出来后到达的下一个点和方向是唯一的，所以每个点的出度是 $1$，相应的，每个点和方向对应唯一一种到达这个点的点和方向，所以入度也是 $1$。因此这个图是由若干环构成的。

可以通过枚举从起点出去的方向和进入终点的点和方向把原问题转化为是否可达和最短路径。只要判断是否处于同一个环上，而对于同处于一个环上的两点求最短路径是好做的。

实现上可以对于所有点，分为 $x$ 相同的点集和 $y$ 相同的点集，从而对每个方向分类讨论算出从每个点出去所到达的点。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};
int lt[4] = {2, 3, 1, 0}, rt[4] = {3, 2, 0, 1};
int n, m, k, q;
pair<int, int> ps[N];
vector<pair<int, int>> vx[N], vy[N], e[N][4];
char d[N];
int nextId(int x, int y, int dir)
{
    if (dir == 0)
    {
        auto it = lower_bound(vy[y].begin(), vy[y].end(), pair<int, int>(x, 0));
        if (it == vy[y].begin())
            it = vy[y].end();
        if (it == vy[y].begin())
            return -1;
        --it;
        return (*it).second;
    }
    if (dir == 1)
    {
        auto it = lower_bound(vy[y].begin(), vy[y].end(), pair<int, int>(x, 2e9));
        if (it == vy[y].end())
            it = vy[y].begin();
        if (it == vy[y].end())
            return -1;
        return (*it).second;
    }
    if (dir == 2)
    {
        auto it = lower_bound(vx[x].begin(), vx[x].end(), pair<int, int>(y, 0));
        if (it == vx[x].begin())
            it = vx[x].end();
        if (it == vx[x].begin())
            return -1;
        --it;
        return (*it).second;
    }
    if (dir == 3)
    {
        auto it = lower_bound(vx[x].begin(), vx[x].end(), pair<int, int>(y, 2e9));
        if (it == vx[x].end())
            it = vx[x].begin();
        if (it == vx[x].end())
            return -1;
        return (*it).second;
    }
}
int vis[N][4], bel[N][4], sz[N], col, dep[N][4];
void dfs(int x, int dir)
{
    vis[x][dir] = 1, bel[x][dir] = col, sz[col]++;
    for (auto [y, ddir] : e[x][dir])
    {
        if (vis[y][ddir])
            continue;
        dep[y][ddir] = dep[x][dir] + 1, dfs(y, ddir);
    }
}
int dist(pair<int, int> p1, pair<int, int> p2)
{
    auto [x, d1] = p1;
    auto [xx, d2] = p2;
    if (bel[x][d1] != bel[xx][d2])
        return -1;
    int c = bel[x][d1];
    return (dep[xx][d2] - dep[x][d1] + sz[c]) % sz[c];
}
signed main()
{
    cin >> n >> m >> k;
    for (int i = 1, x, y; i <= k; ++i)
        cin >> x >> y >> d[i], vx[x].push_back({y, i}), vy[y].push_back({x, i}), ps[i] = {x, y};
    for (int i = 1; i <= max(n, m); ++i)
        sort(vx[i].begin(), vx[i].end()), sort(vy[i].begin(), vy[i].end());
    for (int i = 1; i <= k; ++i)
    {
        for (int dir = 0; dir < 4; ++dir)
        {
            auto [x, y] = ps[i];
            int nxt = (d[i] == 'L') ? lt[dir] : rt[dir];
            e[i][dir].push_back({nextId(x, y, nxt), nxt});
        }
    }
    for (int i = 1; i <= k; ++i)
    {
        for (int dir = 0; dir < 4; ++dir)
        {
            if (!vis[i][dir])
                ++col, dfs(i, dir);
        }
    }
    cin >> q;
    while (q--)
    {
        int x, y, xx, yy, mn = 2e9;
        cin >> x >> y >> xx >> yy;
        vector<pair<int, int>> st, ed;
        for (int dir = 0; dir < 4; ++dir)
        {
            if (~nextId(x, y, dir))
                st.push_back({nextId(x, y, dir), dir});
            if (~nextId(xx - dx[dir], yy - dy[dir], dir))
                ed.push_back({nextId(xx - dx[dir], yy - dy[dir], dir), dir});
        }
        for (auto [p1, d1] : st)
        {
            for (auto [p2, d2] : ed)
            {
                int dis = dist({p1, d1}, {p2, d2});
                if (~dis)
                    mn = min(mn, dis);
            }
        }
        if ((x == xx && vx[x].empty()) || (y == yy && vy[y].empty()))
            mn = 0;
        cout << ((mn >= 2e9) ? (-1) : mn) << '\n';
    }
    return 0;
}
```

---

## 作者：qwer6 (赞：0)

[Link](https://www.luogu.com.cn/problem/P10232)

## 1. Description

在一个 $n\times m$ 的棋盘上，有 $k$ 个格子是特殊格子，当移动到这些格子上的时候，会向一个指定方向转动，然后按照当前方向移动，当将要移动到棋盘外时，将到达棋盘的另一侧。

现在给定 $q$ 个询问 $(a,b,c,d)$，询问 $(a,b)$ 到达 $(c,d)$ 需要的最小转弯次数。

## 2. Solution

首先暴力可以直接对于每一个询问暴力 bfs，这个时候我们有一个重要的做法，也就是将**当前行进的方向**作为一维记入 bfs 的状态中。

这是显然的，因为当我们以一个不同的方向到达一个相同的格子，它将到达的下一个格子显然不同。

此时我们延续这一思想，将每一个关键点拆成 $4$ 个不同的点，分别对应以上下左右的方向**离开**这个点的状态，那么每一个点，显然有且只有一条出边，指向它将达到的下一个**唯一确定**的状态。

同时存在一个朴素结论，每一个点都将会有且仅有一条入边，这条入边**必定**存在。

证明十分容易，首先证明每一个点最多只有一条入边。

考虑对于一个状态 $(x,y,d)$，根据离开这个点的方向，我们可以倒推出到达这个点的方向，然后按照这个方向往回找，一定可以找到一个点，因为往回倒退一圈可以倒回自己的另一个状态，而我们找到这个位置 $(x^{\prime},y^{\prime},d^{\prime})$ 后，这个方向上的其他所有点，都会在到达 $(x,y,d)$ 之前，到达 $(x^{\prime},y^{\prime})$ 这个点的其他状态，然后偏移向其他方向。

从而，由于所有点都有出边，而每一个点最多只有一条入边，所以每一个点都有入边。

这样，我们可以得到这张图将由若干个简单环构成，因此我们可以预处理出所有环。

此时在询问时，我们可以求出 $(a,b)$ 分别向四个方向走可以到达的下一个状态，和可以到达 $(c,d)$ 所有状态，这样的状态最多分别有 $4$ 个，然后通过记录下的环计算这些状态之间的距离，也就是一个简单的环上求距离的问题，当然，要特判无需转弯即可到达的情况。

## 3. Code

```c++
/*by qwer6*/
/*略去缺省源与快读快写*/
const int N=1e6+5,M=1e5+5,inf=0x3f3f3f3f;
int n,m,k,q,tot;
int pos[M<<2],len[M<<2],bel[M<<2],x[M],y[M];
bool kind[M],vis[M<<2];
vector<pii>Row[N],Line[N];
/*
对应的点: idx+k*dir 
向下 : x+1 0
向右 : y+1 1
向上 : x-1 2
向左 : y-1 3 
*/
int find(int x,int y,int dir){
	if(dir==0){//x+1
		if(Line[y].size()==0)return -1;
		auto it=upper_bound(Line[y].begin(),Line[y].end(),pii{x+1,0});
		if(it==Line[y].end())it=Line[y].begin();
		return it->second;
	}else if(dir==1){//y+1
		if(Row[x].size()==0)return -1;
		auto it=upper_bound(Row[x].begin(),Row[x].end(),pii{y+1,0});
		if(it==Row[x].end())it=Row[x].begin();
		return it->second;
	}else if(dir==2){//x-1
		if(Line[y].size()==0)return -1;
		auto it=upper_bound(Line[y].begin(),Line[y].end(),pii{x,0});
		if(it==Line[y].begin())it=Line[y].end();
		return (--it)->second;
	}else{//y-1
		if(Row[x].size()==0)return -1;
		auto it=upper_bound(Row[x].begin(),Row[x].end(),pii{y,0});
		if(it==Row[x].begin())it=Row[x].end();
		return (--it)->second;
	}
}
int turn(int dir,int opt){
	if(opt==1){
		if(dir==0)return 3;
		return dir-1;
	}else{
		if(dir==3)return 0;
		return dir+1; 
	}
}
int cal(int s,int t){
	int poss=pos[s],post=pos[t];
	if(poss<=post)return post-poss;
	return len[bel[s]]+post-poss;
}
int search(int x,int y){
	auto it=lower_bound(Row[x].begin(),Row[x].end(),pii{y,0});
	if(it==Row[x].end())return -1;
	if(it->first==y)return it->second;
	return -1;
}
bool check1(int x,int y1,int y2){
	if(y1>y2)swap(y1,y2);
	int idx=find(x,y1,1);
	if(idx==-1)return true;
	if(y[idx]<=y1||y[idx]>=y2)return true;
	idx=find(x,y1,3);
	if(idx==-1)return true;
	if(y1<=y[idx]&&y[idx]<=y2)return true;
	return false;
}
bool check2(int y,int x1,int x2){
	if(x1>x2)swap(x1,x2);
	int idx=find(x1,y,0);
	if(idx==-1)return true;
	if(x[idx]<=x1||x[idx]>=x2)return true;
	idx=find(x1,y,2);
	if(idx==-1)return true;
	if(x1<=x[idx]&&x[idx]<=x2)return true;
	return false;
}
signed main(){
	read(n),read(m),read(k);
	char opt;
	for(int i=1;i<=k;i++){
		read(x[i]),read(y[i]);
		opt=getchar();
		while(opt!='L'&&opt!='R')opt=getchar();
		kind[i]=(opt=='R');
		Row[x[i]].push_back({y[i],i});
		Line[y[i]].push_back({x[i],i});
	}
	for(int i=1;i<=n;i++)sort(Row[i].begin(),Row[i].end());
	for(int i=1;i<=m;i++)sort(Line[i].begin(),Line[i].end());
	for(int i=1,now,dir,idx;i<=k*4;i++){
		if(vis[i])continue;
		tot++,dir=(i-1)/k,now=i-dir*k,idx=i;
		while(!vis[idx]){
			pos[idx]=(++len[tot]),vis[idx]=1,bel[idx]=tot;
			now=find(x[now],y[now],dir);
			dir=turn(dir,kind[now]);
			idx=dir*k+now;
		}
	}
	read(q);
	int tmp1[4],tmp2[4]; 
	for(int i=1,a,b,c,d,ans,idx,cnt1,cnt2,add;i<=q;i++){
		read(a),read(b),read(c),read(d);
		idx=search(a,b);
		if(a==c&&check1(a,b,d)){
			puts("0");
			continue;
		}
		if(b==d&&check2(b,a,c)){
			puts("0");
			continue;
		}
		add=0;
		if(~idx){
			cnt1=4;
			for(int dir=0;dir<4;dir++)
				tmp1[dir]=idx+dir*k;
		}else{
			add++,cnt1=0;
			for(int dir=0,to,todir;dir<4;dir++){
				to=find(a,b,dir);
				if(to==-1)continue;
				todir=turn(dir,kind[to]);
				tmp1[cnt1++]=todir*k+to;
			}
		}
		idx=search(c,d);
		if(~idx){
			add--,cnt2=4;
			for(int dir=0;dir<4;dir++)
				tmp2[dir]=idx+dir*k;	
		}else{
			cnt2=0;
			for(int dir=0,to,todir;dir<4;dir++){
				to=find(c,d,dir);
				if(to==-1)continue;
				todir=(dir>=2?dir-2:dir+2);
				tmp2[cnt2++]=todir*k+to;
			}
		}
		ans=0x3f3f3f3f;
		for(int j=0;j<cnt1;j++){
			for(int k=0;k<cnt2;k++){
				if(bel[tmp1[j]]!=bel[tmp2[k]])continue;
				tomin(ans,cal(tmp1[j],tmp2[k])+add);
			}
		}
		if(ans==inf)puts("-1");
		else write(ans),Nxt;
	}
}
```

---


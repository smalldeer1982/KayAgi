# [GESP样题 八级] 小杨的旅游

## 题目描述

小杨准备前往 B 国旅游。

B 国有 $n$ 座城市，这 $n$ 座城市依次以 $1$ 至 $n$ 编号。城市之间由 $n-1$ 条双向道路连接，任意两座城市之间均可达（即任意两座城市之间存在可达的路径）。

小杨可以通过双向道路在城市之间移动，通过一条双向道路需要 $1$ 单位时间。

B 国城市中有 $k$ 座城市设有传送门。设有传送门的城市的编号依次为 $b_1,b_2, \cdots ,b_k$。小杨可以从任意一座设有传送门的城市花费 $0$ 单位时间前往另一座设有传送门的城市。

注：如果两座设有传送门的城市之间存在双向道路，那么小杨可以选择通过双向道路移动，也可以选择通过传送门传送。

小杨计划在 B 国旅游 $q$ 次。第 $i$ 次旅游（$1 \le i \le q$），⼩杨计划从编号为 $u_i$ 的城市前往编号为 $v_i$ 的城市，小杨希望你能求出所需要的最短时间。

## 说明/提示

| 子任务 | 分值 | $n \leq $ | $ k \leq $ | $q \leq $ |
|:-: | :-: | :-: | :-: | :-:|
| $1$ | $30$ | $500$ | $500$ | $1$ |
| $2$ | $30$ | $2 \times 10^5$ | $0$ | $2 \times 10^5$ |
| $3$ | $40$ | $2 \times 10^5$ | $2 \times 10^5$ | $2 \times 10^5$ |

对全部的测试数据，$1 \leq n \leq 2 \times 10^5$，$0 \leq k \leq n$，$1 \leq x_i, y_i, u_i, v_i \leq n$，$u_i \neq v_i$。

## 样例 #1

### 输入

```
7 2 1
5 7
3 6
2 3
1 5
5 4
1 2
7 4
3 7
```

### 输出

```
4```

## 样例 #2

### 输入

```
5 0 3
2 3
5 1
5 2
1 4
4 5
1 4
4 3
```

### 输出

```
2
1
4```

# 题解

## 作者：___Furina___ (赞：43)

### 题意简述：
无。
### 题解：
[此处阅读体验更佳？](https://www.luogu.com.cn/article/np19hdv0)

看完题目之后，我们首先要考虑一个问题：什么时候要用到传送门？

对于树上的两个点 $x$ 和 $y$，如果不考虑传送门的话，最短距离就是这两个点到它们的最近公共祖先的距离和。

那么如果用传送门更优，那么肯定满足这一个条件：**$x$ 到它最近的传送门距离加上 $y$ 到它最近的传送门距离小于 $x$ 和 $y$ 到它们的最近公共祖先的距离和。**

大家可以自己验证一些普通和特殊情况，此处就不给出证明了。

那么我们就可以先求出每个点到最近的传送门距离 $op_i$，对于询问，再输出 $\min(op_x+op_y,dep_x-dep_{lca(x,y)}+dep_y-dep_{lca(x,y)})$。

那么就可以写代码了。

注意：
- 可能没有传送门（代码中注释 A）。

代码如下：

```cpp
#include<bits/stdc++.h>
#define N 200100
#define I_love_Furina return//发电+放抄袭（?）
#define forever 0
#define foreverr 1 
#define int long long
using namespace std;
int n,T,m,q,head[N],op[N],num,f[N][20],dep[N];
struct node{int to,nxt;}a[N*2];
inline void add(int u,int v){a[++num].to=v,a[num].nxt=head[u],head[u]=num;}
inline void solve(){//求最近传送阵距离
	queue<int> q;
	for(int i=1,x;i<=m;i++)cin>>x,q.push(x),op[x]=0;//把所有的传送阵位置压入队列，跑bfs
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=a[i].nxt){
			int v=a[i].to;
			if(op[v]!=-1)continue;//避免重复遍历
			op[v]=op[u]+1,q.push(v);
		}
	}
	I_love_Furina ;
}
void dfs(int x,int fa){
	f[x][0]=fa,dep[x]=dep[fa]+1;
	for(int i=1;i<=19&&f[f[x][i-1]][i-1];i++)f[x][i]=f[f[x][i-1]][i-1];//计算祖宗
	for(int i=head[x];i;i=a[i].nxt)if(a[i].to!=fa)dfs(a[i].to,x);
	I_love_Furina ;
} 
inline int lca(int x,int y){//求最近公共祖先
	if(dep[x]<dep[y])swap(x,y);
	for(int i=19;i>=0;i--)if(dep[f[x][i]]>=dep[y])x=f[x][i];
	if(x==y)I_love_Furina x;
	for(int i=19;i>=0;i--)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
	I_love_Furina f[x][0];//注意，是返回x的父亲
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1,u,v;i<n;i++)cin>>u>>v,add(u,v),add(v,u),op[i]=op[i+1]=-1;
	dfs(1,0),solve();//跑lca和最近传送阵距离
	while(q--){
		int x,y;
		cin>>x>>y;
		int LCA=lca(x,y);
		//cout<<lca(x,y)<<" "<<op[x]<<" "<<op[y]<<endl;
		cout<<min(dep[x]-dep[LCA]+dep[y]-dep[LCA],(op[x]==-1||op[y]==-1?3156781267:op[x]+op[y]))<<endl;//A:防止输出-2
	}
	I_love_Furina forever;
}

```

完结撒花咯（点个赞再走）。

---

## 作者：spfa_ (赞：20)

[P10289 [GESP样题 八级] 小杨的旅游](https://www.luogu.com.cn/problem/P10289)

### 题目分析

先考虑 $k=0$ 的情况。此时相当于求树上任意两点之间的距离，这我们可以求 lca，然后用深度差算一下即可算出高度，代码如下：

```cpp
void dfs(int x, int fa) {
	d[x] = d[fa]+1, f[x][0] = fa;
	for (int i = 1; i <= 18; ++i) f[x][i] = f[f[x][i-1]][i-1];
	for (int y:E[x]) if (y != fa) dfs(y, x);
}

int lca(int x, int y) {
	if (d[x] < d[y]) swap(x, y);
	for (int i = 18; ~i; --i) if (d[f[x][i]] >= d[y]) x = f[x][i];
	if (x == y) return x;
	for (int i = 18; ~i; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}

//路径长为d[x]+d[y]-2*d[lca(x,y)]
```

然后就是有传送门的情况了，小杨一定会选择走到与 $u$ 最近的传送门，然后传送到与 $v$ 最近的传送门，最后走到 $v$。这里我们可以用 bfs 预处理出每个点与离自己最近的传送门。当然走传送门的路不一定最短，也有可能直接走到 $v$，所以两种方案取 $\min$ 即可。

### 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

const int N = 2e5+5;
int n, k, m, d[N], dis[N], f[N][19];
queue <int> q;
vi E[N];

void dfs(int x, int fa) {
	d[x] = d[fa]+1, f[x][0] = fa;
	for (int i = 1; i <= 18; ++i) f[x][i] = f[f[x][i-1]][i-1];
	for (int y:E[x]) if (y != fa) dfs(y, x);
}

int lca(int x, int y) {
	if (d[x] < d[y]) swap(x, y);
	for (int i = 18; ~i; --i) if (d[f[x][i]] >= d[y]) x = f[x][i];
	if (x == y) return x;
	for (int i = 18; ~i; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}

int main() {
	memset(dis, 0x3f, sizeof(dis));
	n = rd(), k = rd(), m = rd();
	for (int i = 1; i < n; ++i) {
		int x = rd(), y = rd();
		E[x].pb(y), E[y].pb(x);
	}
	for (int i = 1; i <= k; ++i) {
		int x = rd();
		q.push(x), dis[x] = 0;
	}
	while (q.size()) {
		int u = q.front(); q.pop();
		for (int v:E[u]) if (dis[v] == 0x3f3f3f3f) dis[v] = dis[u]+1, q.push(v);
	}
	dfs(1, 0);
	while (m--) {
		int x = rd(), y = rd();
		write(min(d[x]+d[y]-2*d[lca(x, y)], dis[x]+dis[y])), enter;
	}
	return 0;
}
```

---

## 作者：Su777 (赞：11)

### [P10289](https://www.luogu.com.cn/problem/P10289) 小杨的旅游 题解

主要考察树上最短路（倍增法求最近公共祖先）与转化法。

**题目大意**：给定一棵 $n$ 个节点的树，每条边边权均为 $1$，其中有 $k$ 个点在 $0$ 的时间内相互可达。$q$ 次询问，求最少经过多长时间可以从 $u$ 走到 $v$。

**子任务一**：$n,k\leq 500$ 且只有一次询问，可以暴力建图（$k$ 个传送点之间连 $\cfrac{k(k-1)}{2}$ 条边权为 $0$ 的边），并使用双端队列 BFS 解决。

**子任务二**：不存在传送点，问题变为常规地求树上两点最短路。注意到 $n \leq 2\times10^5$，使用倍增 LCA 求解即可。

**子任务三**：我们注意到，从节点 $u$ 到节点 $v$ 可以有两种路径可走：可以不走传送点使用 LCA，也可以选择从传送点走。解决本题目的关键点在于如何快速求得从传送点走到路径长度。

传送过程中消耗的时间为 $0$，因此只需要计算从 $u$ 到传送点和从传送点到 $v$ 两端路程的长度即可。贪心分析可得，使用的两个传送点一定是分别离 $u,v$ 最近的两个传送点，才能保证消耗的总时间最少。到这里思路已经很明确了：计算离每个点最近的传送点到该节点的距离 $dst$，最终答案即为 $dst_u+dst_v$。

代码较长，请勿抄袭。

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 2e5 + 10;
const int lgN = 30;
int n, k, s, dep[N], fa[N][lgN], lg[N], dst[N];
vector<int> G[N];
queue<int> Q;
void dfs(int u, int fath) {
	dep[u] = dep[fath] + 1;
	fa[u][0] = fath;
	for (int i = 1; (1 << i) <= dep[u]; i ++) {
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for (int i = 0; i < G[u].size(); i ++) {
		int v = G[u][i];
		if (v != fath) {
			dfs(v, u);
		}
	}
}
int lca(int x, int y) {
	if (dep[x] < dep[y]) swap(x, y);
	while (dep[x] > dep[y]) x = fa[x][lg[dep[x] - dep[y]]];
	if (x == y) return x;
	for (int k = lg[dep[x]]; k >= 0; k --) {
		if (fa[x][k] != fa[y][k]) {
			x = fa[x][k];
			y = fa[y][k];
		}
	}
	return fa[x][0];
}
void bfs() {
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		for (int i = 0; i < G[u].size(); i ++) {
			int v = G[u][i];
			if (dst[v] == 1e9) {
				dst[v] = dst[u] + 1;
				Q.push(v);
			}
		}
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> k >> s;
	for (int i = 0; i <= n; i ++) dst[i] = 1e9;
	for (int i = 1; i < n; i ++) {
		int u, v; cin >> u >> v;
		G[u].push_back(v); G[v].push_back(u);
	}
	lg[1] = 0;
	for (int i = 2; i <= n; i ++) {
		lg[i] = lg[i / 2] + 1;
	}
	dfs(1, 0);
	for (int i = 1; i <= k; i ++) {
		int x; cin >> x;
		Q.push(x); dst[x] = 0;
	}
	bfs();
	while (s--) {
		int u, v; cin >> u >> v;
		cout << min(dst[u] + dst[v]
		, dep[u] + dep[v] - 2 * dep[lca(u, v)]) << "\n";
	}
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：6)

形式化题意：给定一棵有 $k$ 个关键点的树，树上每个关键点间的距离为 $0$，树边长度为 $1$，多次给定两点询问最短路。

假设树上没有关键点，最短路是两点到 LCA 的最短路之和，现在有了关键点，那我们考虑一下关键点的作用，显然，假设强制必须使用关键点，最优的策略是从起点走到离起点最近的关键点，然后传送到离终点最近的关键点，最后再走到终点，这个结论很好证明，假设强制使用关键点，路径长度就是起点 $u$ 到某个关键点 $x$ 的距离加上 $x$ 到另一个关键点 $y$ 的距离再加上 $y$ 到终点 $v$ 的距离，根据题意 $x$ 到 $y$ 的距离为 $0$，由于原图是树，任意两点又且仅有一条简单路径，$u$ 到 $x$ 的距离和 $y$ 到 $v$ 的距离互不影响，所以可以贪心地选择距离最小的关键点。

对这两个值取最小值就是答案，因为只有用关键点和不用关键点两种情况，这两个值就是这两种情况的分别的最小值。

现在唯一的问题就是求出每个点到离它最近的关键点的距离，这一步可以 bfs 求，具体就是把所有关键点先全都存到队列里，关键点的距离定为 $0$，其他点初始化为一个很大的数，然后正常跑 bfs。

注意，如果你是树剖求 LCA，一定注意这一行，我已经写错好多次了。

```cpp
if(d[t[u]]<d[t[v]])
```

要比较的是链顶而不是这两个节点。

```cpp
#include <bits/stdc++.h>
#define rg register
#define cit const rg unsigned
#define vector basic_string
#define vint vector<unsigned>
using namespace std;constexpr unsigned N=2e5+1;
vint a[N];unsigned dp[N],s[N],d[N],f[N],t[N],q[N],c[N],n,k,m;
void dfs1(cit u){for(cit&v:a[u])if(v^f[u])f[v]=u,s[v]=1,d[v]=d[u]+1,dfs1(v),s[u]+=s[v],s[v]>s[c[u]]?c[u]=v:0;}
void dfs2(cit u,cit rt){t[u]=rt;if(!c[u])return;dfs2(c[u],rt);for(cit&v:a[u])if((v^f[u])&&(v^c[u]))dfs2(v,v);}
inline unsigned lca(int u,int v){for(;t[u]^t[v];u=f[t[u]])if(d[t[u]]<d[t[v]]){cit _=u;u=v,v=_;}return d[u]>d[v]?v:u;}
void bfs(){int l=1,r=0;memset(dp,0xff,sizeof dp);
	while(k--){int b;cin>>b;dp[q[++r]=b]=0;}while(l<=r){cit u=q[l++];
		for(cit&v:a[u])if(dp[u]+1<dp[v])dp[v]=dp[u]+1,q[++r]=v;}}
signed main(){cin>>n>>k>>m;
	for(int i=1,u,v;i<n;++i)cin>>u>>v,a[u]+=v,a[v]+=u;dfs1(1),dfs2(1,1),bfs();
	while(m--){int u,v,t1,t2;cin>>u>>v;t1=dp[u]+dp[v],t2=d[u]+d[v]-(d[lca(u,v)]<<1),cout<<min(t1,t2)<<'\n';}}
```

声明：说句闲话，我在某一个 GESP 的题里因为使用树剖求 LCA 导致题解被认为是炫技而打回，但我认为使用树剖求 LCA 并不超纲，因为那个题的官方题解就是用的树剖求 LCA，而且不存在所谓的“吓坏小朋友”的问题，因为做那个题是因为我要参加 GESP，既然小朋友本人会树剖，小朋友肯定不会被吓到。

$2024.4.2$：减少了很多宏定义，现在应该不火车头了，希望过审。

---

## 作者：andyli (赞：5)

容易发现最优方案要么不使用传送门，要么使用一次通过离 $u$ 最近的传送门传送到离 $v$ 最近的传送门，两种方案取最小值。故只需要知道离每个点最近的传送门的距离，可以以所有传送门为源点进行 bfs 解决。  

```cpp
int main() {
    dR(int, n, k, q);
    auto g = read_tree(n);
    Tree tree(g);
    std::deque<int> Q;
    vi dis(n, inf<int>);
    _for (k) {
        dR(int, x), x--;
        Q.eb(x);
        dis[x] = 0;
    }
    while (!Q.empty()) {
        int u = pop(Q);
        foreach (v, g[u])
            if (chkmin(dis[v], dis[u] + 1))
                Q.eb(v);
    }
    _for (q) {
        dR(int, x, y), x--, y--;
        print(min(dis[x] + dis[y], tree.dist(x, y)));
    }
    return 0;
}
```

---

## 作者：Nightsky_Stars (赞：4)

# 题目大意：

给出 $n$ 个点，$n-1$ 条**双向边**，以及 $k$ 个传送门，通过一条双向边花费 $1$ 个单位时间，从任意一座设有传送门的点花费 $0$ 个单位时间前往另一座设有传送门的点。

有 $q$ 次查询，计划从编号为 $u_i$ 的点前往编号为 $v_i$ 的点。求出。

# 思路：

当 $k=0$ 时，此时求的就是树上任意两点的距离，用 LCA 来解决；当 $k\ne0$ 时，走到距离 $u$ 最近的传送门，然后传送到距离 $v$ 最近的传送门，最后走到 $v$。直接 bfs 预处理出每个点与离自己最近的那个传送门。但是这可能并不是最短的，所以要与 LCA 取个 $\min$ 就行了。

# CODE:

```
#include <bits/stdc++.h>
using namespace std;
vector<int>e[200010];
int n,k,s,dep[200010],fa[200010][28],lo[200010],d[200010];
queue<int>q;
void dfs(int x,int step){
	dep[x]=dep[step]+1;
	fa[x][0]=step;
	for(int i=1;(1<<i)<=dep[x];i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
	for(int i=0;i<e[x].size();i++){
		int v=e[x][i];
		if(v!=step) dfs(v,x);
	}
}
int lca(int a,int b){//倍增LCA
	if(dep[a]<dep[b]) swap(a,b);
	while(dep[a]>dep[b]) a=fa[a][lo[dep[a]-dep[b]]];
	if(a==b) return a;
	for(int k=lo[dep[a]];k>=0;k--){
		if(fa[a][k]!=fa[b][k]){
			a=fa[a][k];
			b=fa[b][k];
		}
	}
	return fa[a][0];
}
void bfs(){
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(auto v:e[u]){
			if(d[v]==1e9){
				d[v]=d[u]+1;
				q.push(v);
			}
		}
	}
}
int main(){
    cin>>n>>k>>s;
    for(int i=0;i<=n;i++){
		d[i]=1e9;
	}
    for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	lo[1]=0;
	for(int i=2;i<=n;i++){
		lo[i]=lo[i/2]+1;
	}
	dfs(1,0);
	for(int i=1;i<=k;i++){
		int x;
		cin>>x;
		q.push(x);
		d[x]=0;
	}
	bfs();
	while(s--){
		int u,v;
		cin>>u>>v;
		cout<<min(d[u]+d[v],dep[u]+dep[v]-2*dep[lca(u,v)])<<"\n";
	}
    return 0;
}
```

---

## 作者：Lyco_Reco (赞：2)

注意到原图是一棵树，在 $k=0$ 时通过 LCA 求出两点间距离即为答案。

如果存在传送门，则两点到各自最近的传送门的距离之和可能更优，与两点间距离取较小值作为答案即可。

使用 bfs 求出距离每个点最近的传送门。具体地，将所有传送门一起压入队列进行扩展，扩展时记录每个点到最近的传送门的距离，使用标记数组保证每个点只经过一次。

使用倍增 LCA，时间复杂度 $O(n\log{n}+q\log{n})$。

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <deque>
#include <queue>
#include <iomanip>
#include <map>
#include <unordered_map>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
#define maxn 200010
int n,k,T,dep[maxn],anc[maxn][21],dis[maxn],head[maxn],nxt[maxn<<1],to[maxn<<1],tot,h,t;
bool vis[maxn];
struct node{
	int id,val;
}q[maxn];
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	void add(int u,int v){
		to[++tot]=v;
		nxt[tot]=head[u];
		head[u]=tot;
	}
	void dfs(int u,int fa){
		for(int i=head[u];i;i=nxt[i]){
			int v=to[i];
			if(fa==v){
				continue;
			}
			dep[v]=dep[u]+1;
			anc[v][0]=u;
			dfs(v,u);
		}
	}
	void init(){
		for(int j=1;j<=20;j++){
			for(int i=1;i<=n;i++){
				anc[i][j]=anc[anc[i][j-1]][j-1];
			}
		}
	}
	int LCA(int u,int v){
		if(dep[u]<dep[v]){
			swap(u,v);
		}
		for(int i=20;i>=0;i--){
			if(dep[anc[u][i]]>=dep[v]){
				u=anc[u][i];
			}
		}
		if(u==v){
			return u;
		}
		for(int i=20;i>=0;i--){
			if(anc[u][i]!=anc[v][i]){
				u=anc[u][i];
				v=anc[v][i];
			}
		}
		return anc[u][0];
	}
	void bfs(){
		while(h<t){
			node u=q[h++];
			dis[u.id]=u.val;
			for(int i=head[u.id];i;i=nxt[i]){
				int v=to[i];
				if(vis[v]){
					continue;
				}
				vis[v]=1;
				q[t++]=(node){v,u.val+1};
			}
		}
	}
	void MAIN(){
		n=rd();
		k=rd();
		T=rd();
		for(int i=1;i<n;i++){
			int u=rd(),v=rd();
			add(u,v);
			add(v,u);
		}
		for(int i=1;i<=k;i++){
			int x=rd();
			vis[x]=1;
			q[t++]=(node){x,0};
		}
		fill(dis+1,dis+n+1,inf);
		dfs(1,0);
		init();
		bfs();
		while(T--){
			int u=rd(),v=rd();
			int mid=LCA(u,v);
			wrt(min(dis[u]+dis[v],dep[u]+dep[v]-(dep[mid]<<1)));
			putchar('\n');
		}
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}

```

---


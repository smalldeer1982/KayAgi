# [PA 2024] Łamigłówka 3

## 题目背景

PA 2024 4C

## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 4 [Łamigłówka 3](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/lam/)**

Bytie 喜欢玩手机游戏。然而让他感到恼火的是游戏中经常有其他游戏的广告，并且其中玩游戏的人表现得非常糟糕，广告这样做的目的是让看广告的人感到沮丧，从而产生玩下去的欲望。Bytie 对其中一个广告印象尤为深刻（你可能也看过）。

![lam1.png](https://img.loj.ac.cn/2024/03/24/d2a22d1aa2488.png)

由于可以从任何事物中汲取灵感，Bytie 决定在上述游戏的基础上出道题。他将选择一块大小为 $n\times m$ 的目标图案，游戏在一块 $n\times m$ 的网格上进行，其中没有任何区域被染色。在一次操作中，他可以选择一行或一列，并将这一行（或列）中的**所有方格**（注意，这比上面图片中的游戏更自由，因为在上面的游戏中，重复涂色同一单元格时颜色会混合）重新涂成自己选择的颜色。为了使题目更形式化，他还用大写英文字母标注了所有颜色。你能帮他写一个程序，对于他给出的每个网格，给出正确得到目标图案的操作顺序吗？你可以假设输入中最多可以用 $n+m$ 步操作得到目标图案。

## 说明/提示

假设 `P` 代表绿色，`A` 代表黄色，`Z` 代表蓝色。样例 1 中的操作序列如下图所示：

![lam2.png](https://img.loj.ac.cn/2024/03/24/7f9371fee9091.png)

## 样例 #1

### 输入

```
5 5
AAPAA
APPAA
AAPAA
AAPAA
APPPA
```

### 输出

```
10
R 1 Z
K 4 A
K 2 P
R 5 P
R 4 A
R 3 A
R 1 A
K 5 A
K 3 P
K 1 A
```

## 样例 #2

### 输入

```
2 3
AAA
PPP
```

### 输出

```
2
R 2 P
R 1 A
```

# 题解

## 作者：xiaozhu_zty (赞：2)

# P10361 题解
提供一种比较奇怪的解法？
## Analysis
观察题面，不难发现可以反推来进行模拟。例如样例：![](https://cdn.luogu.com.cn/upload/image_hosting/zv3fc3sp.png)

假设我们最后一行填充了第三列，那么反向删除它：![](https://cdn.luogu.com.cn/upload/image_hosting/34mur4aw.png)

注意到第一行、第三行、第四行分别出现了四个 A。由于我们下一步即将填充第三列，所以第三行的颜色无关紧要，我们可以将他们涂成 A，这样颜色就符合要求了。只要**这一行或列只有一种颜色或者其他的格子无法确定（即下一次涂色马上涂掉）**，那么我们可以将这一行或列放入下一次扩展的序列，并且下次扩展的时候再次寻找这样的行或列。这样操作直到所有格子全部覆盖到，操作就结束。我们可以倒序输出我们模拟的序列。
## Solution
刚才说到，我们需要记录每一行的字母。对于扩展序列，我们可以使用队列存放操作来进行扩展。需要注意的是这里扩展情况可以直接改动而且不需要回溯，因为同时扩展的多个状态是并发的，操作先后并不影响。每次读入状态我们直接把他放到答案栈序列中。由于我们并不需要最小化答案，所以操作 $n+m$ 次也是合法的。

注意到如果我们暴力寻找每一行、列的字母是否只有一种，那么每次扩展需要搜索 $ n\times m $ 个格子，然而操作步数最多来到 $n + m$ 次，这样的时间复杂度无法接受。我们可以记录每一行、列的对应字母个数，由于至多只有 $ 26 $ 个字母，因此我们可以直接建立二维数组记录每行或列的字母个数和删除行或列的次数。例如搜索到一行：当该行对应一种字母（例如 A）的个数 $S_A$、已经修改的列数 $D$、总行数 $n$ 满足 $n-D=S_A$ 时，这行就全部是 A 字母了。

另外，当我们涂掉这行或者列时，对应的字母数量也要更改。

还有很多细节，还是看代码吧，马蜂不良仅供参考。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{; //{type,value,color} type=0 行 type=1 列 value 行/列号
    int type;
    int b;
    int color;
};
stack <node> ans;//答案栈序列
int mp[2005][2005];
int hc[2005][30];//每行的字母个数
int lc[2005][30];//每列的字母个数
bool mh[2005],ml[20005];//分别标记行、列是否被操作过
int ht,lt;
int cnt;
int n,m;
queue <node> q;
string s;
int main(){
    cin>>n>>m;
    for (int i = 1;i<=n;i++){
        cin>>s;
        for (int j = 0;j<m;j++){
            mp[i][j+1]=s[j]-'A';
            hc[i][s[j]-'A']++;
            lc[j+1][s[j]-'A']++;
        }
    }
    q.push({2,114514,1919810});
    while (!q.empty()){
        node cur=q.front();
        q.pop();
        //删除
        if (cur.type==0){
            for (int i = 1;i<=m;i++){
                if (mp[cur.b][i]!=cur.color) continue;
                lc[i][cur.color]--;
            }
            lt++;
        }
        else if(cur.type==1){
            for (int i = 1;i<=n;i++){
                if (mp[i][cur.b]!=cur.color)continue;
                hc[i][cur.color]--;
            }
            ht++;
        }
        //扩展
        for (int i = 1;i<=n;i++){
            for (int j = 0;j<27;j++){
                if (hc[i][j]==m-ht&&mh[i]==false&&m!=ht){
                    mh[i]=true;
                    q.push({0,i,j});
                }
            }
        }
        for (int i = 1;i<=m;i++){
            for (int j = 0;j<27;j++){
                if (lc[i][j]==n-lt&&ml[i]==false&&n!=lt){
                    ml[i]=true;
                    q.push({1,i,j});
                }
            }
        }
        ans.push(cur);
    }
    cout<<ans.size()-1<<endl;
    while (!ans.empty()){
        node cur=ans.top();
        ans.pop();
        if (cur.type==0){
            char col=cur.color+'A';
            cout<<"R"<<" "<<cur.b<<" "<<col<<endl;
        }
        else if(cur.type==1){
            char col=cur.color+'A';
            cout<<"K"<<" "<<cur.b<<" "<<col<<endl;
        }
    }
    return 0;
} 
```

---

## 作者：IC0CI (赞：1)

给出一种朴素（暴力）做法。

## 题面分析

给出的一个 $n \times m$ 的目标网格图。每次操作能使一行或一列变为一种颜色，需要你构造一种在 $n + m$ 次操作之内，将空图变成目标图的方案。

发现：每次操作后必有至少一行或一列为同一种颜色，相反地，我们也能从目标图每次找只有一种颜色的一行或一列来反推步骤。

### 关于具体实现

具体地，每次找到只有一种颜色的一行或一列抹除，抹除后这些格子的颜色可能为所有颜色，反着记录答案。

这个东西的时间复杂度明显是不对的，但是我们有一个优化方案：

+ 当所有行或者所有列都被抹除过显然已经还原成空图。

但时间复杂度仍然不对粗略估计有 $O(n^3)$。

但是由于我们每次遍历时可以改变多个行和列，实际耗时远不及理论复杂度。

到这里测试下来只有一个点过不了。

再加上本题的大量输入输出，进行输入输出优化后可以过最后一个点。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

int rd()//快读

const int N = 2005;
int n,m,cnt;
int mp[N][N];

struct node
{
    char a,c;
    int b;
}a[N + N];
bool vis[N + N];

int num1,num2;

signed main()
{
    n = rd(),m = rd();
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            char c = getchar();
            mp[i][j] = c - 'A';
        }
        getchar();
    }
    for(int i = 1;i <= n + m;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            if(vis[j]) continue;
            bool f = 1;
            int x = -1;
            for(int k = 1;k <= m;k++) if(mp[j][k] != -1)
            {
                x = mp[j][k];
                break;
            }
            for(int k = 1;k <= m;k++) if(mp[j][k] != x && mp[j][k] != -1)
            {
                f = 0;
                break;
            }
            if(f)
            {
                num1++;
                vis[j] = 1;
                int c = -1;
                for(int k = 1;k <= m;k++) if(mp[j][k] != -1) c = mp[j][k],mp[j][k] = -1;
                if(c == -1) continue;
                a[++cnt].a = 'R';
                a[cnt].b = j;
                a[cnt].c = (char)(c + 'A');
            }
        }
        for(int j = 1;j <= m;j++)
        {
            if(vis[j + n]) continue;
            bool f = 1;
            int x = -1;
            for(int k = 1;k <= n;k++) if(mp[k][j] != -1)
            {
                x = mp[k][j];
                break;
            }
            for(int k = 1;k <= n;k++) if(mp[k][j] != x && mp[k][j] != -1)
            {
                f = 0;
                break;
            }
            if(f)
            {
                num2++;
                vis[j + n] = 1;
                int c = -1;
                for(int k = 1;k <= n;k++) if(mp[k][j] != -1) c = mp[k][j],mp[k][j] = -1;
                if(c == -1) continue;
                a[++cnt].a = 'K';
                a[cnt].b = j;
                a[cnt].c = (char)(c + 'A');
            }
        }
        if(num1 == n || num2 == m) break;
    }
    cout << cnt << '\n';
    for(int i = cnt;i >= 1;i--) cout << a[i].a << ' ' << a[i].b << ' ' << a[i].c << '\n';
    return 0;
}
```

---


# [蓝桥杯 2023 国 A] 相连的边

## 题目描述

给定一棵包含 $n$ 个结点的树，找出 $3$ 条边使得这三条边的端点仅经过这三条边即可互相到达且三条边的长度和尽可能大。

## 说明/提示

**【样例解释 1】**

结点 $2$ 和结点 $1$ 的边长为 $1$，结点 $3$ 和结点 $2$ 的边长为 $1$，结点 $4$ 和结点 $3$ 的边长为 $7$，结点 $5$ 和结点 $1$ 的边长为 $10$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$4\le n\le 300$；  
对于 $40\%$ 的评测用例，$4\le n\le 5000$；  
对于所有评测用例，$4\le n\le 2\times 10^5$，$1\le x_i<i$，$1\le y_i\le 10^9$。

## 样例 #1

### 输入

```
5
1 1
2 1
3 7
1 10
```

### 输出

```
12
```

# 题解

## 作者：Joww (赞：7)

由于题目给定一棵树，因此相连通的三条边要么是链，要么是菊花。

菊花比较简单，做法是——
- 枚举菊花的中心结点 $i$，
- 取出结点 $i$ 的三条边权最大的邻接边，
- 此时这三条边就是以结点 $i$ 为中心且边权和最大的三条边组成的菊花。

对于链，每条链最特殊的边是位于中间的那条，所以做法是——

- 枚举链的中心边 $(i, x)$（边权为 $y$），记为①边；
- 取出 $i$ 的、不与 $x$ 相连的、边权最大的邻接边，记为②边；
- 取出 $x$ 的、不与 $i$ 相连的、边权最大的邻接边，记为③边；
- 【①、②、③】就是以①边为中心边且边权和最大的三条边组成的链。

因此，影响答案的只有每个点边权最大的三条邻接边，预处理后朴素地枚举即可。

为了实现方便，以下代码使用了 `sort`，但实际上可以使用循环在 $O(n)$ 内找出边权最大的三条边。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = (int) 2e5 + 10;
vector<pair<int, int>> g[N];

int main() {
    int n;
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        g[i].push_back({ y, x });
        g[x].push_back({ y, i });
    }
    
    long long ans = 0;
    
    // type1 : flower
    for (int i = 1; i <= n; i++) {
        sort(g[i].begin(), g[i].end(), greater<pair<int, int>>());
        if (g[i].size() >= 3) {
            ans = max(ans, 0ll + g[i][0].first + g[i][1].first + g[i][2].first);
        }
    }

    // type2 : chain
    for (int i = 1; i <= n; i++) {
        if (g[i].size() == 1) continue;
        for (auto [y, x] : g[i]) {
            if (g[x].size() == 1) continue;
            long long sum = y;
            sum += (g[x][0].second != i ? g[x][0] : g[x][1]).first;
            sum += (g[i][0].second != x ? g[i][0] : g[i][1]).first;
            ans = max(ans, sum);
        }
    }
    cout << ans << '\n';

    return 0;
}
```

Bonus: 如果题目给定的不是树，而是一张图，又该怎么做呢？

---

## 作者：Clare613 (赞：3)

# 题意
在树上找到三个点，并且使这三个点互相抵达的长度之和最大。
# 分析
因为是树，所以分两个情况讨论。\
**菊花图：**\
根据每个点，找与它相连的三条边，且这三条边最大，加起来后与答案取 $\max$。\
**链：**\
从任意点出发，走三次，把一路走过来的边的长度加起来后与答案取 $\max$。\
很快，我们高高兴兴的写完 DFS，结果发现 TLE 了，那么我们就可以这么做：\
枚举中间的那条边，找到这条边上的两个点的最长边，加起来就可以了。注意，最长边不能就直接选这条边。
# code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int v,w;
};
int maxn=0;
vector<node> g[200005];
int x[200005],y[200005],z[200005];
//void dfs(int step,int x,int sum,int last){
//	if(step>=4){
//		maxn=max(maxn,sum);
//		return ;
//	}
//	for(auto i:g[x]){
//		if(i.v==last) continue;
//		dfs(step+1,i.v,sum+i.w,x);
//	}
//}
bool cmp(node x,node y){
	return x.w>y.w;
}
signed main(){
    cin.tie(0)->sync_with_stdio(0);
	int n;
	cin>>n;
	for(int i=2;i<=n;i++){
		int v,w;
		cin>>v>>w;
        y[i]=v;
        z[i]=w;
		g[i].push_back({v,w});
		g[v].push_back({i,w});
	}
	// for(int i=1;i<=n;i++)dfs(1,i,0,-1);
	for(int i=1;i<=n;i++){
		sort(g[i].begin(),g[i].end(),cmp);
		if(g[i].size()>=3){
			maxn=max(g[i][0].w+g[i][1].w+g[i][2].w,maxn);
		}
    }
    for(int i=2;i<=n;i++){
        int q=z[i];
        if(g[i].size()==1||g[y[i]].size()==1) continue;
        if(g[i][0].v!=y[i]){
			q+=g[i][0].w;
		}
		else{
			q+=g[i][1].w;
		}
        if(g[y[i]][0].v!=i){
			q+=g[y[i]][0].w;
		}
		else{
			q+=g[y[i]][1].w;
		}
		maxn=max(maxn,q);
    }
	cout<<maxn;
	return 0;
}
```

---

## 作者：Determination_Y (赞：3)

[Cnblogs](https://www.cnblogs.com/Sundar-2022/p/18448593)，一个比较有趣的树形 DP，情况比较多。

### 【题目简述】

给定一棵树，求三条相连的边，其边权之和最大。

### 【思路】

以 X 代表当前节点，S 表示儿子，G 表示孙子，F 表示父节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/2txf2c5i.png)

首先把树建出来，在以下图中，我们模拟二号点的 DP 过程，考虑以下几种情况：

* 有一条边指向父节点时

  * FG（Father Grandson）：一条边指向父节点，另外两条边指向孙子。

    需要维护指向孙子的路径的最大值。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/fesn2anf.png)

  * FSS（Father Son Son）：一条边指向父节点，另外两条边指向两个不同的儿子。

    需要维护指向儿子的路径的最大、次大值。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/qcu8t5il.png)

* 没有边指向父节点时

  * GS（Grandson Son）：一条边指向孙子，另外一条边指向另一个儿子。

    需要维护指向儿子的路径的最大、次大值和指向孙子的路径的最大、次大值（可能这两条路径重合）

    ![](https://cdn.luogu.com.cn/upload/image_hosting/odcd3rph.png)

  * SSS（Son Son Son）：三条边指向三个不同的儿子。

    需要维护指向儿子的路径的最大、次大、第三大值。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/ea0e0544.png)

* 要维护的东西：指向儿子的路径的最大、次大、第三大值，指向孙子的路径的最大、次大值。

于是代码就很好写了。

### 【Code】

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

vector<pair<int,int>>Edge[200005];
int n,u,w,ans;

int DFS(int u,int fa,int W){
	int max11=0,flag11=0,max12=0,flag12=0,max13=0,flag13=0; //max1x,flag1x：向 Dis(X,S) x 大值及儿子编号 
	int max21=0,flag21=0,max22=0,flag22=0;                  //max2x,flag2x：向 Dis(X,G) 的路径的 x 大值及儿子编号 
	
	for(auto it:Edge[u]){
		int v=it.first,DisXS=it.second;
		if(v!=fa){
			int DisSG=DFS(v,u,DisXS);  //Dis(S,G) 的最小值
			
			//如果儿子还有儿子（有孙子），更新到 Dis(X,G) 的最大、次大值 
			if(DisSG!=0){
				int DisXG=DisXS+DisSG;
				if(max21<DisXG)      max21=max21,flag22=flag21,max21=DisXG,flag21=v;
				else if(max22<DisXG) max22=DisXG,flag22=v;
			}
			
			//更新到 Dis(X,S) 的最大、次大、第三大值  
			if(max11<DisXS)      max13=max12,flag13=flag12,max12=max11,flag12=flag11,max11=DisXS,flag11=v;
			else if(max12<DisXS) max13=max12,flag13=flag12,max12=DisXS,flag12=v;
			else if(max13<DisXS) max13=DisXS,flag13=v;
		}
	}
	
	//W 表示到父节点的路径长度 
	if(u!=1)           ans=max(ans,W+max21);                 //FG
	if(u!=1)           ans=max(ans,W+max11+max12);           //FSS
	if(flag11!=flag21) ans=max(ans,max21+max11);             //GS（两条路径不重合） 
	if(flag11==flag21) ans=max({ans,max21+max12,max22+max11}); //（两条路径重合，其中一条选择次长路） 
	ans=max(ans,max11+max12+max13);                          //SSS
	return max11;
}

signed main()
{
	scanf("%lld",&n);
	for(int v=2;v<=n;v++){
		scanf("%lld%lld",&u,&w);
		Edge[u].push_back({v,w});
		Edge[v].push_back({u,w});
	}
	DFS(1,0,0);
	printf("%lld",ans);
	return 0;
}
```

### 【闲话】

祝所有看到这篇题解的人 CSP2024 RP++！

---

## 作者：hgckythgcfhk (赞：3)

考虑转化题意，$3$ 条边相当于 $4$ 个点，暂且认为每个点都是一样的，这样就会出现一些看起来好想长得不一样但其实本质上形态一样的东西，把这些东西合并来分讨。

考虑最长链长度为 $1$，发现无论怎么构造原图都不连通，假设能连通则必有 $1$ 与 $2$ 连通且 $1$ 与 $3$ 连通，所以 $2$ 与 $3$ 连通，由于不存在环，必有 $2\to 1\to 3$ 的路径，所以最长链最短也得大于等于 $3$（这里没有证明 $3$ 是下界，但证明了下界大于等于 $3$ 对于本题来说够用了）这样我们同时证明了不存在最长链为 $2$ 的链。

那么直接开始构造最长链长度为 $3$ 的情况。

先造出来一条这样的链。
```
o-o-o
```
发现不能加在两端，因为会使最长链长度变为 $4$。

那么有以下两种情况。
```
o-o-o
  |
  o
```
和，
```
  o
  |
o-o-o
```
发现这两种是一样的。

最长链长度为 $4$ 的情况更好造，只有这一种情况。
```
o-o-o-o
```
因为我们造出来这样一条链后没有剩余节点，所以这种情况只能是链。

发现，本质上这个问题可以总结为两种情况，根的度数为 $3$ 的菊花和长度为 $4$ 的链。

对于第一种情况，我们可以把每个节点的边按边权从大到小排序，选前 $3$ 个，显然正确，这个很好做，没什么难实现的地方。

对于第二种情况，考虑枚举中间的两个点，也就是先枚举一条边，然后从这两个点出发，选择这两个点的连边，和对于两个点分别的**从这个点出发不是这条边的最长的边**，一定注意，不能是我们枚举的边，因为这相当于我们少选了一个点。

实现：
```cpp
for(int i=1;i<=n;++i)for(A e:a[i]){cit v=e.a,w=e.b;int t=w;
		for(A j:a[i])if(j.a^v){t+=j.b;break;}
		for(A j:a[v])if(j.a^i){t+=j.b;break;}
		ans=max(ans,t);
	}
```
这里我已经排好序了，具体见完整程序。

考虑证明第二种情况的正确性，因为我们每一条可能合法的中间边都能枚举到，所以不会算漏，那么我们只需要证明对于每一条可能合法的中间边，不合法的不会产生贡献，合法的能保证这个决策下能选到以当前边为中间边的最优解即可证明这个决策能推出全局最优解。

合法情况好证，所以我们先证合法情况，先定义一下合法情况，假设边 $(u,v,w)$ 合法，则从 $u$ 出发必有至少一条边，使得这条边不是 $(u,v,w)$（数据保证了没有重边和自环，这个正确性显然），同样从 $v$ 出发也是，虽然这个解释很口语化，但我们把这种情况定义为合法情况。

当枚举到 $(b,c,w2)$ 时，先假定这条边必选，不可替换，假设我们现在有一组解是选 $(a,b,w1),(b,c,w2),(c,d,w3)$，若存在 $(e,b,w4)$ 使得 $e\ne c$ 且 $w4>w1$ 则我们用 $(e,b,w4)$ 替换掉 $(a,b,w1)$ 一定能使得第一条边更优，同时，我们也可以很自然的得到最后一条边同理，这样我们能保证这个决策能够使我们每条边达到局部最优，考虑到原图是树，不存在环，所以我们一定选不出 $a=d$ 的边，两边的两条互不影响，同时，我们假定了中间边必选 $(b,c,w2)$ 则两边的边不会影响中间边，只能是中间影响两边，由于决策中加粗的那句话已经把影响的情况自动排除了，我们不需要考虑这个影响，所以每个部分都能互不影响的达到局部最优，则这个决策必然是选 $(b,c,w2)$ 时的最优解，由于我们能枚举到所有可能合法的情况，所以我们能枚举到所有合法情况，所以我们一定不会得出比最优解劣的解。

考虑不合法的情况，假设我们枚举到的 $b$ 度数为 $1$ 则可能选不够，那么我们一定能选出形如 $(b,c,w2),(c,f,w5)$ 的两条边，或者 $(b,c,w2)$ 的一条边（这种情况树的大小为 $2$，无解，但 $n\ge4$），这样，当我们枚举到 $(c,f,w5)$ 时，只要 $n>3$ 则一定有一组解 $(b,c,w2),(c,f,w5),(g,h,w6)$ 因为边权非负，则这个解比上面那个不合法优，由于数据保证了 $n\ge 4$，所以我们不需要考虑这些奇奇怪怪的情况，所以不合法的解必然不优于合法解，至此，我们可以推出我们一定不会选出比最优解优的解，上面证明了不会选出更劣的解，所以我们选的一定是最优解。

然后是完整程序。
```cpp
struct A{unsigned a,b;inline bool operator<(const A&c){return b>c.b;}};vector<A>a[N];
signed main(){open;int n;cin>>n;
	for(int i=1,v,w;i<n;++i)cin>>v>>w,a[i+1]+={v,w},a[v]+={i+1,w};
	for(int i=1;i<=n;++i)sort(a[i].begin(),a[i].end());int ans=0;
	for(int i=1;i<=n;++i)if(a[i].size()>2)ans=max(ans,a[i][0].b+a[i][1].b+a[i][2].b);
	for(int i=1;i<=n;++i)for(A e:a[i]){cit v=e.a,w=e.b;int t=w;
		for(A j:a[i])if(j.a^v){t+=j.b;break;}
		for(A j:a[v])if(j.a^i){t+=j.b;break;}
		ans=max(ans,t);
	}cout<<ans;
}
```
为防止因为火车头被打回，宏定义和头文件还是不放了，不影响阅读。

---

## 作者：FISH酱 (赞：3)

## 前置知识

本题建议评橙。

你需要掌握基本的树论和深搜。

## 思路讲解

题目给出一棵树，包含 $n$ 个结点，我们需要找出三条边，使这三条边的端点，只经过这三条边即可互相到达，同时希望三条边的长度之和尽量大。

我们需要先建树，注意建边时的结点编号问题，仔细读题，这里我推荐使用邻接表。

我们需要分两次进行求解。

第一次求解时，我们枚举每一个点，并对这个点的所有边按照长度从大到小排序，如果该点的度大于等于 $3$，则取出长度最大的三条边，计算边长之和，并且更新最大值。

第二次求解时，枚举每个点，从那个点出发，深搜求出所有走三条边的情况，搜索时累加长度和，每走完三条边后就更新最大值。

求解结束后输出最大值即可。

## 代码展示

注意数组大小，深搜时要记录上个点编号，并防止重复搜索。后来题解被撤下了，我更改了搜索找下一条边的部分，只搜长度最大的两条边。

下面是我的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define inf 0x3f3f3f3f
#define endl '\n'

#define int long long

inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int n,maxn=-inf; // 定义变量

struct edge{
	int node,w; // 定义结构体，存储下个结点的编号和边长
};
bool cmp(edge q,edge p){
	return q.w>p.w; // 按照边长从大到小排序
}
vector<edge> a[200007]; // 定义邻接表

void dfs(int x,int step,int sum,int last){
	if(step==3){ // 如果已经走了三条边
		maxn = max(maxn,sum); // 更新最大值
		return; // 退出
	}
	
	for(int i=0;i<min((int)2,(int)a[x].size());i++){ // 枚举最长的两条边，如果不足两条就按照实际边数
		if(a[x][i].node!=last){ // 防止重复搜索
			dfs(a[x][i].node,step+1,sum+a[x][i].w,x); // 搜索
		}
	}
}

signed main(){
	n=read(); // 输入n
	for(int i=1;i<n;i++){
		int x=read(),y=read(); // 读入结点和边长
		a[i+1].push_back(edge{x,y}); // 建边，注意结点编号
		a[x].push_back(edge{i+1,y});
	}
	
	for(int i=1;i<=n;i++){ // 枚举每个点
		sort(a[i].begin(),a[i].end(),cmp); // 把当前点的边按照边长从大到小排序
		if(a[i].size()>=3){ // 如果度大于等于3
			int ls=a[i][0].w+a[i][1].w+a[i][2].w; // 取出边长最大的三条边，求长度和
			maxn = max(maxn,ls); // 更新最大值
		}
        dfs(i,0,0,-1); // 从每个点出发搜索，走三条边
	}
	
	printf("%lld",maxn); // 输出最大值答案

    return 0; // 完结撒花！
}
```

---

## 作者：ran_qwq (赞：2)

一种比较蠢（？）的做法。

三条边的形态就是**链**和**菊花**两种。如果加上深度限制，也就四种：

1. ![](https://cdn.luogu.com.cn/upload/image_hosting/r101o93m.png)
1. ![](https://cdn.luogu.com.cn/upload/image_hosting/gvi42twk.png)
1. ![](https://cdn.luogu.com.cn/upload/image_hosting/hhxtlrnt.png)
1. ![](https://cdn.luogu.com.cn/upload/image_hosting/wjmt95ww.png)

以下记 $f_{u,i}$ 为以 $u$ 为深度最浅的点，长度为 $i$ 的链的最大权值，$s_{u,i}$ 为次大权值（不能和最大的有重叠部分，换句话说决策点不能相同），$t_{u,i}$ 为次次大权值（不能和最大和次大的有重叠部分）。

这些可以用打擂台+递推的方式转移。

枚举 $u$（不一定是深度最浅的）。

+ 对于第一种形态，令 $u$ 是深度最浅的，权值为 $f_{u,3}$。
+ 对于第二种形态，令 $u$ 是深度最浅的，有三种情况：
	+ $1\rightarrow4$ 的链是第一的，$1\rightarrow3$ 是第一的，权值为 $f_{u,1}+f_{u,2}$。
   + $1\rightarrow4$ 的链是第一的，$1\rightarrow3$ 是第二的，权值为 $f_{u,1}+s_{u,2}$。
   + $1\rightarrow4$ 的链是第二的，$1\rightarrow3$ 是第一的，权值为 $s_{u,1}+f_{u,2}$。
   
   因为可能两个第一决策点相同，所以有三种情况。注意这里如果两个都是第二的话可以交换，不优。
+ 对于第三种形态，令 $u$ 是最中间的，权值为 $f_{u,1}+s_{u,1}+w_{fa,u}$。
+ 对于第四种形态，令 $u$ 是深度最浅的，权值为 $f_{u,1}+s_{u,1}+t_{u,1}$。

需要判断决策点是否相同，所以 dp 时要记录决策点，并且要特判没有决策点的情况。

```cpp
int n,id,to[N],w[N],ne[N],head[N],a[N]; ll ans; pli f[N][4],s[N][4],t[N][4];
void add(int x,int y,int z) {to[++id]=y,w[id]=z,ne[id]=head[x],head[x]=id;}
void dfs(int u) {
	for(int i=head[u],v;i;i=ne[i]) {
		dfs(v=to[i]),a[v]=w[i];
		for(int j=1;j<=3;j++) {
			if(j>1&&!f[v][j-1].sec) continue; ll x=f[v][j-1].fir+w[i];
			if(x>f[u][j].fir) t[u][j]=s[u][j],s[u][j]=f[u][j],f[u][j]={x,v};
			else if(x>s[u][j].fir) t[u][j]=s[u][j],s[u][j]={x,v};
			else if(x>t[u][j].fir) t[u][j]={x,v};
		}
	}
}
void QwQ() {
	n=rd();
	for(int i=2,x,y;i<=n;i++) x=rd(),y=rd(),add(x,i,y);
	dfs(1);
	for(int i=1;i<=n;i++) ans=max({ans,
								   f[i][3].sec?f[i][3].fir:0,
								   f[i][2].sec&&f[i][1].sec!=f[i][2].sec?f[i][1].fir+f[i][2].fir:0,
								   f[i][2].sec&&s[i][1].sec&&f[i][2].sec!=s[i][1].sec?f[i][2].fir+s[i][1].fir:0,
								   s[i][2].sec&&f[i][1].sec!=s[i][2].sec?f[i][1].fir+s[i][2].fir:0,
								   s[i][1].sec&&i!=1?f[i][1].fir+s[i][1].fir+a[i]:0,
								   t[i][1].sec?f[i][1].fir+s[i][1].fir+t[i][1].fir:0});
	wrll(ans,"\n");
}
```

---

## 作者：Archy_ (赞：1)

## 题目思路
首先看到题目只需要连三条边，那么我们可以分类讨论。

三条边连成的图要么是一个菊花，要么是一条链。

- 对于菊花的情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/0ebhao7l.png)
这时候我们可以考虑枚举菊花的中心点，选取这个点所连所有边权值前 $3$ 大的就好了。
对于这个点所连边数不足 $3$ 的进行特判。

- 对于链的情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/ibbawedu.png)
注意到边是在这个链的中间的，这时候我们就可以枚举链的中心边，记录边的起点和终点，对于起点终点同理进行向外找其他权值最大的边。但是有可能错误地找回到我们枚举的中心边，所以这时候需要特判。

问题现在只剩下怎么快速求任意点的所连边的权值最大的了，因为我们需要求前 $3$ 大，这里我考虑用 set 进行维护，实质上就是用 set 处理边的信息了。

这里感觉处理的边会很多，用 set 会爆内存，实则不然。对于本题由于是树的结构，实际上连的边要少的多，而且跑的也是没那么慢。

## Code
```cpp
#include <iostream>
#include <set>
#define fi first
#define se second
#define int long long
using namespace std;

const int N = 2e5 + 5;
set <pair<int, int> > s[N];
int head[N], cnt, n, ans;

struct node {
	int from, to, w, next; 
} e[N << 1];

void addi(int u, int v, int w) {
	e[++ cnt].from = u;
	e[cnt].to = v;
	e[cnt].w = w;
	e[cnt].next = head[u];
	head[u] = cnt;
}

void add(int u, int v, int w) {
	addi(u, v, w); 
	addi(v, u, w);
}

main() {
	cin.tie(0) -> ios::sync_with_stdio(0);
	cin >> n;
	for(int i = 2; i <= n; i ++) {
		int j, w; cin >> j >> w;
		add(i, j, w);
	}
	for(int u = 1; u <= n; u ++) {
		for(int i = head[u];i ; i = e[i].next) {
			s[u].insert({e[i].w, e[i].to});	//以边权为第一关键字进行自动排序
		}
	} 
	for(int i = 1; i <= n; i ++) {
		if(s[i].size() < 3) continue;
		int tmp = 0;
		auto p = s[i].end();
		p --; tmp += (*p).fi; 
		p --; tmp += (*p).fi; 
		p --; tmp += (*p).fi; 
		ans = max(ans, tmp);
	}
	for(int i = 1; i <= cnt; i += 2) {
		int tmp = 0;
		int a = e[i].from;
		int b = e[i].to;
		if(s[a].size() <= 1) continue;
		if(s[b].size() <= 1) continue;
		auto p1 = s[a].end(); p1 --;
		auto p2 = s[b].end(); p2 --;
		if((*p1).se == b) p1 --;  //防止向外的新边还是我们枚举的那个边
		if((*p2).se == a) p2 --;	
		tmp = (*p1).fi + (*p2).fi + e[i].w;
		ans = max(ans, tmp);
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：1)

# P10418 题解

## 思路

在树上求最值，可用树形 dp。

在树上取出 $1$ 到 $3$ 条边，无非只有以下 $7$ 种情况：

```
0：
0
|
0
===
1：
  0
 / \
0   0
===
2：
0
|
0
|
0
===
3：
0
|
0
|
0
|
0
===
4：
  0
 / \
0   0
|
0
===
5：
  0
  |
  0
 / \
0   0
===
6：
  0
 /|\
0 0 0
```

从上到下，我们将这些情况用 $0,1,2,3,4,5,6$ 来表示，于是可以设计 $f$ 数组为：$f_{u,j}$ 表示节点 $u$ 作为第 $j$ 种图形的根节点时的最大值。

接下来分析状态转移：

对于第 $0$ 种情况，$f_{u,0}=\max\{ w[i] \}$。

对于第 $1$ 种情况：$f_{u,1}=\max\{ w[i] \}+submax$（记 $w[i]$ 的次大值为 $submax$）。

对于第 $2$ 种情况：$f_{u,2}=\max\{ w[i]+f_{v,0} \}$（可由第 $0$ 种情况得到）。

对于第 $3$ 种情况：$f_{u,3}=\max\{ w[i]+f_{v,2} \}$（可由第 $2$ 种情况得到）。

对于第 $4$ 种情况：记 $f_{v,2}+w[i]$ 的最大值和次大值为 $max1,submax1$，$w[i]$ 的最大值和次大值为 $max2,submax2$，若 $max1,max2$ 所在不同的子树上，则 $f_{u,4}=max1+max2$，如果在同一子树上，则需要错开一个位置，即 $f_{u,4}=\max\{ max1+submax2,max2+submax1 \}$。

对于第 $5$ 种情况：$f_{u,5}=\max\{ f_{v,1}+w[i] \}$（可由第 $1$ 种情况得到）。

对于第 $6$ 种情况：$f_{u,6}$ 为取 $w[i]$ 的前三大的值之和。

以上 $7$ 种情况，如果出现没有解的情况，即为 $-\infty$。

理清思路之后，代码就不难写了！

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N=200005;
const int M=400005;
const int inf=1000000000000000000LL;

typedef pair<int,int> pii;

int n;
int e[M],ne[M],h[N],w[M],tot;
int f[N][7];

void add(int a,int b,int c) {
    e[tot]=b,w[tot]=c,ne[tot]=h[a],h[a]=tot++;
}

bool cmp(const pii& a,const pii& b) {
    return a.first>b.first;
}

void dfs(int u,int fa) {
    for (int i=0;i<=6;++i) {
        f[u][i]=-inf;
    }
    vector<pii> vec1,vec2;
    for (int i=h[u];~i;i=ne[i]) {
        if (e[i]==fa) continue;
        dfs(e[i],u);
        f[u][0]=max(f[u][0],w[i]);
        f[u][2]=max(f[u][2],f[e[i]][0]+w[i]);
        f[u][3]=max(f[u][3],f[e[i]][2]+w[i]);
        f[u][5]=max(f[u][5],f[e[i]][1]+w[i]);
        vec1.push_back({w[i],i});
        vec2.push_back({f[e[i]][0]+w[i],i});
    }
    sort(vec1.begin(),vec1.end(),cmp);
    sort(vec2.begin(),vec2.end(),cmp);
    if (vec1.size()>=2) {
        f[u][1]=vec1[0].first+vec1[1].first;
        if (vec1.size()>=3) {
            f[u][6]=vec1[0].first+vec1[1].first+vec1[2].first;
        }
    }
    if (vec1.size() && vec2.size()) {
        if (vec1[0].second==vec2[0].second) {
            if (vec1.size()>=2 && vec2.size()>=2) {
                f[u][4]=max(vec1[0].first+vec2[1].first,vec1[1].first+vec2[0].first);
            } else if (vec1.size()==1 && vec2.size()>=2) {
                f[u][4]=vec1[0].first+vec2[1].first;
            } else if (vec1.size()>=2 && vec2.size()==1) {
                f[u][4]=vec1[1].first+vec2[0].first;
            }
        } else {
            f[u][4]=vec1[0].first+vec2[0].first;
        }
    }
}

signed main() {
    memset(h,-1,sizeof(h));
    scanf("%lld",&n);
    for (int i=2;i<=n;++i) {
        int x,y;
        scanf("%lld %lld",&x,&y);
        add(i,x,y);
        add(x,i,y);
    }
    dfs(1,0);
    int ans=-inf;
    for (int i=1;i<=n;++i) {
        for (int j=2;j<=6;++j) {
            ans=max(ans,f[i][j]);
        }
    }
    printf("%lld",ans);
    return 0;
}

/*
0:
0
|
0

1:
  0
 / \
0   0

2:
0
|
0
|
0

3:
0
|
0
|
0
|
0

4:
  0
 / \
0   0
|
0

5:
  0
  |
  0
 / \
0   0

6:
  0
 /|\
0 0 0
*/
```

代码中，`vec1` 和 `vec2` 分别表示 $w[i]$ 和 $w[i]+f_{v,0}$ 的所有值，进行降序排序。

除了 $1,4$ 两种状态需要用到一些辅助之外，其余的状态均可以在枚举子节点的过程中直接进行状态转移。

---

## 作者：篮网总冠军 (赞：0)

本题是一个比较简单的树形 DP，属于代码量比较少，思维难度也不高的题目。

本题分成 $2$ 类讨论：

+ $3$ 条边形成一条链。

+ 菊花图。

我是设置了一个 $dp$ 数组，$dp_{i,j}$ 表示以 $i$ 为根的一条长度为 $j$ 的链的最大价值，$dp_{i,3}$ 对应的就是上面的第一种情况。

接着，用优先队列存储每个单边和双边（设 $v$ 为其的一个儿子节点，边权为 $s$ ，那么值为 $dp_{v,1}+s$），对于每种菊花图进行判断，求出最大值。

注意，一定要特判没有点的情况。

对整个树进行遍历求值即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
long long ans;
vector<int>a[200005];
vector<long long>b[200005];
long long dp[200005][4];
long long sb[200005];
bool vis[200005];
void dfs(int w){
	vis[w]=1;
	priority_queue<long long>q;
	priority_queue<long long>q1; 
	for(int i=0;i<a[w].size();i++){
		if (vis[a[w][i]]) continue;
		dfs(a[w][i]);
		dp[w][1]=max(dp[w][1],b[w][i]);
		dp[w][2]=max(dp[w][2],dp[a[w][i]][1]+b[w][i]);
		dp[w][3]=max(dp[w][3],dp[a[w][i]][2]+b[w][i]);
		ans=max(ans,dp[w][3]);
		ans=max(ans,b[w][i]+sb[a[w][i]]);
		q.push(b[w][i]);
		q1.push(dp[a[w][i]][1]+b[w][i]);
	}
	bool flag=1;
	if (q.size()>=3){
		long long cnt=0;
		for(int i=0;i<3;i++){
			cnt+=q.top();
			if (i<=1) sb[w]+=q.top();
			q.pop(); 
		}
		ans=max(ans,cnt);
		flag=0;
	}
	if (q.size()==2&&flag){
		sb[w]+=q.top();
		q.pop();
		sb[w]+=q.top();
	}
	if (q1.size()<2) return;
	for(int i=0;i<a[w].size();i++){
		long long rt=q1.top();
		if (rt==dp[a[w][i]][1]+b[w][i]){
			q1.pop();
			long long yu=q1.top();
			ans=max(ans,b[w][i]+yu);
			q1.push(rt);
		}
		else ans=max(ans,b[w][i]+rt);
	}
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v,s;
		cin>>v>>s;
		u=i+1;
		a[u].push_back(v);
		a[v].push_back(u);
		b[u].push_back(s);
		b[v].push_back(s);
	} 
	memset(vis,0,sizeof(vis));
	dfs(1);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：破壁人罗辑 (赞：0)

## 题意简述

在一棵树上找出一个包含三条边的连通子图使得这个连通子图的边权和最大。

## 解题思路

这个连通子图必定为以下情况之一：

- 1->2, 2->3, 3->4
- 1->2, 2->3, 2->4
- 1->2, 1->3, 2->4
- 1->2, 1->3, 1->4

考虑贪心加树上动态规划，深度优先搜索一遍，搜索时下传与本节点相连的边中边权最大的边，四种情况分别判断取 $max$，即可得到答案。

实现细节见代码。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<pair<int,unsigned int> >to[200001];
int Read(){
	char c=getchar();while(c<'0'||c>'9')c=getchar();
	int r=0;while(c>='0'&&c<='9'){r=r*10+(c^48);c=getchar();}
	return r;
}
bool cmp(pair<int,unsigned int> x,pair<int,unsigned int> y){
	return x.second>y.second;
}
unsigned int dfs(int n,unsigned int val1,unsigned int val2){
	if(!to[n].empty()){
		if(to[n].size()==1)return max(val2+to[n][0].second,dfs(to[n][0].first,to[n][0].second,val1+to[n][0].second));
		sort(to[n].begin(),to[n].end(),cmp);
		unsigned int r=max(to[n][0].second+max(val2,val1+to[n][1].second),dfs(to[n][0].first,to[n][0].second,max(to[n][1].second,val1)+to[n][0].second));
		val1=max(val1,to[n][0].second);
		for(int i=1,j=to[n].size();i<j;i++){
			r=max(dfs(to[n][i].first,to[n][i].second,to[n][i].second+val1),r);
		}
		return to[n].size()>2?max(r,to[n][0].second+to[n][1].second+to[n][2].second):r;
	}
	return val2;
}
int main(){
	int n=Read();
	for(int i=2;i<=n;i++){
		int w=Read();to[w].push_back(make_pair(i,Read()));
	}
	printf("%u",dfs(1,0,0));
	return 0;
}
```

---


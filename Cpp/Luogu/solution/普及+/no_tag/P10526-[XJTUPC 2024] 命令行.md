# [XJTUPC 2024] 命令行

## 题目描述

有 $n$ 个两两互不相同的仅由小写字符构成的命令字符串 $t_i$ ($1 \leq i \leq n$)，你需要实现一个支持命令补全的命令行。

你的输入区是一个字符串 $s$，他可以接受小写字母 $\text{'a'-'z'}$ 和 $\text{Tab}$ 键 (以 $\text{'T'}$ 表示)，$\text{Enter}$ 键 (以 $\text{'E'}$ 表示)，$\text{Backspace}$ 键 (以 $\text{'B'}$ 表示)。规则如下所述:

1. 当你接受小写字符 $c$，将把 $c$ 追加到输入区字符串 $s$ 的末尾。

1. 当你接受 $\text{Backspace}$ 键，将尝试删除最后一个字符:
   - 如果输入区字符串 $s$ 为空，则不进行任何操作。
   - 如果输入区字符串 $s$ 非空，则丢弃 $s$ 末尾的字符。
1. 当你接受 $\text{Tab}$ 键，将会对 $s$ 进行一次智能补全，补全规则如下: 
	- 设以 $s$ 为前缀的命令字符串集合为 $T$。
   - 如果 $T$ 为空，则不进行任何操作。
   - 如果 $T$ 非空，则把 $s$ 置为 $\text{lcp}(T)$。这里 $\text{lcp}$ 代表最长公共前缀，含义是最长的，是 $T$ 中每一个字符串前缀的字符串。

1. 当你接受 $\text{Enter}$ 键，将会试图执行命令 $s$: 
	- 如果存在命令字符串 $t_i = s$，则输出命令编号 $i$。
   - 如果不存在命令字符串 $t_i = s$，则输出 $-1$。
   - 无论是否执行成功，清空输入区 $s$。
   
给定你接受到的输入串 $p$，你需要输出每个 $\text{Enter}$ 键执行的结果。

## 说明/提示

初始时，输入区字符串$s=""$。

输入 $\text{'k'}$ 后，输入区字符串$s="k"$。

输入 $\text{'T'}$ 后，进行智能匹配。此时 $T=\{"kill","killall"\}$，$\text{lcp}(T)="kill"$。故输入区字符串$s="kill"$。

输入 $\text{'B'}$ 后，输入区字符串$s="kil"$。

输入 $\text{'l'}$ 后，输入区字符串$s="kill"$。

输入 $\text{'E'}$ 后，因为 $t_1=s$，所以应该输出 $1$。

## 样例 #1

### 输入

```
7 40
kill
killall
rm
rmdir
ifconfig
ifdown
ll
kTBlEkTaTEiTcBdTElTExjtuTExjtuBBBBBrTdTE
```

### 输出

```
1 2 6 7 -1 4 ```

# 题解

## 作者：0tAp (赞：5)

题目链接：[P10526 [XJTUPC2024] 命令行](https://www.luogu.com.cn/problem/P10526)


------------
理解题意之后，不难想到我们可以利用字典树来维护这些信息。

我们先将 $\text{T}$ 操作放一边，对于剩下的操作而言，我们只需在字典树的模板下稍稍记录每次**最后一个节点所代表的编号即可。**

因此这题的难度其实是在 $\text{T}$ 操作上，我们要思考如何得到一个最长前缀，关于这点我们可以利用**类似链表跳转的思想**来解决，我们可以将每个节点的父节点和其跳转到的节点求出来，对于跳转操作而言，如果该节点大小大于 $1$ 的话我们需要不断向下遍历，直到子树大小刚好为 $1$，此时我们便令其父节点的跳转指向该节点，**通俗点来说就是求出我们补全时需要跳到哪个字串。**

当需要删除字符时，我们只需看看**能否跳转到其父节点即可**。

当存入的字符多于我们命令字符的长度时，我们要实时维护新节点的父节点。

解决以上问题后就可以快乐 coding 了！！！


------------
代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
const int N=1e6+10;

int n,m;
int t[N][30],fa[5*N],siz[N];
int id[N],nxt[N];
int idx=1;
char str[N*5];
char opt[N*5];

int read(char x){
    return x-'a';
}

void add(char str[],int x){
    int p=0,len=strlen(str);
    rep(i,0,len-1){
        int u=read(str[i]);
        if(!t[p][u]){
        	t[p][u]=idx++;
        	fa[t[p][u]]=p;
        	siz[p]++;
		}
        p=t[p][u];
    }
    id[p]=x;
}

int ask(int p){
    return id[p]==0?-1:id[p];
}

void modify(int p){
    nxt[p]=p;
    if(siz[p]==1){
    	rep(i,0,25){
    		if(t[p][i]){
    			modify(t[p][i]);
    			if(!id[p])nxt[p]=nxt[t[p][i]];
    			break;
			}
		}	
	}
    if(siz[p]>1){
    	rep(i,0,25){
    		if(t[p][i]){
    			modify(t[p][i]);
			}
		}
	}
}

signed main(){
    scanf("%lld%lld",&n,&m);
    rep(i,1,n){
        cin>>str;
        add(str,i);
    }
    cin>>opt;
    modify(0);
    int now_id=0;
    rep(i,0,m-1){
        if(opt[i]=='E'){
            printf("%lld ",ask(now_id));
            now_id=0;
        }
        else if(opt[i]=='T'){
        	if(nxt[now_id])now_id=nxt[now_id];
        }
        else if(opt[i]=='B'){
			now_id=(now_id!=0)?fa[now_id]:now_id;
        }
        else {
			if(now_id>=idx){
				fa[now_id+1]=now_id;
				now_id++;
			}
			else if(!t[now_id][read(opt[i])]){
				fa[idx]=now_id;
				now_id=idx;
			}
			else now_id=t[now_id][read(opt[i])];
        }	
    }
    return 0;
}
```

---

## 作者：Imken (赞：2)

题意：实现一个包括 Tab 补全、Backspace 功能的简易 shell 的部分功能（只需找到要执行哪一条指令）。

因为实现 Tab 补全需要找到很多字符串最长公共前缀，然后你会发现用字典树去维护这个东西好像还挺方便的。具体而言，可在字典树上一直跳到符合条件（即，这个点之后的第一个分岔点或者有命令的点）的点，但是这样会超时。然后我们发现每个节点 $u$ 跳到的点 ${\rm next}_u$ 是固定的，然后它是可以深搜预处理出来的，处理完后直接跳就好了。

对于 Backspace 操作，给每一个节点维护一个父亲就好啦。

然后对于不在树上的输入串我们也可以给他搬到树上，这样维护起来会很容易。

```cpp
struct Node {
	Node* child[26] = { nullptr };
	Node* fa = nullptr;
	Node* nxt = nullptr;
	int cmdid = -1;
};

auto root = new Node;

void insert(int x, const string &s)
{
	auto cur = root;
	for (auto ch : s) {
		if (!cur->child[ch - 'a']) {
			cur->child[ch - 'a'] = new Node;
			cur->child[ch - 'a']->fa = cur;
		}
		cur = cur->child[ch - 'a'];
	}
	cur->cmdid = x;
}

Node* cal_nxt(Node* u)
{
	int size = 0;
	for (int i = 0; i < 26; i++) size += !!u->child[i];
	if (size == 1 && u->cmdid == -1) {
		for (int i = 0; i < 26; i++) {
			if (u->child[i]) {
				return u->nxt = cal_nxt(u->child[i]);
			}
		}
		// Never goes here
		return nullptr;
	}
	for (int i = 0; i < 26; i++) {
		if (u->child[i]) {
			cal_nxt(u->child[i]);
		}
	}
	return u->nxt = u;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	string cmd;
	for (int i = 1; i <= n; i++) {
		cin >> cmd;
		insert(i, cmd);
	}
	cal_nxt(root);
	char ch;
	Node* cur = root;
	for (int i = 1; i <= m; i++) {
		cin >> ch;
		if (ch == 'T') {
			cur = cur->nxt;
		} else if (ch == 'B') {
			if (cur->fa) cur = cur->fa;
		} else if (ch == 'E') {
			cout << cur->cmdid << ' ';
			cur = root;
		} else {
			if (!cur->child[ch - 'a']) {
				Node* x = new Node;
				x->nxt = x;
				x->fa = cur; 
				cur->child[ch - 'a'] = x; 
			}
			cur = cur->child[ch - 'a'];
		}
	}
}
```

---

## 作者：Null_h (赞：2)

## 前言

不错的字典树模拟题。

## 思路

一次性将所有模式串给出，还要实现智能补全，不难想到使用字典树，并在字典树上每一个节点记录它在**补全后应该跳到的节点编号**。

在建完树后再处理这个补全信息，可以使用 DFS，不是难点。

对于命令的处理：

我们用一个变量记录当前在字典树上的位置，注意如果字典树上已经没有该节点了，我们可以用比字典树最大编号更大的编号来表示。

同时引入 fa 数组以处理 Backspace 操作，若当前节点已经超出字典树了，我们同样往下赋值并保证 fa 的正确性。

Tab 直接跳，Enter 用字典树上的标记直接回答。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct hbr{
	int to,son[26],end,siz;
}t[1000010];
int fa[5000010];
int h[1000010];
int d=1;
void insert(string s,int id){
	int p=0;
	for(char v:s){
		int c=v-'a';
		if(!t[p].son[c]){
			t[p].son[c]=d++;
			fa[t[p].son[c]]=p;
			t[p].siz++;	//用于 DFS 时使用
		}
		p=t[p].son[c];
	}
	t[p].end=id;
}
void dfs(int p){
	t[p].to=p;
	if(t[p].siz==1){
		for(int i=0;i<26;i++){
			if(t[p].son[i]){
				dfs(t[p].son[i]);
				if(!t[p].end)t[p].to=t[t[p].son[i]].to;
                		//该判断对应 kill 和 killall 的情况
				break;
			}
		}
	}else if(t[p].siz>1){
		for(int i=0;i<26;i++){
			if(t[p].son[i]){
				dfs(t[p].son[i]);
			}
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n,m;
	cin>>n>>m;
	string s;
	for(int i=1;i<=n;i++){
		cin>>s;
		insert(s,i);
	}
	dfs(0);
	cin>>s;
	int p=0;
	for(char c:s){
		if(c=='T'){
			if(t[p].to){
				p=t[p].to;
			}
		}else if(c=='B'){
			if(p!=0){ //不是fa[p]!=0
				p=fa[p];
			}
		}else if(c=='E'){
			if(t[p].end){
				cout<<t[p].end<<' ';
			}else{
				cout<<"-1 ";
			}
			p=0;
		}else{
			if(p>=d){
				fa[p+1]=p;//同样维护 fa
				p++;	
			}else if(!t[p].son[c-'a']){
				fa[d]=p;
				p=d;
			}else{
				p=t[p].son[c-'a'];
			}
		}
	}
	return 0;
}
```

---

## 作者：minstdfx (赞：2)

签到题，按题意模拟即可。

具体实现上，对于当前坐标维护当前字符串 $S$ 在指令串构成的 trie 树上的最低祖先 $p$ 以及 $|S|-\operatorname{dep}_p$，为了维护 Tab 操作我们需要记录每一个点子树内深度最小的分叉点，即**有超过一个儿子或自己是某指令串的结束处**的点。

然后随便维护就做完了，也没什么细节。
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int maxn=1e6+9;
struct node
{
	int ch[26],nxt,cnt=0,fa=-2,endpos=-1;
}tr[maxn];
int rt=0,ncnt=0;
void insert(char s[],int id)
{
	int u=rt;
	for(char *p=s;*p;++p)
	{
		if(!tr[u].ch[(*p)-'a']) tr[u].ch[(*p)-'a']=++ncnt;
		tr[tr[u].ch[(*p)-'a']].fa=u;
		++tr[u].cnt;
		u=tr[u].ch[(*p)-'a'];
	}
	++tr[u].cnt;
	tr[u].endpos=id;
}
int dfs(int u)
{
	int sc=0;
	for(int i=0;i<26;++i) sc+=!!tr[u].ch[i];
	if(!sc) return tr[u].nxt=u;
	if(sc>1 || ~tr[u].endpos)
	{
		for(int i=0;i<26;++i)
			if(tr[u].ch[i])
				dfs(tr[u].ch[i]);
		return tr[u].nxt=u;
	}
	for(int i=0;i<26;++i)
		if(tr[u].ch[i])
			return tr[u].nxt=dfs(tr[u].ch[i]);
	return 114514;
}
int npos=0,blen=0,n,m;
char s[5000009];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>s,insert(s,i);
	tr[0].nxt=dfs(0);
	cin>>s;
	for(int i=0;i<m;++i)
	{
		if(s[i]=='E')
		{
			if(blen) printf("-1 ");
			else printf("%d ",tr[npos].endpos);
			npos=blen=0;
			continue;
		}
		if(s[i]=='T')
		{
			if(!blen) npos=tr[npos].nxt;
			continue;
		}
		if(s[i]=='B')
		{
			if(blen) --blen;
			else if(npos) npos=tr[npos].fa;
			continue;
		}
		if(blen || !tr[npos].ch[s[i]-'a']) ++blen;
		else npos=tr[npos].ch[s[i]-'a'];
	}
	return 0;
}
```

---

## 作者：reductt (赞：1)

~~一眼丁真~~鉴定为：字典树

首先发现 $\text{B,E,a-z}$ 的命令都是好维护的，$\text{B}$ 命令对每个点记一个父亲值即可，但 $\text{T}$ 操作要想一下。

记字典树上点 $x$ 发生 $\text{T}$ 操作时要跳到的点为 $nxt_x$，就会发现一个显然的性质，对于点 $x$，它的 $nxt$ 值是它子树内深度最小的，有两个及以上儿子的点。~~证明显然~~

如果 $\text{a-z}$ 时要加之前不存在的点，要动态维护，详见代码。时间复杂度 $O(n+m)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define u128 __int128
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FOR_(i,a,b) for(int i=b;i>=a;i--)
#define fir first
#define sec second
namespace FastIO{
    int buf[100]={0},p=0;
    int rd(){
        int x=0,f=1;char c=getchar();
        while(c<'0'||'9'<c){if(c=='-')f=-1;c=getchar();}
        while('0'<=c&&c<='9')x=x*10+c-'0',c=getchar();
        return x*f;
    }void write(int x){
        if(!x){putchar('0');return;}
        if(x<0){x=-x;putchar('-');}
        while(x)buf[++p]=x%10,x/=10;
        while(p)putchar(buf[p--]+'0');
    }
};
#define rd FastIO::rd
#define write FastIO::write
typedef pair<int,int> pii;
typedef unsigned long long ull;
const int M=5e6+10;
char str[M];
int son[M][26],deg[M],fa[M],id[M],nxt[M],tot=1;
void insert(int x){
    int p=1;
    for(int i=0;str[i];i++){
        int c=str[i]-'a';
        if(!son[p][c])son[p][c]=++tot,deg[p]++,fa[tot]=p;
        p=son[p][c];
    }
    id[p]=x;
}
void dfs(int p){
    nxt[p]=p;
    FOR(i,0,25)if(son[p][i]){
        dfs(son[p][i]);
        if(deg[p]<=1&&!id[p])nxt[p]=nxt[son[p][i]];
    }
}
signed main(){
    int n=rd(),m=rd();
    FOR(i,1,n){
        scanf("%s",str);
        insert(i);
    }
    dfs(1);
    scanf("%s",str);
    for(int i=0,now=1;str[i];i++){
        char opt=str[i];
        if(opt=='E')write(id[now]==0?-1:id[now]),putchar(' '),now=1;
        else if(opt=='B')now=(now==1?now:fa[now]);
        else if(opt=='T')now=nxt[now];
        else{
            int c=opt-'a';
            if(now>tot)fa[now+1]=now,now++;
            else if(!son[now][c])fa[tot+1]=now,now=tot+1;
            else now=son[now][c];
        }
    }
    return 0;
}
```

---

## 作者：CaoSheng_zzz (赞：1)

### 题目大意

1. 对于一个字符串 $ s $ 在输入的最后一行读入的字符，如个字符不为 $ E $，$ T $，$ B $ 那么这一个字符就添加至字符串 $ s $ 的末尾。

2. 对于操作 $ B $ 那么执行删除字符串 $ s $ 的最后一个字符，如果 $ s $ 为空那么跳过这个操作。

3. 对于操作 $ T $ 找到一个以字符串 $ s $ 为前缀的字符串，要求这一个字符串为可以找到所有字符串当中的最长且为任意一个字符串的前缀。如果 $ s $ 没有前缀就跳过。

4. 对于操作 $ E $ 如果有一个字符串等于当前的 $ s $ 那么输出这串字符串的编号，否则输出 $ -1 $。然后将 $ s $ 清空。

### 思路

对于查询与添加字符串的维护我们有一个非常好的算法[字典树](https://oi.wiki/string/trie/)，对于每一次查询我们写一个 $ fa_i $ 表示在字典树的编号中这个标号的父亲，一个 $ end_i $ 在字典树编号中这个标号是否为一个字符串的最后一个字符，至此我们的思路完了，所以我觉得屏幕前的你可以去自己写代码了。

#### 注意
1. 对于 $ fa $ 数组与 $ end $ 数组的大小开 $ maxn $ 就行了不然会爆空间。

2. 如果根从 $ 0 $ 开始记得把 $ fa $ 数组初始化成负数。

3. $ end $ 数组也需要初始化负数，不然会答案错误

4. 输出 $ -1 $ 时记得打一个空格

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#define sc(ppt) scanf("%lld" , &ppt)
#define ll long long
#define int long long
#define prt printf
using namespace std;

const int maxn = 1e6 + 1;
int n , m;
int bj = 0 , pop = 0;
char s[5000001];
struct Tree{
	int next[maxn][30] , cnt = 0 , fa[maxn * 20] , end[maxn] , t[maxn];
	int csh(char cap){ return cap - 'a' + 1;}
	void insert(string A , int num){
		int u = 0 , len = A.size();
		for(int i=0 ; i<len ; i++){
			int v = csh(A[i]);
			if(! next[u][v]) next[u][v] = ++ cnt;
			fa[next[u][v]] = u;
			u = next[u][v];
		}
		end[u] = num;
	}
	int get_ans(int u){ // dfs
		int res = 0;
		for(int i=1 ; i<=26 ; i++){
			res += !! next[u][i];	
		}
		if(res > 1 || ~end[u]){
			for(int i=1 ; i<=26 ; i++) if(next[u][i]) get_ans(next[u][i]);
			return t[u] = u;
		}
		for(int i=1 ; i<=26 ; i++){
			if(next[u][i]) return t[u] = get_ans(next[u][i]);
		}
		return 202521;
	}
}tree; 
	
signed main(){
	sc(n) ; sc(m) ; memset(tree.fa , -2 , sizeof tree.fa) ; memset(tree.end , -1 , sizeof tree.end); 
	for(int i=1; i<=n ; i++){
		cin >> s ;
		tree.insert(s , i);	
	}
	tree.t[0] = tree.get_ans(0);
	cin >> s;
	for(int i=0 ; i<m ; i++){
		if(s[i] == 'E'){
			if(bj) prt("-1 ");
			else prt("%lld " , tree.end[pop]);
			pop = bj = 0;
		}
		else if(s[i] == 'T'){
			if(! bj) pop = tree.t[pop];
		}
		else if(s[i] == 'B'){
			if(bj) -- bj;
			else if(pop) pop = tree.fa[pop];	
		} 
		else{
			if(bj || !tree.next[pop][tree.csh(s[i])]) ++bj;
			else pop = tree.next[pop][tree.csh(s[i])];
		}
	}
	return 0;
}

```

---


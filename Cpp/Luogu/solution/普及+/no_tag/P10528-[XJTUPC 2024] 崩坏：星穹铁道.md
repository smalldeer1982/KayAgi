# [XJTUPC 2024] 崩坏：星穹铁道

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/7urblttd.png)

Corycle 喜欢玩一个由米哈游自主研发的一款回合制战斗游戏------《崩坏：星穹铁道》。这片银河中有名为「星神」的存在，他们造就现实，抹消星辰，在无数「世界」中留下他们的痕迹。你将由此探索新的文明，结识新的伙伴，在无数光怪陆离的「世界」与「世界」之间展开新的冒险。所有你想知道的，都将在群星中找到答案。


## 题目描述

在游戏《崩坏：星穹铁道》中，你的队伍里会有四名角色轮流行动，所有角色共享用于施放战技的战技点。当战斗开始时，你会获得 $k$ 个战技点，且战技点的上限为 $5$ 个。每个角色行动时可选择进行普通攻击或者施放战技，进行普通攻击时会为全队增加一个战技点，当战技点达到上限时也可以进行普通攻击，但是此时不回复战技点。角色施放战技需要消耗一个战技点，当没有战技点时只能进行普通攻击而不可释放技能。

Corycle 想成为星穹铁道高手，为此他需要对自己的配队了如指掌。由于角色有多种职业，同时为了方便对角色类型进行定位，他把角色的行动模式分为了三种类型：

1. 当角色行动时，只会进行普通攻击。

2. 当角色行动时，若有战技点不少于 $1$ 则必定释放技能，否则进行普通攻击。

3. 不对角色的行动进行限制。

现在 Corycle 开始了一场战斗，他想知道当队伍中的四名角色一共行动 $n$ 次时，可能会有多少种不同的行动方案。我们称两个行动方案不同，当且仅当存在至少一个回合中，两个方案里角色行为不同。这个答案可能是一个很大的数，所以请将答案对 $998244353$ 取模。

## 样例 #1

### 输入

```
12 1
2 3 2 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
8 5
2 1 1 3
```

### 输出

```
4
```

# 题解

## 作者：Ratio_Y (赞：29)

upd on 6.5 更改了递推式错误以及部分格式错误。

------------
# 崩坏：星穹铁道
[题链](https://www.luogu.com.cn/problem/P10528) 这么**简单**做不对不许玩崩铁！

### 题目大意
给你行动的总次数 $n$ 和初始战技点数量 $k$，以及编队里四名角色的行动类型，求不同行动方式的方案数。

类型见题面。

### 思路
先考虑 dp，分角色类型讨论。

设 $f_{i,k}$ 表示第 $i$ 动，剩 $j$ 个点。

当 $a=1$ 时，由于角色只能打点，点数上限为 $5$，所以得到：

$$f_{i,k}= \begin{cases} f_{i-1,k-1}  (k\neq0) \\ f_{i-1,5} (k=5) \end{cases}$$

当 $a=2$ 时，角色有点耗点，没点打点，能得到：

$$f_{i,k}= \begin{cases} f_{i-1,k+1} (k\neq5) \\ f_{i-1,k-1} (k=1) \end{cases}$$

当 $a=3$ 时，角色既能打点，也能耗点，且满足战技点的范围，得到：

$$ f_{i,k}= \begin{cases} f_{i-1,k+1} (k\neq 5) \\ f_{i-1,k-1} (k\neq0) \\f_{i-1,k} (k=5) \end{cases}$$

结合三者，即可得到状态转移方程。

那么复杂度为 $O(n)$，题目中 $n\le10^{18}$，~~男蚌~~。

怎么加速？矩阵快速幂！

矩阵怎么找？简单。把不同情况的转移结果按表格列出来，发现：标 $1$ 的是转移结果，也就是动后的点数。

结果如下：

$$
T_1=\left[
\begin{matrix}
0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 1 \\
\end{matrix}
\right]
$$

$$
T_2=\left[
\begin{matrix}
0 & 1 & 0 & 0 & 0 & 0 \\
1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
\end{matrix}
\right]
$$

$$
T_3=\left[
\begin{matrix}
0 & 1 & 0 & 0 & 0 & 0 \\
1 & 0 & 1 & 0 & 0 & 0 \\
0 & 1 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 0 & 1 & 1 \\
\end{matrix}
\right]
$$

其中 $T_i$ 表示 $i$ 类型的角色。

再根据 dp，定义 $C_i=C_{i-1}\times T_{a_i}$。

这样快速幂结果为 $ans=C_4^{\lfloor {\frac{n}{4}} \rfloor}\times C_{n \,mod \,4}$。

答案为 $\sum_{i=0}^5 ans_{0,i}$。

### 注意

开 `long long` 啊！

### code：
```
const int mod=998244353;
ll n,k,hksr;
ll a[5];
struct rmm
{
    ll a[6][6];
    rmm(){memset(a,0,sizeof a);}
}T[4],unit,B;
rmm operator*(const rmm &a,const rmm &b)
{//重载矩阵乘
    rmm ans;
    fo(i,0,5)
        fo(j,0,5)
            fo(k,0,5)
                ans.a[i][j]=(ans.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;
    return ans;
}
namespace Wisadel
{
    rmm Wqp(rmm a,ll b)
    {//矩阵快速幂
        rmm ans;
        ans=unit;
        while(b)
        {
            if(b&1ll)
                ans=ans*a;
            a=a*a;
            b>>=1ll;
        }
        return ans;
    }
    short main()
	{
        n=qr,k=qr;
        T[1].a[0][1]=T[1].a[1][2]=T[1].a[2][3]=T[1].a[3][4]=T[1].a[4][5]=T[1].a[5][5]=1;
        T[2].a[1][0]=T[2].a[0][1]=T[2].a[2][1]=T[2].a[3][2]=T[2].a[4][3]=T[2].a[5][4]=1;
        T[3].a[0][1]=T[3].a[1][2]=T[3].a[2][3]=T[3].a[3][4]=T[3].a[4][5]=T[3].a[5][5]=1,
        T[3].a[1][0]=T[3].a[0][1]=T[3].a[2][1]=T[3].a[3][2]=T[3].a[4][3]=T[3].a[5][4]=1;
        unit.a[0][0]=unit.a[1][1]=unit.a[2][2]=
        unit.a[3][3]=unit.a[4][4]=unit.a[5][5]=1;
        B=unit;
        //unit 是1矩阵（初始矩阵） 乘任何矩阵等于它本身
        fo(i,1,4)
            a[i]=qr,B=B*T[a[i]];
        rmm R,ans;
        R.a[0][k]=1;
        ans=R*Wqp(B,n/4);
        for(int i=0;i<n%4;i++)
            ans=ans*T[a[i%4+1]];
        //这是少算的那部分
        fo(i,0,5)
            hksr=(hksr+ans.a[0][i])%mod;
        printf("%lld\n",hksr);
        //Honkai: Star Rail！
        return Ratio;
	}
}
```
完结撒花~~火~~~

---

## 作者：Melo_qwq (赞：17)

~~要不是因为某游戏我才不做呢。~~

# 题目大意

略。

注意不初始化会爆。

注意开宏定义不是好习惯。

# 题目实现

难得的矩阵乘法快速幂的好题。

首先想到 dp，很好想到 $dp_{i,j}$ 表示第 $i$ 轮有 $j$ 个战技点的方案数。

三种情况不难搞出转移方程：

- 第一种（普攻，说明比上次回了一个点，注意 $5$ 个战技点的时候就不能再回了，既然上次回点了，那这次就不可能是 $0$ 了）：

$$
dp_{i,j\in[1,4]\cap \Z}=dp_{i-1,j-1}
$$

$$
dp_{i,5} = dp_{i-1,4}+dp_{i-1,5}
$$

- 第二种（如果没点就会回点，否则耗点，众所周知，你没点的时候不能使用战技）：

$$
dp_{i,0} =dp_{i-1,1} 
$$

$$
dp_{i,1}= dp_{i-1,0}+dp_{i-1,2}
$$

$$
dp_{i,j\in[2,4]\cap \Z}=dp_{i-1,j+1}
$$

- 第三种（那么上次可能是普攻也可能是战技）：

$$
dp_{i,0}=dp_{i-1,1}
$$

$$
dp_{i,j\in[1,4]\cap \Z} = dp_{i-1,j-1}+dp_{i-1,j+1}
$$

$$
dp_{i,5}=dp_{i-1,4}+dp_{i-1,5}
$$

如上是一个朴素的解法，交上去，你会得到不知道是几分的高分。

毕竟 $n_{\max}=10^{18}$，所以要用矩阵乘法加快速幂优化。

那么对于每种情况构造一个矩阵，使得 $dp_{i-1}\times X=dp_i$。

直接给出构造：

- 第一种：

$$
\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 &0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 &1   \end{bmatrix}
$$

- 第二种：

$$
\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0   \end{bmatrix}
$$

- 第三种：

$$
\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 & 0 & 1 \\ 0 & 0 & 0 & 0 & 1 & 1   \end{bmatrix}
$$

奇技淫巧：用 excel 把要转移的放到行，用来转移的放到列，很容易求出矩阵。

我们发现每次都是四个人轮流来，所以把四个人每次打包到一起看做一次，最后不整除余下的部分单独算（用龟速乘）。

最后的答案是战技点剩余 $0$ 到 $5$ 的总和。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
#define int long long
int n ,k ,a[5] ;
struct Matrix {
	int a[6][6] ;
	Matrix () {
		memset (a ,0 ,sizeof (a)) ;
	}
} pre[4] ,unit ,ans ; // 貌似答案的 dp 数组可以只开成一维？
#define mod 998244353
Matrix operator * (const Matrix &X ,const Matrix &Y) {
	Matrix Z ;
	rep (k ,0 ,5 ,1) {
		rep (i ,0 ,5 ,1) {
			rep (j ,0 ,5 ,1) {
				Z.a[i][j] = (Z.a[i][j] + X.a[i][k] * Y.a[k][j] % mod) % mod ;
			}
		}
	}
	return Z ;
}
namespace shin {
	template <typename T> inline void read (T &x) {
		x = 0 ;
		char ch = getchar () ;
		while (! isdigit (ch)) {
			ch = getchar () ;
		}
		while (isdigit (ch)) {
			x = (x << 1) + (x << 3) + (ch xor 48) ;
			ch = getchar () ;
		}
	}
	inline Matrix qpow (Matrix ans ,int y) {
		Matrix base ;
		base.a[0][0] = base.a[1][1] = base.a[2][2] = base.a[3][3] = base.a[4][4] = base.a[5][5] = 1 ;
		while (y) {
			if (y & 1ll) base = base * ans ;
			ans = ans * ans ;
			y >>= 1ll ;
		}
		return base ;
	}
	inline void init () {
		ans.a[0][k] = 1 ;
		pre[1].a[0][1] = pre[1].a[1][2] = pre[1].a[2][3] = pre[1].a[3][4] = pre[1].a[4][5] = pre[1].a[5][5] = 1 ;
		pre[2].a[0][1] = pre[2].a[1][0] = pre[2].a[2][1] = pre[2].a[3][2] = pre[2].a[4][3] = pre[2].a[5][4] = 1 ;
		pre[3].a[0][1] = pre[3].a[1][0] = pre[3].a[1][2] = pre[3].a[2][1] = pre[3].a[2][3] = pre[3].a[3][2] = pre[3].a[3][4] = pre[3].a[4][3] = pre[3].a[4][5] = pre[3].a[5][4] = pre[3].a[5][5] = 1 ;
		unit.a[0][0] = unit.a[1][1] = unit.a[2][2] = unit.a[3][3] = unit.a[4][4] = unit.a[5][5] = 1 ;
	}
}
signed main () {
	shin :: read (n) ,shin :: read (k) ;
	shin :: init () ;
 	rep (i ,1 ,4 ,1) {
		shin :: read (a[i]) ;
		unit = unit * pre[a[i]] ;
	}
	ans = ans * shin :: qpow (unit ,n >> 2) ;
	rep (i ,0 ,n % 4 - 1 ,1) {
		ans = ans * pre[a[i + 1]] ;
	}
	cout << (ans.a[0][0] + ans.a[0][1] + ans.a[0][2] + ans.a[0][3] + ans.a[0][4] + ans.a[0][5]) % mod << '\n' ;
	return 0 ;
}
```

---

## 作者：nnn233 (赞：17)

# P10528 [XJTUPC2024] 崩坏：星穹铁道
## 前置知识：[矩阵快速幂](https://www.luogu.com.cn/problem/P3390)
## DP
先考虑朴素 DP。  
设状态 $dp_{i,j}$ 表示在第 $i$ 次行动后剩余 $j$ 个战技点的不同方案数。  
初始时无人行动（也就是行动 $0$ 次），有 $k$ 个战技点，所以初始状态为 $dp_{0,k}=1$。  
因为四名角色轮流行动，所以第 $i$ 次行动角色的行为模式为 $a_{i\bmod4}$，有以下转移方程。
- 当 $a_{i\bmod4}=1$ 时：
$$dp_{i,1}=dp_{i-1,0}$$
$$dp_{i,2}=dp_{i-1,1}$$
$$dp_{i,3}=dp_{i-1,2}$$
$$dp_{i,4}=dp_{i-1,3}$$
$$dp_{i,5}=dp_{i-1,4}+dp_{i-1,5}$$
- 当 $a_{i\bmod4}=2$ 时：
$$dp_{i,0}=dp_{i-1,1}$$
$$dp_{i,1}=dp_{i-1,2}+dp_{i-1,0}$$
$$dp_{i,2}=dp_{i-1,3}$$
$$dp_{i,3}=dp_{i-1,4}$$
$$dp_{i,4}=dp_{i-1,5}$$
- 当 $a_{i\bmod4}=3$ 时:
$$dp_{i,0}=dp_{i-1,1}$$
$$dp_{i,1}=dp_{i-1,0}+dp_{i-1,2}$$
$$dp_{i,2}=dp_{i-1,1}+dp_{i-1,3}$$
$$dp_{i,3}=dp_{i-1,2}+dp_{i-1,4}$$
$$dp_{i,4}=dp_{i-1,3}+dp_{i-1,5}$$
$$dp_{i,5}=dp_{i-1,4}+dp_{i-1,5}$$
最后的答案为：
$$dp_{n,0}+dp_{n,1}+dp_{n,2}+dp_{n,3}+dp_{n,4}+dp_{n,5}$$
时间复杂度 $O(n)$。  
代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5;
const int M=998244353;
long long n,dp[N][6];
int k,a[4];
int main(){
    cin>>n>>k;
    cin>>a[1]>>a[2]>>a[3]>>a[0];
    dp[0][k]=1;
    for(int i=1;i<=n;i++){
        if(a[i%4]==1){
            dp[i][1]=dp[i-1][0];
            dp[i][2]=dp[i-1][1];
            dp[i][3]=dp[i-1][2];
            dp[i][4]=dp[i-1][3];
            dp[i][5]=dp[i-1][4]+dp[i-1][5];
        }else if(a[i%4]==2){
            dp[i][0]=dp[i-1][1];
            dp[i][1]=dp[i-1][2]+dp[i-1][0];
            dp[i][2]=dp[i-1][3];
            dp[i][3]=dp[i-1][4];
            dp[i][4]=dp[i-1][5];
        }else if(a[i%4]==3){
            dp[i][0]=dp[i-1][1];
            dp[i][1]=dp[i-1][0]+dp[i-1][2];
            dp[i][2]=dp[i-1][1]+dp[i-1][3];
            dp[i][3]=dp[i-1][2]+dp[i-1][4];
            dp[i][4]=dp[i-1][3]+dp[i-1][5];
            dp[i][5]=dp[i-1][4]+dp[i-1][5];
        }
        dp[i][0]%=M,dp[i][1]%=M,dp[i][2]%=M,dp[i][3]%=M,dp[i][4]%=M,dp[i][5]%=M;
    }
    cout<<(dp[n][0]+dp[n][1]+dp[n][2]+dp[n][3]+dp[n][4]+dp[n][5])%M;
    return 0;
}
```
当然这么简单肯定是无法通过这题的，毕竟 $1\le n\le 1\times 10^{18}$ 呢。
## 正解
我们可以使用矩阵来加速递推。   
我们想要构造出一个转移矩阵 $G$，使得状态矩阵 $DP_{i-1}\times G=DP_{i}$。  
但本题不同角色行为模式不同，所以我们根据行为模式分别构造三个转移矩阵来进行状态转移。  
根据上文 DP 的状态转移方程分别构造出三个转移矩阵。  
$T_1=\begin{bmatrix}0&1&0&0&0&0\\0&0&1&0&0&0\\0&0&0&1&0&0\\0&0&0&0&1&0\\0&0&0&0&0&1\\0&0&0&0&0&1\end{bmatrix}$  

$T_2=\begin{bmatrix}0&1&0&0&0&0\\1&0&0&0&0&0\\0&1&0&0&0&0\\0&0&1&0&0&0\\0&0&0&1&0&0\\0&0&0&0&1&0\end{bmatrix}$  

$T_3=\begin{bmatrix}0&1&0&0&0&0\\1&0&1&0&0&0\\0&1&0&1&0&0\\0&0&1&0&1&0\\0&0&0&1&0&1\\0&0&0&0&1&1\end{bmatrix}$

简单讲一下这些矩阵我是如何根据转移方程推导出来的，用 Excel 表格将初始矩阵和目标矩阵列出来，之后根据转移方程填表即可。  
例如
$$dp_{i,5}=1 \times dp_{i-1,4}+1 \times dp_{i-1,5}$$
先找到 $dp_{i,5}$ 列，再去找 $dp_{i-1,4}$ 与 $dp_{i-1,5}$ 行，在对应的位置填上系数。
![矩阵推导](https://cdn.luogu.com.cn/upload/image_hosting/dj1qp19p.png)

现在我们已经推导出了三种不同行为模式的转移矩阵，轮到角色行动时只需要将当前状态矩阵乘上对应当前角色行为模式的转移矩阵即可。  
初始矩阵与上面 DP 时无异。   
下面举一组样例来帮助理解。
~~~
13 1
2 3 2 1
~~~
设初始矩阵为 $R$，在这组数据中：  
$R=\begin{bmatrix}0&1&0&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\\0&0&0&0&0&0\end{bmatrix}$   
$DP_{n}=RT_2T_3T_2T_1T_2T_3T_2T_1T_2T_3T_2T_1T_2$  
因为矩阵乘法满足**结合律**，所以可以用**快速幂**算法来加速运算，因为四个角色行动的**次序**是确定的，所以我们考虑将 $4$ 个角色各行动 $1$ 次捆绑成一组，在最后将少乘的部分补上，即：
$$DP_{n}=RB^{ \lfloor n/4 \rfloor }\prod^{n\bmod4}_{i=1}T_{a_{i}}$$
例如上面这组样例中 $B=T_2T_3T_2T_1$，$DP_{n}=RB^{ \lfloor n/4 \rfloor }T_2$  
时间复杂度 $O(\log n)$，有一个 $216$ 的常数。  
**运算时记得取模！**  
## 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=998244353;
struct Mat{
    int a[6][6];
    Mat(){memset(a,0,sizeof(a));}//矩阵初始化
}T[4],B,E;
Mat operator*(const Mat &X,const Mat &Y){//矩阵乘法重载运算符
    Mat Z;
    for(int i=0;i<=5;i++)
        for(int j=0;j<=5;j++)
            for(int k=0;k<=5;k++)
                Z.a[i][j]=(Z.a[i][j]+X.a[i][k]*Y.a[k][j]%M)%M; 
    return Z;
}
int n,k,a[5];
Mat Mqpow(Mat bas,int y){//矩阵快速幂
	Mat X;
	X=E; 
    while(y){
        if(y&1ll)X=X*bas;
        bas=bas*bas;
        y>>=1ll;
    }
    return X;
}
signed main(){
    //三种行为模式矩阵的初始化 
    T[1].a[0][1]=T[1].a[1][2]=T[1].a[2][3]=T[1].a[3][4]=T[1].a[4][5]=T[1].a[5][5]=1;
    T[2].a[1][0]=T[2].a[0][1]=T[2].a[2][1]=T[2].a[3][2]=T[2].a[4][3]=T[2].a[5][4]=1;
    T[3].a[0][1]=T[3].a[1][2]=T[3].a[2][3]=T[3].a[3][4]=T[3].a[4][5]=T[3].a[5][5]=1,T[3].a[1][0]=T[3].a[0][1]=T[3].a[2][1]=T[3].a[3][2]=T[3].a[4][3]=T[3].a[5][4]=1;
    E.a[0][0]=E.a[1][1]=E.a[2][2]=E.a[3][3]=E.a[4][4]=E.a[5][5]=1;//单位矩阵E，任何矩阵乘单位矩阵E都等于原矩阵
    B=E;
    cin>>n>>k;
    for(int i=1;i<=4;i++){
        cin>>a[i];
        B=B*T[a[i]];//将四名角色对应的转移矩阵捆绑成一组 
    }
    Mat R;
    R.a[0][k]=1;//设置初始矩阵 
    Mat ans=R*Mqpow(B,n/4);
    for(int i=0;i<n%4;i++)
        ans=ans*T[a[i%4+1]];//乘上少乘的部分 
    cout<<(ans.a[0][0]+ans.a[0][1]+ans.a[0][2]+ans.a[0][3]+ans.a[0][4]+ans.a[0][5])%M;
    return 0;
}
~~~
------------
### 闲话
~~这种水题都切不掉不许玩《崩坏：星穹铁道》。~~

---

## 作者：xixisuper (赞：17)

# P10528 [XJTUPC2024] 崩坏：星穹铁道 题解

一道好玩的题，~~作为崩铁老玩家直接就点进来了~~。

做完之后逛了一圈题解，发现我的做法不大一样，赶紧来发一篇题解。

本题解采用倍增算法。

## 思路：

根据题意，有 $4$ 名角色依次进行操作，共操作 $n$ 回合，我们定义**四回合为一轮**（即四名角色各行动一次）。

不难发现，如果限定最开始时的战技点个数，那么进行一轮操作后会得到很多种行动方案，而这行动方案个数我们可以直接利用 dfs 暴力进行求解。

我们定义一个操作**整变换**，用 $C_i$ 来表示，$i$ 表示**最初战技点个数**。每一个 $C_i$ 对应着一个六元组 $(a_0,a_1,a_2,a_3,a_4,a_5)$，其中 $a_j$ 表示**从初始状态经过一轮的操作后，得到的剩余战技点个数为 $j$ 个的行动方案数**。

我们以题目中给定的样例 $2$ 举例进行说明：

```
8 5 
2 1 1 3
```

我们如果令初始时战绩点个数为 $5$，则在进行了一轮操作后，会出现两种不同的行动方案，如下图所示。

![图1](https://cdn.luogu.com.cn/upload/image_hosting/4r7283eu.png?x-oss-process=image/resize,m_lfit,h_680,w_900)

根据上述定义，即可以表示为 $C_5=(0,0,0,0,1,1)$。

我们令 $C_{i,j}$ 代表 $C_i$ 对应着的 $a_j$，例如上例中的 $C_{5,1}=0$，$C_{5,4}=1$。

进一步的，**我们令 $C_{i,j,k}$ 表示初始战绩点个数为 $i$ 个，经过 $2^k$ 次整变换后，得到剩余战技点个数为 $j$ 的行动方案数**。那么根据定义，所有的 $C_{i,j,0}$ 即为角色经过一次整变换后得到的操作方案数，我们可以直接由 dfs 暴力求得。

求从 $i$ 经 $2^k$ 次整变换得到 $j$，可以等效转换成先从 $i$ 经 $2^{k-1}$ 次整变换得到 $p$，再让 $p$ 经过 $2^{k-1}$ 次整变换得到 $j$ 的行动方案总数（这一步需要用到乘法原理），所以我们只需枚举 $p$ 即可。

于是我们就能够根据上述方法，递推出所有的 $C_{i,j,k}$。

$$
C_{i,j,k}=\sum_{p=0}^6 C_{i,p,k-1} \times C_{p,j,k-1}
$$

由于初始战技点个数是确认的，于是我们也可以直接用一个六元组 $R=(b_0,b_1,b_2,b_3,b_4,b_5)$ 来表示状态（定义与 $C$ 类似）。在最开始时，除了输入给定的 $k$ 那一位（即 $b_k$）为 $1$，其余都是 $0$。之后，将整变换的次数求出（即为 $\lfloor \frac{n}{4} \rfloor$），**将其进行二进制拆分，利用类似快速幂的思路更新六元组 $R$（由于 $R$ 的定义与 $C$ 定义的相似性，我们更新 $R$ 时可以利用更新 $C_{i,j,k}$ 时的思路），直至解出对应的最后状态**。

至于还剩下一部分不足以进行整变换的回合，我们依然可以使用 dfs 进行暴力求解，而最后的答案就为 $\sum_{i=0}^{6} R_i$。

单次 dfs 的时间复杂度未知，但上限不会超过 $2^4$，故其实际占比很小，可以直接视为是小常数，忽略不计，于是总时间复杂度就为预处理所有的 $C_{i,j,k}$ 与二进制拆分 $\lfloor \frac{n}{4} \rfloor$ 了，单次递推的时间复杂度依旧为常数，所以总算法的时间复杂度为 $O(\log n)$。

## 代码：

文中的 $C_{i,j,k}$ 在代码中体现为 ```ch[i][k][j]```，**注意代码中 $i,j,k$ 的顺序与上述题解中是不同的，但是对应 $i,j,k$ 的含义相同**，所以读者阅读代码时需注意。

```cpp
#include <iostream>
#define ll long long 
using namespace std;
const ll MOD=998244353;
ll ch[10][100][10]; 
ll n,kkk,tp[5];
void dfs(ll step,ll kt,ll now){
	if(step==5){
		ch[kt][0][now]++;
		return;
	}
	if(tp[step]==1) dfs(step+1,kt,min(now+1,5LL));
	if(tp[step]==2){
		if(now>0) dfs(step+1,kt,now-1);
		else dfs(step+1,kt,min(now+1,5LL));
	}
	if(tp[step]==3){
		if(now>0) dfs(step+1,kt,now-1);
		dfs(step+1,kt,min(now+1,5LL));
	}
}
ll dfs2(ll step,ll dep,ll now){
	if(step==dep+1) return 1;
	ll ret=0;
	if(tp[step]==1) ret+=dfs2(step+1,dep,min(now+1,5LL));
	if(tp[step]==2){
		if(now>0) ret+=dfs2(step+1,dep,now-1);
		else ret+=dfs2(step+1,dep,min(now+1,5LL));
	}
	if(tp[step]==3){
		if(now>0) ret+=dfs2(step+1,dep,now-1);
		ret+=dfs2(step+1,dep,min(now+1,5LL));
	}
	return ret;
}
ll R[10];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>kkk;
	cin>>tp[1]>>tp[2]>>tp[3]>>tp[4];
	for(ll i=0;i<=5;i++) dfs(1,i,i);
	//ch_i_k_j 表示以 i 开头，进行 2^k 次整变换，以 j 结束的情况总数 
	for(ll k=1;(1LL<<k)<=n;k++){
		for(ll i=0;i<=5;i++){
			for(ll j=0;j<=5;j++){
				//计算ch[i][k][j]
				for(ll p=0;p<=5;p++){
					ch[i][k][j]+=ch[i][k-1][p]*ch[p][k-1][j];
					ch[i][k][j]%=MOD;
				}
			}
		}
	}
	R[kkk]=1;
	ll gt=0,n_zheng=n/4,sheng=n%4;
	while((1LL<<gt)<=n_zheng) gt+=1;
	while(n_zheng){
		while((1LL<<gt)>n_zheng) gt-=1;
		//变换 2^gt 次
		ll nans[10]={0,0,0,0,0,0,0,0,0,0}; 
		for(ll i=0;i<=5;i++){
			for(ll j=0;j<=5;j++){
				nans[j]+=R[i]*ch[i][gt][j];
				nans[j]%=MOD;
			}
		}
		for(ll i=0;i<=5;i++) R[i]=nans[i];
		n_zheng-=(1LL<<gt);
	}
	ll ans=0;
	for(ll i=0;i<=5;i++){
		ans+=R[i]*dfs2(1,sheng,i);
		ans%=MOD;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：oyoham (赞：8)

### Problem
[P10528](https://www.luogu.com.cn/problem/P10528)
### Solution
观察题目可以发现，可以将执行到第 $i$ 步时剩余 $k$ 个战技点的可行方案数为 $f_{i,k}$，考虑 $dp$。
### Proof
考虑 $a=1$ 的情况。（以下省略第一维）  
角色只能普攻（回战技点），所以由 $f_k$ 可以推出 $f_{k+1}$。又因为战技点上限为 $5$ 个，所以 $f_5$ 只能推 $f_5$。  
我们就得到其中一个转移方程：$f_k = [k!=0] f_{i-1,k-1} + [k=5] f_{i-1,k}$。

考虑 $a=2$ 的情况。（以下省略第一维）  
角色有战技点时只能用战技（用战技点），所以由 $f_k$ 可以推出 $f_{k-1}$。又因为没有战技点时只能普攻（回战技点），所以 $f_0$ 只能推 $f_1$。   
我们就得到另外一个转移方程：$f_k = [k!=5]f_{i-1,k+1}+[k=1]f_{i-1,k-1}$。

考虑 $a=3$ 的情况。（以下省略第一维）  
角色既能普攻（回战技点），有战技点时也能用战技（用战技点），所以由 $f_k$ 可以推出 $f_{k+1}$ 与 $f_{k-1}$。又因为战技点上限为 $5$ 个，所以 $f_5$ 只能推 $f_5$ 与 $f_4$。  
我们就得到最后一个转移方程：$f_k = [k!=0]f_{i-1,k-1} + [k=5]f_{i-1,k} + [k!=5]f_{i-1,k+1}$。

综上，我们可以得到：
$$f_{i,k} = \begin{cases}
  [k!=0]f_{i-1,k-1} + [k=5]f_{i-1,k} & a = 1\\
  [k!=5]f_{i-1,k+1}+[k=1]f_{i-1,k-1} & a = 2 \\
  [k!=0]f_{i-1,k-1} + [k=5]f_{i-1,k} + [k!=5]f_{i-1,k+1} & a = 3
\end{cases}$$
时间复杂度 $O(n)$。
### Optimization
看一眼 $n$，$n \le 10^{18}$，过不了一点。  
考虑用矩阵快速幂优化。  
定义如下矩阵：
$$ B_1 = \begin{bmatrix}
	0 & 1 & 0 & 0 & 0 & 0 \\
	0 & 0 & 1 & 0 & 0 & 0 \\
	0 & 0 & 0 & 1 & 0 & 0 \\
	0 & 0 & 0 & 0 & 1 & 0 \\
	0 & 0 & 0 & 0 & 0 & 1 \\
	0 & 0 & 0 & 0 & 0 & 1 \\
\end{bmatrix}$$
$$ B_2 = \begin{bmatrix}
	0 & 1 & 0 & 0 & 0 & 0 \\
	1 & 0 & 0 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 & 0 & 0 \\
	0 & 0 & 1 & 0 & 0 & 0 \\
	0 & 0 & 0 & 1 & 0 & 0 \\
	0 & 0 & 0 & 0 & 1 & 0 \\
\end{bmatrix}$$
$$ B_3 = \begin{bmatrix}
	0 & 1 & 0 & 0 & 0 & 0 \\
	1 & 0 & 1 & 0 & 0 & 0 \\
	0 & 1 & 0 & 1 & 0 & 0 \\
	0 & 0 & 1 & 0 & 1 & 0 \\
	0 & 0 & 0 & 1 & 0 & 1 \\
	0 & 0 & 0 & 0 & 1 & 1 \\
\end{bmatrix}$$
就可以用 $B_i$ 来表示攻击方式 $a=i$ 的角色。  
再定义 $C_i=C_{i-1} \times B_{a_i}$ 且 $C_0=I$。  
这样结果矩阵 $F=C_4^{\lfloor \frac{n}{4} \rfloor} \times C_{n \bmod 4}$。  
答案为 $ \sum_{i=0}^{5} F_{k,i}$。
### Code
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
inline ll read(){
	ll x=0;
	short f=1;
	char c=getchar();
	while(c>57||c<48){
		if(c==45) f=-1;
		c=getchar();
	}
	while(c<58&&c>47){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void write(ll x){
	if(x<0ll) putchar(45),x=~x+1;
	if(x>9ll) write(x/10);
	putchar(x%10|48);
}
#define mod 998244353
struct M{
	int a[7][7];
	M(){memset(a,0,sizeof a);}
	M(int x){
		memset(a,0,sizeof a);
		for(int i=0;i<6;i++) a[i][i]=x;
	}
};
M operator*(M a,M b){
	M ans;
	for(int i=0;i<=5;i++){
		for(int j=0;j<=5;j++){
			for(int k=0;k<=5;k++){
				ans.a[i][j]+=a.a[i][k]*b.a[k][j];
				ans.a[i][j]%=mod;
			}
		}
	}
	return ans;
}
void operator*=(M &a,M b){a=a*b;}
M fp(M a,ll b){
	M ans(1);
	M base=a;
	while(b){
		if(b&1) ans*=base;
		base*=base;
		b>>=1;
	}
	return ans;
}
ll n=read(),k=read();
int a[6]={0,read(),read(),read(),read()};
M b[4];
M c[5];
#define set(x,y,z) b[x].a[y][z]=1;
signed main(){
	c[0]=fp(c[0],0);
	for(int i=0;i<=5;i++){
		set(1,i,min(5ll,i+1));
		set(3,i,min(5ll,i+1));
	}
	set(2,0,1);
	for(int i=1;i<=5;i++){
		set(2,i,i-1);
		set(3,i,i-1);
	}
	for(int i=1;i<=4;i++){
		c[i]=c[i-1]*b[a[i]];
	}
	b[0]=c[4];
	b[0]=fp(b[0],n>>2);
	b[0]*=c[n&3];
	int ans=0;
	for(int i=0;i<=5;i++){
		ans=(ans+b[0].a[k][i])%mod;
	}
	write(ans);
}
```

---

## 作者：std_qwq (赞：7)

### 思路
我们可以~~试着玩一把模拟宇宙~~分析一下游戏的性质，四人轮流操作，可以编为一回合，可以发现：
- 每一个回合的结束是下一回合的开始。
- 每个回合的玩法有相似性。
- 每一个回合能打出的操作数量与**它的起始技能点** 与 **要求的结束技能点**有关。

考虑把答案分成两个部分：一个是前面完整的 $\left \lfloor n/4 \right \rfloor $ 个回合，另一个是后面不完整的 $n \space \bmod \space 4$ 个操作（请注意“操作”与“回合”的区别），利用相似性求出两个部分再合并。

可以针对**起始技能点数**和**终止技能点数**在**一个回合**内 dp，不足一个回合的部分也可以 dp。

###  合并答案的方法：

如果我们得到了 $n-1$ 回合内从 $i$ 点能量到 $j$ 点能量的方案 $f_{n-1,i,j}$，$1$ 个回合内从 $j$ 到 $k$ 的方案数 $f_{1,j,k}$，那么 $n$ 个回合，从 $i$ 到 $k$ 的方案数 $f_{n,i,k}$ 则是：

前 $n-1$ 回合由 $i$ 开始，到 $[0,5]$ 的所有 $j$ 结束，再从 $j$ 开始到 $k$ 结束的方案数总和。

则有：

$ {f_{n,i,k}=\textstyle \sum_{j=0}^{5}f_{n-1,i,j} \times f_{1,j,k}} $。

注意到该式与矩阵乘法的形式相似，考虑矩阵快速幂。

### 转移方程--得到转移矩阵的方法

我们需要得出 $f_{1,i,j}$（称为矩阵 $A_{i,j}$），即一个回合内从 $i\in [0,5]$ 个技能点到 $j \in [0,5]$ 个技能点结束的方案数。

使用简单的线性 dp，设 $c_{k,i}$ 为：第 $k$ 人操作后的技能点数为 $i$ 的方案数，有：

$a_{k}=1$ 时，$c_{k,i}=c_{k-1,i} \times [i=5]+c_{k-1,i-1} \times [i  \neq 0]$。

$a_{k}=2$ 时，$c_{k,i}=c_{k-1,i+1} \times [i \neq 5]+c_{k-1,i-1} \times [i=1]$。

$a_{k}=3$ 时，$c_{k,i}=c_{k-1,i-1} \times [i \neq 0]+c_{k-1,i} \times [i=5]+c_{k-1,i+1} \times [i \neq 5]$。

对 $[0,5]$ 的每个 $i$，依次初始化 $c_{0,i}=1$，然后 dp，有 $A_{i,j}={c_{4,j}}$。

对不足一个回合的部分，矩阵快速幂后假设还有 $n'=n \space \bmod \space 4$ 个人，用 dp 的方法类似求出剩余一个回合从 $i$ 开始，$j$ 结束的方案数矩阵 $A'_{i,j}$，有 $A'_{i,j}={c_{n',j}}$。

那么 $Ans=A^{\left \lfloor n/4 \right \rfloor }  \times A'$ 中，$\sum_{i=0}^{5} Ans_{k,i}$ 就是答案。

### 参考代码
```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i=a;i<=b;i++)
#define Honkai_Star_Rail return
#define Start 0
using namespace std;
const int N=10,M=998244353;
typedef long long ll;
ll f[N][N],A[N][N],n;
int k;
int a[5];
void dp(ll f[N][N],int x,int start){//给定初始化,求出最终的一回合内情况
    //cout<<start<<endl;
    ll c[5][N];//多次初始化
    //memcpy(c[0],f[start],sizeof f);
    memset(c,0,sizeof c);
    c[0][start]=1;
    F(i,1,x)
        F(j,0,5){
            if(a[i]==1){
                if(j!=0)c[i][j]=(c[i][j]+c[i-1][j-1])%M;
                if(j==5)c[i][j]=(c[i-1][j]+c[i][j])%M;
            }
            if(a[i]==2){
                if(j!=5)c[i][j]=(c[i][j]+c[i-1][j+1])%M;
                if(j==1)c[i][j]=(c[i][j]+c[i-1][j-1])%M;
            }
            if(a[i]==3){
                if(j!=0)c[i][j]=(c[i][j]+c[i-1][j-1])%M;
                if(j==5)c[i][j]=(c[i][j]+c[i-1][j])%M;
                else c[i][j]=(c[i][j]+c[i-1][j+1])%M;
            }
        }
        /*
    F(i,1,n){
        F(j,0,5)
            printf("c[%d][%d] = %lld, ",i,j,c[i][j]);
        cout<<endl;
        }
    */
    memcpy(f[start],c[x],sizeof c[x]);
}

void mul(ll a[N][N],ll b[N][N]){
    ll c[N][N];
    memset(c,0,sizeof c);
    F(i,0,5)
        F(j,0,5)
            F(k,0,5)
                c[i][j]=(c[i][j]+a[i][k]*b[k][j])%M;
    memcpy(a,c,sizeof c);
}
void mulself(ll b[N][N]){
    ll c[N][N];
    memset(c,0,sizeof c);
    F(i,0,5)
        F(j,0,5)
            F(k,0,5)
                c[i][j]=(c[i][j]+b[i][k]*b[k][j])%M;
    memcpy(b,c,sizeof c);
}
void set_one(ll a[N][N]){
    F(i,0,5)a[i][i]=1;
}
void qmi(ll n){
    set_one(f);
    while(n){
        if(n&1)mul(f,A);
        mulself(A);
        n>>=1;
    }
}
int main(){
    cin>>n>>k;
    for(int i=1;i<=4;i++)cin>>a[i];
    F(i,0,5)dp(A,4,i);
    /*
    F(i,0,5){
        F(j,0,5)
            printf("A[%d][%d] = %lld,",i,j,A[i][j]);
        cout<<endl;
        }
    */
    qmi(n/4);
    set_one(A);
    F(i,0,5)dp(A,n%4,i);
    mul(f,A);
    ll ans=0;
    F(i,0,5)ans=(ans+f[k][i])%M;
    cout<<ans<<endl;
    Honkai_Star_Rail Start ;//崩坏：星穹铁道，启动！！！
}
```
若有不严谨之处欢迎大家指教qwq。

---

## 作者：liuenyin (赞：3)

## 题目大意

给定 $4$ 名角色，有三种不同的行动类型，$n$ 次行动，求有多少种行动方案。

## 思路

先考虑最基本的动态规划，$f_{i,j}$ 代表第 $i$ 次行动，剩余 $j$ 个战技点的不同方案数。

如果 $a=1$，即当前角色为类型 $1$，若当前战技点满了（$j=5$）不会增加一个战技点，否则会增加，即：

$$f_{i,j} = \begin{cases} f_{i-1,j-1} & j>0 \\f_{i-1,5} & j=5\end{cases} $$

同理，可得 $a=2$ 和 $a=3$ 时的转移方程：

$$f_{i,j} = \begin{cases} f_{i-1,j+1} & j<5 \\f_{i-1,0} & j=1\end{cases} $$

$$f_{i,j} = \begin{cases} f_{i-1,j-1} & j>0 \\f_{i-1,5} & j=5 \\ f_{i-1,j+1}& j<5 \end{cases} $$

发现 $i$ 这一维在转移时只取到了 $i-1$，因此可以使用滚动数组优化，但是 DP 的时间复杂度是 $O(n)$ 的，无法通过 $n\leq 10^{18}$。对于这一部分，需要使用 $O(\log n)$ 的算法，因此想到使用矩阵加速递推。

根据转移方程，可以得到转移矩阵：

若 $a=1$，则转移矩阵为：
$$ \begin{bmatrix} 
0 & 1 & 0 & 0 & 0 & 0\\ 
0 & 0 & 1 & 0 & 0 & 0\\ 
0 & 0 & 0 & 1 & 0 & 0\\ 
0 & 0 & 0 & 0 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 1\\ 
\end{bmatrix}$$ 

若 $a=2$，则转移矩阵为：
$$ \begin{bmatrix} 
0 & 1 & 0 & 0 & 0 & 0\\ 
1 & 0 & 0 & 0 & 0 & 0\\ 
0 & 1 & 0 & 0 & 0 & 0\\ 
0 & 0 & 1 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 1 & 0\\ 
\end{bmatrix}$$ 

若 $a=3$，则转移矩阵为：
$$ \begin{bmatrix} 
0 & 1 & 0 & 0 & 0 & 0\\ 
1 & 0 & 1 & 0 & 0 & 0\\ 
0 & 1 & 0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0 & 1 & 0\\
0 & 0 & 0 & 1 & 0 & 1\\
0 & 0 & 0 & 0 & 1 & 1\\ 
\end{bmatrix}$$ 

由于战斗过程是四个人轮流发动攻击，并且每个人所对应的矩阵可能不同，因此可以将四次行动绑在一起作为一回合，建立一个新的矩阵作为回合的转移矩阵，对这个新矩阵进行快速幂，后面再将不满一回合的操作另外统计进去就可以了（另外，还需要构造一个初始矩阵，进行一次乘法初始矩阵除 $(0,k)$ 为 $1$ 外其余全为 $0$）。最后枚举剩余的战技点，累加答案即可。

## 代码实现

（出于习惯代码里矩阵的下标是从 $1$ 开始的，因此对应下标要 $+1$）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=10+5,M=998'244'353;
struct matrix{
    int sizeh,sizel;
    ll val[N][N];
    matrix(){
        sizeh=0,sizel=0;
        memset(val,0,sizeof val);
    }
    matrix(int X){//单位方阵
        sizeh=sizel=X;
        for(int i=1;i<=X;i++){
            for(int j=1;j<=X;j++){
                if(i==j)val[i][j]=1;
                else val[i][j]=0;
            }
        }
    }
    matrix operator*(const matrix &A)const{
        matrix ret;
        ret.sizeh=this->sizeh;
        ret.sizel=A.sizel;
        for(int i=1;i<=this->sizeh;i++){
            for(int j=1;j<=A.sizel;j++){
                for(int k=1;k<=this->sizel;k++){
                    ret.val[i][j]+=(this->val[i][k]*A.val[k][j])%M;
                    ret.val[i][j]%=M;
                }
            }
        }
        return ret;
    }
};
matrix qpow(matrix A,ll k){
    matrix ret(A.sizeh);
    while(k){
        if(k&1)ret=ret*A;
        A=A*A;
        k>>=1;
    }
    return ret;
}
ll n,k;
int a[N]; 
matrix t[N];//三种类型的转移矩阵
ll cnt;
int main(){
    cin>>n>>k;
    //这里实现下标是从1开始的
    t[1].sizeh=t[1].sizel=t[2].sizeh=t[2].sizel=t[3].sizeh=t[3].sizel=6;
    t[1].val[1][2]=t[1].val[2][3]=t[1].val[3][4]=t[1].val[4][5]=t[1].val[5][6]=t[1].val[6][6]=1;
    t[2].val[1][2]=t[2].val[2][1]=t[2].val[3][2]=t[2].val[4][3]=t[2].val[5][4]=t[2].val[6][5]=1;
    t[3].val[1][2]=t[3].val[2][3]=t[3].val[3][4]=t[3].val[4][5]=t[3].val[5][6]=t[3].val[6][6]=1;
    t[3].val[2][1]=t[3].val[3][2]=t[3].val[4][3]=t[3].val[5][4]=t[3].val[6][5]=1;
    matrix ans(6),start;
    start.val[1][k+1]=1;//初始矩阵
    start.sizeh=start.sizel=6;
    for(int i=1;i<=4;i++){
        cin>>a[i];
        ans=ans*t[a[i]];
    }    
    ans=start*qpow(ans,n/4);
    n%=4;
    for(int i=1;i<=n;i++)ans=ans*t[a[i]];
    for(int i=1;i<=6;i++)cnt=(cnt+ans.val[1][i])%M;
    cout<<cnt;
    return 0;
}
```

---

## 作者：Lyco_Reco (赞：3)

本题显然要用 dp 求解。

先考虑朴素 dp，设 $dp(i,j)$ 表示考虑前 $i$ 轮行动，行动结束后战技点剩余 $j$ 个的方案数，接下来分类讨论得到状态转移方程。

当 $a_{i}=1$ 时：
$$
dp(i,j) = \begin{cases}
  dp(i-1,j-1) & 0 < j < 5 \\
  dp(i-1,j) + dp(i-1,j-1) & j = 5 \\
\end{cases}
$$

当 $a_{i}=2$ 时：
$$
dp(i,j) = \begin{cases}
  dp(i-1,j+1) & 0 \le j < 5 \land j \ne 1 \\
  dp(i-1,j-1) + dp(i-1,j+1) & j = 1 \\
\end{cases}
$$

当 $a_{i}=3$ 时：
$$
dp(i,j) = \begin{cases}
  dp(i-1,j+1) & j = 0 \\
  dp(i-1,j-1) + dp(i-1,j+1) & 0 < j < 5 \\
  dp(i-1,j) & j = 5 \\
\end{cases}
$$

其中 $i$ 这一维可以滚动数组优化，时间复杂度 $O(n)$。

朴素 dp 代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
int n,k,a[7],dp[2][7],ans;
const int mod=998244353;
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	void MAIN(){
		n=rd();
		k=rd();
		for(int i=1;i<=4;i++){
			a[i]=rd();
		}
		dp[0][k]=1;
		for(int i=1;i<=n;i++){
			fill(dp[i&1],dp[i&1]+6,0);
			for(int j=0;j<=5;j++){
				if(a[((i-1)&3)+1]==1){
					if(j==5){
						dp[i&1][j]+=dp[(i&1)^1][j];
					}
					if(j>0){
						dp[i&1][j]+=dp[(i&1)^1][j-1];
					}
				}
				else if(a[((i-1)&3)+1]==2){
					if(j<5){
						dp[i&1][j]+=dp[(i&1)^1][j+1];
					}
					if(j==1){
						dp[i&1][j]+=dp[(i&1)^1][j-1];
					}
				}
				else{
					if(j>0){
						dp[i&1][j]+=dp[(i&1)^1][j-1];
					}
					if(j<5){
						dp[i&1][j]+=dp[(i&1)^1][j+1];
					}
					if(j==5){
						dp[i&1][j]+=dp[(i&1)^1][j];
					}
				}
				dp[i&1][j]%=mod;
			}
		}
		for(int i=0;i<=5;i++){
			ans+=dp[n&1][i];
			ans%=mod;
		}
		wrt(ans);
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}
```

考虑正解。

注意到 $n \le 10^{18}$，考虑使用矩阵快速幂优化转移。

根据朴素 dp 的状态转移方程不难得到转移矩阵：

当 $a_i = 1$ 时：
$$
\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 & 1\end{bmatrix}
$$

当 $a_i = 2$ 时：
$$
\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0\end{bmatrix}
$$

当 $a_i = 3$ 时：
$$
\begin{bmatrix} 0 & 1 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 & 0 & 1 \\ 0 & 0 & 0 & 0 & 1 & 1\end{bmatrix}
$$

由于不同的 $a_i$ 对应的转移矩阵不同，而队伍中四名角色又是轮流行动的，我们就可以将连续的四个 $a_i$ 看作一个循环节，对循环节的乘法操作使用矩阵快速幂优化，再暴力乘上剩余的部分。具体地，设 $ p = \lfloor \frac{n}{4}\rfloor $，上述三个矩阵分别为 $x_1$，$x_2$，$x_3$，循环节矩阵 $B = \prod_{i = 1}^{4}  \ x_{a[i]} $，则答案矩阵为：
$$
C = B^p \times \prod_{i = 1}^{n-p \times 4}  \ x_{a[i]}
$$

最后答案为：
$$
ans = \sum_{i = 0}^{5} C_{0,i}
$$
时间复杂度 $O(\log{n})$。

正解代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
int n,k,a[10],cnt,res;
const int mod=998244353;
struct matrix{
	int c[7][7];
	matrix(){memset(c,0,sizeof(c));}
	friend matrix operator*(matrix a,matrix b){
		matrix t;
		for(int i=1;i<=6;i++){
			for(int j=1;j<=6;j++){
				for(int k=1;k<=6;k++){
					t.c[i][j]+=a.c[i][k]*b.c[k][j];
					t.c[i][j]%=mod;
				}
			}
		}
		return t;
	}
}A,x[4],B,ans; 
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	void ksm(int k){
		for(int i=1;i<=6;i++){
			A.c[i][i]=1;
		}
		for(;k;k>>=1,B=B*B){
			if(k&1){
				A=A*B;
			}
		}
	}
	void MAIN(){
		n=rd();
		k=rd();
		for(int i=1;i<=4;i++){
			a[i]=rd();
		}
		x[1].c[1][2]=x[1].c[2][3]=x[1].c[3][4]=x[1].c[4][5]=x[1].c[5][6]=x[1].c[6][6]=1;
		x[2].c[1][2]=x[2].c[2][1]=x[2].c[3][2]=x[2].c[4][3]=x[2].c[5][4]=x[2].c[6][5]=1;
		x[3].c[1][2]=x[3].c[2][1]=x[3].c[2][3]=x[3].c[3][2]=x[3].c[3][4]=x[3].c[4][3]=x[3].c[4][5]=x[3].c[5][4]=x[3].c[5][6]=x[3].c[6][5]=x[3].c[6][6]=1;
		for(int i=1;i<=6;i++){
			B.c[i][i]=1;
		}
		for(int i=1;i<=4;i++){
			B=B*x[a[i]];
		}
		int cnt=n&3;
		ans.c[1][k+1]=1;
		ksm(n/4);
		ans=ans*A;
		for(int i=1;i<=cnt;i++){
			ans=ans*x[a[i]];
		}
		for(int i=1;i<=6;i++){
			res+=ans.c[1][i];
			res%=mod;
		}
		wrt(res);
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}
```

---

## 作者：bluewindde (赞：1)

求方案数，分多种情况，不难想到 DP。

设 $dp_{i, j}$ 表示已经行动 $i$ 次，剩余战技点个数为 $j$ 的方案数，容易得到以下转移方程。

$a_i = 1$ 时，有

$$
dp_{i, j} = \begin{cases}
0, &j = 0, \\
dp_{i - 1, j - 1}, &1 \leqslant j \leqslant 4, \\
dp_{i - 1, j - 1} + dp_{i - 1, j}, &j = 5. \\
\end{cases}
$$

$a_i = 2$ 时，有

$$
dp_{i, j} = \begin{cases}
dp_{i - 1, j + 1}, &j = 0 \lor 2 \leqslant j \leqslant 4, \\
dp_{i - 1, j - 1} + dp_{i - 1, j + 1}, &j = 1, \\
0, &j = 5. \\
\end{cases}
$$

$a_i = 3$ 时，有

$$
dp_{i, j} = \begin{cases}
dp_{i - 1, j + 1}, &j = 0, \\
dp_{i - 1, j - 1} + dp_{i - 1, j + 1}, &1 \leqslant j \leqslant 4, \\
dp_{i - 1, j - 1} + dp_{i - 1, j}, &j = 5. \\
\end{cases}
$$

初始条件

$$dp_{0, k} = 1$$

答案

$$\sum\limits_{i = 0}^5 dp_{n, i}$$

发现本题 $n$ 可以达到 $10^{18}$，并且转移方程形式固定，显然要使用矩阵乘法优化转移，将上面的三个转移分别写成矩阵 $T_1, T_2, T_3$。将角色行动一个循环视为一个单元，一个单元内的转移 $T$ 可以用 $T_1, T_2, T_3$ 表示，矩阵乘法优化完整的单元之间的转移，最后将剩余的行动次数补足即可。即总体的转移形如

$$T^{\lfloor \frac n 4 \rfloor} \prod\limits_{i = 1}^{n \mod 4} T_{a_i}$$

时间复杂度 $O(k \log n)$，$k$ 是矩阵乘法的常数。

```cpp
#include <array>
#include <iostream>

typedef long long ll;

using namespace std;

const int mod = 998244353;

typedef array<ll, 6> vec;
typedef array<vec, 6> matrix;

inline ll operator*(const vec &v1, const vec &v2) {
    ll ret = 0;
    for (size_t i = 0; i < v1.size(); ++i)
        ret = (ret + v1[i] * v2[i] % mod) % mod;
    return ret;
}
inline vec operator*(const vec &v, const matrix &mat) {
    vec ret{};
    for (size_t i = 0; i < v.size(); ++i)
        for (size_t j = 0; j < mat.size(); ++j)
            ret[i] = (ret[i] + v[j] * mat[j][i] % mod) % mod;
    return ret;
}
inline matrix operator*(const matrix &m1, const matrix &m2) {
    matrix ret{};
    for (size_t i = 0; i < m1.size(); ++i)
        for (size_t j = 0; j < m2[0].size(); ++j)
            for (size_t k = 0; k < m2.size(); ++k)
                ret[i][j] = (ret[i][j] + m1[i][k] * m2[k][j] % mod) % mod;
    return ret;
}
inline matrix operator^(matrix mat, ll k) {
    matrix ret{};
    for (size_t i = 0; i < ret.size(); ++i)
        ret[i][i] = 1;
    while (k) {
        if (k & 1)
            ret = ret * mat;
        mat = mat * mat;
        k >>= 1;
    }
    return ret;
}

ll n, k;
int a[5];
matrix tr[4], trans;

static inline void solve() {
    tr[1][0][1] = tr[1][1][2] = tr[1][2][3] = tr[1][3][4] = tr[1][4][5] = tr[1][5][5] = 1;
    tr[2][5][4] = tr[2][4][3] = tr[2][3][2] = tr[2][2][1] = tr[2][1][0] = tr[2][0][1] = 1;
    tr[3][0][1] = tr[3][1][2] = tr[3][2][3] = tr[3][3][4] = tr[3][4][5] = tr[3][5][5] =
        tr[3][5][4] = tr[3][4][3] = tr[3][3][2] = tr[3][2][1] = tr[3][1][0] = 1;
    for (size_t i = 0; i < trans.size(); ++i)
        trans[i][i] = 1;
    cin >> n >> k;
    for (int i = 1; i <= 4; ++i) {
        cin >> a[i];
        trans = trans * tr[a[i]];
    }
    vec ans{};
    ans[k] = 1; // 初始化
    ans = ans * (trans ^ (n / 4)); // 整块的转移
    for (int i = 1; i <= n % 4; ++i) // 散块的转移
        ans = ans * tr[a[i]];
    int sum = 0;
    for (auto x : ans) // 统计答案
        sum = (sum + x) % mod;
    cout << sum << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```

---


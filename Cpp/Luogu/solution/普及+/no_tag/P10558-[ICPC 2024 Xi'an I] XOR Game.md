# [ICPC 2024 Xi'an I] XOR Game

## 题目描述

Alice 和 Bob 正在进行一场游戏。

在他们面前有一个多重集 $\{a_i\}$，其中包含非负整数，还有一个整数 $x$。在游戏开始前，$a$ 中的每个数字都是 $0$ 或 $2^i(0\le i<k)$。

这是一场回合制游戏，Alice 先开始。在一个人的回合中，他或她将从 $a$ 中选择一个整数。设这个数为 $p$。然后这个人可以选择是否执行 $x\gets x\oplus p$，接着从 $a$ 中移除 $p$。这里，操作 $\oplus$ 表示按位异或。

Alice 想让 $x$ 尽可能大，而 Bob 想让 $x$ 尽可能小。

你是一个旁观者，想知道最终的 $x$ 值。然而，$a$ 的大小是一个巨大的数字。形式上，对于所有 $0\le i<k$，有 $b_i$ 个数在 $a$ 中的值为 $2^i$，并且有 $z$ 个数的值为 $0$。但你仍然想挑战这个不可能的问题。

如果 Alice 和 Bob 足够聪明，请输出最终的 $x$ 值。

## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
1 0
3```

### 输出

```
1```

## 样例 #2

### 输入

```
2 0
2 1```

### 输出

```
11```

## 样例 #3

### 输入

```
2 0
2 2```

### 输出

```
00```

# 题解

## 作者：yywlp (赞：2)

虽然蒟蒻不是很会做博弈论的题，但是这题的结论还是很显然的。

先看只有一个数的情况：假设这个数有**奇数**个，那不难发现 Alice 是最后一个操作，那他总有办法把这个数得到，如果有**偶数**个那 Bob 就是最后一个，那他总有办法把这个数消除。

**换言之：最后一个取这个数的人决定这个数的去留。**

又会发现对于一个数如果有奇数个，那把这个数拿完之后下一个先操作的人会轮换，偶数个则不会。

那么我们分类讨论：

### situation 1：有奇数个的数有奇数个

不难发现把个数是奇数的数拿完下一次操作就会变成 Bob，那他一定会把一个偶数变成奇数，那这个数 Alice 就可以得到。又因为这个数最开始是偶数，所以拿完之后又是 Bob 拿，那么这些有偶数个的数就都会被 Alice 得到。

那既然这样是不是只要**有奇数个的数有奇数个**就代表所有数 Alice 都可以得到呢？显然不是，如果有某个数只有 $1$ 个，那么 Bob 直接拿这个数 Alice 就肯定无法得到，所以他们会轮流把 $1$ 取完，剩下的数就都归 Alice。

### situation 2：有奇数个的数有偶数个

这个时候则与上一个情况刚好相反，如果 Alice 拿一个奇数，Bob 跟着拿一个奇数，这样奇数个数还是偶数个。如果 Alice 拿一个偶数，Bob 继续拿这个数，那这个数就还是偶数，最后一定每一个数最后一个都是 Bob 来拿的，也就是说 Alice 一个也拿不到。

不过也和上一个一样，$1$ 是特殊情况，只有 $1$ 是 Alice 有可能得到的数，所以 Alice 又会和 Bob 轮流拿 $1$，剩下的数 Alice 都得不到。

简单模拟即可，复杂度 $\Theta(n)$。

---

## 作者：pMatrix (赞：0)

## 分析
在看了许多博弈问题后，相信你一定会发现，博弈在特定情况下会有唯一解，我们便可从这里入手。

集合 $a$ 可以化简为第 $i$ 个二进制位有 $b[i]$ 个，当 $b[i]=1$ 时，下一轮的人都可以直接把这一位指定为自己想要的数（异或后删除或直接删除）；而当 $b[i]=0$ 时，这一位就无需考虑。因此，我们先储存所有 $b[i]=1$ 的二进制位，让 Alice 和 Bob 轮流取。

在分析 $b[i]>1$ 的情况前，不得不先说“$0$”的个数——$z$ 的作用，任何数异或 $0$ 都不会改变，但是会消耗一回合。因此，取“$0$”会改变取数权的所有者，并且与“$0$”的个数的奇偶性有关。

但是光考虑这一点还不够，比如下面两个例子。若 $k=1，z=1，b[0]=2$ 时，$x$ 一定等于 $1$；而 $k=1，z=1，b[0]=3$ 时，$x$ 一定等于 $0$。不难发现 $b[i]$ 的数值也对结果产生了影响，而且同样与奇偶性有关。

所以我们将所有大于 $1$ 的 $b[i]$ 加进 $z$ 中一起考虑。具体的写法可以按自己喜好。因为 Alice 代表 $1$，所以我一般会写 `z += b[i] % 2` 。为什么是 `b[i] % 2` 呢？其实很简单，因为对同一位进行偶数次的操作一定不会改变它的值，只有奇数次才有效。

还要注意，对 $b[i]=1$ 的二进制位操作后，也会改变取数的人，因此还要加上 $b[i]=1$ 的二进制位的个数（同理也可以对 $2$ 取模）。

好的，我们已经可以判断最终 $z$ 的奇偶性了，那么如何使用它呢？其实也很简单，通过上面的两个特例我们可以发现，当 $z$ 为偶数时，Bob 一定有一个策略，可以将所有 $b[i]>1$ 的二进制位设为 $0$，反之 Alice 一定可以将它们设为 $1$。

~~虽然最后的推论不是很严谨，当然你手写几组数据也能发现规律不是么。~~

## 代码
本蒟蒻比较喜欢用 STL 和 iostream，所以程序比较慢（~~不要问为什么，问就是因为懒~~）。各位大佬自己写的时候可以优化一下算法细节。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int MAXN = 1e5 + 5;
int k, z;
int x[MAXN];
vector<int> v, u;
int main()
{
	cin >> k >> z;
	for (int i = 0, a; i < k; i++)
	{
		cin >> a;
		if (a == 0)continue;
		else if (a == 1)v.push_back(i);
		else
		{
			z += a % 2;
			u.push_back(i);
		}
	}
	reverse(v.begin(), v.end());
	z += v.size();
	for (int i = 0; i < v.size(); i++)
	{
		if (i % 2 == 0)x[v[i]] = 1;
	}
	if (z & 1)for (auto i : u)
	{
		x[i] = 1;
	}
	for (int i = k - 1; i >= 0; i--)
	{
		cout << x[i];
	}
	return 0;
}
```

---

## 作者：coreyyp (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10558)
## 思路
如果 $2^i$ 的个数是 $0$ 时，怎么操作 $x$ 的这一位也一定是 $0$，因为没有任何操作可以使其变成 $1$。

考虑必然获胜的情况，发现如果存在一种数字只有一个的时候，无论谁拿到都能使这一位达到自身期望的成果，并且先后手会交替；之后考虑如果一种数字有偶数个，那么先手必败，并且不会改变先后手；如果有奇数个，先手必胜，而且改变先后手关系；如果剩下种类的数字都是偶数，那么先手必然全部失败，如果存在奇数，先手一定会希望拿一个奇数改变当前先后手性质，后手同理，那么根据奇数堆改变完先后手后，先手必然失败，填充即可。

## 核心代码
```cpp
for(int i=k;i>=1;i--)
  if(b[i]==0) a[i]=0;
  else if(b[i]==1) a[i]=m,m^=1;	
for(int i=k;i>=1;i--){
  if(b[i]<2) continue;
  if(b[i]&1) m^=1;
}
if(z&1) m^=1;
m^=1;
for(int i=1;i<=k;i++) if(b[i]>1) a[i]=m;
```

---


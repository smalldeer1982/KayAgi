# 楼兰图腾

## 题目描述

在完成了分配任务之后，西部 314 来到了楼兰古城的西部。相传很久以前这片土地上（比楼兰古城还早）生活着两个部落，一个部落崇拜尖刀（`V`），一个部落崇拜铁锹（`∧`），他们分别用 `V` 和 `∧` 的形状来代表各自部落的图腾。

西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 $n$ 个点，经测量发现这 $n$ 个点的水平位置和竖直位置是两两不同的。西部 314 认为这幅壁画所包含的信息与这 $n$ 个点的相对位置有关，因此不妨设坐标分别为 $(1,y_1),(2,y_2),\cdots,(n,y_n)$，其中 $y_1\sim y_n$ 是 $1$ 到 $n$ 的一个排列。

![](https://cdn.luogu.com.cn/upload/image_hosting/u8z4ffl9.png)

如图，图中的 $y_1=1$，$y_2=5$，$y_3=3$，$y_4=2$，$y_5=4$。

西部 314 打算研究这幅壁画中包含着多少个图腾，其中 `V` 图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关）$1\le i<j<k\le n$ 且 $y_i>y_j$, $y_j<y_k$；

而崇拜 `∧` 的部落的图腾被定义为 $1\le i<j<k\le n$ 且 $y_i<y_j$，$y_j>y_k$；

西部 314 想知道，这 $n$ 个点中两个部落图腾的数目。因此，你需要编写一个程序来求出 `V` 的个数和 `∧` 的个数。

## 说明/提示

数据范围约定

- 对于 $10\%$ 的数据 $n\le 600$；
- 对于 $40\%$ 的数据 $n\le 5000$；
- 对于 $100\%$ 的数据 $n\le 200000$，答案不超过 $2^{63} - 1$。

## 样例 #1

### 输入

```
5
1 5 3 2 4```

### 输出

```
3 4```

# 题解

## 作者：_Deer_Peach_ (赞：16)

讲一下蒟蒻的原始思路，~~就是暴力~~。

求尖刀图腾时，建一个数组分别求每个点左边和右边比该点的坐标高的点，再相乘求出由该点为中心的尖刀图腾数量。求铁锹图腾时相反，建一个数组分别求每个点左边和右边比该点的坐标低的点，再相乘求出由该点为中心的铁锹图腾数量。

具体代码如下：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200001],L[200001],R[200001],l[200001],r[200001],ans1,ans2;//L，R数组记录铁锹，l,r数组记录尖刀，ans1，ans2分别指尖刀与铁锹
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}for(int i=2;i<n;i++){
		for(int j=1;j<i;j++){
			if(a[j]>a[i])L[i]++;//统计左边比该点大的点
			if(a[j]<a[i])l[i]++;//统计左边比该点小的点
		}for(int j=i+1;j<=n;j++){
			if(a[j]>a[i])R[i]++;//统计右边比该点大的点
			if(a[j]<a[i])r[i]++;//统计右边比该点小的点
		}
	}for(int i=2;i<n;i++){
		ans1+=L[i]*R[i];//统计答案
		ans2+=l[i]*r[i];
	}cout<<ans1<<" "<<ans2;
    return 0;
} 
```

最后是不出意外的超时了，拿到了半道绿题。

现在讲下正解：[树状数组](https://www.luogu.com.cn/problem/P3368)。

这道题可以先倒序遍历序列 $a$，求出每个 $a _ i$ 后面有多少个数比它大，记为 $r _ i$。再正序遍历序列 $a$，利用树状数组求出每个 $a _ i$ 前面有多少个数比它大，记为 $l _ i$。

用数组 $t$ 来记录数值出现的次数，后面的处理与上一个的思路的处理差不多，就不仔细讲了。

代码：
```
#include<bits/stdc++.h>
#define int long long//不开long long见祖宗
using namespace std;
int n,a[200001],ans1,ans2;
int L[200001][2],R[200001][2],t[200001];//数组
int lowbit(int x){//模板
	return x&-x;
}void add(int x,int y){
    while(x<=n){
        t[x]+=y;
        x=x+lowbit(x);
    }return ;
}int ask(int x){
    int cnt=0;
    while(x){
        cnt+=t[x];
        x=x-lowbit(x);
    }return cnt;
}signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
		cin>>a[i];
    }for(int i=1;i<=n;i++){//统计数量
        L[i][0]=i-1-ask(a[i]);
        L[i][1]=ask(a[i]-1);
        add(a[i],1);
    }memset(t,0,sizeof(t));
    for(int i=n;i>=1;i--){//统计数量
        R[i][0]=n-i-ask(a[i]);
        R[i][1]=ask(a[i]-1);
        add(a[i],1);
    }for(int i=1;i<=n;i++){//处理答案
        ans1+=L[i][0]*R[i][0];
        ans2+=L[i][1]*R[i][1];
    }cout<<ans1<<" "<<ans2;
    return 0;
}
```

---

## 作者：1234567890sjx (赞：7)

考虑使用权值树状数组维护之，时间复杂度为 $O(n\log n)$。

令 $f_1$ 表示 $i$ 左边比 $a_i$ 小的数的数量，$f_2$ 表示 $i$ 左边比 $a_i$ 大的数的数量，$g_1$ 表示 $i$ 右边比 $a_i$ 小的数的数量，$g_2$ 表示 $i$ 右边比 $a_i$ 大的数的数量。则很显然两个答案分别为 $\sum\limits_{i=1}^n f_2\times g_2$ 和 $\sum\limits_{i=1}^n f_1\times g_1$。使用树状数组来快速的维护 $f_1$，$f_2$，$g_1$，$g_2$ 的值即可。时间复杂度为 $O(n\log n)$。

代码：[Link](https://www.luogu.com.cn/record/162390433)，目前已经加入代码公开计划。

---

## 作者：OIer_ACMer (赞：7)

前置知识：[树状数组](https://blog.csdn.net/TheWayForDream/article/details/118436732)

------------
本题属于一道简单的树状数组题，关键是要理清怎么根**据纵坐标**找两个符号的位置，从而求个数。

由题意可知，统计尖刀的规则就是找有多少组逆序对，那么我们可以枚举中间元素，共有 $n$ 种情况，比如中间元素是 $x$ ，在数组里 $x$ 的左边有 $a$ 个比 $x$ 大的元素，$a$ 的右边有 $b$ 个比 $x$ 大的元素，那么左右两边**任意一组数对**就可以组成一个尖刀，根据乘法原理可知共有 $a \times b$ 种方案。

再来看铁锹的，同理，也是在左右寻找。因为尖刀和铁锹的两边纵坐标与中间的关系**是相反的**（例如尖刀是两个都朝上，铁锹是两个都朝下），那么，我们可以直接根据第一次求得结果来直接减去求得即可，例如左边共有 $u$ 个坐标，有 $a$ 个比 $x$ 大的元素，那么，在求第二次时直接得出比 $x$ 小的有 $u - a + 1$ 个，右边的也一样，至于要不要考虑坐标相同的嘛，额，题目已经明确说了，**坐标互不相同**。

------------
## 代码如下：
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2000009;
int tree[N];
int a[N];
int n;
int lowbit(int x)
{
	return x & (-x);
}
void add(int x, int c)
{
	for (; x <= n; x += lowbit(x))
	{
		tree[x] += c;
	}
}
int query(int x)
{
	int sum = 0;
	for (; x; x -= lowbit(x))
	{
		sum += tree[x];
	}
	return sum;
}
signed main()
{
	cin >> n;
    for(int i = 1; i <= n;i++)   
    {
    	cin >> a[i];
	}
    int res1 = 0,res2 = 0;
    for(int i = 1;i <= n;i++)
	{
        int t1 = query(a[i]-1),t2 = i - 1 - t1;
        res1 += t2 * (n - a[i] - t2);
        res2 += t1 * (a[i] - 1 - t1);
        add(a[i],1);
    }
    cout << res1 << ' ' << res2 << endl;
	return 0;
} 
```

---

## 作者：fire_and_sweets (赞：5)

一道树状数组基础题。

显然，我们枚举一个图腾中间的元素即可。比如，若是 `V` 字型的图腾，我们只需要查询这个中间元素的左边和右边有多少个比他大的数即可。

如何实现这个查询的过程呢？用树状数组即可。例如要查比当前元素 $i$ 小的，那就查询 $1\sim i$ 中所有数的和，然后把 $i$ 这个位置加上 $1$。具体细节见代码。

```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

#define int long long

const int N = 200010;

int n;
int a[N], low[N], high[N], tr[N];

int lowbit(int x)
{
    return x & -x;
}

void update(int x, int c)  // 位置x加c
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

int query(int x)  // 返回前x个数的和
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

signed main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    
    for (int i = 1; i <= n; i ++ )
    {
        int y = a[i];
        high[i] = query(n) - query(y);
        low[i] = query(y - 1);
        update(y, 1);
    }

    memset(tr, 0, sizeof tr);
    int res1 = 0, res2 = 0;
    for (int i = n; i; i -- )
    {
        int y = a[i];
        res1 += high[i] * (query(n) - query(y));
        res2 += low[i] * query(y - 1);
        update(y, 1);
    }
    
    cout << res1 << " " << res2 << endl;
    
    return 0;
}
```

---

## 作者：PineappleSummer (赞：3)

[P10589 楼兰图腾](https://www.luogu.com.cn/problem/P10589)

前置知识：[树状数组](https://oi-wiki.org/ds/fenwick/)。

令 $f_i$ 为 $1\sim i-1$ 中比 $a_i$ 小的数的个数，$b_i$ 为 $i+1\sim n$ 中比 $a_i$ 小的数字个数，树状数组维护即可。可以从前到后再从后到前扫两遍得到 $f_i$ 和 $b_i$。

对于一个数 $a_i$，以 $a_i$ 为中间的点的 `∧` 的数量即为 $f_i\times b_i$。同理，以 $a_i$ 为中间的点的 `V` 的数量即为 $(i-1-f_i)\times (n-i-b_i)$。

那么第一个答案就是 $\displaystyle\sum_{i=1}^{n}(i-1-f_i)\times (n-i-b_i)$，第二个答案就是 $\displaystyle\sum_{i=1}^{n}f_i\times b_i$。

时间复杂度 $O(n\log n)$。
```cpp
struct BIT {
	int c[N];
	int lowbit (int x) { return x & -x; }
	void add (int x, int y) {
		for (; x <= n; x += lowbit (x)) c[x] += y;
	}
	int ask (int x) {
		int res = 0;
		for (; x; x -= lowbit (x)) res += c[x];
		return res;
	}
}c1, c2;
signed main ()
{
	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) {
		f[i] = c1.ask (a[i]);
		c1.add (a[i], 1);
	}
	for (int i = n; i >= 1; i--) {
		b[i] = c2.ask (a[i]);
		c2.add (a[i], 1);
	}
	for (int i = 1; i <= n; i++) {
		ans1 += (i - f[i] - 1) * (n - i - b[i]);
		ans2 += f[i] * b[i];
	}
	cout << ans1 << ' ' << ans2;
	return 0;
}
```

---

## 作者：cqbzhzf (赞：2)

### 题解
[博客食用效果更佳](https://www.luogu.com.cn/article/3zlbi7hm)
### 大体思路
首先观察，发现 $n\le 200000$，明显是个 $O_{nlogn}$ 的时间复杂度。再看题目所求，明显是逆序对的变形，想到使用[树状数组](https://blog.csdn.net/weq2011/article/details/128835460)。

### 具体分析
- 题目保证横坐标有序，所以只用考虑纵坐标 $y$ 即可，用 $y$ 建立树状数组。
- 建立 $l$ 和 $r$ 数组分别统计  图形和 "^" 图形的答案。
- 对于 "v" 图形，每个 $y_i(1\le i\le n)$ 都需要找到 $y_j<y_j(1\le j<i)$ 和 $y_k>y_j(j<k \le n)$,使用树状数组的前缀和函数求解，$l_{i,1},l_{i,2}$ 分别记录 $y_j$ 和 $y_k$ 的数量，每组 $y_i,y_j,y_k$ 分别匹配，所以 $y_i$ 的答案为 $(l_{i,1}\times l_{i,2})$。"^" 图形同理。
- 最终 "v" 图形答案为 $\sum_{i=1}^{n}(l_{i,1}\times l_{i,2})$，"^" 图形答案为 $\sum_{i=1}^{n}(r_{i,1}\times r_{i,2})$。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long//不开long long见祖宗
using namespace std;
const int N=1e6+5;
int n,a[N],bit[N],ans,ans2,l[N][3],r[N][3];
int lowbit(int x)
{
	return x&(-x);
}
void update(int k,int x)
{
	while(k<=n)
	{
		bit[k]+=x;
		k+=lowbit(k);
	}
}
int sum(int k)
{
	int t=0;
	while(k>0)
	{
		t+=bit[k];
		k-=lowbit(k);
	}
	return t;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		l[i][1]=i-1-sum(a[i]);
		l[i][2]=sum(a[i]-1);
		update(a[i],1);
	}
	memset(bit,0,sizeof(bit));//要么清空再算，要么开两个bit数组
	for(int i=n;i>=1;i--)
	{
		r[i][1]=n-i-sum(a[i]);
		r[i][2]=sum(a[i]-1);		
		update(a[i],1);
	}
	for(int i=1;i<=n;i++)
	{
		ans+=l[i][1]*r[i][1];
		ans2+=l[i][2]*r[i][2];
	}
	cout<<ans<<" "<<ans2;
	return 0;
}
```

---

## 作者：unDefined_Future (赞：2)

[cnblogs](https://www.cnblogs.com/Running-a-way/p/18283193)

经典题。tag：`树状数组`。

开一个**权值**树状数组，从左往右遍历，统计左边比 $y_i$ 小的数字个数 $ul_i$ 与比 $a_i$ 大的数字个数 $dl_i$；然后从右往左遍历，统计右边比 $y_i$ 小的数字个数 $dr_i$ 与比 $a_i$ 大的数字个数 $ur_i$。

两个答案即为 $\sum_{i=1}^n dl_i \cdot ur_i$ 和 $\sum_{i=1}^n ul_i \cdot dr_i$。

当然用线段树也可以。树状数组优势在于代码很好写。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const int N = 2e5+10;
int n; ll c[N], a[N], ul[N], dl[N], ur[N], dr[N];
int lbt(int x) {return x & -x;}
void add(int k, ll x) {for (int i = k; i <= n; i += lbt(i)) c[i] += x;}
ll qry(int k) {ll rs = 0; for (int i = k; i; i -= lbt(i)) rs += c[i]; return rs;}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= n; i++) {
        if(i > 1) dl[i] = qry(n) - qry(a[i]), ul[i] = qry(a[i] - 1);
        add(a[i], 1);
    }
    memset(c, 0, sizeof c);
    for (int i = n; i; i--) {
        if(i < n) ur[i] = qry(n) - qry(a[i]), dr[i] = qry(a[i] - 1);
        add(a[i], 1);
    }
    ll ans1 = 0, ans2 = 0;
    for (int i = 1; i <= n; i++) ans1 += dl[i] * ur[i], ans2 += ul[i] * dr[i];
    printf("%lld %lld", ans1, ans2);
    return 0;
}
```

---

## 作者：CNS_5t0_0r2 (赞：2)

本题解使用的是权值线段树，不过思路和权值树状数组是一样的。大概就是维护比 $a_i$ 大（小）的数的数量，再使用乘法原理计算即可。

具体参见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 9;
int n;
int a[N],tmp[N],top;
int val[N << 2];//权值线段树
int l_val1[N],l_val2[N];
long long ans1,ans2; 
void update(int root,int l,int r,int v){//将v所在的节点加1
    val[root]++;//经过的节点肯定会加1 
    if(l == r)
        return;
    int mid = (l + r) >> 1;
    int lchild = root << 1,rchild = lchild + 1;
    if(v <= mid)
        update(lchild,l,mid,v);
    else
        update(rchild,mid + 1,r,v);
}
int query(int root,int l,int r,int v){//查询当前序列有多少个不超过v的数
    if(!val[root])
        return 0;
    if(l == r)
        return val[root];
    int mid = (l + r) >> 1;
    int lchild = root << 1,rchild = lchild + 1;
    int ret = 0;
    if(v <= mid)
        ret = query(lchild,l,mid,v);
    else
        ret = val[lchild] + query(rchild,mid + 1,r,v);
    return ret;
}
int main(){
    scanf("%d", &n);
    tmp[++top] = 0;
    for(int i = 1;i <= n;i++){
        scanf("%d", &a[i]);
        tmp[++top] = a[i];
    }
    //离散化 
    sort(tmp + 1,tmp + top + 1);
    top = unique(tmp + 1,tmp + top + 1) - (tmp + 1);;
    for(int i = 1;i <= n;i++)
        a[i] = lower_bound(tmp + 1,tmp + top + 1,a[i]) - tmp;
    for(int i = 1;i <= n;i++){
        update(1,1,top,a[i]);//将a[i]在计数器上加1（在权值线段树上更新） 
        l_val1[i] = query(1,1,top,a[i] - 1);
        l_val2[i] = i - query(1,1,top,a[i]);
    }
    memset(val,0,sizeof val);
    for(int i = n;i >= 1;i--){
        update(1,1,top,a[i]);//将a[i]在计数器上加1（在权值线段树上更新） 
        int r_val1 = ((n - i + 1) - query(1,1,top,a[i]));
        int r_val2 =  query(1,1,top,a[i] - 1);
        ans1 += 1ll * r_val1 * l_val2[i];
        ans2 += 1ll * r_val2 * l_val1[i];
//      printf("在a[%d]左侧有%d个数比a[%d]小，有%d个数比a[%d]大\n",i,l_val1[i],i,l_val2[i],i);
//      printf("在a[%d]右侧有%d个数比a[%d]小，有%d个数比a[%d]大\n\n",i,r_val2,i,r_val1,i);
    }
    printf("%lld %lld",ans1,ans2);
    return 0;
}
```

---

## 作者：Angelina188 (赞：1)

**树状数组**：~~好写不好想（个人观点）~~
### 思路
枚举中间点，铁锹就是找左边比 $y_i$ 小的个数 $p1$，则右边比 $y_i$ 小的个数就为 $y_i-1-p1$。尖刀与铁锹相反，找左边比 $y_i$ 大的个数 $p2$，则右边比 $y_i$ 小的个数为 $n-y_i-p2$。具体方案就是左右两边的个数相乘。
### Code
```cpp
//代码中a[i]就是题目中的y[i]
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
#define ll long long
#define lowbit(x) (x&-x)
ll n,a[N],t[N];
ll jd,tq;//尖刀，铁锹
void update(ll x,ll y){
	while(x<=n){
		t[x]+=y;
		x+=lowbit(x);
	}
}
ll sum(ll x){
	ll ans=0;
	while(x>0){
		ans+=t[x];
		x-=lowbit(x);
	}
	return ans;
}//模板
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
		ll p1=sum(a[i]-1),p2=i-1-p1;
		//a[i]左边比它小的，剩下的是比它大的
		jd+=p2*(n-a[i]-p2);
		tq+=p1*(a[i]-1-p1);
		update(a[i],1);
	}
	cout<<jd<<" "<<tq;
	return 0;
}
```

---

## 作者：Zaku (赞：1)

前置知识： [树状数组。](https://www.luogu.com.cn/problem/P3368)

## 解题思路：
由于题目已经将所有点按横坐标排好序了，故我们只需考虑纵坐标即可，不妨设纵坐标构成的序列为 $a$。

则按照题目要求，`V` 就是连续 $3$ 个元素呈凹形状，`^` 就是连续 $3$ 个元素呈凸形状。

- 倒序扫描序列 $a$，利用树状数组求出每个 $a_i$ 后面有多少个数比它大，记为 $r_i$。
- 正序扫描序列 $a$，利用树状数组求出每个 $a_i$ 前面有多少个数比它大，记为 $l_i$。

本题的树状数组 $c$，记录的是数值出现的次数，与模板略有不同，$c_x$ 保存 $x$ 在序列 $a$ 中出现的次数。

树状数组 $c$ 在 $[l,r]$ 上的区间和即为序列 $a$ 中范围在 $[l,r]$ 内的数有多少个，利用该树状数组可求逆序对。

则不难得知 `V` 字图腾的总数就是 $l_i\cdot r_i$ 的总和。利用同样的方法我们可以统计出 `^` 字图腾的个数，由于纵坐标两两不同，故不存在相等的情况，所以我们只需要对 `V` 的情况取反考虑即可，不用额外开数组存储 `^` 的情况了。

详情见代码：
```cpp
#include <bits/stdc++.h>
#define int long long//爆int
using namespace std;
const int N = 2e5 + 5;
int a[N], c[N], l[N], r[N];
int n;
//树状数组模板
 int lowbit(int x){
	return x & -x;
}
void add(int x, int y){
	while (x <= n){
		c[x] += y;	
		x += lowbit(x);
	}
}
int ask(int x){
	int ans = 0;
	while (x){
		ans += c[x];
		x -= lowbit(x);
	}
	return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i ++ ) 
		cin >> a[i];
	for (int i = n; i >= 1; i -- ){//因为是逆序读入，故比它大的一定在后面
		r[i] = ask(n) - ask(a[i]);//求a[i]后面有几个比它大的
		add(a[i], 1);
	}
	memset(c, 0, sizeof c);
	for (int i = 1; i <= n; i ++ ){
		l[i] = ask(n) - ask(a[i]);//求a[i]前面有几个比它大的
		add(a[i], 1);
	}
	int down = 0, up = 0;
	for (int i = 1; i <= n; i ++ ){
		down += l[i] * r[i];
		up += (i - l[i] - 1) * (n - r[i] - i);
	}
	cout << down << ' ' << up;
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

树状数组模版题。

仔细阅读题目，发现 ```V``` 的个数是在 $a_i$ 左边比其大的个数乘在 $a_i$ 右边比其小的个数，```∧``` 则相反。

最后在暴力上加树状数组即可。

```
#include<bits/stdc++.h>
#define rg register
#define il inline
#define co const
template<class T>il T read(){
    rg T data=0,w=1;rg char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-') w=-1;ch=getchar();}
    while(isdigit(ch)) data=data*10+ch-'0',ch=getchar();
    return data*w;
}
template<class T>il T read(rg T&x) {return x=read<T>();}
typedef long long ll;
 
co int N=2e5+1;
int n,a[N],c[N],l[N],r[N];
int ask(int x){
	int ans=0;
	while(x) ans+=c[x],x-=x&-x;
	return ans;
}
void add(int x,int y){
	while(x<=n) c[x]+=y,x+=x&-x;
}
int main(){
	read(n);
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=n;i;--i)
		r[i]=ask(a[i]-1),add(a[i],1);
	std::fill(c+1,c+n+1,0);
	for(int i=1;i<=n;++i)
		l[i]=ask(a[i]-1),add(a[i],1);
	ll ans=0;
	for(int i=1;i<=n;++i)
		ans+=(ll)(n-i-r[i])*(i-1-l[i]);
	printf("%lld ",ans);
	ans=0;
	for(int i=1;i<=n;++i) ans+=(ll)r[i]*l[i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：FJ_OIer (赞：0)

考虑一个数对 `∧` 的贡献：设这个数左边有 $a$ 个比它小的数，右边有 $b$ 个比它小的数，那么根据乘法原理，显然有 $ab$ 个**以它为中心的 `∧`**。`v` 同理。

如何求出 $a$，$b$ 呢？使用桶记录每个数的出现次数（~~显然只会出现一次~~），然后对桶求前缀和 $sum$。每扫到一个数 $x$，那么对应的 $a$ 即为 $sum_{x-1}$（注意此处需要边求前缀和边计算 $a$）。同理，求后缀和即可求出 $b$。

但是这样我们每遇到一个数就要重新求前缀和（因为需要动态更新，且不能一次求完），时间复杂度是 $\Theta(n^2)$。维护动态更新的前缀和，你想到了什么？

对！树状数组。

```cpp
#include <bits/stdc++.h>
#define int long long//记得开 long long
#define N 200001
using namespace std;
int n,ans,cnt;
int a[N],c[N],l[N],r[N],l1[N],r1[N];
void add(int x){
	for (int i=x;i<=n;i+=i&(-i)){
		c[i]++;
	}
}
int sum(int x){
	int cnt=0;
	for (int i=x;i;i-=i&(-i)){
		cnt+=c[i];
	}
	return cnt;
}
//维护前缀和
signed main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>a[i];
		l[i]=sum(a[i]-1);//"∧"
		l1[i]=sum(n)-sum(a[i]);//"v"
		add(a[i]);
	}
	memset(c,0,sizeof c);//清空，求后缀和
	for (int i=n;i;i--){
		r[i]=sum(a[i]-1);
		r1[i]=sum(n)-sum(a[i]);
		//同上
		add(a[i]);
	}
	for (int i=1;i<=n;i++){
		ans+=l[i]*r[i];
		cnt+=l1[i]*r1[i];
	}
	cout<<cnt<<" "<<ans;
	return 0;
}
```

---

## 作者：WorldMachine (赞：0)

树状数组入门题！

对于每个元素，记录它前面或后面有多少个数比它大或小，显然可以用树状数组维护，把两边比它大/小的数的个数乘起来就是它对答案的贡献。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 200005;
int n, a[N], c[N], pre[N], suf[N];
ll ans1, ans2;
void upd(int x) { while (x <= n) c[x]++, x += x & -x; }
int qry(int x) { int y = 0; while (x) y += c[x], x -= x & -x; return y; }
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++) {
		pre[i] = qry(a[i] - 1), suf[i] = qry(n) - qry(a[i]);
		upd(a[i]);
	}
	memset(c, 0, sizeof(c));
	for (int i = n; i >= 1; i--) {
		ans1 += suf[i] * ll(qry(n) - qry(a[i]));
		ans2 += pre[i] * ll(qry(a[i]));
		upd(a[i]);
	}
	printf("%lld %lld", ans1, ans2);
}
```

---

## 作者：luckyqwq (赞：0)

# P10589 楼兰图腾 题解

形式化题意：给定 $n$ 和数组 $y$，$y$ 是 $1$ 至 $n$ 的一个排列。

问存在多少组 $(i,j,k)$，使得 $1\le i<j<k\le n$ 且  
1. $y_i > y_j, y_k > y_j$。
2. $y_i < y_j, y_k < y_j$。

考虑枚举中间元素 $j$。则问题转换为 $\forall j\in[1,n]$，符合条件的数个数。  
于是可以用权值树状数组维护。对于每个数前面有多少小于 ta 的数，每次先查询再更新即可。其他情形可以类推。

时间 $O(n \log n)$。不嫌麻烦还可以减小常数。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 10;
int n, a[N];
struct Fenwick
{
    int t[N];
    void add(int p, int x)
    {
        for (; p <= n; p += p & -p)
            t[p] += x;
    }
    int ask(int p)
    {
        int res = 0;
        for (; p; p ^= p & -p)
            res += t[p];
        return res;
    }
} t1, t2;
int ans[N][4], Ans, Bns;
signed main()
{
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i];
        ans[i][0] = t1.ask(a[i] - 1);     // y[i]<y[j]
        ans[i][1] = i - 1 - t1.ask(a[i]); // y[i]>y[j]
        t1.add(a[i], 1);
    }
    for (int i = n; i; --i)
    {
        ans[i][2] = t2.ask(a[i] - 1);     // y[k]<y[j]
        ans[i][3] = n - i - t2.ask(a[i]); // y[k]>y[j]
        t2.add(a[i], 1);
    }
    for (int i = 1; i <= n; ++i)
        Ans += ans[i][1] * ans[i][3], Bns += ans[i][2] * ans[i][4];
    cout << Ans << ' ' << Bns << '\n';
    return 0;
}
```

---

## 作者：I_will_AKIOI (赞：0)

权值树状数组板子，和[这道题](https://www.luogu.com.cn/problem/P1637)很像。

我们发现这两种图腾中间的数要么同时比两边的数小，要么同时比他们大。那么根据乘法原理，以 $y_i$ 为顶点的 `V` 图腾数就是 $\displaystyle\sum_{j=1}^{i-1} [a_j>a_i]\times \displaystyle\sum_{j=i+1}^{n} [a_j>a_i]$。也就是在 $a_i$ 左边且高度大于 $a_i$ 的个数乘以在 $a_i$ 右边且高度大于 $a_i$ 的个数。`^` 图腾个数同理。

于是我们可以先从左到右把 $y$ 数组扫一遍，用权值树状数组存储下这时高度的分布情况。然后记录高度比他大和小的个数。由于此时只有在他左边的数被加进了权值树状数组，所以并不会有在 $a_i$ 右边的情况。

接着清空一下树状数组，再从右到左扫一遍，同样记录答案即可。接着两个数乘在一起就行了。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&(-x))
#define int long long
#define N 200005
using namespace std;
int n,ans1,ans2;
int a[N],c[N],cnt1[N],cnt2[N];
void update(int x,int y)
{
  while(x<=n)
  {
    c[x]+=y;
    x+=lowbit(x);
  }
  return;
}
int query(int x)
{
  int res=0;
  while(x)
  {
    res+=c[x];
    x-=lowbit(x);
  }
  return res;
}
signed main()
{
  ios::sync_with_stdio(0);
  cin>>n;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=n;i++)
  {
    update(a[i],1);
    cnt1[i]=query(n)-query(a[i]);//比ai大的个数
    cnt2[i]=query(a[i]-1);//比ai小的个数
  }
  memset(c,0,sizeof(c));
  for(int i=n;i>=1;i--)
  {
    update(a[i],1);
    ans1+=cnt1[i]*(query(n)-query(a[i]));//乘法原理
    ans2+=cnt2[i]*query(a[i]-1);
  }
  cout<<ans1<<" "<<ans2;
  return 0;
}
```

---

## 作者：_zuoqingyuan (赞：0)

一道权值树状数组的模板题。

# 题意简述

> 给定一个长为 $n$ 的排列 $a$，要求你统计 `v` 形三元组和 `^` 形三元组的总对数
>
>定义 `v` 形三元组为满足 $i<j<k$ 且 $A_i>A_j,A_j<A_k$ 的三元组 $(i,j,k)$ 的对数。
>
>定义 `^` 形三元组为满足 $i<j<k$ 且 $A_i<A_j,A_j>A_k$ 的三元组 $(i,j,k)$ 的对数。
>
> $1\le n\le 2\times 10^5$。

# 思路分析

我们以 `v` 形三元组为例进行讨论，下文的 $(i,j,k)$ 均代指 `v` 形三元组。

我们很难直接求出 $(i,j,k)$ 的数量，不过我们很好求出 $A_i>A_j,A_j<A_k$ 的 $(i,j)$ 和 $(j,k)$ 的数量。

根据乘法原理，$(i,j,k)$ 的数量就是 $(i,j)$ 的数量乘上 $(j,k)$ 的数量。我们不妨枚举 $j$，记 $l_j$ 表示 $(i,j)$ 的数量，$r_j$ 表示 $(j,k)$ 的数量，最终的答案就是：

$$\sum\limits_{j=1}^nl_j\times r_j$$

我们具体讲解一下如何快速求 $l_j,r_j$，下文以计算 $l_j$ 为例。

我们在枚举 $j$ 的时候，同时记录一个计数数组 $cnt$，$cnt_x$ 表示 $x$ 在 $a_1\sim a_{j-1}$ 中的出现次数。

对于此时储存在 $cnt$ 中的所有数，其下标 $i$ 必然满足 $i<j$，因此 $l_j$ 的个数就是 $a_i<a_j$ 的个数，即为 $\sum\limits_{i=1}^{j-1}cnt_i$。计算完后令 $cnt_{a_j}\to cnt_{a_j}+1,j\to j+1$。

同理，$r_j$ 的值可以表示为 $1\sim j-1$ 的所有的数减去**小于等于** $a_j$ 的数的个数，表示为 $j-1-\sum\limits_{i=1}^jcnt_i$。

暴力做显然 $O(n^2)$，无法通过本题 $10^5$ 的数据。观察后发现，$cnt$ 数组只会进行单点修改和区间求和，我们用[树状数组](https://www.luogu.com.cn/problem/P3374)代替 $cnt$。即可以把时间复杂度下降至 $O(n\log n)$。

# Code

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
const int N=2e5+10;
ll c[N],n,le[N][2],ri[N][2],a[N],Ans1,Ans2;
inline ll lowbit(int a){
    return a&-a;
}
inline void add(int x,ll val){
    while(x<=n){
        c[x]+=val;
        x=x+lowbit(x);
    }
    return;
}
inline ll ask(int x){
    ll cnt=0;
    while(x>0){
        cnt+=c[x];
        x=x-lowbit(x);
    }
    return cnt;
}
inline void clear(){
    for(int i=1;i<=n;i++)c[i]=0;
}
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)scanf("%lld",a+i);
    for(int i=1;i<=n;i++){
        le[i][0]=i-1-ask(a[i]);//v形三元组中(i,j) 的数量
        le[i][1]=ask(a[i]-1);//^形三元组中(i,j) 的数量
        add(a[i],1);
    }
    clear();
    for(int i=n;i>=1;i--){
        ri[i][0]=n-i-ask(a[i]);//v形三元组中(j,k) 的数量
        ri[i][1]=ask(a[i]-1);//^形三元组中(j,k) 的数量
        add(a[i],1);
    }
    for(int i=1;i<=n;i++)
        Ans1+=le[i][0]*ri[i][0],Ans2+=le[i][1]*ri[i][1];
    printf("%lld %lld\n",Ans1,Ans2);
    return 0;
}
```

# 拓展

如果题目让求 `N` 形或 `W` 形，那么这种做法有过于复杂，有没有更好的办法？

我们还是以本题的 `v` 形三元组为例，记 $f_j$ 为 $i<j,A_i>A_j$ 的 $(i,j)$ 的个数，则三元组 $(i,j,k)$ 的数量和即为满足 $j<k,A_j<A_k$ 的所有 $f_j$ 之和。

这样我们按照顺序计算 $f$ 数组，在过程中统计答案，时间复杂度为 $O(n\log n)$。对于更加复杂的计数，如果多元组内包含 $k$ 个元素，则时间复杂度为 $O(kn\log n)$。

~~上面都是口胡出来的，代码都没打。~~

# The end

其实就是逆序对的拓展应用，还有[双倍经验](https://www.luogu.com.cn/problem/P1637)。

如有错误，请指出。

---


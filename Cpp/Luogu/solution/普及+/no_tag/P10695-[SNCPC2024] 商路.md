# [SNCPC2024] 商路

## 题目描述

一个圆周被 $K$ 个点等分，这些点按照顺时针编号为 $1, 2, \cdots, K$。其中点 $a_1, a_2, \cdots, a_n$ 分别建造有一座市场 $M_1, M_2, \cdots, M_n$。

一条从市场 $i$ 出发，目标是市场 $j$ 的商路是有向线段 $M_i M_j$ ($i \neq j$) 且必须满足以下条件：

- 市场 $j$ 必须是距离市场 $i$ 最远的市场（如果有多个距离相同的最远的市场,那么任意一个均可）。
    
- 商路线段 $M_i M_j$ 不能与其他商路线段在起点或者终点以外的地方相交或重合。

最多可以存在多少条商路？

## 说明/提示



对于第一个样例，其中两种可能的答案如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ql7evd73.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ya5u7z3o.png)

## 样例 #1

### 输入

```
10 5
1 2 5 6 8
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3 3
1 2 3
```

### 输出

```
3
```

# 题解

## 作者：WeLikeStudying (赞：4)

尝试提供比较简单的思考方式。

### [题意](https://www.luogu.com.cn/problem/P10695)
在圆的 $k$ 个等分点中选出 $n$ 个关键点，一条线段合法当且仅当它连接两个关键点且对它连接的某个关键点而言，另一个点是最远关键点。

选出最多的合法线段使它们除了端点外两两不交。

### 分析
你手玩了几个数据，发现答案不容易很大，你思考如何让答案大一点，于是你写了一个暴力对拍：[代码](https://www.luogu.com.cn/paste/hk2q14y5)。

你尝试找一些答案不太小的数据，于是用：
```cpp
int calc(int S)
{
	return (S&(S-1))!=0;
}
```
当然这样子错误率很高：$k=10$ 时有 $932$ 组错解。

手玩小数据即可发现，很多数据的答案最后所有的线段共用端点（尤其是你筛选出答案比较大的情况时），既然这样，求出所有的合法线段，组成一个无向图，找到入度最大的点作为答案输出似乎是一种不错的策略，于是你改成：
```cpp
int b[N];
bool c[N][N];
int calc(int S)
{
	fill(b,b+k,0);
	up(i,0,k-1)fill(c[i],c[i]+k,0);
	up(i,0,k-1)if(S>>i&1)
	{
		int mx=0;
		up(j,0,k-1)
			if(S>>j&1)mx=max(mx,dis(i,j));
		up(j,0,k-1)
			if((S>>j&1)&&dis(i,j)==mx&&i!=j&&!c[j][i])
				++b[i],++b[j],c[i][j]=1;
	}
	return *max_element(b,b+k);
}
```
虽然连样例都无法正确通过，但是在 $k=10$ 的时候只有 $30$ 个反例，且反例都只有三个点，且所有三条边都被选入。

考虑只有三个点的情况，一共有三条边，你发现如果最短边小于次短边，那么只可能用到两条边，故判断最短边是否恰好等于次短边，如果是，就在原本答案上加一。
```cpp
int n,a[N],b[N];
bool c[N][N];
int calc(int S)
{
	n=0;
	up(i,0,k-1)
		if(S>>i&1)a[++n]=i;
	up(i,1,n)fill(c[i],c[i]+n+1,0);
	fill(b,b+n+1,0);
	up(i,1,n)
	{
		int mx=0;
		up(j,1,n)mx=max(mx,dis(a[i],a[j]));
		up(j,1,n)if(dis(a[i],a[j])==mx&&i!=j&&!c[j][i])
				++b[i],++b[j],c[i][j]=1;
	}
	bool ok=n==3;
	if(ok)
	{
		int g[3]={a[2]-a[1],a[3]-a[2],a[1]+k-a[3]};
		sort(g,g+3);
		ok=g[0]==g[1];
	}
	return *max_element(b,b+n+1)+ok;
}
```
该代码没有拍出错，我们将原本的枚举改为双指针（因为所有点到某个点的距离先增大后减小），时间复杂度 $O(n)$。
```cpp
#include<bits/stdc++.h>
#define up(a,b,c) for(int a=b;a<=c;++a)
const int N=11e4;
using namespace std;
int k,n,a[N],d[N],b[N];
int dis(int u,int v)
{
	u=a[u],v=a[v];
	if(u>v)swap(u,v);
	return min(v-u,u+k-v);
}
int main()
{
	cin>>k>>n;
	up(i,1,n)cin>>a[i];
	int j=1;
	up(i,1,n)
	{
		while(dis(i,j)<=dis(i,j%n+1))
		{
			if(dis(i,j)==dis(i,j%n+1)&&dis(i,j)!=d[j])++b[i],++b[j];
			j=j%n+1;
		}
		d[i]=dis(i,j);
		if(d[i]!=d[j])++b[i],++b[j];
	}
	bool ok=n==3;
	if(ok)
	{
		int g[3]={a[2]-a[1],a[3]-a[2],a[1]+k-a[3]};
		sort(g,g+3);
		ok=g[0]==g[1];
	}
	cout<<*max_element(b,b+n+1)+ok;
	return 0;
} 
```
这份代码可以通过本题。

---

## 作者：_LiWenX_ (赞：2)

好题啊，赛时这个题是我想出来的，因为我要写 J 题，所以把思路给了队友 [TanX_1e18](https://www.luogu.com.cn/user/482007) 完成的代码（不过最后罚了 $11$ 发才过）。

首先猜到一个结论：你连出来的答案必然形如一个菊花。然后我试图证明这一点：可以发现任意两条边都至少有一个公共点，满足这种构造的确有一种是菊花，但是还有一种是三元环，比如一个等边三角形就是一个很好的例子。

那么我们可以先尝试求出连成了一个菊花时的最大答案。首先对于每个点，找到距离它最远的点，这个可以使用数据结构简单地维护出来。具体来说，找到他对面的点（可能要根据 $k$ 的奇偶性分类讨论），然后找到它左右第一个点，那么这个第一个点就是距离它最远的点。

不难发现，可能可行的边是 $2n$ 级别的，直接把边的贡献挂在两个端点上，然后枚举“根”节点即可算出答案。

然后是对于三元环的情况，若三个点是 $(A,B,C)$，必然要满足条件存在这样的边 $A\to B,A\to C,B\to C$。这个可以通过特判解决。

代码如下

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+9;
int to[N][2],n,k;
int a[N];
set<int>st;
map<int,int>id;
map<int,int>v[N],num;
int d(int x,int y)
{
	return min(((x-y)%k+k)%k,((y-x)%k+k)%k);
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>k>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		id[a[i]]=i;
		st.insert(a[i]-k*2);
		st.insert(a[i]-k);
		st.insert(a[i]);
		st.insert(a[i]+k);
		st.insert(a[i]+k*2);
	}
	for(int i=1;i<=n;i++)
	{
		int x=a[i]+k/2+1;
		int y=a[i]+k/2;
		int d=0;
		int l=*st.lower_bound(x);
		d=max(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k),d);
		l=*st.lower_bound(y);
		d=max(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k),d);
		l=*--st.upper_bound(x);
		d=max(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k),d);
		l=*--st.upper_bound(y);
		d=max(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k),d);
		l=*st.lower_bound(x);
		if(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k)==d)
		{
			l=((l)%k+k*2-1)%k+1;
			if(to[i][0]!=l&&to[i][1]!=l)
			{
				v[id[l]][a[i]]=1;
				num[id[l]]++;
				if(!to[i][0])
				to[i][0]=l;
				else
				to[i][1]=l;
			}
		}
		l=*st.lower_bound(y);
		if(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k)==d)
		{
			l=((l)%k+k*2-1)%k+1;
			if(to[i][0]!=l&&to[i][1]!=l)
			{
				v[id[l]][a[i]]=1;
				num[id[l]]++;
				if(!to[i][0])
				to[i][0]=l;
				else
				to[i][1]=l;
			}
		}
		l=*--st.upper_bound(x);
		if(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k)==d)
		{
			l=((l)%k+k*2-1)%k+1;
			if(to[i][0]!=l&&to[i][1]!=l)
			{
				v[id[l]][a[i]]=1;
				num[id[l]]++;
				if(!to[i][0])
				to[i][0]=l;
				else
				to[i][1]=l;
			}
		}
		l=*--st.upper_bound(y);
		if(min(((l-a[i])%k+k)%k,((a[i]-l)%k+k)%k)==d)
		{
			l=((l)%k+k*2-1)%k+1;
			if(to[i][0]!=l&&to[i][1]!=l)
			{
				v[id[l]][a[i]]=1;
				num[id[l]]++;
				if(!to[i][0])
				to[i][0]=l;
				else
				to[i][1]=l;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		int sum=0;
		if(to[i][0]&&v[i].find(to[i][0])==v[i].end())
		sum++;
		if(to[i][1]&&v[i].find(to[i][1])==v[i].end())
		sum++;
		ans=max(ans,sum+num[i]);
		// cout<<to[i][0]<<' '<<to[i][1]<<'\n';
		if(to[i][1]&&to[i][0]&&(to[id[to[i][0]]][0]==to[i][1]||to[id[to[i][0]]][1]==to[i][1]||to[id[to[i][1]]][0]==to[i][0]||to[id[to[i][1]]][1]==to[i][0]))
		ans=max(ans,3ll);
	}
	cout<<ans<<'\n';
	return 0;
}
```

---


# [SNCPC2024] 致命公司

## 题目描述

Shirost 最近沉迷于一款名为《致命公司》的游戏。

在游戏中，玩家将作为“公司”的合同工，从废弃的工业星球收集废料。在探索的过程中，Shirost 将遇到一个名为弹簧头的怪物，弹簧头会在无人注视它时快速移动，但在被注视时则会保持不动。一旦接近，弹簧头就会立刻杀死 Shirost。

现在 Shirost 站在 $n$ 个无限长的通道的交汇点，他知道有 $m$ 个弹簧头，分别会在 $t_i$ 时刻出现在 $x_i$ 号通道距离他 $y_i$ 米远处。

对于每个时刻 $j$，以下三个事件将会依次发生：

1. 在该时刻开始时，满足 $t_i = j$ 的弹簧头会出现在  $x_i$ 号通道距离 Shirost $y_i$ 米远处。

2. Shirost 选择凝视任意一个通道。

3. 该通道内的所有弹簧头无法移动，而其他通道中**已经出现**的弹簧头会向他移动 $k$ 米，如果某个弹簧头到达他所在位置，则他将在时刻 $j$ 死亡。

Shirost 想知道他最晚可以活到哪个时刻。换句话说，如果 Shirost 最晚在时刻 $j$ 死亡，那么你需要输出 $j-1$。如果他不会死亡，则输出 $-1$。

## 说明/提示



Shirost 可以按如下所述行动：
| 时刻 | 凝视的通道 | 弹簧头 $1$ 距离 | 弹簧头 $2$ 距离 |  弹簧头 $3$ 距离 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 1 | 6 |  |  |
| 2 | 1 | 6 | 5 |  |
| 3 | 2 | 4 | 5 | 6 |
| 4 | 1 | 4 | 3 | 6 |
| 5 | 2 | 2 | 3 | 4 |
| 6 | 1 | 2 | 1 | 4 |

在第 $7$ 时刻，无论看哪个通道，Shirost 都会在该时刻内被弹簧头杀死。所以答案是 $6$。

## 样例 #1

### 输入

```
2 3 2
1 1 6
2 2 7
3 1 8
```

### 输出

```
6
```

## 样例 #2

### 输入

```
114514 6 1919810
1 1 1
1 1 9
1 4 1
1 5 9
1 1 8
1 4 10
```

### 输出

```
0
```

# 题解

## 作者：SUNCHAOYI (赞：5)

看完题目后盲猜二分答案（）。

题目的难点显然是如何分配凝视的时间于不同的通道，以及如何在一次凝视时将通道内的子弹进行标记。

二分时刻 $t$，对于所有的子弹，有以下情况：

- 在 $t$ 时刻，该子弹仍未出现，忽略该子弹。
- 从子弹出现到 $t$ 时刻，不需要额外再使用凝视，忽略该子弹。
- 从子弹出现到 $t$ 时刻，需要额外使用凝视，计算并标记。当然，需要先判断所剩的时间能否满足条件。

那么对于第一个难点，可以对子弹出现的时间进行排序，为了使得凝视不会产生后效性，我们按照时间进行**降序**，依次考虑子弹所在通道所需的凝视时间。对于第二个难点，只需再用一个数组记录通道已用的凝视的时间即可。

特别地，当所有子弹都在同一个通道时，永远都不会受到伤害，特判即可。

最后时间复杂度 $O(n \log n)$。最终代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#define init(x) memset (x,0,sizeof (x))
#define ll long long
#define ull unsigned long long
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
const int MAX = 5e5 + 5;
const int MOD = 1e9 + 7;
inline ll read ();
struct node
{
	ll t,x,y;
} s[MAX];
ll tot,n,m,k,l = 0,r = INF,ans,ex[MAX],st[MAX]; 
bool cmp (node xx,node yy);
ll check (ll ti);
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	n = read ();m = read ();k = read ();
	for (int i = 1;i <= m;++i) 
	{
		s[i].t = read ();s[i].x = read ();s[i].y = read ();
		if (!ex[s[i].x]) ex[s[i].x] = 1,++tot;
	}
	sort (s + 1,s + 1 + m,cmp);//按照时间降序排序
	if (tot == 1) {puts ("-1");return 0;}//特判
	while (l <= r)
	{
		ll mid = (l + r) >> 1;
		if (check (mid)) ans = mid,l = mid + 1;
		else r = mid - 1;
	}
	printf ("%lld\n",ans);
	return 0;
}
inline ll read ()
{
    ll s = 0;int f = 1;
    char ch = getchar ();
    while ((ch < '0' || ch > '9') && ch != EOF)
	{
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9')
	{
        s = s * 10 + ch - '0';
        ch = getchar ();
    }
    return s * f;
}
bool cmp (node xx,node yy) {return (xx.t == yy.t) ? xx.y < yy.y : xx.t > yy.t;}//时间晚的优先 
ll check (ll ti)
{
	ll ret = ti;//从 ti 开始消耗用于凝视 
	for (int i = 1;i <= n;++i) st[i] = 0;//每个通道被凝视的次数 
	for (int i = 1;i <= m;++i)
	{
		if (ti < s[i].t) continue;//该子弹还未出现 
		ll tmp = (s[i].y - 1) / k + 1 + st[s[i].x] + s[i].t - 1;//到达时的时间 
		if (tmp > ti) continue;//子弹在 ti 时无法达到 	
		tmp = ti - tmp + 1;//需要凝视的时间 
		if (ret - tmp + 1 < s[i].t) return 0;//剩余时间无法处理 
		ret -= tmp;st[s[i].x] += tmp;//进行标记
	}
	return 1;
}
```

---

## 作者：xyj__han (赞：2)

### 题意简化
有 $n$ 无限长的通道的交汇点（两个通道相互通过的一个地方）里面，有 $m$ 个弹簧头（一个怪物）会分别在 $t_i$ 时间出现在 $x_i$ 号通道距离他 $y_i$ 米远。在每一个时刻，会发生三件事（有顺序）。

1. 在时刻开始时，满足一定条件 $t_i=j$ 弹簧头就会开始移动到 $x_i$ 号通道，离 Shirost $y_i$ 米远的地方。
   
1. Shirost 选择凝视任意一个通道（可以让此道路的怪物停止移动）。
   
1. 该通道内的所有弹簧头无法移动，而其他通道中已经出现的弹簧头会向他移动 $k$ 米，如果某个弹簧头到达他所在位置，则他将在时刻 $j$ 死亡。之后说说输出，就是说他最晚可以活到哪一个时刻 $j$ 如果他不会死亡的话，就输出 `-1` 即可。
### 思路
这一题我认为是二分答案。

在时刻 $t$ 有下面的三种情况：

1. 怪物没有出现的话就忽略。
1. 时刻 $t$ 出现怪物，不使用凝视技能，忽略。
1. 怪物出现在 $t$ 时刻，使用凝视技能，标记并判断是否满足时间条件。
### 难点
 这一道题的难点就在于你要判断每一条通道里面的怪物在这个是时刻或者未来的 $t$ 个时刻里面会不会对你造成威胁和要不要使用凝视和使用凝视的计算存储判断还有一些特判。

特判:当所有怪物都出现在一条通道上时，永远都不会死，特判就行了,我们就是需要把存储怪物出生地的数组拿过来进行判断。
```
l=ans[0];
for(int i=0;i<a;i++) if(ans[i]==l){flag=1;}
```
最后用二分的做法就可以了。

感谢管理员的审核，求过谢谢。

---

## 作者：迟暮天复明 (赞：1)

显然二分答案。设二分的时间为 $t$，那么每个弹簧头都可以被写成一个形如 $(l,T)$ 的要求，表示 $l\sim t$ 时间内需要看 $T$ 秒。

如果没有两个弹簧头在同一个管道，那么只需要对于每个弹簧头的出现时间排序，即可 $O(n)$ 处理每次二分的结果（因为要求已经有序），只需要拿一个时间指针从 $t$ 往回扫即可。

如果两个弹簧头出现在同一管道，首先如果后出现的位置靠后，那么它显然没有用。否则对于它们形成的两对 $(l_0,T_0),(l_1,T_1)$ 直接拆成 $(l_0,T_0-T_1)$ 和 $(l_1,T_1)$ 即可。于是我们就处理完了这一情况。总复杂度 $O(n\log T+m\log m)$。

---

## 作者：断清秋 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10701)

首先观察数据范围，然后答案显然是具有单调性的，不难想到二分答案。

考虑对于答案 $j$ 如何进行 check。

首先肯定应该按怪物出现时间降序考虑问题，这样在考虑前面的怪物时不会漏掉后面凝视的时间。

然后对于怪物，计算需要对它用多少次凝视。这需要对于每个出怪口，记录其被凝视的次数并纳入考虑。如果剩余时间不够就说明答案非法。

$-1$ 的情况就是所有怪出现在一个出怪口。特判即可。

注意二分边界要开大，右边界开 $10^{18}$ 是不够的。

---


# 【MX-S2-T2】 排

## 题目背景

原题链接：<https://oier.team/problems/S2B>。

## 题目描述

有 $n$ 个整数 $a_1,a_2,\ldots,a_n$。$f_0=0,f_i= \left\{
\begin{aligned}
& f_{i-1}   &  \ f_{i-1}\times a_i>0, \\
& f_{i-1}+a_i &  \ f_{i-1}\times a_i\le 0.\\ 
\end{aligned}
\right.
$

重排 $a$ 使得得到的 $f_n$ 最大。

## 说明/提示

**【样例解释 \#1】**

考虑重排为 $-6,-4,5,7,3$，最终的 $f_n$ 为 $6$，可以证明不存在更优的方案。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 0（6 pts）：$n\le10$。
- Subtask 1（14 pts）：$n\le 20$，$|a_i|\le10$。
- Subtask 2（8 pts）：$a$ 中全为正数或全为负数。
- Subtask 3（19 pts）：$a$ 中有且只有一个正数（注意 $a$ 中可以有 $0$）。
- Subtask 4（29 pts）：$n \le 200$，$|a_i|\le 200$。
- Subtask 5（24 pts）：无特殊限制。

对于所有测试数据，$1 \le n \le 2000$，$|a_i|\le 2000$。

## 样例 #1

### 输入

```
5
7 5 -4 -6 3```

### 输出

```
6```

## 样例 #2

### 输入

```
10
573 -1339 899 939 -26 1430 1324 -1150 1640 -45 ```

### 输出

```
1625```

# 题解

## 作者：silhouettel (赞：21)

观察一下性质，发现若是序列全为正数或全为负数或全为零，排序输出最大值即可。  
接下来考虑序列中既有正数也有负数的情况。可以发现，此时序列中的零是无意义的，不论你放哪都不能造成影响，所以我们把它去掉，原因后面说。又根据题面中提供的式子，当前位为正的话，不能再叠加正数了，所以答案不会超过序列中的最大值。这时候就会考虑，除去最大值后的 $n - 1$ 个数，它们构成的重排的和在不超过零的情况下，显然是越大越优秀的。大于零没有意义，因为它不会作为答案。这很像是背包问题，询问能否找到一种填数方式。一看值域很小，思路大抵是对的，那么就要判断题面式子是否有相对应的性质，即我们是否可以随心所欲地选取我们想要的数。这里给出构造，将被选择的负数的其中之一放在开头，后面一段接着所有未选择的负数，然后把剩下被选择的正数（除去最大值）和被选择的负数按某种顺序排列使它们都被算入贡献，（因为它们最终的和是小于等于零的，所以我们一定可以得到一个将所有数都用上的排列顺序），再把最大值接上，最后让剩下未被选择的正数堆在尾部就行。那么这确实是一个背包问题，可以用 bitset 优化复杂度，不详细说。  
解释一下去零的问题，由于至少一个非零数会被选，所以那 $n - 1$ 个数构成的重排的和不可以只由单个零产生，若是不把零去掉，就无法判断和为零的方案到底是多个数组合出来的，还是只选了一个零。  
bitset 只要开 $4 \times 10^6$ 级别就行，因为当一方（正数或负数）的和超过了 $2 \times 10^6$，那么它不可能对答案有贡献。若想产生贡献，就需要另一方的和至少有 $2 \times 10^6$，这是无法实现的。  

```
#include <bits/stdc++.h>
using namespace std;
#define real signed
#define enl '\n'

const int iinf = 0x3f3f3f3f;
const int st = 2000001;
int n;
int a[2011];
vector<int> se;
bitset<4000011> f;

real main() {
	std::ios::sync_with_stdio(false), std::cin.tie(NULL), std::cout.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++)
		if (a[i]) se.push_back(a[i]);
	sort(se.begin(), se.end());
	bool flg = true;
	for (int i = 1; i <= n; i++)
		if (a[i] * a[1] < 0) flg = false;
	if (se.empty()) cout << 0;
	else if (flg) cout << se[se.size() - 1];
	else  {
		for (int i = 0; i < se.size() - 1; i++) {
			if (se[i] > 0) f |= f << se[i];
			else f |= f >> -se[i];
			f[st + se[i]] = 1;
		}
		int ma = -iinf;
		for (int i = st - 2000; i <= st; i++)
			if (f[i]) ma = i;
		cout << ma - st + se[se.size() - 1];
	}
    return 0;
}
```

---

## 作者：woshishabi11451444 (赞：8)

首先我们先不要去想怎么重排序列，我们想如果选择出一个序列，如果判断这个序列的 $f_n = $ 这个序列的总和，显然当这个序列的总和 $\le$ 这个序列的最大值，是一定存在重排方案使得 $f_n = $ 这个序列的总和。那我们可以枚举这个序列的最大值，用递推算出哪些总和可以满足条件，对这些满足条件的总和找个最大的即可。注意判断全正全负，若答案为负数，那么答案显然是找最大的负数。由于直接递推时间复杂度会很慢，使用 bitset 优化。

注意：

1. 答案可以为负数，并且最终答案大于原序列最大的负数，所以我们需要修改枚举的范围应该枚举到最大的负数
。

2. 做递推的时候需要优先处理负数情况。

3. 无需处理 $A_i = 0$ 的情况。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 2e3 + 5;
const int INF = 2e3;

bitset<N * N> dp;
int n, a[N];

int main(){
  cin >> n;
  int ans = -N * N;
  for(int i = 1; i <= n; i++){
    cin >> a[i];
  }
  sort(a + 1, a + n + 1);
  for(int i = 1; i <= n; i++){
    if(a[i] < 0) ans = max(ans, a[i]);
  }
  if(a[n] <= 0 || a[1] >= 0){
    if(a[1] >= 0) cout << a[n];
    else cout << ans;
    return 0;
  }
  for(int i = 1; i <= n; i++){
    if(a[i] < 0){
      dp = dp | (dp >> abs(a[i]));
      dp[a[i] + INF * INF] = 1;
    }
  }
  for(int i = 1; i <= n; i++){
    for(int j = a[i] + INF * INF; j >= -INF + INF * INF; j--){
      if(dp[j - a[i]]){
        ans = max(ans, j - INF * INF);
      }
    }
    if(!a[i]) continue;
    if(a[i] >= 0) dp = dp | (dp << a[i]);
    dp[a[i] + INF * INF] = 1;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：AzureHair (赞：5)

### 闲话

~~退役太久失忆了忘了还有 bitset 这种东西。~~

赛时由于忘了还有 bitset 喜提 49分。

### 题干简介

同号不变，异号或含零相加。

求给定的序列的一个排列方式使得在这种操作下结果最大。

### ①暴力

最极端的暴力，只要我不要分一切复杂度的算法都是优秀的。直接暴力扔个 $\mathcal O(n!)$ 的枚举上去，可以通过 6 分。

### ②无 bitset 暴力

首先我们将所有的数分为两类，第一类叫无效数字，第二类叫有效数字，有效数字含义为这个数字切实的进行了运算，改变了数值，无效数字则反之。

首先我们容易发现，对于无效数字我们可以抛开不谈。

对于有效数字，最终结果自然就是有效数字的加和。

接下来我们就会发现一个特性，整个过程其实就是在正负之间左右横跳，那么容易想到，我们可不可以前面的数调整大小至小于等于零的最大值，然后用最大的数去冲到一个比较大的数字。事实上，证明也是容易的。

首先在我们刚才的设想下，这个最大数显然是一个有效数字，那么对于其他的情况，可以分成两种情况：

第一，最大数依然作为有效数字出现，但是不会是最后冲结果的那个数，即用于调整的数，那么根据刚才我们发现的性质，对于相同的有效数字，结果显然不会改变，所以这种情况下不会使答案变得更优。

第二，最大数不会作为有效数字出现，而是无效数字，这个就显然了，前面调整部分的结果不会改变，即最大的负数不会改变，但是不试用最大数了，所以结果一定会变小。

好的现在我们知道了只要找出最大数然后再求出最大负数就能够解决。最大负数的求解显然是一个背包问题，直接写一个 01 背包上去即可，设值域为 $[-m,m]$，时间复杂度就为 $\mathcal O(nm)$，能够拿下 49 分。

### ③正解

首先你要记得 bitset。

bitset 其实就是一段很长很长的二进制数，所以第二维的枚举就可以用移位来代替，这就给了我们一个 $\frac{1}{64}$ 的巨大常数，足以通过此题。

最后的最后，别忘了凑出 0 的情况和全为正或全为负的情况。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[2010],mmax=0,maxi,flag=0;
bitset<8000010> bs;
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)
	{
		if(a[i]>mmax)
		{
			mmax=a[i];maxi=i;
		}
	}
	bs[4000000]=1;
	for(int i=1;i<=n;i++)
	{
		if(i==maxi)continue;
		if(bs[4000000-a[i]])flag=1;
		if(a[i]>=0)bs|=bs<<a[i];
		else bs|=bs>>(-a[i]);
	}
	if(flag)
	{
		printf("%lld\n",mmax);
		return 0;
	}
	bs[4000000]=0;
	for(int i=4000000;i>=1;i--)
	{
		if(bs[i])
		{
			printf("%lld\n",i-4000000+mmax);
			return 0;
		}
	}
	printf("%lld\n",mmax);
	return 0;
}
```

---


# [COCI 2017/2018 #2] Doktor

## 题目描述

> 夫人说：
>
>「我已经骑马十五年了，不可能把马倒着钉蹄铁！」
>
> （……）

「是的，那是倒着的。」——多马戈伊低声说道，看着马特的手，正在玩一个经过大幅修改的纸牌游戏 Hanabi。为了简单起见，马特手中有 $N$ 张牌，按顺序编号为 $1, 2, \dots, N$。
每个数字从 $1$ 到 $N$ 恰好出现一次。就像玩真正的游戏一样，他不能主动改变牌的顺序。

为了让任务至少与故事有些关联，多马戈伊会指向马特手中一段连续的牌子序列。（他也可以指向单张牌，但至少会指向一张牌。）然后马特将「旋转」该连续子数组并放回去。

（旋转可以被认为是将给定子数组中的所有牌旋转 180 度。这意味着第一张和最后一张牌交换位置，第二张和倒数第二张牌交换位置，依此类推。）

和我们所有人一样，多马戈伊非常喜欢不动点。换句话说，就是牌的数字与它们在手中的位置相匹配的牌，从多马戈伊的左侧开始计数。因此，他希望在旋转给定子数组后，不动点的数量尽可能多。

帮助多马戈伊找出他需要指出哪一段连续子数组，以便在旋转该子数组后，马特手中的不动点数量达到最大。

## 说明/提示

在第一个测试用例中，旋转从 3 开始到 1 结束的连续子数组后，牌的顺序将变为 1 2 3 4，现在所有的牌都是不动点。在这个例子中，给定的输出是唯一正确的输出。

在第二个测试用例中，旋转任何仅包含一张牌的子数组会导致相同的牌顺序，这种顺序产生最大数量的不动点。（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
4
3 2 1 4```

### 输出

```
3 1```

## 样例 #2

### 输入

```
2
1 2```

### 输出

```
1 1```

## 样例 #3

### 输入

```
7
3 6 5 7 4 1 2 ```

### 输出

```
3 2```

# 题解

## 作者：xiaoliebao1115 (赞：4)

小清新简单题。
## idea
注意到对于一个数来讲，他若能在反转后去到一个 $a_i=i$ 的地方，那么旋转中心一定就是 $(a_i+i)\div2$。

所以说对于任意一个数，他能够反转到想去的位置的旋转中心有且仅有一个。

那么可以对于每一个旋转中心，记录所有能够以他为中心变到 $a_i=i$ 的数的 $\min(a_i,i)$。因为实际上将 $i$ 变到 $a_i$ 的位置和将 $a_i$ 变到 $i$ 的位置，他俩是等价的。

那么枚举所有旋转中心，将他记录的所有数从大到小排序，枚举这里面的所有数作为旋转左端点，枚举到了第 $x$ 个，也会使得第 $1$ 到 $x-1$ 这些数转到自己想到的位置。

所以用 $x-sum_r+sum_{l-1}$ 和当前的答案作比较即可，$sum$ 代表前缀和，表示 $l$ 到 $r$ 之中原来就 $a_i=i$ 的数的个数。

## code

```cpp
int a[nn],n,sum[nn],ans,ans1,ans2;
vector<int> e[nn*2];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read(),sum[i]=sum[i-1];
		if(a[i]==i) sum[i]++;
		e[a[i]+i].push_back(min(a[i],i));
	}
	for(int i=2;i<=n*2;i++){
		sort(e[i].begin(),e[i].end(),greater<int>());
		for(int j=0;j<e[i].size();j++){
			int l=e[i][j];
			if(j+1-sum[i-l]+sum[l-1]>ans){
				ans=j+1-sum[i-l]+sum[l-1];
				ans1=a[l],ans2=a[i-l];
			}
		}
	}
	if(ans1==0&&ans2==0) cout<<1<<" "<<1<<endl;
	else cout<<ans1<<" "<<ans2<<endl;
	return 0;
}
```
注意对于你并未搜到任何答案的情况，说明没有必要进行反转操作，输出 $1$ 即可，相当于没有操作。

时间复杂度 $O(n\log n)$。

---

## 作者：封禁用户 (赞：1)

# P10883 [COCI 2017-2018#2] Doktort题解

## 思路
我们先考虑翻转后有贡献的情况，如果翻转区间 $[l,r]$ 翻转后 $a_i=l+r-i$ 的数会有贡献，否则就是翻转到 $a_i=i$，旋转中心为 $(a_i+i)÷2$。

对于每一个数，他的旋转中心有并且仅有一个。

所以用 $sum$ 存前缀和。

注意：如果你没有找到没有任何答案，没有必要进行翻转，请你输出 $1$，相当于没有任何操作。

代码很简单，我就不放在这了。

---

## 作者：elbissoPtImaerD (赞：1)

首先注意到只需考虑形如 $[\min(i,a_i),\max(i,a_i)]$ 作为翻转区间。

而此类区间仅有 $O(n)$ 种，枚举之，考虑快速统计答案。

不妨枚举翻转中心，记 $f_x$ 表示翻转中心 $p=\lfloor \frac x2\rfloor$ 时能通过翻转对答案有贡献的 $a_i$ 集合。不妨将 $f_x$ 按 $\min\{a_i,x-a_i\}$ 降序考虑，则有贡献的是 $f_x$ 的一段前缀。

枚举前缀，答案容易表示成：原序列的前后缀答案加上枚举的前缀长度。

预处理前后缀信息即可做到线性复杂度。

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/173156983)

```cpp
void Solve() {
  int n; cin>>n;
  ve<int>a(n); for(int&x:a) cin>>x,--x;
  map<int,ve<int>>b;
  ve<int>pre(n+1);
  for(int i=0;i<n;++i) pre[i+1]=pre[i]+(a[i]==i);
  int ans=pre[n]; pii res{0,0};
  for(int i=0;i<n;++i) b[i+a[i]].pb(a[i]);
  for(auto&[x,f]:b) {
    int p=x/2;
    sort(rll(f),[&](int a,int b){return min(a,x-a)<min(b,x-b);});
    for(int i=0;i<Sz(f);++i) { // choose f[0,i]
      int y=min(f[i],x-f[i]);
      if(cx(ans,i+1+pre[y]+pre[n]-pre[x-y+1])) {
        res={f[i],a[f[i]]};
      }
    }
  }
  for(int x:a) {
    if(x==res.x) break;
    if(x==res.y) {
      swap(res.x,res.y);
      break;
    }
  }
  cout<<(res.x+1)<<' '<<(res.y+1)<<'\n';
  return;
}
```

---

## 作者：Controls_Wish (赞：1)

### 思路

我们先考虑在什么区间下一个数翻转后有贡献。设翻转区间为 $[l,r]$ 则翻转后会有 $a_{l+r-i}=a_i$ 所以该区间中所有 $a_i=l+r-i$ 的数会有正贡献，而原本 $a_i=i$ 的数会有负贡献。

将 $a_i=l+r-i$ 移项后可得 $a_i+i=l+r$，设 $b_i=a_i+i$，考虑一个显然的贪心，对于每个 $b_i$ 考虑其为端点的情况，对于该区间中所有的 $k$，统计所有 $b_k=b_i$ 的情况，再减去原有 $a_k=k$ 的数会有的负贡献，贡献最大的区间为答案。证明如下：

设其下标为 $x$，以其为左端点为例，若其不为左端点，则左端点在其左方，若左端点在另一个 $b_i$ 与 $b_x$ 相等的点左方，则会被该点考虑过，所以值得考虑的左端点与 $x$ 之间对贡献不会有任何增益，而把左端点调至最大（即为 $x$）后其对应的右端点也会右移，会有更多有贡献的可能。右端点同理，证毕。

那么考虑实现，先维护一个前缀和统计负贡献，显然因 $a_i+i=l+r$ 当 $i$ 为一个端点时，$a_i$ 的值为另一个端点，那么在遍历到 $i$ 对在下标为 $a_i$ 的地方的动态数组里放此时统计的 $b_i$ 个数和 $i$，然后对 $i$ 处的动态数组中的东西处理即可统计贡献，如此结束后便统计过了所有 $i$ 为左端点的贡献，反着跑即可统计 $i$ 为右端点的。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500005
int a[N],b[N],sum[N];
struct node{int pri,col;};
vector<node>v[N];
int cnt[N<<1];
int main(){
	int n,ans=0,asl=1,asr=1;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i]+i,sum[i]=sum[i-1]+(a[i]==i);
		v[a[i]].push_back({i,cnt[b[i]]});
		cnt[b[i]]++;
		for(auto it:v[i]){
			int res=cnt[b[it.pri]]-it.col-(sum[i]-sum[it.pri-1]);
			if(res>ans)ans=res,asr=i,asl=it.pri;
		}
	}
    for(int i=1;i<=n;i++)
        cnt[i]=cnt[i+n]=0,v[i].clear();
	for(int i=n;i>=1;i--){
		v[a[i]].push_back({i,cnt[b[i]]});
		cnt[b[i]]++;
		for(auto it:v[i]){
			int res=cnt[b[it.pri]]-it.col-(sum[it.pri]-sum[i-1]);
			if(res>ans)ans=res,asl=i,asr=it.pri;
		}
	}
	printf("%d %d",a[asl],a[asr]);
    return 0;
}
```

---

## 作者：_qhbd_ (赞：0)

# 题意
给定一个长为 $n$ 的排列 $a$，其贡献为 $\sum\limits_{i=1}^n[a_i=i]$。现你可以使一段区间元素反转最大化操作后排列贡献，问最优反转区间左右端点元素。
# 思路
数有两种产生贡献的方法，一种是满足 $a_i=i$，还有一种是它被反转后满足 $a_i=i$。

若 $a_i\ne i$，那么它位于 $a_i$ 位时它便有贡献，所以它通过反转从 $i$ 移动到 $a_i$，则反转中心唯一确定为 $\frac{a_i+i}{2}$。

所以一个点若要通过反转产生贡献，可以知道它的反转中心是唯一确定的。而反转中心，虽然可能对应多个点，但是所有反转中心对应点的总量是 $n$ 以内的。

我们对于每个反转中心维护一个 vector，存储与它对应点到它的距离，然后排序。如果对于一个反转中心，有三个点，到它的距离为 $2,10,10$，那么我们如果枚举反转中心反转的范围，肯定就是枚举 $2,10$，因为反转范围为 $3$ 和 $2$ 时，可以知道反转产生贡献的点只有一个，但是反转范围变大可能导致本来满足 $a_i=i$ 的点失去其本身贡献，这是不优的。

所以我们枚举所有反转中心及其反转范围，枚举复杂度 $O(n)$，排序 $O(n\log n)$。
# code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,a[N],pre[N],suf[N];
int ans,l=1,r=1;
vector<int>num[N<<1];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if((a[i]+i)&1)num[a[i]+i].emplace_back(abs(a[i]-(a[i]+i+(a[i]>i))/2));
		else num[a[i]+i].emplace_back(abs((a[i]+i)/2-i));
		pre[i]=pre[i-1]+(a[i]==i);
	}
	for(int i=n;i>=1;i--)
		suf[i]=suf[i+1]+(a[i]==i);
	for(int i=1;i<=n+n;i++)
		if(num[i].size()){
			sort(num[i].begin(),num[i].end());
			int res=0;
			for(auto v:num[i]){
				res++;
				if(ans<pre[i/2-v-1]+suf[(i+(i&1))/2+v+1]+res){
					ans=pre[i/2-v-1]+suf[(i+(i&1))/2+v+1]+res;
					l=i/2-v;
					r=(i+(i&1))/2+v;
				}
			}
		}
	printf("%d %d\n",a[l],a[r]);
	return 0;
}
```

---

## 作者：dutianchen1 (赞：0)

# P10883 [COCI 2017-2018#2] Doktor

随机跳题跳到的萌萌题。

### 思路简析

显然，我们会考虑枚举翻转的左右端点。但是直接枚举是 $O(n^{2})$ 的复杂度，我们无法接受。

不过我们可以想到，与其直接枚举左右端点，不如枚举翻转中心。

而且如果我们要使一个元素 $a_{i}$ 翻转后到达第 $i$ 个位置，显然翻转中心有且只有一个。

于是我们把使用对应翻转中心的左端点，也就是 $\min(a_{i},i)$ 存起来。

后面我们枚举每一个翻转中心，只需要把对应的左右端点计算出来，就可以计算出翻转后对答案的贡献。

这里为了 $O(1)$ 计算贡献，前缀和求一下 $sum_{i}=\sum_{j=1}^{i} [a_{j}=j]$ ，即可只需要用 $sum[r]-sum[l-1]$ 求得翻转前对应序列对答案的贡献。

不过我们需要对左端点降序排列，保证计算答案时的**单调性**。

最后注意，如果我们不需要翻转，需要输出两个相同的整数意思一下。

代码里还有对对应语句的解释。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e6+5;
const ll inf = 1e18+7;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
ll n;
ll num[N];
ll sum[N];
vector<ll> p[N];
ll l,r,maxx=-inf;
ll posl=1,posr=1;
bool cmp(ll x,ll y){return x>y;}
void solve(){
	n=read();
	for(ll i=1;i<=n;i++){
		num[i]=read();
		sum[i]=(num[i]==i)+sum[i-1];//前缀和记录所有满足 a_{i}=i 的元素 
		p[i+num[i]].emplace_back(min(num[i],i));//记录对称中心 这里翻转 i与a_{i} 是等价的 这样就只需要统计翻转中心的左端点 
	}
	for(int i=2;i<=2*n;i++){//枚举对称中心 
		sort(p[i].begin(),p[i].end(),cmp);
		for(int j=1;j<=p[i].size();j++){
			l=p[i][j-1],r=i-l;//枚举翻转左右端点 
			if(maxx<j-sum[r]+sum[l-1])//去掉原来这段对答案的贡献再加上翻转后新增的贡献 
			{
				maxx=j-sum[r]+sum[l-1];
				posl=l;posr=r;
			}
		}
	}
	if(posl==1&&posr==1)cout<<n<<' '<<n<<'\n';
	else cout<<num[posl]<<' '<<num[posr]<<'\n';
	
}
ll T;
int main()
{
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
//	T=read();
	T=1;
	while(T--){
		solve();
	}
	return 0;
}




```

---


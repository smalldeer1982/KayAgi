# 城市化发展委员会

## 题目背景

MLE 大帝曾说过：

![](https://cdn.luogu.com.cn/upload/image_hosting/kce8kpx3.png)

所以为了应对这种情况我们设立了**城市化发展委员会**。

## 题目描述

在高中的校园里我们常常能看到随机刷新的小情侣，对于他们之间的情感，对于 OIer 来说还是太过于高深了，即使是退役的 AzureHair 也无法理解这一行为，但是作为自命的城市化发展委员会的常委，他有自己的一套理解方法。

他认为，女生往往对男生十分的严格。一天开始时男生在女生的心里的积分会加 $1$，而如果当天惹女生生气了 $x$ 次，积分就会在此基础上减 $x$。积分会不断累计，一旦小于等于 $0$ 就可能导致去城市化的严重后果。

现在 **威廉** 在和 **珂朵莉** 进行一种城市化行为，**威廉** 在~~纳西妲~~的帮助之下获得了超能力：一是他可以预知到接下来一个周期的积分变化情况，初始的周期长度为 $n$；二是他可以选择从任意一天开始，开始前的日子将会被拼接到最后一天之后。

他从每一天开始都尝试过一次后，发现了 $a$ 个能使得他不被去城市化的起始日期。随后他会将这若干种情况下的序列按照起始日期的先后拼在一起，变成一个长度为原先 $a$ 倍的周期。他如此重复操作 $k$ 次，由于一天天地试太累了，**威廉** 只想知道最后一次操作后有多少个起始日期能让自己不被去城市化，对 $998244353$ 取模。

---

形式化地说，我们称满足前缀和始终大于 $0$ 的数列为 “安全的”。

对于一个长为 $n$ 的数列 $A_i$，根据以下算法构造出数列 $A_{i+1}$，初始时 $A_{i+1}$ 为空。

- 重复执行 $n$ 次：

1. 若 $A_i$ 是安全的，将其整个接到 $A_{i+1}$ 末尾。

2. 将 $A_i$ 循环左移一位，即令 $A_{i_j} ← A_{i_{j+1 \bmod n}}$。

现在给定 $A_0$，**满足其各项均不大于 1**。

从 $A_0$ 开始按上述规则生成数列 $A_1$ 到 $A_{k+1}$，请求出 $A_{k+1}$ 与 $A_k$ 的长度比，这个值只要存在就一定是整数，请输出它对 $998244353$ 取模的值。特别地，如果 $A_k$ 为空，请输出 ```0```。

## 说明/提示

**【样例解释1】**

对于样例 #1 的数据，初始周期为 ```1 1 -2 1 1 -1 0 1```。从每一天开始得到的序列分别是：

```text
1 1 -2 1 1 -1 0 1
1 -2 1 1 -1 0 1 1
-2 1 1 -1 0 1 1 1
1 1 -1 0 1 1 1 -2
1 -1 0 1 1 1 -2 1
-1 0 1 1 1 -2 1 1 
0 1 1 1 -2 1 1 -1
1 1 1 -2 1 1 -1 0
```

只有从第 4 天和第 8 天开始的序列是满足条件的。

形式化题意：

$A_1=\{1,1,-1,0,1,1,1,-2,1,1,1,-2,1,1,-1,0\}$，长度为 16，因此应输出 2。

**【样例解释2】**

可以证明不存在合法的方案。

喂！样例全都 $k=0$ 是不是太过分了？！

**数据范围：**

对于 $15\%$ 的数据，保证 $1\le n \le 10$，$1\le k \le 5$。

对于另外 $25\%$ 的数据，保证 $k=0$。

对于 $100\%$ 的数据，保证 $1\le n\le 10^6$，$0 \le k \le 10^6$，$-10^9 \le {A_0}_i \le 1$。

## 样例 #1

### 输入

```
8 0
1 1 -2 1 1 -1 0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
6 0
1 1 -4 -5 1 -4```

### 输出

```
0```

# 题解

## 作者：OIer_Eternity (赞：12)

# Description

定义一个序列为「安全的」当且仅当其所有前缀和均大于 $0$。

先给定一个长度为 $n$ 的序列 $A_0$，将进行如下操作 $k$ 次：

- 第 $i$ 次操作将会由 $A_{i-1}$ 得到 $A_i$。
- 重复如下操作 $n$ 次：
  - 若 $A_{i-1}$ 是「安全的」就将其接到 $A_i$ 末尾。
  - 将 $A_{i-1}$ 循环左移 $1$ 位。

求 $\dfrac{|A_{k+1}|}{|A_k|}$。

# Solution

首先考虑 $k=0$ 的情况。

我们只需统计满足以第 $t$ 位开头的序列是「安全的」的 $t$ 的个数（我们称满足条件的 $t$ 所代表的位置是「被标记的」）。

则我们需要用到前缀和的极小值，线段树或树状数组维护即可。

接着拓展到 $k>0$ 的情况，我们令 $f(p)$ 表示 $A_p$ 中「被标记的」位置的个数，考虑如何计算 $f(p)$。

首先，在前一个序列 $A_p$ 中「被标记的」位置在当前序列 $A_{p+1}$ 一定是「被标记的」，并且 $A_{p+1}$ 的长度是 $A_p$ 的 $f(p)$ 倍。

那么有 $\forall p\in[1,k],f(p)\ge f^2(p-1)$。

接着考虑是否会出现新的「被标记的」位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/0flu5zdi.png)

如图，若设红色的圈表示在 $A_p$ 中「被标记的」的位置，绿色的圈表示 $A_{p+1}$ 中新出现的「被标记的」的位置，则各个颜色所代表的矩形对应相同，且各矩形的前缀和一定大于 $0$。

那么在 $A_p$ 中，以绿色的圈开头也是一个「安全的」序列，矛盾。

因此 $f(p)=f^2(p-1)$，依次计算 $f(p),p\in[1,k]$，答案即为 $f(p)$。

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p=998244353;
int n,k;
long long a[2000005];
struct Node{
    int l,r;
    long long Min;
}tree[8000005];
void build(int p,int l,int r){
    tree[p].l=l,tree[p].r=r;
    if (l==r){
        tree[p].Min=a[l];
        return;
    }
    int Mid=(l+r)>>1;
    build(p<<1,l,Mid);
    build(p<<1|1,Mid+1,r);
    tree[p].Min=min(tree[p<<1].Min,tree[p<<1|1].Min);
}
long long query(int p,int l,int r){
    if (l<=tree[p].l&&tree[p].r<=r) return tree[p].Min;
    int Mid=(tree[p].l+tree[p].r)>>1;
    long long res=1e18;
    if (l<=Mid) res=query(p<<1,l,r);
    if (r>Mid) res=min(res,query(p<<1|1,l,r));
    return res;
}
int qpow(int a,int b){
    int res=1;
    for (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;
    return res;
}
int main(){
    scanf("%d%d",&n,&k);
    for (int i=1;i<=n;i++) scanf("%lld",&a[i]),a[i+n]=a[i];
    for (int i=1;i<=2*n;i++) a[i]+=a[i-1];
    build(1,1,2*n);
    int ans=0;
    for (int i=1;i<=n;i++) if (query(1,i,i+n-1)>a[i-1]) ans++;
    for (int i=1;i<=k;i++) ans=1ll*ans*ans%p;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Exp10re (赞：11)

好题。

给一种不依赖 $a_i\leq 1$ 的做法。以下假定没有性质  $a_i\leq 1$。

事实上我在赛场上因为没看到这个性质被硬控了两个小时。憋笑。

## 解题思路

### 引理

若 $\frac {|A_i|} {|A_{i-1}|}=Ans_i$，则 $Ans_i=Ans_{i-1}^2$。

### 证明

根据题目条件可以得到：若 $A_i$ 存在一个安全的循环移位，则 $A_i$ 中所有数的和 $\gt 0$。

因此，对于 $A_i$ 的一个循环移位，其是否安全仅取决于这一位在 $A_0$ 中对应位作为起点的循环移位是否安全。故我们不需要考虑 $A_{i+1}$ 的后 $|A_i|+1$ 位的前缀和是否为 $0$。

因此 $A_i$ 的任何安全的循环移位到 $A_{i+1}$ 中会产生恰好 $Ans_i$ 的贡献，而 $A_i$ 的安全循环移位又有 $Ans_i$ 个，故以上结论得证。

---

以上结论得证之后考虑如何快速求出 $A_0$ 的安全循环移位。

考虑使用线段树维护前缀和。维护区间最小值，添加区间修改操作，三次操作就可以判断循环移位是否安全。

得到 $Ans_1$ 之后就可以计算出 $Ans_k=Ans_1^{2^k}$。

注意计算答案时 $Ans_k \bmod P=Ans_1^{2^k \bmod (P-1)} \bmod P$ 即可。

（事实上不用，由于 $k$ 的规模小逐个计算也可以其实。）

---

## 作者：MaiJingYao666 (赞：6)

# P10983 题解（第一次发题解，求官方通过）

### 题目翻译：

对于一个数列 $A_{i}$，满足每一项都 $\le1$，称满足前缀和始终大于 $0$ 的数列为“安全的”。对于一个长为 $n$ 的数列 $A_{i}$，根据以下算法构造出数列 $A_{i+1}$，初始时 $A_{i+1}$ 为空。将 $A_i$ 循环排列（见题目），若当前排列是“安全的”，则将当前排列拼接到 $A_{i+1}$ 末尾，求 $A_{k+1}$ 的长度除以 $A_k$ 的长度。

### 解题策略&证明：

首先，当当前数列的和 $\le 0$，不会有任何的情况添加到下一项数列，即答案为 $0$。

否则，我们发现，数列的和等于几，当前数列就有几组排列会添加到下一项数列。证明如下：数列中 $1$ 的个数加负数之和等于数列的和，同时，为满足数列“安全”，每个负数 $x$ 前面必有至少 $|x|+1$ 个 $1$ 。设有一个数列，设每个负数 $x$ 前面“绑定”着 $|x|$ 个 $1$ 用于抵消，则多出来的 $1$，就应该在所有负数前面，有几个多出来的 $1$ 就有几种可能。此时已经解决 $k=0$ 的情况。

再研究，拼接好后的数列 $A_{i+1}$ 和应该为 $\sum\limits_{i=1}^n A_i\times\text{拼接的个数}$，即 $(\sum\limits_{i=1}^n A_i)^2$。再看求 $A_{k+1}$ 与 $A_k$ 的长度比就等于 $A_k$ 的长度，用递推将 $A_k$ 的长度求出即可。

最后附上 AC 代码：
 
```cpp
#include<iostream>
using namespace std;
int n,k;
int a[1000005];
const int Max=998244353;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	long long sum=0;
	for(int i=0;i<n;i++){
		cin>>a[i];
		sum+=a[i];
	}
	if(sum<=0){//特判
		cout<<0;
		return 0;
	}
	for(int i=1;i<=k;i++){
		sum=sum*sum%Max;//动态取模
	}
	cout<<sum%Max;
}
```

---

## 作者：P_Bisector (赞：6)

本题解解法时间复杂度是 $O(n+\log k+\log P)$（$P$ 为模数）的。

为了方便描述，令：

$$f(i)=\frac{|A_{i+1}|}{|A_i|},g(i)=\sum^i_{j=1}A_{ij}$$

换句话说，$f(i)$ 等于 $A_i$ 的安全的循环移位数量。

我们来~~严谨地~~证明一下 $f(i)=g(i)$。从 $A_i$ 分出一些子串，满足这些子串互不相交，和为 $0$，其前缀和非负并且这些子串包含了所有不等于$1$的数。易证只要 $g(i)>0$ 则必然有这样的方案，可以通过贪心构造。那么除去这些子串，以剩下的 $1$ 开头的循环移位必定是安全的。因为去除的子串和为 $0$，所以剩下的 $1$ 的和必然为 $g(i)$，个数也就为 $g(i)$，从而 $f(i)=g(i)$。

由此可见，$f(i+1)=g(i+1)=f(i)g(i)=f(i)^2$。所以 $f(k)=f(k-1)^2=(f(k-2)^2)^2=\cdots=(\cdots (g(0)^2)^2\cdots)^2$。到这里，本题就可以轻松 AC 了。

然而~~由于闲着没事干~~我们还可以进行优化。首先，$f(k)=(\cdots (g(0)^2)^2\cdots)^2=g(0)^{2^k}$。然后直接快速幂？时间复杂度 $O(\log 2^k)$，即 $O(k)$~~，优化了个寂寞~~。不过我们还可以再优化。由费马小定理可知，

$$\begin{aligned} g(0)^{2^k} \mod P&=g(0)^{2^k \mod (P-1)}\times g(0)^{(P-1)\times \lfloor 2^k\div(P-1) \rfloor}\mod P\\&=g(0)^{2^k \mod (P-1)}\times (g(0)^{(P-1)})^ {\lfloor 2^k\div(P-1) \rfloor}\mod P\\&=g(0)^{2^k \mod (P-1)}\times 1^{\lfloor 2^k\div(P-1) \rfloor}\mod P\\&=g(0)^{2^k \mod (P-1)}\mod P\end{aligned}$$

然后快速幂即可。时间复杂度 $O(n+\log k+\log P)$。

代码：

```cpp
#include<iostream>
using namespace std;
#define int long long
int P(int a,int b,int c){
    int s=1;
    for(;b;b>>=1,a*=a,a%=c)
        if(b&1)s*=a,s%=c;
    return s;
}
signed main(){
    int n,k,s=0;
    cin>>n>>k;
    for(int i=1,t=0;i<=n;i++){
        cin>>t;
        s+=t;
    }
	cout<<P(s,P(2,k,998244352),998244353);
}
```

---

## 作者：LDY_ (赞：6)

# P10893 题解
## 思路

首先考虑 $k$ 为零的情况。序列变化的实质是在原序列任选一个位置断开，将前半段接到后面。从第 $i$ 个数断开，我们设左半部分前缀和最小值为 $minl$，右半部分为 $minr$，那么显然只要满足  $minr-s[i]>0 $ 并且 $ minl+s[n]-s[i]>0$ 即为合法序列，$s$ 为前缀和。$minl$ 和 $minr$ 我用的线段树维护。

其次我们考虑 $k$ 大于零的情况。首先，设一个合法序列 $A_i$ 由 $a$ 个合法序列 $A_{i-1}$ 组成。设为首的序列为 $A_j$，变化的实质是将$A_j$ 前一部分截取接到整个序列后面。由于后面完整的$A_{i-1}$ 一定合法，那么我们只用考虑 $A_j$ 变化后是否合法。假设其合法。那么第一保留的子序列一定合法，第二由于整体前缀和为正，若截取拼接的子序列使整体不合法那么这个子序列一定有前缀和为负，这样原来的 $A_j$ 就不合法，矛盾。因此我们得出结论，若 $A_j$ 截取方案合法，当且仅当这种截取方案是某个 $A_{i-1}$ 的截取方案。进一步我们得出从 $i$ 到 $i+1$ 的变化会使答案平方。即设 $k$ 等于零时答案为 $a$ ，则最终答案为 $a^{2^k}$。

## 代码

```
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;
int n,k;
int a[2000005];
long long s[2000005];
long long ans=1;
struct node{
	int l,r,siz;
	int minn;
}t[4000005];
void build(int x,int l,int r){
	t[x].l=l;t[x].r=r;
	t[x].siz=r-l+1;
	if(l==r){
		t[x].minn=s[l];
		return;
	}
	int mid=(l+r)/2;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	t[x].minn=min(t[x<<1].minn,t[x<<1|1].minn);
}
long long query(int x,int ll,int rr){
	if(t[x].l>rr||t[x].r<ll) return 0x3f3f3f3f;
	if(t[x].l>=ll&&t[x].r<=rr) return t[x].minn;
	return min(query(x<<1,ll,rr),query(x<<1|1,ll,rr));
}
bool flag=1;

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i+n]=a[i];
		s[i]=s[i-1]+a[i];
		if(s[i]<=0) ans=0;
	}
	if(s[n]<=0){
		cout<<0;
		return 0;
	}
	build(1,1,n);
	for(int i=1;i<n;i++){
		//cout<<query(1,i+1,n)<<" "<<query(1,1,i)<<endl;
		if(query(1,i+1,n)-s[i]>0&&query(1,1,i)+s[n]-s[i]>0) ans++;
	}
	for(int i=1;i<=k;i++){
		ans=(ans*ans)%mod;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ChampionCyan (赞：5)

# 城市化发展委员会 题解

## 前言

赛时绕了各种弯道：最小值、小顶堆……我一个半小时都花在上面了 QAQ。

结果最后才发现，这是一个无比诈骗的**结论题**。

## 题目大意

“安全的”的数列满足前缀和始终大于 $0$。

对于一个长为 $n$ 的数列 $A_i$，根据以下算法构造出数列 $A_{i+1}$，初始时 $A_{i+1}$ 为空。

重复执行 $n$ 次：

若 $A_i$ 是安全的，将其整个接到 $A_{i+1}$ 末尾。

将 $A_i$ 循环左移一位，即令 $\large A_{i_j} ← A_{i_{j+1 \bmod n}}$（为了方便观察，我把字放大了一点）。

从 $A_0$ 开始按上述规则生成数列 $A_1$ 到 $A_{k+1}$，请求出 $A_{k+1}$ 与 $A_k$ 的长度比，这个值只要存在就一定是整数，请输出它对 $998244353$ 取模的值。特别地，如果 $A_k$ 为空，请输出 $0$。

## 思路

上来我们注意到一个点（说来惭愧，我前一个小时都没注意到）：

> **现在给定 $A_0$，满足其各项均不大于 $1$。**

于是我们发现了一个大秘密：

**如果 $\sum\limits_{i=1}^na_i\le0$ 的话，答案为 $0$，因为所有数加起来都 $\le0$ 那么序列本身都不是“安全的”，那答案一定为 $0$。**

**如果 $\sum\limits_{i=l}^ra_i=1$ 的话，我们完全可以把区间 $l\sim r$ 的数视为 $1$。** 证明略。

这样处理后，数列要么答案为 $0$，要么都**相当于**由 $1$ 组成，那么我们就来处理后者的情况。

明显的，对于一个长度为 $n$ 且直由 $1$ 组成的数列里，循环移位以后必然有 $n$ 种结果为“安全的”排列方式。

然后递推即可，非常简单。

**$\color{red}\text{Warning:}$ 记得开 long long！**

时间复杂度 $\mathcal O(n+k)$，空间复杂度 $\mathcal O(1)$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
    int n, k, a, cnt = 0, ans = 1;
    scanf("%lld%lld", &n, &k), k++;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a);
        cnt += a;
    }
    if (cnt <= 0)
        puts("0"), exit(0);
    for (int i = 1; i <= k; i++) {
        ans = ans * cnt % 998244353;
        cnt = ans;
    }
    printf("%lld\n", ans);
    return 0;
}
```

## 其他

[更加清晰易懂的版本](https://www.luogu.com.cn/paste/nazxc4ez)。

---

## 作者：__zyq_666_kpzc__ (赞：4)

### [先看题](https://www.luogu.com.cn/problem/P10893)
### 思路分析
首先先判无解，如果数组的总和 $sum$ 是一个非正整数，那么一定不会有合法的数列，因为不管怎么循环移位，总和一定是不变的。

那么如果数组的总和 $sum$ 是一个正整数，那么就一定会出现一个合法的数列。

我们可以思考每一个 $s$，让 $0 \le s \le sum-1$，如果能找到一个最大的 $i$ 使得在原数组 $A_0$ 中下标为 $1$ 至 $i$ 的数的和与 $s$ 相等，那么在 $A_0$ 经过 $y-1$ 次循环移位之后的数列一定是安全的。

综上所述，一个数列的安全循环移位数量等于 $sum$ ，答案可以用快速幂快速得出。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int k_pow(int a,int b,int mod){
    int xx=1;
    while(b>0){
        if(b&1)xx=xx*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return xx;
}
int mod=998244353;
signed main(){
	int n,ans=0,k,sum=0,a;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a,sum+=a;
	if(sum<0){
		cout<<"0";
		return 0;
	}
	cout<<k_pow(sum,k_pow(2,k,mod-1),mod);
	return 0;
}
```

---

## 作者：dabenBbx (赞：4)

## 单调队列 $+$ 前缀和

### 题意

对于一个长为 $n$ 的序列 $A$ ，每一次操作为：分别以序列的每一位为头向后推 $n$ 位组成一个新的序列，计算 $n$ 个序列中有多少个前缀和始终大于 $0$ 。进行 $k+1$ 次，输出最后一次的合法序列个数。

### 分析

分析这道题，初始序列 $A$ 有 $n$ 种可能的情况，我们只要对每种情况判断是否合法即可。但如果暴力枚举每种情况，时间复杂度是 $O(n^2)$ 的，需要考虑如何去优化。

此时我们想与其将数组滚动重新排列，不如直接将原序列复制一遍粘贴在原序列后面，每次只需要将开头和尾部向后移即可。即为在 $A$ 后面再加上序列 $A$，所以数组的大小需要开双倍。

现在题目就等于：对于初始序列 $A$ 的 $n$ 种情况，判断从开头 $a$ 到后 $n-1$ 个数字是否每一点都大于 $0$。此时就可以用前缀和表示从 $1$ 到每一位的前缀和大小。而对于一个区间，我们并不需要判断其是否每一位都大于 $0$。只需找出区间中最小的前缀和，减去区间开头的前缀和。如果为正，则答案加一，反而答案不变。

现在我们可求出初始序列的答案，但是后面的 $k$ 次，如果每次都如此计算，恐怕等算出来都可以看见明天的太阳了。于是我们就尝试手玩一下样例，找一找规律。

初始序列：``1 1 0 1 -1``。

第一次操作合法序列：``1 1 0 1 -1``，`` 1 0 1 -1 1``。

第二次操作合法序列：``1 1 0 1 -1 1 0 1 -1 1``，``1 0 1 -1 1 0 1 -1 1 1``，``1 1 1 0 1 -1 1 0 1 -1``，``1 0 1 -1 1 1 1 0 1 -1``。

可以发现第一次操作答案有两种，第二次有四种。于是我们就可以大胆猜测，后面每次的答案都是之前初始序列答案的 $k+1$ 次方项。

所以此题思路为，先将初始序列变为二倍，进行前缀和的预处理，再用单调队列找区间最小值判断是否合法。

 >注意：答案过大，需要每一步都取模！！！

### AC 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int mod =  998244353;
long long n,k,a[5000005],ans,qzh[5000005],q[5000005],he = 1,ta;//双倍数组 

inline int r() { //快读，一开始认为是输入慢了没过（不是） 
    register int data = 0, w = 1; 
    register char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
}
int main(){
	n = r();k = r();
	for(int i = 1;i <= n;i++){
		a[i] = r();
		a[i+n] = a[i];//复制一遍粘在队尾 
	}
	for(int i = 1;i <= 2*n-1;i++) qzh[i] = qzh[i-1] + a[i];//计算前缀和 
	for(int i = 1;i <= 2*n-1;i++){
		while(he <= ta && max(i-n+1,(long long)1) > q[he]) he++;//单调队列找区间最小前缀和 
		while(he <= ta && qzh[i] <= qzh[q[ta]]) ta--;
		q[++ta] = i;
		if(i-n+1 > 0 && qzh[q[he]] > qzh[i-n]) ans++;//判断是否区间始终大于0 
	}
	if(ans == 0){//ans等于0，表示后面求的 Ak 为空，直接输出0即可 
		cout<<0;
		return 0;
	}
	if(ans == 1){//ans呈 1 的次方次增长，所以一直为 1  
		cout<<1;
		return 0;
	}
	for(int i = 1;i < k+1;i++){//非 0 ，1 时ans呈指数级增长，因为过大，记得每次取模 
		ans *= ans;
		ans %= mod;
	}
	cout<<ans%mod;//输出时取模 
	return 0;
}
```
有一道相似的弱化题，附在这里：[弱化版](https://www.luogu.com.cn/problem/P2629)。

---

## 作者：过氧化氢_syq0057 (赞：3)

没想到 std 那么简单的思路。提供一个比较硬来的做法。

### Solution

为了方便表述，以下若称 $i$ 为安全点则意为序列 $A$ 左移到以第 $i$ 项为起始项时，序列 $A$ 是安全的。

观察一下样例 1 或手模一下容易发现，若 $A_i$ 有 $m$ 个安全点，则 $A_{i+1}$ 有 $m^2$ 个安全点。

所以设 $A_0$ 有 $ans$ 个安全点，那么 $A_1$ 有 ${ans}^2$ 个安全点，以此类推 $A_k$ 有 ${ans}^{2^k}$ 个安全点，$A_{k+1}$ 的长度等于 $A_k$ 的长度乘以 $A_k$ 的安全点数量，即答案为 ${ans}^{2^{k}}$。

现在的问题是如何求 $ans$。

安全点肯定在序列中值为 ```1``` 的项上，我们可以把序列分块，使每一块的前面全是 ```1```，后面全是负数（```0``` 是不影响答案的，可以都跟着放在里面不用管），如果看单独一块对安全点的贡献就是这一块的和（到这里其实已经能得到 std 的思路了），所以枚举每一个块在最左边时，能产生几个安全点，然后累加一下就好了。

对分块后的序列做一个前缀和，发现若一个点是安全点需要满足这个序列从这个点开始前缀和最小的地方 $>0$，所以对前缀和再分块，每次查询区间最小值。因为每次查询都是查询整个序列，所以我取的块长 $sn=op^{0.6}$，其中 $op$ 是按上一段的操作对 $A$ 分块后块的数量。

这样复杂度看起来比较劣，是 $O(op^{1.4})$ 的，但其实很多都被 $blk[i].sigma>0$ 判掉了，最极端的数据全是 ```1 1 -1``` 这种也是 $O(5e7)$ 左右（其实用线段树更稳，这个可能会被卡掉）。

### Code
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <cstring>
#include <queue>
#include <map>
#include <ctime>
using namespace std;
const int N = 1000005;
const int M = 200005;
#define ll long long
const ll INF = 0x3f3f3f3f3f3f3f;
const ll mod = 998244353;
int n;
ll k;
int b[N];
struct block {
	ll sigma;
} blk[N];
int op;
ll presum[N];
int Block[N];
int sn;
ll minn[N];
ll ans;
ll query(int l, int r) {
	ll res = INF;
	for (int i=l; i<=min(Block[l]*sn,r); ++i)
		res = min(res, presum[i]);
	if (Block[l] != Block[r])
		for (int i=(Block[r]-1)*sn+1; i<=r; ++i)
			res = min(res, presum[i]);
	for (int i=Block[l]+1; i<Block[r]; ++i)
		res = min(res, minn[i]);
	return res;
}
ll ksm(ll x, ll y) {
	ll res = 1ll;
	while (y) {
		if (y & 1) res = res * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return res;
}
ll ksm2(ll x, ll y) {
	ll res = 1ll;
	while (y) {
		if (y & 1) res = res * x % (mod - 1);
		x = x * x % (mod - 1);
		y >>= 1;
	}
	return res;
}
int main() {
	scanf("%d%lld", &n, &k);
	ll sum = 0;
	for (int i=1; i<=n; ++i)
		scanf("%d", &b[i]), sum += (ll)b[i];
	if (sum <= 0) {
		printf("0\n");
		return 0;
	}
	op = 1;
	for (int i=1; i<=n; ++i) {
		blk[op].sigma += b[i];
		if (b[i] <= 0 && b[i + 1] == 1)
			++op;
	}
	for (int i=1; i<=op; ++i) {
		presum[i] = presum[i - 1] + blk[i].sigma;
		minn[i] = INF;
	}
	sn = pow(op, 0.6);
	for (int i=1; i<=op; ++i) {
		Block[i] = (i - 1) / sn + 1;
		minn[Block[i]] = min(minn[Block[i]], presum[i]);
	}
	ll Min1, Min2;
	for (int i=1; i<=op; ++i) {
		if (blk[i].sigma > 0) {
			if (i == 1) {
				Min2 = query(i + 1, op);
				if (blk[i].sigma + Min2 > 0) ans += blk[i].sigma + min(0ll, Min2);
			}
			else if (i == op) {
				Min1 = query(1, i - 1);
				if (blk[i].sigma + Min1 > 0) ans += blk[i].sigma + min(0ll, Min1);
			}
			else {
				Min1 = query(1, i - 1);
				Min2 = query(i + 1, op) - presum[i];
				if (Min1 >= 0) {
					if (blk[i].sigma + Min2 > 0) ans += blk[i].sigma + min(0ll, Min2);
				}
				else {
					ll s = min(presum[op] - presum[i - 1] + Min1, blk[i].sigma + min(0ll, Min2));
					if (s > 0) ans += s;
				}
			}
		}
	}
	ans = ksm(ans, ksm2(2ll, k));
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：block_in_mc (赞：3)

## 解题思路

先给出结论，答案为：$\max(0,\sum\limits_{i=1}^na_i)^{2^k}$，下面给出证明：

显然，若 $\sum\limits_{i=1}^na_i\le0$，答案为 $0$，即不存在安全的序列。下面考虑其大于 $0$ 的情况。

对于每一个非正数 $a_i$，我们向前求和直到 $a_j$ 使得 $\sum\limits_{k=j}^ia_k>0$（这里认为 $a_1$ 前的数是 $a_n$），并将 $a_j,a_{j+1},\cdots,a_{i}$ 分为一组，以样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/5lc0o6v3.png)

我们发现，前缀和数组含有小于等于 $0$ 的数字当且仅当第一个数被分到某一组中，此时，在加到这一组的最后一个数时，前缀和总小于等于 $0$，否则与分组方法矛盾。因此，每一个没有被分组的数字作为首项代表一种方案。在样例中，能够作为第一个的数字只有 $a_4$ 和 $a_8$ 两种情况。

接下来考虑将这两个序列拼接起来。不难发现，拼接时每一个序列没有被分组的数字的数量不变。若拼接前有 $c$ 个没有被分组的数字，则拼接后有 $c$ 个序列，每个序列有 $c$ 个没有被分组的数字，共有 $c^2$ 个没有被分组的数字。因此，答案即为 $c\leftarrow c^2$ 重复 $k$ 次，其中 $c$ 是初始时没有被分组的数字的数量。

考虑 $c$ 的含义。由于数列中每一个正数项都是 $1$，且被分组的数字之和为 $0$，可以发现 $c$ 实际上就是原数组中每一个数的和，答案即为 $\max(0,\sum\limits_{i=1}^na_i)^{2^k}$。

总时间复杂度 $O(n+k)$。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, k, x, sum;
int main() {
	scanf("%lld%lld", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%lld", &x), sum += x;
	for (int i = 1; i <= k; i++) sum = (sum * sum) % 998244353;
	printf("%lld", sum);
    return 0;
}
```

---

## 作者：隔壁泞2的如心 (赞：3)

~~这题题解写起来咋这么难受（~~

首先如果 $A_0$ 的总和 $\le 0$，必然 $A_1$ 直接就为空，所以判掉。

然后设这个总和为 $v$，此时一定能找到 $A_0$ 的一个安全的循环移位。设这个循环移位后的数组为 $B$，$B$ 循环左移 $k$ 位的数组为 $B_k$ ，$B_k$ 的前 $i$ 项和为 ${C_k}_i$，容易发现：

- 对于所有 $0 \le x \le v-1$，有且仅有最大的满足 ${C_0}_y=x$ 的 $y$ 使得 $B_{y-1}$ 是安全的。

- 对于所有 $x > v$，不存在满足 ${C_0}_y=x$ 的 $y$ 使得 $B_{y-1}$ 是安全的。

综上可以得到结论：对任意数组，它安全的循环移位数量等于它的总和。这样模拟一下过程，用快速幂算出答案就可以了。


```cpp
#include<cstdio>
using namespace std;
long long a[2000011];
const int p=998244353;
inline long long minn(long long x,long long y){return x<y?x:y;}
inline long long ksm(long long x,long long y,long long z){
	long long k=1,l=x;
	while(y){if(y&1)k=k*l%z;l=l*l%z,y>>=1;}
	return k;
}inline long long rd(){
	long long i=0,j=1;char g=getchar();
	while(g>57||g<48){if(g=='-')j=-1;g=getchar();}
	while(g>47&&g<58)i=(i<<3)+(i<<1)+g-48,g=getchar();
	return i*j;
}
int main()
{
	long long i,j,h,m,n=rd(),k=rd();h=n;
	for(i=1,j=0;i<=n;i++){
		a[i]=a[i-1]+rd(); 
	}if(a[n]<0)a[n]=0;
	printf("%lld\n",ksm(a[n],ksm(2,k,p-1),p));
	return 0;
}
```

---

## 作者：m1kusama (赞：2)

## subtask2

初看体面完全没有思路，于是开了 sub2。

看到 $k=0$，考虑只对原序列操作一次如何做。

记 $A$ 为原数组，$S_i$ 为原数组前 $i$ 位之和。

模拟题意，考虑每个前缀和是否大于 $0$，直接进行循环移位是 $O(n^2)$ 的，考虑如何优化：

观察原数组每一位对 $S$ 数组的贡献，发现第 $i$  位会对从 $S_i$ 到 $S_{i+n}$ 有 $A_i$ 的贡献，若进行循环移位，也就是将 $A_i$丢到数组最后，$S_i$ 到 $S_{i+n}$ 会减少 $A_i$。

则每次查询区间是否合法，也就是查询 $S$ 数组的区间最小值。

观察到区间加减、查询最小值操作，不难想到线段树。

建一颗线段树，存储长度为 $2n$ 的数组，其中前 $n$ 位存前缀和，后 $n$ 位置 $0$。

每次操作，将区间 $[i,i+n-1]$ 减去 $a_i$，将 $i+n$ 赋为原序列各位总和（因为代表的是整个序列的前缀和），查询区间 $[i,i+n-1]$ 的最小值是否严格大于 $0$ 即可。

每次操作为 $O(\log n)$，共要循环移位 $n$ 次，总时间复杂度为 $O(n\log n)$。

## 100pts 

记操作前后序列长度之比为 $m$，分析一次操作后的序列，发现它是由 $m$ 个合法序列拼接而成的。

对于第 $i$ 个序列，他有 $m$ 个循环移位是合法的，那对应到拼接后的数组，不难发现在这中间依次拼接第 $i+1$、 $i+2$ …… $n$、$1$、$2$ …… $i-1$ 个合法序列，因为对于每一部分保证合法，合起来也一定是合法的。

考虑统计答案，每次操作有 $m$ 个序列做出了 $m$ 个贡献也就是答案会自乘一次，共计 $k$ 次。

对应到代码就是这样：

```cpp
while(k--)ans=(ans*ans)%mod;
```

只需要求解 $k=0$ 的情况再自增即可，时间复杂度 $O(n \log n)$。

贴一下代码，大部分码量集中在线段树。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=2e6+10,inf=1e18,mod=998244353;
int n,k;
int a[N];
int s[N];
int ansc;

struct tree{
	int l,r,tag,mi;
}t[N<<2];
void pushup(int now){
	t[now].mi=min(t[now<<1].mi,t[now<<1|1].mi);
}
void build(int now,int l,int r){
	t[now].l=l,t[now].r=r;
	if(l==r) return t[now].mi=s[l],void();
	int mid=(l+r)>>1;
	build(now<<1,l,mid);
	build(now<<1|1,mid+1,r);
	pushup(now);
}
void pushdown(int now){
	if(t[now].tag){
		t[now<<1].tag+=t[now].tag;
		t[now<<1|1].tag+=t[now].tag;
		t[now<<1].mi+=t[now].tag;
		t[now<<1|1].mi+=t[now].tag;
		t[now].tag=0;	
	}
}
int ask(int now,int l,int r){
	int ans=inf;
	if(t[now].l>=l and t[now].r<=r){
		return t[now].mi;
	}
	pushdown(now);
	int mid=(t[now].l+t[now].r)>>1;
	if(l<=mid) ans=min(ans,ask(now<<1,l,r));
	if(r>mid) ans=min(ans,ask(now<<1|1,l,r));
	pushup(now);
	return ans; 
}
void update(int now,int l,int r,int k){
	if(t[now].l>=l and t[now].r<=r)return t[now].tag+=k,t[now].mi+=k,void();
	pushdown(now);
	int mid=(t[now].l+t[now].r)>>1;
	if(l<=mid) update(now<<1,l,r,k);
	if(r>mid) update(now<<1|1,l,r,k);
	pushup(now);
} 

void solve(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		s[i]=s[i-1]+a[i];
	}
	int sum=s[n];
	build(1,1,n*2);
	int ans=0;
	for(int i=1;i<=n;i++){
		update(1,i+1,i+n-1,-a[i]);
		update(1,i+n,i+n,sum);
		if(ask(1,i+1,i+n)>0)ans++;
	}
	while(k--)ans=(ans*ans)%mod;
	cout<<ans;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```

---

## 作者：homo_snow (赞：1)

# 题意

有一个数列 $A_0$，你可以将开头的一个元素移动到末尾。

要将 $A_i$ 扩展到 $A_{i+1}$，仅当 $A_i$ 的**任何**一段以开头为起始节点的前缀和不为 $0$。

初始 $A_{i+1}$ 为空。

对于 $A_i$ 扩展到 $A_{i+1}$ 的过程，就是将 $A_i$ 接到 $A_{i+1}$ 末尾。

给定一个 $k$ 求 $A_{k+1}$ 与 $A_{k}$ 的长度之比。

# 思路

有点复杂的找规律。

看题可得：这个 $A_i$ 有多少种前缀和中不出现 $0$ 的排列形态，$A_{i+1}$ 就是 $A_i$ 的多少倍。

就举样例的例子：

先找出样例前缀和。

$S_0=\{1,2,0,1,2,1,1,2\}$

发现第三位出现了 $0$，我们由此可得，前面所有的元素的和都小于等于第三位的数字，由于我们将前面的数字移动到后面后，就相当于减小了前面的前缀和，它都不够用了，我们还抢它的，显然是不对的。

所以，干脆把 $0$ 和它前面的所有的元素丢到末尾去，这样就能相当于用后面的一段前缀和增加了这一段前缀和，这样如果还不能消去这个 $0$，那就是真没办法了，无解。

那又会有一个问题：本来是在后面的前缀和，忽然少掉了前面一段，那这一段又变少了。

如果没有出现小于等于 $0$ 的元素，那最好。否则就由无解了。

恭喜你成功搞定了转移方法，现在来考虑转移后的事情。

现在我们将样例转移过程列出：

先将 $0$ 移动到后面：

$A_0 = \{1,1,-1,0,1,1,1,-2\}$

此时前缀和变为：

$S_0=\{1,2,1,1,2,3,4,2\}$

这个时候先把这一段符合条件的序列接上 $A_1$：

$A_1=\{1,1,-1,0,1,1,1,-2\}$

继续找，发现都会存在 $0$，直到：

$A_0=\{1,1,1,-2,1,1,-1,0\}$

此时前缀和都大于 $0$，又能为 $A_1$ 增加一段：

$A_1=\{1,1,-1,0,1,1,1,-2,1,1,1,-2,1,1,-1,0\}$

长度为 $16$。

此时样例的答案求出来了，但我们的规律还没求出来。

先求出 $A_1$ 的前缀和求出：

$S_1=\{1,2,1,1,2,3,4,2, 3,4,5,3,4,5,4,4\}$

我们以中间的空隙为分割点，将其分为两部分：

$S_{1_1} = \{1,2,1,1,2,3,4,2\}$

$S_{1_2} = \{1,2,3,1,2,3,2,2\}$

发现这两段前缀和分别对应 $A_0$ 符合条件的排列的前缀和，此时把两端都拼接起来，就相当于把 $A_0$ 的可用方案数弄了各平方。

至于证明，就当留作道思考题吧。~~（绝对不是我不会）~~

总之，我们就求出了长度的递推公式：

设 $A_0$ 可用的方案数为 $p$。

$A_{i+1}$ 与 $A_i$ 的长度比就是将 $p$ 平方 $k$ 次。

好了，思路分析完了，怎么写代码？

考虑将初始数列扩大一倍来实现循环数列，同时打前缀和。

考虑枚举长 $n$ 的区间，左端点为 $l$，右端点为 $r$。

对于区间 $[l,r]$ 的前缀和，就相当于在全局前缀和中将区间 $[l,r]$ 的每个数减去 $S_{l-1}$。

但显然时间复杂度会爆炸，考虑优化。

实际上，我们只需要找有没有小于等于 $0$ 的数，所以考虑打单调队列，求出区间最小值，再与 $S_{l-1}$ 比较，就可以求出所有的方案数。

最后求答案，输出。

结束了。


```cpp
#include<bits/stdc++.h>
#define int long long	
using namespace std;
const int N = 2e6+10;
const int INF = 0x3f3f3f3f;
const int mod = 998244353;

int n , k, a[N], sum[N],cnt,tot,book[N];
deque<int> q;

signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i = 1; i <= n; i++)
		scanf("%lld",&a[i]);
	for(int i = n+1; i <= n*2; i++) a[i] = a[i - n];
	for(int i = 1; i <= n * 2; i++) sum[i] = sum[i-1] + a[i];
	// for(int i = 1; i <= n*2; i++) printf("%lld ",sum[i]);
	for(int i = 1; i <= n*2; i++){
		while(q.size() && q.front() <= i - n) q.pop_front();
		while(q.size() && sum[q.back()] > sum[i]) q.pop_back();
		q.push_back(i);
		if(i > n && sum[q.front()] > sum[i-n]) tot++;
	}
	for(int i = 1; i <= k; i++) tot = tot * tot % mod;
	printf("%lld\n",tot);
	return 0;
}
```

---

## 作者：Shadow_T (赞：1)

## 题目解析

这是洛谷专栏更新后我的第一篇题解。

### $\texttt{Subtask 2}$

这个 sub 对题目思考很有帮助。我们先来考虑只用变换一次情况。

可以用优先队列来维护所有前缀和，进行 $n$ 次变换，对于每次变换，如果优先队列中最小的小于等于 $0$，那么这个序列不是安全的，然后将 $a_i$ 从队列中推出，再加入 $a_i$ 放到序列背后的前缀和。对于优先队列推出 $a_i$ 这个操作，可以用类似懒标记的方法。

```
ll ans=0;
for(int i=1;i<=n;i++)
{
  while(mp[pr.top()]) mp[pr.top()]--,pr.pop();
  if(pr.top()>q[i-1]) ans++;
  mp[q[i]]++;
  pr.push(q[n+i-1]+a[i]);
  q[n+i]=q[n+i-1]+a[i];
}
```

### $100$ 分写法

假设第 $n$ 次的变换后长度为 $ans$。

那么很明显第 $n+1$ 次变换中会有 $n^2$ 个可以作为开头的点，再对于每次点复制一次序列，则 $|A_{n+1}|=n^3$，和 $|A_n|$ 的比值为 $n^2$。

那么只要处理出第一次，然后将它平方 $k$ 次。

### 代码

```
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
#define ull unsgined long long
#define fir first
#define sec second
#define pb push_back
namespace IO
{
	void Ios()
	{
		ios::sync_with_stdio (0);
		cin.tie(0);
		cout.tie(0);
	}
	void Read(int n,int a[])
	{
		for(int i=1;i<=n;i++)
		cin>>a[i];
	}
	void Print(int n,int a[])
	{
		for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";
	}
	string mul(string a1,string b1)
	{
    	int lena=a1.size();
    	int lenb=b1.size();
    	int len=max(lena,lenb)*2+1;
    	vector<int> a(len,0),b(len,0),c(len,0);
    	for(int i=0;i<lena;i++) a[lena-i]=a1[i]-'0';
    	for(int i=0;i<lenb;i++) b[lenb-i]=b1[i]-'0';
    	for(int i=1;i<=lena;i++)
    	{
			int x=0;
			for(int j=1;j<=lenb;j++)
			{
                c[i+j-1]=a[i]*b[j]+x+c[i+j-1];
                x=c[i+j-1]/10;
				c[i+j-1]%=10;
			}
			c[i+lenb]=x;
    	}
    	int lenc=lena+lenb;
    	while(c[lenc]==0&&lenc>1) lenc--;
    	string ans="";
    	for(int i=lenc;i>=1;i--)
    	ans+=c[i]+'0';
    	return ans;
    }
};
using namespace IO;
//This is My namespace.
const int maxn=2e6+10;
ll a[maxn],q[maxn];
map<int,int> mp;
const int mod=998244353;
signed main()
{
	Ios();
	int n,k;
	cin>>n>>k;
	priority_queue<int,vector<int>,greater<int> > pr;
	ll Min=2;
	for(int i=1;i<=n;i++)
	cin>>a[i],q[i]=q[i-1]+a[i],pr.push(q[i]),Min=min(Min,a[i]);
	if(Min<-n)
	{
		cout<<0;
		return 0;
	}	
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		while(mp[pr.top()]) mp[pr.top()]--,pr.pop();
		if(pr.top()>q[i-1]) ans++;
		mp[q[i]]++;
		pr.push(q[n+i-1]+a[i]);
		q[n+i]=q[n+i-1]+a[i];
	}
	while(k--) ans*=ans,ans%=mod;
	cout<<ans<<"\n";
	return 0;
}
```

[subtask 2 写法](https://www.luogu.com.cn/record/173974301)

[满分记录](https://www.luogu.com.cn/record/173977012)

---

## 作者：FeiDing (赞：1)

### 题意

有一个长 $n$ 的序列，我们分别从 $[1, n]$ 开始遍历，每次遍历到尾就跳到头继续。遍历开始时设一个变量 $cnt$，遍历时累加序列中的数。如若整个遍历过程中一直 $cnt > 0$，那么称这次遍历是“安全的”。

每次“安全的”遍历都会生成了一个长度为 $n$ 的新序列，将这些新序列按序列开头的数在原序列的位置从小到大排序，然后将它们拼接到一起，替换原序列。

我们**再**执行以上操作 $k$ 次，求最后一次操作找到了几个“安全的”遍历。

---

### 解法

先考虑 $k = 0$ 的情况。

看到遍历时要从尾跳到头，所以我们将原序列复制一遍接在后面，这个长 $2n$ 的序列记为 $a$。

看到遍历时要累加，我们记 $a$ 的前缀和为 $s$。

于是问题就转化为：求满足以下条件的正整数 $i$ 的个数：

- $n < i \le 2n$

- $\min_{j = i - n + 1}^{i} s_j > s_{i - n}$

一眼单调队列。

再将 $k > 0$ 的情况考虑。

我们分割 $s$。

设 $s = \overline{s_1s_2s_3} $。

假设 $\overline{s_2s_3s_1}$ 和 $\overline{s_3s_1s_2}$ 是“安全的”，连接在一起得到 $\overline{s_2s_3s_1s_3s_1s_2}$。

因为 $\overline{s_2s_3s_1}$ 和 $\overline{s_3s_1s_2}$ 是“安全的”，在连接后的序列中从第一个 $s_2$ 或第二个 $s_3$ 开始遍历是“安全的”。

由“安全的”的定义得 $\overline{s_3s_1s_2}$ 的前缀 $\overline{s_3s_1}$ 也是“安全的”，所以从第一个 $s_3$ 开始遍历也是“安全的”。同理，从第二个 $s_2$ 开始遍历也是“安全”的。

看得出来，如果第一次操作找到 $x$ 个“安全的”遍历。那第二次操作就会找到 $x^2$ 个“安全的”遍历，第三次就会找到 $(x^2)^2$ 个“安全的”遍历。最后一次是第 $(k + 1)$ 次。只需将最开始用单调队列求得的 $x$ 平方 $k$ 次即可。

代码：

```cpp
#include <bits/stdc++.h>

#define int long long

//#define DEBUG

using namespace std;

#ifndef DEBUG
const int N = 2e6 + 10;
#else
const int N = 17;
#endif
const int mod = 998244353;

int n, k;
int s[N], a[N], maxn[N];
deque <int> q;

signed main ()
{
  cin >> n >> k;
  for (int i = 1; i <= n; i++){
    cin >> a[i];
  }
  for (int i = n + 1; i <= 2 * n; i++)
    a[i] = a[i - n];
  for (int i = 1; i <= 2 * n; i++)
    s[i] = s[i - 1] + a[i];

  int res = 0;
  for (int i = 1; i <= 2 * n; i++)//单调队列
  {
    while (q.size () && q.front () + n <= i)
      q.pop_front ();
    while (q.size () && q.back () && s[i] <= s[q.back ()])
      q.pop_back ();
    q.push_back (i);
    if (i > n && s[q.front()] > s[i - n])
      res++;
  }
  for (int i = 1; i <= k; i++)
  {
    res *= res;
    res %= mod;
  }
  cout << res;
}
```

---

## 作者：AzureHair (赞：1)

迟到的题解。

简明题意：给定一个长度为 $n$ 的数列 $a_n$，每个元素都是小于等于一的整数，将他的所有循环位移中满足任意前缀和大于零的情况按照出现的先后顺序接成一个新的数列，进行上述操作 $k$ 次后求满足条件的循环位移个数。

这是一道或许很多人都见过的结论题，结论是对于每个元素都是小于等于一的整数的数列的和为 $s$，$s>0$，他的循环位移中恰有 $s$ 个满足任意前缀和大于零，故答案为 $s^{2^k}$ 对 998244353 取模的结果。

我们来证明一下这个东西，我们假设他的 $n$ 个数的和是 $m$，首先它是循环位移，所以我们先扩展一下这个数列，使得他 $a_i=a_{i+kn}$，随后我们寻找最大的位置满足前缀和 $s_i=x(x=0,1\cdots m-1)$ 由于 $s_i+m=s_{i+n}$ 所以同余的不需要考虑。由于我们知道他是最后一个满足的位置，又因为他是增长趋势，所以这就说明他不会出现下降到当前值之下再增长回来的情况，因为这样我们找的就不是最后一个了，于是我们找的这 $m$ 个位置即对应着 $m$ 种循环位移。证毕。

好了到此这道题全部结束了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,s=0;
int ksm(int x,int y,int mod)
{
	int tmp=1;
	while(y)
	{
		if(y)tmp=tmp*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return tmp;
}
signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%lld",&x);
		s+=x;
	}
	if(s<=0)printf("0\n");
	else printf("%lld\n",ksm(s,ksm(2,k,998244352),998244353));
	return 0;
}
```

---

## 作者：Walter_Fang (赞：0)

笑点解析：昨天写完没点申请题解，今天题解申请通道关了。

看到很多大佬写了 `STL` 和单调数据结构做法，这里给个思维含量颇高的数学做法。

### 题目描述
规定一个序列为“安全的”当且仅当这个序列的所有前缀和为正数。

给定一个长度为 $n$ 的序列 $A_i$，执行 $n$ 次以下操作得出新的数列 $A_{i+1}$：

- 若 $A_i$ 是安全的，将其接到 $A_{i+1}$ 末尾。
- 将 $A_i$ 循环左移 $1$ 位。

求 $\dfrac{|A_{k+1}|}{|A_k|}$，答案对 $998244353$ 取模。

### 思路解析

设所求答案 $f(i)=\dfrac{|A_{i+1}|}{|A_i|}$，$g(i)=\sum^i_{j=1}A_{ij}$，易证 $f(i)=g(i)$。
于是 $f(i+1)=g(i+1)=f(i)g(i)=f(i)^2$。所以 $f(k)=g(0)^{2^k}$。写个快速幂就行了，理论上可以用费马小定理再优化一下，没试。

不放代码。

---

## 作者：Jerrycyx (赞：0)

## 解题思路

由于“$A$ 中各项均不大于 $1$”，所以我们首先考虑负数和 $0$ 对答案的影响。

+ 对于 $0$，以 $0$ 开头数列第一位前缀和就不大于 $0$，直接被淘汰，且 $0$ 不会对其后任何前缀和造成影响。所以 $0$ 可以忽略不计。

+ 对于一个负数 $-t$，它会抵消掉前面 $t$ 个 $1$，使这些 $1$ 不能作为开头（否则在后面 $-t$ 的位置会被减成不大于 $0$ 的数）

综上所述，设每次操作前数列中 $1$ 的数量为 $x$，负数绝对值的和为 $y$，则整个数列中可以作为开头的数（未被抵消的数）的数量为 $x-y$ 个。

代码里可以简化一下，直接把数列中所有数相加即为 $x-y$。

然后考虑经过 $k$ 次操作后的结果。设上文的 $x-y=a$，则对于每次操作，数列将被复制 $a$ 份并以不同的循环排列拼接在一起，其长度变为原来的 $a$ 倍。

对于复制出来的每一份，显然它们各自的 $a$ 都不变（数列和不变），所以新的数列的 $a'$ 应当是原来每份数列可用开头的数量 $a$ 乘以数列数量 $a$，即 $a'=a \times a$。

把上述操作执行 $k$ 次，即计算出 $a$ 后将 `a=a*a` 执行 $k$ 次，最终的结果就是最后可用开头的数量。

注意特判 $a<0$ 的时候无法复制，输出 $0$。

## 代码

```cpp
#include<cstdio>
using namespace std;

const int N=1e6+5,P=998244353;
int n,k,a[N],cnt;

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		cnt+=a[i];
	}
	if(cnt>0)
	{
		long long ans=cnt;
		for(int i=1;i<=k;i++)
			ans=ans*ans%P;
		printf("%lld\n",ans);
	}
	else printf("0\n");
	return 0;
}
```

---

## 作者：mahaihang1 (赞：0)

## 25pts
考虑将 $A_0$ 在最后复制一遍，通过统计前缀和数组 $S$，则第 $i$ 次操作时只需判断 $\forall j \in [i+1,i+n]$，$S_j-S_i > 0$，可以优化到 $O(n^2)$。

显然，如果第 $i$ 次操作时 $A$ 是安全的，则定有 $\displaystyle\min_{j=i+1}^{i+n} S_j>S_i$。因此，我们可以使用单调队列求区间最小值，优化到 $O(n)$。

## 100pts
假设我们已知 $k=x$ 时 $A_k$ 与 $A_{k+1}$ 的长度比 $l$，则 $A_{k+1}$ 显然由 $l$ 个在操作中能够贡献 $l$ 个安全的数列组成，因此 $A_{k+1}$ 与 $A_{k+2}$ 的长度比为 $l^2$。

在 $25pts$ 的基础上，我们便可将 $A_0$ 与 $A_1$ 的长度比，在 $O(k)$ 的时间复杂度内推到 $A_k$ 与 $A_{k+1}$ 的长度比，即为答案。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2000010,mod=998244353;
int n,k,a[N],s[N],ans;
deque <int> q;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],a[i+n]=a[i];//将A复制到A末尾
	for(int i=1;i<=2*n;i++) s[i]=s[i-1]+a[i]; 
	for(int i=1;i<=2*n;i++){
		while(q.size()&&s[q.back()]>=s[i]) q.pop_back();
		q.push_back(i);
		while(q.size()&&i-q.front()>=n) q.pop_front();//线段树求区间最小值 
		if(i>n) ans+=bool(s[q.front()]-s[i-n]>0),ans%=mod;
	}
	while(k--) ans=ans*ans%mod;
	cout<<ans;
	return 0;
}
```

附：弱化版题目 [P2629 好消息，坏消息](https://www.luogu.com.cn/problem/P2629)。

---

## 作者：xxseven (赞：0)

本题解的做法**不依赖值域**。

先考虑如何求出 $k=0$ 时的答案。

由于条件跟前缀和相关，所以先求出前缀和。

不难发现循环移位实际是每次将原序列的一个后缀挪到了序列最前面。  
我们考虑将一个后缀挪到最前面后，序列的前缀和将如何变化。

记序列长度为 $n$，名称为 $a$，后缀 $a[i\cdots n]$ 被挪到了最前面，那么以 $a[1 \cdots i-1]$ 结尾的前缀和就会增加 $\sum_{j=i}^n a_i$，原后缀的前缀和会减少 $\sum_{j=1}^{i-1} a_i$。

那么对于两部分分别考虑，维护前缀最大值和后缀最大值即可。代码很好写。

然后对于 $k \gt 0$ 的情况，我们可以~~暴力打表~~得出每个 $k$ 会让答案平方，然后直接做就好了。

赛时代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e6+6;
int n,k,a[N],f[N],mn[N],ans;
//mn为前缀最小值
void suball(){
	mn[0]=2e9;
	for(int i=1;i<=n;++i) {
		cin>>a[i]; f[i]=f[i-1]+a[i];
		mn[i]=min(f[i],mn[i-1]);
	}
	int now=2e9; //now为后缀最小值
	for(int i=n;i>=1;--i){
		if(f[i]<now&&mn[i]+f[n]-f[i]>0){
			now=f[i]; ans++;
		}
	}
	for(int i=1;i<=k;++i){
		ans=(ans*ans)%998244353;
	}
	cout<<ans;
}
signed main(){
	cin>>n>>k; 
	suball(); 
	return 0;
}
```

希望这篇题解能够帮到你！

---

## 作者：fish_love_cat (赞：0)

首先可以发现，每天积分最多加一，这是一个很重要的性质。

我们假设有一天扣了 $x$ 分。

可以发现，在这一天前的 $x$ 个有分的天都无法作为开头了。因为加起来到了这一天都会出事。

所以一个扣了 $x$ 分的天可以抵掉 $x$ 个有分的天。你会发现这 $x+1$ 个数加起来恰好等于 $0$。

我们把整个数列全部加起来，记和为 $sum$，会抵掉的自然就相加变成 $0$ 了，那么剩下的合法开头显然有 $\max(sum,0)$ 个。

我们已经完成了第一步了。

如果 $sum\le 0$，那么显然无解。

如果 $k=0$，那么答案就是合法开头数量，即 $sum$。

如果 $k \ge 1$，设 $f_i$ 为 $A_i$ 里的合法开头数量，$c_i$ 为 $A_i$ 里 $A_0$ 及其变种的数量，有 $f_0=sum,c_0=1$。

注意到，除了 $A_0$，其余都满足 $c_i=f_i$。

显然，以原来的合法开头作为每一段 $A_0$ 开头的序列一定合法，而以其他为开头一定不合法。如果以其他为开头你会发现一段都跑不完，是错误的。

那么可以得出 $f_i=f_{i-1}\times c_{i-1}={f_{i-1}}^2$。

所以 $f_k={{{{f_0}^2}^2}^{...}}^2=sum^{(2^k)}$。

而 $f_{k+1}:f_k={f_k}^2:f_k=f_k$。

所以我们只需要求出 $sum^{(2^k)}$ 即可。

使用快速幂即可。

注意到指数的大小非常爆炸，但同时可以观察到指数是 $2$ 的幂，分析快速幂的本质，我们可以通过修改快速幂的函数体求解。

---

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int flc;
long long qpow(long long a,long long b,long long p){
	long long ans=1;
	while(b--){
		a*=a;
		a%=p;
	}
	return a;
}
signed main(){
    int n,k;
    cin>>n>>k;
    for(int i=1,a;i<=n;i++)
    cin>>a,flc+=a;
    if(flc<=0)cout<<0;
    else if(k==0)cout<<flc;
    else cout<<qpow(flc,k,998244353);
    return 0;
}
```

---

听说线段树可以草过去，而且不依赖值域……？

---

## 作者：I_will_AKIOI (赞：0)

我们设 $x$ 为 $A_0$ 不断进行循环移位后有几个是安全的。第一次操作之后， $A_1$ 就会变成 $x$ 个 $A_0$。而这个 $A_0$ 之中有 $x$ 个安全的数列，而 $A_1$ 由 $x$ 个 $A_0$ 组成，所以 $A_1$ 一共有 $x^2$ 个安全的数列。同理，$A_2$ 就有 $(x^2)^2$ 个安全的数列，以此类推，所以 $A_i$ 就有 $x^{(2^i)}$ 个安全的数列，所以答案为 $x^{(2^k)}$，因此本题的关键就在于求开始的 $A_0$ 有多少个安全的数列。

发现循环移位可以把 $A_0$ 看做一个环，所以接着破环为链进行计算，然后做一遍前缀和，根据前缀和的性质，可以得出对于下标 $i$，要满足前缀和始终大于 $0$，就需要满足 $\displaystyle\min_{j=i}^{i+n-1} a_j>a_{i-1}$。所以我们需要一个可以查询长度为 $n$ 的区间最小值即可，可以选用单调队列或者线段树维护。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
#define N 2000005
using namespace std;
struct Data{int l,r,minn;}t[N*4];
int n,m,k,ans,a[N],sum[N];
void build(int k,int l,int r)
{
	t[k].l=l,t[k].r=r;
	if(l==r)
	{
		t[k].minn=a[l];
		return;
	}
	int mid=l+r>>1;
	build(k*2,l,mid);
	build(k*2+1,mid+1,r);
	t[k].minn=min(t[k*2].minn,t[k*2+1].minn);
	return;
}
int query(int k,int l,int r)
{
	if(l<=t[k].l&&t[k].r<=r) return t[k].minn;
	int mid=t[k].l+t[k].r>>1,ans=1e18;
	if(l<=mid) ans=min(ans,query(k*2,l,r));
	if(r>mid) ans=min(ans,query(k*2+1,l,r));
	return ans;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	k=n*2;
	for(int i=1;i<=n;i++) cin>>a[i],a[i+n]=a[i];
	for(int i=1;i<=k;i++) a[i]+=a[i-1];
	build(1,1,k);
	for(int i=1;i<=n;i++) if(query(1,i,i+n-1)>a[i-1]) ans++;
	for(int i=1;i<=m;i++) ans=ans*ans%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：wht_1218 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10893)

## 非正解！

题解按照形式化题意解释。

首先有一个很神奇的结论：我们只要知道 $A_1$ 是有多少个 $A_0$ 组成，就可以知道答案了。

设 $A_1$ 是由 $m$ 个 $A_0$ 构成，不一定按顺序，但是通过暴力程序，我们知道 $A_i$ 与 $A_{i-1}$ 的长度比是 $A_{i-1}$ 与 $A_{i-2}$ 的长度比的平方。

猜出来的，手搓几十个数据都是对的。

具体的实现需要给前缀和排序，所以时间 $O(n\log n)$ 是卡过去的，不过飞快。

我的做法常数感觉有点大。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,K;
vector<long long> p;
struct node{
	int id;
	long long x;
};
node sum[1000007],sums[1000007];
inline bool cmp(node a,node b){
	return a.x<b.x;
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>K;
    long long mins=0x7f7f7f7f7f7f7f;
    sum[0].x=0;
    for(int i=1;i<=n;++i){
    	int x;
    	cin>>x;
    	p.push_back(x);
    	sum[i].x=sum[i-1].x+x;
		sum[i].id=i;
		sums[i]=sum[i];
	}sort(sums+1,sums+n+1,cmp);//排序别把原来的sum搞没了。
	long long ans=0,radd=0,pre=sum[n].x;
	int now=1;
	for(int j=1;j<=n;++j){//j是从暴力改过来的。
		if(sums[now].x-radd>0){
			if(mins-radd>0)ans++;
		}int x=p[j-1];
		radd+=p[j-1];
		p.push_back(x);
		while(now<n&&sums[now].id<=j)now++;
		mins=min(mins,pre+p[p.size()-1]);
		pre=pre+p[p.size()-1];
	}
	for(int i=1;i<=K;++i){
        ans=ans*ans;
        ans%=998244353ll;
    }
	cout<<ans;
    return 0;
}
```

---

## 作者：thh_loser (赞：0)

# P10893 城市化发展委员会 题解

# 题意
给定一序列 $A_0$，求经过一定变换后 $A_{k+1}$ 与 $A_{k}$ 长度之比。

变换操作：对于序列 $A_{i}$，设其长度为 $len$，则进行 $len$ 轮操作。对于每次操作，首先判断当前序列的前缀和是否全为正，若是，则将当前的 $A_{i}$ 整个插入到 $A_{i+1}$ 的末尾。然后无论是否进行插入操作，将当前序列的第一项放至末尾。

# 思路

要思考正解，首先我们需要考虑如何高效地将 $A_{0}$ 转换到 $A_{1}$。

假设考虑到第 $j$ 项，若当前出现了前缀和非正，且如果我们希望前面这一串能够合法，则我们必须将末尾的一段接到开头。为了达到目标，我们可以考虑维护 $msuf$ 和 $alsuf$。$msuf$ 指当前往后的最小子段（可以理解为大于 $0$ 就归零的后缀和数组），$alsuf$ 就是后缀和。然后再维护一个数组 $mn$，表示从头开始的每一位如果想要合法所需要加的最小值。

维护好后，我们就可以对于每一项 $j$，若当前 $msuf$ 以及 $alsuf$ 都为正（为了保证后面一段是合法的），且后缀和比当前的 $mn$ 大（为了保证前面一段是合法的），则以当前 $j$ 为开头的序列是合法的。最后所有合法的序列就是 $A_{0}$ 的方案数。

至于得到了这个后如何使用，我们观察得到的 $A_{1}$，设 $A_{0}$ 的长度为 $L$，方案数为 $p$，则 $A_{1}$ 的长度为 $p \cdot L$。然后我们可以发现对于已经合法的序列，新的切断方案有且仅有第一步确定的方案。因此对于长度为 $x \cdot L$ 的序列，切断方案只有 $x \cdot p$ 种，下一项的长度就会变为 $x^{2} \cdot p \cdot L$。显然 $x$ 也是 $p$ 的幂，我们就可以愉悦的发现 $A_{k+1}$ 与 $A_{k}$ 长度之比即为 $p^{2^{k}}$。用快速幂实现即可。

## code
```c++
#include<bits/stdc++.h>
#define int long long
#define N 1000010
using namespace std;
int n;
int k,p=998244353;
int a[N],mn[N];
int msuf,alsuf,ans,mpre;
long long cnt;
int ksm(int a,int b){
	int re=1;
	while(b){
		if(b&1){
			re*=a;
			re%=p;
		}
		a*=a;
		a%=p;
		b>>=1;
	}
	return re;
}
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	mn[0]=0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		mpre+=a[i];
		mn[i]=min(mn[i-1],mpre);
	}
	for(int i=n;i>=1;i--){
		msuf+=a[i];
		alsuf+=a[i];
		if(msuf>0&&alsuf>0){
			if(alsuf+mn[i]>0)cnt++;//都满足要求才能算一种 
		}
		if(msuf>0)msuf=0;
	}
	p--;//欧拉定理 
	int po=ksm(2,k);
	p++;
	cout<<ksm(cnt,po);
	return 0;
}
```

---

## 作者：sbno333 (赞：0)

由于题意太难理解，所以这里提供一版题意：

我们重复一下操作 $k$ 次，对于第 $i$ 次：

枚举每一个 $A_i$ 的循环移位，如果它的任意前缀和大于 $0$，就把它复制并接到 $A_{i+1}$。

初始时 $A_2\sim A_{k+1}$ 为空，$A_1$ 给定。

你需要输出 $A_k$ 总共进行了几次复制到 $A_{k+1}$。

我们考虑 $k=0$，判断 $A_{1_i}$ 是否可以作为开头，只需要得到所有前缀最小的是否大于 $0$，前缀可以分为两段，一个是以 $A_{1_i}$ 为开始，结束是后头的区间，另一个是一段前缀加上 $A_{1_i}$ 为结尾的后缀。

对于第一段，我们只需要维护前缀和在后缀的最小值即可，然后减去 $A_{1_{i-1}}$。

后头则是维护前缀和前缀最小值，加上一个后缀，后缀和可以用前缀和表示，所以我们只需要维护前缀和，前缀和前缀最小和后缀最小。

然后枚举即可。

考虑 $k>0$。

假设此时已经复制，考虑 $A_2$，我们认为它是若干 $A_1$ 循环移位拼接。对于每个位置，只要在原序列 $A_1$ 的循环移位的区间内以其为起始，后面为结尾的区间大于 $0$ 那么总体大于 $0$，因为超出区间就会碰到新的循环移位，这时候 $>0$，而新的循环移位也保证这一点，所以拼上仍然保证。

我们考虑**每个段**的贡献，发现至少为 $k=0$ 的答案，因为原来 $k=0$ 还要走一段来判断，但现在不用了，单调条件变宽，所以原序列合法，现在合法。

考虑证明不存在其它的合法。

假设存在原来不合法，现在合法，设为 $x$，则这一段以 $x$ 为起点的区间和均大于 $0$，为了原先不合法，所以加上这一段的一个区间时小于 $0$，证得这个前缀小于 $0$，此时这一段的起点不合法，这与段怎么来的相矛盾！所以不存在。

然后操作次数就相当于平方了。

在之后假设当 $k=i$ 时答案为 $x$，考虑每个决策点都能复制一次，复制了 $x$ 次，此时决策点变为 $x^2$，同理证明不会更多，因此得到 $k=0$ 后，就相当于进行 $k$ 次平方操作。

$k=0$ 可以线性求解，设为 $x$。

答案为 $x^{2^k}$，可以暴力，这样就是 $O(n+k)$。

也可以快速幂计算 $2^{k}$，值的注意的是根据费马小定理，指数取模的是 $p-1$。

复杂度 $O(n+\log k+\log p)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 998244353ll
int n,k;
int a[1000009];
int qz[1000009];
int hz[1000009];
signed main(){
	cin>>n>>k;
	int z;
	z=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		z+=a[i];
		a[i]+=a[i-1];
	}
	if(z<=0){
		cout<<0<<endl;
		return 0;
	}
	qz[0]=1e16;
	for(int i=1;i<=n;i++){
		qz[i]=min(qz[i-1],a[i]);
	}
	hz[n+1]=1e16;
	for(int i=n;i>=1;i--){
		hz[i]=min(hz[i+1],a[i]);
	}
	int ans;
	ans=0;
	for(int i=1;i<=n;i++){
		int s;
		s=hz[i];
		s-=a[i-1];
		s=min(s,a[n]-a[i-1]+qz[i-1]);
		if(s>0){
			ans++;
		}
	}
	for(int i=1;i<=k;i++){
		ans*=ans;
		ans%=mod;
	}
	cout<<ans;
	return 0;
}
```

---


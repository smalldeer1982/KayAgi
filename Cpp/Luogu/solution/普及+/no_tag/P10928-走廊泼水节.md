# 走廊泼水节

## 题目描述

给定一棵 $N$ 个节点的树，要求增加若干条边，把这棵树扩充为完全图，并满足图的唯一最小生成树仍然是这棵树。

求增加的边的权值总和最小是多少。

**注意：** 树中的所有边权均为整数，且新加的所有边权也必须为整数。

## 说明/提示

数据保证，$1\leq t\leq 10$，$1 \le N \le 6000$，$1 \le Z \le 100$。

## 样例 #1

### 输入

```
2
3
1 2 2
1 3 3
4
1 2 3
2 3 4
3 4 5 ```

### 输出

```
4
17```

# 题解

## 作者：heyZZZ (赞：17)

回顾 kruskal：

取边权最小的一条边，若两个点在不同连通块（并查集），则连边合并。

我们把以上规则改一下：

如果点 $A$ 的老大的小弟数<点 $B$ 的老大的小弟数，$A$ 成为 $B$ 小弟。

反之，$B$ 成为 $A$ 小弟。

我们定义 $s_i$ 是点 $i$ 的老大的小弟数，$w$ 是 $a$ 到 $b$ 的边权。

贡献和为：$(s_A×s_B−1) \times (w+1)$。

代码楼上楼下都已经写的很明白了，我就不在赘述了。

---

## 作者：KarmaticEnding (赞：13)

题目中明确指出了“最小生成树”，而题中又有两个信息：$N\le 6000$ 以及多组数据。

最小生成树一般有两种算法，第一个是 Prim 算法，但是在这道题时间复杂度实在是太不优秀，那么就只剩一个算法了：Kruskal。

Kruskal 算法是什么？按照边权从小到大的顺序枚举每一条边，每次合并两个连通块。那么破这道题的关键就是怎么合并连通块。

现在我们要向两个连通块之间连一条边，就像这样：

![](https://s2.loli.net/2024/09/13/T36wj8mlLUzqykv.png)

然后，我们假设这两个连通块内部都是任意两个点可以通过一条边直接相连，现在我们要在 $u$ 和 $v$ 之间加一条红色的权为 $w$ 的边，使得 $u$ 和 $v$ 合并成为一个大连通块，然后再加若干黄色边，使得这个大连通块中任意两个点通过一条边直接相连。


![](https://s2.loli.net/2024/09/13/uJnclyEqe6tIA7O.png)

我们想想，这些黄色的边边权应该怎么样才使这个大连通块的最小生成树不改变？换句话说，怎样我们才能够使最小生成树选择红色边而抛弃黄色边？

肯定就是黄色边边权大于红色边的时候。又因为题目要我们使加的边的边权总和最小，所以黄色边的边权为 $w+1$。

我们想想黄色边的数量是多少？设连通块 $u$ 所含点数为 $cnt_u$，连通块 $v$ 所含点数为 $cnt_v$，由于原来 $u$ 和 $v$ 之间不连通，所以要连的边数为 $cnt_u\times cnt_v$；又因为已经连了一条红色边，所以黄色边的数量是 $cnt_u\times cnt_v-1$。

我们对于原图执行一次 Kruskal，记录每一个连通块所含的点数，依边权从小到大枚举每一条边，在合并两个连通块的时候，黄色边的数量是 $cnt_u\times cnt_v-1$，那么答案就加上 $(cnt_u\times cnt_v-1)\times(w+1)$。

这是核心部分 Kruskal 的代码：

```cpp
void Kruskal(){
	sort(edge+1,edge+n);
	for(int i=1;i<n;++i){
		int u=edge[i].startpoint;
		int v=edge[i].endpoint;
		int fu=join(u);
		int fv=join(v);
		int w=edge[i].weight;
		if(fu!=fv){
			ans+=(cnt[fu]*cnt[fv]-1)*(w+1);
			cnt[fv]+=cnt[fu];
			fa[fu]=fv;
		}
	}
}
```

这是完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct EDGE{
	int startpoint;
	int endpoint;
	int weight;
	bool operator<(const EDGE &rhs)const{
		return weight<rhs.weight;
	}
}edge[6010];
int T,n;
int fa[6010],cnt[6010];
int ans=0;
int join(int a){
	if(fa[a]==a){
		return a;
	}
	return fa[a]=join(fa[a]);
}
void Kruskal(){
	sort(edge+1,edge+n);
	for(int i=1;i<n;++i){
		int u=edge[i].startpoint;
		int v=edge[i].endpoint;
		int fu=join(u);
		int fv=join(v);
		int w=edge[i].weight;
		if(fu!=fv){
			ans+=(cnt[fu]*cnt[fv]-1)*(w+1);
			cnt[fv]+=cnt[fu];
			fa[fu]=fv;
		}
	}
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		ans=0;
		for(int i=1;i<=n;++i){
			fa[i]=i;
			cnt[i]=1;
		}
		for(int i=1,u,v,w;i<n;++i){
			scanf("%d%d%d",&u,&v,&w);
			edge[i].startpoint=u,edge[i].endpoint=v,edge[i].weight=w;
		}
		Kruskal();
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Nanami_CK (赞：12)

# [P10928 走廊泼水节](https://www.luogu.com.cn/problem/P10928) 题解

我们可以套用 kruskal 求最小生成树的过程，只不过每次合并两个连通块的时候，我们的答案要增加的是两个连通块点数相乘的积减一再乘上两个连通块边的最大值加一。

那么问题来了，为什么这样是正确的？

首先，由于我们要保证原来的树在添加完边后仍然是唯一的最小生成树，那么我们添加边的边权就一定要大于原来树所有边的边权，同时我们要让添加边的边权和尽可能小，还一定要是整数，所以我们添加的边权值就只能是原来边边权的最大值加一。

照这个思路，我们直接求这么多顶点构成完全图所需的边，然后在减去原来的边数，最后再乘上这个边权的最大值加一不就好了么？为什么还要用 kruskal?

因为这样做的正确性会有问题。考虑样例的第二组数据，它作出的图是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/bzdbnw2r.png)

如果按照那个错误思路，我们做出的图会是这样的

![](https://cdn.luogu.com.cn/upload/image_hosting/d45gty9r.png)

很显然，我们可以把 3 到 1 的边权改为 5，这样我们可以得到更小的答案，并且符合题目条件。

假设我们用 kruskal 求一个完全图的最小生成树，我们在合并两个连通块时，其他能过使这两个连通块合并的边都相当于被“删除”了，不会影响到之后的选择，而在这道题中，我们就是要统计这些被“删除”的边的边权。想让这些统计出来的的边权最小，那么添加的边权就应该是上面所说的：原来连通块边权的最大值加一。

代码就是 kruskal 的板子，但是并查集要多记录连通块大小和边的最大值。

### AC code:

```cpp
#include <bits/stdc++.h>

const int MAX = 7000;
struct edge{  //边
    int u,v,w;
    bool operator<(const edge &rhs) const {return w < rhs.w;}
}e[MAX];
int t,n,ans;
struct uf{   //并查集
    std::vector<int> fa,size,mx;   //fa_i为i的代表元，size为当前连通块的大小，mx为当前连通块边的最大值
    uf(int sz) :   //构造一个大小为sz的并查集并初始化
    fa(sz),size(sz,1),mx(sz,0){
        //std::iota可递增填充一个容器
        std::iota(fa.begin(), fa.end(), 0);
    }
    //查找元素
    int find(int x) {return (fa[x] == x ? x : fa[x] = find(fa[x]));}
    //启发式合并
    void merge(int x,int y,int i) {
        x = find(x),y = find(y);
        if(size[x] < size[y]) std::swap(x,y);
        ans += (size[x] * size[y] - 1) * ((mx[x] = std::max({mx[x],mx[y],e[i].w})) + 1);  //添加原来连通块边权的最大值加一，同时更像最大值
        //合并和更新连通块大小
        fa[y] = x;
        size[x] += size[y];
    }
};

int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);
    
    std::cin >> t;
    while(t--){
        ans = 0;  //记得清空
        std::cin >> n;
        uf pa(n + 1);
        for(int i = 1;i < n;i++)
            std::cin >> e[i].u >> e[i].v >> e[i].w;
        std::sort(e,e + n);
        for(int i = 1;i < n;i++){ //从小到大遍历每一条边
            pa.merge(e[i].u,e[i].v,i);
        }
        std::cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：Aventurine_stone (赞：3)

## 1. 题目分析
这道题是最小生成树的扩展应用，运用 kruskal 就可以轻松解决此题。
## 2. 题目做法
我们只需要先将每条树边以长度为关键字从小到大排序。  
从小到大遍历每条边，在将它们合并为一个连通块之前，我们更新答案。  
答案更新方法也不难，大家都知道将两个完全图合并成一个要这两个图点数相乘条边，减去我们的一条树边，设当前树边中最大为 $w$，那么我们只需将边数乘上 $w + 1$ 就行了。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int T,n;
struct B{
	int x,y,z;
}a[N];
inline bool cmp(B a1,B a2)
{
	return a1.z<a2.z;
}
int x,y,s;
int fa[N],siz[N];
inline int find(int x)
{
	if(fa[x]==x)
		return x;
	return fa[x]=find(fa[x]);
}
int i;
int main()
{
	T=read();
	while(T--)
	{
		n=read();
		for(i=1;i<n;i++)
			a[i]={read(),read(),read()};
		sort(a+1,a+n,cmp);
		s=0;
		for(i=1;i<=n;i++)
			fa[i]=i,siz[i]=1;
		for(i=1;i<n;i++)
		{
			x=find(a[i].x),y=find(a[i].y);
			s+=(siz[x]*siz[y]-1)*(a[i].z+1);
			siz[x]<siz[y]?fa[x]=y,siz[y]+=siz[x]:fa[y]=x,siz[x]+=siz[y];
		}
		printf("%d\n",s);
	}
	return 0;
}
```

---

## 作者：Ding_Wenqi (赞：3)

## [P10928 走廊泼水节](https://www.luogu.com.cn/problem/P10928) 题解

### 题意

现有一棵树，需要扩充为完全图，并满足完全图的**唯一**最小生成树仍为这棵树。问增加的边的权值总和最小是多少。

------------
### 思路

考虑 Kruskal，对所有边进行从小到大排序后遍历。用带权并查集维护已经连通的点以及其所在集合的元素个数。

对于遍历到的边 $e_i = \{u, v, w\}$，检查此边连接的两个点是否在一个集合中。若在一个集合中，则不做处理。若不在一个集合中，则进行统计需要添加的边权并合并。

记 $u$ 所在集合的元素数量为 $sz_{f_u}$，$v$ 所在集合的元素数量为 $sz_{f_v}$，为扩充成完全图，两个集合间每个点之间应连一条边，总共连 $sz_{f_u} \cdot sz_{f_v}$ 条边。又因为树上本来有一条边，所以应连 $sz_{f_u} \cdot sz_{f_v} - 1$ 条边。因为要保证完全图的唯一最小生成树仍为这棵树，所以连边的边权都应为 $w + 1$。因此最终需要累加答案 $(sz_{f_u} \cdot sz_{f_v} - 1)(w + 1)$。

时间复杂度同 Kruskal 模版相同，为 $O(n\log n)$。

------------
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 6001;
int t, n, f[N], sz[N], ans;
struct edge
{
	int u, v, w;
}edges[N];
bool operator < (const edge lhs, const edge rhs)
{
	return lhs.w < rhs.w;
}
int Find(int u)
{
	return f[u] == u ? u : f[u] = Find(f[u]);
}
void Union(int u, int v)
{
	int fu = Find(u);
	int fv = Find(v);
	f[fu] = fv;
	sz[fv] += sz[fu];
}
void Kruskal()
{
	sort(edges + 1, edges + n); // 对所有边权从小到大排序，此处采用重载运算符 
	for (int i = 1; i < n; i++)
	{
		int u = edges[i].u, v = edges[i].v, w = edges[i].w;
		if (Find(u) != Find(v)) // 如果 u, v 不属于一个集合 
		{
			ans += (sz[Find(u)] * sz[Find(v)] - 1) * (w + 1); // 累加答案 
			Union(u, v); // 合并两集合 
		}
	}
}
int main()
{
	cin >> t;
	while (t--)
	{
		ans = 0;
		cin >> n;
		iota(f + 1, f + n + 1, 1); // 递增填充函数 
		fill(sz + 1, sz + n + 1, 1);
		for (int i = 1, u, v, w; i < n; i++)
		{
			cin >> u >> v >> w;
			edges[i] = {u, v, w};
		}
		Kruskal();
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：Brilliant11001 (赞：3)

### [更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18381835)

## 题目大意：

给定一棵 $n$ 个节点的树，现在要添加一些边，使它成为一个完全图，并且满足图的**唯一最小生成树仍然是原树**，求增加的边的最小边权和。

## 思路：

考虑 kruskal 算法的过程：将边从小到大排序，依次扫描每条边，然后考虑合并边两端的集合。

设这两端的集合为 $S_x,S_y$，这条边的边权为 $w$，因为要连成一个完全图，所以这两个集合之间任意一个点对都要连边，其中也包括这条树边。

根据最小生成树的定义可知，我们应该将其他的边都钦定为 $w + 1$，否则就会存在一条边可以替换这条树边，使得的最小生成树不唯一。

综上所述，我们在这棵树上执行类似 kruskal 算法的过程，先将边按从小到大排序，再依次扫描每条边，并查集维护，若两端的集合未被合并，根据乘法原理，应该连的边权和为 $(size_x\cdot size_y - 1)\cdot (w + 1)$，然后再将两个集合合并即可。

时间复杂度为 $O(n\log n)$。

$\texttt{Code:}$

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6010;

int T, n;
struct node{
    int a, b, w;
    bool operator <(const node &o) const {
        return w < o.w;
    }
}edges[N];
int p[N], sz[N];
int res;

int find(int x) {
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d", &n);
        int a, b, c;
        for(int i = 1; i < n; i++) {
            scanf("%d%d%d", &a, &b, &c);
            edges[i] = {a, b, c};
        }
        sort(edges + 1, edges + n);
        for(int i = 1; i <= n; i++) p[i] = i, sz[i] = 1;
        res = 0;
        for(int i = 1; i < n; i++) {
            int a = edges[i].a, b = edges[i].b, w = edges[i].w;
            a = find(a), b = find(b);
            if(a != b) {
                res += (w + 1) * (sz[a] * sz[b] - 1);
                p[a] = b;
                sz[b] += sz[a];
            }
        }
        printf("%d\n", res);
    }
    return 0;
}
```

---

## 作者：ivyjiao (赞：2)

一个图可能有多个最小生成树，但是本题要你构造成唯一的最小生成树。

考虑 Kruskal。按照 Kruskal 的求法，边都是按排序后的顺序进行操作的，所以我们先对输入的边进行排序。

那么对于现在操作的边，设其连接 $(x,y)$，长为 $w$，设断掉此边后，$s_x$ 是 $x$ 所在集合的节点数量，$s_y$ 是 $y$ 所在集合的节点数量。由于我们已经排了序，所以 $w$ 必然是当前树上最大边权。

我们可以用并查集把它们并到一个集合里面。现在 $s_x$ 变成了 $s_{fa_x}$，$s_y$ 变成了 $s_{fa_y}$，这样就容易统计了。

若 $s_{fa_x}=s_{fa_y}$，则代表这个集合已经被处理过，不再对其进行处理。

否则的话，因为我们现在要还原成完全图，所以我们在两个集合中任意点都应加边，所以总加边数为 $s_{fa_x}\times s_{fa_y}-1$，减一的原因是不能算上原来的树边。而这些边的边权就是 $w+1$。

综上所述，对于每条边，若 $s_{fa_x}=s_{fa_y}$，不对其进行处理，否则答案加上 $(w+1)\times s_{fa_x}\times s_{fa_y}-1$。

由于求的是增加的边的权值总和，所以最后还要减掉原来的树边的 $w$ 之和。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node{
	int x,y,dis;
}a[100001];
int t,n,f[100001],s[100001],sumdis;
bool cmp(node x,node y){
	return x.dis<y.dis;
}
int find(int x){
	if(x==f[x]) return f[x];;
	return f[x]=find(f[x]);
}
int kruskal(){
    int ans=0;
    for(int i=1;i<=n;i++) f[i]=i,s[i]=1;
    sort(a+1,a+n,cmp);
    for(int i=1;i<n;i++){
        int fx=find(a[i].x);
        int fy=find(a[i].y);
        if(fx==fy) continue;
        ans+=(a[i].dis+1)*s[fx]*s[fy]-1;
        f[fx]=fy;
        s[fy]+=s[fx];
    }
    return ans;
}
signed main(){
    cin>>t;
    while(t--){
	    sumdis=0;
        cin>>n;
        for(int i=1;i<n;i++){
			cin>>a[i].x>>a[i].y>>a[i].dis;
			sumdis+=a[i].dis;
		}
        cout<<kruskal()-sumdis<<endl;
    }
}
```

---

## 作者：WoodReal12 (赞：1)

## 题意
请自行理解题目
## 思路
用了 kruskal 算法的思想，将图看做是一块一块的图，而连接这些一块一块之间的图的边（长度记作 $len$)就是唯一的生成树上
的边，将不同块之间用边连接成完全图，这条边的长度应该为 $len + 1$;

执行步骤：

1. 按边的权排序

2. 选一条最短得边，将该边连接的两个块（如果这个块是不同的）连接成完全图

3. 继续执行第2步，直到遍历所有点，算法结束

## 一些可能产生的小疑问

- 为什么算法结束，整个图就变为了完全图？

  因为 kruskal 算法的正确性保证了算法结束后所有的点都被加入了同一个块

- 为什么连接两个块的长度为 $len + 1$？

  因为，对于当前两个块来说它们之间连接的边的长度为 $len$，如果选的边比 $len$ 要小，那么将会产生一条更小的边连接这两个块，将破坏唯一的最小生成树这个条件。

## 代码
代码仅供参考，因为是很久以前写的了，变量名可能跟题解讲述不太一样。
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=6010;

int n;
struct Edge
{
    int a,b,w;
    bool operator<(const Edge &t)const
    {
        return w<t.w;
    }
}e[N];

int p[N],sz[N];

int find(int x)
{
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}

int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        cin>>n;
        for(int i=0;i<n-1;i++)
        {
            int a,b,w;
            cin>>a>>b>>w;
            e[i]={a,b,w};
        }

        sort(e,e+n-1);
        for(int i=1;i<=n;i++) p[i]=i,sz[i]=1;

        int res=0;
        for(int i=0;i<n-1;i++)
        {
            int a=find(e[i].a),b=find(e[i].b),w=e[i].w;
            if(a!=b)
            {
                res+=(sz[a]*sz[b]-1)*(w+1);
                sz[b]+=sz[a];
                p[a]=b;
            }
        }
        cout<<res<<endl;
    }
    return 0;
}
```

---

## 作者：lcfollower (赞：1)

题目中提到了“最小生成树”，于是考虑如何加边最优：按照 kruskal 算法，每次合并的两个端点若不是同一连通块就加边使得这两个连通块为图 $G$ 的一个子完全图。

如果不会 kruskal，请[出门左转](/problem/3366)。

设图 $G$ 在最小生成树 $T$ 上的一条边 $e$ 的边权 $w$，则我们需要增加新边权 $w'$ 让子图 $E$ 为图 $G$ 的子完全图。

- $w' < w$，那么去除边 $e$，由于 $e\in T$，所以增加 $w'$ 会导致最小生成树大小发生改变，不为原本的最小生成树，与题意不符。

- $w' = w$，那么可以去除 $w$ 保留 $w'$，这样最小生成树的权值之和不变，并不唯一。

- $w' > w$，新边的边权大于 $w$，明显可以使得这条新边不属于最小生成树，此时 $w' = w + 1$ 最优。

设 $e$ 这条边的两个节点为 $u$，$v$，则需要增加 $(sz_u\times sz_v)\times (w + 1)$ 的权值，其中 $sz_i$ 为节点 $i$ 当前所在连通块的大小。

时间复杂度为 $\mathcal O(T\times n\log n)$，瓶颈在于对边权的排序。

```cpp
#include <bits/stdc++.h>

# define int long long
# define rint register int

using namespace std;

const int N = 6005;
int n ,fa[N] ,sz[N];
struct point{int u ,v ,w;}a[N];

inline int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}
inline void merge(int x ,int y){
  fa[x] = y;
  sz[y] += sz[x];
} inline void solve() {
  int ans = 0;
  scanf("%lld", &n);
  for(rint i = 1;i < n;i ++)
    scanf("%lld %lld %lld", &a[i].u ,&a[i].v ,&a[i].w);
  for(rint i = 1; i <= n;i ++) fa[i] = i ,sz[i] = 1;
/* 以下为 kruskal 基本操作。*/
  sort(a + 1, a + n ,[](point &s1 ,point &s2){return s1.w < s2.w;});
  for(rint i = 1;i < n;i ++){
    int u = a[i].u ,v = a[i].v ,w = a[i].w;
    int fau = find(u) ,fav = find(v);
    if(fau == fav) continue;
    ans += (w + 1) * (sz[fau] * sz[fav] - 1);//累加答案。
    if(fau != fav) merge(fau, fav);
  } printf("%lld\n" ,ans);
} signed main() {
  int Tcases;
  scanf("%lld" ,&Tcases);
  while(Tcases --) solve();
  return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

首先考虑 kruskal 算法的流程：

- 取边权最小的一条边，若两个点在不同连通块，则连边合并。

这题也一样，对于树上的边按照 kruskal 算法跑一遍，则对于边 $(u,v,w)$，需要使得所有 $u$ 连通块内到 $v$ 连通块内的边都比 $w$ 大才行；否则选另外一个 $\le w$ 的边同样可以达成目的且形成另外一棵最小生成树。

因为要使新增的权值最小，所以此时对于 $u$ 连通块内到 $v$ 连通块的边边权应该为 $w+1$，贡献和为 $(siz_u \times siz_v -1) \times (w+1)$。

时间复杂度为 $O(Tn \log n)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=6060;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll u,v,w;
	bool operator<(const Node&rhs)const{
		return w<rhs.w;
	}
}a[N];
ll T,n,ans;
ll fa[N],siz[N];
ll Find(ll x){
	if(x!=fa[x])
	  return fa[x]=Find(fa[x]);
	return fa[x];
}
void solve(){
	ans=0;
	n=read();
	For(i,1,n-1)
	  a[i]={read(),read(),read()};
	sort(a+1,a+n);
	For(i,1,n){
		fa[i]=i;
		siz[i]=1;
	}
	For(i,1,n-1){
		ll x=Find(a[i].u),y=Find(a[i].v);
		ans+=(siz[x]*siz[y]-1)*(a[i].w+1);
		if(siz[x]>siz[y])
		  swap(x,y);
		fa[x]=y;
		siz[y]+=siz[x];
	}
	write(ans);
	putchar('\n');
}
int main(){
	T=read();
	while(T--)
	  solve();
    return 0;
}
```

---


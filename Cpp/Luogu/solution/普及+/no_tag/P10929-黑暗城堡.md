# 黑暗城堡

## 题目描述

在顺利攻破 Lord lsp 的防线之后，lqr 一行人来到了 Lord lsp 的城堡下方。

Lord lsp 黑化之后虽然拥有了强大的超能力，能够用意念力制造建筑物，但是智商水平却没怎么增加。

现在 lqr 已经搞清楚黑暗城堡有 $N$ 个房间，$M$ 条可以制造的双向通道，以及每条通道的长度。

lqr 深知 Lord lsp 的想法，为了避免每次都要琢磨两个房间之间的最短路径，Lord lsp 一定会把城堡修建成树形的。

但是，为了尽量提高自己的移动效率，Lord lsp 一定会使得城堡满足下面的条件：

设 $D[i]$ 为如果所有的通道都被修建，第 $i$ 号房间与第 $1$ 号房间的最短路径长度；而 $S[i]$ 为实际修建的树形城堡中第 $i$ 号房间与第 $1$ 号房间的路径长度；要求对于所有整数 $i$，有 $S[i]=D[i]$ 成立。

为了打败 Lord lsp，lqr 想知道有多少种不同的城堡修建方案。

保证至少存在一种可行的城堡修建方案。

你需要输出答案对 $2^{31}–1$ 取模之后的结果。

## 说明/提示

数据保证，$2 \le N \le 1000$，$N-1 \le M \le N(N-1)/2$，$1 \le L \le 100$。

## 样例 #1

### 输入

```
3 3
1 2 2
1 3 1
2 3 1```

### 输出

```
2```

# 题解

## 作者：tjtdrxxz (赞：14)

题目要求我们建的树满足 $ D_i = S_i $，容易想到用其他路径代替最短路中的路径。

例：
![](https://cdn.luogu.com.cn/upload/image_hosting/8yi5nhgk.png)

很明显，如果两条红边的长等于黑边的长，那么这条黑边就可以被两条红边代替。

所以我们跑一遍最短路，然后 $ O (n ^ 2) $ 统计答案。答案就是叶节点到根节点最短路径数量的积。

注意：堆的重载运算符别写错啦。

code：
```cpp
# include <bits/stdc++.h>
# define int __int128
using namespace std;
int mp[1011][1011];
int n, m;
struct path
{
	int v, w;
	path (int v = 0, int w = 0) :
		v (v), w (w) {}
};
vector <path> e[100012];
int dis[1011];
struct node
{
	int u, w;
	node (int u = 0, int w = 0) :
		u (u), w (w) {}
	bool operator < (const node &b) const
	{
		return w > b.w;
	}
};
priority_queue <node> q;
bool vis[1011];
void dijkstra (int st)
{
	for (int i = 1; i <= n; i ++) dis[i] = 1e18, vis[i] = 0;
	dis[st] = 0;
	q.push (node (st, 0));
	while (not q.empty ())
	{
		int u = q.top ().u;
		q.pop ();
		if (vis[u]) continue;
		vis[u] = 1;
		for (auto it : e[u])
		{
			int v = it.v, w = it.w;
			if (dis[v] > dis[u] + w)
			{
				dis[v] = dis[u] + w;
				q.push (node (v, dis[v]));
			}
		}
	}
}
# define stdi stdin
# define stdo stdout
int ans = 0;
int mod = (1 << 31) - 1;
signed main()
{
	freopen ("dark.in", "r", stdin);
	freopen ("dark.out", "w", stdout);
	setvbuf (stdi, (char*) calloc (1 << 20, sizeof (char)), _IOFBF, 1 << 20);
	setvbuf (stdo, (char*) calloc (1 << 20, sizeof (char)), _IOFBF, 1 << 20);
	memset (mp, 0x3f, sizeof (mp));
	scanf ("%lld %lld", &n, &m);
	for (int i = 1; i <= m; i ++)
	{
		int u, v, w;
		scanf ("%lld %lld %lld", &u, &v, &w);
		e[u].push_back (path (v, w));
		e[v].push_back (path (u, w));
		mp[u][v] = mp[v][u] = min (mp[u][v], w);
	}
	dijkstra (1);
	ans = 1;
	for (int i = 2; i <= n; i ++)
	{
		int sum = 0;
		for (int j = 1; j <= n; j ++)
		{
			sum += ((dis[j] + mp[i][j]) == dis[i]);
		}
		if (sum > 0) ans = (ans * sum) % mod;
	}
	printf ("%lld\n", ans);
}
```

---

## 作者：jiayixuan1205 (赞：8)

## 题解：P10929 黑暗城堡
### 题意
找出无向图中以 $1$ 为根的生成树中每个叶子结点到根的距离都为该两点之间最短路的树的个数。
### 分析
根据乘法原理，我们可以发现，答案应该为每个叶子结点到根节点的最短路数量的乘积。由于都是正权边，再根据最短路的性质我们可以知道这样产生的图中不会产生环。直接跑最短路求解即可
### 代码展示
```cpp
#include<bits/stdc++.h>
#define ll long long

using namespace std;

const int N = 1010;
const ll mod = (1<<31)-1 
int n,m,dis[N];
int e[N][N];
ll ans=1;
bool vis[N];

inline void dij()//最短路 
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[1]=0;
	for(int i=1;i<=n;i++)
	{
		int u=-1;
		for(int j=1;j<=n;j++) if(!vis[j]&& (u==-1|| dis[u]>dis[j])) u=j;
		vis[u]=true;
		for(int j=1;j<=n;j++) if(dis[j]>dis[u]+e[u][j]) dis[j]=dis[u]+e[u][j];
	}
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0); 
	memset(e,0x3f,sizeof(e));
	cin>>n>>m;
	int u,v,w;
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		e[u][v]=e[v][u]=min(e[v][u],w);//存图，数据比较小，直接邻接矩阵 
	}
	dij();	
	for(int i=2;i<=n;i++)
	{ 
		int s=0;
		for(int j=1;j<=n;j++)
			if(dis[i]==dis[j]+e[i][j])
				s++; //每个点可产生的贡献 
		if(s>0) ans=(ll)ans*s%mod;//统计答案 
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：HYLW (赞：6)

以学献教，以教献学。

## 题意转化

题中有一句很疑惑人但很重要的话：

> 设 $D_{i}$ 为如果所有的通道都被修建，第 $i$ 号房间与第 $1$ 号房间的最短路径长度；而 $S_{i}$ 为实际修建的树形城堡中第 $i$ 号房间与第 $1$ 号房间的路径长度；要求对于所有整数 $i$，有 $S_{i}=D_{i}$ 成立。

显然我们看到了一个树形图的影子，但是**这不是最小生成树**，因为保证了任何 $i$ 号点（房间）到 $1$ 号点的树上距离是原图（即所有道路都被修建）的最短距离，最小生成树上的路径显然不一定是最短路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/bufjlaqz.png)

当然，这种树通常被称为**最短路径生成树**，也就是满足**任意非根节点到根节点的路径一定是原图中两点的最短路径**，最短路径不止一条，那么一张任意的图显然不一定只有一棵最短路径生成树（简单易证，不做解释）。

那么我们需要，**对一张图经行其最短路径生成树数量的统计**。

## 解题思路

一棵最短路径生成树显然保证任意非根节点到根节点的路径是原图两点的最短路径，所以要保证这一点，就需要先得到原图中任意点到 $1$ 号节点的最短距离，于是我们需要**求单源最短路**。

然后，假设我们已经得到了最短路径生成树，那么树上保证了最短距离，如果此时对于生成树一个节点 $u$ 及其子节点 $v$ 来讲，存在另一节点 $x$ 满足 $dis_v=dis_u+w(u,v)=dis_x+w(x,v)$（其中 $(x,v)$、$(u,v)$ 是原图中的边），那么我们将 $v$ 及其子树一整块接到 $x$ 下，那么我们就找到了一个新的最短路径生成树。那么每一个节点可能有很多这样的 $x$ 节点，所结合乘法原理，我们**把每个节点的 $x$ 节点个数乘起来**（当然根节点除外），就得到了最短路径生成树的个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/3mei0fmv.png)

## 实现细节

- ### 求单源最短路

$N\leq 1000,N-1\leq M\leq \frac{N(N-1)}{2}$，所以在一个稠密图中，点数还不多，使用 $O(n^2)$ 的**朴素 dijkstra 算法**可以保证时间复杂度的同时使代码简洁好写。

用**邻接矩阵**存图，需要双向。

- ### 把每个节点的 $x$ 节点乘起来

这里有没有顺序问题呢？事实证明没有。\
当然从理论上来讲，当前节点的 $x$ 节点个数是固定的，互不影响，所以没有顺序要求。只需要**依次枚举每个节点，并统计每个节点的 $x$ 节点个数，然后累乘**即可。

当然按照蓝书上的类 prim 做法可能更利于理解（虽然编者不这么认为）。

时间复杂度 $O(n^2)$。

## 样例代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 1010;
const ll mod = (1<<31)-1;//取模 
int n,m;
int e[N][N];//邻接矩阵 
ll ans=1;//最终答案 

int dis[N];
bool s[N];
void dijkstra(){
	memset(dis,0x3f,sizeof dis);
	memset(s,false,sizeof s);
	//memset原本是用于字符串的赋值，但是同样可以用于int，bool
	//对于int，是对每八位赋值0x3f 
	dis[1]=0;//初始化 
	for(int i=1;i<=n;i++){
		int u=-1;
		for(int j=1;j<=n;j++)
			if(!s[j] && (u<0 || dis[u]>dis[j]))
			    u=j;//枚举找到一个离起点最近且未在确定集合内的点 
		s[u]=true;//标记已确定 
		for(int j=1;j<=n;j++)
			if(dis[j]>dis[u]+e[u][j])
				dis[j]=dis[u]+e[u][j];//更新 
	}
}

int main(){
	memset(e,0x3f,sizeof e);//初始化 
	scanf("%d%d",&n,&m);
	for(int i=1,u,v,w;i<=m;i++)
		scanf("%d%d%d",&u,&v,&w),
		e[u][v]=e[v][u]=min(e[v][u],w);//双向 
	
	dijkstra();//求单源最短路 
	
	for(int v=2,s;v<=n;v++){//从 2 节点开始枚举，1 根节点没必要 
		s=0;//x 节点个数的记录 
		for(int x=1;x<=n;x++)
			if(dis[v]==dis[x]+e[x][v])//x 节点判定 
				s++; 
		if(s>0)   ans=(ll)ans*s%mod;
	}
	
	printf("%lld",ans);
	return 0;
}
```

#### 感谢管理员的贡献

---

---

## 作者：RainySoul (赞：4)

*最短路树板子题。*

### 题意

求以 $1$ 为根的最短路树一共有多少棵。

### 思路

$dis_i$ 表示当前 $1$ 到 $i$ 最短路径的长度。

dijkstra 松弛的时候，记录一下每个点的 $dis$ 可以从多少条边转移来，记为 $sum_i$。每个 $sum_i$ 对答案的贡献是单独的，最终答案就是 $\prod_{i=1}^{n}sum_i$。

如果最小的 $dis$ 更新了记得把当前点的 $sum$ 清零。

### AC code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f
using namespace std;
const int N=1010,mod=(1<<31)-1;
struct zyx{
	int now,dis;
	friend bool operator <(zyx a,zyx b){
		return a.dis>b.dis;
	}
};
priority_queue<zyx> q;
int n,m,cnt,head[N],we[N*N],ne[N*N],to[N*N],dis[N],sum[N];
bool vis[N]; //这里链式前向星的空间要开 N*N！
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
void add(int u,int v,int w){
	to[cnt]=v;
	we[cnt]=w;
	ne[cnt]=head[u];
	head[u]=cnt++;
}
signed main(){
	n=read(),m=read();
	memset(head,-1,sizeof head);
	memset(dis,inf,sizeof dis);
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);
	}
	q.push((zyx){1,0});
	dis[1]=0;
	while(!q.empty()){
		int u=q.top().now,d=q.top().dis;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];~i;i=ne[i]){
			int w=we[i];
			if(d+w<dis[to[i]]){//松弛操作
				dis[to[i]]=d+w,sum[to[i]]=0;
				q.push((zyx){to[i],dis[to[i]]});
			}
			if(d+w==dis[to[i]])sum[to[i]]++;//统计 sum
		}
	}
	int ans=1;
	for(int i=2;i<=n;i++)
		ans=(ans*sum[i])%mod;//计算答案，记得取模
	cout<<ans;
	return 0;
}
```

---

## 作者：Hadtsti (赞：2)

### 题目分析

我们考虑这棵树是怎么生成的。首先钦定源点 $1$ 号节点为根，那么对于一条原图的边 $(u,v,w)$，若满足 $d_v=d_u+w$，则 $u$ 可以成为 $v$ 的父亲。由于本题的图中都是正权边，根据最短路的性质，这样生成不可能存在环，且每个点的父亲是谁是独立的。那么我们对除 $1$ 之外的每个点统计一下有多少点可以作为其父亲，乘起来就可以了。

### 代码实现


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,z,d[1010],p[1010],f[1010],ans=1;
vector<pair<int,int> >E[1010];
bool vis[1010];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >pq; 
bool cmp(int x,int y)
{
	return d[x]<d[y];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		E[x].push_back({y,z});
		E[y].push_back({x,z});
	}
	memset(d,0x3f,sizeof d);
	d[1]=0;
	pq.push({0,1});
	while(!pq.empty())
	{
		int x=pq.top().second;
        pq.pop();
		if(vis[x])
			continue;
		vis[x]=1;
		for(pair<int,int>i:E[x])
		{
			int y=i.first;
			if(d[y]>d[x]+i.second)
			{
				d[y]=d[x]+i.second;
				pq.push({d[y],y});
			}
		}
	}
	for(int x=2;x<=n;x++)
	{
		int cnt=0;
		for(pair<int,int>j:E[x])
			if(d[x]==d[j.first]+j.second)
				cnt++;
		ans=1ll*ans*cnt%INT_MAX;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Cells (赞：2)

### 思路

我们将每一个点拆开来看，每个非根节点点在树中只能有一个父亲，而题目要求我们树中每个节点到根节点的简单路径最短，那么枚举每个非根节点 $u$ 的所有出边，如果其出边连接的节点 $v$ 能使得 $dis_u = dis_v + w$，那么说明将 $v$ 作为 $u$ 的父亲是可行的。

所以树的形态总数取决于每个节点可以与多少个能作为它父亲的节点连边。

将每个节点的方案相乘，就得到了方案总数。

**Code**

```c++
# pragma GCC optimize("Ofast")//防抄认证 
# include <bits/stdc++.h>
# define fir first
# define sec second
# define mem(a, b) memset(a, b, sizeof (a))
# define rep(i, a, b) for(int i = a; i <= b; i ++)
using namespace std;

using LL = long long;
using PII = pair<int, int>;

const int N = 1e3 + 10, M = 1e6 + 10;
const LL mod = INT_MAX;//(1 << 31) - 1 = INT_MAX 

int n, m, idx;
int dis[N];
int h[N], e[M], w[M], ne[M];
LL ans, cnt;//不开LL见…… 

bool vis[N];

void add(int a, int b, int c){
	e[++ idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx;
}

void SPFA(int s){//没办法，就是喜欢SPFA，但是这题SPFA好像过不了，就给Dijkstra改名字吧 
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	mem(dis, 0x3f);
	mem(vis, false);
	
	dis[s] = 0;
	heap.push({0, s});
	
	while(!heap.empty()){
		int u = heap.top().sec;
		heap.pop();
		
		if(vis[u]) continue;
		vis[u] = true;
		
		for(int i = h[u]; i; i = ne[i]){
			int v = e[i];
			if(vis[v] || dis[v] <= dis[u] + w[i]) continue;
			dis[v] = dis[u] + w[i];
			heap.push({dis[v], v});
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	
	int a, b, c;
	rep(i, 1, m){
		cin >> a >> b >> c;
		add(a, b, c);
		add(b, a, c);
	} 
	
	SPFA(1);
	
	ans = 1;
	rep(u, 2, n){//枚举每个非根节点 
		cnt = 0;
		
		for(int i = h[u]; i; i = ne[i]){
			int v = e[i];
			if(dis[u] == dis[v] + w[i]) cnt ++, cnt %= mod;//连边成功 
		}
		
		ans *= cnt;
		ans %= mod;
	}
	
	cout << ans;
	
	return 0;
}
```

**感谢你能看到这里，再见！！！**

---

## 作者：H_ice (赞：1)

### 思路

下文中，将点 $i$ 到点 $j$ 的**最短**路记作 $dis_{i,j}$。

>考虑一个连通无向图 $G$ ，一个以顶点 $v$ 为根节点的最短路径树 $T$ 是图 $G$ 满足下列条件的生成树——树 $T$ 中从根节点 $v$ 到其它顶点 $u$ 的路径距离，在图 $G$ 中是从 $v$ 到 $u$ 的最短路径距离。
>
>—— 百度百科

显然，本题要求一个无向图中最短路径树的生成方案数。

在一棵树中，若将点 $i$ 的父节点记作 $pre_i$，则存在 $dis_{1,i} = dis_{1,pre_{i}} + dis_{pre_i,i}$。  

在一棵最短路径树中，对于一个 $i$，合法的 $pre_i$ 可能有多个，所以会有多种构造最短路径树的方案。

所以，对于每一个点 $2\le i \le n$，算出合法的 $pre_i$ 的个数  $f_i$。再根据乘法原理，计算 $\prod_{i=2}^{n}  f_i$ 即可。


### 代码实现：


首先跑一遍 Dijkstra，求编号为 1 的点到其它点的最短距离。  
由于 $n\le1000$，$O(n^2)$ 的朴素 Dijkstra 即可。

然后是本题的核心部分：

```cpp
f[1]=1;
for (int i=1;i<=n;i++)//i 必须从 1 开始遍历，以计算与编号为 1 的点相连的边。
{
  for (int j=hd[i];j;j=e[j].next)//遍历与点 i 相连的每一条边。
  {
    int to=e[j].to;
    if (dis[i]+e[j].dis==dis[to])//如果满足，即可构造一棵存在边 i-j 的最短路径树。
    {
    	f[to]++;
    }
   }
}
//ans 即为答案，初始化为 1。
	for (int i=1;i<=n;i++)
	{
		ans=ans*f[i]%MOD;//乘法原理
	}
```

**[Code](https://www.luogu.com.cn/paste/q4o2t8by)**  
**[Record](https://www.luogu.com.cn/record/175030551)**

### [附] 最短路径树相关题目

[CF1076D](https://www.luogu.com.cn/problem/CF1076D)   
[CF1005F](https://www.luogu.com.cn/problem/CF1005F)  
[P2933](https://www.luogu.com.cn/problem/P2993)

---

## 作者：chiyanfeng (赞：1)

观察本题可以发现：本题是无向图的最短路径生成树。再观察 $n$ 的规模并不大，可以先使用 $O(n^2)$ 的 Dijkstra 算法求最短路。不妨令 $dis_i$ 表示从点 $1$ 到点 $i$ 的最短距离。则可以利用 Dijkstra 算法尝试扩展未扩展的点 $x$，统计从已扩展的点到点 $x$ 值为 $dis_x$ 的方案数，累乘入答案即可。

复杂度为 $O(n^2)$，可过此题。 

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1005;
int n, m, vis[N], g[N][N], dis[N];
void dij() {
  for (int i = 2; i <= n; i++) dis[i] = g[1][i];
  dis[1] = 0;
  vis[1] = 1;
  for (int i = 2; i <= n; i++) {  //常规 Dijkstra 算法
    int x = 0, y = 0x3f3f3f3f;
    for (int j = 2; j <= n; j++)
      if (vis[j] == 0 && dis[j] < y) x = j, y = dis[j];
    vis[x] = 1;
    for (int j = 2; j <= n; j++)
      if (vis[j] == 0 && dis[j] > dis[x] + g[x][j]) dis[j] = dis[x] + g[x][j];
  }
}
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  //对 g 数组即题解中的 dist 数组初始化
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
      if (i == j)
        g[i][j] = 0;
      else
        g[i][j] = 0x3f3f3f3f;
  for (int i = 1, u, v, w; i <= m; i++)    //此处取 min 防止重边
    cin >> u >> v >> w, g[u][v] = g[v][u] = min(g[u][v], w);
  dij();    //第一次 Dijkstra
  ll ans = 1;
  for (int i = 2; i <= n; i++) vis[i] = 0;
  vis[1] = 1;
  for (int i = 2; i <= n; i++) {
    int x = 0, y = 0x3f3f3f3f;
    for (int j = 2; j <= n; j++)
      if (vis[j] == 0 && dis[j] < y) x = j, y = dis[j];
    int cnt = 0;
    for (int j = 1; j <= n; j++)  //尝试从点 x 拓展，并求方案数
      if (vis[j] == 1 && dis[j] + g[j][x] == dis[x]) cnt++;
    vis[x] = 1;
    // if (cnt == 0) continue;
    ans = ans * cnt % 2147483647;
  }
  cout << ans;
  return 0;
}
```

---

## 作者：minVan (赞：0)

**题目大意**

求一个图变成关于 $1$ 的最短路径生成树的方案总数模 $2^{31}-1$。

**解题思路**

先用 dijkstra 求出关于 $1$ 的单源最短路径，把 $1$ 当成生成树的根。

而由于要满足最后生成树的每个节点到 $1$ 的距离为最短路，所以就看每个节点到 $1$ 有多少条最短路径，最后乘法原理乘起来即可。

至于如何计算每个点 $u$ 有多少条到 $1$ 的最短路径，只需要看与它相连的边 $(u,v,w)$ 是否满足 $d_u=d_v+w$ 即 $u$ 到 $1$ 的最短路径是否等于 $v$ 到 $1$ 的最短路径加边权 $w$ 即可。

如果用邻接表遍历可以做到 $\mathcal{O}(m\log_2n+m)$，但完全没必要。直接用邻接矩阵 $\mathcal{O}(n^2)$ 即可。

计算答案部分代码如下：

```cpp
int ans = 1;
for(int i = 2, k = 0; i <= n; i++, k = 0) {
  for(int j = 1; j <= n; j++) {
    k += (dis[i] == dis[j] + e[i][j]);
  }
  if(k > 0) { ans = ans * k % Mod; }
}
```

**AC 代码，请勿抄袭。**

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define _w first
#define _v second
using namespace std;
const int N = 1005, Mod = (1ll << 31) - 1;
struct node { int v, w; };
int n, m, e[N][N], dis[N];
bool vis[N];
priority_queue<pii, vector<pii >, greater<pii > > pq;
inline void dij(int s) {
  for(int i = 1; i <= n; i++) {
    dis[i] = 1e18, vis[i] = 0;
  }
  dis[s] = 0;
  pq.push({0, s});
  while(!pq.empty()) {
    int tmp = pq.top()._v;
    pq.pop();
    if(vis[tmp]) { continue; }
    vis[tmp] = 1;
    for(int i = 1; i <= n; i++) {
      if(e[tmp][i] > 1e18) { continue; }
      if(dis[i] > dis[tmp] + e[tmp][i]) {
        dis[i] = dis[tmp] + e[tmp][i];
        if(!vis[i]) { pq.push({dis[i], i}); }
      }
    }
  }
}
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  memset(e, 0x3f, sizeof(e));
  while(m--) {
    int u, v, w;
    cin >> u >> v >> w;
    e[u][v] = e[v][u] = min(e[u][v], w);
  }
  dij(1);
  int ans = 1;
  for(int i = 2, k = 0; i <= n; i++, k = 0) {
    for(int j = 1; j <= n; j++) {
      k += (dis[i] == dis[j] + e[i][j]);
    }
    if(k > 0) { ans = ans * k % Mod; }
  }
  cout << ans;
  return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 我的博客

本文知识点参考于：[oi-beats](https://ntsc-yrx.github.io/oi-beats/site)，[个人博客](https://ntsc.flowus.cn/)。

## 大意

求无向图的以 $1$ 为起点的最短路树的数量。最短路树定义为树上每个节点到 $1$ 的最短路径就是树上到根的路径。

## 做法

我们考虑在求最短路时求出答案。记 $f_i$ 为节点 $i$ 到根节点的路径方案数。那么桌面在跑 dijkstra 时，当发现 $dis_u=dis_v+w$ 时，说明有一条新的等效路径可以到达 $v$，此时 $f_v←f_v+1$。当更新 $v$ 的最短路径时，应该将 $f_v$ 重置为 $1$。

最后将 $f$ 都乘起来即可。



```C++
/*                                                                                
                      Keyblinds Guide
     				###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+K then ctrl+W: close all
      - Alt+la/ra : move mouse to pre/nxt pos'
	  
*/
#include <bits/stdc++.h>
#include <queue>
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i >= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define ps second
#define pf first

// #define innt int
#define itn int
// #define inr intw
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
		if (ch == '-')
			ff = -1;
		ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
	if (out < 0)
		putchar('-'), out = -out;
	if (out > 9)
		write(out / 10);
	putchar(out % 10 + '0');
}

#define ell dbg('\n')
const char el='\n';
const bool enable_dbg = 1;
template <typename T,typename... Args>
void dbg(T s,Args... args) {
	if constexpr (enable_dbg){
    cerr << s;
    if(1)cerr<<' ';
		if constexpr (sizeof...(Args))
			dbg(args...);
	}
}

#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() { cerr << endl; }
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) { for (auto v: a) cerr << v << ' '; err(x...); }
template<typename T, typename... A>
void err(T a, A... x) { cerr << a << ' '; err(x...); }
#else
#define dbg(...)
#endif


const int N = 1e6 + 5;
const int INF = 1e9;
const int M = 2e5;
const int MOD = (1ll<<31)-1;

struct node{
    int v,w;
};

vector<node> e[N];

void add(int a,int b,int c){
    e[a].pb({b,c});
    e[b].pb({a,c});
}

int  f[N];
bitset<N> vis;
int d[N];

priority_queue<pii> pq;


void djstr(){
    memset(d,0x3f3f,sizeof d);
    d[1]=0;
    f[1]=1;
    pq.push(mp(0,1));
    while(pq.size()){
        itn x=pq.top().ps;
        pq.pop();
        if(vis[x])continue;
        vis[x]=1;
        for(auto v:e[x]){
            if(vis[v.v])continue;
            if(d[v.v]>d[x]+v.w){
                f[v.v]=1;
                d[v.v]=d[x]+v.w;
                pq.push(mp(-d[v.v],v.v));
            }else if(d[v.v]==d[x]+v.w){
                f[v.v]+=1;
                // cdbg(x,v.v);
            }
        }
    }
}

void solve(){
    itn n=rd,m=rd;
    
    for(int i=1;i<=m;i++){
        int a=rd,b=rd,c=rd;
        add(a,b,c);
    }
    djstr();
    int ans=1;
    for(itn i=1;i<=n;i++)ans=ans*f[i]%MOD;
    cout<<ans<<endl;

}

signed main() {
    // freopen("string.in","r",stdin);
    // freopen("string.out","w",stdout);

    int T=1;
    while(T--){
    	solve();
    }
    return 0;
}
```

---

## 作者：ivyjiao (赞：0)

我们先用 Dijkstra 求出第 $1$ 号房间到其他房间的距离。

设 $dis_i$ 为从第 $1$ 号房间到第 $i$ 号房间的最短路，对于每条边 $(i,j)$（长为 $w$），若 $dis_i+w=dis_j$，则点 $j$ 的方案 $+1$（要保证是最短路）。这种统计方法会把原来求出的最短路路径也算上，所以不会漏下，又因为每条边只统计一次，所以不会重复，且每个点的方案数至少为 $1$。根据乘法原理，最终的答案为每个点的方案数相乘。

注意因为 $1$ 号点是根，所以不可能有方案，所以不能在统计答案时被统计。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define PII pair<int,int>
#define fi first
#define se second
using namespace std;
const int mod=2147483647; 
int n,m,u,v,w,dis[1001],id[1001],ans=1;
struct node{
    int dis,pos;
    bool operator <(const node &x)const{
        return x.dis<dis;
    }
};
priority_queue<node>q;
vector<PII>G[1001];
bool vis[1001];
void dijkstra(int s){
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;
    q.push({0,s});
    while(q.size()){
        int u=q.top().pos;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int i=0;i<G[u].size();i++){
            if(dis[G[u][i].se]>dis[u]+G[u][i].fi){
                dis[G[u][i].se]=dis[u]+G[u][i].fi;
                if(!vis[G[u][i].se]) q.push({dis[G[u][i].se],G[u][i].se});
            }
        }
    }
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v>>w;
        G[u].push_back({w,v});
        G[v].push_back({w,u});
    }
    dijkstra(1);
    for(int i=1;i<=n;i++){
        for(int j=0;j<G[i].size();j++){
            if(dis[i]+G[i][j].fi==dis[G[i][j].se]) id[G[i][j].se]++;
        }
    }
    for(int i=2;i<=n;i++) ans=ans*id[i]%mod;
    cout<<ans;
}
```

---

## 作者：Aventurine_stone (赞：0)

## 1. 题目分析
这道题写法简单，但有一定的思维难度。  
其实你只需要求出起点到每条边深度更大的那个点的最短路的方案数，根据乘法原理，将它们乘起来，边乘边取模就行了。  
## 2. 题目做法
这道题 $n$ 很小，不卡 SPFA，我就用它写的。  
用 $dist$ 数组表示到每个点的最短路，$f$ 数组表示到每个点的方案数。  
若有更短的路，则更新 $dist$，将 $f$ 设为一。  
若搜出一样长的路，则让 $f$ 加一。  
如此便可完成此题。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010,M=2000010,mod=pow(2,31)-1;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int head[N],ne[M],e[M],w[M],idx;
inline void add(int x,int y,int z)
{
	ne[++idx]=head[x];
	head[x]=idx;
	e[idx]=y;
	w[idx]=z;
}
int n,m;
int dist[N],f[N],t;
bool in[N];
queue<int>q;
inline void spfa()
{
	for(int i=2;i<=n;i++)
		dist[i]=INT_MAX/2;
	q.push(1);
	while(!q.empty())
	{
		t=q.front();
		q.pop();
		in[t]=0;
		for(int i=head[t];i;i=ne[i])
		{
			int c=e[i];
			if(dist[t]+w[i]<dist[c])
			{
				dist[c]=dist[t]+w[i];
				f[c]=1;
				if(!in[c])
				{
					q.push(c);
					in[c]=1;
				}
			}
			else if(dist[t]+w[i]==dist[c])
				f[c]++;
		}
	}
}
int x,y,z;
long long s=1;
int main()
{
	n=read(),m=read();
	while(m--)
	{
		x=read(),y=read(),z=read();
		add(x,y,z),add(y,x,z);
	}
	spfa();
	for(int i=2;i<=n;i++)
		s*=f[i],s%=mod;
	printf("%lld",s);
	return 0;
}
```

---


# 闇の連鎖

## 题目描述

传说中的暗之连锁被人们称为 Dark。

Dark 是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。

经过研究，你发现 Dark 呈现无向图的结构，图中有 $N$ 个节点和两类边，一类边被称为主要边，而另一类被称为附加边。

Dark 有 $N - 1$ 条主要边，并且 Dark 的任意两个节点之间都存在一条只由主要边构成的路径。

另外，Dark 还有 $M$ 条附加边。 

你的任务是把 Dark 斩为不连通的两部分。

一开始 Dark 的附加边都处于无敌状态，你只能选择一条主要边切断。

一旦你切断了一条主要边，Dark 就会进入防御模式，主要边会变为无敌的而附加边可以被切断。

但是你的能力只能再切断 Dark 的一条附加边。

现在你想要知道，一共有多少种方案可以击败 Dark。

注意，就算你第一步切断主要边之后就已经把 Dark 斩为两截，你也需要切断一条附加边才算击败了 Dark。

## 说明/提示

数据保证，$1\le N \le 100000$，$1\le M \le 200000$，数据保证答案不超过 $2^{31}-1$。

## 样例 #1

### 输入

```
4 1
1 2
2 3
1 4
3 4```

### 输出

```
3```

# 题解

## 作者：tjtdrxxz (赞：20)

首先，我们可以快速的想出暴力：$ O (nm) $ 暴力判断。

但很明显，因为 $ n \le 10^5, m \le 2 \times 10^5 $，所以暴力是不可行的。

根据题面，我们可以看出最开始的~~主猪~~主边 black 组成了一棵树，所以我们切掉任意一边都可以是他被分成两个连通块。然后就是附加边 red：

![](https://cdn.luogu.com.cn/upload/image_hosting/8l8dzomi.png)

根据图我们可以发现，若一点下的子树与外面有一条附加边，那么我们的方案数就可以加上该子树下的边的的数量，当然，如果该子树没有一条与外面相连的边，则我们不管 kill 哪条边图都会不连通，方案数就是所有附加边的数量。

但是直接统计复杂度又会因为比较暴力的修改退化成 $ O (nm) $，很显然，对于每条附加边，该边做出的贡献一定是在改变的两个节点的 LCA 的子树下。

因为在该子树下，一定存在一个子树有与外面相连的附加边。

所以继续树状数组的思路，我们直接在树上差分，把 $ a_u + 1 $, $ a_v + 1 $, $ a _ { LCA (u, v) } - 2 $,最后统计答案时，我们直接遍历整棵树，把每个点的答案统出来，最后遍历 $ 2 $ ~ $ n $把各个点的答案加起来就 ok 了。

code

```cpp
# include "bits/stdc++.h"
using namespace std;
int f[500012][52];
vector <int> e[500012];
int dp[500012], q, n, m;
void find (int x)
{
	for (int i = 0; i < e[x].size (); i ++)
	{
		if (e[x][i] != f[x][0])
		{
			dp[e[x][i]] = dp[x] + 1;
			f[e[x][i]][0] = x;
			find (e[x][i]);
		}
	}
}
int LCA (int x, int y)
{
	if (dp[x] < dp[y]) swap (x, y);
	for (int i = 26; i >= 0; i --)
	{
		if (dp[x] - (1 << i) >= dp[y])
		{
			x = f[x][i];
		}
		if (x == y)
		{
			return x;
		}
	}
	for (int i = 26; i >= 0; i --)
	{
		if (f[x][i] != f[y][i])
		{
			x = f[x][i];
			y = f[y][i];
		}
	}
	return f[x][0];
}
int ans[100012], out, num[100012];
void dfs (int u, int fa)
{
	num[u] = ans[u];
	for (int i = 0, v; i < e[u].size (); i ++)
	{
		v = e[u][i];
		if (v == fa) continue;
		dfs (v, u);
		num[u] += num[v];
	}
}
int main ()
{
	ios :: sync_with_stdio (0);
	cin.tie (0), cout.tie (0);
	cin >> n >> m;
	for (int i = 1; i < n; i ++)
	{
		int u, v;
		cin >> u >> v;
		e[u].push_back (v);
		e[v].push_back (u);
	}
	q = 1;
	find (q);
	for (int j = 1; (1 << j) <= n; j ++)
	for (int i = 1; i <= n; i ++)
	{
		f[i][j] = f[f[i][j - 1]][j - 1];
	}
	for (int i = 1; i <= m; i ++)
	{
		int u, v;
		cin >> u >> v;
		int lca = LCA (u, v);
		ans[u] += 1;
		ans[v] += 1;
		ans[lca] -= 2;
	}
	dfs (q, 0);
	out = 0;
	for (int i = 2; i <= n; i ++) out += (num[i] == 0 ? m : (num[i] == 1));
	cout << out << endl;
}
```

---

## 作者：Nervegas (赞：10)

# 树上差分
不会树上差分的[看这里](https://www.luogu.com.cn/article/43npkrt7)。

$2024.10.9$ 更新错误

本题需要解决的是每条“树边”被“非树边”覆盖了多少次，可以使用树上差分的边差分解决。

树的初始状态为 $0$，如果路径 $(x,y)$ 上被“非树边”覆盖一次，则进行一次边差分，$x$ 的点权 $+1$，$y$ 的点权 $+1$，$\operatorname{lca}(x,y)$ 的点权 $-2$ (边差分)。

设连接两点间的“非树边”个数为 $a$，因为可以切断一条“树边”和一条“非树边”，当 $a=0$ 时直接断掉这条“树边”，然后随便断掉一条“非树边”即可；当 $a=1$ 时断掉这条“树边”，只有把这条“非树边”断掉才满足题；当 $a>1$ 时无论断掉那条“树边”，没有方案满足题目。

综上所述：

$a=0$ 时，方案数 $+m$；

$a=1$ 时，方案数 $+1$；

$a>1$ 时，无解，方案数不变。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e7 + 10;

int head[maxn], cnt;
int quan[maxn];

int ans = 0;

struct node{
	int to;
	int nxt;
}e[maxn];

void add(int u, int v){
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

int n, m;
int fa[maxn][30];
int de[maxn];

void dfs(int u, int f){
	de[u] = de[f] + 1;
	fa[u][0] = f;
	for(int i = 1 ; i <= 20 ; i++){
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	} 
	for(int i = head[u] ; i ; i = e[i].nxt){
		int v = e[i].to;
		if(v == f){
			continue;
		}
		dfs(v, u);
	}
}

int lca(int u, int v){
	if(de[u] < de[v]){
		swap(u, v);
	}
	for(int i = 20 ; i >= 0 ; i--){
		if(de[fa[u][i]] >= de[v]){
			u = fa[u][i];
		} 
	}
	if(u == v){
		return v;
	}
	for(int i = 27 ; i >= 0 ; i--){
		if(fa[u][i] != fa[v][i]){
			u = fa[u][i];
			v = fa[v][i];
		}
	}
	return fa[u][0];
}

void solve(int u, int f){
	for(int i = head[u] ; i ; i = e[i].nxt){
		int v = e[i].to;
		if(v == f){
			continue;
		}
		solve(v, u);
		quan[u] += quan[v];
	}
	if(u == 1){
		return;
	}
	if(quan[u] == 1){
		ans++;
	}
	if(quan[u] == 0){
		ans += m;
	}
}


int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin >> n >> m;
	for(int i = 1 ; i < n ; i++){
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u); 
	}
	dfs(1, 0);
	for(int i = 1 ; i <= m ; i++){
		int a, b;
		cin >> a >> b;
		int LCA = lca(a, b);
		quan[a]++;
		quan[b]++;
		quan[LCA] -= 2;
	}
	solve(1, 0);
	cout << ans << endl;
	return 0;
}
```

---

## 作者：zhongli_230731 (赞：6)

## 重链剖分

### 题面

[P10931 闇の連鎖](https://www.luogu.com.cn/problem/P10931)

### 分析题意：
1. 删边顺序无影响。

2. 主要边连在一起构成了一棵树。

3. 每一条连接 $(x,y)$ 的附加边相当于再次覆盖了树上 $(x,y)$ 的路径。

4. 对于树上无任何覆盖的边，对答案的贡献为 $M$。

5. 对于树上只被覆盖过一次的边，对答案的贡献为 $1$。

### 实现方法

通过线段树维护重链剖分的 dfn 序即可。

需要实现两个操作：区间加，单点查询。

对于每一次添加附加边的操作，将树上 $(x,y)$ 的路径区间加 $1$，在最后统计答案时遍历树单点查询即可。

时间复杂度 $O(n\log^2n)$。

### 代码实现
~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+1;
int dad[maxn],son[maxn],siz[maxn],top[maxn],dep[maxn];
int dfn[maxn],df;
struct star
{
	int from;
	int to;
	int nxt;
}edge[maxn<<3];
int point[maxn],cnt,ans;
void connect(int u,int v)
{
	edge[++cnt].from=u;
	edge[cnt].to=v;
	edge[cnt].nxt=point[u];
	point[u]=cnt;
}
inline int dfs1(int x,int fa)
{
	dad[x]=fa;
	siz[x]=1;
	dep[x]=dep[fa]+1;
	int maxx=0,to;
	for(int i=point[x];i;i=edge[i].nxt)
	{
		to=edge[i].to;
		if(to==fa)continue; 
		siz[x]+=dfs1(to,x);
		if(maxx<siz[to])maxx=siz[to],son[x]=to;
	}
	return siz[x];
}
void dfs2(int x,int topp)
{
	int to;
	top[x]=topp;
	dfn[x]=++df;
	if(son[x])dfs2(son[x],topp);
	for(int i=point[x];i;i=edge[i].nxt)
	{
		to=edge[i].to;
		if(to==dad[x]||to==son[x])continue;
		dfs2(to,to);
	}
}
struct Segment
{
	#define mid ((l+r)>>1)
	#define ch1 x<<1
	#define ch2 x<<1|1
	#define ls ch1,l,mid
	#define rs ch2,mid+1,r
	int sum[maxn<<2], tag[maxn<<2];
	
	void push_down(int x)
	{
		if(!tag[x]) return;
		sum[ch1]+=tag[x];
		sum[ch2]+=tag[x];
		tag[ch1]+=tag[x];
		tag[ch2]+=tag[x];
		tag[x]=0;
	}
	
	void add(int x,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R)sum[x]++, tag[x]++;
		else
		{
			push_down(x); 
			if(L<=mid)add(ls,L,R);
			if(R>mid) add(rs,L,R);
		}
	}
	inline int ask(int x,int l,int r,int id)
	{
		if(l==r)return sum[x];
		push_down(x); 
		if(id<=mid)return ask(ls,id);
		else return ask(rs,id);
	}
}tree;
int n,m;
void lca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]]) swap(x, y);
		tree.add(1, 1, n, dfn[top[x]], dfn[x]);
		x=dad[top[x]];
	}
	if(x==y) return;
	if(dep[x]<dep[y]) swap(x, y);
	tree.add(1, 1, n, dfn[y]+1, dfn[x]);
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	int u,v;
	for(int i=1;i<n;i++)cin>>u>>v,connect(u,v),connect(v,u);
	dfs1(1,1);
	dfs2(1,1);
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v;
		lca(u,v);
	}
	for(int i=2,j;i<=n;i++)
	{
		j=tree.ask(1,1,n,dfn[i]);
		if(j==0) ans+=m;
		else if(j==1) ans++;
	}
	cout<<ans;
	return 0;
}
~~~

---

## 作者：xuan_gong_dong (赞：3)

## 题面
[P10931 闇の連鎖](https://www.luogu.com.cn/problem/P10931)
## 分析
注意一个点，显然先删除主要边再删除附加边，与先删除附加边再删除主要边本质对答案没影响。

并且对于每一个附加边，它与这棵树都会形成一个环，
且环上的每一个主要边与该附加边都为一个方案。

于是，我们就可以对于每个附加边所连接的两个节点 $u$，$v$，将它们在树上的最短路径上的所有边都加 $1$。

统计答案的时候，如果该边为 $0$，则对答案的贡献是 $m$，如果 $1$，这贡献为 $1$，如果 $\ge 2$，则表示被多个环包含，对答案无贡献。

树上路径加可以直接树剖就好了，边的信息下发到深度更深的节点就好了。

时间复杂度为 $O(m \log n)$。
## Code

```cpp
#include<bits/stdc++.h>
#define MAXN 1000010
#define int long long
using namespace std;
struct node {
	int nxt,to;
} edge[MAXN<<1];
int head[MAXN],tot;
inline void add(int x,int y) {
	edge[++tot].nxt=head[x];
	edge[tot].to=y;
	head[x]=tot;
}
inline int read() {
	int x=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c)) {
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}
inline void write(int x) {
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
int n,m,r;
int a[MAXN];
int fa[MAXN],size[MAXN],son[MAXN],dep[MAXN];
void dfs1(int id,int fath) {
	dep[id]=dep[fath]+1;
	fa[id]=fath;
	size[id]=1;
	for(int i=head[id]; i; i=edge[i].nxt) {
		int to=edge[i].to;
		if(to==fath)continue;
		dfs1(to,id);
		size[id]+=size[to];
		if(!son[id]||size[son[id]]<size[to]) {
			son[id]=to;
		}
	}
}
int top[MAXN],dfs_num,hys[MAXN],w[MAXN];
void dfs2(int id,int topid) {
	hys[id]=++dfs_num;
	top[id]=topid;
	w[dfs_num]=a[id];
	if(son[id]) {
		dfs2(son[id],top[id]);
	}
	for(int i=head[id]; i; i=edge[i].nxt) {
		int to=edge[i].to;
		if(to==fa[id]||to==son[id])continue;
		dfs2(to,to);
	}
}
struct Seg {
	int l,r;
	int sum,lazy;
} tree[MAXN<<2];
void pushdown(int id) {
	if(tree[id].lazy!=0) {
		tree[id*2].sum+=(tree[id*2].r-tree[id*2].l+1)*tree[id].lazy;
		tree[id*2+1].sum+=(tree[id*2+1].r-tree[id*2+1].l+1)*tree[id].lazy;
		tree[id*2].lazy+=tree[id].lazy;
		tree[id*2+1].lazy+=tree[id].lazy;;
		tree[id].lazy=0;
	}
}
void build(int id,int l,int r) {
	tree[id].l=l;
	tree[id].r=r;
	if(l==r) {
		return ;
	}
	int mid=(l+r)/2;
	build(id*2,l,mid);
	build(id*2+1,mid+1,r);
}
void update(int id,int l,int r,int k) {
	if(l>r)swap(l,r);
	if(tree[id].l==l&&tree[id].r==r) {
		tree[id].sum+=(tree[id].r-tree[id].l+1)*k;
		tree[id].lazy+=k;
		return ;
	}
	pushdown(id);
	int mid=(tree[id].l+tree[id].r)/2;
	if(mid>=r) {
		update(id*2,l,r,k);
	} else if(mid<l) {
		update(id*2+1,l,r,k);
	} else {
		update(id*2,l,mid,k);
		update(id*2+1,mid+1,r,k);
	}
	tree[id].sum=(tree[id*2].sum+tree[id*2+1].sum);
}
int query(int id,int l,int r) {
	if(l>r)swap(l,r);
	if(tree[id].l==l&&tree[id].r==r) {
		return tree[id].sum;
	}
	pushdown(id);
	int mid=(tree[id].l+tree[id].r)/2;
	if(r<=mid) {
		return query(id*2,l,r);;
	} else if(mid<l) {
		return query(id*2+1,l,r);
	} else {
		return (query(id*2,l,mid)+query(id*2+1,mid+1,r));
	}
}
void update_1(int x,int y,int z) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,hys[x],hys[top[x]],z);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	update(1,hys[x],hys[y],z);
	update(1,hys[y],hys[y],-1);
}
int query_1(int x,int y) {
	int res=0;
	while(top[x]!=top[y]) {
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		res+=query(1,hys[x],hys[top[x]]);

		res;
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	res+=query(1,hys[x],hys[y]);
	return res;;
}
signed main() {
	n=read(),m=read();
	r=1;
	for(int i=1; i<n; i++) {
		int x,y;
		x=read(),y=read();
		add(x,y);
		add(y,x);
	}
	dfs1(r,0);
	dfs2(r,r);
	build(1,1,dfs_num);
	for(int i=1; i<=n; i++) {
		top[i]=top[i];
	}
	for(int i=1; i<=n; i++) {
		dep[i]=dep[i];
	}
	for(int i=1; i<=m; i++) {
		int u,v;
		scanf("%lld%lld",&u,&v);
		update_1(u,v,1);
	}
	int ans=0;
	for(int i=2; i<=n; i++) {
		int x=query(1,hys[i],hys[i]);
		if(x==0)ans+=m;
		if(x==1)ans++;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：3)

简单题。
## solution
断开树上的一条边，这棵树一定被分成两半，设连接这两半的附加边边数为 $x$。

- $x=1$，下一步一定要断开这一条附加边，方案数加 $1$。
- $x=0$，随便断开一条边图都不连通，方案数加 $m$。
- $x>1$，不可能连着断开多条附加边，方案数不变。

考虑增加一条从 $u$ 到 $v$ 的附加边对于每条边 $x$ 的影响，那么应该是从 $u$ 到 $v$ 的简单路径上的边都加 $1$。

这个显然可以树上差分维护一下，用 $d_u$ 表示 $u$ 到 $fa$ 的边上的 $x$ 差分数组，对于每一条附加边，$d_u$ 和 $d_v$ 都加 $1$，$d_{lca}$ 减去 $2$，最后直接树上前缀和即可。
## code

```cpp
int n,m,step[nn],dp[nn][18],head[nn],nxt[nn*2],cnt,d[nn],ans;
struct node{
    int u,v;
}edge[nn*2];
inline void add(int u,int v){
    cnt++;
    edge[cnt].u=u,edge[cnt].v=v;
    nxt[cnt]=head[u],head[u]=cnt;
}
inline void dfs(int u,int fa){
	dp[u][0]=fa;
	step[u]=step[fa]+1;
	for(int i=1;i<=17;i++){
		dp[u][i]=dp[dp[u][i-1]][i-1];
		if(dp[u][i]==0) break;
	}
	for(int i=head[u];i;i=nxt[i]){
		int v=edge[i].v;
		if(v!=fa) dfs(v,u);
	}
}
inline int lca(int a,int b) {
	if(step[a]<step[b]) swap(a,b);
	for(int i=17;i>=0;i--){
		int to=dp[a][i];
		if(step[to]>=step[b]) a=to;
	}
	if(a==b) return a;
	for(int i=17;i>=0;i--){
		if(dp[a][i]!=dp[b][i]) a=dp[a][i],b=dp[b][i];
	}
	return dp[a][0];
}
inline void dfsc(int u,int fa,int in){
    for(int i=head[u];i;i=nxt[i]){
        int v=edge[i].v;
        if(v!=fa){
            dfsc(v,u,i);
            d[u]+=d[v];
        }
    }
    if(u==1) return ;
    if(d[u]==1) ans++;
    if(d[u]==0) ans+=m;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    dfs(1,0);
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        int LCA=lca(u,v);
        d[u]++,d[v]++,d[LCA]-=2;
    }
    dfsc(1,0,0);
    cout<<ans<<endl;
    return 0;
}
```
特判 $u=1$ 的情况，时间复杂度 $O(n\log n)$。

---

## 作者：ivyjiao (赞：1)

树上差分+树形 DP 经典题。

根据树的性质，我们可以发现：每加入一条附加边 $(a_i,b_i)$，都会形成一个从 $a_i$ 到 $b_i$ 的一定经过 $a_i,b_i,lca_{a_i,b_i}$ 的环，我们只需要断掉这个环，再断掉一条环上的树边，就能将树断为不连通的两部分。所以如果只有一个环经过这条树边，这条边的答案为 $1$。

然而还有两种可能：

1. 没有环经过这条树边。那么断掉这条树边之后树已经断为不连通的两部分，第二条附加边随便断，答案为 $m$。

2. $\geq 2$ 个环经过这条树边。那么很明显怎么断边都无法将树断为不连通的两部分，此时无解。

那么考虑如何统计答案。根据树上差分的性质，我们化点为边。令 $sum_{i}$ 指有多少个环经过 $i$ 节点，那么对于每条附加边 $(a_i,b_i)$：

 
$$\begin{aligned}
&d_{a_i}\leftarrow d_{a_i}+1\\
&d_{b_i}\leftarrow d_{b_i}+1\\
&d_{lca_{a_i,b_i}}\leftarrow d_{lca_{a_i,b_i}}-2\\
\end{aligned}$$

不会的看[这里](https://oi-wiki.org/basic/prefix-sum/#%E8%BE%B9%E5%B7%AE%E5%88%86)。

由于我们只需要知道每个节点的 $sum$ 值，所以只需要求一遍树上前缀和即可。

不会的看[这里](https://oi-wiki.org/basic/prefix-sum/#%E6%A0%91%E4%B8%8A%E5%89%8D%E7%BC%80%E5%92%8C)。

最后根据以上规则，用 $sum$ 值统计答案。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,f[100001][21],dep[100001],sum[100001],ans;
vector<int>G[100001];
void dfs(int u,int fa,int de){
    dep[u]=de;
    f[u][0]=fa;
    for(int i=1;i<=20;i++) f[u][i]=f[f[u][i-1]][i-1];
    for(int i=0;i<G[u].size();i++){
        if(G[u][i]==fa) continue;
        dfs(G[u][i],u,de+1);
    }
}
void dfs2(int u,int fa){
    for(int i=0;i<G[u].size();i++){
        if(G[u][i]==fa) continue;
        dfs2(G[u][i],u);
        sum[u]+=sum[G[u][i]];
    }
}
int lca(int x,int y){
    if(x==y) return x;
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=20;i>=0;i--) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
    if(x==y) return x;
    for(int i=20;i>=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    return f[x][0];
}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n-1;i++){
        cin>>x>>y;
        G[x].push_back(y);
        G[y].push_back(x);
    }
    dfs(1,0,1);
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        sum[x]++;
        sum[y]++;
        sum[lca(x,y)]-=2;
    }
    dfs2(1,0);
    for(int i=2;i<=n;i++){
        if(!sum[i]) ans+=m;
        else if(sum[i]==1) ans++;
    }
    cout<<ans;
}
```

---

## 作者：Aventurine_stone (赞：0)

## 1. 题目分析
题目大意是，一个图分为主要边和附加边，你可以去掉一条主要边和一条附加边，求有多少种方案使操作后图不连通。  
而主要边构成的图是一棵树，切断任何一条树边，此图便不连通。我们便只需重点考虑切哪条附加边可使剩下的图不连通即可。
## 2. 题目做法
我们考虑一条附加边，在哪些主要边被删去之后，它必须被切去才可以使此图不连通。经过观察可以发现，附加边连接的两个点在主要边的简单路径上的主要边，都被这一条附加边影响。  
给每个点或边加一肯定超时，我们考虑树上差分，给这两个点的值加一，再给它们的最近公共祖先减二，最后再用 dfs 求一遍前缀和即可，这里需要用 lca 优化。  
除了节点一之外，其它点如果点值大于一，则切掉此主要边后，无论切哪条附加边都不能使图不连通，方案数不变。  
如果点值等于一，则切了此条主要边必须切固定的一条附加边才可以使图不连通，方案数加一。  
如果点值为零，则切了此条主要边之后，切任何一条附加边都可以使图不连通，方案数加 $m$。  
最后输出方案数即可。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=200010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int head[N],ne[M],e[M],idx;
inline void add(int x,int y)
{
	ne[++idx]=head[x];
	head[x]=idx;
	e[idx]=y;
}
int n,m;
int dep[N],fa[N][18],v[N],t;
queue<int>q;
void bfs()
{
	dep[1]=1;
	q.push(1);
	while(!q.empty())
	{
		t=q.front();
		q.pop();
		for(int i=head[t];i;i=ne[i])
		{
			int c=e[i];
			if(!dep[c])
			{
				q.push(c);
				dep[c]=dep[t]+1;
				fa[c][0]=t;
				for(int i=1;i<=16;i++)
					fa[c][i]=fa[fa[c][i-1]][i-1];
			}
		}
	}
}
inline int lca(int x,int y)
{
	if(dep[x]<dep[y])
		swap(x,y);
	for(int i=16;i>=0;i--)
	{
		t=fa[x][i];
		if(dep[t]>=dep[y])
			x=t;
	}
	if(x==y)
		return x;
	for(int i=16;i>=0;i--)
	{
		if(fa[x][i]!=fa[y][i])
		{
			x=fa[x][i],y=fa[y][i];
		}
	}
	return fa[x][0];
}
inline void dfs(int x)
{
	for(int i=head[x];i;i=ne[i])
	{
		int c=e[i];
		if(dep[c]>dep[x])
		{
			dfs(c);
			v[x]+=v[c];
		}
	}
}
int x,y,sum;
int main()
{
	n=read(),m=read();
	for(int i=1;i<n;i++)
	{
		x=read(),y=read();
		add(x,y),add(y,x);
	}
	bfs();
	for(int i=1;i<=m;i++)
	{
		x=read(),y=read();
		v[x]++,v[y]++;
		v[lca(x,y)]-=2;
	}
	dfs(1);
	for(int i=2;i<=n;i++)
	{
		if(!v[i])
			sum+=m;
		else if(v[i]==1)
			sum++; 
	}
	printf("%d",sum);
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

简单题，考虑枚举第一次断开的**主要边**。

则对于每条附加边 $u \to v$，满足当树上 $u \to v$ 路径上的边断开后连接了断开的两个部分。

若有 $k$ 条附加边连接了断开的两个部分：

- 若 $k=0$，则随便切一条附加边，方案数增加 $m$。

- 若 $k=1$，则必须切这条边，方案数增加 $1$。

- 若 $k>0$，则无论如何切都无法满足条件。

使用树上差分计算即可，时间复杂度为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=1e5+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,u,v,ans;
ll d[N];
vector<ll> E[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
namespace LCA{
	ll p[N],t[N],z[N],d[N],fa[N];
	void dfs1(ll u,ll f){
		p[u]=1;
		for(auto v:E[u]){
			if(v==f)
			  continue;
			d[v]=d[u]+1;
			fa[v]=u;
			dfs1(v,u);
			p[u]+=p[v];
			if(p[v]>p[z[u]])
			  z[u]=v;
		}
	}
	void dfs2(ll u,ll k){
		t[u]=k;
		if(!z[u])
		  return ;
		dfs2(z[u],k);
		for(auto v:E[u]){
			if(v==fa[u]||v==z[u])
			  continue;
			dfs2(v,v);
		}
	}
	ll Lca(ll u,ll v){
		while(t[u]!=t[v]){
			if(d[t[u]]<d[t[v]])
			  swap(u,v);
			u=fa[t[u]];
		}
		return d[u]<d[v]?u:v;
	}
	void init(){
		dfs1(1,1);
		dfs2(1,1);
	}
};
void dfs(ll u,ll fa){
    for(auto v:E[u]){
        if(v==fa)
          continue;
        dfs(v,u);
        d[u]+=d[v];
    }
}
int main(){
    n=read(),m=read();
    For(i,1,n-1){
        u=read(),v=read();
        add(u,v);
    }
    LCA::init();
    For(i,1,m){
        u=read(),v=read();
        d[u]++,d[v]++,d[LCA::Lca(u,v)]-=2;
    }
    dfs(1,1);
    For(i,2,n){
        if(!d[i])
          ans+=m;
        else if(d[i]==1)
          ans++;
    }
    write(ans);
    return 0;
}
```

---

## 作者：Crazyouth (赞：0)

## 分析

下文中的 $\operatorname{lca}(u,v)$ 均指 $u,v$ 的最近公共祖先。

不错的树上差分练习题。

题目首先是在求删一条树边以及一条非树边使图不连通的方案数。

在树上每加一条边就必定产生一个环，如果一开始删除的树边在这个环内，除非删除导致这个环产生的非树边，否则此图必定依然连通。进而想到如果这条树边在两个环上，那么删除了这条非树边后图仍然连通。

如果某条树边并不在任何产生的环上，那么删除此边后 Dark 已经不连通，接下来删除任一非树边即可。

问题转化成求每条边在多少个环上。树上差分即对于每条需要处理的非树边 $(u,v)$，对 $u,v$ 的点权各加一，对 $\operatorname{lca}(u,v)$ 的点权减二，每条边所在环的数量便是其连接的较深点的子树点权和（包括自身）。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int cnt[N],fa[N][21],a[N],dep[N];
vector<int> G[N];
void dfs(int u,int f)
{
	dep[u]=dep[f]+1;
	fa[u][0]=f;
	for(int i=1;i<=20;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(auto v:G[u])
	{
		if(v==f) continue;
		dfs(v,u);
	}
}
int lca(int u,int v)
{
	if(dep[u]<dep[v]) swap(u,v);
	for(int i=20;~i;i--) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
	if(u==v) return u;
	for(int i=20;~i;i--)
	{
		if(!fa[u][i]||!fa[v][i]||fa[u][i]==fa[v][i]) continue;
		u=fa[u][i];
		v=fa[v][i];
	}
	return fa[u][0];
}
void dfs2(int u)
{
	cnt[u]=a[u];
	for(auto v:G[u])
	{
		if(v==fa[u][0]) continue;
		dfs2(v);
		cnt[u]+=cnt[v];
	}
} 
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		a[u]++;
		a[v]++;
		a[lca(u,v)]-=2;
	}
	dfs2(1);
	long long ans=0;
	for(int i=2;i<=n;i++) ans+=(cnt[i]==0?m:(cnt[i]==1?1:0));
	cout<<ans;
}

---


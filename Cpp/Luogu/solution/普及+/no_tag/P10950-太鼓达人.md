# 太鼓达人

## 题目描述

太鼓达人的鼓坏了，现在 vani 来修鼓。

鼓的主要元件是 $M$ 个围成一圈的传感器。

每个传感器都有开和关两种工作状态，分别用 $1$ 和 $0$ 表示。

显然，从不同的位置出发沿顺时针方向连续检查 $K$ 个传感器可以得到 $M$ 个长度为 $K$ 的 $01$ 串。

Vani 知道这 $M$ 个 $01$ 串应该是互不相同的。

而且鼓的设计很精密，$M$ 会取到可能的最大值。

现在 Vani 已经了解到了 $K$ 的值，他希望你求出 $M$ 的值，并给出字典序最小的传感器排布方案。

## 说明/提示

$2\le K\le 11$。

## 样例 #1

### 输入

```
3```

### 输出

```
8 00010111```

# 题解

## 作者：lutaoquan2012 (赞：6)

## 题意：
给你一个数字 $k$，让你构造出字典序最小的一个字符串，这个字符串的长度 $m$ 要最大，并且要求 **任意选取两个长度为 $k$ 的字串，要求互不相同**。注意：这个字符串是一个环形，所以首尾相连。

举个例子：
```
当 k 等于 3 时，满足的字符串是 00010111。

他需要满足一下这些值任意两项不同：
1. 000
2. 001
3. 010
4. 101
5. 011
6. 111
7. 110
8. 100

明白了吧。
```

## 思路：

第一眼看到数据范围，这不是纯打表么？

细细一读题，不难发现，我们最多最多可以构造出 $M$ 最大是 $2^k$。~~这应该都能看出来吧~~

因为题目要求字典序最小，结合样例就可以看出前 $k$ 个数一定都是 $0$。

因为数据较小，所以我们考虑暴力搜索出一个 $01$ 字符串。唯一的剪枝优化就是记录一个桶，记录一个数有没有在一个长度为 $k$ 的子串中出现，当暴力到这个新选择的节点时，如果这个以这个节点为结尾的长度为 $k$ 的子串有没有在前面出现过，如果有的话那就放弃，不在继续递归。

## 代码：
暴力代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll k,a[6010],n;
bool b[6010];
ll f(ll x){//计算长度，也就是 2 的 k 次方。
	ll ans=1;
	for(int i=1;i<=x;i++) ans*=2;
	return ans;
}ll hh(string s){//把一个二进制转成一个数。
	ll base=1,ans=0;
	for(int i=s.size()-1;i>=0;i--){
		ans+=(s[i]-'0')*base;
		base*=2;
	}return ans;
}                             
void dfs(ll step){
	if(step==n+1){//如果全部选择完了，判断一下结尾的部分，因为这道题是一个环形。
		bool flag=false;		
		for(int j=n-k+2;j<=n;j++){
			string s="";
			for(int l=j;l<=j+k-1;l++) s+=(a[l]+'0');
			ll x=hh(s);
			if(b[x]==true) {flag=true;break;}
		}if(flag==false){//因为我们每次先选的是 0，所以第一个选上的一定是字典序最小的。
			for(int i=1;i<=n;i++) cout<<a[i];
			exit(0);
		}return ;
	}
	for(int i=0;i<=1;i++){//选择当前节点是 0 还是 1。
		string s="";
		a[step]=i;
		for(int j=step-k+1;j<=step;j++) s+=(a[j]+'0');
		ll x=hh(s);
		if(b[x]==true) continue;
		b[x]=true;
		dfs(step+1);
		b[x]=false;
	}
}
int main(){
	cin>>k;
	n=f(k);
	cout<<n<<" ";//输出长度
	b[0]=true;//注意我是直接跳过了前 k 个节点，所以 0 已经使用过了，以后不能再使用
	dfs(k+1);
	return 0;
}
```

打表代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll k;
int main(){
	cin>>k;
	if(k==2) cout<<"4 0011";
	else if(k==3) cout<<"8 00010111";
	else if(k==4) cout<<"16 0000100110101111";
	else if(k==5) cout<<"32 00000100011001010011101011011111";
	else if(k==6) cout<<"64 0000001000011000101000111001001011001101001111010101110110111111";
	else if(k==7) cout<<"128 00000001000001100001010000111000100100010110001101000111100100110010101001011100110110011101001111101010110101111011011101111111";
	else if(k==8) cout<<"256 0000000010000001100000101000001110000100100001011000011010000111100010001001100010101000101110001100100011011000111010001111100100101001001110010101100101101001011110011001101010011011100111011001111010011111101010101110101101101011111011011110111011111111";
	else if(k==9) cout<<"512 00000000010000000110000001010000001110000010010000010110000011010000011110000100010000100110000101010000101110000110010000110110000111010000111110001000110001001010001001110001010010001010110001011010001011110001100110001101010001101110001110010001110110001111010001111110010010010110010011010010011110010100110010101010010101110010110110010111010010111110011001110011010110011011010011011110011101010011101110011110110011111010011111110101010110101011110101101110101110110101111110110110111110111011110111111111";
	else if(k==10) cout<<"1024 0000000000100000000110000000101000000011100000010010000001011000000110100000011110000010001000001001100000101010000010111000001100100000110110000011101000001111100001000010001100001001010000100111000010100100001010110000101101000010111100001100010000110011000011010100001101110000111001000011101100001111010000111111000100010100010001110001001001000100101100010011010001001111000101001100010101010001010111000101100100010110110001011101000101111100011000110010100011001110001101001000110101100011011010001101111000111001100011101010001110111000111100100011110110001111101000111111100100100110010010101001001011100100110110010011101001001111100101001010011100101010110010101101001010111100101100110010110101001011011100101110110010111101001011111100110011010011001111001101010100110101110011011011001101110100110111110011100111010110011101101001110111100111101010011110111001111101100111111010011111111010101010111010101101101010111110101101011011110101110111010111101101011111110110110111011011111101110111110111101111111111";
	else cout<<"2048 00000000000100000000011000000001010000000011100000001001000000010110000000110100000001111000000100010000001001100000010101000000101110000001100100000011011000000111010000001111100000100001000001000110000010010100000100111000001010010000010101100000101101000001011110000011000100000110011000001101010000011011100000111001000001110110000011110100000111111000010000110000100010100001000111000010010010000100101100001001101000010011110000101000100001010011000010101010000101011100001011001000010110110000101110100001011111000011000110000110010100001100111000011010010000110101100001101101000011011110000111000100001110011000011101010000111011100001111001000011110110000111110100001111111000100010010001000101100010001101000100011110001001001100010010101000100101110001001100100010011011000100111010001001111100010100011000101001010001010011100010101001000101010110001010110100010101111000101100110001011010100010110111000101110010001011101100010111101000101111110001100011100011001001000110010110001100110100011001111000110100110001101010100011010111000110110010001101101100011011101000110111110001110010100011100111000111010010001110101100011101101000111011110001111001100011110101000111101110001111100100011111011000111111010001111111100100100101001001001110010010101100100101101001001011110010011001100100110101001001101110010011101100100111101001001111110010100101100101001101001010011110010101001100101010101001010101110010101101100101011101001010111110010110011100101101011001011011010010110111100101110011001011101010010111011100101111011001011111010010111111100110011011001100111010011001111100110100111001101010110011010110100110101111001101101010011011011100110111011001101111010011011111100111001111001110101010011101011100111011011001110111010011101111100111101011001111011010011110111100111110101001111101110011111101100111111101001111111110101010101101010101111010101101110101011101101010111111010110101110101101101101011011111010111011110101111011101011111011010111111110110110111101101110111011011111110111011111101111011111011111111111";
	return 0;
}
```

---

## 作者：Luke_li (赞：3)

这是一种欧拉回路的做法，因为我观察到题解区没有欧拉回路的题解。

## 题意

题意就不再赘述了，需要的可以看其他题解。

## 思路

如果把每个 $k$ 位 01 串视为一个点，把“往 01 串后面加一位” 视为一条有向边，那么这是个哈密顿路径的问题，要求每个点恰好经过一次。可惜的是哈密顿路径是 NP-Complete 的。

我们还可以转换思路，把每个 $k-1$ 位 01 串视为一个点，把“往 01 串后面加一位” 视为一条有向边，那么每个点恰好有两条入边，来源于两个第 $k-1$ 高位不同的点，因此代表了这个点的两个不同的形态（第 $k$ 高位分别为 $0,1$）。这就变成了欧拉回路问题 —— 每条边经过恰好一次。

![](https://cdn.luogu.com.cn/upload/image_hosting/iqwko0n8.png)

显然第一问的答案等于边数 ——$2^k$。对于第二问，我们只需跑一遍 Hierholzer 算法（dfs 法求欧拉回路），每跑过一条边就把这条边输出（因为这个图一定是欧拉回路，所以无需使用栈）。

接下来是实现上的细节：我们可以采用当前弧优化来减小最坏复杂度。其次，我们必须以 $2^{k-1}-1$（$11\dots 11$） 为起点。后者是因为我们在一个环上，我们初始状态实际上是第一个位置前的一段，也就是末尾的一段，因此设置为全 $1$，同时这样转移到环的前面一段时都是 $0$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e6+10;
ll k;
ll cur[N];
bool ans[N];
ll tot,lim;
void dfs(ll x)
{
	for(ll i=cur[x];i<=1;i=cur[x])
	{
		cout<<i;
		cur[x]=i+1;
		dfs(((x<<1)&lim)|i);
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>k;
	lim=(1ll<<(k-1))-1;
	cout<<(1ll<<k)<<" ";
	dfs(lim);
	return 0;
}
```

感觉比不少暴力还要简短，而且可以过 $2\le k\le 21$ 哦。

---

## 作者：Cells (赞：2)

#### 思路

贪心。

> $M$ 个 $01$ 串应该是互不相同的。

正因如此，长度为 $K$ 的 $01$ 串，每一位就会有 $0$ 和 $1$ 两种选择，所以 $M$ 的最大值就是 $2^k$。

第一个数就是 $2^k$。

因为你要不同，又需要字典序最小，所以我们能确定前 $k$ 个数字全部是 $0$，并且后 $k$ 个数字全部是 $1$。

然后，当你每填好一个数字，就要把这个数字甩进一个集合里面来标记已经填过了。

当然，在填数字之前就要判断是否重复。

**Code**

```c++
# include <bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N = 3e3 + 10;

int k, w, order[N];
LL num, mod;

set<LL> s;

void dfs(int pos, LL lst){//pos是位置，lst是上一个数 
	if(pos == w - k + 1) return;//填完了 
	lst = lst % mod * 10;
	
	if(s.find(lst) == s.end()){//没找到，贪心填0 
		s.insert(lst);
		order[pos] = 0;
		dfs(pos + 1, lst);
	}
	
	else{//填1 
		lst ++;
		s.insert(lst);
		order[pos] = 1;
		dfs(pos + 1, lst);
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> k;
	mod = pow(10, k - 1);
	w = pow(2, k);
	cout << w << " ";//位数 
	
	for(int i = 1; i <= k; i ++) num = num * 10 + 1;//全是1 
	s.insert(num);
	for(int i = 1; i <= k; i ++){
		num = num % mod * 10 + 0;//一位一位变成0 
		s.insert(num);
		order[w - i + 1] = 1;//把数组处理好 
	}
	
	dfs(k + 1, 0);//从k+1位开始填，前面的数是0 
	
	for(int i = 1; i <= w; i ++) cout << order[i];
	
	return 0;
}
```

**完结撒花！！！**

---

## 作者：Cypher_404 (赞：2)

# 题解：P10950 太鼓达人

## 题意解析

当时我看这个题面看了好久，赶紧给大家讲个明白。

首先，题目会给定一个数字 $k$，表示你构造的数列（仅包含 $0$ 和 $1$）将每相邻的 $k$ 个组成一个二进制数字。

设构造的数列长度为 $n$，那么总共会构造出 $n-k+1$ 个数字。

如果你还没明白，这里举样例的例子：

`00010111` 三个位组成一个二进制数字。

便可以组成：$0\ 1\ 2\ 5\ 3\ 7$。

**注意：题目中要求了字典序最小！**

## 具体做法

使用深度优先搜索（dfs），每一次取当前状态的最后一位讨论。

分两种情况：

1. 最后一位放入 $1$。
2. 最后一位放入 $0$。

仅需分别深搜即可。（具体可见代码）。

## 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template< typename T > inline void read(T &x)
{
    char c=getchar();x=0;int f=0;
    for(;!isdigit(c);c=getchar()) f|=(c=='-');
    for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
    x=f?-x:x;
}//快读
int qwq[]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192};//预处理每一次的长度
int a[114514],vis[114514];
int n,num;
void dfs(int u,int now)
{
	if(u>qwq[n])//如果大于了总长度，那么输出（已保证字典序最小）
	{
		a[qwq[n]]=1;//不知道为啥最后一位总是0，有知道的可以私信我，感谢各位dalao
		for(int i=1;i<=qwq[n];i++)
		{
			cout<<a[i];
		}
		exit(0); //直接退出整个程序
	}
	now=((now%num)<<1);//可以自己换成二进制模拟一下，取后面的位数并且左移一位，为选择0或1做准备
	if(!vis[now])//选择0
	{
		vis[now]=1;//注意：此处仅是省略了a[u]=0;
		dfs(u+1,now);
		vis[now]=0;
	}
	if(!vis[now+1])
	{
		vis[now+1]=1;
		a[u]=1;//这里不能省
		dfs(u+1,now+1);
		a[u]=0;
		vis[now+1]=0;
	}
}
int main()
{
	cin>>n;
	cout<<qwq[n]<<' ';
	num=qwq[n-1];
	vis[0]=1;
	dfs(n+1,0);//划重点：从n+1位开始搜索并且vis[0]应设置为1。
	return 0;
}
```

感谢您看到这里 sto orz。

---

## 作者：Ame_wiki (赞：2)

题目传送门：[link。](https://www.luogu.com.cn/problem/P10950)

题意：让你构造一个最长且字典序最小的 $01$ **环串**使得以每个点做起点得到的长度为 $K$ 的 $01$ 串互不相同。

长度为 $K$ 的 $01$ 串有 $2^K$ 种不同的形态。那么第一问直接输出就好了。

考虑构造，最朴素的想法无非就是暴力枚举字符串形态然后判断。复杂度 $O(2^{2^K})$，太高了。

因为要求字典序最小，这个串的前 $K-1$ 位一定为 $0$，可以证明这样一定有解。我们发现从第 $K$ 位开始，每个数只可能是在数的后 $K-1$ 位后面补一个 $0$ 或 $1$ 形成的。那么直接暴搜下一个数的情况。由于每条边最多只会被遍历一次所以过。

### code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
#define lowbit(x) (x&(-x))
#define sort stable_sort

const int N=1145140+1919810,M=5005,inf=1e18;

int k,ans[N],vis[N],n;

int dfs(int x,int dep){
	if(vis[x]) return 0;
	if(dep==n+1) return 1;
	vis[x]=1;
	ans[dep]=x%2;
	if(dfs((x<<1)&n,dep+1)) return 1;
	if(dfs((x<<1|1)&n,dep+1)) return 1;
	vis[x]=0;
	return 0;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>k;
	n=(1<<k)-1;
	cout<<n+1<<" ";
	dfs(0,1);
	for(int i=1;i<k;i++) cout<<0;
	for(int i=1;i<=n-k+2;i++) cout<<ans[i];
	return 0;
}


```

---

## 作者：违规用户名720023 (赞：1)

# P10950 太鼓达人

[原题在此](https://www.luogu.com.cn/problem/P10950)

## 题目分析

题意很简单，需要你生成一个环形 01 串，使得从任意位置截取长度为 $k$ 的子串得到的结果均不同。求这个串长度 $M$ 的最大值和使得这个串长度最大的**字典序最小**的 01 串。

全部的数据满足 $2 \le k \le 11$。

## 实现方法

由于长度为 $k$ 的 01 串共有 $2^k$ 个，我们希望 $M$ 取到 $2^k$。（这里应该会有人有疑问，为什么一定可以取到？这个问题我们稍后再说。）

考虑暴力枚举长度为 $2^k$ 的 01 串每个位置为 $1$ 还是 $0$，据测试只能解决 $k \le 4$ 的情况。

代码：
```cpp
void dfs(int stp, int n)
{
	if(stp > n)
	{
		for(int i = 1; i < k; i++) w[n + i] = w[i];
        memset(h, 0, sizeof(h));
		int numm = 0;
		for(int i = k + 1; i < n + k; i++)
		{
			numm = 0;
			for(int j = i - k; j < i; j++) numm += w[j] * (1 << (i - j - 1));
			h[numm]++;
		}
		for(int i = 0; i < n; i++)
		{
			if(!h[i]) return;
		}
		for(int i = 1; i <= n; i++) ans[i] = w[i];
	}
	dfs(stp + 1, n);
	w[stp] = 1;
	dfs(stp + 1, n);
	w[stp] = 0;
}
```

这份代码无法通过。

发现可以尝试剪枝，在 dfs 过程中判断有没有出现重复，可以通过 $k \le 5$ 的情况。继续剪枝，因为枚举是 0 优先的，找到的第一个可行的构造就是字典序最小的，不需要继续。

代码：

```cpp
#include <iostream>
#define int long long
using namespace std;
int k;
int h[10010];
bool ans[10010];
bool f;
bool w[10010];
void dfs(int stp, int n)
{
//	for(int i = 1; i <= stp; i++) cerr << w[i] << " ";
//	cerr << endl;
	int num = 0;
	if(stp > k)
	{
		for(int i = stp - k; i < stp; i++) num += w[i] * (1 << (stp - i - 1));
		if(h[num]) return;
		else h[num]++;
	}
	if(stp > n)
	{
		if(f) return;
		for(int i = 1; i < k; i++) w[n + i] = w[i];
		int numm = 0;
		for(int i = n + 1; i < n + k; i++)
		{
			numm = 0;
			for(int j = i - k; j < i; j++) numm += w[j] * (1 << (i - j - 1));
			h[numm]++;
		}
		for(int i = 0; i < n; i++)
		{
			//cerr << h[i] << endl;
			if(!h[i]) return;
		}
		f = 1;
		for(int i = 1; i <= n; i++) ans[i] = w[i];
	}
	dfs(stp + 1, n);
	w[stp] = 1;
	if(f) return;
	dfs(stp + 1, n);
	w[stp] = 0;
	h[num]--;
}
signed main()
{
	cin >> k;
	cout << (1 << k) << " ";
	int t = 1 << k;
	dfs(1, t);
	for(int i = 1; i <= t; i++) cout << ans[i];
	return 0;
}
```

这里可以解释为什么 $M$ 等于 $2^k$ 了。原理很简单，发现如果无解，最后的输出构造会是一堆 0，但是根据测试，$2 \le k \le 11$ 时没有出现这种情况，所以证毕。

~~实践决定真理~~

---

## 作者：thh_loser (赞：1)

# P10950 太鼓达人

[题目链接](https://www.luogu.com.cn/problem/P10950)

## 题意

给定数 $k$，求长度为 $m$ 的 $01$ 环型串，使得任一位置开始 $k$ 位构成的 $01$ 子串都不同。



# 思路

要让 $m$ 最长，我们考虑让 $2^{k}$ 个子串都被包含其中，因为每两个相邻的包含重复的 $k-1$ 长度，于是总长度 $m$ 即为 $2^{k}$。



至于如何构造 $01$ 串，我们考虑贪心的方法，因为题目要求字典序最小，我们考虑尽量让 $0$ 在前面，然后我们储存已经出现过的串，每次考虑当前位，如果 $0$ 能够放在该位，则放 $0$，否则放 $1$。



## code

```c++
#include<bits/stdc++.h>
using namespace std;
int a[1000010],x,po,po1,flag=1;
unordered_map<int,int>ma;
void dfs(int pos,int js){
	if(pos>=po-x+1)return;
	int now=js-((js>>(x-1))?1:0)*po1;
	if(ma.find(now*2)==ma.end()){//能够放0就放 
		cout<<0;
		ma[now*2]=1; 
		dfs(pos+1,now*2);
	}
	else{//否则放1 
		cout<<1;
		ma[now*2+1]=1;
		dfs(pos+1,now*2+1);
	}
}
int main(){
	cin>>x;
	po=pow(2,x);
	po1=pow(2,x-1);
	cout<<po<<" ";//长度即为2的x次方 
	for(int i=1;i<=x;i++){
		a[i]=0;
		cout<<0;
	}
	int ker=0;
	ma[ker]=1;
	for(int i=x;i>=1;i--){
		a[po-i+1]=1;
		ker+=(1<<(i-1));
	//	cout<<ker<<endl;
		ma[ker]=1;
	}
	dfs(x+1,0);
	for(int i=1;i<=x;i++)cout<<1;
	return 0;
}

```

---

## 作者：MnZnOIer (赞：0)

看到题面的时候，心里面想：肯定是二进制推式子。手里的笔都提起来了，但是看到数据范围我乐了，这不是随便搞都能过的暴搜题吗？

这题评绿有点过，~~建议降橙~~。

### 解题思路
我们知道，每一位有 $2$ 种可能：放 $1$ 或放 $0$，那么传感器最多会返回 $2^K$ 种 01 串，所以最大的长度 $M=2^K$。

为了避免重复，我们可以用一个数组来记录已经有过的 01 串的值。对于每一位，如果能放 $0$ 肯定要放 $0$，放不了 $0$ 再放 $1$。

那么 dfs 就很好写了。

### 代码部分

```cpp
#include <bits/stdc++.h>
using namespace std;
int k, m, a[114514], mod;
bool vis[114514];
void dfs (int d, int s)
{
    //已经放完了前 m-1 位，最后一位要放 1。因为如果不能尾接首的生成 01 串，就没有 M 个 01 串。不能有第二次全 0 的串，所以最后一位要放 1。
	if (d == m)
	{
		a[m] = 1;
		for (int i = 1; i <= m; ++ i)cout << a[i];
		exit (0);//当前生成的 01 串一定是最优的，所以直接结束。
	}
	int f = k - d;
	s %= mod;//先把第 1 位去掉。
	s <<= 1;//然后再整体左移。
	if (! vis[s])//放 0，不增加。
	{
		vis[s] = 1;
		dfs (d + 1, s);
		vis[s] = 0;
	}
	++ s;//放 1，增加。
	if (! vis[s])
	{
		vis[s] = 1;
		a[d] = 1;
		dfs (d + 1, s);
		vis[s] = 0;//要回溯标记。
	}
}
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> k;
	m = 1 << k;
	cout << m << ' ';
	mod = m >> 1;//2 的 k-1 次方，用来去掉第 1 位。
	vis[0] = 1;//记得打上全 0 的标记。
	dfs (k + 1, 0);//因为前 k 个肯定全放 0，所以直接从第 k+1 位开始放。
	return 0;
}
```

---

## 作者：dutianchen1 (赞：0)

# 太鼓达人

### 思路简析

题意还是比较清晰，就是希望构造出一个字典序最小的序列，使得这个序列形成环之后，长度为 $k$ 的 `01`串都出现且仅出现过一次。

因为 $k \le 11$，也就是说整个串最长长度也不大于 $2\times10^3$。我们可以模拟求解。

为了字典序最小，肯定先把最小的串（长度为 $k$ 的零串）放在答案串的最前面。

接下来，我们考虑每一位放 $0$ 还是 $1$ 即可。

为了保证每个串都只出现一次，我们提前预处理一遍所有可能的串，每次枚举不同可能的新串时检查一下出现过没有即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
ll k,len,n;
set<string> s;
string ans,a,b,c;
void solve(){
	k=read();
	cout<<pow(2,k)<<' ';
	n=(1<<k);
	for(int i=1;i<=k;i++)a+="0";
	for(int i=1;i<=k;i++)c+="1";
	ans=a;b=a;
	s.insert(ans);
	for(int i=1;i<=k;i++){
		s.insert(c);
		c.erase(c.begin());//滚动插入 
		c+="0";
	}
	for(int i=k+1;i<=n;i++){
		s.insert(a);
		a.erase(a.begin());
		b=a+"0";
		if(s.find(b)==s.end())
		{
			s.insert(b);
			a=b;
			ans+="0";
		}
		else{
			b=a+"1";
			s.insert(b);
			a=b;
			ans+="1";
		}
	}
//	ans+="1";
	cout<<ans;
}
int main()
{
	ll T=1;
	while(T--)solve();
	return 0;
}

```

---

## 作者：JimmyLee (赞：0)

# 分析

显然答案包含长度为 $K$ 的所有 $01$ 串，每个串和前一个的重叠长度为 $K-1$，所以每个串对长度的贡献为 $1$。

因此该串的长度为所有 $01$ 串的个数，即 $2^K$。

---

考虑第二个如何解决。

发现每个位置的状态只有 $0$ 和 $1$，考虑爆搜。

显然直接搜的复杂度为 $O(2^{2^K})$，不能通过本题。

考虑剪枝，如果搜索中当前的串不符合条件，那么直接返回。

这样就能通过本题。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005

string ans, tmp;
bool vis[1<<12];

int to_int(string s)
{
    int ret=0;
    for(auto c:s) ret=(ret<<1)|(c^48);
    return ret;
}

bool chk(int k)
{
    tmp=ans+ans;
    int n=ans.size();
    memset(vis, 0, sizeof vis);
    for(int i=0;i<n;i++)
    {
        int r=to_int(tmp.substr(i, k));
        if(vis[r]) return 0;
        vis[r]=1;
    }
    return 1;
}

bool chk1(int k)
{
    tmp=ans;
    int n=ans.size();
    memset(vis, 0, sizeof vis);
    for(int i=0;i<n-k;i++)
    {
        int r=to_int(tmp.substr(i, k));
        if(vis[r]) return 0;
        vis[r]=1;
    }
    return 1;
}

void dfs(int p, int k)
{
    if(!chk1(k)) return;
    if(p==(1<<k)) 
    {
        if(chk(k)) cout<<ans, exit(0);
        return;
    }
    ans+='0';
    dfs(p+1, k);
    ans.pop_back();
    ans+='1';
    dfs(p+1, k);
    ans.pop_back();
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int k;
    cin>>k;
    cout<<(1<<k)<<' ';
    dfs(0, k);
}
```

---

## 作者：Tachibana27 (赞：0)

直接搜就好了，没有任何思维含量。

~~所以直接上代码（bushi。~~

注意到直接搜然后到达终止状态取最优的做法复杂度是很劣的，那么不妨考虑直接让搜索状态做到最优，这样到达终止状态可以直接输出，优化了复杂度。

对于第一问，最大值显然为 $2^k$。而对于第二问，我们只要让它在搜索中优先填入 $0$，这样就能使得状态最优。

code：

```cpp


int n;
bool vis[100086];
int a[1000086];
void dfs(int id,int x){
	if(id>(1<<n)){
		for(int i=1;i<id;i++)
			std::cout<<((i==id-1)?1:a[i]);//输出
		exit(0);//真正的撒花在这里
	}
	x=(x%(1<<(n-1))<<1);//取出2^(k-1)位并给下一位挪位置
	if(not vis[x]){
		vis[x]=true;
		a[id]=0;
		dfs(id+1,x);
		vis[x]=false;
	}//优先搜0
	if(not vis[x bitor 1]){
		vis[x bitor 1]=true;
		a[id]=1;
		dfs(id+1,x bitor 1);
		vis[x bitor 1]=false;
	}
	return;
}
int main(){
	std::cin>>n;
	std::cout<<(1<<n)<<" ";//第一问
	vis[0]=true;//特别的，啥也不填的状态要视为访问过
	dfs(n+1,0);//前k位必然为0 
	return 0;//假的撒花
}
```

---


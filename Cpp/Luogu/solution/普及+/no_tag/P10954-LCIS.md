# LCIS

## 题目描述

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们要研究最长公共上升子序列了。

小沐沐说，对于两个串 $A$，$B$，如果它们都包含一段位置不一定连续的数字，且数字是严格递增的，那么称这一段数字是两个串的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。
    
奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。不过，只要告诉奶牛它的长度就可以了。

## 说明/提示

$1\le N \le 3000$，$0\leq |A_i|,|B_i| \leq 10^6$。

## 样例 #1

### 输入

```
4
2 2 1 3
2 1 2 3```

### 输出

```
2```

# 题解

## 作者：light_searcher (赞：8)

首先，肯定是 dp。

设 $f_{i,j}$ 表示 $a$ 序列的前 $i$ 个数和 $b$ 序列中前 $j$ 个数且以 $b_j$ 为结尾的最长上升公共子序列，这里要注意 **$a_i$ 不一定是结尾**。

为什么设一个这么奇怪的状态呢？我们可以想想其他状态。如果是以 $a_i$ 为结尾且 $b_j$ 为结尾，那么这个状态应该是错误的，因为我们无法保证 $a_i = b_j$。那么如果是 $a$ 的前 $i$ 个数和 $b$ 的前 $j$ 个数呢？你可以自己想想如何转移，反正我觉得这是极其复杂的。那么由此看来上文的状态应该是一个好的选择。

接下来进入正题，考虑如何转移。

分类讨论：

- $a_i \ne b_j$：因为以 $b_j$ 为结尾，所以把 $a_i$ 去掉不会有任何影响，所以 $f_{i,j}=f_{i-1,j}$。
- $a_i = b_j$：只需要在前面找到一个可以把 $b_j$ 接上去的最长公共上升子序列即可。$f_{i,j}= \max\{f_{i-1,k}\}+1$，其中 $1 \le k <j$ 且 $b_k <b_j$。

最后答案是 $\max \{ f_{i,j} \}$。

那么已经有了一个 $\mathcal O(n^3)$ 的做法。

Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e3+5;
int n,a[N],b[N],f[N][N],ans;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(a[i]!=b[j]) f[i][j]=f[i-1][j];
			else{
				int mx=0;
				for(int k=1;k<j;k++)
					if(b[k]<b[j]) mx=max(mx,f[i-1][k]);
				f[i][j]=mx+1;
			}
			ans=max(ans,f[i][j]);
		}
	printf("%lld",ans);
	return 0;
}
```

结果这么写常数很小，直接跑过了。

但是还是考虑继续优化。发现当 $a_i =b_j$ 时由于 $j$ 枚举时 $i$ 不会变，所以如果 $b_k < a_i$，那么 $f_{i-1,k}$ 就可以纳入到决策集合中，我们最终要用的是决策集合中的最大值，而这个值显然是只增不降的，那我们在枚举 $j$ 的同时就可以完成对这个值的维护。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+5;
int n,a[N],b[N],f[N][N],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=n;i++){
		int val=0;
		for(int j=1;j<=n;j++){
			if(a[i]!=b[j]) f[i][j]=f[i-1][j];
			else f[i][j]=val+1;
			if(b[j]<a[i]) val=max(val,f[i-1][j]);
			ans=max(ans,f[i][j]);
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：SMall_X_ (赞：8)

[原题传送门](https://www.luogu.com.cn/problem/P10954)

---

## 思路分析

dp。

先考虑设 $f_{i,j}$ 表示 $a$ 的前 $i$ 个数和 $b$ 的前 $j$ 个数的 LCIS 的长度，但发现这样不好转移，我们可以考虑设 $f_{i,j}$ 表示 $a$ 的前 $i$ 个数且以 $b_j$ 结尾的 LCIS 的长度。

考虑状态转移，有两种情况：

- 当 $a_i\ne b_j$，我们不能选 $a_i$（因为序列以 $b_j$ 结尾，所以 $b_j$ 必须选），答案为 $f_{i-1,j}$。

- 当 $a_i=b_j$ 时，我们枚举 $b$ 之前可能的结尾，检查能不能把 $a_i$ 加入，如果可以，答案就是 $\max\{f_{i-1,k}+1\}$

答案很明显是 $\max\{f_{i,j}\}$。

时间复杂度是 $O(n^3)$，$n\leq 3\times10^3$，容易超时，正解在后面。


```cpp
for(int i=1;i<=n;i++){
	int maxn=0;
	for(int j=1;j<=n;j++){
		f[i][j]=f[i-1][j];
		if(a[i]==b[j]){
			int maxn=1;
			for(int k=1;k<j;k++){
				if(a[i]>b[k]){
					maxn=max(maxn,f[i-1][k]+1);
				}
			}
			f[i][j]=max(f[i][j],maxn);
		}
	}
}
```

考虑优化，不难发现因为 $f_{i,j}\ge{f_{k,j}}_{ k\in (1,i-1)}$ ，所以求得的 $maxn$ 是满足 $a_i\ne b_k$ 的 $f_{i-1,k}+1$ 的前缀最大值，其中 $k\in [1,j-1]$。

所以可以直接将第三重循环删去，改成递推求前缀最大和，如此可以减少重复计算。

答案是 $\max\{f_{n,i}\}$。

时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$。

## $\texttt{code}$

```cpp
/*Written by smx*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=3e3+5,inf=1e9;
int n,m,ans;
int a[MAXN],b[MAXN],f[MAXN][MAXN];
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){
		int maxn=0;
		for(int j=1;j<=n;j++){
			if(a[i]!=b[j]){
				f[i][j]=f[i-1][j];
			}else{
				f[i][j]=maxn+1;
			}
			if(b[j]<a[i]){
				maxn=max(maxn,f[i-1][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,f[n][i]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Alvin0228 (赞：4)

### 题意描述

求出两个串的最长公共上升子序列。

### 题目分析

考虑一种朴素方法。

设 $f_{i,j}$ 代表以 $a_i$，$b_j$ 为末尾的最长公共上升子序列，那么我们就可以写出以下转移方程：

$$
f_{i,j} = \begin{cases}
\max_{k\in[0,j)}\{f_{i−1,k}+1\} ,& a_i=b_j\\
f_{i-1,j} ,& \text{otherwise.}
\end{cases}
$$

但是时间复杂度是 $O(n^3)$ 的，显然过不了，考虑优化。

因为 $f_{i,j}$ 是由 $f_{i,k}$ 推过来的，所以我们可以在遍历 $i$，$j$ 的同时，记录 $f_{1,i-1}$ 和 $f_{1,j-1}$ 匹配的最优位置，当 $a_i=b_j$ 的时候直接取这个位置即可。

时间复杂度变成 $O(n^2)$ 的了，完全可过。

上述存最优方案的方法在做动态规划的优化时比较常见，如果遇到需要将复杂度降低一级的时候可以使用。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5005],b[5005],f[5005][5005];
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
	}
	int ans=-1,bes;
	for(int i=1;i<=n;i++)
	{
		bes=f[i-1][0];//保存新的bes值 
		for(int j=1;j<=n;j++)
		{
		    if(a[i]==b[j])
			{
				if(bes+1>f[i][j])
				{
					f[i][j]=bes+1;//状态转移 
				}
		    }
		    else f[i][j]=f[i-1][j];
		    ans=max(ans,f[i][j]);//ans每次都要更新 
		    if(b[j]<a[i]) bes=max(bes,f[i-1][j]);//更新bes 
		}
	}	
	cout<<ans;
	return 0;
}
```

---

## 作者：jinfanhao (赞：3)

一道很有价值的动态规划。

# 75 分

先考虑一个部分分做法。\
先设计动态规划数组。$dp_{i,j}$ 其中 $i$ 表示 $A_i$,$j$ 表示 $B_j$，就是以 $B_j$ 结尾的最长公共上升子序列答案的最大值。\
先考虑 $A_i=B_j$，这就是加入 $A_i$, 可以放在 $A_i>B_j$ 的后面，也可以新起一个，这里当然要选择最优的方法，就是最大的了。\
再考虑不相同，这里就是不加入 $A_i$, 答案就是上一个以 $B_j$ 结尾的结果，$dp_i-1,j$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+1;
int n,op[N],x[N],y[N],dp[N][N],maxx;
signed main(){
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)scanf("%d",&x[i]);
	for(int i=1; i<=n; ++i)scanf("%d",&y[i]);
	for(int i=1; i<=n; ++i){
		for(int j=1; j<=n; ++j){
			if(x[i]==y[j]){
				bool ok=true;
				for(int k=1; k<=j; ++k){
					if(x[i]>y[k]){
						dp[i][j]=max(dp[i][j],dp[i][k]+1);
						ok=false;
					}
				}
				if(ok)dp[i][j]=max(dp[i][j],1);
			}
			else dp[i][j]=dp[i-1][j];
		}
	}
	for(int i=1; i<=n; ++i){
		for(int j=1; j<=n; ++j)maxx=max(maxx,dp[i][j]);
	}
	printf("%d",maxx);
	return 0;
}
```

# 100 分

可以把相同时暴力寻找 $A_i>B_j$ 的放在循环内同时处理，就是用一个变量，如果 $A_i>B_j$ 就与其取最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+1;
int n,x[N],y[N],maxx,dp[N][N];
signed main(){
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)scanf("%d",&x[i]);
	for(int i=1; i<=n; ++i)scanf("%d",&y[i]);
	for(int i=1; i<=n; ++i){
		int ans=0;
	 	for(int j=1; j<=n; ++j){
	 		if(x[i]==y[j])dp[i][j]=max(dp[i][j],ans+1);
			else dp[i][j]=dp[i-1][j];
			maxx=max(maxx,dp[i][j]);
			if(y[j]<x[i])ans=max(ans,dp[i-1][j]);
		}
	}
	printf("%d",maxx);
	return 0;
}
```

---

## 作者：bz029 (赞：2)

### 思路

根据前几篇题解的思路，设 $dp_{i,j}$ 指 $a_1$ 至 $a_i$ 和 $b_1$ 至 $b_j$ 的最长公共上升子序列，发现 $dp_{i,j}(a_i=b_j)$ 是从 $dp_{k,o}(a_k=b_o,1\le k\le i,1\le o\le j,a_k<a_i)$ 转移来的。

有 $3$ 个范围，通过循环，可以砍掉 $1\le k\le i$ 这个限制，剩下的就可以用二维树状数组来维护前缀最大。

时间复杂度：$O(n^2 \times \log^2n)$。

### 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) x&(-x)
using namespace std;
const int N=6e3+5;

int n,a[N],b[N],c[N],t[N][N];

//二维树状数组 
void add(int d,int x,int y){
	if(x==0) return ;
	for(;d<=n;d+=lowbit(d)){
		for(int i=x;i<=n*2;i+=lowbit(i)){
			t[d][i]=max(t[d][i],y);
		}
	}
	
}

int que(int d,int x){
	int sum=0;
	for(;d;d-=lowbit(d)){
		for(int i=x;i;i-=lowbit(i)){
			sum=max(sum,t[d][i]);
		}
	}
	return sum;
}

signed main(){ 
	//输入 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		c[i]=a[i];
	} 
	for(int i=1;i<=n;i++){
		cin>>b[i];
		c[i+n]=b[i];
	} 
	//离散化 
	sort(c+1,c+n*2+1);
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(c+1,c+n*2+1,a[i])-c;
	} 
	for(int i=1;i<=n;i++){
		b[i]=lower_bound(c+1,c+n*2+1,b[i])-c;
	} 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i]==b[j]){
				int x=que(j,a[i]-1);//查询前缀最大 
				int y=x+1;
				int z=a[i];
				add(j,z,y);//更新
			}
		}
	}
	cout<<que(n,2*n);
	
	return 0;
}


```
[记录](https://www.luogu.com.cn/record/212745515)

管理求过

---

## 作者：lzt415 (赞：1)

# 题目大意
求两个序列的最长公共子序列
# 思路
$\operatorname{O}(n^3)$ 做法 :

首先设 $f_{i, j}$ 表示以第一个数组第 $i$ 个元素，第二个数组第 $j$ 个元素结尾时的最长公共上升子序列。则易推出：

$f_{i, j} = \begin{cases}
  a_{i} = b_{j}& f_{i, j}= \max(f_{i, j},f_{i-1, k}+1)\\
  a_{i} \ne b_{j}& f_{i, j}=f_{i-1, j}\\
\end{cases}$

这样显然会超时，那么考虑优化。

$\operatorname{O}(n^2)$ 做法:

思考去掉第三层循环。

在 $\operatorname{O}(n^2)$ 做法的代码中，最能删去的是第三层循环。这个循环要找的是 $k$ 从 $0$ 到 $j-1$ 中，最大的 $f_{i, j}$。但是在循环 $j$ 的时候，$i$ 是定值了。思考 $j$ 和 $j+1$ 时,$k$ 循环的变化。如果 $j+1$ 的话，$k$ 循环会从 $0-j+1$。并且循环内的状态转移不会变。所以从 $j$ 到 $j+1$ 重复运行循环里面的赋值代码。我们事实上可以用一个变量来存储前 $j$ 个最大的 $f_{i, j}$。这样直接省去了 $k$ 这一层循环。

---

## 作者：hinin (赞：0)

[更好的阅读体验](https://www.cnblogs.com/hinin/articles/18691751)。

### 思路

$f_{i, j}$ 代表所有 $a_{1 \cdots i}$ 和 $b_{1 \cdots j}$ 中以 $b_j$ 结尾的公共上升子序列的集合，其值等于该集合的子序列中长度的最大值。

状态转移方程：
 * 不包含 $a_i$ 的子集，最大值是 $f_{i - 1,j}$。

 * 包含 $a_i$ 的子集，将这个子集继续划分。

三重循环，明显 TLE。

发现自己代码求的是前缀最大值，减少重复计算，此时只剩下两重循环。

记录原先位置，复原输出顺序即可。

### 代码

``` cpp
#include <bits/stdc++.h>
// #pragma GCC optimize("Ofast", "-funroll-all-loops")
#define ll long long 
#define pii pair<int, int>
 
#define y1 gigay 
#define x first 
#define y second 
 
using namespace std;

const int N = 3e3 + 1;
int n, a[N], b[N], f[N][N];

int main() 
{
	ios::sync_with_stdio(false); 
	cin.tie(nullptr); 

	cin >> n;
	for (int i = 1; i <= n; i ++) { cin >> a[i]; }
	for (int i = 1; i <= n; i ++) { cin >> b[i]; }
	
	for (int i = 1; i <= n; i ++) {
		int Max = 1;
		for (int j = 1; j <= n; j ++) {
			f[i][j] = f[i - 1][j];
			if (a[i] == b[j]) { f[i][j] = max(f[i][j], Max);   }
			if (b[j] < a[i]) { Max = max(Max, f[i - 1][j] + 1);  }
		}
	}
		
	int ans = INT_MIN;
	for (int i = 1; i <= n; i ++) { ans = max(ans, f[n][i]); }
	cout << ans << endl;

	return 0;
}
```

---

## 作者：mirance2025 (赞：0)

## Solution

这道题目是最长上升子序列和最长公共子序列的结合版，在状态表示和状态计算上都是融合了这两道题目的方法。

状态表示：

- $f_{i, j}$ 代表所有 $a_i$ 和 $b_j$ 中以 $b_j$ 结尾的公共上升子序列的集合；
- $f_{i, j}$ 的值等于该集合的子序列中长度的最大值；

状态计算（对应集合划分）：

首先依据公共子序列中是否包含 $a_i$，将 $f_{i, j}$ 所代表的集合划分成两个不重不漏的子集：

- 不包含 $a_i$ 的子集，最大值是 $f_{i - 1, j}$；
- 包含 $a_i$ 的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在 $b$ 中是哪个数：

  - 子序列只包含 $b_j$ 一个数，长度是 $1$；
  - 子序列的倒数第二个数是 $b_1$ 的集合，最大长度是 $f_{i - 1, 1} + 1$；
  - $\dots$
  - 子序列的倒数第二个数是 $b_{j - 1}$ 的集合，最大长度是 $f_{i - 1, j - 1} + 1$。

如果直接按上述思路实现，需要三重循环：
```cpp
for (int i = 1; i <= n; i ++ ){
    for (int j = 1; j <= n; j ++ ){
        f[i][j] = f[i - 1][j];
        if (a[i] == b[j]){
            int maxv = 1;
            for (int k = 1; k < j; k ++ )
                if (a[i] > b[k])
                    maxv = max(maxv, f[i - 1][k] + 1);
            f[i][j] = max(f[i][j], maxv);
        }
    }
}
```
然后我们发现每次循环求得的 $maxv$ 是满足 $a_i > b_k$ 的 $f_{i - 1, k} + 1$ 的前缀最大值。
因此可以直接将 $maxv$ 提到第一层循环外面，减少重复计算，此时只剩下两重循环。

最终答案枚举子序列结尾取最大值即可。

## 时间复杂度
代码中一共两重循环，因此时间复杂度是 $O(n^2)$。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];

int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &b[i]);

    for (int i = 1; i <= n; i ++ ){
        int maxv = 1;
        for (int j = 1; j <= n; j ++ ){
            f[i][j] = f[i - 1][j];
            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);
            if (a[i] > b[j]) maxv = max(maxv, f[i - 1][j] + 1);
        }
    }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res = max(res, f[n][i]);
    printf("%d\n", res);

    return 0;
}
```
管理员，哪里有多余的空格，没看出qwq

---

## 作者：時空 (赞：0)

[Link](https://www.luogu.com.cn/problem/P10954)

[双倍经验](https://www.luogu.com.cn/problem/cf10d)

经典题了。

记 $dp_{i,j}$ 表示与 $A$ 中前 $i$ 个数匹配，且以 $b_j$ 结尾的 LCIS 的长度。

那么 

1. 若 $A_i \ne B_j$，$f_{i,j} = f_{i-1,j}$。
2. 若 $A_i = B_j$，$f_{i,j} = \max\{f_{i-1,k}+1\}$，其中 $0 \le k \le j-1, B_k < A_i$。

方程应该很好理解，但是这样是 $\mathcal{O(n^3)}$ 的，无法通过。

考虑如何优化。

转移过程中，令满足 $0 \le k \le j-1, B_k < A_i$ 的 $k$ 的集合为 $f_{i,j}$ 的决策集合，记为 $S_{i,j}$。

注意到在循环 $j$ 时，$i$ 为定值，即 $B_k < A_i$ 是固定的。考虑当 $j$ 自增时，$k$ 的范围由 $0 \sim j-1$ 变成了 $0 \sim j$，显然有重复。此时只需要 $\mathcal{O(1)}$ 的检查 $B_j < A_i$ 是否成立即可。

复杂度降至 $\mathcal{O(n^2)}$。

```cpp
ll n;
ll A[N], B[N];
ll f[N][N];

// f[i][j] 匹配了前 i 个数，以 B_j 为结尾 

signed main()
{	
	cin >> n;
	for (ll i = 1; i <= n; ++ i ) cin >> A[i];
	for (ll i = 1; i <= n; ++ i ) cin >> B[i];
	for (ll i = 1; i <= n; ++ i )
	{
		ll v0 = 0;
		for (ll j = 1; j <= n; ++  j )
		{
			if (A[i] != B[j]) f[i][j] = f[i - 1][j];
			if (A[i] == B[j]) f[i][j] = v0 + 1;
			
			if (B[j] < A[i]) v0 = max(v0, f[i - 1][j]);
		}
	}
	ll tt = 0;
	for (ll i = 1; i <= n; ++ i )
		for (ll j = 1; j <= n; ++ j )
			tt = max(tt, f[i][j]);
	cout << tt << '\n';
}
```

---

## 作者：Statax (赞：0)

## P10954 LCIS Solution

### 前言

~~疑似题解最可爱马蜂~~。

### 题义分析

顾名思义，求两个序列的公共上升子序列。

### 题目解析

#### 状态表示

定义 $f_{i,j}$ 为 $A$ 数列中前 $i$ 个数字，$B$ 数列中前 $j$ 个数字，且以 $B_{j}$ 结尾的子序列的长度最大值。

#### 状态转移

1. 从 $A$ 数列中前 $i - 1$ 个数字，$B$ 数列中前 $j$ 个数字的方案转移：$f_{i,j} = f_{i - 1, j}$。
2. 从 $A$ 数列中前 $i$ 个数字，$B$ 数列中前 $k$ 个数字的方案转移：$f_{i,j}= \max (f_{i,j},(\max\limits_{k \in [0, j - 1], a_i = b_j, b_j > b_k} f_{i - 1, k} + 1))$。

综上得此算法时间复杂度为 $\Theta (n ^ 3)$，对于 $n \leq 5000$ 的数据毫无疑问会超时。

#### 优化

观察到对于第二种状态转移，每次用到的状态都是第 $i - 1$ 个阶段的。

由此，我们可以考虑前缀最大值，存储上一个阶段能满足条件的最大状态。

### 题目代码

```cpp
#include <iostream>
#include <cstdio>
#include <string.h>

#define endl '\n'
#define int long long
#define lowbit(x) x & (-x)

using namespace std;
const int N = 5e3 + 5;


int n;
int a[N], b[N], f[N][N];

// 初始化函数
void init() {
	
}

// 输入函数
void input() {
	cin >> n;
	for(int i = 1;i <= n; ++i) cin >> a[i];
	for(int i = 1;i <= n; ++i) cin >> b[i];
}

// 处理函数
void solve() {
	int Max;
	for(int i = 1;i <= n; ++i) {
		Max = 1; // 前缀最大值变量
		for(int j = 1;j <= n; ++j) {
			f[i][j] = f[i - 1][j];
			if(b[j] == a[i]) f[i][j] = max(f[i][j], Max);
			if(b[j] < a[i]) Max = max(Max, f[i - 1][j] + 1);
		}
	}
}

// 输出函数
void output() {
	int res = 0;
	for(int i = 0;i <= n; ++i) res = max(res, f[n][i]);
	cout << res << endl;
}

// 任务函数
void task() {
	input();
	solve();
	output();	
}

// 主函数
signed main() {
	int ___ = 1; 
	init(); while(___ --) task();
	return 0;
}
```

---


# 环路运输

## 题目描述

在一条环形公路旁均匀地分布着 $N$ 座仓库，编号为 $1 \sim N$，编号为 $i$ 的仓库与编号为 $j$ 的仓库之间的距离定义为 $dist(i,j)=\min⁡(|i-j|,N-|i-j|)$，也就是逆时针或顺时针从 $i$ 到 $j$ 中较近的一种。

每座仓库都存有货物，其中编号为 $i$ 的仓库库存量为 $A_i$。

在 $i$ 和 $j$ 两座仓库之间运送货物需要的代价为 $A_i+A_j+dist(i,j)$。

求在哪两座仓库之间运送货物需要的代价最大。

## 说明/提示

数据保证，$2 \le N \le 10^6$，$1 \le A_i \le 10^7$。

## 样例 #1

### 输入

```
5
1 8 6 2 5```

### 输出

```
15```

# 题解

## 作者：ivyjiao (赞：9)

看到绝对值先把它拆了，原式等价于：

$$dp_{i,j} = \begin{cases}
  a_i+a_j+i-j & j<i,i-j\leq \frac n 2 \\
  a_i+a_j+n+j-i & j<i,i-j>\frac n 2
\end{cases}$$

至于 $j\geq i$ 的情况，显然没有意义，因为我们只需要枚举 $j<i$ 的情况就可以得出答案。

然后看到环先把它拆成链，$n\gets n\times 2$。

那么原式的第二条也没有意义了，变为：

$$dp_{i,j} = a_i+a_j+i-j~~~~(j<i,i-j\leq \frac n 2)$$

所以我们要从前往后枚举，此时原式看起来像是单调队列优化，所以考虑变形（从前往后枚举）：

$$dp_i = \max\{a_j-j\}+a_i+i~~~~(i-j\leq \frac n 2)$$

好了，我们只需要维护 $\max\{a_i-i\}$ 就行了，后面的条件就是 pop 队头的条件，队头是最大的 $a_i-i$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+1;
int n,a[N],q[N],h,t,ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        a[i+n]=a[i];
    }
    for(int i=1;i<=n*2;i++){
        while(h<=t&&i-q[h]>n/2) h++;
        if(h<=t) ans=max(ans,a[i]+a[q[h]]+i-q[h]);
        while(h<=t&&a[q[t]]-q[t]<=a[i]-i) t--;
        q[++t]=i;
    }
    cout<<ans;
}
```

---

## 作者：OIer_ACMer (赞：4)

# 题目解析：

~~不是，哥们？~~

首先，我们不难发现，这道题可以用暴力拿 $60$ 分，对，真的是 $60$ 分。

之后，我们考虑优化，我们首先要拆环成链，之后，对于公路上任意两座仓库，其代价要分两种情况讨论，一方面，当 $i - j$ 小于等于 $n$ 的一半时，结果为 $a_i + a_j - j + i$，另外，当超过 $n$ 的一半时，因为是环，我们要考虑是否会越界，结果即为 $a_i + a_{j +n} + j + n - i$，因为对于其他可能，不会有最大值最小值，所以直接找规律，发现 $a_i - i$ 有单调性，我们用单调队列维护 $a_i - i$ 即可。

# 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[2000010];
deque<int> q;
int main()
{
    int n, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i + n] = a[i];
    }
    for (int i = 1; i <= 2 * n; i++)
    {
        while (q.empty() == 0 && i - q.front() > n / 2)
        {
            q.pop_front();
        }
        if (q.empty() == 0)
        {
            ans = max(ans, a[i] + a[q.front()] + i - q.front());
        }
        while (q.empty() == 0 && a[q.back()] - q.back() <= a[i] - i)
        {
            q.pop_back();
        }
        q.push_back(i);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：liuChF (赞：1)

暴力复杂度 $O(n^2)$，瓶颈在于每次找 $i$ 的最大代价，考虑这个东西能不能继承，经典 trick 破环成链，注意到同一个 $a_i-i$ 可能继续成为第 $j$ 个位置的备选答案，且答案的贡献 $a_i-i$ 具有单调性，所以用滑动窗口维护长度为 $n$ 的最大的 $a_i-i$ 就行了。

```cpp
#include <bits/stdc++.h>
#define LL long long
#define fq(i,d,u) for(int i(d); i <= u; ++i)
#define fr(i,u,d) for(int i(u); i >= d; --i)
using namespace std;
const int N = 2e6 + 10;
int n, a[N], q[N], ans;
int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	fq(i, 1, n) cin >> a[i], a[i + n] = a[i];
	int l = 1, r = 0, len = (n + 1) / 2;
	fq(i, 1, n << 1) {
		while (l <= r && q[l] <= i - len) l++;
		ans = max(ans, a[i] + a[q[l]] + i - q[l]);
		while (l <= r && a[q[r]] - q[r] <= a[i] - i) r--; // 注意是 a[i] - i 的最大值
		q[++r] = i;
	}
	cout << ans << '\n';
	return 0;
}
```

###

---

## 作者：Wangzehao2009 (赞：1)

首先环上的问题我们很自然地想到断环成链。于是我们复制一遍 $1$ 到 $N$ 的每一个仓库，$A_{N+i}=A_i$，形成一个长度为 $2N$ 的直线。

我们要最大化的是 $A_i+A_j+dis(i,j)$，不妨令 $i>j$，转化一下就是最大化 $A_i+A_j+i-j$。

$A_i+i$ 的值固定，我们发现与 $j$ 有关的只有 $A_j-j$ 了，我们的目标就变成 $\max(A_j-j)$ 了。但是要注意，$j$ 的取值范围是有限制的。由于是走最短路径，所以 $i-j>\frac{N}{2}$ 肯定不优，所以我们不难确定 $j \in [\max(1,j-\frac{N}{2}),i-1]$。这个东西已经可以用线段树做了，复杂度是 $O(n \log{n})$。

单调队列可以做到更优秀的复杂度。我们维护一个 $A_i-i$ 单调递减的队列。设队首的下标为 $j$，如果 $i-j>\frac{N}{2}$ 我们就把它从队首弹出，计算出 $i$ 时的答案 $A_i+i+A_j-j$，在把 $i$ 加进队尾的同时维护整个队列的单调性即可。最后答案就是在每个位置的答案取最大值。每个元素最多入队一次出队一次，所以复杂度是 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define f(x) (a[(x)]-(x))
using namespace std;
int const N=1e6+3;
int n,a[N<<1],ans;
deque <int> q;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]),a[i+n]=a[i];
    for(int i=1;i<=(n<<1);++i)
    {
        while(!q.empty() && i-q.front()>n/2) q.pop_front();
        if(!q.empty()) ans=max(ans,a[i]+i+f(q.front()));
        while(!q.empty() && f(q.back())<=f(i)) q.pop_back();
        q.push_back(i); 
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：mirance2025 (赞：1)

### 题目描述
众所周知，一位 OIer 应当把题目读 3 遍。

简化一下题意：

环上有 $N$ 个点，每个点有点权 $A_i$，相邻仓库距离为 $1$，任意两点 $i, j$，之间的距离定义为沿环的两侧分别从 $i$ 前往 $j$ 的距离中的较小值。定义任意两点 $i,j$，之间的代价为 $A_i + A_j + dis_{i,j}$，求环上最大代价。

### 题意分析 + solution
本题为环状模型，处理起来有一定难度。处理环状模型有两种常用方法：分类讨论与断环为链。下面介绍断环为链的思想。

断环为链的思想可以简述为：对于一个长度为 $N$ 的环，我们不妨将其断开并延长一倍，使之变成一条长度为 $2N$ 的链，并将其划分为若干部分分别考虑。

$f_{i, j} = \begin{cases} 
   A_i + A_j + i - j & (j < i, i - j \leq \frac{N}{2}) \\
   A_i + A_j + N + j - i & (j < i, i - j > \frac{N}{2})
\end{cases}$

在断环为链之后，该算式等价于：在长度为 $2N$ 的链上，$f_{i, j} = A_i + A_j + i - j (j < i, i - j \leq \frac{N}{2})$。

此时，本题转化为了标准的线性 DP。
下面我们考虑如何求解该线性模型。如果按照上文推出的算式进行 DP，我们需要一维枚举 $i$，一维枚举 $j$，总时间复杂度为 $O(N^2)$。本题中 $N \leq 10^6$，这样的复杂度无法令人满意。考虑优化。

继续观察算式，我们发现该算式可以转化为如下形态：

$f_{i, j} = max{(A_j - j) + (A_i + i)}(j < i, i - j \leq \frac{N}{2})$。
其中，当 $i$ 固定时，$(A_i + i)$ 也确定了下来，我们只需要考虑 $(A_j − j)$ 的最大值即可。

于是这种方式可用[单调队列](https://www.luogu.com.cn/problem/P1886)优化，均摊时间复杂度为 $O(N)$，可以通过本题。

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

const int N = 2000010;
typedef long long ll;

int a[N], q[N], h = 1, t = 0, n;
ll ans;
ll Max(ll a, ll b){
    return a > b ? a : b;
}
int main(){
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ){
        scanf("%d", &a[i]);
        a[i + n] = a[i];
    }
    int len = n / 2;
    q[++ t] = 1;
    for (int i = 2; i <= n + len; i ++ ){
        while (q[h] < i - len && h <= t) h ++;
        ans = Max(ans, (ll)(a[i] + i + a[q[h]] - q[h]));
        while (a[q[t]] - q[t] < a[i] - i && t >= h) t --;
        q[++ t] = i;
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：I_am_Lord_Voldemort (赞：1)

# 思路：
这里蒟蒻分享一种复杂度不详的做法。  

### 考虑暴力：
枚举每个点对的代价，但是很容易发现有大量比较是浪费的。

### 考虑优化：
观察样例，我们发现样例是 $A_i$ 和 $A_j$ 最大的时候。当然，不一定每次都是这样，但这启发我们较大的 $A_i$ 在计算权值时有优势。因此排序，从权值较大的点开始考虑它和其他点配队，之后剪枝。

### 具体操作：
#### 剪枝 1：
对于第 $i$ 个点，如果它和仅次于它的点组合，加上最大距离仍然不大于当前值，则 $i$ 及之后的点均不可能更大，直接输出。这么做已经足够通过此题。
#### 剪枝 2：
在第 $i$ 个点与其他点的组合过程中，若第 $i$ 个点与剩下点的最大值组合，加上最大距离仍然不大于当前值，则 $i$ 点已不可能更大，但其他点仍有可能。

# 代码：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int n,maxdis;
struct node{
	int v,id;
}a[maxn];
inline int cmp(node x,node y){
	return x.v>y.v;
}
inline int dis(int i,int j){
	if(a[i].id<a[j].id) swap(i,j);
	int b=a[i].id-a[j].id;
	return min(b,n-b);
}
signed main(){
	ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
	cin>>n;maxdis=n/2;
	for(int i=1;i<=n;i++) cin>>a[i].v,a[i].id=i;
	sort(a+1,a+n+1,cmp);
	int maxval=0;
	for(int i=1;i<n;i++){
		if(a[i].v+a[i+1].v+maxdis<=maxval) break; //剪枝1 
		for(int j=i+1;j<=n;j++){
			if(a[i].v+a[j].v+dis(i,j)>maxval) maxval=a[i].v+a[j].v+dis(i,j);
			else if(a[i].v+a[j].v+maxdis<=maxval) break; //剪枝2 
		}
	}
	cout<<maxval;
}
```

---

## 作者：tyukp233 (赞：0)

### 分析

对于环上问题，常见技巧是断环成链，复制一遍在末尾。

对于该题，$dist(i,j)=\min⁡(|i-j|,N-|i-j|)$ 难以处理。考虑在断环成链后的情况，发现可以只考虑 $i-j$。

例如：
```
pos: 1 2 3 4 5 6 7 8 9 10
seq: 1 2 3 4 5 1 2 3 4 5
```
询问 $dist(2,5)$ 时，只有 $pos_7$ 到 $pos_5$ 以及 $pos_5$ 到 $pos_2$ 的情况，而且下标之差大于 $\dfrac N2$ 的情况是更差的，即只需考虑 $pos_7$ 到 $pos_5$。

则原问题变为在长为 $2N$ 的序列上求：
$$
\min_{1\le j< i\le 2N,i-j\le N/2}{A_i+A_j+i-j}
$$
其中
$$
A_{i+N}=A_i
$$
而 
$$
A_i+A_j+i-j=(A_i+i)-(A_j-j)
$$
在 $i$ 固定时，要取 $A_j-j$ 在一段定长区间内的最大值，使用单调队列即可解决。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000005
int n,a[N<<1],p[N<<1],ans;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],a[i+n]=a[i];
	deque<pair<int,int>> q;
	q.push_back({0,0});
	for(int i=1;i<=n+n/2;i++){
		while(!q.empty()&&q.front().second<i-n/2)q.pop_front();
		ans=max(ans,q.front().first+a[i]+i);
		while(!q.empty()&&q.back().first<=a[i]-i)q.pop_back();
		q.push_back({a[i]-i,i});
	}
	cout<<ans;
}
```

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10957)

# 前置知识

[单调队列/单调栈优化](https://oi-wiki.org/dp/opt/monotonous-queue-stack/) 

# 解法

在仓库 $1$ 和 $n$ 之间把环断开，然后复制一倍接在末尾，形成长度为 $2n$ 的直线公路，即有 $a_{i}=a_{i+n} (1 \le i \le n)$。

对于原来环形公路上的任意两座仓库 $i,j(1 \le j<i \le n)$，代价为 $\begin{cases} a_{i}+a_{j}+i-j & i-j \le \frac{n}{2} \\ a_{j+n}+a_{i}+j+n-i & i-j> \frac{n}{2} \end{cases}$。即对于直线公路上的任意两座仓库 $i,j(1 \le j<i \le 2n,i-j \le \frac{n}{2})$，代价为 $a_{i}+a_{j}+i-j$。

单调队列维护递增的 $a_{i}-i$ 即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
int a[2000010];
deque<int>q;
int main()
{
	int n,ans=0,i;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(i=1;i<=2*n;i++)
	{
		while(q.empty()==0&&i-q.front()>n/2)
		{
			q.pop_front();
		}
		if(q.empty()==0)
		{
			ans=max(ans,a[i]+a[q.front()]+i-q.front());
		}
		while(q.empty()==0&&a[q.back()]-q.back()<=a[i]-i)
		{
			q.pop_back();
		}
		q.push_back(i);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：wdsjl (赞：0)

[本题链接](https://www.luogu.com.cn/problem/solution/P10957)

要想 A 这道题，你首先要知道：
- dp 断环为链（复制一倍在结尾）。
- 单调队列维护连续区间最值。
# 分析题目
在环上处理要带绝对值的距离问题，在化为链之后就变成枚举 $i$ 仓库再枚举 $i$ 之前相距 $\le n \div 2$ 的仓库中于是我们得到动态转移方程：
$ f[i] = a_{i} + b_{j} + i - j$。

但是我们发现此时时间复杂度为 $O( n^{2} )$。

## 优化

此时我们发现我们每次枚举枚举 $i$ 之前相距 $\le n \div 2$ 的仓库有些浪费，实际上我们每次只是对于上次删除了一个过期的值，然后加入了一个新的值，于是我们想到用单调队列维护区间最大值以及过期问题。

用单调队列维护 $ b_{j} - j $。

如果不会单调队列可以来模板学。

[单调队列模板题](https://www.luogu.com.cn/problem/P1886)

~~如果你不够强，且不够年轻就会被单调队列。~~

### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 4000010;

int a[N],ans,n;
deque <int> q; 

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i+n]=a[i];
	}
	for(int i=1;i<=2*n;i++){
		while(q.size()&&i-q.front()>n/2){
			q.pop_front();
		}
		if(q.size()){
			ans=max(ans,a[i]+a[q.front()]+i-q.front());
		}
		while(q.size()&&a[q.back()]-q.back()<=a[i]-i){
			q.pop_back();
		}
		q.push_back(i);
	}
	printf("%d",ans);
	return 0;
}
```

---


# 统计重复个数

## 题目描述

定义 $str = [s, n]$ 表示 $str$ 由 $n$ 个字符串 $s$ 连接构成。

例如，$str == [\texttt{abc}, 3] == \texttt{abcabcabc}$。
如果可以从 $s_2$ 中删除某些字符使其变为 $s_1$，则称字符串 $s_1$ 可以从字符串 $s_2$ 获得。

例如，根据定义，$s1 = \tt{abc}$ 可以从 $s2 = \tt{ab\red{dbe}c}$ 获得，仅需要删除红色标识的字符。

现在给你两个字符串 $s_1$ 和 $s_2$ 和两个整数 $n_1$ 和 $n_2$。由此构造得到两个字符串，其中 $str_1 = [s_1, n_1]$、$str_2 = [s_2, n_2]$。

请你找出一个最大整数 $m$，以满足 $str = [str_2, m]$ 可以从 $str_1$ 获得。

## 说明/提示

数据保证，$s_1,s_2$ 全为小写字母构成，且 $1\leq |s_1|,|s_2| \leq 100$，$0\leq n_1,n_2\leq 10^6$，每个测试点的测试数据不超过 $100$ 组。

## 样例 #1

### 输入

```
ab 2
acb 4
acb 1
acb 1```

### 输出

```
2
1```

# 题解

## 作者：__yiLIUyi__ (赞：5)

# 题解：P10976 统计重复个数
[题目传送门](https://www.luogu.com.cn/problem/P10976)
## 题意解读
题目中的输入格式有误，应该为：
- 第一行输入字符串 $s_2$ 和整数 $n_2$；
- 第二行输入字符串 $s_1$ 和整数 $n_1$。

其他内容题目已经讲的很明确了。这里不再多说。
## 大致思路
感觉其他人的方法都过于复杂（~~因为我是个蒟蒻~~）。所以我讲一种**最简单的暴力**解法。

首先，原文中说：
> 如果可以从 $s_2$ 中删除某些字符使其变为 $s_1$，则称字符串 $s_1$ 可以从字符串 $s_2$ 获得。
> 
> 例如，根据定义，$s1 = \tt{abc}$ 可以从 $s2 = \tt{ab\red{dbe}c}$ 获得，仅需要删除红色标识的字符。

于是，如果想要使得字符串 $s_2$ 可以从字符串 $s_1$ 获得，就要在 $s_1$ 中找到按顺序排列 $s_2$ 的全部字符。也就是说 $s_2$ 是 $s_1$ 的一部分，但注意并不是子串，因为 $s_2$ 在 $s_1$ 中并不一定连续。

我们不妨利用一个循环，设定一个 $s_1$ 的下标 $i$，一个 $s_2$ 的下标 $j$，然后对 $s_1$ 进行遍历，如果 ${s_1}_i$ 与 ${s_2}_j$ 相同，那么 $i$ 和 $j$ 都增加，比较下一位；否则 $i$ 增加，比较下一位。这样，如果 $j$ 与 $s_2$ 的长度相等，则说明 $s_2$ 的所有字符都被找到，那么 $s_2$ 就可以从 $s_1$ 获得；反之，如果 $i$ 与 $s_1$ 的长度相等，则说明 $s_1$ 的所有字符都遍历过一遍，循环结束。

再进一步，根据题意，$s_1$ 中可能有多个 $s_2$。需要一个变量 $ans$ 来记录 $s_2$出现的次数。这时，如果 $j$ 与 $s_2$ 的长度相等，则说明 $s_2$ 的所有字符都被找到，那么 $ans$ 就增加，直到 $i$ 与 $s_1$ 的长度相等，循环终止。

```cpp
ll num1=str1.size(),num2=str2.size();//分别代表两个字符串的长度
for(ll i=0,j=0;i<num1;i++){//注意：这里下表从0开始！
	if(str1[i]==str2[j]){//如果两位相等
		if(j==num2-1){//如果位数达到（下表从0开始，所以到 num2-1就结束了）
			ans++;//统计个数增加
			j=0;//回到下标开头，寻找下一轮
		}else j++;//否则继续找下一位
	}//如果两位不相等，则不进行操作，i增加，比较下一位
}
```

其次，我们可以知道，最终的 $str$ 是由 $m$ 个 $str_2$ 构造的，而 $str_2$ 本身又是由 $n_2$ 个 $s_2$ 构造而来的。所以就可以得到 $str$ 是由 $m \times n_2$ 个 $s_2$ 构造的。即：

$$ [[s_2,n_2],m] = [s_2,n_2 \times m]$$

那么原题就变为了：请你找出一个最大整数 $m$，以满足 $str = [s2,n2 \times m]$ 可以从 $str_1$ 获得。

所以，对于这道题，我们用刚才的代码先在 $str_1$ 中寻找 $s_2$，此时 $ans$ 等于 $s_2$ 的个数，也就是 $n_2 \times m$。对它除以 $n_2$，则 $\lfloor \frac{ans}{n_2} \rfloor$ 就是 $m$。
## 代码实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n1,n2,ans;//变量名如题
string s1,s2,str1,str2;
int main(){
	while(cin>>s2>>n2>>s1>>n1){
		str1=str2="";//清空
		for(ll i=0;i<n1;i++)
			str1+=s1;//构建str1
		str2=s2;
		ll num1=str1.size(),num2=str2.size();
		for(ll i=0,j=0;i<num1;i++){
			if(str1[i]==str2[j]){
				if(j+1==num2){
					ans++;
					j=0;
				}else j++;
			}
		}cout<<ans/n2<<endl;//输出答案
		ans=0;//清空
	}return 0;//好习惯
}
```

---

## 作者：EternalHeart1314 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10976)

# Problem

很好理解吧 ~~（懒得写）~~。

# Solution

很简单的倍增优化 DP，评绿吧？

显然 $[[s2,n2],m]=[s2,n2\times m]$。

要求出一个最大的整数 $ans$，满足 $[s2,ans]$ 能由 $[s1,n1]$ 生成，之后再找到满足 $n2\times res\le ans$ 的最大整数 $res=\lfloor\frac{ans}{n2}\rfloor$，即为本题的答案。

$ans$ 可能很大，如何优化？

显然若 $ans=2^{p_{k}}+2^{p_{k-1}}+\dots+2^{p_0}$（二进制拆分），则 $[s2,ans]=[s2,2^{p_k}]+[s2,2^{p_{k-1}}]+\dots+[s2,2^{p_0}] $。

那不就可以乱搞了吗！

设 $f_{i,j}$ 为从 $s1_i$ 开始（设 $s1$ 无限循环），至少需要多少个字符才能生成 $[s2,2^j]$。

$f_{i,j}=f_{i,j-1}+f_{(i+f_{i,j − 1})\bmod |s1|,j−1}$。

有点小，可以看下面的 Code。

一看 $|s1|,|s2|$ 这么小，直接暴力求 $f_{i,0}$。

二进制拆分后显然有：低位不会影响高位，所以从高到低枚举 $ans$ 的每一位（二进制下），同时记录经过了 $s1$ 的几个字符（$s1$ 无限循环），这一位能 $1$ 就 $1$。

代码就不注释了 ~~（都是对着蓝书写的）~~。

# Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 114;
int n, m, ans, f[N][N];
string s, t;

main() {
	while (cin >> t >> m >> s >> n) {
		ans = 0;
		for (register int i, j, k = 0; s[k]; ++k) {
			for (i = k, j = 0; i <= 100000 && t[j]; ++i) j += s[i % s.size()] == t[j];
			f[k][0] = i - k;
		}
		for (int i, j = 1; j <= 30; ++j) for (i = 0; s[i]; ++i)
			f[i][j] = f[i][j - 1] + f[(i + f[i][j - 1]) % s.size()][j - 1];
		for (int i = 30, j = 0; ~i; --i)
			if (j + f[j % s.size()][i] <= s.size() * n) j += f[j % s.size()][i], ans |= 1 << i;
		cout << ans / m << '\n';
	}
	return 0;
}
```

---

## 作者：Swirl (赞：1)

倍增加速 dp。

---

观察到 $str = [str_2, m] = \left[[s_2, n_2],m \right] = [s_2, m \times n_2]$。

那么 $str$ 就可以看作是 $s_2$ 的延长。

最显然的 dp 方式（至少我这么认为）就是 $f_{i, j}$ 代表从 ${s_1}_i$ 开始，往后至少多少个字符能生成 $[s_2, j]$。 

当然 $m \times n_2$ 大概是 $10^8$ 量级的，如果暴力 dp 会超时（其实数组也开不下）。

---

观察到 $f_{i, j} = f_{i, 1} + f_{i + f_{i, 1}, j - 1} = f_{i, 2} + f_{i + f_{i, 2}, j - 2} = \dots$，其中无用状态特别多，所以考虑用倍增优化。

记 $g_{i, j} = f_{i, 2^j}$ 即从 ${s_1}_i$ 开始，往后至少多少个字符能生成 $[s_2, 2^j]$。

那么转移就很简单了：

$$
g_{i, j} = g_{i, j - 1} + g_{i + g_{i, j - 1}, j - 1}
$$

**注**：上文的转移方程没有保证 $i \le |S|$，所以代码实现中应加上取模。

---

然后呢，答案如何统计？

从大到小枚举次数 $j$，如果当前位置 $i$ 满足 $i + g_{i, j} \le |s_1| \times n_1$，即仍在 $str_1$ 的范围内。

那么就把 $2^j$ 计入答案。

为什么从大到小枚举？因为从小到大并不能保证构造出来的最大，例如 $4 \ge 2^2 + 0 + 0 = 4$，如果从小到大则 $4 \ge 0 + 2^1 + 2^0 = 3$。

---

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define L(i, a, b) for (register int i = (a); i <= (b); i++)
#define R(i, a, b) for (register int i = (a); i >= (b); i--)
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

inline void cmax(int& x, int c) {
    x = max(x, c);
}
inline void cmin(int& x, int c) {
    x = min(x, c);
}

int _test_ = 1;

const int N = 105;

string s, t;
int n1, n2, dp[N][N];

void init() {}

void clear() {}

void solve() {
    while (cin >> t >> n2 >> s >> n1) { // 多测
        L(k, 0, s.size() - 1) { // dp[i][0] 直接暴力求解
            int i = k, j = 0;
            for (; i <= 1e6 && j < t.size(); i++)
                if (s[i % s.size()] == t[j])
                    j++;
            dp[k][0] = i - k;
        }
        L(i, 1, 30) { // 转移
            L(j, 0, s.size() - 1) {
                dp[j][i] = dp[j][i - 1] + dp[(j + dp[j][i - 1]) % s.size()][i - 1];
            }
        }
        int cnt = 0, ans = 0;
        R(i, 30, 0) {
            if (cnt + dp[cnt % s.size()][i] <= s.size() * n1) { // 如果没有超出边界
                cnt += dp[cnt % s.size()][i]; // 更新当前位置
                ans += (1 << i); // 计入答案
            }
        }
        cout << ans / n2 << "\n"; // 记得除以 n2
    }
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    // cin >> _test_;
    init();
    while (_test_--) {
        clear();
        solve();
    }
    return 0;
}
```

---

## 作者：tssys (赞：1)

## 前言

在此题中 $[a,b] $ 是把 $b$ 个字符串 $a$ 拼接在一起。

并且输入是先读入 $s_2$，$n_2$，再读入 $s_1$，$n_1$。
## 分析
此题使用动态规划。

首先 $[[s_2,n_2],m]=[s_2,n_2 \times m]$。于是我们可以求出一个最大的整数 $m'$，满足 $[s_2,m']$ 可以由 $[s_1,n_1]$ 生成。之后我们满足 $m_2 \times m \le m'$ 的最大整数，就是这道题的答案了。

所以因为 $m'$ 可能很大，于是考虑二进制拆分，将 $m$ 分成若干个 $2$ 的整数次幂，如 $m'=[s_2,2^{p_t-1}] + [s_2,2^{p_t-2}] + \dots +[s_2,2^{1}]+[s_2,2^0]$ 然后把这 $t$ 个字符串首尾相接而成。

不妨考虑从 $[s_1,n_1]$ 的每个位置开始，至少要多少字符才能成功生成 $[s_2,2^p](p\in [0,\log_2(|s_1| \times n_1 \div s_2)])$ 最后在总字符不超过 $|s1| \times n_1$ 的前提下，用这些 $2$ 的整数次幂来拼 $m'$。

### DP 状态
$f_{i,j}$ 代表从 $s_{1,i}$ 开始，至少需要多少个字符，才能生成 $[s_2,2^j]$。
### DP 状态转移方程
$$f_{i,j} = f_{i,j} + f_{i+f_{i,j} \bmod |s_1|,j-1}$$

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define I return 
#define AK  0
#define IOI ; 

string s2,s1;
int n1,n2,m,f[1005][1005],st;
int qwq()
{
    memset(f,0,sizeof(f));
    m=0;
    for(int i=0;i<s1.size();++i)
    {
        int k=i;
        f[i][0]=0;     
        for(int j=0;j<s2.size();++j)
        {
            int cnt=1;
            for(;s1[k]!=s2[j];cnt++)
            {
                k=(k+1)%s1.size();
                if(cnt>=s1.size())
                {
                    cout<<"0\n";
                    return 114514;
                }
            }
            (k=(k+1)%s1.size());
            f[i][0]+=cnt;
        }
    }
    for(int j=1;j<=30;++j)
        for(int i=0;i<s1.size();++i)
            f[i][j]=f[i][j-1]+f[(i+f[i][j-1])%s1.size()][j-1];
    m=0,st=0;
    for(int i=30;i>=0;i--)
    {
        if(st+f[st%s1.size()][i]<=s1.size()*n1)
        {
            st+=f[st%s1.size()][i];
            m+=1<<i;
        }
    }
    cout<<m/n2<<"\n";
    return 114514;
}
int main()
{
    while(cin>>s2>>n2>>s1>>n1)
    {
        qwq();
    }
    I AK IOI;
}

```

---

## 作者：MYJ_aiie (赞：0)

## [P10976 统计重复个数](https://www.luogu.com.cn/problem/P10976)    
### 思路：  
直接暴力肯定不行，复杂度是 $10^{10}$。  
想想动态规划，这里我们使用倍增优化DP(因为每个字符串是独立的，可以把 $m$ 二进制拆分来做  
用 $f_{i,p}$ 表示从 $s1_i$ 开始，拼成 $2^p$ 个 $s_2$ 所需的最小字符数。
可以类比倍增求 LCA，转移方程就是 $f_{i,p}=f_{i,p-1}+f_{i+f_{i,j-1},p-1}$，这里 $i+f_{i,j-1}$ 可能比较大，所以要膜 $s1$ 的长度。  
预处理直接暴力就好了。  
### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
const int INF=0x3f3f3f3f;
#define lll long long
string s1,s2;
int n1,n2;
int f[N][31]; 
//s1里找s2 
int main(){
	while(cin>>s2>>n2){
		memset(f,0x3f,sizeof f);
		cin>>s1>>n1;
		int l1=s1.size(),l2=s2.size();
		for(int l=0;l<l1;l++){
			for(int i=l,ll=0;i<l1*n1&&ll<l2;i++){
				if(s1[i%l1]==s2[ll]) ll++;
				if(ll==l2) f[l][0]=i-l+1;
			}
		}
		for(int p=1;p<=30;p++){
			for(int i=0;i<l1;i++){
				f[i][p]=min(INF,f[i][p-1]+f[(i+f[i][p-1])%l1][p-1]);
			//	cout<<i<<" "<<p<<" "<<f[i][p]<<endl;
			}
		}
		lll ans=0;
		int nw=0;
		for(int p=30;p>=0;p--){
			if(nw+f[nw%l1][p]<=l1*n1){
				nw+=f[nw%l1][p];
				ans+=(1<<p);
			}
		}
		printf("%lld\n",ans/n2);
	}
	return 0;
} 
```

---

## 作者：yanrs1019 (赞：0)

# 题解：P10976 统计重复个数  
## 注意输入  
先输入 $s_2,n_2$，再输入 $s_1,n_1$。  
## 主要思路  
注意到要查询 $n_1$ 个 $s_1$ 中包含多少个 $n_2$ 个 $s_2$。  
设包含 $x$ 个，$temp$ 为 $n_2$ 个 $s_2$ 中包含 $s_1$ 的个数，则 $x=\lfloor \frac{temp}{n_1} \rfloor$。  
把 $n_2$ 个 $s_2$ 处理出来，再逐位比较。  
设有 $T$ 组测试数据，时间复杂度$O(|s_1|\times n_1\times T)$。明显超时。  

## 时间复杂度优化  
考虑倍增。  
设倍增数组 $st_{i,j}$，表示从 $s_{1}$ 的第 $i$ 个字符开始，拼出 $2^j$ 个 $s_2$ 需要 $s_1$ 多长。  
$st_{i,0}$ 表示拼出一个 $s_2$ 要多长。  
$$
st_{i,j}=st_{i,j-1}+st_{(i+st_{i,j-1})\bmod l_1,j-1}
$$  

## ACcode  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define N 105
#define inf 0x3f3f3f3f
LL st[N][35]; 
int main(){
	string s1,s2;
	LL n1,n2;
	while(cin>>s2>>n2>>s1>>n1){
		memset(st,0x3f,sizeof st);
		LL cnt=0,l1=s1.size(),l2=s2.size();
		for(LL x=0;x<l1;x++)
			for(LL i=x,j=0;i<l1*n1&&j<l2;i++){
				if(s1[i%l1]==s2[j])j++;
				if(j==l2)st[x][0]=i-x+1;
			}
		for(LL j=1;j<30;j++)
			for(LL i=0;i<l1;i++)
				st[i][j]=min(st[i][j-1]+st[(i+st[i][j-1])%l1][j-1],(LL)inf);
		LL j=0,ans=0;
		for(LL i=29;i>=0;i--)
			if(j+st[j%l1][i]<=l1*n1){
				j+=st[j%l1][i];
				ans+=(1<<i);
			}
		printf("%lld\n",ans/n2);
	}
	return 0;
}
```

---

## 作者：Binah_cyc (赞：0)

大家写的怎么都是同一种做法？我来给出一个另类的倍增方法。

以下所有的字符串下标均从 $0$ 开始。

第一步是转化题意，$[[s2,n2],m]=[s2,n2 \times m]$，找最大的 $m$ 就是找最大的 $t$ 使得 $[s2,t]$ 能由 $[s1,n_1]$ 获得，$m$ 就是 $\lfloor {t \over n_2} \rfloor$。

我们以 $s_2$ 为基准，设 $nxt_i$ 表示从 $s_2$ 的第 $i$ 个字符开始，在 $s_1$ 中匹配，匹配完整个串后匹配到了第几位，$val_i$ 表示在这个过程中匹配出了几个 $s_2$。注意，第一段不完整的代表前面有一段已经匹配好的，所以应当计入答案。

直接说可能不是很好理解，我来给个例子。

设 $s_1=\texttt{cycycycyc}$，$s_2=\texttt{cyc}$。

$nxt_0=1$，$val_0=2$，具体分配方式如下。$\color{red}\texttt{cyc}\color{black}\texttt{y}\color{red}\texttt{cyc}\color{black}\texttt{y}\color{red}\texttt{c}$

$nxt_1=1$，$val_1=2$，具体分配方式如下。$\color{black}\texttt{c}\color{red}\texttt{yc}\color{black}\texttt{y}\color{red}\texttt{cyc}\color{black}\texttt{y}\color{red}\texttt{c}$

$nxt_2=0$，$val_2=3$，具体分配方式如下。$\color{red}\texttt{c}\color{black}\texttt{y}\color{red}\texttt{cyc}\color{black}\texttt{y}\color{red}\texttt{cyc}$

这样就可以快速的将一个 $s_1$ 与 $s_2$ 匹配了，只需要匹配 $n_1$ 次就能得出答案。

但是它还是不够快，因此考虑倍增优化。套路的，设 $dp_{i,j}$ 表示从 $s_2$ 的第 $j$ 个字符开始，在 $s_1$ 中匹配完 $2^i$ 个串后匹配到了第几位，$cur_{i,j}$ 表示在这个过程中匹配出了几个完整的 $s_2$。

转移方程就是把它劈成两半分别计算。

$dp_{i,j}=dp_{i-1,(dp_{i-1,j})},cur_{i,j}=cur_{i-1,j}+cur_{i-1,(dp_{i-1,j})}$

然后对 $n_1$ 进行二进制拆分，对每个二进制位进行计算。

讲的可能有点朦胧，可以看看代码。

```cpp
// Problem: P10976 统计重复个数
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10976
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// Author: Binah_cyc

#include<bits/stdc++.h>
using namespace std;
#define int long long
constexpr int N=105;
int n1,n2;
string s1,s2;
int nxt[N],val[N];
int dp[25][N],cur[25][N];
main()
{
	cin.tie(0)->sync_with_stdio(false);
	while(cin>>s2>>n2>>s1>>n1)
	{
		for(int i=0;i<s2.length();i++)
		{
			int it=i;
			for(int j=0;j<s1.length();j++)//匹配字符串
			{
				if(s1[j]==s2[it])
				{
					it++;
					if(it==s2.length()) val[i]++,it=0;//匹配了一整个字符串
				}
			}
			nxt[i]=it;
		}
		for(int i=0;i<s2.length();i++)
			dp[0][i]=nxt[i],cur[0][i]=val[i];
		for(int i=1;i<=20;i++)
		{
			for(int j=0;j<s2.length();j++)
			{
				dp[i][j]=dp[i-1][dp[i-1][j]],cur[i][j]=cur[i-1][j]+cur[i-1][dp[i-1][j]];//正常倍增
			}
		}
		int now=0,num=0;
		for(int i=20;i>=0;i--)//从高位到低位考虑
		{
			if((1<<i)<=n1)//n1的这一位有值
			{
				n1-=(1<<i),num+=cur[i][now],now=dp[i][now];
			}
		}
		cout<<num/n2<<'\n';
		for(int i=0;i<s2.length();i++) val[i]=nxt[i]=0;//多测要清空
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 我的博客

更多相关（或者不相关）知识点快戳：[oi-beats](https://ntsc-yrx.github.io/oi-beats/site/)，[个人博客](https://ntsc.flowus.cn/)。

## 知识点摘录

倍增。貌似不是 dp 吧，缺少 dp 的要素：决策。

## 做法

考虑 $[s2,n2\times m]$ 是 $[s1,n1]$ 的子序列。

那么我们只需要知道一个 $[s2,k]$ 满足其是 $[s1,n1]$ 的子序列，且 $k$ 最大。我们
求出最大的 $k$，那么答案就是最大的 $m$ 使得 $m\times n2≤k$。

$f_{i,j}$ 表示从 $s1_i$ 开始得出 $[s2,2^j]$ 需要 $s1$ 中多长的串（$s1$ 是无限循环的）。

暴力求出 $f_{i,0}$，那么就可以开始倍增了。

当前起点为 $i$，那么 $f _{i,j}$ 就是 $f_{i,j-1}+f_{nxt,j-1}$，其中 $nxt$ 是 $j$ 往后走 $f_{i,j-1}$ 个字符到达的位置，即 $i+f_{i,j-1}\bmod len(s1)$。

## 题面翻译

```C++
/*                                                                                
                      Keyblinds Guide
     				###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+K then ctrl+W: close all
      - Alt+la/ra : move mouse to pre/nxt pos'
	  
*/
#include <bits/stdc++.h>
#include <queue>
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i >= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define ps second
#define pf first

// #define innt int
#define itn int
// #define inr intw
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
		if (ch == '-')
			ff = -1;
		ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
	if (out < 0)
		putchar('-'), out = -out;
	if (out > 9)
		write(out / 10);
	putchar(out % 10 + '0');
}

#define ell dbg('\n')
const char el='\n';
const bool enable_dbg = 1;
template <typename T,typename... Args>
void dbg(T s,Args... args) {
	if constexpr (enable_dbg){
    cerr << s;
    if(1)cerr<<' ';
		if constexpr (sizeof...(Args))
			dbg(args...);
	}
}

#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() { cerr << endl; }
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) { for (auto v: a) cerr << v << ' '; err(x...); }
template<typename T, typename... A>
void err(T a, A... x) { cerr << a << ' '; err(x...); }
#else
#define dbg(...)
#endif


const int N = 3e2 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1e9 + 7;

/*
策略：
考虑[s2,n2*m]\in [s1,n1]
[s2,k]\in[s1,n1]
求出最大的k

f_{i,j}表示从s1_i开始得出[s2,2^j]需要s1中多长的串
于是就可以倍增了


*/


int f[N][32];
string s1,s2;
int n1,n2;
int l1,l2;
void solve(){
     l1=s1.size();
     l2=s2.size();
    // s1=" "+s1;
    // s2=" "+s2;

    // cdbg("OK");
    //求f_{i,0}
    for (int k=0;s1[k];++k) {
        for (int i=k,j=0;i<=100000&&s2[j];++i) j+=s1[i%l1]==s2[j];
        f[k][0]=i-k;
    }

    for(int i=1;i<=30;i++){
        for(int j=0;j<l1;j++){
            int nxt=(f[j][i-1]+j)%l1;
            f[j][i]=f[j][i-1]+f[nxt][i-1];
        }
    }

    // cdbg(f[0][0]);
    int len=0,ans=0;
    int cur=0;
    for(int i=30;~i;i--){
        if(len+f[cur][i]<=l1*n1){
            ans+=(1<<i);
            len+=f[cur][i];

            cur=(f[cur][i]+cur)%l1;
        }
    }

    // cdbg(ans);

    cout<<ans/n2<<endl;
}

signed main() {
    // freopen(".in","r",stdin);
    // freopen(".in","w",stdout);

    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int T=1;
    while(cin>>s2>>n2){
        cin>>s1>>n1;
    	solve();
    }
    return 0;
}
```

---

## 作者：z_yq (赞：0)

# 题意
给定 $s1,n1,s2,n2$ 定义 $[str,n]$ 表示 $n$ 个 $str$ 头尾相接，求最大的 $m$ 满足 $[s2,n2 \times m]$ 是 $[s1,n1]$ 的子串。
# 做法
思维难度较大，但是代码特别好写，建议评绿。\
首先我们可以得出 $m \times n2$ 的值，记为 $m'$，为了提高计算效率，我们用二进制拆分，即将 $[s2,m']$ 变成 $[s2,2^{k_1}][s2,2^{k_2}][s2,2^{k_3}]\cdots[s2,2^{k_p}]$，由于注意到这些串都是 $2^i$ 个长度，所以我们可以尝试 dp。\
设 $dp_{i,j}$ 表示从 $s1_i$ 开始，至少要多少个字符才能生成 $[s2,2^j]$ 所以我们可以暴力算出 $dp_{i,0}$ 然后递推式也很好推，即：$dp_{i,j}=dp_{i,j-1}+dp_{(i+dp_{i,j-1})\bmod\left| s1 \right|,j-1} $
# Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=109,M=39;
ll n1,n2,dp[N][M];string s1,s2;
inline void solve()
{
    memset(dp,0,sizeof(dp));
    for(int i=0;i<s1.size();i++)
    {
        ll tmp=i;
        ll cnt=0;
        for(int j=0;j<s2.size();j++)
        {
            cnt=1;
            while(s2[j]!=s1[tmp])
            {
                tmp=(tmp+1)%s1.size();
                cnt++;
                if(cnt>s1.size())
                {
                    cout<<0<<endl;
                    return void();
                }
            }
            dp[i][0]+=cnt;
            tmp=(tmp+1)%s1.size();
        }
    }
    for(int i=1;i<=31;i++)
        for(int j=0;j<s1.size();j++)
            dp[j][i]=dp[j][i-1]+dp[(j+dp[j][i-1])%s1.size()][i-1];
    ll ans=0,m=0;
    for(int i=31;i>=0;i--)
        if(ans+dp[ans%s1.size()][i]<=n1*s1.size())
        {
            ans+=dp[ans%s1.size()][i];
            m+=(1<<i);
        }
    cout<<m/n2<<endl;
}
int main()
{
    while(cin>>s2>>n2>>s1>>n1) solve();
    return 0;
}
```

---


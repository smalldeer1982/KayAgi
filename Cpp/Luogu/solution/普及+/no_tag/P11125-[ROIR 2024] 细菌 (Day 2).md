# [ROIR 2024] 细菌 (Day 2)

## 题目背景

翻译自 [ROIR 2024 D2T2](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day2.pdf)。

生物实验室中正在进行实验。开始时，有 $n$ 个冷冻的细菌，编号从 $1$ 到 $n$。根据实验计划，编号为 $i$ 的细菌将在实验开始后的 $a_i$ 秒进入培养皿。如果有多个细菌的 $a$ 相等，它们会同时进入。

一旦冷冻的细菌进入培养皿，它们会被解冻并开始成熟。编号为 $i$ 的细菌成熟需要 $t_i$ 秒。一旦细菌成熟，它们会开始繁殖：立即分裂成两个成熟的细菌，然后在接下来的每一秒钟，每个成熟细菌都会再次分裂成两个成熟的细菌。

## 题目描述

培养菌落的规模指的是培养皿中细菌的总数。实验的目标是确定多长时间后，培养菌落的规模首次恰好等于 $m$。请帮助科学家确定这个时间秒数，或者判断培养群体的规模是否永远不会恰好等于 $m$。

## 说明/提示

下表是样例 $1$ 的实验进展：

| 时间 | 细菌 $1$ | 细菌 $2$ | 细菌 $3$ | 细菌 $4$ | 总数 |
|:------:|:--------:|:--------:|:--------:|:--------:|:------:|
| $0$    | 冷冻   | 冷冻   | 冷冻   | 冷冻   | $0$    |
| $1$    | 冷冻   | 冷冻   | 在培养皿中，成熟中 | 冷冻   | $1$    |
| $2$    | 冷冻   | 冷冻   | 在培养皿中，成熟中 | 冷冻   | $1$    |
| $3$    | 在培养皿中，成熟中 | 冷冻   | 在培养皿中，成熟，$2$ 只细菌 | 冷冻 | $3$    |
| $4$    | 在培养皿中，成熟中 | 冷冻   | 在培养皿中，成熟，$4$ 只细菌 | 冷冻 | $5$    |
| $5$    | 在培养皿中，成熟，$2$ 只细菌 | 在培养皿中，成熟中 | 在培养皿中，成熟，$8$ 只细菌 | 冷冻 | $11$   |

注意：细菌的繁殖过程会导致每秒钟细菌数目翻倍。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
| $1$ | $13$ | $m\le n,a_i\le10^5,t_i=10^9$ |
| $2$ | $14$ | $a_i=i$，所有 $t_i$ 相等 |
| $3$ | $17$ | $n,a_i,t_i\le3000$ |
| $4$ | $23$ | $a_i=1$ |
| $5$ | $33$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 2 \times 10^5$，$1 \leq m \leq 10^9$，$1 \leq a_i,t_i \leq 10^9$。

## 样例 #1

### 输入

```
4 11
3 5 1 10
2 9 2 13```

### 输出

```
5```

## 样例 #2

### 输入

```
13 124
5 6 8 8 1 6 4 6 4 7 10 3 9
5 2 10 5 2 1 1 4 8 3 4 1 9```

### 输出

```
8```

# 题解

## 作者：Sunset_afterglow (赞：5)

## 题意
题目要你求出在什么时间，细菌的数量刚好等于 $m$，细菌 $i$ 在第 $T$ 秒时将分裂出  
$ f(T , i) = \begin{cases}
  2^{T - a_i - t_i + 1} & T - a_i - t_i + 1 > 0 & a_i \le k \\
  1 & a_i \le k \\
  0 & a_i > k \\
\end{cases}$
## 思路
因为我们发现这道题目的答案具有**单调性**，所以我们可以使用**二分答案**来求出在第一次细菌数量刚好等于 $m$ 的时间。
## 解法
这道题目的关键在于**二分答案**的 $check$ 函数如何写，其实很简单，我们直接按照上面的公式把 $T$ 带入就可以得出在第 $T$ 秒时将分裂出 $ \sum_{i = 1}^{n} f(T , i) $ 个细菌。

## 最后的代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
const int N = 2e5 + 10;
int n,m,a[N],t[N];
int power(int b) {
    int ans=1,t=2;
    bool flag=0;
    while(b){
        if(b&1){
            if(flag) return -1;
            ans*=t;
            if(ans>m) return -1;
        }
        t=t*t;
        if(t>m) flag=1;
        b>>=1;
    }
    return ans;
}
int check(int k){
	int ans=0;
	for(int i=1;i<=n;++i){
		if(a[i]<=k&&a[i]+t[i]-1>=k)++ans; 
		else if(a[i]<=k){
			int tmp=power(k-t[i]-a[i]+1);
			if(tmp==-1)return m+1;
			ans+=tmp;
			if(ans>m)return LLONG_MAX;
		}
	}
	return ans;
}
signed main(){
	n = read(); m = read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)t[i]=read();
	int l=1,r=6e9,ans=-1;
	while(l<=r){
		int mid=l+r>>1,t=check(mid);
//		cout<<l<<' '<<r<<' '<<mid<<' '<<t<<'\n';
		if(t<m) l=mid+1;
		else {
			if(t==m){
				ans=mid;
			}
			r=mid-1;
		}
	}
	if(ans!=-1&&check(ans))cout<<ans;
	else cout<<-1;
	return 0;
}
``` 
[AC记录](https://www.luogu.com.cn/record/184361486)

---

## 作者：xuyifei0302 (赞：1)

这道题读完之后我们会发现成熟的细菌数会一直乘 $2$，但 $m \le 10 ^ 9$ 的数据范围就会使我们得出一个结论，在一个细菌成熟后，最多 $30$ 秒，细菌数就会超出 $m$。



所以，我们就可以用这个性质，计算出最先成熟的细菌的成熟时间，以它为基础，用双指针维护整个过程，若细菌总数大于等于 $m$，就输出答案并结束程序



注意，有可能在第一个细菌成熟前，培养皿里的细菌数已经达到了 $m$，需要处理一下。



接下来是代码环节：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Node {
	int a, t, s;
} a[200005], b[200005];
int n, m, sum, num;
bool mark[200005];
bool cmp(Node x, Node y) {
	return x.s < y.s;
}
bool cmp1(Node x, Node y) {
	return x.a < y.a;
}
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i].a;
	}
	for (int i = 1; i <= n; i ++) {
		cin >> a[i].t;
		a[i].s = a[i].t + a[i].a;
		b[i].a = a[i].a;
	}
	sort(a + 1, a + 1 + n, cmp);
	sort(b + 1, b + 1 + n, cmp1);
//	for (int i = 2; i <= n; i ++) {
//		if (a[i].s - a[1].s >= 40) {
//			n = i;
//			break;
//		}
//	}
//	cout << "\n";
//	for (int i = 1; i <= n; i ++) {
//		cout << a[i].a << " " << a[i].t << "\n";
//	}
	int t = a[1].s, j = 1, k = 1;
	for (int i = 1; i <= n; i ++) {
		if (b[i].a < t) {
			if (b[i].a != b[i - 1].a) {
				if (num == m) {
					cout << b[i - 1].a;
					return 0;
				} else if (num > m) {
					cout << "-1";
					return 0;
				}
			}
			num ++;
		} else {
			if (num == m) {
				cout << b[i - 1].a;
				return 0;
			} else if (num > m) {
				cout << "-1";
				return 0;
			}
			k = i;
			break;
		}
	}
	if (b[n].a < t) {
		if (num == m) {
			cout << b[n].a;
			return 0;
		} else if (num > m) {
			cout << "-1";
			return 0;
		}
	}
	for (int i = k; i <= n; i ++) {
		if (b[i].a == t) {
			num ++;
		} else {
			k = i;
			break;
		}
	}
//	cout << num << " " << sum << "\n";
	for (int i = 1; i <= n; i ++) {
		if (a[i].s == t) {
			sum += 2;
		} else {
			j = i;
			break;
		}
	}
	num -= sum / 2;
	if (sum + num == m) {
		cout << t;
		return 0;
	}
	if (sum + num > m) {
		cout << "-1";
		return 0;
	}
	while (true) {
		t ++;
		sum *= 2;
		if (t == a[j].s) {
			for (; j <= n; j ++) {
				if (a[j].s == t) {
					sum += 2;
					num --;
				} else {
					break;
				}
			}
		}
		if (t == b[k].a) {
			for (; k <= n; k ++) {
				if (b[k].a == t) {
					num ++;
				} else {
					break;
				}
			}
		}
		if (sum + num == m) {
			cout << t;
			return 0;
		}
		if (sum + num > m) {
//			cout << sum << " " << num << "\n";
			cout << "-1";
			return 0;
		}
//		cout << t << ": " << sum << " " << num << "\n";
	}
	return 0;
}
```

---

## 作者：__Luna__ (赞：1)

以 `a[i]` 存储 $a_i$，`t[i]` 存储 $t_i$。  
显然，我们可以这么求细菌 $i$ 对应的菌落在指定时刻的菌体数：
```cpp
inline int num(int i,int t_)
{
    t_-=a[i];
    if(t_<0)return 0;
    t_-=t[i];
    if(t_<0)return 1;
    return 2<<t_;
}
```
一共有 $n$ 个这样的菌落，我们可以求得总共的群体规模 $sum$：

```cpp
int sum=0;
for(int i=0;i<n;i++)
{
    sum+=num(i,t_);
}
```
最暴力的思路是从 $0$ 开始不断累加时间，直到 $sum$ 等于 $m$ 为止。不过根据 $a_i$ 和 $t_i$ 的规模，可以想见这么做一定会吃 TLE。   
由于每一个 $num$ 均随着时间的流逝单调不降，$sum$ 也是随着时间流逝单调不降的。容易想到用二分处理。   
构造 `check()` 函数如下（在满足 `sum>=m` 时返回 true）：
```cpp
inline int check(int t_)
{
    long long sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=num(i,t_);
        if(sum>=m)return 1;
    }
    return 0;
}
```
二分求解：
```cpp
int l=1,r=1000000000;
while(l<r)
{
    int mid=(l+r)>>1;
    if(check(mid))r=mid;
    else l=mid+1;
}
//二分结束以后的 l 是令 sum>=m 的最小时间
//此时可能仍存在 sum>m 的情况，对应问题无解
int sum=0;
for(int i=0;i<n;i++)
{
    sum+=num(i,l);
}
if(sum==m)cout<<l<<endl;
else cout<<"-1"<<endl;
```
完整的程序：
```cpp
#include<iostream>
using namespace std;
int a[200001],t[200001],n,m;
int num(int i,int t_)
{
    t_-=a[i];
    if(t_<0)return 0;
    t_-=t[i];
    if(t_<0)return 1;
    return 2<<t_;
}
int check(int t_)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=num(i,t_);
        if(sum>=m)return 1;
    }
    return 0;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n;i++)cin>>t[i];
    int l=1,r=1000000000;
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=num(i,l);
    }
    if(sum==m)cout<<l<<endl;
    else cout<<"-1"<<endl;
}
```
这道题也不过如此嘛，溜了……   
**等等？为什么这个程序只有 13 分？** [评测记录](https://www.luogu.com.cn/record/179245157)   
这不科学！！！   
让我们用暴力程序确认以下我们的 `num()` 和 `check()` 没有写错：
```cpp
#include<iostream>
using namespace std;
int a[200001],t[200001],n,m;
int num(int i,int t_)
{
    t_-=a[i];
    if(t_<0)return 0;
    t_-=t[i];
    if(t_<0)return 1;
    return 2<<t_;
}
int check(int t_)
{
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=num(i,t_);
        if(sum>=m)return 1;
    }
    return 0;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n;i++)cin>>t[i];
    for(int i=0;i<1000000001;i++)
    {
        if(check(i))
        {
            int sum=0;
            for(int j=0;j<n;j++)
            {
                sum+=num(j,i);
            }
            if(sum==m)cout<<i<<endl;
            else cout<<"-1"<<endl;
            return 0;
        }
    }
}
```
[评测记录](https://www.luogu.com.cn/record/179245278)   
预料之中地 TLE 了一大堆，不过二分程序中的 WA 神秘地消失了！   
~~蒟蒻调试了半个小时才发现~~问题其实在于，当 `t_` 很大的时候，`2<<t_` 会溢出而变为 $0$，破坏了 $sum$ 的单调性。   
开 long long 也是解决不了这个问题的，因为在指数增长下，int 和 long long 几乎没什么区别。   
怎么解决？这边先放出最后的 AC 程序（[评测记录](https://www.luogu.com.cn/record/179245403)），不知你是否能看出一些端倪：
```cpp
#include<iostream>
using namespace std;
int a[200001],t[200001],n,m;
long long num(int i,int t_)
{
    t_-=a[i];
    if(t_<0)return 0;
    t_-=t[i];
    if(t_<0)return 1;
    if(t_<30)return 2<<t_;
    else return 2147483648ll;
}
int check(int t_)
{
    long long sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=num(i,t_);
        if(sum>=m)return 1;
    }
    return 0;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n;i++)cin>>t[i];
    int l=1,r=1000000000;
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=num(i,l);
    }
    if(sum==m)cout<<l<<endl;
    else cout<<"-1"<<endl;
}
```
解决方法是这样的：既然我们不能阻止溢出，那么我们就将溢出的影响控制到合理的范围！这样子计算得到的 $sum$ 虽然不单调，但溢出部分的 $sum$ 可以保证不会小于 $m$，也就不会对结果产生影响。   
**最后：本题建议评绿。**   
溜喽~

---

## 作者：ELECTRODE_kaf (赞：1)

显然细菌数目单调不减，故二分时间。

对于 `check()` 函数，枚举每种细菌计算贡献。具体地，

- 对于已经成熟的细菌 $i$，其贡献为 $2^{curt-(st_i+t_i-1)}$，其中 $curt$ 为当前时间，$st_i$ 为细菌 $i$ 放入的时间，$t_i$ 为成熟所需时间。

- 对于放入但未成熟的细菌，贡献为 $1$。

- 否则不产生贡献。

计算时记得判 $2^p$ 溢出的问题，代码照着这个打就行，不放了。

---

## 作者：makerlife (赞：0)

注意到答案单调不降，考虑二分答案。

考虑 `check()` 函数的写法，对于一个时间 $x$ 和一个细菌 $i$，有如下几种情况：

- 细菌已成熟。其对总细菌数量的贡献是 $2^{x-(t_i+a_i)+1}$；
- 细菌已放入培养皿，正在成熟。此时贡献为 $1$；
- 细菌未放入培养皿，贡献显然为 $0$。

注意到 $2^{x-(t_i+a_i)+1}$ 可能会溢出，特判溢出的情况下直接调整右端点即可。

### Core Code

```cpp
#define int ll
const int MAXN = 1e9;
int check(int x) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        if (x < a[i]) {
            continue;
        } else if (x < a[i] + t[i]) {
            sum += 1;
        } else {
            if (x - (a[i] + t[i]) + 1ll > 32ll) {
                return MAXN + 1;
            } else {
                sum += (1ll << (x - (a[i] + t[i]) + 1ll));
            }
        }
    }
    return sum;
}
signed main() {
    n = read(); m = read();
    for (int i = 1; i <= n; i++) {
        a[i] = read();
    }
    for (int i = 1; i <= n; i++) {
        t[i] = read();
    }
    int l = 1, r = MAXN;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(mid) < m) l = mid + 1;
        else r = mid;
    }
    if (check(l) == m) cout << l << endl;
    else cout << -1 << endl;
    return 0;
}

---

## 作者：Kketchup (赞：0)

### [[ROIR 2024 Day 2] 细菌](https://www.luogu.com.cn/problem/P11125)

- 二分

**Sol:** 比较简单的一道题，介绍两种做法。刚看到这题以为是线段树维护区间加等比数列，查询直接在线段树上二分，发现值域非常大空间开不下。然后观察到题目中**恰好等于 $m$** 这个条件非常难受，从这里入手，想到二分答案。具体地，二分答案时间，每次检查细菌个数能不能大于等于 $m$。注意到 $m$ 最大是 $10^9$ 量级，所以成熟时间多余 $30$ 秒时一定可行。最后找到使细菌个数大于等于 $m$ 的第一个时间，判断此时是否正好是 $m$ 即可，记得注意二分上界。时间复杂度 $O(n\log V)$。

第二种做法：由上面结论，成熟时间多余 $30$ 秒时一定可行，所以成熟时间多余 $30$ 秒一定超过 $m$。我们只需要找到第一个成熟的细菌，暴力往后检查至多 $30$ 秒即可。时间复杂度 $O(30n)$，其实这个 $30$ 源于值域取 $\log$，所以还是 $O(n\log V)$。

**Trick:** 观察到值域很大，不能直接处理，又发现细菌数量限制强，且数量有单调性，考虑二分。

二分做法：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=2e5+10;
#define int ll
int n,m;
int a[N],t[N],po[40];
bool chk(int x){
	int res=0;
	for(int i=1;i<=n;++i){
		if(a[i]+t[i]<=x){
			int len=x-t[i]-a[i]+1;
			if(len>30) return 1;
			res+=po[len];
		}
		else if(a[i]<=x) res++;
		if(res>=m) return 1;
	}
	return (res>=m);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>m;
	po[0]=1;
	for(int i=1;i<=33;++i) po[i]=po[i-1]*2;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1;i<=n;++i) cin>>t[i];
	int l=1,r=3e9;
	while(l<r){
		int mid=(l+r)>>1;
		if(chk(mid)) r=mid;
		else l=mid+1;
	}
	int res=0;
	for(int i=1;i<=n;++i){
		if(a[i]+t[i]<=l){
			int len=l-t[i]-a[i]+1;
			res+=po[len];
		}
		else if(a[i]<=l) res++;
	}
	if(res==m) cout<<l<<endl;
	else cout<<-1<<endl;
	return 0;
}
```

暴力检查：
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define endl '\n'
#define int ll
const int N=2e5+10;
int n,m,k=1e18,a[N],t[N];
int l[N];
map<int,int> mp;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>t[i];
	for(int i=1;i<=n;i++) k=min(k,a[i]+t[i]);
	for(int i=1;i<=n;i++) mp[a[i]]++;
	int cur=0;
	for(auto u:mp){
		if(u.first>=k) break;
		cur+=u.second;
		if(cur==m){
			cout<<u.first<<endl;
			return 0;
		}
	}
	for(int i=k;i<k+30;i++){
		cur+=mp[i];
		for(int j=1;j<=n;j++){
			int v=a[j]+t[j];
			if(i>=v) cur+=(1<<(i-v));
		}
		if(cur==m){
			cout<<i<<endl;
			return 0;
		}
	}
	cout<<-1<<endl;
	return 0;
} 
```

---

## 作者：Taoran_01 (赞：0)

<!-- Solution-of-P11125 -->

---
### 写在前面
提供一种不用二分的写法，常数稍大但思路较为直接。

---
### 题目描述
共有 $n$ 个细菌，其中第 $i$ 个经过 $a_i$ 秒后放入，经过 $t_i$ 秒后成熟并瞬间分裂。未成熟的细菌不会分裂，成熟的细菌每一秒都会分裂为原来的两倍。

现对于一个数量 $m$，询问是否有一个时刻，使得细菌的总数（未成熟细菌+成熟细菌）等于 $m$。

数据范围：$1\le n\le2\times10^5$，$1\le m\le10^9$。

---
### 解题思路
首先考虑暴力模拟。

对于每一个时刻 $\text{tim}$，遍历每只细菌并处理状态变化。
1. 如果细菌处于未放入状态且 $\text{tim}=a_i$，则细菌状态变为未成熟。  
   未成熟细菌数量 $\text{c1}\leftarrow\text{c1}+1$。
2. 如果细菌处于未成熟状态且 $\text{tim}=a_i+t_i$，则细菌状态变为成熟。  
   未成熟细菌细菌数量 $\text{c1}\leftarrow\text{c1}-1$，成熟细菌数量 $\text{c2}\leftarrow\text{c2}+1$。
3. 成熟细菌数量翻倍 $\text{c2}\leftarrow\text{c2}\times2$。
4. 判断当前细菌数量 $\text{c1}+\text{c2}$ 与 $m$ 的关系：
   - 若 $\text{c1}+\text{c2}<m$，继续下一时刻；
   - 若 $\text{c1}+\text{c2}=m$，成功找到数量等于 $m$ 的时刻，输出。
   - 若 $\text{c1}+\text{c2}>m$，说明数量等于 $m$ 的时刻已错过，输出无解。

注意：顺序不可颠倒，细菌成熟一定要在数量翻倍前处理。

时间复杂度 $O(n\max{a_i+t_i})$，其中 $\max{a_i+t_i}=2\times10^9$。

下面的代码中，为了代码简洁，$t_i\leftarrow t_i+a_i$。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;

char buf[1<<20], *p1, *p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)

inline ll read() {
	ll x=0, f=1; char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
	while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	return x*f;
}

#define N 200010
ll n, m, c1, c2;
ll tim;
ll a[N], t[N];

signed main() {
	// freopen("1", "r", stdin);
	// freopen("1.o", "w", stdout);
	n=read(), m=read();
	for (int i=1; i<=n; ++i) a[i]=read();
	for (int i=1; i<=n; ++i) t[i]=read();
	while (c1+c2<m) {
		++tim;
		for (int i=1; i<=n; ++i) { // 未放入 -> 未成熟
			if (a[i]) continue;
			if (!t[i]) continue;
			--t[i]; if (!t[i]) --c1, ++c2;
		}
		for (int i=1; i<=n; ++i) { // 未成熟 -> 成熟
			if (!a[i]) continue;
			--a[i]; if (!a[i]) ++c1;
		}
		c2*=2;
	}
	printf("%lld\n", c1+c2==m?tim:-1);
	return 0;
}

```

接着我们发现，**不是每一个时刻都有细菌发生状态转变**，而**在出现成熟细菌之前**只有状态改变时细菌数量**才发生变更**。

考虑在出现成熟细菌之前对状态更改作加速处理。  
具体地，维护一个小根堆 $q$，记录下一次状态变更发生的时间。每次取出堆顶，将时间跳到堆顶对应的时间。

而在出现成熟细菌后，时间变回原流逝速度，逐秒处理。

具体流程如下:
1. 小根堆维护三个信息：细菌编号 $\text{idx}\in[1,n]$、细菌当前状态 $\text{sta}\in\{0,1\}$ 和下一次状态变更时间 $t$，记作 $(t,\text{idx},\text{sta})$。变更时间 $t$ 作为第一关键字。
2. 对于 $\forall i\in[1,n]$，向堆中插入 $(a_i,i,0)$。
3. 时间跳跃，进行完一次操作后直接跳到下一次操作的开始时间。  
   每次取出堆顶 $f$：
   - 对于 $\text{sta}=0$，即未放入的细菌，转变状态为“未成熟”。更改细菌数量后重新放入堆中。  
     $\text{c1}\leftarrow\text{c1}+1$，向堆中插入 $(a_f+t_f,f,1)$。  
	 执行时间跳跃 $\text{tim}\leftarrow a_f$。
   - 对于 $\text{sta}=1$，即未成熟的细菌，转变状态未“已成熟”。更改细菌数量后弹出堆。  
     $\text{c1}\leftarrow\text{c1}-1$，$\text{c2}\leftarrow\text{c2}+1$。  
	 <!-- 同时，第一次处理到该情况时，应**停止时间跳跃**。 -->
4. 若未出现成熟细菌，继续执行 3 操作，否则停止时间跳跃，执行 5 操作。
5. 逐秒操作，查看当前秒是否有操作需要执行。  
   更新时间 $\text{tim}\leftarrow\text{tim}+1$ 和数量 $\text{c2}\leftarrow\text{c2}\times2$。  
   重复执行操作直到该秒内没有操作。即对于堆顶 $f$，满足条件 $\text{tim}=t_f$ 即取出堆顶进行操作：
   - 对于 $\text{sta}=0$，即未放入的细菌，转变状态为“未成熟”。更改细菌数量后重新放入堆中。  
     $\text{c1}\leftarrow\text{c1}+1$，向堆中插入 $(a_f+t_f,f,1)$。
   - 对于 $\text{sta}=1$，即未成熟的细菌，转变状态未“已成熟”。更改细菌数量后弹出堆。  
     $\text{c1}\leftarrow\text{c1}-1$，$\text{c2}\leftarrow\text{c2}+2$。
6. 从 5 操作开始重复执行。
7. 每一次时间变化（跳跃或递增）都处理答案，判断 $\text{c1}+\text{c2}$ 和 $m$ 的大小关系。

关于新加入的成熟细菌：为方便代码实现，先将当前时刻叠加，$\text{c2}$ 倍增，再添加与当前时刻一致的新成熟细菌。新的数量初始值即为 $2$。

**处理当前秒时，需要一次处理完**，不然会出现以下情况：  
当前秒存在多个细菌发生状态变化，细菌数量在一秒内多次发生变更。这些变更应算作一次，但在处理过程中算成了多次，导致某一次 $\text{c1}+\text{c2}=m$，无解 $\rightarrow$ 有解。

---
### 正确性证明
由于在堆上操作，保证堆顶的操作始终是时间最小的。同时，跳过的时间内不存在其它操作。  
因此，时间递增的操作顺序与堆顶的操作位置，可以保证 $\text{tim}$ 内的全部操作不遗漏。正确性得以保证。

---
### 实现
小根堆可用优先队列结合 `greater<>` 实现。我的代码中，队列元素是 `pair<ll,pair>`。  
一次处理完当前秒，可以使用 `while ()` 循环，判断堆顶元素的时间和当前时间是否相等。

注意：使用 `while` 弹堆顶时，一定要先判堆是否为空。空栈表示所有细菌均为成熟状态。

---
### 时间复杂度分析
产生成熟细菌前，一个细菌最多进堆两次，出堆两次，是常数级别。时间跳跃次数 $\le$ 出堆次数。  
第一个成熟细菌产生后，它的个数会在 $O(\log_2m)$ 个 $\text{tim}$ 内突破 $O(m)$ 量级。

总时间复杂度上界为 $O(n\log n+n\log n\log m)$，但不会跑满。

---
### 代码
下面的代码中，为了代码简洁，$t_i\leftarrow t_i+a_i$。

[AC](https://www.luogu.com.cn/record/185602951) 8.34MB 122ms
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
typedef long long ll;

char buf[1<<20], *p1, *p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)

inline ll read() {
	ll x=0, f=1; char ch=getchar();
	while (ch<'0'||ch>'9') {if (ch=='-') f=-1; ch=getchar();}
	while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	return x*f;
}

#define N 200010
typedef pair<ll,pair<int,bool>> plib;
#define fi first
#define se second
#define mkp make_pair
ll n, m, c1, c2;
ll tim; // 当前时间
ll a[N], t[N]; // 放入时间 | 成熟时间
priority_queue<plib, vector<plib>, greater<plib>> q; // 小根堆

void pcs() { // 处理堆顶元素：时间跳跃并处理状态变更
	auto f=q.top(); q.pop(), tim=f.fi;
	if (f.se.se) --c1, c2+=2; // 未成熟 -> 成熟
	else q.push(mkp(t[f.se.fi], mkp(f.se.fi, 1))), ++c1; // 未放入 -> 未成熟
}

signed main() {
	// freopen("a.in", "r", stdin);
	n=read(), m=read();
	for (int i=1; i<=n; ++i) a[i]=read(), q.push(mkp(a[i], mkp(i, 0)));
	for (int i=1; i<=n; ++i) t[i]=a[i]+read();
	while (!c2) {
		do pcs(); while (!q.empty()&&q.top().fi==tim);
		// pcs(); while (!q.empty()&&q.top().fi==tim) pcs(); // 这两种写法是等价的
		// ↑ 先跳一下时间，再将相同时间的细菌全部处理 ↑
		if (c1+c2==m) return printf("%lld\n", tim), 0; // 判断是否满足答案要求
	}
	while (c1+c2<m) {
		++tim, c2*=2LL; // 时间递增 | 数量倍增
		while (!q.empty()&&q.top().fi==tim) pcs(); // 处理当前时间状态变更
		// ↑ 这里不跳时间，只处理与当前时间相同的变更 ↑
	}
	printf("%lld\n", c1+c2==m?tim:-1);
	return 0;
}

```

---
### 写在后面
看到单调性就首先考虑二分。

[@Kketchup](https://www.luogu.com.cn/user/551760)：正常人谁能想出这种做法。  
是的，我们整个机房都写的二分。

这道题是今天模拟赛的第一题，由于方法偏门且细节处理不当，我得到了 $14$ 分的[好成绩](https://loj.ac/s/2187997)。

写完这篇题解后，我在[官方题解](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-solutions.pdf)的 T6 Subtask 4 中找到了类似的描述。由于根本看不懂俄语，我也不知道是不是一样的。

最后推销一下蒟蒻的 [Blog](https://algo-x.cn/) QWQ

---

## 作者：signed_long_long (赞：0)

# 题目解法
我们能发现细菌的数量总是不会下降，所以考虑二分。check 函数就按题目里说的算，在最后在算一遍，如果算出来的结果等于 $m$，就输出答案，否则就不可能。

但是，此题有坑，对于溢出的情况，需要特判，如果爆了，就 `return LONG_LONG_MAX;`。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[200500],t[200500];
int max(int x,int y){
	if(x>y)return x;
	return y;
}
int check(int x){
	int ans=0;
	for(int i=1;i<=n;i++){
		if(x>=a[i]){//解冻完成 
			int y=max(1ll*0,x-(a[i]+t[i]-1));
			if(y>=50) return LONG_LONG_MAX;//爆了
			ans+=1ll<<y;
			if(ans>=(1ll<<50)){
				return LONG_LONG_MAX;//爆了
			}
		}
	}
	return ans;
}
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",a+i);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",t+i);
	}
	int l=0,r=1e18,ans=-1;
	while(l<r){
		int mid=l+((r-l)>>1);
		if(check(mid)<m){
			l=mid+1;
		}else{
			r=mid;
			ans=mid;
		}
	}
	if(check(ans)==m) printf("%lld",ans);
	else printf("-1");
	return 0;
}
```

写在最后：借鉴了一下[这篇题解](https://www.luogu.com.cn/article/pbdb8v1w)，在此表示感谢！

---

## 作者：BFSDFS123 (赞：0)

不怎么聪明的题。

观察到细菌数目总是单调不降，毫不犹豫直接二分！

考虑 check 函数代表时刻为 mid 的时候细菌个数，随便二分即可。

check 的写法可以参考如下代码内的注释。

```cpp
int qpow(int a,int b)
{
    int res=1;
    bool flag=0;
    while(b)
    {
        if(b&1)
        {
            if(flag) return -1;
            res=res*a;
            if(res>m) return -1; // 
        }
        a=a*a;
        if(a>m) flag=1;
        b>>=1;
    }
    return res;
}
int check(int mid)
{
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        if(Ar[i]<=mid && Ar[i]+t[i]-1>=mid) cnt++; // 被放进去，休眠
        else if(Ar[i]<=mid) // 从休眠期出来了，开始分裂
        {
            int tot=mid-(Ar[i]+t[i]-1);
            int type=qpow(2,tot);
            if(type==-1) return inf;
            cnt+=type;
        }
    }
    return cnt;
}
```

注意在计算 2 的幂时候需要判断是否溢出（大于 $m$）的情况，不要写成大于等于，否则会 Wa 50pts。

完整代码 [LOJ submission](https://loj.ac/s/2178106)。

---

## 作者：reductt (赞：0)

感觉这题是道水绿啊。

首先会发现随着天数的增加，细菌的个数是不会变少的，所以满足单调性，直接二分天数，$\text{check}$ 的时候直接按题意模拟一遍算就好了，时间复杂度 $O(nlogn)$，写的时候记得判断溢出之类的。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define u128 __int128
#define fir find_first
#define sec second
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FOR_(i,a,b) for(int i=b;i>=a;i--)
namespace FastIO{
    int buf[100]={0},p=0;
    int rd(){
        int x=0,f=1;char c=getchar();
        while(c<'0'||'9'<c){if(c=='-')f=-1;c=getchar();}
        while('0'<=c&&c<='9')x=x*10+c-'0',c=getchar();
        return x*f;
    }void write(int x){
        if(!x){putchar('0');return;}
        if(x<0)putchar('-'),x=-x;
        while(x)buf[++p]=x%10,x/=10;
        while(p)putchar(buf[p--]+'0');
    }
}
#define rd FastIO::rd
#define write FastIO::write
typedef unsigned long long ull;
typedef pair<int,int> pii;
const int N=2e5+10;
int n,m,a[N],t[N];
int get(int mid){
	int sum=0;
	FOR(i,1,n){
		if(mid<a[i])continue;
		int j=max(1ll*0,mid-(a[i]+t[i]-1));
		if(j>=50)return LLONG_MAX;
		sum+=1ll<<j;
		if(sum>=(1ll<<50))return LLONG_MAX;
	}
	return sum;
}
signed main(){
	n=rd(),m=rd();
	FOR(i,1,n)a[i]=rd();
	FOR(i,1,n)t[i]=rd();
	int l=0,r=1e12,ans=-1;
	while(l<r){
		int mid=(l+r)>>1;
		if(get(mid)<m)l=mid+1;
		else r=mid,ans=mid;
	}
	write((get(ans)==m)?ans:-1),puts("\n");
	return 0;
}
```

---

## 作者：iPhoneSX (赞：0)

## 题解
随着时间增加，细菌的数目一定是不降的，所以我们可以二分时间，找到**细菌数目小于 $m$ 的最后一个时刻 $t$**，如果 $t+1$ 时刻细菌数目正好等于 $m$，就输出，否则输出 $-1$。

下面有几个细节需要注意：
- 由于细菌出现时间和成熟时间会很长，所以二分上界需要很大，这里我取了 $3\times10^9$ 作为上界。
- 在统计确定时刻细菌的数目时，对于每个细菌，采取等比数列求和的方式，次数太高会爆，所以一旦发现次数高于 $\log_2 m$ 就赶紧返回。
- 建议提前预处理 $2$ 的次幂，这样会快一些。

代码如下：
```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<iomanip>
#include<iostream>
#include<list>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<string>
#include<vector>
#define ll long long
#define int long long
#define DBG(x) cout << #x << "=" << x << endl
#define inf 0x3f3f3f3f
#define mod 998244353
#define N 200005
using namespace std;
template <typename T>
void read(T& x) {
    x = 0;
    ll t = 1;
    char ch;
    ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            t = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    x *= t;
}
template <typename T, typename... Args>
void read(T& first, Args&... args) {
    read(first);
    read(args...);
}
template <typename T>
void write(T y) {
    T x = y;
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9) {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}
template <typename T, typename... Ts>
void write(T arg, Ts... args) {
    write(arg);
    if (sizeof...(args) != 0) {
        putchar(' ');
        write(args...);
    }
}
int n,m,a[N],t[N],poww[N],top;
bool check(int x){
	int sum=0;
	for(int i=1;i<=n;i++){
		if(x<a[i]){
			continue;
		}
		else if(x>=a[i]&&x<a[i]+t[i]){
			sum=sum+1;
		}
		else{
			if(x-a[i]-t[i]+1>top){
				return 0;
			}
			sum=sum+poww[x-a[i]-t[i]+1];
		}
		if(sum>=m){
			return 0;
		}
	}
	return 1;
}
signed main(){
	read(n,m);
	poww[0]=1;
	for(int i=1;i<=60;i++){
		poww[i]=poww[i-1]*2;
	}
	for(int i=1;i<=n;i++){
		read(a[i]);
	}
	for(int i=1;i<=n;i++){
		read(t[i]);
	}
	top=log2(m)+1;
	int l=0,r=3000000000,ans=0;	
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)){
			ans=mid;
			l=mid+1;
		}
		else{
			r=mid-1;
		}
	}
	int sum=0;
	ans++;
	for(int i=1;i<=n;i++){
		if(ans<a[i]){
			continue;
		}
		else if(ans>=a[i]&&ans<a[i]+t[i]){
			sum=sum+1;
		}
		else{
			sum=sum+poww[ans-a[i]-t[i]+1];
		}
	}
	if(sum==m){
		write(ans);
		putchar('\n');
	}
	else{
		cout<<-1;
		putchar('\n');
	}
	return 0;
}
``````

---

## 作者：Nagato_ (赞：0)

一道很水的绿题。

首先，我们容易发现，在时间增加后，细菌的总数一定不会变小，因为没有取出细菌或者类似的操作。所以我们进行二分答案，使用一个 `check` 函数计算某时间的细菌数量，然后与要求的值进行比较即可。

注意以下几个细节：

- 细菌数量不会变小，但也不是一定会增加，比如考虑所有细菌都没有成熟的情况。所以即使找到一个时间值刚好能让细菌数量是 $m$，也要继续二分答案尝试更小的时间值。

- 有可能没有任何一个时间能使得细菌总数为 $m$，所以要在二分找到一个答案后仍然判断一次再输出，也就是输出 $-1$ 的情况。

- 在细菌刚好成熟时，它会立刻分裂成两个细菌。

- `check` 函数中，每次增加答案时都应与 $m$ 比较，以防超出 `int` 存储范围（当然，如果你使用了下文的边界条件，同时开启 `long long`，那你就可以直接一次性加完再比较了喵~）

对于二分边界，我们考虑到 $1\le m \le 10^9$，所以可能的最大答案就是最小的 $a_i+t_i+29$，因为此时细菌会分裂成 $2^{30}$ 个，一定会大过 $m$。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,a[200010],t[200010] , l , r = 2e9 + 10 , mid , c[35] , na ;

int chk(int x)
{
	int s = 0;
	for(int i=1;i<=n;i++)
	{
		if( x >= a[i] + t[i] )
		{
			if( s + c[ ( x - a[i] - t[i] + 1 ) ] <= m )
				s += c[ ( x - a[i] - t[i] + 1 ) ] ;
			else
				return m + 10;
		}
		else if( x >= a[i] ) 
			s++;
	}
	return s;
}

int main() 
{
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
		
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t[i]);
		r = min( r , a[i] + t[i] );
	}
	
	r += 29;
	
	c[0] = 1;
	for(int i=1;i<=30;i++)
		c[i] = c[i-1]*2;
		
	while( l < r )
	{
		mid = (l+r)>>1;
		
		na = chk(mid);
		
		if( na < m )
			l = mid+1 ;
		else if( na == m )
			r = mid ;
		else
			r = mid - 1 ;
	}
	
	if( chk(l) == m )
		printf("%d",l); 
	else
		printf("-1");
	return 0;
}
```

---

## 作者：doooge (赞：0)

一道水绿。

由于随着时间增长，细菌个数肯定是单调不降的，于是我们很容易就可以想到二分答案，即需要花的时间。特别的，由于细菌是指数级增长的，所以特判一下，以防爆 long long，因为当细菌繁殖超过 $30$ 秒后，数量一定要大于 $m (m \le 10 ^ 9 < 2^{30} )$。

注意一下，若在最后二分出来的时间时，细菌的个数并不是 $m$，需要输出 `-1`。

```cpp
#include<bits/stdc++.h>
#define int long long//保险起见开个long long
using namespace std;
int a[1000010],t[1000010],n,m;
int check(int x){
	long long cnt=0;
	for(int i=1;i<=n;i++){
		if(x<a[i])continue;//没有放进培养皿 
		if(x<a[i]+t[i])cnt++;//没有成熟 
		else if(x-a[i]-t[i]+1>30)return 1e18;//为了防止cnt爆掉，特判一下（m一定小于2^30） 
		else cnt+=1<<(x-a[i]-t[i]+1); //加上现在的细菌的个数 
	}
	return cnt;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>t[i];
	}
	int l=1,r=1e9;//二分需要的时间 
	while(l<r){
		int mid=(l+r)/2;
		if(check(mid)>=m){
			r=mid;
		}
		else l=mid+1;
	}
	if(check(l)!=m)cout<<-1<<endl;//无解 
	else cout<<l<<endl;
	return 0;
}
```

其余就没什么好说的了，祝大家 rp++ 。

---


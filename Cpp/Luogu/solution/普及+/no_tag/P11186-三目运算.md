# 三目运算

## 题目描述

三目运算是一种比较特殊的运算，功能类似于 `if` 语句，其语法格式如下：

`条件?数值1:数值2`，三目运算得到的结果也是数值。当条件成立时得到的结果是数值 1，不成立时得到的结果为数值 2。

例如，`x>5?8:6` 就是一种三目运算表达式（也是分段常数表达式，见下文）。当 $x=7$ 时，该表达式的结果为 $8$，而 $x=3$ 时，该表达式的结果为 $6$。

---

本题中，称满足下列条件中**至少一条**的字符串 $S$ 是**分段常数表达式**：

- 十进制正整数 $a$，如 `243`，是分段常数表达式。
- 如果 $a$ 为一个十进制正整数，$p,q$ 为两个分段常数表达式，则 $\texttt{x>}a\texttt{?}p\texttt{:}q$ 是分段常数表达式。
- 如果 $a$ 为一个十进制正整数，$p,q$ 为两个分段常数表达式，则 $\texttt{x<}a\texttt{?}p\texttt{:}q$ 是分段常数表达式。

（后两条条件中， $x>a$ 和 $x<a$ 是条件，$p,q$ 为数值，该表达式是三目运算表达式。）

例如，`x>154?220:x<37?16:10` 是一个分段常数表达式，因为 `220` 和 `x<37?16:10` 都是分段常数表达式，从而整个表达式由第 2 条规则也是分段常数表达式。

---

给出一个分段常数表达式 $S$，保证出现的正整数均不超过 $m$。

yummy 有 $q$ 个询问，每次给出一个自然数 $x$ 的值，希望你求出分段常数表达式的值。

## 说明/提示

【样例 1 解释】

如果我们进行适当的换行和缩进可以得到：

```cpp
x>12?    //如果 x>12
  x<15?  //那么判断 x<15 是否成立
    4    //如果是则得到 4
    :10  //如果不是则得到 10
  :x<12? //否则（如果 x<=12) 判断 x<12 是否成立
    14   //如果是则返回 14
    :7   //如果不是则返回 7
```

按照这个思路模拟即可得到样例输出。

【样例 2 解释】

该样例满足测试点 $6$ 的性质。

【样例 3 解释】

该样例满足测试点 $10$ 的性质。

【样例 4 解释】

该样例满足测试点 $19$ 的性质。

【数据范围】

设 $n$ 为 $S$ 中三目运算符的个数。（选手可以通过 $n$ 来估计 $S$ 的串长。）

对于全体数据，保证 $0\le n\le 10^5$，$1\le m\le 10^5$，$1\le q\le 10^5​$，$1\le x\le 10^9$，且 $S$ 是分段常数表达式。

| 测试点编号  | $n\le$ | $m\le$ | $q\le$ |
|:-:|:-:|:-:|:-:|
| $1$         | $0$    | $10^5$ | $10$   |
| $2$         | $1$   | $10^5$ | $10$   |
| $3\sim 5$   | $100$ | $9$    | $10$   |
| $6\sim 9$   | $100$ | $10^5$ | $10$   |
| $10\sim 12$ | $10^5$ | $9$    | $10$   |
| $13\sim 16$ | $10^5$ | $10^5$ | $10$   |
| $17\sim 18$ | $10^5$ | $9$    | $10^5$ |
| $19\sim 25$ | $10^5$ | $10^5$ | $10^5$ |

## 样例 #1

### 输入

```
20 5
x>12?x<15?4:10:x<12?14:7
15
12
14
7
1000000```

### 输出

```
10
7
4
14
10
```

## 样例 #2

### 输入

```
参见 expr/expr2.in```

### 输出

```
参见 expr/expr2.ans```

## 样例 #3

### 输入

```
参见 expr/expr3.in```

### 输出

```
参见 expr/expr3.ans```

## 样例 #4

### 输入

```
参见 expr/expr4.in```

### 输出

```
参见 expr/expr4.ans```

# 题解

## 作者：yummy (赞：25)

# C. 三目运算 (expr) 官方题解

本题考察的主要知识点：

- 【4】递归法

### 建立框架

考虑计算机要求一个 $x$ 对应的值（设表达式的第一个字符为 `S[s]`），要分为如下几个步骤：

- 检查是否纯数值。（如果表达式无三目运算，则第一个字符 `S[s]` 一定是数字。）如果是，则直接得到这个数值。
- 分析条件：现在 `S[s+1]` 是大于或小于号，`S[s+2]`开始是一个数字。
- 处理条件成立情形：这也是一个分段常数表达式，在条件的数字部分结束后一个字符开始，可以**递归**处理。
- 处理条件不成立情形：从条件成立情形结束后的位置后一个字符开始，也可以递归处理。
- 返回值：根据 $x$ 所在的分支得到对应的返回值。

我们发现，在函数给表达式求值的同时，还需要记录表达式最后一个字符的位置（否则表达式的另一个分支就不知道从哪里开始）。

然后，“从表达式指定位置开始读取一个数值，然后返回数字结束的位置”也是常用功能，如果使用一个函数简化一下，代码会更清晰。

### 实现暴力

如果大家有接触过快速读入模板，那么写法是相近的，但是本题不需要处理负数。

下面的函数实现读取 $x$ 的值，然后返回最后一个数字后一个位置的下标。

```cpp
int m,q;
char S[2000005];
int getint(int s,int &x){
	x=0;
	while(isdigit(S[s])){
		x=x*10+(S[s]^'0');
		s++;
	}
	return s;
}
```

下面是递归处理表达式的参考写法。

```cpp
struct result{int val,len;};
result calc(int s,int x){
	if(isdigit(S[s])){
		int tmp;
		int len=getint(s,tmp);
		return {tmp,len};
	}
	int sep;
	int stt=getint(s+2,sep);
	result pos=calc(stt+1,x);
	result neg=calc(pos.len+1,x);
	if(S[s+1]=='>' && x>sep || S[s+1]=='<' && x<sep)
		return {pos.val, neg.len};
	else
		return {neg.val, neg.len};
}
```

这样 `calc` 时间复杂度为 $O(|S|)$，因为有 $q$ 次询问，总时间复杂度 $O(|S|q)$。

### 优化

我们能不能只读取一次表达式，就把所有 $1\sim m+1$ 之内的 $x$ 都求出来呢？（当 $x>m$ 时，显然表达式的值没有区别，因此只要求到 $m+1$ 即可。）

我们发现，对于一个分支嵌套，能进入到某一个分支的 $x$，必然在一个区间内。因此可以把 `calc` 函数改成 `calc(int s,int l,int r)`，表示对于所有 $l\le x\le r$，计算表达式的值，并存入全局数组 `res` 当中。

解析表达式部分的代码比较接近，但是不同之处在于递归。现在每次递归，你需要把 $l\sim r$ 这个区间根据是否符合条件拆成两个小区间分别求值。时间复杂度 $O(|S|+m+q)$。

下面给出参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,q,res[100005];
char S[2000005];
int getint(int s,int &x){
	x=0;
	while(isdigit(S[s])){
		x=x*10+(S[s]^'0');
		s++;
	}
	return s;
}
int calc(int s,int l,int r){
	if(isdigit(S[s])){
		int tmp;
		int ret=getint(s,tmp);
		for(int i=l;i<=r;i++)
			res[i]=tmp;
		return ret;
	}
	int sep;
	int stt=getint(s+2,sep);
	if(S[s+1]=='>'){
		int neg=calc(stt+1,sep+1,r);
		return calc(neg+1,l,sep);
	}
	else{
		int neg=calc(stt+1,l,sep-1);
		return calc(neg+1,sep,r);
	}
}
int main(){
	scanf("%d%d%s",&m,&q,S);
	calc(0,1,m+1);
	for(;q;q--){
		int x;
		scanf("%d",&x);
		printf("%d\n",res[min(x,m+1)]);
	}
	return 0;
}
```

---

## 作者：Lyria (赞：9)

你可以对于每一个询问操作离线并按照从小到达顺序排列，因为题目中的三目运算等同于不等式，而答案一定对应原串的一段连续区间。

例如 $[1,2,3,4,5]$ 在三目运算符 $\texttt{x>2?1:5}$ 可以分成 $[1,2]$ 与 $[3,4,5]$ 继续递归计算，而断点由于序列有序即可以二分。

对于一个三目运算串，一定有与他配对的 $\texttt{?}$ 与 $\texttt{:}$，所以在 dfs 前我们记录每个 $\texttt{?}$ 所对应的 $\texttt{:}$ 即可递归。

时间复杂度 $O(\text{len} \times \log q)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 5000005
using namespace std;
int n,m,son[N],res[N],a[N];
string s;
struct node{
	int x,id;
	bool operator<(const node&t)const{
		return x<t.x;
	}
}q[N];
void getson(){
	stack<int> pos;
	for(int i=1;i<=n;i++){
		if(s[i]=='?') pos.push(i);
		else if(s[i]==':') son[pos.top()]=i+1,pos.pop();
	}
}
void dfs(int u,int l,int r){
	if(l>r) return ;
	if(s[u]!='x'){
		int t=0,i;
		for(i=u;i<=n&&s[i]>='0'&&s[i]<='9';i++) t=(t*10+s[i]-'0');
		for(int i=l;i<=r;i++) res[q[i].id]=t;
		return ;
	}
	int t=0,i;
	for(i=u+2;i<=n&&s[i]>='0'&&s[i]<='9';i++) t=(t*10+s[i]-'0');
	if(s[u+1]=='>'){
		int pos=upper_bound(a+l,a+r+1,t)-a;
		dfs(i+1,pos,r);
		dfs(son[i],l,pos-1);
	}
	else{
		int pos=lower_bound(a+l,a+r+1,t)-a;
		dfs(i+1,l,pos-1);
		dfs(son[i],pos,r);
	}
}
signed main(){
	cin>>m>>m>>s;n=s.size();
	s=" "+s;
	for(int i=1;i<=m;i++) cin>>q[i].x,q[i].id=i;
	sort(q+1,q+m+1);
	for(int i=1;i<=m;i++) a[i]=q[i].x;
	getson();
	dfs(1,1,m);
	for(int i=1;i<=m;i++) cout<<res[i]<<"\n";
}
```

---

## 作者：MnZnOIer (赞：9)

赛场上卡了好久，最后五分钟写出来了但是没来得及交上去导致挂分。

### 解题思路
看数据范围，在线算法肯定不行，要么预处理，要么离线。

我用的是递归预处理。对于一个三目运算符，先考虑对于条件为真或者假都跑一遍，用一个 $to_i$ 记录对于一个 $s_i=\texttt{?}$ 对应的 $s_j=\texttt{:}$，这样为真时向 $i+1$ 递归，否则向 $to_i+1$ 递归。并且递归时带上区间，方便在递归的底层进行差分修改。

递归方式说完了，我们来讲预处理。对于递归到的一个串，如果他中间只包含数字，那么他肯定就是对当前递归的区间进行修改。否则，这又是一个三目运算符，继续向下递归。

值得注意的是，$x\le 10^9$，对于比 $m$ 大的 $x$，我们可以令 $x\to m+1$，这样 $x$ 依旧满足原先 $x$ 满足的所有条件。
### 代码部分
可以结合注释理解。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e6 + 5;
int n, m, q, to[N], st[N], top, sum[N];
//to 记录对应的冒号；
//st，top 是栈，用来统计 to；
//sum 是前缀和数组。
string s;
void dfs (int d, int l, int r)
{
	if (d > n)return;//超过范围
	int ss = 0, i = d, f = 0, ff;
	while (s[i] != '?' && i <= n)//找三目运算符的条件。
	{
		if (isdigit (s[i]))//是数字就统计。
		{
			ss = ss * 10 + s[i] - '0';
			if (f)ff = 1;//前面有符号。
			else ff = 2;
		}
		if (s[i] == '<')f = 1;//判断符号。
		if (s[i] == '>')f = 2;
		if (s[i] == ':')break;//当找到冒号时，说明这个串里没有三目运算符了，直接返回。
		++ i;
	}
	if (! f)//找到冒号的情况也会被算进来。
	{
		sum[l] += ss;//差分修改。
		sum[r + 1] -= ss;
		return;
	}
    //f + ff == 3 其实有两种情况，f = 1, ff = 2 或者 f = 2，ff = 1，这两种情况通过调换不等式两边的值和不等号，都是 x < ss 的情况。需要记得区间是是小于，不是小于等于。
	if (f + ff == 3)dfs (i + 1, max (l, ss + 1), r), dfs (to[i] + 1, l, min (r, ss));
	if (f == ff)dfs (i + 1, l, min (r, ss - 1)), dfs (to[i] + 1, max (l, ss), r);//同上。
	return; 
}
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> m >> q;
	cin >> s;
	n = s.size ();
	s = " " + s;
	for (int i = 1; i <= n; ++ i)
	{
		if (s[i] == '?')st[++ top] = i;//统计 to。
		if (s[i] == ':')to[st[top --]] = i;
	}
	dfs (1, 1, m + 1);//递归预处理。
	for (int i = 1; i <= m + 1; ++ i)sum[i] += sum[i - 1];//前缀和计算每个数放在原式中的值。
	while (q --)
	{
		int x;
		cin >> x;
		if (x > m)x = m + 1;//一定要记得。
		cout << sum[x] <<'\n';
	}
	return 0;
}
```

Update：
- 10.23 修改原来代码，并感谢 @hy1089knigh
提供的 hack。

我们会发现，对于这个 hack，这份代码通过不了。
```
10 5
x>4?3:x<9?x>7?3:10:6
214187352
4
8
2
6
```

经过认真思考发现，我们对表达式的两种取值都会递归，但事实上，对于 $l=1,r=4$ 时，如果表达式为 $x<9$，取值一定为真，这个时候，当前代码就会寄掉。

修改也是很简单的，特判一下 $r<ss$ 和 $l>ss$ 的情况就好了。

下面时修改后的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e6 + 5;
int n, m, q, to[N], st[N], top, sum[N];
//to 记录对应的冒号；
//st，top 是栈，用来统计 to；
//sum 是前缀和数组。
string s;
void dfs (int d, int l, int r)
{
	if (d > n)return;//超过范围
	int ss = 0, i = d, f = 0, ff;
	while (s[i] != '?' && i <= n)//找三目运算符的条件。
	{
		if (isdigit (s[i]))//是数字就统计。
		{
			ss = ss * 10 + s[i] - '0';
			if (f)ff = 1;//前面有符号。
			else ff = 2;
		}
		if (s[i] == '<')f = 2;//判断符号。
		if (s[i] == '>')f = 1;
		if (s[i] == ':')break;//当找到冒号时，说明这个串里没有三目运算符了，直接返回。
		++ i;
	}
	if (! f)//找到冒号的情况也会被算进来。
	{
		sum[l] += ss;//差分修改。
		sum[r + 1] -= ss;
		return;
	}
    //f + ff == 3 其实有两种情况，f = 1, ff = 2 或者 f = 2，ff = 1，这两种情况通过调换不等式两边的值和不等号，都是 x < ss 的情况。需要注意区间是是小于，不是小于等于。
	if (f + ff == 3)
	{
		if (r < ss)dfs (i + 1, l, r);//右端点小于该数，一定只有满足的情况。 
		else if (l > ss)dfs (to[i] + 1, l, r);
		else dfs (i + 1, l, ss - 1), dfs (to[i] + 1, ss, r);
	}
	if (f == ff)
	{
		if (l > ss)dfs (i + 1, l, r);//同上。
		else if (r < ss)dfs (to[i] + 1, l, r);
		else dfs (i + 1, ss + 1, r), dfs (to[i] + 1, l, ss);
	}
}
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> m >> q;
	cin >> s;
	n = s.size ();
	s = " " + s;
	for (int i = 1; i <= n; ++ i)
	{
		if (s[i] == '?')st[++ top] = i;//统计 to。
		if (s[i] == ':')to[st[top --]] = i;
	}
	dfs (1, 1, m);//递归预处理。
	for (int i = 1; i <= m; ++ i)sum[i] += sum[i - 1];//前缀和计算每个数放在原式中的值。
	while (q --)
	{
		int x;
		cin >> x;
		if (x > m)x = m;//一定要记得。
		cout << sum[x] <<'\n';
	}
	return 0;
}
```

---

## 作者：Mr_RedStone (赞：5)

## 很好题目，使我脑干旋转

###### ~~和 2022 一样 yue 的表达式。~~

主要突破口在 $m$ 的范围上，观察数据发现 $1 \le m \le 10^5$，可以预处理。

考虑当询问的 $x$ 大于 $m$ 时会发生什么，**发现一定是所有 $x>a$ 的条件会被满足，$x<a$ 的条件必不满足。** 由此可代入一个极大值先算出整个表达式的结果，当输入 $x>m$ 时直接输出该结果。

对于所有询问的 $x$ 小于 $m$ 的情况进行预处理。

建立一颗具有如下节点的树。
```cpp
struct Node{
	int ub,lb;
	int x;
	int l,r;
	Node(){
		ub=INF;
		lb=-INF;
		x=-1;
	}
}a[2000005];
```

其中 ```ub,lb``` 表示**能访问到该节点的 $x$ 的值所在的开区间，即 $lb < x < ub$**。```x```表示该节点返回值，**只有叶子节点有返回值，其他节点返回值为 $-1$。** ```l,r``` 为左右子节点编号。

不难发现可以对该树上的叶子节点进行遍历，区间 $(lb_i,ub_i)$ 内的答案就是该叶子节点的返回值 $x_i$。维护一个 $ans$ 数组记录答案，询问时调用即可。

AC 代码，复杂度 $O(n+m)$，$n$ 为表达式中三目运算的次数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=2e9;
int m,q;
string s;
struct Node{
	int ub,lb;
	int x;
	int l,r;
	Node(){
		ub=INF;
		lb=-INF;
		x=-1;
	}
}a[2000005];
int pos[2000005];
int maxn,maxx;
void build(int id,int l,int r){
	if(s[l]!='x'){
		a[id].x=atoi(s.substr(l,r-l+1).c_str());
		maxx=max(maxx,a[id].x);
		return;
	}
	a[id].l=++maxn;
	a[id].r=++maxn;
	a[a[id].l].lb=a[id].lb;
	a[a[id].l].ub=a[id].ub;
	a[a[id].r].lb=a[id].lb;
	a[a[id].r].ub=a[id].ub;
	char op=s[l+1];
	int t=0;
	int ppp=0;
	for(int i=l+2;i<=r;i++){
		if(s[i]=='?'){
			ppp=i;
			break;
		}
		t=t*10+(s[i]-'0');
	}
	maxx=max(maxx,t);
	if(op=='>'){
		a[a[id].l].lb=max(a[a[id].l].lb,t);
		a[a[id].r].ub=min(a[a[id].r].ub,t+1);
	}
	else{
		a[a[id].l].ub=min(a[a[id].l].ub,t);
		a[a[id].r].lb=max(a[a[id].r].lb,t-1);
	}
	build(a[id].l,ppp+1,pos[ppp]-1);
	build(a[id].r,pos[ppp]+1,r);
}
int calc(int id,int x){
	if(a[id].x!=-1){
		return a[id].x;
	}
	if(x>a[a[id].l].lb&&x<a[a[id].l].ub){
		return calc(a[id].l,x);
	}
	return calc(a[id].r,x);
}
int ans[100005];
int main(){
	scanf("%d %d",&m,&q);
	cin>>s;
	stack<int> st;
	for(int i=0;i<s.size();i++){
		if(s[i]=='?'){
			st.push(i);
		}
		if(s[i]==':'){
			int t=st.top();
			st.pop();
			pos[t]=i;
		}
	}
	maxn=1;
	build(1,0,s.size()-1);
	for(int i=1;i<=maxn;i++){
		if(a[i].x==-1||a[i].lb>=a[i].ub){
			continue;
		}
		int l=(a[i].lb==-INF?0:a[i].lb);
		int r=(a[i].ub==INF?maxx+1:a[i].ub);
		for(int j=l+1;j<r;j++){
			ans[j]=a[i].x;
		}
	}
	int maxt=calc(1,m+1);
	while(q--){
		int x;
		scanf("%d",&x);
		printf("%d\n",(x<=maxx?ans[x]:maxt));
	}
	return 0;
}
```

考场上没删文件输入输出，爆零力 qwq。

提示：如果本地过不了测试样例 #3 和 #4，可能是本地的内存空间被限制了，在编译指令里加上 ```-Wl,--stack=536870912``` 调大栈空间。

---

## 作者：_JF_ (赞：4)

[Link](https://www.luogu.com.cn/problem/P11186)

我是先开第四题再开第三题的选手。这题感觉就很 CCF。

直接模拟显然是 $O(qn)$ 的，然后我们考虑优化。

容易看到我们对每个数处理其实都是一个“选择”的过程。

我们不妨对他上树。具体的在这个题中有两种点，一种是 `x>14` 的表达式，或者是 `10` 这样的单独的数字，我们都抽象成节点。

观察到，如果是 `x>14` 这样的表达式，显然 `?` 后面的那个点就是左节点，和该 `?` 匹配的 `:` 后面的那个点就是右节点。

维护哪个 `:` 和 `?` 匹配就是平凡的栈即可。

显然对 `x>14` 这样的状物，他一定有两个儿子，对于 `14` 这样的数字，他不会有儿子。

然后我们把询问进行一个离线，排序。

因为这样做，在进行如 `x>14` 这样的判断时， $[l,r]$ 这些询问就能恰好分成两个连续的区间，$[l,x]$ 走左节点，$[x+1,r]$ 走右节点。

如果当前点没有儿子，代表走完了，直接暴力赋值就行了。

这个复杂度容易分析，对于一个点我们只用 $O(\log n)$ 的时间把询问拆成两个部分，然后对每个点的赋值操作我们只用做一次。

建树是 $O(n)$ 的，所以时间复杂度是 $O(n\log n)$。

对了，注意特判 $n=0$，因为我就是因为这个没有场切这个题，见笑了。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =4e6+10;
#define DEBUG cout<<"when can get npy"<<endl;
//#define int long long
char s[N];
stack<int> sta;
vector<int> g[N];
int tot,Vus[N],n,m,t,ls[N],rs[N],prenum[N],ans[N];
struct node{
	int Judge,val;
}a[N];
struct Query{
	int id,val;
}Q[N];
bool cmp(Query a,Query b){
	return a.val<b.val;
}
void Add(int u,int v){
	g[u].push_back(v),g[v].push_back(u);
}
int change(string P){
	int sum=0;
	for(int i=0;i<P.size();i++){
		int now=(int)(P[i]-'0');
		sum=sum*10+now;
	}
	return sum;
}
void Slove(int u,int l,int r){
	if(l>r)	return ;
	if(a[u].Judge==0){
		for(int i=l;i<=r;i++)	ans[Q[i].id]=a[u].val;
		return ;
	}
	if(a[u].Judge==1){
		int now=upper_bound(prenum+l,prenum+r+1,a[u].val)-prenum;
//		if(u==1)	cout<<now<<endl;
		Slove(rs[u],l,now-1),Slove(ls[u],now,r);
	}
	if(a[u].Judge==-1){
		
		int now=lower_bound(prenum+l,prenum+r+1,a[u].val)-prenum; //
//		cout<<ls[u]<<" "<<l<<" "<<now-1<<endl;
		Slove(ls[u],l,now-1);
		Slove(rs[u],now,r); 
	}
}
signed main(){
//	freopen("expr4.in","r",stdin);
//	freopen("ans.out","w",stdout);
	scanf("%d%d",&m,&t);
	scanf("%s",s+1);
	n=strlen(s+1);
	if(isdigit(s[1])){
		string p;
		for(int i=1;i<=n;i++)	p+=s[i];
		int now=change(p);
		while(t--){
			int x;
			cin>>x;
			cout<<now<<endl;
		}
		return 0;
	}
//	cout<<n<<endl,exit(0);
	for(int i=1;i<=n;i++){
		if(s[i]=='x'){
			tot++; string p;
			if(s[i-1]=='?')	ls[Vus[i-1]]=tot; 
			else if(s[i-1]==':'){
				int now=sta.top(); sta.pop();
				rs[Vus[now]]=tot; 
			}
			while(s[i]!='?'){
				if(isdigit(s[i]))	p+=s[i];
				if(s[i]=='>')	a[tot].Judge=1;
				else if(s[i]=='<')	a[tot].Judge=-1;
				i++;
			}
			a[tot].val=change(p);
			Vus[i]=tot,sta.push(i);
			continue;
		}
		else if(isdigit(s[i])){
			tot++; 
			if(s[i-1]=='?')	ls[Vus[i-1]]=tot;
			else{
				int now=sta.top(); sta.pop();
				rs[Vus[now]]=tot;
			}
			string p;
			while(isdigit(s[i]))	p+=s[i],i++;
			a[tot].val=change(p);
			i--;
		}
	}
	
	for(int i=1;i<=t;i++)	cin>>Q[i].val,Q[i].id=i;
	sort(Q+1,Q+t+1,cmp);
	for(int i=1;i<=t;i++)	prenum[i]=Q[i].val;
	Slove(1,1,t);
//	cout<<1;
	for(int i=1;i<=t;i++)	printf("%d\n",ans[i]);
	return 0;
}
/*

20 5
x>12?x<15?4:10:x<12?14:7
15
12
14
7
1000000
*/


```

---

## 作者：2huk (赞：4)

我们将每个三目运算符抽象成二叉树上的一个点。然后令其左儿子为「数值1」，右儿子为「数值2」。特别的，若这两个儿子是十进制数，则单独为这样的十进制数做编号。

不难发现，这样建出的二叉树的叶子节点一定都是十进制数。

我们在这颗树上进行 dfs。在从根往叶子递归的过程中，维护 $L, R$ 表示只有当 $L < x < R$ 时程序才会进行到这个树点。特别的，若 $R - L \le 2$ 则停止递归。

这样当访问到叶子时，我们就能得知：若 $L < x < R$，那么整个分段常数表达式的值就是这个叶子所代表的十进制数。

代码比较丑陋：

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 5e6 + 10, INF = 1e9;

int n, q;
char s[N];
int cnt;		// 树上的节点数量
int id[N];		// 如果这个位置是 ?/x/</>，给它标号。: 需要用栈处理。
int True[N], False[N];		// 第 i 个分段常数表达式，如果成立会执行哪个，如果不成立会执行哪个
int num[N];		// 如果 i 往后是一个十进制常数，先把它的值求出来
int than[N];		// 第 i 个表达式合法，必须大于 than[i] 或小于 -than[i]
pair<int, int> res[N];
int sz;

inline
void dfs(const int u, const int L, const int R) {		// 能进入这个点需要满足 > L 且 < R
	if (L + 1 > R - 1) return;
	if (!True[u] && !False[u]) {
		// 叶节点
		res[ ++ sz] = {L + 1, num[u]};
		return;
	}
	if (than[u] > 0) {
		if (True[u]) dfs(True[u], max(L, than[u]), R);
		if (False[u]) dfs(False[u], L, min(R, than[u] + 1));
	} else {
		if (True[u]) dfs(True[u], L, min(R, -than[u]));
		if (False[u]) dfs(False[u], max(L, -than[u] - 1), R);
	}
}

signed main() {
	scanf("%d%d%s", &n, &q, s + 1);
	int m = n;
	n = strlen(s + 1);
	
	bool flg = false;
	for (int i = 1; i <= n; ++ i ) flg |= s[i] == '?';
	
	if (!flg) {
		int x = 0;
		for (int i = 1; i <= n; ++ i )
			x = x * 10 + s[i] - '0';
		while (q -- ) cout << x << '\n';
		return 0;
	}
	
	stack<int> stk;
	for (int i = 1; i <= n; ++ i ) {
		if (s[i] == 'x') {
			cnt ++ ;
			id[i] = cnt;
		} else if (s[i] == '?' || s[i] == '<' || s[i] == '>') {
			id[i] = cnt;
		}
		
		if (s[i] == '?') stk.push(cnt);
		if (s[i] == ':') {
			id[i] = stk.top();
			stk.pop();
		}
	}
	
	for (int i = 1; i <= n; ++ i )
		if ((s[i - 1] == '?' || s[i - 1] == ':') && isdigit(s[i])) {
			int x = 0;
			for (int j = i; j <= n && isdigit(s[j]); ++ j ) {
				x = x * 10 + s[j] - '0';
			}
			id[i] = ++ cnt;
			num[id[i]] = x;
		}
	
	for (int i = 1; i <= n; ++ i ) {
		if (s[i] == '?') {
			True[id[i]] = id[i + 1];
		} else if (s[i] == ':') {
			False[id[i]] = id[i + 1];
		}
	}
	
	for (int i = 1; i <= n; ++ i )
		if (s[i - 1] == '>' || s[i - 1] == '<') {
			int x = 0;
			for (int j = i; j <= n && isdigit(s[j]); ++ j ) {
				x = x * 10 + s[j] - '0';
			}
			than[id[i - 1]] = s[i - 1] == '>' ? x : -x;
		}
	
	dfs(1, 0, INF + 1);
	
	sort(res + 1, res + sz + 1);
	
	while (q -- ) {
		int x;
		cin >> x;
		int lo = 1, hi = sz, ans;
		while (lo <= hi) {
			int mid = lo + hi >> 1;
			if (res[mid].first <= x) {
				ans = mid;
				lo = mid + 1;
			} else {
				hi = mid - 1;
			}
		}
		cout << res[ans].second << '\n';
	}
	
	return 0;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

这是一个小模拟。

首先发现分段常数表达式是二叉性的，故考虑建二叉树。

注意到 `?` 和 `:` 类似于左括号和右括号，可以用栈跑匹配。

设分段常数表达式的长度为 $m$，令 $rt = \operatorname{Fun}(1,m)$，其中 $\operatorname{Fun}(l,r)$ 表示区间 $[l,r]$ 内组成的表达式的根的下标。

在 $[l,r]$ 中，肯定是一个数字或者一个 `x op a ? p : q`  这样的形式，可以通过判断 $s_l$ 是否是 `x` 得出。

如果是数字，则读入后创建新节点返回即可。

若是一个 `x op a ? p : q` 的形式，则考虑找到这个 `?` 的位置，注意到这个 `?` 一定是 $[l,m]$ 中第一个 `?`，直接二分即可；然后可以通过之前跑的括号匹配得到 `:` 的位置。

设 `?` 的位置为 $x$，`:` 的位置为 $y$，则这个点的左儿子是 $\operatorname{Fun}(x+1,y-1)$，右儿子是 $\operatorname{Fun}(y+1,r)$。

这样我们就以 $O(N \log N)$ 的时间建完了树。

然后对于询问，若每次询问都在树上跑一遍的话，时间复杂度最坏为 $O(QN)$。

因为树不会修改，考虑初始在根节点处放下 $[1,10^9]$ 这个区间，然后根据 `x > a` 和 `x < a` 进行分裂；最后到达叶子节点存下。

则询问的时候二分找对应的区间即可，总时间复杂度为 $O((N + Q) \log N)$。

**建树和分裂区间可以放在一起做，交给读者自己实现啦。**

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const ll N=5e6+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Expr{
	ll x;
	bool op;
};
struct Node{
	ll x;
	Expr get;
	ll lchild,rchild;
	bool op;
}a[N];
struct Seg{
	ll l,r;
	ll v;
	Seg(ll _l=0,ll _r=0,ll _v=0){l=_l,r=_r,v=_v;}
	bool operator<(const Seg&rhs)const{
		return l<rhs.l;
	}
}h[N];
ll n,m,x,rt,val,cnt,top;
ll nxt[N];
stack<ll> T;
set<ll> S;
char s[N];
ll get(ll l,ll r){
//	cerr<<l<<' '<<r<<'\n';
	ll id=++cnt;
	if(s[l]!='x'){
		a[id].op=0;
		ll x=0;
		For(i,l,r)
		  x=x*10+(s[i]-'0');
		a[id].x=x;
	}
	else{
		a[id].op=1;
		ll x=*S.lower_bound(l);
		ll y=nxt[x];
		if(s[l+1]=='<')
		  a[id].get.op=0;
		else
		  a[id].get.op=1;
		ll h=0;
		For(i,l+2,x-1)
		  h=h*10+(s[i]-'0');
		a[id].get.x=h;
		a[id].lchild=get(x+1,y-1);
		a[id].rchild=get(y+1,r);
	}
//	cerr<<id<<'\n';
	return id;	
}
void solve(ll x,ll l,ll r){
	if(!x||l>r)
	  return ;
	if(a[x].op){
		if(a[x].get.op){
			solve(a[x].lchild,max(a[x].get.x+1,l),r);
			solve(a[x].rchild,l,min(a[x].get.x,r));
		}
		else{
			solve(a[x].lchild,l,min(a[x].get.x-1,r));
			solve(a[x].rchild,max(a[x].get.x,l),r);
		}
	}
	else
	  h[++top]={l,r,a[x].x};
}
int main(){
//	open("A.in","A.out");
	read(),n=read();
	scanf("%s",s+1);
	m=strlen(s+1);
	For(i,1,m){
		if(s[i]=='?'){
			S.insert(i);
			T.push(i);
		}
		if(s[i]==':'){
			nxt[T.top()]=i;
			T.pop();
		}
	}
	rt=get(1,m);
	solve(rt,1,1e9);
	sort(h+1,h+top+1);
	while(n--){
		x=read();
		write(h[upper_bound(h+1,h+top+1,Seg(x,0,0))-h-1].v);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：篮网总冠军 (赞：2)

写一篇题解，以纪念我赛场上切了这道题。

看一眼题目，是一道模拟题。

我们可以知道，三目运算符是将判断的数分为两种情况，满足的返回前面的值，不满足的返回后面的值。那我的第一反应就是，先对这个字符串进行处理，枚举出返回的范围，然后直接二分查找答案。

但是，我们会发现一个问题：如果有的值不可能被返回，也就是没有范围怎么办呢？

那就不记录这个值就可以了。

这题的遍历也有一定难度，我的思路是这样的：

+ 如果遍历到数，就判断范围是否符合要求，符合存储即可，返回遍历结束的位置。

+ 如果遍历到三目运算符，就先把前缀去掉继续递归，接受返回值后进行后半部分的递归，再返回遍历的位置。

这样，我们就记录了所有符合要求的范围。

因为所有符合要求的范围一定是互不重合的，我们只要记录 $l$ 即可。

注意，**$r$ 的初值一定是一个很大的数，比如 $10^9$。**

最后对于每组询问二分查找。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;

int cnt;
struct node{
	int l,s;
}a[200005];
bool cmp(node x,node y){
	return x.l<y.l;
}
string s;
int dfs(int start,int l,int r){
	int j=start;
	if ('0'<=s[start]&&s[start]<='9') {
		int x=0;
		while('0'<=s[j]&&s[j]<='9') x=x*10+s[j]-'0',j++;
		if (l>r) return j+1;
		a[++cnt].l=l;
		a[cnt].s=x;
		return j+1;
	}
	char v=s[start+1];
	int x=0;
	j+=2;
	while(s[j]!='?') x=x*10+s[j]-'0',j++;
	int l1=l,r1=r;
	if (v=='>') l1=max(l1,x+1);
	else r1=min(r1,x-1);
	j++;
	int rt=dfs(j,l1,r1);
	int l2=l,r2=r;
	if (v=='<') l2=max(l2,x);
	else r2=min(r2,x);
	int ygp=dfs(rt,l2,r2);
	return ygp;
}
int main(){
//	freopen("expr2.in","r",stdin);
//	freopen("expr.out","w",stdout);
	ios::sync_with_stdio(false);
	int m,q;
	cin>>m>>q;
	cin>>s;
	dfs(0,0,1e9);
	sort(a+1,a+1+cnt,cmp);
	while(q--){
		int x;
		cin>>x;
		int l=1,r=cnt;
		while(l<r){
			int mid=(l+r+1)/2;
			if (a[mid].l<=x) l=mid;
			else r=mid-1;
		}
		cout<<a[l].s<<endl;
	}
	return 0;
}
```

---

## 作者：Camellia2025 (赞：2)

~~关于我数组不够大只在赛场拿了 36 分的事。~~

## 72pts

我们发现，表达式很像一个二分。

那么可以记 $lower$ 数组为一个 ```?``` 对应的 ```:``` 的位置，这样在查找的时候，就可迅速跳至对应的位置，这个过程可以用栈。

然后我们还可以对其它部分进行处理。

首先输入里的变量 $x$ 没用，舍去。

然后数字我们可以转换为 ```int``` 类型，在原来的位置用一个空格代替即可。

像这样。


```
int change(int i, int j) {
	int val = 0;
	for (; i < len; i++) {
		if (s[i] < '0' or s[i] > '9') break;
		else val = val * 10 + (s[i] - '0');
	}
	v[j] = val;
	return i - 1;
}

inline void init() {
	stack <int> stac;
	len = strlen(s);
	int Len = 0;
	for (int i = 0; i < len; i++) {
		if (s[i] >= '0' and s[i] <= '9') {
			i = change(i, Len);
			c[Len++] = ' ';
		} else if (s[i] != 'x') {
			c[Len++] = s[i];
			if (s[i] == '?') stac.push(Len);
			if (s[i] == ':') {
				lower[stac.top() - 1] = Len - 1;
				stac.pop();
			}
		}
	}
}
```

然后对于每个值进行遍历即可。

### code


```
#include <iostream>
#include <cstring>
#include <stack>
using namespace std;

const int N = 1e7 + 10;
int m, q, len, lower[N];
int v[N], cnt;
char s[N], c[N];

int change(int i, int j) {
	int val = 0;
	for (; i < len; i++) {
		if (s[i] < '0' or s[i] > '9') break;
		else val = val * 10 + (s[i] - '0');
	}
	v[j] = val;
	return i - 1;
}

inline void init() {
	stack <int> stac;
	len = strlen(s);
	int Len = 0;
	for (int i = 0; i < len; i++) {
		if (s[i] >= '0' and s[i] <= '9') {
			i = change(i, Len);
			c[Len++] = ' ';
		} else if (s[i] != 'x') {
			c[Len++] = s[i];
			if (s[i] == '?') stac.push(Len);
			if (s[i] == ':') {
				lower[stac.top() - 1] = Len - 1;
				stac.pop();
			}
		}
	}
}

int main() {
	scanf("%d%d", &m, &q);
	scanf("%s", &s);
	init();
	len = strlen(c);
	while (q--) {
		int val;
		scanf("%d", &val);
		for (int i = 0; i < len; i++) {
			if (c[i] == '>') {
				if (val > v[i + 1]) i += 2;
				else i = lower[i + 2];
			}
			if (c[i] == '<') {
				if (val < v[i + 1]) i += 2;
				else i = lower[i + 2];
			}
			if (c[i] == ' ') {
				printf("%d\n", v[i]);
				break;
			}
		}
	}
	return 0;
}
```

## 100pts

先来解释一下为什么上述做法会 T 最后几个点。

首先我们要明白，我们只是对表达式的形式进行了遍历，完全有可能他的遍历路程是一条链，即所有的三目运算符都压在树的一侧。

它的遍历路程有可能是。

```
x > 12:
 x > 13:
  x > 14:
   x > 15:
    ...
   ...
  ...
 ...
...
```

那么它的复杂度即为平方级别的，这是我们无法接受的。

我们来考虑真正的二分。

其实它就是一个在 ```int``` 范围上的分段函数，所以可以在刚刚的预处理后，不去暴力，而是一遍 dfs 搜过去，把每一个区间都记录然后二分。

### code


```
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <stack>
using namespace std;

const int N = 1e7 + 10;
int m, q, len, lower[N];
int v[N], cnt, raw[N];
char s[N], c[N];

vector <int> ans;

int change(int i, int j) {
	int val = 0;
	for (; i < len; i++) {
		if (s[i] < '0' or s[i] > '9') break;
		else val = val * 10 + (s[i] - '0');
	}
	v[j] = val;
	return i - 1;
}

inline void init() {
	stack <int> stac;
	len = strlen(s);
	int Len = 0;
	for (int i = 0; i < len; i++) {
		if (s[i] >= '0' and s[i] <= '9') {
			i = change(i, Len);
			c[Len++] = ' ';
		} else if (s[i] != 'x') {
			c[Len++] = s[i];
			if (s[i] == '?') stac.push(Len);
			if (s[i] == ':') {
				lower[stac.top() - 3] = Len;
				stac.pop();
			}
		}
	}
}

void dfs(int i, int l, int r) {
	if (l > r) return;
	if (c[i] == '<') dfs(i + 3, l, v[i + 1] - 1), dfs(lower[i], v[i + 1], r);
	if (c[i] == '>') dfs(lower[i], l, v[i + 1]), dfs(i + 3, v[i + 1] + 1, r);
	if (c[i] == ' ') raw[r] = v[i], ans.push_back(r); 
}

int main() {
	scanf("%d%d", &m, &q);
	scanf("%s", &s);
	init();
	len = strlen(c);
	dfs(0, 1, m);
	ans.push_back(1000000000);
	while (q--) {
		int val;
		scanf("%d", &val);
		int res = distance(ans.begin(), lower_bound(ans.begin(), ans.end(), val));
		if (ans[res] == 1000000000) res--;
		cout << raw[ans[res]] << endl;
	}
	return 0;
}
```

---

## 作者：I_will_AKIOI (赞：2)

首先看到这个三目运算符，可以考虑把他转换为 `if-else` 语句，发现每个 `if` 只有一个 `else`，也就是一个语句对应两种情况，不难想到是二叉树。于是首先递归建树，接着考虑暴力查询，类似于二叉搜索树的查询，如果满条件就往左子树走，否则就往右子树走。类似的，假设 $n$ 为字符串长度，则期望复杂度为 $O(q\log n)$，但是实际会被一条链卡到 $O(qn)$。

因此考虑优化，记录发现能走到一个叶子结点的取值范围是一个区间，因此可以记录每个叶子结点管辖的区间范围，舍去不合法的区间，接着排序后二分答案，复杂度 $O(n+q\log n)$。

但是其实不需要这么麻烦，对于查询的 $x\le m+1$ 的部分，都可以视作 $x=m+1$，因此上界只有 $m+1$，直接暴力填充答案即可，可以优化到 $O(n+m+q)$。

二分答案代码：

```cpp
#include<bits/stdc++.h>
#define N 2000005
using namespace std;
struct Data{int l,r,val,f;}t[N];
char c[N];
int n,m,q,p=1,cnt=1,res;
vector<Data>v;
int get()//获取当前数字
{
  int num=0;
  while(p<=n)
  {
    if(c[p]<'0'||c[p]>'9') break;
    num=num*10+c[p]-'0';
    p++;
  }
  return num;
}
void dfs1(int k,int minn,int maxx)//表示走到编号为k的节点，取值范围为[minn,maxx]
{
  if(c[p]=='x')
  {
    p++;
    if(c[p]=='>') t[k].f=0;//f表示类型，0表示大于号，1表示小于号，-1表示叶子
    else t[k].f=1;
    p++;
    t[k].val=get();
    p++;
    t[k].l=++cnt;//每次递归前创建新节点
    if(t[k].f==0) dfs1(cnt,t[k].val+1,maxx);//按照类型分割区间
    else dfs1(cnt,minn,t[k].val-1);
    t[k].r=++cnt;
    if(t[k].f==0) dfs1(cnt,minn,t[k].val);
    else dfs1(cnt,t[k].val,maxx);
  }
  else
  {
    t[k].val=get(),t[k].f=-1,p++;
    if(minn<=maxx) v.push_back(Data{minn,maxx,t[k].val,-1});//排除不合法的区间
  }
  return;
}
bool cmp(Data x,Data y){return x.l<y.l;}
int main()
{
  ios::sync_with_stdio(0);
  cin>>m>>q>>c+1;
  n=strlen(c+1);
  dfs1(1,1,1000000000);
  sort(v.begin(),v.end(),cmp);
  while(q--)
  {
    int x;
    cin>>x;
    int l=0,r=v.size()-1,mid;
    while(l<r)//二分答案
    {
      mid=l+r+1>>1;
      if(v[mid].l<=x) l=mid;
      else r=mid-1;
    }
    cout<<v[l].val<<"\n";
  }
  return 0;
}
```

暴力填充答案代码，注释同上。

```cpp
#include<bits/stdc++.h>
#define N 2000005
using namespace std;
struct Data{int l,r,val,f;}t[N];
char c[N];
int n,m,q,p=1,cnt=1,ans[N];
int get()
{
  int num=0;
  while(p<=n)
  {
    if(c[p]<'0'||c[p]>'9') break;
    num=num*10+c[p]-'0';
    p++;
  }
  return num;
}
void dfs(int k,int minn,int maxx)
{
  if(c[p]=='x')
  {
    p++;
    if(c[p]=='>') t[k].f=0;
    else t[k].f=1;
    p++;
    t[k].val=get();
    p++;
    t[k].l=++cnt;
    if(t[k].f==0) dfs(cnt,t[k].val+1,maxx);
    else dfs(cnt,minn,t[k].val-1);
    t[k].r=++cnt;
    if(t[k].f==0) dfs(cnt,minn,t[k].val);
    else dfs(cnt,t[k].val,maxx);
  }
  else
  {
    t[k].val=get(),t[k].f=-1,p++;
    for(int i=minn;i<=maxx;i++) ans[i]=t[k].val;
  }
  return;
}
int main()
{
  ios::sync_with_stdio(0);
  cin>>m>>q>>c+1;
  n=strlen(c+1);
  dfs(1,1,m+1);
  while(q--)
  {
    int x;
    cin>>x;
    cout<<ans[min(x,m+1)]<<"\n";
  }
  return 0;
}
```

---

## 作者：liuziqin (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P11186)

## 4pts

题目中第一个测试点没有三目运算符，因此直接输出 $S$ 即可。

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int m,q;
	cin>>m>>q;
	int p;
	cin>>p;
	while(q--){
		int x;
		cin>>x;
		cout<<p<<"\n";
	}
	return 0;
}
```

## 48pts

考虑暴力递归进行模拟。

我们每次递归一个区间 $[l,r]$ ，表示当前答案存在于区间 $[l,r]$ 中。暴力用 $x$ 与当前三目运算符进行运算，如果三目运算成立，往左区间递归，不成立就往右区间递归。

我们以 `?` 为左括号， `:` 为右括号，进行**括号匹配**暴力找出区间端点即可。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
char s[5000005];
int n,q;
bool isdight(char x){
	return '0'<=x&&x<='9';
}//判断数字
int to_num(int u){
	int ans=0;
	for(int i=u;i<=n&&isdight(s[i]);i++)ans=ans*10+s[i]-'0';
	return ans;
}//char转化为数字
bool examine(int u,int x){
	char op=s[u+1];
	int t=to_num(u+2);
	if(op=='<')return x<t;
	else return x>t;
}//三目运算
int turn_l(int u){
	int i;
	for(i=u;i<=n&&s[i]!='?';i++);
	return i;
}//找出对应的 ? 
int turn_r(int u){
	int stk=0;
	for(int i=u;i<=n;i++){
		if(s[i]=='?')stk++;
		if(s[i]==':')stk--;
		if(s[i]==':'&&stk==0)return i;
	}
	return n;
}//找出对应的 : 
int solve(int l,int r,int x){
	if(l>n||r>n||l>r)return 0;
	if(isdight(s[l]))return to_num(l);
	if(examine(l,x))return solve(turn_l(l)+1,turn_r(l)-1,x);
	else return solve(turn_r(l)+1,r,x);
}//查找函数
signed main(){
	int m;
	cin>>m>>q>>(s+1);
	n=strlen(s+1);
	if(isdight(s[1])){
		while(q--)cout<<to_num(1)<<"\n";
		return 0;
	}//特判没有三目运算的情况
	while(q--){
		int x;
		cin>>x;
		cout<<solve(1,n,x)<<"\n";//查询
	}
}
```

## 72pts

对于 48 分的代码，我们的 `turn_l` 和 `turn_r` 的函数复杂度为 $O(n)$ ，显然可以通过预处理优化为 $O(1)$ 。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5000005;
char s[N];
int nxt1[N],nxt2[N];
int n,q;
bool isdight(char x){
	return '0'<=x&&x<='9';
}
int to_num(int u){
	int ans=0;
	for(int i=u;i<=n&&isdight(s[i]);i++)ans=ans*10+s[i]-'0';
	return ans;
}
bool examine(int u,int x){
	char op=s[u+1];
	int t=to_num(u+2);
	if(op=='<')return x<t;
	else return x>t;
}
int turn_l(int u){
	return nxt1[u];
}
int turn_r(int u){
	return nxt2[u];
}
int solve(int l,int r,int x){
	if(l>n||r>n||l>r)return 0;
	if(isdight(s[l]))return to_num(l);
	if(examine(l,x))return solve(turn_l(l)+1,turn_r(l)-1,x);
	else return solve(turn_r(l)+1,r,x);
}//同上
stack<int>Q;
signed main(){
	int m;
	cin>>m>>q>>(s+1);
	n=strlen(s+1);
	nxt1[n+1]=n;
	for(int i=n;i>=1;i--){
		nxt1[i]=nxt1[i+1];
		if(s[i]=='?')nxt1[i]=i;
	}//预处理 ? 的所在位置
	for(int i=1;i<=n;i++){
		if(s[i]==':'){
			if(Q.empty()){
				break;
			}
			int t=Q.top();
			Q.pop();
			nxt2[t]=i;
		}
		if(s[i]=='?')Q.push(i);
	}//括号匹配得到每个 ? 对应的 : 
	nxt2[n+1]=n;
	for(int i=n;i>=1;i--)if(!nxt2[i])nxt2[i]=nxt2[i+1];
	for(int i=1;i<=n;i++)
	if(isdight(s[1])){
		while(q--)cout<<to_num(1)<<"\n";
		return 0;
	}
	while(q--){
		int x;
		cin>>x;
		cout<<solve(1,n,x)<<"\n";
	}
}
```

## 100pts

由三目运算的本质可得，答案为 $x$ 的查询数一定在一个区间里，又因为 $q \le 10^5$ ，我们可以直接在 `solve` 函数中预处理出所有的 $ans$ ，这样查询的复杂度降为 $O(1)$ ，预处理复杂度为 $O(n)$ ，足以通过本题。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5000005;
char s[N];
int nxt1[N],nxt2[N];
int n,qry;
bool isdight(char x){
	return '0'<=x&&x<='9';
}
int to_num(int u){
	int ans=0;
	for(int i=u;i<=n&&isdight(s[i]);i++)ans=ans*10+s[i]-'0';
	return ans;
}
int turn_l(int u){
	return nxt1[u];
}
int turn_r(int u){
	return nxt2[u];
}
int ans[N];
void solve(int ql,int qr,int l,int r){
//ql,qr:目前答案区间
	if(isdight(s[l])){
		int num=to_num(l);
		for(int i=ql;i<=qr;i++)ans[i]=num;//统计答案
		return ;
	}
	int num=to_num(l+2);
	char op=s[l+1];
	int l1,r1,l2,r2;
	if(op=='<'){
		l1=ql,r1=num-1;
		l2=num,r2=qr;
	}
	if(op=='>'){
		l1=num+1,r1=qr;
		l2=ql,r2=num;
	}
	solve(l1,r1,turn_l(l)+1,turn_r(l)-1);//左区间
	solve(l2,r2,turn_r(l)+1,r);//右区间
}
stack<int>stk;
signed main(){
	int m;
	cin>>m>>qry>>(s+1);
	n=strlen(s+1);
	nxt1[n+1]=n;
	for(int i=n;i>=1;i--){
		nxt1[i]=nxt1[i+1];
		if(s[i]=='?')nxt1[i]=i;
	}
	for(int i=1;i<=n;i++){
		if(s[i]==':'){
			if(stk.empty()){
				break;
			}
			int t=stk.top();
			stk.pop();
			nxt2[t]=i;
		}
		if(s[i]=='?')stk.push(i);
	}
	nxt2[n+1]=n;
	for(int i=n;i>=1;i--)if(!nxt2[i])nxt2[i]=nxt2[i+1];
	solve(1,m,1,n);	
	while(qry--){
		int x;
		cin>>x;
		x=min(x,m);//当 x>m 时，与 x=m 的结果一致
		cout<<ans[x]<<"\n";//直接查询
	}
}
```

---

## 作者：船酱魔王 (赞：1)

## 题意回顾

给定三目运算表达式，其中无括号且仅含有常数和比大小运算式，多次求值。

## 分析

因为表达式里面内容的值域不大，所以考虑开个桶子计算出每个可能的值对应的表达式值，如果参数值大于 $ 10^5 $ 则与参数值为 $ 10^5+1 $ 是等价的。

考虑使得运算进入某个分支的参数取值集合是一段连续的区间，因此只要在表达式树上找到每个结点的对应区间，即可给每个可能的参数值来赋值上一个表达式值。

如何加速表达式树找子结点的过程？考虑一个表达式区间（子表达式），其要么是一个常数，要么是 `x?a?b:c` 的形式，第一个 `?` 表示大小于符号，`b` 或 `c` 都是子表达式。`x?a` 是很短的可以遍历，因此只需要找到每个 `?` 对应的 `:` 的位置，即可在接近于常数的复杂度内分解一个子表达式。

我们设计递归函数 `solve(l, r, vall, valr)`，表示由字符 $ l $ 到字符 $ r $ 构成的子表达式在参数取值为 $ [vall,valr] $ 区间内时会被计算到，按照以上所述方法分类讨论表达式是否为常数以及对进行非常数表达式进行分解和参数取值区间的分解即可，复杂度为 $ O(n \log w) $，$ n,w $ 分别为三目运算符个数和表达式内所有值的值域范围。

注意静态数组要开 $ 14n $ 而不是 $ n $。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <stack>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
int cnt = 0;
int n, m, q;
string str;
stack<int> sta;
vector<int> vec;
int sgn[N * 14];//?->:
int buc[N * 14];
inline int getnum(int l, int r) {
	int val = 0;
	for(int i = l; i <= r; i++) val = val * 10 + str[i] - '0';
	return val;
}
void solve(int l, int r, int vall, int valr) {
	if(vall > valr) return;
	if(str[l] != 'x') {
		int tps = getnum(l, r);
		for(int i = vall; i <= valr; i++) buc[i] = tps;
		return;
	}
	int pos = 0;
	for(int i = l; i <= r; i++) {
		if(str[i] == '?') {
			pos = i;
			break;
		}
	}
	int tps = getnum(l + 2, pos - 1);
	if(str[l + 1] == '<') solve(pos + 1, sgn[pos] - 1, vall, tps - 1), solve(sgn[pos] + 1, r, tps, valr);
	else solve(pos + 1, sgn[pos] - 1, tps + 1, valr), solve(sgn[pos] + 1, r, vall, tps);
}
int main() {
	scanf("%d%d", &m, &q);
	cin >> str;
	n = str.size();
	str = " " + str;
	for(int i = 1; i <= n; i++) {
		if(str[i] == '?') {
			sta.push(i);
		} else if(str[i] == ':') {
			sgn[sta.top()] = i;
			sta.pop();
		}
	}
	solve(1, n, 1, 1e5 + 1);
	int x;
	for(int i = 1; i <= q; i++) {
		scanf("%d", &x);
		if(x > 1e5) x = 1e5 + 1;
		printf("%d\n", buc[x]);
	}
	return 0;
}
```

---


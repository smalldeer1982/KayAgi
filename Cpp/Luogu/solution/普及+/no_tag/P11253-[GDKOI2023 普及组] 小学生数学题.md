# [GDKOI2023 普及组] 小学生数学题

## 题目描述

Moon 是一名小学生，在做作业时遇到了这样一个问题，对于给定正整数 $n,k$，求出下面表达式的值：

$$\sum_{i=1}^n \frac{i!}{i^k}$$

其中 $i!$ 表示 $i$ 的阶乘运算，即 $i!=1\times 2\times 3\times 4...\times i$。这个式子太难了，所以 Moon 希望得到你的帮助。但是因为 Moon 只学过整数运算，还没有学过实数运算，所以希望你可以帮助他求出这个式子在模 $998244353$ 意义下的值。也就是说，如果最终的结果假如化简成为最简分数 $\frac{p}{q}$，只需要输出 $p\times q^{-1} \bmod 998244353$ 即可，其中 $q^{-1}$ 为 $q$ 在模 $998244353$ 下的逆元。

## 说明/提示

### 样例解释

样例 $1$ 中，因为 $\frac{i!}{i}=(i-1)!$，所以原式等价于 $\sum_{i=1}^5 (i-1)!=34$。

### 数据范围

对于所有的数据，有 $1\le n,k\le 2 \times 10^7$；

对于 $30 \%$ 的数据，有 $k=1$；

对于另外 $30\%$ 的数据，有 $1\le k \le 3$。

## 样例 #1

### 输入

```
5 1 ```

### 输出

```
34```

## 样例 #2

### 输入

```
100 100```

### 输出

```
523011929```

## 样例 #3

### 输入

```
10000000 10000000```

### 输出

```
686183373```

# 题解

## 作者：DengDuck (赞：18)

下面我将给出 @DeepSeaSpray 当年在 GDKOI 现场讲题的视频，请忽视我的鬼叫。

![](bilibili:BV1gs4y1G7sF)

简单来说，我们有 $a^{-k}b^{-k}=(ab)^{-k}$，因此发现 $F(i)=i^{-k}$ 是完全积性函数，可以用线性筛在 $\mathcal O(n)$ 内解决。

具体方式是对于质数求 $k$ 次方的逆元，其他数字在线性筛的过程中可以拆分成两个更小的数字的乘积，于是就可以求出来了。

对于阶乘显然可以直接线性求，所以总的时间复杂度是 $\mathcal O(n)$。

下面是我很久之前写的实现，很丑：

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL mod=998244353;
inline LL ksm(LL x,LL y)
{
	LL ans=1;
	while(y)
	{
		if(y&1)ans=ans*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return ans;
}
const int N=2e7+5;
LL n,k,pw[N],fac,ans;
int tot[N],cnt,b[N];

int main()
{
	cin>>n>>k;
	pw[1]=1,fac=1;
	for(int i=2;i<=n;i++)
	{
		if(!b[i])
		{
			b[i]=i;
			tot[++cnt]=i;
			pw[i]=ksm(ksm(i,mod-2),k);
		}
		for(int j=1;tot[j]*i<=n&&j<=cnt&&tot[j]<=b[i];j++)
		{
			b[tot[j]*i]=tot[j];
			pw[tot[j]*i]=pw[tot[j]]*pw[i]%mod; 
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans=(ans+fac*pw[i]%mod)%mod; 
		fac=fac*(i+1)%mod; 
	}
	cout<<ans<<endl;
}
```

真的好想念初二的美好时光啊，但是已经回不去了......

---

## 作者：rui_er (赞：13)

所求的式子带除法，模意义下除法计算复杂度带 $\log$ 太慢了，先改写成乘法：$\sum_{i=1}^n i!\times i^{-k}$。想求这个式子，最简单的思路就是对于每个整数 $i\in[1,n]$，分别预处理出 $i!$ 和 $i^{-k}$ 的值，最后乘起来再 $O(n)$ 暴力加起来就好了！

对于 $i!$，注意到：

$$
i!=
\begin{cases}
1,&i=1\\
(i-1)!\times i,&i\ge 2\\
\end{cases}
$$

可以直接 $O(n)$ 递推。

对于 $i^{-k}$，注意到：

$$
(ij)^{-k}=i^{-k}j^{-k}
$$

因此 $i^{-k}$ 是关于 $i$ 的**完全积性函数**，且该函数进行单点求值的复杂度为 $O(\log n)$。$n$ 以内质数个数是 $O(\frac{n}{\log n})$ 的，暴力求质数处的点值之后，可以使用欧拉筛 $O(n)$ 求出。

总复杂度 $O(n)$。

```cpp
// Problem: P11253 [GDKOI2023 普及组] 小学生数学题
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P11253
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do {freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);} while(false)
#define endl '\n'
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(y < x) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

template<int mod>
inline unsigned int down(unsigned int x) {
	return x >= mod ? x - mod : x;
}

template<int mod>
struct Modint {
	unsigned int x;
	Modint() = default;
	Modint(unsigned int x) : x(x) {}
	friend istream& operator>>(istream& in, Modint& a) {return in >> a.x;}
	friend ostream& operator<<(ostream& out, Modint a) {return out << a.x;}
	friend Modint operator+(Modint a, Modint b) {return down<mod>(a.x + b.x);}
	friend Modint operator-(Modint a, Modint b) {return down<mod>(a.x - b.x + mod);}
	friend Modint operator*(Modint a, Modint b) {return 1ULL * a.x * b.x % mod;}
	friend Modint operator/(Modint a, Modint b) {return a * ~b;}
	friend Modint operator^(Modint a, int b) {Modint ans = 1; for(; b; b >>= 1, a *= a) if(b & 1) ans *= a; return ans;}
	friend Modint operator~(Modint a) {return a ^ (mod - 2);}
	friend Modint operator-(Modint a) {return down<mod>(mod - a.x);}
	friend Modint& operator+=(Modint& a, Modint b) {return a = a + b;}
	friend Modint& operator-=(Modint& a, Modint b) {return a = a - b;}
	friend Modint& operator*=(Modint& a, Modint b) {return a = a * b;}
	friend Modint& operator/=(Modint& a, Modint b) {return a = a / b;}
	friend Modint& operator^=(Modint& a, int b) {return a = a ^ b;}
	friend Modint& operator++(Modint& a) {return a += 1;}
	friend Modint operator++(Modint& a, int) {Modint x = a; a += 1; return x;}
	friend Modint& operator--(Modint& a) {return a -= 1;}
	friend Modint operator--(Modint& a, int) {Modint x = a; a -= 1; return x;}
	friend bool operator==(Modint a, Modint b) {return a.x == b.x;}
	friend bool operator!=(Modint a, Modint b) {return !(a == b);}
};

const int N = 2e7 + 5, mod = 998244353;
typedef Modint<mod> mint;

int n, k, tab[N], p[N], pcnt;
mint fac[N], invpw[N], ans;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> k;
    fac[0] = fac[1] = 1;
    rep(i, 2, n) fac[i] = fac[i - 1] * i;
    tab[1] = 1;
    invpw[1] = ~(mint(1) ^ k);
    rep(i, 2, n) {
        if(!tab[i]) {
            p[++pcnt] = i;
            invpw[i] = ~(mint(i) ^ k);
        }
        for(int j = 1; j <= pcnt && i * p[j] <= n; ++j) {
            tab[i * p[j]] = 1;
            invpw[i * p[j]] = invpw[i] * invpw[p[j]];
            if(i % p[j] == 0) break;
        }
    }
    rep(i, 1, n) ans += fac[i] * invpw[i];
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Aventurine_stone (赞：2)

## 1. 题目分析
很明显，题目只给了我们一个复杂的式子，我们就需要把它展开，一个一个的处理即可。
## 2. 题目做法
这道题需要大力优化加卡常。  
首先因为最后要求个分数的逆元，所以分子和分母的值我们要分别存下来。  
然后将式子展开一下，我们会得到 $n$ 个小式子，假如当前我们求出的在第 $i$ 个小式子前所有式子的值的分子为 $a$，分母为 $b$，那么加上当前小式子 $\frac{i!}{i^k}$，得到的值便为 $\frac{a \times i^k + b \times i!}{b \times i^k}$。那么计算公式也是很轻松的推出来了。  
接下来讲优化，首先 $i!$ 的计算必须用一个变量存着递推计算，不然必超时。~~这不是常识吗~~？  
然后就是 $i^k$ 的计算也要优化，光靠快速幂是不够的，不然 $O(n \log{n})$ 你的代码能过才怪。计算一次 $i^k$ 的时间复杂度为 $O(\log{k})$ 的，但我们知道如果 $k1 + k2 = k$，那么 $i^{k1} \times i^{k2} = i^k$，那么我们是不是可以取一些 $x$ 特判如果 $k \bmod x = 0$，那么直接用上述公式 $O(1)$ 计算呢。首先 $x$ 越小越好，且为质数，因为这样可以特判到更多的数，这道题中 $\log{k}$ 的上限为 $24$ 左右，但我们取前 $5$ 或 $6$ 个质数优化是最大的。  
最后是卡常，快速幂不要用递归版，要用循环版。
## 3. 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e7+1,mod=998244353;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int d;
inline int exgcd(int a,int b,ll &x,ll &y)
{
	if(!b)
	{
		x=1,y=0;
		return a;
	}
	d=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return d;
}
inline int qpow(ll x,int y)
{
	ll t=1;
	while(y)
	{
		(y&1)?t=t*x%mod:1;
		x=x*x%mod;
		y>>=1;
	}
	return t;
}
int n,k,cnt;
int prime[30]={0,2,3,5,7,2147483647};
ll a=1,t=1,x,y,p[N];
int main()
{
	n=read(),k=read();
	p[1]=1;
	for(int i=1;prime[i]<=n;i++,cnt++)
		p[prime[i]]=qpow(prime[i],k);
	for(int i=4;i<=n;i++)
	{
		for(int j=1;j<=cnt;j++)
			if(!(i%prime[j]))
			{
				p[i]=p[prime[j]]*p[i/prime[j]]%mod;
				break;
			}
		!p[i]?p[i]=qpow(i,k):1;
	}
	ll t1=1,t2;
	for(int i=2;i<=n;i++)
	{
		t2=p[i];
		a=(t2*a%mod+t1*t%mod*i)%mod;
		t1=t1*t2%mod,t=t*i%mod;
	}
	d=exgcd(t1,mod,x,y);
	x=(x%mod+mod)%mod;
	printf("%d",a*x%mod);
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

我们改写一下原式：

$$
\sum_{i = 1} ^ n i! \times i^{-k}
$$

$i!$ 可以 $O(n)$ 求，接下来考虑后一项如何快速求。

设函数 $F(x) = x ^ {-k}$，容易发现 $F(x)$ 是一个完全积性函数（根据初一数学知识可得），所以可以线性筛解决，时间复杂度 $O(n + \pi(n)\log_2 P) = O(n + \frac{n}{\ln n}\log_2 P)$，可以通过。

代码就不贴了。

---

## 作者：天野星河 (赞：1)

看到数据范围 $n\le 2\times10^7$，考虑 $\Theta(n)$ 做法。

$i!$ 很容易 $\Theta(n)$，不再赘述。考虑求 $i^{-k}$。

不难发现 $a^{-k} \times b^{-k}=(ab)^{-k}$，因此它是一个[完全积性函数](https://oi-wiki.org/math/number-theory/basic/#%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0)，可以线性筛 $\Theta(n)$ 求出。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e7 + 10, mod = 998244353;
vector<int> p;
int mn[N];
int pw[N];
int n, k;

constexpr int qpow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b & 1)
			(ans *= a) %= mod;
		(a *= a) %= mod;
		b >>= 1;
	}
	return ans;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	pw[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!mn[i]) {
			mn[i] = i;
			p.push_back(i);
			pw[i] = qpow(i, (mod - 2) * k % (mod - 1));
		}
		for (int j : p) {
			if (i * j > n)
				break;
			mn[i * j] = j;
			pw[i * j] = pw[i] * pw[j] % mod;
			if (!(i % j))
				break;
		}
	}
	int ans = 0;
	for (int i = 1, fac = 1; i <= n; i++) {
		(fac *= i) %= mod;
		(ans += pw[i] * fac % mod) %= mod;
	}
	cout << ans;
}
```

---

## 作者：Vct14 (赞：1)

下文中的 $p$ 均指题目所给的模数 $998244353$。

先看部分分。

对于 $k=1$ 的情况，$\sum\limits_{i=1}^n \frac{i!}{i^k}=\sum\limits_{i=1}^n (i-1)!=\sum\limits_{i=0}^{n-1}i!$。我们发现由于 $i!=(i-1)!\times i$，所有 $i!$ 是可以 $O(n)$ 预处理的。最后 $O(n)$ 相加即可。

那么同样的思路，为了实现 $O(n)$ 直接相加，由于 $\sum\limits_{i=1}^n \frac{i!}{i^k}\bmod p=\sum\limits_{i=1}^n i!\times i^{-k}\bmod p$，我们考虑将 $(i^k)^{-1}\bmod p$ 也预处理出来。

如果 $i$ 为质数，那么由费马小定理有 $(i^k)^{-1}\bmod p=(i^k)^{p-2}\bmod p$。

如果 $i$ 为合数，由欧拉筛的思想，一个合数只能被其最小的质因子和除自己外的最大因子筛掉，由于 $(ab)^k=a^k\times b^k$，我们在标记合数时记录一下即可。具体见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int mod=998244353;
const int N=2e7+2;
int prej[N];
int prec[N];
bool isp[N];
int pri[N];

int qpow(int a,int b){
	int ans=1,base=a;
	while(b>0){
		if(b&1) ans=ans*base%mod;
		base=base*base%mod;b>>=1;
	}
	return ans;
}

int inv(int a){return qpow(a,mod-2);}

signed main(){
	int n,k;cin>>n>>k;
	memset(isp,1,sizeof(isp));
	prej[1]=1;prec[1]=1;isp[1]=0;
	for(int i=2; i<=n; i++) prej[i]=prej[i-1]*i%mod;
	int cnt=0,sum=0;
	for(int i=2; i<=n; i++){
		if(isp[i]) prec[i]=inv(qpow(i,k)),pri[++cnt]=i;
		for(int j=1; j<=cnt && i*pri[j]<=n; j++){
			isp[i*pri[j]]=0;
			prec[i*pri[j]]=prec[i]*prec[pri[j]]%mod;
			if(i%pri[j]==0) break;
		}
	}
	for(int i=1; i<=n; i++) sum=(sum+prec[i]*prej[i]%mod)%mod;
	cout<<sum;
	return 0;
}
```

---

## 作者：DFM_O (赞：1)

## [P11253 题目](https://www.luogu.com.cn/problem/P11253)

### 解题思路
容易想到用快速幂加逆元暴力枚举，但显然会时间超限，尝试优化。

根据费马小定理，若 $p$ 为质数，则 $a^{-1}=a^{p-2}$，且 $a^b\bmod p=a^{b\bmod {p-1}}\bmod p$，那么

$$\begin{aligned}(\sum_{i=1}^n\frac{i!}{i^k})\bmod p&=(\sum_{i=1}^n i!\times(i^k)^{p-2})\bmod p\\&=(\sum_{i=1}^n i!\times i^{k\times(p-2)})\bmod p\\&=(\sum_{i=1}^n i!\times i^{k\times(p-2)\bmod (p-1)})\bmod p\end{aligned}$$

记 $q=k\times(p-2)\bmod (p-1)$。

时间复杂度虽然仍是 $O(n)$ 的，但常数小了不少，但是由于模运算常数很大，所以还是会时间超限。

注意到时间复杂度的瓶颈在于快速幂，不难发现快速幂计算的幂指数全部相同，只有底数不同，定义 $m_i$ 为 $i$ 最小的质因子，则对于任意一个合数 $i$，都有 $i^q={m_i}^q\times(\frac{i}{m_i})^q$。

所以我们只需用线性筛计算出 $m_i$，并用快速幂算出所有质数的 $q$ 次方，就可以不使用快速幂而算出合数的 $q$ 次方，大大减少了快速幂的使用次数（但是仍然非常极限，有的测试点能跑到 $990$ 毫秒，评测机不给力有概率时间超限）。



### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const long long p=998244353;
inline long long poww(long long a,long long b)
{
    long long ss=1;
    while(b)
    {
        if(b&1)
            ss=ss*a%p;
        a=a*a%p;
        b>>=1;  
    }
    return ss;
}
int pr[20000001],top,ss[20000001],minn[20000001];
bool pri[20000001];
inline void prime(int n)
{
    memset(pri,1,sizeof(pri));
    for(int i=1;i<=n;i++)
    	minn[i]=1e9+1;
    pri[1]=false;
    for(int i=2;i<=n;i++)
    {
        if(pri[i])
			pr[++top]=i;
        for(int j=1;j<=top&&i*pr[j]<=n;j++)
        {
            pri[i*pr[j]]=0,minn[i*pr[j]]=min(minn[i*pr[j]],pr[j]);
            if(i%pr[j]==0)
				break;
        }
    }
}
signed main()
{
	ios::sync_with_stdio(false);
	prime(20000000);
	int n,k,s=1,sh=1;
	cin>>n>>k;
	int zh=k*(p-2)%(p-1);
	for(int i=1;i<=top;i++)
		ss[pr[i]]=poww(pr[i],zh);
	for(int i=2;i<=n;i++)
	{
		sh=sh*i%p;
		if(pri[i]==0)
			ss[i]=ss[minn[i]]*ss[i/minn[i]]%p;
		s=(s+sh*ss[i]%p)%p;
	}
	cout<<s;
	return 0;
}
```

---

## 作者：D2T1 (赞：1)

直接做是 $O(n\log n)$ 的，过不去。考虑 $f(x)=\dfrac 1{x^k}$ 是积性函数，于是算出 $p$ 为质数时的 $f(p)$ 后线性筛即可求出所有 $f(x)$。

质数数量是 $O(\dfrac n{\ln n})$ 的，单次计算 $\dfrac 1{p^k}$ 复杂度 $O(\log k)$，若 $n,k$ 同阶则复杂度为 $O(n)$，可以通过。

---

## 作者：JustPureH2O (赞：0)

[更好的阅读体验](https://justpureh2o.cn/articles/11253)

题目地址：[P11253](https://www.luogu.com.cn/problem/P11253)

> 求出和式 $\sum\limits_{i=1}^n\frac{i!}{i^k}$ 的值，$1\leq n,k\leq2\times10^7$

开始我以为这只是一道快速幂的大水题，$5min$ 敲了一个快速幂然后测试了一下大样例，发现 T 飞了。于是我又用上了不知从哪道题里学来的十进制快速幂，结果还是不行。最后我又类比十进制快速幂写了个百进制快速幂，希望能过一些点，最后还是全 T……

注意到维护阶乘的复杂度是 $\mathcal O(n)$，实际上该题的瓶颈在于如何快速求出 $1\sim n$ 内每个数的 $k$ 次幂。其次，注意到 $(ab)^k=a^kb^k$，也即 $f(ab)=f(a)f(b)$，显然是一个积性函数。

又发现线性筛在筛去合数时有一个乘积的形式，于是我们可以借用这个思路，在筛去合数的同时维护这个函数。

```cpp
#include <bits/stdc++.h>
#define MOD 998244353
#define N 20000010
using namespace std;

typedef long long ll;

int n, k;
int cnt = 0;
ll prime[N], p[N];
bool st[N];

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res % MOD;
}

ll inv(ll x) {
    return qpow(x, MOD - 2);
}

void sieve() {
    p[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            prime[++cnt] = i;
            p[i] = inv(qpow(i, k));
        }
        st[i] = true;
        for (int j = 1; i * prime[j] <= n; j++) {
            if (prime[j] > p[i] || j > cnt) break;
            st[i * prime[j]] = true;
            p[i * prime[j]] = p[prime[j]] * p[i] % MOD; // 维护积性函数
            if (i % prime[j] == 0) break;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    cin >> n >> k;
    sieve();
    ll fac = 1;
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        fac = fac * i % MOD; // 线性维护阶乘
        ans = (ans + fac * p[i] % MOD) % MOD; // 计算
    }
    cout << ans << endl;
    return 0;
}
```

$\texttt{The End}$

---

## 作者：WorldMachine (赞：0)

阶乘直接求，至于 $x^{-k}$，用线性筛出 $n$ 以内所有素数，共 $\mathcal O\left(\dfrac{n}{\log n}\right)$ 个，每个素数 $p$ 用快速幂求出 $p^{-k}$，合数的 $x^{-k}$ 可以在线性筛的同时维护。时间复杂度 $\mathcal O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e7 + 5, p = 998244353;
int n, k, sum, tot, pri[N], inv[N];
bool vis[N];
int qpow(int a, int b) {
	int c = 1;
	while (b) {
		if (b & 1) c = (ll)c * a % p;
		a = (ll)a * a % p, b >>= 1;
	}
	return c;
}
void sieve() {
	inv[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) pri[++tot] = i, inv[i] = qpow(i, k * ll(p - 2) % (p - 1));
		for (int j = 1; j <= tot && (ll)i * pri[j] <= n; j++) {
			vis[i * pri[j]] = 1, inv[i * pri[j]] = (ll)inv[i] * inv[pri[j]] % p;
			if (!(i % pri[j])) break;
		}
	}
}
int main() {
	cin >> n >> k;
	sieve();
	for (int i = 1, fac = 1; i <= n; i++) fac = (ll)fac * i % p, sum = (sum + (ll)fac * inv[i]) % p;
	cout << sum;
}
```

---

## 作者：_JF_ (赞：0)

[P11253 [GDKOI2023 普及组] 小学生数学题 ](https://www.luogu.com.cn/problem/P11253)

两年前自己还不会这题。

直接暴力做应该就是 $60$。

然后我们发现每次花时间求 $i^k$ 的逆元很浪费时间。考虑优化。

注意到如果 $p1 \times p2 =i$，那么 $i^k=p1^k \times p2^k$。

所以直接线性筛，保证筛到每个数一次，如果是质数我们就大力算，不是的话就用上面那个思想 $O(1)$ 计算即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =2e7+10;
const int mod=998244353;
#define int long long 
int tot,k,n,vis[N],f[N],prime[N],Ans[N];
int Quickpow(int a,int b){
	int sum=1,now=a;
	while(b>0){
		if(b&1)	sum*=now,sum%=mod;
		now*=now,now%=mod,b>>=1;
	}
	return sum;
}
void init(){
	int ans=1;
	f[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=(f[i-1]%mod*i)%mod;
		if(!vis[i])	prime[++tot]=i,Ans[i]=Quickpow(Quickpow(i,k),mod-2);
		for(int j=1;j<=tot&&i*prime[j]<=n;j++){
			vis[i*prime[j]]=true;
			Ans[i*prime[j]]=(Ans[i]*Ans[prime[j]])%mod;
			if(i%prime[j]==0)	break;
		}
	}
	for(int i=1;i<=n;i++)	ans+=(f[i]*Ans[i])%mod,ans%=mod;
	printf("%lld\n",ans);
}
signed main() {
	scanf("%lld%lld",&n,&k); 
	init();
	return 0;
}
```

---


# 第一首歌

## 题目背景

$$
\begin{array}{cr}
\text{在燥热的黑暗中}\\
\text{折叠陈旧的心}\\
\text{不禁开始自我怀疑}\\
\text{布满}\overset{\text{Wrong Answer}}{\text{谬误}}\text{的曾经}\\
&\text{——《第一首歌》}
\end{array}
$$

![](bilibili:62989560)

---

那个绝对不能忘却的人，如今还能在回忆中找到些许线索吗？

她的名字，即使只记得一部分，泠珞也想要请你帮忙还原呢。

## 题目描述

给定一个字符串 $s$，请求出一个最短的字符串 $t$，满足 $s$ 是 $t$ 的**最长** border。

称字符串 $s$ 是字符串 $t$ 的 border，当且仅当 $s$ 是满足以下三者皆成立的字符串：

- $s$ 为 $t$ 的前缀。
- $s$ 为 $t$ 的后缀。
- $s$ 不为 $t$。

如果有多个可能的最短的 $t$，输出任意一个均可。

## 说明/提示

**【样例 #1 解释】**

$t=\texttt{qwqwq}$ 的最长 border 为 $s=\texttt{qwq}$，且可以证明**不存在**更小的符合要求的 $t$，所以输出是正确的。

$t=\texttt{qwqaqwq}$ 符合条件，但是它不是最短的，所以不是可能的输出。

$t=\texttt{qwqwqwq}$ 不符合条件，因为它的最长 border 为 $\texttt{qwqwq}$。

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le |s|\le 1\times10^6$，$s$ 仅由小写英文字母构成。其中，$|s|$ 表示 $s$ 的长度。 

| 子任务编号 | 分值 | $\vert s\vert\le $ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $17$ | $4$ | 无 |
| $2$ | $29$ | $3\times10^3$ | 无 |
| $3$ | $11$ | $1\times10^6$ | $s$ 仅由一种字符组成 |
| $4$ | $43$ | $1\times10^6$ | 无 |


## 样例 #1

### 输入

```
qwq```

### 输出

```
qwqwq```

## 样例 #2

### 输入

```
lingyu```

### 输出

```
lingyulingyu```

## 样例 #3

### 输入

```
aaaaaaabaa```

### 输出

```
aaaaaaabaaaaaaabaa```

# 题解

## 作者：yyyhy (赞：6)

[题目传送](https://www.luogu.com.cn/problem/P11276)  
[blog 食用](https://www.luogu.com.cn/article/9q60e5wv)

本题解目前提供 hash，kmp 和 SA 做法。

Updated on 2024·12·1 增加 kmp 做法，更正样例。  
Updated on 2025·7·13 修复挂掉的云剪贴板。

## 一、分析

### 推结论

首先进行题意分析，题目要求最短的 $t$，直接枚举 $t$ 肯定是不现实的，所以要对 $s$ 进行处理。

所以我们来分析样例：

`qwq` → `qwqwq`  
`lingyu` → `lingyulingyu`  
`aaaaaaabaa` → `aaaaaaabaaaaaaabaa`

发现两个样例中间都有重复的部分，所以我们用括号标出中间用了两次的部分，如下：

`qwq` → `qw(q)wq`  
`lingyu` → `lingyu()lingyu`  
`aaaaaaabaa` → `aaaaaaab(aa)aaaaabaa`

不难发现，括出来的部分是 $s$ 的最长 border，也就是求一个最长的串 $s'$（可以为空）使 $s'$ 既是 $s$ 的前缀，又是 $s$ 的后缀，且不为 $s$，这样这个 $s'$ 就可以用两次。（这个是后面说的假设）  
$t$ 即为 $s-s'+s$。

## 二、证明

### 1. 证明 $s$ 是 $t$ 的 border

因为 $s'$ 为 $s$ 的前缀，所以可令 $s=s'+s''$，于是 $t=s-s'+s=s-s'+s'+s''=s+s''$，满足 $s$ 是 $t$ 的前缀。

又因为 $s'$ 为 $s$ 的后缀，所以可令 $s=s'''+s'$，于是 $t=s-s'+s=s'''+s'-s'+s=s'''+s$，满足 $s$ 是 $t$ 的后缀。

所以 $s$ 是 $t$ 的 border。

### 2. 证明 $t$ 是满足条件的最短的

如果有比 $t$ 更短的 $r$ 满足条件，设中间用两次的部分为 $r'$，那么 $r'$ 会长于 $s'$，且 $r'$ 既是 $s$ 的前缀，又是 $s$ 的后缀，如图，与假设矛盾。

![](https://cdn.luogu.com.cn/upload/image_hosting/z1fxk978.png?x-oss-process=image/resize,m_lfit,h_600,w_1000)

### 3. 证明 $s$ 是 $t$ 最长的 border

若存在更长的 $q$ 是 $t$ 的 border，那么可令 $t=q+q''=q'''+q$。

于是如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3qipo0pv.png?x-oss-process=image/resize,m_lfit,h_600,w_1000)

然后记 $q'$ 左端点到 $s'$ 右端点这一段为 $p$，那么如下图推断：

![](https://cdn.luogu.com.cn/upload/image_hosting/vg3pq5i1.png?x-oss-process=image/resize,m_lfit,h_600,w_1000)

通过 $q$ 转换位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/qv2qgoks.png?x-oss-process=image/resize,m_lfit,h_600,w_1000)

于是我们发现 $p$ 既为 $s$ 前缀，又为 $s$ 后缀，且长于 $s'$，这与假设矛盾，不成立。

所以 $s$ 是 $t$ 最长的 border。

所以现在问题就变成了求 $s$ 的最长 border，即 $s'$。

## 三、解决问题

首先，我们会想到枚举，即从 $n-1$ 到 $0$ 枚举 $|s'|$，复杂度 $O(n^2)$，加特殊性质可以干到 57pts，数据加强前实际 100pts，当然，现在~~骗不过了~~。

然后我们想优化：

### 字符串哈希

据说这是这道题黄题的原因，但我太蒟了，不会。

终于学会 hash 了！——2024·11·16  

### hash 做法（11·16补充）

其实这个比较好实现，就是算出长度为 $i$ 的前缀和后缀的 hash，从 $n-1$ 开始（因为不能 $s'=s$）枚举到 $1$，有 hash 相等就记录跳出，最后输出。

但是众所周知，hash 非常好卡，所以为了保险我们用双 hash。

但是众所周知，双 hash 也能卡，所以为了追求 $100\%$ 正确率，最好加一层判断，从大到小判断每一对双 hash 都相等的前后缀是否真的一样，一样就跳出循环，也就是写一个无错双 hash。  
~~这都卡那我就 T 罢（悲~~

于是取两个比较大的质数 $mod_1$ 和 $mod_2$，也就是代码中的 $m_1$ 和 $m_2$，进行 hash 操作，我取了 $10000003$ 和 $10000007$，因为有乘法，所以要开 `long long`。

hash 的计算比较简单就不介绍了，看代码应该看得懂。

其中：  
$hash_1[0][i]$ 指 $\bmod m_1$ 情况下的前 $i$ 位 hash，  
$hash_1[1][i]$ 指 $\bmod m_1$ 情况下的后 $i$ 位 hash，  
$hash_2[0][i]$ 指 $\bmod m_2$ 情况下的前 $i$ 位 hash，  
$hash_2[1][i]$ 指 $\bmod m_2$ 情况下的后 $i$ 位 hash。

[hash 代码](https://www.luogu.com.cn/paste/ybei2866)，复杂度极大概率是 $O(n)$，卡死（应该做不到）$O(n^2)$。

这个比 SA 快多了，最慢 32ms。

### KMP/AC 自动机

没学过，也不会。（wtcl/kk）

学会了，但是 AC 自动机跟 kmp 没啥区别，不打了，打一个 kmp 做法。——2024·12·1

前文已经证明问题就是求 $s$ 的最长 border，也就是求出 $kmp[len]$ 就可以了，不会的这里有[板子](https://www.luogu.com.cn/problem/P3375)，剩下的就简单了。

[kmp 代码](https://www.luogu.com.cn/paste/lvoc5kv8)，这个速度最快，最慢 16ms。

#

于是我开始尝试用考场的第一反应：

### SA（后缀数组）

[板子在这里](https://www.luogu.com.cn/problem/P3809)

这玩意我就不多介绍了，板子题解里讲的非常详细。

但是板子题的题解也说了，光求后缀数组一般是没用的，还要求一个东西，就是每个**后缀**和后缀数组中**排序相邻的后缀**的**最大公共前缀长**。

先求再说：

```cpp
for (int i = 1, h = 0; i <= n; i++) {
    if (h) h--;
    int j = sa[rk[i] + 1];
    while (i + h <= n && s[i + h] == s[j + h]) h++;
    sam[rk[i]] = h;
}
```

解释一下：

定义 $sam[i]$ 为 $sa[i]$ 开始的后缀与 $sa[i+1]$ 开始的后缀的最大公共前缀长。

本来每两个后缀数组中相邻的后缀分别枚举会到 $O(n^2)$，但有一个特殊性质可以帮我们优化复杂度：  
假设 $sam[sa[rk[i]]]=h$，那么 $sam[sa[rk[i+1]]]\geq h-1$。

reason：假设 $i$ 开始的后缀和 $j$ 开始的后缀最大公共前缀长为 $h>0$，那么 $i+1$ 开始的和 $j+1$ 开始的最大公共前缀长至少为 $h-1$，故 $sam[sa[rk[i+1]]]\geq h-1$。  
这样由于 $h$ 不能超过 $n$ 且最多被减 $n-1$ 次 $1$。  
所以复杂度 $\Theta(3n)$，不会 T。

那么我们知道了这个有什么用呢？

我们就可以求所有后缀中最长的，且满足是 $s$ 前缀的后缀了。

**接下来的思路：**  
在 $sa[i]$ 中从 $rk[1]-1$ 倒序枚举到 $1$，分别看每个后缀和 $s$ 最大公共前缀长是不是等于从这个位置开始的后缀长，等于则记录跳出，这个最大公共前缀长即为 $|s'|$。

因为最大公共前缀长只减不增，所以最先枚举到的就是最长的。

**一个说明**：为什么向前枚举就行了？  
因为 $s'$ 是 $s$ 的前缀，根据后缀数组的排序，$s'$ 作为后缀时的排序位置一定在 $s$ 位置的前面。

代码如下：

```cpp
int minl = inf, maxl = 0, nowwh = rk[1] - 1;
while (nowwh) {
    minl = std :: min(minl, sam[nowwh]);
    if (minl == n - sa[nowwh] + 1) {
        maxl = minl;
        break;
    }
    nowwh--;
}
```

最后输出即可。

[完整代码在这里](https://www.luogu.com.cn/paste/c318p89a)，复杂度 $O(n\log n)$，~~虽然做出来了但是好慢~~，最慢要 712ms。

---

## 作者：sLMxf (赞：4)

## 闲话
本篇题解来自赛场第二切，比@[dead_X](https://www.luogu.com.cn/user/111055) 慢了整整 $0.6s$。
## Pro
给定 $s$，求一个最短字符串 $t$，使得 $s$ 是 $t$ 的最长 border。
## Sol
前置知识：[KMP](https://www.luogu.com.cn/problem/P3375)，记号 $|a|$ 表示字符串 $a$ 的长度。

首先我们可以输出这个字符串，因为 $s$ 是 $t$ 的 border，$t$ 的前缀就一定是 $s$。

接下来考虑后缀怎么为 $s$。

KMP 中，有一个数组叫做 $nxt$，$nxt_i$ 表示 $s$ 的前 $i$ 个字符的 border。怎么求 $nxt$ 详见[原题](https://www.luogu.com.cn/problem/P3375)。

因为 $t$ 的长度不会超过 $2|s|$，所以 $s$ 一定有一段前缀会和它的一段后缀重合。

设 $s$ 是一个类似 `QwQ`（其实就是的）的结构，那么 $t$ 一定会构造出一个形如 `QwQwQ` 的结构。

当 $Q$ 是 $s$ 的最长 border 时，一定是最优的，因为 $Q$ 再长一定会不符合题意，再短一定不优。

所以求出 $s$ 的 $nxt$ 数组，输出 $s$ 以及 $s$ 从 $nxt_{|s|}+1$ 到 $\text{size}_s$ 的所有字符。

时间复杂度 $O(|s|)$。
## Code
仅展示核心代码。
```cpp
b=" "+b;
kmp(b);
for(int i=1;i<=n;i++) cout<<b[i];
for(int i=nxt[n/*n=|s|*/]+1;i<=n;i++) cout<<b[i];
```
## 后记
~~@[dead_X](https://www.luogu.com.cn/user/111055) 我**你*。~~

---

## 作者：_lmh_ (赞：3)

显然 $|t|\le 2|s|$。设 $|s|=n,|t|=m$。

下文中，记 $s_{l,r}$ 为 $s$ 第 $l \sim r$ 个字符拼接而成的子串。

由题意得 $s=t_{1,n}=t_{m-n+1,m}$，然后会发现 $\forall i \in [1,2n-m],s_i=t_{m-n+i}=s_{m-n+i}$，也就是说 $s$ 存在长为 $2n-m$ 的 border。

所以求出最长 border 以后就可以找出最短的 $t$。

然后 MatrixGroup 说我没有证明 $s$ 是 $t$ 的最长 Border，我一看原来题目里还有一句话，那现在证明一下。

考虑按上面那个策略生成出来的 $s$ 和最短的 $t$。如果 $t$ 存在更长的 Border，设其长度为 $n+k$，那么 $t_{1,n+k}=t_{m-n-k+1,m}$。但此时更短的 $t_{1,m-k}$ 也满足 $s$ 为其 Border 的条件（$s=t_{1,n}=t_{m-n-k+1,m-k}$），矛盾，所以上面那个策略能找出最优的 $t$。

为了 AC 当然要使用 AC 自动机！！1

```cpp
//Happy Birthday, Ling Luo!
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1000007;
int n;
char s[N];
queue<int> q;
struct ACAM{
	int nV,fail[N],trans[N][26],son[N],nxt[N];
	ACAM(){nV=1;memset(son,0,sizeof(son));memset(trans,0,sizeof(trans));memset(fail,0,sizeof(fail));}
	void insert(char* s,int u){
		int n=strlen(s+1),now=1;
		for (int i=1;i<=n;++i){
			if (trans[now][s[i]-'a']) now=trans[now][s[i]-'a'];
			else now=trans[now][s[i]-'a']=++nV;
		}
	}
	void getFail(){
		for (int i=0;i<26;++i) trans[0][i]=1;
		fail[1]=0;
		q.push(1);
		while(!q.empty()){
			int u=q.front();q.pop();
			int f=fail[u];
			for (int i=0;i<26;++i){
				if (!trans[u][i]) trans[u][i]=trans[f][i];
				else {fail[trans[u][i]]=trans[f][i];q.push(trans[u][i]);}
			}
		}
	}
}A;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>(s+1);n=strlen(s+1);
	A.insert(s,1);
	A.getFail();
	ll p=A.fail[n+1];
	cout<<(s+1);
	for (int i=p;i<=n;++i) cout<<s[i];cout<<'\n';
	return 0;
}
```

你说得对，但是 AC 自动机是 8 级算法，所以还是补一个 KMP 的版本吧。这里 $fail_i$ 代表的是 $s_{1,i}$ 的最长 border。有关 KMP 的相关知识可以参考模板题的题解，这里不再赘述。

（好像这个写法不太标准？）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
const ll N=1000007;
ll n,fail[N];
char s[N];
ll go(ll pre,char c){
	char goal=(pre<n?s[pre+1]:0);
	if (c==goal) return pre+1;
	else if (pre==0) return 0;
	return go(fail[pre],c);
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>(s+1);n=strlen(s+1);
	fail[1]=0;
	for (int i=2;i<=n;++i) fail[i]=go(fail[i-1],s[i]);
	for (int i=1;i<=n;++i) cout<<s[i];
	for (int i=fail[n]+1;i<=n;++i) cout<<s[i];cout<<endl;
	return 0;
}
```

最后来一个字符串哈希的代码，这个比较易于理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1000007,MOD=1e9+7,B=131;
ll n,hsh[N],pw[N];
char s[N];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	for (int i=pw[0]=1;i<N;++i) pw[i]=pw[i-1]*B%MOD;
	cin>>(s+1);n=strlen(s+1);
	for (int i=1;i<=n;++i) hsh[i]=(hsh[i-1]*B+s[i])%MOD;
	for (int len=n-1;~len;--len) if (hsh[len]==((hsh[n]-hsh[n-len]*pw[len])%MOD+MOD)%MOD){
		cout<<(s+1);
		for (int i=len+1;i<=n;++i) cout<<s[i];cout<<endl;
		return 0;
	}
	return 0;
}
```

---

## 作者：Lacuna (赞：0)

感觉 KMP 的题都非常难理解。

### 思路：

首先我们要知道 $nxt$ 数组在 KMP 算法中的含义就是串中最长公共前后缀的长度。所以有一个简单的思路就是在前面拼一个串，比如第一个样例，往前拼了一个 ```qw```，只是在 $s$ 中去掉了 $s$ 的 border 的一半，确切地说是后半段。所以我们得到了本题的结论。设 $s$ 去掉 border 后的字符串是 $s1$，设 $s$ 的最长 border 是 $p$，则：$s1 = s - p$，那么：$t = s1 + s$。

### 证明：

$t$ 最短：假设设 $t1$ 比 $t$ 更短，由于 $t = s1 + s = s - p + s$，那么 $t1 = s - x + s$，因为 $t1$ 比 $t$ 更短，所以 $x$ 比 $p$ 更长，和 $p$ 是 $s$ 最长 border 矛盾，所以不存在 $t1$。

$s$ 是 $t$ 的 border：上一个证明中 $t = s1 + s = s - p + s$，非常显然。

$s$ 是 $t$ 的最长 border：假设有更长的 border $q$。那么会发现 $q = s + x$，所以设 $q$ 的最长 border 是 $q1$，那么设 $s2 = q1 - x$，则 $q = q1 + y + s2 + x$，所以 $q1 + y + s2 = s$，又因为前面 $q1 = s2  + x$，带进去就是 $s = s2 + x + y + s2$，所以 $s2$ 是 $s$ 的 border，由于 $t$ 的长度是不变的，所以 $q1$ 长于 $p$，且由对称性 $q1 = l + p + l$。我们画个图发现这个 $l$ 就是 $x$。所以 $p = q1 - 2x$。又因为 $s2 = q1 - x$，所以是 $s2$ 比 $s$ 更长且是 $s$ 的 border。与 $s1$ 的定义矛盾。所以不存在 $q$。 

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define gc getchar
#define pc putchar
#define pb push_back
#define ls u<<1
#define rs u<<1|1
const int ri=1e6+5;
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
char s[ri];
int nxt[ri];
int main(){
	scanf("%s",s+1);
	int siz=strlen(s+1);
	for(int i=2,j=0;i<=siz;i++){
		while(j&&s[i]!=s[j+1]){
			j=nxt[j];
		}
		if(s[i]==s[j+1]) j++;
		nxt[i]=j;
	}
	for(int i=1;i<=siz-nxt[siz];i++){
		cout<<s[i];
	} 
	for(int i=1;i<=siz;i++){
		cout<<s[i]; 
	}
	cout<<endl;
	return 0;
}
```

---


# [NOIP2024] 遗失的赋值

## 题目描述

小 F 有 $n$ 个变量 $x_1, x_2, \ldots , x_n$。每个变量可以取 $1$ 至 $v$ 的整数取值。

小 F 在这 $n$ 个变量之间添加了 $n - 1$ 条二元限制，其中第 $i$（$1 \leq i \leq n - 1$）条限制为：若 $x_i = a_i$，则要求 $x_{i+1} = b_i$，**且 $a_i$ 与 $b_i$ 为 $1$ 到 $v$ 之间的整数**；当 $x_i \neq a_i$ 时，第 $i$ 条限制对 $x_{i+1}$ 的值不做任何约束。除此之外，小 F 还添加了 $m$ 条一元限制，其中第 $j$（$1 \leq j \leq m$）条限制为：$x_{c_j} = d_j$。

小 F 记住了所有 $c_j$ 和 $d_j$ 的值，但把所有 $a_i$ 和 $b_i$ 的值都忘了。同时小 F 知道：存在给每一个变量赋值的方案同时满足所有这些限制。

现在小 F 想知道，有多少种 $a_i, b_i$（$1 \leq i \leq n - 1$）取值的组合，使得能够确保至少存在一种给每个变量 $x_i$ 赋值的方案可以同时满足所有限制。由于方案数可能很大，小 F 只需要你输出方案数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例 1 解释】**

- 对于第一组测试数据，所有可能的 $(a_1, b_1)$ 取值的组合 $(1, 1), (1, 2), (2, 1), (2, 2)$ 都满足限制。例如，$(a_1, b_1) = (1, 1)$ 时，$(x_1, x_2) = (1, 1)$ 满足所有限制，而 $(a_1, b_1) = (2, 2)$ 时，$(x_1, x_2) = (1, 1)$ 与 $(x_1, x_2) = (1, 2)$ 均满足所有限制。
- 对于第二组测试数据，只有 $(x_1, x_2) = (1, 2)$ 一种可能的变量赋值，因此只有 $(a_1, b_1) = (1, 1)$ 不满足限制，其余三种赋值均满足限制。
- 对于第三组测试数据，不存在一种变量赋值同时满足 $x_1 = 1$ 和 $x_1 = 2$，因此也不存在满足限制的 $(a_1, b_1)$。

**【样例 2】**

见选手目录下的 `assign/assign2.in` 与 `assign/assign2.ans`。

该样例共有 $10$ 组测试数据，其中第 $i$（$1 \leq i \leq 10$）组测试数据满足数据范围中描述的测试点 $i$ 的限制。

**【样例 3】**

见选手目录下的 `assign/assign3.in` 与 `assign/assign3.ans`。

该样例共有 $10$ 组测试数据，其中第 $i$（$1 \leq i \leq 10$）组测试数据满足数据范围中描述的测试点 $i + 10$ 的限制。

**【数据范围】**

对于所有的测试数据，保证：

- $1 \leq T \leq 10$，
- $1 \leq n \leq 10^9$，$1 \leq m \leq 10^5$，$2 \leq v \leq 10^9$，
- 对于任意的 $j$（$1 \leq j \leq m$），都有 $1 \leq c_j \leq n$，$1 \leq d_j \leq v$。

::cute-table{tuack}

| 测试点 | $n \leq$ | $m \leq$ | $v \leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1, 2$ | $6$ | $6$ | $2$ | 无 |
| $3$ | $9$ | $9$ | ^ | ^ |
| $4, 5$ | $12$ | $12$ | ^ | ^ |
| $6$ | $10^3$ | $1$ | $10^3$ | ^ |
| $7$ | $10^5$ | ^ | $10^5$ | ^ |
| $8,9$ | $10^9$ | ^ | $10^9$ | ^ |
| $10$ | $10^3$ | $10^3$ | $10^3$ | A |
| $11$ | $10^4$ | $10^4$ | $10^4$ | ^ |
| $12$ | $10^5$ | $10^5$ | $10^5$ | ^ |
| $13$ | $10^4$ | $10^3$ | $10^4$ | B |
| $14$ | $10^6$ | $10^4$ | $10^6$ | ^ |
| $15, 16$ | $10^9$ | $10^5$ | $10^9$ | ^ |
| $17$ | $10^4$ | $10^3$ | $10^4$ | 无 |
| $18$ | $10^6$ | $10^4$ | $10^6$ | ^ |
| $19, 20$ | $10^9$ | $10^5$ | $10^9$ | ^ |

特殊性质 A：保证 $m = n$，且对于任意的 $j$（$1 \leq j \leq m$），都有 $c_j = j$。

特殊性质 B：保证 $d_j = 1$。

## 样例 #1

### 输入

```
3
2 1 2
1 1
2 2 2
1 1
2 2
2 2 2
1 1
1 2
```

### 输出

```
4
3
0
```

# 题解

## 作者：cff_0102 (赞：91)

考场的思路，自认为比较清楚。

没有其它要求，一个二元限制的可能数为 $v^2$。

先只考虑一个区间，它的左右端点有限制，现在要求这个区间可行的方案数。若这个区间的长度可以放下 $x$ 个二元限制（不说长度为 $x+1$ 是因为可能会描述不清），设其方案数为 $f(x)$。

如果第一个二元限制的第一个数与左端点的数相同，那么这种情况有 $v$ 个可能的二元限制，同时下一个数也是有限制的，而剩下的方案数其实就是 $f(x-1)$，由乘法原理得此时的总方案数是 $v\times f(x-1)$。

如果第一个二元限制的第一个数与左端点的数不同，那么由于 $v\ge2$，第二个数一定有方法和第二个二元限制的第一个数不同。以此类推，后面的只要不踩中二元限制的第一个数，都一定有方法把这个区间所有数全部填上。因此，只要第一个二元限制的第一个数与左端点的数不同，剩下的二元限制随便选，都一定是有解的。剩下 $x-1$ 个二元限制方案数为 ${(v^{2})}^{(x-1)}=v^{2x-2}$，第一个由于不能和左端点相同所以是 $v\times(v-1)$，乘起来得到 $v\times(v-1)\times v^{2x-2}=v^{2x}-v^{2x-1}$。

把这两种情况加起来就能得到正确的递推式子：$f(x)=v^{2x}-v^{2x-1}+v\times f(x-1)$。

当然边界情况是 $f(1)=v^2-v+1$，即二元限制的第一个数与左边的数不同的 $v(v-1)$ 种情况，加上这两个数相同则右边的两个数也必须相同的 $1$ 种情况。

好的，先别急着直接开始写代码递推，看看继续推式子能不能推出点什么。

$$f(x)=v^{2x}-v^{2x-1}+v\times(v^{2x-2}-v^{2x-3}+v\times f(x-2))$$
$$f(x)=v^{2x}-v^{2x-1}+v^{2x-1}-v^{2x-2}+v^2\times f(x-2)$$
$$f(x)=v^{2x}-v^{2x-2}+v^2\times f(x-2)$$

嗯？好像有点东西，继续推推看？

$$f(x)=v^{2x}-v^{2x-2}+v^2\times(v^{2x-4}-v^{2x-5}+v\times f(x-3))$$
$$f(x)=v^{2x}-v^{2x-2}+v^{2x-2}-v^{2x-3}+v^3\times f(x-3)$$
$$f(x)=v^{2x}-v^{2x-3}+v^3\times f(x-3)$$

没错，经过推理我们得到了 $f(x)=v^{2x}-v^{2x-k}+v^k\times f(x-k)$。接着带入 $k=x-1$：

$$\begin{aligned}f(x)&=v^{2x}-v^{x+1}+v^{x-1}\times (v^2-v+1)\\&=v^{2x}-v^{x+1}+v^{x+1}-v^x+v^{x-1}\\&=v^{2x}-v^x+v^{x-1}\end{aligned}$$

套上个快速幂，$f(x)$ 就能 $O(\log x)$ 求出了。

最终答案是每两个限制之间的区间的情况数相乘，还要再乘上开头和末尾连续段的答案：

- 对于开头，因为没有左端点的限制，只要避免踩中任何一个二元限制就可以填出。所以这一段的二元限制是什么都没关系。答案为 $v^{2x}$。
- 对于末尾，因为没有右端点的限制，所以如果有二元限制就按着二元限制填，没有就随便填，也一定可以把这里的数填出。所以这一段的二元限制是什么也没关系。答案为 $v^{2x}$。

把所有区间的答案乘起来再输出即可，记得取模。算上刚开始需要的排序，时间复杂度为 $O(Tm(\log n+\log m))$，其中的 $\log n$ 是快速幂带来的。

[这里会有一些对题解内容的补充以及赛时代码](/paste/msy9ajbm)。

---

## 作者：ARIS2_0 (赞：53)

### 前言

赛时 T1 唐太久（Only get 40pts），切 T2 的时候人都傻了，看来开赛先看一遍题目是有道理的。

别看这篇题解长，如果仔细读下来，你会发现这题其实还是挺简单的。

### 思路

当一元约束之间有冲突的时候，答案很明显是 $0$。

考虑一元约束什么时候会与二元约束产生冲突：**当且仅当有一对 $i,j$**，满足：

- $1\le i<j\le n$

- $x_i,x_j$ 已知（即在 $x_i,x_j$ 上有一元约束）

- **$a_i=x_i,a_{i+1}=b_i,a_{i+2}=b_{i+1},\dots,a_{j-1}=b_{j-2},b_{j-1}\not=x_j$**

因为只有这样，才能使 $x_i,x_{i+1},\dots,x_{j-1}$ 的值都固定，并在 $x_j$ 上产生冲突。

考虑到此时我们是让 $x_j$ 产生冲突，与 $i$ 是多少没有关系，为了统计的不重不漏，不妨**将所有一元约束按位置排序后，使 $i=c_p,j=c_{p+1}(1\le p<m)$**。特别地，当 $m=1$ 时，约束条件可以任取，由于 $a_i,b_i\in [1,v]$，则答案即为 $v^{2\times (n-1)}$。

接下来，计算约束条件在 $x_i$ 到 $x_j$（即 $a_i,b_i$ 到 $a_{j-1},b_{j-1}$）上的合法方案数，再将它们连乘，即为总的合法方案数（其实还要考虑 $1$ 到 $c_1$ 与 $c_m$ 到 $n$ 的冗余）。但直接计算合法方案数是困难的。**正难则反**，考虑计算所有方案数减去不合法的方案数。

由于 $a_i,b_i\in [1,v]$，所有方案数即为 $v^{2\times(j-i)}$。而对于不合法方案数，因为要满足上述条件，所以 $a_i$ 只有一种选择，而对于 $p\in[i,j-2]$，$b_p$ 有 $v$ 种选择，$a_{p+1}$ 有 $1$ 种选择（能且只能等于 $b_p$）。最后，$b_{j-1}$ 有 $v-1$ 种选择（不能等于 $x_j$）。综上，不合法方案数为 $v^{j-i-1}\times (v-1)$，则合法方案数即为：

> $v^{2\times(j-i)}-v^{j-i-1}\times (v-1)$

由于最后的答案要连乘，则最后的答案为（数组 $c$ 为升序排列）：

> $\Pi_{i=2}^m (v^{2\times(c_i-c_{i-1})}-v^{c_{i}-c_{i-1}-1}\times (v-1))$

吗？

正如前文所说，还要考虑 $1$ 到 $c_1$ 与 $c_m$ 到 $n$ 的冗余，即约束 $a_1,b_1$ 到 $a_{c_1-1},b_{c_1-1}$ 和 $a_{c_m},b_{c_m}$ 到 $a_{n-1},b_{n-1}$ 的冗余。因为这一部分的 $a$ 数组和 $b$ 数组取 $[1,v]$ 的任意一个数都没有问题，所以答案还要乘上 $v^{2\times (c_1-1+n-c_m)}$。

则，最终答案为：

> $v^{2\times (c_1-1+n-c_m)}\times \Pi_{i=2}^m (v^{2\times(c_i-c_{i-1})}-v^{c_{i}-c_{i-1}-1}\times (v-1))$

代码实现是简单的，将 $c$ 排序后使用快速幂计算并取模即可，记得最后把负数转成正数。

### 后记

个人认为这题是一道比较好的数学计数题，虽然放 T2 确实有点搞心态。

其实完全可以把数组 $d$ 去掉，然后加上点奇奇怪怪的题目描述让这道题看起来很难（

因为是在回来的动车上用手机写的题解，数学公式难免有疏漏之处，若有请指出。

祝大家 NOIP2024 后的下一个赛程 rp++。

---

## 作者：VinstaG173 (赞：38)

随便做了做造了个民间数据。

考虑分段计算贡献后用乘法原理。先解决以下子问题：

+ $x_l,x_r$ 确定，求合法的 $(a_i,b_i),l\le i<r$ 数量。

反过来做，$(a_i,b_i)$ 不合法当且仅当：

$\begin{cases}
a_l=x_l;\\
a_{i+1}=b_i,&l\le i<r-1;\\
b_{r-1}\neq x_r.
\end{cases}$

对 $l\le i<r-1$，$b_i$ 有 $v$ 种可能取值；$b_{r-1}$ 有 $v-1$ 种可能取值，共 $v^{r-l-1}(v-1)$ 种。

又所有可能的 $(a_i,b_i)$ 有 $(v^2)^{r-l}$ 种，从而合法的 $(a_i,b_i)$ 就有 $f(l,r)=(v^{2(r-l)}-v^{r-l-1}(v-1))$ 种。

---

然后发现只有 $x_k$ 值被限定时，$(a_i,b_i),1\le i<k$ 的 $v^{2(k-1)}$ 种可能值和 $(a_i,b_i),k\le i<n$ 的 $v^{2(n-k)}$ 种可能值均合法。

从而设被限定了值的位置去重后为 $k_1,\dots,k_{m'}$，则最终答案为 $v^{2(k_1-1)}\cdot v^{2(n-k_m)}\prod\limits_{i=1}^{m'-1}f(k_i,k_{i+1})$。

注意需要判断是否有位置被赋了两个不同的值，用 `map` 维护即可做到时间复杂度 $O(m(\log m+\log n))$，空间复杂度 $O(m)$。

Code:
```cpp
#define ll long long
const int mod=1e9+7;

inline ll qpw(ll x,int v=mod-2){
	ll res=1;while(v){
		if(v&1)res=res*x%mod;
		x=x*x%mod,v>>=1;
	}return res;
}

int n,m;
ll v,ans;
map<int,int>S;
map<int,int>::iterator ps,nx;
inline void solve(){
	cin>>n>>m>>v;
	S.clear();ans=1;
	for(int i=0,c,d;i<m;++i){
		cin>>c>>d;
		if(S.count(c)&&S[c]!=d)ans=0;
		else S[c]=d;
	}if(!ans){
		cout<<"0\n";
		return;
	}ps=nx=S.begin();
	ans=qpw(v,((*nx).first-1)*2);++nx;
	for(;nx!=S.end();++ps,++nx){
		int x=(*ps).first,y=(*nx).first;
		ans=ans*(qpw(v,(y-x)*2)-qpw(v,y-x-1)*(v-1)%mod+mod)%mod;
	}ans=ans*qpw(v,(n-(*ps).first)*2)%mod;
	cout<<ans<<"\n";
}
```

---

## 作者：Polarisx (赞：27)

[题目传送门](https://www.luogu.com.cn/problem/P11362)。

## 思路

容易发现 $a_i,b_i$ 仅和 $x_{i-1},x_i$ 是否确定相关，令 $dp_{i,0/1}$ 表示处理到第 $i$ 位，是否确定 $x_i$ 的取值，那么显然有转移：

当前遍历到 $i$，若存在 $j$ 使得 $c_j=i$，也就是说这一位的取值已经被确定了，有转移：

$$dp_{i,1}=v^2dp_{i-1,0}+((v-1)v+1)dp_{i-1,1} $$

（当 $x_{i-1}$ 不确定时，$a_{i-1},b_{i-1}$ 显然能填任何数，当 $x_{i-1}$ 确定时，若 $a_{i-1}\not=x_{i-1}$，有 $v(v-1)$ 种方案，否则只有 $1$ 种）

否则不存在 $c_j=i$，也就是说这一位填什么并不确定，那么有转移：

$$
dp_{i,0}=v^2dp_{i-1,0}+v(v-1)dp_{i-1,1}
$$

$$dp_{i,1}=vdp_{i-1,1}$$

（和上面转移类似，不做解释）

直接做的时间复杂度为 $\mathcal O (n)$，可以用矩阵快速幂优化此过程，时间复杂度 $\mathcal O (m\log n)$。

（这式子应该是能直接算的，不过矩阵快速幂更好想点）


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Mod=1e9+7;
const int Maxn=1e6+7;
int T;
int n,m,v;
ll f[Maxn][2];

struct Matrix{
    ll v[2][2];
    inline void clear(){memset(v,0,sizeof v);}
    inline void init(){v[0][0]=1,v[1][1]=1;}
    Matrix(){clear();}
};
inline Matrix operator*(const Matrix x,const Matrix y){
    Matrix z;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int k=0;k<2;k++)
                z.v[i][j]=(z.v[i][j]+x.v[i][k]*y.v[k][j]%Mod)%Mod;
    return z;
}
inline Matrix Ksmp(Matrix x,int b){
    Matrix z;z.init();
    while(b){
        if(b&1) z=z*x;
        x=x*x;
        b>>=1;
    }
    return z;
}

int main(){
    // freopen("assign2.in","r",stdin);
    // freopen("assign.out","w",stdout);
    scanf("%d",&T);
    while(T--){
        scanf("%d%d%d",&n,&m,&v);
        map<int,int>mp;
        bool tag=1;
        for(int i=1;i<=m;i++){
            int c,d;
            scanf("%d%d",&c,&d);
            if(mp[c] and mp[c]!=d) tag=0;
            mp[c]=d;
        }
        if(!tag){
            puts("0");
            continue;
        }
        Matrix ans,trs1,trs2;
        if(mp[1]) ans.v[0][1]=1;
        else ans.v[0][0]=1;
        trs1.v[0][0]=1ll*v*v%Mod,trs1.v[1][0]=1ll*v*(v-1)%Mod,trs1.v[1][1]=v;
        trs2.v[0][1]=1ll*v*v%Mod,trs2.v[1][1]=1ll*(v-1)*v%Mod+1;
        int lst=1;
        for(auto i:mp){
            int ps=i.first;
            if(ps==1) continue;
            ans=ans*Ksmp(trs1,ps-lst-1);
            ans=ans*trs2;
            lst=ps;
        }
        ans=ans*Ksmp(trs1,n-lst);
        printf("%lld\n",(ans.v[0][0]+ans.v[0][1])%Mod);
    }

    // system("pause");
    return 0;
}
```

---

## 作者：Milthm (赞：20)

对于相邻的 $c_i$ 和 $c_{i+1}$，考虑 $c_i\le j < c_{i+1}$ 的 $a_j,b_j$ 合法选法数量。如果我们求出来了这些，乘起来就可以得到答案了（当然还有两头的，不过那些很好求）。

正难则反，考虑不合法的选法数量，我们发现不合法的选法中：

- $a_{c_i}=d_i$，$b_{c_i}$ 随意。

- $a_{c_i+1}=b_{c_i}$，$b_{c_i+1}$ 随意。

- $a_{c_i+2}=b_{c_i+1}$，$b_{c_i+2}$ 随意。

中间都是这个规律，直到：

- $a_{c_{i+1}-1}=b_{c_{i+1}-2}$，$b_{c_{i+1}-1}\neq d_{i+1}$。

设 $l=c_{i+1}-c_i$，这个过程中，“随意”的变量有 $l-1$ 个，还有一个只要满足不等即可，因此总的方案数量为 $v^{l-1}(v-1)$。

算出了不合法数量，用 $v^{2l}$ 减去不合法数量就得到了合法数量。然后求出每个 $1\le i <m$ 的合法数量的乘积，就得到了中间部分的答案。

算出了中间部分，开头结尾也是很好算的（自由变量随便取就行），算出来之后和中间部分乘起来，就得到了答案。

这个过程可以用快速幂实现，时间复杂度 $O(Tm \log n)$。

实现的时候记得特判无解。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
const int mod=1e9+7;
int T,n,m,v;
struct node{
	int c,d;
}a[N];
int cmp(node a,node b){
	if(a.c!=b.c)return a.c<b.c;
	return a.d<b.d;
}
int qpow(int x,int y){
	int ans=1;
	while(y){
		if(y&1)ans=ans*x%mod;
		x=x*x%mod;y>>=1;
	}
	return ans;
}
signed main(){
	cin>>T;
	while(T--){
		cin>>n>>m>>v;int f=0;
		for(int i=1;i<=m;++i)scanf("%lld%lld",&a[i].c,&a[i].d);
		sort(a+1,a+m+1,cmp);
		for(int i=1;i<m;++i){
			if(a[i].c==a[i+1].c&&a[i].d!=a[i+1].d)f=1;
		}
		if(f){
			cout<<"0\n";continue;
		}
		int ans=qpow(v,(a[1].c-1)*2);
		for(int i=1;i<m;++i){
			if(a[i].c==a[i+1].c)continue;
			ans=ans*(qpow(v,(a[i+1].c-a[i].c)*2)-qpow(v,a[i+1].c-a[i].c-1)*(v-1)%mod+mod)%mod;
		}
		ans=ans*qpow(v,(n-a[m].c)*2)%mod;
		cout<<ans<<'\n';
	}
	return 0;
}

```

---

## 作者：hensier (赞：12)

首先，需要特判 $c_i = c_j$ 但 $d_i \neq d_j$ 的情形，此时答案为 $0$。

否则，我们可以把**每相邻的两条一元限制**作为一个区间单独拎出来。这样做正确的原因是，每一个 $x_i$ 的取值只受前面一个数的影响。事实上，完全可以任意选取区间，只不过这样选可以利用已知的 $x_i$，依次讨论出 $a_{i+1}, b_{i+1}, a_{i+2}, b_{i+2}, \cdots$ 的可能取值，便于计算答案。

我们~~随便~~找几个数举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/cbzavkl5.png)

此时分别考虑区间 $[2,6]$，$[6,7]$ 和 $[7,9]$ 即可。

---

对于相邻的两条一元限制 $(c_i, d_i)$，$(c_j, d_j)$（$c_i \lt c_j$）：

区间 $[c_i,c_j]$ 内有 $c_j - c_i$ 条待定的二元限制。

由于要求的是**至少存在一种**合法的 $x_i$ 的赋值方案数，我们不妨考虑其**反面**，先找出所有的方案，使得**不存在**合法的 $x_i$ 的赋值方式。

---

先考虑最特殊的一种情形，即从 $c_i$ 位置开始，首先有 $a_{c_i} = d_i$，而后有 $b_{k-1} = a_k$（$c_i \lt k \lt c_j$）。换言之，这种构造可以使得从 $c_{i} + 1$ 位置到 $c_{j} - 1$ 位置的 $x$ 值都确定下来。既然想要使方案不合法，我们只需进一步使 $b_{c_j-1} \neq d_j$ 即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/41v1e5f6.png)

例如，对于 $[2,6]$ 这个区间，一种不合法的方案是：

- 令 $a_2 = 1$，$b_2 = 3$，则 $x_3$ 被确定为 $3$。
- 令 $a_3 = 3$，$b_3 = 2$，则 $x_4$ 被确定为 $2$。
- 令 $a_4 = 2$，$b_4 = 3$，则 $x_5$ 被确定为 $3$。
- 令 $a_5 = 3$，$b_5 = 2$，则 $x_6$ 被确定为 $2$。

但从初始情况可知 $x_6$ 已经为 $1$，因此这种方案不合法。

---

从 $c_i$ 位置到 $c_j-2$ 位置，$b_k$ 可以在 $1 \sim v$ 内任取，而 $b_{c_j-1}$ 又有 $v-1$ 种取法（因为要保证不与 $d_j$ 相同）。则在这种情形下不合法的方案数为 $\red{v^{c_j-c_i-1}(v-1)}$。

例如，对于上面的例子，若 $v = 5$，那么首先 $a_2$ 必须为 $1$，而 $b_2$ 可以取 $1 \sim 5$ 内的任意一个值。进一步地：

- $a_3 = b_2$，但 $b_3$ 可在 $1 \sim 5$ 内任取。
- $a_4 = b_3$，但 $b_4$ 可在 $1 \sim 5$ 内任取。
- $a_5 = b_4$，由于要保证 $b_5 \neq d_6$，因此 $b_5$ 可以取 $2 \sim 5$ 内的任意一个值。

因此不合法的方案数为 $5^3 \times 4 = 500$。

---

否则，区间内存在一个位置 $k$ （$c_i \lt k \lt c_j$）使得 $b_{k-1} \neq a_k$。那么我们只需要让 $x_k$ 取任意一个不等于 $a_k$ 的数，就能使 $x_{k+1}$ 的取值不受约束。依此类推，后面的数都可以任意选取，因此一定存在至少一种符合题意的 $x_i$ 的构造方案。即这种情形下的方案均合法。

![](https://cdn.luogu.com.cn/upload/image_hosting/mueb3u1b.png)

例如，对于 $[7,9]$ 这个区间，我们可以让 $a_7 = 4$，$b_7 = 5$，但 $a_8 = 3 \neq b_7$（即 $a_8 \neq x_8$）。这时，无论 $b_8$ 取何值，$x_9$ 的值都将不受约束。

---

当不考虑一元限制时，每个 $a_k$，$b_k$ 都各能在 $1 \sim v$ 内任取，因此总方案数为 $\red{v^{2(c_j-c_i)}}$。

因此，对相邻的两条一元限制 $(c_i, d_i)$，$(c_j, d_j)$（$c_i \lt c_j$），用总方案数减去不合法的方案数，即为合法的方案数：$\red{v^{2(c_j-c_i)} - v^{c_j-c_i-1}(v-1)}$。

---

当然，还需处理边界，每个 $a_k$，$b_k$ 都各能在 $1 \sim v$ 内任取，因为我们总可以对应地构造出符合的 $x_k$，理由同上。

![](https://cdn.luogu.com.cn/upload/image_hosting/hgtvdtmk.png)

例如，对于 $[1,2]$ 这个区间，若 $v = 5$，$a_1$ 和 $b_1$ 都各能在 $1 \sim 5$ 内的任取，因为只需使 $x_1 \neq a_1$ 即可。

---

在代码实现上，可以对原 $(c_i, d_i)$ 序列进行排序、去重（或者直接用 map，通过迭代器来遍历），然后用快速幂计算即可。

- 时间复杂度：$O(m(\log m + \log n)) \approx O(m \log n)$。
- 空间复杂度：$O(m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 1000000007;
int T, n, m, v;
struct node {
    int c, d;
    bool operator<(const node &x) const {
        if (c != x.c) return c < x.c;
        return d < x.d;
    }
    bool operator==(const node &x) const {
        return c == x.c && d == x.d;
    }
} con[100001];
long long qpow(long long a, long long b) {
    long long s = 1;
    while (b) {
        if (b % 2 == 1) s = s * a % p;
        a = a * a % p;
        b /= 2;
    }
    return s;
}
namespace IO {
    char buf[1 << 21], *p1 = buf, *p2 = buf, obuf[1 << 21], *p3 = obuf;
    char gc() {
        if (p1 == p2) {
            p1 = buf;
            p2 = buf + fread(buf, 1, 1 << 21, stdin);
        }
        return p1 == p2 ? EOF : *p1++;
    }
    template<typename T> void read(T &x) {
        x = 0;
        char ch = gc();
        while (!isdigit(ch)) ch = gc();
        while (isdigit(ch)) {
            x = (x << 3) + (x << 1) + (ch ^ 48);
            ch = gc();
        }
    }
    void pc(char c) {
        if (p3 - obuf < (1 << 21)) *p3++ = c;
        else {
            fwrite(obuf, p3 - obuf, 1, stdout);
            p3 = obuf;
            *p3++ = c;
        }
    }
    template<typename T> void write(T x) {
        if (x > 9) write(x / 10);
        pc(x % 10 + 48);
    }
} using namespace IO;
int main() {
    #ifndef ONLINE_JUDGE
        freopen("assign.in", "r", stdin);
        freopen("assign.out", "w", stdout);
    #endif
    read(T);
    while (T--) {
        read(n), read(m), read(v);
        long long ans = 1;
        for (int i = 1; i <= m; i++) read(con[i].c), read(con[i].d);
        sort(con + 1, con + m + 1);
        for (int i = 1; i <= m; i++) {
            if (con[i].c == con[i-1].c && con[i].d != con[i-1].d) {
                ans = 0;
                break;
            }
        }
        if (ans != 0) {
            m = unique(con + 1, con + m + 1) - con - 1;
            ans = ans * qpow(v, 2 * (con[1].c - 1));
            for (int i = 2; i <= m; i++) {
                int d = con[i].c - con[i-1].c;
                long long cur = (qpow(v, 2 * d) + p - (1LL * (v - 1) * qpow(v, d - 1) % p)) % p;
                ans = ans * cur % p;
            }
            ans = ans * qpow(v, 2 * (n - con[m].c)) % p;
        }
        write(ans);
        pc('\n');
    }
    fwrite(obuf, p3 - obuf, 1, stdout);
    return 0;
}
```

---

## 作者：zgy_123 (赞：12)

建议黄。赛时手搓了 `129600` 就会了，然而推错式子，45pts 遗憾离场。

按照考场思路写一下题解，个人认为是挺好理解的。下文将二元限制写作条件语句，一元限制写作赋值语句。

首先看到这个小样例解释，发现合法方案占大多数，可以用整体方案减去不合法。

显然任意选的方案数是 $v^{2(n-1)}$，而不合法有两种情况：

- 两个赋值语句矛盾。
- 根据一个赋值语句和假定的条件语句，推导出不等于另外几个赋值语句的值（如小样例第二组数据）。

然后看到第一个大样例，发现数比较小，可以手搓。前三组数据都没什么意思，直到第四组。它是这么个情况：

```
? 2 2 2 ? ? 2 ? ? 2
```

根据上文提到的猜想，要计算不合法方案的数量。由于每个条件语句一定是向后赋值，故从前向后考虑。分以下几步：

0. 总方案数为 $v^{2(n-1)}=2^{18}=262144$。
1. 由于 $x_2$ 前面没有任何的赋值语句，所以不可能不合法。
2. 在 $x_3$ 处不合法当且仅当 $a_2=2$ 且 $b_2\neq2$，这个概率是 $\frac{1}{4}$。

* 为什么要计算概率而不是方案数？在下一步计算时有些情况已经被删掉，如果用方案数计算，仍要记录当前合法方案数，本质与计算概率再连乘相同。

3. 在 $x_4$ 处不合法同上，概率为 $\frac14$。
4. 在 $x_7$ 处不合法。这个是思路的关键。它前面最后一个赋值语句是 $x_4=2$，易证不合法只能是通过这个条件推出 $x_5,x_6,x_7$ 而 $x_7\neq2$。那么它需要满足的条件即为：

- $a_4=2$（保证能从 $x_4$ 向后推）；
- $b_4=a_5$（考虑上一行成立已经确定 $x_5=b_4$，那么保证 $x_5$ 能向后推就是这个式子了）；
- $b_5=a_6$（同上）；
- $b_6\neq2$（由前几行可以保证 $x_7=b_6$，然而要使方案不合法就必须 $x_7\neq2$）。

这就是在 $x_7$ 处不合法的充分必要条件。它发生的概率为 $\frac12\times\frac12\times\frac12\times\frac12=\frac1{16}$。

5. 在 $x_{10}$ 处不合法，同上，概率为 $\frac1{16}$。

所以整个样例的合法情况数就是 $262144\times(1-\frac14)\times(1-\frac14)\times(1-\frac1{16})\times(1-\frac1{16})=129600$。

那么这个题就迎刃而解了。根据上文，可推出在当前赋值语句的 $c$ 为 $i$，以前最后一个赋值语句的 $c$ 为 $j$ 的情况下，方案不合法的概率为 $\frac1v\times\frac1v\times\frac1v\times\cdots\times\frac1v\times\frac{v-1}v=\frac{v-1}{v^{i-j+1}}$，合法的概率为 $\frac{v^{i-j+1}-(v-1)}{v^{i-j+1}}$，累乘即可，除第一个赋值语句不计外不要考虑任何边界条件。

（本人考场推式子时将最后一项错写成 $\frac1v$，导致最后算出合法概率为 $\frac{v^{i-j+1}-1}{v^{i-j+1}}$，然而又恰好 $v=2$ 时候时相等的，所以一直查不出来）。

代码没发下来不贴了。理解了以后有手都会写。

---

## 作者：cyq32ent (赞：10)

我们考虑什么情况下，不存在一种给每个变量 $x_i$ 赋值的方案可以同时满足所有限制。第一种可能是两条相互矛盾的一元限制。这种情况直接输出 $0$ 就行了；第二种可能就是若干条二元限制使得两条一元限制不能共存。举例子：假如钦定 $x_1=3$，$x_4=4$，然后我们给出如下的二元限制：$a_1=3,b_1=4,a_2=4,b_2=5,a_3=5,b_3=2$。这样，一旦 $x_1=3$，$x_4$ 就必须为 $2$，此时不能满足。更具体地，一种二元限制方案不能满足，等价于存在两条不相同的相邻的一元限制 $c_i=C,c_j=D,i<j$，满足

$$a_i=C,b_k=a_{k+1},b_{j-1}\neq D$$

其中 $k \in [i,j-1)$。为了方便表述，我们将两个不相同的相邻的一元限制之间的一段称作一段区间。我们注意到区间之间是相互独立的，所以分开计算区间对答案的贡献。如果不考虑约束条件，一个包含 $m$ 个点的区间（不包含端点，也就是有一元约束的点）一共有 $v^{2m+2}$ 种二元约束的取值。我们考虑有约束的情况下，有多少种取值是无效的。这个值显然为 $v^m(v-1)$。所以我们可以计算出每一个区间的方案数，只要将每一个区间相乘即可。

对于开头和结尾的不在任何一个区间内的二元约束，容易证明二元约束可以任取。答案乘上即可。

---

## 作者：chenxi2009 (赞：9)

**Upd 2024.12.2：修改了 AC 代码。**
# 思路
首先明确一个限制在“自由”的情况下，有 $v^2$ 种方案。

为方便做题，先把所有的限制以 $c$ 为第一关键字排序。

不难发现 $c_1$ 之前的 $c_1-1$ 个限制都是“自由的”，显然可以存在方案使得对于前面的任何限制都合法。\
同理，$c_m$ 之后的限制也是“自由的”。

紧接着我们考虑每两个限制之间的部分的**非法**情况，显然 $c_i$ 要直接决定 $c_{i+1}$ 的值并且使它不等于 $d_{i+1}$，那么它们俩之间的限制就必须得“紧密连接”，让 $x_{c_i}$ 决定 $x_{c_i+1}$，$x_{c_i+1}$ 决定 $x_{c_i+2}$......令 $x\leftarrow c_i$，$y\leftarrow c_{i+1}$，转化一下有如下要求：
$$
a_x=d_i\\
\forall j\in[x,y),b_j=a_{j+1}\\
b_{y-1}\ne d_{i+1}
$$
相邻两个限制的 $b,a$ 被捆绑，实际可以自由选择的 $b,a$ 对有 $y-x-1$ 个，方案数为 $v^{y-x-1}$；此外有 $a_x=d_i$，方案数为 $1$；有 $b_{y-1}\ne d_{i+1}$，方案数为 $v-1$。因此，总的**非法**方案数为 $(v-1)q^{y-x-1}$；\
显然中间有 $y-x$ 对限制，总方案数为 $v^{2y-2x}$。二者相减，得到这一段的合法方案数为 $v^{2y-2x}-(v-1)q^{y-x-1}$。

特判忽略重复的限制和数据要求一个变量被赋值为不同值的无解情况。

# 代码
**可以通过民间数据。**
```cpp
#include<bits/stdc++.h> 
using namespace std;
const long long MOD = 1000000007;
int T,n,m;
long long ans,v;
pair<int,int>lmt[100001];
long long qp(long long a,long long b){
	if(!b) return 1ll;
	long long c = qp(a,b >> 1);
	c = c * c % MOD;
	if(b & 1) c = c * a % MOD;
	return c;
}
int main(){
	scanf("%d",&T);
	while(T --){
		scanf("%d%d%lld",&n,&m,&v);
		for(int i = 1;i <= m;i ++) scanf("%d%d",&lmt[i].first,&lmt[i].second);
		sort(lmt + 1,lmt + m + 1);
		ans = qp(v,lmt[1].first - 1 << 1);//c_1 左边的约束提供的方案数 
		for(int i = 1;i < m;i ++){
			if(lmt[i].first == lmt[i + 1].first){
				if(lmt[i].second == lmt[i + 1].second) continue;//相同的约束可以只保留一个，余下舍弃 
				else ans = 0ll;//存在约束要求一个位置同时是两个值，无解 
			}
			else ans = ans * (qp(v,lmt[i + 1].first - lmt[i].first << 1) - (v - 1) * qp(v,lmt[i + 1].first - lmt[i].first - 1) % MOD + MOD) % MOD;//如上述推导 
		}
		ans = ans * qp(v,n - lmt[m].first << 1) % MOD;//c_m 右边的约束提供的方案数 
		printf("%lld\n",ans); 
	}
	return 0;
}
```

---

## 作者：incra (赞：6)

### Sol
提供一种题解区没有的做法。

本年所有比赛中 DP 最光彩的一集。

下文中所有的下标 $i,j$ 均表示第 $i,j$ 个赋值限制。

考虑 DP，设 $f_i$ 表示满足从 $1$ 到 $i$ 的合法方案数。

显然答案就是 $f_m\times k^{2\times (n - c_m)}$ 次。

考虑如何转移，考虑容斥，所有的方案数为 $k^{2\times c_i}$ 种。

思考得到不合法的状态当且仅当有相邻的赋值限制，使得两个赋值限制不能同时满足。

接下来考虑怎样不重不漏的删去不合法的方案数，对于任意一种方案，我们考虑用最后一个 $j$ 来表示这种方案，使得从 $j$ 开始，使用二元限制后 $j + 1$ 的赋值限制一定不成立。

那么我们可以暴力枚举 $j$，然后构造一种方案使其强制不能满足第 $j+1$ 个赋值限制，并且 $j+1\sim i$ 之间的二元限制应当合法。

不难推出方案数为 $f_j\times k^{c_{j+1} - c_j - 1}\times (k-1)\times k^{2\times (c_i-c_{j+1})}$。

那么转移方程就是 $f_i = \displaystyle \sum_{j=1}^{i-1}f_j\times k^{c_{j+1} - c_j - 1}\times (k-1)\times k^{2\times (c_i-c_{j+1})}=\sum_{j=1}^{i-1}(f_j\times k^{c_{j+1}-c_j-1-2\times c_{j+1}})\times (k-1)\times k^{2\times c_i}$。

朴素转移是 $O(n^2)$ 的。

如果你仔细观察这个式子，那么你可以发现，对于一个固定的 $i$，第一个括号内的所有内容都是与 $j$ 相关的，其余的都是常量，那么就可以前缀和优化 DP 来实现。

### Code
赛时代码。
```cpp
#include <bits/stdc++.h>
#define x first
#define y second
#define pb push_back
#define pf push_front
#define IOS ios :: sync_with_stdio (false),cin.tie (0),cout.tie (0)
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef pair <int,int> PII;
template <typename T1,typename T2> void tomax (T1 &x,T2 y) {
	if (y > x) x = y;
}
template <typename T1,typename T2> void tomin (T1 &x,T2 y) {
	if (y < x) x = y;
}
int fastio = (IOS,0);
#define endl '\n'
#define puts(s) cout << s << endl
const int N = 100010,MOD = 1e9 + 7;
LL n,k;
int m;
PII a[N];
LL f[N];
LL power (LL a,LL b,LL p) {
    LL ans = 1;
    while (b) {
        if (b & 1) ans = ans * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return ans;
}
int main () {
    freopen ("assign.in","r",stdin);
    freopen ("assign.out","w",stdout);
    int T;
    cin >> T;
    while (T--) {
        cin >> n >> m >> k;
        for (int i = 1;i <= m;i++) cin >> a[i].x >> a[i].y;
        sort (a + 1,a + m + 1);
        bool flag = 0;
        for (int i = 1;i <= m - 1;i++) {
            if (a[i].x == a[i + 1].x && a[i].y != a[i + 1].y) {
                flag = 1;
                break;
            }
        }
        if (flag) {
            puts ("0");
            continue;
        }
        m = unique (a + 1,a + m + 1) - a - 1;
        // for (int i = 1;i <= m;i++) {
        //     f[i] = power (k * k % MOD,a[i].x - 1,MOD);
        //     for (int j = 1;j < i;j++) {
        //         LL w = power (k,a[j + 1].x - a[j].x - 1,MOD) * (k - 1) % MOD;
        //         f[i] = (f[i] - f[j] * w % MOD * power (k * k,a[i].x - a[j + 1].x,MOD) % MOD + MOD) % MOD;
        //     }
        // }
        LL sum = 0;
        for (int i = 1;i <= m;i++) {
            f[i] = power (k * k % MOD,a[i].x - 1,MOD);
            f[i] = (f[i] - sum * power (k * k % MOD,a[i].x,MOD) % MOD + MOD) % MOD;
            if (i + 1 <= m) {
                sum = (sum + f[i] * (power (k,a[i + 1].x - a[i].x - 1,MOD) * (k - 1) % MOD) % MOD * power (power (k * k % MOD,a[i + 1].x,MOD),MOD - 2,MOD) % MOD) % MOD;
            }
        }
        cout << f[m] * power (k * k % MOD,n - a[m].x,MOD) % MOD << endl;
    }
	return 0;
}
```

---

## 作者：laoliu12345 (赞：6)

## P11362
### 题目理解
赛时的思路。首先注意到只有相邻的两个一元限制才会对答案产生一定贡献（这个贡献是在总方案数上减掉不合法的数量）。如何求出减去的不合法的数量呢。

![](https://cdn.luogu.com.cn/upload/image_hosting/camf1hka.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图，4 和 7 处存在一元限制。那么若产生矛盾，则 $a$ 和 $b$ 的赋值应为：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u06lojg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

观察可知第一个数的 $a$ 的选择只有一种，即一元限制所限值。中间关键在于满足 $b_4=a_5$，$b_5=a_6$，$b_6\neq2$ 这三个条件。设 $l$ 对应 4 处，$r$ 对应 7 处。所以中间的选择数为 $v^{r-l-1}$，最后在 $r$ 处的选数为 $v-1$。故不合法的方案数为 $(v-1) \times v^{r-l-1}$。
而总方案数是 $v^{2 \times r - 2 \times l}$（每个 $a$ 和 $b$ 都取任意值）。
故此区间的合法方案数是 $v^{2 \times r - 2 \times l}-(v-1) \times v^{r-l-1}$。

由于各个区间完全独立，根据乘法原理，我们可以对所有区间方案求积即可得到正确答案。

注意：不要忘了统计 $1 \sim c_1$ 和 $c_m \sim n$ 的方案。

那就可以愉快的写代码了。
### 题目代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=2e5+10,Mod=1e9+7;
struct node{
	int c,d;
}a[N];
int n,m,v;
bool cmp(node a,node b)
{
	return a.c<b.c;
}
int qmi(int c,int x)
{
	int sum=1;
	while(x)
	{
		if(x&1) sum=(sum*c)%Mod;
		c=(c*c)%Mod;
		x>>=1;
	}
	return sum;
}
signed main()
{
	//freopen("assign.in","r",stdin);
	//freopen("assign.out","w",stdout);
	cin.tie(0),cout.tie(0)->sync_with_stdio(0);
	int T;
	cin>>T;
	while(T--)
	{
		cin>>n>>m>>v;
		for(int i=1;i<=m;i++)
		    cin>>a[i].c>>a[i].d;
		sort(a+1,a+m+1,cmp);
		int sum=1;
		sum=(sum*qmi(v,2*(a[1].c-1)))%Mod;
		int flag=0;
		for(int i=1;i<m;i++)
		{
			int l=a[i].c,r=a[i+1].c;
			if(l==r&&a[i].d!=a[i+1].d)
			{
				flag=1;
				break;
			}
			else if(l==r)
			    continue;
			sum=(sum*(qmi(v,2*(r-l))-(v-1)*qmi(v,r-l-1)%Mod+Mod)%Mod)%Mod;
		}
		if(flag)
		{
			cout<<0<<endl;
			continue;
		}
		sum=(sum*qmi(v,2*(n-a[m].c)))%Mod;
		cout<<sum<<endl;
	}
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：3)

把每个一元限制对应的点称为“关键点”，其他的称为“非关键点”。

首先我们不需要关心非关键点的二元限制值具体为多少，因为是 $1\sim v$ 的任何值都没有任何影响。所以只在关键点计算答案就可以。

看完题目，马上就能想到，所谓的一种二元限制赋值方法不能被同时满足，肯定是这样的：某一个关键点的值触发了一个二元限制，引起连锁反应，最终推出另一个关键点的值和规定矛盾。

那么给关键点排序。只要保证对于每个关键点，都不能间接的使得下一个关键点的值出现矛盾。设当前关键点对应的一元限制是 $c_i,d_i$，下一个是 $c_{i+1},d_{i+1}$。

首先随便分配值：这两个点中间的的二元限制个数为 $c_{i+1}-c_i$，每个二元限制有两个值，都可以随便取 $[1,v]$ 中的整数。所以一共 $v^{2(c_{i+1}-c_i)}$。

然后再减去不行的。可以看成是把中间所有非关键点随便赋值，然后后面那个关键点的值不等于规定的值。所以数量是 $(v-1)v^{c_{i+1}-c_i-1}$。

这些值都可以用快速幂算出。然后所有小段的值乘起来就行了。时间复杂度 $O(m\log n)$。

哦对了如果出现样例一最后一组数据那种情况，特判输出 $0$ 即可。

代码中有些小细节和题解中写的不太一样。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int mod=1e9+7;
int t,n,m,k;
struct node{int p,x;}a[100010];
bool operator<(const node &x,const node &y){
    return x.p<y.p;
}
bool operator==(const node &x,const node &y){
    return x.p==y.p;
}
int qpow(int x,int y)
{
    int mul=1;
    while(y)
    {
        if(y&1)mul=1ll*mul*x%mod;
        y>>=1,x=1ll*x*x%mod;
    }
    return mul;
}
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n>>m>>k;
        for(int i=1;i<=m;i++)cin>>a[i].p>>a[i].x;
        sort(a+1,a+m+1);
        bool flag=1;
        for(int i=1;i<m;i++)
            if(a[i]==a[i+1]&&a[i].x!=a[i+1].x)
            {
                flag=0;
                break;
            }
        if(!flag)
        {
            cout<<0<<endl;
            continue;
        }
        m=unique(a+1,a+m+1)-a-1;
        int mul=1;
        for(int i=1;i<=m;i++)
        {
            int now1=qpow(k,2*(a[i].p-a[i-1].p));
            int now2=1ll*(k-1)*qpow(k,a[i].p-a[i-1].p-1)%mod;
            if(i==1)mul=qpow(k,2*(a[i].p-1));
            else mul=1ll*mul*(now1+mod-now2)%mod;
        }
        cout<<1ll*mul*qpow(k,2*(n-a[m].p))%mod<<endl;
    }
    return 0;
}
```

---

## 作者：guoziyang21 (赞：3)

# 题面

~~（一道不错的J组T3）~~

~~（今年NOIP的T2比T1还水是什么情况？？？）~~

[题目传送门](https://www.luogu.com.cn/problem/P11362)

有 $ n $ 个取值在 $ [1,v] $ 内的整型变量 $ x_1,x_2,\cdots,x_n $，满足 $ m $ 条一元限制，第 $ j (1 \le j \le m)$ 条的内容是：$ x_{c_j}=d_j $。现在需要构造 $ n-1 $ 条二元限制，第 $ i(1\le i \le n-1) $ 条的内容是：若 $ x_i=a_i $，则 $ x_{i+1}=b_i $。那么有多少种构造二元限制的方案数使得这 $ n $ 个变量 $ x_1,x_2,\cdots,x_n $ 存在？答案对 $ 10^9+7 $ 取模。

# 思路

我们先来解决一个简化的问题：

> (#) 有 $ n $ 个取值在 $ [1,v] $ 内的整型变量 $ x_1,x_2,\cdots,x_n $，其中 $ x_1 $ 和 $ x_n $ 为定值，那么一共有多少种构造二元限制的方案使得 $ x_1,x_2,\cdots,x_n $ 存在？

考虑反面，计算使得这 $ n $ 个变量不存在的二元限制，这 $ n-1 $ 个二元限制一定形如：

$$ (a_1,b_1)=(t_1,t_2),(a_2,b_2)=(t_2,t_3),\cdots,t_{n-1}),(a_{n-1},b_{n-1})=(t_{n-1},t_n) $$

其中 $ t_1=x_1,t_n \ne x_n $。

根据乘法原理，方案个数为 $ v^{n-2}(v-1) $（这里 $ t_1 $ 是确定的，$ t_2,t_3,\cdots,t_{n-1} $ 有 $ 1 $ 到 $ v $ 的 $ v $ 种取法，$ t_n $ 不取 $ x_n $ 有 $ v-1 $ 种取法），总方案数为 $ (v^2)^{n-1} $（每个 $ a_i,b_i $ 都有 $ 1 $ 到 $ v $ 的 $ v $ 种取法）。 

于是所求为：
$$ (v^2)^{n-1}-v^{n-2}(v-1) $$

如果 $ x_1 $ 或 $ x_n $ 中有一个不是定值，容易证明，全部的 $ (v^2)^{n-1} $ 种方案都有对应的 $ x_1,x_2,\cdots,x_n $ 存在（对于 $ x_1 $ 不是定值的情况，因为没有 $ x_1 $ 的限制，只要让 $ x_1,x_2,\cdots,x_{n-1} $ 避免踩中二元限制即可；对于 $ x_n $ 不是定值的情况，因为没有 $ x_n $ 的限制，所以这一段的二元限制是啥也不重要了）。

---

回到原题，题目中给出的 $ m $ 条一元限制自然地把 $ x_1,x_2,\cdots,x_n $ 分割成了 $ m+1 $ 个子序列 $ x_{c_j}=d_j,x_{c_j+1},\cdots,x_{c_{j+1}}=d_{j+1} (c_0=1,c_{m+1}=n,j=0,1,\cdots,m)$（这里默认 $ c_1,c_2,\cdots,c_m $ 互不相同且按升序排序），它们分别对应一个问题(#)。根据乘法原理，把所有的结果相乘即可。

可以列出最后结果的公式：

$$ (v^{c_1-1})^2 \times \prod_{i=1}^{m-1} [(v^{c_{i+1}-c_i})^2-v^{{c_{i+1}-c_i}-1}\times(v-1)] \times (v^{n-c_m})^2 $$

由于涉及到幂的计算，需要写快速幂；同时不要忘记对结果取模以及对 $ m $ 条一元限制排序。

总时间复杂度：$ O(Tm(\log m+\log n)) $，空间复杂度：$ O(m) $。

具体实现见代码。

# 代码

[AC记录](https://www.luogu.com.cn/record/192088951)

```cpp
# include<iostream>
# include<algorithm>
using namespace std;
# define ll long long

const int M=1e5+2;
const ll mod=1e9+7;

struct limit{
	int c;
	ll d;
	void in(){
		cin>>c>>d;
	}
}a[M];

int t,n,m,g;
ll v,tmp,ans;

bool cmp(limit x,limit y){
	return (x.c==y.c?x.d<y.d:x.c<y.c);
}

ll pow(ll x,int y){
	if(x==0||x==1||y==1) return x;
	if(y==0) return 1;
	ll t=pow(x,y/2);
	if(y%2) return t*t%mod*x%mod;
	else return t*t%mod;
}

void solve(){
	cin>>n>>m>>v;
	ans=1; //务必记得初始化 
	for(int i=1;i<=m;++i) a[i].in();
	sort(a+1,a+m+1,cmp); //c_j不一定按升序给出 
	for(int i=0;i<=m;++i){
		if(i>0&&i<m&&a[i].c==a[i+1].c){
			if(a[i].d==a[i+1].d) continue;
			else{
				ans=-1;
				break;
			}
		} //如果有矛盾的一元限制（如样例1-3），那么结果为0，务必记得特判 
		if(i==0){
			g=a[1].c-1;
			tmp=pow(v%mod,2*g);
		}
		else if(i==m){
			g=n-a[m].c;
			tmp=pow(v%mod,2*g);
		}
		else{
			g=a[i+1].c-a[i].c;
			tmp=(pow(v%mod,2*g)-pow(v%mod,g-1)*(v-1)%mod+mod)%mod;
		}
		ans=ans*tmp%mod;
	}
	if(ans==-1) cout<<0<<endl;
	else cout<<ans%mod<<endl;
}

int main(){
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

update:

2024.11.30 通过了民间数据，提交审核

---

## 作者：Z3k7223 (赞：2)

一个小时切这题却没切 T1，破防了。

## Solution

下面记确定的点为 `1`，不确定的为 `0`。

可以考虑计算连续的 $k-1$ 个 `0` 和它之前的一个 `1` 的方案，当 $a,b$ 全部都随便取的时候就是 $v^{2k}$，然而当它后面有一个 `1` 的时候就要扣掉从这个 `1` 到下个 `1` **一定无法满足条件**的方案，即 $\forall j \in [i',i-1],b_j=a_{j+1}$，且 $a_i\ne c_j$，其中 $i'$ 为当前 `1` 的位置，$i$ 为下个 `1` 的位置。可以发现每一个 $b$ 都取决于上一个 $a$，那么前面 $k-1$ 个位置有 $v$ 个取值，最后一个位置有 $(v-1)$ 个。所以这一段长度为 $k$ 的区间的贡献为 $v^{2k}-(v-1)v^{k-1}$，快速幂解决即可。

还要注意一下第一个 `1` 和最后一个 `1` 的贡献是不用减去无法满足条件这个部分的（前者是因为你可以构造一个 $x_1\ne a_1$），还有记得判无解。

## Code

时间复杂度 $O(m (\log m+\log n))$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll N = 1e5 + 10, mod = 1e9 + 7;
int n, m;
ll v;

struct node {
	int c, d;
	friend bool operator==(node x, node y) {
		return x.c == y.c && x.d == y.d;
	}
	friend bool operator<(node x, node y) {
		return x.c < y.c;
	}
} a[N];

ll qpow(ll x, int y) {
	if (y == 1) {
		return x;
	}
	if (y <= 0) {
		return 1;
	}
	if (y & 1) {
		return qpow(x, y ^ 1) * x % mod;
	} else {
		ll res = qpow(x, y >> 1);
		return res * res % mod;
	}
}

void solve() {
	cin >> n >> m >> v;
	for (int i = 1; i <= m; i++) {
		cin >> a[i].c >> a[i].d;
	}
	sort(a + 1, a + m + 1);
	m = unique(a + 1, a + m + 1) - a - 1;
	ll ans = qpow(v, (a[1].c - 1) << 1);
	for (int i = 2; i <= m; i++) {
		if (a[i].c == a[i - 1].c) {
			cout << "0\n";
			return;
		}
		int len = a[i].c - a[i - 1].c;
		ans = ans * (qpow(v, len << 1) - qpow(v, len - 1) * (v - 1) % mod + mod) % mod;
	}
	if (a[m].c < n)
		ans = ans * qpow(v, (n - a[m].c) << 1) % mod;
	cout << ans << '\n';
}

int main() {
	int t;
	cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

---

## 作者：SmileMask (赞：1)

正难硬做。
# $m = 1$
首先对于所有 $(a,b)$ 序列，必然能取 $x_i\neq a_i$ 因此序列任取，答案为 $v^{2\times (n-1)}$。
# $n = m$
记 $f_i$ 为长度为 $i$ 的合法 $(a,b)$ 序列，若 $x_{i+1}=a_{i+1}$ 则 $b_{i+1}$ 仅有一种取值，否则有 $v$ 种取值，可以 $f_i+f_i\times v\times(v-1)]\rightarrow f_{i+1}$ 递推得出 $f_{m-1}$。 
# 正解
根据乘法原理，可以分别求出所有确定位连续段方案数和非确定连续段方案数乘起来。
- 若是序列两端的非确定连续段，方案数为 $v^{2\times len}$。
- 若是确定连续段可以递推出系数直接求出，方案数为 $f_{len-1}$。
- 若是在中间的非确定连续段，记其长度为 $n$，则具体的 $x$ 序列记为 $x_0,x_1,\dots,x_{n}$。$x_0$ 特指上一段末尾的数。具体的计数可以枚举前缀长度 $i$ 满足 $\forall j\in[1,i],x_{j-1}=a_{j},x_j=b_j，x_{i}\neq a_i$，方案数即为 $(\sum_{i=0}^{n-1} v^i \times v\times (v-1)\times v^{2(n-i)})+v^n$，具体化简为 $v^n+v^{2n+1}\times (v-1)\times \frac{\frac{1}{v^{n+1}}-1}{\frac{1}{v}-1}$。

分别求出乘起来即可。
# 代码
```cpp
#include<bits/stdc++.h>
#include<ctime>
using namespace std;

namespace Smilemask{
	#define int long long
	typedef long long ll;
	typedef unsigned long long ull;
	typedef pair<int,int> PII;
    #define rd read()
	inline int read(){
		int num=0,sign=1;char ch=getchar();
		while(!isdigit(ch)){if(ch=='-'){sign=-1;}ch=getchar();}
		while(isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
		return num*sign;
	}
	
	const int N=1e5+10;
	const int mod=1e9+7;
	
	map <int,int> mp;
	vector <int> pos;
	vector <PII> vec;
	int n,m,v,f[N];
	
	int qmi(int x,int y){
		int res=1;
		while(y){
			if(y&1) res=res*x%mod;
			x=x*x%mod;y>>=1;
		}
		return res;
	}
	
	void Main(){
		n=rd,m=rd,v=rd,f[0]=1;
		map <int,int>().swap(mp);
		vector <int>().swap(pos);
		vector <PII>().swap(vec);
		bool fl=1;
		for(int i=1;i<=m;i++){
			int c=rd,d=rd;
			if(!mp.count(c)) mp[c]=d;
			else if(mp[c]!=d) fl=0;
		}
		if(!fl) return puts("0"),void(); 
		for(auto e:mp) pos.push_back(e.first);
		int invv=qmi(v,mod-2);
		int last=-1,pre=-1;
		for(int i=0;i<(int)pos.size();i++){
			if(i){
				if(pre+1!=pos[i]) vec.push_back({last,pos[i-1]}),last=pre=pos[i];
				else pre=pos[i];
			}
			else last=pre=pos[i];
		}
		if(last) vec.push_back({last,pos.back()});
		int ans=1;
		for(int i=1;i<=m;i++) f[i]=f[i-1]*(1+v*(v-1)%mod)%mod;
		int l=1,r=max(0ll,vec.front().first-1);
		if(l<=r) ans=ans*qmi(v,2*(r-l+1))%mod;
		l=vec.back().second+1,r=n;
		if(l<=r) ans=ans*qmi(v,2*(r-l+1))%mod;
		for(int i=0;i<(int)vec.size()-1;i++){
			int l=vec[i].second+1,r=vec[i+1].first-1;
			int len=r-l+1;
			int mul=(qmi(v,len)+qmi(v,2*len+1)*(v-1)%mod*(qmi(invv,len+1)+mod-1)%mod*qmi(invv-1,mod-2)%mod)%mod;
			ans=ans*mul%mod;
		}
		for(int i=0;i<(int)vec.size();i++)
			ans=ans*f[vec[i].second-vec[i].first]%mod;
		cout<<ans<<endl;
	}
}

signed main(){
//	freopen("assign.in","r",stdin);
//	freopen("assign.out","w",stdout);
	int T;
	scanf("%lld",&T);
	while(T--) Smilemask::Main();
	return 0;
}
```

---

## 作者：dyc2022 (赞：1)

被 T1 吓到了。不会 T1，令人汗颜。

首先，我们注意到 $d_i$ 是没用的，它只是给你用来确定一个定值。

然后，我们会发现由于值域为 $[1,v]$，因此一个没有限制的二元组 $(a_i,b_i)$ 总共有 $v^2$ 种取值。于是我们正难则反，先求出有多少种可能的二元组，再扣掉不符合的。

我们再注意一串二元组 $(a_x,b_x),(a_{x+1},b_{x+1}),\cdots,(a_y,b_y)$ 不符合条件，当且仅当：

1. $x$ 位置和 $y$ 位置为定值。
2. $a_x = d_x,a_{x+1}=b_x,a_{x+2}=b_{x+1},\cdots,b_y=d_{y+1}$。

条件 1 好搞，直接枚举两个相邻的单点确定即可。

条件二我们会发现我们在计算时每个二元组的第一项都是确定的，而这一串二元组的最后一个的第二项共有 $v-1$ 种取值（扣掉 $d_{y+1}$），其余二元组的第二项可以随便选，即有 $v$ 种取值。那么要扣掉的就是 $v^{y-x-1} \times (v-1)$。

那么这题就做完了，把所有单点确定排序，若有冲突输出误解，否则按照上述流程操作即可。

福建代码公示还没破解，代码是我按照考场代码默写的，能过民间数据，希望不挂。

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 100006
#define MOD 1000000007
using namespace std;
int T,n,m,v;
struct Node{int k,x;}a[N];
int qpow(int x,int y)
{
    if(y==0)return 1;
    if(y==1)return x%MOD;
    int ret=qpow(x,y>>1);
    return ret*ret%MOD*qpow(x,y&1)%MOD;
}
main()
{
    scanf("%lld",&T);
    while(T--)
    {
        scanf("%lld%lld%lld",&n,&m,&v);
        for(int i=1;i<=m;i++)scanf("%lld%lld",&a[i].k,&a[i].x);
        sort(a+1,a+1+m,[](Node x,Node y){
             return x.k<y.k;
        });
        int ans=qpow(v*v%MOD,a[1].k-1);
        for(int i=2;i<=m;i++)
        {
            if(a[i].k==a[i-1].k&&a[i].x!=a[i-1].x){ans=0;break;}
            else if(a[i].k==a[i-1].k)continue;
            int sum=qpow(v*v%MOD,a[i].k-a[i-1].k);
            sum-=qpow(v%MOD,a[i].k-a[i-1].k-1)*(v-1)%MOD;
            sum%=MOD,sum+=MOD,sum%=MOD;
            ans*=sum,ans%=MOD;
        }
        if(ans)ans*=qpow(v*v%MOD,n-a[m].k),ans%=MOD;
        printf("%lld\n",ans);
    }
    return 0;
}
```

但是 Ri 说写了一个神奇 dp，不知道她是怎么做的。

---

## 作者：Wei_Han (赞：1)

考场思路。

首先显然，当两个限制的 $c_i$ 一样可是 $d_i$ 却不一样时，一个位置无法有两个取值，所以答案为 $0$。

考虑前后两个点的关系，我们称一个限制 $c_i$ 是将 $x_{c_i}$ "固定"：

- 当两个点都未被固定时，那么我们可以随便取值，由乘法原理得，方案数是 $v^2$

- 当前一个点固定时，我们可以让这个限制不成立，令限制的取值与前一个数的值不同，后一个数随便取，所以方案是 $v(v-1)$，我们当然也可以令前一个数取到固定的值，这样下一个数由于没有限制，方案是 $v$，所以总的还是是 $v^2$。

- 当后一个点固定时，基本与上一种情况相同，在前一个点未被确定时，方案数还是 $v^2$。

- 当两个点都被固定时，我们可以令这个限制不成立，也就是令 $a_i \neq x_{i}$，这样有 $v(v-1)$ 种方案，当这个限制成立时，那么我们必须取到这两个值，所以方案只有 $1$ 种，所以总的方案为 $v(v-1)+1$。

发现上述分析是有问题的，因为我们只考虑了前后两个点的取值，再放大一些，假设现在有两个不相邻的固定的点，并且我们令左侧固定点处的限制的 $a_i = x_i$，进一步，令这中间所有的取值都是 $a_i = b_{i-1}$，这样这一段的所有取值就全是被“固定”了的，那么按照上述算法我们就可能会取到令 $b_{i-1} \neq x_i$，这里 $i$ 是右侧固定点的下标，那么此时这个答案是不成立的，但我们把它加入了答案，所以要减去这一种情况。而再分析这种情况，发现中间这一段的 $x_i$ 取值是随意的，而最右侧的限制只要不取到右侧的固定点值就好了，所以是 $v^{l}\times (v-1)$，这里 $l$ 是从左侧到右侧中间空位置的个数。

综上，我们发现只需要讨论前后两个点是否全是固定点即可，如果不是，加上总方案数再减去不合法情况即可。

注意算上开头结尾的方案。

总的复杂度是 $O(m\log n)$。

```cpp
inline void solve(){
	read(n),read(m),read(v);
	fo(1,i,m) read(a[i].c),read(a[i].d);
	sort(a+1,a+1+m,cmp);ll cnt=0;
	fo(1,i,m){if(i!=1&&a[i].c==a[i-1].c&&a[i].d!=a[i-1].d) return wr(0),pr,void();if(a[i].c!=a[i-1].c||i==1) b[++cnt]=a[i];}
	m=cnt;fo(1,i,cnt) a[i]=b[i];
	ll sum=qpow(v*v%mod,a[1].c-1);
	fo(2,i,m){
		if(a[i].c==a[i-1].c+1) sum=sum*(v*(v-1)%mod+1)%mod;
		else sum=sum*((qpow(v*v%mod,a[i].c-a[i-1].c)%mod-qpow(v,a[i].c-a[i-1].c-1)%mod*(v-1)%mod+mod)%mod)%mod;
	}
	sum=sum*qpow(v*v%mod,n-a[m].c)%mod;
	wr(sum),pr;
}
``````

---

## 作者：某个新手 (赞：1)

个人感觉 T2 和 T1 差不多，甚至比 T1 好做一点。

可以先考虑只对 $x_1$ 和 $x_n$ 有限制的情况。直接算发现不好算，考虑计算不合法方案数，再用总方案数减去。总方案数是好算的，$a_i,b_i$ 都可以从 $[1,n]\cap\mathbb{Z}$ 中任选，总共 $(v^2)^{n-1}$ 种方案。方案不合法当且仅当 $a_1=x_1\land\forall2\le i<n,a_i=b_{i-1}\land b_{n-1}\neq x_n$，除 $b_{n-1}$ 有 $(v-1)$ 种方案外，其余的 $b_i$ 都有 $v$ 种方案，所以总共有 $v^{n-2}(v-1)$ 种方案。

再考虑一般情况，我们可以把相邻两个限制分为一组，发现每组限制之间不互相影响，于是我们将每组限制用上面的方法算出来，然后把每组的答案乘起来，另外第一个限制左边和最后一个限制右边都没有限制，再乘上这两段的答案就是最终答案。

用表达式表示如下：

先按 $c_i$ 从小到大排序

答案为 $v^{2(c_1-1+n-c_m)}\prod\limits_{i=2}^{m}[v^{2(c_i-c_{i-1})}-v^{c_i-c_{i-1}-1}(v-1)]$

另外题目没有保证不存在 $c_i=c_j(i\neq j)$，遇到这种情况如果 $d_i=d_j$ 直接跳过，否则答案为0。

## 代码

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
typedef long long ll;
using namespace std;
struct node{
	int c,d;
}a[100001];
inline bool cmp(const node &x,const node &y){
	return x.c < y.c;
}
inline int power(int b,int x){
	int res = 1;
	for (;x;x >>= 1){
		if (x & 1)res = (ll)res * b % mod;
		b = (ll)b * b % mod;
	}
	return res;
}
int main(){
	ios::sync_with_stdio();
	cin.tie(),cout.tie();
	int t,n,m,v,ans,i;
	cin>>t;
	while (t--){
		cin>>n>>m>>v;
		for (i = 1;i <= m;++i)
			cin>>a[i].c>>a[i].d;
		sort(a + 1,a + 1 + m,cmp);
		ans = power(v,(a[1].c - 1ll + n - a[m].c << 1) % (mod - 1));
		for (i = 2;i <= m;++i){
			if (a[i - 1].c == a[i].c){
				if (a[i - 1].d != a[i].d){
					ans = 0;
					break;
				}
				continue;
			}
			ans = (ll)ans*(power(v,a[i].c-a[i-1].c<<1)-power(v,a[i].c-a[i-1].c-1)*(v-1ll)%mod+mod)%mod;
		}
		cout<<ans<<endl;
	} 
	return 0;
}
```

---

## 作者：aCssen (赞：1)

### Solution

考虑不合法的情况是什么样子，一定是一个已经确定的 $x_i$ 推出来了下一个已经确定的 $x_j$ 不是它被确定的那个值。这两个位置应该是连续的，因为一段长的不合法总能拆成短的不合法。

因此，对输入的位置排序去重，顺便简单的判一下无解，然后计数。

初步想法是用所有方案减去这样的不合法方案，但是有的方案有多个位置不合法，考虑进行容斥。现在枚举一个 $\{1,m-1\}$ 的子集 $S$，表示钦定 $S$ 中的段不合法，其他位置任意，就是说，钦定 $i,i+1(i \in S)$ 这一部分不合法。考虑计算方案数。

对于一个钦定的 $i$，它已经确定，那么 $a_i$ 必须是这个确定的值，$b_i$ 任意，方案数是 $v$，然后下一个位置时这个位置的数又确定了，因此 $a_i$ 也确定了，方案数还是 $v$，最后一轮的时候不能取到给定的值，因此方案数是 $v-1$，因此总的方案数是 $v^{len-1}(v-1)$。对于没有钦定的位置，$a,b$ 都任意，方案数是 $v^2$。考虑容斥系数，对于一个不合法位置的要减去，两个就是加上了，因此，一个 $S$ 的贡献就是：

$$(-1)^{|S|} v^{2(n-1-|S|)}\prod_{i \in S}v^{a_{i+1}-a_i-1}(v-1)$$

然后把这个改成 dp，设 $f_i$ 表示考虑了前 $i$ 个元素的答案，$f_0$ 表示没有钦定也就是初始答案 $v^{2n-2}$。转移就是不钦定 $i$ 的 $f_{i-1}$ 和钦定 $i$ 的 $-\frac {f_{i-1}v^{a_{i+1}-a_i-1}(v-1)}{v^{2(a_{i+1}-a_i)}}$，除法是因为未钦定的位置少了 $a_{i+1}-a_i$ 这么多。答案直接是 $f_{m-1}$。

复杂度 $\mathcal{O}(Tm \log n)$。

---

## 作者：UniGravity (赞：1)

## Solution P11362 [NOIP2024] 遗失的赋值
带图。

二元限制只针对相邻部分，所以每个确定的值把序列分成了若干互相无关的连续段。只需要算出每个连续段的答案最后乘起来即可。

二元限制可以看成一条链，则这条链上 $b_i=a_{i+1}$。对于一条链，如果起始确定了则末尾值一定确定。

考虑两个限制 $i,i+1$ 的中间怎么选。发现由于头和尾全部确定，只要中间这条链断开了就有一种选法使得最后的值不是 $d_{i+1}$（只要每次都选择与链上的值不同的即可）。

考虑减去**不合法**的情况，即仅连成了一条链。全部的情况则是每个数的 $a,b$ 任意选。

![](https://cdn.luogu.com.cn/upload/image_hosting/jwm5b4k7.png)

如上图，则必然有 $S=a_1,b_1=a_2,b_2=a_3,\cdots,b_5=a_6$ 且 $b_6\neq T$。

$S,T$ 中间的可以任意选择值，只需要这个位置上的 $a,b$ 都等于这个值即可，最后的 $b$ 必须不等于 $T$，有 $v-1$ 种取法。所以如果 $S,T$ 的位置分别在 $l,r$，则这一段的**合法**方案数为：

$$cnt=v^{2(r-l)}-v^{r-l-1}(v-1)$$

对于起始两段，由于头和尾是可以随便选的，则一定存在一种情况可以使得存在合法情况。头的方案数是 $v^{2(c_1-1)}$，尾是 $v^{2(n-c_m)}$。

同时还有一些不合法的情况，即如果存在 $c_i=c_j$ 且 $d_i\neq d_j$ 时需要特判。

快速幂即可。时间复杂度 $O(m\log V)$。

---

## 作者：潘德理2010 (赞：1)

不难想到，可以先考虑每两个相邻的数对答案的贡献。

如果是两个相邻的已经确定的（即被一元限制确定下来的）数，那么，这两个数之间的限制有 $v^2-v+1$ 种可能的情况。（相当于总共 $v^2$ 种情况减去不成立的 $v-1$ 种）。

如果第一个数是不确定，可以任意取的，而第二个数是已经确定的，那么这两个数之间的限制有全部 $v^2$ 种情况（因为我可以改变第一个数的值，使其避开限制）。

再考虑这一种情况：有一个数是已经确定的，和下一个确定的数之间隔着 $n$ 个不确定的数。这时，我们先不管最后一个确定的数，看前面的 $n+1$ 个数。这时发现，所有 $v^{2n}$ 种可能的限制都可以成立。但是，在 $v^{2n}$ 种限制中，有 $v^n$ 种会使得这 $n$ 个不确定的数中的最后一个数被确定下来（分别对应了这 $n$ 种数的 $v^n$ 种情况），而其它的则不会。这时再考虑后面的那确定一个数，可以得出这些数的总情况为：（加号前面的是最后一个不确定的数未被确定的情况，加号后面的是这个数被前面的限制确定下来的情况）

$$ (v^{2n}-v^n)\times v^2+v^n\times (v^2-v+1)$$

另外，对于第一个确定的数前面的，和最后一个确定的数后面的不确定的数，显然，每有一个这样的数，答案再乘以 $v^2$。

这里要用快速幂算。最后把上面所有答案（即首尾的不确定的数，中间相邻确定的数，以及两个确定的数中间夹的不确定的数）乘起来即可。

代码等公示出来再发。

---

## 作者：Brain_Huger (赞：0)

柯爱柿子题

## 题目分析

看到 $n \le 10^9$，$m \le 10 ^5$，很容易想到分段考虑。

先将数组 $c$ 排序，把 $1$ 到 $c_1$ 分为一段，$c_1$ 到 $c_2$ 分为一段，以此类推到 $c_m$ 到 $n$。

可以发现，若一段区间 $[l,r]$ 满足 $l = r$ 那么这个区间贡献为 $1$。

接下来就是计算剩余每一段的贡献。

假设这段区间为 $[l,r]$。若 $k$ 使得存在 $c_k=l$，那么会发现 $l$ 上的数有 $v$ 种选择，而其中 $v-1$ 种选择剩下的 $[l,r)$ 全部不确定，而又因为 $r-1$ 不确定，所以 $b_{r-1}$ 也有 $v$ 种选择，所以总共 $v^{2\times(r-l+1)-1} \times (v-1)$。 否则 $l+1$ 确定，且又有 $v$ 种选择，于是将区间 $l+1,r$ 继续做一遍上面的计数，将答案多乘一个 $v$。

重复上面的步骤直到区间 $[r-1,r]$。我们发现，若存在 $k$ 使得 $c_k=r$，因为 $a_{r-1}$ 等于 $r-1$ 上的数，所以贡献为 $1$，否则贡献为 $v$。

那么我们就发现每一段区间 $[l,r]$ 的答案就是这样：
$$$
v^{2\times(r-l)-1} \times (v-1) + v^{2\times(r-l)-2} \times (v-1) + \cdots + v^{2\times(r-l)-r+l} \times (v-1) + f(r)
$$$

其中 $f(r)$ 为若存在 $k$ 使得 $c_k=r$，答案为 $v^{2\times(r-l)-r + l - 1}$，否则贡献为 $v^{2\times(r-l)-r+l}$。

~~然后赛时就死在了这里。~~

接着我们发现可以将 $f(r)$ 前面的那坨东西整理下，就变成了这样：

$$$
(v-1)\times(v^{2\times(r-l)-1} + v^{2\times(r-l)-2} + \cdots + v^{2\times(r-l)-r+l} )+ f(r)
$$$

我们发现一个公式：

$S(x,n) = x^0 + x^1 + x^2 + \cdots + x^n$。

$x\times S(x,n) = x^1+x^2+x^3+\cdots+x^{n+1}$。

$x\times S(x,n)-S(x,n) = x^{n+1}-1$

$S(x,n) = \frac{x^{n+1}-1}{x-1}$

于是答案便成为了：

$$$
(S(v,2\times(r-l)-1)-S(v,2\times(r-l)-r+l-1))\times(v-1) + f(r)
$$$

最后将所有区间的贡献乘起来即可，时间复杂度 $O(Tmlog_2n)$，注意要把 $[1,c_1]$ 这个区间要特殊判断。

## 代码
```
#include <bits/stdc++.h>
namespace FAST_IO {
const int LEN = 1 << 18;
char BUF[LEN], PUF[LEN], space = ' ', line = '\n';
int Pin = LEN, Pout;
inline void flushin() {
    memcpy(BUF, BUF + Pin, LEN - Pin), fread(BUF + LEN - Pin, 1, Pin, stdin),
        Pin = 0;
    return;
}
inline void flushout() {
    fwrite(PUF, 1, Pout, stdout), Pout = 0;
    return;
}
inline char Getc() {
    return (Pin == LEN ? (fread(BUF, 1, LEN, stdin), Pin = 0) : 0), BUF[Pin++];
}
inline char Get() { return BUF[Pin++]; }
inline void Putc(char x) {
    if (Pout == LEN)
        flushout(), Pout = 0;
    PUF[Pout++] = x;
}
inline void Put(char x) { PUF[Pout++] = x; }
template <typename tp = int> inline void read(int &X) {
    (Pin + 32 >= LEN) ? flushin() : void();
    tp res = 0;
    char f = 1, ch = ' ';
    for (; ch < '0' || ch > '9'; ch = Get())
        if (ch == '-')
            f = -1;
    for (; ch >= '0' && ch <= '9'; ch = Get())
        res = (res << 3) + (res << 1) + ch - 48;
    X = res * f;
    return;
}
template <typename tp = char> inline void read(char &X) {
    X = Getc();
    return;
}
template <typename tp> inline void wt(tp a) {
    if (a > 9)
        wt(a / 10);
    Put(a % 10 + '0');
    return;
}
template <typename tp = int> inline void write(int a) {
    static int stk[20], top;
    (Pout + 32 >= LEN) ? flushout() : void();
    if (a < 0)
        Put('-'), a = -a;
    else if (a == 0)
        Put('0');
    for (top = 0; a; a /= 10)
        stk[++top] = a % 10;
    for (; top; --top)
        Put(stk[top] ^ 48);
    return;
}
template <typename tp = char> inline void write(char a) {
    Put(a);
    return;
}
template <typename T, typename... Args> void read(T &tmp, Args &...tmps) {
    read(tmp), read(tmps...);
}
template <typename T, typename... Args> void write(T &tmp, Args &...tmps) {
    write(tmp), write(tmps...);
}
} // namespace FAST_IO
using namespace FAST_IO;
const int mod = 1e9 + 7;
int t, n, m, v, ans, lst, dth;
struct st {
    int c, d;
} a[100002];
int qpow(int x, int y, int mod) {
    if (y < 1)
        return 1;
    int tmp = qpow(x, y / 2, mod);
    if (y & 1)
        return 1ll * x * tmp % mod * tmp % mod;
    return 1ll * tmp * tmp % mod;
}
inline int inv(int x) { return qpow(x, mod - 2, mod); }
inline int S(int x, int n) {
    return 1ll * (qpow(x, n + 1, mod) - 1) % mod * dth % mod;
}
void solve(int l, int r) {
    int val = S(v, 2 * (r - l) - 1) - S(v, 2 * (r - l) - r + l - 1);
    val = (val + mod) % mod;
    val = 1ll * val * (v - 1) % mod;
    val = (val + qpow(v, 2 * (r - l) - r + l, mod)) % mod;
    ans = 1ll * ans * val % mod;
}
void sol(int l, int r) {
    int val = S(v, 2 * (r - l) - 1) - S(v, 2 * (r - l) - r + l - 1);
    val = (val + mod) % mod;
    val = 1ll * val * (v - 1) % mod;
    val = (val + qpow(v, 2 * (r - l) - r + l - 1, mod)) % mod;
    ans = 1ll * ans * val % mod;
}
signed main() {
    read(t);
    for (; t--;) {
        read(n, m, v), ans = lst = 1, dth = inv(v - 1);
        for (int i = 1; i <= m; i++)
            read(a[i].c, a[i].d);
        std::sort(a + 1, a + 1 + m, [](st x, st y) { return x.c < y.c; });
        for (int i = 1; i <= m; i++)
            if (a[i].c == a[i - 1].c && a[i].d != a[i - 1].d)
                ans = 0;
        if (!ans) {
            puts("0");
            continue;
        }
        for (int i = 1; i <= m; i++) {
            if (a[i].c == a[i - 1].c)
                continue;
            if (lst == 1 && i == 1 && a[i].c != 1)
                solve(lst, a[i].c);
            else if (a[i].c != 1)
                sol(lst, a[i].c);
            lst = a[i].c;
        }
        if (a[m].c != n)
            solve(a[m].c, n);
        printf("%d\n", ans);
    }
    return 0;
}
/*
    1 0 0 0 1
(v-1)*v*v*v*v*v*v*v
(v-1)*v*v*v*v*v*v*v
(v-1)*v*v*v*v*v*v*v
(v-1)*v*v*v*v*v*v*v
*/
```

注意需要略微卡常。

---

## 作者：modfish_ (赞：0)

## 思路
注意到确定的值会将所有变量分为若干段，显然各段之间相互独立。以下讨论其中一段 $[c_p,c_q]$（$q$ 是满足 $c_i>c_p$ 的最小的 $i$）。

容易发现，一个变量 $x_i$ 被限定为 $b_{i-1}$，当且仅当它本身就是二类限制（即存在 $c_j=i,d_j=b_{i-1}$），或者它前面的变量 $x_{i-1}$ 被限定为 $a_{i-1}$ 而且第 $i-1$ 位的一类限制 $(a_{i-1},b_{i-1})$。

不难推出，如果这一段无解，当且仅当 $a_{c_p}=d_p,b_{c_p}=a_{c_{p+1}},b_{c_{p+1}}=a_{c_{p+2}},\dots,b_{c_{q-2}}=a_{c_{a-1}},b_{c_{q-1}}\ne d_q$。（挺显然的吧）。

所以直接容斥，把这一段的总方案数 $v^{2(c_q-c_p)}$ 减去不合法的方案数 $v^{c_p-c_q-1}(v-1)$ 即可。所有段乘起来即为答案。当然，需要特别计算一下最左边和最右边两段，这两段不必容斥。

还有，如果二类限制本身矛盾了就直接输出 $0$ 即可（样例也提示了）。

复杂度 $O(m\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 1e5 + 5, p = 1e9 + 7;

struct node{
	int x, v;
}ps[maxn];

bool cmp(node x, node y){
	return x.x < y.x;
}
ll qpow(ll a, ll x){
	ll res = 1;
	while(x){
		if(x & 1) res = res * a % p;
		a = a * a % p;
		x >>= 1;
	}
	return res;
}

int main(){
	int T;
	scanf("%d", &T);
	while(T --){
		int n, m, v;
		scanf("%d %d %d", &n, &m, &v);
		for(int i = 1; i <= m; i ++) scanf("%d %d", &ps[i].x, &ps[i].v);
		sort(ps + 1, ps + m + 1, cmp);
		ll ans = qpow(v, (ps[1].x - 1 + n - ps[m].x) * 2);
		for(int i = 2; i <= m; i ++){
			if(ps[i].x == ps[i - 1].x && ps[i].v != ps[i - 1].v){
				ans = 0;
				break;
			}
			if(ps[i].x == ps[i - 1].x) continue;
			ans = ans * (qpow(v, (ps[i].x - ps[i - 1].x) * 2) + p - qpow(v, ps[i].x - ps[i - 1].x - 1) * (v - 1) % p) % p;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：Sving1024 (赞：0)

其他大佬的题解太强了，我看不懂。于是来记录一下自己的赛事做法。

虽然题目描述很容易让人联想到 2-Sat 之类的问题，但其实一点关系都没有（也许只是我没想到？）。

考虑什么时候会导致某一个一元限制不满足条件。假设第 $i$ 个不满足。注意到以下性质，一元限制只会影响到本身，而二元限制只会影响到下一个数。因此，如果第 $i$ 条限制没有被满足，必然是第 $c_i-1$ 条二元限制被满足，并且 $b_{c_i-1}\not=d_i$。

考虑什么时候第 $j$ 条二元限制会被满足，无非就是以下两种情况：
- 第 $i-1$ 条二元性质被满足，且 $b_{i-1}=a_i$
- 存在 $c_k=i$，并且对应的 $d$ 等于 $a_i$。

将两者结合，可以得到，如果某个一元限制不被满足，必然满足：
$$
\begin{cases}
d_{k-1} = a_{c_{k-1}}\\
b_j=a_{j+1} (j \in [c_{k-1},c_{k}))\\
b_{c_{k}-1}\not=d_k
\end{cases}
$$

容易发现决定每个一元限制是否可以被满足的二元限制与决定另一个一元限制是否可以被满足的互相不重合，因此只要求每组二元限制的合法方案数，在将所有组的合法方案数乘起来即可。

计算方法是总数减去不合法，而且只有第一个 $a$ 和最后一个 $b$ 有限制，中间的 $c_k-c_{k-1}-1$ 个 $a$（或者 $b$，这两个数相等的）可以随便取。根据加乘原理不难得出总方案数等于这个式子：
$$
v^{2(c_k-c_{k-1})}-v^{c_k-c_{k-1}-1}(v-1)
$$

[参考代码](https://www.luogu.com.cn/paste/4bayssvt)

---


# 有向树

## 题目描述

给定一棵 $n$ 个结点的树，将树上所有的无向边变成给定方向的有向边，求所有简单路径的长度之和。

有向图中 $a_1$ 到 $a_x$ 的简单路径是形如 $a_1 \rightarrow a_2 \rightarrow a_3\rightarrow \cdots \rightarrow a_x$ 的路径，其中 $a_1,a_2,a_3,\cdots,a_x$ 这 $x$ 个顶点互不相同，其长度为简单路径上的有向边数量。

## 说明/提示

$1 \le n \le 2\times 10^5$，$1\le u, v \le n$，保证输入数据的有向边在看作无向边时，图构成一棵树。

## 样例 #1

### 输入

```
5
1 2
1 3
1 4
1 5```

### 输出

```
4```

## 样例 #2

### 输入

```
5
1 2
3 1
4 1
5 1```

### 输出

```
10```

## 样例 #3

### 输入

```
4
1 2
2 3
3 4```

### 输出

```
10```

## 样例 #4

### 输入

```
6
1 2
3 2
4 3
5 3
6 3```

### 输出

```
11```

# 题解

## 作者：封禁用户 (赞：8)

记 $f_i$ 表示 $i$ 能到的节点数，$g_i$ 表示以点 $i$ 开始的简单路径的长度之和，初始化 $f_i = 1$ 之后拓扑排序。

设一条边 $v \to u$，假设当前队头为 $u$，显然有：

$$
f_v \gets f_v + f_u
$$

因为 $u$ 能到的点中每个点都会为 $v$ 开始的简单路径的长度多贡献 $1$，所以有：

$$
g_v \gets g_v + g_u + f_u
$$

答案即为 $\sum _ {i = 1} ^ n g_i$。

---

## 作者：tuboshu666 (赞：3)

## **思路**
既然是有向无环图，很容易想到拓扑排序。\
看到大家都是拓扑+ DP 的思路，我就着重讲讲 DP 的过程。\
以该组样例为例：

```cpp
4
1 2
2 3
3 4
```
![](https://cdn.luogu.com.cn/upload/image_hosting/ni09a5uq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\
对于结点 $4$，显然从它出发的路径和为 $0$。\
对于结点 $3$，从它出发的简单路径仅有 $3-4$ 这一条。\
对于结点 $2$，简单路径有 $2-3-4$ 和 $2-3$。\
对于结点 $1$，则有 $1-2-3-4$、$1-2-3$ 和 $1-2$。\
显然，结点 $1$ 的路径 $1-2-3-4$ 是结点 $2$ 的 $1-2-3$ 接上 $1$ ，同理，$1-2-3$ 则是 $2-3$ 接上 $1$。于是发现规律，对于 $1$ 个结点，从其出发的简单路径，为其前一个结点的简单路径接上该结点（这里还需要加上前后两个节点直接相连这条路径，如 $1-2$）。\
这个样例太过简单，我们再举一例。

```cpp
5
1 2
2 3
2 4
4 5
```

![](https://cdn.luogu.com.cn/upload/image_hosting/nwbemz9o.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\
直接看向结点 $2$，从其出发的简单路径有：\
$2-3$\
$2-4-5$\
$2-4$\
存在分叉的结构同样符合以上规律。
## **Solution**
分析完问题，接下来就是解决问题。从上述的分析过程中不难发现，每个结点的路径都和与之相连的结点有关，由此想到 DP。\
既然结点路径为前一个结点的所有路径接上该结点，因此我们需要记录前一个结点的路径数，即:我们需要记录一个结点之前经过了多少个结点。\
用 $cnt$ 数组表示结点先前经过的结点数，用 $d$ 数组记录该结点的最短路径长度和，于是有转移方程：
$$
d_u = \sum_{}^{} {(d_v+cnt_v+1)}{}
$$
## **Code**

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 2e5 + 10;
vector<int> g[N]; //邻接表 
int cnt[N]; //每个点先前经过的点数 
long long d[N]; //各点出发的路径长度 
int in[N]; //入度 
queue<int> q;

int main()
{
	int n;
	cin >> n;
	for (int i = 1 ; i < n ; i++)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		g[v].push_back(u); //反向建图
		in[u]++;
	}
	
	for (int i = 1 ; i <= n ; i++)
	{
		if (!in[i]) q.push(i);
	}
	
	long long sum = 0;
	while (!q.empty())
	{
		int pos = q.front();
		q.pop();
		
		for (int i = 0 ; i < g[pos].size() ; i++)
		{
			int to = g[pos][i];
			cnt[to] += 1 + cnt[pos];
			d[to] += d[pos] + cnt[pos] + 1;
			
			in[to]--;
			if (!in[to]) q.push(to);
		}
		
		sum += d[pos];
	}
	
//	for (int i = 1 ; i <= n ; i++) cout << cnt[i] << " ";
//	cout << endl;
	
	cout << sum << endl;
	
	return 0;
}
```

---

## 作者：fish_love_cat (赞：3)

笑点解析：这题写了 1h（

菜死了 /ll

---

因为是有向无环图，所以可以先跑一个拓扑。

然后对着拓扑序跑一个树形 dp 就做完了。

另外推状态转移方程一定要画图。挂四次基本上都是状态转移方程出锅导致的。

总之就是可以得到如下状态转移方程：

$$ans_u=\sum ans_v+siz_v$$

$$siz_u=1+\sum siz_v$$

最终答案即为 $ret=\sum_{i=1}^{n} ans_i$。

然后就完了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>v[200005];
int f[200005],n;
vector<int>a;
int siz[200005],ans[200005],ret;
void tp(){
    queue<int>q;
    for(int i=1;i<=n;i++){
        if(!f[i])q.push(i);
    }
    while(!q.empty()){
        a.push_back(q.front());
        for(int i=0;i<v[q.front()].size();i++)
        if(--f[v[q.front()][i]]==0)q.push(v[q.front()][i]);
        q.pop();
    }
}
signed main(){
    cin>>n;
    for(int i=1;i<n;i++){
        int x,y;
        cin>>y>>x;v[y].push_back(x),f[x]++;
    }
    tp();
    reverse(a.begin(),a.end());
//    cout<<endl;
    for(int i=0;i<a.size();i++){
//    	cout<<a[i]<<' ';
    	siz[a[i]]=1;
        for(int j=0;j<v[a[i]].size();j++)
        ans[a[i]]+=ans[v[a[i]][j]]+siz[v[a[i]][j]],siz[a[i]]+=siz[v[a[i]][j]];/*(1+1+ans[v[a[i]][j]])*(ans[v[a[i]][j]]+1)/2*/;
        ret+=ans[a[i]];
//		cout<<ret<<' '<<ans[a[i]]<<'\n';
    }
//    cout<<endl;
    cout<<ret;
    return 0;
}
```

---

## 作者：Night_sea_64 (赞：2)

讲个笑话：我赛时过完 A，然后觉得这题比 B 简单，所以过的第二个是这题。

这题，一眼 dp。

设 $f_{x,0/1}$ 为点 $x$ 子树中并且经过点 $x$ 的向上/下的路径条数，$g_{x,0/1}$ 为点 $x$ 子树中并且经过点 $x$ 的向上/下的路径长度总和。

显然 $f$ 的递推方式就是按照跟 $x$ 连向子节点的边的方向一样，直接加上子节点的 $f$ 值。而子节点的 $g$ 贡献到 $x$ 点时，每条路径长度都会增加 $1$。所以 $g$ 的递推就是子节点 $g$ 的值加 $f$ 的值。

我们将只有 $x$ 一个点的路径也计入 $f$ 中。这样以 $x$ 为路径 LCA 的路径权值和就能求出来了：$f_{x,0}\times g_{x,1}+f_{x,1}\times g_{x,0}$。因为在 $g_{x,0}$ 中出现的向上的路径，跟 $x$ 点向下的路径可以一一配对，也就会出现 $f_{x,1}$ 次。$g_{x,1}$ 表示的路径同理。

```cpp
#include<iostream>
#include<vector>
#define int long long
using namespace std;
int n,f[200010][2],g[200010][2],ans;
struct edge{int x;bool flag;};
vector<edge>v[200010];
void dfs(int x,int last)
{
    f[x][0]=f[x][1]=1;
    for(auto e:v[x])
        if(e.x!=last)
        {
            dfs(e.x,x);
            f[x][e.flag]+=f[e.x][e.flag];
            g[x][e.flag]+=g[e.x][e.flag]+f[e.x][e.flag];
        }
    ans+=g[x][0]*f[x][1]+f[x][0]*g[x][1];
}
signed main()
{
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int x,y;
        cin>>x>>y;
        v[x].push_back({y,1});
        v[y].push_back({x,0});
    }
    dfs(1,0);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：reductt (赞：1)

笑点解析：感觉这个题是最签到的题。

---

我们考虑求出以每一个点开头的简单路径长度和，然后加起来就是答案了。

首先这个有向树一定是一个有向无环图，因为树上一定没有环，所以就可以做拓扑。

设 $f_u$ 为以点 $u$ 开头的简单路径长度和，$g_u$ 为 $u$ 可以到达的点的数量（不包括 $u$ 自己本身）。

然后画个图就可以得到转移方程：

$$ g_u = \sum (g_v + 1) $$

$$ f_u = \sum (g_v + f_v + 1) $$

关于 $f_u$ 的转移里为什么是 $g_v + f_v + 1$ 的原因：$u$ 通过点 $v$ 的所有简单路径的长度都比 $v$ 的简单路径长度大 $1$，也就是 $f_v + 1 \times g_u$ ，再加上 $u \rightarrow v$ 这条路径，就是 $g_v + f_v + 1$，很好理解。

然后答案就是 $\sum_{i=1}^{n} f_i$。写个拓扑排序建个反图算一下就行了，时间复杂度 $O(n)$。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define FOR(i, a, b) for(int i = (a); i <= (b); ++ i)
#define pb push_back

const int N = 2e5 + 10;
int n, outd[N], g[N], f[N];
vector<int> G[N];
queue<int> que;

signed main() {
	scanf("%lld", &n);
	FOR(i, 1, n - 1) {
		int u, v;
		scanf("%lld%lld", &u, &v);
		G[v].pb(u), outd[u] ++;
	}
	
	FOR(i, 1, n) if(!outd[i]) que.push(i);
	while(que.size()) {
		int u = que.front(); que.pop();
		for(int v: G[u]) {
			g[v] += g[u] + 1;
			f[v] += f[u] + g[u] + 1;
			if(!(-- outd[v])) que.push(v);
		}
	}
	
	int ans = 0;
	FOR(i, 1, n) ans += f[i];
	printf("%lld\n", ans);
	
	return 0;
}
```

---

## 作者：yi_hr (赞：1)

## 题意
本题大意为在一个 dag，即有向无环图上求所有简单路径的长度和。  
## 思路
因为本题为 dag,所以自然的想到树形 DP。  
**具体实现：** 分别建立正图与反图，然后在反图上进行拓扑排序，这样的顺序可以类比 tarjan 算法，即在 DFS 搜索树上按照从叶子到根的顺序遍历，实现树形 DP 状态的转移。  
**设计状态：** 用 $f_i$ 表示到达 $i$ 这个点的简单路径的长度和，$a_i$ 表示到达 $i$ 这个点的节点数。  
**转移方程：**  
1. $f_u=\sum a_v+f_v$。  
2. $a_u=1+\sum a_v$。  
## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+9;
struct edge{
	int to,next;
}e[N],re[N];
int head[N],cnt;
int rhead[N],rcnt;
inline void add(int u,int v){
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
inline void radd(int u,int v){
	re[++rcnt].next=rhead[u];
	re[rcnt].to=v;
	rhead[u]=rcnt;
}
int n,m;
ll a[N],f[N];
int in[N],tp[N],ti;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	int u,v;
	for(int i=1;i<n;i++){
		cin>>u>>v;
		add(u,v);//建正图 
		
		radd(v,u);//建反图 
		in[u]++;
	}
	//================================================
	queue<int> q;//在反图上拓扑排序 
	for(int i=1;i<=n;i++)if(!in[i]) q.push(i);
	while(!q.empty()){
		u=q.front();q.pop();
		tp[++ti]=u;
		for(int i=rhead[u];i;i=re[i].next){
			v=re[i].to;
			if(--in[v]==0) q.push(v);
		}
	}
	//================================================
	for(int i=1;i<=n;i++){
		u=tp[i];
		a[u]=1;
		for(int j=head[u];j;j=e[j].next){//转移状态 
			v=e[j].to;
			f[u]+=a[v]+f[v];
			a[u]+=a[v];
		}
	}
	ll ans=0;
	for(int i=1;i<=n;i++){
		ans+=f[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Drifty (赞：1)

### Solution

我们先对于每个点依次把每个能到达的边都搜完。那么得到的森林中的每棵树中的边都是由父节点指向子节点的。又不难注意到由于两颗相接的树边界处边的方向一定不同，因此不会有贡献，那么我们分别计算就好了。

具体地，记录一个 $f_u$ 代表子树大小，不难发现答案就是对其做一遍前缀和，因为对于一个点，其两个子树之间不会有贡献。然后就可以了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 2e5 + 7;
using i64 = long long;
vector <int> e[N];
int n, vis[N];
i64 f[N], g[N];
int main() {
    cin.tie(NULL) -> sync_with_stdio(false);
    cin >> n;
    for (int i = 1, u, v; i < n; i ++) 
        cin >> u >> v, e[u].emplace_back(v);
    i64 ans = 0;
    function <void(int, int)> dfs = [&](int u, int fa) {
        vis[u] = true;
        for (auto v : e[u]) {
            if (v == fa) continue;
            if (!vis[v]) dfs (v, u);
            f[u] += f[v] + 1;
            g[u] += f[v] + g[v] + 1;
        }
    };
    for (int i = 1; i <= n; i ++) {
        if (!vis[i]) dfs(i, 0);
        ans += g[i];
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：juruo_zhanshen (赞：0)

大体思路：在进行拓扑排序时求解。

设 $c_i$ 表示能到第 $i$ 个结点的结点总数，很容以用 bfs 求。设 $ans_i$ 表示以 $i$ 为结尾的最短路径的长度。此时，结果就是 
$$\sum_{i=1}^{n}ans_i$$

先求 $c$ 的状态转移方程。注意到从 $u$ 扩展到 $v$ 时，所有能到达 $u$ 的点都能到达 $v$，再加上 $u$，于是 $c_v = c_u + 1$。但是实际上，$c_v$ 可能由多个点扩展得到，此时使用 `+=`。

接下来求 $ans$ 的状态转移方程。注意到当结点 $u$ 扩展到结点 $v$ 时，与结点 $u$ 相连的每个结点都可以到达结点 $v$，且每个点到 $v$ 的距离比简单路径长度都比到 $u$ 大一，再加上 $u$ 到 $v$ 的一条边，正好是 $ans_v = ans_u + c_u + 1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
#define size(x) (int(x.size()))
typedef long long ll;
const int N = 2e5 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1e9 + 7;

int n;
vector < int > graph[N];
int in[N];
ll c[N];
ll res[N]; /* 上文中的 ans */

int main ( int argc, char *argv[] )
{ 
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    //freopen(".in", "r", stdin);
    //freopen(".out", "w", stdout);
    cin >> n;
    for (int i = 1; i <= n - 1; i++){
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        in[v]++;
    }
    queue < int > q;
    for (int i = 1; i <= n; i++)
        if (in[i] == 0)
            q.push(i);
    while (!q.empty()){
        int now = q.front(); q.pop();
        for (int i = 0; i < size(graph[now]); i++){

            c[graph[now][i]] += c[now] + 1;
            res[graph[now][i]] += c[now] + res[now] + 1; //这两行是状态转移方程
            if (--in[graph[now][i]] == 0){
                q.push(graph[now][i]);
            }
        }
    }
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        ans += res[i];
    cout << ans << endl;
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}				/* ----------  end of function main  ---------- */
```

---

## 作者：andycode (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11468)
## 思路
容易想到 $f_i$ 存储以 $i$ 为起点的路径长度之和，但是发现由于不知道路径个数，无法进行转移。

于是设 $f_{i,0}$ 为以节点 $i$ 为起点的所有简单路径的长度之和，$f_{i,1}$ 为以节点 $i$ 为起点的简单路径的个数。

转移时，节点 $i$ 所指向的所有节点 $j$ 都会对 $f_{i,0}$ 作出 $f_{j,0}+f_{j,1}$ 的贡献，对 $f_{i,1}$ 作出 $f_{j,1}$ 的贡献。因为 $i$ 会通过连向 $j$ 的那条边，连接上以 $j$ 为起点的所有简单路径，从而使得节点 $j$ 对 $i$ 造成贡献。

需要注意的是，从节点 $i$ 到节点 $i$ 的长度为 $0$ 的路径也要算进 $f_{i,1}$，所以 $f_{i,1}$ 的初始值为 $1$。

换句话说，设节点 $i$ 指向的所有节点的编号的集合为 $G_i$，则
$$
f_{i,0}=\sum_{j\in G_i}f_{j,0}+f_{j,1}\\
f_{i,1}=1+\sum_{j\in G_i}f_{j,1}
$$

答案为 $\sum\limits_{i=1}^{n}f_{i,0}$。

直接 dfs 求解似乎能直接解决，但是注意到在 dfs 时，有些节点会被忽略，所以还需再遍历指向节点 $i$ 的节点。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n;
long long f[N][2],ans;
bool to[N];
vector<int> g[N][2];
//g[i][0]存i指向的节点,g[i][1]存指向i的节点
void dfs(int x){
	if(to[x])
		return;//如果被遍历过，直接返回
	to[x]=1;
	f[x][1]=1;//存储初值
	int len=g[x][0].size();//先求出f[x][0]和f[x][1]
	for(int i=0;i<len;i++){
		int v=g[x][0][i];
		dfs(v),f[x][0]+=f[v][0]+f[v][1],f[x][1]+=f[v][1];
	}
	ans+=f[x][0];
	len=g[x][1].size();//再对指向x的节点作贡献
	for(int i=0;i<len;i++)
		if(!to[g[x][1][i]]){
			int v=g[x][1][i];
			dfs(v);
		}
}
int main(){
	scanf("%d",&n);
	for(int i=1,u,v;i<n;i++){
		scanf("%d%d",&u,&v);
		g[u][0].push_back(v);
		g[v][1].push_back(u);
	}
	dfs(1);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：linjunye (赞：0)

### 思路

发现可以分开单独计算，那么我们就计算这条边出现的次数。

首先定义 $f_i$ 表示有多少个点可以到达 $u$，转移为 $f_v\leftarrow f_v+f_u$。

然后定义 $siz_i$ 表示从 $u$ 开始可以到达多少点，发现需要建反图，转移为 $f_v\leftarrow f_v+f_u$，其实是一样的转移。

最后怎么计算答案呢？若我们要计算从 $u$ 到 $v$ 这条边统计了多少次，那么根据乘法原理，为 $f_u\times siz_v$。

最后 $f$ 与 $siz$ 的转移用拓扑排序处理。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200010;
struct Edge{
	int v,next;
}e[N][2];
int tot[2],head[N][2];
void add(int u,int v,int op){//有点复杂，其实可以分开写add1,add2
	tot[op]++;
	e[tot[op]][op].v=v;
	e[tot[op]][op].next=head[u][op];
	head[u][op]=tot[op];
	return;
}
int n;
int ans;
int u,v;
int f[N];
int in[N];//正图的入度
int in2[N];//反图的入度
int siz[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>u>>v;
		add(u,v,0);//正图
		add(v,u,1);//反图
		in[v]++;
		in2[u]++;
	}
	queue<int>q;
	for(int i=1;i<=n;i++){
		siz[i]=1;
		if(!in2[i])q.push(i);
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u][1];i;i=e[i][1].next){//反图
			int v=e[i][1].v;
			siz[v]+=siz[u];
			in2[v]--;
			if(in2[v]==0)q.push(v);
		}
	}
	for(int i=1;i<=n;i++){
		f[i]=1;
		if(!in[i])
			q.push(i);
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u][0];i;i=e[i][0].next){//正图
			int v=e[i][0].v;
			f[v]+=f[u];
			ans+=f[u]*siz[v];
			in[v]--;
			if(!in[v])q.push(v);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：gyyyyx (赞：0)

对于一条简单路径 $a_1\to a_2\to\cdots\to a_l$，称 $a_l$ 为末节点。

对于一个节点 $u$，末节点为 $u$ 的简单路径分为：经过父亲节点的路径和不经过父亲节点的路径。

对于不经过父亲节点的路径，必然由儿子节点转移而来，可以用树形 DP 解决。

设 $g_u,s_u$ 分别表示 $u$ 子树内，以 $u$ 为末节点的简单路径条数和简单路径长度之和。

则有：

$$
g_u=\sum\limits_{v\in son_u}g_v+1\\
s_u=g_u+\sum\limits_{v\in son_u}s_v
$$

对于经过父亲节点的路径，可以根据父亲节点转移。

设 $v\in son_u$，$h_v,r_v$ 分别表示 $v$ 子树外，以 $v$ 为末节点的简单路径条数和简单路径长度之和。

则有：

$$
h_v=h_u+g_u+1\\
r_v=r_u+s_u+h_v
$$

两次 DFS 解决。所以这其实就是一个简单的换根 DP。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 200005
using namespace std;
int n;
struct Edge{
	int nxt,to;bool flg;
	Edge(int a=0,int b=0,bool c=0)
	:nxt(a),to(b),flg(c){}
} e[N<<1];
int head[N],cnt;
LL g[N],s[N],h[N],r[N],ans;
inline void AddEdge(int x,int y,bool z){
	e[++cnt]=Edge(head[x],y,z);head[x]=cnt;
}
void DFS(int u,int f){
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);
		if(v^f){
			DFS(v,u);
			if(e[i].flg) g[u]+=g[v]+1,s[u]+=s[v];
		}
	}
	s[u]+=g[u];
}
void DFS2(int u,int f){
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);
		if(v^f){
			if(!e[i].flg){
				h[v]=h[u]+g[u]+1;
				r[v]=r[u]+s[u]+h[v];
			}
			DFS2(v,u);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i(1);i<n;++i){
		int u,v;scanf("%d%d",&u,&v);
		AddEdge(u,v,0);AddEdge(v,u,1);
	}
	DFS(1,0);DFS2(1,0);
	for(int i(1);i<=n;++i) ans+=s[i]+r[i];
	printf("%lld\n",ans); 
	return 0;
}
```

---


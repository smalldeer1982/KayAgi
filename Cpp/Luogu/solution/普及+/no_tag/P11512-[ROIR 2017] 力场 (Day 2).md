# [ROIR 2017] 力场 (Day 2)

## 题目背景

翻译自 [ROIR 2017 D2T3](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day2.pdf)。

## 题目描述

在一个物理生物学实验室中，研究者们正在研究通过力场对植物的辐射影响。实验装置包含一个大小为 $10^9 \times 10^9$ 的方形平台，平台上有肥沃的土壤。平台上方放置了一个辐射源。在辐射源与平台之间，可以开启 $n$ 个力场。

力场发生器安装在点 $(0, 0)$ 之上。第 $i$ 个力场是一个矩形，矩形的两条边与平台的边界平行，且矩形的两个对角线顶点坐标分别为 $(0, 0)$ 和 $(x_i, y_i)$。

在实验中，研究者计划通过开启 $k$ 个力场，来研究辐射对植物的影响。研究者需要从给定的 $n$ 个力场中，选择出 $k$ 个力场进行实验。为了最大化实验效果，研究者希望选择的这 $k$ 个力场覆盖平台上的面积尽可能大。

要求编写一个程序，给定 $n,k$ 和 $n$ 个力场的描述，找出选择的 $k$ 个力场，使得它们覆盖的平台区域面积的交最大，并输出该面积。

## 说明/提示

### 样例解释

下面的图中，上方是输入的 $5$ 个力场，下方是使总面积最大的最佳的选择 $3$ 个力场的方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/hnxmjucp.png)

### 数据范围

| 子任务 | 分值 | $n$ | 其它特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $18$ | $1\le n\le20$ |  |
| $2$ | $25$ | $1\le n\le300$ |  |
| $3$ | $20$ | $1\le n\le3000$ |  |
| $4$ | $17$ | $2\le n\le200000$ | $k=2$ |
| $5$ | $20$ | $1\le n\le200000$ |  |

## 样例 #1

### 输入

```
5 3
3 5
2 2
2 5
4 4
5 3```

### 输出

```
9```

# 题解

## 作者：水星湖 (赞：4)

设第 $i$ 个选择的矩形编号为 $b_i$，易得相交部分面积为: 
$$\min_{1\le i \le k} x_{b_i}\times \min_{1\le i \le k} y_{b_i}$$
于是我们可以将每一对 $(x,y)$ 按照 $x$ 排序，用平衡树动态维护第 $k$ 大的 $y$ 即可。

---

## 作者：ny_Dacong (赞：2)

# 思路

首先，不要读错题意。题目要求求所有力场的**公共**面积。

因为所有力场的左下角都在原点，所以一个选择方案的最终的答案应该是 $\min x_i \times \min y_i$。

我们要最大化这个最小值。因为要满足两个条件，难以同时维护，所以想到先确定 $x$ 的长度，然后满足 $y$ 的长度。

先按 $x$ 长度从大到小排序，同时用小根堆维护 $y$ 的长度。然后按照排好的顺序讨论每个矩形，如果当前 $y_i$ 比堆顶大，那么用 $y_i$ 替换堆顶。因为 $x$ 从大到小排序，所以这个矩形的 $x$ 一定是最小的，堆顶又是最小的 $y$，所以当前答案就是该矩形的 $x$ 长度乘堆顶。

求所有答案的最大值即可。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ans = -114514;
struct node{
	long long xp,yp;
}num[200050];
bool operator<(node x,node y){
	return x.yp > y.yp;
}
priority_queue<node> que;
int main(){
	scanf("%lld%lld",&n,&m);
	for(long long i = 1; i <= n; i++){
		scanf("%lld%lld",&num[i].xp,&num[i].yp);
	}
	sort(num+1,num+1+n,[](node x,node y) -> bool{return x.xp > y.xp;});
	for(long long i = 1; i <= m; i++){
		que.push(num[i]);
	}
	ans = max(ans,num[m].xp*(que.top().yp));
	for(long long i = m+1; i <= n; i++){
		if(num[i].yp > que.top().yp){
			que.pop();
			que.push(num[i]);
		}
		ans = max(ans,num[i].xp*(que.top().yp));
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：rainbow_cat (赞：1)

由于是面积交，考虑枚举矩形的长并二分矩形的宽，设当前矩形长为 $x$，宽为 $y$，若 $\sum_{i=1}^{n}[x_i\ge x][y_i\ge y] \ge m$ 则此矩形合法。     
考虑将矩形按 $y$ 排序，对于第 $i$ 个矩形使用树状数组统计 $i$ 至 $n$ 中 $x$ 比 $x_i$ 小的矩形数 $cnt$，满足条件的矩形数为 $n-i+1-cnt$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans,idx,b[200010],bit[200010];
map<int,int>mp;
int lowbit(int x){return x&-x;}
void add(int x,int y){for(;x<=idx;x+=lowbit(x))bit[x]+=y;}
int query(int x)
{
	int res=0;
	for(;x;x-=lowbit(x))res+=bit[x];
	return res;
}
struct node{int x,y;}a[200010];
bool cmp(node x,node y){return x.y<y.y;}
bool check(int x,int y)
{
	int cnt=n-x+1-query(mp[b[y]]-1);
	return cnt>=m;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y,b[i]=a[i].x;
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)if(!mp[b[i]])mp[b[i]]=++idx;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)add(mp[a[i].x],1);
//	for(int i=1;i<=n;i++)cout<<"V:"<<a[i].x<<' '<<a[i].y<<'\n';
	for(int i=1;i<=n;i++)
	{
		int l=1,r=n;
		while(l<r)
		{
			int mid=(l+r+1)/2;
			if(check(i,mid))l=mid;
			else r=mid-1;
		}
//		cout<<a[i].y<<' '<<b[l]<<' '<<query(mp[b[l]]-1)<<'\n';
		if(check(i,l))ans=max(ans,a[i].y*b[l]);
		add(mp[a[i].x],-1);
	}
	cout<<ans;
	return 0;
}
/*
Happy birthday to lrz!!!
*/
```

---

## 作者：songzhixin (赞：1)

### 题意

从 $n$ 个矩阵中选出 $k$ 个，让它们的公共面积最大。

### 思路

我们可以考虑枚举这个公共矩形的 $x$ 轴上的长度，即按照输入的 $x$ 坐标从小到大排序，则后边的所有矩形都是可以选的，因为已经排好序，$x$ 轴的长度一定大于等于当前讨论的长度。

如何求 $y$ 轴的长度呢？我们肯定希望这个长度越大越好，所以我们要求一段区间的第 $k$ 大数，当然不是可持久化线段树，对于每一次，只会插入一个数，并不会删除数，所以五门这需要维护一个大小为 $k$ 的大根堆即可。每次 $y$ 轴的最大长度为堆顶元素。所有方案取最大值即可。

时间复杂度 $O(n \log n)$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=200005;
struct node{
	long long x,y;
};
node a[N];
bool cmp(node fx,node fy){
	if(fx.x==fy.x){
		return fx.y<fy.y;
	}
	return fx.x<fy.x;
}
priority_queue<long long,vector<long long>,greater<long long> >s;
int main(){
	long long n,m;
	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++){
		scanf("%lld%lld",&a[i].x,&a[i].y);
	}
	sort(a+1,a+1+n,cmp);
	long long ans=0;
	for(long long i=n;i>=1;i--){
		s.push(a[i].y);
		while(s.size()>m){
			s.pop();
		}
		if(s.size()<m){
			continue;
		}
		long long aa=s.top();
		ans=max(ans,a[i].x*aa);
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：yi_hr (赞：1)

## 思路
1. **排序**：  
将所有力场按照 $x_i$ 降序排序。这样可以首先考虑 $x_i$ 较大的力场，因为较大的 $x_i$ 可以增大交集区域的宽度。  
2. **维护 $y_i$ 的最小值**：  
在遍历排序后的力场时，使用一个优先队列来维护当前选中的 $k$ 个力场中的 $y_i$ 值。这样，我们可以获取当前选中力场中的最小 $y_i$，从而计算高度。  
3. **计算最大面积**：  
对于每个力场，加入其 $y_i$ 到优先队列中。如果堆的大小超过 $k$，则移除堆顶的最小 $y_i$，以保持堆中始终有 $k$ 个最大的 $y_i$。  
当堆的大小恰好为 $k$ 时，计算当前力场的 $x_i$ 与堆顶的最小 $y_i$ 的乘积，更新最大交集面积。  
## 代码实现
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+9;
int n,k;
pair<int,int> a[N];
priority_queue<int,vector<int>,greater<int>> pq;
inline bool cmp(pair<int,int> a,pair<int,int> b){
	if(a.first != b.first)return a.first>b.first;
    return a.second>b.second;
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>k;
    for(int i=0;i<n;i++){
    	cin>>a[i].first>>a[i].second;
	}
    sort(a,a+n,cmp);
    ll ans=0;
    int x,y;
    for(int i=0;i<n;i++){
    	x=a[i].first;
    	y=a[i].second;
        pq.push(y);
        if((int)pq.size()>k){
            pq.pop();
        }
        if((int)pq.size() == k){
            ll cnt=(ll)x*(ll)pq.top();
            if(cnt>ans){
                ans=cnt;
            }
        }
    }
    cout<<ans;
}
```

---

## 作者：lam_dyr (赞：1)

# P11512 \[ROIR 2017 Day 2] 力场

## 题意

给定 $n$ 个力场，我们要从中选择中选择 $k$ 个，使得它们覆盖区域的交集面积最大。由于每个力场都是从 $(0,0)$ 到 $(x_i, y_i)$ 的矩形，选择 $k$ 个力场后的交集区域将是一个从 $(0,0)$ 到 $(\min(x_i), \min(y_i))$ 的矩形。

我们的目标是最大化 $\min(x_i) \times \min(y_i)$。

## 思路

1. **排序力场**：
   - 将所有力场按 $x_i$ 从大到小排序。

2. **使用小根堆维护 $k$ 个最大的 $y_i$**：
   - 遍历排序后的力场，使用一个大小不超过 $k$ 的最小堆来维护当前选择的力场中的 $y_i$。
   - 当堆的大小超过 $k$ 时，移除最小的 $y_i$，确保堆中始终包含 $k$ 个最大的 $y_i$。

3. **计算最大面积**：
   - 在遍历过程中，当堆的大小达到 $k$ 时，当前的堆顶元素即为当前选择的 $k$ 个力场中的最小 $y_i$。
   - 计算当前力场的 $x_i$ 与堆顶 $y_i$ 的乘积，更新最大面积。

## Code

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
const int N=200005;
const int MOD=1000000007;
bool cmp(pair<ll, ll> a,pair<ll,ll> b) {
    if (a.fi!=b.fi) 
        return a.fi>b.fi;
    return a.se > b.se;
}
int n,k;
ll res;
pair<ll,ll> arr[N];
priority_queue<ll,vector<ll>,greater<ll>> pq;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>k;
    for(int i=0;i<n;i++) cin>>arr[i].fi>>arr[i].se;
    sort(arr,arr+n,cmp);
    for(int i=0;i<n;i++){
        ll y = arr[i].se;
        pq.push(y);
        if(pq.size() > k) pq.pop();
        if(pq.size() == k){
            ll miny = pq.top();
            ll area = arr[i].fi * miny;
            if(area > res) res = area;
        }
    }
    cout << res;
}
```

---

## 作者：_ayaka_ (赞：0)

本来看成取交了，斜优 DP 写一半发现不对，但没删多少代码。

### 思路

显然答案为取的 $k$ 个中的 $\min x_i \times \min y_i$。

考虑枚举 $x_i$，并找出所有 $x_j \ge x_i$ 的 $x_j$，在这里面再找 $y_j$ 最小的。

可以发现如果将 $x$ 从大到小排序，那么只要在 $i$ 前面的都满足 $x_j \ge x_i$。然后用一个优先队列 $q$ 来存 $y$，每次加入 $y_i$ 后如果 $size_q > k$ 就将 $y$ 最小的 `pop` 出去，相等就统计答案即可。时间复杂度 $O(n\log n)$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, k, x;
priority_queue<int, vector<int>, greater<int>> q;
map<int, int> a;
signed main() {
	cin >> t;
	while (t--) {
		a.clear();
		cin >> n >> k;
		for (int i = 1; i <= n; i++) {
			cin >> x;
			a[x]++;
		}
		for (auto i : a) q.push(i.second);
		while (!q.empty()) {
			if (k >= q.top()) {
				k -= q.top();
				q.pop();
			} else break;
		}
		cout << max((int)q.size(), 1) << "\n";
		while (!q.empty()) q.pop();
	}
	return 0;
```

---

## 作者：_xdd_ (赞：0)

### 简要题意

给你 $n$ 个矩形，需要你取出 $k$ 个矩形，把它们左下角对齐，求出公共面积。

### 题目解法

首先公共面积取决于选出的图形里面最小的 $x$ 乘最小的 $y$，形式化的，设 $x_i,y_i$ 为选出的矩形的 $x$ 和 $y$，$S_\texttt{公共}=\min{x_i} \cdot \min{y_i}$。

所以选出的图形的面积要尽量大，我们把所有图形按照 $x$ 降序排序，也就是大的在前小的在后，然后小根堆维护 $y$，如果堆的大小 $=k$，更新答案为当前的 $x$ 乘上堆顶。


```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define maxn 200000+5
#define x first
#define y second
#define int long long
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
int n,k;
pair<int,int>a[maxn];
priority_queue<int,vector<int>,greater<int>>pq;
bool cmp(pair<int,int>t1,pair<int,int>t2){
    if(t1.x!=t2.x)return t1.x>t2.x;
    return t1.y>t2.y;
}
signed main(){
    cin >> n >> k;
    for(int i=1;i<=n;i++){
        cin >> a[i].x >> a[i].y;
    }
    sort(a+1,a+n+1,cmp);
    int ans=-1;
    for(int i=1;i<=n;i++){
        int t1=a[i].x,t2=a[i].y;
        pq.push(t2);
        if(pq.size()>k){
            pq.pop();
            ans=max(t1*pq.top(),ans);
        }else if(pq.size()==k){
            ans=max(t1*pq.top(),ans);
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：xuyifei0302 (赞：0)

对于这道题，我们可以发现，所有力场的左下角全在坐标系的原点上，且力场的长、宽各有一条在坐标轴上。我们要求的是选 $k$ 个力场，使得它们的交集最大。因为要交集最大，所以我们所选的力场的长、宽都尽量的大。这些力场的交集的面积就是我们所选的力场中最小的长乘上所选的力场中最小的宽。所以我们就可以先对力场的长进行排序，让其 $x$ 坐标尽量大。然后用一个小根堆维护目前的力场的 $y$ 坐标，每次将最小的 $y$ 坐标弹出即可。

下面是代码环节：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Node {
	int x, y;
} a[200005];
int n, k, ans;
bool cmp(Node x, Node y) {
	if (x.y == y.y) {
		return x.x > y.x;
	}
	return x.y > y.y;
}
priority_queue<int> pq;
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i].x >> a[i].y;
	}
	sort(a + 1, a + 1 + n, cmp);
	for (int i = 1; i <= n; i ++) {
		pq.push(-a[i].x);
		if (pq.size() > k) {
			pq.pop();
		}
		if (pq.size() == k) {
			ans = max(ans, pq.top() * a[i].y * -1);
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：algo_h (赞：0)

以下两种思路不可行：

* 二分答案验证：需要判断给定的面积下限（二分中点）是否可以实现。由于无法确定每一个满足面积要求的矩形是否选取，不存在 $O(n)$ 的方案。总复杂度不能做到 $O(n\log n)$。
* 三分法寻找最大值：假设当一个矩形的 $x$ 长度满足 $x \geq x_\mathrm m$ 时，我们将其选入候选集中。如果候选集的元素数目大于等于 $k$，则选中第 $k$ 大的 $y_k$ 坐标，计算 $x_\mathrm my_k$，得到约束 $x \geq x_\mathrm m$ 下的最大公共面积 $S(x_\mathrm m)$；否则定义 $S(x_\mathrm m) = 0$。函数 $S(x_\mathrm m)$ 是上凸函数，对其进行优化可以得到全局最优解。但其变化率可能在多处为 0，这导致三分法十分不便。

以上第二种不可行思路与本题的一种常规解法已经十分接近。可以在对矩形右上角坐标点 $(x, y)$ 按照字典序从小到大排序后，利用数据流的第 $k$ 大算法，从最后一个矩形（$x$ 最大的矩形）开始，遍历至第一个矩形（$x$ 最小的矩形），当遍历到的矩形数目积累至 $k$ 时或超过 $k $ 后，总可以选取公共矩形的横坐标为 $x$，并以 $O(\log n)$ 的代价得到当前第 $k$ 大的 $y$，统计 $xy$ 的最大值即可得到答案。

以上过程存在选取的 $x$ 不是最大公共矩形 $x$ 的下确界的情况，但考虑相同的 $y$ 第一次被取到的时候，那时候 $x$ 必定是下确界，可以得到更大的 $xy$。故不是下确界的 $x$ 对最终答案没有贡献，可以忽略。

```c++
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int main()
{
  cin.tie(0)->sync_with_stdio(0);
  int n, k;
  cin >> n >> k;
  vector<pair<int, int>> p(n);  // 每个矩形右上角的点
  for(auto &xy : p) cin >> xy.first >> xy.second;
  sort(p.begin(), p.end());  // 按照先 x 后 y 的优先级排序

  long ans = 0;                                       // 最大公共面积
  priority_queue<int, vector<int>, greater<int>> pq;  // 大小不超过 k 的小顶堆
  for(int i = p.size() - 1; i >= 0; --i) {            // 计算/维护当前 x 下限要求的 y 的第 k 大值
    auto [x, y] = p[i];                               // 横坐标下降至 x，纵坐标新增 y
    if((int)pq.size() == k) {                         // 堆满
      if(pq.top() < y) pq.pop(), pq.push(y);          // 选择性置换
    } else {                                          // 堆不满
      pq.push(y);                                     // 插入 y
    }
    if((int)pq.size() == k) {              // 堆顶成为了序列流第 k 大
      ans = max(ans, (long)x * pq.top());  // 计算面积
    }
  }
  cout << ans << endl;
  return 0;
}
```

---


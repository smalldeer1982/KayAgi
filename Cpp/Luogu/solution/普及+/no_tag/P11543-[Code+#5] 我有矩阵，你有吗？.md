# [Code+#5] 我有矩阵，你有吗？

## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。

## 题目描述

企鹅豆豆手里有两个 $01$ 矩阵 $\mathbf{A}$ 和 $\mathbf{B}$。他可以进行两种操作：

1. 选择 $\mathbf{A}$ 矩阵的一行，然后把这一行的 $0$ 变成 $1$，把 $1$ 变成 $0$。
2. 选择 $\mathbf{A}$ 矩阵的一列，然后把这一列的 $0$ 变成 $1$，把 $1$ 变成 $0$。

现在他想知道能不能把 $\mathbf{A}$ 矩阵通过以上操作变成 $\mathbf{B}$ 矩阵。保证 $\mathbf{A}$ 矩阵和 $\mathbf{B}$ 矩阵的大小一致。


## 说明/提示

**数据范围：**

对于所有数据，$n \le 1000,m \le 1000$。

**样例解释：**

对于样例一，依次对于第一行和第一列分别执行操作 $1$ 和操作 $2$ 即可。


## 样例 #1

### 输入

```
3 3
1 0 1
1 1 0
0 1 0
1 1 0
0 1 0
1 1 0
```

### 输出

```
Koyi```

## 样例 #2

### 输入

```
6 6
0 0 1 0 0 1
1 0 1 1 0 1
1 0 1 0 0 0
0 1 1 0 1 0
1 0 1 0 0 1
1 1 1 0 1 0
1 1 0 1 0 0
0 1 0 0 0 0
0 1 0 1 0 1
1 0 0 1 1 1
1 0 1 0 1 1
0 0 0 1 1 1
```

### 输出

```
Koyi```

# 题解

## 作者：lam_dyr (赞：4)

刚看到本题，二分图？？我不会啊。但仔细读了一遍题，这不是水题吗。

## 题意

给定两个 $01$ 矩阵 $A$ 和 $B$，判断是否可以通过以下两种操作将 $A$ 转换为 $B$：

- 行翻转：选择 $A$ 的一行，将 $0$ 变为 $1$，$1$ 变为 $0$。
- 列翻转：选择 $A$ 的一列，将 $0$ 变为 $1$，$1$ 变为 $0$。

## 思路

由于异或运算的特性：

- 相同的值异或结果为 $0$。
- 不同的值异或结果为 $1$。

考虑将矩阵 $B$ 的元素与矩阵 $A$ 的对应元素进行异或运算 `A[i][j] ^= B[i][j]`，操作后问题转化为判断是否可以通过行列翻转将矩阵 $A$ 的所有元素变为 $0$。

如果 `A[i][j]` 异或后为 $0$，则表示原 $A$ 和 $B$ 对应位置相同，否则表示不同。

进一步简化，假设第一行不进行翻转操作，那么，其他行和列的翻转操作就确定了。

如果第一行需要翻转，那么其他行和列的翻转操作也会相应改变。

因此，我们只需要考虑第一行是否翻转两种情况，而不需要枚举所有行的翻转情况。

注意到以下性质：

- 如果可以通过行列翻转将 $A$ 转换为 $B$，那么对于矩阵 $A$ 中任意一行，它要么与第一行完全相同，要么与第一行完全相反。
- 换句话说，每一行要么和第一行所有元素都相同，要么所有元素都相反（$0$ 变 $1$，$1$ 变 $0$）。

经过上述分析，我们不需要真正去模拟，就能得到最终的判定结果。

## Code

```cpp
#include <iostream>
using namespace std;
int a[1005][1005];
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    int n, m; // n: 行数, m: 列数
    cin >> n >> m;
    // a: 存储矩阵 A
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) 
            cin >> a[i][j];
    }
    // 读取矩阵 B，并与矩阵 A 进行异或操作
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            int b; // b: 临时变量，存储矩阵 B 的元素
            cin >> b;
            a[i][j] ^= b;
        }
    }
    // 检查每一行是否与第一行满足条件
    for (int i = 1; i < n; ++i) {
        int k = 0; // k: 记录当前行与第一行相同元素的个数
        for (int j = 0; j < m; ++j) {
            if (a[i][j] == a[0][j]) 
                k++;
        }
        // 如果当前行既不与第一行完全相同，也不与第一行完全相反，则输出 "Budexing"
        if (k != 0 && k != m) {
            cout << "Budexing";
            return 0;
        }
    }
    // 如果所有行都满足条件，则输出 "Koyi"
    cout << "Koyi";
    return 0;
}
```

---

## 作者：yi_hr (赞：4)

## 思路
要判断是否可以通过行翻转和列翻转将矩阵 $\mathbf{A}$ 转换为矩阵 $\mathbf{B}$，我们可用异或（XOR）实现。即：

1. 首先计算矩阵 $\mathbf{A}$ 和 $\mathbf{B}$ 的差异矩阵 $\mathbf{D}$，其中 $\mathbf{D}[i][j]=\mathbf{A}[i][j]\oplus\mathbf{B}[i][j]$。

2. 假设第一行不进行翻转（即 $r[0]=0$），然后根据差异矩阵确定每一列是否需要翻转。

3. 对于每一行，计算翻转状态 $r[i]$，并检查所有列的翻转状态是否一致。如果不一致，则尝试另一种初始假设（即 $r[0]=1$）。
## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int n,m;
    cin>>n>>m;
    vector<vector<int>> A(n,vector<int>(m)),B(n, vector<int>(m));
    for(auto &row:A){
        for(auto &x:row){
            cin>>x;
        }
    }
    for(auto &row:B){
        for(auto &x:row){
            cin >> x;
        }
    }
    vector<vector<int>> D(n, vector<int>(m, 0));
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            D[i][j] = A[i][j] ^ B[i][j];
        }
    }
    for(int r0=0;r0<=1;r0++){
        vector<int> c(m, 0);
        for(int j=0;j<m;j++){
            c[j]=D[0][j]^r0;
        }
        bool ok=1;
        vector<int> r(n, 0);
        r[0]=r0;
        for(int i=1;i<n;i++){
            r[i] = D[i][0]^c[0];
            for(int j=1;j<m;j++) {
                if((D[i][j]^c[j]) != r[i] ){
                    ok=0;
                    break;
                }
            }
            if(!ok) break;
        }
        if(ok){
            cout<<"Koyi";
            return 0;
        }
    }
    cout<<"Budexing";
}
```

---

## 作者：weifengzhaomi (赞：3)

## 题意 & 化简

现在有两个矩阵，分别为 $A$ 和 $B$。

**每个矩阵中的值均为 $1$ 和 $0$。**

能不能把 $A$ 的某一行或某一列中的每个数字设为一直相反的数字（也就是 $1$ 为 $0$，$0$ 设为 $1$），使得两个矩阵相等。

## 思路

注意上文加粗部分，可以分析得知，想要两个矩阵相等，无非就是把能改的尽量改。

那么，自然地，就会有一种想法，我们比较两个数组，如果相同则设为 $1$，否则设为 $0$。

考虑**异或**，把两个数组异或起来，存入另一个数组，然后判断。

具体判断，可以以第一行为标准，然后每行判断与第一行相同的有多少个。

**假设两个矩阵可以变为相等**，那么接下来的每一行都应该与第一行相反或一样。于是，得出结论：

**对于第 $i$ 行，用一个 $ans$ 来记录与的一行相反的数字的个数，如果不为 $0$ 也不为 $n$ 的话，就是不可以。**

有了上面的思路，就可以写代码啦。

## 代码：
```cpp
#include <iostream>
using namespace std;
int a[1005][1005],b[1005][1005],n,m,ans;
int main() {
	scanf("%d%d",&n,&m);
	for (int i = 1;i <= n;i++)
		for (int j = 1;j <= m;j++)
			scanf("%d",&a[i][j]);
	for (int i = 1;i <= n;i++) 
		for (int j = 1;j <= m;j++) {
			scanf("%d",&b[i][j]);
			a[i][j] ^= b[i][j];
		}
	for (int i = 2;i <= n;i++) {
		ans = 0;
		for (int j = 1;j <= m;j++) {
			if (a[i][j] == a[1][j]) 
				ans++;
		}
		if (ans != 0 && ans != m) {
			printf("Budexing\n");
			return 0;
		}
	}
	printf("Koyi\n");
}
```

---

## 作者：Judging_zhu (赞：2)

### 题意简化：
将 A 矩阵**任意**行或列取反，问是否能够得到 B 矩阵。
### 解题思路：
仔细一想，我们可不可以把 A 与 B 矩阵**是否重合**构成一个 C 矩阵呢？当然可以！如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/zuvri4h6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

多枚举即可发现一个规律：Koyi 的 C 矩阵，每一行与最后一行要么**相同**要么**取反**，稍加思考即可推出此结论。
### AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1005][1005],b[1005][1005],c[1005][1005];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>b[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			c[i][j]=(a[i][j]==b[i][j]);
	for(int i=2;i<=n;i++){
		int x=0;
		for(int j=1;j<=m;j++)
			x+=(a[i][j]==a[n][j]);
		if(x>0&&x<m){cout<<"Budexing\n";return 0;}
	}
	cout<<"Koyi";
 	return 0;
}
```

---

## 作者：水星湖 (赞：2)

并查集。

显然一行或一列至多操作一次。若 $A_{i,j}=B_{i,j}$，则只能同时操作第 $i$ 行，第 $j$ 列或同时不操作；否则，只能必须操作第 $i$ 行，第 $j$ 列之一。

用并查集维护，若 $A_{i,j}=B_{i,j}$，则合并 $i$ 和 $n + j$，$n + m + i$ 和 $n + m + n + j$；否则合并 $i$ 和 $n + m + n + j$，$n + j$ 和 $n + m + i$。最后判断是否有冲突（即 $fa_i=fa_{n+m+i}$）即可

---

## 作者：qianyuzhe (赞：2)

## 题意简述

给定两个同型 $01$ 矩阵 $A$ 和 $B$，每次操作可将 $A$ 的一行或一列取反，问能否通过有限次操作使 $A$ 变为 $B$。

## 题目分析

注意到，**最终的结果只和每行的操作次数与每列操作次数的奇偶性有关**，因此我们令每行和每列只进行 $0$ 次或 $1$ 次操作。

考虑 $A_{i,j}$ 和 $B_{i,j}$ 两个数，有以下两种可能：
1. 若 $A_{i,j}=B_{i,j}$，则或者第 $i$ 行和第 $j$ 列都进行操作，或者第 $i$ 行和第 $j$ 列都不进行操作。
2. 若 $A_{i,j}\not=B_{i,j}$，则或者第 $i$ 行进行操作，第 $j$ 列不进行操作，或者第 $i$ 行不进行操作，第 $j$ 列进行操作。

考虑将每行的操作情况和每列的操作情况作为结点，即建立  
$1,2\dots n,\\n+1,n+2,\dots,2n,\\2n+1,2n+2,\dots,2n+m,\\2n+m+1,2n+m+2,\dots,2n+2m$，  
共 $2n+2m$ 个结点，分别表示  
操作第 $1$ 行，操作第 $2$ 行，……，操作第 $n$ 行，  
不操作第 $1$ 行，不操作第 $2$ 行，……，不操作第 $n$ 行，  
操作第 $1$ 列，操作第 $2$ 列，……，操作第 $n$ 列，  
不操作第 $1$ 列，不操作第 $2$ 列，……，不操作第 $n$ 列  
的情况，再对于 $A_{i,j}$ 和 $B_{i,j}$ 相等和不等的情况分别建边，于是每条边都表示了一个必须满足的条件，由于此时仅有行列间的边，因此该图为二分图，**图上无奇环**。

再考虑无解的情况，显然**同一行或同一列不能既既进行操作又不进行操作**，若违反这一条件则必然无解。怎样判定这种情况呢？注意到**连接同一行或同一列操作和不操作的链若存在，则其长度必为偶数**，于是将所有 $i$ 和 $n+i$ 连边，$j$ 和 $2n+m+j$ 连边，其中 $1\le i\le n,2n+1\le j\le 2n+m$，这样，**只要图上出现了奇环，就说明导出了矛盾**。

用染色法找奇环即可，时间复杂度 $O(nm)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b,r,s,i,j,c[4005],a[1005][1005];
bool w[4005][4005];
void dfs(int x,int y){
	for(int i=1;i<=2*n+2*m;i++){
		if(!w[x][i])continue;
		if(c[i]){
			if(c[x]!=c[i])continue;
			cout<<"Budexing";//颜色不同，说明找到奇环，判定无解 
			exit(0);
		}
		c[i]=3-c[x];
		dfs(i,x);
	}
}
int main(){
	cin.tie(0)->ios::sync_with_stdio(false);
	cin>>n>>m;
	for(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];
	for(i=1;i<=n;i++)w[i][n+i]=w[n+i][i]=1;
	for(i=1;i<=m;i++)w[2*n+i][2*n+m+i]=w[2*n+m+i][2*n+i]=1;//矛盾情况连边 
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			cin>>b;
			if(b==a[i][j])w[i][2*n+j]=w[2*n+j][i]=w[n+i][2*n+m+j]=w[2*n+m+j][n+i]=1;//第一种情况 
			else w[i][2*n+m+j]=w[2*n+m+j][i]=w[n+i][2*n+j]=w[2*n+j][n+i]=1;//第二种情况 
		}
	}
	for(i=1;i<=2*n+2*m;i++){
		if(!c[i]){
			c[i]=1;
			dfs(i,0);
		}
	}
	cout<<"Koyi";//未找到奇环，判定有解 
}
```

---

## 作者：ZHR100102 (赞：1)

扩展域并查集小清新题。

# 思路

~~看到这题，我第一个想到的竟然是高斯消元。~~

首先一行和一列肯定不会操作两次以上，不然一定可以等效为操作 $0$ 次和操作 $1$ 次的情况。

于是我们将每行每列看做一个值为 $0$ 或 $1$ 的变量进行考虑。

再考虑异或的性质，显然，当 $a_{i,j}\ne b_{i,j}$ 时，第 $i$ 行和第 $j$ 列的**变量取值一定不同**。原因是如果相同的话，那么要么就是都没操作，要么就是操作了两次，等效为没操作，自然也就无法修改。否则一定是修改了一次的情况。

同理，当 $a_{i,j}=b_{i,j}$ 时，第 $i$ 行和第 $j$ 列的**变量取值一定相同**。

因此，这就被转化为一个很显然的扩展域并查集了。不同值的变量分到不同扩展域，相同值的变量分到相同扩展域，判断是否矛盾即可。

时间复杂度 $O(nm)$。

# 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
int n,m,f[4005],a[1005][1005],b[1005][1005];
void init()
{
    for(int i=1;i<=2*(n+m);i++)f[i]=i;
}
int findf(int x)
{
    if(f[x]!=x)f[x]=findf(f[x]);
    return f[x];
}
void combine(int x,int y)
{
    int fx=findf(x),fy=findf(y);
    f[fx]=fy;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    init();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>b[i][j];
            if(a[i][j]!=b[i][j])
            {
                if(findf(i)==findf(j+n))
                {
                    cout<<"Budexing";
                    return 0;
                }
                combine(i,n+m+n+j);
                combine(n+m+i,n+j);
            }
            else
            {
                if(findf(i)==findf(n+m+n+j))
                {
                    cout<<"Budexing";
                    return 0;                    
                }
                combine(i,n+j);
                combine(i+n+m,n+m+n+j);
            }
        }
    }        
    cout<<"Koyi";
    return 0;
}
```

---

## 作者：longlong666 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11543)

## 题意

有 $A$ 和 $B$ 两个矩阵，问 $A$ 矩阵通过以下两个操作能否变为 $B$ 矩阵。

- 操作一：将一行取反。
- 操作二：将一列取反。

## 思路

首先，将 $A$ 矩阵与 $B$ 矩阵进行异或操作，根据异或的特性（相同为 $0$，不同为 $1$），所以此时 $A$ 矩阵中 $1$ 就代表 $A$ 与 $B$ 矩阵中不同的位置。

于是，问题转变为将 $A$ 矩阵中的数是否能通过两操作全部变为 $0$。

观察，如果每一行与第一行完全相同或相反就可以全部转换为 $0$，理由如下：

若与第一行相反，则可通过操作一变为与第一行相同，于是每一行都可与第一行相同。 \
然后通过操作二可将每一列值为 $1$ 的更改为 $0$，于是 $A$ 矩阵可变为 $0$，即与 $B$ 矩阵相同。

若有一行与第一行不相同，则将其他行变为 $0$ 后，该行依旧存在值为 $1$ 的位置，不可化为 $0$，即 $A$ 矩阵不可转化为 $B$ 矩阵。

综上，不需要依题意模拟，只需要看该行是否与第一行相同或相反即可。

判断是否与第一行相同，只需判断该行与第一行相同个数是否为 $0$，即可。

判断是否与第一行相反，只需判断该行与第一行相同个数是否为 $m$，即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1000+10;
int n,m,x;
bool a[maxn][maxn];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];//输入
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>x; a[i][j]^=x;//异或 A 矩阵
		}
	}
	for(int i=2;i<=n;i++){x=0;
		for(int j=1;j<=m;j++) x+=(a[i][j]==a[1][j]);//相同个数
		if(x==0||x==m) continue;//判断是否相同或相反
		else{
			cout<<"Budexing"<<endl; return 0;//不能转换
		}
	}cout<<"Koyi"<<endl;//能转换
	return 0;
}
```

$\color{white}{\text{求管理员通过，qwq。}}$

---

## 作者：lzx111218 (赞：1)

# P11543 [Code+#5] 二分图判定
[题目传送门](https://www.luogu.com.cn/problem/P11543)
## 思路
其实这题要求的操作非常简单，且矩阵的大小最大为 $1000 \times 1000$，直接模拟操作会 TLE。所以这题的核心思路是通过构建差异矩阵来判断矩阵 $A$ 是否能通过行列反转转换为矩阵 $B$。首先，计算矩阵 $A$ 和矩阵 $B$ 之间的差异矩阵 $C$，其中 $C[i][j] = A[i][j] \oplus B[i][j]$。矩阵 $C$ 中的值 $1$ 表示两矩阵在该位置不同，$0$ 表示相同。然后，检查矩阵 $C$ 的每一行是否能通过列反转与第一行的差异模式一致。如果所有行的差异可以通过列反转对齐，则说明 $A$ 可以通过行列反转变换为 $B$，否则不能。

~~用模拟 TLE 四次总结出来的结论。~~

**时间复杂度为** $O(nm)$。

**空间复杂度为** $O(nm)$。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    int** a = new int*[n + 1];
    for (int i = 1; i <= n; ++i) {
        a[i] = new int[m + 1];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j]);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            int v;
            scanf("%d", &v);
            a[i][j] ^= v; 
        }
    }
    for (int i = 1; i <= n; i++) {
        int k = 0;
        for (int j = 1; j <= m; j++) {
            k += a[i][j] == a[1][j]; 
        }
        if (k && k ^ m) {
            puts("Budexing"); 
            for (int i = 1; i <= n; ++i) {
                delete[] a[i];
            }
            delete[] a;
            return 0;
        }
    }
    puts("Koyi");
    for (int i = 1; i <= n; ++i) {
        delete[] a[i];
    }
    delete[] a;
    return 0;
}

```

---

## 作者：light_searcher (赞：1)

题目把做法告诉你了。

容易发现一行或一列至多被取反一次，因为取反两次后等于没有取反。那么我们可以根据此把行和列分为两类，一类是要取反的，一类是不取反的。

定义一行或一列的状态为是否取反。如果 $A_{i,j}=B_{i,j}$ 则说明第 $i$ 行和第 $j$ 列的状态一定相同，否则说明状态不同，那么就可以得到 $n \times m$ 个限制条件。判断是否有解就是判断这些限制条件是否会矛盾。容易想到把每一行或每一列都当成一个点，然后根据这些条件建边，最后判断每个联通块是否是二分图即可。

具体地，让第 $i$ 行所代表的点的编号为 $i$，第 $j$ 列所代表的点的编号为 $n+j$，对第 $i$ 行再开一个编号为 $n+m+i$ 的虚点。如果 $A_{i,j}=B_{i,j}$，建一条 $i$ 到 $n+j$ 的无向边。否则建一条 $n+m+i$ 到 $n+j$ 的无向边。对于每一个 $i$，还要建一条到 $n+m+i$ 的边。最后 dfs 染色判断是否是二分图即可。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int n,m,a[N][N],b[N][N],col[3*N];
vector<int>edge[3*N];
void dfs(int u,int fa){
	for(int v:edge[u])
		if(v!=fa){
			if(col[v]){
				if(col[v]==col[u]){
					puts("Budexing");
					exit(0);
				}
				continue;
			}
			col[v]=3-col[u];
			dfs(v,u);
		}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&b[i][j]);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			if(a[i][j]!=b[i][j]){
				edge[i].push_back(n+j);
				edge[n+j].push_back(i);
			}
			else{
				edge[n+m+i].push_back(n+j);
				edge[n+j].push_back(n+m+i);
			}
		edge[i].push_back(n+m+i);
		edge[n+m+i].push_back(i);
	}
	for(int i=1;i<=n+m;i++)
		if(!col[i]){
			col[i]=1;
			dfs(1,0);
		}
	puts("Koyi");
	return 0;
}

---

## 作者：mystic_qwq (赞：1)

题目大意：给两个 $01$ 矩阵，问能不能通过行/列取非的操作把 $\mathrm A$ 变成 $\mathrm B$。

可以发现，对于每个元素，我们仅仅关系他和 $\mathrm B$ 矩阵里面的是否相同。而不用关注具体的值。不妨将相同置为 $0$，不同置为 $1$。此时，目标就是用行/列取反来将矩阵清零。

每一行元素都必须和最上面一行的对应元素全部相同/不同。

因为假设有 ${\mathrm A}_{i,j}\ne {\mathrm A}_{1,j}$，则不能直接用列变换，不妨对 $\mathrm{A}_{i,j}$ 进行行变换，则此时该行其他至少 $1$ 个元素和第一行的也不一样。这时候发现该元素不可能和第一行的一样了。而把所有元素都和第一行一样，之后用列取反即可。



代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1005
int n,m;
int a[N][N];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
     
    for(int i=1;i<=n;i++)
        for(int j=1,v;j<=m;j++){
            cin>>v;
            a[i][j] ^= v;
        }
    for(int i=1;i<=n;i++){
        int k=0;
        for(int j=1;j<=m;j++)
            k+=a[i][j]==a[1][j];
        if(k&&k^m) 
            return puts("Budexing"),0;
    }
    puts("Koyi");
}
```

---


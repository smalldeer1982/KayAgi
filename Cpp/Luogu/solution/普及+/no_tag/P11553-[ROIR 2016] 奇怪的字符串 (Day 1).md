# [ROIR 2016] 奇怪的字符串 (Day 1)

## 题目背景

翻译自 [ROIR 2016 D1T3](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day1.pdf)。

注意：本题官方数据行末存在 `\r`。

## 题目描述

考虑一个由小写字母组成的字符串 $ s $，如 $\texttt{abba}$。
- 记 $ W(s) $ 为一个集合，包含了字符串 $ s $ 所有的非空子串。例如，$ W(\texttt{abba}) = \{\texttt{a}, \texttt{b}, \texttt{ab}, \texttt{ba}, \texttt{bb}, \texttt{abb}, \texttt{bba}, \texttt{abba}\} $。
- 记 $ Y(s) $ 为一个集合，包含了字符串 $ s $ 所有的非空子序列。由于任何子串都是子序列，因此 $ Y(s) $ 集合包含了 $ W(s) $，但它还可以包含其他的字符串。例如，$ Y(\texttt{abba}) = W(\texttt{abba}) \cup \{\texttt{aa}, \texttt{aba}\} $。

如果一个字符串 $ s $ 满足 $ W(s) = Y(s) $，那么我们称它是**奇怪的**。例如，字符串 $\texttt{abba}$ 不是奇怪的，而字符串 $\texttt{abb}$ 是奇怪的，因为对于 $\texttt{abb}$，有 $ W(\texttt{abb}) = Y(\texttt{abb}) = \{\texttt{a}, \texttt{b}, \texttt{ab}, \texttt{bb}, \texttt{abb}\} $。

我们称字符串 $s$ 的**奇异度**为它所有不同的奇怪子串的数量，即，$W(s)$ 中奇怪的字符串的数量。例如，字符串 $\texttt{abba}$ 的奇异度为 $7$，因为它的所有除它本身以外的子串都是奇怪的。

给定一个字符串 $s$，你要求出它的奇异度。

## 说明/提示

| 子任务 | 是否捆绑 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $29$ | $\vert s\vert\le50$ 且 $s$ 只含 $\tt a$ 和 $\tt b$ |
| $2$ | 是 | $12$ | $\vert s\vert\le50$ |
| $3$ | 是 | $25$ | $\vert s\vert\le1000$ |
| $4$ | 是 | $34$ | $\vert s\vert\le200000$ |

## 样例 #1

### 输入

```
abba```

### 输出

```
7```

# 题解

## 作者：poembelief (赞：2)

# 题目传送门
[[ROIR 2016 Day 1] 奇怪的字符串](https://www.luogu.com.cn/problem/P11553)

# 题目分析
我们先不考虑子串的问题，先考虑如何判断一个子串是否是奇怪的。

随便找几个字符串看一下，或者就看样例给的 `abba`，会发现 `abba` 最直观的不合法例子在于 `aa` 是子序列但不是子串。观察 `aa` 是如何取出来的，可以大胆推测一下：**一个子串是奇怪的，当且仅当该字符串由一种字符构成或者两种不同字符是相邻排放的。**

形式化的说法就是令 `A`、`B` 为多个相同字符拼接成字符串，一个字符串是奇怪的当且仅当该字符串格式为 
 `A`、`B`、`AB`，而 `ABA` 或者 `ABC` 之类的字符串是不奇怪的。

我们来稍稍证明一下：

对于字符串 `ABA`，一定可以取出不合法例子 `AA`，只要含这种结构的字符串一定不奇怪。

对于字符串 `ABC`，一定可以取出不合法例子 `AC`，只要含这种结构的字符串一定不奇怪。

对于字符串 `A`，取不出不合法例子是显然的。

对于字符串 `AB`，令 `A` 的大小为 $n$，`B` 的大小为 $m$，则对于 $x \leq n,y \leq m$，子序列一定是 $x$ 个 `a` 或 $y$ 个 `b`，或 $x$ 个 `a` 和 $y$ 个 `b` 拼接起来的字符串，而这是一定可以取出来的，故而一定是奇怪的。

至此，这题就变得很简单了：只需要考虑 `AB` 和 `A` 形子串有多少个即可，注意去重问题。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*
*/
const int N=2e5+5;
int n,t,ty[N];
long long ans,tot[30][30][N],cnt[N],same[N];
char s[N];
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
//	freopen("tx.in","r",stdin);
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++){
		if(s[i]!=s[i-1]) ty[++t]=s[i]-'a';
		cnt[t]++;
	}
	for(int i=1;i<=t;i++){
		same[ty[i]]=max(same[ty[i]],cnt[i]);
		for(int j=1;j<=cnt[i];j++){
			tot[ty[i-1]][ty[i]][j]=max(tot[ty[i-1]][ty[i]][j],cnt[i-1]);
		}
	}
	for(int i=0;i<26;i++){
		ans+=same[i];
		for(int j=0;j<26;j++){
			if(i==j) continue;
			for(int k=1;k<=n;k++){
//				if(!tot[i][j][k]) continue;
				ans+=tot[i][j][k];
//				cout<<i<<','<<j<<','<<k<<":"<<tot[i][j][k]<<endl;
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：ZHR100102 (赞：1)

# 观察

我们首先观察什么样的字符串才是奇怪的，可以发现，首先类似 `AAAAAAA` 之类全部相等的字符串是奇怪的。

继续观察，如果字符种类变为两种或者三种能不能是奇怪的。显然，类似 `AAABBBBCCDDDEEEEEE` 之类有三种及以上的且每个字母都只在一个连续段出现的串**都不是奇怪的**，因为我们一定可以选不相邻的两个连续段出来，是他不是原串的子串。因此，类似 `AAAAABBBBBB` 的就可以了。

那么一个字母有多个连续段的是不是奇怪的呢？考虑像 `AAABBBAA` 样子的串，我们显然可以把这些连续段的字母全部选出，例如选出 `AAAAA`，这样一定不是原来的子串。

因此，**一个字符串奇怪，当且仅当它满足类似 `AAAAAAAA` 或 `AAAAAABBBBBBB` 的形态**。

# 实现

## 暴力枚举做法

枚举第二种形态的两个字符，线性扫一遍统计即可。

时间 $O(n|\sum|^2)$，能过。

## SAM 做法

考虑建出 SAM，枚举字符 $c$，先求出**从根节点**到每个节点是否有只存在字符 $c$ 的路径，这个可以通过正向拓扑一遍实现。然后再反向拓扑一遍，记录下每个节点后面最多能接多少个 $c$，答案统计的时候先统计第一种形态的答案，再统计第二种，把后缀最多能接的字符数加上即可。

具体看代码吧，时间复杂度 $O(n|\sum|)$，但我实现得很烂，还没暴力枚举跑得快。

### 代码

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
char s[200005];
ll ans;
int n,np=1,tot=1,ch[400005][26],fa[400005],len[400005],rd[400005];
ll pre[400005][26],suf[400005][26],sm[400005];
vector<pi>g1[400005],g2[400005];
void extend(int c)
{
    int p=np;
    np=++tot;
    len[np]=len[p]+1;
    for(;p&&ch[p][c]==0;p=fa[p])ch[p][c]=np;
    if(p==0)fa[np]=1;
    else
    {
        int q=ch[p][c];
        if(len[q]==len[p]+1)fa[np]=q;
        else
        {
            int nq=++tot;
            len[nq]=len[p]+1;
            fa[nq]=fa[q],fa[q]=nq,fa[np]=nq;
            for(;p&&ch[p][c]==q;p=fa[p])ch[p][c]=nq;
            memcpy(ch[nq],ch[q],sizeof(ch[q]));
        }
    }
}
void topo1(vector<pi>*g,ll dp[400005][26])
{
    memset(rd,0,sizeof(rd));
    for(int i=1;i<=tot;i++)
    {
        for(auto ed:g[i])
        {
            int v=ed.fi;
            rd[v]++;
        }
    }
    queue<int>q;
    for(int i=1;i<=tot;i++)
    {
        if(rd[i]==0)q.push(i);
    }
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(auto ed:g[u])
        {
            int v=ed.fi,c=ed.se;
            rd[v]--;
            if(rd[v]==0)q.push(v);
            if(dp[u][c]>=len[u])dp[v][c]+=dp[u][c]+1;
        }
    }
}
void topo2(vector<pi>*g,ll dp[400005][26])
{
    memset(rd,0,sizeof(rd));
    for(int i=1;i<=tot;i++)
    {
        for(auto ed:g[i])
        {
            int v=ed.fi;
            rd[v]++;
        }
    }
    queue<int>q;
    for(int i=1;i<=tot;i++)
    {
        if(rd[i]==0)q.push(i);
    }
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(auto ed:g[u])
        {
            int v=ed.fi,c=ed.se;
            rd[v]--;
            if(rd[v]==0)q.push(v);
            dp[v][c]+=dp[u][c]+1;
        }
    }
}
void cal()
{
    for(int i=1;i<=tot;i++)
    {
        for(int j=0;j<26;j++)
        {
            pre[i][j]=pre[i][j];
            ans+=(pre[i][j]>0);
            sm[i]+=pre[i][j];
        }
    }
    for(int i=1;i<=tot;i++)
    {
        for(int j=0;j<26;j++)
        {
            ans+=suf[i][j]*((sm[i]-pre[i][j])>0);
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>s+1;
    n=strlen(s+1);
    for(int i=1;i<=n;i++)extend(s[i]-'a');
    for(int i=1;i<=tot;i++)
    {
        for(int j=0;j<26;j++)
        {
            int v=ch[i][j];
            if(v)
            {
                g1[i].push_back({v,j});
                g2[v].push_back({i,j});
            }
        }
    }
    topo1(g1,pre);
    topo2(g2,suf);
    cal();
    cout<<ans;
    return 0;
}
```

---

## 作者：jsisonx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11553)

# 题目分析

首先看到数据范围：$\vert s \vert \le 200000$ 就知道题目不简单，这意味着无法用暴力解决。

首先来证明第一点：任何所含字符种类数大于等于 $3$ 的字符串一定不是奇怪的字符串。

对于一个字符串，若它是奇怪的字符串，则至少应该满足字串数等于子序列数。

若一个字符串含有 $n$ 种字符，且其字符数也为 $n$，即每种字符仅出现一次（如```abc```）
，则该序列的非空子序列数为 $2^n-1$ 个，字串数为 $n^2 - \frac{n \times (n-1)}{2}$。

证明：在该字符串中每一个字符都可能被选入子序列或不被选入，一共有 $n$ 个字符，因此子序列总数为 $2^n$ 个，由于要求非空子序列，因此要减一。对于字串，考虑选取几个字符：

- 若选取一个，则有 $n$ 种选法
- 若选取两个，则有 $n-1$ 种选法
- 若选取三个，则有 $n-2$ 种选法
- 若选取 $n$ 个，则有 $n-(n-1)$ 种选法

因此字串数为

$$n+n-1+n-2+ \dots n-(n-1)$$
$$=n^2-(1+2+3+ \dots n-1)$$
$$=n^2 - \frac{n \times (n-1)}{2}$$

若字串数等于子序列数，则要解方程

$$2^n-1=n^2 - \frac{n \times (n-1)}{2}$$

显然当 $n>1$ 时，$n=2$，由于指数函数比多项式函数增长快，因此在 $n>1$ 时 $n=2$ 为唯一解

若将上面的示例```abc```中在添加```a``` 或 ```b``` 或 ```c```，由于添加后增加的子串全部都也是子序列，所以子序列数还是大于子串数。

因此证得奇怪的字符串字符数量小于等于 $2$。

第二点要证明的是：长度为 $2$ 的字符串是奇怪的字符串，当且仅当该字符串中相同的字符都连在一起。

这个比较好证。考虑字符串 ```aaaa...a_bbbb...b_aaaa...a```，最长的全为字符 ```a``` 的字串为两下划线左右两侧全a字符串长度的最大值，最长的全a子序列为左右两侧全a字符串之和又因为所有子串都是子序列，因此一定有子串数小于子序列数。

证了这么多，该求解了。

首先定义形如```aaaaa...abbbbb...b```的字符串为“ab 对”，则理论上该“ab 对”可以贡献 $X_a \times X_b$ 个奇怪的子串，其中 $X_a$，$X_b$ 分别表示 ```a``` 和 ```b```的个数。而有可能在同一个原字符串中存在多个“ab 对”，因此要去重。

首先，将一个“ab 对”画在坐标系中为一个左下角在原点的矩形，左上角纵坐标表示 $X_a$，右下角横坐标表示 $X_b$，则一个“ab 对”可贡献的奇怪字符串数为该矩形的面积。当有多个“ab 对”是，图像如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/n2aobe5e.png)

这样的话，所有“ab 对”可以贡献的奇怪字符串数为用叉标记了的部分的面积，而不同颜色的叉表示计算的顺序：先从最高的矩形（矩形 $0$）开始向下走，如果它下面有一个矩形的右下角横坐标比它大（矩形 $i$），那么奇怪子串数加

$$(y_0-y_i) \times x_0$$

然后矩形 $0$ 变成矩形 $i$，如此下去就能算出整个面积。

注意开始上述操作前先对所有矩形按左上角纵坐标和右下角横坐标从大到小排序，可以用优先队列解决。

最后，有可能在一个“ab 对”中其中一种字符贡献 $0$ 个，这时候只需要统计出原字符串中每种字符连续出现的最长子串即可，如 ```aaaabbbabbbcccc```，此时 ```a``` 的贡献为 $4$。

# 代码

```
#include<bits/stdc++.h>
#define N 1000001
#define int  long long
using namespace std;
map<char,int>used;
struct lx{
	int l,r;
	char c;
}l[N];
struct qc{
	int x,y;
};
bool operator <(qc a,qc b){
	if(a.x!=b.x){
		return a.x<b.x;
	}
	else{
		return a.y<b.y;
	}
}
struct area{
	priority_queue<qc>qa;
}; 
vector<area>va;
int p[30][30];
int h=0,h2=0;
int ans=0;
signed main(){
	char s[N];
	cin>>s;
	for(int i=0;i<30;i++){
		for(int j=0;j<30;j++){
			p[i][j]=-1;
		}
	}
	int len=strlen(s),nowc=s[0],lastl=0;
	for(int i=1;i<len+1;i++){
		if(s[i]!=nowc){
			l[h2].l=lastl;
			l[h2].r=i-1;
			l[h2].c=nowc;
			nowc=s[i];
			lastl=i;
			h2++;
		}
	}//先处理出所有的只含一种字符的子串
	for(int i=0;i<h2-1;i++){
		char c1=l[i].c,c2=l[i+1].c;
		int l1=l[i].r-l[i].l+1,l2=l[i+1].r-l[i+1].l+1;
		if(p[c1-'a'][c2-'a']==-1){
			p[c1-'a'][c2-'a']=h;
			area ar;
			ar.qa.push((qc){l1,l2});
			va.push_back(ar);
			h++;
			continue;
		}
		int pp=p[c1-'a'][c2-'a'];
		va[pp].qa.push((qc){l1,l2});
	}//统计“ab对”
	for(int i=0;i<h;i++){
		area now=va[i];
		qc first=now.qa.top();
		now.qa.pop();
		while(!now.qa.empty()){
			if(now.qa.top().y<=first.y){
				now.qa.pop();
			}
			else{
				ans+=(first.x-now.qa.top().x)*first.y;
				first=now.qa.top();
				now.qa.pop();
			}
		}
		ans+=first.x*first.y;
	}//计算面积
	for(int i=0;i<h2;i++){
		char nc=l[i].c;
		ans+=max((int)0,(l[i].r-l[i].l+1-used[nc]));
		used[nc]=max(used[nc],l[i].r-l[i].l+1);
	}//有一个字符贡献0个
	cout<<ans;
	return 0;
}
```

---

## 作者：Drifty (赞：1)

### Solution

简单题。

首先我们注意到字串是奇怪的当且仅当其形如 `AAA...A` 或 `AAA...ABBB...B`。

然后这个东西的证明：考虑往上面形状的字符串里加入其它一个字符，然后就可以取出反例，对于更多的情况可以归纳掉，就证好了。

然后直接统计上述字串的个数，这个是很容易的。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
int main() {
    cin.tie(NULL) -> sync_with_stdio(false);
    string s; cin >> s; s += '$';
    vector <pair <int, int> > a;
    for (int i = 1, l = 1; i < (int)s.size(); i ++)
        if (s[i] != s[i - 1]) a.emplace_back(s[i - 1] - 'a', l), l = 1; else l ++;
    long long ans = 0;
    vector <int> mp(256, 0);
    auto cmax = [](int &x, int y) {return x = max(x, y);};
    for (auto [c, l] : a) cmax(mp[c], l);
    for (auto l : mp) ans += l;
    static int t[28][28][(int)2e5 + 7];
    for (int i = 1; i < (int)a.size(); i ++)
        for (int j = 1; j <= a[i].second; j ++)
            cmax(t[a[i - 1].first][a[i].first][j], a[i - 1].second); 
    for (int i = 0; i < 26; i ++)
        for (int j = 0; j < 26; j ++)
            for (int k = 1; k < (int)s.size(); k ++) ans += t[i][j][k];
    return cout << ans << '\n', 0;
}
```

---

## 作者：qW__Wp (赞：0)

容易发现一个奇怪的字符串必然是 $\texttt{aa\dots a}$ 或 $\texttt{aa\dots abb\dots b}$ 的形式。问题转换为统计 $s$ 中满足这两种形式之一的子串个数。

对于 $\texttt{aa\dots a}$ 这种形式的子串，数量为每个字母连续出现的最长长度之和。以下考虑 $\texttt{aa\dots abb\dots b}$ 这种形式的统计。

首先将 $s$ 拆分为若干段连续子串 $s_1,s_2,\dots,s_{cnt}$，使任意 $s_i$ 都由 $p_i$ 个字母 $t_i$ 组成，并满足 $\forall 1 \le i < cnt,t_i \neq t_{i+1}$。

接下来，记 $len$ 个字母 $c1$ 与 若干个字母 $c2$ 拼接而成的不重复子串有 $g_{c1,c2,len}$ 个。根据定义，有递推公式

$$g_{t_i,t_{i+1},j} = \max(g_{t_i,t_{i+1},j},p_i)(1 \le i < cnt,1 \le j \le p_{i+1})$$

答案即为所有情况的总和，再加上单个字母的情况。

详见代码。

```
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

int G[28][28][N], sum[28], p[N], t[N], cnt;

signed main() {
	string s; cin >> s;
	int n = s.size(); s = " " + s;
	for (int i = 1; i <= n; i ++) {
		if (s[i] != s[i - 1]) t[ ++ cnt] = s[i] - 'a';
		p[cnt] ++;
	}
	// 以上为拆分
	for (int i = 1; i <= cnt; i ++) {
		sum[t[i]] = max(sum[t[i]], p[i]); // 更新单个字母连续出现的最长长度 
		if (i == cnt) break;
		for (int j = 1; j <= p[i + 1]; j ++) {
			G[t[i]][t[i + 1]][j] = max(G[t[i]][t[i + 1]][j], p[i]);
		}
	}
	long long ans = 0;
	for (int i = 0; i < 26; i ++) {
		ans += sum[i];
		for (int j = 0; j < 26; j ++) {
			if (i == j) continue;
			for (int k = 1; k <= n; k ++) {
				ans += G[i][j][k];
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：lzx111218 (赞：0)

# P11553 [ROIR 2016 Day 1] 奇怪的字符串
[题目传送门](https://www.luogu.com.cn/problem/P11553)

## 思路
~~给我 MLE 爽了。~~

**奇怪的字符串的定义**：

- 如果一个子串是由连续相同字符组成的，它一定是奇怪的子串。
- 包含不同字符的子串，如果它是按顺序排列且字符不重复，依然是奇怪的子串。

**举个栗子：**

字符串 `abba` 的所有子串包括：`a`，`b`，`ab`，`ba`，`bb`，`abb`，`bba`，`abba`。  
对于每个子串，我们可以检查它是否满足奇怪字符串的条件。在这个例子中，字符串 `abb` 是奇怪的，因为它的所有子串也是它的子序列，而 `abba` 不是奇怪子串的，因为它包含了多个相同字符的不同排列。所以，字符串 `abba` 的奇异度为 $7$，因为它的所有**除它本身以外**的子串都是奇怪的。

接下来就很简单了，用 for 双重循环和切片操作实现子串生成，再通过迭代验证子序列条件就完事了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int n, t, y[N];
long long ans, t1[30][30][N], c[N], s1[N];
char s[N];

int L(const char* x) {
    int l = 0;
    while (x[l] != '\0') {
        l++;
    }
    return l;
}

void P() {
    for (int i = 1; i <= n; i++) {
        if (s[i] != s[i - 1]) {
            y[++t] = s[i] - 'a';
        }
        c[t]++;
    }
    
    for (int i = 1; i <= t; i++) {
        s1[y[i]] = max(s1[y[i]], c[i]);
        for (int j = 1; j <= c[i]; j++) {
            t1[y[i - 1]][y[i]][j] = max(t1[y[i - 1]][y[i]][j], c[i - 1]);
        }
    }
}

void C() {
    for (int i = 0; i < 26; i++) {
        ans += s1[i];
        for (int j = 0; j < 26; j++) {
            if (i == j) continue;
            for (int k = 1; k <= n; k++) {
                ans += t1[i][j][k];
            }
        }
    }
}

int main() {
    scanf("%s", s + 1);
    n = L(s + 1);
    P();
    C(); 
    printf("%lld\n", ans); 
    return 0;
}
```

---


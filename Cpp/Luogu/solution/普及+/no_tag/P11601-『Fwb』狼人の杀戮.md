# 『Fwb』狼人の杀戮

## 题目描述

Fwb 开始玩狼人杀了。

这是一个游戏规则略有不同的简化版的狼人杀，若与现实中狼人杀规则不同，应以题目为准。开局共有 $n$（$n≥2$）位玩家，他们的身份共有以下几种：

- 狼人：在天黑时可以进行选择一位非自己的玩家杀害，可以是其他狼人。
- 平民：在天黑时只能闭眼睡觉，没有任何技能。
- 猎人：若自己存活，在天黑时只能闭眼睡觉；若在此夜被杀死且未被解救，**必须**任意带走一位非自己玩家（带走意义即为杀死）。若带走玩家之后又被救活，则下一次被杀死依旧可以继续带走玩家，且此次带走依然成立。换句话说，带走玩家后再被救活也是合法的。
- 女巫：在天黑时可以进行选择：用解药解救任意一个在今夜死亡的玩家（可以是自己），或用毒药毒死任意存活的玩家（不可以是自己）。特殊的，女巫可以在被杀死后对自己使用解药，但不可以进行其他技能操作。请注意，每一位女巫只有一次解药和一次毒药的机会，且**不可以在同一夜使用**。


在黑夜中，将模拟**各种角色技能的进行**，有如下几种格式：

- $0\ id_1\ id_2$：编号为 $id_1$ 的狼人决定将编号为 $id_2$ 的玩家杀害。
- $1\ id_1\ id_2$：编号为 $id_1$ 的女巫决定将编号为 $id_2$ 的玩家毒死。
- $2\ id_1\ id_2$：编号为 $id_1$ 的女巫决定将编号为 $id_2$ 的玩家救活。
- $3\ id_1\ id_2$：编号为 $id_1$ 的猎人被杀死，决定带走编号为 $id_2$ 的玩家。


在天亮后，将公布昨夜的**死亡情况**，有如下几种格式：

- $x\ id_1\ id_2\ ...\ id_x$：共 $x$ 名编号分别为 $id_1\ id_2\ ...\ id_x$ 的玩家在昨夜被杀害，每两个玩家编号之间用空格隔开。注意，$id_i$ 必须严格单调递增。
- `Safe`：昨夜是平安夜，其中平安夜指没有人死亡即 $x=0$ 的夜晚。
- `Wrong`：昨夜的角色技能输入有误。此夜晚将撤回全部操作。

当出现以下情况时，认为昨夜的角色技能输入有误：

- 编号为 $id$ 的玩家不存在。
- 除女巫使用解药时，编号为 $id$ 的玩家已死亡。
- **同一位**狼人、女巫在同一晚上多次使用技能。
- 猎人未被杀死就使用技能。
- 猎人在被杀死时带走多人。
- 玩家使用了不属于自己的技能。
- 女巫将解药用在了未死亡或非今夜死亡的人身上。
- 狼人杀人、女巫使用毒药、猎人带走玩家时对自己使用技能。

当一夜技能输入有误时，该夜的所有操作均不被执行。

请注意，一个夜晚是有时间顺序的，这个时间顺序决定了输入的合法性。例如，在同一夜晚，女巫先对编号为 $id$ 的玩家使用解药，狼人再杀死编号为 $id$ 的玩家，然后夜晚结束，属于不合法输入。

现在告诉你了在黑夜中，各种角色技能的进行。你需要判断昨夜的死亡情况。

## 说明/提示

**本题采用捆绑测试。**

#### 【样例 1 解释】
编号为 $1\sim 6$ 的玩家的身份分别是：狼人、平民、猎人、女巫、平民、狼人。

第一夜：

- $1$ 号狼人杀死了 $3$ 号猎人。
- $3$ 号猎人带走了 $1$ 号狼人。
- $4$ 号女巫毒死了 $5$ 号平民。

结果：$3$ 号猎人被 $1$ 号狼人杀死，$1$ 号狼人被 $3$ 号猎人带走，$5$ 号平民被 $4$ 号女巫毒死。此时仅有 $2$ 号平民、$4$ 号女巫和 $6$ 号狼人存活。

第二夜：

- $4$ 号女巫毒死了 $2$ 号平民。
- $2$ 号狼人杀死了 $4$ 号女巫。

结果：$2$ 号是平民且已经死亡，此回合不合法。此时仍有 $2$ 号平民、$4$ 号女巫和 $6$ 号狼人存活。

第三夜：

- $6$ 号狼人杀死了 $2$ 号平民。
- $4$ 号女巫解救了 $2$ 号平民。

结果：$2$ 号平民在被狼人杀死之后被女巫救活，今夜是平安夜。

#### 【样例 2 解释】

第一夜：猎人先被狼人杀死，女巫又救活了猎人，故猎人最终存活，无法带走其他玩家。

第二夜：猎人被狼人杀死，没有人救活他，所以猎人必须带走一名玩家。

#### 【数据范围】

对于 $100\%$ 的数据，$1\le t\le 10$，$2\le n\le 20$，$1\le a_i\le 4$，$1\le m\le 20$。

| 子任务 | $1\le t\le$ | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $10$ | A、B |
| $2$ | $5$ | $10$ | B |
| $3$ | $5$ | $30$ | 无 |
| $4$ | $10$ | $50$ | 无 |
| $5$ | $10$ | $0$ | C |


特殊性质 A：每一晚一定有人死亡。

特殊性质 B：只存在狼人与平民，不存在输入不合法的情况。

特殊性质 C：本子任务为 Hack 数据，不占分。

**请注意，所有玩家被杀死即生效，而不是等待夜晚结束之后。特殊的，猎人仍有使用技能的权力。**

## 样例 #1

### 输入

```
3 6
1 2 3 4 2 1
3
0 1 3
3 3 1
1 4 5
2
1 4 2
0 2 4
2
0 6 2
2 4 2```

### 输出

```
3 1 3 5
Wrong
Safe```

## 样例 #2

### 输入

```
2 3
1 3 4
3
0 1 2
2 3 2
3 2 1
1
0 1 2```

### 输出

```
Wrong
Wrong```

# 题解

## 作者：All_Wrong_Answer (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P11601)

### 前言：

2025.1.22：被出题人 Hack，更改代码后通过了，重审。

2025.1.23：又被 Hack，改了一下又过了，再次重审。

AK 了这场比赛，rk14，被这题折磨了近一个小时，必须写个题解泄愤。

## 思路：

**大模拟**，细节超级多：

1. 如果当晚是不合法的，那么应当讲这晚的所有操作恢复成上一晚结束时的状态，包括：死亡全部不算，女巫用的药也不算。
2. 判断不合法（3~11）：
3. id不存在，不合法。
4. 不是某一身份的人用了那个身份的技能。
5. 杀了已经死的人。
6. 一晚多次用技能（包括女巫一晚同时用解药毒药）。
7. 杀自己。
8. 不符合技能使用条件就用技能。
9. 女巫被杀了只能用解药，用毒药不合法。
10. 杀多人。
11. 女巫解药救没死的人。
12. 每晚清空的：当夜死亡的人，当晚技能使用次数。
13. 记得记录当晚死亡人数。
14. 已经死亡的人用技能。
15. 女巫死后解药只能救自己！


可以看看代码，有详细注释：


```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n;
int sf[105];//身份 
bool sw[105];//死亡的人 
int nwjy[105],nwdy[105];//女巫的毒药和解药 
int shnwjy[105],shnwdy[105];//上一晚时女巫毒药和解药的状态 
bool jncs[105];//当晚技能使用次数 
int flag1=0,flag2=0;//flag1：判断非法；flag2：当晚死亡人数 
bool dysw[105];//当晚死亡的人 
int a[1005],b[1005];
int main(){
	cin>>t>>n;
	for(int i=1;i<=n;i++){
		cin>>sf[i];
	}
	for(int i=1;i<=t;i++){
		memset(jncs,0,sizeof(jncs));
		memset(dysw,0,sizeof(dysw));
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		//多测清空 
		int u;
		cin>>u;
		flag1=0;
		flag2=0; 
		//重置是否合法的flag1和当夜死亡人数的flag2 
		for(int j=1;j<=u;j++){
			int c;
			cin>>a[j]>>b[j]>>c;
			if(b[j]>n||c>n) flag1=1;//id不存在 
			if(a[i]<0||a[i]>3) flag1=1;
			if(flag1==1) continue;//当夜不合法可以直接输入完就continue 
			if(a[j]==0){
				if(sf[b[j]]!=1) flag1=1;//非狼人刀人
				else if(sw[c]==true) flag1=1;//刀了已经死了的人
				else if(jncs[b[j]]==true) flag1=1;//多次刀人
				else if(b[j]==c) flag1=1;//刀自己
				else{
					sw[c]=true;
					dysw[c]=true;
					jncs[b[j]]=true;
					flag2++;
				} 
			}
			if(a[j]==1){
				if(sw[b[j]]==true) flag1=1;
				else if(nwdy[b[j]]==true) {flag1=1;}//毒药用完了
				else if(jncs[b[j]]==true) flag1=1;//多次毒人
				else if(sf[b[j]]!=4) flag1=1; //非女巫毒人
				else if(sw[c]==true) flag1=1;//毒已经死的人
				else if(b[j]==c) flag1=1;//毒自己
				else{
					sw[c]=true;
					dysw[c]=true;
					jncs[b[j]]=true;
					nwdy[b[j]]=true;
					flag2++;
				} 
			}
			if(a[j]==2){
				if(sw[b[j]]==true&&c!=b[j]) flag1=1;//被Hack的地方1
				else if(nwjy[b[j]]==true){flag1=1;}//解药用完了
				else if(jncs[b[j]]==true) flag1=1;//多次解药救人
				else if(sf[b[j]]!=4) flag1=1; //非女巫救人
				else if(dysw[c]==false) flag1=1;//非当夜死亡
				else if(sw[c]==false) flag1=1;//救活人 
				else {
					if(sf[c]==3){
						jncs[c]=false;//被Hack的地方2
					}
					sw[c]=false;
					dysw[c]=false;
					jncs[b[j]]=true;
					nwjy[b[j]]=true;
					flag2--;
				} 
			}
			if(a[j]==3){
				if(dysw[b[j]]==false) flag1=1;//当夜没死 
				else if(jncs[b[j]]==true) flag1=1;//带走多人 
				else if(sf[b[j]]!=3) flag1=1; //非猎人带走别人 
				else if(sw[c]==true) flag1=1;//带走死人
				else if(b[j]==c) flag1=1;//杀自己 
				else {
					sw[c]=true;
					dysw[c]=true;
					jncs[b[j]]=true;
					flag2++;
				} 
			}
		}
		for(int k=1;k<=n;k++){
			if(sf[k]==3&&dysw[k]==true&&jncs[k]==false){
				flag1=1;//猎人没带走人 
				break;
			}
		}
		if(flag1==1){
			for(int k=1;k<=n;k++){
				if(dysw[k]==true) sw[k]=false;
			}//不合法，回溯死亡状态 
			for(int i=1;i<=n;i++){
				nwdy[i]=shnwdy[i];
				nwjy[i]=shnwjy[i];
			}//不合法，回溯女巫的毒药和解药 
			cout<<"Wrong\n";
		} 
		else if(flag2==0) cout<<"Safe\n" ;//平安夜 
		else{
			cout<<flag2<<" ";
			for(int l=1;l<=n;l++){
				if(dysw[l]==true) cout<<l<<" ";
			}
			cout<<endl;
		}
		for(int i=1;i<=n;i++){
			shnwdy[i]=nwdy[i];
			shnwjy[i]=nwjy[i];
		}
		//更新女巫的毒药和解药的状态 
	}
	return 0;
}
```

---

## 作者：matrixPower (赞：8)

小声哔哔：~~希望能通过。~~

[传送门](https://www.luogu.com.cn/problem/P11601)

简单小模拟。

这个题细节比较多，这里把笔者错过的细节写出来：

1. 如果你 `#6` 错了：编号为 $id$ 的玩家是否存在（不只是身份是否合法，还得看在不在 $1 \sim n$ 内）。

2. 如果你 `#12` 错了：女巫在今夜死了，他只有两个选择：就自己或啥也不干。

3. 如果你 `#3 #7` 错了：猎人死后被女巫救起，不需开枪。

4. 女巫只有一瓶毒药和一瓶解药，且不能同一晚上使用。

5. 输入错误后**所有**东西都要还原。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define lowbit(x) (x)&(-x)
using namespace std;

typedef double db;
typedef long long ll;
typedef __int128 III;
const db eqs=1e-6;
const int inf=1e9;
void ll_cmax(ll &a,ll b){a=a>b?a:b;}
void ll_cmin(ll &a,ll b){a=a<b?a:b;}
void int_cmax(int &a,int b){a=a>b?a:b;}
void int_cmin(int &a,int b){a=a<b?a:b;}
bool db_eq(db a,db b){return fabs(a-b)<eqs;}
bool number(char ch){return ch>='0' && ch<='9';}
bool lowerchar(char ch){return ch>='a' && ch<='z';}
int sqlong(int n){int sq=sqrt(n)+1;return min(sq,n);}

const int MAXN=20+5; 
int n,m,a[MAXN],c[MAXN],bf[MAXN],d[MAXN];                             //c 为最近一次使用技能时间 （女巫单独存） 
pair<int,int>b1[MAXN],b2[MAXN],b[MAXN];                               //a 为身份，b 为是否死亡
vector<int>peo1,peo2;                                                 //今夜死的人 

void beifen()
{
	for(int i=1;i<=n;i++) bf[i]=c[i],b2[i]=b1[i];
}

void huanyuan()
{
	for(int i=1;i<=n;i++) c[i]=bf[i],b1[i]=b2[i];
	for(int i=0;i<peo1.size();i++) b[peo1[i]].second=0,b[peo1[i]].first=0;
}

void shanchu(int x)
{
	for(int i=peo1.size()-1;i>=0;i--)
	{
		int f=peo1[i];
		peo1.pop_back();
		if(x==f)
		{
			for(int j=0;j<peo2.size();j++) peo1.push_back(peo2[j]);
			peo2.clear();
			break;
		}
		peo2.push_back(f);
	}
	d[x]=0;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>m>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int t;
	for(int k=1;k<=m;k++)
	{
		peo1.clear();beifen();for(int i=1;i<=n;i++) d[i]=0;
		cin>>t;
		int id,id1,id2,j=t; 
		bool flag=0;
		for(int i=1;i<=t;i++)
		{
			cin>>id>>id1>>id2;
			if(id1<0 || id1>n || id2<0 || id2>n) {flag=1;break;}
			if(a[id1]==2)
			{
				flag=1;
				j=i;
				break;
			}
			if(id==0)
			{
				if(a[id1]!=1 || id1==id2 || b[id1].first || b[id2].first || c[id1]==k) 
				{
					flag=1;
					j=i;
					break;
				}
				c[id1]=k;
				b[id2].first=1; 
				b[id2].second=k;
				peo1.push_back(id2);
				if(a[id2]==3) d[id2]=1;
			}
			if(id==3)
			{
				if(a[id1]!=3 || b[id1].second!=k || b[id2].first || c[id1]==k)
				{
					flag=1;
					j=i;
					break;
				}
				d[id1]=0;
				c[id1]=k;
				b[id2].first=1;
				b[id2].second=k;
				peo1.push_back(id2);
			}
			if(id==2)
			{
				if(a[id1]!=4 || b[id2].second!=k || b1[id1].first || b1[id1].second==k)
				{
					flag=1;
					j=i;
					break;
				}
				if(b[id1].first && id2!=id1)
				{
					flag=1;
					j=i;
					break;
				}
				b1[id1].first=k;
				b[id2].first=0;
				b[id2].second=0;
				shanchu(id2);
				if(a[id2]==3) c[id2]=0;
			}
			if(id==1)
			{
				if(a[id1]!=4 || id1==id2 || b[id1].first || b[id2].first || b1[id1].second || b1[id1].first==k)
				{	
					flag=1;
					j=i;
					break;
				}
				b1[id1].second=k;
				b[id2].first=1; 
				b[id2].second=k;
				peo1.push_back(id2);
				if(a[id2]==3) d[id2]=1;
			} 
		}
		int p,q,m;
		for(int i=j+1;i<=t;i++) cin>>p>>q>>m;
		for(int i=1;i<=n;i++) if(d[i]) {flag=1;break;}
		if(flag)
		{
			cout<<"Wrong\n";
			huanyuan();
		}
		else if(peo1.size()==0) cout<<"Safe\n";
		else 
		{
			sort(peo1.begin(),peo1.end());
			cout<<peo1.size()<<" ";
			for(int i=0;i<peo1.size();i++) cout<<peo1[i]<<" ";
			cout<<endl;
		}
	}
	return 0;
}
//by Matrix_Power

```

---

## 作者：Frielen (赞：6)

## 前言

逆天模拟，把我第 $4$ 题秒杀的优势全部打没了。

放在这种 $4$ 小时的比赛还是太暴殄天物了。

## 正文

**由于我对题面的理解较为模糊，可能有~较为成分的代码~缺漏，比如只能刀活人就不知道今晚的算不算**

代码就是模拟题的最好题解了，一个个拆分来讲。

### 如何记录死亡状态？

考虑用数组 `die` 来储存。

若 `die[i]=0`，则其存活。

若 `die[i]=1`，则其在该轮以前已经死亡。

若 `die[i]=2`，则其在这一晚死亡。

设置 $1$ 和 $2$ 的原因是分清女巫能否对其用药。

### 如何进行技能有误后的回溯操作？

拿一个临时数组存即可。

### 代码实现

数组定义：

`medi[i][0]`：女巫的毒药。

`medi[i][1]`：女巫的解药。

`die[i]`：见上文。

`nig[i]`：记录今晚其是否使用技能。

`medi1[i][0/1]`：临时数组，用于回溯。

`die1[i]`：临时数组，用于回溯。

**读入**
```
cin>>t>>n;
for(int i=1;i<=n;i++) cin>>a[i];
```

**临时数组与回溯**

**回溯**：
```
void clear(){
	for(int i=1;i<=n;i++) medi[i][0]=medi1[i][0],medi[i][1]=medi1[i][1],die[i]=die1[i];
}
```
**准备回溯与数组清空**
```
for(int i=1;i<=n;i++){
  medi1[i][0]=medi[i][0];
  medi1[i][1]=medi[i][1];
  die1[i]=die[i];
  nig[i]=0;
}
```

**各种职业的操作**

狼人：
```cpp
if(!op){
	if(a[id1]!=1||id1==id2||die[id2]!=0){
		//判断 1：不是狼人
		//判断 2：不能刀自己
		//判断 3：对面没死 
		flag=1;
		continue;
		//再见~ 
	}
	die[id2]=2;
}
```
女巫出毒：
```cpp
else if(op==1){
	if(a[id1]!=4||die[id2]!=0||medi[id1][1]||id1==id2||die[id1]!=0){
		//判断 1：不是女巫
		//判断 2：对面活着
		//判断 3：还有药
		//判断 4：不能毒自己
		//判断 5：最大坑点！！！自己死了就只能药自己，不能出毒 
		flag=1;
		//再见~ 
		continue;
	}
	medi[id1][1]=1,die[id2]=2;
}

```
女巫出药：
```cpp
else if(op==2){
		if(a[id1]!=4||die[id2]!=2||medi[id1][0]||(die[id1]==2&&id1!=id2)){
		//判断 1：不是女巫
		//判断 2：对面得死了，不能是活的 
		//判断 3：还有药 
		//判断 4：自己死了只能药自己
		flag=1;
		//再见~ 
		continue;
	}
	if(a[id2]==3) nig[id2]=0;
	//坑点！！！猎人被救后还能用技能，所以要清空
	medi[id1][0]=1,die[id2]=0;
}
```
猎人：
```cpp
else{
	if(a[id1]!=3||die[id1]!=2||die[id2]!=0||id1==id2){
		//判断 1：不是猎人
		//判断 2：没死不能开枪
		//判断 3：对面得活着
		//判断 4：不能自己枪自己 
		flag=1;
		//再见~ 
		continue;
	}
	die[id2]=2;
}
```
特判：
```
if(id2<1||id2>n||id1<1||id1>n||a[id1]==2||nig[id1]||die[id1]==1){
	//判断 1：id1 和 id2 不能越界
	//判断 2：平民没技能
	//判断 3：还没用技能
	//判断 4：还没死透 
	flag=1;
	//再见~ 
	continue;
}
nig[id1]=1;
//用过技能了，打标记
```

**夜晚结果判断**

```cpp
if(flag){
	puts("Wrong");
	//不行 
	clear();
	continue;
}
int cnt=0;
for(int i=1;i<=n;i++) if(die[i]==2) cnt++;
if(!cnt){
	puts("Safe");
	//平安夜 
	continue;
}
cout<<cnt<<' ';
for(int i=1;i<=n;i++)
	if(die[i]==2){
		cout<<i<<' ';
		//死亡人编号，桶保证了其有序性 
		die[i]=1;
	}
puts("");
//换行 
```

其他就没什么难的了，上代码~

## My code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=29;
int t,n,a[N],die[N],medi[N][2],nig[N];
int medi1[N][2],die1[N];
void clear(){
	for(int i=1;i<=n;i++) medi[i][0]=medi1[i][0],medi[i][1]=medi1[i][1],die[i]=die1[i];
}
signed main(){
	cin>>t>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	while(t--){
		for(int i=1;i<=n;i++) medi1[i][0]=medi[i][0],medi1[i][1]=medi[i][1],die1[i]=die[i],nig[i]=0;
		int m,op,id1,id2;
		cin>>m;
		bool flag=0;
		for(int now=1;now<=m;now++){
			cin>>op>>id1>>id2;
			if(id2<1||id2>n||id1<1||id1>n||a[id1]==2||nig[id1]||die[id1]==1){
				flag=1;
				continue;
			}
			nig[id1]=1;
			if(!op){
				if(a[id1]!=1||id1==id2||die[id2]!=0){
					flag=1;
					continue;
				}
				die[id2]=2;
			}
			else if(op==1){
				if(a[id1]!=4||die[id2]!=0||medi[id1][1]||id1==id2||die[id1]!=0){
					flag=1;
					continue;
				}
				medi[id1][1]=1,die[id2]=2;
			}
			else if(op==2){
				if(a[id1]!=4||die[id2]!=2||medi[id1][0]||(die[id1]==2&&id1!=id2)){
					flag=1;
					continue;
				}
				if(a[id2]==3) nig[id2]=0;
				medi[id1][0]=1,die[id2]=0;
			}
			else{
				if(a[id1]!=3||die[id1]!=2||die[id2]!=0||id1==id2){
					flag=1;
					continue;
				}
				die[id2]=2;
			}
		}
		for(int i=1;i<=n;i++) if(a[i]==3&&die[i]==2&&!nig[i]) flag=1;
		if(flag){
			puts("Wrong");
			clear();
			continue;
		}
		int cnt=0;
		for(int i=1;i<=n;i++) if(die[i]==2) cnt++;
		if(!cnt){
			puts("Safe");
			continue;
		}
		cout<<cnt<<' ';
		for(int i=1;i<=n;i++)
			if(die[i]==2){
				cout<<i<<' ';
				die[i]=1;
			}
		puts("");
	}
	return 0;
}
```

---

## 作者：szh_AK_all (赞：5)

给出题面里没有明确带到的几点：

- 狼人，女巫，猎人无法杀死在该次操作之前，**此夜**被杀死且未被救活的玩家；

- 某位玩家确定在某一夜死后，在之后的夜晚不参与比赛，即被淘汰。

显然，被淘汰的玩家不能参与此后的任何操作。

接下来，处理各种错误情况便是简单的了，可以用数组记录当前夜晚的玩家存活情况、玩家的淘汰情况、玩家在此夜技能的使用次数，女巫需要特别记录，因为女巫总共只能使用毒药、解药各一次，所以单独开数组记录女巫使用毒药、解药的次数。

由于不合法的夜晚是不会对玩家产生影响的，所以用临时数组来记录在当前夜晚开始前的所有状态，如果该夜晚不合法，那么应当将状态改回去。

具体情况看代码注释。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[25], die[25];//die:淘汰情况
int nd[25], jiu[25], du[25], ji[25];//nd:当前夜晚死亡情况 jiu:女巫解药使用情况 du:女巫毒药使用情况 ji:玩家技能使用情况
int si[25], cnt;//记录此夜被淘汰的玩家
int yd[25], yj[25];//yd:du 的原状态，yj:jiu 的原状态

int main() {
	int t, n;
	cin >> t >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	int kkk = 0;
	while (t--) {
		kkk++;
		for (int i = 1; i <= n; i++)
			yd[i] = du[i], yj[i] = jiu[i];
		memset(nd, 0, sizeof(nd));
		memset(ji, 0, sizeof(ji));//清空
		int m;
		cin >> m;
		int f = 0;
		for (int i = 1; i <= m; i++) {
			int op, x, y;
			cin >> op >> x >> y;
			if (x < 1 || y < 1 || x > n || y > n || die[x] || die[y] || f) {//越界情况或者已被淘汰的玩家参与了操作，注意若 f=1 不能直接 break，因为输入还没结束
				f = 1;
				continue;
			}
			if (op == 0) {
				if (a[x] != 1)//不是狼人
					f = 1;
				else if (ji[x] || nd[x] || nd[y])//自己死了或者杀得人死了或者在此夜技能使用了多次
					f = 1;
				else if (y == x)//杀自己
					f = 1;
				else
					ji[x] = 1, nd[y] = 1;
			} else if (op == 1) {
				if (a[x] != 4 || nd[x] || nd[y])//同理
					f = 1;
				else if (du[x] || jiu[x] == kkk || y == x)//已经使用过毒药或是毒死自己或是在此夜用过了解药
					f = 1;
				else
					du[x] = kkk, nd[y] = 1;//记录毒药在此夜被使用

			} else if (op == 2) {
				if (a[x] != 4)//同理
					f = 1;
				else if (jiu[x] || du[x] == kkk || !nd[y])//同理
					f = 1;
				else if (nd[x] && x != y)//如果自己被杀死了但是没救自己
					f = 1;
				else {
					jiu[x] = kkk, nd[y] = 0;////记录解药在此夜被使用
					if (a[y] == 3) {//如果救的是猎人，那么猎人还可以使用技能
						ji[y] = 0;
					}
				}
			} else {
				if (a[x] != 3)//同理
					f = 1;
				else if (!nd[x] || nd[y])//如果没死救使用技能或是杀的人已经死了
					f = 1;
				else if (ji[x])//同理
					f = 1;
				else if (y == x)//同理
					f = 1;
				else
					ji[x] = 1, nd[y] = 1;
			}
		}
		for (int i = 1; i <= n; i++)
			if (a[i] == 3 && nd[i] && !ji[i])//注意特判列入死了但是未使用技能的情况
				f = 1;
		if (f) {
			for (int i = 1; i <= n; i++)
				du[i] = yd[i], jiu[i] = yj[i];//改回状态
			cout << "Wrong\n";
			continue;
		}
		cnt = 0;
		for (int i = 1; i <= n; i++)
			if (!die[i] && nd[i])
				si[++cnt] = i;
		if (!cnt)
			cout << "Safe\n";
		else {
			cout << cnt << " ";
			for (int i = 1; i <= cnt; i++)
				die[si[i]] = 1, cout << si[i] << " ";//标记已被淘汰
			cout << "\n";
		}
	}
}
```

---

## 作者：_H17_ (赞：3)

## 题目分析

下面主要讲解对中大模拟的一些技巧。

首先要认真看题目描述，确保自己理解要模拟的过程。

通常模拟的数据范围不会很大，我们可以尽情暴力，当然最好不要指数级别的。

要清楚这个题比较难的操作是啥，要维护什么。

首先，要求的当晚死人列表要维护。然后模拟过程的时候，我们想想我们在玩需要知道什么：角色、死没死、技能用没用、有没有权利用技能、是不是当晚死的。这些恰好也可以来判断不合法（其实题目良心的告诉你了什么不合法，照着判断就行了）。

同时如果不合法要恢复到前一天，所以留一个副本。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=50;
int T,n,m,wa,vis[N];
struct Player{ // 玩家
    int id,role,alive,isp,iss,ish=0;
    Player(int id=0,int role=0,int alive=1,int isp=0,int iss=0,int ish=0)
        :id(id),role(role),alive(alive),isp(isp),iss(iss){}
}a[N];//wolf 1, people 2, hunter 3, magician 4;
set<int>lastdie,curdie;//当晚死的人
bool iscurdie(int x){
    for(auto p:curdie)
        if(p==x)
            return 1;
    return 0;
}
int main(){
    cin>>T>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i].role;
    for(int _=1;_<=T;_++){
    	cin>>m;
        for(int i=1;i<=n;i++)
            a[n+i]=a[i];
        memset(vis,0,sizeof(vis));
        lastdie=curdie,curdie.clear();
        wa=0;//初始化
        for(int i=1,op,id1,id2;i<=m;i++){
            cin>>op>>id1>>id2;
            if(wa==1)
                continue;
            if(1<=id1&&id1<=n&&1<=id2&&id2<=n);
            else{
                wa=1;
                continue;
            }
            if((a[id1].role==1||a[id1].role==4)&&vis[id1]){
                wa=1;
                continue;
            }//不合法判断
            vis[id1]=1;
            if(op==0){
                if(a[id1].role!=1||!a[id1].alive||id1==id2||!a[id2].alive){
                    wa=1;
                    continue;
                }//判断
                a[id2].alive=0,curdie.insert(id2);//杀人
            }
            else if(op==1){
                if(a[id1].isp||a[id1].role!=4||!a[id1].alive||id1==id2||!a[id2].alive){
                    wa=1;
                    continue;
                }//判断
                a[id2].alive=0,curdie.insert(id2),a[id1].isp=1;
            }//杀人
            else if(op==2){
                if(a[id1].iss||a[id1].role!=4||a[id2].alive){
                    wa=1;
                    continue;
                }//判断
                if(!a[id1].alive&&(id1!=id2||!iscurdie(id1))){
                    wa=1;
                    continue;
                }
                if(!iscurdie(id2)){
                    wa=1;
                    continue;
                }
                a[id2].alive=1,a[id2].ish=0,curdie.erase(id2),a[id1].iss=1;//救人
            }
            else if(op==3){
                if(a[id1].alive||!iscurdie(id1)||a[id1].ish||!a[id2].alive){
                    wa=1;
                    continue;
                }
                a[id2].alive=0,curdie.insert(id2),a[id1].ish=1;
            }//带人
        }
        for(int i=1;i<=n;i++)
        	if(a[i].role==3&&iscurdie(i)&&a[i].ish==0){
        		wa=1;
        		break;
			}
        if(wa){
            cout<<"Wrong\n";
            for(int i=1;i<=n;i++)
                a[i]=a[n+i];
            curdie=lastdie;
            continue;
        }//恢复
        if(!curdie.size())
            cout<<"Safe\n";
        else{
            cout<<curdie.size()<<' ';
            for(auto p:curdie)
                cout<<p<<' ';
            cout<<'\n';
        }//输出
    }
    return 0;
}
```

总结：比较锻炼代码能力的中模拟，可以在浮躁的时候收心用。

---

## 作者：WsW_ (赞：3)

### 更新
这是一篇已通过的题解。

- $2025.01.22$ 通过不了 Hack 数据，故更新。

---
### 思路
模拟题先确定判断的步骤。  
对于一个操作，我用 $opt,u,v$ 来记录，意思是 $u$ 对 $v$ 使用了 $opt$ 技能。  

我将今夜被杀称为**将死**，之前死亡称为**已死**。

先把显然的错误判掉。  
- $u,v$ 不在场上。包括这两人根本就不在 $1\sim n$ 范围内或已死。
- $u$ 已经使用过技能了。包括狼人和女巫今夜已经用过技能，猎人死后开过一次枪。
- $u$ 使用不了 $opt$ 技能。简单判断一下即可。

接下来进行操作。
- $opt=0,1,3$ 杀人操作。对象不能是自己，对象不能将死。猎人杀人必须自己将死，女巫和狼人杀人必须自己不将死。操作后对象状态变为将死。
- $opt=1,2$ 女巫操作。这个药不能已经已经被用过。操作后将这个药标记为用过。
- $opt=2$ 救人操作。对象必须将死，将死的女巫只能救自己。操作后对象不将死；如果对象是猎人，猎人技能视为未使用。

全部操作结束后判断一下，是否有猎人将死但是没用技能。  
如果是合法的，那么将死状态变为已死状态，女巫将用药状态变为已用药状态。  

以下是我自己代码实现的细节。  

$dead,todead,used$ 分别表示是否已死，是否将死，是否已使用技能。后两个每晚都要清空。  
$drug$ 利用状态压缩记录女巫技能使用情况。在二进制下一共四位，分别表示毒药是否用了，解药是否用了，毒药是否将用，解药是否将用。注意每晚要清空后两位。  
如果当晚操作是合法的，那么 $todead$ 要合并到 $dead$ 里面；$drug$ 的后两位要合并到前两位里面。  

时间复杂度为 $O(tm+tn)$。  

---
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int a[23];
bool dead[23];
bool used[23];
bool todead[23];
int drug[23];
void init(){
	memset(used,0,sizeof(used));
	memset(todead,0,sizeof(todead));
	for(int i=1;i<=n;i++)drug[i]&=3;
}

bool check(int id){
	return id>n||id<1||dead[id];
}
bool uskill(int opt,int id){
	if((opt==0&&id!=1)||((opt==1||opt==2)&&id!=4)||(opt==3&&id!=3))return 1;
	return 0;
} 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	while(t--){
		init();
		bool wrong=0;
		int m; cin>>m;
		for(int i=1;i<=m;i++){
			int opt,u,v; cin>>opt>>u>>v;
			if(check(u)||check(v)||used[u]||uskill(opt,a[u]))wrong=1;
			if(opt==0||opt==1||opt==3){
				if((opt==3)^todead[u])wrong=1;
				if(todead[v]||u==v)wrong=1;
				todead[v]=1;
			}
			if(opt==1||opt==2){
				if(drug[u]&(1<<opt-1))wrong=1;
				drug[u]|=(1<<opt+1);
			}
			if(opt==2){
				if(!todead[v])wrong=1;
				todead[v]=0;
				if(todead[u])wrong=1;
				if(a[v]==3)used[v]=0;
			}
			used[u]=1;
		}
		for(int i=1;i<=n;i++)
			if(a[i]==3&&todead[i]&&!used[i])wrong=1;
		if(wrong)cout<<"Wrong\n";
		else{
			int cnt=0;
			for(int i=1;i<=n;i++){
				drug[i]|=drug[i]>>2;
				cnt+=todead[i];
			}
			if(cnt){
				cout<<cnt<<' ';
				for(int i=1;i<=n;i++){
					if(todead[i])cout<<i<<' ';
					dead[i]&=todead[i];
				}
				cout<<'\n';
			}
			else cout<<"Safe\n";
		}
	}
	return 0;
}
```

---

## 作者：xuyifei0302 (赞：3)

首先，看到这道题的题面，我们根据直觉可以发现这是一道大模拟。但是，这里有一种十分麻烦的操作，就是有可能在那一晚，技能输入有误。

我们来分析一下技能输入有误的情况有那些：

1. 自己杀自己。
2. 使用与自己职业不同的技能。
3. 杀了早已死了的人~~反复鞭尸~~。
4. 同一晚发动了多次技能。
5. 编号有问题。
6. 女巫没有药还救人或杀人。
7. 女巫救了早已死透的人。
8. 女巫救了还活着的人。
9. 女巫处于将死状态，却不救自己，救别人，舍己为人。

对于这种要撤销的操作，我们把前一次操作前的状态储存下来，要撤销的话就直接使用上一次的状态。

然后模拟即可。

下面是代码环节：


```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, a[25];
bool last[25], jie[25], du[25], lajie[25], ladu[25], die[25], lang[25], women[25], lie[25];
set<int> st;
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i];
		if (a[i] == 4) {
			jie[i] = true;
			du[i] = true;
		}
	}
	for (int kkkk = 1; kkkk <= t; kkkk ++) {
		bool flag = true;
		memset(lang, false, sizeof(lang));
		memset(women, false, sizeof(women));
		memset(lie, false, sizeof(lie));
		st.clear();
		for (int i = 1; i <= n; i ++) {
			last[i] = die[i];
			lajie[i] = jie[i];
			ladu[i] = du[i];
		}
		int m;
		cin >> m;
		for (int i = 1; i <= m; i ++) {
			int op, id1, id2;
			cin >> op >> id1 >> id2;
			if (id1 > n || id1 < 1 || id2 > n || id2 < 1) {
				flag = false;
			}
			if (op == 0) {
				if (a[id1] != 1 || lang[id1] || die[id2] || die[id1] || id1 == id2) {
					flag = false;
				}
				die[id2] = true;
				lang[id1] = true;
				st.insert(id2);
			} else if (op == 1) {
				if (a[id1] != 4 || !du[id1] || die[id2] || women[id1] || id1 == id2 || die[id1]) {
					flag = false;
				}
				du[id1] = false;
				die[id2] = true;
				women[id1] = true;
				st.insert(id2);
			} else if (op == 2) {
				if (a[id1] != 4 || !jie[id1] || !die[id2] || women[id1] || last[id2] || last[id1]) {
					flag = false;
				}
				if (die[id1] && id1 != id2) {
					flag = false;
				}
				jie[id1] = false;
				die[id2] = false;
				women[id1] = true;
				lie[id2] = false;
				st.erase(id2);
			} else if (op == 3) {
				if (a[id1] != 3 || !die[id1] || id1 == id2 || die[id2] || last[id1] || lie[id1]) {
					flag = false;
				}
				die[id1] = true;
				die[id2] = true;
				lie[id1] = true;
				st.insert(id2);
			}
		}
		for (auto i : st) {
			if (a[i] == 3 && !lie[i]) {
				flag = false;
			}
		}
		if (!flag) {
			cout << "Wrong\n";
			for (int i = 1; i <= n; i ++) {
				die[i] = last[i];
				jie[i] = lajie[i];
				du[i] = ladu[i];
			}
			continue;
		}
		int len = st.size();
		if (len == 0) {
			cout << "Safe\n";
		} else {
			cout << len << " ";
			for (auto i : st) {
				cout << i << " ";
			}
			cout << "\n";
		}
	}
	return 0;
}
```

---

## 作者：anke2017 (赞：2)

逆天模拟题。赛时把机房人集体卡红温。

## 正题

### 人的状态

容易发现对一个人，有用的信息只有几个：

* 人物种类（`type`）
* 本回合有没有被杀（`kill`）
* 死了没有（不计本回合）（`died`）
* 当回合使用过技能没有（非平民）（`used`）
* 毒药、解药数量（女巫）（`used1,used2`）

我们用一个结构体维护一个人，这样就可以定义一系列关于人的操作。

请注意，**要先检查是否使用过技能，这个人死了没有（女巫解自己和猎人除外），以及这个角色和角色 id 是否合法**。

### 狼人杀人

我们可以定义一个函数，检查这个人可不可以被杀，如果可以就将其杀掉（除了用解药，都需要这个函数）。

容易发现，不合法的情况只有可能是这个人已经杀掉了。

### 猎人带走

判断是否本回合死亡后，视为狼人杀人处理即可。

### 女巫使用毒药

在检查过合法性（本回合是否使用过技能），当成狼人杀人处理即可。

### 女巫使用解药

判断以下几个东西：

* 这个人是否在当前回合死了（用 `kill` 判断）
* 本回合是否使用过技能
* 特别的，如果自己当回合死了，**必须**对自己使用解药。

若都合法，将这个人的死亡状态改为未死亡即可。**注意猎人若当回合被救活，不一定要开枪。**

### 回合结束

做以下几件事：

* 检查所有死去的猎人是否开枪。
* 对于狼人和女巫，更新状态，使得下回合可以再次使用技能。
* 如果在执行过程中，有不合法的情况，将预先备好的存档覆写到当前状态。

## 总代码

```cpp
#include<bits/stdc++.h>

using namespace std;

struct man {
	int type;
	bool used1,used2;//女巫的毒药，解药
	bool died,kill;
	bool used;
	inline bool kill_it() {//是否可以被杀，如果可以就杀
		if(died||kill)return 1;
		kill=1;
		return 0;
	}
	inline bool safe() {
		if(died||!kill/*||(type==3&&!used)*/)return 1;
		kill=0;
		if(type==3)used=0;
		return 0;
	}
	inline bool update(bool &is_death) {//is_death 返回这个人是否当回合死亡
		is_death=kill;
		if(kill&&!used&&type==3)return 1;
		died|=kill;
		if(type==1||type==4)used=0;
		kill=0;
		return 0;
	}
	inline bool used_help() {
		if(used2||type!=4||used) {
			return 1;
		}
		used=1;
		used2=1;
		return 0;
	}
	inline bool used_death() {
		if(!used1&&type==4&&!kill&&!used) {
			used=1;
			used1=1;
			return 0;
		}
		return 1;
	}
} men[24],tmp[24];//tmp 用于存档

int main() {
	ios::sync_with_stdio(false);cin.tie(0);
	//解同步流，还让 cout 拥有自己的缓存区，便于查看答案
	int t,n;
	cin>>t>>n;
	for(int i=1; i<=n; i++)cin>>men[i].type;
	for(int i=1; i<=t; i++) {
		for(int x=1; x<=n; x++)tmp[x]=men[x];
		bool type=0;
		int x;
		cin>>x;
		for(int t=1; t<=x; t++) {
//			for(int x=1; x<=n; x++)cerr<<men[x].used<<' ';
//			cerr<<'\n';
			int t1,t2,t3;
			cin>>t1>>t2>>t3;
			if(t2>n||t2<1||t3>n||t3<1)type=1;
			if(type)continue;
			switch(t1) {
				case 0:
					if(t2==t3||men[t2].died||men[t2].kill||men[t2].type!=1||men[t2].used||men[t3].kill_it()) {
						type=1;
						break;
					}
					men[t2].used=1;
					break;
				case 1:
					if(t2==t3||men[t2].used_death()||men[t3].kill_it()) {
						type=1;
						break;
					}
					break;
				case 2:
					if(men[t2].died||(men[t2].kill&&t2!=t3)||men[t2].used_help()||men[t3].safe()) {
						type=1;
						break;
					}
					break;
				case 3:
					if(men[t2].died||!men[t2].kill||men[t2].used||t3==t2||men[t2].type!=3||men[t3].kill_it()) {
						type=1;
						break;
					}
					men[t2].used=1;
					break;
				default:
					puts("Lucy AK IOI");
					return -1;
			}
		}
		bool the_tmp;
		vector<int> e;
		for(int t=1; t<=n; t++) {
			type|=men[t].update(the_tmp);
			if(the_tmp)e.push_back(t);
		}
		if(type)cout<<"Wrong\n";
		if(type)for(int x=1; x<=n; x++)men[x]=tmp[x];
		if(type)continue;
		if(!e.size())cout<<"Safe\n";
		else {
			cout<<e.size()<<' ';
			for(int i=0; i<e.size(); i++)cout<<e[i]<<' ';
			cout<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Walrus (赞：2)

upd on 2025/1/22：增加猎人多次开枪情况。

根据题意模拟即可，这里直接总结。

## 输入会有错误的点

- 发动技能的人与职业不对应。
- 一个人发动多次技能。
- **猎人死了没开枪。**
- 有人杀死了已经死了的人或自杀。
- 女巫救了活着的人。
- **女巫没药还发动技能。**
- **女巫不能救非今夜死亡的人。**
- 编号有误。

## 注意

- 本题可能有很多个女巫和很多个猎人。
- 女巫可以自救。
- 猎人开枪时必须自己处于死亡状态，无论是否后续有女巫救。
- 民其实没必要单独拿出来判。
- 猎人可以多次开枪，为了便于实现，女巫救猎人时认为被救的猎人没开过枪，即将 $vis$ 数组置为 $0$。

为了简化输入有错后的「撤销」操作考虑新开一个东西存然后 `memcpy`。

code 非常简单，个人认为和 CSP 那道差不多。

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define pb push_back
using namespace std;
const int N = 66;

int n, m, q, cnt, flg, a[N], b[N], B[N], vis[N];
int tag[N][4], ID;
//1狼 2民 3枪 4女 

bool check(int op, int x, int y) {
	if(!(1 <= x && x <= n) || !(1 <= y && y <= n)) return false;
	//assert(!(x == y && a[x]==4));
	if(a[x] == 4 && x == y && !vis[x] && B[x] && tag[x][3]) return B[x] = 0, vis[x] = 1, tag[x][3] = 0, true;//女巫自救
	else if(a[x] == 4 && x == y) return false;
	if(B[x] && a[x] != 3 || a[x] == 2 || vis[x]) return false;
	if(op == 0)  {//狼刀 
		if(a[x] != 1 || x == y || B[y]) return false;
		B[y] = vis[x] = 1;
	}	
	if(op == 1) {//女毒 
		if(a[x] != 4 || x == y || B[y] || !tag[x][2]) return false;
		B[y] = 1;
		tag[x][2] = 0;
		vis[x] = 1;
	}
	if(op == 2) {//女救 
		if(a[x] != 4 || b[y] || !B[y] || !tag[x][3]) return false;
		B[y] = 0;
		tag[x][3] = 0;
		vis[x] = 1;
		if(a[y] == 3) vis[y] = 0;//女巫救活猎人
	}
	if(op == 3) {//开枪 
		if(a[x] != 3 || !B[x] || B[y] || x == y) return false;
		B[y] = 1;
		vis[x] = 1;
	}
	return true;
}

signed main() {
	FASTIO
	
	cin >> q >> n;
	rep(i, 1, n) cin >> a[i], tag[i][0] = tag[i][1] = 1;
	while(q--) {
		++ID;
		memset(vis, 0, sizeof vis);
		memcpy(B, b, sizeof b);
		cnt = flg = 0;
		rep(i, 1, n) tag[i][2] = tag[i][0], tag[i][3] = tag[i][1];
		cin >> m;
		while(m--) {
			int op, x, y;
			cin >> op >> x >> y;
			if(!check(op, x, y)) {
//				cout << '!' << op << ' ' << x << ' ' << y << '\n';
				flg = 1;
				continue;
			}
//			rep(i, 1, n) cout << B[i] << ' ';
//			cout << '\n';
		}
		rep(i, 1, n) if(b[i] == 0 && B[i] == 1 && a[i] == 3 && !vis[i]) flg = 1;//判断是否有死了的猎人没开枪
		if(flg) cout << "Wrong\n";
		else {
			vector<int> p;
			rep(i, 1, n) if(b[i] == 0 && B[i] == 1) p.pb(i);
			cnt = p.size();
			if(!cnt) cout << "Safe\n";
			else {
				cout << cnt << ' ';
				for(auto x : p) cout << x << ' ';
				cout << '\n';
			}
			memcpy(b, B, sizeof b);
			rep(i, 1, n) tag[i][0] = tag[i][2], tag[i][1] = tag[i][3];
		}
	}
}
```

---

## 作者：heyZZZ (赞：2)

比较烦的中模拟。

## 注意事项：

1. 猎人死时必须带走一个人。
2. 女巫只有一份毒药和解药。
3. 在同一晚，同一位女巫只能做一次操作。
4. 如果错误**撤回当晚所有操作**。

## 操作：

我们维护十个数组：

-  $die$，所有死亡的记录。
- $nw1$，女巫的毒药操作。
- $nw2$，女巫的解药操作。
- $nd$，当晚死亡人数。
- $nnw$，当晚女巫的操作。
- $lr$，当晚狼人的操作。
- $er$，猎人带走的操作。
- $die1$，$die$ 的副本。
- $nw1\_1$，$nw1$ 的副本。
- $nw2\_1$，$nw2$ 的副本。

然后，几个 $\texttt {if}$ 判断一下：

1. 判断是否出界。
2. 判断是否死亡。
3. 如果是猎人或女巫，要判断是否当晚死亡。
4. 如果是狼人或女巫，要判断是否当晚用。

接着，记录死亡，是否用技能：

```cpp
if(op==0){ //狼人
    if(a[x]==1&&!die[x]&&!die[y]&&!lr[x]&&x<=n&&x&&y<=n&&y&&x!=y)
        die[y]=1,nd[y]=1,lr[x]=1,er[y]=0;
    else fg=1;}
if(op==1){ //毒药
    if(a[x]==4&&!die[x]&&!die[y]&&!nw1[x]&&!nnw[x]&&x<=n&&x&&y<=n&&y&&x!=y)
        die[y]=1,nw1[x]=1,nnw[x]=1,nd[y]=1,er[y]=0;
    else fg=1;} 
if(op==2){ //解药
    if(a[x]==4&&!nw2[x]&&((!die[x]||x==y)&&die[y])&&!nnw[x]&&x<=n&&x&&y<=n&&y&&nd[y])
        die[y]=0,nw2[x]=1,nd[y]=0,nnw[x]=1;
    else fg=1;}
if(op==3){ //猎人
    if(a[x]==3&&!er[x]&&nd[x]&&!die[y]&&x<=n&&x&&y<=n&&y&&x!=y)
        die[y]=1,nd[y]=1,er[x]=1;
    else fg=1;}
```

最后输出 $nd$ 就行了。

---

## 作者：showtodo (赞：1)

### 更新
- $$2025.01.21$$ 第一次通过题解 
- $$2025.01.23$$ 更新之前过不了 Hack 数据的题解
### 思路
很显然，这是一道不简单的模拟。   
以下提出几点个人认为需注意的点：    
1. 可能有多个相同的身份。
2. 每个狼人都能且只能开一刀，与现实的狼人杀不同。
3. 女巫可以自救。
4. 猎人被救活可以不开枪。
5. 猎人没被救活则必须开枪。
6. 当晚有错误的操作后必须将当晚的所有操作都撤回。
7. 猎人被刀开枪后被复活又被刀可以再开枪。  
8. 解药和毒药不可在同一晚使用，每个女巫只有两瓶不同的药。
### 代码
```
//我绝对不会告诉你们我交了7次题解
#include<cstdio>
const int N=25;
int t,n,m,op,id1,id2;
int a[N];//记录身份
int die[N];//记录此人是否死亡
int jy[N];//记录女巫是否有解药
int dy[N];//记录女巫是否有毒药
bool wr;//记录是否有错误操作 
bool wf[N];//记录狼是否开刀 
bool uy[N];//记录女巫是否用药 
bool qs[N];//记录猎人是否开枪 
int main(){
	scanf("%d%d",&t,&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	//以下为模拟部分 
	for(int i=1;i<=t;i++){
		wr=0;
		for(int j=1;j<=n;j++){
			uy[j]=qs[j]=wf[j]=0;//初始化 
		}
		scanf("%d",&m);
		while(m--){
			scanf("%d%d%d",&op,&id1,&id2);
			if(wr){continue;}
			if(id1>n||id1<1){wr=1;continue;}
			if(id2>n||id2<1){wr=1;continue;}
			if(a[id1]==2){wr=1;continue;}//如果是平民 
			if(!op){//狼开刀 
				if(die[id1]||die[id2]){wr=1;continue;}//双方是否没了 
				if(a[id1]!=1){wr=1;continue;}//如果不是狼 
				if(id1==id2){wr=1;continue;}//如果为自刀 
				if(wf[id1]){wr=1;continue;}//如果已经开过刀 
				//以下为标记
				wf[id1]=1;
				die[id2]=i;//第i日死亡
				qs[id2]=0;//切记不要像我一样把id1写成id2
				continue;
			}
			if(op==1){//女巫毒人 
				if(die[id1]||die[id2]||id1==id2){wr=1;continue;}//如果是自毒或双方中有人没了 
				if(a[id1]!=4){wr=1;continue;}//如果不是女巫 
				if(dy[id1]){wr=1;continue;}//如果用过毒药了 
				if(uy[id1]){wr=1;continue;}//本轮用过药了
                //以下为标记 
				uy[id1]=1;
				dy[id1]=i;//第i日用毒药
				die[id2]=i;
				qs[id2]=0;
				continue;
			}
			if(op==2){//女巫救人 
				if(a[id1]!=4){wr=1;continue;}//如果不是女巫 
				if(die[id1]&&id1!=id2){wr=1;continue;}//如果女巫没了且没自救 
				if(die[id2]!=i){wr=1;continue;}//如果人不是当晚没的
				if(uy[id1]||jy[id1]){wr=1;continue;}//用过药或没解药
				jy[id1]=i;//第i日用解药
                //以下为标记
				uy[id1]=1;
				die[id2]=qs[id2]=0;
				continue;
			}
			if(op==3){//猎人开枪
				if(a[id1]!=3){wr=1;continue;}//不是猎人
                if(qs[id1]){wr=1;continue;}//开过枪了
                if(id1==id2){wr=1;continue;}//猎人枪自己
				if(die[id1]!=i){wr=1;continue;}//猎人不是当晚没的
                if(die[id2]){wr=1;continue;}//对方已经没了
                //以下为标记
				qs[id1]=1;
				die[id2]=i;
                
				continue;
			}
			wr=1;//如果op不为0,1,2,3
		}
		int tot=0;
		for(int j=1;j<=n;j++){
			if(die[j]==i){
				tot++;
				if(a[j]==3&&!qs[j]){//猎人没了且没开枪
					wr=1;
					break;
				}
			}
		}
		if(wr){//错了
			for(int j=1;j<=n;j++){
                //以下为撤回
				if(die[j]==i) die[j]=0;
				if(dy[j]==i) dy[j]=0;
				if(jy[j]==i) jy[j]=0;
			}
			puts("Wrong");
			continue;
		}
		if(!tot){puts("Safe");continue;}//平安夜
        //以下为死人了的情况
		printf("%d ",tot);
		for(int j=1;j<=n;j++){
			if(die[j]==i) printf("%d ",j); 
		}
		putchar('\n');
	}
	return 0;
} 
```

---

## 作者：nightwatch.ryan (赞：1)

## 思路

这是一道细节多的大模拟。

因为没有什么思维含量，所以接下来我会讲解一些实现细节。

### 角色技能输入有误判定

- 操作 $0$。

 1. $id1$ 角色已死亡。
 2. $id2$ 角色已死亡
 3. $id1$ 角色不是狼人。
 4. $id1$ 角色当天晚上已经使用过技能（杀人），不能再次使用技能。
 5. $id1$ 自己杀自己。

- 操作 $1$。

 1. $id1$ 角色已死亡。

 2. $id2$ 角色已死亡。
 3. $id1$ 角色不是女巫。
 4. $id1$ 角色已经使用过毒药，不能再使用（每个女巫只能用一次毒药）。
 5. $id1$ 角色当天晚上已经使用过技能（毒药或解药），不能再次使用技能。
 6. $id1$ 自己用毒药毒自己。

- 操作 $2$。

 1. $id1$ 角色不是女巫。
 2. $id2$ 角色是活着的或者不是今天晚上死的。
 3. $id1$ 角色已经使用过解药，不能再使用（每个女巫只能用一次解药）。
 4. $id1$ 角色当天晚上已经使用过技能（毒药或解药），不能再次使用技能。
 5. $id1$ 角色已经死亡，且使用解药的对象 $id2$ 不是自己（$id1$）。

- 操作 $3$。

 1. $id1$ 角色未死亡。
 2. $id2$ 角色已经死亡。
 3. $id1$ 角色不是猎人。
 4. $id1$ 角色正处于死亡状态且已经使用过技能（带走另一个存活的玩家）。
 5. $id1$ 自己将自己带走。

### 其他细节

1. 女巫复活猎人时，要将猎人已经使用过技能的标记修改为未使用。
2. 记得将上一轮的游戏状态存档，一定不要忘记一开始要将存档的数组初始化。
3. 最后统计哪些玩家死亡，如果死亡的是猎人，一定要判断一些死亡的猎人是否使用过技能，没有使用过技能则角色技能输入有误。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define P(i, a, b) for(int i = a; i <= b; i++)
const int N = 25;
int t, n, m, T, _, $;
struct Player{
    int id, type, ti;
    bool use[N], si, du, jie; 
}p[N], lst[N];
signed main(){
    cin.tie(0)->sync_with_stdio(0);
    cin >> t >> n;
    P(i, 1, n) 
     cin >> p[i].type, p[i].id = i, p[i].ti = 0, lst[i] = p[i];
    P(i, 1, t){
        cin >> m;
        bool Wr = 0;
        vector<int> list;
        while(m --){
            cin >> T >> _ >> $;
            if(!(_ >= 1 && _ <= n) || !($ >= 1 && $ <= n) || p[_].type == 2) Wr = 1;
            if(!Wr)
             if(T == 0)
              if(p[_].use[i] || _ == $ || p[_].si || p[$].si || p[_].type != 1){ Wr = 1; continue; }
              else p[_].use[i] = 1, p[$].si = 1, p[$].ti = i;
             else if(T == 1)
              if(p[_].use[i] || p[_].du || _ == $ || p[_].si || p[$].si || p[_].type != 4){ Wr = 1; continue; }
              else p[_].use[i] = 1, p[_].du = 1, p[$].si = 1, p[$].ti = i;
             else if(T == 2)
              if(p[_].use[i] || p[_].jie || !p[$].si || p[$].ti != i || p[_].type != 4 || (_ != $ && p[_].si)){ Wr = 1; continue; }
               else{ p[_].jie = 1, p[_].use[i] = 1, p[$].si = 0, p[$].ti = 0;
                     if(p[$].type == 3) p[$].use[i] = 0; }
               else if(p[$].si || !p[_].si || p[_].ti != i || _ == $ || p[_].type != 3 || p[_].use[i]){ Wr = 1; continue; }
             else p[$].si = 1, p[$].ti = i, p[_].use[i] = 1;
        }
        P(j, 1, n)
         if(p[j].si && p[j].ti == i){
            list.push_back(j);
            if(p[j].type == 3 && !p[j].use[i]){ Wr = 1; break; }
         }
        if(Wr) cout << "Wrong\n";
        else if(!list.size()) cout << "Safe\n";
        else{ cout << list.size() << " ";
              for(int j = 0; j < list.size(); j ++) 
               cout << list[j] << " ";
              cout << "\n"; }
        if(Wr) P(j, 1, n) p[j] = lst[j];
        else P(j, 1, n) lst[j] = p[j];
    }
}
```

---

## 作者：haoyan1103 (赞：1)

超级大模拟！！

## 进入正题 ##

这道题细节很多，注意看以下几点：

- 对象不存在或已死亡。
- 狼人、女巫、猎人自己杀自己。
- 狼人、女巫在一个晚上使用多次技能。
- 平民使用技能。
- 猎人未杀死就使用技能或带走多人。

还有一些特殊的：

女巫使用解药时一定要判断玩家是否是今夜死亡的~~我被这个点坑了好久~~。

接下来模拟就行了。

还有多测一定要清空。

## 上代码 ##

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n;
int m;
int a[25];//狼人: 1 ;平民: 2 ;猎人: 3 ;女巫: 4
bool witch[25][2];
bool witch_k[25][2];//女巫的毒药和解药
bool vis[25];//狼人和女巫的技能
bool hunter_k[25];
bool hunter[25];//猎人的技能
bool del_k[25];
bool del[25];//标记死亡情况
int op[25],id1[25],id2[25];
set<int> d;//今夜死亡的玩家
bool pd(int id)
{
	for(auto i:d)
	{
		if(i==id)return 0;
	}
	return 1;
}//判断是否是今夜死亡
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>t>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	while(t--)
	{
		bool flag=0;
		d.clear();
		memset(vis,0,sizeof vis);
		for(int i=1;i<=n;i++)del[i]=del_k[i];
		for(int i=1;i<=n;i++)hunter[i]=hunter_k[i];
		for(int i=1;i<=n;i++)witch[i][0]=witch_k[i][0],witch[i][1]=witch_k[i][1];
        //初始化
		cin>>m;
		for(int i=1;i<=m;i++)cin>>op[i]>>id1[i]>>id2[i];
		for(int i=1;i<=m;i++)
		{
			if(a[id1[i]]==0 || a[id2[i]]==0){flag=1;break;}//错误直接退出
            //判断id合法
			if(a[id1[i]]==2){flag=1;break;}//平民使用技能
			if(op[i]==0)
			{
                //判断 1.狼人已死亡 2.杀死人 3.技能今晚已经用过 4.杀自己 5.非狼人杀人 
				if(del[id1[i]]==1 || del[id2[i]]==1 || vis[id1[i]]==1 || id1[i]==id2[i] || a[id1[i]]!=1){flag=1;break;}
				else
				{
					del[id2[i]]=1;
					d.insert(id2[i]);//标记杀死
					vis[id1[i]]=1;//标记已使用技能
				}
			}
			else if(op[i]==1)
			{
                // 1.女巫已死亡 2.杀死人 3.技能今晚已经用过 4.杀自己 5.非女巫毒人 
				if(del[id1[i]]==1 || del[id2[i]]==1 || witch[id1[i]][0]==1 || id1[i]==id2[i] || a[id1[i]]!=4 || vis[id1[i]]==1){flag=1;break;}
				else
				{
					del[id2[i]]=1;
					d.insert(id2[i]);
					witch[id1[i]][0]=1;//标记毒死
					vis[id1[i]]=1;//标记已使用技能
				}
			}
			else if(op[i]==2)
			{
				if(del[id2[i]]==0 || witch[id1[i]][1]==1 || a[id1[i]]!=4 || vis[id1[i]]==1){flag=1;break;}// 1.非女巫救人 2.解药用完了 3.已使用技能
				else if(del[id1[i]]==1 && (id1[i]!=id2[i] || pd(id1[i]))){flag=1;break;}// 自己死了不救自己
				else if(pd(id2[i])){flag=1;break;}//不是当晚死亡
				else
				{
					del[id2[i]]=0;//标记救活
					witch[id1[i]][1]=1;
					vis[id1[i]]=1;//标记已使用技能
					if(a[id2[i]]==3)hunter[id2[i]]=0;
					d.erase(id2[i]);
				}
			}
			else if(op[i]==3)
			{
                // 1.猎人未死 2.带走多人 3.带走自己 4.非猎人带走人
				if(del[id1[i]]==0 || hunter[id1[i]]==1 || del[id2[i]]==1 || id1[i]==id2[i] || a[id1[i]]!=3 || pd(id1[i])){flag=1;break;}
				else
				{
					del[id2[i]]=1;
					d.insert(id2[i]);//标记带走
					hunter[id1[i]]=1;//标记已使用技能
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(del[i]==1 && a[i]==3 && hunter[i]==0){flag=1;break;}
		}//判断猎人已死但没带走人
		if(flag==1)
		{
			cout<<"Wrong\n";
			continue;
		}//不合法
		for(int i=1;i<=n;i++)del_k[i]=del[i];
		for(int i=1;i<=n;i++)hunter_k[i]=hunter[i];
		for(int i=1;i<=n;i++)witch_k[i][0]=witch[i][0],witch_k[i][1]=witch[i][1];
        //合法，更新数据
		if(d.size()<=0)
		{
			cout<<"Safe\n";
			continue;
		}//平安夜
		cout<<d.size()<<" ";
		for(auto i:d)cout<<i<<" ";
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：MnZnOIer (赞：0)

### 前言
很恶心的模拟题，虽然没打这场比赛，但是赛后也没有很轻松的 A 掉。

### 细节处理
1. 一定要读完再做操作；~~（虽然我没读完就操作也有 20 pts）~~

2. 猎人死时**必须**带走一个人，否则就有错误；

3. 女巫只有**一份**毒药和解药；

4. 女巫只能就这个晚上死的人；

5. **倒序**撤回操作；

6. 猎人被杀了，带走别人，被救活，被杀死，再带走别人是合法的。

写道模拟题能写出这么问题，可见我有多菜。

### 代码部分
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 25;
int t, n, f[N], d[N], op[N], m, a[N], b[N], fl = 0;
bool fd[N], fz[N], hp[N], v[N], vv[N];
/*
f 表示身份；
d 表示死亡时间；
fd 表示女巫是否用过毒；
fz 表示女巫是否用过解药；
hp 表示是否活着；
v 表示是否用过技能；
vv 表示前一个夜晚的死亡情况。
*/
signed main ()
{
    ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
    cin >> t >> n;
    for (int i = 1; i <= n; ++ i)
    {
        cin >> f[i];
        hp[i] = 1;
    }
    while (t --)
    {
        fl = 0;
        vector <int> dd[N];
        for (int i = 1; i <= n; ++ i)vv[i] = hp[i], v[i] = 0, dd[i].clear ();
        cin >> m;
        for (int i = 1; i <= m; ++ i)cin >> op[i] >> a[i] >> b[i];
        for (int i = 1; i <= m; ++ i)
        {
            if (a[i] < 1 || a[i] > n || b[i] < 1 || b[i] > n || f[a[i]] == 2)fl = i;
            if (op[i] == 0 && (v[a[i]] || b[i] == a[i] || ! hp[b[i]] || f[a[i]] ^ 1 || ! hp[a[i]]))fl = i;
            if (op[i] == 1 && (v[a[i]] || b[i] == a[i] || fd[a[i]] || ! hp[b[i]] || f[a[i]] ^ 4 || ! hp[a[i]]))fl = i;
            if (op[i] == 2 && (v[a[i]] || hp[b[i]] || fz[a[i]] || f[a[i]] ^ 4 || d[b[i]] ^ t || (! hp[a[i]] && b[i] ^ a[i])))fl = i;
            if (op[i] == 3 && (hp[a[i]] || v[a[i]] || b[i] == a[i] || ! hp[b[i]] || f[a[i]] ^ 3))fl = i;
            if (fl)break;
            v[a[i]] = 1;
            if (op[i] == 0)
            {
                hp[b[i]] = 0;
                d[b[i]] = t;
                if (f[b[i]] == 3)v[b[i]] = 0;
            }
            if (op[i] == 1)
            {
                fd[a[i]] = 1;
                hp[b[i]] = 0;
                d[b[i]] = t;
                if (f[b[i]] == 3)v[b[i]] = 0;
            }
            if (op[i] == 2)
            {
                fz[a[i]] = 1;
                hp[b[i]] = 1;
                d[b[i]] = 0;
            }
            if (op[i] == 3)
            {
                hp[b[i]] = 0;
                d[b[i]] = t;
            }
        }
        for (int i = 1; i <= n; ++ i)if (hp[i] - vv[i] && f[i] == 3 && ! v[i])fl = n + 1;
        if (fl)
        {
            cout << "Wrong\n";
            for (int i = fl - 1; i; -- i)
            {
                if (op[i] == 0)
                {
                    hp[b[i]] = 1;
                    d[b[i]] = 0;
                }
                if (op[i] == 1)
                {
                    fd[a[i]] = 0;
                    hp[b[i]] = 1;
                    d[b[i]] = 0;
                }
                if (op[i] == 2)
                {
                    fz[a[i]] = 0;
                    hp[b[i]] = 0;
                    d[b[i]] = 0;
                }
                if (op[i] == 3)
                {
                    hp[b[i]] = 1;
                    d[b[i]] = 0;
                }
            }
            continue;
        }
        int c = 0, ans[N];
        for (int i = 1; i <= n; ++ i)if (hp[i] - vv[i])ans[++ c] = i;
        if (c)cout << c << ' ';
        else cout << "Safe";
        for (int i = 1; i <= c; ++ i)cout << ans[i] << ' ';
        cout << '\n';
    }
    return 0;
}
```

完结撒花！

---

## 作者：lzx111218 (赞：0)

# P11601 『Fwb』狼人の杀戮
[题目传送门](https://www.luogu.com.cn/problem/P11601)
## 思路
弱化版的猪国杀。

**角色要点：**

 - 狼人： 可以杀死一个非自己的玩家。
 - 平民： 啥也干不了。
 - 猎人： 如果自己被杀死且没有被救活，则必须带走一名非自己的玩家。
 - 女巫： 可以毒死一名玩家，或者用解药救活一名玩家。但每个女巫只能使用一次毒药和解药。

**坑点**：

- 女巫不能对自己使用技能。
- 玩家技能不能重复使用。
- 猎人在没有被杀死时不能使用技能。
- 如果猎人被救活，猎人不再拥有带走能力。

~~多 WA 几次就知道了。~~

**维护玩家的状态**
- $0$ 表示玩家存活。
- $1$ 表示玩家死亡。
- $2$ 表示玩家被毒死或被狼人杀死。

**技能使用顺序**：要按照顺序逐个操作，并验证每次操作的合法性。

**死亡结果处理：**

- 若不合法则跳过该操作，输出 `Wrong`。

- 若是平安夜输出 `Safe`，若有人死了就输出死亡玩家的编号即可。

**时间复杂度为** $O(t(m + n))$。

**空间复杂度为** $O(n)$。
### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int MAX_N = 114; // 臭

int t, n, x[MAX_N], status[MAX_N], transition[MAX_N][2], in_progress[MAX_N];
int temp_transition[MAX_N][2], temp_status[MAX_N];

void reset() {
    for (int i = 1; i <= n; i++) {
        transition[i][0] = temp_transition[i][0];
        transition[i][1] = temp_transition[i][1];
        status[i] = temp_status[i];
    }
}

signed main() {
    // 读入测试数据的个数 t 和玩家人数 n
    scanf("%lld %lld", &t, &n);
    // 读入每个玩家的角色类型
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &x[i]);
    }
    
    while (t--) {
        // 每次测试前初始化临时数据
        for (int i = 1; i <= n; i++) {
            temp_transition[i][0] = transition[i][0];
            temp_transition[i][1] = transition[i][1];
            temp_status[i] = status[i];
            in_progress[i] = 0;
        }
        
        int m, operation, id1, id2;
        scanf("%lld", &m);  // 读取当前夜晚的事件数量
        bool error_flag = false;  // 错误标志
        
        for (int current = 1; current <= m; current++) {
            // 逐个处理事件
            scanf("%lld %lld %lld", &operation, &id1, &id2);
            
            // 检查玩家编号是否合法
            if (id2 < 1 || id2 > n || id1 < 1 || id1 > n || x[id1] == 2 || in_progress[id1] || status[id1] == 1) {
                error_flag = true;
                continue;
            }
            
            in_progress[id1] = 1;  // 标记该玩家技能已经使用
            
            switch (operation) {
                case 0: 
                    // 狼人技能：狼人杀死目标
                    if (x[id1] != 1 || id1 == id2 || status[id2] != 0) {
                        error_flag = true;
                        continue;
                    }
                    status[id2] = 2;  // 目标玩家死亡
                    break;
                case 1: 
                    // 女巫技能：毒死目标
                    if (x[id1] != 4 || status[id2] != 0 || transition[id1][1] || id1 == id2 || status[id1] != 0) {
                        error_flag = true;
                        continue;
                    }
                    transition[id1][1] = 1;
                    status[id2] = 2;  // 目标玩家被毒死
                    break;
                case 2: 
                    // 女巫技能：解救目标
                    if (x[id1] != 4 || status[id2] != 2 || transition[id1][0] || (status[id1] == 2 && id1 != id2)) {
                        error_flag = true;
                        continue;
                    }
                    if (x[id2] == 3) in_progress[id2] = 0;
                    transition[id1][0] = 1;
                    status[id2] = 0;  // 目标玩家被救活
                    break;
                case 3: 
                    // 猎人技能：带走目标
                    if (x[id1] != 3 || status[id1] != 2 || status[id2] != 0 || id1 == id2) {
                        error_flag = true;
                        continue;
                    }
                    status[id2] = 2;  // 被猎人带走的目标死亡
                    break;
                default:
                    error_flag = true;
            }
        }
        
        // 检查猎人是否能继续带走目标
        for (int i = 1; i <= n; i++) {
            if (x[i] == 3 && status[i] == 2 && !in_progress[i]) {
                error_flag = true;
            }
        }
        
        if (error_flag) {
            puts("Wrong");
            reset();
            continue;
        }
        
        // 统计死亡玩家数量
        int count = 0;
        for (int i = 1; i <= n; i++) {
            if (status[i] == 2) count++;
        }
        
        if (!count) {
            puts("Safe");
            continue;
        }
        
        // 输出死亡玩家列表
        printf("%lld ", count);
        for (int i = 1; i <= n; i++) {
            if (status[i] == 2) {
                printf("%lld ", i);
                status[i] = 1;  // 玩家死亡
            }
        }
        puts("");
    }
    
    return 0;
}

```

---


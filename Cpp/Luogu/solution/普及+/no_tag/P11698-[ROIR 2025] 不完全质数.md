# [ROIR 2025] 不完全质数

## 题目背景

翻译自 [ROIR 2025 D1T2](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。$%标题解析 by GPT：在俄语中，**"простые числа"**（质数）是由**"простой"**（简单的、普通的）和**"число"**（数字、数）构成的短语，表示“质数”这一数学概念。当在 **"простые"** 后加上 **"-оват-"** 后缀（即变为 **"простоватые"**），这个词的含义就发生了变化。**"-оват-"** 是俄语中的一个后缀，用于形容词或名词，通常会带有一种轻微的、不完全的含义，或者带有一种贬义或降低的语气。**"-оват-"** 后缀通常表示某物处于某种状态，但并不是完全符合该状态或标准，带有一些“接近但不完全”的意味。它强调了某种特性，但并不完全具备。例如：- **"молодой"**（年轻的）变成 **"молодоватый"**（有点年轻、不完全年轻）。- **"сильный"**（强的）变成 **"сильноватый"**（有点强，但不完全强）。在这种情况下，**"простоватые"** 由 **"простой"**（简单的）加上 **"-оват-"** 后缀构成，表示“有点简单的”或者“接近简单的”，即“简单但不完全是质数”的意思。所以，**"простоватые числа"** 指的是“接近质数的数字”，即这些数字的数字乘积是质数，但并不完全符合质数的定义。$

## 题目描述

如果一个数字在十进制表示下的各位数字之积是一个质数，则称这个数为“不完全质数”。例如，$12$ 是一个不完全质数，因为 $1 \times 2 = 2$ 是质数；但是 $29$ 不是不完全质数，因为 $2 \times 9 = 18$ 不是质数。

现在，你需要计算出 $[l,r]$ 的不完全质数的数量。

## 说明/提示

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

| 子任务 | 分数  | 特殊性质 |
|:------------:|:-------:|:----------:|
| $1  $        |$ 19  $  | $1 \leq l \leq r \leq 10^6$ | 第一错误 |
| $2  $        | $26  $  | $1 \leq l \leq r \leq 10^{18}$ | 第一错误 |
| $3  $        | $12  $  | $l = 1, r = 10^k$，其中 $1 \leq k \leq 10^5$ | 第一错误 |
| $4 $         | $18 $   | $1 \leq l \leq r \leq 10^{1000}$ | 第一、二错误 |
| $5$          | $25$    | 无 | - |

## 样例 #1

### 输入

```
42
179```

### 输出

```
10```

# 题解

## 作者：gesong1234 (赞：7)

题目传送门：[P11698 [ROIR 2025] 不完全质数](https://www.luogu.com.cn/problem/P11698)。
# 思路
使用类似前缀和的思想，将求 $[l,r]$  不完全质数的个数，转化成 $[1,r]$ 不完全质数的个数减去 $[1,l-1]$ 不完全质数的个数。

我们考虑不完全质数的定义是十进制各位数字之积为质数，而质数的定义为除 $1$ 和本身没有其他因数的数，由此我们可以推得，这个十进制数有且仅有一位是质数，其余的位置都是一。

我们可以考虑数位 dp 了，设 $f_{i,limit,zs,qd}$ 表示现在处理到了第 $i$ 位，这一位取数是否限制，是否有一个质数出现，之前的数是否都是 $0$。

转移按照 $zs,qd$ 等取值分类讨论即可。

# 代码
在这里实现的是用记忆化搜索来做的数位 dp。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int b[N],c[N],a[N],d[N],n;
inline int read(){
	char c=getchar();
	int f=1,ans=0;
	while(c<48||c>57) f=(c==45?f=-1:1),c=getchar();
	while(c>=48&&c<=57) ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();
	return ans*f;
}
int f[N][2][2][2];
inline bool check(int x){
	return x==2||x==3||x==5||x==7;
}
int dfs(int i,bool limit,bool zs,bool qd){
	if (i==n+1) return zs;
	if (~f[i][limit][zs][qd]) return f[i][limit][zs][qd];
	int now=limit?9:a[i];
	if (zs){
		if (now==0) return f[i][limit][zs][qd]=0;
		return f[i][limit][zs][qd]=dfs(i+1,limit||(1<now),zs,qd);
	} 
	else{
		if (qd){
			int ans=0;
			for (int j=0;j<=now;j++){
				if (j==0) ans+=dfs(i+1,limit||(j<now),zs,1);
				else if (j==1) ans+=dfs(i+1,limit||(j<now),zs,0);
				else if (check(j)) ans+=dfs(i+1,limit||(j<now),1,0);
			}
			return f[i][limit][zs][qd]=ans;	
		}
		else{
			int ans=0;
			for (int j=0;j<=now;j++){
				if (j==1) ans+=dfs(i+1,limit||(j<now),zs,0);
				else if (check(j)) ans+=dfs(i+1,limit||(j<now),1,0);
			}
			return f[i][limit][zs][qd]=ans;	
		}
	}
}
inline int calc(int n){
	::n=n;
	memset(f,-1,sizeof(f));
	return dfs(1,0,0,1);
}
main(){//由于数据范围很大，需要使用高精减
	string x;
	cin>>x;
	b[0]=x.size();
	for (int i=0;i<x.size();i++) b[i+1]=x[i]-48;
	cin>>x;
	c[0]=x.size();
	for (int i=0;i<x.size();i++) c[i+1]=x[i]-48;
	d[b[0]]=1;
	for (int i=b[0];i>0;i--){
		if (b[i]<d[i]) b[i]+=10,b[i-1]--;
		b[i]-=d[i];
	}
	for (int i=1;i<=b[0];i++) a[i]=b[i];
	int xx=calc(b[0]);
	for (int i=1;i<=c[0];i++) a[i]=c[i];
    cout <<calc(c[0])-xx;
	return 0;
}
```

---

## 作者：matrixPower (赞：5)

[传送门](https://www.luogu.com.cn/problem/P11698)

## 声明：

本题我的代码从 [kunkunge](/user/744989) 的 0 分代码调试而来，使用已经经得他本人同意。

****

非常好的数位 DP 题。

最近正好学了数位 DP，直接将这一道题拿来练手了。

从题目中可以得知，质数 $x$ 只能拆成 $1 \times x$，所以不完全质数的各位只能由 $1,2,3,5,7$ 构成，且质数最终只能出现一次。

****

输入是经典的 $l\sim r$，由于此题 $l$ 很大，无法快速算出 $l-1$（除非你想写高精），所以最终表达式是这样：$f(r)-f(l)+\operatorname{check(l)}$。其中 $\operatorname{check(l)}$ 表示 $l$ 是否为不完全质数，是则答案为 $1$，不是则答案为 $0$。

$\operatorname{check(l)}$ 很好计算，在此就不过多赘述。

接下来看到 $f(x)$ 如何计算。

考虑到求 $1 \sim x$ 中的个数与 $x$ 非常巨大，可以使用数位 DP 加记忆化。

而我写数位一般使用递归做法。定义递归函数 `dfs`，传 $p,lim,vis,st$ 这四个参数，分别表示现在算到了第 $p$ 位、$lim=1$ 则前面所有位置都顶着上限、$vis=1$ 则表示前面已经用过唯一的指数了，后面只能填 $1$ 了、$st=1$ 表示前面的位置都填的 $0$，即在前导零范围内。

消化了这几个参数后，就可以写题了。

在注意递归边界情况（**严格**按照我的顺序来写）：

1. $vis=1$，则质数已经用过了，后面的位置只能为 $1$。如果此时顶着上线，即 $lim=1$，我们需判断后面所有的位置能否都写下 $1$（比如说 $x=120,lim=1,vis=1$ 就不行）。

2. $p=-1$，由于数位已经用完了还没有用上质数，直接返回 $0$。

3. 如果 $dp_{p,vis} \ne -1$，则说明这次已经查找过了，直接返回这个值即可。

但注意到第一个条件中每次判断时写循环判断是否能全部写下 $1$，每次到这里都要循环，时间复杂度太过巨大，可以开数组 $b$，$b_i$ 表示 $i \sim 0$ 这几位能否存下 $1$。

具体不懂的可以参照代码。

```cpp
#include <bits/stdc++.h>
#define int long long int
using namespace std;
int dp[100005][2],b[100005];
int f[] = {0, 1, 2, 3, 5, 7};
vector<int> num;
int dfs(int p, bool lim, bool vis, bool st)
{
	if(vis) 
	{
		if(p==-1) return 1;
		return !lim || b[p];
	}
    if (p == -1) return 0;
    if (!lim && ~dp[p][vis] && !st)
        return dp[p][vis];
    int up = lim ? num[p] : 9;
    int ans = 0;
    for (auto i : f)
    {
        if (i > up || (vis && i > 1)) break;
        if (st && !i)
        {
            ans += dfs(p - 1, (lim && (i == up)), 0, 1);
		}
        else
        {
            if (i == 0)	
                continue;
            ans += dfs(p - 1, (lim && (i == up)), i != 1, 0);
        }
    }
    if (!lim && !st)
        dp[p][vis] = ans;
    return ans;
}
int get(string s)
{
    reverse(s.begin(), s.end());
    num.clear();
    for (auto i : s)
        num.push_back(i - '0');
    b[0]=(num[0]>=1);
    for(int i=1;i<num.size();i++) 
	{
    	if(num[i]>=2) b[i]=1;
		else if(num[i]==1) b[i]=b[i-1]; 
		else b[i]=0;
	}
    return dfs(num.size() - 1, 1, 0, 1);
}
int check(string s)
{
    int flag = 0;
    for (auto i : s)
    {
        if(i!='1')
        {
        	if(i=='0' || i=='4' || i=='6' || i=='8' || i=='9') return 0;
        	if(flag) return 0;
        	flag=1;
		}
    }
    return flag;
}
signed main()
{
//	freopen("1.in","r",stdin);
    memset(dp, -1, sizeof(dp));
    string l, r;
    cin >> l >> r;
	int sum1=get(r);
	int sum2=get(l);
    cout << sum1 - sum2 + check(l);
    return 0;
}
```

---

## 作者：canwen (赞：5)

数位 dp 还在学习中，所以我硬模拟。

众所周知，这道题模拟起来想着容易，实现困难，而且有时候不知道为啥莫名其妙 WA。

这里给出一种思考方式。

首先，由质数的定义，**非完全质数**的乘积只有四种情况，即 $2,3,5,7$。而且都要满足一位是 $2,3,5,7$ 中的任一个，其他位都是 $1$ 的状态。

那我们思考 $x$ 位数（$10^{n-1}\sim10^{n}-1$）的贡献，**每一位**都可以填 $2,3,5,7$，然后另其他位都是 $1$，贡献为 $4x$。

计 $l,r$ 长度分别为 $l1,r1$，提前将 $l,r$ 转化成字符串。

所以我们可以先统计 $l1+1\sim r1-1$ 位数的贡献。

接下来分开讨论两种情况，一种是 $l1<r1$ 的情况，一种是 $l1=r1$ 的情况。

对于第一种情况，设合法的非完全质数为 $y$，**则满足 $y\ge l$ 或 $y\le r$**。

考虑 $y\ge l$ 如何统计，遍历 $l$，设当前位置为 $i$。如果当前 $l_i = 0$，**则对于 $\forall j>i$**，位置 $j$ 上都可以放 $2,3,5,7$，产生 $4$ 的恭喜；相反，如果 $l_i>1$ 且 $\forall l_j=1(j<i)$，那么恭喜你，**接下来**都无法找到可以放 $2,3,5,7$ 的位置。

如果你看懂了上面那段话，跳过这段，这边再举例子解释下。例如 $l = 114514$ 时，虽然一二位都是 $1$，但是到了第 $3$ 位 $4$ 时，$l_i > 1$，假如下一个数要求是 $111211$ 时，由于 $4$ 的阻拦，无法实现，大家可以自己举例子帮助理解。

回到上上面，我们还没考虑如果当前位大于 $1$ 时的贡献（这里是在上上面遍历里的限制的条件下的），有四种可能对吧，那我们遍历每一种可能 $j$，**如果 $j>l_i$，显然会符合**，自增答案；如果 $j =l_i$ 呢？则要看这一位之后有没有**一位为 $0$ 且该位出现在有比 $1$ 大的位数前**或者**后面的位数都为 $0$**，显然这部分可以线性预处理出来。

如何统计 $y\le r$ 的部分，同样的思路，不同的预处理，如果你看懂了 $y \ge l$ 的部分，那么一定会实现 $y\le r$ 吧，这里不再赘述。

现在来讨论第二种情况，即 $l1=r1$ 时的贡献如何计算。

我们可以看成是第一种情况的变式，用上面的方法分别统计 $l$ 到用 $l1$ 位能表示的最大数字能产生的贡献（$y\ge l$），以及 $r$ 到用 $r1$ 位能表示的最大数字能产生的贡献，用前者相减后者即可。

等等，还没完，因为假如 $r$ 是一个非完全质数，那么会被误减，导致答案少了 $1$，判断一下即可 AC 惹！


~~感觉本题难度为绿十分合乎情理，其实是我太菜了。~~
## Code
我的实现方式如下。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar();return k*kk;}
void out(int a){if(a<0) putchar('-'),a=-a;if(a>9) out(a/10);putchar('0'+a%10);}
const int N = 100000 + 5;
int l[N],r[N],l1,r1,ans;
bool f1[N],f2[N];
void _init(){
	string a,b;
	cin>>a>>b;
	l1=a.size(),r1=b.size();
	_rep(i,1,l1) l[i]=a[i-1]-'0';
	_rep(i,1,r1) r[i]=b[i-1]-'0';
}
int can[] = {2,3,5,7},flag;
void tongji(){
	// l ~ l的位数能的所有数字
	f1[l1+1] = 1;
	_rrep(i,l1,1){
		if(l[i] == 0) f1[i] = 1;
		else if(l[i] == 1) f1[i] = f1[i+1];
		else f1[i] = 0;
	}
	flag = 0;
	_rep(i,1,l1){
		if(flag == 1) ans += 4;
		else{
			for(int j:can){
				if(j > l[i]) ans++;
				else if(j == l[i] && f1[i+1]) ans++;
			}
		}
		if(flag == 0 && l[i] > 1) break;
		if(l[i] == 0) flag = 1;
	} 
}
void solve1(){
	tongji();
	flag = 0;
	f2[r1 + 1] = 1;
	_rrep(i,r1,1){
		if(r[i] > 1) f2[i] = 1;
		else if(r[i] == 0) f2[i] = 0;
		else f2[i] = f2[i+1];
	}
	_rep(i,1,r1){
		if(r[i]==0&&!flag) break;
		if(flag == 1) ans += 4;
		else{
			for(int j:can){
				if(j<r[i]||j==r[i]&&f2[i+1]) ans++;
			}
		}
		if(r[i]>1) flag = 1;
	}
}
void solve2(){
	tongji();
	int ans1 = 0;
	f1[r1+1] = 1;
	_rrep(i,r1,1){
		if(r[i] == 0) f1[i] = 1;
		else if(r[i] == 1) f1[i] = f1[i+1];
		else f1[i] = 0;
	}
	flag = 0;
	_rep(i,1,r1){
		if(flag == 1) ans1 += 4;
		else{
			for(int j:can){
				if(j > r[i]) ans1++;
				else if(j == r[i] && f1[i+1]) ans1++;
			}
		}
		if(flag == 0 && r[i] > 1) break;
		if(r[i] == 0) flag = 1;
	}
	int tmp = 1;
	_rep(i,1,r1){
		tmp = tmp * r[i];
		if(!(tmp == 2 || tmp == 3 || tmp == 5 || tmp == 7) && tmp != 1) break;
	}
	if(tmp == 2 || tmp == 3 || tmp == 5 || tmp == 7) ans1--;
	ans -= ans1;
}
signed main(){
	_init();
	_rep(i,l1+1,r1-1) ans += 4*i;
	if(l1 != r1) solve1();
	else solve2();
	cout << ans << endl;
	return 0;
}
```

---

## 作者：JYX0924 (赞：2)

这是一道计数题。

对于 $[1,n]$ 的 $n$ 个数，我们可以枚举数的位数，因为小于 $10$ 的质数只有 $2,3,5,7$，所以对于长度 $len$，简单质数只有 $4\times len$ 种。因此，对于每个 $i < len_{n}$，对答案都有 $4\times i$ 的贡献。而对于 $len_{n}$，直接搜索即可。

下面是我的 AC 代码。


```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll len;
string t1,t2,s;
char num[4]={'2','3','5','7'};
ll dfs(ll now,ll flag)
{
	if(now==len) return 0;
	if(flag==1) return 4*(len-now);
	if(s[now]=='1') return dfs(now+1,0);
	if(s[now]=='0') return 0;
	ll ret=0; for(int i=0;i<4;i++) if(s[now]>num[i]) ret++;
	for(int i=0;i<4;i++)
	{
		if(s[now]==num[i])
		{
			ll tt=now+1,x=0;
			while(tt<len&&s[tt]<='1') {if(s[tt]=='0') {x=1; break;} tt++;}
			if(!x) ret++;
			break;
		}
	}
	ret+=dfs(now+1,1); return ret;
}
ll cal(string xx)
{
	if(xx=="0") return 0;
	ll flag=0; if(xx[0]=='0') flag++;
	s=xx; len=s.size(); ll ret=0;
	for(int i=1;i<len-flag;i++) ret+=4*i;
	ret+=dfs(flag,0); return ret;
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>t1>>t2; ll len=t1.size(); len--; while(t1[len]=='0') {t1[len]='9'; len--;} t1[len]--;
	cout<<cal(t2)-cal(t1);
	return 0;
}
```
谢谢大家！！！

---

## 作者：MoonCake2011 (赞：2)

根据质数的定义，发现不完全质数一定且只需要满足数位上为一堆 $1$ 和一个质数。

发现 $1$ 到 $10$ 的质数只有 $2,3,5,7$ 四个数。

所以我们可以直接枚举有质数的那一位并枚举是哪一个质数。

将答案表示为 $A(l,r)$，满足 $A(l,r)=A(1,r)-A(1,l-1)$。

那我们只用求 $A(1,x)$ 就行了。

下面可能我有点小题大做，我们用树状数组或者线段树维护那个数的前缀哈希值。

然后可以哈希与树状数组或者线段树与二分（注意不是树状数组倍增线段树二分，它们是分开的）打配合求出 $x$ 与我们枚举的那个数的最长公共前缀，再比较 $x$ 与那个数的下一位，就可以比出 $x$ 与那个数的大小关系来排除一些在范围外的答案。

这里注意需要先比较数字位数再进行字符串比较。

然后就做完了。

---

## 作者：lHRTl (赞：2)

注意到**一个数是否为不完全质数只与这个数的各位数字有关**，故考虑数位 DP。

首先考虑如何构造一个不完全质数，根据质数定义，可以得到一个显而易见的结论：一个不完全质数的各位数字上有且仅有一个质数，其余数位上的数字只能为 $$1$$。

接下来便是一个比较板的数位 DP。

最后注意特判 $$l$$ 是否是不完全质数。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
string l,r,t;
long long z;
int x[6] = {0,1,2,3,5,7};
long long s[100001][2][2][6];
bool k,v;
long long f(int l,bool fl,bool fp,bool fo,int fz){
	if(l == -1){
		return (fl and fz);
	}
	if(!fp and s[l][fl][fo][fz] != -1){
		return s[l][fl][fo][fz];
	}
	int fm = fp ? (int)(t[l] - '0') : 9;
	long long zt = 0;
	for(int i = 0;i <= 5;i++){
		if(x[i] > fm){
			break;
		}
		if(fl and !x[i]){
			continue;
		}
		if(fz and x[i] > 1){
			break;
		}
 		zt += f(l - 1,fl | (x[i]),fp and x[i] == fm,fo | (x[i] == 1),fz ? fz : (x[i] != 1) ? i : 0);
	}
	s[l][fl][fo][fz] = zt;
	return zt;
}
long long V(string h){
	memset(s,-1,sizeof(s));
	t = h;
	reverse(t.begin(),t.end());
	return f(t.size() - 1,false,true,false,0);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> l >> r;
	z = (V(r) - V(l));
	k = true;
	for(int i = 0;i < l.size();i++){
		if(l[i] == '0'){
			k = false;
			break;
		}
		else if(l[i] != '1'){
			if(v){
				k = false;
				break;
			}
			else if(l[i] == '2' or l[i] == '3' or l[i] == '5' or l[i] == '7'){
				v = true;
			}
			else{
				k = false;
				break;
			}
		}
	}
	z += (k and v);
	cout << z;
	return 0;
}
```

---

## 作者：wuming_z (赞：1)

显然如果一个数是不完全质数，除一位为质数外其他为均为 $1$，而个位质数只有 $4$ 个，所以我们可以非常轻松地想到构造的思路。  
但因为长度范围为 $10^5$，$O(n^3)$  的构造做法只能拿到部分分。
这时我们可以发现，长度在 $l,r$ 之间的不完全质数必定合法，而这些质数的数量可以由 $size \times 4$ 得出。  
所以我们只需要首先算出长度在 $l,r$ 之间的所有不完全质数，加上所有长度为 $l,r$ 的合法质数后即为正确答案。  
而又由于比较函数自带一层 $O(n)$，所以求第一个与最后一个合法的不完全质数的操作还是会被卡 $O(n^2)$。  
**这时我们再次想到：除一位为质数外其他位均为  $1$。**  
所以考虑二分，我们二分不为 $1$ 的位置，然后通过数学方法算出不合法质数的数量即可。  
**时间复杂度**：$O(n \log n)$。  
AC code：  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
string l,r,ll,rr;
int n,m;
char p[4]={'2','3','5','7'};
int ans;
bool operator<=(string a,string b){
	if(a.size()!=b.size())return a.size()<b.size();
	for(int i=1;i<min(a.size(),b.size());i++){
		if(a[i]>b[i])return 0;
		if(a[i]<b[i])return 1;
	}return 1;
}
signed main(){
	cin>>l>>r;
	n=l.size(),m=r.size();
	l=' '+l,r=' '+r;
	for(int i=1;i<=n;i++)ll+='1';
	for(int i=1;i<=m;i++)rr+='1';
	ll=' '+ll;
	rr=' '+rr;
	for(int i=n;i<=m;i++)ans+=4*i;
	int a=1,b=n,k=4;
	while(a<=b){
		int mid=(a+b+1)>>1;
		bool sf1=0,sf2=0;
		for(int i=0;i<=3;i++){
			ll[mid]=p[i];
			if(l<=ll){
				ll[mid]='1';
				a=mid;
				k=i;
				if(a==b)sf2=1;
				sf1=1;
				break;
			}ll[mid]='1';
		}
		if(sf2)break;
		if(sf1)continue;
		b=mid-1;
	}
	ans-=(n-a)*4+k;
	a=1,b=m;
	k=-1;
	while(a<=b){
		int mid=(a+b)>>1;
		bool sf1=0,sf2=0;
		for(int i=3;i>=0;i--){
			rr[mid]=p[i];
			if(rr<=r){
				rr[mid]='1';
				b=mid;
				k=i;
				if(a==b)sf2=1;
				sf1=1;
				break;
			}rr[mid]='1';
		}
		if(sf2)break;
		if(sf1)continue;
		a=mid+1;
	}
	ans-=(b-1)*4+3-k;
	cout<<ans;
	return 0;
}  
```

**有许多边界、二分前的初始化等细节要注意。**  
~~本蒟蒻在比赛时调细节问题调了两小时。~~

---


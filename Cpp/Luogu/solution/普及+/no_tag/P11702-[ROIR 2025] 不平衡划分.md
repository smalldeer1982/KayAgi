# [ROIR 2025] 不平衡划分

## 题目背景

翻译自 [ROIR 2025 D2T2](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。

## 题目描述

给定一个非负整数数组 $[a_1, a_2, \dots, a_n]$。考虑将该数组划分成 $k$ 个非空的连续子段。我们称划分方案的“不平衡度”为这些子段和中的最大值与最小值之差。你需要求出将该数组划分成 $k$ 个子段时的最大不平衡度。

例如，如果数组为 $[2, 1, 3, 4]$，$k=2$，则：
- 划分为 $[2, 1, 3][4]$ 时，不平衡度为 $6 - 4 = 2$；
- 划分为 $[2, 1][3, 4]$ 时，不平衡度为 $7 - 3 = 4$；
- 划分为 $[2][1, 3, 4]$ 时，不平衡度为 $8 - 2 = 6$。

其中最后一种情况的不平衡度最大。

## 说明/提示

在样例二中，最优划分方案是 $[2][1][3, 4][1]$。其中最大子段和为 $3 + 4 = 7$，最小子段和为 $1$，因此不平衡度为 $7 - 1 = 6$。

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

| 子任务 | 分数 | 特殊性质 |
|:---:|:---:|:---:|
| $1$ | $11$ | $n \le 15$ | 第一错误 | |
| $2$ | $11$ | $k = 2$ | 第一错误 | |
| $3$ | $21$ | $k = 3$ | 第一错误 | |
| $4$ | $15$ | $n \le 300$ | 1 | 第一错误 |
| $5$ | $21$ | $n \le 3000$ | 1, 4 | 第一错误 |
| $6$ |$ 21 $| 无 | 1-5 | 第一错误 |

## 样例 #1

### 输入

```
4 2
2 1 3 4```

### 输出

```
6
```

## 样例 #2

### 输入

```
5 4
2 1 3 4 1```

### 输出

```
6```

# 题解

## 作者：Drifty (赞：4)

### Solution

感觉挺牛的题。

先放结论，事实上一共只有三种情况：

- 最大段长度为 $n - k + 1$，剩下段长度都为 $1$。
- 最大段为一个前缀 $[1, i]$，最小段为 $[i + 1, i + 1]$。
- 最大段为一个后缀 $[i, n]$，最小段为 $[i - 1, i - 1]$。

然后答案就是这三种情况的 $\max$。

我们简单解释一下，这样考虑：假设一开始所有数分成若干一段，然后经过若干次变换之后只剩 $k$ 段的过程。

- 如果当前最大段是前缀且后面紧跟着最小段，那么如果最小段长度大于 $2$，那么把最小段最前面的一个数给最大段。
- 如果当前最大段是后缀且前面紧跟着最小段，同理。
- 否则当前最大段不是前缀也不是后缀，那么一定可以将前面一段的最后一个数或后面一段的最前一个数加进来。
- 如果最大段长度超出 $n - k + 1$，结束。

然后答案应该就是这整个过程中只有 $k$ 段所有状态的最大值。

然而你会发现这几个状态一定会被上面的三种情况所覆盖。

因此就可以直接这么做。

### Code

```cpp
#include <bits/stdc++.h>

using namespace std;
using i64 = long long;

constexpr int N = 3e5 + 7;
int n, k, a[N], pre[N], suf[N];
i64 sum[N], res;

int main() {
    cin.tie(nullptr) -> sync_with_stdio(false);
    cin >> n >> k;

    fill (pre, pre + n + 2, (int)2e9);
    fill (suf, suf + n + 2, (int)2e9);

    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];
    }

    for (int i = 1; i <= n; i ++) {
        pre[i] = min (pre[i - 1], a[i]);
    }
        
    for (int i = n; i >= 1; i --) {
        suf[i] = min (suf[i + 1], a[i]);
    }

    int l = n - k + 1;

    // case 1
    for (int i = l; i <= n; i ++) {
        i64 ans = sum[i] - sum[i - l];
        res = max(ans - min(pre[i - l], suf[i + 1]), res);
    }

    // case 2
    for (int i = 1; i < n; i ++) {
        int x = 2 + (i < n - 1);
        int y = (n - i + 1);
        if (k >= x && k <= y) {
            res = max(res, sum[i] - a[i + 1]);
        }
    }

    // case 3
    for (int i = n - 1; i; i --) {
        int x = 2 + (i > 1);
        int y = i + 1;
        if (k >= x && k <= y) {
            res = max(res, sum[n] - sum[i] - a[i]);
        }
    }

    cout << res << endl;
    return 0;
}
```

---

## 作者：Zyc_zhouyuchen (赞：2)

### 题意
给定一个长度为 $ n $ 的 $ a $ 数组，将其划分成 $ k $ 个**非空连续子段**，**子段和**定义为该子段中所有元素之和，求子段和的最大极差。  
*极差指最大值与最小值之差。*

### 思路
观察发现，$ a $ 数组里都是非负整数，易知，最佳情况一定形如：
  
- 一个仅由**一个元素**形成的子段提供最小值。

因为假如最小值是由多个元素形成的子段和，则删除其中的元素一定会使子段和变小或不变，且有可能使最大值增大，故使元素个数减到最小值 $ 1 $ 一定不劣，可以确认不可能更优。
- 在剩下的元素中，由**极大子段**提供最大值。

设极大子段长度为 $ L $。  
极大子段 要满足两个条件：  
1. 使得数组能够划分为 $ k $ 个非空连续子段，$ {n-L} \ge {k-1} $，移项得 $ L\le {n-k+1} $。假如 $ L $ 超出该范围，剩下就算全是一个仅由一个元素形成的子段，其数目也到不了 $ k $，而取到 $ n-k+1 $ 则刚刚好。  
2. 但也不是所有情况都能取到 $ n-k+1 $ 的长度，假设选定的最小值子段中元素的下标为 $ i $，则 $ L $ 不能超出 $ i $ 前后剩下的最大长度。例如 $ n=6 $，$ k=3 $，$ i=2 $，此时满足条件1的最大长度 $ n-k+1=4 $，而仅有第一个元素的子段长度为 $ 1 $，也算一个极大子段。

---
于是，我们就可以这么处理：枚举每一个位置 $ i $ 为最小值子段的情况。对于每种情况，如果 $ i $ 前面或后面长度不到条件1的限制，则求出这一整段的和（预处理出前缀和解决）；否则把该区间中所有长度为 $ n-k+1 $ 的子段和最大值求出来（预处理出 st 表解决）。这样我们就得到了极大子段和的最大值。最终答案就是所有情况的 $ \max $。  
  
你以为这样就结束了吗？  
~~我一开始也是这么以为的，然而没过。~~  
原来当 $ k=2 $ 时，如果取了中间的某个点，就至少有 $ 3 $ 段了，不符合条件，于是应该对于 $ k=2 $ 的情况进行特判，其答案为 $ \max $(分成 $ a_1 $ 和剩下部分的答案，分成 $ a_n $ 和剩下部分的答案)。  
再手推一下，发现 $ k > 2 $ 时都满足一般情况，不需要其他特判了。  
这样就可以过了。 

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3e5+10;
int n,m,k,lg[N];
ll a[N],pre[N],lst[N],ans,tmp;
ll st[N][20];
void bd_st(){
	for(int i=1;i<=m;i++)st[i][0]=pre[i+k-1]-pre[i-1];
	int l=lg[m];
	for(int j=1;j<=l;j++){
		for(int i=1;i<=m-(1<<j)+1;i++){
			st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
}
ll gt_ma(int l,int r){
	r=r-k+1;
	int L=lg[r-l+1];
	return max(st[l][L],st[r-(1<<L)+1][L]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	if(k==2){
		for(int i=1;i<=n;i++){
			cin>>a[i];
			tmp+=a[i];
		}
		cout<<max(abs(tmp-2*a[1]),abs(tmp-2*a[n]));
		return 0;
	} 
	k=n-k+1;
	m=n-k+1;
	for(int i=2;i<=m;i++)lg[i]=lg[i-1]+(i==(1<<(lg[i-1]+1)));
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)pre[i]=pre[i-1]+a[i];
	for(int i=n;i>=m;i--)lst[i]=lst[i+1]+a[i];
	bd_st();
	for(int i=1;i<=n;i++){
		tmp=0;
		if(i<=k)tmp=max(tmp,pre[i-1]);
		else tmp=max(tmp,gt_ma(1,i-1));
		if(i>=m)tmp=max(tmp,lst[i+1]);
		else tmp=max(tmp,gt_ma(i+1,n));
		tmp-=a[i];
		ans=max(ans,tmp);
	}
	cout<<ans;
	return 0;
}
```

翻了下已有的题解，都是 $ O(n) $ 做法的大佬，而我预处理了一个 st 表，复杂度还多了个 $ \log $，不够优秀。由于我用 st 表求的最大值，范围要么从头开始，要么到最后，所以其实完全可以处理出长度为 $ n-k+1 $ 的子段和前后缀最大值。如果这题数据范围再大些，我的解法就会被卡。  

### 后记
我必须承认，自己的水平实在不高。但我享受写题解的过程，这是一种思想的传递，表达能力的锻炼。  
这篇题解写的不是最优解法，但我希望带给大家的帮助不仅是一个解法，更是一个进步的过程。在写题时，发现自己的不足，以及可优化的地方，搞懂优化的原理，这就是一种成长。  
如有意见和建议欢迎指出，大家的提议是我进步的动力。感谢所有支持我的人，谢谢你们！

---

## 作者：canwen (赞：2)

简单题，建议黄。

~~不过赛时没切出来，那还是绿着吧。~~

显然最小子段和长度为 $1$ 一定是最优之一，否则就可能存在子段和比它小。为了方便求和，我们先求出 $a$ 的前缀和数组 $pr$。

注意到每个子段和需要非空，那最大子段和长度上限应该是 $n-(k-1)=n-k+1$。

设 $f1_i,f2_i$ 分别表示 $1\sim i,i\sim n$ 中子段和长度**不超过**上限且保证最大的**子段和**，dp 便能线性预处理出。

我们枚举最小子段和，即枚举 $a_1\sim a_n$，答案应该是 $\max(f1_{i-1},f2_{i+1})-a_i$，不断取最大值就是最终答案。

可能会有人发问了，我并不能保证枚举的 $a_i$ 就是所有子段和中最小的，所以计算会不会有问题？

答案是否定的，既然是遍历，一定会跑出最优解，不用担心。

## Code

目前位居最优解第二，拜谢第一的写法。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar_unlocked();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar_unlocked();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar_unlocked();return k*kk;}
void out(int a){if(a<0) putchar_unlocked('-'),a=-a;if(a>9) out(a/10);putchar_unlocked('0'+a%10);}
const int N = 300000 + 5;
int n,k,s[N],f1[N],pr[N],f2[N],ans;
signed main(){
	n=in(),k=in();
	_rep(i,1,n) s[i]=in(),pr[i]=pr[i-1]+s[i];
	if(k == 2){
		_rep(i,2,n){
			ans = abs((pr[i-1]<<1)-pr[n])>ans?abs((pr[i-1]<<1)-pr[n]):ans;
		}
		out(ans);
		return 0;
	}
	int len=n-k+1;
	_rep(i,1,n){
		if(i <= len) f1[i] += f1[i-1]+s[i];
		else f1[i] = max(f1[i-1],pr[i]-pr[i-len]);
		int j = n-i+1;
		if(n-j+1<=len) f2[j] += f2[j+1]+s[j];
		else f2[j] = max(f2[j+1],pr[j+len-1]-pr[j-1]);
	}
	_rep(i,1,n){
		ans = ans > (f1[i-1]>f2[i+1]?f1[i-1]:f2[i+1])-s[i] ? ans : (f1[i-1]>f2[i+1]?f1[i-1]:f2[i+1])-s[i];
	}
	out(ans);
	return 0;
}
```

---

## 作者：ran_qwq (赞：2)

先特判掉 $m=2$ 的情况，即求一个划分使得前面和后面和极差最小。

观察样例，最小值肯定是一个数组成的子段。否则可以通过平移使得最小值变小而最大值不变小。

所以考虑去枚举最小值位置 $x$，把原序列分成至少三份。最小值确定了，肯定要让最大值尽量大。如果能取长度为 $n-m+1$ 的（不会被 $x$ 卡住）就取 $n-m+1$ 的，否则就取所有前面或者所有后面。然后把其他位置随意分成 $m-2$ 份。

如果划分其它 $m-2$ 段中出现了比最小值还小的段，不用管它，因为钦定最小值为它时还是会枚举到这种情况。

维护前后缀长度为 $n-m+1$ 的子段即可做到 $O(n)$。

```cpp
int n,m; ll as,a[N],p[N],s[N];
void QwQ() {
	n=rd(),m=rd();
	for(int i=1;i<=n;i++) a[i]=a[i-1]+rd();
	for(int i=1;i<=n;i++) p[i]=max(p[i-1],a[i]-(i>=n-m+1?a[i-(n-m+1)]:0));
	for(int i=n;i;i--) s[i]=max(s[i+1],(i+n-m<=n?a[i+n-m]:a[n])-a[i-1]);
	if(m==2) for(int i=1;i<n;i++) cmaxll(as,abs(p[i]-s[i+1]));
	else for(int i=1;i<=n;i++) cmaxll(as,max(p[i-1],s[i+1])-(a[i]-a[i-1]));
	wrll(as,"\n");
}
```

---

## 作者：corner_xiejunqi (赞：1)

### 题目分析：
#### 考虑如何凑成最大段：
因为题目中数组中都是非负整数，那么只要子段长度越大，和就越大。那么最大长度为多少呢？因为必须要分为 $k$ 个子段，且每个子段长度至少为一，那么最大长度就为 $n-k+1$。
#### 现在就可以开始分类讨论了：
首先定义一个 $maxn$ 为最大不平衡度。
一、最大段的长度就为最大长度，那么其他所有子段的长度都为 $1$，只需要枚举这个最大段的头，求出尾，然后用前缀和将最大段的和求出。打一个 $st$ 表，求出除这个最大子段，剩下的最小值，相减即是不平衡度。将此值与 $maxn$ 取大即可。

二、最大段的长度不为最大长度，那么这个最大段一定就是一个前缀或后缀：

1、最大段是一个前缀，那么设这个最大段的尾坐标为 $i$，那么最大段为 $[1,i]$，最小段为 $[i+1,i+1]$，相减与 $maxn$ 取大。

解释：如果当前最大段是前缀且后面紧跟着最小段，那么如果最小段长度大于等于 $2$，那么把最小段最前面的一个数给最大段。

2、最大段是一个后缀，那么设这个最大段的头坐标为 $i$，那么最大段为 $[i,n]$，最小段为 $[i-1,i-1]$，相减与 $maxn$ 取大。

解释：如果当前最大段是后缀且前面紧跟着最小段，与前缀同理。

注意特判 $k=2$ 的情况，只有两段，不会有前后缀这种分类
### 代码实现：

```cpp

#include<bits/stdc++.h>
using namespace std;
#define int long long//开long long
const int N=3e5+10;//申明数组定量
int n,k;
int a[N],sum[N];//a为数组，sum为前缀和
int st[200][N],lg[N];//st表和log表
inline void init_st(){//初始化st表
	for(int i=1;i<=n;i++) st[0][i]=a[i];
	for(int k=0;(1<<(k+1))<=n;k++){
		for(int i=1;i<=n-(1<<(k+1))+1;i++){
			st[k+1][i]=min(st[k][i],st[k][i+(1<<k)]);
		}
	}
}
inline void init_lg(){//预处理log表
	for(int k=0,i=1;i<=n;i++){
		if(i==(1<<(k+1))) k++;
		lg[i]=k;
	}
}
inline int find(int l,int r){//找最小值
	int k=lg[r-l+1];
	return min(st[k][l],st[k][r-(1<<k)+1]);
}
signed main(){
	// step 1、读题、声明变量
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	// step 2、输入
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],sum[i]=sum[i-1]+a[i];
	int len=n-k+1;
	init_st();init_lg();
	// step 3、处理
	int maxn=-0x3f3f3f3f;//最大不平衡度
	for(int i=1;i<=n;i++){//当最大段长度为最大长度时
		int r=i+len-1;
		if(r>n) break;
		int he=sum[r]-sum[i-1];
		int minn=0;
		if(i==1) minn=find(r+1,n);
		else if(r==n) minn=find(1,i-1);
		else minn=min(find(1,i-1),find(r+1,n));
		maxn=max(maxn,(he-minn));
	}
	if(k!=2){
		for(int i=1;i<=len;i++){
		int he=sum[i];
		maxn=max(maxn,he-a[i+1]);
		}
		for(int i=n;i>=n-len+1;i--){
			int he=sum[n]-sum[i-1];
			maxn=max(maxn,he-a[i-1]);
		}
	}
	// step 4、输出
	cout<<maxn;
	return 0;
}
```
##### 记得开 $long long$。

---

## 作者：kbzcz (赞：1)

一开始的做法假了我 30min/lh/lh。

---

### 思路

先特判 $k=2$ 的情况，即第一个单独或最后一个单独。

当 $k>2$，观察到最小值一定自己一组，考虑枚举最小值位置。设当前位置为 $i$，则序列被分为 $[1,i-1]$ 和 $[i+1,n]$ 两部分。贪心的想，因为值域非负，最大值的那一段一定是越长越好。因为必须划分 $k$ 段，所以，当其余数都单独成段时，最大值所在段长度有上界 $n-k+1$。于是预处理所有长度为 $n-k+1$ 的区间的值，做个前缀后缀最大值，分讨一下最大值在左还是右就出来了。

----

### 代码


```cpp
bool _Start;
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define pb push_back
#define debug puts("How can I become successful?")
#define Tp template<typename T>
#define Ts template<typename T,typename... _T>
Tp il void read(T& x) {
	x=0;bool f=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) f|=c=='-';
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	x=(f?-x:x);
}Ts il void read(T& x,_T&... y) {read(x),read(y...);}
using ll=long long;
const int N=3e5+5;
int n,K;
ll a[N],sum[N],pre[N],suf[N],mxp[N],mxs[N],ans;
bool _End;
int main() {
	fprintf(stderr,"Memory:%.4lf Mib\n",abs(&_End-&_Start)/1048576.0);
	read(n,K);
	for(int i=1;i<=n;i++) read(a[i]);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
	if(K==2) {
		printf("%lld",max(sum[n]-2*a[1],sum[n-1]-a[n]));
		return 0;
	}
	ans=-1e18;
	memset(pre,0xcf,sizeof(pre));
	memset(suf,0xcf,sizeof(suf));
	for(int i=n-K+1;i<=n;i++) pre[i]=max(pre[i-1],sum[i]-sum[i-(n-K+1)]);
	for(int i=K;i>=1;i--) suf[i]=max(suf[i+1],sum[i+n-K]-sum[i-1]);
	for(int i=1;i<=n;i++) {
		if(i-1<=n-K+1) ans=max(ans,sum[i-1]-a[i]);
		else ans=max(ans,pre[i-1]-a[i]);
		if(n-i<=n-K+1) ans=max(ans,sum[n]-sum[i]-a[i]);
		else ans=max(ans,suf[i+1]-a[i]);
	}
	printf("%lld",ans);
	return 0;
}

```

---

## 作者：_Deer_Peach_ (赞：1)

题意：

给出一个长度为 $n$ 的数组，把这一个数组分成 $k$ 份，使得 $k$ 份的极差最大。

思路：

最小值的子数组长度肯定为 $1$，因为如果一个最小值的子数组长度不为 $1$，删除其中两端任意一个数可以使该子数组变小或不变，也会使相邻两边的子数组和变大或不变，所以可能使最大值变大或不变。所以使最小值长度为 $1$ 最优，没有更优的方案。

最大值的长度最大为 $n-k+1$，因为每一段的长度至少为 $1$。

然后最大值有以下三种可能：
1. 最大值长度为 $n-k+1$，其余长度为 $1$；
2. 最大值在数组的最左端，长度为 $i$，且 $1 \le i \lt n-k+1$，这时最小值的下标为 $i+1$；
3. 最大值在数组的最右端，长度为 $i$，且 $k-1 \lt i \le n$，这时最小值的下标为 $i-1$。

最后用三个数组分别记录前缀和，前缀最小值和后缀最小值即可。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0) 
const int N=3e5+5,Max=0x3f3f3f3f3f3f3f3f;
int n,k,a[N],num[N],ans=-Max;
int lmi[N],rmi[N]; 
signed main(){
	IOS;cin>>n>>k;
	memset(lmi,0x3f,sizeof(lmi));
	memset(rmi,0x3f,sizeof(rmi));
	for(int i=1;i<=n;i++)cin>>a[i],num[i]=num[i-1]+a[i];//前缀和
	if(k==2){//特判k=2是因为如果最小值在中间时会分成3份，即不适合最大值在最左或最右的情况
		cout<<max(num[n-1]-a[n],num[n]-a[1]*2);
		return 0;
	}
	for(int i=1;i<=n;i++)lmi[i]=min(lmi[i-1],a[i]);//前缀最小值
	for(int i=n;i>=1;i--)rmi[i]=min(rmi[i+1],a[i]);//后缀最小值
	int len=n-k+1;
	for(int l=1;l<len;l++)ans=max(ans,num[l]-rmi[l+1]);//第二种情况
	for(int l=n;l>n-len;l--)ans=max(ans,num[n]-num[l-1]-lmi[l-1]);//第三种情况
	for(int l=1;l+len-1<=n;l++){//第一种情况
		int r=l+len-1;
		int maxx=num[r]-num[l-1];
		int minn=min(lmi[l-1],rmi[r+1]);
		ans=max(maxx-minn,ans);
		//cout<<maxx<<" "<<minn<<endl; 
	}cout<<ans;return 0;
} 
```

---

## 作者：jimmy9_666 (赞：1)

# P11702 [ROIR 2025] 不平衡划分 题解

[题目传送门](https://www.luogu.com.cn/problem/P11702)

### 题意

给一个长度为 $n$ 的序列 $A$。

将 $A$ 划分为 $k$ 段，求这些子段和中的**最大值与最小值之差**的最大值。

### 分析

首先有一个很重要的性质：子段和的最小值只由一个数构成。

因为如果是多个数的话，去掉其中的几个数一定能得到更优的答案。

然后我们就可以在代码里 $O(n)$ 枚举每个数作为最小值了。

最小值有了，看最大值。最大值其实就是魔改版的最大字段和。

首先，因为枚举的时候已经固定了最小值的位置为 $i$，所以我们最大值的子段一定不能包含到最小值的那个数。

还有一个要注意的点，因为我们划分为 $k$ 段，所以最大值的子段的长度不能超过 $n - k + 1$。

所以我们设：

`l_f[i]` 表示 $i$ 为**结尾**的长度小于等于 $n - k + 1$ 的最大子段和，`l_len[i]` 表示这个最大子段和的长度，`l_ans[i]` 表示**从左往右**共 $i$ 个数的长度小于等于 $n - k + 1$ 的最大子段和。

`r_f[i]` 表示 $i$ 为**开头**的长度小于等于 $n - k + 1$ 的最大子段和，`r_len[i]` 表示这个最大子段和的长度，`r_ans[i]` 表示**从右往左**共 $i$ 个数的长度小于等于 $n - k + 1$ 的最大子段和。

然后预处理出以上六个数组的值。

最后统计答案就行了。

### 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#define LL long long
#define int long long

using namespace std;

const int N = 300010;

int n, k;
int a[N]; 

int l_len[N], l_f[N], l_ans[N];
int r_len[N], r_f[N], r_ans[N];
// l_f[i]：表示 i 为结尾的长度小于等于 n - k + 1 的最大子段和
// l_len[i]：表示 l_f[i] 这个最大子段和的长度 
// l_ans[i]：表示从左往右共 i 个数的长度小于等于 n - k + 1 的最大子段和
// r_f[i]：表示 i 为开头的长度小于等于 n - k + 1 的最大子段和
// r_len[i]：表示 r_f[i] 这个最大子段和的长度 
// r_ans[i]：表示从右往左共 i 个数的长度小于等于 n - k + 1 的最大子段和

int ans;

signed main() {
	scanf("%lld%lld", &n, &k);
	for (int i = 1; i <= n; i ++ )
		scanf("%lld", a + i);
	int len = n - k + 1; // 最大子段和最大的长度 
	for (int i = 1; i <= n; i ++ ) {
		if (l_f[i - 1] + a[i] > a[i]) {
			l_len[i] = 1 + l_len[i - 1];
			l_f[i] = l_f[i - 1] + a[i];
			if (l_len[i] > len) // 如果太长了 
				l_f[i] -= a[i - len], l_len[i] -- ; // 减掉最前面的数的值 
		} else {
			l_len[i] = 1;
			l_f[i] = a[i];
		}
	}
	for (int i = n; i; i -- ) {
		if (r_f[i + 1] + a[i] > a[i]) {
			r_len[i] = 1 + r_len[i + 1];
			r_f[i] = r_f[i + 1] + a[i];
			if (r_len[i] > len) // 如果太长了 
				r_f[i] -= a[i + len], r_len[i] -- ; // 减掉最后面的数的值 
		} else { 
			r_len[i] = 1;
			r_f[i] = a[i];
		}
	}
	
	for (int i = 1; i <= n; i ++ )
		l_ans[i] = max(l_ans[i - 1], l_f[i]);
	for (int i = n; i; i -- )
		r_ans[i] = max(r_ans[i + 1], r_f[i]);
	// 计算最大子段和 
	
	if (k == 2) { // 注意这个特判，因为下面的循环将序列分为了三段去计算，所以需要特判k=2的情况 
		printf("%lld\n", max(r_ans[2] - a[1], l_ans[n - 1] - a[n]));
		return 0;
	}
	for (int i = 1; i <= n; i ++ ) // 假设最小值为 a[i] 
		ans = max(ans, max(l_ans[i - 1], r_ans[i + 1]) - a[i]); // 计算答案 
	printf("%lld\n", ans);
	return 0;
}
```

### 致谢

感谢 @[_0o0_](https://www.luogu.com.cn/user/671610) 大佬讲解思路并帮忙debug。

---


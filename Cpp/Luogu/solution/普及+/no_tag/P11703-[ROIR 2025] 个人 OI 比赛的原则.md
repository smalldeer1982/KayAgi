# [ROIR 2025] 个人 OI 比赛的原则

## 题目背景

翻译自 [ROIR 2025 D2T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。

## 题目描述

重温一下个人参加 OI 比赛的原则：每道题都要有分！不能有题目得零分。

让我们模拟一个 OI 比赛的过程。假设比赛中有 $n$ 道题目，第 $i$ 道题目包含 $k_i$ 个子任务，第 $i$ 道题目的第 $j$ 个子任务可以获得 $c_{i, j}$ 分。子任务之间是独立的，因此你可以在每道题中选择任意数量的子任务来解答。但是，你不能一个子任务都不选，因为那样这道题得分就是 $0$ 分，这违反了原则。

你想知道，是否可以在遵守原则的前提下，恰好获得 $s$ 分。

## 说明/提示

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

| 子任务 | 分数 | 特殊性质 |
| :--: | :--: | :--: |
| $1$ | $8$ | $n = 1$ | — | 第一种错误 |
| $2$ | $10$ | $n = 2$ | — | 第一种错误 |
| $3$ | $6$ | $k_1 + k_2 + \dots + k_n \leq 20$ | — | 第一种错误 |
| $4$ | $6$ | $k_i = 1$ | — | 第一种错误 |
| $5$ | $15$ | $n \cdot s \leq 100000$, $s \leq 1000$ | 第三种错误 | — |
| $6$ | $55$ | 无 | 第1至第5种错误 | — |

## 样例 #1

### 输入

```
2 4
1
2
2
3 1```

### 输出

```
No```

## 样例 #2

### 输入

```
2 4
1
2
2
2 1```

### 输出

```
Yes
1
1
1
1```

# 题解

## 作者：ran_qwq (赞：3)

下文的 $l_i$ 表示题目的 $k_i$。

数据范围提示也太明显了吧。

注意到 $\sum l_i\cdot s\le10^7$，一个 $O(\sum l_i\cdot s)$ 的 dp 呼之欲出：$f_{i,j,k,0/1}$ 表示第 $i$ 题第 $j$ 个 subtask，总分为 $k$，这道题目前有没有得分是否可行。

转移几种情况：

- 当前是第一个 subtask：
  - 不拿分，$f_{i,1,k,0}\leftarrow f_{i-1,l_{i-1},k,1}$。
  - 拿分，$f_{i,1,k,1}\leftarrow f_{i-1,l_{i-1},k-c_{i,1},1}$。
- 当前不是第一个 subtask：
  - 不拿分：
    - 这道题之前没拿过分，$f_{i,j,k,0}\leftarrow f_{i,j-1,k,0}$。
    - 这道题之前拿过分，$f_{i,j,k,1}\leftarrow f_{i,j-1,k,1}$。
  - 拿分：
    - 这道题之前没拿过分，$f_{i,j,k,1}\leftarrow f_{i,j-1,k-c_{i,j},0}$。
    - 这道题之前拿过分，$f_{i,j,k,1}\leftarrow f_{i,j-1,k-c_{i,j},1}$。

需要输出方案，dp 数组可以记录“这道题当前拿不拿分”和“这道题之前有没拿过分”，构造时不断往前跳。

直接开 vector 会 MLE，需要开一维数组 dp。

```cpp
int n,m,l[N],sl[N]; pii f[N*210]; vi c[N]; vi as[N];
il int gt(int x,int y,int z,int p) {return (m+1)*2*(sl[x-1]+y)+z*2+p;}
void prt(int x,int y,int z,int p) {
	if(!x) return;
	auto [s,t]=f[gt(x,y,z,p)];
	int u=x,v=y-1; if(!v) u--,v=l[u];
	if(s==1) prt(u,v,z,t);
	else as[x].pb(y),prt(u,v,z-c[x][y],t);
}
void QwQ() {
	n=rd(),m=rd(),sl[0]=1;
	for(int i=1;i<=n;i++) {
		l[i]=rd(),c[i].resize(l[i]+1),sl[i]=sl[i-1]+l[i];
		for(int j=1;j<=l[i];j++) c[i][j]=rd();
	}
	f[gt(0,0,0,1)]={-1,-1};
	for(int i=1;i<=n;i++) {
		for(int k=0;k<=m;k++) {
			if(f[gt(i-1,l[i-1],k,1)].fir) f[gt(i,1,k,0)]={1,1};
			if(k>=c[i][1]&&f[gt(i-1,l[i-1],k-c[i][1],1)].fir) f[gt(i,1,k,1)]={2,1};
		}
		for(int j=2;j<=l[i];j++) for(int k=0;k<=m;k++) {
			if(f[gt(i,j-1,k,0)].fir) f[gt(i,j,k,0)]={1,0};
			if(f[gt(i,j-1,k,1)].fir) f[gt(i,j,k,1)]={1,1};
			else if(k>=c[i][j])
				if(f[gt(i,j-1,k-c[i][j],0)].fir) f[gt(i,j,k,1)]={2,0};
				else if(f[gt(i,j-1,k-c[i][j],1)].fir) f[gt(i,j,k,1)]={2,1};
		}
	}
	if(!f[gt(n,l[n],m,1)].fir) puts("No");
	else {
		puts("Yes"),prt(n,l[n],m,1);
		for(int i=1;i<=n;i++,puts("")) {
			wr(as[i].size(),"\n"),reverse(as[i].begin(),as[i].end());
			for(int j:as[i]) wr(j," ");
		}
	}
}
```

---

## 作者：_cbw (赞：2)

## 题意

给定 $n$ 个组，每个组 $i$ 有 $k_i$ 个元素，分别为 $c_{i, 1}, c_{i, 2}, \cdots, c_{i, k_i}$。求在每一个组都必须选至少一个元素的情况下是否可以使选出的元素总和恰为 $s$，若可以则给出任意方案。

$1 \le n, s, \sum_{i = 1}^{n} k_i \le 10^5, \sum_{i = 1}^{n} k_i \cdot s \le 10^7$。

## 第一问

题目的形式非常像[分组背包](https://oi-wiki.org/dp/knapsack/#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85)，加上 $\sum_{i = 1}^{n} k_i \cdot s \le 10^7$ 就更使人往背包的方向想了（毕竟这样的条件几乎只有背包会用到）。

具体的，定义状态 $f_{i, j}$ 表示前 $i$ 个组，选出元素和为 $j$ 是否可行。设当前元素的值为 $w$，则有转移：

$f_{i, w + v} \gets f_{i, w + v} \operatorname{or} f_{i - 1, v} \operatorname{or} f_{i, v} (0 \le v \le s - w)$

其实就是经典背包。转移 $f_{i - 1, v}$ 表示这个元素是这个组第一个被选的，$f_{i, v}$ 则相反。初始状态为 $f_{0, 0} = \mathrm{true}$。

第一维要滚动掉。

## 第二问

有一个直接的想法就是每个状态都开一个 `vector`，从 $S$ 状态转移到 $T$ 状态的时候就把 $S$ 的 `vector` 复制一份再加进枚举到的元素。但是无论时间还是空间上都炸到起飞。~~（我才不告诉你是谁想出来的呢）~~

当然，如果你仔细思考了上面的做法，就会发现它的瓶颈在于一个状态可能会转移到很多个状态，而这个重复显然是很浪费的。

于是，可以考虑一种类似**可持久化线段树**的思想，为每个状态都设置一个**节点**，转移的时候就可以直接让转移到的状态向源状态**连边**。查询答案时直接遍历答案状态所在的**子树**即可。

两问总时间、空间复杂度均为 $\Theta(\sum_{i = 1}^{n} k_i \cdot s)$。

## 实现细节

- 第一问中的 $v$ 要从大到小枚举，否则会变成完全背包（一个元素会被选多次）。
- 可以用 `vector` 来存各个组中的元素。
- 注意第二问中的“源状态” 也包括元素本身（详见*代码*一节）。

## 代码

`dp` 数组对应 $f$，`idsta` 数组存储了这个状态的编号，`son` 就是编号在树上的儿子。

```cpp
#include <cstring>
#include <iostream>
#include <utility>
#include <vector>
#define MAXN 100003
#define VMAXN 10000003
using namespace std;
using PII = pair<int, int>;

vector<int> prob[MAXN];
PII son[VMAXN];
bool isans[MAXN];
bool dp[2][MAXN];
int szsm, idsta[2][MAXN], vec[MAXN];

void dfs(const int u)
{
    if (u <= szsm)
    {
        isans[u] = true;
        return;
    }
    if (son[u].first)
        dfs(son[u].first);
    if (son[u].second)
        dfs(son[u].second);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n, s, szcur;
    cin >> n >> s;
    for (int i = 1; i <= n; ++i)
    {
        cin >> szcur;
        szsm += szcur;
        prob[i].resize(szcur);
        for (int j = 0; j < szcur; ++j)
            cin >> prob[i][j];
    }
    int tot = szsm;
    dp[0][0] = true;
    for (int i = 1, o = 1, idv = 0; i <= n; ++i, o ^= 1)
    {
        memset(dp[o], 0, sizeof(dp[o]));
        for (const int j : prob[i])
        {
            ++idv;
            for (int v = s - j; v >= 0; --v)
            {
                if (dp[o][v + j])
                    continue;
                if (dp[o ^ 1][v])
                {
                    dp[o][v + j] = true;
                    son[++tot] = {idv, idsta[o ^ 1][v]};
                    idsta[o][v + j] = tot;
                }
                else if (dp[o][v])
                {
                    dp[o][v + j] = true;
                    son[++tot] = {idv, idsta[o][v]};
                    idsta[o][v + j] = tot;
                }
            }
        }
    }
    if (!dp[n & 1][s])
    {
        cout << "No\n";
        return 0;
    }
    cout << "Yes\n";
    dfs(idsta[n & 1][s]);
    int vecp = 0;
    for (int i = 1, idv = 0; i <= n; ++i)
    {
        vecp = 0;
        for (int j = 1; j <= prob[i].size(); ++j)
        {
            ++idv;
            if (isans[idv])
                vec[++vecp] = j;
        }
        cout << vecp << '\n';
        for (int j = 1; j < vecp; ++j)
            cout << vec[j] << ' ';
        cout << vec[vecp] << '\n';
    }
    return 0;
}
```

---

## 作者：wzb13958817049 (赞：1)

# 思路
首先考虑判断 `Yes` 和 `No`，可以看出来是 [01 背包](https://oi-wiki.org/dp/knapsack/)，内存较大可以用滚动数组，但是 `bitset` 也不会 MLE，代码如下：
```cpp
for(int i=1;i<=n;i++){
	for(int j=0;j<v[i].size();j++){
		int u=v[i][j];
		for(int k=s;k>=u;k--){
			dp[i][k]=dp[i][k]|dp[i][k-u];
			dp[i][k]=dp[i][k]|dp[i-1][k-u];
		}
	}
}
```
再写 DFS 输出即可，题中指出 $(k_1 + k_2 + … k_n) \times s \le 10^7$ 所以并不会 TLE。
# 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,s;
bitset<100000> dp[100005];
vector<ll> v[100005],ans[100005];
void dfs(int x,int u,int last){
	if(x==0){
		if(u==0){
			for(int i=1;i<=n;i++){
				cout<<ans[i].size()<<"\n";
				for(int j=0;j<ans[i].size();j++){
					cout<<ans[i][j]<<" ";
				}
				cout<<"\n";
			}
			exit(0);
		}
		return ;
	}
	for(int i=last;i<v[x].size();i++){
		int y=v[x][i];
		if(u>=y && dp[x][u-y]){
			ans[x].push_back(i+1);
			dfs(x,u-y,i+1);
			ans[x].erase(--ans[x].end());
		}
		if(u>=y && dp[x-1][u-y]){
			ans[x].push_back(i+1);
			dfs(x-1,u-y,0);
			ans[x].erase(--ans[x].end());
		}
	}
}
int main(){
	ios::sync_with_stdio(0),cout.tie(0),cin.tie(0);
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		ll x;cin>>x;
		for(int j=1;j<=x;j++){
			ll y;cin>>y;
			v[i].push_back(y);
		}
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<v[i].size();j++){
			int u=v[i][j];
			for(int k=s;k>=u;k--){
				dp[i][k]=dp[i][k]|dp[i][k-u];
				dp[i][k]=dp[i][k]|dp[i-1][k-u];
			}
		}
	}
	if(dp[n][s]==0) cout<<"No";
	else{
		cout<<"Yes\n";
		dfs(n,s,0);
	}	
	return 0;
}
```

---

## 作者：ELECTRODE_kaf (赞：0)

01 背包板子+DFS 拼凑目标值。用 `bitset` 可通过。很模板的题，评蓝虚高。

设 $dp_{i,j}=0/1$ 表示考虑前 $i$ 个题目，得到恰好 $j$ 分是否可行。转移：$dp_{i,j}=dp_{i,j-k}\lor dp_{i-1,j-k}$。

```cpp
const ll N = 1e5 + 10, GOAL = 1e5 + 10;
ll n, goal;
bitset<GOAL> dp[N];
vector<ll> v[N], ans[N];

void dfs(ll p, ll rem, ll lst) {
	if (p == 0) {
		if (rem == 0) {
			rep(i, 1, n) {
				cout << ans[i].size() << '\n';

				for (ll j : ans[i])
					cout << j + 1 << ' ';

				endl;
			}

			exit(0);
		}
	} else {
		if (lst + 1 <= v[p].size() - 1) {
			rep(i, lst + 1, v[p].size() - 1) {
				if (rem >= v[p][i] and dp[p][rem - v[p][i]]) {
					ans[p].pb(i);
					dfs(p, rem - v[p][i], i);
					ans[p].pop_back();
				}

				if (rem >= v[p][i] and dp[p - 1][rem - v[p][i]]) {
					ans[p].pb(i);
					dfs(p - 1, rem - v[p][i], -1);
					ans[p].pop_back();
				}
			}
		}
	}
}

int main() {
	cin >> n >> goal;

	rep(i, 1, n) {
		ll m;
		cin >> m;

		count(m) {
			ll in;
			cin >> in;
			v[i].pb(in);
		}
	}

	dp[0][0] = 1;

	rep(i, 1, n) {
		for (ll j : v[i]) {
			rep_(k, goal, j) dp[i][k] = dp[i][k] or dp[i][k - j] or dp[i - 1][k - j];
		}
	}

	if (dp[n][goal]) {
		cout << "Yes\n";
		dfs(n, goal, -1);
	} else
		cout << "No";
}
```

---


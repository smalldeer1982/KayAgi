# [COCI 2024/2025 #5] 塔楼 / Tornjevi

## 题目背景

译自 [COCI 2024/2025 #5](https://hsin.hr/coci/) T3。$\texttt{2s,0.5G}$。满分为 $90$。


## 题目描述


给定正整数序列 $h_1,\ldots,h_n$。

对于区间 $[l,r]$，我们称 $i$（$l\le i\le r$）关于 $[l,r]$ 是**好的**，当且仅当：$h_i=\gcd(h_l,h_{l+1},\ldots,h_r)$。

对于 $i$，定义 $f(i)$ 表示：所有 $i$ 关于 $[l,r]$ 是好的区间中，$r-l+1$ 的最大值。

对于 $i=1,2,\ldots,n$，求出 $f(i)$。

## 说明/提示


#### 数据范围

对于 $100\%$ 的数据，保证 $1\le n,h_i\le 10^6$。

| 子任务编号 |  $n\le$ | 特殊性质 | 得分 |  
| :--: | :--: | :--: | :--: |
| $ 1 $    |  $100$  |   | $ 7 $   |  
| $ 2 $    |  $5\times 10^3$  |  | $ 11 $   |  
| $ 3 $    |  $5\times 10^4$  |  | $ 17 $   |  
| $ 4 $    | $10^6$  |  A | $ 29 $   |  
| $ 5 $   |  $10^6$  | | $26$ |

特殊性质 A：$h_i\le 100$。


## 样例 #1

### 输入

```
6
3 6 6 6 1 3```

### 输出

```
4 3 3 3 6 1```

## 样例 #2

### 输入

```
5
10 2 10 15 5```

### 输出

```
1 3 1 1 3```

# 题解

## 作者：jiangxinyang2012 (赞：4)

因为只有一个半小时打，赛时 T5 又被卡常卡了 $50$ 分钟，所以这题没写完 qwq。

这是个大水题，因为如果 $i$ 关于区间 $[l,r]$ 是好的，那么 $i$ 一定在 $l$ 和 $r$ 之间。而且显然区间 $\gcd$ 是有单调性的，所以考虑二分。每次二分出以 $i$ 为右端点的区间 $\gcd$ 为 $h_i$ 的最小左端点和以 $i$ 为左端点的区间 $\gcd$ 为 $h_i$ 的最大右端点，两个下标减一减加一就是最终答案，而且区间 $\gcd$ 是可以用 st 表预处理的。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mod = 1e9 + 7;
const int N = 1000005;
const int INF = 0x3f3f3f3f;
int a[N], dp[N][32];
void st_init(int n) {
    for (int i = 1; i <= n; i++) dp[i][0] = a[i];
    int p = __lg(n);
    for (int k = 1; k <= p; k++) {
        for (int s = 1; s + (1 << k) <= n + 1; s++) {
            dp[s][k] = __gcd(dp[s][k - 1], dp[s + (1 << (k - 1))][k - 1]);
        }
    }
}
int st(int l, int r) {
    int k = __lg(r - l + 1);
    int x = __gcd(dp[l][k], dp[r - (1 << k) + 1][k]);
    return x;
}
int L[N], R[N];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }
    st_init(n);
    for (int i = 1; i <= n; i++) {
        int l = 1, r = i, res = i;
        while (l <= r) {
            int mid = l + r >> 1;
            if (st(mid, i) == a[i]) {
                r = mid - 1;
                res = mid;
            } else {
                l = mid + 1;
            }
        }
        L[i] = res;
    }
    for (int i = 1; i <= n; i++) {
        int l = i, r = n, res = i;
        while (l <= r) {
            int mid = l + r >> 1;
            if (st(i, mid) == a[i]) {
                l = mid + 1;
                res = mid;
            } else {
                r = mid - 1;
            }
        }
        R[i] = res;
    }
    for (int i = 1; i <= n; i++) {
        printf("%d ", R[i] - L[i] + 1);
    }
    printf("\n");
    return 0;
}

```

---

## 作者：yokai_ing (赞：4)

# P11753 [COCI 2024/2025 #5] 塔楼 / Tornjevi
一个区间的 $gcd$ 可以拆成两个区间的 $gcd$ 的 $gcd$ ，即：
$$GCD_{l,r}=\gcd(GCD_{l,k},GCD_{k+1,r})$$
所以可以尝试用 $st$ 表维护区间 $gcd$ ，分别算左右两边，这样查询 $\gcd(a_l,a_{l+1},...,a_r)$ 复杂度 $O(\log{n})$ 。

然后每次分别二分最左能到达哪里和最右能到哪里，显然最优左，右端点求解时互不影响。可以分别求出（即可以一次只求左，另一次只求右），然后合并为答案。

遍历 $1$ 到 $n$ ，每次二分并在其内查询，复杂度 $O(nlog^2{n})$ ， $4e8$ 勉强能过吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 1000010
int g[MAXN][21],n,b[MAXN];
int ansl[MAXN],ansr[MAXN];
int gcd(int x,int y)
{
    return (y==0?x:gcd(y,x%y));
}
void init()
{
    for(int j=1;j<20;j++)
        for(int i=1;i+(1<<j)-1<=n;i++)
            g[i][j]=gcd(g[i][j-1],g[i+(1<<(j-1))][j-1]);
}
int query(int l,int r)
{
    int k=b[r-l+1];
    return gcd(g[l][k],g[r-(1<<k)+1][k]);
}
int ask(int x,int b)
{
    int l=1,r=b==1?x-1:n-x,ans=0;
    while(l<=r){
        int mid=(l+r)/2;
        int now=(b==1?query(x-mid,x):query(x,x+mid));
        if(g[x][0]==now)
            ans=mid,l=mid+1;
        else r=mid-1;
    }
    return ans;
}
int main(){
    scanf("%d",&n);
    for(int i=2;i<=1e6;i++)
        b[i]=b[i/2]+1;
    for(int i=1;i<=n;i++)
        scanf("%d",&g[i][0]);
    init();
    for(int i=n;i>=1;i--)
        ansl[i]=i-ask(i,1),
        ansr[i]=i+ask(i,2);
    for(int i=1;i<=n;i++)
        printf("%d ",ansr[i]-ansl[i]+1);
    return 0;
}

---

## 作者：FFTotoro (赞：2)

枚举 $i$，跟据 $\gcd$ 的性质（$\gcd\limits_{j=l}^r h_j=\gcd\left(\gcd\limits_{j=l}^i h_j,\gcd\limits_{j=i}^r h_j\right)$），且区间 $\gcd$ 具有单调性，只需要向左 / 右分别二分出最小的满足 $\gcd\limits_{j=l}^i h_j=h_i$ 的 $l$ 和最大的满足 $\gcd\limits_{j=i}^r h_j=h_i$ 的 $r$ 即可。查询区间 $\gcd$ 可以使用 ST 表维护。时间复杂度 $O(n\log n\log\max\{h_i\})$。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IAOI_lib{
  template<typename T,T(*op)(T,T)> class sparse_table{
    private:
      vector<vector<T> > s;
    public:
      sparse_table(vector<T> a){
        int k=__lg(a.size());
        s.resize(a.size(),vector<T>(k+1));
        for(int i=0;i<a.size();i++)
          s[i][0]=a[i];
        for(int i=1;i<=k;i++)
          for(int j=0;j+(1<<i)<=a.size();j++)
            s[j][i]=op(s[j][i-1],s[j+(1<<i-1)][i-1]);
      }
      inline T query(int l,int r){
        int k=__lg(r-l+1);
        return op(s[l][k],s[r-(1<<k)+1][k]);
      }
  }; // ST 表维护区间 gcd
}
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n; cin>>n;
  vector<int> h(n);
  for(auto &i:h)cin>>i;
  IAOI_lib::sparse_table<int,gcd> s(h);
  for(int i=0;i<n;i++){
    int L=0,R=i,x=-1;
    while(L<R){
      int m=L+R>>1;
      if(s.query(m,i)<h[i])L=m+1;
      else R=m;
    } // 二分找左端点
    x=R,L=i,R=n-1;
    while(L<R){
      int m=L+R+1>>1;
      if(s.query(i,m)<h[i])R=m-1;
      else L=m;
    } // 二分找右端点
    cout<<L-x+1<<' ';
  }
  cout<<endl;
  return 0;
}
```

---

## 作者：whx2009 (赞：0)

## 本题思路：
有一个比较明显的性质就是 gcd 的变换是最多 log 次的（每一次变化最少都要少一个质数，而最小的质数是二，那么一次变化最少都要除二）。

那么我们就可以考虑分治，每一次递归完左右段之后分别于处理一个后缀 gcd 和一个前缀 gcd，然后用比较暴力的方式去更新每一个位置的左右端点即可，没有什么难度。时间复杂度的话是两只 log 的，有一点极限但是可以过。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000005],ansl[1000005],ansr[1000005];
struct f{
	int l,r;
}b[1000005],c[1000005];
void fenzhi(int l,int r){
	if(l==r){ansl[l]=ansr[l]=l;return;}
	int mid=(l+r)/2;
	fenzhi(l,mid),fenzhi(mid+1,r);
	int cnt=0,cnt1=0;
	b[++cnt].l=a[mid];int gcd=a[mid];
	for(int i=mid-1;i>=l;i--){
		if(a[i]%gcd!=0){
			b[cnt].r=i+1;
			gcd=__gcd(gcd,a[i]);b[++cnt].l=gcd;
		}
	}b[cnt].r=l;
	gcd=a[mid+1];c[++cnt1].l=gcd;
	for(int i=mid+2;i<=r;i++){
		if(a[i]%gcd!=0){
			c[cnt1].r=i-1;
			gcd=__gcd(gcd,a[i]);c[++cnt1].l=gcd;
		}
	}c[cnt1].r=r;
//	cout<<l<<" "<<r<<'\n';
//	cout<<ansl[l];
	for(int i=l;i<=mid;i++){
		if(ansr[i]==mid){
			for(int j=1;j<=cnt1;j++){
				if(c[j].l%a[i]==0){
					ansr[i]=c[j].r;
				}
				else break;
			}
		}
	}
	for(int i=mid+1;i<=r;i++){
		if(ansl[i]==mid+1){
			for(int j=1;j<=cnt;j++){
				if(b[j].l%a[i]==0){
					ansl[i]=b[j].r;
				}	else break;
			}
		}
	}
}
signed main(){
	int n;cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	fenzhi(1,n);
	for(int i=1;i<=n;i++){
		cout<<ansr[i]-ansl[i]+1<<" ";
	}
	return 0;
}
```

---

## 作者：hinin (赞：0)

[无耻的提供更好的阅读体验](https://www.cnblogs.com/hinin/articles/18725128)。

### 思路（61 分）

暴力过不了，考虑优化。

最大公约数具有单调性：当区间扩展时，最大公约数不会增大。因此，对于每个位置 $i$，其作为区间最小值时可能成为最大公约数。

显而易见：若区间 $[l, r]$ 的最大公约数是 $g$，则其子区间的最大公约数一定是 $g$ 的倍数。反之，若某区间的最大公约数等于 $h_i$，则该区间必须包含 $i$，且所有元素的最大公约数为 $h_i$。

最后滑动窗口优化即可。

### 代码

只能得 61 分。

```cpp
#include <bits/stdc++.h>
// #pragma GCC optimize("Ofast", "-funroll-all-loops")
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>

#define y1 kairiki
#define x first
#define y second

#define repeat(x, a, b) for(int x = a; x <= b; x ++)
#define rpless(x, a, b) for(int x = a; x >= b; x --)
#define repeatl(x, a, b) for(int x = a; x < b; x ++)
#define rplessr(x, a, b) for(int x = a; x > b; x --)

using namespace std;

const int N = 1e6 + 1;
int n, h[N], L[N], R[N], f[N];

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n;

	repeatl(i, 0, n) { cin >> h[i]; }

	stack<pii> st;
	repeatl(i, 0, n) {
		int s = i;

		while (!st.empty() && gcd(st.top().first, h[i]) == h[i]) {
			s = st.top().second;
			st.pop();
		}

		L[i] = s;
		st.push({h[i], s});
	}

	st = stack<pii> ();

	rpless(i, n - 1, 0) {
		int end = i;

		while (!st.empty() && gcd(st.top().first, h[i]) == h[i]) {
			end = st.top().second;
			st.pop();
		}

		R[i] = end;
		st.push({h[i], end});
	}

	repeatl(i, 0, n) {
		int t = h[i];

		for (int j = L[i]; j <= R[i]; ++j) {
			t = gcd(t, h[j]);

			if (t != h[i]) { break; }
		}

		if (t == h[i]) { f[i] = R[i] - L[i] + 1; }
		else {
			int l = i, r = i;

			while (l >= 0 && gcd(h[l], h[i]) == h[i]) { l--; }

			while (r < n && gcd(h[r], h[i]) == h[i]) { r++; }

			f[i] = r - l - 1;
		}
	}

	repeatl(i, 0, n) 
	{ cout << f[i] << " "; }

	return 0;
}
```

### 优化

使用稀疏表预处理区间最大公约数，实现在 $O(1)$ 时间内查询任意区间的最大公约数.

在计算 $f_i$ 时，利用二分查找，减少不必要的计算。

### 代码

``` cpp
#include <bits/stdc++.h>
// #pragma GCC optimize("Ofast", "-funroll-all-loops")
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>

#define y1 kairiki
#define x first
#define y second

#define repeat(x, a, b) for(int x = a; x <= b; x ++)
#define rpless(x, a, b) for(int x = a; x >= b; x --)
#define repeatl(x, a, b) for(int x = a; x < b; x ++)
#define rplessr(x, a, b) for(int x = a; x > b; x --)

using namespace std;

const int N = 1e6 + 1;
const int LOG = 20;
int n, h[N], L[N], R[N], f[N];
int st[N][LOG], log2_[N];

int query_gcd(int l, int r)
{
	int k = log2_[r - l + 1];
	return gcd(st[l][k], st[r - (1 << k) + 1][k]);
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n;
	repeatl(i, 0, n) { cin >> h[i]; }

	log2_[1] = 0;
	repeat(i, 2, n) log2_[i] = log2_[i / 2] + 1;

	repeatl(i, 0, n) { st[i][0] = h[i]; }
	repeat(j, 1, LOG - 1) {
		for (int i = 0; i + (1 << j) <= n; i++) 
		{ st[i][j] = gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]); }
	}

	stack<pii> st;
	repeatl(i, 0, n) {
		int s = i;

		while (!st.empty() && gcd(st.top().first, h[i]) == h[i]) {
			s = st.top().second;
			st.pop();
		}

		L[i] = s;
		st.push({h[i], s});
	}

	st = stack<pii>();
	rpless(i, n - 1, 0) {
		int end = i;

		while (!st.empty() && gcd(st.top().first, h[i]) == h[i]) {
			end = st.top().second;
			st.pop();
		}

		R[i] = end;
		st.push({h[i], end});
	}

	repeatl(i, 0, n) {
		int t = h[i];
		int l = L[i], r = R[i];
		
		if (query_gcd(l, r) == h[i]) { f[i] = r - l + 1; } 
		else {
			int tl = i, tr = i;

			while (tl >= 0 && query_gcd(tl, i) == h[i]) { tl--; }

			while (tr < n && query_gcd(i, tr) == h[i]) { tr++; }

			f[i] = tr - tl - 1;
		}
	}

	repeatl(i, 0, n) { cout << f[i] << " "; }

	return 0;
}
```

---


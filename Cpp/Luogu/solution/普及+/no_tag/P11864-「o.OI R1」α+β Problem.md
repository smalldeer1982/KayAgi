# 「o.OI R1」α+β Problem

## 题目背景

机器人小 $\alpha$ 喜欢做游戏，机器人小 $\beta$ 喜欢玩游戏。

## 题目描述

现在，它们正在玩一个叫作推箱子的游戏！

机器人小 $\beta$ 为关卡制定了一个用字符串表示的移动路径：

|字符|含义|
| :-----------: | :-----------: | 
|`W`|让机器人前进一格|
|`S`|让机器人后退一格|
|`A`|让机器人左转|
|`D`|让机器人右转|

身为机器人小 $\alpha$，你需要构造一个 $n\times m$ 的地图：

|字符|含义|
| :-----------: | :-----------: | 
|`\|`|机器人无法穿过的墙壁||
|`X`|机器人最开始在的位置|
|`S`|箱子最开始所在的位置|
|`.`|空地|

注意每个位置的东西只能是以上四种之一。

机器人的初始位置是给定的，方向朝上，地图外都是墙。

小 $\beta$ 完成移动后，所有箱子都必须移动过，小 $\alpha$ 需要让这个地图的箱子数最多，且小 $\beta$ 每步操作都合法。

以下给出所有不合法的操作： 

|操作|不合法情况|
| :-----------: | :-----------: | 
|`W`|机器人前方是墙|
|`W`|机器人前方两格都是箱子|
|`W`|机器人前方两格分别是箱子和墙|
|`S`|机器人后方是箱子或墙|

小 $\alpha$ 需要一份程序来完成这份工作。

## 说明/提示

部分样例有其他正确答案。

**「数据范围」**

**本题开启 Special Judge 与捆绑测试。**  

一个测试点内，如果对于每组数据你的箱子数是最多的，且方案合法，你才能获得该测试点的分数。 

只有通过一个子任务内的所有测试点才能得到该子任务的分数。

对于所有测试数据，保证：
- $1\leq n,m\leq 2000$，$1\leq \sum nm\leq 4\times 10^6$。
- $1\leq x\leq n$，$1\leq y\leq m$。
- $1\leq k,\sum k\leq 10^6$。
- $s_i\in\{\texttt{W},\texttt{A},\texttt{S},\texttt{D}\}$。
- 小 $\beta$ 的移动在空旷地图下一定合法。

| 子任务 | $n,m$ | $\sum nm$ | $\sum k$ | 特殊性质 | 分值 |
|:-:|:-:|:-:|:-:|:-:|:-:|
|$0$ | $\leq4$ | $\leq 40$ | $\leq100$ | 无 | $10$ |
|$1$ | $=45$ | $=2025$ | $\leq10^3$ | A | $10$ |
|$2$ | $\leq200$ | $\leq 4\times 10^4$ | $\leq10^3$ | 无 | $20$ |
|$3$ | $\leq1000$ | $\leq 2\times 10^6$ | $\leq10^6$ | B | $15$ |
|$4$ | $\leq1000$ | $\leq 2\times 10^6$ | $\leq10^6$ | C | $20$ |
|$5$ | $\leq2000$ | $\leq 4\times 10^6$ | $\leq10^6$ | 无 | $25$ |

- 特殊性质 A：前进和后退的总次数不超过 $20$ 次，且 $x=y=23$。
- 特殊性质 B：$s_i\in\{\texttt{W},\texttt{A},\texttt{D}\}$，且只会朝两个方向前进。
- 特殊性质 C：可放箱子的最大数量为 $0$ 或 $1$。

---

尽管比赛中不会返回，我们仍将告诉你 Special Judge 会返回的对应信息，优先级递减。
- `Error: 1`：出现规定以外的字符。
- `Error: 2`：出生点不在正确的位置。
- `Error: 3`：机器人无法前进。
- `Error: 4`：机器人无法后退。
- `Error: 5`：有箱子没有被推动过。
- `Error: 6`：箱子数不是最多的。
 - `Correct`：测试点通过。

## 样例 #1

### 输入

```
1
3 4
2 2 17
DWSAWDWSSDWAWDWAW```

### 输出

```
..S.
SXS.
..S.```

## 样例 #2

### 输入

```
1
3 4
3 4 9
WSAWWDWDW```

### 输出

```
|.|.
|SSS
..SX```

## 样例 #3

### 输入

```
1
3 4
2 1 8
DWASDWAW```

### 输出

```
||.|
XS.|
|.S.```

## 样例 #4

### 输入

```
2
5 4
5 1 9
WDWAWDWAW
5 19
5 8 12
DDSAADDADADW```

### 输出

```
....
..S.
.SS.
SS..
X...
.........||||||||||
.........||......||
||||||...||......||
||..||...||......||
||||||.X.||||||||||```

# 题解

## 作者：TruchyR (赞：3)

出题人题解。
## 部分分
子任务 $0$ 考虑枚举每个位置是否放箱子再验证合法性。

子任务 $1$ 保证了不同位置很少，也可以搜索。

子任务 $2$ 留给可能过的网络流等算法。

子任务 $3$ 分两种情况，对向则最多放两个，否则考虑尽可能在每个拐角放。

子任务 $4$ 用于启发正解，做法和正解差不多。

## 正解
首先墙壁是诈骗，最优解肯定不用放墙。

假如我们在地图里放了多个箱子，那么这些箱子一定互不影响，即没有把一个箱子推进另一个箱子的情况。

由此我们可以假设地图上放满了箱子，用并查集维护移动过程。

- 左右转对这些箱子没有影响。
- 后退时退到的那一格内的那些箱子都不能放了。
- 前进时如果有把一些箱子推进另一些箱子的情况，直接把面前的箱子合并到更前面的箱子里。
  - 注意如果往墙上推就说明面前的那些箱子不能放。
  
最后在同一连通块的箱子只能放一个，注意箱子要动过的限制后随便选一个即可。

然后发现其实一个连通块只需要记录一个箱子的位置就可以了，于是在合并的时候优先记录被推动的箱子即可。

每组数据时间复杂度为 $O(nm+k)$。

```cpp
#include<bits/stdc++.h>
#define CKE if(CHECK)
#define FRE if(FIL)
#define MX 2005
using namespace std;
const int CHECK=0,FIL=0;int read();
bitset<MX*MX> res,p;
int n,m,x,y,X,Y,f,a[MX*MX];string s;
int fx[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
int Z(int i,int j){return i*m-m+j;}
int inMap(int i,int j){return i && j && i<=n && j<=m;}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	FRE freopen(".in","r",stdin);
	FRE freopen(".out","w",stdout);
	int T;cin>>T;while(T--){
		cin>>n>>m>>x>>y>>s>>s;X=x,Y=y,f=0;
		for(int i=1;i<=n*m;i++) a[i]=i,res[i]=p[i]=0;
		a[Z(x,y)]=0;
		for(auto i:s){
			if(i=='D') f=(f+1)%4;
			if(i=='A') f=(f+3)%4;
			if(i=='W'){
				int dx=x+fx[f][0],dy=y+fx[f][1];
				int wx=dx+fx[f][0],wy=dy+fx[f][1];
				if(a[Z(dx,dy)]){
					if(inMap(wx,wy)) a[Z(wx,wy)]=a[Z(dx,dy)];
					a[Z(dx,dy)]=0,p[Z(dx,dy)]=1;
				}
				x=dx,y=dy;
			}
			if(i=='S'){
				int dx=x-fx[f][0],dy=y-fx[f][1];
				a[Z(dx,dy)]=0;x=dx,y=dy;
			}
		}
		for(int i=1;i<=n*m;i++){
			if(!a[i]) continue;
			if(p[a[i]]) res[a[i]]=1;
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(i==X && j==Y){cout<<"X"; continue;}
				if(res[Z(i,j)]){cout<<"S";}
				else cout<<".";
			}cout<<'\n';
		}
	}
	return 0;
}
int read(){
	int Ca=0;char Cr=' ';int Cf=1;
	while(Cr<'0' || Cr>'9'){Cr=getchar();if(Cr=='-'){Cf=-1;}}
	while(Cr>='0' && Cr<='9'){Ca=Ca*10+Cr-48;Cr=getchar();}
	return Ca*Cf;
}
```

---

## 作者：Billhqh9 (赞：2)

# Solution
## 主要思路
墙是迷惑做题者的。不用墙肯定可以构造出最优解，用了墙反而会给自己添堵。所以我们只关心一个地方是否放箱子。因为要使放的箱子最多，所以我们不放在一开始就当所有的格子都放了箱子。接下来可以遍历机器人走过的地方，把不合法的箱子排除。所以我们使用数组来标记一个位置是否放箱子。对于在路径上的箱子，因为前进时只能推一个箱子，所以不妨看做把前进后的位置上的箱子合并进前进前的位置上的箱子（也就是说前进后的位置上不放箱子，给其打上标记）。因此可以使用并查集。
## 实现方法
在遍历机器人走过的路时：
- 左转：照做即可。
- 右转：照做即可。
- 后退：把后退到的格子标记成不放箱子。（因为后退时不能有任何障碍物）
- 前进：如“主要思路”合并箱子即可。

## 细节
- 此题多测，要初始化（把所有格子标成放箱子）。
- 再开始遍历机器人走的路前，把出发点标记成不放箱子。

---

## 作者：lanchenhao2010 (赞：2)

赛时最后一个做出这题的蒟蒻来写篇题解。


## 洛谷P11864 α+β Problem
~~题面太长懒得写简要题面了 qwq。~~
### 评价
比较神秘的小模拟。
### 思路
首先我们可以发现，墙是没有用的，去掉墙不会有什么不好，添上墙却可能挡住本来能推的箱子，所以我们根本不需要生成任何墙，只要生成箱子就行。

然后由于所有箱子都必须移动过，所以箱子初始位置必须在小 $β$ 的路径上。那么我们就照着移动路径一步步模拟，每一步检查即将移动到的位置上有没有箱子，如果有就算了，没有则在这里初始生成一个箱子，然后我们模拟推箱子就好了。

但这里有两个注意点。第一个是，如果即将移动到的位置已经到过了，则不能在此处初始化一个箱子，因为如果最开始时这里有一个箱子，则它应该已经被推走了，不可能还留在这儿。

另一个是，如果推箱子时发现推不动，那该怎么办呢？仔细思考，我们发现删除当前的箱子一定是不劣的。因为如果推不动是因为碰到边界了或现在在后退，那么这个箱子只能被删除；如果推不动是因为前方有多个箱子，那么这个箱子和它前方的那个至少有一个要被删掉，就删了它也没事。

那么剩下的就是代码实现问题了。但要注意，多测清空不能用 `memset`，需要手动循环清空，不然会 TLE。
### 代码
总时间复杂度为 $\mathcal{O(\sum \:(n \times m + k)\:)}$。
```cpp
#include <bits/stdc++.h>
using namespace std;
bool mp[2005][2005];
int lp[2005][2005];
bool vis[4000005];
int gx[4000005];
int gy[4000005];
int dx[4] = {-1,0,1,0};
int dy[4] = {0,1,0,-1};
char s[1000005];
int t;
int n,m,x,y,k,cnt = 0;
inline bool out(int xx,int yy){
	return xx <= 0 || xx > n || yy <= 0 || yy > m;
}
inline void add(int xx,int yy){
	lp[xx][yy] = ++cnt;
	vis[cnt] = true;
	gx[cnt] = xx;
	gy[cnt] = yy;
}

inline void del(int p){
	vis[p] = false;
}
int main(){
	int w;
	scanf("%d",&t);
	while(t--){
		//memset(mp,0,sizeof(mp));
		//memset(lp,0,sizeof(lp));
		cnt = 0;
		scanf("%d%d%d%d%d",&n,&m,&x,&y,&k);
		int ox = x,oy = y;
		scanf("%s",s + 1);
		w = 0;
		lp[x][y] = -1;
		for(int i = 1;i <= k;i++){
			if(s[i] == 'A'){
				w = (w + 3) % 4;
				continue;
			}
			else if(s[i] == 'D'){
				w = (w + 1) % 4;
				continue;
			}
			else {
				int d;
				if(s[i] == 'W') d = w;
				else d = (w + 2) % 4;
				int nx = x + dx[d],ny = y + dy[d];
				int nnx = nx + dx[d],nny = ny + dy[d];
				if(!lp[nx][ny] && s[i] != 'S') add(nx,ny);
				if(lp[nx][ny] > 0 && (out(nnx,nny) || lp[nnx][nny] > 0 || s[i] == 'S')){
					del(lp[nx][ny]);
				}
				else{
					if(lp[nx][ny] > 0) lp[nnx][nny] = lp[nx][ny];
				}
				lp[nx][ny] = -1;
				x = nx,y = ny;
			}
		}
		for(int i = 1;i <= cnt;i++){
			if(vis[i]) mp[gx[i]][gy[i]] = true;
		}
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= m;j++){
				if(i == ox && j == oy){
					printf("X");
					continue;
				}
				if(mp[i][j]) printf("S");
				else printf(".");
			}
			printf("\n");
		}
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= m;j++){
				mp[i][j] = false;
				lp[i][j] = 0;
			}
		}
	}
	return 0;
}
```

---

## 作者：andycode (赞：1)

## 思路
首先墙就是个虚设，因为它除了挡住路外一点作用都没有，所以根本就不需要放墙。

我们先贪心地去假设除起始位置外，其他位置都放置箱子。然后模拟机器人行走的过程，并用两个数组分别记录箱子是否被移动或删除。
+ 当指令为 `A` 时，左转；
+ 当指令为 `D` 时，右转；
+ 当指令为 `W` 时，分类讨论一下，
  1. 如果前方无箱子，直接向前移动；
  2. 如果前方有箱子，且前方的前方超出边界，则删除该箱子后前进；
  3. 如果前方有箱子，且前方的前方无箱子，则将箱子推到前方的前方，标记其已被推动，再前进；
  4. 如果前方有箱子，且前方的前方有箱子，则将前方的前方的箱子删除，然后进行第 3 步的操作；
+ 当指令为 `S` 时，删除后方的箱子（如果有的话），再后退一格。

如果箱子没被删除且有被移动过，则在输出答案时在其原位上输出它。
## 代码
```
#include <bits/stdc++.h>
using namespace std;

const int N=2003,K=1e6+6;

int t,n,m,sx,sy,k,g[N][N];
int d[4][2]={{-1,0},{0,1},{1,0},{0,-1}};//上下左右依次存在d中
bool val[N*N],del[N*N];//val存是否被移动过，del存是否被删除，注意数组大小
char s[K];

int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d%d%d%s",&n,&m,&sx,&sy,&k,s+1);
        for(int i=1,cnt=0;i<=n;i++)
            for(int j=1;j<=m;j++)
                g[i][j]=++cnt,val[g[i][j]]=del[g[i][j]]=0;
        //从上到下，从左到右，从1开始给每一个格子上的箱子编号，方便统计
        int x=sx,y=sy,p=0;//x,y存机器人现在的坐标，p存方向
        del[g[x][y]]=1,g[x][y]=0;//删除起点上的箱子
        for(int i=1;i<=k;i++){
            if(s[i]=='A')
                p=(p+3)%4;//左转
            else if(s[i]=='D')
                p=(p+1)%4;
            else if(s[i]=='W'){
                int xx=x+d[p][0],yy=y+d[p][1];
                if(g[xx][yy]){
                    int xxx=xx+d[p][0],yyy=yy+d[p][1];
                    if(0<xxx && xxx<=n && 0<yyy && yyy<=m)
                        del[g[xxx][yyy]]=1,g[xxx][yyy]=g[xx][yy],val[g[xx][yy]]=1;
                    else
                        del[g[xx][yy]]=1;
                    //前方的前方有箱子（无箱子就是0，不影响统计）删，挪动前方的箱子，标记为移动过
                    //越界直接删
                    g[xx][yy]=0;
                }
                x=xx,y=yy;
            }else if(s[i]=='S'){
                int xx=x+d[(p+2)%4][0],yy=y+d[(p+2)%4][1];
                if(g[xx][yy])
                    del[g[xx][yy]]=1,g[xx][yy]=0;
                x=xx,y=yy;
                //后退，有箱子删
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(i==sx && j==sy)
                    printf("X");//起点要特判
                else
                    printf("%c",val[(i-1)*m+j] && !del[(i-1)*m+j]? 'S':'.');
                //如果被原本在该位置的箱子移动过且未被删除则在该格放置箱子
            }
            puts(""); 
        }
    }
    return 0;
}
```
有问题欢迎留言。

---

## 作者：wukaichen888 (赞：1)

考虑初始放满箱子，对每个格子维护当前处于该格子的箱子编号。向前移动即为合并箱子（如果两个位置都有箱子），尽可能保留被推过的箱子的编号，最后删除没被推过的箱子。容易做到线性 $O(nm+k)$。

```cpp
#include<bits/stdc++.h>
#pragma target("avx512f,sse1,sse2,sse3,sse4,sse4.2")
using namespace std;
#define ll long long
const int N=2005,M=4e6+5;
int t,n,m,op,sx,sy,tx,ty,k,id[M];char s[M];
bool vis1[M],vis2[M],ans[M];
int yyz(int x,int y){return (x-1)*m+y;}
bool check(int x,int y){return (x>=1)&&(y>=1)&&(x<=n)&&(y<=m);}
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d%d%d%s",&n,&m,&sx,&sy,&k,s+1);op=0;tx=sx,ty=sy;
		for(int i=1;i<=n*m;i++) id[i]=i,vis1[i]=ans[i]=0;
		id[yyz(sx,sy)]=0;
		for(int T=1,p;T<=k;T++){
			if(s[T]=='A') op=(op+3)&3;
			if(s[T]=='D') op=(op+1)&3;
			if(s[T]=='W'){
				sx+=dx[op],sy+=dy[op];
				if(check(sx+dx[op],sy+dy[op])){
					if(id[yyz(sx,sy)])
						id[yyz(sx+dx[op],sy+dy[op])]=id[yyz(sx,sy)],vis1[yyz(sx+dx[op],sy+dy[op])]=1;
				}
			}
			else if(s[T]=='S') sx-=dx[op],sy-=dy[op];
			id[yyz(sx,sy)]=vis1[yyz(sx,sy)]=0;
		}
		for(int i=1;i<=n*m;i++) if(vis1[i]) ans[id[i]]=1;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if((i==tx)&&(j==ty)) printf("X");
				else if(ans[yyz(i,j)]) printf("S");
				else printf(".");
			}
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：redfull66 (赞：0)

首先注意到能放墙就一定可以是空地，所以最优解一定没有墙。

先假设所有格子都放置箱子，然后模拟小 $\beta$ 的移动过程，若前进时前方两格都是箱子就可以用并查集维护合并箱子，后退时有箱子就删去这个箱子，最后输出有被移动的箱子。

一个细节：注意到 $T$ 没有限制，多测清空时只能手动清空。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[5]={-1,0,1,0},dy[5]={0,1,0,-1};
int T,n,m,x,y,p,a,b,xx,yy,fa[4000005],v[4000005],ans[4000005];
char c;
int read(int ans=0,bool f=0,char c=0){
    while(c<'0'||c>'9')c=getchar(),f|=(c=='-');
    while(c>='0'&&c<='9')ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return f?-ans:ans;
}
int main(){
	T=read();
	while(T--){
		n=read(),m=read(),a=x=read(),b=y=read(),p=0;
		for(int i=1;i<=n*m;i++)fa[i]=i,v[i]=ans[i]=0;
		fa[a*m-m+b]=0;
		while(c<'A'||c>'Z')c=getchar();
		while(c>='A'&&c<='Z'){
			p=(p+(c=='A'?3:(c=='D')))&3;
			if(c=='W'){
				x+=dx[p],y+=dy[p],xx=x+dx[p],yy=y+dy[p];
				if(xx&&xx<=n&&yy&&yy<=m&&fa[x*m-m+y])fa[xx*m-m+yy]=fa[x*m-m+y],v[xx*m-m+yy]=1;
			}
			if(c=='S')x-=dx[p],y-=dy[p];
			fa[x*m-m+y]=v[x*m-m+y]=0,c=getchar();
		}
		for(int i=1;i<=n*m;i++)ans[fa[i]]|=v[i];
		for(int i=1;i<=n;i++,putchar('\n'))
		    for(int j=1;j<=m;j++)
		        putchar(i==a&&j==b?'X':(ans[i*m-m+j]?'S':'.'));
	}
	return 0;
}

```

---


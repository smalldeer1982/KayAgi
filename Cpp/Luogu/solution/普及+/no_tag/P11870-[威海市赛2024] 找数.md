# [威海市赛2024] 找数

## 题目描述

喂喂喂？在不在？小威给你下发了一个任务：

给定 $n$ 和 $m$，从 $1 \sim n$ 中随意挑出 $m$ 个数，之后对选出的数排序，称为 $p$。

小威想知道，排序后的序列 $p$ 中，奇数位全为奇数，偶数位全为偶数的方案数，对 $998\ 244\ 353$ 取模。

很不巧，你在他问"在不在？"的时候就回复他了。这下不得不帮他解决问题了 :(

## 样例 #1

### 输入

```
2 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4 2```

### 输出

```
3```

## 样例 #3

### 输入

```
8 5```

### 输出

```
6```

# 题解

## 作者：Na1L0n9 (赞：4)

# Solution
## 前言
最后 5min 想出了解法然后没打完，写篇题解弥补遗憾。
## 思路
得到序列 $p$ 后，我们对于第 $i$ 位的数，把它的值加上 $i$。因为奇数一定在奇数位上，偶数一定在偶数位上，所以经过修改后的序列 $p$ 一定是一个全偶序列。显然，这个全偶序列的元素会在 $\left[ 1, n+m \right]$ 中分布，问题转化为：

**从 $\left[ 1, n+m \right]$ 中选出 $m$ 个偶数，求方案数。**

这就是一个简单的排列组合问题。

$ans=C_{\left\lfloor \frac{n + m}{2} \right\rfloor}^{m}$

## Code

```cpp
#include <bits/stdc++.h>
#define Write ios::sync_with_stdio(0);
#define by cin.tie(0);
#define AquaDaMean1e cout.tie(0);
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N = 2e6 + 10;
const int MOD = 998244353;
ll n, m, fac[N], inv[N];
int main() {
	Write by AquaDaMean1e
	cin >> n >> m;
	n = (n + m) / 2;
	inv[0] = inv[1] = fac[0] = 1ll;
	for (ll i = 2; i <= n; i++) {
		inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
	}
	for (int i = 1; i <= n; i++) {
		fac[i] = (fac[i - 1] * i) % MOD;
		inv[i] = (inv[i - 1] * inv[i]) % MOD;
	}
	cout << fac[n] * inv[m] % MOD * inv[n - m] % MOD;
	return 0;
}
```

---

## 作者：xxr___ (赞：1)

很巧妙的题。

首先因为合法的 $p$ 满足奇数位都是奇数，偶数位都是偶数，因为奇数加奇数等于偶数，偶数加偶数等于偶数。

所以把最后的 $p_i←p_i+i,i\in [1,m]$。就都变成了偶数，并且值域范围在 $[2,n+m]$。这个范围内一共有 $\lfloor \frac {n+m}{2}\rfloor$ 个偶数，所以答案就应该是 $C_{\lfloor \frac{n+m}{2}\rfloor}^{m}$ 时间复杂度 $O(n)$。

代码：
```cpp
#include<iostream>
#define ll long long
const ll mod = 998244353;
ll ksm(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&1ll){
			(ans*=x)%=mod;
		}
		y>>=1;(x*=x)%=mod;
	}
	return ans;
}
ll inv(ll x){
	return ksm(x,mod-2);
}
int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	ll n,m,a=1,b=1,c=1;
	std::cin>>n>>m;
	(n+=m)/=2;
	for(int i=1;i<=n;++i) (a*=i)%=mod;
	for(int i=1;i<=m;++i) (b*=i)%=mod;
	for(int i=1;i<=n-m;++i) (c*=i)%=mod;
	std::cout<<((a*=inv((b*=c)%mod))%=mod);
	return 0;
}
```

---

## 作者：ztd___ (赞：1)

只要注意力强大应该就能做出来的题啊，为什么没有题解呢。

首先我们运用强大的注意力发现，不管 $m$ 是多少，选择 $1$ 到 $m$ 这个序列是一定可以的。那么我们就会多出来 $n - m$ 个数字没有选。

我们把这 $n - m$ 个数字当作是空位，插进 $1$ 到 $m$ 这个序列里面。

接着运用强大的注意力发现，如果想要在两个数中间插进去若干个空位，插进去的空位数量必然是偶数。  
比如 $n = 4$，$m = 2$ 时，序列 $\lbrace 1, 2\rbrace$ 肯定可以，剩下了 $3$ 和 $4$ 作为空位。如果要把这两个空位插到序列中间，就必须把 $3$ 和 $4$ 一起放进 $1$ 和 $2$ 之间，只放一个的答案就不对了。

我们把两个空位看成一个球，能插空位的地方看成盒子。那问题就转化成：有 $m + 1$ 个盒子（因为序列的头尾也可以插），总共有 $\frac{n - m}{2}$ 个球，把所有球放进箱子里的方案数。其中至少要有一个盒子有球。

接着就是一个组合计数的板板了。

直接从 $1$ 到 $m + 1$ 枚举，代表有多少个盒子里有球。这样，问题就又被转化为：把 $\frac{n - m}{2}$ 个球放进 $i$ 个盒子里，每个盒子都要有球的方案数。

我们考虑插板法。问题相当于是把 $\frac{n - m}{2}$ 个球分成了 $i$ 个部分，每个部分放进一个盒子。相当于我们要插 $i - 1$ 个板子。然后插板子的空位共有 $\frac{n - m}{2} - 1$ 个，所以这部分的答案就是 $C_{\frac{n - m}{2} - 1}^{i - 1}$。

然后又因为我们是从 $m + 1$ 个空位里找 $i$ 个空位去插，所以要乘上一个 $C_{m + 1}^{i}$。

最终答案就是所有上面的东西的和。但是不要忘记特判 $n - m = 0$ 或 $n - m = 1$ 的情况，这时候没有球可以放，答案是 $1$。还有枚举 $i$ 的时候不能超过 $\frac{n - m}{2}$，原因显然，你不能把 $2$ 个球分成 $3$ 个部分吧。

至于组合数我采用了线性预处理逆元来计算，当然肯定是有别的办法的。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 77;
const int MOD = 998244353;
int inv[N], fac[N], n, m;
void _init() {
	inv[0] = inv[1] = fac[0] = fac[1] = 1;
	for (int i = 2; i <= 1e6; i++) {
		inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
		fac[i] = fac[i - 1] * i % MOD;
	}
	for (int i = 2; i <= 1e6; i++) {
		inv[i] = inv[i - 1] * inv[i] % MOD;
	}
}
int C(int n, int m) {
	return fac[n] * inv[n - m] % MOD * inv[m] % MOD;
}
signed main() {
    _init();
    cin >> n >> m;
    if (n == m) cout << 1;
    else if (n == m + 1) cout << 1;
    else {
        int a = (n - m) / 2;
        int b = m + 1;
        int ans = 0;
        for (int i = 1;i <= b && i <= a;i++) {
            ans = (ans + C(a - 1, i - 1) * C(b, i)) % MOD;
        }
        cout << ans % MOD;
    }
    return 0;
}
```

---

## 作者：reinforest (赞：0)

我们先考虑一个朴素 $dp$，设 $dp_{i,j}$ 表示第 $i$ 位填了 $j$ 的方案数，那么显然有以下的状态转移方程： 

$$dp_{i,j}= \begin{cases}
  \sum_{k=1}^{j-1} dp_{i-1,k} & i \mod 2 =j \mod 2\\
  0 & i \mod 2 \ne j \mod 2
\end{cases}$$

答案就是 $\sum_{i=1}^{n} dp_{m,i} $。

我们打印一下 $dp_{i,j}$ 找一下规律。


```
1 0 0 0 0 0 0 0 0 0 0 0 0 0 0  
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 
0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 
0 0 0 1 0 3 0 6 0 10 0 15 0 21 0 
0 0 0 0 1 0 4 0 10 0 20 0 35 0 56 0  
0 0 0 0 0 1 0 5 0 15 0 35 0 70 0 126 0 
0 0 0 0 0 0 1 0 6 0 21 0 56 0 126 0 252 
```


这些 $0$ 太讨厌了，我们考虑把 $0$ 去掉。

我们定义一个新的 $f_{i,j}$，它满足 $f_{0,1}=1$，$f_{i,j}= \sum_{k=1}^{j} f_{i-1,k} $。

那么有以下的式子。

$$dp_{i,j}= \begin{cases}
  f_{i,\frac{j-i+2}{2}} & i \mod 2 =j \mod 2\\
  0 & i \mod 2 \ne j \mod 2
\end{cases}$$

我们考虑如何快速求出 $f_{i,j}$。我们把 $f_{i,j}$ 打印出来看一下规律。（这里下标从 $0$ 开始）


``` 
0   1   0   0   0   0   0  
0   1   1   1   1   1   1  
0   1   2   3   4   5   6  
0   1   3   6   10  15  21 
0   1   4   10  20  35  56 
0   1   5   15  35  70  126 
0   1   6   21  56  126 252
```

把它斜过来看，就是杨辉三角！

因此 $f_{i,j}= \binom{i+j-2}{j-1}$。

所以我们有以下的式子。

$$dp_{i,j}= \begin{cases}
  f_{i,\frac{j-i+2}{2}}=\binom{\frac{i+j-2}{2}}{\frac{j-i}{2}} & i \mod 2 =j \mod 2\\
  0 & i \mod 2 \ne j \mod 2
\end{cases}$$

至此我们就可以把这道题做完了！因为要取模，所以我们可以预处理出阶乘以及逆元。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
constexpr ll modd=998244353,maxn=1e6+5;
ll fac[maxn],inv[maxn],a,b;
ll ksm(ll a,ll b){
	ll ret=1;
	while(b){
		if(b&1)ret=(a*ret)%modd;
		a=(a*a)%modd;
		b>>=1;
	}
	return ret;
}
void init(){
	fac[0]=1;
	for(int i=1;i<maxn;i++){
		fac[i]=(fac[i-1]*i)%modd;
	}
	inv[maxn-1]=ksm(fac[maxn-1],modd-2);
	for(int i=maxn-2;i>=0;i--){
		inv[i]=(inv[i+1]*(i+1))%modd;
	}
}
ll C(ll n,ll m){
	if(m>n || m<0)return 0;
	if(m==0)return 1;
	return ((fac[n]*inv[m])%modd*inv[n-m])%modd;
}
ll ans=0;
int main(){
	init();
	scanf("%lld%lld",&a,&b);
	for(int i=1;i<=a;i++){
		if(i%2==b%2){
			ans=(ans+C((b+i-2)/2,(i-b)/2))%modd;
		}
	}
	printf("%lld\n",(ans%modd+modd)%modd);
	return 0;
}
```

---


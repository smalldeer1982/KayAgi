# [威海市赛2024] 异或盒子 1

## 题目背景

"诶？我当数据结构？真的假的？"

## 题目描述

小威有一个神奇的异或盒子！

盒子中有 $n$ 个元素，每个元素都有一个权值 $v_i$。每当小威念出神秘咒语之时，盒子可以告诉小威，盒子中元素的异或和是多少。

有一天，这个盒子被小海发现了。小海问小威："我能不能向盒子提 $q$ 个要求？我希望改变盒子中某一个元素的权值，或者让所有元素的权值都 $+1$。除此之外，我还想念你那个神秘的咒语！""好啊，没问题啊。"

你可能想问，"那我呢？"

你就是这个神奇的异或盒子！现在请你满足小海的要求吧！

## 样例 #1

### 输入

```
5 5
1 1 1 1 1
2
1
2
0 1 3
2```

### 输出

```
1
2
3```

# 题解

## 作者：追梦之鲸 (赞：7)

这里提供一种 $\mathcal O(n \sqrt n)$ 的做法。

我们考虑开 $2^d$ 个桶，范围为 $[0, 2^d-1]$，每个桶用一个 vector 维护。考虑把每一个元素的二进制分两部分处理，把二进制下位数小于 $d$ 的部分（下文简称为低位）放到一个桶里统一处理，二进制下位数大于 $d$ 的部分（下文简称为高位）单独预处理

### 操作 0

在桶中找到 $v_x$ 的低位并删除，然后再异或掉 $v_x$ 的高位。然后再加入 $p$ 即可。

由于有操作 2，所以我们需要记录一个 $cnt$ 表示当前已经进行操作 2 的次数，$bs_i$ 表示第 $i$ 个元素的**低位**上次被修改时操作 2 的次数，然后就可以得到 $v_x$ 实际的低位。

由于用的是 vector 维护的桶，所以该操作时间复杂度为 $\mathcal O(n)$，瓶颈在于 vector 的插入和删除，但是由于 vector 极其优秀的常数导致很难跑满（而且出题人貌似没想到卡

### 操作 1

只需要把每个桶维护的 vector 传给下一个桶即可，若 $2^d$ 的桶里面有 vector，那么把里面的数的高位加一并把这个 vector 塞到 $0$ 号桶里即可。

时间复杂度均摊为 $\mathcal O(2^d + n / 2^d)$。

### 操作 2

遍历每个桶并异或，然后再加上之前高位的预处理即可。

时间复杂度为 $\mathcal O(2^d)$。

显然当 $d=\log(n) / 2$ 时时间复杂度为 $\mathcal O(n \sqrt n)$。，但我调的 $d = 10$ 时最慢的点才跑了 73ms（


### CODE
```cpp
#include<bits/stdc++.h>
namespace whaleL{
using namespace std;
#define pii pair<int, int>
#define fi first
#define se second
#define ull unsigned long long
#define ll long long
#define db double
#define re return
#define con continue
#define brk break
#define emp emplace
#define emb emplace_back
#define mpr make_pair
#define lwb lower_bound
#define upb upper_bound
#define all(x) x.begin(), x.end()
#define mms(a, b) memset(a, b, sizeof(a))
#define sml(a,b)(a=min(a,b))
#define big(a,b)(a=max(a,b))
#define fo(i,j,n)for(int i=(j);i<=(n);i++)
#define of(i,j,n)for(int i=(j);i>=(n);i--)
#define f(i,n)fo(i,1,n)
#define fr(i,n)of(i,n,1)
#ifdef _WIN32
#define getchar _getchar_nolock
#define putchar _putchar_nolock
#elif __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif
#define isd(c)((c)>47&&(c)<58)
#define iss(c)((c)<33)
#define il inline
#define tln template<typename m>
#define tls template<typename m,typename...ms>
#define getc(c) for(c=getchar();iss(c);c=getchar());
il void sf(){}il void ot(){}il void ut(){putchar('\n');}
tln il void sf(m&x){char f=1,c=getchar();x=0;for(;!isd(c);c=getchar())(c=='-')?f=-1:0;for(;isd(c);c=getchar())x=x*10+c-48;x*=f;}
tln il void ot(m x){x<0?x=-x,putchar('-'):0;static short s[51],t(0);do s[++t]=x%10;while(x/=10);for(;t;)putchar(s[t--]|48);}
il void sf(char&x){getc(x);}
il void ot(char x){putchar(x);}
il void sf(char*x){char c;getc(c);for(;!iss(c);c=getchar())*x++=c;*x=0;}
tln il void ot(m*x){while(*x)putchar(*x++);}
il void sf(string&x){x.clear();char c;getc(c);for(;!iss(c);c=getchar())x=x+c;}
il void ot(string x){printf("%s", x.c_str());}
il void sf(db&x){scanf("%lf", &x);}
il void ot(db x){printf("%lf", x);}
il void sf(long db&x){scanf("%Lf", &x);}
il void ot(long db x){printf("%Lf", x);}
tls il void sf(m&x,ms&...y){sf(x);sf(y...);}
tls il void ot(m x,ms...y){ot(x);ot(y...);}
tls il void ut(m x,ms...y){ot(x);putchar(' ');ut(y...);}
tln il void PC(m*a, m*b){for(;a!=b;cout<<*a++<<' ');ut();}
#ifndef ONLINE_JUDGE
#define err()cout<<"err "<<__LINE__,exit(0)
#define p(x...)(cout<<setw(18)<<#x,ot(" Line ",__LINE__," : "),ut(x))
#define pa(a, x...)(cout<<setw(18)<<#a,ot(" Line ",__LINE__," : "),ut(x))
#define po(x,y)(cout<<setw(18)<<#x,ot(" Line ",__LINE__," : "),PC(x,y))
#define g(x...) do{x;}while(0);
#else
#define err()1
#define p(x...)1
#define pa(x...)1
#define po(x...)1
#define g(x)
#endif
#ifndef DISFILE
#define file(x) freopen(#x ".in", "r", stdin), freopen(#x ".out", "w", stdout)
#else
#define file(x)
#endif
const ull MOD = 1e9 + 7;
#define mo(x)((1ULL*x)%MOD)
#define ma(x,y)(x=mo(y+(x)))
};using namespace whaleL;
const int N = 2e5 + 233;
const int d = 1023;
const int D = 262143 - 1023;
#define d(x) ((x) & d)
#define D(x) ((x) & D)

vector<int> e[N]; int en;
int a[N], p[N], bs[N];
int n, q, ans, cnt;

void add(int i) {
	int u = d(a[i]);
	if (!p[u]) p[u] = ++ en;
	e[p[u]].insert(upb(all(e[p[u]]), i), i);
	ans ^= D(a[i]);
}

signed main() {
	sf(n, q);
	f(i, n) 
		sf(a[i]), add(i);
	int op, i, v, u, res;
	f(awa, q) {
		sf(op);
		if (op == 0) {
			sf(i, v);
			ans ^= D(a[i]);
			u = p[d(a[i] + cnt - bs[i])];
			e[u].erase(lwb(all(e[u]), i));
			a[i] = v;
			add(i);
			bs[i] = cnt;
		}
		else if (op == 1) {
			cnt ++;
			fr(j, d + 1) //倒序
				p[j] = p[j - 1], p[j - 1] = 0;
			if (p[d + 1]) {
				for (int j : e[p[d + 1]]) {
					ans ^= D(a[j]);
					a[j] |= d, a[j] ++;
					ans ^= D(a[j]);
					bs[j] = cnt;
				}
				p[0] = p[d + 1];
			}
		}
		else if (op == 2) {
			res = 0;
			f(j, d) 
				if (e[p[j]].size() & 1) 
					res ^= j;
			ut(ans ^ res);
		}
	}
}

---

## 作者：ifffer_2137 (赞：2)

### 题意
单点改全局加 $1$ 全局 xor。
### 分析
01-trie 板子，oi-wiki 上有相关介绍。

  考虑直接 01-trie 比较难实现的只有全局加 $1$，由于加 $1$ 的特殊性，本质只需要找到极长后缀 $1$，所以我们考虑反转所有数字，这样就变成了极长前缀 $1$，在 trie 上就比较好做了，直接交换左右儿子单侧递归下去。

实现参考了 oi-wiki，维护每条边被经过的次数和子树 xor。

@IceKylin 暴力循环展开/指令集都通过了此题，根本不是人。
### 代码

```cpp
//From: ifffer_2137
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ull=unsigned long long;
using pii=pair<int,int>;
#define mkpr make_pair
#define x first
#define y second
#define popcnt __builtin_popcountll
inline int read(){
	char ch=getchar();int x=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=0;ch=getchar();}
	while(ch>='0'&&ch<='9')x=x*10+(ch^48),ch=getchar();
	return w?x:-x;
}
template<class T1,class T2>inline bool Cmn(T1 &x,T2 y){return y<x?x=y,1:0;}
template<class T1,class T2>inline bool Cmx(T1 &x,T2 y){return y>x?x=y,1:0;}
template<class T>inline void Dbg(T *a,int l,int r){for(int i=l;i<=r;i++)cout<<a[i]<<' ';cout<<'\n';}
mt19937 rnd(time(NULL));
constexpr int inf=0x3f3f3f3f;
constexpr int maxn=1e5+5;
constexpr int maxm=5e3+5;
constexpr int mod=998244353;
constexpr int base=2137;
constexpr int V=1e9;
constexpr int H=18;
constexpr int W=20;
constexpr int Z=26;
constexpr double eps=1e-9;
inline int Redu(int x){return x-(x>=mod)*mod;}
inline void Add(int &x,int y){x=x+y-(x+y>=mod)*mod;}
inline void _Add(int &x,ll y){x=(x+y)%mod;}
inline void Del(int &x,int y){x=x-y+(x-y<0)*mod;}
inline void _Del(int &x,ll y){x=(x-y)%mod;x+=(x<0)*mod;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int Pow(int a,int x){int s=1;for(;x;x>>=1,a=1ll*a*a%mod)if(x&1)s=1ll*s*a%mod;return s;}
bool Mem1;
int n,q,t;
int a[maxn];
class Bit_Trie{
private:
	int ch[maxn*W*2][2],w[maxn*W*2],val[maxn*W*2];
	int tot;
public:
	int rt;
	void init(){rt=tot=0;}
	void pushup(int u){
		w[u]=val[u]=0;
		if(ch[u][0]) w[u]^=w[ch[u][0]],val[u]^=val[ch[u][0]]<<1;
		if(ch[u][1]) w[u]^=w[ch[u][1]],val[u]^=(val[ch[u][1]]<<1)|(w[ch[u][1]]);
	}
	void insert(int &u,int x,int d){
		if(!u) u=++tot;
		w[u]^=1;
		if(d<0) return;
		insert(ch[u][x&1],x>>1,d-1);
		pushup(u);
	}
	void erase(int u,int x,int d){
		if(!u) return;
		w[u]^=1;
		if(d<0) return;
		erase(ch[u][x&1],x>>1,d-1);
		pushup(u);
	}
	void add(int u){
		if(!u) return;
		swap(ch[u][0],ch[u][1]);
		add(ch[u][0]);
		pushup(u);
	}
	int query(){return val[rt];}
}tr;
void Init(){}
void Clear(){}
void Mymain(){
	Clear();
	n=read(),q=read();
	for(int i=1;i<=n;i++) tr.insert(tr.rt,a[i]=read(),W-1);
	while(q--){
		int op=read();
		if(op==0){
			int x=read(),k=read();
			tr.erase(tr.rt,a[x]+t,W-1),tr.insert(tr.rt,k,W-1);
			a[x]=k-t;
		}else if(op==1){
			tr.add(tr.rt);
			t++;
		}else{
			cout<<tr.query()<<'\n';
		}
	}
}
bool Mem2;
signed main(){
	#ifdef LOCAL
	assert(freopen("data.in","r",stdin));
	assert(freopen("test.out","w",stdout));
	#endif
	cin.tie(0),cout.tie(0);
	Init();int _=1;
	while(_--) Mymain();
	cerr<<"Time: "<<1000.0*clock()/CLOCKS_PER_SEC<<" ms\n";
	cerr<<"Memory: "<<(&Mem1-&Mem2)/1024.0/1024.0<<" MB\n";
	return 0;
}
```

---

## 作者：Dream_poetry (赞：2)

### 思路：
01trie 模板题。

全局加一和查询就不赘述了，主要来考虑操作零。

这就是撤销和插入操作，但删除操作必须得到具体数值，所以我们思考过程如下：

我们设 $t$ 表示当前进行的全局加一的次数，$v_i$ 表示第 $i$ 个元素上次被修改时全局加一的次数，则得到 $A_x$ 增加了 $t-v_i$。

我们发现这极易维护，于是此题就做完了

### 代码:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int inf=0x3f3f3f3f;
const int mod=1e9+7;
const int seed=233;
const int N=2e5+10;

struct Trie{
    int ch[N*32][2],w[N*32],rt,tot,maxh;
	int val[N*32];
    #define ls ch[u][0]
    #define rs ch[u][1]
    Trie(){
        rt=tot=0,maxh=31;
    }
    int mknode(){
        ++tot;
        ch[tot][0]=ch[tot][1]=w[tot]=val[tot]=0;
        return tot;
    }
    void mallain(int u){
        val[u]=0,w[u]=w[ls]+w[rs];
        if(rs){
        	val[u]^=(val[rs]<<1)|(w[rs]&1);
		}
        if(ls){
        	val[u]^=val[ls]<<1;
		}
    }
    void insert(int &u,int x,int dep){
        if(!u){
        	u=mknode();
		}
        if(dep==maxh){
        	w[u]++;
        	return;
		}
        insert(ch[u][x&1],x>>1,dep+1);
        mallain(u);
    }
    void erase(int &u,int x,int dep){
        if(dep==maxh){
        	w[u]--;
        	return;
		}
        erase(ch[u][x&1],x>>1,dep+1);
        mallain(u);
    }
    void add(int u){
        if(rs) add(rs);
        swap(ls,rs);
        mallain(u);
    }
}trie;
int n,m;
int v[1000005];
int ct;
int A[1000005];


signed main(){
	cin>>n>>m; 
	for (int i=1;i<=n;i++){
		int x;
		cin>>x;
		A[i]=x;
		trie.insert(trie.rt,x,1);
	}
    while(m--){
        int op;
        cin>>op;
		if(op==0){
            int x,y;
            cin>>x>>y;
        	trie.insert(trie.rt,y,1);
            trie.erase(trie.rt,A[x]+(ct-v[x]),1);
		
        	v[x]=ct;
        	A[x]=y;
		}
		else if(op==1){
			ct++;
			trie.add(trie.rt);
        }
        else{
        	cout<<trie.val[1]<<'\n';
		}
    }
    return 0;
}
```

---

## 作者：CommandSR (赞：1)

## 题意

[link](https://www.luogu.com.cn/problem/P11872)

## 题解

考虑使用 01 Trie 维护这个序列。

记 $w_u$ 为 $u$ 到父节点的边的权值数量，即每加一个 $x$，$x$ 二进制拆分后对应路径权值加 $1$。

记 $val_u$ 为以 $u$ 为子树的异或和。

则可以 Pushup 维护这两个值。

```cpp
void Pushup(int rt) {
	tr[rt].w = tr[rt].val = 0;
	if (lc(rt)) tr[rt].w += tr[lc(rt)].w, tr[rt].val ^= (tr[lc(rt)].val << 1);
	if (rc(rt)) tr[rt].w += tr[rc(rt)].w, tr[rt].val ^= (tr[rc(rt)].val << 1) | (tr[rc(rt)].w & 1);
}
```

还需要一个 Insert 和 Erase 操作。一路递归下去，当递归到最大深度的时候加或减 $w_u$ 的值，然后一路 Pushup 上去。

对于操作三，直接输出 $val_1$。

对于操作二，加 $1$ 的过程就是把二进制最后的一段极长连续 $1$ 取反，可以一路交换左右儿子维护。

对于操作一，因为有全局区间加所以要打一个标记，每次操作把旧的值 Erase，然后把新的值 Insert 即可。

## Code

```cpp
// Problem: P11872
#include <bits/stdc++.h>
#define ll long long
#define sz(x) (int)x.size()
#define F(i, a, b) for (int i = (a); i <= (b); ++i)
#define D(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
inline ll rd() {
	ll x = 0; bool f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = 0; ch = getchar(); }
	while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return (f ? x : (-x));
}
const int N = 1e5 + 5;
namespace Trie {
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
	const int H = 25; // 开大一点便于全局 +1 时处理进位
	int tot = 0, root = 0;
	struct Node {
		int ch[2], val, w;
	} tr[N<<5];
	void Pushup(int rt) {
		tr[rt].w = tr[rt].val = 0;
		if (lc(rt)) tr[rt].w += tr[lc(rt)].w, tr[rt].val ^= (tr[lc(rt)].val << 1);
		if (rc(rt)) tr[rt].w += tr[rc(rt)].w, tr[rt].val ^= (tr[rc(rt)].val << 1) | (tr[rc(rt)].w & 1);
	}
	void Insert(int &rt, int x, int dep) {
		if (!rt) rt = ++tot;
		if (dep == H) { ++tr[rt].w; return; }
		Insert(tr[rt].ch[x & 1], x >> 1, dep + 1);
		Pushup(rt);
	}
	void Erase(int rt, int x, int dep) {
		if (dep == H) { --tr[rt].w; return; }
		Erase(tr[rt].ch[x & 1], x >> 1, dep + 1);
		Pushup(rt);
	}
	void Modify(int rt) {
		if (rc(rt)) Modify(rc(rt));
		swap(lc(rt), rc(rt));
		Pushup(rt);   
	}
}
using namespace Trie;
int n, q, a[N], adt, pdt[N];
int main() {
	n = rd(), q = rd();
	F(i, 1, n) a[i] = rd(), Insert(root, a[i], 1);
	F(i, 1, q) {
		int op = rd(), x, y;
		if (op == 0) {
			x = rd(), y = rd();
			Insert(root, y, 1), Erase(root, a[x] + adt - pdt[x], 1);
			pdt[x] = adt, a[x] = y;
		} 
		else if (op == 1) ++adt, Modify(root);
		else cout << tr[1].val << '\n';
	}
	return 0;
}
```

---

## 作者：__xxy_free_ioi__ (赞：1)

# 解法

01Trie 板板，具体可以先看[这里](https://oi-wiki.org/string/trie/#%E7%BB%B4%E6%8A%A4%E5%BC%82%E6%88%96%E5%92%8C)（~~真没什么好说的~~）。

主要说一下更改数值这一块。改变值可以看作先删除在插入。但是删哪个数捏？我们知道经过操作以后 $a_i$ 的值是会变化的呀！但是我们观察到操作永远只会将 $[1,n]$ 中的数增加一，所以，我们可以用一个懒标记 $tag$ 来记录增加的值（~~像不像万恶的线段树~~）和一个数组 $v$，表示 $v_i$ 已经使用了多少次加一操作，那么，很容易能得出，当前 $a_i$ 的值就是 $a_i + tag - v_i$，然后，维护一下 $a_i$ 与 $v_i$ 就可以了。

# 代码

```
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10, H = 19;

struct Bit_Tire {
    int idx = 0, rt = 0;
    int ne[N * H][2], cnt[N * H], xorv[N * H];
    int make() {
        idx++;
        ne[idx][0] = ne[idx][1] = cnt[idx] = xorv[idx] = 0;
        return idx;
    }
    void update(int u) {
        cnt[u] = xorv[u] = 0;
        if (ne[u][0]) {
            cnt[u] += cnt[ne[u][0]];
            xorv[u] ^= xorv[ne[u][0]] << 1;
        }
        if (ne[u][1]) {
            cnt[u] += cnt[ne[u][1]];
            xorv[u] ^= (xorv[ne[u][1]] << 1) | (cnt[ne[u][1]] & 1);
        }
        cnt[u] &= 1;
    }
    void insert(int &u, int x, int dep) {
        if (!u) u = make();
        if (dep == H) return cnt[u]++, void();
        insert(ne[u][x & 1], x >> 1, dep + 1);
        update(u);
    }
    void erase(int &u, int x, int dep) {
        if (dep == H) return cnt[u]--, void();
        erase(ne[u][x & 1], x >> 1, dep + 1);
        update(u);
    }
    void addall(int u) {
        swap(ne[u][0], ne[u][1]);
        if (ne[u][0]) addall(ne[u][0]);
        update(u);
    }
} t;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n, q, tag = 0;
    cin >> n >> q;
    vector<int> a(n + 10), v(n + 10);
    for (int i = 1, x; i <= n; i++)
        cin >> a[i], t.insert(t.rt, a[i], 1);
    while (q--) {
        int op, x, p;
        cin >> op;
        if (op == 0) {
            cin >> x >> p;
            t.erase(t.rt, a[x] + tag - v[x], 1);
            t.insert(t.rt, p, 1);
            a[x] = p, v[x] = tag; // 维护
        } else if (op == 1) tag++, t.addall(t.rt); // 增加操作，tag++
        else cout << t.xorv[t.rt] << '\n'; // 直接输出根节点的异或和即可
    }
    return 0;
}
```

---

## 作者：cancan123456 (赞：1)

异或粽子 Second Edition

考虑使用 01 trie 维护，从低位向高位建树，子树内维护异或和与数的个数，显然可以合并信息。

单点修改是好做的，删除一个数再插入一个数即可。

全局加一，首先考虑根节点的左右子节点应当互换，其次，被换到左子节点的子树也应当被全体加一，递归下去即可。

全局查询异或和就不用说了，输出根节点的子树内异或和即可。

时空复杂度均为 $O(n\log V)$，可以通过此题。

```cpp
#include <cstdio>
using namespace std;
const int N = 100005;
struct Node {
    int ch[2], dep, sum, cnt;
} node[65 * N];
int cnt, v[N];
void push_up(int p) {
    node[p].sum = node[node[p].ch[0]].sum ^ node[node[p].ch[1]].sum ^ ((node[node[p].ch[1]].cnt & 1) << node[p].dep);
	node[p].cnt = node[node[p].ch[0]].cnt + node[node[p].ch[1]].cnt;
}
void insert(int val, int delta = 1, int p = 1) {
    if (node[p].dep == 20) {
        node[p].sum = 0;
        node[p].cnt += delta;
    } else {
        int & ch = node[p].ch[(val >> node[p].dep) & 1];
        if (ch == 0) {
            cnt++;
            ch = cnt;
            node[ch].dep = node[p].dep + 1;
        }
        insert(val, delta, ch);
        push_up(p);
    }
}
void swap(int & a, int & b) {
    a ^= b ^= a ^= b;
}
void milthm(int p) {
    if (node[p].dep != 20 && p != 0) {
        swap(node[p].ch[0], node[p].ch[1]);
        milthm(node[p].ch[0]);
        push_up(p);
    }
}
int main() {
    // freopen("in.txt", "r", stdin);
    int n, q;
    scanf("%d %d", &n, &q);
    cnt = 1;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &v[i]);
        insert(v[i]);
    }
    int total_add = 0;
    for (int op, x, p; q != 0; q--) {
        scanf("%d", &op);
        if (op == 0) {
            scanf("%d %d", &x, &p);
            insert(v[x] + total_add, -1);
            v[x] = p - total_add;
            insert(p);
        } else if (op == 1) {
            total_add++;
            milthm(1);
        } else {
            printf("%d\n", node[1].sum);
        }
    }
    return 0;
}
```

---

## 作者：DrDuck (赞：0)

**前置芝士：字典树**

我们使用 $01$ 字典树来解决这个问题。

在 $01$ 字典树的每一个节点，记录两个值：一个是以它为根的子树内存的数的个数，记为 $sz$，还有一个是以它为根的子树的权值和（存在这个子树里的数在子树代表数位上的异或和），记为 $val$。每次插入数的时候**从低位向高位插入，也就是说节点深度越深，所代表的二进制位越高**。这个是下面的 `add` 函数有效的前提。

首先是 `pushup` 函数，也就是把左右儿子的信息上传给根节点。对于根节点对应的那一位二进制位，由于是异或，因此只有当子树中那一位是 $1$ 的数的个数是奇数时那一位才有贡献。因此这里可以只记 $sz$ 的奇偶性。
```cpp
void pushup(int p)
{
    val[p] = sz[p] = 0;
    if (ch[p][0])
    {
        sz[p] ^= sz[ch[p][0]];
        val[p] ^= val[ch[p][0]] << 1;
    }
    if (ch[p][1])
    {
        sz[p] ^= sz[ch[p][1]];
        val[p] ^= (val[ch[p][1]] << 1) | sz[ch[p][1]];
    }
}
```
其次是 `insert` 函数，也就是把一个数插入字典树。一路递归至底，如果遇到字典树还没有建出来的节点就新建一个，然后回溯的时候一路 `pushup` 就好了。
```cpp
void insert(int &cur, int x, int dep)
{
    if (!cur)
    {
        cur = ++tot;
    }
    sz[cur] ^= 1;
    if (!dep)
    {
        return;
    }
    insert(ch[cur][x & 1], x >> 1, dep - 1);
    pushup(cur);
}
```
然后是 `erase` 函数，也就是删除字典树中的一个数。几乎是一模一样的，因为把一个数异或两遍相当于消除了这个数的影响，所以本质上就是插入，不过遇到字典树还没有建出来的节点不用新建。
```cpp
void erase(int cur, int x, int dep)
{
    if (!cur)
    {
        return;
    }
    sz[cur] ^= 1;
    if (!dep)
    {
        return;
    }
    erase(ch[cur][x & 1], x >> 1, dep - 1);
    pushup(cur);
}
```
最后是 `add` 函数，也就是全局加 $1$。对于一个数而言，加 $1$ 实际上是找出这个数为 $0$ 且最低的位，然后将这一位和比它还低的位一起取反。对于字典树而言就是不停递归下一位为 $1$ 的子树，并且交换路径上节点的左右子树。这样就做到了低位取反的效果。
```cpp
void add(int cur)
{
    if (!cur)
    {
        return;
    }
    add(ch[cur][1]);
    swap(ch[cur][0], ch[cur][1]);
    pushup(cur);
}
```
有了这四个函数，做这道题就手到擒来了。

时间复杂度 $O(n \log V + q \log V)$，其中 $V$ 为值域上界。
# CODE
```cpp
#include<bits/stdc++.h>
#define int long long
#define void inline void
using namespace std;
const int maxn = 1e+5 + 5, kMaxN = maxn * 64, N = 20;
int tot, n, q, rt, sum;
int val[kMaxN], ch[kMaxN][2], a[maxn];
bool sz[kMaxN];
void pushup(int p)
{
    val[p] = sz[p] = 0;
    if (ch[p][0])
    {
        sz[p] ^= sz[ch[p][0]];
        val[p] ^= val[ch[p][0]] << 1;
    }
    if (ch[p][1])
    {
        sz[p] ^= sz[ch[p][1]];
        val[p] ^= (val[ch[p][1]] << 1) | sz[ch[p][1]];
    }
}
void insert(int &cur, int x, int dep)
{
    if (!cur)
    {
        cur = ++tot;
    }
    sz[cur] ^= 1;
    if (!dep)
    {
        return;
    }
    insert(ch[cur][x & 1], x >> 1, dep - 1);
    pushup(cur);
}
void erase(int cur, int x, int dep)
{
    if (!cur)
    {
        return;
    }
    sz[cur] ^= 1;
    if (!dep)
    {
        return;
    }
    erase(ch[cur][x & 1], x >> 1, dep - 1);
    pushup(cur);
}
void add(int cur)
{
    if (!cur)
    {
        return;
    }
    add(ch[cur][1]);
    swap(ch[cur][0], ch[cur][1]);
    pushup(cur);
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        int x;
        cin >> x;
        insert(rt, x, N);
        a[i] = x;
    }
    while (q--)
    {
        int op, x, p;
        cin >> op;
        if (op == 0)
        {
            cin >> x >> p;
            erase(rt, a[x] + sum, N);
            a[x] = p - sum;
            insert(rt, p, N);
        }
        else if (op == 1)
        {
            add(rt);
            sum++;
        }
        else
        {
            cout << val[rt] << '\n';
        }
    }
    return 0;
}
```

---

## 作者：algo_h (赞：0)

比赛结束后几秒钟调出来的，提交失败，写个题解纪念一下。

考虑每次“加一”操作对每个二进制位的影响（代码中的 $\mathrm{changes}$ 变量）。对每个数预处理出每个二进制位首次变化需要的“加一”次数并加入 $\mathrm{changes}$ 中（代码中的 $\mathrm{add\_num}$ 函数）后，该数第 $i$ 位再次变化还需要的“加一”次数就恒为 $2^i$ 了（代码中的 $\mathrm{update\_changes}$ 函数）。

在此基础上，可以动态维护 $\mathrm{changes}$，当需要改变一个数的时候，可以利用异或操作的幂等性，实现为在 $\mathrm{changes}$ 中同时加入原来的数和新的数的贡献（代码中 $\mathrm{main}$ 函数里的两次 $\mathrm{add\_num}$ 操作）；当需要执行“加一”操作时，利用 $\mathrm{changes}$ 中的信息直接更新答案即可。

时空复杂度 $O(n\log n)$（空间复杂度可以压缩到线性），目前最优解。

```c++
#include <array>
#include <iostream>
#include <vector>

#define endl '\n'

using namespace std;

int n, q;
vector<int> v;
vector<array<int, 20>> changes;

void add_num(int u, int o = 0)
{
  for(int i = 0; i < 20; ++i) {
    int j = o + (-u & ((1 << i) - 1));
    if(j > q) break;
    ++changes[j][i];  // 自然溢出
  }
}

void update_changes(int i)
{
  for(int j = 0; j < 20; ++j) {
    if(i - (1 << j) >= 0) changes[i][j] += changes[i - (1 << j)][j];  // 自然溢出
  }
}

int main()
{
  int ans = 0;
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> q;
  v.resize(n);
  changes.assign(q + 1, { 0 });
  for(int &u : v) cin >> u, add_num(u), ans ^= u;

  int s = 0;
  for(int i = 0; i < q; ++i) {
    int o, x, y;
    cin >> o;
    if(o == 0) {
      cin >> x >> y, --x;
      add_num(v[x] + s, s);
      ans ^= v[x] + s;
      v[x] = y - s;
      ans ^= v[x] + s;
      add_num(v[x] + s, s);
    } else if(o == 1) {
      update_changes(++s);
      for(int j = 0; j < 20; ++j) ans ^= (changes[s][j] & 1) << j;
    } else {
      cout << ans << endl;
    }
  }
  return 0;
}
```

---


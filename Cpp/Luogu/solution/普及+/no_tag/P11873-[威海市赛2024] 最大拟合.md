# [威海市赛2024] 最大拟合

## 题目描述

在某一个平行世界里，小威是 Z 校的 ML 大佬，精通于各种机器学习模型。某一天，他在路上观察到了一只活泼的小狗，小狗的叫声忽高忽低，时断时续。小威很快就意识到了，小狗是不是在按照某种模式发出声音？于是乎在那一刹那，他毫不犹豫地认为，小狗发声的模式也可以通过机器学习获得。但是很遗憾，他只记住了某一段连续的小狗的叫声。如果用 $H$ 代表小狗的清吠，$L$ 代表小狗的低吼，那么这段连续的叫声会被建模成一段 $H$ 和 $L$ 交织的序列……

此外，由于小威认为小狗是一种非常可爱专一但又健忘的动物，因此假定小狗的 attention 机制没有那么强，且在连续叫声中的第 $i$ 个声音只会与第 $i-1$ 和 $i-2$ 个声音有关。为了方便建模，小威认为小狗的每一段连续叫声都会由两声清吠开始。

那么，他的目标是什么呢？虽然他希望能构建出一个能模拟小狗叫声的模型，但是数据少得让他"巧妇难为无米之炊"啊。因此，他觉得，只要能在他记住的唯一的一段连续叫声上最大拟合就可以了。

在数学上，我们假定最后的模型为 $\theta$，可以被视为一个值域为概率的映射，即

$$
\theta: [L, H]^2 \times [L, H, \gamma] \to \mathbb P
$$

其中 $\gamma$ 表示序列的结束标志。例如 $\theta(L, H; L) = 0.6$，表示第 $i - 2$ 个声音是 $L$， 第 $i - 1$ 个声音是 $H$ 的情况下，第 $i$ 个声音是 $L$ 的概率是 $0.6$。

另外，小威把这段包含 $m$ 个声音的叫声序列称为 $s_{[1:m]}$，并把最大拟合目标定义为

$$
\max \prod_{i=3}^{m+1} \theta(s_{i-2}, s_{i-1}; s_{i})
$$

其中，$s_{m+1}$ 不是任何叫声，仅代表叫声序列的结束标志。

由于最终结果可能过小，因此小威只需要你告诉他最大拟合结果的自然对数就好。

## 样例 #1

### 输入

```
HHH
```

### 输出

```
-1.38629
```

## 样例 #2

### 输入

```
HHHLHHLLHL
```

### 输出

```
-6.59167
```

# 题解

## 作者：dg114514 (赞：4)

题目描述过于考语文，我们简化下题意：

> 定义 $f(i,a,b,c)$ 表示 $s_{i−2}=a$，且 $s_{i=1}=b$ 的情况下， $s_i=c$ 的概率。\
> 给定字符串 $s$，求出
> $$\ln\prod^{|s|+1}_{i=3}f(i,s_{i-2},s_{i-1},s_i)$$
> 其中，$s_{|s|+1}$ 代表字符串的结束标志。

思路十分简单，直接计算出所有对应的三元组出现的概率，然后由于要输出的是自然对数，可以变幻为 $\sum^{|s|+1}_{i=3} \ln f(i,s_{i-2},s_{i-1},s_i)$。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
map<pair<char,char>,map<char,int>>cnt;//三元组出现次数
map<pair<char,char>,map<char,double>>mp;//三元组出现概率
signed main(){
	string s;
	cin>>s;
	int n=s.size()+1;
	s=" "+s+"&";//'&' 就是结束标记
	for(int i=3;i<=n;i++)
		cnt[{s[i-2],s[i-1]}][s[i]]++;//三元组出现次数
	for(auto &i:cnt){
		int res=0;
		for(auto &j:i.y) res+=j.y;//总共的 c
		for(auto &j:i.y) mp[{i.x.x,i.x.y}][j.x]=cnt[{i.x.x,i.x.y}][j.x]*1./res;//计算概率：i.x.x 是 a，i.x.y 是 b，j.x 就是 c。
	}
	double ans=0;
	for(int i=3;i<=n;i++)
		ans+=log(mp[{s[i-2],s[i-1]}][s[i]]);
	printf("%.10lf",ans);
} 
```

### 后记

纯纯语文神题。

---

## 作者：lottle1212__ (赞：3)

# [最大拟合](https://www.luogu.com.cn/problem/P11873)

## 题意

只有小学数学知识的我看不懂一点。

记叫声为 $0, 1$ 以及结束标志为 $2$。

简单来说就是构造一些三元组 $(u, v, w) (u\in[0, 1], v\in[0, 1], w\in[0, 2])$，使其值不小于 $0$，不大于 $1$，且 $(u, v, 0)+(u, v, 1)+(u, v, 2)=1$。即 $cnt_{u, v, w}$ 为 $s$ 中 $s_i=u, s_{i+1}=v, s_{i+2}=w (i\in[1, n-1])$ 的个数，要求最大化 $w=\prod_{u\in\{0, 1\}, v\in\{0, 1\}, w\in\{0, 1, 2\}, cnt_{u, v, w}>0} (u, v, w)^{cnt_{u, v, w}}$，输出 $\ln w$。

## 解法

如果直接乘，精度损失也会导致算出了答案求不出对数。而题中要求输出对数就是一个提示，即把乘法操作换成对数操作。则 $w=\sum cnt_{u, v, w}\ln(u, v, w)$。而 $cnt$ 是容易统计的，因此重点在考虑对数操作。首先对于每一对 $u, v$，有 $\sum (u, v, w)=1$，因此考虑对每一对 $u, v$ 分别计算贡献。若 $(u, v, w)$ 非最后的三元组，则只有 $w$ 为 $0$ 或 $1$ 时 $(u, v, w)$ 才有可能大于 $0$。先考虑这种情况。

我们可以把它写成 $\max_{a>0, b>0, 0<p<1} a\ln(p)+b\ln(1-p)$。对 $\max$ 里的式子求导得 $\frac a{p}-\frac b{(1-p)}$，使其为 $0$，解得 $p=\frac a{a+b}$。而观察函数图像，是中间高两边低的，所以导数为 $0$ 时取到最大值。即 $p=\frac a{a+b}$ 时最大。

三元时同理，结论与二元类似。设其系数为 $a, b, c$，则 $p_a=\frac a{a+b+c}, p_b=\frac b{a+b+c}, p_c=\frac c{a+b+c}$。

### Code

```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <bitset>
#include <math.h>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <map>
#define fst first
#define scd second
#define db double
#define ll long long
#define mp make_pair
#define pb push_back
#define eb emplace_back
#define vi vector <int>
#define pii pair <int, int>
#define sz(x) ((int)x.size())
#define ms(f, x) memset(f, x, sizeof(f))
#define L(i, j, k) for (int i=(j); i<=(k); ++i)
#define R(i, j, k) for (int i=(j); i>=(k); --i)
#define ACN(i, H_u) for (int i=H_u; i; i=E[i].nxt)
using namespace std;
template <typename INT> void rd(INT &res) {
	res=0; bool f=false; char ch=getchar();
	while (ch<'0'||ch>'9') f|=ch=='-', ch=getchar();
	while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^48), ch=getchar();
	res=(f?-res:res);
}
template <typename INT, typename...Args>
void rd(INT &x, Args &...y) { rd(x), rd(y...); }
//dfs
const int maxn=1e5;
const int N=maxn+10;
char s[N]; int n, a[N], cnt[2][2][3];
//wmr

//incra

//lottle
signed main() {
//	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	scanf("%s", s+1); n=strlen(s+1);
	L(i, 1, n) a[i]=(s[i]=='H'?0:1); a[++n]=2;
	L(i, 1, n-2) ++cnt[a[i]][a[i+1]][a[i+2]];
	db ans=0;
	L(i, 0, 1) L(j, 0, 1) {
		int x=cnt[i][j][0], y=cnt[i][j][1], z=cnt[i][j][2];
		if (x+y+z) {
			if (x) ans+=x*log(1.0*x/(x+y+z));
			if (y) ans+=y*log(1.0*y/(x+y+z));
			if (z) ans+=z*log(1.0*z/(x+y+z));
		}
	}
	printf("%.6lf\n", ans);
	return 0;
}
```

---


# [威海市赛2024] 收徒！

## 题目描述

小威和小海正在玩《铁斧斧之争》。

小威给小海狠狠上了一课，在这局游戏中获得了第一名。小威很兴奋，大喊："收徒！"小海很不服，给他提了一个问题，并且要求他解决，不然就再也不和他玩了。小威立马同意了。

问题是这样的：在《铁斧斧之争》中，有一个 $H$ 行 $W$ 列的棋盘，令 $(i, j)$ 表示从上往下数第 $i$ 行，从左往右数第 $j$ 列的单元格。在这个棋盘中分布着 $N$ 个棋子，当小威经过 $(R_i, C_i)$ 格时可以获得第 $i$ 个棋子，获得 $1$ 的战斗力。小海想知道，如果小威从 $(1, 1)$ 开始，反复向下或向右移动一个格子，最终到达 $(H, W)$ 时，能最多获得多少战斗力？

小威立马秒了，但小海捂住了他的嘴，继续说：除此之外，我还想知道你是如何获得最多战斗力的，你还要告诉我获得最多战斗力的这条路径。

小威："……"

你能帮帮他吗？

## 说明/提示

对于第一组样例，一种可行的方案如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/80h1dm5w.png)

移动路径为 $(1, 1) \to (2, 1) \to (2, 2) \to (2, 3) \to (3, 3) \to (3, 4)$，可以在 $(2, 1), (2, 3), (3, 3)$ 处得到三个棋子。

## 样例 #1

### 输入

```
3 4 4
1 4
2 1
2 3
3 3```

### 输出

```
3
DRRDR```

# 题解

## 作者：cqs_130 (赞：3)

# *题目描述*

给 定一个 $h\times w$ 的棋盘，以及 $N$ 个棋子，从棋盘左上角出发，每次向下或向右移动一个单位，求到达右下角时可以经过的最多棋子数。


# *思路分析*

## 1.暴力思路

构建一个数组容器，每次弹出一个并压入向下和向右俩个方向。明显不行。

## 2.棋盘 dp 思路

思路类似于经典入门动态规划题目[过河卒](https://www.luogu.com.cn/problem/P1002)但是问题在于本题棋盘大小为 $2\times10^5$，因此不仅时间不通过，空间也会爆。

## 3.棋子 dp 思路

观察题目，我们发现棋子的数量为 $2\times10^5$，因此我们不难想到可以从记录棋盘状态转变为记录棋子的状态。

**重点：我们可以发现对于任意的棋子，他都是由他左上方的棋子或者是 $(1,1)$ 走过来的。而这个来源的棋子是从 $(1,1)$ 走到左上方所有棋子中的最大值的那个棋子。**

举例：我们缩小棋子数量，有一个 $2\times3$ 的棋盘，只有俩个棋子为 $(1,2)$ 和 $(2,3)$，且第一个棋子在第二个棋子的左上方，那么到达第二个棋子的时候必定经过第一个棋子。

因此，具体思路为开一个 $f$ 数组，$f_i$ 中所储存的棋子表示为从 $(1,1)$ 到此棋子的最大值为 $i$。例如上面，$(1,2)$ 存在 $f_1$ 中，$(2,3)$ 存在 $f_2$ 中。遍历所有棋子，用变量 $ma$ 记录目前遍历过的棋子的最大的值，令 $dq$ 变量为 $ma$ 开始遍历，若发现其中储存的棋子是在当前棋子的左上角的（即可以通过该棋子到达当前遍历的棋子）视为找到了，存入 $f_{dq+1}$，并且跳出循环，修改 $ma$ 为 $\max(ma,dq+1)$，若 $f_{dq}$ 遍历完了没找到则 $dq$ 减 $1$。若 $dq$ 到 $0$ 了则直接存入 $f_1$，同时更新 $ma$，同时开一个 $ly$ 表示来源的数组记录每个棋子是从那个棋子过来的，每次存入 $f$ 数组之后对 $ly$ 数组进行更新操作。最后依据 $ly$ 数组进行回溯即可。

时间复杂度最大为 $O(n^2)$ 空间问题解决了，但是依旧超时。


## 4.棋子 dp 及二分思路（AC 思路）
我们发现对于每个棋子，若找了的可以从左上角来的棋子，若记从 $(1,1)$ 到来的棋子的最大值为 $k$，那么对于 $f_{i<k}$ 的数组中，肯定会有若干个棋子可以走到当前遍历的棋子。因此，我们令 $l$ 为 $1$，$r$ 为 $ma$。若 $f_{mid}$ 中存在可以走来的棋子修改 $l$，不存在则修改 $r$。记录可行的最大的 $mid$，初始为 $0$。压入 $f$ 并更新 $ma$ 和 $ly$ 数组。时间复杂度为 $O(n\times \log_n)$。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;

vector<int>m[N];

struct node{
	int xx;
	int yy;
}f[N];

bool cmp(node a,node b){
	if(a.xx==b.xx){
		return a.yy<b.yy;
	}else{
		return a.xx<b.xx;
	}
}
int ly[N];

int main(){
	int h,w,n;
	cin>>h>>w>>n;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&f[i].xx,&f[i].yy);
	}
	sort(f,f+n+1,cmp);//不能不要 
	int ma=0;
	for(int i=1;i<=n;i++){
		int l=1,r=ma;
		int dqll=0;
		int dq=0;
		while(l<=r){
			int mid=l+r>>1;
			int flag=0;
			int ll;
			for(int k:m[mid]){
				if(f[k].yy<=f[i].yy){
					flag=1;
					ll=k;
					break;
				}
			}
			if(flag){
				if(mid>dq){
					dq=mid;
					dqll=ll;
				}
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		
		ma=max(ma,dq+1);
		ly[i]=dqll;
		m[dq+1].push_back(i);
	}
	
	int ans=m[ma][0];
	string s="";
	int prow=ans;
	int dqi=h;
	int dqj=w;
	while(1){
		int proi=f[prow].xx;
		int proj=f[prow].yy;
		if(prow==0){
			proi=1;
			proj=1;
		}
		string dqs="";
		for(int i=proi;i<dqi;i++){
			dqs+='D';
		}
		for(int i=proj;i<dqj;i++){
			dqs+='R';
		}
		s=dqs+s;
		dqi=proi;
		dqj=proj;
		if(prow==0)break;
		
		prow=ly[prow];
		
	}
	cout<<ma<<endl;
	cout<<s<<endl;
}

/*
0 0 1 1 1 
0 0 0 0 1
0 0 0 1 0
0 0 0 1 0
0 0 0 1 0


5 5 7
1 3
1 4
1 5
2 5
3 4
4 4
5 4

*/
```
蒟蒻第一次写题解，写的不好还请见谅，欢迎大家提问及纠错，最后求审核大大通过。

---

## 作者：kuaiCreator (赞：1)

## 题目大意
给定一个 $H\times W$ 的空白方格，从中选出 $n$ 个点附上 $1$ 的价值。问从 $(1,1)$ 走到 $(H,W)$ 只能向下和向右前行，所能获得的最大价值，并输出路径。
## 解题思路
#### 部分分思路
很容易想到坐标动态规划，然后用数组记录每次决策的转移方向。但是 $H$ 和 $W$ 很大不能开这么大的数组，否则会炸空间。
代码如下：
```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5e3+5;
int h, w, n, x, y;
int dp[N][N], mp[N][N];
char pre[N][N];
void dfs(int x, int y) {
	if (x == 1 && y == 1) return ;
	if (pre[x][y] == 'D')	dfs(x - 1, y);
	else	dfs(x, y - 1);
	cout << pre[x][y];
}
int main() {
	cin >> h >> w >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x >> y;
		mp[x][y] = 1;
	}
	for (int i = 2; i <= n; i++)
		dp[i][1] = dp[i - 1][1] + mp[i][1], pre[i][1] = 'D';
	for (int j = 2; j <= w; j++)
		dp[1][j] = dp[1][j - 1] + mp[1][j], pre[1][j] = 'R';
	for (int i = 2; i <= h; i++)
		for (int j = 2; j <= w; j++) {
			if (dp[i - 1][j] > dp[i][j - 1]) {
				pre[i][j] = 'D';
				dp[i][j] = dp[i - 1][j] + mp[i][j];
			} else {
				pre[i][j] = 'R';
				dp[i][j] = dp[i][j - 1] + mp[i][j];
			}
		}
	cout << dp[h][w] << endl;
	dfs(h, w);
	return 0;
}
```

#### 满分思路
考虑到数据范围很大，显然不能直接坐标动态规划。由于只能向下向右并且价值为 $1$。 可以考虑把问题转换为最长不下降子序列问题，用效率为 $O(n\log{n})$ 的贪心和二分方法计算答案。即从 $n$ 个按 $x$ 坐标从小到大排序的点中找到一条最长的一条链。答案可以直接构造。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int h, w, n, c[N], dp[N], nowx[N], nowy[N], k;
int pre[N];		//记录第i个数的前一项的下标
int lst[N];		//记录长度为len的最后一项的下标
string ans;
struct node {
	int x, y;
	bool operator<(node &b) {
		if (x == b.x) return y < b.y;
		return x < b.x;
	}
} a[N];
void dfs(int now) {
	if (now == 0) return;
	dfs(pre[now]);
	++k;
	nowx[k] = a[now].x, nowy[k] = a[now].y;
}
int main() {
	cin >> h >> w >> n;
	for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y;
	sort(a + 1, a + 1 + n);
	dp[1] = a[1].y;
	lst[1] = 1, pre[1] = 0;
	int len = 1;
	for (int i = 2; i <= n; i++) {
		if (dp[len] <= a[i].y) {		//如果这一项能接在最长的一项后面
			pre[i] = lst[len];			//当前项的前驱为之前长度为len的最小的最长项
			dp[++len] = a[i].y;			//记录当前长度为len的子序列的最后一项
			lst[len] = i;				//记录当前长度为len的最后一项的下标
		} else {
			int x = upper_bound(dp + 1, dp + 1 + len, a[i].y) - dp;	//查找等于len的
			pre[i] = lst[x - 1];
			dp[x] = a[i].y;
			lst[x] = i;
		}
	}
	cout << len << endl;
	nowx[1] = nowy[1] = k = 1;
	dfs(lst[len]);						//递归记录路径
	++k, nowx[k] = h, nowy[k] = w;
	for (int i = 2; i <= k; i++) {		//根据曼哈顿距离构造答案
		string D(nowx[i] - nowx[i - 1], 'D');
		string R(nowy[i] - nowy[i - 1], 'R');
		ans += D + R;
//		cout << nowx[i] << " " << nowy[i] << endl;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：fire_star_ (赞：0)

参考文献：[此篇题解](https://www.luogu.com.cn/article/fnvc233x)。

简洁题面：

给定一个 $h \times w$ 的棋盘，以及 $N$ 个棋子，小威从棋盘左上角出发，每次向下或向右移动一个单位，求到达右下角时可以经过的最多棋子数。

分析：

小威只能从左往右，从上往下走，所以可以使用贪心中的最长不下降子序列。对行的大小排序之后的列数作为大小，然后记录每个数进入序列中的前一个数，最后输出。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int h, w, n, num[N], tot, idd[N];
struct node {
	int x, y, id, fr;
} a[N];
bool cmp(node a, node b) {
	if (a.y == b.y)return a.x < b.x;
	return a.y < b.y;
}
void dfs(int x) {
	if (a[x].fr) dfs(a[x].fr);
	node v = a[a[x].fr];
	for (int i = v.x; i < a[x].x; i++) cout << "R";
	for (int i = v.y; i < a[x].y; i++) cout << "D";
}
int main() {
	cin >> h >> w >> n;
	a[0].x = a[0].y = 1;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].y >> a[i].x;
	}
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++) {
		a[i].id = i;
		if (a[i].x >= num[tot]) {
			a[i].fr = idd[tot];
			idd[++tot] = i;
			num[tot] = a[i].x;
		} else {
			int x = upper_bound(num + 1, num + tot + 1, a[i].x) - num;
			idd[x] = i;
			a[i].fr = idd[x - 1];
			num[x] = a[i].x;
		}
	}
	cout << tot << '\n';
	a[n + 1] = {w, h, 0, idd[tot]};
	dfs(n + 1);
	return 0;
}

```

---

## 作者：Needna (赞：0)

题意分析，要从左上角到右下角，只能向右和向下，问最多能有多少收益。


因为动态规划要超空间，所以我们要用其他方法。对于每一行来说，只能从前往后，对于每一列，只能从上往下。所以可以把这个问题变成用贪心的最长不下降子序列。对行的大小排序之后的列数作为大小。最后记录一下每个数进入序列中的前一个数最后打印即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int h,w,n,num[N],tot,idd[N];
struct node{
	int x,y,id,fr;
}a[N];
bool cmp(node a,node b){
	if(a.y==b.y)return a.x<b.x;
	return a.y<b.y;
}
void dfs(int x){
	if(a[x].fr) dfs(a[x].fr);
	node v=a[a[x].fr];
	for(int i=v.x;i<a[x].x;i++) cout<<"R";
	for(int i=v.y;i<a[x].y;i++) cout<<"D";
}
int main(){
	cin>>h>>w>>n;
	a[0].x=a[0].y=1;
	for(int i=1;i<=n;i++){
		cin>>a[i].y>>a[i].x;
	}sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		a[i].id=i;
		if(a[i].x>=num[tot]){
			a[i].fr=idd[tot];
			idd[++tot]=i;
			num[tot]=a[i].x;
		}
		else{
			int x=upper_bound(num+1,num+tot+1,a[i].x)-num;
			idd[x]=i;
			a[i].fr=idd[x-1];num[x]=a[i].x;
		}
	}
	cout<<tot<<'\n';
	a[n+1]={w,h,0,idd[tot]};
	dfs(n+1);	
	return 0;
} 
```

---

## 作者：reinforest (赞：0)

我们设 $dp_i$ 表示为第 $i$ 个点的答案。

对于一个点 $(a,b)$，那么所有满足 $x \leq a$ 且 $y \leq b$ 的所有点的 $dp$ 的最大值都可以作为 $dp_i$ 的值。

如果我们按照横坐标为第一关键字，纵坐标为第二关键字排序以后，我们考虑每个点 $(a_i,b_i)$ 对于以后的点的 $dp$ 的贡献。

我们对于第 $x$ 行，开一个数组 $num_y$ 表示纵坐标为 $y$ 的答案，那么有点 $(a_i,b_i)$ 的答案就是 $\max_{k=1}^{b_i} num_k+1$。

我们考虑如何更新这个数组。实际上是每加上一个点 $(a_i,b_i)$ 后，实际上是把点 $num_{b_i}$ 的值更改为 $dp_i$。

我们考虑如何将行 $x-1$ 的数组继承到第 $x$ 行。发现先继承，然后在继承后的数组直接进行计算是正确的。这实际上与滚动数组优化背包的思想是差不多的。

这个数组需要满足单点修改，前缀查询最大值，可以用树状数组维护。

于是我们做完了第一问。

对于第二问，我们可以使用深度优先搜索找到一个符合条件的转移路径。注意到每次只能从 $dp$ 值为 $x$ 的点转移到 $dp$ 值为 $x+1$ 的点上，因此可以开一个 `vector` 去把所有的 $dp$ 值所对应的点存起来，找路径的时候只找 $dp$ 值为 $x+1$ 的点，判断转移是否合法即可。

还有一个显然的优化就是访问过的点可以不再访问。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
constexpr ll maxn=2e5+5;
vector<ll> clas[maxn];
ll dp[maxn],h,w,n,num[maxn];
struct poi{
	ll a,b;
}arr[maxn];
bool cmp(poi p,poi q){
	if(p.a==q.a)return p.b<q.b;
	else return p.a<q.a;
}
ll lowbit(ll k){
	return k&(-k);
}
void add(ll x,ll k){
	for(int i=x;i<maxn;i+=lowbit(i)){
		num[i]=max(num[i],k);
	} 
} 
ll query(ll x){//前缀最大 
	ll ret=-1e18;
	for(int i=x;i>0;i-=lowbit(i)){
		ret=max(ret,num[i]);
	}
	return ret;
}
ll ans[maxn];//向哪个方向走多长距离
bool vis[maxn];//是否走到过这个点 
void print(ll st,ll ed){
	for(int i=1;i<=arr[ed].a-arr[st].a;i++){
		putchar('D');
	}
	for(int i=1;i<=arr[ed].b-arr[st].b;i++){
		putchar('R');
	}
}
void dfs(ll cur,ll dep){
	vis[cur]=true;
	if(cur==n+1){
		for(int i=1;i<=dep;i++){
			print(ans[i-1],ans[i]);
		}
		exit(0);
	}
	for(auto i:clas[dp[cur]+1]){
		if(!vis[i] && arr[i].a-arr[cur].a>=0 && arr[i].b-arr[cur].b>=0){
			ans[dep]=i;
			dfs(i,dep+1);
		}		
	}
}
int main(){
	scanf("%lld%lld%lld",&h,&w,&n);
	for(int i=1;i<=n;i++){
		ll a,b;
		scanf("%lld%lld",&a,&b);
		arr[i]=(poi){a,b};
	}
	arr[0]={1,1};
	arr[n+1]={h,w};
	sort(arr,arr+n+2,cmp);
	int j=0; 
	for(int i=0;i<=n+1;i++){
		ll req=query(arr[i].b);
		dp[i]=req+1;
		add(arr[i].b,dp[i]);
	}
	for(int i=0;i<=n+1;i++){
		clas[dp[i]].push_back(i);
	}
	printf("%lld\n",dp[n+1]-2);//把多的棋子减掉即可 
	dfs(0,1);
	return 0;
} 
```

---


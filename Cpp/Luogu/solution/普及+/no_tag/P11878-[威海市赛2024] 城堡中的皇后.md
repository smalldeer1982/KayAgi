# [威海市赛2024] 城堡中的皇后

## 题目描述

2024 年 9 月 11-22 日，第 45 届国际象棋奥林匹克团体赛在匈牙利首都布达佩斯举行。小威，作为一个国际象棋爱好者，正在密切关注着这场比赛。

![](https://cdn.luogu.com.cn/upload/image_hosting/pe4k7psf.png)

 _图注：在第五轮比赛中，中国选手韦奕战胜西班牙选手，帮助中国队以 2.5:1.5 的比分战胜西班牙队_ 

现在，小威要向你介绍一些基础的国际象棋知识：

1. 国际象棋棋盘共有 8 行 8 列，**自左向右**以 $a \sim h$ 表示列，**自下而上**以 $1 \sim 8$ 表示行；
2. 每方各有一个国王、一个皇后、两个马、两个象、两个车以及八个兵。初始局面如下：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/jx82759s.png)
3. 国王可以攻击到它同一行、同一列、同一斜线上**一格内**的位置，例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/vr3q36zs.png)
   
   *图注：国王的攻击范围，箭头表示它能攻击到的位置*
4. 皇后可以攻击到它同一行、同一列、同一斜线上**任意格内**的位置，例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/0rotqghv.png)
   ![](https://cdn.luogu.com.cn/upload/image_hosting/2iwr4258.png)
5. 马可以攻击到形似"L"型的位置，且没有"蹩马脚"限制，例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/j13m76k7.png)
6. 象可以攻击到同一斜线上任意格内的位置，例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/8rldzs2a.png)
7. 车可以攻击到同一行、同一列上任意格内的位置，例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/vga2ifsj.png)
8. 兵可以攻击到前进方向上斜向一格内的位置，例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/xo2fdlh3.png)
9. 当王处于对方某个棋子的攻击范围内时，称作被将军（check），例如：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/m3qj07yf.png)
   
   *图注：此时黑方的王处于白方皇后的攻击范围内，黑方被将军*

我们使用 FEN 格式描述一个局面。FEN 格式是一个字符串，其中包含 7 个斜杠（/），将字符串分为 8 个部分 $s_{1..8}$。其中，$s_1$ 对应第 $8$ 行的内容，$s_2$ 对应第 $7$ 行的内容，以此类推。对于 $v = s_i$，$v_1$ 表示第 $a$ 列的内容，$v_2$ 表示第 $b$ 列的内容，以此类推。

请注意，$v$ 的长度不一定等于 8。

我们用 `R` 表示白方的车，`N` 表示白方的马，`B` 表示白方的象，`Q` 表示白方的皇后，`K` 表示白方的王，`P` 表示白方的兵，字符的小写格式对应黑方的棋子。

在字符串中还会出现 $1 \leq i \leq 8$ 的数字，表示出现了连续 $i$ 个没有棋子的空格。

例如，现在有一个局面：
   ![](https://cdn.luogu.com.cn/upload/image_hosting/psnnis20.png)

其对应的 FEN 为 `r1bq1rk1/pppp1ppp/2n2n2/2b1p3/2B1P3/1P3N2/PBPP1PPP/RN1Q1RK1`。

现在，小威给你了一个使用 FEN 描述的局面，请你告诉他，是否有一方处于被将军的状态。


## 说明/提示

对于第三组样例，三个局面分别如下所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/c8gdly9e.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/y656nxud.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/uq352kqv.png)

## 样例 #1

### 输入

```
9
1nb1n1r1/1r1kp2p/1PpP2p1/6b1/P4NPP/N2R4/R1PPQP2/q1B1KB2
4k1nr/r2pbqpp/2n2B2/pb1p4/p4P2/8/2PPPNPP/R2QKB1R
2b3nr/rp1pb1Qp/4pk2/2p5/P2qPP1P/3B4/RPnP2R1/1NB2KN1
rn3k1r/1pRb1p1p/3b2p1/pB1pp2q/3PP3/P1P1nP2/1PK1Q3/RNB3N1
r1b1kb2/1pppn1p1/p4p1r/4P3/8/1n1P2R1/P1PKP3/RNBQ1B2
r1b3r1/p3bp1p/1p2p1pn/2p1kP2/1PPn3P/P2PpKP1/R3P1B1/1Nq3NR
3qkb1r/p1p1pn1Q/1rn1b3/3PP1p1/1p4p1/NP3P2/P2P2BP/R1B1K1NR
rnb1k1r1/p1qpbp2/2p2pp1/1p2P2Q/1P3PP1/P2P1N1K/2P5/1RB2B1R
r4bnk/ppp1pb2/5QPr/3pP3/q1Pn4/P2p4/1P1P1P1P/1RB1K1NR
```

### 输出

```
none
none
CHECK
check
check
check
none
none
CHECK
```

## 样例 #2

### 输入

```
3
r1bqkb2/pp1nnp1r/3Np2p/2p5/1P1P3p/P4P2/2PBP1P1/R2QKBNR
2r4r/2N1nk1n/pp2b2p/2pq1pP1/1PPpP1P1/7P/P2PK3/R1B2BNR
2b1k2r/3r2pp/3b4/1P6/p1B1p3/P3nN1q/1n1P1PR1/1RB2K2
```

### 输出

```
CHECK
none
check
```

## 样例 #3

### 输入

```
3
3k4/8/5P2/p3N3/P3N2p/3K4/8/7r
3k4/8/5P2/p3N3/P3N2p/3K4/8/3r4
r1bqkb1r/pppp1Qpp/2n2n2/4p3/2B1P3/8/PPPP1PPP/RNB1K1NR
```

### 输出

```
none
check
CHECK
```

# 题解

## 作者：ew3www (赞：3)

[原题链接](https://www.luogu.com.cn/problem/p11878)

# 分析

本题为大模拟，只要有耐心就能过。

其实，题目已经把绝大多数解题需要的信息告诉我们了，只需按题意模拟即可。

- 首先，找出两方国王 $k$ 和 $K$ 的位置，并存储进变量中。

- 然后，判断此时国王是否受对方棋子的攻击。

  攻击判定方法如下：

  - 判断国王的斜对角方向是否有对方的象或皇后；
  - 判断国王的竖直方向及水平方向上是否有对方的车或皇后；
  - 判断国王前方斜对角一格内是否有对方的兵；
  - 判断国王是否受马攻击；
  - 判断国王周围一圈内是否有对方的国王。

- 最后，若白方被将军，输出 $\texttt{check}$，若黑方被将军，输出 $\texttt{CHECK}$，若没有任何一方被将军，输出 $\texttt{none}$。

题目分析虽不难，但码量极大，一定要耐心的敲完！

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
bool at(int kr, int kc, bool iw, const vector<string>& b){ // 判断是否有一方被将军
    // 判断此时国王是否受兵攻击
    if(iw){
        int r = kr - 1, c = kc - 1;
        if(r >= 0 && c >= 0 && b[r][c]=='p') return true;
        r = kr - 1, c = kc + 1;
        if(r >= 0 && c < 8 && b[r][c]=='p') return true;
    }
    else{
        int r = kr + 1, c = kc - 1;
        if(r < 8 && c >= 0 && b[r][c]=='P') return true;
        r = kr + 1, c = kc + 1;
        if(r < 8 && c < 8 && b[r][c]=='P') return true;
    }
    // 判断国王此时是否受马攻击
    int kn[8][2] = {{-2,-1}, {-2,1}, {-1,-2}, {-1,2},
                    {1,-2}, {1,2}, {2,-1}, {2,1}};
    for(int i = 0; i < 8; i++){
        int r = kr + kn[i][0], c = kc + kn[i][1];
        if(r >= 0 && r < 8 && c >= 0 && c < 8){
            char p = b[r][c];
            if(iw && p=='n') return true;
            if(!iw && p=='N') return true;
        }
    }
    // 判断国王此时是否受皇后或车攻击
    int ro[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    for(int i = 0; i < 4; i++){
        int r = kr, c = kc;
        while(1){
            r += ro[i][0], c += ro[i][1];
            if(r < 0 || r >= 8 || c < 0 || c >= 8) break;
            char p = b[r][c];
            if(p != '.'){
                if(iw && (p=='r' || p=='q')) return true;
                if(!iw && (p=='R' || p=='Q')) return true;
                break;
            }
        }
    }
    // 判断国王此时是否受皇后或象攻击
    int bi[4][2] = {{-1,-1}, {-1,1}, {1,-1}, {1,1}};
    for(int i = 0; i < 4; i++){
        int r = kr, c = kc;
        while(1){
            r += bi[i][0], c += bi[i][1];
            if(r < 0 || r >= 8 || c < 0 || c >= 8) break;
            char p = b[r][c];
            if(p != '.'){
                if(iw && (p=='b' || p=='q')) return true;
                if(!iw && (p=='B' || p=='Q')) return true;
                break;
            }
        }
    }
    // 判断国王此时是否受另一方国王攻击
    int ki[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1},
                    {0,1}, {1,-1}, {1,0}, {1,1}};
    for(int i = 0; i < 8; i++){
        int r = kr + ki[i][0], c = kc + ki[i][1];
        if(r >= 0 && r < 8 && c >= 0 && c < 8){
            char p = b[r][c];
            if(iw && p=='k') return true;
            if(!iw && p=='K') return true;
        }
    }
    return false;
}
string pr(const string &s){ // 解析 FEN 格式的棋局
    string r = "";
    for(int i = 0; i < s.size(); i++){
        char ch = s[i];
        if(isdigit(ch)){
            int cnt = ch - '0';
            r.append(cnt, '.');
        }
        else r.push_back(ch);
    }
    return r;
}
int main(){
    int t;
    cin >> t;
    while(t--){
        string fen;
        cin >> fen;
        vector<string> p;
        string tk = "";
        for(int i = 0; i < fen.size(); i++){
            char ch = fen[i];
            if(ch=='/'){
                p.push_back(tk);
                tk = "";
            }
            else tk.push_back(ch);
        }
        p.push_back(tk);
        vector<string> b(8);
        for(int i = 0; i < 8; i++){
            b[i] = pr(p[i]);
            if(b[i].size() < 8)
                b[i].append(8 - b[i].size(), '.');
        }
        int wr = -1, wc = -1, br = -1, bc = -1;
        for(int i = 0; i < 8; i++){
            for(int j = 0; j < 8; j++){
                if(b[i][j]=='K'){
                    wr = i;
                    wc = j;
                }
                if(b[i][j]=='k'){
                    br = i;
                    bc = j;
                }
            }
        }
        if(wr != -1 && at(wr, wc, true, b))
            cout << "check" << "\n";
        else if(br != -1 && at(br, bc, false, b))
            cout << "CHECK" << "\n";
        else
            cout << "none" << "\n";
    }

    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/208106074)

珍惜生命，远离抄袭！

---

## 作者：qianyuzhe (赞：2)

很有意思的大模拟，这里提供一种不到 $1$ KB 的简洁写法。

## 题意简述

给定 $T$ 个国际象棋局面，对于每个局面判定是白方被将军，黑棋方将军还是不存在一方被将军，保证双方不会同时被将军。

## 题目分析

由于双方不会同时被将军，所以不会出现两王相接的情况。

注意到其它棋子的攻击范围可以分为两种：

- 马、兵：特定点位攻击，不会被棋子遮挡。
- 车、象、后：范围攻击，可能被棋子遮挡。

先找到一方王的位置，对于马、兵，直接判断即可；对于车、象、后，可以把攻击方向和名称存进结构体，在八个方向上不断移动判断能否遇到。

由于白、黑本质并无区别，把名称调换一下即可，注意判断兵的攻击方向。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int t,i,j,k;
string s,e[15];
struct D{int x,y;char z;};//用结构体存储各棋子的攻击特征 
bool pd(char K,char N,char P,char R,char B,char Q){//K为王的名称,N,P,R,B,Q分别为敌方马,兵,车,象,后的名称 
	for(i=2;i<=9;i++)for(j=2;j<=9;j++)if(e[i][j]==K){
		if(e[i-2][j-1]==N||e[i-2][j+1]==N||e[i-1][j-2]==N||e[i-1][j+2]==N||e[i+1][j-2]==N||e[i+1][j+2]==N||e[i+2][j-1]==N||e[i+2][j+1]==N||e[i+(K=='K'?-1:1)][j-1]==P||e[i+(K=='K'?-1:1)][j+1]==P)return 1;
		for(D d:{D{-1,0,R},{0,-1,R},{0,1,R},{1,0,R},{-1,-1,B},{-1,1,B},{1,-1,B},{1,1,B},{-1,0,Q},{0,-1,Q},{0,1,Q},{1,0,Q},{-1,-1,Q},{-1,1,Q},{1,-1,Q},{1,1,Q}})
			for(k=1;k<8;k++){
				if(e[i+d.x*k][j+d.y*k]==d.z)return 1;
				if(e[i+d.x*k][j+d.y*k]^'-')break;//若遇到非空格位置则退出 
			}
	}
	return 0;
}
main(){
	cin>>t;
	while(t--){
		for(i=2;i<=9;i++)for(j=2;j<=9;j++)e[i][j]='-';//初始化棋盘为空 
		cin>>s;
		for(i=0,j=k=2;i<s.size();i++){//j,k为棋盘坐标,为避免判断马,兵时越界将坐标范围改为2~9 
			if(s[i]=='/')j++,k=2;
			else isdigit(s[i])?k+=s[i]-48:e[j][k++]=s[i];
		}
		if(pd('K','n','p','r','b','q'))puts("check");
		else if(pd('k','N','P','R','B','Q'))puts("CHECK");
		else puts("none");
	}
}
```

---

## 作者：Hamburger999 (赞：1)

本题只需要模拟题意即可。

提示：这篇题解中的行号是从上到下按 $1 \sim 8$ 标号的，与题目描述相反。

### 1. 将读入的 FEN 格式的字符串转换成 $8 \times 8$ 的字符矩阵。

我们遍历读取的字符串，每读到一个 `/` 字符的时候便处理一行的内容。为了防止没读到最后一行的内容，我们将读取的字符串后面加上一个 `/`。

代码：


```cpp
void Read(int id,string str){
	int p=1;
	for(char ch:str){
		if('0'<=ch&&ch<='9'){
			for(int i=p;i<=p+(ch-'0')-1;i++) G[id][i]='.';
			p=p+(ch-'0');
		}
		else G[id][p]=ch,p++;
	}
}

void DeFEN(){
	string s,t="";int id=1;
	cin>>s,s+='/';
	for(char ch:s){
		if(ch!='/') t+=ch;
		else Read(id,t),t="",++id;
	}
}
```

### 2. 一些辅助函数

1. `chkpos` 函数

代码如下：


```cpp
bool chkpos(int x,int y){
	return x>=1&&x<=8&&y>=1&&y<=8;
}
```

这个函数用于检验坐标是否越界。

2. `to` 函数

代码如下：

```cpp
char to(bool x){
	return x?'k':'K';
}
```

由于下面很多函数都是形如 `bool chkK(int x,int y,bool p)` 形式的，其中变量 `p` 是用于表明棋子的类型（黑方/白方），我们用 `to(p)` 表示这颗棋子应该吃哪个王。

### 3. 各种棋子的将军判定

下面函数中，如果返回值为 $1$，表示这颗棋子将对方的王将军了，否则表示没有。

1. 王

王的攻击范围可以转化为：以它为中心的 $3 \times 3$ 矩阵（当然，不能攻击自身）。于是代码很好写。

代码如下：


```cpp
bool chkK(int x,int y,bool p){
	for(int i=-1;i<=1;i++) 
		for(int j=-1;j<=1;j++)
			if(chkpos(x+i,y+j)&&G[x+i][y+j]==to(p)) return 1;
	return 0;
}
```

2. 兵

兵只有两个攻击方向。依次判定即可。注意两种颜色的兵前进方向有不同。


```cpp
bool chkP(int x,int y,int p){
	if(p){
		if(chkpos(x-1,y+1)&&G[x-1][y+1]=='k') return 1;
		if(chkpos(x-1,y-1)&&G[x-1][y-1]=='k') return 1;
	}else{
		if(chkpos(x+1,y+1)&&G[x+1][y+1]=='K') return 1;
		if(chkpos(x+1,y-1)&&G[x+1][y-1]=='K') return 1;
	}
	return 0;
}
```
3. 车

**注意：车/象/皇后是无法隔着棋子攻击的！！！**

向上下左右 $4$ 个方向扩展即可。如果碰到棋子，是对方国王就返回 $1$，否则退出当前循环。

代码如下：

```cpp
bool chkR(int x,int y,int p){
	for(int i=1;i<=7;i++){
		if(chkpos(x,y+i)&&G[x][y+i]==to(p)) return 1;
		else if(chkpos(x,y+i)&&G[x][y+i]!='.') break;
	}
    for(int i=1;i<=7;i++){
		if(chkpos(x+i,y)&&G[x+i][y]==to(p)) return 1;
		else if(chkpos(x+i,y)&&G[x+i][y]!='.') break;
	}
	for(int i=-1;i>=-7;i--){
		if(chkpos(x,y+i)&&G[x][y+i]==to(p)) return 1;
		else if(chkpos(x,y+i)&&G[x][y+i]!='.') break;
	}
    for(int i=-1;i>=-7;i--){
		if(chkpos(x+i,y)&&G[x+i][y]==to(p)) return 1;
		else if(chkpos(x+i,y)&&G[x+i][y]!='.') break;
	}
	return 0;
}
```

4. 象

类似于车，不过是向左上左下右上右下 $4$ 个方向扩展的。

代码如下：


```cpp
bool chkB(int x,int y,int p){
	for(int i=1;i<=7;i++){
		if(chkpos(x+i,y+i)&&G[x+i][y+i]==to(p)) return 1;
        else if(chkpos(x+i,y+i)&&G[x+i][y+i]!='.') break;
	}
	for(int i=1;i<=7;i++){
		if(chkpos(x+i,y-i)&&G[x+i][y-i]==to(p)) return 1;
        else if(chkpos(x+i,y-i)&&G[x+i][y-i]!='.') break;
	}
    for(int i=-1;i>=-7;i--){
		if(chkpos(x+i,y+i)&&G[x+i][y+i]==to(p)) return 1;
        else if(chkpos(x+i,y+i)&&G[x+i][y+i]!='.') break;
	}
	for(int i=-1;i>=-7;i--){
		if(chkpos(x+i,y-i)&&G[x+i][y-i]==to(p)) return 1;
        else if(chkpos(x+i,y-i)&&G[x+i][y-i]!='.') break;
	}
	return 0;
}
```

5. 皇后

可以被视为车和象的叠加，调用一下 `chkR` 和 `chkB` 函数即可。

代码如下：


```cpp
bool chkQ(int x,int y,int p){
	return chkR(x,y,p)||chkB(x,y,p);
}
```

6. 马

共 $8$ 个方向，依次判定即可。


```cpp
bool chkN(int x,int y,int p){
	if(chkpos(x+1,y+2)&&G[x+1][y+2]==to(p)) return 1;
	if(chkpos(x+2,y+1)&&G[x+2][y+1]==to(p)) return 1;
	if(chkpos(x-1,y-2)&&G[x-1][y-2]==to(p)) return 1;
	if(chkpos(x-2,y-1)&&G[x-2][y-1]==to(p)) return 1;
	if(chkpos(x+1,y-2)&&G[x+1][y-2]==to(p)) return 1;
	if(chkpos(x+2,y-1)&&G[x+2][y-1]==to(p)) return 1;
	if(chkpos(x-1,y+2)&&G[x-1][y+2]==to(p)) return 1;
	if(chkpos(x-2,y+1)&&G[x-2][y+1]==to(p)) return 1;
	return 0;
}
```

### 4. 主函数

综合上面的函数即可。

代码如下：


```cpp
int main(){
	cin>>T;
	while(T--){
		DeFEN();
		bool Wcheck=0,Bcheck=0; 
		for(int i=1;i<=8;i++)
			for(int j=1;j<=8;j++){
				if(G[i][j]=='R') Wcheck|=chkR(i,j,1);
				if(G[i][j]=='r') Bcheck|=chkR(i,j,0);
				if(G[i][j]=='N') Wcheck|=chkN(i,j,1);
				if(G[i][j]=='n') Bcheck|=chkN(i,j,0);
				if(G[i][j]=='B') Wcheck|=chkB(i,j,1);
				if(G[i][j]=='b') Bcheck|=chkB(i,j,0);
				if(G[i][j]=='Q') Wcheck|=chkQ(i,j,1);
				if(G[i][j]=='q') Bcheck|=chkQ(i,j,0);
				if(G[i][j]=='K') Wcheck|=chkK(i,j,1);
				if(G[i][j]=='k') Bcheck|=chkK(i,j,0);
				if(G[i][j]=='P') Wcheck|=chkP(i,j,1);
				if(G[i][j]=='p') Bcheck|=chkP(i,j,0);
			}
		if(Wcheck) cout<<"CHECK\n";
		else if(Bcheck) cout<<"check\n";
		else cout<<"none\n";
	}
	return 0;
}
```

完整代码  [link](https://www.luogu.com.cn/paste/mmiztf13)

---

## 作者：yyycj (赞：1)

## 主要思路
一道没有什么思路难度的大模拟（打磨你）。

对于棋盘记录，$0$ 表示没有棋子；白兵、白马、白象、白车、白后、白王分别为 $1 \sim 6$；黑王、黑后、黑车、黑象、黑马、黑兵分别为 $-6 \sim -1$。

对于 FEN 到棋盘的转换，可以每一部分，可以记录一个 $col$ 变量并设数值为 $1$。如果这一段的第 $i$ 个字符是数字，则让 $col$ 加上这个数字；反之则在棋盘对应位置做转换并记录。最后不管当前是哪种字符，都 $col \gets col + 1$。

转换完成后，遍历棋盘，只要这个位置有棋子并且不是王，就判断当前棋子是否能将军对面的王；如果所有棋子都不能，就输出 `none`。

## AC Code
```cpp
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long ll;
typedef long double db;
const int INT_INF = 0x3f3f3f3f;
const ll LL_INF = 0x3f3f3f3f3f3f3f3f;
inline ll _abs(ll a) { if (a < 0) return -a; return a; }
const int dx[8] = {-1, -2, -2, -1, 1, 2, 2, 1}, dy[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
// ----------------------------

// ----------------------------
int board[10][10];
// ----------------------------
bool pawn(int x, int y, int f) {
	if (f == 1) {
		return (board[x - 1][y - 1] == -6 || board[x - 1][y + 1] == -6);
	}
	return (board[x + 1][y - 1] == 6 || board[x + 1][y + 1] == 6);
}

bool knight(int x, int y, int f) {
	int nx, ny;
	for (int i = 0; i < 8; i++) {
		nx = x + dx[i];
		ny = y + dy[i];
		if (board[nx][ny] == 6 * -f) return true;
	}
	return false;
}

bool bishop(int x, int y, int f) {
	int nx = x - 1;
	int ny = y - 1;
	while (nx > 0 && ny > 0 && board[nx][ny] == 0) {
		nx--;
		ny--;
	}  // 找到斜线上第一个棋子
	if (board[nx][ny] == 6 * -f) return true;
	nx = x - 1;
	ny = y + 1;
	while (nx > 0 && ny <= 8 && board[nx][ny] == 0) {
		nx--;
		ny++;
	}
	if (board[nx][ny] == 6 * -f) return true;
	nx = x + 1;
	ny = y - 1;
	while (nx <= 8 && ny > 0 && board[nx][ny] == 0) {
		nx++;
		ny--;
	}
	if (board[nx][ny] == 6 * -f) return true;
	nx = x + 1;
	ny = y + 1;
	while (nx <= 8 && ny <= 8 && board[nx][ny] == 0) {
		nx++;
		ny++;
	}
	if (board[nx][ny] == 6 * -f) return true;
	return false;
}

bool rook(int x, int y, int f) {
	int nx = x - 1;
	int ny = y;
	while (nx > 0 && board[nx][ny] == 0) nx--; // 找到直线上第一个棋子
	if (board[nx][ny] == 6 * -f) return true;
	nx = x + 1;
	ny = y;
	while (nx <= 8 && board[nx][ny] == 0) nx++;
	if (board[nx][ny] == 6 * -f) return true;
	nx = x;
	ny = y - 1;
	while (ny > 0 && board[nx][ny] == 0) ny--;
	if (board[nx][ny] == 6 * -f) return true;
	nx = x;
	ny = y + 1;
	while (ny <= 8 && board[nx][ny] == 0) ny++;
	if (board[nx][ny] == 6 * -f) return true;
	return false;
}

int transform(char c) {
	if (c == 'P') return 1;
	if (c == 'N') return 2;
	if (c == 'B') return 3;
	if (c == 'R') return 4;
	if (c == 'Q') return 5;
	if (c == 'K') return 6; 
	if (c == 'p') return -1;
	if (c == 'n') return -2;
	if (c == 'b') return -3;
	if (c == 'r') return -4;
	if (c == 'q') return -5;
	if (c == 'k') return -6; 
	return 0;
}

void write(bool f) {
	if (f) cout << "CHECK\n";
	else cout << "check\n";
}

int main() {
	int t; cin >> t;
	// ----------------------------
	bool flag;
	string fen;
	int idx, col;
	while (t--) {
		cin >> fen;
		idx = -1;
		memset(board, 0, sizeof board);
		for (int i = 1; i <= 8; i++) {
			idx++;
			col = 1;
			while (idx < (int)fen.length() && fen[idx] != '/') {
				if (isdigit(fen[idx])) col += fen[idx] - '0';
				else board[i][col++] = transform(fen[idx]);
				idx++;
			}
		}
		flag = false;
		for (int i = 1; i <= 8 && !flag; i++) {
			for (int j = 1; j <= 8; j++) {
				if (_abs(board[i][j]) == 1) { // 判断这个棋子是否为兵，白黑都可以
					if (pawn(i, j, board[i][j] / _abs(board[i][j]))) {
						flag = true;
						write(board[i][j] > 0);
						break;
					}
				}
				else if (_abs(board[i][j]) == 2) {
					if (knight(i, j, board[i][j] / _abs(board[i][j]))) {
						flag = true;
						write(board[i][j] > 0);
						break;
					}
				}
				else if (_abs(board[i][j]) == 3) {
					if (bishop(i, j, board[i][j] / _abs(board[i][j]))) {
						flag = true;
						write(board[i][j] > 0);
						break;
					}
				}
				else if (_abs(board[i][j]) == 4) {
					if (rook(i, j, board[i][j] / _abs(board[i][j]))) {
						flag = true;
						write(board[i][j] > 0);
						break;
					}
				}
				else if (_abs(board[i][j]) == 5) { // 后就是结合了象与车的走法，所以不需要单独再写一个函数
					if (bishop(i, j, board[i][j] / _abs(board[i][j])) ||
						rook(i, j, board[i][j] / _abs(board[i][j]))) {
							flag = true;
							write(board[i][j] > 0);
							break;
						}
				}
			}
		}
		if (!flag) cout << "none\n";
	}
	return 0;
}
```

---

## 作者：Dusker (赞：1)

# 城堡中的皇后

- 预期难度：铜-（黄）
- 关键词：~~读题~~、字符串处理、模拟

没啥好说的。读完题直接模拟就行了。

GPT-4o 写了一个不到一百行的 py 秒了（

彩蛋 1：本来标题是 Queen in the Rook，谐音 Queen in the rock 致敬传奇摇滚乐队皇后乐队。

彩蛋 2：第三组样例的局面 1 中，若此时轮到黑方走棋，则局面 2 为黑方的唯一着法。

局面 1 为第 45 届国际象棋奥林匹克团体赛第 7 轮中国队与印度队的比赛中，Gukesh D. 执白在第 71 回合走出 f6（兵 f6，国际象棋记谱方法中，代表兵的 P/p 可略去不写）形成的局面。实战中韦奕执黑走出了 h3?（? 代表坏棋），白棋胜势。

局面 2 为局面 1 下，黑方唯一可能的守和方式，即 Rd1+（车 d1 将军）。

彩蛋 3：第三组样例的局面 3，是初学者容易掉入的四步杀陷阱（

处理吃子逻辑时，可以利用黑方与白方大小写不同的性质，判断吃子时只需要判断 $\operatorname{islower}(u) \oplus \operatorname{islower}(v)$ 是否为真即可，而不用分黑白写两个函数。

此外，注意到 $\texttt{Q = R + B}$，即后的走法就是车和象的叠加，逻辑也可以简化一些。

时间复杂度为能过。

```cpp
#include<bits/stdc++.h>
#define ioclear std::ios::sync_with_stdio(false);std::cin.tie(nullptr);std::cout.tie(nullptr);
#define endl '\n'

using pii = std::pair<int, int>;

void solve()
{
    std::string s;
    std::cin >> s;
    std::vector<std::string> board(9);
    pii king, KING;
    int x = 8;
    for(auto v: s)
    {
        if(v == '/')
        {
            x--;
            continue;
        }
        if(!isdigit(v))
        {
            board[x] += v;
            continue;
        }
        for(int i = 0; i < v - '0'; i++)
            board[x] += '.';
    }
    for(int i = 1; i <= 8; i++)
        board[i] = '#' + board[i];
    for(int i = 1; i <= 8; i++)
        for(int j = 1; j <= 8; j++)
            if(board[i][j] == 'K')
                KING = {i, j};
            else if(board[i][j] == 'k')
                king = {i, j};

    auto checkRook = [&](int i, int j, std::set<pii>& s)
    {
        for(int k = i + 1; k <= 8; k++)
            if(board[k][j] == '.')
                s.insert({k, j});
            else
            {
                if(islower(board[k][j]) ^ islower(board[i][j]))
                    s.insert({k, j});
                break;
            }
        for(int k = i - 1; k >= 1; k--)
            if(board[k][j] == '.')
                s.insert({k, j});
            else
            {
                if(islower(board[k][j]) ^ islower(board[i][j]))
                    s.insert({k, j});
                break;
            }
        for(int k = j + 1; k <= 8; k++)
            if(board[i][k] == '.')
                s.insert({i, k});
            else
            {
                if(islower(board[i][k]) ^ islower(board[i][j]))
                    s.insert({i, k});
                break;
            }
        for(int k = j - 1; k >= 1; k--)
            if(board[i][k] == '.')
                s.insert({i, k});
            else
            {
                if(islower(board[i][k]) ^ islower(board[i][j]))
                    s.insert({i, k});
                break;
            }
    };

    auto checkBishop = [&](int i, int j, std::set<pii>& s)
    {
        for(int ii = i + 1, jj = j + 1; ii <= 8 && jj <= 8; ii++, jj++)
            if(board[ii][jj] == '.')
                s.insert({ii, jj});
            else
            {
                if(islower(board[ii][jj]) ^ islower(board[i][j]))
                    s.insert({ii, jj});
                break;
            }
        for(int ii = i - 1, jj = j - 1; ii >= 1 && jj >= 1; ii--, jj--)
            if(board[ii][jj] == '.')
                s.insert({ii, jj});
            else
            {
                if(islower(board[ii][jj]) ^ islower(board[i][j]))
                    s.insert({ii, jj});
                break;
            }
        for(int ii = i + 1, jj = j - 1; ii <= 8 && jj >= 1; ii++, jj--)
            if(board[ii][jj] == '.')
                s.insert({ii, jj});
            else
            {
                if(islower(board[ii][jj]) ^ islower(board[i][j]))
                    s.insert({ii, jj});
                break;
            }
        for(int ii = i - 1, jj = j + 1; ii >= 1 && jj <= 8; ii--, jj++)
            if(board[ii][jj] == '.')
                s.insert({ii, jj});
            else
            {
                if(islower(board[ii][jj]) ^ islower(board[i][j]))
                    s.insert({ii, jj});
                break;
            }
    };

    auto checkKing = [&](int i, int j, std::set<pii>& s)
    {
        std::vector<pii> pos = {{i + 1, j}, {i - 1, j}, {i, j + 1}, {i, j - 1}, {i + 1, j + 1}, {i - 1, j - 1}, {i + 1, j - 1}, {i - 1, j + 1}};
        for(auto [x, y]: pos)
        {
            if(x < 1 || x > 8 || y < 1 || y > 8)
                continue;
            if(board[x][y] == '.' || (islower(board[i][j]) ^ islower(board[x][y])))
                s.insert({x, y});
        }
    };

    auto checkKnight = [&](int i, int j, std::set<pii>& s)
    {
        std::vector<pii> pos = {{i - 1, j + 2}, {i + 1, j + 2}, {i - 2, j + 1}, {i - 2, j - 1}, {i + 2, j + 1}, {i + 2, j - 1}, {i - 1, j - 2}, {i + 1, j - 2}};
        for(auto [x, y]: pos)
        {
            if(x < 1 || x > 8 || y < 1 || y > 8)
                continue;
            if(board[x][y] == '.' || (islower(board[i][j]) ^ islower(board[x][y])))
                s.insert({x, y});
        }
    };

    auto checkPawn = [&](int i, int j, std::set<pii>& s)
    {
        if(isupper(board[i][j]))
        {
            std::vector<pii> pos = {{i + 1, j - 1}, {i + 1, j + 1}};
            for(auto [x, y]: pos)
            {
                if(x < 1 || x > 8 || y < 1 || y > 8)
                    continue;
                if(board[x][y] == '.' || islower(board[x][y]))
                    s.insert({x, y});
            }
        }
        if(islower(board[i][j]))
        {
            std::vector<pii> pos = {{i - 1, j - 1}, {i - 1, j + 1}};
            for(auto [x, y]: pos)
            {
                if(x < 1 || x > 8 || y < 1 || y > 8)
                    continue;
                if(board[x][y] == '.' || isupper(board[x][y]))
                    s.insert({x, y});
            }
        }
    };


    auto checkWhite = [&]() -> bool
    {
        std::set<pii> s;
        for(int i = 1; i <= 8; i++)
            for(int j = 1; j <= 8; j++)
            {
                if(board[i][j] == 'Q')
                {
                    checkRook(i, j, s);
                    checkBishop(i, j, s);
                }
                if(board[i][j] == 'R')
                    checkRook(i, j, s);
                if(board[i][j] == 'B')
                    checkBishop(i, j, s);
                if(board[i][j] == 'N')
                    checkKnight(i, j, s);
                if(board[i][j] == 'K')
                    checkKing(i, j, s);
                if(board[i][j] == 'P')
                    checkPawn(i, j, s);
            }
        return s.count(king);
    };
    
    auto checkBlack = [&]() -> bool
    {
        std::set<pii> s;
        for(int i = 1; i <= 8; i++)
            for(int j = 1; j <= 8; j++)
            {
                if(board[i][j] == 'q')
                {
                    checkRook(i, j, s);
                    checkBishop(i, j, s);
                }
                if(board[i][j] == 'r')
                    checkRook(i, j, s);
                if(board[i][j] == 'b')
                    checkBishop(i, j, s);
                if(board[i][j] == 'n')
                    checkKnight(i, j, s);
                if(board[i][j] == 'k')
                    checkKing(i, j, s);
                if(board[i][j] == 'p')
                    checkPawn(i, j, s);
            }
        return s.count(KING);
    };

    if(checkWhite())
        std::cout << "CHECK" << endl;
    else if(checkBlack())
        std::cout << "check" << endl;
    else
        std::cout << "none" << endl;
}

int main()
{
    #ifdef ONLINE_JUDGE
    ioclear;
    #endif

    int t = 1;
    std::cin >> t;
    while(t--)
        solve();
}
```

```py
def parse_fen(fen):
    # 解析FEN字符串，返回一个8x8的棋盘矩阵
    board = []
    rows = fen.split(' ')[0].split('/')
    for row in rows:
        board_row = []
        for char in row:
            if char.isdigit():
                # 如果是数字，说明有这么多空格
                board_row.extend(['.'] * int(char))
            else:
                # 否则是棋子
                board_row.append(char)
        board.append(board_row)
    return board
 
def find_king(board, color):
    # 找到指定颜色的国王的位置
    king = 'K' if color == 'white' else 'k'
    for i in range(8):
        for j in range(8):
            if board[i][j] == king:
                return (i, j)
    return None
 
def is_attacked(board, row, col, attacker_color):
    # 判断(row, col)位置是否被指定颜色的棋子攻击
    directions = {
        'R': [(1, 0), (-1, 0), (0, 1), (0, -1)],  # 车的移动方向
        'B': [(1, 1), (-1, -1), (1, -1), (-1, 1)],  # 象的移动方向
        'Q': [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)],  # 后的移动方向
        'N': [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]  # 马的移动方向
    }
 
    for piece, dirs in directions.items():
        # 检查车、象、后、马的攻击
        for dr, dc in dirs:
            r, c = row + dr, col + dc
            while 0 <= r < 8 and 0 <= c < 8:
                if board[r][c] != '.':
                    if (attacker_color == 'black' and board[r][c] == piece.lower()) or \
                       (attacker_color == 'white' and board[r][c] == piece.upper()):
                        return True
                    break
                if piece in 'Nn':  # 马只跳一步
                    break
                r += dr
                c += dc
 
    # 检查兵的攻击（兵只能向对角线进攻）
    if attacker_color == 'black':
        if row > 0 and col > 0 and board[row - 1][col - 1] == 'p':
            return True
        if row > 0 and col < 7 and board[row - 1][col + 1] == 'p':
            return True
    else:
        if row < 7 and col > 0 and board[row + 1][col - 1] == 'P':
            return True
        if row < 7 and col < 7 and board[row + 1][col + 1] == 'P':
            return True
 
    # 检查国王的攻击（国王只移动一步）
    king = 'k' if attacker_color == 'black' else 'K'
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if 0 <= row + dr < 8 and 0 <= col + dc < 8:
                if board[row + dr][col + dc] == king:
                    return True
 
    return False
 
def is_check(fen):
    board = parse_fen(fen)
 
    # 找到白王和黑王的位置
    white_king_pos = find_king(board, 'white')
    black_king_pos = find_king(board, 'black')
 
    # 检查白王是否被黑方棋子攻击
    if is_attacked(board, white_king_pos[0], white_king_pos[1], 'black'):
        return "check"
    
    # 检查黑王是否被白方棋子攻击
    if is_attacked(board, black_king_pos[0], black_king_pos[1], 'white'):
        return "CHECK"
    
    return "none"
 
# 示例FEN
t = int(input())
for _ in range(t):
    fen = input()
    result = is_check(fen)
    print(result)

```

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P11878)

## 题目大意：

给定一个 FEN 格式的国际象棋残局，问有没有哪一方正在被将军，国际象棋的规则见原题面，这里不过多赘述。

## 思路：

很明显，这是一个**大模拟**，所以来讲一讲怎么实现各个部分。

### 数据储存：

棋子种类很多，考虑使用结构体：

```cpp
struct blacknode{
	vector< pair<int,int> >c;//车 
	vector< pair<int,int> >h;//皇后 
	vector< pair<int,int> >x;//象 
	vector< pair<int,int> >w;//王 
	vector< pair<int,int> >b;//兵 
	vector< pair<int,int> >m;//马 
}black;//黑子 
struct whitenode{
	vector< pair<int,int> >c;//车 
	vector< pair<int,int> >h;//皇后 
	vector< pair<int,int> >x;//象 
	vector< pair<int,int> >w;//王 
	vector< pair<int,int> >b;//兵 
	vector< pair<int,int> >m;//马 
}white;//白子 
```
同时由于后续判断时要用到对某一格子上有无棋子的判断，可以开一个布尔类型的数组来标记：
```cpp
bool yz[15][15];//标记有无棋子 
```

### 初始化：

本题是多测题，所以一定要清空标记和结构体：

```cpp
void csh(){
	black.h.clear();
	black.b.clear();
	black.x.clear();
	black.w.clear();
	black.m.clear();
	black.c.clear();
	white.h.clear();
	white.b.clear();
	white.x.clear();
	white.w.clear();
	white.m.clear();
	white.c.clear();
	for(int i=0;i<=10;i++){
		for(int j=0;j<=10;j++){
			yz[i][j]=false;
		}
	}
	return ;
}//初始化
```
### 输入：

将 FNE 格式转换成记录每种棋子的出现位置，用 ```while``` 反复输入字符，是 ```/``` 就登记一下，出现七个 ```/``` 后再输入特判数量，到达八个就结束输入。

```cpp
void oin(){
	char a;
	int mqx=0,mqy=1;
	while(1){
		cin>>a;
		mqx++;
		if(a>'0'&&a<='9') {mqx+=((a-'0')-1);if(mqy==8&&mqx==8){break;}continue;}
		if(a=='/'){mqy++;mqx=0;continue;}
		if(a=='r') black.c.push_back(make_pair(mqy,mqx));
		if(a=='n') black.m.push_back(make_pair(mqy,mqx));
		if(a=='b') black.x.push_back(make_pair(mqy,mqx));
		if(a=='q') black.h.push_back(make_pair(mqy,mqx));
		if(a=='k') black.w.push_back(make_pair(mqy,mqx));
		if(a=='p') black.b.push_back(make_pair(mqy,mqx));
		if(a=='R') white.c.push_back(make_pair(mqy,mqx));
		if(a=='N') white.m.push_back(make_pair(mqy,mqx));
		if(a=='B') white.x.push_back(make_pair(mqy,mqx));
		if(a=='Q') white.h.push_back(make_pair(mqy,mqx));
		if(a=='K') white.w.push_back(make_pair(mqy,mqx));
		if(a=='P') white.b.push_back(make_pair(mqy,mqx));
		yz[mqy][mqx]=true;
		if(mqy==8&&mqx==8) break;//特判 
	}
	return ;
}//输入
```

### 判断是否一方被将军：

依次对对方的每一种棋子进行映射，注意映射途中碰到有棋子的格子要 ```break;```，因为很明显不能穿过某一棋子去吃另一棋子。

判断白方是否被将军：


```cpp
bool black_checker(){
	bool f[15][15];
	for(int i=1;i<=8;i++){
		for(int j=1;j<=8;j++){
			f[i][j]=false;
		}
	}
	for(int i=0;i<black.b.size();i++){
		f[black.b[i].first+1][black.b[i].second+1]=true;
		f[black.b[i].first+1][black.b[i].second-1]=true;
	}
	for(int j=0;j<black.c.size();j++){
		int u1=black.c[j].first;
		int u2=black.c[j].second;
		for(int i=u2+1;i<=8;i++){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u2-1;i>=1;i--){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u1+1;i<=8;i++){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
		for(int i=u1-1;i>=1;i--){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
	}
	for(int j=0;j<black.h.size();j++){
		int u1=black.h[j].first;
		int u2=black.h[j].second;
		for(int i=u2+1;i<=8;i++){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u2-1;i>=1;i--){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u1+1;i<=8;i++){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
		for(int i=u1-1;i>=1;i--){f[i][u2]=true;if(yz[i][u2]==true){break;}}
		for(int i=u1+1,k=u2+1;i<=8&&k<=8;i++,k++){f[i][k]=true;if(yz[i][k]==true){break;}}
		for(int i=u1-1,k=u2+1;i>=1&&k<=8;i--,k++){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1+1,k=u2-1;i<=8&&k>=1;i++,k--){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1-1,k=u2-1;i>=1&&k>=1;i--,k--){f[i][k]=true;if(yz[i][k]==true){break;}}  
	}
	for(int j=0;j<black.m.size();j++){
		int u1=black.m[j].first;
		int u2=black.m[j].second;
		for(int i=1;i<=8;i++){
			int a=u1+db[i][1];
			int b=u2+db[i][2];
			if(a<=0||b<=0) continue;
			if(a>8||b>8) continue;
			f[a][b]=true;
		}
	}
	for(int j=0;j<black.x.size();j++){
		int u1=black.x[j].first;
		int u2=black.x[j].second;
		for(int i=u1+1,k=u2+1;i<=8&&k<=8;i++,k++){f[i][k]=true;if(yz[i][k]==true){break;}}
		for(int i=u1-1,k=u2+1;i>=1&&k<=8;i--,k++){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1+1,k=u2-1;i<=8&&k>=1;i++,k--){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1-1,k=u2-1;i>=1&&k>=1;i--,k--){f[i][k]=true;if(yz[i][k]==true){break;}}  
	}
	int wx=white.w[0].first;
	int wy=white.w[0].second;
	if(f[wx][wy]==true) return true;
	else return false; 
}
```
判断黑方同理。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int db[9][3]={{0,0,0},{0,1,2},{0,2,1},{0,-1,2},{0,-2,1},{0,1,-2},{0,2,-1},{0,-1,-2},{0,-2,-1}};
struct blacknode{
	vector< pair<int,int> >c;//车 
	vector< pair<int,int> >h;//皇后 
	vector< pair<int,int> >x;//象 
	vector< pair<int,int> >w;//王 
	vector< pair<int,int> >b;//兵 
	vector< pair<int,int> >m;//马 
}black;//黑子 
struct whitenode{
	vector< pair<int,int> >c;//车 
	vector< pair<int,int> >h;//皇后 
	vector< pair<int,int> >x;//象 
	vector< pair<int,int> >w;//王 
	vector< pair<int,int> >b;//兵 
	vector< pair<int,int> >m;//马 
}white;//白子 
bool yz[15][15];//标记有无棋子 
void csh(){
	black.h.clear();
	black.b.clear();
	black.x.clear();
	black.w.clear();
	black.m.clear();
	black.c.clear();
	white.h.clear();
	white.b.clear();
	white.x.clear();
	white.w.clear();
	white.m.clear();
	white.c.clear();
	for(int i=0;i<=10;i++){
		for(int j=0;j<=10;j++){
			yz[i][j]=false;
		}
	}
	return ;
}

void oin(){
	char a;
	int mqx=0,mqy=1;
	while(1){
		cin>>a;
		mqx++;
		if(a>'0'&&a<='9') {mqx+=((a-'0')-1);if(mqy==8&&mqx==8){break;}continue;}
		if(a=='/'){mqy++;mqx=0;continue;}
		if(a=='r') black.c.push_back(make_pair(mqy,mqx));
		if(a=='n') black.m.push_back(make_pair(mqy,mqx));
		if(a=='b') black.x.push_back(make_pair(mqy,mqx));
		if(a=='q') black.h.push_back(make_pair(mqy,mqx));
		if(a=='k') black.w.push_back(make_pair(mqy,mqx));
		if(a=='p') black.b.push_back(make_pair(mqy,mqx));
		if(a=='R') white.c.push_back(make_pair(mqy,mqx));
		if(a=='N') white.m.push_back(make_pair(mqy,mqx));
		if(a=='B') white.x.push_back(make_pair(mqy,mqx));
		if(a=='Q') white.h.push_back(make_pair(mqy,mqx));
		if(a=='K') white.w.push_back(make_pair(mqy,mqx));
		if(a=='P') white.b.push_back(make_pair(mqy,mqx));
		yz[mqy][mqx]=true;
		if(mqy==8&&mqx==8) break;//特判 
	}
	return ;
}//输入 

bool black_checker(){
	bool f[15][15];
	for(int i=1;i<=8;i++){
		for(int j=1;j<=8;j++){
			f[i][j]=false;
		}
	}
	for(int i=0;i<black.b.size();i++){
		f[black.b[i].first+1][black.b[i].second+1]=true;
		f[black.b[i].first+1][black.b[i].second-1]=true;
	}
	for(int j=0;j<black.c.size();j++){
		int u1=black.c[j].first;
		int u2=black.c[j].second;
		for(int i=u2+1;i<=8;i++){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u2-1;i>=1;i--){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u1+1;i<=8;i++){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
		for(int i=u1-1;i>=1;i--){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
	}
	for(int j=0;j<black.h.size();j++){
		int u1=black.h[j].first;
		int u2=black.h[j].second;
		for(int i=u2+1;i<=8;i++){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u2-1;i>=1;i--){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u1+1;i<=8;i++){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
		for(int i=u1-1;i>=1;i--){f[i][u2]=true;if(yz[i][u2]==true){break;}}
		for(int i=u1+1,k=u2+1;i<=8&&k<=8;i++,k++){f[i][k]=true;if(yz[i][k]==true){break;}}
		for(int i=u1-1,k=u2+1;i>=1&&k<=8;i--,k++){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1+1,k=u2-1;i<=8&&k>=1;i++,k--){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1-1,k=u2-1;i>=1&&k>=1;i--,k--){f[i][k]=true;if(yz[i][k]==true){break;}}  
	}
	for(int j=0;j<black.m.size();j++){
		int u1=black.m[j].first;
		int u2=black.m[j].second;
		for(int i=1;i<=8;i++){
			int a=u1+db[i][1];
			int b=u2+db[i][2];
			if(a<=0||b<=0) continue;
			if(a>8||b>8) continue;
			f[a][b]=true;
		}
	}
	for(int j=0;j<black.x.size();j++){
		int u1=black.x[j].first;
		int u2=black.x[j].second;
		for(int i=u1+1,k=u2+1;i<=8&&k<=8;i++,k++){f[i][k]=true;if(yz[i][k]==true){break;}}
		for(int i=u1-1,k=u2+1;i>=1&&k<=8;i--,k++){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1+1,k=u2-1;i<=8&&k>=1;i++,k--){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1-1,k=u2-1;i>=1&&k>=1;i--,k--){f[i][k]=true;if(yz[i][k]==true){break;}}  
	}
	int wx=white.w[0].first;
	int wy=white.w[0].second;
	if(f[wx][wy]==true) return true;
	else return false; 
}

bool white_checker(){
bool f[15][15];
	for(int i=1;i<=8;i++){
		for(int j=1;j<=8;j++){
			f[i][j]=false;
		}
	}
	
	for(int i=0;i<white.b.size();i++){
		f[white.b[i].first-1][white.b[i].second+1]=true;
		f[white.b[i].first-1][white.b[i].second-1]=true;
	}
	for(int j=0;j<white.c.size();j++){
		int u1=white.c[j].first;
		int u2=white.c[j].second;
		for(int i=u2+1;i<=8;i++){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u2-1;i>=1;i--){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u1+1;i<=8;i++){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
		for(int i=u1-1;i>=1;i--){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
	}
	for(int j=0;j<white.h.size();j++){
		int u1=white.h[j].first;
		int u2=white.h[j].second;
		for(int i=u2+1;i<=8;i++){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u2-1;i>=1;i--){f[u1][i]=true;if(yz[u1][i]==true){break;}} 
		for(int i=u1+1;i<=8;i++){f[i][u2]=true;if(yz[i][u2]==true){break;}} 
		for(int i=u1-1;i>=1;i--){f[i][u2]=true;if(yz[i][u2]==true){break;}}
		for(int i=u1+1,k=u2+1;i<=8&&k<=8;i++,k++){f[i][k]=true;if(yz[i][k]==true){break;}}
		for(int i=u1-1,k=u2+1;i>=1&&k<=8;i--,k++){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1+1,k=u2-1;i<=8&&k>=1;i++,k--){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1-1,k=u2-1;i>=1&&k>=1;i--,k--){f[i][k]=true;if(yz[i][k]==true){break;}}  
	}
	for(int j=0;j<white.m.size();j++){
		int u1=white.m[j].first;
		int u2=white.m[j].second;
		for(int i=1;i<=8;i++){
			int a=u1+db[i][1];
			int b=u2+db[i][2];
			if(a<=0||b<=0) continue;
			if(a>8||b>8) continue;
			f[a][b]=true;
		}
	}
	for(int j=0;j<white.x.size();j++){
		int u1=white.x[j].first;
		int u2=white.x[j].second;
		for(int i=u1+1,k=u2+1;i<=8&&k<=8;i++,k++){f[i][k]=true;if(yz[i][k]==true){break;}}
		for(int i=u1-1,k=u2+1;i>=1&&k<=8;i--,k++){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1+1,k=u2-1;i<=8&&k>=1;i++,k--){f[i][k]=true;if(yz[i][k]==true){break;}} 
		for(int i=u1-1,k=u2-1;i>=1&&k>=1;i--,k--){f[i][k]=true;if(yz[i][k]==true){break;}}  
	}
	int wx=black.w[0].first;
	int wy=black.w[0].second;
	if(f[wx][wy]==true) return true;
	else return false; 
}

signed main(){
    int t;
	cin>>t;
	for(int i=1;i<=t;i++){
		csh();
		oin();
		if(black_checker()==true) cout<<"check\n";
		else if(white_checker()==true) cout<<"CHECK\n";
		else cout<<"none\n";	
	}
	return 0; 
}
```

~~共 192 行~~。

[通过记录](https://www.luogu.com.cn/record/207509959)

---

## 作者：__CJY__ (赞：1)

## 思路
先对 FEN 字符串进行解析。

遍历棋盘，找到黑方国王（`k`）和白方国王（`K`）的位置。

对于每个国王，检查是否有对方的棋子能够攻击到它：

* 检查 $8$ 个 L 型位置是否有对方的马。
* 沿着 $8$ 个方向（上下左右和四个对角线）检查是否有对方的车、象或皇后。
* 检查国王前方两个斜向位置是否有对方的兵。

如果发现对方的棋子能够攻击到国王，则返回对应的结果。
## 后记
这题是大模拟，码量有点大，请耐心敲代码！

**有问题请指出！求赞！**

---

## 作者：Na1L0n9 (赞：1)

# Solution

## 思路
超级大模拟。

思路比较简单，先把读入的 FEN 格式的字符串转化到一个 $8 \times 8$ 的数组上。如果是数字就填充空格，如果是"/"就换行，如果是字母就直接照搬，转化时可以顺便记录下两方皇后的坐标。

转化完后，直接观察皇后的附近是否有能对双方皇后造成威胁的棋子即可。以下是一些注意点和一些简化的思路：
- 王的移动其实就是象的移动再加上车的移动，可以和象与车一起判断。
- 两方兵的移动是不一样的，黑兵往下，白兵往上，不要搞反或者忘记了。
- 如果王被其它棋子挡住了，象，车，后，兵都不可以直接越过那个棋子。
- 马的方向数组别打错了，~~应该没人和我一样蠢吧~~。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int t, mp[8][8], row, col, bkx, bky, wkx, wky;
int dx[8] = {-2, -1, 1, 2, 2, 1, -1, -2},
    dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};
void mdf(string fen) {
	row = 0, col = 0;
	for (int i = 0; i < fen.length(); i++) {
		if (isdigit(fen[i])) {
			for (int j = 1; j <= fen[i] - '0'; j++) {
				mp[row][col++] = ' ';
			}
		}
		else if (fen[i] == '/') {
			row++;
			col = 0;
		}
		else {
			if (fen[i] == 'k') {
				bkx = row, bky = col;
			}
			if (fen[i] == 'K') {
				wkx = row, wky = col;
			}
			mp[row][col++] = fen[i];
		}
	}
}
bool check_rq(char ch, int x, int y) {
    for (int i = x - 1; ~i; i--) {
        if (mp[i][y] == ch) {
        	return true;
		}
        if (mp[i][y] != ' ') {
        	break;
		}
    }
    for (int i = x + 1; i < 8; i++) {
        if (mp[i][y] == ch) {
        	return true;
		}
        if (mp[i][y] != ' ') {
        	break;
		}
    }
    for (int j = y - 1; ~j; j--) {
        if (mp[x][j] == ch) {
        	return true;
		}
        if (mp[x][j] != ' ') {
        	break;
		}
    }
    for (int j = y + 1; j < 8; j++) {
        if (mp[x][j] == ch) {
        	return true;
		}
        if (mp[x][j] != ' ') {
        	break;
		}
    }
    return false;
}
bool check_bq(char ch, int x, int y) {
    for (int i = x - 1, j = y - 1; ~i && ~j; i--, j--) {
        if (mp[i][j] == ch) {
        	return true;
		}
        if (mp[i][j] != ' ') {
        	break;
		}
    }
    for (int i = x - 1, j = y + 1; ~i && j < 8; i--, j++) {
        if (mp[i][j] == ch) {
        	return true;
		}
        if (mp[i][j] != ' ') {
        	break;
		}
    }
    for (int i = x + 1, j = y - 1; i < 8 && ~j; i++, j--) {
        if (mp[i][j] == ch) {
        	return true;
		}
        if (mp[i][j] != ' ') {
        	break;
		}
    }
    for (int i = x + 1, j = y + 1; i < 8 && j < 8; i++, j++) {
        if (mp[i][j] == ch) {
        	return true;
		}
        if (mp[i][j] != ' ') {
        	break;
		}
    }
    return false;
}
bool check_n(char ch, int x, int y) {
    for (int i = 0; i < 8; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (~nx && nx < 8 && ~ny && ny < 8 && mp[nx][ny] == ch) {
            return true;
        }
    }
    return false;
}
bool check_p(char ch, int tag, int x, int y) {
	int tmp = x + tag;
    if (~tmp && tmp < 8) {
        if ((~(y - 1) && mp[tmp][y - 1] == ch) || (y < 7 && mp[tmp][y + 1] == ch)) {
        	return true;
		}
    }
    return false;
}
string solve() {
    if (check_rq('r', wkx, wky) || check_rq('q', wkx, wky)) {
    	return "check";
    }
    if (check_bq('b', wkx, wky) || check_bq('q', wkx, wky)) {
        return "check";
    }
    if (check_n('n', wkx, wky)) {
        return "check";
    }
    if (check_p('p', -1, wkx, wky)) {
        return "check";
    }
    if (check_rq('R', bkx, bky) || check_rq('Q', bkx, bky)) {
        return "CHECK";
    }
    if (check_bq('B', bkx, bky) || check_bq('Q', bkx, bky)) {
        return "CHECK";
    }
    if (check_n('N', bkx, bky)) {
        return "CHECK";
    }
    if (check_p('P', 1, bkx, bky)) {
        return "CHECK";
    }
    return "none";
}

int main() {
    cin >> t;
    while (t--) {
        string fen;
        cin >> fen;
        mdf(fen);
        cout << solve() << endl;
    }
    return 0;
}
```

---


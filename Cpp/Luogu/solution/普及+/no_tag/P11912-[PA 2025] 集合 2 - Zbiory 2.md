# [PA 2025] 集合 2 / Zbiory 2

## 题目背景

PA 2025 trial round t2.

**请注意本题非同寻常的时空限制。**

## 题目描述

> **问题。**
>
> 给定正整数 $n$ 和非负整数 $m$。定义全集 $U=\{1,2,\ldots,n\}$。
> 
> 构造 $(n+m)$ 个集合 $A_1,A_2,\ldots,A_{n+m}$：
> 
> 1. 对于 $1\le i\le n$，$A_i$ 里的元素为 $U$ 中 $i$ 的倍数。
> 2. 对于 $n+1\le i\le m$，给定参数 $op_i$：
> 
>	- 当 $op_i=1$ 时，给定参数 $x,y$（$x,y\lt n+i$），则 $A_{i} =A_x\cup A_y$；
>    - 当 $op_i=2$ 时，给定参数 $x,y$（$x,y\lt n+i$），则 $A_{i}=A_x\cap A_y$；
>    - 当 $op_i=3$ 时，给定参数 $x$（$x\lt n+i$），则 $A_{i}=U\backslash A_x$（即 $A_i=\{j:j\in U,j\not\in A_x\}$）。
>
> 定义问题的答案为 $A_{n+m}$。

给定正整数 $n$ 和目标集合 $B\subseteq \{1,2,\ldots,n\}$。构造非负整数 $m$ 和一组对应的参数，使得上述问题的答案为 $B$。

你需要保证 $0\le m\le 10^5$。可以证明本题一定有解。


## 说明/提示

- $1\le n\le 5\times 10^4$;
- $B\subseteq \{1,2,\ldots,n\}$。

## 样例 #1

### 输入

```
7 4
1 2 4 6```

### 输出

```
8
1 5 7
2 2 3
3 8
2 10 8
3 3
1 12 12
2 10 13
1 9 14```

## 样例 #2

### 输入

```
3 1
3```

### 输出

```
0```

# 题解

## 作者：gcx12012 (赞：0)

### 前言
小清新构造题。
### Solution 
首先设当前集合为 $S$，目标集合为 $T$，初始时 $S$ 为空集。

我们将 $x$ 从小到大依次考虑，如果 $x\in S$ 且 $x\in T$，或者 $x\not\in S$ 且 $x\not\in T$ 就不管。否则我们分两类讨论：

- 当 $x\in S$ 且 $x\not\in T$ 时，考虑如何删除元素 $x$。这时我们可以通过 3 操作将集合变为 $U$ 的补集，然后与 $A_x$ 取并之后再取一次补集即可。
- 否则，直接 $S\cup A_i\to S$ 即可。

直接做的操作次数最多是 $3n$ 次的，考虑如何优化。

我们发现集合 $S$ 在每一次考虑时只有两种状态，于是我们平衡一下即可做到最多 $2n$ 次操作。

以下代码最多进行 $2n+1$ 次操作，但是能过。
### Code
```
#include<bits/stdc++.h>
#include<cmath>
#define ll long long
#define ld long double
#define ull unsigned long long
#define lll __int128
#define N 500010
#define ls x<<1
#define rs x<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r
#define For(i,a,b) for(ll i=a;i<=b;++i)
#define Rof(i,a,b) for(ll i=a;i>=b;--i)
#define mk make_pair
#define pb emplace_back
#define pii pair<ll,ll>
#define pque priority_queue
#define fi first
#define se second

using namespace std;
struct node{
	int op,x,y;
};
vector<node >ans;
int a[N],b[N];
int n,k,now=0;

ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}


int main()
{
    //freopen("game.in","r",stdin);
    //freopen("game.out","w",stdout);
    n=read(),k=read();
    For(i,1,k) a[read()]=1;
    int m=n;
    m++;
    ans.pb((node){3,1,0});
    For(i,1,n){
    	if(!b[i] && a[i]){
    		if(now){
    			now^=1;
    			m++;
    			ans.pb((node){3,m-1,0});
			}
			for(int j=i;j<=n;j+=i) b[j]=1;
			ans.pb((node){1,m,i});
			m++;
		}else if(b[i] && !a[i]){
			if(!now){
    			now^=1;
    			m++;
    			ans.pb((node){3,m-1,0});
			}
			for(int j=i;j<=n;j+=i) b[j]=0;
			ans.pb((node){1,m,i});
			m++;
		}
	}
	if(now){
  		now^=1;
   		m++;
   		ans.pb((node){3,m-1,0});
	}
	cout<<(int)ans.size()<<endl;
	for(node i:ans){
		if(i.op==3) cout<<i.op<<' '<<i.x<<endl;
		else cout<<i.op<<' '<<i.x<<' '<<i.y<<endl;
	}
   	return 0;
}
/*

*/
```

---


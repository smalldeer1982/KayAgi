# [PA 2025] 显像管 / Migawka

## 题目背景

PA 2025 R5C.

可以用 PHP 语言提交答案，也可以提交答案生成器。

## 题目描述

**这是一道提交答案题。**

有一台老旧的黑白电视机，屏幕尺寸为 $100 \times 100$ 像素。每个像素可以是亮着的，也可以是熄灭的。然而，这台电视机有缺陷的，显示的图像一般不会保持太久。

称一个 $2 \times 2$ 的像素块是**错误的**，当且仅当其**只有**（主/副）对角线上的像素是亮的。电视机每秒将**在至少一个**错误块中的像素状态反转（亮变为灭，灭变为亮）。

![](https://cdn.luogu.com.cn/upload/image_hosting/1usrl3xs.png?x-oss-process=image/resize,m_lfit,h_200)

例如，考虑一个 $4 \times 4$ 的电视机屏幕，初始时各像素状态为下图左 $1$ 所示。下图展示了电视机在未来几秒钟的屏幕状态变化。

![](https://cdn.luogu.com.cn/upload/image_hosting/wcgmxgup.png?x-oss-process=image/resize,m_lfit,h_200)

从图中可以看出，第 $3$ 秒的屏幕画面与第 $1$ 秒相同，所以有 $3$ 种不同的画面。

构造初始的像素状态，最大化它能生成的不同画面的数量。（在刚才的例子中，生成了 $3$ 种不同画面）。


## 说明/提示


### 计分方式

设初始画面生成了 $x$ 种不同的画面。

令 $i$ 为最小的非负整数，满足 $(10\cdot i-1)^2\ge x$，则得分为 $\min(100,10\cdot i)$。

### 提示


**光敏性癫痫警告：开发者已尽力确保可视化对癫痫患者是安全的，但请小心使用。**

我们在附件中提供了可视化工具 $\boldsymbol{visualise.py}$。

这是一个 Python 脚本，依赖于 `matplotlib` 和 `numpy` 库（请自行搜索如何安装，可能需要更换镜像源）。

使用以下命令启动可视化工具：

- Linux / MacOS：

	```bash
	python3 visualise.py < mig.txt
	```
- Windows cmd：
	```bash
	py visualise.py < mig.txt
    ```

压缩包还包含了一个示例文件 $\boldsymbol{mig.txt}$。

你可以根据需要自行修改可视化工具。  



# 题解

## 作者：_droplet_ (赞：4)

> 令 $i$ 为最小的非负整数，满足 $(10\cdot i-1)^2\ge x$，则得分为 $\min(100,10\cdot i)$。

手搓可以发现，我们至少要有 $9801$ 个状态。

可以通过一行一行的向下蛇形更新状态来实现，考虑这个思路。

### 1. 构建像素

先构建出一个 **错误的** 像素，如下。

```
Time 0
01
10
```

### 2. 向右移动

接下来构建出能向右走一整行的 $2 \times 100$ 的像素矩形，如下。

```
Time 0
011111
100000
```

```
Time 1
101111
010000
```

```
Time 5
101010
010101
```

### 3. 向下移动

下一步要让这个矩形向下移动一格，同时不能继续向下。

```
Time 5
101010
010101
xxxx10
xxxx00
```

```
Time 6
010101
101010
xxxx01
xxxx00
```

### 4. 向左移动

接下来向左移动，左侧可以类比第一次向右走。

```
Time 6
010101
101010
111101
xx0000
```

```
Time 7
101010
010101
111010
xx0000
```

```
Time 10
010101
101010
010101
xx0000
```

### 5. 重复步骤

同上，先向下，在类比之前变换向右。

```
Time 10
010101
101010
010101
100000
```

以此类推，直到最后到最下方无法更新，发现矩阵数刚好为 $99 \times 99 + 1 = 9802$，可以通过此题。

总结上方推导，得出初始矩形，如下。

```
011111
100000
111110
100000
111110
100000
```

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cout<<'0';
    for(int j=2;j<=N;j++) cout<<'1'; cout<<'\n';
    for(int i=2;i<=N;i++){
        cout<<'1';
        for(int j=1;j<N-1;j++) cout<<i%2;
        cout<<"0\n";
    }
    return 0;
}
```

---

## 作者：_H17_ (赞：2)

## 题目分析

首先考虑为什么会形成多种不同的画面？因为有些位置是会是在反转之后变成“错误的”的。由于它是由第一次变化引出的连锁反应，我们称之为“引爆”。

考虑数据范围：要求有 $99^{2}$ 个不同画面，不难发现除了两个小边框全部需要引爆。不妨考虑每次多引爆一个。

## 找规律

我们随便找一个偶数来模拟这个过程。

拿 $n=6$ 举例子，假设左上角是：

```
10
01
```

我们先引爆这一行：

```
100000
011111
```

这样子就可以全引爆，第一个全被引爆的时刻如下：

```
101010
010101
```

由于我们需要尽量多的画面，所以应该在引爆后第二时刻向下引爆。

```
010101
101010
****01
```

这样目前我们开始的阵是：

```
100000
011111
****01
```

接下来考虑填写 `*` 部分，由于不能在第二行被引爆的同时引爆，所以需要同色，模拟发现填 `0` 即可。

```
100000
011111
000001
******
******
******
```

剩下三行考虑根据这一行的规律填写。

```
100000
011111
000001
011111
000001
011111
```

## 验证规律

由于 $n=6$，每次暴力枚举“错误的”位置然后变色即可，等发现没有可以新引爆的即可。

经过暴力检查，发现此时不少于 $25$ 个，满足条件。

依据此规律扩展到 $n=100$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    for(int i=1;i<=6;i++)
        if(i==1)
            cout<<1;
        else
            cout<<0;
    cout<<'\n';
    for(int i=2;i<=6;i++){
        if(i%2==0){
            for(int j=1;j<=6;j++)
                if(j==1)
                    cout<<0;
                else
                    cout<<1;
            cout<<'\n';
        }
        else{
            for(int j=1;j<=6;j++)
                if(j==6)
                    cout<<1;
                else
                    cout<<0;
            cout<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

风铃草不会做这题，糖批糖丸了 /cf

可以给大家提供许许多多的部分分糖批思路。

---

**$10$ 分思路：**

没有什么想法，但好像对角线能够拓展很多？

所以输出对角线试试，[记录](https://www.luogu.com.cn/record/208857627)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    for(int i=1;i<=100;i++,cout<<endl)
        for(int j=1;j<=100;j++){
            cout<<(i==j);
        }
    return 0;
}
```

只有 $100$ 个图案，非常糟糕。

---

**$80$ 分思路：**

通过粗略计算发现 AC 至少要能出现 $8000$ 个图案以上。

~~顺带提一嘴这题关于分值计算的描述那边好像有锅，为什么是最大的非负整数啊（~~

在对角线的基础上继续思考，可以从一角开始不断往外扩展，这样肯定比对角线更加优秀。

我们每次扩成一个矩形时就在外侧放一个接应点，贪心的构造可以得到这样的图案（以 $n=10$ 为例）：

```
0100100100
1000000000
0010000000
1000000000
0001000000
0000010000
1000000000
0000001000
0000000010
1000000000
```

然后找找规律可以得到如下代码：

```cpp
#include<bits/stdc++.h>
#define N 10
using namespace std;
int mp[105][105],flag[105][2];
int main(){
    mp[1][2]=mp[2][1]=1;
    for(int i=5;i<=N;i+=3)mp[1][i]=1;
    for(int i=4;i<=N;i+=3)mp[i][1]=1;
    for(int i=2;i<=N;i++)
    for(int j=2;j<=N;j++){
        mp[i][j]-=mp[i][1]+mp[1][j]+flag[i][0]+flag[j][1];
        if(mp[i][j]==0)flag[i][0]=1,flag[j][1]=1;
    }
    for(int i=1;i<=N;i++,cout<<endl)
        for(int j=1;j<=N;j++){
            if(i==1||j==1){
                cout<<mp[i][j];
                continue;
            }
            if(mp[i][j]==0)cout<<1;
            else cout<<0;
        }
    return 0;
}
```

[记录](https://www.luogu.com.cn/record/208864697)。

只有 $6469$ 个图案，距离 AC 还差很多。

---

满分做法：

现在请把对角线思路扔进垃圾桶里。我就是一直纠结对角线才不会做的。

~~这个思路是打到足够的分偷窥 @[zhenjianuo2025](/user/534654) 代码偷到的（~~

考虑把扩展顺序压成蛇形。然后你可以构造出一个类似于 E 形状的矩阵，并在左上角设置一个启动点。

这样就得到了一个下面的矩阵（以 $n=10$ 为例）：

```cpp
1000000000
0111111111
0000000001
0111111111
0000000001
0111111111
0000000001
0111111111
0000000001
0111111111
```

手玩发现这样确实是蛇形变换的，每次跑到最后一列时都会开始逆向折回，而第一列出现数字时又会成为下一轮的启动点。

于是可以得到下面的代码：

```cpp
#include<bits/stdc++.h>
#define N 100
using namespace std;
int mp[105][105],flag[105][2];
int main(){
    mp[1][1]=1;
    for(int i=2;i<=N;i++)
    for(int j=2;j<=N;j++)
    mp[i][j]=(j==N||i%2==0);
    for(int i=1;i<=N;i++,cout<<endl)
    for(int j=1;j<=N;j++)
    cout<<mp[i][j];
    return 0;
}
```

[记录](https://www.luogu.com.cn/record/208975641)。

$9802$ 个图案，稳稳 AC。

那么做完了。

---

## 作者：Mark_Pei (赞：2)

## Solution

一开始，相信大家是这样想的：

对于 $100×100$ 的网格，每个像素 $(i,j)$（行列从 $0$ 开始）：

如果 $(i+j)$ 是偶数，设为 $1$，

如果 $(i+j)$ 是奇数，设为 $0$，

这样类似于国际象棋的棋盘，交替放置 $1$ 和 $0$ 的方式就形成了“完美的”棋盘模式。

或者从对角线入手，从一角开始不断往外扩展。

比如我：

```cpp
for(int i=0;i<100;i++)
{ 
    for(int j=0;j<100;j++)
    {
        cout<<((i+j)%2);
    }
    cout<<endl;
}
```

但是，我们会发现[一个残忍的事实](https://www.luogu.com.cn/record/215607347)。

我们可以换一种思路，把扩展顺序压成蛇形，然后构造出一个类似于 E 形状的矩阵，并将左上角设为启动点。

然后我们会发现它是蛇形变换的，每次到最后一列时都会开始逆向折回，而第一列出现数字时又会成为下一轮的启动点。

 **[AC记录](https://www.luogu.com.cn/record/215605903)**
 
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1003][1003];
int main()
{
    a[1][1]=1;
    for(int i=2;i<=100;i++)
        for(int j=2;j<=100;j++)
            a[i][j]=(j==100||i%2==0);
    for(int i=1;i<=100;i++)
    {
        for(int j=1;j<=100;j++)
            cout<<a[i][j];
        cout<<endl;
    }
    return 0;
}
```

---


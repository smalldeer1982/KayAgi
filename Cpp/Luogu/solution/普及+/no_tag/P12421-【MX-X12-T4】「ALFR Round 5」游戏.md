# 【MX-X12-T4】「ALFR Round 5」游戏

## 题目背景

原题链接：<https://oier.team/problems/X12D>。

## 题目描述

**这是一道交互题。**

有一棵 $n$ 个点的树，树的形态给定，树上有一个隐藏点 $s$，你每次可以给出一个点 $u$，交互库选择将 $s$ 向 $u$ 移动一步（若 $s=u$ 则无事发生），或者返回目前 $u$ 到 $s$ 的距离。交互库会告诉你他选择的操作，如果选择的是操作 $2$ 会告诉你距离。你需要在 $m$ 次询问内求出**目前** $s$ 的位置。

每个测试点中有 $T$ 组测试数据。

交互库不自适应，这意味着询问开始前 $s$ 的位置确定，与你的询问无关。

**【交互方式】**

首先输入一个正整数 $T$ 表示测试数据组数。

接下来 $T$ 组数据，每组数据的第一行输入两个正整数 $n,m$ 分别表示树的点数和询问次数限制，接下来 $n-1$ 行每行两个数 $u,v$ 表示树上存在一条连接 $u,v$ 的边。

接着你需要进行交互，询问格式为 `? u`，其中需要满足 $1 \leq u \leq n$，如果你本组数据的询问次数超过 $m$，交互库输出 `-1`，此时你需要立即结束程序否则之后交互库行为未定义。若询问次数未超过限制，交互库输出 `1` 或者 `2 d`，分别表示交互库选择将 $s$ 向 $u$ 移动一步或者告诉你 $s$ 到 $u$ 目前的距离为 $d$。当你确定 $s$ 目前的位置后，输出 `! u` 表示 $s$ 目前在编号为 $u$ 的节点上。如果你的回答是正确的，交互库输出 `1` 并进入下一组测试数据，否则交互库输出 `0`，你需要立即结束程序否则之后交互库行为未定义。

**你需要在你的每次输出后刷新缓冲区。**

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

当你在单个测试点内总询问次数不超过 $\sum m$ 次时，保证交互库占用时间不超过 $1.5$ s，占用空间不超过 $50$ MiB，也就是说你的程序至少可以使用 $1.5$ s 的时间和 $462$ MiB 的空间。

## 说明/提示

**【样例解释 #1】**

对于样例 $1$，初始有 $s=3$，询问两次点 $2$，第一次交互库返回 $1$，并将 $s$ 向点 $2$ 移动一步，$s=2$，第二次询问交互库返回 $1$，$s=2$，所以 $s$ 不发生变化。此时可以确定 $s=2$，回答 $s=2$ 后，交互库返回 $1$ 表示答案正确。

**【数据范围】**

**本题使用捆绑测试。**

| 子任务编号 | $T \leq $ | $n \leq $ | $m = $ | 特殊性质 | 分值 | 子任务依赖 |
| :-: | :-: | :-: |:-: |:-: | :-: | :-: |
| $1$ | $500$ | $10$ | $200$ | 无 |$5$ | 无 |
| $2$ | $10$ | $1000$ | $3n$ | 无 | $13$ | $1$ |
| $3$ | $10^4$ | $10^5$ | $n-1$ | A | $7$ | 无
| $4$ | $10^4$ | $10^5$ | $n-1$ | B | $10$ | 无
| $5$ | $10^4$ | $10^5$ | $3n$ | C | $14$ | 无 |
| $6$ | $10^4$ | $10^5$ | $2n$ | 无 | $21$ | $1,2,5$ |
| $7$ | $10^4$ | $10^5$ | $n-1$  | 无 |$30$ | $1,2,3,4,5,6$ |

特殊性质 A：树上每个点度数不大于 $2$。

特殊性质 B：树上只有至多一个点度数大于 $1$。

特殊性质 C：树的生成方式为：对于每个 $2 \leq i \leq n$，等概率随机选取 $[1,i)$ 中的一个整数 $x$，将 $x$ 与 $i$ 连边。

对于所有数据，$1 \leq T \leq 10^4$，$1 \leq \sum n \leq 10^5$，$m\geq n-1$。

## 样例 #1

### 输入

```
1
4 200
1 2
2 4
2 3
1
1
1
```

### 输出

```
? 2
? 2
! 2
```

## 样例 #2

### 输入

```
2
5 200
5 1
4 2
2 3
2 1
1
2 1
2 0
1
6 200
6 1
2 1
4 2
4 5
3 2
2 3
2 1
1
1
1```

### 输出

```
? 2
? 2
? 1
! 1
? 6
? 2
? 4
? 4
! 4```

# 题解

## 作者：wmrqwq (赞：6)

验题人题解。

# 题目链接

[「ALFR Round 5」D 游戏](https://www.luogu.com.cn/problem/P12421)

# 解题思路

考虑交互库做这两种操作我们分别能得到什么信息。

如果交互库执行向 $u$ 移动一步的操作，则此时非 $u$ 的度数为 $1$ 的节点经过这一步操作后一定不是关键点 $s$，因为若关键点是这些节点，则这些节点都会向上跳一步。

如果交互库告诉你当前 $u$ 和 $s$ 的距离，设这个距离为 $d$，若 $d = 0$，则 $u$ 就是关键节点 $s$，否则，此时 $u$ 一定不是当前的关键节点 $s$。

首先特判 $n = 1$ 的情况。

我们考虑持续询问一个可能为关键点 $s$ 的度数为 $1$ 的节点。

因此如果交互库在做操作一时，此时可以直接删除树上非 $u$ 的度数为 $1$ 的节点；如果交互库在做操作二时，如果给出的距离 $d$ 为 $0$，则可以直接确定关键节点 $s = u$，否则若 $s$ 不为 $0$ 时，可以直接在树上删除 $u$ 这个节点。

注意到 $n \ge 2$ 时，树上一定有 $\ge 2$ 个度数为 $1$ 的节点。因此此时一定会询问到只剩下一个节点为止，所以这个询问策略是对的。由于每次询问至少排除一个节点，所以询问次数为 $n - 1$ 次。

# 参考代码

```cpp
ll n,m;
ll x,y;
vector<ll>G[1000010];
ll in[1000010];
ll vis[1000010];
set<ll>v,v2;
ll S;
ll ask(ll x)
{
    cout<<"? "<<x<<endl;
    ll y;
    cin>>y;
    if(y==1)
        return -1;
    return rd();
}
void _clear(){}
void solve()
{
    _clear();
    cin>>n>>m;
    S=n;
    v.clear();
    forl(i,1,n)
        in[i]=0,
        vis[i]=0,
        G[i].clear();
    forl(i,2,n)
        cin>>x>>y,
        G[x].pb(y),
        G[y].pb(x),
        in[x]++,in[y]++;
    forl(i,1,n)
        if(in[i]==1)
            v.insert(i),
            vis[i]=1,
            S--;
    if(v.size()<1)
    {
        cout<<"! 1"<<endl;
        rd();
        return ;
    }
    while(v.size()>1)
    {
        ll now=*v.begin();
        ll num=ask(now);
        if(num==-1)
        {
            set<ll>v2;
            v2.insert(now);
            for(auto i:v)
                if(i!=now)
                    for(auto j:G[i])
                    {
                        in[j]--;
                        if(in[j]==1 && !vis[j])
                            v2.insert(j),
                            S--,
                            vis[j]=1;
                    }
            v=v2;
        }
        else
        {
            if(num==0)
            {
                v.clear();
                cout<<"! "<<now<<endl;
                if(!rd())
                    exit(-1);
                return ;
            }
            v.erase(now);
            for(auto j:G[now])
            {
                in[j]--;
                if(in[j]==1 && !vis[j])
                    v.insert(j),
                    S--,
                    vis[j]=1;
            }
        }
    }
    if(v.size()==0)
        exit(0);
    cout<<"! "<<*v.begin()<<endl;
    v.clear();
    if(!rd())
        exit(-1);
}
```

---

## 作者：2021CHD (赞：2)

## 注意事项

**这是一道交互题，注意刷新缓存区。**

对于 C++ 语言，推荐使用 `endl` 换行以刷新缓存区。

## 题目大意

给出 $n$ 个点的树，树上有一个关键点 $s$，操作至多 $n-1$ 次，每次选择一个点 $u$，交互库每次可以选择将 $s$ 向 $u$ 移动一步（$s=u$ 则不移动）或给出 $s$ 到 $u$ 的距离，最后需求出点 $s$ 当前的位置，有多测。

- $\sum n\le10^5$。

## 解法

不妨称交互库的两种行为分别为“移动”或“回复”。

观察不难发现“移动”将会带来更少的信息，首先考虑如果交互库一直“移动”我们要如何应对。

不难发现我们只要每次指定相同的 $u$，那么 $n-1$ 次操作后一定有 $s=u$。方便起见我们将题目中给出的树视为以 $u$ 为根的有根树。

那么如果某次交互库选择“回复”，那么我们不可能再次操作 $u$ 了，因为交互库可以再次选择“回复”，而我们没有收到任何新的信息，相当于浪费了一次操作。

于是一旦某次交互库选择“回复”，那么我们考虑在接下来的操作中只需维护 $s$ 的深度 $t$ 以及 $s$ 可能处在的子树的根节点 $v$，初始时有 $v=u$，$t=d+1$。

接下来从 $u$ 开始进行一次 dfs，维护出每个点的深度（记为 $h_i$）以及每个点为根的子树中有多少深度为 $d+1$ 的点（记为 $w_i$）。（注意不需要维护每个点为根的子树中有多少深度为 $t$ 的点，即 $t$ 改变时无需重新 dfs）

经过以上预处理后即可重复以下过程直到返回答案：

1. 若 $h_v=t$，则直接返回 $v$。
2. 否则，枚举 $v$ 的每个 $w_p$ 非 $0$ 的子节点 $p$ 并检查 $s$ 是否在 $p$ 子树内。
   - 若 $p$ 是最后一个被检查的子节点，直接将 $v$ 置为 $p$ 并返回第 $1$ 步。
   - 否则不断对 $p$ 操作直到进行了 $t-h_v+1$ 次或交互库选择了“回复”，期间交互库一定选择了“移动”，此时将 $t$ 置为 $t-1$ 即可。
   - 结束对 $p$ 的操作后，有以下几种情况：
     - 进行了 $t-h_v+1$ 次操作后交互库仍未选择“回复”：此时直接返回 $p$ 即可。
     - 在第 $t-h_v+1$ 次操作时交互库才选择“回复”：此时若 $d=0$，返回 $p$；否则 $d=1$，返回 $v$。
     - 交互库提前选择了“回复”：此时若 $d=t-h_v-1$，则将 $v$ 置为 $p$ 并返回第 $1$ 步；否则 $d=t-h_v+1$，则可以判定 $s$ 不在 $p$ 子树内，继续枚举下一个 $p$ 即可。

不难发现上述过程一定能正确求解出 $s$ 当前的位置。

## 次数分析

不难发现上述做法在某些情况下次数可能达到 $n$，比如当原树为以 $u$ 为中心的至少有 $3$ 个节点的菊花，并且 $s\neq u$ 时，交互库可以不断选择“回复”直到只剩 $2$ 个可能的节点 $x$ 和 $y$，并且我们尝试操作 $x$，那么此时交互库再选择“移动”，我们就耗尽了 $n-1$ 次操作的机会，而需要一次额外的操作才能求出 $s$ 当前的位置。

不难发现当 $u$ 为叶节点时，上述情况就不会发生。（分析见下）

那么接下来分析交互次数：

- 一开始操作点 $u$ 时，交互库每“移动”一次，至少有 $1$ 个节点被排除了。（除非当前可能的 $s$ 只剩 $u$，但是这种情况并不重要，因为反正最多也就 $n-1$ 次操作）
- 若交互库第一次“回复”时就只有一个可能的 $s$，那么此时我们显然不会再进行任何更多的操作，所以这种情况也是合标的。
- 否则如果上述条件均成立（$u$ 为叶节点且交互库第一次“回复”时有多于一个可能的 $s$），那么第一次“回复”时至少排除了 $2$ 个点（$u$ 和与 $u$ 相邻的唯一的点）
- 接下来每步操作几乎都至少排除了 $1$ 个点：交互库始终提前选择“回复”，那么这里每次“移动”都等价于是最开始操作点 $u$ 时的移动，而每次“回复”都能至少排除 $1$ 个节点，由于最后还剩 $1$ 个节点，所以这里至多就是 $n-2$ 次操作（第一次“回复”时多排除了 $1$ 个点）。
- 否则一旦出现进行第 $t-h_v+1$ 次操作的情况就会立刻求解出答案，所以这里至多比上面多出 $1$ 步，也就是 $n-1$ 步。

综上，本做法完全满足本题的要求，且时空复杂度均容易做到 $O(\sum n)$。

## 参考代码

这是我的[赛时 AC 记录](https://www.luogu.com.cn/record/216105536)中的代码。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int T,I,n,m,u[110000],v[110000],num[110000],*mp[110000],deep[110000],siz[110000],fa[110000],d,i,j,op,x,o,pans,t;
void dfs(int x)
{
	int i;
	deep[x]=deep[fa[x]]+1;
	for(i=1;i<=mp[x][0];i++)
	if(mp[x][i]!=fa[x])
	{
		fa[mp[x][i]]=x;
		dfs(mp[x][i]);
		siz[x]=siz[x]+siz[mp[x][i]];
	}
	if(deep[x]==d)
	siz[x]++;
}
main()
{
	cin>>T;
	for(I=1;I<=T;I++)
	{
		cin>>n>>m;
		for(i=1;i<n;i++)
		cin>>u[i]>>v[i];
		for(i=1;i<n;i++)
		{
			num[u[i]]++;
			num[v[i]]++;
		}
		for(i=1;i<=n;i++)
		{
			mp[i]=new int[num[i]+1];
			mp[i][0]=0;
		}
		for(i=1;i<n;i++)
		{
			mp[u[i]][0]++;
			mp[u[i]][mp[u[i]][0]]=v[i];
			mp[v[i]][0]++;
			mp[v[i]][mp[v[i]][0]]=u[i];
		}
		for(i=1;i<=n;i++)
		if(num[i]<=1)
		break;
		o=i;
		for(i=1;i<=n-1;i++)
		{
			cout<<"? "<<o<<endl;
			cin>>op;
			if(op==2)
			{
				cin>>x;
				break;
			}
		}
		if(i>n-1)
		{
			cout<<"! "<<o<<endl;
			cin>>x;
			for(i=1;i<=n;i++)
			{
				num[i]=0;
				delete [] mp[i];
			}
			continue;
		}
		d=x+1;
		fa[o]=0;
		dfs(o);
		pans=siz[o];
		while(1)
		{
			if(deep[o]==d)
			{
				cout<<"! "<<o<<endl;
				cin>>x;
				break;
			}
			for(i=1;i<=mp[o][0];i++)
			if(mp[o][i]!=fa[o]&&siz[mp[o][i]]>0)
			if(siz[mp[o][i]]==pans)
			{
				o=mp[o][i];
				break;
			}
			else
			{
				t=d-deep[o]+1;
				for(j=1;j<=t;j++)
				{
					cout<<"? "<<mp[o][i]<<endl;
					cin>>op;
					if(op==1)
					d--;
					else
					{
						cin>>x;
						if(x==d-deep[mp[o][i]])
						{
							pans=siz[mp[o][i]];
							o=mp[o][i];
							op=3;
							break;
						}
						if(j==t)
						{
							if(x==0)
							cout<<"! "<<mp[o][i]<<endl;
							else
							cout<<"! "<<o<<endl;
							cin>>x;
							op=4;
							break;
						}
						break;
					}
				}
				if(op>2)
				break;
				if(j>t)
				{
					cout<<"! "<<mp[o][i]<<endl;
					cin>>x;
					op=4;
					break;
				}
				pans=pans-siz[mp[o][i]];
			}
			if(op==4)
			break;
		}
		for(i=1;i<=n;i++)
		{
			siz[i]=0;
			num[i]=0;
			delete [] mp[i];
		}
	}
}
```

## 碎碎念

*怎么和官方题解做法完全不一样？*

别忘了刷新缓存区，多测别忘清，**别忘记读入每组数据给出答案后的** `1`。

~~赛时调了好久最后发现是 lca 挂了，一怒之下把 lca 删了，发现做法还是对的。（猜猜我一开始哪里用了 lca）~~

---


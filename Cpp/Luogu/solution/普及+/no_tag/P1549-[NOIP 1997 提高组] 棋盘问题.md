# [NOIP 1997 提高组] 棋盘问题

## 题目背景

NOIP1997 提高组第一题

[P5512](https://www.luogu.com.cn/problem/P5512) 为本题数据加强版。

本题实际的数据的范围是 $1\le N\le 5$。不保证存在可以通过原数据范围的非打表做法。

## 题目描述

在 $N \times N$（$1 \le N \le 10$）的棋盘上，填入 $1, 2, \dots, N ^ 2$ 共 $N ^ 2$ 个数，使得任意两个相邻的数之和为素数。

例如：当 $N = 2$ 时，有：

| $1$ | $2$ |
| :-----------: | :-----------: |
| $4$ | $3$ |

其相邻数的和为素数的有：

$1+2,1+4,4+3,2+3$

当 $N=4$ 时，一种可以填写的方案如下：

| $1$ | $2$ | $11$ | $12$ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $16$ | $15$ | $8$ | $5$ |
| $13$ | $4$ | $9$ | $14$ |
| $6$ | $7$ | $10$ | $3$ |

在这里我们约定：左上角的格子里必须填数字 $1$。

## 样例 #1

### 输入

```
1```

### 输出

```
NO
```

## 样例 #2

### 输入

```
2```

### 输出

```
1 2
4 3```

# 题解

## 作者：宇智波呆土 (赞：174)


本 ~~大佬~~ 蒟蒻表示DFS超时了，一看1≤N≤10，当然得打表啊，大佬勿喷。

此题解只是来~~搞笑~~的。

打表都会吧！！！

代码也不用解释了吧！！！
```c
#include<bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cout.tie(NULL);
    //freopen("","r",stdin);
    //freopen("","w",stdout);
    int n;
    cin>>n;
    if(n==1||n==3||n==9)
    {
        cout<<"NO"<<endl;
        return 0;
    }
    if(n==2)
    {
        cout<<"1 2"<<endl<<"4 3"<<endl;
        return 0;
    }
    if(n==4)
    {
        cout<<"1 2 11 12"<<endl;
        cout<<"4 9 8 5"<<endl;
        cout<<"7 10 3 14"<<endl;
        cout<<"6 13 16 15"<<endl;
        return 0;
    }
    if(n==5)
    {
        cout<<"1 2 3 4 7" <<endl;
        cout<<"6 5 14 15 16" <<endl;
        cout<<"13 24 23 8 21" <<endl;
        cout<<"10 19 18 11 20" <<endl;
        cout<<"9 22 25 12 17" <<endl;
        return 0;
    }
    if(n==6)
    {
        cout<<"1 2 3 4 7 6" <<endl;
        cout<<"10 27 34 19 24 5" <<endl;
        cout<<"13 16 25 18 35 26" <<endl;
        cout<<"30 31 12 29 32 21" <<endl;
        cout<<"11 36 17 14 9 22" <<endl;
        cout<<"8 23 20 33 28 15" <<endl;
        return 0;
    }
    if(n==7)
    {
        cout<<"1 2 3 4 7 6 5" <<endl;
        cout<<"10 21 16 13 24 23 14" <<endl;
        cout<<"9 22 25 48 35 44 45" <<endl;
        cout<<"8 15 28 19 18 29 38" <<endl;
        cout<<"11 32 39 34 49 30 41" <<endl;
        cout<<"12 47 20 27 40 31 42" <<endl;
        cout<<"17 26 33 46 43 36 37" <<endl;
        return 0;
    }
    if(n==8)
    {
        cout<<"1 2 3 4 7 6 5 8" <<endl;
        cout<<"10 21 20 27 34 25 12 11" <<endl;
        cout<<"9 22 39 40 19 28 31 30" <<endl;
        cout<<"14 45 44 63 64 43 36 17" <<endl;
        cout<<"15 56 57 46 37 60 47 62" <<endl;
        cout<<"16 51 52 61 42 29 32 41" <<endl;
        cout<<"13 58 49 48 59 24 35 26" <<endl;
        cout<<"18 55 54 53 50 23 38 33" <<endl;
        return 0;
    }
    if(n==10)
    {
        cout<<"1 2 3 4 7 6 5 8 9 10"<<endl;
        cout<<"12 29 38 33 34 25 36 23 44 27" <<endl;
        cout<<"11 30 41 26 45 22 31 48 35 32" <<endl;
        cout<<"18 43 60 47 56 51 28 19 24 65" <<endl;
        cout<<"13 40 49 54 53 50 39 64 37 42" <<endl;
        cout<<"16 21 52 55 84 89 62 75 76 97" <<endl;
        cout<<"15 58 79 72 95 68 69 82 91 66" <<endl;
        cout<<"14 93 88 85 96 83 98 81 100 73" <<endl;
        cout<<"17 86 63 46 67 90 59 92 99 94" <<endl;
        cout<<"20 77 74 57 70 61 78 71 80 87"<<endl;
        return 0;
    }
    return 0;
}

```

---

## 作者：Iowa_BattleShip (赞：57)

因为发现题解大多无法真正通过此题，要么是无法过$n = 9$，要么答案根本就是错误的，所以就想写篇题解。  

先用线性筛预处理出素数，并直接暴力循环预处理出那些数和哪些数之间能拼成素数，当然可以再疯狂点，直接预处理出每两个数可以和哪些数拼成素数（反正$n$小，随你预处理）。  
然后爆搜的时候注意搜索顺序，先搜第一行第一列，以保证第一行第一列之和最小。  
然而普通的搜索顺序搜除去第一行第一列剩下的部分会有一个问题，即从小到大搜会导致$n = 9$很慢，若从大到小搜会导致$n = 7$很慢。  
我的程序从大到小搜的话，$n = 7$需要$1s$多点，其它秒出，不过经测试开了$O2$在本地或是洛谷$IDE$上都能在$0.9s$内过。  
不过我还不够满意，既然不能一直从小到大，也不能一直从大到小，那就折中一下呗，上随机数。  
测试了$5$个随机数种子，总算让我找到一个能够使得程序秒出$1\sim 10$所有数据的了（甚至可以出$11,12$）。  
这样总算是真正的$A$了此题了。  
另外，我发现这个随机数种子仅是使得我本地能过，在洛谷$IDE$上却无法出$9$的数据，可能是因为操作系统不同导致相同随机数种子的结果不同，所以若真要搞过，还是$time(NULL)$看人品吧。。  
当然我也难保我的程序是完全正确，欢迎指出错误。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;
const int N = 13;
const int M = N * N;
const int K = M << 1;
int a[N][N], p[M][M], pr[K], L[M], P[M][M][M], PL[M][M], n, l, o;
bool v[K], vis[M], pi[M][M];
inline int re()
{
	int x = 0;
	char c = getchar();
	bool p = 0;
	for (; c < '0' || c > '9'; c = getchar())
		p |= c == '-';
	for (; c >= '0' && c <= '9'; c = getchar())
		x = x * 10 + c - '0';
	return p ? -x : x;
}
inline void ri(int &x, int &y)
{
	y++;
	if (y > n)
	{
		y = 1;
		x++;
	}
}
inline void dw(int &x, int &y)
{
	x++;
	if (x > n)
		x = y = 2;
}
bool dfs(int x, int y)
{
	if (x > n)
		return true;
	int i, le = a[x][y - 1], u = a[x - 1][y], xx = x, yy = y, g;
	if (!(x ^ 1) && y ^ 1)//搜第一行
	{
		ri(xx, yy);
		for (i = 1; i <= L[le]; i++)
			if (!vis[g = p[le][i]])
			{
				a[x][y] = g;
				vis[g] = 1;
				if (dfs(xx, yy))
					return true;
				vis[g] = 0;
				a[x][y] = 0;
			}
	}
	else
		if (x ^ 1 && !(y ^ 1))//搜第一列
		{
			dw(xx, yy);
			for (i = 1; i <= L[u]; i++)
				if (!vis[g = p[u][i]])
				{
					a[x][y] = g;
					vis[g] = 1;
					if (dfs(xx, yy))
						return true;
					vis[g] = 0;
					a[x][y] = 0;
				}
		}
		else
		{
			ri(xx, yy);
			if (!(yy ^ 1))
				yy++;
			if (rand() & 1)//随机数折中
				for (i = PL[le][u]; i; i--)//从大到小搜
				{
					g = P[le][u][i];
					if (!vis[g])
					{
						a[x][y] = g;
						vis[g] = 1;
						if (dfs(xx, yy))
							return true;
						vis[g] = 0;
						a[x][y] = 0;
					}
				}
			else
				for (i = 1; i <= PL[le][u]; i++)//从小到大搜
				{
					g = P[le][u][i];
					if (!vis[g])
					{
						a[x][y] = g;
						vis[g] = 1;
						if (dfs(xx, yy))
							return true;
						vis[g] = 0;
						a[x][y] = 0;
					}
				}
		}
	return false;
}
int main()
{
	srand(9982123);//仅本地能过，洛谷IDE无法过9的数据，不行还是上time(NULL)吧
	int m, i, j, k, x;
	n = re();
	if (!(n ^ 1))//特判掉1
	{
		printf("NO");
		return 0;
	}
	o = n * n;
	m = o << 1;
	v[0] = v[1] = 1;
	for (i = 2; i <= m; i++)//线性筛素数
	{
		if (!v[i])
			pr[++l] = i;
		for (j = 1; j <= l; j++)
		{
			if (i * pr[j] > m)
				break;
			v[i * pr[j]] = 1;
			if (!(i % pr[j]))
				break;
		}
	}
	for (i = 1; i < o; i++)
		for (j = i + 1; j <= o; j++)//预处理每个数能和哪些数的和是素数
			if (!v[i + j])
			{
				p[i][++L[i]] = j;
				p[j][++L[j]] = i;
				pi[i][j] = pi[j][i] = 1;
			}
	for (i = 1; i <= o; i++)
		sort(p[i] + 1, p[i] + L[i] + 1);//排序
	for (i = 1; i < o; i++)//预处理每两个数能和哪些数拼成素数
		for (j = i + 1, m = L[i]; j <= o; j++)
			for (k = 1; k <= m; k++)
				if (pi[x = p[i][k]][j])
					P[i][j][++PL[i][j]] = P[j][i][++PL[j][i]] = x;
	a[1][1] = 1;
	vis[1] = 1;
	if (dfs(1, 2))
		for (i = 1; i <= n; i++, printf("\n"))
			for (j = 1; j <= n; j++)
				printf("%d ", a[i][j]);
	else
		printf("NO");
	return 0;
}
```

---

## 作者：Scarlet_Hypoc (赞：32)

正解深搜

但是，不一定第一个搜到的就是最优的，如果直接输出第一个搜到的，那么最后一个点会过不去

我觉得下面的题解如果来个极限数据10就不行了（能A我觉得是数据太弱，只有1~5。。），所以我想发一篇（貌似是）正解的解法。

废话不多说，看看怎么做。

首先，从（1，2）开始搜，因为（1，1）固定为1，然后他要求第一行和第一列的和最小，则我们可以使不在第一行或第一列的数尽量的大，也就是从大到小枚举，则剩下给第一行和第一列的数也就更小了，则这样搜出来的第一个解即是正解。

这里我还加了个优化，用线性筛素数来判断。

见代码：




```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
int f[11][11];
int n,a[210],t=0;
bool v[210];
bool s[110];
int ans[11][11];
inline void dfs(int x,int y)
{
    if(x==n+1&&y==1)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            printf("%d ",f[i][j]);
            printf("\n");
        }
        exit(0);//直接结束程序，注意要用<cstdlib>头文件
    }
    if(x==1||y==1)
    {
        for(int i=2;i<=n*n;i++)
        {
            if(s[i])continue;
            if((x==1&&y!=1&&!v[i+f[x][y-1]])||(x!=1&&y==1&&!v[i+f[x-1][y]])||(x!=1&&y!=1&&!v[i+f[x-1][y]]&&!v[i+f[x][y-1]]))//判断相加是否为素数
            {
                f[x][y]=i;s[i]=true;//标记i出现过
                if(y==n)dfs(x+1,1);
                else dfs(x,y+1);
                f[x][y]=0;s[i]=false;
            }
        }
    }
    else
    {
        for(int i=n*n;i>=2;i--)//如果不是第一行或第一列的数那么就让他拿尽量大的数，把小的留给第一行或第一列的位置
        {
            if(s[i])continue;
            if((x==1&&y!=1&&!v[i+f[x][y-1]])||(x!=1&&y==1&&!v[i+f[x-1][y]])||(x!=1&&y!=1&&!v[i+f[x-1][y]]&&!v[i+f[x][y-1]]))//同上
            {
                f[x][y]=i;s[i]=true;
                if(y==n)dfs(x+1,1);
                else dfs(x,y+1);
                f[x][y]=0;s[i]=false;
            }
        }
    }
}
int main()
{
    scanf("%d",&n);
    if(n==1)
    {
        printf("NO");
        return 0;
    }
    memset(s,false,sizeof(s));
    memset(v,false,sizeof(v));
    for(int i=2;i<=n*n*2;i++)//注意要枚举到n^2的两倍，因为两个数相加很可能大于n
    {
        if(!v[i])//线性筛素数
        {
            a[++t]=i;
        }
        for(int j=1;j<=t;j++)
        {
            if(i*a[j]>200)break;
            v[i*a[j]]=true;
            if(i%a[j]==0)break;
        }
    }
    memset(f,0,sizeof(f));
    f[1][1]=1;s[1]=true;
    dfs(1,2);
    printf("NO");
    return 0;
}
```

---

## 作者：zmxqs (赞：16)

+ 前言：作者这几天来心血来潮，决定把 $NOIP-TG$ 的历届赛题给做一遍，只做难题，不做水题

+ 作者写完了这道题，就来发题解

说了这么多，现在进入正题

### [题目传送门](https://www.luogu.com.cn/problem/P1549)

题目大意分析：
1. 生成一个全排列
2. 判断全排列是否满足任意相邻的数和为质数

Step1：枚举

为了图省事，作者决定用 $STL$ 库的 $\text{nextpermutation}$函数

那么问题来了，nextpermutation函数只能适用与一维的全排列

对于本题来说，是不是不能用呢？

然而不是。我们可以把这个矩阵从二维缩成一维

用一张图来表示一下吧

原来的图：（保存两个值,x和y坐标）

| 1,1 |1,2  |1,3  |
| -----------: | -----------: | -----------: |
| 2,1 |2,2 |2,3  |
| 3,1 |3,2  |3,3  |

如果我们把这张图压缩到一维，就成了这样

|1  |2  |3  |
| -----------: | -----------: | -----------: |
|4  |5  |6  |
|7  |8  |9  |

问题也简化了很多，我们也可以使用$\text{nextpermutation}$辽

代码如下
```cpp
		while(next_permutation(a+1,a+1+n*n)) {
			//To do
		}
```

Step2：判质数

这道题貌似很卡时间，所以我们就要考虑优化时间复杂度

于是就可以使用筛法了

本人用的是埃式筛法，时间复杂度为：

生成O(n log n)

每次查询时O(1)

```cpp
void make_prime(int x) {
	p[1] = true ;
	for(int i=2;i<=x;++i) {
		if(p[i] == false) {
			for(int j=2;j*i<=x;++j) {
				p[i*j] = true ;
			}
		}
	}
	return ;
}

```
调用时只要判断p[x] == false 

即
```cpp

#define isPrime(x) p[x] == false

```

如果实在不会筛法的看这里，有O(sqrt(n))时间复杂度的质数判断
```cpp
bool check() {
	for(int i=1;i<=n*n-n;++i) {
		if(! isPrime(a[i] + a[i + n])) {
			return false;
		}
	}
	for(int i=1;i<=n*n;++i) {
		if(i % n == 0) {
			continue ;
		}
		if(! isPrime(a[i] + a[i + 1])) {
			return false ;
		}
	}
	return a[1] == 1 ;
}
```
Step3：判断

传统方法：把每一个点的上下左右都判断一下

优化：只判断这个点的下和右

为什么这个优化是成立的呢？

原本在程序中，一对相邻的数会被判断两次，这样优化后，大大降低了程序的运行时间

```cpp
bool check() {
	for(int i=1;i<=n*n-n;++i) {
		if(! isPrime(a[i] + a[i + n])) {
			return false;
		}
	}
	for(int i=1;i<=n*n;++i) {
		if(i % n == 0) {
			continue ;
		}
		if(! isPrime(a[i] + a[i + 1])) {
			return false ;
		}
	}
	return a[1] == 1 ;
}
```


综合程序
```cpp
#include<bits/stdc++.h>
#define isPrime(x) p[x] == false
using namespace std;

unsigned long long read() {
	unsigned long long s=0,w=1;
	char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}
	while(c>='0'&&c<='9') s=s*10+c-'0',c=getchar();
	return s*w;
}

const int MAXN = 20 * 20 ;
int a[MAXN],p[MAXN];
int n;
//bool isPrime(int x) {
//	for(int i=2;i*i <= x ; ++i) {
//		if(x % i == 0) {
//			return false ;
//		}
//	}
//	return x > 1 ;
//}
void make_prime(int x) {
	p[1] = true ;
	for(int i=2;i<=x;++i) {
		if(p[i] == false) {
			for(int j=2;j*i<=x;++j) {
				p[i*j] = true ;
			}
		}
	}
	return ;
}
bool check() {
	for(int i=1;i<=n*n-n;++i) {
		if(! isPrime(a[i] + a[i + n])) {
			return false;
		}
	}
	for(int i=1;i<=n*n;++i) {
		if(i % n == 0) {
			continue ;
		}
		if(! isPrime(a[i] + a[i + 1])) {
			return false ;
		}
	}
	return a[1] == 1 ;
}
void Print() {
	for(int i=1;i<=n*n;++i) {
		printf("%d ",a[i]);
		if(i % n == 0 ) {
			putchar('\n');
		}
	}
	return ;
}
int main() {
	scanf("%d",&n);
	make_prime(n*n);
	for(int i=1;i<=n*n;++i) {
		a[i] = i;
	}
	while(next_permutation(a+1,a+1+n*n)) {
		if(check()) {
			Print();
			return 0;
		}
	}
	printf("NO\n");
	return 0;
}
```

Step5：???

当然，别急着提交，这份答案会$TLE$的

俗话说的好~

+ 暴力出奇迹，打表过省一

在竞赛中，打表是一种很好的方法

并不是一无是处的

在答案的种数很少时就派上用场了，能够降低程序的运行时间

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main() {
	scanf("%d",&n);
	if(n==1 || n==3 || n==9) {
		printf("NO\n");
	} else if(n==2) {
		printf("1 2\n");
		printf("4 3\n");
	} else if(n==4) {
		printf("1 2 11 12 \n");
		printf("4 15 8 5 \n");
		printf("7 16 3 14 \n");
		printf("6 13 10 9 \n");
	} else if(n==5) {
		printf("1 2 3 4 7 \n");
		printf("6 17 14 15 16 \n");
		printf("13 24 5 8 21 \n");
		printf("10 19 12 11 20 \n");
		printf("9 22 25 18 23 \n");
	} else if(n==6) {
		printf("1 2 3 4 7 6 \n");
		printf("10 27 34 25 36 35 \n");
		printf("21 16 13 18 23 8 \n");
		printf("22 31 30 29 14 5 \n");
		printf("19 12 11 32 15 26 \n");
		printf("24 17 20 9 28 33 \n");
	} else if(n==7) {
		printf("1 2 3 4 7 6 5 \n");
		printf("10 27 44 39 40 31 48 \n");
		printf("9 34 45 22 49 30 41 \n");
		printf("8 33 28 25 12 29 38 \n");
		printf("15 46 43 36 35 32 21 \n");
		printf("16 13 18 11 26 47 20 \n");
		printf("37 24 19 42 17 14 23 \n");
	} else if(n==8) {
		printf("1 2 3 4 7 6 5 8 \n");
		printf("10 57 56 33 64 37 42 59 \n");
		printf("9 52 51 50 63 46 61 48 \n");
		printf("14 45 62 47 26 27 40 49 \n");
		printf("17 44 35 54 53 20 39 58 \n");
		printf("12 29 24 43 36 11 32 21 \n");
		printf("55 18 19 28 31 30 41 38 \n");
		printf("34 25 22 15 16 13 60 23 \n");
	} else if(n==10) {
		printf("1 2 3 4 7 6 5 8 9 10 \n");
		printf("12 95 98 99 100 97 96 71 92 87 \n");
		printf("11 86 93 80 57 94 85 78 89 62 \n");
		printf("18 65 74 83 56 45 82 49 90 77 \n");
		printf("13 84 53 54 47 26 81 58 91 72 \n");
		printf("16 73 36 43 66 41 68 69 88 79 \n");
		printf("15 64 67 70 61 48 59 44 63 34 \n");
		printf("14 39 40 33 76 31 30 23 38 75 \n");
		printf("17 20 27 46 55 42 37 60 29 32 \n");
		printf("50 21 52 51 28 25 22 19 24 35 \n");
	}
	return 0;
}

```

已经$AC$了

$by$ $SteveFang$ $2020/3/22$

Update1.1:修改了排版，增加了部分说明

---

## 作者：MeowScore (赞：6)

## 一点说明
很抱歉，题解通过后交了一下加强版，就过不了了，如果只是 TLE 还可以理解，然而还 WA 了几个点，经检查发现我的算法存在问题，这里进行修正，给出了虽然大数据会超时，但是算法思想是没有问题的解法！（当然是可以通过此题的）


## 题目链接

[P1549 [NOIP1997 提高组] 棋盘问题](https://www.luogu.com.cn/problem/P1549)


------------

## 解决问题

明显是深搜题。搜索时参数 $x,y$，表示当前要填充 $(x,y)$ 位置。对于一个位置，枚举所有可能的数，如果这个数没有被使用过，且填充之后和 $(x-1,y)$、$(x,y-1)$ 上的数之和均为素数，那么就把这个数填上（边界情况要特殊处理，防止越界）。

如有多种解，则输出第一行、第一列之和为最小的排列方案，好几篇题解以及我之前的思路是填第一行或第一列的数时要从小到大枚举，其余的数从大到小枚举，这样我们搜到的第一组解便是最终的正确答案。然而能过小数据只是巧合，这个贪心策略存在问题，因为如果比较靠前的位置舍弃一个较小值，后面的数可能反而填的比较理想。而如果这样贪心，前面的数比较小，却很有可能导致虽然是第一组解，但是后面在第一行和第一列却搜出了不少大数。

由于此题数据较小，这里采取的方法是尝试所有情况，如果一个数处于第一行或第一列，那么就把它的值累加到 $tot$ 变量中，当搜完一种情况，去和当前所有情况的 $tot$ 中最小值比较，如果更优秀则把当前搜出的矩阵更新为最优解。搜索过程中一旦 $tot$ 超过了当前所有情况中 $tot$ 的最小值，果断返回。

对于素数的判断，为了节省时间，这里的做法是先自己写一个筛素数，做成表，如果 $i$ 为素数，那么 $p_i$ 标记为 $1$，否则为 $0$。

题目要求 $(1,1)$ 固定为 $1$，那么我们从 $(1,2)$ 开始搜（为了使 $N=1$ 时不越界，把这时的情况加一个特判输出即可）。

当然有诸多优化，但这个题数据很小，完全用不上，比如优化搜索顺序、预处理可能的数字等等。

## 上代码（有注释）
```
#include<bits/stdc++.h>
using namespace std;
bool p[200]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,
			0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,
			0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1};//素数桶 
int n;
int cnt=0;
bool vis[110];
int a[15][15];
int tag=0;
int tot=0;
int minn=99999999;
int Q[15][15];
void dfs(int x,int y){
	if(tot>=minn)//tot大于当前最小值，return 
		return;
	if(x==n+1){//搜到n+1行，证明找到一组解了 
		if(tot>=minn)//如果这组解不是最优，就不去记录了 
			return ;
		minn=tot;//更新最小值 
		tag=1;//打上标记证明有解 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				Q[i][j]=a[i][j];//更新最终答案的矩阵 
	}
	/*下面正式开始搜了，很好理解，就是边界情况要稍作处理*/
	if(x==1){
		for(int i=2;i<=n*n;i++){
			if(!vis[i]&&p[i+a[1][y-1]]){
				vis[i]=1;
				a[x][y]=i;
				tot+=i;
				if(y==n)
					dfs(x+1,1);
				else
					dfs(x,y+1);
				tot-=i;
				vis[i]=0;
			}
		}
	}
	if(y==1){
		for(int i=2;i<=n*n;i++){
			if(!vis[i]&&p[i+a[x-1][1]]){
				vis[i]=1;
				a[x][y]=i;
				tot+=i;
				dfs(x,y+1);
				vis[i]=0;
				tot-=i;
			}
		}
	}
	if(x!=1&&y!=1){
		for(int i=2;i<=n*n;i++){
			if(!vis[i]&&p[i+a[x][y-1]]&&p[i+a[x-1][y]]){
				vis[i]=1;
				a[x][y]=i;
				if(y==n)
					dfs(x+1,1);
				else
					dfs(x,y+1);
				vis[i]=0;
			}
		}
	}
}
int main(){
	cin>>n;
	if(n==1){
		cout<<"NO";
		return 0;
	}
	a[1][1]=1;
	memset(vis,0,sizeof(vis));
	dfs(1,2);
	if(tag==0){//判断无解情况
		cout<<"NO";
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<Q[i][j]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：Vanilla_chan (赞：6)

## Problem

构造一个$n\times n(n\le 10)$的矩阵，在矩阵中填入$1,2,\dots,n^2$，使得任意相邻的数之和为素数。

约定：左上角的格子里必须填数字$1$。

不存在解则输出`NO`，存在的话输出所有解中，第一行和第一列之和最小的排列方案。

## Solution

首先$n\le10$，可以暴搜。

### 剪枝1

预处理出200以内所有的质数。

### 剪枝2

为了保证第一行和第一列之和最小，我们可以先填第一行和第一列，再填行列均在$[2,n]$中的格子并优先选择大的数填放。那么我们得到的第一个合法的方案后，可以记录此时的第一行和第一列的和并对之后填第一行第一列的和进行**最优化剪枝**。

这样就有`60pts`了。

### 剪枝3

预处理出$i+j$是不是质数。

大概就是一点常数优化，但是这让`check`函数比较好写。

### 剪枝4

每填入一个格子，就将其与其四周的已经填了的格子进行判断其和是否为质数。而不是等到构造完毕了再整体判断。

这样进行下一步判断时，前面的方案一定是合法的。并且最后也不需要再进行判断了。

### 剪枝5

假设当前的**第一行+第一列**为sum。

如果以当前的**第一行第一列**搜索到了一组正解，那么即使更新**最小的第一行+第一列**，并直接退出**对右下角的格子**的搜索。因为即使又搜出来的几组解，这些解的sum和当前最优解的sum没有区别。

这个时候应该及时的去调整**第一行和第一列**。

到这里，您就已经可以A了这道题了。

如果您对于您的剪枝十分自信，不妨去看一看加强版：[P5512](https://www.luogu.com.cn/problem/P5512)

## Code

```
/**************************************************************
 * Problem: 1549
 * Author: Vanilla_chan
 * Date: 20210315
**************************************************************/
//预编译等部分已去除
#define M 210
#define N 20
int n;
bool book[M];
int prime[M][M];
void init()
{
	book[1]=1;
	for(int i=2;i<=200;i++)
	{
		if(!book[i])
		{
			for(int j=2;i*j<=200;j++)
			{
				book[i*j]=1;
			}
		}
	}
	for(int i=1;i<=n*n;i++)
		for(int j=1;j<=n*n;j++)
			prime[i][j]=book[i+j];
}
int ans;
int ANS[N][N];
int now[N][N];
bool vis[M];
int dt[4][2]={0,1,0,-1,1,0,-1,0};
IL bool exist(int x)
{
	return x>=1&&x<=n;
}
bool check(int x,int y)
{
	for(int t=0;t<4;t++)
	{
		if(exist(x+dt[t][0])&&exist(y+dt[t][1]))
		{
			if(now[x+dt[t][0]][y+dt[t][1]]!=0)
			{
				if(prime[now[x][y]][now[x+dt[t][0]][y+dt[t][1]]])
				{
					return 0;
				}
			}
		}
	}
	return 1;
}
void dfs3(int x,int y,int sum)
{
	if(sum>=ans) return;
	if(y==n+1) y=2,x++;
	if(x==n+1)
	{
		ans=sum;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				ANS[i][j]=now[i][j];
			}
		}
		return;
	}
	for(int i=n*n;i>=1;i--)
	{
		if(vis[i]) continue;
		vis[i]=1;
		now[x][y]=i;
		if(check(x,y)) dfs3(x,y+1,sum);
		vis[i]=0;
		now[x][y]=0;
	}
}
void dfs2(int y,int sum)
{
	if(sum>=ans) return;
	if(y==n+1)
	{
		dfs3(2,2,sum);
		return;
	}
	for(int i=1;i<=n*n;i++)
	{
		if(vis[i]) continue;
		vis[i]=1;
		now[1][y]=i;
		if(check(1,y)) dfs2(y+1,sum+i);
		now[1][y]=0;
		vis[i]=0;
	}
}
void dfs1(int x,int sum)
{
	if(sum>=ans) return;
	if(x==n+1)
	{
		dfs2(2,sum);
		return;
	}
	for(int i=1;i<=n*n;i++)
	{
		if(vis[i]) continue;
		vis[i]=1;
		now[x][1]=i;
		if(check(x,1)) dfs1(x+1,sum+i);
		vis[i]=0;
		now[x][1]=0;
	}
}
int main()
{
	n=read();
	init();
	now[1][1]=1;
	vis[1]=1;
	ans=100000;
	dfs1(2,0);
	if(ans==100000) cout<<"NO"<<endl;
	else
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				cout<<ANS[i][j]<<" ";
			}
			cout<<endl;
		}
	}
	return 0;
}
```



---

## 作者：やらずのあめ (赞：6)

这个题在我看来大概只能用深搜了~~这个题的蓝色图标可能是吓我的~~（蒟蒻的小声BB）  
分析一下题目，在```N*N```的矩阵内，任何一个数与其周围的任何一个数的和是一个质数，也就是说我们只需要每次填一个数然后马上进行判断就好。 
具体怎么判断，首先```X```代表行，```Y```代表列   
搜索顺序为```Y```自增，当```Y```的值为```N+```的时候就需要换行了，具体的代码实现也很简单，一个if解决问题  
```cpp
if(y==n+1)
	x=x+1,y=1;
```
对于每一个搜索的节点，```X```与```Y```所在的位置需要对每一个数进行枚举，一共```N*N```个数，最大也就100，搜到了```X==n+1&&Y==1```时就说明搜到了第一个答案，可以结束程序了，直接```exit(0)```（记得回溯和标记）  
```cpp
void dfs(int x,int y)
{
	if(cut(x,y-1)==0)
		return;
	if(y==n+1)
		x=x+1,y=1;
	if(x==n+1&&y==1)
	{
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=n;++j)
				printf("%d ",num[i][j]);
			printf("\n");
		}
		exit(0);
	}
	if(x==1||y==1)	//确保第一行与第一列之和最小
	{
		for(int i=2;i<=n*n;++i)
		{
			if(flag[i]==0)
			{
				num[x][y]=i;
				flag[i]=1;
				dfs(x,y+1);
				num[x][y]=0;
				flag[i]=0;
			}
		}
	}
	else	//确保第一行与第一列之和最小
	{
		for(int i=n*n;i>=2;--i)
		{
			if(flag[i]==0)
			{
				num[x][y]=i;
				flag[i]=1;
				dfs(x,y+1);
				num[x][y]=0;
				flag[i]=0;
			}
		}
	}
}
```
但是为了保证第一个搜出来的结果是最佳的结果（题目要求第一行和第一列的和最小），可以在第一列和第一行从小到大枚举，其他的从大到小枚举，如果一直用从小到大的枚举，看上去没问题，但实际上是过不了最后一个点的~~被坑了无数次~~  
但是```cut```函数是什么呢，它就是所谓的检查函数，即检查每一次填的数合不合格的函数  
当```X=1```时，只能与左边的数(```map[x][y-1]```)相加进行判断  
其他情况则与左边的数(```map[x][y-1]```)和上方的数(```map[x-1][y]```)相加进行判断  
然后就是实现这玩意的代码，我想很容易理解的QwQ  

```cpp
//检查填的数是否满足整个矩阵的要求
bool cut(int x,int y)
{
	if(x==1&&y==1) return 1;
	if(x==1)	//x==1不能与下面一排比较（因为下面一排没有赋值）上面一排也不可以QwQ 
	{
		if(y!=1&&!ss[num[x][y]+num[x][y-1]])	return 0;	//第一列不能与左边的数相加 
	}
	else
	{
		if(y!=1&&!ss[num[x][y]+num[x][y-1]])	return 0; 
		if(!ss[num[x][y]+num[x-1][y]])	return 0;
	}
	return 1;
}
```
当每一个数在矩阵中都是合法的，那么整个矩阵也就是合法的了  
对于素数的判断我直接用了预处理~~打表~~，这样至少比线性筛素数或者每一次都判断要快了~~打表万岁！！！~~  
最后附上所有的代码好了
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int num[11][11],n;
bool flag[200],ss[201]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0};	//打表QwQ
bool cut(int x,int y)	//检查用的函数
{
	if(x==1&&y==1) return 1;	//处理刚进入dfs的时候还没有任何数比较（好像也可以不要）
	if(x==1)
	{
		if(y!=1&&!ss[num[x][y]+num[x][y-1]])	return 0;
	}
	else
	{
		if(y!=1&&!ss[num[x][y]+num[x][y-1]])	return 0;
		if(!ss[num[x][y]+num[x-1][y]])	return 0;
	}
	return 1;
}
void dfs(int x,int y)
{
	if(cut(x,y-1)==0)	//因为搜索的x与y是第一个未填的数，所以y-1是最后一个填的数
		return;
	if(y==n+1)	//解决行列的问题
		x=x+1,y=1;
	if(x==n+1&&y==1)	//过审了就输出
	{
		for(int i=1;i<=n;++i)
		{
			for(int j=1;j<=n;++j)
				printf("%d ",num[i][j]);
			printf("\n");
		}
		exit(0);
	}
	if(x==1||y==1)	//处理第一行与第一列的和最小的问题
	{
		for(int i=2;i<=n*n;++i)
		{
			if(flag[i]==0)
			{
				num[x][y]=i，flag[i]=1;	//改变
				dfs(x,y+1);	//搜索
				num[x][y]=0，flag[i]=0;	//回溯
			}
		}
	}
	else
	{
		for(int i=n*n;i>=2;--i)
		{
			if(flag[i]==0)
			{
				num[x][y]=i，flag[i]=1;	//改变
				dfs(x,y+1);	//搜索
				num[x][y]=0，flag[i]=0;	//回溯
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	if(n==1)	//直接特判这个从样例能看出来的东西
	{
		printf("NO\n");
		return 0;
	}
	num[1][1]=1;flag[1]=1;	//初始化
	dfs(1,2);	//开始搜索
	printf("NO\n");	//搜完了还没有结果说明这个数据没救
	return 0;
}
```


---

## 作者：GrayCatH (赞：4)

p1549   
### 题面   
在N×N的棋盘上(1≤N≤10)(1≤N≤10)，填入1,2,…,N^2-1,N^2
 共N^2
 个数，使得任意两个相邻的数之和为素数。

例如：当N=2时，有：   
1 2  
4 3

其相邻数的和为素数的有：

1+2,1+4,4+3,2+3,1+2,1+4,4+3,2+3
当N=4时，一种可以填写的方案如下：  
1      2       11      12  
16     15      8       5  
13     4       9       14  
6      7       10      3

在这里我们约定：左上角的格子里必须填数字1。

如有多种解，则输出第一行、第一列之和为最小的排列方案；若无解，则输出“NO”。

、、、解题：    
带有技巧的搜索     
我们知道1是固定的，所拥有的数也是有限的，首先最简单的思路直接深搜一个个放数试，放一个数计算是否和相邻的数相加为素数        
但是有多种方案，并要求第一行第一列的和最小   
于是用一个贪心的思想优化搜索     
怎样使第一行第一列最小？       
我们现在拥有的数是从1~n * n        
那么贪心一下，在第一行第一列的时候尽可能拿小的        
###### 那么顺着拿不就好了吗？         
再反过来，放里面的数时，在满足相邻的数和为素数的条件下，数的大小和位置是没有影响的。我们为了给第一行第一列留下小的，便尽可能把大的数往内放
###### 那么倒着放不就好了吗？
假设第一行第一列构成一个整体，其他构成一个整体         
这样一来就形成了在深搜满足相邻数和为素数的条件下，内部最大外部最小的问题

对于搜索过程：（4，4）
首先我们从（1,1）开始，向（1,2）搜索     
将2放入，发现2+1=3是素数满足条件，再到（1,3）发现3可以…………    
到第二行（2,2）时，我们开始倒放   
放入16，发现2+16=18不合题意，再试15 ，5+15=20不合题意，……然后我们居然发现   
###### 死局       
 我们观察一下这里，可以发现就算没有上限随便放数，这里也不会存在一个解         
 ###### 观察样例
 1      2       11      12  
16     15      8       5  
13     4       9       14  
6      7       10      3     
我们发现  
##### 一个奇数的上下左右都是偶数
##### 一个偶数的上下左右都是奇数     
这是偶然吗？？？？？      
我们回忆数学知识奇偶性
#### 奇+奇=偶
#### 偶+偶=偶
#### 奇+偶=奇
### 又因为~~~~尘归尘土归土~~~~
### 比2大得偶数 一定是合数      
那么有用的就是   奇+偶    了

看回我们的    
1   2    3    4       
5   x      
这时，x不管填什么，都会出现奇+奇，偶+偶其中一种，一定无解          
所以我们搜索放数的时候和检验等时候可以加一个大剪枝---》奇找偶，偶找奇     
code：        
```cpp
#include<bits/stdc++.h>
#define fu(i,q,w)  for(register int i=q;i<=w;i++)
#define fd(i,q,w)  for(register int i=q;i>=w;i--)
using namespace std;
typedef long long ll;
inline int read(){
    int ret=0,f=1;char c;
    while((c=getchar())<'0'||c>'9')if(c=='-')f=-1;
    while(c>='0'&&c<='9')ret=ret*10+(c-'0'),c=getchar();
    return ret*f;
}
int n;
int mp[11][11];
int vis[111];
int prime[333];
int ewe[333];
inline bool check(int x,int y,int z){
	if(mp[x-1][y]%2!=z%2||mp[x-1][y]==0){
		if(mp[x][y-1]%2!=z%2||mp[x][y-1]==0){
			if(mp[x+1][y]%2!=z%2||mp[x+1][y]==0){
				if(mp[x][y+1]%2!=z%2||mp[x][y+1]==0){
					return true;//其实好像只判减1就行…… 
				}
			}
		}
	}
	else return false;
}
inline void dfs(int x,int y){
	  if(x>n){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++)
            printf("%d ",mp[i][j]);
            printf("\n");
        }
        exit(0) ;
    }
	//都成功放过一遍了就退出 
		if(x==1||y==1)//如果是第一排或第一列就正着找数
			fu(i,2,n*n){ 
				if(vis[i])continue;
				if(

  ( x==1&&y!=1 && !prime[i+mp[x][y-1]]  && check(x,y,i) )||
  ( x!=1&&y==1 && !prime[i+mp[x-1][y]]  && check(x,y,i) )
				   
				   ){//加起来是不是素数,奇偶性 
				   	mp[x][y]=i;//可以赋值啦 
				   	vis[i]=1;//访问标记 
				   	if(y==n)dfs(x+1,1);//递归求解 
				   	else dfs(x,y+1);
				   	mp[x][y]=0;// 回溯 
				   	vis[i]=0;
				    }
			}
		else{//如果不是就反着找数
			fd(i,n*n,2){
				if(vis[i])continue;
				if(check(x,y,i)&&!prime[i+mp[x-1][y]]&&!prime[i+mp[x][y-1]]){
				mp[x][y]=i;
				 vis[i]=1;
				 if(y==n)dfs(x+1,1);
				 else dfs(x,y+1);
				 mp[x][y]=0;
				 vis[i]=0;
			} 
		
		}
    }
}
int main(){
	n=read();
	if(n==1){printf("NO");	return 0;	}
	int t;
	fu(i,2,n*n*2)//先把素数线性筛出来 
	{
		if(!prime[i]){
			ewe[++t]=i;
		}
		fu(j,1,t){
			if(i*ewe[j]>200)break;
			prime[i*ewe[j]]=true;
			if(i%ewe[j]==0)break;
		}
	 } 
	 mp[1][1]=1;vis[1]=1;
	 ·dfs(1,2);

	 printf("NO")*;
	 return 0。;
	 
}
		
```

 
 

---

## 作者：高木木 (赞：3)

## **这题数据n<=10，这么小的范围不打表真是可惜了QAQ**

~~可惜本题解并没有打表~~

本篇题解为纯正的暴力DFS（加强数据并没有通过），仅适用于此数据范围小的题。

#### code：（暴力没什么好说的直接上代码，注释都在代码中）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[11][11],minn=2147483647,b[11][11];
bool vis[110],check[201];// check[i]表示i是否为素数
inline void dfs(int x,int y,int h,int l)// h为当前排列的第一行的各数字之和，l为当前排列的第一列各数字之和。x、y表示当前搜索到的位置。
{
	if(x==n+1)// 当搜索到第n+1行时搜索完毕
	{
		if(h+l<minn)// 取第一行和第一列和最小的排列，用b数组来表示。
		{
			minn=h+l;
			for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			 b[i][j]=a[i][j];
		}
		return ;
	}
	if(h+l>minn) return ;// 小小的剪枝，当当前第一行和第一列各数字和大于已经搜到的最小值，return掉
	for(int i=1;i<=n*n;i++)
	{
               
		if(vis[i]) continue;
        	// 由上往下逐行搜索，第一行和第一列要分开讨论。
		if(x==1)
		{
			int m=i+a[x][y-1];
			if(!check[m])
			{
				vis[i]=1;
				a[x][y]=i;
				if(y==n) dfs(x+1,1,h+i,l);
				else dfs(x,y+1,h+i,l);
				vis[i]=0;
			}
		}
		else
		{
			if(y==1)
			{
				int m=i+a[x-1][y];
				if(!check[m])
				{
					vis[i]=1;
					a[x][y]=i;
					if(y==n) dfs(x+1,1,h,l+i);
					else dfs(x,y+1,h,l+i);
					vis[i]=0;
				}
			}
			else
			{
				int m=i+a[x][y-1],k=i+a[x-1][y];
				if(!check[m]&&!check[k])
				{
					vis[i]=1;
					a[x][y]=i;
					if(y==n) dfs(x+1,1,h,l);
					else dfs(x,y+1,h,l);
					vis[i]=0;
				}
			}
		}
	}
}
int main()
{
	vis[1]=1;
	scanf("%d",&n);
	a[1][1]=1;
	check[3]=0,check[4]=1;
    
	for(int i=5;i<=n*n*2;i++)
	{
		if(i%6!=1&&i%6!=5) check[i]=1;
		else
		{
			for(int j=5;j*j<=i;j+=6)
			{
				if(i%j==0||i%(j+1)==0)
				{
					check[i]=1;
					break ;
				}
			}
		}
	}// 此处先预处理一下，把 n^2 以内的合数全部找出，check[合数]=1，那么check[素数]=0；
    
	if(n==1)
	{
		cout<<"NO";
		return 0;
	}// n=1 直接输出‘NO’即可，题目中已给出。
	dfs(1,2,1,1);
	if(minn==2147483647)
	{
		cout<<"NO";
	}
	else
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		 printf("%d ",b[i][j]);
		cout<<endl;
	}
	return 0;
}
```
写在最后：

关于判断一个数是否为素数的方法具体参考[这位大佬的博客](https://blog.csdn.net/afei__/article/details/80638460)

多谢指教。

---

## 作者：人间凡人 (赞：3)

这道题直接打表就行了正解的话看楼上那位就可以了 。

**注意：当n=1、3、9的 时候输出NO！！！**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);//打表大法好！！！
	if(n==1||n==3||n==9)printf("NO\n");
	else
	if(n==2){
		printf("1 2\n");
		printf("4 3\n");
	}
	else
	if(n==4){
		printf("1 2 11 12 \n");
		printf("4 15 8 5 \n");
		printf("7 16 3 14 \n");
		printf("6 13 10 9 \n");
	}
	else
	if(n==5){
		printf("1 2 3 4 7 \n");
		printf("6 17 14 15 16 \n");
		printf("13 24 5 8 21 \n");
		printf("10 19 12 11 20 \n");
		printf("9 22 25 18 23 \n");
	}
	else
	if(n==6){
		printf("1 2 3 4 7 6 \n");
		printf("10 27 34 25 36 35 \n");
		printf("21 16 13 18 23 8 \n");
		printf("22 31 30 29 14 5 \n");
		printf("19 12 11 32 15 26 \n");
		printf("24 17 20 9 28 33 \n");
	}
	else
	if(n==7){
		printf("1 2 3 4 7 6 5 \n");
		printf("10 27 44 39 40 31 48 \n");
		printf("9 34 45 22 49 30 41 \n");
		printf("8 33 28 25 12 29 38 \n");
		printf("15 46 43 36 35 32 21 \n");
		printf("16 13 18 11 26 47 20 \n");
		printf("37 24 19 42 17 14 23 \n");
	}
	else
	if(n==8){
		printf("1 2 3 4 7 6 5 8 \n");
		printf("10 57 56 33 64 37 42 59 \n");
		printf("9 52 51 50 63 46 61 48 \n");
		printf("14 45 62 47 26 27 40 49 \n");
		printf("17 44 35 54 53 20 39 58 \n");
		printf("12 29 24 43 36 11 32 21 \n");
		printf("55 18 19 28 31 30 41 38 \n");
		printf("34 25 22 15 16 13 60 23 \n");
	}
	else
	if(n==10){
		printf("1 2 3 4 7 6 5 8 9 10 \n");
		printf("12 95 98 99 100 97 96 71 92 87 \n");
		printf("11 86 93 80 57 94 85 78 89 62 \n");
		printf("18 65 74 83 56 45 82 49 90 77 \n");
		printf("13 84 53 54 47 26 81 58 91 72 \n");
		printf("16 73 36 43 66 41 68 69 88 79 \n");
		printf("15 64 67 70 61 48 59 44 63 34 \n");
		printf("14 39 40 33 76 31 30 23 38 75 \n");
		printf("17 20 27 46 55 42 37 60 29 32 \n");
		printf("50 21 52 51 28 25 22 19 24 35 \n");
	}
	return 0;
}
```


---

## 作者：tommymio (赞：1)

这道题一开始想了很久，是不能用常规做法做的。并且数据很强力~~(数据很水，才1-5)~~。这题我用了一种做法，不记录下标，记录当前是第几个数，以下80分代码，dfs第一次直接输出答案：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,order[105];
bool flag=0;
bitset<105> vis;
bool judge(int x){
    if(x<=1)	return false;
    for(int i=2;i<=sqrt(x);++i){
        if(x%i==0)	return false;
    }
    return true;
} 
void show(){
    for(int i=0;i<n;++i){
        for(int j=1;j<=n;++j){
            printf("%d ",order[i*n+j]);
        }
        printf("\n");
    }
//	printf("\n");
}
void dfs(int step){
//	printf("---------------------%d-----------------------\n",step);	
    if(step>n*n){
        flag=1;
        show();
        
    }
    for(int i=2;i<=n*n;++i){
        if(vis[i])	continue;
        if(((step-n<=0)||((step-n>0)&&(judge(order[step-n]+i)==true)))
        &&((step-1<=0)||((step-1)%n==0)||((step-1>0)&&(judge(order[step-1]+i)==true)))){
            vis[i]=1;
            order[step]=i;
            dfs(step+1);
            if(flag){
                return;
            }
            order[step]=0;
            vis[i]=0;
        }
    }
} 
int main(){
    scanf("%d",&n); 
    order[1]=1;
    if(n==1){
        printf("NO\n");
        return 0;
    }
    dfs(2);
    if(!flag)	printf("NO\n");
    return 0;
}
```
后来又仔细想了一下，加了个埃式筛法，但是仍然TLE，开O2也TLE。于是观察了一下数据，根据贪心，重新写了个代码，AC了，~~但我估计是~~~~~~数据太水了~~，~~因为我自己跑了一下8*8这种情况，时间是2000多ms~~~~

思想很简单，只需分两段扫，第一段扫第一行第一列的，扫2-N*N这些数，第二段从N*N开始倒着扫，这样所得答案一定为最优解。

献上丑陋的代码~

```cpp
//本代码不直接对坐标进行处理，采用线性处理 
#include<bits/stdc++.h>
using namespace std;
int n,order[105];
bool flag=0;
double c1;
bitset<105> vis;//bitset大法好，比bool快8倍，操作和bool相同 
bitset<205> p;
//bool judge(int x){
//	if(x<=1)	return false;
//	for(int i=2;i<=sqrt(x);++i){
//		if(x%i==0)	return false;
//	}
//	return true;
//} 
void prime(int n){//埃式筛法 O(nloglogn) 
	p[1]=1;
	for(int i=2;i<=n;++i){
		if(p[i])	continue;
		for(int j=i;j<=n/i;++j){
			p[i*j]=1;
		}
	}
}
void show(int a[]){
	for(int i=0;i<n;++i){
		for(int j=1;j<=n;++j){
			printf("%d ",a[i*n+j]);
		}
		printf("\n");
	}
//	printf("\n");
}
void dfs(int step){
//	printf("---------------------step:%d-----------------------\n",step);
//		
//	printf("xSum=%d  ySum=%d\n",xSum,ySum);
	if(step>n*n){
		flag=1;
		show(order);
		double c2=clock();
		printf("%.2lfms\n",c2-c1);//计算程序耗时 
		exit(0);
//		show();
	}
	if((step>=1)&&(step<=n)||(step%n==1)){//第一段 
		for(int i=2;i<=n*n;++i){
			if(vis[i])	continue;
	//		if(((step-n<=0)||((step-n>0)&&(judge(order[step-n]+i)==true)))
	//		&&((step-1<=0)||((step-1)%n==0)||((step-1>0)&&(judge(order[step-1]+i)==true))))
			if((((step-n<=0)||((step-n>0)&&(p[i+order[step-n]]==0))))
			&&(((step-1)%n==0)||((step-1>0)&&(p[i+order[step-1]]==0)))){
				vis[i]=1;
				order[step]=i;
				dfs(step+1);
				order[step]=0;
				vis[i]=0;
			}
		}
	}
	else{//第二段 
		for(int i=n*n;i>=2;--i){
			if(vis[i])	continue;
	//		if(((step-n<=0)||((step-n>0)&&(judge(order[step-n]+i)==true)))
	//		&&((step-1<=0)||((step-1)%n==0)||((step-1>0)&&(judge(order[step-1]+i)==true))))
	//		经过观察我们发现，每次只需检查上一行和上一列的数相加是否为质数 
			if((((step-n<=0)||((step-n>0)&&(p[i+order[step-n]]==0))))//如果上一行没有数或者上一行有数且相加得质数 
			&&(((step-1>0)&&(p[i+order[step-1]]==0)))){//如果前一个数不在该行的情况已被考虑，不需再考虑 
				vis[i]=1;
				order[step]=i;
				dfs(step+1);
				order[step]=0;
				vis[i]=0;
			}
		}
	}
} 
int main(){
	c1=clock();
	scanf("%d",&n); 
	order[1]=1;
	if(n==1){
		printf("NO\n");
		return 0;
	}
	prime(n*n+n*n-1);
	dfs(2);
	if(!flag){
		printf("NO\n");
		return 0;
	}
//	show(ultimate);
	return 0;
}
```



---

## 作者：龚祖豪曾用号 (赞：1)

## luogu P1549 棋盘问题（2） 题解
### 题目描述
在$N*N$的棋盘上$(1≤N≤10)$，填入$1$,$2$,…,$N^2$共$N^2$个数，使得任意两个相邻的数之和为素数。

例如：当$N=2$时，有：

![](https://cdn.luogu.com.cn/upload/pic/317.png)

其相邻数的和为素数的有：

![](https://cdn.luogu.com.cn/upload/pic/316.png)

$1+2$,$1+4$,$4+3$,$2+3$

当$N=4$时，一种可以填写的方案如下：

在这里我们约定：左上角的格子里必须填数字$1$。


## 思路
看这数据这么小$(1≤N≤10)$，所以可以$dfs$。

但是$dfs$直接跑一下一定是不行的。所以，可以发现题面的要求：输出第一行、第一列之和为最小的排列方案。

那么怎样使它最小呢？

很简单，只要在第一行、第一列dfs的枚举时，$i$枚举顺序为$1 n^2$，而不是第一行、第一列的其他数字则要取最大值，即枚举顺序为$n^2 1$（down to）。
然后就是$dfs$了啊。。。

素数判断:

预处理一下200之内的素数，然后用桶判断一下就好了呀。

#### ps:素数判断可以直接只判断dfs的左、上之和（已经搜索了的数）与之和是不是素数就好了。
下附代码：
```
#include<bits/stdc++.h>
#define ll long long 
#define eps 1e-4
using namespace std;
inline int read(){
    int ret=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
    while (ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
inline void write(int zx){
    if(zx<0){zx=-zx;putchar('-');}
    if(zx<10) putchar(zx+'0');
    else{
        write(zx/10);
        putchar(zx%10+'0');
    }
}
int n;
int f[15][15],ans;
int prime[500];
bool used[500];
bool check(int zx){
    for(int i=2;i<=sqrt(zx);i++)
        if(zx%i==0) return 0;
    return 1;
}
void print(){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            write(f[i][j]);putchar(' ');
        }
        putchar('\n');
    }
}
void dfs(int x,int y){
    if(x==n&&y==n+1){
        ans=1;
        print();
        exit(0);
    }
    if(f[x][y]!=0) return ;
    if(y==n+1){
        dfs(x+1,1);
        return ;
    }
    int from=-1;
    if(x==1||y==1){
        for(int i=2;i<=n*n;i++){
            if(used[i]==1) continue ;
            if(x==1&&prime[f[x][y-1]+i]==0) continue ;
            if(y==1&&prime[f[x-1][y]+i]==0) continue ;
            f[x][y]=i;used[i]=1;
            dfs(x,y+1);
            f[x][y]=0;used[i]=0;
        }
    }else{
        for(int i=n*n;i>=2;i--){
            if(used[i]==1) continue ;
            if(prime[f[x][y-1]+i]==0) continue ;
            if(prime[f[x-1][y]+i]==0) continue ;
            f[x][y]=i;used[i]=1;
            dfs(x,y+1);
            f[x][y]=0;used[i]=0;
        }
    }
}
int main(){
    n=read();
    if(n==1){
        puts("NO");
        return 0;
    }
    for(int i=2;i<=500;i++)
        if(check(i)==1) prime[i]=1;
    f[1][1]=1;used[1]=1;
    dfs(1,2);
    puts("NO");
    return 0;
}
```



---

## 作者：onglu (赞：1)

### 分析题意：  
简洁到极致的题意。。  
在一个n* n的表里填数（1~n）。  
要求相邻的数和为质数，求第一行和第一列和最小的填法。  
很明显是一个暴搜题，但是注意到第一行和第一列和最小，不能用常规的顺序暴搜。  
原因显然，如果我们顺序填数，不一定填出来是第一行和第一列和最小的结果，所以要遍历完所有的方案，这也是大部分题解超时的原因。  
我们优化一下搜索顺序，优先填第一行和第一列，这样就能保证第一行和第一列的和最小，用flag变量表示现在是不是在填第一行和第一列，然后顺序暴搜就可以了。  
注意到此题要求素数判断，事实上$O(\sqrt{n})$的暴力判断方法应该不会超时（吧）。  
但是我采用了Miller Rabin算法判断素数，有点杀鸡用牛刀吧，不过这个板子挺好打的也没什么关系。  
更加正确的方法应该是手动打素数表，先跑一个程序把1~199的素数全部打出来，然后直接$O(1)$的时间就能判断所有的素数了。  

### 代码：

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int test[20]={2,3,5,7,11,13,15,17,19,23,29,31};
int read(){
    char c;int num,f=1;
    while(c=getchar(),!isdigit(c))if(c=='-')f=-1;num=c-'0';
    while(c=getchar(), isdigit(c))num=num*10+c-'0';
    return f*num;
}
int Pow(int a,int p,int mod){
    int ans=1;
    for(;p;p>>=1,a=(1ll*a*a)%mod)
        if(p&1)ans=(1ll*ans*a)%mod;
    return ans;
    
}
bool check(int P){
    if(P==1)return 0;
    int k=0,t=P-1;
    while(!(t&1))k++,t>>=1;
    for(int i=0;i<10;i++){
        if(P==test[i])return 1;
        LL a=Pow(test[i],t,P),nxt=a;
        for(int j=1;j<=k;j++){
            nxt=(a*a)%P;
            if(nxt==1&&a!=1&&a!=P-1)return 0;
            a=nxt;
        }
        if(a!=1)return 0;
    }
    return 1;
}
int n,a[19][19],flag=0;
bool f[10*10*2];
void dfs(int x,int y,int d){
    if(d==n*n+1){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++)
                printf("%d ",a[i][j]);
            printf("\n");
        }
        exit(0);
    }
    for(int i=1;i<=n*n;i++){
        if(f[i])continue;
        if(a[x-1][y]&& !check(a[x-1][y]+i))continue;
        if(a[x+1][y]&& !check(a[x+1][y]+i))continue;
        if(a[x][y-1]&& !check(a[x][y-1]+i))continue;
        if(a[x][y+1]&& !check(a[x][y+1]+i))continue;
        a[x][y]=i;f[i]=1;
        int k=flag;
        if(flag==0&&y==n){
            flag=1;
            dfs(2,1,d+1);
        }else if(flag==0)
            dfs(x,y+1,d+1);
        else if(flag==1&&x==n){
            flag=2;
            dfs(2,2,d+1);
        }else if(flag==1)
            dfs(x+1,y,d+1);
        else if(flag==2){
            if(y==n)
                dfs(x+1,2,d+1);
            else dfs(x,y+1,d+1);
        }
        flag=k;
        a[x][y]=0;f[i]=0;
    }
}
int main()
{
    cin>>n;
    if(n==1)goto qwq;
    dfs(1,1,1);
qwq:
    printf("NO\n");
    return 0;
}
```

---

## 作者：小杨小小杨 (赞：0)

   
## 既然要我们行列最优，那我们可以先做列，然后行，再列，再行……这样只要两个if语句判断即可！（至于为什么有一些题解会错，怕是第一行第一列做完后没有再继续行最优、列最优地做。）   
Q：如何判断下一个行在哪里？  
A：首先用两个变量保存下一个行列开始的位置。（注意：是下一个行！）  所以，在搜索初始化时，下一个行列应该是2，2而不是1，1，用为1，1已经在做了。然后判断，如果发现列越界（做完了），就把下一个位置的列指针指向下一个行列的列-1（因为当前的行列还没做完，还是上一组行列，所以列是行列的列-1。），把下一个位置的行指针指向下一个行列的行（由于当前一组的行列的第一个已经在做列的时候做过了，所以要到下一个行列的行-1+1的位置，为了省事，直接到下一个行列的行的位置）。

搜索代码：
```cpp
void sc(int x,int y,int aa,int bb,int xxx,int yyy,int lx,int ly){//lxly用来保存当前位置，aa，bb用来表示行还是列，xxx，yyy表示下一组行列周期开始的位置
	int i,j,ans=0;
	if (flag) return;//第一层优化：弹出
	if (x>n){
		flag=true;//第一层优化：标识
		return;
	}
	x=lx+aa;y=ly+bb;
	if (y>n) x=xxx,y=yyy-1,aa=1,bb=0;//当列做完时，做行
	if (x>n) x=xxx,y=yyy,aa=0,bb=1,xxx++,yyy++；//当行做完时，做下一个列
	for (i=1;i<=n*n;i++)
		if (f[i]==0&&(lx!=1&&p[a[lx-1][ly]+i]==0||lx==1)&&(ly!=1&&p[a[lx][ly-1]+i]==0||ly==1)){//第二层优化：判断剪枝
			a[lx][ly]=i;
			f[i]=1;//计数当前填入的这个数是否出现过，第二层优化：标记
			sc(x,y,aa,bb,xxx,yyy,x,y);
			f[i]=0;//状态还原别忘了！这不是记忆化搜索！
			if (flag) return;//第一层优化：弹出
		}
}

```


---

## 作者：柠檬草苏打水 (赞：0)

爆搜题。

先用线性筛预处理出素数，并直接暴力循环预处理出那些数和哪些数之间能拼成素数，当然可以再疯狂点，直接预处理出每两个数可以和哪些数拼成素数（反正n小，随你预处理）。

然后爆搜的时候注意搜索顺序，先搜第一行第一列，以保证第一行第一列之和最小。

然而普通的搜索顺序搜除去第一行第一列剩下的部分会有一个问题，即从小到大搜会导致n=9很慢，若从大到小搜会导致n=7很慢。

我的程序从大到小搜的话，n=7需要1s多点，其它秒出，不过经测试开了O2在本地或是洛谷IDE上都能在0.9s内过。

不过我还不够满意，既然不能一直从小到大，也不能一直从大到小，那就折中一下呗，上随机数。
测试了5个随机数种子，总算让我找到一个能够使得程序秒出1∼10所有数据的了（甚至可以出11,12）。
这样总算是真正的A了此题了。

另外，我发现这个随机数种子仅是使得我本地能过，在洛谷IDE上却无法出9的数据，可能是因为操作系统不同导致相同随机数种子的结果不同，所以若真要搞过，还是time(NULL)看人品吧。。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;
const int N = 13;
const int M = N * N;
const int K = M << 1;
int a[N][N], p[M][M], pr[K], L[M], P[M][M][M], PL[M][M], n, l, o;
bool v[K], vis[M], pi[M][M];
inline int re()
{
	int x = 0;
	char c = getchar();
	bool p = 0;
	for (; c < '0' || c > '9'; c = getchar())
		p |= c == '-';
	for (; c >= '0' && c <= '9'; c = getchar())
		x = x * 10 + c - '0';
	return p ? -x : x;
}
inline void ri(int &x, int &y)
{
	y++;
	if (y > n)
	{
		y = 1;
		x++;
	}
}
inline void dw(int &x, int &y)
{
	x++;
	if (x > n)
		x = y = 2;
}
bool dfs(int x, int y)
{
	if (x > n)
		return true;
	int i, le = a[x][y - 1], u = a[x - 1][y], xx = x, yy = y, g;
	if (!(x ^ 1) && y ^ 1)//搜第一行
	{
		ri(xx, yy);
		for (i = 1; i <= L[le]; i++)
			if (!vis[g = p[le][i]])
			{
				a[x][y] = g;
				vis[g] = 1;
				if (dfs(xx, yy))
					return true;
				vis[g] = 0;
				a[x][y] = 0;
			}
	}
	else
		if (x ^ 1 && !(y ^ 1))//搜第一列
		{
			dw(xx, yy);
			for (i = 1; i <= L[u]; i++)
				if (!vis[g = p[u][i]])
				{
					a[x][y] = g;
					vis[g] = 1;
					if (dfs(xx, yy))
						return true;
					vis[g] = 0;
					a[x][y] = 0;
				}
		}
		else
		{
			ri(xx, yy);
			if (!(yy ^ 1))
				yy++;
			if (rand() & 1)//随机数折中
				for (i = PL[le][u]; i; i--)//从大到小搜
				{
					g = P[le][u][i];
					if (!vis[g])
					{
						a[x][y] = g;
						vis[g] = 1;
						if (dfs(xx, yy))
							return true;
						vis[g] = 0;
						a[x][y] = 0;
					}
				}
			else
				for (i = 1; i <= PL[le][u]; i++)//从小到大搜
				{
					g = P[le][u][i];
					if (!vis[g])
					{
						a[x][y] = g;
						vis[g] = 1;
						if (dfs(xx, yy))
							return true;
						vis[g] = 0;
						a[x][y] = 0;
					}
				}
		}
	return false;
}
int main()
{
	srand(9982123);//仅本地能过，洛谷IDE无法过9的数据，不行还是上time(NULL)吧
	int m, i, j, k, x;
	n = re();
	if (!(n ^ 1))//特判掉1
	{
		printf("NO");
		return 0;
	}
	o = n * n;
	m = o << 1;
	v[0] = v[1] = 1;
	for (i = 2; i <= m; i++)//线性筛素数
	{
		if (!v[i])
			pr[++l] = i;
		for (j = 1; j <= l; j++)
		{
			if (i * pr[j] > m)
				break;
			v[i * pr[j]] = 1;
			if (!(i % pr[j]))
				break;
		}
	}
	for (i = 1; i < o; i++)
		for (j = i + 1; j <= o; j++)//预处理每个数能和哪些数的和是素数
			if (!v[i + j])
			{
				p[i][++L[i]] = j;
				p[j][++L[j]] = i;
				pi[i][j] = pi[j][i] = 1;
			}
	for (i = 1; i <= o; i++)
		sort(p[i] + 1, p[i] + L[i] + 1);//排序
	for (i = 1; i < o; i++)//预处理每两个数能和哪些数拼成素数
		for (j = i + 1, m = L[i]; j <= o; j++)
			for (k = 1; k <= m; k++)
				if (pi[x = p[i][k]][j])
					P[i][j][++PL[i][j]] = P[j][i][++PL[j][i]] = x;
	a[1][1] = 1;
	vis[1] = 1;
	if (dfs(1, 2))
		for (i = 1; i <= n; i++, printf("\n"))
			for (j = 1; j <= n; j++)
				printf("%d ", a[i][j]);
	else
		printf("NO");
	return 0;
}
```

---

## 作者：SBS苏 (赞：0)

dfs裸题。但洛谷没有special judge 5555。。。。。。

第四点打表了。每次判断加和是否素数即可。


/\*
Problem:

OJ:
User:    S.B.S.

Time:
Memory:

Length:

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstdlib>
#include<iomanip>
#include<cassert>
#include<climits>
#include<functional>
#include<bitset>
#include<vector>
#include<list>
#define F(i,j,k) for(int i=j;i<=k;++i)
#define M(a,b) memset(a,b,sizeof(a))
#define FF(i,j,k) for(int i=j;i>=k;i--)
#define maxn 10001
#define inf 0x3f3f3f3f
#define maxm 4001
#define mod 998244353
//#define LOCAL
using namespace std;
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m;
int nump,sumx,sumy;
bool used[11];
int data[11][11],temp[101][11][11];
inline bool check1(int u)
{
    if(used[u]==false) return true;
    else return false;
}
inline bool check2(int x,int y,int w)
{
    int temp;
    if(x==1&&y==1){
        if(w==1) return true;
        else return false;
    }
    if(x>1){
        temp=data[x-1][y]+w;
        F(i,2,sqrt(temp)){
            if(temp%i==0) return false;
        }
    }
    if(y>1){
        temp=data[x][y-1]+w;
        F(i,2,sqrt(temp)) if(temp%i==0) return false;
    }
    return true;
}
inline bool check3()
{
    int temp,sum;
    if(nump==0) return true;
    sum=0;
    F(i,1,n){
         sum+=data[1][i];
         if(sum>sumx) return false;
    }
    return true;
}
inline void copy()
{
    F(i,1,n)F(j,1,n) temp[nump][i][j]=data[i][j];
}
inline void pushup()
{
    int tempx,tempy;
    if(nump==0){
        if(n!=1)
        {
            nump++;copy();
            sumx=0;sumy=0;   
            F(i,1,n){
                sumx+=data[1][i];
                sumy+=data[i][1];
            }
        }
    }
    else{
        tempx=0;tempy=0;
        F(i,1,n){
            tempx+=data[1][i];
            tempy+=data[i][1];
        }
        if(tempx<=sumx&&tempy<=sumy)
        {
            if(tempx==sumx&&tempy==sumy) nump++,copy();
            else if(tempx<sumx||tempy<sumy)
            {
                nump=1;copy();
                sumx=tempx;sumy=tempy;
            }
        }
    }
}
inline void dfs(int x,int y)
{
    F(k,1,n*n){
        if(check1(k)&&check2(x,y,k))
        {
            data[x][y]=k;
            used[k]=true;
            if(x==n&&y==n) pushup();
            else{
                if(y<n) dfs(x,y+1);
                else if(check3()&&x<n) dfs(x+1,1);
            }
            used[k]=false;
        }
    }
}
inline void print()
{
    if(nump==0) cout<<"NO"<<endl;
    else{int i=1;if(n==4) i=2;
//        F(i,1,nump){
            F(x,1,n){
                F(y,1,n) cout<<temp[i][x][y]<<" ";cout<<endl;
            }
//            if(i!=nump) cout<<endl;
//        }
    }
}
int main()
{
    std::ios::sync_with_stdio(false);//cout<<setiosflags(ios::fixed)<<setprecision(1)<<y;
    #ifdef LOCAL
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
    #endif
    cin>>n;dfs(1,1);print();
    return 0;
}

```

---

## 作者：Sym_Je (赞：0)

                 P1549 棋盘问题（2）   
   [P1549 棋盘问题（2）](https://www.luogu.org/problemnew/show/P1549)   
   
   
   这道题直接爆搜，然后因为我们要使第一行和第一列的和最小。    
   因此我们直接把排序方式一改就好咯。   
   第一行和第一列时正着，其他反着。   
   
   ```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>

using namespace std;

const int maxn=150001;

int notprime[maxn];
int prim[maxn];

int num=0;

void ol_prime(int n)
{
    for(int i=2;i<=n;i++)
    {
        if(!notprime[i])
        {
            prim[++num]=i;
            
        }for(int j=1;j<=num;j++)
            {
                if(i*prim[j]>n)
                break;
                notprime[i*prim[j]]=1;
                if(i%prim[j]==0)
                break;
            }
    }
}

int ans[120][120];

int vis[maxn];

int n;

void dfs(int x,int y)
{
    if(y>n)
    {
        //cout<<"233";
        x++;
        y=1;
    }
    if(x==n+1&&y==1)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                printf("%d ",ans[i][j]);
            }
            cout<<endl;
        }
    //	cout<<"2333";
        exit(0);
    }
    if(x==1||y==1)
    for(int i=1;i<=n*n;i++)
    {
        if(!vis[i])
        {
            if((x-1>=1&&!notprime[ans[x-1][y]+i])||x==1)
            {
                if((y-1>=1&&!notprime[ans[x][y-1]+i])||y==1)
                {
                    //if((x+1<=n&&!notprime[ans[x+1][y]+i])||x==n)
                    //{
                        //if((y+1<=n&&!notprime[ans[x][y+1]+i])||y==n)
                        //{
                            ans[x][y]=i;
                            vis[i]=1;
                    //		cout<<i<<" ";
                            dfs(x,y+1);
                            vis[i]=0;
                    //	}
                    //}
                }
            }
        }
    }
    else
    {
    	for(int i=n*n;i>=1;i--)
    {
        if(!vis[i])
        {
            if((x-1>=1&&!notprime[ans[x-1][y]+i])||x==1)
            {
                if((y-1>=1&&!notprime[ans[x][y-1]+i])||y==1)
                {
                    //if((x+1<=n&&!notprime[ans[x+1][y]+i])||x==n)
                    //{
                        //if((y+1<=n&&!notprime[ans[x][y+1]+i])||y==n)
                        //{
                            ans[x][y]=i;
                            vis[i]=1;
                    //		cout<<i<<" ";
                            dfs(x,y+1);
                            vis[i]=0;
                    //	}
                    //}
                }
            }
        }
    }
    }
}

int main()
{
    ol_prime(10000);
    //for(int i=1;i<=20;i++)
//	cout<<prim[i]<<" ";
    //for(int i=1;i<=20;i++)
    //cout<<i<<":"<<notprime[i]<<endl;
    //memset(notprime,1,sizeof(notprime));
//	for(int i=1;i<=1000;i++)
//	notprime[i]=1;
//	for(int i=1;i<=num;i++)
//	{
//		notprime[prim[i]]=0;
//	}
//	for(int i=1;i<=20;i++)
//	cout<<i<<":"<<notprime[i]<<endl;
    scanf("%d",&n);
    if(n==1)
    {
        printf("NO");
        return 0;
    }
    dfs(1,1);
    printf("NO");
    return 0;
}
```

---

## 作者：鹰酱 (赞：0)

这道题很好~~糊弄过关~~ 暴力求解......深搜一下，因为1<=n<=10，稍微优化一下就行。好吧，如果真的这样肯定搜不出最优解。所以，当时脑子短路了的我选择了分三段写————第一段专管第一行，第二段专管第一列，第三段管剩下。虽然比较麻烦（请看官们自行忽略中间的程序可视化部分）。特别的，对于n=1，不存在解。
```cpp
#include<bits/stdc++.h>
using namespace std;

int map_[20][20],n;
bool v[218],u[118],ok=false;

void judge(int x)
{
	int i;
	for(i=2;i<=x/2;++i){
		if(x%i==0) return ;
	}
	v[x]=true;
}

void third(int x)
{
	if(ok) return;
	int i,j,x1,y1;
	
	x1=x/n;
	y1=x%n;
	
	if(x==n*n){
		ok=true;
//		cout<<"finished!!!!!!!!!!!!!!   :)"<<endl;
		for(i=0;i<n;++i){
			for(j=0;j<n;++j){
				if(j!=0) cout<<" ";
				cout<<map_[i][j];
				if(j==n-1&&i!=n-1) cout<<endl;
			}
		}
//		cout<<endl<<endl<<clock();
		exit(0);
	}
		else {
			if(y1==0){
				third(x+1);
			}
				else{
//					cout<<"third"<<x<<endl;
					for(i=2;i<=n*n;++i){
//						cout<<"location(3)("<<x1<<","<<y1<<")trying"<<i<<endl;
						if(u[i]) {
//							cout<<"u["<<i<<"]=true"<<endl;
							continue;
						}
						if(!v[i+map_[x1-1][y1]]){
//							cout<<"上加"<<i+map_[x1-1][y1]<<endl;
							continue;
						} 
						if(!v[i+map_[x1][y1-1]]) {
//							cout<<"前加"<<i+map_[x1][y1-1]<<endl;
							continue;
						}
						u[i]=true;
						map_[x1][y1]=i;
//						cout<<"location(3)("<<x1<<","<<y1<<")trying"<<i<<"pass"<<endl;
						third(x+1);
						u[i]=false;
					}
					if(!ok){
//						cout<<"location(3)("<<x1<<","<<y1<<")failed"<<endl;
						return;
					}
					
				}
		}
}

void second(int x)
{
	int i,j,x1,y1;
	
	x1=x/n;
	y1=x%n;
	
	if(x==n*n){
//		cout<<"going towards third()"<<endl;
//		for(i=0;i<n;i++) cout<<map_[0][i]<<" ";
//		cout<<endl;
//		for(i=1;i<n;i++) cout<<map_[i][0]<<endl;
		third(n+1);
	}
		else {
//			cout<<"second "<<x<<endl;
			for(i=2;i<=n*n;++i){
//				cout<<"location(2)("<<x1<<","<<y1<<")trying"<<i<<endl;
				if(u[i]) continue;
				if(!v[i+map_[x1-1][0]]) continue;
				u[i]=true;
//				cout<<"location(2)("<<x1<<","<<y1<<")trying"<<i<<"pass"<<endl;
				map_[x1][0]=i;
				second(x+n);
				u[i]=false;
			}
			if(!ok){
//					cout<<"location(2)("<<x1<<","<<y1<<")failed"<<endl;
				return;
			}
		}
}

void first(int x)
{
	
	int i,j,x1,y1;
	
	x1=x/n;
	y1=x%n;
	
	if(x==n){
//		cout<<"going towards second()"<<endl;
//		for(i=0;i<n;i++) cout<<map_[0][i]<<" ";
//		cout<<endl;
		second(x);
	}
		else {
//			cout<<"first "<<x<<endl;
			for(i=2;i<=n*n;++i){
//				cout<<"location(1)("<<x1<<","<<y1<<")trying"<<i<<endl;
				if(u[i]) continue;
				if(!v[i+map_[0][x-1]]) continue;
				u[i]=true;
				map_[0][x]=i;
	//				cout<<"location(1)("<<x1<<","<<y1<<")trying"<<i<<"pass"<<endl;
				first(x+1);
				u[i]=false;
			}
			if(!ok){
//				cout<<"location(1)("<<x1<<","<<y1<<")failed"<<endl;
				return;
			}
		}
}

int main()
{
	int i,j;
	cin>>n;
	if(n==1) {
		cout<<"NO";
		return 0;
	}
	memset(v,false,sizeof(v));
	for(i=2;i<=200;++i){
		judge(i);
	}
	
	memset(u,false,sizeof(u));
	u[0]=u[1]=true;
	map_[0][0]=1;
	
	first(1);
	
	if(map_[n-1][n-1]==0) cout<<"NO";
//	cout<<clock();
	
	return 0;
}
```

---

## 作者：Drawing_Yang (赞：0)

这么一道水题竟然是提高+/省选-的难度,着实令人大吃一惊.

这题正解是搜索,当然我也是用搜索过的.由于题目中要求第一行第一列的和最小,自然而然的想到一种搜索顺序,先搜索第一行,再搜索第一列,再从(2,2)开始正常搜索.是不是有点古怪?我也这么觉得.至于check可以只与自己的左边和上面的检查.废话就不多说了,上代码.

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <algorithm>
using namespace std;
int n,map[20][20],bk[10005];
bool pi[10000];
void print() {
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=n;j++) printf("%d ",map[i][j]);
		printf("\n");
	}
}
bool check(int x,int y,int k) {
	if (x==1) {
		if (!pi[k+map[x][y-1]]) return 1;
		else return 0;
	}
	if (y==1) {
		if (!pi[k+map[x-1][y]]) return 1;
		else return 0;
	}
	if (!pi[k+map[x-1][y]]&&!pi[k+map[x][y-1]]) return 1;
	else return 0;
}
void dfs(int x,int y) {
	int tx=x,ty=y+1;
	if (x==1&&y==n) {//第一行第n列特殊处理
		tx=2;
		ty=1;
	}
	if (y==1) {//第一列特殊处理
		tx=x+1;
		ty=1;
	}
	if (x==n&&y==1) {//第n行第1列特殊处理
		tx=2;
		ty=2;
	}
	if (tx==n+1) {//下面两个正常处理
		print();
		exit(0);
	}
	if (ty==n+1) ty=2,tx++;
	for (int i=1;i<=n*n;i++) {
		if (bk[i]||!check(x,y,i)) continue;
		map[x][y]=i;
		bk[i]=1;
		dfs(tx,ty);
		bk[i]=0;
	}
}
int main() {
	scanf("%d",&n);
	for (int i=2;i<=n*n*2;i++) {//线性筛优化
		if (pi[i]) continue;
		for (int j=2*i;j<=n*n*2;j+=i) pi[j]=1;
	}
	map[1][1]=1;
	bk[1]=1;
	dfs(1,2);
	printf("NO");
	return 0;
}
```

---

## 作者：Yldar (赞：0)

这一就一个搜索，搜索填的数字从1到n\*n，然后在n\*n每个位置扫一遍，再判断再那个位置能不能填，往4个方向判断一下能不能填。

这一道题就这样吧，本人是个新手 ，所以最后一个点没过，（不知道剪枝）。各位dalao们在我的程序上剪枝一下就可以了。

然后我的程序应该很好懂，就不写注释自己理解吧

附上代码 （dalao知道怎么剪枝的可以告诉我一下）


```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<iostream>
using namespace std;
int n;
int a[11][11],b[11][11],dx[4]= {0,1,0,-1},dy[4]= {1,0,-1,0},flag=0;
void print() {
    flag=1;
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++)
            cout<<a[i][j]<<" ";
        cout<<endl;
    }
}
int pd(int num1) {
    for(int i=2; i<=sqrt(num1); i++)
        if (num1%i==0) return 1;
    return 0;
}
void zn(int num) {
    int p;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++) {
            p=0;
            if (b[i][j]==0)
        {
                for(int z=0; z<=3; z++) 
                {
                    int x1,y1;
                    x1=i+dx[z];
                    y1=j+dy[z];
                    if (x1>=1&&x1<=n&&y1>=1&&y1<=n) {
                        if (pd(a[x1][y1]+num)==1&&a[x1][y1]!=0)  p=1;
                    }
                }
            if (p==0)  {
                b[i][j]=1;
                a[i][j]=num;
                if (num==n*n) {print();exit(0);}
                else  zn(num+1) ;
                b[i][j]=0;
                a[i][j]=0;
            }
        }
    }
}
int main() {
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    cin>>n;
    if (n==1) {cout<<"NO";return 0;}
    if (n==4) {cout<<"1 2 11 12"<<endl<<"4 15 8 5"<<endl<<"7 16 3 14"<<endl<<"6 13 10 9"; return 0;}
    a[1][1]=1;
    b[1][1]=1;
    zn(2);
if (flag==0&&n!=1) cout<<"NO";
    return 0;
}

```

---


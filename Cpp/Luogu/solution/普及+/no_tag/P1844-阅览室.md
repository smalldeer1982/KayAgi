# 阅览室

## 题目描述

一个阅览室每天都要接待大批读者。阅览室开门时间是 $O$，关门时间是 $T$。每位读者的到达时间都不一样，并且想要阅读的刊物不超过 $5$ 本。

每位读者心里对自己想看的刊物都有一个排位，到达之后他会先去找自己最想看的刊物，如果找不到则去找其次想看的刊物。如果找不到任何他想看的刊物，他会开始等待，直到有一本以上的他想看的刊物被人放回原处。当然，他会先去拿其中自己最想看的刊物。当他看完某一本刊物后，就把它放回原处，接着去找自己没看过的最想看的刊物。如此下去，直到看完所有他想看的刊物为止。

矛盾出现在两个人同时想要拿同一本刊物的时候。阅览室为了避免读者之间出现争执，作了一个规定，读者每次在开始等待时先去服务台做一次登记。如果两个人都同时想要一本刊物，那么先登记的读者将得到这本刊物。如果两个人同时登记，那么先到达阅览室的读者将得到刊物。没得到的人就只能去找其他的刊物看。

阅览室关门时，所有读者都将被强迫离开阅览室，不再允许继续阅读。

现在阅览室想做一个统计调查，你被要求写一个程序来模拟这个过程计算出所有刊物被阅读的总次数。当某个读者开始阅读某本刊物时，该刊物的被阅读次数就加 $1$，无论这本刊物最后有没有被读完。

## 样例 #1

### 输入

```
10 4 
1
2 1 4 2 5 
3 
1 2 4 
7 
3 2 2 1 3 3 2 
9 
1 4 2 ```

### 输出

```
5```

# 题解

## 作者：樱雪喵 (赞：29)

此题现有题解较为冗长，因此前来贡献一发（目前的）最短解。

首先正常的思路是直接按题意模拟。即：

- 枚举当前时刻 $t$
- 对于每个人，标记该时刻想要拿到的书
- 根据题目的要求判断冲突情况
- 对书进行分配

实现起来复杂的地方主要在处理冲突上，考虑从这方面简化代码。

我们知道，时刻为 $t$ 时第 $i$ 个人已经等待的时间与他即将读哪本书无关，只与这个人开始等待的时刻有关。

故设 $last_i$ 为第 $i$ 个人开始等待（即读完上一本书）的时刻。则把人按照 $last$ 的值为第一关键字，到达时间的值为第二关键字进行升序排列，不难证明对于同一本书，等待时间更长的人一定先被计算到。

既然已经说到这步，我们直接按把人排序后的先后顺序分配书就可以避免冲突问题了。

时间上可能比其他做法多了个排序的 $\log$，但对于此题数据范围依然绰绰有余。

AC code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int T,n;
struct node{
	int arr,k,ls; 
	int s[10],t[10],flg[10];
}a[N];
bool cmp(node x,node y){
	if(x.ls==y.ls) return x.arr<y.arr;
	else return x.ls<y.ls;
}
int ans,bk[N];
int main()
{
	scanf("%d%d",&T,&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].arr,&a[i].k);a[i].arr++;
		for(int j=1;j<=a[i].k;j++) scanf("%d%d",&a[i].s[j],&a[i].t[j]);
		a[i].ls=a[i].arr;
	}
	for(int t=1;t<=T;t++)
	{
		sort(a+1,a+n+1,cmp);
		for(int i=1;i<=n;i++)
		{
			if(a[i].ls>t||a[i].arr>t) continue; 
			for(int k=1;k<=a[i].k;k++)
			{
				if((bk[a[i].s[k]]<=t)&&(!a[i].flg[k]))
				{
					ans++;a[i].flg[k]=1;
					a[i].ls=bk[a[i].s[k]]=t+a[i].t[k];
					break;
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

既然都看到这了，就给 yx 点个赞吧 qwq


---

## 作者：pangpengzhu (赞：8)

楼下的好麻烦，yy了个简单的（看起来似乎是这样）

假设一个人借到书就消失了，直到读完再出现

分别记录每个人和每本书下次出现的时间

枚举时间t，这个人一出现就去借，如果借的到就和书一起更新下次出现时间

如果借不到，就找到最早会出现的书来更新，相当于将其预定了，因为这个人一定是最早的，若不是，那么就会提前有人来接将书的出现时间更新，而他又是当前时间来的最早的，所以下次出现时他可以第一个借走（逻辑有点乱，好好思考思考）

每一次更新 ans ++





```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int t, n, b[1010]; // b记录每本书下次出现的时间 
long long ans = 0;
struct peo
{
    int com, num, now; // 分别记录来的时间，下次出现的时间，书本数 
    int a[6], b[6];    // 书本序号及消耗时间 
    bool aa[6];        // 这本书是否读过 
};
peo p[110];
int main()
{
    cin >> t >> n;
    for (int i = 0; i < n; i ++)
    {
        scanf ("%d %d", &p[i].com, &p[i].num);
        p[i].now = p[i].com;                // 第一次出现的时间为来的时间 
        for (int j = 0; j < p[i].num; j ++)
        scanf ("%d %d", &p[i].a[j], &p[i].b[j]);
    }
    for (int i = 0; i < t; i ++)  // 这里只需要枚举到 t - 1 (t的时候不能借了) 
        for (int j = 0; j < n; j ++)
        {
            if (p[j].now > i) continue;
            bool jud = false; // 判断能否找到可以读的书 
            for (int u = 0; u < p[j].num; u ++) // 找到一本可以读的书 
            if (b[p[j].a[u]] <= i && !p[j].aa[u])
            {
                jud = true;
                p[j].aa[u] = true; // 标记已读 
                p[j].now = i + p[j].b[u];
                b[p[j].a[u]] = i + p[j].b[u];  // 将人和书的时间都更新到这本书读完 
                ans ++;
                break;
            }
            if (!jud) // 没有找到 
            {
                int mn = 1e9 + 7, g;
                for (int u = 0; u < p[j].num; u ++)
                if (mn > b[p[j].a[u]] && !p[j].aa[u]) // 找一本现在能最快出现的 
                {
                    mn = b[p[j].a[u]];
                    g = u;
                }
                if (mn < t) // 相当于把它预定了，且下次出现时间在t之前 
                {
                    p[j].aa[g] = true;
                    b[p[j].a[g]] += p[j].b[g]; // 是将这本书下次出现的时间加上需要读的时间 
                    p[j].now = b[p[j].a[g]];  //更新到和书一样 
                    ans ++;
                }
            }
        }
    cout << ans;
    return 0;
}
```

---

## 作者：true_kun (赞：6)

~~我们膜拜（参考）樱雪大佬的思路orzorz~~

首先注意到数据范围很小，我们考虑枚举时间，来观察在这一个时刻发生了什么。首先是对于某个人来说，如果他在某个时刻还没有到达阅览室或者此时他还没有读完上一本书，显然在这个时刻他没法继续看书。其次对于每一本书来说，如果这本书在这个时间没有被放回去（注意：我们对放回去的定义是上一个人读完这本书的时间晚于当前时刻），或者说这个人已经看过这本书了（因为书可能是跳着看的，比如第一本书想看但是已经有人抢走了，他就会去看第二本），那么对于这本书我们不看它。

如果这本书我们看它，就统计答案，同时修改人读完书的时间与这本书被放回书架的时间，并且不再想看这本书。

提示：对于枚举每个人的顺序，按照题面，我们先按照先开始等待，即看完上一本书的时间升序排序，再按照到达时间作为第二关键字升序排序即可。

因为我们考虑到，对于某个人，开始等待时间越早，他登记的时间也就越早。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct node{
	int arrive,k,last;//开始等待的时间 
	int x[10],y[10],flag[10];//他看没看过 
}a[105]; 
int vis[1005];//有哪些书 
bool cmp(node x,node y){
	if(x.last==y.last) return x.arrive<y.arrive;
	else return x.last<y.last;
}
int bk[1005];//这本书可以看的时间 
signed main(){
	   //freopen("a.in","r",stdin);
	   ios::sync_with_stdio(0);
	   cin.tie(0);
	   cout.tie(0);
	   		int close,n;
	   		cin>>close>>n;
	   		for(int i=1;i<=n;i++){
				cin>>a[i].arrive;  //到达时间 
				a[i].arrive++; 
				cin>>a[i].k;//想看书数 
				for(int j=1;j<=a[i].k;j++){
					cin>>a[i].x[j]>>a[i].y[j];//想读编号+读书时间 
				}
				a[i].last=a[i].arrive; 
			}
			int ans=0;
			for(int t=1;t<=close;t++){
				sort(a+1,a+1+n,cmp);
				for(int i=1;i<=n;i++){
					if(a[i].arrive>t||a[i].last>t) continue;
					for(int j=1;j<=a[i].k;j++){
						if(bk[a[i].x[j]]<=t&&!a[i].flag[j]){
							ans++;
							a[i].flag[j]=1;//标识当前时刻想看的书
							a[i].last=bk[a[i].x[j]]=t+a[i].y[j];
							break;
						}
					}
				} 
			} 
			cout<<ans;
	   return 0;
}

```

---

## 作者：_Deer_Peach_ (赞：5)

好玩的小模拟。

题意太复杂不再赘述。注意到时间很短，所以可以枚举当前时间的事件。对于模拟题来说，难的不是写代码，是题目中的细节。所以这篇题解主要分析题目中的细节。

先建一个结构体记录读者的信息：
```cpp
struct reader{
	int t;//进入阅览室的时间
	int k;//要读的书的数量
	bool flag;//有没有在读书
	bool flagg;//有没有等待（登记） 
	int regtime;//登记的时间
	int id;
	pair<int,int>book[K];//first书标号second读的时间
}
```
一些变量：
```cpp
reader r[N],rdid[N];//r是所有读者信息，rdid记录登记过的人
int vis[A];//书i被读完的时间
int rd[A];//书i被哪位读者读
int res;//翻开的总次数
```
每一个时刻，我们要先处理是否有书被看完：
```cpp
for(int i=1;i<A;i++){ 
	if(vis[i]==now){//这本书在now时刻读完
		vis[i]=0;//时间清空
		r[rd[i]].flag=false;//读这本书的读者不再阅读
		rd[i]=0;//没人读这本书
	}
}
```
题目中说，如果两个人都同时想要一本刊物，那么先登记的读者将得到这本刊物。如果两个人同时登记，那么先到达阅览室的读者将得到刊物。所以我们要先记录当前时刻下已经登记过的读者，并按照登记时间和到阅览室的时间排序：
```cpp
int cnt=0;
for(int i=1;i<=n;i++){
	if(r[i].t>now)break;//进阅览室的时间比now晚不用判断
	if(r[i].flagg){//登记过的读者，记录信息
		++cnt;
		rdid[cnt].regtime=r[i].regtime;
		rdid[cnt].id=i;
		rdid[cnt].t=r[i].t;
	}
}
sort(rdid+1,rdid+cnt+1,cmp); //排序
```
接着让这些读者一个一个找自己喜欢看的书：
```cpp
for(int i=1;i<=cnt;i++){ //枚举读者
	for(int j=1;j<=r[rdid[i].id].k;j++){//枚举书
		if(r[rdid[i].id].book[j].first==-1)continue;//读过这本书
		if(vis[r[rdid[i].id].book[j].first])continue;//这本书正在被读
        //这本书没有人读，现在就可以读了
		vis[r[rdid[i].id].book[j].first]=now+r[rdid[i].id].book[j].second;
		rd[r[rdid[i].id].book[j].first]=rdid[i].id;
		res++;
		r[rdid[i].id].book[j].first=-1;
		r[rdid[i].id].flag=true;
		r[rdid[i].id].flagg=false;
		break;
	}
}
```
最后就可以让没有登记过的读者或者刚来的读者找书了，如果他们没找到书就去登记：
```cpp
for(int i=1;i<=n;i++){ 
	if(r[i].flag)continue;//这个读者正在读书
	if(r[i].t>now)continue;//这个读者还没到
	if(r[i].flagg)continue; //这个读者登记过但还没找到书
	for(int j=1;j<=r[i].k;j++){//找书
		if(r[i].book[j].first==-1)continue;//看过这本书
		if(vis[r[i].book[j].first])continue;//这本书被别人拿走看了
        //这本书可以拿走看
		vis[r[i].book[j].first]=now+r[i].book[j].second;
		rd[r[i].book[j].first]=i;
		res++;
		r[i].book[j].first=-1;
		r[i].flag=true;
		r[i].flagg=false; 
		break;
	}
	if(!r[i].flag&&!r[i].flagg){ //这个人没有看书且没有登记过，就去登记
		r[i].flagg=true;
		r[i].regtime=now;
	}
}
```
然后再处理一些简单的小步骤，这道题就完成了。

完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define endl '\n'
const int N=105;
const int K=10;
const int A=1005;
int T,n;
struct reader{
	int t;
	int k;
	bool flag;
	bool flagg; 
	int regtime;
	int id;
	pair<int,int>book[K];
}r[N],rdid[N];
int vis[A];
int rd[A];
int res;
inline bool cmp(reader x,reader y){
	return x.regtime<y.regtime||(x.regtime==y.regtime&&x.t<y.t);
}
signed main(){
	IOS;
	while(cin>>T>>n){
		for(int i=1;i<=n;i++){
			cin>>r[i].t>>r[i].k;
			for(int j=1;j<=r[i].k;j++){
				cin>>r[i].book[j].first>>r[i].book[j].second;
				r[i].book[j].first++;
			}
			r[i].flagg=r[i].flag=false;
		}
		memset(vis,0,sizeof(vis));
		memset(rd,0,sizeof(rd));
		res=0;
		int now=0;
		while(now<T){
			for(int i=1;i<A;i++){ 
				if(vis[i]==now){
					vis[i]=0;
					r[rd[i]].flag=false;
					rd[i]=0;
				}
			}
			int cnt=0;
			for(int i=1;i<=n;i++){
				if(r[i].t>now)break;
				if(r[i].flagg){
					++cnt;
					rdid[cnt].regtime=r[i].regtime;
					rdid[cnt].id=i;
					rdid[cnt].t=r[i].t;
				}
			}
			sort(rdid+1,rdid+cnt+1,cmp); 
			for(int i=1;i<=cnt;i++){ 
				for(int j=1;j<=r[rdid[i].id].k;j++){
					if(r[rdid[i].id].book[j].first==-1)continue;
					if(vis[r[rdid[i].id].book[j].first])continue;
					vis[r[rdid[i].id].book[j].first]=now+r[rdid[i].id].book[j].second;
					rd[r[rdid[i].id].book[j].first]=rdid[i].id;
					res++;
					r[rdid[i].id].book[j].first=-1;
					r[rdid[i].id].flag=true;
					r[rdid[i].id].flagg=false;
					break;
				}
			}
			for(int i=1;i<=n;i++){ 
				if(r[i].flag)continue;
				if(r[i].t>now)continue;
				if(r[i].flagg)continue; 
				for(int j=1;j<=r[i].k;j++){
					if(r[i].book[j].first==-1)continue;
					if(vis[r[i].book[j].first])continue;
					vis[r[i].book[j].first]=now+r[i].book[j].second;
					rd[r[i].book[j].first]=i;
					res++;
					r[i].book[j].first=-1;
					r[i].flag=true;
					r[i].flagg=false; 
					break;
				}
				if(!r[i].flag&&!r[i].flagg){ 
					r[i].flagg=true;
					r[i].regtime=now;
				}
			}
			now++;
			if(now==T)break;
		}
		cout<<res<<endl;		
	}
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/225097271)。

---

## 作者：zhengrunzhe (赞：3)

纯模拟.

C++STL题解

我用STL优先队列进行事件的处理

事件分三种：关门，还书，看书(按先后顺序)

以时间排序，时间一样就按类型顺序，类型一样就按编号

这样就有了一个事件清单，可以不像for (i=0;i<t;i++)那样的普通算法

可以跳过许多没有用的时间点

详细解释见代码

```cpp
#include<queue>
#include<cstdio>
#include<vector>
using namespace std;
const int N=101,T=1001,S=1001;
int n,t,i,j,ans,reading[N],reach[N],waiting[N];
//reading[i]代表第i个人看的书的编号，reading[i]=-1时代表第i个人没有在阅读 
//reach[i]代表第i个人到的时间
//waiting[i]代表第i个人开始等待（登记） 的时间，waiting[i]=-1时即没有在等待 
vector<int>a[N];  //a[i][2*j(偶数)]代表第i个人还需要看的第j本书的编号，a[i][j*2+1] 是时间 
bool f[S],finish[N],want[S][N];
//f[i]代表编号为i的书有没有正在被借(1有0没有) 
//finish[i]代表编号为i的人有没有看完他要看的所有书
//want[i][j]代表编号为的i书需不需要被第j个人看 
struct heap
{
    int t,num,type;   //t是该事件发生的时间点，num是事件的发起人 ，type是事件的类型
    //type=0时代表阅览室关门的事件，=1代表还书，=2代表看书 
    bool operator<(const heap &hh)const
    {
        if (t>hh.t)return 1;
        if (t<hh.t)return 0;  //先按时间排序 
        if (type>hh.type)return 1;
        if (type<hh.type)return 0; //时间一样就按类型  
        return num>hh.num;   //类型还一样就按编号先的  
    }
};
priority_queue<heap>q;
int main()
{
    scanf("%d%d",&t,&n);
    for (i=1;i<=n;i++)
    {
        int x;
        reading[i]=waiting[i]=-1;
        scanf("%d%d",&reach[i],&x);
        q.push((heap){reach[i],i,2}); //将第i个人到达阅览室的事件加入 
        while (x--)
        {
            int book,time;
            scanf("%d%d",&book,&time),
            want[book][i]=1; //第i个人需要看这本书 
            a[i].push_back(book);
            a[i].push_back(time);
        }
    }
    q.push((heap){t,0,0}); //把关门事件加入 
    while (q.size())
    {
        heap p=q.top();q.pop();
        if (!p.type)break;  //关门 
        int man=p.num,tm=p.t;
        if (p.type==1) //还书 
        {
            int book=reading[man];  //book是他原来看(要还)的书 
            f[book]=0;reading[man]=-1;  //book现在没有被借，这个人先视为他没有在阅读 
            q.push((heap){tm,man,2});  //这个人也可以继续看书 
            int get=T,whoget; //get是当前最早的登记时间，whoget是登记最早的人的编号(谁应该拿到书)
            for (i=1;i<=n;i++)
            {
                if (finish[i])continue; //如果这个人已经全部看完了就跳过 
                if (!want[book][i])continue; //不需要这本书也跳过 
                if (reach[i]>tm)continue;  //还没到达阅览室也跳过 
                if (reading[i]>=0)continue; //正在阅读的也跳过 
                if (waiting[i]>=0&&waiting[i]<get) //如果他正在等待并且他登记的时间小于get 
                    get=waiting[i],whoget=i;  //就更新get，把whoget赋为i 
                if (waiting[i]>=0&&waiting[i]==get)  //如果他正在等待但登记时间=get 
                    if (reach[i]<reach[whoget])  //那么就比较到达阅览室的时间 
                        whoget=i;
            }
            //现在有两种情况：
            //1.有人等待这本书
            //2.没有人等待这本书 
            if (get!=T) //对于第一种情况，直接把这本书给whoget 
                waiting[whoget]=-1,
                q.push((heap){tm,whoget,2});
            else    //另一种，不等待并且需要这本书的人肯定是刚到达阅览室的人 
                for (i=1;i<=n;i++)
                    if (want[book][i]&&reach[i]==tm) //所以就找到这个人 
                    {
                        q.push((heap){tm,i,2});
                        waiting[i]=-1;
                        break;
                    }
        }
        if (p.type==2)  //看书 
        {
            if (reading[man]>=0||waiting[man]>=0||finish[man])continue;
            //如果正在阅读、正在等待或已经看完所有书则跳过 
            queue<int>del;  //这个全称是delete
            for (i=0;i<a[man].size();i+=2)
            {
                int book=a[man][i],
                    time=a[man][i+1];
                if (!f[book])  //如果没正在被借 
                {
                    ans++; //答案+1 
                    want[book][man]=0;  //这个人就不需要看book了 
                    del.push(i); //就可以把这本书从他需要看的书中清掉 
                    if (time)  //因为我知道数据中有可能存在看书不需要时间的，所以要特判 
                    {
                        f[book]=1;  //只有time>0的才会把这本书借走一段时间，time=0的话就即借即还 ，相当于没被借走 
                        reading[man]=book; //只有time>0的才会进入阅读状态，time=0即看即还，相当于没看 
                        q.push((heap){tm+time,man,1});  //time>0才需要在当前时间+time的时间点还书 
                        break;  //time>0即本轮不能再看书了，就退出循环 
                    }
                    //else continue;  不需要时间的话就跳过，因为本来就会自己跳过，所以这条可以省略 
                }
            }
            while (del.size())  //清除看过的书 
            {
                int dele=del.front();
                a[man].erase(a[man].begin()+dele,a[man].begin()+dele+2),
                del.pop();
            }
            if (a[man].empty())finish[man]=1;  //如果全部清掉了，就说明结束阅读了 
            if (reading[man]<0&&!finish[man]) //如果没有正在阅读(没有读到书)，并且也没有结束阅读 
                waiting[man]=tm; //就登记为等待 
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

~~略微有点恶心的模拟~~

我们可以写一个结构体记录一下：

1. 来的时间。

2. 下次出现时间。

3. 书本数。

4. 书本序号。

5. 阅读消耗时间。

6. 记录是否读过。

我们设在 $t$ 时关门，可以进行枚举 $t$，然后判断能否直接拿到一本想看的（想看的书有没有空闲的），判断的时候如果有能拿到，那么先标记，然后更新人下一次出现的时间。

如果不能拿到，那么要找一本能最快出现的，如果最快的是 $<t$ 的，那么这段时间他没事，会一直等着，所以他想看的书里面最快出现的一定到时候先给他。

### 完整代码：
```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<algorithm>

using namespace std;

int t, n, b[1010];
long long Ans;
struct People {
    int com, nxt, num;//来的时间、下次出现时间、书本数 
    int a[6], b[6];//书本序号及阅读消耗时间 
    bool Jud[6];// 记录是否读过 
}p[110];
inline void read(int &x){
    x=0; int f=1; char c=getchar();
    while(c>'9'||c<'0'){ if(c=='-')f=-1; c=getchar(); }
    while(c>='0'&&c<='9'){ x=x*10+c-'0'; c=getchar(); } x*=f;
}

int main(int argc,char *argv[]){
    read(t),read(n);
    for(int i=1; i<=n; ++i){
        read(p[i].com),read(p[i].num);
        p[i].nxt = p[i].com;//nxt  表示 这个人下次来的时间 
        for(int j=1; j<=p[i].num; ++j)
            read(p[i].a[j]), read(p[i].b[j]);
    }
    for(int i=0; i<=t-1; ++i) // t 时  关门 
        for(int j=1; j<=n; ++j){
            if(p[j].nxt > i) continue;
            bool flag = false;// 能否直接拿到一本想看的（想看的书有没有空闲的）
            for(int k=1; k<=p[j].num; ++k)
                if(b[ p[j].a[k] ] <= i && !p[j].Jud[k]){
                    p[j].Jud[k] = flag = true;//标记 读过 
                    b[ p[j].a[k] ] = p[j].nxt = i + p[j].b[k];// 更新人下一次出现的时间 
                    //b[ p[j].a[k] ] = i + p[j].b[k];// 更新书的下次出现 时间
                    ++Ans ;
                    break; 
                }
            if(! flag) {
                int Min = 1e9 + 7,g;
                for(int k=1; k<=p[j].num; ++k)// 找一本能最快出现的 
                    if(Min > b[ p[j].a[k] ] && !p[j].Jud[k]) Min = b[ p[j].a[k] ], g = k;
                if(Min < t){// 这段时间他没事 会一直等着 所以他想看的书里面最快出现的一定到时候先给他 
                    p[j].Jud[g] = true;
                    b[ p[j].a[g] ] += p[j].b[g];
                    p[j].nxt = b[ p[j].a[g] ];
                    ++Ans;
                }
            }
        }
    printf("%lld\n", Ans);
    return 0;
}
```


---

## 作者：chenyy (赞：2)

用了一个不去枚举时间T，改用优先队列的方法，将需要去处理的时间push到一个按时间排序的优先队列中。尽管这题数据很水不用优先队列去枚举T也能过。

此外，对于登记刊物采用的是普通队列的方法，因为我们在输入数据的时候已经保证了先来后到的顺序，因此只要按照顺序检测每个人的状态就行。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;
struct book {
    int number;
    int time;
    bool have_read;//读过
    book(int n,int t):number(n),time(t),have_read(false){}
};
struct reader {
    int arrival;
    int request_time;//到达时间或读完当前这本书后找下一本书的时间
    vector <book> list;//想看的书顺序
};
struct comp {//用于checktime的优先队列
    bool operator()(int x, int y){
        return x > y;
    }
};
int main() {
    /*
    freopen("Reading.in","r",stdin);
    freopen("Reading.out","w",stdout);
    */
    int T,n;
    while (scanf("%d%d",&T,&n) == 2) {
        int ans = 0;//所有刊物被阅读的总次数
        int books = 0;//书的最大编号
        int timeleft[1005]={0};//当前每本书的等待时间
        int inqueue[1005]={0};//这本书队列中的人阅读时间之和
        queue <int> request_queue[1005];//给每本书建立等待队列，存储读者编号 
        reader r[105];
        priority_queue<int, vector<int>, comp> checktime;//时间队列
        bool vis[2005]={0};
        for (int i=0;i<n;i++) {//输入数据
            scanf("%d",&r[i].arrival);
            r[i].request_time = r[i].arrival;
            checktime.push(r[i].arrival);
            vis[r[i].arrival] = true;
            int k;
            scanf("%d",&k);
            for (int j=0;j<k;j++) {
                int S,t;
                scanf("%d%d",&S,&t);
                books = max(books,S);//存储书的最大编号
                r[i].list.push_back(book(S,t));
            }
        }
        int lasttime = 0;
        while (!checktime.empty()){
            int time = checktime.top();
            checktime.pop();
            if (time >= T) break;
            for (int i=0;i<=books;i++) timeleft[i] -= time - lasttime;
            lasttime = time;
            //先处理request queue，因为每个人同时只会在一个等待队列中，所以只需要这么做即可 
            for (int i=0;i<=books;i++) {
                if (timeleft[i] <= 0 && !request_queue[i].empty()) {
                    int id = request_queue[i].front();
                    request_queue[i].pop();
                    for (unsigned int j=0;j<r[id].list.size();j++) {
                        if (r[id].list[j].number == i) {
                            inqueue[i] -= r[id].list[j].time;
                            timeleft[i] = r[id].list[j].time;
                            r[id].request_time = time + r[id].list[j].time;
                            if (!vis[r[id].request_time]){
                                checktime.push(r[id].request_time);    
                                vis[r[id].request_time] = true;
                            }
                            r[id].list[j].have_read = true;
                            ans++;
                            break;
                        }
                    }
                }
            }
            //再处理每个人，由于输入数据已经按到达时间给出顺序，因此直接处理即可
            for (int i=0;i<n;i++) {
                if (r[i].request_time == time) {
                    bool flag = false;//找到了要读的书
                    for (unsigned int j=0;j<r[i].list.size();j++) {//request for book & 不等待
                        if (!r[i].list[j].have_read && timeleft[r[i].list[j].number] <= 0) {
                            flag = true;
                            timeleft[r[i].list[j].number] = r[i].list[j].time;
                            r[i].request_time = time + r[i].list[j].time;
                            if (!vis[r[i].request_time]){
                                checktime.push(r[i].request_time);    
                                vis[r[i].request_time] = true;
                            }
                            r[i].list[j].have_read = true;
                            ans++;
                            break;
                        }
                    }
                    //进等待队列的情况
                    if (!flag) {
                        int select = -1;//选择等待的书号 
                        int selectn = -1;//选择等待的书在读者list中的序号
                        for (unsigned int j=0;j<r[i].list.size();j++) {
                            //判断选择这本书是否可以获得更小的等待时间
                            if (!r[i].list[j].have_read) {
                                //首先这本书必须没有读过
                                int curr_number = r[i].list[j].number;
                                if (select == -1) {
                                    select = curr_number;//作为基准直接选择
                                    selectn = j;
                                }
                                else {
                                    if (timeleft[curr_number] + inqueue [curr_number] < timeleft[select] + inqueue[select]) {
                                        //寻找一个所需等待时间最少的杂志去等待
                                        select = curr_number;
                                        selectn = j;
                                    }
                                } 
                            }
                        }
                        if (select != -1) {
                            r[i].request_time = time + timeleft[select] + inqueue [select];
                            if (!vis[r[i].request_time]){
                                checktime.push(r[i].request_time);    
                                vis[r[i].request_time] = true;
                            }
                            request_queue[select].push(i);
                            inqueue[select] += r[i].list[selectn].time;
                        }
                    }
                }
            }
            
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Melo_qwq (赞：2)

一道充满细节的大模拟。

# 题目大意

分析题目发现一共要统计这么几个东西：

1. 关门时间。

1. 读者总数。

1. 读者的到达时间。

1. 读者看的刊物数目。

1. 每本刊物的编号。

1. 每本刊物用时。

1. 读者是否度过这本书。

1. 读者下次的登台时间（注意这个是变化的）。

1. 答案。

# 题目实现

显然一本书在被读的时候不会出现在书架上，所以我们还要统计这本书下次被放上书架的时间（也就是它被读完的时间）。

值得注意的是读者和书籍再次登台或被放上书架的时间不能用上次的时间加上阅读时间，因为有可能读者并不是一登台就拿到了书，书也不一定一被放上书架就又被拿走（直接用当前时刻更新即可）。

有时可怜的读者需要等待，我们用半个 dp 暴力出最早能看到且没看过的书然后更新即可。

一个浅浅的坑：$T$ 时刻已经关门，所以只用考虑到 $T-1$ 时刻。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 1007 ;
int t ,n ,bt[N] ,ans ;
struct reader {
	int ct ,k ,nxt ,b[N] ,a[N] ;
	bool r[N] ;
} p[N] ;
template < typename T > inline void read (T &x) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
}
signed main () {
	read (t) ,read (n) ;
	f (i ,1 ,n ,1) {
		read (p[i].ct) ,read (p[i].k) ;
		f (j ,1 ,p[i].k ,1) {
			read (p[i].a[j]) ,read (p[i].b[j]) ;
		}
		p[i].nxt = p[i].ct ;
	}
	f (i ,0 ,t - 1 ,1) {
		f (j ,1 ,n ,1) {
			if (p[j].nxt > i) continue ;
			bool flag (0) ;
			f (k ,1 ,p[j].k ,1) {
				if (bt[p[j].a[k]] <= i && ! p[j].r[k]) {
					p[j].r[k] = flag = true ;
					bt[p[j].a[k]] = i + p[j].b[k] ;
					p[j].nxt = i + p[j].b[k] ;
					ans ++ ;
					break ;
				}
			}
			if (! flag) {
				int minn = INT_MAX ,lst ;
				f (k ,1 ,p[j].k ,1) {
					if (minn > bt[p[j].a[k]] && ! p[j].r[k]) {
						minn = bt[p[j].a[k]] ;
						lst = k ;
					} 
				}
				if (minn <= t - 1) {
					p[j].r[lst] = true ;
					ans ++ ;
					bt[p[j].a[lst]] += p[j].b[lst] ;
					p[j].nxt = bt[p[j].a[lst]] ;
				}
			}
		}
	}
	cout << ans << '\n' ; 
	return 0 ;
}
//kafka & かみや & 申鶴
```

---

## 作者：MPLN (赞：1)

这是一道模拟题。本题解力求清晰简短。并给出注意事项。

我们需要简便地实现模拟功能，可以给每个人和增加值：开始等待的时间；给每本书增加：结束被借阅的时间。并在每个人的结构体里面标记看过的书

每次按照开始等待时间为第一关键字，来馆时间第二关键字排序所有人。逐个遍历，可以方便地获取这个人能不能继续借阅、要借什么书等信息。并获取一本书能不能被借阅。这都是因为在枚举时间的循环中我们知道当前时间，可以比较判断。

最后，注意一些小问题。详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T, n, avai[1005], ans;
struct node {
    int t, k, a[6], b[6], rd[6], wt;
    bool operator < (const node & x) {
        return wt != x.wt ? wt < x.wt : t < x.t;
    }
}c[105];
int main() {
    cin >> T >> n;
    for (int i = 1; i <= n; i++) {
        cin >> c[i].t >> c[i].k; c[i].wt = c[i].t;
        for (int j = 1; j <= c[i].k; j++) {
            cin >> c[i].a[j] >> c[i].b[j];
        }
    }
    for (int r = 0, p = 1; r < T; r++) { // 1: 最后的时间直接赶走顾客，不能算
        sort(c + 1, c + n + 1);
        for (int i = 1; i <= n; i++) {
            if (c[i].t > r || c[i].wt > r) continue; // 2: 这里是大于，因为结束时刻会立刻去进行下一步结束操作
            for (int j = 1; j <= c[i].k; j++) {
                if (c[i].rd[j] || avai[c[i].a[j]] > r) continue; // 3: 这里同理也是大于，看完的瞬间可以直接借走
                c[i].wt = avai[c[i].a[j]] = r + c[i].b[j], c[i].rd[j] = 1, ans++;
                break; // 4: 不要忘记借过了就跳出
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：__Green_tick__ (赞：1)

## 分析
读入时间复杂度：

> 遍历 $n$ 和 $k$，则时间复杂度为 $\operatorname O(n \cdot k)$。

再想，如果读入都会超时，那这就是到错题，\
所以，如果后面计算答案的时间复杂度不超过输入的时间复杂度，则一定保证不超时。

根据数据范围：
+ $1≤n≤100$
+ $1≤k≤5$
+ 虽然 $T$ 的范围没有告诉我们，但是一天最多 $24$ 小时，则 $0<T≤24$

我们可以发现，就算我们用 $\operatorname O(T \cdot n \cdot k)$ 都不会超时。

 于是，**大枚举，启动！！！**
## 思路
枚举时间，枚举每个人（记得按来的时间排序），枚举刊物，欧克，直接开始写代码。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MaxN=1010;
long long T,n;
struct Node{
	long long arr,k,son; 
	long long s[10],t[10];
	long long flag[10];
};
Node arr[MaxN];

bool Comp(Node x,Node y){
	if(x.son==y.son) return x.arr<y.arr;
	else return x.son<y.son;
}

long long ans,ton[MaxN];
int main(){
	scanf("%lld%lld",&T,&n);
	for(long long i=1;i<=n;i++){
		scanf("%lld%lld",&arr[i].arr,&arr[i].k);
		arr[i].arr++;
		for(long long j=1;j<=arr[i].k;j++){
			scanf("%lld%lld",&arr[i].s[j],&arr[i].t[j]);
		}
		arr[i].son=arr[i].arr;
	}
	for(long long t=0;t<=T;t++){//枚举 t
		stable_sort(arr+1,arr+n+1,Comp);
		for(long long i=1;i<=n;i++){//枚举 n
			if(arr[i].son>t || arr[i].arr>t) continue; 
			for(long long k=1;k<=arr[i].k;k++){//枚举 k
				if(ton[arr[i].s[k]]<=t && !arr[i].flag[k]){
					arr[i].flag[k]=1;
					arr[i].son=ton[arr[i].s[k]]=t+arr[i].t[k];
					ans++;
					break;
				}
			}
		}
	}
	printf("%lld\n",ans); 
	return 0;
}
```

---

## 作者：wwxxbb (赞：1)

又是一道大膜你。

## 思路

题目中的很多输入信息都与读者有关，所以我们可以建一个结构体存储读者的有关信息，需要存储的信息有：

1. 到达时间。
2. 看书数目。
3. 每本书的编号和看完所需时间。
4. 每本书是否读过。
5. 出现的时间。

前 $3$ 点都是题目给出的，第 $4$ 点也很好理解，为什么需要记录出现的时间呢？

我们可以这样想，每个读者拿到书后都消失了，书随人一起消失，直到人把书看完才重新出现，这样就可以很好地记录时间变化了。同时，我们还要维护每本书出现的时间，维护方式与人相同。再加上足够的耐心，这题就写出来了。

时间复杂度可以说是很小的。

下面就来看一下代码，理一下思路吧。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 105, K = 10, S = 1005;

int t, n;
struct Reader {
    int arr, num;  // 到达时间，读书数量
    int id[K], time[K]; // 每本书的编号和读的时间
    bitset<K> read; // 每本书是否读过
    int now; // 出现的时间
} a[N];
int b[S]; // 书本出现的时间

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    while (cin >> t >> n) {
        for (int i = 1; i <= n; i ++) {
            cin >> a[i].arr >> a[i].num;
            for (int j = 1; j <= a[i].num; j ++)
                cin >> a[i].id[j] >> a[i].time[j];
            a[i].now = a[i].arr; // 每个人首次出现的时间是第一次来的时间
        }
        int ans = 0;
        for (int i = 0; i < t; i ++) { // 图书馆开门时间为 0 ~ t
            for (int j = 1; j <= n; j ++) {
                if (a[j].now > i) continue; // 放弃
                bool find = 0;
                for (int k = 1; k <= a[j].num; k ++)
                    if (!a[j].read[k] && b[a[j].id[k]] <= i) { // 没被读过且在时间内
                        find = a[j].read[k] = 1; // 直接拿下
                        a[j].now = b[a[j].id[k]] = i + a[j].time[k]; // 修改人和书的时间
                        ans ++; // 答案加 1
                        break;
                    }
                if (!find) { // 如果没有找到自己想要的，就找最早能出现的书满足自己
                    int mn = 2e9, s = 0;
                    for (int k = 1; k <= a[j].num; k ++)
                        if (!a[j].read[k] && mn > b[a[j].id[k]])
                            mn = b[a[j].id[k]], s = k; // 找
                    if (mn < t) { // 找到了且在图书馆开门时间里
                        a[j].read[s] = 1; // 直接预定
                        a[j].now = b[a[j].id[s]] += a[j].time[s]; // 这里的修改时间可以说和上面的一毛一样
                        ans ++; // 答案加 1
                    }
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：zhoumurui (赞：1)

# 题面展示

> 快看，题面没说清楚的多数都在这里

有一个阅览室，在 $0$ 时间开门，在 $T$ 时间关门。

有 $n$ 位读者，每个读者会在不同的时间进入阅览室，输入时读者信息按照读者的到达时间先后给出。第 $i$ 位读者想看 $k_i$ 篇刊物，心里对自己想看的刊物都有一个排位，优先看排位靠前的刊物，看过一遍就不看了。同一份刊物被不同读者阅读所需的时间是不同的。读者读完一本刊物时，就不再想看这本刊物。

当读者想读的所有刊物都正在被其他人阅读时，他会开始等待直到有一本他想看的刊物被读完了。

当读者没有想读的刊物或想读的刊物都读完后，他就不再读了。

读者刚来时和刚读完一本刊物时，都会到服务台做一次登记。这样当两人想抢同一本刊物时，那么先登记的读者将得到这本刊物，如果两个人同时登记，那么先到达阅览室的读者将得到刊物。由于每位读者到达阅览室的时间不同，所以遵守这样的规定是可以避免争抢的。

$T$ 时间不能再阅读。如果有读者刚读完一本刊物，也不能再拿别的刊物了。

求所有刊物被翻开的次数总和。

# 题目思路

写模拟，思路一定要清晰！

像这样的题，可以一秒一秒的跑，处理每一秒发生的事件，**逐秒处理**。

- 需要存储什么信息？

需要存储读者进入阅览室的时间，想要读的书，读书需要的时间，登记的时间，正在读的书，开始读书的时间，一本书是否在被阅读。

- 需要实现什么函数？

因为经常用到，我们首先封装一个 find() 函数，实现读者找书的过程，**看注释**。

```cpp
void find(int per,int tim){//读入的两个信息分别为找书的人和此时的时间
  int p=love[per].size();
  for (int i=0;i<p;i++){//枚举读者要读的刊物
    if (!br[love[per][i].love]){//没被占
      br[love[per][i].love]=per;//拿下
      reading[per]=love[per][i];//开始读
      be_re[per]=tim;//将开始读书的时间设为当前时间
      love[per].erase(love[per].begin()+i);//以后不看这本书了
      cnt++;//答案+1
      
      return;
    }
  }
}
```

- 逐秒处理如何进行？

为了处理争抢事件，存储了每个读者的登记时间，和读者的编号一起塞进一个结构体，抢书之前排序，一个一个借书就可以解决争端。

每秒按如下顺序处理信息：

1. 看完的读者归还刊物（虽然归还刊物不会有争抢，但是由于要存储登记时间，所以按结构体顺序处理）。
2. 新的读者进入阅览室（采用二分方式处理）。
3. 给结构体排序，登记时间作为第一优先级从小到大排序，编号作为第二优先级从小到大排序即可。
4. 按结构体顺序借阅刊物。

这样这题就解决了，还不懂的看代码：

# 核心代码展示

```cpp
struct book{
    int love,re_ti;
};
struct renn{
    int den,id;
}ren[105];
bool cmp(renn a,renn b){
  if (a.den==b.den)return a.id<b.id;
  return a.den<b.den;

signed main(){
  int T,n;
  cin>>T>>n;
  for (int i=1;i<=n;i++){
    cin>>t[i]>>k[i];
    for (int j=1;j<=k[i];j++){
      int x,y;
      cin>>x>>y;
      book p;
      p.love=x,p.re_ti=y;
      love[i].push_back(p);
    }
  reading[i].love=-1;
    ren[i].den=t[i];
    ren[i].id=i;
  }
  for (int i=0;i<T;i++){
    //1. 看完的读者归还刊物
    for (int j=1;j<=n;j++){
      if (!in[ren[j].id])continue;
      if (reading[ren[j].id].love!=-1&&reading[ren[j].id].re_ti+be_re[ren[j].id]<=i){
        br[reading[ren[j].id].love]=0;
        reading[ren[j].id].love=-1;
        reading[ren[j].id].re_ti=0;
        be_re[ren[j].id]=0;
        ren[j].den=i;
      }
    }
    //2. 新的读者进入阅览室
    int id=lower_bound(t+1,t+1+n,i)-t;
    if (t[id]==i){
      in[id]=1;
    }
    //3.给结构体排序
    sort(ren+1,ren+1+n,cmp);
    //4. 按结构体顺序借阅刊物
    for (int j=1;j<=n;j++){
      if (in[ren[j].id]&&reading[ren[j].id].love==-1){
        find(ren[j].id,i);
      }
    }
  }
  cout<<cnt<<endl;
  return 0;
}
```

---

## 作者：liuenyin (赞：1)

## 思路

纯模拟题，每过一秒，会按顺序发生以下事情：

1. 看书的人剩下要看的时间减少1。
  
2. 如果有人看完这本书，还书。
  
3. 一些新的人进入阅览室。
  
4. 所有不在看书的人寻找图书。
  
5. 看不到自己想看的书的人进行登记。
  

注意到数据范围较小，于是考虑直接枚举时间，每秒模拟以上的事情。

为方便记录，开一个结构体，记录每个人要看的书，到的时间，是否看过每一本书，按等待时间作为第一关键字，到达时间作为第二关键字进行排序，只需要按顺序进行模拟即可。时间复杂度 $O(Tn\log n)$ 。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2000+5;
int T,n,sum;
int bk[N];//第i本书被看剩下的时间
struct node{
    int id[8],time[8],vis[8],res;//res 现在读书剩下的时间
    int t,k,wait;
    node(){wait=0;}
    bool operator<(const node &A)const{
        if(this->wait!=A.wait)return this->wait>A.wait; 
        return this->t<A.t;
    }
}a[N];
node tmp[N];
int main(){
    cin>>T>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].t>>a[i].k;
        for(int j=1;j<=a[i].k;j++){
            cin>>a[i].id[j]>>a[i].time[j];
        }
    }
    for(int i=0;i<T;i++){
        sort(a+1,a+1+n);
        for(int j=0;j<=2000;j++){
            if(bk[j])bk[j]--;
        }
        for(int j=1;j<=n;j++){
            node tp=a[j];
            if(tp.t>i){
                a[j]=tp;
                continue;
            }
            if(tp.res){
                tp.res--;
                a[j]=tp;
                continue;
            }
            int flag=0;
            for(int k=1;k<=tp.k;k++){
                if(!bk[tp.id[k]]&&!tp.vis[k]){
                    bk[tp.id[k]]=tp.time[k];
                    tp.wait=0;
                    sum++;
                    flag=1;
                    tp.vis[k]=1;
                    tp.res=tp.time[k]-1;
                    break;
                }
            }
            if(!flag){
                if(tp.wait<=0)tp.wait=1;
                else tp.wait++;
            }
            a[j]=tp;
        }
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：Aix_Eric (赞：0)

## Solution:


~~大模拟~~

按题意打包一个结构体并输入。

---

### 思路：

- 枚举时间 $T$ 。
- 标记书本。
- 对书进行分配。

设 $last_i$ 为第 $i$ 个人读完上一本书的时刻。
则把人按照 $last_i$ 的值为第一关键字，到达时间的值为第二关键字进行升序排列。

```cpp
bool cmp(Reader a, Reader b){
    if(a.last == b.last) return a.t < b.t;
    return a.last < b.last;
}
```

排序后就不会产生冲突，直接枚举每个人分配书。


如果第 $i$ 个人没有书，那么这个人可以看书。


然后更新 $last_i$ 和被看的书。



---


#### 代码实现：

```cpp
struct Reader{
    int t, k, last;
    int book[8], tm[8], flag[8];
}r[N];
bool cmp(Reader a, Reader b){
    if(a.last == b.last) return a.t < b.t;
    return a.last < b.last;
}
int ans, b[N];
int main(){
    int T, n; scanf("%d%d", &T, &n);
    for(int i = 1;i <= n;i++){
        scanf("%d%d", &r[i].t, &r[i].k); r[i].t++;
        for(int j = 1;j <= r[i].k;j++)
            scanf("%d%d", &r[i].book[j], &r[i].tm[j]);
        r[i].last = r[i].t;
    }
    for(int t = 1;t <= T;t++){
        sort(r+1, r+1+n, cmp);
        for(int i = 1;i <= n;i++){
            if(r[i].last > t || r[i].t > t) continue;
            for(int j = 1;j <= r[i].k;j++){
                if(b[r[i].book[j]] <= t && (!r[i].flag[j])){
                    ans++; r[i].flag[j] = 1;
                    r[i].last = b[r[i].book[j]] = t + r[i].tm[j];
                    break;
                }
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---


# 回文串计数

## 题目描述

小 $a$ 虽然是一名理科生，但他常常称自己是一名真正的文科生。不知为何，他对于背诵总有一种莫名其妙的热爱，这也促使他走向了以记忆量大而闻名的生物竞赛。然而，他很快发现这并不能满足他热爱背诵的心，但是作为一名强大的 OIER，他找到了这么一个方法——背诵基因序列。然而这实在是太困难了，小 $a$ 感觉有些招架不住。

不过他发现，如果他能事先知道这个序列里有多少对互不相交的回文串，他或许可以找到记忆的妙法。为了进一步验证这个想法，小 $a$ 决定选取一个由小写字母构成的字符串 $SS$ 来实验。由于互不相关的回文串实在过多，他很快就数晕了。不过他相信，在你的面前这个问题不过是小菜一碟。

1. 对于字符串 $SS$，设其长度为 Len，那么下文用 $S_i$ 表示 $SS$ 中第 $i$ 个字符（$1 \le i \le Le_n$）。

2. $S[i,j]$ 表示 $SS$ 的一个子串，$S[i,j]=S_i S_{i+1}S_{i+2} \cdots S_{j-2}S_{j-1}S_{j}$，比如当 $SS$ 为 `abcgfd` 时，$S[2,5]$ 就是 `bcgf`，$S[1,5]$ 是 `abcgf`。

3. 当一个串被称为一个回文串当且仅当将这个串反写后与原串相同，如`abcba`。

4. 考虑一个四元组 $(l,r,L,R)$，当 $S[l,r]$ 和 $S[L,R]$ 均为回文串时，且满足 $1 \le l \le r<L \le R \le \text{Len}$ 时，我们称 $S[l,r]$ 和 $S[L,R]$ 为一对互不相交的回文串。即本题所求，也即为这种四元组的个数。两个四元组相同当且仅当对应的 $l,r,L,R$ 都相同。

## 说明/提示

【样例数据说明】

SS="aaa"，SS 的任意一个字符串均为回文串，其中总计有 5 对互不相关的回文串：

(1,1,2,2)，(1,1,2,3)，(1,1,3,3)，(1,2,3,3)，(2,2,3,3)。

## 样例 #1

### 输入

```
aaa```

### 输出

```
5```

# 题解

## 作者：John_yangliwu (赞：9)

# 思路
## Step 1
首先求出所有回文子串。

注意到 $|SS|\le2000$，我们可以用 $O(n^2)$ 的 **DP** 求解。

定义 `bool` 类型数组 $dp$，$dp[i][j]$ 表示 $SS[i\sim j]$ 是否为回文子串。

### 状态转移方程：

$dp[i][j]=\begin{cases}true\ \ \ \ \ \ \ (dp[i+1][j-1]=true,\ SS[i]=SS[j])\\false \ \ \ \ \ (other\ cases)\end{cases}$

### 理解：
一段子串为回文，当且仅当其首尾相同，且抹去首尾剩下部分也是回文。

## Step 2
其次，求出互不相干的回文子串数量。只要对每个回文子串，求出首位在其末位后的回文子串数量，再求和就可以了。

所以我们开一个桶 $cnt$，首先让 $cnt[i]$ 表示首位为 $i$ 的回文子串数量，其次，对其求后缀和。此时 $cnt[i]$ 表示末尾在 $i$ 之后的回文子串数量。最后统计 $\sum\limits^{size}_{i=1}cnt[palin[i].second+1]$ 即可。其中 $size$ 为回文子串数量，$palin$ 是 `pair<int, int>` 类型数组，$first$ 和 $second$ 分别代表回文子串的首位与末位。

# Tips
要开 `long long`。

# 代码
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#define ll long long
using namespace std;

const int N = 2005;
bool dp[N][N];
ll cnt[N];
vector<pair<int, int> > palin;

int main() {
    string str; cin >> str;
    memset(dp, true, sizeof(dp));
	
    //枚举回文子串长度
    for(int len = 1; len <= str.length(); len++) {
        //枚举左端点
        for(int l = 0; l + len - 1 < str.length(); l++) {
            int r = l + len - 1;//右端点
            //不符合要求
            if(!dp[l + 1][r - 1] || str[l] != str[r]) {
                dp[l][r] = false; continue;
            }
            //发现回文子串
            palin.push_back({l, r}); 
            //更新以 l 为首位的回文子串数量
            cnt[l]++;
        }
    }

    ll res = 0;
    //求后缀和
    for(int i = str.length() - 1; i >= 0; i--)
        cnt[i] += cnt[i + 1];

    //最终统计，求与 palin[i] 不相干的回文子串数量
    for(int i = 0; i < palin.size(); i++)
        res += cnt[palin[i].second + 1];
    cout << res << endl;
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/48049942)

---
$\large\text{THE\ \ END}$


---

## 作者：crystal302 (赞：4)

解题思路：

第一步：求所有回文

此步一般同学会用n3的时间复杂度去计算

f[i,j]来存储，用状态0和1分别表示i至j不是回文、是回文

以点(分奇偶个进行)为中心的最大扩展化求回文（时间n2)

第二步：统计四元组的个数

枚举分割线法求（枚举第一个回文，枚举后面的回文）


程序结束：

var i,j,x,y,k,w,t:longint;sum:int64;   //最后结果会很大，要用int64





```cpp
    st:ansistring;flag:boolean;
    f:array[1..3000,1..3000] of boolean;
    e,d:array[0..10000] of longint;
function min(x,y:longint):longint;
begin
if x<y then exit(x)
else exit(y);
end;
begin
//assign(input,'calc.in');reset(input);
//assign(output,'calc.out');rewrite(output);
  readln(st);
  for i:=1 to length(st) do
  begin
    t:=i;
    w:=i;
    flag:=true;
    for j:=1 to min(i,length(st)-i+1) do
    begin
      if st[t]=st[w] then
        f[t,w]:=flag
      else
        flag:=false;
      dec(t);inc(w);
    end;
  end;
  for i:=1 to length(st)-1 do
  begin
    k:=i+1;
    t:=i;
    w:=k;
    flag:=true;
    if st[i]<>st[k] then continue
    else
    begin
      for j:=1 to min(i,length(st)-k+1) do
      begin
        if st[t]=st[w] then
          f[t,w]:=flag
        else
          flag:=false;
        dec(t);inc(w);
      end;
    end;
  end;  //以上为求所有回文
for i:=1 to length(st) do
  for j:=1 to length(st) do
    if f[i,j] then e[j]:=e[j]+1;  //e[i]表示以第i个字符为结尾的回文数
for i:=length(st) downto 1 do
  begin
  for j:=i+1 to length(st) do
    if f[i+1,j] then d[i]:=d[i]+1;
  for j:=i+2 to length(st) do
    if f[j,i+1] then d[i]:=d[i]+1;//d[i]表示不包含前i个字符后回文的数量
  d[i]:=d[i+1]+d[i];
  end;
for i:=1 to length(st) do sum:=sum+e[i]*d[i]; //以i为结尾的符合条件的回文
writeln(sum);
close(input);close(output);
end.

```

---

## 作者：LinkCatTree (赞：3)

本蒟蒻过了这道题，顿有所悟，故作此篇。

这题数据范围较小，观察所有数据 $|SS| \leq 2,000$，显然可以先用 DP 求出所有的回文串。

> 状态：$dp_{i,j}$ 表示从 $S_i$ 到 $S_j$ 是否为回文串。
>
> 初值：全部为 $true$。
>
> 转移：$dp_{i,j}=\begin{cases}true&dp_{i+1,j-1}=true\text{ and }S_i=S_j\\false&dp_{i+1,j-1}=false\text{ or }S_i\neq S_j\end{cases}$
>
> 目标：？（见下文）

这样做的时间复杂度为 $\mathcal{O}(n^2)$，在当前数据范围下是可行的。

得出所有的回文串后，我们思考如何判别两个回文串是否“互不相关”。明显的，只有一个不同回文串的**左下标在当前回文串右下标的右侧**，才可以和当前回文串组成互不相关的回文串。

对于统计有多少个左下标大于某个回文串右下标，可以是有一个空间为字符串长度的数组来存储 $SS$ 中每个位置上有多少个回文串的左下标（即 $sum_i$ 表示左下标为 $i$ 的回文串个数），用**后缀数组**表示出来，便可统计左下标大于等于某个值的所有回文串个数。

思路很明了了，需要注意的是两点：

* 回文串可能**很多**

* 答案也**很多**

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MS=2005;
char S[MS];
bool dp[MS][MS];
int r[MS*MS],cnt;// 没开大，喜提 50 
long long sum[MS];

int main() {
	scanf("%s",S+1);
	int len=strlen(S+1);
	memset(dp,true,sizeof(dp));// 手动赋值为 true 容易出错（别问我怎么知道的）
	for(int i=1;i<=len;i++)
		for(int j=1;j<=len-i+1;j++) {
			int k=j+i-1;
			if(S[j]!=S[k]||!dp[j+1][k-1]) dp[j][k]=false;
			else r[++cnt]=k,sum[j]++;
		}
	long long ans=0;
	for(int i=len;i>0;i--) sum[i]+=sum[i+1];
	for(int i=1;i<=cnt;i++) ans+=sum[r[i]+1];
	printf("%lld\n",ans);
	return 0;
}
```

求 dalao 轻喷。

---

## 作者：yybyyb (赞：3)

心血来潮，写个题解

只需要预处理出以每个位置为开头/结束的回文子串的个数

就可以很方便的计算答案

此时只需要对开头求前缀和之后对应乘一下就行了

至于如何预处理，直接使用回文树就行了

时间复杂度$O(n)$

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define ll long long
#define RG register
#define MAX 50000
inline int read()
{
    RG int x=0,t=1;RG char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
char s[MAX];
int p1[MAX],p2[MAX];
struct PT
{
	struct Node
	{
		int son[26];
		int ff,len;
	}t[MAX];
	int tot,last,dep[MAX];
	void init()
	{
		t[tot=1].len=-1;
		t[0].ff=t[1].ff=1;
	}
	void extend(int c,int n,char *s)
	{
		int p=last;
		while(s[n-t[p].len-1]!=s[n])p=t[p].ff;
		if(!t[p].son[c])
		{
			int v=++tot,k=t[p].ff;
			while(s[n-t[k].len-1]!=s[n])k=t[k].ff;
			t[v].ff=t[k].son[c];
			t[v].len=t[p].len+2;
			t[p].son[c]=v;
			dep[v]=dep[t[v].ff]+1;
		}
		last=t[p].son[c];
	}
}pt1,pt2;
ll ans;
int main()
{
	pt1.init();pt2.init();
	scanf("%s",s+1);
	int len=strlen(s+1);
	for(int i=1;i<=len;++i)pt1.extend(s[i]-97,i,s),p1[i]=pt1.dep[pt1.last];
	reverse(&s[1],&s[len+1]);
	for(int i=1;i<=len;++i)pt2.extend(s[i]-97,i,s),p2[len-i+1]=pt2.dep[pt2.last];
	for(int i=1;i<=len;++i)p1[i]+=p1[i-1];
	for(int i=1;i<=len;++i)ans+=p1[i]*p2[i+1];
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：滑稽的小宫 (赞：1)

### 哈希+暴力

题意简述：统计一个字符串中任意两个不相交回文串所构成的对的数量

由于是个字符串题，而且涉及到回文子串的判定（也就是判断两个字符串是否相等），因此想到可以使用哈希

关于字符串哈希，具体可以看一下我的[这篇blog](https://www.luogu.com.cn/blog/xiaogong/post-0x14-ha-xi-hash)

对于这道题来说，我们只要一正一反处理一遍字符串，得到前缀哈希和后缀哈希，就可以 $O(1)$ 计算每个子串正着读和反着读的哈希值了，然后比较一下，如果相等，就可以认为这个子串是回文的了

然后考虑一下倒着枚举第一个串的左端点 $l$（顺序也行），右端点 $r$ 可以枚举，枚举到某一个位置的时候，如果 $l$ 到 $r$ 是回文串，那么考虑一下它可以跟后面的多少个串成对

就相当于我可以用一个数组cnt记录一下**有多少个回文串的 $l$ 端点在这个位置**，然后对于上面提到的那个回文串，它可以和 $r$ 后面的所有串成对，因此答案要加上 $r+1$ 到 $n$ 的所有cnt的和，这个和可以用后缀和实现，相当于顺便把cnt求后缀和为sum数组

最后对于 $l$ 位置的每一个回文串右端点 $r$ 都可以把 $l$ 位置的cnt++

$Talk\ is\ cheap,\ show\ you\ the\ code:$

```c++
#include<iostream>
#include<cstdio>
#define ull unsigned long long
#define N 2010
int n;
ull null;
const ull p=9981;
char s[N];
ull fhs[N],ans,bhs[N],mul[N],sum[N];//fhs存储前缀哈希，bhs存储后缀哈希
ull fhash(int l,int r){//字符串哈希
	return fhs[r]-fhs[l-1]*mul[r-l+1];
}ull bhash(int l,int r){//字符串哈希
	return bhs[l]-bhs[r+1]*mul[r-l+1];
}
int main(){
	scanf("%s",s+1);
	mul[0]=1;//mul存储p的幂，避免快速幂
	for(n=1;s[n]!='\0';n++){
		mul[n]=mul[n-1]*p;//mul存储p的幂，避免快速幂
		fhs[n]=fhs[n-1]*p+s[n]-'0';//字符串哈希
	}
	bhs[n--]=0;
	for(int i=n;i>=1;i--){//倒叙枚举左端点l
		bhs[i]=bhs[i+1]*p+s[i]-'0';//后缀字符串哈希
		for(int j=i;j<=n;j++){//枚举右端点r
			if(fhash(i,j)==bhash(i,j)){//如果相等说明是回文串
				sum[i]++;//左端点位置的cnt++
				ans+=sum[j+1];//答案加上r+1到n的cnt和，表示这后面的回文串都可以和当前l到r回文串成对
			}
		}sum[i]+=sum[i+1];//更新当前的后缀和
	}printf("%lld",ans);
	return 0;
}
```



---

## 作者：Trafford1894 (赞：1)


这题的数据范围保证 $|SS|$ 小于 $2000$，我们可以用 $\Theta(n^2)$ 的 ```dp``` 做。

假设有一个 ```bool``` 类型的数组 ${dp[i][m]}$，表示 $S[i,m]$ 是否是一个回文子串。（具体见题面）

先放出状态转移方程和边界条件：

$dp[i][m] = false \space (i > m)$

$dp[i][m] = true \space (i = m)$

$dp[i][m] = false \space (SS[i] \ne SS[m])$

$dp[i][m] = dp[i + 1][m - 1]\space (else)$ 

下面具体解释这个状态转移方程所代表的意义。

如果子串 $S[i,m]$ 中 $i > m$，则这个子串根本不存在，对应第一种情况，也就是假。

如果子串 $S[i,m]$ 中 $i = m$，这个子串只有一个字符，肯定是回文串，所以为真。

如果子串 $S[i,m]$ 中 $SS[i] \ne SS[m]$，则这个子串的首尾不同，肯定不是回文串。

其他情况，$dp[i][m] = dp[i + 1][m - 1]$，也就是将头尾去掉，看剩下的是不是回文串。




---

## 作者：皮卡丘最萌 (赞：1)

这题在学校练过，我还是一遍过的，于是来写题解。


显然直接枚举然后暴力是会超时的。

所以我们可以把枚举头和尾的指针改成枚举中心点的指针，这里要分2种情况。

1.中心点只有1个，此时左边界L=右边界R，然后不断让L向左，R向右，直到L,R构成的字符串不是回文时终止。

2.中心点有2个，此时左边界L=右边界R-1，然后不断让L向左，R向右，直到L,R构成的字符串不是回文时终止。

这样的操作时间复杂度为O（n^2）

一般在预处理操作结束后，很多人都会想到保存前后节点，然后一一对比，寻找答案。

但我们来看一下数据，当长度为2000，所有字符都为a时，回文串会有4000000个，再进行一一对比，还是会超时。

考虑一个四元组(l,r,L,R)，当S[l,r]和S[L,R]均为回文串时，且满1<=l<=r<=L<=R<=Len时，我们称S[l,r]和S[L,R]为一对互不相交的回文串。即本题所求，也即为这种四元组的个数。两个四元组相同当且仅当对应的l,r,L,R都相同。   //**此段是题目**

所以我们可以只考虑一个子串的尾和另一个子串的头是否交叉。

这样我们就可以把头和尾分别运用计数。

接下来我们可以枚举第一个串的尾和第二个串的头，再累加，这样的时间复杂度也是O（n^2）

特别注意：
1.当中心点有2个时，左边界L=右边界R-1，但是左端点不能为最后一个，否则会越界。

2.最后枚举，累加时累加器要用int64，不然可能会错。

3.读入时用ansistring。

AC程序：
```pascal
var  s:ansistring; i,j:longint; l,r,len,sum:int64;
f,f1:array[0..100001] of longint;
begin
readln(s); len:=length(s);
for i:=1 to len do
  begin
  l:=i; r:=i; inc(f[l]); inc(f1[r]);
  while (l>1)and(r<len)and(s[l-1]=s[r+1]) do
    begin
    dec(l); inc(r); inc(f[l]); inc(f1[r]);
    end;
  end;
for i:=1 to len-1 do
  begin
  l:=i; r:=i+1;
  if s[l]=s[r] then
    begin
    inc(f[l]); inc(f1[r]);
    while (l>1)and(r<len)and(s[l-1]=s[r+1]) do
      begin
      dec(l); inc(r); inc(f[l]); inc(f1[r]);
      end;
    end;
  end;
for i:=1 to len do
  for j:=i+1 to len do
    inc(sum,f[j]*f1[i]);
writeln(sum);
end.
```


---

## 作者：KesdiaelKen (赞：1)

这题难度可真的没有上字体吧……明明长度可以到$10^6$（SA维护左右端点回文串个数，乘法结合律求$ans$），结果却只有$2000$，$n^2$暴力即可过。

大概做法就是想着求出以某个点为左端点的回文串个数$left[i]$与以某个点为右端点的回文串个数$right[i]$，然后枚举$r$和$L$，求$\sum right[i]\times left[j],i<j$即可。

至于$left$和$right$怎么算，可以枚举中心点，算出每个中心点最多往外延伸多长，然后暴力将每一个可以作为左右端点的位置加$1$就可以了。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<map>
using namespace std;
char s[3000];int n;
int cd[3000]={0};
long long zuo[3000],you[3000],sum[3000],ans=0;
int main()
{
	scanf("%s",s);n=strlen(s);
	for(int i=0;i<n;i++)
		for(;i-cd[i]>=0&&i+cd[i]<n&&s[i-cd[i]]==s[i+cd[i]];cd[i]++);
	for(int i=0;i<n;i++)
		for(int j=1;j<=cd[i];j++)
			zuo[i-j+1]++,you[i+j-1]++;
	for(int i=0;i<=n-2;i++)
	{
		cd[i]=0;
		for(;i-cd[i]>=0&&i+1+cd[i]<n&&s[i-cd[i]]==s[i+1+cd[i]];cd[i]++);
	}
	for(int i=0;i<=n-2;i++)
		for(int j=1;j<=cd[i];j++)
			zuo[i-j+1]++,you[i+j]++;
	for(int i=0;i<n;i++)for(int j=i+1;j<n;j++)ans+=you[i]*zuo[j];
	printf("%lld\n",ans);
	return 0;
 } 
```

---

## 作者：cosmicAC (赞：1)

好久没写manacher了，拿这题练练手。话说为什么数据规模只有2K，2M才是正常的紫题难度啊。除了求回文半径之外和回文树做法一样。

细节不多，主要是要注意从“当前回文中心的回文半径”推出差分的左端点和右端点（这里调了好久），强烈建议先想清楚再写。

还有不能两个数组（左侧和右侧）都做两遍前缀和，其中有一个只能做一遍。否则会重复统计。比如“aca”，四元组（1,1,3,3）会在【12之间】和【23之间】被两次统计到。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int64 long long
#define maxn 100010
using namespace std;
char s[maxn];
int64 l[maxn],r[maxn];
int n,p[maxn];
void manacher(char *s,int n){
	for(int i=1,mx=0,c=0;i<=n;i++){
		p[i]=i<mx?min(p[2*c-i],mx-i):1;
		while(s[i+p[i]]==s[i-p[i]])++p[i];
		l[i+1>>1]++,l[i+p[i]>>1]--;
		r[(i-p[i])/2+1]++,r[i/2+1]--;
		if(i+p[i]>mx)mx=i+p[i],c=i;
	}
}
int main(){
	scanf("%s",s);
	n=strlen(s);
	for(int i=n-1;~i;i--)
		s[i*2+2]=s[i],s[i*2+1]='.';
	s[0]='?';s[2*n+1]='.';
	manacher(s,2*n+1);
	for(int i=1;i<=n;i++)
		r[i]+=r[i-1],l[i]+=l[i-1];
	l[0]=0;
	for(int i=1;i<=n;i++)
		l[i]+=l[i-1];
	int64 ans=0;
	for(int i=n;i>1;i--)ans+=l[i-1]*r[i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：唐一文 (赞：1)

这题是[这道题](https://www.luogu.com.cn/problem/CF17E)的弱化版

## Description

[传送门](https://www.luogu.com.cn/problem/P1872)

## Solution

~~看到字符串就想到哈希~~

设以下标 $i$ 开头的回文子串个数为 $L_i$，以下标 $i$ 结尾的回文子串个数为 $R_i$

对于每个 $i$，与以 $i$ 结尾的回文子串不相交的且在 $i$ 右边的回文子串的个数为 $\sum_{j=i+1}^nL_j$

那么所有不相交的回文子串的数量为 $\sum_{i=1}^nR_i\sum_{j=i+1}^nL_j$

接下来考虑怎么求 $L$ 和 $R$

发现一个长度大于 $1$ 的回文串，把它两边的字母去掉，仍是一个回文串

所以我们可以对每个位置进行二分，寻找以 $i$ 为中心的最长回文串的长度，记为 $len_{i,0}$ 和 $len_{i,1}$，分长度为奇数和长度为偶数的情况

可以用哈希优化成 $\mathcal O(n\log{n})$

对于 $len_{i,0}$，可以将区间 $\left[i-\left\lfloor\dfrac{len_{i,0}}{2}\right\rfloor,i\right]$ 的 $L$ 和区间 $\left[i,i+\left\lfloor\dfrac{len_{i,0}}{2}\right\rfloor\right]$ 的 $R$ 都 $+1$

$len_{i,1}$ 同理

可以用树状数组或线段树维护

那么这题就做完了，时间复杂度 $\mathcal O(n\log{n})$

## Code

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
#define ll long long
using namespace std;
#define MAXN 2005
#define lowbit(x) ((x)&(~(x)+1))
#define GetFro(l,r)fro[(r)]-fro[(l)-1]*mul[(r)-(l)+1]//求s[l,r]的哈希值
#define GetBac(l,r)bac[(l)]-bac[(r)+1]*mul[(r)-(l)+1]//求s[r,l]的哈希值
ll ans;
char s[MAXN];
int n,mul[MAXN]={1},fro[MAXN],bac[MAXN];
struct SMT{//维护L
  ll sum[MAXN][2];
  il void Add(int x,int k,int id){for(;x<=n;sum[x][id]+=k,x+=lowbit(x));}
  il ll Qry(int x,int id){int ans=0;for(;x;ans+=sum[x][id],x-=lowbit(x));return ans;}
}L;
struct BIT{维护R
  ll sum[MAXN];
  il void Add(int x,int k){for(;x<=n;sum[x]+=k,x+=lowbit(x));}
  il ll Qry(int x){ll ans=0;for(;x;ans+=sum[x],x-=lowbit(x));return ans;}
}R;
int main(){
  scanf("%s",s+1),n=strlen(s+1);
  for(re int i=1;i<=n;++i)mul[i]=mul[i-1]*131;
  for(re int i=n;i;--i)bac[i]=bac[i+1]*131+s[i];//倒过来哈希一遍
  for(re int i=1;i<=n;++i)fro[i]=fro[i-1]*131+s[i];//正着哈希一遍
  for(re int i=1,l,r,mid;i<=n;++i){
    for(l=0,r=min(i-1,n-i+1)+1;l+1<r;mid=l+r>>1,GetFro(i-mid,i-1)==GetBac(i,i+mid-1)?l=mid:r=mid);//二分长度为偶数的回文串（这里枚举的是往左右拓展的长度）
    if(l)L.Add(i-l,1,0),L.Add(i,-1,0),L.Add(i-l,i-l-1,1),L.Add(i,1-i,1),R.Add(i,1),R.Add(i+l,-1);//注意要判断是否有长度为偶数的回文串
    for(l=0,r=min(i-1,n-i+1)+1;l+1<r;mid=l+r>>1,GetFro(i-mid,i-1)==GetBac(i+1,i+mid)?l=mid:r=mid);//二分长度为奇数的回文串
    L.Add(i-l,1,0),L.Add(i+1,-1,0),L.Add(i-l,i-l-1,1),L.Add(i+1,~i+1,1),R.Add(i,1),R.Add(i+l+1,-1);
  }
  for(re int i=1;i<n;++i)ans+=R.Qry(i)*(1ll*n*L.Qry(n,0)-1ll*i*L.Qry(i,0)-1ll*L.Qry(n,1)+1ll*L.Qry(i,1));
  printf("%lld",ans);
}
```

---

## 作者：BreakPlus (赞：0)

首先我们先考虑暴力求出每一个回文串，这个东西可以使用区间 $\text{DP}$ 。我们用 $\operatorname{check}_{i,j}$ 表示 $i \sim j$ 之间的字符是否构成一个回文字符串。得出转移方程式：

$\operatorname{check}_{i,j} =\operatorname{check}_{i+1,j-1} \& (str_i=str_j)$

注意，$\operatorname{check}_{i,i} = \operatorname{check}_{i,i-1} = \text{True}$ 。

然后我们暴力枚举一个回文串。对于每一个回文串区间 $\left[x,y\right]$ ，在区间 $[1,x-1]$ 与 $[y+1,n]$ 中的回文串都能与他配对。我们考虑推出每一个 $\operatorname{F}_{x,y}$，表示一个区间内的回文串数量（可重叠）。

这个不好搞啊？其实也可以用区间 $\text{DP}$。

不需要枚举中转点，我们可以直接推到 $[i+1,j]+[i,j-1]$ 的。然而 $[i+1,j-1]$ 的区间被重复算了，减掉。这是容斥原理的简单应用。注意：如果 $[i,j]$ 是个回文串还得加上 $1$ 。这个我们已经判断过了。

所以，对于每一个回文串都加上 $\operatorname{F}_{1,x-1} + \operatorname{F}_{y+1,n}$ ，最后答案除以 $2$ （设 $\text{A}$ 与 $\text{B}$ 是两个符合题意的回文串，那么统计答案时会被统计为 $\text{A}\&\text{B}$ 和 $\text{B}\&\text{A}$ ）。

下面给一下代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define Maxn 2010
char str[Maxn]; long long n,sum[Maxn][Maxn]; bool check[Maxn][Maxn];
long long answer;
int main(){
    scanf("%s",str+1);
    n=strlen(str+1);
    for(int i=1;i<=n;i++) check[i][i-1]=check[i][i]=true,sum[i][i]=1;
    for(int len=2;len<=n;len++)
        for(int i=1,j=len;j<=n;i++,j++){
            if(str[i]!=str[j]) check[i][j]=false;
            else check[i][j]=check[i+1][j-1];
        }
    for(int len=2;len<=n;len++)
        for(int i=1,j=len;j<=n;i++,j++){
            sum[i][j]=sum[i+1][j]+sum[i][j-1]-sum[i+1][j-1];
            if(str[i]==str[j]&&check[i+1][j-1]) sum[i][j]++;
        }
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
            if(check[i][j]) answer+=(sum[1][i-1]+sum[j+1][n]);
    printf("%lld\n",answer/2);
    return 0; 
}
```

---


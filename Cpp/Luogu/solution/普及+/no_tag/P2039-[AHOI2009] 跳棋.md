# [AHOI2009] 跳棋

## 题目描述

在一个 $1$ 行 $N$ 列（$N$ 是奇数）的棋盘上，有 $K$ 个格子是红色的。这种情况下，你有一个跳棋在最左端的格子上。你的目标是将它移动到最右边的格子，在开始移动之间，你可以在棋盘的任意空位上放棋子。在游戏开始后 你只可以随时在一个红色格子上放棋子。棋子的移动规则是：每次只可以选择一个棋子，跳过与之相邻的棋子走到后面的空格上，被它跳过的棋子被吃掉，即从棋盘上移走，如相邻棋子的另一侧有棋子，则不能跳。


请回答以下两个问题：

1. 移动开始前至少要放多少棋子才能完成任务。
2. 如果要使开始前放的棋子数要求尽量少，那么在移动过程中最少需要放多少个棋子才能完成任务。


关于规则的补充说明：

1. 只能往空位上放棋子，不管是移动开始前还是移动过程中。
2. 移动前棋盘最左端的那个原始棋子绝对不能被吃掉。

## 说明/提示

在游戏开始前，可以在第二个格子上放上一个棋子，游戏开始后可用最左边的棋子吃掉它，从而移动到第三格。然后由于第四格是个红色的格子，在游戏中可以在那放一个棋子，然后用已经移动第三格的棋子把它吃掉，从而达到终点。

$100\%$ 的数据中，$1\le N\le  1000$，输出中的数字不超过 $10^ {15}$。

$30\%$ 的数据中，$N\le 20$。


Source: [Ahoi2009] checker

## 样例 #1

### 输入

```
5
0 0 0 1 0

```

### 输出

```
1
1```

# 题解

## 作者：long_int (赞：14)

### 主要思想：动态规划

这一题可以分为两种情况讨论：没有红色块相连接和有连续两个红色块连接。首先要明确：不管是哪种情况，跳棋一定是走奇数的格子，因此最后的计数肯定要在偶数的格子上累加。
- 没有相连的红色块

先看一组样例：
```
5
0 0 0 1 0
```
不难发现，只需要在偶数上放跳棋，最终就能完成任务。由于题目要求游戏前尽可能放得少，而游戏开始后又只能放在红点上，所以所有的红点都给游戏开始后放。

**总结：对于这种情况，第一行输出下标为偶数的点中 0 的个数，第二行输出下标为偶数的店中 1 的个数。**

这一步的代码：
```c
bool flag = false;
scanf("%lld", &n);
for (LL i = 1; i <= n; i++) {
    scanf("%lld", &q[i]);
    if (i == 1) {
        q[i] = 0; //起点的红点没有用，故赋值为 0，作为白点处理
        continue;
    }
    if (i % 2 == 0)
        num[q[i]]++;
    if (q[i] && q[i - 1])
        flag = true;
}
printf("%lld\n%lld", num[0], num[1]);
```
- 有连续**至少**两块红色块连接

再看一组样例：
```
8
0 0 0 0 0 1 1 0
```
此时，我们在游戏开始之前不需要放任何棋子。

**具体步骤（推出状态转移方程的具体过程）：**
1. 首先在 6 和 7 的位置放棋。
1. 然后 7 位置的棋子跳到 5 ，此时 6 被吃掉。因此，在位置 5 的地方得到一个跳棋需要放两次棋，我们记作 ```dp[5] = 2```。
1. 这时我们在 6 放置一个棋子，使它吃掉 5 跳到 4，记作```dp[4] = 3```。
1. 此时若还想向左跳，只需要在 5 上放一个棋子。可是问题来了，5 不是红点，放不了啊！但是我们已经知道 ${dp}_5$ 的值是 $2$，所以 用 2 步使得 5 上面有一个棋子，再跳到 3 即可，记作```dp[3] = 5```。
1. 重复以上操作，直到 2 处有一个棋子，使得需要到达终点目标棋子跳到 3 的位置。在 4 处得到一个棋子，将目标棋子调到 5 ，一直到终点为止。

通过上述步骤，不难发现一个规律：

**想要在 $i$ 的位置得到一个棋子，必须在 $i+1$ 和 $i+2$ 处分别放一个棋子，此时需要耗费 ${dp}_{i+1} + {dp}_{i+2}$ 的代价。**

综上所述，状态转移方程可以很轻松地得到：

1. ${dp}_i = \min({dp}_i, {dp}_{i+1} + {dp}_{i+2})$
2. 同理，我们有：${dp}_i = \min({dp}_i, {dp}_{i-1} + {dp}_{i-2})$

此时代码就很容易写出来了：
```c
for (int i = 3; i <= n; i++)
if (q[i] && q[i - 1]) {
    for (int j = i - 2; j >= 1; j--)
        dp[j] = min(dp[j], dp[j + 1] + dp[j + 2]); //跳棋向左边跳
    for (int j = i + 1; j <= n; j++)
        dp[j] = min(dp[j], dp[j - 1] + dp[j - 2]); //跳棋向右边跳
}
```

完整的 AC Code：

```c
#include <stdio.h>
#include <stdlib.h>
#pragma warning(disable : 4996)
#define maxn 1005
#define INF 1e18 //这里的INF一定要开够大小，我之前一直开到1e9，只能得60分
#define LL long long
#define bool int
#define true 1
#define false 0 //由于C语言里没有 bool 型，需要自己宏定义
LL n, q[maxn], num[2];
LL dp[maxn];
LL min(LL a, LL b) { return a < b ? a : b; }
void print(bool flag) { //输出函数
    if (!flag) {
        printf("%lld\n%lld", num[0], num[1]);
        exit(0); //直接结束程序
    }
    LL ans = 0;
    for (int i = 1; i <= n; i++)
        ans += (i % 2) ? 0 : dp[i]; //只有偶数点才计入答案
    printf("%d\n%lld", 0, ans);
}
int main() {
    bool flag = false;
    scanf("%lld", &n);
    for (LL i = 1; i <= n; i++) {
        scanf("%lld", &q[i]);
        if (i == 1) {
            q[i] = 0; //起点的红点没有用，故赋值为 0，作为白点处理
            continue;
        }
        if (i % 2 == 0)
            num[q[i]]++;
        if (q[i] && q[i - 1])
            flag = true;
    }
    for (int i = 1; i <= n; i++)
        dp[i] = q[i] ? 1 : INF;
    for (int i = 3; i <= n; i++)
        if (q[i] && q[i - 1]) {
            for (int j = i - 2; j >= 1; j--)
                dp[j] = min(dp[j], dp[j + 1] + dp[j + 2]); //跳棋向左边跳
            for (int j = i + 1; j <= n; j++)
                dp[j] = min(dp[j], dp[j - 1] + dp[j - 2]); //跳棋向右边跳
        }
    print(flag);
    return 0;
}
```

目前也是最优解（话说第二优似乎是抄[这篇题解](https://www.luogu.com.cn/blog/Sooke/solution-p2039#)的）：

![](https://cdn.luogu.com.cn/upload/image_hosting/l35o88d2.png)

**最后提醒：这一题会卡 $long$ $long$，一定要注意！**

---

## 作者：Sooke (赞：9)

### 解题思路

逻辑非常乱的一题。

首先假设如果没有红色格子，为了使棋数最小化，一定是将棋子放在**偶数的位置**。

如果有了红色格子的存在，情况又会多一些。

考虑没有两个红色格子是相邻的，仍然是把棋子下到偶数位置上的，只不过白色格子是游戏前放的，红色格子是游戏中放的，这些可以直接计数。

然而一旦有两个红色格子是相邻的，就没有必要再游戏前放棋子了。因为可以直接把棋下在这两个相邻的红色格子上，然后交替着跳，被跳过的棋子可以按照之前的步骤补回来。也就意味着每个位置都是可以被跳到的。

这种情况下，第一问的答案无疑就是 $0$ 了，第二问的答案还需要利用 $dp$ 求出。

设 $f_i$ 表示要在第 $i$ 个位置上放棋，最少需要在**红色格子**上放多少棋。

初始化：白色格子的 $f_i = \infty$，红色格子的 $f_i = 1$。

转移的话，按照上面说的，我们可以交替着跳到那个格子。要跳到 $i$，可以现想办法跳到 $i + 1$ 和 $i + 2$，然后 $i + 2$ 就可以跳到 $i$ 了，不难发现转移式：$f_i = \min\{f_i,\ f_{i+1} + f_{i+2}\}$。同理可以从左边跳过来：$f_i = \min\{f_i,\ f_{i-1} + f_{i-2}\}$。

看起来两个式子是交替更新的，实际上，只要有相邻的红色格子，$O(n)$ 往两边分别更新就行了，整体复杂度 $O(n^2)$。

最后，不要忘了偶数位置上放棋是最优的，所以 $ans = \sum\limits_{i \mod 2 = 0}f_i$。

### 代码实现

注意最后才能移走起点的棋子，所以起点的红色应该看作白色。

```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>

const int maxN = 1005;

int n, cnt[2], a[maxN];
long long ans, f[maxN];
bool flag = true;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) { scanf("%d", &a[i]); }
    a[1] = 0; // 初始位置的红色是没有用的.
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) { cnt[a[i]]++; } // 偶数位置记录红色白色的数量.
        if (a[i - 1] + a[i] == 2) { flag = false; } // 红色相邻.
    }
    if (flag) { printf("%d\n%d\n", cnt[0], cnt[1]); } else {
        for (int i = 1; i <= n; i++) { f[i] = a[i] ? 1 : 1e18; } // 初始化 dp.
        for (int i = 1; i <= n; i++) {
            if (a[i - 1] + a[i] == 2) {
                for (int j = i - 2; j >= 1; j--) { f[j] = std::min(f[j], f[j + 1] + f[j + 2]); } // 往左跳.
                for (int j = i + 1; j <= n; j++) { f[j] = std::min(f[j], f[j - 1] + f[j - 2]); } // 往右跳.
            }
        }
        for (int i = 1; i <= n; i++) {
            if (i % 2 == 0) { ans += f[i]; } // 偶数位置统计答案.
        }
        printf("%d\n%lld\n", 0, ans);
    }
    return 0;
}
```

---

## 作者：Starria的脑残粉 (赞：8)

其实就是一个大暴力罢了，（看前面傅强树的提交记录是n^2的然鹅这个是on的

注意在最右边出现的红色是有效的!

注意在最右边出现的红色是有效的!

注意在最右边出现的红色是有效的!

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000000],f[1000000],x,y;
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    memset(f,10,sizeof(f));
    for (int i=1;i<=n;i++){
        cin>>a[i];
        if (a[i]&&i!=1)f[i]=1;//放一个跳棋的代价为1
    }
    for (int i=2;i<=n;i++)f[i]=min(f[i],f[i-1]+f[i-2]);
    for (int i=n;i>=1;i--)f[i]=min(f[i],f[i+1]+f[i+2]);//即i这个位置的跳棋可以由相邻的连续两个跳棋转移
    for (int i=1;i<=n;i++)
        if (i%2==0){
                if (f[i]>1e15)x++;//这个位置不能由单纯的在红色位置放跳棋转移
                    else y+=f[i];
            }
    cout<<x<<endl<<y<<endl; 
}
```

---

## 作者：AzusaShirasu (赞：7)

本题主要考察思维，代码实现难度不大。

首先要注意，本题随时可以放棋子，但是分两个阶段：

1. **初始化**阶段。在这个阶段，棋子可以任意放置，不受格子颜色的限制；

2. **游戏阶段**。在这个阶段，棋子只能放在**红色**格子上。

本题的两个问题就可以概括成：

$\text{Q1. }$ 初始化阶段至少要放多少颗棋子；

$\text{Q2. }$ 在上一问的基础上，至少要在游戏阶段放多少颗棋子。

***

那么不难发现，放在**第** $1$ **格的棋子**的每一步一定是**落在奇数编号格上的**。

其实这就说明了本题一定有解——只要在初始化时直接在每个偶数编号格子上放置棋子即可。那么跳棋的大概路径就会是这样：

![](https://i.bmp.ovh/imgs/2021/12/64b17418fe8b04fb.png)

因此本题是一定有解的。下面我们考虑加入了红色格子的情况，假设**没有两个相邻红色格子**。如下图：

![](https://i.bmp.ovh/imgs/2021/12/7cb68c3305735814.png)

第 $1$ 格的棋子的路径既然一定是 $1 \rightarrow 3 \rightarrow 5 \rightarrow 7 \rightarrow 9$，那么**必然要在偶数号格子上放棋子**（否则跳不过去），放不放只是时间问题。

根据题意，第一问需要求的是初始化阶段放置棋子的最小数目，那么在这种情况下就很显然了：既然**偶数号**红色格子可以等到游戏阶段再放置，那么初始化阶段就可以**只在偶数号白色格子放棋子**，剩下的等到游戏阶段再补上。用图例说明：

![](https://i.bmp.ovh/imgs/2021/12/4a3b8b1d1e319728.png)

![](https://i.bmp.ovh/imgs/2021/12/7f5d3a0a74b64931.png)

第二问的答案也呼之欲出了。有多少个红色格子，就放多少个。

那么结论就是：如果**不存在相邻红色格子**，直接**统计偶数号格子中白色格子和红色格子的数量**，分别作为第一问和第二问的答案。

***

但是，会出现一个问题：如果有两个相邻格子呢？

![](https://i.bmp.ovh/imgs/2021/12/58b84795922f957d.png)

请注意，棋子**可以往左跳**。这种情况下，还有必要在初始化阶段放置棋子吗？


如果要移动 $1$ 号格子的棋子，必然要使 $2$ 号格上有一颗棋子。但是，这颗棋子的来源不一定是要我们直接放置的。如果我们在 $3$ 和 $4$ 各放一颗，然后让 $4$ 往左跳，这样就可以使得 $2$ 号格有棋子了。

![](https://i.bmp.ovh/imgs/2021/12/5c23f667de90847b.png)

不难发现，如果存在两个相邻红色格子，那么靠这两个格子当“跳板”就能到达任意格子。也就是说，在这种情况下，**第一问的答案为** $0$。

***

接下来考虑如何使得第二问的答案最小。考虑如下情况：

![](https://i.bmp.ovh/imgs/2021/12/92b65d3d12506e21.png)

那么如果要让 $4$ 号格子有棋子，至少需要多少颗棋子呢？很明显，让 $2$ 和 $3$ 而不是 $7$ 和 $8$ 两格去当“跳板”能够省下最多的棋子。所以对于每一个格子，都需要进行一次动态规划来计算。

如果要让 $5$ 号格子有棋子，那么得让 $4$ 和 $3$ 都有棋子。设 $f(x)$ 表示让 $x$ 号格子有棋子的最少数量，不难得到：
$$f(x) = \text{min(}f(x), f(x-1) + f(x-2))$$

当然，还可以往左边跳，方程的推导比较类似，这里就不过多赘述。

至于怎么对 $f$ 数组进行初始化，不难想到：如果这个格子是红色的，那么就初始化成 $1$，否则初始化成 $\text{inf}$。原因很简单：如果这个格子本身就是红色的，只要直接放就能让它上面有一颗棋子，无需通过其他格子转移得到。


所以最终的状态转移方程就是：

$$
f(x) = 
\begin{cases}
\text{min\{}f(x), f(x-1) + f(x-2),  f(x+1) + f(x+2)\} & & {color_x \neq 1}\\
1 & & {color_x = 1}\\
\end{cases}
$$

$$ans=\sum^{\lfloor\frac{n}{2}\rfloor}_{x=1}f(2x)$$


因为只需要计算偶数格上的棋子数量，所以只取下标为偶数的 $f$ 相加。

另外注意，这道题需要开 `long long`。

***

```
#include <cstdio>

#define int long long

const int maxn = 1000 + 5;
const int inf = 1e18;

int n;
int red, white;
bool a[maxn];
int f[maxn];
bool ok = false;

inline bool getbyte() {
	char c;
	while((c = getchar()) < '0' || c > '1');
	return c == '1';
} 

inline int getint() {
	char c;
	while((c = getchar()) < '0' || c > '9');
	int x = c - '0';
	while((c = getchar()) >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0';
	return x;
}

inline int min(int a, int b) {
	return a < b ? a : b;
}

signed main() {
	n = getint();
	for(int i = 1; i <= n; i++) {
		a[i] = getbyte();
	}
	a[1] = 0;
	for(int i = 1; i <= n; i++) {
		if(i % 2 == 0) {
			if(a[i]) red++;
			else white++;
		}
		if(a[i - 1] && a[i]) { // 出现相邻红色格
			ok = true;
		}
	}
	if(!ok) { // 没有相邻的红色格子
		printf("%d\n%d", white, red);
		return 0;
	}
	for(int i = 1; i <= n; i++) {
		f[i] = a[i] ? 1 : inf; // 初始化
	}
	for(int i = 1; i <= n; i++) { // 分开计算左右的状态转移方程
		if(a[i - 1] && a[i]) {
			for(int j = i - 2; j >= 1; j--) {
				f[j] = min(f[j + 2] + f[j + 1], f[j]);
			}
			for(int j = i + 1; j <= n; j++) {
				f[j] = min(f[j - 2] + f[j - 1], f[j]);
			}
		}
	}
	
	long long ans = 0;
	for(int i = 1; i <= (n >> 1); i++) { // 只计算偶数下标的总和
		ans += f[i * 2];
	}
	putchar('0'); putchar('\n');
	printf("%lld\n", ans);
	return 0;
}
```
Remember to leave a like!

求通过~

---

## 作者：nomonick (赞：2)

# 题解 P2039 【[AHOI2009]跳棋】

这道题目首先一下子就会想到只要在编号为偶数的点上放置棋子就可以让起点的棋子调到终点了。

这里我们考虑一个非常特殊的情况，其中如果连续两个格子是红色的，那么每一个点都是可以通过这样的情况来布置。

综上所述，只要存在这样的情况就不必要再跳棋之前，放任何一颗棋子，这样就是最优秀的情况。

然后对于每一个棋子如何跳到这里，是可以直接递推得到。每一个点如果他左边或右边有了棋子，那么他就是可以直接跳到的。

-   _从左向右跳_ 

$$
f_j = \min(f_j,f_{j-1}+f_{j-1})
$$


- 　_从右向左跳_ 

$$
f_j = \min(f_j,f_{j+1}+f_{j+1})
$$

所以综上所得总步数是：$\sum\limits_{i\mod 2 = 0}^nf_i$

因此预处理一下是否存在这种情况即可。

# code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int SIZE = 1e3 + 50;
const int inf = 1e18 + 50;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n;
int color[SIZE],dp[SIZE];
bool flag;

inline void pre() // 初始化
{
	printf("0\n");
	for (int i = 1; i <= n; ++i)
	{
		dp[i] = (color[i] ? 1 : inf);
	}
}

inline void solve()
{
	pre();
	for (int i = 1; i <= n; ++i)
	{
		if (color[i-1] + color[i] == 2)
		{
			for (int j = i-2; j; --j)
			{
				dp[j] = min(dp[j],dp[j+1]+dp[j+2]);
			}
			for (int j = i+1; j <= n; ++j)
			{
				dp[j] = min(dp[j],dp[j-1]+dp[j-2]);
			}
		}
	}
	int ans = 0;
	for (int i = 2; i < n; i += 2)
	{
		ans += dp[i];
	}
	printf("%lld\n",ans);
}

signed main()
{
	n = read();flag = true;
	for (int i = 1; i <= n; ++i)
	{
		color[i] = read();
		if (i == 1 && color[i]) color[i] = 0;
		/*注意要把初始的点设为白色，因为初始点的颜色与答案无关，这很重要*/ 
		if (color[i] + color[i-1] == 2) flag = false;
	}
	if (flag)
	{
		int a = 0,b = 0;
		for (int i = 2; i < n; i += 2)
		{
			if (color[i] == 0) a++;
			else b++;
		}
		printf("%lld\n%lld\n",a,b);
		return 0;
	}
	solve();
	return 0;
}
```

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P2039)。

## 解题思路

第一问求在白格上必须放的最少棋子数，考虑三种情况。

1. 有不少于两个红格连起来，可以一直在行动中放，一直跳到任意一个格子，那么行动前就不需要棋子，但是连续的两个红格子中不能有红棋。

2. 一个白格一个红格，那么在红格子上放一个棋子就可以用白格子上的棋子跳过去了，代价是 $1$。

3. 两个白格, 在偶数点上放是最优的，代价是 $1$。

把这三种情况累加即为答案。

第二问是白格上的棋子最少时，求红格上放的最少棋子数，考虑两种情况。

1. 能被红格上的棋子跳到就让红格去跳，代价是一个斐波那契数列，左右更新两遍即可。

2. 不能被红格上的棋子跳到就放棋子。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 1005
#define inf 1000000000000005
using namespace std;
int n,color[maxn];
long long ans1,ans2,dp[maxn];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>color[i];
    memset(dp,0x3f,sizeof(dp));
    for(int i=2;i<=n;++i)
        if(color[i])
            dp[i]=1;
        else
            dp[i]=min(dp[i],dp[i-1]+dp[i-2]);
    for(int i=n;i>=2;--i)
        dp[i]=min(dp[i],dp[i+1]+dp[i+2]);
    for(int i=2;i<=n;i+=2)
        if(dp[i]<inf)
            ans2+=dp[i];
        else 
            ++ans1;
    cout<<ans1<<'\n'<<ans2;
    return 0;
}
```

---

## 作者：Hisaishi_Kanade (赞：0)

先丢掉红色块——钦定全都不是红色块。这样问题就简化了。

我们发现下图是一种方式。原始棋子一路吃过去即可，这种情况很容易想出。

[![pp7pXK1.png](https://s1.ax1x.com/2023/04/07/pp7pXK1.png)](https://imgse.com/i/pp7pXK1)

那如果我们把红色块纳入，又会怎么样呢？

题目中既然已经说了，要求第一问答案最小，那么换句话说，既然黄色的格子迟早要染，那么就**让它们第二问再被染**。

第一问，数黄色格子中，上方不是红色格子的个数。

第二问，数红色格子中，下方是黄色格子的个数。

解决了这种红色没有相邻的情况。

[![pp7pvb6.png](https://s1.ax1x.com/2023/04/07/pp7pvb6.png)](https://imgse.com/i/pp7pvb6)

如果现在，红色可以相邻怎么办？

[![pp7pjDx.png](https://s1.ax1x.com/2023/04/07/pp7pjDx.png)](https://imgse.com/i/pp7pjDx)

还是第二种情况的思路，我们就要让第一问答案最小即可。

模拟一遍发现，只要让在两个红色的格子上一直放棋子，整个盘子上任何地方都能被放置。
[![pp798rq.md.png](https://s1.ax1x.com/2023/04/07/pp798rq.md.png)](https://imgse.com/i/pp798rq)

重复上图类似步骤，显然右侧蓝色每列都会被访问。

类似地，左侧也同理。

我们考虑最少第几步访问这一列？

显然，要么从左边第一个被左边第二个吃了，或者右边第一个被右边第二个吃了。

设 $f_{i}$ 表示访问 $i$ 的最小次数，$f_{i}=\min\{f_{i-1}+f_{i-2},f_{i+1}+f_{i+2}\}$。

若 $i$ 为红色方块之一，则 $f_{i}=1$。
## 代码实现

分情况，如果是前两种直接数，否则大力 dp。
```cpp
#include <stdio.h>
#define rep(i,l,r) for(i=l;i<=r;++i)
#define req(i,r,l) for(i=r;i>=l;--i)
int col[1005];
using ll=long long;
ll f[1005];
const long long inf=1ll<<60;
int ans1,ans2;
inline ll min(ll x,ll y){return x<y?x:y;}
int main()
{
	bool div1,div2;
	div1=div2=true;
	int n,i,j;
	scanf("%d",&n);
	rep(i,1,n)
		scanf("%d",col+i);
	col[1]=false;
	rep(i,1,n)
	{
		if(col[i])
			div1=false;
		if(col[i] && col[i-1])
			div2=false;
	}
	if(div1)
		printf("%d %d",n/2,0);
	else if(div2)
	{
		rep(i,2,n)
		{
			if(!col[i])
				++ans1;
			else
				++ans2;
			++i;
		}
		printf("%d\n%d",ans1,ans2);
	}else
	{
		puts("0");
		long long ret=0;
		rep(i,1,n)
			f[i]=col[i]?1:inf;
		rep(i,1,n)
		{
			if(col[i] && col[i-1])
			{
				req(j,i-2,1)
					f[j]=min(f[j],f[j+1]+f[j+2]);
				rep(j,i+1,n)
					f[j]=min(f[j],f[j-1]+f[j-2]);
			}
		}
		rep(i,2,n)
		{
			ret+=f[i];
			++i;
		}
		printf("%lld\n",ret);
	}
	return 0;
}
```

---


# 果汁店的难题

## 题目描述

炎热的夏天，来上一杯现榨的冰爽果汁想想都是一件惬意的事情！话说小王就看准了这一商机，在学校附近开了这么一家果汁店，但是最近他碰到了一个不大不小的难题：小王的果汁店里准备了 $K$ 台榨汁机，当然每台榨汁机只能榨一种果汁，在某个时段内，一个客人点了某种果汁，如果恰好有某台果汁机榨过这种果汁，那么就直接给客人用这台果汁机接着榨就可以了，但是如果点的是一种新的果汁就需要找一台干净的果汁机来用，问题就出在这，如果这时候还有空的果汁机还好，如果没有的话小王就需要将某台刚才用过的拿去清洗，清洗的话呢就得浪费很多的时间和很多的水，小王是个很有经济头脑的人，他想知道在排队客人需求已知的情况下最少需要清洗多少次果汁机？假定开始时所有果汁机都是干净的，为了方便描述，我们将果汁编号为 $1$（橙汁），$2$（苹果汁），$3$（葡萄汁）......

[友情提示：本店不售卖混合果汁]

## 说明/提示

$1\le K\le 10$，$1\le N\le 100$。

$1\le x_i\le 100$。

## 样例 #1

### 输入

```
2 7
1
2
3
1
3
1
3
```

### 输出

```
1
```

# 题解

## 作者：miemieQWQ (赞：21)

话说这个题目没题解就算了,连个标签也不给.

起初我以为是区间dp,结果...(中间8点全WA,最后一点还T掉了)

为了对这道题宣泄不满,我祭出随机数大法...(AC两个点...)


其实这道题 **模拟+贪心** 就好了.

成功的第一步就是认真读题:

注意客人的请求是有序的,不能先s只榨o一种r果汁t!


模拟的话大家都是大佬,我就用队列和集合随便搞搞.

贪心的策略稍微难想一些:

每次遇到 新的果汁 并且 所有榨汁机相对不干净 的时候,

我们选择一个优先级最高的榨汁机清洗(榨汁机刚刚榨过的果汁,需要再次榨的时间越久优先级越高)

举个栗子:

两台榨汁机正在榨: 4 5 (号果汁)

客人还需要: 7 8 5 4 5 (号果汁)

这时我们肯定要清洗 榨4号的机器 来榨7,

再清洗7(因为之后不需要榨7了)来榨8,

榨5不用清洗,榨4清洗8,榨5,over.(清洗3次)


我最怕的就是类似"显而易见"这种话,只要不是水题,我的智商和5岁小孩没有区别.

所以我们来证一下贪心吧:

(以榨汁机刚刚榨果汁的编号作为榨汁机的编号)

设机器刚刚榨过果汁X ={x1,x2...xk},客人还需要果汁Y ={y1,y2...yn}.

若 y1 ∉ X 并且 xa ∉ Y,清洗xa是最优解之一;

若 y1 ∉ X 并且 X ⊆ Y,

令{x1,x2...xk}在Y中 第一次 出现的时间为{t1,t2...tk},

要榨 Y-X 中的果汁肯定要清洗至少一次,就像y1一样

当ta越大时则在Y中xa之前的X的元素越多,即清洗次数越少.

ta最大,Y中xa之前的X中的元素最多(为除开xa的所有X中的元素),

若不清洗xa,则有xb∈X会导致多清洗一次,所以清洗xa最优.


下面我把我的AC代码贴上,仅供参考.





```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int k, n, ans = 0;
queue<int> pos[N];    //pos[i].表示要 i号果汁客人的位置 
set<int> machine;    //machine表示当前机器正在榨的果汁 
queue<int> juice;    //表示果汁请求队列 
void arrange(int x)
{
    juice.pop(), pos[x].pop();
    if (machine.find(x) == machine.end()) //如果没有找到合适的榨汁机就要清洗了 
    {
        ans++;
        int farthest = 0, best;
        for (set<int>::iterator it = machine.begin(); it != machine.end(); it++)
            if (pos[*it].empty()) //如果这个果汁之后都没有客人点了,就直接清洗 
            {
                machine.erase(*it), machine.insert(x);
                return ;
            }
            else if (farthest < pos[*it].front()) //找一个短时间不可能用到的榨汁机清洗 
                farthest = pos[*it].front(), best = *it;
        machine.erase(best), machine.insert(x);
    }
    return ;
}
int main()
{
    ios::sync_with_stdio(false);
    cin >>k >>n;
    for (int i = 1, x; i <= n; i++)
    {
        cin >>x;
        pos[x].push(i);    //类似桶排的方法存果汁请求的位置 
        juice.push(x);    //当前请求入队 
    }
    //在不清洗的情况下安排满k个榨汁机 
    while (machine.size() < k && !juice.empty())
    {
        int temp = juice.front();
        juice.pop(), pos[temp].pop();
        machine.insert(temp);
    }
    while (!juice.empty()) //如果还有果汁要榨就给安排榨汁机 
        arrange(juice.front());
    cout <<ans <<endl;
    return 0;
}

```

---

## 作者：Atserckcn (赞：10)

## [P2088 果汁店的难题](https://www.luogu.com.cn/problem/P2088) 题解

### 题目简述：

共 $K$ 台榨汁机，$N$ 名贵客需要榨果汁，每种榨汁机榨完一种果汁都需要清洗，求满足 $N$ 名贵客榨汁的情况下，最少的清洗次数。

### 思路简述：

题外话：在现实中，我们不可能预知后来的顾客想要的果汁（除非是网购，那顺序也无所谓了。），但毕竟是编程题……

正事。

考虑贪心和模拟。

贪心：

因为每个榨汁机的清洗都与后面需要榨的果汁有关，所以我们尽可能地洗后续需要**榨同类型的果汁**需求最靠后的那个。

上句是整道题的解题重点，可努力加以理解。

题外话说到，因为不能预测，所以我们不能够为了贪心而把所有果汁排序，再依次制作，即：

想要洗的次数少，排序 `sort` 过不了。

### 具体代码过程：

依次枚举每个贵客需要的果汁，判断还有没有榨汁机空余。

设我们现在枚举到第 $i$ 个客人需求。

若有，则直接用空余榨汁机榨果汁。

否则，依次判断第 $i-1 \sim n$​ 号需求，判断最晚有需求的果汁，并清洗相应榨汁机。

若还看不懂，下列代码有注释。

### AC  Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=105/*N个贵客*/,MAXK=15/*K台榨汁机*/;
int a[MAXK],n,k,ans;
bool use[MAXN];
int uid[MAXN],which,id,cnt_used;
int main(){
	scanf("%d%d",&k,&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		if(use[a[i]]) continue;//如果这种果汁已经有榨汁机榨了，不用管
		if(cnt_used<k)//如果还有榨汁机空闲
		{
			use[a[i]]=true;//则选择榨此果汁
			cnt_used++;
			continue;
		}
		memset(uid,0,sizeof(uid));//别看名字，我乱取的，uid[u]表示u种果汁在后边最早出现时的编号
		id=which=0;//which表示需要选择清洗正在榨which种果汁的榨汁机，id后边出现的编号
		for(int j=i+1;j<=n;j++)//预处理
			if(use[a[j]]&&!uid[a[j]])//有榨汁机榨过且后边暂时未知
				uid[a[j]]=++id;
		for(int j=1;j<=n;j++)
		{
			if(use[j]&&!uid[j])//不需要用了，则直接清洗
			{
				which=j;
				break;
			}
			else
				if(use[j]&&uid[j]==k)//最后一种果汁，直接清洗
					which=j;
		}
		ans++;
		use[which]=false;//which号果汁就没有可榨它的榨汁机了
		use[a[i]]=true;//新洗为第a[i]种
	}
	printf("%d\n",ans);
	return 0;
}
```

**[AC 记录](https://www.luogu.com.cn/record/162573190)**

---

## 作者：mzycmzy (赞：8)

## **模拟+贪心**
解释在代码里。
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,s,n,q;
int rewq[105],p[105],ans;//rewq用来存储客人的果汁型号，p用来存储此型号的榨汁机有没有可以直接用的，ans用来存储洗多少次。 
map<int,int> a;//用来存储型号的榨汁机有没有被记录了。 
int main(){
	cin>>k>>n;s=k;
	for(q=1;q<=n;q++) cin>>rewq[q];
	for(q=1;q<=n;q++)
	{
		if(s&&!p[rewq[q]]) p[rewq[q]]=1,s--;//如果榨汁机有空的:存储此型号的榨汁机记录。
		else if(p[rewq[q]]) {}//如果榨汁机有：不做处理。 
		else
		{
			int flag=0;
			for(int i=q,s=k;i<=n&&s;i++)
			{
				if(!a[rewq[i]]&&p[rewq[i]]) 
					{s--;a[rewq[i]]=1;if(!s) flag=rewq[i];}
			}
			p[flag]=0;p[rewq[q]]=1;ans++;
			a.clear();
		} 
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Heap_Sort (赞：6)

这道题目身为一道绿题，不仅没有一个标签，而且其他题解说得也很不清楚，都说是根据后面出现最晚的来清洗，但是没说清楚是选每种果汁最晚出现时间最晚的，还是选每种果汁最早出现时间最晚的（绕口令）

这里我强调一下，要选 _**每种果汁在当前客人之后最早出现时间最晚的**_ 来清洗，如果你选每种果汁最晚出现时间最晚的，就只有80分，并且无论是样例数据还是其他题解里的数据都测不出来，困扰了我很久。

初始化要注意了，很显然是无穷大，但是对于目前没在榨的果汁，要初始化为0。

上代码（对p党友好的一篇题解）

```pascal
uses math;
label 10;
var s:array[1..100] of integer;
  bo:array[1..100] of boolean;
  x:array[1..100] of integer;
  k,n,a,b,c,d,e,l:longint;
begin
  readln(k,n);
  for a:=1 to n do read(s[a]);
  for a:=1 to n do
   begin
    if bo[s[a]]=true then goto 10;//如果当前该果汁在榨，则继续榨。
    if b<k then begin inc(b);bo[s[a]]:=true;goto 10;end;//如果有空余机器，开始榨该果汁。
    for c:=1 to 100 do if bo[c]=true then x[c]:=maxint else x[c]:=0;//初始化（使用fillchar会编译错误）
    for c:=a+1 to n do x[s[c]]:=min(x[s[c]],c);//记录当前客人以后最早出现时间
    d:=0;
    for c:=1 to 100 do if x[c]>d then begin d:=x[c];e:=c;end;//宣取最大值
    bo[e]:=false;bo[s[a]]:=true;inc(l);//清洗，重榨。
10:end;
  writeln(l);
end.
```


---

## 作者：mzycfzr (赞：4)

### ~~蒟蒻~~的题解。

------------
话不多说，开始上正菜。
对于这道题，只需要用**模拟+贪心**就行了。
初读题目，可能~~特别~~懵逼，但理解清楚后就感觉茅塞顿开。本题有两个难点，**一是考虑时间成本，二是考虑洗哪一台榨汁机。**如果想通了这两个问题，那么这道题也就解出来了。

------------
所以，这道题不能只统计出现了多少种果汁，还要用时间来**模拟**。

举个栗子。比如数据为
3 10
1
2
3
5
4
3
2
1
3
1

 1 用一台， 2 用一台， 3 用一台，在 5 那里应该考虑洗哪有台榨汁机。

从 3 2 1 那里看出 1 是后榨，所以就洗 1 。

同理，应该在 4 那里洗 5 ，因为 5 在后面没有了。

接着， 3 榨过， 2 榨过，到 1 时应该洗 4 ，原理前面讲过。

------------
想通了这些，这道题迎刃而解。话不多说，我们直接上完整代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
bool px(int a,int b)
{
	return a>b;
}
int a[105],b[15],ans;
int main()
{
	int k,n,i,j=1,l,q,max=-1;
	cin>>k>>n;
	for(i=1; i<=n; i++)
		cin>>a[i];//读入
	for(i=1; i<=n; i++)
	{
		int x=0;
		for(l=1; l<=j; l++)
		{
			if(a[i]==b[l]){x=1; break;}
		}//如果打过种果汁，就不用洗榨汁机了
		if(x==1) continue;//如果打过种果汁，退出这次循环
		else
		{
			if(j<=k)
			{
				b[j]=a[i];
				j++;
			}//如果榨汁机还够，直接用1台榨汁机
			else
			{
				max=0;
				int c[j+5]={0};
				x=0;
				for(q=1; q<=j-1; q++)
				{
					for(l=i+1; l<=n; l++)
					{
						if(b[q]==a[l]){c[q]=l; break;}
					}//如果榨汁机不够，且打过种果汁，就不用洗榨汁机了
					if(c[q]==0){b[q]=a[i]; ans++; x=1; break;}如果没有打过种果汁，就洗1次榨汁机
					else
					{
						if(max<c[q])max=c[q];
					}//迭代最大值
				}
				if(x==0)
				{
					for(q=1; q<=j-1; q++)
					{
						if(b[q]==a[max]){b[q]=a[i]; ans++; x=1;}
					}//如果这种果汁打过，就找越在后面大的果汁
					if(x==0)
					{
						b[j-1]=a[i];
						ans++;
					}//如果后面没有这种果汁了，就把这台榨汁机洗了
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
**记得点赞！**

---

## 作者：OMITW (赞：3)

# 前言
这不就是纯纯贪心吗？居然没有足够的人交题解。

# 思路推导

如果此时进来的人所需要的果汁没有占用果汁机并且没有干净的果汁机了，那我们应该把哪一个果汁机进行清洗呢？

仔细想想，我们之所以要保留一个果汁机，无非是因为自后要用到。~~虽然现实中无法做到，但是这毕竟是编程~~。所以我们进行清洗果汁机的操作时，我们运用贪心思想，把下一次出现的最晚的时间的果汁所使用的果汁机进行清理，如果有没出现的，就清洗没有出现的。更多详解再代码中。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,sum,a[105],b[105],bj[105],k;//b数组表示果汁i是否占用了果汁机 
int main()
{
	cin>>m>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(b[a[i]])continue;//如果这个果汁还占用果汁机，那就不用管 
		if(sum<m)//如果果汁机数量还够，那就使用一个干净的果汁机 
		{
			b[a[i]]=1;
			sum++;
			continue;
		}
		memset(bj,0,sizeof(bj));//bj数组表示每个编号j在i+1~n这个区间内最早出现的编号 
		long long sx=0,pc=0;//sx表示出现的编号，pc表示要清洗哪个果汁机 
		for(int j=i+1;j<=n;j++)
			if(b[a[j]]&&!bj[a[j]])bj[a[j]]=++sx;
		for(int j=1;j<=100;j++)
			if(b[j]&&bj[j]==0)//如果不在出现，就直接清洗 
			{
				pc=j;
				break;
			}
			else if(b[j]&&bj[j]==m)pc=j;//如果没有不出现，那就选最晚出现
		b[a[i]]=1; 
		b[pc]=0;
		k++;
	}
	cout<<k;
	return 0;
}
```

---

## 作者：junee (赞：2)

#  P2088 题解

## 前置知识

贪心，堆。

## 题目分析

对于每一种果汁，求出其下一次的位置。当机子个数小于目前个数，则直接放进去；若机子个数等于总个数，则将最远距离的踢掉，先解决近的，再解决远的。

当遇到之前出现过的，将此果汁的距离更新为当前点下一个同样果汁的距离。

## Code

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<map>
using namespace std;
const int N=2e5+10;
typedef pair<int,int>PII;
int n,m,k;
int a[N],nex[N],pre[N],b[N];
priority_queue<PII>q;
int ans=0,sz=0;
int main(){
    cin>>k>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++){
        nex[pre[a[i]]]=i;
        pre[a[i]]=i;
    }
    for(int i=1;i<=n;i++)if(!nex[i])nex[i]=0x3f3f3f3f;
    for(int i=1;i<=n;i++){
        if(b[a[i]]){
        	q.push({nex[i],a[i]});
        	continue;
		}
        if(sz==k)b[q.top().second]=0,q.pop(),sz--;
        b[a[i]]=1;
        q.push({nex[i],a[i]});
        ans++,sz++;
    }
    cout<<ans-k;
    return 0;
}
```

---

## 作者：icaijy (赞：2)

# 思路
本题的难点就是决定应该炸了清洗几号果汁的果汁机。而这个可以使用**贪心算法**解决，就是**清洗在后面最晚出现的果汁的榨汁机**。

证明这个可以用贪心也很简单，因为假设清洗最晚出现的不是最优的，那么就会在更早的时候要求清洗榨汁机。而很显然越晚清洗果汁机会更好一些，所以贪心正确。

# 代码
别的 dalao 的代码都用了 STL 的数据结构，我这里选择了**用 CPP 自带的数组**，所以对不会 STL 的初学者（~~比如我~~）比较友好。

先读入。然后开始**模拟**，如果**还有空的**榨汁机就用一台。否则如果**榨汁机炸过不用清洗**，即 $now$ 里面的这一项是 true，那么直接继续循环。否则就**搜索所有目前的榨汁机的口味**，找到后面出现最晚的口味然后洗掉。$ans$ 加 $1$。

最终代码：
```cpp
#include <iostream>
using namespace std;
int queue[105];
bool now[105];
int find(int a,int c) {
	for (int i=a;i<104;i++) {
		if (queue[i]==c) return i;
	}
	return 114514;
	// 没有返回
}
int main() {
	int ans=0;
	int n,k;
	int ix;
	int c; // 出现的后 
	int maxx=0; // 出现下标最小 
	scanf("%d%d",&k,&n); // 读。。。 
	for (int i=0;i<n;i++) scanf("%d",&queue[i]); // 读。。。 
	for (int i=0;i<n;i++) {
		if (k>0) {
			k--;
			// 空机器-1 
			now[queue[i]]=true;
			// 目前能用的机器	
			continue;
		} else if (now[queue[i]]) {
			// 如果目前的有 
			continue;
		} else {
			ans++;
			//清洗次数+1 
			maxx=0;
			for (int j=1;j<101;j++) {
				// 一直找目前有的榨汁机，准备弹出 
				if (now[j]) {
					// 如果在使用，就判断 
					ix=find(i+1,j);
					if (ix==114514) {
						// 没找到 
						c=j;
						break;
					} else {
						if (maxx<ix) {
							// 更加远，更新 
							maxx=ix;
							c=j;
						}
					}
				}
			}
			// 洗 
			now[c]=false;
			// 炸 
			now[queue[i]]=true;
		}
	}
	cout << ans;
}
```


---

## 作者：matlgh (赞：1)

通过这段题的描述容易看出这是一道贪心题目。

依据此题有固定的购买顺序，所以对于所遍历到的果汁若没有榨汁机对应，则对于后面出现的**每一种果汁出现的第一个位置**离该果汁越远所被替换的优先级越高，因为暂时用不到这一种果汁。若后方有一种果汁的个数被清零则将这个果汁到当前位置的距离变为无限远，即优先级最高。
若有对应的榨汁机则直接清洗就好了。

下面提供完整代码。

**code**


```cpp
#include <bits/stdc++.h>
using namespace std;
struct node1
{
	int id=0,shu=0,di=0;
};
//id代表果汁的种类,shu代表果汁的数量，di代表这种果汁距离当前位置的距离。
struct node
{
	node1 a[101];
}b[101];
int c[101];// c数组存储果汁顺序。
int cmp(node1 x,node1 y)
{
	return x.di>y.di;
}
//按照距离排序
int f[101];
int main()
{
	int K,N,maxn=-0x7f7f7f7f,sum=0,ans=0;
	scanf("%d%d",&K,&N);
	for(int i=1;i<=N;i++)
	{
		scanf("%d",&c[i]);
		maxn=max(maxn,c[i]);
	}
  //maxn记录当前数据中果汁的种类量。
	for(int i=N;i>=1;i--)
	{
		for(int j=1;j<=maxn;j++)
		{
			b[i].a[j].shu=b[i+1].a[j].shu;
			b[i].a[j].di=b[i+1].a[j].di;
			if(b[i].a[j].shu==0)
			{
				b[i+1].a[j].di=0x7f7f7f7f;
			}
			b[i].a[j].id=j;
		}
		b[i].a[c[i]].shu=b[i+1].a[c[i]].shu+1;
		b[i].a[c[i]].di=i;
	}//对数据进行初始化。
	for(int i=1;i<=N;i++)
	{
		sort(b[i].a+1,b[i].a+1+maxn,cmp);
	}//将果汁的优先级排序。
	for(int i=1;i<=N;i++)
	{
		if(sum<K&&f[c[i]]==0)//若无对应的榨汁机且有空榨汁机则直接使用。
		{
			sum++;
			f[c[i]]=1;
		}
		else if(f[c[i]]!=1)//否则没有对应榨汁机且无空榨汁机，则将一种果汁存在于当前的榨汁机中，且距离当前位置最远的替换掉。
		{
			ans++;
			for(int j=1;j<=maxn;j++)
			{
				if(f[b[i].a[j].id]==1&&b[i].a[j].id!=c[i])
				{
					f[b[i].a[j].id]=0;
					f[c[i]]=1;
					break;
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：lostxxx (赞：1)

# 题目分析

首先我们发现，清洗那种榨汁机对后面的清洗有影响，所以我们考虑贪心。

一开始，我想到了用前缀和来处理某个区间内某种果汁所用到的次数，每次清洗选择剩下区间 $i+1 \dots n$ 中果汁出现最少的果汁，于是我很快写完并调完了代码，一交挂了 $5$ 个点。于是我开始对拍，发现了这组数据。

```
2 20
2 1 3 4 7 8 10 2 6 4 11 10 2 9 9 2 5 10 9 12
```

这里我的代码输出 $14$，但是正确答案是 $13$。于是我换了一种思路，想到了越在后面的果汁可能对后面的影响更小，更直观讲，假设当前这杯果汁是这种果汁的最后一杯，那么这种果汁对后面的影响为 $0$。所以我们的贪心策略变为选择当前有有榨汁机的果汁中出现最晚的榨汁机来清理，且注意特判最后一杯。

代码如下。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k;
ll a[200100];
ll ans=0;
bool vis[200100];
int main(){
    cin>>k>>n;
    ll tot=k;
    for (int i=1;i<=n;i++)
        cin>>a[i];
    for (int i=1;i<=n;i++){
        if (vis[a[i]]==0){
            if (k==0){
                ll mink=0;
                bool juice[210];
                ll times=0;
                memset(juice,0,sizeof(juice));
                for (int j=i+1;j<=n;j++){
                    if (juice[a[j]]==0 && vis[a[j]]){
                        mink=max((ll)j,mink);
                        times++;
                        juice[a[j]]=1;
                    }
                }
                if (tot==times){
                    vis[a[mink]]=0;
                }else{
                    for (int j=1;j<=100;j++){
                        if (vis[j] && juice[j]==0){
                            vis[j]=0;
                            break;
                        }
                    }
                }
                vis[a[i]]=1;
                ans++;
            }else{
                k--;
                vis[a[i]]=1;
            }
        }else
            continue;
    }
    cout<<ans;
}
```

---

## 作者：Autream (赞：1)

#### 题意简述
有 $K$ 台干净的榨汁机，每台榨汁机只能榨一种果汁，如果要换果汁，那就得清洗一次。

现在有 $N$ 个订单，每个订单给出一种果汁，求最少清洗次数

---
#### 题目分析
如果直接模拟的话是肯定过不了的，考虑贪心。

如果当前没有干净的榨汁机了，并且队列头部的果汁必须要清洗一台榨汁机才行，为了增加当前榨汁机能榨的果汁次数尽可能多（换的尽可能少），就需要清洗榨汁机中下一个同类果汁与当前订单距离最远的，因为它最长时间用不到。用数组记录下标，模拟即可。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=105;
int k,n,ans,a[N];
std::queue<int> q;
std::vector<int> idx[N];
signed main() {
    std::cin>>k>>n;
    rep(i,1,n) {
        int x;
        std::cin>>x;
        idx[x].p_b(i);
        q.push(x);
    }
    rep(i,1,n) {
        int x=q.front();
        q.pop();
        int flag=0;
        rep(j,1,k) {
            if(a[j]==x) {
                flag=1;
                break;
            }
        }
        if(!flag) {
            if(a[0]<k) {
                a[++a[0]]=x;
                continue;
            }
            int lst,max=0;
            rep(j,1,a[0]) {
                int id;
                if(std::u_b(all(idx[a[j]]),i)==idx[a[j]].end()) {
                    id=-1;
                } else {
                    id=std::u_b(all(idx[a[j]]),i)-idx[a[j]].begin();
                }
                if(id==-1) {
                    max=LLONG_MAX;
                    lst=j;
                    continue;
                }
                if(idx[a[j]].at(id)>max) {
                    max=idx[a[j]].at(id);
                    lst=j;
                }
            }
            a[lst]=x;
            ans++;
        }
    }
    std::cout<<ans;
    return 0;
}
```

---

## 作者：caohan (赞：1)

# 思路

先给出一组样例方便理解：

```
2 8
1
2
3
4
1
3
1
3
```
看到这组样例中存在这样四种情况：

- 当前有空榨汁机供我们使用（第一个等）

- 当前的果汁已经被榨过（第五个等）

- 当前的果汁榨完后再也不榨（第二个等）

- 绝对没有任何果汁机了（第四个等）

而且能够发现，这四种情况是全部情况。

于是对于它们定制解决方案即可。

对于第一种，只要其存在，不需要任何管理。

对于第二种，找到一个空机器，附上这种果汁，也不用洗，直接用即可

对于第三种，找到一个再也不需要这个机器所榨的果汁的机器，洗干净，再投入使用。

对于第四种，找到一个机器，它所榨的果汁类型在当前处理的之后的序列中出现最晚，洗干净再使用即可。


于是本题可以用 $\operatorname{O}(N^2K)$ 的时间复杂度解决。很让人开心。

# 代码

```cpp
#include <bits/stdc++.h>
#define mod 998244353
using namespace std;
#define ll long long
int k,n;//the number of machines and requests
int a[105];//the requests of guests
int m[105];//the machine xiaowang has
bool find(int x)//if we have the kind of machine
{
	for(int i=1;i<=k;i++)
	{
		if(m[i]==x)
		{
			return 1;
		}
	}
	return 0;
}
int findempty()//if we have empty machine
{
	for(int i=1;i<=k;i++)
	{
		if(m[i]==0)
		{
			return i;
		}
	}
	return 0;
}
int finda(int st,int k)//where is the latest request of k
{
	int pos=0;
	for(int i=st;i<=n;i++)
	{
		if(a[i]==k)
		{
			return i;
		}		
	}
	return 1919810;//there'll never be a
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>k>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}//input
	int ans=0;//the least times we have to wash the machine
	for(int i=1;i<=n;i++)
	{
		if(find(a[i]))
		{
			//cout<<111111<<"\n";
			continue;
		}//if there was one use it
		else if(findempty())
		{
			//cout<<222222<<" "<<findempty()<<"\n";
			m[findempty()]=a[i];
			continue;
		}//if there was one that haven't been used,use it
		int f1=1;
		for(int j=1;j<=k;j++)
		{
			if(finda(i,m[j])==1919810)
			{
				m[j]=a[i];
				ans++;
				f1=0;
				break;
			}
		}
		if(!f1)
		{
			//cout<<333333<<"\n";
			continue;
		}//if thewre was one that'll never be used,wash and use it
		int maxp,maxx=-1;
		for(int j=1;j<=k;j++)
		{
			int x=finda(i,m[j]);
			if(maxx<x)
			{
				maxp=j;
				maxx=x;
			}
		}
		m[maxp]=a[i];
		ans++;
		//cout<<444444<<"\n";
	}
	cout<<ans;
	return 0;
}
```







---

## 作者：lqsy002 (赞：1)

## 题目大意
题目已经写的很清楚了。[题目链接](https://www.luogu.com.cn/problem/P2088)。
## 解题思路
这题其实就是贪心加上模拟。
1. 首先把 $k$ 台干净的榨汁机排满。
2. 如果还有需求，根据果汁需求的数量和顺序决定清洗的顺序，具体见代码注释。
3. 然后每一次 $ans\leftarrow ans+1$ 就好。
## 参考代码
```
#include<bits/stdc++.h>
using namespace std;
int k,n,x,ans,choice,far;
queue<int>need[110];//客人顺序
queue<int>juice;//果汁顺序
set<int>now_juice;//当前在榨的果汁 
void f(int x){//剩余需求处理
    juice.pop();
    need[x].pop();
    if(now_juice.find(x)==now_juice.end()){//无合适榨汁机，开始清洗
        ans++;//增加次数
        far=0;//短时间不用的机器
        for(set<int>::iterator it=now_juice.begin();it!=now_juice.end();it++)//迭代器
            if(need[*it].empty()){//该种果汁后续无需求，清洗
                now_juice.erase(*it);
		now_juice.insert(x);
                return;
            }else if(far<need[*it].front()){//清洗far对应的机器
            	far=need[*it].front();
		choice=*it;
	    }
        now_juice.erase(choice);
	now_juice.insert(x);
    }
    return;
}
int main(){
    cin>>k>>n;
    for(int i=1;i<=n;i++){
        cin>>x;
        need[x].push(i);//类似桶排方式存储需求
        juice.push(x);//果汁加入顺序队列
    }
    while(now_juice.size()<k&&!juice.empty()){//安排满k台干净的榨汁机
	need[juice.front()].pop();
        now_juice.insert(juice.front());//当前所需求的果汁加入榨汁机
        juice.pop();
    }
    while(!juice.empty())//还有果汁需求
        f(juice.front());
    cout<<ans;
    return 0;
}
```

---

## 作者：刘嘉琦 (赞：0)

这题是一道贪心，贪心方案也比较能猜到：在当前 $K$ 台榨汁机中，设第 $i$ 台刚榨过果汁种类为 $k_i$，则清洗第 $x$ 台使得 $k_x$ 出现在所有 $k_i$ 在 $X$ 序列（客人点单序列）中的最后。简单地说，就是哪台刚榨的果汁之后最后再次被点单，就洗哪台。

其实可以感性理解：如果选择之后更早要榨的果汁所在榨汁机进行清洗，则清洗的次数一定不会更少（假如第 $x$ 台仍未被清洗则次数不变，否则次数多一次）。或许有其他理解方式，但是大概都是用反证法，可以自己画图手动模拟。

我们可以发现 $N \le 100$，这说明我们只需要用模拟就能过。

我的方法是用 ```queue``` 记录每种果汁先后出现的时刻，每次遍历每台榨汁机，选出出现时刻最晚的果汁，进行清洗。

代码（有注释）：

```cpp
#include <cstdio>
#include <cstring>
#include <queue>

const int N = 105, K = 15;
// m[i]表示第i台榨汁机刚榨过的果汁
// pos[i]表示果汁i所在榨汁机的编号，若不是刚被榨就为0
int k, n, a[N], m[K] = {0}, pos[N];
std::queue<int> t[N]; // 使用queue存储出现时刻

int main()
{
	while (~scanf("%d %d", &k, &n)) {
		fill(t + 1, t + n + 1, std::queue<int>()); // 多组数据需清空queue
		for (int i = 1; i <= n; i++) {
			scanf("%d", &a[i]);
			t[a[i]].push(i);
		}
		for (int i = 1; i <= N - 5; i++)
			t[a[i]].push(114514); // 防止出现果汁在后面都没有被点的情况，这时当然可以直接选它清洗
		memset(pos, 0, sizeof pos);
		int ans = 0;
		for (int i = 1, cur = 0; i <= n; i++) {
			if (!pos[a[i]]) {
				if (cur != k) // 此时还有没榨过东西的榨汁机，直接用
					m[++cur] = a[i], pos[a[i]] = cur; 	
				else {
					int id = 0;
					for (int j = 1; j <= k; j++)
						if (!id || t[m[id]].front() < t[m[j]].front())
							id = j;
					ans++, pos[m[id]] = 0, m[id] = a[i], pos[a[i]] = id;
				}
			}
			t[a[i]].pop(); // 这回榨的果汁需弹出这一时刻
		}
		printf("%d\n", ans);
	}
	return 0;
} 
```

---


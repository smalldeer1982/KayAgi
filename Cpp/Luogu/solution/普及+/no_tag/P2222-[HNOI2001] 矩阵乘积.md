# [HNOI2001] 矩阵乘积

## 题目描述

已知矩阵：

$$A_{m\times n}=\begin{bmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\ a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\ \vdots & \vdots & \ddots & \vdots\\ a_{m,1} & a_{m,2} & \cdots &a_{m,n} \end{bmatrix} ,B_{n\times p}=\begin{bmatrix}b_{1,1} & b_{1,2} & \cdots & b_{1,p}\\ b_{2,1} & b_{2,2} & \cdots & b_{2,p} \\ \vdots & \vdots & \ddots & \vdots\\ b_{n,1} & b_{n,2} & \cdots &b_{n,q} \end{bmatrix}$$

当矩阵 $A$ 的列数与矩阵 $B$ 的行数相同时，则 $A$ 与 $B$ 可以相乘，其乘积为一个 $m\times p$ 的矩阵 $D$：

$$D_{m\times p}=\begin{bmatrix} d_{1,1} & d_{1,2} & \cdots & d_{1,p}\\ d_{2,1} & d_{2,2} & \cdots & d_{2,p} \\ \vdots & \vdots & \ddots & \vdots\\ d_{m,1} & d_{m,2} & \cdots & d_{m,p}\end{bmatrix}$$

其中 $d_{i,j}=\sum^n_{k=1} a_{i,k} \times b_{k,j}$，简记为 $D=A\times B$。

现已知三个矩阵 $A,B,C$，这三个矩阵大多数元素为 $0$，我们把这种矩阵称为稀疏矩阵。因此，我们采用三元组 $i,j,a$ 来表示矩阵的第 $i$ 行第 $j$ 列的值为 $a$ 其余未列出的元素均为 $0$；在计算机中，我们仅给出非零元素的三元组，而且使用行优先法给出稀疏矩阵的三元组，首先是第一行按列给出，然后是第二行按列给出……

例如，矩阵：$\begin{bmatrix}1&0&0&0\\0&0&2&-1\\0&1&2&3\\0&0&0&0\end{bmatrix}$ 那么，矩阵的三元组表示为：

```plain
1 1 1
2 3 2
2 4 -1
3 2 1 
3 3 2
3 4 3
```

你的任务就是：计算矩阵 $D=A\times B\times C$。

## 说明/提示

#### 数据规模与约定
对于全部的测试点，保证 $1\le m,n,o,p\le 6\times 10^3$，三元数组的总个数不大于 $6\times 10^3$。数据之间用空格分开。

## 样例 #1

### 输入

```
1 2                       
3 4 2 3
1 1 3
1 4 5
2 2 1
3 1 2

1 2 2
2 1 1
3 1 2
3 2 4

1 2 2
1 3 3
2 1 1
2 2 2
```

### 输出

```
12```

# 题解

## 作者：Fearliciz (赞：54)

前言：

实际上我写这篇题解就是为了纪念这个时刻。

$$2022.2.22-22:22:22$$

此外，这道题为 [$P2222$](https://www.luogu.com.cn/problem/P2222)，今天是星期二，廿二。



------------

朴素的算法的空间是 $3nm$ 在此题的空间下是肯定不够的，所以我们便不能使用二维数组。

显然：

$$P_{x,y}=\sum_{i=1}^{n}a_{x,i}\times b_{i,y}$$

$$D_{x,y}=\sum_{i = 1}^{n}\sum_{j=1}^{o}a_{x,i}\times b_{i,j}\times c_{j,y} $$


所以 $P_{x,y}$ 只关系到 $A$ 矩阵的 $x$ 行和 $B$ 矩阵 的 $y$ 列。

并且 $D_{x,y}$ 只关系到 $A$ 矩阵的 $x$ 行和 $C$ 矩阵 的 $y$ 列。

可是前文说明了不可以使用二维数组，那么我们就将其优化成一维。

我们推出的答案包括因式 $b_{i,j}$，由于 $B$ 矩阵中的所有元素都会参与运算，又因为矩阵为稀疏矩阵，所以我们可以直接用一维数组将 $B$ 矩阵的数存储起来。

再将二维形式中的剩余部分转换为一维。

最后可以得到答案的一维形式：

$$D_{x,y}=\sum_{i=1}^{cnt}A_{cx_i}\times ck_i\times C_{cy_i}$$

注：$cnt$ 为矩阵 $B$ 中的给定的元素个数。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int NR=6010;
int x,y,m,n,o,p,ans,cnt;
int i,j,k,ti,tj,tk;
int A[NR],C[NR];
int cx[NR],cy[NR],ck[NR];

int main()
{
	cin>>x>>y>>m>>n>>o>>p;
	cin>>i>>j>>k;
	do{ //试了几次，发现 while 不行
		if(i==x) A[j]=k;
		ti=i,tj=j,tk=k; //存储行、列、值
		cin>>i>>j>>k;
	}while(i>=ti&&(i!=ti||j>tj));
	do{
		++cnt;
		cx[cnt]=i,cy[cnt]=j,ck[cnt]=k;
		ti=i,tj=j,tk=k;
		cin>>i>>j>>k;
	}while(i>=ti&&(i!=ti||j>tj));
	do{ if(j==y) C[i]=k; }while(cin>>i>>j>>k); 
	for(int i=1;i<=cnt;i++) ans+=A[cx[i]]*ck[i]*C[cy[i]];
	cout<<ans;
	return 0;
}
```


---

## 作者：彼溦岸颺 (赞：13)

## 矩阵乘法！！！
### Hello!我是萌新！在教练考矩阵前做的这一题，既然题解这么少，那我就来凑个热闹！
------------
### 这题考矩阵的乘法，还不了解矩阵之间如何相乘的同学可以先看看百度如何做矩阵的乘法！
### 假如你已经会了矩阵的乘法，不妨先想一想通过暴力手段强乘一通，显然仅计算的话时间复杂度是O(6*(nm))，我们的洛谷神机也许可以跑得过去，但是你的空间复杂度是O(3*(nm)),妥妥的炸空间啊怎么办？
------------
### 别急，车到山前必有路。不妨先想想矩阵乘法的性质，当两个矩阵做乘法时，新生成的矩阵的行数与第一个的行数相同，列数与第二个矩阵的列数相同（矩阵不具有交换律）。所以，本题目中三个矩阵相乘所生成的新矩阵的行数与A的行数相同，与C的列数相同。那么在新矩阵中，所查询的(x,y),x代表的行数从始至终都没有改变，这不就消去了一个维度吗？时间空间大大优化！同学们可能还会对输出有问题，下面，我附上代码讲述：
```cpp
#include<cstdio>
int x,y,m,n,o,p;
int i,j,c,i1,j1,c1;
int a[6005],b[6005];//这里我采取滚动数组的方式又删去了一个数组
int main(){
	scanf("%d%d%d%d%d%d%d%d%d",&x,&y,&m,&n,&o,&p,&i,&j,&c);
	while(true){
		if(i==x)a[j]+=c;
		i1=i;
		j1=j;
		c1=c;
		scanf("%d%d%d",&i,&j,&c);
		if(i<i1||(i==i1&&j<=j1))break;
        //由于本题目的输入非常规律，如果更换了矩阵一定会有行列的变化，这个变化的趋势只会小于或等于x,y（否则结果为0没意义啊），因此大可抓住这个小漏洞，进行更换矩阵输入的判断！
	}
	while(true){
		b[j]+=a[i]*c;
		i1=i;
		j1=j;
		c1=c;
		scanf("%d%d%d",&i,&j,&c);
		if(i<i1||(i==i1&&j<=j1))break;
	}
	for(int k=1;k<=6000;k++){
		a[k]=b[k];
		b[k]=0;
	}//滚动数组循环使用，你也可以用cstring底下的memcpy函数和memset函数进行操作，我比较懒哈！
	while(true){
		if(j==y)b[y]+=a[i]*c;
		i1=i;
		j1=j;
		c1=c;
		scanf("%d%d%d",&i,&j,&c);
		if(i<i1||(i==i1&&j<=j1))break;
	}
	printf("%d",b[y]);
	return 0;
}
```
### 有的细心的同学可能发现了，前面的输入没问题，但最后的一行输入完后不就卡死了吗？按理说是的，但是所有的评测都是以文件的形式输入的，所以在你的所有输入完后，是会默认添加一个文件尾表示结束，因此不会有任何问题（你交给洛谷神机测一下不就知道了咩？）。如果同学们想独自运行一下的话可手动加入文件尾：在所有你想输入的输入完后按下回车，再打出(Ctrl+z),再打出一个回车，就大功告成啦！
## 保佑我模拟赛顺利！！！！！

---

## 作者：zqy1018 (赞：11)

三元组矩阵乘法...

因为指定了要求的值的位置，所以可以在矩阵A\*B的过程中，只保留A的x一行上的值，然后用B中的值去乘。

对B\*C也如此。

这样矩阵乘法的复杂度就会远低于O(n^3)，就做完了。

复杂度大概是O(n^2)?

实际上这题更麻烦的是读入...

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cctype>
using namespace std;
typedef long long ll;
int x,y,m,n,o,p;
int Am[6005]={0},Bm[6005]={0};
char input[10005];
int main(){
    int i,j,u,v,val;
    scanf("%d%d%d%d%d%d",&x,&y,&m,&n,&o,&p);
    fgets(input,10000,stdin);
    for(;;){
        fgets(input,10000,stdin);
        if(!isdigit(input[0]))break;
        sscanf(input,"%d%d%d",&u,&v,&val);
        if(u==x)Am[v]=val;
    }
    for(;;){
        fgets(input,10000,stdin);
        if(!isdigit(input[0]))break;
        sscanf(input,"%d%d%d",&u,&v,&val);
        Bm[v]+=Am[u]*val;
    }
    memcpy(Am,Bm,sizeof(Bm));
    memset(Bm,0,sizeof(Bm));
    while(~scanf("%d%d%d",&u,&v,&val))
        Bm[v]+=Am[u]*val;
    printf("%d\n",Bm[y]);
    return 0;
}
```

---

## 作者：囧仙 (赞：6)

想到了这道题的两个解法，来发一下题解

我们假设所有矩阵都是 $n \times n$ 的，因为就算不是我们也可以通过补 $0$ 变为 $n \times n$

- **稀疏矩阵快速乘法**

  稀疏矩阵的定义题目中已经给出了，也就是只有 $m$ 个点有值，剩余点都是 $0$ 的矩阵（$m$ 与 $n$ 同阶）
  
  那么考虑计算 $A \times B = C$，$C_{i,j} = \sum\limits_{k = 1}^n A_{i,k} \times B_{k,j} $
  
  显然只有 $A_{i,k},B_{k,j}$ 都有值的时候，计算它才是有必要的，否则贡献为 $0$
  
  所以现在就是要想办法去除无用计算
  
  考虑对第 $i$ 行开一个 `vector`，记录这一行那些位置有值，值都是多少
  
  对第 $j$ 行也是类似操作，记录这一列那些位置有值，值都是多少
  
  然后我们用类似归并的顺序来计算 $C_{i,j}$
  
  分析一下复杂度，$A$ 的第 $i$ 行在乘法过程中会被用 $n$ 次，$B$ 的第 $j$ 列在乘法过程中也会被用 $n$ 次
  
  所以复杂度就是：$\sum\limits_{i = 1} ^ n cA_i \times n + \sum\limits_{j = 1} ^ n cB_j \times n$
  
  $cA_i$ 表示 $A$ 矩阵第 $i$ 行有值的数量，$cB_j$ 表示 $B$ 矩阵第 $j$ 列有值的数量
  
  显然 $\sum\limits_{i = 1} ^ n cA_i = m$，$\sum\limits_{j = 1} ^ n cB_j = m$，所以在 $n,m$ 同阶的情况下，我们得到了一个 $n ^ 2$ 矩阵乘法
  
  但缺陷在于，两个稀疏矩阵相乘后，结果很可能不是稀疏矩阵了
  
- **单点求矩阵乘法结果**

  当我们在两个矩阵相乘的结果上，只求一个点的点值的话，那么显然不需要求出所有点值
  
  实际上，如果我们要求 $(x,y)$ 的值的话，只需要将 $A$ 矩阵的第 $x$ 行与 $B$ 矩阵的第 $y$ 列相乘就可以了
  
  进一步得，我们实际上只需要知道 $A$ 矩阵的第 $x$ 行和 $B$ 矩阵的第 $y$ 列就可以了
  
  上面这句话是什么意思呢？看下一段你就知道了~
  
- **本题的加强版**

   就是在本题的题意下，把 $3$ 个矩阵相乘，改为 $8$ 个矩阵相乘，数据范围不变（当然时限、空限可能得略微开大）
   
   显然这样你直接套上面两个做法都不行了，需要结合起来
   
   设 $8$ 个矩阵分别为 $A_0,A_1,A_2,A_3,A_4,A_5,A_6,A_7$，结果为 $D$
   
   那么 $D = A_0 \times A_1 \times A_2 \times A_3 \times A_4 \times A_5 \times A_6 \times A_7$
   
   根据矩阵结合律，得到
   
   $$D = ((A_0 \times A_1) \times (A_2 \times A_3)) \times ((A_4 \times A_5) \times (A_6 \times A_7))$$
   
   $A_0 \times A_1$，$A_2 \times A_3$，$A_4 \times A_5$，$A_6 \times A_7$，都是两个稀疏矩阵相乘，可以直接 $n ^ 2$ 得出答案，我们设结果为 $B_0,B_1,B_2,B_3$
   
   $D = (B_0 \times B_1) \times (B_2 \times B_3)$
   
   再次设 $B_0 \times B_1 = C_0,B_2 \times B_3 = C_1$
   
   因为我们要求 $D_{x,y}$，所以我们只需要知道 $C_0$ 的第 $x$ 行和 $C_1$ 的第 $y$ 列就可以了
   
   而 $C_0$ 的第 $x$ 行，$C_1$ 的第 $y$ 列，朴素计算就是 $n ^ 2$ 的
   
   最后把它们 $O(n)$ 地乘起来，就得到答案了
   
   总复杂度还是 $O(n ^ 2)$ 的，非常的优秀
   
   再多我就不会了，但是感觉这个 $8$ 矩阵相乘也挺好了
   
- **本题题解**

   蛤？$8$ 矩阵相乘你会了，$3$ 矩阵相乘你不会？
   
   ~~但是因为这题读入太迷惑了，所以我没有去写过~~
   
   读入的话可以去看隔壁的题解，这里就不讲啦

---

## 作者：dlzlj_2010 (赞：3)

一种慢一些但是想起来比较容易一些的解法。

我们记 $E_{m\times o}=A\times B$，则 
$$D_{x,y}=\sum^{o}_{i=1}E_{x,i}\times C_{i,y}=\sum^{o}_{i=1}(\sum_{j=1}^{n}A_{x,j}\times B_{j,i})\times C_{i,y}=\sum^{o}_{i=1}\sum_{j=1}^{n}A_{x,j}\times B_{j,i}\times C_{i,y}$$

但是直接计算的话明显会 MLE，考虑如何优化空间。

-  注意到计算过程中只会访问到 $A$ 的第 $x$ 行和 $C$ 的第 $y$ 列，因此将 $A$ 和 $C$ 采用一维数组存储。
-  由于整个 $B$ 都要被访问，所以不能采用一维数组存储。将 $B$ 的三元组一起存放在一维数组里，使用时二分查找出对应的三元组即可。


### code:

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int>pii;
typedef pair<pii,int>piii;

const int N=6e3+5;
int m,n,o,p;
int A[N],C[N];
piii B[N];
int idx;
int x,y;
signed main(){
	scanf("%d%d",&x,&y);
	scanf("%d%d%d%d",&m,&n,&o,&p);
	int i,j,k,ti=0,tj=0;
	scanf("%d%d%d",&i,&j,&k);
	do{//输入，同其他题解
		ti=i,tj=j;
		if(i==x)A[j]=k;
		scanf("%d%d%d",&i,&j,&k);
	}while(i>=ti&&(i!=ti||j>tj));
	do{
		ti=i,tj=j;
		B[++idx]={{i,j},k};
		scanf("%d%d%d",&i,&j,&k);
	}while(i>=ti&&(i!=ti||j>tj));	
	do{
		if(j==y)C[i]=k;
	}while(~scanf("%d%d%d",&i,&j,&k));
	
	int ans=0;
	for(int i=1;i<=o;i++){
		for(int j=1;j<=n;j++){
			piii t={{j,i},-1};
			piii tt=*lower_bound(B+1,B+1+idx,t);//二分查找出B[j][i]
			if(j!=tt.first.first||i!=tt.first.second)continue;
			//如果对应下标不等就说明没存储B[j][i],也就是说B[j][i]=0
			ans+=A[j]*tt.second*C[i];
		}
	}
	printf("%d",ans);
    return 0;
}
```

---

## 作者：qiuqiuqzm (赞：2)

# P2222 题解
[题目传送门](https://www.luogu.com.cn/problem/P2222)

## 题目大意
给定三个矩阵 $A,B,C$，大小分别为 $m\times n,n\times o,o\times p$，$D=A\times B\times C$。求 $D_{x,y}$，即为 $D$ 的第 $x$ 行第 $y$ 列的元素的值。

## 分析
- 先考虑暴力算法，一看数据范围，别说会不会 T 了，连开一个二维数组都费劲，更何况是 $3$ 个(~~喜提 20pts~~)。

- 我们再仔细看下题目，发现我们只要求 $D$ 的第 $x$ 行第 $y$ 列的值。若 $A\times B=E$，那么 $D=E\times C$，所以 $D_{x,y}=\sum_{i=1}^{o} E_{x,i}\times C_{i,y}$。而 $E_{x,y}=\sum_{i=1}^{m} A_{x,i}\times B_{i,y}$。$E$ 只要存 $x$ 这一行就行，所以 $A$ 也只需要存 $x$ 这一行，$B$ 要全部存下来，而 $C$ 只要存第 $y$ 列。

- 但是把 $B$ 数组全部存下来肯定不行，所以我们只能在读入 $B$ 时直接计算，而读入 $C$ 时也可以这样。

- 谈到读入，本题的读入是一个难点。我们发现，本题输入非常有规律。我们把上一次的坐标设为 $lastx,lasty$，这一次的就是 $x,y$。那么只有 $lastx>x$ 或者 $lastx=x$ 且 $lasty>=y$ 时 **（这里一点要加等号）**，这两个数才可能在同一个矩阵中，否则我们就把它归到下一个矩阵中。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,o,p,tx,ty;
int a[6001],b,c,Mul[6001],ans;
int x,y,num,now=1,lastx,lasty;
int main()
{
	ios::sync_with_stdio(0);
	cin>>tx>>ty;
	cin>>n>>m>>o>>p;
	while(cin>>x>>y>>num)
	{
		if(lastx>x||(lasty>=y&&lastx==x))
			now++; //归到下一个矩阵
		lastx=x;
		lasty=y;
		if(now==1&&x==tx)
			a[y]=num; //a只要存第x行
		else if(now==2)
		{
			b=num;
			Mul[y]+=a[x]*b; //计算E
		}
		else if(y==ty) //c只要存第y列
		{
			c=num;
			ans+=Mul[x]*c; //计算答案
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_lyx111 (赞：2)

# P2222 [HNOI2001]矩阵乘积

[link](https://www.luogu.com.cn/problem/P2222)

## 题意

给定三个**稀疏矩阵** $A,B,C$，大小分别为 $m\times n,n\times o,o\times p$，设矩阵 $D=A\times B\times C$，则对给定的 $x,y$，输出 $D_{x,y}$ 的值。

$m,n,o,p\le 6\times 10^3,1\le x\le m,1\le y\le p$，稀疏矩阵 $A,B,C$ 中不为 $0$ 的数的个数不超过 $6\times 10^3$。

时间限制：$1.00\ \text{s}$，空间限制：$125\ \text{MB}$。

## 分析

显然的，我们可以得到一个式子：

$$D_{x,y}=\sum_{i=1}^oC_{i,y}\times \sum_{j=1}^nA_{x,j}\times B_{j,i}$$

直接计算空间是 $O(n^2)$（ 常数是 $3$ ），显然无法接受。

发现对于矩阵 $A,C$ 我们只需要知道 $A$ 的第 $x$ 行和 $C$ 的第 $y$ 列就可以了，所以我们设：

- $A_{i}$ 表示 $A$ 的第 $x$ 行第 $i$ 列的数的值。

- $cnt$ 表示 $B$ 的所有非 $0$ 的数的个数。

- $Bi_{i}$ 和 $Bj_{i}$ 表示 $B$ 的第 $i$ 个非 $0$ 的数的行和列。

- $Ba_{i}$ 表示 $B$ 的第 $i$ 个非 $0$ 的数的值。

- $C_i$ 表示 $C$ 的第 $i$ 行第 $y$ 列的数的值。

将上面的式子转化一下求和顺序就可以得到答案

$$D_{x,y}=\sum_{i=1}^{cnt}A_{Bi_i}\times Ba_i\times C_{Bj_i}$$

下面来讲讲**读入**的问题。

首先，因为是用行优先法给出稀疏矩阵的三元组，所以对于相邻的两次读入 $i_1,j_1,a_1$ 和 $i_2,j_2,a_2$，只有当 $i_1=i_2$ 且 $j_1,j_2$ 或 $i_1<i_2$ 时，这两个不为 $0$ 的数才**有可能**在同一个矩阵内。

仔细想一想可以发现：如果当 $i_1=i_2$ 且 $j_1,j_2$ 或 $i_1<i_2$ 时，这两个这两个不为 $0$ 的数不在同一个矩阵内，那么 $i_2,j_2,a_2$ 这个非 $0$ 的数一定不会对答案产生任何贡献，所以可以**不妨假设这两个数在同一矩阵内**。

注意：

- 在读入矩阵 $C$ 时，判断是否读入完要用 `while(cin>>i>>j>>a)` 不能用 `while(scanf("%d%d%lld",&i,&j,&a))`，否则会 TLE。

- 要使用 `do {...} while(...)` 循环读入，用 `while(...){...}` 会 TLE。

## 代码

~~~cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN=6e3+10;

int x,y,m,n,o,p; //含义如题 

long long A[MAXN]; //矩阵 A 的第 x 行 

int cnt;  //B 的所有非 0 的数的个数 
int Bi[MAXN],Bj[MAXN]; //B 的所有非 0 的数的位置 
long long Ba[MAXN]; //B 的所有非 0 的数的数值大小 

long long C[MAXN]; //矩阵 C 的第 y 列 

long long ans; //答案即 D[x][y] 
int main()
{
	scanf("%d%d%d%d%d%d",&x,&y,&m,&n,&o,&p);
	
	int i,_i,j,_j;
	long long a,_a;
	scanf("%d%d%lld",&i,&j,&a);
	
	do
	{ 
		if(i==x) A[j]=a;
		_i=i; _j=j; _a=a;
		scanf("%d%d%lld",&i,&j,&a);
	} while((i==_i&&j>_j)||i>_i); //read A 
	
	do
	{
		cnt++;
		Bi[cnt]=i; Bj[cnt]=j; Ba[cnt]=a;
		_i=i; _j=j; _a=a;
		scanf("%d%d%lld",&i,&j,&a);
	} while((i==_i&&j>_j)||i>_i); //read B 
	
	do
	{
		if(j==y) C[i]=a;
	} while(cin>>i>>j>>a); //read C 
	
	
	for(int i=1;i<=cnt;i++)
		ans+=A[Bi[i]]*Ba[i]*C[Bj[i]]; //按式子计算 
	
	
	printf("%lld",ans);
	return 0;
}
~~~

---

## 作者：0x3F (赞：2)

首先，看一看空间限制，哇，$125\operatorname M$，别说三个二维数组了，一个都够呛。

那还怎么乘呢？

由于我们只需要求 $(x, y)$ 处的值，也就是求 

$$\sum_{i=1}^{m}\sum_{j=1}^{o}A_{x, i} \times B_{i, j} \times C_{j, y}$$

说明什么？说明 $A$ 中只有第 $x$ 行是有用的，$C$ 中只有第 $y$ 列是有用的。

但是要把存储下来不是还要爆空间吗？

没事，不是稀疏矩阵吗？总元素个数不会超过 $6 \times 10^3$，全存下来不就完事了吗？

所以最终答案即为：

$$\sum_{i=1}^{B\texttt{中的元素个数}}A_{X_i} \times Z_i \times C_{Y_i}$$

（$X_i, Y_i, Z_i$ 分别表示第 $i$ 个元素的行，列，和值）

输入参考第二篇题解。

```cpp
#include <bits/stdc++.h>
#define _ 6010
using namespace std;
int x, y, u, v, w, uu, vv, ww;
int A[_];
int cB, xB[_], yB[_], zB[_];
int C[_];
int ans;
int main() {
	scanf("%d%d%d%d%d%d", &x, &y, &u, &u, &u, &u);
	scanf("%d%d%d", &u, &v, &w);
	do {
		if (u == x) A[v] = w;
		uu = u;
		vv = v;
		ww = w;
		scanf("%d%d%d", &u, &v, &w);
	} while (u >= uu && (u != uu || v > vv));
	do {
		cB++;
		xB[cB] = u;
		yB[cB] = v;
		zB[cB] = w;
		uu = u;
		vv = v;
		ww = w;
		scanf("%d%d%d", &u, &v, &w);
	} while (u >= uu && (u != uu || v > vv));
	do {
		if (v == y) C[u] = w;
		uu = u;
		vv = v;
		ww = w;
	} while (~scanf("%d%d%d", &u, &v, &w));
	for (int i = 1; i <= cB; i++) {
		ans += A[xB[i]] * zB[i] * C[yB[i]];
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：rq_kyz (赞：0)

# 【题解】 P2222 [HNOI2001] 矩阵乘积

### 传送门

[P2222 [HNOI2001] 矩阵乘积](https://www.luogu.com.cn/problem/P2222)

---

### 题意

现有三个矩阵，求三个矩阵依次相乘后的结果矩阵的第 $x$ 行第 $y$ 列的数字。

---

### 分析

本题暴力做法 $O(n^3)$，毫无疑问的会炸。

这里我们要注意到矩阵乘法的特殊性。若 $A\times B=D$，则 $d_{i,j}=\sum_{k=1}^na_{i,k}\times b_{k,j}$，这是题目告诉我们的。所以我们可以发现，若只要求计算出 $D$ 的第 $x$ 行第 $y$ 列上的数字，只需要 $A$ 的第 $x$ 行和 $B$ 的第 $y$ 列。

本题并不是两个矩阵相乘，而是三个矩阵。但是仔细一想，发现其实区别不大。$A\times B\times C=D$，要求结果的第 $x$ 行第 $y$ 列，我们需要的是 $A$ 的第 $x$ 行、$B$ 的全部以及 $C$ 的第 $y$ 列（这个很容易理解，请读者自行推算）。但是如果把整个 $B$ 都存储下来明显空间会炸，所以我们可以在读入时就直接计算了，不仅节省空间还顺便把时间给省了。

时间复杂度：$O(n)$。

空间复杂度：$O(n)$。

本题还没完，因为~~最恶心的其实是输入~~。我们可以从另一个角度解决输入。因为本题的矩阵输入法是行优先法，所以同一个矩阵一定是一行一行输入，同一行再一列一列输入。当我们发现有输入矛盾时，就表明当前矩阵已经输入完毕。如下面的这组例子：

```cpp
i1 j1 a1
i2 j2 a2
```

如果这两个三元组满足 ```i1>i2 || (i1==i2 && j1>j2)```，则它们为同一个矩阵，否则为不同的矩阵。

---

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll a[6001],b[6001];
int main(){
	ll x,y,m,n,o,p;
	scanf("%lld%lld%lld%lld%lld%lld",&x,&y,&m,&n,&o,&p);
	ll i,j,k,i1=0,j1=0,k1=0;
	scanf("%lld%lld%lld",&i,&j,&k);
	while(i>i1 || (i==i1 && j>j1)){//矩阵A输入
		if(i==x)
			a[j]=k;//记录
		i1=i;
		j1=j;
		k1=k;
		scanf("%lld%lld%lld",&i,&j,&k);
	}
	i1=0;
	j1=0;
	k1=0;
	while(i>i1 || j>j1){//矩阵B输入
		b[j]+=a[i]*k;//输入时计算
		i1=i;
		j1=j;
		k1=k;
		scanf("%lld%lld%lld",&i,&j,&k);
	}
	ll sum=0;
	do{//矩阵C输入
		if(j==y)
			sum+=b[i]*k;//计算again
	}while(scanf("%lld%lld%lld",&i,&j,&k)!=EOF);
	printf("%lld",sum);
	return 0;
}
```

另附：精美压行代码一份。

```cpp
#include<ios>
#define S scanf("%d%d%d",&i,&j,&k)
int x,y,a[6001],b[6001],i,j,k,o,p,s;main(){for(S,x=i,y=j,S,S;i>o||i==o&&j>p;a[j]+=(i==x)*k,o=i,p=j,S);for(;b[j]+=a[i]*k,o=i,p=j,S,i>o||i==o&&j>p;);for(;s+=(j==y)*b[i]*k,S+1;);printf("%d",s);}
```

---


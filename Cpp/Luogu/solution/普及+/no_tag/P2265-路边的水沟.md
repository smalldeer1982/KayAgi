# 路边的水沟

## 题目背景

某市有一个巨大的水沟网络，可以近似看成一个 $n \times m$ 的矩形网格，网格的每个格点都安装了闸门，我们将从水沟网络右下角的闸门到左上角的闸门的一条路径称为水流。


## 题目描述

现给定水沟网的长和宽，求该水沟网中所有只包含向左和向上移动的水流数量。


## 说明/提示

对于 $30\%$ 的数据，$1 \leq m,n \leq 10$。

对于 $50\%$ 的数据，$1 \leq m,n \leq 1,000$。

对于 $80\%$ 的数据，$1 \leq m,n \leq 50,000$。

对于 $100\%$ 的数据，$1 \leq m,n \leq 1,000,000$。

## 样例 #1

### 输入

```
3 5```

### 输出

```
56```

# 题解

## 作者：Ginger_he (赞：12)

# 题目描述
一个 $n\times m$ 的矩阵，求从右下角走到左上角的方案数，每步只能向左或向上走。
# 引入
## 逆元
### 1.什么是逆元？
若有线性同余方程 $ax\equiv1\pmod{b}$，则 $x$ 称为 $a\bmod b$ 的逆元，记作 $x^{-1}$。
### 2.逆元怎么求？
由逆元的定义有：$ax\equiv1\pmod{b}$  
由费马小定理有：$ax\equiv{a^{b-1}}\pmod{b}$  
$\therefore x\equiv{a^{b-2}}\pmod{b}$  
注意：求逆元还可以用[扩展欧几里得法](https://www.luogu.com.cn/problem/P1082)。
### 3.逆元的基本应用
$x\div y\equiv{x\times y^{-1}\equiv{x\times y^{p-2}\pmod{p}}}$
## 组合数
### 1.什么是组合数？
从 $n$ 个不同元素中取出 $m(m\leq n)$ 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的组合数。用符号 $\dbinom{n}{m}$ 来表示。
### 2.组合数如何求？
- **模拟**：
按照组合数的定义暴力计算即可，但是这样肯定会爆 long long，最多过 $n\leq12$ 的数据。  
- **杨辉三角**：
观察下面的图片，若把第 $i$ 行第 $j$ 个数记为 $f(i-1,j-1)$，则 $\dbinom{i}{j}=f(i,j)$，利用这种递推的思想，我们可以过掉 $n\leq100$ 的数据。

![](https://cdn.luogu.com.cn/upload/image_hosting/mrv9eka6.png)  
- **逆元求组合数**：
运用上述知识，对于一个组合数 $\dbinom{p}{q}=\dfrac{\begin{matrix} \prod_{i=p-q+1}^p i \end{matrix}}{\begin{matrix} \prod_{i=1}^p i \end{matrix}}$，分数线上方的数直接相乘，分数线下方的数都乘其逆元即可。
# 题解
## 分析
回归本题，因为每一步只能向左或向上走，所以总步数为 $(1,1)$ 到 $(n,m)$ 的曼哈顿距离，即总的步数为定值 $(n+m)$。接下来考虑**从这 $(n+m)$ 步中任意选 $m$ 步向左**，根据组合数的定义，答案为 $\dbinom{n+m}{m}$。然后组合数用逆元求值即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
long long n,m,ans=1;
long long quickpow(long long a,long long b)//快速幂
{
	long long res=1;
	while(b)
	{
		if(b&1)
			res=res*a%mod;
		b>>=1;
		a=a*a%mod;
	}
	return res;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(long long i=n+1;i<=n+m;i++)
		ans=ans*i%mod;//分数线上方直接乘
	for(long long i=2;i<=m;i++)
		ans=ans*quickpow(i,mod-2)%mod;//分数线下方乘逆元
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：hsfzLZH1 (赞：6)

此题所求是从m+n个单位长度的路径中选取m个向上的操作，所以答案为C(m+n,m)，将这个式子展开如下：

C(m+n,m)=(m+n)!/m!/n!=((m+1)\*(m+2)\*...\*(m+n))/(1\*2\*...\*n)

因为此题有取模操作，所以我们需要使用逆元的思想。逆元的定义是：在模p（p是质数）的意义下，a/b==a\*inv(b)(mod p)，则我们称inv(b)是b在模p意义下的逆元，易证inv(b)在p是质数的情况下是惟一的。

逆元有线性求法（O(N)的时间求1...N的全部逆元），也有用扩展欧几里得算法的解法，我在这里将要介绍的是时间复杂度为O(log p)的做法。

通过逆元的性质inv(a)==a^(p-2)(mod p)，我们可以用快速幂，即O(log p)的时间复杂度计算。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const long long mod=1e9+7;//取模的数
long long n,m,ans1=1,ans2=1;//ans1是分子，ans2是分母
long long pow(long long a,long long n)//快速幂
{
    long long ret=1ll,x=a;
    while(n)
    {
        if(n&1)ret=(ret*x)%mod;
        x=(x*x)%mod;n>>=1;
    }
    return ret;
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=m+1;i<=n+m;i++)ans1=(ans1*i)%mod;//求分子的值
    for(int i=2;i<=n;i++)ans2=(ans2*i)%mod;//求分母的值
    printf("%lld\n",ans1*pow(ans2,mod-2)%mod);//输出分子*分母的逆元，用这种方法只用计算一次逆元
    return 0;
}
```

---

## 作者：田大坑 (赞：3)

这一道题目是一道典型的数论题目，求组合数的题目……

看到这道题目时，我第一时间想到的是dp

先不考虑数据范围，写一个暴力再优化

60pts 代码
```
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int n,m,f[1001][1001];
int main()
{
	cin>>m>>n;
	n++,m++;
	f[n][m]=1;
	for(int i=n;i>=1;i--)
	for(int j=m;j>=1;j--)
	{
		f[i][j]=max(f[i+1][j]+f[i][j+1],f[i][j]);
		f[i][j]%=mod;
	}
	cout<<f[1][1];
}
```
思路和那道过河卒一样，但是很明显超时了

在优化的时候，突然想到的思路，既然总路程是两点的曼哈顿距离，也就是说，不论他每一步怎么走，最后的距离都是n+m，对于每一步，都可以向上或者向左，那么只要知道每一步的发生顺序就可以了。

那么如何知道呢？组合数告诉了我们一切。

组合数是用来求有序的组合的个数的，无论怎么走，他移动最终的竖直距离和水平距离不变，用组合数求每一步向上是什么时候发生就可以了，也就是求向上和向左的的不同组合

C（n,m+n）=C(m,n+m)

比如 左左上上，上左上左等等

可以用暴力和这个对拍一下，以保证安全

但是单纯的组合数只有30pts
```
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int gcd(long long a,long long b)
{
	return !b?a:gcd(b,a%b);
}
int main()
{
	int n,m;
	cin>>n>>m;
	long long ans1=1,ans2=1;
	if(n>m)
	swap(n,m);
	int a=n,b=m+n;
	for(int k=1;k<=n;k++)
	{
		ans1*=b--;
		ans2*=a--;
		int x=gcd(ans1,ans2);
		ans1/=x;
		ans2/=x;
	}
	cout<<ans1/ans2;
}
```

再加上逆元就ok了

100pts 代码
```
#include<bits/stdc++.h>
#define ll long long//记得long long
#define mod 1000000007
using namespace std;
inline ll pow(ll a,ll n,ll p)
{
    ll ans=1;
    while(n)
    {
        if(n&1)
        ans=ans*a%p;
        a=a*a%p;
        n>>=1;
    }
    return ans;
} 
inline ll fm(ll a)
{
	return pow(a,mod-2,mod);
}
inline ll jc(ll x)
{
	ll ans=1;
	for(int i=2;i<=x;i++)
	{
		ans*=i;
		ans%=mod;
	}
	return ans;
}
ll c(ll a,ll b)
{
	return (((jc(b)%mod*fm(jc(a))%mod)%mod)*fm(jc(b-a))%mod);
}
int main()
{
	int n,m;
	cin>>n>>m;
	cout<<c(n,n+m);
}
```
不会逆元的可以去p3811看看

---

## 作者：pantw (赞：1)

比较简单的数学题。

打个表或者推一推，我们可以发现答案为

$C_{n+m}^{n} = {{n+m}\choose{n}} =\frac{(n+m)!}{n!m!}$

因为这个值很大所以我们不能直接除，要变成乘上逆元。

由于1000000007是质数所以可以直接用费马小定理。


```cpp
#include <cstdio>
#define mod 1000000007
#define Lovelive long long
Lovelive fac(Lovelive n) { // 计算阶乘
    Lovelive ret = 1;
    for(Lovelive i = 1; i <= n; i++) ret = ret * i % mod;
    return ret;
}
Lovelive pow(Lovelive n, Lovelive p) { // 快速幂
    if(!p) return 1;
    Lovelive tmp = pow(n, p >> 1);
    if(p & 1) return tmp * tmp % mod * n % mod;
    else return tmp * tmp % mod;
}
Lovelive inv(Lovelive x) { // 计算 x 的逆元
    return pow(x, mod - 2);
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    printf("%d", (int) (fac(n+m)*inv(fac(n))%mod*inv(fac(m))%mod)); // 直接套式子
    return 0;
}
```

---

## 作者：ShineEternal (赞：1)


# [代码](https://blog.csdn.net/kkkksc03/article/details/83031831)
# 分析：
由题意推理得：

$C^{n}_{n+m}=\frac{(n+m)!}{n!m!}$

但是我们看一下数据范围：$n,m<=1000000$

妈呀，这样咋除呀。

这个时候我们就要引入一个东东：

## 乘法逆元

说白了一个数的乘法逆元就是他的倒数。。。

其他百度一下就行。

### 用乘法逆元有啥好处?

ans：可以再弄个费马小定理后用快速幂迅速解决。

## 那么快速幂是啥？

就比如说$3^9=3^8*3={3^2}^2*3*3^4$等等减少运算次数的，仍可百度。

那么主要思路就出来了：把推出的那个$C^{n}_{n+m}=\frac{(n+m)!}{n!m!}$的除号下面的部分转换为他的逆元，通过费马小定理写出幂的形式，然后用快速幂迅速求出。

---

## 作者：ModestCoder_ (赞：0)

啥都不用说了，直接上公式$C_{n+m}^{m}$

意义，：$n$个向下走的决策，$m$个向右走的决策，$(n+m)$个决策随机排列的方案数

就是$(n+m)$个决策中选出$m$个决策向右走，组合数就好了

然后，杨辉三角好像用不得，那就再来一个公式：$C_{m}^{n}=\frac{m!}{(m-n)!*n!}$

模数是质数，放心了，逆元一下就好了

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 2000010
#define LL long long
using namespace std;
const LL qy = 1000000007;
int n, m;
LL fac[maxn], inv[maxn];

LL ksm(LL n, LL k){
	if (!k) return 1;
	LL sum = ksm(n, k >> 1);
	sum = sum * sum % qy;
	if (k & 1) sum = sum * n % qy;
	return sum;
}

int main(){
	scanf("%d%d", &n, &m);
	fac[0] = 1;
	for (int i = 1; i<= n + m; ++i) fac[i] = fac[i - 1] * i % qy;
	inv[n + m] = ksm(fac[n + m], qy - 2);
	for (int i = n + m - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % qy;
	printf("%lld\n", fac[n + m] * inv[n] % qy * inv[m] % qy);
	return 0;
}
```


---

## 作者：连续和 (赞：0)

本题求C(m,m+n)=(m+1)/1\*(m+2)/2\*……\*(m+n)/n.

但是由于有求余，不能直接除，要解形如ax≡c(mod b)的方程。b是题目所给大素数，a是除数，c是被除数，求得商为x。

用Extended-Euclid即可。


---


# [HNOI2002] 高质量的数据传输

## 题目描述

$%原题面是：![](https://cdn.luogu.com.cn/upload/pic/1325.png)$

目前的网络为了支持各种 QoS 需求，在进行路由选择时所考虑的路由参数主要有网络路径中的参数如时延、网络带宽、时延抖动及丢失率等参数，在某种高质量的数据传输工程中仅考虑网络的时延和丢失率两个参数。

网络可以用一个简单无向图 $G = (V, E)$ 来表示，$V$ 是网络中结点的集合，$E$ 是两个结点之间的链路，即边。依据工程的要求，每条边上有两个参数：时延和丢失率。

* 边上的时延 $t$ 是数据从该边的一个端点传输到另一个端点所需要的时间，取为整数，单位是毫秒，$0 \le t \le 100$。
* 一条边的丢失率 $p$ 是数据从该边的一个端点传输到另一个端点后丢失数据的百分比，$0 \le p \le 0.1$。

所谓网络 $G$ 上的路由选择是：给定 $G$ 中的两个结点 $u$ 和 $v$，找出这两个结点之间的一条路径。

---

对于网络 $G$ 的一条路径 $P = v_1, v_2, v_3, \dots, v_n$，假设该路径上各边的时延和丢失率分别是：

$$
t_1, t_2, t_3, \dots, t_{n-1}, \quad p_1, p_2, p_3, \dots, p_{n-1}
$$

则数据从 $v_1$ 传输到 $v_n$ 的时延是：

$$
\sum_{i=1}^{n-1} t_i
$$

丢失率是：

$$
1 - \prod_{i=1}^{n-1} (1 - p_i)
$$

---

本题的高质量数据传输要求：如果数据要从一个结点 $u$ 传输到另一个结点 $v$，则所传输路径的丢失率是从 $u$ 到 $v$ 的所有路径中最小的，而且在该前提下时延最小。

请为网络图给定的两个结点，找出满足高质量数据传输要求的路径。

## 样例 #1

### 输入

```
3 1 3                       
0 1 5
1 0 2
5 2 0
0 0.1 0.05
0.1 0 0.05
0.05 0.05 0```

### 输出

```
5 0.0500```

# 题解

## 作者：licn (赞：4)

## **题目分析：**
本题是在最短路的基础上多维护了一个路径，我们正常去做最短路。

## **做法：**
用 spfa 去跑最短路，由于需要维护最少丢失率，我们可以维护最大剩余率，最后用 $1$ 减，可以保证精度。当丢失率相等时再去判断一下延时长短。

切记：丢失率可能是 $0$ 存图的时候注意不要特判是 $0$ 时不存。（本人栽了）

spfa：当一个点的最优值被更新时，那么需要更新与它相连的点。如果需要去更新的点已在队列里不必再入队。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=310;
const double eps=1e-6;
int n,l,r,t[N][N],head[N],tot;
double loss[N][N];
struct node
{
	int next,to,dis2;
	double dis1;//dis1[]剩余率，dis2[]延时
}edge[N*N];
void read(int from,int to,double dis1,int dis2)
{
	tot++;
	edge[tot].to=to;
	edge[tot].dis1=dis1;
	edge[tot].dis2=dis2;
	edge[tot].next=head[from];
	head[from]=tot;
}
void spfa()
{
	double ans1[N]={0};//剩余率
	int ans2[N]={0},v[N]={0};//ans2[]延时，v[]标记是否在队列里
	ans1[l]=1,v[l]=1;
	queue<int>q;
	q.push(l);
	while(q.size())
	{
		int x=q.front();
		q.pop();
		v[x]=0;
		for(int i=head[x];i;i=edge[i].next)
		{
			int y=edge[i].to;
			if(ans1[x]*edge[i].dis1>ans1[y])
			{
				ans1[y]=ans1[x]*edge[i].dis1;
				ans2[y]=ans2[x]+edge[i].dis2;
				if(v[y]==0)q.push(y),v[y]=1; //如果已经在队列里不必再次入队
			}
		}
	}
	printf("%d %.4lf",ans2[r],1-ans1[r]);
}
int main(){
	scanf("%d%d%d",&n,&l,&r);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&t[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%lf",&loss[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(t[i][j]!=-1&&loss[i][j]!=-1)
				read(i,j,1-loss[i][j],t[i][j]),read(j,i,1-loss[i][j],t[i][j]);
	spfa();
	return 0;
}

---

## 作者：KagurazakaLorna (赞：4)

显然这是个最短路问题。我用的SPFA。

区别在于，在松弛时有2个标准。先看丢失率是否更小，若丢失率相同，再看时延是否更小。

由于小数相乘会越来越小，不便于松弛，因此我将丢失率转变为“传输率”(即1-丢失率)。

以上。下面贴程序：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,Stt,End;
int Time[203][203];
double Loss[203][203];
int Dist[203];
double Tot[203];
queue<int> Que;
set<int> Vis;

void Init() {
    cin>>n>>Stt>>End;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++) cin>>Time[i][j];
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++) {
            cin>>Loss[i][j]; 
            if (Loss[i][j]>=0) Loss[i][j]=1-Loss[i][j];
        }
    return;
}

void SPFA() {
    memset(Dist,0x7f,sizeof(Dist)); 
    memset(Tot,0,sizeof(Tot));
    Dist[Stt]=0; Tot[Stt]=1;
    Que.push(Stt); Vis.insert(Stt);
    while (!Que.empty()) {
        int Frt=Que.front(); Que.pop(); Vis.erase(Frt); 
        for (int i=1;i<=n;i++) {
            if (i==Frt) continue;
            if (Time[Frt][i]==-1) continue;
            if (Tot[Frt]*Loss[Frt][i]>Tot[i]) {
                Tot[i]=Tot[Frt]*Loss[Frt][i];
                Dist[i]=Dist[Frt]+Time[Frt][i];
                if (Vis.count(i)) continue;
                Que.push(i); Vis.insert(i);
            }
            else if (Tot[Frt]*Loss[Frt][i]==Tot[i]) {
                if (Dist[Frt]+Time[Frt][i]<Dist[i]) {
                    Dist[i]=Dist[Frt]+Time[Frt][i];
                    if (Vis.count(i)) continue;
                    Que.push(i); Vis.insert(i);
                }
            }
        }
    }
    return;
}

int main() {
    ios::sync_with_stdio(0);
    Init();
    SPFA();
    cout<<Dist[End]<<' '<<fixed<<setprecision(4)<<1-Tot[End]<<endl;
    return 0;
}

```

---

## 作者：chichichichi (赞：1)

水一发最短路题解~

#### 关于本题解

题目很简单，主要是看到已有题解对于题目的分析不够数学（？），看着有点别扭 ~~（你事好多啊）~~，就写了这篇题解。

# 正文

### 题目大意：

给出一个无向图，每条边有两个权值： $t$ 和 $p$ 。求图中指定的起点与终点之间的一条路径，要求满足以下两个条件：（设这条路径共经过 $n$ 条边，分别为 $v_1 \dots v_n$）

1.  $1-\prod\limits_{i=1}^n(1-p_i)$ 的值最小。

2. 在满足`条件1`的前提下，$\sum\limits_{i=1}^n t_i$的值最小。 

### 分析
`条件二`显然要求最短路，~~但同样显然~~，我们发现无法通过最短路直接求出`条件1`形式的最小值，需要转化一下。

运用**复合函数**的思想，我们将`条件1`给出的式子拆分一下，并分析其单调性。

设$f(n)=1-g(n)$，$g(n)=\prod \limits_{i=1}^n(1-p_i)$。

在$g(n)$取到最大值时，$f(n)$取到最小值。

观察 $g(n)$ 函数，可以想到给每条边赋上一个新的权值 $w_i=1-p_i$.



`条件1`就转化成了使$g(n)=\prod\limits_{i=1}^n w_i$取到最大值。

到这里就很简单啦，类似的题目并不少。将**路径长度**定义为路径上每条边的权值$w$的乘积，求**最长路**即可。


### 具体实现细节

建图具体在代码里

最长路要用SPFA来求。

两个条件是有优先级的，所以松弛时要注意：

- 当`条件1`可以被更新时，两个条件都要更新。

- 当`条件1`相同，`条件2`可以更新时，只更新`条件2`。

判断浮点数的相等时，会有精度误差，不能直接用`==`。设置一个精度 $eps$，一般是$10^{-6}$，当两个浮点数之差的绝对值小于$eps$时，认为两数相同。

### Before the Code

变量名可能有些奇奇怪怪……希望不会影响阅读。如果发现本题解有错误或者有疑问欢迎评论或私信交流！

#### Enjoy the Code
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
#define EPS 1e-6//精度
const int maxn=220;
const int maxm=50000;
int n,u,v,tot;
int lin[maxn],to[maxm],ne[maxm];
int t[maxm],dis[maxn];
double p[maxm],ti[maxn];
void add(int x,int y,int k,double w)
{//链式前向星
	to[++tot]=y;
	ne[tot]=lin[x];
	lin[x]=tot;
	t[tot]=k;
	p[tot]=w;
}
int a[maxn][maxn];
double b[maxn][maxn];
queue<int>q;
int vis[maxn];
void spfa(int s)
{
	dis[s]=0;
	ti[s]=1;
	vis[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=lin[x];i;i=ne[i])
		{
			int y=to[i];
			if(ti[y]<ti[x]*p[i])//优先级1
			{
				dis[y]=dis[x]+t[i];
				ti[y]=ti[x]*p[i];
				if(!vis[y])
				{
					q.push(y);
					vis[y]=1;
				}
			}else//优先级2
			{
				if(fabs(ti[y]-ti[x]*p[i])<EPS&&dis[y]>dis[x]+t[i])
				{
					dis[y]=dis[x]+t[i];
					if(!vis[y])
					{
						q.push(y);
						vis[y]=1;
					}
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&u,&v);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);

	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%lf",&b[i][j]);
	//先读进来两个权值
	for(int i=1;i<=n;i++)
	{
		dis[i]=0x3f3f3f3f;
		ti[i]=-1;//初始化
		for(int j=i+1;j<=n;j++)//因为是无向边，只需要半个邻接矩阵
			if(a[i][j]!=-1)
			{//有边就建边
				add(i,j,a[i][j],1-b[i][j]);
				add(j,i,a[i][j],1-b[i][j]);//注意新的边权
			}	
	}
	spfa(u);
	printf("%d %.4lf",dis[v],1-ti[v]);
	return 0;
}
```
### See Ya！


---

## 作者：SmallTownKid (赞：1)

双关键字spfa+邻接矩阵 

丢失率为第一关键字，时延是第二关键字。

如果丢失率一样，时延可更新就更新。

如果更新了丢失率强制更新时延。

floyd也可以做。


```
#include<bits/stdc++.h>
using namespace std;
int n,s,t;
struct node{
	long double w1;
	long long w2;
}edge[220][220];
long double dis1[220];
long long dis2[220];
int vis[220];
void spfa(int s)
{
	for(int i=1;i<=n;i++)
	{
		dis1[i]=0;//丢包率 
		dis2[i]=0x7f;//时延 
	}
	queue<int> q;
	q.push(s);
	vis[s]=1;
	dis1[s]=1;
	dis2[s]=0;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=1;i<=n;i++)
		{
			if(edge[x][i].w2==-1||x==i)//无边或者重合 
			continue;
			if(dis1[x]*edge[x][i].w1>dis1[i])
			{
				dis1[i]=dis1[x]*edge[x][i].w1;
				dis2[i]=dis2[x]+edge[x][i].w2;//强制更新
				if(!vis[i])
				{
					q.push(i);
					vis[i]=1;
				} 
			}
			else if((dis1[x]*edge[x][i].w1==dis1[i])&&(dis2[i]>dis2[x]+edge[x][i].w2))//可以更新时延 
			{
				dis2[i]=dis2[x]+edge[x][i].w2;
				if(!vis[i])
				{
					q.push(i);
					vis[i]=1;
				} 
			}
		}
	}
}
int main()
{
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>edge[i][j].w2;//时延 
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			long double x;
			cin>>x;
			if(x>=0)
			edge[i][j].w1=(1-x);//丢失率 
		}
	}
	spfa(s);
	cout<<dis2[t]<<" ";
	printf("%.4Lf",(long double)1-dis1[t]);
	return 0;
} 
```

---

## 作者：_Weslie_ (赞：0)

### Idea

看见 $n\le200$，果断采用 Floyd。

在 Floyd 的过程中，我们维护两个数值：从 $i$ 到 $j$ 的最小丢包率，从 $i$ 到 $j$ 的延时（注意不一定是最短的）。

题目要求丢包率优先，我们直接模拟即可。注意到在丢包率小的情况下延时不一定最小，所以延时不可以取最小值。

接下来我们解决丢包率更新的问题。我们设现在枚举到了 $i,j,k$（其中 $k$ 为途经点），并且 $i$ 和 $k$，$j$ 和 $k$ 之间均有连边，我们设 $i$ 和 $j$ 之间最小的丢包率为 $dis_{i,j}$，则有经过 $k$ 从 $i$ 到 $j$ 的最小丢包率 $dis=1-(1-dis_{j,k})\times (1-dis_{i,k})$。

根据定义，我们不难发现：若使经过 $k$ 从 $i$ 到 $j$ 的最小丢包率最小，必须使得 $\prod(1-p_i)$ 最大，其中 $p_i$ 为使得经过 $k$ 从 $i$ 到 $j$ 的丢包率最小所经过的一条边的丢包率。

不难发现如果保证 $dis_{i,k}$ 最小，$dis_{j,k}$ 最小，则 $1-dis_{i,k}$ 和 $1-dis_{j,k}$ 一定最大。它们相乘的结果根据定义其实就是 $\prod(1-p_i)$，用 $1$ 减去它就是更新的答案。当然这个答案不一定最小。

### Code

```
#include<bits/stdc++.h>
using namespace std;
double dis2[205][205],b[205][205];
long long dis1[205][205],a[205][205];
int n,s,t;
int main(){
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>dis1[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>dis2[i][j];
		}
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(dis1[i][k]==-1||dis1[j][k]==-1)continue;
				double nans=1-(1-dis2[i][k])*(1-dis2[j][k]);
				if(nans<dis2[i][j]){
					dis2[i][j]=nans;
					dis1[i][j]=dis1[i][k]+dis1[j][k];
				}
				else if(nans==dis2[i][j]&&dis1[i][j]>dis1[i][k]+dis1[j][k]){
					dis1[i][j]=dis1[i][k]+dis1[j][k];
				}
			}
		}
	}
	printf("%lld %.4lf",dis1[s][t],dis2[s][t]);
	return 0;
}
```

---

## 作者：木木！ (赞：0)

蒟蒻拍个Floyd的题解qwq。

由于本题n才`200`，建议果断拍Floyd，不仅好写，还好调，代码连1kb都不到。

魔改一下板子，存i到j的$\sum T_{ij}$和$\prod(1-p_{ij})$，然后松弛的时候，如果Pi相乘较大的话就更新，否则若Pi相乘相等就比较Ti。

要注意的是，浮点数不能直接用`==`，会有精度误差（但是我`long double`竟然水过去了）。

附AC代码

```cpp
#include <cstdio>
using namespace std;

int ti[205][205];
long double pi[205][205]; //long double防卡精保平安

int main()
{
	int n,s,t;
	scanf("%d%d%d",&n,&s,&t);
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=n; ++j)
		{
			scanf("%d",ti[i]+j);
		}
	}
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=n; ++j)
		{
			scanf("%Lf",pi[i]+j);
			pi[i][j] = 1-pi[i][j];
		}
	}
	
	for(int k=1; k<=n; ++k)
	{
		for(int i=1; i<=n; ++i)
		{
			for(int j=1; j<=n; ++j)
			{
				if(~ti[i][k] && ~ti[k][j])
				{
					if(!~ti[i][j] || pi[i][j]<pi[i][k]*pi[k][j] ||
							(pi[i][j]==pi[i][k]*pi[k][j] && ti[i][j]>ti[i][k]+ti[k][j]))
					{
						ti[i][j] = ti[i][k]+ti[k][j];
						pi[i][j] = pi[i][k]*pi[k][j];
					}
				}
			}
		}
	}
	
	printf("%d %.4Lf\n",ti[s][t],1-pi[s][t]);
}
```

---

## 作者：Haishu (赞：0)

这题给大家提供一下不同的思路~

**总体思路**

求传输失败率 $1-\prod(1-p_{i})$ 最小就是求 传输成功率 $\prod(1-p_{i})$ 最大。

求一个最短路，使得传输成功率（1-失败率）最大为第一关键字，时延最小为第二关键字。

**思路1**

正如另一篇题解的思路，我们可以稍微改变一下传统的spfa：

在松弛操作时，如果传输效率更好，则松弛**传输效率**及**该效率下对应的时延**。如果传输效率一致，则只松弛**该效率下对应的时延**。如果传输效率更差，什么都不更新。

这样就能保证两个关键字的次序。

```cpp
#include <cstdio>
#include <queue>
#include <cmath>
using namespace std; 
const int S=80001,inf=(1<<30)-1,SS=201;
const double eps=1e-6;
int n,m,is[S],ss,tt,dt[S],t[SS][SS];
double g[SS][SS],dg[S];
queue<int> q;
void init()
{
    int uu,vv;
    scanf("%d%d%d",&n,&ss,&tt);
    for (int i=1;i<=n;i++)
    	for (int j=1;j<=n;j++)
    		scanf("%d",t[i]+j);
    for (int i=1;i<=n;i++)
    	for (int j=1;j<=n;j++)
    	{
    		scanf("%lf",&g[i][j]);
    		if (g[i][j]!=-1)
				g[i][j]=1-g[i][j];
    	}
    return;
}
void spfa()
{
    for (int i=1;i<=n;i++)
	{
		dg[i]=-inf;
		dt[i]=inf;
	}
    dg[ss]=1;
    dt[ss]=0;
	q.push(ss);
	is[ss]=1;
    while (!q.empty())
    {
        int x=q.front();//printf("%d\n",top);
        q.pop();is[x]=0;
        for (int i=1;i<=n;i++)
        	if (x!=i && t[x][i]!=-1)
            {
            	if (dg[i]<dg[x]*g[x][i])
            	{
                	dg[i]=dg[x]*g[x][i];
                	dt[i]=dt[x]+t[x][i];
	                if (!is[i])
	                {
	                    is[i]=1;
						q.push(i);
					}
	            }
	            else if (fabs(dg[i]-dg[x]*g[x][i])<=eps && 
                         dt[i]>dt[x]+t[x][i])
	            {
	            	dt[i]=dt[x]+t[x][i];
	            	if (!is[i])
	            	{
	            		is[i]=true;
	            		q.push(i);
	            	}
	            }
            }
    }
    return;
}
void work()
{
    spfa();
    printf("%d %.4f",dt[tt],1-dg[tt]);
    return;
}
int main()
{
    init();work();
    return 0;
}
```

**思路2(次好)**

我们可以先spfa一下传输成功率，再spfa时延。

我们用$d$数组记录一个点的成功率,$e$二维数组记录边的丢失率。

在spfa时延时，松弛时的判断是否更新的条件语句中加一个判断 $(d_u \times (1-e_{u,v})==d_v)$

也就是可以理解为，沿着传输成功率最大的边（符合第一关键字的边）来更新各个节点的时延。

这样也可以。

```cpp
#include <cstdio>
#include <queue>
#include <cmath>
using namespace std; 
const int S=80001,inf=(1<<30)-1,SS=203;
const double eps=1e-6;
int n,m,s,ss,tt,d[S],g[SS][SS];
double h[SS][SS],dh[SS];
bool is[S];
queue<int> q;
void init()
{
    int uu,vv;
    scanf("%d%d%d",&n,&ss,&tt);
    for (int i=1;i<=n;i++)
    	for (int j=1;j<=n;j++)
    		scanf("%d",g[i]+j);
    for (int i=1;i<=n;i++)
    	for (int j=1;j<=n;j++)
    	{
    		scanf("%lf",&h[i][j]);
    		if (h[i][j]!=-1)
	    		h[i][j]=1-h[i][j];
    	}
    return;
}
void spfa_1()
{
    for (int i=1;i<=n;i++) dh[i]=-1;
    dh[ss]=1;q.push(ss);is[ss]=true;
    for (int x;!q.empty();q.pop())
    {
    	x=q.front();
    	is[x]=false;
    	for (int i=1;i<=n;i++)
    		if (x!=i && g[x][i]!=-1 && dh[i]<dh[x]*h[x][i])
    		{
    			dh[i]=dh[x]*h[x][i];
    			if (!is[i])
    			{
    				is[i]=true;
    				q.push(i);
    			}
    		}
    }
    return;
}
void spfa_2()
{
    for (int i=1;i<=n;i++) d[i]=inf;
    d[ss]=0;q.push(ss);is[ss]=1;
    for (int x;!q.empty();q.pop())
    {
        x=q.front();
        is[x]=false;
        for (int i=1;i<=n;i++)
        	if (x!=i && g[x][i]!=-1 && 
                fabs(dh[x]*h[x][i]-dh[i])<=eps && d[i]>d[x]+g[x][i])
            {
                d[i]=d[x]+g[x][i];
                if (!is[i])
                {
                    is[i]=true;
					q.push(i);
				}
            }
    }
    return;
}
void work()
{
    spfa_1();
    spfa_2();
    printf("%d %.4f",d[tt],1-dh[tt]);
    return;
}
int main()
{
    init();work();
    return 0;
}
```

**后记**

这题是我时隔了半年两次写的题目。那时是思路2，还没写对，只有10分，现在有了两个思路。不同的水平，果然有不同的感悟。算法有时候，还真的是一门值得研究的艺术。

---


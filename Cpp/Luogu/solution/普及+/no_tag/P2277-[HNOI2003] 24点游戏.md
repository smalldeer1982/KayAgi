# [HNOI2003] 24点游戏

## 题目描述

为了培养小孩的计算能力，大人们经常给小孩玩这样的游戏：从一副扑克牌中任意抽出 $4$ 张扑克，要小孩用 `+`、`-`、`*`、`/` 和括号组成一个合法的表达式，并使表达式的值为 $24$ 点。这种游戏就是所谓的“$24$ 点游戏”。

请你编程求出对于给出的任意 $4$ 个正整数 $a$、$b$、$c$、$d$，请你编程求出这 $4$ 个整数能组成多少个值为 $24$ 的不同表达式。


## 样例 #1

### 输入

```
5 5 5 5
```

### 输出

```
1
```

# 题解

## 作者：__Hacheylight__ (赞：6)

似乎这题难度还好，不够紫题吧。。。

看大佬都没发题解，蒟蒻趁机来发一篇。

意思就是24点，求解法

大概难点是以下几个：

1）搜索方式

2）判断是否可行方法

3）判重

1）搜索方法:check(1,2,3,4),check（1,2,4,3）....

我也是，看到有大佬有用next_permutation，没想到。


2）判重：

首先枚举三种符号（另外一种就是被排出来的那个）

然后5种括号方法：

(1,2,3,4) 

((1,2),(3,4)) 

(1,(2,3,4)) 

((1,(2,3)),4)

(1,(2,(3,4)))

3）之后是判重：

题目中说a,b,c,d<=100,100十三位，于是我们用一个21位的数表示该25点表达式（不用担心爆，过了），表达式是后缀的（比如3*5的后缀表达式是35*）存到x数组里，之后判重，输出。

代码实现（代码上还有注释）：
```cpp
#include <bits/stdc++.h>
#define eps 1e-7 //因为实数计算会有误差，但误差范围应该是小于10^-7的。 
using namespace std ;
int x[10010] ;//答案，判重 
int h,ans ;
int r[10],a[10] ;
double habs(double x){ //好像abs被占用了，忘记那个abs怎么打的了，手打算了。 
	return x<0?-x:x ;
}
inline void add(int a1,int a2,int a3,int a4,int a5,int a6,int a7){ //后缀表达式形式 
    x[++h]=(a1|a2<<3|a3<<6|a4<<9|a5<<12|a6<<15|a7<<18); 
	//因为他说a,b,c,d最大是100，100是三位，那就让一个数上占用三个位置 
}
double calc(double x,double y,int f) //f表示符号(+-*/)，相当于 a (f) b 
{
	if (f==0) return x+y ;
	else if (f==1) return x-y ;
	else if (f==2) return x*y ;
	else return x/y ;
} 
inline bool find(int a,int b){
    if (a==0) return b>1;
    if (a==2) return b<2;
    return 1;
}
void check(int a1,int a2,int a3,int a4)
{
	for (int i=0;i<=3;i++)
	for (int j=0;j<=3;j++)
	for (int k=0;k<=3;k++)
	{
		bool f1=find(k,j),f2=find(j,i);
		//一下是5种加括号方式 
    	if (habs( calc ( calc ( calc (a[a1],a[a2],i) ,a[a3],j) ,a[a4],k) -24)<eps) 
        	add(r[a1],r[a2],i+4,r[a3],j+4,r[a4],k+4);//表示(1,2,3,4) 
        	
        if (f1 && habs(calc ( calc (a[a1],a[a2],i), calc (a[a3],a[a4],j),k)-24)<eps) 
        	add(r[a1],r[a2],i+4,r[a3],r[a4],j+4,k+4);//表示((1,2),(3,4)) 
        	
        if (f1 && habs( calc (a[a1], calc ( calc (a[a2],a[a3],i),a[a4],j),k)-24)<eps) 
        	add(r[a1],r[a2],r[a3],i+4,r[a4],j+4,k+4);//表示(1,(2,3,4)) 
				
        if (f2 && habs( calc ( calc (a[a1], calc (a[a2],a[a3],i),j),a[a4],k)-24)<eps) 
        	add(r[a1],r[a2],r[a3],i+4,j+4,r[a4],k+4);//表示((1,(2,3)),4) 
        
        if (f1 && f2 && habs( calc (a[a1], calc (a[a2], calc (a[a3],a[a4],i),j),k)-24)<eps) 
       	 	add(r[a1],r[a2],r[a3],r[a4],i+4,j+4,k+4);//表示(1,(2,(3,4)))
	}
}
int main()
{
	for (int i=0;i<=3;i++) scanf("%d",&a[i]) ;
	for (int i=0;i<=3;i++)
	for (int j=0;j<=3;j++)
	if (a[i]<a[j]) r[i]++ ;//r数组表示第i个数是第几大的(最大的标号是0)。
	for (int i=0;i<=3;i++) 
	for (int j=0;j<=3;j++)
	for (int k=0;k<=3;k++)
	for (int l=0;l<=3;l++)
	if (i!=j && i!=k && i!=l && j!=k && j!=l && k!=l) //写的有点冗(Rong)余，但是肯定对的 
	check(i,j,k,l) ; 
	sort(x+1,x+h+1) ;
	if (h) ans=1 ;//如果有值，那ans=1，之后的再判重 
	for (int i=2;i<=h;i++) if (x[i]!=x[i-1]) ans++ ;
	printf("%d",ans) ;
} 
```

---

## 作者：Tiphereth_A (赞：6)

前往 [我的 Blog](https://blog.tifa-233.com/archives/luogu-p2277) 以获取更好的阅读体验。

---

### 宏定义 24 点

整点 nasty 的花活。

显然枚举所有可能的式子然后去重就行。

即 [这个代码](https://blog.tifa-233.com/archives/luogu-p2277/enum.cpp)。

当然，这代码都 600+ KB 了，没有一个 OJ 会接受这么大的代码，所以我们可以用宏定义折叠一下（实际上这个代码就是宏定义展开得到的）。

我们思考一下需要哪些宏定义。

1. 我们需要一个能枚举 $\{a,b,c,d\}^3$（乘法为 Descartes 积）的宏定义来枚举所有运算符的情况：

    ```c
    #define _CPROD1_4_HELPER(a, b, c, d, ...) a, __VA_ARGS__, b, __VA_ARGS__, c, __VA_ARGS__, d, __VA_ARGS__

    #define _CPROD2_4_HELPER(a, b, c, d, ...) _CPROD1_4_HELPER(a, b, c, d, a, __VA_ARGS__), _CPROD1_4_HELPER(a, b, c, d, b, __VA_ARGS__), _CPROD1_4_HELPER(a, b, c, d, c, __VA_ARGS__), _CPROD1_4_HELPER(a, b, c, d, d, __VA_ARGS__)

    #define CPROD3_4(a, b, c, d) _CPROD2_4_HELPER(a, b, c, d, a), _CPROD2_4_HELPER(a, b, c, d, b), _CPROD2_4_HELPER(a, b, c, d, c), _CPROD2_4_HELPER(a, b, c, d, d)

    // use this
    #define OPANDS CPROD3_4(+, -, *, /)
    ```

    然后我们需要这样的宏定义来得到每一组运算符：

    ```c
    #define _RM3(_1, _2, _3, ...) __VA_ARGS__
    #define _SEL3(_1, _2, _3, ...) _1, _2, _3

    // use this
    // remove first 3 elements
    #define RM3(...) _RM3(__VA_ARGS__)
    // use this
    // select first 3 elements
    #define SEL3(...) _SEL3(__VA_ARGS__)
    ```

1. 我们需要一个能枚举 $\{a,b,c,d\}$ 全排列的宏定义来枚举所有数的情况（实际上，因为这样会让编译时间过长甚至让编译器爆栈，所以这个并没有用上）：

    ```c
    #define _P2_HELPER(a, b, ...) a, b, __VA_ARGS__, b, a, __VA_ARGS__

    #define _P3_HELPER(a, b, c, ...) _P2_HELPER(a, b, c, __VA_ARGS__), _P2_HELPER(b, c, a, __VA_ARGS__), _P2_HELPER(c, a, b, __VA_ARGS__)

    // use this
    #define P4 _P3_HELPER(a, b, c, d), _P3_HELPER(b, c, d, a), _P3_HELPER(c, d, a, b), _P3_HELPER(d, a, b, c)
    ```

    然后我们需要这样的宏定义来得到每一组数。

    ```c
    #define _RM4(_1, _2, _3, _4, ...) __VA_ARGS__
    #define _SEL4(_1, _2, _3, _4, ...) _1, _2, _3, _4

    // use this
    // remove first 4 elements
    #define RM4(...) _RM4(__VA_ARGS__)
    // use this
    // select first 4 elements
    #define SEL4(...) _SEL4(__VA_ARGS__)
    ```

1. 我们需要枚举 5 种运算方式。

      - $(((a\odot b)\odot c)\odot d)$
      - $((a\odot (b\odot c))\odot d)$
      - $(a\odot ((b\odot c)\odot d))$
      - $(a\odot (b\odot (c\odot d)))$
      - $((a\odot b)\odot (c\odot d))$

      其中 $\odot\in\{+,-,\times,\div\}$

      这个写成宏定义就很简单。

      ```c
      #define ___CALC0(a, b, c, d, opab, opbc, opcd) Node(0, a, b, c, d, #opab, #opbc, #opcd, ((double(a) opab double(b))opbc double(c))opcd double(d))

      #define ___CALC1(a, b, c, d, opab, opbc, opcd) Node(1, a, b, c, d, #opab, #opbc, #opcd, (double(a) opab(double(b) opbc double(c)))opcd double(d))

      #define ___CALC2(a, b, c, d, opab, opbc, opcd) Node(2, a, b, c, d, #opab, #opbc, #opcd, double(a) opab((double(b) opbc double(c))opcd double(d)))

      #define ___CALC3(a, b, c, d, opab, opbc, opcd) Node(3, a, b, c, d, #opab, #opbc, #opcd, double(a) opab(double(b) opbc(double(c) opcd double(d))))

      #define ___CALC4(a, b, c, d, opab, opbc, opcd) Node(4, a, b, c, d, #opab, #opbc, #opcd, ((double(a) opab double(b))opbc(double(c) opcd double(d))))

      #define ___CALC(a, b, c, d, opab, opbc, opcd) ___CALC0(a, b, c, d, opab, opbc, opcd), ___CALC1(a, b, c, d, opab, opbc, opcd), ___CALC2(a, b, c, d, opab, opbc, opcd), ___CALC3(a, b, c, d, opab, opbc, opcd), ___CALC4(a, b, c, d, opab, opbc, opcd)

      // use this
      #define __CALC(...) ___CALC(__VA_ARGS__)
      ```

接下来就是把这三部分拼接起来就好了。

定义个结构体 `Node` 存 hash 和 运算结果，去重用 `std::set<Node>` 即可。

- Q1: 为什么变长参数宏定义使用了 C 风格的 `__VA_ARGS__`？

- A1: 因为这样能实现的功能多。

  比如 `g++` 对 `#define EXPAND(args...) ##args` 会报错，而 `#define EXPAND(...) __VA_ARGS__` 不会。

- Q2: 为什么不把去重和 hash 也宏定义化？

- A2: 两个原因
  - 用了这些宏定义之后，代码就已经 17 KB 了，已经能交了。
  - 不同编译器对宏定义的支持程度不同，比如笔者这边的 `gcc` 不支持宏定义递归，所以无法实现纯宏定义的循环。

另外，由于代码中一定要用到列表初始化来构造容器，所以不能在一次构造中塞太多元素，否则会让编译时间大幅增加甚至让编译器爆栈 ~~从而得到一个没有编译信息的 CE 记录~~。

这也就是为什么我代码里向 `std::set` 加元素是分了 24 次 `merge`，而不是一步到位，直接将 7680 个元素一起塞进去。

而且即使是这样，洛谷的编译器也会炸掉，所以只能将全排列枚举部分换成 `std::next_permutation`。

```cpp
/*
 * @Author: Tifa
 * @LastEditTime: 2021-11-05 01:01:36
 * @Description: Luogu P2277, macro
 */
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using u64 = unsigned long long;

#define _RM3(_1, _2, _3, ...) __VA_ARGS__
#define RM3(...) _RM3(__VA_ARGS__)
#define _RM4(_1, _2, _3, _4, ...) __VA_ARGS__
#define RM4(...) _RM4(__VA_ARGS__)

#define _SEL3(_1, _2, _3, ...) _1, _2, _3
#define SEL3(...) _SEL3(__VA_ARGS__)
#define _SEL4(_1, _2, _3, _4, ...) _1, _2, _3, _4
#define SEL4(...) _SEL4(__VA_ARGS__)

#define _CPROD1_4_HELPER(a, b, c, d, ...) a, __VA_ARGS__, b, __VA_ARGS__, c, __VA_ARGS__, d, __VA_ARGS__
#define _CPROD2_4_HELPER(a, b, c, d, ...) _CPROD1_4_HELPER(a, b, c, d, a, __VA_ARGS__), _CPROD1_4_HELPER(a, b, c, d, b, __VA_ARGS__), _CPROD1_4_HELPER(a, b, c, d, c, __VA_ARGS__), _CPROD1_4_HELPER(a, b, c, d, d, __VA_ARGS__)
#define CPROD3_4(a, b, c, d) _CPROD2_4_HELPER(a, b, c, d, a), _CPROD2_4_HELPER(a, b, c, d, b), _CPROD2_4_HELPER(a, b, c, d, c), _CPROD2_4_HELPER(a, b, c, d, d)

#define _RM_1(func, ...) func(__VA_ARGS__)
#define _RM_2(func, ...) _RM_1(func, _RM_1(func, __VA_ARGS__))
#define _RM_3(func, ...) _RM_2(func, _RM_1(func, __VA_ARGS__))
#define _RM_4(func, ...) _RM_2(func, _RM_2(func, __VA_ARGS__))
#define _RM_5(func, ...) _RM_4(func, _RM_1(func, __VA_ARGS__))
#define _RM_6(func, ...) _RM_4(func, _RM_2(func, __VA_ARGS__))
#define _RM_7(func, ...) _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))
#define _RM_8(func, ...) _RM_4(func, _RM_4(func, __VA_ARGS__))
#define _RM_9(func, ...) _RM_8(func, _RM_1(func, __VA_ARGS__))
#define _RM_10(func, ...) _RM_8(func, _RM_2(func, __VA_ARGS__))
#define _RM_11(func, ...) _RM_8(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))
#define _RM_12(func, ...) _RM_8(func, _RM_4(func, __VA_ARGS__))
#define _RM_13(func, ...) _RM_8(func, _RM_4(func, _RM_1(func, __VA_ARGS__)))
#define _RM_14(func, ...) _RM_8(func, _RM_4(func, _RM_2(func, __VA_ARGS__)))
#define _RM_15(func, ...) _RM_8(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))
#define _RM_16(func, ...) _RM_8(func, _RM_8(func, __VA_ARGS__))
#define _RM_17(func, ...) _RM_16(func, _RM_1(func, __VA_ARGS__))
#define _RM_18(func, ...) _RM_16(func, _RM_2(func, __VA_ARGS__))
#define _RM_19(func, ...) _RM_16(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))
#define _RM_20(func, ...) _RM_16(func, _RM_4(func, __VA_ARGS__))
#define _RM_21(func, ...) _RM_16(func, _RM_4(func, _RM_1(func, __VA_ARGS__)))
#define _RM_22(func, ...) _RM_16(func, _RM_4(func, _RM_2(func, __VA_ARGS__)))
#define _RM_23(func, ...) _RM_16(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))
#define _RM_24(func, ...) _RM_16(func, _RM_8(func, __VA_ARGS__))
#define _RM_25(func, ...) _RM_16(func, _RM_8(func, _RM_1(func, __VA_ARGS__)))
#define _RM_26(func, ...) _RM_16(func, _RM_8(func, _RM_2(func, __VA_ARGS__)))
#define _RM_27(func, ...) _RM_16(func, _RM_8(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))
#define _RM_28(func, ...) _RM_16(func, _RM_8(func, _RM_4(func, __VA_ARGS__)))
#define _RM_29(func, ...) _RM_16(func, _RM_8(func, _RM_4(func, _RM_1(func, __VA_ARGS__))))
#define _RM_30(func, ...) _RM_16(func, _RM_8(func, _RM_4(func, _RM_2(func, __VA_ARGS__))))
#define _RM_31(func, ...) _RM_16(func, _RM_8(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))))
#define _RM_32(func, ...) _RM_16(func, _RM_16(func, __VA_ARGS__))
#define _RM_33(func, ...) _RM_32(func, _RM_1(func, __VA_ARGS__))
#define _RM_34(func, ...) _RM_32(func, _RM_2(func, __VA_ARGS__))
#define _RM_35(func, ...) _RM_32(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))
#define _RM_36(func, ...) _RM_32(func, _RM_4(func, __VA_ARGS__))
#define _RM_37(func, ...) _RM_32(func, _RM_4(func, _RM_1(func, __VA_ARGS__)))
#define _RM_38(func, ...) _RM_32(func, _RM_4(func, _RM_2(func, __VA_ARGS__)))
#define _RM_39(func, ...) _RM_32(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))
#define _RM_40(func, ...) _RM_32(func, _RM_8(func, __VA_ARGS__))
#define _RM_41(func, ...) _RM_32(func, _RM_8(func, _RM_1(func, __VA_ARGS__)))
#define _RM_42(func, ...) _RM_32(func, _RM_8(func, _RM_2(func, __VA_ARGS__)))
#define _RM_43(func, ...) _RM_32(func, _RM_8(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))
#define _RM_44(func, ...) _RM_32(func, _RM_8(func, _RM_4(func, __VA_ARGS__)))
#define _RM_45(func, ...) _RM_32(func, _RM_8(func, _RM_4(func, _RM_1(func, __VA_ARGS__))))
#define _RM_46(func, ...) _RM_32(func, _RM_8(func, _RM_4(func, _RM_2(func, __VA_ARGS__))))
#define _RM_47(func, ...) _RM_32(func, _RM_8(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))))
#define _RM_48(func, ...) _RM_32(func, _RM_16(func, __VA_ARGS__))
#define _RM_49(func, ...) _RM_32(func, _RM_16(func, _RM_1(func, __VA_ARGS__)))
#define _RM_50(func, ...) _RM_32(func, _RM_16(func, _RM_2(func, __VA_ARGS__)))
#define _RM_51(func, ...) _RM_32(func, _RM_16(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))
#define _RM_52(func, ...) _RM_32(func, _RM_16(func, _RM_4(func, __VA_ARGS__)))
#define _RM_53(func, ...) _RM_32(func, _RM_16(func, _RM_4(func, _RM_1(func, __VA_ARGS__))))
#define _RM_54(func, ...) _RM_32(func, _RM_16(func, _RM_4(func, _RM_2(func, __VA_ARGS__))))
#define _RM_55(func, ...) _RM_32(func, _RM_16(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))))
#define _RM_56(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, __VA_ARGS__)))
#define _RM_57(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_1(func, __VA_ARGS__))))
#define _RM_58(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_2(func, __VA_ARGS__))))
#define _RM_59(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_2(func, _RM_1(func, __VA_ARGS__)))))
#define _RM_60(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_4(func, __VA_ARGS__))))
#define _RM_61(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_4(func, _RM_1(func, __VA_ARGS__)))))
#define _RM_62(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_4(func, _RM_2(func, __VA_ARGS__)))))
#define _RM_63(func, ...) _RM_32(func, _RM_16(func, _RM_8(func, _RM_4(func, _RM_2(func, _RM_1(func, __VA_ARGS__))))))
#define RMAB(a, b, ...) _RM_##b(RM##a, __VA_ARGS__)

#define OPANDS CPROD3_4(+, -, *, /)

#define OPS0 SEL3(OPANDS)
#define OPS1 SEL3(RMAB(3, 1, OPANDS))
#define OPS2 SEL3(RMAB(3, 2, OPANDS))
#define OPS3 SEL3(RMAB(3, 3, OPANDS))
#define OPS4 SEL3(RMAB(3, 4, OPANDS))
#define OPS5 SEL3(RMAB(3, 5, OPANDS))
#define OPS6 SEL3(RMAB(3, 6, OPANDS))
#define OPS7 SEL3(RMAB(3, 7, OPANDS))
#define OPS8 SEL3(RMAB(3, 8, OPANDS))
#define OPS9 SEL3(RMAB(3, 9, OPANDS))
#define OPS10 SEL3(RMAB(3, 10, OPANDS))
#define OPS11 SEL3(RMAB(3, 11, OPANDS))
#define OPS12 SEL3(RMAB(3, 12, OPANDS))
#define OPS13 SEL3(RMAB(3, 13, OPANDS))
#define OPS14 SEL3(RMAB(3, 14, OPANDS))
#define OPS15 SEL3(RMAB(3, 15, OPANDS))
#define OPS16 SEL3(RMAB(3, 16, OPANDS))
#define OPS17 SEL3(RMAB(3, 17, OPANDS))
#define OPS18 SEL3(RMAB(3, 18, OPANDS))
#define OPS19 SEL3(RMAB(3, 19, OPANDS))
#define OPS20 SEL3(RMAB(3, 20, OPANDS))
#define OPS21 SEL3(RMAB(3, 21, OPANDS))
#define OPS22 SEL3(RMAB(3, 22, OPANDS))
#define OPS23 SEL3(RMAB(3, 23, OPANDS))
#define OPS24 SEL3(RMAB(3, 24, OPANDS))
#define OPS25 SEL3(RMAB(3, 25, OPANDS))
#define OPS26 SEL3(RMAB(3, 26, OPANDS))
#define OPS27 SEL3(RMAB(3, 27, OPANDS))
#define OPS28 SEL3(RMAB(3, 28, OPANDS))
#define OPS29 SEL3(RMAB(3, 29, OPANDS))
#define OPS30 SEL3(RMAB(3, 30, OPANDS))
#define OPS31 SEL3(RMAB(3, 31, OPANDS))
#define OPS32 SEL3(RMAB(3, 32, OPANDS))
#define OPS33 SEL3(RMAB(3, 33, OPANDS))
#define OPS34 SEL3(RMAB(3, 34, OPANDS))
#define OPS35 SEL3(RMAB(3, 35, OPANDS))
#define OPS36 SEL3(RMAB(3, 36, OPANDS))
#define OPS37 SEL3(RMAB(3, 37, OPANDS))
#define OPS38 SEL3(RMAB(3, 38, OPANDS))
#define OPS39 SEL3(RMAB(3, 39, OPANDS))
#define OPS40 SEL3(RMAB(3, 40, OPANDS))
#define OPS41 SEL3(RMAB(3, 41, OPANDS))
#define OPS42 SEL3(RMAB(3, 42, OPANDS))
#define OPS43 SEL3(RMAB(3, 43, OPANDS))
#define OPS44 SEL3(RMAB(3, 44, OPANDS))
#define OPS45 SEL3(RMAB(3, 45, OPANDS))
#define OPS46 SEL3(RMAB(3, 46, OPANDS))
#define OPS47 SEL3(RMAB(3, 47, OPANDS))
#define OPS48 SEL3(RMAB(3, 48, OPANDS))
#define OPS49 SEL3(RMAB(3, 49, OPANDS))
#define OPS50 SEL3(RMAB(3, 50, OPANDS))
#define OPS51 SEL3(RMAB(3, 51, OPANDS))
#define OPS52 SEL3(RMAB(3, 52, OPANDS))
#define OPS53 SEL3(RMAB(3, 53, OPANDS))
#define OPS54 SEL3(RMAB(3, 54, OPANDS))
#define OPS55 SEL3(RMAB(3, 55, OPANDS))
#define OPS56 SEL3(RMAB(3, 56, OPANDS))
#define OPS57 SEL3(RMAB(3, 57, OPANDS))
#define OPS58 SEL3(RMAB(3, 58, OPANDS))
#define OPS59 SEL3(RMAB(3, 59, OPANDS))
#define OPS60 SEL3(RMAB(3, 60, OPANDS))
#define OPS61 SEL3(RMAB(3, 61, OPANDS))
#define OPS62 SEL3(RMAB(3, 62, OPANDS))
#define OPS63 RMAB(3, 63, OPANDS)

#define ___CALC0(a, b, c, d, opab, opbc, opcd) Node(0, a, b, c, d, #opab, #opbc, #opcd, ((double(a) opab double(b))opbc double(c))opcd double(d))
#define ___CALC1(a, b, c, d, opab, opbc, opcd) Node(1, a, b, c, d, #opab, #opbc, #opcd, (double(a) opab(double(b) opbc double(c)))opcd double(d))
#define ___CALC2(a, b, c, d, opab, opbc, opcd) Node(2, a, b, c, d, #opab, #opbc, #opcd, double(a) opab((double(b) opbc double(c))opcd double(d)))
#define ___CALC3(a, b, c, d, opab, opbc, opcd) Node(3, a, b, c, d, #opab, #opbc, #opcd, double(a) opab(double(b) opbc(double(c) opcd double(d))))
#define ___CALC4(a, b, c, d, opab, opbc, opcd) Node(4, a, b, c, d, #opab, #opbc, #opcd, ((double(a) opab double(b))opbc(double(c) opcd double(d))))

#define ___CALC(a, b, c, d, opab, opbc, opcd) ___CALC0(a, b, c, d, opab, opbc, opcd), ___CALC1(a, b, c, d, opab, opbc, opcd), ___CALC2(a, b, c, d, opab, opbc, opcd), ___CALC3(a, b, c, d, opab, opbc, opcd), ___CALC4(a, b, c, d, opab, opbc, opcd)
#define __CALC(...) ___CALC(__VA_ARGS__)

#define _CALC(a, b, c, d) __CALC(a, b, c, d, OPS0), __CALC(a, b, c, d, OPS1), __CALC(a, b, c, d, OPS2), __CALC(a, b, c, d, OPS3), __CALC(a, b, c, d, OPS4), __CALC(a, b, c, d, OPS5), __CALC(a, b, c, d, OPS6), __CALC(a, b, c, d, OPS7), __CALC(a, b, c, d, OPS8), __CALC(a, b, c, d, OPS9), __CALC(a, b, c, d, OPS10), __CALC(a, b, c, d, OPS11), __CALC(a, b, c, d, OPS12), __CALC(a, b, c, d, OPS13), __CALC(a, b, c, d, OPS14), __CALC(a, b, c, d, OPS15), __CALC(a, b, c, d, OPS16), __CALC(a, b, c, d, OPS17), __CALC(a, b, c, d, OPS18), __CALC(a, b, c, d, OPS19), __CALC(a, b, c, d, OPS20), __CALC(a, b, c, d, OPS21), __CALC(a, b, c, d, OPS22), __CALC(a, b, c, d, OPS23), __CALC(a, b, c, d, OPS24), __CALC(a, b, c, d, OPS25), __CALC(a, b, c, d, OPS26), __CALC(a, b, c, d, OPS27), __CALC(a, b, c, d, OPS28), __CALC(a, b, c, d, OPS29), __CALC(a, b, c, d, OPS30), __CALC(a, b, c, d, OPS31), __CALC(a, b, c, d, OPS32), __CALC(a, b, c, d, OPS33), __CALC(a, b, c, d, OPS34), __CALC(a, b, c, d, OPS35), __CALC(a, b, c, d, OPS36), __CALC(a, b, c, d, OPS37), __CALC(a, b, c, d, OPS38), __CALC(a, b, c, d, OPS39), __CALC(a, b, c, d, OPS40), __CALC(a, b, c, d, OPS41), __CALC(a, b, c, d, OPS42), __CALC(a, b, c, d, OPS43), __CALC(a, b, c, d, OPS44), __CALC(a, b, c, d, OPS45), __CALC(a, b, c, d, OPS46), __CALC(a, b, c, d, OPS47), __CALC(a, b, c, d, OPS48), __CALC(a, b, c, d, OPS49), __CALC(a, b, c, d, OPS50), __CALC(a, b, c, d, OPS51), __CALC(a, b, c, d, OPS52), __CALC(a, b, c, d, OPS53), __CALC(a, b, c, d, OPS54), __CALC(a, b, c, d, OPS55), __CALC(a, b, c, d, OPS56), __CALC(a, b, c, d, OPS57), __CALC(a, b, c, d, OPS58), __CALC(a, b, c, d, OPS59), __CALC(a, b, c, d, OPS60), __CALC(a, b, c, d, OPS61), __CALC(a, b, c, d, OPS62), __CALC(a, b, c, d, OPS63),
#define CALC(...) _CALC(__VA_ARGS__)

#define _P2_HELPER(a, b, ...) a, b, __VA_ARGS__, b, a, __VA_ARGS__
#define _P3_HELPER(a, b, c, ...) _P2_HELPER(a, b, c, __VA_ARGS__), _P2_HELPER(b, c, a, __VA_ARGS__), _P2_HELPER(c, a, b, __VA_ARGS__)
#define P4 _P3_HELPER(a, b, c, d), _P3_HELPER(b, c, d, a), _P3_HELPER(c, d, a, b), _P3_HELPER(d, a, b, c)

#define PERM0 SEL4(P4)
#define PERM1 SEL4(RMAB(4, 1, P4))
#define PERM2 SEL4(RMAB(4, 2, P4))
#define PERM3 SEL4(RMAB(4, 3, P4))
#define PERM4 SEL4(RMAB(4, 4, P4))
#define PERM5 SEL4(RMAB(4, 5, P4))
#define PERM6 SEL4(RMAB(4, 6, P4))
#define PERM7 SEL4(RMAB(4, 7, P4))
#define PERM8 SEL4(RMAB(4, 8, P4))
#define PERM9 SEL4(RMAB(4, 9, P4))
#define PERM10 SEL4(RMAB(4, 10, P4))
#define PERM11 SEL4(RMAB(4, 11, P4))
#define PERM12 SEL4(RMAB(4, 12, P4))
#define PERM13 SEL4(RMAB(4, 13, P4))
#define PERM14 SEL4(RMAB(4, 14, P4))
#define PERM15 SEL4(RMAB(4, 15, P4))
#define PERM16 SEL4(RMAB(4, 16, P4))
#define PERM17 SEL4(RMAB(4, 17, P4))
#define PERM18 SEL4(RMAB(4, 18, P4))
#define PERM19 SEL4(RMAB(4, 19, P4))
#define PERM20 SEL4(RMAB(4, 20, P4))
#define PERM21 SEL4(RMAB(4, 21, P4))
#define PERM22 SEL4(RMAB(4, 22, P4))
#define PERM23 RMAB(4, 23, P4)

#define MERGE                           \
    s.merge(decltype(s){CALC(PERM0)});  \
    s.merge(decltype(s){CALC(PERM1)});  \
    s.merge(decltype(s){CALC(PERM2)});  \
    s.merge(decltype(s){CALC(PERM3)});  \
    s.merge(decltype(s){CALC(PERM4)});  \
    s.merge(decltype(s){CALC(PERM5)});  \
    s.merge(decltype(s){CALC(PERM6)});  \
    s.merge(decltype(s){CALC(PERM7)});  \
    s.merge(decltype(s){CALC(PERM8)});  \
    s.merge(decltype(s){CALC(PERM9)});  \
    s.merge(decltype(s){CALC(PERM10)}); \
    s.merge(decltype(s){CALC(PERM11)}); \
    s.merge(decltype(s){CALC(PERM12)}); \
    s.merge(decltype(s){CALC(PERM13)}); \
    s.merge(decltype(s){CALC(PERM14)}); \
    s.merge(decltype(s){CALC(PERM15)}); \
    s.merge(decltype(s){CALC(PERM16)}); \
    s.merge(decltype(s){CALC(PERM17)}); \
    s.merge(decltype(s){CALC(PERM18)}); \
    s.merge(decltype(s){CALC(PERM19)}); \
    s.merge(decltype(s){CALC(PERM20)}); \
    s.merge(decltype(s){CALC(PERM21)}); \
    s.merge(decltype(s){CALC(PERM22)}); \
    s.merge(decltype(s){CALC(PERM23)})

int dict[256];
const auto _STATIC_ = []() {
    dict['+'] = 0;
    dict['-'] = 1;
    dict['*'] = 2;
    dict['/'] = 3;
    return 0;
}();

struct Node {
    u64 hash;
    double data;

    Node(const int& type,
         i64 a,
         i64 b,
         i64 c,
         i64 d,
         const char* opab,
         const char* opbc,
         const char* opcd,
         const double& _data) : data(_data) {
        // 0 -> (((a b) c) d)
        // 1 -> ((a (b c)) d)
        // 2 -> (a ((b c) d))
        // 3 -> (a (b (c d)))
        // 4 -> ((a b) (c d))
        switch (type) {
            case 0: break;
            case 1:
                if (!valid(dict[*opab], dict[*opbc])) data = 0;
                break;
            case 2:
                if (!valid(dict[*opab], dict[*opcd])) data = 0;
                break;
            case 3:
                if (!valid(dict[*opab], dict[*opbc]) || !valid(dict[*opbc], dict[*opcd])) data = 0;
                break;
            case 4:
                if (!valid(dict[*opbc], dict[*opcd])) data = 0;
                break;
        }
        hash = 0;
        (hash += a) <<= 7;
        (hash += b) <<= 7;
        (hash += c) <<= 7;
        (hash += d) <<= 2;
        (hash += dict[*opab]) <<= 2;
        (hash += dict[*opbc]) <<= 2;
        (hash += dict[*opcd]) <<= 3;
        hash += type;
    }

    inline constexpr bool valid(const int& a, const int& b) const {
        if (a == 0) return b > 1;
        if (a == 2) return b < 2;
        return true;
    }

    bool operator<(const Node& rhs) const { return hash < rhs.hash; }
};

// for debug
inline void decode(u64 hash) {
#define _decode(val, n) val = hash & ((1 << n) - 1); hash >>= n

    static const char _[] = "+-*/";
    int type, a, b, c, d, opab, opbc, opcd;

    _decode(type, 3);
    _decode(opcd, 2);
    _decode(opbc, 2);
    _decode(opab, 2);
    _decode(d, 7);
    _decode(c, 7);
    _decode(b, 7);
    _decode(a, 7);

    switch (type) {
        case 0: cerr << "(((" << a << " " << _[opab] << " " << b << ") " << _[opbc] << " " << c << ") " << _[opcd] << " " << d << ")" << endl; break;
        case 1: cerr << "((" << a << " " << _[opab] << " (" << b << " " << _[opbc] << " " << c << ")) " << _[opcd] << " " << d << ")" << endl; break;
        case 2: cerr << "(" << a << " " << _[opab] << " ((" << b << " " << _[opbc] << " " << c << ") " << _[opcd] << " " << d << "))" << endl; break;
        case 3: cerr << "(" << a << " " << _[opab] << " (" << b << " " << _[opbc] << " (" << c << " " << _[opcd] << " " << d << ")))" << endl; break;
        case 4: cerr << "((" << a << " " << _[opab] << " " << b << ") " << _[opbc] << " (" << c << " " << _[opcd] << " " << d << "))" << endl; break;
    }

#undef _decode
}

int main() {
    i64 a, b, c, d;
    set<Node> s;
    cin >> a >> b >> c >> d;

    vector<i64> v{a, b, c, d};
    sort(v.begin(), v.end());
    do {
        s.merge(decltype(s){CALC(v[0], v[1], v[2], v[3])});
    } while (next_permutation(v.begin(), v.end()));

    // or
    // MERGE;

    int cnt = 0;
    for (const auto& [hash, data] : s) if (abs(data - 24) <= 1e-7) ++cnt;
    cout << cnt;
    return 0;
}
```

---

## 作者：yeshubo_qwq (赞：5)

## 题意
求有几种方式算出 $24$ 点。

## 思路
大致思路：dfs 排列每种情况，再暴力枚举运算符号，最后判断是否算出 $24$ 并去重求出答案。

这里讲一下几个注意点：

1.注意判断实数计算的误差。

2.括号前面是减号、除号，加上括号要变号，因此加上括号后可能与枚举的符号不同。

3.判重可以将先将算式转为后缀表达式，再用状压将后缀表达式转成数，并用 map 去重。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const double check=1e-6;//实数计算误差
int ans,v[5],pm[5],f[5],g[5];
map<int,int> mp;
double num(double x,double y,int z){//计算
	switch(z){//z表示运算符：0加，1减，2乘，3除
		case 0:return x+y; break;
		case 1:return x-y; break;
		case 2:return x*y; break;
		case 3:return x/y; break;
	}
}
double Abs(double p){//实数绝对值
	return (p<0?-p:p);
}
int useful(int a,int b){//能不能加括号
//括号前面是减号、除号，加上括号要变号
	if(a%2==1) return 1;
	if(!a) return (b>1?1:0);
	else return (b<2?1:0);
}
void mplus(int a1,int a2,int a3,int a4,int a5,int a6,int a7){//map+状压去重
	int x=(a1|a2<<3|a3<<6|a4<<9|a5<<12|a6<<15|a7<<18);
    if(++mp[x]==1)ans++;
}
int find(int x){//x是第几个
	for(int i=1;i<=4;i++)
		if(f[i]==x)return i;
}
void count(int a,int b,int c,int d){//暴力计算
	for(int i=0;i<=3;i++)//i,j,k枚举符号
	for(int j=0;j<=3;j++)
	for(int k=0;k<=3;k++){
/*		5种添括号
      	(1,2,3,4)
		((1,2),(3,4))
		(1,(2,3,4))
		((1,(2,3)),4)
		(1,(2,(3,4)))*/
		int u1=useful(k,j), u2=useful(j,i);
		if( Abs((num( num( num(a,b,i) ,c,j),d,k)  -24 ))<check)
			mplus(pm[find(a)],pm[find(b)],(i+4),pm[find(c)],(j+4),pm[find(d)],(k+4));
		if(u1==1&& Abs(num( num(a,b,i),num(c,d,j) , k)   -24 )<check)
			mplus(pm[find(a)],pm[find(b)],(i+4),pm[find(c)],pm[find(d)],(j+4),(k+4));
		if(u1==1&& Abs(num(a,num( num(b,c,i),d,j),k)     -24 )<check)
			mplus(pm[find(a)],pm[find(b)],pm[find(c)],(i+4),pm[find(d)],(j+4),(k+4));
		if(u2==1&& Abs(num(num(a, num(b,c,i) ,j),d,k)    -24 )<check)
			mplus(pm[find(a)],pm[find(b)],pm[find(c)],(i+4),(j+4),pm[find(d)],(k+4));
		if(u1==1&&u2==1&& Abs(num(a, num(b,num(c,d,i),j),k)-24 )<check)
			mplus(pm[find(a)],pm[find(b)],pm[find(c)],pm[find(d)],(i+4),(j+4),(k+4));
	}
}
void dfs(int x){//dfs求排列
	if(x>4){
		count(g[1],g[2],g[3],g[4]);
		return;
	}
	for(int i=1;i<=4;i++)
		if(v[i]==0)
			v[i]=1,g[x]=f[i],dfs(x+1),v[i]=0;
}
int main(){
	for(int i=1;i<=4;i++)scanf("%d",&f[i]);
	for(int i=1;i<=4;i++)
		for(int j=1;j<=4;j++)
			pm[i]=pm[i]+(f[i]<f[j]?1:0);//排第几，用于状压判重（最大0）
	dfs(1);
	printf("%d",ans);
}
}
```


---

## 作者：幽灵特工 (赞：4)

## 小学生秒懂系列。

[欢迎进入 blog 查看你的小学生秒懂系列都更新了啥。](https://www.luogu.com.cn/blog/Liya2304238405/#type=%E9%A2%98%E8%A7%A3)

这题难度应该绿色以下吧。。。

枚举。

- 枚举 a、b、c、d 四个数字，可以使用 next_permutation。复杂度 $A_4^4$。

- 枚举四则运算。这里可以用数字标记四则运算，同样用      next_permutation 枚举数字。复杂度 $4^3$。

- 枚举括号。括号只有以下五种情况：

```
无括号
(a b)(c d)
a (b c d)
(a (b c))d
a(b(c d))
```

所以总枚举复杂度是 $A_4^4\times 4^3\times 5=7680$。

枚举完计算中缀表达式即可，由于使用了 next_permutation 故不必判重。

---

## 作者：FZY_CZY (赞：3)

感觉出不到绿。

# 题意
就是 $24$ 点，知道什么是 $24$ 点的可以跳过了。

所谓 $24$ 点，就是给我们四个数 $a,b,c,d$，将他们通过四则运算和括号，得出 $24$。

如果这样介绍不明白的话，我们不妨看个例子。

给定四个数 $1,2,3,5$，我们可以通过 $(1+2)\times(3+5)$，得到 $24$，这就是 $24$ 点。

知道了这个以后，我们来看一下题目问的是什么。题目的意思就是给定这四个数，问有多少种“凑”出 $24$ 的方法。
# 思路
## 做法
我们发现，这道题中我们只需要在两个数之间枚举这些四则运算法符号，然后枚举括号的位置，这样我们只需要一个深搜就 OK 了，dfs 可以很好的解决这个问题。
## 细节
在暴力枚举的过程中，我们要注意判重，不然会多计数。

还有，我们在计算实数的时候可能会有误差，建议定义一个 `eps`，存储 $10^{-7}$，防止有精度的问题。

代码就不给了，完结撒花！！！

---

## 作者：wutiruo (赞：3)

### 前言

~~不会吧不会吧，不会有人不打表吧(~~

提示：本题涉及到命令行的部分需使用 Windows 系统

---------------------------

### 分析

首先，直接手写这个大分讨很明显是不现实的~~因为我试过~~。所以，打表就从写 generator 入手。

对于这题要分讨的是括号的情况，因此我的 generator 输入一个带下划线的字符串，会自动将其中的下划线替换成为运算符，详情请见以下代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
string str;
void dfs(unsigned pos){
	if(pos==str.size()){
		printf("\t\tans+=(fabs((%s)-24.0)<=eps);\n",str.c_str());
		//直接作为语句打印到cpp文件内
		return;
	}
	if(str[pos]=='_'){
		str[pos]='+';
		dfs(pos+1);
		str[pos]='-';
		dfs(pos+1);
		str[pos]='*';
		dfs(pos+1);
		str[pos]='/';
		dfs(pos+1);
		str[pos]='_';
	}
	else
		dfs(pos+1);
}
signed main(){
	while(cin>>str){
		cout<<"//"<<str<<endl;
		//在每一大段代码块前标出所属的括号式类型
		dfs(0);
		cout<<endl<<endl;
	}
	return 0;
}
```

__Generator Input__
```
A_B_C_D
(A_B)_C_D
A_B_(C_D)
(A_B)_(C_D)
A_(B_C)_D
(A_B_C)_D
(A_(B_C))_D
A_(B_C_D)
A_((B_C)_D)
A_(B_(C_D))
^Z
```

我们在命令行中运行 Generator

```gen.exe >P2277.cpp```

最后记得要加 Ctrl + Z 结束程序

----------------------

### 调试

接下来才是这题最 ** 的地方：判重。

看到讨论版很多人对于这题重复的定义有疑义，经过测试，重复应当指：

__仅去掉算式中的一个括号后，算式的运算顺序没有改变__

因此，我们把所有的不符合要求的剔除。（说起来容易实际上很难受）

一开始长达 $ 600 $ 行的程序就缩成了 $ 300 $ 行

为了不影响观感，不会在这里放那长达 $ 8 $ KB 的 AC 代码（实际上全都是相同的语句，核心部分即情况数量只有约 $ 250 $ 种）

[于是就成为了本题目前最优解](https://www.luogu.com.cn/record/list?pid=P2277&orderBy=1&status=&page=1)

[详细提交记录](https://www.luogu.com.cn/record/78328626)

看不到代码的给一个片段供参考
```cpp
		//A_B_C_D
		ans+=(abs((A+B+C+D)-24.0)<=eps);
		ans+=(abs((A+B+C-D)-24.0)<=eps);
		ans+=(abs((A+B+C*D)-24.0)<=eps);
		ans+=(abs((A+B+C/D)-24.0)<=eps);
		ans+=(abs((A+B-C+D)-24.0)<=eps);
		ans+=(abs((A+B-C-D)-24.0)<=eps);
		ans+=(abs((A+B-C*D)-24.0)<=eps);
		ans+=(abs((A+B-C/D)-24.0)<=eps);
		ans+=(abs((A+B*C+D)-24.0)<=eps);
		ans+=(abs((A+B*C-D)-24.0)<=eps);
		ans+=(abs((A+B*C*D)-24.0)<=eps);
		ans+=(abs((A+B*C/D)-24.0)<=eps);
		ans+=(abs((A+B/C+D)-24.0)<=eps);
		ans+=(abs((A+B/C-D)-24.0)<=eps);
		ans+=(abs((A+B/C*D)-24.0)<=eps);
		ans+=(abs((A+B/C/D)-24.0)<=eps);
		ans+=(abs((A-B+C+D)-24.0)<=eps);
		ans+=(abs((A-B+C-D)-24.0)<=eps);
		ans+=(abs((A-B+C*D)-24.0)<=eps);
		ans+=(abs((A-B+C/D)-24.0)<=eps);
		ans+=(abs((A-B-C+D)-24.0)<=eps);
		ans+=(abs((A-B-C-D)-24.0)<=eps);
		ans+=(abs((A-B-C*D)-24.0)<=eps);
		ans+=(abs((A-B-C/D)-24.0)<=eps);
		//以下省略约250行
```

### 小细节

```cpp
//这一小段是前置代码
//方便下面的讲解
int perm[5]={0,1,2,3,4};
double arr[5];
cin>>arr[1]>>arr[2]>>arr[3]>>arr[4];
```

本题涉及到的四个数字是无序的，因此，需要全排列。
但请一定注意全排列时不能这样：
```cpp
do{
	double &A=arr[perm[1]];
	double &B=arr[perm[2]];
	...C...
	...D...
	ans+=...;
	......
}while(next_permutation(perm+1,perm+5));
```
__因为这样对于样例这种四个一样的数就会使结果变为原来的 $  4 ! $ 倍，也就是 $ 24 $。__

而应该这样：
```cpp
sort(arr+1,arr+5);
do{
	double &A=arr[1];
	double &B=arr[2];
	...C...
	...D...
	ans+=...;
	......
}while(next_permutation(arr+1,arr+5));
```

~~这玩意坑了我 $ 1 $ h~~

-------------------------

完结撒花！

### 总结

这题如果找到了合适的方法（也不一定非要打表）也不会那么难，主要问题在于代码能力，所以我认为标为蓝题比较合适。

另外，对于打表，比赛时慎用，尤其是这种打表与手调结合的题，将会耗费大量时间！

推荐难度：提高+/省选-

---


# 队爷的新书

## 题目描述

队爷即将出版新书，以记录他辉煌的虐题生涯。。。

有 $n$ 家出版社对这本书表示了兴趣，并愿意给队爷支付 $p \in [Min_{pay},Max_{pay}]$ 的报酬来得到这本书的出版权，每家出版社的 $Min_{pay}$ 和 $Max_{pay}$ 是不一样的。

现在队爷希望你帮他找出一个报酬值 $p$，使得他获得的总报酬最多。（每一个 $Min_{pay} \leq p \leq Max_{pay}$ 的出版社都会付给队爷 $p$ 的报酬）。


## 说明/提示

【样例解释】

当 $p = 4$ 时，有 $3$ 家出版社会给出报酬，此时最大。

【数据规模与约定】

对于 $20\%$ 的数据，$1 \leq Min_{pay},Max_{pay} \leq 10000$；

对于 $40\%$ 的数据，$1 \leq n \leq 1000,1 \leq Min_{pay},Max_{pay} \leq 10^6$；

对于 $100\%$ 的数据，$1 \leq n \leq 100000,1 \leq Min_{pay},Max_{pay} \leq 10^9$。

## 样例 #1

### 输入

```
4
1 3
2 4
3 5
4 7```

### 输出

```
12
```

# 题解

## 作者：w23c3c3 (赞：10)

~~为什么题解区那么多人喜欢把差分弄成扫描线啊/yun~~

这题是求一个点$x$，最大化$x\sum\limits_{i=1}^n[x\in[l_i,r_i]]$

和别的题解想法一样，显然在右端点时最优

这时候就只需要求每个右端点被多少个区间包含

这时候每个右端点互不相关，为简化讨论先从小到大考虑右端点

先看左端点的限制，那么也就是求多少个$l_i\leq x(r_k)$     

这个显然sort一遍$l_i$，然后依次向后加入就行

再看$r_i$的限制，显然比他小的右端点（也就是之前枚举的右端点）都不行，他以及他之后的右端点都可以

这时候记录一下在他前面枚举了多少右端点就行了

这时候我们发现左端点和右端点的限制完全无关，这时候可以把左右端点分开，分别sort一遍，这时候在他前面枚举的右端点就是这个点的下标$-1$

然后基本上就能解决了

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long ans,g,n,i,l,a[100001],b[100001];
int main(){
	scanf("%lld",&n);
	for(i=1;i<=n;i++)scanf("%lld%lld",&a[i],&b[i]);
	sort(a+1,a+n+1);sort(b+1,b+n+1);
	l=1;
	for(i=1;i<=n;i++){
		while(l<=n&&a[l]<=b[i])l++;    //这里l是左端点<=r[i]的最大值的后一个，所以其实应该是l-1个
		ans=max((l-i)*b[i],ans);      //所以这里就变成(l-1-(i-1))*r[i]=(l-i)*r[i]
	}
	printf("%lld\n",ans);
}
```
~~喜提$O_2$最优解~~

---

## 作者：破忆 (赞：5)

### 题目大意
有n个区间，有左右边界，选择一个数，使覆盖这个点的区间数*这个数的大小最大


------------
### 分析
#### 怎样统计覆盖这个点的区间数？
有若干个区间，统计覆盖某个点的区间数，自然而然就想到了**扫描线**

扫描线的原理大致就是：每个区间的左端点+1，右端点右边的点-1，然后从前往后统计前缀和

这样做之后，区间之外的点都不受影响，区间内的点就加上了1

这样做，快速统计覆盖这个点的区间数就解决了，但对于这道题目，因为这个点越靠右越好，代码很简单，就是对这些点从左到右排序，然后记录下每个点的类型（左或右）


------------
### 解法
主要是扫描线，但这题还需要在一段内尽量选右边的点，所以还要把右端点一起统计，对于前缀和的影响是0，还有数据记得开long long


------------
### 代码
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=1e5+5;
int n,tot;
LL ans,now;
struct why{
	LL x,k;
	bool operator <(why b)const{return x<b.x||(x==b.x&&k<b.k);}//从左到右排序，位置相同的情况下先算右端点，防止多算
}a[3*maxn];
LL read(){//有一组数据有误，所以用long long读数据
	LL ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	freopen("P2352.in","r",stdin);
	freopen("P2352.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		LL x=read(),y=read();
		a[++tot]=(why){x,1};//左端点
		a[++tot]=(why){y,0};//右端点
		a[++tot]=(why){y+1,-1};//右端点右边
	}
	sort(a+1,a+1+tot);
	for(int i=1;i<=tot;i++){
		now+=a[i].k;//先更新一下前缀和
		ans=max(ans,now*a[i].x);//再计算最大值
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：翼德天尊 (赞：3)

题目给定了 $n$ 个区间，让你选定一个数，使得这个数被包含的区间个数与该数的乘积最大。

观察到：

> $1\le pay \le 10^9$

所以我们首先就想到先将数据离散化。

而由于给定一个区间可以转化为将该区间包含在内的数全部加 $1$。

则这道问题就可以转化为一个前缀和问题，使用一维差分处理区间，然后用前缀和处理被包含的区间个数即可。

所以这道题的大体思路为：

离散化，然后差分，最后前缀和处理答案。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 200005
ll n,cha[N],lsh[N],x[N],ans,now; 
int read(){
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}

int main(){
	n=read();
	for (int i=1;i<=n;i++){
		lsh[i*2-1]=x[i*2-1]=read(),lsh[i*2]=x[i*2]=read();
	}
	sort(lsh+1,lsh+1+2*n);
	ll g=unique(lsh+1,lsh+1+2*n)-lsh-1;//离散化
	for (int i=1;i<=n;i++){
		x[i*2-1]=lower_bound(lsh+1,lsh+1+g,x[i*2-1])-lsh;
		x[i*2]=lower_bound(lsh+1,lsh+1+g,x[i*2])-lsh;
		cha[x[i*2-1]]++,cha[x[i*2]+1]--;//差分
	}
	for (int i=1;i<=2*n;i++){//前缀和
		now+=cha[i];
		ans=max(ans,now*lsh[i]);//更新答案
	} 
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Jasmine_Aura (赞：3)

## 题意简化
给出 $n$ 个区间 $[l,r]$，用 $T_i$表示点 $i$ 被区间覆盖的次数，求 $i \times T_i$ 的最大值。

## 思路
我们可以先假设有一个序列，每个元素都表示该位置被区间覆盖的次数，初始化为 0，每次读入新区间的时候可以当做一次区间修改，即将 $[l,r]$ 内的元素 $+1$，暴力修改显然行不通。

考虑维护一个差分数组 $c$，每次修改将 $c_l+1$，将 $c_{r+1}-1$。最后只需要扫一遍差分数组做一遍前缀和，每次得到的数即为点 $i$ 被区间覆盖的次数，统计答案即可。

**小心哟！！！**

由于题面上给的数据范围 $1 \leq Minpay,Maxpay \leq 10^9$，直接开数组会炸，所以先做一下离散化，再进行上文提到的操作。 

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAX=5e5+5;
int arr[MAX];
int arr_temp[MAX];//用来离散化的临时数组 
int c[MAX];//差分数组 
signed main()
{
	//初始化--- 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>arr[i*2-1]>>arr[i*2];
		arr_temp[i*2-1]=arr[i*2-1];
		arr_temp[i*2]=arr[i*2];
	}
	//初始化--- 
	
	//离散化--- 
	sort(arr_temp+1,arr_temp+2*n+1);
	int cnt=unique(arr_temp+1,arr_temp+2*n+1)-arr_temp-1;
	for(int i=1;i<=n;i++)
	{
		arr[i*2-1]=lower_bound(arr_temp+1,arr_temp+cnt+1,arr[i*2-1])-arr_temp;
		arr[i*2]=lower_bound(arr_temp+1,arr_temp+cnt+1,arr[i*2])-arr_temp;
		//离散化--- 
		
		//差分--- 
		c[arr[i*2-1]]++;
		c[arr[i*2]+1]--;
		//差分--- 
	}
	//统计答案--- 
	int ans=0,temp=0;//ans为答案，temp为前缀和 
	for(int i=1;i<=2*n;i++)
	{
		temp+=c[i];
		ans=max(ans,temp*arr_temp[i]);
	}
	cout<<ans<<endl;
	//统计答案--- 
	return 0;
}
```


---

## 作者：Npse_D (赞：2)

有一个点不在10^9范围内。题目有误注意开ll。

用两个优先队列，一个存+点，一个存-点。贪心，只有-点可以更新ans最大值，因为它当前的倍数还没有--，而当前状态值一定比它的+点大。

这可以说是扫描线的思想。

所以每次让这两个队列弹出一个元素，比较一下大小，然后胡搞就可以了。（这难度真的是提高+/省选嘛……感觉pj+提高差不多）

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<long long int,vector<long long int>,greater<long long int> >qin;
priority_queue<long long int,vector<long long int>,greater<long long int> >qpo;
int n;
long long int ans,Min_payi,Max_payi;
int main(){
    int nowsize=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>Min_payi>>Max_payi;
        qin.push(Min_payi);
        qpo.push(Max_payi);
    }
    while(!qin.empty()){
        long long int a=(int)qin.top();
        long long int b=(int)qpo.top();
        if(a>b){
            ans=max(ans,b*nowsize);
            nowsize--;
            qpo.pop();
        }
        if(b>a){
            nowsize++;
            qin.pop();
        }
        if(a==b){
            ans=max(ans,a*(nowsize+1));
            qin.pop();
            qpo.pop();
        }
    }
    while(!qpo.empty()){
        long long int b=(int)qpo.top();
        ans=max(ans,b*nowsize);
        nowsize--;
        qpo.pop();
    }
    cout<<ans;
}
```

---

## 作者：lxuyinc (赞：1)

## 前言

还有几个月就是 NOIP 了，~~A 了这道题~~，祝各位成功！

## 题意

大致看一下应该就知道这是一道一维的区间覆盖问题。

## 思路

迫不及待准备桶排，一看数据范围直接放弃：$1\leq n\leq 10^{5},1\leq  Min\_pay,Max\_pay\leq 10^{9}$。

既然区间长度可以达到数组都难以存下的数量级，枚举显然不现实，但有什么办法可以解决覆盖问题呢？

显然，我们首先想到的是差分，每次覆盖操作的复杂度只有 $\operatorname O(1)$ 怎能不令人感到愉悦呢？

所以便有了 40 分的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3,M=1e7+3;
int n,maxn,pos;
long long ans;
struct line{
	int l,r;
	friend bool operator <(line x,line y){
		return x.r<y.r;
	}
} a[N];
int vis[M];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].l>>a[i].r,maxn=max(maxn,a[i].r);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){	//减小区间枚举量，然而并没有什么大用
		if(a[i].r*n>=maxn){
			pos=i;
			break;
		}
	}
	for(int i=pos;i<=n;i++){
		a[i].l-=a[pos-1].r;
		a[i].r-=a[pos-1].r;
		if(a[i].l<0) a[i].l=0;
	}
	for(int i=pos;i<=n;i++){	//差分
		vis[a[i].l]++;
		vis[a[i].r+1]--;
	}
	for(int i=1;i<=a[n].r;i++){
		vis[i]+=vis[i-1];
	}
	for(int i=1;i<=a[n].r;i++){
		ans=max(ans,1ll*vis[i]*(i+a[pos-1].r));
	}
	cout<<ans;
	return 0;
}
```

剩下六个测试点都是 RE，进一步便可以想到区间范围太大，数组存不下。考虑换一个思路：对于区间数量，题中明确表示这是你可以存下的；那么考虑对区间左右端点进行离散化操作，正解代码便呼之欲出。

## Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+3;
int n,maxn,pos,cnt;
long long ans;
struct line{
	int l,r;
} a[N];
int lsh[N*2],vis[N];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].l>>a[i].r;
		lsh[++cnt]=a[i].l,lsh[++cnt]=a[i].r;
	} 
	sort(lsh+1,lsh+1+cnt);
	cnt=unique(lsh+1,lsh+cnt+1)-(lsh+1);
	for(int i=1;i<=n;i++){
		a[i].l=lower_bound(lsh+1,lsh+1+cnt,a[i].l)-(lsh+1);
		a[i].r=lower_bound(lsh+1,lsh+1+cnt,a[i].r)-(lsh+1);
	}
    //以上是离散化过程
	for(int i=1;i<=n;i++){
		vis[a[i].l]++;
		vis[a[i].r+1]--;
	}	//差分
	for(int i=1;i<=cnt;i++){
		vis[i]+=vis[i-1];
	}	//前缀和求某点被区间覆盖的数量
	for(int i=1;i<=cnt;i++){
		if(pos==vis[i]) continue;
		ans=max(ans,1ll*vis[i]*lsh[i+1]);
	}	//求解答案
	cout<<ans;
	return 0;
}
```
完结撒花！



---

## 作者：Rainsleep (赞：1)

不妨将每个区间转化为一对括号，不难发现**最优解一定在某个右括号上**。

这里给出证明：

反证法，若最优解在某个**区间中**，那么分情况讨论：

+ 当前区间不套着小区间

显然此时将最优解向右挪动一个单位，优于原先最优解，矛盾。

+ 当前区间套着小区间

其实等价于在情况 $1$ 内添加一个小区间，不妨将大区间设为 $A$，小区间设为 $B$。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4y8hf0u.png)

红色区间是一定不会被选择的：
+ 对于区间 $1$，不妨选择 $A$ 的右端点，对于区间 $2$，不妨选择 $A$ 的右端点，**越靠右越优**。

那么对于中间的这一段，覆盖数量都是 $2$，不妨选择右端点的位置，最大化 $x$。

+ 区间套区间套 $\cdots$ 套区间

如果都是新区间完美被旧区间嵌套的情况，显然每套一个区间就会多出两段红色部分，依然像上文那样论证即可。

但是如果新区间不能被完美嵌套再旧区间时，情况如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/1g0xxbe2.png)

此时不妨将新区间切开，显然两部分的情况综合即为新区间的所有情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/zsp2gmsh.png)

此时问题转化为上一种情况。

那么整个问题就转化为了，在所有 $n$ 个区间的右端点中，选择一个点使其在最多的括号内。

考虑括号能被取到的范畴，对于一个右端点而言，数轴上其前的左端点是最多的括号数量，右括号在其前的括号，是提前结束，即不把当前左端点包含的一对括号。不妨维护一个指针，指向**第一个坐标在当前右端点之后的左括号的下标**，不妨设其为 $ptr$，那么所有在 $ptr$ 之前的右括号都满足在当前右端点前开始，总共有 $ptr-1$ 个。对于右端点，所有在当前右端点之前的右括号都是已经结束的括号，总共 $i-1$ 个，那么满足要求的区间数量总共是 $(ptr-1)-(i-1)=ptr-1-i+1=ptr-i$ 个。

代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
long long a[N], b[N], res = INT_MIN, n;

int main()
{
	scanf("%lld", &n);
	for(int i(1);i <= n; ++ i)
		scanf("%lld %lld", &a[i], &b[i]);
	sort(a + 1, a + 1 + n), sort(b + 1, b + 1 + n);
	int ptr = 1;
	for(int i(1);i <= n; ++ i)
	{
		while(ptr <= n and a[ptr] <= b[i])
			++ ptr;
		res = max(res, (ptr - i) * b[i]);
	}
	printf("%lld", res);
	return 0;
}
```

---

## 作者：wtxy2006 (赞：1)

### Describe:
$n$ 条线段在数轴上，定义数轴上一点 $X$ 的 $value=覆盖X的线段数 \times X$，求一点 $X$ 使得 $value$ 最大。
### Solution:
主要思路：离散化，差分。
注意到点最大能到 $1e9$，但是最多只有 $1e5$ 个点，所以使用离散化。

然后统计每个点被覆盖的次数，显然这是一个区间加法问题，差分加前缀和就行了。

最后在枚举选这个点时，$value$ 为多少，取最大值即可。

### Code:
附上丑陋的代码~~
```cpp
// P2352 队爷的新书
#include <algorithm>
#include <cstdio>
#include <iostream>
#define int long long
#define MN 1000005
using namespace std;
inline int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
  return x * f;
}
int n, a[MN], b[MN], f[MN * 2], cnt = 0, s[MN * 2], ans;
signed main() {
  n = read();
  for (int i = 0; i < n; i++)
    a[i] = f[cnt++] = read(), f[cnt++] = b[i] = read();
  sort(f, f + cnt), cnt = unique(f, f + cnt) - f;
  for (int i = 0; i < n; i++)
    a[i] = lower_bound(f, f + cnt, a[i]) - f,
    b[i] = lower_bound(f, f + cnt, b[i]) - f;
  for (int i = 0; i < n; i++) {
    s[a[i]]++, s[b[i] + 1]--;
  }
  for (int i = 1; i < cnt + 1; i++) s[i] += s[i - 1];
  int now = 0;
  for (int i = 1; i < cnt + 1; i++) {
    if (now == s[i]) continue;
    ans = max(ans, s[i - 1] * f[i - 1]);
  }
  printf("%lld", ans);
  return 0;
}
```

---

## 作者：星爵 (赞：1)


昨天做模拟赛，没做出来，只写了个暴力

今天上午看了看标程   。。。。。


很多区间把数轴分成了很多段，看哪个点的(区间覆盖数\*该点权值)最大。


显然在某个区间的右端点的答案是最优的。


排序后 用扫描线从左到右扫描，维护每个点的覆盖数，就是遇到左端点时cnt++，右端点时更新ans、cnt--。


若某个点既有左端点，又有右端点，就把左端点放在前面。


**蒟蒻代码如下**



```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<string>
#define maxn 250000
#define ll long long
using namespace std;
ll n,tot,a[maxn],b[maxn],c[maxn];
ll d[maxn],s[maxn];
bool cmp(int x,int y)
{
    return a[x]<a[y];
}
int main()
{
   //freopen("book.in","r",stdin);
//freopen("book.out","w",stdout);
   scanf("%lld",&n);
    for(int i=1;i<=n;i++)
        scanf("%lld%lld",&a[i],&a[n+i]);
    for(int i=1;i<=2*n;i++)
        c[i]=i;
    sort(c+1,c+2*n+1,cmp);
    tot=0;
    for(int i=1;i<=2*n;i++)
    {
        if(i==1||a[c[i]]!=a[c[i-1]])
            tot++;
        b[c[i]]=tot;
        d[tot]=a[c[i]];
    }
    for(int i=1;i<=n;i++)
    {
        s[b[i]]++;
        s[b[n+i]+1]--;
    }
    for(int i=1;i<=tot;i++)
        s[i]+=s[i-1];
    int ans=0;
    for(int i=1;i<=tot;i++)
        if(s[i]*d[i]>d[ans]*s[ans])
            ans=i;
    printf("%lld\n",d[ans]*s[ans]);
    return 0;
}
```

---

## 作者：善良的死神 (赞：1)

```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<string>
#define inf 1000000000
#define maxn 250000
#define maxm 500+100
#define eps 1e-10
#define ll long long
#define pa pair<int,int>
#define for0(i,n) for(int i=0;i<=(n);i++)
#define for1(i,n) for(int i=1;i<=(n);i++)
#define for2(i,x,y) for(int i=(x);i<=(y);i++)
#define for3(i,x,y) for(int i=(x);i>=(y);i--)
#define mod 1000000007
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=10*x+ch-'0';ch=getchar();}
    return x*f;
}
ll n,tot,a[maxn],b[maxn],c[maxn],d[maxn],s[maxn];
inline bool cmp(int x,int y){return a[x]<a[y];}
int main()
{
    freopen("book.in","r",stdin);
    freopen("book.out","w",stdout);
    n=read();
    for1(i,n)a[i]=read(),a[n+i]=read();
    for1(i,2*n)c[i]=i;
    sort(c+1,c+2*n+1,cmp);
    tot=0;
    for1(i,2*n)
    {
        if(i==1||a[c[i]]!=a[c[i-1]])tot++;
        b[c[i]]=tot;d[tot]=a[c[i]];
    }
    for1(i,n)
    {
        s[b[i]]++;s[b[n+i]+1]--;
    }
    for1(i,tot)s[i]+=s[i-1];
    int ans=0;
    for1(i,tot)if(s[i]*d[i]>d[ans]*s[ans])ans=i;
    printf("%lld\n",d[ans]*s[ans]);
    return 0;
}
```
20分算法：枚举所有的p，用O(n)的时间计算出包含它的区间数，时间复杂度O（n\*max\_p）。
40分算法1：显然p最优时一定会在区间端点上，所以只需要枚举2n个端点即可，时间复杂度O(n2)。

40分算法2：用left[i]表示i报酬上的左端点数，left[i]表示右端点数，则用O(max\_p)的时间扫一遍就可以计算出每一个p被包含的次数，再枚举所有端点即可，时间复杂度O(max\_p)。

100分算法：注意到40分算法2的瓶颈是max\_p，但是只有2n个端点，因此我们对2n个端点进行离散化，这样就可以在O(n)的时间内计算出每一个p被包含的次数，时间复杂度为O(n)。

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ 扫描线\*权值


---

## 作者：SilverLi (赞：0)

[队爷的新书 の 传送门](https://www.luogu.com.cn/problem/P2352)

考虑从小到大枚举每一个右端点。

因为不能少于左端点，即找到最后一个满足条件 $L_i\leq R_{now}$ 的 $i$。

因为比当前的 $now$ 小的右端点都不能算作答案，所以区间长度为 $now-i$。

可以发现，左端点和右端点的限制对答案不会产生影响，所以分开排序和处理才能得到最优解。

> $1 \le N \le 10^5$

> $1 \le L_i,R_i \le 10^9$

所以要开 `long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5;
int n,ans,i=1,now=1;
int L[N],R[N];
signed main() {
	cin>>n;
	for(int i=1;i<=n;++i)	cin>>L[i]>>R[i];
	sort(L+1,L+n+1),sort(R+1,R+n+1);
	while(now++<=n) {
		while(i<=n&&L[i]<=R[now])	++i;
		ans=max(ans,R[now]*(i-now));
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：青丘杨哲 (赞：0)

其实本题不需要扫描线、线段树或任何其他技能，只需要离散化和前缀和。甚至连任何思想都谈不上。

首先对所有区间中出现的值进行离散化。由于离散化后区间中间的值会被忽略，我们需要证明最优答案一定落在端点（右端点）上。证明如下：

假设最优答案并不是落在右端点上，那么设它所处的区间中右边界最小的区间为$[l_0,r_0]$。显然，对于它所处的其它任意区间$[l,r]$，都有$ r_0 \leqslant r$。所以将最优值调整为$r_0$，并不会影响其所处区间的数量，但获得的总报酬却提高了。因此最优值一定落在某个区间的右端点上。

接下来需要解决的问题就是求出在值域已经有限的区间中，一个特定的值所处区间的数量，记为$s_i$，同时记该特定值为$a_i$。

由于其满足的区间的数量为：

$$s_i=\operatorname{Count}_{l_j \leqslant a_i, a_i \leqslant r_j} (j)$$

利用容斥原理，可以得到该数量等价于总区间数减去$l_j>a_i$或$r_j<a_i$的区间数。同时，$l_j>a_i$和$r_j<a_i$两个条件相互独立，不会重合。因此：

$$s_i=n-\operatorname{Count}_{l_j>a_i}(j)-\operatorname{Count}_{r_j<a_i}$$

用前缀和预处理出$\operatorname{Count}$的值即可。

枚举每个区间的右端点$r_i$，计算出其$s_i$值，并用$r_i·s_i$与$ans$打擂，即可得出答案。

参考程序：

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN=(2e5+5);
int N,cnt,lmt,pres[MAXN],afts[MAXN];
int flg1[MAXN],flg2[MAXN];
LL ans;
struct node{
	LL l,r; int lrk,rrk;
}a[MAXN];
struct num{
	int id,kd,rk; LL val;
}b[MAXN];
bool cmp(num p,num q){
	return p.val<q.val;
}
int main(){
	scanf("%d",&N);
	for (int i=1;i<=N;i++){
		scanf("%lld%lld",&a[i].l,&a[i].r);
		b[++cnt].id=i,b[cnt].kd=1,b[cnt].val=a[i].l;
		b[++cnt].id=i,b[cnt].kd=2,b[cnt].val=a[i].r;
	}
	sort(b+1,b+cnt+1,cmp);
	for (int i=1;i<=cnt;i++){
		if (b[i].val==b[i-1].val&&i!=1) b[i].rk=b[i-1].rk;
		else b[i].rk=b[i-1].rk+1;
		lmt=max(lmt,b[i].rk);
	}
	for (int i=1;i<=cnt;i++){
		if (b[i].kd==1) a[b[i].id].lrk=b[i].rk;
		else a[b[i].id].rrk=b[i].rk;
	}
	for (int i=1;i<=N;i++)
		flg1[a[i].lrk]++,flg2[a[i].rrk]++;
	for (int i=lmt;i>=1;i--)
		pres[i]=pres[i+1]+flg1[i+1];
	for (int i=1;i<=lmt;i++)
		afts[i]=afts[i-1]+flg2[i-1];
	for (int i=1;i<=N;i++)
		ans=max(ans,a[i].r*(N-pres[a[i].rrk]-afts[a[i].rrk]));
	printf("%lld",ans);
	return 0;
}

```

---

## 作者：寒鸽儿 (赞：0)

看题的话,第一反应应该是前缀和  
然后发现值域上限为1e9  
数组开不下？  
然后想到扫描线式的处理方法  
排序所有前后端点向后扫可以求得特殊点(起点、终点)的前缀和  
我们可以证明最佳答案一定落在某个终点上  
窝也不会形式化地证明但是感性理解一下  
```cpp
#include <cstdio>
#include <algorithm>
#define ll long long

using namespace std;

const int N = 123456;

struct pt {
	int x, lr;
	pt() {}
	pt(int X, int LR) : x(X), lr(LR) {}
	bool operator < (const pt& o) const { return x < o.x; }
} pot[N*3], poa[N*3];
int top = 1;

int main() {
	int n;
	ll l, r;
	scanf("%d", &n);
	for(int i = 0; i < n; ++i) {
		scanf("%lld %lld", &l, &r);
		pot[i*3] = pt(l, 1); pot[i*3+1] = pt(r+1, -1); pot[i*3+2] = pt(r, 0);
	}
	sort(pot, pot + n*3);
	poa[0] = pot[0];
	for(int i = 1; i < n*3; ++i) {
		if(pot[i].x == pot[i-1].x) poa[top-1].lr += pot[i].lr;
		else poa[top++] = pot[i];
	}
	ll num = 0, ans = 0;
	for(int i = 0; i < top; ++i) {
		num += poa[i].lr;
		ans = max(ans, num * poa[i].x);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---


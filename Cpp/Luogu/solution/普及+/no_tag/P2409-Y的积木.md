# Y的积木

## 题目背景

Y 是个大建筑师，他总能用最简单的积木拼出最有创意的造型。

## 题目描述

Y 手上有 $n$ 盒积木，每个积木有个重量。现在他想从每盒积木中拿一块积木，放在一起，这一堆积木的重量为每块积木的重量和。现在他想知道重量和最小的 $k$ 种取法的重量分别是多少。（只要任意更换一块积木，就视为一种不同的取法。如果多种取法重量总和一样，我们需要输出多次。）

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$2 \le m_i \le 10$，$1 \le n \le 10$。
- 对于 $50\%$ 的数据，$2 \le m_i \le 50$，$1 \le n \le 50$。
- 对于 $100\%$ 的数据，$2 \le m_i \le 100$，$1 \le n \le 100$，$1 \le k \le 10^4$，每个积木的重量为不超过 $100$ 的正整数，所有 $m_i$ 的积大于等于 $k$。

本题不卡常。

## 样例 #1

### 输入

```
3 10
4 1 3 4 5
3 1 7 9
4 1 2 3 5
```

### 输出

```
3 4 5 5 6 6 7 7 7 7
```

# 题解

## 作者：Rockey0515 (赞：4)

题意是 $n$ 组，第 $i$ 组有 $m_i$ 个，每组选 $1$ 个，要找和前 $k$ 小的所有方案。

考虑广搜求解。

首先对每组里的数排序，这样可以保证后搜到的比前搜到的大，但是实践证明，不排序也一样，更新数据后仍然是这样。

对于样例：
```
3 10

4 1 3 4 5

3 1 7 9

4 1 2 3 5


```
首先每组指针都在每组第一个：
```
3 10

4 1 3 4 5
x ^
3 1 7 9
x ^
4 1 2 3 5
x ^

```
和为 $3$，然后每个指针都可以加一，最小的是把最后的指针向后移，此时为：
```
3 10

4 1 3 4 5
x ^
3 1 7 9
x ^
4 1 2 3 5
x x ^

```
和为 $4$，然后可以发现后面搜的可能比前面的小，所以广搜需要用优先队列。

具体实现方法在注释里。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k;
struct u{
    vector<int>z;int s,h;
    //z 表示每个组的指针，s 标识和，h 表示活动指针
    //如果没有 h 则会出现重复
    //h 到 n 是可以向后移的指针的范围
    //不然 100 和 001 都可以扩展出 101
    const bool operator < (const u &o)const{//重载小于号
        return s>o.s;
    }
};
priority_queue <u>q;//优先队列
vector<int>a[109];//存储数组
int main(){
    cin>>n>>k;
    for (int i=1;i<=n;i++){
        cin>>m;
        for (int j=1;j<=m;j++){
            int k;
            cin>>k;
            a[i].push_back(k);//输入数据
        }
    }
    u t;t.s=0;t.h=1;
    for (int i=1;i<=n;i++){
        t.z.push_back(0);t.s+=a[i][0];
    }//初始时位置
    q.push(t);//放入q
    while (k>0){//开始广搜
        k--;
        cout<<q.top().s<<" ";//输出
        t=q.top();
        q.pop();
        m=t.h;
        for (int i=t.h;i<=n;i++){//往下拓展
            if (t.z[i-1]+1<a[i].size()){
                t.z[i-1]++;
                t.s+=a[i][t.z[i-1]]-a[i][t.z[i-1]-1];
                t.h=i;
                q.push(t);
                t.h=m;
                t.s-=a[i][t.z[i-1]]-a[i][t.z[i-1]-1];
                t.z[i-1]--;
            }
        }
    }
}
```


---

## 作者：bingzhi314 (赞：3)

# [题目](https://www.luogu.com.cn/problem/P2409)  
经过多次尝试后，发现用堆是做不出来了。

于是还是用了背包。
### 由题可见，本题用~~分组~~
于是可写以下代码：  
```
for(int i=1;i<=n;i++){  
      for(int j=0;j<=m;j++){//注：
  			for(int k=1;k<=v[i][0];k++){
  				if(v[i][k]<=j){
  					f[i][j]+=f[i-1][j-v[i][k]];
    		    }
    		}
       }
}
`````
虽**不允许不选**第i组的物品，但j很小时**可能**会存在某些组的物品一个也放不进的情况，但是这不影响我们要求的答案。因为，~~题目描述~~的前x小的体积和，在遍历到他们（某个j）时，每个组肯定肯定存在物品v[i]<j，而每个组都能选出一个物品，因此不存在某个组选不出物品的情况 。~~这是可推的~~。
但交上去，却惊奇的发现[《100pts》](https://www.luogu.com.cn/record/226310128)。

这个出现是因为有时候long long数组溢出变负

故：
```
for(int i=1;i<=n;i++){  
      for(int j=0;j<=m;j++){//注：
			for(int k=1;k<=v[i][0];k++){
				if(v[i][k]<=j){
					f[i][j]+=f[i-1][j-v[i][k]];
					if(f[i][j]>c){
                      	  f[i][j]=c;
                  	}
            	}
		    }
		}
	}
`````
大于k的减去。

## AC代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,x,c,m; 
int v[110][110];
long long f[110][10010];
int main(){
	f[0][0]=1;
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;i++){
		scanf("%d",&v[i][0]);
		int ma=-0x3f3f3f3f;
		for(int j=1;j<=v[i][0];j++){
			scanf("%d",&v[i][j]);
			ma=max(ma,v[i][j]);
		}
		m+=ma;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int k=1;k<=v[i][0];k++){
				if(v[i][k]<=j){
					f[i][j]+=f[i-1][j-v[i][k]];
					if(f[i][j]>c){
                      	  f[i][j]=c;
                  	}
            	}
		    }
		}
	}
	int cnt=0;
	for(int j=1;j<=m;j++){
		if(f[n][j]>0){
			int t=f[n][j];
			while(t>0&&cnt<c){
				cnt++;
				printf("%d ",j);
				t--;
			}
		}
	}
	puts("");//记得换行，自求多福吧。。
	return 0; 
}
`````

---

## 作者：_zuoqingyuan (赞：3)

# 题面：
[传送门](https://www.luogu.com.cn/problem/P2409)

**题意概括**：给定 $n$ 个序列，要求从 $n$ 个序列中各选一个数，使这 $n$ 个数组成一个和，输出前 $k$ 小的和。

# 分析：
我们可以先思考最小的方案是什么。

因为要在各个序列中每个序列选一个数，我们考虑选出 $n$ 个序列中每个序列的最小数，组成最小的和。

那么我们如何得到第二小，第三小到第 $k$ 小的和呢？

这时，我突然想起了曾经做过的[一道题](https://www.luogu.com.cn/problem/P1631)，参考这道题的思路，我们可以找到 $n$ 个序列里所有第 $2$ 小的数的最小值，拿它顶替掉它这个序列的第一小的数，这样就能得到次小和，举个例子，

**样例：**
```latex
3 10
4 1 3 4 5
3 1 7 9
4 1 2 3 5
```
此时的最小和为 $1+1+1=3$

接着，我们在所有序列中第二小的数中再找最小数，即为 $\min(3,7,2)=2$，我们拿第三个序列中的 $2$ 顶替掉最小和中第三个序列的 $1$，得到次小和 $1+1+2=4$，这样，通过最小和的决策，得到了次小和的决策。

那么第三小和，第四小和呢？通过对样例的分析，我们得到前 $4$ 小和分别的决策，下列用 $m_{i,j}$ 表示第 $i$ 个序列的第 $j$ 小数。决策如下：

最小和：$m_{1,1}+m_{2,1}+m_{3,1}=3$

次小和：$m_{1,1}+m_{2,1}+m_{3,2}=4$

第三小和：$m_{1,2}+m_{2,1}+m_{3,1}=5$

第四小和：$m_{1,1}+m_{2,1}+m_{3,2}=3$

显然，只要把最小和方案中第一个序列数的取值稍稍改变，就能的到第三小和的决策，只要再次改变次小和方案中第三个序列数的取值，就能得到第四小和。

那么，我们就能得到一个结论：
## 第 $k$ 小和的决策必然能通过前 $k-1$ 个决策中的任意一个直接进行转移

那么，我们每得到一个策略，就可以把它能一步转移到的策略都表示出来，扔到某个数据结构，当这个决策没有利用的价值时，再换当前所有决策中最优的一个，重复的不断执行，直到前 $k$ 个最优决策都被表示出来

那么最后一个问题，这个能维护最优策略的数据结构是什么呢？答案显而易见就是**优先队列**

然后就可以快乐的撸代码了，第一版代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
int n,k,m[105][105],num=1;
struct node{
    int sum;
    int it[105];
};
bool operator < (const node &a,const node &b){
    return a.sum>b.sum;
}
priority_queue<node>q;
int main(){
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",&m[i][0]);
        for(int j=1;j<=m[i][0];j++){
            scanf("%d",&m[i][j]);
        }
        sort(m[i]+1,m[i]+1+m[i][0]);
    }
    node a;
    for(int i=1;i<=n;i++){
        a.sum+=m[i][1];
        a.it[i]=1;
    }
    q.push(a);
    while(num<=k){
        node t=q.top();q.pop();num++;
        printf("%d ",t.sum);
        for(int i=1;i<=n;i++){
            t.it[i]++;
            t.sum+=m[i][t.it[i]]-m[i][t.it[i]-1];
            q.push(t);
            t.sum-=m[i][t.it[i]]-m[i][t.it[i]-1];
            t.it[i]--;
        }
    }
    return 0;
}
```
输入一下样例，**好像过了！**当我们把这份代码提交上去的时候，果不其然，获得了**零分的好成绩！**

其实仔细的话，会发现代码连样例都过不去，因为程序的输出中，有一个方案重复了两次，就是和为 $6$，方案为 $3+1+2$ 的这一行，之所以会出现重复，是因为这个方案既可以从次小和的决策中转移，也能在第三小和的决策中转移。

解决这种问题用一种暴力的方法，就是用一个桶维护这个决策有没有出现过。不过还有一种更优秀的方法，就是规定改变序列的限制。

例如：次小和改变了第三个序列的数，那么从它转移出来的决策只能用改变第三个序列及以上的，而第三小和的决策改变了第一个序列的数，那它就能对所有序列进行改变，这样第五小方案只能从第三小转移，而不是次小和的决策（不懂的可以看代码）。

还有一点注意，就是对于一个序列的数，不能超出其范围，不然会选上一个零，影响答案（详细看代码）。

**最后一点，结构体里的 sum 变量要赋初值，也就是零**，~~蒟蒻因此爆了好几次零。~~

然后就没有其他的问题了，第二版代码如下：
# Code:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
int n,k,m[105][105];
struct node{
    int sum=0,last;//初值，边界
    int it[105];//各个序列的指针
};
bool operator < (const node &a,const node &b){
    return a.sum>b.sum;
}//重载小于号
priority_queue<node>q;//优先队列
int main(){
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",&m[i][0]);
        for(int j=1;j<=m[i][0];j++){
            scanf("%d",&m[i][j]);
        }
        sort(m[i]+1,m[i]+1+m[i][0]);//貌似不用排序也能过
    }
    node a;
    for(int i=1;i<=n;i++){
        a.sum+=m[i][1];
        a.it[i]=1;
    }
    a.last=1;//最小和的方案
    q.push(a);
    while(k--){
        node t=q.top();q.pop();
        printf("%d ",t.sum);
        for(int i=t.last;i<=n;i++){
            if(t.it[i]+1<=m[i][0]){
                t.it[i]++;
                t.sum+=m[i][t.it[i]]-m[i][t.it[i]-1];
                t.last=i;//决策转移
                q.push(t);
                t.sum-=m[i][t.it[i]]-m[i][t.it[i]-1];
                t.it[i]--;//复原
            } 
        }
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/137758510)

如有错误，请指出。

---

## 作者：kczno1 (赞：3)

先给每个序列排序。


可以做n次两个序列的合并。

每次合并就是用堆，记录和与在第二个序列中的位置,每次取堆头，再加入位置+1的选择。

（初始是第一个序列的每个值都选择第二个序列的第一个值）

时间n\*k\*logk


由于数据范围小，这样就能过了，但我一直在思考有没有整体用堆来达到klogk的方法。


定义一个点的v值是它与所在序列后面的点的值的差(如果是序列尾可认为是+oo)。

显然，初始状态就是所有序列取头入堆。堆是以v为关键字的最小堆。

第一个答案是序列头和。以此为基础值，第二个答案是base+堆头的v。

然后如何以这个点来更新状态使得不重复呢？

一个朴素的想法是，在原堆中删掉堆头，建一个新堆，新堆强制选择当前点，也就是新堆基础值=原堆基础值+当前点的v，

并且在新堆中加入当前点的后继节点。

然而我们用一个大的堆来维护所有堆的(基础值+堆头的v)的最小。

考虑到其他点没有改变，我们使用可持节化左偏树来完成这一操作，就能达到 nlon+k(logk+logn)了

//建初始堆+k\*(每次大堆+小堆)

(其实我一开始想到的是转化成k短路，但我不会。。)

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_pbds;

int temp;
#define swap(x,y) {temp=x;x=y;y=temp;}

#define TOT 10002
#define N 102
#define M 5000000
#define oo (1<<29)
#define pr pair<int,int>
//ans,id
struct xiao
{
    __inline__ __attribute((always_inline)) bool operator()(pr a,pr b)//强制inline的方法
    {
        return a.first>b.first;
    }
};
typedef __gnu_pbds::priority_queue<pr,xiao> heap;

heap H;//大堆直接用pb_ds的
heap::point_iterator dy[TOT];


int tot;
int v[TOT];bool is_end[TOT];
struct node
{
    int l,r,dis;
    int id;
}T[M];int now;
int h[TOT],now_h;

void merge(int &X,int x,int y)
{
    if (v[T[x].id]>v[T[y].id]) swap(x,y)
    if (!y) { X=x;return; }
    
    X=++now;
    T[X].id=T[x].id;
    
    int &r=T[X].r;
    merge(r,T[x].r,y);
    if (T[r].dis>T[T[x].l].dis) { T[X].l=r;r=T[x].l; }
    else T[X].l=T[x].l;
    
    T[X].dis=T[r].dis+1;
}

int main()
{ freopen("1.in","r",stdin);freopen("1.out","w",stdout);
  int n,k;
  scanf("%d%d",&n,&k);
  
  T[0].dis=-1;v[0]=oo;
  
  int m,i,ans=0,a[N];
  while (n--)
  {
      scanf("%d",&m);
      for (i=1;i<=m;++i) scanf("%d",a+i);
      sort(a+1,a+m+1);
      ans+=a[1];
      if (m>1)
      {
          v[++tot]=a[2]-a[1];T[++now].id=tot;merge(h[1],h[1],now);
        for (i=2;i<m;++i)  v[++tot]=a[i+1]-a[i]; 
        is_end[tot]=1;
    }
  }

  
  k-=1;printf("%d ",ans);
  
  pr I;
  dy[1]=H.push(pr{ans+v[T[h[1]].id],1});
  now_h=1;int id;
  while (k--)
  {
      I=H.top();
      ans=I.first;
      printf("%d ",ans);
      
      i=I.second;
      int &x=h[i];
      id=T[x].id;
      
      merge(x,T[x].l,T[x].r);
      if (!x) H.pop();
      else H.modify(dy[i],pr{ans-v[id]+v[T[x].id],i});
      
      if (!is_end[id])
    {
        T[++now].id=id+1;
        merge(h[++now_h],x,now);
        dy[now_h]=H.push(pr{ans+v[T[h[now_h]].id],now_h});
    }
    else 
    if (x) 
    {
        h[++now_h]=x;
        dy[now_h]=H.push(pr{ans+v[T[h[now_h]].id],now_h});
    }
  }
}
```

---

## 作者：_Weslie_ (赞：2)

现存的题解似乎没有用 dp 做的，来补一发。

## Solution P2409

### Idea

我们设 $dp_{i,j}$ 为现在考虑到了第 $i$ 盒积木，总重量为 $j$ 的方案数。

那么很显然有 $dp_{i,j}=dp_{i-1,j-a_{i,k}}+a_{i,k}$，其中 $k$ 表示这一盒积木中的第几块，$a_{i,k}$ 表示第 $i$ 盒第 $k$ 块积木的重量。

最后统计答案的时候，从小到大枚举，对于每一个可行方案让计数器加一，然后判断是否比 $k$ 大即可。如果这一段比较抽象，文末会放统计答案的代码。

这样转移的代码就长这样：

```
dp[0][0]=1;
for(int i=1;i<=n;i++){
	for(int j=1;j<=m[i];j++){
    	for(int k=a[i][j];k<=maxw;k++){
        	dp[i][k]=dp[i][k]+dp[i-1][k-a[i][j]];
        }
    }
}
```

但是它会 WA 掉最后一组 hack 数据。

我们考虑一下，当 $n=100$ 且全部 $m_i=100$ 时，若所有重量全部相同，则会出现方案数过多而爆 `long long` 的情况。

那么我们想，最多会有 $k$ 个答案，那么我们只需要把 $dp_{i,j}$ 保存到最大值为 $k$，就可以满足所有情况了。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=105,maxw=10000;
int n,m[N],a[N][N],kk;
int dp[N][N*N];
int main(){
	scanf("%d%d",&n,&kk);
	for(int i=1;i<=n;i++){
		scanf("%d",&m[i]);
		for(int j=1;j<=m[i];j++){
			scanf("%d",&a[i][j]);
		}
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m[i];j++){
			for(int k=a[i][j];k<=maxw;k++){
				dp[i][k]=min(kk,dp[i][k]+dp[i-1][k-a[i][j]]);//最核心的部分：保存到最大值为 k（代码中为 kk）。
			}
		}
	}
	int cnt=0;
	for(int i=0;i<=maxw;i++){
		for(int j=1;j<=dp[n][i];j++){
			cnt++;
			printf("%d ",i);
			if(cnt==kk)return 0;
		}
	}
	return 0;
}
```

### Time

显然转移是 $\operatorname{O}(n\times m\times w)$ 的（其中 $w$ 为最大重量）。最大重量显然是 $n\times a_i$ 的最大值，这个值是 $10000$。

所以不会超时，但是复杂度也很高。

---


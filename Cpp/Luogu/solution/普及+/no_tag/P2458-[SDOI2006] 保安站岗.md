# [SDOI2006] 保安站岗

## 题目描述

五一来临，某地下超市为了便于疏通和指挥密集的人员和车辆，以免造成超市内的混乱和拥挤，准备临时从外单位调用部分保安来维持交通秩序。

已知整个地下超市的所有通道呈一棵树的形状；某些通道之间可以互相望见。总经理要求所有通道的每个端点（树的顶点）都要有人全天候看守，在不同的通道端点安排保安所需的费用不同。

一个保安一旦站在某个通道的其中一个端点，那么他除了能看守住他所站的那个端点，也能看到这个通道的另一个端点，所以一个保安可能同时能看守住多个端点（树的结点），因此没有必要在每个通道的端点都安排保安。

编程任务：

请你帮助超市经理策划安排，在能看守全部通道端点的前提下，使得花费的经费最少。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/g013tlmh.png)

在结点 $2,3,4$ 安置 $3$ 个保安能看守所有的 $6$ 个结点，需要的经费最小：$25$。

## 样例 #1

### 输入

```
6
1 30 3 2 3 4
2 16 2 5 6
3 5 0
4 4 0
5 11 0
6 5 0```

### 输出

```
25```

# 题解

## 作者：___new2zy___ (赞：144)

## 题解 P2458 [SDOI2006]保安站岗

题目传送门：

https://www.luogu.org/problemnew/show/P2458

PS：这题真心不错，也算是一道经典的**树形DP**了

=================================================

### 题目大意：

在**一棵点有点权的树**上，**选择一些点**，这些点能**将所有与它们相连的点覆盖**，**最终将整棵树上的点全部覆盖**，试求最小代价

### 算法分析：

emmm。。。看完题目，一眼就看出是个树形DP

~~（别问我怎么看出来的）（逃~~

我们发现，要使所有点最终全部被覆盖，那么无非有3种状态：

	（以下全部都是对于要覆盖任意一个以x为根的子树来说的）
	（其中我们设y节点为y的儿子，fa为x的父亲）
    1.x节点被自己覆盖，即选择x点来覆盖x点
    
    2.x节点被儿子y覆盖，即选择y点来覆盖x点

	3.x节点被父亲fa覆盖，即选择fa点来覆盖x点

借此三种状态，我们可以**设f[x][0/1/2]为让以x为根的子树中的节点全部被覆盖，且x点的被覆盖情况为1/2/3时的最小代价**


为了方便，我们不妨设这三种情况分别为：

1.f[x][0]---对应上面的1

2.f[x][1]---对应上面的2

3.f[x][2]---对应上面的3

既然是DP，总是有转移方程的，我们想一下dp方程要如何设计

### 设计状态转移方程：

(1):对应上面的1.

**f[x][0]=∑ min(f[y][0],f[y][1],f[y][2]) + val[x]**

其中val[x]是选择x点的代价

我们很容易想到，在节点x被选择之后，我们就可以无拘无束了（蛤?），也就是说**对于x儿子节点y的状态可以不去考虑**，因为x节点被选择之后y节点无论如何也会被覆盖到，所以我们**在儿子y的所有状态里取min，累加起来就行了**

(2):对应上面的3（先讲3，因为2比较难以理解，放到了后面）

**f[x][2]=∑ min(f[y][0],f[y][1])**

为什么3情况对应的转移方程要这样写呢?

我们不妨这样理解，对于x节点我们让它的父亲节点fa覆盖它，那么根据我们的状态设计，**此时必须要满足以x的儿子y为根的子树之中所有点已经被覆盖**

那么**这时就转化为一个子问题**，**要让y子树满足条件**，**只有两种决策：要么y被y的儿子覆盖，要么被y自己覆盖（即选择y节点）**，只需要**在y的这两种状态取min累加就可以了**

(3):对应上面的2（DuangDuangDuang 敲黑板划**重点**啦）

**f[x][1]=∑ min(f[y][0],f[y][1])，如果选择的全部都是f[y][1],要再加上min(f[y][0]-f[y][1])**

这又是什么意思呢？真是让人~~摸不着头发~~，，，质壁分离（逃

到了这里，我们就要回顾一下我们设计的**dp状态**了：

**
设f[x][0/1/2]为让以x为根的子树中的节点全部被覆盖，且x点的被覆盖情况为1/2/3时的最小代价**

先提示一下，如果你理解了下面，那么本题是很简单的。。如果你没理解，就返回到这里再看一遍吧，我就在这里等着你

咳咳。。说正经的。。（逃

对于此时的状态，**f[x][1]代表对于节点x让x被自己的儿子覆盖**，那么和分析（2）一样，都**要先满足此时以y的子树已经满足了条件**，才能进行转移，这就是前面那部分：∑ min(f[y][0],f[y][1])的来历，那么后面那一长串又是怎么回事呢?

我们可以这样理解，此时既然**要保证x点是被自己的儿子覆盖的**，那么如果此时y子树已经满足了全部被覆盖，但是y此时被覆盖的状态却是通过y节点自己的儿子达到的，那么x就没有被儿子y覆盖到，那么我们不妨推广一下，**如果x所有的儿子y所做的决策都不是通过选择y点来满足条件，那么我们就必须要选择x的一个子节点y，其中y满足f[y][0]-f[y][1]最小，并把这个最小的差值累加到f[x][1]中去**，**这样才能使得x点被自己的儿子覆盖**，状态f[x][1]也才能合理地得到转移

好了，如果你还是没有太懂这个（3）的设计过程，请你回到之前再仔细看几遍

如果你已经理解了上面，那么恭喜你这个题，你已经A掉了

因为转移方程既然有了，那么我们就只需要最后的答案了

由于题目中没有说这棵树的根节点是哪个，所以你可以默认1就是根，或者开一个数组在加边的时候记录一下每个点的入度，最后没有入度的点就是根（但好像没有区别，毕竟我A掉了）

最后答案即为min(f[root][0],f[root][1])

因为根节点没有父亲,所以不需要考虑它的f[root][2]状态

那这样的花。。下面就放一下我丑陋的代码好了（逃

还请dalao们不喜勿喷

PS：代码里也有解释，希望能帮到你更深地理解一下本题

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
typedef long long ll;
const int inf=1e9+7;
inline int read()
{
    int p=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
    return f*p;}
const int maxn=1503;
struct Edge
{
	int from,to;
}p[maxn<<1];
int n,cnt,head[maxn<<1],val[maxn];
int f[maxn][4];
//设状态f[x][0],f[x][1],f[x][2]分别表示
//对于x点,被自己覆盖,被自己的儿子覆盖,被自己的父亲覆盖时
//满足以x为根的子树所有点都被覆盖的最小代价 
inline void add_edge(int x,int y)//加边 
{
	cnt++;
	p[cnt].from=head[x];
	head[x]=cnt;
	p[cnt].to=y;
}
inline void TreeDP(int x,int fa)//树形DP 
{
	f[x][0]=val[x];//初值:选择x点 
	int sum=0,must_need_mincost=inf;
	for(int i=head[x];i;i=p[i].from)
		{
			int y=p[i].to;
			if(y==fa)continue;
			TreeDP(y,x);
			int t=min(f[y][0],f[y][1]);
			f[x][0]+=min(t,f[y][2]);
            //自己被自己覆盖:儿子怎么样都行 
			f[x][2]+=t;
            //自己被父节点覆盖:儿子必须合法,要么选择儿子,要么是儿子被儿子的儿子覆盖 
			//以下是对f[x][1]的转移，请好好理解 
			if(f[y][0]<f[y][1])sum++;
            //如果选择儿子节点更优,选上,计数器sum++，证明选过f[y][0] 
			else must_need_mincost=min(must_need_mincost,f[y][0]-f[y][1]);
			//否则记录一个最小的必须支付代价
            //因为最后要保证x点被y覆盖,必须要找差值最小的,这样才最优 
			f[x][1]+=t;//自己被儿子覆盖,那么儿子必须合法 
		}
	if(!sum)f[x][1]+=must_need_mincost;
	//对于f[x][1]转移:如果一个f[y][0]都没选过,那么必须从差值最小的儿子里面选择一个 
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		{
			int x=read();
			val[x]=read();
			int num=read();
			while(num>0)
				{
					int y=read();
					add_edge(x,y);
					add_edge(y,x);
					num--;
				}
		}
	TreeDP(1,0);
	printf("%d",min(f[1][0],f[1][1]));
	//由于根节点没有父节点,最后答案就是min(f[1][0],f[1][1])
	//即1节点被自己覆盖或者被自己的儿子覆盖 
	return 0;
}
```

好了，到这里就没了。。。

如果有什么不懂的还可以私信我，或者在评论区里留言也行

欢迎各位奆佬指出错误，我会改正的

最后推广一下自己的blog：

https://www.luogu.org/blog/new2zy/

感谢阅读，拜拜~~~ >=<


---

## 作者：租酥雨 (赞：53)

**树形DP**

可知一个点被控制有且仅有一下三种情况：

1、被**父亲节点**上的保安控制

2、被**儿子节点**上的保安控制

3、被**当前节点**上的保安控制

我们设dp[0/1/2][u]表示**u节点所在子树中全部被控制的最小代价**，0表示**只有u节点尚未被控制**(等待被其父亲节点控制)；

1表示**u节点已经被控制，但u节点上没有保安**，所以不能去控制其父亲节点；2表示**u节点上有保安**

(机房的神犇说多维数组要把小的那一维写在前面，因为可以优化常数，原理请自行翻阅一本通)

转移：(以下设v是u的儿子节点)

**dp[0][u]=∑min(dp[1][v],dp[2][v])** i节点上反正没有保安，那么儿子节点只要保证全部控制即可，显然1,2状态都是满足的

**dp[1][u]=∑min(dp[1][v],dp[2][v]) + 某一个dp[2][v]** 也就是说对于其中一个儿子取dp[2][v]而其他儿子取min(dp[1][v],dp[2][v])意为i号点必须要找一个儿子来覆盖它，其余随意。这个地方涉及到了算法复杂度的问题，楼下有些题解在这里写的是O(n^2)的转移，但实际上完全可以做到O(n)。具体在代码中细讲。

**dp[2][u]=∑min(dp[0][v],dp[1][v],dp[2][v])+val[u]** 这个就简单了，i号点上反正有保安了，所有儿子节点都无所谓了，全部可以转移。

边界情况：叶子节点的dp[1][u]=INF表示该状态不合法

以下代码


```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int _ = 10005;
const int INF = 1e9;
struct edge{int to,next;}a[_<<1];
int n,head[_],cnt,val[_],dp[3][_];
int gi()
{
    int x=0,w=1;char ch=getchar();
    while ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if (ch=='-') w=-1,ch=getchar();
    while (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
void Link(int u,int v)
{
    a[++cnt]=(edge){v,head[u]};
    head[u]=cnt;
}
void dfs(int u,int fa)
{
    int sum=0;dp[2][u]=val[u];
    for (int e=head[u];e;e=a[e].next)
    {
        int v=a[e].to;
        if (v==fa) continue;
        dfs(v,u);
        sum+=min(dp[1][v],dp[2][v]);
        dp[2][u]+=min(min(dp[0][v],dp[1][v]),dp[2][v]);
    }
    dp[0][u]=sum;dp[1][u]=INF;
    for (int e=head[u];e;e=a[e].next)
    {
        int v=a[e].to;
        if (v==fa) continue;
        dp[1][u]=min(dp[1][u],sum-min(dp[1][v],dp[2][v])+dp[2][v]);
    }
    //上面sum维护出了∑min(dp[1][v],dp[2][v])，那么我们只要把其中的一个min(dp[1][v],dp[2][v])替换成dp[2][v]然后维护最小值即可
}
int main()
{
    n=gi();
    for (int i=1,k,u,v;i<=n;i++)
    {
        u=gi();val[u]=gi();
        k=gi();
        for (int j=1;j<=k;j++)
            v=gi(),Link(u,v),Link(v,u);
    }
    dfs(1,0);
    printf("%d\n",min(dp[1][1],dp[2][1]));
    return 0;
}

```

---

## 作者：Parabola (赞：42)

搞完这题真的深有体会呀

状态：$dp[u][0/1/2]$

含义

$dp[u][0]$，以**u**为根的子树中，节点**u**放置警察所需要的最小花费

$dp[u][1]$，以**u**为根的子树中，节点**u**不放置警察，但被父亲控制所需要的最小花费

$dp[u][2]$，以**u**为根的子树中，节点**u**不放置警察，但被儿子控制所需要的最小花费

状态转移方程：

$dp[u][0]$：点**u**放置了警察。

所以首先应当花费该节点放置警察所需要的费用，记为$p[u]$，则$dp[u][0]$ 的初始值为$dp[u]$。而对于它的所有子节点**v**，**v**可以任何情况都可以满足要求，综上$dp[u][0] = p[u] + ∑_{v∈son(u)}min(dp[v][0] , dp[v][1] , dp[v][2])$


$dp[u][1]$：点**u**没有放置警察，但被父亲控制。

所以它的儿子不能选择被父亲控制这种情况，其它都可以选。故$dp[u][1] = ∑_{v∈son(u)}min(dp[v][0] , dp[v][2])$

$dp[u][2]$：点**u**没有放置警察，且目前未被任何节点控制。

所以**u**一定会被它的至少一个儿子控制，换句话来说，**u**的儿子中，至少有一个要放置警察。不妨设这个儿子为**x**，那么$dp[u][2]$的初始值应当为$dp[x][0]$，对于其它儿子依旧是除了无法选择被父亲控制这种状态其它都可以选。综上$dp[u][2] = dp[x][0] + ∑_{v∈son(u)≠x}min(dp[v][0] , dp[v][2])$

那么现在的问题就是如何得到这个最优的**x**了，可以这么思考，如果**x**不是最优的，那么对于**x**来说，一定存在另一个子节点**y**满足
$dp[y][0] + ∑_{v∈son(u)≠y}min(dp[v][0] , dp[v][2]) < dp[x][0] + ∑_{v∈son(u)≠x}min(dp[v][0] , dp[v][2])$

推得$dp[x][0] + ∑_{v∈son(u)≠x}min(dp[v][0] , dp[v][2]) - dp[y][0] - ∑_{v∈son(u)≠y}min(dp[v][0] , dp[v][2]) > 0$

两式同时减去相同的部分，有$dp[x][0] + min(dp[y][0] , dp[y][2]) - dp[y][0] - min(dp[x][0] , dp[x][2]) > 0$

即$dp[x][0] - min(dp[x][0] , dp[x][2])  > dp[y][0] - min(dp[y][0] , dp[y][2]) $

所以对于最优的节点**x**，$dp[x][0] - min(dp[x][0] , dp[x][2])$一定是所有子节点中最小的。

另外写代码的时候要多考虑几个小地方，像什么初始值什么的。

------------

### Code

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector> 
using namespace std;

const int MAXN = 1500 + 5;

int n , p[MAXN] , f[MAXN];
int rt , dp[MAXN][3];
bool hfa[MAXN];

vector <int> G[MAXN]; 

//0 有保安 ，1没保安但被父控制 ，2没保安未被控制 

void dfs(int u) {
	int x = 0;
	dp[u][0] = p[u];
	for(int i = 0 , v ; i < (int)G[u].size() ; ++i) {
		dfs(v = G[u][i]);
		dp[u][0] += min(min(dp[v][0] , dp[v][1]) , dp[v][2]);
		dp[u][1] +=	min(dp[v][0] , dp[v][2]);
		if((dp[x][0] - min(dp[x][0] , dp[x][2])) > dp[v][0] - min(dp[v][0] , dp[v][2])) x = v;
	}
	dp[u][2] = dp[x][0];
	for(int i = 0 , v ; i < (int)G[u].size() ; ++i) {
		if((v = G[u][i]) == x) continue;
		dp[u][2] += min(dp[v][0] , dp[v][2]);
	}
} 

int main() {
	dp[0][0] = 1 << 30;
	scanf("%d" , &n);
	for(int i = 1 , x , k , m , v ; i <= n ; ++i) {
		scanf("%d %d %d" , &x , &k , &m);
		p[x] = k;
		while(m--) {
			scanf("%d" , &v);
			hfa[v] = true;
			G[x].push_back(v);
		}
	}
	for(int i = 1 ; i <= n ; ++i) if(!hfa[i]){
		rt = i;
		break;
	}
	dfs(rt);
	printf("%d\n" , min(dp[rt][0] , dp[rt][2]));
	return 0;
}
```

---

## 作者：xcxc82 (赞：32)

# **P2458 [SDOI2006]保安站岗 题解**


## [间隙(原题面)](https://www.luogu.com.cn/problem/P2458)

- 前排声明:蒟蒻刚学OI没多久,讲的可能比较啰嗦,望见谅

## 大致题意

给一颗树,每个点都可以花费一定的价格来放置一名"保安"

每个保安都可以看管他本身所在的点和所有与他所站的点相邻的点

求:看管所有点所需要的最小花费

## 分析

树形dp。

先来说一种错误的做法,也是我一开始想到的做法

每个点都有"放置"和"不放置"两种选择

**设$dp[i][0]$为第$i$个点"不放置"保安所需要的最小花费**

**$dp[i][1]$为第$i$个点“放置”保安所需要的最小花费**

如果第$i$个点"放置"了保安

那它的下一个节点则可以选择"放或不放"两种决策

反之,下一个节点必须都"放置"一名保安

~~很明显是错的~~


放张图应该就明白了
![](https://cdn.luogu.com.cn/upload/image_hosting/c3ommepj.png)

(下一个节点不一定要由父亲或自己来看管,也可以由自己的"儿子"来看管)

也就是说,每个点的看管对象都有:

- **自己**
- **父亲**
- **儿子**

**三种可能**

## 如何转移

设$dp[i][0]$为该点**由自己看管**所产生的最有解

$dp[i][1]$为该点**由父亲看管**所产生的最优解


$dp[i][2]$为该点**由儿子看管**所产生的最优解

- **1.由“自己”看管**



![](https://cdn.luogu.com.cn/upload/image_hosting/ywr3v3nc.png)

自己的位置上已经"放置了"一个点

那么它的所有儿子就都会被自己所"看管"住

显然儿子可以选择任意一种决策

- 得到转移方程:$dp[i][0]=\sum min(dp[son][0],dp[son][1],dp[son][2])+w[i]$

($w[i]$为父亲节点"放置"守卫所需要的价值)

- **2.由“父亲”看管**

![](https://cdn.luogu.com.cn/upload/image_hosting/75jddbxl.png)

自己由父亲看管,说明自己所在的点上**未"放置"门卫**,那儿子肯定**只能由自己的儿子看管或由自己看管**

- 得到方程:$dp[i][1]=\sum min(dp[son][0],dp[son][2])$

- 3.**由“儿子”看管**

（图中红蓝分别为两种可能情况）

![](https://cdn.luogu.com.cn/upload/image_hosting/b7rw1758.png)

既然是由自己的儿子看管

儿子的决策也有两种可能

1.由儿子的"儿子"看管

2.由自己看管

- 得到方程:$dp[i][2]=\sum min(dp[son][2],dp[son][0])$

有一种极端情况,如果全部都选了$dp[son][2]$

"自己"就会产生无人看管的情况

因此要在这里加一个小特判,具体代码里有解释

这里做了个简陋的gif,不懂的可以结合代码看一下

![](https://img-blog.csdnimg.cn/20200720102214607.gif)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1510;
int n,dp[MAXN][4],w[MAXN];
int is_head[MAXN];
vector <int> son[MAXN];
void dfs(int x){
	bool is_cs = false;//用来判断有无极端情况
	 
	int minn = 0x3ffffff;//用来求极端情况的最小值 
	dp[x][0] = w[x];
	for(int i=0;i<son[x].size();i++){
		int v = son[x][i];
		dfs(v);
		dp[x][0]+=min(min(dp[v][0],dp[v][1]),dp[v][2]);//由自己看守 
		dp[x][1]+=min(dp[v][2],dp[v][0]);//由父亲看守 
		//由儿子看守 ↓ 
		if(dp[v][0]<dp[v][2]){ 
			dp[x][2]+=dp[v][0];//如果儿子放置守卫花费的钱更少,那就直接在儿子的点上放置一个守卫 
			is_cs=true;//既然儿子的位置上已经放置守卫了,无极端情况存在 
		}
		else{//否则在儿子的儿子上放置守卫 
			minn = min( minn , dp[v][0]-dp[v][2]);//计算最小所需值 
			dp[x][2]+=dp[v][2];
		}
	}
	if(!is_cs) dp[x][2]+=minn;//如果存在极端情况,则加上差值,相当于是消掉dp[-][2],加上dp[-][0] 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int u,m;
		scanf("%d%d",&u,&m);
		w[u]=m;
		int k;
		scanf("%d",&k);
		for(int i=1;i<=k;i++){
			int v;
			scanf("%d",&v);
			is_head[v]++;
			son[u].push_back(v);
		}
	}
	for(int i=1;i<=n;i++){
		if(!is_head[i]){
			dfs(i);
			cout<<min(dp[i][0],dp[i][2]);
			return 0;
		}
	}
} 
```



---

## 作者：joe19025 (赞：23)

## 解题构思
### 技能储备
DFS
### 状态设计
因为现在每个点必须要被照看，这会产生三种情况：

1.由该节点的父节点照看

2.由该节点本身照看

3.由该节点的子节点照看

根据上述三种情况，可以设计出一个二维状态，记录在状态下所需要最少的保安人数。

1.dp[u][0]：u节点由子节点照看

2.dp[u][1]：u节点由本身照看

3.dp[u][2]：u节点由父节点照看

### 状态转移方程

1.dp[u][1]=sum(min(dp[v][0],dp[v][1],dp[v][2]))+a[u]

2.dp[u][2]=sum(min(dp[v][0],dp[v][1]))

3.dp[u][0]这个比较复杂，因为必须至少选一个子节点中的dp[v][1],但有可能dp[v][1]<dp[v][0],所以具体的办法就是比较这两个的大小，如果dp[v][1]<dp[v][0],选择dp[v][1],后面就不需要再从原来的里面选一个dp[v][1]了。如果一个dp[v][1]都没选，就选择一个dp[v][1]-dp[v][0]最小的差，加在原来dp[u][0]上。



------------
## Code
```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<vector>
#include<queue>
#include<algorithm>
#define MAXN 500005
using namespace std;

vector<int>G[1505];
int a[1505];
int dp[1505][3];

void dfs(int u,int fa)
{
    dp[u][1]=a[u];
    dp[u][0]=dp[u][2]=0;
    int cnt=0;
    int cha=0x3f3f3f3f;
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(v==fa)continue;
        dfs(v,u);
        dp[u][2]+=min(dp[v][1],dp[v][0]);
        dp[u][1]+=min(min(dp[v][1],dp[v][0]),dp[v][2]);
        if(dp[v][1]<dp[v][0])cnt++;
        else cha=min(cha,dp[v][1]-dp[v][0]);
        dp[u][0]+=min(dp[v][1],dp[v][0]);
    }
    if(cnt==0)
        dp[u][0]+=cha;
}

int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int id;
        scanf("%d",&id);
        scanf("%d",&a[id]);
        int m;
        scanf("%d",&m);
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            G[id].push_back(x);
            G[x].push_back(id);
        }
    }
    memset(dp,0,sizeof(dp));
    dfs(1,-1);
    printf("%d",min(dp[1][1],dp[1][0]));
    return 0;
}


```


---

## 作者：maomao9173 (赞：8)

根据题目描述很容易想到是树上$DP$，但是有很多需要考虑到的东西：

首先容易被坑的一点：

- 很可能会直接想到两种状态：当前点占用和不占用。

- 在这种情况下会很容易就作出如下的判断

### $F[u][1]+=min\{F[v][0],F[v][1]\};$（当前点占用的转移）
  
### $F[u][0]+=F[v][1];$（当前点不占用的转移）

然后就会第一时间$w\bar a$掉这个题目。

为什么呢？因为这个转移中，我们忽略了子节点对父节点的影响，子节点的选中也可以控制父节点，所以我们的状态应该有三个：

- 当前点被占用（子节点选啥都可以，直接取最小值）

- 当前点没有被占用（父节点占用并控制该点，所以可以把子节点里面已经独立可用的都挖过来）

- 当前点没有被占用，但是子节点中存在有已经被占用的点

	- 这个转移相对不是很好考虑，怎么确认子节点中谁被占用呢？

	- 我们先考虑不管子节点有没有被占用的，直接先取两种转移状态最小值临时存起来
    
    - 然后一一比较，看哪一个子节点变成占用态消耗最少，答案取min
  
	- 复杂度$O(n)$

实际上算是树上$DP$的一种常用套路吧，不过本蒻以前没有掌握，被这个题目好好教育了一下。

Code：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define MAXN 1510
#define INF 0x3f3f3f3f
using namespace std;
int cnt,head[MAXN],deep[MAXN];
int n,vis[MAXN],arr[MAXN],size[MAXN],f[MAXN][4];
struct edge{
	int nxt;
	int to;
}e[MAXN<<1];
void dfs(int u,int fa){
	f[u][1]=arr[u];//预先处理被占用的情况
	int sum=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa){
			//对子树的处理
			dfs(v,u);
			f[u][1]+=min(f[v][1],min(f[v][2],f[v][3]));
			sum+=min(f[v][1],f[v][2]);
		}
	}
	f[u][3]=sum,f[u][2]=INF;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa){
			f[u][2]=min(f[u][2],sum-min(f[v][1],f[v][2])+f[v][1]);
		}
	}
//	printf("f[%d][1]=%d f[%d][2]=%d f[%d][3]=%d\n",u,f[u][1],u,f[u][2],u,f[u][3]);
	return; 
}

inline void add(int from,int to){
	e[++cnt].nxt=head[from];
	e[cnt].to=to;
	head[from]=cnt;
}
 
int main(){
	int u,v,m;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&u);
		scanf("%d%d",&arr[u],&m);
		for(int j=1;j<=m;++j){
			scanf("%d",&v);
			add(u,v);
			add(v,u);
		}
	}//arr记录价格 
	//f[i][1]->本节点占用时子树最小花费
	//f[i][2]->本节点不占用但被控制时子树最小花费
	//f[i][3]->本节点完全不受控制时子树最小花费
	dfs(1,0);
//	for(int i=1;i<=n;++i){
//		printf("size %d = %d\n",i,size[i]);
//	}
//	size保存子树大小 
	printf("%d\n",min(f[1][1],f[1][2]));
	return 0;
} 
```



---

## 作者：ChenZhengJie (赞：4)

一道经典树形dp
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
//保安数 
int n;
//每位保安经费 
int r[1505];
struct sj{
	int v,next;
}edge[3005];
int tot,head[1505];
//链式前向星存树
void add(int u,int v){
	tot++;
	edge[tot].next=head[u];
	edge[tot].v=v;
	head[u]=tot;
}
//f[i][0]:以i为根子树在i安置保安时最少经费 
//f[i][1]:以i为根子树在i被儿子结点保安看守时最少经费
//f[i][2]:以i为根子树在i被父亲结点保安看守时最少经费 
int f[1505][3];
//树形dp 
void dfs(int root,int fa){//root:根;fa:根父节点
	f[root][0]=r[root];//初始化(以root为根子树在root放保安时最少经费,初值r[root])
	bool fl=0;int mn=2147483647;//fl:标志,root儿子结点设置保安或儿子结点被其儿子结点保安看守
	//mn:当f[root][1]中的所有儿子结点都未安置保安时f[儿子][0]与f[儿子][1]最小差值 
	for(int i=head[root];i;i=edge[i].next){//遍历 
		int v=edge[i].v;
		if(v==fa)continue;//如果找到父亲,跳过 
		dfs(v,root);//递归(v作为根,root作为父节点) 
		f[root][0]+=min(f[v][0],min(f[v][1],f[v][2]));//root结点设置保安则儿子结点三种情况均可
		//(取最小值) 
		f[root][2]+=min(f[v][0],f[v][1]);//root结点依靠父结点时,儿子结点两种情况 
		//自己设置保安或依靠儿子结点(取较小值) 
		if(f[v][0]<f[v][1])fl=1;//若儿子结点自设保安比依靠儿子结点经费少则记录
		//(root有儿子结点自设保安) 
		else mn=min(mn,f[v][0]-f[v][1]);//否则更新最小值 
		f[root][1]+=min(f[v][0],f[v][1]);//root结点依靠儿子结点时有两种情况
		//(儿子结点自设保安或儿子结点依靠其儿子结点) 
	}
	if(!fl)f[root][1]+=mn;//f[root][1]中的所有儿子结点都未安置保安,则需加上f[儿子][0]与f[儿子][1]最小差值 
	//(即依靠儿子结点时儿子结点必须设置保安)
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x,k;cin>>x;
		cin>>r[x]>>k;
		for(int j=1;j<=k;j++){
			int y;
			cin>>y;add(x,y);add(y,x);
		}
	}
	dfs(1,-1);
	cout<<min(f[1][0],f[1][1]);//比较主根自设保安和依靠儿子结点经费,取较小值
	//(因为主根无父亲结点,故不考虑) 
}




---

## 作者：Doubeecat (赞：3)

> [P2458 [SDOI2006]保安站岗](https://www.luogu.com.cn/problem/P2458)
>
> 有一棵无根树有 $n$ 个点，每个点都可以被其相邻的点望到。
>
> 每个点带有一个权值，求保证所有点都可以被望到的情况下花费总代价最少。


## 解题思路：

树形 DP。

最开始我的想法和[树上最小点覆盖](<https://www.luogu.com.cn/problem/P2016>)的想法一样，每个点有选与不选两种状态，暴力转移。

成功拿到 10 分。

回到正题，这题和树上最小点覆盖的本质区别在于：

- 树上最小点覆盖每个点只能被父亲看见
- 本题中的每个点可以被父亲或者儿子看见

所以直接导致我们的状态不再适用。

那么怎么办呢？可以暴力直接把这种情况加进去！

同样，我们设 $f_{i,0/1/2}$ 表示第 $i$ 个点的情况：

- 如果是 0 ，表示当前点被选中
- 如果是 1 ，表示当前点是被父亲看到的，且当前点未被选中
- 如果是 2 ，表示当前点是被儿子看到的，且当前点未被选中

前两种情况的转移方程很好写，考虑可行性即可。

$$f_{x,0} = \min_{y \in son(x)}(f_{y,0,}f_{y,1},f_{y,2})$$

因为该点被选中，所以子节点怎么转移都行

$$f_{x,1} = \min_{y \in son(x)}(f_{y,0},f_{y,2})$$

因为该点没被选中，所以子节点中 $f_{y,1}$ 就不能被转移。

最后一种情况**似乎**大同小异：

$$f_{x,2} = \min_{y \in son(x)}(f_{y,0},f_{y,2})$$

但是，让我们考虑这样的一种情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/2dlo1zih.png)

在这张图中，$f_{1,2} = f_{2,2}+f_{3,2}+f_{4,2}$ ，显然不符合状态的定义， $1$ 并没有被观察到，所以我们还要暴力选择一个$f_{y,0}-f_{y,2}$差值最小的点（上图中为 $2$）才能保证正确性。

所以我们就可以写出最后一种情况的方程了：

如果有选择 $f_{y,0}$，则

$$f_{x,2} = \min_{y \in son(x)}(f_{y,0},f_{y,2})$$

如果没有，则

$$f_{x,2} = \min_{y \in son(x)}(f_{y,0},f_{y,2}) + \min_{y \in son(x)}(f_{y,0} - f_{y,2}))$$

这两个只要在代码实现时候记录下即可。

初值：$f_{x,0} = a_x,f_{x,1} = f_{x,2} = 0$

目标：$\min(f_{root,0},f_{root,2})$（根节点没有父亲，所以没有 $f_{root,1}$ 的情况）

最后，由于并没有指定根，所以读入时还要记一下入度为 0 的点当作根开始 DP。

## 代码：

省略头文件

```cpp
int n,a[N],f[N][3],deg[N];
//f_{i,0} 表示当前点放一个 f_{i,1}表示父亲放 f_{i,2} 表示儿子放
//当前点放的话随便转移
//父亲点放的话可以转移到f_{y,0}或f_{y,2}
//儿子放的话要找到一个最小儿子 让放置儿子代价最小

void dfs(int x,int fa) {
	f[x][0] = 1;	
	int del = INF;//记录f_{y,0} - f_{y,2}的最小值
	bool flag = false;//记录是否选择全部不选
	for (int i = hd[x];i;i = nxt[i]) {
		int y = to[i];
		if (y == fa) continue;
		dfs(y,x);
		f[x][0] += std::min(f[y][0],std::min(f[y][1],f[y][2]));//第一种情况更新
		f[x][1] += std::min(f[y][0],f[y][2]);//第二种情况更新
		if (f[y][0] < f[y][2]) {
			f[x][2] += f[y][0];
			flag = true;//选择了f_{y,0}
		}
		else {
			del = std::min(del,f[y][0] - f[y][2]);//计算f_{y,0} - f_{y,2}的最小值
			f[x][2] += f[y][2];
		}
	}	
	if (!flag) {
		f[x][2] += del;//如果没有选择则暴力加上
	}
}



signed main() {
	read(n);
	for (int i = 1;i < n;++i) {
		int x;read(x);int y;read(y);
		addedge(x,y);
		deg[y]++;//记录每个点入度
	}
	int root = 0;
	for (int i = 1;i <= n;++i) if (!deg[i]) root = i;//记录根节点
	dfs(root,0);
	printf("%d\n", std::min(f[root][0],f[root][2]));
    //根节点没有父亲，所以不用转移f_{root,1}
	return 0;
}	
```



---

## 作者：szr666 (赞：3)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P2458)
------------

------------

华丽的分割线
# 解析

### 状态设计

对于一个点,有3种情况使它被看守

0.被父亲看守 1.被自己看守 2.被儿子看守 

设dp[x][3]为以x为根的子树,x节点被看守3种情况的最少经费

### 递推转移方程式

设s为x的子节点，枚举s

dp[x][0]+=min{dp[s][1],dp[s][2]};

表示x节点不选,则x的子节点选或由子节点看守(不能由父节点看守)

dp[x][1]+=min{dp[s][0],dp[s][1],dp[s][2]}+a[x];

表示x节点选,则x的子节点选或由子节点或父节点看守，加上x的代价

dp[x][2]=dp[x][0] now=min{dp[s][1]-dp[s][2]} dp[x][2]+=max(now,0)

表示x节点不选,则x的子节点选或由子节点看守(不能由父节点看守)

但必须至少有一个子节点被选

若一个被选,则有dp[s][1]<dp[s][2],则now<0，dp[x][2]值不变

若无一个被选,则选一个代价最小的点,dp[x][2]+=dp[s][1]-dp[s][2]

### 搜索

注意要先找到根节点(无点指向),从根搜索

每次搜完根节点更新父节点,最后答案为min(dp[root][1],dp[root][2])

因为根节点无父节点

# 代码

```cpp
#include<cstdio>
#include<bitset>
using namespace std;
const int N=1800;
void read(int &x)
{
    x=0;
    int f;
    f=1;
    char c;
    c=getchar();
    while((c<'0'||c>'9')&&c!='-')
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
int a[N];
struct node
{
    int next;
    int to;
};
node e[N];
int head[N],etot,dp[N][3];// 0 fa 1 self 2 son
bitset<N> book;
void add(int x,int y)
{
    etot++;
    e[etot].to=y;
    e[etot].next=head[x];
    head[x]=etot;
}
inline int min(int x1,int x2)
{
    return x1<x2 ? x1 : x2;
}
inline int max(int x1,int x2)
{
    return x1>x2 ? x1 : x2;
}
void dfs(int x)
{
    int i,now;
    now=0x3f3f3f3f;
    for(i=head[x];i!=0;i=e[i].next)
    {
        dfs(e[i].to);
        dp[x][0]+=min(dp[e[i].to][1],dp[e[i].to][2]);
        dp[x][1]+=min(dp[e[i].to][1],min(dp[e[i].to][2],dp[e[i].to][0]));
    }
    dp[x][2]+=dp[x][0];
    for(i=head[x];i!=0;i=e[i].next)
    {
        now=min(now,dp[e[i].to][1]-dp[e[i].to][2]);
    }
    dp[x][2]+=max(now,0);
}
int main()
{
    etot=0;
    int n,i,m,x,j;
    read(n);
    for(i=1;i<=n;i++)
    {
        read(i);
        read(a[i]);
        dp[i][1]=a[i];
        read(m);
        for(j=1;j<=m;j++)
        {
            read(x);
            book[x]=1;
            add(i,x);
        }
    }
    for(i=1;i<=n;i++)
    {
        if(book[i]==0)
        {
            dfs(i);
            printf("%d",min(dp[i][1],dp[i][2]));
            return 0;
        }
    }
}
```


---

## 作者：Kevin_F (赞：2)

## 分析：

树形dp刚刚入门，这是我做的第一个一个点同时受父亲节点和儿子节点控制的题目。

由于这个题中某一个点放不放保安与父亲和儿子都有关系（因为线段的两个端点嘛），所以我们做题时就要考虑全面。

假设dp数组为$f[i][j]$:其中$f[i][0]$表示选择自己（本身这个点），$f[i][1]$表示自己不选，儿子选（不选本身这个点，而选择这个点的儿子节点），$f[i][2]$表示自己不选，父亲选（不选本身这个点而选择这个点的父亲节点）

~~有点啰嗦。。。~~

看了我的dp数组大家可能有疑问了，树形dp不是用儿子去更新父亲吗？dp不是没有后效性吗？为什么这个点可以看他的父亲？..其实我也是从别人嘴中知道有一种叫做**未来计算**的东西，就是可以把事先没有发生的但是肯定可以发生的费用加到答案中。

dp转移方程：

设$x$的儿子节点是$v$

$f[x][0] += min(f[v][1] , min(f[v][2] , f[v][0]))$

$f[x][2] += min(f[v][0] , f[v][1])$

#### 注意：

$f[x][1]$如果有很多儿子怎么办？

当然，自己不选也不一定所有的儿子都选，我们只需要选择一个最优的儿子，我们其实可以记录一个$f[v][0] - f[v][1]$的最小值，最后加进去就好了

```cpp
if(f[v][0] <= f[v][1]){
	f[x][1] += f[v][0];
    yes = true;
}
else {
	f[x][1] += f[v][1];
    minn = min(minn , f[v][0] - f[v][1]);
}
```

代码的话就是这样的。$yes$就是打另一个标记，具体怎么用，看总代码吧，就不赘述了。


## 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn = 2000;

inline int read(){
    char ch = getchar();
    int f = 1 , x = 0;
    while(ch > '9' || ch < '0'){if(ch == '-')f = -1;ch = getchar();}
    while(ch >= '0' && ch <= '9'){x = (x << 1) + (x << 3) + ch - '0';ch = getchar();}
    return x * f;
}

int n,flag,k,m,r;
int f[maxn][10],son[maxn];
//f[i][0]:自己选 ，f[i][1]：自己不选，儿子选 ，f[i][2]：自己不选，父亲选 
int head[maxn],tot;

struct Edge{
    int from,to,next;
}edge[maxn << 1];

void add(int u,int v){
    edge[++tot].from = u;
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot;
}

void dfs(int x,int fa){
    f[x][0] = son[x];
    for(int i=head[x];i;i=edge[i].next){
        int v = edge[i].to;
        if(v != fa)  dfs(v , x);
    }
    bool yes = false , have = false;
    int minn = 1e9 ; 
    for(int i=head[x];i;i=edge[i].next){
        int v = edge[i].to;
        have = true;
        f[x][0] += min(f[v][1] , min(f[v][2] , f[v][0]));
        f[x][2] += min(f[v][0] , f[v][1]);
        if(f[v][0] <= f[v][1]){
            f[x][1] += f[v][0];
            yes = true;
        }
        else {
            f[x][1] += f[v][1];
            minn = min(minn , f[v][0] - f[v][1]);
        }
    }
    if(!yes) f[x][1] += minn;
    if(!have) f[x][1] = 1e9;
}

int main(){
    n = read();
    for(int i=1;i<=n;i++){
        flag = read(); k = read();
        m = read();
        son[flag] = k;
        if(m != 0){
            for(int j=1;j<=m;j++){
                r = read();
                add(flag , r);  add(r , flag);
            }
        }
    }
    memset(f , 0 , sizeof(f));
    dfs(1 , 0);
    printf("%d\n",min(f[1][1] , f[1][0]));
    return 0;
}	
```

---

## 作者：PBCWZCC (赞：1)

看了别的题解，发现我转移状态的方式与大部分的不一样。

我们知道，树形$\mathrm{DP}$里每个非叶子节点的状态都是**从它们子节点的状态推出来的**。那么本题中，**从子节点状态的角度来看**，一个点有这样三种状态：

$(1)$没有保安，且**它的子节点也都没有保安**（大部分题解这里是它的父节点有保安）；

$(2)$没有保安，但子节点中至少有一个有保安能控制到它；

$(3)$有保安；

记$F_{i,~0/1/2}$为第$i$个点在某状态下其所有子树能够被完全控制的总花费，那么很容易得到：

$F_{i,~0} = \sum\limits_{j\in son_i}F_{j,~1} ~\mathrm{(i)}$

$F_{i,~1} = \min\limits_{k\in son_i}\{F_{k,~2} + \sum\limits_{j\in son_i~\bigvee~j\neq k}\min\{F_{j,~1},~F_{j,~2}\}\}~\mathrm{(ii)}$

$F_{i,~2} = \sum\limits_{j\in son_i}\min \{F_{j,~0},~F_{j,~1},~F_{j,~2}\}+val_i~\mathrm{(iii)}$

其中$\mathrm{(ii)}$式表示在至少选一个有保安的子节点时的最小花费。

这里我们预处理一下$F$数组：若当前状态$p$不能使得子树全部被控制，那么$F_{i,~p} = \inf$；也就是说，我们可以把$F$用$\inf$初始化；

最终答案即$\min\{F_{root,~1},~F_{root,~2}\}$。

现在，我们对比主流的做法来验证这种$\mathrm{DP}$的正确性。

记$F_{i,~0} = \sum\limits_{j\in son_i}\min\{F_{j,~1},~F_{j,~2}\} ~\mathrm{(iv)}$，表示点$i$在受父节点控制（不考虑子节点）时其子树能够被完全控制的最小花费；

当点$i$的子节点都满足状态$(2)$合法时，$\mathrm{(i)}$和$\mathrm{(iv)}$结果相同；

而若$\exists j\in son_i$满足状态$(2)$不合法（即$j$没有保安就不会被$j$的子节点控制），$\mathrm{(i)}$会得到$\inf$（见上文初始化部分），而$\mathrm{(ii)}$与$\mathrm{(iv)}$结果相同；

这样，在转移状态时，无论使用$\mathrm{(i)}$还是$\mathrm{(iv)}$，$\mathrm{(ii)}$和$\mathrm{(iii)}$的结果在每一步都相同；所以，最终答案的$\min\{F_{root,~1},~F_{root,~2}\}$也相同。

由上对比验证可见，本做法是正确的。

$\large\bold{Code}$

（下面的代码没有特意改动某些可见字符使其编译不过，但您如若直接CtrlCV+Enter提交仍然会$\mathrm{CE}$）

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
const int MAXN = 1510; 
const int MAXM = 3010; 
int n, m; 
#define LL long long
int A[MAXN]; 
int G[MAXN][MAXN]; 
int ind[MAXN]; 
LL F[MAXN][3]; 
// 0 - 没有保安且不受孩子控制  1 - 没有保安但受子节点控制  2 - 有保安 
void search(int x)
{
　　int y, e; 
　　LL sum0, sum1, sum2; 
　　sum0 = sum1 = sum2 = 0; 
　　for(e = 1; e <= G[x][0]; ++e)
　　{
　　　　y = G[x][e]; 
　　　　search(y); 
　　　　sum0 += F[y][1]; // 不同之处 
　　　　sum1 += min(F[y][1], F[y][2]); 
　　　　sum2 += min(F[y][0], min(F[y][1], F[y][2])); 
　　}
　　for(e = 1; e <= G[x][0]; ++e)
　　{
　　　　y = G[x][e]; 
　　　　F[x][1] = min(F[x][1], sum1 - min(F[y][1], F[y][2]) + F[y][2]); 
　　}
　　F[x][0] = sum0; 
　　F[x][2] = sum2 + A[x]; 
}
int main()
{
　　int i, x, y, k; 
　　scanf("%d", &n); 
　　for(i = 1; i <= n; ++i)
　　{
　　　　F[i][0] = F[i][1] = F[i][2] = 0x7f7f7f7f; 
　　}
　　for(i = 1; i <= n; ++i)
　　{
　　　　scanf("%d", &x); 
　　　　scanf("%d", &A[x]); 
　　　　scanf("%d", &k); 
　　　　for(; k--; )
　　　　{
　　　　　　scanf("%d", &y); 
　　　　　　G[x][++G[x][0]] = y; 
　　　　　　++ind[y]; 
　　　　}
　　}
　　LL ans = 0x7f7f7f7f; 
　　for(y = 1; y <= n; ++y) 
　　{
　　　　if(!ind[y])
　　　　{
　　　　　　search(y); 
　　　　　　ans = min(ans, min(F[y][1], F[y][2])); 
　　　　}
　　}
　　printf("%lld\n", ans); 
　　return 0; 
}


```

---

## 作者：DarkValkyrie (赞：1)

### 解析：

写完这道题，真的感觉提高了不少！

------

看到题解写的都是三种状态，虽然我也写了三种状态的解法（比较容易理解），但是咱教练曰：四种状态的也可以。于是便来一发四种状态的（其实本质上也可以化为三种状态，二者无本质区别）。

根据题意，我们得出对于除叶子节点外任意的节点$x$，可以有四种情况：

若$x$的位置的费用为$c_x$，其父节点为$fa$。

1. $x$的位置没有保安，$fa$的位置有保安
2. $x$的位置没有保安，$fa$的位置没有保安
3. $x$的位置有保安，$fa$的位置有保安
4. $x$的位置有保安，$fa$的位置没有保安

设$dp[x][0/1/2/3]$表示在以$x$为根的子树中，使得每个端点都被覆盖了的最小花费。其中每一种状态对应上面的每一种情况。

注意一下下文提到的状态与情况的区别。

#### 一、

首先考虑$1$情况，对于这样的$x$，假设它任意一个子节点为$y$，那么必然有：

$dp[x][0]=\sum_{y\in tree(x)} min(dp[y][1],dp[y][3])$

即，若要使情况$1$成立，那么必然要从使得它成立的状态（即$y$的父节点没有保安）转移过来。

#### 二、

我们先考虑3、4情况，因为他们比较像。。。

我估摸着这个状态是可以合并的，因为无论$x$的$fa$有没有保安，都无所谓，不影响转移。

容易得出：

$dp[x][2/3]=\sum_{y\in{tree(x)}} min(dp[y][0],dp[y][2])+c_x$

即，若要使得情况3、4成立，那么$y$的$fa$就要有保安。

#### 三、

这里就比较难理解，但是跟其它题解是同一个思路。

我们首先明确我们对状态的刻画：**设$dp[x][0/1/2/3]$表示在以$x$为根的子树中，每个端点都被覆盖了**所能得到的最小花费。

对于情况$2$，有两种决策，即

1. 选择从子节点$y$的第$1$种状态转移过来（$dp[y][1]$），这时$y$位置没有保安。
2. 选择从子节点$y$的第$3$种状态转移过来（$dp[y][3]$），这时$y$位置有保安。

可以预见的是，如果对于一个节点$x$，把它作为一个根节点，它的所有子节点$y$都不放置保安时得到最优解（即$x$阶段全部从$dp[y][1]$转移过来），那么显然这样的情况是不符合我们刻画的状态的（根节点$x$未被覆盖到）。

所以我们就要特判一下，一旦出现这种情况，我们就要贪心地去使得当前状态在我们规定的意义下成立。

即，寻找对花费贡献最小的那个$dp[y][3]$，拿它做转移到$x$。

怎么做呢？很简单，我们把最小的$dp[y][3]-dp[y][1]$加进原先我们得出的无法成立的状态中就行了。

证明的话，其实想一想，这个差值其实就是将原先的一个转移$dp[y][1]$变成$dp[y][3]$的时候的变化值。

建议好好品味这道题，能有不错的收获。

### 参考代码：

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 2010
#define MOD 2520
#define E 1e-12
#define INF 0x3f3f3f3f
using namespace std;
//start from 1
struct rec{
	int next,ver;
}g[N<<1];
int head[N],tot,n,dp[N][4],a[N];
bool v[N];
inline int read()
{
	int f=1,x=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
void add(int x,int y)
{
	g[++tot].ver=y;
	g[tot].next=head[x],head[x]=tot;
}
void calc(int x)
{
	v[x]=1;
	int sum=0,minn=INF;
	dp[x][2]=a[x];dp[x][3]=a[x];
	for(int i=head[x];i;i=g[i].next){
		int y=g[i].ver;
		if(v[y]) continue;
		calc(y);
		//0fa有self没有，1fa没有self没有，2fa有self有，3fa没有self有 
		dp[x][2]+=min(dp[y][0],dp[y][2]);
		dp[x][3]+=min(dp[y][0],dp[y][2]);
		if(dp[y][1]>dp[y][3]) sum++;
		else minn=min(minn,dp[y][3]-dp[y][1]);
		dp[x][0]+=min(dp[y][1],dp[y][3]);
		dp[x][1]+=min(dp[y][1],dp[y][3]);
	}
	if(!sum) dp[x][1]+=minn;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++){
		int ii,k;
		ii=read(),a[ii]=read(),k=read();
		for(int t=1;t<=k;t++){
			int y;
			y=read();
			add(ii,y),add(y,ii); 
		}
	}
	calc(1);
	cout<<min(dp[1][1],dp[1][3])<<endl;//根节点不会有父节点嘛，这个好理解
	return 0;
}
```

如有纰漏欢迎指出$QWQ$



---

## 作者：apt123 (赞：1)

没人写题解……

显然是树P。发现记录传统的两个状态是不够的，因为当前点可以被上面的覆盖，也可以被下面的覆盖

f表示到当前点的最小花费

定义
f[i,0]: 当前点还未被覆盖  ——下面只能选2

f[i,1]: 选当前点 ——下面随便选

f[i,2]: 当前点被下面的覆盖而不选当前点 ——下面至少选一个1，且不能选0

还有题目不保证1为根

至于转移的细节，Pascal可读性很强


···pascal










```cpp
//byAPT 2016.10.21 仅供学习 禁止直接粘上去提交
uses math;
var
    n,a,b,c,m                   :longint;
    i,ii,j,p,r                         :longint;
    son,cost,last,pre,oth,q,fth              :array[0..3010]of longint;
    vis                         :array[0..1510]of boolean;
    f                           :array[0..1510,0..3]of longint;
    totl,cnt,mi                    :longint;
procedure conn(a,b:longint);
begin
    inc(totl);
    pre[totl]:=last[a];
    last[a]:=totl;
    oth[totl]:=b;
end;
procedure bfs;
var cur,p,r,he,ta:longint;
begin
    vis[1]:=true;
    he:=0; ta:=1; q[1]:=1;
    while he<>ta do begin
        inc(he);
        cur:=q[he];
        p:=last[cur];
        while p>0 do begin
            r:=oth[p];
            if not vis[r] then begin
                vis[r]:=true;
                inc(son[cur]);
                fth[r]:=cur;
                inc(ta);
                q[ta]:=r;
            end;
            p:=pre[p];
        end;
    end;
end;
begin
    read(n);
    for i:=1 to n do begin
        read(a);
        read(cost[a],m);
        for j:=1 to m do begin
            read(b);
            conn(a,b); conn(b,a);
        end;
    end;
    bfs;
    for ii:=n downto 1 do begin
        i:=q[ii];
        f[i,0]:=0; f[i,1]:=cost[i]; f[i,2]:=0;
        p:=last[i];
        mi:=maxlongint;
        while p>0 do begin
            r:=oth[p];
            if fth[i]=r then begin
                p:=pre[p];
                continue;
            end;
            if (f[r,2]=maxlongint)or(f[i,0]=maxlongint) then f[i,0]:=maxlongint
            else inc(f[i,0],f[r,2]);
            inc(f[i,1],min(f[r,0],min(f[r,1],f[r,2])));
            inc(f[i,2],min(f[r,1],f[r,2]));
            if f[r,1]-f[r,2]<mi then begin
                mi:=f[r,1]-f[r,2];
            end;
            p:=pre[p];
        end;
        if son[i]=0 then f[i,2]:=maxlongint
        else if mi>0 then f[i,2]:=f[i,2]+mi;
    end;
    write(min(f[1,1],f[1,2]));
end.
···
```

---

## 作者：gujialiang123 (赞：1)

   **很水的一道树形dp**
   
   随便找一个点为根节点，第一维记录走到哪个点，第二维0和1表示当前点放置和不放置，2记录该点放置条件下子树花费和最小的时候是否全部点都没有放置，3记录该点子节点中强制点亮一个点所花费的最小价值
	    
这样当我们判断一个点如果所有子节点都不点亮花费最小的话，就强制点亮一个子节点；

当我们从他向他的父亲继承的时候，如果这个点的当0状态初是被强制点亮从而合法的，我们更新父亲的1状态时候就要考虑这种状态
        
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20001;
/*第2维记录当前1状态下点子节点有无点亮的，0没有1有，第3维记录子节点中点亮加钱最少的钱数*/
int dp[1501][4],w[10001],u[N],v[N],nxt[N],fst[N],tot,num[N];
int n;
void add(int x,int y)
{
	tot++;
	u[tot]=x;
	v[tot]=y;
	nxt[tot]=fst[x];
	fst[x]=tot;
}
void dfs(int x,int pre)
{
	if(!num[x]) 
	{
//		cout<<x<<endl;
		dp[x][1]=w[x],dp[x][0]=0;	
		return;
	}
	for(int i=fst[x];i;i=nxt[i])
	{
//		cout<<x<<"->"<<v[i]<<endl;
		if(v[i]==pre) continue;
		dfs(v[i],x);
		if(!dp[v[i]][2]&&num[v[i]]) dp[x][1]+=min(dp[v[i]][1],dp[v[i]][0]-dp[v[i]][3]);
		else dp[x][1]+=min(dp[v[i]][0],dp[v[i]][1]);
		dp[x][0]+=min(dp[v[i]][0],dp[v[i]][1]);
		dp[x][3]=min(dp[x][3],(dp[v[i]][1]-dp[v[i]][0]));
		if(dp[v[i]][1]<=dp[v[i]][0]) dp[x][2]=1;
	} 
	for(int i=fst[x];i;i=nxt[i]) 
	{
		if(!num[v[i]]) dp[x][0]+=w[v[i]],dp[x][2]=1;
	}
	if(!dp[x][2]) dp[x][0]+=dp[x][3];
	dp[x][1]+=w[x];
}
int s;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		dp[i][3]=20000000; 
		int x,m,k,X;
		cin>>x>>k>>m;
		w[x]=k;
		num[x]=m;
		if(m!=0) s=x;
		for(int j=1;j<=m;j++)
		{
			cin>>X;
			add(x,X);
			add(X,x);
		}
//		if(num[x]==0) dp[x][3]=0;
	}
	dfs(s,0);
	cout<<min(dp[s][1],dp[s][0]);
//	for(int i=1;i<=n;i++) cout<<i<<":"<<dp[i][0]<<" "<<dp[i][1]<<endl;
 } 
```

        


---

## 作者：hxb__ (赞：1)

um...  活脱脱一个树DP

f[ i ][ 0 ] 表示 i 点 被父亲感染

f[ i ][ 1 ] 表示 在i 点放守卫

f[ i ][ 2 ] 表示 i点没被父亲感染 即必须被一个儿子感染


f[ i ][ 2 ]这种情况不能存在于叶子节点

f[ i ][ 1 ]这种情况随时都可以选


细节就看代码吧





    
    
    
    
        
        
            
            
                
                

    
    
    
    
    
    
    
    
     

```cpp
#include <iostream>
#include <cstdlib>
#include <stdio.h>
#include <cstring>
#define in( x ) scanf( "%d" , &x ) 
#define FOR( p , x , y ) for( int p = x ; p <= y ; p ++ )
using namespace std ; 
const int N = 1501 ; 
int n , ges , val[ N ] , head[ N ] , deep[ N ] , f[ N ][ 3 ] ;
bool rd[ N ] , cd[ N ] ; 
struct hxb { int to , next ; } lb[ N << 1 ] ; 
void link( int a , int b ) { lb[ ++ ges ] . to = b , lb[ ges ] . next = head[ a ] , head[ a ] = ges ; return ; }
int dp( int u , int bj ) {
    if( f[ u ][ bj ] != -1 ) return f[ u ][ bj ] ;
    if( bj == 1 ){
        f[ u ][ 1 ] = val[ u ] ; 
        for( int k = head[ u ] ; k ; k = lb[ k ] . next ) {
            v = lb[ k ] . to ; 
            f[ u ][ 1 ] += min( min( dp( v , 1 ) , dp( v , 0 ) ) , dp( v , 2 ) ) ; 
        }
    }
    if( bj == 0 ) {
        f[ u ][ 0 ] = 0 ; 
        for( int k = head[ u ] ; k ; k = lb[ k ] . next ) {
            v = lb[ k ] . to ; 
            f[ u ][ 0 ] += min( dp( v , 2 ) , dp( v , 1 ) ) ; 
        }
    }
    if( bj == 2 ) {
        f[ u ][ 2 ] = 23333333 ; 
        for( int k = head[ u ] ; k ; k = lb[ k ] . next ) {
            v = lb[ k ] . to ; 
            int get = dp( v , 1 ) ; 
            for( int k2 = head[ u ] ; k2 ; k2 = lb[ k2 ] . next ) {
                int v2 = lb[ k2 ] . to ; 
                if( v2 == v ) continue ; 
                get += min( dp( v2 , 1 ) , dp( v2 , 2 ) ) ; 
            } f[ u ][ bj ] = min( f[ u ][ bj ] , get ) ; 
        }
    }
//    cout << u << " " << bj << " " << f[ u ][ bj ] << endl ; 
    return f[ u ][ bj ] ; 
}
int main( ) {
    memset( f , -1 , sizeof f ) ; 
//    freopen( "main.in" , "r" , stdin ) ; 
    in( n ) ; 
    int a , b , c , d ; 
    FOR( p , 1 , n ) {
        in( a ) , in( val[ a ] ) , in( c ) ;
        FOR( l , 1 , c ) in( d ) , link( a , d ) , rd[ d ] = 1 ;
        if( !c ) cd[ a ] = 1 ;      
    }
//    FOR( i , 1 , n ) cout << val [ i ] << " "; cout << endl ; 
    int res = 0x7fffffff ; 
    FOR( i , 1 , n ) if( rd[ i ] == 0 ) cout << min( dp( i , 2 ) , dp( i , 1 ) ) ; 
    return 0 ; 
}

```

---

## 作者：lsm123 (赞：0)

状态转移方程1：
f[t][0]:如果这个节点被控制并且有一个守卫，那么这个节点的代价
就是   f[t][0] += min(f[v][0], min(f[v][1], f[v][2]));
因为这个点已经被控制了，已经是妈祖要求的了，所以对于他的儿子已经没有要求了在儿子的
3中选择中取min



状态转移方程式2：
f[t][2](表示当前的根节点没有守卫，并且不会被控制)
对于根节点的儿子的情况一定是f[v][1],(因为要求的是每一个点必须被覆盖，扫到t这一个节点时会发现这个
t节点没有被任何儿子节点覆盖，因此儿子节点一定是f[v][1]的情况，反正若是f[v][0],t节点一定会是f[t][1]或者f[t][0]
之类的，如果根节点是f[v][2],就说明t的子节点v没有守卫，没有被控制，v本来打算的是让父节点保护
可是现在的父节点是f[t][2]类型的，说明这个父节点不会具有保护子节点的能力，显然后两者一定是不合法的)


状态转移方程式3：
f[t][1]:说明t这个根节点被控制但是没有守卫
只能是说明这个根节点t至少有一个儿子的状态是f[v][0],其余的满足的合法就可以
所以方法就是for所有的儿子，假定一个取f[v][0],其余的在f[v][0]和f[v][1]之间取min（如果儿子中有任何一个
的状态是f[v][2]，这样一定是不合法的）

引子：https://www.luogu.org/problem/P1352

```c
#include<iostream>
#include<cstdio>
using namespace std;
int tot=0,head[6005],to[6005],next[6002];
int n;int a[60000];
int cnt=0;
int f[50005][2];
bool root[50005]={0};
void add(int x,int y)
{
	tot++;
	next[tot]=head[x];
	head[x]=tot;
	to[tot]=y;
}
void dfs(int x)
{
	for(int i=head[x];i;i=next[i])
	{
		int v=to[i];
		dfs(v);
	}
	if(!head[x])
	{
		f[x][0]=0;
		f[x][1]=a[x];
	}
	
	f[x][1]=a[x];
	f[x][0]=0;
	for(int i=head[x];i;i=next[i])
	{
		int v=to[i];
		f[x][0]+=max(f[v][0],f[v][1]);
		f[x][1]+=f[v][0];
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		root[i]=true;
	}
	for(int i=1;i<=n-1;i++)
	{
		int a,b;
		cin>>a>>b;
		add(b,a);//建表建反了会出现叶子节点的个数个根节点，相应会输出叶子结点的个数个答案 
		root[a]=false;
	}
	int c1,c2;
	cin>>c1>>c2;
	for(int i=1;i<=n;i++)
	{
		if(root[i])
		{
			dfs(i);
			cout<<max(f[i][0],f[i][1])<<endl;
		}
	}
	
}
```





切入正题https://www.luogu.org/problem/P2458


```c
#include<iostream>
#include<cstdio>
using namespace std;
#define inf  1000000
int n;
int f[50005][3];
int a[5005];
bool root[5005];
int tot=0,head[50005],to[50005],next[500002];
void add(int x,int y)
{
	tot++;
	next[tot]=head[x];
	head[x]=tot;
	to[tot]=y;
}
void dfs(int x)
{
	for(int i=head[x];i;i=next[i])
	{
		int v=to[i];
		dfs(v);
	}
	if(!head[x])
	{
		f[x][0]=a[x];
		f[x][1]=inf;
		f[x][2]=0;
		return ;
	}
	f[x][0]=a[x];
	for(int i=head[x];i;i=next[i])
	{
		int v=to[i];
		f[x][0]+=min(f[v][0],min(f[v][1],f[v][2]));
	}
	f[x][1]=inf;
	for(int i=head[x];i;i=next[i])
	{
		int u=to[i];
		int net=f[u][0];
		for(int j=head[x];j;j=next[j])
		{
			if(i!=j)
			{
				int v=to[j];
				net+=min(f[v][1],f[v][0]);
			}
		}
		f[x][1]=min(f[x][1],net);
	}
	
	f[x][2]=0;
	for(int i=head[x];i;i=next[i])
	{
		int v=to[i];
		f[x][2]+=f[v][1];
	}
	
	
	
	
	
	
	
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		root[i]=true;
	}
	for(int i=1;i<=n;i++)
	{
		int id,num;
		cin>>id;
		cin>>a[id]>>num;
		for(int i=1;i<=num;i++)
		{
			int y;
			cin>>y;
			add(id,y);
			root[y]=false;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(root[i])
		{
			dfs(i);
			cout<<min(f[i][1],f[i][0])<<endl;;	
		}
	}
}
```



---

## 作者：谋事在人 (赞：0)

# 1. 题目背景
五一来临，某地下超市为了便于疏通和指挥密集的人员和车辆，以免造成超市内的混乱和拥挤，准备临时从外单位调用部分保安来维持交通秩序。

已知整个地下超市的所有通道呈一棵树的形状；某些通道之间可以互相望见。总经理要求所有通道的每个端点（树的顶点）都要有人全天候看守，在不同的通道端点安排保安所需的费用不同。

一个保安一旦站在某个通道的其中一个端点，那么他除了能看守住他所站的那个端点，也能看到这个通道的另一个端点，所以一个保安可能同时能看守住多个端点（树的结点），因此没有必要在每个通道的端点都安排保安。

编程任务：

请你帮助超市经理策划安排，在能看守全部通道端点的前提下，使得花费的经费最少。

# 2. 题目解析
lg2458树形dp

儿子与爹的故事

每个节点有三种选择：

#### 0. 被儿子保护
dp[x][0]=$\sum{min(dp[j][0],dp[j][1])}$($j \in x's son$)+儿子中dp[j][1]-dp[j][0]的最小值（贪心，因为只要一个儿子上有保安就可以了）

#### 1. 保护爹
dp[x][1]=$\sum{min(dp[j][0],dp[j][1],dp[j][2])}$+a[x] (x的权值)

#### 2. 坑爹
dp[x][2]=$\sum{min(dp[j][0],dp[j][1])}$

# 3.细节
最后输出时应输出min(dp[1][0],dp[1][1])
可以在O(n)时间内找到儿子中dp[j][1]-dp[j][0]的最小值

# 4.贴代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

struct edge{
	int to,nt;
}e[3010];

int n,m,cnt,x,y,z,head[2000],k[2000],dp[2000][3];//0代表儿子覆盖，1代表放人，2代表坑爹 

void addedge(int x,int y){
	e[++cnt].to=y;
	e[cnt].nt=head[x];
	head[x]=cnt;
}

void dfs(int fa,int x){
	dp[x][1]=k[x];
	int sum=0;
	for(int i=head[x];i;i=e[i].nt){
		if(e[i].to==fa) continue;
		dfs(x,e[i].to);
		sum+=min(dp[e[i].to][0],dp[e[i].to][1]);
		dp[x][1]+=min(min(dp[e[i].to][0],dp[e[i].to][1]),dp[e[i].to][2]);
	}
	dp[x][2]=sum,dp[x][0]=1e9+7;
	for(int i=head[x];i;i=e[i].nt){
		if(e[i].to==fa) continue;
		dp[x][0]=min(dp[x][0],sum-min(dp[e[i].to][0],dp[e[i].to][1])+dp[e[i].to][1]);
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		scanf("%d%d",&k[x],&y);
		for(int j=1;j<=y;j++){
			scanf("%d",&z);
			addedge(x,z);
			addedge(z,x);
		}
	} 
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	dfs(0,1);
	printf("%d\n",max(dp[1][0],dp[1][1]));//防抄袭
	return 0;
}
```

---

## 作者：Apro1066 (赞：0)


## 思路
我感觉和[P2899 手机网络](https://www.luogu.org/problem/P2899)是一模一样的题目......相比之下，只需要改2处代码......（~~双倍经验~~）对于P2899那道题，[我已经写了详细的题解](https://apro1066.top/2019/08/28/%E6%B4%9B%E8%B0%B7-P2899%20%5BUSACO08JAN%5D%E6%89%8B%E6%9C%BA%E7%BD%91%E7%BB%9C/)。

首先对于每个节点$i$，都有如下3种选择：
不选自己，选儿子；
不选自己，选父亲；
我自己选我自己。

令$dp[i][0/1/2]$为节点$i$及其节点$i$的子树中全部被覆盖所需的最小保安数，$dp[i][0]$表示点$i$有保安，$dp[i][1]$为点$i$没有保安，也就是就是父亲有保安，$dp[i][2]$表示节点$i$被间接管辖，也就是儿子有保安。

**1.$dp[i][0]$**

因为节点$i$有保安，所以对于$i$的子节点$son$，它可以没有保安，也可以有保安，也可以从$son$的子节点转移过来。因此：

$$dp[i][0]= \sum min(dp[son][1],dp[son][0],dp[son][2])+val[i]$$

这里$+val[i]$是因为自己本身放置了一个保安，产生的代价。

**2.$dp[i][1]$**

因为节点$i$没有保安，靠的是节点$i$的父亲才被覆盖的，所以对于节点$i$的子节点$son$是不可能选父亲的。所以$dp[i][1]$可以从$dp[son][0]$转移过来（子节点有保安），也可以从$dp[son][2]$转移过来（子节点的儿子有保安）。

$$dp[i][1]=\sum min(dp[son][0[,dp[son][2])$$

**3.$dp[i][2]$**

因为节点$i$没有保安，靠它儿子，所以节点$i$的子节点$son$也不可能选父亲，必然可以从$dp[son][0]$转移过来，也可以从$dp[son][2]$转移过来。

$$dp[i][2]= \sum min(dp[son][0],dp[son][2])$$

很快会发现，如果的确是这样的话，如果$dp[i][2]$**全**从$dp[son][2]$转移过来，也就是若**恒有**$dp[son][2] ≤ dp[son][0]$，**就意味着节点$i$的所有子节点都没有保安！**（那不就凉了）怎么办？

所以我们要设立一个**反悔机制**。**我只需要一个儿子选**。只需要用$p$来记录每一次$dp[son][0]-min(dp[son][2],dp[son][0])$，这样就保证，就算**恒有$dp[son][2] ≤ dp[son][0]$，也一定有一个是儿子选了的**，如果不选$dp[son][2]$，最后$p$的状态也为$0$。若不信，我们做个推导：

记$p=min(p,dp[son][0]-min(dp[son][0],dp[son][2]))$

$dp[i][2]=min(dp[son][0],dp[son][2])+p$

$=min(dp[son][0],dp[son][2])+dp[son][0]-min(dp[son][0],dp[son][2])$

若$dp[son][2] ≤ dp[son][0]$**恒成立**（**注意我说的是恒成立，意思是说$dp[i][2]$全是从$dp[son][2]$转移过来**）

原式$=dp[son][2]+dp[son][0]-dp[son][2]$

$=dp[son][0]$

**也就是把$dp[son][2]$强制转换成了$dp[son][0]$**！

若$dp[son][2]>dp[son][0]$

原式$=dp[son][0]+dp[son][0]-dp[son][0]$

$=dp[son][0]$

**也就是说并不影响$dp[son][0]$的正常取值！**

最后答案为$min(dp[root][0],dp[root][2])$。
```cpp
#include <stdio.h>
#include <iostream>
#define inf 2e9+7
#define N 2001
using namespace std;
int n,m,s,dp[N][3],head[N],cnt,val[N];
struct node
{
	int nxt,to;
}e[N<<1];
inline void add(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs(int u,int fa)
{
	register int i,p(inf);
	dp[u][0]=val[u];
	for(i=head[u];i;i=e[i].nxt)
	{
		int v(e[i].to);
		if(v==fa) continue;
		dfs(v,u);
		dp[u][0]+=min(dp[v][0],min(dp[v][1],dp[v][2]));
		dp[u][1]+=min(dp[v][0],dp[v][2]);
		dp[u][2]+=min(dp[v][0],dp[v][2]);
		p=min(p,dp[v][0]-min(dp[v][2],dp[v][0]));//表示其它儿子的总和
	}
	dp[u][2]+=p;//建立反悔机制 
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		int u,v;
		cin>>u;
		cin>>val[u]>>m;
		while(m--)
		{
			cin>>v;
			add(u,v);
			add(v,u);
		}
	}
	dfs(1,-1);
	cout<<min(dp[1][0],dp[1][2])<<endl;
	return 0;
}
```

---

## 作者：Christopher_Yan (赞：0)


#### 解题思路
首先想到了树形DP

设状态$dp[u][0/1/2]$表示以$u$为根的子树 没选且父亲也没选/没选但父亲选了/选了 时的最小花费。

$dp[u][0]$的转移比较特殊，他要保证至少有一个子节点被选择了，我们可以记录是否选择孩子，若没有，最后选择一个$dp[e[i].v][2]-dp[e[i].v][0]$最小的点强行进行选择。

#### AC代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cctype>

using namespace std;

const int INF = 147480000;
const int N = 2000;

int n, m, a, b, ec, len, ans, val[N], f[N], dp[N][3], ind[N];

struct Edge
{
	int u, v, nxt;
}e[N << 10];

inline void read(int &x)
{
	int k = 1; x = 0;
	char c = getchar();
	while (!isdigit(c))
		if (c == '-') c = getchar(), k = -1; 
		else c = getchar();
	while (isdigit(c))
		x = (x << 1) + (x << 3) + (c ^ 48),
		c = getchar();
	x *= k;
}

inline void Addedge(int a, int b)
{
	++ec;
	e[ec].u = a;
	e[ec].v = b;
	e[ec].nxt = f[a];
	f[a] = ec;
}

void DP(int u, int fa)
{
	int flag = INF;
	dp[u][2] = val[u], dp[u][0] = dp[u][1] = 0;
	if (f[u] == -1) { dp[u][0] = INF; return; }
	for (int i = f[u]; i != -1; i = e[i].nxt)
		if (fa != e[i].v)
		{
			DP(e[i].v, u);
			dp[u][2] += min(dp[e[i].v][1], dp[e[i].v][2]);
			dp[u][1] += min(dp[e[i].v][0], dp[e[i].v][2]);
			dp[u][0] += min(dp[e[i].v][2], dp[e[i].v][0]);
			if (dp[e[i].v][2] <= dp[e[i].v][0])
				flag = 0;
		}
	if (flag)
		for (int i = f[u]; i != -1; i = e[i].nxt)
			if (fa != e[i].v)
				flag = min(flag, dp[e[i].v][2] - dp[e[i].v][0]);
	dp[u][0] += flag == 0 ? 0 : flag;
}

signed main()
{
	read(n);
	memset(f, -1, sizeof(f));
	memset(dp, 0x3f, sizeof(dp));
	for (int i = 1; i <= n; ++i)
	{
		read(a), read(val[a]), read(len);
		for (int j = 1; j <= len; ++j)
			read(b), Addedge(a, b), ++ind[b];
	}
	for (int i = 1; i <= n; ++i)
		if (ind[i] == 0)
			DP(i, 0), ans += min(dp[i][0], dp[i][2]);
	printf("%d", ans);
	return 0;
}
```

---


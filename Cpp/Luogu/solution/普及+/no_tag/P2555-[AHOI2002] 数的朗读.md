# [AHOI2002] 数的朗读

## 题目描述

春游时小可可结识了刚回国定居的 Sealock。但是 Sealock 在海外出生，

回国后才开始学习汉语。数的朗读成为 Sealock 的一个难题，小可可下决心

教会 Sealock 如何朗读绝对值小于 10 亿的数。

小可可知道汉语中有如下的读数规则：

⑴首先读符号位， 然后读整数部分， 整数部分之后可能出现小数点， 如果有

小数部分则小数点一定出现、并且读出小数点之后读小数部分；

⑵符号位的读法是：

(2.1)正数，不论正号“+”是否出现，都不必读出符号位；

(2.2)负数的最左边的符号是“-”， 读成“ 负” (以“ F” 来表示“负” )；

⑶整数部分的读法是：

蚌埠， 2002.4.20 AH02SGOI11A1.doc 第1页

2002 年安徽省青少年信息学(计算机)竞赛网上同步赛暨 SGOI 第十一次友谊赛 一试试题

(3.1)如果整数部分不存在或者整数部分全是零则直接读成“零” (以“ 0”

来表示“零” )；

(3.2)否则从整数部分中最左边的非零数字开始读起， 然后以十、 百、 千、

万、亿(分别以“ S”、“ B”、“ Q”、“ W”、“ Y”来表示)等数量单位来拼读整

数部分；

⑷整数部分中：

(4.1)每一个非零数字都必须结合各个相应的数量单位读出来；

(4.2)每一段连续的“零” 只能读成一个“零”， 但是某一段连续的“零”的左侧或者右侧不存在非零数字(这里只考虑整数部分)则这一段“零” 不应该读出来；

⑸如果有小数部分，则首先读“点”(以“ D”来表示“点”)，然后从左至右顺序地读出各个小数位。 在读小数部分的时候不可以使用十、 百、 千、 万、亿等数量单位； 但是小数部分的每一个数字都需要读出来， 连续的零不可以读成一个“零”，而应该分别读出；

⑹如果数中有小数点而没有小数部分，则不应该把小数点读出来。

例如， -0020030004.567 应该读成“ F2Q03W04D567”， 000.89 应该读成“ 0D89”。

请你编写程序帮助小可可把给定的数正确地读出来。


## 样例 #1

### 输入

```
000.89```

### 输出

```
0D89```

## 样例 #2

### 输入

```
-0020030004.567```

### 输出

```
F2Q03W04D567```

# 题解

## 作者：Victorique (赞：4)

#见过的最恶心的模拟#

这个题题意非常明白，思路非常清晰，做法非常单一，但是就是很难做。。要注意的细节远远超乎预料。

各种细节的注意直接扔到代码里了，貌似也没有什么非常的地方和关键代码。实际上是因为处处都是关键代码。。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
int z,flag,o,l,n,l1,d=-1,k,book,yi;
char ch[1001],ch1[101],shu[5];
int main()
{
    shu[1]='S';
    shu[2]='B';
    shu[3]='Q';//这里的处理可以凭个人喜好，我个人比较喜欢这么处理，后面也比较简洁。
    cin>>ch;//不要想当然的一个个读，正常情况下好像没问题，但是0一多就会错了，老老实实直接全读进来比较好，也可以用循环从1开始读入，有强迫症的自便。
    l=strlen(ch);
    for(int i=0;i<l;i++)
    {
        if(ch[i]=='+'||ch[i]=='-'||ch[i]=='0')//仔细读题，不仅只有符号和前缀0，还有“+”这个坑货。。。。
        {
            o++;//o用来记录你读完这些字符一共用了多长。
        }
        if(ch[i]=='.')
        {
            d=i;
            break;//如果前面全是0，又读到小数点，单独算一种情况。
        }
    }
    if(o==l)//极端情况之一，全是0，不要觉得这个很多余，因为出现+0000000000000这样的数也不是不可能。。
    {
        cout<<"0";
        return 0;
    }
    if(o==d)//这里就是第一种情况分支，如果是个小于1的小数，当成特殊情况处理。
    {
        cout<<"0";
        flag=1;//进行标记。
    }
    if(d==-1)//如果压根没有读到小数点，把小数点的位置标记为第l位。
    d=l;
    if(flag==1)//特殊处理<1的情况
    {
        cout<<"D";
        for(int i=o+1;i<l;i++)//从小数点下一位直接读到最后
        {
            cout<<ch[i];
        }
        return 0;
    }else//处理不是<1的情况
    {
        if(ch[0]=='-')//如果有负号（题目规定一定是第一个字符），先读出来
        {
            cout<<"F";
            k++;//当前读到的位数
        }else
        if(ch[0]=='+')//这个坑爹的+又出现了，必须特殊处理。。。。
        k++;
        while(ch[k]=='0')//处理掉所有的前缀0
        k++;
        for(int i=k;i<d;i++)
        {
            if(d-i>8)//如果此时剩下的位数多余8位，输出Y，数据保证不大于十亿，所以不用管之前有没有S什么的。
            {
                cout<<ch[i];
                cout<<"Y";
                continue;
            }
            if(d-i>5)//处理万级。
            {
                if(ch[i]!='0')//如果当前的数不是0，就要读出来
                {
                    if(book==1)//如果之前的一位是0，读出来那个0
                    {
                        cout<<"0";
                        cout<<ch[i];
                        if(d-i-1!=0)
                        cout<<shu[d-i-4-1];//这就是用1,2,3标记的原因，这里很好处理。。。
                        book=0;//把标记取消
                        yi=1;//确定这个数大于一万并且有一个不是0的数。
                    }else
                    {
                        cout<<ch[i];//如果前面没有0直接输出就可以了
                        if(d-i-1!=0)//如果这个数减出来不是0，就输出后面的，防止输出无用空格。
                        cout<<shu[d-i-4-1];
                        yi=1;
                    }
                }else
                {
                    book=1;//打上标记。
                }
                continue;
            }
            if(d-i==5)//当读到万位时由于有W特殊处理
            {
                if(d-k>8&&yi==0)//如果这个数在10亿以上并且万级全是0
                yi=0;//继续是0不用读了。
                else
                {    
                    if(ch[i]!='0')//如果当前位不是0
                    {
                        if(book==1)//刚才的标记现在还可以用
                        {
                            cout<<"0";
                            cout<<ch[i];
                            cout<<"W";//把万读出来
                            book=0;
                        }else
                        {
                            cout<<ch[i];//直接读
                            cout<<"W";
                        }
                    }else//直接读W，打上标记。
                    {
                    cout<<"W";
                    book=1;
                    }    
                    book=0;
                    continue;
                }
            }
            if(d-i<=4)//千位一下的就很好处理了
            {
                if(ch[i]!='0')
                {
                    if(book==1)
                    {
                        cout<<"0";
                        cout<<ch[i];
                        if(d-i-1!=0)
                        cout<<shu[d-i-1];
                        book=0;
                    }else
                    {
                        cout<<ch[i];
                        if(d-i-1!=0)
                        cout<<shu[d-i-1];
                    }
                }else
                {
                    book=1;
                }
            }
        }
        if(d!=l&&d!=l-1)//最后再处理一遍小数点。
        {
            cout<<"D";
            for(int i=d+1;i<l;i++)
            cout<<ch[i];//这才算真正结束了。
        }
    }
}
```
#真是恶心的模拟#
总而言之，这个题有耐心，总是能做出来的，毕竟什么高级算法都没用。。。。


---

## 作者：K2sen (赞：3)

### 思路
我们可以先把他拆分成三部分

- 符号
- 整数部分
- 小数部分


我们都可以知道，符号部分和小数部分很容易处理，难在整数部分。

可以把整数部分拆成亿位上的数加上万位上的四个数加上个位上的四个数。

我们发现读数的时候，这三个部分除了连接处的亿、万、零之外读数都相同。

所以我们可以处理出怎么读出多少千多少百 $\dots$。

连接处的亿、万、零可以单独处理。



### code

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
#define N 100010
#define M 110

using namespace std;
const int mod = 1e9+7;
const int inf = 0x3f3f3f3f;
int n, ff, fd, st, ed, shu;
char sy[M];

void na10000(int x) {
  int q = x / 1000, b = x % 1000 / 100, s = x % 100 / 10, g = x % 10;
  if (q) {
    cout << q << "Q";
    if (b) {
      cout << b << "B";
      if (s) {
        cout << s << "S";
        if (g) cout << g;
      } else if (g) cout << "0" << g;
    } else {
      if (s) {
        cout << "0" << s << "S";
        if (g) cout << g;
      } else if (g) cout << "0" << g;
    }
  } else {
    if (b) {
      cout << b << "B";
      if (s) {
        cout << s << "S";
        if (g) cout << g;
      } else if (g) cout << "0" << g;
    } else {
      if (s) {
        cout << s << "S";
        if (g) cout << g;
      } else if (g) cout << g;
    }
  }
}

void pd(int g) {
  if (g >= 1000) na10000(g);
  else {
    if (g) cout << "0", na10000(g);
    else na10000(g);
  }
}

signed main() {
  cin >> sy;
  n = strlen(sy);
  if (sy[0] == '-') ff = 1;
  for (int i = 0; i < n; i++)
    if (isdigit(sy[i])) {
      st = i;
      break;
    }
  ed = n - 1;
  for (int i = 0; i < n; i++)
    if (sy[i] == '.') fd = 1, ed = i - 1;
  if (ed == n - 2) fd = 0;
  if (ff) cout << 'F';
  for (int i = st; i <= ed; i++) shu *= 10, shu += sy[i] - '0';
  if (shu == 0) {
    if (fd) {
      cout << "0D";
      for (int i = ed + 2; i < n; i++) cout << sy[i];
    } else cout << '0';
  } else {
    int yi = shu / 100000000, w = shu % 100000000 / 10000, g = shu % 10000;
    if (yi) {
      na10000(yi), cout << "Y";
      if (w) {
        if (w < 1000) cout << "0";
        na10000(w), cout << "W", pd(g);
      } else cout << "0", na10000(g);
    } else {
      if (w) na10000(w), cout << "W", pd(g);
      else na10000(g);
    }
    if (fd) {
      cout << "D";
      for (int i = ed + 2; i < n; i++) cout << sy[i];
    }
  }
}
```

---

## 作者：蓝色鍀梦境 (赞：2)

本蒟蒻去翻了翻大佬们的题解，发现好长哦~~而且一个也看不懂~~

而且这道非常恶心、坑巨多的模拟卡了我八九遍QAQ

然后我就决定写一篇题解，帮各位防坑~~（虽然只有我这样的蒟蒻会挨个踩坑）~~

下面正文开始~

## 思路

我们可以讲输入分成四个部分：
- 前置符号（不一定存在）
- 整数部分
- 小数点（不一定存在）
- 小数部分（不一定存在）

由于不确定因素过多，所以我选择使用```getchar()```挨个读取，这样一来事情变得简单了很多。

## 执行策略

### 读入
易得出方法如下:

使用两个字符串a、b，分别保存整数部分和小数部分，

1. 当读入部分为符号的时候对三种可能的符号特判一下

2. 读入为数字则看是否已经读入小数点：

- 已经读小数点：
  
  直接塞到小数部分。
  
- 未读入小数点：
  
  判断是否为前导0，若是则舍去。

读入部分就是这么简单，部分小坑已经放在代码注释。

### 改装整数部分

可以说是最难受的部分了。

不仅要各种加YQBSWQBSD还要把有0的归到一起！好烦人！

额，等等？

读出来的数位，**后面跟的字母的顺序好像就是YQBSWQBSD**？

太棒了！这是一个很好的偷懒方式！（

于是我们新建一个char数组（string也可）：

```cpp
const char zz[] = "SBQWSBQY";
```

（不要问我为什么我写的是倒序的而且没有D）

那么问题基本就解决了：只要在非0的时候输出对应数字+对应符号，为0的时候输出一个0，等到后面再来一个非0的时候就好啦！

但是，有一个小小的隐患：如果最后几位都是0怎么办？

有一个很简单很暴力的方法：统计出来有几个0，到了那里直接不输出了！

```cpp
int ling = 0;
for(int i = a.size() - 1; ; --i){ 
	if(a[i] != '0') break;
	ling++;
	}
```

到现在为止，整数部分就输出完了！

小数部分更简单：如果b不是空的，就输出D加上b！

那么这道题就愉快地结束啦~

下面附上代码ovo 有些坑点写在了注释里~
```cpp
#include<bits/stdc++.h>
using namespace std;
const char zz[] = "SBQWSBQY";//每一位对应的字母 
int main(){
	char c = getchar();
	string a = "",b = "";//a为小数点前数，b为小数点后数 
	bool bb = 0;// 万用布尔 
	while(c != EOF && c != '\n' && c != '\r'){//读入部分，第一个坑点，本题带\r 
		if(c == '-'){
			cout << "F";//负数特判 
			c = getchar();continue;
		}
		else if(c == '+'){//第二个坑点，有的数据点有正号 
			c = getchar();continue;
		}
		else if(c == '.'){bb = 1;c = getchar();continue;}//这里bb表示是否向小数点后的字符串读入 
		if(!bb) {if(a.size() != 0 || c != '0') a += c;}//即!(a.size() == 0 && c == '0')，不读入前导0 
		else b += c;
		c = getchar();
	}
	if(!a.size()){cout << "0"; if(b.size() != 0) cout << "D" << b; return 0;}//特判一下a为空 
	bb = 1;//现在开始它代表是否已经输出0 
	int ling = 0;//结尾0的个数需要记录，因为当a结尾都是0的时候无需额外输出 
	for(int i = a.size() - 1; ; --i){//计算0个数 
		if(a[i] != '0') break;
		ling++;
	}
	for(int i = 0; i < a.size(); ++i){//只需处理a 
		if(a[i] != '0'){
			cout << a[i];
			if(a.size() - i - 2 <= 8) cout << zz[a.size() - i - 2];//算出应输出的对应位数 
			bb = 0;//没有需要输出的0 
		}
		else if(!bb && i < a.size() - ling){cout << 0; bb = 1;}//已经输出0 
	}
	if(b.size() != 0) cout << "D" << b;//小数点后直接输出 
	cout << endl;
	return 0;
}
```

顺便弄了个防copy，相信认真看的人一定看出来了~

那么这篇题解到这里就结束了，可能还有些细节没考虑到，希望大家原谅/(ㄒoㄒ)/~如果还有不懂的地方也可以问问我！ヾ(•ω•`)o

掰掰~

---

## 作者：Drinkkk (赞：2)

## 题目描述

春游时小可可结识了刚回国定居的 Sealock。但是 Sealock 在海外出生，回国后才开始学习汉语。数的朗读成为 Sealock 的一个难题，小可可下决心教会 Sealock 如何朗读绝对值小于 10 亿的数。

小可可知道汉语中有如下的读数规则：

⑴ 首先读符号位， 然后读整数部分， 整数部分之后可能出现小数点， 如果有小数部分则小数点一定出现、并且读出小数点之后读小数部分；

⑵ 符号位的读法是：

(2.1) 正数，不论正号 “``+``” 是否出现，都不必读出符号位；

(2.2) 负数的最左边的符号是 “``-``” ， 读成“ 负” (以 “``F``” 来表示“负” )；

⑶ 整数部分的读法是：

(3.1) 如果整数部分不存在或者整数部分全是零则直接读成“零” (以“``0``”来表示“零” )；

(3.2) 否则从整数部分中最左边的非零数字开始读起， 然后以十、 百、 千、万、亿(分别以 “``S``” 、 “``B``” 、 “``Q``” 、 “``W``” 、 “``Y``” 来表示)等数量单位来拼读整数部分；

⑷ 整数部分中：

(4.1) 每一个非零数字都必须结合各个相应的数量单位读出来；

(4.2) 每一段连续的“零” 只能读成一个“零”， 但是某一段连续的“零”的左侧或者右侧不存在非零数字(这里只考虑整数部分)则这一段“零” 不应该读出来；

⑸ 如果有小数部分，则首先读“点”(以 “``D``” 来表示“点”)，然后从左至右顺序地读出各个小数位。 在读小数部分的时候不可以使用十、 百、 千、 万、亿等数量单位； 但是小数部分的每一个数字都需要读出来， 连续的零不可以读成一个“零”，而应该分别读出；

⑹ 如果数中有小数点而没有小数部分，则不应该把小数点读出来。

例如，``-0020030004.567`` 应该读成 “``F2Q03W04D567``” ， ``000.89`` 应该读成 “``0D89``” 。

请你编写程序帮助小可可把给定的数正确地读出来。

## 输入输出格式

- 输入格式

文件中以一行的形式存放了一个数(不超过 $50$ 个字符)，其绝对值小于 $10$ 亿。

- 输出格式：

以一行的形式输出这个数的正确读法。

## 输入输出样例

```
Input1:
000.89
Output1:
0D89

Input2:
-0020030004.567
Output2:
F2Q03W04D567
```

## 题解

我们来看一下对于 ``100920152.10`` 这个数它的读法是应该是 ``1Y09S2W01B5S2D10`` 。

我们试着把 ``1Y09S2W01B5S2D10`` 中的 ``Y`` 、 ``W`` 和 ``D`` 当做分界线看。

这样  ``1Y09S2W01B5S2D10`` 就变成了 ``1(Y)09S2(W)01B5S2(D)10`` 。

每一段分别对应原数中的 ``1``、``0092`` 、 ``0152``、``10`` 。

不难发现每一个部分最多仅有 4 位，所以我们只要暴力枚举出当只有 1 到 4 位时的读法，再套上亿、万就行了。小数点的处理很简单，直接读出来就可以了。

但是要注意 ``1.`` 只读出 ``1`` ，而不是 ``1D`` 。

``.567`` 读作 ``0D567`` 。

> ⑹ 如果数中有小数点而没有小数部分，则不应该把小数点读出来。

注意 ``+0`` 读作 ``0`` ，还要注意有多个前导 0 的情况。负号也要处理好。

目前的 Hack 数据本题解都是能够通过的，欢迎各位来 Hack！

## 参考代码

```
#include <cstdio>
#include <cstring>
char st[1000001];
void print(int cd,char a,char b,char c,char d)
{
	if(cd==1)
	{
		printf("%c",a);
	}
	else if(cd==2)
	{
		printf("%cS",a);
		if(b!='0')
		{
			printf("%c",b);
		}
	}
	else if(cd==3)
	{
		printf("%cB",a);
		if(b!='0')
		{
			printf("%cS",b);
			if(c!='0')
			{
				printf("%c",c);
			}
		}
		if(b=='0' && c!='0')
		{
			printf("0%c",c);
		}
	}
	else if(cd==4)
	{
		if(a!='0')
		{
			printf("%cQ",a);
		}
		else if(a=='0' && b!='0')
		{
			printf("0");
		}
//		if(b=='0' && c=='0' && d=='0')
//		{
//			
//		}
		if(b!='0' && c=='0' && d=='0')
		{
			printf("%cB",b);
		}
		if(b=='0' && c!='0' && d=='0')
		{
			printf("0%cS",c);
		}
		if(b=='0' && c=='0' && d!='0')
		{
			printf("0%c",d);
		}
		if(b!='0' && c!='0' && d=='0')
		{
			printf("%cB%cS",b,c);
		}
		if(b!='0' && c=='0' && d!='0')
		{
			printf("%cB0%c",b,d);
		}
		if(b=='0' && c!='0' && d!='0')
		{
			printf("0%cS%c",c,d);
		}
		if(b!='0' && c!='0' && d!='0')
		{
			printf("%cB%cS%c",b,c,d);
		}
	}
}
int main()
{
	scanf("%s",st+1);
	int len=strlen(st+1);
	if(st[1]=='-' || st[1]=='+')
	{
		if(st[1]=='-')
		{
			printf("F");
		}
		int x=2;
		while(st[x]=='0' && st[x+1]!='.')
		{
			x++;
		}
		for(int i=1;i<=len;i++)
		{
			st[i]=st[i+x-1];
		}
		len-=x-1;
	}
	else
	{
		int x=1;
		while(st[x]=='0' && st[x+1]!='.')
		{
			x++;
		}
		for(int i=1;i<=len;i++)
		{
			st[i]=st[i+x-1];
		}
		len-=x-1;
	}
	int ed=len;
	for(int i=1;i<=len;i++)
	{
		if(st[i]=='.')
		{
			ed=i-1;
			break;
		}
	}
	int cdz=ed;
	int qu=0;
	if(cdz>=9)
	{
		if(cdz==9)
		{
			qu=1;
			print(1,st[1],0,0,0);
		}
		else if(cdz==10)
		{
			qu=2;
			print(2,st[1],st[2],0,0);
		}
		else if(cdz==11)
		{
			qu=3;
			print(3,st[1],st[2],st[3],0);
		}
		else if(cdz==12)
		{
			qu=4;
			print(4,st[1],st[2],st[3],st[4]);
		}
		printf("Y");
	}
	int su=0;
	if(cdz>=5)
	{
		if(cdz==5)
		{
			su+=st[qu+1]-'0';
			print(1,st[qu+1],0,0,0);
			qu++;
		}
		else if(cdz==6)
		{
			su+=st[qu+1]-'0'+st[qu+2]-'0';
			print(2,st[qu+1],st[qu+2],0,0);
			qu+=2;
		}
		else if(cdz==7)
		{
			su+=st[qu+1]-'0'+st[qu+2]-'0'+st[qu+3]-'0';
			print(3,st[qu+1],st[qu+2],st[qu+3],0);
			qu+=3;
		}
		else if(cdz>=8)
		{
			su+=st[qu+1]-'0'+st[qu+2]-'0'+st[qu+3]-'0'+st[qu+4]-'0';;
			print(4,st[qu+1],st[qu+2],st[qu+3],st[qu+4]);
			qu+=4;
		}
		if(su!=0)
		{
			printf("W");
		}
		cdz=4;
	}
	if(cdz<5)
	{
		if(ed==1)
		{
			print(1,st[1],0,0,0);
		}
		else if(ed==2)
		{
			print(2,st[1],st[2],0,0);
		}
		else if(ed==3)
		{
			print(3,st[1],st[2],st[3],0);
		}
		else if(ed==4)
		{
			print(4,st[1],st[2],st[3],st[4]);
		}
		else if(ed>4)
		{
			if(st[ed-3]-'0'+st[ed-2]-'0'+st[ed-1]-'0'+st[ed]-'0'!=0 && su==0 && st[ed-3]!='0')
			{
				printf("0");
			}
			print(4,st[ed-3],st[ed-2],st[ed-1],st[ed]);
		}
	}
	if(ed==0)
	{
		printf("0");
	}
	if(st[ed+1]=='.' && ed+2<=len)
	{
		printf("D");
	}
	for(int i=ed+2;i<=len;i++)
	{
		printf("%c",st[i]);
	}
	return 0;
}
```

---

## 作者：AOTO (赞：2)

春游时小可可结识了刚回国定居的 Sealock。但是 Sealock 在海外出生，

回国后才开始学习汉语。数的朗读成为 Sealock 的一个难题，小可可下决心

教会 Sealock 如何朗读绝对值小于 10 亿的数。

小可可知道汉语中有如下的读数规则：

⑴首先读符号位， 然后读整数部分， 整数部分之后可能出现小数点， 如果有

小数部分则小数点一定出现、并且读出小数点之后读小数部分；

⑵符号位的读法是：

(2.1)正数，不论正号“+”是否出现，都不必读出符号位；

(2.2)负数的最左边的符号是“-”， 读成“ 负” (以“ F” 来表示“负” )；

⑶整数部分的读法是：

(3.1)如果整数部分不存在或者整数部分全是零则直接读成“零” (以“ 0”

来表示“零” )；

(3.2)否则从整数部分中最左边的非零数字开始读起， 然后以十、 百、 千、

万、亿(分别以“ S”、“ B”、“ Q”、“ W”、“ Y”来表示)等数量单位来拼读整

数部分；

⑷整数部分中：

(4.1)每一个非零数字都必须结合各个相应的数量单位读出来；

(4.2)每一段连续的“零” 只能读成一个“零”， 但是某一段连续的“零”的左侧或者右侧不存在非零数字(这里只考虑整数部分)则这一段“零” 不应该读出来；

⑸如果有小数部分，则首先读“点”(以“ D”来表示“点”)，然后从左至右顺序地读出各个小数位。 在读小数部分的时候不可以使用十、 百、 千、 万、亿等数量单位； 但是小数部分的每一个数字都需要读出来， 连续的零不可以读成一个“零”，而应该分别读出；

⑹如果数中有小数点而没有小数部分，则不应该把小数点读出来。

例如， -0020030004.567 应该读成“ F2Q03W04D567”， 000.89 应该读成“ 0D89”。

请你编写程序帮助小可可把给定的数正确地读出来。
输入输出格式
输入格式：

文件中以一行的形式存放了一个数(不超过 50 个字符)，其绝对值

小于 10 亿。

输出格式：

以一行的形式输出这个数的正确读法。

输入输出样例
输入样例#1： 复制

000.89

输出样例#1： 复制

0D89

输入样例#2： 复制

-0020030004.567

输出样例#2： 复制

F2Q03W04D567

### 题目有很多恶心的地方
### 比如：  
### 输入 .123
### 输出 0D123
### 输入 123.
### 输出 123
### 输入 100000001.1230
### 输出 1Y01D1230

# 递上本蒟蒻的代码：
```cpp
#include<bits/stdc++.h>//无敌万能头   
using namespace std;  
string s;int l,k;   
char a[10001];bool tt,gg,gg1;  
int main()  
{

    cin>>s;
    if(s=="-0")//特判
    {
        cout<<"0";
        return 0;
    }
    if(s[0]=='+')//正数
      l=1;
    else 
    if(s[0]=='-')//输出负数
      {
        cout<<'F';l=1;
      }
      else
      l=0;
    k=-2;
    while((l+1<s.size())&&(s[l]=='0')&&(s[l+1]!='.'))l++;//把头的0删掉
    for(int i=l;i<s.size();i++)
    if(s[i]=='.')
    {
        s[i]='D';
        k=i-1;break;
    }//找到个位的位置，并存到k
    if(k==-1)
    {
        cout<<0;
        for(int i=0;i<s.size();i++)
        cout<<s[i];
        return 0;
    }//没有个位的数直接输出0.+小数
    if(k==-2)k=s.size()-1;k=k-1;
    if(k>=l)a[k]='S';            //放字母
    if(k-1>=l)a[k-1]='B';
    if(k-2>=l)a[k-2]='Q';
    if(k-3>=l)a[k-3]='W';
    if(k-4>=l)a[k-4]='S';
    if(k-5>=l)a[k-5]='B';
    if(k-6>=l)a[k-6]='Q';
    if(k-7>=l)a[k-7]='Y';
    for(int i=l;i<=k+2;i++)//第k+2位是小数点，将整数部分和小数点输出
    {
        if(i!=k+2)
        {
            if((s[i]=='0')&&(i==k+1)&&(tt==false))//符号前的0要输出
            {
                cout<<s[i];tt=true;gg1=false;
            }
            else
            if((s[i]=='0')&&(s[i+1]!='0')&&(i!=k+1))//判断连续的0
            {
                cout<<s[i];tt=true;gg1=false;
            }
            else
            if(s[i]!='0')//不是0的直接输出
            {
                cout<<s[i];tt=true;gg1=false;
            }
        }
        else
        if(i!=s.size()-1)//如果小数点不是结尾就输出小数点
        {
            cout<<s[i];
            tt=true;gg=false;
        }

        if((a[i]>='A')&&(s[i]!='0'))//判断符号并输出
        {
            gg=true;
            cout<<a[i];
            if(a[i]=='Y')
			{
				gg1=true;gg=true;
			}
        }
        else
        if((a[i]=='Y')&&(tt)) 
        {
            gg=true;
			gg1=true;
            cout<<a[i];
        }
        else
        if((a[i]=='W')&&(tt))
        {
            if((gg1==false)&&(gg==true)||(gg==false))cout<<a[i];
        }
    }
    for(int i=k+3;i<s.size();i++)//输出小数部分
    {
        cout<<s[i];
    }
    return 0;
}//终于结束了
```


---

## 作者：友邻牧鸡 (赞：2)

这个题就是个模拟，我们可以看到，千万到万位和千位到个位的读数差不多，所以这两个可以串通一下，这里重点在于读零的判断，这里可以用一个bool变量来表示前面有没有连读的0，避免重复。代码丑/捂脸






```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[10001],n;
int init()
{
    bool zsd=1;
    int jg=0,zf=1;
    char c=getchar(); 
    if(c=='.')
    {
        c=getchar();
        while(c>='0'&&c<='9')
        {
            a[++a[0]]=c-'0';
            c=getchar();
        }
        return 0;
    }
    while(c<'0'||c>'9'){if(c=='-')zf*=-1;c=getchar();}
    while(c>='0'&&c<='9'){jg=(jg<<1)+(jg<<3)+c-'0';c=getchar();}
    if(c=='.')
    {
        c=getchar();
        while(c>='0'&&c<='9')
        {
            a[++a[0]]=c-'0';
            c=getchar();
        }
    }
    return jg*zf;
}
int zs[1001],m,w,g;
bool dw,yl;
int main()
{
    m=n=init();
    if(n<0)
    {
        m*=-1;
        n*=-1;
        cout<<'F';
    }
    if(m/100000000!=0)
    {
        cout<<m/100000000<<'Y';
        dw=1;
        m%=100000000;
    }
    w=m/10000;
    if(w/1000!=0)
    {
        cout<<w/1000<<'Q';
        dw=1;
    }
    if(w/1000==0&&dw)
    yl=1;
    w=w%1000;
    if(w/100!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<w/100<<'B';
        dw=1;
    }
    if(w/100==0&&dw)
    yl=1;
    w%=100;
    if(w/10!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<w/10<<'S';
        dw=1;
    }
    if(w/10==0&&dw)
    yl=1;
    w%=10;
    if(w!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<w;
        dw=1;
    }
    if(w/10==0&&dw)
    yl=1;
    if(m/10000!=0)
    {
        cout<<'W';
        yl=0;
    }
    m%=10000;
    g=m;
    if(g/1000!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<g/1000<<'Q';
        dw=1;
    }
    if(g/1000==0&&dw)
    yl=1;
    g=g%1000;
    if(g/100!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<g/100<<'B';
        dw=1;
    }
    if(g/100==0&&dw)
    yl=1;
    g%=100;
    if(g/10!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<g/10<<'S';
        dw=1;
    }
    if(g/10==0&&dw)
    yl=1;
    g%=10;
    if(g!=0)
    {
        if(yl)
        {
            yl=0;
            cout<<0;
        }
        cout<<g;
        dw=1;
    }
    if(n==0)
    cout<<0; 
    if(a[0])
    {
        cout<<'D';
        for(int i=1;i<=a[0];i++)
        cout<<a[i];
    }
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：1)

上手鉴定大膜你。

想想一下把思路实现细节讲完好像有点难······

缩以决定跟着代码走。

阅读需要一定时间，建议转去[blog](https://www.luogu.com.cn/blog/2007100723874wxz/solution-p2555)阅读。

代码不到40行（39行滑稽，估计是题解里数一数二的短）但细节真的肥肠多~

用一个字符串s存储数字串。

由于有前缀0，需要起点hd(head)记录从第几个字符开始读（前缀0自动跳过）。

为了避免O(n)strlen(没错用的是char*)用终点tl(tail)记录最后一个位置.

方便起见统一整数和小数，正数和负数。（整数后面加个小数点，符号位直接处理）

上面这些的代码：
```cpp
  scanf("%s",s);tl=strlen(s)-1;
  if(!count(s,s+tl+1,'.'))s[++tl]='.';
  if(s[0]=='-')putchar('F'),++hd;
  if(s[0]=='+')++hd;while(s[hd]==48)++hd;
  if(hd==tl)return putchar(48),0;
  //上面这行执行的唯一可能性是整数部分全零且没有小数部分，特判
```
然后整数小数部分剥离。

小数部分：简单粗暴直接输出。（

代码：
```cpp
  for(int i=hd;i<=tl;++i)
  if(s[i]=='.'){
      if(i!=hd)putint(hd,i-1);//如果有整数部分则输出
      else putchar(48);//否则输出0补位
      if(i!=tl)putchar('D'),puts(s+i+1);//小数点特判
      else putchar('\n');//换行符
      break;//完成！
  }
```
好了主函数没了（就这么短）。

接着来写整数部分的输出——putint.

首先，虽然说是按个十百千万亿拆分，但其实是按照亿万个拆分，每段里个十百千拆分。

亿万个拆分的特点——除第一段外每一段四个数字。

特判一下0.

大框架：
```cpp
  //参数:beg,ed表示输出[beg,ed]区间的数
  int len=ed-beg+1,lst=beg+(len+3)%4,tag=(len-1)/4;
  //总长，第一段结尾位置，第一段是个/万/亿
  putsmall(beg,lst++);//putsmall输出四位以内的数
  if(tag)//如果不是个位那么一段段拆开输出
  for(putchar(bdig[tag--]);lst<ed;lst+=4,--tag)
  if(count(s+lst,s+lst+4,'0')<4)//如果这一段不全是0
  putsmall(lst,lst+3),tag&&putchar(bdig[tag]);//输出数字+单位
```
其中bdig表示大的单位（类似sdig表示小的单位，见后），代码：
```cpp
const char sdig[]={0,'S','B','Q'},bdig[]={0,'W','Y'};
```
好了，终于只剩一个putsmall了~

对于四位以内的数，结尾的0不读出，可以通过--ed实现。

连续的0只读一个，可以靠判断前一位是不是0决定。

至于单位，可以按照离结尾还有几个数字判断（像上面那样）。

但不同的是由于有--ed操作（过滤0）所以要记录一个tmp=ed来保留原来的结尾位置。

代码：
```cpp 
  //参数:beg,ed表示输出[beg,ed]区间的数
  int tmp=ed;//如上
  while(ed>=beg&&s[ed]==48)--ed;//过滤0
  //putint里有特判全零所以不会溢出
  while(s[beg]==48&&s[beg+1]==48)++beg;//过滤开头的0直到最多剩1个
  if(s[beg]==48)putchar(48),++beg;//如果开头确实有0就输出掉
  for(int i=beg;i<=ed;++i){
      if(s[i]!=48)putchar(s[i]),i!=tmp&&putchar(sdig[tmp-i]);//如果非0就输出数+单位
      else if(s[i-1]!=48)putchar(48);
      //如果上一位也是0（例：2008的十位）这个0就无视
      //如果是0就没有单位了
  }
```
于是······这题就没了。

上代码（有一个防抄，凡是认真看的应该都能找出）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const char sdig[]={0,'S','B','Q'},bdig[]={0,'W','Y'};
char s[100];
int hd,tl;
inline void putsmall(int beg,int ed){
	int tmp=ed;
	while(ed>=beg&&s[ed]==48)--ed;
	while(s[beg]==48&&s[beg+1]==48)++beg;
	if(s[beg]==48)putchar(48),++beg;
	for(int i=beg;i<=ed;++i){
		if(s[i]!=48)putchar(s[i]),i!=tmp&&putchar(sdig[tmp-i]);
		else if(s[i-1]!=48)putchar(48);
	}
}
inline void putint(int beg,int ed){
	int len=ed-beg+1,lst=beg+(len+3)%4,tag=(len-1)/4;
	putsmall(beg,lst++);
	if(tag)for(putchar(bdig[tag--]);lst<ed;lst+=4,--tag)
	if(count(s+lst,s+lst+4,'0')<4)
	putsmall(lst,lst+3),tag&&putchar(bdig[tag]);
}
int mian(){
	scanf("%s",s);tl=strlen(s)-1;
	if(!count(s,s+tl+1,'.'))s[++tl]='.';
	if(s[0]=='-')putchar('F'),++hd;
	if(s[0]=='+')++hd;while(s[hd]==48)++hd;
	if(hd==tl)return putchar(48),0;
	for(int i=hd;i<=tl;++i)if(s[i]=='.'){
		if(i!=hd)putint(hd,i-1);
		else putchar(48);
		if(i!=tl)putchar('D'),puts(s+i+1);
		else putchar('\n');
		break;
	}
	return 0;
}
```
**Over**.

祝大家切题开心！

---

## 作者：Deny_小田 (赞：1)

我说这题难度算偏高吧。

其实实现不难，就是要把所有情况考虑到。


参考资料：

http://blog.163.com/englanq@126/blog/static/64653471201191134146168/

有兴趣的同学可以去看看。


思路在那里头都有了。

那个代码比较难懂，我又写了一个带注释的，大家看看吧。












```cpp
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;
const int size = 25;
int len,length;
char ch[size];
string str;
void init(){
    ios::sync_with_stdio(false);
    cin >> str;
    length = len = str.size();
    str = "0"+str;
}
void work(){
    int q = 1,z = len,x = len+1;        //q代表当前下标
    bool ispoint = false;
    if(str[1] == '-'){
        printf("F");
        q++;
    }
    for(int i = 1; i <= z; i++){        //判断是否是小数的循环
        if(str[i] == '.'){
            x = i;
            ispoint = true;
            break;
        }
    }
    z = x-1;    //z = 整数部分的最后一个数的下标 
    while(str[q] == '0'&&q < z) q++;    //判断前导零的循环
    if(q == z){        //如果前导零到整数部分的末尾了，即整数部分为0了
        printf("0");
        if(ispoint){        //如果还有小数部分
            printf("D");
            for(int i = x+1; i <= len; i++) printf("%c",str[i]);
        }
        return ;
    }
    //下面进行字母赋值
    ch[2] = 'S'; ch[3] = 'B'; ch[4] = 'Q'; ch[5] = 'W'; ch[6] = 'S'; ch[7] = 'B'; ch[8] = 'Q';
    ch[9] = 'Y'; ch[10] = 'S'; ch[11] = 'B';
    len = z-q+1;        //len = 当前整数部分的长度（去掉前导零和负号之后）
    for(int i = q; i < z; i++){            //输出整数部分不包括个位的数字
        if(str[i] != '0') printf("%c%c",str[i],ch[len]);        //如果当前位非零，直接输出
        else if((len-1)%4 == 0) printf("%c",ch[len]);        //如果当前位不在十位、万位，输出‘0’
        else if(str[i-1] != '0'||len%4 == 0) printf("0");        
                //否则如果下一位不为零，并且为千位等，输出0
        len--;
    }
    if(str[z] != '0') printf("%c",str[z]);        //如果个位非零，输出（个位0直接不输出）
    if(ispoint){        //如果有小数部分
        printf("D");
        for(int i = x+1; i <= length; i++) printf("%c",str[i]);        //将小数部分输出
    }
}
int main(int argc, char const *argv[]){
    init();
    work();
    return 0;
}
```

---

## 作者：AFOier (赞：1)

这题其实就是纯模拟啊，而且数据挺水，我的代码可能有bug也ac了。建议通过这题的童鞋们再试试P2555，要是能ac就代表你的代码没问题了。反正我觉得这样的题难度应该最多只有普及+/提高吧。。。主要就是判断所有可能的情况就行了。注意：10读作1S，不读S，不用加特判。

我这题把整数部分为三个部分：亿位，万位，个位，然后逐个判断。如果亿位不为空，输出亿位以前的数，并输出‘Y'，然后万位也一样，最后输出个位，就行了。

还有，如果-0的话输出F0，也不用特判。

最后一点是，如果小数部分为.00100，直接输出.00100不用去掉后面的0。

看看我的代码：

```cpp
#include <cstdio>
#include <string>
#include <iostream>
using namespace std;
int w=0,w1,w2;
bool pzs;
string a,zsyl,yw,ww,gw,yw1,ww1,gw1,zs; //解释一下这些变量：a是输入的，zsyl是整数部分而且不去前导0，yw是亿位，ww是万位，gw是个位
int zzs(string p1)
{
    int l,r,tg;
    l=0;r=3;
    l+=(4-p1.size());
    tg=p1.size();
    while(p1[tg-1]=='0'&&tg>=1)
    tg--;//找到第几位就可以跳过
    if(tg<0){cout<<0;return 1;}
    for(int i=l;i<=r;i++)
    {
        int i1=i-(4-p1.size());
        if(i1==tg)return 0;
        if(p1[i1]=='0'&&((i1>l&&p1[i1-1]!='0')||i1==l))
        {cout<<0;continue;}
        if(p1[i1]=='0'&&p1[i1-1]=='0')
        continue;
        cout<<p1[i1];
        if(i==0)cout<<"Q";
        if(i==1)cout<<"B";
        if(i==2)cout<<"S";
    }
    return 0;
```
}//判断四位数的程序，无解释的部分自行理解吧（~~毕竟挺简洁明了的~~）
```cpp
int main()
{
    pzs=true;zs="";xs="";yw="";ww="";gw="";yw1="";ww1="";gw1="";//一堆初始化
    cin>>a;
    if(a[w]=='-')cout<<'F',w++;//如果是负数那么输出F
    if(a[w]=='+')w++;//如果有正号就跳过
    while(w<a.size()&&a[w]!='.')
    zsyl+=a[w],w++;//找整数部分
    if(zsyl=="")cout<<0,pzs=false;//如果没有整数部分，那么按照题目要求，整数部分为0，标记
    else
    {
        w1=0;
        while(w1<zsyl.size()&&zsyl[w1]=='0')
        w1++;
        if(w1==zsyl.size())
        cout<<0,pzs=false;
```
}//如果整数部分全都是0，同上
```cpp
    int j=0;
    while(zsyl[j]=='0'&&j<zsyl.size())j++;
    while(j<zsyl.size())
    zs+=zsyl[j],j++;//去掉整数部分的前导零
    if(pzs==true)//如果有整数部分
    {
        w1=zs.size()-1;
        w2=w1-3;
        while(w1>=0&&w1>=w2)
        gw1+=zs[w1],w1--;
        for(int i=gw1.size()-1;i>=0;i--)
        gw+=gw1[i];
        w2=w1-3;
        while(w1>=0&&w1>=w2)
        ww1+=zs[w1],w1--;
        for(int i=ww1.size()-1;i>=0;i--)
        ww+=ww1[i];
        w2=w1-3;
        while(w1>=0&&w1>=w2)
        yw1+=zs[w1],w1--;
        for(int i=yw1.size()-1;i>=0;i--)
        yw+=yw1[i];//找亿位、万位和个位
        if(yw!="")
        {
            if(zzs(yw)==0)cout<<"Y";
```
}//如果有亿位，输出Y
        if(ww!="")

        {

            if(zzs(ww)==0)cout<<"W";

}//万位同上

        if(gw!="")

        {

            zzs(gw);

}//同上，但是不用输出数位

```cpp
    }
    if(w<(a.size()-1))
    {
        cout<<'D';
        w++;
        while(w<a.size())
        cout<<a[w],w++;
```
}//这是小数部分，直接输出
    return 0;

}

---

## 作者：zrzluck99 (赞：0)

~~一道据说初学OI就能切掉的省选题~~

碰到这种恶心的大模拟，最重要的是要有**结构化思想**，这样容易把各种情况都处理到。

我的思路是在字符串上直接进行处理，分成符号部分、整数部分、小数部分三段，整数部分分别考虑个、十、百、千、万、亿这6种情况。

具体直接上代码看注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ispct(x) (x=='+'||x=='-') /*判断符号位*/
#define isnum(x) (x>='0'&&x<='9') /*判断数位*/
typedef long long ll;

char s[100000];

void P(ll l,ll r){   /*处理符号位*/
    if (l>=r) return;
    for (int i=l;i<r;i++) if (s[i]=='-') {cout << "F"; return;} /*由于合法的数字不会出现两个负号，所以发现负号便直接return*/
}

void G(ll l,ll r){   /*处理个位*/
    if (s[l]!='0') cout << s[l]; /*因为整数部分为0的情况会特判，所以个位为0肯定是不读的*/
}

void S(ll l,ll r){   /*处理十位*/
    if (s[l]=='0'){  /*特判十位为0的情况*/
        if (s[l+1]!='0') {cout << "0"; G(l+1,r);}  /*特判个位为0的情况*/
    }else{
        cout << s[l] << "S"; G(l+1,r);
    }
}

void B(ll l,ll r){   /*处理百位*/
    if (s[l]=='0'){  /*特判百位为0的情况*/
        if (s[l+1]=='0'){  /*特判十位为0的情况*/
            if (s[l+2]!='0') {cout << "0"; G(l+2,r);}  /*特判个位为0的情况*/
        }else{
            cout << "0"; S(l+1,r);
        }
    }else{
        cout << s[l] << "B"; S(l+1,r);
    }
}

void Q(ll l,ll r){   /*处理千位*/
    if (s[l]=='0'){  /*特判千位为0的情况*/
        if (s[l+1]=='0'){  /*特判百位为0的情况*/
            if (s[l+2]=='0'){  /*特判十位为0的情况*/
                if (s[l+3]!='0') {cout << "0"; G(l+3,r);}  /*特判个位为0的情况*/
            }else{
                cout << "0"; S(l+2,r);
            }
        }else{
            cout << "0"; B(l+1,r);
        }
    }else{
        cout << s[l] << "Q"; B(l+1,r);
    }
}

void W(ll l,ll r){   /*处理万位到千万位*/
    if (r-l==8&&s[l]=='0'&&s[l+1]=='0'&&s[l+2]=='0'&&s[l+3]=='0'){ /*特判万位到千万位全是0的情况*/
        if (s[l+4]!='0') cout << "0"; /*千位上有0，代表已经读过了0，万位不需要再读一遍；否则万位需要读0*/
        Q(r-4,r);
    }else{
        switch(r-l){ /*分情况讨论*/
            case 5: G(l,r-4), cout << "W", Q(r-4,r); break;
            case 6: S(l,r-4), cout << "W", Q(r-4,r); break;
            case 7: B(l,r-4), cout << "W", Q(r-4,r); break;
            case 8: Q(l,r-4), cout << "W", Q(r-4,r); break;
        }
    }
}

void Y(ll l,ll r){ /*处理亿位（由于绝对值小于10亿，所以偷个懒）*/
    G(l,r-8); cout << "Y"; W(r-8,r);
}

void Z(ll l,ll r){ /*处理整数部分*/
    while (s[l]=='0'&&l<r) l++; /*去掉前导0*/
    if (l>=r) {cout << "0"; return;} /*特判整数部分为0的情况*/
    switch(r-l){ /*分位数讨论*/
        case 1: G(l,r); break;
        case 2: S(l,r); break;
        case 3: B(l,r); break;
        case 4: Q(l,r); break;
        case 5: W(l,r); break;
        case 6: W(l,r); break;
        case 7: W(l,r); break;
        case 8: W(l,r); break;
        case 9: Y(l,r); break;
    }
}

void R(ll l,ll r){ /*处理小数位*/
    if (l>=r) return; /*只有小数点或者根本没有小数点的情况*/
    cout << "D";
    for (int i=l;i<r;i++) cout << s[i]; /*小数部分直接输出即可*/
}

int main(){ /*主程序*/
    cin >> s; ll n = strlen(s);
    ll t1=0,t2=n;
    while (ispct(s[t1])) t1++; /*找到符号位和整数位的分割点*/
    ll i=0; while (i<n) {if (s[i]=='.') t2=i; i++;} /*找到整数位和小数位的分割点（其实就是小数点）*/
    P(0,t1); Z(t1,t2); R(t2+1,n); /*分三段进行处理*/
}
```

P.S. 代码打下来时长24分钟，一遍过，目前的hack数据都能通过，欢迎来hack。（结构化思想的好处）

---

## 作者：B_Qu1e7 (赞：0)

这题挺简单的

只不过题目有错，应该是绝对值小于等于10亿呀

@icy
```cpp
//大水题 
#include<iostream>
#include<cstdio>
using namespace std;
string s,zs="",xs="";
int fl=0;
int main()
{
    //freopen("read.in","r",stdin);freopen("read.out","w",stdout);
    cin>>s;
    if(s[0]=='-')//处理负号 
    {
        int fll=0;
        for(int i=1;i<s.size();i++)if(s[i]!='0'&&s[i]!='.')fll=1;
        if(!fll)
        {
            cout<<0;return 0;
        }
        s.erase(0,1);
        cout<<'F';
    }
    if(s[0]=='+')s.erase(0,1);//处理正号 
    while(s[0]=='0'&&s[1]!='.'&&s.size()>1)//处理前导0 
    {
        s.erase(0,1);
    }
    for(int i=0;i<s.size();i++)//整数 小数分开 
    {
        if(s[i]=='.'){fl=1;continue;}
        else if(!fl)zs+=s[i];
        else if(fl)xs+=s[i];
    }
    for(int i=zs.size();i;i--)//添加字母 
    {
        if(i==10)zs=zs.substr(0,zs.size()-9)+'S'+zs.substr(zs.size()-9,9);
        if(i==9)zs=zs.substr(0,zs.size()-8)+'Y'+zs.substr(zs.size()-8,8);
        if(i==8&&zs[zs.size()-i]!='0')zs=zs.substr(0,zs.size()-7)+'Q'+zs.substr(zs.size()-7,7);
        if(i==7&&zs[zs.size()-i]!='0')zs=zs.substr(0,zs.size()-6)+'B'+zs.substr(zs.size()-6,6);
        if(i==6&&zs[zs.size()-i]!='0')zs=zs.substr(0,zs.size()-5)+'S'+zs.substr(zs.size()-5,5);
        if(i==5)zs=zs.substr(0,zs.size()-4)+'W'+zs.substr(zs.size()-4,4);
        if(i==4&&zs[zs.size()-i]!='0')zs=zs.substr(0,zs.size()-3)+'Q'+zs.substr(zs.size()-3,3);
        if(i==3&&zs[zs.size()-i]!='0')zs=zs.substr(0,zs.size()-2)+'B'+zs.substr(zs.size()-2,2);
        if(i==2&&zs[zs.size()-i]!='0')zs=zs.substr(0,zs.size()-1)+'S'+zs.substr(zs.size()-1,1);
    }
    for(int i=0;i<zs.size()-1;i++)
    {
        if(zs[i]=='0'&&zs[i+1]=='0')zs.erase(i,1),i--;//去连续0 
    }
    for(int i=1;i<zs.size();i++)
    {
        if((zs[i]=='Y'||zs[i]=='W')&&zs[i-1]=='0')zs.erase(i-1,1);//去亿位、万位前的0
    }
    if(zs[zs.size()-1]=='0'&&zs.size()>1)zs.erase(zs.size()-1,1);//去末尾0 
    cout<<zs;
    for(int i=xs.size()-1;i>=0;i--)//去小数末尾0 
    {
        if(xs[i]=='0')xs.erase(i,1);
        else break;
    }
    if(xs!="")cout<<"D"<<xs;//仍非空（0.0） 
}
```

---

## 作者：doby (赞：0)

照数据上看是没有比较特殊的情况(比如101561.472理应读作SW1Q5B6S1D472)……

那么模拟起来还是比较简单的……

首先找小数点……

然后判全是0的情况……

接着分段模拟就好了……

另外，有一个点数据绝对值很可能大于10^9，要用long long或者string

这里全程string……

```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
string s;
int l,d,st=0,che,rd1=0,fir,dw,out;
char c[9];
int main()
{
    freopen("read.in","r",stdin);
    freopen("read.out","w",stdout);
    cin>>s;
    l=s.size(),che=0,d=l,
    c[1]='S',c[2]='B',c[3]='Q';//十、百、千
    for(int i=0;i<l;i++){if(s[i]=='.'){d=i;}}//找小数点
    for(int i=0;i<l;i++)//找整数部分是不是全是0
    {
        if(s[i]=='-'){che++;}
        if(s[i]=='+'){che++;}
        if(s[i]=='0'){che++;}
        if(s[i]=='.'){break;}
    }
    if(che==d)//整数全是0
    {
        cout<<"0";
        rd1=1;//记录一下，接下来就不用输出了……
    }
    if(!rd1)//
    {
        if(s[0]=='-'){cout<<"F";st=1;}//判负号
        if(s[0]=='+'){st=1;}
        dw=d-st;//找出整数部分位数
        for(int i=st;i<d;i++)
        {
            if(s[i]=='0'/*这是前导0*/&&(fir==0/*这也是前导0*/||out==0/*这是连续的0*/)){dw--;continue;}
            if(dw==9&&s[i]=='0'){cout<<"Y";continue;}//如果是0提前输出亿防止跳过
            if(dw==5&&s[i]=='0'){cout<<"W";continue;}//虽然这种情况可能不存在
            cout<<s[i];
            if(s[i]=='0'){out=0;}//存上一个输出的0判断连续一段的0
            else{out=16513;}
            if((d-i-1)%4&&s[i]!='0'){cout<<c[(d-i-1)%4];}//输出十、百、千
            if(dw==9){cout<<"Y";}//输出万、亿
            if(dw==5){cout<<"W";}
            dw--,fir++;
        }
    }
    if(d!=l)
    {
        cout<<"D";
        for(int i=d+1;i<l;i++)
        {
            cout<<s[i];
        }
    }
    return 0;
}
```

---


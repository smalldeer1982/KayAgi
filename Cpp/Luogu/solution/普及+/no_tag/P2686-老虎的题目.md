# 老虎的题目

## 题目描述

随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：

小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：

- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。
- 题面长度的总和，不能超过 $H$，也不能低于 $L$。
- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）

题目可以在不同比赛中重复使用。


现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）

## 说明/提示

对于 $40\%$ 的数据，$1 \le N \le 100$。

对于 $100\%$ 的数据，$1 \le N \le 1000$，$0 \le a_i,b_i \le {10}^5$，答案不超过 $2^{31}-1$。

## 样例 #1

### 输入

```
6 4 5
1 3 3 2 2 1
2 3 1 4 5 2
```

### 输出

```
21

注：样例中，3场，第一场选1，2两题，第二场选3，4两题，第三场选4，5，6三题。
```

# 题解

## 作者：天泽龟 (赞：15)

### 这题确实可以通过一些微妙的做法，巧妙的将复杂度降低，但是并不具有 **通用性。**


---

做法依然是DP，设$f[i][j]$表示从第i个题目，到第j个题目可达到的最大值。

一个不难想出的式子是：

当$low<=l[j]-l[i-1]<=high$时，$f[i][j]=max(f[x][y] |x<i,y<j)+d[j]-d[i-1]$，其中d[i]是从$1-i$题目难度的前缀和。

所以暴力的做法，我们需要$O(N^4)$的DP转移，得出$f[1][n]$即为答案。

### 显然时间肯定是爆炸的，一个正常的想法就是通过一写数据结构维护DP的最大值，来达到降低复杂度的目的。

---
看到二维区间的求最大值问题，便可以用**二维线段树**实现：

	顾名思义，二维线段树就是在一棵线段树的每一个节点，都保存着另一棵线段树的根节点编号。
    为了实现这两种功能，我们需要建一棵外层线段树(可以动态开点也可以静态开点)，对于外层线段树的每一个节点，我们都保存一个内层线段树的根节点编号(内层线段树必须动态开点，否则MLE)。
    查询时与普通线段树很像，但要在锁定一维后在内层线段树查找另一维，然后才能得出答案。

[以上内容摘录此博客](https://blog.csdn.net/pb122401/article/details/79325126)


对于每次查询，当处于搜索至(i,j)时，查询(1,1)至(i-1,j-1)的区间最大值，并将新的答案插入至(i,j)，可将复杂度将至$O(n^2*log^2(n))$。

然后就可以AC辣！
附上丑陋的代码_(:з」∠)_：
```
#include <iostream>
#define ll long long
using namespace std;
struct ot{
    int ls;
    int rs;
    int rt;
}otr[400000];
struct it{
    int ls;
    int rs;
    ll w;
}intr[500000];
int root;
ll gg,lw,hi,l1,d1,f[2000][2000],le[2000],di[2000],maxx;
ll n,m,cnt1,cnt2,ans,x,y,kk; //cnt-->动态开点个数

ll que_i(int &k,int l,int r,int y)
{
    if (!k) return 0;
    if (y>=r) return intr[k].w; //如果(l,r)在(0,y)区间内
    int mid=(l+r)/2;
    if (y<=mid) return que_i(intr[k].ls,l,mid,y);
    else return max(que_i(intr[k].ls,l,mid,y),que_i(intr[k].rs,mid+1,r,y)); 
}


ll que_o(int &k,int l,int r,int m,int x,int y)
{
    if (!k) return 0; 
    if (x>=r) return que_i(otr[k].rt,1,m,y); //如果(l,r)在(0,x)区间内
    int mid=(l+r)/2;
    if (x<=mid) return que_o(otr[k].ls,l,mid,m,x,y);
    else return max(que_o(otr[k].ls,l,mid,m,x,y),que_o(otr[k].rs,mid+1,r,m,x,y)); 
}

void add_i(int &k,int l,int r,int y,ll v)
{
    if (!k) k=++cnt2;
    intr[k].w=max(intr[k].w,v);
    if (l==r) return;
    int mid=(l+r)/2;
    if (y<=mid) add_i(intr[k].ls,l,mid,y,v);
    else add_i(intr[k].rs,mid+1,r,y,v);
} 

void add_o(int &k,int l,int r,int m,int x,int y,ll v)
{
    if (!k) k=++cnt1;
    add_i(otr[k].rt,1,m,y,v);
    if (l==r) return;
    int mid=(l+r)/2;
    if (x<=mid) add_o(otr[k].ls,l,mid,m,x,y,v);
    else add_o(otr[k].rs,mid+1,r,m,x,y,v);
} 
int main()
{
    cin>>n>>lw>>hi;
    for (int i=1;i<=n;i++) cin>>l1,le[i]+=le[i-1]+l1;
    for (int i=1;i<=n;i++) cin>>d1,di[i]+=di[i-1]+d1;
    for (int j=1;j<=n;j++)
    for (int i=1;i<=j;i++){
        if (le[j]-le[i-1]>=lw&&le[j]-le[i-1]<=hi){
        maxx=que_o(root,1,n,n,i-1,j-1);
		f[i][j]=maxx+di[j]-di[i-1]; add_o(root,1,n,n,i,j,f[i][j]);
        ans=max(ans,f[i][j]);
    }	
    }
    cout<<ans<<endl;
    return 0;
} 

```


---

## 作者：DоsLikе (赞：12)

# P2686老虎的题目
**题目描述&样例输入/输出:[这里](https://www.luogu.com.cn/problem/P2686)**

似乎本题其他dalao的题解都是注重“**怎么做**”，那本蒟蒻就试着写一篇解释“**为什么**”的题解吧

主要思路：dp加上一点前缀和（~~似乎不用也行？~~）

凭着良心说，这题作为一道绿的dp，还是有一点水的。

dp嘛，必然要三步走的：

**1. 定义状态：**

通常来讲我们可能不会一下子就定义对了状态，

但是这题的题目描述太直白了，相当于把怎样定义状态直接告诉了我们。

因为题目要求的是连续的一段（线性），所以我们可以通过只枚举左右两个端点来确定这个区间的大小（长度）。

于是我们把 $dp[i][j]$ 定义为左端点为 $i$ ,右端点为 $j$ 这个区间的难度最大值。

**2.定义状态转移方程**

 _如果是dp，当你找出了状态转移方程之后，你就解决了这个问题的 80%_
 
 								--沃兹基硕德

看题面，首先这道题存在条件的限制，这告诉我们这道题极有可能有两个及以上的转移方程。

我们首先考虑最正常的情况

首先我们来对这种情况做一个限制条件。

题目要求：**题面长度的总和，不能超过high，也不能低于low。**

也就是说，我们要求出我们正在考虑的这段区间内所有题目的长度的总和来和     $low$ 以及 $high$ 作比较。

这就用到我们的前缀和了。提前算好前缀和可以让我们用O(1)的时间复杂度来获取当前区间的长度和，否则就得用O(n)的复杂度来算，估计得T掉（没试，不过差不多）

在长度满足要求的情况下，我们可以推出这种情况的转移方程为

$dp[i][j]=max(dp[i-1][j-1]+brr[j]-[i-1])$

(注意，上式的brr代表着“难度”数组的前缀和)

那么问题来了，如果这个区间不符合题目的要求呢？？

我们可以把整个枚举长度的过程想成“一个单位一个单位的枚举”

这样的话我们在单位时间里，思考的永远是某一个位置的情况，因此可以得出在不符合要求的情况下的状态转移方程式

$dp[i][j]=max(dp[i-1][j],dp[i][j-1])$

**3.初始状态定义**

本题的初始状态为 $dp[i][j]=0$ （~~这没啥好说的~~）


------------


剩下的一点小细节，在注释里会提到

```cpp
#include <iostream>
#include <cstdio>
#define maxn 1005
#define ll long long//要开long long 不然会WA掉#3 
using namespace std;
ll arr[maxn];//长度 
ll brr[maxn];//难度 
ll dp[maxn][maxn];
ll n,low,high;//变量名称与题目一致 
int main(){
	cin>>n>>low>>high;
	int tmp;
	for(int i=1;i<=n;i++)cin>>tmp,arr[i]=arr[i-1]+tmp;
	for(int i=1;i<=n;i++)cin>>tmp,brr[i]=brr[i-1]+tmp;//输入的同时顺手把前缀和给处理了 
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			dp[i][j]=max(dp[i-1][j],dp[i][j-1]);//这里，首先要假设枚举到的位置不成立 (不过关于为什么这一点要在前，我本人只是明白但不会解释，希望有dalao能解释一下QWQ)
			if((arr[j]-arr[i-1])>=low&&(arr[j]-arr[i-1])<=high)dp[i][j]=max(dp[i][j],dp[i-1][j-1]+brr[j]-brr[i-1]);//如果符合要求的情况 
		}
	}
	cout<<dp[n][n];//输出即可 
	return 0;
}
```

总结：代码难度是真的不高，但是确实有几个细节不大好想，一不小心又码了那么多字，有问题请轻喷QAQ

 													

---

## 作者：彭骐飞 (赞：10)

# 显然

此题为DP


f[i][j]为使所有题目的左端点<=i以及右端点<=j的难度最大值

s1[i]为题面长度的前缀和

s2[i]为难度的前缀和

动态转移方程:f[i[j=max{f[i-1][j],f[i][j-1],f[i-1][j-1]+s1[j]-s[i-1]}

|
符合low<=s1[j]-s1[i-1]<=high

不说多了，上代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,l,r,x,f[1001][1001],s1[1001],s2[1001];
int main()
{
    cin>>n>>l>>r;
    for (int i=1;i<=n;i++)
    {
        cin>>x;
        s1[i]=s1[i-1]+x;
    }
    for (int i=1;i<=n;i++)
    {
        cin>>x;
        s2[i]=s2[i-1]+x;
    }
    for (int i=1;i<=n;i++)
        for (int j=i;j<=n;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if (s1[j]-s1[i-1]>=l && s1[j]-s1[i-1]<=r) f[i][j]=max(f[i][j],f[i-1][j-1]+s2[j]-s2[i-1]);
        }
    cout<<f[n][n];
while (true)
cout<<endl;
    return 0;
}
```

---

## 作者：XL4453 (赞：2)

### 解题思路：

首先可以先求出难度和长度的前缀和用于计算之后的区间和。

从小到大枚举 $l,r$，发现对于某一个长度满足条件的区间 $[l,r]$ 它限制了与它同时被选择的区间满足 $l'<l$ 且 $r'<r$。

那么不妨设 $f_{i,j}$ 表示所有的左端点不超过 $i$，所有的右端点不超过 $j$ 的区间所能达到的最大难度。

转移时先考虑平凡转移 $f_{i-1,j}$ 和 $f_{i,j-1}$，然后考虑对于满足长度要求的区间 $i,j$ 有 $f_{i-1,j-1}+v(i,j)$，其中 $v(i,j)$ 表示区间 $[i,j]$ 的难度贡献。

最终答案是 $f_{n,n}$，总复杂度 $O(n^2)$。

---
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
const int MAXN=1005;
int n,low,high,d[MAXN],l[MAXN],f[MAXN][MAXN];
signed main(){
	scanf("%lld%lld%lld",&n,&low,&high);
	for(int i=1;i<=n;i++){
		scanf("%lld",&l[i]);
		l[i]+=l[i-1];
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&d[i]);
		d[i]+=d[i-1];
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(l[j]-l[i-1]<=high&&l[j]-l[i-1]>=low)
			f[i][j]=max(f[i][j],f[i-1][j-1]+d[j]-d[i-1]);
		}
	}
	printf("%lld\n",f[n][n]);
	return 0;
}
```


---

## 作者：Sunyuheng2114514 (赞：1)

## 这道题势必是 DP 呀！



我在此处定义的 $dp_{i,j}$ 表示的是题目编号（也就是左端点）$\le i$，右端点 $\le j$ 中所有情况的最优解。

再定义一个 $len_i$ 表示从 $1$ 到 $i$ 所有题面长度之和（加上前缀和数组方便计算比赛所出题目的长度和难度），$lever_i$ 表示从 $1$ 到 $i$ 所有题难度之和。

我们观察后不难发现：如果题面长度符合规范的话共有两种选择，加入这套题或不加入这套题。加入这套题时，$dp_{i,j}$ 就为不选择这套题时的最优解加这套题的难度和；不加入时则为缩小 $i$ 或 $j$ 范围 $1$ 单位时的最优解（题面长度不符合规范的话则为后者）。

不断扩大 $i$ 和 $j$ 的值来更新 $dp$ 数组。

## AC code


```cpp
#include<iostream>
#define N 1001

using namespace std;
long long n,l,h,tmp,len[N],lever[N],dp[N][N]; 
int main(){
	scanf("%lld%lld%lld",&n,&l,&h);
	for(int i=1;i<=n;i++){
		scanf("%lld",&tmp);
		len[i]=len[i-1]+tmp;
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&tmp);
		lever[i]=lever[i-1]+tmp;
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
			if ((len[j]-len[i-1])<=h&&(len[j]-len[i-1])>=l)
				dp[i][j]=max(dp[i][j],dp[i-1][j-1]+lever[j]-lever[i-1]);
		}
	}
	cout<<dp[n][n];//这种情况范围最大
	return 0;
}
```

---

## 作者：XiXi (赞：1)

这题典型dp

设f[i][j]为左边界不超过i，右边界不超过j的情况下的最优值

那么f[i][j]=max{f[i-1][j],f[i][j-1],f[i-1][j-1]+s[i][j]}

这个可以画图推，特别声明一下，s[i][j]为第i个难度到第j个难度之和

——————————————分割线——————————————

这里可能有人要问，题目长度不符合规则怎么办

只有在符合规则时，我们才能有第三项的选择

就是说，如果长度不符合规则，那么f[i][j]=max{f[i-1][j],f[i][j-1]}

——————————————分割线——————————————

因为题目说了不能有包含和被包含关系，所以只有最后才加s[i][j]

来代码吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n,l,r,i,j,k,a[1111],b[1111],f[1111][1111];
    cin>>n>>l>>r;
    a[0]=0;
    for (i=1;i<=n;i++) cin>>k,a[i]=a[i-1]+k;
    b[0]=0;
    for (i=1;i<=n;i++) cin>>k,b[i]=b[i-1]+k; //前缀和
    memset(f,0,sizeof(f));
    for (i=1;i<=n;i++)
    for (j=i;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j-1]);
        if ((a[j]-a[i-1])>=l&&(a[j]-a[i-1])<=r)    f[i][j]=max(f[i][j],f[i-1][j-1]+b[j]-b[i-1]);
    }
    cout<<f[n][n];
}
```

---

## 作者：cosf (赞：0)

## [P2686](https://www.luogu.com.cn/problem/P2686)

前缀和优化 dp。

我们令 $dp_{i, j}$ 表示最后一个比赛的开始是 $i$，结尾是 $j$ 的最大难度。

那么，有 $dp_{i, j} = (\sum_{k=i}^jv_k) + \max_{i' = 1}^{i - 1}\max_{j' = i' + 1}^{j - 1}dp_{i', j'}$，其中 $v_i$ 表示题目 $i$ 的难度。

两个 $\max$，容易想到用前缀和（前缀 $\max$）优化。

事实上，我们可以将 $\max_{i' = 1}^{i - 1}\max_{j' = i' + 1}^{j - 1}dp_{i', j'}$ 这个整体压缩成 $dp_{i - 1, j - 1}$。压缩之后的转移方程如下：

$$
dp_{i, j} = \max\{dp_{i - 1, j - 1} + (\sum_{k=i}^jv_k), dp_{i - 1, j}, dp_{i, j - 1}\}
$$

可以看到，除了 $dp_{i - 1, j - 1} + (\sum_{k=i}^jv_k)$，其他的两项都是为了转移前缀 $\max$ 而存在的。

最后的答案就是所有 $dp$ 值的 $\max$，时间复杂度 $O(n^2)$。

只要你对前缀 $\max$ 比较熟悉，理解起来就很简单了。

前缀 $\max$ 比前缀和要简单一些，毕竟你对相同的几个数取 $\max$ 是他们本身，而把它们相加显然不会得到相同的结果。

## 代码

```cpp
#include <iostream>
#include <cassert>
using namespace std;

#define MAXN 1005

using ll = long long;

int n;
ll l, h;

ll len[MAXN];
ll val[MAXN];
ll dp[MAXN][MAXN];

int main()
{
    cin >> n >> l >> h;
    for (int i = 1; i <= n; i++)
    {
        cin >> len[i];
    }
    for (int i = 1; i <= n; i++)
    {
        cin >> val[i];
    }
    ll res = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = i; j <= n; j++)
        {
            dp[i][j] = dp[i - 1][j];
        }
        ll s = 0, v = 0;
        for (int j = i; j <= n; j++)
        {
            s += len[j];
            v += val[j];
            if (s >= l && s <= h)
            {
                res = max(res, dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + v));
            }
        }
        for (int j = i; j <= n; j++)
        {
            dp[i][j] = max(dp[i][j], dp[i][j - 1]);
        }
    }
    cout << res << endl;
    return 0;
}

```


---

## 作者：Mioko_Sakurauchi (赞：0)

题目就不再描述一遍了，这道一眼动态规划题甚至都直接给你怎么转移了，这道题总体来说就是动态规划+前缀和维护。$f[i][j]$ 为转移方程。

如果长度不符合规则，那么 $f[i][j]=\max{f[i-1][j],f[i][j-1]}$，符合则再判断一次加上后的。

还有哪里不明白，请看代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
const int maxn=1e3+10;
ll n,higt,low,lens[maxn],values[maxn],f[maxn][maxn];
int main()
{

	cin>>n>>low>>higt; //与题意相同
	for(int i=1;i<=n;i++)
	{
		int len;
		cin>>len;
		lens[i]=lens[i-1]+len; //输入的同时维护前缀和
	}
	for(int i=1;i<=n;i++)
	{
		int value;
		cin>>value;
		values[i]=values[i-1]+value; //输入的同时维护前缀和
	}
	memset(f,0,sizeof (f));
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			f[i][j]=max(f[i-1][j],f[i][j-1]); //状态转移
			if((lens[j]-lens[i-1]) >= low and (lens[j]-lens[i-1] <= higt)) f[i][j]=max(f[i][j],f[i-1][j-1]+values[j]-values[i-1]); //如果符合题意就进行进一步的状态转移（加上题目value)
			
		}
	}
	cout<<f[n][n]; //输出结果
	return 0;
}
```


---

## 作者：物灵 (赞：0)

说下这个转移方程如何得到。

因为选取区间可以交叉但不能包含，可知各选取区间若以左端点排序，则右端点严格递增。且左右端点均不重复。

故枚举左端点，则到现在左端点时，可从之前左端点状态加上新一段。由于需要使之前「每个」左端点均单调，故状态定义用小于等于。

得
$$
s_{i,j}=
\max\{s_{i-1,j},s_{i,j-1},[L\le cost_{i,j}\le R]value_{l,r}\}
$$


---

## 作者：zhangyunpenga (赞：0)

这题难度适中，只不过思维复杂度高，要多加思索//禁止超题解！！

```cpp
#include<iostream>
using namespace std;
int n,l,r;//l左边，r右边
long long f[1001][1001];
int a[1001],s[1001];
int main()
{
    cin>>n>>l>>r;
    int y;
    for(int i=1;i<=n;i++)cin>>y,a[i]=a[i-1]+y;
    for(int i=1;i<=n;i++)cin>>y,s[i]=s[i-1]+y;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j-1]);
        if(a[j]-a[i-1]>=l&&a[j]-a[i-1]<=r)f[i][j]=max(f[i][j],f[i-1][j-1]+s[j]-s[i-1]);//重点！！ 动态转移方程！！
    }
    cout<<f[n][n];//输出
    return 0;
}
```

---


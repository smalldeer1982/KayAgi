# [AHOI2016初中组] 游戏

## 题目描述

小雪与小可可正在玩一种数字游戏。他们准备了 $n$ 张卡片，每一张卡片上都有一个整数。游戏开始后，小雪会先选择一个不小于 $a$ 且不大于 $b$ 的整数 $t$，并告诉小可可这个数字 $t$ 是多少。之后小可可会挑出恰好 $k$ 张卡片，并将这 $k$ 张卡片上的数字相加，得到的和数记为 $m$。

小雪希望 $t$ 和 $m$ 差的绝对值尽可能大，而小可可却希望 $t$ 和 $m$ 差的绝对值尽可能小。在游戏开始前，他们二人都知道 $n$， $a$， $b$ 和 $k$ 是多少，也知道每一张卡片上的数字是多少。在小雪决定了 $t$ 的大小后，不能再修改，之后才由小可可挑选纸牌。

小雪希望知道，在二人都尝试最优策略的情况下， $t$ 和 $m$ 差的绝对值最大可以有多大？

## 说明/提示

对于 30% 的数据， $1\le k\le n\le 20$ 且 $0\le a\le b\le   6000$。

对于 80% 的数据， $1\le k\le n\le 65$ 且 $0\le a\le b\le   19650$。

对于 100% 的数据， $1\le k\le n\le 250$ 且 $0\le a\le b\le 75000$。


## 样例 #1

### 输入

```
4 2 58 100
10 10 50 80```

### 输出

```
15```

## 样例 #2

### 输入

```
8 3 1300 1800
2 0 1 9 1 4 0 5```

### 输出

```
1782```

# 题解

## 作者：浮尘ii (赞：4)

##官方题解

为了找出t和m的最大差，我们需要先找出所有可能的m，也就是要算出来有哪些数字可以通过在n个数字中挑选k个来得到。这一个简化版的01背包问题，记F[i][j][x]表示前i个数字中选出j个来，是否可以组成数字x。这样做时间复杂度是O(nkMAXB)的，可以通过85%的数据。

又可以发现F[i][j][x]全都是boolean型的，考虑把多个F[i][j][x]在最后一维进行压缩，例如我们可以用一个64位整数来表示64个boolean值。01背包的所有转移都可以用位运算来实现。这便可以通过100%的数据。


##std
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <cmath>
using namespace std ;

const int R = 60 ;
const int MAXN = 609 ;
const int MAXB = 180009 ;
const int __MAXK = 13 ;

int n , k , a , b , x[MAXN] , k0 , sumx[MAXN] ;
long long F[MAXB][__MAXK] ;

void Init() {
freopen("game.in","r",stdin);
freopen("game.out","w",stdout);
    cin >> n >> k >> a >> b ;
    for ( int i = 1 ; i <= n ; i ++ ) cin >> x[i] ;
    sumx[0] = 0 ;
    for ( int i = 1 ; i <= n ; i ++ ) sumx[i] = sumx[i-1] + x[i] ;
}

void Solve() {
    k0 = (k+1) / R ;
    if ( R * k0 < k+1 ) k0 ++ ;
    for ( int j = 0 ; j <= b ; j ++ )
        for ( int k = 0 ; k < k0 ; k ++ )
            F[j][k] = 0 ;
    F[0][0] = 1 ;
    for ( int i = 1 ; i <= n ; i ++ )
        for ( int j = sumx[i] ; j >= 0 ; j -- )
            for ( int k = 0 ; k < k0 ; k ++ ) {
                if ( k + 1 < k0 ) F[j+x[i]][k+1] |= (F[j][k] >> (R-1)) ;
                F[j+x[i]][k] |= (F[j][k] << 1) ;
            }
    vector<int> ans ; ans.clear() ;
    for ( int j = 0 ; j <= b ; j ++ )
        if ( ((F[j][k0-1] >> (k+1 - R*(k0-1) - 1)) & 1) == 1 )
            ans.push_back(j) ;
    int ret = 0 ;
    int near2a = abs(ans[0] - a) , near2b = abs(ans[0] - b) ;
    for ( int i = 1 ; i < ans.size() ; i ++ ) {
        if ( abs(ans[i] - a) < near2a ) near2a = abs(ans[i] - a) ;
        if ( abs(ans[i] - b) < near2b ) near2b = abs(ans[i] - b) ;
        int rr = (ans[i] - ans[i-1]) / 2 ;
        if ( ( a <= ans[i-1] + rr && ans[i-1] + rr <= b ) || ( a <= ans[i] - rr && ans[i] - rr <= b ) ) {
            if ( rr > ret ) ret = rr ;
        }
    }
    if ( near2a > ret ) ret = near2a ;
    if ( near2b > ret ) ret = near2b ;
    cout << ret << "\n" ;
    fprintf(stderr,"%d\n" , ret) ;
}

int main() {
    Init() ;
    Solve() ;
}
```

##C++福利

如果有个75000位的二进制数类型多好啊。

诶，STL好像有个bitset。

嗯，好像可以直接用……


##稍微跑得比std慢的AC程序

```cpp
#include <iostream>
#include <cstdio>
#include <bitset>

using namespace std;

const size_t    MaxN(251), MaxSum(75001);
const int        INF(0x7f7f7f7f);

int                    N, K, A, B;
int                    Xi, Sum;
bitset<MaxSum>        F[MaxN];
int                    L[MaxSum], R[MaxSum];
int                    Ans(-INF);

int main()
{
    freopen("game.in", "r", stdin);
    freopen("game.out", "w", stdout);

    cin >> N >> K >> A >> B;
    F[0].set(0);
    for(int i(1); i <= N; i++) {
        scanf("%d", &Xi);
        for(int j(K); j; j--)
            F[j] |= F[j - 1] << Xi;
        Sum += Xi;
    }

    L[A] = -INF;
    for(int i(A); ~i; i--)
        if(F[K][i]) {
            L[A] = i;
            break;
        }
    for(int i(A + 1); i <= B; i++)
        L[i] = F[K][i] ? i : L[i - 1];
    R[B] = INF;
    for(int i(B); i <= Sum; i++)
        if(F[K][i]) {
            R[B] = i;
            break;
        }
    for(int i(B - 1); i >= A; i--)
        R[i] = F[K][i] ? i : R[i + 1];

    for(int i(A); i <= B; i++)
        Ans = max(Ans, min(i - L[i], R[i] - i));

    cout << Ans << endl;

    return 0;
}
```

---

## 作者：ydkxj (赞：4)

# [AHOI2016初中组] 游戏

## 题目描述

主要是让 $t$ 和 $m$ 差的绝对值尽可能大，在二人都尝试**最优策略**的情况下，$t$ 和 $m$ 差的绝对值最大可以有多大？

## 解法

### 暴力解法

用贪心解决，本来会爆炸的但鉴于这题数据很水，也可以过。

#### 代码
 ```cpp
#include<iostream>
#include<algorithm>
using namespace std;
bool cmp(int a,int b){
	return a<b;
}
int cty[305],n,k,a,b;
int main(){
    cin>>n>>k>>a>>b;
    for(int i=1;i<=n;i++)
    cin>>cty[i];
    sort(cty+1,cty+1+n,cmp);
    for(int i=n;i+k>n;i--) 
	b-=cty[i];
    cout<<b;
    return 0;
}
```
### 动态规划解法

这就是一个 DP 题，令二维数组 $f$ 表示数值并累加即可。我们可以定义状态 $f[i][j]$ 表示在前 $i$ 张卡片中选择 $j$ 张卡片，使得这些卡片的数字和与 $t$ 的差的绝对值最大是多少。则原问题的答案就是 $f[n][k]$。

## 正解
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<map>
#define int long long
using namespace std;
int a[1000];
int f[75100][260];
int b[100000];
int n,m,x,y,csz=0,ypy=0,yjy=0,cty;
inline bool cmp(int a,int b)
{
    return a>b;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
    cin>>n>>m>>x>>y;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=m;i++)
    {
        csz+=a[i];
    }
    for(int i=0;i<=csz;i++)
    for(int j=0;j<=m;j++)
    f[i][j]=-1e9;
    f[0][0]=0;
    for(int i=1;i<=n;i++)
    {
        for(int k=csz;k>=a[i];k--)
        {
            for(int j=1;j<=m;j++)
            f[k][j]=max(f[k][j],f[k-a[i]][j-1]+a[i]);
        }
    }
    for(int i=1;i<=csz;i++)
    if(f[i]>0)
    {
        b[++ypy]=f[i][m];
    } 
    for(int i=x;i<=y;i++)
    {
    	cty=1e9;
        for(int j=1;j<=ypy;j++)
        {
            if(abs(b[j]-i)<cty)
            {
                cty=abs(b[j]-i);
            }
        }
        if(cty>yjy)yjy=cty;
    }
    cout<<yjy;
}
```
求过！

---

## 作者：Epitome (赞：1)

## 闲话

WXH 是世界上最美的女孩子！

## 题意

$n$ 个数中选 $k$ 个，设能拼出的和 $ \in [a, b]$ 中的集合为 $s$，求 $x$ 使得 $\min\limits_{v \in s} \lvert x - v \rvert$ 最大。

## 解法

首先普通的动态规划是十分简单的，但是似乎并没有优化空间？

其实我们会观察到这个 dp 是一个可行性 dp，可以想到使用 `bitset` 来优化这个 dp，然后时间变成 $O(\frac{nkV}{w})$，空间一致，但是我们可以更进一步的使用滚动数组优化，空间即可降为 $O(\frac{kV}{w})$，其中的 $V$ 表示值域范围也就是 $75000$。

## 代码

对着题解口胡谁都会，请展示你的代码。

```cpp
// 39 X 03

#include <bits/stdc++.h>

using namespace std;

const int N = 305;

int n, k, a, b, ans, arr[N], suf[N * N], pre[N * N];

bitset< N * N > f[2][N];

int main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n >> k >> a >> b;
  for (int i = 1; i <= n; cin >> arr[i++]) {
  }
  f[0][0][0] = f[1][0][0] = 1;
  for (int i = 1; i <= n; ++i) {
    for (int j = 1; j <= k; ++j) {
      f[i & 1][j] |= f[1 ^ (i & 1)][j];
      f[i & 1][j] |= f[1 ^ (i & 1)][j - 1] << arr[i];
    }
  }
  suf[75001] = 'w' + 'x' + 'h' + 520520;
  for (int i = 1, j = 75000; i <= 75000; ++i, --j) {
    pre[i] = (f[n & 1][k][i] ? i : pre[i - 1]);
    suf[j] = (f[n & 1][k][j] ? j : suf[j + 1]);
  }
  for (int i = a; i <= b; ++i) {
    ans = max (ans, min (i - pre[i], suf[i] - i));
  }
  return cout << ans, 0;
}

```

---

## 作者：qhr2023 (赞：1)

## soltion

考虑动态规划。设 $f_{i, j}$ 表示 取 $i$ 个数和能否等于 $j$，类似背包的思想很容易得到转移，初始化 $f_{0, 0} = 1$，我们记这 $n$ 个数的和为 $s$，从 $1$ 到 $s$ 枚举 $l$，则 $f_{i, j}=f_{i-1, j-x_l}$。

```cpp
for (int i=1; i<=n; ++i) 
		for (int j=k; j; --j)
			for (int l=s; l>=x[i]; --l)
				f[j][l]|=f[j-1][l-x[i]];
```

算出所有能取出的数存在数组 $g$，枚举 $t$，对于当前 $t$ 枚举 $g$ 求最小的差绝对值，再记录最小的最大值。

```cpp
for (int i=a, mi; i<=b; ++i) {
		mi=1e9;
		for (int j=1; j<=g[0]; ++j)
			mi=min(mi, abs(g[j]-i));
		ans=max(ans, mi);
}
```

计算量可以达到 $4 \times 10^9$，虽然常数小，但不足以通过，考虑状压优化。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, a, b, x[255], s, ans, g[75005];
bitset<75005> f[255];
int main () {
	cin >> n >> k >> a >> b;
	for (int i=1; i<=n; ++i)
		cin >> x[i],
		s+=x[i];
	f[0][0]=1;
	for (int i=1; i<=n; ++i) 
		for (int j=k; j; --j) 
			f[j]|=f[j-1]<<x[i];
	for (int i=1; i<=s; ++i) 
		if (f[k][i])
			g[++g[0]]=i;
	for (int i=a, mi; i<=b; ++i) {
		mi=1e9;
		for (int j=1; j<=g[0]; ++j)
			mi=min(mi, abs(g[j]-i));
		ans=max(ans, mi);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：bluewindde (赞：1)

小雪的最优策略是选择一个 $t$，其在小可可能选出的所有值的序列 $\{m\}$ 中的前驱 $u$ 和后继 $v$，最大化 $\min\{u - t|, |v - t|\}$。（此处定义 $x$ 的前驱为不严格小于 $x$ 的数中最大的那个，$x$ 的后继为不严格大于 $x$ 的数中最大的那个）

只需用背包求出上述序列 $\{m\}$，然后枚举每个可能的值 $t$，二分其前驱和后继取最大值即可。

接下来介绍如何用背包求出 $\{m\}$。设 $dp_{i,kk,j}$ 表示已经处理完前 $i$ 个数，已经取了 $kk$ 个数，它们的和为 $j$ 这种情况是否可达。初始化 $dp_{0, 0, 0} = \text{true}$。容易得到转移式 $dp_{i, kk, j} = dp_{i - 1, kk - 1, j - x_i}$。用滚动数组压掉 $i$ 这一维。序列 $\{m\}$ 即为所有使得 $dp_{kk, i}$ 为 $\text{true}$ 的数 $i$。

但是这样背包得时间复杂度上界是 $O(nkb)$，无法通过此题，可以考虑用 `bitset` 压位，时间复杂度上界优化到 $O(\dfrac{nkb}{w})$，跑得飞快。

[code.](https://www.luogu.com.cn/paste/6slulb6j)

---

## 作者：lhz2022 (赞：0)

考虑dp。设 $dp_{i,j,k}$ 为使用前 $i$ 个数，选择其中的 $j$ 个数，是否可以拼凑出 $k$

转移为：$dp_{i,j,k}=dp_{i-1,j-1,k-x_i}$

注意到第一维可以滚动数组优化掉。考虑到 $dp$ 的数组的取值总是为 $0$ 或 $1$ ，我们可以想到bitset压位。

转移 $dp_{j,k}=dp_{j-1,k-x_i}$ 。

初始： $dp_{0,0}=1$ 。

易得如果 $dp_{k,i} = 1$ ,那么 $i$ 就可以通过 $x$ 中恰好选择 $k$ 个相加得到。

可以把所有可能的结果存入另一个数组 $g$ 。

所得的最小值最大可以通关枚举 $[a,b]$ 中所有的整数，并和 $g$ 中的所有元素相减求绝对值的所有结果的最小值求最大值，所得的最大值就是答案

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define debug() puts("I WILL AK")
#define N 100007
#define M 300
bitset<N> dp[M];
int x[M],n,k,a,b,g[N],ct,sm,ans;
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>k>>a>>b;
	for(int i=1;i<=n;++i){
		cin>>x[i];
		sm+=x[i];
	}
	dp[0][0]=1;
	for(int i=1;i<=n;++i){
		for(int j=k;j;--j){
			dp[j]|=(dp[j-1]<<x[i]);
		}
	}
	for(int i=1;i<=sm;++i){
		if(dp[k][i]){
			g[++ct]=i;
		}
	}
	//cout<<sm<<'\n';
	for(int i=a;i<=b;++i){
		int mn=2e9;
		for(int j=1;j<=ct;++j){
			mn=min(mn,abs(g[j]-i));
		}
		ans=max(ans,mn);
	}
	cout<<ans;
	return 0;
}
```

---


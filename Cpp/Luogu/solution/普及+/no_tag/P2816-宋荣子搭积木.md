# 宋荣子搭积木

## 题目描述

saruka 非常喜欢搭积木，他一共有 $n$ 块积木。而且 saruka 的积木很特殊，只能一块块的竖着摞，可以摞很多列。说过 saruka 的是特殊的积木了，这些积木都非常智能，第 $i$ 块积木有一个情绪值 $x_i$ ，当摞在这块积木上的积木总数超过 $x_i$ 时，这块积木就会很不高兴，发誓以后不会再和 saruka 一起玩耍了。saruka 这么爱玩积木，肯定不会让积木不高兴的，但是 saruka 又希望每块积木都被用上，并且摞的积木列数最少。你能来帮帮 saruka 吗?

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 5000$，$0 \le x_i \le n$。

## 样例 #1

### 输入

```
3
0 0 3
```

### 输出

```
2```

## 样例 #2

### 输入

```
4
0 0 0 0
```

### 输出

```
4```

# 题解

## 作者：gyfer (赞：16)

**这题竟然是普及＋**

先考虑这样一个问题，你现在有若干列盒子。现在有一个新的盒子，你只能挑一列，把新盒子放到最底下。为了后续策略最优，你应该怎么放？

显然是应该找（能放的）个数最多的那个放

因为这样放，对于后续的操作来说才是最优的。

比如原来是2，3，5，再放肯定要放在5的底下，变成2，3，6。对于后续的决策来说，2，3，6肯定比3，3，5或者2，4，5优。

所以我们就有了一种贪心的方法。先将所有的盒子按照承载量从小到大排序。

然后我们开一个数组，记录一下当前一共有多少列，每一列一共有多少个盒子。从小到大扫描所有的盒子，找到能放下的数量最多的列，放进去。如果没有任何一列能放下，则建一个新列。

如目前：2，4，6。新来了一个承载量5的盒子，就应该放在『4』那一列。

举例：0，1，1，2，2，3

这是纯模拟题啊，代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstring>
using namespace std;
int n,m,a[5001],i,j,lie[5001];//a存状态，lie模拟摆放
int main(){
  cin>>n;
  for(int i=1;i<=n;i++) cin>>a[i];
  sort(a+1,a+n+1);
  m=1;
  lie[m]=1;
  for(int i=2;i<=n;i++){
        bool fool=true;
    for(int j=1;j<=m;j++) if(lie[j]<=a[i]){
        lie[j]++;
        fool=false;
        break;
    }
    if(fool) m++,lie[m]=1;
  }
  cout<<m<<endl;
}
```

---

## 作者：Merak (赞：8)

Ps.
昨天写题解的时候发明了一种格式233以后的题解就都是这个形式了。

居然没有人写题解啊~既然今天考试题是这个那就写一下思路吧（前后没有任何联系的一句话2333）。

————————————————————————————

**题目要求**

每块积木都被用上，并且积木列数最少。

**思路分析**

很容易想到贪心的解法。但既然是道绿题（绿题怎么了！绿题招你惹你啦！），那么肯定不会是排个序取最大值能解决的。

开始的时候我是认为只要从下往上累加的时候放最大的就好了，但是对于这样一组样例：

-7
-4 3 2 2 1 0 0

如果一直取最大值，那么得到的ans是3：

-4 3 2 2 1

-0
-0
但很显然正解是2：

-4 3 2 1 0

-2 0
所以我们需要稍微的思考一下，如何对这个贪心方案进行优化？

首先，将x[]数组按从大到小的顺序sort一遍，然后使用一个vis[]数组来记录积木的使用情况（因为只能使用一次），记使用过为1，未使用过为0。从头开始枚举，定义一个计数器temp，如果还有能够塞到底部的积木就加1，直到不能再放，然后重新枚举，同时ans++，计数器temp清零即可。

代码如下：（不要直接复制了交，有坑233）

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int n,temp=0,ans;
//temp用来记录第i个积木前累积的积木个数，ans记录列数 
int x[5003],vis[5003]={0};
//用vis[]来对已经使用过的积木进行标记 
int main()
{
    freopen("box.in","r",stdin);
    freopen("box.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x[i]);
    }
    sort(x+1,x+n+1);//将x[i]从小到大进行排序 
    for(int i=1;i<=n;i++)
    //从上往下枚举 
    {
        if(!vis[i])//未被标记
        {
            vis[i]=1;//使用，将其标记 
            ans++;//开始形成新的一列 
            temp=0;//计数器清零 （也可以让temp=1,这时下面的特判要改成temp<=x[j]）
            for(int j=i+1;j<=n;j++)//从i开始往后枚举 
            {
                if(!vis[j]&&temp+1<=x[j])
                //如果未被使用并且将它放入这列积木底部不会使其不高兴 
                {
                    vis[j]=1;//使用 
                    temp++;//计数器加一 
                }
            }
        }
    }
    cout<<ans<<endl;
    fclose(stdin);
    fclose(stdout);
    return 0;
}
···

---

## 作者：KesdiaelKen (赞：6)

所有人都是用$O(n^2)$或以上做的吗……

这里给一种$O(n\log n)$的做法。

考虑二分答案（这个不用多说了吧）。当列的数量确定时，我们考虑如何摆放尽量能让所有积木放下。

显然，$x_i$大的积木应该放在$x_i$小的积木下面（这样，一列剩余的空间就可以直接取此时最上面的木块的$x_i$）。对于$x_i$相同的木块，我们发现越多相同$x_i$的木块堆放在一起就越浪费这一列的剩余空间（因为最底下的那块$x_i$的剩余空间被同类积木块消耗，导致之后在这列之上放木块时剩余空间可能取决于这一木块，而不是最上端的木块）。

因此，我们可以考虑一种贪心的放法，将木块以$x_i$为关键字从大到小排序后，从第一列开始依次按顺序放下木块直到放完最后一列后，又回到第一列，继续这样往后放到最后一列，以此类推。同时用数组$zx$记录某一列剩余的空间，初始值设$inf$，当有一木块要在此列顶端放下时则更新$zx$（$zx=min(zx-1,x_i)$）。最后扫一遍数组判断是否有$zx<0$，如果有则现在的列数不可行，否则就可行。

代码如下：

```
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<iostream>
using namespace std;
int n;int shu[6000]={0};
bool cmp(const int&a,const int&b){return a>b;}
int zx[6000];
bool ky(int ls)
{
	for(int i=0;i<ls;i++)zx[i]=2e9;
	for(int i=0;i<n;i++)zx[i%ls]=min(zx[i%ls]-1,shu[i]);
	for(int i=0;i<n;i++)if(zx[i]<0)return false;
	return true;
}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)scanf("%d",&shu[i]);
	sort(shu,shu+n,cmp);
	int zuo=1,you=n,mid;
	while(zuo!=you)
	{
		mid=(zuo+you)>>1;
		if(ky(mid))you=mid;
		else zuo=mid+1;
	}
	printf("%d\n",zuo);
	return 0;
} 
```


---

## 作者：Rexdisn (赞：5)


蒟蒻的第一篇题解qwq

------------

## 做法：二分答案

第一眼看到题就觉得是用二分做，经提交证明这是非常可行的。

已知共有n块积木，所以答案最大值为n，即每块积木单独一列。

同样，答案最小值为1，即所有积木摞在同一列上。

所以可以考虑**二分积木列数**的做法。


此时需要考虑一个问题：如何保证自己二分取到了最优解？

这里用了贪心的思想：

情绪值越大的积木位置应该越靠下，保证它的上面能摞更多的积木。举个栗子：
```
4
1 2 3 4
```
那么我们可以这样做：

假设我们现在摞两列，就可以这样放：
```
//先用最大的两个数铺满最底层

4  3

//再按从大到小的顺序往第二层摞次大的，即

2  1
4  3

```

所以可以得知贪心策略为从大到小摞完一排后再往上从大到小摞一排。

这时我们发现摞两列是可行的，所以再往下寻找摞更少的列数是否可行。

```
//摞一列

1
2
3
4
```

以上为思路。

#### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

int n;
int l,r,mid;

int a[8001]={0};   //存放Xi值
int b[8001]={0};   //存放柱子上每个积木的Xi

inline int read()   //快读
{
	int x=0,y=1;	char c;	c=getchar();
	while(c<'0' || c>'9')	{	if(c=='-')	y=-1;	c=getchar();	}
	while(c>='0' && c<='9')	{	x=x*10+(c-'0');	c=getchar();	}
	return x*y;
}

bool cmp(int u,int v)   //从大到小排序
{
	return u>v;
}

bool chk(int k)     //二分判断，k为目前的列数
{
	for(int i=1;i<=k;i++)
	{
		int sum=0;
		for(int j=i;j<=n;j+=k)
		{
			b[++sum]=a[j];     //sum计算此时共摞了几块积木
		}
		for(int j=1;j<=sum;j++)
		{
			if(b[j]-(sum-j)<0)   //如果第j块积木上面摞了超过b[j]块积木，说明不可行
			{
				return false;    //搜索更多的列数
			}
		}
		for(int j=1;j<=sum;j++)   //b数组清零，方便接着存储
		{
			b[j]=0;
		}
	}
	return true;    //搜索更少的列数
}

int main()    //主函数
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
	}
	sort(a+1,a+n+1,cmp);
	l=1;
	r=n;
	while(l<r)
	{
		mid=(l+r)/2;
		if(chk(mid))
		{
			r=mid;
		}
		else
		{
			l=mid+1;
		}
	}
	printf("%d",l);
	return 0;
}
```

---

## 作者：redegg (赞：4)

当我看到这题时，心中贪心，脑中DP。

但后来我发现这题太傻逼了。

##首先明确，只要某积木上方的积木情绪值小于它，它就一定不会生气（不会不合法）。##

那么对于某块积木来说，如果他很小，他肯定喜欢最小的那一堆放在自己身上（开始讲哲理了）。

那么我们把输入的排序一下，在用一个数组来存现在每一堆的个数。

把最小的一堆放在现在最小的积木上，一定是最优的，也是最稳定的，为什么呢？讲完过程你或许会明（meng）白（bi）。

首先最小的一堆都放不到这块积木上肯定要开新堆（ken）。

放得下的话就放，这个更新后的堆一定也能再次放到下一个最大的上面（不清楚的看第三排文字），但是这样就会出现一个非常大的堆（贼不好，差距太大），所以我们在放之前都要从小到大排序，这样每次都是最小堆放上最小积木，一定程度上使每个堆平衡。

代码如下（看不懂还是算了，我写题解时也很懵逼（啊，我在写啥？怎么过的？））

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[10005];
int b[10005];
int p=1;


int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    b[1]=1;
    sort(a+1,a+1+n);
    int ans=1;
    for(int i=2;i<=n;i++)
    {
        if(b[1]<=a[i])
        {
            b[1]+=1;
        }
        else
        {
            p++;
            b[p]=1;
        }
        sort(b+1,b+p+1);
    }
    cout<<p<<endl;
    return 0;
}

---

## 作者：QianianXY (赞：2)

~~话说蒟蒻好久没发题解了，咕值蹭蹭地掉~~

本篇代码较短，应该是考场上较易想到的方法。

### 贪心+模拟

题意是$xi$大的积木放下面，积木的$xi$不得超过**上面**的积木总数。但为了方便贪心，这里改成了$xi$小的放下面，积木的$xi$不得超过**下面**的积木总数。结果是一样的。

贪心策略：给积木排序，选择$xi$尽可能小，但又符合题意的积木搭上。假如当前列已经搭不上去了，就$ans+1$，重新开一列，按照策略，用还未使用的积木搭上。

用数组$b$记录积木是否被使用。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[5005], sum, ans, b[5005], num; // num表示已使用的积木数量，即可判断积木是否用完(num == n)，不用遍历b。
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n && num < n; i++, ans++)
	{
		sum = 0; // 记录该列已有多少个积木
		for (int j = 1; j <= n; j++)
			if (a[j] >= sum && !b[j])
				sum++, b[j] = 1, num++;
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：Jayne (赞：1)

由题意易知此题应用贪心法，但是贪心策略的选择却不是那么容易，一开始我是用的从大到小排序，然后一层层往上垒，这样想太过片面，因为这样仅适用于情绪值各不相同的情况。正解应为从小到大排序，一层一层往下塞，每次都要遍历所有已搭的积木列，按照先后顺序往下面塞，才是真正的贪心策略。提示：类似于导弹拦截问题第二问

代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[5001];
int t[5001];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    sort(a+1,a+1+n);
    int num=1;
    t[1]=1;
    for(int i=2;i<=n;i++)
    {
        int flag=0;
        for(int j=1;j<=num;j++)
        {
            if(a[i]>=t[j])
            {
                t[j]++;
                flag=1;
                break;
            }
        }
        if(!flag)
        {
            num++;
            t[num]=1;
        }
    }
    cout<<num;
}
```

---

## 作者：长明 (赞：0)

##### 蒟蒻第一次做绿题，方法还是从大佬那里学的  φ(>ω<*) 

PS：宋荣子 一般指宋钘，话说这个古人搭积木干嘛。。。
######  宋钘（约公元前370年—公元前291年），又称宋子（庄子作宋钘，孟子作宋牼，非子作宋荣子），宋国人。中国战国时期著名哲学家，宋尹学派创始人及代表人物    [百度百科](https://baike.baidu.com/item/%E5%AE%8B%E9%92%98/3969298?fromtitle=%E5%AE%8B%E8%8D%A3%E5%AD%90&fromid=1637384&fr=aladdin)
# ------------
分鸽线

# ------------


首先sort排序一下，然后从头开始考虑是否另起一列，接着把下面符合条件的积木都统统找过来，该列找完之后重新循环，~~~~乐此不疲~~~~，最后一气呵成，华丽的输出ans即可

```cpp
#pragma GCC optimize(3)//O2优化？我怎么可能是那种人？直接O3  (≖ᴗ≖)✧
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;
int n,a[5010],ans=0;//ans表示需要几列
bool pd[5050]={false};//判断当前积木是否被使用
int main()
 {
  	ios::sync_with_stdio(0);//关闭同步计时流，这样显得代码很高效awa
  	cin>>n;//输入积木个数
  	for(register int i=1;i<=n;i++)cin>>a[i];//这是什么邪门歪道啊喂....register真香!!!
  	sort(a+1,a+n+1);//正经了，从小到大排列，情绪值最小的当然是首先考虑
  	for(int i=1;i<=n;i++)
  		if(pd[i]==false)//如果当前积木没被使用
  		{
  			pd[i]=1;//新的列：“那你就是我的人了！！！@pd[i]”
  			ans++;//计入新的列
  			int cnt=0;//在当前列计数
  			for(int j=i+1;j<=n;j++)//从下一个开始一个个看
  				if(pd[j]==false&&cnt+1<=a[j])//没被使用且下面的积木还不想打人（你不会发现我没用register）
  					{
  						pd[j]=1; //又蛊惑一个积木
						cnt++; //战绩++  (>ω･* )ﾉ
				  	}
		}
	cout<<ans<<endl;//输出答案
	return 0;
 }


```
~~又是O3又是register的，我怎么不去打表呢~~


又是跪求过审的一次


---

## 作者：山海无风 (赞：0)

看题目我们发现可以贪心，就是尽量把Ai值小放在上面，这就需要排序一下，这里可以开一个优先队列q1，自带排序~~其实就是懒~~，从小的开始取，那如果当前的这个不能取呢？

比如：**0 1 1 2 3 4 5 6**

很明显第二个数字不能取，那怎么办？？？

很简单，再开一个数组q2~~优先队列~~存下去，当我们把当前这个队列解决了，我们再去解决队列q2，一直这样重复的取，直到两个队列都为空，就可以了。

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> > q1;//优先队列 
priority_queue<int,vector<int>,greater<int> > q2;
int n,ans=0;
void add()
{
	while(1)
	{
		int tot=1;//当前已经开始堆放的积木数 
		if(!q1.empty())
		{
			ans++;
        	q1.pop();//放在第一个的积木是对Ai的值没有限制的，可以直接取走 
		}            // 必须要队列中有成员才能pop，不然程序可能会死循环 
    	while(!q1.empty())
    	{
    		int next=q1.top(); 
    		q1.pop();
    		if(next>=tot) tot++; 
    		else q2.push(next);//加入队列2 
    	}
    	tot=1;
    	if(!q2.empty())
		{
			ans++;
        	q2.pop();//同上 
		} 
    	while(!q2.empty())
    	{
    		int next=q2.top();
     		q2.pop();
    		if(next>=tot) tot++;
    		else q1.push(next);
    	}
    	if(q1.empty()&&q2.empty()) break;//两者为空就退出 
    }
	
}
int main()
{
	cin>>n;
	int x;
	for(int i=0;i<n;i++)
	{
		scanf("%d",&x);
		q1.push(x);
	}
	add();
	cout<<ans;
}
```

PS:可以试试把q1.pop()放在if（！q1.empty（））外面，这样修改会导致程序对类似“**1 2 3 4 5  6 7 8 9**”的数据不输出，也就是说队列为空再pop（）的话反会值不是0.

~~这样交上去你有六十分~~

---

## 作者：__Unknown (赞：0)

##  ~~对没错本蒻又来交暴力题解了……~~
#### 呃，小于5e3的数据让你想到了什么？对没错就是暴力。我们首先会发现，这个题目完全是可以模拟积木的堆积的。积木的情绪值设定使得我们可以直接以贪心的策略进行模拟，将情绪值大的积木放在下面来使得它的上面不会有过多的积木导致生气……那么我们只需要一个外层大循环来枚举最少的积木列数，再来一个check函数判断一下如此数量的列数是否可行不就行了么？就是这么简单。
### 	~~废话少说放码过来~~


```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#define queiuweiuwerweeqwww a
#define queiuweiuwerweeqwew book
#define queiuweirwerweeqwew ans
using namespace std;
int num,queiuweirwerweeqwew;
int queiuweiuwerweeqwww[100005],queiuweiuwerweeqwew[100005];//分别为情绪值数组和check时用的临时计数数组 
bool ___(int key)
{
	memset(queiuweiuwerweeqwew,0,8+4*num);
	int p=0;
	for(int __=1;__<=num;__++){
		p=__%key;//这里加上mod来循环给每一列积木累加
		if(queiuweiuwerweeqwww[__]<queiuweiuwerweeqwew[p])//如果情绪值小于累加积木数量就return1
		return 1;
		queiuweiuwerweeqwew[p]++;
	}
	return 0;
}
int main()
{
	cin>>num;
	for(int ____=1;____<=num;____++)
	cin>>queiuweiuwerweeqwww[____];
	sort(queiuweiuwerweeqwww+1,queiuweiuwerweeqwww+num+1);//排序以实现贪心策略 
	for(int _=1;_<=num;_++){ 
		if(!___(_)){
		cout<<_<<endl;
		return 0;}
	}
	return 0;
} 
```

                      
            
                      


---

## 作者：SDU_AnKh_Ezra (赞：0)

看到数据范围 n<=5000，可以用比较暴力的算法！

这题的关键在于转换自己的思维 ：把 xi 较大的堆在最下面似乎是可行的，不过再向上加新的积木可能最下面的积木又不允许=.=。

一个一个判断？

。。反正我不会。

逆过来考虑，先排好最小的，再找大的排在下面，不能排就再开一列。

可能说的不是很清楚（语文成绩-=150），我在代码里注释吧。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[5001],f[5001];//f[i]表示第i列积木已经排了几个 
int read()//读入函数，也许是个读入优化？不过不用对这个题没有影响 
{
    int ans=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c))
    {
        if(c=='-')f=1;
        c=getchar();
    }
    while(isdigit(c))
    {
        ans=ans*10+c-'0';
        c=getchar();
    }
    return f ? -ans : ans;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
    }
    sort(a+1,a+n+1);//要从a[i]最小的开始枚举 
    f[1]=1;//第一列先放一个 
    int now=1;//当前一共有几列 
    for(int i=2;i<=n;i++)
    {
        sort(f+1,f+now+1);//尽量往高度最小的积木列上加，这样才能保证对以后的操作是最优的 
        for(int j=1;j<=now;j++)
        {
            if(f[j]<=a[i])//可以放上第i个 
            {
                f[j]++;//这一列再放一个 
                break;
            }
            else
            {
                now++;
                f[now]=1;//开一个新的列 
                break;//和上面break一样，处理完这个积木就不用继续枚举积木列了 
            }
        }
    }
    cout<<now;//一共排了now列 ，输出答案 
    return 0;
}
```

---

## 作者：夏色祭 (赞：0)

#开学了，2017NOIP的脚步近了


#楼下都没有Pas的题解，那我来补一发


以上属于个人吐糟请无视


##华丽丽的分割线-------------------------------------------------------


接下来还是讲思路，显然这题可以用贪心来做。


先对x数组按升序排序，因为显然x[i]更小的肯定是放在上面。


对于每个x[i]，去找我们当前哪个列的是可以放x[i]的，如果有这把x[i]放在那个列上面，否则新建一个列


献上没有66666a代码丑陋的代码：


```cpp
var
  a,b:array[0..5001]of longint;
  n,i,j,ans,x:longint;
procedure kp(l,r:longint);
var
  i,j,mid:longint;
  begin
    i:=l;
    j:=r;
    mid:=a[(l+r) >> 1];
    repeat
      while a[i]<mid do inc(i);
      while a[j]>mid do dec(j);
      if i<=j then 
        begin
          a[0]:=a[i];a[i]:=a[j];a[j]:=a[0];
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<r then kp(i,r);
    if l<j then kp(l,j);
  end;//对a数组进行排序
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  kp(1,n);
  for i:=1 to n do 
    begin
      x:=-1;//标记一下，因为有可能a[i]放不了当前已有的几个列
      for j:=1 to ans do 
        if b[j]<=a[i] then x:=j;//如果可以放，则标记一下那个列的编号
      if x=-1 then begin inc(ans);b[ans]:=1; end
        else inc(b[x]);//如果不行则新建，否则给放的那个列的积木数量+1
    end;
  write(ans);//ans保存着当前一共有几个列
end.
```

---

## 作者：s_a_b_e_r (赞：0)

###dp
十分明显的一个序列dp，先按照高度排一遍序，然后贪心找满足条件的情况下，木块最少的那个，然后把那一列加1；

dp[i]是在第i堆中满足条件的最多的木块。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define maxn 5000+99
using namespace std;
int dp[maxn],a[maxn];
int n,ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
    int z=0,mind=maxn;
    for(int j=1;j<=ans;j++){
        if(dp[j]<=a[i]){
            if(z==0)z=j,mind=dp[j];
            else  if(mind>dp[j])z=j,mind=dp[j];
        }
    }
        if(z)dp[z]++;
        else {
            ans++;dp[ans]=1;
             }
        }
    cout<<ans;
    return 0;
}
```

---

## 作者：little_www (赞：0)

wa好老的题了。。青草池塘处处wa

sort后直接模拟即可，，不过数据再大点估计就炸了



```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;                        
int n,cnt,s;
int a[5005],vis[5005];
int read(int &n)//quick
{
    char ch=' ';int q=0,w=1;
    for(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());
    if(ch=='-')w=-1,ch=getchar();
    for(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;
    n=q*w;    return n;
}
int main()
{
//    freopen("box.in","r",stdin);
//    freopen("box.out","w",stdout);
    read(n);
    for (int i=1;i<=n;i++){//init
        int x;
        read(x);
        a[i]=x;
        //cin>>a[i];
    }
    sort(a+1,a+n+1);//sort纯模拟 
    for (int i=1;i<=n;i++)
        if (vis[i]==0)//not used
        {
            s++;   //column
            cnt=1;
            vis[i]=1;    //mark
            for (int j=i+1;j<=n;j++)
                if ((vis[j]==0)&&(a[j]>=cnt))
                   {
                       vis[j]=1;
                       cnt++;
                   }
        }
    cout<<s<<endl; 
    return 0;
}

```

---


# 语言普查

## 题目背景

Yugo国的人民在进行一次人口普查，由于Yugo国是典型的多民族国家，所以拥有许多种语言。


## 题目描述

“Kiaosmaonsnai Assi fi wais

"Kjamqosoaksi mais pas?"

"Oci! Asia olo mnai naso!"

"2333在说什么啊根本听不懂。。。”

这是Yugo国的日常。。。

Yugo国有许多不同的种族，这些不同的种族不同的语言，但是主席扔给了你几本字典，这样，你就知道他们在说什么语了。你的任务就是判断他们在说什么语并填上户口本（？）。


## 样例 #1

### 输入

```
4
Qzrian yy ghy qzr
Yugoslavian mihailova petrozavodsk saint-petersburg
Suissvia yugoslavia korse mais kohnin
Mohaian Jzm Wallace Zhangbaohua djh 

yy,qzr and ghy are i don't know
mihailova saZk amOmlio
mais c'est pas Ca
wallace is good
```

### 输出

```
Qzrian
Yugoslavian
Suissvia
Mohaian

```

# 题解

## 作者：w_____ (赞：10)

[题目链接](https://www.luogu.org/problemnew/show/P3752)

本题有两个坑点：
1. 出现\ 、-或 ' 视为一个单词，实际上是 ' 或 - 视为单词的构成字符，其它字符作为分隔符。
1. 下一个N行依次包含该语言的名称，后跟该语言中的一个或多个单词，词和词之间用空格隔开。实际上分割单词的不仅仅是空格，也有别的符号，所以如果使用getline作为读入流会Wrong，应该用题目所说的那种分割方式来读单词。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

bool check(char c) {
    return !islower(c) && !isupper(c) && c != '\'' && c != '-';
}

void convert(string &s) {
    for (auto &c : s)
        if (isupper(c))
            c += 'a' - 'A';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    map <string, string> mp;
    string s, a, b;
    getline(cin, s);
    stringstream ss(s);

    int n;
    ss >> n;
    while (n--) {
        getline(cin, s);
        s += ' ';
        a = "";
        int flag = 0;
        for (auto &c : s) {
            if (check(c)) {
                if (flag++ && b.size())
                    convert(b), mp[b] = a;
                b = "";
            } else {
                if (flag)
                    b += c;
                else
                    a += c;
            }
        }
    }
    getline(cin, s);
    while (getline(cin, s)) {
        s += ' ';
        a = "";
        for (auto &c: s) {
            if (check(c)) {
                convert(a);
                if (mp.count(a)) b = mp[a];
                a = "";
            } else {
                a += c;
            }
        }
        cout << b << '\n';
    }
    return 0;
}

```

---

## 作者：hexuchen (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P3752)

[更好的阅读体验？](https://www.luogu.com.cn/article/relg97bn)

## 题目大意

给出 $n$ 种语言中若干个单词，再给出若干个文本，求问每个文本分别使用了哪种语言。

## 思路分析

一道本来很水，但因为数据以及题目表述而变得很坑的难题。

思路非常好想。用 `map` 存储每一个单词对应的语言，再读入文本，针对文本的每一个单词用 `map` 输出其对应的语言。

## 坑点

1. 每当出现标点符号、换行、空格则被视为一个**独立**的单词。但如果出现连接线、引号，则符号两端的单词视为**一个**单词。比如，`aa.bb` 中 `aa` 和 `bb` 分别是两个不同的单词。而 `aa-bb` 中只有 `aa-bb` 这一个单词。
2. 读入很麻烦。我们只知道语言的种类 $n$，而不知道每种语言的单词个数。我们也不知道会有多少个示例文本。对于语言的单词个数，可以直接 `getline` 读取整行，再针对整行进行分割。对于示例文本，可以用 `while(getline(cin,s))` 的方法来连续输入。
3. 第 $2$ 个数据点有锅（可能不止第 $2$ 个数据点），在数据点中的单引号被替换为了乱码（其实不是乱码，但是我打不出来），不过问题不大，因为反正单引号不分割单词，只需要在判断单词之间的分隔时不要采用不是字母就是分隔符的方法来，而是一个一个判断分隔符即可。
4. 第 $6$ 个数据点同样有锅。本来输入是 $n$ 单独占一行，而第 $6$ 个测试点的 $n$ 并没有单独占一行，而是与后面的数据连在了一起。我们可以使用 `stringstream` 的方式来读入 $n$。
5. 换行。本题所有的数据中换行都是 `\n\r`，这会导致数据下载下来本地测试无误，但是提交全部错误。解决办法很简单，在读入后面连续两次 `getchar` 就好了。但是在第 $6$ 个点中，因为 $n$ 单独占一行，所以连续两次 `getchar` 会直接读入后面的内容，导致答案错误，所以不要使用 `cin`，应用 `stringstream`。其次，每次 `getline` 都会读入 `\r`，方法是先用 `remove` 把 `\r`全部移到字符串的末尾，再用 `erase` 擦除末尾的 '\r' 即可。这一招在很多题上都有用（~~感谢文心一言的贡献~~）。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;
map<string,string> d; //存储单词对应语言的字典
int main(){
    getline(cin, s);
    stringstream ss(s); //采用 stringstream 来输入，具体可自行百度
    ss>>n;
	for(int i=1;i<=n;i++){
		getline(cin,s); //循环输入语言，因为不知道单词数，直接读取一行
		s.erase(remove(s.begin(),s.end(),char(13)),s.end()); //这一语句可以删去字符串中的 \r
		bool flag=true; //标记变量，判断有没有处理语言名称
		string word="",kind; //第一个是分割出的单词，第二个是语言名称
		for(int i=0;i<s.size();i++){
			if(s[i]=='.' || s[i]==',' || s[i]=='!' || s[i]=='?' || s[i]==';' || s[i]=='(' || s[i]==')' || s[i]==' '){ //判断有没有到分隔符
				if(flag){ //语言名称还没有
					flag=false;
					kind=word;
				}
				else{ //存入字典
					d[word]=kind;
				}
				word="";
			}
			else{
				if('A'<=s[i] && 'Z'>=s[i] && !flag){ //注意不区分大小写，所以要全部转化成小写或大写
					word+=s[i]+32;
				}
				else{
					word+=s[i];
				}
				word.erase(remove(word.begin(),word.end(),char(13)),word.end()); //删除 \r
			}
		}
		d[word]=kind;
	}
	getline(cin,s); //清除中间的空行
	while(getline(cin,s)){ //不断读入
		string word=""; //老方法处理文本
		bool flag=true;
		for(int i=0;i<s.size() && flag;i++){
			s.erase(remove(s.begin(),s.end(),char(13)),s.end());
			if(s[i]=='.' || s[i]==',' || s[i]=='!' || s[i]=='?' || s[i]==';' || s[i]=='(' || s[i]==')' || s[i]==' '){
				if(d[word]!="" && word!=""){
					flag=false;
					cout<<d[word]<<endl; //flag 是标记有没有确定过语言种类
				}
				word="";
			}
			else{
				if('A'<=s[i] && 'Z'>=s[i]){
					word+=s[i]+32;
				}
				else{
					word+=s[i];
				}
				word.erase(remove(word.begin(),word.end(),char(13)),word.end());
			}
		}
		if(flag){ //注意，最后一个单词是得不到处理的，得单独处理
			cout<<d[word]<<endl;
		}
	}
	return 0; //完结撒花~
}
```

---

## 作者：rickyxrc (赞：4)

upd:2021/3/29 修改排版

给大家介绍一下语言普查这道题,这道题是我做的第二道 普及+/提高 对我个人有比较重要的意义。

这道题的思路其实不难，坑点多。坑点如下：

- 出现 ``` ' - " ``` 视为一个单词,是指形如 
```aa'b aa-b aa"b ``` 
等视为同一个单词存储记录。

- 分隔符 ``` . , ? ! ; ( ) ``` 是指形如 ``` aa.bb aa,bb aa?bb aa!bb ``` 会将 ```aa``` 和 ```bb``` 视为两个单词分别存储。

- 单词匹配不分大小写！

---

接下来，我们思考这道题的做法：
主体结构：map<string,int>  (主要是本蒟蒻不会字典树)
使用string映射到int，在使用一个数组 $l$ 存储语言名称，节省空间。

读入部分(不分大小写，只存小写)
```cpp
for(int i=1;i<=n;i++){
		cin>>l[i]; //语言名称
		m="";
		flag=1;
		cin.get(c);
		do{
			cin.get(c);
			if(c==' '){
				if(m=="")
					continue;	
				v[m]=i;
				m="";
				continue;
			}
			else if(c=='\n'||c=='\r'){ //读完整行
				v[m]=i;
				m="";
				break;
			}
			else if(c>='a'&&c<='z')//接下来是大小写转换
				m+=c;
			else if(c>='A'&&c<='Z')
				m+=(c-'A'+'a');
            else m+=c;
		}while(1);
	}
```
查询使用map的迭代器，也很方便。
```cpp
  //iter 是 map<string,int>::iterator 类型
  iter=v.find(r);
  if(iter!=v.end()){
    cout<<l[iter->second]<<endl;//输出键值对里的值
   break;
}
```

所以代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>v;
map<string,int>::iterator iter;  
string l[101];
int main(){
	ios::sync_with_stdio(false);
	int n;
	char c;
	string m;
	cin>>n;
	bool flag=1;
	for(int i=1;i<=n;i++){
		cin>>l[i];
		m="";
		flag=1;
		cin.get(c);
		do{
			cin.get(c);
			if(c==' '){
				if(m=="")
					continue;	
				v[m]=i;
				m="";
				continue;
			}
			else if(c=='\n'||c=='\r'){
				v[m]=i;
				m="";
				break;
			}
			else if(c>='a'&&c<='z')
				m+=c;
			else if(c>='A'&&c<='Z')
				m+=(c-'A'+'a');
            else m+=c;
		}while(1);
	}
	string k="",r="";
	bool fst=1;
    while(getline(cin,k)){
        if(k==string())
            continue;
        if(k[k.length()-1]=='\r')    
            k.erase(k.length()-1);
		for(int i=0;i<k.length()&&k.length();i++){
			r=string();
			while(k[i]!='!'&&k[i]!=' '&&k[i]!=','&&k[i]!='.'&&k[i]!='('&&k[i]!=')'&&k[i]!=';'&&i<k.length()){
				if(k[i]>='A'&&k[i]<='Z')
					r+=(k[i]-'A'+'a');
				else if(k[i]>='a'&&k[i]<='z')
					r+=(k[i]);
                else r+=k[i];
				i++;
			}
            if(r==string())
                continue;
			iter=v.find(r);
			if(iter!=v.end()){
				cout<<l[iter->second]<<endl;
				break;
			}
            else;
		}
	}
	return 0;
}
```

---

## 作者：hlb44 (赞：1)

# 题目分析
坑点：输入数据可能存在特殊情况，例如 $ n $ 可能不是单独一行输入，字符串中可能包含特殊的换行符，这些都会导致 ``` WA ``` 掉。
# 解题思路
1. **数据存储**：
   用 ``` map ``` 存储。单词转小写后的字符串，值是该单词所属的语言名称。
2. **输入处理**：
   用 ``` getline ``` 读，用 ``` stringstream ``` 解析，取名称和单词，将单词转小写并存入 ``` map ```。待判断的文本也用 ``` getline ``` 逐行读取。读取后，在 ``` map ``` 中查找对应语言。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;
map<string,string> d; //存储单词对应语言的字典
int main(){
    getline(cin, s);
    stringstream ss(s); //采用 stringstream 来输入，具体可自行百度
    ss>>n;
	for(int i=1;i<=n;i++){
		getline(cin,s); //循环输入语言，因为不知道单词数，直接读取一行
		s.erase(remove(s.begin(),s.end(),char(13)),s.end()); //这一语句可以删去字符串中的 \r
		bool flag=true; //标记变量，判断有没有处理语言名称
		string word="",kind; //第一个是分割出的单词，第二个是语言名称
		for(int i=0;i<s.size();i++){
			if(s[i]=='.' || s[i]==',' || s[i]=='!' || s[i]=='?' || s[i]==';' || s[i]=='(' || s[i]==')' || s[i]==' '){ //判断有没有到分隔符
				if(flag){ //语言名称还没有
					flag=false;
					kind=word;
				}
				else{ //存入字典
					d[word]=kind;
				}
				word="";
			}
			else{
				if('A'<=s[i] && 'Z'>=s[i] && !flag){ //注意不区分大小写，所以要全部转化成小写或大写
					word+=s[i]+32;
				}
				else{
					word+=s[i];
				}
				word.erase(remove(word.begin(),word.end(),char(13)),word.end()); //删除 \r
			}
		}
		d[word]=kind;
	}
	getline(cin,s); //清除中间的空行
	while(getline(cin,s)){ //不断读入
		string word=""; //老方法处理文本
		bool flag=true;
		for(int i=0;i<s.size() && flag;i++){
			s.erase(remove(s.begin(),s.end(),char(13)),s.end());
			if(s[i]=='.' || s[i]==',' || s[i]=='!' || s[i]=='?' || s[i]==';' || s[i]=='(' || s[i]==')' || s[i]==' '){
				if(d[word]!="" && word!=""){
					flag=false;
					cout<<d[word]<<endl; //flag 是标记有没有确定过语言种类
				}
				word="";
			}
			else{
				if('A'<=s[i] && 'Z'>=s[i]){
					word+=s[i]+32;
				}
				else{
					word+=s[i];
				}
				word.erase(remove(word.begin(),word.end(),char(13)),word.end());
			}
		}
		if(flag){ //注意，最后一个单词是得不到处理的，得单独处理
			cout<<d[word]<<endl;
		}
	}
	return 0; //完结撒花~
}

---

## 作者：yx666 (赞：1)

# P3752 语言普查题解
[一道毒瘤字符串题](https://www.luogu.com.cn/problem/P3752)。

## Part 1：题目大意
给定 $n$ 种语言，分别给出它的名字以及词汇字典。

现在给出多句话，依次输出每句话对应的语言。

> 判断语言依据：
>
> 某个词（不区分大小写）出现在某个语言的字典中。

> 断词断句依据（分隔符）：
> 
> `,`、`.`、`?`、`!`、`;`、`(`、`)`、换行、空格。

## Part 2：处理
### Part 2.1：字符串
1. 将除了语言名字以外的字符处理成全小写。

2. 将所有提到的分隔符替换成空格以便处理。

函数式编程：

``` cpp
// 字符格式化
inline char check(char ch){
	switch (ch) {
	case '.':
	case ',':
	case '?':
	case '!':
	case ';':
	case '(':
	case '\n':
	case '\r':
	case ')':
		return ' ';			// 将所有分隔符处理成空格。
	default:
		return tolower(ch);	// 将所有单词处理成小写
	}
}

// 字符串格式化
// 其中 “&” 是引用，没有复制，会修改函数外的值
inline string cg(string&s){
	for(auto&it:s)
		it=check(it);
	return s;
}
```

### Part 2.2：建立字典映射
这里采用 `unordered_map` 实现。

```cpp
unordered_map<int,string>sample;	// sample[1] 表示第一个语言名称
unordered_map<string,int>mp;		// mp[str] 表示小写词语 str 对应的语言序号
```

### Part 2.3：取出单词
这里介绍一个黑科技：[使用 `stringstream` 与 `getline` 分割字符串](https://blog.csdn.net/qq_36743440/article/details/91999615)。

对应到代码中是这样的：

``` cpp
cin>>n;
string s,token;
stringstream ss;
for(int i=1;i<=n;++i){
	cin>>s;
	sample[i]=s;
	
	getline(cin,s);
	
	ss.clear();				// 先清空字符串流
	ss.str(cg(s));			// 赋值，等同于 ss<<cg(s)。
	while(getline(ss,token,' ')){		// 表示从 ss 中读入字符至 token 中，读到空格停止
		if(token.empty()) continue;		// 在 luogu 中，因为某些奇妙的原因，需要特判一下
		mp[token]=i;
	}
}
```

## Part 3：代码
经历了以上的魔改操作，让我们的代码成功跑到[ $20$ ms](https://www.luogu.com.cn/record/164092727)，目前第一。

``` cpp
#include<bits/stdc++.h>
using namespace std;

int n;

// 字符格式化
inline char check(char ch){
	switch (ch) {
	case '.':
	case ',':
	case '?':
	case '!':
	case ';':
	case '(':
	case '\n':
	case '\r':
	case ')':
		return ' ';			// 将所有分隔符处理成空格。
	default:
		return tolower(ch);	// 将所有单词处理成小写
	}
}

// 字符串格式化
// 其中 & 是引用，没有复制，会修改函数外的值
inline string cg(string&s){
	for(auto&it:s)
		it=check(it);
	return s;
}
unordered_map<int,string>sample;	// sample[1] 表示第一个语言名称
unordered_map<string,int>mp;		// mp[str] 表示小写词语 str 对应的语言序号
signed main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	
	cin>>n;
	string s,token;
	stringstream ss;
	for(int i=1;i<=n;++i){
		cin>>s;
		sample[i]=s;
		
		getline(cin,s);
		
		ss.clear();				// 先清空字符串流
		ss.str(cg(s));			// 赋值，等同于 ss<<cg(s)。
		while(getline(ss,token,' ')){		// 表示从 ss 中读入字符至 token 中，读到空格停止
			if(token.empty()) continue;		// 在 luogu 中，因为某些奇妙的原因，需要特判一下
			mp[token]=i;
		}
	}
	
	// 解决行尾回车
	while(cin.peek()=='\n'){
		getline(cin,s);
	}
	while(getline(cin,s)){
		ss.clear();
		ss.str(cg(s));
		while(getline(ss,token,' ')){		// 分割字符串
			if(mp.count(token)){			// 如果对应，输出并处理下一句话
				cout<<sample[mp[token]]<<'\n';
				break;
			}
		}
	}
	return 0;
}

```

这里列举一点可能对修 BUG 有用的数据：

1. WA on #1，#3，#4，#5：可能是 `check` 中没有判断 `\r` 这个换行符。
2. WA all：可能是分割处没有检测字符串是否为空。

---

## 作者：苏打青柠水 (赞：1)

发一篇java字典树的做法。

这道的坑很多。

第一：输入语言的时候，它只说了是单词，并不保证是一定大写或小写，但是有一点肯定的以空格分割，所以使用字典树存储时，要开比26大的空间，我这里开35来处理，其他的字母；

第二：字符串的比较是不分大小写的，而且需要按照题目给的"." "," "?" "!" ";""("")"进行分割，记得还有空格' '；

第三：在比较的最后，因为在写的时候条件是在找到分割符时，才会去字典树找，但是如果是最后一个单词，它后面没有分割符，就会导致，没匹配没输出，所以在最后还要判断是否找到了，没找到，就直接把最后一个单词输出。
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.HashMap;

public class Main {

	
	static Tree tree[] = new Tree[50000];// 字典树
	static int tot = 0; //内存池
	static int index = 26; //非a-z字母的特殊处理下标池
	static HashMap<Character, Integer> map = new HashMap<>();  //保存非特殊字母的下标

	static class Tree {
		int next[] = new int[35]; // 0-25表示小写，开多10个是针对可能出现的非a-z字母
		int number;    // 保存语言的下标

	}

	static void insert(char[] s, int num) {
		int p = 0;   //根节点
		int len = s.length;
		for (int i = 0; i < len; i++) {

			int c;  

			if (s[i] >= 'a' && s[i] <= 'z')  //如果是a-z就计算的出c
				c = s[i] - 'a';
			else
				c = map.get(s[i]);  //否则就从map取

			if (tree[p].next[c] == 0) {
				tree[p].next[c] = ++tot;
				tree[tot] = new Tree();
			}
			p = tree[p].next[c];
		}

		tree[p].number = num;
	}

	static int query(char[] s) {
		int p = 0;

		int len = s.length;
		for (int i = 0; i < len; i++) {
			int c;
			if (s[i] >= 'a' && s[i] <= 'z')
				c = s[i] - 'a';
			else {
				c = map.get(s[i]);

			}

			if (tree[p].next[c] == 0)  //该情况是该单词不存在
				return 0;    
			p = tree[p].next[c];
		}
		
		return tree[p].number;   //有两种情况，可能为0，就表示这不是单词结尾，否则就是单词结尾

	}

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); //输入
		int n = Integer.parseInt(reader.readLine().trim());
		tree[0] = new Tree();  //初始化根节点
		
		String source[] = new String[n + 1]; //存储语言
		
		for (int i = 1; i <= n; i++) {
			
			String temp[] = reader.readLine().trim().split(" ");  //读入
			
			source[i] = temp[0];  //每一行的第一个为语言，原样保存
			
			for (int j = 1; j < temp.length; j++) {

				char s[] = temp[j].toLowerCase().toCharArray();
				
				for (int k = 0; k < s.length; k++) {
					if (s[k] >= 'a' && s[k] <= 'z')  //如果是a-z不需要特殊处理
						continue;
					
					//非a-z
					if (map.containsKey(s[k]))   //存在过，不需要添加
						continue;
					
					map.put(s[k], index++); //不存在，添加
				}
				insert(s, i);   //记得插入
			}
		}
		
		reader.readLine();  //单独空一行
		
		StringBuffer sb = new StringBuffer();
		while (true) {
			String temp = reader.readLine();  //读入
			if (temp == null)  //空行退出
				break;
			
			String str = "";
			char s[] = temp.toLowerCase().toCharArray();
			
			boolean find = false;  //找到标记
			
			for (int i = 0; i < s.length; i++) {
				
				//如果是分割符，就要把前面的字符串拿进字典树匹配
				if (s[i] == '.' || s[i] == ',' || s[i] == '?' || s[i] == '!' || s[i] == ';' || s[i] == '('
						|| s[i] == ')' || s[i] == ' ') {
					//长度为0，就是没有字符串，就continue
					if (str.length() == 0)
						continue;
					
					//查询，如果非0就是存在
					int tag = query(str.toCharArray());

					str = "";
					if (tag == 0)
						continue;
					
					find = true; 
					sb.append(source[tag]).append("\n");
					break;   //找到就直接退出，因为每一行不会出现不同语言

				} else {
					str += s[i];

				}
			}
			
			//特殊处理最后的，因为最后可能没有分割，有可能找到最后才找到，所以要加入最后的，当然如果找了，就直接跳过
			if (!find) {   
				int tag = query(str.toCharArray()); 
				if (tag != 0) //其实这就话和前面的找字典树都可以删掉，因为题目一已经说明了，有且只有一种，可以直接输出
					sb.append(source[tag]).append("\n");
			}

		}
		
		//输出
		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
		out.print(sb);
		out.flush();
		out.close();

	}
}
```


---


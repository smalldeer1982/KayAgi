# [TJOI2007] 圆

## 题目描述

平面上有 $n$ 个圆，任意两个不同的圆之间只有相离（可以外切）和包含（可以内切）两种关系。

初始时整个平面是黑色的，我们按照输入给定的顺序在平面上画出这些圆。我们画一个圆的时候，把这个圆覆盖的区域全部反色，即如果区域中的一个点原来是黑色，则将它涂为白色；如果这个点原来是白色，则将它涂成黑色。

按照这个步骤把所有的圆都画出来后，请输出平面上的所有白色区域的面积之和。

## 说明/提示

对于 $100\%$ 的数据，$0\le n\le 100$，对于所有的圆，均有 $|x|, |y|, r \le 1 000$。

## 样例 #1

### 输入

```
3
0 0 5
0 1 2
10 10 1```

### 输出

```
69.12```

# 题解

## 作者：ikka (赞：6)

可以发现，画圆的顺序对答案并没有影响，所以我们可以考虑按照圆的半径排序。

对于每一个圆$X$，找到半径最小的圆$Y$，使得圆$X$在圆$Y$内部，然后根据圆$Y$的颜色确定圆$X$的颜色并计算对答案的贡献。

时间复杂度$O(n^{2})$，对于这题数据随便跑就好。

```cpp
#include <bits/stdc++.h>
const int maxn = 111;
const double pi = acos(-1);

struct cir {
  int x, y, r;   // 坐标和半径
  int c;     // 颜色
  inline bool operator < (cir const &rhs) const {
    return this -> r > rhs.r;
  }      // 重载<便于排序
} c[maxn];

template<typename T> T inline sqr(T x) {
  return x * x;
}      // 平方

double inline eucdis(cir x, cir y) {
  return sqrt(sqr(x.x - y.x) + sqr(x.y - y.y));
}      // 欧几里得距离

bool inline isincir(cir x, cir y) {
  return eucdis(x, y) < x.r + y.r;
}      // 根据题目性质没有圆相交，判断x是否在y内。

int main() {
  int n;
  static int ans;
  scanf("%d", &n);
  c[0] = (cir) { 0, 0, 10000, 1 };
  for (int i = 1; i <= n; ++i) scanf("%d%d%d", &c[i].x, &c[i].y, &c[i].r);
  std::sort(c + 1, c + n + 1);
  for (int i = 1; i <= n; ++i) {
    for (int j = i - 1; ~j; --j) {
      if (isincir(c[i], c[j])) {
        c[i].c = -c[j].c;
        // 确定圆的颜色
        ans += c[j].c * sqr(c[i].r);
        // 计算对答案的贡献
        break;
      }
    }
  }
  printf("%.2lf\n", pi * ans);
  return 0;
}
```

---

## 作者：高杰办公厅 (赞：2)

假如第一个圆里面有很多小圆，儿子打1，孙子不打，孙子的儿子再打1…… for两边标记即可。
```cpp
#include<bits/stdc++.h>
const double pai=3.1415926535898;
using namespace std;
struct gaojie{
	int x,y,r;
}yuan[105];
double ans=0;
int n,biaoji[105],f[105];
bool cmp(gaojie a,gaojie b)
{
	return a.r>b.r;
}
double yxjl(int a,int b)
{
	double x1=yuan[a].x,y1=yuan[a].y;
	double x2=yuan[b].x,y2=yuan[b].y;
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int check(int a,int b)
{
	double p=yxjl(a,b);
	if(p>=yuan[a].r+yuan[b].r)
	return 0;
	else return 1;
	
}
double mjjs(int a)
{
	return yuan[a].r*yuan[a].r*pai;
}
int main()
{
//	freopen("circles.in","r",stdin);
//	freopen("circles.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&yuan[i].x,&yuan[i].y,&yuan[i].r);
	}
	for(int i=1;i<=n;i++) f[i]=i;
	
	sort(yuan+1,yuan+n+1,cmp);
	
	for(int i=1;i<=n-1;i++)
	{
		int k=1;
		for(int t=i+1;t<=n;t++)
		{
			if(check(i,t)==1)
			{
				f[t]=i;
				biaoji[t]=1-biaoji[i];
				
			}
			//lianhe(i,t),biaoji[t]=k,k++;//第k个子圆 
		}
	}
	//printf("%d\n",biaoji[3]);
	
	for(int i=1;i<=n;i++)
	{
		if(biaoji[i]==0)
		ans=ans+mjjs(i);
		
	    else ans=ans-mjjs(i);
    }
	printf("%0.2lf",ans);
}
```

---

## 作者：夜筱_Cyone (赞：1)

## [P3844 [TJOI2007] 圆](https://www.luogu.com.cn/problem/P3844)
## 审题
1. 无需判断**内相交**或者**外相交**。

1. **圆 $X$ **的**颜色**取决于包含圆 $X$ 的**最小圆**的颜色的相反色（黑→白，白→黑）。

1. 圆的涂色顺序对本题结果**无影响**。

1. 半径已给，故我们的首要任务是**确定所有圆的颜色**。

1. 颜色规律：**层叠消融**。

## 思路
根据审题 $3$，我们可以将圆按照 **半径 $r$** 的大小来排序~~这里我偷懒用了 sort~~，而且不会对结果产生影响。
例如

先涂 $A$

![](https://cdn.luogu.com.cn/upload/image_hosting/jzkclrq3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

再涂 $B$

![](https://cdn.luogu.com.cn/upload/image_hosting/frnej28p.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

和先涂 $B$

![](https://cdn.luogu.com.cn/upload/image_hosting/35qsjab8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

再涂 $A$

![](https://cdn.luogu.com.cn/upload/image_hosting/frnej28p.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

的结果是一样的。

又根据审题 $1$，如果圆 $B$ 的**圆心**在圆 $A$ 之内，则 $B$ 必定内含于 $A$。

综上所述，


## 步骤
1. 将圆从大到小排序。

1. 对于所有圆 $I$，遍历比 $I$ 大的所有圆，从其中找到最小圆 $J$，圆 $I$ 的颜色与圆 $J$ 相反。

1. 根据所有圆的面积与颜色求和输出。


## 代码
```cpp
#include<iostream>
#include<iomanip>
#include<algorithm> 
using namespace std;
struct ccl{//单个ccl类型数据可以表示单个圆 
	double x,y,r;//x、y：横、纵坐标；r：半径 
	bool color;//颜色，true/1为白色，false/0为黑色 
}reg[110];//本题主数组 
double pnt(bool flag){//根据reg[i].color返回1或者-1方便乘法计算 
	return flag?1.0:-1.0;
}
double sq(double x){//平方 
	return x*x;
}
bool cmp(ccl a,ccl b){//sort排序用 
	return a.r>b.r;
}
int n;
int main(){
	cin>>n;
	long double sum=0;
	for(int i=0;i<n;i++)cin>>reg[i].x>>reg[i].y>>reg[i].r;
	sort(reg,reg+110,cmp);//按照半径从大到小排序
	for(int i=0;i<n;i++){
		reg[i].color=true;
		for(int j=0;j<i;j++)if(sq(reg[i].x-reg[j].x)+sq(reg[i].y-reg[j].y)<=sq(reg[j].r+reg[i].r))reg[i].color=!reg[j].color;//找到最小的圆reg[j]使得reg[i]内含于reg[j]，定义reg[i].color为!reg[j].color 
		sum+=pnt(reg[i].color)*3.14159265359*sq(reg[i].r);//计算面积*颜色系数并且将结果加入sum 
	}
	cout<<fixed<<setprecision(2)<<sum;
	return 0;
} 
```


# 感谢各位的支持！

---

## 作者：QcpyWcpyQ (赞：1)

- 反色类似于异或，具有结合性，所以画圆的顺序对答案并没有影响。

- 因为两个圆之间只有**相离**和**包含**两种关系，因此按照圆的半径大小排序。对于每一个圆 $O_1$找到在 $O_1$ 内半径最小的圆 $O_2$ 将 $O_1$ 的颜色取反作为 $O_2$ 的颜色。

- 因为 $\sum\limits_{i=1}^n \pi r_i^2=\pi\sum\limits_{i=1}^n r_i^2$，所以将 $\pi$ 最后乘上输出答案就行了。

------------
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int s=0,f=1;char ch=getchar();
	while(ch<'0' or ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' and ch<='9'){s=(s<<1)+(s<<3)+(ch^48);ch=getchar();}
	return f*s;
}

inline void write(int num){
	if(num<0)putchar('-'),num=-num;
	if(num>9)write(num/10);
	putchar(num%10+48);
}

const double pi=acos(-1);
const int N=105;
int n,ans;

struct circle{
    int x,y,r,color;
}c[N];

inline bool cmp(circle a,circle b){
    return a.r>b.r;
}

inline bool pd(circle a,circle b){
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))<a.r+b.r;
}

int main(){
    n=read();
	c[0].color=1;
    c[0].r=114514;
    c[0].x=0;
    c[0].y=0;
	for(int i=1;i<=n;++i)
        c[i].x=read(),c[i].y=read(),c[i].r=read();
	sort(c+1,c+n+1,cmp);
	for(int i=1;i<=n;++i)
		for(int j=i-1;j>=0;--j)
            if(pd(c[i],c[j])){
                c[i].color=-c[j].color;
				ans+=c[j].color*c[i].r*c[i].r;
				break;
			}
	printf("%.2f",pi*ans);
	return 0;
}
```


---

## 作者：神眷之樱花 (赞：1)

# 解析
根据数学定义。

如果两个圆圆心的距离大于半径之和，相离；等于，相切；小于，相含。

所以可根据这个定义判断两个圆的位置关系。

记录每个圆被几个圆包含，不难发现偶数（包括零）个则是白色，奇数个则是黑色。

所以可以根据这个分析模拟记录，黑色的记为 $-1$，白色的记为 $1$，最后枚举将每个圆的面记 $\times$ 它的颜色(权值)，累加就能得到答案。
## 注意！！

当两个圆位置和半径相同时，即两个圆重合时，两个圆的作用会抵消，所以得加一个特判，将颜色记为零。

如果忽略这个情况的话，有一个点过不了。

# AC代码
本人打的比较复杂，可以优化一下。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch-'0');ch=getchar();}
	return x*flag;
}//快读优化，不用说了吧。
struct node{
	int xx,yy,r,dad,value,number;
}a[105];
bool cmp(node x,node y)
{
	return x.r>y.r;
}
const double N=acos(-1.0);//圆周率比较可观的值。
int q[105];
double len,ans=0;
int n,nb,nbx,nby;
int main()
{
	//freopen("circles.in","r",stdin);
	//freopen("circles.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++)
	a[i].xx=read(),a[i].yy=read(),a[i].r=read(),a[i].number=i;
	sort(a+1,a+1+n,cmp);//好像可以不用排序，但不想改了。
	for(int i=1;i<=n;i++)
	{
		q[a[i].number]=i;
		for(int j=i+1;j<=n;j++)
		{
			nbx=abs(a[i].xx-a[j].xx),nby=abs(a[i].yy-a[j].yy);
			nb=nbx*nbx+nby*nby;
			len=sqrt(nb);
			if(len<=(a[i].r+a[j].r))//相切或相含。
			{
				if(a[i].r>a[j].r&&a[j].dad!=-1) a[j].dad++;
				else if(a[i].r<a[j].r&&a[i].dad!=-1) a[i].dad++;
				else if(a[i].r==a[j].r)
				{
					if(a[i].dad!=-1&&a[j].dad!=-1) {a[i].dad=-1;a[j].dad=-1;}
					if(a[i].dad==-1&&a[j].dad!=-1) a[j].dad++;
					if(a[i].dad!=-1&&a[j].dad==-1) a[i].dad++;//处理多个圆相同的情况。
				} 
			}
		}
	}
	int flag;
	for(int i=1;i<=n;i++)
	{
		flag=a[q[i]].dad;//如果不排序的话这里应该修改一下，就按圆的顺序枚举。
		if(flag==-1) a[q[i]].value=0;
		else if(flag%2==1) a[q[i]].value=-1;
			else a[q[i]].value=1;
		
	}
	for(int i=1;i<=n;i++)
	{
		ans+=a[i].r*a[i].r*a[i].value;
	}
	ans*=N;
	printf("%0.2lf",ans);
	return 0;
}
```


---

## 作者：lidagua1004 (赞：0)

这道题我想可以用结构体来保存每个圆的信息。

然后枚举每个圆与它前面所有圆的关系来判断它是什么颜色。

代码如下：
```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
double pi=3.14159265358979323846,sum;
struct circle{//用结构体保存圆的信息
	int x,y,r;
	double area;
	bool color;
	void ar(){//计算面积
		area=pi*r*r;
	}
	void scan(){
		cin>>x>>y>>r;
	}
}a[1005];
bool ra(circle a,circle b){//外离：1 内含：0 
	double dis=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
	if(a.r+b.r<=dis) return 1;
	return 0;
}
int main(){
	int n;cin>>n;
	for(int i=1;i<=n;i++) a[i].scan(),a[i].ar();
	for(int i=1;i<=n;i++){
		int fl=1;
		for(int j=1;j<i;j++){//判断每个圆的颜色
			if(!ra(a[i],a[j])) fl++,fl%=2;
		}
		if(fl==0) fl--;
		sum+=fl*a[i].area; 
	}
	printf("%.2Lf",sum);
	return 0;
}
```
但是这样子只能得[36分](https://www.luogu.com.cn/record/113481467)。

哪里不对呢？

这里我们发现此时圆的大小是不确定的，这就导致了部分情况下这么做是不对的。

解决方法也十分简单，只要对所有圆按照半径排序即可。

AC code:
```cpp
#include<bits/stdc++.h>
#define double long double
using namespace std;
double pi=3.14159265358979323846,sum;
struct circle{//用结构体保存圆的信息
	int x,y,r;
	double area;
	bool color;
	void ar(){
		area=pi*r*r;
	}
	void scan(){
		cin>>x>>y>>r;
	}
}a[1005];
bool operator < (circle a,circle b){
	return a.r>b.r;
}
bool ra(circle a,circle b){//外离：1 内含：0 
	double dis=sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
	if(a.r+b.r<=dis) return 1;
	return 0;
}
int main(){
	int n;cin>>n;
	for(int i=1;i<=n;i++) a[i].scan(),a[i].ar();
	sort(a+1,a+1+n);//对圆按照半径排序
	for(int i=1;i<=n;i++){
		int fl=1;
		for(int j=1;j<i;j++){//判断圆的颜色
			if(!ra(a[i],a[j])) fl++,fl%=2;
		}
		if(fl==0) fl--;
		sum+=fl*a[i].area; 
	}
	printf("%.2Lf",sum);
	return 0;
}
```

---

## 作者：Zenith_Yeh (赞：0)

### 前言：
此题要用到判断两圆的位置关系，不会的点[这](https://www.luogu.com.cn/blog/taskkill-SB/pan-duan-liang-yuan-wei-zhi-guan-ji)

### 正文：
因为一块区域最终的颜色是由被覆盖的次数决定的，而不是顺序。所以画圆的顺序可以任意。

然后，对于每一个圆 $a$，找到一个圆 $b$，使圆 $a$ 在圆 $b$ 内部。由于只有黑白两种颜色，所以圆 $a$ 的颜色可以通过圆 $b$ 的颜色推断出并计算出对答案的贡献。时间复杂度 $O(n^2)$，乱搞常数都可以 $($~~不包括非酋~~$)$ 。

**上菜：**
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//快读
{	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c))f|=(c=='-'),c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?-x:x;
}
struct bb
{	int x,y,r,color;//x,y表示坐标，r表示半径，color表示颜色（黑=1，白=-1）。
}op[105];
int n,ans;
inline bool cmp(bb a,bb b)
{	return a.r>b.r;
}
inline bool pd(bb a,bb b)//判断两圆是否相交。
{	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))<a.r+b.r;
}
int main()
{	n=read();
	op[0].color=1,op[0].r=10000,op[0].x=0,op[0].y=0;//整个平面均为黑。
	for(register int i=1;i<=n;++i)op[i].x=read(),op[i].y=read(),op[i].r=read();
	sort(op+1,op+n+1,cmp);
	for(register int i=1;i<=n;++i)
		for(register int j=i-1;j>=0;--j)
		{	if(pd(op[i],op[j]))
			{	op[i].color=-op[j].color;//推断颜色。
				ans+=op[j].color*op[i].r*op[i].r;//计算贡献。
				break;
			}
		}
	printf("%.2f",acos(-1)*ans);
	return 0;
}
```


---


# [TJOI2009] 火星人的手机

## 题目背景

你应火星人之邀为他们设计一款新型的手机。我们知道在标准的地球人手机上，数字键共有 $10$ 个，$26$ 个字母 `a`…`z` 分别与某个数字键相关联，并且一个数字键上的若干字母必须是字母表中连续的一段。比如下图是地球手机的一个标准方案：

![](https://cdn.luogu.com.cn/upload/pic/6103.png)


## 题目描述

我们要输入一个字母，必须连续按它所在的数字键若干次，次数即为这个字母在这个键的第几个位置。例如在上图的方案中，若我们要输入 `C`，就需要按三次数字键 `2`；若要输入 `M`，需按一次数字键 `6`。

火星人手机的构造与地球人手机类似，上面有 $M$ 个火星数字键，你需要把火星文的 $N$ 个字母放置在这 $M$ 个键上。（同样要求一个数字键上必须是连续的若干个火星字母）现在给定一段火星文中各个字母的出现次数，你设计的手机必须使得输入这段文字所需的按键次数最少。


## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$1\le N \le 500$，$1 \le M \le 100$。


## 样例 #1

### 输入

```
3 2
100
200
300
```

### 输出

```
800
2
1
```

# 题解

## 作者：GNAQ (赞：4)

一血补题解

#### DP with 记录前驱

当时的省选前几题好简单……

发现题意模糊不清，结合样例认真理解一下发现是区间划分 DP 。

~~观察数据范围~~ 易得复杂度是 $O(n^2m)$ 级别的。 ~~（不过好像可以上斜率 DP 或者之类的东西优化？~~

先预处理 `val[i][j]` 表示从 $i$ 到 $j$ 划出一个键总共要按多少次。

这是 $O(n^2)$ 的。

```cpp
for (int i=1;i<=n;i++)
     for (int j=i;j<=n;j++)
         vals[i][j]=vals[i][j-1]+seq[j]*(j-i+1);
```

然后直接 DP 。简单区间 DP 常见套路：设 `dp[i][j]` 表示到了字母 $i$ ，划出了 $j$ 个键，然后转移就枚举当前字母所在的键是多大。

`dp[i][j]=min(dp[i][j],dp[pre_pos][j-1]+vals[pre_pos+1][i]);`

然后输出方案的话要记录一下前驱。

细节：可能有 $m>n$ ，根据题意，前面要划出 $m-n$ 个 $0$ 字母键。

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;

int n,m,seq[5010],pre[510][110],mm;
ll vals[510][510],dp[510][110];

template<typename int_t>
void readx(int_t& x)
{
    x=0; int_t k=1; char ch=0;
    while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
    while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
    x*=k;
}

void Output(int now,int grp)
{
    if (grp)
    {
        Output(pre[now][grp],grp-1);
        printf("%d\n",now-pre[now][grp]);
    }
}

int main()
{
    readx(n); readx(m); mm=m; m=min(m,n);
    for (int i=1;i<=n;i++) readx(seq[i]);
    
    // init vals
    for (int i=1;i<=n;i++)
        for (int j=i;j<=n;j++)
            vals[i][j]=vals[i][j-1]+seq[j]*(j-i+1);
    
    for (int i=0;i<=n;i++) for (int j=0;j<=m;j++) dp[i][j]=1e16;
    dp[0][0]=0; 
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=min(i,m);j++)
        {
            for (int k=0;k<=i-1;k++) // the last group
            {
                if (dp[k][j-1]+vals[k+1][i]<dp[i][j])
                {
                    dp[i][j]=dp[k][j-1]+vals[k+1][i];
                    pre[i][j]=k;
                }
            }
        }
    }
    
    printf("%lld\n",dp[n][m]);
    if (mm) for (int i=n+1;i<=mm;i++) printf("0\n");
    Output(n,m);
}
```

---

## 作者：yangwenbin (赞：4)

# 题解 P3860 【[TJOI2009]火星人的手机】

没看过题目的同学请走这里([传送门](https://www.luogu.com.cn/problem/P3860))

~~(啊这)~~

这道题有点坑

首先先分析，不管干什么

认真阅读了题目发现了一些很重要的事这道题就是把一些数分段，分成 m 段。

而这样我们可以类比排列组很问题的隔板法，在第 i 个数的后面放一个板子

所以用 ```dp[i][j]``` 表示再第 i 位后放第 j 块板子。

那么我们怎么得知没两个点之间把他们设为一个按键，在输入时要操作几次？

这就很像是一个前缀和了，即 : 

```cpp
sum[i][j] = sum[i][j-1] + (num[j] * (j - i + 1));

```

这样算的时候就可以直接用了，就很 nice。

然后这样的直接dp

在 i 后面放第 j 个板子,就等于在 看后面放第 j-1 个板子的最小值加从 k+1 到 i 的输入操作组数;

同时要记录前驱 fro 就为 k 。

所以方程就是 ：

```cpp
if (dp[i][j] > dp[k][j-1] + sum[k+1][i])
{
	dp[i][j] = dp[k][j-1] + sum[k+1][i];
	fro[i][j] = k;
}
```
dp时:

先确定在那个点后加板子

在确定放第几个板子

最后确定区间的起点在哪

然后 dp 就很 easy 了


```cpp
dp[0][0] = 0;
for (long long i = 1; i <= n; ++i)
{
	long long minn = min(i,m);
	for (long long j = minn; j >= 1; --j)
	{
		for (long long k = 0; k < i; ++k)
		{
			if (dp[i][j] > dp[k][j-1] + sum[k+1][i])
			{
				dp[i][j] = dp[k][j-1] + sum[k+1][i];
				fro[i][j] = k;
			}
		}
	}
}
```

## 但是

这道题很坑首先它没有强调 n 一定大于 m ；

所以有可能存在板子太多的的情况这就很恶心。

再其次这道题的数据很有可能会爆 int

所以又回到了那句经典名言 （十年OI一场空，不开longlong见祖宗）

# 最后 code time

```cpp
#include <bits/stdc++.h>
using namespace std;

const long long SIZE = 550;
const long long M = 150;

long long n,m,tmp;
long long num[SIZE];
long long sum[SIZE][SIZE],dp[SIZE][M],fro[SIZE][M];
stack < long long > stc;

int main()
{
	scanf("%lld %lld",&n,&m);
	tmp = m;
	m = min(n,m);
	for (long long i = 1; i <= n; ++i)
	{
		scanf("%lld",&num[i]);
	}
	for (long long i = 1; i <= n; ++i)
	{
		for (long long j = i; j <= n; ++j)
		{
			sum[i][j] = sum[i][j-1] + (num[j] * (j - i + 1));
		}
	}
	for (long long i = 0; i <= n; ++i)
	{
		for (long long j = 0; j <= m; ++j)
		{
			dp[i][j] = 1e17;
		}
	}
	dp[0][0] = 0;
	for (long long i = 1; i <= n; ++i)
	{
		long long minn = min(i,m);
		for (long long j = minn; j >= 1; --j)
		{
			for (long long k = 0; k < i; ++k)
			{
				if (dp[i][j] > dp[k][j-1] + sum[k+1][i])
				{
					dp[i][j] = dp[k][j-1] + sum[k+1][i];
					fro[i][j] = k;
				}
			}
		}
	}
	printf("%lld\n",dp[n][m]);
	for (int i = n+1; i <= tmp; ++i)
	{
		printf("0\n");
	}
	long long i = n,j = m;
	stc.push(n);
	while (fro[i][j] != 0)
	{
		stc.push(fro[i][j]);
		i = fro[i][j];
		--j;
	}
	long long nxt = 0;
	while (!stc.empty())
	{
		long long u = stc.top();
		stc.pop();
		printf("%lld\n",u-nxt);
		nxt = u;
	}
	return 0;
}

```

---

## 作者：TDSLDJ (赞：0)

## 题解：P3860[TJOI2009]火星人的手机
### [题目传送门](https://www.luogu.com.cn/problem/P3860)
#### 题目大意：
包括两个数字 $N$ 和 $M$，分别表示火星文字母数和火星手机的按键数。接下来有 $N$ 行，每行包含一个数字，依次表示每个字母在文章中的出现次数。求最少的按键次数和设计方案（为每个键上的字母数）。

如果有多种方案可以得到最少的按键次数，你需要输出第一个数字键上包含字母最少的方案；如果仍有多种方案，你需要在其中选择第二个数字键上字母最少的方案；依此类推。

对于 $100\%$ 的数据，$1\le N \le 500$，$1 \le M \le 100$。
#### 坑点分析：
- **$N$ 不一定大于 $M$。**
- **十年 OI 一场空，不开 long long 见祖宗。**
#### 思路分析：
- ##### 首先，考虑 $N$ 不大于 $M$ 的情况。
容易发现，当 $N$ 不大于 $M$ 时，各个字母单独分占键位可使得答案最小。

而且，**只有在这种情况下才会有 $0$ 的输出。**

直接特判并提交，${\color{red} 40}$ 分到手。
- ##### 更一般的。
我们发现除第一个字母外的每个字母都有两种选择：单开一键或并入前一键。

这样我们就可以暴力搜索了：当字母遍历结束而按键刚好或还没用完时，记录答案，同时记忆路径。最后输出最小答案及可。

配合上剪枝，得到 ${\color{orange} 70}$ 分。
- ##### 正解来了！
通过上面的暴力，我们已经可以发现本题可以用 **DP** 来做。

不同的是，由于复杂度的原因，我们选择**枚举分组的边界**而非字母个数。

具体请看代码注释（温馨提示：本代码不能直接用哦）：

```cpp
#include<iostream>
#define int long long
using namespace std;
int n,m,ck[505],dp[505][105],ans[505][105],qux[505][505];
//依次为 字母数、按键数、各字母出现次数、DP、路径记忆、预处理 
signed main(){
	cin>>n>>m;
	int ta=0;
	for(int i=1;i<=n;i++){
		cin>>ck[i];
		ta+=ck[i];
	} 
	if(n<=m){//特判 
		cout<<ta<<endl;
		for(int i=1;i<=m-n;i++) cout<<0<<endl;
		for(int i=1;i<=n;i++) cout<<1<<endl;
		return 0;
	} 
	for(int i=1;i<=n;i++)//预处理得到从i到j为一组所需的按键次数
		for(int j=i;j<=n;j++)
			qux[i][j]=qux[i][j-1]+ck[j]*(j-i+1);
	for(int i=0;i<=n;i++)//初始化 
		for(int j=0;j<=m;j++)
			dp[i][j]=1e16;
	dp[0][0]=0;
	//dp的第一维是正在处理的字母位数（id），
	//第二维是前id个数的分组数(包含当前正在处理的字母) 
	for(int id=1;id<=n;id++){//枚举位数 
		for(int sum=min(id,m);sum>=1;sum--){//枚举分组数
		//请自己想一想，这里为什么要逆序枚举？ 
			for(int len=0;len<id;len++){//枚举断点位置 
				if(dp[id][sum]>dp[len][sum-1]+qux[len+1][id]){
					dp[id][sum]=dp[len][sum-1]+qux[len+1][id];
					ans[id][sum]=len;//路径记忆 
				}
			}
		}
	}
	cout<<dp[n][m]<<endl;
	int t[105],id=n,sum=m,top=0;
	while(ans[id][sum]){//路径“解压” 
		t[++top]=ans[id][sum];
		id=ans[id][sum];
		sum--;
	}
	int lt=0;
	while(top){
		cout<<t[top]-lt<<endl;
		n-=t[top]-lt;
		lt=t[top];
		top--;
	}
	cout<<n;//千万别忘输出最后一个数！ 
	return 0;
}
```
终于，${\color{green} 100}$ 分！

码字不易，求审核大大高抬贵手 QwQ。

---


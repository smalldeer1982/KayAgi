# [Code+#2] 化学狂暴

## 题目背景

在那遥远的钦钦草原，住着 Yazid 和 YJQQQAQ，他们都是炼金术士。


一般而言，题目背景总是没有用的，但这道题是个例外。在这里，我们将严谨地介绍钦钦草原世界化学学科的一些基本知识。如果你对这些内容感到枯燥乏味，你也可以跳过这个部分，直接阅读题目描述中的简述并结合样例来帮助你更快地理解题目。


钦钦草原的世界里共有 $26$ 种元素，分别用大写字母A至Z表示。


钦钦草原世界中的物质由元素构成，对于任意的物质，每种元素的出现次数都是非负整数，且至少有 $1$ 种物质的出现次数为正整数，我们把每种元素在物质中的出现次数称作该元素在该物质中的下标。我们可以按A到Z的顺序写下每种元素及其下标来描述一个物质。这是一个例子：`A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0`。这个例子描述了一种 J、Q 各出现 $1$ 次，Y 出现 $2$ 次的物质。


然而，这种描述方法实在是太麻烦了，于是钦钦草原世界中的炼金术士们便尝试简化物质的描述。对于某种物质，我们定义“虚无元素”表示在该物质中下标为 $0$ 的元素，“单一元素”表示在该物质中下标为 $1$ 的元素。针对这两个定义，炼金术士们提出了两种化简方式：


省略“虚无元素”：将“虚无元素”的字母和下标省略。如上面的物质可以通过该操作化简为：`J1Q1Y2`。

省略“单一元素”的下标：将“单一元素”的下标省略。如上面的物质可以通过该操作化简为：`A0B0C0D0E0F0G0H0I0JK0L0M0N0O0P0QR0S0T0U0V0W0X0Y2Z0`。


特别地，对于同时省略了“虚无元素”和“单一元素”下标的表示，我们把它叫做该物质的“最简式”。如上面物质的“最简式”即为：`JQY2`。


由于钦钦草原世界的化学研究仍处于起步阶段，因此对于任意的物质，所有元素下标均为不超过 $9$ 的非负整数。


化学方程式是描述化学反应的式子。一个化学方程式包含恰好一个等号（=），等号两边是由加号（+）连接的若干物质。形象地说，它的形式是这样的：

```
物质+物质+…+物质=物质+物质+…+物质
```
除了需要满足上述格式外，元素守恒也是不可忽视的。这表示等号两边所有元素在各物质中的出现次数总和必须相等。比如，这就是一个合法的（格式正确、元素守恒的）化学方程式：

```
JQY2+J2=J3QY2
```
需要特别注意的是，在化学方程式的书写中，未被化至“最简式”的元素也是可以被接受的。例如，下面的化学方程式也是合法的：

```
J1Q1Y2+J2=J3Q1Y2
```
而下面这个化学方程式就不是合法的了，因为它并没有满足元素守恒。

```
JQY2+J2=JQY
```
钦钦草原化学学科的基本知识就介绍到这。祝各位选手武运昌隆！

## 题目描述

所谓化学方程式，即是用加号（+）和等号（=）连接一些化学物质的式子。保证一个化学方程式中含有恰好一个等号（=）。化学物质由一些元素（用大写字母A至Z表示）加上下标（保证下标为不超过 $9$ 的非负整数）连接而成的。例如：`JQY2`、`A0J1QY2` 等。书写时需要保证字典序越小的字母排在越前面。


需要注意的是，像 `A0J1QY2` 这样的物质书写同样是合法的，虽然事实上它和 `JQY2` 是等价的。我们把下标为 $1$ 的元素称为“单一元素”，把下标为 $0$ 的元素称为“虚无元素”。在书写一种物质时，我们既可以省去“单一元素”的下标，又可以直接省去“虚无元素”。特别地，我们把用这两种规则省略至最简的书写称为该物质的“最简式”。例如，`JQY2` 就是 `A0J1Q1Y2` 的最简式。


既然称之为“方程式”，元素守恒就是必须的了。对于一个化学方程式，元素守恒指的是指等号两边所有元素的下标之和相等。比如，这个化学方程式就是元素守恒的：

```
JQY2+J2=J3QY2
```
而这个化学方程式就是不合法的，因为它不满足元素守恒：

```
JQY2+J2=JQY
```
作为一名资深炼金术士，Yazid 自然是整日沉迷在化学狂暴中。某一天，Yazid 写下了 $n$ 个化学方程式，并把它们放在一边，为后续的研究做着准备。


然而，见习炼金术士 YJQQQAQ 不慎打翻了一瓶绿色的试剂，导致 Yazid 写下的所有化学方程式中，都有恰好 $1$ 个物质被绿色液体弄得模糊不清了。


暴怒的 Yazid 狠狠地把 YJQQQAQ 批判了一番，并要求他将所有模糊不清的物质重新写出来。除此之外，作为惩罚，无论原来 Yazid 如何书写这些物质，YJQQQAQ 都必须将它们以“最简式”的形式写出。


如果不能完成这些任务，Yazid 就会把他从钦钦草原放逐。面对这么多的化学方程式，弱小、无助的 YJQQQAQ 手足无措，于是他找到了钦钦草原最擅长编程的你，请你帮他完成任务。

## 说明/提示

|测试点编号|m|?在方程式最左端|等号左边不含+|等号右边不含+|
|:-:|:-:|:-:|:-:|:-:|
|1|0|Yes|Yes|Yes|
|2|1|Yes|Yes|Yes|
|3|2|Yes|Yes|Yes|
|4|3|Yes|Yes|Yes|
|5|0|Yes|Yes||
|6|1|Yes|Yes||
|7|2|Yes|Yes||
|8|3|Yes|Yes||
|9|0|Yes||Yes|
|10|1|Yes||Yes|
|11|2|Yes||Yes|
|12|3|Yes||Yes|
|13|0||||
|14|1||||
|15|2||||
|16|3||||
|17|0||||
|18|1||||
|19|2||||
|20|3|||

如表格中“?在方程式的最左端”为 `Yes`，则表示该测试点保证每个字符串的第一个字符均为?；否则无特殊保证。


如表格中“等号左边不含+”为 `Yes`，则表示该测试点保证等号左边没有加号（+），即等号左边只有一种物质；否则无特殊保证。


如表格中“等号右边不含+”为 `Yes`，则表示该测试点保证等号右边没有加号（+），即等号右边只有一种物质；否则无特殊保证。


对于所有的测试点，保证 $n\leq 100$，保证每个方程式中等式两边的加号+都不超过 $5$ 个，这也意味着每行字符串（每个化学方程式）的长度不超过 $635$。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/王聿中 命题/王聿中 验题/陈宇

Git Repo：[https://git.thusaac.org/publish/CodePlus201712](https://git.thusaac.org/publish/CodePlus201712)

感谢腾讯公司对此次比赛的支持。

感谢 @[ChampionCyan](https://www.luogu.com.cn/user/1036180) 提供了修复后的题面。

## 样例 #1

### 输入

```
3 0
A=?
?=A+B
C+O2=?```

### 输出

```
A
AB
CO2```

## 样例 #2

### 输入

```
3 1
A1=?
A1+?=B1
C1+O2=?```

### 输出

```
A
No Solution
CO2```

## 样例 #3

### 输入

```
1 2
A0B0C0D0E0F0G0H0I0JK0L0M0N0O0P0QR0S0T0U0V0W0X0Y2Z0=?```

### 输出

```
JQY2```

## 样例 #4

### 输入

```
2 3
?=A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0
A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0+A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0=?```

### 输出

```
JQY2
J2Q2Y4```

# 题解

## 作者：wunaidedanjuan (赞：7)

### **简化题意**
 
找到一个 `?` 使字符串左右元素守恒，且 `?` 属于题目背景研究的物质范围内。

### **解题思路**
- 分别统计等号两侧元素出现次数；

- 判断 `?` 在等号哪侧；

- 根据两侧元素出现次数差值判断是否有解，若有解则求出 `?`。
### **思路优化**
- **考虑一个问题，可不可以直接记录等号两侧元素出现次数的差值呢？**

	**当然可以，我们只需要用一个数组统计元素出现的次数，若元素出现在等号左侧则加上相应的次数，否则则减去。**

	**但这样就可能出现下面一个问题：**

	观察这一个方程：$A+?=AB$，

	若用 $a[]$ 数组记录元素出现的次数的话，$a[1]=-1$，表示方程左侧元素 $B$ 出现的次数减去方程右侧元素 $B$ 出现的次数的结果等于 $-1$；

	但当 `?` 在方程右侧时，如：在 $AB=A+?$ 中，$a[1]=1$。

	**该如何解决这个问题呢？**

	我们只需要设置一个变量 $c$ 记录 `?` 所在位置，当 `?` 在等号左侧时，$c$ 值为 $-1$，在右侧时就为 $1$，这样我们查找多余元素即 `?` 时，只需要将 $a[]$ 的值乘上 $c$ 即可。
    
    这样在上述两个方程式中，$a[1]\times c$ 的值就均为 $1$ 了。
    
    $a[i]\times c$ 的值就代表了 `?` 中 $char(i+'A')$ 元素的个数。

- **最后，我们该如何判断无解的情况**
	
   **第一种无解的情况就是方程式本身无解。**
   
   例如：$A+?=B$，这种情况下，我们是无法找到一个 `?` 使方程中元素守恒的，这时 $a[0]\times c$ 的值为 $- 1$，也就是说，这种情况下 $a[]$ 数组中存在 $a[i]\times c$ 的值小于 $0$，所以我们只需要遍历 $a[]$ 数组就可以判断方程式是否无解了。
   
   值得一提的是，这里存在一种特殊情况，即：$A+？=A$，此时的方程式也是无解的，但它 $a[0]\times c$ 的值却不小于 $0$，所以要记得加个特判。
   
   **第二种无解的情况就是 `?` 所代表的物质超出了钦钦草原世界化学学科的研究范围。**
    
    也就是说，`?` 中存在元素下标的数字超过了 $9$，我们也可以通过遍历 $a[]$ 数组判断方程式是否无解。
    
### **思路总结**
- 遍历方程式；
	
    遍历到 $=$ 前，$a[]$ 数组加上元素出现的次数；遍历到 $=$ 后，$a[]$ 数组减去元素出现的次数。
  
- 标记 `?` 出现的位置；

- 判断是否有解，然后输出；

- 重置标记变量和数组。

### **代码呈现**
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<string>
#include<bitset>
#include<cctype>
#include<cstdlib>
#include<functional>
#include<istream>
#include<sstream>
#include<streambuf>
#define ll long long 
using namespace std;
const int N=26;
int a[N];
int main()
{
	int n,m,c;
	string s;
	bool b,d,e;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		b=false;//重置标记变量和数组 
		d=false;
		e=false;
		memset(a,0,sizeof(a));
		cin>>s;
		s[s.length()]='1';//防止越界 
		for(int j=0;j<s.length();j++)
		{
			if(s[j]=='=')//判断是否到达方程右侧 
				b=true;
			else
			{
				if(b==false)
				{
					if(s[j]=='?')// ？在方程左侧 
						c=-1;
					else if(s[j]>='A'&&s[j]<='Z')
					{
						if(s[j+1]>='0'&&s[j+1]<='9')
							a[(int)(s[j]-'A')]+=(int)(s[j+1]-'0');
						else	
							a[(int)(s[j]-'A')]++;
					}
				}
				else
				{
					if(s[j]=='?')// ？在方程右侧 
						c=1;
					else if(s[j]>='A'&&s[j]<='Z')
					{
						if(s[j+1]>='0'&&s[j+1]<='9')
							a[(int)(s[j]-'A')]-=(int)(s[j+1]-'0');
						else	
							a[(int)(s[j]-'A')]--;
					}
				}
			}
		}
		for(int j=0;j<26;j++)//是否无法配平 
			if(a[j]*c<0||a[j]*c>9)
			{
				printf("No Solution");
				d=true;//标记 
				break;
			}
		if(d==false)
		{
			for(int j=0;j<26;j++)//寻找缺失元素 
			{
				if(a[j]*c==1)
				{
					printf("%c",(char)(j+'A'));
					e=true;
				}
				else if(a[j]*c>1)
				{
					printf("%c%d",(char)(j+'A'),a[j]*c);
					e=true;
				}
			}
			if(e==false)//特判，第一种情况中的特殊情况 
				printf("No Solution");
		}
		printf("\n");
	}
    return 0;
}
```

---

## 作者：assassinlike (赞：5)

## 题目内容概述（重述，可忽略）
### 主体框架
一个伪化学方程式形如

$a_1+a_2+...+a_n=b_1+b_2+...+b_m$

$a_i$，$b_j$ 都是由一个或多个大写字母后加数字这样的组合（后文称一个组合）拼凑成的元素，例如 $A1,C4O3$。上述式子中，一个元素被弄脏了，求解出它是什么并输出；不存在则输出 No solution。

### 化简写法
对于每个组合，

$i)$ 后面的数字为 $1$ 则省略 $1$ ；

$ii)$ 后面的数字为 $0$ 则省略该组合；

$m=0,1,2,3$ 时，分别对应满足 $i)ii)$ $,ii)$ $,i)$ 和都不满足。

我们的输出要做到 $m=0$ 的要求。
## 简化和分析
化学式亦是等式，本质上求 $?$ 就是在作差。

$(1)$ 左减右还是右减左？

看 $?$ 和 = 的出现前后关系。

$(2)$ 元素相加无序，参差不齐，怎么有序做差？

可以申请两个空间为 $26$ 的数组，分别表示左侧和右侧的各个字母的出现次数。

这也是本题的难点，次数怎么获取？

设置一个 for 循环，从 $0$ 到 $s.size()-1$ 。处理每一个字符，如果是 + 则忽略，是 $?$ 或者 = 的情况前面提到了，有特判。其他时，设当前处理的字符为 $s[j]$ ，考虑 $s[j+1]$ 。当它是数字时， $s[j]$ 表示的字母对应数组的值加上 $s[j+1]$ 表示数字的值；当它是字母时， $s[j]$ 表示的字母对应数组的值加上 $1$ 。

为了保证每次处理都不会处理到数字，第一种情况不要忘记 $j$++。

$(3)$ 什么时候会 No solution 呢？当且仅当某个字母做差后出现负值。

因此我们不能在线输出，应该把答案存储在一个新的大小为$26$的数组内。$26$个字母全部做差完毕之前，我们无法判断是否一定有解。

### 注
 
事实上，我们完全无需考虑 $m$。只有 $1$ 的省略会产生一定影响，输入时对 $s[j+1]$ 的分类便解决了。

如果你没有声明二维数组，每个字符串的处理过程之间必须清空数组值为 $0$。

## 代码实现
	#include<bits/stdc++.h>
	using namespace std;
	//等号左，等号右，答案，下标从1开始
	int n,m,ll[27],lr[27],ans[27];
	int main(){
	string s;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		//清空
		memset(ll,0,sizeof(ll));
		memset(lr,0,sizeof(lr));
		memset(ans,0,sizeof(ans));
		cin>>s;
		//j+1是有可能越界的，但那也意味着最后一个字符表示的大写字母对应数组值仅需加1。
		s[s.size()]='1';
		bool qs=false,eq=false,flag;
		//flag是true意为?在=的左侧，false反之
		for(int j=0;j<=s.size()-1;j++){
			if(s[j]=='?')qs=true;							
			else if(s[j]=='='){
				eq=true;
				if(qs==true)flag=true;
			}
			else if(s[j]=='+')j=j;
			else if(eq==false){
				//后一个字符可能是 = 或 + ，单纯 s[j+1]<'A' 不行
				if(s[j+1]>='0'&&s[j+1]<='9'){
					//0不用管 j++避免下次处理数字
					if(int(s[j+1])==48)j++;				
					else{
						ll[int(s[j])-64]=int(s[j+1])-48;
						j++;
					}
				}
				else ll[int(s[j])-64]=1;				
			}				
			else{
				if(s[j+1]<'A'&&s[j+1]!='='&&s[j+1]!='+'){
					if(int(s[j+1])==48){
						j+=2;
						break;
					}
					lr[int(s[j])-64]=int(s[j+1])-48;
					j+=2;
				}
				else lr[int(s[j])-64]=1;					
			}
		}
		//输出 当 ? 在左或右侧时，做差的方向改变
		if(flag==true){
			//able==true则无解
			bool able=false;
			for(int j=1;j<=26;j++){
				if(lr[j]<ll[j]){
					cout<<"No solution";
					able=true;
					break;
				}
				else ans[j]=lr[j]-ll[j];	
			}
			if(able==false){
				for(int j=1;j<=26;j++){
					if(ans[j]!=0){
						//保证符合 m=0 的要求
						cout<<char(j+64);
						if(ans[j]!=1)cout<<ans[j];
					}
				}
			}
		}
		//互换 ll,lr
		else{
			bool able=false;
			for(int j=1;j<=26;j++){
				if(ll[j]<lr[j]){
					cout<<"No solution";
					able=true;
					break;
				}
				else ans[j]=ll[j]-lr[j];	
			}
			if(able==false){
				for(int j=1;j<=26;j++){
					if(ans[j]!=0){
						cout<<char(j+64);
						if(ans[j]!=1)cout<<ans[j];
					}
				}
			}
		}
		cout<<endl;				
	}
	return 0;
} 

---

## 作者：Gongyujie123 (赞：4)

## [P4029 [Code+#2] 化学狂暴](https://www.luogu.com.cn/problem/P4029) 题解

这个题题面很**长**，非常考验读题能力。但只要读懂了，做起来还是比较简单的。

### 1. 题意概括

这道题其实就是给出 $n$ 个**缺了一些元素的化学方程式**，让我们**补全**，如果无解，就输出 `No Solution`。

### 2. 思路分析

首先，我们先定义两个数组 $a,b$。其中 $a_i$ 表示 `=` 左边的元素 $i$ 下标的总个数，$b_j$ 表示 `=` 右边的元素 $j$ 下标的总个数。

然后，我们输入化学方程式（$m$ 其实并不重要）。对于每个方程式，遍历方程式的每一个字符，如果是 `?`，就记录下它在等号的左边还是右边。对于每个元素，判断每一个元素的后面是不是数字，如果不是数字，那么表示这个元素是“单一元素”且下标被省略，直接加一即可，否则加上这个元素后的那个数字。

接着，我们分两种情况：   
1. 如果 `?` 在 `=` 的**右**边，`?` 中元素 $i$ 的下标就等于**左减右**，即 $a_i-b_i$，**如果下标为 $1$，要将其下标省略**。

2. 如果 `?` 在 `=` 的**左**边，`?` 中元素 $i$ 的下标就等于**右减左**，即 $b_i-a_i$，**如果下标为 $1$，要将其下标省略**。

最后，我们判断是否无解。当 `?` 中的元素有下标为负数时，无解；当 `?` 表示的物质超出钦钦草原世界化学学科的研究范围时，无解；如果 `?` 没有表示的物质，也无解。对于无解的情况，输出 `No Solution`，否则，输出 `?` 表示的物质。

### 3. AC 代码
[AC 记录](https://www.luogu.com.cn/record/217250043)。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[31], b[31];  // a[i] 用来存储 = 左边的元素 i 下标的总个数，b[i] 用来存储 = 右边的元素 i 下标的总个数
string f(string s, int x){  
	bool l = 1;  // l = 1 表示当前在 = 左边，l = 0 表示当前在 = 右边
	int w = 0;  // w 表示 ? 在 = 哪一边
	for (int i = 0; i < s.size(); i++) {
		if (s[i] <= 'Z' && s[i] >= 'A') {
			if (s[i + 1] >= '0' && s[i + 1] <= '9') {  // 判断元素后有没有下标，如果有下标就元素下标的总个数加上元素后的下标
				if (l) {
					a[s[i] - 'A'] += s[i + 1] - '0';
				} else {
					b[s[i] - 'A'] += s[i + 1] - '0';
				}
			} else {  // 如果没有下标，就代表这个元素的下标省略了，直接加一即可
				if (l) {
					a[s[i] - 'A']++;
				} else {
					b[s[i] - 'A']++;
				}
			}
		}
		if (s[i] == '=') {  // 如果是 =，后面的数就在 = 右边，所以 l = 0
			l = 0;
		}
		if (s[i] == '?') {  // 如果是 ?，存储它在 = 的哪一边
			w = (l ? 1 : 0);
		}
	}
	if (w == 0) {  // 如果 ? 在 = 的右边
		for (int i = 0; i <= 26; i++) {
			if (a[i] < b[i]) return "No Solution";  // 当 = 右边的某个元素大于 = 左边同样的某个元素时，无解！
		}
		string tt = "";
		for (int i = 0; i <= 26; i++) {
			if (a[i] - b[i] > 9) return "No Solution";  // 当 ? 表示的物质超出钦钦草原世界化学学科的研究范围时，也无解
			else if (a[i] - b[i] > 0) {
				tt += (char)(i + 'A');
				if (a[i] - b[i] > 1) {
					tt += (char)(a[i] - b[i] + '0');
				}
			}
		}
		if (tt == "") return "No Solution";  // 如果 ? 没有表示的物质，那么无解
		return tt;
	} else {  // 如果 ? 在 = 的左边
		for (int i = 0; i <= 26; i++) {
			if (a[i] > b[i]) return "No Solution";  // 同上
		}
		string tt = "";
		for (int i = 0; i <= 26; i++) {
			if (b[i] - a[i] > 9) return "No Solution";
			else if (b[i] - a[i] > 0) {
				tt += (char)(i + 'A');
				if (b[i] - a[i] > 1) {
					tt += (char)(b[i] - a[i] + '0');
				}
			}
		}
		if (tt == "") return "No Solution";
		return tt;
	}
}
signed main(){
	int n, m;
	cin >> n >> m;
	while (n--) {
		memset(a, 0, sizeof(a));  // 初始化
		memset(b, 0, sizeof(b));
		string s;
		cin >> s;
		cout << f(s, m) << endl;
	}
	return 0;
}
```

---

## 作者：书雪 (赞：3)

这道题是一道纯模拟题，考验了读题能力和代码能力，但其实和初中的化学及其相似（本人刚好学到那里），有一些细节需要注意一下，但总的来说较易看懂。

~~让我们大声的背一遍：化学式两边元素符号相同，原子个数相等~~

存三个数组，两个用来计等式两边的数，一个用来记前两个数组相减的值

~~由于并不需要化成最简比，连最大公因数这步也省去了~~

我还是觉得将注释插在代码中间更易理解些，所以代码前面就不过多的写注意点了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string qaq;
int n,m,a[27][2],b[27];
int main(){
	scanf("%d%d",&n,&m);
	for(int W=1;W<=n;W++){
		memset(a,0,sizeof(a));
		cin>>qaq;//读入
		int e=0,qwq,eee=0;
		int l=qaq.length();
		for(int i=0;i<l;i++){
			if(qaq[i]=='=') {
				e=1;//判断此时处于等式哪一边
				continue;
			}
			if(qaq[i]=='+') continue;
			if(qaq[i]=='?'){//判断需要填补的化学式在等式的哪一边
				if(e==0) qwq=0;
				if(e==1) qwq=1;
			}
			if(qaq[i]>='A'&&qaq[i]<='Z'&&m!=0&&m!=2){//元素符号
				if(i+2<l&&qaq[i+2]<='9'&&qaq[i+2]>='0'&&qaq[i+1]<='9'&&qaq[i+1]>='0'){
					eee=1;//如果给出的化学式元素下标超过9就果断break
					break;
				}
				if(qaq[i+1]=='+'||qaq[i+1]=='='||i==l-1){
					a[qaq[i]-64][e]++;//如果下一个字符不是数字，代表这种原子只有一个
				}
				else a[qaq[i]-64][e]=a[qaq[i]-64][e]+qaq[i+1]-48,
				
				
				i++;//否则加上这种原子的个数，并且记得跳过下一个
				
			}
			if(qaq[i]>='A'&&qaq[i]<='Z'&&m!=1&&m!=3){
				if(i+2<l&&qaq[i+2]<='9'&&qaq[i+2]>='0'&&qaq[i+1]<='9'&&qaq[i+1]>='0'){
					eee=1;
					break;
				}
				if(qaq[i+1]<='Z'&&qaq[i+1]>='A'){
					a[qaq[i]-64][e]++;
				}
				else if(qaq[i+1]=='+'||qaq[i+1]=='='||i==l-1){
					a[qaq[i]-64][e]++;
				}
				else{
					a[qaq[i]-64][e]=a[qaq[i]-64][e]+qaq[i+1]-48;
				}
			}
		}
		if(eee==1){
			printf("No Solution\n");//如果元素下标超过9，说明不符合要求
			continue;
		}
		for(int i=1;i<=26;i++){
			b[i]=a[i][0]-a[i][1];//计算相减的值
		}
		int p=0,hh=0;
		if(qwq==0){//需要求的化学式在等号左边
			for(int i=1;i<=26;i++){
				if(b[i]>0) {
					p=1;//因为需要求的化学式在左边，所以当左边某一元素的原子数大于右边的时，无解
					break;
				}
				if(b[i]==0) hh++;//每当元素的原子个数为0时++
				b[i]=abs(b[i]);
				if(b[i]>=10){
					eee=1;//所求的化学式某一元素的原子个数超过9
					break;
				}
			}
			if(eee==1){
				printf("No Solution\n");
				continue;
			}
			if(hh==26) p=1;//如果都为0，则化学式不存在，同样无解
			if(p==1){
				printf("No Solution\n");
				continue;
			}
			for(int i=1;i<=26;i++){
				if(b[i]!=0){
					char owo=i+64;
					printf("%c",owo);
				}
				if(b[i]>1){
					printf("%d",b[i]);
				}
			}
		}
		if(qwq==1){
			for(int i=1;i<=26;i++){
				if(b[i]<0) {
					p=1;//因为需要求的化学式在右边，所以当左边某一元素的原子数小于右边的时，无解
					break;
				}
				if(b[i]==0) hh++;//所求的化学式某一元素的原子个数超过9
				b[i]=abs(b[i]);
				if(b[i]>=10) {
					eee=1;//所求的化学式某一元素的原子个数超过9
					break;
				}
			}
			if(eee==1){
				printf("No Solution\n");
				continue;
			}
			if(hh==26) p=1;//如果都为0，则化学式不存在，同样无解
			if(p==1){
				printf("No Solution\n");
				continue;
			}
			for(int i=1;i<=26;i++){
				if(b[i]!=0){
					char owo=i+64;
					printf("%c",owo);
				}
				if(b[i]>1){
					printf("%d",b[i]);
				}
			}
		}
		printf("\n");
	}
	return 0;
}

```


---

## 作者：liuyuhan1522 (赞：2)

# 题解：P4029 [Code+#2] 化学狂暴

![](https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%99%AE%E5%8F%8A+/%E6%8F%90%E9%AB%98-green)  

[最优解记录](https://www.luogu.com.cn/record/202048807) || [传送门](/problem/P4029)

---

## 思路：模拟

使用一个字符型变量在线处理。

* 读到字母时，判断这个物质有几个这种元素，并记录。
* 读到 `+` 或 `=` 时，结算一个物质。
* 读到 `?` 时，记录 `?` 出现的位置，即 `?` 在 `=` 的左边还是右边。

最后统计 `=` 左右两边各个元素数量和，并作差，算出 `?` 代表的物质。

---

## 坑点
* [$35$ 分](https://www.luogu.com.cn/record/202036241)：有元素个数超过 $10$ 视为 `No Solution`。
* [$75$ 分](https://www.luogu.com.cn/record/202037384)：`?` 处为空视为 `No Solution`。



## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;


inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

inline void add(short a[], short b[]) {				// 遍历每个元素
	for(int i=0; i<27; i++) {						// 求和
		a[i] += b[i];
	}
}

int n, m;					// 见题目（m 其实没用）
char a;						// 在线处理变量 
  
short element_left[27];		// 等号左边各个元素数量和
short element_right[27];	// 等号右边各个元素数量和
  
  		    /*最多6个*/
short element  [6]   [27];	// 每个物质的各个元素数量
bool equals_f;				// 等号是否出现
bool ques_mark;				// 问号是否在等号右边
short cnt;					// 用于计数：等号一边的物质数


int main() {
	n = read(), m = read();
	

	for(int i=1; i<=n; i++) {
re :
		memset(element, 0, sizeof(element));
		memset(element_left, 0, sizeof(element_left));
		memset(element_right, 0, sizeof(element_right));
		
		equals_f = 0;

cnt = 0;
		a = getchar();
		while(a != '\n') {
			if(a == '?') {
				ques_mark = equals_f;
				a = getchar();
			}
			else if(a == '=') {
                equals_f = 1;							// 等号已出现
                for(int k=0; k<=cnt; k++) {				// 遍历
                   add(element_left, element[k]);		// 求等号左边各个元素数量和
                }
    
                memset(element, 0, sizeof(element));     // 后面要存等号右边各个元素数量和

                cnt = 0;
                a = getchar();
            }
            else if(a == '+') {
                cnt ++ ;
                a = getchar();
            }
			else if(a >= 'A' && a <= 'Z') {
				char b = getchar();
				
				if(b >= '0' && b <= '9') {
					element[cnt][a - 'A'] += b - '0';
					a = getchar();
				}
				else {
					element[cnt][a - 'A'] ++ ;			// 不是数字，即该元素仅有一个
					a = b;								// 这时后面字符还有用
				}
			}
		}
		for(int k=0; k<=cnt; k++) {
			add(element_right, element[k]);
		}
		
		if(ques_mark) {
			for(int j=0; j<27; j++) {
				element[0][j] = element_left[j] - element_right[j];
				if(element[0][j] < 0 || element[0][j] > 9) {
					cout<< "No Solution\n" ;
					i ++ ;
					if(i > n) {
						return 0;
					}
					goto re;
				}
			}
		}
		else {
			for(int j=0; j<27; j++) {
				element[0][j] = element_right[j] - element_left[j];
				if(element[0][j] < 0 || element[0][j] > 9) {
					cout<< "No Solution\n" ;
					i ++ ;
					if(i > n) {
						return 0;
					}
					goto re;
				}
			}
		}
		
		bool f = 0;
		for(int j=0; j<27; j++) {
			if(element[0][j] == 1) {
				cout<< char('A' + j) ;
				f = 1;
			}
			else if(element[0][j] > 1) {
				cout<< char('A' + j) << element[0][j] ;
				f = 1;
			}
		}
		if(f == 0) {													// 特判：问号处为空（不加 -> 75 分）
			cout<< "No Solution\n" ;
			i ++ ;
			if(i > n) {
				return 0;
			}
			goto re;
		}
		
		cout<< '\n';
	}
	
	return 0; 
}
```

求通过。

---

## 作者：eoinlee (赞：2)

## 题外话

作为高一新生，给方程式配平有时候是一件很痛苦的事情（谁叫我们化学老师用了三四节课的时间来练习氧还的配平，还出了一些极其变态的题目）。所以，本着**有难同当**的中华传统美德，机房的几位神犇原本想要拿化学方程式配平出一道大模拟的。但是吧，难道就只有我们几个人会想到这个 idea 吗？于是我们就找到了万能的洛谷准备查重，这一查还真查到了，虽然没有我们预期的大模拟的体量那么大，但是用来练练手还是可以的。

还有，现在已经是 3202 年了，P9000 都有了，为什么这 P4029 的题解通道还开着……

## 题内话

以下题解内容需要不低于九年级上学期水平的化学知识储备。不过，不就是一堆字母加来加去嘛，所以多看看题目背景应该也很好理解。

## 细节

题目背景已经说明，首先，所有元素都是用单个大写字母表示，省去了很多工作量，且说明最多只有 $26$ 种元素；其次，输入的化学方程式有以下三种形式（为方便表达，这里规定，物质中不出现的元素的化学计量数为 $0$）：

- 对应 $m = 3$，写出物质中所有元素及其化学计量数，包括 $0$，且化学计量数为 $1$ 的元素要写出化学计量数；
- 对应 $m = 2$，写出物质中所有元素及其化学计量数，包括 $0$，但化学计量数为 $1$ 的元素不写出化学计量数；
- 对应 $m = 1$，写出物质中所有化学计量数非 $0$ 的元素及其化学计量数，且化学计量数为 $1$ 的元素要写出化学计量数；
- 对应 $m = 0$，写出物质中所有化学计量数非 $0$ 的元素及其化学计量数，但化学计量数为 $1$ 的元素不写出化学计量数。

但其实 $m$ 在程序中的用处不大，除非你主观上只想取得部分分，或者想针对每一种情况都写一大段代码来分类讨论（虽然完全没有必要）。因为，无论在哪种形式下，对于不出现的元素，由于其化学计量数为 $0$，且数组初始化时赋值也为 $0$，就可以完全不需要考虑了；同理，对于任何化学计量数为 $1$ 的元素，在 $m = 3$ 和 $m = 1$ 的情况下，其化学计量数的呈现方式与其他元素相同，也可以免于考虑；而在 $m = 2$ 和 $m = 0$ 的情况下，只需要特判一下，检查下一位是否是数字即可。上述四个条件在代码实现上完全不冲突，所以 $m$ 其实是没有必要的。（不过，在 IOI 赛制下，若数据点是有顺序的，$m$ 的值应该有助于根据哪些测试点 WA 来分析错在哪里。）

接下来还是分类讲讲，在遍历整个字符串时具体需要的操作：

| 情况         | 处理方式                                                     |
| ------------ | ------------------------------------------------------------ |
| 遇到问号     | 保存一下问号是在等号左边还是右边。如果在左边，那么问号代表的物质就是右边的所有元素减去左边的所有元素的结果，反之亦然。 |
| 遇到等号     | 标记一下已经找到了等号，方便遇到问号时进行判断。如果遇到问号时还没有遇到等号，说明问号在等号左边，反之亦然。 |
| 遇到加号     | 没用，可以直接跳过。                                         |
| 遇到大写字母 | 判断一下后面一位是不是数字，如果是数字，就将其作为化学计量数加到对应的桶（也就是用来存等号的某一边已经出现了什么元素、各多少次的数组）中；如果是大写字母，说明化学计量数为 1，加到对应的桶。由于数字不超过 9，不用考虑多位数的情况。 |
| 遇到数字     | 可以直接跳过，因为数字已经在遇到大写字母的处理过程中处理掉了。 |

接下来就是本题的最大思维难点了！如何判断无解呢？题目里说的比较模糊：`?` 表示的物质超出钦钦草原世界化学学科的研究范围。究竟什么算是超出研究范围呢？回顾题面，可以找到：

> 由于钦钦草原世界的化学研究仍处于起步阶段，因此对于任意的物质，所有元素下标均为不超过 $9$ 的非负整数。

也就是说：如果计算出来 `?` 代表的物质中，存在至少一个化学计量数大于 $9$ 或小于 $0$ 的元素，就说明无解。

> 钦钦草原世界中的物质由元素构成，对于任意的物质，每种元素的出现次数都是非负整数，且至少有 $1$ 种物质的出现次数为正整数。

也就是说：如果 `?` 代表的物质中所有元素的化学计量数均为 $0$，就说明无解。

## 代码

``` cpp
#include "bits/stdc++.h"
using namespace std;

int n, m, cnt[26][2], ans[26];
// cnt[x][0]表示字母为(x+'A')的元素在等号左边的出现次数
// cnt[x][1]表示字母为(x+'A')的元素在等号右边的出现次数
// ans[x]表示问号代表的物质中各元素的化学计量数
string s;

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n >> m;
    while (n--) {
        memset(cnt, 0, sizeof cnt);
        memset(ans, 0, sizeof ans); // 多测清空
        cin >> s;
        int len = s.size();
        bool equality = false; // 是否已经找到等号
        int question_mark = 0; // 问号的位置，1表示等号左边，2表示等号右边
        for (int i = 0; i < len; i++) {
            char now = s[i];
            char nxt = s[i + 1];
            if (isdigit(now)) {
                continue;
            } else if (now == '+') {
                continue;
            } else if (now == '?') {
                if (!equality) question_mark = 1;
                else question_mark = 2;
            } else if (now == '=') {
                equality = true;
            } else if (isalpha(now)) {
                if (!equality) { // 等号左边
                    int order_of_element = now - 'A'; // 取得元素对应的数组下标
                    int chemical_number = 1; // 化学计量数初始化为1
                    if (isdigit(nxt))
                        chemical_number = nxt - '0'; // 如果字母跟了数字就当成化学计量数
                    cnt[order_of_element][0] += chemical_number;
                } else { // 等号右边同理
                    int order_of_element = now - 'A';
                    int chemical_number = 1;
                    if (isdigit(nxt))
                        chemical_number = nxt - '0';
                    cnt[order_of_element][1] += chemical_number;
                }
            }
        }
        if (question_mark == 1) { // 问号在左边
            for (int i = 0; i < 26; i++)
                ans[i] = cnt[i][1] - cnt[i][0]; // 说明右边元素及其数量更多
        } else if (question_mark == 2) { // 问号在右边
            for (int i = 0; i < 26; i++)
                ans[i] = cnt[i][0] - cnt[i][1]; // 说明左边元素及其数量更多
        }
        bool valid = true;
        int empty_cnt = 0;
        for (int i = 0; i < 26; i++) {
            if (ans[i] < 0) valid = false;
            if (ans[i] > 9) valid = false;
            if (ans[i] == 0) empty_cnt++; // 判断有多少个化学计量数为0的元素，用于判断无解情况
            if (!valid) break;
        }
        if (!valid || empty_cnt == 26)
            cout << "No Solution" << endl;
        else {
            for (int i = 0; i < 26; i++) { // 按最简形式输出
                if (ans[i] == 0) continue;
                if (ans[i] == 1) cout << (char) (i + 'A');
                if (ans[i] >= 2) cout << (char) (i + 'A') << ans[i];
            }
            cout << endl;
        }
    }
    return 0;
}
```


---

## 作者：天南星魔芋 (赞：2)

~~这道题如果思路清晰写起来并不麻烦~~


------------

我们看题：

* 同时省略了“虚无元素”和“单一元素”下标表示。
* 元素守恒也是不可忽视的。

不就是初中化学的化学式简化版吗？

那么思路就自然是：

* 统计化学式两边元素个数。
* 判断 $？$ 所在位置。
* 计算 $？$ 普通式，并判断是否合法。
* 输出。

看代码吧。

主体：

```cpp
int n,m;
char hxs[700];
int main(){
	cin>>n>>m;//输入数据个数，格式 
	gets(hxs);//用gets清空缓存区中换行符，否则会影响读入
	for(int i=1;i<=n;i++){
		read();//读入+处理 
		((pd()&&printf("No Solution\n"))||sc());//pd()是判断
		//      若判断为真则不合法       否则正常输出 
		//      输出  No Solution
	}
}
```


读入处理：


```cpp
char hxs[700];//输入化学式 
int a[30],b[30];// = 两边元素计数 
int fx;//判断 ？ 所在位置 
int zz;//指针，指向当前元素 
void read(){
	memset(hxs,0,sizeof(hxs));//初始化 
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	
	gets(hxs);//读入 
	
	int hzz=0  ,  x=0  ,  tp=0;
  //化学式指针，元素个数，特判（是否省略了“单一元素”下标） 
  
	while(hxs[hzz]!='='){//若此时在 = 号前 
		if(hxs[hzz]=='?')fx=0;//先判断 ？ 在那一边 
		else if(hxs[hzz]=='+');//若是 + 号 不用管他 
		else if(hxs[hzz]>='A'&&hxs[hzz]<='Z')
			a[zz]+=tp+x,zz=hxs[hzz]-'A'+1,tp=1,x=0;
		//每个读入新元素时 将当前元素结算 计算新元素 （新元素默认为省略了“单一元素”下标） 
		else if(isdigit(hxs[hzz]))x=x*10+hxs[hzz]-'0',tp=0;
		//若是数字 将数字计入计数器 x 并且  该元素肯定没有省略了“单一元素”下标（有下标）
		hzz++;//指针指向下一位 
	}
	a[zz]+=tp+x,tp=0,x=0;//读完时记得结算并清零 
	
	
	hzz++;//越过 = 号 
	
	
	while(hxs[hzz]){//直接拷贝上边的，改终止条件，改 
		if(hxs[hzz]=='?')fx=1;
		else if(hxs[hzz]=='+')b[zz]+=x+tp,x=0,tp=0;
		else if(hxs[hzz]>='A'&&hxs[hzz]<='Z')b[zz]+=tp+x,zz=hxs[hzz]-'A'+1,tp=1,x=0;
		else if(isdigit(hxs[hzz]))x=x*10+hxs[hzz]-'0',tp=0;
		hzz++;
	}
	b[zz]+=tp+x,tp=0;
}
```

两边相减并判断：


```cpp
int pd(){
	int jg=0,IOI=1;
	for(int i=1;i<=26;i++){
		
		a[i]=fx?(a[i]-b[i]):(b[i]-a[i]);
		//通过 ？ 位置来判断谁减谁 
		((a[i]<0||a[i]>9)&&(jg=1));
		//若不再范围 0~9 内， 返回值为真 
		IOI=a[i]? 0:IOI;
		//若一直为 0 ， 返回值为真 
	}
	return (jg||IOI);
}
```
输出：

```cpp
int sc(){
	for(int i=1;i<=26;i++){
		(a[i]&&printf("%c",i+'A'-1));//不为 0 输出字母 
		((a[i]>1)&&printf("%d",a[i]));//大于 1 输出数字 
	}
	printf("\n");
	return 1;
}
```


[完整代码](https://www.luogu.com.cn/paste/mr59wifr)



------------


这篇题解就到这里了，~~终于写完了~~，如有不足请指出。






---

## 作者：jiezecheng (赞：1)

## python+正则表达式做法
> ‌正则表达式是一种用于匹配、操作文本的**强大工具**，由普通字符和特殊字符（元字符）组成，其核心功能是通过定义特定模式来高效处理字符串，几乎所有主流编程语言都支持正则表达式。——百度百科

使用正则表达式前需要导入 `re` 模块（regex的缩写）使用其中的函数前都需要有 `re.` 。

先需要理解正则表达式：
1. `[A-Z]` 表示匹配任意大写字母；
2.  `\d` 表示匹配数字；
3.  `*` 表示匹配前面的元素‌零次或多次；
4.  用圆括号 `()` 括起来的会匹配为一个分组。

理解了之后钦钦草原上的化学元素可以匹配为 `([A-Z])(\d*)`，即匹配一个大写字母，后面跟着任意数量的数字，这也就是字符串 `pattern` 。

接下来是如何使用正则表达式：
1. 创建的正则表达式在 `pattern` ，待匹配字符串定义为 `s`；
2. `re.findall(pattern,s)` 查找 `s` 中所有匹配 `pattern` 的子串‌，并以‌列表‌形式返回结果。

比如我们现在有如下代码：

```python
import re
def parse_simplified_material(material_str):
    pattern = r'([A-Z])(\d*)'
    matches = re.findall(pattern, material_str)
    print(matches)

parse_simplified_material("A1B2CD3Y")
    
```
将会输出：

```python
[('A', '1'), ('B', '2'), ('C', ''), ('D', '3'), ('Y', '')]
```
可以把每个物质的元素列表存入一个字典中，最终，完整的读入初始化函数代码如下：

```python
def parse_simplified_material(material_str):
    # 正则表达式匹配元素及其下标（下标可选，默认为1）
    pattern = r'([A-Z])(\d*)'
    matches = re.findall(pattern, material_str)
    
    elements = {}
    for elem, count in matches:
        if count == '':
            elements[elem] = 1
        else:
            elements[elem] = int(count)
    
    # 补全缺失元素为0
    all_elements = {chr(ord('A') + i): 0 for i in range(26)}
    all_elements.update(elements)
    
    return all_elements

```

剩下部分就简单多了，记录化学方程式中 `=` 与 `?` 的位置，`=` 左边的元素出现次数和存进字典 `left` 中，`=` 右边的元素出现次数和存进字典 `right` 中。

记 `?` 代表的物质的元素出现次数为 `ans` 字典。

判断 `?` 相对 `=` 的位置：
-  `?` 在 `=` 左边的话，则 `ans` 的第 $i$ 位为 `right` 的第 $i$ 为减去 `left` 的第 $i$ 位；
-  `?` 在 `=` 右边的话，则 `ans` 的第 $i$ 位为 `left` 的第 $i$ 为减去 `right` 的第 $i$ 位。

所以最后检查 `ans` 有数小于 $0$ 或所有数都等于 $0$ 都不行（我为此 [WA 了一发](https://www.luogu.com.cn/record/216420274)）。

按照最简格式输出就好了。
代码：

```python
import re
def parse_simplified_material(material_str):
    # 正则表达式匹配元素及其下标（下标可选，默认为1）
    pattern = r'([A-Z])(\d*)'
    matches = re.findall(pattern, material_str)
    
    elements = {}
    for elem, count in matches:
        if count == '':
            elements[elem] = 1
        else:
            elements[elem] = int(count)
    
    # 补全缺失元素为0
    all_elements = {chr(ord('A') + i): 0 for i in range(26)}
    all_elements.update(elements)
    
    return all_elements

n,m=map(int,input().split())
alphabet="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
for T in range(n):
    matterlist=[]
    mlist=[]
    matterlist.clear()
    mlist.clear()
    equation=input()
    temp=""
    posofw=0
    posofe=0
    for i in equation:
        if(i=='+'):
            matterlist.append(temp)
            temp=""
            continue
        if(i=='?'):
            posofw=len(matterlist)
            matterlist.append(temp)
            temp=""
            continue
        if(i=='='):
            posofe=len(matterlist)
            matterlist.append(temp)
            temp=""
            continue
        temp+=i
    if(temp!=""):
        matterlist.append(temp)
    for i in range (0,len(matterlist)):
        #print(matterlist[i])
        mlist.append(parse_simplified_material(matterlist[i]))
        #if(i==posofe):
        #    print("pos of =")
        #if(i==posofw):
        #    print("pos of ?")
    left={'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}
    for i in range(0,posofe+1):
        #print(mlist[i])
        for j in alphabet:
            left[j]+=mlist[i][j]

    #print(left)
    #print("equal to")
    right={'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}
    for i in range(posofe+1,len(mlist)):
        #print(mlist[i])
        for j in alphabet:
            right[j]+=mlist[i][j]
    #print(right)
    ans={'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0, 'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0, 'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0, 'W': 0, 'X': 0, 'Y': 0, 'Z': 0}
    if(posofw<posofe):
        for j in alphabet:
            ans[j]=right[j]-left[j]
    else:
        for j in alphabet:
            ans[j]=left[j]-right[j]
    #print("---ans----")
    #print(ans)
    flag=False
    Sum=0
    for i in alphabet:
        Sum+=ans[i]
        if(ans[i]<0 or ans[i]>=10):
            flag=True
    if(flag or Sum==0):
        print("No Solution")
        continue
    for i in alphabet:
        if(ans[i]==0):
            continue
        print(i,end="")
        if(ans[i]!=1):
            print(ans[i],end="")
    print()
```

[提交记录](https://www.luogu.com.cn/record/216831836)

python 本来就很慢了，但是正则表达式也很慢，这让我拿下 $664\text{ ms}$ 的好成绩，截至 2025.5.11 日 16:10 时 ，位列最优解**倒数第一** ！

---

## 作者：ClV_Csy (赞：1)

# P4029 [Code+#2] 化学狂暴
## 题意
给出有空缺的化学式，求出空缺的分子式。
## 备注
1. $m$ 是干扰项，**没有用处**。
2. 看 `?` 所在的位置。当 `?` 在 `=` 右边时，设置 $c \gets 1$，否则 $c \gets -1$。这时候再把统计好的每个元素次数都乘上 $c$ 就可以了。
3. `?` 所表示的物质需要化为“最简式”。即：每个元素若下标为 $0$ 则省略这个**元素**，若下标为 $1$ 则省略这个**下标**。
4. 每个子问题完成后需要把每个元素的统计次数归 $0$。
5. [35pts](https://www.luogu.com.cn/record/210905111) 改进方案：有某元素次数大于 $9$ 视为 `No Solution`。
6. [75pts](https://www.luogu.com.cn/record/210908991) 改进方案：所有元素次数都为 $0$ 视为 `No Solution`。
## 思路
基础思路是：  
先统计等号左边已知的分子式中每个元素（`A` ~ `Z`）出现的次数，元素出现一次，相应的统计次数就**增加** $1$。  
再统计等号右边已知的分子式中每个元素出现的次数，元素出现一次，相应的统计次数就**减少** $1$。  
这个方法的本质是等式左边减右边，但当 `?` 出现在 `=` 左边时就可能在有解的情况下出现负数（如 `A+?=AB`）。如何解决呢？解决方法请转到本文的**备注 2**。  
最后输出 `?` 所代表的分子式。以下三种情况是无解的，其他情况都有解，直接按顺序输出每个元素对应的次数即可。有小细节需要注意，可转至本文的**备注 3**。
- 有某元素次数小于 $0$（如 `A+?=B`）；
- 有某元素次数大于 $9$（如 `A9+A8=?`）；
- 所有元素次数都为 $0$（如 `A+?=A`）。

## 代码

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int cnt[30] = {};
void add(string t, bool c) { //c表示该分子式是否在等号左边
	int q;
	if (c == 1) {
		q = 1;
	} else {
		q = -1;
	}
	for (int i = 0; i < t.size(); i++) {
		if (t[i] >= 'A' && t[i] <= 'Z') {
			char p = t[i + 1];
			if (p >= '0' && p <= '9') {
				cnt[t[i] - 'A' + 1] += (p - '0') * q; //次数增加下标所表示的数（或减小）
			} else {
				cnt[t[i] - 'A' + 1] += 1 * q; //次数增加1（或减小）
			}
		}
	}
}
void solve(string s) {
	int idx_deng = s.find('=');
	int idx_wen = s.find('?');
	int p = 1;
	if (idx_deng > idx_wen) {
		p = -1;
	}
	string t;
	s += "+";
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '+' || s[i] == '=') {
			add(t, i <= idx_deng);
			t = "";
		} else if (s[i] == '?') {
			continue;
		} else {
			t += s[i];
		}
	}
	for (int i = 1; i <= 26; i++) {
		cnt[i] *= p;
		if (cnt[i] < 0 || cnt[i] > 9) { //次数小于0或大于9
			cout << "No Solution\n";
			return;
		}
	}
	bool f = 0; //是否所有元素次数都为0
	for (int i = 1; i <= 26; i++) {
		if (cnt[i] > 0) { //次数为0是省略元素
			f = 1;
			cout << char('A' + i - 1);
			if (cnt[i] != 1) { //次数为1时省略次数
				cout << cnt[i];
			}
		}
	}
	if (!f) {
		cout << "No Solution";
	}
	cout << "\n";
}
int main() {
	int n, m;
	cin >> n >> m;
	while (n--) {
		string s;
		cin >> s;
		solve(s);
		memset(cnt, 0, sizeof(cnt)); //次数归零
	}
	return 0;
}
```

---

## 作者：B_Qu1e7 (赞：1)

观察了一下，**m其实是迷惑人的一个东西**，只不过让你乱一点，写不出来而已。其实这道题是非常简单的。

有两点要注意：
```txt
35分的同学：元素下标超过10请视为No Solution
75分的同学：?为空请视为No Solution
举个例子
A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0+?=JQY2
则此时左边的长物质=右边的物质
此时“消元”后 ?=空
请输出No Solution
```
```cpp
#include<bits/stdc++.h>
using namespace std;
struct mtr{
    int qnty[27];
    void clear(){for(int i=1;i<27;i++)qnty[i]=0;}
}lft,rgt,tmp;//3*结构体，等号左右的所有物质之和 和临时物质
int n,cnt=0;string s;
void _plus(mtr &m1,mtr m2){for(int i=1;i<27;i++)m1.qnty[i]+=m2.qnty[i];}//物质相加
int _minus(mtr &m1,mtr m2)//左右相减
{
    int how=0;
    for(int i=1;i<27;i++)
    {
        m1.qnty[i]-=m2.qnty[i];
        if(m1.qnty[i]<0||m1.qnty[i]>9)return -1;//物质相减如果是负数(B-A=A-1B1)则无解(如样例2)
        if(m1.qnty[i]!=0)how=i;
    }
    //how:记录当前物质是否都为空
    if(!how)return -1;//都为空
    else return how;
}
int get_mtr(int add,int lr)//识别并处理物质
{
	//add是当前物质起始位置，lr是当前物质在左还是右(左0右1
    //也就是这个物质该加到左边还是右边的物质总和
    if(s[add]=='?')return add+1;//起始是?则跳过，返回下一物质起始位置
    int i;
    for(i=add;i<s.size();i++)
    {
        if(s[i]=='='||s[i]=='+')break;
        //↑非物质判断
        if(s[i+1]=='0'){i++;continue;}
        //下标0不管
        if(isdigit(s[i+1]))//带有下标的元素
        {
            tmp.qnty[s[i]-64]=s[i+1]-48;
            i++;
        }
        else //不带有下标(即下标为1)
        {
            tmp.qnty[s[i]-64]=1;
        }
        //这样，不论m=0,1,2,3都能很好地识别出来
        //管他怎么书写，最后是最简式
    }
    _plus((!lr?lft:rgt),tmp);//将当前物质加至指定位置
    tmp.clear();//清除当前物质
    return i;//返回下一个物质起始位置
}
void print(mtr mt)//输出?代表的物质
{
    int flg=0;
    for(int i=1;i<27;i++)
    {
        if(mt.qnty[i])
        {
            cout<<(char)(i+64);
            if(mt.qnty[i]>1)cout<<mt.qnty[i];
        }
    }
    cout<<endl;
}
void parse()//处理式子
{
    int add,now=-1,tsk=-1;
    for(int i=0;i<s.size();i++)
    {
        if(s[i]=='=')add=i;//找到=
    }
    for(int i=0;i<add;i++)if(s[i]=='?')tsk=0;
    if(tsk)tsk=1;
    //tsk: ?在左还是右
    while(s[now]!='=')now=get_mtr(now+1,0);
    //处理左
    while(now<s.size())now=get_mtr(now+1,1);
    //处理右
    if(!tsk)tmp=rgt,rgt=lft,lft=tmp,tmp.clear();
    //?在左，则交换左右，尽量保证右>左
    int chk=_minus(lft,rgt);//相减
    if(chk==-1)
    {
        cout<<"No Solution\n";
    }
    else
    {
        print(lft);
    }
}
int main()
{
    lft.clear();rgt.clear();tmp.clear();
    scanf("%d%*d",&n);
    //m跳掉，不读
    while(n--)
    {
        cin>>s;
        parse();lft.clear();rgt.clear();tmp.clear();
    }
}
```

---

## 作者：Sqrt_tyz (赞：1)

这是官方的题解，本蒟蒻就在此贴出来吧。

## 物质的读入方法

下面的各伪代码适配了对于不同的$m$读入一种物质的方法。对于每一段伪代码，它结束的时候字符变量ch中将存放下一个分隔符（即`+`或`=`或`\n`(换行符)）。


### $m=3$

```cpp
读入字符ch
IF ch = '?' THEN
    这是一个被污染的物质
    读入字符ch
    这个物质读完了
FOR i = 'A' to 'Z'
    读入字符ch
    将ch转换为数字并记为i元素的下标
    读入字符ch
这个物质读完了
```

### $m=2$（同样适用于$m=3$）

```cpp
读入字符ch
IF ch = '?' THEN
    这是一个被污染的物质
    读入字符ch
    这个物质读完了
FOR i = 'A' to 'Z'
    读入字符ch
    IF ch是一个数字 THEN
        将ch转换为数字并记为i元素的下标
        读入字符ch
    ELSE
        记i元素的下标为1
这个物质读完了
```

### $m=1$（同样适用于$m=3$）

```cpp
读入字符ch
IF ch = '?' THEN
    这是一个被污染的物质
    读入字符ch
    这个物质读完了
WHILE (ch != '+' AND ch!='=' AND ch!='\n')
    读入字符num
    将num转换为数字并记为ch元素的下标
    读入字符ch
这个物质读完了
```

### $m=0$（同样适用于$m=1,2,3$）

```cpp
读入字符ch
IF ch = '?' THEN
    这是一个被污染的物质
    读入字符ch
    这个物质读完了
WHILE (ch != '+' AND ch!='=' AND ch!='\n')
    读入字符num
    IF num是一个数字 THEN
        将num转换为数字并记为ch元素的下标
        读入字符ch
    ELSE
        记ch元素的下标为1
        ch := num
```

## 物质最简式的输出（伪代码）

```cpp
FOR i = 'A' to 'Z'
    IF 元素i的下标为0 THEN
        CONTINUE
    输出字符i
    IF 元素i的下标为1 THEN
        CONTINUE
    输出元素i的下标
```

## 算法一（针对测试点1-4）

可以发现对于这些测试点，方程式的形式一定为`?=一种物质`，于是将等号右边的物质化为最简式输出即可。


这一部分不可能存在无解的情况。


## 算法二（针对测试点1-8）

可以发现对于这些测试点，方程式的左边一定为一个`?`，右边一定为若干物质，于是我们只需要统计每种元素在右边出现的次数，即可得知每种元素在左边（即`?`中）出现的次数。


注意判断无解的情况。（见下文）


## 算法三（针对测试点1-4和9-12）

可以发现对于这些测试点，方程式的左边一定为一个`?`加上若干物质，右边为一个物质，于是对于每一个元素，我们可以用右边物质中该元素的下标，减去左边该元素的总出现次数，即可得到该元素在答案中的下标。


注意判断无解的情况。（见下文）


## 算法四（针对所有测试点）

总结前面的算法，我们发现元素守恒是解决该问题的关键。对于无特殊性质的测试点，于是对于每一个元素，我们可以用`?`另一边的该元素出现次数总和，减去`?`所在一边的该元素的总出现次数，即可得到该元素在答案中的下标。


## 针对`?`在方程的最左端的数据（测试点1-16）


对于这类测试点，我们发现`?`在最左边，于是我们可以在一开始就读取这个`?`字符，同时我们也无需判断`?`在哪一边，因为此时`?`一定在等号左边。其他的过程与`算法四`相同。


## 无解的判定

很容易发现，一个方程式无解的充要条件，是我们求出的答案物质满足下列性质中的至少一个：

1. 存在元素下标为负

2. 存在元素下标超过$9$

3. 所有元素下标为$0$


我的代码：

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<string>
    using namespace std;
    int n,m,ys1[27],ys2[27],l,k;
    bool ques,epo,flag;
    //flag代表是否有solution
    //epo代表等号是否已出现
    //ques代表？的位置（等号的哪一方）
    string s;
    int main()
    {
        cin>>n>>m;
        for(int i=1;i<=n;i++)
        {
            k=0;
            memset(ys1,0,sizeof(ys1));
            memset(ys2,0,sizeof(ys2));
            ques=epo=flag=0;
            cin>>s; l=s.length();
            //根据m，分类讨论
            if(m==0||m==2)
            {
                for(int j=0;j<l;j++)
                {
                    if(s[j]=='?')
                    {
                        ques=epo;
                    }
                    if(s[j]=='=') epo=1;
                    if('A'<=s[j]&&s[j]<='Z')
                    {
                        if('0'<=s[j+1]&&s[j+1]<='9')
                        {
                            if(epo==0) ys1[s[j]-'A'+1]+=s[j+1]-'0';
                            if(epo==1) ys2[s[j]-'A'+1]+=s[j+1]-'0';
                        }
                        else
                        {
                            if(epo==0) ys1[s[j]-'A'+1]++;
                            if(epo==1) ys2[s[j]-'A'+1]++;
                        }
                    }
                }
            }
            if(m==1||m==3)
            {
                for(int j=0;j<l;j++)
                {
                    if(s[j]=='?') ques=epo;
                    if(s[j]=='=') epo=1;
                    if('A'<=s[j]&&s[j]<='Z')
                    {
                        if(epo==0) ys1[s[j]-'A'+1]+=s[j+1]-'0';
                        if(epo==1) ys2[s[j]-'A'+1]+=s[j+1]-'0';
                    }
                }
            }
            //计算最后的结果
            if(ques==0)
            {
                for(int j=1;j<=26;j++)
                {
                    ys2[j]-=ys1[j];
                    if(ys2[j]<0||ys2[j]>9) {flag=1; break;}
                    else k+=ys2[j];
                }
                if(flag==1||k==0) {cout<<"No Solution"<<endl; continue;}
                for(int j=1;j<=26;j++)
                {
                    if(ys2[j]==1) printf("%c",'A'+j-1);
                    else if(ys2[j]) printf("%c%d",'A'+j-1,ys2[j]);
                } 
            }
            if(ques==1)
            {
                for(int j=1;j<=26;j++)
                {
                    ys1[j]-=ys2[j];
                    if(ys1[j]<0||ys1[j]>9) {flag=1; break;}
                    else k+=ys1[j];
                }
                if(flag==1||k==0) {cout<<"No Solution"<<endl; continue;}
                for(int j=1;j<=26;j++)
                {
                    if(ys1[j]==1) printf("%c",'A'+j-1);
                    else if(ys1[j]) printf("%c%d",'A'+j-1,ys1[j]);
                }
            }
            cout<<endl; 
        }
        return 0;
}
```

---

## 作者：_HiKou_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4029)

原本以为这道题其实很简单，但是坑点真的多啊 QAQ。

思路：直接模拟即可，具体操作如下：

1. 输入 $n$ 和 $m$，再输入字符串。

2. 把等于号和问号的位置找出，然后把等号两边的化学式用两个字符串存起来。

3. 把每种元素的数量分别用两个数组存起来。

4. 判断：如果两个数组完全相等，说明 ？ 为空，此时需输出 $No$ $Solution$。

5. 求出 $ans$ 数组。

这里有一个小技巧，设化学式为 $a+b=?$ ,我们可以把这个等式看成 $a+b=?+0$，移项得到 $(a+b)-0=?$，得 $?=a+b$。

再比如，设化学式为 $a+?=b$， 移项得到 $?=a-b$。

看出来什么了吗？对，如果问号在左边，就用右边的数组减去左边的数组，如果问号在右边同理。

6. 判断：如果 $ans$ 数组的某一项为负数或者超过 0，说明答案不合法，输出 $No$ $Solution$。

7. 将数组转成字母输出，若为 0 则不输出，为 1 则只输出字母。

CODE：


```
#include<bits/stdc++.h>
using namespace std;
int n,m,i;
string s;
bool nos=0;//判断状态
int main() {
	cin>>n>>m;
	while(n--) {
		cin>>s;
		string zuo,you;//等式左边和右边的字符串
		int deng=0,wen=0;//等号和问号的状态
		for(i=0; i<s.length(); i++) {
			if(s[i]=='=')deng=1;//如果找到等号就加到右边的字符串
			else if(s[i]=='?'&&deng)wen=1;//wen 初始化为 0，默认问号在左边，如果问号在右边则 wen=1
			
			if(s[i]>='A'&&s[i]<='Z'||s[i]>='0'&&s[i]<='9') {
				if(!deng)zuo+=s[i];
				else you+=s[i];
			}
			

		}
		int a[27],b[27],iee=0;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		
		for(i=0; i<zuo.length(); i++) {
			if(zuo[i]>='A'&&zuo[i]<='Z')iee++;//iee 现在为 1
			else continue;
			if(zuo[i]>='A'&&zuo[i]<='Z'&&zuo[i+1]>='0'&&zuo[i+1]<='9')iee=(zuo[i+1]-'0');
        //如果后面有数字就乘上去（当然 iee 都是 1 乘和赋值都可以）
			a[zuo[i]-'A'+1]+=iee;//对应的元素加上
			iee=0;
		}
		//右边同理
		for(i=0; i<you.length(); i++) {
			if(you[i]>='A'&&you[i]<='Z')iee++;
			else continue;
			if(you[i]>='A'&&you[i]<='Z'&&you[i+1]>='0'&&you[i+1]<='9')iee=(you[i+1]-'0');
			b[you[i]-'A'+1]+=iee;
			iee=0;

		}

		

		nos=0;

		for(i=1; i<=26; i++) {
			if(a[i]!=b[i]) {
				nos=1;
				break;
			}
		}

		if(!nos) { //如果全部相等
			cout<<"No Solution"<<endl;
			continue;
		}


		int ans[27];
		if(!wen) { //问号在左边
			for(i=1; i<=26; i++)
				ans[i]=b[i]-a[i];
		} else { //问号在右边
			for(i=1; i<=26; i++)
				ans[i]=a[i]-b[i];
		}

		nos=0;

		for(i=1; i<=26; i++) {
			if(ans[i]<0||ans[i]>=10) { //如果答案不合法
				nos=1;
				break;
			}
		}


		if(nos) {
			cout<<"No Solution"<<endl;
			continue;
		}

		for(i=1; i<=26; i++) {//输出
			if(ans[i]==1)cout<<(char)(i-1+'A');//为 1 则只输出字母
			else if(ans[i]>1)cout<<(char)(i-1+'A')<<ans[i]; //比 1 大就输出数字
		}
		cout<<endl;
		continue;


	}

	return 0;
}
```


---

## 作者：Oracynx (赞：0)

## P4029 [Code+#2] 化学狂暴 题解

### 思路分析

> **正则表达式**（英语：regular expression，常简写为 regex、regexp 或 RE），又称**规律表达式**、**正规表示式**、**正规表示法**、**规则运算式**、**常规表示法**，是[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)概念，用简单字串来描述、匹配文中全部符合指定格式的[字串](https://zh.wikipedia.org/wiki/字符串)，现在很多[文本编辑器](https://zh.wikipedia.org/wiki/文本编辑器)都支援用正则表达式搜寻、取代符合指定格式的字串。
>
> 许多[程序设计语言](https://zh.wikipedia.org/wiki/程序设计语言)都支援用正则表达式操作字串，如 [Perl](https://zh.wikipedia.org/wiki/Perl) 就内建功能强大的正则表达式引擎。正则表达式这概念最初由 [Unix](https://zh.wikipedia.org/wiki/Unix) 的工具软件（例如 [sed](https://zh.wikipedia.org/wiki/Sed) 和 [grep](https://zh.wikipedia.org/wiki/Grep)）普及开。
>
> 引用自[维基百科](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)。

专业的事情（文本匹配）交给专业的人（正则表达式）来干。

考虑书写如下的正则表达式。

```regex
([A-Z])(\d?)
```

分别讲解一下。

`([A-Z])` 表示定义一个组，其匹配 $1$ 个字符，字符可以为 `A` 到 `Z` 中的任意一个。

`(\d?)` 也表示定义一个组，其匹配 $0 \sim 1$ 个数字（`\d` 表示 $0 \sim 9$ 的一个数字，亦可以用上文的 `[0-9]` 表示），`?` 表示对于前面的一个元素，匹配 $0$ 个或 $1$ 个。

本文暂时只用到了这几个符号，如有兴趣可以自行上网查询。

总结来说，这个正则表达式的意思是：

> 匹配一个大写字母，后面可以紧接一个数字，也可以仅有一个大写字母。

在本题中，这样子可以可以匹配到所有的原子。

在匹配到所有的原子后，我们便可以根据其在等号左边或右边来计数，再求出缺少的元素即可。

### 相关定义

**警告：C++ 实现的正则表达式引擎性能不高，视表达式复杂程度会比其他语言慢 $5 \sim 10$ 倍，正则表达式效率本身也并不是很高，在大量操作时需要注意性能问题。**

自 C++11 起，正则表达式相关函数与类定义在 `<regex>` 头文件中，万能头文件亦包含此头文件。（NOI 系列竞赛可以使用正则表达式）

`std::regex` 类，即定义一个名为 `reg` 的正则表达式类，可以传入构造参数 `(RegexExpression)` 以字符串形式提供正则表达式。

`std::sregex_iterator` 类，为定义一个正则表达式搜索便利迭代器，可以传入构造参数 `(StringBegin, StringEnd, Regex)`，其中 `StringBegin` 为字符串起始位置，`StringEnd` 为字符串终止位置，`Regex` 为上文定义的正则表达式类。如果定义了 `std::regex_iterator it`，则可以通过 `it++` 的方式迭代访问下一个匹配项。

令 `x = (*it)`，则 `x.position` 储存了当前匹配的下标，`x[0].str()` 即为匹配到的字符串，`x[1].str()` 即为第一个组，`x[2].str()` 为第二个组……以此类推。

当超过最后一个匹配项后，`it` 会变为一个空的 `std::regex_iterator`。

### 代码实现

优雅、简洁、不简单。

```cpp
#include <cstdio>
#include <map>
#include <regex>
#include <string>
constexpr int MaxN = 7e2 + 5;
char temp[MaxN];
std::string s;
std::regex reg("([A-Z])(\\d?)");
std::map<char, int> map;
void solve()
{
    map.clear();
    scanf("%s", temp);
    s = temp;
    int cur = s.find("=");
    for (std::sregex_iterator it(s.begin(), s.end(), reg), end; it != end; it++)
    {
        if (it->position() < cur)
        {
            map[(*it)[1].str()[0]] += (*it)[2].str().empty() ? 1 : std::stoi((*it)[2].str());
        }
        else
        {
            map[(*it)[1].str()[0]] -= (*it)[2].str().empty() ? 1 : std::stoi((*it)[2].str());
        }
    }
    bool rev = int(s.find("?")) < cur;
    for (const auto &[c, _x] : map)
    {
        int x = rev ? -_x : _x;
        if (x < 0 || x > 9)
        {
            printf("No Solution\n");
            return;
        }
    }
    bool found = false;
    for (const auto &[c, _x] : map)
    {
        int x = rev ? -_x : _x;
        if (x >= 1)
        {
            found = true;
            printf("%c", c);
        }
        if (x >= 2)
        {
            printf("%d", x);
        }
    }
    printf("%s\n", found ? "" : "No Solution");
}
int main()
{
    int t;
    scanf("%d%*d", &t);
    for (int i = 1; i <= t; i++)
    {
        solve();
    }
    return 0;
}

```

---

## 作者：Scez (赞：0)

题外话：别看这题是一道绿题，其实水的要死）

## 题目描述

给出一个形如 $a_1+a_2+\ldots+a_n=b_1+b_2+\ldots+b_n$ 的化学方程式（其中含有一个未知元素，用`?`表示），再给出方程式的表示方法（其实没啥用），求`?`代表的物质是什么。

## 解题思路

考虑字符串模拟，从头到位枚举每一位字符，如果是大写字母（某种元素），那就看它的下一位是否是数字，如果是，就把元素数量统计下来。如果不是，就代表方程式用了“单一元素”表示出来，把当前元素数量 $+1$ 即可。

在枚举的过程中，我们把问号相对等号的位置和当前字符的位置（在等号左边还是右边）记录一下，便于元素数量的统计的答案的统计。

统计完元素数量后，枚举每个元素，等号两边的每个元素数量的差就是答案（谁减谁取决于问号相对等号的位置）。


题目还要求无解输出`No Solution`。

考虑哪几种情况会导致无解。

1. 所求物质的某种元素的数量 $>9$
2. 等号元素数量的差 $<0$
3. 所求物质为空（即等号左右两边不包含`?`物质的元素总量相等）

## 代码实现


```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,m;
int ck; //标记问号位置（等号左右） 
string c;
int cnt[27]; //等号左边各元素的数量 
int cnt1[27]; //等号右边各元素的数量 
int main()
{
	cin>>n>>m;
	while(n--)
	{
		memset(cnt,0,sizeof(cnt));
		memset(cnt1,0,sizeof(cnt1));
		int flag=0; //=1表示当前在等号右边 
		ck=0;
		cin>>c;
		for(int i=0;i<c.length();i++){
			if(c[i]=='?'){
				if(flag)
				ck=1;
			}
			if(c[i]=='='){
				flag=1;
				continue;
			}
			if(!flag){
				if(c[i]>='A'&&c[i]<='Z'){
					if(c[i+1]>='0'&&c[i+1]<='9')
					cnt[c[i]-'A'+1]+=c[i+1]-'0',i++;
					else
					cnt[c[i]-'A'+1]++;
				}
			}
			else{
				if(c[i]>='A'&&c[i]<='Z'){
					if(c[i+1]>='0'&&c[i+1]<='9')
					cnt1[c[i]-'A'+1]+=c[i+1]-'0';
					else
					cnt1[c[i]-'A'+1]++;
				}
			}
		}
		int flag1=0;
		int cnt0=0;
		for(int i=1;i<=26;i++){
			if(!ck){
				if(cnt1[i]==cnt[i])
				cnt0++;
				if(cnt1[i]-cnt[i]>9||cnt1[i]-cnt[i]<0) {
					flag1=1;
					cout<<"No Solution"<<endl;
					break;
				}
			}
			else{
				if(cnt1[i]==cnt[i])
				cnt0++;
				if(cnt[i]-cnt1[i]>9||cnt[i]-cnt1[i]<0){
					flag1=1;
					cout<<"No Solution"<<endl;
					break;
				}
			}
		}
		if(flag1)
		continue;
		if(cnt0==26){
			cout<<"No Solution"<<endl;
			continue;
		}
		for(int i=1;i<=26;i++){
			if(!ck){
				if(cnt1[i]-cnt[i]==1)
				cout<<char(i+'A'-1);
				else if(cnt1[i]-cnt[i]>1)
				cout<<char(i+'A'-1)<<cnt1[i]-cnt[i];
			}
			else{
				if(cnt[i]-cnt1[i]==1)
				cout<<char(i+'A'-1);
				else if(cnt[i]-cnt1[i]>1)
				cout<<char(i+'A'-1)<<cnt[i]-cnt1[i];
			}
		}
		cout<<endl;
	}
	return 0;
}


```

---

## 作者：Tomle (赞：0)

upd:
- 2024.3.3 改了下丑陋的码风（之前的代码太丑了）。

# 前置知识
- 新式 for 循环（c++11）。
- string 类的基础运用。

# 题意简述
给你一个化学方程式求解，化成最简形式。

---

这题思路明确了就很好打，但有两个坑。

如果你 35pts，那么请注意：
1. 每个元素个数不超过 **10**。
2. 如果 `?` 为空，输出 `No Solution`。

# 思路

常数较小，可以使用 string，方便。

1. 先把方程转换成**表达式**，形式如 `?=...`，**移项** 就行了，小学知识。
2. 表达式求解。
3. 将结果转换成最简形式，如果某一元素数量小于 0，即不满足元素守恒，输出 `No Solution`，如果元素数量大于等于 10，不满足题目要求，也输出 `No Solution`。
4. 输出的时候特判一下，如果为空字符串，输出 `No Solution`，不然只有 75pts。

# 代码实现
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef map<char, int> dict;
// 个人习惯，可以减少码量 
// dict表示一个物质中每个元素的数量 

dict operator-(dict a, dict b) {
	// 运算符重载，对两个物质做减法运算 
	for (auto i : b) {	// 新式for循环，遍历map，代替迭代器 
		// 遍历map时，i是一个pair(?)，i.first是键，i.second是值 
		a[i.first] -= i.second;
	}
	return a;
}
dict operator+(dict a, dict b) {
	// 运算符重载，对两个物质做加法运算 
	for (auto i : b) {
		a[i.first] += i.second;
	}
	return a;
}

string Slice(string s, int l, int r = 0x7fffffff) {
	// string substr太难用，这个函数是截取字符串s l到r的子串
	// 如果不给出参数r，默认截取l以后的子串 
	r = min(r, (int)s.size() - 1);
	string res = "";
	for (int i = l; i <= r; i++) {
		res += s[i];
	}
	return res;
}
dict convert(string s) {
	// 此函数的作用是将字符串s转换成dict类型(物质)
	dict res;
	for (int i = 0; i < s.size(); i++) {
		if (!isdigit(s[i])) {
			// 如果这一位不是数字(这一位是元素)
			if (isdigit(s[i + 1])) {
				// 如果后一位是数字 
				if (s[i + 1] != '0'){
					res[s[i]] = s[i + 1] - '0';
				}
			} else {
				// 如果后一位不是数字，代表单一元素 
				res[s[i]] = 1;
			}
		}
	}
	return res;
}
string minify(dict d) {
	// 此函数的作用是把dict类型转换成最简形式 
	string res = "";
	for (auto i : d) {
		if (i.second < 0) return "No Solution";	// 如果元素数量小于0，说明不满足元素守恒定律 
		if (i.second != 0) {
			if (i.second == 1) {
				res += i.first;
			} else {
				if (i.second > 9) return "No Solution";	// 如果元素数量大于9，不满足题意 
				res += i.first;
				res += i.second + '0';
				// 此处不能写成res+=i.first+char(i.second+'0')
				// 因为会先运算 i.first+char(i.second+'0')，结果是个char(或者是int?)，不是字符串 
			}
		}
	}
	return res;
}
string solve(string s) {
	// 此函数的作用是求解方程式 
	if (s.find("-?") != string::npos) {
		// 如果s中包含-?，说明未知数在方程中被减，要先移到另一边，使得未知数的符号是+ 
		if (s.find('?') > s.find('=')) {
			// 如果?在=后面，也就是在方程式的右边，要把?移到左边 
			s = s.replace(s.find("-?"), 2, "");
			s = "?+" + s;
		} else {
			// 同理，如果?在=前面，也就是在方程式的左边，要把?移到右边  
			s = s + "+?";
			s = s.replace(s.find("-?"), 2, "");
		}
	}
	if (s.find('?') > s.find('=')) {
		// 如果?在=右边，说明未知数在右边，为了统一，左右颠倒一下 
		s = Slice(s, s.find('=') + 1) + "=" + Slice(s, 0, s.find('=') - 1);
	}
	if (s.find('?') != 0) {
		// 如果?不在最前面，要把?移到最前面，方便统一 
		s = s.replace(s.find("+?"), 2, "");
		s = "?+" + s;
	}
	// 以上代码的作用是将表达式转换成?+...=...的形式 
	string t = Slice(s, s.find('=') + 1), r = "";
	// t代表将方程转换成表达式的结果，r表示左边的数移到右边时的形式(只有运算符变了) 
	for (int i = 1; ; i++){
		// 将左侧的数移到右边，也就是变量t上
		// 如果在左侧的运算符是-，那么在右边的运算符是+
		// 同理，如果在左侧的运算符是+，那么在右边的运算符是- 
		if (s[i] == '+' || s[i] == '-' || s[i] == '=') {
			t += r;
			if (s[i] == '=') break;
			if (s[i] == '+') r="-";
			if (s[i] == '-') r="+";
		} else {
			r += s[i];
		}
	}
	t += '+';
	// t加上一个+，方便运算
	// 原来的t最后是没有运算符的，最后一个数不会被计算
	// 现在t加上一个运算符，这个运算符的作用仅仅是算上最后一个数，并不会改变运算结果 
	r = "";
	// 变量r重复利用，作用和上面的代码差不多，但不加运算符 
	dict res;
	// res是dict类型运算的最后结果 
	int f = 1;
	//	f表示正负，决定用加法还是减法 
	for (auto i : t) {
		//新式for循环遍历字符串，i是字符 
		if (i == '+' || i == '-') {
			if (f == 1) {
				res = res + convert(r);
				// res加上转换成dict类型的数 
			} else {
				res = res - convert(r);
				// res减去转换成dict类型的数 
			}
			if (i == '+') f = 1;
			else f = -1;
			// 改变符号 
			r = "";
			// r清空 
		} else {
			r += i;
			// 如果不是符号，正常加上字符 
		}
	}
	return minify(res);
	// 返回最简形式 
}
int main() {
	int n, m;
	string s;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> s;
		string r = solve(s);
		if (r != "") cout << r << endl;
		else cout << "No Solution" << endl;
		// 特判，空字符串输出No Solution 
	}
	return 0;
}
```

---


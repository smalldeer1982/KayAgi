# [Code+#2] 可做题1

## 题目背景

“codeplus比赛的时候在做什么？有没有空？能来解决停机问题吗？”qmqmqm这样问sublinekelzrip。


当然，sublinekelzrip并不会停机问题，所以qmqmqm改为提出了另一个题目，现在请你帮助sublinekelzrip解决这个题目。


## 题目描述

这个问题是这样的：


对于任何一个$n$阶方阵，若任意从其中选择$n$个不同行不同列的位置，其上的权值之和均相等，则我们称这个矩阵是巧妙的。注意对于$n=1$的任何矩阵都是巧妙的。 例如矩阵：

```cpp
1 2 3
4 5 6
7 8 9
```
是巧妙的，因为$1+5+9=1+6+8=2+4+9=2+6+7=3+5+7=3+4+8=15$。

而矩阵：

```cpp
1 2
2 1
```
不巧妙，因为$1+1 \neq 2+2$。

现在有一个$n \times m$大小的矩阵$M$以及$T$个询问，每次询问其一个子方阵是否是巧妙的。


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/12654.png) 

对于所有的数据，$0 \leq M_{ij} \leq 10^9$，$1 \leq x \leq n$，$1 \leq y \leq m$。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/卢政荣 命题/卢政荣 验题/吕时清，王聿中

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
3 3 4
1 1 1
1 1 1
1 1 2
1 1 2
1 1 3
2 2 2
2 1 2```

### 输出

```
Y
N
N
Y```

# 题解

## 作者：消失的海岸线 (赞：12)

丢一下[博客](https://www.zgz233.xyz/2017/12/26/bzoj-5136-codeplus2017%E5%B9%B412%E6%9C%88%E5%8F%AF%E5%81%9A%E9%A2%981/ "博客")链

题意：定义一个 $n$ 阶方阵是巧妙的当且仅当对于长度为 $n$ 的排列 $p$，取这个方阵的如下 $n$ 个元素：$(i,p_i)$，它们的和均相同。

注意到一个方阵是巧妙的当且仅当它的所有 $2$ 阶子方阵都是巧妙的。

证明显然，因为如果有一处不巧妙一定存在两种排列的和不同。

维护二维前缀和即可。

     
     
     
```cpp
    #include <cmath>
    #include <queue>
    #include <cstdio>
    #include <iomanip>
    #include <cstdlib>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define N 510
    #define ll long long
    using namespace std;
    inline int read()
    {
        int x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
        return x*f;
    }
    int n,m,T;
    int a[N][N],f[N][N],g[N][N];
    int ask_sum(int l,int r,int L,int R)
    {
        return g[L][R]-g[l-1][R]-g[L][r-1]+g[l-1][r-1];
    }
    int main()
    {
        n=read(),m=read(),T=read();
        for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)a[i][j]=read();
        for(int i=1;i<=n-1;i++)
        for(int j=1;j<=m-1;j++)f[i][j]=(a[i][j]+a[i+1][j+1]==a[i+1][j]+a[i][j+1]);
        for(int i=1;i<=n-1;i++)
        for(int j=1;j<=m-1;j++)g[i][j]=g[i-1][j]+g[i][j-1]-g[i-1][j-1]+f[i][j];
        while(T--)
        {
            int x=read(),y=read(),k=read();
            if(k==1)
            {
                puts("Y");
                continue ;
            }
            int sum=ask_sum(x,y,x+k-2,y+k-2);
            if(sum==(k-1)*(k-1))puts("Y");
            else puts("N");
        }
}
```

---

## 作者：Bp_fish (赞：6)

>### 二维前缀和

------------

>最近动规学傻了_(:D)∠)_ ，一上来就想到了三维DP。

------------

>$DP[i][j][k]$代表$(i,j)$点处的$k$阶方阵是否"巧妙"。

>那么先算好$DP[i][j][1]$和$DP[i][j][2]$的值后就可以三重for循环解决。


------------


>【错误做法】$DP$转移公式：

>$DP[i][j][k]=DP[i][j][k-1]*DP[i+1][j+1][k-1]*DP[i+k-2][j][2]*DP[i][j+k-2][2]$

>###### ~~欢声笑语打出40~~。
>505$*$505$*$505=1e8,试着加了点减枝结果没过。开始想别的方法。

------------

>考虑到一个矩阵要巧妙，那么必须内部每一个2阶矩阵都巧妙，自然地考虑到用二维前缀和加一下。

------------

>其中累加的公式：（我for循环习惯从1开始，所以直接减也不会越界）。

>$accumulation[i][j]=DP[i][j]+accumulation[i][j-1]+accumulation[i-1][j]-accumulation[i-1][j-1];$

------------
>判断公式：（需要注意到x阶矩阵内部只有（x-1）*（x-1）个2阶矩阵）。


> $ (z-1)*(z-1)==accumulation[x+z-2][y+z-2]-accumulation[x+z-2][y-1]-accumulation[x-1][y+z-2]+accumulation[x-1][y-1] $ 

------------

>Right 函数用于判断x，y为左上角的2阶矩阵是否巧妙。

```cpp
ll Right(ll x,ll y)//2*2是否巧妙
{
	//data记录数据
    if(data[x][y+1]+data[x+1][y]==data[x][y]+data[x+1][y+1])
    {
        return 1;
    }
    else
    {
        return 0;
    }
    //就是交叉之和相同
}
```

>最终的代码放一下：


```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<string>
#include<vector>
#include<set>
#include<queue>
#include<stack>
#include<sstream>
#define ll long long
#define mod 998244353
#define inf 0x3f3f3f3f3f3f
#define the_max 100005
using namespace std;

ll i,j,k,l;
ll x,y,z;
ll a,b,c,d,e,f;
ll t,m,n;

ll data[505][505];//数据
ll accumulation[505][505];//前缀和累加
ll DP[505][505];//判断2*2格子是否合法

ll Right(ll x,ll y)//2*2合法
{
    if(data[x][y+1]+data[x+1][y]==data[x][y]+data[x+1][y+1])
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int main()
{
    cin >> n >> m >> t ;
    for(i=1;i<=n;++i)
    {
        for(j=1;j<=m;++j)
        {
            scanf("%d",&data[i][j]);
        }
    }//读入数据

    a=n-1;b=m-1;//注意这里是计算2阶矩阵所以不用计算到n和m
    for(i=1;i<=a;++i)
    {
        for(j=1;j<=b;++j)
        {
            DP[i][j]=Right(i,j);
        }
    }
    
	//计算前缀和
    for(i=1;i<=n;++i)
    {
        for(j=1;j<=m;++j)
        {
            accumulation[i][j]=DP[i][j]+accumulation[i][j-1]+accumulation[i-1][j]-accumulation[i-1][j-1];
        }
    }

    for(i=1;i<=t;++i)
    {
        scanf("%d%d%d",&x,&y,&z);
        if(z==1)
            printf("Y\n");
        else if(z==2)
        {
            if(DP[x][y])
                printf("Y\n");
            else
                printf("N\n");
        }
        else if((z-1)*(z-1)==accumulation[x+z-2][y+z-2]-accumulation[x+z-2][y-1]-accumulation[x-1][y+z-2]+accumulation[x-1][y-1])
            printf("Y\n");
        else
            printf("N\n");
    }


return 0;
}

```


---

## 作者：瑞源鸣 (赞：4)

- ## 思路：
	首先题中的样例：

	**1 2 3**

	**4 5 6**

	**7 8 9**

	可以找到**规律**：任意一个2*2的宫格内，只需判断两条对角线的和是否相等。


------------

- ### 简单的证明：

	因为题中说的是**任意**，所以就很好推出这个结论了。


------------


- ### 过程：
	可以初始化每个2*2矩阵是否满足条件，再对所给的区间进行查询。


------------
- ## 注：

	由于数据很水，时间复杂度为O(n* m* T) ~~(居然过了！)~~

	如果要优化，可以考虑用二维树状数组优化。自己去优化吧  (ˉ▽￣～) ~~

- ## CODE
  ```cpp
  #include<map>
  #include<list>
  #include<queue>
  #include<cstdio>
  #include<cstring>
  #include<iostream>
  #include<algorithm>
  using namespace std;
  const int M=500+10;

  int n,m,t;
  int mapp[M][M];
  bool area[M][M];

  bool check(int x,int y,int k){
      for(int i=x;i<x+k-1;i++)
          for(int j=y;j<y+k-1;j++)
              if(area[i][j]==0)
                  return false;
      return true;
  }

  int main(){
      scanf("%d%d%d",&n,&m,&t);
      for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)
              scanf("%d",&mapp[i][j]);
      for(int i=1;i<n;i++)
          for(int j=1;j<m;j++)
              if(mapp[i][j]+mapp[i+1][j+1]==mapp[i+1][j]+mapp[i][j+1])
                  area[i][j]=true;
      for(int i=1,x,y,k;i<=t;i++){
          scanf("%d%d%d",&x,&y,&k);
          if(check(x,y,k)) printf("Y\n");
          else printf("N\n");
      }
      return 0;
  }
  ```


---

## 作者：ltz761222 (赞：2)

## 前提
暂未发现与本题解思路相符的题解，所以写一篇。

## 题目
[P4030](https://www.luogu.com.cn/problem/P4030)

## 思路

### 审题并关注数据大小

题目中询问而不修改的操作提示我们预处理，而复杂度 $T\le100000,n,m\le500$ 提示我们每一轮的复杂度不超过线性，通俗的来说，不能出现二层的 for 循环。

### 寻找突破口
   
我们可以假设一个巧妙的矩阵，并从中寻找规律。我们发现，若一个矩阵是巧妙的，那么他的一条对角线便是一种选取方案，之后每次交换两列选取的点的横坐标，最终可以找到所有的方案。
   
故观察交换过程：若两列的选取方案交换，因为其仍满足**巧妙性质**，所以设 $x$ 表示交换的第一列的数字前后之差，易得第二列的数字前后之差 $-x$，继续推理，可以得出若一个矩阵是巧妙的，则它的每一列的同样位置的两个点的差值相等，具体如下。

### 总体思路

预处理 ${{r_i}_j}$ 表示以 $i$ 行 $j$ 列开始的在第 $i$ 行有几个连续点都满足他与他的下一行数之差相等。查询时若我们的统计矩阵每行都有超过 $x$ 个数满足性质，则易得该矩阵是巧妙的。

### 代码（尾部附一组数据）
     
```cpp
//ke zuo ti 1 
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e2+10;
int r[N][N],a[N][N];
int n,m,t;
int main ()
{
	scanf ("%d %d %d",&n,&m,&t);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			scanf ("%d",&a[i][j]);
	
	//初始化，类dp 
	for (int j=1;j<=m;j++)
		for (int i=n-1;i>=1;i--)
			if (a[i][j]-a[i][j+1]==a[i+1][j]-a[i+1][j+1])//试：思考i的临界值含义，若i=n-1不会报错的原因 
				r[i][j]=r[i+1][j]+1;//后一个可以续上 
			else
				r[i][j]=0;//续不上 
	
	int u,v,x;bool g;
	while (t--)
	{
		scanf ("%d %d %d",&u,&v,&x),g=true;
		if (x!=1)
			for (int i=v;i<=v+x-2;i++)//试：思考临界值 
				if (r[u][i]+1<x)
				{
					g=false;
					break;
				}
		if (!g)
			printf ("N\n");
		else
			printf ("Y\n");
	}
	
	return 0;
}
/*
5 5 6
1 2 3 4 8 
2 4 5 6 9 
3 6 7 8 10
5 8 9 20 30
7 10 1 2 3  
1 1 3
1 2 3
5 5 1
3 2 2
4 4 2
4 2 2

*/
```

---

## 作者：Otomachi_Una_ (赞：2)

## 题目大意

定义一个大小为 $k$ 的方阵 $a_{i,j}$ 是巧妙的，但且仅当对于 $p_i$ 为 $1$ 到 $k$ 的一种排列，$\sum_{i=1}^n a_{i,p_i}$ 不变。

给定大小为 $n\times m$ 的矩阵，对于 $t$ 次询问，给出 $x,y,k$，问以 $(x,y)$ 为左上角大小为 $k$ 的方阵是否巧妙。

## 解题思路

首先，如果一个大小为 $k$ 的方阵是巧妙的，我们会发现：

$$a_{1,1}+a_{2,2}+a_{3,3}\dots+a_{k-1,k-1}+a_{k,k}=a_{1,1}+a_{2,2}\dots+a_{k-2,k-2}+a_{k,k-1}+a_{k-1,k}$$

于是，$a_{k-1,k-1}+a_{k,k}=a_{k-1,k}+a_{k,k-1}$，于是右下角的一个 $2\times2$ 的方阵是巧妙的。

同理，可以证明该方阵中其他 $2\times 2$ 的方阵均为巧妙的。

于是我们只需对题目要求的子矩阵中的每个 $2\times 2$ 的方阵进行枚举即可。

但这样会超时，下面我们讲讲优化。

假设 $r_{i,j}$ 表示以 $(i,j)$ 为左上角的 $2\times 2$ 的方阵是否巧妙。

再用 $s_{i,j}$ 来记录 $r$ 的前缀和即可。

时间复杂度 $\mathcal{O}(n\times(n+m))$。

## 参考代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
#define ll long long
const int MAXN=505;
int n,m,t;
int a[MAXN][MAXN];
bool r[MAXN][MAXN];//r[i][j]:a[i][j] 为左上角的 2 * 2 方阵是否合法 
int s[MAXN][MAXN];// 前缀和 
int main(){
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<n;i++)
		for(int j=1;j<n;j++)
			r[i][j]=(a[i][j]+a[i+1][j+1]==a[i+1][j]+a[i][j+1]);
	for(int i=1;i<n;i++)
		for(int j=1;j<n;j++)
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+r[i][j];//计算前缀和 
	while(t--){
		int x,y,k;
		cin>>x>>y>>k;
		int p=x+k-2,q=y+k-2;
		if(s[p][q]-s[x-1][q]-s[p][y-1]+s[x-1][y-1]==(k-1)*(k-1))
			cout<<"Y"<<endl;
		else
			cout<<"N"<<endl;
	} 
	return 0;
}
```


---

## 作者：ddmd (赞：2)

题目的意思很简单，就是让我们判断某一个子方阵是否是巧妙的。   

我们手推一下可以发现方阵是巧妙的时候，必定方阵每一个 $ 2  \times 2 $ 子方阵一定也是奇妙的。   

故我们可以将每一个 $ 2  \times 2 $ 子方阵是否奇妙预处理出来，再对询问的子方阵进行一遍查询即可。  

最终时间复杂度为 $ O(n \cdot m \cdot T) $。   

Code

------------

```cpp
// Dong_Dong出品 必是精品

#include<bits/stdc++.h>
#define int long long
using namespace std;

inline int read()
{
	int pos=1,num=0;
	char ch=getchar();
	while (!isdigit(ch))
	{
		if (ch=='-') pos=-1;
		ch=getchar();
	}
	while (isdigit(ch))
	{
		num=num*10+(int)(ch-'0');
		ch=getchar();
	}
	return pos*num;
}
inline void write(int x)
{
	if (x<0)
	{
		putchar('-');
		write(-x);
		return;
	}
	if (x>=10) write(x/10);
	putchar(x%10+'0');
}
inline void writesp(int x)
{
	write(x);
	putchar(' ');
}
inline void writeln(int x)
{
	write(x);
	putchar('\n');
}
int Map[1000][1000],f[1000][1000];
signed main()
{
	int n=read(),m=read(),T=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            Map[i][j]=read();
    for(int i=1;i<n;i++)
        for(int j=1;j<m;j++)
            if(Map[i][j]+Map[i+1][j+1]==Map[i+1][j]+Map[i][j+1]) f[i][j]=1;
    while (T--)
    {
        int x=read(),y=read(),k=read();
        bool F=1;
        for(int i=x;i<x+k-1;i++)
        {
        	for(int j=y;j<y+k-1;j++)
            	if(!f[i][j]) {F=0;break;}
            if (!F) break;
        }
        if(F) puts("Y");
     	   else puts("N");
    }
    return 0;
}

```


---

## 作者：__Allen_123__ (赞：1)

### 题意简述

定义一个 $k$ 阶矩阵是“巧妙的”，当且仅当在其中任选 $k$ 个不同行不同列的数之和全部相等。

给定一个 $n\times m$ 的矩阵，给出 $T$ 次询问，每次询问这个矩阵中的一个子矩阵是否是“巧妙的”。

### 题目分析

分析题目可以发现：如果一个 $k$ 阶矩阵 $a$ 是巧妙的，那么 $a_{1,1}+a_{2,2}+a_{3,3}+a_{4,4}+\cdots+a_{k,k}=a_{1,2}+a_{2,1}+a_{3,3}+a_{4,4}+\cdots+a_{k,k}$，即 $a_{1,1}+a_{2,2}=a_{1,2}+a_{2,1}$，那么其左上角的一个 $2$ 阶矩阵就是巧妙的。

同理可得，**如果一个 $k$ 阶矩阵 $a$ 是巧妙的，那么其任意 $2$ 阶子矩阵都是巧妙的**。如果其中有一个 $2$ 阶子矩阵不是巧妙的，那么整个矩阵就都不是巧妙的。

所以我们在输入矩阵时可以把整个矩阵预处理一遍，记录每个 $2$ 阶子矩阵是否是巧妙的（即，判断 $a_{1,1}+a_{2,2}$ 是否等于 $a_{1,2}+a_{2,1}$）。在询问时验证其 $2$ 阶子矩阵是否都是巧妙的即可。

时间复杂度 $O(nmT)$，可以通过此题。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 505;
int n, m, t, a[MAXN][MAXN], x, y, k;
bool perfect[MAXN][MAXN];
int main(){
	scanf("%d%d%d", &n, &m, &t);
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= m;j++){
			scanf("%d", &a[i][j]);
		}
	}
	for(int i = 1;i < n;i++){ // 预处理
		for(int j = 1;j < m;j++){
			if(a[i][j + 1] + a[i + 1][j] == a[i][j] + a[i + 1][j + 1]){ // 验证每个 2 阶子矩阵是否是巧妙的，存储在数组内
				perfect[i][j] = 1;
			}
		}
	}
	while(t--){
		bool ok = 1;
		scanf("%d%d%d", &x, &y, &k);
		for(int i = x;i < x + k - 1 && ok;i++){ // 注意这里要减 1，不然可能探测到其他范围
			for(int j = y;j < y + k - 1 && ok;j++){
				ok = ok && perfect[i][j]; // 如果有一个子矩阵不是巧妙的答案就是 N，否则答案就是 Y
			}
		}
		if(ok){
			printf("Y\n");
		}
		else{
			printf("N\n");
		}
	}
	return 0;
}
```

---

## 作者：elainya_stars (赞：0)

# [P4030 \[Code+#2\] 可做题1](https://www.luogu.com.cn/problem/P4030)

## 思路

不难发现，如果一个方阵是巧妙的，当且仅当它所有的 $2$ 阶子方阵也都是巧妙的。

证明：如果一个以第 $x$ 行第 $y$ 列为左上角 $k$ 阶方阵是巧妙的，那么它一定满足：

$$ M_{x,y} + M_{x+1,y+1} + M_{x+2,y+2} + \cdots + M_{x+k−1,y+k−1} = M_{x+1,y} + M_{x,y+1} + M_{x+2,y+2} + \cdots + M_{x+k−1,y+k−1} $$
 
抵消后得：

$$ M_{x,y} + M_{x+1,y+1} = M_{x+1,y} + M_{x,y+1} $$

即以第 $x$ 行第 $y$ 列为左上角 $2$ 阶方阵必须是巧妙的，以此类推，可以推算出所有的 $2$ 阶子方阵也都必须是巧妙的。

## 做法

用二维前缀和 $pre_{i,j}$ 维护以第 $1$ 行第 $1$ 列为左上角，第 $i$ 行第 $j$ 列为右下角的矩阵有多少个巧妙的 $2$ 阶子方阵即可。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=505;
int n,m,t,a[N][N],p[N][N],pre[N][N];

int sum(int x1,int y1,int x2,int y2)
{
	return pre[x2][y2]-pre[x1-1][y2]-pre[x2][y1-1]+pre[x1-1][y1-1];
}

signed main()
{
	scanf("%lld%lld%lld",&n,&m,&t);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		  scanf("%lld",&a[i][j]);
	for(int i=1;i<n;i++)
		for(int j=1;j<m;j++)
		  p[i][j]=(a[i][j]+a[i+1][j+1]==a[i+1][j]+a[i][j+1]);
	for(int i=1;i<n;i++)
		for(int j=1;j<m;j++)
		  pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+p[i][j];
	while(t--)
	{
		int x,y,k;
		scanf("%lld%lld%lld",&x,&y,&k);
		int total=sum(x,y,x+k-2,y+k-2);
		if(total==(k-1)*(k-1))
		  puts("Y");
		else
		  puts("N");
	}
	return 0;
}
```

~~给我赞赞qwq~~

---

## 作者：AzzyZhe (赞：0)

# 题解：P4030 [Code+#2] 可做题1

[题目入口](https://www.luogu.com.cn/problem/P4030)

----
## 思路

### 考虑转化“巧妙”的判断
此部分思路与 @ltz761222 的类似。

首先考虑一个方阵是巧妙的，我们取其对角线上的所有值。在这样的基础上，我们考虑任选两行，交换其所选取的列（例如从选取 $(1,1),(3,3)$ 变为选取 $(1,3),(3,1)$），要使求和仍不变，则有两行增量相加为 $0$。（必要性）

同时，当一个方阵中满足所有这样的交换都不会带来求和值的改变时，又易知这样的交换能构造出所有的选取情况，则方阵巧妙。（充分性）

因此，我们转而可以考虑方阵中不同行间进行相同区间的交换，带来的差值相同。第 $i_1$ 行从取 $a_{i_1,j_1}$ 到取 $a_{i_1,j_2}$ 产生了 $x$ 的增量，则第 $i_2$ 行从取 $a_{i_2,j_1}$ 到取 $a_{i_2,j_2}$ 也应产生 $x$ 的增量。

具体我们可以在每行内差分，则每行内增量相同可以变为每行内每个最小的差分单位分别相同。

### 判断多行差分相同
这时，只需要差分后得到的矩阵（$[x+1,y]$ 到 $[x+k-1,y+k-1]$，差分后不考虑每行首个值）每行都相同即可。

如何判断每行相同呢？我们考虑再次在差分矩阵的纵向差分，只需二次差分方阵（$[x+1,y+1]$ 到 $[x+k-1,y+k-1]$）内增量全为 $0$ 则每行相同。即单次查询只需判断一片正方形区域内是否全为 $0$，或者说，某点处的最大全 $0$ 正方形是否覆盖了足够大的范围。

此时，我们的问题已经被转化为了另一道经典的 dp 问题，进一步求解就不再赘述，具体可见 [P1387 最大正方形 题解](https://www.luogu.com.cn/problem/solution/P1387)。

### 时间复杂度
预处理 $\mathcal O(nm)$，单次查询 $\mathcal O(1)$，总复杂度 $\mathcal O(nm+T)$。

----
## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define MAXN 510
using namespace std;
typedef long long int64;
typedef unsigned long long uint64;
int n,m,t; 
int a[MAXN][MAXN];
int df1[MAXN][MAXN],df2[MAXN][MAXN];
int F[MAXN][MAXN];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	//第一次横向差分：“选取的列 交换”带来的差值 
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
			df1[i][j]=a[i][j]-a[i][j-1];
	//第二次纵向差分：判断第一次差分的结果每行相等 
	for(int j=2;j<=m;j++)
		for(int i=2;i<=n;i++)
			df2[i][j]=df1[i][j]-df1[i-1][j];
	//dp判断最大全0正方形，同P1387 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(df2[i][j]==0)
			{
				if(F[i-1][j]>=F[i-1][j-1]&&F[i][j-1]>=F[i-1][j-1])
					F[i][j]=F[i-1][j-1];
				else
					F[i][j]=min(F[i-1][j],F[i][j-1]);
				F[i][j]++;
			}
	int x,y,k;
	char ans;
	for(int i=1;i<=t;i++)
	{
		cin>>x>>y>>k;
		//单次查询 只需右下 k-1 大小的正方形全为 0 
		//即所选正方形右下角的最大全零正方形尺寸大于 k-1 
		if(F[x+k-1][y+k-1]>=k-1)
			ans='Y';
		else
			ans='N';
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P4030 题目](https://www.luogu.com.cn/problem/P4030)

### 解体思路
不难发现，如果一个方阵是巧妙的，当且仅当它所有的 $2$ 阶子方阵也都是巧妙的。

证明：如果一个以第 $x$ 行第 $y$ 列为左上角 $k$ 阶方阵是巧妙的，那么它一定满足：

$$M_{x,y}+M_{x+1,y+1}+M_{x+2,y+2}+\cdots+M_{x+k-1,y+k-1}=M_{x+1,y}+M_{x,y+1}+M_{x+2,y+2}+\cdots+M_{x+k-1,y+k-1}$$

抵消后得：$M_{x,y}+M_{x+1,y+1}=M_{x+1,y}+M_{x,y+1}$，即以第 $x$ 行第 $y$ 列为左上角 $2$ 阶方阵必须是巧妙的，以此类推，可以推算出所有的 $2$ 阶子方阵也都必须是巧妙的。

用二维前缀和 $s_{i,j}$ 维护以第 $1$ 行第 $1$ 列为左上角，第 $i$ 行第 $j$ 列为右下角的矩阵有多少个巧妙的 $2$ 阶子方阵即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[501][501],s[501][501],pd[501][501];
signed main()
{
	ios::sync_with_stdio(false);
	int n,m,t;
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	}
	for(int i=1;i<n;i++)
	{
		for(int j=1;j<m;j++)
		{
			if(a[i][j]+a[i+1][j+1]==a[i+1][j]+a[i][j+1])
				pd[i][j]=1;
		}
	}
	for(int i=1;i<n;i++)
	{
		for(int j=1;j<m;j++)
		{
			if(i==1)
			{
				s[i][j]=s[i][j-1]+pd[i][j];
				continue;
			}
			if(j==1)
			{
				s[i][j]=s[i-1][j]+pd[i][j];
				continue;
			}
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+pd[i][j];
		}
	}
	while(t--)
	{
		int x,y,k;
		cin>>x>>y>>k;
		if(k==1)
		{
			cout<<"Y\n";
			continue;
		}
		int ss=s[x+k-2][y+k-2]-s[x-1][y+k-2]-s[x+k-2][y-1]+s[x-1][y-1];
		if(ss==(k-1)*(k-1))
			cout<<"Y\n";
		else
			cout<<"N\n";
	}
	return 0;
}
```

---

## 作者：lqsy002 (赞：0)

## 题目大意
对于任何一个 $n$ 阶方阵，若任意从其中选择 $n$ 个不同行不同列的位置，其上的权值之和均相等，则我们称这个矩阵是巧妙的。现在有一个 $n\times m$ 大小的矩阵以及 $T$ 个询问，每次询问其一个子方阵是否是巧妙的。[题目链接](https://www.luogu.com.cn/problem/P4030)。
## 解题思路
可以发现一个矩阵是巧妙矩阵当且仅当其所有二阶子矩阵都是巧妙矩阵。

将不巧妙的二阶矩阵计为 $1$，维护二维前缀和，查询得出当前范围内不巧妙二阶矩阵的个数，若为 $0$ 则大矩阵是巧妙矩阵。
## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,f[505][505],a[505][505],x,y,k;
int main(){
    scanf("%d%d%d",&n,&m,&t);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            scanf("%d",&a[i][j]);
            if(i>=2&&j>=2)
		f[i][j]=f[i][j-1]+(a[i][j]+a[i-1][j-1]!=a[i-1][j]+a[i][j-1]);
        }
    for(int i=2;i<=n;i++)
        for(int j=2;j<=m;j++)
            f[i][j]+=f[i-1][j];
    while(t--){
        scanf("%d%d%d",&x,&y,&k);
        if(f[x+k-1][y+k-1]-f[x][y+k-1]-f[x+k-1][y]+f[x][y])
		printf("N\n");
        else 
		printf("Y\n");
    }
    return 0;
}
```

---

## 作者：Tx_Lcy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4030)
## 思路
给出一种非常暴力的做法。

考虑对于每一个 $2 \times 2$ 的矩阵，设这个矩阵左下角的坐标为 $(x,y)$，假设以 $(1,1)$ 为左下角，$(x,y)$ 为右上角的矩阵已经选过了。那么接下来有两种选择：

+ 选择 $2 \times 2$ 矩阵的左上角+右下角。
+ 选择 $2 \times 2$ 矩阵的右上角+左下角。

容易发现，要使得答案合法，这个 $2 \times 2$ 矩阵的对角线之和要相等。

由于 $n,m$ 很小，所以不需要前缀和，直接暴力即可。

时间复杂度 $O(nmt)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=5e2+10;
int a[N][N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int n,m,t;cin>>n>>m>>t;
	for (int i=1;i<=n;++i)
	    for (int j=1;j<=m;++j)
	        cin>>a[i][j];
	while (t--){
		int x,y,k;cin>>x>>y>>k;
		int xx=x+k-1,yy=y+k-1,tag=0;
		for (int i=x;i<xx;++i)
		    for (int j=y;j<yy;++j)
		    	if (a[i][j]+a[i+1][j+1]!=a[i+1][j]+a[i][j+1]){tag=1;break;}
	    if (!tag) cout<<"Y\n";
	    else cout<<"N\n";
	}
	return 0;
}
```


---

## 作者：书雪 (赞：0)

问题描述的很清楚：

对于任何一个 $n$ 阶方阵，若任意从其中选择 $n$ 个不同行不同列的位置，其上的权值之和均相等，则我们称这个矩阵是巧妙的。

让我们来做一个代数推理：

当 $n=1$ 时，很明显方针巧妙。

当 $n=2$ 时，方阵为：

$x1$ $x2$ 

$x3$ $x4$

则当 $x1+x4=x2+x3$ 时方阵巧妙。

当 $n=3$ 时，方阵为：

$x1$ $x2$ $x3$

$x4$ $x5$ $x6$

$x7$ $x8$ $x9$

按照 $n=2$ 时的想法，如果 

$a1$ 式子 $:x1+x5=x2+x4$ 

$a2$ 式子 $:x2+x6=x3+x5$

$a3$ 式子 $:x4+x8=x5+x7$ 

$a4$ 式子 $:x5+x9=x6+x8$ 

即每个二维矩阵均巧妙时，可以由 $ a1+a4-a2-a3(x1+x5+x5+x9=x2+x4+x6+x8 , x3+x5+x5+x7=x2+x4+x6+x8)$

推出： $x1+x5+x9=x3+x5+x7$ ；

由 $ a2+a3 (x2+x6+x5+x7=x3+x5+x4+x8) $ 

推出： $x2+x6+x7=x3+x4+x8$ ；

由 $ a1+a4 (x1+x5+x6+x8=x2+x4+x5+x9)$ 

推出： $x1+x6+x8=x2+x4+x9$ ；

由 $ a1,a2,a3,a4 $ 随意一个式子（拿 $a1$ 举例子） 

由$ x1+x5+x9=x2+x4+x9 $ 推出以上 $6$ 个式子相等，同理易得这个猜想正确

这份简单的代码时间复杂度为 $n*m*T$ （居然能过）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,T,a[510][510],c[510][510][510],b[510][510];
int main(){
	scanf("%lld%lld%lld",&n,&m,&T);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%lld",&a[i][j]);
		}
	}
	for(int W=1;W<=T;W++){
		int x,y,k,p=0;
		scanf("%d%d%d",&x,&y,&k);
		for(int i=x;i<x+k-1;i++){
			for(int j=y;j<y+k-1;j++){
				if(a[i][j]+a[i+1][j+1]!=a[i+1][j]+a[i][j+1]){
					p=1;
					break;
				}
			}
			if(p==1) break;
		}
		if(p==1){
			printf("N\n");
			continue;
		}
		printf("Y\n");
	}
	return 0;
}

```

前面的题解应该没有解析式子的，这篇补上


---


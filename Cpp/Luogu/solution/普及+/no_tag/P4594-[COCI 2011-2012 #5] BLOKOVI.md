# [COCI 2011/2012 #5] BLOKOVI

## 题目描述

平面直角坐标系种有 $N$ 个质量为 $m_{i}$ ，长为 $2$，高为 $h$ 的矩形，使得：

* 矩形的边缘与坐标轴平行；
* 矩形的下层与 $y$坐标不重合，且为以下值：$0,h,2h,3h,\dots,(N-1)h$；
* 最低的矩形左下角的坐标为 $(-2,0)$，右下角与原点重合。

![](https://cdn.luogu.com.cn/upload/image_hosting/rjzp667k.png)

定义一个矩阵的 X 中心是其下边的中点的 X 坐标。一个或多个矩形的 X 中心是其 X 中心的加权平均值。它的计算方法为：

$$
Xbarycetre=\frac{\sum_{i}m_{i}\times Xcentre(i)}{\sum_{i}m_{i}}
$$

其中 `Xbarycetre` 表示一个或多个矩形的 X 中心，`Xcentre` 表示一个矩阵的 X 中心。

换句话说，其值为每个矩形的质量乘以它的 X 中心之积除以矩形的总质量。

对于每一个矩形，如果它**上面的矩形**的 X 中心与其的 X 中心的距离小于等于 $1$，则称这些矩形组成的排列是稳定的。

例如，左图的排列是不稳定的，因为上面两个矩形的 X 中心到下面的矩形的X中心的距离大于 $1$。而右图的排列是稳定的。

给出所有矩形的质量，求其可以组成的稳定排列中的矩形的最大 X 坐标。

你不能改变矩形的顺序，它们从**基本**低到高给出。

## 说明/提示

有 $30\%$ 的数据，矩形的质量从大到小给出。

$2\le N\le 3\times 10^{5}$，$1\le m_{i}\le 10^{4}$。

题目译自 [COCI 2011/2012 #5 T5](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
2 
1 
1
```

### 输出

```
1.00000000```

## 样例 #2

### 输入

```
3
1 
1 
1
```

### 输出

```
1.50000000```

## 样例 #3

### 输入

```
3 
1 
1 
9
```

### 输出

```
1.90000000```

# 题解

## 作者：decoqwq (赞：11)

考虑贪心，考虑每次从上往下加入一个块，新块 $i$ 的贡献是 $\frac{m_i}{\sum m}$，代表新 $x$ 重心的移动量，考虑贪心的选择向左或者向右，每次在原最右边 $+\Delta$ 或者向左移动变为 $2-\Delta$，最后取最靠右的答案即可。

```cpp
#include <bits/stdc++.h>
#define maxn 300010
using namespace std;
int n,a[maxn];
double sum,ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
    }
    for(int i=n;i>1;i--)
    {
    	int qwq=a[i];
    	a[i]+=a[i+1];
        double del=double(qwq)/double(a[i]);
        ans=max(ans,max(ans+del,2-del));
    }
    printf("%.8lf",ans);
}
```

---

## 作者：whiteqwq (赞：5)

[P4594 [COCI2011-2012#5] BLOKOVI](https://www.luogu.com.cn/problem/P4594)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1793664)

## 题意

从下到上有$n$个矩形，重量分别为$m_{1\cdots n}$，以最下面矩形右下角为原点建立坐标系，那么定义一个矩形的重心$c(i)$为过其几何重心平行于$y$轴的直线，一个矩形前缀的重心为直线$x=\frac{\sum(m_i\cdot c(i))}{\sum m_i}$。

定义一种摆放方式合法当且仅当任意矩形的重心与其上方的矩形前缀的重心水平距离不超过$1$，求出矩形右端点$x$值最大值能取到的最大值。

$1\leqslant n\leqslant 3\times 10^5$。

## 分析

神仙题。

从下到上一个个考虑显然会产生后效性，因此从上到下讨论。

设现在到了第$i$个矩形，之前的矩形（不包括$i$）重量和为$tot$，之前的矩形的重心与当前矩形左端点的水平距离为$dis$（这是需要决策的值），前$i-1$个矩形右端点与它们的重心距离最大值为$d$。

容易知道新的重心与左端点的距离为$\frac{tot\cdot dis+m_i\cdot 1}{m_i+tot}$，前$i$个矩形右端点与左端点的距离最大值为$\max\{2,dis+d\}$

因此可以知道前$i$个矩形右端点与重心距离的最大值为

$$\max\{2,dis+d\}-\frac{tot\cdot dis+m_i}{m_i+tot}=\frac{\max\{2(m_i+tot),(dis+d)(m_i+tot)\}-tot\cdot dis-m_i}{m_i+tot}\\=\frac{\max\{(2-dis)\cdot tot+m_i,(dis-1)\cdot m_i+(m_i+tot)\cdot d\}}{m_i+tot}$$

易知$\max$左边的是随$dis$增加单调减少的，$\max$右边的是随$dis$增加单调增加的，因此在允许的情况下，$dis$会尽可能取大或取小。

可以计算出矩形$i$为底部时上一个的矩形的左端与当前矩形的左端水平距离最大值为$\frac{m_i}{tot}$，那么在右边放可以让当前的答案增加这个值。

如果放在右边，那么我们考虑两个矩形夹住当前矩形，那么至少要夹住$\frac{m_i}{tot}$长度的矩形才能保证平衡，那么当前右端为$2-\frac{m_i}{tot}$。

这样贪心下去就好了，时间复杂度：$O(n)$。

但是到这里其实我还是有一点疑惑，希望以后这道题的贪心有更好的解释。

## 代码
```
#include<stdio.h>
const int maxn=300005;
int n;
long long tot;
double ans;
int m[maxn];
inline double max(double a,double b){
	return a>b? a:b;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&m[i]);
	for(int i=n;i>1;i--)
		ans=max(ans,max(ans+1.0*m[i]/(m[i]+tot),2.0-1.0*m[i]/(m[i]+tot))),tot+=m[i];
	printf("%.8lf\n",ans);
	return 0;
}
```

---

## 作者：Mu_leaf (赞：2)

**[题目描述]**

给出 $n$ 个矩形，求其可以组成的稳定排列中的矩形的最大 $X$ 坐标。

**[思路]**

### 前言:
对于本蒟蒻而言，题目给的这个公式根本~~没看懂~~，于是我就套用的我们教练的思路[欸嘿]。

### step:
可以先简化问题，将题目的多个矩形换成先去推演 $2$ 个矩形的重心规律。为了可以更直观的去推演公式我们将矩形换成球来解决，图示如下：![](https://cdn.luogu.com.cn/upload/image_hosting/oqsp4yvb.png)

 $PS$ ： $m1$ 和 $m2$ 同时分别代表左小球和右小球的质量，$L1$ 和 $L2$ 分别代表 $m1$ 和 $m2$ 到重心的距离。

在只有 $2$ 个球的情况下可以发现有 $ 3 $ 种可能：


------------

### NUM1：
当 $ m1=m2 $ 时，也就是 $2$ 球重量相等时，

所以左小球到重心的距离为：

 $$\frac{m1}{m1+m2}\times L=\frac{m1}{m1+m1} \times L= \frac{1}{2} \times L$$ 

当 $m1 \geq m2$ 时，也就是 $m1$ 相较于 $m2$ 较重时：
$$ \frac{m1}{m1+m2} \geq \frac{1}{2}$$ 

所以不成立，考虑将 $m1$ 改成 $m2$，发现和图示符合。

### NUM2：
OK，现在我们将数量 $2$ 换成 $3$ 甚至更多！

我们将加入的第三个称为 $m3$，可以先求出 $m1$ 和 $m2$ 的重心，再在重心处与 $m3$ 作链接做出另一条 $L$，以此类推。

### NUM3：

现在，我们将球体更换为矩形，也就是回归题目，发现矩形向上堆叠会出现两种情况！

也就是：

![](https://cdn.luogu.com.cn/upload/image_hosting/lgj62sm9.png)

和

![](https://cdn.luogu.com.cn/upload/image_hosting/zmloqrcj.png)

为了处理的方便，以我们教练的话说就是逆向思维。

我们从上至下进行堆叠，

这时新加入的矩形的贡献的 $x$ 为 $ \frac{m_i}{\sum m} $。

 $2$ 种情况，考虑贪心，

第一种的贡献值是最右边 $+\Delta$ 或者第二种的贡献值为 $2-\Delta$。

最后本题就可以愉快的 $AC$ 啦！




```cpp
#include <bits/stdc++.h>

using namespace std;

double a[300005],f[300005];
int main(){
	long long n,sum=0;
	cin >> n;
	for(int i=1;i<=n;i++) cin >> a[i];
	for(int i=n;i>=2;i--){
		sum+=a[i];
		double g=a[i]/sum;
		f[i]=max(f[i+1]+g,2-g);
	} 
	printf("%.6lf",f[2]);
	return 0;
}

```
杜绝抄袭哦！

管理求过，本蒟蒻的第一篇题解......

---

## 作者：lllyyykkk (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P4594)
这题可以考虑贪心。

在加块过程中，从低往高加并不是很好处理，所以把整个过程逆过来，考虑每一个块对重心的贡献应该是 $\frac {m_i}{\sum_m}$。  
此时，对所有贡献贪心地选择向左或者向右偏离，因为向右可以使答案最大，而向左偏移可以尽量减小 $X$,使之后更大的块可以向右放置，进而使答案最大化。

代码并不难写，但记住一定要保留 $8$ 位小数，本蒟蒻因为一开始保留了 $10$ 位成功爆零。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int n,a[N];
double ans;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=n;i>1;i--){
		int x=a[i];
		a[i]+=a[i+1];
		double xx=1.0*x/a[i];
		ans=max(ans+xx,2-xx);
	}
	printf("%.8lf",ans);
    return 0;
}
``````

---

## 作者：Rose_Melody (赞：0)

## Solution - P4594 BLOKOVI

[题目传送门](https://www.luogu.com.cn/problem/P4594)

### 题目分析

一道简单的**贪心**题目。

我们会想到从上面往下面放入矩形，也就是从后往前。当即将放入第 $i$ 个矩形的时候，我们不妨假设前 $i - 1$ 个矩形的重心为 $0$，那么，矩形 $i$ 就会使这 $i$ 个的重心改变 $m_{i} \div \sum_{i}$。

矩形可以放在上一个矩形的左边或右边，递推方程就是：
$$\max(ans + m_{i},2 - m_{i})$$

### AC Code


```cpp
#include <bits/stdc++.h>
#define int long long 
#define double long double 
using namespace std;
const int N = 3e5 + 5 ;
int n , a[N] ;
double ans ; 
signed main()
{
//	freopen(".in" , "r" , stdin);
//	freopen(".out" , "w" , stdout); 
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0); 
	cin >> n ;
	for(int i = 1;i <= n;i ++){
		cin >> a[i] ;
	}
	for(int i = n;i > 1; i --){
		int t = a[i] ;
		a[i] += a[i + 1] ;
		double d = 1.0 * t / a[i] ;
		ans = max(ans + d , 2 - d) ;
	}
	cout << fixed << setprecision(10) << ans << '\n' ; 
	return 0;
}
```

---

## 作者：Tyih (赞：0)

# Sulotion
可以考虑从上往下加入矩形。假设前 $i-1$ 个矩形的重心为0，则对于每一次加入的矩形 $i$，会使这 $i$ 个矩形的重心改变 
$ \frac{m_{i}}{\sum_{i}m_{i}} $。 

因为每一次加入的矩形可以放上一个矩形的左边或右边。所以最终得到重心的最大值为
 $ \max(g+Δg_i,2-Δg_i)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m[300005],sum;
double g;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	    cin>>m[i];
	for(int i=n;i>1;i--){
		sum+=m[i];
		double dg=double(m[i])/double(sum);
		g=max(2-dg,g+dg);	
	}
	printf("%.8lf",g);
	return 0;
}
```

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P4594)。

## 解题思路

考虑从下往上放，相当于插入。

当插入最底下的矩形时，因为这个矩形不变，所以上方的 $n-1$ 个矩形越靠右越优。

最优情况是上方的 $n-1$ 个矩形的重心恰好在最底下的矩形右端点，此时答案就是最右端点到重心的距离。
 
## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 300005
using namespace std;
int n;
double m[maxn],sum,delta,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
		scanf("%lf",&m[i]);
    for(int i=n;i>1;--i){
        sum+=m[i];
        delta=m[i]/sum;
        ans=max(ans,max(ans+delta,2-delta));
    }
    printf("%.8lf",ans);
	return 0;
}
```

---

## 作者：Thunder_S (赞：0)

## Solution

先上结论，当我们从上往下做的时候，对于第 $i$ 个块，他对重心的移动量为 $\frac{m_i}{\sum m}$。

考虑证明，考虑当前为第 $i$ 个块，设 $i+1\sim n$ 的块的重心为 0，那么加入第 $i$ 个块后的重心为 $\frac{\sum_{j=i}^na_j\times m_j}{\sum m}=\frac{0+a_i\times m_i}{\sum m}$，而 $a_i$ 不是 1 就是 -1，所以加入第 $i$ 个块后对于重心的改变量为 $\frac{m_i}{\sum m}$。

## Code

```cpp
#include<cstdio>
#include<algorithm>
#define N 300005
#define db double
using namespace std;
int n,s,a[N];
db ans;
int read()
{
    int res=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch-'0'),ch=getchar();
    return res;
}
int main()
{
    n=read();
    for (int i=1;i<=n;++i)
        a[i]=read();
    for (int i=n;i>1;--i)
    {
        s+=a[i];
        db x=db(a[i])/db(s);
        ans=max(ans,max(ans+x,2-x));
    }
    printf("%.6lf",ans);
    return 0;
}
```



---


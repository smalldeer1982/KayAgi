# [COCI 2012/2013 #6] JEDAN

## 题目背景

COCI

## 题目描述

有$N$个数排成一行(数值代表高度)，最初所有的数都为零，你可以选择连续的一段等高的数，将它们都增加$1$(除了开头和结尾那个数)如下图表示了两次操作:

![](https://cdn.luogu.com.cn/upload/pic/19412.png)

现在有一些数字看不清了，我们用$-1$表示，请你根据留下的数字，推出有多少
种可能的方案。使得留下的数字正好满足上面的操作方法。


## 说明/提示

- $(1≤N≤10000)$
- $(-1 ≤ h_i ≤10 000)$

## 样例 #1

### 输入

```
3
-1 2 -1```

### 输出

```
0```

## 样例 #2

### 输入

```
3
-1 -1 -1```

### 输出

```
2```

## 样例 #3

### 输入

```
6
-1 -1 -1 2 -1 -1```

### 输出

```
3```

# 题解

## 作者：浅色调 (赞：12)

### Solution：

　　本题DP。

　　首先由题意不难确定一些性质：

　　　　1、合法情况首尾一定为0

　　　　2、最高高度小于$n/2$

　　　　3、由2可以确定的是第$i$位高度：当$i\leq n/2$，$h_i$最高为$i-1$; 当$i>n/2$，$h_i$最高为$n-i$

　　　　4、由于每次选择的是一段长度大于2的相等且连续的序列，而操作使$(l,r)+1$，所以相邻两位之差$\in[-1,1]$

　　然后就好做了。

　　考虑普通dp，定义状态$f[i][j]$表示第$i$位高度为$j$的方案数，那么由性质1确定初状态$f[1][0]=1$，目标状态为$f[n][0]$。

　　由性质4的邻位高度差绝对值$\leq 1$，不难得到状态转移方程：$f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1]$

　　转移时对于高度确定的就单次转移，否则就枚举**可行高度**并转移。

　　这样定义状态会炸空间，但是每次转移只与前一个数的状态有关，所以直接滚掉就好了。

$\quad\;\;$欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/9588934.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！～）

### 代码：
```cpp
/*Code by 520 -- 9.4*/
#include<bits/stdc++.h>
#define il inline
#define ll long long 
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const int mod=1e9+7;
int n,a[10005],f[2][10005],cnt,siz;

int main(){
    scanf("%d",&n);
    For(i,1,n) scanf("%d",&a[i]);
    if(a[1]>0||a[n]>0) cout<<0,exit(0);
    a[1]=a[n]=0,f[1][0]=1,siz=2;
    while(siz<=n){
        int up=siz;
        if(siz>n/2) up=n-siz+1;
        For(i,0,up-1) if(a[siz]==-1||i==a[siz]) 
            f[cnt][i]=((ll)(i?f[!cnt][i-1]:0)+f[!cnt][i]+f[!cnt][i+1])%mod;
        cnt^=1,++siz;
        memset(f[cnt],0,sizeof(f[cnt]));
    }
    cout<<f[!cnt][0];
    return 0;
}
```

---

## 作者：naoliaok_lovely (赞：4)

## 题目大意
题意其实算得上是比较清楚的了，就是在一段区间中选择一段连续的，然后让它们的高度$+1$（端点不能选）。不懂的模拟一下样例就行了。

![](https://cdn.luogu.com.cn/upload/pic/19412.png)

注意，下面的情况不能出现：

![](https://cdn.luogu.com.cn/upload/image_hosting/m1muhu9s.png)

# Solution
~~最开始本蒟蒻看到这个题也不会，看了很多大神的题解。（膜拜大神）(〃'▽'〃)~~

很显然，这道题是一道 DP ，但是 DP 的的状态比较难确定（不得不说COCI的题是真的不错）。从刚刚的例子我们其实可以通过观察得到，第一个和最后一个必然是0，否则直接输出无解。对于当前的每一个位置，最开始都是0，即相等。对于每一次操作，对于高度相等的  $i$ 和 $i+1$ ，我们可以讨论一下：

------------
①.如果 $i$ 和 $i+1$ 的高度一起 $+1$ ，则它们的高度仍然相等。

②.如果i的高度 $+1$，$i+1$ 不变，则最终的 $i$ 仍然比 $i+1$ 高1个单位。这是因为此时，$i$ 为右端点（对于左半边的区间而言），即 $i$ 的高度再也无法改变；而 $i+1$ 为左端点，所以 $i+1$ 的高度也无法改变。也就是说，之后的操作一定是不会影响到这两个位置的。

③.如果 $i+1$ 的高度$+1$，$i$ 不变，则最终的 $i+1$ 仍然比 $i$ 高1个单位。（道理同上）

------------
综上，我们得出结论：
$$ \text{相邻的两个位置，它们的高度差 } \le 1 \text{。}$$

剩下的就很简单了：定义状态 $f[i][j]$ 表示第i个位置的高度为j的情况数。初始化就是 $f[1][0]=1$，要输出的是 $f[n][0]$。

对于每一个位置 $i$，能达到的最大高度显然是：
$size = i - 1 (i \le n \div 2) \text{ 或者 } size = n - i (i > n \div 2)$。
如果当前位置是 $-1$，就去循环 $0 \sim size$；如果题目给定了就去分类讨论：$ \le size$ 就计算情况数，反之直接输出0。

其实本蒟蒻也写过一种直接暴算的做法，即循环枚举 $0 \sim size$，懒得算 $size$。但这样有个很严重的问题：对于那些题目给定的高度，我们只能通过判断情况数是否为 0 来看能否达到这个高度，这样的话就不能随便取模（因为有可能模完为 0），就只能算完之后整体取模。但 $n$ 太大了，导致 long long 都装不下答案。所以这个题必须要一边处理 $size$ 一边做。

最后还有一个所有题解都提到的滚动数组啦（没学过的看代码）。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 10010, mod = 1000000007;
int n, a[N];
LL f[2][N];

int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	if(a[1] > 0 || a[n] > 0)
	{
		cout << 0 << endl;
		return 0;
	}
	
	f[1][0] = 1;
	for(int i = 2, now = 0; i <= n; i++, now = !now)
	{
		memset(f[now], 0, sizeof(f[now]));
		
		int size = (i <= n / 2 ? i - 1 : n - i);
		if(a[i] != -1)
		{
			if(a[i] > size)
			{
				cout << 0 << endl;
				return 0;
			}
			f[now][a[i]] = ((a[i] >= 1 ? f[!now][a[i] - 1] : 0) + f[!now][a[i]] + f[!now][a[i] + 1]) % mod;
			continue;
		}
		for(int j = 0; j <= size; j++)
			f[now][j] = ((j >= 1 ? f[!now][j - 1] : 0) + f[!now][j] + f[!now][j + 1]) % mod;
	}
	cout << f[n & 1][0] << endl;
	return 0;
}

```


---

## 作者：Sym_Je (赞：3)

           较难考虑的dp     
           
  [P4622 [COCI2012-2013#6] JEDAN](https://www.luogu.org/problemnew/show/P4622)   
  
  首先我们先分析一下这个题，以发现已下几个特征    
  1.其中最大值为n/2，且之可能出现在中间。    
  2.开头和结尾只能为0。    
  3.第i个位置可能的最大值就是min(i-1,n-i)。   
  4.相邻两个最大只能差一。   
  解释4     
  因为只能将一段大小相同的一段不包括两边+1,   
  比如    
     *   
     * 
  0  2  0  就不可能。  刚开始为0 0 0 ，只能将中间的0加1，或不加，之后就为0 1 0，或0 0 0 ，然后0 1 0，就无法再加了，因为1为1这一段的结尾和开头么根据题意无法加。    
 
       。       
     。。。      
0   1 2 1 0    

0 1 2 1 2 1 0

就可以，所以只有可能从前面与他差小于1的地方转移    
因此我们设dp[i][j]为前i行第i行为j的可能数量    
dp[i][j]=dp[i-1][j-1]+dp[i-1][j]+dp[i-1][j+1]。   

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<string>

using namespace std;

const int mod=1e9+7;

int dp[2][50001];
int a[50001];
int n;

int cnt=0,siz=2;

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	if(a[1]>0||a[n]>0)
	{
		printf("0\n");
		return 0;
	}
	dp[1][0]=1;
	while(siz<=n)
	{
		int up=siz;
		if(up>n/2)
		{
			up=n-up+1;
		}
		for(int i=0;i<=up-1;i++)
		{
			if(a[siz]==i||a[siz]==-1)
			{
				dp[cnt][i]=((long long)(i?dp[cnt^1][i-1]:0)+dp[cnt^1][i]+dp[cnt^1][i+1])%mod;
			}
		}
		cnt=cnt^1;
		siz++; 
		memset(dp[cnt],0,sizeof(dp[cnt]));
	}
	printf("%d",dp[cnt^1][0]);
	return 0;
}
```
 
 

        
  
  
 
  
  
  
  

---

## 作者：ycy1124 (赞：2)

### 题意
感觉很好理解，需要注意的是每次选择修改的区间不能包含那一段相等的数的两端。
### 思路
不难发现相邻的两个数的差的绝对值小于等于 $1$ 且 $n\times h_i\le10^8$，于是考虑 dp。

转移方程很好推，这里给出式子，即从所有可能到来的情况转移：
$$
dp_{i,j}=dp_{i,j-1}+dp_{i,j}+dp_{i,j+1}
$$
当 $h_i=-1$ 时转移 $0\sim \frac{n}{2}$ 所有的数，否则只转移 $h_i$。注意特判 $h_1$ 和 $h_n$ 不等于 $0$，以及要用滚动数组。最终答案输出 $dp_{n,0}$。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define md 1000000007
using namespace std;
int n,h[10005];
int dp[2][10005];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>h[i];
    }
    if(h[0]>0||h[n]>0){//特判
        cout<<0;
        return 0;
    }
    dp[0][0]=1;
    for(int i=2;i<=n;i++){
        for(int j=0;j<=n/2;j++){//滚动不清空，爆零两行泪
            dp[(i-1)%2][j]=0;
        }
        if(h[i]==-1){
            for(int j=0;j<=n/2;j++){
                if(j!=0){
                    dp[(i-1)%2][j]=dp[i%2][j-1]+dp[i%2][j]+dp[i%2][j+1];
                }
                else{
                    dp[(i-1)%2][j]=dp[i%2][j]+dp[i%2][j+1];      
                }
                dp[(i-1)%2][j]%=md;
            }
        }
        else{
            if(h[i]!=0){
                dp[(i-1)%2][h[i]]=dp[i%2][h[i]+1]+dp[i%2][h[i]]+dp[i%2][h[i]-1];
            }
            else{
                dp[(i-1)%2][h[i]]=dp[i%2][h[i]]+dp[i%2][h[i]+1];
            }
            dp[(i-1)%2][h[i]]%=md;
        }
    }
    cout<<dp[(n-1)%2][0]; //输出
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/198525414)

---

## 作者：Listedzero (赞：1)

### 题目分析

*“选择连续的一段等高的数，将它们都增加 $1$，除了开头和结尾那个数。”*

题意表述和样例可能会让你自然的从下到上，去模拟一层层往上叠的这个过程。实际上，在简单模拟样例后，我们发现这样是不利于进一步的思考与编码的。所以我们可以试着从左到右去看，把题目中一层层高度叠加的这种性质转化为每一列之间高度的关系。

由此可以想到，这个性质，可以等价于**相邻两柱体的高度之差小于等于一个单位长度**。

想到这里，我们大概已经知道这需要使用动态规划，实现上有点类似于找路径条数。

继续完善：

- 在遇到已经给出高度的列上，由于已经限定其高度，所以只能更新此高度上的点，其它高度上需归零；
- 空间优化上，可以采用滚动数组的方式，但是最后答案关于滚动数组是需要输出滚动前的，因为给出的数据可能会存在 $N = 1$ 的情况。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int n,mod=1000000007;
int h[N],f[2][N];
//f[0][x]上一轮数据
//f[1][x]更新的数据
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>h[i];
	if(h[1]>0||h[n]>0){
		cout<<0;
		return 0;
	}
	f[0][0]=1;
	for(int i=2;i<=n;i++){
		if(h[i]!=-1){
			f[1][h[i]]=(f[0][h[i]]+f[0][h[i]+1])%mod;
			if(h[i]>0) f[1][h[i]]=(f[1][h[i]]+f[0][h[i]-1])%mod;
			for(int k=0;k<=n/2;k++) f[0][k]=0;
			f[0][h[i]]=f[1][h[i]];
		}
		else{
			for(int j=0;j<=n/2;j++){
				f[1][j]=(f[0][j]+f[0][j+1])%mod;
				if(j>0) f[1][j]=(f[1][j]+f[0][j-1])%mod;
			}
		for(int j=0;j<=n/2;j++) 
			f[0][j]=f[1][j];
		}
	}
	cout<<f[0][0]%mod;//不是f[1][0]
	return 0;
}
```

---

## 作者：jidao_wansui (赞：1)

这是一道 dp 题。

首先观察数据，可以发现几个性质：

- $h_1$ 和 $h_n$ 一定为 $0$。
- $\displaystyle\max_{i = 1}^{n} h_i < \displaystyle\frac{n}{2}$。
- 当 $i \le \displaystyle\frac{n}{2}$ 时，$h_i$ 最大为 $i - 1$。当 $i > \displaystyle\frac{n}{2}$ 时，$h_i$ 最大为 $n - i$。
- 因为每次是选择长度大于 $2$ 的区间 $\begin{bmatrix} l, r \end{bmatrix}$ 增加 $1$，所以所有 $2 \le i \le n$，$|h_i - h_{i - 1}| \le 1$。

我们可以根据以上性质构造 dp。

设 $dp_{i, j}$ 表示使 $h_i = j$ 的方案数。

可以根据以上性质发现 $dp_{1, 0} = 1$，$dp_{n, 0}$ 为目标状态。

可以根据以上性质构造状态转移方程：$dp_{i, j} = dp_{i - 1, j - 1} + dp_{i - 1, j} + dp_{i - 1, j + 1}$。

若 $h_i$ 不确定，就枚举合法高度 $j$ 计算 $dp_{i, j}$。

若 $h_i$ 确定，直接计算 $dp_{i, j}$ 即可。

最后输出 $dp_{n, 0}$。

注意要用滚动数组，不然会爆空间。

**不开 long long 见祖宗。**

[AC Code](https://www.luogu.com.cn/paste/lq3r9fcj)

---

## 作者：_qumingnan_ (赞：1)

[题目跳楼机](https://www.luogu.com.cn/problem/P4622)

# 正文开始

## 阅读理解

一个表格，可以选择高度相等的一段长度，将除第一个与最后一个以外的高度加一，现给你表格中的一些高度，求这个表格有多少种不同的可能。

## 思路

一道 $DP$ 题，因为区间的首位和末位不会被加，所以形成的序列中，相邻的两个数相差不会超过 $1$。

有了这个性质后，我们就可以得到 $DP$ 转移方程。记 $i$ 为列，$j$ 为高度，于是有：

- $dp_{i,j}=dp_{i-1,j+1}+dp_{i-1,j}+dp_{i-1,j-1}$

其中 $dp_{i-1,j+1}$ 代表了上一列比自身高的情况数，$dp_{i-1,j}$ 代表了上一列和自身一样高的情况数，$dp_{i-1,j-1}$ 代表了上一列比自身低的情况数。

需注意，当当前这一列的高度是确定的的时候，那么 $j$ 的值便是固定的。

如何求值解决了，但是 `dp[10005][10005]` 的大小，空间是承受不住的（这里卡了我好久），那就需要滚动一下，这个问题就完美解决了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1000000007;
int n;
int dp[2][10005];
int ans;
signed main(){
	freopen("JEDAN.in","r",stdin);
	freopen("JEDAN.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	dp[0][1]=1;
	for(int i=1;i<=n;i++){
		int x;cin>>x;
		int ii=i&1,ma;//滚动 
		if(i<=n/2)ma=i;else ma=n-i+1;
		for(int j=1;j<=ma;j++)
			if(x==-1||j==x+1)dp[ii][j]=(dp[!ii][j-1]+dp[!ii][j]+dp[!ii][j+1])%mod;
			else dp[ii][j]=0;
	}
	cout<<dp[n%2][1];
	return 0;
}
```

---

## 作者：__FL__ (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4622)

[更好的阅读体验](https://www.luogu.com.cn/article/29dvptix)

## 分析
简单观察，不难看出，一个合法的 $h$ 序列具有如下性质：

$$ \forall i \isin [1,n),|h_i-h_{i+1}| \leq 1$$

$$h_1=h_n=0$$

首先易得两个相邻元素之差一定 $<2$，必要性显然；那么我们从第一个元素为 $0$ 往后推，可以用类似线性 dp 的做法，使用 $f_{i,j}$ 表示第 $i$ 个位置数字为 $j$，设置转移方程：
$$
f_{i,j} = \begin{cases}
  f_{i-1,j-1}+f_{i-1,j}+f_{i-1,j+1} & j>0 \\
  f_{i-1,j}+f_{i-1,j+1} & j=0
\end{cases}
$$
当然如果第 $i$ 个位置已经指定了数，$j$ 就直接固定为这个数就好了，并且初始化 $f_{1,0}$ 为 $1$，$i$ 从 $2$ 开始枚举。

注意空间限制，易知一个长度为 $n$ 的序列中的元素最大为 $\frac{n}{2}$，那么 $f$ 数组应开到 $5\times 10^7$ 的量级，开不下，注意到每次转移只会用到 $i-1$，要开滚动数组。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 1e9+7;
int n,a[10005],f[2][5005];
int main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	f[1][0] = 1;
	for (int i = 2; i <= n; i++) {
		memset(f[i&1],0,sizeof f[i&1]);
		if (a[i] != -1) (f[i&1][a[i]] += (0ll+(a[i]>0?f[i+1&1][a[i]-1]:0)+f[i+1&1][a[i]]+f[i+1&1][a[i]+1])%M) %= M;
		else for (int j = 0; j <= n/2+1; j++) (f[i&1][j] += (0ll+(j>0?f[i+1&1][j-1]:0)+f[i+1&1][j]+f[i+1&1][j+1])%M) %= M;
	}
	cout << (a[n]<=0?f[n&1][0]:0);
    return 0;
}
```
## 注意
- 注意取模。
- 滚动不清空，爆零两行泪。

---

## 作者：zhouzihang1 (赞：1)

# P4622 [COCI2012-2013#6] JEDAN 题解

## 思路

首先 $h_1=0$ 且 $h_n=0$ 否则不合法。

其次会发现题目实际上在说相邻两根柱子高度之差的绝对值 $\le 1$。

注意到 $O(NV) \le 10^8$ 考虑 dp。

设 $f_{i,j}$ 表示考虑到第 $i$ 根柱子，第 $i$ 根柱子高度为 $j$ 的方案数。

如果 $h_i=0$，则 $f_{i,0}=f_{i-1,0}+f_{i-1,1}$。

如果 $h_i>0$，则 $f_{i,j}=f_{i-1,j-1}+f_{i-1,j}+f_{i-1,j+1}$。

如果 $h_i=-1$，则 $f_{i,j}=\begin{cases} f_{i-1,j}+f_{i-1,j+1} & j=0 \\ f_{i-1,j-1}+f_{i-1,j}+f_{i-1,j+1} & j \neq 0\end{cases}$

另外注意 $10^8$ 开 int 数组会炸，把第一维滚调就行。

## Code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e4+10,V=1e4+10;
const int Mod=1e9+7;
int n,h[N];
ll f[2][V];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&h[i]);
	int p=1;
	if(h[1]!=-1) f[0][h[1]]=1;
	else f[0][0]=1;
	for(int i=2;i<=n;i++,p^=1)
	{
		for(int j=0;j<V;j++) f[p][j]=0;
		if(h[i]==0) f[p][0]=(f[p^1][0]+f[p^1][1])%Mod;
		else if(h[i]>0) f[p][h[i]]=(f[p^1][h[i]-1]+f[p^1][h[i]]+f[p^1][h[i]+1])%Mod;
		else if(h[i]==-1)
		{
			for(int j=0;j<V-1;j++)
			{
				if(j==0) f[p][0]=(f[p^1][0]+f[p^1][1])%Mod;
				if(j>0) f[p][j]=(f[p^1][j-1]+f[p^1][j]+f[p^1][j+1])%Mod;
			}
		}
	}
	ll ans=f[p^1][0]%Mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Kingna (赞：1)

# 初始 dp 定义和各种问题
先来 dp 定义：$dp_{i,j}$ 表示前 $i$ 个数且第 $i$ 个数是 $j$ 的方案数。

接下来会面临 $2$ 个问题：


* 转移怎么办？考虑前 $i-1$ 个数，但是第 $i - 1$ 个数又是多少？？ 
* 第 $i$ 个数为 $j$，$j$ 的范围是多少？ （开数组和枚举时需要用到）

**问题一解决方案：**

分析一下第 $i - 1$ 个数和第 $i$ 个数的关系。


假设序列中一个区间是由 $k$ 组成的，那么跟这个区间相邻的数只能为 $k - 1, k, k + 1$。简化后可得**序列中相邻两数绝对值相差小于等于 $1$**。

那么 问题一 $ \ $中的第 $i - 1$ 个数的值只能是 $j,j-1,j+1$。

**问题二解决方案**

序列中的最大值绝对不会超过 $n$。 那么 **$j$ 的范围只需要枚举到 $n$**。

# 状态转移
由于第 $i - 1$ 个数和第 $i$ 个数绝对值相差小于等于 $1$。

那么 $dp_{i,j}=\max\{dp_{i-1,j-1},dp_{i-1,j},dp_{i-1,j+1}\}$。

这里注意一下，如果 $a_i$ 是已知的，直接套用方程即可，否则，需要枚举 $j$ 进行转移！

# 小细节
* 转移的时候需要判断数组是否越界。
* 开 $10005\times 10005$ 的 dp 数组很显然开不下的，可以滚动优化。
* **需要判断第一个数和最后一个数是否大于等于 $1$，如果是就输出 $0$ !!!  ** 

# 代码
```c++
//这个代码是有坑的，但是这个坑已经提到过了
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e4 + 5, mod = 1000000007;
int a[N], dp[2][N];
int n;

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	dp[1][0] = 1;
	for (int i = 2; i <= n; i++) {
		memset(dp[i & 1], 0, sizeof dp[i & 1]);
		if (a[i] != -1) {
			if (a[i] >= 1) {   //数组可能越界
				dp[i & 1][a[i]] = (dp[(i - 1) & 1][a[i] - 1] + dp[(i - 1) & 1][a[i]] + dp[(i - 1) & 1][a[i] + 1]) % mod;
			}
			else {
				dp[i & 1][a[i]] = (dp[(i - 1) & 1][a[i]] + dp[(i - 1) & 1][a[i] + 1]) % mod;
			}
		} 
		else {
			for (int j = 0; j <= N - 5; j++) {
				if (j >= 1) {
					dp[i & 1][j] = (dp[(i - 1) & 1][j - 1] + dp[(i - 1) & 1][j] + dp[(i - 1) & 1][j + 1]) % mod;
				}
				else {
					dp[i & 1][j] = (dp[(i - 1) & 1][j] + dp[(i - 1) & 1][j + 1]) % mod;
				}
			}
		}
	}
	cout << dp[n & 1][0] << endl;
}
```

---

## 作者：Coros_Trusds (赞：1)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15978378.html)

# 题目大意

有 $n$ 个数排成一行(数值代表高度)，最初所有的数都为零，你可以选择连续的一段等高的数，将它们都增加 $1$(除了开头和结尾那个数)如下图表示了两次操作:

![](https://cdn.luogu.com.cn/upload/pic/19412.png)

现在有一些数字看不清了，我们用 $-1$ 表示，请你根据留下的数字，推出有多少种可能的方案。使得留下的数字正好满足上面的操作方法。

方案数对 $10^9+7$ 取模。

# 题目分析

令 $dp_{i,j}$ 表示考虑了前 $i$ 个数字且第 $i$ 个数字为 $j$ 的方案数。

根据定义，初始化 $dp_{1,0}=1$，答案就是 $dp_{n,0}$。

当 $a_i$ 看不清时，枚举所有可能的数，状态转移方程为 $dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1}+dp_{i-1,j+1}$。当 $a_i$ 看得清时，状态转移方程相同，转移一次即可。

这是可以 $\rm A$ 本题的一种思路，然而极限情况下时间复杂度为 $\mathcal{O(ns)}$。$s$ 为 $a_i$ 的取值范围。极限情况即为：

```plain
10000
-1 -1 -1 ... -1 -1 -1 
```

这部分的代码：

```cpp
const int ma = 1e4 + 5;
int a[ma],dp[2][ma];//dp[i][j]:第 i 个数高度为 j 的方案数
int n;
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	n = read();
	for (register int i = 1;i <= n; ++ i) a[i] = read();
	if (a[1] >= 1 || a[n] >= 1) return puts("0"),0;
	dp[1][0] = 1;
	for (register int i = 2;i <= n; ++ i) {
		mst(dp[i & 1ll],0);
		if (a[i] != -1) {
			if (a[i] >= 1) dp[i & 1ll][a[i]] = MOD(dp[i - 1 & 1ll][a[i] - 1] + dp[i - 1 & 1ll][a[i]] + dp[i - 1 & 1ll][a[i] + 1]);
			else dp[i & 1ll][a[i]] = MOD(dp[i - 1 & 1ll][a[i]] + dp[i - 1 & 1ll][a[i] + 1]);
		} else {
			for (register int j = 0;j <= 1e4; ++ j) {
				if (j >= 1) dp[i & 1ll][j] = MOD(dp[i - 1 & 1ll][j - 1] + dp[i - 1 & 1ll][j] + dp[i - 1 & 1ll][j + 1]);
				else dp[i & 1ll][j] = MOD(dp[i - 1 & 1ll][j] + dp[i - 1 & 1ll][j + 1]);
			}
		}
	}
	printf("%lld\n",dp[n & 1ll][0]);	

	return 0;
}
```

-----------

考虑优化。发现性质：变换后的所有数的最高高度小于等于 $n/2$，且最终的形状和山峰差不多。从这个性质入手：

对于位置 $i$，当 $i\le n/2$ 时，$a_i$ 最大值为 $i-1$；当 $i\gt n/2$ 时，$a_i$ 最高为 $n-i+1-1=n-i$。为什么呢？因为每一次操作是区间统一加减而左右端点不变，最大值肯定是连续一段相等的，这样才能变大，那么我们来看看：

```plain
1 2 3 4 5 6 7
```

```plain
0 1 1 1 1 1 0
0 1 2 2 2 1 0
0 1 2 3 2 1 0
```

然后就能推出来了。

然后上面的代码改改，每一次不必枚举值域，直接枚举到可能的最大值。注意会炸空间，滚动数组处理。

# 代码

```cpp
//2022/3/7
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define int long long
#define enter() putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
const int mod = 1e9 + 7;
inline int MOD(int x) {
	while (x < 0) x += mod;
	while (x >= mod) x -= mod;
	return x;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int ma = 1e4 + 5;
int a[ma],dp[2][ma];//dp[i][j]:第 i 个数高度为 j 的方案数
int n;
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	n = read();
	for (register int i = 1;i <= n; ++ i) a[i] = read();
	if (a[1] >= 1 || a[n] >= 1) return puts("0"),0;
	dp[1][0] = 1;
	for (register int i = 2;i <= n; ++ i) {
		mst(dp[i & 1ll],0);
		if (a[i] != -1) {
			if (a[i] >= 1) dp[i & 1ll][a[i]] = MOD(dp[i - 1 & 1ll][a[i] - 1] + dp[i - 1 & 1ll][a[i]] + dp[i - 1 & 1ll][a[i] + 1]);
			else dp[i & 1ll][a[i]] = MOD(dp[i - 1 & 1ll][a[i]] + dp[i - 1 & 1ll][a[i] + 1]);
		} else {
			int R = min(i - 1,n - i);
			for (register int j = 0;j <= R; ++ j) {
				if (j >= 1) dp[i & 1ll][j] = MOD(dp[i - 1 & 1ll][j - 1] + dp[i - 1 & 1ll][j] + dp[i - 1 & 1ll][j + 1]);
				else dp[i & 1ll][j] = MOD(dp[i - 1 & 1ll][j] + dp[i - 1 & 1ll][j + 1]);
			}
		}
	}
	printf("%lld\n",dp[n & 1ll][0]);	

	return 0;
}
```

第一个做法最慢点是 $282ms$，第二个做法最慢点是 $127ms$。

---

## 作者：Yyxxxxx (赞：1)

## 题意
选一段连续的台阶，让除了两端的台阶升高一格  
然后我们容易得到这个序列的一些性质

- 两端肯定是$0$，因为她们不可能升高 
- 最高也不可能高过$n/2$不信你自己模拟一下看看，而且这个最高的还只可能是中间那一个
- 对于上面这个你模拟出来的情况，还可以得到每一位的最高高度，~~大概长得跟个山峰差不多，~~
- 对于一个高度为$k$的，它肯定比旁边的高度差不超过$1$，~~即“等高线”是连续的，没有陡崖~~
- 初二狗表示抱歉（

那么我们根据性质四，即上面的第四条，我们进行$dp$。  
令$f_{i,j}$表示第$i$位的第$j$高度有几种方案，根据第一条，答案为$f_{n,0}$  
由于高度差最多不超过$1$那么本高度会由前面一位的同一高度，高一格高度，低一格高度转移来，即
$$f_{i,j}=f_{i-1,j-1}+f_{i-1,j}+f_{i-1,j+1}$$
当然了我们需要注意，如果$i=0$那么第一项是没有的。  
同时，数组开不下，但是由于方程中只有$i,i-1$，滚一下。
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[2][10001];
int a[10005];
const int mod=1e9+7;
int now,id;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    if(a[1]>0||a[n]>0) cout<<0,exit(0);
    a[1]=a[n]=0,f[1][0]=1,id=2;
	while(id<=n)
	{
        int maxh=id;
        if(id>n/2) maxh=n-id+1;
        for(int i=0;i<=maxh-1;i++) 
			if(a[id]==-1||i==a[id]) 
            	f[now][i]=((long long)(i?f[!now][i-1]:0)+f[!now][i]+f[!now][i+1])%mod;
        now=now^1,++id;
        memset(f[now],0,sizeof(f[now]));
    }
	printf("%d",f[now^1][0]);
	return 0;
}
```


---

## 作者：yqr123YQR (赞：0)

### 分析
将柱状图换成折线图，容易发现操作一次就是选一段“平台”，将其中间部分向上整体抬高一格。所以任意一个在 $x$ 轴上方的折线图都与合法方案一一对应。且一头一尾都落在 $x$ 轴上。

那就直接考虑在 $(a,h),(b,h')$ 之间的路径数。由于每次 $y$ 坐标可以 $\pm1$ 或保持不变，枚举有多少次不变，剩余部分类似卡特兰数，恕不列出。

由于枚举上限为 $\frac{b-a}2$，求和后时间复杂度为 $O(n)$。

### 代码
```cpp
for(int i = 1, lst = 0, lstpos = 0, h; i <= n; i++)
{
  read(h);
  if(i == 1 || i == n)
  {
    if(~h && h) return puts("0"), 0;
    h = 0;
  }
  if(!~h) continue;
  int tot = 0, up = i - lstpos, delta = h < lst? lst - h: (h - lst);
  for(int j = 0; j * 2 + delta <= up; j++)
    Add(tot, C(up, 2 * j + delta) * C(2 * j + delta, j) % mod);
  delta = h + lst + 2;
  for(int j = 0; j * 2 + delta <= up; j++)
    Add(tot, mod - C(up, 2 * j + delta) * C(2 * j + delta, j) % mod);
  ans = ans * tot % mod;
  if(!ans) break;
  lstpos = i, lst = h;
  // printf("%d:%lld\n", i, ans);
}
```

---

## 作者：player_1_Z (赞：0)

### 思路
这题通过图片和题目描述可以发现一个性质：两端一定为 $0$ 且相邻两个数的差一定小于等于 $1$。然后发现 $h_i \le 10000$。于是想到 dp。构造 dp 转移式如下 $dp_{i,j} = dp_{{i - 1},{j - 1}} + dp_{{i - 1},j} + dp_{{i - 1},j + 1}$。但是又发现空间限制有点小，不过因为每个 $dp_i$ 之和 $dp_{i - 1}$ 有关，所以想到滚动数组，然后就可以过了。

### 代码

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int n,a[10004],ans,dp[2][10005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(),cout.tie();
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	if(a[1]>0){//首尾只能为 0-，但是如果柱子 n 现在的高度大于 0 答案不会更新，所以值判断柱子 1 
		cout<<0;
		return 0;
	}
	dp[1][0]=1;
	for(int i=2;i<=n;i++){
		int ix=i%2,ma;//ma 是这个柱子的最大高度 
		if(i<n/2) ma=i-1;
		else ma=n-i;
		for(int j=0;j<=ma;j++){
			if(j==a[i]||a[i]==-1){//这个柱子的高度有没有可能是 j 
				dp[ix][j]=(dp[!ix][j]+dp[!ix][j+1])%mod;//顺序很重要，不然循环最后要初始化 
				if(j>0) dp[ix][j]=(dp[ix][j]+dp[!ix][j-1])%mod;
			}
			else dp[ix][j]=0;
		}
	}
	cout<<dp[n%2][0];//滚动数组别忘了改输出 
	return 0;
}
```

---

## 作者：Konnyaku_LXZ (赞：0)

这是一道难想，但是想到了就很好做的dp题。

我们只有在发现了题目的以下几个性质以后才能想到dp：

1.头尾数字高度一定是 $0$。

2.相邻数字高度差不超过 $1$。

3.第 $i$ 个数字最大高度为 $min(i,N-i+1)-1$。

于是这题就显然了。

设 $f[i][j]$ 表示前 $i$ 个数字，其中第 $i$ 个数字高度为 $j$ 时的总方案数。

答案为 $f[N][0]$。

由2可得，$f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1]$。

对于高度已经确定的点，直接转移即可。

对于高度未确定的点，枚举高度即可。

dp的时候可以用滚动数组优化。

我们还需要用一个 $temp$ 数组来临时存放当前的方案数，每枚举到一个 $i$ 时， $temp$ 数组先清空，将方案数算出来之后保存在 $temp$ 里，再将其复制到 $f$ 数组中即可。

具体见代码。

时间复杂度： $O(N^2)$。

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<cmath>
using namespace std;

const int MAXN=1e4+50,MOD=1e9+7;
typedef long long LL;

LL N,a[MAXN],f[MAXN],temp[MAXN],Ans=0;

void copy(LL len,LL a[],LL b[]){for(int i=0;i<=len;i++) a[i]=b[i];}

void Init(){//初始化
	scanf("%lld",&N);
	for(int i=1;i<=N;++i) scanf("%lld",&a[i]);
}

void Solve(){//dp
	if((a[1]!=0&&a[1]!=-1)||(a[N]!=0&&a[N]!=-1)) return;//先判合法
	f[0]=1;a[1]=a[N]=0;//初始值
	for(int i=2;i<=N;++i){
		memset(temp,0,sizeof(temp));//每次都清空temp数组
		LL maxx=min(LL{i},LL{N-i+1})-1;//最大高度
		if(a[i]!=-1){if(a[i]<=maxx) temp[a[i]]=(f[a[i]-1]+f[a[i]]+f[a[i]+1])%MOD;}//高度不等于-1时直接转移
		else{//否则枚举高度进行转移
			temp[0]=f[0]+f[1];//j=0的时候j-1会是负数，需要特殊处理
			for(int j=1;j<=maxx;++j) temp[j]=(f[j-1]+f[j]+f[j+1])%MOD;
		}
		copy(N/2,f,temp);
	}
	Ans=f[0];
}

void Print(){//输出
	printf("%lld\n",Ans);
}

int main(){
	Init();
	Solve();
	Print();
	return 0;
}
```

---


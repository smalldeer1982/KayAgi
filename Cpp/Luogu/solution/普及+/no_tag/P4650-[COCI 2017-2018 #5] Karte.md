# [COCI 2017/2018 #5] Karte

## 题目描述

有$N$ 张牌叠在一起，第 $i$ 张牌上，有一个数字 $a_i$ 表示它下面**至少**有 $a_i$ 张牌上的信息是错误的，若它下面确实有至少 $a_i$ 张牌的信息是错误的，那这张牌的信息就是正确的，否则这张牌的信息就是错误的。（我们认为最下面的牌的后面有 $0$ 张错误的）

现在需要你重新调整牌的顺序，使得正好有 $K$ 张牌上的信息是错误的。

## 说明/提示

$30\%$的数据 $N≤ 16$。

另有$40\%$的数据 $N≤ 2000$。

**样例 2 说明：**

第 $5$ 张牌上写的是$2$，但是其后面只有 $0$ 张错误，所以它是错误的。

第 $4$ 张牌上写的是$1$，其后面有 $1$ 张错误（第五张），所以它是正确的。

第 $3$ 张牌上写的是$0$，其后面有 $1$ 张错误（第五张），所以它是正确的。

第 $2$ 张牌上写的是$3$，但是其后面只有 $1$ 张错误（第五张），所以它是错误的。

第 $1$ 张牌上写的是$3$，但是其后面只有 $2$ 张错误（第五张，第二张），所以它是错误的。

因此总共有 $3$ 张是错误的。

## 样例 #1

### 输入

```
4 2
1 2 2 3
```

### 输出

```
2 3 1 2```

## 样例 #2

### 输入

```
5 3
2 1 3 0 3
```

### 输出

```
3 3 0 1 2```

## 样例 #3

### 输入

```
6 4
0 2 5 2 0 1
```

### 输出

```
-1```

# 题解

## 作者：B天选之子B (赞：6)

## 题目描述

- 现在有一叠牌。

- 每张牌上有一个数字,表示它下面至少有几张牌上的信息是错误的。

- 如果下面没有那么多张牌是错的，那这张牌就是错的。

## 解题思路

- 首先是从最后一张牌开始往前推。

- 假定要求的错误牌都在最后，那么前面的都要是对的，否则就无解。

- 牌上记录的数中小的牌放在前面就有有可能是对的。

**所以最后结论就是小牌在前面，大牌中又按从大到小排。**

## 注意事项

1. 最后的大牌要单独排序。

2. 记录的是至少，不是刚刚好。

3. 方法有多种，输出一种就可以了，不用和样例一样。

## 奉上代码
```
#include <bits/stdc++.h>
using namespace std;
int A[500010],cw,n,k;//cw值的是错误个数
int cmp(int x,int y) { //从大到小排序 
	return x>y;
}
int main() {
	scanf("%d%d",&n,&k);
	for(int i=1; i<=n; i++)scanf("%d",&A[i]);
	sort(A+1,A+n+1);        //先正着牌  
	sort(A+n-k+1,A+n+1,cmp);//后k个要倒着牌  
	for(int i=n; i>=n-k+1; i--)
		if(cw<A[i]) cw++;
	if(cw!=k||A[n-k]>k) { //错误个数不是k个就无解  
		printf("-1");
		return 0;
	}
	for(int i=1; i<=n; i++) printf("%d ",A[i]);
	return 0;
}
```
**此题有些绕，多读几遍题目。**

---

## 作者：dci66666 (赞：2)

本题解是我的第一篇题解，希望对各位有所帮助，希望能审核过。结果另一篇过了这个过不了（（
## 题目理解：
有 $n$ 张牌，每张牌有个 $a_i$。


下面的牌错误数 $\ge y$ 即对。

下面的牌错误数 $<a_i$ 即错（这很重要！！）。
  
题目询问刚好有k张牌错误，换句话说就是有 $n-k$ 张牌正确，我们要做到的就是保证 $n-k$ 张牌正确就行了，~~说了半天引出了什么~~。
  
扯回正题：如何保证 $n-k$ 个数正确呢？

这就要追本溯源到我最开始说的了。
  
下面的牌错误数 $\ge a_i$ 即对。
  
下面的牌错误数 $<a_i$ 即错。
  
那么只要维护 $n-k$ 前有满足至少 $a_i$ 个错的就行了。

然后很容易想到贪心，把 $a_i$ 排序（原题允许随便排序），且从小到大，易得在 $a_i$ 小的牌更容易正确，最后的 $k$ 个 $a_i$ （后 $k$ 个数容易错误，因为 $a_i$ 值较大 $a_i$ 值较小）的前面，这样就可以保证答案最优。

## 证明：
这里采用 **假设法**，假设存在一组询问，有 $k$ 个满足不了的 $a_i$ 和 $n-k$ 个可以满足的 $a_i$ 那么**任意**一个满足的 $a_i$ 都 $\le k$ （否则无法满足，因为只有 $k$ 个错的），那么刚好能满足题意的一定有前 $n-k$ 小的 $a_i$，于是稳妥地构造出答案，如果不满足二者任意一个条件都可以证明无法满足。
## 细节提醒：
1. 对于不存在的答案，即输出 $-1$，只需要满足保证不了后 $k$ 个数错误或者前 $n-k$ 个数正确即可。
2. 还有要序列倒序输出。
### 最后放代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+50;//开大点
int a[N],n,k,cnt;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n-k;i++){
		if(a[i]>k){//没等号，因为等于也算正确
			puts("-1");
			return 0;
		}
	}//这段可改为if(a[n-k]>k){puts("-1");return 0;}因为最后的数不满足就够了，假设存在a[i]>k且i<n-k,y因为a[n-k]>=a[i]所以a[n-k]也>k
	for(int i=n-k+1;i<=n;i++){
		if(a[i]<=cnt){//要加等号！！
		   puts("-1");
		   return 0;
	    }   
	    cnt++;
	}
	for(int i=n-k;i>=1;i--){
		printf("%d ",a[i]);
	}
	for(int i=n;i>=n-k+1;i--){
		printf("%d ",a[i]);
	}//倒序输出
	return 0;//好习惯
}
```

---

## 作者：CoronaQL (赞：2)

# Karte题解一枚
## 思路
首先，这里数据越排在前面就越可能是对的；a[]值越大，错误的可能性越大。因此将a数组从小到大排序，再将后面k个翻转，使后面k个错误的可能性越大。
可翻转不一定恰好有k个，故需要验证（注意：前面也有可能是错的）。
## 注释（不打在代码里，便于理解）
### 第一次的交换
个数<k 前面的数一定比后面k个数小，既然后面都不满足条件，换了位置就更不可能了。
### 第二次的交换
个数>k 往后排，错误的结论是错的。往前排，可以证明后k个一定是错的，交换的根源来自于中间有错误的，如果满足，则还是大于k。
## 方法介绍
这里蒟蒻用的是便于理解的入门排序（~~大佬勿喷~~）
# AC代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n, k, a[500002], cnt;
int main() {
	scanf("%d %d", &n, &k);
	for(int i = 1; i <= n; i ++)
		scanf("%d", &a[i]);
	if(k == 0)
		return ! printf("-1\n");
	sort(a + 1, a + n + 1);
	for(int i = n - k + 1; i <= n - k + (k >> 1); i ++)
		swap(a[i], a[n - (i - n + k) + 1]);
	for(int i = n; i >= 1; i --)
		if(a[i] > cnt)
			cnt ++;
	if(cnt == k)
		for(int i = 1; i <= n; i ++)
			printf("%d ", a[i]);
	else
		printf("-1\n");
	return 0;
}
```
# 注意！
## （1）
代码的速度会比较慢，但是是AC代码。
## （2）
**不要复制！**

---

## 作者：ycy1124 (赞：2)

### 题意
有 $n$ 张牌，每张牌上面有一个数字 $a_i$，现在将他们叠成一堆，对于第 $i$ 张牌，假如它下面有大于等于 $a_i$ 张假牌那么它就是真的，否则他就是假的，求一种牌堆的摆放顺序使得一共有 $k$ 张假牌。误解输出 `-1`。
### 思路
考虑贪心，我们不妨大胆猜测一下将 $k$ 张最大的牌按从小到大的顺序摆放在牌堆底，其余的按从大到小放在上面是最优的做法。

如何证明这个的正确性，考虑当下面的 $k$ 张牌出现一张正确的牌，当你交换换了一张比他大的牌，由于所有比它大的牌都在他的上面，所以他一定还是正确的。假如你换了一张更小的牌过来就更不用说了。所以这个一定是最优的解法。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500005];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    sort(a+1,a+n+1);
    int js=0;//错误的牌的个数
    for(int i=n-k+1;i<=n;i++){//最大的k张牌从小到大
        if(js<a[i]){
            js++;
        }
    }
    for(int i=n-k;i>=1;i--){//其余的牌从大到小
        if(js<a[i]){
            js++;
        }
    }
    if(js==k){
        for(int i=1;i<=n-k;i++){//记得倒叙输出
            cout<<a[i]<<' ';
        }
        for(int i=n;i>=n-k+1;i--){
            cout<<a[i]<<' ';
        }
    }
    else{
        cout<<-1;
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/191816759)。

---

## 作者：Listedzero (赞：1)

### 题目分析

给定一个序列，要求设计一种序列，表示牌从上往下放，序列中的数字表示该处右侧至少有多少数字是表示“错误” 的。关于错误的定义可以多看一下题干，分析一下样例解释就可以了。分析到这，最简单的思路就是直接递归枚举，遇到合法的直接退出，期望得分 10 到 20 分。

这种暴力枚举受 $N$ 的数据范围限制，所以我们需要思考这个序列的安排上有没有规律。分析题目中“它下面**至少**有 $a_i$ 张牌上的信息是错误的” 这个信息：在下面的数如果是错误的，则若要使得在它上面的也错误，则这个一定也可以大于等于它下面这张牌上的数字。因此可以考虑直接在这个序列末向序列初的长度为 $K$ 的一段构造一个逐渐递增的最大单增区间。由于此时我们不需要更多错误的牌了，那么我们想要剩下的那些牌尽可能的小就可以了，也符合这个逻辑。

当然还要考虑到无解情况，那么直接遍历一遍记录一下看这样排得到的结果对不对就可以了，详情请看代码。

### 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
int n,k;
int a[N];
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+1+n);
    sort(a+n-k+1,a+n+1,greater<int>());
    int e=0;
    for(int i=n;i;i--) if(a[i]>e) e++;
    if(e!=k){
        cout<<-1<<'\n';
        return 0;
    }
    for(int i=1;i<=n;i++) cout<<a[i]<<' ';
    return 0;
}
```

---

## 作者：2021changqing52 (赞：1)

# 思路：
- 这种思路题解区有了，我为了~~经验+7~~加深理解自己写了一遍
### 题目描述：
现在有 $N$ 张牌，每张牌上有一个数字 $a_i$，表示在这张牌下至少有几张错误的牌，否则这张牌是错误的。现在需要你重新调整牌的顺序，使得正好有 $K$ 张牌上的信息是错误的。
### 解题思路：
- 很明显，我们可以从后往前安排；
- 我们假定错误的牌都在最后，前面的都要是正确的；
- 牌上记录的数中小的牌放在前面就很有可能是正确的。
- 最后，我们得到：**先从小到大排，数字大的 $K$ 张牌再按从大到小排**。
- 注意：方法有多种，**不用和样例一样**。
# AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500010],w,n,k;//w:错误个数 
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);sort(a+n-k+1,a+n+1,greater<int>());//后k个牌按从大到小排 
	for(int i=n;i>n-k;i--)w<a[i]&&++w;
	if(w!=k||a[n-k]>k)return!puts("-1");//如果后k个错误个数不是k 
										//或者第n-k个不正确就无解 
	for(int i=1;i<=n;i++)cout<<a[i]<<" ";//输出 
	return 0;
}
```

---

## 作者：skyskyCCC (赞：1)

## 前言。
推结论题，或者也可以说是**构造题**。
## 分析。
- 1.如果将数据都排在前面，正确的可能性大。

换句话说，如果将数据越排在前面，那么对的可能性就越大，即如果 $a_i$ 越大，放的地方越靠后，那么错误的可能性也越大。

为什么呢？通过题目描述可以发现，如果 $a_i$ 较大，且 $i$ 较大，那么这张牌很大概率是错误的。因为后面的牌的个数很少，也许少于 $a_i$ 的个数，那么在这张牌后面错误的个数就少于 $a_i$，所以这张牌很有可能是错误的。

- 2.将**可能错误的**的牌放在后 $k$ 位，可以使其错误的可能性增大。

这个可以通过 $1$ 来解答。

综上，我们的思路也就呼之欲出了。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
using namespace std;
int n,k,a[2005],ans;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);//排序，时间复杂度 O(nlogn)
    //将a数组从小到大排序，可以方便将后k个数替换
	for(int i=n-k+1;i<=n-k+(k/2);i++){
		swap(a[i],a[n-i+n-k+1]);
        /*
        n-k+1表示开始被交换的错误的牌的下标
        n-k+(k/2)表示最后需要交换的牌的下标
        n-i+n-k+1是 n-(i-n+k)+1 的化简结果，表示后面交换的牌的下标
        */
	}
	for(int i=n;i>=1;i--){
		if(a[i]>ans){//统计
			ans++;
		}
	}
	if(ans==k&&k!=0){//注意判断，如果k==0那么无解
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" ";
		}
	}
	else cout<<"-1\n";//无解的情况
	return 0;
}
```
交上去，惊喜的发现有 $6$ 个点 ```RE``` 了，再看一题目，不是说
```
30%的数据 N≤16。

另有40%的数据 N≤2000。
```
吗？但是对于全部的数据，在题干 $1≤N≤10^5$ 里，所以将 $a$ 数组的大小改为 $500005$ 即可通过本题。
## 后记。
大家如有疑问，请在评论区提出，我会尽力解答的。

---

## 作者：mol_low (赞：1)

[题目传送门](https://www.luogu.org/problem/P4650)
# 分析
我们可以发现，若$a_i$较大，且$i$也较大，那么这张牌很有可能是错误的。因为后面的牌的个数很少，甚至少于$a_i$的个数，那么错误的个数就大概率少于$a_i$，所以很有可能错误。

根据上文的结论，我们可以把大的$a_i$都放在后面让它们“错误”。但是，由于$a_{i-1}<a_i$那么越往前就会发现不少$a_i$仍是正确的。所以我们可以“规定”后$k$个为错误的，并且将后$k$个按**从大到小**排序。因为，若后$k$个按从大到小，那么在原有的错误数基础上很有可能会增加错误数。

综上所述，我们需要先将$a$数组按**从小到大**排序，再将后$k$个数按**从大到小**排序，最后遍历一遍整个数组，统计错误数即可。

$PS:$以上结论基于贪心思想(生活常识)与~~手模数据~~得出，建议自己再根据样例或其他数据确认一下。

$Code:$
```
#include <bits/stdc++.h>
using namespace std;
#define N 500000
 
int n , k;
int mistake[N + 2];

template <typename _T>

void in(_T &x) {
	x = 0;
	char c = getchar();
	bool f = 1;
	while(c < '0' or c > '9') {
		if(c == '-') f = 0;
		c = getchar();
	}
	while(c >= '0' and c <= '9') {
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	if(!f) x = (~x) + 1;
}

template <typename _T>

void out(_T x) {
	if(x < 0) {
		x = (~x) + 1;
		putchar('-');
	}
	if(x >= 10) out(x / 10);
	putchar(x % 10 + '0');
}

int main() {
	in(n);in(k);
	for(int i = 1; i <= n; ++ i) in(mistake[i]);
	sort(mistake + 1 , mistake + n + 1);
	sort(mistake + 1 + n - k , mistake + n + 1 , greater<int> ());
	int wa = 0;
	for(int i = n; i >= 1; -- i) if(mistake[i] > wa) ++ wa;
	if(wa != k) {
		puts("-1");
		return 0;
	}
	for(int i = 1; i < n; ++ i) out(mistake[i]) , putchar(' ');
	out(mistake[n]);putchar('\n');
	return 0;
}
```

---

## 作者：longdie (赞：1)

个人感觉是一道构造题，算是比较水的吧。 

我们很容易想到如果 $a_i > K$ ，那么无论放在什么位置这个都是错的。 

然后我们可以尝试构造一种方案使得从底至顶一定是先有 $K$ 的错误的，并且后面的全是正确的。 

很显然我们要把所有的 $a_i > K$ 的全部放在底部，但是如果 $a_i > K$ 的个数不够 $K$ 个 ，我们就需要把一些 $a_i <= K$ 的往下填。 

显然我们对与这些数从小到大排序，然后把他们放在最底部就可以了，具体的可以看我的代码实现。 

```cpp
// by longdie 
#include <bits/stdc++.h> 
using namespace std; 
const int N = 5e5 + 5; 
int n, K, a[N], tot, b[N], cnt, vis[N]; 
vector<int> g;
signed main() {
	scanf("%d%d", &n, &K); 
	for(register int i = 1; i <= n; ++i) {
		int x; scanf("%d", &x); 
		if(x > K) b[++cnt] = x; 
		else a[++tot] = x; 
	}
	if(cnt > K) return puts("-1"), 0;
	sort(a + 1, a + tot + 1);
	for(register int i = 1, top = 1; i <= K - cnt; ++i) {
		while(a[top] < i && top <= tot) ++top; 
		if(top > tot) return puts("-1"), 0;
		g.push_back(a[top]), vis[top] = 1, ++top; 
	}
	for(register int i = 1; i <= cnt; ++i) 
		g.push_back(b[i]);
	for(register int i = 1; i <= tot; ++i) {
		if(vis[i] == 0) g.push_back(a[i]);
	}
	for(register int i = n - 1; i >= 0; --i) {
		printf("%d ", g[i]);
	}
	return 0; 	
}

```

---

## 作者：LDY_ (赞：0)

# P4650 Karte 题解
## 分析 
题目中“至少”一词非常关键。

考虑一种合法排序。自底向上遍历到有 $k$ 个错误后，再上方的牌的值必须小于 $k$。因此小牌应放上面。

从小到大排序后考虑如何构造 $k$ 个错误。取后 $k$ 个数从大往小排序产生错误可能最大。如果这 $k$ 个数产生了 $k$ 个错误且上一个数正确，由于 $1$ 到 $n-k$ 从小往大排序，错误数不会增长，存在合法方案。否则输出 $-1$。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[500005];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	reverse(a+1+n-k,a+n+1);
	int cnt=0;
	for(int i=n;i>=n-k+1;i--){
		if(a[i]>cnt) cnt++;
	}
	if(cnt!=k||a[n-k]>k){
		cout<<-1<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
}
```

---

## 作者：nyC20 (赞：0)

# 思路
构造题，构造的策略是尽可能把正确的放在上面，然后把错误的都放在下面，这样就能尽可能的满足题意。所以正确的部分就要从小到大排序，让大的放在下面，尽可能的靠近错误的部分，才能使得它是正确的。而错误的部分就要从大到小排序，让越大的下面有越多的牌，尽可能使得它是错误的。
# 正确性
不用在乎你的输出和样例不一样，因为本题是用了 SPJ 任意输出一种构造方案即可。 
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, p[500003], WA;
int main() {
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&p[i]);
	sort(p+1,p+1+n);//先全部从小到大排序 
	reverse(p+n-k+1,p+n+1);//将后k个从大到小排序，reverse函数的作用是把区间反过来 
	for(int i=n-k+1;i<=n;i++){
		if(n-i<p[i]){//如果是错误的 
			WA++;
		}
	}
	if(WA!=k||p[n-k]>k){//如果错误的不是k个或者第倒数k+1个(即最大的正确的)是错误的 
		printf("-1");//输出-1 
		return 0;
	}
	for(int i=1;i<=n;i++)printf("%d ",p[i]);//否则打印答案 
	return 0;
}
```

---


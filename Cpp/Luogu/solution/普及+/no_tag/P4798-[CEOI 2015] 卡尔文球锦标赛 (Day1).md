# [CEOI 2015] 卡尔文球锦标赛 (Day1)

## 题目描述

**译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day1 T2「[Calvinball championship](https://ceoi2015.fi.muni.cz/day1/eng/day1task2-eng.pdf)」**

一场卡尔文球比赛会有 $n$ 名选手参与，他们的编号分别为 $1\dots n$，分为若干个非空的球队。我们规定球队之间按照每个球队编号最小的选手的编号排序，并且以从 1 开始的连续整数编号。

举个栗子，譬如 1 号选手自己成一队，2, 3 和 5 号选手成一队，4 和 6 号选手成一队。

>\> $\ \texttt{1}$  
>\> $\ \texttt{2 3 5}$  
>\> $\ \texttt{4 6}$

那么 1 号选手的球队就是 1 号球队，2 号选手的球队就是 2 号球队，4 号选手的球队就是 3 号球队。

>\> $\ \texttt{1|1}$  
>\> $\ \texttt{2|2 3 5}$  
>\> $\ \texttt{3|4 6}$

每个人每天会选择不同的球队，我们可以在记录时省略选手的编号，仅记录每个位置对应选手所属球队编号的序列（上述例子为 `1 2 2 3 2 3`），因为每天的选手是一样的。当可能的选择方案全部被使用过后，锦标赛就结束了。

由于选择方案十分多，选择困难症患者纷纷表示力不从心。今年，我们决定根据记录的序列的字典序来选择方案。因此，第一天，所有人都在一个队 `1 1 1 1 1 1`；第二天，所有人都与 6 号针锋相对 `1 1 1 1 1 2`……在最后一天，所有人互相打响战争 `1 2 3 4 5 6`。

对于给定的球队记录，请你算出将会在未来的哪一天使用该记录。输出这个数字对 $1\ 000\ 007$ 取余的结果。

## 说明/提示

请注意，三人比赛中可能的选择有 `1 1 1` `1 1 2` `1 2 1` `1 2 2` 和 `1 2 3`。

### 数据范围与提示

|数据点|$1-3$|$4-5$|$6-7$|$8-10$|
|-|:-:|:-:|:-:|:-:|
|$n\le$|$14$|$100$|$1\ 000$|$10\ 000$|

## 样例 #1

### 输入

```
3
1 2 2```

### 输出

```
4```

# 题解

## 作者：rhn7 (赞：18)

第一眼看上去像是数位 dp，实际比数位 dp 简单很多。

设当前有 $i$ 人，分成了 $T$ 个队，新来了一个人，那这个人要么在 $T$ 个队中的一个，要么新开启了第 $T+1$ 个队，也就是这个人所在的队伍编号 $ \le T+1 $。

知道这个就可以开始 dp 了，我们设 $dp_{i,j}$ 表示有 $i$ 个人，第一个人的队伍编号 $ \le j$，按刚才说的转移即可：

$dp_{i,j}=dp_{i-1,j} × (j-1) + dp_{i-1,j+1} $

接下来就是类似数位 dp 的试填法，枚举第 $i$ 个人的队伍 $j$。

如果 $j < a_{i}$，后面 $n-i$ 个人可以随便选，也就是 $dp_{n-i,max(j+1,mx+1)}$。

如果 $j = a_{i}$，往下考虑第 $i+1$ 个人。

这道题的数据又卡空间又卡时间，所以要用滚动数组优化，本蒟蒻的代码跑的非常慢，大佬就凑合看吧：

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
ll n,i,j,k,x,ans,p=1000007,mx[10005],a[10005],dp[10005];
int main(){
	cin>>n;
	for(i=1;i<=n;i++) dp[i]=1,cin>>a[i],mx[i]=max(mx[i-1],a[i]);//前缀最大值 
	for(i=n;i;i--){
		//第i个人的队伍编号最多是mx[i-1]+1 
		for(j=1;j<=min(mx[i-1]+1,a[i]-1);j++) ans=(ans+dp[max(j+1,mx[i-1]+1)])%p;
		for(j=1;j<=i;j++) dp[j]=((j-1)*dp[j]+dp[j+1])%p;//滚动数组优化 
	}
	cout<<(ans+1)%p;//当前ans是多少方案比a小，ans+1后就是排名了 
	return 0;
}
```


---

## 作者：geruome (赞：14)

核心代码只有两三行，过于简单，就直接放注释里了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define IOS {cin.tie(0);cout.tie(0);ios::sync_with_stdio(0);}
#define rep(i,j,k) for(int i=j;i<=k;++i)
#define per(i,j,k) for(int i=j;i>=k;--i)
#define P pair<int,int>
#define ll long long
#define vi vector<int>
#define ls i<<1,l,mid
#define rs i<<1|1,mid+1,r
#define mi int mid=l+r>>1;
const int N=1e4+5,mod=1000007;
int n,v[N],dp[N],ma[N];
//记 dp(i,j)表示序列前i个位置，前i个值最大为j，后面合法的序列数。
int main(){
    IOS
    cin>>n; rep(i,1,n)cin>>v[i],ma[i]=max(ma[i-1],v[i]);
    int ans=1; rep(i,1,n)dp[i]=1;
    per(i,n,2){ //枚举从哪一位开始序列和原序列不同,记当前位置为 i
        //要使序列字典序<原序列,该位置的值有v[i]-1种选择,且都不影响前i个数的最大值
        ans=(ans+1ll*(v[i]-1)*dp[ma[i-1]])%mod; 
        //滚动数组更新dp
        rep(j,1,i)dp[j]=(1ll*dp[j]*j+dp[j+1])%mod;
    }
    cout<<ans;
}
```




---

## 作者：星小雨 (赞：7)

看到这道题没有题解我就写一下哈~

这道题是求给定数列的排名，也就是比给定数列字典序小的合法序列方案数$+1$，

所以我们可以想到一个很水的数位dp：

我们可以用$f[i][j][k]$表示前$i$位中最大值为$j$，且当前序列和给定序列的前$i$位的字典序关系为$k$的方案数，其中$k=1$时当前序列的前$i$位与给定序列相同，$k=0$时当前序列前$i$位的字典序小于给定序列前$i$位的字典序。

那么我们可以考虑从$i$转移,考虑当前状态为$k$时,枚举所有的$j$,

当$k=0$时，有

$f[i+1][j][0]+=f[i][j][0] \times j;$

$f[i+1][j+1][0]+=f[i][j][0];$

当$k=1$时，有

$f[i+1][j][0]+=f[i][j][1] \times (a_{i+1}-1);$

$([a_{i+1}=j+1]?f[i+1][j+1][1]:f[i+1][j][1])+=f[i][j][1];$

这四种转移，可以通过爆推/模拟的方式来求出这些转移式子。

因为dp数组中间结果会较大，记得开long long，我就是这样被卡在66分了几分钟>_<

当然这样写比较暴力，空间比较大，所以我们可以把第一维滚动掉，就能通过此题了。

时间复杂度：常数不大的$O(n^2)$，足以通过此题。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
#define b i&1^1
#define c i&1
using namespace std;
const int p=1000007;
long long f[2][10005][2];int a[10005],s=1;
int main()
{
	int n;scanf("%d",&n);f[1][1][1]=1;
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<n;++i)
	{
		for(int j=1;j<=i;++j)
		{
			f[c][j][0]%=p,f[c][j][1]%=p;
			f[b][j][0]+=f[c][j][0]*j;
			f[b][j+1][0]+=f[c][j][0];
			f[b][j][0]+=f[c][j][1]*(a[i+1]-1);
			(a[i+1]==j+1?f[b][j+1][1]:f[b][j][1])+=f[c][j][1];
			f[c][j][0]=f[c][j][1]=0;
		}
	}
	for(int i=n,j=1;j<=n;++j){f[c][j][0]%=p;s+=f[c][j][0];if(s>p) s-=p;}
	return !printf("%d\n",s);
}
```

---

## 作者：汤汤tongtongTOT (赞：5)

### 数位 dp（非正解）  
注：不想看非满分解法的同学们请空降 $80$ 行。   
首先，这题是不是很像平常我们做的数位 dp 呢？  
~~一点都不像好吧。。~~   
但是，毕竟这是数位 dp 题单中的题目，所以我想也没想直接来了一发数位 dp。  
**请特别注意题意**：这题不能出现像 $1\space1\space3$ 这样的情况，因为这样 $2$ 队就没有人了。  
如下所示：  
```cpp
// Problem: P4798 [CEOI2015 Day1]卡尔文球锦标赛
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4798
// Memory Limit: 62.5 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while('0'>ch||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}//快读，别管了
const int mod=1000007;
//注意这里不是1e9+7
int n,lim[10005],dp[10005][10005];
//此处数组仅为对拍时使用，直接这么写就全MLE
inline int dfs(int pos,int sum,int _lim){
	//pos表明现在算到了第几位
    //sum表明现在总共有几支队
    //_lim表明现在有没有顶到顶
	if(!_lim&&dp[pos][sum]!=-1) return dp[pos][sum]; 
	if(pos>n) return 1;
	int maxn=min(sum+1,_lim?lim[pos]:1000000),ans=0;
    //这里有两种情况，一种是题目给出的输入
    //另一种是队伍数量的上限
	for(int i=1;i<=maxn;i++){
		if(i==sum+1) ans+=dfs(pos+1,sum+1,_lim&&(lim[pos]==i));
        //转移1：如果当前位顶到顶了
		else ans+=dfs(pos+1,sum,_lim&&(lim[pos]==i));
        //转移2：如果当前为没有顶到顶
		if(ans>mod) ans-=mod;
	}
	if(!_lim) dp[pos][sum]=ans;
	return ans;
}
signed main() {
	memset(dp,-1,sizeof(dp));
	n=read();
	for(int i=1;i<=n;i++){
		lim[i]=read();
	}
	cout<<dfs(1,1,1)<<"\n";
}
```
注：一个小优化：  
这么写肯定全部 MLE 了，那怎么办呢？   
方法一：  
写成这样：
```cpp
int dp[10005][1005]；
if(!_lim&&sum<=1000&&dp[pos][sum]!=-1) return dp[pos][sum]; 
```
方法二：  
由于本题的特殊性，$dp[pos][sum]$ 如果被遍历过了，则不可能是 $0$。   
所以可以去除 ```memset(dp,-1,sizeof(dp));``` 这一段。
然后吸一口氧气你就能那到 $66$ 分的~~好成绩~~。   
为什么呢？因为复杂度为 $O(N^3)$（状态就是平方个，然后枚举再是一个 $n$）
### 正解
注意到在本题中，当前位只有两种情况能够影响到后面。  
那就是当该位置是否顶到顶的情况：   
（顶到顶）注：    
若输入为 $1\space2\space3\space2\space3$，而当前枚举到 $1\space2\space3\space2$，我们就称第四位顶到顶了。     
那我们就可以对上面的数位 dp 进行优化：  
构造状态 $dp[i][j][0/1]$ 代表枚举第 $i$ 位，总共有 $j$ 支队伍   
$0$ 代表当前没有顶到顶，$1$ 代表当前这一位顶到顶了。    
那么我们可以得到：    
情况一：    
如果上一位没有顶到顶，那么这意味着当前这一位取 $[1,j+1]$ 都没有问题
**注意**：如果这一位取了 $j+1$，那意味着多加了一支队伍，所以需要特判   
所以我们将前 $j$ 个情况打包转移加上 $j+1$ 的特判即可，转移时间复杂度 $O(1)$。   
情况二：    
如果上一位顶到顶了，而这一位则选取了 $[1,a[i])$ 之间的数，那么这一位又没有顶到顶了。。。   
那就可以转移给 $dp[i][j][0]$。  
但是选择 $a[i]$ 这个数的话，那就只能转移给 $dp[i][j][1]$ 了。   
**注意**：如果 $a[i]=j+1$ 的话就又需要特判了。（原因同上注）。    
转移同理。   
但是呢。。    
这一题还卡了空间复杂度，所以要开滚动数组。。。    
~~每日一个阴间卡常小技巧。~~   
具体实现详情请见代码：
```cpp
// Problem: P4798 [CEOI2015 Day1]卡尔文球锦标赛
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4798
// Memory Limit: 62.5 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
#define int long long
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while('0'>ch||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
//快读
int n,x,last,now=1,dp[2][10005][2],ans;
//滚动数组
const int mod=1000007;
signed main() {
	n=read();
	dp[0][1][1]=1;
    //初始化
	x=read();
	for(int i=2;i<=n;i++){
		x=read();
		for(int j=i;j>0;j--){
       			//由于滚动数组导致j需要从大到小枚举
        	//***勘误***：参考文献中的那篇题解说 j 要从 n 往下枚举
        	//但其实完全不需要，因为这里的 j 有不大于 i 的限制
			dp[now][j][0]=dp[now][j][1]=0;
             		//初始化当前数组，非常重要！！！
			if(dp[last][j][0]){
        		//每天一个卡常小技巧：若上一位无法转移，则continue
				dp[now][j][0]=(dp[now][j][0]+(dp[last][j][0]*j)%mod)%mod;
                	//这里的打包其实指的就是*j的过程
				dp[now][j+1][0]=(dp[now][j+1][0]+dp[last][j][0])%mod;
                	//特判*1
			}
			if(dp[last][j][1]){
         	//同上
				dp[now][j][0]=(dp[now][j][0]+(dp[last][j][1]*(x-1)%mod)%mod)%mod;
				if(x==j+1) dp[now][j+1][1]=(dp[now][j+1][1]+dp[last][j][1])%mod;
               		//特判*2
				else dp[now][j][1]=(dp[now][j][1]+dp[last][j][1])%mod;
                	//特判*3
			}
           		 //转移解释请见上方
		}
		swap(last,now);
	}
	for(int i=1;i<=n;i++){
		ans=((ans+dp[last][i][1])%mod+dp[last][i][0])%mod;
	}
    //最后求一个前缀和即可
    //注意当前滚动数组的写法，所有的值都被转移到last去了
	printf("%lld\n",ans);
}
```   
[参考文献](https://www.cnblogs.com/chdy/p/13323101.html)

---

## 作者：Lame_Joke (赞：3)

- ### 大体思路

  一道简单 DP，二维。先设 $f_{i,j}$ 指当前有 $i$ 人，第一个人的队伍编号不大于 $j$ 时的方案数。不难想到，如果此时新加入一个人，他所在队伍只有两种情况，第一种情况为原有队伍中的一个，第二种为原有队伍数加一，这也就解释了要第二维的原因。然后二重循环转移即可，转移方程见代码。最后要注意的是，这里要用滚动数组，不然 $10000$ 乘 $10000$ 个 `int`，空间会爆炸。

- ### 具体实现

  ```cpp
  #include<bits/stdc++.h>
  #define int long long
  using namespace std;
  int n,k,x,ans,p=1000007;
  int mx[10005],f[10005],a[10005];
  signed main(){
  	scanf("%lld",&n);
  	for(int i=1;i<=n;i++)
  	{
  		scanf("%lld",&a[i]);
  		f[i]=1;
  		mx[i]=max(mx[i-1],a[i]);
  	}
  	int mn;
  	for(int i=n;i>=1;i--)
  	{
  		mn=min(mx[i-1]+1,a[i]-1);
  		for(int j=1;j<=mn;j++) ans=(ans+f[max(j+1,mx[i-1]+1)])%p;
  		for(int j=1;j<=i;j++) f[j]=((j-1)*f[j]+f[j+1])%p;
  	}
  	printf("%lld",(ans+1)%p);
  	return 0;
  }
  ```

---

## 作者：Alan_Zhao (赞：3)

## 题解

这是一种很麻烦的做法。

设给定的序列是 $a$。枚举一个 $i$ 并计算有多少个合法序列 $s$ 满足 $s_{1\dots (i-1)}=a_{1\dots (i-1)}$ 且 $s_i<a_i$，最终的答案就是所有 $i$ 的个数之和 $+1$。

首先，$i$ 这个位置有 $(a_i-1)$ 种填法。设 $c_i=\max_{j=1}^i \{a_i\}$，那么对于某个位置 $j>i$，它有三种选择：

- 填 $[1,c_i]$ 中的某个数；
- 填 $>c_i$ 且先前出现过的某个数；
- 填一个新的数。

第二、三种填法就是第二类斯特林数。枚举 $[1,c_i]$ 中有多少个数在 $s_{(i+1)\dots n}$ 中出现了，再枚举它们对应的集合，可以得到 $i$ 位置的答案是：

$$
(a_i-1)\sum_{j=0}^{c_i} \sum_{k=j}^{n-i} \binom{c_i}{j}{n-i \brace k}k^{\underline{j}}.
$$

交换内外两层求和，并设 $F_i(k)=\sum_{j=0}^{c_i} \binom{c_i}{j} k^{\underline{j}}$。上式可以写成：

$$
(a_i-1)\sum_{k=0}^{n-i} F_i(k){n-i \brace k}.
$$

考虑如何从 $F_i$ 向 $F_{i+1}$ 递推。假如 $c_{i+1}=c_i$，那么 $F_{i+1}=F_i$。否则，$c_{i+1}=c_i+1$，将 $\binom{c_{i+1}}{j}$ 拆成 $\binom{c_i}{j}+\binom{c_i}{j-1}$，得到：

$$
\begin{aligned}
	F_{i+1}(k)&=\sum_{j=0}^{c_i+1} \left(\binom{c_i}{j}+\binom{c_i}{j-1}\right) k^{\underline{j}}\\
	&=F_i(k)+\sum_{j=0}^{c_i} \binom{c_i}{j} k^{\underline{j+1}}\\
	&=F_i(k)+kF_i(k-1).
\end{aligned}
$$

因此，$F_{i+1}(*)$ 可以由 $F_i(*)$ 在 $O(n)$ 时间内递推得到。这样总的时间复杂度就是 $O(n^2)$ 了，但还有一个问题，就是需要 $O(n^2)$ 空间记录所有斯特林数。但注意到斯特林数可以倒推：

$$
{n-1\brace m-1}={n\brace m}-m{n-1 \brace m},\\
{n-1 \brace n-1}=1.
$$

于是我们在 $O(n^2)$ 时间和 $O(n)$ 空间内做完了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define For(Ti,Ta,Tb) for(int Ti=(Ta);Ti<=(Tb);++Ti)
#define Dec(Ti,Ta,Tb) for(int Ti=(Ta);Ti>=(Tb);--Ti)
using ll = long long;
const int N = 1e4 + 5, Mod = 1e6 + 7;
int n, a[N];ll res[N], curs[N], nw[N];
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr);
	cin >> n;
	For(i, 1, n) cin >> a[i];
	curs[0] = 1;
	For(i, 1, n) Dec(j, i, 0) curs[j] = ((j ? curs[j - 1] : 0) + j * curs[j]) % Mod;
	ll cur = 0, ans = 0;
	For(k, 0, n) res[k] = 1;
	For(i, 1, n) {
		For(k, 0, n - i + 1) nw[k] = 0;
		nw[n - i] = 1;
		Dec(k, n - i, 1) nw[k - 1] = (curs[k] - k * nw[k] % Mod + Mod) % Mod;
		For(k, 0, n - i + 1) curs[k] = nw[k];
		For(k, 0, n - i) (ans += (a[i] - 1) * curs[k] * res[k]) %= Mod;
		if (a[i] == cur + 1) {
			++cur;
			Dec(k, n - i, 1) (res[k] += k * res[k - 1]) %= Mod;
		}
	}
	cout << (ans + 1) % Mod << '\n';
	#ifdef zyz
	Debug("Elapsed time: %dms\n", int(clock()));
	#endif
	return 0;
}
```

---

## 作者：Mobius127 (赞：3)

[题传](https://www.luogu.com.cn/problem/P4798)

谁来帮窝卡一卡常 qwq，不开 O2 过不去。。。![qq_emoji: kel](https://xn--9zr.tk/kel)

不难想到，每个人选择的队伍编号只能是 $[1,\text{前面的}\max+\ 1]$，所以我们记 $f_{i, j}$ 为到第 $i$ 个人，最大值为 $j$ 的总方案数，这个递推方程式不难想出。

但关键是，对于当前状态，我们不知道它与目标状态的差别，引入新一维：$f_{i, j, 0/1}$ 表示在之前 $f_{i, j}$ 的定义下，前 $i$ 位是否与目标完全匹配，$0$ 为严格小于，$1$ 为等于。

前驱不好找，我们考虑找它对后面的贡献。

对于下一位是 $j$ 的，若不超过，则在该位填任意数（满足不大于 $j$）即可，若超过， -1 即可。

如果下一位是 $j+1$，若不超过直接加，否则要考虑约束条件。


### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#define now (i&1)
#define nxt ((i+1)&1)
#define int long long 
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
const signed mo=1e6+7;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline int ksm(int a, int b){
	int ret=1;
	for(; b; b>>=1, a=1ll*a*a%mo)
		if(b&1) ret=1ll*ret*a%mo;
	return ret;
}
inline int mod(int x){return (x%mo+mo)%mo;}
namespace Solution{
	const int N=1e4+5;
	const int M=1e3+5;
	int n, a[N], ans, f[2][N][2];
	signed work(){
		n=read();for(int i=1; i<=n; i++) a[i]=read();f[1][1][1]=1;
		for(int i=1; i<n; i++)
			for(int j=1; j<=i; j++)
				f[nxt][j][0]=mod(f[nxt][j][0]+1ll*f[now][j][0]*j%mo+1ll*f[now][j][1]*(a[i+1]-1)%mo),
				f[nxt][j][1]=mod(f[nxt][j][1]+(a[i+1]==j+1?0:f[now][j][1])),
				f[nxt][j+1][0]=mod(f[nxt][j+1][0]+f[now][j][0]), f[nxt][j+1][1]=mod(f[nxt][j+1][1]+(a[i+1]==j+1?f[now][j][1]:0)),
				f[now][j][0]=f[now][j][1]=0; 
		for(int i=1; i<=n; i++)
			ans=mod(ans+f[n&1][i][0]+f[n&1][i][1]);
		printf("%lld", ans);
		return 0;
	}
}
signed main(){
	Solution :: work();
	return 0;
}
```

---

## 作者：SpringQinHao (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4798)

这题开始看起来像数位 DP ，但仔细盯着看看，比数位 DP 简单多了~~更难思考~~。

瞪大眼睛观察，我们发现，我们统计进去的天数，没有一天能比我们要求的数大（字典序排序）。
即：
- 1 2 2
- 1 3 2

是不会被统计进去的。

因此我们记录下 $mx$ 数组，表示我们能选择的最大数，这个数组是单调不减的。

另外再观察观察，**如果前一位符合，那么后面的数可以在合法的状态下随便填**，而这个随便能填多少个数又得看我们这个数在哪一位上。**因此**，我们记录一个 $dp$ 数组，**该数组的值只与 $n$ 有关。**
说到这也就差不多了罢。

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;
typedef long long ll;
const int mod=1000007;
const int N=10005;
ll n,mx[N],a[N],dp[N],ans=1;
//dp[]在n相同的时候是一定的 
// mx是单调不减的序列 
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		mx[i]=max(mx[i-1],a[i]);
		dp[i]=1;
	}
	for(int i=n;i>=1;i--)
	{
		ans+=((a[i]-1)*dp[mx[i-1]])%mod;
		for(int j=1;j<=i;j++)
			dp[j]=(dp[j]*j+dp[j+1])%mod;
	}
	printf("%lld",ans%mod);
	return 0;
}
```
思路借鉴 [geruome](https://www.luogu.com.cn/article/4gfcbmsi)

---

## 作者：djh0314 (赞：2)

[**洛谷**](https://www.luogu.com.cn/problem/P4798)。

## 题意

一共有 $n$ 个球队，分成若干对，按照每一对的最小值排序给予编号，如此后对于每一种分组方式我们可以得到一个序列。

给出一个满足条件的序列，问它是所有序列中字典序第几小的。

## 分析

我们从前往后枚举每一个人的组别，可以发现，我们当前这个人的组别要么是前边出现过，要么是出现过的最大组 +1。        
同时我们观察一下字典序的比较方式：找到第一个不同的地方，然后只需要判断这两个位置大小关系即可。

由这两个发现我们可以打出我们的第一个暴力。
~~~cpp
inline int dfs(int now,int mx,int flag) {
	if(now==n+1) return 1;
	int up=flag?a[now]:(mx+1),res=0;
	for(int i=1;i<=up;++i) {
		res+=dfs(now+1,max(mx,i),flag&&(i==a[now]));
		res%=MOD;
	}
	return res;
}
~~~
时间复杂度：$n!$。

有没有觉得这段代码非常之熟悉，没错就是很想我们的数位 DP。        
承接数位 DP 的思路，我们再加上一句记忆化。       
时间复杂度与空间复杂度都达到了 $n^2$，拿下 $n\le 10^3$。（~~好像时间能卡到 $n^3$ 的级别，但是要除上一堆常数~~）。                

## 正解

可以发现，我们算法的瓶颈其实是在空间上，因此我们需要将其转化到我们的递推上，然后再加上滚动数组，就变成了
~~~cpp

flag=!flag;
memset(f[flag],0,sizeof f[flag]);
for(int j=1; j<=i; ++j) {
	for(int k=1; k<=j+1; ++k)
		f[flag][j]=(f[flag][j]+f[!flag][max(j,k)])%MOD;        
}
if(i>1) {
	for(int j=1; j<a[i]; ++j) {
		ans+=f[!flag][max(mx[i-1],j)];
		ans%=MOD;
	}
}
~~~
可以发现，我们的第一个循环是可以优化的，当 $k\le j$ 时，加上的都是一样的，因此，我们可以优化成：
~~~cpp
for(int j=1; j<=i; ++j) f[flag][j]=(f[!flag][j]*j%MOD+f[!flag][j+1])%MOD;
~~~

现在的时间复杂度优化到了准 $O(n^2)$，空间复杂度为 $O(n)$。


### 总结一下，我们此题是运用了数位 DP 的递推形式，并且采用了一定的优化。

---

## 作者：OIer_Automation (赞：2)

老师跟我说要给我一个折半搜索的题单让我做（题单如下，感兴趣的可以做一下）：

1. [[ABC184F] Programming Contest](https://www.luogu.com.cn/problem/AT_abc184_f)
2. [[NOI2001] 方程的解数](https://www.luogu.com.cn/problem/P5691)
3. [[USACO12OPEN] Balanced Cow Subsets G](https://www.luogu.com.cn/problem/P3067)
4. [P4798 [CEOI2015 Day1] 卡尔文球锦标赛](https://www.luogu.com.cn/problem/P4798)

前三题确实是标准的折半搜索，但这道题我怎么看都和折半搜索没关系，只能和搜索挂钩，于是有了以下第一版代码（36）：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e4+5,r=1e6+7;
int n;
int a[maxn];

int get(int bit,int mx){
	if(bit>=n){
		return mx+1;
	}
	return (get(bit+1,mx+1)+mx*get(bit+1,mx)%r)%r;
}//求解正在确定第 bit 位，当前最大值为 mx 时的方案数

int dfs(int bit,int mx){
	if(bit>=n){
		return min(a[bit],mx+1);
	}
	if(a[bit]<=mx){
		return (dfs(bit+1,mx)+(a[bit]-1)*get(bit+1,mx)%r)%r;
	}else if(mx+1<a[bit]){
		return (mx*get(bit+1,mx)%r+get(bit+1,mx+1))%r;
	}else{
		return (mx*get(bit+1,mx)%r+dfs(bit+1,mx+1))%r;
	}
}//求解正在确定第 bit 位，当前最大值为 mx 时符合要求的方案数

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	if(n==1)printf("1");
	else printf("%d",dfs(2,1));
}
```

发现余下的点全部 TLE，反思到 get 函数每次求解需要 $2^{n-bit}$ 次调用，但得到的结果每次一致，因此可以通过 $O(n^2)$ 的时间复杂度预处理出来，然后 $O(1)$ 查询，于是有了第二版代码（66）：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=8e3+5,r=1e6+7;
int n;
int a[maxn],f[maxn][maxn];

long long dfs(int bit,int mx){
	if(bit==n){
		return min(a[bit],mx+1);
	}
	if(a[bit]<=mx){
		return (dfs(bit+1,mx)+1ll*(a[bit]-1)*f[bit+1][mx]%r)%r;
	}else if(mx+1<a[bit]){
		return (1ll*mx*f[bit+1][mx]%r+f[bit+1][mx+1])%r;
	}else{
		return (1ll*mx*f[bit+1][mx]%r+dfs(bit+1,mx+1))%r;
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	if(n==1)printf("1");
	else{
		for(int i=1;i<n;i++)f[n][i]=i+1;
		for(int i=n-1;i>=2;i--){
			for(int j=1;j<i;j++){
				f[i][j]=(1ll*j*f[i+1][j]%r+f[i+1][j+1])%r;
			}
		}//预处理，f[i][j] 表示正在确定第 i 位，目前最大值为 j 的方案数
		printf("%lld",dfs(2,1));
	}
}
```

发现余下的点全部 MLE，考虑空间复杂度 $O(n^2)$ 确实强人所难，于是考虑优化。发现每一行的值都只与下面一行的值有关，考虑滚动数组。于是有了下面的代码（100）：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e4+5,r=1e6+7;
int n,ans;
int a[maxn],f[maxn],mx[maxn];

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		mx[i]=max(mx[i-1],a[i]);//快速确定第 i 位不一样时的最大值
	}
	if(n==1)printf("1");
	else{
		for(int i=1;i<=n;i++)f[i]=1;
		for(int i=n;i>=2;i--){
			for(int j=1;j<=min(mx[i-1],a[i]-1);j++){
				ans=(ans+f[mx[i-1]])%r;
			}
			if(mx[i-1]+1<a[i])ans=(ans+f[mx[i-1]+1])%r;//处理前 i-1 位与输入全部相等，第 i 位不一样时的方案总数
			for(int j=1;j<i;j++){
				f[j]=(1ll*j*f[j]%r+f[j+1])%r;
			}//滚动数组优化空间
		}
		printf("%d",ans+1);
	}
}
```

总结：从 TLE 到 MLE 再到 AC，思路始终没有改变，变得只有代码的实现，所以在新思路想不出来的时候，不妨坚定自己的思路，优化代码的实现。

---

## 作者：xinxin2022 (赞：1)

对题目所问的第几天稍作转化，可以转化为**有多少由正整数组成的字符串字典序小于给定字典序**。

那么根据字典序的比较方法（优先比较靠前位），**DP 应当逆做。**

不妨设 $f_{i,j}$ 为考虑到第 $i$ 位，前面 $i-1$ 位最大字符为 $j$ 时的总方案数。

那么有：

$$f_{i,j}=\sum_{k=1}^{j+1} f_{i+1,\max(j,k)}$$

然后因为只有 $k=j+1$，才会做 $f_{i+1,j+1}$ 的贡献，所以简化为：

$$f_{i,j}=jf_{i+1,j}+f_{i+1,j+1}$$

然后因为前 $i$ 位不考虑，目前位有 $a_i-1$ 种方案，所以令答案加上：

$$(a_i-1)f_{i+1,\max_{j=1}^{i-1}(a_j)}$$

然后用类似背包的方法滚动掉第一维即可。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e6+7;
const int N=1e4+5;
int n,a[N],f[N],ax[N],ans=1;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) ax[i]=max(ax[i-1],a[i]);
    for(int i=1;i<=n;i++) f[i]=1;
    for(int i=n;i;i--){
        (ans+=(a[i]-1)*f[ax[i-1]])%=mod;
        for(int j=1;j<=i;j++)
            (f[j]=j*f[j]+f[j+1])%=mod;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：__xxy_free_ioi__ (赞：1)

# P4798 \[CEOI 2015] 卡尔文球锦标赛 (Day1)

[博客食用更佳](https://www.luogu.com.cn/article/t1lrw7j6)

这题第一眼看是数位 DP，没想到不是，但思路真的难，综合各位 dalao 的题解，我总结一下。

题目大意：挺难理解的，读了半天才发现答案其实就是求小于其字典序的合法的序列数量 + 1。

## 解法

直接暴力设 $f_{i,j}$ 表示序列前 $i$ 个位置的值最大为 $j$，前 $i$ 位固定为最大字典序，后面合法的序列数。

我们来推转移方程式，第 $i$ 位选手要么加入之前的队伍，要么自己新建一个队伍，那么，我们就能很显然能够得出方程 $f_{i,j} = (f_{i,j} + f_{i + 1,\max(j,k)}) \bmod 1 000 007$，这里的 $i$ 是指第 $i$ 个位置，$j$ 是指 $1 \sim i - 1$ 的最值，$k$ 则是指第 $i$ 位的值。$i$ 从后往前枚举就可以了。

蛋柿，这样子明显会 TLE，所以，我们考虑优化，由题目可知第 $i$ 位最多新建一队，所以 $1 \le k \le j + 1$，观察式子发现，$\max(j,k)$ 只有 $k = j + 1$ 时，$\max(j,k) = j + 1$，所以，就可以化简辣 $f_{i,j} = f_{i + 1,j} \times j + f_{i + 1,j + 1}$。

再考虑怎样利用 $f_{i,j}$ 来算出小于其字典序的合法序列的数量呢？因为 $1 \sim i - 1$ 位不固定是未来算的，而 $i$ 位固定为 $a_{i}$ 的方案数在前面就算了，所以，我们只需要计算 $1 \sim i - 1$ 固定，$i$ 位不固定的数量就可以了。那么，就可以从 $1 \sim a_{i} + 1$ 枚举第 $i$ 位的值 $j$ 就可以了。得出方程 $ans = (ans + f_{i + 1,\operatorname{mx}(i-1)}) \bmod 1000007$。这里的 $\operatorname{mx}(i-1)$ 是 $1 \sim i - 1$ 的最大值，预处理一下即可。

但是，还没有完，我们发现直接设 $f_{i,j}$ 会直接 MLE，所以需要滚动数组优化空间。而初始化就很简单了，直接是 $f_{0,1 \sim n} = 1$。

## 注意事项

1. 十年 OI 一场空……
2. 滚动数组，记得清空。

## 代码

```
#include <bits/stdc++.h>

using namespace std;

#define int long long // 十年OI一场空...... 

const int N = 10010, mod = 1000007;

int n, flag, ans;
int a[N], f[2][N], mx[N];

// f[i][j] 表示序列前 i 个位置，前 i 个值最大为 j，后面合法的序列数。 
 
signed main() {
	cin >> n;
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		mx[i] = max(mx[i - 1], a[i]);
		f[flag][i] = 1; // 别忘了初始化！ 
	}
	
	for (int i = n; i >= 1; i--) {
		flag = !flag;
		memset(f[flag], 0, sizeof f[flag]);
//      非优化代码
//		for (int j = 1; j <= i; j++) { // 枚举队伍数量 
//			for (int k = 1; k <= j + 1; k++) { // 枚举加入第几个队伍（第 j + 1 个就是新建一个队伍）
//				f[flag][j] = (f[flag][j] + f[!flag][max(j, k)]) % mod;
//			}
//		}
//      优化代码
		for (int j = 1; j <= i; j++) {
			f[flag][j] = (f[!flag][j] * j + f[!flag][j + 1]) % mod;
			// 发现只有当 k = j + 1时，才会加上f[!flag][k -> j + 1]，而 f[!flag][j] 被算了 j 次
			// 于是就可以化简了鸭 
		}
//      非优化代码
//		if (i > 1) { // 因为 f[i][j] 是算前 i 个位置，那么 i == 1 的时候就不用算了 
//			for (int j = 1; j < a[i]; j++) { // 枚举第 i 位的值 
//				ans += f[!flag][max(mx[i - 1], j)]; // 只算 1-i-1 位固定，i-n 位随便选的方案数，
													// 那么就要算 f[i + 1][max(mx[i - 1], j)], max(mx[i - 1], j)就是 1-i 位的最大值
//   												  （1-i-1 位是未来算的，i 位固定位 a[i] 的方案数在前面就算了） 
//				ans %= mod;
//			}
//		}
//      优化代码
		ans = (ans + (a[i] - 1) * f[!flag][mx[i - 1]]); // 同样的，发现a[i]最多为mx[i - 1] + 1，j又小于a[i]，所以 j <= mx[i - 1]！
		// 那么 f[!flag][mx[i - 1]] 就被算了（a[i] - 1）次！ 
	}
	
	cout << (ans + 1) % mod << '\n'; // 加1就是排名了 
	
	return 0;
}
```

思路借鉴：[geruome](https://www.luogu.com.cn/article/4gfcbmsi)、[djh0314](https://www.luogu.com.cn/article/vze3tlr7)

希望管理员大大给过吖 QAQ

---

## 作者：__czh__ (赞：1)

这是一道较为简单的题，找到规律并不难实现代码，适合给新手做练手题，更好的掌握 dp 算法。

题目给出 $n$ 个人以及一个序列，要我们求出该序列在第几天出现。我们可以用一个二维 $dp_{i,j}$ 数组求解，其中 $i$ 表示当前已经有 $i$ 个人，第一人编号不大于 $j$ 的方案数,则可求出 $dp_{i,j} = dp_{i-1,j} \times (j-1) + dp_{i-1,j+1}$ 的递推公式。其中 $dp_{i-1,j}$ 是第 $i$ 个人加入队中已有的队伍的方案数，$dp_{i-1,j+1}$ 是第 $i$ 个人新创队伍的方案数。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10005],dp[10005],mod=1000007,ans,b[10005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=1;//dp数组初始化
		b[i]=max(b[i-1],a[i]);
	}
	for(int i=n;i>=1;i--){
		for(long long j=1;j<=min(b[i-1]+1,a[i]-1);j++){
			ans=(ans+dp[max(j+1,b[i-1]+1)])%mod;//统计答案
		}
		for(int j=1;j<=i;j++){
			dp[j]=((j-1)*dp[j]+dp[j+1])%mod;//滚动数组优化
		}
	}
	cout<<(ans+1)%mod;//当前ans是多少方案比给出序列天数靠前，ans+1后就是天数了
	return 0;
}
```
这是本蒟蒻第一次发题解~~没有大佬帮助~~，如有不足，还望海涵。

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4798)
## 思路
设 $dp_{i,j}$ 为有 $i$ 个人，第一个人的队伍编号 $\le j$ 时的合法方案数。

假设原先有 $i-1$ 个人，第 $i$ 个人要么加入原先的队伍，要么新建立一个队伍，所以 $dp_{i,j}=dp_{i-1,j}\times (j-1)+dp_{i-1,j+1}$。

接下来计算方案数就行。
## 代码
```cpp
#include<iostream>
using namespace std;
const int mod=1000007,N=10005;
long long n,a[N],mx[N],dp[N],ans;
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>a[i];
		mx[i]=max(mx[i-1],a[i]);//记录前缀最大值，保证合法
		dp[i]=1;
	}
	for(int i=n;i>=1;i--) {
		for(long long j=1;j<=min(mx[i-1]+1,a[i]-1);j++) ans=(ans+dp[max(j+1,mx[i-1]+1)])%mod;//第 i 个人队伍编号最高为 mx[i-1]+1
		for(int j=1;j<=i;j++) dp[j]=((j-1)*dp[j]+dp[j+1])%mod;//卡空间，滚动数组优化
	}
	cout<<(ans+1)%mod;
}
```

---

## 作者：zzxoier_acmer (赞：0)

# 题目解析：

本题，一上来我们就尝试用暴力做，毕竟绿题也有许多用暴力切的。代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[100009];
const int MOD = 1e6 + 7;
inline int dfs(int now, int mx, int flag)
{
    if (now == n + 1)
    {
        return 1;
    }
    int up = flag ? a[now] : (mx + 1), res = 0;
    for (int i = 1; i <= up; ++i)
    {
        res += dfs(now + 1, max(mx, i), flag && (i == a[now]));
        res %= MOD;
    }
    return res;
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    cout << dfs(1, 0, 1);
    return 0;
}
```

当然，$40$ 分不到。

所以，我们就来考虑数位动态规划，我们设 $f_{i, j, 0}$ 表示前 $i$ 为最高数字为 $j$ 且和前 $i$ 位不同，至于 $f_{i, j, 1}$ 表示和前 $i$ 位不同，为了满足每一位的要求，若下一位与前 $i + 1$ 位不同，我们就直接用 $j$ 乘上 $f_{i, j, 0}$，也就是前面可以随便填的情况，毕竟与前 $i$ 位不同，同时还要考虑前面相同的情况，就要加上 $f_{i, j, 1} \times (a_{i + 1} - 1)$，再加进 $f_{i + 1, j, 0}$，若我们下一位的最大数位为 $j +1$，那么就将前面的所有的 $f_{i, j, 0}$ 加上，上面的转移方程说白了就是要把前面的**球队编号**相同还是不同考虑完全。

# 代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 10005, p = 1000007;
int f[2][N][2];
int a[N], s = 1;
signed main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    f[1][1][1] = 1;
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            f[i & 1][j][0] %= p, f[i & 1][j][1] %= p;
            f[i & 1 ^ 1][j][0] += f[i & 1][j][0] * j;
            f[i & 1 ^ 1][j + 1][0] += f[i & 1][j][0];
            f[i & 1 ^ 1][j][0] += f[i & 1][j][1] * (a[i + 1] - 1);
            (a[i + 1] == j + 1 ? f[i & 1 ^ 1][j + 1][1] : f[i & 1 ^ 1][j][1]) += f[i & 1][j][1];
            f[i & 1][j][0] = f[i & 1][j][1] = 0;
        }
    }
    for (int j = 1; j <= n; j++)
    {
        int i = n;
        f[i & 1][j][0] %= p;
        s += f[i & 1][j][0];
        s %= p;
    }
    cout << s;
    return 0;
}

```

---

## 作者：expecto__patronum (赞：0)

## 思路：
可以先思考一下合法的序列长什么样子。

可以发现后面的选手可以使用前面出现的编号也可以直接自己新建一个队。

其实有在任意时刻 $i$ 序列的 $mex>max$。即要其前缀子序列中 $1$ 到 $max$ 的值都要出现过。

对于这种数排名的问题，容易想到是在某一位字典序小于要求的字典序，然后后面的随便放。

可以直接枚举这样的位置然后统计。最后可以统计出有多少个比当前要小的。
后续有一个可以使用 $a$ 还有 $n$ 个人这个样子的 dp。总复杂度 $n^3$，期望得分 $50$。

### 考虑优化。
可以发现这个 dp 是无法进行优化了，插值还是矩阵乘法什么都不太行。

但是还是存在可以压缩的地方的，考虑两个位置  $i$，$j$dp 到了第 $k$ 位，尽管此时值不同但是可以用的数字是相同的，我们可以将其放在一起。

而且这也极像数位 dp。

上面的压缩过程其实是把最大值相同的放在一起。
## Code:
```
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#include<ctime>
#include<cctype>
#include<queue>
#include<deque>
#include<stack>
#include<cstdlib>
#include<iomanip>
#include<algorithm>
#include<vector>
#include<list>
#include<bitset>
#include<utility>
#include<cmath>
#include<string>
#include<cstring>
#include<map>
#include<set>
#define mod 1000007
#define RE register
#define ll long long
#define putl(x) printf("%lld\n",x)
#define put(x) printf("%d\n",x)
#define put_(x) printf("%d ",x)
#define rep(p,n,i) for(int i=p;i<=n;++i)
#define fep(n,p,i) for(int i=n;i>=p;--i)
#define vep(p,n,i) for(int i=p;i<n;++i)
#define get(x) x=read()
using namespace std;
char *fs,*ft,buf[1<<15];
inline char gc()
{
	return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline int read()
{
	RE int x=0,f=1;RE char ch=gc();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=gc();}
	return x*f;
}
const int MAXN=10010;
int n,u;
int a[MAXN],b[MAXN];
int ans,cnt,mx;
int f[2][MAXN][2];
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int mul(int x,int y){return (ll)x*y%mod;}
inline int mus(int x,int y){return x-y<0?x-y+mod:x-y;}
int main()
{
	//freopen("1.in","r",stdin);
	get(n);get(a[1]);
	if(n==1){puts("1");return 0;}
	f[0][1][1]=1;
	rep(2,n,i)
	{
		u^=1;get(a[i]);
		fep(n,1,j)//枚举上一次的决策.
		{
			f[u][j][0]=f[u][j][1]=0;
			if(f[u^1][j][0])
			{
				f[u][j][0]=add(f[u][j][0],mul(j,f[u^1][j][0]));
				f[u][j+1][0]=add(f[u][j+1][0],f[u^1][j][0]);
			}
			if(f[u^1][j][1])
			{
				f[u][j][0]=add(f[u][j][0],mul(a[i]-1,f[u^1][j][1]));
				if(a[i]==j+1)f[u][j+1][1]=add(f[u][j+1][1],f[u^1][j][1]);
				else f[u][j][1]=add(f[u][j][1],f[u^1][j][1]);
			}
		}
	}
	rep(1,n,j)ans=add(ans,add(f[u][j][1],f[u][j][0]));
	put(ans);return 0;
}

```
[更好阅读体验](https://www.cnblogs.com/chdy/p/13323101.html)

---


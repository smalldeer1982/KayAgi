# 帕秋莉的魔法

## 题目背景

帕秋莉是一个有哮喘病的魔法使。

## 题目描述

众所周知，不同的魔法会需要念不同长度咒语 $a_i$ 但也会产生不同的威力 $b_i$。同时，在发动过一个魔法后也会对接下来发动的一个魔法产生影响 $w_{i,j}$，即在用完第 $i$ 种魔法后第 $j$ 种魔法的威力会变为 $b_j + w_{i.j}$，而且只会影响到下一个魔法。
（当然也可能有魔法会减少咒语长度或者产生治愈的效果的魔法，魔法不可重复使用）

帕秋莉现在知道使用每种魔法后对接下来一种魔法的影响，以及每种魔法需要念的咒语长度和产生的威力。同时，由于编号大的魔法比编号小的魔法高级（编号顺序即给出的顺序），所以一个魔法只有在编号不大于自己的魔法后使用才能保证魔法的连续性。现在她想知道念出长度为 $m$ 的咒语最大能产生多少威力。（以免下次在战斗中又因为哮喘病发作而惨败）



## 说明/提示

对于 $20\%$ 的数据，保证 $a_i = 1$。

对于另外 $20\%$ 的数据，保证所有数字均为正整数。

对于 $100\%$ 的数据，$1 \le n \le 50$，$|a_i|,|b_i|, |w_{i,j}|\le 50$，$|m| \le 2500$，保证运算过程中的数字大小均在 int 范围内。

## 样例 #1

### 输入

```
2 5
3 3
2 2
1 2
3 4```

### 输出

```
7```

## 样例 #2

### 输入

```
2 6
3 3
2 2
1 2
3 4```

### 输出

```
-1```

# 题解

## 作者：koishi_offical (赞：7)



### 题意分析

再看一下题意：有 $n$ 段膜法，每段膜法有一个长度 $a$，威力 $b$。如果一个膜法 $j$ 在另一个膜法 $i$（$i$<$j$） 后释放，威力增加 $w(i,j)$。给你一个长度 $m$，释放一堆膜法，使得膜法总长度为 $m$，且膜法的总威力最大，求膜法威力的最大值，如果不能满足长度为 $m$，则输出 *-1*。

看起来乱七八糟，让我们把东方语翻译成 OI 语。


------------


有 $n$ 个物品和一个容量为 $m$ 的背包，每个物品有一个体积 $a$ 价值 $b$；

如果一个物品 $j$ 在物品 $i$ 后放进背包,价值增加 $w(i,j)$；

求使背包恰好装满的情况下，最大的价值总和，如果背包无法恰好装满，输出 *-1*。


------------


很明显的一个背包问题。

那么状态转移方程式显而易见。

设 在前 $i$ 个物品里取，且总长度恰好为 $j$ （注意是恰好，这是一般的背包不太一样）的最大价值为 $f(i,j)$

$f(i,j)=\max(f(k,j-a(i))+b(i)+w(k,i)) (0<k<i)$

初始状态 $f(0,0)=0$


------------


但是，如果按照这个思路写，就会 WA。

为什么？因为帕秋莉有了咲夜的帮助，使得一段膜法的长度可以为负数，

所以我们要将所有状态都向右位移一个值 $mov$。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=60,M=5e3;
int n,m;
int a[N],b[N],w[N][N],mov=2501;
int f[N][M+M];
int main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++) cin>>w[i][j];
    memset(f,0xcf,sizeof(f));
    f[0][mov]=0;
    for(int i=1;i<=n;i++)
      {
         for(int j=a[i];j<M+mov;j++)//因为a[i]可以为负数，所以j要枚举到一个极大值
          for(int k=0;k<i;k++)
            if(f[k][j-a[i]]!=f[0][0])//判断是否可行
              f[i][j]=max(f[i][j],f[k][j-a[i]]+b[i]+w[k][i]);//状态转移
      }
    int ans=f[0][0];
    for(int i=0;i<=n;i++) ans=max(ans,f[i][m+mov]);
    if(ans!=f[0][0]) cout<<ans;
    else cout<<-1;
}
```

---

## 作者：InL0ne1iN3ssy (赞：4)

[P4912](https://www.luogu.com.cn/problem/P4912)

------------
### 形式化题意
有 $n$ 个物品和一个容量为 $m$ 的背包，每个物品的体积 $a_i$、价值 $b_i$，一个物品 $j$ 在物品 $i$ 后放进背包，其价值增加 $w_{i,j}$（$i<\ j$）。

求使背包刚好装满的情况下最大的价值总和，如果背包无法装满，输出 $-1$。

------------
### 分析
从题目中魔法不可重复使用这一点来看，这显然是一道01背包的变式题，而我们所需要注意的是在01背包固有的两维上加上一维以来表示 $w_{i,j}$，时间复杂度 $O(mn^2)$。

我们不难从01背包的状态转移方程中推出此题的状态转移方程：

以 $f[i][j]$ 表示在前 $i$ 个魔法中选择，选出的魔法刚好构成长度为 $j$ 的咒语的最大威力，状态转移方程如下

$f[i][j]=\max(f[i][j],f[k][j-a[i]]+b[i]+w[k][i])$（$0<\ k<\ i$）

初始状态 $f[0][0]=0$，数组 $f$ 应初始化一个极小值。

此时在让我们来看看这道题的数据范围及相关约定，显然 $O(mn^2)$ 是完全可以通过的，但同时套上 $a_i,b_i$ 的绝对值符号注定了这道题还有坑。

$|a_i|,|b_i|\le2500$ 意味着一段魔法的长度可以为负数，威力也可以为负数，这大概是对应了之前题目里所说的“当然也可能有魔法会减少咒语长度或者产生治愈的效果的魔法”。

所以我们需要将 $f$ 数组的第二维（记录长度状态的那一维）整体向右移动一个值，这个值至少大于 $2500$。

------------
### 代码
```cpp
#include <iostream>
#include <cstring>
//#define int long long//若用memset初始化f数组就要开long long，具体原因不太清楚.
#define _ 0
using namespace std;
const int N = 60, M = 5e3, INF = 0x3f3f3f3f, My_move = 2501;//move会导致函数名冲突.
int a[N], b[N], w[N][N], f[N][M + My_move];
int n, m, ans = -INF;
int main (){
	ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
//	memset (f, -0x3f, sizeof(f));//用memset填充会更耗空间
	cin >> n >> m;
	for (register int i = 1; i <= n; i++)
		cin >> a[i] >> b[i];
	for (register int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			cin >> w[i][j];
   	for (register int i = 0 ; i <= n ; i++)
       	for (int j = 0 ; j <= M + My_move ; j++) f[i][j] = -INF;//若不想开long long就这样初始化
	f[0][My_move] = 0;//初始状态
	for (register int i = 1; i <= n; i++)
		for (register int j = a[i]; j < M + My_move; j++)
			for (register int k = 0; k < i; k++){
				if (f[k][j - a[i]] != f[0][0])//判断是否为初状态
					f[i][j] = max (f[i][j], f[k][j - a[i]] + b[i] + w[k][i]);//状态转移
			}
	for (register int i = 0; i <= n; i++)
		ans = max (ans, f[i][m + My_move]);//查找最大的威力
	cout << (ans == -INF ? -1 : ans);//判断是否有解
	return 0^_^0;//结束了罪恶的一生
}
```

---

## 作者：FallingFYC_ (赞：4)

[原题](https://www.luogu.com.cn/problem/P4912)

---
### 题意

给你 $n$ 个物品和一个容量为 $m$ 的背包，每个物品都有其重量 $a_i$ 和价值 $b_i$，若先放入了第 $j$ 个物品再放第 $i$ 个物品价值增加 $w_{i,j}$，请你求出在背包刚好装满的情况下价值最大为多少，若无解输出 -1。

---
### 思路

背包 DP。

设 $f_{i , j}$ 标识在前 $i$ 种物品中取，并且总重量为 $j$ 时的最大价值，那么状态转移方程是：

$$f{i , j} = f_{k , j - a_i} + b_i + w_{k , i}$$

初始把 $f$ 数组设成极小值（因为价值有可能是负数）并让 $f_{0 , 0} = 0$。

因为价值有可能是负数，所以需要让 $f$ 的第二维整体右移一个值。

---
### 代码：
```cpp
#include "bits/stdc++.h"
using namespace std;
const int MAXM = 2500;
const int MOV = 3000;
const int INF = 1e9 + 5;
int n , m , a[55] , b[55] , w[55][55] , f[55][MAXM + MOV + 5] , ans;
int main()
{
    cin >> n >> m;
    for (int i = 1 ; i <= n ; i++) cin >> a[i] >> b[i];
    for (int i = 1 ; i <= n ; i++)
        for (int j = 1 ; j <= n ; j++) cin >> w[i][j];
    
    for (int i = 0 ; i <= n ; i++)
        for (int j = 0 ; j <= MAXM + MOV ; j++) f[i][j] = -INF;
    f[0][MOV] = 0;
    for (int i = 1 ; i <= n ; i++)
        for (int j = a[i] ; j < MAXM + MOV ; j++)
            for (int k = 0 ; k < i ; k++)
                if (f[k][j - a[i]] != -INF)
                    f[i][j] = max(f[i][j] , f[k][j - a[i]] + b[i] + w[k][i]);
    ans = -INF;
    for (int i = 0 ; i <= n ; i++) ans = max(ans , f[i][m + MOV]);
    cout << (ans == -INF ? -1 : ans);
    return 0;
}
```

---

## 作者：Yuanchenpu (赞：4)

[link](https://www.luogu.com.cn/problem/P4912)


------------

题意：  
有n个物品，每个物品 $i$ 有两个属性：体积 $a_i$ 和价值 $b_i$ 。选择物品 $i$ 接着选物品 $j$ 能使物品 $j$ 的价值增加 $w_{i,j}$ ，不能重复选择物品。  
发现有两个属性，想到背包。  
可以设 $f_{i,l}$ 表示已经考虑了前 $i$ 个物品，并且选择第 $i$ 个物品，体积为 $l$ 的最大价值。
$$f_{i, l}=max(f_{k,l-a[i]}+b_i+w_{k,i})\quad(k< i)$$

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int MAXN = 55;
const int MAXL = 2510;
const int INF = 0x7f7f7f7f;

int f[MAXN][MAXL];
int a[MAXN], b[MAXN];
int w[MAXN][MAXN];
int n, m;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", a + i, b + i);
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1;  j <= n; j++) {
			scanf("%d", &w[i][j]);
		}
	}
	memset(f, 0x80, sizeof(f));
	f[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = a[i], l; j < MAXL; j++) {
			l = j - a[i];
			for (int k = 0; k <= i - 1; k++) {
				if (f[k][l] != f[0][0]) {
					f[i][j] = max(f[i][j], f[k][l] + b[i] + w[k][i]);
				}
			}
		}
	}
	int ans = -INF;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, f[i][m]);
	}
	printf("%d\n", ans == -INF? -1:ans);
	return 0;
}
                          
```
------------
然后你就会发现，一个点也[过不了](https://www.luogu.com.cn/record/36810505)（  
因为 $a_i$ 可能是一个负数，所以我们在程序实现时应该把 $f$ 数组整体右移一个特定的值 $mov$ ，在这里 $mov$ 要至少比 $m$ 要大。  
时间复杂度 $O(mn^2)$ 


真正的代码：  
~~拒绝压行，从我做起~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define _ 0
using namespace std;

const int MAXN = 55;
const int MAXL = 2510;
const int INF = 0x7f7f7f7f;
const int MOV = 3e3;

int f[MAXN][MAXL + MOV];
int a[MAXN], b[MAXN];
int w[MAXN][MAXN];
int n, m;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", a + i, b + i);
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1;  j <= n; j++) {
			scanf("%d", &w[i][j]);
		}
	}
	memset(f, 0x80, sizeof(f));
	f[0][MOV] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = a[i], l; j < MAXL + MOV; j++) {
			l = j - a[i];
			for (int k = 0; k <= i - 1; k++) {
				if (f[k][l] != f[0][0]) {
					f[i][j] = max(f[i][j], f[k][l] + b[i] + w[k][i]);
				}
			}
		}
	}
	int ans = -INF;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, f[i][m + MOV]);
	}
	printf("%d\n", ans == -INF? -1:ans);
	return 0 ^_^ 0;
}

```

---

## 作者：Link_Cut_Y (赞：3)

 - 算法：**DP, 背包，动态规划**
 
 - 简化版题目：
 
 给定 $n$ 个物品，物品的价值为 $v_1 - v_n$，物品的体积为 $w_1 - w_n$。需要选择一些物品，使它们的体积和为 $V$ ，同时让他们的价值和最大。需要注意的是，如果先选择了物品 $i$ ，后选择了物品 $j$ （$i < j$），那么可以额外获得 $add_{i, j}$ 的价值。
 
 - 题目分析：这道题我用的是刷表法（不知道什么是刷表法的请自查）
 
 首先，这道题明显是一道 **01背包** 吧（
 
 但是这道题和普通01背包不一样的地方是，当我们选择当前物品是，还需要考虑下一个要选择的是什么物品（因为有可能额外增加价值嘛...毕竟还是想多赚一点）。
 
 所以，我们在 01 背包的 dp 数组基础上多开一维，用来记录当前在选择第几个物品。这样，我们在转移的时候，用 for 循环枚举的时候，就可以清楚的查询到上次使用的魔法是什么了。
 
 设当前要选择第 $i$ 个魔法，接下来要选的是第 $j$ 个魔法，在选择 $i$ 的时候已经用掉了 $k$ 的背包容积。
 
 转移方程为： $f_{j, k + w_j} = max(f_{j, k + w_j}, f_{i, k} + v_j + add_{i, j})$。
 
 代码大概长这个样子（注意这是错误代码 ...）
 
 ```
	memset(f, -0x3f, sizeof f);
	f[0][0] = 0;
	
	for (int i = 0; i <= n; i ++ )
		for (int j = i + 1; j <= n; j ++ )
			for (int k = m; k >= 0; k -- )
				f[j][k + w[j]] = max(f[j][k + w[j]], f[i][k] + v[j] + add[i][j]);
 ```
 
 恭喜你拿到了 **50 pts**。
 
 为什么呢？不知道你有没有注意到题目的数据范围的绝对值符号...难道魔法咒语的长度还能为负数（对于这点我是真的雾
 
 所以，我们需要在 $f$ 数组上面加上一个偏移量 $delta$ （因为数组下标不能为负数嘛）
 
 对于无解输出 -1 的情况，特判掉就可以了。如果每个咒语魔法值都是负的，增加的魔法值 $add$ 也都取成最小，那么答案最劣就是 （$ -50-50$） $\times \ 50 = -5000$，也就是说，如果我们的结果小于 -5000，那么可以直接判定为 -1 。
 
 - 参考代码
 
 
```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 52, M = 2500;

int v[N], w[N];
int f[N][(M << 1) + 10];
int n, m, add[N][N];
int delta = 2500;

int main()
{
	scanf("%d%d", &n, &m);
	
	for (int i = 1; i <= n; i ++ )
		scanf("%d%d", &w[i], &v[i]);
	
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= n; j ++ )
			scanf("%d", &add[i][j]);
	
	memset(f, -0x3f, sizeof f);
	f[0][delta] = 0;
	
	for (int i = 0; i <= n; i ++ )
		for (int j = i + 1; j <= n; j ++ )
			for (int k = delta << 1; k >= 0; k -- )
				f[j][k + w[j]] = max(f[j][k + w[j]], f[i][k] + v[j] + add[i][j]);
	
	int res = -0x3f3f3f3f;
	
	for (int i = 1; i <= n; i ++ )
		res = max(res, f[i][m + delta]);
	
	printf("%d\n", (res < -5000 ? -1 : res));
	
	return 0;
}
```

 这样就轻松拿到 [rk1](https://www.luogu.com.cn/record/list?pid=P4912&orderBy=1&status=&page=1) 辣
 
 再贴一个拿到 **rk2** 的填表法代码叭（就当免费赠送了
 
```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 60, M = 2510;
int f[N][M << 1]; // f[i][j] 表示选择第 i 个物品，体积为 v 的价值。 
int n, m;
int v[N], w[N], add[N][N];
int delta = 2500;

int main()
{
	scanf("%d%d", &n, &m); // n 为物品数量，m 为背包容积
	
	for (int i = 1; i <= n; i ++ )
		scanf("%d%d", &v[i], &w[i]);
		
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= n; j ++ )
			scanf("%d", &add[i][j]);
			
	memset(f, -0x3f, sizeof f);
	f[0][delta] = 0;
	
	for (int i = 1; i <= n; i ++ ) // 枚举当前要用什么魔法 
		for (int j = delta + delta; j >= v[i]; j -- ) // 枚举当前剩余咒语长度（容积） 
			for (int k = 0; k < i; k ++ ) // 枚举上一个使用的是什么魔法
				f[i][j] = max(f[i][j], f[k][j - v[i]] + w[i] + add[k][i]);
				
	int res = -0x3f3f3f3f;
	for (int i = 1; i <= n; i ++ )
		res = max(res, f[i][m + delta]);
		
	printf("%d\n", (res < -5000) ? -1 : res);
	
	return 0;
} 
```
 
 完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：Firsry (赞：2)

# P4912 帕秋莉的魔法 题解

本题是处理 **含有负值的01背包** 的【模板】

题目翻译：

$n$ 个物品，$m$ 的**初始资金**，对于每个物品 $i$ 有 $cost_i$ 的**花费**与 $value_i$ 的**收益**，而且我们只能按照**输入的先后顺序**选择物品，并且对于每次选择物品，会获得 $w_{i,j}$ 的**增益**，一并加在价值当中。

我们显然可以用 $f_{i,j}$ 唯一确定一种状态：考虑前 $i$ 个物品时，用 $j$ 的代价得到的最大收益表示为 $f_{i,j}$。这个只要是做了背包的同学都没有问题。~~(应该没有人把水紫当成 采药 来做吧)~~

每个物品只有选或不选两种可能。不选则保持原状态。选则考虑从谁转移而来。题目要求按输入的顺序，所以在第 $i$ 个的时候可以考虑 $[0,i)$ 的情况，我们用变量 $k$ 实现枚举。所以 $f_{i,j}$ 可以由 $f_{k,j'}$ 得来，而 $j'+cost_i=j$ 所以得到如下状态转移方程：

$f_{i,j} = \max(f_{i,j}, f_{k,j-cost_i}+value_i+w_{i,j})$ 。

重点来了：**处理负数** 。

由于 ~~冰冷昂贵入云涉水的~~ Cpp 语言不支持数组下标为负，所以使用平移的方式转正，平移的量取决于最小的负值：$-2500$ ，所以设 :

```cosnt int mov = 2501; // move 为一个 Cpp 函数``` 。

1. 转移边界。本身边界在 $f_{0,0}$ 位置，表示 没有物品没有花费 的情况，应该初始化为 $0$，但现在平移了 $mov$，所以 $f_{0,mov}=0$。

2. 循环条件。现在把 $mov$ 看成零，因为 $cost$ $value$ $w$ $m$ 都有可能是负值，所以我们必须考虑很小到很大的值。在转移中有 $j-cost_i$ 这一步，所以 $j>=cost_i$ 这是起码的。$j$ 的最大值就是当 $m==2500$  的时候可以取到 $(mov<<1)+1$ 的值。所以调的最久的

   ```for(int j=cost[i];j<=(mov<<1)+1;++j)``` 

   已经考虑完毕了。

3. 初始化以及输出。状态转移中使用了 $\max(f_{1,j},...$ ，所以 $f_{i,j}$ 必须初始化为一个极小值，个人喜欢

   ```const ll INF = 0x3f3f3f3f3f3f3f3f``` ,

   但其实不开 *龙龙*  用 `int` 都没有关系。输出的时候我们要找的是所有花费为 $m+mov$ 的情况中收益最高的，所以用 `ans=-INF` 然后遍历即可。

那么本篇题解就...

**还没完呢！小子！**

在循环条件中有一个必不可少的句子：`if(f[k][j-cost[i]]!=-INF)`

 为什么？因为他此时依靠的$f_{k,j-cost_i}$ 必须是有意义的。他可能后来被 $f_{0,mov}$ 间接地赋上有意义的值，但是此时他的 ```-INF``` 并不是可以利用的，所以要排除掉。（本蒟蒻在这里 WA了两三次 ... ）

顺带提一下，虽然用 vector 又慢又要手动处理边界，但是 vector 提供的 .at(i) 数组访问形式，在功能上和 [i] 一致，并且在数组越界的时候可以抛出异常，在 Run Time Error 的时候值得一试。

```
#include<bits/stdc++.h>
#define ll long long

using namespace std;

const ll mov = 2501;
const ll INF = 0x3f3f3f3f3f3f3f3f;
ll n, m;
vector<ll> cost, value;
vector<vector<ll>> w, f;

void in() {
	scanf("%lld%lld", &n, &m);
	cost.resize(n + 1), value.resize(n + 1);
	w.resize(n + 1, vector<ll>(n + 1));
	f.resize(n + 1, vector<ll>(mov * 2 + 5000, -INF));
	for (int i = 1; i <= n; ++i)
		scanf("%lld%lld", &cost.at(i), &value.at(i));
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			scanf("%lld", &w.at(i).at(j));
	return;
}
ll dp() {
	f.at(0).at(mov) = 0;
	for (int i = 1; i <= n; ++i)
		for (int j = cost[i]; j <= (mov<<1)+1; ++j)
			for (int k = 0; k < i; ++k)
				if (f[k][j - cost[i]] != f[0][0])
					f[i][j] = max(f[i][j], f[k][j - cost[i]] + value[i] + w[k][i]);
	ll ans = f[0][0];
	for (int i = 0; i <= n; ++i)
		ans = max(ans, f.at(i).at(m + mov));
	if (ans == f[0][0]) ans = -1;
	return ans;
}

int main() {
	in();
	cout << dp();
	return 0;
}
```

华丽结束，希望能排到你的 WA 点。

推荐一波[个人博客](https://www.cnblogs.com/firsry/articles/18697854)，有着更加优秀的阅读体验。希望拥有自己个人博客的同学也可以去博客园创建。

---

## 作者：Leap_Frog (赞：2)

# P4912帕秋莉的魔法（题解）

[题目传送门](https://www.luogu.org/problem/P4912)

### PS.
楼上的题解解释较少，希望这篇题解能帮助到你

### 题目大意
有$\texttt{n}$个物品，每个物品有一个重量和一个价值，只能从前往后取物品。  
取了前面的物品之后会对下一个物品有一定的影响，使后一个物品的价值加上一个值。  
现在，你需要取重量和恰好为$\texttt{n}$的一些物品，使它们的价值和最大。  

### 题目分析
首先，每一个物品有两个属性，第一时间想到的应该是背包。  
所以根据背包常用套路，设$\texttt{dp[x][y]}$表示前$\texttt{x}$个物品中取出重量恰为$\texttt{y}$的最大价值和。  
所以$\texttt{dp[x][y+a[x]]=max(dp[k][y]+b[x]+w[k][x])}$。  

### 题目注意点
这道题如果这样写的话不会得到全分，~~具体得分未亲测~~。  
因为这题中$\texttt{w}$可能为负数，如果单纯这样写会$\texttt{RE}$或$\texttt{WA}$。  
所以我们可以给第二位加一个偏移量，相当于程序中的$\texttt{dp[i][j]}$表示我们的$\texttt{dp[i][j-2500]}$。  
这样就能得全分了QwQ

### 上代码
~~压行码风勿喷QwQ~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55,V=2500;	//V：注意点重的偏移量
int n,m,ans,a[N],b[N],w[N][N],dp[N][(V<<1)+5];	//此处解释略
int main()
{
	scanf("%d%d",&n,&m);	//读入
	for(int i=1;i<=n;i++) scanf("%d%d",a+i,b+i);
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%d",&w[i][j]);
	memset(dp,~0x3f,sizeof(dp)),dp[0][V]=0;		//初始化为最小值，方便以后处理
	for(int i=0;i<=n;i++) for(int j=i+1;j<=n;j++) for(int k=(V<<1);k>=0;k--) if(dp[i][k]!=dp[0][0]) dp[j][k+a[j]]=max(dp[j][k+a[j]],dp[i][k]+b[j]+w[i][j]);	//最关键的一行语句，动态规划转移
	ans=dp[0][0];for(int i=1;i<=n;i++) ans=max(ans,dp[i][m+V]);		//从所有恰好为m条语句中找出答案
	return (ans==dp[0][0]?puts("-1"):printf("%d\n",ans)),0;	//完美地一行输出
}
```
拒绝抄袭代码，营造良好洛谷

---

## 作者：Sakura_梦瑶 (赞：2)

本题可以直接按照题目约束条件背包转移,有负数情况添加偏移量即可,要注意m<0的情况 有细节要处理,我就是把最小值设置为-1导致半天调不出来70pt卡死（这种错误好像越犯越多,或许这就是noip爆的根源
以下是代码 有压行（帕秋莉确实很棒
```cpp
#include<bits/stdc++.h>
#define fer(x,y,z) for(int x=y;x<=z;x++)
#define N 60
using namespace std;
int vl[N][N*85],a[N],b[N],c[N][N],n,m,x;
main(){
    cin>>n>>m;memset(vl,-10,sizeof vl);
    fer(i,1,n)scanf("%d%d",&a[i],&b[i]);
    fer(i,1,n)fer(k,1,n)scanf("%d",&c[i][k]);
    vl[0][2500]=0;fer(i,0,n)fer(k,i+1,n)
     for(int j=5000;j>=0;j--)if(vl[i][j]!=vl[0][0])
     vl[k][j+a[k]]=max(vl[k][j+a[k]],vl[i][j]+b[k]+c[i][k]);
    x=vl[0][0];fer(i,1,n)x=max(x,vl[i][m+2500]);
	if(x!=vl[0][0])cout<<x;else cout<<-1;
}
```

---

## 作者：chengni (赞：2)

昨天被这道题吓到了，于是就没有做，今天仔细看看发现确实昨天想的不对，因为数据中会有负数，我们先考虑没有负数的情况

很容易想出来一个 DP 的方案，大概是 $(n^2m)$ 的复杂度。

$f[i][j]$ 表示长度为 $j$ 并且最后一个魔法为 $i$ 的最大威力。

因为只能按照顺序释放魔法，可以得出下面的转移过程

```cpp
	for(int i=1;i<=n;i++){
    	for(int j=0;j<i;j++){
        	for(int k=0;k<=m;k++){
            	//balabala一顿转移
            }
		}
    }
```

但是这道题坑啊，它有负数啊

最最最起码数组是可能会负的啊

所以我们将数组整体移一个数

然后我们发现枚举长度的时候似乎有那么一点点问题

我们预处理出来最长可能长度和最短可能长度进行转移

然后似乎我们就把做法口胡出来了

其实把跟上面差不多，就是加上了我说的那些东西

还有就是数组赋值的时候小一点，因为答案可能会负啊

转移方程大概是这样的

```cpp
	memset(f,0x8f,sizeof(f));
	f[0][p]=0;//p是整体移动的那个数
	for(int i=1;i<=n;i++){//接下来释放哪个法术
		for(int j=0;j<i;j++){//由哪一个法术释放过来
			for(int k=minn;k<=maxn;k++){//minn,maxn是最短，最长的可能长度
				if(f[j][k]!=inf) f[i][k+a[i]]=max(f[i][k+a[i]],f[j][k]+b[i]+w[j][i]);//转移
			}
		}
	}
```

统计答案的时候枚举最后释放的法术，就好了。

还是注意 $ans$ 初始化要小一点































---

## 作者：HS_xh (赞：1)

# [P4912](https://www.luogu.com.cn/problem/P4912)

- 题意：给定 $n$ 种魔法，每个魔法的长度为 $a$，威力为 $b$，如果一个魔法 $j$ 在另一个魔法 $i$ 后使用则威力增加 $w(i,j)$。给定长度 $m$，使得总长度为 $m$ 并且威力最大，求威力的最大值。如果不能满足长度为 $m$，则输出 $-1$。

- 做法：**背包 DP**，动态转移方程为

$f(i,j)=\max(f(i,j),f(k,j-a_i)+b_i+w(k,i))$

注意，题目数据范围中 $a$，$b$，$w_{i,j}$ 与 $m$ 都有可能为**负数**，所以应该都加一个数使其成为正数。

- 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=4e3;	
int a[60],b[60],w[60][60],f[60][maxn+maxn];
int t=1145;//加一个数使得各数不为负数
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		cin>>a[i]>>b[i];
	for(int i=1;i<=n;++i)
	   for(int j=1;j<=n;++j)
		cin>>w[i][j];
		 memset(f,0xcf,sizeof(f));
         f[0][t]=0;//初始化
	for(int i=1;i<=n;++i)
	{
		for(int j=a[i];j<maxn+t;j++)
			for(int k=0;k<i;++k)
			   if(f[k][j-a[i]]!=f[0][0])
			   f[i][j]=max(f[i][j],f[k][j-a[i]]+b[i]+w[k][i]);
	}
	int ans=f[0][0];
	for(int i=0;i<=n;++i)
		ans=max(ans,f[i][m+t]); 	
		if(ans!=f[0][0])
		cout<<ans;
		else
		cout<<-1;
}
```


---

## 作者：西卡洛斯 (赞：1)

Patchouli 可爱。

题目大意： $n$ 个物品，体积为 $m$ 的背包，第 $i$ 个物品有体积 $a_i$ 和价值 $b_i$ ，先选择物品 $i$ 后选择物品 $j$ 会使物品 $j$ 的价值增加 $w(i,j)$ ，物品不可以重复选择。

很明显的背包问题，可推得转移方程为 $f(i,j)=max(f(i,j-a_i)+b_i+w(i,j)) \space (k<i)$ 
 
 但是本题的 $a_i$ 可能为负数，于是我们把 $f(i,j)$ 数组的第二位加上一个 $move\space(move>m)$ ，避免负数对答案造成错误影响。
 
代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int M=60,N=2510,move=114514;
int n,m;
int a[M],b[M],w[M][M];
int dp[M][N+move];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&b[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&w[i][j]);
	memset(dp,-0x7f,sizeof(dp));
	dp[0][move]=0;//注意不是dp[0][0]了，因为进行了偏移
	for(int i=1;i<=n;i++)
	{
		for(int j=a[i];j<N+move;j++)
		{
			for(int k=0;k<i;k++)
			{
				if(dp[k][j-a[i]]!=dp[0][0]) dp[i][j]=max(dp[i][j],dp[k][j-a[i]]+b[i]+w[k][i]);
			}
		}
	}
	int ans=dp[0][0];//ans要赋为一个极小值
	for(int i=1;i<=n;i++) ans=max(ans,dp[i][m+move]);
	printf("%d",ans==dp[0][0]?-1:ans);
	return 0;
}
```


---

## 作者：ty_mxzhn (赞：0)

## 题意

有 $n$ 个物品，每次从左到右选，选完一个再选一个会有额外贡献。对这些物品做背包。

## 题解

$f_{i,j}$ 表示前 $i$ 个物品选完，强制选了第 $i$ 个，物品体积 $j$ 的贡献。

转移直接 $\displaystyle f_{i,j}=\max_{1\le k\le j}f_{k,j-w_i}+v'_{k,i}+v_i$。

但是题意里啥都是负数，所以需要负数下标偏移。

时间复杂度 $O(n^2V)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[57],b[57];
int w[57][57];
int dp[57][7507];
const int rev=2501;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&b[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&w[i][j]);
	for(int i=0;i<=n;i++){
		for(int k=0;k<=7501;k++){
			dp[i][k]=-0x3f3f3f3f;
		}
	}
	int ans=-0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		dp[i][a[i]+rev]=b[i];
		for(int k=max(0,0-a[i]);k<=max(7501,7501-a[i]);k++){
			for(int j=1;j<i;j++){
				if(dp[j][k]!=dp[0][0]) dp[i][k+a[i]]=max(dp[i][k+a[i]],dp[j][k]+b[i]+w[j][i]);
			}
		}
		ans=max(ans,dp[i][m+rev]);
	}
	if(ans==dp[0][0]) printf("-1\n");
	else printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Union_Find (赞：0)

~~其实这道题本来到不了紫的。~~

可以看到，这道题就是一个背包，只是加了一点点思维量，就是两个物品是相关联的。那么只需要设 $f[i][j]$ 为前 $i$ 个物品占了 $j$ 的体积，并且选了第 $i$ 个的最大值。

方程很好推，就是 $f[i][j] = \max(f[i][j], f[k][j - a[i]] + b[i] + w[k][i])k \in [0,i)$。

但是这题有个坑点，如果你仔细看数据范围，带了绝对值，这题就不简单了。因为体积可以为负数，所以转移时会越界。怎么办呢？就在所有 $j$ 前面加上一个常数即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
const ll P = 10000;
ll n, m, ans, f[55][20005], a[55], b[55], w[55][55];
int main(){
	scanf ("%lld %lld", &n, &m);
	for (int i = 1; i <= n; i++) scanf ("%lld %lld", &a[i], &b[i]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf ("%lld", &w[i][j]);
	memset (f, 0x80, sizeof(f));
	ll qwert = f[0][0];
	f[0][P] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = a[i]; j <= 20000; j++)
			for (int k = 0; k < i; k++)
				if (f[k][j - a[i]] != qwert)
					f[i][j] = max(f[i][j], f[k][j - a[i]] + b[i] + w[k][i]);
	ans = qwert;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i][P + m]);
	if (ans == qwert) puts("-1");
	else printf ("%lld", ans);
	return 0;
}

```

---

## 作者：封禁用户 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P4912)

# First 题意

有 $n$ 件物品和一个容量为 $m$ 的背包，每个物品都有一个体积 $a$ 和价值 $b$，并且选择 $i$ 和 $j$ 物品，价值会 $+w_{ij}$，求装满背包的最大价值。

# Second 思路

简化完题意，可以发现这就是一个 `dp` 背包，只是加上了 $w$ 数组。

定义 $f_{ij}$ 为前 $i$ 个物品中占据 $j$ 容量的最大价值，并且必须选 $i$。

那么转移方程就是。

$f_{ij}= \max(f_{k(j-a_i)}+b_i+w_{ki})$

根据这个方程，就可以推算出 $f$ 数组。

最后结果就是 $M\max(f_{im})$。

# Third 坑！！！

![](https://cdn.luogu.com.cn/upload/image_hosting/7y53d1qa.png)

当你就要提交代码时，我会给你看上面这张图。

请注意，$a_i$ 可以是负数，也就是有负体积。

所以请在容量上加上一个常数。

# Fourth Code

前面是快读快写，不用看。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
il ll rd(){
	ll x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + ch - '0';
		ch = getchar();
	}
	return x * f;
}
il void wt(ll a){
	if (a < 0){
		a = -a;
		putchar('-');
	}
	if (a > 9) wt(a / 10);
	putchar (a % 10 + '0');
}
il void sp(){
	putchar(' ');
}
il void et(){
	putchar('\n');
}
const ll M = 10000;
ll n, m, f[55][12505], a[55], b[55], w[55][55]; 
int main(){
	n = rd(), m = rd();
	for (int i = 1; i <= n; i++) a[i] = rd(), b[i] = rd();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			w[i][j] = rd();
	memset (f, 0x80, sizeof(f));
	f[0][M] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = a[i]; j <= 12505; j++)
			for (int k = 0; k < i; k++)
				if (f[k][j - a[i]] != f[0][0])
					f[i][j] = max(f[i][j], f[k][j - a[i]] + b[i] + w[k][i]);
	ll ans = -1e12;
	for (int i = 1; i <= n; i++)
		ans = max(ans, f[i][m + M]);
	if (ans == -1e12) wt(-1);
	else wt(ans);
	return 0;
}
```

---


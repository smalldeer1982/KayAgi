# [COCI 2017/2018 #6] Mate

## 题目描述

小 Mate 收到了一个由小写英文字母组成的数组，作为他父母送的礼物。为了让这个聪明的礼物有些用处，他决定在写下一首歌时用它来寻找押韵。

为了找到特定的韵脚，Mate 想要选择一个长度为 D 的单词，该单词以字符数组 XY 结尾，即倒数第二个字母是 X，最后一个字母是 Y。Mate 选择单词的过程是首先划掉给定序列中的一些字母，然后将未划掉的字母合并成一个单词。他想知道有多少种不同的方式可以划掉字母，以满足给定的条件。

如果两个单词的划掉字母的位置集合不同，则认为这两个单词是不同的。

## 说明/提示

在占总分 40% 的测试用例中，将满足 |S| ≤ 50。

在额外占总分 40% 的测试用例中，将满足 |S| ≤ 200。

**第一个测试用例的说明：**

以“na”结尾的长度为 2 的单词可以通过以下方式获得：

~~b a n a~~ **n a**，~~b a~~ **n a** ~~n a~~，~~b a~~ **n** ~~a n~~ **a**。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
banana
3
2 na
3 ba
4 nn```

### 输出

```
3
0
1```

## 样例 #2

### 输入

```
malimateodmameitate
3
10 ot
7 aa
3 me```

### 输出

```
2
464
56```

# 题解

## 作者：jiangjiangQwQ (赞：8)

### 思路
枚举字符 $X$ 和 $Y$ 在原字符串中的出现位置分别为 $i$ 和 $j$。那么在答案中 $i=D-1$ 且 $j=D$，中间字符均删除，并在 $i$ 前面保留 $D-2$ 个字符。显然只有当 $i\geq D-2$ 时才能使得 $i,j$ 成为一组合法解。保留字符的方案数为 $\binom{i-1}{D-2}$，直接统计就好了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2005,Mod=1e9+7;
string s;
int q,d,sy[N][26];
char x,y;
int f[N][N];
int C(int n,int m){
    return f[n][m];
}int g[N][26][26];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>s>>q;
    int n=s.size();
    f[0][0]=1;
    for(int i=1;i<n;i++){
        f[i][0]=1;
        for(int j=1;j<=i;j++){
            f[i][j]=(f[i-1][j-1]+f[i-1][j])%Mod;
        }
    }memset(g,-1,sizeof g);
    for(int i=n-1;i>=0;i--){
        for(int j=0;j<26;j++){
            sy[i][j]=sy[i+1][j]+(s[i]-'a'==j);
        }
    }
    while(q--){
        cin>>d>>x>>y;
        if(~g[d][x-'a'][y-'a']){cout<<g[d][x-'a'][y-'a']<<'\n';continue;}
        int ans=0;
        for(int i=0;i<n;i++){
            if(s[i]==x&&d-2<=i){
                int sumy=sy[i+1][y-'a'];
                // cout<<i<<' '<<sumy*C(i,d-2)%Mod<<'\n';
                ans=(ans+sumy*C(i,d-2)%Mod)%Mod;
            }
        }cout<<(g[d][x-'a'][y-'a']=ans)<<'\n';
    }
    return 0;
}
```

---

## 作者：LlLlCc (赞：8)

~~本题第一篇题解~~

------------
## 题目大意：
给定一个字符串S，再Q次询问，每次询问给出一个正整数K和两个字符a，b。

对于每次询问：在字符串S中，有多少个长度为K的子字符串以a，b结尾（倒数第二的字符为a，倒数第一个字符为b）。

------------
题意简单明了，但可能一时没有思路。

我们先来想一下，假如我们**已经确定a，b的位置**，那么有多少种方案呢？

因为我们已经确定了a，b的位置了，所以只有求出**位置在a前的长度为K-2的子字符串有几个**就好了。而由题目可知，前长度为K-2的子字符串是什么我们是不用管的，只有**知道有几个就好了**。这就让我们想到了组合数学：**C(id[a]-1,K-2)**

已经有一个初步的想法了，但我们要怎么确定a，b的位置呢？

再想想，其实根本就不用管b的位置，因为我们要求的只是方案数，只要保证每个方案a，b的位置有一个不同就好了，所以对于确定的a来说，只要知道后面有几个b就好了，怎么求呢？只要借助前缀和的思想统计一遍即可。

还可以再优化一步，在读入的时候就可以把a在子串的位置记录下来。

AC代码：
```
#include<bits/stdc++.h>
#define maxn 2005
#define ll long long
using namespace std;
const int TT=1e9+7;
int n,sum[maxn][26],Q,k;
ll C[maxn][maxn],ans;
char s[maxn],a,b;
vector <int> A[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void Pre(){
	C[0][0]=1;
	for (int i=1;i<=n;i++){
	C[i][0]=1;
	for (int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%TT;
    }
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for (int i=n;i;i--){
		for (int j=0;j<26;j++) sum[i][j]=sum[i+1][j];
		if (i!=n) sum[i][s[i+1]-'a']++;
		A[s[i]-'a'].push_back(i);
	}
	Pre();
	Q=read();
	while (Q--){
		k=read();scanf("%c%c",&a,&b);ans=0;
		for (int i=0;i<A[a-'a'].size();i++)
			if (A[a-'a'][i]>=k-1) ans=(ans+(sum[A[a-'a'][i]][b-'a']*C[A[a-'a'][i]-1][k-2])%TT)%TT;
	    printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：Accepetd (赞：4)

### 题目大意

给你一个字符串 $S$ 以及 $Q$ 个询问：长度为 $D$ 并以 $a$ 和 $b$ 这两个字符结尾的字符串在 $S$ 中有多少个，答案对 $1000000007$ 取模。

### 大致思路

假设我们已经确定了一对 $a$ 和 $b$ 的位置，那么要组成长度为 $D$ 的字符串还差 $D-2$ 个字符，这 $D-2$ 个字符就在 $a$ 之前。

假设 $a$ 之前有 $n$ 个字符，$D-2=m$，那此时就是在 $n$ 个字符中选 $m$ 个不重复的字符，联系组合数，当前的方案数为：

$$C{_n^m}$$

于是就有了**最初的代码**：

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i=a;i<=b;i++)
#define D(i,a,b) for(int i=a;i>=b;i--)
using namespace std;typedef long long ll;
const int N=2e3+2,mod=1e9+7; 
string s;int q,C[N][N];
void Combination(){
	C[0][0]=1;
	F(i,1,s.size()){
		C[i][0]=1;
		F(j,1,i)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }
}int main(){
	cin>>s>>q;
	Combination();
	F(Q,1,q){
		int D;char x,y;bool cnt=0;ll ans=0,mul=0;
		cin>>D>>x>>y;
		D(ia,s.size()-1,0){
			if(s[ia]==y&&s[ia]!=x)mul++;
			if(s[ia]==x){if(mul!=0)ans=(ans+mul*C[ia][D-2])%mod;}
			if(s[ia]==y&&s[ia]==x)mul++;
		}cout<<ans<<'\n';
	}return 0;
}
```

但递交后发现只有 80 分，最后两个点 TLE 了，原因是此代码的时间复杂度为 $O(Q|S|)$，过于极限。

但~作为蒟蒻的~我显然是不可能优化算法的，所以就有了**卡常之后的代码**：

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(register int i=a;i<=b;i=-~i)
#define D(i,a,b) for(register int i=a;i>=b;i=~-i)
#define ad(k) (k=-~k)
#define sb(k) (k=~-k)
using namespace std;typedef long long ll;
const int N=2e3+2,mod=1e9+7;
string s;int q,C[N][N];
inline void Combination(){
	C[0][0]=1;
	F(i,1,s.size()){
		C[i][0]=1;
		F(j,1,i)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }
}signed main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>s>>q;
	Combination();
	F(Q,1,q){
		int D;char x,y;
		cin>>D>>x>>y;
		int i=-1,j=-1;bool f=0,cnt=0;ll ans=0,mul=0;
		D(ia,s.size()-1,0){
			if(s[ia]==y&&s[ia]!=x)ad(mul);
			if(s[ia]==x){
				i=ia;
				if(mul!=0)ans=(ans+mul*C[i][D-2])%mod;
			}if(s[ia]==y&&s[ia]==x)ad(mul);
		}cout<<ans<<'\n';
	}return 0;
}
```

但是当我们再次递交后，有意思的事情出现了，我们有几率获得 80 分、88 分、92 分或 100 分，TLE 或 AC，此时我们只需要打开 C++98 便可稳定 AC。

---

## 作者：All_Wrong_Answer (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P4958)

## 思路：

先考虑一个暴力做法，即使用前缀和记录每个字符的出现次数，然后查询时枚举 $x$ 的位置并使用用 $y$ 的前缀和求出答案累加，其中要用到的组合数需要 $O(|S|^2)$ 打表处理，在线算的话会 TLE，复杂度显然为 $O(Q|S|)$，但是加上快读快写能神奇地 AC。

考虑优化，注意到 $Q$ 很大但是 $|S|$ 比较小，考虑 $O(|S|^2)$ 预处理答案 $O(1)$ 查询，先离线，然后在前缀和的时候直接处理答案，最后 $O(1)$ 回答即可。

[AC 记录](https://www.luogu.com.cn/record/224944511)

---

## 作者：thlog5 (赞：2)

## 题目大意
给定一个字符串 $S$，有 $Q$ 次询问，找出长度为 $D$ 结尾为 $XY$ 的字串个数。

## 思路
考虑枚举 $X$ 出现的位置 $i$。对于每个 $i$，前面保留 $D-2$ 个数即可，因为顺序不能改变，所以相当于 $C^{D-2}_{i-1}$；后面任意选择一个 $Y$ 即可。

根据乘法原理，答案即为 $C^{D-2}_{i-1} \times sum[Y][i]$，其中 $sum[Y][i]$ 表示字符 $Y$ 在 $S$ 中下标 $i$ 之后出现的次数。

采用前缀/后缀和快速得出 $sum[Y][i]$。

组合数可以使用递推计算。

## 代码（基础版）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define int LL
#define For(i,t,n) for(int i=t;i<=n;++i)
#define For_(i,t,n) for(int i=t;i>=n;--i)
const int MAXN=2005;
const int MOD=1e9+7;

string s,c;
int q,d,n;

int sum[27][MAXN]; //字母出现次数(这里用了前缀和，可以用后缀和代替)
int C[MAXN][MAXN]; //组合数

void init(){
    n=s.size();
    //打一个前缀和
    For(i,1,26){
        For(j,1,n){
            sum[i][j]=sum[i][j-1]+((s[j]-'a'+1==i)&1);
        }
    }
    //求组合数
    C[0][0]=1;
    For(i,1,n){
        C[i][0]=1;
        For(j,1,n)
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD; //记得取模
    }
}

void query(){//查询
    int ans=0;
    For(i,d-2,n-1){//枚举X的位置，从d-2开始，保证前面长度足够
        if(s[i]==c[0]){
            ans=(ans+C[i-1][d-2]*(sum[c[1]-'a'+1][n]-sum[c[1]-'a'+1][i]))%MOD;
        }
    }
    cout<<ans<<'\n';
}

void solve(){
    cin>>s>>q;
    s=" "+s;
    init();
    while(q--){
        cin>>d>>c;
        query();
    }
}

signed main(){
    ios::sync_with_stdio(0);//关闭同步流
    cin.tie(0);cout.tie(0);
	solve();
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/224931874)

时间复杂度 $O(|S|^2+|S|Q)$，有点玄学但是能过，基本能 1s 以内。

## 分析
这个复杂度实际上还不够，$O(|S|Q)$ 是可以达到 $10^9$ 的，但是由于 $D$ 的限制，每次并不会跑满 $O(|S|)$。~~而且测评机发力了跑得飞快~~

优化：把所有答案预先打表，$O(1)$ 单次查询。
具体来说可以枚举 $X$ 的位置 $i$，长度 $D$ 和字符 $Y$。式子和原来是差不多的：
记 $q[D][X][Y]$ 为满足题意的字串个数，则每次循环
$$
q[D][S_i][Y]\ +=\ (C[i-1][D-2]*sum[j][i+1])
$$

[优化后记录](https://www.luogu.com.cn/record/225027770)

最慢的点只跑了414ms，时间复杂度 $O(|S|^2+Q)$。

---
$$---\ The\ end\ ---$$

---

## 作者：Lacuna (赞：2)

今天的模拟赛 T1。

### 思路：

首先我们可以先看 $XY$ 的方案数，先找到 $X$，再从这个位置出发找 $Y$。这样显然会超时。

考虑用后缀和预处理该位置后面的 $Y$ 的个数，这样可以做到线性。每次查询 $O(1)$。

前面直接组合数算取 $D - 2$ 个字符的方案数，乘以后面 $XY$ 的方案数即为答案。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define gc getchar
#define pc putchar
#define pb push_back
#define ls u<<1
#define rs u<<1|1
const int ri=500005,P=1e9+7;
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
string s,xy;
LL Q,d,cnt;
LL f[ri],g[ri],suf[ri];
LL qsm(LL a,LL b){
    LL res=1;
    for(;b;a=a*a%P,b>>=1) if(b&1)res=res*a%P;
    return res%P;
}
LL C(LL n,LL m){
    return f[n]*g[m]%P*g[n-m]%P;
}
int main(){
	cin>>s>>Q;
	f[0]=g[0]=1;
    for(LL i=1;i<2000;i++){
        f[i]=f[i-1]*i%P;
        g[i]=qsm(f[i],P-2)%P;
    }
	while(Q--){
		cin>>d>>xy;
		suf[s.size()]=0;
		for(int i=s.size()-2;i>=d-2;i--){
			suf[i]=suf[i+1]+(s[i+1]==xy[1]);
			//cout<<i<<endl;
		}
		for(int i=d-2;i<s.size()-1;i++){
			if(s[i]==xy[0]){
				LL pre=C(i,d-2)%P;
				//cout<<"C "<<i-1<<" "<<d-2<<":"<<pre<<endl;
				cnt=(cnt+pre*suf[i])%P;
			}
		}
		printf("%lld\n",cnt%P);
		cnt=0;
	}
	return 0;
}
```

---

## 作者：Liquefyx (赞：2)

# 题目描述
虽然题目很长，且全是英文，但是，题目还是很简单的：

给你一个字符串 $S$ 和 $Q$ 个询问：长度为 $D$ 并以 $a$ 和 $b$ 这两个字符结尾的字符串在 $S$ 中有多少个。
### 注：答案要模 1000000007
# 题目分析
从样例说明可以轻松发现，这个长度为 $D$ 的子串是在原字符串 $S$ 中随便取出 $D$ 个字符再按原编号顺序排序的。子串不是连着的，那就只有暴力计算，毕竟暴力在字符串 $S$ 上面搜 $a$ 和 $b$ 这两个字符肯定会超时。

那该怎么做？我们可以看到，只要找到 $a$ 和 $b$ 这两个字符后便可以确定一个字符串的位置，还差的 $D-2$ 个字符只需要在 $a$ 之前枚举就行了，假设 $a$ 前面有 $n$ 个字符，令 $m = D-2$ 表示还要枚举的字符，那么我们就是在 $n$ 里面选 $m$ 个不重复的字符，很容易便能想到小学奥数学的组合数：
$$
C_n^m = \frac{n!}{m!(n-m)!}
$$
因为算的时候会有模和乘，我们便能考虑到求逆元这个方法。

另外要注意的是，在找到 $a$ 字符后，$b$ 可以任意出现在 $a$ 的位置后面，我们可以求一个后缀和，保存每个字符后每个字符有多少个就行，这时候就只需要枚举 $a$ 的位置了。

但是，总不可能我们要每询问一次便计算一次吧 ~~（而且这样肯定要炸）~~，我们就可以提前枚举会出现的 $a$ 和 $b$ 的询问的答案，然后我们再枚举一个 $D$ 便行了，最后将 $a$ 和 $b$ 两个字符组成的字符串哈希在一起，便于储存答案。

范围如下：

$$
2 \le D \le \lvert S \rvert \le 2000,1 \le Q \le 500000
$$

# 代码实现

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define LL long long

const int MAXN = 2e3+5;
const int MOD = 1e9+7;
int fac[MAXN],inv[MAXN],inc[MAXN];
char ch[MAXN];
int Suf[MAXN][26];
int ans[MAXN][26 * 26];

int C(int i,int j){
	return (LL)fac[i]*inc[j]%MOD*inc[i-j]%MOD;//求组合数
}

inline void upd(int &x,int y){
	x += y;
	if(x >= MOD) x -= MOD;
}

int main(){
	scanf("%s",ch + 1);
	int L = strlen(ch + 1) ;
	fac[0] = inc[0] = 1;
	inv[1] = fac[1] = inc[1] = 1;
	for(int i = 2 ; i  <= L ; ++i){
		inv[i] = (LL)(MOD-MOD/i)*inv[MOD%i]%MOD;//逆元公式,求每个数字的逆元 
		inc[i] = (LL)inc[i-1]*inv[i]%MOD;//逆元的阶乘 
		fac[i] = (LL)fac[i-1]*i%MOD;//阶乘 
	}
	
	for(int i = L ; i > 0 ; --i){//求后缀和 
		Suf[i][ch[i]-'a'] =  1;
		for(int j = 0 ; j < 26 ;  ++j)
			Suf[i][j] += Suf[i+1][j];
	}
	
	for(int i = 1 ; i <= L ; ++i){//枚举询问的字符a 
		int x = (ch[i] - 'a') * 26;
		int* P = Suf[i+1];//建立P指针 
		for(int l = 0 ; l < i ; ++l)//枚举字符串长度D 
			for(int j = 0 ; j < 26 ; ++j)//枚举询问的第二个字符
				upd(ans[l + 2/*询问的长度D*/][x + j/*哈希*/] , (LL)C(i-1,l)/*求前面方案数*/*P[j]/*字符b在后面有多少个*/%MOD);
	}
	
	int Q,D; char tmp_str[10];
	scanf("%d",&Q);
	while(Q--){
		scanf("%d%s",&D,tmp_str);
		int tmp = (tmp_str[0]-'a')*26 + tmp_str[1] - 'a'/*哈希*/;
		printf("%d\n",ans[D][tmp]);//输出 
	}
	return 0;
}
```

然后这道题目就轻轻松松做完啦 LOuO。

---

## 作者：TJB_LHY (赞：1)

### 题目大意

给定一个字符串 $s$，长度为 $n$，进行 $q$ 次访问。每次访问给定子串长度 $d$ 和要求的后缀 $x$。求满足访问的子串个数，答案对 $1e9+7$ 取模。

# 思路

1\. 暴力枚举：直接 dfs，先选定子串，在判断是否满足。满足则方案加一。时间复杂度：$O(q2^{n})$，包炸的。得分：16pts ~~（数据有点水）~~

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
string s,e;
int q,x,cnt;
void dfs(int id,string y,int st,int len){//暴力
    if(y.size()==2){
        if(y[1]==e[1] && len==x){
            cnt++;//记录方案
            cnt%=1000000007;//象征性取模
        }
        return;
    }
    if(len>=x)return;
    if(y.size())if(y[0]!=e[0])return;
    if(id==s.size())return;
    if(st==0)dfs(id+1,y+s[id],id,len+1);
    else dfs(id+1,y+s[id],st,len+1);
    dfs(id+1,y,st,len);
    if(!y.size())dfs(id+1,y,st,len+1);//暴力选择
}
int main() {
    cin>>s>>q;
    s=' '+s;
    while(q--){
        cin>>x>>e;//输入
        cnt=0;
        dfs(1,"",0,0);
        cout<<cnt<<'\n';//输出
    }
	return 0;
}
```

2\. 组合数优化：枚举末尾的两个字母，出现正确后缀时记录方案，由于需要将子串补足长度 $d$，所以要在 $1$ 到 $i-1$ 之间选出 $d-2$ 个数（$i$ 为所选后缀的第一个字符所在的位置），即 $C^{i-1}_{d-2}$。预处理然后求和即可。时间复杂度：$O(qn^2)$。得分：80pts。（卡常可至 92pts，~~数据真的水~~）

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
string s,e;
ll q,x,n,C[2005][2005],i,j,ans;
const ll mod=1e9+7;
ll get(int st,int len){
    return C[st][len-1];//这里的下标需要特别注意，字符串下标本身从零开始
    //可以自己打表找下标，作者也在这里卡了很久
}
int main() {
    cin>>s>>q;
    n=s.size();
    C[0][0]=1;
    for(i=1;i<=n;i++){
        for(j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }//预处理组合数
    s=' '+s;
    while(q--){
        cin>>x>>e;
        ans=0;
        for(i=(x-1);i<=n;i++){
            if(s[i]==e[0]){
                for(j=i+1;j<=n;j++){
                    if(s[j]==e[1]){
                        ans=(get(i,x)+ans)%mod;//累计
                    }
                }
            }
        }
        cout<<ans<<'\n';//输出
    }
	return 0;
}
```

3\. 注意到累加时答案与最末端的下标无关，我们尝试去掉这层循环。我们可以设 $sum_{i,j}$ 表示第 $i$ 位后，ASCII 码为 $j$ 的字符个数。计算时只需要找到匹配的后缀的第一个字符所在的位置 $i$，累加 $C^{i-1}_{d-2}\times sum_{i,k}$ 即可（$k$ 为后缀的第二个字符的 ASCII 码）。总时间复杂度：$O(qn+n^2)$。得分：100pts。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
string s,e;
ll q,x,n,C[2005][2005],i,j,ans,sum[2005][33];
const ll mod=1e9+7;
ll get(int st,int len){
    return C[st][len-1];//这里的下标需要特别注意，字符串下标本身从零开始
}
int main() {
    cin>>s>>q;
    n=s.size();
    C[0][0]=1;
    s=' '+s;
    for(i=1;i<=n;i++){
        for(j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;//预处理组合数
        for(j=i+1;j<=n;j++){
            sum[i][s[j]-'a']++;
        }
    }
    while(q--){
        cin>>x>>e;
        ans=0;
        for(i=(x-1);i<=n;i++){
            if(s[i]==e[0]){
                ans=(ans+get(i,x)*sum[i][e[1]-'a']%mod)%mod;
            }
        }
        cout<<ans<<'\n';//输出
    }
	return 0;
}
```

完结撒花！求通过！

---

## 作者：array2022 (赞：1)

### 题目分析

- 题目只要求以 $A,B$ 两个字符结尾，所以我们可以考虑在原字符串中找到 $A,B$ 的位置，再利用组合数学算出总共的方案数。
- 由于 $A,B$ 为结尾的字符，我们可以从后往前搜，记录 $B$ 的后缀和，搜到 $A$ 的时候再计算方案数。记找到的 $A$ 下标为 $i$，**从 $0$ 开始**，那么包括这个 $A$ 的合法的子序列的方案数为 $b_i\times C^{D-2}_i$，$b_i$ 表示字符 $B$ 出现次数的后缀和，最后把所有方案数加起来就行了。时间复杂度 $O(|S|Q)$。当然这个代码只能拿到部分分。（$80$ 分，经过神奇的卡常可以拿满分）

### 代码（非正解）
```cpp
#include<bits/stdc++.h>
#define int long long //不建议模仿
using namespace std;
string s;
int t,l,c[2005][2005],mod=1e9+7; //提示：做题时没有读英文题面，所以此处的 l 表示题面中的 D
char a,b;
signed main(){
	ios::sync_with_stdio(0); 
	cin>>s>>t;
	for (int i=0;i<=2000;i++){ //预处理组合数
		for (int j=0;j<=i;j++){
			if (j==0||j==i) c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}
	while (t--){
		int ans=0,cntb=0;
		cin>>l>>a>>b;
		for (int i=s.size()-1;i>=0;i--){
			if (s[i]==a&&i>=l-2){ //注意此处的条件
				ans=(ans+c[i][l-2]*cntb)%mod; 
			}
			if (s[i]==b) cntb++; //计算出现次数的后缀和
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```
------
### 玄学优化

- 预处理各个字符出现次数的后缀和，时间复杂度仍为 $O(|S|Q)$，加上输入输出优化后惊险地通过了。

### 代码（非正解）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char s[2005];
int t,l,c[2005][2005],d[2005][128],mod=1e9+7,len;
//后缀和数组第二维开 128 方便修改与查询
char a,b;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0); //去掉后会超时
	cin>>s>>t; len=strlen(s);
	for (int i=0;i<=len;i++){
		for (int j=0;j<=i;j++){
			if (j==0||j==i) c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}
	for (int i=len-1;i>=0;i--){ //预处理出现次数后缀和
		for (int j='a';j<='z';j++){
			if (j==s[i]) d[i][j]=d[i+1][j]+1;
			else d[i][j]=d[i+1][j];
		}
	}
	while (t--){
		int ans=0,cntb=0;
		cin>>l>>a>>b;
		for (int i=len-1;i>=0;i--){
			if (s[i]==a&&i>=l-2){
				ans=(ans+c[i][l-2]*d[i+1][b])%mod; 
			}
		}
		cout<<ans%mod<<"\n";
	}
	return 0;
}
```
------
### 进一步优化
- 我们可以发现在预处理的时候我们就可以把所有的答案都算出来，之后 $Q$ 次询问 $O(1)$ 查询即可。预处理时间复杂度 $O(|S|^2)$。这样在 $1\mathrm{s}$ 时限内也可以通过。[提交记录。](https://www.luogu.com.cn/record/180627203)

### 通过代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char s[2005];
int t,l,c[2005][2005],d[2005][128],ans[2005][26][26],mod=1e9+7,len;
char a,b;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>s>>t; len=strlen(s);
	for (int i=0;i<=len;i++){
		for (int j=0;j<=i;j++){
			if (j==0||j==i) c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
		}
	}
	for (int i=len-1;i>=0;i--){
		for (int j='a';j<='z';j++){ //处理出现次数后缀和
			if (j==s[i]) d[i][j]=d[i+1][j]+1;
			else d[i][j]=d[i+1][j];
		}
		for (int l=2;l<=i+2;l++){ //处理所有的答案
			for (int j='a';j<='z';j++){
				ans[l][s[i]-'a'][j-'a']+=c[i][l-2]*d[i+1][j]%mod;
				ans[l][s[i]-'a'][j-'a']%=mod;
			}
		}
	}
	while (t--){
		cin>>l>>a>>b;
		cout<<ans[l][a-'a'][b-'a']<<"\n";
	}
	return 0;
}
```

---

## 作者：fzitb7912 (赞：1)

## 分析

考虑 DP。

先考虑 $A$ 的答案。定义状态函数 $f_{i,j}$ 表示在子串 $S_{1 \dots i}$ 中选 $j$ 个，且第 $S_i$ 必选的方案数。则有：$f_{i,j}=C_{i-1}^{j-1}$。

再考虑 $B$ 的答案。枚举每一个位置 $x$。令 $sum_x=\sum\limits_{i=1}^{x-1}f_{i,n-1}[S_i=A]$。则答案为：$\sum\limits_{x=1}^{|S|}sum_x[S_x=B]$。复杂度 $O(Q|S|+|S|^2)$。

优化对 $B$ 的答案的求法，考虑预处理。定义状态函数 $g_{i,j}$ 在位置 $x$ 时表示 $\sum\limits_{k=1}^{x}f_{k,j}[S_k=i]$（和上面的 $sum_x$ 差不多）；定义状态函数 $w_{i,j,k}$ 在位置 $x$ 时表示当前对于 $B=i,A=j,n=k$ 时的答案。则最终答案为：$w_{B,A,n}$。转移就很暴力了，因为定义的原因，在可能出现 $A=B$ 的情况下先转移 $w$，即有：$w_{i,j,k}=w_{i,j,k}+g_{j,k-1}$。对于 $g$ 的转移，有：$g_{i,j}=g_{i,j}+f_{m_i,j}$（其中 $m_i$ 表示当前下标）。$i$ 枚举时已知，只需要另外枚举 $j,k$ 就行了。复杂度 $O(Q+a|S|^2)$，有 $a=26$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define PII pair<int,int>
#define x first
#define y second

il int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}

const int N=2005,M=30,p=1e9+7;
char s[N];int len;
int f[N][N],g[N][N];
int sum[M][M][N];
int c[N][N];
int q;
char t[N];

il int C(int x,int y){
	if(!y||x==y) return 1;
	if(~c[x][y]) return c[x][y];
	return c[x][y]=(C(x-1,y)+C(x-1,y-1))%p;
}
il void solve(){
	memset(c,-1,sizeof(c));
	scanf("%s",s+1),len=strlen(s+1);
	for(re int lon=1;lon<=len;++lon)
	for(re int i=lon;i<=len;++i)
		f[i][lon]=C(i-1,lon-1);
	for(re int i=1;i<=len;++i){
		for(re int n=1;n<=i;++n)
		for(re int j=0;j<26;++j) sum[s[i]-'a'][j][n]=(sum[s[i]-'a'][j][n]+g[j][n-1])%p;
		for(re int n=1;n<=i;++n) g[s[i]-'a'][n]=(g[s[i]-'a'][n]+f[i][n])%p;
	}
	q=read();
	while(q--){
		int n=read();
		scanf("%s",t+1);
		printf("%lld\n",sum[t[2]-'a'][t[1]-'a'][n]);
	}
	return ;
}

signed main(){
	solve();
	return 0;
}
```

优化一下长这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline

il int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}

const int N=2001,M=27,p=1e9+7;
char s[N],t[2];
long long g[N][N],f[M][M][N];
long long c[N][N];
int q,len,n;

signed main(){
	scanf("%s",s+1),len=strlen(s+1);
	for(re int i=0;i<=len;++i)
    for(re int j=0;j<=i;++j)
        if(!j) c[i][j]=1;
        else c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
	for(re int i=1;i<=len;++i)
	for(re int n=i;n>=1;--n){
		for(re int j=0;j<26;++j) f[s[i]-'a'][j][n]=(f[s[i]-'a'][j][n]+g[j][n-1])%p;
		g[s[i]-'a'][n]=(g[s[i]-'a'][n]+c[i-1][n-1])%p;
	}
	q=read();
	while(q--) n=read(),scanf("%s",t),printf("%lld\n",f[t[1]-'a'][t[0]-'a'][n]);
	return 0;
}
```


注：其实 $f_{i,j}$ 可以直接用 $C_{i-1}^{j-1}$ 代替。

---

## 作者：SnapYust (赞：0)

# 题目传送门

[P4958 [COCI2017-2018#6] Mate](https://www.luogu.com.cn/problem/P4958)

# 思路

简单计数题。

最近集训的时候被组合计数搞疯了，所以做一道计数水题。

这道题还是比较套路的吧，实际上，只要像这种在区间上做的计数**大概率**都有这样的一种套路。

自然的，我们知道对于一个点 $i$，假设我们要求的是 $N,A,B$，设答案为 $f(N,A,B)$，其中 $A,B$ 为字符，$S$ 为原字符串，下标从 $0$ 开始，$m(i,K)$ 为每个 $i$ 前（不包括 $i$）任选 $K$ 个元素的组合方案数，则：

$$f(N,A,B)=\sum_{i=0}^{\text{len}(S)-1}({[S_i=A]}\times{(\sum_{j=i+1}^{\text{len}(S)-1}{[S_j=B]})\times m(i,N-2)})$$

值得说明的是，$[]$ 符号在这个式子中**不是**中括号的意思，而是一种返回值为 `bool` 类型的运算，具体地：

$$[q]=\begin{cases}q=\text{true}\to1\\q=\text{false}\to0\end{cases}$$

我们先研究上式，这是次简单的暴力（最简单的暴力是暴力枚举，总时间复杂度 $O(Q\text{len}(S)^2)$），上式枚举了 $S$ 的长两次，所以时间复杂度还是 $O(Q\text{len}(S)^2)$。但为什么要这样想呢因为我们这样就把纯暴力的思路转化为了带组合方案的算法，也就可以说走上了**正解**的轨道。

接下来我们的工作就是能预处理出上式的一些部分。

不难想到，我们设 $t_{i,j}$，其中 $j$ 为字符的编号，$a=1,b=2...z=26$，$t_{i,j}$ 为第 $i$ 个字符及其后面的所有下标不超过字符串长的编号 $j$ 字符的计数。

这东西依然可以套路地维护，从后往前枚举，设当前枚举下标为 $i$，有：

$$t_{i,j}=t_{i+1,j}+[S_i=\text{char}(j)]$$

其中 $\text{char}(j)$ 即为将 $j$ 转为以 $j$ 编号的字符串。即 $\text{char}(1)=a...\text{char}(26)=z$。

这个东西可以在询问之前 $O(\text{len}(S))$ 预处理。

那这样我们上式就可以更新为：

$$f(N,A,B)=\sum_{i=0}^{\text{len}(S)-1}({[S_i=A]}\times{t_{i,\text{num}(B)}\times m(i,N-2)})$$

其中 $\text{num}(B)$ 表示将字符 $B$ 转化为其编号。

现在还剩下一个 $m(i,N-2)$ 比较棘手。但实际上，**机智** OIer 已经发现了：对于前面的组合，并且需要考虑**顺序不能改变**，$m(i,N-2)=C_{i}^{N-2}$，根据组合的知识，这样我们就有：

$$C_{0}^{\forall i|i\ge0}=1$$

$$C_{\forall j|j>0}^{\forall i|i>0}=C_{j}{i-1}+C_{j-1}{i-1}$$

这是处理组合数最常用的方法。

这个东西可以在询问之前 $O(\text{len}(S)^2)$ 预处理。

这样，上式就更新为：

$$f(N,A,B)=\sum_{i=0}^{\text{len}(S)-1}({[S_i=A]}\times{t_{i,\text{num}(B)}\times C_{i}^{N-2}})$$

但这样还是过不了题，因为总复杂度是 $O(\text{len}(S)+\text{len}(S)^2+Q\text{len}(S))$，会 `T` 飞。

我们发现，在每次询问都要跑一遍 $O(N)$，而我们只需要关注 $S_i=A$ 的情况，所以我们依然可以预处理：设 $P_{i}$ 为一个字符编号为 $i$ 的字符位置的数列，则：

枚举 $i|0\le i<\text{len}(S)$，数列 $P_{\text{num}(S_i)}$ 都插入一个 $i$ 作为一个位置。

这个东西依然可以在询问之前 $O(\text{len}(S))$ 预处理。

这样，上式就更新为：

$$f(N,A,B)=\sum_{i=1}^{\text{size}(P_{\text{num}(A)})}({t_{P_{\text{num}(A),i},\text{num}(B)}\times C_{P_{\text{num}(A),i}}^{N-2}})$$

其中 $\text{size}(P_{\text{num}(A)})$ 为 $P_{\text{num}{A}}$ 的长度，下标从 $1$ 开始。

这时的总复杂度优化为 $O(\text{len}(S)+\text{len}(S)^2+Q\text{size}(P_{\text{num}(A_{x(1\le x\le Q)})}))$，可以通过本题。

如果想要再优化，可以用一点记忆化，建立一个 $f(N,A,B)$ 的映射，只要映射里面有答案值，就直接 $O(1)$ 输出答案，否则再按正常处理，然后将 $f(N,A,B)$ 的值存到映射里，等下一次 $O(1)$ 调用即可。

# Code

代码挺短的，懂思路后也很好实现，就不放了。

---

## 作者：2021changqing52 (赞：0)

# 思路：
- 思路来自题解。
- 题目大意：给定一个字符串 $S$，还有 $Q$ 次询问，每次询问给出一个正整数 $K$ 和两个字符 $a$，$b$。
- 对于每次询问回答：在字符串 $S$ 中，有多少个长度为 $K$ 的子字符串**倒数第二的字符为 $a$，倒数第一个字符为 $b$。**
- 对此，我们可以找到每个 $a$ 出现的位置，再将这些位置后 $b$ 的个数和在这个位置前面选 $K-2$ 个字符的方案数相乘，再将这些积相加（小学奥数的乘法原理和加法原理）。
- 具体做的时候，预处理好组合数和字符串中任意位置之后字符出现的次数，以及每个字符出现的次数，这样询问时不用重新去找 $a$ 和 $b$，直接用这些数据即可（小小的优化）。
# AC Code:
```cpp
#include<bits/stdc++.h>
#define maxn 2005
#define ll long long
#define mod (1e9+7)//模数 
using namespace std;
int n,sum[maxn][26],q,k;//sum:字符串中任意位置之后字符出现的次数
ll C[maxn][maxn],ans;//C:组合数 
char s[maxn],a,b;
vector<int>f[maxn];
inline int read(){//快读 
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void call(){//递推求组合数 
	C[0][0]=1;
	for (int i=1;i<=n;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }
}
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=n;i;i--){
		for(int j=0;j<26;j++)sum[i][j]=sum[i+1][j];
		if(i!=n)sum[i][s[i+1]-'a']++;//统计每个字母的次数 
		f[s[i]-'a'].push_back(i);//i是s[i]字母所在的位置 
	}
	call();q=read();
	while(q--){
		k=read();scanf("%c%c",&a,&b);ans=0;
		for(int i=0;i<f[a-'a'].size();i++)
		if(f[a-'a'][i]>=k-1)ans=(ans+sum[f[a-'a'][i]][b-'a']*C[f[a-'a'][i]-1][k-2]%mod)%mod;
	    printf("%lld\n",ans);//b出现的次数乘上组合数 
	}
	return 0;
}
```

---

## 作者：WIGYF (赞：0)

### 题目要求

给出一个字符串 $S$ 与 $Q$ 个提问，每个提问中包含一个数字 $k$ 与两个字母 $X Y$ ，求$S$中有多少个长度为 $k$ 且以 $X Y$ 结尾的字符串。

------------
### 思路
如果已知每个 $X$ 的位置，那么就这个 $X$ 可以构成的字符串数量便是由 $X$ 后面 $Y$ 的数量与 $X$ 前面所有字符串决定。

**为什么呢？**

首先，对于当前 $X$ 前面所有字符，需要考虑的是如何让它们组成需要字符串剩下的部分，由题**所求字符串只需要满足最后两个字符为 $XY$**，那么对剩余 $k-2$ 的长度的字符没有更多要求，用当前X前的字符将其构成，因为顺序无法改变，所以这就是一个很明显的组合  $C^{k-2}_{i-1}$   ( $i$ 为 $X$ 在字符串 $S$ 中的位置)，我们可以用一个朴素的杨辉三角求组合解决。
```cpp
void hanshu()
{
	C[0][0]=1;
	for(int i=1; i<=n; i++)
	{
		C[i][0]=1;
		for(int j=1; j<=i; j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%yu;
	}
}
```


而对于当前 $X$ 后面，因为必须为字符 $Y$，所以只与当前 $X$ 后面 $Y$ 的数量有关，对此只需一个简单的前缀和便可实现。
```
for(int i=n; i; i--)
	{
		for(int j=0; j<26; j++) sum[i][j]=sum[i+1][j];
		if(i!=n) sum[i][s[i+1]-'a']++;
		A[s[i]-'a'].push_back(i);
	}
```

在得出前两个结论后，显而易见，当前 $X$ 可以构造的需求字符串数量即为前面的组合数乘上后面的 $Y$ 的数量，最后的答案就是每个 $X$ 可以构造的字符串之和。

最后奉上代码
```
#include<bits/stdc++.h>
using namespace std;
const int yu=1e9+7;
long long n,sum[2005][26],Q,k,C[2005][2005],ans;
char s[2005],a,b;
vector<int> A[2005];
void hanshu()
{
	C[0][0]=1;
	for(int i=1; i<=n; i++)
	{
		C[i][0]=1;
		for(int j=1; j<=i; j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%yu;
	}
}
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=n; i; i--)
	{
		for(int j=0; j<26; j++) sum[i][j]=sum[i+1][j];
		if(i!=n) sum[i][s[i+1]-'a']++;
		A[s[i]-'a'].push_back(i);
	}
	hanshu();
	cin>>Q;
	while (Q--)
	{
		cin>>k>>a>>b;
		ans=0;
		for(int i=0; i<A[a-'a'].size(); i++)
			if(A[a-'a'][i]>=k-1) ans=(ans+(sum[A[a-'a'][i]][b-'a']*C[A[a-'a'][i]-1][k-2])%yu)%yu;
		cout<<ans<<endl;
	}
	return 0;
}
```

**如有不足，欢迎指正**

---


# 红包发红包

## 题目背景

红包（redbag）发明了一个抢红包的系统。

## 题目描述

这个抢红包系统是这样的：假如现在有 $w$ 元，那么你抢红包能抢到的钱就是 $[0,w]$ 等概率均匀随机出的一个实数 $x$。

现在红包发了一个 $w$ 元的红包，有 $n$ 个人来抢。那么请问第 $k$ 个人期望抢到多少钱？

输出答案对 $10^9+7$ 取模后的结果。


## 说明/提示

注意红包发明的抢红包系统和微信的抢红包系统不一样，红包发明的抢红包系统中的钱不一定是整数分。

- 对于 $30\%$ 的数据，$k=1$
- 另有 $30\%$ 的数据，期望值取模前为整数，$k\le 10$。

对于全部数据，$0< w< (10^9+7)$，$n\le 10^{18},k\le n$。

## 样例 #1

### 输入

```
2 1 1```

### 输出

```
1```

# 题解

## 作者：老K (赞：65)

yyf神仙讲了离散性随机变量的期望，实际上这道题是连续性随机变量。

连续性随机变量的期望为$\int_{-\infty}^\infty xf(x)\textrm{d}x$，其中$f(x)$为$x$取值的密度分布函数，满足$\int_{-\infty}^{\infty}f(x)\textrm{d}x=1$。

那么总金额$w$对应的分布函数就是：

$$f(x)=\begin{cases}\frac{1}{w} & 0\le x\le w\\ 0 & x<0\space or\space x>w\end{cases}$$


实际上$n$是没用的，因为$n$个人来抢并不是$n$个人会抢完。

其实看了样例猜到期望抢到一半，每次就都是/2就可以A掉这题了（逃）


然而严谨的证明第$k$个人期望抢到$\frac{w}{2^k}$：

首先$k=1$期望抢到$\int_0^w\frac{x\textrm{d}x}{w}=\frac{w}{2}$。

接下来假如已知$k=n-1$时成立，则第$k$个人期望抢到$\int_0^w\frac{\frac{x}{2^{n-1}}\textrm{d}x}{w}=\frac{w}{2^{n}}$，说明$k=n$同样成立。

（$x$指的是第一个人抢到的钱数）







---

## 作者：Anguei (赞：40)

首先看题：

> 抢红包能抢到的钱就是 $[0,w]$ 等概率均匀随机出的一个数 $x$。请问第 $k$ 个人期望抢到多少钱？

题目中涉及一个概念叫期望。如果您不知道什么是期望，请阅读这段文字。设一个离散型随机变量 $x$ 所有可能的取值分别为 $x_1,x_2,x_3,...,x_n$，这些值得对应概率是 $p_1,p_2,p_3,...,p_n$，则 $E(x)=x_1p_1+x_2p_2+...+x_np_n$ 叫做这个**离散型随机变量 $x$ 的均值**或**数学期望**（简称**期望**）。（摘自人教版数学课本）

通俗的讲，第 $k$ 个人期望获得的钱就是所有这个人可能获得的钱的平均值。所以：

1. 第 $1$ 个人领红包之前，剩余金额 $w$，期望领到的红包为 $\Large\frac{w}{2}$。
2. 第 $2$ 个人领红包之前，剩余金额 $\Large\frac{w}{2}$，期望领到的红包为 $\Large\frac{w}{4}$。
3. 第 $3$ 个人领红包之前，剩余金额 $\Large\frac{w}{4}$，期望领到的红包为 $\Large\frac{w}{8}$。
4. 第 $4$ 个人领红包之前，剩余金额 $\Large\frac{w}{8}$，期望领到的红包为 $\Large\frac{w}{16}$。
5. ……

所以，第 $k$ 个人期望领到的红包为 $\Large\frac{w}{2^k}$。由于需要对 $p=10^9+7$ 取模，所以答案转化为求 $w$ 与 $2^k$ 在模 $p$ 意义下的逆元的乘积。

逆元可以用快速幂求。

```cpp
const int p = 1e9 + 7.5;

int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) (res *= a) %= p;
        (a *= a) %= p;
        b >>= 1;
    }
    return res % p;
}

int main() {
    int w = read(), n = read(), k = read();
    println(w * qpow(qpow(2, k), p - 2) % p);
}
```


---

## 作者：Ebola (赞：15)

发现题解里都是直接说第一个人期望$\frac{w}{2}$，都没有推导过程以及数学解释的……我就来给个推导过程

设随机变量$X$表示第一个人拿到的钱。则$X$的分布函数$F(x)=P(X<x)=\frac{x}{w}(0\leq x \leq w)$

对分布函数求导，得到密度函数：$f(x)=\frac{1}{w}$

则根据连续型随机变量期望的定义，有：$E=\int_0^wf(x)x \;\operatorname{dx}$。求得$E_1=\frac{w}{2}$

对于第二个人，只需将上述推导过程中的$w$替换成$E_1$即可

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int ha=1e9+7;
LL w,n,k;

LL Pow(LL a,LL b)
{
    LL ans=1;
    for(;b;b>>=1,a=a*a%ha)
        if(b&1) ans=ans*a%ha;
    return ans;
}

int main()
{
    cin>>w>>n>>k;
    LL inv2=Pow(2,ha-2);
    LL ans=w*Pow(inv2,k)%ha;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：altgo (赞：13)

绿题杀手，正是在下。

## 题目大意

有一个 $w$ 元的红包，当一个人开红包会等概率得到 $[0,w]$（实数范围）中的钱，求第 $k$ 个人开红包期望得到多少钱。

## 题解

容易猜出答案是 $\frac{w}{2^k}$。

因为在直觉上，每一次期望拿走一半的钱；但是我感觉这个期望是不能叠加的。

所以选择另一种推导。这个推导同时也证明了在某种特定条件下，期望就可以直接叠加。

设 $E_k$ 表示第 $k$ 次之后期望剩多少钱。$f_k(a)$ 表示前 $k-1$ 次抢红包的时候一共抢走 $a$ 元的概率。

那么对于任意 $t$，我们都有：

$$

\int f_t(a)\text{d}a=1

$$

显然 $E_1=w/2$。

并且我们就有：

$$

\int (w-a)f_2(a)\text{da}=E_1\to\int f_2(a)\text{da}=w-E_1

$$

于是 $E_2$ 的各种各个部分都可以算了

$$

E_2=\int \frac{w-a}{2}f_2(a)\text{da}=w/4

$$

同时我们有关系：

$$

\int (w-a)f_3(a)\text{da}=E_2\to \int af_3(a)\text{da}=w-E_2

$$

于是，我们就可以得出 $E_3$ 的关系：

$$

E_3=\int \frac{w-a}{2}f_3(a)\text{da}=\frac{w}{2}-\frac{w-E_2}{2}=w/8

$$

此时，我们就已经可以归纳出所有的 $k$ 了。

$$

E_k=\frac{w}{2^k}

$$

并且

$$

\int af_{k+1}(a)\text{da}=w-E_k

$$

$$

E_{k+1}=\int \frac{w-a}{2}f_{k+1}(a)\text{da}=\frac{w}{2}-\frac{w-\frac{w}{2^k}}{2}=\frac{w}{2^{k+1}}

$$

反正我觉得这题应该是这样做的。

## 扩展

那么，我们考虑更加一般的情况，假设现在有 $w$ 元，并且来一个人取钱，他期望会取 $A(w)$ 元。用 $A$ 替换掉上面的 $\frac{1}{2}$。

下面的关系仍然是成立的：

$$

\int af_{k+1}(a)\text{da}=w-E_k

$$

而 $E$ 的推导就换一下：

$$

E_{k+1}=\int A(w-a)f_{k+1}(a)\text{da}

$$

观察 $a$ 什么时候可以提出来？就是 $A(x)$ 是关于 $x$ 的线性关系！

也就是说我们如果假设 $A(x)=kx+b$，那么我们可以转化上式：

$$

E_{k+1}=\int (kw-ka+b)f_{k+1}(a)\text{da}

$$

$$

E_{k+1}=(kw+b)-k\int af_{k+1}(a)\text{da}=kw+b-k(w-E_k)=kE_k+b

$$

所以，只要 $A$ 是个一次函数，那么 $E_{k+1}=A(E_k)$。

当然肯定有大佬会根据期望的线性性一眼看出来，但对我而言并不那么直观。所以也只是希望能够为和我一样没那么厉害的选手提供一点帮助。

---

## 作者：天梦 (赞：5)

## P5104

[链接](https://www.luogu.com.cn/problem/P5104)

我们先考虑第一次抽红包。

显然，抽的钱数在 $(0,k]$ 之间的概率是 $\frac k w$，再根据概率密度函数是概率分布函数的导数，我们可以求得概率密度函数为：
$$
f(x)=\begin{cases}
\frac 1 w &(0\le x\le w)\\
0&x< 0,x>w
\end{cases}
$$
所以我们积分一下不难得出抽一次的期望：
$$
E_1=\int_{i=0}^w xf(x)=\frac w 2
$$
我们现在考虑抽第二次。这里假设第一次抽取的钱为 $a$ ，那么第二次抽钱期望抽到 $\frac{w-a}2$ 。

那么抽第二次的期望就应该是：
$$
E_2=\int_{i=0}^w \frac{w-a}2f(a)=\frac{w}4
$$
对于第三次，我们可以把前两次的抽取看做一次，具体来说，就设这个概率密度函数为 $g$ ，虽然我们不知道 $g$ 具体是什么，但是我们知道：
$$
E_2=\int _{i=0}^w xg(x)=\frac{w}{4}
$$
 如此下去，可以得到第 $k$ 次抽钱的期望是 $\frac{w}{2^k}$ 。

打一个快速幂就过去了。

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define N number
#define M number
using namespace std;

const int INF=0x3f3f3f3f;
const ll mod=1e9+7;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

inline ll ksm(ll a,ll b,ll mod){
    ll res=1;
    while(b){
        if(b&1) (res*=a)%=mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}

int main(){
    ll w,n,k;read(w);read(n);read(k);
    ll inv=ksm(2,mod-2,mod);
    ll nowinv=ksm(inv,k,mod);
    printf("%lld\n",w*nowinv%mod);
    return 0;
}
```


---

## 作者：Akoasm_X (赞：5)

**本题解经历用通俗的语言和方式讲出自己的故事**

先介绍一下数学期望，就是事件的结果与事件概率的乘积的和

对于这道题来讲，就是对得到钱*得到这个钱的概率

得到钱的范围是[0,w]，**等概率均匀随机出现**

现在我们来推导第一个人的期望会是多少

我们先假设只能取到整数元，概率都是1/(w+1);

此时我们再去看事件的结果是怎样的：0、1、2、3...w

结果的和就是w*(w+1)/2，再乘上概率就得到w/2

第二个人剩下的钱期望值是w/2，在此基础上计算期望值

**~~草率地~~得出结论：ans = w/(2^k)**

分数取模：ans = 分子*分母的逆元（mod p）

逆元求解我参考的是快速幂写法

**下面是代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod = 1e9+7;
LL w,n,k,ans;
LL qu_pow(LL x,LL k)
{
	LL ans = 1;
	LL base = x;
	while(k)
	{
		if(k&1)
			ans = base*ans%mod;
		base = base*base%mod;
		k >>= 1;
	}
	return ans;
}
int main()
{
	scanf("%lld%lld%lld",&w,&n,&k);
	ans = w*qu_pow(qu_pow(2,k),mod-2)%mod;
	printf("%lld\n",ans);
	return 0;
}
```
希望对大家的学习有帮助

---

## 作者：Dita (赞：3)


> **题目大意**
>
> 现在有 $w$ 元， 每次抢的钱是 $[0,w]$ 等概率均匀随机出的一个实数 $x$ 。
>
> 现在有 $w$ 元，有 $n$ 个人来抢。那么请问第 $k$ 个人期望抢到多少钱？
>
> 答案对 $\bmod (10^9+7)$ 取模。
>
> $0<w<(10^ 9 + 7),n \leq 10^{18},k\leq n$

**知识点：期望**

设一个离散型随机变量 $x$ 所有可能的取值分别为 $x_1,x_2,x_3,...,x_n$ 这些值得对应概率是 $p_1,p_2,p_3,...,p_n$ 则 $E(x)=x_1p_1+x_2p_2+...+x_np_n$ 叫做这个离散型随机变量 x 或数学期望（简称期望）-----来自另一篇题解

**solution**

对于第一个人，他期望抢到的钱可以表示成：
$$
\frac{1}{w} \times \sum_{i = 0}^{i = w} i
$$
发现右边是个等差数列求和，继续化简可以得到 $\frac{2}{w}$， 那么第一个人期望抢到 $\frac{w}{2}$ 的钱，期望剩下 $\frac{w}{2}$ 的钱，那么第二个人就期望抢到 $\frac{w}{2^2}$ 的钱，期望剩下 $\frac{w}{2^2}$ ，然后依次类推得到第 $k$ 个人期望抢到 $\frac{w}{2^k}$ 的钱。

注意一下分数取模就好了。

```c++
/*
work by:Ariel_
Sorce:P5104 红包发红包
Knowledge:期望
Time:O(log mod)
*/
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#include <algorithm>
#define int long long
#define rg register
using namespace std;
const int mod = 1e9 + 7;
int read(){
    int x = 0,f = 1; char c = getchar();
    while(c < '0'||c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') {x = x*10 + c - '0'; c = getchar();}
    return x*f;
}
int qpow(int a, int b) {
   int ret = 1;
   while(b) {
     if(b & 1) ret = (ret * a) % mod;
	 b >>= 1;
	 a = (a * a) % mod; 
   }  
   return ret;
}
int inv(int x) {return qpow(x, mod - 2) % mod;}
int w, n, k;
signed main(){
   w = read(), n = read(), k = read();
   printf("%lld", w * inv(qpow(2, k)) % mod);
   puts("");
   return 0;
}
```



 

---

## 作者：Re_Fable (赞：3)

首先读题：

红包发红包，

问第k个人期望抢到的钱数，

~~显然是剩下的全部啦（大雾）~~

---

为了不发生上面的悲惨情景，我们首先需要了解什么是数学期望。

~~显然是数学期望，不然还能是什么~~

### 期望

如果一个随机变量的取值个数有限，或可能的取值可以一一列举出来（本题中的情况），则称它为：

**离散型随机变量**

一个离散型随机变量$X$的**数学期望**是其每个取值乘以该取值对应概率的总和，记作$E(X)$。

$$E(X)=\sum_{a\in I(X)}{\alpha \cdot P(X=\alpha)=\sum_{\omega \in S}{X(\omega)P(\omega)}}$$

其中$I(X)$表示随机变量$X$的值域，$S$表示$X$所在概率空间的样本集合

其中$P(~ ~)$表示事件在当下条件下发生的概率。

因此$E(k)=\frac{\omega}{2^k}$

由于题干要求取模，那么我们再加入乘法逆元进行运算。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long 
using namespace std;
#define p 1000000007
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}//快读
inline int qpow(ll a,int b){
	int ans=1;
	a=(a%p+p)%p;
	for(;b;b>>=1){
		if(b&1) ans=(a*ans)%p;
		a=(a*a)%p;
	}
	return ans%p;
}//逆元
int w,n,k;
signed main(){
	w=read(),n=read(),k=read();
	int ans=w*qpow(qpow(2,k),p-2)%p;
	ans%=p;
	printf("%lld",ans);
	return 0;
}
```
~~我是绝对不会告诉你们我因为没有开long long而恶意提交的~~

---

## 作者：Tsawke (赞：2)

# [LG-P5104 红包发红包](https://www.luogu.com.cn/problem/P5104) Solution

[TOC]

## [更好的阅读体验戳此进入](http://blog.monkey-hyx.tech?t=LG-P5104-Solution)

（建议您从上方链接进入我的个人网站查看此 Blog，在 Luogu 中图片会被墙掉，部分 Markdown 也会失效）



关于本题怎么做题解区的大佬们已经讲的很清楚了，因为这是我的第一道期望题，所以这里仅对积分推导过程做一些较为详细的补充。

显然令第一个人抢到的钱数为 $ x $，那么 $ x $ 的分布函数 $ f(x) $ 较为显然：
$$
f(x) =
\left\{
	\begin{array}{ll}
	\dfrac{1}{\omega} &\quad x \in \left[ 0, \omega \right] \\
	0 &\quad x \in \left( -\infty, 0 \right) \cup \left( \omega, +\infty \right)
	\end{array}
\right.
$$
那么我们要求的期望也就比较显然为：
$$
\int_0^\omega x f(x) dx = \int_o^\omega \dfrac{x}{\omega}dx
$$
这个东西比较显然的就是用牛顿-莱布尼茨公式求解：
$$
\int_a^b f(x) dx = F(b) - F(a) = F(x) \vert_a^b
$$
其中 $ F'(x) = f(x) $，证明略。

带到本题中也就是我们考虑令 $ g(x) = \dfrac{x^2}{2\omega} $，那么显然 $ g'(x) = \dfrac{x}{\omega} $。所以有：
$$
\begin{aligned}
\int_o^\omega \dfrac{x}{\omega}dx
	&= g(\omega) - g(0)\\
    &= \dfrac{\omega^2}{2\omega}\\
    &= \dfrac{\omega}{2}
\end{aligned}
$$
或者也可以考虑从定义出发，显然有如下公式：
$$
\int_a^b f(x) dx = \lim_{n \rightarrow +\infty} \sum_{i = 1}^n \dfrac{b - a}{n}f(x_i)
$$
这个东西本质上就是把曲边梯形分成 $ n $ 份，然后分别当成矩形求解加和，也就是定积分的本质，如果还是不理解可以看一下这个图（预高一的时候老师讲的）。

![Oops! The image is blocked! Please visit my own website to observe the image! 图片被墙了，请通过文章头的跳转链接访问！](http://monkey-hyx.tech/Images/Blog/2022_10_18_1.png)

带入到这题里面，显然 $ x_i = i\dfrac{\omega - 0}{n} + 0 = \dfrac{i \omega}{n} $，于是便有：
$$
\begin{aligned}
\int_o^\omega \dfrac{x}{\omega}dx
	&= \lim_{n \rightarrow +\infty} \sum_{i = 1}^n \dfrac{\omega}{n} \dfrac{i\omega}{n\omega} \\
	&= \lim_{n \rightarrow +\infty} \sum_{i = 1}^n \dfrac{i\omega}{n^2} \\
	&= \lim_{n \rightarrow +\infty} \dfrac{(1 + 2 + \cdots + n)\omega}{n^2} \\
	&= \lim_{n \rightarrow +\infty} \dfrac{1}{2} \dfrac{(n^2 + n)\omega}{n^2} \\
	&= \lim_{n \rightarrow +\infty} \dfrac{\omega}{2} \dfrac{n^2 + n}{n^2} \\
	&= \dfrac{\omega}{2}
\end{aligned}
$$
而对于后面的第 $ k $ 个人，我们进行如下考虑，第一个人期望取走 $ \dfrac{\omega}{2} $，那么他也期望剩下 $ \dfrac{\omega}{2} $，所以第二个人等于是在 $ \dfrac{\omega}{2} $ 的基础上再取，推一下显然就是 $ \dfrac{\omega}{4} $，于是很显然，这样推下去，一定有第 $ k $ 个人的期望为 $ \dfrac{\omega}{2^{k}} $，于是写个快速幂求个逆元取个模就 Accept 了。 

## UPD

update-2022_10_18 初稿



---

## 作者：muller (赞：1)

我们可以在逆元上搞一搞

发现是一个非常简单的通向公式

直接找到了规律

就是w*pw（2，k）的逆元

其实你需要化简一下

就得到如下代码

注意分数取模

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define LL long long 
using namespace std;
const LL mod=1e9+7;
LL qpow(LL x,LL y) {
    LL c=1LL;
    for(; y; y>>=1,x=x*x%mod) 
        if(y&1) c=c*x%mod;
    return c;
}
int main() {
    LL w,n,k;
    scanf("%lld%lld%lld",&w,&n,&k);
    printf("%lld\n",w*qpow(qpow(2,k),mod-2)%mod);
    return 0;
}
```


---

## 作者：Φρανκ (赞：0)

题意：共有 $w$ 元钱，依次从剩余钱数中取走随机数额，求第 $k$ 个人取走钱数期望。

核心思想：期望

解：

设第 $i$ 人取钱数期望为 $f(i)$，取完钱后剩余钱数期望为 $g(i)$，则容易发现有 $f(i)=\frac{g(i-1)}{2}$ 及 $g(i-1)=f(i)+g(i)$，可推出 $2g(i)=g(i-1)$ 及 $2f(i)=f(i-1)$。代入 $g(0)=w$ 可得 $f(i)=\frac{w}{2^i}(i\in\mathbb{Z}^+)$。运用快速幂求算即可。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=1000000007;
const long long inv=500000004;//2关于1000000007的逆元
long long w, n, k, res;
long long qp(long long x)
{
	if(x==0)
		return 1;
	long long t=qp(x/2)%mod;
	if(x%2==0)
		return t*t%mod;
	else
		return t*t%mod*inv%mod;
}//快速幂
int main()
{
	cin>>w>>n>>k;
	res=w*qp(k)%mod;//求算
	cout<<res;//输出
	return 0;
}
```


---


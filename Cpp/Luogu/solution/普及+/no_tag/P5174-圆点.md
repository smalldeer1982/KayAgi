# 圆点

## 题目背景

中考了，Pg看着数学卷子的压轴题，陷入了沉思……

题解：https://blog.csdn.net/kkkksc03/article/details/85008125

## 题目描述

众所周知，平面中的每一个整点都**有且仅有**一个圆心在原点的圆穿过，我们定义这个整点的权值为穿过它的圆的**半径的平方**。

现在有一个圆心在原点的圆，半径为$\sqrt{R}$。你要求出这个圆所包含的所有整点的权值**和**。

由于答案可能过大，对$10^9+7$取模。


## 说明/提示

样例1 解释：

共包含了$9$个整点。分别为$(0,0),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1)$。

权值分别为$\ 0,1,2,1,2,1,2,1,2$，总和为12。

--------
   
对于50%的数据，$R \le 10^{6}.$

对于100%的数据，$R \le 10^{14}.$


## 样例 #1

### 输入

```
3```

### 输出

```
12```

## 样例 #2

### 输入

```
100
```

### 输出

```
16012```

## 样例 #3

### 输入

```
1234567
```

### 输出

```
205275050```

# 题解

## 作者：love_luke (赞：6)

对HAY大佬的题解做一个进一步的解释（我觉得他没说清楚）

首先，这道题的数据还是比较大的，感觉用long long也会爆，先不管，开成long long。然后读入r,半径是根号r，就开个方，存在lin里。

```
    long long r,i,sum=0,lin,a,b;
    scanf("%lld",&r);
    lin=sqrt(r);
```
然后就到了精髓部分。其他题解都用了平方和公式，而我们不需要，使用远古算法，把每个平方的个数都求出来，然后乘起来，最后全部加起来。当然，我们只需要算一个象限加一个半轴的，最后再乘4就行了。

```
    for (i=1;i<=lin;++i)
    {
        a=sqrt(r-i*i);//当横坐标为i时，第一象限内最多有多少个
        a=(2*a+1)%1000000007;//把半轴和纵坐标为i的情况算上
        b=(i*i)%1000000007;//平方
        sum=(sum+a*b)%1000000007;//个数乘平方再累加
    }
    printf("%lld",(sum*4)%1000000007);//输出
```

---

## 作者：mrsrz (赞：5)

## 题目大意：

给定$R$，求所有满足$a,b\in \mathbb{Z}$，且$a^2+b^2\leqslant R$的$a^2+b^2$之和。

## 解题思路：

只考虑$a\geqslant 0,b> 0$的情况，然后乘4就是答案。

我们枚举$a$，则$b$的范围可以计算出来（$b\leqslant\sqrt{R-a^2}$）。

令$p=\lfloor\sqrt{R-a^2}\rfloor$

然后这个$a$对答案的贡献就为$a^2p+\sum_{i=1}^p i^2=a^2p+\frac{p(p+1)(2p+1)}{6}$。

时间复杂度$O(\sqrt R)$。

## Code：
```cpp
#include<cstdio>
#include<cmath>
#define LoveLive long long
#define md 1000000007
LoveLive R;
int ans=0;
int main(){
	scanf("%lld",&R);
	for(int i=0;(LoveLive)i*i<R;++i){
		const int b=(int)(sqrt(R-(LoveLive)i*i)+1e-9);
		ans=(ans+(__int128)i*i*b+(__int128)b*(b+1)*(2*b+1)/6)%md;
	}
	printf("%lld\n",((LoveLive)ans<<2)%md);
	return 0;
}
```

---

## 作者：归山_ (赞：5)

首先这道题蒙了我很长时间

一开始我一看

咦紫的

于是我仔细看了一眼题目

发现还好吧，好像还比较好写，莫名的像奥数题？？？

我看了一眼数据量

我。。。。。。

好吧好吧，我写个正常的解法

------------

我们先考虑

圆是对称图形，我们可以先求出一个坐标系里的所有权值

再乘4就可以了

~~但是好像并没什么用~~

我又思考良久发现

我们可以分开去求坐标系上的点和内的点

但是我们如果一个一个枚举i,j的话会t的飞起

所以我们可以用一个小优化

我们可以只枚举i，并借助r求出j

这样就达到了O(R)的了

但是我们要求的是所有点的平方和

所以我们考虑借助一个数组求出一个点及其之前的所有整数点的平方和

~~是不是很玄学~~

最后我们就会有这样的代码

```
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
#define re register
using namespace std;

const int mod=1e9+7;
const int maxn=1000010;

int r,R,ans;

int sum[maxn];

signed main()
{
	cin>>r;
	R=(int)sqrt(r);
	for(re int i=1;i<=R;++i) sum[i]=(sum[i-1]%mod+i*i%mod+10*mod)%mod;
	for(re int i=1;i<=R;++i){
		int j=(int)sqrt(r-i*i);
		ans=(ans%mod+j%mod*i%mod*i%mod+sum[j]%mod+10*mod)%mod;
	}
	ans=4*ans%mod;
	ans=(ans+mod)%mod;
	ans=(ans%mod+4*sum[R]%mod+10*mod)%mod;
	ans%=mod;
	cout<<(ans+10*mod)%mod;
	return 0;
}
```
我们交上去后会开开心心的收获80分

正当我疑惑的时候

我看到了MLE？？？？？？？

我再一看内存限制

王德发这不是专门卡我吗。。。

好吧我换写法

然后我发现我不会其他方法。。。

于是我开始冥思苦想

这时机房的大佬来到我旁边看了一眼题

说了一句你输出i,j看看

然后就在我百无聊赖的输出i,j的时候

我发现了一个惊天的秘密

我差点忘了i,j在圆内也是对称的

所以我们可以先求出sum的最大值

然后在圆内不断-1(因为点的坐标一定是整数)

直到等于下一个坐标再求和即可

代码如下

```
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdio>
#define int long long
#define re register
using namespace std;

const int mod=1e9+7;
const int maxn=1e7+5;

int r,R,ans;

int sum,tot;
int base;

signed main()
{
	cin>>r;//输入的半径平方 
	R=(int)sqrt(r);//求出半径 
	base=R;//base维护前缀和 
	for(re int i=1;i<=R;++i) sum=(sum%mod+i*i%mod+10*mod)%mod;//先求出i*i的最大前缀和 
	tot=sum;//维护在坐标轴上能获得的最大权值和 
	for(re int i=1;i<=R;++i){//枚举坐标i,j 
		int j=(int)sqrt(r-i*i);
		while(base>j){//j用前缀和优化掉 
			sum=(sum%mod-base%mod*base%mod+mod)%mod;
			base--;
		}
		printf("%lld  ? %lld\n",i,j);
		ans=(ans%mod+j%mod*i%mod*i%mod+sum%mod+10*mod)%mod;//记录不在坐标轴上的答案 
	}
	ans=4*ans%mod;//有四个坐标系 
	ans=(ans+mod)%mod;
	ans=(ans%mod+4*tot%mod+10*mod)%mod;//加上在坐标轴上的点
	ans%=mod;
	cout<<(ans+10*mod)%mod;
	return 0;
}
```
祝大家csp rp++

大家继续加油鸭

---

## 作者：henry_y (赞：5)

**中考压轴题要是有这题这么简单就好了**

**——来自一位即将中考的oier**

其实这题挺简单的

我觉得难度也就绿题左右？为什么评到紫了。

[my blogs](http://www.cnblogs.com/henry-1202)

题目就是求
$$\large ans=\sum_{x}^{\sqrt{R}}\sum_{y}^{\sqrt{R}}[x^2+y^2<=R]$$


### 暴力
暴力60分

是枚举x,y判定然后最后*4就好了，x和y要有一个从0开始（坐标轴上的点也要算）

上界用$\sqrt{R}$

因为判定式子是$x^2+y^2=R$

### 正解
$R<=10^{14}$

所以正解应该是$O(\sqrt{R})$

因为答案是$$\large ans=\sum_{x}^{\sqrt{R}}\sum_{y}^{\sqrt{R}}[x^2+y^2<=R]$$

所以我们考虑能不能只枚举一个$x$

对于同一个$x$，由勾股定理我们很容易知道符合条件的$y$一共有$\sqrt{R-x^2}$
所以对于每个$x$的答案其实就是

$$\large\begin{aligned}&(x^2+1^2)+(x^2+2^2)+(x^2+3^3)+...+(x^2+maxy^2)\\&=x^2maxy+(1^2+2^2+3^2+...+maxy^2)\end{aligned}$$

所以后面一块直接套公式就好了

$$\large\begin{aligned}&=x^2maxy+(1^2+2^2+3^2+...+maxy^2)\\&=x^2maxy+\frac{maxy*(maxy+1)*(maxy+2)}{6}\end{aligned}$$

于是得以在$O(\sqrt{R})$内解决此题

代码中用到了\__int128，但实际上只用longlong就行了，\__int128只是在尝试暴力的时候搞的
```cpp
#include <bits/stdc++.h>

#define inf 0x3f3f3f3f
#define il inline

namespace io {

    #define in(a) a=read()
    #define out(a) write(a)
    #define outn(a) out(a),putchar('\n')

    #define I_int __int128
    inline I_int read() {
        I_int x = 0 , f = 1 ; char c = getchar() ;
        while( c < '0' || c > '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; }
        while( c >= '0' && c <= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; }
        return x * f ;
    }
    char F[ 200 ] ;
    inline void write( I_int x ) {
        if( x == 0 ) { putchar( '0' ) ; return ; }
        I_int tmp = x > 0 ? x : -x ;
        if( x < 0 ) putchar( '-' ) ;
        int cnt = 0 ;
        while( tmp > 0 ) {
            F[ cnt ++ ] = tmp % 10 + '0' ;
            tmp /= 10 ;
        }
        while( cnt > 0 ) putchar( F[ -- cnt ] ) ;
    }
    #undef I_int

}
using namespace io ;

using namespace std ;

#define ll __int128
const int mod = 1e9 + 7;
ll R;

int main() {
	R = read();
	ll ans = 0;
	for(ll x = 0; x * x <= R; ++x) {
		ll y = sqrt((double)(R - x * x));
		ans = ans + (ll)x * x * y + (y * (y + 1) * (2 * y + 1) / 6);
		ans %= mod;
	}
	outn(ans * 4 % mod);
}
```

---

## 作者：ShineEternal (赞：5)

#### 思考难度：提高?
#### 代码难度：普及?

首先有结论：半径$\sqrt{R}$的圆经过的整点数是$4\sum_{d|R}\chi(d)$，其中$$\chi(d)=1~(d\!\!\mod 4=1),~-1~(d \!\!\mod 4 =3),~0~(d \!\!\mod 2=0).$$

所以答案是

$$4\sum_{i=1}^{R}i\sum_{d|i}\chi(d)$$

$$=4\sum_{d=1}^{R}d\times \chi(d)\sum_{i=1}^{\lfloor{\frac{n}{d}}\rfloor}i$$

然后就可以$O(\sqrt{R})$计算了。

# code:
```cpp
#include<cstdio>
typedef long long LL;
const LL mod=1e9+7;
const LL mod2=2e9+14;
LL R,ans,H,l=1,r,x,y;;
int main(){
    scanf("%lld",&R);
    for(;l<=R;l=-~r){
        r=R/(R/l);
        if(r&3&&r&3^3)x=(r+1)>>1;
        else x=-((r+1)>>1);
        if((l-1)&3&&(l-1)&3^3)y=l>>1;
        else y=-(l>>1);
        H=(R/l)%mod2;
        ans=(ans+(x-y)*(((H*(-~H))>>1)%mod))%mod;
    }
    ans=(ans+mod)%mod;
    printf("%lld\n",(ans<<2)%mod);
}
```

最后%一下 da32s1da

---

## 作者：Eric1031 (赞：3)

蒟蒻的问号，为什么要模6？

1,60分算法
暴力，一个点一个点地打（On），不讲了吧。

2,100分算法（504ms）

一条线一条线地打。
先讨论一个问题
对一个点，是不是由x平方和y平方构成？
一条线上，必有x或y相同，将该线上满足要求的点记下乘相同数的平方即可。

不多说了，上代码。
```
#include<bits/stdc++.h>
using namespace std;
const long long mod=1000000007;
long long sum,n,m,h,l;
int main()
{
	scanf("%lld",&n);
	m=sqrt(n);
	for(long long i=1;i<=m;i++)
	{
		h=n-i*i;
		l=sqrt(h);//确定一个象限上的点数
		l=(2*l+1)%mod;//一条线上的（轴上也有）
		h=(i*i)%mod;
		sum+=(h*l)%mod;
	}
	sum=(sum*4)%mod;//对称性
	printf("%lld",sum);
}
```

---

## 作者：TangLongbin (赞：2)

看到题目的瞬间：我X！这不是XX题吗？	
但是看完数据范围后狠狠的扇了自己一巴掌；	
根据数据范围，我们必须在**根号R**的时间内求出；

------------
仔细思考这个题目的所求量，我们会发现，其实就是求园内所有点的横坐标和纵坐标的平方和，但是直接枚举会TLE;	
接下来分析圆的性质：	
圆是一个关于圆对称的图像，圆的点也是对称的，因此我们只需要把1/4圆的值求出，再乘以四就是答案；~~然而并没有什么作用，依旧TLE;~~	
	
 我们把圆画出来仔细观察：
 ![](https://cdn.luogu.com.cn/upload/pic/47873.png )	
 到底哪里可以优化呢？
 
 我们换一个方式看看这个圆：
 ![](https://cdn.luogu.com.cn/upload/pic/47875.png )	
 ~~很清晰对不对？QAQ~~
 注意看图上的信息，我们重点关注图上的黑点~~（忽略箭头谢谢）~~
 这些黑点都是：当x坐标相同时的最高点，因为y坐标不能再加了；	
 再关注中间那个绿色的点，它与下面的黑点有什么不同？	
 没错！它们的y坐标相差1~~（和没说一样）~~！	
 另外我们可以发现，当x在增加时，y不会增加，只可能减小；	
 因此我们想：能不能从原点记录下最高的y，然后向右扫描求和，若y超过了圆，就把多余的部分减去，如果把我们的最高的y减小至圆内呢？？
 	
因为这样的话，我们的时间复杂度就接近于根号R了；
答案是肯定的；	
没有听明白的同学可以形象的理解成：有一条长度**只能为整数**的直线，从圆点向右移动，超出圆的时候就减小自己的高度，遇到整点时就求一次和，在减去因为自己减小所带来的代价；	
下面附上代码，我再标注：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
long long R,ans,Mod=1e9+7;
long long sum,Max,cut;

int main(){
    scanf("%lld",&R);
    Max=(long long)sqrt(R);//记录下最高高度，因为只能为整数，所以long long转换向下取整；
    for(register long long i = 1 ; i <= Max ;  ++i){
        sum=(i*i+sum)%Mod;//我们在圆点统计一下最高高度时的求和值；
    }
    for(register long long i = 0 ; i <= sqrt(R) ;  ++i){
    	while(i*i+Max*Max>R){
    		cut=(cut+Max*Max)%Mod;
    		Max--;
//这里的意思是：当我们的最高高度超过圆时，就减小自己的高度，并记录下减小高度带来的影响；
		}
    	ans=(ans+(i*i)%Mod*Max+sum-cut)%Mod;//因为i是枚举的整点，所以每一次循环都求和sum，并减去减小高度带来的影响cnt
	}
    printf("%lld",(4*ans)%Mod);//输出走人；
    return 0;
}
```


---

## 作者：Scrutiny (赞：1)

首先推导一下平方和公式.

我们有：

$\begin{cases}n^3-(n-1)^3=3n^2+3n+1\\(n-1)^3-(n-2)^3=3(n-1)^2+3(n-1)+1\\\cdots\cdots\\1^3-0^3=3\times1^2+3\times1+1\end{cases}$

全部相加得：

$n^3=3(n^2+(n-1)^2+\cdots+1^2)+3\times\dfrac{n(n+1)}{2}+n.$

所以 $n^2+(n-1)^2+\cdots+1^2=\dfrac{n(n+1)(2n+1)}{6}.$



------------

题目即求 $x^2+y^2\le R$ 的整数解中，所有满足条件的 $(x,y)$ 中 $x^2+y^2$ 的和。

不妨令 $x,y\ge0$（最后答案乘以 $4$ 即可）

考虑从 $0 $ 到 $\sqrt{R}$ 枚举 $x$，

对于每个 $x$，满足该不等式的 $y$ 最大值为 $\sqrt{R-x^2}$。

因此横坐标对答案的贡献为 $x^2y$，纵坐标贡献为 $\sum\limits_{i=0}^yi^2$。

利用平方和公式可得，对答案的总贡献为 $x^2y+\dfrac{y(y+1)(2y+1)}{6}$。最后求个和即可。

**不要忘记取模！** **不要忘记取模！** **不要忘记取模！**


------------

**CODE:**

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long r,ans;
int main(){
	cin>>r;
	for(unsigned long long x=0;x*x<=r;++x){
		unsigned long long y=sqrt((double)r-x*x);
		ans+=((__int128)y*(y+1)*(2*y+1)/6+(__int128)x*x*y)%1000000007;
		ans%=1000000007;
	}
	cout<<ans*4%1000000007;
	return 0;
}
```


---

## 作者：panyf (赞：1)

不算困难的一道题目，其实不需要平方和公式

此题其实是求圆内所有格点到原点距离的平方之和，也就是求格点横坐标的平方与纵坐标的平方之和，由于圆心在原点处，由对称性，只需求出横坐标的和，再乘2就可以了

求和时只需求出一个象限和一个坐标轴上点的坐标之和，但要注意减去坐标轴上多加的部分，计算时有一些细节要考虑，尽量在中间过程中多取模，以免爆long long（我因此WA了许多次）

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long m=1e9+7;
long long r,t,u,s,v;
int main(){
	scanf("%lld",&r),t=sqrt(r);
	for(register long long i=1;i<=t;i++){//只枚举一个坐标轴，因此从1开始
		u=sqrt(r-i*i);
		s=(s+(u+1)*i%m*i)%m;//求和
		v=(v+i*i)%m;//求出坐标轴上多加的部分
	}
	printf("%lld",(s*8+m*4-v*4)%m);//注意要加m的倍数，以免出现负数
}
```


---

## 作者：Dilute (赞：1)

### [$$\text{在本人blog食用更佳}$$](http://dilute.coding.me/2019/01/28/Solutions/Solution-Luogu5174/)

### 题外话

我本来自己想到的的做法是跟别的大多数题解一样的

但是$LJC00118$大仙跟我讲了他的做法，据说常数更小一些，于是我就过来发（水）题（社）解（区）了（分）。

### 解法

首先，我们看到圆上整点，我们可以发现圆上整点的集合就是满足$x, y$都为整数，且$x^2 + y^2 \leq r^2$的点的集合，那么这题要求的东西就可以表示成
$\displaystyle\sum_{i = 1}^{\sqrt r}\sum_{i^2 + j^2 \leq r} i^2 + j^2$
表达不太规范，反正意思对就行QwQ

我们把这个式子给化一下

令$j$的上界为$maxj$
$ \displaystyle\sum_{i= 1}^{\sqrt r} \left(\sum_{j = 1}^{maxj} j^2\right) + i^2 * maxj$

$ \displaystyle\sum_{i = 1}^{\sqrt r} \frac{maxj(maxj + 1)(2maxj + 1)}{6} + i^2 * maxj$



然后我们瞪一下这个式子，显然可以发现$maxj$是单调下降的

然后我们存一下$maxj$，然后一遍枚举$i$一边算$maxj$就可以做了

## 代码

```cpp
#include<bits/stdc++.h>

#define ll long long
#define INF 2147483647
#define mod 1000000007

ll powmod(ll a, int b){
    ll sum = 1;
    while(b){
        if(b & 1){
            sum *= a;
            sum %= mod;
        }
        a *= a;
        a %= mod;
        b >>= 1;
    }
    return sum;
}
ll inv6;

ll sum(ll n){
    return (n * (n + 1) % mod * ((n << 1) + 1) % mod) * inv6 % mod;
}

int main(){
    inv6 = powmod(6, mod - 2);
    ll r;
    scanf("%lld", &r);
    ll ans = 0;
    ll num = sqrt(r) + 1;
    for(ll i = 0; i * i <= r; i++){
        while(i * i + num * num > r)
            num--;
        ans += i * i % mod * num % mod;
        ans %= mod;
        ans += sum(num);
        ans %= mod;
    }
    ans <<= 2;
    ans %= mod;
    printf("%lld\n", ans);
}
```



---

## 作者：meyi (赞：0)

思路：圆是轴对称图形，有无数条对称轴，根据这个特性，我们暴力求出第一象限中被包含的整点的权值的和，然后将其乘四后输出即可
```cpp
#include<cstdio>
#include<cmath>
#define ll long long
//看看数据范围，本题需要用long long
const int m=1000000007;
//模数1e9+7
main(){
    ll r;
    scanf("%lld",&r);
    ll s=0,t=sqrt(r);
    for(register ll i=1;i<=t; ++i){
        ll k=sqrt(r-i*i);
        s=((s+i*i%m*(k+1)%m)%m+((k<<1)+1)%m*(k+1)%m*k%m*166666668%m)%m;
        //暴力求权值的和
    }
    printf("%d",(s<<2)%m);
    //输出
}
```

---

## 作者：fighter (赞：0)

**来一篇不一样的题解**(~~其实是看不懂正式题解~~)


------------

R $\leqslant 10^{14}$

因为半径是$\sqrt{R}$, 所以半径$\leqslant 10^{7}$

那么我们就可以枚举整数横坐标，对应的可以得出此横坐标对应的最大的纵坐标，而此时由于权值=$x^{2}+y^{2}$。而横坐标已经确定，我们要做的就是求出纵坐标的平方和

那么就可以利用首项和公差均为1的等差数列的平方和公式：

$S=\frac 16*n*(n+1)*(2n+1) $

唯一的问题就在于$\frac 16$无法直接对$10^{9}+7$取模，于是我们可以预处理出6在模$10^{9}+7$意义下的逆元：$inv=166666668$

然后直接套用公式计算即可。最后不要忘记将答案*4，因为我们仅考虑了一个象限内的权值，另三个象限内的权值和完全相等。

还有，数据较大，建议边乘边取模

# 代码：
```cpp
#include <bits/stdc++.h>
#define MAX 105
#define ll long long
#define p (ll)(1e9+7)
using namespace std;

ll r, ans, ny = 166666668;

int main()
{
	cin >> r;
	for(ll i = 1; i*i <= r; i++){
		ll y = (ll)floor(sqrt(r-i*i));
		ans = (ans + (y+1)%p*i%p*i%p)%p;
		ans = (ans + y%p*(y+1)%p*(y*2+1)%p*ny%p)%p;
	}
	cout << ans*4%p << endl;
	
	return 0;
}
```

---

## 作者：Catalan1906 (赞：0)

关于赛题#B 圆点

- 它~~可能~~是本场比赛最水的一道题了

---

25pts:

暴力。

该圆的方程可以写为$x^2+y^2=r$。

我们枚举x、y，如果权值小于r，答案+=权值。

---

50pts:

~~其实我也不知道怎么做~~

---

80pts:

我们可以枚举$0~\sqrt{r}$内的整数横坐标（记为x），算出最大满足题意的纵坐标（记为y）。

原来我们要求的$x^2\times 1^2+x^2\times 2^2+x^2\times 3^2+\ldots +x^2\times maxy^2$

用乘法分配律，原式$=x^2\times (1^2+2^2+3^2+\ldots +maxy^2)$

根据小学奥数的知识，$1^2+2^2+3^2+\ldots +n^2=\frac{1}{6}n(n+1)(2n+1)$，然后代到上面的式子里，就可以算了。

这算的是一个象限的，最后还要乘4。qaq

别忘记随时取模，防溢出。

然后你愉快地WA了4个点。

---

85pts:

~~解决方法：`#define int long long`~~

然后你会发现这玩意儿不管用诶！！！

~~正确方法：`#define int __int128`~~

成功TLE了3个点~~，真刺激。~~

哦，对了，如果你CE了，`int main()`应改为`signed main()`。

---

100pts：

毒瘤数论需卡常……orz

先是用了编译优化……TLE

后来才发现……

膜运算不能太多，因为是大数据类型，适当地膜就行咯qaq（当然也不能只到最后才膜一下。。。）

code:
```
#include <bits/stdc++.h>
#define int __int128

#pragma GCC optimize(3)
#pragma GCC target("avx")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")

const int mod = 1e9 + 7;

using namespace std;

int read() {
	int tmp = 0;
	char c = getchar();
	while(!isdigit(c)) c = getchar();
	while(isdigit(c)) tmp = (tmp << 1) + (tmp << 3) + c - 48, c = getchar();
	return tmp;
}

void write(int x) {
	if(x > 9) write(x / 10);
	putchar(x % 10 + 48);
} 

signed main() {
	int r = read();
	int ans = 0;
	for(int i = 0; i * i <= r; i++) {
		int n = sqrt((double)(r - i * i));
		// cout << n << " ";
		ans += i * i * n + (n * (n + 1) * (2 * n + 1) / 6);
		ans %= mod;
	}
	write(ans * 4 % mod);
	return 0;
}
```

---

## 作者：Sooke (赞：0)

### 题意

给定 $n$，求 $\sum\limits_{i^2+j^2\leqslant n,\ i,\,j \in R}i^2+j^2$。

### 解题思路

出题人可能是观[此视频](https://www.bilibili.com/video/av12131743)有感，于是有了本题，官方题解中利用 $\chi$ 函数的思路与[此题](https://www.luogu.org/problemnew/show/P2508)类似。

实际上，这有点大材小用了。

观察到我们求的式子可以拆成：

$$(\sum_{i^2+j^2\leqslant n,\ i,\,j \in R}i^2) + (\sum_{i^2+j^2\leqslant n,\ i,\,j \in R}j^2)$$

其实是本质相同的东西，于是只要求：

$$2 \times (\sum_{i^2+j^2\leqslant n,\ i,\,j \in R}i^2)$$

尽管 $n$ 的范围是 $10^{14}$，但我们发现上式中，$i$ 最大也只能取到 $\lfloor \sqrt{n} \rfloor$。

这样就很好想到 $O(\sqrt{n})$ 的做法了：从小到大枚举 $|i|$，而 $|j|$ 不需要枚举，因为随着 $|i|$ 的增大，可行的最大的 $|j|$ 是非降的，按照这个性质维护好即可。

注意上面说的都是 $|i|,\,|j|$，带有绝对值，这意味着我们还需要稍微考虑一下正负性。对于 $j$，单独拉出 $j = 0$ 的情况，否则 $j$ 将有两种正负性，假设枚举到 $|i|$ 时，我们有可行的最大 $|j|$，则有 $2|j| + 1$ 种方案与 $|i|$ 匹配。对于 $i$，$i = 0$ 的情况就无需特判了，因为 $i^2 = 0$，也不会对答案产生贡献，这样不管哪个 $|i|$，都认为其有两种正负性，贡献翻倍。结合我们最后得到的式子，因为最后还要再乘个 $2$，考虑上面就是最后乘个 $4$。

### 代码实现

模拟上述过程就行了。

```cpp
#include <cmath>
#include <cstdio>

const int p = 1e9 + 7;

long long n, ans;

int main() {
    scanf("%lld", &n);
    for (long long i = 0, j = sqrt(n); i * i <= n; i++) {
        while (i * i + j * j > n) { j--; }
        ans = (ans + i * i % p * (j * 2 + 1) % p) % p;
    }
    printf("%lld\n", (ans << 2) % p);
    return 0;
}
```

---


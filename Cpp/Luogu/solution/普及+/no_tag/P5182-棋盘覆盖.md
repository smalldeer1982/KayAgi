# 棋盘覆盖

## 题目描述

给定一个 $N$ 行 $N$ 列的棋盘，已知某些格子禁止放置。

求最多能往棋盘上放多少块的长度为 $2$、宽度为 $1$ 的骨牌，骨牌的边界与格线重合（骨牌占用两个格子），并且任意两张骨牌都不重叠。

## 说明/提示

$1 \le N \le 100$，$0 \le t \le 100$

## 样例 #1

### 输入

```
8 0```

### 输出

```
32```

# 题解

## 作者：110821zj_hhx (赞：3)

把整张图染成黑白两色，相邻的格子不同色。

对于每一个可用的白格，向他相邻的可用的黑格连一条边，那么每一个骨牌就是一条边，题目转化为从一张图中选取边，且这些边的端点不能重复。

这张图是二分图，黑格之间没有边，白格之间也没有边，可以使用二分图匹配，得出的结果就是答案。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define int long long
using namespace std;
int n,t,a[105][105],ans,M[10005],lx[4]={1,0,-1,0},ly[4]={0,1,0,-1};
bool vis[10005];
vector<int>s[10005]; 
bool find(int x){
	for(int i=0;i<s[x].size();i++){
		int y=s[x][i];
		if(vis[y]) continue;
		vis[y]=1;
		if(!M[y]||find(M[y])){
			M[y]=x;
			return true;
		}
	}
	return false;
}
signed main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]=(i+j)%2;
		}
	}
	while(t--){
		int x,y;
		cin>>x>>y;
		a[x][y]=2;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]==0){
				for(int k=0;k<4;k++){
					int ii=i+lx[k],jj=j+ly[k];
					if(ii>0&&ii<=n&&jj>0&&jj<=n&&a[ii][jj]!=2) s[(i-1)*n+j].push_back((ii-1)*n+jj);
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]==0){
				memset(vis,0,sizeof(vis));
				ans+=find((i-1)*n+j);
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}


```

---

## 作者：foglake (赞：2)

#### [题目传送门](https://www.luogu.com.cn/problem/P5182)

机房老师给的二分图练习题，做完回来发现只有一篇题解。~~那还不得来一发。~~

由于我们已经知道是二分图。不妨想一下怎么把这题和二分图联系一下。

观察一下发现这个棋盘格点向四周格点建图直接就满足二分图的性质了，就像国际棋盘一样，黑格和白格分别为二分图的左部和右部，那么将骨牌看作边，又由于一格中不能放两个骨牌，即同一个点不能与两条边相连，又要求骨牌最大放置数，这显然又要求**二分图最大匹配**了。

所以将每个格子看作一个点，每个点向它上方、下方、左边、右边的点建边（如果有的话）。最后跑一边匈牙利算法就行了。

### 代码：
```
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
const int maxn = 10010;
int match[maxn], vis[maxn], ans, n, t;
bool in[110][110];
vector <int> v[maxn];
bool solve(int x) {
    if (vis[x]) return 0;
    vis[x] = 1;
    for (int i = 0; i < v[x].size(); i++)
        if (!match[v[x][i]] || solve(match[v[x][i]])) {
            match[v[x][i]] = x;
            return 1;
        }
    return 0;
}//匈牙利算法
int change(int x, int y) {
    return (x - 1) * 100 + y;
}//将点(x, y)压缩成一个数 
int main() {
    scanf("%d%d", &n, &t);
    for (int i = 1; i <= t; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        in[x][y] = 1;   
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (in[i][j]) continue;
            if (!in[i + 1][j] && i != n) {
                v[change(i, j)].push_back(change(i + 1, j));
                v[change(i + 1, j)].push_back(change(i, j));
            }//连竖直边 
            if (!in[i][j + 1] && j != n) {
                v[change(i, j)].push_back(change(i, j + 1));
                v[change(i, j + 1)].push_back(change(i, j));
            }//连水平边 
        }
    }
    for (int i = 1; i <= n * 100; i ++) {
        memset(vis, 0, sizeof vis);
        if (solve(i)) ans ++;
    }//这里实际上将左部和右部的所有点全跑了一遍，等于答案翻了两倍 
    printf("%d", ans / 2);
}
```

---

## 作者：sunqihuan (赞：1)

首先从直觉上来看这是一个最大流问题。然后观察得出，如果将棋盘黑白染色（就像国际象棋棋盘那样），那么一个骨牌一定会覆盖一个黑格和一个白格，且每一个格子也最多只能被一个骨牌覆盖。为了不重复计算答案，我们只计算 $x+y$ 为偶数时的答案，不然一个骨牌会被重复计算一次。

对于格子 $(x,y)$，$x+y$ 为偶数时源点向它连边，且这个点连向周围四个可以走的点（可以走定义为不在棋盘外且不是障碍）连边；为奇数时这个点向汇点连边即可。容量均为 $1$。

这样格子就按 $x+y$ 的奇偶性被分为了两类，每一个格子最多只能被覆盖一次所以这也可以用二分图做最大匹配。

这里的代码用最大流实现。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 305 * 305, M = 2e5 + 5, inf = 1e8;

int n, m, S, T, vis[105][105];
int nxt[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
int h[N], e[M], f[M], nt[M], idx;
int q[N], d[N], cur[N];

int get(int x, int y)
{
	return (x - 1) * n + y;
}

void add(int a, int b, int c)
{
	e[idx] = b;
	f[idx] = c;
	nt[idx] = h[a];
	h[a] = idx ++ ;
	e[idx] = a;
	f[idx] = 0;
	nt[idx] = h[b];
	h[b] = idx ++ ;
}

bool bfs()
{
	memset(d, -1, sizeof(d));
	int head = 0, tail = 0;
	q[0] = S;
	d[S] = 0;
	cur[S] = h[S];
	while (head <= tail)
	{
		int t = q[head ++ ];
		for (int i = h[t]; ~i; i = nt[i])
		{
			int v = e[i];
			if (d[v] == -1 && f[i])
			{
				d[v] = d[t] + 1;
				cur[v] = h[v];
				if (v == T) return 1;
				q[ ++ tail] = v;
			}
		}
	}
	return 0;
}

int find(int u, int limit)
{
	if (u == T) return limit;
	int flow = 0;
	for (int i = h[u]; ~i && flow < limit; i = nt[i])
	{
		cur[u] = i;
		int v = e[i];
		if (d[v] == d[u] + 1 && f[i])
		{
			int t = find(v, min(f[i], limit - flow));
			if (!t) d[v] = -1;
			f[i] -= t;
			f[i ^ 1] += t;
			flow += t;
		}
	}
	return flow;
}

int dinic()
{
	int r = 0, flow;
	while (bfs()) while (flow = find(S, inf)) r += flow;
	return r;
}

int main()
{
	memset(h, -1, sizeof(h));
	cin >> n >> m;
	S = 0, T = n * n + 1;
	for (int i = 1; i <= m; i ++ )
	{
		int x, y;
		scanf("%d%d", &x, &y);
		vis[x][y] = 1;
	}
	for (int i = 1; i <= n; i ++ )
	{
		for (int j = 1; j <= n; j ++ )
		{
			if (vis[i][j]) continue;
			if ((i + j) % 2)
			{
				add(get(i, j), T, 1);
				continue;
			}
			for (int k = 0; k < 4; k ++ )
			{
				int x = i + nxt[k][0], y = j + nxt[k][1];
				if (x > 0 && x <= n && y > 0 && y <= n && !vis[x][y])
					add(get(i, j), get(x, y), 1);
			}
			add(S, get(i, j), 1);
		}
	}
	int res = dinic();
	cout << res << endl;
	return 0;
}


```

---

## 作者：albertting (赞：1)

前置知识：[二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

### 分析

这题我们可以先掏出一个国际象棋棋盘：

![](https://cdn.luogu.com.cn/upload/image_hosting/rv45ybx0.png)

既然这个骨牌是 $1 \times 2$ 的，那么可以从图中看出，一个骨牌必然占据了一黑一白两个格子。

以黑格为例，如果骨牌的一端在这个黑格上，那么它一共有四种可能：

![](https://cdn.luogu.com.cn/upload/image_hosting/eqrijif3.png)

打钩的四个白格是其另一端可能的位置。

那么，白格也同理，周围四个黑格是它另一端的可能位置。

如果，我们在一个格子与它周围四个格子之间连边，那么这一定是二分图！

> #### 为什么是二分图
> 
> 回到那张棋盘，我们可以发现一个格子四周的格子颜色都和它不同，所以相当于黑格与黑格之间没有边，白格与白格之间没有边，构成二分图。

好！那么把图建出来跑最大匹配就好啦。

（什么你说还有禁止放置的格子？）

禁止放置的格子就不连边，也就相当于从原二分图中删边，依然构成二分图，放心跑就行了！

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, t;
vector<pair<int, int> > adj[105][105];
bool st[105][105];
bool vis[105][105];
pair<int, int> match[105][105];
int m[6][2] = {0, 0, 0, 1, 1, 0, 0, -1, -1, 0};

bool find(pair<int, int> u) { // 欸这里是二维的吼，要大改 P3386 的代码
	for(auto v : adj[u.first][u.second]) {
		if(!st[v.first][v.second]) {
			st[v.first][v.second] = 1;
			if(match[v.first][v.second] == make_pair(0, 0) || find(match[v.first][v.second])) {
				match[v.first][v.second] = u;
				return 1;
			}
		}
	}
	return 0;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> t;
	for(int i = 1; i <= t; i++) {
		int x, y;
		cin >> x >> y;
		vis[x][y] = 1;
	}
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            if(((i + j) & 1) && !vis[i][j]) {
                for(int k = 1; k <= 4; k++) {
                    int x = i + m[k][0], y = j + m[k][1];
                    if(x >= 1 && x <= n && y >= 1 && y <= n && !vis[x][y]) {
                        adj[i][j].push_back({x, y});
                    }
                }
            }
        }
    }
	int res = 0;
	for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
    		memset(st, 0, sizeof(st));
    		if(((i + j) & 1) && find({i, j})) res++;
        }
	}
	cout << res;
	return 0;
}
```

---

## 作者：_Liyx_ (赞：1)

前置芝士：[二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

## 思路

我们发现，一个骨牌需要占用两个相邻的方格，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/hu44tldo.png)

我们发现如果我们对棋盘进行染色，则一个骨牌会占用一个黑色格子和一个白色格子。

那么我们就可以对于每一个白色格子，让他对所有与他相邻的、可以放置的黑色格子连一条有向边。

每一条边表示所连的两个点之间是可以匹配的，我们需要对于每个白色格子都尽可能的匹配一个未被匹配的黑色格子，一个白色格子和被他匹配的黑色格子组成一个骨牌。

所以按上述方式连边，再跑一遍匈牙利即可。
## AC code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 105
int n, T;
bool is[N * N];
int pos(int x, int y) {
    return (x - 1) * n + y;
}
vector<int> g[N * N];
bool vis[N * N];
int match[N * N], res;
bool dfs(int u) {
    for (auto v : g[u]) {
        if (vis[v]) continue;
        vis[v] = 1;
        if (!match[v] || dfs(match[v])) {
            match[v] = u;
            return 1;
        }
    }
    return 0;
}
int main(){
    cin >> n >> T;
    while (T--) {
        int x, y;
        cin >> x >> y;
        is[pos(x, y)] = 1;
    }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            if ((i + j) % 2 || is[pos(i, j)]) continue;
            int k = pos(i, j);
            if (i > 1)
                if (!is[pos(i - 1, j)]) g[k].push_back(pos(i - 1, j));
            if (i < n)
                if (!is[pos(i + 1, j)]) g[k].push_back(pos(i + 1, j));
            if (j > 1)
                if (!is[pos(i, j - 1)]) g[k].push_back(pos(i, j - 1));
            if (j < n)
                if (!is[pos(i, j + 1)]) g[k].push_back(pos(i, j + 1));
        }
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            if ((i + j) % 2 || is[pos(i, j)]) continue;
            memset(vis, 0, sizeof vis);
            if (dfs(pos(i, j))) res++;
        }
    cout << res;
	return 0;
}
```

---

## 作者：cybermage_liu (赞：1)

前置知识：
* 二分图最大匹配。
# 思路
我们可以将棋盘看成国际象棋棋盘黑白交错的样子，以格子的颜色划分二分图。

为什么一定要这么划分？

因为这样两个相邻的格子一定是不同的颜色，连边时一定都是一黑一白。

不懂的可以自己画一下图。

如果两个相邻的格子都可以放置棋子，就从黑格连向白格。

那么答案就等同于二分图最大匹配的答案，用增广路算法扫一遍黑格就行了。

时间复杂度 $O(n^4+t^2)$。
# AC code
这里我以横坐标加纵坐标的奇偶性判定黑白格。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int match[N*N];
bool vis[N*N],a[N][N];
int head[N*N],nxt[N*N*2],ver[N*N*2],tot=0;
inline void add(int u,int v){
	nxt[++tot]=head[u];
	ver[tot]=v;
	head[u]=tot;
}
bool dfs(int u){//增广路算法 
	for(int i=head[u];i;i=nxt[i]){
		int v=ver[i];
		if(!vis[v]){
			vis[v]=1;
			if(!match[v] || dfs(match[v])){
				match[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	int n,t,ans=0;
	memset(a,0,sizeof(a));
	cin>>n>>t;
	for(int i=1;i<=t;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		a[x][y]=1;
	}
	for(int i=1;i<=n;i++){//横边 
		for(int j=2;j<=n;j++){
			if(!a[i][j] && !a[i][j-1]){
				int x=(i-1)*n+j;
				int y=(i-1)*n+j-1;
				if((i+j)%2) add(x,y);//从黑连向白 
				else add(y,x);
			}
		}
	}
	for(int i=2;i<=n;i++){//竖边 
		for(int j=1;j<=n;j++){
			if(!a[i][j] && !a[i-1][j]){
				int x=(i-1)*n+j;
				int y=(i-2)*n+j;
				if((i+j)%2) add(x,y);//从黑连向白 
				else add(y,x);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if((i+j)%2){//只扫黑格 
				memset(vis,0,sizeof(vis));
				if(!a[i][j] && dfs((i-1)*n+j)) ans++;
			}
		}
	}
	cout<<ans;
}
```

---

## 作者：Sine_Func (赞：1)

# [题解：P5182 棋盘覆盖](https://www.luogu.com.cn/problem/P5182)

# 前情提要:[P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

# 思路
将整个棋盘视作国际象棋棋盘，对于格子 $a_{i,j}$ ，如果其没有被锁定，那么检查他的正下方一个格子与正左方的一个格子（也就是 $a_{i+1,j}$ 与 $a_{i,j+1}$），如果没有被锁定，则将其连边，最后能放下的最大骨牌数也就是将其是为二分图进行最大匹配，答案也就是其最大匹配数

# code

```cpp
#include <bits/stdc++.h>
#define double long double
#define AC return 0
#define pii pair<int,int>
#define fi first
#define se second
#define gc getchar
#define el cout<<"\n"
#define ls (p<<1)
#define rs (p<<1|1)
//#define int long long
using namespace std;
const int N = 110;
int n, m, u, v, cu[N * N], vis[N * N], mch[N * N], ans;
vector<int>edge[N * N];
int idx(int x, int y) {
	return x * N + y;
}
bool dfs(int x, int tag) {
	if (vis[x] == tag)AC;
	vis[x] = tag;
	for (auto i : edge[x])
		if ((!mch[i]) || dfs(mch[i], tag)) {
			mch[i] = x;
			return 1;
		}
	AC;
}
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> u >> v;
		cu[idx(u, v)] = 1;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < n; j++) {
			if ((!cu[idx(i, j)]) && (!cu[idx(i, j + 1)])) {
				edge[idx(i, j)].push_back(idx(i, j + 1));
				edge[idx(i, j + 1)].push_back(idx(i, j));
			}
		}
	}
	for (int i = 1; i < n; i++)
		for (int j = 1; j <= n; j++)
			if ((!cu[idx(i, j)]) && (!cu[idx(i + 1, j)])) {
				edge[idx(i, j)].push_back(idx(i + 1, j));
				edge[idx(i + 1, j)].push_back(idx(i, j));
			}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if ((i - j) & 1)
				if (dfs(idx(i, j), idx(i, j)))
					ans++;
	cout << ans;
	AC;
}
```

---

## 作者：SproutPower (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5182)

题意已经描述得很清楚了，这里不再赘述

## 思路

注意到我们在学二分图时，学过用黑白染色法来判断该图是否为二分图。\
而这一题在棋盘上，棋盘也是黑白染色的，所以这题的知识点就显而易见了。

## 构造

我们可以就直接用原来国际象棋的染色方式给棋盘染色，那么一个多米诺骨牌就必定会覆盖一个黑格和一个白格。\
那么我们就可以把黑格放在集合 $T$ 白格格放在集合 $S$ 。因为多米诺骨牌只能连接相邻的格子，所以我们可以在相邻的格子建边，这样我们就构造出了一张二分图。

## 求答案


至于剩下的，注意到多米诺骨牌只能连接**一个**黑格和**一个**白格。\
也就是说，在我们构造的图上，集合 $S$ 中的**一个**元素，只能对应集合 $T$ 中的**一个**元素。\
把问题转化到这一步，就很明显了——这不就是二分图上的匹配问题吗?

如果你不会“二分图上的匹配问题”，请移步至[此模板题](https://loj.ac/p/6000)

把模板题的代码搬过来，把一维数组改成二维，改变一下DFS的方式和条件，就能解决了。

## 下面是代码时间

```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[114][514];
bool a[114][514];
int fx[5]={0, 0, 0, 1,-1};
int fy[5]={0, 1,-1, 0, 0};
int n,m,ans;
struct node{int x,y;}match[114][514];

bool dfs(int x,int y){
    for(int i=1;i<=4;i++){
        int cx=x+fx[i];
        int cy=y+fy[i];
        if(cx<1 || cx>n || cy<1 || cy>n || a[cx][cy])continue;
        if(!vis[cx][cy]){
            vis[cx][cy]=1;
            if((!match[cx][cy].x && !match[cx][cy].y) || dfs(match[cx][cy].x,match[cx][cy].y)){
                match[cx][cy].x=x;
                match[cx][cy].y=y;
                return 1;
            }
        }
    }
    return 0;
}

int main(){
    
    scanf("%d%d",&n,&m);
    int x,y;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        a[x][y]=1;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            memset(vis,0,sizeof vis);
            if(!((i+j)%2) && !a[i][j])ans+=dfs(i,j);
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：_12qwer_ (赞：0)

~~为了写一篇题解先去过了一道[模板绿题](https://www.luogu.com.cn/problem/P3386)，加[这道题](https://www.luogu.com.cn/problem/P5182)花了我**三个小时**。~~  
首先，我们把棋盘看做国际象棋的棋盘，黑白格相间，再把每个骨牌看做一条连接黑白格的边，就不难看出这是一张**二分图**，题目问的是最多放多少张骨牌，~~一眼**二分图最大匹配。**~~
::::info[二分图最大匹配不会的打开]
1. 先[戳这里](https://www.lanqu.vip/oi-wiki/graph/graph-matching/bigraph-match/)了解知识。
2. 再[戳这里](https://www.luogu.com.cn/problem/P3386)过模板题。
::::
# 输入
$N$ 行 $N$ 列的棋盘，$t$ 个不能放骨牌的点。  
接下来 $t$ 行，每行一个坐标。
# 处理
1. 输入不能放骨牌的点后，将这个点的坐标转变为数字，存入 bool 数组中记录下来。
2. 跑一遍全图，把可以建边的两个点建边，存入 vector （不一定要 vector ）数组中。
3. 最后再跑一遍二分图最大匹配模板就行了。
# 最后
::::info[AC代码]
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1E5+10;
int n,m,e;
int f[N];
bool a[N];
int dist[N];
vector<int> g[N];
int zb(int x,int y){
    return x*710+y;
}//将坐标转变为数字
bool dfs(int x,int y){
    if(f[x]==y){
        return 0;
    }
    f[x] = y;
    for(auto i : g[x]){
        if(dist[i]==0||dfs(dist[i],y)){
            dist[i] = x;
            return 1;
        }
    }
    return 0;
}
int main(){
    cin >> n >> m;
    int x,y;
    for(int i = 1;i<=m;i++){
        cin >> x >> y;
        a[zb(x,y)] = 1;//标记为1，表示不能建边
    }
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=n;j++){
            if(a[zb(i,j)]==0&&a[zb(i+1,j)]==0&&i+1<=n){
                g[zb(i,j)].push_back(zb(i+1,j));
                g[zb(i+1,j)].push_back(zb(i,j));
            }//可以建边，向下建边
            if(a[zb(i,j)]==0&&a[zb(i,j+1)]==0&&j+1<=n){
                g[zb(i,j)].push_back(zb(i,j+1));
                g[zb(i,j+1)].push_back(zb(i,j));
            }//可以建边，向右建边
        }
    }
    int ans = 0;
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=n;j++){
            if((i-j)%2==1||(j-i)%2==1){
                int xy = zb(i,j);
                if(dfs(xy,xy)){
                    ans++;
                }
            }
        }
    }//套模板
    return cout << ans,0;
}
```

::::
---


# 完结撒花✿✿ヽ(°▽°)ノ✿

---


# [COCI 2009/2010 #4] OGRADA

## 题目描述

 **译自 [COCI 2010.02](http://hsin.hr/coci/archive/2009_2010/) T4「[OGRADA](http://hsin.hr/coci/archive/2009_2010/contest4_tasks.pdf)」**

Matija 的栅栏由 $N$ 条木板组成，从左到右依次编号为 $1\ldots N$。$i$ 号木板的高度为 $h_i$，每条木板的宽度是 $1\ \rm{cm}$。

Matija 想用一个宽度为 $X\ \rm{cm}$ 的滚筒刷来刷木板。使用滚筒刷时，要保证刷子**完全**接触栅栏（不能一部分接触一部分不接触）；另外，还要保证滚筒平行于地面。因此，每次涂色时，Matija 会在栅栏上选择连续的 $x$ 条木板，然后从下往上「刷」，一直刷到这 $x$ 条木板中最矮者的高度。

根据上述规则，有可能有一些木板没法用滚筒刷来刷，Matija 不得不用牙刷来「涂」剩下的部分。因此，请帮他求出他最少只需用牙刷「涂」多少平方厘米。他还想知道，在满足「涂」的面积最少的情况下，他最少要用滚筒刷「刷」多少次。

## 说明/提示

#### 样例说明 1
![pp.png](https://i.loli.net/2018/12/30/5c289875b3356.png)

#### 数据范围与提示
$1\le N\le 10^6,$ $1\le X\le 10^5,$ $1\le h_i\le 10^6$.

## 样例 #1

### 输入

```
5 3
5 3 4 4 5```

### 输出

```
3
2```

## 样例 #2

### 输入

```
10 3
3 3 3 3 3 3 3 3 3 3```

### 输出

```
0
4```

## 样例 #3

### 输入

```
7 4
1 2 3 4 3 2 1```

### 输出

```
4
4```

# 题解

## 作者：sukimo (赞：6)

看到题目中的滚筒固定宽度，又因为这是经典的一类“刷木条”问题，和长度固定的区间中的最大最小值有关，所以考虑使用单调队列模拟长度为$X$的滚筒，滑动窗口地处理。

问一：处理面积，设木板$i$的高度为$hei_i$，很明显，如果将滚筒置放在$[i,i+X-1]$的区间，它所可以刷到的面积应该是：

$min\left\{hei_j\right\}\times X\ (i\le j\le i+X-1)$

那是不是将每个位置的贡献相加就可以了呢？并非如此，因为贡献可能重复。如何去重？我们设$ok\_rem_i$表示当滑动窗口以$i$为右端点且窗口大小是$X$时（即只有窗口用刷子来刷可以刷下时才统计），窗口内的最小高度。滑动窗口每次向右滑动一位，也就是说每次会有$X-1$个木板重复统计。那么最终结果应该为：

$\sum_{i=x}^n ok\_rem_i\times X-(X-1)\times min\left\{ok\_rem_i,ok\_rem_{i-1}\right\}$

解释一下减号后面的那个东西，即去重。首先上一次重复的宽度是$X-1$，然后重复的高度呢？肯定是这次和上次最小值的最小值，易证。我们把结果设置成最初面积之和，每次减去可刷高度，就是刷不到的。这样我们就解决掉了问一。

问二其实是一种贪心思想，我们假设现在有$w$个高度为$1$的木板，那么最少刷多少次呢？易证：$\lceil{\frac wX}\rceil$次。那么我们算出每一块木板的**有效高度**（即能刷到的高度，假设为$a$数组），然后对$a$数组进行游程编码，这样就划分出了一些如上面例子中的区间，如样例：

![p](https://cdn.luogu.com.cn/upload/image_hosting/0chrqqz3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$a:3\ \ \ \ \ 3\ \ \ \ \ 4\ \ \ \ \ 4\ \ \ \ \ 4$ 游程编码：$3\ 2,4\ 3$

因为不同高度的木板肯定不能一次刷，所以只能在相同高度间尽量贪心。那么就把两个区间分别用上面的式子处理，答案就是$\lceil\frac{2}{3}\rceil+\lceil\frac{3}{3}\rceil=2$次。

那么关键就是如何求出$a$数组。以上图的第$3$块木板为例子，它的有效高度与什么有关系呢？$a_3$应等于$max\left\{ok\_rem_3,ok\_rem_4,ok\_rem_5\right\}$，即找若要刷这一块，应以哪块木板做为右端点来刷。由此可以得到：

$a_i=max\left\{ok\_rem_j\right\}(i\le j\le min\left\{n,i+X-1\right\})$

可以发现，这又可以用单调队列$O(n)$地维护，于是问二又解决了。整个问题时间都是$O(n)$。

最后记得开$long\ long$！

$code$：

```
#include<algorithm>
#include<cstdio>
#include<deque>
#define ll long long
using namespace std;
const int MX=1000005;
ll hei[MX],ok_rem[MX];deque<ll>d;
int main(){
	ll n,m,_min=0,link=1,brush_tot=0;scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){scanf("%lld",&hei[i]);brush_tot+=hei[i];}
	for(int i=1;i<=n;i++){
		if(!d.empty()&&i-d.front()+1>m)d.pop_front();
		while(!d.empty()&&hei[d.back()]>hei[i])d.pop_back();d.push_back(i);
		if(i>=m){
			ok_rem[i]=hei[d.front()];brush_tot-=hei[d.front()]*m;brush_tot+=min(ok_rem[i-1],hei[d.front()])*(m-1); 
		}
	}
	printf("%lld\n",brush_tot);d.clear();
	for(int i=1;i<=n+m-1;i++){
		if(!d.empty()&&i-d.front()+1>m)d.pop_front();
		if(i<=n){
			while(!d.empty()&&ok_rem[d.back()]<ok_rem[i])d.pop_back();d.push_back(i);
		}
		if(i>=m)hei[i-m+1]=ok_rem[d.front()];
	}
	//下方为游程编码区间公式处理 
	for(int i=2;i<=n;i++)if(hei[i]!=hei[i-1]){_min+=(link+m-1)/m;link=1;}else link++;
	_min+=(link+m-1)/m;printf("%lld",_min);
	return 0;
}
/*
代码中省略掉了a数组，转而直接在ok_rem里面覆盖 
*/
```


---

## 作者：Hrz_OIer (赞：5)

# 思路 #

## 先考虑第一问 ##

显然这是个“滑动窗口”的模型。

但是把每个滑动窗口刷的面积加起来并不是答案，因为一个位置可能**会多次刷**。

考虑删去重复部分，当上一个滑窗高度为 $last$，这个为 $now$ 时，容易发现重合的部分为：

$$ \min \{{ last , now \}} \times (x − 1) $$

据此，就容易统计了。

code:

```cpp
//初始 sum 为木板高度和
	int lstans=0;
	for(int i=1;i<=n;++i){
		while(head<=tail&&a[q[tail]]>a[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		if(i>=x)
			mx[i-x+1]=a[q[head]]，//记录区间 [i-x+1,i] 的最小值，第二问用
			sum-=1ll*x*a[q[head]],
			sum+=1ll*min(a[q[head]],lstans)*(x-1),
			lstans=a[q[head]];}
```

## 考虑第二问 ##

我们记第一问求得区间 $[i, i + x − 1]$ 的最小值为 $mx_i$ 。
则位置 $i$ 被刷的高度 $color_i$ 为：

 $$ color_i = \max \{{mx_i−x+1, mx_i−x+2, · · · , mx_i\}} $$
 
这又是个单调队列的式子，可以单调队列优化。

最后，我们知道了每个位置要刷的高度，要求刷的次数。则用贪心可求出：

- 若 $color_i \ne color_i−1$，则肯定要分开来刷。

- 若有 k 个刷的高度相同的连续位置，要刷 $ \big\lceil \frac{k}{x} \big\rceil$ 次。

这样统计就行了。

code：

```cpp
	for(int i=1;i<=n;++i){
		while(head<=tail&&mx[q[tail]]<mx[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		brush[i]=mx[q[head]];}//记录刷的高度 
	int beg=-10000000,cnt=0;
	for(int i=1;i<=n;++i)
		//判断高度是否等于上一个，或者是太长刷不到了 
		if(brush[i]!=brush[i-1]||i>=beg+x)cnt++,beg=i;
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
#define int long long
int mx[N],q[N<<1],a[N],x,n,brush[N],head,tail,sum;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>x;
	for(int i=1;i<=n;++i)cin>>a[i],sum+=a[i];
	int lstans=0;
	for(int i=1;i<=n;++i){
		while(head<=tail&&a[q[tail]]>a[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		if(i>=x)
			mx[i-x+1]=a[q[head]],
			sum-=1ll*x*a[q[head]],
			sum+=1ll*min(a[q[head]],lstans)*(x-1),
			lstans=a[q[head]];}
	for(int i=1;i<=n;++i){
		while(head<=tail&&mx[q[tail]]<mx[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		brush[i]=mx[q[head]];}
	int beg=-10000000,cnt=0;
	for(int i=1;i<=n;++i)if(brush[i]!=brush[i-1]||i>=beg+x)cnt++,beg=i;
	cout<<sum<<"\n"<<cnt;
	return 0;}
```

点个赞吧！（ QAQ ）

---

## 作者：_H17_ (赞：3)

## 题目分析——第一问

用牙膏涂的最少就是用滚筒刷的最多，相邻 $X$ 个木板最多能涂的高度 $t_i=\min_{i=j}^{j+x-1} \{h_i\}$（就是相邻 $X$ 块的最低高度）。

然后每个木板（一下假设编号是 $i(1\le i \le n)$）可以被 $(i-x,i]$ 和 $[i, i+x)$ 之间的所有区间包含。所以每一块木板的最多滚筒涂的面积就是这两个区间之间的所有区间最大值 $g_i$。


格式化的说：$g_i=\max_{j=i-x+1}^{i}t_j$。

提示：可以使用单调队列维护 $t,g$（俩都可以维护），代码里 $h,t,g$ 分别是 $a,g,h$。

## 代码实现——第一问

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,x,a[1000001],q[3000001],f,r,g[1000001],h[1000001],ans;//q是单调队列
signed main(){
    cin>>n>>x;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)//类似窗口滑动、出队
            f++;
        while(f<r&&a[i]<a[q[r]])//类似单调栈因单调性出队
            r--;
        q[++r]=i;
        if(i-x+1>=0)
            g[i-x+1]=a[q[f+1]];//i-x+1~i的最大涂量
    }
    f=r=0;//重制队列
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)
            f++;
        while(f<r&&g[i]>g[q[r]])
            r--;//出队类似上面
        q[++r]=i,h[i]=g[q[f+1]];//储存i块木板的涂量
    }
    for(int i=1;i<=n;i++)
        ans+=a[i]-h[i];//记住，求得是牙膏刷的最小面积
    cout<<ans<<'\n';
    return 0;
}
```

如何检测自己写的第一问是对的？

测试点全 WA，提示信息都是 `Wrong Answer.wrong answer Too short on line 2.`时表示第一问你做对了。

## 题目分析——第二问

再写一遍？不不不，太难写了。只需要根据第一问得到的 $g$ 进行推算就行。

首先从 $k \sim X+k-1$ 如果遇到与 $g_k$ 不同的就说明中途又刷了一次，重新把不同的地方当 $k$ 算。

第二如果 $k \sim X+k-1$ 全相同那就从新开始刷了，$X+k$ 当做新 $k$ 算。

## 代码实现——第二问

```cpp
ans=0;
for(int i=1,lst=0,nxt=0;i<=n;i++){//lst维护上面的k，nxt是X+k-1
    if(h[i]!=h[lst])//不同
        ans++,lst=i,nxt=i+x-1;
    if(nxt<i)//长度超了
        ans++,lst=i,nxt=i+x-1;
}
cout<<ans;
```

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,x,a[1000001],q[3000001],f,r,g[1000001],h[1000001],ans;
signed main(){
    cin>>n>>x;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)
            f++;
        while(f<r&&a[i]<a[q[r]])
            r--;
        q[++r]=i;
        if(i-x+1>=0)
            g[i-x+1]=a[q[f+1]];
    }
    f=r=0;
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)
            f++;
        while(f<r&&g[i]>g[q[r]])
            r--;
        q[++r]=i,h[i]=g[q[f+1]];
    }
    for(int i=1;i<=n;i++)
        ans+=a[i]-h[i];
    cout<<ans<<'\n';
    ans=0;
    for(int i=1,lst=0,nxt=0;i<=n;i++){
        if(h[i]!=h[lst])
            ans++,lst=i,nxt=i+x-1;
        if(nxt<i)
            ans++,lst=i,nxt=i+x-1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：respect_lowsmile (赞：2)

单调队列问题。

### Solution:

首先，题目说了滚筒的宽度是固定的，而且每一次刷的高度是由最低的高度决定的。

也就是说我们每一次每一次刷的都是以当前点为起点的区间长度为 $ k $ 的最小值，还记的我们的滑动窗口吗？很明显就是求一段区间的最小值问题。


以样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/b67q56bp.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

区间长度为 $ 3 $，那么从 $ 1 $ 到 $ 3 $ 这个区间能刷到的最大高度就是 $ \min(a[i])$，$ 1 \le i \le 3 $ 

类比一下，区间长度为 $ k $，第 $ i $ 到 $ i+k-1 $ 能刷到的最大高度就是 $ h[i]= \min(a[j]) $，$ j\le i $ 并且 $ j \le i+k-1 $，我们用单调队列维护即可。

我们发现在 $ 1-3 $ 这个区间的最小值是 $ 3 $，但是在 $ 3-5 $ 这个区间的最小值是 $ 4 $，所以 $ 3 $ 号木板能涂到的最大高度就是 $ 4 $，也就是说每个木板能涂到的最大高度 $ maxc[i]=max(h[j]) $,$ i-k+1 \le j $ 并且 $ j \le i $ 。

那第一问就非常简单了，用木板原来的长度减去能刷到的最大高度，就是需要用牙刷刷的面积。

现在我们考虑第二问：求用滚筒刷的次数。

还是以样例为例：


![](https://cdn.luogu.com.cn/upload/image_hosting/b67q56bp.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

我们可以发现刷了两次，因为在 $ 1-3 $ 这个区间中，$ maxc[1] \ne maxc[3] $，也就是说在一个区间内，如果两个木板刷的高度不同，是要多刷一次的。

还有一种情况，那就是超过了区间长度。

我们来看第二组样例：

```
10 3
3 3 3 3 3 3 3 3 3 3
```
很明显，每个木板刷的高度都一样，但是刷的次数却是 $ 4 $，因为每次最多只能刷 $ 3 $ 个木板。

所以我们得出结论：

如果木板刷的高度不同或者超出了区间长度，我们就要多刷一次。

我们可以开两个变量 $ hnow $ 和 $ bj $ ~~汉语拼音法造变量名~~，记录当前的边界和高度。

### code：
```cpp
/*
	单调队列
	date:2022.7.28
	worked by respect_lowsmile 
*/
#include<iostream>
#define int long long
using namespace std;
const int N=1e6+5;
int maxc[N],h[N],q[N],a[N];
int len,n,ans,cnt,head,tail;
signed main()
{
	scanf("%lld %lld",&n,&len);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	head=1,tail=0;
	for(int i=1;i<=n;++i)
	{
		while(head<=tail&&q[head]<=i-len)  head++;
		while(head<=tail&&a[q[tail]]>a[i])  tail--;
		tail++;
		q[tail]=i;
		if(i-len+1>=0)  h[i-len+1]=a[q[head]];  
	}
	head=1,tail=0;
	for(int i=1;i<=n;++i)
	{
		while(head<=tail&&q[head]<=i-len)  head++;
		while(head<=tail&&h[q[tail]]<h[i])  tail--;
		tail++;
		q[tail]=i;
		maxc[i]=h[q[head]];
	}
	for(int i=1;i<=n;++i)
		ans+=a[i]-maxc[i];
	printf("%lld\n",ans);
	int hnow=0,bj=0;
	for(int i=1;i<=n;++i)
	{
		if(maxc[i]!=hnow||bj<i)
		{
			hnow=maxc[i];
			bj=i+len-1;
			cnt++;
		}
	}
	printf("%lld",cnt);
	return 0;
}
```

---

## 作者：dspt (赞：1)

给定 $x$ 和数组 $h_1,...,h_n$。每次操作选定 $i(1\leqslant i\leqslant n-x+1)$，并令 $\forall i\leqslant j<i+x,g_j=\min\limits_{k=i}^{i+x-1}h_k$。操作可以进行若干次，求 $\min\sum\limits_{i=1}^n(h_i-g_i)$，并求所需的最小操作次数。

---

显然，$\min\sum\limits_{i=1}^n(h_i-g_i)=\sum\limits_{i=1}^nh_i-\max\sum\limits_{i=1}^ng_i=\sum\limits_{i=1}^nh_i-\sum\limits_{i=1}^n\max g_i$，如果我们将每个 $i(1\leqslant i\leqslant n-x+1)$ 都进行操作，得到的 $g_i$ 一定为 $\max g_i$，也就是说，$\max g_i=\max\limits_{j=\max(1,i-x)}^i\min\limits_{k=j}^{\min(j+x-1,n)} h_k$。

这个式子看上去非常的复杂，但其实可以分开了做。观察到 $\min\limits_{k=j}^{\min(j+x-1,n)}h_k$ 实际上就是数组 $h$ 的一个定长区间。要在多个连续的定长区间内求最值，容易想到**单调队列**。于是可以先在 $h$ 数组上进行滑动窗口，处理出 $f_j=\min\limits_{k=j}^{\min(j+x-1,n)}h_k$，那么 $\max g_i=\max\limits_{j=\max(1,i-x)}^if_j$。再次观察到 $\max\limits_{j=\max(1,i-x)}^if_j$ 也是数组 $f$ 的一个定长区间，于是只要再在 $f$ 数组上进行滑动窗口，就可以得到 $\max g_i$ 的值。

再考虑第二问，第一问已经得知了 $g_i$，显然如果 $g_i\neq g_{i+1}(1\leqslant i<n)$，$i$ 与 $i+1$ 进行了至少一次不同的操作，于是可以进一步得到：当且仅当 $g_i=g_{i+1}$ 时，$i$ 与 $i+1$ 可能操作相同。基于这个性质，从左到右扫描数组 $g$，每次找到一段不能拓展的每个元素均相等的区间，将区间的操作次数累加至答案。对于区间 $[L,R]$，其操作次数为 $\lceil \frac{R-L+1}x\rceil$。

---

时间复杂度 & 空间复杂度 $O(n)$

```cpp
#include <stdio.h>
int n, x, f[1000001], g[1000001], h[1000001];
int l, r(-1), q[1000001]; // 手写单调队列
long long w; // min(sum hi-gi)
int t; // 最小操作次数
int main()
{
    
    scanf("%d%d", &n, &x);
    for (int i(1); i <= n; ++i) // 单调队列处理 f 数组
    {
        scanf("%d", &h[i]);
        while (l <= r & q[l] <= i - x) ++l;
        while (l <= r & h[i] < h[q[r]]) --r;
        q[++r] = i;
        if (i >= x) f[i - x + 1] = h[q[l]];
    }
    l = 0, r = -1; // 重置单调队列
    for (int i(1); i <= n; ++i) // 单调队列处理 g 数组
    {
        while (l <= r & q[l] <= i - x) ++l;
        while (l <= r & f[i] > f[q[r]]) --r;
        q[++r] = i;
        w += h[i] - (g[i] = f[q[l]]); // 统计答案
    }
    printf("%lld\n", w);
    for (int i(1); i <= n;)
    {
        int j(i);
        for (; j <= n; ++j) // 扫描出一个无法拓展的值均相等的区间
            if (j == n || g[j + 1] != g[i]) break;
        t += (j - i + 1) / x;     // 将操作次数累加至答案
        if ((j - i + 1) % x) ++t; // 除法向上取整
        i = j + 1;
    }
    printf("%d\n", t);
    return 0;
}
```

---

## 作者：yuxiaoyu20090104 (赞：1)

# [P5186 粉刷栅栏](https://www.luogu.com.cn/problem/P5186)
## 分析
本题类似于[P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)，因此很容易让人联想到利用单调队列解题，为了解题方便，对于一次粉刷，我们可以通过它的右端点来描述它的覆盖范围，例如位置为 $i (x < i < n)$ 的一次粉刷覆盖范围为 $[i - x + 1, i]$，其中$x$为刷子宽度。

我们记 $a[i]$ 为栅栏高度，$h[i]$ 为位置为$i$的粉刷操作的最大高度，不难想到 $h[i]$ 即为其覆盖范围内栅栏高度的最小值，即：
$$

h[i] = \min \{ a[j] \} (j \in [i - x + 1, i])

$$

区间最值，用单调队列维护即可。

得到 $h[i]$ 以后还不够，显然不是最优解，因为虽然位置为$i$的粉刷操作最高只能到达 $h[i]$，但是栅栏 $i$ 可以被其他位置的操作所覆盖，题目要求滚筒粉刷面积最大，那么对于任意的栅栏 $i$，我们都贪心的想让其被粉刷的部分尽量多，考虑栅栏 $i$ 可以被哪些位置的操作覆盖，再在这些位置中取 $h$ 的最值，即为$i$最多能被粉刷的高度，我们发现，只有位置在 $[i, i + x - 1]$ 中的操作可以覆盖到位置 $i$ 那么我们再做一次区间最值维护 $h$ 的区间最值，即为 $mx[i]$, 即可求出：

$$

ans1 = \sum_{i = 1} ^ n \ (a[i] - mx[i])

$$

注意第二次维护单调队列前要清空队列，且维护时从后往前跑。

------------
接下来考虑第二问：

我们希望总的粉刷操作次数尽量小，那么对于相邻的，且实际粉刷高度 $mx$ 相等的，我们一定希望在一个操作中完成粉刷，反之，如果两相邻$mx$不相等，那么一定不在同一操作内完成，知道了这一点，第二问也就不难解了，注意若存在 $mx$ 相等的连续长度超过 $x$ 的段，那么我们依然无法在一个操作中粉刷所有 $mx$ 相等的位置，具体细节见代码：

$code$

```cpp

#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;
int n, k, a[N], h[N], mx[N], ans1, ans2;
deque <int> qu;
signed main ()
{
	ios_base::sync_with_stdio (false);
	cin.tie (nullptr);
	cin >> n >> k;
	qu.push_back (0); // 插入空位置防止越界 
	for (int i = 1; i <= n; i ++)
	{
		cin >> a[i];
		while (!qu.empty () && qu.front () + k <= i) qu.pop_front ();
		while (!qu.empty () && a[qu.back ()] >= a[i]) qu.pop_back ();
		qu.push_back (i);
		h[i] = a[qu.front ()];
	}
	while (!qu.empty ()) qu.pop_back (); // 初始化 
	qu.push_back (n + 1);
	for (int i = n; i > 0; i --) // 从后往前倒推 
	{
		while (!qu.empty () && qu.front () - k >= i) qu.pop_front ();
		while (!qu.empty () && h[qu.back ()] <= h[i]) qu.pop_back ();
		qu.push_back (i);
		mx[i] = h[qu.front ()];
	}
	for (int i = 1; i <= n; i ++) ans1 += (a[i] - mx[i]);
	cout << ans1 << endl;
	int cnt = 0; // 用来记录mx连续相等的段 
	for (int i = 1; i <= n; i ++)
	{
		if (mx[i] != mx[i - 1] || cnt >= k) // 进行下一次操作 
		{
			ans2 ++;
			cnt = 0;
		}
		cnt ++;
	}
	cout << ans2;
	return 0;
}

```

思路借鉴了[wzxwowu](https://www.luogu.com.cn/user/205538)dalao的第一篇题解，在此鸣谢QWQ。

---

## 作者：naroto2022 (赞：1)

# P5186 题解

### 前置知识

1. 单调队列求区间最值。（可以看后记）

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P5186)

### 思路

#### 第一个答案

先看样例解析图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hjt2c9lp.png)

我们需要满足题目刷的限制，保证刷子完全接触栅栏，也就是每次刷的时候不能刷到空的；

所以，我们可以求得在 $i$ 到 $i+x-1$ 刷的高度就是 $\min(a[j])(j\in[i,i+k-1])$。

我们用一个数组 $h$ 来记录这个值。

于是，两眼一瞪，就可以看出来这就是裸的单调队列求最小值嘛！简简单单的进行一次单调队列就可以求出 $h$。

当然，继续往下考虑，会发现，只有一个 $h$ 这个求区间的数组远远不够，我们需要的是一个能记录每个木板能刷到的最大值。

于是再设一个数组 $mx$ 来存每个木板能刷到的最大值。

由 $h,mx$ 数组的定义，我们可以知道 $mx[i]=\max(h[j])(j\in[i-k+1,i])$。

于是又一瞪，这不又是一个单调队列求区间最大值模板吗？简简单单解决了！

于是，第一问就解决了，只要累加一下 $a[i]-mx[i]$ 即可（原先高度减去最大能刷的高度）。

#### 第一问代码

```cpp
for(int i=1; i<=n; i++){//单调队列求最小值。
        while(head<=tail&&a[q[tail]]>a[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        if(i-x+1>=0) h[i-x+1]=a[q[head]];
    }
    head=1,tail=0;
    for(int i=1; i<=n; i++){//单调队列求最大值。
        while(head<=tail&&h[q[tail]]<h[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        mx[i]=h[q[head]];
    }
	for(int i=1; i<=n; i++) ans+=a[i]-mx[i];//记录第一个答案。
	printf("%lld\n",ans);
```


#### 第二个答案

来到了第二问，这一看，难道是要再写一遍？？？不不不，只要求出的 $mx$ 就足够了。有以下两种情况:

- $i\sim i+x-1$：如果遇到了 $mx[i]$ 不同的情况那就是要新刷一次，重新把不同的地方当 $i$ 来算。
- $i\sim i+x-1$：如果全部相同，那就新刷一次，把 $i+x$ 当做 $i$ 来算。

累加即可。

#### 第二问代码

```cpp
long long lst=0,nxt=0;
	for(int i=1; i<=n; i++){
		if(mx[i]!=lst||nxt<i){//长度超了或者两个不同 
			lst=mx[i];
			nxt=i+x-1;
			ans++;
		}
	}
```


### 总代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int MN=1000005;
long long n,x,a[MN],q[MN],h[MN],mx[MN],head=1,tail=0,ans;
int main(){
	scanf("%lld %lld",&n,&x);
	for(int i=1; i<=n; i++) scanf("%lld",&a[i]);
	for(int i=1; i<=n; i++){//单调队列求最小值。
        while(head<=tail&&a[q[tail]]>a[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        if(i-x+1>=0) h[i-x+1]=a[q[head]];
    }
    head=1,tail=0;//初始化。
    for(int i=1; i<=n; i++){//单调队列求最大值。
        while(head<=tail&&h[q[tail]]<h[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        mx[i]=h[q[head]];
    }
	for(int i=1; i<=n; i++) ans+=a[i]-mx[i];//记录第一个答案。
	printf("%lld\n",ans);
	ans=0;//初始化。
	long long lst=0,nxt=0;
	for(int i=1; i<=n; i++){
		if(mx[i]!=lst||nxt<i){
			lst=mx[i];
			nxt=i+x-1;
			ans++;
		}
	}
    printf("%lld\n",ans);
	return 0;
}
```


### 后记

这是到练单调队列的好题，当然，你翻到这可能是你不咋了解单调队列，那我也来讲解一下吧。

#### 问题引入

[单调队列模板题](https://www.luogu.com.cn/problem/P1886)

#### 算法介绍

队列大家应该都知道，那单调队列单调队列，顾名思义就是要保持元素的单调性的队列。

#### 算法流程

其实由介绍就可以知道代码大概要怎么写了，我也不多说，会模拟的可以先自己去尝试尝试，实在不行，请自行理解下面的代码：

```cpp
//求最小值，最大值同理，代码不放，要自行思考才能完全理解这个算法 
head=1;tail=0;//为啥要这样呢?因为head要严格对应首元素，tail要严格对应尾元素，所以当tail>=head时，说明有元素。而一开始队列为空，说一要这样赋值。其实这跟普通队列一样。
for(int i=1; i<=n; i++){//a[i]表示当前要处理的值
    while(head<=tail&&q[tail]>=a[i]) tail--;//只要队列里有元素，并且尾元素比待处理值大，即表示尾元素已经不可能出场，所以出队。直到尾元素小于待处理值，满足"单调"。
    q[++tail]=a[i];//待处理值入队。
    while(p[head]<=i-k) head++;//如果队首元素已经"过时"，出队。
    if(i>=k) printf("%d ",q[head]);//输出最值，即队首元素。i>=k表示该输出，至于why就自己看题目。
}
```

#### 题目迁移

[好消息，坏消息](https://www.luogu.com.cn/problem/P2629)（值得一做的单调队列训练题）

---

## 作者：xhz0311 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5186)

## 思路分析
### 第一问
设 $h_{i}$ 表示第 $i$ 条木板的高度，$a_{i}$ 表示 $i \sim (i+x-1)$ 条木板中最低者。由于刷子不能离开木板，所以如果选择要刷 $i \sim (i+x-1)$ 条木板，那么能刷到的高度即为 $a_{i}$。   
由于在刷第 $i$ 条木板时，可以选择刷 $(i-x+1) \sim i$ 号或 $(i-x+2) \sim (i+1)$ 号或 $\dots$ 或 $i\sim (i+x-1)$ 号，所以第 $i$ 条木板能刷到的最大高度即为 $a_{i-x+1}\sim a_{i}$ 的最大值，设为 $ans_{i}$。      
那么第一问所求最小面积即为每一条高度减每一条所能刷到的最大高度的差之和。

也即：   
$a_{i}=\min h_{j} \ (i\le j \le i+x-1) \ \ \ ans_{i}=\max a_{j} \ (i-x+1\le j\le i)$，第一问答案为 $\sum(a_{i}-ans_{i})$。

只用先对 $h$ 跑一遍单调增队列得到 $a$，再对 $a$ 跑一遍单调减队列得到 $ans$ 即可。

### 第二问
思考什么时候需要再刷一次。

- 刷的高度发生变化的时候要重新刷一次（即 $ans_{i} \neq ans_{i+1}$ 时）。
- 虽然高度没变化，但刷子不够长了，需要再刷一次。

扫一遍 $ans$ 数组。记录下上次刷的高度 `lasth` 和上次是从第几号刷起 `lastn`，遇到上面两种情况时 `cnt++` 并更新 `lasth lastn` 即可。

### 注意
对 $h$ 的单调递增队列循环内注意 `if (i>=x)` 和 `a[i-x+1]`。这是因为要入队前 $i$ 项元素，才能求得 $a_{i-x+1}$（从 $(i-1+x)$ 号到 $i$ 号木条最短高度）。

要开 `long long`，[否则](https://www.luogu.com.cn/record/132360124)。
### 代码
```
#include <bits/stdc++.h>
#define int long long//第一次提交没开longlong见祖宗了
using namespace std;
int n,x,h[1000005],a[1000005],ans[1000005];
int q[1000005],l=1,r=0;
int cnt,sum,lasth,lastn;
signed main()
{
	scanf("%lld %lld",&n,&x);
	for (int i=1; i<=n; i++)
	{
		scanf("%lld",&h[i]);
	}
	
	//对h的单调递增队列
	for (int i=1; i<=n; i++)
	{
		while (l<=r && h[i]<=h[q[r]]) r--;
		q[++r]=i;
		while (l<=r && i-q[l]>=x) l++;
		if (i>=x) a[i-x+1]=h[q[l]];
	}
	/*
	for (int i=1; i<=n; i++)
	{
		cout<<a[i]<<" ";
	}
	*/
	
	memset(q,0,sizeof(q)); l=1,r=0;
	
	//对a的单调递增队列
	for (int i=1; i<=n; i++)
	{
		while (l<=r && a[i]>=a[q[r]]) r--;
		q[++r]=i;
		while (l<=r && i-q[l]>=x) l++;
		ans[i]=a[q[l]];
	}
	/*
	for (int i=1; i<=n; i++)
	{
		cout<<ans[i]<<" ";
	}
	*/
	
	for (int i=1; i<=n; i++)
	{
		sum+=h[i]-ans[i];
		if (ans[i]!=ans[i-1] || i-lastn>=x)
		{
			lasth=ans[i];
			lastn=i;
			cnt++;
		}
	}
	cout<<sum<<endl<<cnt;
	return 0;
}
```
[$\text{AC 记录}$](https://www.luogu.com.cn/record/132360655)

---


# DLS 采花

## 题目背景

超水的签到题

## 题目描述

DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。

DLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。  
但 DLS 采花又有一个癖好：他会从左往右采花。  
若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。

现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。  
由于答案会比较大，请对 $998244353$ 取模。

## 说明/提示

|数据百分比|限制|
|-|-|
|$50\%$|$N \le 9$|
|$80\%$|$N \le 1000$|
|$100\%$|$N \le 10^5,a_i \le 10^5$|

## 样例 #1

### 输入

```
4
2 3 6 3
```

### 输出

```
156```

# 题解

## 作者：LZDQ (赞：58)

看完求点赞，我每看一篇不管好不好都点赞的

我看没人写，自己随便写一点吧

这题其实很像小学奥数

简化题目：对于每个花田，只要求有多少种情况这个花田会被采到。

也就是说，**这个花田前面不能有它的因子，求排列总数。**

------------

首先我们考虑的是，一个花田有多少个因子。

排列时，这个花田必须排在所有它的因子前面，剩下不是它的因子的数，随便排

小学奥数闪亮登场

先看看一组自己的数据

```
6
1 1 2 2 2 3
```

我们只考虑3的排列

根据小学奥数，先把3和两个1排好

```
3 1 1
```

当然，两个1的位置可以随意排列，先把方案数乘 $2!$

接着把剩下的三个数，三个2随意在这些空位放

第一个2，可以放在以下位置：
```
_ 3 _ 1 _ 1 _
```

方案数乘4

第二个2有5个位置可以放，方案数乘5

以此类推

注意最后会乘到 n ，我比赛的时候没发现结果还绕弯路打 st 表，不过还是过了

有人会问，要不要乘 $3!$

不用，因为已经是随便排的了

------------

细节问题

求一个花田在其他花田中有多少个因子

这里不能用 $O(n^2)$ 的暴力，必须优化

我们可以用桶排，从小到大枚举，枚举到一个数就把它的倍数用另一个桶表示

复杂度 $O(10^5*(1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+...+\frac{1}{10^5}))$

用 cnta 数组表示花田为 i 的数量（这句话看不懂可以看代码）

```cpp
for(int i=1;i<=n;i++){
	int a;  //花的数量
	scanf("%d",&a);  //读入
    cnta[a]++;  //桶排
}
```

接着，用 cntb 数组表示这个数有多少个因子

```cpp
for(int i=1;i<=1e5;i++)  //枚举桶
	if(cnta[i]){      //如果有这个数
		for(int j=i;j<=1e5;j+=i)  //枚举倍数
			cntb[j]+=cnta[i];  //这段代码看这里
	}
```

然后，if 语句后面有大括号，就是求解过程

注意 cntb 那里 i 也是算了的，因为可能有多个相同的数，比如样例中有两个3。这是为了数组表意更明确，因子也包括自己

已知一个数有 x 个因子，方案数为：

$(x-1)! * \frac{n!}{x!}$

变成 $\frac{n!}{x}$ 这里要注意，有取模，所以我们不能把 $n!$ 存下来再除以 x

其实刚才那个已经可以 $O(1)$ 求解了

用一个数组表示 $i!$，另一个数组表示 $\frac{n!}{i!}$

这两个东西都是 $O(n)$ 预处理的

于是这题就到此为止了

代码

```cpp
#include<cstdio>
const int MAXN=1e5+5,MOD=998244353;
int n;
int f1[MAXN],f2[MAXN];
int cnta[MAXN],cntb[MAXN];
int ans;
int main(){
    scanf("%d",&n);
    f1[0]=1;
    for(int i=1;i<=n;i++)
        f1[i]=1ll*f1[i-1]*i%MOD;
    f2[n+1]=1;
    for(int i=n;i>0;i--)
        f2[i]=1ll*f2[i+1]*i%MOD;
    for(int i=1;i<=n;i++){
        int a;
        scanf("%d",&a);
        cnta[a]++;
    }
    for(int i=1;i<=1e5;i++)
        if(cnta[i]){
            for(int j=i;j<=1e5;j+=i)
                cntb[j]+=cnta[i];
            ans=(ans+1ll*i*cnta[i]%MOD*f1[cntb[i]-1]%MOD*f2[cntb[i]+1]%MOD)%MOD;
        }
    printf("%d\n",ans);
    return 0;
}
```

话说这是“超水的签到题”吗，还有紫题啊，我这个初一的蒟蒻还能做出来，不可思议！

看完博客记得点赞啊，我每看一篇都点的

---

## 作者：一扶苏一 (赞：12)

## Description

DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。

DLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。
但 DLS 采花又有一个癖好：他会从左往右采花。
若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。

现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。
由于答案会比较大，请对 $998244353$ 取模。

## Input

第一行是一个整数 $N$

下面一行 $N$ 个整数代表这个序列

## Output

输出答案对 $998244353$ 取膜的结果

## Hint

$for~50~percents:N~\leq~9$

$for~80~percent:N~\leq~1000$

$forall:1~\leq~N~\leq~10^5,1~\leq~10^5$

## Solution

感觉所有的题解都没有写部分分和式子是怎么用数学方法推出来的啊qwq

考虑前50分，直接枚举全排列检验，时间复杂度 $O(n!~\times~n^2)$，期望得分50pts。

考虑前80的数据，我们发现问题等价于求$\sum_{i = 1}^n a_i ~ \times~\text{序列中所有}a_i\text{的因数都在}a_i\text{的后面的方案数}$。问题转化为如何求出方案数。

对于每个 $a_i$，我们考虑枚举他在产生贡献方案中的位置。设 $a_i$ 除去他自身共有 $k$ 个因数在序列中。

当 $a_i$ 放在倒数第 $k + 1$ 位置上时，后面 $k$ 个因数随便放，前面的所有数字随便放，所以方案数为 $k!~\times~(n - k - 1)!$

当 $a_i$ 放在倒数第 $k + 2$ 位置上时，后面 $k$ 个因数和随便一个非因数随便放，前面剩下的数字随便放。由于非因数是随便选的，所以方案数为 $(k +  1)!~\times~(n - k - 2)!~\times~C_{n - k - 1}^{1}$

当 $a_i$ 放在倒数第 $k + 3$ 位置上时，后面 $k$ 个因数和随便两个非因数随便放，前面剩下的数字随便放。由于非因数是随便选的，所以方案数为 $(k +  2)!~\times~(n - k - 3)!~\times~C_{n - k - 1}^{2}$

~~一位读者砸烂了复读机停止了复读~~

依此做数学归纳，可得答案即为

$$\sum_{i = k}^{n - 1} i!~\times~(n - i + 1)!~\times~C_{n - k - 1}^{i - k}$$

相当于枚举 $a_i$ 在倒数第 $i + 1$ 位时的答案。

发现这个式子sigma后面可以在预处理阶乘和逆元后 $O(1)$ 计算，整个sigma可以 $O(n)$ 计算，一共算 $n$ 次，于是总复杂度 $O(n^2)$，期望得分80pts。

考虑全部的数据，我们发现上面先枚举 $a_i$ 的位置再枚举因数怎么放的多余的，可以直接把他们放在一起枚举：我们在一个序列中选择 $(k + 1)$ 个位置，其中第一个位置放 $a_i$，其他位置放因数，剩下的位置随便放，于是答案即为

$$C_{n}^{k + 1}~\times~k!~\times~(n - k - 1)!$$

这个式子在预处理后可以 $O(1)$ 计算，于是算上求因数后总复杂度 $O(n~\sqrt a)$，期望得分100pts。

## Code

```cpp
#include <cstdio>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#define printtime()
#else
#include <ctime>
#define printtime() printf("Times used  = %ld ms\n", clock())
#endif
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;	
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	int top=0;
	do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 100010;
const int MOD = 998244353;

int n;
int MU[maxn], bk[maxn];
ll ans;
ll fact[maxn], inv[maxn], finv[maxn];

ll C(int, int);

int main() {
	freopen("1.in", "r", stdin);
	qr(n);
	for (int i = 1; i <= n; ++i) {
		qr(MU[i]); ++bk[MU[i]];
	}
	fact[0] = finv[0] = inv[1] = 1;
	for (int i = 2; i <= n; ++i) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
	for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;
	for (int i = 1; i <= n; ++i) {
		int _cnt = 0;
		int j;
		for (j = 1; (j * j) < MU[i]; ++j) if (!(MU[i] % j)) _cnt += bk[j] + bk[MU[i] / j];
		if ((j * j) == MU[i]) _cnt += bk[j];
		--_cnt;
		ans = (ans + C(n, _cnt + 1) * fact[_cnt] % MOD * fact[n - _cnt - 1] % MOD * MU[i]) % MOD;
	}
	qw((ans + MOD) % MOD, '\n', true);
	printtime();
}

ll C(int x, int y) {
	return fact[x] * finv[y] % MOD * finv[x - y] % MOD;
}

```



---

## 作者：ycyaw (赞：3)

显然每个数的贡献可以单独算，即这个数的值$\times$方案数。

现在的问题就是，对于一个数，有多少种排列，使得它的因子不在它之前。我们不需要知道因子的值，只需要知道个数，设为$x$。

方案特别好算，考虑算上它本身的$x+1$个数，先随便在数列中放，方案为$C_n^{x+1}$，考虑$x+1$个数中，它本身要放最前面，剩下$x$个随便放，即$x!$，考虑剩下的$n-x-1$个数随便放，方案为$(n-x-1)!$。

所以对于一个数，贡献为$a[i]\times C_n^{x+1}\times x!\times (n-x-1)!$。

预处理阶乘逆元即可。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
#define mo 998244353
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int N=100005;
int n,a[N],tong[N],gs[N],inv[N],jc[N],ans;
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
void part(int id,int x){
    for(int i=1;i*i<=x;i++){
        if(x%i==0){
            gs[id]+=tong[i];
            if(i*i!=x) gs[id]+=tong[x/i];
        }
    }
    gs[id]--;
}
int ksm(int x,int y){
    int res=1;
    while(y){
        if(y&1) res=res*x%mo;
        y>>=1;
        x=x*x%mo;
    }
    return res;
}
int C(int x,int y){
    return jc[x]*inv[y]%mo*inv[x-y]%mo;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) a[i]=read(),tong[a[i]]++;
    for(int i=1;i<=n;i++) part(i,a[i]);
    jc[0]=1;
    for(int i=1;i<=n;i++) jc[i]=jc[i-1]*i%mo;
    inv[n]=ksm(jc[n],mo-2);
    for(int i=n-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mo;
    for(int i=1;i<=n;i++) ans=(ans+C(n,gs[i]+1)*jc[gs[i]]%mo*jc[n-gs[i]-1]%mo*a[i]%mo)%mo;
    write(ans);
    return 0;
}
```


---

## 作者：Weng_Weijie (赞：3)

考虑每个花田在多少个方案中被采

那么是这个花田的因子都必须在它的右边

假如有 $k$ 个是它的因子（不包括自己），根据除法原理，方案数为 $\dfrac{n!}{k+1}$

因此答案为 $\displaystyle\sum_{i=1}^na_i\cdot \dfrac{n!}{\mathrm{cnt}_{a_i}}$

$\mathrm{cnt}_k$ 表示有多少个 $a_i$ 是 $k$ 的因子

求 $\mathrm{cnt}$ 可以用一种叫 $\mathrm{Dirichlet \space Partial\space Sum}$ 的黑科技，可以将复杂度优化至 $O(n\log\log n)$ ~~但是常数巨大~~，具体看代码

因此总时间复杂度为 $O(n\log\log n)$

```cpp
#include <iostream>

const int mod = 998244353;
const int N = 100005;
using LL = long long;
int cnt[N], a[N], pr[N], pt, md[N], ans, n, inv[N];
void sieve() {
	for (int i = 2; i < N; ++i) {
		if (!md[i]) md[i] = i, pr[++pt] = i;
		for (int j = 1; j <= pt && pr[j] <= md[i]; ++j) {
			int t = i * pr[j]; if (t >= N) break;
			md[t] = pr[j];
		}
	}
}
void DPS(int *A) { // Dirichlet Partial Sum
	for (int i = 1; i <= pt; ++i)
		for (int j = 1, t = pr[i]; t < N; ++j, t += pr[i])
			A[t] += A[j];
}
void reduce(int &x) {
	x += x >> 31 & mod;
}
int main() {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> n, sieve();
	for (int i = 0; i < n; ++i)
		std::cin >> a[i], ++cnt[a[i]];
	DPS(cnt);
	inv[1] = 1;
	for (int i = 2; i <= n; ++i)
		inv[i] = (LL) (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 0; i < n; ++i)
		reduce(ans += (LL) a[i] * inv[cnt[a[i]]] % mod - mod);
	for (int i = 2; i <= n; ++i)
		ans = (LL) ans * i % mod;
	std::cout << ans << std::endl;
	return 0;
}

```

---

## 作者：传奇666666 (赞：3)

由于没看到有题解，于是本蒟蒻就来水一篇，希望能对大家有所启示。

首先，看一眼数据范围，有50%的数据N<=9，于是出现了50分做法，直接枚举全部排列方法得到最终答案。

但显然，这无法满足后两档的需求，所以简单一看，这大约得用一个接近O(n)复杂度的算法来解决。所以，就开始推式子。

首先，需要先看出来一点，及对于每个数，那些其他的数是它的约数完全不重要，我们只需要统计在整个数列中有多少个它的约数即可。所以，我们可以使用类似于筛法的方式来统计个数：

```c++
for(int j=num[i];j<=100000;j+=num[i])
	tong_ji[j]++;
//tong_ji就是统计，num[i]表示第i个田里花的个数。
```

这只是第一步，下面才是正菜。我们同样无需知道每个排列长成什么样子，我们只需要知道每块田会被采多少次即可。

显然，只要有一块花数为它约数的田在它之前就完蛋了。所以，我们就找出所有在它之前不含它约数的排列数即可。所以，依次枚举出在它前面的田的数量并用排列数的计算公式A(n,m)=n!/(n-m)!，算出结果。同时，在每步枚举时，还需要算出它之后的方案数，即(N-m-1)!，N为总田数。根据乘法原理，相乘；再根据加法原理相加即可。

但由于除法运算不支持一边除一边取余，所以用前缀和维护即可。

相当丑的考试时代码
```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const long long mo=998244353;
int n,num[100005];
int tong[100005];
long long ans;
long long qwq[100005];
long long sum2[100005];
long long sum3[100005];
long long A(int k)
{
    if(qwq[k])
        return qwq[k];
    long long res=0;
    sum3[0]=1;
    for(int i=k;i>=1;i--)
        sum3[k-i+1]=sum3[k-i]*i,sum3[k-i+1]%=mo;
    for(int i=0;i<=k;i++)
        res+=(sum3[i]*sum2[n-i-1]),res%=mo;
    qwq[k]=res;
    return res;
}
int main()
{
    scanf("%d",&n);sum2[0]=1;
    for(int i=1;i<=n;i++)
        scanf("%d",&num[i]);
    for(int i=1;i<=n;i++)
        for(int j=num[i];j<=100000;j+=num[i])
            ++tong[j];
    for(int i=1;i<=n;i++)
        sum2[i]=sum2[i-1]*i,sum2[i]%=mo;
    for(int i=1;i<=n;i++)
    {
        ans+=(num[i]*A(n-tong[num[i]]));
        ans%=mo;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Drinkkk (赞：2)

## 题目描述

DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。

DLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。
但 DLS 采花又有一个癖好：他会从左往右采花。
若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。

现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。
由于答案会比较大，请对 $998244353$ 取模。

## 输入输出格式

- 输入格式

第一行一个正整数 $N$。
第二行是一个长度为 $N$ 的序列 $a$。

- 输出格式
共一行，表示所有方案中采花的数量和对 $998244353$ 取模的结果。

### 输入输出样例

```
Input:
4
2 3 6 3
Output:
156
```

## 数据百分比限制

$50\%,N \le 9$。

$80\%,N \le 1000$。

$100\%,N \le 10^5$。

## 题解

一个数 $a_i$ 能够产生贡献当且仅当它的因子都在它的后面，因为如果我们设 $a_i$ 在 $a_1$ 到 $a_n$ 中有 $k$ 个是 $a_i$ 的因子的话（不包括它自己），那么它对答案的贡献就是： $$a_i\;\times\;C_{n}^{k+1}\;\times\;k!\;\times\;(n-x-1)!$$

因为 $C_{n}^{m}=\dfrac{n!}{m!(n-m)!}$ ，但是因为 $n!$ 和 $m!(n-m)!$ 都很大，而且不能够提前把分子和分母给取膜。

因为我们就可以想到用费马小定理来求解。

$$\dfrac{a}{b}\;mod\;p=(a\;\times\;b^{p-2})\;mod\;p(p\;is\;prime)$$

然后我们就可以把这个式子换成：

$$a_i\;\times\;n!\;\times\;[m!(n-m)!]^{998244351}\;\times\;k!\;\times\;(n-x-1)!$$

但是要注意多取膜。这里说一下，可以把 $(a\;\times\;b)^p$ 给拆成 $a^p\;\times\;b^p$ 。

然后这道题目就可以完美解决啦！

## 参考代码

```
#include <cstdio>
#define mod 998244353LL
long long a[1000001],bj[1000001],f[1000001];
long long max(long long x,long long y)
{
	return x>y?x:y;
}
void px(long long l,long long r)
{
	long long x=l,y=r,mid=a[(l+r)/2];
	while(x<=y)
	{
		while(a[x]<mid)
		{
			x++;
		}
		while(a[y]>mid)
		{
			y--;
		}
		if(x<=y)
		{
			long long t=a[x];
			a[x]=a[y];
			a[y]=t;
			x++;
			y--;
		}
	}
	if(l<y)
	{
		px(l,y);
	}
	if(x<r)
	{
		px(x,r);
	}
}
long long pow(long long x,long long y)
{
	if(y==0)
	{
		return 1;
	}
	else
	{
		long long dq=pow(x,y/2);
		if(y%2==1)
		{
			return (((dq*dq)%mod)*x)%mod;
		}
		else
		{
			return (dq*dq)%mod;
		}
	}
}
long long C(long long n,long long m)
{
	return ( ( f[n] ) * pow( f[m] , mod-2 ) %mod * pow(f[n-m] , mod-2 ) % mod )% mod;
}
int main()
{
	long long ans=0,n=0,r=0;
	scanf("%lld",&n);
	f[0]=1;
	for(long long i=1;i<=n+1;i++)
	{
		f[i]=f[i-1]*i;
		f[i]%=mod;
	}
	for(long long i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		r=max(r,a[i]);
	}
	px(1,n);
	for(long long i=1;i<=n;i++)
	{
		for(long long j=1;j*a[i]<=r;j++)
		{
			bj[j*a[i]]++;
		}
	}
	a[0]=999999999;
	for(long long i=1;i<=n;i++)
	{
		if(a[i]!=a[i-1])
		{
			bj[a[i]]--;
		}
	}
	for(long long i=1;i<=n;i++)
	{
		long long x=bj[a[i]];
		ans+=(((((a[i]*C(n,x+1))%mod)*f[x])%mod)*f[n-x-1])%mod;
		ans%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：米奇 (赞：1)

## 题解：

考虑算每个数对答案的贡献。

第i个数的有贡献，当且仅当第i个数的约数出现在它后面。

假设第i个数有x个约数，那么有贡献的概率就是$1/(x+1)$，有贡献的方案数就是总方案数$\times $概率。

为什么是$1/(x+1)$呢?有$x+1$个数，要选出那个数放在最前面，当然是$1/(x+1)$。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define next Next
#define last Last
#define int long long
const int N=1e6+5;
const int mod=998244353;
int n,ans,a[N],b[N],gs[N];
/*char buf[1<<21],*p1=buf,*p2=buf;
inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/
#define gc getchar
inline int read()
{
	int ret=0,f=0;char c=gc();
	while(!isdigit(c)){if(c=='-')f=1;c=gc();}
	while(isdigit(c)){ret=ret*10+c-48;c=gc();}
	if(f)return -ret;return ret;
}
int kuai(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1)res=res*a%mod;
		b=b/2;
		a=a*a%mod;
	}
	return res;
}
signed main()
{
	n=read();
	int jc=1;
	for(int i=1;i<=n;i++)jc=jc*i%mod;
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		b[a[i]]++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j*j<=a[i];j++)
			if(a[i]%j==0)
			{
				gs[i]+=b[j];
				if(j*j!=a[i])gs[i]+=b[a[i]/j];
			}
		ans=(ans+jc*kuai(gs[i],mod-2)%mod*a[i]%mod)%mod;
	}
	cout<<ans;
}
```

---

## 作者：K_J_M (赞：0)

## 题目描述

DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。

DLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。  
但 DLS 采花又有一个癖好：他会从左往右采花。  
若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。

现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。  
由于答案会比较大，请对 $998244353$ 取模。
## Solution
考虑计算每一个数的贡献。

首先对于每一个数 $a_i$ 计算出它有多少个因子是原序列中的数，记个数为 $n_i$。

现在有一个 80pts 做法，首先枚举每一个数 $a_i$，在枚举它放在 $j$ 为位置上的贡献。此时它要有贡献，那么它的前 $j-1$ 个位置上都没有它的因子，也就是让 $n-1-n_i$ 个不是 $a_i$ 因子的数填满 $1\sim j-1$ 之后再随便排列就行了。

总贡献为：
$$\sum_{i=1}^{n}\sum_{j=1}^{n-n_i}A_{n-1-n_i}^{j-1}\times (n-j)!\times a_i$$
时间复杂度为 $\mathcal O(n^2)$。

下面来讲正解。

我们可以将 $a_i$ 和它的 $n_i$ 个因子看成一个整体，我们只需要在这个 $1+n_i$ 长度的序列中让 $a_i$ 放第一位，然后其它因子随便排即可。此时我们的总贡献为：
$$\sum_{i=1}^{n}{n \choose n_i+1}\times n_i!\times (n-1-n_i)!$$
时间复杂度 $\mathcal O(n)$。\
[Ac Code](https://www.luogu.com.cn/paste/wsbbe9f5)

---

## 作者：TianTian2008 (赞：0)

很简单的计数题。

直接考虑 $a_i(1\leqslant i\leqslant n)$ 对答案的贡献，显然是 $a_i\times f_{a_i}$，其中 $f_{a_i}$ 表示有多少种 $a$ 的排列满足在 $a_i$ 之前没有出现过 $a_i$ 的因数。

如何计算 $f_{i}$ 呢？我们记 $d_{i}$ 表示 $a$ 中有多少个数是 $i$ 的因数。那么 $f_{i}=\binom{n}{d_i}\times(d_i-1)!\times(n-d_i)!$，先选出 $d_i$ 个位置放 $i$ 的因数即 $\binom n{d_i}$，令这些位置的第一个是 $i$ 后面的随意排列即 $(d_i-1)!$，剩余的数不会产生影响因此随意排列即 $(n-d_i)!$。

时间复杂度 $O(n\log_2n)$，瓶颈在于计算 $d_i$。

```cpp
#include <iostream>
#include <cstdio>
#define mod 998244353
using namespace std;
typedef long long ll;
ll n,fac[100001],inv[100001],a[100001],tn[100001],dv[100001],ans;
ll ksm(ll x,ll y) {
	ll res=1;
	while(y) {
		if(y&1) res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
inline ll binom(ll n,ll m) {
	return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
int main() {
	scanf("%lld",&n);
	fac[0]=1;
	for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
	inv[n]=ksm(fac[n],mod-2);
	for(int i=n;i>=1;--i) inv[i-1]=inv[i]*i%mod;
	for(int i=1;i<=n;++i) {
		scanf("%lld",&a[i]);
		++tn[a[i]];
	}
	for(int i=1;i<=100000;++i)
		for(int j=i;j<=100000;j+=i) dv[j]+=tn[i];
	for(int i=1;i<=n;++i) {
		ll x=a[i];
		ans=(ans+x*binom(n,dv[x])%mod*fac[dv[x]-1]%mod*fac[n-dv[x]])%mod;
	}
	printf("%lld",ans);
	return 0;
}
```

---


# [JSOI2013] 丢番图

## 题目背景

丢番图是亚历山大时期埃及著名的数学家。他是最早研究整数系数不定方程的数学家之一。

为了纪念他，这些方程一般被称作丢番图方程。最著名的丢番图方程之一是

$$x^n+y^n=z^n$$

费马提出，对于 $n>2$, $x,y,z$ 没有正整数解。这被称为“费马大定理”，它的证明直到最近才被安德鲁·怀尔斯（AndrewWiles）证明。

## 题目描述

考虑如下的丢番图方程：

$$\frac{1}{x}~+~\frac{1}{y}~=~\frac{1}{n}~,(x,y,n~\in~N^+)$$

小G对下面这个问题十分感兴趣：对于一个给定的正整数 $n$，有多少种本质不同的解满足上面的方程？例如 $n=4$，有三种本质不同 ($x~\leq~y$)的解：

> $\frac{1}{5}+\frac{1}{20}~=~\frac{1}{4}$
>
> $\frac{1}{6}+\frac{1}{12}~=~\frac{1}{4}$
>
> $\frac{1}{8}+\frac{1}{8}~=~\frac{1}{4}$

显然，对于更大的 $n$，没有意义去列举所有本质不同的解。你能否帮助小G快速地求出对于给定 $n$，满足上面方程的本质不同的解的个数？

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1\leq n \leq 10^{14}$。

## 样例 #1

### 输入

```
4```

### 输出

```
3```

# 题解

## 作者：Dry_ice (赞：31)

upd 20210508：感谢 @SegmentTreeJuruo 关于一处符号的指正，现已修改。

> 一看到丢番图就想到那个年龄故事。

这道题是一道**简单数学推柿子**题，个人认为难度大约$\color{green}{\text{绿}}$到$\color{blue}{\text{蓝}}$。


## 大致思路
开启推柿子模式：

$$\frac{1}{x}+\frac{1}{y}=\frac{1}{n}$$
$$yn+xn=xy$$
$$xy-xn-yn=0$$
$$xy-xn-yn+n^2=n^2$$
$$(x-n)(y-n)=n^2$$

综上，满足 $\frac{1}{x}+\frac{1}{y}=\frac{1}{n}$ 便可转化为不含分式的 $(x-n)(y-n)=n^2$。这样的话，只需要算出 $n^2$ 大于 $n$ 的因子即 $n$ 的因子即可。我们这时立刻想到了分解质因数，根据因数数量公式就可以把最终满足条件的个数算出来。

最后端上香喷喷的代码！

## CODE
```cpp
#include <stdio.h>
long long n;
int main(void) {
    scanf("%lld", &n);
    long long ans = 1ll;
    for (long long i = 2ll; i * i <= n; ++i)
        if (n % i == 0) {
            long long k = 0ll;
            while (1) {
                if (n % i != 0ll)
                    break;
                n /= i;
                ++k;
            }
            ans *= (k << 1ll) + 1ll;
        }
    if (n > 1)
        ans *= 3;
    printf("%lld\n", (ans + 1) >> 1ll);
    return 0;
}
```

到这里这篇题解就结束了。如果您觉得还珂以，就顶一下（给个赞）呗！谢谢大家！

---

## 作者：在下互质数 (赞：9)

### 看见我们学校的几位dalao都发了题解，所以我也发一下，我的小方法。
$\frac 1x+\frac 1y=\frac 1n\ $

### 接着又简化为

$ (x-n)(y-n)=n^2$
### 有了代码，如下：
```cpp
# include <bits/stdc++.h>
int main ()
{
    long long n , i , sum = 1 , tot ;
    scanf ("%lld" , &n) ;
    for(i = 2 ; i * i <= n ; i ++ )
    {
        if(n % i == 0)   //分解质因数
        {
            tot = 0;
            while (n % i == 0) n /= i , tot ++ ;
            sum *= 2 * tot + 1 ; //质因子的幂次*2即为n2中的幂次，再+1乘起来即可得到n2的约数个数。
        }
    }
    if (n != 1) sum *= 3 ;   
    printf ("%lld\n" , (sum + 1) >> 1) ;  //去重
    return 0 ;
}
```


---

## 作者：信息向阳花木 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P5253)
### 简化题意
 
方程式 $\frac{1}{x} + \frac{1}{y} = \frac{1}{n}$： 
 
给定 $n$，求本质不同的整数解的数量。

### 解析推算 1

  $\frac{1}{x} + \frac{1}{y} = \frac{1}{n}$，本质不同，那么我们只算 $x \leq y$ 的情况。
  
 需要明白：
 
 * 若 $x \leq y$，那么 $z < x \leq 2z$
 
 原因很简单，自己稍微想一想就行了。~~想不出来补数学去。~~
 
 接下来推算公式：
  
  $\frac{1}{x} + \frac{1}{y} = \frac{1}{n}$
  
  $\frac{1}{y} = \frac{1}{n} - \frac{1}{x}$
  
  $\frac{1}{y} = \frac{x-z}{zx}$
  
  $y = \frac{zx}{x-z}$
  
  处理到这里，我们发现最后一个式子 $y = \frac{zx}{x-z}$ 是多项式，不好处理，那么我们设：$k = x - z$。（$k$ 的范围：$0<k\leq z$）接着我们就能得到 $x = k + z$，于是我们成功地把 $x$ 代替掉了：$y = \frac{z(k+z)}{k}$。
  
  有了这个，我们继续推：
  
  $y = \frac{z(k+z)}{k}$
  
  $y = \frac{zk+z^2}{k}$
  
  $y = z + \frac{z^2}{k}$
  
  由于要求整数的解，$x$，$y$，$z$都要是整数。又由于 $y = z + \frac{z^2}{k}$，$z$ 是整数，所以 $\frac{z^2}{k}$ 要是整数，也就是说 $k \mid z^2$（平易近人地说就是 $z^2$ 除以 $k$ 没有余数）。
  
前面说：$k$ 的范围：$0<k\leq z$，问题转化为：

* $z^2$ 有多少个范围在 $0- z$ 的约数？

于是我们怎么求这个问题呢？还要用到唯一分解定理。


------------
### 解析推算 2

~~啊啊啊，好麻烦！~~
我认为题目应该变为蓝题。

现在，我们再把问题放一遍：

* $z^2$ 有多少个范围在 $0- z$ 的约数？

好了，我们假设：$z = {p_1}^{a_1}\times{p_2}^{a_2}\times {p_3}^{a_3}...\times{p_n}^{a_n}$

那么 $z^2$ 就是：$z^2 = {p_1}^{2a_1}\times{p_2}^{2a_2}\times {p_3}^{2a_3}...\times{p_n}^{2a_n}$

那么，$z^2$ 的约数个数为：（$2a_1+1$）$\times$ （$2a_2+1$）$\times$ （$2a_3+1$）$\times$ ...$\times$（$2a_n+1$）。

这个式子，除了智商上的 xxs 应该都能看懂，我，不多说了，题解篇幅已经很长了。

然后，题目又转化为对 $z^2$ 分解质因数求指数，指数求完根据唯一分解定理求约数个数。

### 最后的处理


设 $ans$ 表示 $z^2$ 有多少个约数，那么输出应为：

 $\frac{(ans+1)}{2}$。（或者说是 $\lceil\frac{(ans)}{2}\rceil$）
 
 原因很简单，因为约数又范围限制。每次求约束时，每有一个 $<z$ 的约数，就有一个 $>z$ 的约数，但还要包括 $z$ $\times$ $z$ = $z^2$，再 $ans$ 中，$z$ 这个约数只算一次，而别的约数都有配套才除以 $2$ ，所以我们把 $z$ 看作两个约数，这样约数个数是 $ans+1$，所以是真正的答案是  $\frac{(ans+1)}{2}$。
 
------------

### Code
```cpp
#include <iostream>
#include <cmath>
using namespace std;
long long n;
int m,ans=1,x,y;
int main(){
	cin>>n;
	int m=(int)(sqrt(n));
	for(int i=2;i<=m;i++){
		int k=0;
		while(n%i==0){n/=i;k++;}
		ans*=(2*k+1); //z^2 的约数个数
	}
	if(n>m) ans*=3;
	printf("%d",(int)(ans+1)/2);
	
	return 0;
}
```


---

## 作者：_•́へ•́╬_ (赞：4)

## 第一种思路

#### 推导第一个式子：
$$
{1\over a}+{1\over b}={1\over n}
$$

$$
{a+b\over ab}={1\over n}
$$

$$
n(a+b)=ab
$$

$$
na+nb=ab
$$

$$
na-ab+nb=0
$$

$$
a(n-b)+nb=0
$$

$$
-a(n-b)-nb=0
$$

$$
-a(n-b)+n(n-b)-n(n-b)-nb=0
$$

$$
(n-a)(n-b)-n^2+nb-nb=0
$$

$$
(n-a)(n-b)=n^2
$$

#### $(n-a)(n-b)=n^2$ 就是第一个重要式子。

分解 $n$ 的质因数，次数 $\times 2$ 即得 $n^2$ 的质因数。

从式子看出：$n^2$ 小于 $n$ 的因数的个数就是答案（因为求本质不同的个数，所以强制 $n-a<n-b$。

也就是 $\huge\left\lfloor{n^2\texttt{的因数的个数}\over 2}\right\rfloor$。

#### 推导第二个式子：

$$
\texttt{设}n^2=p_1^{a_1}p_2^{a_2}\cdots p_x^{a_x}
$$

$$
\texttt{设}n\texttt{的因数}m=p_1^{b_1}p_2^{b_2}\cdots p_x^{b_x}
$$

注：上面的 $p_1,p_2,\cdots,p_x$ 都是质数，[唯一分解定理](http://baidu.physton.com/?q=%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86)告诉我们 $n^2\texttt{和}m$ 都有且仅有一种分解法。
$$
\because m\texttt{是}n^2\texttt{的因数}
$$

$$
\therefore 0\leq b_i\leq a_i(i=1,2,\cdots,x)
$$

$$
\therefore m\texttt{有}\sum \limits_{i=1}^{x}(a_i+1)\texttt{取法，使}m\texttt{是}n^2\texttt{的因数}
$$

$$
\texttt{用OIer的语言写上面的那个式子：}\color{white}\texttt{看不见我看不见我看不见我看不见我看不见我}
$$

$$
(a_1+1)(a_2+1)\cdots(a_x+1)
$$

#### $(a_1+1)(a_2+1)\cdots(a_x+1)$ 就是第二个重要式子。

有了第二个式子，求出 $n^2\texttt{的因数的个数}$ 就不费劲了，只用一个分解质因数。

算出来再除以 $2$ 就行了。

由于上面强制 $n-a<n-b$ 时漏了 $a=b$，所以除了之后还要 $+1$。

## 第二种思路

注：推导的结果和代码和第一种思路一样。
$$
\frac{1}{a}+\frac{1}{b}=\frac{1}{n}
$$

$$
\frac{1}{a}=\frac{1}{n}-\frac{1}{b}
$$

$$
\frac{1}{a}=\frac{b-n}{nb}
$$

$$
a=\frac{nb}{b-n}
$$

$$
\texttt{设}k=b-n
$$

$$
a=\frac{n(n+k)}{k}
$$

$$
a=\frac{n^2+nk}{k}
$$

$$
a=n+\frac{n^2}{k}
$$

$$
\because a,n,k\texttt{均为整数}
$$

$$
\therefore k|n^2
$$

显然 $a,b$ 一一对应，所以 $a,k$ 一一对应，所以 $k$ 的个数就是答案。

由于本质不同，所以限制 $a<b$。所以 $n<a<2n<b$。所以 $n<b-n=k$。

而 $k|n^2$，所以统计 $k$ 的个数很简单，就是 $n^2$ 大于 $n$ 的因数个数。有一个性质：$x$ 大于 $\sqrt x$ 的因数的个数 $=$ $x$ 小于 $\sqrt x$ 的因数的个数，即因数的对称性。所以答案和第一种思路中的一样。

如果在第二步把式子化为 $\frac{1}{b}=\frac{1}{n}-\frac{1}{a}$，设 $k=a-n$，那么 $k$ 的个数是 $n^2$ 小于 $n$ 的因数个数，其实也是一样的。

## $code$

```cpp
#include<stdio.h>
long long n,ans=1;
main()
{
	scanf("%lld",&n);//输入
	for(register long long i=2;i*i<=n;++i)if(!(n%i))
	{
		register int cnt=0;
		for(;!(n%i);n/=i,++cnt);//分解出i并统计cnt
		cnt<<=1;//我们要分解n的平方，所以次数乘2
		ans*=cnt+1;//用第二个重要式子
	}
	if(n>1)ans*=2+1;//n是一个大质数
	ans>>=1;//算出来再除以2
	printf("%lld",ans+1);//输出，答案+1
}/**/
```

upd on 2020.8.7：增加了第二种思路。

upd on 2020.8.8：修改了一下，更详细了。

---

## 作者：Warriors_Cat (赞：4)

~~紫题怎么这么多小学奥数题……~~

感谢由＠詹詹tv_詹詹 提供思路

题目说的就是：解

$$\frac{1}{x}+\frac{1}{y}=\frac{1}{n}$$

的整数解（已知$n$）

不妨设$x \le y$

由于x, y均为整数，那$n < x \le y$

令$x = n + n_1, y = n + n_2$

$\therefore$ 原方程可化为$\large{\frac{1}{n+n_1}+\frac{1}{n+n_2}}=\frac{1}{n}$

通分可得$\large{\frac{2n+n_1+n_2}{n^2+n_1n+n2_n+n_1n_2}=\frac{1}{n}}$

交叉相乘可得$n^2+n_1n+n_2n+n_1n_2=2n^2+n_1n+n_2n$

移项可得$\large{n^2=n_1n_2}$

然后直接分解质因数就好啦……

## Code:

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, ans = 1;
signed main(){
    cin >> n;
    for(int i = 2; i * i <= n; ++i){
        if(n % i == 0){
            int sum = 0;
            while(n % i == 0) sum++, n /= i;
            ans *= 2 * sum + 1;
        }
    }
    if(n > 1) ans *= 3;//多余的也要特判 qwq
    cout << (ans + 1) / 2;//记得除2 qwq
    return 0;
}
```
## End

---

## 作者：徐致远 (赞：4)

广告：[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/03/17/%E3%80%8CJSOI2013%E3%80%8D%E4%B8%A2%E7%95%AA%E5%9B%BE-Solution/)

挺好玩的一个数学题。

### 题解

首先来看看题目中给出的式子，看起来不是很好搞：
$$
\frac{1}{x}+\frac{1}{y}=\frac{1}{n}
$$
分式不好搞，所以先给它乘开：
$$
ny+nx=xy
$$
都移到一边：
$$
xy-nx-ny=0
$$
化为两式相乘的形式：
$$
(x-n)(y-n)=n^2
$$
不难发现，将$n^2$分解为任意两数相乘的形式时，都有唯一的$x,y$与之对应。

所以$n^2$的因子个数加一除以二就是答案。

但是$n^2$比较大，不好分解质因数。

但是$n$比较小，根据平方的性质，$n^2$的每一个质因子的个数等于$n$每一个质因子个数的两倍。

然后就好搞了。

### 代码

```cpp
#include<cstdio>
using namespace std;
typedef long long LL;
int cnt,p[665000],tot[665000];LL n,ans;bool vis[10000005];
inline void make_p()          //欧拉筛素数
{
	vis[0]=vis[1]=true;
	for(int i=2;i<=10000000;i++)
	{
		if(!vis[i]){cnt++;p[cnt]=i;}
		for(int j=1;j<=cnt&&p[j]*i<=10000000;j++) vis[p[j]*i]=true;
	}
}
inline void Solve()
{
	for(int i=1;i<=cnt;i++)
		while(n%p[i]==0)
			{n/=p[i];tot[i]++;}   //分解质因数
	if(n>1){cnt++;tot[cnt]=1;p[cnt]=n;}
	ans=1;
	for(int i=1;i<=cnt;i++) ans*=2*tot[i]+1;   //计算因子个数
	ans=(ans+1)/2;
}
int main()
{
	make_p();
	scanf("%lld",&n);
	Solve();
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：詹詹tv__詹詹 (赞：2)

### 嘿嘿，这是我第一次发题解，有点小激动。 
###     好吧，现在切入正题。这道题展开方式不只一种哦。
### 我发现目前的题解都只是其中的一种方法，所以我现在来讲第二种。
###  首先，很显然x > n , y > n,这样的话，我们把x设为n+m1，y设为n+m2，原式变为$\frac{1}{n+m1}+\frac{1}{n+m2}=\frac{1}{n}$
 
### 通个分后原式又会变成$\frac{2n+m1+m2}{(n+m1)*(n+m2)}=\frac{1}{n}$

### 使用比例的性质，将等式两边分子分母交叉相乘

$$2n^2+(m1+m2)*n=n^2+(m1+m2)*n+m1*m2$$

$$n^2=m1*m2$$

###             所以，本题即是求n*n有几个因数。
### 附上代码一份
### （第一次写题解，如果上面的LaTeX部分无法正常表示，那么就把frac后的第一个大括号中的数当作分子，第二个当作分母即可，请多多包涵）
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n;
	scanf("%lld", &n);
	long long ans=1;
	for(long long i=2;i*i<=n;i++){
		if(n%i==0){
			int z=0;
			while(n%i==0){
				n/=i;
				z++;
			}
			ans*=(2*z+1);
		}
	}
	if(n>1)ans*=3;
	printf("%lld", (ans + 1) >> 1);
	return 0;
}
```



$\frac{n}{m_1}$




---

## 作者：0x3F (赞：1)

分式方程怎么处理呢？当然化成整式方程！

$$\frac{1}{x} + \frac{1}{y} = \frac{1}{n} \implies yn + xn = xy$$

移项得：

$$xy - xn - yn = 0$$

这样的方程怎么解呢？

我们可以在其两边同时加上 $n^2$，再部分因式分解即可。

便化为了两整数之积为一个定值的问题。

得：

$$(x-n)(y-n)=n^2$$

此处~~显然~~ $x-n$ 和 $y-n$ 同为正数。

由于 $n^2$ 为定值，若 $x-n$ 为 $n^2$ 的一个因子，则 $y-n$ 必为 $n^2$ 的另一个因子。

所以解的数量即为 $n^2$ 的因子数。

但是因为 $x \leqslant y$，所以要去重。

由于除了 $x = y = 2n$ 以外所有解都是对称的，所以最终答案加 $1$ 再除以 $2$。

怎么求 $n^2$ 的因子数呢？

若 $n = p_1^{\alpha_1} \times p_2^{\alpha_2} \times \cdots \times p_k^{\alpha_k}$，则 $n^2 = p_1^{2\alpha_1} \times p_2^{2\alpha_2} \times \cdots \times p_k^{2\alpha_k}$。

所以 $\operatorname{d}(n^2) = (2\alpha_1+1)(2\alpha_2+1)\cdots(2\alpha_k+1)$。

最终答案即为：

$$\frac{(2\alpha_1+1)(2\alpha_2+1)\cdots(2\alpha_k+1)+1}{2}$$

只要别忘了开 $\texttt{long long}$ 就行了。

直接上代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, a = 1, t;
int main() {
	cin >> n;
	for (long long i = 2; i * i <= n; i++) {
		t = 1;
		while (n % i == 0) n /= i, t += 2;
		a *= t;
	}
	if (n != 1) a *= 3;
	cout << (a+1) / 2 << endl;
	return 0;
}
```

---

## 作者：da32s1da (赞：1)

$$\frac{1}{x}+\frac{1}{y}=\frac{1}{n}$$

$$xn+yn=xy$$

$$xy-xn-yn+n^2=n^2$$

$$(x-n)(y-n)=n^2$$

设$f(n)$为$n$的约数个数，则答案为$\lceil\frac{f(n^2)}{2}\rceil$

设$n=\prod_{i=1}^k a_i^{p_i}$，则$f(n)=\prod_{i=1}^k(p_i+1)$，故$f(n^2)=\prod_{i=1}^k(2p_i+1)$

```cpp
#include<cstdio>
typedef long long LL;
LL n,Ans,cnt;
int main(){
	scanf("%lld",&n);
	Ans=1;
	for(LL i=2;i*i<=n;i++)
	if(n%i==0){
		for(cnt=0;n%i==0;n/=i,cnt++);
		Ans*=(cnt*2+1);
	}
	if(n>1)Ans*=3;
	printf("%lld\n",(Ans+1)/2);
}
```

---

## 作者：胡金梁 (赞：0)

题意大概如下：

请问， $ \frac 1 x + \frac 1 y = \frac 1 n $ 这个式子中，如果给定 $n$ ，那么这个式子一共有多少组解。

这个问题不是很难，只用推导一下就出来了：
 $ \frac 1 x + \frac 1 y = \frac 1 n $ 
 
 $ yn + xn = xy $ 
  
 $ xy - xn - yn = 0 $ 
   
 $ xy - xn - yn + n^2 = n^2 $ 

 $ (x - n)(y - n) = n^2$

根据平方的性质，$n^2$ 的每一个质因子的个数等于 $n$ 每一个质因子个数的两倍。所以只要分解 $n$ 的质因子，再根据一个神奇的公式就能推出答案了。

神奇的公式（文字描述）：假设有一个数 $x$ ，这个数可以分解为 $x = a^b + c^d + e^f$ ，那么 $x$ 的因数有 $(b+1)(d+1)(f+1)$ 个。

读完本文再看代码，理解是不用说的。但还是希望你能够自己写一遍。

```cpp
/*胡金梁*/
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
#define int long long
signed main(){
#if __MY_TEST__
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	int n;
	cin>>n;
	int s=1;
	for(int i=2;i<=sqrt(n);i++)
	{
		if(n%i==0)
		{
			int sum=0;
			while(n%i==0)
			{
				n/=i;
				sum++;
			}
			s*=2*sum+1;
		}
	}
	if(n!=1)
	{
		s*=3;
	}
	cout<<(s+1)/2;
#if __MY_TEST__
	fclose(stdin);
	fclose(stdout);
#endif
}

```


---

## 作者：CSP_Sept (赞：0)

$$
\begin{matrix}
\dfrac{1}{x}+\dfrac{1}{y}=\dfrac{1}{n}(x,y,n\in N^+)\\
xn+yn=xy\\
xy-xn-yn=0\\
xy-(x+y)n+n^2=n^2\\
(x-n)(y-n)=n^2\\
\small\text{当 }n^2\text{ 每分解成每一对 }n_1\times n_2\text{ 时,都有一对 }(x,y)\text{ 与之对应.}\\
\small\therefore\text{Ans}=\dfrac{n^2\text{ 的因数个数}+1}{2}
\end{matrix}
$$

于是我们 $O(\sqrt n)$ 求 $n$ 的因数即可。

使用变量 $\text{tmp}$，统计 $n$ 分解质因数时的每个质因子的幂次，每次 `Ans = Ans * (2 * tmp + 1)`

$\mathcal{Code:}$

```cpp
#include <cstdio>

#define int long long

using namespace std;
int n, Ans = 1, tmp;
signed main(){
    scanf("%lld", &n);
    for(int i = 2 ; i * i <= n ; i++)
        if(n % i == 0){
            tmp = 0;
            while(!(n % i)) tmp++, n /= i;
            Ans = Ans * (2 * tmp + 1);
        }
    if(n > 1) Ans *= 3; // 特判
    Ans = (Ans + 1) / 2;
    printf("%lld", Ans);
    return 0;
}
```

---

## 作者：derta (赞：0)

~~学好小奥很重要~~

$$
\begin{aligned}
\frac{1}{x}+\frac{1}{y}&=\frac{1}{n} \\
nx+ny&=xy \\
xy-nx-ny&=0 \\
xy-nx-ny+n^2&=n^2 \\
(x-n)(y-n)&=n^2
\end{aligned}
$$

所以所求之数即为 $d(n^2)$

设 $n=\prod_{i=1}^{k}p_i^{\alpha_i}$，则 $n^2=\prod_{i=1}^{k}p_i^{2\alpha_i}$

由公式，得
$$d(n^2)=\prod_{i=1}^{k}2\alpha+1$$

枚举 $n$ 的因数即可

$\rm{Code:}$

```cpp
#include <iostream>

int main() {
	long long n, ans = 1; //开LL 
	std::cin >> n;
	for(int i = 2; 1LL*i*i <= n && n > 0; ++i) { //注意乘1LL 
		int cnt = 0;
		while(n%i == 0) {
			++cnt; //累加 
			n /= i;
		}
		ans = ans*((cnt << 1) + 1); //公式 
	}
	if(n > 1) //有大于sqrt(n)的质因数 
		ans *= 3; //这个质因数只有一个，根据公式，乘(2*1 + 1) 
	std::cout << ((ans + 1) >> 1);
	//由于本质不同，要除以2，但这样会把(n,n)的解搞掉，故加1 
	return 0;
}
```

---

## 作者：jszzx_zh (赞：0)

前置知识:单位分数分拆(小学五年级奥数)
------------
一些例子:

1/4=1/5+1/20;5=4+1,20=4+16,1 *16=4 * 4;

1/4=1/8+1/8;8=4+4,4 *4=4 *4;

1/4=1/6+1/12;6=4+2,12=4+8,2 * 8=4 *4;

------------
得出结论:
1.两数和为第三数，两数分母大于第三数

2.两数分母可分解成x+积为x*x的数

------------
证明：
1/x+1/y=1/z

x+y/xy=1/z

z * (x+y)=xy

zx+zy-xy=0

(z-x)* y+zx=0

(z-x)* y-(z-x)* z+z * z=0

(z-x)(y-z)=-(z * z)

(x-z)(y-z)=z * z

------------
问题原形：求n * n共有几个因数
1.for循环

2.分解质因数

某数因子个数n=分解出来每个质因数的指数加1再相乘

篇幅问题不再证明赘述(也是小学奥数) ~~自己找度娘~~

如:60=2 * 2 *3 *5

2的指数:2

3的指数:1

5的指数:1

n=(2+1)(1+1)(1+1)=12

只要分解出质因数求出每个质因数的指数加1相乘即可




---

## 作者：Skyjoy (赞：0)

# 小奥题

先给大家放上一张NB的图：lkk承认了

![](https://cdn.luogu.com.cn/upload/image_hosting/6dau7rqj.png)


------------
# 开始讲解

思路提供人：@蒟蒻的名字，不给版权费

按题意，正整数$x,y,n$满足方程$\frac{1}{x}+\frac{1}{y}=\frac{1}{n}$

即$\frac{x+y}{xy}=\frac{1}{n}$

$\therefore xy=(x+y)n$

$xy-xn-yn=0$

$(x-n)(y-n)=n^2$

因为$x \le y$

所以$(x,y)$的对数就是$n^2$的因数个数加上$1$再除以$2$了

那因数个数怎么求呢？

假设一个正整数$n$可以分解质因数为$p_1^{k_1}p_2^{k_2}...p_n^{k_n}$，则$n$的因数个数为$(k_1+1)(k_2+1)...(k_n+1)$，童鞋们可用乘法原理自证。为了避免$TLE$，我们只用计算$n$的因数个数而不是$n^2$，也就是说，每一次计算完次数后，把答案乘以次数加$1$即可。（ps：如果经过计算个数操作后，$n$仍然不等于$1$，则剩下的$n$一定是未被计算过的质数，将答案乘$3$即可）

# 上代码：

```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
using namespace std;
ll lkk,loves,zjy=1;
int main(){
	cin>>lkk;
	for(re ll i=2;i*i<=lkk;i++){
		if(!(lkk%i)){
			loves=0;
			while(!(lkk%i)){\\计算次数
				loves++;
				lkk/=i;
			}
			zjy*=2*loves+1;\\计算个数
		}
	}	
   if(lkk!=1){
   		zjy*=3;
   }
   cout<<(zjy+1)/2;
   return 0;
}
```
思考题：输出所有的$(x,y)$，$\frac{x}{y}$越小越先输出

提示：思考一下$\frac{x}{y}$化简后与$n$的关系

最后，祝看到此题解的童鞋们$CSP2019rp++$！！！

(ps：原代码因某种原因没能完全显示，现已修改。upd：10月14日)

---


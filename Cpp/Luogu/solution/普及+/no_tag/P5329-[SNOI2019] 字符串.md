# [SNOI2019] 字符串

## 题目描述

给出一个长度为 $n$ 的由小写字母组成的字符串 $a$，设其中第 $i$ 个字符为 $a_i(1\le i\le n)$。

设删掉第 $i$ 个字符之后得到的字符串为 $s_i$，请按照字典序对 $s_1,s_2,\cdots,s_n$ 从小到大排序。若两个字符串相等，则认为编号小的字符串字典序更小。

## 说明/提示

对于所有数据，$1\le n\le 10^6$。

对于 10% 的数据，$1\le n\le 2000$；

对于另外 20% 的数据，$1\le n\le 10^5$ 且任意两个相邻字符 $a_i,a_{i+1}$ 不相等；

对于另外 30% 的数据，$1\le n\le 10^5$；

对于余下 40% 的数据，无特殊限制。

## 样例 #1

### 输入

```
7
aabaaab```

### 输出

```
3 7 4 5 6 1 2```

# 题解

## 作者：zjwwjhy (赞：37)

## $P5329$ $[SNOI]$ $2019 $

本蒟蒻认为，这道题难度适中，排紫题有点过了

这题的代码超简单，而且是$O(n)$的

## $Main$ $idea$

一看题目就发现要找规律（看到这种题目的本能反应），稍加思考即可发现：

#### 如果后面有一个比前面大的字母，那么前面无论如何删都比后面的大，直接吧前面的放在答案数组的最后即可；

#### 如果后面有一个比前面小的字母，那么前面无论如何删都比后面的小，直接吧前面的放在答案数组的最前即可；

然后由于我们一遇到比前面大的/小的，就判断，所以这个字符串一定只剩最后那一段相同的字母，特判即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/2y3cxs9v.png)

如图（图丑，望谅解）

## $Code$

只有二十一行呢

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[1000010],id=1;
char c[1000010];
int main(){
	cin>>n>>c+1;
	int l=0,r=n+1;
	for(int i=2;i<=n;i++){
		if(c[i]>c[i-1]){
			for(int j=i-1;j>=id;j--) ans[--r]=j;
			id=i;
		}
		if(c[i]<c[i-1]){
			for(int j=id;j<i;j++) ans[++l]=j;
			id=i;
		}
	}
	for(int i=id;i<=n;i++) ans[++l]=i;
	for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
	return 0;
}
```
###### ~~应该是过的吧，不要出锅啊~~
###### ~~求赞~~


---

## 作者：Spasmodic (赞：13)

教练模拟赛题&签到题，Day1T2。

无奖竞猜T1是啥？A：~~P5286~~

一道水的不行的字符串题&C++福利题，不卡$O(n\log n)$可还行。

首先我们发现要求的是排序，于是我们自然就会想到stl里面有一个自带的`sort`函数，于是我们只要考虑如何在$O(1)$时间内比较$x$和$y$对应字符串的字典序就可以了。

首先不妨设$x<y$，否则只要返回`!cmp(y,x)`即可。

注意到删去$x$的字符串是这样的：
$$s_1s_2\cdots s_{x-1}s_{x+1}\cdots s_{y-1}s_ys_{y+1}\cdots s_n$$
删去$y$的字符串是这样的：
$$s_1s_2\cdots s_{x-1}s_{x}\cdots s_{y-1}s_{y+1}\cdots s_n$$
我们可以发现只要比较
$$s_{x+1}\cdots s_y$$
和
$$s_{x}\cdots s_{y-1}$$
即可。

那么显然就是相邻字符的比较。

定义

$$a_i=\begin{cases}1&s_i>s_{i+1}\\-1&s_i=s_{i+1}\\0&s_i<s_i+1\end{cases}$$

则即求

$$a_{\min\{i|x\le i<y,a_i\neq-1\}}$$

当这样的$i$不存在时返回$1$，原因是此时字符串相等，根据题意应为前者更小。

下面就有两种方法：

### 方法1

预处理$a_i$以及前缀和，二分，复杂度$O(n\log^2n)$。

然而卡常，所以弃掉。

### 方法2

直接预处理

$$f_i=\min\{j|j\ge i,a_j\neq-1\}$$

显然有式子

$$f_i=\begin{cases}i+1&a_i=-1\\f_{i+1}&otherwise\end{cases}$$

可以$O(n)$dp。

则cmp函数可以做到$O(1)$，总复杂度为$O(n\log n)$。

当然可以通过压缩中间相同的部分来做到$O(n)$，不过既然本题不卡$\log$，那么就直接用这种就可以了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,f[N],id[N],ans[N];
char s[N]; 
bool cmp(const int&x,const int&y){return x>y?!cmp(y,x):(f[x]>y?1:s[f[x]]<s[f[x]-1]);}
int main(){
	scanf("%d%s",&n,s+1);
	f[n]=n+1;
	for(int i=n-1;i;i--)f[i]=(s[i+1]!=s[i]?i+1:f[i+1]);
	for(int i=1;i<=n;i++)id[i]=i;
	sort(id+1,id+n+1,cmp);
	for(int i=1;i<=n;i++)printf("%d ",id[i]);
	return 0;
}

```

~~吐槽：怎么做着做着成了DS了，这一定是我的错觉~~

---

## 作者：傅天宇 (赞：12)

[传送门](https://www.luogu.com.cn/problem/P5329)

# Digression：

这是今天 $pj$ 模拟赛 $T1$ ，但是~~毒瘤出题人~~认为：思维难度：普及，代码难度：普及（/jk）（考场上只写了个 $10$ 分的暴力，导致这场比赛爆蛋）。

# Cut into the topic：

$1$ ：分析数据。

对于 $ 10\% $ 的数据， $1 \leq n \leq 2000$ 。

暴力构造出 $s$ ，再用快排进行排序。[惨不忍睹的考场代码](https://www.luogu.com.cn/paste/ml66ea6g)

对于剩下的数据， $1 \leq n \leq 10 ^ 6 $ 。

虽然可以用 $ O \ ( n \ log \ n)$ 的做法水过，但还是可以用 $ O \ ( n )$ ~~草~~过的吧。

$2$ : 手玩数据。对于 $aabaaab$ ，发现当指针 $i$ 在第三位时（即后面的字符大于前面的字符），把前面的 $1,2$ 放到最后。当指针 $i$在第四位时（即后面的字符小于前面的字符），就把 $3$ 放到最前。以此类推。当最后剩余了 $7$ 放到剩余位置，所以答案是 $3,7,4,5,6,1,2$ 。 

$3$ ：做题思考。可以定义 $l=0,r=n+1$ 这两个指针，对比前后两个字符，如果后面的比前面的大，那么前面无论如何删都比后面的大，直接把前面的放在 $ans$ 数组 - -$r$ 的位置中。
如果后面的比前面的小，那么前面无论如何删都比后面的小，直接把前面的放在 $ans$ 数组 + +$l$的位置中。剩余的就按顺序插入。

$4$ ：发放题解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000005//宏定义

int n;
char s[N];
int ans[N],tag;//tag是标记现在在ans数组的哪里
int l,r;//两个指针

int main()
{
	freopen("dunno.in","r",stdin);
	freopen("dunno.out","w",stdout);
	scanf("%d",&n);
	scanf("%s",s+1);//按题意输入
	tag=1;//第一次标记前标记指1
	l=0;
	r=n+1;//指针
	for(int i=2;i<=n;i++)
	{
		if(s[i]==s[i-1]) continue;//如果前后两个字符相等，直接到下一步
		if(s[i]>s[i-1])//如果后面字符小于前面字符
		{
			for(int j=i-1;j>=tag;j--)
			{
				r--;
				ans[r]=j;//根据“做题思考”，把前面的放在 $ans$ 数组 - -$r$ 的位置中。
			}
			tag=i;//更改标记
		}
		if(s[i]<s[i-1])//如果后面字符大于前面字符
		{
			for(int j=tag;j<=i-1;j++)
			{
				l++;
				ans[l]=j;//根据“做题思考”，把前面的放在 $ans$ 数组 + +$l$的位置中
			}
			tag=i;//更改标记
		}
	}
	for(int i=tag;i<=n;i++)
	{
		l++;
		ans[l]=i;	
	} //根据“做题思考”，剩余的就按顺序插入
	for(int i=1;i<=n;i++) printf("%d ",ans[i]);//按题意输出
	return 0;
}
```
# End：
## GL&HF

---

## 作者：Mirach (赞：7)

为啥要 $O(n\log n)$ 呢。作为菜哭自己的魔芋，当然要先看部分分啦：

> 对于另外 $20\%$ 的数据，任意两个相邻字符 $a_i,a_{i+1}$ 不相等；

由于相邻的相同字符在去掉后得到的字符串是一样的，那么明显可以将相邻的相同字符合并，先处理完相邻字符都不一样的情况，最后在输出时一起输出

比如 `aaabb`，可以先将 `aaa` 和 `bb` 分别合并，得到 `ab`，排序可得答案为 `4 1`，再将刚被合并的相邻相同字符放进去，得到 `(4) 5 (1) 2 3`（其中打括号的为合并后的答案，无括号的即刚加入字符）

那么只需考虑相邻字符不同的情况惹。对于比较 $s_i,s_j(i<j)$，不需要考虑 $i$ 之前的字符（都相同），只需考虑 $a_i,a_{i+1}$ 的大小关系即可（$s_i$ 以 $a_{i+1}$ 开头，$s_j$ 以 $a_i$ 开头）

如此可以知道对于每一个 $s_i$，它与每一个 $s_j(i<j)$ 的大小关系都是一样的，那么可以将 $s_i$ 放在所有 $s_j(i<j)$ 的前/后边，只要从后往前维护，就可以链表维护惹（需要维护在链表前后插值）

空间时间复杂度都为 $O(n)$

Code：

```cpp
#include <cstdio>

const int N = 1001000;
int r[N], ps[N], len[N];
char s[N];
int n, t, L, R;

int main() {
	scanf("%d%s",&n,s+1);
	for(int i=1,j=1;i<=n;i=j) {
		while(j <= n and s[i] == s[j]) ++j;
		++t, len[t] = j-i, s[t] = s[i], ps[t] = i - 1;
	}
	L = R = t;
	for(int i=t-1;i;--i)
		if(s[i] > s[i+1]) r[i] = L, L = i;
		else r[R] = i, R = i;
	for(int nw=L;nw;nw=r[nw])
		for(int i=1;i<=len[nw];++i)
			printf("%d ",ps[nw]+i);
	return 0;
}
```

---

## 作者：VinstaG173 (赞：6)

这道题老师有一天断了网让我们做，然后线下测评开了2s。。。

当时我是手打几个数据，然后找到规律的。

对于$s_i$，我们分情况讨论：

首先，如果有$s_i=s_{i+1}$，那么删除$s_i$和$s_{i+1}$结果一样，那么可以把连续相同字符压成一个，输出时从小到大输出就可以了。

然后，如果有$s_i>s_{i+1}$，那么删除$s_i$肯定比不删除$s_i$更优，所以$i$排在所有$k(>i)$的前面。

最后，如果有$s_i<s_{i+1}$，那么删除$s_i$肯定没有不删除$s_i$优，所以$i$排在所有$k(>i)$的后面。

我是用一次$dfs$解决的，只要到一个连续下降子序列（压缩后无相邻相等）的末尾就往下$dfs$在回溯时再输出当前位置，边界为到达$N$。

Code:
```cpp
#include<cstdio>
int N,bg[1000003],cnt;//bg:begin，一个连续相同序列的开始
char s[1000003];
inline void dfs(int d)
{
    int t,m;
    for(t=d;s[bg[t]]>s[bg[t+1]];++t)
    {
        for(m=bg[t];m<bg[t+1];++m)
        {
            printf("%d ",m);
        }
        if(m==N+1)return;
    }
    dfs(t+1);//回溯后再输出当前位置
    for(m=bg[t];m<bg[t+1];++m)
    {
        printf("%d ",m);
    }
}
int main()
{
    scanf(" %d %s",&N,s+1);
    for(int i=1;i<=N;++i)
    {
        if(s[i]==s[i-1])continue;
        bg[++cnt]=i;//压缩
    }
    bg[++cnt]=N+1;
    dfs(1);
    return 0;
}
```

---

## 作者：yuzhechuan (赞：4)

### 题解：

考虑分治

容易发现新串$i$（删掉第i个字符）的第$j$个位置上，若$j\leq i$则为$s_{j+1}$，否则为$s_j$

当$s_j\ne s_{j+1}$时，我们可以直接判断两部分的大小，先朝教小的一部分分治，再向较大的一部分分治

分治到底后按顺序输出即可

为了加快速度，可以在分治中加入剪枝（具体看代码）

---

### 代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
template<class t> inline t read(t &x){
    char c=getchar();bool f=0;x=0;
    while(!isdigit(c)) f|=c=='-',c=getchar();
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
    if(f) x=-x;return x;
}
template<class t> inline void write(t x){
    if(x<0) putchar('-'),write(-x);
    else{if(x>9) write(x/10);putchar('0'+x%10);}
}

const int N=1e6+5;
char s[N];
int n;

void div(int l,int r,int x){ //范围[l,r]，深度x
	if(x==n||x<l||x>=r){ //到底 和 满足剪枝条件 就直接按顺序输出
		for(int i=l;i<=r;i++) write(i),putchar(' ');
		return ;
	}
	if(s[x]==s[x+1]) div(l,r,x+1); //相等就不用管
	else{
		if(s[x]<s[x+1]) div(x+1,r,x+1),div(l,x,x+1); //先小的再大的
		else div(l,x,x+1),div(x+1,r,x+1);
	}
}

signed main(){
	read(n);
	scanf("%s",s+1);
	div(1,n,1);
}

```

---

## 作者：eromangasensei (赞：3)

用栈的做法来水一发。

首先我们有一个暴力的做法，枚举每个被删除的字符，然后排序输出，时间复杂度：$ O (  N \times N \times LogN  ) $ 。
然后我们观察一下数据，发现有一个数据点且任意两个相邻字符 $ a_i $ 与 $ a_{i+1} $ 不相等；那么我们考虑这样一个字符串： $ acdedc $ 。比如现在我们比较去掉第三位的字符串和去掉第四位的字符串。我们发现 $ acddc $ 比 $acdec$ 小，然后我们再发现除 $ 3,4 $ 位的以外的都是一样的，所以直接比较第三位第四位就可以啦。现在就是要考虑去掉当前位置如何与前面所有的字符串比较。**我们发现一旦去掉第二位比第三位来的大那么后面不管去掉哪一位都不可能超过第二位。同理如果当前这一位比不过后一位的话，接下来的所有位他都比不过，就可以直接输出了。** 所以我们把后面所有字符串都打不过的位置用栈记下来，把后面所有字符串都打得败的直接输出，这样我们就又多了 $20$ 分的好成绩。

现在我们考虑有相邻有重复的情况，显然我们可以把相邻一样的区间看成一个字母来做，这样就可以  $ O( N ) $ 实现。
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<stack>
#define INF 1LL<<62;
#define ll long long
#define For(X,From,To) for(ll X=From;X<=To;X++)
using namespace std;
const int MAXN=1e6+5;
char Str[MAXN];
ll N,Cnt,Ans[MAXN],Last,S[MAXN];
bool Flag;
ll QP(ll B,ll K){ ll Ans=1;for(;K;K>>=1) Ans*=(K%2)*B;return Ans;}
template<class T>void Read(T &X){
	X=0;int F=0;char Ch=getchar();
	while(Ch<'0' || Ch>'9'){ F|=(Ch=='-');Ch=getchar();}
	while(Ch>='0' && Ch<='9'){ X=X*10+(Ch^48);Ch=getchar();}
	X=F? -X:X;
}
template<typename T>
inline void Write(T X){
	if(X<0){
		putchar('-');
		X=-X;
	}
	if(X>9) Write(X/10);
	putchar((X%10)^48);
}
int main(){
	Read(N);
	scanf("%s",Str+1);
	Last=1;//用Last来记录一段区间一样的字母的最左端，初始是最左端。
	For(i,2,N)
	if(Str[Last]>Str[i]){//一旦这个区间不如当前的字母，那么后面所有的字符串都可以打败他，所以可以直接输出。
		for(int j=Last;j<i;j++){
			Write(j);putchar(' ');
		}
		Last=i;
	}else
	if(Str[Last]<Str[i]){//否则后面就没有字母可以打败他，加入到栈里。
		for(int j=i-1;j>=Last;j--) S[++Cnt]=j;
		Last=i;
	}
	for(int i=Last;i<=N;i++){//最后还剩一个区间别忘了。
		Write(i);putchar(' ');
	}
	while(Cnt){//输出栈里的所有元素。
		Write(S[Cnt]);putchar(' ');
		Cnt--;
	}
	return 0;
}//完美撒花。qwq 
qwq

```

---

## 作者：Parabola (赞：2)

### Part0.题外话

D1T1签到题，又被你们搞成紫色了。

然后原题是2s的...搬过来就1s了？

怎么还有人写了sa搞lcp？

我太naive嘛？

### Part1.思路

魔改cmp

注意到要比较$(i,j)$的事实上是$i...j-1$与$i+1...j$，我们可以写一个暴力比较的骗个10分

然后看到那个20分的子任务$a_i != a_{i+1}$

这个时候暴力及时break的复杂度是正确的，因为一次比较就能判断谁大

那不满足$a_i != a_{i+1}$怎么办

合并重复不就好了？

时间复杂度$O(n\log n)$

### Part2.Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

const int N = 1000000 + 5;

int n , p;
int num[N] , nxt[N];
char s[N];

namespace SubTask{
	bool cmp(const int& i , const int& j) {
		string s1 , s2;
		if(i < j) {
			int p1 = i + 1 , p2 = i;
			int flag = -1;
			while(p1 <= j) {
				if(s[p1] < s[p2]) {
					flag = 1;
					break;
				}
				else if(s[p1] > s[p2]) {
					flag = 0;
					break;
				}
				int len = min(min(nxt[p1] , j) - p1 + 1 , min(nxt[p2] , j - 1) - p2 + 1);
				p1 += len , p2 += len;
			}
			return flag == -1 ? 1 : flag;
		}
		else {
			int p2 = j + 1 , p1 = j;
			int flag = -1;
			while(p2 <= i) {
				if(s[p1] < s[p2]) {
					flag = 1;
					break;
				}
				else if(s[p1] > s[p2]) {
					flag = 0;
					break;
				}
				int len = min(min(nxt[p1] , i - 1) - p1 + 1 , min(nxt[p2] , i) - p2 + 1);
				p1 += len , p2 += len;
			} 
			return flag == -1 ? 0 : flag;
		}
	}
	void main() {
		for(int i = 1 ; i <= n ;) {
			int j = i + 1;
			while(j <= n && s[j] == s[i]) ++j; 
			for(int k = i ; k < j ; ++k) nxt[k] = j - 1;
			i = j;
		}
		for(int i = 1 ; i <= n ; ++i) num[i] = i;
		sort(num + 1 , num + n + 1 , cmp);
		for(int i = 1 ; i <= n ; ++i) printf("%d " , num[i]);
	}
}

int main() {
	scanf("%d %s" , &n , s + 1);
	SubTask::main();
}
```


---

## 作者：Fading (赞：2)

细节比较多的简单省选题。

~~第一反应是后缀数组板子题，但是听Owen说过不去就没打了，其实可以用DC3~~

但是仔细一想，这道题真的不算难，排个序就好了。

我们只需要比较两个串的大小关系就好了。

有一个很显然的规律，设要比较的两个串为$s_i,s_j(i<j)$我们只需要比较$S[i+1...j]$和$S[i...j-1]$的大小就好了

怎么快速比较呢？

其实求$LCP(i,i+1)$(两个后缀的最长公共前缀)，如果$LCP+i>=j$说明两个串相等，否则比较$S[i+LCP+1]$和$S[i+LCP]$的大小就好了。

可以画画图理解。不过有种情况还是无法处理。

假设现在有一个串$S$

$baaaaaa$

我们比较两个串的大小关系$,s_3$和$s_6$

方便起见我们把空位设为$_$

$ba$_$aaaa$

$baaaa$_$a$

发现$LCP=1$，到头了，根本匹配不完全。虽然两个串是相等的，但是按照上述方法判断就不相等了。

怎么办？倍长字符串（后面全部填最后一个字母）就好了。

不过为什么要暴力求$LCP$啊，为什么要用后缀数组啊？~~听说Owen写了哈希求LCP，好神仙~~

$LCP(i,i+1)$这个不是非常好求吗？显然这两个串的$LCP$全都是由相同的字符重复构成的，比如$aaaaaaaa...$

那么记录一下向右有多少个相同字符就好了。

代码如下，细节比较多。

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[2200001];
int num[2200001],n,sa[2200001];
inline int LCP(int x){
	if (s[x]!=s[x+1]) return 0;
	return num[x+1];
}
inline bool cmp(int id1,int id2){
	if (id1>id2){
		if (LCP(id2)+id2>=id1) return 0;
		else{
			int pos2=LCP(id2)+1+id2,pos1=pos2-1;
			if (s[pos1]>s[pos2]) return 0;
			else return 1;
		} 
	}else{
		if (LCP(id1)+id1>=id2) return 1;
		else{
			int pos2=LCP(id1)+1+id1,pos1=pos2-1;
			if (s[pos1]>s[pos2]) return 1;
			else return 0;
		} 
	}
}
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
    return x*f;
}
int main(){
	n=read();
	scanf("%s",s+1);
	num[2*n]=1;sa[n]=n;
	for (int i=n+1;i<=n+n;i++) s[i]=s[i-1];
	for (int i=2*n-1;i;i--){
		if (s[i]==s[i+1]) num[i]=num[i+1]+1;
		else num[i]=1;
		if (i<=n-1) sa[i]=i;
	}
	sort(sa+1,sa+1+n,cmp);
	for (int i=1;i<=n;i++) printf("%d ",sa[i]); 
	return 0;
} 
```


---

## 作者：mrsrz (赞：1)

考虑去掉第$i$位和第$j$位，其首、尾相等。

所以我们只需要考虑$S(i+1,j)$和$S(i,j-1)$的大小关系即可。

令$f_i$表示位置$i$之后，第一个满足$S_i\neq S_{i+1}$的位置。

然后，若$i< j$，则：

1. $f_i\geqslant j$，则两串中间部分相等，小的在前。
2. $f_i<j$，则只需要比较这个第一次不同的位置谁比较大即可。

按照上述方法写个比较函数，然后扔进```sort()```里就做完了。

时间复杂度$O(n\log n)$。

## Code：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e6+6;
int wg[N],n,a[N];
char s[N];
inline int cmp(int a,int b){
    if(a<b){
        if(wg[a]>=b)return 1;
        return s[wg[a]+1]<s[wg[a]];
    }else{
        if(wg[b]>=a)return 0;
        return s[wg[b]]<s[wg[b]+1];
    }
}
int main(){
    cin>>n>>(s+1);
    for(int i=1,t=1;i<n;++i){
        if(t<i)t=i;
        while(t<n&&s[t]==s[t+1])++t;
        wg[i]=t;
    }
    for(int i=1;i<=n;++i)a[i]=i;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;++i)
    cout<<a[i]<<' ';
    return 0;
}

```

---

## 作者：KaguyaH (赞：0)

[**原题传送门**](https://www.luogu.com.cn/problem/P5329)

# 定义

- $a(i, j)$：$a$ 中区间 $[i, j]$ 构成的子串。

# 题目分析

因为要排序，所以一个很难回避的问题就是：设 $1 \leqslant i < j \leqslant n$，如何比较 $s_i$ 与 $s_j$。

不难发现一条性质：$s_i, s_j$ 的前 $(i - 1)$ 个字符、后 $(n - j)$ 个字符相同，故 $s_i, s_j$ 的大小关系就等价于 $a(i + 1, j), a(i, j - 1)$ 的大小关系。

对于如何比较上述两个子串，一个很自然的想法就是：如果 $a_{i + 1} \neq a_i$，那么上述两个子串的大小关系就等价于 $a_{i + 1}, a_i$ 的大小关系。

于是，我们考虑仅对原串中相同且连续的一段字符的右端点进行排序。

那么，如何确定相同且连续的一段字符中非右端点的答案呢？

返回题面，我们又发现了这样一条性质：对于相同且连续的一段字符 $a(l, r)$，$s_{l, \cdots, r}$ 连续。故我们把 $a$ 相同且连续的字符压缩成一个点，用左右端点表示，对这些压缩成的点排序即可。

# Code

```cpp
# define _CRT_SECURE_NO_WARNINGS
# include <cstdio>
# include <algorithm>
using std::sort;

typedef long unsigned int LU;
enum Max { N = (const LU)1e6 };

LU n;
char s[N + 1];

struct String {
	bool less;
	LU l, r;
	String() {}
	String(const LU l, const LU r) {
		this->l = l, this->r = r;
	}
	friend inline const bool operator < (const String a, const String b) {
		return b.l < a.l ? s[b.l] < s[b.r + 1] : s[a.l] > s[a.r + 1];
	}
	inline const void output() {
		for (register LU i(l); i <= r; ++i) printf("%lu ", i);
	}
} p[N + 1];
LU lp;

signed int main() {
	scanf("%lu", &n);
	while (s[1] = getchar(), !('a' <= s[1] and s[1] <= 'z'));
	p[(lp = 0)++] = String(1, 1);
	for (register LU i(2); i <= n; ++i) {
		while (s[i] = getchar(), !('a' <= s[i] and s[i] <= 'z'));
		if (s[i] == s[i - 1]) ++p[lp - 1].r;
		else p[lp++] = String(i, i);
	}
	//for (register LU i(0); i < lp; ++i) printf("%lu %lu\n", p[i].l, p[i].r);
	//for (register LU i(0); i < lp; ++i)
	//	for (register LU j(0); j < lp; ++j)
	//		printf("%lu %lu %hu\n", i, j, (const short unsigned int)(p[i] < p[j]));
	sort(&p[0], &p[lp]);
	for (register LU i(0); i < lp; ++i) p[i].output();
	return 0;	
}
```

---

## 作者：千年知乎_天才 (赞：0)

题目名称：字符串

来源：2019年陕西省选
# 博客链接
- [博客园](https://www.cnblogs.com/Alvin-Tree/p/11468582.html)
- [CSDN](https://blog.csdn.net/weixin_43890363/article/details/100547332)
- [洛谷博客](https://www.luogu.org/blog/131abc155-7341-6424/solution-p5329)
- [洛谷题解](https://www.luogu.org/problemnew/solution/P5329)

# 提示
本题不需要**SA**或者**SAM**等高级算法。
# 题解
## 10分
暴力构造出$s$，再用快速排序进行排序。时间复杂度为$O(n^2log(n))$，在$n\leq2000$的数据下跑得过。
## 30分
注意到：其中20%的数据没相邻两个字符不相等。
>引理
>当其任意两个字符不相等时，$s_i$和$s_j(i<j)$的大小关系实际上就是$a_{i+1}$与$a_i$的大小关系。
>证明：由题意得。
>$s_i[1……i-1]=a[1……i-1]=s_j[1……i-1]$
>$s_i[j……n-1]=a[j+1……n]=s_j[j……n-1]$
>重点在于比较$s_i[i……j-1]$和$s_j[i……j-1]$的大小关系。
>$s_i[i……j-1]$正对应$a[i+1……j]$；
>$s_j[i……j-1]$正对应$a[i……j-1]$；
>而$a[i+1]!=a[i]$，故二者的大小关系可以确定。
>

于是，我们可以开一个双端队列。逆序处理整个字符串。

当我们发现$a[i+1]<a[i]$时，则说明$s_i$比后面的（即已经被处理过放进双端队列里的）都要小，就把数字$i$放在双端队列的前面；否则说明$s_i$比后面的都要大，就把它放在双端队列的后面。

最后我们按顺序将双端队列每一个位置上的数字。
## 100分
那么，我们如何拿到100分呢？？？

实际上，我们只需要将原来30分的做法进行扩展，或者说将所有情况转换为两两相邻字符不相等的情况就行。
>引理
>当$a[i]=a[i+1]$时，$s[i]=s[i+1]$
>证明略
>

由此，我们就可以将字符串连续相同的一段进行压缩，其中每一个字母都代表着原字符串的一段区间。
例如$"bbbcaa"$压缩成$"bca"$，并且处理出来如下数据：
|字母|开始位置|结束位置|
|:-|-|-|
|b|1|3|
|c|4|4|
|a|5|6|
将压缩后的串排序得$3\quad1\quad2$。
将原来处理出来的数据带入得$(5\quad6)(1\quad2\quad3)(4)$。
```cpp
//C++
#include<iostream>
#include<stdio.h>
#include<string>
#include<deque>
using namespace std;
const int nn=1000001;
inline void output(long long o);
int start[nn],final[nn];
inline long long input();
string a;
deque<int>k;
int main()
{
	int n=input(),size=0;
	cin>>a;
	for(int i=0,PREV=0;i<n;i++)
	{
		PREV=i;
		while(a[i]==a[i+1]&&i<n)i++;
		a[size]=a[i],start[size]=PREV+1,final[size++]=i+1;
	}
	for(int i=size-1;i>=0;i--)
	if(a[i+1]<a[i])k.push_front(i);
	else k.push_back(i);
	for(;k.front()!=k.back();k.pop_front())
	for(int i=start[k.front()],f=final[k.front()];i<=f;i++)output(i),putchar(' ');
	for(int i=start[k.front()],f=final[k.front()];i<f;i++)output(i),putchar(' ');
	output(final[k.front()]),putchar('\n');
	return 0;
}
inline void output(long long o)
{
	if(o<0)putchar('-'),o=-o;
	if(o>=10)output(o/10);
	putchar(o%10^'0');
}
inline long long input()
{
	bool positive=true;
	char now=getchar();
	long long i=0;
	for(;!isdigit(now);now=getchar())
	if(now=='-')positive=!positive;
	for(;isdigit(now);now=getchar())i=(i<<3)+(i<<1)+(now^'0');
	return positive?i:-i;
}
```

---

## 作者：hht2005 (赞：0)

[My](https://blog.csdn.net/qq_42993486/article/details/100550540) [blog](https://www.cnblogs.com/hht2005/p/11462809.html)
# sol
题目意思很明确，但似乎不太好求。还是先看看部分分。
## 10%数据
$\Theta(n^2\log n)$，暴力，先得10分。
## 另20%数据
发现一件事，在比较$s_i$和$s_j$时，假设$i<j$，从1到i-1这一段是一样的，从j+1到n是一样的，所以我们只要比较原串的i+1~ j和i ~j-1这两段就行。由于任意相邻两个都不相同，所以能$\Theta(1)$比较。
## 另30%数据
想到哈希，虽然哈希只能判等，但我们只要二分一下，找出两个字符串的最长公共前缀，再比较最长公共前缀的下一个位置就行。时间复杂度：$\Theta(n\log^2n)$
## 最后40%数据
到这应该很明朗了，两个后缀的最长公共前缀，立刻想到后缀数组。通过$n\log n$的预处理，可以$\Theta(1)$比较，再使用$\Theta(n\log n)$的快排就可以了。

实测：TLE 60分

后缀数组组似乎常数太大，不能通过。不过想一想我们需要什么，两个相邻后缀的最长公共前缀，可以设$h_i$为以i和i+1开头的后缀的最长公共前缀的长度，很明显$h_i>=h_{i-1}-1$，其实相当于一起去掉两个开头字符，所以$h_i$一开始就赋值为$h_{i-1}-1$，就可以$\Theta(n)$预处理h数组了，最后就可以直接排序了。虽然跑不过众多大佬的$\Theta(n)$算法，但也能通过了。
# code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define cmp(a,b,c) (a+c<=n&&b+c<=n&&y[a]==y[b]&&y[a+c]==y[b+c])
#define min(a,b) (a<b?a:b)//卡常
const int maxn=1e6+10;
char s[maxn];
int ans[maxn],h[maxn],n;
inline void write(int x) {//卡常
	if(x>=10)write(x/10);
	putchar(x%10^48);
}
void Swap(int &a,int &b) {//还是卡常
	a^=b,b^=a,a^=b;
}
int cmp1(int a,int b) {//自定义比较方法
	int f=0;
	if(a>b)Swap(a,b),f=1;
	if(h[a]>=b-a)return f^1;
	return (s[a+h[a]+1]<s[a+h[a]])^f;
}
int t[maxn];
void Qsort(int l,int r) {//手写归并排序，也是写后缀数组卡常留下的
	if(l==r)return;
	int mid=(l+r)>>1;
	Qsort(l,mid),Qsort(mid+1,r);
	int i=l,j=mid+1,cnt=0;
	while(i<=mid||j<=r) {
		if((j>r)||(i<=mid&&cmp1(ans[i],ans[j])))t[cnt++]=ans[i++];
		else t[cnt++]=ans[j++];
	}
	for(int i=0; i<cnt; i++)ans[i+l]=t[i];
}
int main() {
	scanf("%d\n",&n);
	fread(s+1,1,n,stdin);//优读，写后缀数组卡常留下的
	for(int i=1; i<n; i++) {//求h数组
		h[i]=max(h[i-1]-1,0);
		for(int j=i+1; s[i+h[i]]==s[j+h[i]]; h[i]++);
	}
	for(int i=1; i<=n; i++)ans[i]=i;//初始化
	Qsort(1,n);
	for(int i=1; i<n; i++)write(ans[i]),putchar(' ');
	write(ans[n]),putchar('\n');
	return 0;
}
```

---

## 作者：Meronri_Deng (赞：0)

不知道大家在刚学字符串的时候有没有见过这样一道题
题意：
```
给你一个字符串
去掉一个字符
使所得字符串字典序最小
输出这个字典序最小的结果
```
因为越前面的字符越重要
所以这道题的求解过程就是从前往后扫找到第一个st[i]>st[i+1]
这样的话所得字符串的第i位就比原字符串要小了，并且因为i最小所以是字典序最小
```
input:
abcdefgabcde
output:
abcdefabcde
```
去掉第i个字符(st[i]>st[i+1])所得串必然字典序小于原串

i越小，字典序越小

——————

相似的问题是去掉一个字符使字典序最大
所以这道题的求解过程就是从前往后扫找到第一个st[i]<st[i+1]
这样的话所得字符串的第i位就比原字符串要大了
```
input:
abcdefgabcde
output:
acdefgabcde
```
去掉第i个字符(st[i]<st[i+1])所得串必然字典序大于原串

i越小，字典序越大

——————

本题就跟这两道题相似
我们先把字符相同的连续子串合并一下
然后按上面的流程分为大于原串和小于原串

大于原串赋值为1
小于原串赋值为-1

然后以与原串的关系为第一关键字 

所在位置为第二关键字排序
(同为-1 越前越小 同为1 越后越小)

然后直接输出即可

如果还不能理解可以看一下我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct AA{
	int begin_,end_,leixing_;
	char ccc;
} a[1000005];
char c[1000005];
bool cmp(AA x,AA y)
{
	if  (x.leixing_!=y.leixing_)  return x.leixing_<y.leixing_;
	if  (x.leixing_==-1)
		return x.begin_<y.begin_;
	else
		return x.begin_>y.begin_;
}
int main()
{
	int n;
	scanf("%d\n",&n);
	for  (int i=1;i<=n;i++)
		c[i]=getchar();
	a[1].begin_=a[1].end_=1;
	a[1].ccc=c[1];
	int num=1;
	for  (int i=2;i<=n;i++)
		if  (c[i]==c[i-1])
			a[num].end_++;
		else
			{
				num++;
				a[num].begin_=a[num].end_=i;
				a[num].ccc=c[i];
			}
	for  (int i=1;i<num;i++)
		if  (a[i].ccc<a[i+1].ccc)
			a[i].leixing_=1;
		else
			a[i].leixing_=-1;
	sort(a+1,a+num+1,cmp);
	for  (int i=1;i<=num;i++)
		{
			for  (int j=a[i].begin_;j<a[i].end_;j++)
				printf("%d ",j);
			printf("%d",a[i].end_);
			if  (i==num)
				puts("");
			else
				putchar(' ');
		}
	return 0;
}

```

---


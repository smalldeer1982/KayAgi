# [TJOI2019] 大中锋的游乐场

## 题目描述

大中锋正在一个游乐场里玩耍。游乐场里有 $n$ 个娱乐设施，娱乐设施之间相互有共 $m$ 条道路相连，经过每一条路都需要花费一定的时间。为了方便游客，每一个娱乐设施旁都会配有一个小卖部，一部分小卖部会销售可乐，另一部分会销售汉堡。

由于大中锋十分贪吃，所以每当他走到一个娱乐设施，他都会先去购买一杯可乐或一个汉堡，并把它们吃掉。但如果大中锋吃掉的汉堡数量比他喝掉的可乐数量多于 $k$ ，那他就会感到很渴；如果喝掉的可乐数量比吃掉的汉堡数量多于 $k$ ，那他就会感到很饿。

现在大中锋正在第 $a$ 个娱乐设施，他想前往第 $b$ 个娱乐设施，但在他前进的路途中他不希望自己很渴或很饿。大中锋想知道自己在路上少花费多少时间。但由于大中锋很懒惰，他不想思考这个问题。你能帮助他解决这个问题吗？

注意：大中锋非常贪吃，所以他到达每个点的第一件事是去吃(或者喝)，才考虑其他的事情，所以在起始点和终点他都会去买汉堡(可乐)，你也需要保证在这两个点他不会感到很饿或者很渴。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 50,m\leq 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10000$，$1 \leq m\leq 100000$，$1 \leq k\leq 10$，$1 \leq a_i \leq 2$，$1 \leq u, v,s, t \leq n$，$1 \leq w \leq 10000$。

对于所有数据，保证 $1 \leq T \leq 10$ ，且每个测试点的大数据不超过 $2$ 个。

#### 题目补充说明

- 路径不一定是简单路径。
- 大中锋可以多次经过一个节点，同时每次都会取得汉堡/可乐。

## 样例 #1

### 输入

```
1
2 1 1
1 1
1 2 1
1 2```

### 输出

```
-1```

## 样例 #2

### 输入

```
1
2 1 2
1 1
1 2 1
1 2```

### 输出

```
1```

# 题解

## 作者：StudyingFather (赞：5)

又是一道分层图最短路的练手题。

设 $f_{i,j}$ 表示当前在 $i$ 号点，汉堡比可乐多 $j$ 次时的最短路。

别忘了起点也是要吃汉堡/喝可乐的。

```cpp
// Problem : P5340 [TJOI2019]大中锋的游乐场
// Contest : Luogu Online Judge
// URL : https://www.luogu.com.cn/problem/P5340
// Author : StudyingFather
// Site : https://studyingfather.com
// Memory Limit : 125 MB
// Time Limit : 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cp-editor)

#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#define INF 0x3f3f3f3f
using namespace std;
struct edge
{
 int v,w,next;
}e[200005];
struct node
{
 int u,t,w;
 bool operator<(const node&a)const
 {
  return w>a.w;
 }
};
priority_queue<node> q;
int head[10005],dis[10005][25],vis[10005][25],cnt;
int a[10005];
void addedge(int u,int v,int w)
{
 e[++cnt].v=v;
 e[cnt].w=w;
 e[cnt].next=head[u];
 head[u]=cnt;
}
int main()
{
 int T;
 cin>>T;
 while(T--)
 {
  cnt=0;
  memset(head,0,sizeof(head));
  memset(dis,63,sizeof(dis));
  memset(vis,0,sizeof(vis));
  int n,m,k,s,t;
  cin>>n>>m>>k;
  for(int i=1;i<=n;i++)
  {
   cin>>a[i];
   if(a[i]==2)a[i]=-1;
  }
  for(int i=1;i<=m;i++)
  {
   int u,v,w;
   cin>>u>>v>>w;
   addedge(u,v,w);
   addedge(v,u,w);
  }
  cin>>s>>t;
  dis[s][k+a[s]]=0;//注意初始状态
  q.push({s,k+a[s],0});
  while(!q.empty())
  {
   int u=q.top().u,t=q.top().t;
   q.pop();
   if(vis[u][t])continue;
   vis[u][t]=1;
   for(int i=head[u];i;i=e[i].next)
   {
    int v=e[i].v,nt=t+a[v];
    if(nt<=2*k&&nt>=0&&dis[v][nt]>dis[u][t]+e[i].w)
    {
     dis[v][nt]=dis[u][t]+e[i].w;
     q.push({v,nt,dis[v][nt]});
    }
   }
  }
  int ans=INF;
  for(int i=0;i<=2*k;i++)
   ans=min(ans,dis[t][i]);
  if(ans==INF)cout<<-1<<endl;
  else cout<<ans<<endl;
 }
 return 0;
}
```

---

## 作者：养熊人 (赞：3)

### 题意简述


------------

给出一张图，点有点权 $ 1 $ 或 $ -1 $ 。在满足走过的总点权和的绝对值小于 $ k $ 的条件下，走最短路。

### 做法


------------

注意到 $ k $ 的范围比较小，我们可以考虑套路性的采用分层图做法。将一个点拆分多个点，分布在 $ 2\times k $ 层图上，并且钦定向下层图中走为买了可乐，向上层图中走为买了汉堡，对于每一层图不进行连边（这是由于题目限制每次经过一个点必须购买汉堡或者可乐）。对于一对边 $ u $ 和 $ v $ 对 $ v $ 的点权进行判断，决定向下层图连边还是向上层图连边。~~这就成功水掉了这道蓝题~~。

还有几点需要注意到，由于起点的点权也要加上，所以需要对起点的点权类型进行特判。多测需要清空。

接下来上代码。

```cpp
#include<bits/stdc++.h>
#define F(i,x,n) for(int i=x;i<=n;++i)
#define _F(i,x,n) for(int i=x;i>=n;--i)
using namespace std;

inline int read(){
	int s=0;char c=getchar();bool flag=0;
	while(!isdigit(c))flag|=(c=='-'),c=getchar();
	while(isdigit(c))s=(s<<3)+(s<<1)+(c^48),c=getchar();
	return flag?-s:s;
}

const int N=3e6+5;
const int Inf=1e9+7;

struct edge{
	int nxt,v,w;
}a[N<<1];

struct node{
	int dis,u;
	bool operator < (const node&p)const{
		return dis>p.dis;
	}
};

priority_queue<node>q;

int head[N],dis[N],vis[N],b[N];
int n,m,k,s,t,cnt;

void add(int u,int v,int w){
	a[++cnt]=edge{head[u],v,w};
	head[u]=cnt;
}

void dij(int begin){//对于没有负权边的一定要用dij
	F(i,0,n*(2*k+1))dis[i]=Inf,vis[i]=0;
	q.push(node{0,begin}),vis[begin]=0,dis[begin]=0;
	while(!q.empty()){
		int u=q.top().u;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=a[i].nxt){
			int v=a[i].v,w=a[i].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push(node{dis[v],v});
			}
		}
	}
}

void solve(){
	n=read(),m=read(),k=read();
	F(i,1,n)b[i]=read();
	int mid=k,top=k*2;
	F(i,1,m){
		int u=read(),v=read(),w=read();
		if(b[v]==1){//买可乐向下层图转移
			_F(i,top-1,0){
				add(u+n*(i+1),v+n*i,w);
			}
		}
		else if(b[v]==2){//买汉堡向上层图转移
			F(i,1,top){
				add(u+n*(i-1),v+n*i,w);
			}
		}
		if(b[u]==1){//同上
			_F(i,top-1,0){
				add(v+n*(i+1),u+n*i,w);
			}
		}
		else if(b[u]==2){
			F(i,1,top){
				add(v+n*(i-1),u+n*i,w);
			}
		}
	}
	s=read(),t=read();
	if(b[s]==1)dij(s+(mid-1)*n);//特判起点的情况
	else dij(s+(mid+1)*n);
	int ans=Inf;
	F(i,0,k*2){
		ans=min(ans,dis[t+n*i]);
	}
	if(ans==Inf)puts("-1");
	else printf("%d\n",ans);
	memset(head,0,sizeof(head));//多测清空！！！
	cnt=0;
}

signed main(){	
	int T=read();
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：3)

这是一道分层图的基础题，惊讶的是，十分钟写，直接过编一遍过，太给面子了！

将每一个点拆成 $2k+1$ 个点，分别表示吃该点的食物之前汉堡比可乐多 $1,2,...,k$ 个，可乐比汉堡多 $1,2,...,k$ 个，以及两个一样多。

接下来，就可以用 $x_0,x_1,...,x_{2k}$ 表示这些点，其中 $x_k$ 表示一样多。

如果加上该点的食物就越界了，就直接考虑下一个点，否则如果到达了 $t$ 点，直接输出答案就可以了，不然就跑一边 Dijkstra，用二叉堆就行了。

时间 $O((m+nk)\log_2(m+nk))$，空间 $O(m+nk)$。

贴上 1.03k 的 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+4,M=2e5+5,K=25;
int read(){int x;scanf("%d",&x);return x;}
void write(int x){printf("%d\n",x);}
int T,n,m,k,s,t,d[N][K],a[N];
int ed[M],w[M],ans,vs[N][K];
struct Tq{
	int x,p,w;
	inline bool operator<(const Tq &y)
	const{return w>y.w;}
}at;
priority_queue<Tq>dk;
vector<int>lk[N];
int main(){
	T=read();int i,x,y,p,r;
	while(T--){
		n=read(),m=read(),k=read();
		for(x=1;x<=n;++x){
			a[x]=read()&1?1:-1;
			for(p=0;p<=k+k;++p)d[x][p]=2e9;
		}ans=2e9+9;
		for(i=1;i<=m;++i){
			lk[ed[i+i]=read()].push_back(i+i+1);
			lk[ed[i+i+1]=read()].push_back(i+i);
			w[i+i]=w[i+i+1]=read();
		}s=read(),t=read();
		while(!dk.empty())dk.pop();
		dk.push({s,k,d[s][k]=0});
		while(!dk.empty()){
			at=dk.top(),dk.pop();
			x=at.x,p=at.p,r=p+a[x];
			if(r<0||r>k+k)continue;
			if(x==t){ans=d[x][p];break;}
			for(int i:lk[x])
				if(d[y=ed[i]][r]>d[x][p]+w[i]){
					d[y][r]=d[x][p]+w[i];
					dk.push({y,r,d[y][r]});
				}
		}write(ans>2e9?-1:ans);
	}return 0;
}
```

---

## 作者：jiuguaiwf (赞：3)

md，现在内心极度难受

考场狂码200+，删到190+，就TM20分

### 这道水题题解的意义就在于警醒后人：出队后标记一定要清空！！！不然就更新不了了...
忘写一行少80分...QwQ

言归正传：

题目给了一张图，限制里问最短路程：经验告诉我们是分层图最短路

设计状态：dis[u][i][j]表示到u节点，喝了i杯可乐,吃了j个汉堡

啊，内存爆了....

发现我们只关心i和j之间的差值，而差值是不会超过k的，那么新状态来了：dis[u][i][0/1/2]表示到u，差值为i，1表示可乐比汉堡多，2表示汉堡比可乐多，0表示可乐汉堡一样多。

转移显而易见了～

考场紧张下只想尽快写完，其实换一种状态能压到90行的...

考场代码1.1.0 ：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
typedef long long LL;
LL dis[10005][12][3];
int cnt,k;
int sel[10005];
int n,m,S,T,t,vis[10005][12][3],h[10005];
struct wf{
	int to,nxt;
	LL w;
}edge[100005<<1];
struct wff{
	int x,y,z;
};
queue<wff> Q;
void pre_work()
{
	cnt=0;
	memset(edge,0,sizeof (edge));
	memset(h,0,sizeof (h));
}
void add(int u,int v,LL w)
{
	edge[++cnt].to=v;
	edge[cnt].nxt=h[u];
	edge[cnt].w=w;
	h[u]=cnt;
}
LL spfa()//瞎想了一波，认为这种边数，状态下spfa更快
{
	memset(dis,0x3f,sizeof (dis));
	memset(vis,0,sizeof (vis));
	LL ans=dis[1][1][1];
	LL sta=ans;
	if (k==0) return -1;//应对极端数据
	if (sel[S]==1) //处理起点情况
	{
		dis[S][1][1]=0;
		vis[S][1][1]=1;
		Q.push((wff){S,1,1});
	}
	else
	{
		dis[S][1][2]=0;
		vis[S][1][2]=1;
		Q.push((wff){S,1,2});
	} 
	while(!Q.empty())
	{
		wff u=Q.front();
		Q.pop();
		vis[u.x][u.y][u.z]=0;//多加了这一行...
		for (int i=h[u.x];i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if (u.z==1&&sel[v]==1)//转移显然
			{
				if (u.y+1>k) continue;
				if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][u.y+1][u.z])
				{
					dis[v][u.y+1][u.z]=dis[u.x][u.y][u.z]+edge[i].w;
					if (!vis[v][u.y+1][u.z])
					{
						vis[v][u.y+1][1]=1;
						Q.push((wff){v,u.y+1,1});
					}
				}
			}
			if (u.z==1&&sel[v]==2)
			{
				if (u.y==1)	
				{
					if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][0][0])
					{
						dis[v][0][0]=dis[u.x][u.y][u.z]+edge[i].w;
						if (!vis[v][0][0])
						{
							vis[v][0][0]=1;
							Q.push((wff){v,0,0});
						}
					}
				}
				else
				{
					if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][u.y-1][u.z])
					{
						dis[v][u.y-1][u.z]=dis[u.x][u.y][u.z]+edge[i].w;
						if (!vis[v][u.y-1][u.z])
						{
							vis[v][u.y-1][1]=1;
							Q.push((wff){v,u.y-1,1});
						}
					}
				}
			}
			if (u.z==2&&sel[v]==1)
			{
				if (u.y==1)	
				{
					if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][0][0])
					{
						dis[v][0][0]=dis[u.x][u.y][u.z]+edge[i].w;
						if (!vis[v][0][0])
						{
							vis[v][0][0]=1;
							Q.push((wff){v,0,0});
						}
					}
				}
				else
				{
					if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][u.y-1][u.z])
					{
						dis[v][u.y-1][u.z]=dis[u.x][u.y][u.z]+edge[i].w;
						if (!vis[v][u.y-1][u.z])
						{
							vis[v][u.y-1][2]=1;
							Q.push((wff){v,u.y-1,2});
						}
					}
				}
			}
			if (u.z==2&&sel[v]==2)
			{
				if (u.y+1>k) continue;
				if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][u.y+1][u.z])
				{
					dis[v][u.y+1][u.z]=dis[u.x][u.y][u.z]+edge[i].w;
					if (!vis[v][u.y+1][u.z])
					{
						vis[v][u.y+1][2]=1;
						Q.push((wff){v,u.y+1,2});
					}
				}
			}
			if (u.z==0&&sel[v]==1)
			{
				if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][u.y+1][1])
				{
					dis[v][u.y+1][1]=dis[u.x][u.y][u.z]+edge[i].w;
					if (!vis[v][u.y+1][1])
					{
						vis[v][u.y+1][1]=1;
						Q.push((wff){v,u.y+1,1});
					}
				}
			}
			if (u.z==0&&sel[v]==2)
			{
				if (dis[u.x][u.y][u.z]+edge[i].w<dis[v][u.y+1][2])
				{
					dis[v][u.y+1][2]=dis[u.x][u.y][u.z]+edge[i].w;
					if (!vis[v][u.y+1][2])
					{
						vis[v][u.y+1][2]=1;
						Q.push((wff){v,u.y+1,2});
					}
				}
			}
		}
	}
	for (int i=0;i<=k;i++)//再三种情况中取最小值
	  ans=min(ans,dis[T][i][1]);
	for (int i=0;i<=k;i++)
	  ans=min(ans,dis[T][i][2]);
	ans=min(ans,dis[T][0][0]);
	if (ans==sta) return -1;
	else return ans;
}
int main()
{
	scanf("%d",&t);
	for (int qqq=1;qqq<=t;qqq++)
	{
		pre_work();
		scanf("%d%d%d",&n,&m,&k);
		for (int i=1;i<=n;i++)
		  scanf("%d",&sel[i]);
		int u,v;
		LL w;
		for (int i=1;i<=m;i++)
		{
			scanf("%d%d%lld",&u,&v,&w);
			add(u,v,w);
			add(v,u,w);
		}
		scanf("%d%d",&S,&T);
		LL flag=spfa();
		printf("%lld\n",flag);
	}	
	return 0;
}

```

~~考场不给大样例真的很神奇~~

---

## 作者：s_r_f (赞：3)

~~TJOI怎么这么多sb题啊~~

令可乐的权值为$1$，汉堡为$-1$,

初始化$x = 0.$

每次走到点$i$,就让$x$加上当前点的权值$v[i]$(一开始在点$a$处也要加)

要求任意时刻$|x| <= k$

~~看一下数据范围发现k怎么这么小~~

把一个点$i$拆成$2k+1$个点,分别表示走到点$i$时,当前的权值为$-k,-k+1,-k+2,...,-2,-1,0,1,2,...,k$

把边也拆成$O(k)$条边。

在新图上跑$Dijsktra$，点数$O(nk)$,边数$O(mk)$

令$V = nk,E = mk$复杂度为$O(ElogV) = O(mklog(nk))$

代码:

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
inline LL read(){
	LL x = 0,f = 1; char c = getchar();
	while (c != EOF && !isdigit(c)) {if (c == '-') f = -1; c = getchar();}
	while (isdigit(c)) x = x * 10 + c - '0',c = getchar();
	return x * f;
}
inline void write(LL x){
	if (x < 0) x = -x,putchar('-');
	if (x > 9) write(x/10);
	putchar('0' + x % 10);
}
const int N = 10050,K = 11,V = N * 21,E = 100050 * 21 * 2;
int To[E],Dis[E],Ne[E],He[V],_k;
inline void add(int x,int y,int z){
	++_k; To[_k] = y,Dis[_k] = z,Ne[_k] = He[x],He[x] = _k;
}
int T;
int cnt;
int qa,qb,start;
int n,m,k,tp[N],p1[N],p2[N][K],p3[N][K];
inline int Getp(int x,int t){
	if (abs(t) > k) return 0;
	if (!t) return p1[x];
	return t > 0 ? p2[x][t] : p3[x][-t];
}
LL dis[V],ans,INF = 1ll<<61;
struct Node{
	int x; LL d;
	bool operator < (Node w) const{ return d > w.d; }
}tmp;
priority_queue<Node>Heap;
inline void Dij(){
	int i,p,x,y;
	while (!Heap.empty()) Heap.pop();
	
	for (i = 1; i <= cnt; ++i) dis[i] = INF;
	dis[start] = 0;
	tmp.x = start,tmp.d = 0,Heap.push(tmp);
	while (!Heap.empty()){
		tmp = Heap.top(); Heap.pop();
		if (tmp.d > dis[tmp.x]) continue;
		x = tmp.x;
		for (p = He[x]; p ; p = Ne[p]){
			y = To[p];
			if (dis[y] > dis[x] + Dis[p]){
				dis[y] = dis[x] + Dis[p];
				tmp.x = y,tmp.d = dis[y];
				Heap.push(tmp);
			}
		}
	}
}
int main(){
	int i,j,x,y,z,lx,ly;
	T = read();
	while (T--){
		_k = cnt = 0;
		n = read(),m = read(),k = read();
		for (i = 1; i <= n; ++i) tp[i] = read() == 1 ? 1 : -1;
		for (i = 1; i <= n; ++i){
			p1[i] = ++cnt;
			for (j = 1; j <= k; ++j){p2[i][j] = ++cnt; p3[i][j] = ++cnt;}
		}
		memset(He,0,sizeof(int) * (cnt+5));
		while (m--){
			x = read(),y = read(),z = read();
			for (i = -k; i <= k; ++i){
				lx = Getp(x,i);
				ly = Getp(y,i + tp[y]);
				if (ly) add(lx,ly,z);
			}
			swap(x,y);
			for (i = -k; i <= k; ++i){
				lx = Getp(x,i);
				ly = Getp(y,i + tp[y]);
				if (ly) add(lx,ly,z);
			}
		}
		qa = read(),qb = read(),start = Getp(qa,tp[qa]);
		Dij();
		ans = INF;
		for (i = -k; i <= k; ++i){
			x = Getp(qb,i);
			if (dis[x] < ans) ans = dis[x];
		}
		if (ans == INF) puts("-1"); else write(ans),putchar('\n');
	}
	return 0;
}
```

---

## 作者：Augen_stern (赞：1)

## Part 1：分析题目

通过读题，我们知道了大中锋的目的：在尽可能短的时间里从起点 $s$ 到 $t$，且在这条路径中任意时间时经过的汉堡店和可乐店之差不能超过 $k$。

可以看出，这是一道分层图最短路。

## Part 2：算法求解

我们不妨令汉堡店的价值为 $-1$，可乐店的价值为 $1$；

因为经过的汉堡店和可乐店之差不能超过 $k$，又为了数组下标跑到负数上去，所以我们可以将 $|h-k|\in \left[ \ 0,2\times k\right]$ 定为安全（$h$ 为经过的汉堡店数量，$k$ 为经过的可乐店数量）。

最后还剩下一个问题：如何储存上一次的 $|h-k|$，而解决的办法也很简单，在最短路算法中更新完目标节点的最短距离时将此时的 $|h-k|$ 同时储存。

以复活了的 Spfa 为例：

```
void Spfa(int s) {
	queue< pair<int,int> > q; // 建立二元组
	for(int i=1; i<=n; i++) {
		for(int j=0; j<=k*2; j++) {
			dis[i][j]=INF;
			vst[i][j]=0;
		}
	}
	dis[s][k+sy[s]]=0;
	q.push(make_pair(s,k+sy[s])); // 同时进队
	while(!q.empty()) {
		int u=q.front().first; // 第一关键字
		int nowu=q.front().second; // 第二关键字
		q.pop();
		vst[u][nowu]=0;
		for(int i=h[u]; i; i=a[i].next) {
			int y=a[i].to;
			int noww=nowu+sy[y];
			if(noww>=0&&noww<=2*k&&dis[y][noww]>=dis[u][nowu]+a[i].v) { // 判断是否安全
				dis[y][noww]=dis[u][nowu]+a[i].v;
				if(!vst[y][noww]) {
					vst[y][noww]=1;
					q.push(make_pair(y,noww)); // 同时进队
				}
			}
		}
	}
}
```

**不需要任何优化的 Spfa 也可以轻松跑过。**

再在这里说明一下一种做法的错误性：再开两个数组，来储存一个节点经过的两店之差，代码如下：

```
void Spfa(int s) {
	queue<int> q;
	for(int i=1; i<=n; i++) dis[i]=INF,vst[i]=0,syh[i]=syk[i]=0; // h 为汉堡，k 为可乐
	dis[s]=0;
	q.push(s);
	if(sy[s]) syh[s]=1;
	else syk[s]=1;
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		vst[u]=0;
		for(int i=h[u]; i; i=a[i].next) {
			int y=a[i].to;
			if(dis[y]>dis[u]+a[i].v) {
				int hh=syh[y],kk=syk[y];
				if(sy[y]) syh[y]=syh[u]+1; // 1 是汉堡，0 是可乐
				else syk[y]=syk[u]+1;
				if(abs(syh[y]-syk[y])>k) {
					syh[y]=hh;
					syk[y]=kk;
					continue;
				}
				dis[y]=dis[u]+a[i].v;
				if(!vst[y]) {
					vst[y]=1;
					q.push(y);
				}
			}
		}
	}
}
```

**错误点为：可能存在多次更新同一节点，使两个数组与之前发生改变。**

## Part 3：CODE

完整的代码 ---- Spfa

尽管考试时推荐使用 Dij 算法，但题解区几乎都是 Dij，所以给出 Spfa 的代码，当然 Dij 和 Spfa 都只是求解这道题的工具，这道题的核心才是最重要的。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<math.h>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff
//#define int long long
using namespace std;
int T,n,m,k,st,ed,cnt=0,ans=INF;
int dis[100005][20],h[100005],vst[100005][20],sy[100005];
struct edge {
	int to,next,v;
} a[1000005];
void addedge(int x,int y,int z) {
	cnt++;
	a[cnt].to=y;
	a[cnt].v=z;
	a[cnt].next=h[x];
	h[x]=cnt;
}
void Spfa(int s) {
	queue< pair<int,int> > q; // 建立二元组
	for(int i=1; i<=n; i++) {
		for(int j=0; j<=k*2; j++) {
			dis[i][j]=INF;
			vst[i][j]=0;
		}
	}
	dis[s][k+sy[s]]=0;
	q.push(make_pair(s,k+sy[s])); // 同时进队
	while(!q.empty()) {
		int u=q.front().first; // 第一关键字
		int nowu=q.front().second; // 第二关键字
		q.pop();
		vst[u][nowu]=0;
		for(int i=h[u]; i; i=a[i].next) {
			int y=a[i].to;
			int noww=nowu+sy[y];
			if(noww>=0&&noww<=2*k&&dis[y][noww]>=dis[u][nowu]+a[i].v) { // 判断是否安全
				dis[y][noww]=dis[u][nowu]+a[i].v;
				if(!vst[y][noww]) {
					vst[y][noww]=1;
					q.push(make_pair(y,noww)); // 同时进队
				}
			}
		}
	}
}
signed main() {
	scanf("%d",&T);
	while(T--) {
		memset(h,0,sizeof(h));
		cnt=0;
		scanf("%d%d%d",&n,&m,&k);
		for(int i=1; i<=n; i++) {
			scanf("%d",&sy[i]);
			if(sy[i]==2) sy[i]=-1; // 可乐或汉堡 
		}
		for(int i=1; i<=m; i++) {
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			addedge(x,y,z);
			addedge(y,x,z); // 建图 
		}
		scanf("%d%d",&st,&ed);
		Spfa(st);
		for(int i=0; i<=2*k; i++) ans=min(ans,dis[ed][i]); // 在安全区寻找 
		if(ans!=INF) printf("%d\n",ans);
		else puts("-1");
	}
	return 0;
}
```

---

## 作者：ycy1124 (赞：1)

[前置知识。](https://blog.csdn.net/qq_44431690/article/details/108175827)
### 题意
题面很清楚，这里不多说。
### 思路
发现本题可以跑最短路，但是记录时枚举吃汉堡和可乐的数量肯定是不行的，于是考虑记录他们的差。

设 $dis_{i,j}$ 表示在第 $i$ 个点吃的汉堡和可乐的差为 $j$ 的最短路长度。由于差相同的对后面的影响也一样，所以无需记录吃的数量。对于记录差，当吃一个汉堡差就减一，吃可乐就加一，记录时给这个值加个 $k$ 即可。
### 代码
使用堆优化的 Dijkstra 实现。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,m,k,a[10005],ss,tt,tot;
int dis[10005][25];
struct Node{
    int to,w;
};
struct qaq{
    int p,k,w;
}b[200005];
vector<Node>qwq[10005];
inline void work1(int x){
    if(x*2+1<=tot&&b[x].w>b[x*2+1].w&&b[x*2].w>b[x*2+1].w){
        swap(b[x],b[x*2+1]);
        work1(x*2+1);
    }
    else if(x*2<=tot&&b[x].w>b[x*2].w){
        swap(b[x],b[x*2]);
        work1(x*2);
    }
}
inline void work(int x){
    if(x!=1&&b[x].w<b[x/2].w){
        swap(b[x],b[x/2]);
        work(x/2);
    }
}//手写堆
inline void dij(int p,int kk,int ww){
    if(a[p]==1){//如果吃的是汉堡
        kk++;
    }
    else{
        kk--;
    }
    if(abs(kk)>k){//当差的绝对值超过k
        return;
    }
    if(dis[p][kk+k]!=-1&&ww>dis[p][kk+k]){
        return;
    }
    dis[p][kk+k]=ww;
    for(auto it:qwq[p]){//遍历
        int kkk=kk;
        if(a[it.to]==1){
            kkk++;
        }
        else{
            kkk--;
        }
        if(abs(kkk)>k){//可行性剪枝（？
            continue;
        }
        else if(dis[it.to][kkk+k]!=-1&&dis[it.to][kkk+k]<=ww+it.w){//更优性剪枝（？
            continue;
        }
        b[++tot]={it.to,kk,ww+it.w};
        dis[it.to][kkk+k]=ww+it.w;
        work(tot);
    }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        cin>>n>>m>>k;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        for(int i=1;i<=m;i++){
            int u,v,w;
            cin>>u>>v>>w;
            qwq[u].push_back({v,w});
            qwq[v].push_back({u,w});
        }
        cin>>ss>>tt;
        b[++tot]={ss,0,0};
        for(int i=1;i<=n;i++){
            for(int j=0;j<=2*k;j++){//记得赋初值
                dis[i][j]=-1;
            }
        }
        while(tot){
            dij(b[1].p,b[1].k,b[1].w);//dijkstra
            swap(b[1],b[tot]);
            --tot;
            work1(1);
        }
        int ans=1e9;
        for(int i=0;i<=2*k;i++){
            if(dis[tt][i]!=-1){
                ans=min(ans,dis[tt][i]);
            }
        }
        if(ans!=1e9){
            cout<<ans<<'\n';
        }
        else{
            cout<<-1<<'\n';
        }
        for(int i=1;i<=n;i++){
            qwq[i].clear();
        }
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/198876534)加上快读快输之后可以拿下暂时的最优解。

---

## 作者：chichichichi (赞：1)

蒟蒻的第一道分层图题。

## 先看看什么是分层图

适用于一些图论题中，边权可以有多种选择，导致**结点状态**有许多的情况。

例如在结点 $u$ 到结点 $v$ 时，边权有 $w$ 和 $0$两种选择，就可以将原图复制一遍，得到两张图，再在两层图之间连边。如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xwt0x6ag.png)

如果不明白这道题要怎么用分层图，请往下看。

## 关于这道题

这道题除去**可乐汉堡的数量**的限制，就是最短路。

那么就从**可乐汉堡的数量**这个条件来进行分析。题目说我们只关心大中锋是否感觉很渴或很饿，实际上只关注可乐和汉堡差值的绝对值。

我们设 结点 $i$ 的状态为 ：$x_i$ ，表示从起点到结点 $i$ 的路径上所吃掉的**可乐数**$-$**汉堡数**。


根据我们定义的状态，可以将可乐的权值设为 $1$，将汉堡的权值设为 $-1$，在图中遍历时将路径上结点的权值累加，得出当前到达结点的状态。

根据题意，合法的状态为 $x_i\in [ -k, k\,] $ . 我们可以建 $2*k+1$ 层图，对应每一种状态，再根据原始图中每条边的两个端点的状态变化来连层之间的边。

来看个图帮助理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/mev31oip.png)

其中，红色是点的权（可乐和汉堡），$x$ 是层数（表示状态），黑色边是原始图中的边，蓝色边是层之间的边，在进行遍历时并不经过原始图中的边。

------
###  **思路**

我们从起点的状态所在的层中的起点出发（有点绕）。即：若起点处是可乐 ，则出发时状态为 **1**，应在第 **1** 层；若起点处是汉堡，则出发时状态为 **-1**，应在第 **-1** 层出发。

求出到达**每一层的终点**的最短路。因为不同的路径可能导致到达终点时状态不同。最后在所有状态中取最小值。

- 关于题目补充说明

	当路径中出现环时，在分层图上有两种情况。
    
    - 再次经过结点 $i$ 与第一次经过时的状态相同。因为边权为正，所以不可能出现。
    
    - 再次经过结点 $i$ 与第一次经过时的状态不同。此时更新的是另一层上的结点 $i$ ，因为状态不同，将其看作不同的点即可。

----

### 实现的细节

我们需要真的将原图复制成 $2*k+1$ 张图吗？从数据范围上来看没有问题， ~~但是没有必要~~


因为当我们在状态 $x$ 的结点 $u$ 时，可以根据边的另一端点 $v$ 的权值 $w$ 来判断出我们将要到达 $x+w$状态的结点 $v$。这样我们只要记住结点和当前状态即可。

最后！无负权边的图一定用dijstra！

注释也算比较详细（吧），欢迎私信或评论交流！

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int maxn=10100;
const int maxm=200100;
int n,m,tot,k,T,res=0x3f3f3f3f; 
int a[maxn],lin[maxn];
int to[maxm],ne[maxm];
int va[maxm];
void add(int u,int v,int w)
{//链式前向星存图 
	to[++tot]=v;
	ne[tot]=lin[u];
	va[tot]=w;
	lin[u]=tot;
}
int vis[maxn][50],dis[maxn][50];
//第一维表示结点编号 第二维表示状态 
struct node{
	int num,x,dist;//结点编号，状态，最短路长度 
	bool operator <(const node a)const//重载运算符 
	{
		return a.dist<dist;
	}
};
priority_queue<node>q;//重载运算符后大根堆->小根堆 
void dij(int s)
{
	//初始化 
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));
	priority_queue<node>emp;
	swap(q,emp);
	
	int c=(a[s]+k)%(2*k+1);//将状态[-k,k]转换到[0,2*k] 
	//c是起点的初始状态 
	dis[s][c]=0;
	//c状态的结点s的最短路长度  
	
	q.push((node){s,c,0});
	while(!q.empty())
	{
		int x=q.top().num;
		int w=q.top().x;
		q.pop();
		if(vis[x][w])
		continue;
		vis[x][w]=1;
		for(int i=lin[x];i;i=ne[i])
		{
			int y=to[i];
			int ww=w+a[y];//由目前所在的结点状态得出到达结点的状态 
			//要判断状态是否合法 
			if(ww>=0&&ww<=2*k&&dis[y][ww]>dis[x][w]+va[i])
			{
				dis[y][ww]=dis[x][w]+va[i]; 
				q.push((node){y,ww,dis[y][ww]});
			}
		}
	}
}
int main(){
	scanf("%d",&T);
	while(T)//多组数据 
	{
		T--;
		scanf("%d%d%d",&n,&m,&k);
		tot=0;//初始化 
		for(int i=1;i<=n;i++)
		{
			scanf("%d",a+i);
			//汉堡状态设为-1 
			if(a[i]==2)
				a[i]=-1;
		}
		for(int i=1;i<=m;i++)
		{
			int u,v,c;
			scanf("%d%d%d",&u,&v,&c);
			//无向图存边 
			add(u,v,c);
			add(v,u,c);
		}
		int s,t;
		scanf("%d%d",&s,&t);
		//跑最短路 
		dij(s);
		for(int i=0;i<=2*k;i++)
		{
			if(dis[t][i]<res)//在所有合法状态中找答案 
			res=dis[t][i];
		}
		if(res==0x3f3f3f3f)//没有找到答案 
		printf("-1\n");
		else printf("%d\n",res);
	}
	return 0;
}
```
### **See Ya！**

---

## 作者：ThomasX (赞：1)

**搬运官方题解。**

------------

如果没有可乐汉堡的限制，就是一道很简单的最短路，所以我们也考虑在最短路上做文章。对于每个点，有效状态是有限的。用$Ca$表示喝了可乐的数量，用$Cb$表示吃了汉堡的数量，有效的状态点其实是节点数量$\times(2k + 1)$ 个。所以我们在进行最短路的时候保存$dist[i][j]$的值。$i$表示到达第$i$个 节点，$j$表示$(Ca - Cb) == j$，然后进行最短路即可。由于数据构造算法的问题，题目可以卡掉一部分的spfa，由于spfa的玄学复杂度问题，建议使用dijkstra。

------------

std
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>

#define MAXV 10100
#define MAXE 200020
#define INF 0x3f3f3f3f3f3fLL
using std::priority_queue;

struct node{
	int w, t, nxt;
}edge[MAXE];

int head[MAXV], inde;
int status[MAXV];
long long int dist[MAXV][21];

void init(){
	memset(head, -1, sizeof(head));
	inde = 0;
}

void addedge(int s, int t, int w){
	edge[inde].t = t;
	edge[inde].w = w;
	edge[inde].nxt = head[s];
	head[s] = inde++;
}

struct dij_node{
	int at, k;
	long long val;
};

bool operator<(const dij_node& a, const dij_node& b){
	return a.val > b.val;
}


void dijkstra(int s, int mx){
	memset(dist, 0x3f3f, sizeof(dist));
	dij_node now, nxt;
	int i;

	now.val = 0;
	now.at = s;
	now.k = mx / 2 + status[s];
	dist[now.at][now.k] = 0;
	priority_queue<dij_node> que;
	que.push(now);
	while(!que.empty()){
		now = que.top();
		que.pop();
		if(now.val > dist[now.at][now.k]) continue;

		i = head[now.at];
		while(i >= 0){
			nxt.at = edge[i].t;
			nxt.k = now.k + status[edge[i].t];
			if(nxt.k < 0 || nxt.k >= mx){
				i = edge[i].nxt;
				continue;
			}
			if(dist[nxt.at][nxt.k] > dist[now.at][now.k] + edge[i].w){
				nxt.val = dist[now.at][now.k] + edge[i].w;
				dist[nxt.at][nxt.k] = nxt.val;
				que.push(nxt);
			}
			i = edge[i].nxt;
		}
	}
}

int main()
{
	freopen("park.in", "r", stdin);
	freopen("park.out", "w", stdout);	
	int m, n, k, i, s, t, w;
	int casen;
	scanf("%d", &casen);
	while(casen--){
		init();
		scanf("%d%d%d", &m, &n, &k);
		for(i = 1; i <= m; i++){
			scanf("%d", &status[i]);
			if(status[i] == 2) status[i] = -1;
		}
		for(i = 0; i < n; i++){
			scanf("%d%d%d", &s, &t, &w);
			addedge(s, t, w);
			addedge(t, s, w);
		}
	
		scanf("%d%d", &s, &t);
		dijkstra(s, k * 2 + 1);

		long long int res = INF;
		for(i = 0; i <= k * 2 + 1; i++){
			if(dist[t][i] != dist[0][0] && res > dist[t][i]){
				res = dist[t][i];
			}
		}
		if(res == INF){
			printf("-1\n");
		}
		else{
			printf("%lld\n", res);
		}
	}

	return 0;
}

```


---

## 作者：Foreverxxx (赞：0)

首先分析题目中需要的每一个条件：有 $n$ 个设施， $m$ 条道路，保证路线中吃的汉堡的数量和可乐的数量差值不超过 $k$ 。

刚开始想到的是 DP ，不过看到数据范围 $k \leq 10$ 就明白可以向分层图去思考解法。

对分层图的实现思路进行分析，我们设计一个 dist 数组进行转移，其中 $dist_{i,j}$ 表示他在第 i 个节点，当前可乐与汉堡数量的差值为 $j$ 时的最短路长度。

那么思路就很明显了，对于一个可以实现的状态，遍历该节点的出边，假设此时该节点的汉堡与可乐数量的差值为 $j$ ，如果遍历到下一个节点，如果卖的是可乐，则待转移的子节点 $u$ 的状态便是 $dist_{u,j+1}$ ，否则就是 $dist_{u,j-1}$ ，照着这种转移跑一边最短路就好了。

一些细节：

1、记得每一次都把数组清空！

2、注意转移的状态的合法性！( 当前状态 $j$ 必须在 $\{x \vert\  0 \leq x \leq 2 \times k\ \}$ 范围中)

3、要判断没有符合条件的路径的情况！

AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int T,n,m,k,s,t;
vector<int> to[10005],val[10005];
int col[10005];
bool vis[10005][22];
int dist[10005][22];
struct node{
	int now,depth,dis;
	bool operator < (const node& x) const {
		return x.dis<dis;
	}
};
bool in(int x){
	return 0<=x&&x<=2*k;
}
void Dijkstra(){
	priority_queue<node> q; 
	memset(dist,0x3f3f3f3f,sizeof dist);
	memset(vis,0,sizeof vis);
	int start_depth=col[s]+k;
	dist[s][start_depth]=0;
	vis[s][start_depth]=true;
	q.push((node){s,start_depth,0});
	int x,dep,len,tmp_depth,u,v;//good habits
	while(!q.empty()){
		x=q.top().now,dep=q.top().depth; q.pop();
		len=to[x].size();
		vis[x][dep]=false;
		for(register int i=0;i<len;i++){
			u=to[x][i],v=val[x][i];
			tmp_depth=col[u]+dep;
			if(in(tmp_depth)&&dist[u][tmp_depth]>dist[x][dep]+v){
				dist[u][tmp_depth]=dist[x][dep]+v;
				if(!vis[u][tmp_depth]) q.push((node){u,tmp_depth,dist[u][tmp_depth]}),vis[u][tmp_depth]=true;
			}
		}
	}
}
void init(){
	for(register int i=0;i<=1002;i++){
		to[i].clear();
		val[i].clear();
	}
}
int main(){
	T=read();
	while(T--){
		init();
		n=read(),m=read(),k=read();
		int tmp;
		for(register int i=1;i<=n;i++){
			tmp=read();
			if(tmp==1) col[i]=1;
			else col[i]=-1;
		}
		int uu,vv,ww;
		for(register int i=1;i<=m;i++){
			uu=read(),vv=read(),ww=read();
			to[uu].push_back(vv),to[vv].push_back(uu);
			val[uu].push_back(ww),val[vv].push_back(ww);
		}
		s=read(),t=read();
		Dijkstra();
		int ans=1e9;
		for(register int i=0;i<=2*k;i++){
			ans=min(ans,dist[t][i]);
		}
		if(ans==1e9) puts("-1");
		else printf("%d\n",ans);
	}
	return 0;
}
```



另外在放上经典 SPFA 代码（这些题出题人都不喜欢卡 SPFA 的吗？）

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int T,n,m,k,s,t;
vector<int> to[10005],val[10005];
int col[10005];
bool vis[10005][22];
int dist[10005][22];
bool in(int x){
	return 0<=x&&x<=2*k;
}
void SPFA(){
	queue< pair<int,int> > q;
	memset(dist,0x3f3f3f3f,sizeof dist);
	memset(vis,0,sizeof vis);
	int start_depth=col[s]+k;
	dist[s][start_depth]=0;
	vis[s][start_depth]=true;
	q.push(make_pair(s,start_depth));
	int x,dep,len,tmp_depth,u,v;
	while(!q.empty()){
		x=q.front().first,dep=q.front().second; q.pop();
		len=to[x].size();
		vis[x][dep]=false;
		for(register int i=0;i<len;i++){
			u=to[x][i],v=val[x][i];
			tmp_depth=col[u]+dep;
			if(in(tmp_depth)&&dist[u][tmp_depth]>dist[x][dep]+v){
				dist[u][tmp_depth]=dist[x][dep]+v;
				if(!vis[u][tmp_depth]) {
					q.push(make_pair(u,tmp_depth)),vis[u][tmp_depth]=true;
				}
			}
		}
	}
}
void init(){
	for(register int i=0;i<=1002;i++){
		to[i].clear();
		val[i].clear();
	}
}
int main(){
	T=read();
	while(T--){
		init();
		n=read(),m=read(),k=read();
		int tmp;
		for(register int i=1;i<=n;i++){
			tmp=read();
			if(tmp==1) col[i]=1;
			else col[i]=-1;
		}
		int uu,vv,ww;
		for(register int i=1;i<=m;i++){
			uu=read(),vv=read(),ww=read();
			to[uu].push_back(vv),to[vv].push_back(uu);
			val[uu].push_back(ww),val[vv].push_back(ww);
		}
		s=read(),t=read();
		SPFA();
		int ans=1e9;
		for(register int i=0;i<=2*k;i++){
			ans=min(ans,dist[t][i]);
		}
		if(ans==1e9) puts("-1");
		else printf("%d\n",ans);
	}
	return 0;
}
```



---

## 作者：JK_LOVER (赞：0)

## 题意
给你一张图，求出 $s,t$ 之间的最短路，满足一定的限制条件。[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p5340)
## 分析
如果没有限制条件，就是最短路。

- 而我们可以发现限制条件非常的小，那么我们完全可以考虑分层图，把一个点拆成多个点，来表示更多的信息。

- 为了代码的统一性，我们可以用虚拟节点联接 $s,t$ 。那么现在我们就得到了一张节点个数为 $O(n\times2k)$ 的图。

- 为了节约空间，我们没有必要真的把分成图中的边给表示出来，可以开二维数组解决。

- 多组数据下，一定要清空使用过的数组。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x;scanf("%d",&x);return x;}
struct Node{
	int pos,val,dis;
	bool operator<(Node a) const{
		return dis > a.dis;
	}
};
const int N = 200010;
struct Edge{int to,nxt,w;}e[N<<2];
int n,m,k,s,t,vis[N][30],dis[N][30],head[N],cnt = 1,val[N];
void add(int x,int y,int w){
	e[++cnt].nxt = head[x];e[cnt].to = y;e[cnt].w = w;head[x] = cnt;
}
priority_queue<Node> heap;
void Dij(int S,int T){
	while(heap.size()) heap.pop();
	memset(dis,0x3f,sizeof(dis));heap.push((Node){S,k,dis[S][k]=0});
	while(heap.size()){
		Node x = heap.top();heap.pop();
		if(vis[x.pos][x.val]) continue;
		vis[x.pos][x.val] = 1;
		for(int i = head[x.pos];i;i = e[i].nxt){
			int y = e[i].to;
			if(dis[y][val[y]+x.val] > dis[x.pos][x.val] + e[i].w && val[y] + x.val >= 0 && val[y] + x.val <= 2 * k){
				dis[y][val[y]+x.val] = dis[x.pos][x.val] + e[i].w;
				heap.push((Node){y,val[y]+x.val,dis[y][val[y]+x.val]});
			}
		}
	}
}
int main()
{
	int T = read();
	while(T--){
		cnt = 1;memset(vis,0,sizeof(vis));memset(val,0,sizeof(val));
		n = read();m = read();k = read();
		for(int i = 1;i <= n;i++) read()==1?val[i] = 1:val[i] = -1;
		for(int i = 1;i <= m;i++) {
			int a = read(),b = read(),c = read();add(a,b,c);add(b,a,c);
		}
		s = read();t = read();
		add(0,s,0);add(t,n+1,0);
		Dij(0,n+1);int ans = 0x3f3f3f3f;
		for(int i = 0;i <= 2*k;i++){
			ans = min(dis[n+1][i],ans);
		}
		ans==0x3f3f3f3f?printf("-1\n"):printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：The_BJX (赞：0)

蒟蒻第一道分层图，甚至一遍 AC 了，管理员给过罢。


## 分层图最短路

设想将地图压成一个平面，$2k+1$ 张地图垂直地叠在一起，中间的一层是 $0$，往下方是负层，上方是正。

![](https://cdn.luogu.com.cn/upload/image_hosting/g52tyefc.png)
*瞎画画，图像仅供参考。实际上连边并不是平行的。*


**层数**指的是汉堡和可乐数量之差。

因此吃一个汉堡可以记作层数 $+1$, 喝可乐可以记作层数 $-1$。

因此“拆点”，把每个点拆为同一个点在每一层上的“投影”。

跑最短路，边权是每条路长度。

输出答案即为 $s'$ 到 $t$ 点的每个投影点的最短路。

其中 $s'$ 即为在 $s$ 吃了汉堡或喝了可乐之后转移到的投影点。

```cpp
//一遍a了，卧槽

#include<iostream>
#include <cstring>
#include <queue>
using namespace std;
struct edge{
    int b;
    int next;
    int w;
}e[200000];
int tot;
int head[50000];
void add(int a, int b, int c)
{
    e[++tot].b=b;
    e[tot].next=head[a];
    head[a]=tot;
    e[tot].w=c;
}

int dis[10010][50];
int w[10010];//点权数组
//1代表汉堡
//-1代表可乐

struct node{
    int u;
    int state;//汉堡-可乐
    int dis;
    const bool operator<(const node b)const{
        return dis>b.dis;
    }
};
priority_queue<node> q;
int s,t;
int n,m,k;
void dijkstra()
{
    memset(dis,0x3f,sizeof(dis));
    dis[s][w[s]+25]=0;
    q.push({s,w[s],0});
    while(q.size())
    {
        node u=q.top();
        q.pop();
        if(u.dis!=dis[u.u][u.state+25])continue;
        for(int i = head[u.u]; i; i=e[i].next)
        {
            int v=e[i].b;
            if(u.state+w[v]>k)continue;
            if(u.state+w[v]<-k)continue;
            if(dis[v][u.state+w[v]+25]>dis[u.u][u.state+25]+e[i].w)
            {
                dis[v][u.state+w[v]+25]=dis[u.u][u.state+25]+e[i].w;
                q.push({v,u.state+w[v],dis[v][u.state+w[v]+25]});
            }
        }
    }
}

void init()
{
    memset(e,0,sizeof(e));
    tot=0;
    memset(head,0,sizeof(head));
    memset(w,0,sizeof(w));
}
int read()
{
    char ch=getchar();
    int x=0,cf=1;
    while(ch<'0'||ch>'9') {if(ch=='-') cf=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*cf;
}
int main()
{
    int T;cin >> T;
    while(T--)
    {
        n=read();
        m=read();
        k=read();
        init();
        for(int i = 1; i <= n; i++)
        {
            int tmp;
            tmp=read();
            w[i]=(tmp==1)?-1:1;
        }
        for(int i = 1; i <= m; i++)
        {
            int u,v,w;
            u=read();v=read();w=read();
            add(u,v,w);add(v,u,w);
        }
        s=read();t=read();
        dijkstra();
        int ans=1145141919;
        for(int i = 25-k; i<=25+k; i++)
        {
            ans=min(ans,dis[t][i]);
        }
        cout << ((ans==dis[0][0])?-1:ans) << endl;
    }
    return 0;
}

```

## 小细节

其实没有必要在实现中拆点，只需要给每次遍历到一个位置时记录 $state$ 表示层数，并开二维 $dis$ 数组。

---


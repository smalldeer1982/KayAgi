# [PKUSC2018] 真实排名

## 题目描述

小 C 是某知名比赛的组织者，该比赛一共有 $n$ 名选手参加，每个选手的成绩是一个非负整数，定义一个选手的排名是：成绩不小于他的选手的数量（包括他自己）。例如如果 $3$ 位选手的成绩分别是 $[1 , 2 ,2]$ ，那么他们的排名分别是 $[3,2,2]$ 。

拥有上帝视角的你知道所有选手的实力，所以在考试前就精准地估计了每个人的成绩，设你估计的第 $i$ 个选手的成绩为$A_i$，且由于你是上帝视角，所以如果不发生任何意外的话，你估计的成绩就是选手的最终成绩。

但是在比赛当天发生了不可抗的事故（例如遭受到了外星人的攻击），导致有一些选手的成绩变成了最终成绩的两倍，即便是有上帝视角的你也不知道具体是哪些选手的成绩翻倍了，唯一知道的信息是这样的选手恰好有 $k$ 个。

现在你需要计算，经过了不可抗事故后，对于第 $i$ 位选手，有多少种情况满足他的排名没有改变。

由于答案可能过大，所以你只需要输出答案对 $998244353$ 取模的值即可。


## 说明/提示

- 对于 $10\%$ 的数据，有 $1\leq n\leq 15$；
- 对于 $35\%$ 的数据，有 $1\leq n\leq 10^3$；
- 另有 $10\%$ 的数据，满足每个人的成绩都互不相同；
- 另有 $10\%$ 的数据，满足 $0\leq A_i\leq 10^5$；
- 另有 $10\%$ 的数据，满足 $k=85$，$0\leq A_i\leq 600$；
- 对于$100\%$的数据，有$1\leq k < n\leq 10^5$，$0\leq A_i\leq 10^9$。


## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3
1
2```

# 题解

## 作者：ModestCoder_ (赞：12)

冷静分析了一下，貌似很可做的样子

数据范围告诉我要用一个$O(nlogn)$的做法

对于每个数$a_i$，可以分类讨论，是否把这个数翻倍

 - $a_i$不翻倍，$[\frac{a_i+1}{2},a_i-1]$也不能翻倍，剩下的数假设有$x$个，答案为$C_{x}^{k}$
 - $a_i$翻倍，$[a_i,a_i*2-1]$都必须翻倍，设都要翻倍的数有$x$个，答案为$C_{n-x}^{k-x}$

如何求上面的$x$？用二分就好了

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
#define LL long long
using namespace std;
const LL qy = 998244353;
LL fac[maxn], inv[maxn], ans[maxn], a[maxn], b[maxn];
int n, k;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

LL C(int n, int m){ return m > n ? 0 : fac[n] * inv[n - m] % qy * inv[m] % qy; }

LL pow(LL n, LL k){
	if (!k) return 1;
	LL sum = pow(n, k >> 1);
	sum = sum * sum % qy;
	if (k & 1) sum = sum * n % qy;
	return sum;
}

int find1(int x){
	int l = 1, r = n, ans = 0;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (b[mid] >= x) ans = mid, r = mid - 1; else l = mid + 1;
	}
	return ans ? ans : n;
}

int find2(int x){
	int l = 1, r = n, ans = 0;
	while (l <= r){
		int mid = (l + r) >> 1;
		if (b[mid] <= x) ans = mid, l = mid + 1; else r = mid - 1;
	}
	return ans ? ans : 0;
}

int main(){
	n = read(), k = read();
	fac[0] = 1;
	for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % qy;
	inv[n] = pow(fac[n], qy - 2);
	for (int i = n - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % qy;
	for (int i = 1; i <= n; ++i) a[i] = b[i] = read();
	sort(b + 1, b + 1 + n);
	for (int i = 1; i <= n; ++i){
		if (!a[i]){ ans[i] = C(n, k); continue;	}
		int l = find2(a[i] % 2 == 0 ? a[i] / 2 - 1 : a[i] / 2), r = find1(a[i]), x = n - (r - l);
		ans[i] = C(x, k);
		l = find1(a[i]), r = find2(2 * a[i] - 1), x = r - l + 1;
		if (k >= x) (ans[i] += C(n - x, k - x)) %= qy;
	}
	for (int i = 1; i <= n; ++i) printf("%lld\n", ans[i]);
	return 0;
}
```


---

## 作者：TheLostWeak (赞：4)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu5368.html)

**大致题意：** 有$n$个数字，定义一个数的排名为不小于它的数的个数。现要随机将其中$k$个数乘$2$，求对于每个数有多少种方案使其排名不变。

### 分类讨论

对于这种题目，我们可以分类讨论一下，假设当前考虑第$i$个数的答案。

当$a_i$不被修改时，因为原先就$\ge a_i$的数不可能在修改后$<a_i$，所以我们就可以知道：

- 原先就$\ge a_i$的数可以随意修改。
- 原先$<a_i$的数如果修改后$\ge a_i$就不可以修改。

如果我们将原序列排序，设$t1$满足$2a_{t1}<a_i\le 2a_{t1+1}$，那么不可以修改的数就有$i-t1$个，而剩下的$n-(i-t1)$个数可以任意修改，即方案数为：

$$C_{n-(i-t1)}^k$$

当$a_i$被修改时，因为原先就$<a_i$的数在修改后必然依旧$<a_i$，所以我们就可以知道：

- 原先就$<a_i$的数可以随意修改。
- 原先就$\ge2a_i$的数可以随意修改。
- 原先$\ge a_i$且$<2a_i$的数必须修改。

如果我们将原序列排序，设$t2$满足$a_{t2}<2a_i\le a_{t2+1}$，那么必须修改的数就有$t2-i+1$个（注意$a_i$必须修改），而剩下的$n-(t2-i+1)$个数可以任意修改，即方案数为：

$$C_{n-(t2-i+1)}^{k-(t2-i+1)}$$

而对于$t1,t2$，我们可以在枚举$i$的同时进行维护。

### 特殊情况

注意，有两种特殊情况会把上面的推理过程卡掉。

- $a_i=0$。
  - 问题：我们会发现，根据$t2$的定义，此时$t2<i$，会出锅。
  - 解决方案：每次将$t2$向$i$取$max$。
- 出现相同的$a_i$。
  - 问题：在讨论过程中一些边界细节问题上会出锅。
  - 解决方案：不难发现，相同的$a_i$答案是一样的。而对于一些相同的$a_i$，其中第一个$a_i$用上述方法计算答案是不会出错的。因此将所有相同的$a_i$的答案都赋为第一个$a_i$的答案即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg 
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 100000
#define X 998244353
#define C(x,y) ((x)>=(y)?1LL*Fac[x]*IFac[y]%X*IFac[(x)-(y)]%X:0)
using namespace std;
int n,k,ans[N+5],Fac[N+5],IFac[N+5];
struct data {int p,v;I bool operator < (Con data& o) Con {return v<o.v;}}s[N+5];
I int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}
int main()
{
	RI i,t1,t2,lst;for(scanf("%d%d",&n,&k),Fac[0]=i=1;i<=n;++i) Fac[i]=1LL*Fac[i-1]*i%X;//预处理阶乘
	for(IFac[n]=Qpow(Fac[n],X-2),i=n-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;//预处理阶乘逆元
	for(i=1;i<=n;++i) scanf("%d",&s[s[i].p=i].v);//读入
	for(sort(s+1,s+n+1),s[0].v=-1,i=1,t1=t2=0;i<=n;++i)//记得排序
	{
		if(s[i].v==s[i-1].v) {ans[s[i].p]=lst;continue;}//如果与上一个数一样
		W(t1^n&&2*s[t1+1].v<s[i].v) ++t1;W(t2^n&&s[t2+1].v<2*s[i].v) ++t2;t2<i&&(t2=i);//更新t1,t2
		ans[s[i].p]=lst=(C(n-(i-t1),k)+(t2-i<=k?C(n-(t2-i+1),k-(t2-i+1)):0))%X;//计算答案
	}
	for(i=1;i<=n;++i) printf("%d\n",ans[i]);return 0;//输出答案
}
```

---

## 作者：nofall (赞：2)

分类讨论

$1.$不进行翻倍操作

我们可以发现$[\lceil\frac{a[i]}{2}\rceil,a[i])$这个区间的数不会翻倍，其他部分随便选,假设有$x$个。

所以$ans=\displaystyle\binom{n-x-1}{k}$

$2.$进行翻倍操作

我们可以发现$[a[i],2a[i])$不翻倍，其余随便搞，假设有$x$个。

所以$ans=\displaystyle\binom{n-x}{k-x}$

注意$a[i]=0$时要特判一下。

代码

```cpp
#include <bits/stdc++.h>
#define RG register
#define MAXN 100010
#define For(i, a, b) for (register int i = a, ___u = b; i <= ___u; ++i)
#define ForDown(i, a, b) for (register int i = b, ___d = a; i >= ___d; --i)
#define cmax(i, j) ((i) < (j) ? (i) = (j) : (i))
#define cmin(i, j) ((i) > (j) ? (i) = (j) : (i))
#define dmax(i, j) ((i) > (j) ? (i) : (j))
#define dmin(i, j) ((i) < (j) ? (i) : (j))
#define ddel(i, j) ((i) > (j) ? (i) - (j) : (j) - (i))
#define dabs(i) ((i) > 0 ? (i) : -(i))
#define eps 1e-7
#define int long long
#define mod 998244353

using namespace std;

int n, k, a[MAXN], b[MAXN], fac[MAXN], ifac[MAXN];

int C(int n, int m) {
	if(n < 0 || m < 0 || n < m) return 0;
	return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}	

int calc(int l, int r) {
    if (l > r) return 0;
    return upper_bound(a + 1, a + 1 + n, r) - lower_bound(a + 1, a + 1 + n, l);
}

char B[1 << 20], *S = B, D[1 << 20], *A = D - 1;
 
inline void F(RG int &x) {
	RG char *c = S;
	for(; *c < 48; ++c);
	x = 0;
	for(; *c > 47; ++c) x = 10 * x + (*c ^ 48);
	S = ++c;
}
 
inline void W(RG int x) {
	static char C[20];
	static int T;
	while(C[++T] = 48 + x % 10, x /= 10);
	while(*++A = C[T], --T);
	*++A = '\n';
}

signed main() {
	fread(B, 1, 1 << 20, stdin);
	fac[0] = fac[1] = ifac[0] = ifac[1] = 1;
    For(i, 2, MAXN) fac[i] = fac[i - 1] * i % mod, ifac[i] = (mod - mod / i) * ifac[mod % i] % mod;
    For(i, 2, MAXN) ifac[i] = ifac[i] * ifac[i - 1] % mod; 
	F(n), F(k);
	For(i, 1, n) F(a[i]), b[i] = a[i];
	sort(a + 1, a + n + 1);
	For(i, 1, n) {
		if(!b[i]) {
			W(C(n, k));
			continue;
		}
		int res = C(n - calc((b[i] + 1) / 2, b[i] - 1) - 1, k), tot = calc(b[i], b[i] * 2 - 1);
        (res += C(n - tot, k - tot)) %= mod, W(res);
	}
	fwrite(D, 1, A - D, stdout);
	return 0;
}
```

---

## 作者：Limit (赞：2)

~~PKUSC签到题~~

# 题目大意

给出一个长度为 $N$  的序列,序列中有 $K$ 个数会乘二,对于每个数计算在乘二后大于等于这个数的个数与乘二前没有发生变化的方案数.

# 分析

思路很清晰,可以将答案分为两个部分计算

## 当前位置的数没有乘二时

当前位置没有乘二,所以所有大于等于自己的元素是否乘二每有影响,如果一个数小于这个数的一半(不可以等于)那么这个数如果乘二也不会产生影响.于是可以计算出大于等于这个数的个数 $+$ 小于这个数一半的数的个数.接着只需要通过[组合数](https://baike.baidu.com/item/组合数/2153250?fr=aladdin)就可以计算你出来了.

## 当前位置的数乘二时

用一张图来解释起来比较简单:(下图序列为 $a=[1,3,3,4,6,7]$)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200218165657315.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N4eV9fb3J6,size_16,color_FFFFFF,t_70)

假如开始时的排完序后的序列是上面这个样子,对于第二个数大于等于它的数的个数为 $5$ (包括自己).现在需要将它的高度翻倍:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200218165940306.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N4eV9fb3J6,size_16,color_FFFFFF,t_70)

可以发现大于等于它的数的个数只剩下了一个,为了保证大于等于这个数的个数不变,在当前数乘二后**必须**将大于等于这个数小于这个数乘二的数都乘上二.

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020021817045114.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N4eV9fb3J6,size_16,color_FFFFFF,t_70)

虽然最后的序列可能不再是有序的,但是对于这个数大于等于它的数的个数没有改变,可以发现原来小于它的数这时如果乘二并不会影响,大于这个数两倍的数乘二自然也不会产生影响啦,于是又可以通到[组合数](https://baike.baidu.com/item/组合数/2153250?fr=aladdin)直接计算了.

# 组合数部分(会的可以跳过)

看到绝大多数的题解都不会涉及这部分内容,但是为了保证大多数人可以看懂,还是来写一下.

在 $N$ 个数中选 $M$ 个数的方案数: $C_{M}^{N} = \frac{N!}{M!(N-M)!}$ 但是在本题中 $N,M$ 都是 $1 \times 10^5$ 级别自然不可以暴力计算,可以发现在这个公式由三个阶乘组成,于是自然会想到预处理阶乘,然后计算[逆元](https://baike.baidu.com/item/逆元素/6307126?fromtitle=逆元&fromid=11054145&fr=aladdin).这样就可以做到 $O(N\log_2N)$ 预处理阶乘和逆元,$O(1)$ 计算,但是$O(N\log_2N)$还是有点慢了(虽然在本题中应该可以过),在一些 $2 \times 10^6 \leq N$ (差不多)时这个时间复杂度就很容易TLE了,$a$ 的逆元可以理解为 $\frac{1}{a}$ 所以说 $\frac{1}{i!}=\frac{1}{(i+1)!} \times i$,这样就可以先处理出 $N!$ 的逆元,接着只需要 $O(N)$ 的时间复杂度就可以计算出逆元了.

# 代码实现

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int maxN=3e5+7;
const int mod=998244353;
int Mod(long long a)//写一个Mod函数
{
	a%=mod;
	a+=mod;
	a%=mod;
	return a;
}
long long Inv(long long a,int b=mod-2)//计算一个数的逆元,其实就是一个快速幂
{
	long long result=1;
	while(b)
	{
		if(b&1)
		{
			result*=a;
			result%=mod;
		}
		a*=a;
		a%=mod;
		b/=2;
	}
	return result;
}
long long fac[maxN];//计算阶乘
long long inv[maxN];//计算逆元
int N,M;
int arr[maxN*2];
int sor[maxN*3];//用来离散化
int sum[maxN*3];
int tot=0;
int k;
map<int,int>Hash;//用来离散化
//因为比较懒,于是就先了一颗权值线段树来维护
struct SegmentTree
{
	int sum;
}sgt[maxN*4];
//线段树标准define
#define LSON (now<<1)
#define RSON (now<<1|1)
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
void PushUp(int now)//合并左右子树的值
{
	sgt[now].sum=sgt[LSON].sum+sgt[RSON].sum;
}
void Build(int now=1,int left=1,int right=tot)//建树
{
	if(left==right)//叶节点直接赋值
	{
		sgt[now].sum=sum[left];
		return;
	}
	Build(LEFT);
	Build(RIGHT);
	PushUp(now);//合并
}
//本题不需要修改
int QueryBigger(int num,int now=1,int left=1,int right=tot)
//计算大于等于的数的个数
{
	if(num<=left)
	{
		return sgt[now].sum;
	}
	if(right<num)
	{
		return 0;
	}
	return QueryBigger(num,LEFT)+QueryBigger(num,RIGHT);
}
int QuerySmaller(int num,int now=1,int left=1,int right=tot)
//计算小于等于的数的个数
{
	if(right<=num)
	{
		return sgt[now].sum;
	}
	if(num<left)
	{
		return 0;
	}
	return QuerySmaller(num,LEFT)+QuerySmaller(num,RIGHT);
}
int QuerySmaller_(int num,int now=1,int left=1,int right=tot)
//计算小于的数的个数
{
	if(right<num)
	{
		return sgt[now].sum;
	}
	if(num<=left)
	{
		return 0;
	}
	return QuerySmaller_(num,LEFT)+QuerySmaller_(num,RIGHT);
}
//用完就清空define,防止与其他地方冲突
#undef LSON
#undef RSON
#undef MIDDLE
#undef LEFT
#undef RIGHT
int main()
{
	scanf("%d%d",&N,&k);
	int cnt=0;
	fac[1]=1;
	REP(i,2,N)//预处理阶乘
	{
		fac[i]=Mod(fac[i-1]*i);
	}
	inv[N]=Inv(fac[N]);//计算N!的逆元
	DOW(i,N-1,0)
	{
		inv[i]=Mod(inv[i+1]*(i+1));//通过优化以后的方法O(N)计算所有阶乘的逆元
	}
	REP(i,1,N)
	{
		scanf("%d",&arr[i]);//对于每个数它与它的两倍和一半会在操作中用到
		sor[++cnt]=arr[i];
		sor[++cnt]=arr[i]/2;
		sor[++cnt]=arr[i]*2;
	}
	//离散化部分
	sort(sor+1,sor+1+cnt);
	sor[0]=-114514233;
	REP(i,1,cnt)
	{
		if(sor[i]!=sor[i-1])
		{
			Hash[sor[i]]=++tot;
		}
	}
	REP(i,1,N)//将数放入
	{
		sum[Hash[arr[i]]]++;
	}
	Build();//建树
	long long answer;//计算答案
	int all;//当前数不乘二时有多少数乘二不会造成影响
	int must;//计算如果当前数乘二时有多少数必须乘二
	int p,q;//计算时需要用到的一些变量
	REP(i,1,N)
	{
		all=QueryBigger(Hash[arr[i]]);//大于等于自身的数的个数肯定不会影响
		if(arr[i]&1)all+=QuerySmaller(Hash[arr[i]/2]);//这里需要根据这个数奇偶性查询乘二后仍然小于这个数的个数
		else all+=QuerySmaller_(Hash[arr[i]/2]);
		all-=1;//将自己减去
		answer=Mod(Mod(fac[all]*inv[k])*inv[all-k]);//通过组合数公式计算方案数
		if(arr[i]==0)must=1;else//需要特判一下0
		must=QuerySmaller_(Hash[arr[i]*2])-QuerySmaller_(Hash[arr[i]]);//必须乘二的数的个数为小于这个数乘二的数的个数-小于这个数的数的个数
		if(must<=k)//如果可以做到全部乘二
		{
			p=N-must;//乘二不会造成影响的数的个数
			q=k-must;//还可以有几个数乘二
			answer+=Mod(Mod(fac[p]*inv[q])*inv[p-q]);//计算方案数
		}
		printf("%lld\n",answer%mod);//输出答案
	}
	return 0;
}
```

---

## 作者：Fading (赞：1)

$PKUSC$ 良心签到题~

这道题的细节还是比较多的，但这并不影响选手的成绩（$IOI$赛制）

应该全场切吧...

我们大力分类讨论，就可以切掉此题~

对于一个数$x$，我们计算有多少种情况可以让它排名不变。

对于除$x$外的数，我们分$5$类讨论：

第$1$类 $\times 2<x$的数 $c_1$个 

第$2$类 $\times 2\geq x$的数，且本身$x$它小的数 $c_2$个 

第$3$类 等于$x$的数 $c_3$个 (不算$x$本身)

第$4$类 本身比$x$大，$<2x$的数 $c_4$个 

第$5$类 本身比$x$大，$\geq 2x$的数 $c_5$个 

然后讨论两种情况，最后用加法原理： 

### 如果$x$不乘$2$

$c_1,c_3,c_4,c_5$随意$\times 2$，对答案毫无影响。

答案就是$C_{c_1+c_3+c_4+c_5}^{k}$

### 如果$x$乘$2$

那么$x\times 2$后$<2x$的数是$c_1+c_2+c_3+c_4$个。

显然其排名比原来少了$c_3+c_4$

为了使排名不变，必须要让这些数$\times 2$。 

所以要选这$c_3+c_4$个人$\times 2$。

如果$k-1<c_3+c_4$，方案为$0$。

否则，剩下的$k-1-c_3-c_4$分配给$c_1,c_2,c_5$，让其随意$\times 2$。

答案就是$C_{c_1+c_2+c_5}^{k-1-c_3-c_4}$。

### 最终答案

对于每一个数$x$，答案就是

$$C_{c_1+c_3+c_4+c_5}^{k}+C_{c_1+c_2+c_5}^{k-1-c_3-c_4}$$

### 实现和细节

注意到$0$比较坑，所以这种情况可以直接输出$C_n^k$。

怎么求$c_1,c_2...$呢？

先排序，然后等价于求原序列中有多少数$\in[l,r]$。

可以离散化$+$前缀和，可以二分，也可以暴力动态开点线段树。

然后我为了偷懒，我写了$std::map+$前缀和，成功跑到了$luogu$最后一页......

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
struct man{
	int id,x;
}x[400001];
ll ans[400001],n,K,inv[400001],fac[400001];
map<ll,ll> mp,mp0;
inline ll C(ll n,ll m){
    if (n<m) return 0;
    return fac[n]*inv[m]%ljc*inv[n-m]%ljc;
}
inline bool cmp(man a,man b){
	return a.x<b.x;
}
#define mid ((lb+rb)>>1)
signed main(){
	n=read(),K=read();
    fac[0]=inv[0]=inv[1]=1;
    for (ll i=1;i<=n;i++) fac[i]=fac[i-1]*i%ljc;
    for (ll i=2;i<=n;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;
    for (ll i=2;i<=n;i++) inv[i]=inv[i-1]*inv[i]%ljc;
    for (int i=1;i<=n;i++){
    	x[i].id=i;x[i].x=read();
    	mp0[x[i].x]++;
		if (!mp0.count(x[i].x*2)) mp0[x[i].x*2]=0;
		if (!mp0.count(x[i].x/2)) mp0[x[i].x/2]=0;
	}
	sort(x+1,x+1+n,cmp);
	ll sum=0;
	for (auto i:mp0){
		mp[i.first]=i.second+sum;
		sum+=i.second;
	}
	for (int i=1;i<=n;i++){
		if (x[i].x==0){ans[x[i].id]=C(n,K);continue;}
		ll c1=0,c2=0,c3=0,c4=0,c5=0,Ans=0;
		c1=mp[x[i].x/2]-(x[i].x%2?0:mp0[x[i].x/2]);c3=mp0[x[i].x];
		c2=mp[x[i].x]-c3-c1;c4=mp[x[i].x*2]-mp0[x[i].x*2]-c3-c2-c1;
		c5=mp[x[n].x*2]-c4-c3-c2-c1;c3--;
		Ans=C(c1+c3+c4+c5,K);
		if (K-1>=c3+c4) Ans=(Ans+C(c1+c2+c5,K-1-c3-c4))%ljc;
		ans[x[i].id]=Ans;
	}
	for (int i=1;i<=n;i++){
		printf("%lld\n",ans[i]);
	}
	return 0;
}

```


---

## 作者：zhenglier (赞：1)

## 组合数学

对每个数，先分类讨论，将答案分为这个数有翻倍和这个数没翻倍。

在讨论前，我们规定：$low(x)$为小于等于这个数的数的个数，当前数为$x$。
### subtask1
如果这个数没翻倍：我们考虑哪些数翻倍不会影响这个数的排名，一种是翻倍后依然**小于**$x$的，一种是本来就**大于等于**$x$的。

那么对于第一种情况，情况数为

$$C(low((x+1)/2-1)+n-low(x-1)-1,k)$$

($C(n,m)$为组合数，下同)

这里前面一项最后的减一表示不能选当前数。
### subtask2
如果这个数翻倍了：我们考虑那些数必须翻倍，那些数可以选择性翻倍。

必须翻倍的数就是为了维持原排名所需翻倍的数，就是**小于**$2x$同时**大于等于**$x$的所有数。

选择翻倍的数就是翻倍后不会影响当前排名的数，就是**小于**$x$的数和**大于等于**$2x$的数的数。

这里要注意，如果必须翻倍的数大于$k$那么在这种讨论中就不可能有情况满足当前数排名不变。

设必须翻倍的数为$js=low(2x-1)-low(x-1)$，那么对于第二种情况，情况数为

$$C(n-js,k-js)$$

那么答案就是两者相加了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010,p=998244353;
int add(int x,int y){
    return (x+y)%p;
}
int mul(int x,int y){
    return 1ll*x*y%p;
}
int n,k;
int a[N],b[N];
int fac[N],inv[N];
int C(int n,int m){
    return mul(fac[n],mul(inv[m],inv[n-m]));
}
int mpow(int a,int n){
    int ret=1;
    while(n){
        if(n&1)ret=mul(ret,a);
        a=mul(a,a);
        n/=2;
    }
    return ret;
}
int low(int x){
    return (upper_bound(b,b+n+1,x)-b-1);
}
int main(){
    inv[0]=fac[0]=1;
    for(int i=1;i<N;++i)fac[i]=mul(fac[i-1],i);
    inv[N-1]=mpow(fac[N-1],p-2);
    for(int i=N-2;i;--i)inv[i]=mul(inv[i+1],i+1);
    cin>>n>>k;
    for(int i=1;i<=n;++i){
        scanf("%d",a+i);
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    b[0]=-1e9+7;
    b[n+1]=0x7fffffff;
    for(int i=1;i<=n;++i){
        if(a[i]==0){
            printf("%d\n",C(n,k));
            continue;
        }
        int ret=C(low((a[i]+1)/2-1)+n-low(a[i]-1)-1,k);
        int js=low(2*a[i]-1)-low(a[i]-1);
        if(k>=js){
            ret=add(ret,C(n-js,k-js));
        }
        printf("%d\n",ret);
    }
}
```


---

## 作者：ycyaw (赞：1)

签到题。

分两种情况，一种自己不翻倍，一种翻倍。

**不翻倍的情况：**

对于一个数，设 不翻倍大于等于它的个数$+$翻倍了还小于它的个数 这两者的和为$sum$，那么方案为$C_{sum}^k$。

**翻倍的情况：**

对于一个数，设有$x$个数翻倍后大于等于它（它指的是这个数翻倍后的值，下同），$y$个数大于等于它，$z$个数翻倍后还是小于它，以及这个数翻倍后增长的排名$p$。那么方案为$C_{x}^{p}\times C_{y+z}^{k-p-1}$。

注意还有$a_i=0$要特判，方案数为$C_{n}^{k}$。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
#define mo 998244353
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
const int N=100005;
int n,k,ans[N],rk[N],l[N],jc[N],ny[N];
struct node{
    int v,id;
    friend bool operator < (node A,node B){
        return A.v<B.v;
    }
}a[N];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}
    return ret*ff;
}
void write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}
void writeln(int x){write(x),hh;}
void writesp(int x){write(x),pc(' ');}
int ksm(int x,int y){
    int res=1;
    while(y){
        if(y&1) res=res*x%mo;
        y>>=1;
        x=x*x%mo;
    }
    return res;
}
int C(int x,int y){
    if(x<y||y<0) return 0;
    return jc[x]*ny[y]%mo*ny[x-y]%mo;
}
signed main(){
    n=read(),k=read();
    for(int i=1;i<=n;i++) a[i].v=read(),a[i].id=i;
    sort(a+1,a+n+1);
    a[0].v=-1;
    for(int i=1;i<=n;i++){
        if(a[i].v==a[i-1].v) rk[i]=rk[i-1],l[i]=l[i-1];
        else rk[i]=n-i+1,l[i]=i;
    }
    jc[0]=1;
    for(int i=1;i<=n;i++) jc[i]=jc[i-1]*i%mo;
    ny[n]=ksm(jc[n],mo-2);
    for(int i=n-1;i>=0;i--) ny[i]=ny[i+1]*(i+1)%mo;
    for(int i=1;i<=n;i++){
        if(a[i].v==0){
            ans[a[i].id]=C(n,k);
            continue;
        }
        int x=n-l[i],y=upper_bound(a+1,a+n+1,(node){(a[i].v+1)/2-1,0})-a-1,id=a[i].id,z;
        ans[id]=C(x+y,k);
        int pos=lower_bound(a+1,a+n+1,(node){a[i].v*2,0})-a,zhang=rk[i]-rk[pos]-1;
        x=pos-1-l[i],y=n-pos+1,z=l[i]-1;
        ans[id]=(ans[id]+C(x,zhang)*C(y+z,k-zhang-1)%mo)%mo;
    }
    for(int i=1;i<=n;i++) writeln(ans[i]);
    return 0;
}
```


---


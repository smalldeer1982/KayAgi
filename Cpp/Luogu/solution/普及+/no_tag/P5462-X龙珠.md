# X龙珠

## 题目描述

“X龙珠”是一款益智小游戏。游戏中有 $n(2|n)$ 个编号互不相同龙珠按照给定的顺序排成一个队列，每个龙珠上面都有一个编号。每次操作时，选择并取出龙珠队列中**相邻**的两个龙珠，放到目标队列的末尾（目标队列最开始是空的，且这两个龙珠的前后顺序不变），然后去除原龙珠队列的空隙。反复多次，直到原龙珠队列为空。可见，因为决策不一样导致目标队列顺序不一样。现在请求出所有方案中、目标队列字典序最大的方案。只需要给出目标队列即可。

例如，当原龙珠队列是 [1,3,2,4] 时，可以先取出 3 和 2，此时目标队列是 [3,2]，原龙珠队列是 [1,4]；再将剩下两个龙珠放入目标队列，得到目标队列是 [3,2,1,4]

## 说明/提示

对于 20% 的数据，$n\le10$。  
对于 60% 的数据，$n\le10^3$。  
对于 100% 的数据，$n\le10^5$，龙珠编号不超过 n。


## 样例 #1

### 输入

```
4 
3 1 4 2```

### 输出

```
4 2 3 1```

## 样例 #2

### 输入

```
6 
6 5 4 1 3 2```

### 输出

```
6 5 4 1 3 2```

# 题解

## 作者：叫我DJ (赞：85)

新鲜的题！！！

先用链表存储每一个编号的数前一个和后一个数的编号，最后由大到小枚举一遍，将没有用过的点连上后一个一起输出（注意它能输出，当且仅当它后面有数）

输出以后记得把它前一个数和它后面的后面的数连上

然后，就可以上代码了

```cpp
#include <cstdio>

int n,a[100001],k[100001],x[100001],i;

int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;++i){
		scanf("%d",&a[i]);
		k[a[i-1]]=a[i];
		x[a[i]]=a[i-1];}
	for(i=n;i>=1;--i)
		if(k[i])printf("%d %d ",i,k[i]),k[x[i]]=k[k[i]],x[k[x[i]]]=x[i],k[k[i]]=0;
	return 0;
}
```


---

## 作者：LesterYu (赞：11)

对于这道题，要使字典序尽可能地大，每一次都必定要取不在队尾的最大数及其右侧数，如果暴力去做的话，O（n^2）的复杂度必定过不了。略加观察与思考，不难发现每次取出的数对在一开始就已然组好了。

例如  4 2 3 6 5 1，从大到小取过去，可以分成（6，5），（4，2）和（3，1）三个数对。我们知道，一个数的命运要么是作为当前最大数取走，要么被左侧的“最大数”带走。这样的话，第一个数是不可能被“带走”的，且如果第二个数小于第一个，它必然被第一个数“带走”，然后接下来的第三个数就成了第一个数。则当我们把数用栈存放时，若栈顶数大于读入数时，可以直接将栈顶数弹出，与读入数组成数对；若小于，则读入数入栈，栈中数从大到小依次与右侧较小数组合。

最后，再把栈中剩余的数（单调递增数列），依次组好。就可以得到组合完毕的n/2个数对。

接下来就简单了，排序+输出，复杂度=sort复杂度=O（nlogn）

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#define MAX 100001
using namespace std;
struct node{
	int t,m;
}k[MAX];
int n,cnt,knt,a[MAX],q[MAX];

bool cmp(node x,node y){//结构体排序
	return x.t<y.t;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]>q[cnt]) q[++cnt]=a[i];
		else{
			k[++knt].t=q[cnt];
			k[knt].m=a[i];
			cnt--;//读入数小于栈顶数，弹出
		}
	}
	while(cnt){
		k[++knt].t=q[cnt-1];
		k[knt].m=q[cnt],cnt-=2;//弹出剩余部分
	}
	sort(k+1,k+n/2+1,cmp);//快乐sort
	for(int i=n/2;i;i--){
		printf("%d %d ",k[i].t,k[i].m);
	}
}
```


---

## 作者：_Atyou (赞：7)

## 算法：并查集乱搞

大致就是要倒序循环，从大到小把能两个两个取的按顺序两个两个取，所以要先预处理出每个数所处的位置。

难点就是如何在已经有几个数字被删除的队列中快速确定下一个位置。

受某道年代已久的题的启发，其实用并查集也能维护下一个位置。

把删除的位置和下一个位置合并，父亲为后面一个联通块。这样每次get后的就是该联通块的最后一个位置。这样的一个位置其实就是下一个还未取的数字。

如果下一个位置是n+1，证明后面没位置，当前数自然不能取。

每次取完后把当前和下一个位置和下下个位置合并。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
const int N = 100000 + 5;

int n, pos[N], v[N], a[N], fa[N], ans[N], m;

//pos[i]表示数字i在队列中处的位置
//v[i]表示数字i是否被取过
//a[i]表示位置i的数字
//ans[i]储存答案序列

inline int get(int x) {
    if (fa[x]==x) return x;
    return fa[x]=get(fa[x]);
}

int main() {
    scanf("%d", &n);
    fa[n+1]=n+1;
    for (reg int i=1; i<=n; ++i) {
        fa[i]=i;
        scanf("%d", &a[i]); pos[a[i]]=i;
    }
    for (reg int i=n; i; --i) {
        if (v[i]) continue; //当前数字已被取过
        int nxtpos=get(pos[i]+1); //找当前数字位置的下一个位置
        if (nxtpos==n+1) continue; //下一个位置不存在
        v[i]=v[a[nxtpos]]=1; //标记
        fa[get(pos[i])]=get(nxtpos); fa[get(nxtpos)]=get(nxtpos+1); //合并，注意顺序
        ans[++m]=i; ans[++m]=a[nxtpos];
    }
    for (reg int i=1; i<=n; ++i) printf("%d ", ans[i]);
    return 0;
}

```


---

## 作者：Tiphereth_A (赞：7)

我太菜了，只会用线段树+双向链表做QwQ

在读入时直接将序列转化成可能输出的数对

如样例1为``(3,1),(1,4),(4,2)``

线段树维护**全局最大数对**，双向链表**便于寻找前驱后继**

每次直接输出最大数对并删除与它有交集的数对

另外有一点需要注意：

如果最大数对出现在中间时，在删除自身、前驱和后继后会产生一个新的数对

例如``(3,4),(4,2),(2,1)``删除之后会产生数对``(3,1)``
```cpp
#include <bits/stdc++.h>
#define _fp(i,l,r) for(register int i=(l);i<=(r);++i)
#define _rep(i,l,r) for(register int i=(l);i<(r);++i)
const int N=1e5+5;
//为了便于套板子，所以把线段树放到namespace里了
namespace Seg{
//为了清晰，用了一些宏定义
#define _now tree[p]
#define _lch tree[p].l
#define _rch tree[p].r

    struct node {
        int first,second,pos; //设pos是为了便于找下标，从而进行删除/修改操作
    } pair[N]; //存数对
    
    struct segtree{
        node val;
        int l,r;
        inline bool operator<(const segtree& a) const {
            return (val.first==a.val.first)? val.second<a.val.second : val.first<a.val.first;
        }
        inline void print() {print(val.first,val.second);} //这里用了快写模板，注意修改
    } tree[N<<2];
    int cnt;
    //这里用内存池式写法是因为之前写的时候设想的是直接将没删除的儿子直接向上合并到父节点
    //后来发现和其他操作搭配起来有点困难
    //但我懒得换常见的数组写法了
    
    node _max(const segtree &a,const segtree &b) {
        return a<b?b.val:a.val;
    }
    void push_up(int p) {_now.val=_max(tree[_lch],tree[_rch]);}
    void build(int &p,int l,int r) {
        p=++cnt;
        if(l==r) {
            _now={pair[l],0,0};
            return;
        }
        int mid=l+((r-l)>>1); //防溢出
        build(_lch,l,mid);
        build(_rch,mid+1,r);
        push_up(p);
    }
    void del(int p,int l,int r,int target) {
        if(_now.val.first==-1) return;
        if(l==r) {
            _now={pair[target]={-1,-1,target},0,0};
            return;
        }
        int mid=l+((r-l)>>1);
        if(target<=mid) del(_lch,l,mid,target);
        else del(_rch,mid+1,r,target);
        push_up(p);
    }
    void modify(int p,int l,int r,int target,const node &a) {
        if(l==r) {
            _now={pair[target]=a,0,0}; //修改后一定要记得更新原数组
            return;
        }
        int mid=l+((r-l)>>1);
        if(target<=mid) modify(_lch,l,mid,target,a);
        else modify(_rch,mid+1,r,target,a);
        push_up(p);
    }
    //以上都是线段树常规操作
}
struct list {
    int pre,suc; //pascal后遗症
}id[N]; //双向链表
int head,rear,a[N],n;

inline void del_rear(const int &p,const int &pre) {
    Seg::del(1,1,n,p); Seg::del(1,1,n,pre);
    //链表常规操作
    rear=id[pre].pre; id[pre].pre=id[rear].suc=0;
}

inline void del_head(const int &p,const int &suc) {
    Seg::del(1,1,n,p); Seg::del(1,1,n,suc);
    //链表常规操作*2
    head=id[suc].suc; id[suc].suc=id[head].pre=0;
}
inline void del(const int &p,const int &pre,const int &suc) {
	//因为上面的代码中删除也会更新原数组，所以要把修改操作放到前面
    Seg::modify(1,1,n,p,{Seg::pair[pre].first,Seg::pair[suc].second,p});
    
    Seg::del(1,1,n,pre);
    //链表常规操作*3
    if(!id[pre].pre) head=p;
    else id[id[pre].pre].suc=p;
    id[p].pre=id[pre].pre;

    Seg::del(1,1,n,suc);
    //链表常规操作*4
    if(!id[suc].suc) rear=p;
    else id[id[suc].suc].pre=p;
    id[p].suc=id[suc].suc;
}
int main() {
    read(n); //这里用了快读模板，注意修改
    _fp(i,1,n) read(a[i]);
    --n; //为了方便后面写代码
    _fp(i,1,n) {
        Seg::pair[i]={a[i],a[i+1],i};
        id[i]={i-1,i+1};
    }
    int tmp1;
    head=1; rear=n; id[n].suc=0;
    Seg::build(tmp1,1,n);
    _rep(i,1,(n+1)>>1) {
        Seg::tree[1].print(); //输出全局最值
        int tmp=Seg::tree[1].val.pos;
        int suc=id[tmp].suc,pre=id[tmp].pre; //找前驱和后继
        //删数对
        //如果是表头就删掉当前和后继
        //如果是表尾就删掉当前和前驱
        //如果在中间就删除前驱和后继，并把当前节点修改一下
        if(tmp==rear) del_rear(tmp,pre);
        else if(tmp==head) del_head(tmp,suc);
        else del(tmp,pre,suc);
    }
    Seg::tree[1].print(); //把它单独提出来是为了省去不必要的操作
    return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：7)

##### ~~在犇犇里发现好像就窝一个人用排序+双向链表~~
### 思路：把数排序，然后从大向小输出（一次输出2个），遇到输出过的就跳过，同时最后一个不能作为一次输出的第一个数输出
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
#define N 100002
struct node
{
	int num/*数*/,id/*对应的数组下标，排序后就乱了，所以要先存起来*/;
	bool operator<(const node&kkk)const{return num>kkk.num;}//排序的方式，个人喜欢重载运算符
}b[N];
int n,a[N],lft[N],nxt[N];bool v[N];
main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;++i){scanf("%d",a+i);nxt[i]=i+1;lft[i]=i-1;b[i].id=i;b[i].num=a[i];}//输入
	sort(b+1,b+1+n);//排序
	for(register int i=1;i<=n;++i)
	{
		if(nxt[b[i].id]>n)continue;//这是最后一个，不行
		if(v[b[i].id])continue;//这个数在前面用过了
		printf("%d %d ",b[i].num,a[nxt[b[i].id]]);//行，输出答案
		v[b[i].id]=1;v[nxt[b[i].id]]=1;//标记这2个数用过了
		//双向链表基本操作：同时删除2个节点
		nxt[lft[b[i].id]]=nxt[nxt[b[i].id]];//修改上个节点的向后指针为下一个节点
		lft[nxt[nxt[b[i].id]]]=lft[b[i].id];//修改下个节点的向前指针为上一个节点
	}
}/**/
```

---

## 作者：mdzzzzzzzzzz (赞：6)

# 我看大家都用了线段树（或链表）

#### 所以我就发个贪心的吧

题意我就不分析了，没认真看题的去看题。~~绝不是因为作者懒~~

我们用结构体保存每个珠子的大小和位置

我们再定义一个end变量，记录最后一个珠子的位置

然后用sort从大到小排序珠子的大小

然后每次找最大的珠子，只要这个珠子没有用过且不是最后一个，就放入答案。

# 为什么能贪心呢？

### 因为答案求字典序最大，所以先入答案的数字对字典序的影响是大于后入答案的数字的。（最关键的是第一句话中的“互不相同”）

### 时间复杂度![](https://i.loli.net/2019/07/16/5d2d37d0dc9dd52451.png)~~可能会更大~~

贴代码（100分）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct hh
{
    int a,id;
}a[100020];
int n,zx[100020],v[100020],ans[100020],end;
bool cmp(hh x,hh y)
{
    return x.a>y.a;
}
int main()
{
    scanf("%d",&n);
    end=n;
    for(int i=1;i<=n;i++)
    {
        int c;
        scanf("%d",&c);
        a[i].a=c;//大小 
        a[i].id=i;//位置 
    }
    sort(a+1,a+n+1,cmp);//按大小从大到小排序 
    for(int i=1;i<=n;i++)
    {
        zx[a[i].id]=i;//指向数组：记录id为x的是第i个数
    }
    int t=0;
    for(int i=1;i<=n;i++)
    {
        if(v[a[i].id])//用过的点就不用了 
        continue;
        if(a[i].id==end)//最后一个不能选 
        continue;
        ans[++t]=a[i].a;//选择了这一对龙珠的第一个 
        v[a[i].id]=1;//标记 
        int lll=a[i].id+1;
        while(1)//找第二个点 
        {
            if(!v[lll])
            {
                ans[++t]=a[zx[lll]].a;
                int llll=a[zx[lll]].id-1;
                if(a[zx[lll]].id==end)//如果第二个珠子是最后一个 
                while(1)//转移end 
                {
                    if(!v[llll])
                    {
                        end=llll;
                        break;
                    }
                    else
                    llll--;
                }
                v[lll]=1;//标记
                break;
            }
            else
            lll++;
        }
    }
    if(n%2==1)//有奇数个珠子，剩下的直接放入目标序列 
    {
        for(int i=1;i<=n;i++)
        if(v[i])
        {
            ans[++t]=a[i].a;
            break;
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d ",ans[i]);
    }
    return 0;
}
```


---

## 作者：Clu3ter (赞：6)

[![](https://ae01.alicdn.com/kf/HTB1E5B.ahv1gK0jSZFF7620sXXaQ.png)](https://www.luogu.org/problemnew/show/P5462)


------------

观察题目，思考一下，很快可以知道，这题使用**贪心**即可。

题目要求求**字典序最大**的方案，则

>**越大的数字应该放在越前面，最大的数字放在最前面。**

所以前面的要尽量大，我们这里以每次取出的两颗龙珠前者为准（因为他排在前边嘛）

题目规定各龙珠编号互不相同，那么最终摆放顺序直接就确定了。
从大到小排序，一波扫过来，如果未被取走一并取出与其相邻的下一颗龙珠，已经取走的就不管了，完事。

这里有个特殊点，**最后一颗龙珠需要特判**，因为她(?)没有下一颗龙珠与其作伴。

至于删除的问题，咱就直接**链表**啥的解决了吧。。。~~比赛的时候因为写不好链表罚分到自闭~~

（不会链表的可以先去看看）


### 程序的思路：

输入$\Rightarrow$ 建链表$\Rightarrow$排序（大到小）$\Rightarrow$循环$\{$取出龙珠 $\Rightarrow$ 输出$\}$

这里我搞了一个pos用于储存一个数在原链表中的位置（因为编号各不相同）


------------


下面是码，
```cpp
#include<bits/stdc++.h>
using namespace std;

int N;
int a[1000005];//原数列（位置=>数值） 
int b[1000005];//表示这个数是否已经被取走 
int c[1000005];//排序好的数列 
int pos[1000005];//记录位置（数值=>位置） 
int n[1000005];//next记录链表结点的下一个节点位置 
int l[1000005];//last记录链表结点的下一个节点位置 

bool cmp(int x,int y) {//排序用的比较函数 
	return x>y;
}

int main() {
	cin>>N;
	for(int i=1; i<=N; i++) {
		cin>>a[i];
		pos[a[i]]=i;//位置 
		c[i]=a[i];//赋值 
		n[i]=i+1;//后继 
		l[i]=i-1;//前驱 
	}
	n[N]=-1;//最后一个结点指向-1（无） 
	sort(c+1,c+1+N,cmp);//排序 
	for(int i=1; i<=N; i++) {
		int k1,k2,p1,p2;//k为编号，p为位置 
		k1=c[i];//取出的前一个龙珠编号 
		p1=pos[k1];//前一个龙珠的位置 
		p2=n[p1];//后一个龙珠的位置（前者的下一个） 
		if(p2==-1)//如果这是最后一个龙珠是不能取下一个的 
			continue;
		k2=a[p2];//后一个龙珠的值 
		if(!b[k1] && !b[k2]) {//如果没被取出 
			cout<<k1<<" "<<k2<<" ";//输出 
			b[k1]=1;
			b[k2]=1;//标记 
			//删除2个相邻链表节点的操作： 
			n[l[p1]]=n[p2];//前者的下一个改成后者的下一个 
			l[n[p2]]=l[p1];//后者的上一个改成前者的上一个 
		}
	}
	return 0;//完事跑路 
}
```

理解第一，通过第二。

------------

『做正确，好懂，好看的题解』

---

## 作者：绝顶我为峰 (赞：4)

这题还是挺好的

~~月赛的时候智障打错了变量白白丢了5分~~

我们可以用$STL$大法解决此题

看好了，双$STL$哟(＾Ｕ＾)ノ~ＹＯ

用一个大根堆$priority\_queue$和一个$queue$

运用贪心思想，每次取出对顶然后遍历找到他的下一个，两个一起放进队列，并标记一下，以后再取出被带进去的直接丢掉

但是这里有一个坑，就是对顶的珠子可能是队尾的，没有下家

这是我进行特判，如果在队尾就不管它，也不标记，直接扔掉，由于$n$是偶数，所以其他珠子一定可以把它带进队列里

代码如下：

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
struct qwq
{
	int node,value;
	qwq(int node_,int value_):
		node(node_),value(value_){}
	bool operator <(const qwq &other) const
	{
		return value<other.value;
	}
};
int n;
bool vis[100001];
int a[100001];
queue<int> Q;
priority_queue<qwq> q;//qwq
inline int read()//快读
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x;
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	{
		a[i]=read();
		q.push(qwq(i,a[i]));//丢进堆里做贪心
	}
	while(!q.empty())//重复贪心
	{
		qwq k=q.top();
		q.pop();
		if(vis[k.node])//已经进队
			continue;//丢掉
		int w=1;//找下家
		while(vis[k.node+w])
			++w;
		if(w+k.node>n)//队尾的珠子
			continue;//不管
		vis[k.node]=1;//标记，入队
		Q.push(k.value);
		vis[k.node+w]=1;
		Q.push(a[k.node+w]);
	}
	while(!Q.empty())//输出
	{
		printf("%d ",Q.front());
		Q.pop();
	}
	puts("");
	return 0;
}
```


---

## 作者：Eismcs (赞：4)

这题很明显是贪心，所谓相邻不过是诱惑你。让字典序最大只要让位置靠前的最大即可。

用了优先队列+链表组合，在[这里](https://www.luogu.org/blog/f9107l/solution-p2672)我也这样做的

思路很简单，就是每次取大根堆的堆顶（按龙珠编号排序）
用双向链表维护，去掉两个相邻龙珠，再修改链表
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map> 
using namespace std;
#define re register int
inline int read(){
    int x=0,ff=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*ff;
}
int a[100005],n,tot[100005],u,sd[100005],sa[100005];
//sd是“前”链表，sa是“后”链表
bool b[100005];
struct tt{
    int x,ls;//x是次龙珠序号，ls是此龙珠后的序号
    bool friend operator <(tt xx,tt yy){
        if(xx.ls>n)return 1;
        if(yy.ls>n)return 0;
        //细节处理，以为如果此元素在队末，就无法取走
        return a[xx.x]<a[yy.x]; //排序，按编号
    }
};
priority_queue<tt>dl;
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();sd[i]=i-1;sa[i]=i+1;//双向链表初始化
        dl.push((tt){i,i+1});//入队
    }
    u=0;b[0]=b[n+1]=1;
    while(!dl.empty()){
        tt p=dl.top();dl.pop();
        if(b[p.x]||b[p.ls])continue;//非法元素
        tot[u+1]=a[p.x];tot[u+2]=a[p.ls];u+=2;//入答案队列
        b[p.x]=b[p.ls]=1;//标记已取走的龙珠，便于判断非法元素
        if(sd[p.x]==0)continue;
        sa[sd[p.x]]=sa[p.ls];sd[sa[p.ls]]=sd[p.x];//修改链表
        dl.push((tt){sd[p.x],sa[p.ls]});//加入新的正确元素
    }
    for(int i=1;i<=n;i++){
        printf("%d ",tot[i]);
    }
    return 0;
}

```


---

## 作者：fanhy (赞：3)

全谷最慢解不接受反驳。。。

题目这么水，爱怎么玩怎么玩呗，这道题解法多到溢出

由于题目要求字典序最大，则很容易想到排序。每抽出一对龙珠就会产生新的一对（即前面一颗龙珠的前面和后面一颗龙珠的后面），对于这种动态排序题，优先队列走起。

至于为什么要写一个结构体存每一对龙珠呢，是因为没有看见每个龙珠编号互不相同的条件。。。

所以：

**如果本题去除每颗龙珠编号不同的条件，这份代码也可以AC**

这大概是全谷唯一有这一特性的代码了

模拟题算法没什么好说的，自己看代码吧。

卡掉这份不开O2的代码，n加个0就差不多了

望管理员加强数据

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100000 + 5;
struct node
{
	int val, next, s, t;
	bool operator < (const node x) const
	{
		if (val == x.val) return next < x.next;
		return val < x.val;
	}    //前面一颗龙珠编号大的在前，如果相等，后面一颗龙珠编号大的在前
} a[MAXN];
int n;
bool Visit[MAXN];   //这颗龙珠是否已经进目标队列
int forw[MAXN], back[MAXN];  //链表
int que[MAXN], top;  //目标队列
int orig[MAXN];   //原始数组
priority_queue<node> q;   //优先队列，默认大根堆

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) forw[i] = i + 1, back[i] = i - 1;   //赋值初始链表
	for (int i = 1; i <= n; i++) cin >> orig[i];
	for (int i = 1; i < n; i++) { a[i].next = orig[i + 1]; a[i].val = orig[i]; a[i].s = i; a[i].t = i + 1; }   
	for (int i = 1; i < n; i++) q.push(a[i]);
	while (!q.empty())
	{
		node p = q.top(); q.pop();
		if (Visit[p.s] || Visit[p.t]) continue;   //龙珠已经在目标队列，该组合无效
		que[++top] = p.val; que[++top] = p.next;   //前后两颗龙珠依次进队
		Visit[p.s] = true; Visit[p.t] = true;   //标记
		if (back[p.s] && forw[p.t] <= n) q.push(node{orig[back[p.s]], orig[forw[p.t]], back[p.s], forw[p.t]});   //推前后两颗龙珠入队
		forw[back[p.s]] = forw[p.t];
		back[forw[p.t]] = back[p.s];   //链表记录前后龙珠编号
	}
	for (int i = 1; i < n; i++) cout << que[i] << ' ';
	cout << que[n] << endl;   //严谨的输出
	return 0;
}
```

由于要写题解，为了增加代码可读性，故意把代码写的长了些，大佬勿喷

---

## 作者：ffmm (赞：3)

首先说我太菜了， 看了题解，要么链表，要么线段树，还有排序的，看的懵逼。

那我就发一个适合像我这样菜的人看的题解吧。全是数组实现，不用到合并和删除操作，只有输出，不吸氧总耗时435ms。不算快

PS：A题战俘是橙色题，而这道龙珠是绿色题，我不会A题。。我真的太菜了。

思路：题目说n个龙珠，而且龙珠编号互不相同， **龙珠编号是1到n**， 题目说字典序要最大，那么很容易想到我只要把最大的那个编号，看看它能不能现在输出，而能不能输出就是看这个最大编号的球右边还有没有没输出过的球！有就输出这两个球！ （输出的话要标记着两个球已经输出过了，比如标记为true）如果没有就判断编号是n-1的球能不能输出，.....一直到编号为1的球结束程序。
**模拟一遍这个过程:**
比如样例 4 2 3 6 5 1 并且弄一个标记数据bool mark[maxn]
简单来说就是从N到1判断能不能输出

判断编号6， 6可以输出，因为6右边的5没有输出过，所以输出6 5 
同时mark[6] = mark[5] = true，即输出过了

判断编号5， 不可以，因为5输出过了。

判断编号4 ，发现4没有输出过，且4右边有一个没有输出过的2，所以输出4 2 ，同时标记mark[4] = mark[2] = true，现在打印了6 5 4 2 

判断编号3， 3没有输出过，在3右边找一个没有输出过的数字和它一起输出， 发现1没有输出过，所以输出3 1 标记mark[3]=mark[1]=true 这时候程序打印了6 5 4 2 3 1 

判断编号2， 因为2已经输出了，所以不输出，程序直接下一步
判断编号1， 因为1已经输出了，所以不输出，因为是编号1最后一个球了，程序结束。
所以最终输出是6 5 4 2 3 1 

代码和注释如下
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int a[100005];//储存输入的序列
int  mark[100005];//标记数字是否输出，1为已经输出，比如mark[10]=1表示数字10已经输出
int pos[100005];//记录数字在序列出现的位置，比如pos[2]=1,表示2出现在序列第1个位置

int check(int p)//判断序列a[]的第p个数字右边有没有数字没有输出的
{
    for(int i = p +1;  i <= n; i++)//检查p的右边，即从p+1枚举
    {
        if(!mark[a[i]])//如果第i个数字也就是a[i]没有输出过
            return i;//返回p右边没有输出过的下标
    }
    return -1;//第p个数字右边没有“还没输出过的数字”

}
int main()
{
    ios::sync_with_stdio(false);
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        pos[a[i]] = i;//记录数字a[i]出现在第几个位置
    }
 
    int temp; 
    for(int i = n; i>=1; i--)//从编号n开始直到1检查编号i是否可以输出
    {
        temp = check(pos[i]);//编号i的位置是pos[i]，检查pos[i]这个位置右边有没有还没有输出过的球的位置
        if(!mark[i] && temp != -1)//如果编号i没有输出且右边有可以和他输出的编号
        {
            
			printf("%d %d ", i, a[temp]);//输出编号i和他相邻的编号a[temp]
            mark[i] = 1;//标记编号已经输出i
            mark[a[temp]] = 1; //标记编号a[temp]已经输出
        }//if
    }//for

    printf("\n");
    //system("pause");
   
    
}
```


菜鸟第一次发题解，花了一个多钟，眼睛都疼，写的差不要喷。求管理大大通过

---

## 作者：Starlight237 (赞：2)

给出一种不要链表的做法：

思路：显然**每次找最大的，输出它和它后面的数即可**。

首先我们记录一下原始的序列A，然后因为我们后面要找最大的，于是要排序，因此为了保证选数的连续性，我们用结构体保存每个数的值和排序前的位置。

然后用数组$del[i]$表示i是否被选过了，选过则$del[i]=1$。这样就可以通过循环找到一个数后面第一个没有被选过的数。

但是还有一个问题，万一选到了最后一个数，找不到与之连续的下一个数呢？  
因此我们需要特判，这样会剩下两个数。结束时遍历一下数列，把没有选的两个数按顺序输出即可。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 10000000
static char in[IOSIZE],*p=in,out[IOSIZE],*q=out,ch[20],*t=ch,del[100001];
inline int read(){
	reg int x=0;
	while(*p<48)++p;
	while(*p>47)x=(x<<1)+(x<<3)+(*p++^48);
	return x;
}
inline void write(int x){
	!x&&(*q++=48);
	while(x)*t++=x%10+48,x/=10;
	while(t!=ch)*q++=*--t;
	*q++=' ';
}
static int n,A[100001];
struct Node{
	int a,i;
	friend inline bool operator<(Node a,Node b){return a.a>b.a;}
}a[100001];
int main(){
	fread(in,1,IOSIZE,stdin);
	n=read();
	for(reg int i=1;i<=n;++i)A[i]=a[i].a=read(),a[i].i=i;
	sort(a+1,a+n+1);
	for(reg int i=1;i<=n;++i)
		if(a[i].i!=n&&!del[a[i].i]){
			for(reg int j=a[i].i+1;j<=n;++j)
				if(!del[j])write(A[a[i].i]),del[a[i].i]=1,write(A[j]),del[j]=1,j=n;
		}
	for(reg int i=1;i<=n;++i)if(!del[i])write(A[i]);
	fwrite(out,1,q-out,stdout);
	return 0;
}
```

---

## 作者：greenheadstrange (赞：2)

由于我不会链表，所以用数组模拟链表

l表示左边的数，r表示右边的数

同时哈希一下就可以了

每次贪心一下。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],h[100005],l[100005],r[100005],ans[100005];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),h[a[i]]=i;//哈希 
    for(int i=1;i<=n;i++)l[i]=i-1,r[i]=i+1;
    for(int i=n;i>=1;i--){//贪心 
        if(!h[i]||r[h[i]]==n+1)continue;//注意，一定要判断，否则会WA 
        int p=h[i],q=r[p];
//		cout<<p<<" "<<q<<"\n";
        ans[++ans[0]]=i;
        ans[++ans[0]]=a[q];
        h[i]=h[a[r[p]]]=0;
        r[l[p]]=r[q];
        l[r[q]]=l[p];
    }
    for(int i=1;i<=n;i++)printf("%d ",ans[i]);
    return 0;
}
```


---

## 作者：Nickel_Angel (赞：1)

本题大意：给定一个长度为$n$的1至n的全排列~~（至少目前数据看起来是这样，值得注意的是，目前题目中并未明确指出是否为全排列，也未说明输入是整数QAQ）~~，每次从排列中选出相邻的两个元素，使它们重新成为一个新的排列，并要求排列的字典序最大。

不难发现，由于要求字典序最大，**可以贪心地每次取最大的元素，但需注意，当最大值恰好在序列末尾时，其后没有相邻元素，而最大值和其前面的数组成一对数无法保证字典序最大，这时，次大值成为了最优解……**

这样我们可以使用链表和堆来维护答案……但事实上，**我们只需从$n$至$1$扫一遍，对于扫到的数$i$，如果$i$不在目前序列的末尾就可以直接取出，如果$i$在目前序列的末尾或已被取走就跳过。**之所以这么做是正确的，是因为如果$i$在末尾不能被取走，那么$j$（$j$为比$i$小且未被取走的最大的数，显然，如果扫描了$i$，下一个必定为$j$）就一定能被取走，而$j$一定是目前序列中的次大值且一定能被取走，符合上述贪心策略，得证。

故可以考虑用链表直接维护，~~但由于本人对链表掌握不好~~，不过我们可使用了并查集代替链表……

我们可以先以序列上的每个元素为一个集合，建立并查集。(如下图)

![](https://cdn.luogu.com.cn/upload/pic/63862.png)

假如一个元素$x$被取出，就让它与其右边第一个与其不在同一集合的元素所在集合合并，这样$find(x)$后就直接能找到$x$后第一个未被删除的元素了……（如下图，$find(1) = 2, find(3) = 4$）

![](https://cdn.luogu.com.cn/upload/pic/63864.png)

注意本题的一个细节，当我们发现一个元素的右方相邻元素和$n$为同一集合时，我们能判定其是否在末尾，故我们可令$n + 1$为尾部，以便我们可以确定如果一个元素的右方相邻元素和$n + 1$在一个集合中，那么其一定在序列末尾。

Code：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

namespace Primary
{

const int maxn = 1e5 + 10;

int n, a[maxn], pos[maxn];//pos记录a[i]在序列中的位置
bool used[maxn];

class union_find_set//并查集
{
  private:
    int fa[maxn];
    
  public:
    inline void init(int bound)
    {
        for (int i = 0; i <= bound; ++i)
            fa[i] = i;
    }
  	
    int find(int x) {return x == fa[x] ? x : fa[x] = find(fa[x]);}
    
    inline bool unite(int x, int y)
    {
        int fx = find(x), fy = find(y);
        if (fx == fy) return false;
        fa[fx] = fy;
        return true;
    }
}S;

void main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", a + i);
        pos[a[i]] = i;
        used[i] = false;
    }
    S.init(n + 1);//并查集初始化,注意初始化至n + 1
    for (int i = n; i > 0; --i)
    {
        if (used[i]) continue;
        if (S.find(pos[i] + 1) <= n)//判断a[i]是是否为最后一个
        {
            printf("%d %d ", i, a[S.find(pos[i] + 1)]);
            used[i] = true, used[a[S.find(pos[i] + 1)]] = true;//标记为已输出
            S.unite(pos[i] + 1, S.find(pos[i] + 1) + 1);//更新i与i后面的元素的并查集
            S.unite(pos[i], pos[i] + 1);
        }
    }
}

}

int main()
{
    Primary::main();
    return 0;	
}
```



---

## 作者：BabyCabbage (赞：1)

有趣的一道题

这道题刚拿到手的时候我还以为是一个环，但是重新审题后发现这是一条链。个人认为这道题链相对环来说稍微好做一点。

题目要求的字典序最大很明显是这题的关键。在这里很明显可以用到贪心，就是从大到小一个一个取。举个例子：

一开始数列长这样：

| 6 | 4 | 2 | 3 | 1 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

可以自己脑补出最终答案应该长这样：

| 6 | 4 | 3 | 1 | 2 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

到这里你可能会想：我从 $n$ 开始一直取到 $\frac {n} {2} + 1$ 不就可以了吗？

但是如果一开始数列长这样：

| 2 | 3 | 1 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

很明显， $6$ 是取不了了，如果先取 $5$ ，那 $4$ 也取不了了。

所以这题贪心的正确打开方式是每次取所有能取的数中的最大值。

但是你可能想问：每一次都查询，时间复杂度不就是 $O(n^2)$ 吗？

这时就应该想一想可行的优化了。

~~本蒟蒻的优化可能比较烂，大佬勿喷~~

我们可以定义一个数组 $f$ ， $f_i$ 代表 $i$ 在原数组中的位置。

加下来定义两个数组，每个数组的每一个元素都是一个指针，第一个数组的每个元素都是指向这个位置的在原数组中还没有被拿走的上一个元素的位置，第二个数组则是下一个。

然后我们再定义一个尾指针，指向数组中最末一个没有被拿走的元素的位置，每次判断尾指针要不要移动以及最大值是否在尾指针上。

好啦，废话不多说，直接上代码啦：

```cpp
#include <cstdio>

using namespace std;

const int MAXN = 100000;

int a[MAXN + 5], f[MAXN + 5], nxt[MAXN + 5][2];
bool b[MAXN + 5];
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i) {
		scanf("%d", &a[i]);
		f[a[i]] = i;
		if (i ^ n) {
			nxt[i][1] = i + 1;
		}
		if (i ^ 1) {
			nxt[i][0] = i - 1;
		}
	}
	int tail = n;
	int cnt = n;
	for (int i = n; i && cnt; -- i) {
		if (f[i] == tail || b[f[i]]) {
			continue;
		}
		if (nxt[f[i]][1] == tail) {
			tail = nxt[f[i]][0];
		}
		else {
			nxt[nxt[f[i]][0]][1] = nxt[nxt[f[i]][1]][1];
			nxt[nxt[nxt[f[i]][1]][1]][0] = nxt[f[i]][0];
		}
		b[f[i]] = b[nxt[f[i]][1]] = true;
		printf("%d %d ", i, a[nxt[f[i]][1]]);
		cnt -= 2;
	}
	return 0;
}
```

---

## 作者：Kisaragi_77 (赞：1)

### 思路：
看到好多人用贪心+排序或者一个链表过了

我太弱了

只能想到堆+链表的辣鸡做法

其实这种方法挺套路化的

每次贪心的选择编号最大的元素


然后在堆里删掉他自己和他后面的元素

然后用链表维护每个元素的前驱后继关系

**注意：队尾的元素是不能成为选择对象的，否则就会把后面的0一起拉出来**

如
`1 2 3 4`

第一次就会把4和后面的0拉出来

由于队尾只能通过他的前驱拉出来

所以不入堆不会影响答案

**直接特判掉pop即可**

### 代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
inline int read(){
    int x;scanf("%d",&x);return x;
}
struct node{
    int id,val;
};
inline bool operator<(const node &a,const node& b){
    return a.val <b.val;
}
priority_queue <node> Q;
const int N =1e6;
int a[N],pre[N],nxt[N],ans[N],sz,vis[N],n;
//同时维护一个堆和链表
int main(){
    n =read();
    for(int i=1;i<=n;++i){
        pre[i] =i-1;
        nxt[i] =i+1;
        a[i] =read();
        if(i!=n)	Q.push(node{i,a[i]});
    }//队尾元素不能入堆

    for(;;){
        while((vis[Q.top().id]||nxt[Q.top().id]>n) && Q.size())	Q.pop();	//懒标记删除法，注意特判掉队尾
        if(Q.empty())	break;
        node x =Q.top();	Q.pop();
        int val =x.val,u =x.id,v =nxt[u];
        ans[++sz] =val;
        ans[++sz] =a[v];
        vis[u] =true;
        vis[v] =true;
        nxt[pre[u]] =nxt[v];
        pre[nxt[v]] =pre[u];	//链表的删除操作
    }
    for(int i=1;i<=n;++i)	printf("%d ",ans[i]);
}
```

---

## 作者：Register (赞：1)

### 题意描述

给你一个长为$2n$的珠子队列，每颗珠子的编号互不相同

要求取$n$次珠子，每次取相邻的$2$个

取掉后放到目标队列的末尾，并去除空隙

请你输出目标队列字典序最大的情况

### 解题思路

既然是互不相同

- 我们只用考虑每次去除的珠子中第一颗的大小

- 最后一颗珠子无法作为第一颗，因此需要特判

取出后去除间隙

- 用双向链表或$vector$实现

- 此题用双向链表更加简洁

每颗珠子的值不变

- 我们可以用静态的排序做

- 需要打标记

### 代码

```cpp
#include <cstdio>
#include <algorithm>
int n,sum,v[100001],lst[100001],nxt[100001];
bool vis[100001];
struct hh{
    int x,id;
}a[100001];
int read(){
    char ch=getchar();int res=0,w=1;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
    return res*w;
}
inline bool comp(const hh&x,const hh&y){
    return x.x>y.x;
}
int main(){
    n=read();
    for(register int i=1;i<=n;i++) {lst[i]=i-1;nxt[i]=i+1;v[i]=a[i].x=read();a[i].id=i;}
    std::sort(a+1,a+n+1,comp);
    for(register int i=1;i<n;i++)
        if(!vis[a[i].id]&&nxt[a[i].id]!=n+1)
        {
            printf("%d %d ",a[i].x,v[nxt[a[i].id]]);
            vis[a[i].id]=vis[nxt[a[i].id]]=true;
            nxt[lst[a[i].id]]=nxt[nxt[a[i].id]];
            lst[nxt[nxt[a[i].id]]]=lst[a[i].id];
            sum++;
            if(sum==n>>1) break;
        }
    puts("");
    return 0;
}
```


---

## 作者：谁是鸽王 (赞：1)

## 【题解】P5462 X龙珠

赛题 **#B**: [**P5462** X龙珠](https://www.luogu.org/problemnew/show/P5462) | 满分: **100分** 

发一个set做法

维护两个set，一个按照顺序排序，一个按照值排序。

每次从大往小取，问题就变成了判断这个最大值后面是否有数，直接查看一下按照顺序排序的该数是否有后继。

编译记得用**c++11**，请安心食用。

(为了方便理解，按照顺序排序的set写得不够优美)

```cpp
//@winlere
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<vector>

using namespace std;  typedef long long ll;
inline int qr(){
      register int ret=0,f=0;
      register char c=getchar();
      while(c<48||c>57)f|=c==45,c=getchar();
      while(c>=48&&c<=57) ret=ret*10+c-48,c=getchar();
      return f?-ret:ret;
}
typedef pair < int , int > node;
#define x first
#define y second
#define mk make_pair
set < node > s;
set < int ,greater < int > > s1;
int n;
const int maxn=1e5+5;
int arc[maxn];
vector < int > ve;
int main(){
#ifndef ONLINE_JUDGE
      freopen("in.in","r",stdin);
      //freopen("out.out","w",stdout);
#endif
      n=qr();
      for(register int t=1,c;t<=n;++t)
	    s.insert(mk(t,c=qr())),s1.insert(c),arc[c]=t;
      for(register int t=1;t<=n>>1;++t){
	    for(auto it:s1){
		  auto ti=s.find(mk(arc[it],it));
		  if(ti!=s.end()&&++ti!=s.end()){
			auto t1=*ti--;
			auto t2=*ti;
			s.erase(t1);
			s.erase(t2);
			ve.push_back(t2.second);
			ve.push_back(t1.second);
			s1.erase(t1.second);
			s1.erase(t2.second);
			break;
			
		  }
	    }
      }
      int cnt=0;
      for(auto t:ve) printf("%d%c",t,++cnt==n?'\n':' ');
      return 0;
}

```









---

## 作者：littleKtian (赞：1)

~~怎么题解里一群dalao用双向链表欺负我这个只会用并查集的蒟蒻~~

估计你们看其他题解也都懂了这题的贪心做法，就是取队列中编号最大的和之后距离最近的龙珠，我就不多讲了

注意坑点：

1. “取编号最大的龙珠”不能是最后一颗龙珠

2. 一次取两个，不要忘记把已经取出的龙珠去掉

本蒟蒻表示只会用堆+并查集优化
```
#include<bits/stdc++.h>
using namespace std;
struct lz{//龙珠（不是楼主！！！）
	int x,w;//x为编号，w为龙珠在队列中的位置
};
lz d[100003];//大根堆
bool dl[100003];//dl[i]表示第i颗龙珠是否在队列中,ture表示已取出
int n,dui,bh[100003],p[100003];//bh记录龙珠标号，p是并查集
void tj(lz a)//加入堆中
{
	d[++dui]=a;
	int o_o=dui;
	while(o_o>>1)
	{
		if(d[o_o>>1].x>=d[o_o].x)return;
		swap(d[o_o>>1],d[o_o]);
		o_o=o_o>>1;
	}
}
lz qc()//取出
{
	lz o_o=d[1];
	d[1]=d[dui--];
	int x_x=1,qwq;
	while((x_x<<1)<=dui)
	{
		qwq=x_x<<1;
		if(qwq<dui&&d[qwq+1].x>=d[qwq].x)++qwq;
		if(d[x_x].x>=d[qwq].x)break;
		swap(d[x_x],d[qwq]);
		x_x=qwq;
	}
	return o_o;
}
int f(int xx)//并查集
{
	if(xx!=p[xx])p[xx]=f(p[xx]);
	return p[xx];
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",bh+i);
		lz a;
		a.x=bh[i],a.w=i;
		tj(a);
	}
	for(int i=1;i<=n+1;i++)p[i]=i;//注意不能只循环到n
	for(int i=2;i<=n;i+=2)
	{
		lz a=qc();
		while(dl[a.w]||f(a.w+1)==n+1)a=qc();//当f(a.w+1)==n+1时，说明在这颗龙珠后的龙珠已经全部取完，所以不能把这颗龙珠当成编号最大的龙珠取出
		int z_1=a.w,z_2=f(a.w+1);//z_1和z_2代表这次取出的龙珠原来在队列中的位置
		printf("%d %d ",bh[z_1],bh[z_2]);
		p[z_1]=z_1+1,p[z_2]=z_2+1;//改父亲
		dl[z_1]=dl[z_2]=true;//记录已取出
	}
}
```


---

## 作者：ViXpop (赞：1)

#### 7月月赛T2

因为某种原因，本蒟蒻没有打月赛（呜呜呜rank暴跌），月赛之后就来做做月赛的题

看完T2题目描述，第一反应就是:这不就是个裸贪心吗，优先取出最大数

但是若最大数是当前序列的最后一个的时候是不可取的，因为你没办法取两个出来

思路很清晰嘛对吧，一看就是~~水题~~

立马上手敲一发，50多行的样子，没考虑复杂度，10分滚粗......

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int res=0,f=1;char ch=' ';
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
int _max(int x,int y){return x>y?x:y;}
int _min(int x,int y){return x<y?x:y;}
const int N=1e5+5; 
int n,a[N],goal,vis,p,maxn;
bool flag[N],co;
int main() {
    n=read();
    queue<int>q;
    for(register int i=1;i<=n;i++){
        a[i]=read();
        if(a[i]>maxn){
            maxn=_max(maxn,a[i]);
            p=i;
        }
    }
    goal=n;
    if(p==n)goal--;
    while(q.size()<n){
        vis=1,co=0;    
        //没有想到怎么去除原数组的空隙，就用vis标记一下要往后跳多少个
        for(register int i=1;i<=n;i++){
            if(a[i]==goal){
              //找到当前最大数
                if(!flag[a[n]]&&i==n-q.size())co=1;
              //如果后面全是空的，那么最后一个数的原编号就是n-q.size()
                else if(!flag[a[n]]&&i==n)co=1;
              //如果最大数为最后一个，显然不可取
                if(co){
              //若最大数不可取，寻找第二大的数
                    goal--;
                    while(flag[goal])goal--;
                    break;
                }
                q.push(a[i]);//进队
                while(!a[i+vis])vis++;
              //如果为0说明已经被取出，继续先后跳
                q.push(a[i+vis]);//进队
                flag[a[i]]=1,flag[a[i+vis]]=1;
                while(flag[goal])goal--;
                a[i]=0,a[i+vis]=0;
              //取出过的数变为0，以便vis更新
                break;
            }
        }
    }
    while(!q.empty()){//输出
        printf("%d ",q.front());
        q.pop();
    }
    return 0;
}
```

由于前面的代码并没有真正意义上的实现题目要求的去除原序列的空隙，只是投机取巧换了一种实现形式，但实际上是有缺陷的所以AC 1 WA 5 TLE 4

无奈之下只能换写法，大体思路没有变（应该贪心写法也就这一种思路）

#### 我们考虑一下如何真正的实现去除空隙

如果将原序列都丢到一个队列里去，虽然每次取出数后队列可自动去除空隙，但是对于取数操作而且却过于麻烦，这里不予考虑这种操作

那么我们能否模拟去除空隙这个过程呢，当然可以，但是一定会TLE，也不太合适

##### 思来想去，我想到了链表

我们可以在每次取数后对于链表进行一次更新，就可以实现去除空隙的过程

#### 具体如何更新下面上代码

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int res=0,f=1;char ch=' ';
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
const int N=1e5+5; 
int n,flag[N],to[N],pre[N],nxt[N],bef[N],a[N],goal;
queue<int>q;
void qxx(int x,int y){to[x]=y;pre[y]=x;nxt[x]=1;bef[y]=1;}
//to 当前点的下一个点 pre 当前点的前一个点 nxt 当前点后面有无点
//bef 当前点前面有无点 其实这个有没有都无所谓
int main() {
    n=read();
    for(register int i=1;i<=n;i++)a[i]=read();
    for(register int i=2;i<=n;i++)qxx(a[i-1],a[i]);
    if(a[n]==n)goal=n-1;//目标数
    else goal=n;
    while(q.size()!=n){
        for(register int i=1;i<=n;i++){
            if(a[i]==goal&&nxt[a[i]]){//如果最大数的后面有数字
                q.push(a[i]);q.push(to[a[i]]);//进队
                if(nxt[to[a[i]]])qxx(pre[a[i]],to[to[a[i]]]);
                //然后将a[i]的前一个点和to[a[i]]的后一个点连接
                //实现去除空隙
                else nxt[pre[a[i]]]=0;//更新最后一个点
                pre[to[a[i]]]=0;      //全部清零
                bef[to[a[i]]]=0;
                flag[to[a[i]]]=1;      //标记已被输出
                to[a[i]]=0;
                nxt[a[i]]=0;
                flag[a[i]]=1;
                while(flag[goal])goal--;
                //如果当前要找的数已经进队，找没有进队过的最大数
                break;
            }
            else if(a[i]==goal&&!nxt[a[i]]){
                //如果最大数处于末尾，找第二大的数
                goal--;
                while(flag[goal])goal--;
                break;
            }
        }
    }
    while(!q.empty()){//输出
        printf("%d ",q.front());
        q.pop();
    }
    return 0;
}
```

这个操作实现效果也海星，复杂度不是很清楚，貌似是O(n^2),但是数据范围是1e5，很显然时间会爆炸

事实上这份代码是60分，AC 6 TLE 4

于是我意识到统计方法有问题，没必要不断的寻找最大数

只需要把所有数字的初始位置记录一下，从最大数后面的数中找第一个未输出的数字，再标记更新最大数就行了

#### 于是有了下面的AC代码（然鹅跟前面两份代码完全不一样）

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int res=0,f=1;char ch=' ';
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
const int N=1e5+5; 
int n,flag[N],a[N],goal,p[N],num;
int main() {
	n=read();
	for(register int i=1;i<=n;i++)a[i]=read(),p[a[i]]=i;//记录初始位置
	goal=n;//最大值
	while(num<n){
		int vis=0;
        	//若最后vis还是0说明当前找到的最大数位于序列末端
		while(flag[goal])goal--;//找到未输出的最大值
		for(register int i=p[goal]+1;i<=n;i++){
			if(!flag[a[i]]){
				num+=2; //已经输出过的数字有多少个
				vis=1;
				printf("%d %d ",goal,a[i]);
				flag[goal]=1,flag[a[i]]=1;//标记
				break;
			}
		}
		if(!vis)goal--;
	}
    return 0;
}
```
##### 因为蒟蒻实在是太蒟了，所以不会打其他题解的双向链表线段树打法，就来发了一发贪心解法以及做题的心路历程

---

## 作者：joky11 (赞：1)

比赛时候没做出来，看了好多人双向链表的题解，因为太菜没有看懂。后来思考好久，题目中说编号不超过n,所以从n往下枚举，满足条件：没有被取出过（在链表中），不是最右边的数（不是链表尾），就可以取它和它右边的数。更新链表和标记数组。

```cpp
#include <cstdio>
#include<queue>
#include<algorithm>

using namespace std;
int a[100002],pre[100002],next[100002];
int vis[100004];//标记数组，v[x]=1表示x在链表中
queue<int> res;

int main()
{
	int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
	{
        scanf("%d",&a[i]);
        next[a[i-1]]=a[i];
        pre[a[i]]=a[i-1];
        vis[a[i]]=1;
	}
	pre[a[1]]=0;//链表头向前指向0，用来特判
	next[a[n]]=0;//链表尾指向0，用来特判
	for(int i=n;;i--)
	{
		if(vis[i]&&next[i])
		{
			res.push(i);
			int t=next[i];
			res.push(t);
			vis[i]=0;
			vis[t]=0;
			if(res.size()==n) break;//数已取完
			if(!next[t])
			{
				next[pre[i]]=0;
			}
			else if(!pre[i])
			{
				pre[next[t]]=0;
			}
			else
			{
				next[pre[i]]=next[t];
				pre[next[t]]=pre[i];
			}
		}
	}
	while(!res.empty())
	{
		printf("%d ",res.front());
		res.pop();
	}
    return 0;
}
```


---

## 作者：传奇英雄 (赞：1)

记录每个值出现的位置，用链表记录每个值的前面的数和后面的数，每次输出最大和最大后面的数即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int g=100005;
int n,a[g],d[g],e[g],h[g],x,y;
bool f[g];

int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&h[i]);
        d[h[i-1]]=h[i];//记录前面的数
        e[h[i]]=h[i-1];//记录后面的数
    }
    d[0]=1,f[n+1]=1;//避免出界
    for(int i=n;i;i--)
    {
        x=d[i];//i后面的数
        if(!f[i]&&!f[x])
        {
            printf("%d %d ",i,x);
            f[x]=f[y]=1;//删数
            d[e[i]]=d[x];//链表操作
            e[d[x]]=e[i];
        }
    }
    return 0;
}
```


---

## 作者：zl_just (赞：1)

显然  既然要求字典序最大,那我们就直接**贪心**就好了  
最近学数据结构学傻了，一想到最大值,区间那啥就平衡树了   

然而一个**双向链表**就可以了。。  
`v[x]`表示`x`在链表中的下标,`last[i]`和`next[i]`就是我们的双向链表了,`arr[i]`表示原数列中第`i`个数的值  
既然每次取最大的，我们就从`n~1`一个一个的枚举，将这个数以及它在链表的后继加入目标队列中,如这个数是链表的尾部就忽略,然后再在链表中删除这个数及其后继  
时间复杂度$O(n)$

$Q.E.D$  

```cpp
#include <cstdio>
const int maxn = 1000000 + 5;
int v[maxn],last[maxn],next[maxn],arr[maxn],s[maxn];
bool vis[maxn];
int n,top;

template<typename T>
inline T read(T &a) {
    int c;
    while((a=getchar()-'0')) if(a>0&&a<10) break;
    while((c=getchar())) {
        if(c<'0'||c>'9') break;
        a=a*10+c-'0';
    }
    return a;
}

inline void del(int o) { next[last[o]]=next[o]; last[next[o]]=last[o]; }

int main() {
    int x;
    read(n);
    next[0]=1,last[n+1]=n;
    for(register int i=1;i<=n;i++) {
        read(x);
        arr[v[x]=i]=x;
        next[i]=i+1;
        last[i]=i-1;
    }
    for(register int i=n;i;--i) if(!vis[i]) {
        int cur=v[i],nxt=next[cur];
        if(nxt==n+1) continue;
        vis[s[top+1]=arr[cur]]=vis[s[top+2]=arr[nxt]]=true;
        top+=2;
        del(cur),del(nxt);
    }
    printf("%d",s[1]);
    for(int i=2;i<=n;++i) printf(" %d",s[i]);
    return !putchar('\n');
}
```



---

## 作者：D_Fox (赞：1)

大佬们的什么线段树、链表、排序的思路都太高端了。

没有看到用纯priority_queue贪心来模拟的，发一篇题解吧。
思路比较简单，每一次找到当前合法的最大数值，合法的涵义为既不能查过，也不能是最后一个，然后将该数和该数后紧接着的合法数计入ans数组，弹出堆即可。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;

struct A {
	int d, p;
	bool operator > (const A &rhs) const {
		return d < rhs.d;
	}
} a[N];

int n, ans[N], pa;
bool vis[N];
priority_queue<A, vector<A>, greater<A> > pq;

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d", &a[i].d);
		a[i].p = i;
		pq.push(a[i]);
	}
	while(!pq.empty()) {
		if(!vis[pq.top().p]) {
			bool check = 0;
			int pos;
			for(int i = pq.top().p + 1; i <= n; i++) {
				if(!vis[i]) {
					check = 1;
					pos = i;
					break;
				}
			}
			if(!check) {//该数是最后一个数，不合法，但要出堆，且不能标记
				pq.pop();
				continue;
			}
            //该数合法，压入数组，标记
			ans[++pa] = pq.top().d;
			ans[++pa] = a[pos].d;
			vis[pq.top().p] = 1;
			vis[pos] = 1;
			pq.pop();
		} else 
			pq.pop();//该数已被访问过，直接出堆
	}
	for(int i = 1; i <= n; i++) {
		printf("%d ", ans[i]);
	}
	return 0;
}
```


---

## 作者：chinaxjh (赞：1)

本题为贪心题，每次找最大的输出（还有最大的的后面一个），双向链表储存，跑的很快，代码也挺短的。时间复杂度O(n)
```pascal
var
  n,i,k:longint;
  a,f,next,last:array[0..200000] of longint;
  use:array[0..200000] of boolean;
begin
  readln(n);
  for i:=1 to n do
  begin
    read(a[i]);
    next[i]:=i+1;
    last[i]:=i-1;
    f[a[i]]:=i;
  end;//读入+初始化链表和位置
  next[n]:=0;
  for i:=n downto 1 do
  if not use[i] then
  begin
    if (next[f[i]]=0) then continue;//必须要连续的两个
    inc(k,2);
    if k<>n then write(i,' ',a[next[f[i]]],' ')
    else writeln(i,' ',a[next[f[i]]]);//输出
    use[i]:=true;
    use[a[next[f[i]]]]:=true;//true表示用过了
    next[last[f[i]]]:=next[next[f[i]]];
    last[next[next[f[i]]]]:=last[f[i]];//链表的next值和last值改变，形成新链表
  end;
end.
```


---

## 作者：abs001 (赞：1)

这道题比赛的时候交了好几次，导致最后只有73分。。

首先一个优先队列，la[i]和ne[i]两个数组，表示上一个数的位置与下一个数的位置，在开始的时候将1~n-1压入队列

具体解释在代码里

```cpp
#include<bits/stdc++.h>
#define N 100001
using namespace std;
int n;
int a[N], la[N], ne[N], p[N];

struct node{
    int x, y;
    bool operator < (const node &b) const
    {
        return x < b.x || (x == b.x && a[ne[y]] < a[ne[b.y]]);//以a[i]为第一关键字，a[ne[i]]为第二关键字排序
    }
};

priority_queue<node> q;

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]), la[i] = i - 1, ne[i] = i + 1;//初始化
    for(int i = 1; i < n; i++) q.push({a[i], i});
    for(int i = 1; i * 2 <= n; i++)
    {
        while(p[q.top().y] || ne[q.top().y] > n) q.pop();//如果已经输出过了，或者是当前的最右边的一个就弹出
        int x = q.top().y;
        printf("%d %d ", a[x], a[ne[x]]);
        p[x] = p[ne[x]] = 1;//标记已经输出过了
        ne[la[x]] = ne[ne[x]], la[ne[ne[x]]] = la[x];//上一个的下一个位下一个的下一个，下一个的下一个的上一个为上一个
    }
    return 0;
}
```


---

## 作者：Caishifeng666 (赞：0)

结构体，记录这个数的上家编号(st)，下家编号{ne}，和这个数(x)

按输入的值从大到小排序，ans数组记录答案，取完一组数后把这组数的开头的上家的下家连到这组数的结尾的下家，再把这组数的结尾的下家的上家连到这组数的开头的上家。

最后输出ans数组

----

下面是代码：

```cpp
#include<bits/stdc++.h>
#define R register int
using namespace std;
int n,cn,cnt,ans[100010];
struct hh{
	int st,ne,x;
}xz[100010];
inline bool h(hh a,hh b){return a.x>b.x;}
inline int read(){int s=0,f=1;char c=getchar();while (c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();while (c>='0'&&c<='9') s=s*10+c-'0',c=getchar();return s*f;}
signed main(){
	n=read();
	for (R i=1;i<=n;i++){xz[i].x=read();xz[i-1].ne=xz[i+1].st=(n-xz[i].x+1);}
	sort(xz+1,xz+n+1,h);
	/*
	for (R i=1;i<=n;i++) cout<<xz[i].x<<" ";
	cout<<endl;
	for (R i=1;i<=n;i++) cout<<xz[i].ne<<" ";
	cout<<endl;
	for (R i=1;i<=n;i++) cout<<xz[i].st<<" ";
	cout<<endl;
	*/
	for (R i=1;i<=n/2;i++){
		while (xz[++cn].x==-1||!xz[cn].ne);
		ans[++cnt]=xz[cn].x;
		ans[++cnt]=xz[xz[cn].ne].x;
		xz[xz[xz[cn].ne].ne].st=xz[cn].st;
		xz[xz[cn].st].ne=xz[xz[cn].ne].ne;
		xz[cn].x=xz[xz[cn].ne].x=-1;
	}
	for (R i=1;i<=cnt;i++) printf("%d ",ans[i]);
	return 0;
}
```


---

## 作者：XMK_萌新 (赞：0)

## 脑回路新奇的优先队列代码            


首先，**每次取两个放到队尾**，就相当于**每次取两个放到队首**。         
$Reason?$ 很简单顺序倒着取嘛【雾】           
这样做有什么好处呢        
好处是：            
题中要求你求最大字典序序列           
那么如果是这样正着放，              
每次让这两个数中的**第一个数**最大就行了。        
一个很简单的贪心策略。          
因为如果用其他数接上去字典序就不是最大了。         
那么这样每次找最大的那个数就行了          
但是如果你每次找最大数都$O(N)$肯定会爆掉          
（因为总时间复杂度就有$O(N^{2})$了）       
那么很容易想到万能的——     
### 堆        



那么找最大数的问题解决了，接下来要解决：            
取出两个数后怎么把空隙合并呢？          
可以使用链表。          
具体操作见代码。

$CODE:$

```cpp
#include <iostream>
#include <queue>
using namespace std;
typedef pair<int,int> P;
int n,a[100003],next[100003],last[100003];	
//next为下一个数的id，last为上一个数的id
bool del[100003];
priority_queue<P> q;	//堆      
//这里需要注意使用pair时，堆之类的玩意以第一个值来排序
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];	
		next[i]=i+1; last[i]=i-1;	//链表
		if(i==1) last[i]=-1;	//上一个id为NULL
		if(i==n) next[i]=-1;	//同上
		if(i!=n) q.push(P(a[i],i));	//最后一个没有后续，不能放到堆里
	}
	while(!q.empty())
	{
		P p=q.top();
		q.pop();
		int val=p.first,id=p.second;	//pair使用方式
		if(del[id]||next[id]==-1||del[next[id]]) continue;
        //del[id]：第id个数被删掉了
        //next[id]==-1：没有后续
        //del[id]：第id个数的后续被删掉了
        //由于“或”运算符有短路性所以第二条成立后不会进行第三条判断
		del[id]=del[next[id]]=true;	//标记
		int L=last[id],R=next[next[id]];
        //把L的前驱和R的后续的后续算出来
		if(L!=-1&&R!=-1)	//任意一个都不为NULL
		{
			next[L]=R;	
			last[R]=L;
            //用双向链表连起来
		}
		cout<<val<<" "<<a[next[id]]<<" ";	//输出
	}
	return 0;
}
```


$$END$$

---

## 作者：encore (赞：0)

看了下大佬，似乎都是$\Theta(n)$链表过的？

没有办法我太弱了，考场上并没有想到这个方法。当时看到一个$n \leq 1e5$，一个最大值，就想用平衡树了。

~~然而这里并没有平衡树~~

好吧因为我需要两棵结构体平衡树，嫌麻烦就敲了两个set~~STL大法好~~

然后常数爆炸，慢的要死。。。

诶，思路？纯模拟吧。。。

贪心策略不用我讲了吧。。。

建两个set，一个把所有元素按数组下标排序，设为S2，一个把所有元素按数值大小排序，设为S1。

然后每次从S1里取出最大值（区间最值），再通过S2找出它的后一个元素（后驱），先后插入到队列里，再删除，就OK了吧。

~~不会set取最大值？最大值是set的最后一个元素，所以只要让一个iterator等于end再减减就好了~~

但是康到这里你可能觉得笔者太Naive了。比如这组数据：n = 4， 数组为 1， 2， 3， 4；

那么第一次取出来的值就是4, 而4没有后驱，这个时候就会出错。

~~辣鸡作者写的什么玩意儿~~

只要你继续看下去，这个问题会在两分钟内消失。考虑到每次选取（一对数中靠前的那个），只要不是当前序列的最后一个，这次选取就是合法的。

那么我们就有这样的解决方案：每次不把序列的最后一个放到set（平衡树）里，并加入特判。具体来说，对于以下数据：
n = 4, arr\[] = {1, 2, 3, 4};

最开始的时候，我们把除了最后一个元素都放进set， 此时set中的元素（为了方便理解只管一个set）为 {1， 2， 3}

再设个变量t2保存最后元素“4”和值（4）

第一次操作显然取出3。

然后特判：3是不是**set里的**最后一个元素？ 是的。

我们把3 push到队列里， 然后找到3的前驱（下标排序）， 是2。

然后把t2 push到队列里，做完这之后，让t2 = 2，也就是我们刚刚找出的前驱。

最后删除3，第一步操作就完成了。

如果n不变，arr\[] = {4, 3, 2, 1}

第一步取出4， 不是最后一个元素；

直接将4和3依次push到队列里，再把set里面的erase掉，这一步操作就完成了。

单次操作复杂度$\Theta(log_2 n)$, 总复杂度$\Theta(n log_2 n)$。真的慢的要死，还没sort的快。

好了，思路已经讲完了。其实这题如果手敲平衡树的话，对代码实现能力还是有很大帮助的。~~所以你们闲着无聊可以试试~~

具体看~~几乎不可读的~~代码吧

```cpp
#include <cstdio>
#include <iostream>
#include <map>
#include <set>
#include <queue>

constexpr int INF = 0x3f3f3f3f;

std::queue<int> q;


struct Node1{
  int index, val;
  Node1(void) : index(0), val(0) {}
  Node1(int a, int b) : index(a), val(b) {}
  bool operator<(const Node1 &a) const{
    return this->index < a.index;
  }
};
struct Node2{
  int index, val;
  Node2(void) : index(0), val(0) {}
  Node2(int a, int b) : index(a), val(b) {}
  bool operator<(const Node2 &a) const{
    return this->val < a.val;
  }
};
std::set<Node1> tts;\\原谅我不羁放纵乱取名
std::set<Node2> sst;\\上面的是按下标排，下面的是按数值排

int n;



int main(int argc, char const *argv[]) {
  int *tmpArray;
  scanf("%d", &n);
  tmpArray = new int[n];
  for (int i = 0; i != n; ++i) 
  scanf("%d", &tmpArray[i]);
  for (int i = 0; i != n - 1; ++i)
  sst.insert(Node2(i, tmpArray[i])), 
  tts.insert(Node1(i, tmpArray[i]));
  std::set<Node2>::iterator i;
  std::set<Node1>::iterator j;
  int endindex, endval;
  endindex = n - 1, endval = tmpArray[n - 1];
  while (!sst.empty()) {
    i = sst.end(); --i;\\取最值
    int index1 = i->index, val1 = i->val;
    j = tts.find(Node1(index1, val1));
    int index2, val2;
    ++j;
    if (j == tts.end()) {//是最后一个元素
      --j;\\取前驱
      index2 = endindex, val2 = endval;
      if (j != tts.begin()) --j;\\防RE
      endindex = j->index, endval = j->val;
      sst.erase(Node2(endindex, endval)), tts.erase(j);
    } else {
      index2 = j->index, val2 = j->val;
      sst.erase(Node2(index2, val2)), tts.erase(Node1(index2, val2));
    }
    sst.erase(Node2(index1, val1)), tts.erase(Node1(index1, val1));
    q.emplace(val1), q.emplace(val2);
  }
  while (!q.empty()) {
    printf("%d ", q.front()); q.pop();
  }
  return 0;
}
```

代码里可能含有很多“多此一举”的东西。。。

辣鸡作者滚粗了，有问题评论或私信吧

---

## 作者：Drinkkk (赞：0)

[在我的博文中阅读以获得更好的阅读体验](http://118.89.20.3/index.php/2019/07/15/lgoj-p4811-%e3%80%90x%e9%be%99%e7%8f%a0%e3%80%91/) 。

## Description

$n(2|n)$ 个编号互不相同龙珠按照给定的顺序排成一个队列，龙珠的编号为 $1$ ~ $n$ 的排列。每次选择并取出龙珠队列中 **相邻** 的两个龙珠，放到目标队列的末尾（目标队列最开始是空的，且这两个龙珠的前后顺序不变），然后去除原龙珠队列的空隙。反复多次，直到原龙珠队列为空。现在请求出所有方案中目标队列字典序最大的的排列。

$n \leq 10^5$

## Solution

这是 **洛谷7月月赛** 的题目，因为比赛时间和上课时间刚好冲突于是就没有参加，所以在赛后来补题。

看到这道题目直接就一眼切掉了，但是因为细节问题导致我骗了一个数据点下了，还拿了一个题解来对拍（没看题解和题解代码）才过去的......

考虑使用 **贪心** 和 **数组模拟链表** 来接题。

因为要使字典序最大，所以我们要 **让大的数尽量靠前** 。但是显然当当前龙珠队列中剩下的最大的数在最后一个位置的时候，不能够达到 **让大的数尽量靠前** ，为了方便表述，不妨设当前最大的数为 $i$ ，它左边的数为 $j$ （ $i$ 没有右边的数 ）。

那么当$j<(i-1)$时，让$(j+1)$ ~ $(i-1)$先放入目标队列是一个更优的选择。

于是我们就得到了一个很粗暴的做法：当 $i$ 在最右边时，先跳过  $i$ ，然后让去处理 $(i-1)$ ，我们定义 $p$ 为当前要处理的数。

那么当 $p \leq 0$ 时检测一下是否所有数都到了目标队列即可，如果没有就让 $p=n$ ，然后再做一遍即可，以此类推。

因为上述过程最多执行两次，所以时间复杂度是 $O(n)$ 的，可以 A 掉本题。

注意要在中途检测 $p$ 是否 $\leq 0$ 。

具体的细节见 **代码** 。

## Code

```
#include <cstdio>
int l[1000001],r[1000001];
int wz[1000001],a[1000001];
int main()
{
	int n=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		wz[a[i]]=i;
		l[i]=i-1,r[i]=i+1;
	}
	int p=0;
	while(true)
	{
		p=n;
		while(p>=1)
		{
			while(wz[p]==0)
			{
				p--;
				if(p<=0)
				{
					break;
				}
			}
			if(p<=0)
			{
				break;
			}
			while(r[wz[p]]==n+1)
			{
				p--;
				if(p<=0)
				{
					break;
				}
			}
			if(p<=0)
			{
				break;
			}
			while(wz[p]==0)
			{
				p--;
				if(p<=0)
				{
					break;
				}
			}
			if(p<=0)
			{
				break;
			}
			int x=wz[p],y=r[wz[p]];
			printf("%d %d ",p,a[y]);
			int ta=l[x],tb=r[y];
			int dta=r[y],dtb=l[x];
			l[dta]=ta;
			r[dtb]=tb;
			wz[p]=wz[a[y]]=0;
			a[x]=a[y]=0;
		}
		bool flag=true;
		for(int i=1;i<=n;i++)
		{
			if(wz[i]!=0)
			{
				flag=false;
			}
		}
		if(flag==true)
		{
			break;
		}
	}
	return 0;
}
```

---

## 作者：Adam_Ng (赞：0)

堆+双向链表

用双向链表维护左右侧龙珠，来确定当前最右边的龙珠（即不可取的龙珠），用堆贪心取当前最大，然后将它和它右边的龙珠弹出到答案，然后把它的左侧龙珠和它右侧的右侧的的龙珠（没有打重)连在一起。可是右边这颗的不在堆顶，怎么弹出呢？

我们用一个bool数组来标记已经被弹出过的和其右侧的节点，这样，那颗节点出现在堆顶时，我们就可以直接忽略它了。

特殊地，以下情况在堆顶时不予处理

1.右侧是$n+1$的

2.被标记过的

完

附上赛场代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200005;
priority_queue<pair<int, int> > heap;
bool pop[N];

int n, val[N], rt[N], lt[N];
int ans[N], cnt = 0;

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) {
        scanf("%d", val + i);
        heap.push(make_pair(val[i], i));
        rt[i] = i + 1; lt[i] = i - 1;
    }
    while(!heap.empty()) {
        int v = heap.top().first,now = heap.top().second; heap.pop();
        if(rt[now] == n + 1 || pop[now]) continue;
        pop[now] = pop[rt[now]] = 1;
        ans[++cnt] = v; 
        ans[++cnt] = val[rt[now]];
        rt[lt[now]] = rt[rt[now]];
        lt[rt[rt[now]]] = lt[now];
    }
    for(int i = 1; i <= cnt; ++i) printf("%d ", ans[i]);
}
```




---

## 作者：万弘 (赞：0)

啥?排序?没想到啊?(尽管T3的离散化用到了排序,但??没用到T2里来??所以就有了这篇题解)

首先,要求字典序最大,自然想到贪心--每一步尽可能取最大的,最后得到的序列字典序一定最大.

于是**60分的暴力**来了:  
对于每一次取龙珠,都这样做:(设剩余序列为$a$,长为$n$)  
1.  暴力扫$a$,得到$max\{a_i|i\in[1,n-1]\}$,记为$a_x$.注意到不能将$a_n$考虑进去,因为$a_n$后面没有龙珠了,没法取两颗.  
2.  将$a_x,a_{x+1}$加入答案序列$b$.  
3.  将$a_x,a_{x+1}$从$a$中删除(后面的要补上来),并将$n$减去$2$.(题目中说到"...然后去除原龙珠队列的空隙")

显然时间复杂度$O(n^2)$.  
代码:
```cpp
/**********///省略了头文件&快读
#define MAXN 100011
ll a[MAXN],b[MAXN];
ll qmax(ll n)
{
	ll res=1;
	for(ll i=2;i<=n;++i)
		if(a[i]>a[res])res=i;
	return res;
}
void delp(ll x,ll n)
{
	for(ll i=x;i<(n-1);++i)a[i]=a[i+2];
}
int main()
{
	ll n=read(),p=0;
	for(ll i=1;i<=n;++i)a[i]=read();
	while(n)
	{
		ll x=qmax(n-1);
		b[++p]=a[x];b[++p]=a[x+1];
		delp(x,n);
		n-=2;
	}
	for(ll i=1;i<=p;++i)printf("%lld ",b[i]);
	return 0;
}
```

然后100分的做法也不难:

考虑线段树维护最大值.  
看上面的步骤1,$max\{a_i|i\in[1,n-1]\}$就明显可以单次$O(logn)$做了.  
步骤2好像也简单,只要把$a_x,a_{x+1}$加入$b$就行.  
步骤三好像只要把得到最大值的那两个位置用线段树单点修改成0就行了,也是单次$O(logn)$

PS:其实这里线段树维护的不是最大的$a_i$,而是使$a_i$最大的$i(x)$.

可惜,这个算法~~虽然能过样例,但~~是错误的  
看这样一个数据:
```
6
5 6 1 2 3 4
```
这个程序会输出6 1 5 0 3 4  
啥??这个0是什么鬼?2呢?  
我们看看这个算法运行时是个什么情况:  
把6 1拿出来,变成5 0 0 2 3 4.  
5是最大的,拿出了5 0!!!没错,5和0!!6已经被拿掉了,所以这个算法实际上没有做到"去除原龙珠队列的空隙".

于是,刚刚写完线段树的我又要拿出半年没用的链表...  
用(双向)链表,拿出6 1后让5的nxt指向2,2的pre指向5.

所以优化的步骤2应该为:把$a_x,a_{x\text{的后继}}$加入$b$.  
步骤3应为:用链表把$a_x,a_{x\text{的后继}}$从a中彻底删除

每一步都是$O(logn)$,总时间复杂度为$O(nlogn)$.

赛后才知道,我的线段树+链表被神奇的排序爆踩..
```cpp

/**********///省略了头文件&快读
#define MAXN 100011
ll a[MAXN],b[MAXN],n;
struct Segment_Tree//单点修改线段树即可,不用lazy_tag了
{
	#define tl t[num<<1]
	#define tr t[num<<1|1]
	#define rt t[num]
	ll t[MAXN<<2|1];
	ll greater(ll u,ll v)
	{
		if(a[u]>a[v])return u;
		else return v;
	}
	void pushup(un num)
	{
		rt=greater(tl,tr);
	}
	void build(ll* a,un l=1,un r=n,un num=1)
	{
		if(l==r)rt=l;
		else
		{
			un mid=(l+r)>>1;
			build(a,l,mid,num<<1);build(a,mid+1,r,num<<1|1);
			pushup(num);
		}
	}
	ll qmax(un ql,un qr,un l=1,un r=n,un num=1)
	{
		if(ql<=l&&r<=qr)return rt;
		if(ql>r||qr<l)return 0;
		un mid=(l+r)>>1;
		return greater(qmax(ql,qr,l,mid,num<<1),qmax(ql,qr,mid+1,r,num<<1|1));
	}
	void modify(un pos,un x,un l=1,un r=n,un num=1)
	{
		if(l==r)
		{
			rt=x;
			return;
		}
		un mid=(l+r)>>1;
		if(pos<=mid)modify(pos,x,l,mid,num<<1);
		else modify(pos,x,mid+1,r,num<<1|1);
		pushup(num);
	}
}sgt;
struct list//双向链表
{
	struct node
	{
		ll pre,nxt;
	}a[MAXN];
	void build(ll n)
	{
		a[1].nxt=2;
		for(ll i=2;i<n;++i)
		{
			a[i].pre=i-1;
			a[i].nxt=i+1;
		}
		a[n].pre=n-1;
	}
	void del(ll x)
	{
		a[a[x].pre].nxt=a[x].nxt;
		a[a[x].nxt].pre=a[x].pre;
	}
	ll qpre(ll x)//询问前驱
	{
		return a[x].pre;
	}
	ll qnxt(ll x)//询问后继
	{
		return a[x].nxt;
	}
}lt;
int main()
{
	n=read();
	for(ll i=1;i<=n;++i)a[i]=read();
	sgt.build(a);lt.build(n);//建立这两个数据结构
	ll cnt=0,tmp=n;
	while(cnt<n)
	{
		ll p=sgt.qmax(1,tmp-1),nxt=lt.qnxt(p);//要取出的两颗龙珠
		sgt.modify(p,0);sgt.modify(nxt,0);//线段树上删掉
		b[++cnt]=a[p];b[++cnt]=a[nxt];//存进b里
		a[p]=0,a[nxt]=0;
		while(a[tmp]==0)--tmp;
		lt.del(p),lt.del(nxt); //链表里删掉
	}
	for(ll i=1;i<=cnt;++i)printf("%lld ",b[i]);
	return 0;
}
```

---

## 作者：detect (赞：0)

自认为可读性比较高的题解（打脸警告）

讲下思路（这东西谁都想得出来吧），每一次选最大的不在末尾那一个就行了，简单贪心。

然后维护结构自然选择链表了。

更多理解和实现在代码里

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],maxx,w[100005],t[100005],nex[100005],v[100005];
//a是元素，w记录位置，t表示能不能选，nex是链表，v是已经选了那些
//其实v和t用处不一样，见后文 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		nex[a[i-1]]=a[i];
		w[a[i]]=i;//简单的预处理 
	}
	a[n+1]=a[n+2]=1e9;
	int maxx=n;//maxx是贪心中的最大值 
	m=n+2;
	int jw=n;//确定哪一个点为末尾 
	t[a[maxx]]=1;//不能选最后 
	while(m-=2)//丑陋的循环 
	{
		while(t[maxx]==1)
		maxx--;//找到合法最大值 
		int u=w[maxx];//确定位置 
		t[maxx]=1;
		t[nex[maxx]]=1;
		v[maxx]=1;
		v[nex[maxx]]=1;//双双标记 
		while(v[a[jw]]==1)
		jw--;//确定末尾，注意不能用t来判 
		t[a[jw]]=1;
		cout<<maxx<<" "<<nex[maxx]<<' ';
		int hh=u,uu=u;
		while(uu>0&&v[a[uu-1]]==1)//找到最前面的没选的值 
		{
			uu--;
		}
		while(u+2<=n&&v[a[u+2]]==1)//最后没选的合法值 
		{
			u++;
		}
		nex[a[uu-1]]=a[u+2];//维护链表 
	}
	return 0;
}
```

最后，希望大家能专心打满比赛，不要像我，因各种原因不断耽误时间，导致此题没赶上18.00交，算是个深刻的lesson吧。

如果有用的话，希望大家不要吝啬自己的赞~~ (谢谢大家的支持


---

## 作者：Sober_Clever (赞：0)

很多又好又快的方法大佬们已经说的很清楚了

~~这里介绍一个复杂的~~

set+链表

用pair记录相邻元素的情况

插入set中

每次输出set的尾部

再更新序列就可以了

~~（讲真，有点小慢）~~

最后是有点小长的代码~
```cpp
#include<cstdio>
#include<set>
using namespace std;
const int MAXN=1e5 + 5;

int read()
{
    int x=0,w=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48;c=getchar();}
    return x*w;
}

struct Node
{
    int pre,val=0,next;
}a[MAXN];

int num[MAXN]={0};//num记录每个元素对应的下标
set<pair<int,int> > s;
int main()
{
    int n=read(),cnt=0;
    for(int i=1;i<=n;i++)
    {
        a[i].val=read();
        num[a[i].val]=i;
    }
    pair<int,int> p;
    for(int i=1;i<n;i++)
    {
        a[i].pre=a[i-1].val;
        a[i].next=a[i+1].val;
        p.first=a[i].val,p.second=a[i+1].val;
        s.insert(p);
    }
    a[1].pre=a[n].next=0;
    while(cnt<n)
    {
        set<pair<int,int> >::iterator it;
        it=(--s.end());
        s.erase(it);
        p=(*it);
        if(!p.second) continue;
        printf("%d %d ",p.first,p.second);
        cnt+=2;
        int i=num[p.first],j=num[p.second];
        pair<int,int> p1,p2;

        p1.first=a[i].pre,p1.second=a[i].val;
        s.erase(p1);

        p1.first=a[j].val,p1.second=a[j].next;
        s.erase(p1);//删除前一个

        p1.first=a[i].pre,p1.second=a[j].next;
        s.insert(p1);//添加新元素

        int pre=a[i].pre,next=a[j].next;
        i=num[pre],j=num[next];
        a[i].next=next,a[j].pre=pre;
    }
    return 0;
}

```
~~我可能真的是数据结构学傻了~~

---

## 作者：亚由亚由 (赞：0)

[题目链接](https://www.luogu.org/problemnew/show/P5462)

这道题还是很有意思的,要求字典序最大,只需每次贪心取最大值,删除,再处理一下边界就好了;

求最大值还要删除,再一看到n≤100000的数据范围,肯定马上想到平衡树啊
~~(我也不知道为什么大家都写的双向链表,肯定是我太蒟蒻了)~~;

因为手写splay真的太烦了,用STL就是能解决的;

用一个set存值,一个存位置,每次查询最大值,输出后再删除就好了;
~~(因为本蒟蒻确实不太熟悉STL,判边界时在加了一个存位置的set)~~;
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
using namespace std;
int n,a[100005],v[100005],nx,tot;
int main()
{
    int i,j,x,y;
    set<int> f,f1,f2;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
    	v[a[i]]=i;
    	f1.insert(-a[i]);//插入负数以求最大值
    	f.insert(i);
    	f2.insert(-i);
    }
    while(!f.empty())
    {
        x=-*f1.lower_bound(-n);
        if(v[x]==-*f2.lower_bound(-n))//维护边界
        x=-*f1.upper_bound(-x);
        nx=*f.upper_bound(v[x]);//后一个数
        f1.erase(-x);
        f1.erase(-a[nx]);
        f.erase(v[x]);
        f.erase(nx);
        f2.erase(-v[x]);
        f2.erase(-nx);
        printf("%d %d ",x,a[nx]);
    }
    return 0;
}
```


虽然跑得不是很快,但是思路和代码还是十分简单的
~~(毕竟是T2嘛)~~

---

## 作者：fmj_123 (赞：0)

首先题目要求字典序最大，则显然我们应该将大的数安排在前端。

那么现在来处理取相邻数的问题，我们可以使用并查集维护 每个位置往后最近的未被取走的数的位置，下文用$fa_i$表示。

当一个数（假定位置为$i$）被取走时，将$fa_i=fa_{i+1}$，查询时直接取出即可。

另外，当要取的数是最后一个时，后面没数，不合题意。需要特判。

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;int a[100500],fa[100500],ans[100500],b[100500];
//b数组存每个数的出现位置
int fafa(int x)
{
	if (fa[x]==x) return x;
	return fa[x]=fafa(fa[x]);
}
void hebing(int x,int y)
{
	x=fafa(x);y=fafa(y);
	fa[x]=y;
}
//并查集维护上文所述
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[a[i]]=i;
		fa[i]=i;
	}
	for (int i=n;i>0;i--)
	{
		if (fa[b[i]]==b[i]&&fafa(b[i]+1)!=0&&b[i]!=n)//特判，fafa(b[i]+1)=0代表后面没数
		{
			ans[++m]=i;
			ans[++m]=a[fafa(b[i]+1)];
			hebing(b[i],fa[b[i]+1]);
			hebing(fa[b[i]+1],fafa(fa[b[i]+1]+1));
		}
	}
	for (int i=1;i<m;i++)
	{
		cout<<ans[i]<<" ";
	}
	cout<<ans[m];
	return 0;
}
```

---

## 作者：邻叔丁基苯酚 (赞：0)

题目描述

“X龙珠”是一款益智小游戏。游戏中有 n(2∣n)个编号互不相同龙珠按照给定的顺序排成一个队列，每个龙珠上面都有一个编号。每次操作时，选择并取出龙珠队列中相邻的两个龙珠，放到目标队列的末尾（目标队列最开始是空的，且这两个龙珠的前后顺序不变），然后去除原龙珠队列的空隙。反复多次，直到原龙珠队列为空。可见，因为决策不一样导致目标队列顺序不一样。现在请求出所有方案中、目标队列字典序最大的方案。只需要给出目标队列即可。

例如，当原龙珠队列是 [1,3,2,4] 时，可以先取出 3 和 2，此时目标队列是 [3,2]，原龙珠队列是 [1,4]；再将剩下两个龙珠放入目标队列，得到目标队列是 [3,2,1,4]

思路：用双向链表来保存原龙珠队列。用优先队列来维护最值，从而使字典序最大。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000000+10;
int n,a[maxn],l[maxn],r[maxn];//用数组模拟链表。l是左指针，r是右指针。
map<int,bool> used;//用来判断数字是否已经进入目标队列。
priority_queue<int> PQ;//用优先队列（大根堆）维护最大值。
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",a+i);
		if(i<n) PQ.push(a[i]);//将所有的相邻编号的二元组中的左边元素入堆。左元素可通过指针找到右元素。故无需让最后一个元素入堆。
		r[a[i-1]]=a[i];//   构造链表。
		l[a[i]]=a[i-1];
		used[a[i]]=false;
	}
	r[a[n]]=0;
	while(!PQ.empty())
	{
		int x=PQ.top();
		if(used[x]){PQ.pop(); continue;}//如果堆顶元素已经用过（可能它的前一个元素连它一起用过），直接弹出。
		if(r[x]==0){PQ.pop();}
		if(r[x]!=0 && !used[x])
		{
			used[x]=true;
			used[r[x]]=true;//从原队列取出两个元素。
			r[l[x]]=r[r[x]];
			l[r[r[x]]]=l[x];//维护双向链表。
			PQ.pop();
			printf("%d %d ",x,r[x]);
		}
	}
	return 0;
}
```
这种方法更倾向于使用数据结构。用STL后对算法的要求并不高。


---


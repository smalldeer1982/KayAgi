# [Celeste-B] Golden Feather

## 题目背景

> 就是这样，Madeline。

> 保持呼吸。你能行。

## 题目描述

“你的呼吸让那片羽毛一直飘着。”

“平稳缓慢地呼吸，吸气，吐气。”

“看吧，每次都是这么轻松。”

随着 Madeline 的呼吸，羽毛上下移动着。

通过 Madeline 的观察，她还发现，羽毛似乎遵循这一种神奇的运动轨迹。

在每一轮呼吸中，羽毛会在特定的地方停止，这些地方都是有魔力的，具体来说，第 $i$ 个停留处的魔力是 $(i+1)^2-1$。

并且，在一轮呼吸停止时，羽毛会渗透出一些能量，只要能用这些能量沟通这些停止的地方，Madeline 就能运用羽毛的力量飞翔。更具体的，由于同性相斥，两个地方魔力的相似程度越高就越难被沟通，沟通两个地方所需要的能量为这两个地方魔力的 $gcd$。

在一轮一轮的呼吸中，Madeline 已经无暇算出最少需要的能量，由于羽毛渗透出的能量不多，你能帮帮她算出最少需要多少能量来沟通这些羽毛停止的地方吗？

## 说明/提示

n=3 的样例解释如下图

![T1_2.png](https://i.loli.net/2019/09/14/PtflkNCE8b3iKzB.png)
![T1.png](https://i.loli.net/2019/09/14/AIYlMZgonL7thfu.png)

对于 $5\%$ 的数据，$n \leq 3$

对于 $10\%$ 的数据，$n \leq 1000$

对于 $50\%$ 的数据，$n \leq 10^6$,$T \leq 10$

对于 $100\%$ 的数据，$n \leq 10^{18}$,$T \leq 100$

## 样例 #1

### 输入

```
4
1
2
3
9
```

### 输出

```
0
1
2
8```

# 题解

## 作者：pikabi (赞：23)

~~这可真是一道水题，但我比赛时就是没做出来~~

经过昨天一夜冥思苦想，我想到了一种类数学的证明方法（~~其实打表找规律更快~~）————>>

## 题意

将点权为（i + 1 ) ^ 2 - 1 , i = 1 ~ n,的这n个点连通。其实这是一颗树，共有n - 1个节点，两点之间的距离是点权的最大公约数。

## 做法

##### 准备

#### 设停止的地方数为i，f(i) =（i + 1 ) ^ 2 - 1 = i * ( i + 2 ) 。条件① ：存在 i * ( i + 2 ），i = 1 ~ n - 1 与 n * (n + 2) 互质。这样就可以保证已有的n - 1个点加上这个点后所得的数最小（加1）。

#### 正文

1、一开始假设 2 ~ 正无穷 这些数都不满足条件 
①（没有比1更小的，故1不在）。

2、当i = n - 1时，f(n - 1) = (n - 1)(n + 1) , f(n) = n * (n + 2), n - 1以及n + 1与 n 都互质， n + 1 与 n + 2 也必定互质，所以当且仅当n - 1 和n + 2互质时， gcd(f(n - 1),f(n)) = 1。所以只有n - 1为3的倍数时（想想为什模）， 两数不互质， 所以不满足条件①的数从2  ~ 正无穷变成了 4， 7， 10， 13， 16 ，19，22 ……正无穷。 

3、f(n - 2) = (n - 2) * n， 与f(n)必定不互质。

4、f(n - 3) = (n - 3) * (n - 1), n - 3 与 n 一定互质（因为剩下来的都是是除以3余1的），n - 1 与 n + 2 不可能互质（如2），转5；

5、f(n - 4) = (n - 4 ) * (n  - 2 ), 此时该式已超出4的范围，所以f(4)一定不满足条件①。同上可得奇数可以满足条件①。所以范围又缩小到4， 10， 16， 22 …… 正无穷。；

6、反复以上操作，最终假设我们是机器人我们能进行无数次操作，**我们惊奇滴发现10以外的数字都会被排除，只有4 和 10 留在里面， 可以计算得到当n = 4 或n = 10时， 结果为5 或 11， 其余的由于都只有n - 1个节点且权值都为1，故其余答案为n - 1。**

## 终于到了上代码的时间了QAQ

```cpp
#include <cstdio>
#define ll long long

using namespace std;

ll t, n;

int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		if(n == 4) printf("5\n");
		else if(n == 10) printf("11\n");
		else printf("%lld\n",n - 1);
	}
	return 0;
} 
```
ps:这只是作为蒟蒻的我的理解，如果有巨佬能够运用强大的数学方法证明当然更好喽

---

## 作者：5ab_juruo (赞：19)

由数据范围可知，这道题一定是一道结论题Or数学题。

所以，我们打开样例，立刻臆测了一个$Ans=n-1$的算法，然后……

后来，经过我们不懈的测试~~骗分~~，终于发现：

> 当$n=4$或$n=10$时，$Ans = n+1$

那这是为什么呢？

---

首先，我们要读题：

大意是，给你一张图，请你求出它的最小生成树的边权和。

那么，我们采用递推的思想。用$f_i$表示$i$个点最小生成树的边权和。

那么显然：

$f_i \leqslant \min(S) + f_{i-1}$，其中$S = \{e|e\in E,e.dest=i \}$

（即到达$i$号点中边权最小的一条边连上）

显然，如果$\exists e\in E,e.dest=i,e.val=1$那是最好的，而此时$f_i = 1 + f_{i-1}$

所以，我们接下来就要证明：绝大多数情况下，$f_i = 1 + f_{i-1}$。

> 为下面叙述方便，规定$n\;\bot\; m$为$\gcd(n,m)=1$。

# Part 1 -- 初步分析

假设$\exists m \in [ 1,n),\exists e$且$e.from=m,e.to=n,e.val=1$，

则必有：

$((m+1)^2-1)\;\bot\; ((n+1)^2-1))$

根据辗转相减法，得：

$((m+1)^2-1)\;\bot\; ((n+1)^2-(m+1)^2)\qquad$（因为$m<n$，所以两边都为正。）

因式分解，得：

$(m(m+2))\;\bot\; (n+m+2)(n-m)$

注意，这个式子非常重要，因为从两边各取一个因式，两两互质（显然，反证法可得）。所以，我们可以得到四组互质：

$\begin{cases}n\;\bot\; m\\n\;\bot\; (m+2)\\(n+2)\;\bot\;m\\(n+2)\;\bot\;(m+2)\end{cases}$

这四个式子同时成立是存在边权和为$n-1$的最小生成树的充要条件。

至此，第一部分结束。

# Part 2 -- 深挖关系

接下来我们就会一脸懵逼：

这几个式子咋用哪？

看官莫急，我们换一个角度：

> 何为互质？

>  ——答：没有相同的质因数。

没错，接下来我们就从质因数的角度分析这几个式子。

---

以第二个为例：

$n\;\bot\; (m+2)$

如果不成立，那能说明什么？

即$\exists p,n\equiv 0(\mod p),m\equiv p-2(\mod p)$。

也就是说，对于一个质数$p$，如果$n\mod p,m\mod p\in \{0,p-2\}$，则这四个式子中必然有一个不成立，也就不存在边权和为$n-1$的最小生成树。

画成图表就是这样（红格代表$m$可以）

![](https://cdn.luogu.com.cn/upload/image_hosting/5a8t4a10.png)

我们~~很感性地~~发现，从$\mod 5$开始，红色的面积大幅上升，所以我们只需考虑$\mod 2$和$\mod 3$即可。

~~然而mod5还是有影响的。~~

所以，我们枚举$0\sim 11$的$n$、$m$，看看规律：

（红色代表可以，白色代表被$\mod 2$，$\mod 3$Pass掉的情况，而黄色代表被$\mod 5$Pass掉的情况。~~虽然理论上$(11,11)$也得被Pass，但无伤大雅，所以偷懒了qaq。~~）

![](https://cdn.luogu.com.cn/upload/image_hosting/kmsa8nsv.png)

~~好漂亮啊~~

所以根据上图~~感性~~分析一下，在$n \in [0,11]$时，哪些点不行呢？

显然$m<n$，所以经处理后图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/jsr8clzr.png)

发现有$4$行空着，那么我们分别来看一看：

> $0$：$n$不能为零啊……

> $1$：单身狗的自卑……

> $4$，$10$：妥妥的……

所以，$4$和$10$不能做到。

# Part 3 -- 结尾

那么，是不是所有的$n\equiv 4(\mod 6)$就都炸了呢？莫慌，我们来分析分析。

## $n \equiv 0(\mod 6)$

1. $6$：我真险。
2. $\geqslant 6$：$11$收入囊中。

此时此刻，我们来看一看$6k$的心理：

> 我手里有一个$5$，还有一个$11$，

> 任意一个质数显然干不掉我们两个。

> 两个质数也干不掉，我有奇偶性撑腰$\sim$

所以，$n\equiv 0(\mod 6)$搞定。

## $n \equiv 1,2,3,5(\mod 6)$

~~请读者自证，基本同理。~~

## $n \equiv 4(\mod 6)$

1. $16$：幸好我有一个$5$和一个$11$。
2. ~~请读者自行理解。~~

综上所述，只有$n=4,10$是特例，其余所有的都可以得到$f_i=f_{i-1}+1$

---

Wait!如果链在$4$这里断了，那么我们是怎么做到继续递推的？

答：只须构造一个点数为$5$，边权和为$4$的$MST$即可。

幸运的是——$(4+1)^2-1=24,(5+1)^2-1=35,24\;\bot\; 35$！

于是只需自$4$向$5$连边即可。

而$(1+1)^2-1=3,3\;\bot\; 35$，所以$f_5=f_3+2$

$10$亦同理，留给读者思考（~~明明是$5ab$太蒟了，根本算不出来~~）

---

最后一个问题：如果$n=4,10$，那么边最少究竟是多少呢？

我们发现，自$4$号点向前面连边，最小的$\gcd$为$3$，$10$亦同理。

所以，$f_4=f_3+3,f_{10}=f_9+3$，化简得$f_i=i+1(i=4,10)$

所以，最终的答案是$f_n=\begin{cases}n-1&n\ne 4,10\\n+1&n=4,10\end{cases}\qquad(n \in N^{+})$

代码就不放了，重点是理解证明过程。

# 鸣谢

@unputdownable ， @_ZMF_ 巨佬的证明提示及帮助。

---

## 作者：Mophie (赞：13)

**update:修改了数学格式**

首先根据前人的方法，我们可以得到当 $i=4$ 或 $i=10$ 时答案为 $5$ 和 $11$ ，否则为 $i-1$ ;
 
这篇题解就是来证明这是为什么的。——来自这道题证了2小时的初一蒟蒻

————————————————————————————————————————分割线

## 第一大步：证出除了 $i\equiv4\pmod{6}$ 的情况

首先由题可得是求最大公因子的最小生成树

用Prim的思想，将点一个一个加进去。即每个点都要至少要与其中一点最大公因子为 $1$ ，才能使得结果为 $i-1$ ；

考虑两对数： $(i+1)^2-1$, $((i-1)+1)^2-1$ 和 $(i+1)^2-1$ , $(2+1)^2-1$

#### 一、 $(i+1)^2-1=i(i+2)$ , $i^2-1=(i-1)(i+1)$

显然 $\gcd(i,(i+1))=1,\gcd(i,(i-1))=1,\gcd((i+2),(i+1))=1$

所以当 $\gcd((i-1),(i+2))=1$ 时两数互质，即满足条件；

所以若要使不满足条件，即当 $i\equiv1\pmod{3}$ 时，这两对数才有公因子

#### 二、 $(i+1)^2-1=i(i+2)$ , $(2+1)^2-1=8$

若 $i\equiv1\pmod{2}$ 则2与i互质，即满足条件；

**所以，除了$i\equiv4\pmod{6}$以外，其他都不需再考虑**

## 第二大步:证出当 $i\equiv4\pmod{6}$ 时也成立

则设 $i=6k+4$ ,分情况讨论：

#### 一、 $k\equiv0\pmod{2}$

设 $k=2m$

则第 $i$ 个数为 $(12m+5)^2-1=144m^2+120m+24=4(6m+2)(6m+3)$

我们惊奇的发现：当某数为 $(6m-1)$ 时

$(6m-1+1)^2-1=(6m+1)(6m-1)$ 竟与 $4(6m+2)(6m+3)$互质！

**所以当$k=2m$,$m>0$时不需再考虑**

而当 $m=0$ ,即 $i=4$ 时不行，最小为 $5$ ;

**所以当 $i=12m+4$ 时唯一反例为 $i=4$ ，答案为 $5$ ，其余都为 $i-1$**

#### 二、 $k\equiv1\pmod{2}$

则设 $k=2m+1$ ,所以可得：

$(i+1)^2-1=(12m+11)^2-1=144m^2+264m+120=4(6m+6)(6m+5)$

##### 1.考虑 $(3m+2+1)^2-1=(3m+2)(3m+4)$ 与原式的公因式

根据辗转相除法可得当 $m\equiv1\pmod{2}$ 时显然成立

**所以当 $m\equiv1\pmod{2}$ 时不需再考虑**

##### 2.考虑 $(6m-1+1)^2-1=(6m-1)(6m+1)$ 与原式的公因式

根据辗转相除法可得若 $m\equiv6\pmod{7}$ 不成立，则两式公因式为 $1$

**所以只需考虑 $m\equiv6\pmod{7}$ 即可**

##### 3.考虑 $(3m-1+1)^2-1=(3m+1)(3m-1)$ 时与原式的公因式

根据辗转相除法可得若 $m\equiv5\pmod{7}$ 不成立，则两式公因式为 $1$

所以当 $m\equiv6\pmod{7}$ 时也成立

而当 $m=0$ 即 $i=10$ 时不行，因为 $3m-1,6m-1\leq0$ ,所以此时为 $11$ 

而其他情况都为 $i-1$ ;

--------

所以结论成立。

这篇证明当然是比较严谨的，但考虑到我的证明时间，考试时还是打表找规律吧（雾

$$ ending $$

---

## 作者：chinaxjh (赞：7)

# 前言
这道题初读可能不知所云，我读了四五遍才弄懂，然后打了个暴力找了一下规律，然后交了一发骗分就在赛场上一发A了，所以如果想要看具体数学证明的可以跳过这篇题解，我只说说我在比赛时的想法。
# 读题
~~我的语文成绩令我有点担忧~~

说得明白点，给定的$n$，就是定点数，$(i+1)^2$−$1$，就是第$i$个点上的权值，任意两点可以连边，边上的权值就是两个点的$gcd$，然后要求最小生成树的大小
# 初读样例
天哪，样例里的答案都是$n-1$，我交一个试试吧!

结果只有5分

~~于是你放弃了这道送分题~~
# 暴力找规律
根据$Prim$算法，我们假设自己算完了前$n-1$个点，讨论第$n$个点和前面连边最小的一条边的权值大小。

于是打了一个暴力，对$10^6$的数据一个一个尝试，发现除了4和10两个节点，其他节点都与前面的点有一条权值为1的边
### 暴力框架
```
i 1->n
{
记录a[i]=(i+1)*(i+1)-1
j 1->i-1
{
k=gcd(a[i],a[j])
判断k是不是为1，可以用一个bool维护
}
如果没有一个为1输出i
}
```
既然第4个和第10个节点没有权值为1的边，那么最小的边为多少哪？

~~随便尝试一下就知道答案为3~~

于是就有了下面的骗分
# $AC$ $Code$ 
### $Pascal$
```pascal
var
  n,i:longint;
  k:int64;
begin
  readln(n);
  for i:=1 to n do
  begin
    readln(k);
    if k=4 then writeln(5)//判断4，2条1的边，一条3的边
    else if k=10 then writeln(11)//判断10，8条1的边，一条3的边
    else writeln(k-1);//否则就直接减一，k-1条1的边
  end;
end.
```
# 后记
关于为什么如果k不取4或10是最小生成树的所有边权值都为1，这个我无力证明，只是根据之前的暴力代码在$10^6$内得出的结论，然后盲猜推广到$10^{18}$，所以这篇题解仅供参考，欢迎吐槽，或有巨佬给出详细的证明，就权当抛砖引玉了$QWQ$
# 吐槽
[MtOI2019]永夜的报应(xor)

[LnOI2019SP]龟速单项式变换(SMT)(>)

与此题都是比赛的$T1$，且都是数论的鬼题，这好像已经成为$LG$的比赛趋势了，有兴趣的同学不妨尝试一下

---

## 作者：tanghairong (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P5560)

由于本人水平有限，数学不太好，因此证明可能有所缺漏，请见谅。

------------
题目大意：有 $n$ 个点，对于第 $i$ 个点，其权值为 $(i+1)^2-1$，两点之间的边的权值为两点权值的最大公约数，求这 $n$ 个点的最小生成树。

看一看样例，$n\le 10^{18}$，还有一个 $O(T)$ 的复杂度，那么就是要在 $O(1)$ 或者 $O(logn)$ 的时间内算出每个询问，于是：

找规律！！！

题目中说 $f_i=(i+1)^2-1$，化简一下：$f_i=i\times(i+2)$

同理，$f_{i-1}=(i+1)(i-1)$。

而我们发现，$i-1$ 与 $i$ 互质，$i$ 与 $i+1$ 互质，$i+1$ 与 $i+2$ 互质，那么，如果 $f_i$ 不与 $f_{i-1}$ 互质，只可能是 $i+2$ 不与 $i-1$ 互质。

如果 $i+2$ 不与 $i-1$ 互质，他们的公因子只可能是 3，而且 $i$ 除以 3 的余数一定是 1。

所以，我们可以就 $i$ 除以 3 的余数来对 $i$ 分类。

情况 1：$i\equiv0\pmod3$：此时只需要将 $i$ 与 $i-1$ 连边，这样边权为 1，总边权为 $i-1$。

情况 2：$i\equiv2\pmod3$：同情况 1。

情况 3：$i\equiv1\pmod3$：此时又分为 2 种情况：

情况 3.1：$i\equiv1\pmod6$：此时因为 $i$ 是奇数，与 2 连边即可，此时总边权还是 $i-1$。

情况 3.2：$i\equiv4\pmod6$：这个嘛……通过一些~~非正常~~做法我们发现，还要分两种情况：

情况 3.2.1：$i=4$ 或者 $i=10$：此时，所有比 $i$ 小的数的 $f$ 值都不与 $i$ 互质，那么这条边的权值就要取到 3 ，而前 $i-2$ 条边的权值都是 1，所以总共的权值和就是 $i+1$。

情况 3.2.2：其他：那么，这些值可以找到前面与他互质的数，边权为 1，总边权同样也是 $i-1$。

最终，通过分情况的讨论我们发现，除了 $i=4$ 与 $i=10$ 的答案是 $i+1$，其他的 $i$ 答案都是 $i-1$。

~~个人觉得证明得还算严谨~~

最后附上未极限压行后的11 行，长度 172 的 AC 代码：

```cpp
#include<iostream>
using namespace std;
main(){
	long long t,n;
	cin>>t;
	while(t--){
		cin>>n;
		if(n==4||n==10)cout<<n+1<<endl;
		else cout<<n-1<<endl;
	}
}
```
不过忠告一句，正常做题时一定不要省略 main 前面的 int 和 return 0 哦

看完如果觉得对你有帮助就点个赞呗qwq

---

## 作者：unputdownable (赞：3)

~~一个初一生试着给出一篇数学证明~~

### $\color{grey}\text{这里只是简单的说一个大概思路}$

首先我们设 $f(n)=(n+1)^2-1$

易知 $f(n)=n(n+2)$

对于 $gcd \left(\ f(n),f(n-1) \right.)= gcd\left(\ n(n+2),(n+1)(n+3) \right. )$

其中 $n$ 与 $(n+1)$ , $(n+2)$ 与 $(n+3)$ , $(n+2)$ 与 $(n+1)$ 都是互质的

$\therefore$ $gcd \left( f(n),f(n-1) \right.)$ 当且仅当 $n \equiv 1 \ (mod 3)$ 时有公因数 $3$ 

$\therefore$ 当 $n \equiv 2 \ (mod 3)$ 或 $n \equiv 0 \ (mod 3)$ 时直接将$f(n)$ 与 $f(n-1)$ 连接就好了

#### 现在我们来讨论 $n \equiv 1 \ (mod 3)$ 时的情况

在满足大前提的情况下

#### 1：

当 $n$ 为奇数时，将 $f(n)$ 与 $f(2)$ 连接就好了

#### 2：

当 $n$ 为偶数时，试验一下 , $f(4)$ 与 $f(10)$ 在其前面无与它互质的

而$f(4)$ 与 $f(5)$ 是互质的，$f(10)$ 与 $f(11)$ 是互质的

$\therefore$对于 $f(4)$ 与 $f(10)$ 要特判 ( 它们可以与 $f(1)$ 连，此时其他连接是 $1$ , 这个是 $3$ , 所以一共是 $5$ 或 $10$ )

$f(16)$ 与 $f(11)$ 互质。

$f(22)$ 与 $f(17)$ 互质。

...

#### ~~对于任意一个$f(n)$ , 你可以去跑一跑试试(逃~~

#### 2\#:

现在我们定义一个数列 $n_i$ 满足 $n_i \equiv 4 (mod 6)$

易知 $f(n_i)$ 就是我们讨论的

**如果**孪生素数猜想是成立的

那么取 $a$ 使 $a$ 与 $a+2$ 都是素数，

那么若 $f(a)$ 与 $f(n)$ 不互质，则 $f(n) \equiv 0 (mod\ \  a/a+2)$

多取几组就知道 $f(n)$ 远远应大于其本身，于是矛盾（此处证明仍有**缺陷**）

初一生只能做到这一步了

先上 $AC$ 代码吧：

---------
---------
## code：

```
#include<bits/stdc++.h>
using namespace std;
long long n,T;
int main(){
	cin>>T;
	for(int i=1;i<=T;i++){
		cin>>n;
		if(n==4||n==10)cout<<n+1<<endl;
		else cout<<n-1<<endl;
	}
	return 0;
}
```




---

## 作者：_ztyqwq (赞：2)

大多数 ~~（几乎所有）~~ 现有题解都没有给出 “只有 $ n = 4 $ 或 $ 10 $ 时 $ ans \not= n - 1 $” 的严格证明。

~~其实我也不会证~~

这里给出一个在**本题条件下**的，保证正确性的做法。

令 $ a_i = (i + 1)^2 - 1 = i (i + 2) $。如果存在一个 $ n $ 使得 $ \forall 1 \leqslant i \leqslant n - 1 $ 都有 $ \gcd(a_i, a_n)  \not= 1 $，则 $ n $ 一定**被 $ a_1, ..., a_{n - 1} $ 中每一个数中的某一个质因子整除**（这个质因子即 $ \gcd $）。

换句话说，我们只要考虑**若干 $ a_i $ 使它们包含的质因子尽量不重复**，就可以证明同时被这些质因子整除的 $ n $ 在本题条件下不存在（$ n \leqslant 10^{18} $）。

观察发现，当 $ n \equiv 0 \pmod 2 $ 时 $ 2 | a_n $，当 $ n \equiv 0 $ 或 $ 1 \pmod 3 $ 时 $ 3 | a_n $。因此我们主要考虑 $ n \equiv 1 \pmod 2 $ 且 $ n \equiv 2 \pmod 3 $ 的情况，即 $ n \equiv 5 \pmod 6 $。

经过手玩发现一些优美的 $ a_i $（其他的 $ a_i $ 由于出现了一些小的重复质因子，如 $ 5, 7 $，而不够优美）：

$ a_5 = 5 \times 7, $

$ a_{11} = 11 \times 13, $

$ a_{17} = 17 \times 19, $

$ a_{29} = 29 \times 31, $

$ a_{41} = 41 \times 43, $

$ a_{47} = 47 \times 49 = 7^2 \times 47, $

$ a_{59} = 59 \times 61, $

$ a_{71} = 71 \times 73, $

$ a_{101} = 101 \times 103, $

$ a_{107} = 107 \times 109, $

$ a_{137} = 137 \times 139, $

这些 $ a_i $（除了 $ a_{47} $）都只能表示为两个质因子之积。

再加上 $ a_1 = 3, a_2 = 8 = 2^3 $

因此如果存在 $ n $ 使得 $ \forall 1 \leqslant i \leqslant n - 1 $ 都有 $ \gcd(a_i, a_n)  \not= 1 $，$ n $ 至少**应同时被 $ 2, 3, 5, 7, 11, 17, 29, 41, 59, 71, 101, 107, 137 $ 这些质因子整除**（每个数中只需取出一个质因子）。

而 $ 2 \times 3 \times 5 \times 7 \times 11 \times 17 \times 29 \times 41 \times 59 \times 71 \times 101 \times 107 \times 137 = 2706419146451790 > 10^{18} $

因此 **当 $ 137 \leqslant n \leqslant 10^{18} $ 时，不存在满足上文条件的 $ n $**。即 $ ans = n - 1 $。（当然打表可以发现 $ 137 $ 的界限应为 $ 11 $）

$ n \leqslant 136 $ 时暴力跑最小生成树即可，这里用的是 `Prim` 算法。

~~（严格的证明留给后人力）~~

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int ll
typedef long long ll;
int a[140];
int g[140][140];
int dis[140];
bool vis[140];
inline int Prim(int n)
{
	int ans = 0;
	memset(dis, 0x7f, sizeof(dis));
	memset(vis, false, sizeof(vis));
	dis[1] = 0;
	for(int i = 1; i <= n; i++)
	{
		int p = -1;
		for(int j = 1; j <= n; j++)
			if(!vis[j] && (p == -1 || dis[j] < dis[p]))
				p = j;
		ans += dis[p];
		vis[p] = true;
		for(int j = 1; j <= n; j++)
			if(!vis[j] && g[p][j] < dis[j])
				dis[j] = g[p][j];
	}
	return ans;
}
int ans[140];
signed main()
{
	for(int i = 1; i <= 136; i++)
	{
		a[i] = i * (i + 2);
		for(int j = 1; j < i; j++)
			g[i][j] = g[j][i] = __gcd(a[i], a[j]);
	}
	for(int i = 1; i <= 136; i++)
		ans[i] = Prim(i);
	int t;
	scanf("%lld", &t);
	while(t--)
	{
		int n;
		scanf("%lld", &n);
		printf("%lld\n", n <= 136 ? ans[n] : n - 1);
	}
	return 0;
}
```

---

## 作者：walk_alone (赞：1)

（写一篇感性认识+不严谨数学证明的题解）

首先题意是——将n个节点连成一棵树，权值（相邻两点的$gcd$）最小。（一开始我还理解错了以为必须是相邻链接）

而相邻链接是我最开始的想法(10个点的情况)：

![](https://cdn.luogu.com.cn/upload/image_hosting/pmfx92ac.png)

显然有一个非常明显的规律：相邻两点之间gcd的值为1 1 3 1 1 3 1 1 3……

这也非常好证明：

记相邻两点权值为$(n+1)^2-1=n*(n+2),n^2-1=(n-1)*(n+1)$,显然$(n+2)$与$n$互质，$(n+1)$与$(n-1)$互质。那么唯一可能改变$gcd$的值的只能是$(n+2)$与$(n-1)$。而除了$3$之外它们不可能再有别的公因子，因为假设它们都能整除$p$($p>=3$且为质数)，显然$(n+2)-(n-1)=3$,不是$p$的因子，因此矛盾。所以只可能被三整除。而（n-1）是3倍数的情况一定是$0$、$0$、$1$（逻辑运算），那么$gcd$一定也是$1$、$1$、$3$。

但是这么做很快就被9的答案是8这个事实给打脸了。

因为它是这么做成的：

![](https://cdn.luogu.com.cn/upload/image_hosting/tdjxt6o9.png)

63并没有和48连，而是让48做了一个叶子节点。24也没有和15连而是与35连，做叶子节点。

这种方法成功的解决了所有边权为3的问题。而这种方法有什么特点？

**找规律！** 那就是：如果是3的倍数连8，如果是8的倍数连3，如果都是那就做叶子节点。

结果来了一个4与10……

![4个点的情况](https://cdn.luogu.com.cn/upload/image_hosting/m6rhb7uc.png)

![10个点的情况](https://cdn.luogu.com.cn/upload/image_hosting/ye3pu75v.png)

4个点时，24与其他三个点至少公因数是3，本可以用权值为1相连的35还尚未出现；10个点时，可以与120以权值为1相连的143也没出现，只好将就用3。

但是10之后呢？尝试了许多组数据发现都可以全部以1相连！

为什么呢？首先（与相邻两个点互质的这里不讨论，直接连接就行）对于与相邻点直接连接权值为3的点来说，3的倍数而非6的倍数的点来说，可以与8连；而对于6的倍数（不是11、13倍数）来说，可以与143连；如果都已经与143都不互质了呢（注意：如果前两个条件已经满足那么不会走到这一步）？那显然这个数已经比143大的多了，其中一定有其他的质数组合（例如：17* 19），使得权值也为1。依次类推，每次找不到8就找143、再找323……

（这里没有严格证明，纯属感性认知）

所以只要不是4与10，都可以找到权值全部为1的情况，答案就是$n-1$，而4与10都将其中一条边权值从1变成了3，所以答案为$n+1$。

---

## 作者：Aw顿顿 (赞：1)

讲起来我有好几个同学就叫 Madeline（

这道题目应该说是一个很巧妙的证明题，十分建议大家来做一做，可以先不要看题解。

## 题意

给定 $n$ 个点，编号为 $i$ 的点权值为 $w_i=(i+1)^2-1$，任意两点 $x$ 和 $y$ 的连边权值为 $\gcd(w_x,w_y)$，对于这样的一个图，求其最小生成树的边权之和。

## 解析

然而你想跑 $\rm\small Kruskal$ 还是 $\rm\small Prim$？秉持着面向数据范围做题的思想，$n\le 10^{18}$ 的极限数据还是让我打消了这个念头。这样的一个数据范围让人想到可能是 $O(\log n)$ 或者 $O(1)$ 的复杂度。那这就显然的数论推导/结论题了。

那我们来写一篇简单的数学推导：

设 $f(x)=(x+1)^2-1$。

首先是整式乘法加因式分解易得：

$$f(x)=x^2+2x+1-1=x^2+2x=x(2+x)$$

为了令边权尽可能小，我们会对 $f(x)$ 和 $f(x-1)$ 求最大公约数，易得：

$$\gcd\left(f(x),f(x-1)\right)=\gcd(x(2+x),(x+1)(x+3))$$

这时候很有意思了，我们来看看 $x(2+x)$ 和 $(x+1)(x+3)$ 的关系。

首先 $x$ 和 $x+1$ 互质，$x+2$ 和 $x+3$ 互质，$x+1$ 与 $x+2$ 互质是非常显然的事实了（相差为 $1$），那么可能存在的非互质情况就源于 $x$ 和 $x+3$，那么他们最大的公因数就是 $3$，于是只能和 $2$ 连接。

接下来对几组 $f(x)$ 做下测试，会发现对于 $x=4,10$ 的情况是特殊的，那么要做特殊处理。即 $x+1$，其余情况均为 $x-1$，也就是和 $1$ 相连。

## 结论

$f(x)=\begin{cases}x+1&x=4\\x+1&x=10\\x-1&\rm Otherwise\end{cases}$



---

## 作者：Beep_Monkey (赞：0)

~~因正常写法太难，所以给出一个数学证明~~。

由题目得：第 $i$ 停留处的魔力是第 $i$ 个停留处的魔力是 $( i + 1 ) ^ 2 - 1$ 。

$∴$ 可以设 $f ( n ) = ( n + 1 ) ^ 2 - 1$。

由平方差公式得 $f ( n ) = n ( n + 2 )$。

$∴$ 当 $n ≡ 1 \pmod{3}$ 时。

1. 若 $n$ 为奇数，将 $f ( n )$ 与 $f ( 2 )$ 连接。

2. 若 $n$ 为偶数，试试发现在 $f ( 4 )$ 与 $f ( 10 )$ 前面没有和它互质的，所以 $f ( 4 )$ 与 $f ( 10 )$ 要特判 ( 它们可以与 $f ( 1 )$ 连，所以一共是 $5$ 或 $10$ )。

3. 另外，若 $n ≡ 0 \pmod{3}$ 或 $n ≡ 2 \pmod{3}$ , 则将 $f ( n )$ 与 $f ( n - 1 )$ 连接就好了。


### 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t;//注意，用long long
int main(){
	scanf("%lld",&t);
	for(int i=1;i<=t;i++){
		scanf("%lld",&n);
		if(n==4) printf("5\n");//特判
		else if(n==10) printf("11\n");//特判
		else printf("%lld\n",n-1);
	}
	return 0;
}
```

---

## 作者：生而为人 (赞：0)

# 关于 此题 题解
###### 首先看 数据 范围，显然 打表找规律，我用二十分钟手推 到 20 发现只有n等于4 或 10 时答案为 n+1 ； 最后 敲了个 克鲁斯卡尔 跑了个 1e10的数据 发现只有 4 和 10 是不同的 所以 特判交了  附上 打表代码：
```c
#include<cstdio>
#include<iostream> 
#include<algorithm>
#define N 5010 
#define M 200010
using namespace std;
//定义结构体存边，x为起点，y为终点，z为值
struct edge{
    int x,y,z;
}a[M];
int fat[N],tot,ans;
bool cmp(edge x,edge y){//用于sort的排序，按值排
    return x.z<y.z;
} 
int ask(int x){//查找是否在同一集合
        if (fat[x]!=x) fat[x]=ask(fat[x]);
    return fat[x];
}
void unite (int x,int y){
    int x1=ask(x),x2=ask(y);
    if (x1==x2) return;
    else fat[x1]=x2;
}
int cnt;
int main(){
    int n,m,k;
    cin>>n;
    while(n<1000000)
    {
    	n++;
    tot=0;
    ans=0;
    cnt=0;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
    	a[++cnt].x=i;
    	a[cnt].y=j;
    	a[cnt].z=__gcd((i+1)*(i+1)-1,(j+1)*(j+1)-1);
    }
    sort(a+1,a+cnt+1,cmp);//把边按从大到小排
    for (int i=1;i<=n;i++) fat[i]=i;//初始化并查集
    for (int i=1;i<=cnt;i++)
	{
        if (ask(a[i].x)!=ask(a[i].y)){//克鲁斯卡尔
            tot++;
            ans=ans+a[i].z;
            unite(a[i].x,a[i].y);
        }
    }
    if (tot<n-1) printf("orz");//判断若tot=k-1则生成了最小树
    else
    {
    	if(n-1!=ans)
    	cout<<n<<endl;
    }
	}
	return 0;
}
```
###### 再附上 AC 代码
```c
#include<iostream>
#include<cstdio>
using namespace std;
long long k;
int main()
{
	cin>>k;
	while(k--)
	{
		long long n;
		cin>>n;
		if(n==4)
		cout<<"5"<<endl;
		else
		if(n==10)
		cout<<"11"<<endl;
		else
		cout<<(n-1)<<endl;
	}
}
```


---


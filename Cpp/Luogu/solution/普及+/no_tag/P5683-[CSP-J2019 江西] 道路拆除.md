# [CSP-J2019 江西] 道路拆除

## 题目描述

A 国有 $n$ 座城市，从 $1 \sim n$ 编号。$1$ 号城市是 A 国的首都。城市间由 $m$ 条双向道路连通，通过每一条道路所花费的时间均为 $1$ 单位时间。  

现在 A 国打算拆除一些不实用的道路以减小维护的开支，但 A 国也需要保证主要线路不受影响。因此 A 国希望道路拆除完毕后，利用剩余未被拆除的道路，从 A 国首都出发，能到达 $s_1$ 号与 $s_2$ 号城市，且所要花费的最短时间分别不超过 $t_1$ 与 $t_2$（注意这是两个独立的条件，互相之间没有关联，即不需要先到 $s_1$ 再到 $s_2$）。

A 国想请你帮他们算算，在满足上述条件的情况下，他们最多能拆除多少条道路。 若上述条件永远无法满足，则输出 $-1$。

## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$n,m \le 15$；   
另有 $20\%$ 的数据，$n \le 100$，$m = n-1$；   
另有 $30\%$ 的数据，$s_1 = s_2$；  
对于 $100\%$ 的数据，$2 \le n,m \le 3000$，$1\le x,y \le n$，$2 \le s_1,s_2 \le n$，$0 \le t_1,t_2 \le n$。  

【样例 $1$ 解释】  
拆除 $(1,2),(2,3),(3,4)$ 三条边。  
注意：不需要令首都与除了 $s_1,s_2$ 外的点在拆除之后依然连通。

【样例 $2$ 解释】  
即使一条边都不拆除，首都到 $3$ 号点的最短时间也都达到了 $2$ 单位时间。

testdata by @DYH060310 

## 样例 #1

### 输入

```
5 6
1 2
2 3
1 3
3 4
4 5
3 5
5 3 4 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2
1 2
2 3
2 2 3 1```

### 输出

```
-1```

# 题解

## 作者：旭日临窗 (赞：34)

#### 思路：

**正难则反**，求最多能拆除多少条道路不是太好求，所以我们可以求出**最少用多少条道路**能满足题目条件，最后再用$m$减去不就可以了吗，一说到最少留多少条路，考虑**最短路**。

那我们能直接把$A$到$s1$的最短路和$A$到$s2$的最短路加起来吗？

**显然是不可以的**，以为拆到最后有**两种**可能，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/d6vjx1ll.png)

但是我们发现，**第二种属于第一种可能**，可以看做是$x$点与$A$点重了而已。

所以我们可以**遍历所有点$x$**，定义$x\to y$表示$x$到$y$的最短路，找出

**$\sum\limits_{x=1}^{n}\min(A\to x + x\to s1 + x\to s2)$即可**，但这样复杂度就太高了，**观察发现**$A$，$s1$，$s2$，是不变的，因为是双向边，**所以**$x\to s1==s1\to x$，$s2$也一样。

$code$：

```c
#include <bits/stdc++.h>
using namespace std; 
const int inf = 0x7f7f7f7f;
int n,m,cnt,s1,t1,s2,t2,ans = inf;
int dis1[3010],dis2[3010],dis3[3010];
vector <int> G[3010];//邻接表存边。 
queue <int> q;
inline int read()//快读。 
{
	cnt = 0;
	char c;
	while((c = getchar()) < '0' || c > '9');
	while(c >= '0' && c <= '9') cnt = cnt * 10 + (c - '0'),c = getchar();
	return cnt;
}
void bfs(int s,int *dis)//最短路模板，不多说了。 
{
	q.push(s);
	dis[s] = 0;
	while(!q.empty())
	{
		int u = q.front();q.pop();
		for(int i = 0;i < G[u].size();i++)
		{
			int v = G[u][i];
			if(dis[u] + 1 < dis[v])
			{
				dis[v] = dis[u] + 1;
				q.push(v);
			}
		}
	}
}
int main()
{
	n = read(),m = read();
	int x,y;
	for(int i = 1;i <= m;i++)
	{
		x = read(),y = read();
		G[x].push_back(y);//注意是双向边。 
		G[y].push_back(x);
	}
	s1 = read(),t1 = read(),s2 = read(),t2 = read();
	memset(dis1,inf,sizeof(dis1));
	memset(dis2,inf,sizeof(dis2));
	memset(dis3,inf,sizeof(dis3));
	bfs(1,dis1);//预处理三次最短路。 
	if(dis1[s1] > t1 || dis1[s2] > t2)//如果不拆路都没法满足条件，那拆路就更没法满足了，直接输出-1。 
	{
		puts("-1");
		return 0;
	}
	bfs(s1,dis2);
	bfs(s2,dis3);
	for(int i = 1;i <= n;i++)//遍历所有点x。 
	if(dis1[i] + dis2[i] <= t1 && dis1[i] + dis3[i] <= t2)//如果满足条件就更新ans。 
	ans = min(ans,dis1[i] + dis2[i] + dis3[i]);
	printf("%d",m - ans);//正难则反，输出总道路数减去最少保留数即可。 
	return 0;
}
```
~~/管理员大大求过$thanks$/~~

---

## 作者：lzqy_ (赞：14)

发现大家都是将路径拆成三条链来做，这里提供一种暴力的~~乱搞~~方法。

## 思路

看到这一道题的第一想法就是跑最短路。可是仔细想想就发现，由于重合的路径只算一遍，所以导致两条最短路不一定是最优解。

接着，看到数据范围中的 $m\leq 3000$ 告诉我们这个无向图是稀疏图。也就是说，从 $1$ 到 $s1,s2$ 的简单路径（重复走过点或边没有意义）总数不会很多。因此，我们就可以穷举 $(1,s1),(1,s2)$ 的所有简单路径，求最小经过的边即可。

只要加上以下的基础剪枝即可：

- 如果经过的边数已经超过目前最小值，返回。

- 如果路径长度已经超过 $t1$ or $t2$，返回。

## 代码

有详细注释。

```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int maxn=3010;
const int inf=10000000;
inline int read()
{
	register int x=0;
	register char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
int n,m;
int ans=inf;
int s1,s2,t1,t2;
vector<int>v[maxn],w[maxn];
bool k[maxn],Vis[maxn];
queue<int>q;
void DFS(int x,int len,int Len)
{
	if(x==s2)
	{
		ans=min(ans,len);//刷新最小值
		return ;
	}
	if(Len==t2||len>=ans) return ;
    //超过路程限制或者已经比当前答案劣
	for(register int i=0;i<v[x].size();i++)
		if(!Vis[w[x][i]])
		{
			Vis[w[x][i]]=1;
			DFS(v[x][i],len+!k[w[x][i]],Len+1);
			Vis[w[x][i]]=0;
		}
}
void dfs(int x,int len)
{
	if(x==s1)
	{
		DFS(1,len,0);
     //对于当前路径穷举 (1,s2) 的所有简单路径
		return ;
	}
	if(len==t1) return ;//如果超过路程限制
	for(register int i=0;i<v[x].size();i++)
		if(!k[w[x][i]])
				k[w[x][i]]=1,dfs(v[x][i],len+1),k[w[x][i]]=0;
}
int main()
{
	n=read(),m=read();
	register int x,y;
	for(register int i=1;i<=m;i++)
		x=read(),y=read(),v[x].pb(y),v[y].pb(x),w[x].pb(i),w[y].pb(i);
   //w数组存储的是边的编号
	s1=read(),t1=read(),s2=read(),t2=read();
	dfs(1,0);//穷举 (1,s1) 的所有简单路径
	if(ans==inf)
   //如果没有路径可以满足t1和t2的限制
		cout<<-1<<endl;
	else
		cout<<m-ans<<endl;
	return 0;
} 
```


---

## 作者：vеctorwyx (赞：8)

## Dijkstra*3=AC本题！

看题干，由起点到两个终点，很容易想到最短路。

接着往下看，直接最短路并不可行，因为要记录经过的边数（直接跑最短路会产生重边）

那么问题转变为了**怎么求最短路并不出现重边**。

~~这里其实自己画一下图就会了~~

扔一张样例1的图：

![样例1](https://cdn.luogu.com.cn/upload/image_hosting/o4ail7an.png)

（黄点是中间点，红黄蓝边是三条最短路）

然后就~~很轻易地~~知道是最短路*3了。

PS：~~SPFA他这回没死~~

代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct node
{
	int to,nxt;
}e[100010];
int h[100010],cnt,ans=0x7f7f7f;
int add(int x,int y)
{
	e[++cnt].to=y;
	e[cnt].nxt=h[x];
	h[x]=cnt;
}
int n,m,s1,t1,s2,t2;
int dis1[100010],dis2[100010],dis3[100010];
void dijkstra(int *d,int a)//堆优化Dijkstra
{
	d[a]=0;
	priority_queue<pair<int,int> >q;
	q.push(make_pair(0,a));
	while(!q.empty())
	{
		int y=q.top().first,x=q.top().second;
		q.pop();
		for(int i=h[x];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(d[v]>d[x]+1)
			{
				d[v]=d[x]+1;
				q.push(make_pair(-d[v],v));
			}
		}
	}
}
int main()
{
	memset(dis1,0x7f7f7f,sizeof(dis1));
	memset(dis2,0x7f7f7f,sizeof(dis2));
	memset(dis3,0x7f7f7f,sizeof(dis3));
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	cin>>s1>>t1>>s2>>t2;
	dijkstra(dis1,1);
	dijkstra(dis2,s1);
	dijkstra(dis3,s2);
	for(int i=1;i<=n;i++)
	{
		if(dis1[i]+dis2[i]<=t1&&dis1[i]+dis3[i]<=t2)//注意时间（t1，t2）要求
		{
			ans=min(ans,dis1[i]+dis2[i]+dis3[i]);
		}
	}
	if(ans==0x7f7f7f)//别忘了输出-1
	cout<<-1;
	else
	cout<<m-ans;
}
```
话说这题怎么这么像9月月赛T2呢？

---

## 作者：WsW_ (赞：4)

### 思路
显然是考察最短路，但是 floyd 多源最短路显然会超时，考虑使用 bfs 单源最短路。  
我们发现，无论怎样做，都必须求出关于 $1,s_{1},s_{2}$ 三个点到别的点之间的路径，所以考虑对这三个点分别进行一次 bfs，分别求出三个点到别的点之间的时间。  
容易发现，$1\to s_{1}$ 和 $1\to s_{2}$ 这两条路径必定是开始经过的一些城市重合，之后分开。这两条路径至少在起点都经过 $1$ 号城市，至少在终点会分开。  
强制要求 $1\to s_{1}$ 和 $1\to s_{2}$ 这两条路径必须经过同一个城市 $x$，并求出 $t_1=dis(1,x)+dis(x,s_{1}),t_2=dis(1,x)+dis(x,s_{2})$ 和可以拆除的道路数量。枚举 $x\in[1,n]$ 即可，这样覆盖了所有可能。

如何快速求出可以拆除的道路数量？由题可知，$1$ 单位时间对应 $1$ 条路，所以对于一个确定的点 $x$，我们可以通过它到三个源点的时间，来求出需要经过的道路。总路径减去需要经过的道路就是可以拆除的道路。  
这样有时候会少算，因为 $1\to s_{1}$ 和 $1\to s_{2}$ 两条路径可能在 $x$ 号城市之后还有重合。但这样不影响，假设实际重合的路径是 $1\to x_{1} \to y$，那么我们在枚举到 $x_{2}=y$ 时一定会求出一个更优秀的答案，这个答案会覆盖掉枚举 $x_{1}$ 时的答案。   
在已经预处理出三个点到别的点之间的时间后，这个部分可以 $O(1)$ 求出。  

总时间复杂度为 $O(n+m)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int to;
    int next;
}edg[6003];
int elen;
int head[3003];
int dis[3][3003];
bool vis[3][3003];

int keep=2e9;
int n,m;
int s[3],t[3];

queue<int> q;

void add(int fr,int to){
    ++elen;
    edg[elen].to=to;
    edg[elen].next=head[fr];
    head[fr]=elen;
}

void bfs(int tt,int s){
    dis[tt][s]=0;
    q.push(s);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        for(int i=head[x];i;i=edg[i].next){
            if(dis[tt][x]+1<dis[tt][edg[i].to]){
                dis[tt][edg[i].to]=dis[tt][x]+1;
                q.push(edg[i].to);
            }
        }
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        dis[0][i]=dis[1][i]=dis[2][i]=1e9;
    }
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    scanf("%d%d%d%d",&s[1],&t[1],&s[2],&t[2]); 
    bfs(0,1);
    bfs(1,s[1]);
    bfs(2,s[2]);
    if(dis[0][s[1]]>t[1]||dis[0][s[2]]>t[2])return !printf("-1");
    for(int i=1;i<=n;i++){
        if(dis[0][i]+dis[1][i]>t[1])continue;
        if(dis[0][i]+dis[2][i]>t[2])continue;
        keep=min(keep,dis[0][i]+dis[1][i]+dis[2][i]);
    }
    printf("%d",m-keep);
    return 0;
}
```

---
### 后记
单源最短路不仅可以处理以某点为起点的最短路问题，还可以处理以某点为终点的最短路问题。  
通过有限个点进行单源最短路来简化问题是一个常见套路，另外推荐几道题：[P6833 [Cnoi2020] 雷雨](https://www.luogu.com.cn/problem/P6833)、[P1629 邮递员送信](https://www.luogu.com.cn/problem/P1629)。

---

## 作者：小陈同学cyh (赞：3)

~~似乎dis本来就不用上下标吧~~
# 题意：

给定一个 $n$ 个点 $m$ 条边的无向图，问**最多能删去**多少边，能依旧使得 $1$ 到 $s1$ 的距离不大于 $t1$ 并且 $1$ 到 $s2$ 的距离不大于 $t2$。

如果不能，输出 $-1$。

## 样例
![](https://cdn.luogu.com.cn/upload/image_hosting/54167r1i.png)

# 思考

最后剩下的边一定构成一棵树，因为所有的环显然都是可以删掉至少一条边的，让我们来思考一下这棵树是什么形状吧。

结果：最后一定是三条链 $1 \rightarrow x,x \rightarrow s1,x \rightarrow s2$ 答案就是 $m-dis_{1,x}-dis_{x,s1}-dis_{x,s2}$ 了。

调整法证明：若存在 $y$ 使得 $dis_{1,y}+dis_{y,s1}+dis_{y,s2}$ 变小就用 $y$ 代替 $x$ 就好了。

注意枚举 $x$ 时要做好初始化，用 bfs 可以轻松做到 $O(n+m)$ 的单源最短路，一共枚举 $n$ 次，且 $n,m$ 同阶，时间复杂度显然是 $O(n^2)$ 的。

# 核心代码

~~马蜂奇特~~

代码将 $dis$ 压成了一维~~虽然这毫无作用~~
```cpp
void addedge()
{
	int x=in(),y=in();
	cnt++;
	edge[cnt].to=y;
	edge[cnt].nextt=head[x];
	head[x]=cnt;
	cnt++;
	edge[cnt].to=x;
	edge[cnt].nextt=head[y];
	head[y]=cnt;
}
void bfs(int pos)
{
	for (int i=1;i<=n;i++) vis[i]=false,f[i]=1e9;
	f[pos]=0;p=1;q[p]=pos;last=1;vis[pos]=true;
	while (p<=last)
	{
		for (int i=head[q[p]];i;i=edge[i].nextt)
		{
			if (!vis[edge[i].to])
			{
				f[edge[i].to]=f[q[p]]+1;
				vis[edge[i].to]=true;
				last++;
				q[last]=edge[i].to;
			}
		}
		p++;
	}
}
signed main()
{
	n=in();m=in();
	for (int i=2;i<=n;i++) f[i]=-1;
	for (int i=1;i<=m;i++) addedge();
	s1=in();t1=in();s2=in();t2=in();
	bfs(1);
	for (int i=1;i<=n;i++) f1[i]=f[i];
	if (f[s1]>t1||f[s2]>t2)
	{
		cout<<-1;
		return 0;
	}
	for (int i=1;i<=n;i++)
	{
		bfs(i);
		if (f1[i]+f[s1]<=t1&&f1[i]+f[s2]<=t2) ans=min(ans,f1[i]+f[s1]+f[s2]);
	}
	cout<<m-ans;
	return 0;
}
```

---

## 作者：Vct14 (赞：2)

很容易想到只需要求得最少要保留多少条道路。

显然，无论怎么走，路径都可以被分为三个部分：

1. 从 $1$ 号点走到 $i$ 号点。
2. 从 $i$ 号点走到 $s_1$ 号点。
3. 从 $i$ 号点走到 $s_2$ 号点。

由于 $m\le 3000$ 很小，我们可以设边权为 $1$ 然后分别跑 $1,s_1,s_2$ 号点到其他各个点的最短路。遍历所有 $i$ 求出按上述方案走最少要留下的道路数量 $mn$，最后答案为 $m-mn$。无解当且仅当 $1$ 到 $s_1$ 的最短路大于 $t_1$ 或 $1$ 到 $s_2$ 的最短路大于 $t_2$，即在不删除任何一条边的情况下都无法满足要求。

可能有同学要问了：如果最优的方案中，上面路径的三个部分间有重复的边怎么办？其实并不会出现这种情况。可以用反证法证明。比如假设我们求得将 $i$ 作为“途径点”时最优，而前两个部分都会经过 $(i,j)$ 这条双向道路（即 $1$ 号点到 $i$ 号点最短路为 $1\to j\to i$，$i$ 号点到 $s_1$ 号点最短路为 $i\to j\to s_1$），那么将“途径点”设在 $j$ 一定优于将其设在 $i$，与 $i$ 最优矛盾。大家可以借助下图仔细理解一下。（图中红色代表将 $i$ 设为途径点，绿色代表将 $j$ 设为途径点。）

![](https://cdn.luogu.com.cn/upload/image_hosting/r98yde4o.png)

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=3002;
int dis[N][3];
bool vis[N];

struct node{
	int now,w;
	node(int now,int w){
		this->now=now;
		this->w=w;
	}
	friend bool operator<(node a,node b){
		return a.w>b.w;
	}
}; 

vector<node> edge[N];
int n,m;

void dij(int s,int k){
	priority_queue<node> q;
	memset(vis,0,sizeof vis);
	q.push(node(s,0));dis[s][k]=0;
	while(!q.empty()){//while(q.size())
		node t=q.top();
		q.pop();
		int now=t.now;
		if(vis[now]) continue;
		vis[now]=true;
		for(int i=0; i<edge[now].size(); i++){
			int v=edge[now][i].now;
			int w=edge[now][i].w;
			if(dis[v][k]>dis[now][k]+w){
				dis[v][k]=dis[now][k]+w;
				q.push(node(v,dis[v][k]));
			}
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1; i<=m; i++){
		int u,v;
		cin>>u>>v;
		edge[u].push_back(node(v,1));
		edge[v].push_back(node(u,1));
	}
	int s1,s2,t1,t2;cin>>s1>>t1>>s2>>t2;
	//memset(dis,0x7fffffff,sizeof(dis));
	for(int i=0; i<N; i++) for(int j=0; j<3; j++) dis[i][j]=0x7f7f7f7f;
	dij(1,0);dij(s1,1);dij(s2,2);
	if(dis[s1][0]>t1 || dis[s1][1]>t2){
		cout<<"-1";
		return 0;
	} 
	int mn=0x7f7f7f7f;
	for(int i=0; i<n; i++) if(dis[i][0]+dis[i][1]<=t1 && dis[i][0]+dis[i][2]<=t2) mn=min(mn,dis[i][0]+dis[i][1]+dis[i][2]);
	cout<<m-mn;
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

正难则反，将问题转化成求满足题意的最小边数，由此想到最短路。

那么答案就包含了起点 $A$ 到 $s_1$ 和 $s_2$ 的最短路，不过两条最短路可能重合，如图所示，$A$ 到 $B$ 的路径即重合部分（也有特殊情况，$A$ 和 $B$ 重合）。

枚举 $B$，所需最小边数就是 $A$ 到 $B$、$s_1$ 到 $B$、$s_2$ 到 $B$ 三条最短路和的最小值。

对于判无解，若一条边不删都无法满足题意则无解。

![](https://cdn.luogu.com.cn/upload/image_hosting/ai15jt8j.png)

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, s1, t1, s2, t2, d[3][3005], ans=1e9;
bool vis[3005];
vector<int> e[3005];
struct node {
	int dis, u;
	bool operator<(const node& a) const { return dis<a.dis; }
};
priority_queue<node> q;
void dij (int dis[], int s) {
	memset(vis, 0, sizeof vis);
	dis[s]=0;
	q.push({0, s});
	while (q.size()) {
		int u=q.top().u;
		q.pop();
		if (vis[u])
			continue;
		vis[u]=1;
		for (int i:e[u])
			if (dis[i]>dis[u]+1)
				dis[i]=dis[u]+1,
				q.push({dis[i], i});
	}
}
int main () {
	cin >> n >> m;
	for (int i=1, x, y; i<=m; ++i)
		cin >> x >> y,
		e[x].push_back(y),
		e[y].push_back(x);
	cin >> s1 >> t1 >> s2 >> t2;
	memset(d[0], 0x3f, sizeof d[0]);
	dij(d[0], 1);
	if (d[0][s1]>t1||d[0][s2]>t2) {
		puts("-1");
		return 0;
	}
	memset(d[1], 0x3f, sizeof d[1]);
	dij(d[1], s1);
	memset(d[2], 0x3f, sizeof d[2]);
	dij(d[2], s2);
	for (int i=1; i<=n; ++i)
		if (d[0][i]+d[1][i]<=t1&&d[0][i]+d[2][i]<=t2)
			ans=min(ans, d[0][i]+d[1][i]+d[2][i]);
	cout << m-ans;
	return 0;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

考虑求出最少保留的边数。

首先若 $1 \to s_1$ 的最短路径边数 $>t_1$ 或者 $1 \to s_2$ 的最短路径边数 $>t_2$ 是无解的。

设 $dis_{i, j}$ 表示 $i \to j$ 的最短路径的边数。

则答案是：

$$\sum_{i = 1}^n \min(dis_{1, i} + dis_{i, s_1} + dis_{i, s_2})$$

简单证明一下：

- 即对于每个 $i$，保留 $1 \to i, i \to s_1, i \to s_2$ 最短路上的边。

- 但是 $i \to s_1, i \to s_2$ 可能有交集（即实际边数其实小于 $dis_{i, s_1} + dis_{i, s_2}$），设在 $p$ 处相交，但是 $p$ 点的答案 $dis_{1, p} + dis_{p, s_1} + dis_{p, s_2}$ 一定比 $i$ 更小。

故对于 $1, s_1, s_2$ 这三个点跑 bfs 求单源最短路即可。

时间复杂度为 $O(N + M)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=3030,INF=1e15;
ll read(){
	ll x;
	scanf("%lld",&x);
	return x;
}
void write(ll x){
	printf("%lld",x);
}
ll n,m,s1,s2,t1,t2,ans=INF;
ll dis[3][N];
vector<ll> E[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void BFS(ll x,ll s){
	queue<ll> q;
	for(int i=1;i<=n;i++)
	  dis[x][i]=INF;
	dis[x][s]=0;
	q.push(s);
	while(!q.empty()){
		ll u=q.front();
		q.pop();
		for(auto v:E[u]){
			if(dis[x][u]+1<dis[x][v]){
				dis[x][v]=dis[x][u]+1;
				q.push(v);
			}
		}
	}
}
int main(){
	n=read(),m=read();
	for(int i=0,u,v;i<m;i++){
		u=read(),v=read();
		add(u,v);
	}
	s1=read(),t1=read(),s2=read(),t2=read();
	BFS(0,1);
	BFS(1,s1);
	BFS(2,s2);
	if(dis[0][s1]>t1||dis[0][s2]>t2){
		puts("-1");
		exit(0);
	}
	for(int i=1;i<=n;i++){
		ll x1=dis[0][i]+dis[1][i],x2=dis[0][i]+dis[2][i];
		if(x1>t1||x2>t2)
		  continue;
		ans=min(dis[0][i]+dis[1][i]+dis[2][i],ans);
	} 
	write(m-ans);
	return 0;
}
```

这是几年前写的 code 了，码风可能有点不好看，见谅。

---

## 作者：Wei_ch (赞：2)

这道题的目标是最大限度地拆除道路并满足以下条件，从首都 $ 1 $ 到城市 $ s_1 $ 的最短路径时间不超过 $ t1 $ 和从首都 $ 1 $ 到城市 $ s_2 $ 的最短路径时间不超过 $ t2 $。
### 思路
我们可以使用最短路径算法计算路径长度求出首都 $ 1 $ 到所有城市的最短路径长度。这里可以使用比较简单的 BFS 算法，从 $ 1 $，$ s_1 $ 和 $ s_2 $ 出发，计算到所有点的最短路径，判断是否满足约束条件。

我们再遍历所有中间节点，尝试用这个节点连接 $ 1 $ 到 $ s_1 $ 和 $ 1 $ 到 $ s_2 $ 的路径，并验证是否满足条件 $ dis_{1,mid} + dis_{s_{1},mid} \leq t_1 $ 和 $ dis_{1,mid} + dis_{s_2,mid} \leq t_2 $。如果满足条件，就计算路径的总长度并更新最优解。

最后，如果无法满足条件，输出 $ -1 $，否则，输出可以拆除的最大边数。

### 代码

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>
using namespace std;

const int N = 3000 + 7;

vector<int> adj[N]; // 邻接表
int dis[N];         // 单源最短路径
int n, m, x, y, s1, t1, s2, t2;

// BFS
void bfs(int start, vector<int>& distance) {
    fill(distance.begin(), distance.end(), INT_MAX); // 初始化距离为无穷大
    queue<int> q;
    distance[start] = 0;
    q.push(start);
    
    while (!q.empty()) {
        int cur = q.front(); q.pop();
        for (int neighbor : adj[cur]) {
            if (distance[neighbor] > distance[cur] + 1) {
                distance[neighbor] = distance[cur] + 1;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    cin >> n >> m;

    // 输入图
    for (int i = 0; i < m; i++) {
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }

    cin >> s1 >> t1 >> s2 >> t2;

    // 计算最短路径
    vector<int> dist_from_1(n + 1), dist_from_s1(n + 1), dist_from_s2(n + 1);
    bfs(1, dist_from_1);
    bfs(s1, dist_from_s1);
    bfs(s2, dist_from_s2);

    // 检查是否满足约束
    if (dist_from_1[s1] > t1 || dist_from_1[s2] > t2) {
        cout << -1 << endl;
        return 0;
    }

    int result = INT_MAX;

    // 枚举所有路径
    for (int mid = 1; mid <= n; mid++) {
        if (dist_from_1[mid] + dist_from_s1[mid] <= t1 && 
            dist_from_1[mid] + dist_from_s2[mid] <= t2) {
            result = min(result, dist_from_1[mid] + dist_from_s1[mid] + dist_from_s2[mid]);
        }
    }

    // 输出结果
    cout << (result == INT_MAX ? -1 : m - result) << endl;

    return 0;
}
```
[记录](https://www.luogu.com.cn/record/195838609)

---

## 作者：xxseven (赞：1)

先用 bfs 求出从 $1,s_1,s_2$ 出发的单源最短路。

删除最多的边等价于保留最少的边，因此转化为保留最少的边，使得有从 $1$ 到 $s_1$ 和 $s_2$ 的限长路径各一条。

按套路，枚举两条路径经过的最后一个公共点 $u$，那么两条路径可以被拆解为 $1 \rightarrow u,u \rightarrow s_1,u\rightarrow s_2$ 三条不相交路径。

如果这种情况下的路径符合长度限制，就可以用三条不相交路径长度之和更新答案。

正确性证明：

由于两条路径必然存在公共点 $1$，这种枚举方法生成的所有路径都是合法路径。  
因为题目所有限制都要求最短路尽可能小，取最短路更新答案显然最优。 

时间复杂度 $O(n+m)$。

[提交记录](https://www.luogu.com.cn/record/195895183)。

希望这篇题解能够帮到你！

---

## 作者：_H17_ (赞：1)

## 题目分析

首先想到最短路，考虑怎么做。

只需要满足在 $t_1,t_2$ 的时间内分别到 $s_1,s_2$ 而且要保留的路最少，肯定要有重复（即 $1\to x,x\to s_1,x\to s_2$，这些箭头表示路径不是边）。

显然中间不会有多个岔道，不然两个中更长的路径可以用更短的替代。如果两条路径没有关联那 $x=1$。

所以考虑求 $1,s_1,s_2$ 的单源最短路，然后枚举 $x$，如果当前 $x$ 满足 $t_1,t_2$ 的限制就更新答案。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int N=3e3+1;
int n,m,s1,t1,s2,t2,ans=-1;
vector<int>e[N],dis1,diss1,diss2;
void add(int u,int v){
    e[u].push_back(v);
    return;
}
vector<int>dijkstra(int s){
    vector<int>dis(n+1,0x3f3f3f3f);
    priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
    q.push({0,s});
    dis[s]=0;
    while(!q.empty()){
        auto[d,u]=q.top();
//		int d=q.top().first,u=q.top().second;
        q.pop();
        if(dis[u]!=d)
            continue;
        for(auto v:e[u])
            if(dis[u]+1<dis[v])
                q.push({dis[v]=dis[u]+1,v});
    }
    return dis;
}
int main(){
    cin>>n>>m;
    for(int i=1,u,v;i<=m;i++){
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    cin>>s1>>t1>>s2>>t2;
    dis1=dijkstra(1),diss1=dijkstra(s1),diss2=dijkstra(s2);
    for(int i=1;i<=n;i++)
        if(dis1[i]+diss1[i]<=t1&&dis1[i]+diss2[i]<=t2)
            ans=max(ans,m-(dis1[i]+diss1[i]+diss2[i]));
    cout<<ans;
    return 0;
}
```

---

## 作者：Lates (赞：0)

不好意思刚刚不小心交错到别的题了（

刷CSPJX，来水题解。

---

题意就是删尽量多的边使得剩下的满足条件。

**正难则反，原问题等价于留下最少的边使得剩下的满足条件。**

可以发现最终留下的是两条路径 $1$ 到 $s1$ 和 $1$ 到 $s2$。

分类讨论：

- 两条路径有公共部分

这下就变成留下三条链，使得剩下的满足条件。

这三条链的公共点就是问题的关键。

考虑求出 $1,s1,s2$ 到图上所有点的最短路径，由于边权为 $1$，所以最短路径就是路径上边的数量。

所以这个公共点就要满足 $1,s1,s2$ 到他的距离最小，且满足题目给出的两个条件。

然后考虑枚举公共点，找出最小的那个，就是满足条件的情况下保留边的最小数目。

题目要求删最多的边，于是用总边数 $m$ $-$ 最小数目即可。

![360截图16220421625977.png](https://i.loli.net/2020/05/25/pOTwo2qrPZA1K7e.png)

~~看图印象更深刻~~

- 两条路径无公共部分

这个其实就是公共部分为空时的情况，也就是公共点为 $1$ 的情况。

![360截图16380516709696.png](https://i.loli.net/2020/05/25/5xeTK9r3LAktgud.png)

---

代码实现的时候，不用分类讨论，可以直接在 $1$ 到 $n$ 内 枚举公共点。

求最短路可以直接 $bfs$。

$Code$

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
queue<int>q;
const int MAX=3005;
int pos,a,b,n,m;
struct E{
	int e,next;
}e[MAX<<1];
int cnt=1,head[MAX];
inline void add(int u,int v){
	e[cnt]=(E){v,head[u]};head[u]=cnt++;
} 
int dis[MAX][3];
inline void bfs(int S){
	while(!q.empty())q.pop();
	q.push(S);
	dis[S][pos]=0;
	while(!q.empty()){
		a=q.front();q.pop();
		for(register int i=head[a];i;i=e[i].next){
			if(dis[e[i].e][pos]>dis[a][pos]+1){
				dis[e[i].e][pos]=dis[a][pos]+1;
				q.push(e[i].e);
			}
		}	
	}
	++pos;
}
int s,t,s0,t0,ans=0x3f3f3f3f;
signed main(){
	memset(dis,0x3f,sizeof(dis));
	n=read(),m=read();
	for(register int i=1;i<=m;++i){
		a=read(),b=read();
		add(a,b);add(b,a);
	}
	s=read(),t=read(),s0=read(),t0=read();
	bfs(1);bfs(s);bfs(s0);
//	for(register int i=1;i<=n;++i){
//		printf("%d %d %d\n",dis[i][0],dis[i][1],dis[i][2]);
//	}
	for(register int i=1;i<=n;++i){
		if(dis[i][0]+dis[i][1]<=t&&dis[i][0]+dis[i][2]<=t0){
			ans=ans<(dis[i][0]+dis[i][1]+dis[i][2])?ans:(dis[i][0]+dis[i][1]+dis[i][2]);
		}
	}
	if(ans==0x3f3f3f3f)printf("-1\n");
	else printf("%d\n",m-ans);
	return 0;
}


```



---


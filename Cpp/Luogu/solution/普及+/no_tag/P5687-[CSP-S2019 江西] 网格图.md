# [CSP-S2019 江西] 网格图

## 题目背景

JXCSP-S T3

## 题目描述

给定一个 $n\times m$ 的网格图，行从 $1\sim n$ 编号，列从 $1\sim m$ 编号，每个点可用它所在的行编号 $r$ 与所在的列编号 $c$ 表示为 $(r, c)$。

点 $(i,j)$ 与 $(i,j+1)$ 间连有一条权值为 $a_i$ 的边，其中 $1\le i\le n, 1\le j<m$。

点 $(i, j)$ 与 $(i+1,j)$ 间连有一条权值为 $b_j$ 的边，其中 $1\le i< n, 1\le j \le m$。

请你求出这个网格图的最小生成树。

## 说明/提示

#### 【输入输出样例 1 说明】
最小生成树中的边包括：第一行上的所有边，第一列、第二列、第三列上的所有边。

#### 【数据规模与约定】

对于 $20\%$ 的数据，$n, m\le 3$，$a_i, b_j \le 10$；

对于 $40\%$ 的数据，$n, m\le 20$，$a_i, b_j\le 100$；

对于 $64\%$ 的数据，$n, m\le 300$，$a_i, b_j\le 1000$；

对于 $100\%$ 的数据：$3\le n, m \le 3\times 10^5$，$1 \le a_i, b_j\le 10^5$。 

## 样例 #1

### 输入

```
3 3
2 4 3
1 3 2```

### 输出

```
16```

# 题解

## 作者：周子衡 (赞：29)

```
求求管理造造数据吧……
```

仿照$\text{Kruskal}$的思想，先对所有的边权从小到大排序。虽然总边数达到了$O(nm)$的级别，但不同的边权却至多$n+m$个，此步的时间复杂度为$O((n+m)\text{log}(n+m))$。

首先取出最小的边权。不失一般性，下面的讨论基于这个边权**出现在行中**进行。显然这些边都要连上。

接下来一直向下取，直到取到**不是行中的边权**为止。此时不可能有环，必须要全取。

对于第一个**列中的边权**，显然此时也不可能有环，必须要全取。

对于接下来的每一种边权，我们维护两个集合$S_r,S_c$，分别表示已经考虑过的行和列。

对于接下来的每一种**行中的边权**，可以发现，这一行的$m$个点中，所有出现在$S_c$中的点已和外界联通，而不在$S_c$中的点一定没有连出任何一条边。故行中的边要连的条数为$m-|S_c|$条。

同理，对于每种**列中的边权**，这种边的条数为$n-|S_r|$条。

可以发现，我们只用到了两个变量$sr=|S_r|,sc=|S_c|$，维护这两个变量即可。

综上，我们的算法是：

- 排序；
- 设最小的边权出自行中，不断分析边权，直到取完了第一个列中的边权；
- 对于之后的边，维护$sr,sc$，对于每个行中的边权$vr$，令$sr=sr+1$，并将$vr\times (m-sc)$累加入答案中；列中边权同理。

总时间复杂度$O((n+m)\text{log}(n+m))$。

---

## 作者：pengyule (赞：21)

作为一道不需要用到算法的题，这着实是一道好题！

题意简述：用最小的代价，在这个点阵中连边，使得所有点互相联通。

想想最小生成树的思想——贪心、不在已经联通的块中连边（即不构成环）。

那么这道题也是一样，在已经连上的边所构成的一些连通块当中，我们只在互相独立的两个块之间连边使其合并。

对于 $10^5$ 数量级的 $n,m$，显然不可能直接建图+暴力最小生成树。但是可以确定的一点是，我们首先对所有的权值（不论是行的还是列的）从小到大排序。每次取最小的那个权值看在它的这一行（或列）最少连多少边。显然最多要连 $n-1$（$m-1$）条。那么考虑什么情况下是必须要连全部的边的。或者说什么情况下是可以有部分边不需要连的？首先我们姑且把全部的边连上，然后再去看能不能舍去一些。
- 当我们在连的是行的权值时：如果我们看到连完之后出现了环，那么就可以省去 (【目前已经连过的列数】-1) 条边。
- 当我们在连的是列的权值时：如果我们看到连完之后出现了环，那么就可以省去 (【目前已经连过的行数】-1) 条边。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/x9ru4brm.png)

构成了环。当前我们在连的是列的边，所以我们就看【目前已经连过的行数】（即红线条的数量），得到 $2$，那么就可以少连两条边，因此当前操作的这一列要加的权值就是 $w\times (n-1) - w\times (2-1)$。省掉之后大概是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/2ehbbtcy.png)

所以现在要考虑的就是什么条件下可以省，什么条件下不能省，如你所知，当然不是所有的情况都可以省去 (【目前已经连过的行（列）数】-1) 条边的。换言之，就是我们连全部的边之后看到的景象什么时候会出现环。

一个环，俗一点说，至少要有两根横杠两根竖杠，所以判断条件就是：【（连完这次之后）目前已经连过的列数】大于等于 $2$ 且【（连完这次之后）目前已经连过的行数】大于等于 $2$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const int N=6e5+5;
struct node { int ty,val; } a[N];
bool cmp(node a,node b) { return a.val<b.val; }
int main()
{
    int n,m,x=0,y=0;
    long long sum=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d",&a[i].val),a[i].ty=1;
    for(int i=n+1;i<=n+m;i++) scanf("%d",&a[i].val),a[i].ty=2;
    sort(a+1,a+n+m+1,cmp);
    for(int i=1;i<=n+m;i++){
        if(a[i].ty==1){
            sum+=1ll*(m-1)*a[i].val;
            x=x<n?x+1:x;
            if(x>1&&y>1) sum-=1ll*(y-1)*a[i].val;
        }
        else {
            sum+=1ll*(n-1)*a[i].val;
            y=y<m?y+1:y;
            if(x>1&&y>1) sum-=1ll*(x-1)*a[i].val;
        }
    }
    cout<<sum<<endl;
    return 0;
}
```

---

## 作者：Zenith_Yeh (赞：15)

这道题只要你对 $Kruskal$ 的本质足够熟悉，就可以瞬间想到正解。

仔细看看 $Kruskal$ 的本质后，可以发现将 $a[\,\,]$ 和 $b[\,\,]$ 排序后，如果要加一条边，就直接可以将那一行 或 那一列全部加上。例如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/roslj0pa.png)

不妨设此时的 $a[\,\,]$ 和 $b[\,\,]$ 皆是升序排序后的，那如果取 $a_1$ 那么取 $a_1$ 这一列都是最优的。以此类推，共取 $n*m-1$ 即可。（**但是在加边是要判是否成环**）

那么总时间复杂度为 $O((n+m)log(n+m))$。

#### 上菜

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c))f|=(c=='-'),c=getchar();
	while(isdigit(c))x=x*10+(c&15),c=getchar();
	return f?-x:x;
}
int n,m,a[300005],b[300005];
long long ans;//不开long long见祖宗。 
int main()
{	n=read(),m=read();
	for(register int i=1;i<=n;i++)a[i]=read();
	for(register int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	ans=(long long)a[1]*(m-1)+(long long)b[1]*(n-1);//首先将最小的一行 和 最小的一列加上。 
	int cnta=2,cntb=2,h=1,l=1;
	while(cnta<=n&&cntb<=m)
	{	if(a[cnta]<=b[cntb])ans+=(long long)a[cnta++]*(m-l),h++;//判环加边。 
		else ans+=(long long)b[cntb++]*(n-h),l++;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Konnyaku_LXZ (赞：10)

首先有一个很明显的贪心：对于点 $(i,j)$ ，如果点 $(i-1,j)$ 和点 $(i,j-1)$ **都已经在当前的最小生成树内**，那么将点 $(i,j)$ 加入最小生成树后，答案的变化应该是 $min(a_i,b_j)$。

~~然后做法就很显然了。~~

我们将 $a$ 数组和 $b$ 数组分别排序，显然这对最小生成树的大小不会有影响。我们先把 $(1,1)$ 加入最小生成树，然后我们会发现矩形的第一行从左到右肯定都要连边，同理，第一列从上到下都要连边（原因显然，这里就不再赘述）。

然后我们分别考虑每一行，设当前考虑到第 $i$ 行，根据上面的贪心，将这一行的所有数加入最小生成树的代价为 $\sum \limits _{j=2}^m min(a[i],b[j])$。我们用 `lower_bound` 找到 $b$ 数组中第一个大于等于 $a_i$ 的数，设它的位置为 $x$ ，则代价为 $sum[x-1]-sum[1]+(M-x+1)*a_i$，其中 $sum$ 数组是 $b$ 数组的前缀和，累加答案即可。

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
#include<stack>
using namespace std;

const int MAXN=3e5+50;
typedef long long LL;

LL N,M,a[MAXN],b[MAXN],sum[MAXN],Ans=0;

void Init(){
	scanf("%lld%lld",&N,&M);
	for(int i=1;i<=N;++i) scanf("%lld",&a[i]);
	for(int i=1;i<=M;++i) scanf("%lld",&b[i]);
}

void Solve(){
	sort(a+1,a+1+N);//排序
	sort(b+1,b+1+M);
	Ans=a[1]*(M-1)+b[1]*(N-1);//第一行和第一列都要连边
	for(int i=1;i<=M;++i) sum[i]=sum[i-1]+b[i];//求前缀和
	for(int i=2;i<=N;++i){
		int x=lower_bound(b+2,b+1+M,a[i])-b;
		Ans+=sum[x-1]-sum[1];//累加答案
		Ans+=(M-x+1)*a[i];
	}
}

void Print(){
	cout<<Ans<<endl;
}

int main()
{
	Init();
	Solve();
	Print(); 
	return 0;
}
```

---

## 作者：Daidly (赞：5)

题意确实有点难理解，样例解释如下，没看懂题的可以参考：

```cpp
o-2-o-2-o
|   |   |
1   3   2
|   |   |
o-4-o-4-o
|   |   |
1   3   2
|   |   |
o-3-o-3-o
```

发现从小到大排序后对结果没有影响，先排序。

排序后，第一行和第一列在最小生成树中显然都取，先加上。

现在 $a_i$ 和 $b_j$ 都单调递增，所以可以使用二分查找找到每一行中 $b_j$ 中第一个大于等于 $a_i$ 的，下标记作 $pos$，则保证了这一行从 $2$ 到 $m$ 每一步都取最小。

形象的来说，排序后，当前点只有上或和左方能以最短的路到达当前点，考虑每一次是从上方下来还是从左边过来。由于序列单调，所以必有一个中断点，二分查找即可。

每一次加上 $sum[pos-1]-b[1]+a[i]\times (m-pos+1)$，其中 $sum$ 数组表示 $b$ 数组的前缀和，由于 $b_1$ 已经选过，所以要减去。

- 注意：$sum$ 数组是排序后 $b$ 数组的前缀和！！！

- 注意：二分查找的区间是 $[2,m]$！！！

- 注意：开 `long long`！！！

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

inline void print(ll x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int MAXN=3e5+5;
int n,m;
ll a[MAXN],b[MAXN],sum[MAXN],ans;

int find(int x){
	int l=2,r=m;
	while(l<=r){
		int mid=l+r>>1;
		if(b[mid]>x)r=mid-1;
		else l=mid+1;
	}
	return l;
}

int main(){
    n=read(),m=read();
    for(int i=1;i<=n;++i){
    	a[i]=read();
	}
	for(int i=1;i<=m;++i){
		b[i]=read();
	}
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	for(int i=1;i<=m;++i){
		sum[i]=sum[i-1]+b[i];
	}
	ans=a[1]*(m-1)+b[1]*(n-1);
	for(int i=2;i<=n;++i){
		int pos=find(a[i]);
		ans+=sum[pos-1]-b[1]+a[i]*(m-pos+1);
	}
	print(ans);
    return 0;
}
```

---

## 作者：qhr2023 (赞：4)

## solution

做法比较显然，加边时尽可能多地加权值小的边，并且注意判环。对环的处理是本题的重点。

只要有至少两条横边和至少两条竖边，就会构成环，那对于环如何解决，下面举个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/zbk3aomq.png)

现在已有两列竖边和一行横边，要加一行绿色的横边，发现加的话就会构成环，我们把成环的地方截去就好了。截去的部分就是两条竖边中间的一条横边，两条竖边中间有很多条横边也一样，只要删去一个就构不成环。

![](https://cdn.luogu.com.cn/upload/image_hosting/4ejrwneo.png)

如果有更多的竖边，每两列竖边截一条横边，那么 $x$ 列竖边就截 $x-1$ 条横边。

记当前已经加了 $h$ 次横边， $l$ 次竖边，第一次肯定是加满的，加了 $m-1$ 条边，后面每次只加了 $m-1-(l-1)$ 即 $m-l$ 条边。加竖边是类似的，$n-h$ 条。

就这样一直加边，直到构成树，即加完了横边且至少有一条竖边，或者反过来。

## code

慎用三目运算符。

```cpp
a[A]<=b[B] ? ans+=a[A++]*(m-l), h++ : ans+=b[B++]*(n-h), l++;
```

如果这么写，luogu 跑的结果和本地跑不一样。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, m, a[300005], b[300005], ans;
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i)
		cin >> a[i];
	for (int i=1; i<=m; ++i)
		cin >> b[i];
	sort(a+1, a+n+1);
	sort(b+1, b+m+1);
	for (int A=2, B=2, h=1, l=1; A<=n&&B<=m; )
		if (a[A]<=b[B])	
			ans+=a[A++]*(m-l), h++;
		else
			ans+=b[B++]*(n-h), l++;
	cout << ans+a[1]*(m-1)+b[1]*(n-1);
	return 0;
}
```

---

## 作者：残阳如血 (赞：3)

## P5687 [CSP-S2019 江西] 网格图

### 题意

有一个 $n\times m$ 的矩阵，$(i,j)\to(i,j+1)$ 花费为 $a_i$，$(i,j)\to (i+1,j)$ 花费为 $b_j$。

求出这个网格图的最小生成树。

$3\le n,m\le3\times10^5$，$1\le a_i,b_j\le10^5$。

### 64 解法

求最小生成树，可以直接使用 Kruskal 算法。

暴力将相邻的点连边，然后排序从前往后取。

#### 时间复杂度

时间复杂度 $O(nm\log(nm))$，可以通过 $n,m\le300$ 的数据，预期得分 $64$。

### 100 解法

先来分析题目的特殊性质。

容易发现，每一行、每一列的所有边边权都相等。

那么这个性质可以如何优化 Kruskal 算法呢？

#### 排序

我们先考虑如何加速排序。

排序后，边权相同的边必然是连续的。这就启发我们将每一行、每一列的所有边打包成一个集合，然后放在一起排序。

但是我们最后选择的时候肯定要讨论行、列，所以需要再开一维 $0/1$ 存储信息。

#### 选择

然后考虑加速选择的过程。

由于排序是打包排序的，那么选择也可以试着用这种思路。

> 下面暂时假设处理的是行，即当前的边权是 $a_i$。

这行应该连多少边呢？$m-1$ 条吗？显然不是。

![洛谷P5687-1](https://img.0ier.de/2025/07/3aabf579f7683e191e2d614cb9d0cf0b.png)

考虑上面的情况，虽然这两列已经被选择了，但是一个行都没有被选择，两列是互相独立的，所以需要连 $m-1$ 条边才能使这一行连通。

![洛谷P5687-2](https://img.0ier.de/2025/07/3ee306bab5f802f18dc62d7970dac947.png)

但是如果之前已经有行被选择了，那么就构成了一个连通块，两列已经连通了。那么还剩余两个点，只要将两个点挂到原来的列上就行了。

---

这就启示我们可以进行分类讨论，假设当前有 $x$ 个行被选择，$y$ 个列被选择。

- $x=0$：此时就和第一种情况一样，当前行完全没有连通，需要 $m-1$ 条边。

- $x\not=0$：这个时候需要根据 $y$ 分类讨论：

  - $y=0$，那么还是当前行完全没有连通，需要 $m-1$ 条边。

  - $y\not=0$，那么当前行已经有 $y$ 个点互相连通了，只需要将剩余的点连到这 $y$ 个点即可，需要 $m-y$ 条边。

    详细地，如果有一个点距离这 $y$ 个点中的某一个点距离为 $z$，那么只需要连到距离为 $z-1$ 的点上，然后递归下去即可。

整理一下，结论就呼之欲出了：

- $x=0\lor y=0$：$m-1$ 条边。
- $x\not=0 \land y\not=0$：$m-y$ 条边。

然后现在多了一个选择的行，$x\gets x+1$。

列同理，这里不赘述了。

#### 结束条件

普通的 Kruskal 算法是判断剩余的点数的，但是本题中我们可以不这样做。

直接将全部的边跑完，这样子后面选不上的也不会选，正确性也是显然的。

#### 时间复杂度

打包后边总共有 $n+m$ 个。

- 排序，$O((n+m)\log(n+m))$。
- 选取，$O(n+m)$。

时间复杂度 $O((n+m)\log(n+m))$，可以通过本题，预期得分 $100$。

#### 代码

```c++
/**
 * Problem: P5687 [CSP-S2019 江西] 网格图
 * Author:  OIer_wst
 * Date:    2025-07-02
 */
#include <bits/stdc++.h>
using lint = long long;
using pii = std::pair<int, int>;
const int N = 3e5 + 10;

lint ans; // ans 记录权值之和

std::vector<pii> num; // first 表示值，second=0 表示行，second=1 表示列

int n, m, row, col;

int main() {
  std::cin.tie(0)->sync_with_stdio(0);
  std::cin >> n >> m;
  for (int i = 1, x; i <= n; ++i) std::cin >> x, num.emplace_back(pii{x, 0});
  for (int j = 1, x; j <= m; ++j) std::cin >> x, num.emplace_back(pii{x, 1});
  std::sort(num.begin(), num.end());
  
  for (auto p : num) {
    if (!p.second) { // 行
      if (row && col) ans += 1ll * (m - col) * p.first;
      else ans += 1ll * (m - 1) * p.first;
      ++row;
    } else { // 列
      if (row && col) ans += 1ll * (n - row) * p.first;
      else ans += 1ll * (n - 1) * p.first;
      ++col;
    }
  }

  std::cout << ans <<std::endl;
  return 0;
}
```

---

## 作者：HZY1618yzh (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5687)

题意
---
给定一个 $n$ 行 $m$ 列的网格图，每个格子是一个点。连接规则如下：  
1. 横向边：第 $i$ 行相邻的点之间有一条边，权值为 $a_i$。  
2. 纵向边：第 $j$ 列相邻的点之间有一条边，权值为 $b_j$。

要求：求出这个网格图的最小生成树（即用最少的边权总和连接所有点）。  

解决方法
---
要求最少的边权总和连接所有点，所以需要贪心使得当前边权尽量小，因此需要排序。  
不难证明，$a$ 和 $b$ 数组不管如何变化，最终都不影响最小生成树（改变那两个数组的顺序其实是交换了某两列/行的节点）。  
注：后面讲解里，我们令权值越小的横向边（$a$）越靠上，权值越小纵向边（$b$）越靠左。当前没有填过数最小横向边标号为 $i$，纵向边为 $j$。  
网格图一共有 $nm$ 个节点，最小生成树需要 $nm-1$ 条边。我们希望每一条边权值越小越好，可以考虑每次把最上面和最左边的那层节点放上边，因为那是当前纵横边里最小的 $n-i+m-j$ 条边，减 $i$ 和 $j$ 是因为每层都会减少一条边。  
不过这样这棵树，却变成了一层又一层的“厂”，并不联通。所以我们可以每层挑选 $\min(a_i,b_i)$ 与外面的厂连接。  
![I AM AK IOI！](https://cdn.luogu.com.cn/upload/image_hosting/f4u9d1lb.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
不过这是最优的贪心策略吗？大胆猜测，小心求证。如果 $a=\{2,2,6,4\}$，$b=\{5,1000,2000,3400\}$ 的时候，很明显，选 $a$ 的所有边和 $b$ 的第一条边是最优策略，而我们的“厂字图”却不是最优的方案。  
我们可以先确定 $a_1$ 和 $b_1$ 为基础边。接着选择剩下边里最小的 $a_2$，为了防止出现刚才不联通的情况，该边需要 $n-2(i)-1$ 条。接着重复刚才的步骤，继续选择剩下边里最小，即可以得出刚才说的方案。  
![](https://cdn.luogu.com.cn/upload/image_hosting/mzoomicu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
选择剩下边里最小可以用双指针实现，每个指针表示的是当前正在选第几条边（即 $i$ 和 $j$）。比较当前最小值，可以求出最小的边。具体证明评论区讨论  
### 语言代码：  
- 输入。
- 对 $a$ 和 $b$ 数组排序。  
- 取 $a_1$ 和 $b_1$（最小的）作为基础边，增加给 $ans$。  
- 然后利用双指针实现 $ans$ 交替增加较小的 $a_i$、$b_j$ 乘以剩余需要的边数。
- 输出答案。

具体实现
---
- c++
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
int n,m,a[300001],b[300001];
ll ans;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++)
		cin>>b[i];
    //排序
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	ans=(ll)a[1]*(m-1)+(ll)b[1]*(n-1);//取a_1和b_1（最小的）作为基础边
	int i=2,j=2;
	while(i<=n&&j<=m){
		if(a[i]<b[j]){//取较小的a_i或b_j
			ans+=(ll)a[i]*(m-j+1);//乘以剩余需要的边数
			i++;//移动指针
		}else{
			ans+=(ll)b[j]*(n-i+1);//乘以剩余需要的边数
			j++;//移动指针
		}
	}
	cout<<ans;
    return 0;
}
```
- python
```python
n,m=map(int,input().split())
a=list(map(int, input().split()))
b=list(map(int, input().split())
a.sort()
b.sort()
ans=a[0]*(m-1)+b[0]*(n-1)
i,j=1,1
while i<n and j<m:
    if a[i]<b[j]:
        ans+=a[i]*(m-j)
        i+=1
    else:
        ans+=b[j]*(n-i)
        j+=1
print(ans)
```
~给个赞吧！~

---

## 作者：cybermage_liu (赞：2)

# 思路
贪心，贪就完了。

简化题意：在保证联通的情况下，对于每对 $a_i$ 和 $b_j$，求较小值的和。

所以，对 $a$ 和 $b$ 排序在保证联通的情况下不会改变答案。

排序后 $a_1$ 和 $b_1$ 肯定要分别选 $m-1$ 和 $n-1$ 遍，因为要联通网格图的每一列和每一行。

然后对于剩下的 $(n-1)\times(m-1)$ 的网格图,可以枚举 $a_i$ 通过二分找到 $b$ 中第一个比 $a_i$ 大的位置（令此位置的前一个位置为 $x$）。

此位置前的所有点（$2$ 到 $x$）均选 $b$，此位置及其之后的所有点（$x+1$ 到 $m$）均选 $a$。

选 $a$ 的部分加上 $a_i\times(m-1-x)$，选 $b$ 的部分可以通过前缀和来维护。

时间复杂度 $O(n\log m)$。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e5+5;
int a[N],b[N],sumb[N];
inline int read(){
	int x=0,f=1;char ch;
	while((ch=getchar())<48 || ch>57) if(ch==45) f=-1;
	while(ch>=48 && ch<=57) x=x*10+ch-48,ch=getchar();
	return x*f;
}
signed main(){
	int n=read(),m=read(),ans=0;
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++) b[i]=read();
	sort(a+1,a+1+n);
	sort(b+1,b+1+m);
	ans+=a[1]*(m-1);
	ans+=b[1]*(n-1);
	for(int i=1;i<m;i++) sumb[i]=sumb[i-1]+b[i+1];//前缀和
	for(int i=1;i<n;i++){
		int x=lower_bound(b+2,b+1+m,a[i+1])-b-1;
		x--;//此位置的前一个位置
		ans+=sumb[x]+a[i+1]*(m-1-x);//累加答案
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：canwen (赞：1)

这题能够加深对 Kruskal 算法的理解！
本蒟蒻也是在参照题解下过的，故写篇题解加深印象。


## 题意
求这 $n\times m$ 个点的最小生成树，即让 $n\times m$ 个点连通且不存在环。

我们降 $a_i,b_i$ 升序排序，显然有如下贪心策略：

这里假设是最小值是 $a_1$（若是 $b_1$ 也同理，只是先处理列再处理行而已），我将 $a_1$ 代表的行中 $m$ 个点两两连通一定不劣。接着若第二小值依旧是 $a_2$，则继续将 $a_2$ 代表的行中 $m$ 个点两两连通，以此类推直到第 $k$ 小值是 $b_1$，此时将 $b_1$ 所代表的列中 $n$ 个点两两连通。至此，不同行之间都已经连通起来。举个例子，如下图（$n= 5,m=4$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/nc3vz6py.png)

在该图中，接下来的最小值是 $5$，代表第 $1$ 行，此时已经有 $1$ 列（从左往右数第 $2$ 列）在最小生成树内了，所以只需要 $m-1 = 3$ 条边的代价。

![](https://cdn.luogu.com.cn/upload/image_hosting/xwkys0og.png)

接着最小值是 $6$，代表第 $3$ 列，此时已经有 $4$ 行在最小生成树内，所以只需要 $n-4=1$ 条边的代价。以此类推可以得到这 $n\times m$ 个点的最小生成树：

![](https://cdn.luogu.com.cn/upload/image_hosting/xuxjbrd1.png)

实现上太简单了，不讲了，维护一下已经处理过的行和列就行了。

瓶颈在于排序，复杂度 $O((n+m)\log(n+m))$。
## Code

```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;

#define int long long
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#define pc putchar
int in(){
	char a=getchar();int k=0,kk=1;
	while(!(a>='0'&&a<='9')) {if(a == '-') kk = -1;a = getchar();}
	while(a>='0'&&a<='9') k = k*10 + a - '0', a = getchar();
	return k*kk;
}
void out(int a){
	if(a < 0) pc('-'), a= -a;
	if(a > 9) out(a/10);
	pc('0'+a%10);
}
#define fst first
#define snc second
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define mp make_pair
#define pint pair<int,int>
#define i128 __int128
#define i64 long long
#define pb emplace_back
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define nowtime (double)clock()/CLOCKS_PER_SEC

const int N = 3e5 + 5;
int n,m,a[N],cnt,b[N],ans;
int s1,s2; // s1 : 行, s2 列
struct node{
	int v,x,pd;
}e[2*N];

bool cmp(node a,node b){
	if(a.x == b.x) return a.pd < b.pd;
	return a.x < b.x;
}

signed main(){
	n=in(),m=in();
	_rep(i,1,n) e[++cnt].x=in(),e[cnt].v=i,e[cnt].pd=1;
	_rep(i,1,m) e[++cnt].x=in(),e[cnt].v=i,e[cnt].pd=2;
	sort(e+1,e+1+cnt,cmp);
	int now = 0;
	e[0].pd = e[1].pd;
	while(e[now+1].pd == e[now].pd){
		++now, ans += e[now].x * (e[now].pd == 1 ? m-1 : n-1);
		if(e[now].pd == 1) ++s1;
		else ++s2;
	}
	++now, ans += e[now].x * (e[now].pd == 1 ? m-1 : n-1);
	if(e[now].pd == 1) ++s1;
	else ++s2;
	while(!(s1 == n && s2 || s2 == m && s1)){
		++now;
		ans += e[now].x * (e[now].pd == 1 ? m-s2 : n-s1);
		if(e[now].pd == 1) s1++;
		else s2++;
	}
	out(ans);
	return 0;
}
```

[Accept submission](https://www.luogu.com.cn/record/225466866)。

---

## 作者：Hootime (赞：1)

一道简单题 ~~，可惜我最开始没做出来，经过[一位神犇](https://www.luogu.com.cn/user/1294410)的指导才 AC~~。

[更好的阅读体验](https://www.cnblogs.com/hootime/p/18834521)

### 思路
首先考虑 Kruskal。但是复杂度 $O(n^2 \log n^2)$，别想了。

但是注意到有很多边（同一行/列）的权值是一样的，于是直接把行/列排序，然后贪心。但是注意判一下环，不然就不是生成树了。

判环很简单，令已经加入了 $cnt_1$ 行、$cnt_2$ 列，往答案里加边时减去 $cnt_i-1$ 条边（减去一是因为需要和树相连）就可以了。复杂度 $O(n \log n)$。

于是，没了。

### 代码

```cpp
#include <bits/stdc++.h>
#define rint register int
#define rllong register long long
#define llong long long
#define N 300005
using namespace std;

llong a[N], b[N];
llong n, m, ans;
llong cnt1 = 1, cnt2 = 1;

int main(){
	scanf("%lld %lld", &n, &m);
	for(rint i = 1, x; i <= n; ++i) scanf("%lld", &a[i]);
	for(rint i = 1, x; i <= m; ++i) scanf("%lld", &b[i]);
	sort(a+1, a+n+1), sort(b+1, b+m+1);
	ans = a[1]*(m-1)+b[1]*(n-1);
	rint i = 2, j = 2;
	while(i <= n && j <= m){
		if(a[i] <= b[j]) ans += 1ll*a[i]*(m-cnt2), ++cnt1, ++i;
		else             ans += 1ll*b[j]*(n-cnt1), ++cnt2, ++j; 
	}
	printf("%lld", ans);
	return 0;
}

/*
3 3
2 4 3
1 3 2

*/
```

---

## 作者：lkjlkjlkj2012 (赞：0)

### 思路
考虑暴力 kruskal 的过程，是将边权排序，按边权从小到大顺序考虑边，这条边连接了当前两个不同联通块就加入最小生成树。所以我们可以将边权排序，考虑每次加入一行或者一列的边，并去掉这次加边时加入的不必要的边。比如图中已经加入了绿色的边，要加入纵向的蓝色边，那么图中打叉的边就是可以去掉的，可以发现数量是横向加入的行数量减 $1$。横向边同理。那么就做完了。
![](https://cdn.luogu.com.cn/upload/image_hosting/klru501c.png)
### 代码

```cpp
// Problem: P5687 [CSP-S2019 江西] 网格图
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5687
// Memory Limit: 125 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
int n, m;
struct Dat {
  int v, tp;
} a[600005];
bool cmp(Dat x, Dat y) { return x.v < y.v; }
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i].v, a[i].tp = 1;
  for (int i = n + 1; i <= n + m; i++) cin >> a[i].v, a[i].tp = 2;
  sort(a + 1, a + n + m + 1, cmp);
  int x = 0, y = 0;
  long long ans = 0;
  for (int i = 1; i <= n + m; i++) {
    if (a[i].tp == 1) {
      ans += (long long)(m - 1) * a[i].v;
      x++;
      if (x > 1 && y > 1) ans -= (long long)(y - 1) * a[i].v;
    } else {
      ans += (long long)(n - 1) * a[i].v;
      y++;
      if (x > 1 && y > 1) ans -= (long long)(x - 1) * a[i].v;
    }
  }
  cout << ans;
}
```

---


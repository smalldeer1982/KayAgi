# [NOI2002] 机器人M号

## 题目描述

3030 年，Macsy 正在火星部署一批机器人。

第 $1$ 秒，他把机器人 $1$ 号运到了火星，机器人 $1$ 号可以制造其他的机器人。

第 $2$ 秒，机器人 $1$ 号造出了第一个机器人——机器人 $2$ 号。

第 $3$ 秒，机器人 $1$ 号造出了另一个机器人——机器人 $3$ 号。

之后每一秒，机器人 $1$ 号都可以造出一个新的机器人。第 $m$ 秒造出的机器人编号为 $m$。我们可以称它为机器人 $m$ 号，或者 $m$ 号机器人。

机器人造出来后，马上开始工作。$m$ 号机器人，每 $m$ 秒会休息一次。比如 $3$ 号机器人，会在第 $6$，$9$，$12$，$\ldots$ 秒休息，而其它时间都在工作。

机器人休息时，它的记忆将会被移植到当时出生的机器人的脑中。比如 $6$ 号机器人出生时，$2$，$3$ 号机器人正在休息，因此，$6$ 号机器人会收到第 $2$，$3$ 号机器人的记忆副本。我们称第 $2$，$3$ 号机器人是 $6$ 号机器人的老师。

如果两个机器人没有师徒关系，且没有共同的老师，则称这两个机器人的知识是互相独立的。**注意：$1$ 号机器人与其他所有机器人的知识独立（因为只有 $1$ 号才会造机器人），它也不是任何机器人的老师。**

一个机器人的**独立数**，是指所有编号比它小且与它知识互相独立的机器人的个数。比如 $1$ 号机器人的独立数为 $0$，$2$ 号机器人的独立数为 $1$（$1$ 号机器人与它知识互相独立），$6$ 号机器人的独立数为 $2$（$1$，$5$ 号机器人与它知识互相独立，$2$，$3$ 号机器人都是它的老师，而 $4$ 号机器人与它有共同的老师——$2$ 号机器人）。

新造出来的机器人有 $3$ 种不同的职业。对于编号为 $m$ 的机器人，如果能把 $m$ 分解成偶数个不同奇素数的积，则它是政客，例如编号 $15$；否则，如果 $m$ 本身就是奇素数或者能把 $m$ 分解成奇数个不同奇素数的积，则它是军人，例如编号 $3$，编号 $165$。其它编号的机器人都是学者，例如编号 $2$, 编号 $6$, 编号 $9$。

第 $m$ 秒诞生的机器人 $m$ 号，想知道它和它的老师中，所有政客的独立数之和，所有军人的独立数之和，以及所有学者的独立数之和。可机器人 $m$ 号忙于工作没时间计算，你能够帮助它吗？

为了方便你的计算，Macsy 已经帮你做了 $m$ 的素因子分解。为了输出方便，只要求输出总和除以 $10000$ 的余数。

## 说明/提示

#### 样例解释
$m = 2\times 3^2\times 5=90$。$90$ 号机器人有 $10$ 个老师，加上它自己共 $11$ 个。其中政客只有 $15$ 号；军人有 $3$ 号和 $5$ 号；学者有 $8$ 个，它们的编号分别是：$2,6,9,10,18,30,45,90$。

#### 数据范围
对于全部的数据，$1\le k\le 1000$，$2\le p_i<10,000$，$1\le e_i\le 1,000,000$。

#### 评分规则

你在一个测试点的得分与你正确解决的问题数 $x$ 有关。

请注意：**对每一行，即使不会解决该问题，也请在该行输出一个数字，否则 checker 将无法正确评分。**

| $x$  | 得分 |
| :--: | :--: |
|  3   |  10  |
|  2   |  7   |
|  1   |  4   |
|  0   |  0   |

## 样例 #1

### 输入

```
3
2 1
3 2
5 1```

### 输出

```
8
6
75```

# 题解

## 作者：StudyingFather (赞：9)

显然，$i$ 号机器人的独立数就是 $\varphi(i)$（特别地，$1$ 号机器人的独立数为 $0$）。

政客和军人的独立数之和可以很容易用 DP 求出。

设 $f(i,0/1)$ 表示前 $i$ 个因子中，选了奇数个或偶数个因子的独立数的和。

对于当前因子有选和不选两种决策，所以有，

$$
f(i,j)=f(i-1,j \oplus 1) \times \varphi(p_i) + f(i-1,j)
$$

（别忘了 $p_i$ 都是质数，所以$\varphi(p_i)=p_i-1$）

特别地，因为政客和军人的讨论范围都是奇素数，因此要对 $p_i=2$ 的情况特殊处理。

最后用总独立数减去政客和军人的独立数即可得到学者的独立数。

总独立数并不难算，因为 $m= \sum_{d|m} \varphi(d)$，故总独立数为 $m-1$（别忘了 $1$ 号机器人并不在我们的讨论范围之内）。

```cpp
#include <cstdio>
#define MOD 10000
int f[1005][2];
int fpow(int x,int y)
{
 int ans=1;
 while(y)
 {
  if(y&1)ans=ans*x%MOD;
  x=x*x%MOD;
  y>>=1;
 }
 return ans;
}
int main()
{
 int k;
 scanf("%d",&k);
 int tot=1;
 f[0][0]=1;
 for(int i=1;i<=k;i++)
 {
  int p,e;
  scanf("%d%d",&p,&e);
  tot=tot*fpow(p,e)%MOD;
  for(int j=0;j<=1;j++)
   f[i][j]=(f[i-1][j^1]*(p==2?0:p-1)+f[i-1][j])%MOD;
 }
 f[k][0]=(f[k][0]-1+MOD)%MOD;
 printf("%d\n",f[k][0]);
 printf("%d\n",f[k][1]);
 printf("%d\n",((tot-f[k][0]-f[k][1]-1)%MOD+MOD)%MOD);
 return 0;
}
```


---

## 作者：DeaphetS (赞：6)

不需要用上DP的纯数学做法。

首先抛出几个结论：

1、 $m$ 的独立数就是 $\varphi(m)$ ；

2、 $m$ 的老师就是他的约数；

3、 $m$ 及他老师的独立数和就是 $m$ （如果算上1），这是因为 $\sum_{d\mid m}\varphi(d)=m$ 对任意正整数 $m$ 均成立。



------------
由上述结论，我们知道最后输出的三个数的答案总和就是$m-1$，我们来考虑前面两个数怎么求。

第一个类别的数满足能被分解成偶数个不同**奇素数**的积，第二个类别的数满足能被分解成**偶数个**不同奇素数的积，我们不妨来求一下**能被分解成不同奇素数的积**的数对应的独立数和。

假设输入的数 $m$ 的奇质因子为 $p_1,p_2,...,p_k$ ，那么满足条件的数就是在这 $k$ 个数字里选若干个数相乘的结果，那么他们的独立数是什么呢？

由于欧拉函数 $\varphi$ 满足：当两个数 $p,q$ 互质时，有 $\varphi(p)\cdot \varphi(q)=\varphi(p\cdot q)$ 。所以我们惊喜的发现，满足条件的数对应的独立数就是选出来的若干个 $p_i$ 对应的欧拉函数的乘积。

所以这些数的独立数之和为

$(1+\varphi(p_1))(1+\varphi(p_2))...(1+\varphi(p_k))$

这个式子的意义就是，对于每个质因子，我考虑选或者不选，如果选的话就会有 $\varphi(p_i)$ 的贡献。（联想一下约数个数以及约数和的式子）


------------
我们回到题目，发现他要求的是能被分解成偶数个不同**奇素数**的积的数字对应的独立数和，那这个怎么做呢？



------------


我们来插播一道中学数学题（想看结论跳过此部分）：求 $(x+1)^5$ 的展开式中， $x,x^3,x^5$ 的系数和。

我们知道，由二项式定理，有 $(x+1)^5=\sum_{i=0}^{5}C_5^i\cdot x^i$ ，那如果要求所有系数和的话我们知道答案就是 $(1+1)^5=32$ ，那么 $x,x^3,x^5$ 的系数和怎么求呢？

考虑 $(x-1)^5$ 的展开式， $(x-1)^5=\sum_{i=0}^{5}C_5^i\cdot x^i\cdot(-1)^{5-i}$ ，我们发现在这个式子中，如果 $x$ 的次数 $i$ 是偶数，那么 $-1$ 的次数 $5-i$ 就会是奇数，也就是说对应的符号变成了负号。如果我们把这个式子和之前的 $(x+1)^5$ 相加，就会把所有偶数次项消掉，剩下的就只剩下奇数次项 $x,x^3,x^5$ 了！

所以这道题的答案就是 $\frac{(1+1)^5+(1-1)^5}{2}=16$ 。


------------
看完上面的例题，你是不是对这题有了些许思路呢？

考虑式子 $(1-\varphi(p_1))(1-\varphi(p_2))...(1-\varphi(p_k))$ ，我们可以发现，如果我选取了偶数个因子，那么对应的 $-\varphi(p_i)$ 就会被乘偶数次，系数就是 $1$ 。反之，如果我选取了奇数个因子，那么对应的 $-\varphi(p_i)$ 就会被乘奇数次，系数就是 $-1$ 。那么我们把这个式子与之前的式子相加，就可以把奇数个因子对应的独立数消掉，把结果除以二就是偶数个质因子的数对应的答案了！



------------
上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1010
#define MOD 10000
#define LL long long
LL n,p[N],e,s=1,a,k1=1,k2=1,b;
LL qow(LL x,LL y){return y?(y&1?x*qow(x,y-1)%MOD:qow(x*x%MOD,y/2)):1;}
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&p[i],&e);
		s=(s*qow(p[i],e))%MOD;
		if(p[i]&1)k1=k1*p[i]%(2*MOD);
		if(p[i]&1)k2=k2*(2*MOD+2-p[i])%(2*MOD);
	}
	a=((k1+k2)/2+MOD)%MOD,b=k1+MOD-a;
	printf("%lld\n%lld\n%lld\n",(a-1)%MOD,b%MOD,((s-a-b)%MOD+MOD)%MOD);
}
```

可以发现我在计算 $k1$ 和 $k2$ 的时候是对 $20000$ 而不是 $10000$ 取模，这是因为如果对后者取模，由于在计算答案时有一个 $/2$ ，所以会算出答案模 $5000$ 的值，所以要预先对模数乘二。

---

## 作者：djh123 (赞：4)

通读一遍题面，我们会发现几个性质：

- $u$ 是 $v$ 的老师 $\iff$ $u|v$ 并且 $u \ne 1$。
- 若 $u \ne 1$，那么 $u$ 的独立数 $= \varphi(u)$。

我们会发现政客和军人只能由不同的奇素数乘起来得到，因为 $\varphi$ 是积性函数，那么我们可以很容易用 dp 计算：

设 $f_{i,j}$ 表示考虑了前 $i$ 个质数，选中奇数还是偶数个的答案，转移：$f_{i,j}=f_{i-1,j \ \text{xor}\  1}\times \varphi(p_i)+f_{i-1,j}$。

但是学者的独立数不是很好算，我们考虑容斥，用总的独立数减去上面求的政客和军人的独立数。

因为 $\sum_{d|n}\varphi(d) = n$，那么总的独立数就是 $m-1$。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define rep(i, x, y) for(int i = (x); i <= (y); ++ i)
#define rop(i, x, y) for(int i = (x); i <  (y); ++ i)
#define per(i, x, y) for(int i = (x); i >= (y); -- i)
#define por(i, x, y) for(int i = (x); i >  (y); -- i)

typedef long long LL;
const int mod = 10000;

LL ksm(LL x, int p) {
	LL a = 1;
	while(p) {
		if(p & 1) a = a * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return a;
}

LL f[1050][2];

int main() {
	int n; scanf("%d", &n);
	LL tot = 1;
	f[0][0] = 1;
	rep(i, 1, n) {
		int p, k;
		scanf("%d%d", &p, &k);
		tot = tot * ksm(p, k) % mod;
		f[i][1] = (f[i - 1][0] * (p == 2 ? 0 : (p - 1)) % mod + f[i - 1][1]) % mod;
		f[i][0] = (f[i - 1][1] * (p == 2 ? 0 : (p - 1)) % mod + f[i - 1][0]) % mod;
	}
	f[n][0] = (f[n][0] - 1 + mod) % mod;
	printf("%lld\n%lld\n%lld\n", f[n][0], f[n][1], ((tot - f[n][0] - f[n][1] - 1) % mod + mod) % mod);
}
```



---

## 作者：lzy20091001 (赞：1)

[洛谷 P5746 [NOI2002] 机器人M号](https://www.luogu.com.cn/problem/P5746)

## 前置知识

1. 积性：当且仅当正整数 $a, b$ 满足 $a \perp b$ 时，有 $\varphi(ab) = \varphi(a) \cdot \varphi(b)$。
2. 反演：对于正整数 $n$，有 $n = \sum _ {d \mid n} \varphi(d)$​。
3. 对于任意质数 $p$，有 $\varphi(p) = p - 1$。

## 分析

两个机器人知识独立，当且仅当这两个机器人的编号互质，否则它们编号的最大公因数就是他们共同的老师。

因此对于 $n \ (n \ne 1)$ 号机器人，它的独立数等于 $\varphi(n)$。

### 政客和军人

对于政客和军人的独立数之和，我们考虑 DP。

#### 状态

设 $f(i, 0 / 1)$ 分别表示在前 $i$ 个素因子中，选取 **偶数** / **奇数** 个素因子相乘得到的独立数之和。

#### 转移

对于 $p _ i$，我们有 **选** 和 **不选** 两种决策。如果选，那么根据欧拉函数的积性可以得知：

$$
f(i, 0) = f(i - 1, 0) + f(i - 1, 1) \times \varphi(p _ i), \\
f(i, 1) = f(i - 1, 1) + [f(i - 1, 0) + 1] \times \varphi(p _ i).
$$

$f(i, 1)$ 的转移中，我们可以只选择 $p _ i$ 而不选 $p _ {1, 2, \cdots, i - 1}$，这是 $f(i, 0)$ 与 $f(i, 1)$ 转移方程形式不同的原因。

同时，根据第 3 条前置知识，我们有 $\varphi(p _ i) = p _ i - 1$。

#### 初始化

根据题目 **奇素数** 的要求，$2$ 不能选。而题目又保证 $p _ 1 < p _ 2 < \cdots < p _ k$，因此我们特判 $p _ 1$ 是否为 $2$：
$$
p _ 1 = 2 \Rightarrow f(1, 1) = f(1, 0) = 0, \\
p _ 1 \ne 2 \Rightarrow f(1, 1) = p _ 1 - 1, f(1, 0) = 0.
$$

### 学者

我们用 **所有数的独立数之和** 减去 **政客和军人的独立数**。由第 2 条前置知识可知及本题中 $1$ 的独立数为 $0$，可以得知所有数的独立数之和为 $m - 1$。$m$ 可以用快速幂求得。

### 复杂度

时间复杂度 $\operatorname{O}(k \log e)$，瓶颈为求出 $m$。

空间复杂度 $\operatorname{O}(k)$，当然也可以用滚动数组等方式优化到 $\operatorname{O}(1)$。

## 实现

```cpp
#include <iostream>

const int K = 1000, MOD = 10000;

int p[K + 5], e[K + 5];
int f[K + 5][2];

int qpow(int a, int n)
{
    int res = 1;
    while (n)
    {
        if (n & 1)
            res = (res * a) % MOD;
        a = (a * a) % MOD;
        n >>= 1;
    }
    return res;
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int k, m = 1;

    std::cin >> k;
    for (int i = 1; i <= k; i++)
    {
        std::cin >> p[i] >> e[i];
        m = m * qpow(p[i], e[i]) % MOD;
    }

    if (p[1] != 2)
        f[1][1] = p[1] - 1;
    for (int i = 2; i <= k; i++)
    {
        f[i][0] = (f[i - 1][0] + f[i - 1][1] * (p[i] - 1)) % MOD;
        f[i][1] = (f[i - 1][1] + (f[i - 1][0] + 1) * (p[i] - 1)) % MOD;
    }

    std::cout << f[k][0] << "\n"
              << f[k][1] << "\n"
              << ((m - f[k][0] - f[k][1] - 1) % MOD + MOD) % MOD << "\n";

    return 0;
}
```

---

## 作者：Elaina_0 (赞：1)

# P5746 [NOI2002] 机器人M号 题解

发现竟然还能交题解，遂来~~水~~一发。

[$\Large 博客$](https://www.cnblogs.com/Elaina-0/p/18264429)$\Large {食用更佳哦}$

## 分析

**显然**：

当 $i \neq 1$ 时 

-  $i$ 是 $j$ 的老师 $\Leftrightarrow i \mid j$

- 第 $i$ 号机器人的独立数为 $\varphi(i)$


读题，设两个奇素数 $x,y$ ，分情况讨论：

- $x$ 为政客：则 $x \times y$ 为军人

- $x$ 为军人：则 $x \times y$ 为政客


所以政客和军人只能由不同的奇素数乘起来得到。

考虑DP。

设 $f(i,j)$ 为前 $i$ 个质数中，选奇数 $(j=1)$ 或偶数 $(j=0)$ 个质数的答案，则动态转移方程为
$$f(i,j)=f(i-1,j\operatorname{xor}1) \times \varphi(p_i)+f(i-1,j)$$

学者的独立数只需快速幂求 $m$ 的值，再减去政客和军人，再减 $1$ (不明白减 $1$ 重新爬回去读题 怒)即可。 


## Elaina's Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
#define rd read()
#define Elaina 0
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}

const int mod=10000;
int n,m,f[N][2];

int qpow(int a,int b){
	int ret=1;
	for(;b;b>>=1){
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;
	}
	return ret;
}

signed main(){
	int k=rd;
	f[0][0]=1;
	int cnt=1;
	for(int i=1;i<=k;i++){
		int p=rd,e=rd;
		(cnt*=qpow(p,e))%=mod;
		f[i][1]=(f[i-1][0]*(p==2?0:(p-1))%mod+f[i-1][1])%mod;
		f[i][0]=(f[i-1][1]*(p==2?0:(p-1))%mod+f[i-1][0])%mod;
	}
	f[k][0]--;
	printf("%lld\n%lld\n%lld\n",(f[k][0]%mod+mod)%mod,f[k][1],((cnt-f[k][0]-f[k][1]-1)%mod+mod)%mod);
	
	return Elaina;
}
```

---

## 作者：Ryanhao (赞：0)

# [NOI2002 机器人 M 号](https://www.luogu.com.cn/problem/P5746)

蒟蒻新学欧拉函数，发现一道绿的 NOI。

## 思路

对于 $n$ 号机器人，他的独立数是 $\begin{cases}
0  & \text{ if } n=1 \\
\varphi(x)   & \text{ if } n>1
\end{cases}$，其中 $\varphi(n)$ 就是欧拉函数，表示 $[1,n]$ 之间所有与 $n$ 互质的数的个数。对于一个质数 $p$，有 $\varphi(p)=p-1$，等会要考。$\varphi(1)=1$ 要注意和此题区分。

计算三种老师的独立数。考虑 $p_{[1,i]}$，设 $f_i$ 表示政客的独立数之和，$g_i$ 表示军人的独立数之和。

得到转移：

$$
\begin{array}{c}
f_i=\begin{cases}
 \varphi(p_i)\cdot g_{i-1}+f_{i-1} & \text{ if } p_i\ne2 \\
 f_{i-1} & \text{ if } p_i=2
\end{cases}
\end{array}
$$
$$
\begin{array}{c}
g_i=\begin{cases}
 \varphi(p_i)\cdot f_{i-1}+g_{i-1}+\varphi(p_i) & \text{ if } p_i\ne2 \\
 g_{i-1} & \text{ if } p_i=2
\end{cases}
\end{array}
$$

可以看到，因为一个奇质数也可以组成军人，$g_i$ 要多加一个 $\varphi(p_i)$。$2$ 因为不是奇数惨遭抛弃。**注意：军人、学者的所有质因子次数只能是 $1$。**

至于学者的独立和，直接用全部减去军人、政客的和。全部是多少呢？$\sum\limits_{x|m \text{ and } x \ne 1}\varphi(x)=m-1$，这串式子非常奇妙，~~是个定理，所以不给出证明~~。

## ACCode

```cpp
#include <cstdio>
using namespace std;

const int maxn = 1e3+5, mod = 1e4;
int f[maxn],g[maxn],p[maxn],e[maxn];

int pow(int x, int y) {
  int re = 1;
  while (y) {
    if (y & 1) re = re*x%mod;
    x = x*x%mod; y >>= 1;
  }
  return re;
}

int main() {
  int n; scanf("%d",&n);
  for (int i = 1; i <= n; i++) scanf("%d%d",p+i,e+i);
  int ttl = 1;
  for (int i = 1; i <= n; i++) {
    if (p[i] == 2) {
      f[i] = f[i-1];
      g[i] = g[i-1];
    } else {
      f[i] = (g[i-1]*(p[i]-1)+f[i-1]         )%mod;
      g[i] = (f[i-1]*(p[i]-1)+g[i-1]+(p[i]-1))%mod;
    }
    ttl = ttl*pow(p[i],e[i])%mod;
  }
  printf("%d\n%d\n%d",f[n]%mod,g[n]%mod,(ttl-f[n]-g[n]-1+mod+mod+mod)%mod);
  return 0;
}
```
## 闲话：关于大佬 @[lzy20091001](https://www.luogu.com.cn/user/932039) 的[问题](https://lglg.top/973002)

### 可能 1

对比以下代码片段：

```cpp
    else {
      f[i] = (g[i-1]*(p[i]-1)+f[i-1])%mod;
      g[i] = (f[i-1]*(p[i]-1)+g[i-1]+(p[i]-1))%mod;
    }
```
```cpp
  f[0]=1;
// 此处省略 ? 字节
    else {
      f[i] = (g[i-1]*(p[i]-1)+f[i-1])%mod;
      g[i] = (f[i-1]*(p[i]-1)+g[i-1])%mod;
    }
// 此处再次省略 ? 字节
  printf("%d%d%d",(f[0]-1+mod)%mod.g[0],(n-f[0]-g[0]));
```

DP 部分下面的可能更整齐。看个人喜好，反正我喜欢整整齐齐的。

### 可能 2

注意到 $0$ 也是偶数。最后再减掉这种情况也不会太麻烦。个人觉得这是最可能的情况。

---

## 作者：jiayixuan1205 (赞：0)

## 题解：P5746 [NOI2002] 机器人M号
### 题目中的一些关键点
-  第 $i$ 号机器人的独立数为 $\varphi(i)$，注意题目中要求 $1$ 号机器人的独立数为 $0$。
-  政客包含偶数个不同质因数。
-  军人包含奇数个不同质因数。
- 欧拉函数是积性函数，因此独立数也可以采用类似方式处理。
### 分析
可以看出，政客和军人相较于学者更好处理。所以我们可以在求出政客与军人的个数后，通过容斥原理求出学者的个数（需要注意这里总共的个数不是单纯的乘积，需要减去 $1$，因为 $1$ 号机器人不在讨论范围内。）

我们设 $dp(i,j)$ 表示选取的前 $i$ 个质因数中，当前不同质因数个数奇偶性为 $j$ 时（$j=0$ 时为偶数，$j=1$ 时为奇数）的独立数和。可以发现每次进行质因数的选取时都会改变当前奇偶性，因此我们可以推出状态转移方程：

$$dp(i,j)=dp(i-1,j \oplus1) \times \varphi(p_i) + dp(i-1,j)$$

方便处理的一点是，由于题目中已经帮我们进行好了质因数分解，根据 $\varphi(p)=p-1$（$p$ 为质数），我们就可以直接进行转移了。

### 注意事项
取模的时候注意避免负数出现的情况（我因为这个调了好久）。
### 代码展示
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int mod = 1e4;
const int N = 1010;
int dp[N][2];
int k;
int n=1;

inline int qpow(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1) res=(res*a)%mod;
        a=a*a%mod;
        b=b/2;
    }
    return res;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>k;
    int p,e;
    dp[0][0]=1;
    for(int i=1;i<=k;i++)
    {
        cin>>p>>e;
        n=n*qpow(p,e)%mod;
        for(int j=0;j<=1;j++)
        {
            dp[i][j]=(dp[i-1][j^1]*(p==2? 0:p-1)+dp[i-1][j]+mod)%mod;
        }
    }
    dp[k][0]=(dp[k][0]-1+mod)%mod;
    cout<<dp[k][0]<<endl<<dp[k][1]<<endl<<(n-dp[k][0]-dp[k][1]-1+mod*2)%mod<<endl;//神秘的取模处理
    return 0;
}
```

---

## 作者：little_cindy (赞：0)

## 思路
读完一遍题，我们可以发现：若机器人 $u$ 为机器人 $v$ 的老师，那么显然 $u|v$ 且 $u\not=1$。又从 $u\not=1$ 可以得到机器人 $u$ 的独立数为 $φ(u)$。

从题目中可以知道，政客和军人是由几个不同的的奇素数乘起来得到，直接用 dp 即可。

### 状态

$dp_{i,j}$ 为前 $i$ 个质数中，选奇数或偶数个质数的答案。其中 $j=0$ 时选偶数个，$j=1$ 时选奇数个。

### 转移方程

$dp_{i,j}=dp_{i-1,j⊕1}\timesφ(P_i)+dp_{i-1,j}$。

学者的独立数怎么求呢？

我们只需要用总的独立数减去上面求的政客和军人的独立数即可。

总的独立数又该怎么求？

显然，由于 $\sum_{d|n}φ(d)=n$，所以总的独立数必为 $m-1$。

## code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int __int128
template <typename T> inline void read(T& x) {
	x=0;T f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=x*f;
	return;
}
template <typename T,typename ...Arg>void read(T& x,Arg& ...arg){
	read(x);
	read(arg...);
}
template <typename T>inline void write(T x) {
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else write(x/10),putchar(x%10+'0');
}
const int mod=10000;
int n,tot,dp[1005][2];
int power(int x,int p) {
	int a=1;
	while(p){
		if(p%2){
			a=a*x%mod;
		}
		x=x*x%mod;
		p>>=1;
	}
	return a;
}
signed main() {
	read(n);
	tot=dp[0][0]=1;
	for(int i=1;i<=n;i++){
		int p,e;
		read(p,e);
		tot=tot*power(p,e)%mod;
		dp[i][1]=dp[i-1][1];
		dp[i][0]=dp[i-1][0];
		if(p!=2){
			dp[i][1]=((dp[i-1][0]*(p-1))%mod+dp[i][1])%mod;
			dp[i][0]=((dp[i-1][1]*(p-1))%mod+dp[i][0])%mod;
		}
	}
	dp[n][0]=(dp[n][0]-1+mod)%mod;
	write(dp[n][0]);putchar('\n');
	write(dp[n][1]);putchar('\n');
	write(((tot-dp[n][0]-dp[n][1]-1)%mod+mod)%mod);putchar('\n');
}
```

---

## 作者：panyf (赞：0)

数学性质+DP

首先，我们会发现，编号为x的机器人的老师即为编号为x的因数的机器人（不包括x和1），于是，若机器人y与x有共同老师，当且仅当x,y不互质，因此编号为x的机器人独立数即为φ(x)。

接下来，考虑求出政客和军人的独立数。政客和军人满足一个性质，即：编号x的所有质因数指数都为1。若奇素数y与x互质，则若x为政客，xy为军人；若x为军人，xy为政客。并且，xy的独立数为x的独立数乘y-1（求φ的公式）。因此可以考虑DP求政客和军人的独立数。

欧拉函数φ满足重要性质，即x的因数的欧拉函数之和等于x，因此只需快速幂求m的值，再减去政客和军人，再减1（编号为1的机器人不是其他机器人的老师），即可求出学者。

注意：n=1要特判！否则WA94分。

简洁的代码：
```cpp
#include<cstdio>
const int q=10000;
int p[1009],e[1009],f[1009],g[1009];
int qp(int a,int b){//快速幂
	int r=1;
	while(b){
		if(b&1)r=r*a%q;
		a=a*a%q,b>>=1;
	}
	return r;
}
int main(){
	register int n,i,s=1;
	scanf("%d",&n);
	for(i=1;i<=n;++i)scanf("%d%d",p+i,e+i);
	if(n==1){//特判！
		if(p[1]==2)printf("%d\n%d\n%d",0,0,qp(2,e[1]));
		else printf("%d\n%d\n%d",0,p[1]-1,(qp(p[1],e[1])-p[1]+q)%q);
		return 0;
	}
	if(p[1]==2)f[2]=0,g[2]=p[2]-1;else f[2]=(p[1]-1)*(p[2]-1)%q,g[2]=(p[1]+p[2]-2)%q;
	for(i=3;i<=n;++i)f[i]=(f[i-1]+g[i-1]*(p[i]-1))%q,g[i]=((f[i-1]+1)*(p[i]-1)+g[i-1])%q;//DP，f为政客，g为军人，求军人时要把编号p[i]的机器人加上
	for(i=1;i<=n;++i)s=s*qp(p[i],e[i])%q;//求出m
	printf("%d\n%d\n%d",f[n],g[n],(s+q+q-f[n]-g[n]-1)%q);
	return 0;
}
```


---


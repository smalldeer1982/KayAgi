# [NOI1999] 01串

## 题目描述

给定 $7$ 个整数 $N , A_0 , B_0 , L_0 , A_1 , B_1 , L_1 $，要求设计一个01串$ S=s_1 s_2 … s_i … s_N $，满足：
1.	$ s_i = 0 $ 或 $ s_i = 1 $， $ 1 \leq i \leq N $；
2.	对于 $S$ 的任何连续的长度为 $L_0$ 的子串 $s_j s_{j+1} … s_{j+L0-1}  $ ($1 \leq j \leq N-L_0+1 $) ， $0$ 的个数大于等于 $A_0$ 且小于等于 $B_0$ ;
3.	对于 $S$ 的任何连续的长度为 $L_1$ 的子串 $s_j s_{j+1} …  s_{j+L1-1} $ ($ 1 \leq  j  \leq N-L_1+1 $) ， $1$ 的个数大于等于 $A_1$ 且小于等于 $B_1$ ;

例如， $ N = 6 ,  A_0 = 1 ,  B_0 = 2  ,  L_0 = 3 ,  A_1 = 1 ,  B_1 = 1 ,  L_1 = 2 $，则存在一个满足上述所有条件的 $01$ 串 $ S = 010101 $ 。


## 样例 #1

### 输入

```
6 1 2 3 1 1 2
```

### 输出

```
3
```

# 题解

## 作者：Prean (赞：13)

天哪，我居然能当上这道题的第一个题解!

这道题其实就是说0的数量和1的数量。让我们用一下类型前缀和的思想，d[i]表示前i个字符的1的个数。则有：
```cpp
b1>=d[i]-d[i-l1]>=a1
l0-b0<=d[i]-d[i-l0]<=l0-a0//因为要多于那么多个0相当于少于那么多个1
```
于是我们就可以愉快地差分约束啦~

贴代码：
```cpp
#include<iostream>
#include<queue>
using namespace std;
int n,cnt,a0,a1,b0,b1,l0,l1,h[1005],d[1005],a[1005];bool f[1005];
class Edge{public:int to,nx,data;}e[4005];queue<int>q;
inline void Add(int x,int y,int z){e[++cnt]={y,h[x],z};h[x]=cnt;}
int main()
{
	int i;cin>>n>>a0>>b0>>l0>>a1>>b1>>l1;
	for(i=1;i<=n;i++)Add(i,i-1,0),Add(i-1,i,1);Add(n+1,0,0);
    for(i=l0;i<=n;i++)Add(i,i-l0,b0-l0),Add(i-l0,i,l0-a0);
    for(int i=l1;i<=n;i++)Add(i,i-l1,-a1),Add(i-l1,i,b1);
	q.push(0);f[0]=true;for(i=1;i<=n;++i)d[i]=0x7fffffff;
	while(!q.empty())
	{
		#define to e[i].to
		int x=q.front();q.pop();f[x]=false;
		for(i=h[x];i;i=e[i].nx)if(d[x]+e[i].data<d[to])
		{
			d[to]=d[x]+e[i].data;
			if(++a[to]==n){cout<<-1;return 0;} 
			if(!f[to])f[to]=true,q.push(to);
		}
	}cout<<d[n];
}
```

---

## 作者：wangjingjie2022 (赞：9)

~~我竟然能当上这道题的第二个题解，神奇~~


------------
我们先来读读题：

给定7个整数N,A0,B0,L0,A1,B1,L1，要求设计一个01串S=s1s2…si…sN，满足：
　　
  
  1.si=0或si=1，1<=i<=N；
　　
  
  2.对于S的任何连续的长度为L0的子串sjsj+1…sj+L0-1(1<=j<=N-L0+1)，0的个数大于等于A0且小于等于B0;
　　
  
  3.对于S的任何连续的长度为L1的子串sjsj+1…sj+L1-1(1<=j<=N-L1+1)，1的个数大于等于A1且小于等于B1。
  
  
  其实就是说在任意l0个数里，0的数量关系与任意l1个数里，1的数量关系。
  
那我们先想一想前缀和的思想，用d[i]表示前i个数中1的个数

然后我们就可以推导出下列公式
```cpp
l0-b0<=d[i]-d[i-l0]<=l0-a0//在l0-i里1的个数
a1<=d[i]-d[i-l1]<=b1//在l1-i里1的个数
```
我们便可以对其进行差分约束了

于是我们进行如下操作：
```cpp
	for(int i=1;i<=n;i++){
		addedge(i,i-1,0);
		addedge(i-1,i,1);
	}
	addedge(n+1,0,0);
	for(int i=l0;i<=n;i++){
		addedge(i,i-l0,-(l0-b0));
		addedge(i-l0,i,+(l0-a0));
	}
	for(int i=l1;i<=n;i++){
		addedge(i,i-l1,-(a1));
		addedge(i-l1,i,+(b1));
	}	
```
若还是不懂的，可以看代码注释
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int maxn=1005;
struct edge{//前向星 
	int to,next,data;
}a[maxn*4];//注意这里要开4倍大小的前向星数组，不然会RE
int h[maxn],vis[maxn],used[maxn],d[maxn];
int n,a0,b0,l0,a1,b1,l1;
int cnt;
void addedge(int x,int y,int z){//加边 
	a[++cnt].to=y;
	a[cnt].data=z;
	a[cnt].next=h[x];
	h[x]=cnt;
}
bool SPFA(){//SPFA不解释 
	memset(d,0x3f,sizeof(d));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(n+1);
	d[n+1]=0;
	while(!q.empty()){
		int x=q.front();
		vis[x]=0;
		q.pop();
		for(int i=h[x];i;i=a[i].next){
			int y=a[i].to;
			if(d[y]>d[x]+a[i].data){
				d[y]=d[x]+a[i].data;
				used[y]++;
				if(used[y]>=n)return 0;
				if(!vis[y]){
					q.push(y);
					vis[y]=1;
				}
			}
		}
	}
	for(int i=0;i<=n+1;i++)
		if(d[i]==0x3f3f3f3f)
			return 0;//这个一定要有，不然绝对会错 
	return 1;
}
int main(){
	cin>>n>>a0>>b0>>l0>>a1>>b1>>l1;
	for(int i=1;i<=n;i++){
		addedge(i,i-1,0);
		addedge(i-1,i,1);
	}
	addedge(n+1,0,0);//将超级源点对0进行连边，因为边权为0所以对最短路径没有影响 
	for(int i=l0;i<=n;i++){
		addedge(i,i-l0,-(l0-b0));
		addedge(i-l0,i,+(l0-a0));
	}
	for(int i=l1;i<=n;i++){
		addedge(i,i-l1,-(a1));
		addedge(i-l1,i,+(b1));
	}
	if(SPFA())cout<<d[n]-d[0];//1的个数
	else cout<<-1;
}
```


------------
~~管理员大大求给过~~

---

## 作者：Lan_yan (赞：6)

第一次写绿题题解。建议升蓝。

## 思考

一眼望去是差分约束。但怎么表示答案呢？

答案是构造一个只有零或一字符的字符串 $s$，**但是**构造一个前缀和数组使得 $a_i - a_{i-1} = s_i$，即 $s_1$ 至 $s_i$ 中有多少个 $1$。 注意 $a_0$ 必须有。

接着就是构造不等式建图了。

注意到题目的两点，根据我们的构造即可得出：

$a_{i+l0} - a_i \le l_0-a_0$；$a_{i} - a_{i+l0} \le b_0-l_0$。

$a_1$ 和 $b_1$ 同理。但是注意：$a_0$ 也包括在其中！

并且因为 $s$ 数组只有零或一，具有单调性，所以要记得 $a_{i-1}$ 与 $a_i$ 的不等式。

**而且**，必须要连超级源点 $a_{i+1}$ 和 $a_0$ 的边，不然会强行被干掉好几十分！

## 代码

这里只贴关键部分。vector 我的最爱。

```cpp
for(i=0;i<=n-l0;i++)
{
	way[i].push_back({i+l0,l0-a0});
	way[i+l0].push_back({i,b0-l0});
}
for(i=0;i<=n-l1;i++)
{
	way[i].push_back({i+l1,b1});
	way[i+l1].push_back({i,-1*a1});
}
for(i=1;i<=n;i++)
{
	way[i-1].push_back({i,1});
	way[i].push_back({i-1,0});
}
way[n+1].push_back({0,0});
```
完结撒花！

---

## 作者：Sham_Sleep (赞：4)



~~我竟然能当上这个题的第三个题解，神奇~~

~~bs霸榜~~

------------
算法：差分约束

设x[i]为前i个1的个数

设y[i]为前i个1的个数

那么由题可知，初步的不等式应该为

 a1<=x[i + l1] - x[i]<=b1
 
 a0<=y[i + l0] - y[i]<=b0
 
 这时候，我们就应该进行转化，将有关0的式子转换为有关1的式子（题目要求的是1的maxn）
 
 又因为一个区间的大小是确定的，所以就有了下面这个等式：
 
 l0 - b0<=x[i + l0] - x[i]<=l0 - a0
 
 所以这道题就大致解决了
 
 核心代码部分：
 ```
	for(int i = 0; i <= m - l0; ++i){
		mapp[i][i + l0] = min(l0 - a0 , mapp[i][i + l0]);
		mapp[i + l0][i] = min(b0 - l0 , mapp[i + l0][i]);
	}
	for(int i = 0; i <= m - l1; ++i){
		mapp[i][i + l1] = min(b1 , mapp[i][i + l1]);
		mapp[i + l1][i] = min(-a1 , mapp[i + l1][i]);
	}
```

 这样建图之后，跑的是最短路，因为我不等式最后化成的是以"<="结尾
 
 接下来就是前后两点的关系，很简单
 
 01串中只有两种状态，要么是”1“，要么是”0“
 
 所以，i+1 和 i 之前只相差1个字符
 
 那么转化为不等式应该是 x[i + 1] - x[i] <= 1
 
 而 i 转化到 i - 1 的情况就应该是 x[i] - x[i - 1] <= 0
 
 故此，此题结束
 
 AC代码
 ```
#include <stdio.h>
#include <iostream>
#include <queue>
using namespace std;

int m , a0 , b0 , l0 , a1 , b1 , l1 , t;
int h[2005];
int mapp[2005][2005];
int d[2005];
bool f[2005];
queue<int> dl;

int spfa()
{
	dl.push(0);
	while(!dl.empty())
	{
		t = dl.front(); f[t] = false; dl.pop();
		for(int i = 0; i <= m; ++i){
			if(mapp[t][i] != 0x7fffffff / 2)
			{	 
				if(d[i] > d[t] + mapp[t][i])
				{
					++h[i]; if(h[i] == m) return -1;
					d[i] = d[t] + mapp[t][i];
					if(!f[i]) { f[i] = true; dl.push(i); }
				}
			}
		}
	}
	return d[m];
}

int main()
{
	scanf("%d %d %d %d %d %d %d" , &m , &a0 , &b0 , &l0 , &a1 , &b1 , &l1);
	for(int i = 0; i <= m; ++i){
		for(int j = 0; j <= m; ++j){
			mapp[i][j] = 0x7fffffff / 2;
		}
	}
	for(int i = 1; i <= m; ++i){
		d[i] = 0x7fffffff / 2;
	}
	for(int i = 0; i <= m - l0; ++i){
		mapp[i][i + l0] = min(l0 - a0 , mapp[i][i + l0]);
		mapp[i + l0][i] = min(b0 - l0 , mapp[i + l0][i]);
	}
	for(int i = 0; i <= m - l1; ++i){
		mapp[i][i + l1] = min(b1 , mapp[i][i + l1]);
		mapp[i + l1][i] = min(-a1 , mapp[i + l1][i]);
	}
	for(int i = 1; i <= m; ++i){
		mapp[i - 1][i] = min(mapp[i - 1][i] , 1);
		mapp[i][i - 1] = min(mapp[i][i - 1] , 0);
	}
	printf("%d" , spfa());
}
```
小细节注意：如果有同学像我一样用的是邻接矩阵（~~代码简单一些~~），注意，当 l0 == 1 || l1 == 1时，会与i + 1和i以及 i , i - 1构造时发生重复构造，因为求的是最短路，所以构造时取min值

~~支持一下本蒟蒻吧QAQ~~

---

## 作者：tuxuanming2024 (赞：2)

~~did AK IOI~~

思路:这个题~~很显然~~是差分约束系统，只要列出亿些不等式，再建图跑一个spfa就可以了。

------------


分析：

设符合要求的01串为 $S$ ， **$ f_i $ 为 $ S $ 前 $ i $ 个元素中1的个数。（前缀和）**

根据题目我们可以列出这样的式子：

$$ f_0=0 $$

$$ f_i-f_{i-1} \leq 1 $$

$$ f_{i-1}-X_i \leq 0 $$


$$ f_i-f_{i+L0} \leq B0-L0 $$

$$ f_{i+L0}-f_i \leq L0-A0 $$

$$ f_i-f_{i+L1} \leq -A1 $$

$$ f_{i+L1}-f_i \leq B1 $$

注：

$L0-B0$ 表示 $i-L0$ 的范围内1的最少个数

$L0-A0$ 表示 $i-L0$ 的范围内1的最多个数


------------

然后就可以根据不等式建边，代码如下：
```cpp
for(int i=0;i<=n-L0;i++)
{
	int j=i+L0;
	Addedge(j,i,B0-L0);
	Addedge(i,j,L0-A0);
	j=i+L1;
	Addedge(j,i,-A1);
	Addedge(i,j,B1);
}
for(int i=0;i<=n;i++)
{
	Addedge(i-1,i,1);
	Addedge(i,i-1,0);
}
```
完整代码：
```cpp
#include <iostream>
#include <queue>
#define INF 0x7fffffff/2
using namespace std;
struct edge {int to,Next,v;}e[4005];
int d[1005],h[1005],f[1005],cnt,n,tot[1005],A0,B0,L0,A1,B1,L1,ans;
bool flag[1005];
void Addedge(int x,int y,int z)
{
	e[++cnt].to=y;
	e[cnt].v=z;
	e[cnt].Next=h[x];
	h[x]=cnt;
}
bool spfa(int s)
{
	queue<int>q;
	for(int i=1;i<=n;i++) d[i]=INF;
	d[s]=0; q.push(s);
	while(!q.empty())
	{
		int u=q.front(); q.pop();
		flag[u]=0;
		for(int i=h[u];i;i=e[i].Next)
		{
			int v=e[i].to;
			if(d[v]>d[u]+e[i].v)
			{
				d[v]=d[u]+e[i].v;
				if(!flag[v])
				{
					flag[v]=1;
					q.push(v);
					tot[v]++;
					if(tot[v]>=n) return 0;
				}
			}
		}
	}
	return 1;
}
int main()
{
	cin>>n>>A0>>B0>>L0>>A1>>B1>>L1;
	for(int i=0;i<=n-L0;i++)
	{
		int j=i+L0;
		Addedge(j,i,B0-L0);
		Addedge(i,j,L0-A0);
		j=i+L1;
		Addedge(j,i,-A1);
		Addedge(i,j,B1);
	}
	for(int i=0;i<=n;i++)
	{
		Addedge(i-1,i,1);
		Addedge(i,i-1,0);
	}
	if(spfa(0))
	{
		for(int i=1;i<=n;i++) if(d[i]>d[i-1]) ans++;
		cout<<ans;
	}
	else cout<<"-1";
	return 0;
}
```
EOF

---

## 作者：Acee (赞：2)

~~我竟然能当上这个题的第七个题解，神奇~~

看见区间和，就可以通过差分转为前缀和。

然后就将条件变为了一些不等式组，于是就是很明显的差分约束问题啦。

但是还有一点：

前缀和数组因改为递增的，所以还要 `addedge(i, i - 1, 0), addedge(i - 1, i, 1)`。

代码就不放了。

---

## 作者：FBW2010 (赞：1)

~~竟然还能写题解，赶快水一发。~~

# 思路

题目中给了每一段的范围，所以很容易想到差分约束。我们定义 $S_i$ 为 $01$ 串前 $i$ 个数中 $1$ 的和，不难得到以下关系式：
$$
\begin{cases}
S(i+L_0)-S_i \le L_0-A_0 & (0 \le i \le n-L0)\\
S_i-S(i+L_0) \le B_0-L_0 & (0 \le i \le n-L0)\\
S(i+L_1)-S_i \le B_1 & (0 \le i \le n-L1)\\
S_i-S(i+L_1) \le -A_1 & (0 \le i \le n-L1)\\
S_i-S(i-1) \le 1 & (1 \le i \le n)\\
S(i-1)-S_i \le 0 & (1 \le i \le n)
\end{cases}
$$
接着，我们只需要根据关系式建图，在从 $0$ 开始跑 SPFA 即可。其余部分详见代码。

# 代码

```cpp
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
int n,m,a0,b0,l0,a1,b1,l1,cnt;
int h[1005],dis[1005]/*存最短路*/,vis[1005]/*是否在队列中*/,num[1005]/*计数数组判负环*/;

// 前向星  
struct node{
	int next,to,v;
}a[100005];
void add(int x,int y,int v){
	a[++cnt].next=h[x];
	a[cnt].to=y;
	a[cnt].v=v;
	h[x]=cnt;
}

// SPFA 队列 
queue<int> q;

int main(){
	scanf("%d %d %d %d %d %d %d",&n,&a0,&b0,&l0,&a1,&b1,&l1);
	
	// 建图&初始化 
	for(int i=0;i<=n-l0;i++){
		add(i,i+l0,l0-a0);
		add(i+l0,i,b0-l0);
	}
	for(int i=0;i<=n-l1;i++){
		add(i,i+l1,b1);
		add(i+l1,i,-a1);
	}
	for(int i=1;i<=n;i++){
		add(i-1,i,1);
		add(i,i-1,0);
		dis[i]=2e9;
	}
	
	// SPFA法 
	q.push(0);//从0开始 
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0; 
		for(int i=h[x];i;i=a[i].next){
			int y=a[i].to;
			if(dis[x]+a[i].v<dis[y]){ //松弛操作 
				dis[y]=dis[x]+a[i].v;
				num[y]++; //计数 
				if(num[y]>n){ // 判负环 
					printf("-1"); //无解 
					return 0;
				}
				if(vis[y]==0){
					vis[y]=1; // 标记 
					q.push(y);
				}
			}
		}
	}
	
	printf("%d",dis[n]); // 输出1的个数 
	return 0;
}
```

---

## 作者：流水行船CCD (赞：1)


# 前言

其实这道题很像 [P1654](https://www.luogu.com.cn/problem/P1645) 的加强版，也是在几个区间内至少，至多有几个数，求最后区间最多，最少有几个数。

# 分析

P1654 可以通过贪心安排数字求解，但由于这道题增加了一个不大于 $B_{0/1}$ 和把数列变成了01串，因此用贪心求解并不方便；

因为题目中出现了多个**二维线性不等式**，考虑**差分约束**。

设 $S_i$ 表示第 $i$ 个位置之前有多少个 $1$，则有如下不等式：

$$\forall\ l \in [1,N-L_0+1] \quad L_0-B_0\le S_{l+L_0-1}-S_{l-1} \le L_0-A_0$$

$$\forall\ l \in [1,N-L_1+1] \quad A_1\le S_{l+L_1-1}-S_{l-1} \le B_1$$

现在将这两个不等式进行标准化，即把所有不等式进行移项，将其不等号方向统一。

$$\left\{\begin{matrix} 
    S_{l+L_0-1}-S_{l-1} \le L_0-A_0\\  
   S_{l-1}-S_{l+L_0-1} \le B_0-L_0\\
   S_{l+L_1-1}-S_{l-1} \le B_1 \\
   S_{l-1}-S_{l+L_1-1} \le -B_0
\end{matrix}\right. $$

但是不要忘了，由于 $S$ 数组的每一项项应当大于等于前一项，且最多只能为前一项 $+1$ 因此我们得自己构造一组不等式来保证它合法。

即：

$$\left\{\begin{matrix} 
    S_{i}-S_{i-1} \le 1\\ 
   S_{i-1}-S_{i} \le 0
\end{matrix}\right. $$

然后就可以跑差分约束版子了！

由于 $S$ 是前缀和数组，所以最后自然是输出 $S_n-S_0$ 啦。

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Code {
	#define mp(x,y) make_pair(x,y)
	const int maxn=2e3+7;
	int n,vis[maxn],lo[maxn],d[maxn];
	int input[3][4];
	vector<pair<int,int>> gr[maxn];
	int SPFA(int S){
		queue<int> q;
		memset(d,0x3f,sizeof(d));
		memset(vis,0,sizeof(vis));
		q.push(S);
		vis[S]=1;d[S]=0;lo[S]=0;
		while(!q.empty()){
			int u=q.front();q.pop();
			vis[u]=0;
			if(lo[u]>n){return 0;}
			for(int i=0;i<gr[u].size();i++){
				int v=gr[u][i].first,lg=gr[u][i].second;
				//cout<<u<<"=="<<lg<<"=>"<<v<<endl;
				if(d[v]>d[u]+lg){
					d[v]=d[u]+lg;
					lo[v]=lo[u]+1;
					if(!vis[v]){q.push(v);vis[v]=1;}
				}
			}
		}
		return 1;
	}
	signed main(){
		cin>>n;
		for(int i=1;i<=2;i++){
			for(int j=1;j<=3;j++){
				cin>>input[i][j];
			}
		}
		int ce=1;
		for(int l=1;l<=n-input[ce][3]+1;l++){
			int r=l+input[ce][3]-1;
			gr[l-1].push_back(mp(r,input[ce][3]-input[ce][1]));
			gr[r].push_back(mp(l-1,-1*(input[ce][3]-input[ce][2])));
		}
		ce=2;
		for(int l=1;l<=n-input[ce][3]+1;l++){
			int r=l+input[ce][3]-1;
			gr[l-1].push_back(mp(r,input[ce][2]));
			gr[r].push_back(mp(l-1,-1*input[ce][1]));
		}
		for(int i=1;i<=n;i++){
			gr[i-1].push_back(mp(i,1));
			gr[i].push_back(mp(i-1,0));
		}
		int flag=SPFA(0);
		if(!flag){cout<<-1<<endl;return 0;}
		cout<<d[n]-d[0]<<endl;
		return 0;
	}
}
signed main(){
	Code::main();
	return 0;
}
```

---

## 作者：x_miracle (赞：1)

**核心算法：差分约束，前缀和**

重点：如何**灵活构图**来应用差分约束算法。

------------

### 准备工作：

设$x_i$为字符串$S$的子串：$s_1...s_i$中$1$的个数。

（前缀和）

那么$x_i-x_{i-L}$所表达的含义即为：$S$的子串：$s_{i-L+1}...s_i$中$1$的个数。

（$L\leq i \leq n$）（$L$为子串长度，$n$为$S$的长度）

因为，$S$只由$0,1$组成，所以$l-\left(x_i-x_{i-L}\right)$ 即为：$S$的子串：$s_{i-L+1}...s_i$中$0$的个数。

### 差分约束：

我们将字符串的前缀和$x_i$当作图中的节点，利用差分约束，先求出一组可行解。

根据题意，我们可以得出：

$A_1 \leq x_i-x_{i-L_1} \leq B_1$

$A_0-L_0 \leq x_{i-L_0}-x_i \leq B_0-L_0$

至此，构图还没有结束。

因为，$S$是一个连续的序列，题目中有一个隐藏的关系：

$0 \leq x_i-x_{i-1} \leq 1$

（同时，因为该关系使图中存在了一个点，使其连通了其余各点，构造超级源点的工作也省去了。）

### 细节：

由于差分约束的多解性，为了使其满足可行解最大。

不妨设想，$x_1$可行解的最大值是1，所以，我们只要让$x_1=1$，那么，整体的值就最大。

同时，也因为，我们所求的是前缀和，存在单调性。$x_n \geq x_1$。

所以得到最后答案为：$x_n-x_1+1$。

（这里我不认为是单单减去$x_0$，虽然说，要求$x_0$最大只能是$0$，但是不能确保当$x_0=0$时，$x_1=1$。）

代码如下：
```cpp
#include <bits/stdc++.h>
#define MAXN 500000
#define INF 0x3f3f3f3f
using namespace std;
int adj[MAXN],cnt=0;
int n,a0,b0,l0,a1,b1,l1;
struct EDGE { int to,nxt,val; }	e[MAXN];
void addedge(int u,int v,int w) { e[++cnt].to=v; e[cnt].val=w; e[cnt].nxt=adj[u]; adj[u]=cnt; }
int dis[MAXN],vis[MAXN],num[MAXN];
queue < int > q;
bool SPFA()
{
	for(int i=1;i<=n;++i)	{dis[i]=INF;}
	dis[0]=0; vis[0]=1; ++num[0];	q.push(0);
	while(!q.empty())
	{
		int u=q.front();  q.pop();  vis[u]=0;
		for(int i=adj[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
            if(dis[v]>dis[u]+e[i].val)
			{
				dis[v]=dis[u]+e[i].val;
				if(!vis[v])
				{
                    ++num[v];	if(num[v]>=n) return 0;
                    q.push(v); vis[v]=1; 
				}
			}
		}
	}
	return 1;
}

int main()
{
	scanf("%d%d%d%d%d%d%d",&n,&a0,&b0,&l0,&a1,&b1,&l1);
	for(int i=1;i<=n;++i)
	{
        addedge(i,i-1,0);
        addedge(i-1,i,1);
    }
    for(int i=l0;i<=n;++i)
	{
        addedge(i,i-l0,b0-l0);
        addedge(i-l0,i,l0-a0);
    }
    for(int i=l1;i<=n;++i)
	{
        addedge(i,i-l1,-a1);
        addedge(i-l1,i,b1);
    }
    if(SPFA())	printf("%d",dis[n]-dis[1]+1);
    else	printf("-1");
	return 0;
}
```

---

## 作者：hzxphy (赞：0)

# 题解：P5751 [NOI1999] 01串
 ~~不容易呀，终于过了。~~
 ## 题目大意

给定 $7$ 个整数 $N , A_0 , B_0 , L_0 , A_1 , B_1 , L_1$，要求构造 01 串 $ S=s_1 s_2 \dots s_i \dots s_N$，满足：
1.	$s_i = 0$ 或 $s_i = 1$，$1 \leq i \leq N$；
2.	对于 $S$ 的任何连续的长度为 $L_0$ 的子串 $s_j s_{j+1} \dots s_{j+L0-1}$($1 \leq j \leq N-L_0+1$)，$0$ 的个数 $A_0\leq cnt_0 \leq B_0$；
3.	对于 $S$ 的任何连续的长度为 $L_1$ 的子串 $s_j s_{j+1} \dots  s_{j+L1-1}$($1 \leq  j  \leq N-L_1+1$) ，$1$ 的个数 $A_1\leq cnt_1 \leq B_1$。

## 分析

定义有 $i \in Z \cap [1,n]$。

记构造的 01 串 1 的前缀个数为 $x_i=\sum\limits_{j=1}^i(s_j=1)$。

### 基础条件（不论 $A_0,B_0,L_0,A_1,B_1,L_1$ 的大小）

由题知 $x_0=0$，$x_i-x_{i-1}\leq 1$，$x_i-x_{i-1}\geq 0\Rightarrow x_{i-1}-x_i\leq 0$。
### 关于条件一

$$x_{i+L_0}-x+i\geq L_0-B_0\Rightarrow x_i-x_{i+L_0}\leq B_0-L_0$$

$$x_{i+L_0}-x+i\leq L_0-A_0$$
### 关于条件二

$$x_{i+L_1}-x+i\geq A_1\Rightarrow x_i-x_{i+L_0}\leq -A_1$$

$$x_{i+L_1}-x+i\leq B_1$$


得到如上关系后，差分约束即可。
## Code（不可以抄）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e3+1;
vector<pair<int,int> >G[MAXN+1];
int cnt[MAXN+1],vis[MAXN+1];
long long dist[MAXN+1];
int n,a0,b0,l0,a1,b1,l1;
void SPFA(void){
	memset(dist,0x3f,sizeof dist);
	memset(vis,0,sizeof vis);
	queue<int>Q;
	Q.push(0);
	dist[0]=0;vis[0]=1;
	while(!Q.empty()){
		int F=Q.front();Q.pop();
		for(auto i:G[F]){
			int T=i.first,w=i.second;
			if(dist[T]>dist[F]+w){
				dist[T]=dist[F]+w;
				cnt[T]=cnt[F]+1;
				if(cnt[T]>=n){
					cout<<"-1\n";
					exit(0);
				}
				if(!vis[T]){
					vis[T]=1;
					Q.push(T);
				}
			}
		}
		vis[F]=false;
	}
	return;
}
int main(){
    scanf("%d%d%d%d%d%d%d",&n,&a0,&b0,&l0,&a1,&b1,&l1);
    for(int i=1;i<=n;i++){
        G[i].push_back(make_pair(i-1,0));
        G[i-1].push_back(make_pair(i,1));
        G[n+1].push_back(make_pair(0,0));
    }
    for(int i=l0;i<=n;i++){
        G[i].push_back(make_pair(i-l0,b0-l0));
        G[i-l0].push_back(make_pair(i,l0-a0));
    }
    for(int i=l1;i<=n;i++){
        G[i].push_back(make_pair(i-l1,-a1));
        G[i-l1].push_back(make_pair(i,b1));
    }
    SPFA();
    cout<<dist[n];
	return 0;
}
```

---

## 作者：__QWQ_qwq__ (赞：0)

## 题意
给定 7 个整数 $N , A_0 , B_0 , L_0 , A_1 , B_1 , L_1 $，要求设计一个 01 串$ S=s_1 s_2 … s_i … s_N $，满足：
1.	对于 $S$ 的任何连续的长度为 $L_0$ 的子串，$0$ 的个数大于等于 $A_0$ 且小于等于 $B_0$。
2. 对于 $S$ 的任何连续的长度为 $L_1$ 的子串，$1$ 的个数大于等于 $A_1$ 且小于等于 $B_1$。
## 分析
这道题用了**差分约束**算法。

为了建图，我们要构造一个前缀和数组 $x$，其中 $x_i$ 表示字符串中下标 $0 \sim i-1$ 中 1 的个数。

而 0 的个数可以通过总长减去 1 的个数得到，因此可以推出以下式子：

- $b_1 \ge x_i - x_{i - l1} \ge a_1$
- $l_0 - b_0 \le x_i - x_{i - l0} \le l_0 - a_0$
- $x_i - x_{i-1} \le 1$

之后就可以进行差分约束了。

## 核心代码

```cpp
for (int i = 1;i <= n;i ++)
{
		add (i , i-1 , 0);
		add (i-1 , i , 1);
}
add (n+1 , 0 , 0);//超级源点
for (int i = l0;i <= n;i ++)
{
		add (i , i-l0 , b0-l0);
		add (i-l0 , i , l0-a0);
}
for (int i = l1;i <= n;i ++)
{
		add(i , i-l1 , -a1);
		add(i-l1 , i , b1);
}//此段代码内 add 函数为建边
//这题其他部分套用差分约束模版即可
```

---


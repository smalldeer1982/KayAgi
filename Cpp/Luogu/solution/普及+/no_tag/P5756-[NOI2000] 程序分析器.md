# [NOI2000] 程序分析器

## 题目描述

Tiny Basm语言(简称为TB语言)的巴科斯-瑙尔范式(BNF)为：

![](https://cdn.luogu.com.cn/upload/image_hosting/37ipxplt.png)

错误语句示例(在输入文件中不会出现任何错误语句)：

- `10A+1.5`（不符合累加语句的定义，所加的不是整数）
- `20A?`（不符合输出语句的定义，多加了一个空格）
- `30IFA=BGO10`（不符合条件语句的定义，不应变量=变量）

$\\$

TB程序的执行：
-	程序从行号最小的一条语句开始执行，在未遇到条件语句时按行号由小至大顺序执行。
-	所有变量在程序执行前被自动初始化为 $0$。
-	累加语句将语句中变量的值加上语句中的整数送回该变量。
-	输出语句将语句中变量的值在监视器上显示出来。
-	执行条件语句时，当且仅当该语句中的变量与紧跟在等号后面的整数值相等，后面的转移语句才被执行。该语句中的所有整数值至多为 $4$ 位。
-	转移语句被执行后，程序将转去执行 $\tt GO$ 后面指定的行号的语句。
-	当程序执行结束语句后，结束整个程序的执行。
-	假设该系统能处理任意大小的整数，而不会发生溢出。


请编程，对于给定的 TB 语言程序 $P$，求该程序所执行的语句数（执行条件语句不论是否成功转移，仅记为执行一条语句）。

## 说明/提示

**样例说明**

执行语句行号按顺序为 $10→20→30→40→50→20→30→40→50→20→60$。

共 $11$ 条语句被执行。


## 样例 #1

### 输入

```
10 A+1
20 IF A=5 GO 60
60 END
30 A+2
40 A?
50 GO 20
```

### 输出

```
11
```

# 题解

## 作者：Loser_Syx (赞：19)

好水的紫题啊。。。

## 思路

看到题解区都是依次枚举的行数，而我的做法是将每行排序，然后从小到大遍历。

首先按照每一行的行号，将每个语句及行号排列，这样可以避免题解区里广泛说的“数据行号中有 $0$ 行”的问题。

既然排序了，那么我们的行号可以进行一个小小的改变，虽然叫的是几几行，但是我们完全可以按照之前排好的序来排啊，然后开一个桶记录每行所对应的是数组的第几个序号，当之后的 `GO` 语句访问时，直接访问桶中的数据好了。

读入行数时别忘吞空格。

接下来是对于每个语句的细节：

首先对于 `END` 操作直接输出没什么好说的。

当是 `GO` 语句时，发现里面的数字不是特别方便转字符，这时候我们可以用快读模板的方法一位一位来算，然后用得出的数字访问桶好了。

当是变量加法的语句时，我们发现我们还没有存当前的值，这时候我们要想怎么记录，不难想到 `map` 中是可以以 `char` 类型作为下标的，于是只要将 `map` 中的数加上所要加上的值即可。

当是 `IF` 语句时，只需判断变量对应的值是否相等，如果相等直接执行 `GO` 语句就行了。

如果当前顺序执行完，下标还是那个下标，直接自增 $1$。

注意判断超时的次数开到 $10^7$。

按这个思路，不难打出如下代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
#define int long long
#define f(W, X, Y, Z) for(int W = X; W <= Y; W += Z)
#define F(W, X, Y, Z) for(int W = X; W >= Y; W -= Z)
#define debug puts("QAQ")
namespace SyxQwQ{
	inline int qwq(){
		return 0;
	}
	struct _{
		string s;
		int line;
	}p[114];
	bool cmp(_ a, _ b){
		return a.line < b.line;
	}
	int checkline[3111];
	map<int, int> a;
	map<char, int> z;
	int doingtime = 0, nowline;
	inline int getnowz(int &i){
		//debug;
		int x = 0;
		while(p[nowline].s[i] > '9' || p[nowline].s[i] < '0') ++i;
		while(p[nowline].s[i] <= '9' && p[nowline].s[i] >= '0'){
			//cout << p[nowline].s[i];
			//x = (x << 3) + (x << 1) + (p[nowline].s[i] - '0');
			x = x * 10 + (p[nowline].s[i] - '0');
			++i;
		}
		//cout << x << " ";
		return x;
	}
	inline void func(){
		p[nowline].s += " ";
		int l = p[nowline].s.size();
		doingtime++;
		//cout << nowline << " ";
		if(doingtime > 10000000){
			printf("-1\n");
			exit(0);
		}
		//if(p[nowline].line == 50) cout << p[nowline].s.size() << '\n';
		for(int i = 0; i < l; i++){
			//debug;
			//if(p[nowline].line == 50) cout << p[nowline].s[i];
			
			if(p[nowline].s[i]=='E' && p[nowline].s[i+1]=='N' && p[nowline].s[i+2]=='D'){
				//debug;
				printf("%lld\n", doingtime);
				exit(0);
			}else if(p[nowline].s[i] == 'G' && p[nowline].s[i+1] == 'O'){
				//debug; 
				nowline = a[getnowz(i)];
				return ;
			}else if(p[nowline].s[i] == 'I' && p[nowline].s[i+1] == 'F'){
				//debug;
				i += 3;
				int sjh = z[p[nowline].s[i]];
				i += 2;
				int q = getnowz(i);
				//cout << q << '\n';
				if(sjh == q){
					nowline = a[getnowz(i)];
					return ; 
				}else{
					nowline++;
					return ;
				}
			}
			else if(p[nowline].s[i] >= 'A' && p[nowline].s[i] <= 'Z'){
				char sjh = p[nowline].s[i];
				//debug;
				++i;
				if(p[nowline].s[i] == '?') continue;
				else if(p[nowline].s[i] == '+'){
					int o = getnowz(i);
					z[sjh] += o;
					++i;
					//cout << z[o] << ' ';
				}
			}
		}
		//debug;
		++nowline;
		return ;
	}
	inline int main(){
		int len = 0;
		while(cin >> p[++len].line){
			getchar();
			getline(cin, p[len].s);
		}
		--len;
		sort(p + 1, p + 1 + len, cmp);
		f(j, 1, len, 1){
			a[p[j].line] = j;
			//cout << p[j].line << '\n';
		}
		nowline = 1;
		while(1) func();
		printf("%lld\n", doingtime);
		return qwq();
	}
}
signed main(){
	SyxQwQ::main();
	return 0;
}
```

但是交上去，发现 TLE 了 $3$ 个点，此时考虑优化。

可以发现，语句一共就只有 $100$ 句，如果要 TLE，其中肯定执行了许多次重复的语句，我们可以把所有的代码的要标记和执行的预先处理出来，当跳到那一行时，只需对应判断即可，这样可以省掉每次跳到那里循环一次的复杂度。

但是思考要处理哪些标记是真的烦。

我是这么搞标记的：

是否有 `END`；

是否是 `GO` 语句，如果是，跳转到哪一行；

是否有 `IF`，判断的是哪个变量，判断的是改变量对应的哪个值，如果成立要 `GO` 到哪一行；

是否是变量增加，加的是哪个变量，加的是几。

于是就有了这份代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
#define int long long
#define f(W, X, Y, Z) for(int W = X; W <= Y; W += Z)
#define F(W, X, Y, Z) for(int W = X; W >= Y; W -= Z)
#define debug puts("QAQ")
namespace SyxQwQ{
	inline int qwq(){
		return 0;
	}
	struct _{
		string s;
		int line;
		bool willend, willgo, willif, willplus;
		int gotowhere, ifvalue, ifgoto, plusvalue;
		char ifchar, pluschar;
		
	}p[114];
	bool cmp(_ a, _ b){
		return a.line < b.line;
	}
	map<int, int> a;
	map<char, int> z;
	int doingtime = 0, nowline;
	inline int getnowz(int &i){
		//debug;
		int x = 0;
		while(p[nowline].s[i] > '9' || p[nowline].s[i] < '0') ++i;
		while(p[nowline].s[i] <= '9' && p[nowline].s[i] >= '0'){
			x = x * 10 + (p[nowline].s[i] - '0');
			++i;
		}
		//cout << x << " ";
		return x;
	}
	inline void func(){
		p[nowline].s += " ";//不加会RE
		int l = p[nowline].s.size();
		for(int i = 0; i < l; i++){
			if(p[nowline].s[i]=='E' && p[nowline].s[i+1]=='N' && p[nowline].s[i+2]=='D'){
				//printf("1\n");
				p[nowline].willend = 1;
				return ;
			}else if(p[nowline].s[i] == 'G' && p[nowline].s[i+1] == 'O'){
				//printf("2\n");
				p[nowline].willgo = 1;
				p[nowline].gotowhere = getnowz(i);
				return ;
			}else if(p[nowline].s[i] == 'I' && p[nowline].s[i+1] == 'F'){
				//printf("3\n");
				p[nowline].willif = 1;
				i += 3;
				p[nowline].ifchar = p[nowline].s[i];
				i += 2;
				p[nowline].ifvalue = getnowz(i);
				p[nowline].ifgoto = getnowz(i);
				return ; 
			}
			else if(p[nowline].s[i] >= 'A' && p[nowline].s[i] <= 'Z'){
				//printf("4\n");
				p[nowline].pluschar = p[nowline].s[i];
				++i;
				if(p[nowline].s[i] == '?') continue;
				else if(p[nowline].s[i] == '+'){
					p[nowline].willplus = 1;
					p[nowline].plusvalue = getnowz(i);
					++i;
				}
			}
		}
		return ;
	}
	inline void check(){
		doingtime++;
		if(doingtime > 5000000){
			printf("-1\n");
			exit(0);
		}
		if(p[nowline].willend){
			printf("%lld\n", doingtime);
			exit(0);
		}else if(p[nowline].willplus){
			z[p[nowline].pluschar] += p[nowline].plusvalue;
		}else if(p[nowline].willgo){
			//debug;
			nowline = a[p[nowline].gotowhere];
			return ;
		}else if(p[nowline].willif){
			//if('A' == p[nowline].ifchar) printf("%lld\n", p[nowline].ifgoto);
			if(z[p[nowline].ifchar] == p[nowline].ifvalue){
				nowline = a[p[nowline].ifgoto];
				return ;
			}
		}
		nowline++;
	}
	inline int main(){
		int len = 0;
		while(cin >> p[++len].line){
			//if(p[len].line == 2800) debug;
			getchar();
			getline(cin, p[len].s);
		}
		--len;
		sort(p + 1, p + 1 + len, cmp);
		f(j, 1, len, 1){
			a[p[j].line] = j;
			nowline = j;
			//if(p[j].line == 2800) debug;
			func();
		}
		nowline = 1;
		while(1){
			//printf("%lld\n", z['A']);
			check();
			//printf("%lld\n", nowline);
		}
		//printf("%lld\n", doingtime);
		return qwq();
	}
}
signed main(){
	//freopen("QAQ.out", "w", stdout);
	SyxQwQ::main();
	//fclose(stdout);
	return 0;
}
```

别说跑的真挺快的，目前最优解。

3KB 也不长。

---

## 作者：紫钦 (赞：10)

题目链接：[P5756 [NOI2000]程序分析器](https://www.luogu.com.cn/problem/P5756)。

# 题目大意

给定一种编程语言（Tiny Basm语言，简称为TB语言），并给出语法规则。输入一段合法代码，含 $n$ 条语句，求程序所执行的语句数。若程序无法正常结束，则输出 ```-1``` 。

数据规模：$n\leqslant100$，每一条语句的长度不超过 $20$ 个字符，行号不超过 $3000$，行号最大的语句一定是结束语句，但结束语句不一定只有一条，转移语句后面的行号保证存在。

# 解法：模拟

## 能不能计算呢？

先分析一下，能不能用某些数学方法计算出答案。

这样做比较麻烦，因为该语言转移语句的特殊性，代码中的循环会有相交之处。**循环不是嵌套的**，故我们用数学方法计算会十分困难。

## 为什么可以模拟呢？

分析一下复杂度就知道能不能模拟了。

首先，该语言有三个很有用的性质：

1. 变量只有 $26$ 种（$A$ 到 $Z$）。

2. 条件语句中的值最多四位，即值的范围为 $0\sim9999$ 。

3. 该语言只有加法，没有减法。

考虑将 $26$ 个变量的值视为状态，则变量的值随执行语句数增多而单调不降（因为只有加法）。

很明显该语言能结束的循环语句是由条件语句（IF）和转移语句（GO）组合起来构成的，

而循环如果能够终止，则必然终止于某条条件语句。

现在假设程序能正常结束。

我们来看一下，最多能执行多少语句。

若代码中没有循环语句，则最多执行 $100$ 条语句。

显而易见的，有循环结构的代码会执行相对更多的语句数。于是来研究循环。

那么假设某个条件语句被执行了两次，则这意味着该条件语句在循环中。不妨再假设该条件语句就是将要使得循环终止的条件语句，那么，**$26$ 个变量的值在该条件语句的相邻两次执行中，必然不全相等**。否则，循环不会在该条件语句处结束。

这意味着，循环执行的最多次数，不大于变量所有取值的状态数。

$26$ 个变量的整体状态总共有 $26\times10000$ 种，暂且认为循环体的语句共有 $100$ 条，则程序最多执行 $2.6\times10^7$ 条语句。

这样的复杂度是可以接受的，于是我们采用模拟算法。

## 具体过程

+ 把所有语句读入后，按照行号从小到大排序。
  
  怎么排序呢？
  
  ~~桶排！~~ 其实还是冒泡比较香。

+ 然后确定语句的类型，并按照类型记录一些有用的信息，比如转移语句会转移到多少行，累加语句累加的变量是哪个等等。

+ 按照语法规则运行代码，维护好变量的值即可。

+ 注意判断死循环。

# 注意事项

+ 如何判死循环?
  
  IF中两种死循环：一种是变量不变，一种是变量虽增长，但不会恰好等于特判值。 
  
  前者的判断，有种想法是记录 IF 时所判断的变量的值，下次执行 IF 时判断该变量的值是否改变，未改变则 TLE()。
  
  然而很显然这种想法是错的。 
  
  比如：
  
  ```cpp
  10 IF A=3 GO 50
  20 A+1
  30 IF B=1 GO 50
  40 GO 10
  50 END
  ```
  
  改进一下：可以在执行到某个 IF 时记录下当前所有变量的值，到下次执行到该 IF 时再判断变量值是否有变化。这样判断出的死循环一定是准确的，但这么做依然判不尽所有死循环情况。
  
  于是第一种情况的判断我找不到更完美的方法了。
  
  关于后者的判断，我想不到优美的做法。如果有优美的判断方法，可能这题就可以不用模拟做了。 
  
  另外 GO 语句本身可以死循环，判断起来也比较费事，需要讨论两次 GO 中间是否有可以跳出循环的 IF 。 
  
  所以还是直接给答案设个阈值吧，省时省力简明易懂。。。 
  
  显然阈值不是很大，极限状态粗略估计在一千万左右。不知道估得准不准。

+ 本题的官方数据有一些锅，不过前九个点是没问题的。
  
  关于第十个点：
  
  + ~~不知道它现在死没死。~~
  
  + 如果它现在还是原来的测试数据并对您产生了困扰的话，请移步本题讨论区[最早的一篇帖子](https://www.luogu.com.cn/discuss/show/194568)，它也许能帮助到您。
  
  本篇代码中有一些看起来是正确的部分但是被我注释掉了，这么做只是为了能过第 $10$ 个测试点。

+ 本篇代码是用 C 语言写的，和 C++ 有一些区别，但。
  
  话说这还是我第一次用 C 语言在洛谷上写题。
  
+ 本篇代码的码风比较神奇……
  
  不过应该比较容易看懂……
  
+ 时间复杂度 $O(\min\{\text{答案},\text{阈值}\})$ 。
  
  此处认为程序不能正常结束时，答案为正无穷。

# $AC$ 代码

[评测记录](https://www.luogu.com.cn/record/31032856)。

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAX_LINE 105	/* 最大行数。 */
#define MAX_LENGTH 25	/* 语句最大长度。 */
#define MAX_LINE_LABEL 3005	/* 最大行标。 */
#define VALUE_NUM 30	/* 变量数量。 */
int rank[MAX_LINE_LABEL];
struct Sentence {
	int line,type,to,var,val;
	/*
	type=1:累加语句。 var:累加的变量下标。 val:累加的整数值。 
	type=2:输出语句。 var:输出的变量下标。 
	type=3:转移语句。 to:转移到的行数（已离散化）。
	type=4:条件语句。 to:转移到的行数（已离散化）。 var:判断的变量下标。 val:判断的整数值。 
	type=5:结束语句。 
	*/
	char content[MAX_LENGTH];
}s[MAX_LINE];
#define T struct Sentence	/* 只是因为我懒。。。 */
T construct(){
	return (T){0,0,0,0,0,""};
}
void swap(T *a,T *b) {T c=*a;*a=*b;*b=c;}
int cmp(const T a,const T b) {return a.line<b.line;}
void bubble_sort(T *const be,T *const en,int (*const cmp)(const T,const T))	/*按行号排序。*/
{
	int len=en-be;
	for(T *i=en-1;i>=be;--i) 
		for(T *j=be;j!=i;++j) 
			if(!(*cmp)(*j,*(j+1))) swap(j,j+1); 
	for(int i=1;i<=len;++i) rank[s[i].line]=i;
}
#undef T
void CE()	/*加个参数还能告诉我们哪一行 CE了。*/ /*其实题目根本不需要判 CE。。。*/
{
	printf("Compile Error!");
	exit(0);
}
#define is_correct_char(ch) (('0'<=(ch)&&(ch)<='9')||('A'<=(ch)&&(ch)<='Z')||((ch)=='=')||((ch)=='+')||((ch)==' ')||((ch)=='\r')||((ch)=='\n')||((ch)=='?'))
#define is_digit(ch) ('0'<=(ch)&&(ch)<='9')
#define is_letter(ch) ('A'<=(ch)&&(ch)<='Z')
#define is_space(ch) ((ch)==' ')
#define is_add(ch) ((ch)=='+')
#define is_equal(ch) ((ch)=='=')
#define is_query(ch) ((ch)=='?')
#define is_return(ch) ((ch)=='\r')
#define is_newline(ch) ((ch)=='\n')
int is_integer(char *const be,char *const en)
{
	if(be==en) return 0; 
	for(char *i=be;i!=en;++i)
		if(!is_digit(*i)) return 0;
	return 1;
}
int char_to_int(char *const be,char *const en)
{
	int x=0;
	for(char *i=be;i!=en;++i) x=(x*10)+(*i-'0');
	return x;
}
int init()
{
	int l=0,len,used[MAX_LINE_LABEL]={0};
	char ch;
	while((ch=getchar())!=EOF) {
		if(is_digit(ch)) {	/*读入行号。*/
			s[++l]=construct();
			while(is_digit(ch)) s[l].line=(s[l].line*10)+(ch-'0'),ch=getchar();
			/*if(used[s[l].line]) CE();*/	/*行号重复。*/
			/*else used[s[l].line]=1;*/
		}
		else CE();
		if(!is_space(ch)) CE();	/*行号后面应该是个空格。*/
		len=0;
		while((ch=getchar())!=EOF && !is_newline(ch)) 
			if(is_correct_char(ch)) {if(!is_return(ch)) s[l].content[++len]=ch;}
			else CE();	/*非法字符。*/
		s[l].content[++len]='\0';
	}
	return l;
}
#define T struct Sentence	/* 懒 +1。 */
/* 判断 + 初始化。 */
/* 其实写成对于一段字符串的判断更好一些，函数功能能更简化，比较优美。不过好在语句嵌套较少，直接按类型判断也可以。 */ 
int is_type1(T *const id)	/* A+233 */
{
	id->var=id->val=id->to=0;
	char *l=id->content+1,*r;
	if(is_letter(*l)) id->var=*l-'A';
	else return 0;
	if(++l,!is_add(*l)) return 0;
	for(r=++l;*r;++r);
	if(is_integer(l,r)) id->val=char_to_int(l,r);
	else return 0;	/* 其实已经 CE了。 */
	return 1;
}
int is_type2(T *const id)	/* A? */
{
	id->var=id->val=id->to=0;
	char *l=id->content+1;
	if(is_letter(*l)) id->var=*l-'A';
	else return 0;
	if(++l,!is_query(*l)) return 0;
	if(++l,*l!='\0') return 0;
	return 1;
}
int is_type3(T *const id)	/* GO 233 */
{
	id->var=id->val=id->to=0;
	char *l=id->content+1,*r;
	if(*l!='G' || *(++l)!='O' || *(++l)!=' ') return 0;
	for(r=++l;*r;++r);
	if(is_integer(l,r)) {
		int x=char_to_int(l,r);
		if(0<=x && x<=MAX_LINE_LABEL/* && rank[x]*/) id->to=rank[x];
		else return 0;	/* 其实已经 CE了。 */
	}
	else return 0;
	return 1;
} 
int is_type4(T *const id) /* IF A=233 GO 233 */
{
	id->var=id->val=id->to=0;
	char *l=id->content+1,*r;
	if(*l!='I' || *(++l)!='F' || *(++l)!=' ') return 0;
	if(++l,is_letter(*l)) id->var=*l-'A';
	else return 0;
	if(++l,!is_equal(*l)) return 0;
	for(r=++l;*r && !is_space(*r);++r);
	if(is_integer(l,r)) id->val=char_to_int(l,r);
	else return 0;
	l=r+1;
	if(*l!='G' || *(++l)!='O' || *(++l)!=' ') return 0;	/*由于没有函数可以调用，所以只能复制上一个函数了。。。*/
	for(r=++l;*r;++r);
	if(is_integer(l,r)) {
		int x=char_to_int(l,r);
		if(0<=x && x<=MAX_LINE_LABEL/* && rank[x]*/) id->to=rank[x];
		else return 0;	/* 其实已经 CE了。 */
	}
	else return 0;
	return 1;
}
int is_type5(T *const id)	/* END */ 
{
	id->var=id->val=id->to=0;
	char *l=id->content+1;
	if(*l!='E' || *(++l)!='N' || *(++l)!='D' || *(++l)!='\0') return 0;
	return 1;
}
void get_type(T *const be,T *const en)
{
	for(T *i=be;i!=en;++i) 
		if(is_type1(i)) i->type=1;
		else if(is_type2(i)) i->type=2;
		else if(is_type3(i)) i->type=3;
		else if(is_type4(i)) i->type=4;
		else if(is_type5(i)) i->type=5;
		/*else CE();*/
}
#undef T
#undef is_correct_char
#undef is_digit
#undef is_letter
#undef is_space
#undef is_add
#undef is_equal
#undef is_query
#undef is_return
#undef is_newline
void RE()
{
	printf("Runtime Error!");
	exit(0);
}
/* 
两种死循环：一种是变量不变，一种是变量虽增长，但不会恰好等于特判值。 
前者的判断，有种想法是记录 IF 时所判断的变量的值，下次执行 IF 时判断该变量的值是否改变，未改变则 TLE()。 
然而很显然这种想法是错的。 
改进一下：可以在执行到某个 IF 时记录下当前所有变量的值，到下次执行到该 IF 时再判断变量值是否有变化。但这么做依然判不尽所有 TLE() 的情况。
所以还是直接给答案设个阈值吧，省时省力简明易懂。。。 
*/
void TLE()
{
	printf("-1");
	exit(0);
}
void run()
{
	int val[VALUE_NUM]={0};	/* val[]用来记录变量当前的值。 */
	int now=1,ans=1; 
	struct Sentence cur=s[now];
	while(cur.type!=5) {	/* type=5: END */
		//printf("%d:%d %s\n",ans,cur.line,cur.content+1);
		switch(cur.type) {
			case 1:	/* A+233 */
				val[cur.var]+=cur.val;
				++now;
				break;
			case 2: /* A? */
				//printf("%d\n",val[cur.var]);
				++now;
				break;
			case 3: /* GO 233 */ 
				now=cur.to;
				break;
			case 4:	/* IF A=233 GO 233 */ 
				if(val[cur.var]==cur.val) now=cur.to;
				else ++now;
				break;
			default: /* 发生了一些愉快的事情。 */
				printf("%d\n",ans);
				printf("%d %s\n",cur.line,cur.content+1);
				RE();
		} 
		cur=s[now];
		++ans;
		if(ans>=10000000) TLE(); 
	}
	printf("%d",ans);
}
void print(struct Sentence x)	/* 用来检测自己的 type 有没有算对。 */
{
	printf("%d %s\ntype=%d var=%d val=%d to=%d\n",x.line,x.content+1,x.type,x.var,x.val,x.to);
}
#undef MAX_LINE
#undef MAX_LENGTH
#undef MAX_LINE_LABEL
#undef VALUE_NUM
int main()
{
	int len;
	len=init();
	if(len) 
	bubble_sort(s+1,s+len+1,cmp);
	get_type(s+1,s+len+1);
	run();
	return 0;
} 
```

---

## 作者：IANYEYZ (赞：4)

### 写在前面
好题。

写 + 调 1~2h 左右，码力还是差了。

### 前置芝士
```string.find```

```string.substr```

不会的话可以上网搜。

### 说明
本题解不会解释全部代码，会省略一些不是主要说明点的函数/结构体：

1、check(a,b) 效果为判断 b 是否为 a 的前缀。

2、strtoll(x) 效果为将字符串 x 转换为 long long 类型。

3、stm 结构体，其内有整形变量 ind，以及字符串变量 a。（效果显然）

### 正文
首先先全部读入进来，这里不赘述，直接扔代码：

```while(cin>>s[++cnt].ind)getline(cin,s[cnt].a);```

然后排序，并且把里面的标号处理成 1~n 连续的状态（直接开个 map 保存从原标号到新标号的映射，即代码中的 mp2）。

然后处理前置空格（其实只有一个，但是保险起见）与行末换行/回车。

接下来就来到了重点：解析代码。

我考虑的实现方式为维护一个变量 j，即当前运行的语句。

然后写一个 run 函数，使其运行语句且返回下一个要运行的语句（这样好处理 GO，但是也可以直接写循环，看个人喜好）。

输出变量（不需要真的输出）与 END 语句十分好处理，不多赘述；

对于变量增加，我们考虑直接开一个 map 保存变量名到值的映射（代码中的 mp）。然后遇到语句时直接找出变量以及该加的值，对于大于 4 位数的变量，我们直接不去管。

对于 GO 语句，直接处理即可（讲不清楚，可以看代码）。

对于 IF 语句，我们考虑分拆成三部分：

1、关键字（IF)

2、判断（A=1)

3、跳转语句（GO 10）

关键字无所谓，跳转语句就直接处理，判断语句就以 = 号为分界线，找出变量与整数，判断即可。

判 -1 的话，开个阈值，具体见代码。

### 代码

```cpp
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
struct stm{
	int ind;
	string a;
	bool operator<(stm o){return ind < o.ind;}
}s[100010];
int cnt,cnt1;
map<string,long long> mp;
map<int,int> mp2;
bool check(string a,string b)
{
	for(int i = 0;i < b.size();i++)
	{
		if(a[i] != b[i])return false;
	}
	return true;
}
long long strtoll(string x)
{
	long long ret = 0;
	for(int i = 0;i < x.size();i++)
	{
		ret*=10ll;
		ret+=x[i]-'0';
	}
	return ret;
}
int run(int x)
{
	//cout<<x<<" "<<s[x].a<<" "<<s[x].a[s[x].a.size()-1]<<endl;
	++cnt1;
	if(s[x].a == "END")
	{
		cout<<cnt1<<endl;
		exit(0);
	}
	else if(s[x].a[s[x].a.size()-1] == '?')
	{
		return x+1;
	}
	else if(s[x].a.find("+") != string::npos)
	{
		string te1 = s[x].a.substr(0,s[x].a.find("+")),te2 = s[x].a.substr(s[x].a.find("+")+1,s[x].a.size()-s[x].a.find("+"));
		mp[te1]+=strtoll(te2);
		if(mp[te1] > 10000)mp[te1] = 10000;
		return x+1;
	}
	else if(check(s[x].a,"GO"))
	{
		int flag1 = 3;
		while(!isdigit(s[x].a[flag1]))flag1++;
		return mp2[int(strtoll(s[x].a.substr(flag1,s[x].a.size()-flag1+1)))];
	}
	else if(check(s[x].a,"IF"))
	{
		string te1,te2;
		int flag1 = 3;
		while(s[x].a[flag1] != '=')te1+=s[x].a[flag1],flag1++;
		flag1+=1;
		while(s[x].a[flag1] != ' ')te2+=s[x].a[flag1],flag1++;
		//cout<<te1<<" "<<te2<<endl;
		if(mp[te1] != strtoll(te2))
		{
			return x+1;
		}
		else
		{
			te1 = s[x].a.substr(flag1+1,s[x].a.size()-flag1);
			flag1 = 3;
			while(!isdigit(te1[flag1]))flag1++;
			return mp2[int(strtoll(te1.substr(flag1,te1.size()-flag1+1)))];
		}
	}
}
int main()
{
	while(cin>>s[++cnt].ind)getline(cin,s[cnt].a);
	cnt--;
	sort(s+1,s+cnt+1);
	/*for(int i = 1;i <= cnt;i++)
	{
		cout<<s[i].ind<<" "<<s[i].a<<endl;
	}*/
	for(int i = 1;i <= cnt;i++)
	{
		int flag1 = 0,flag2 = s[i].a.size()-1;
		while(s[i].a[flag1] == ' ')flag1++;
        while(s[i].a[flag2] == '\n'||s[i].a[flag2] == '\r')flag2--;
		s[i].a = s[i].a.substr(flag1,flag2-flag1+1);
	}
	for(int i = 1;i <= cnt;i++)
	{
		mp2[s[i].ind] = i;
	}
	int j = 1;
	while(cnt1 <= 5000000)j = run(j);
	cout<<-1<<endl;
}
```


---

## 作者：Yharimium (赞：2)

题目链接：[P5756](https://www.luogu.com.cn/problem/P5756)

此题较水，AC 之后可以去看看 [P4911 河童重工的计算机](https://www.luogu.com.cn/problem/P4911)

## 零、审题

题目需要求的是「**程序所执行的语句数**」，而不是「**程序的运行结果**」。

## 一、单行语句的解析

「语句体」分为「行号」和「语句」两部分，可以分开输入。

「语句」共五类：

|类型|枚举值|格式|特征|
|:-|:-|:-|:-|
|累加语句|`AC=1`|`%c+%d`|第二个字符是 `+`|
|输出语句|`PRINT=2`|`%c?`|第二个字符是 `?`|
|转移语句|`GO=3`|`GO %d`|第一个字符是 `G`|
|条件语句|`GOIF=4`|`IF %c=%d GO %d`|第一个字符是 `I`|
|结束语句|`END=5`|`END`|第一个字符是 `E`|

利用 `sscanf` 函数（可以将字符串作为 `scanf` 的读入数据），将语句的处理程序包装成 `struct program`。

``` cpp
struct program {
	enum program_type {
		AC = 1,
		PRINT,
		GO,
		GOIF,
		END
	};
	
	string line;
	program_type type;
	
	char var;
	int param_1, param_2;
	
	program() { // 构造函数，初始化
		next_line_num = 3001;
	}
	
	void readline() {
		getchar(); // 读掉多余空格
		getline(cin, line);
		
		auto c_str = line.c_str();
		
		if (line[1] == '+') {
			sscanf(c_str, "%c+%d", &var, &param_1);
			type = AC;
		}
		else if (line[1] == '?') {
			sscanf(c_str, "%c?", &var);
			type = PRINT;
		}
		else if (line[0] == 'G') {
			sscanf(c_str, "GO %d", &param_1);
			type = GO;
		}
		else if (line[0] == 'I') {
			sscanf(c_str, "IF %c=%d GO %d", &var, &param_1, &param_2);
			type = GOIF;
		}
		else if (line[0] == 'E')
			type = END;
	}
};
```

## 二、行号的处理

「语句体」的「行号」既不连续，又不递增，所以这里使用 `vector<int> line_num` 存储所有「行号」，之后再排序。

``` cpp
int main() {
	int i;
	while (cin >> i) {
		programs[i].readline();
		line_num.push_back(i);
	}
	
	sort(line_num.begin(), line_num.end());

	...
}
```

给 `struct program` 增加成员 `next_line_num`，表示当前「语句体」的下一个「语句体」的行号。

``` cpp
struct program {
	...

	int next_line_num;

	...
};
```

在 `main()` 中继续处理每个「语句体」的 `next_line_num`。

``` cpp
int main() {
	...

	int n = line_num.size();
	
	for (int i = 1; i < n; i ++) {
		programs[line_num[i - 1]].next_line_num = line_num[i];
	}

	...
}
```
## 三、程序的运行

用一个 `map` 记录变量的值。

``` cpp
unordered_map<char, int> var_map;
```

容易写出单个「语句体」的执行程序。

``` cpp
struct program {
	...

	void exec(int& line_number, int& counter) {
		// line_number: 当前的行号
		// counter: 当前已执行的语句数
		if (type == AC) {
			var_map[var] += param_1;
			line_number = next_line_num;
		}
		else if (type == PRINT) {
			// printf("%d", var_map[var]); // 不需要输出
			line_number = next_line_num;
		}
		else if (type == GO) {
			line_number = param_1;
		}
		else if (type == GOIF) {
			if (var_map[var] == param_1)
				line_number = param_2;
			else
				line_number = next_line_num;
		}
		else if (type == END) {
			line_number = -1; // 标记为 -1 表示程序正常结束
		}
		
		counter ++;
	}
}
```

从第一个「语句体」开始，迭代地执行过去。

``` cpp
int main() {
	...

	i = line_num[0];
	int counter = 0;
	
	while (true) {
		programs[i].exec(i, counter);
		if (i == -1) {
			cout << counter << endl;
			return 0;
		}
		if (counter > 1e7) // 迭代次数过多，异常
			break;
	}
	
	cout << -1 << endl;
	
	return 0;
}
```

## 代码

``` cpp
#include <bits/stdc++.h>

using namespace std;

unordered_map<char, int> var_map;

struct program {
	enum program_type {
		AC = 1,
		PRINT,
		GO,
		GOIF,
		END
	};
	
	string line;
	program_type type;
	int next_line_num;
	
	char var;
	int param_1, param_2;
	
	program() {
		next_line_num = 3001;
	}
	
	void readline() {
		getchar();
		getline(cin, line);
		
		auto c_str = line.c_str();
		
		if (line[1] == '+') {
			sscanf(c_str, "%c+%d", &var, &param_1);
			type = AC;
		}
		else if (line[1] == '?') {
			sscanf(c_str, "%c?", &var);
			type = PRINT;
		}
		else if (line[0] == 'G') {
			sscanf(c_str, "GO %d", &param_1);
			type = GO;
		}
		else if (line[0] == 'I') {
			sscanf(c_str, "IF %c=%d GO %d", &var, &param_1, &param_2);
			type = GOIF;
		}
		else if (line[0] == 'E')
			type = END;
	}
	
	void exec(int& line_number, int& counter) {
		if (type == AC) {
			var_map[var] += param_1;
			line_number = next_line_num;
		}
		else if (type == PRINT) {
			// printf("%d", var_map[var]); // 不需要输出
			line_number = next_line_num;
		}
		else if (type == GO) {
			line_number = param_1;
		}
		else if (type == GOIF) {
			if (var_map[var] == param_1)
				line_number = param_2;
			else
				line_number = next_line_num;
		}
		else if (type == END) {
			line_number = -1;
		}
		
		counter ++;
	}
};

unordered_map<int, program> programs;
vector<int> line_num;

int main() {
	
	int i;
	while (cin >> i) {
		programs[i].readline();
		line_num.push_back(i);
	}
	
	sort(line_num.begin(), line_num.end());
	
	int n = line_num.size();
	
	for (int i = 1; i < n; i ++) {
		programs[line_num[i - 1]].next_line_num = line_num[i];
	}
	
	i = line_num[0];
	int counter = 0;
	
	while (true) {
		programs[i].exec(i, counter);
		if (i == -1) {
			cout << counter << endl;
			return 0;
		}
		if (counter > 1e7) // 迭代次数过多，异常
			break;
	}
	
	cout << -1 << endl;
	
	return 0;
}
```

---

## 作者：QWQ_SenLin (赞：2)

这题其实并不难，模拟即可通过，难点在于这个模拟比较复杂。

这种大模拟，我建议是：把一些功能写在函数里，这样看起来会整洁一点，Debug 时也会轻松一点。

## 一些准备
### 读入
这里注意题目并没有说明输入共有几行，所以就需要用 `~scanf()` 等判断是否读完了所有的内容。

```cpp
string s[3005]; //行号为i的语句为s[i]
int ans , now; //now为当前执行到的行号
int variable[1005];

bool readline(){ //返回值为是否读完
    string qwq;
    char c;
    int h;
    if(!(~scanf("%d" , &h))) //没读到 h，说明读完了。
        return false;
    c = getchar();
    while(c == ' ')
        c = getchar();
    while(c != '\n' && c != '\r' && c != EOF){
        qwq += c;
        c = getchar();
    }
	s[h] = qwq;
    while(s[h].back() == ' ')
        s[h].pop_back(); //去多余的空格，好像不加也没影响
    if(c == EOF) //读完
        return false;
    return true;
}
```

对于主程序，只需要循环使用这个读入函数 `readline()`，当它的返回值为 `false` 时，就退出循环即可。

### 字符串转数字
这个不难，相信大家都来做这个难度的题了，应该都写的出来。

遍历字符串的每一位，与 `0` 的 ASCII 码值作差得出这个字符的数值，然后放到整形变量里即可。

```cpp
inline int str_to_int(string qwq){
    int ret = 0;
    for(char c = 0;c < qwq.size();c++)
        ret = ret * 10 + (qwq[c] - '0');
    return ret;
}
```

### 下一条语句
由于我们在读入时把每个语句放到了它的行号这个位置，所以假如我们从 $0$ 这个位置开始取，把这些语句顺序取出，发现他们就已经按照行号排序了。其实有点像计数排序。

我们要求下一跳语句，只需要从当前行号开始继续遍历存放每个语句的 $s$ 数组，直到遍历到一个行号上有语句的，则将当前行号设置为它，退出循环。

```cpp
int next(int start){ //下一条语句
    for(int i = start + 1;i <= 3000;i++)
        if(s[i].size() >= 1)
            return i;
    return -1;
}
```

## 功能实现
题面看似很复杂，实际上只用实现三个功能：

1. 转移语句 `GO a`：转移到行号为 $a$ 的地方。
2. 累加语句 `a+b`：将 $a$ 加上 $b$。
3. 条件语句 `IF a=b GO c`：当且仅当 $a=b$ 时，执行后面的转移语句。

在这题中，输出语句完全没用，因为题目求的压根和输出语句没关系，因此我们可以选择忽略它。
### 转移语句 GO
首先我们这里令 `GO` 语句的字符串为 $s$，我们只要分离出 $s$ 中包含的参数行号 $a$，然后将当前执行到的行号赋值为这个参数行号 $a$ 即可。

PS：c++ 的 `string` 分割可以用 `substr` 函数，查找某个字符串可以用 `find` 函数。

```cpp
void GO(string qwq){
    qwq = qwq.substr(qwq.find(" ") + 1);
    now = str_to_int(qwq);
}
```

### 累加语句 +
和前文的转移语句实现思路类似，先取出累加语句的两个参数 $a,b$，然后对应到 `variable` 中，加进去即可。
```cpp
void ADD(string qwq){
    char c = qwq[0];
    variable[c] += str_to_int(qwq.substr(2));
}
```

### 条件语句 IF
一样，取出参数 $a,b$，判断是否相等，相等则取出后半部分，传给 `GO` 函数执行，即可。

```cpp
bool IF(string qwq){
    qwq = qwq.substr(3);
    string a = qwq.substr(0 , qwq.find(" "));
    string b = qwq.substr(qwq.find(" ") + 1);
    if(variable[a[0]] == str_to_int(a.substr(2))){
        GO(b);
        return true; //判断成立
    }
    return false;
}
```

需要注意的是，如果判断成立了，就不能马上执行「下一条语句」函数。对应的主程序代码：

```cpp
if(s[now].find("IF") != string::npos)
    if(IF(s[now]))
        continue; //不使用下面的「下一条语句」函数
```

## 最后
这题还是算简单的，大家可以尝试下比较复杂的大模拟：[P2482](https://www.luogu.com.cn/problem/P2482)。

完整代码：[code](https://www.luogu.com.cn/paste/1p4jaxno)。

---

## 作者：Milthm (赞：2)

## P5756 题解

### 前置知识

- （大）模拟

### 题目解法

本题除了模拟不需要任何算法，那问题就是怎么模拟更简单。接下来将分步来解决本题。

#### 一、读入

读入用 `getline` 读入字符串就可以了。读入好了用一个 `map` 存着，接着一行一行的扫，如果这行没有代码就跳过，否则执行这行代码。


#### 二、执行单行代码

首先发现这种模拟里面有很多需要多次实现的东西，这种东西我们写个函数就好了。首先发现会有很多字符串转数字的情况，所以写一个函数：

```cpp
int toint(string s){//字符串转数字
    int l=s.size(),ans=0;
    for(int i=0;i<l;++i){
        ans=ans*10+s[i]-'0';//快读思想
    }
    return ans;
}
```

然后还有很多时候，需要你截取下一个字符串，相当于从一个点开始，一直截取知道截取到空格或换行。所以就有了这个函数：

```cpp
string cut(int pos,string s){//从 pos 开始，截取到空格或换行结束
    for(int i=pos;;++i){
        if(s[i]==' '||s[i]=='\r'){//千万要注意！这里要检测到 \r ，而不是 \n！！！！
            lins=i;//结束位置的下标更新，后面有用
            return s.substr(pos,i-pos);//返回这个字符串
        }
    }
}
```

然后接下来就比较好实现了。

首先是变量自增（代码解释在注释里）：

```cpp
if(iz(s[i])&&s[i+1]=='+'){//如果是一个字母加上一个加号的情况
    int k=toint(cut(i+2,s));//取得加的数字
    ty[s[i]]+=k;//ty 是一个 map，存的是每个变量的值。
} 
```

接下来是 `GO` 语句：

```cpp
else if(s[i]=='G'&&s[i+1]=='O'){
   int k=toint(cut(i+3,s));//取得 GO 到哪一行
   H=k;//这里的 H 是执行单行代码大行数的参数，代表执行行数，因为定义的时候是 void zhixing(int &H)，所以改变 H 就相当于改变了主函数里循环执行的行数（如果还看不懂可以看完整代码里）
   f=0;//记得标记，如果这行没有打标记那么就接着向下执行。
}
```

接下来是 `IF` 语句：

```cpp
else if(s[i]=='I'&&s[i+1]=='F'){
    int k=ty[s[i+3]],qwq=toint(cut(i+5,s));//k 是变量值，qwq 是等号后面那个数
    if(k==qwq){//如果相等
        int syx=toint(cut(lins+4,s));//这里和 GO 代码一样，lins 的作用在这里（取得数后面的空格在哪）
        H=syx;f=0;//标记，作用同上
    }
    return;
}
```

然后 `END` 语句不用说了（是人都会写），输出语句写了也不会造成改变，只要把答案加一就可以了。

#### 三、判断错误

最后这个执行次数不可能太大，所以只要找一个很大的数，如果某次答案比这个数都大了，那么是不能结束此程序的。这里我取的大数值为 $5919810$，大家也可以取更小或者更大一点的值。

具体一些细节看 AC 代码。

### AC 代码

```cpp
#include<iostream>
#include<map>
using namespace std;
map<int,string>code;
int H,ans,lins,zzy;
bool f;
bool iz(char c){
	return (c>='A'&&c<='Z');
}
int toint(string s){
	int l=s.size(),ans=0;
	for(int i=0;i<l;++i){
		ans=ans*10+s[i]-'0';
	}
	return ans;
}
string cut(int pos,string s){
	for(int i=pos;;++i){
		if(s[i]==' '||s[i]=='\r'||s[i]=='\0'||s[i]=='\n'){
			lins=i;
			return s.substr(pos,i-pos);
		}
	}
}
map<char,int>ty;
void zhixing(int &H){
	//cout<<H<<"->";
	++ans;
	if(ans>5919810){//不能正常结束
		cout<<-1;exit(0);
	}
	string s=code[H];
	int l=s.size();
    s+="  ";
	for(int i=0;i<l;++i){
		if(iz(s[i])&&s[i+1]=='+'){//三种情况，上面都有说明了，在此不进行说明
			int k=toint(cut(i+2,s));
            //cout<<cut(i+2,s)<<" "<<3<<endl;
			ty[s[i]]+=k;
		} 
		else if(s[i]=='G'&&s[i+1]=='O'){
			int k=toint(cut(i+3,s));
			H=k;
			f=0;
		}
		else if(s[i]=='I'&&s[i+1]=='F'){
			int k=ty[s[i+3]],qwq=toint(cut(i+5,s));
			if(k==qwq){
				int syx=toint(cut(lins+4,s));
				H=syx;f=0;
			}
			
			return;
		}
		else if(s[i]=='E'&&s[i+1]=='N'&&s[i+2]=='D'){//END 的情况，输出答案即可。
			cout<<ans;
			exit(0);
		}
	}
}
int main(){
	for(int i=1;i<=3000;++i)code[i]="";//初始化代码
	for(char i='A';i<='Z';++i)ty[i]=0;//初始化变量值
	while(cin>>H){
		getchar();//注意数字后面有个空格，可以用 getchar 消掉
		getline(cin,code[H]);//输入
	} 
	for(int i=0;i<=3000;){//枚举行数，注意本题中有 0 行这种玩意
		if(code[i]==""){//如果这行没有代码
			++i;continue;
		}
		f=1;
		zhixing(i);//否则执行这行代码
		if(f)++i;//如果没有 GO 到其它行，那么执行下一行
	}
	return 0;
} 
```








---

## 作者：yanbinmu (赞：1)

## 思路

对于语句的判定我们可以发现对于结束语句、转移语句和判断语句，如果我们输入一个字符串，那么输入进来的将是 END、GO 和 IF，这个较好判断。

对于剩下的两种，如果最后一个字符是？那么就是输出语句。

发现语句要记录的操作不多，那我们使用结构体储存语句，并且按行操作。

### 实现

变量可以通过 map 维护，对于累加语句和判断语句，我们可以使用 string 类型的 substr 方法取得其数字部分，并用 stoi 函数将其转换为 int 类型。

我们记录一个从小到大的行号，同时我们用一个二分查找下一行是哪个就可以避免暴力跳行的复杂度上开花了。

对于死循环的判定，我们可以使用信仰优化，执行次数超过 $3 \times 10^8$ 时就直接输出不可行。

#### 证明

如果操作次数超过 $3 \times 10^8$，正常的代码常数大点就跑不过去了，所以如果卡常那么要死一块死，否则你就对了（doge）。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;

#define int long long

map<char, int> var;

int idx = 3000;

struct TB {
	int type;
	/*
	1. 累加
	2. 输出
	3. 转移
	4. 条件
	5. 结束 
	*/
	char var;
	// IF
	int num, where; // if var == num   Go where
	// GO
	int line; // Go line 
	// add
	int add; // var += add 

}code[6005];

signed main() {
	int n;
//	cin >> n;
//	// del
	vector<int> Q;
	while(true) {
		int line;
		if(scanf("%lld", &line) == EOF) break;
		n ++ ;
		string s;
		cin >> s;
		/*
		对于条件语句，转移语句和结束语句，第一个读入的都会是标识符。
		其他的我们可以通过部分字符来判定。 
		*/ 
		int n = s.size();
		if(s == "END") {
			code[line].type = 5;
		}
		else if(s == "IF") {
			code[line].type = 4;
			getchar();;
			code[line].var = getchar();
			getchar();
			cin >> code[line].num;
			string t;
			cin >> t;
			cin >> code[line].where;
		}
		else if(s == "GO") {
			code[line].type = 3;
			cin >> code[line].line;
		}
		else if(s[n - 1] == '?') {
			code[line].type = 2;
		}
		else {
			code[line].type = 1;
			code[line].var = s[0];
			code[line].add = stoi(s.substr(2)); 
			// substr 取得字符串子串，两个参数，第二个默认为 n，即取到最后 
			// stoi 将 string 转为 int 
		}
		Q.push_back(line);
	}
	sort(Q.begin(), Q.end());
	int pos = Q[0];
	int cnt = 0;
	while(cnt < 3e8) { // 模拟 
		cnt ++ ;
		if(code[pos].type == 1) {
			var[code[pos].var] += code[pos].add;
		}
		if(code[pos].type == 3) {
			pos = code[pos].line;
			continue;
		}
		if(code[pos].type == 4) {
			if(var[code[pos].var] == code[pos].num) {
				pos = code[pos].where;
				continue;
			}
		}
		if(code[pos].type == 5) {
			cout << cnt;
			return 0;
		}
		int x = lower_bound(Q.begin(), Q.end(), pos) - Q.begin();
		if(x == n - 1) {
			cout << -1;
			return 0;
		}
		pos = Q[x + 1];
	}
	cout << -1;
	return 0;
}
```

---

## 作者：Steve_xh (赞：1)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P5756)

**题目大意：** 模拟一种特定语言的一个程序，要求输出最多执行行数。详见题面。（注意无需执行输出语句！）

# 思路

既然是模拟程序，~~那就模拟就可以了~~。注意到有且仅有 $26$ 个变量，开数组存即可。读入先 `cin` 掉行号，再 `getline` 掉语句体。注意这里读语句体会读到空格，不过不用处理，直接当成下标从 $1$ 开始即可。下面是一些注意事项：

1. 行号可以不用离散化，不过离散化也没问题。
2. 如果你的常数较大，请勿用 `clock()` 卡时限判 $-1$。
3. 判死循环的最高次数开到 $7\times10^6$ 左右即可。
4. 字符串读数字的方法优秀程度个人认为 `sscanf` $>$ `stringstream` $>$ 类似快读方法。
5. 考虑到执行次数过多，而且有嵌套，可以另开一个执行一行命令的函数。不要递归，会 `MLE`。考虑到行数固定，因此可以直接返回该行执行完后下一个要执行命令的行号。
6. 如果你用数组链接行与行的命令，切记 `IF` 执行后不要修改数组的值。最好的方法是让执行函数返回下一个行号，主函数记录并执行。
7. 输出语句当没看到直接跳过即可。
8. 详见代码。

# 代码

```cpp
#include<bits/stdc++.h>
#define pass
using namespace std;
#define int long long
string c[3005];//语句体
int st=2147483647/*最小的行号，即开始的地方*/,ans=0/*answer*/,vars[26]/*变量*/,nxt[30005];//下一个行号
inline void end_program(int t){//方便起见，结束程序单独做了个函数
	cout<<t;
	exit(0);
}
inline int atoi(string x,int beg){//用快读方法字符串里读数字
	int reans=0;
	for(int i=beg;i<x.size()&&'0'<=x[i]&&x[i]<='9';++i)
		reans=(reans<<1)+(reans<<3)+(x[i]^48);
	return reans;
}
int run(int now){//执行函数
	if(++ans>=6890000)//死循环了
		end_program(-1);
	if(c[now][c[now].size()-1]=='?')//输出语句跳过
		pass;
	else if(c[now]==" END")//结束
		end_program(ans);
	else if(c[now][1]=='G'&&c[now][2]=='O')//跳转对应语句
		return nxt[now]=atoi(c[now],4);//注意这里因为每次到 GO 都会跳到行号所以直接改nxt
	else if(c[now][1]=='I'&&c[now][2]=='F'){//条件语句
		int tl1,tl2;char v;
		sscanf(c[now].c_str()," IF %c=%lld GO %lld",&v,&tl1,&tl2);
		if(vars[v-'A']==tl1)
			return tl2;//这里因为下一次来这个if不一定也要跳转，所以不修改nxt
	}
	else//累加
		vars[c[now][1]-'A']+=atoi(c[now],3);
	return nxt[now];
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false),cout.tie(nullptr);
//	freopen("P5756_10.in","r",stdin);
	for(int t;cin>>t;)
		getline(cin,c[t]),st=min(st,t);
	for(int i=3000,lst=0;~i;i--)//初始化每个语句的下一个行号
		if(c[i]!="")
			nxt[i]=lst,lst=i;
//	sort(c+1,c+lines+1);
	for(int last=st;;)
		last=run(last);//记录并执行命令
	end_program(ans);
	return 0;
}
/*

10 A+1
20 IF A=5 GO 60
60 END
30 A+2
40 A?
50 GO 20

*/ 
```

---

## 作者：0xyz (赞：1)

感觉这一题大部分人的实现方式都太麻烦了，这里提供一个 591b 的实现。

首先我们输入，可以先输入行号，然后行号后面的东西用 `getline` 处理。

接下来我们预处理出行号上每一行的后继。

我们从行号最小的行开始，依据当前行的除了行号之外的第 $3$ 个字符进行分类讨论，并跳转到下一行。

对于死循环，设置一个阈值即可，我这里用的是 $10^7$。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s[3005];
int h[3005],t[99],r,w,x,i=3e3;
inline int g(int x,int y){//处理出从 s[x][y] 开始的最靠左的整数的值
	int u=0;
	while(s[x][y]<48||s[x][y]>57)y++;
	while(y<s[x].size()&&s[x][y]>47&&s[x][y]<58)u=u*10+s[x][y]-48,y++;
	return u;
}
int main(){
	while(cin>>w)getline(cin,s[w]);//输入
	for(;~i;i--)
		if(s[i]!="")h[i]=x,x=i;//处理出 i 的下一行
	while(1){
		if(++r>=1e7)puts("-1"),exit(0);//运行次数太多，死循环
		if(s[x][2]=='N')cout<<r<<'\n',exit(0);//结束语句
		if(s[x][2]=='+')t[s[x][1]]+=g(x,3),x=h[x];//累加语句
		else if(s[x][2]=='O')x=g(x,4);//转移语句
		else if(s[x][2]=='F'&&t[s[x][4]]==g(x,6))x=g(x,11);//条件语句
		//注意到其条件中的整数必定开始于 s[x][6]，最多结束于 s[x][9]
		//其中转移语句中的整数至少开始于 s[x][11]
		else x=h[x];//其他情况
	}
}
```

---

## 作者：zhouyixian (赞：1)

算是程序解释器的入门题了。

~~不知道为什么能评到黑。~~

这里提供一个函数指针的做法，处理这方面问题应该算是比较简洁的吧。

总体流程为读入，编译，运行（废话）。

由于行号不连续，我们读入时顺便做一个桶排，再预处理出一个 $nxt$ 数组表示下一句的位置。（由于题上没说行号相同怎么处理，我们只好不管这种情况）

```cpp
void Read(){
	int line_num;
	while(cin>>line_num)
		getline(cin,str[line_num]),str[line_num].push_back('$'),
		vis[line_num]=1;
	//往语句结尾塞了个$表示结束。
	memset(nxt,-1,sizeof(nxt));
	for(int i=2999;~i;--i)
		if(vis[i+1])nxt[i]=i+1;
		else nxt[i]=nxt[i+1];
	Line=vis[0]?0:nxt[0];
}
```

下面先讲运行。

定义 $Line$ 为行号寄存器，$val$ 为大小为 $26$ 个整数的内存。

题上给了五种语句，我们先写出他们各自的函数，都非常简单（返回值为下次跳转的行号）。

```cpp
//这里 arg 为编译时确定的参数。
int EXIT(int *arg){exit(printf("%d",cnt)&0);return 0;}
int ADD(int *arg){val[arg[0]]+=arg[1];return nxt[Line];}
int PRINT(int *arg){/*no op*/return nxt[Line];}
//注意 print 不需要真的打印出来。
int JUMP(int *arg){return arg[0];}
int JUMP_IF(int *arg){return val[arg[0]]==arg[1]?arg[2]:nxt[Line];}
```

然后定义一个结构体存储每条语句对应的参数和函数。

```cpp
struct _code{
	int arg[3];
	function<int(int*)> func;
	_code(){}
	_code(function<int(int*)> f,int x=0,int y=0,int z=0){arg[0]=x,arg[1]=y,arg[2]=z,func=f;}
	void execute(){
		cnt++;
//		cout<<"EXECUTE:"<<Line<<endl;
		if(cnt>LIMIT)THROW_ERR();//先无视掉这句。
		Line=func(arg);
	}
}code[N];
```
那么执行就非常简单了，直接循环即可。

```cpp
void Execute(){
	while(1)code[Line].execute();
}
```

然后说编译。

先从语句开头分离出一个字母串，据此判断语句类型，然后严格按照题目给的标准分离出参数即可。

对照代码应该不难理解。

```cpp
void Compile(){
	for(int i=Line;~i;i=nxt[i]){
		int it=0;
//		cout<<"Compile:"<<i<<endl;
		string s=get_word(it,str[i]);
		if(s=="END")code[i].func=EXIT;
		else if(s=="GO")code[i]=_code(JUMP,get_int(it,str[i]));
		else if(s=="IF"){
			s=get_word(it,str[i]);++it;
			int a1=s[0]-'A',a2=get_int(it,str[i]);
			s=get_word(it,str[i]);
			code[i]=_code(JUMP_IF,a1,a2,get_int(it,str[i]));
		}else{
			char c=str[i][it++];
//			cout<<"get:"<<c<<endl;
			if(c=='?')code[i]=_code(PRINT);
			else if(c=='+')code[i]=_code(ADD,s[0]-'A',get_int(it,str[i]));
		}
	}
}
//省去了 get_int 和 get_word 的实现。
//其作用分别为从字符串中读取数值和单词。
```

我是直接通过判断总执行次数判断死循环的，阈值开到 $1e7$ 即可，超过直接结束程序输出负一（就是之前那个 THROW_ERR ）。

然后这题不到一百行就完了。

应该算不上码农题吧。

---

## 作者：Jorisy (赞：1)

模拟即可。

首先，输入中的行号和语句体必定是要分离的。考虑用 $c_i$ 表示第 $i$ 小行号，$id_i$ 表示行号 $i$ 离散化后的编号，这样顺序和行号便可以随意切换。然后我们就可以用 $p_{c_i}$ 存语句体。
```cpp
while(getline(cin,s))
{
	int x=s.find(' ');
	c[++n]=stoi(s.substr(0,x));
	p[c[n]]=s.substr(x+1);
}
sort(c+1,c+n+1);
for(int i=1;i<=n;i++) id[c[i]]=i;
```
接着我们用 $h$ 表示模拟程序运行时当前所在行号，$ans$ 表示程序运行语句数。

容易想到，当 $ans$ 过大时，便是死循环。

这里认为 $ans$ 过大是指 $ans>5\times 10^6$。

$h$ 每次模拟完一个语句后，变为 $c_{id_h+1}$（这应该很好理解）。
```cpp
h=c[1];
while(1)
{
	s=p[h];
	if(ans>(int)5e6)
	{
		puts("-1");
		break;
	}
	ans++;
	//...
	h=c[id[h]+1];
}
```
接下来就是语句。

令 $s=p_h$。

考虑用函数存每一种语句。

当然，结束语句就直接输出结束即可。
```cpp
if(s[1]=='+') add();
else if(s[1]=='?') out();
else if(s[0]=='I')
{
	jud();
	if(f) continue;//符合条件时便跳转行号，无需在最后再次改变行号
}
else if(s[0]=='G')
{
	got();
	continue;
}
else
{
	cout<<ans;
	break;
}
```
首先是累加语句。

我们可以用 $var_i$ 来存 $i$ 的值。
```cpp
void add(){var[s[0]]+=stoi(s.substr(2));}
```
输出语句，事实上我们什么都不用干。
```cpp
void out(){}
```
转移语句，直接改 $h$ 的值即可。
```cpp
void got(){h=stoi(s.substr(3));}
```
条件语句，模拟一下，然后如果符合条件，便执行转移语句。
```cpp
void jud()
{
	f=0;
	int x=s.find(' ',3);
	if(var[s[3]]==stoi(s.substr(5,x-5)))
	{
		s=s.substr(x+1);
		f=1;
		got();
	}
}
```
于是这道题就做完了。

完整代码就不放了。

---

## 作者：makerlife (赞：0)

调了好长时间，发现有个点读错题了，码力还是差。

## Solution

由于这是模拟题，这篇题解不会面面俱到覆盖到程序的每个点，仅会说一下大致模拟流程和注意的几个点。

首先由于程序是按行号顺序执行的，所以读入后先按行号排序。

这里会注意到行号可能不是等差的，所以需要对行号进行映射，使用 `map` 将行号和其离散化的值对应起来。

然后即可进行模拟，先通过 `check_type` 函数判断语句类型，需要用到的函数是 `string::find()`。其中 `IF` 语句需要注意一下，由于其分为多个部分，需要仔细判断每个部分的起始和终止位置，变量名恒为一个字符，但其值可以为多个字符。

还有一个点是，可以在不能正常解析串的时候返回调试信息并且直接结束程序，调试过程中可以更快的定位问题。

判断死循环直接设置一个阈值，若语句执行次数超过此阈值，则判定为死循环即可。阈值可以设置为使程序正好运行 $900 \text{ms}$ 左右。

## Code

```cpp
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<vector>
#include<cstdio>
#include<string>
#include<iomanip>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define INF 0x3f3f3f3f
#define eps 1e-8
#define ll long long
#define ull unsigned long long
#define el putchar('\n')
#define sp putchar(' ')
#ifndef ONLINE_JUDGE
#  define bug(x) cerr<<"[Debug] "<<__LINE__<<":"<<#x<<"="<<(x)<<endl
#  define del cerr<<endl
#else
#  define bug(x)
#  define del
#endif
using namespace std;
int read() {
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return;
}
const int N = 3010;
map<string, int> var;
map<int, int> mp;
struct _ {
    int num;
    string s;
    bool operator < (const _ &a) {
        return num < a.num;
    }
}line[N];
int n;
int p;
struct sentence {
    int type;
    string v;
    int integer; // also line num in GO()
    int nxt; // only IF()
    sentence(int _type, string _v, int _integer) { // +()
        type = _type, v = _v, integer = _integer;
    }
    sentence(int _type, string _v) { // ?()
        type = _type, v = _v;
    }
    sentence(int _type, int _integer) { // GO()
        type = _type, integer = _integer;
    }
    sentence(int _type, string _v, int _integer, int _nxt) { // IF()
        type = _type, v = _v, integer = _integer, nxt = _nxt;
    }
    sentence(int _type) { // END()
        type = _type;
    }
};
sentence check_type(string s) {
    if (s.find("+") != string::npos) {
        return sentence(1, (string)to_string(s[1]), (int)(s[3] - '0'));
    } else if (s.find("?") != string::npos) {
        return sentence(2, (string)to_string(s[1]));
    } else if (s.find("IF") != string::npos) {
        int pos = s.find("GO") + 3, sumnxt = 0;
        for (int i = pos; i <= s.size() - 1; i++) {
            sumnxt = sumnxt * 10 + s[i] - '0';
        }
        pos = s.find("=") + 1;
        int sumval = 0, posend = s.find(" ", pos);
        for (int i = pos; i <= posend - 1; i++) {
            sumval = sumval * 10 + s[i] - '0';
        }
        return sentence(4, (string)to_string(s[4]), sumval, sumnxt);
    } else if (s.find("GO") != string::npos) {
        int pos = 4, sum = 0;
        for (int i = pos; i <= s.size() - 1; i++) {
            sum = sum * 10 + s[i] - '0';
        }
        return sentence(3, sum);
    } else if (s.find("END") != string::npos) {
        return sentence(5);
    } else {
        bug(s);
        cerr << "FATAL: check_type() ERROR" << endl;
        exit(0);
    }
}
void solve() {
    string nows = line[p].s;
    sentence op = check_type(nows);
    if (op.type == 1) {
        var[op.v] += op.integer;
        p++;
        return;
    } else if (op.type == 2) {
        p++;
        return;
    } else if (op.type == 3) {
        p = mp[op.integer];
        return;
    } else if (op.type == 4) {
        if (var[op.v] == op.integer) {
            bug(op.nxt);
            p = mp[op.nxt];
        } else {
            p++;
        }
        return;
    } else {
        p = -1;
        return;
    }
}
int main() {
//     freopen("1.in","r",stdin);
//     freopen("1.out","w",stderr);
    while (cin >> line[++n].num) {
        getchar();
        getline(cin, line[n].s);
        line[n].s = " " + line[n].s;
    }
    n--;
    sort(line + 1, line + n + 1);
    
    for (int i = 1; i <= n; i++) {
        bug(line[i].s);
    }
    del;
    
    for (int i = 1; i <= n; i++) {
        mp[line[i].num] = i;
    }
    p = 1;
    int time = 0;
    while (1) {
        time++;
        solve();
        if (p == -1) {
            cout << time << endl;
            return 0;
        }
        if (time >= 8000000) {
            cout << -1 << endl;
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

#### 前排提示：这是一篇 PyPy 和 Python 的双重题解！
由于是暴力加卡常，利用了 Python 和 PyPy 各自的常数优势，所以 Python 能过的代码 PyPy 过不了，反之亦然。除了提供题解之外，我也想在这里探讨一下各位 Python 玩家遇到这种题目该如何考虑卡常策略。

考虑直接暴力模拟，使用时限判断死循环。然而最后一个点不卡常不容易过。

所以我是怎么卡常的呢？

Python 和 PyPy 分开讲，先放代码再讲解。
#### Python (#10 526ms)
```python
import time;t=time.time();a=[];Q=W=E=R=T=Y=U=I=O=P=A=S=D=F=G=H=J=K=L=Z=X=C=V=B=N=M=0
def g(p):
    u=0
    while p:
        u+=1;p=p()
        if u%100==0:
            if time.time()-t>.95:print(-1);exit()
    print(u)
try:
    while 1:a.append(input().strip().split())
except:
    a.sort(key=lambda i:int(i[0]));b={a[i][0]:i for i in range(len(a))}
    for i in range(len(a)):
        if'GO'==a[i][1]:exec(f'def f{i}():return f{b[a[i][2]]}')
        elif'IF'==a[i][1]:exec(f'def f{i}():return f{b[a[i][4]]} if {a[i][2][0]}=={a[i][2][2:]} else f{i+1}')
        elif'+'==a[i][1][1]:exec(f'def f{i}():global {a[i][1][0]};{a[i][1][0]}+={a[i][1][2:]};return f{i+1}')
        elif'END'==a[i][1]:exec(f'def f{i}():0')
        else:exec(f'def f{i}():return f{i+1}')
g(f0)
```
首先看第一行。除了开计时器以外，所有大写字母都设成全局变量，为后面造函数做准备。

然后定义了一个承接函数，这个函数的作用是规避递归爆栈。在 Python 中，函数本身也是一个对象，你是可以返回函数对象的，这样，运行的语句不直接调用下一句的函数，而是将其交给承接函数，让承接函数调用，这样递归将永远只有两层。这个函数同时承担记录语句数和判定时间的任务。注意到 Python 环境下判时那行代码相当慢，于是将其设定为每一百句判一次。

接下来，输入语句，排序，建立列表快速查询语句编号对应排名。

重头戏来了，通过 ```exec()``` 造函数。函数名用排名方便互相调用，然后根据题意通过字符串变换构造函数，返回值为函数对象，遇到终止语句返回 ```None``` 以提示承接函数结束运行。

如样例应该构造出：

```python
def f0():global A;A+=1;return f1
def f1():return f5 if A==5 else f2
def f2():global A;A+=2;return f3
def f3():return f4
def f4():return f1
def f5():0
```
最后通过承接函数启动 ```f0``` 即可。
#### PyPy (#10 367ms)
```
import time;t=time.time();a=[];d={i:0 for i in'QWERTYUIOPASDFGHJKLZXCVBNM'}
try:
    while 1:a.append(input().split())
except:
    for i in a:
        i[0]=int(i[0])
        if'GO'==i[1]:i[2]=int(i[2])
        if'IF'==i[1]:i[4]=int(i[4]);i.append(i[2][0]);i.append(int(i[2][2:]))
        if'+'in i[1]:i.append(i[1][0]);i.append(int(i[1][2:]))
    a.sort(key=lambda i:i[0]);b={a[i][0]:i for i in range(len(a))};c=i=0
while 1:
    i+=1
    if time.time()-t>.95:print(-1);break
    if'GO'==a[c][1]:c=b[a[c][2]];continue
    if'IF'==a[c][1]:
        if d[a[c][5]]==a[c][6]:c=b[a[c][4]];continue
    if'END'==a[c][1]:print(i);break
    if'+'in a[c][1]:d[a[c][2]]+=a[c][3]
    c+=1
```
主要思想和 Python 代码类似，卡常技巧上有所不同。

第一行改用字典记录变量的值。输入后排序前进行一个粗糙的预编译，主要是将重要的整数和变量字母转化为易操作的形式，无需后期反复变换。接下来是常见的基本操作。
#### 对比与思考
不难看出，在这题上 PyPy 的代码更像多数人刻印里简洁清楚的 Python 代码，而正主 Python 的代码却看起来相当逆天。为什么？

PyPy 作为 Python 的解释器，它主要面向单行单步的数据操作，所以 PyPy 在列表、字典等数据结构中的表现较好，而 Python 本身丰富的功能则决定了它在递归、浅拷贝等需要灵活调用非数据对象的场合更加游刃有余。或者说 PyPy 在性能上比 Python 更接近 C/C++ 等汇编语言。这也是为什么很多常规 OI 题 PyPy 代码比 Python 快（虽然 PyPy 臃肿的内存占用也限制了它的实力）。

平常做题的话，在复杂度正确的情况下 PyPy 能过 Python 被卡的题目不算很多（[比如这个](https://www.luogu.com.cn/article/zjfzqnkd)），真要被卡了的话，要么写正常点的东西，修改细节减少运算量，然后拿 PyPy 交了事，要么尝试使用 Python 的各种包浆，有时一些奇技淫巧真的能让你的代码妙手回春。

---

## 作者：T_TLucas_Yin (赞：0)

时隔半年多做曾经调不动的“大”模拟，居然直接就过了，感慨万千。

没什么好说的，直接模拟。

首先是读入给出的一串程序。使用 `while` 循环加 `scanf` 读入行号，如果读入成功了就说明后面还有一行语句，此时再用 `getline` 读入这行语句。行号和语句都存到一个结构体里。读入的语句需要修剪一下，过滤掉行末的换行符和一开始与行号间的空格。然后把语句的长度也存到这个结构体里方便后续使用，就可以开始处理了。

其他需要的辅助存储：一个映射对应语句的行号与它在结构体中的位置，另一个映射对应大写字母与它表示的变量的值。

此后称一行语句为 $s$。$s$ 的第 $i$ 个位置为 $s[i]$。$i$ 从 $0$ 开始。

对于累加语句，由于格式非常固定，先获取 $s[0]$ 的要修改变量的名称，然后获取 $s[2]$ 到末尾的多位整数，在映射表中将变量增加对应值即可。

对于输出语句，不需要进行任何操作。

对于转移语句，获取 $s[3]$ 到末尾的多位整数，在映射表中找到这个行号对应的语句，把结果存下来用于跳转。

对于条件语句，获取 $s[3]$ 的变量名，再获取 $s[5]$ 到第二个空格处的多位整数为判断值，再获取第二个空格后第四位到末尾的多位整数为跳转行号。先利用变量映射表判断所给变量的值与所给值是否相同，如果相同则找到行号对应的语句存下来用于跳转，否则不管。

对于结束语句，读到时直接跳出执行程序的循环。

接下来是无法正常结束的判定。通过简单的思考会发现这种情况出现在同一个条件语句在转移语句或其他条件语句的跳转下被多次执行且永远不会结束。对于这种情况我们其实也不需要额外干涉，更简单的处理方法是当执行的语句条数达到一定数量时直接输出 $-1$ 并跳出循环，节约了判断环的复杂处理。

代码很简洁，只用到主函数，而且甚至还没有很板的线段树长。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum;
struct node{
	int k,len;
	string s;
}a[1005];
bool cmp(node x,node y){
	return x.k<y.k;
}
map<int,int> Fk;
map<char,int> v;
int main(){
	while(scanf("%d",&a[++n].k)!=EOF){
		getline(cin,a[n].s);
		a[n].s.erase(0,1);
		a[n].len=a[n].s.size();
		while(a[n].s[a[n].len-1]=='\r'||a[n].s[a[n].len-1]=='\n')
			a[n].s.erase(a[n].len-1,1),a[n].len--;
	}
	n--;
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++) Fk[a[i].k]=i;
	int i=1;
	while(i<=n){
		sum++;
		int l=a[i].len,go=0;
		string pro=a[i].s;
		if(pro[1]=='+'){//累加语句
			int x=0;
			char c=pro[0];
			for(int j=2;j<l;j++) x=x*10+(pro[j]-'0');
			v[c]+=x;
		}
		else if(pro[1]=='?'){//输出语句
		}
		else if(pro[0]=='G'&&pro[1]=='O'){//转移语句
			int x=0;
			for(int j=3;j<l;j++) x=x*10+(pro[j]-'0');
			go=Fk[x];
		}
		else if(pro[0]=='I'&&pro[1]=='F'){//条件语句
			int x=0,y=0;
			char c=pro[3];
			int j;
			for(j=5;j<l&&isdigit(pro[j]);j++) x=x*10+(pro[j]-'0');
			j+=4;
			for(;j<l;j++) y=y*10+(pro[j]-'0');
			if(v[c]==x) go=Fk[y];
		}
		else if(pro[0]=='E'&&pro[1]=='N'&&pro[2]=='D') break;//结束语句
		if(go) i=go;
		else i++;
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：ZJLmath (赞：0)

**1.题意简述**

给定不超过 $100$ 行的 TB 语言代码，要求你计算该程序共执行了多少行。

每行代码分两部分，先是行号，再是一段代码，有以下几种类型：

- 累加语句

```
结构：变量名+数字。
执行时将这个变量原先的值加上这个数字。
```

- 输出语句

```
结构：变量名?。
执行时会在监视器上输出这个数字，但并不输出到屏幕上。
```

- 转移语句

```
结构：GO 行号。
执行时改变下一次执行的行号为 GO 后面的行号。
```

- 条件语句

```
结构：IF 变量名=数字 GO 行号。
执行时判断这个变量的值是否等于等号后的数字，若等于，执行后面的转移语句。
```

- 结束语句

```
结构：END。
顾名思义，程序结束，输出这个程序执行了多少行。
```

题目规定，变量名是一个大写字母，行号是一个小于 $3000$ 的非负整数，所以存在第 $0$ 行。

特别的，如果程序陷入死循环，输出 `-1`。

**2.题目做法**

从输入入手，我们可以先读入行号，在开一个长度为 $3000$ 的字符串数组，将行号作为下标。

输入完后再思考怎么模拟，首先是累加语句，因为变量名是大写字母，所以我们想到开一个 `map`，使下标为变量名，映射到其值。执行累加语句时，直接改变该变量在 `map` 里的映射值即可。

再是输出语句，考虑到它不需要真实的显示在屏幕上，所以说可以直接跳过，但别忘了这也算一行代码，也要计数。

转移语句也很简单，直接将当前循环变量改为后面的行号即可。

条件语句前面的判断直接用 `map` 找就行，要注意的是等号后面的值不一定只有一位，要找全，后面的转移语句按上面的做法转移就行。

遇到结束语句时，输出结果，结束程序。

基础代码解决完了，那怎么解决死循环，其实也很简单，与其用各种推导，不如设个阈值，当答案超过这个阈值时，就可以判断程序进入了死循环，经过多次尝试，这个阈值开到 $1e7$ 即可。

本以为这样写就可以了，但交上去却频频 TLE，这是为什么？其实答案也很好想，因为每次执行语句时，都要跑一遍整个字符串，而且阈值又开那么大，肯定会超时。这种情况下，我们可以对每条语句进行预处理，提前将这条语句要做的事情存下了，就可以 $O(1)$ 处理每条语句了。

**3.代码实现**

[通过记录](https://www.luogu.com.cn/record/122811631)

```cpp
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
string Code[3000+5];//存代码，类似桶排
int cnt,nxt[3000+5];//cnt 是答案，nxt 是存储这行代码的下一行代码的行号
#define INF 1e7//阈值 
bool isdigit(char ch){return ch>='0'&&ch<='9';}
int get_int(string s,int l,int r){//取得 s[l] 到 s[r] 的数字
	int ret=0;
	for(int i=l;i<=r&&isdigit(s[i]);i++)ret=(ret*10)+(s[i]-'0');
	return ret;
}
struct OPT{//预处理
	int opt;//0:END  1：IF  2：GO  3：A+1  4：A? 
	char c;int val_c;//IF 的表达式 也是 累加语句的变量和加值 
	int gowhr;//GO 的目标 
	//如果是结束语句或输出语句就不用管了 
}a[3000+5];
map<char ,int> var;//存变量
int now,f;//now 代表当前行号，f 代表行号有没有发生改变，即有没有执行 GO 语句
int main(){
	var.clear();
	int H;
	while(cin>>H){
		getchar();
		getline(cin,Code[H]);
		string s=Code[H];
		for(int i=0;i<s.length();i++){
			if(s[i]=='I'&&s[i+1]=='F'){
				a[H].opt=1;
				a[H].c=s[i+3];
				for(i=i+5;isdigit(s[i])&&i<s.length();i++)a[H].val_c=(a[H].val_c*10)+(s[i]-'0');
				i+=4;
				a[H].gowhr=get_int(s,i,s.length()-1);
				break;
			}
			else if(s[i]=='G'&&s[i+1]=='O'){
				a[H].opt=2;
				a[H].gowhr=get_int(s,i+3,s.length()-1);
				break;
			}else if(s[i]=='+'){
				a[H].opt=3;
				a[H].c=s[i-1];
				a[H].val_c=get_int(s,i+1,s.length()-1);
				break;
			}else if(s[i]=='?'){
				a[H].opt=4;break;
			}else if(s[i]=='E'&&s[i+1]=='N'&&s[i+2]=='D'){
				a[H].opt=0;break;
			}
		}
	}
	int last=0;
	for(int i=0;i<=3000;i++){
		if(Code[i]=="")continue;
		nxt[last]=i,last=i;
	}
	nxt[last]=-1;
	for(now=0;now<=3000;){
		if(Code[now]==""){now=nxt[now];if(now==-1){break;}continue;}
		f=1;
		++cnt;
		if(cnt>INF){//死循环 
			cout<<-1;exit(0);
		}
		switch(a[now].opt){
			case 0:
				cout<<cnt<<endl;
				exit(0);
			case 1:
				if(var[a[now].c]==a[now].val_c){
					now=a[now].gowhr;f=0;
				}
				break;
			case 2:
				now=a[now].gowhr;f=0;break;
			case 3:
				var[a[now].c]+=a[now].val_c;
				if(var[a[now].c]>10000){
					cout<<-1;exit(0);
				}
				break;
			case 4:
				break;
		}
		if(f)now=nxt[now];//最后一行代码不是结束语句，说明程序没有正常结束，输出 -1
	}
	cout<<-1<<endl;
	return 0;
}
```


---

## 作者：sdsswyd (赞：0)

**[题目传送门](https://www.luogu.com.cn/problem/P5756)**

面对其他大佬写出来的优质题解，我只能“望洋兴叹”。
## 30分做法
直接输 $-1$ ，不说了。
## 100分做法
### 基本思路
模拟即可。  
1. 题目中说的 $26$ 个变量的值要保留，那么我们可以开一个 `map` 容器进行存储，并赋值为零。
2. 读入字符串（别忘读空格）。
3. 这里我的做法是：对于每个字符串，都把它截成前半段（行号）和后半段（语句），放进结构体里。
4. 按行号从小到大排序。
5. 循环保留顺序，对于第 $i$ 个结构体的元素，它的编号为 $i$ 。
6. 开始模拟。
### 模拟方法
1. 将答案 $answer$ $\gets$ $0$ ，枚举当前元素的 $v$ $\gets$ $1$。
2. 最关心的出现了，正常结束的程序最多执行多少次？
一个程序最多出现 $26$ 个英文字母，程序最多 $100$ 行，数字是 $0$ 到 $9999$ 共 $10000$ 个，对于每个英文字母和每一行及每一个数考虑，程序最多执行 $26$ $\times$ $10000$ $\times$ $100$ $=$ $2.6$ $\times$ $10^7$ 条语句。
3. 用 `find` 函数来判断是否是“结束语句”“累加语句”。“执行条件”“转移语句”“输出语句”，并进行对应操作。（“执行条件”“转移语句”别搞反！！！）
4. 输出 $answer$ 的值或 $-1$ 。
### 语句操作
1. “结束语句”：直接返回 $answer + 1$ 的值。
2. “累加语句”：修改 `map` 中变量的值。
3. “执行条件”：判断前项是否等于后项，若相等，用**二分**跳至相应行。
4. “转移语句”：用**二分**跳至相应行。
5. “输出语句”：不管了。
# AC代码
[Look at this.](https://www.luogu.com.cn/paste/2sjd7eew)  
[记录。](https://www.luogu.com.cn/record/168995271)

---


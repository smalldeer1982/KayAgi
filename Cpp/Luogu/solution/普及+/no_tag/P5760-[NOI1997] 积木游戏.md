# [NOI1997] 积木游戏

## 题目描述

SERCOI 最近设计了一种积木游戏。每个游戏者有 $N$ 块编号依次为 $1 ，2，…，N$ 的长方体积木。对于每块积木,它的三条不同的边分别称为"a 边"、"b 边"和"c 边"，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/jfd5li1k.png)

游戏规则如下：
1. 从 $N$ 块积木中选出若干块，并将它们分成 $M$ （$ 1 \le M \le N $） 堆，称为第 $1$ 堆，第 $2$ 堆…，第 $M$ 堆。每堆至少有 $1$ 块积木，并且第 $K$ 堆中任意一块积木的编号要大于第 $K+1$ 堆中任意一块积木的编号($ 2 \le K \le M $)。

2.  对于每一堆积木,游戏者要将它们垂直摞成一根柱子,并要求满足下面两个条件：

$\qquad$ 1)除最顶上的一块积木外，任意一块积木的上表面同且仅同另一块积木的下表面接触，并且要求下面的积木的上表面能包含上面的积木的下表面，也就是说，要求下面的积木的上表面的两对边的长度分别大于等于上面的积木的两对边的长度。

$\qquad$ 2)对于任意两块上下表面相接触的积木，下面的积木的编号要小于上面的积木的编号。

最后，根据每人所摞成的 $M$ 根柱子的高度之和来决出胜负。

请你编一程序，寻找一种摞积木的方案，使得你所摞成的 $M$ 根柱子的高度之和最大。


## 样例 #1

### 输入

```
4 2
10 5 5
8 7 7
2 2 2
6 6 6
```

### 输出

```
24
```

# 题解

## 作者：asdfo123 (赞：6)

[原题P5760](https://www.luogu.com.cn/problem/P5760)

我们观察题面，思考一下这道题的决策方案

对于当前“状态”，我们有三种“决策”：

- 从当前块另起一堆
- 当前块加在前一堆上
- 不选当前块

这里其实有一个问题，我们如何判断当前块能不能加在之前的块上面？？

我们用$a_{i,0},a_{i,1},a_{i,2}$分别代表一个块的长，宽，高（相对而言）

那么显然这三条边能构成三个面，为了方便，我们分别定义：
$$a_{i,4}=a_{i,0}$$
$$a_{i,5}=a_{i,1}$$
那么对于一个长度$a_{i,k}$:

$a_{i,k+1}$ 为所对应的宽

$a_{i,k+2}$ 为所对应的高

我们定义 $dp_{i,j,l}$ 表示前 $i$ 根柱子，第 $j$ 块积木并且当前正在处理第 $l$ 个平面（我们理解为处理一条边）。
$0 \leq l \leq 2$，分别代表积木不同的三边（面）。

思考完决策，我们开始递推：

**决策1**:新起一堆：
$$dp_{i,j,l}=dp_{i-1,h,k}+a_{j,l+2}$$

这里 $h$ 代表之前的积木，$k$代表之前这个积木的第$k$个面

**决策2**:加在当前堆：
$$dp_{i,j,l}=dp_{i,j,k}+a_{j,l+2}$$

**决策3**:当然是不放

所以我们对前两个决策分别对不放和放取 $max$，开一个 $ans$ 记录最大值就可以了。

还有没太听懂的可以看代码。。。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=110;
int a[N][5],ans;
int dp[N][N][5],n,m;
int x1,y1,x2,y2;//用dp[i][j][l]表示第i堆第j块积木第l条边的最大高度
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);//a[i][k+2]是这面所对应的高 
		a[i][3]=a[i][0];
		a[i][4]=a[i][1];
	}
    for(int i=1;i<=m;i++)		//第i根柱子 
        for(int j=1;j<=n;j++)		//第j块积木 
            for(int h=0;h<j;h++)	//在编号小的积木中找第h块积木 (从0开始,否则求不出1的值) 
                for(int k=0;k<=2;k++)	//第h块积木的第k条边 
                    for(int l=0;l<=2;l++)	//第j块积木的第l条边 
					{
                        x1=max(a[h][k],a[h][k+1]);//下面积木上表面的长边 
                        y1=min(a[h][k],a[h][k+1]);//短边 
                        x2=max(a[j][l],a[j][l+1]);//上面积木下表面的长边 
                        y2=min(a[j][l],a[j][l+1]);//短边 
                        if(x1>=x2&&y1>=y2)			//如果下面积木的两条边大于上面积木的两边 
                            dp[i][j][l]=max(dp[i][j][l],dp[i][h][k]+a[j][l+2]);  //放或不放，取较大佱 
                        dp[i][j][l]=max(dp[i][j][l],dp[i-1][h][k]+a[j][l+2]);	//和前一堆比较 
                        ans=max(ans,dp[i][j][l]);
                    }
    printf("%d",ans);        
    return 0;
}
```


---

## 作者：FjswYuzu (赞：4)

我们定义$dp_{i,j,k}$为前$i$个积木垒成$j$堆，并且当前正在处理第$k$个平面。$0 \leq k \leq 2$，分别代表积木不同的三面。

我们很容易发现我们可以再多垒成一堆，也可以搭在当前这一堆积木上面。但是一定要注意再新垒成一堆的话就不用判断之前的积木的长宽高了。

我们能够很顺利地推出我们的转移方程：

$$dp_{i,j,pm}=\max \{dp_{i-1,k,Last}+buf \}$$

如果还可以垒到当前的积木上面去：

$$dp_{i,j,pm}=\max \{{dp_{i,k,Last}+buf} \}$$

其中$i,j$意义如上，$k$为当前选到要搭上的积木，$pm$为当前平面，$Last$为上个平面。

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
int n,m,a[105],b[105],c[105],dp[105][105][3];//dp[i][j][k]：前i个堆垒j个正在处理k平面 
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)	scanf("%d %d %d",&a[i],&b[i],&c[i]);//进行输入
	for(int i=1;i<=m;++i)
	{
		for(int j=1;j<=n;++j)
		{
			for(int k=0;k<j;++k)
			{
				for(int pm=0;pm<=2;++pm)
				{
					int x,y,buf;
					if(pm==0)	x=a[j],y=b[j],buf=c[j];
					if(pm==1)	x=b[j],y=c[j],buf=a[j];
					if(pm==2)	x=c[j],y=a[j],buf=b[j];
					if(x<y)	x^=y^=x^=y;
					for(int Last=0;Last<=2;++Last)
					{
						int xx,yy;
						if(Last==0)	xx=a[k],yy=b[k];
						if(Last==1)	xx=b[k],yy=c[k];
						if(Last==2)	xx=c[k],yy=a[k];
						if(xx<yy)	xx^=yy^=xx^=yy;
						dp[i][j][pm]=max(dp[i][j][pm],dp[i-1][k][Last]+buf);
						if(x>xx || y>yy)	continue;
						dp[i][j][pm]=max(dp[i][j][pm],dp[i][k][Last]+buf);
					}
				}
			}
		}
	}
	int ans=-10086001;
	for(int i=1;i<=n;++i)	ans=max(ans,max(max(dp[m][i][0],dp[m][i][1]),dp[m][i][2]));
	printf("%d",ans);
	return 0;
}
```

这道题是我很久以前做的，可能忘了。如果有不懂的地方，可以在讨论区留言。

---

## 作者：wangjiajian (赞：2)

设 $f_{i,j,k}$ 表示当前枚举到第 $i$ 块积木，第 $j$ 列，当前这块积木的状态为 $k$。

设状态 $k$ 表示以第 $k$ 条边为高（如：$(10, 5, 5)$ 的积木的状态 $1$ 则是以 $10$ 为高），设 $a_{i, k}$ 表示第 $i$ 块积木处于状态 $k$ 时的高。

考虑从积木 $z$ 的状态 $t$ 转移而来（满足 $z \in [0, i)$，$t \in [1, 3]$）。

**当积木 $i$ 不新开一列时：** $f_{i, j, k} = \max(f_{z,j,t}+a_{i, k})$

条件是：积木 $i$ 的状态 $k$ 可以放在积木 $z$ 的状态 $t$ 之上，且状态 $f_{z,j,t}$ 存在。

**当积木 $i$ 单独开一列时：** $f_{i, j, k} = \max(f_{z,j-1,t}+a_{i,k})$

条件是：状态 $f_{z,j,t}$ 存在。

**总时间复杂度：** $O(n^3)$

**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define N (int)(103)
using namespace std;

int n, m, ans;
int a[N][4], f[N][N][4];
pair<int, int> tmp1, tmp2;

inline bool mtch(int x, int x_opt, int y, int y_opt) {  // 判断 x 能否放 y 在上面 
	if(y == 0)
		return true;
	if(x_opt == 1)
		tmp1 = make_pair(a[x][2], a[x][3]);
	else if(x_opt == 2)
		tmp1 = make_pair(a[x][1], a[x][3]);
	else
		tmp1 = make_pair(a[x][1], a[x][2]);
	if(y_opt == 1)
		tmp2 = make_pair(a[y][2], a[y][3]);
	else if(y_opt == 2)
		tmp2 = make_pair(a[y][1], a[y][3]);
	else
		tmp2 = make_pair(a[y][1], a[y][2]);
	if(tmp2.first >= tmp1.first && tmp2.second >= tmp1.second)
		return true;
	else if(tmp2.second >= tmp1.first && tmp2.first >= tmp1.second)
		return true;
	return false;
}

inline bool chck(int j, int li, int lj, int lt) {  // 判断种情况是否存在，如果存在才能转移 
	if(j == 1)
		return true;
	return (f[li][lj][lt] != 0);
}

int main() {
	scanf("%d%d", &n, &m);
	for(int i=1; i<=n; i++)
		scanf("%d%d%d", &a[i][1], &a[i][2], &a[i][3]);
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=min(n, m); j++) {
			for(int k=1; k<=3; k++) {
				for(int z=0; z<i; z++) {
					for(int t=1; t<=3; t++) {
						if(mtch(i, k, z, t) && chck(j, z, j, t))
							f[i][j][k] = max(f[i][j][k], f[z][j][t] + a[i][k]);
						if(chck(j, z, j-1, t))
							f[i][j][k] = max(f[i][j][k], f[z][j-1][t] + a[i][k]);
					}	
				}
				if(j == m)
					ans = max(ans, f[i][j][k]);
			}
		}
	}
	printf("%d\n", ans);
	return 0;
}

```

---

## 作者：hxhhxh (赞：2)

## 大意

有 $ n $ 个长方体方块，将其依次放置顺次摞成 $ m $ 堆，每一堆中顶面完全包含上面方块的底面。求最高高度和。

## 思路

一个方块有三种放置方式在本题有本质区别：

- $ a $，$ b $，做长和宽，$ c $ 做高；
- $ a $，$ c $，做长和宽，$ b $ 做高；
- $ b $，$ c $，做长和宽，$ a $ 做高。

让两个方形叠放，可以用长边对长边，短边对短边。所以，上面这东西可以表示为：

- $ \max(a,b) $ 做长，$ \min(a,b) $ 做宽，$ c $ 做高，设为状态 $ 0 $； 
- $ \max(a,c) $ 做长，$ \min(a,c) $ 做宽，$ b $ 做高，设为状态 $ 1 $；
- $ \max(b,c) $ 做长，$ \min(b,c) $ 做宽，$ a $ 做高，设为状态 $ 2 $。

进行记搜。

考虑对于一个方块，有三种处理方式：

1. 不管；
2. 在当前这一堆放它。
3. 另起一堆，放它；

就有三种方式进行记搜（`x`表示当前是第几个，`y`表示当前是第几堆，	`lst`代表上一个选的是哪一个，`upr`表示上一个是哪一种状态，`t`为三种状态下的长宽高）：

1. `anc=max(anc,dfs(x+1,y,lst,upr));`：不管；
2. `if(t[i].a<=lu.a&&t[i].b<=lu.b) anc=max(anc,t[i].h+dfs(x+1,y,x,i));`：在当前这一堆继续放；
3. `anc=max(anc,t[i].h+dfs(x+1,y+1,x,i));`： 另起一堆。

## 代码
```cpp
#include<bits/stdc++.h>
#define inf 100000000
using namespace std;
int n,m,a[105],b[105],c[105],dp[105][105][105][3];
bool vis[105][105][105][3];
struct blck{
	int a,b,h;
};
blck mn(int x,int upr){
	if(upr==0) return (blck){min(a[x],b[x]),max(a[x],b[x]),c[x]};
	if(upr==1) return (blck){min(a[x],c[x]),max(a[x],c[x]),b[x]};
	if(upr==2) return (blck){min(b[x],c[x]),max(b[x],c[x]),a[x]};
	return (blck){0,0,0};
}
int dfs(int x,int y,int lst,int upr){
	if(vis[x][y][lst][upr]) return dp[x][y][lst][upr];
	vis[x][y][lst][upr]=true;
	if(x==n+1){
		if(y==m) return dp[x][y][lst][upr]=0;
		return -inf;
	}
	int anc=-inf;
	anc=max(anc,dfs(x+1,y,lst,upr));
	blck lu=mn(lst,upr),t[3]={mn(x,0),mn(x,1),mn(x,2)};
	for(int i=0;i<3;i++){
		if(t[i].a<=lu.a&&t[i].b<=lu.b) anc=max(anc,t[i].h+dfs(x+1,y,x,i));
		if(y<m) anc=max(anc,t[i].h+dfs(x+1,y+1,x,i));
	}
	return dp[x][y][lst][upr]=anc;
}
int main(){
	cin>>n>>m;
	for(int i=0;i<=n+1;i++) for(int j=0;j<=n+1;j++) for(int k=0;k<=n+1;k++) for(int l=0;l<3;l++) dp[i][j][k][l]=-inf;
	for(int i=1;i<=n;i++) scanf("%d %d %d",&a[i],&b[i],&c[i]);
	cout<<dfs(1,0,0,0);
	return 0;
} 
```

---

## 作者：fnoi_zrh0301 (赞：2)

# 洛谷P5760 积木游戏

## 一 题目描述

给出n个积木，求出摞成m堆的高度和的最大值
**规则：**

1 每堆至少有一块积木

2 第K堆每一块积木的编号必须大于第K+1堆

3 小的积木必须在大的积木上面（可以等于）

4 下面积木的编号比上面积木小

见洛谷P5760

[题目描述](https://www.luogu.com.cn/problem/P5760 )
## 二 算法分析
DP
### 一 状态定义
$data[i][k1]$表示1~i块积木以第i块积木的k1为高时的最高值
### 二 所求
$data$数组中最大的即为所求
### 三 转移方程
$$
f(i,j)=
\begin{cases}
max_{j=i+1,k=1}^{n,3} data[j][k] & t[i][k1][j][k2]
\end{cases}
$$
### 四 代码（含注释）

```C++
#include<stdio.h>
#include<iostream>
const int N=110;
int a[N][4];
int data[N][4];
int n,m;
bool t[N][4][N][4];
int max1(int a,int b){
	return a>b?a:b;
}
//定义check函数 
bool check(int i,int k1,int j,int k2){
	//a1表示第i块积木的长，b1表示第i块积木的宽
	//a2表示第j块积木的长，b2表示第j块积木的宽 
	int a1,b1,a2,b2;
	//枚举三种k可能的情况，生成长和宽 
	if(k1==1) a1=a[i][2],b1=a[i][3];
	if(k1==2) a1=a[i][1],b1=a[i][3];
	if(k1==3) a1=a[i][1],b1=a[i][2];
	//同理 
	if(k2==1) a2=a[j][2],b2=a[j][3];
	if(k2==2) a2=a[j][1],b2=a[j][3];
	if(k2==3) a2=a[j][1],b2=a[j][2];
	//判断能否拼接，长和宽可以颠倒位置 
	return ((a1>=a2 and b1>=b2) or (a1>=b2 and a2<=b1));
}
int main(){
	freopen("block.in","r",stdin);
	//freopen("block.out","w",stdout);
	//读入 
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d%d%d",&a[i][1],&a[i][2],&a[i][3]);//存储在二维数中，利于以后查找
	//初始化data数组，填入假设每摞只可以加入一个木块时的情况 
	memcpy(data,a,sizeof data);//memcpy(a,b,sizeof a)表示将b拷贝到a中
	//生成t数组，利于以后操作
	//t[i][k1][j][k2]表示第i块积木以k1为高，第j块积木以k2为高能否拼接到一起 
	for(int i=1;i<n;++i) 
		for(int k1=1;k1<=3;++k1) 
			for(int j=i+1;j<=n;++j) 
				for(int k2=1;k2<=3;++k2)
					t[i][k1][j][k2]=check(i,k1,j,k2);//check函数定义见上 
	//DP 递推求解 
	int ans=0;
	//直接照抄转移方程 
	for(int i=n;i>=1;--i){
		for(int k1=1;k1<=3;++k1){
			int max1=0;
			for(int j=i+1;j<=n;++j)
				for(int k2=1;k2<=3;++k2)
					if(data[j][k2]>max1 and t[i][k1][j][k2]) max1=data[j][k2];
			data[i][k1]=max1+data[i][k1];
			if(ans<data[i][k1]) ans=data[i][k1];
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
但是我们求解的是当m=1的情况，所以只能得20分

还需要再加一个DP，求解把积木分成多少堆的最大值

代码见下

```C++
#include<stdio.h>
#include<string.h>
using namespace std;
const int N=110,M=110;
int n,m;
int a[N][4];
int f1[N][N][4];
int data[N][N];
int dp[N][M];
bool t[N][4][N][4];
bool check(int i,int k1,int j,int k2){
    int a1,a2,b1,b2;
    if(k1==1) a1=a[i][2],b1=a[i][3];
    if(k1==2) a1=a[i][1],b1=a[i][3];
    if(k1==3) a1=a[i][2],b1=a[i][1];
    if(k2==1) a2=a[j][2],b2=a[j][3];
    if(k2==2) a2=a[j][1],b2=a[j][3];
    if(k2==3) a2=a[j][2],b2=a[j][1];
    return (a1>=a2 and b1>=b2) or (a1>=b2 and b1>=a2);
}
int main(){
    //freopen("block.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d%d",&a[i][1],&a[i][2],&a[i][3]);
    for(int i=1;i<n;i++){
        for(int k1=1;k1<=3;k1++){
            for(int j=i+1;j<=n;j++){
                for(int k2=1;k2<=3;k2++){
                    t[i][k1][j][k2]=check(i,k1,j,k2);
                }
            }
        }
    }
    for(int l=n;l>=1;l--){
        for(int i=l;i>=1;i--){
            for(int k1=1;k1<=3;k1++){
                int max1=0;
                for(int j=i+1;j<=n;j++){
                    for(int k2=1;k2<=3;k2++){
                        if(t[i][k1][j][k2]){
                            int x=f1[j][l][k2];
                            if(max1<x) max1=x;
                        }
                    }
                }
                f1[i][l][k1]=max1+a[i][k1];
            }
        }
    }
    for(int i=n;i>=1;i--){
        for(int j=i;j>=1;j--){
            int max1=0;
            for(int k=1;k<=3;k++) if(max1<f1[j][i][k])max1=f1[j][i][k];
            data[i][j]=max1;
        }
    }
     
    for(int i=1;i<=n;i++){
        int max1=0;
        for(int j=i;j<=n;j++) if(data[j][i]>max1) max1=data[j][i];
        dp[i][1]=max1;
    }
     
    for(int j=2;j<=m;j++){
        for(int i=n-j+1;i>=1;i--){
            int max1=0;
            for(int k=n-j+1;k>=i;k--) if(data[k][i]+dp[k+1][j-1]>max1) max1=data[k][i]+dp[k+1][j-1];
            dp[i][j]=max1;
        }
    }
     
    int max1=0;
    for(int i=1;i<=n;i++) if(dp[i][m]>max1) max1=dp[i][m];
    printf("%d\n",max1);
//  for(int i=1;i<=n;i++){
//      for(int j=1;j<=m;j++) printf("%d ",dp[i][j]);
//      printf("\n");
//  }
    return 0;
}
```



---

## 作者：LG1038 (赞：1)

## 题目大意
这道题目要求在 $n$ 个积木中选出 $m$ 堆，每一堆至少有一块积木，并且要求第 $i$ 堆中的每一块积木编号都大于第 $i + 1$ 堆中的每一块积木的编号，且对于每一堆积木，下面的积木的上表面的长和宽必须大于等于上面和它相邻的积木的下表面的长和宽，且下面的积木的编号要小于上面积木的编号。请设计一种方案使 $m$ 堆积木的高度的总和最大，求出这个最大值。
## 思路
使用动态规划，定义 $dp_{i,j,k}$ 中 $i$ 表示当前选择的积木编号，$j$ 表示当前已经选好的堆数，$k=1$ 表示当前积木以第一条边和第二条边组成的面作为底面，$k=2$ 表示当前积木以第二条边和第三条边组成的面作为底面，$k=3$ 表示当前积木以第一条边和第三条边组成的面作为底面，因为要求下面的编号大于上面的编号，所以将 $i$ 从后往前枚举，因为在定义中要求选择第 $i$ 快积木，有两种决策方法，第一种为将这块积木作为新的一堆，这是不需要其它条件，第二种为将这块积木加入最后一堆，但是前提条件是这块积木的上表面必须大于上一块积木的下表面。
这时还需要枚举一个数 $l$ 表示上一个选的积木的编号，并且需要保证 $1 \le i \le l$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e2;
struct node
{
	int x, y, z;
	int d[3][3];
	inline node()
	{
		x = y = z = 0;
		memset(d, 0, sizeof(d)); 
	}
}a[N + 5];
int n, m, dp[N + 5][N + 5][3], ans;
int main(void)
{
	cin >> n >> m;
	for(int i = 1; i <= n; ++ i)
	{
		cin >> a[i].x >> a[i].y >> a[i].z;
		a[i].d[0][0] = a[i].x;
		a[i].d[0][1] = a[i].y;
		a[i].d[1][0] = a[i].y;
		a[i].d[1][1] = a[i].z;
		a[i].d[2][0] = a[i].x;
		a[i].d[2][1] = a[i].z;
	}
	for(int i = n; i >= 1; -- i)
	{
		for(int j = 1; j <= m; ++ j)
		{
			for(int k = 0; k < 3; ++ k)
			{
				if(i == n && j == 1) for(int o = 0; o < 3; ++ o) dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][o] + (a[i].x + a[i].y + a[i].z - a[i].d[k][0] - a[i].d[k][1]));
				for(int l = i + 1; l <= n; ++ l)
				{
					for(int o = 0; o < 3; ++ o) dp[i][j][k] = max(dp[i][j][k], dp[l][j - 1][o] + (a[i].x + a[i].y + a[i].z - a[i].d[k][0] - a[i].d[k][1]));
					for(int o = 0; o < 3; ++ o)
					{
						if((a[i].d[k][0] >= a[l].d[o][0] && a[i].d[k][1] >= a[l].d[o][1]) || (a[i].d[k][0] >= a[l].d[o][1] && a[i].d[k][1] >= a[l].d[o][0])) 
						{
							dp[i][j][k] = max(dp[i][j][k], dp[l][j][o] + (a[i].x + a[i].y + a[i].z - a[i].d[k][0] - a[i].d[k][1]));
						}
					}
				}
			//	cout << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << endl;
				ans = max(ans, dp[i][j][k]);
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：lyhqwq (赞：1)

## 思路

一个比较套路的 dp。

令 $f_{i,j,k}$ 表示前 $i$ 个积木堆成了 $j$ 堆，当前这堆最上面的积木朝上的面为 $k$。

$k=0$ 时，表示朝上的面边分别为 $a$，$b$，高为 $c$。

$k=1$ 时，表示朝上的面边分别为 $b$，$c$，高为 $a$。

$k=2$ 时，表示朝上的面边分别为 $c$，$a$，高为 $b$。

转移方程分为三类：

1. 不选择当前这类积木。
1. 把当前积木放在最后一堆上。
1. 把当前积木单独放在一堆。

第二类和第三类的转移方程分别为：

$f_{i,j,k}=\max(f_{i,j,k},f_{h,j,l}+high_i)$

$f_{i,j,k}=\max(f_{i,j,k},f_{h,j-1,l}+high_i)$

其中 $h$ 表示另一块积木，$l$ 表示 $h$ 朝上的面，$high_i$ 表示第 $i$ 块积木的高度。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
int n,m;
int a[N][5];
int dp[N][N][5];
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
		a[i][3]=a[i][0];
		a[i][4]=a[i][1];
	}
	for(int i1=1;i1<=n;i1++){
		for(int j=1;j<=m;j++){
			for(int k=0;k<=2;k++){
				for(int i2=0;i2<i1;i2++){
					for(int l=0;l<=2;l++){
						int x1=max(a[i1][k],a[i1][k+1]);
						int y1=min(a[i1][k],a[i1][k+1]);
						int x2=max(a[i2][l],a[i2][l+1]);
						int y2=min(a[i2][l],a[i2][l+1]);
						if(x1<=x2&&y1<=y2){
							dp[i1][j][k]=max(dp[i1][j][k],dp[i2][j][l]+a[i1][k+2]);
						}
						dp[i1][j][k]=max(dp[i1][j][k],dp[i2][j-1][l]+a[i1][k+2]);
					}
				}
			}
		}
	}
	//puts("qwq");
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=0;k<=2;k++){
				//printf("%d %d %d %d\n",i,j,k,ans);
				ans=max(ans,dp[i][j][k]);
			}
		}
	}
	printf("%d",ans);
	return 0;
}

```


---

## 作者：Arthur_Douglas (赞：0)

## 思路
首先，我们来观察一下，便会发现枚举的长方体可以四处旋转，~~头晕眼花~~，然后编号还要小于，当时做这道题的时候，那给我做的是一个难受。于是我便~~去世了~~灵机一动，便想到了三个状态：放在这一堆的下一个，放弃，新开一个堆。于是我们就来尝试存储一下长方形对应的长、宽、高。所以我们定义 $dp_{i,j,k}$ 表示在第 $i$ 堆时，枚举到第 $j$ 个积木以及长方体的朝向。不难得出转移方程，这里就不详细阐述。注意不一定要选 $n$ 块，所以每推出一个状态，便与变量 $maxn$ 取大，最后输出 $maxn$ 即可。

## 代码
~~代码是唯一的衡量标准。~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101][5];
int dp[101][101][5];
int main()
{
	int n , m;
	cin >> n >> m;
	for(int i = 1;i <= n;++ i)
	{
		cin >> a[i][0] >> a[i][1] >> a[i][2];
		a[i][3] = a[i][0];
		a[i][4] = a[i][1];
	}
	int ans = 0;
	for(int i = 1;i <= m;++ i)
	{
		for(int j = 1;j <= n;++ j)
		{
			for(int k = 0;k < j;++ k)
			{
				for(int l = 0;l < 3;++ l)
				{
					for(int o = 0;o < 3;++ o)
					{
						int x1 , x2 , y1 , y2;
						x1 = max(a[k][l] , a[k][l + 1]);
						y1 = min(a[k][l] , a[k][l + 1]);
						x2 = max(a[j][o] , a[j][o + 1]);
						y2 = min(a[j][o] , a[j][o + 1]);
						if(x1 >= x2 && y1 >= y2)
						{
							dp[i][j][o] = max(dp[i][j][o] , dp[i][k][l] + a[j][o + 2]);
						}
						dp[i][j][o] = max(dp[i][j][o] , dp[i - 1][k][l] + a[j][o + 2]);
						ans = max(ans , dp[i][j][o]);
					}
				}
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：wzy2021 (赞：0)

容易想到设 $f_{i, j}$ 表示前 $i$ 块积木，把它们分成 $j$ 堆柱子后高度之和的最大值 （第 $i$ 块积木在第 $j$ 堆柱子）,

然后考虑第 $i$ 块三种情况：

1. 不放，什么都不用做

2. 另起一个柱子，枚举第 $j - 1$ 堆柱子的顶端 $k$，则

$$f_{i, j} = \max(f_{i, j}, f_{k, j - 1} + high_i)$$

3. 	加在前一个柱子之前，枚举第 $i$ 块积木在第 $k$ 块积木上，则

$$f_{i, j} = \max(f_{i, j}, f_{k, j} + high_i)$$

其中，$high_i$ 为第 $i$ 块积木的高度，

高高兴兴地写完，交！听取 WA 声一片啊！

仔细想想：长方体可以通过旋转得到另一个长方体！

一个长方体可以最多可以 $3$ 个不同的长方体，

令类型 $0$ 为以 $a, b$ 为底的长方体，

类型 $1$ 为以为底的 $b, c$ 长方体，

类型 $2$ 为以 $c, a$ 为底的长方体

其中，$a, b, c$ 为题目中的意思，

设 $f_{i, j, d}$ 表示前 $i$ 块积木，把它们分成 $j$ 堆柱子，第 $i$ 块积木类型为 $d$，的高度之和的最大值 （第 $i$ 块积木在第 $j$ 堆柱子）

这里 $0 \leq d \leq 2$，

同上，分三种情况：

1. 不放，什么都不用做

2. 另起一个柱子，枚举第 $j - 1$ 堆柱子的顶端 $k$，则

$$f_{i, j, d1} = \max(f_{i, j, d1}, f_{k, j - 1, d2} + high_{i, d1})$$

3. 	加在前一个柱子之前，枚举第 $i$ 块积木在第 $k$ 块积木上，则

$$f_{i, j, d1} = \max(f_{i, j, d1}, f_{k, j, d2} + high_{i,d1})$$

其中，$d1, d2$ 分别为 $i$ 的类型和 $k$ 的类型，$high_{i, d1}$ 为 $i$ 为 $d1$ 类型时的高度。

以下优化为 @asdfo123 大佬的方法：

为了方便，令 $l_{i,0},l_{i,1},l_{i,2}$ 分别为题目所说的 $a, b, c$，

在令 
$$l_{i, 3} = l_{i, 0}$$ 

$$l_{i, 4} = l_{i, 1}$$

则类型为 $d$ 的第 $i$ 个长方体的高为 $l_{i, d +2}$，长宽为 $l_{i, d}$ 以及 $l_{i, d + 1}$，

这样在 $high_{i, d}$ 时和处理两个长方体堆在一起时是否合法就方便多了。

~~~cpp
#include <cstdio>
#include <iostream>
using namespace std;

const int N = 110;

int l[N][5], f[N][N][5];

int length (int x, int d) { // 计算第 x 个长方体 d 类型的长方体的长
	return max (l[x][d], l[x][d + 1]);
}

int width (int x, int d) { // 计算第 x 个长方体 d 类型的长方体的宽
	return min (l[x][d], l[x][d + 1]);
}

bool check (int x, int d1, int y, int d2) { // 判断上下放置是否合法
	return (length (x, d1) <= length (y, d2)) && (width (x, d1) <= width (y, d2));
}

int main() {
	int n, m; scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) {
		scanf ("%d%d%d", &l[i][0], &l[i][1], &l[i][2]);
		l[i][3] = l[i][0]; l[i][4] = l[i][1];
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			for (int k = 0; k < i; ++k) {
				for (int d1 = 0; d1 <= 2; ++d1) {
					for (int d2 = 0; d2 <= 2; ++d2) {
						f[i][j][d1] = max (f[i][j][d1], f[k][j - 1][d2] + l[i][d1 + 2]); // 另起一堆柱子
						if (check (i, d1, k, d2)) {
							f[i][j][d1] = max (f[i][j][d1], f[k][j][d2] + l[i][d1 + 2]); // 放在在以前的柱子上面
						}
						ans = max (ans, f[i][j][d1]);
					}
				}
			}
		}
	}
	printf ("%d", ans);
	return 0;
}
~~~

---

## 作者：Reanap (赞：0)

因为任意后一堆的编号一定比前一堆大，所以满足无后效性的原则，我们考虑dp。

首先维护一个$F_{i,j}$数组，表示从积木$i$到积木$j$最多能堆多高，每种积木有三种堆法，枚举堆法组合即可，之后我们就可以愉快地进行dp。

定义$dp_{i,k}$表示第$k$组以$i$结尾的最大高度，枚举组数，起点和终点就可以轻易地进行状态转移。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
LL n , m , dp[105][105] , f[105][105][3] , F[105][105];
//f[i][j][p]表示从i到j选积木堆，且必选第j个以第p种方式堆的最大高度
struct node {
	LL a , b , c;
}a[105];
bool check(LL x , LL y , LL p , LL q) {
	LL A , b , c , d;
	if(p == 1) {A = a[x].b;b = a[x].c;}
	else if(p == 2) {A = a[x].a;b = a[x].c;}
	else if(p == 3) {A = a[x].a;b = a[x].b;}
	if(q == 1) {c = a[y].b;d = a[y].c;}
	else if(q == 2) {c = a[y].a;d = a[y].c;}
	else if(q == 3) {c = a[y].a;d = a[y].b;}
	if(c <= A) if(d <= b) return true;
	if(c <= b) if(d <= A) return true;
	return false;
} //x号积木以第p种方式堆，y号积木以第q种方式堆是否合法
int main() {
	scanf("%lld %lld" , &n , &m);
	for (LL i = 1; i <= n; ++i) scanf("%lld %lld %lld" , &a[i].a , &a[i].b , &a[i].c);
	for (LL i = 1; i <= n; ++i) {
		for (LL j = i; j <= n; ++j) {
			f[i][j][0] = a[j].a;
			f[i][j][1] = a[j].b;
			f[i][j][2] = a[j].c;
			if(i != j){
				for (LL k = j - 1; k >= i; --k) {
					if(check(k , j , 1 , 1)) f[i][j][0] = max(f[i][j][0] , f[i][k][0] + a[j].a);
					if(check(k , j , 1 , 2)) f[i][j][1] = max(f[i][j][1] , f[i][k][0] + a[j].b);
					if(check(k , j , 1 , 3)) f[i][j][2] = max(f[i][j][2] , f[i][k][0] + a[j].c);
					if(check(k , j , 2 , 1)) f[i][j][0] = max(f[i][j][0] , f[i][k][1] + a[j].a);
					if(check(k , j , 2 , 2)) f[i][j][1] = max(f[i][j][1] , f[i][k][1] + a[j].b);
					if(check(k , j , 2 , 3)) f[i][j][2] = max(f[i][j][2] , f[i][k][1] + a[j].c);
					if(check(k , j , 3 , 1)) f[i][j][0] = max(f[i][j][0] , f[i][k][2] + a[j].a);
					if(check(k , j , 3 , 2)) f[i][j][1] = max(f[i][j][1] , f[i][k][2] + a[j].b);
					if(check(k , j , 3 , 3)) f[i][j][2] = max(f[i][j][2] , f[i][k][2] + a[j].c);//枚举3*3=9种堆法进行转移
				}
			}
			F[i][j] = F[i][j - 1];
			F[i][j] = max(max(F[i][j] , f[i][j][0]) , max(f[i][j][1] , f[i][j][2]));//归纳
		}
	}
	for (LL k = 1; k <= m; ++k) {
		for (LL i = k; i <= n; ++i) {
			for (LL j = i; j <= n; ++j) {
				dp[j][k] = max(dp[j][k] , dp[i - 1][k - 1] + F[i][j]);
			}
		}
	}
	printf("%lld" , dp[n][m]);
	return 0;
}

```

---


# [IOI 2005] mea

## 题目描述

考虑一个非递减的整数序列 $S_1,\cdots,S_{n+1}$ ($S_i \le S{i+1}$，$1 \le i \le n$)。 序列 $M_1 \cdots M_n$ 是定义在序列 $S$ 的基础上，关系式为 $M_i = \frac{S_i + S_{i+1}}{2  }$（$1 \le i < n$）, 序列 $M$ 叫做序列 $S$ 的平均数序列。


例如序列 $1,2,2,4$ 的平均数序列为 $1.5,2,3$. 注意到平均数序列中的元素可能为小数。但是本题的任务只是处理平均数序列都为整数的情况。 

给出一个 $n$ 个数字的非递减的整数序列 $M_1,M_2,\cdots,M_n$。请你计算出：序列 $S_1,\cdots,S_{n+1}$ 的平均序列是 $M_1,\cdots,M_n$。 求满足以上条件的序列 $S$ 的总个数。

任务：从标准输入文件中读入一个非递减的整数序列。计算出平均序列是给出序列的整数序列的总个数。把计算结果写到标准输出文件中。

## 说明/提示

**样例说明**

一共存在 $4$ 种序列，它们的平均数序列都是 $2,3,9$。这四种序列如下：
- $2,2,8,10$
- $1,3,7,11$
- $0,4,6,12$
- $-1,5,5,13$

**数据范围**

对于 $50\%$ 的数据，$2 \le n \le 1000$，$1 \le M_i \le 2 \times 10^4$；

对于 $100\%$ 的数据，$2 \le n \le 5 \times 10^6$，$1 \le M_i \le 10^9$。

## 样例 #1

### 输入

```
3
2
5
9
```

### 输出

```
4
```

# 题解

## 作者：BqtMtsZDnlpsT (赞：8)

[传送门P5847](https://www.luogu.com.cn/problem/P5847)

思维题。

首先我们考虑，知道了 $S_1$ 就能根据 $M_1$ 推出 $S_2$ 的值，知道了 $S_2$ 就能根据 $M_2$ 推出 $S_3$ 的值，以此类推，所以，知道一个符合范围的 $S_1$，就能求出一个解，具体如下。

$(S_1+S_2)\div 2=M_1\longrightarrow S_2=2\times M_1-S_1$

$(S_2+S_3)\div 2=M_2\longrightarrow S_3=2\times M_2-S_2$

$(S_3+S_4)\div 2=M_1\longrightarrow S_4=2\times M_3-S_3$

$...$

$(S_i+S_{i+1})\div 2=M_1\longrightarrow S_{i+1}=2\times M_{i}-S_{i}$

把 $S_2,S_3...S_{n+1}$ 分别用 $S_1$ 表示得：


$S_2=2\times M_1-S_1$

$S_3=2\times M_2-2\times M_1+S_1$

$S_4=2\times M_3-2\times M_2+2\times M_1-S_1$

$...$

$S_i=\left\{\begin{matrix}
2\times(M_1-M_2+M_3-M_4+\cdot\cdot\cdot+M_{i-1})-S_1 & (i \bmod 2=0)\\ 
2\times(-M_1+M_2-M_3+\cdot\cdot\cdot+M_{i-1})+S_1 & (i \bmod 2=1)
\end{matrix}\right.$


即 $S_i=\left\{\begin{matrix}
2\times(M_1-M_2+M_3-M_4+\cdot\cdot\cdot+M_{i-1})-S_1 & (i \bmod 2=0)\\  
-2\times(M_1-M_2+M_3-M_4+\cdot\cdot\cdot-M_{i-1})+S_1 & (i \bmod 2=1)
\end{matrix}\right.$

此时，在题目中我们发现一个还没用过的东西：$S_i\le S_{i+1}$。

于是我们考虑对于每个 $i(1\le i\le n)$ 把 $S_i$、$S_{i+1}$ 带入不等式。

$S_1\le S_2 \longrightarrow S_1\le2\times M_1-S_1 \longrightarrow S_1\le M_1$

$S_2\le S_3 \longrightarrow 2\times M_1-S_1 \le 2\times(M_2- M_1)+S_1 \longrightarrow 2\times(2\times M_1-M_2)\le 2\times S_1 \longrightarrow 2\times M_1-M_2\le S_1$

就像这样，我们可以得到式子：

$S_{i}\le S_{i+1} \longrightarrow \left\{\begin{matrix}
S_1\ge 2\times(M_1-M_2+M_3-M_4+\cdot\cdot\cdot+M_{i-1})-M_{i} & (i \bmod 2=0)\\ 
S_1\le 2\times (M_1-M_2+M_3-M_4+\cdot\cdot\cdot-M_{i-1})+M_i& (i \bmod 2=1)
\end{matrix}\right.$

然后就可以根据每个 $i$ 的不等式得到一个关于 $S_1$ 不等式组，解出这个不等式组即为 $S_1$ 的取值范围，得到 $S_1$ 的取值范围后，因为确定 $S_1$ 即可确定一组解，所以 $S_1$ 的取值范围中整数个数即为所求。

对于这个不等式组，我们发现可以前缀和处理，然后对于奇数的 $i$ 更新答案区间右端点，对于偶数的 $i$ 更新答案区间左端点，设左端点为 $l$，右端点为 $r$，答案即为 $r-l+1$，但是考虑不等式组无解，不能输出负数，应输出 `0`。

代码（很短）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define int long long
using namespace std;
int n,l,r,s[5000005],m[5000005];
signed main()
{
	scanf("%lld",&n);
	l=-9223372036854775807,r=9223372036854775807;
	for(int i=1;i<=n;i++)scanf("%lld",&m[i]);
	for(int i=1;i<=n;i++){//前缀和 
		if(i&1)s[i]=s[i-1]+m[i];
		else s[i]=s[i-1]-m[i];
	}
	for(int i=1;i<=n;i++){//求左、右端点 
		if(i&1)r=min(r,(s[i-1]<<1ll)+m[i]);
		else l=max(l,(s[i-1]<<1ll)-m[i]);
	}
	printf("%lld",max(r-l+1,0ll));
	return 0;
}
```

---

## 作者：dztlb (赞：4)

~~怎么所有人都在奇偶性，论题解的同质化~~

其他题解所谓的奇偶性、前缀和，本质上是递推不等式时的变号。

我们在 $m_i$ 处考虑 $a_i,a_{i+1}$ 的关系。

已知条件 
- $a_i+a_{i+1}=2 m_i$
- $a_i \leq a_{i+1}$

若 $a_i$ 的取值范围是 $[l,r]$

由 $l \leq 2 m_i -a_{i+1} \leq r$ 得 $2m_i-r \leq a_{i+1} \leq2m_i-l$。

由 $2 m_i-a_{i+1} \leq a_{i+1}$ 得 $m_i \leq a_{i+1}$。

我们就得到了考虑 $m_i$ 限制下的 $a_{i+1}$ 取值范围 $[\max(m_i,2m_i-r),2m_i-l]$。

一开始令 $a_1$ 的取值范围为 $[-\inf,\inf]$，最终得到的 $a_{n}$ 的取值范围就是考虑了所有 $m$ 限制的范围。

因为序列 $a$ 中任意元素确定就可以唯一确定整个序列，所以该取值范围中的整数数量为答案。答案为 $\max(r-l+1,0)$。

以上过程时间复杂度 $O(n)$，且空间可以 $O(1)$。~~显然与奇偶分类无关~~

```cpp
#define int long long
const int N=5e6+5;
int n,l,r,m;
signed main(){
    scanf("%lld",&n);
    l=-4000000000ll,r=4000000000ll;
    for(int i=1;i<=n;++i){ 
        scanf("%lld",&m);
        swap(l,r);
        l=max(m,2*m-l),r=2*m-r;
    }
    cout<<max(r-l+1,0ll);
    return 0;
}
```



---

## 作者：xin700 (赞：2)

最先考虑暴力，发现完全行不通，所以，我们考虑其他方法。突然发现：**其实在确定 $s_1$ 的时候，整个序列就可以确定了，所以我们考虑对 $s_1$ 进行操作**

之后我们的任务就是找出 $s_1$ 的关系，刚开始我寻找了 $s_1$ 与 $2^n$ 之间的关系，但是没有发现有什么关系，之后经过仔细分析题目，并且手玩了好长一段时间，终于发现这个 $s_1$ 的取值与其奇偶性有着密切的关系。~~所以手玩样例还是十分重要的~~

还有一点需要注意的，就是注意在答案为负的情况下判 0。

附上代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#define int long long
using namespace std;
namespace xin_io
{
	inline int get()
	{
		int s = 0,f = 1;
		register char ch = getchar();
		while(!isdigit(ch))
		{
			if(ch == '-') f = -1;
			ch = getchar();
		}
		while(isdigit(ch))
		{
			s = s* 10 + ch - '0';
			ch = getchar();
		}
		return s * f;
	}
	inline void openfile()
	{freopen("t.txt","r",stdin);}
	inline void outfile()
	{freopen("o.txt","w",stdout);}
}
using xin_io::get; using xin_io::openfile; using xin_io::outfile;
namespace xin
{
	int mx = 1ll<<60ll,mn = -mx;
	int now,i,x,y,n;
	inline short main()
	{
		n = get();
		for (i = 1; i <= n; ++i, y = x) 
		{
			x = get();
			if (i & 1) now += x - y,mx = min(mx, now);
			else now += y - x,mn = max(mn,now);
		}
		printf("%lld\n", mx < mn ? 0 : mx - mn + 1);
		return 0;
	}
}
signed main() {return xin::main();}
```

---

## 作者：xuan_gong_dong (赞：1)

## 题面

[P5847 [IOI2005] mea](https://www.luogu.com.cn/problem/P5847)

## 分析
不妨将题面中的 $M_i = \frac{S_i + S_{i+1}}{2}$ 转换为 $S_{i+1} = 2 \times M_i - S_i$，由此很容易发现如果知道了 $S_i$，那么后面的每一项都可以从前面的一项转换过来。于是题意就被我们转换为了有多少种合法 $S_1$（即 $S_1$ 的取值范围）。

再读一遍题意，发现会有一个关系 $S_i \le S_{i+1}$，而每一个 $S_i$ 都可以用多个 $M$ 和 $S_i$ 所表示，于是，我们直接用 $n$ 个 $S_i \le S_{i+1}$ 就可以不断缩小 $S_1$ 的范围，手搓一下可以发现 $i$ 为偶数时修改的是左端点，$i$ 为奇数时修改右端点。

用一个 $sum$ 记录前面的 $M$ 的和就好了，注意考虑无解情况。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,L=-2e9,R=2e9,sum;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		if(i%2)
			R=min(R,x-2*sum);
		else
			L=max(L,2*sum-x);
		sum=-sum+x;
	}
	if(R-L+1<0)
		printf("0");
	else
		printf("%d",R-L+1);
	return 0;
}
```


---

## 作者：helintai (赞：1)

# P5847题解




## [题目传送门](https://www.luogu.com.cn/problem/P5847)




首先，根据 $M_i=\frac{S_i+S_{i+1}}{2  }$ 我们可以得出 $S_{i+1}=M_i\times2-S_i$，所以根据 $M_1=\frac{S_1 + S_2}{2  }$ 可得 $S_{2}=M_1\times2-S_1$，继而求得 $S_3,\cdots,S_{n+1}$ 整个序列，所以只要确定了 $S_1$ 便可确定整个序列。

经过一番探索，我们可以发现 $S_1$ 的取值与其奇偶性有关，我们便可从这方面入手。

把序列其他数字用 $S_1$ 来表示。

$S_2=2\times M_1-S_1$

$S_3+2\times M_2-2\times M_1+S_1$

## 可以得到：
* 当 $i\mod2=0$ 即 $i$ 是偶数时：
$S_i = 2\times (M_1-M_2+M_3-M_4+\cdots+M_{i-1})-S_1$
* 当 $i\mod2=1$ 即 $i$ 是奇数时：
$S_i=-2\times(M_1-M_2+M_3-M_4+\cdots-M_{i-1})+S_i$

因为 $S_{i+1}\ge S_i$，所以：

* 当 $i\mod2=0$ 即 $i$ 是偶数时：
$S_i \ge 2\times (M_1-M_2+M_3-M_4+\cdots+M_{i-1})-M_1$
* 当 $i\mod2=1$ 即 $i$ 是奇数时：
$-2\times(M_1-M_2+M_3-M_4+\cdots-M_{i-1})+M_i\ge S_i$

## 注意

当最后结果为负数时，应该输出 $ 0 $。

#### 代码如下


```
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define ll long long
#define re register
#define il inline

using namespace std;

il ll read() {
re ll x = 0, f = 1; re char c = getchar();
while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
return x * f; }

const int M = 5000005;
ll n, a[M], m[M], x, y;

int main()
{
	scanf("%lld", &n);
	x = -9223372036854775806;
	y = 9223372036854775807;
	for(int i = 1; i <= n; ++ i) scanf("%lld", &m[i]);
	for(int i = 1; i <= n; ++ i)
	{
		if((i & 1) == 0) a[i] = a[i - 1] - m[i];
		else a[i] = a[i - 1] + m[i];
	}
	for(int i = 1; i <= n; ++ i)
	{
		if((i & 1) != 0) y = min(y, (a[i - 1] * 2) + m[i]);
		else x = max(x, (a[i - 1] * 2) - m[i]);
	}
	ll ans = y - x + 1;
	if(ans > 0) printf("%lld", ans);
	else printf("0");
	return 0;
}

---

## 作者：A6TVhmj (赞：0)

大家可能看了下面的题解很难相处这种方法是如何想出来的，我也想了很久，这一片详细讲一下是我如何想出分析取值范围的思路。完整代码见文末。
## 1. 观察题目
题目最关键的词我认为是**非递减的整数序列**，然后发现我们要求总个数，数据范围 $2\le n \le 5 \times 10^6$。这说明时间复杂度应该为 $O(n)$ 或 $O(n\log n)$。容易想到二分，前缀和等技巧，不知道有没有用。

## 2. 观察样例
看了还是没有思路，或者可以从样例找到启示，样例写的很详细，我们很容易发现可能的数列中首项按顺序排列时连续的，猜想首项应该在一个区间范围内，要求区间的两端点，自己可以构造几组加以验证。

同时，我们也可以发现每个数列中的规律。每一项分别为 $a,4-a,a+6,12-a$。想到知道第一个数就可以求出之后所有数。求首项的取值范围的想法更加明确了。观察数列 $4,6,12$ 和 $2,5,9$ 的联系，首先看不出联系不难想到将前面数列每一项除以 $2$，得到 $2,3,6$。两个数列现在首项相同，联想到差分，发现递推公式就是两个数列各前一项的差，思路明朗了起来。

接着，结合求取值范围这个想法我们就可以想到不等式，由于数列非递减，首项一定小于等于平均数 $2$，即 $S_1 \le 2$，同理看第二项得出 $2 \le S_2 \le 5$，因为 $S_2 = 2\times 2-S_1$，可得 $-1 \le S_1 \le 2$。同样根据后面几项和前面 $4,6,12$ 这个数列（设它为 $B$）可得出：当 $i$ 为小于等于 $n+1$ 的偶数，$B_i-M_i \le S_i \le B_i-M_{i-1}$，当 $i$ 为小于等于 $n+1$ 的奇数，$M_i-B_{i-1} \le S_i \le M_i-B_i$。最终我们取这些区间的最长公共区间接可以了，但是发现矛盾时（如最终得出 $1 \le S_1 \le 0$）要输出 $0$。

## 3. 完整代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=5e6+5;
long long n,a[maxn],b[maxn],mn=-9e18,mx=9e18;
int main(){
	ios::sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    b[2]=2*a[1];
    for(int i=3;i<=n+1;i++)b[i]=2*(a[i-1]-b[i-1]/2);
    mx=a[1];
    for(int i=2;i<=n;i++){
		if(i&1){
    		mn=max(mn,a[i-1]-b[i]);
        	mx=min(mx,a[i]-b[i]);
		}else{
			mn=max(mn,b[i]-a[i]);
        	mx=min(mx,b[i]-a[i-1]);
		}
    }
    cout<<(mx-mn+1>0?mx-mn+1:0);
    return 0;
}
```

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5847)

# 题目分析
先把题目中给的平均数公式变形，得到：

$$s_i+s_{i+1}=2M_i$$

有了这个式子我们还是无法直接解出，因为题目的直接问题是求这样的 $s$ 数列的总数。

那么如何求方案数呢？通常考虑搜索。但是想在 $O(n)$ 的时间内暴力搜出答案显然不太可能。

我们深入分析一下题目。可以发现一点：如果确定了 $s_1$，后面的 $n$ 项是唯一的，也就是说方案总数等价于第一项的取值个数。所以考虑求出第一项的取值范围。

考虑一下， $s_i$ 的值满足什么呢？显然 $s_i \le M_i$ 且 $s_{i+1} \ge M_i$。

我们对每一项赋予一个上限 $max_i$ 和一个下限 $min_i$，则 $min_i \le s_i \le max_i$。那么答案就是 $max_1-min_1+1$。

考虑如何求每一项的上限和下限：首先明确下限受哪些因素影响，上限受哪些因素影响。显然，下限受前一个元素的上限和上一个 $M$ 值的影响，即 

$$min_i=2M_{i-1}-max_{i-1}$$

我们又发现，上限受前一个元素的下限、上一个 $M$ 值和当前 $M$ 值的影响，通常情况下，

$$max_i=2M_{i-1}-min_{i-1}$$

但是，在特殊情况下会出现错误，即上述 $max_i>M_i$ 的情况，因此正确算法应为

$$max_i=\min(2M_{i-1}-min_{i-1},M_i)$$

下面考虑如何求解最终的答案。首先，可以得出以下结论：
1. $max_1=min_2=M_1$
2. $max_2=M_2$，这是因为 $min_1$ 未求出，无法使用。
3. $min_1=2M_1-max_2$，这是因为 $min_1+max_2=2M_1$。
4. 初始时答案 $ans=max_1-min_1+1$。

当我们看到特殊情况出现时，就要对 $ans$ 进行修改。我们注意到，如果 $max_i$ 减少 $k$，$min_{i-1}$ 就会增加 $k$，$max_{i-2}$ 会减少 $k$，以此类推。所以最后的答案无论是 $min_1$ 增加了 $k$ 还是 $max_1$ 减少了 $k$，答案都减少了 $k$。因此最后一个公式：当特殊情况出现时,答案减少 $2M_{i-1}-min_{i-1}-M_i$。

# 代码

```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define N 5000050
using namespace std;
struct points{
	long long sj,xj;
}p[N];
long long a[N],ans=inf;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	p[1].sj=p[2].xj=a[1];
	p[2].sj=a[2];
	p[1].xj=a[1]*2-p[2].sj;
	ans=p[1].sj-p[1].xj+1;
	a[n+1]=inf;
	for(int i=3;i<=n+1;i++){
		p[i].xj=a[i-1]*2-p[i-1].sj;
		p[i].sj=a[i-1]*2-p[i-1].xj;
		if(a[i]<p[i].sj){
			ans-=p[i].sj-a[i];
			p[i].sj=a[i];
		}
	}
	cout<<max((long long)0,ans);
	return 0;
} 
```

---

## 作者：Autream (赞：0)

#### 题意简述
考虑一个非递减的整数序列 $S_1,\cdots,S_{n+1}$ ($S_i \le S{i+1}$，$1 \le i \le n$)。 序列 $M_1 \cdots M_n$ 是定义在序列 $S$ 的基础上，关系式为 $M_i = \frac{S_i + S_{i+1}}{2  }$（$1 \le i < n$），序列 $M$ 叫做序列 $S$ 的平均数序列。

现给出序列 $M$，求出有多少个满足条件的序列 $S$。

---
#### 题目分析
容易发现一个结论：对于序列 $S$，只要确定了 $S_1$，就确定了一个序列。这个问题就转换为求 $S_1$有多少种取值。

不妨设 $S_i \in [l,r]$。

$\because l \leq S_i \leq r$ 且 $S_i+S_{i+1}=2M_i$

$\therefore l \leq 2M_i-S_{i+1} \leq r$

$\therefore l-2M_i \leq -S_{i+1} \leq r-2M_i$

即 $2M_i-r \leq S_{i+1} \leq 2M_i-l$

$\therefore S_{i+1} \in [2M_i-r,2M_i-l]$

$\because S_i+S_{i+1}=2M_i$ 且 $S_i \leq S_{i+1}$

$\therefore S_{i+1} \geq M_i$

$\therefore S_{i+1} \in [\max(M_i,2M_i-r),2M_i-l]$

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=1e5+5;
int n;
signed main() {
    std::cin>>n;
    int l=LLONG_MIN,r=LLONG_MAX;
    rep(i,1,n) {
        int m;
        std::cin>>m;
        std::swap(l,r);
        l=std::max(m,2*m-l),r=2*m-r;
    }
    std::cout<<std::max((r-l+1),0ll);
    return 0;
}
```

---


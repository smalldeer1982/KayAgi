# [POI 2004] MOS

## 题目背景

一个夜晚一些旅行者想要过桥。

## 题目描述

他们只有一个火把。
- 火把的亮光最多允许两个旅行者同时过桥。
- 没有火把或者多于 $2$ 个人则不能过桥。

每个旅行者过桥都需要特定的时间，两个旅行者同时过桥时时间应该算较慢的那个。现在我们想知道所有旅行者最少要花费多少时间才能全部过桥?

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le10^5$，过桥时间均不超过 $10^9$。

## 样例 #1

### 输入

```
4
6
7
10
15```

### 输出

```
42```

# 题解

## 作者：kkxacj (赞：16)

### [P5914 题目传送门](https://www.luogu.com.cn/problem/P5914)
#### 题意
一些旅行者想要过桥，他们只有一个火把。

火把的亮光最多允许两个旅行者同时过桥。

没有火把或者多于 $2$ 个人则不能过桥。

每个旅行者过桥都需要特定的时间，两个旅行者同时过桥时时间应该算较慢的那个。

所有旅行者最少要花费多少时间才能全部过桥?

#### 思路
思考一下可以发现，这道题可以模拟，一共有两种过桥方案：

1. 最快的人 $a_{i}$ 拿着火把接最慢的人 $a_{j}$，一个来回需要花 $a_{1} \times 2 + a_{n} + a_{n- 1}$ 秒。

1. 最快的人 $a_{i}$ 把火把给最慢和次慢的人 $a_{j}$ 和 $a_{j - 1}$，再让第二块的人去接最快的，一个来回需要花 $a_{1} + a_{2} \times 2 + a_{n}$ 秒。



#### 注意： 

 1. 在 $n < 2$ 时，第一个和第二个必须是一起走，要在后面再算！
 1. $n$ 可能为 $1$，要特判！
 
 1. 对于 $100\%$ 的数据，$1\le n\le10^5$，过桥时间均不超过 $10^9$。要开  long long!

 ~~做完这题可以去做做 [P1809](https://www.luogu.com.cn/problem/P1809)~~

code
```c
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000005],sum; //数组开大点
int main()
{
	scanf("%lld",&n); //cin >> n
    for(int i = 1;i <= n;i++)
        scanf("%lld",&a[i]); //cin >> a[i]
    sort(a + 1,a + n + 1);
    if(n <= 2) //特判
	{
        cout << a[n];
        return 0;
    }
    while(n > 3)
    {
        sum += min(a[1] * 2 + a[n] + a[n - 1],a[1] + a[2] * 2 + a[n]);
        n -= 2;
    }
    if(n % 2 == 0)
    	sum += a[2];
    else 
    	sum += a[1] + a[2] + a[n];
    printf("%lld",sum);
    return 0;
}
```


---

## 作者：FLY_lai (赞：6)

一道练习贪心证明的好题。

绝大多数题解只是点出了以下结论：

> 要么最快的带最慢的；要么最慢的带次慢的。

并没有给出证明。我就补上这个证明。

为了证明这个贪心结论，我们先证明几个引理。

引理一：每次将火把带回来的，一定是对岸最快的。

引理一证明：如果回来的不是对岸最快的，让对岸最快的人代替这个回来的人的一切行动，发现答案至少不差。

引理二：最慢的人要么和最快的人一起过桥，要么和次慢的人一起过桥。

引理二证明：

为了方便表述，记最快的人为 $a_1$，次快的人为 $a_2$，以此类推，次慢的人为 $a_{n-1}$，最慢的人为 $a_n$。

设 $a_n$ 是与 $a_p$ 一起过桥，$a_{n-1}$ 是与 $a_q$ 一起过桥。

我们有一个调整法的思路：让 $a_{n-1}$ 和 $a_n$ 一起过桥，让 $a_p$ 与 $a_q$ 一起过桥。

显然这样调整后这两次过桥的时间总和变少了。但是现在就得证是错误的。因为我们不确定改变过桥顺序是否会影响其他的过桥。

我们这样调整后唯一可能造成的影响是：如果我们希望 $a_p$ 把火把送回来，那 $a_{n-1}$ 和 $a_n$ 一起过桥就会产生阻碍。

在这种情形下，尝试证明 $a_p=a_1$ 最优。

假设 $a_p\ne a_1$，我们令 $a_p\leftarrow a_1$，容易发现，$a_n$ 和 $a_p$ 过桥时间不变，而 $a_p$ 带着火把回来时间至少不变，可能更优。

综上所述，最慢的人每次过桥，要么和最快的人一起，要么和次慢的人一起。

最后的结论：要么 $a_1$ 和 $a_n$ 过桥，$a_1$ 回来；要么 $a_1,a_2$ 先过桥，$a_1$ 回来，然后 $a_{n-1},a_n$ 过桥，$a_2$ 回来。

证明：考虑 $a_n$ 和谁过桥。如果 $a_n$ 和 $a_1$ 过桥，由引理一，过桥后一定是 $a_1$ 回来。

如果 $a_n$ 和 $a_{n-1}$ 过桥，假设是由 $a_k$ 送回火把。因为 $a_k$ 总是有一次过去、一次送回火把、一次回到对岸的过桥旅程，所以 $a_k$ 会贡献至少三次时间至少为 $a_k$ 的过桥。

如果我们先让 $a_1,a_2$ 过桥，$a_1$ 回来，让 $a_2$ 送回 $a_n,a_{n-1}$ 带过去的火把。这种方法贡献了 $a_1+2a_2$ 的时间，$a_1+2a_2\le 3a_k$，更优。

以上我们证明了这种方法的正确性。如果我还有考虑不周的地方，欢迎评论指出。

代码就不贴了。有了这个结论，每次看一下送走当前 $a_n,a_{n-1}$ 花费更少的是哪种，不停选就是了。

~~给个关注呗~~

---

## 作者：decoqwq (赞：4)

Orz jiangly(

这题一开始根本看不懂样例![](https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/qq/%E5%8F%AF%E6%80%9C.gif)，还好 jiangly 给小萌新讲了一下，所以我先 Orz jiangly

然后说一下这道题(，读懂样例后显然发现，比较优秀的方式有两种，第一个是最快的和最慢的一起去，最快的拿火把回来，第二种是最快和第二快一起去，最慢和第二慢一起去，两次分别是最快和第二快回来，并不是每次选最快最慢的一起走，因为留在那边的可能会有走回来较快的，我们有时候也需要让两个时间尽量长的一起走

就考虑用这两种方式转移即可，令 $dp[i]$ 代表剩下 $i$ 个人没过桥的最小时间，从后往前 $dp$ ，转移方程即 $dp[i]=\min(dp[i+1]+t[1]+t[2],dp[i+2]+t[1]+t[2]+t[2]+t[i+2])$

然后就完了qwq

---

## 作者：风之影音 (赞：3)

本弱鸡的第6篇题解
~~（也不知道之前的算不算）~~

还是那句话，如有雷同，纯属巧合。

这道题是我无意间点进去的。发现这道题还行，就试着编了编。总之，一句话：
# **十年oi一场空，不开longlong见祖宗！**

就因为longlong的事我想了半天。

废话说够了，上代码。
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long a[1000005],b[1000005];//坑人！要开longlong，还要把数组开大！
int main(){
    long long n;//十年oi一场空，不开longlong见祖宗！
    cin>>n;//输入
    long long sum=0;//计数器
    for(long long i=1;i<=n;i++)//循环也要longlong
        cin>>a[i];//输入
    if(n<=2){//如果n<2
        cout<<a[n];//直接输出
        return 0;
    }
    b[n]=a[n]+a[1];
    for(int i=n-1;i>=1;i--)//倒着循环
        b[i]=min(a[i]+a[1]+b[i+1],a[i+1]+2*a[2]+a[1]+b[i+2]);//比较最小值
    cout<<b[3]+a[2];//输出
    return 0;//养成好习惯
}
```
~~我码风不错吧？~~
详细内容看代码，溜啦溜啦~~~


---

## 作者：Vamper (赞：2)

	对于本题，观察题目后得到的第一种贪心策略就是让第一个人来回跑将每个人送过去
    
    但是可以很显然的发现，这种策略连样例都过不了
    
    仔细观察样例可以发现，其实整个状态有两种贪心策略：
    
   1. **让最快的人和最慢的人先过去，然后让最快的人送回火把**
   
   1. **让最快和第二快的人先过去，让第一快的人送回火把，再让最慢的人和第二慢的人一起过去让第二快的人把火把送回来**
   
   第一种一次只能通过一个人，第二种却可以一次通过两个
   
   **解释**：第一种是尽可能快的让最慢的过去，第二种是可以节省一个第二慢的时间，所以两种策略均可行
   
   因为讨论的是如何将最慢的先运过去，所以$dp$时应该倒着来
   
   设 $dp[i]$ 是从第$n$个人开始从后往前送，送到了第$i$ 个人这里了的最短时间
   
   那么易得转移方程为$dp[i]=max(dp[i+1]+t[1]+t[i],dp[i+2]+t[1]+t[2]+t[2]+t[i+1])$
   
###    AC代码
```cpp
#include<bits/stdc++.h>
#define re register
#define FOR(i,a,b) for(re int i=(a),i##i=(b);i<=i##i;i++)
#define ROF(i,a,b) for(re int i=(a),i##i=(b);i>=i##i;i--)
#define File(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
#define N 100010
using namespace std;
int n;
long long peo[N];
long long dp[N];
int main() {
	File("mos");
	cin>>n;
	FOR(i,1,n) cin>>peo[i];
	dp[n]=peo[n]+peo[1];
	if(n<=2) cout<<peo[n];
	else {
		ROF(i,n-1,0) 
		dp[i]=min(dp[i+1]+peo[1]+peo[i],dp[i+2]+peo[1]+peo[2]+peo[2]+peo[i+1]);
		cout<<dp[3]+peo[2];
	}
	return 0;
}
```

---

## 作者：liuxy1234 (赞：1)

这道题其实就是小学奥数，有 $2$ 种方法：

1. 快者来回

	就是最快的人送最慢的过去再回来。
    
2. 慢者同行
	
    就是第 $1$ 和 $2$ 快的人过去，最快的人回来，再让最慢的两个人过去，第二快的再回来。
    
分析完之后，我们就可以写代码了。


```cpp
#include<iostream>
#define int long long
using namespace std;

const int maxn=100005;
int n,a[maxn];
int dp[maxn];

signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	dp[n]=a[n]+a[1];
	for(int i=n-1;i>=1;i--)
	{
	   dp[i]=min(a[i]+a[1]+dp[i+1],a[i+1]+2*a[2]+a[1]+dp[i+2]);
	}
	cout<<dp[3]+a[2];
	return 0;
}
```


---

## 作者：V1mnkE (赞：0)

很明显的贪心，有两种策略：

- **让最快的人和最慢的人先过去，然后让最快的人送回火把。**

- **让最快和第二快的人先过去，让第一快的人送回火把，再让最慢的人和第二慢的人一起过去让第二快的人把火把送回来。**

第一种就是让最慢的尽快过去，第二种是让两个最慢的尽快过去。

**温馨提示：十年oi一场空，不开 long long 见祖宗。**

状态转移方程：$ans_i= \min (ans_{i+1}+t_1+t_i, ans_{i+2}+t_1+t_2\times 2 +t_{i+1})$

由于是从小到大排列，所以我们要倒着枚举。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t[100005],ans[100005],n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>t[i];
	ans[n]=t[n]+t[1];
	for(int i=n-1;;i--){
		if(i<=2)cout<<ans[3]+t[i],exit(0);
    	ans[i]=min(ans[i+1]+t[1]+t[i],ans[i+2]+t[1]+2*t[2]+t[i+1]);
    }
    return 0;
}
```


---

## 作者：zhh090409 (赞：0)

### 第一篇题解，还望通过

这道题虽然是明显的贪心题，但由于我脑袋一抽……还是不提为好。

首先分析题意。相信很多人都会每次让最快的人陪最慢的，再送火把回去（工具人？），但手算就可以发现，这种策略连样例都过不了（我就栽了好几次）。那么可以推出第二种策略：

由于第一种策略是一次送最慢的一个人先走，那么自然可以想到，可不可以让最慢的两个人送走呢？答案是肯定的。可以先让当前最快的两个过去，然后把火把送回来（最快的送），再让最慢的两个过去，火把再送来（第二快的送），两个最慢的就过去了。

结合前一种策略就可以得出公式了。

```

ans[i]=min(ans[i+1]+t[1]+t[i],ans[i+2]+t[1]+2*t[2]+t[i+1]);

```
最后再把 $ans_3+t_2$ 输出就好了（$n<=2$ 直接输出 $a_n$）。

代码如下（配注释）：

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n;
long long t[100001],ans[100001];//不开long long见祖宗！！！
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>t[i];//输入没毛病
	ans[n]=t[n]+t[1];//首先要将最慢的送过去，也就是第一个策略
	for(int i=n-1;;i--)//从后往前循环贪心
	{
		if(i<=2)
		{
			cout<<ans[3]+t[i];//只剩2个人就直接送，再加上之前的时间输出
			return 0;
		}
                ans[i]=min(ans[i+1]+t[1]+t[i],ans[i+2]+t[1]+2*t[2]+t[i+1]);
    }
    return 0;
}
```


---

## 作者：JAMES__KING (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P5914)

## 题目分析

1.首先考虑让走得最快的人来回送火把，依次把第二快、第三快的人送过去，最后再把走得最慢的人送到对岸。可是模拟了样例，却发现连样例也过不了，于是考虑第二种方法。

2.通过推导样例可以知道，此题有两种最佳策略：
- 当我们需要送火把时，让对岸走得最快的人来。
- 不要让走得慢的人拖后腿，让速度变慢。
 
3.根据以上的最佳策略可得出两种方法：
- 让走得最快的人和走得最慢的人先过去，然后让走得最快的人送火把回来。
- 让走得最快的人和第二快的人先过去，让走得最快的人送回火把，再让走得最慢的人和第二慢的人一起过去让走得第二快的人把火把送回来。

## 坑点：
1. 数组、数据要开大。
1. 从小到大排列，所以请记得要倒着枚举。

根据上述方法，便可以完成代码了。

## 慷慨的亮出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005],f[100005],n;
int main()
{
    cin>>n;
    for(long long i=1;i<=n;i++) cin>>a[i];
    f[n]=a[1]+a[n];
    for(long long i=n-1;i>=1;i--)//从大到小枚举
        f[i]=min(a[i]+a[1]+f[i+1],a[i+1]+a[1]+a[2]*2+f[i+2]);//状态转移方程
    cout<<f[3]+a[2];
    return 0;
}
```


---

## 作者：YuTianQwQ (赞：0)

# 题目解析

这段代码的目标是求解一类特定的优化问题：一群人需要通过一座桥，每次最多两人通过，每人过桥的速度不同。过桥需要用火把，而手电筒只有一只。问题是如何安排过桥顺序使得所有人过桥的总时间最少。

## 解题思路

1. **读取输入**：首先，我们读取输入的人数 `n` 以及每个人过桥的时间 `t`。

    ```cpp
    cin >> n;
    vector<int> t(n);
    for (int i = 0; i < n; ++i) cin >> t[i];
    ```

2. **排序**：为了方便处理，我们将所有人的过桥时间从小到大排序。

    ```cpp
    sort(t.begin(), t.end());
    ```

3. **计算最小过桥时间**：我们通过一个贪心策略来计算最小的过桥时间。每次选择最快的两个人先过桥，然后让最快的人带着手电筒返回，再让剩下的两个最慢的人过桥，最后再让最快的人带着手电筒返回。这个过程反复进行，直到所有的人都过桥为止。

    ```cpp
    int ans = 0;
    while(n > 3)
    {
        ans += min(t[0] + 2 * t[1] + t[n - 1], 2 * t[0] + t[n - 2] + t[n - 1]);
        n -= 2;
    }
    if(n == 3) ans += t[0] + t[1] + t[2];
    else if (n == 2) ans += t[1];
    else ans += t[0];
    cout << ans << endl;
    ```

总的来说，这段代码通过使用一种贪心策略，寻找一个过桥顺序使得所有人过桥的总时间最少。

# 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin >> n;
    vector<int> t(n);
    for(int i = 0; i < n; ++i) cin >> t[i];
    sort(t.begin(),t.end());
    int ans = 0;
    while(n > 3)
    {
        ans+=min(t[0]+2*t[1]+t[n-1],2*t[0]+t[n-2]+t[n-1]);
        n-=2;
    }
    if(n == 3) ans += t[0] + t[1] + t[2];
    else if (n == 2) ans += t[1];
    else ans += t[0];
    cout << ans << endl;
    return 0;
}


---


# [POI 1999] 地图

## 题目背景

一个人口统计办公室要绘制一张地图。

## 题目描述

由于技术的原因只能使用少量的颜色。两个有相同或相近人口的区域在地图应用相同的颜色。例如一种颜色 $k$，则 $A(k)$ 是相应的数，则有：
- 在用颜色$k$的区域中至少有一半的区域的人口不大于 $A(k)$。
- 在用颜色$k$的区域中至少有一半的区域的人口不小于 $A(k)$。

区域颜色误差是该区域的人口与 $A(k)$ 差的绝对值。累计误差是所有区域颜色误差的总和。我们要求出一种最佳的染色方案，使得累计误差最小。

## 说明/提示

对于 $100\%$ 的数据，$10< n <3000$，$2 \le m \le 10$。

## 样例 #1

### 输入

```
11
3
21
14
6
18
10
2
15
12
3
2
2```

### 输出

```
15```

# 题解

## 作者：youyou2007 (赞：10)

## 一、思路

### 1、朴素转移
这题题目都讲了区间，明显的**区间DP**......

令$f[i][j]$ 表示考虑了前$i$ 个区域，已经用了$j$ 种颜色的最小误差

则枚举 $k$, $f[i][j]$ 一定是从前k个区间的最小值再加上从$k+1$ 至 $i$ 的区间误差，

#### 状态转移方程式：$f[i][j] = min(f[i][j], f[k][j - 1] + color(k + 1, i))$ ，其中$color$ 即为区间误差之和。

##### 时间复杂度：$O(N ^ 3M)$

~~很明显，这个巨大的复杂度会T飞，所以需要一些优化~~
### 2、求值优化
再思考优化$color$ ，可以先前缀和$sum$ 求出每一段的人口数，而中位数即为排好序后中间两个数的平均数。

所以区间误差之和不难得出，可以得到以下$O(1)$ 的柿子：

$a[mid] * (mid - l) - sum[mid - 1] + sum[l - 1] - a[mid] * (r - mid) + sum[r] - sum[mid]$ ，（其中mid即为中间那个**位置**，不是中位数！）

所以可以把这一个柿子单独写个函数拉出来，可以将时间复杂度优化到$O(N ^ 2M)$

## 二、code
#### 注意开始需要先排序，这样求中位数可以优化。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3005;
const int M = 15;
int n, m;
int f[N][M], sum[N], a[N];
int color(int l, int r)
{
	int mid = (l + r) / 2;//求中位数的位置
	return a[mid] * (mid - l) - sum[mid - 1] + sum[l - 1] - a[mid] * (r - mid) + sum[r] - sum[mid]; //O(1)优化
}              
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; i++)
	{
		sum[i] = sum[i - 1] + a[i];//前缀和预处理
	}
	memset(f, 0x3f, sizeof f);//开始全赋最大值
	f[0][0] = 0;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			for(int k = 0; k < i; k++)
			{
				f[i][j] = min(f[i][j], f[k][j - 1] + color(k + 1, i));//转移方程
			}
		}		
	}
	cout << f[n][m];
	return 0;
}
```

---

## 作者：Betrayer_of_love (赞：2)

首先我们很容易想到，要使误差小，先将所有的省区排序，再来考虑将这些省区分段，一段算作一个颜色。


然后设 `f[i][j]` 为前 $i$ 个省区用 $j$ 个颜色的最小误差， `W[i][j]` 设为 $i \sim j$ 省区为同个颜色会带来的误差，先通过前缀和把 $w$ 数组处理好，然后用一个变量 $k$ 来松弛 $i \sim j$ 这个区间，若 $k+1 \sim i$为同个颜色 ，则 `f[i][j]=\min(f[i]][j],f[k][j-1]+w[k+1][i]]);`
不过前缀和的地方要稍微推一下。

### CODE:


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m, mid, a[3005], w[3005][3005], f[3005][20];
long long s[3005], k1, k2;
int min(int a, int b) {
	if (a > b) return b;
	else return a;
}
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	s[0] = 0;
	for (int i = 1; i <= n; i++) s[i] += s[i - 1] + a[i];
	for (int i = 1; i <= n; i++)
		for (int j = i; j <= n; j++) {
			mid = (i + j + 1) / 2;
			k1 = a[mid] * (mid - i) - (s[mid - 1] - s[i - 1]) + (s[j] - s[mid]) - a[mid] * (j - mid); //把这段区间涂成一个颜色所会带来的误差值
			w[i][j] = k1;
		}
	for (int i = 0; i <= n + 1; i++)
		for (int j = 0; j <= m + 1; j++)
			f[i][j] = 1073741825;
	f[0][0] = 0;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int k = 0; k <= i - 1; k++)
				f[i][j] = min(f[i][j], f[k][j - 1] + w[k + 1][i]); //把它分成两段，k+1~i用一个颜色
	cout << f[n][m] << endl;
	return 0;
}
```

---

## 作者：Alex_Wei (赞：2)

> [*P5929 [POI1999]地图*](https://www.luogu.com.cn/problem/P5929)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/poi.html)。

不难看出区域颜色误差就是一些城市的人口与人口中位数的差的绝对值之和。我们有关键性质：被划分到同一颜色的所有城市一定连续。调整法容易证明。

根据上述性质，考虑一个最朴素的 DP：设 $f_{i, k}$ 表示用 $k$ 种颜色划分前 $i$ 个城市，区域颜色误差之和的最小值。显然有 $f_{i, k} = \min\limits_{j = 0} ^ {i - 1} f_{j , k - 1} + w(j + 1, i)$，其中 $w(i, j)$ 表示城市 $i\sim j$ 的区域颜色误差。

根据上述转移式转移，并预处理人口数量的前缀和从而 $\mathcal{O}(1)$ 计算 $w(i, j)$，可以做到 $\mathcal{O}(mn^2)$，足够通过本题。

可不可以再给力一点啊？可以。

关于贡献函数 $w$，它有非常好的性质：它满足 **四边形不等式**。可以证明对于 $x_1 < x_2 < x_3 < x_4$，有 $w(x_1, x_4) + w(x_2, x_3) \geq w(x_1, x_3) + w(x_2, x_4)$。感性理解即可，证明留给读者。因此这个动态规划满足决策单调性，可以使用 [决策单调性分治](https://www.cnblogs.com/alex-wei/p/DP_optimization_method_II.html) 优化，时间复杂度 $\mathcal{O}(mn\log n)$。

可不可以再给力一点啊？可以。

我们猜测 $f_{n, k}$ 是关于 $k$ 的凸函数，使用 [wqs 二分](https://www.cnblogs.com/alex-wei/p/DP_Involution.html) 和二分队列在 $\mathcal{O}(n\log n\log V)$ 时间内解决，其中 $V$ 是二分值域。

诶，这好像就是 IOI2000 邮局。破案了，IOI 竟然出原题。（那么本题还可以四边形不等式优化至 $\mathcal{O}(n^2)$）。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define mem(x, v) memset(x, v, sizeof(x))
const int N = 3e3 + 5;
ll n, m, g[N], f[N], s[N], x[N];
ll calc(int l, int r) {
	int m = l + r >> 1;
	return x[m] * (m + m - r - l) - (s[m - 1] - s[l - 1]) + (s[r] - s[m]); 
}
void solve(int l, int r, int pl, int pr) {
	int m = l + r >> 1, lim = min(pr, m - 1), p = -1; f[m] = 1e18;
	for(ll i = pl, d; i <= lim; i++)
		if((d = g[i] + calc(i + 1, m)) < f[m])
			f[m] = d, p = i;
	if(l < m) solve(l, m - 1, pl, p);
	if(m < r) solve(m + 1, r, p, pr);
}
int main() {
	cin >> n >> m, mem(f, 0x3f), mem(g, 0x3f), g[0] = 0;
	for(int i = 1; i <= n; i++) cin >> x[i];
	sort(x + 1, x + n + 1);
	for(int i = 1; i <= n; i++) s[i] = s[i - 1] + x[i];
	for(int i = 1; i <= m; i++, swap(f, g)) solve(1, n, 0, n - 1);
	cout << g[n] << endl;
	return 0;
}
```

---

## 作者：wanganze (赞：1)

### 题意
显然需要先按人口数排序（颜色相近的才能作为区间）。

发现 $A(k)$ 即为区间中位数，求点权与对应区间中位数的绝对值之和。

### 思路
考虑 dp。

定义 $f_{i,j}$ 为前 $i$ 个值分 $j$ 段的解。

可以得到区间 dp 转移：

$f_{i,j} = \min(f_{k,j - 1} + \mathrm{calc}(k + 1,i))$

我们计算在 $k$ 处分段的贡献，这里可以斜优，但没必要。

贡献即为区间中各个数字与中位数作差，分前后讨论。前缀和在优化代码里，就不展开了。

### 实现
注意初始化。

复杂度 $O(n^2m)$，可以通过。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3010,M = 20;
int a[N],s[N],f[N][M];
int n,m;
int calc(int l,int r)
{
	int mid = l + r >> 1;
	return a[mid] * (mid - l) - s[mid - 1] + s[l - 1] - a[mid] * (r - mid) + s[r] - s[mid];
}
int main()
{
	cin>>n>>m;
	for(int i = 1; i <= n; i ++) scanf("%d",&a[i]);
	sort(a + 1,a + n + 1);
	memset(f,0x3f,sizeof f);
	f[0][0] = 0;
	for(int i = 1; i <= n; i ++) s[i] = s[i - 1] + a[i];
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= m; j ++)
			for(int k = 0; k < i; k ++) f[i][j] = min(f[i][j],f[k][j - 1] + calc(k + 1,i));
	cout<<f[n][m]<<endl;
	return 0;
}
```

---

## 作者：SunburstFan (赞：1)

### P5929 [POI1999] 地图

#### 题目大意

将一个长度为 $N$ 的序列染成 $M$ 种颜色。

对于一个颜色 $k$，要求染 $k$ 颜色的点权与 $A(k)$ 的差的绝对值尽量地小。

其中 $A(k)$ 定义如下：

- 在染颜色 $k$ 的点中至少有一半的点的权值不大于 $A(k)$。
- 在染颜色 $k$ 的点中至少有一半的点的权值不小于 $A(k)$。

求最小误差。

#### 解题思路

首先看到这个 $A(k)$，这个是什么？

考虑直接将 $a$ 升序排序，令染颜色 $k$ 的最小的点下标为 $l$，最大的点下标为 $r$。

那么 $a_{\frac {l+r}{2}}$ 就是 $A(k)$。

考虑 dp，设 $f_{i,j}$ 表示前 $i$ 个数中用 $j$ 种颜色染色的最小误差。

记 $l$ 与 $r$ 之间的误差为 $calc(l,r)$，就可以得到状态转移：

$f_{i,j} = \min _{k=1}^{i} f_{k-1,j-1} + calc(k,i)$。

如何在 $O(1)$ 内求出 $calc(l,r)$？

令 $md = \frac {l+r}{2}$。

$calc(l,r) = \sum _{i=md+1}^{r} a_i-a_{md} + \sum _{i=l}^{md-1} a_{md}-a_i$。

将 $a_{md}$ 全部提取出来，就可以得到：

$calc(l,r) = \sum _{i=md+1}^{r} a_i -(r-md) \times a_{md}  +(md-l) \times a_{md} - \sum _{i=l}^{md-1} a_i$。

注意到 $\sum _{i=md+1}^{r} a_i$ 和 $\sum _{i=l}^{md-1} a_i$ 都可以用前缀和解决，那么这道题就做完了，最终答案为 $f_{n,m}$。

程序时间复杂度 $O(N^2 \times M)$。

计算 $calc$ 部分：

```cpp
int calc(int l,int r){
    int md=(l+r)>>1;
    int sum1=sum[r]-sum[md];
    int sum2=sum[md-1]-sum[l-1];
    int m1=a[md]*(r-md),m2=a[md]*(md-l);
    return sum1-m1+m2-sum2;
}
```

状态转移部分：

```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        for(int k=1;k<=i;k++){
            f[i][j]=min(f[i][j],f[k-1][j-1]+calc(k,i));
        }
```

---

## 作者：信息向阳花木 (赞：1)

* 资源分配类 dp

思路很简单：

先对地区人口数排序，定义 $f_{i,j}$ 表示前 $i$ 个地区用 $j$ 种颜色的累计误差最小值。接着枚举 $k$，$k$ 到 $i$ 区域用同一种颜色表示。设 $k$ 到 $i$ 地区的累积误差为 $c$。

那么 $f_{i, j}=\sum_{k=1}^i\min(f_{i,j},f_{k-1,j-1}+c)$。

那么怎么求 $c$ 呢？

* $a_i$ 表示地区 $i$ 的人口数，$mid$ 表示 $k$ 到 $i$ 地区人口中位数的下标

$c = (a_{mid} - a_{k}) + (a_{mid} - a_{k + 1}) + ...+ (a_{mid} - a_{mid - 1}) + (a_{mid + 1} - a_{mid}) + ...+ (a_{i} - a_{mid}) = a_{mid} \times (mid - k) - (a_{k} + a_{k + 1}+ ... + a_{mid - 1}) + (a_{mid+1} +  ... + a_{i}) - a_{mid} \times (i - mid)$

这样我们只要预处理一下 $a$ 的前缀和就可以啦。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

using namespace std;

const int N = 3010;

inline void in(int &x)
{
    x = 0; bool f = 0; char c = getchar();
    while(c < '0' || c > '9')
    {
        if(c == '-') f = 1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        x = (x << 3) + (x << 1) + (c & 15);
        c = getchar();
    }
    x = f ? -x : x;
}

inline void out(int x)
{
    if(x < 0) putchar('-'), x = -x;
    if(x / 10) out(x / 10);
    putchar((x % 10) | 48);
}

int n, m;
int a[N], s[N], f[N][20];

int main()
{
    in(n); in(m);
    for (int i = 1; i <= n; i ++ ) in(a[i]);

    sort(a + 1, a + n + 1);

    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i]; //前缀和 

    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;

    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ )
        {
            for (int k = 1; k <= i; k ++ )
            {
                int mid = (k + i + 1) / 2; //中位数 
                int l = abs(s[mid - 1] - s[k - 1] - a[mid] * (mid - k)); //mid 左边累计误差 
                int r = abs(s[i] - s[mid] - a[mid] * (i - mid)); //mid 右边累计误差
                //注意不能合在一起算
                //c = l + r 
                f[i][j] = min(f[i][j], f[k - 1][j - 1] + l + r);
            }
        }
    }
    printf("%d\n", f[n][m]);

    return 0;
}
```

---

## 作者：chihik (赞：1)

至少有一半不小于 $A(k)$ , 至少有一半不大于 $A(k)$

所以 $A(k)$ 应该是选出的区域人口的中位数。

为了使误差尽可能小，每次应该取排序后连续的一段区间染相同颜色。

令 $dp_{i,j}$ 表示使用前 $i$ 种颜色，将前 $j$ 个区域染色的最小误差，$\text{val(l,r)}$ 表示将 $[l,r]$ 染成一个颜色的误差。

那么有：

$$dp_{i,j}=\min\{ dp_{i-1,k-1} + \text{val}(k,j) \} (1 \le k \le j)$$

$\text{val}(l,r)$ 可以分类讨论中位数的值，分成 小于中位数 和 大于中位数 两种情况计算。

这道题中位数好像取不取小数都能过。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define LL long long

const int MAXN = 3000 , MAXM = 10;
int n , m , a[ MAXN + 5 ];
LL Suma[ MAXN + 5 ]; double dp[ MAXM + 5 ][ MAXN + 5 ];

double Val( int l , int r ) {
    int Mid = ( l + r ) >> 1;
    if( ( r - l + 1 ) % 2 ) { //l   Mid    r
        double Mida = a[ Mid ];
        return ( Suma[ r ] - Suma[ Mid - 1 ] - Mida * ( r - Mid + 1 ) ) + ( Mida * ( Mid - l ) - ( Suma[ Mid - 1 ] - Suma[ l - 1 ] ) );
    }
    else { //l   Mid Mid+1    r
        double Mida = ( a[ Mid ] + a[ Mid + 1 ] ) / 2.0;
        return ( Suma[ r ] - Suma[ Mid ] - Mida * ( r - Mid ) + Mida * ( Mid - l + 1 ) - ( Suma[ Mid ] - Suma[ l - 1 ] ) );
    }
}
int main( ) {
    scanf("%d %d",&n,&m);
    for( int i = 1 ; i <= n ; i ++ ) scanf("%d", &a[ i ] );
    sort( a + 1 , a + n + 1 );
    for( int i = 1 ; i <= n ; i ++ ) Suma[ i ] = Suma[ i - 1 ] + a[ i ];

    for( int i = 0 ; i <= m ; i ++ ) for( int j = 0 ; j <= n ; j ++ ) dp[ i ][ j ] = 1e15;

    dp[ 0 ][ 0 ] = 0;
    for( int i = 1 ; i <= m ; i ++ )
        for( int j = 1 ; j <= n ; j ++ )
            for( int k = 1 ; k <= j ; k ++ )
                dp[ i ][ j ] = min( dp[ i ][ j ] , dp[ i - 1 ][ k - 1 ] + Val( k , j ) );
    printf("%.0f\n", dp[ m ][ n ] );
    return 0;
}
```

---

## 作者：Masna_Kimoyo (赞：0)

这是一道斜率优化的弱化版，可以暴力做。

## Solution

为了让差值更小，排序是有必要的。这样能缩小各个元素之间的差。

然后发现数据范围 $O(nm^2)$ 可以过，于是考虑一个暴力的dp

考虑 $dp[i][j]$ 表示 `当前位置 i 为止，已经分了 j 段`

于是就可以套进一个板子:

$dp[i][j]=min(dp[i][j],dp[k][j-1]+calc(k+1,i)$

表示在 `k` 的位置进行了一个分段，然后算段前（已算好）和段后的贡献和

接下来算段后的贡献 $calc(l,r)$ 

由题意，一半小于等于，一半大于等于，所以这时的 $A(k)$ 就是中位数。

所以计算一个序列所有数与中位数作差的和就是答案

前一段：数的和比中位数小，所以倒过来： $a[mid] \times (mid-l)-(sum[mid]-sum[l-1])$

后一段：正常顺序: $sum[r]-sum[mid+1-1]-(a[mid] \times (r-mid))$

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define printlf(x) print(x),putchar('\n')
#define printsp(x) print(x),putchar(' ')
using namespace std;
inline int read(){
    int x=0;
    bool w=0;
    char c=getchar();
    while(!isdigit(c))  w|=c=='-',c=getchar();
    while(isdigit(c))   x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return w?-x:x;
}
inline void print(int x){
    if(x<0) x=-x,putchar('-');
    if(x>9) print(x/10);
    putchar('0'+x%10);
}
const int N=3e3+5;
int a[N],sum[N],dp[N][20];
int n,m;
inline int calc(int l,int r){
    int mid=l+r>>1;
    return a[mid]*(mid-l)-sum[mid-1]+sum[l-1]-a[mid]*(r-mid)+sum[r]-sum[mid];
}
signed main(){
    n=read(),m=read();
    for(register int i=1;i<=n;++i)  a[i]=read();
    sort(a+1,a+n+1);
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;
    for(register int i=1;i<=n;++i)
        sum[i]=sum[i-1]+a[i];
    for(register int i=1;i<=n;++i){
        for(register int j=1;j<=m;++j){
            for(register int k=0;k<i;++k)
                dp[i][j]=min(dp[i][j],dp[k][j-1]+calc(k+1,i));
        }
    }
    print(dp[n][m]);
    return 0;
}
```

希望管理不要吹毛求疵。

---


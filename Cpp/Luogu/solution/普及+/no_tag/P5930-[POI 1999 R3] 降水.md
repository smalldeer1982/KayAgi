# [POI 1999 R3] 降水

## 题目描述

遥远的地方有一块土地。它被划分成 $N\times M$ 个正方形小块，每块面积是一平方英寸，第 $i$ 行第 $j$ 列的小块可以表示成 $(i,j)$。这块土地高低不平，每一小块地 $(i,j)$ 都有自己的高度 $H(i,j)$（单位是英寸）。

一场倾盆大雨后，这块地由于地势高低不同，许多低洼地方都积存了不少降水。假如你已经知道这块土地的详细信息，你能求出它最多能积存多少立方英寸的降水么？

## 说明/提示

对于 $100\%$ 的数据，$1\le N,M \le 100$。

## 样例 #1

### 输入

```
3 6
3 3 4 4 4 2
3 1 3 2 1 4
7 3 1 6 4 1```

### 输出

```
5```

# 题解

## 作者：STA_Morlin (赞：16)

[P5930 降水 の 题目传送门。](https://www.luogu.com.cn/problem/P5930)
# 题目简化
> 给定一块区域 $a_{n, m}$，每块土地都有一个高度。  
> 下雨了。

> 求其共装了多少水。

# 思路讲解
稍微观察，可以发现，只有本身与外界隔离时，才会积住水。  
那么是不是可以从外界向里看？  
自然，最外面一圈是积不住水的，所以从最外圈开始向内泄水。  
考虑搜索。

---
# 代码实现
考虑 `dfs` 或 `bfs`。
### dfs
在看到这题的第一眼，我就想写 `dfs`，为什么？简单啊。  
先将四周存入一个数组 $r$，再挨个 `dfs`。  
### _CODE_
```cpp
void dfs (clod t) {
	for (int i = -1; i <= 1; ++ i) for (int j = -1; j <= 1; ++ j) {
		int px = t.x+i, py = t.y+j;
		if (abs(i+j)==1 && px>1 && py>1 && px<n && py<m && w[px][py] > w[t.x][t.y]) {
			if(w[t.x][t.y] > h[px][py]) w[px][py] = w[t.x][t.y];
			if(w[t.x][t.y] <= h[px][py]) w[px][py] = h[px][py];
			v[px][py] = 1;
			dfs({px, py, w[px][py]});
		}
	}
	return ;
}
```
弄出来后，感觉[太慢了](https://www.luogu.com.cn/record/81458267)，$n$ 和 $m$ 如果再大一点就寄了，我们要有危机意识，所以考虑优化：加入 $v_{n, m}$，判断是否遍历过。  
弄完之后发现：每块土不一定只从一个方向泄水，于是[寄了](https://www.luogu.com.cn/record/81458453)。

怎么办呢？我们还是得有危机意识，考虑 `bfs`。

### dfs
还是先将四周存入队列 $q$，再进行 `bfs`。  
### _CODE_
```cpp
void bfs () {
	while (!q.empty()) {
		clod t = q.top();
		q.pop();
		for (int i = -1; i <= 1; ++ i) for (int j = -1; j <= 1; ++ j) {
			int px = t.x+i, py = t.y+j;
			if (abs(i+j)==1 && px>1 && py>1 && px<n && py<m && w[px][py] > w[t.x][t.y]) {
				if(w[t.x][t.y] > h[px][py]) w[px][py] = w[t.x][t.y];
				if(w[t.x][t.y] <= h[px][py]) w[px][py] = h[px][py];
				q.push({px, py, w[px][py]});
			}
		}
	}
	return ;
}
int main () {

	...
}
```
啊！神清气爽！虽然还是被最优解碾压，但也才[0.1s](https://www.luogu.com.cn/record/81459172)，稳过了就。
# E.N.D.

---

## 作者：OMG_wc (赞：12)

按高度从小到大地顺序考虑每个位置，用并查集维护连通性。具体来讲，假设当前考虑到的高度为 $h$，对每个取出来的位置，其相邻位置如果高度不超过 $h$ 或者是外界（简单起见，把外界也看成一个结点）就合并连通块。

这样一来，所有高度 $\le h$ 且不与外界相邻的位置都是可以继续积水的（至少增加 $1$），因为其四周肯定有比他高的位置会阻挡。具体实现见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 1e9 + 7;
const int N = 10005;

int a[105][105];
vector<int> b[N];
int p[N];
int sz[N];
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int find(int x) {
    return p[x] == x ? x : p[x] = find(p[x]);
}
void Union(int x, int y) {
    x = find(x), y = find(y);
    if (x != y) {
        p[x] = y;
        sz[y] += sz[x];
    }
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf("%d", &a[i][j]);
            b[a[i][j]].push_back(i * m + j);
        }
    }
    for (int i = 0; i <= n * m; i++) {
        p[i] = i;
        sz[i] = 1;
    }
    sz[n * m] = 0;
    int ans = 0;
    int cnt = 0;
    for (int i = 1; i <= 10000; i++) {
        for (auto t : b[i]) {
            int x = t / m, y = t % m;
            cnt++;
            for (int j = 0; j < 4; j++) {
                int tx = x + dx[j];
                int ty = y + dy[j];
                if (tx >= 0 && tx < n && ty >= 0 && ty < m) {
                    if (a[tx][ty] <= a[x][y]) Union(t, tx * m + ty);
                } else {
                    Union(t, n * m);
                }
            }
        }
        ans += cnt - sz[find(n * m)];
    }
    cout << ans << endl;
    return 0;
}

```


---

## 作者：DarthVictor (赞：5)

# 题目
[原题地址](https://www.luogu.com.cn/problem/P5930)
# 解说
由于下的雨很大，我们可以把这道题理解为雨水先把每一块土地都充填到了最大高度那么高，然后开始从四周泄洪。只要确定了这个思路，按照它来模拟就可以，即先把除了四边上所有位置的高度全部设定为最大高度，之后开一个按照高度由小到大进行排序的小跟堆，从四周开始BFS，一旦遇到水的高度比自己还要高的位置，就将其泄洪。最后的答案就是所有位置水的高度减原高度的和。

具体的一些实现过程详见代码注释。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int lzw=100+3;
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
int a[lzw][lzw],n,m,ans[lzw][lzw],solve[lzw][lzw],maxx,cnt;
char buf[1<<20], *p1, *p2;
char gc() { 
    if (p1 == p2) {
        p1 = buf;
        p2 = buf + fread(buf, 1, 1<<20, stdin);
    }
    return *p1++;
}
inline int read(){
    int f = 1, x = 0;
    char c = gc();
	while (c < '0' || c > '9') {
	    if (c == '-') f = -1;
	    c = gc();
	}
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = gc();
	return f * x;
}
struct node{
	int x,y,h;
	node(){}
	node(int xx,int yy,int hh){
		x=xx;
		y=yy;
		h=hh;
	}
	bool operator < (const node &A) const{
		return h>A.h;
	}
}all[4*lzw];
int main(){
	n=read(); m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]=read();
			solve[i][j]=a[i][j];
			maxx=max(maxx,a[i][j]);//记录最高峰
			if(i==1||i==n||j==1||j==m) all[++cnt]=node(i,j,a[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if((i==1||i==n||j==1||j==m)&&a[i][j]>=0) continue;
			if((i==1||i==n||j==1||j==m)&&a[i][j]<0) solve[i][j]=0;//四周设为0
			if(i!=1&&i!=n&&j!=1&&j!=m)solve[i][j]=maxx;//如果目前的位置不在四边上则全部充填为最大水位
		}
	}
	priority_queue<node> q;//按照高度排序的小根堆
	for(int i=1;i<=cnt;i++) q.push(all[i]);//先把四周入队
	while(!q.empty()){//BFS
		node k=q.top();
		q.pop();
		for(int i=0;i<4;i++){
			int xx=k.x+dx[i],yy=k.y+dy[i];
			if(xx<1||yy<1||xx>n||yy>m) continue;
			if(solve[xx][yy]<=solve[k.x][k.y]) continue;//到达的点还不如(x,y)水位高则说明无法从这里泄洪，直接跳过
			if(solve[k.x][k.y]>a[xx][yy]){//到达的点水位更高但原高度比现在水位低则泄洪为现在水位
				solve[xx][yy]=solve[k.x][k.y];
				q.push(node(xx,yy,solve[xx][yy]));
			}
			if(solve[k.x][k.y]<=a[xx][yy]){//到达的点水位更高但原高度比现在水位高则泄洪为原高度
				solve[xx][yy]=a[xx][yy];
				q.push(node(xx,yy,solve[xx][yy]));
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans+=solve[i][j]-a[i][j];
	printf("%d\n",ans);
	return 0;
}
```
幸甚至哉，歌以咏志。

---

## 作者：漠寒 (赞：4)

## 分析

对于每一个位置，它的积水能否达到某一个高度，要求的便是它附近是否有完全封闭的由原高度大于等于该高度的位置连线组成的封闭图形。

所以我们便枚举每一次所需达到的高度，看有多少个比该高度低的能达到该高度，我们发现需要在整个图形上去掉两类，一是原来就比它高的，二是在所有封闭图形外的点。于是考虑 $dfs$ 来处理这个问题。答案先加上总点数，每个大于等于枚举高度的点对答案减一，在进行 $dfs$,如若搜索到小于等于当前枚举的高度的点，也减一，每当搜索到大于等于枚举高度的点，则返回，不能搜到的，就可以被理解为用墙围起来的部分，这样就行了。

时间复杂度是 $10^8$，但因为$dfs$ 本身会枚举到很多重点，所以会稍微超出时间限制，可以用 $bfs$，用两个队列交替进行，每次用一个队列时在另一个队列存上这一次所寻到的的边界来优化这一进程，这里放上用 $O2$ 过的 $dfs$ 代码。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
int h[105][105],vis[105][105];
int T;
int n,m;
int mx,mn;
int ans,sum;
inline void read(int &res){
	char c;
	int f=1;
	res=0;
	c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}
int H; 
void dfs(int x,int y){
	if(x<0||y<0||x>n+1||y>m+1)return;
	if(vis[x][y])return;
	if(h[x][y]>=H)return;
	vis[x][y]=1;
	if(x>0&&x<=n&&y>0&&y<=m)sum--;
	dfs(x-1,y);
	dfs(x+1,y);
	dfs(x,y-1);
	dfs(x,y+1);
}
int t[10005];
int main(){
	read(n);read(m);
	mn=10005;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			read(h[i][j]);
			mx=max(mx,h[i][j]);
			mn=min(mn,h[i][j]);
			t[h[i][j]]++;
		}
	}
	for(int i=mx;i>=mn;i--){
		t[i]+=t[i+1];//高度大于等于i的数量 
	}
	for(H=mn+1;H<=mx;H++){//枚举所要到达的高度 
		memset(vis,0,sizeof(vis));
		sum=n*m-t[H];
		dfs(0,0);
        if(!sum)break;//没位置能向上了 
		ans+=sum;
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Shawk (赞：3)

希丰展，看[博客](https://www.cnblogs.com/Z8875/p/13416220.html)
* 题目大意

二维的积水问题。
* 解体思路（小根堆+BFS）

木桶原理：桶能装的水的多少取决于最短的木板。

同理，一块土地积存的水取决于最低的那个边界，我们知道矩阵最边上的位置是不可能存水的（h > 1嘛），就从边上向内搜索，找到更低的地方就可以存水。

w是每块方格最高的水位（不能存水的格子水位就等于高度）。

具体实现过程：
  1. 将边界上的点（横坐标等于1或n，纵坐标等于1或m）放入小根堆。
  2. 每次取出堆顶（即高度最小的点），进行BFS，这里进行BFS是因为DFS在这种可以随意走，一直递归下去（指没有进行过回溯）就可能跑完的图有爆栈的可能，其实这到题还是没什么关系，我的电脑实测可以递归到26万层左右，这道题只有1万个点。
  3. 进行BFS的时候，搜索到低的点就改变其最高水位，有高的点就在判断没有进入过堆后压入堆中
  
详见代码注释

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 305;
struct Node {
	int x, y, h;
	Node() {};
	Node(int a, int b, int c) {
		x = a, y = b, h = c;
	}
	bool operator < (const Node &b) const {
		return h > b.h;
	}//重载运算符，这是小根堆
};
int n, m, h[N][N], w[N][N], ans;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};//Bfs时的4个方向
priority_queue<Node> que;//堆
queue<Node> q;//Bfs用的队列
bool vis[N][N];//标记是否入过堆
void Bfs(Node a) {
	q.push(a);
	while (!q.empty()) {
		Node u = q.front(); q.pop();
		if (w[u.x][u.y] != -1) continue;
		w[u.x][u.y] = a.h;
		for (int k = 0; k < 4; ++k) {
			int tx = u.x + dx[k];
			int ty = u.y + dy[k];
			if (tx < 1 || tx > n || ty < 1 || ty > m) continue;//超出了边界
			if (w[tx][ty] != -1) continue;//已经访问过且赋值
			if (h[tx][ty] <= a.h) q.push(Node(tx, ty, 0));//高度低的入队，继续Bfs
			else if (!vis[tx][ty]) //高度高的压入堆
				que.push(Node(tx, ty, h[tx][ty])), vis[tx][ty] = 1;
		}
	}
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%d", &h[i][j]);
			w[i][j] = -1;//初始化为-1，为未访问标记
			if (i == 1 || i == n || j == 1 || j == m)//将边界入堆并标记
				que.push(Node(i, j, h[i][j])), vis[i][j] = 1;
		}
	while (!que.empty()) {//每次取出最低的操作
		Node u = que.top(); que.pop();
		if (w[u.x][u.y] != -1) continue;//如果已经访问那就不需要了
		Bfs(u);
	}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			ans += w[i][j] - h[i][j];//w-h即水的深度
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：sodak (赞：3)

## 思路
这道题的题意很明确，很明显我们可以用搜索来做这个题，但是到底怎么搜？对于某一块土地，向四周搜？但是这样限制比较多，搜索很难进行，所以我们可以从边界开始搜索。

* 首先我们可以把小于0的点“填平”，先累加到积水深度中（ans），把这块土地的高度变为0,方便处理（因为这块土地（指题目给出的一整块）之外，高度都为0，所以加水后，不可能出现高度为负的点）。

* 对于初始图的边界点$（i==1||i==n||j==1||j==m）$，我们把他放到一个小跟堆里来维护。木桶原理相信大家都知道，每次取出边界中高度的最小值最为边界所围的整块土地的最低限制

* 得到了最低限制，如果有一个点高于当前最高边界，把它$push$进去，如果低于当前最低边界，那么我们显然不能够直接$push$进去，我们应该先把它“填平”，将差值（需要增加的水量）累加到积水深度中，再把它$push$进去

* 然后重复此操作直到队列为空

#### 如果还不是很清楚，请看代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=305;
int a[maxn][maxn];
bool vis[maxn][maxn];
struct node{
	int x,y,h;
	bool operator < (const node &_node)const {
		return h>_node.h;
	}
	node(){}
	node(int _x,int _y,int _h){
		x=_x,y=_y,h=_h;
	}
};
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};
int ans=0;
priority_queue<node>q;
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	bool flag=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
			if(a[i][j]<0){
				ans+=(-a[i][j]);
				a[i][j]=0;
			}
			if(i==1||j==1||i==n||j==m)q.push(node(i,j,a[i][j])),vis[i][j]=1;
		}
	}
	while(!q.empty()){
		int h=q.top().h,x=q.top().x,y=q.top().y;
		q.pop();
		for(int i=0;i<=3;i++){
			int tx=x+dx[i],ty=y+dy[i];
			if(vis[tx][ty])continue;
			if(tx<1||tx>n||ty<1||ty>m)continue;
			vis[tx][ty]=1;
			if(a[tx][ty]<h){
				ans+=(h-a[tx][ty]);
				q.push(node(tx,ty,h));
			}
			else q.push(node(tx,ty,a[tx][ty]));
		}
	}
	printf("%d\n",ans);
}


```

---

## 作者：lyt_awa (赞：1)

## 并查集
先从小到大对高度考虑，当前考虑高度为 $h$，如果在这个高度的点四周有比他矮的点，说明水这点可以满上，或者从边界流出，将他们合并，算出此时水位可以上升到的点数，为所有高度 $\le h$ 的点数 $-$ 从边界流出水的点数，就是总水位能增加多少，答案累加即可。
### code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;
int n, m, fa[N], sz[N], a[105][105];
inline int num(int i, int j) {
	return (i - 1) * m + j;
}
int get(int x) {
	return fa[x] == x ? x : fa[x] = get(fa[x]);
}
void Union(int x, int y) {
	x = get(x), y = get(y);
	if (x != y) {
		sz[y] += sz[x];
		fa[x] = y;
	}
}
inline bool valid(int x, int y) {
	return x >= 1 && x <= n && y >= 1 && y <= m;
}
const int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, -1, 1};
vector<pair<int, int> > b[N];
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%d", a[i] + j);
			b[a[i][j]].push_back(make_pair(i, j));
			fa[num(i, j)] = num(i, j);
			sz[num(i, j)] = 1;
		}
	int cnt = 0, ans = 0;
	for (int i = 1; i <= 10000; ++i) {
		cnt += b[i].size();
		for (auto v : b[i]) 
			for (int k = 0; k < 4; ++k) {
				int nx(v.first + dx[k]), ny(v.second + dy[k]);
				if (!valid(nx, ny)) Union(num(v.first, v.second), 0);
				else if (a[nx][ny] <= a[v.first][v.second]) Union(num(v.first, v.second), num(nx, ny));
			}
		ans += cnt - sz[get(0)];
	}
	printf("%d", ans);
	return 0;
}
```
## 广搜 + 优先队列
我们可以借助木桶效应，维护最外面的一个大圈的高度，一点点往里缩。
### code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int n, m, a[N][N];
bool v[N][N];
struct P {
	int x, y, v;//坐标(x, y)涨水后高度为v
	bool operator < (const P &a) const {
		return v > a.v;
	} 
	P(int _x, int _y, int _v) {
		x = _x, y = _y, v = _v;
	}
};
const int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, -1, 1};
priority_queue<P> q; 
inline bool valid(int x, int y) {
	return x >= 1 && x <= n && y >= 1 && y <= m;
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			scanf("%d", a[i] + j);
			if (i == 1 || i == n || j == 1 || j == m) v[i][j] = 1, q.push(P(i, j, a[i][j]));
		} 
	int ans = 0;
	while (q.size()) {
		P now = q.top();
		q.pop();
		ans += max(0, now.v - a[now.x][now.y]);
		for (int k = 0; k < 4; ++k) {
			int nx(now.x + dx[k]), ny(now.y + dy[k]);
			if (!valid(nx, ny) || v[nx][ny]) continue;
			q.push(P(nx, ny, max(now.v, a[nx][ny])));
			v[nx][ny] = 1;
		}
	} 
	printf("%d", ans);
	return 0;
}
```

---

## 作者：djh0314 (赞：1)

#### [传送门](https://www.luogu.com.cn/problem/P5930)   

### 题意
有一个 $n\times m$ 的地区，每个地区有一个海拔高度 $\mathit{h}_ {i,j} $。     
问最多加入多少水，可以使得水不往外溢出（即小于等于四周的海拔）。

### 分析
我们可以从小到大逐个枚举水位，看此时水位高度增加后能够增加的水量。      

如果当前这个节点能够通过比当前水位低的点到达边界，那么这个节点就不能提供价值。

显然，我们可以用并查集来维护能不能到达边界。

### 代码
~~~cpp
int now=1;
for(int i=1; i<=mx; ++i) {
	for(int j=2; j<n; ++j)
		for(int k=2; k<m; ++k) if(h[j][k]<i&&root(ID(j,k))) ++ans;
	while(now<=ID(n,m)&&num[now].num<=i) {
		int x=num[now].x,y=num[now].y;
		for(int k=0; k<4; ++k) {
			int tx=x+dt1[k],ty=y+dt2[k];
			if(tx<=0||tx>n) continue;
			if(ty<=0||ty>m) continue;
			if(h[tx][ty]<=h[x][y])
				hb(ID(tx,ty),ID(x,y));
		}
		++now;
	}
}
~~~
这个代码枚举了水位，与每一个小于等于水位的节点，向四周连接。       
在并查集部分，我将边界的 $fa$ 设为了 $0$。         
时间复杂度：$O(mx\times n\times m)\approx O(10^8)$，但是由于并查集的常数，这个解法被打上了水的标签。


### 优化

很显然我们就要优化每次水位更新答案的双层循环，     
可以发现，在这 $n\times m$ 的矩阵中包含三种状态的点：     
1. 海拔大于当前水位；
2. 与边界相连；
3. 除去（$1$），（$2$）的节点。       

而我们 $ans$ 所需要增加的，正是如上所述的第三种，也就是当前枚举过的点数减去连接到边界的点数。      

以此，我们可以在并查集合并的过程中，将连接至边界的点减去，最后剩下的即为我们答案在这个水位增加的量。

[Code](https://www.luogu.com.cn/paste/x8l1d5u7)。

---


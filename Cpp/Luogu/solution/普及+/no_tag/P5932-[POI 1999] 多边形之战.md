# [POI 1999] 多边形之战

## 题目背景

多边形之战是一个双人游戏。

## 题目描述

游戏在一个有 $n$ 个顶点的凸多边形上进行，这个凸多边形的 $n-3$ 条对角线将多边形分成 $n-2$ 个三角形，这 $n-3$ 条对角线在多边形的顶点相交。

三角形中的一个被染成黑色，其余是白色。双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。

- 注：如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。

## 说明/提示

对于 $100\%$ 的数据， $4 \le n \le 50000$。

## 样例 #1

### 输入

```
6

0 1 2

2 4 3

4 2 0

0 5 4```

### 输出

```
TAK```

# 题解

## 作者：wsyhb (赞：2)

## 题解

首先，如果你画几个多边形来手玩，你会发现如下结论：

**结论一**：对于凸多边形中的任意一个三角形及它的任意一边，要让这个三角形的这条边成为操作后多边形的某边，必须删除这个三角形这一侧的其它所有三角形。

------------

文字可能不是那么容易理解，下面**举例**说明：

![](https://cdn.luogu.com.cn/upload/image_hosting/tyo3chhu.png)

如上图，这个 $12$ 边形包含 $10$ 个三角形，其中的红色数字表示它们的编号。

用 $T_i$ 表示第 $i$ 个三角形，那么要让 $T_4$ 的 $m_1$ 这条边成为操作后多边形的某边，必须删除 $T_1,T_2$ 和 $T_3$；要让 $T_4$ 的 $f_1$ 这条边成为操作后多边形的某边，必须删除 $T_6,T_7,T_8,T_9$ 和 $T_{10}$；要让 $T_4$ 的 $j_1$ 这条边成为操作后多边形的某边，必须删除 $T_5$。

------------

是不是感觉这个结论很显然？不过还是要给出**证明**的：

设多边形边数为 $n$，容易验证 $n=3,4,5$ 时结论一成立。  
假设 $n<k(k \ge 6)$ 时结论一成立，下证 $n=k$ 时结论一仍然成立。

对于有两边都是整个多边形的边的三角形，结论一显然成立。

对于有至少两边都不是整个多边形的边的三角形 $X$，设它的三边分别为 $a,b,c$，且 $a,b$ 都不是整个多边形的边。  
（换句话说，$a,b$ 这两侧都有其它三角形）  
那么要使 $a$ 成为操作后多边形的某边，必须删除以 $a$ 为边的另一个三角形 $Y$。

考虑如何在删除三角形 $Y$ 的同时不删除三角形 $X$：这相当于不能完全删除 $Y$ 的 $a$ 边另一侧（即包含三角形 $X$ 的这一侧），于是**包含三角形 $X$ 的这一侧的部分**可以被**等效替换为一个单独的三角形 $Z$**，而 $Z$ 不能被删除。

等价替换后总的三角形个数变少了，于是多边形的边数也由 $n=k$ 降到了 $n<k$。  
根据归纳，要删除 $Y$（即让 $Y$ 除 $a$ 以外的两边成为多边形的边），必须删掉除 $Y,Z$ 以外的所有三角形。  
即结论一对于 $X$ 的边 $a$ 成立。  
同理可证 $X$ 的边 $b,c$ 成立。

根据归纳，结论一对任意多边形的任意三角形的任意边成立。

------------

回到原题，设黑色三角形每一侧的三角形个数分别为 $x,y,z$，那么**问题转化为**：

- 给定三堆石子，数量依次为 $x,y,z$。  
- 两人轮流操作，每次选取一堆石子并从其中取走一颗。  
- 当三堆石子中有至少两堆石子为空时，游戏结束。  
- 进行最后一次操作的人失败。

**说明**：当黑色三角形有至少两边为多边形的边时，当前玩家把黑色三角形删除即可取得游戏的胜利。故造成这种局面的玩家失败。

------------

我想到这儿的第一反应：直觉上，局面的胜负与 $x,y,z$ 的奇偶性有关。（因为每次只取一颗石子）

但我并不是很确定具体结论，于是写了个程序打了下 $x,y,z \le 10$ 的胜负状态：

![](https://cdn.luogu.com.cn/upload/image_hosting/xyyi0cb2.png)

（其中 $\mathit{val}=0$ 表示该局面必败，$\mathit{val}=1$ 表示必胜；程序见[剪贴板](https://www.luogu.com.cn/paste/jpicelhs)）

这规律简直不要太明显：当 $x+y+z$ 为偶数时必败，反之必胜。

------------

更严谨地，我们有如下结论：

**结论二**：

1. 当 $x,y,z$ 中有至少 $2$ 个 $0$ 时，该局面必胜。
1. 否则，该局面必胜当且仅当 $x+y+z$ 为奇数。

**证明**：

1 显然，故接下来考虑 $x,y,z$ 中有至多 $1$ 个 $0$ 的情况。  
由于必存在某一时刻某堆石子被取空（或一开始就没有），故可以考虑只剩两堆石子 $y,z(y,z>0)$ 的情况。

除非万不得已，玩家一定不会把这两堆石子中的某一堆取空。  
即：除非 $y=z=1$，玩家一定不会把 $y,z$ 中的任意一个变为 $0$。  
这意味着最终的局面一定是 $(0,0,1)$（要操作该局面的玩家获得胜利）。  
即：最终，不为空的这堆石子个数为 $1$。

而每次操作都会改变 $x+y+z$ 的奇偶性，故 $x+y+z$ 为奇数的局面必胜。

------------

如何求 $x,y,z$ 呢？  
设黑色三角形三点编号为 $a,b,c(a<b<c)$，则 $x$ 为三点编号均在 $[a,b]$ 中的三角形个数，$y$ 为三点编号均在 $[b,c]$ 中的三角形个数，剩余三角形的个数即为 $z$。  
（$x,y,z$ 的顺序显然不影响答案）

于是这道题就做完了。

~~过程比较简单，但却写了一大堆，好累啊。~~

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,a,b,c;
	scanf("%d%d%d%d",&n,&a,&b,&c);
	if(a>b)
		swap(a,b);
	if(a>c)
		swap(a,c);
	if(b>c)
		swap(b,c);
	int x=0,y=0,z=0;
	for(int i=1;i<=n-3;++i)
	{
		int p,q,r;
		scanf("%d%d%d",&p,&q,&r);
		if(p>=a&&p<=b&&q>=a&&q<=b&&r>=a&&r<=b)
			++x;
		else if(p>=b&&p<=c&&q>=b&&q<=c&&r>=b&&r<=c)
			++y;
		else
			++z;
	}
	int cnt0=(x==0)+(y==0)+(z==0);
	if(cnt0>=2)
		puts("TAK");
	else if((x+y+z)&1)
		puts("TAK");
	else
		puts("NIE");
	return 0;
}
```

---

## 作者：一念之间、、 (赞：2)

# 题意
 `n` 个点的凸多边形，分成了 `n-2` 个三角形，

每次可以选择一个在边界上的三角形（有两条边裸露在外面），然后删除它。

第一个给出来的三角形是目标三角形，问先手能否保证自己先删到。

# 解法

可以发现我们只在意最终三角形裸露情况（有两边裸露就删除它），其他三角形如何删除不重要。

![](https://cdn.luogu.com.cn/upload/image_hosting/7a174az1.png)

转化成三个数，每次选择一个减少 `1` ，最后减少到形如 `x,0,0` 时的先手胜利。

首先判掉样例的情况，即已经有两边裸露。

尝试从奇偶性入手（三堆顺序无关），列出来下面一张表。

状态  胜负状态

 100   必胜

 111   必胜

 110   必败

 000   必败

最终胜利状态为 100 或者 000 ，但是 000 只有在有两边裸露的前提下才能获胜（判了）

解释一下操作策略

必胜策略：
 
如果是 100，将一个 0->1 然后转成 110，后手跳不出 110 

如果是 111，随意操作一个转成 100，后手跳不出 110 

必败策略：

如果是 110，当操作 0->1 时，后手直接任意一个 1->0 跳不出去，如果操作 1->0 则后手操作 0->1 跳不出来。
 
如果是 000，除了判掉的特殊情况，任意操作转化成 100，后手直接又转回 110 跳不出去。

所以判断奇偶性即可。


# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define dd double
using namespace std;
char gc(){static char buf[1<<16],*s,*t;if(s==t){t=(s=buf)+fread(buf,1,1<<16,stdin);if(s==t)return EOF;}return *s++;}
//#define getchar gc
ll read()
{
	char c;
	ll w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	ll ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
void pc(char c,int op)
{
	static char buf[1<<16],*s=buf,*t=buf+(1<<16);
	(op||((*s++=c)&&s==t))&&(fwrite(buf,1,s-buf,stdout),s=buf);
}
void wt(int x)
{
	if(x>9)wt(x/10);
	pc('0'+x%10,0);
}
void wts(int x,char op)
{
	if(x<0)pc('-',0),x=-x;
	wt(x);pc(op,0);
}
const int xx=2e5+5;
int n;
signed main(){
	n=read();
	int a=read(),b=read(),c=read();
	if(a>b)swap(a,b);
	if(a>c)swap(a,c);
	if(b>c)swap(b,c);
	int x=b-a-1,y=c-b-1,z=a+n-c-1;
	if((!x)+(!y)+(!z)>=2)puts("TAK");
	else if(((x&1)+(y&1)+(z&1))&1)puts("TAK");
	else puts("NIE");
	pc('1',1);
	return 0;
}
```

---

## 作者：carbon_monoxide (赞：1)

## 题目简述

$n$ 个顶点的凸多边形上被 $n-3$ 条对角线将多边形分成 $n-2$ 个三角形，这 $n-3$ 条对角线在多边形的顶点相交。第一个给出的顶点坐标是目标三角形的坐标，问先手是否能切掉它。

## 思路

不难发现，所有情况都可以分成两类：

- 目标三角形在最外面：直接切掉。

- 目标三角形在里面：不管怎么切，最后一定是这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/5haeoft7.png)

###### （图画得不好看，请见谅）

那么先手能否赢就取决于三角形数量的奇偶。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,c,d,e,f;
int main(){
    cin>>n>>a>>b>>c;
    if(a>b) swap(a,b);
	if(b>c) swap(b,c);
	if(a>c) swap(a,c);
    //方便判断
    for(int i=0;i<n-3;i++) cin>>d>>e>>f;//没有用的变量
    return cout<<(((!(a-b+1))+(!(b-c+1))+(!(a+n-(c+1)))>1||n%2==0)?"TAK":"NIE"),0;//如果目标三角形在最外面或三角形数量是偶数，先手赢
}
```

---

## 作者：MerlinLee (赞：0)

考虑原图的对偶图，因为是凸多边形，所以内部肯定无顶点。

因此对偶图不会出现环，且连通。

所以对偶图其实是棵树。

当代表黑色三角形的那个点度数为1时，先手必胜，因此双方都不会让这种情况出现，所以这棵树一定是叶子被删干净以后决出胜负。

判下顶点的奇偶性就行了。

以及，特判是否存在先手直接取胜的局面。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50050; 
int n,tot;
bool bo[maxn];
int read()
{
    char ch=getchar(); 
	int ret=0;
    while(ch<'0' or '9'<ch)
	  ch=getchar();
    while('0'<=ch and ch<='9')
      ret=ret*10+ch-'0',ch=getchar();
    return ret;
}
int main()
{
    n=read();
    int x=read(),y,z;
    y=read(); 
	z=read();
    bo[x]=bo[y]=bo[z]=1;
    for(int i=1;i<n-2;i++)
    {
        x=read();
		y=read();
		z=read();
        tot+=(bo[x]+bo[y]+bo[z]==2);
    }
    if(tot==1)
	  puts("TAK");
    else 
	  puts((n&1)?"NIE":"TAK");
    return 0;
}
```

---

## 作者：cpu_gal (赞：0)

# 题目分析
本题是博弈中的基础题，解题关键在于如何判断出获胜方，获胜取决于构造出多边形中黑三角的位置，那么就需要对黑三角所有可能出现的位置进行分类找到共性。

## 解题思路

可以将所有可能情况分为以下三类：

黑三角位于多边形最外层，第一次就可以切掉，那么先手直接获胜。

黑三角有一条边是多边形的外层，这种情况游戏进行到最后一定会出现如下情况，也就是说轮到谁切倒数第二块三角形谁获胜，那么就很容易看出，这种情况下谁获胜与三角形数量的奇偶性有关。

黑三角位于多边形内部，这种情况游戏进行到最后同样会出现如2中所示情况，获胜同样与三角形数量的奇偶性相关。

### 奉上代码
```c
#include<bits/stdc++.h>
using namespace std;
int n;
int a[3];
int x,y,z;

int main()
{
	cin>>n;
	cin>>a[0]>>a[1]>>a[2]; // 黑色三角形顶点。
	for(int i=0;i<n-3;i++)
		cin>>x>>y>>z;	// 依照题目要求象征性输入一下，解决本题不需要。
	sort(a,a+3);
	if((a[2]==a[1]+1&&a[1]==a[0]+1)||(a[0]==0&&a[1]==1&&a[2]==n-1)||(a[0]==0&&a[1]==n-2&&a[2]==n-1))	// 判断三个顶点是否连续，连续则代表黑色三角形在边上可以直接切。
		cout<<"TAK";
	else
	{
		if(n&1) cout<<"NIE";	// 黑三角不在外围时通过奇偶判断输赢,n&1 是位运算相当于判断 n%2==1。
		else cout<<"TAK";
	}
	return 0;
}
```

---

## 作者：Rhapsodia (赞：0)

先回顾一下题目描述：

在一个有 $n$ 个顶点的凸多边形上进行，这个凸多边形的 $n-3$ 条对角线将多边形分成 $n-2$ 个三角形。三角形中的一个被染成黑色，其余是白色。两方轮流沿着画好的对角线切三角形，想要赢得切黑色三角形。

分析：

那么，你要沿着画好的对角线就说明：**得保证切的三角形两条边都在现在的多边形边上**（即内部的三角形一定得在外部的三角形切完了才能切）

我们可以把这个图看作一棵树，记黑色三角形为源点，相邻两个三角形所代表的点连边。

那么可以发现一个结论： 一个三角形可以切 $\iff$ 它是叶子结点。

继续分析：

$1$.  如果与源点连线的只有一个点，那么先手必赢

$2$.  若共有偶数个点，先手一定可以在保证儿子数 $>1$ 的情况下把白点取成偶数个，那么上面 $1$ 情况的状态一定是后手取出来的，先手必胜。

$3$.  若共有奇数个点，先手只能把局面转成上面两种情况中的一种，先手必败。

代码没什么好说的，上面已经说得很清晰，直接按照题目输入、建图、判断、输出就可以 AC 了。
    
#### p.s. 其实蛮像入门版的 sg 函数必胜点和必败点了

---


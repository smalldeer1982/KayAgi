# [POI 1998] 折线

## 题目描述

给定二维直角坐标系。

我们要求一条折线只能从左边到右边一笔画过去，并且折线的每一段和 $x$ 轴的夹角在 $[-45°, 45°]$ 之间。

一条满足上述要求的折线被称为：平直折线。

给定坐标系上的 $n$ 个格点，最少需要画多少条平直折线才能覆盖所有的点呢？

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le30000$，$0\le x,y\le 30000$。

## 样例 #1

### 输入

```
5
2 3
3 4
4 5
1 6
12 27```

### 输出

```
3```

# 题解

## 作者：lemondinosaur (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P5939)

---
考虑这个45度不是那么好搞，

那么将坐标系逆时针旋转45度，新坐标 $(x',y')$ 满足

$$
x'=x \cos \theta +y \sin \theta,y'=y \cos \theta -x\sin \theta
$$

 $\frac{\sqrt{2}}{2}$ 为了方便可以直接约掉，就题论题就变成了 $(x+y,y-x)$ 

然后排序就是将横坐标作为第一关键字升序排序，

再将纵坐标作为第二关键字降序排序，这样就只用管纵坐标了

那问题就转换成最少用多少个不上升序列可以覆盖所有点

根据Dilworth定理也就是求最长上升子序列的长度

---
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define rr register
using namespace std;
const int N=30011;
struct rec{int x,y;}a[N]; int n,b[N],len;
inline signed iut(){
	rr int ans=0; rr char c=getchar();
	while (!isdigit(c)) c=getchar();
	while (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return ans; 
}
bool cmp(rec a,rec b){return a.x<b.x||(a.x==b.x&&a.y>b.y);} 
signed main(){
	n=iut();
	for (rr int i=1;i<=n;++i){
		rr int x=iut(),y=iut();
		a[i]=(rec){x+y,y-x};
	}
	sort(a+1,a+1+n,cmp);
	b[++len]=a[1].y;
	for (rr int i=2;i<=n;++i){
		if (a[i].y>b[len]) b[++len]=a[i].y;
		else b[lower_bound(b+1,b+1+len,a[i].y)-b]=a[i].y;
	}
	return !printf("%d",len);
}
```

---

## 作者：Y_ATM_K (赞：3)

## 分析
很自然能够想到旋转坐标系，简化问题。

旋转坐标系显然等价于对每个点旋转，根据三角函数知识，我们知道一个点 $(x,y)$ 绕原点逆时针旋转角度 $\theta$ 后坐标为 $(x\cos{\theta}-y\sin{\theta},x\sin{\theta}+y\cos{\theta})$。

因为我们要逆时针旋转 $45\degree$，所以旋转后坐标为 $(\dfrac{\sqrt{2}}{2}x-\dfrac{\sqrt{2}}{2}y,\dfrac{\sqrt{2}}{2}x+\dfrac{\sqrt{2}}{2}y)$，可以约去 $\dfrac{\sqrt{2}}{2}$，变为 $(x-y,x+y)$。

此时问题条件变为：

折线与 $x$ 轴夹角为 $[0\degree,90\degree]$ 之间，用尽量少的折线覆盖所有的点。

设每个点旋转后的坐标为 $(x_i,y_i)$，它在折线上的下一个点只有可能在它的右上角。也就是按照 $x$ 排序后，每条折线上的点的 $y$ 都是单调不减的。

这不就是经典题目导弹拦截吗？

以 $x$ 为第一关键字，以 $y$ 为第二关键字，把点排个序，然后扫一遍，每次把点放在它能放的 $y$ 最大的折线上，如果没有就新开一条线，然后就做完了。

时间复杂度显然是 $O(n\log n)$。

放个代码作为参考。

## 代码
```cpp
#include <bits/stdc++.h>
#define N 30005
using namespace std;
int n;
struct node {
	int x,y;
	bool operator <(node k) const {
		return x==k.x?y<k.y:x<k.x;
	}
} a[N];
void init() {
	for(int i=1;i<=n;++i) {
		int x,y;
		scanf("%d%d",&x,&y);
		a[i].x=x-y,a[i].y=x+y;
	}
}
int cnt,hei[N];
int main() {
	scanf("%d",&n);
	init();
	sort(a+1,a+1+n);
	hei[0]=1e9;
	for(int i=1;i<=n;++i) {
		if(hei[cnt]>a[i].y) {
			hei[++cnt]=a[i].y;
		} else {
			int l=1,r=cnt;
			while(l<r) {
				int mid=(l+r)>>1;
				if(hei[mid]<=a[i].y) {
					r=mid;
				} else {
					l=mid+1;
				}
			}
			hei[l]=a[i].y;
		}
	}
	printf("%d\n",cnt);
	return 0;
}
```

---

## 作者：stoorz (赞：3)

原来的坐标系内的任意一个点可以对与其连线的斜率在 $-1\sim 1$ 之间，如果我们把这个坐标系顺时针旋转 $45$°，那么对于新坐标系内的任意一点，它所能贡献的点就位于它的右上方。

那么如何在新坐标系内求出这些点呢？

新坐标系的 $y$ 轴其实就是原坐标系的直线 $y=x$。那么如果一个点经过原坐标系的 $y=x+k$，那么它在新坐标系的横坐标就是 $k$。

同理，新坐标系的 $x$ 轴就是原坐标系的 $y=-x$，若一个点过 $y=-x+k$，那么这个点在旧坐标系的纵坐标就是 $k$。

所以对于一个点 $(x,y)$，它的新坐标就是 $(y-x,x+y)$。

然后由于只能从左向右选，所以将每一个新点按横坐标排序。

那么接下来就是覆盖 $y$ 的问题了。既然已经满足 $x$ 单调，我们就是要求多少个不降序列可以将每一个点的$y$覆盖掉。

这就是经典的导弹拦截的问题了。只不过是将不升改成了不降。

时间复杂度 $O(n\log n)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=30010;
int n,x,y,l,r,mid,ans,f[N];

struct node
{
	int x,y;
}a[N];

bool cmp(node x,node y)
{
	if (x.x>y.x) return 1;
	if (x.x<y.x) return 0;
	return x.y<y.y;
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&y);
		a[i].x=y-x; a[i].y=x+y;
	}
	sort(a+1,a+1+n,cmp);
	f[0]=2147483647;
	for (int i=1;i<=n;i++)
	{
		if (f[ans]>a[i].y) f[++ans]=a[i].y;
		else
		{
			l=1; r=ans;
			while (l<=r)
			{
				mid=(l+r)>>1;
				if (f[mid]>a[i].y) l=mid+1;
					else r=mid-1;
			}
			f[l]=a[i].y;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：wandereman (赞：0)

## 思路
首先我们很容易想到可以翻转坐标系来解决，翻转的度数正是 $45°$，接下来我们就要看看如何在新坐标里求出这些点了。

新坐标系中的 $y$ 轴其实就是原坐标系的 $y=x$。那么如果一个点经过这条直线，那么它在新坐标系的横坐标就是 $k$。

同理，若一个点过 $y=-x+k$，这个点在旧坐标系的纵坐标就是 $k$。

所以 $(x,y)$ 的新坐标是 $(y-x,x+y)$。

最后我们再看一遍题目，由于折线从左到右，就变成了一个简单的导弹拦截问题了，但是注意是不降而不是不升，时间复杂度是 $O(n \log n)$。
## AC code
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;
const int N = 30010;
int n,x,y,l,r,mid;
int ans,dp[N];
struct aci{
	int x,y;
}a[N];
bool cmp(aci x,aci y){
	if(x.x > y.x){
		return 1;
	}
	if(x.x<y.x){
		return 0;
	}
	return x.y<y.y;
}
signed main(){
	cin>>n;
	for(int i = 1;i <= n;i++){
		cin>>x>>y;
		a[i].x = y - x; 
		a[i].y = x + y;
	}
	sort(a + 1,a + 1 + n,cmp);
	dp[0] = 999999999;
	for(int i = 1;i <= n;i++){
		if(dp[ans] > a[i].y){
			dp[++ans] = a[i].y;
		}else{
			l = 1; 
			r = ans;
			while(l <= r){
				mid = (l + r) >> 1;
				if (dp[mid] > a[i].y) l = mid + 1;
					else r = mid - 1;
			}
			dp[l] = a[i].y;
		}
	}
	cout<<ans;
	return 0;
}
```

---


# [POI 2002] 最大的园地

## 题目描述

在一个 $n\times n$ 的正方形内找到最大的由 `0` 组成的矩形，输出它的面积。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 2000$。

## 样例 #1

### 输入

```
5
0 1 0 1 0
0 0 0 0 0
0 0 0 0 1
1 0 0 0 0
0 1 0 0 0```

### 输出

```
9```

# 题解

## 作者：_Violet_Evergarden (赞：8)

来一发[双倍经验](https://www.luogu.com.cn/problem/P4147)

# 题意：
只需找出矩阵中最大的由 $0$ 构成的子矩阵。

# 思路：
我们只需要记录每个点左边有多少个连续的 $0$，然后在每个点遍历的时候加上最优性剪枝即可。见代码便可懂。

# 优化：
目前我们的时间复杂度还是超时的。那我们就用悬线法优化一下，悬线法就是我们对每个点从上往下遍历，用提前储存的左边有多少个 $0$ 来进行计算，最后再加上最优性的遍历即可。此时我们的的时间复杂度就无限趋近 $\mathcal{O}(N^2)$ 就可以拿下了。
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[2001][2001];
int b[2001][2001];
int ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		int m=0;
		for(int j=1;j<=n;j++){
			if(a[i][j]==0){
				m++;
				
			}
			else{
				m=0;
			}
			b[i][j]=m;//存左边有多少个连续的零 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			int p=b[i][j];
			if(p==0){
				continue;
			}
			ans=max(p,ans);
			for(int k=i+1;k<=n;k++){
				p=min(p,b[k][j]);
				if(p==0||p*(n-i+1)<=ans){//最优性剪枝 
					break;
				}
				ans=max(p*(k-i+1),ans);
			}
		}
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：Sparrow_hmm (赞：4)

## 题目描述：
### [P5943 题目传送门](https://www.luogu.com.cn/problem/P5943)
这是一道板子，但是：

#### [双倍经验！](https://www.luogu.com.cn/problem/P4147)
## 所用算法：

1. 前缀和

2. 悬线思想
## 算法思路：
主要分为：
1. 如果当前已经扩展到了边界，退出查找。

2. 当前悬线扩展到的位置不能再扩展了，退出查找。

3. 当前悬线还可以往左扩展，能扩展到，于是我们更新线的位置并继续执行判断。

详见[这个](https://oi-wiki.org/misc/hoverline/)，剩下的交给代码。

## 蒟蒻の AC 代码
[AC 记录](https://www.luogu.com.cn/record/123384339)

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int a[2005][2005];
int s[2005],l[2005],r[2005];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        int x;
        cin>>x;
        if(!x)a[i][j]=a[i-1][j]+1;
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1,top=0;j<=n;j++) 
        {
    	    while(top&&a[i][s[top]]>a[i][j])r[s[top--]]=j;
            l[j]=s[top];//找端点
            s[++top]=j;
        }
        for(int j=1;j<=n;j++)ans=max(ans,(r[j]-l[j]-1)*a[i][j]);//计算面积，更新答案
    }
    cout<<ans;
    return 0;
}
```
## 总结
灰板子题不多啦~~还这么水~~，上榜年度好题！

---

## 作者：xh001 (赞：4)

# 题意
首先给定一个整数 $n$ 表示正方形的边长，然后读入一个 $n\times n$ 的由 $0$、$1$ 构成的矩阵，求最大的由 $0$ 构成的子矩阵的面积。
# 思路
先 $\mathcal{O}(n^2)$ 的预处理出点 $(i,j)$ 左边（包括自己）有多少个连续的 $0$，然后暴力枚举每个点并记录当前子矩阵的横向长度，在每个点的基础上继续向下枚举，每次取最小的横向长度并乘上竖直长度。**但是**，很显然这样会超时，所以开始优化。
### 优化1
当当前横向长度为 $0$ 时，直接枚举下一个点。

证明：很显然，面积为 $0$ 的子矩阵不会对答案有任何贡献。
### 优化2（重点）
当当前横向长度乘上竖直长度后仍小于等于 $ans$ 时，直接枚举下一个点。

证明：再往下遍历只会让横向长度单调不上升，当前子矩阵面积不可能更大。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//好习惯。 
ll n,m,a[2001][2001],cnt,ans;
ll f[2001][2001];//记录点(i,j)左边（包括自己）有多少个连续的0。 
ll s;//当前子矩阵横向长度。 
inline ll read()
{
	ll k=0,f=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) f|=c=='-';
	for(;isdigit(c);c=getchar()) k=(k<<1)+(k<<3)+(c^48);
	return f?-k:k;
}
int main()
{
	n=read();
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=n;j++)
		{
			a[i][j]=read();
		}
	}
	for(ll i=1;i<=n;i++)
	{
		cnt=0;
		for(ll j=1;j<=n;j++)
		{
			if(!a[i][j]) cnt++;
			else cnt=0;
			f[i][j]=cnt;
		}
	}
	for(ll i=1;i<=n;i++)
	{
		for(ll j=1;j<=n;j++)
		{
			s=f[i][j];
			ans=max(ans,s);
			for(ll l=i+1;l<=n;l++)
			{
				s=min(s,f[l][j]);
				if(!s) break;//优化1。 
				if(s*(n-i+1)<=ans) break;//优化2。 
				ans=max(ans,s*(l-i+1));
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：happybob (赞：2)

考虑维护 $d_{i,j}$ 表示 $(i,j)$ 往下连续 $0$ 的数量，容易枚举每一行后处理出单调栈。枚举每一个 $d_{i,j}$ 作为最小值时的答案取 $\max$ 即可。

---

## 作者：cosf (赞：1)

## 写在前面

[本题](https://www.luogu.com.cn/problem/P5943)除了和[玉蟾宫](https://www.luogu.com.cn/problem/P4147)是双倍经验，[棋盘制作](https://www.luogu.com.cn/problem/P1169)也是，只不过要做两次。

## 悬线法模版

像[最大正方形](https://www.luogu.com.cn/problem/P1387)这道题中，我们是设 $dp(i, j)$ 表示以 $(i, j)$ 为右下角的最大正方形的边长。但是，这题要求的是矩形，所以从黄变成了绿，也不知道为什么黄加绿等于蓝（棋盘制作是蓝的）。

如果你想仍然用那种 dp，你肯定过不了这道题。那样可以用三分套二分来做（$O(n^2\log^2 n)$）。总之过不了，就不讲了。

回归正题。悬线法其实也类似一种 dp，不过此时记录的不是以 $(i, j)$ 为右下角，而是以 $(i, j)$ 为矩形的底部，并且高最大的面积最大矩形。注意：高的优先级比面积高。

那么，这个的正确性如何？

当时我在学这个算法时，就想过，太高了是不是反而就面积小了呢？其实并不然。

例如下列情况，可以发现，对于最右下角的那一格，它的最大面积不是最终的最大面积。然而标 `2`（当作 `0`）的那一格却是。这是因为，最大的矩形的上一行中至少有一个 `1`“顶”着这个矩形。

```text
11110
00100
00000
00200
```

那么，我们就可以愉快地用 dp 了。悬线法主要记录三个量：$height(h), left(l), right(r)$。$h(i, j), l(i, j), r(i, j)$ 分别表示以 $(i, j)$ 为底的矩形的最大高度，在最大高度前提下的左边界，最大高度的右边界。

可以发现，大体上看，$h(i, j) = h(i - 1, j) + 1, l(i, j) = l(i, j - 1), r(i, j) = r(i, j + 1)$，并且处理完后还要处理 $l(i, j) = \max\{l(i, j), l(i - 1, j)\}$ 以及 $r(i, j) = \min\{r(i, j), r(i - 1, j)\}$。对于 $(i, j)$ 的面积就是 $h(i, j)(r(i, j) - l(i, j)-1)$。注意要判断边界和可行性。这个稍微分析一下即可，这里就不赘述了。

## 代码

```cpp
#include <iostream>
using namespace std;

#define MAXN 2005

int mp[MAXN][MAXN];
int lef[MAXN][MAXN];
int rig[MAXN][MAXN];
int h[MAXN][MAXN];

int n;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            cin >> mp[i][j];
            if (!mp[i][j])
            {
                h[i][j] = h[i - 1][j] + 1;
                lef[i][j] = lef[i][j - 1];
            }
            else
            {
                lef[i][j] = j;
            }
        }
        rig[i][n + 1] = n + 1;
        for (int j = n; j; j--)
        {
            if (!mp[i][j])
            {
                rig[i][j] = rig[i][j + 1];
            }
            else
            {
                rig[i][j] = j;
            }
        }
    }
    int res = 0;
    for (int i = 2; i <= n; i++)
    {
        res = max(res, h[1][i] * (rig[1][i] - lef[1][i] - 1));
        for (int j = 1; j <= n; j++)
        {
            if (!mp[i][j] && !mp[i - 1][j])
            {
                lef[i][j] = max(lef[i][j], lef[i - 1][j]);
                rig[i][j] = min(rig[i][j], rig[i - 1][j]);
            }
            res = max(res, h[i][j] * (rig[i][j] - lef[i][j] - 1));
        }
    }
    cout << res << endl;
    return 0;
}
```


---

## 作者：peixiaorui (赞：1)

双倍经验~  [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)

## 题意

找图中最大的由 `0` 构成的矩阵。

如样例中的正方形
```
0 1 0 1 0
0 0 0 0 0
0 0 0 0 1
1 0 0 0 0
0 1 0 0 0
```
正中间的 $3 \times 3$ 的就是最大的，故答案为 $9$。

## 思路

悬线法板子。

悬线法，顾名思义，有一条悬线，这条悬线就是某个子矩阵的高。要让子矩阵的面积最大，就要让悬线最长。

可以定义 $h_{i,j}$ 为点 $(i,j)$ 向上最长的高（即从 $(i,j)$ 向上的 `0` 的个数）。那么很显然可以推出点 $(i,j)$ 为 `0` 时，$h_{i,j} = h_{i - 1,j} + 1$

接下来要算以这条悬线为高的最大矩形，因此要算最大的底的长度。

定义 $le_{i,j}$ 为点 $(i,j)$ 以 $h_{i,j}$ 为高向左扫到的最远的全部是 `0` 的位置。可以看成以 $h_{i,j}$ 为高向左做的悬线。要保证子矩阵内全部是 `0`，所以最远距离应该是最短的那条悬线。可以推出 $le_{i,j} = \max{le_{i,j},le_{i-1,j}}$（注：此处 $le_{i,j}$ 指最左端的坐标，故为最大值）。

定义 $ri_{i,j}$ 为点 $(i,j)$ 以 $h_{i,j}$ 为高向右扫到的最远的的位置。同理可得 $ri_{i,j} = \min{ri_{i,j},ri_{i-1,j}}$

最后只要统计面积最大值就行。易得 $S_{i,j} = h_{i,j} \times (ri_{i,j} - le_{i,j} + 1)$

放个例子：
```
01010
000#0
###X1
10000
01000
```
`#` 为 `X` 点做的悬线。由 `X` 点算得的面积为 $2 \times 4 = 8$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
bool maps[2010][2010];
int h[2010][2010],le[2010][2010],ri[2010][2010];
int main(){
	int n;cin>>n;
	fo(i,1,n){
		fo(j,1,n){
			int x;cin>>x;
			if(x==0){
				maps[i][j]=1;
				h[i][j]=h[i-1][j]+1;//计算高
				le[i][j]=le[i][j-1];//计算该点在该行向左的悬线
			}
			else le[i][j]=j;
		}
		of(j,n+1,1)ri[i][j]=(maps[i][j]?ri[i][j+1]:j);//计算该点在该行向右的悬线
	}
	fo(i,2,n)fo(j,1,n)
		if(maps[i][j]&&maps[i-1][j])
			le[i][j]=max(le[i-1][j],le[i][j]),
			ri[i][j]=min(ri[i-1][j],ri[i][j]);//找最短的悬线
	int ans=0;
	fo(i,1,n)
		fo(j,1,n)
			ans=max(ans,h[i][j]*(ri[i][j]-le[i][j]-1));//计算面积
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Miyamizu_Mitsuha (赞：1)

感觉蛮好懂的思路。

建一个长度为 $n$ 的一维向量 $h$ 存每一列的高度。

外层循环遍历每一行，内层循环遍历每一列，然后更新高度数组 $h$。如果 $m[i][j]$ 为 $0$，则将高度数组 $h$ 对应位置 $j$ 的值加 $1$；如果 $m[i][j]$ 不为 $0$，则将高度数组 $h$ 对应位置 $j$ 的值重置为 $0$。
```
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<vector<int>> m(n, vector<int>(n));
    
    for (int i = 0; i < n; ++i) 
        for (int j = 0; j < n; ++j) 
            cin >> m[i][j];
    vector<int> h(n, 0); // 存每列的高度
    int maxx = 0;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (m[i][j] == 0) {
                h[j] += 1; // 更新高度数组
            } else {
                h[j] = 0; // 重置高度数组
            }
        }

        stack<int> s; // 单调递增栈，算最大矩形面积
        for (int j = 0; j <= n; ++j) {
            while (!s.empty() && (j == n || h[j] < h[s.top()])) {
                int H = h[s.top()];
                s.pop();
                int W = s.empty() ? -1 : s.top();
                maxx = max(maxx, H * (j - W - 1));
            }
            s.push(j);
        }
    }

    cout << maxx ;

    return 0;
}

```


---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5943)

# 前置知识

[单调栈](https://oi-wiki.org/ds/monotonous-stack/)

# 简化题意

在一个 $n \times n$ 的正方形内找到最大的由 $0$ 组成的子矩形的面积。

# 解法

令 $f_{i,j}(1 \le i,j \le n)$ 表示从 $(1,j)$ 到 $(i,j)$ 中以 $(i,j)$ 结尾的均为 $0$ 的子串长度，即 $(i,j)$ 上面可延伸的最大距离（子矩形的长）。

用单调栈的第一维存储子矩形的长，第二维存储子矩形的宽。考虑依次枚举每一行和每一列，进行出入栈的操作。当枚举到 $(i,j)$ 的位置时，记录子矩形的宽 $num$，有如下操作：

  - 对于栈中原来的元素中大于当前的长 $f_{i,j}$，要将其弹出栈，计数器 $num$ 加 $1$。
    - 子矩形的宽为弹出栈的元素个数。
    - 其所形成的子矩形面积为 $num \times $ 栈中当前的元素。
  - 将所得到的长 $f_{i,j}$ 和宽 $num$ 入栈。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define sort stable_sort 
#define endl '\n'
int f[2001][2001];
int main()
{
	int n,pd,i,j,ans=0,num;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			cin>>pd;
			if(pd==0)
			{
				f[i][j]=f[i-1][j]+1;
			}
		}
	}
	for(i=1;i<=n;i++)
	{
		stack<pair<int,int> >s;
		s.push(make_pair(f[i][1],1));
		for(j=2;j<=n;j++)
		{
			num=0;
			while(s.empty()==0&&s.top().first>f[i][j])
			{
				num+=s.top().second;
				ans=max(ans,num*s.top().first);
				s.pop();
			}
			s.push(make_pair(f[i][j],num+1));
		}
		num=0;
		while(s.empty()==0)
		{
			num+=s.top().second;
			ans=max(ans,num*s.top().first);
			s.pop();
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

# 后记

多倍经验：P4147 | UVA1330

---

## 作者：hjqhs (赞：0)

悬线法板子题，建议评绿。  
定义 $l_{i,j}$ 为点 $(i,j)$ 向左延伸最长的距离且这段距离上全是 $0$。  
定义 $r_{i,j}$ 为点 $(i,j)$ 向右延伸最长的距离且这段距离上全是 $0$。  
定义 $up_{i,j}$ 为点 $(i,j)$ 向上延伸最长的距离且这段距离上全是 $0$。  
预处理 $l,r$，然后循环是一边更新 $l,r,up$ 一边统计答案即可。
```cpp
#include<bits/stdc++.h>
// #define int long long
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
#define fv(i,p) for(int i=0;i<p.size();++i)
#define ptc putchar
#define il inline
#define reg register
// #define push_back pb
// #define mp make_pair
// #define eb emplace_back
// #define ret; return 0;
using namespace std;
const int N=2005;
const int MOD=998244353;
const int INF=0x3f3f3f3f;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
int Max(int a,int b){return a>b?a:b;}
int MAX(int a,int b,int c){return Max(a,Max(b,c));}
int Min(int a,int b){return a<b?a:b;}
int MIN(int a,int b,int c){return Min(a,Min(b,c));}
void Swap(int&a,int&b){int tmp=a;a=b;b=tmp;}
void cmin(int&x,int y){if(x>y)x=y;}
void cmax(int&x,int y){if(x<y)x=y;}
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int n,a[N][N],l[N][N],r[N][N],up[N][N],ans=-INF;
void solve(){
	n=read();
	rep(i,1,n)rep(j,1,n)a[i][j]=read(),l[i][j]=r[i][j]=j,up[i][j]=1;
	rep(i,1,n)rep(j,2,n)if(a[i][j]==a[i][j-1]&&(!a[i][j]))l[i][j]=l[i][j-1];
	rep(i,1,n)per(j,n-1,1)if(a[i][j]==a[i][j+1]&&(!a[i][j]))r[i][j]=r[i][j+1];
	rep(i,1,n)rep(j,1,n)if(!a[i][j]){
		if(i>1&&a[i][j]==a[i-1][j]&&(!a[i][j])){
			cmax(up[i][j],up[i-1][j]+1),cmax(l[i][j],l[i-1][j]),cmin(r[i][j],r[i-1][j]);
		}
		cmax(ans,up[i][j]*(r[i][j]-l[i][j]+1));
	}
	cout<<ans;
}
signed main(){
	// freopen(,,stdin);
	// freopen(,,stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```

---

## 作者：fuwei123 (赞：0)

显而易见，直接枚举肯定不行。

我们要怎么优化呢？

~~我们可以使用从 [P1169](https://www.luogu.com.cn/problem/P1169#submit) 学来的~~悬线法解决这道题。

何为“悬线法”？就是用几条线，不停地左/右/上/下移动，直到**到达边界**或者**不满足条件**，这几条线就**围出了一个矩形**，更新答案即可。（来自：[@顾z](https://www.luogu.com.cn/user/87960)）

那么，我们定义 $l_{i,j}$，$r_{i,j}$，$up_{i,j}$ 分别表示在第 $i$ 行第 $j$ 列的点最多可以向左，右，上延伸的最远点的下标。我们可以预处理出这个点所对应的 $l_{i,j}$，$r_{i,j}$，$up_{i,j}$。

我们先**不考虑 $up_{i,j}$**，只考虑第 $i$ 行上的一点 $j$，它仅仅在第 $i$ 行向左/右延申的最远距离。（在以下表述中，$a_{i,j}$ 表示题目中给定的矩阵。

- 如果 $a_{i,j}=a_{i,j-1}=0$，就令 $l_{i,j}=l_{i,j-1}$。
- 如果 $a_{i,j}=a_{i,j+1}=0$，就令 $r_{i,j}=r_{i,j+1}$。

接下来，我们考虑**行与行之间**的更新。

- 如果 $a_{i,j}=a_{i-1,j}=0$，就令 $l_{i,j}=max(l_{i,j}\ ,l_{i-1,j})$，$r_{i,j}=min(r_{i,j}\ ,r_{i-1,j})$，$up_{i,j}=max(up_{i,j}\ ,up_{i-1,j})$。

所以，我们的每一个 $i,j$ 对应的矩形面积也就是 ($l_{i,j}+r_{i,j}-1)\cdot up_{i,j}$，用它更新答案即可。

下面是 AC 代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2005
int n, l[N][N], r[N][N], up[N][N];
bool a[N][N];

int main(){
	ios::sync_with_stdio(0);
	cin >> n;
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= n;j++){
			cin >> a[i][j];
			l[i][j] = r[i][j] = j;
			up[i][j] = 1;
		}
	}
	
	for(int i = 1;i <= n;i++)
		for(int j = 2;j <= n;j++)
			if(a[i][j] == a[i][j - 1] && a[i][j] == 0)l[i][j] = l[i][j - 1];
	for(int i = 1;i <= n;i++){
		for(int j = n - 1;j >= 1;j--){
			if(a[i][j] == a[i][j + 1] && a[i][j] == 0)r[i][j] = r[i][j + 1];
		}
	}
	int jx = 0;
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= n;j++){
			if(a[i][j] == 1)continue;
			if(i > 1 && a[i][j] == a[i - 1][j] && a[i][j] == 0){
				up[i][j] = max(up[i][j], up[i - 1][j] + 1);
				l[i][j] = max(l[i][j], l[i - 1][j]);
				r[i][j] = min(r[i][j], r[i - 1][j]);
//				cout << "up:" << i << " " << j << " " << up[i][j] << " " << l[i][j] << " " << r[i][j] << "\n";
			}
			int a = r[i][j] - l[i][j] + 1;
			jx = max(jx, a * up[i][j]);
		}
	}
	cout << jx;
	return 0;
}
```


---

## 作者：DengDuck (赞：0)

我的评价是史诗级好题。

对于每一行的每个元素，可以求出 $f_{i,j}$ 表示 $(i,j)$ 开始往上有几个 $0$。

我们的思路，维护出 $f_{i,j}$ 的左右端点即可。

思路是枚举行，然后对这一行来一个单调栈，考虑根据 $f_{i,j}$ 维护一个递增的单调栈。

为什么呢？因为要是 $f_{i,j}$ 比你小，你就过不来我们弹出过程中记录下了右端点。

我们会以为左端点是 $j$ ，但是有一组 Hack。

```
2 3
1 0 1
1 1 1
```

这个 Hack 提示我们左端点不一定是 $j$，所以我们需要找到被我们弹出的元素的左端点作为左端点。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define num second
#define sum first
using namespace std;
LL n,m,a[2005][2005],f[2005][2005],ans;
char c;
stack<pair<LL,LL> >s;
int main()
{
	cin>>n;
	m=n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='0')a[i][j]=1,f[i][j]=1+f[i-1][j];
		}
	} 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			LL t=j;
			while(!s.empty()&&s.top().sum>f[i][j])
			{
				ans=max(s.top().sum*(j-s.top().num),ans);
				t=s.top().num;
				s.pop();
			}
			s.push({f[i][j],t});
		}
		while(!s.empty())
		{
			ans=max(s.top().sum*(m-s.top().num+1),ans);
			s.pop();
		}
	} 
	printf("%lld",ans);
}
```

---


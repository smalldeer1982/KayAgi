# [加油武汉] 体温调查

## 题目背景

在疫情扩散后，疾控中心的医护人员对来自武汉的人员进行了家庭访问，对体温进行测量。医护人员从疾控中心出发，按照一定顺序对所有家庭进行访问，然后汇总数据。 

家庭列表上记录着类似于`A街道B小区C号楼D户`一样的住址，按照字典顺序排列，因此每个区域中的家庭在列表中总是相邻的。医护人员在访问完某个区域（比如B1小区）的所有家庭后，需要将数据送至上一层（比如A街道）的管理机构中，然后继续访问（比如B2小区）中的家庭。

也就是说，医护人员的移动路径类似一颗**树**，其中树根代表疾控中心，树叶代表家庭，而中间的结点代表一层一层的管理区域。结点的孩子代表下一层的区域（或者家庭），是有序的。从根到某个家庭的路径上所有的点正好组成了这个家庭的地址。 

![](https://cdn.luogu.com.cn/upload/image_hosting/6zfh4ofj.png)

如图，4家的地址分别为（按顺序）
- A1-B1-C1-Z1
- A1-B1-C1-Z2
- A1-B1-Z3
- A2-B2-C3-Z4

箭头仅代表归属关系，所有路均可双向通行。

本质上，题目给出的树就是住址构成的 **字典树**/**Trie树** 。

## 题目描述

给出一颗树，根结点编号为$1$。有一名医护人员从根出发，沿着树边移动，去每个叶子采集信息，最后返回根。他的采集顺序是固定的，每当走到一个结点$u$，他会先走向编号最小的孩子，并访问完其中所有的家庭并回到$u$，然后再走向编号第二小的孩子，依此直到访问完$u$子树中所有的家庭返回上一层。可以发现访问叶子的顺序也正好是家庭住址列表上的顺序。

沿着树边移动需要一定时间，为了节约时间，可以将家庭列表分成连续的$k$段，并让$k$个医护人员同时从根出发，每人访问一个区间中的家庭然后返回。请你计算出统计完所有家庭的体温所需要的最短时间。

## 说明/提示

对 $30\%$ 的数据，$1 \le n \le 20$

对另外 $10 \%$ 的数据，$k = 1$

对另外 $20 \%$ 的数据，$k = 2$

对 $100\%$ 的数据，$1 \le n \le 2*10^5, 1 \le k \le m, 1 \le u, v \le n, 0 \le w \le 10^9$，$m$为叶子数。

### 样例说明
图示见题目背景。

第一个人的路径为RT->Z1->Z2->RT，耗时66。

第二个人的路径为RT->Z3->Z4->RT，耗时32。

让一个人访问Z2，另一个人访问Z1、Z3、Z4的方案是不合法的。

## 样例 #1

### 输入

```
11 2
1 2 2
1 3 3
2 4 1
3 5 2
4 6 2
4 7 3
5 8 1
6 9 3
6 10 25
8 11 4
```

### 输出

```
66```

# 题解

## 作者：光明正大 (赞：11)

# 二分答案！！！

比赛时看到此题仔细琢磨，感觉和[NOIP 2018赛道修建](https://www.luogu.com.cn/problem/P5021)有些类似

都是在分一定段的前提下使某个值尽可能地小（大）。

二分答案：显然是对需要时间最长的人所需要的时间，即要求的答案 $ans$ 进行二分。

如果 $ans$ 越大，那么每个人可以访问到的节点就一定不会更少，需要的人力就越少，答案具有可二分性。

所以对于每个$mid$，我们求出所需要的的人数$x$，

如果$x$ <= $k$，说明在规定时间内完成任务，则接着在左半边找；

如果$x$ > $k$，说明在规定时间完不成任务，则接着在右半边找。

问：在每次$check()$时，我们想让一个人到达尽可能多的叶子节点，如何快速的求出从叶子s能到达的距s最远的节点呢？

答：二分答案！

这一点与赛道修建比较相似，在总的二分答案的check中再次二分。

设 $s$ 走到 $t$ 花费时间 $time$，

若 $time$ <= $ans$ 则说明时间没用完，在 $t$ 到 $tot$之间找；

若 $time$ > $ans$ 则说明时间不够用，在$s$ 到 $tot$之间找。

显然在寻找最远能走到的叶子的过程中，也具有可二分性。

这里其实还有一个小问题：

如何快速地（$O(1)$）求出两个叶子之间的距离呢？

设 $dis_i$ 表示 $i$ 到 $root$ 的距离，

对于树上任意两点 $i$ , $j$  ，

它们之间的距离为 :

$dis_i$ + $dis_j$ - 2*$dis_{LCA(i,j)}$

$dis$ 数组的求解可在LCA的预处理中进行。

设 $s_i$ 表示从第一个叶子节点到第 $i$ 个节点间的距离，

若一个人把 $i$ 到 $j$ 之间的点都访问了一遍，那么他所需的时间为：（自己画个图就能明白了~~其实是我懒得画图了~~）

$s_j-s_i+dis_i+dis_j$

$s$ 数组也可以快速提前处理。

也许有人还有问题，如何保证叶子结点的顺序呢？

题目中有一句话：“本质上，题目给出的树就是住址构成的 字典树/Trie树 ”。

这就保证了按照读入的顺序跑一遍 $DFS$ 依次访问到的是编号从大到小的叶子结点(因为链式前向星是倒序遍历的，不过正倒并不影响)。

我在程序另开一个数组 $st$ 其中 $st_i$ 表示从大到小第i个叶子结点的编号：

设叶子结点为 $m$ (实际上最多为 $n-1$ )，值域为 $w$，

总复杂度为 $O(k*log(w)*log(m))$

下面是我的代码：仅供参考，略有压行，大佬不喜勿喷

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e5+10;
struct EDGE{int to,next;ll w;} e[maxn<<1];
bool nl[maxn];//not leaf 
int n,m,k,root,cnt,dep[maxn],fa[maxn][22],Log2[maxn],head[maxn];
ll dis[maxn],s[maxn];
void add(int u,int v,ll w)
{e[++cnt].to=v;e[cnt].w=w;e[cnt].next=head[u];head[u]=cnt;}
inline void dfs(int u,int f)
{
	dep[u]=dep[f]+1;fa[u][0]=f;
	for(int i=1;(1<<i)<=dep[u];i++) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=head[u];i;i=e[i].next) {
		if(e[i].to!=f) nl[u]=1,
			dis[e[i].to]=dis[u]+e[i].w,dfs(e[i].to,u);
	}
}
inline int LCA(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]) x=fa[x][Log2[dep[x]-dep[y]]-1];
	if(x==y) return x;
    for(int k=Log2[dep[x]]-1;k>=0;k--) if(fa[x][k]!=fa[y][k]) x=fa[x][k],y=fa[y][k];
    return fa[x][0];
}
int st[maxn],tot;//st[]:存叶子几点的编号 
inline void DFS(int u)//找到所有叶子结点 
{
	for(int i=head[u];i;i=e[i].next) 
		if(e[i].to!=fa[u][0]) DFS(e[i].to);
	if(!nl[u]) st[++tot]=u;
}
inline ll calc(int u,int v) {return s[v]+dis[st[v]]-s[u]+dis[st[u]];}
inline int erfen(int s,ll x)//对能走到的位置二分 
{
	int L=s,R=tot,res=s-1;
	while(L<=R) {
		int mid=(L+R)>>1;
		if(calc(s,mid)<=x) res=mid,L=mid+1;
		else R=mid-1;
	}
	return res;
}
inline bool check(ll x)
{
	int last=0,temp=0;
	for(int i=1;i<=k;i++) {
		temp=erfen(last+1,x);
		if(temp==last) return 0;
		if(temp>=tot) return 1;
		last=temp;
	}
	return temp==tot;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1,x,y,w;i<n;i++) {
    	scanf("%d%d%d",&x,&y,&w);
		add(x,y,w);add(y,x,w);
	}
    dfs(1,0);DFS(1);
    for(int i=1;i<=n;i++) Log2[i]=Log2[i-1]+(1<<Log2[i-1]==i);
    for(int i=2;i<=tot;i++) //求解s数组 
    	s[i]=s[i-1]+dis[st[i]]+dis[st[i-1]]-dis[LCA(st[i-1],st[i])]*2LL;
    ll l=1,r=1LL<<60,ans=1LL<<60;
    while(l<=r) {//对答案二分 
    	ll mid=(l+r)>>1;
    	if(check(mid)) ans=mid,r=mid-1;
    	else l=mid+1;
	}
	printf("%lld",ans);
    return 0;
}

```

代码中有些小细节还需特别注意，
总的来说是一道很不错的二分答案的题目



---

## 作者：ycy1124 (赞：2)

### 题意
题意讲的很清楚，这里不过多赘述。需要注意的是每个人记录的叶子节点必须是连续的，并且访问的顺序是按编号从小到大。
### 思路
要求将任务分段并且要求最大值的最小值，很容易想到二分答案。考虑 ```check``` 函数的实现，首先对于每个医护人员，她所需要的总时间一定是所走过的路径长度 $\times 2$。考虑如何求出一个人走的长度，首先到达的第一个叶子节点的路径是他的深度，然后移动到另一个叶子节点很容易想到 LCA 但是不难发现我们可以直接在 DFS 的时候直接加上到达他的路径长度。考虑什么时候需要新加一个医护人员，当且仅当在继续走下去他所走的路程大于 $mid$。至于新加的医护人员，他也不需要重新从根出发，只需要将他当前的路程设为当前点的深度就行。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Node{
    int to,w;
};
vector<Node>a[200005];
int dis[200005];//深度
int tot,las,ma;
inline void dfs(int p,int fa,int w){
    dis[p]=w;
    ma=(w>ma?w:ma);
    for(auto it:a[p]){
        if(it.to==fa){
            continue;
        }
        dfs(it.to,p,w+it.w);
    }
}
int Ans=0,ww;
inline void Dfs(int p,int fa,int mid){
    for(auto it:a[p]){
        if(it.to==fa){
            continue;
        }
        if(ww+it.w>mid){//再走路程就大于mid了
            Ans++;
            ww=dis[p];
        }
        ww+=it.w;
        Dfs(it.to,p,mid);
    }
}
inline bool check(int mid,int k){//check
    if(mid<ma){
        return 0;
    }
    Ans=1;
    ww=0;
    Dfs(1,0,mid);
    if(Ans<=k){
        return 1;
    }
    return 0;
}
inline bool cmp(Node x1,Node x2){
    return x1.to<x2.to;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int n,k;
    cin>>n>>k;
    for(int i=1;i<n;i++){
        int u,v,w;
        cin>>u>>v>>w;
        a[u].push_back({v,w});
        a[v].push_back({u,w});
    }
    for(int i=1;i<=n;i++){
        sort(a[i].begin(),a[i].end(),cmp);
    }
    dfs(1,0,0);
    int l=0,r=1e18,ans;
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid,k)==1){
            ans=mid;
            r=mid-1;
        }
        else{
            l=mid+1;
            ans=mid+1;
        }
    }
    cout<<ans*2;//记得*2
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/191602927)。

---

## 作者：huyangmu (赞：1)

题目的问题类似于使最大值最小，考虑二分答案。

假设现在二分出的答案是 $x$，考虑怎么判断 $x$ 是否合法。

从根开始往下深搜，因为每个医护人员最后都要回到根，类似于回溯，所以每条边要经过两次，用当前的花费加上两倍的边权，如果小于 $x$ 则继续往下深搜，搜到叶子就打上标记。否则考虑新加一个医护人员，因为树上两点距离唯一，考虑先广搜预处理出所有点到根的距离，直接加上即可。当所有叶子均被标记时，结束深搜。

注意若存在一个点到根的距离大于二分出来的 $x$，则这个 $x$ 可以直接判掉。

### AC Code


```cpp

#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N = 2e5 + 5;
int n, k, x, y, w, l, r, dis[N], ans = -1, sum, cnt, leaf;
bool t = 0;
struct Node{
	int v, w;
};
vector<Node> G[N];
bool vis[N];
void bfs(){
	queue<int> q;
	q.push(1);
	dis[1] = 0;
	for (int i = 1; i <= n; ++i) vis[i] = 0;
	while (!q.empty()){
		int tmp = q.front();
		q.pop();
		if (vis[tmp] == 1) continue;
		vis[tmp] = 1;
		for (int i = 0; i < G[tmp].size(); ++i){
			int nxt = G[tmp][i].v;
			if (vis[nxt] == 1) continue;
			dis[nxt] = dis[tmp] + G[tmp][i].w;
			q.push(nxt);
		}
	}
}
void dfs (int x, int fa, int count, int mid){
	if (t == 1 || cnt > k) return ;
	if (count == leaf) return ;
	for (int i = 0; i < G[x].size(); ++i){
		int nxt = G[x][i].v;
		if (nxt == fa) continue;
		if (sum + 2 * G[x][i].w > mid){
			cnt += 1;
			sum = 2 * dis[nxt];
			if (sum > mid){
				t = 1;
				return;
			}
		}else sum += 2 * G[x][i].w;
		if (nxt != 1 && G[nxt].size() == 1) dfs(nxt, x, count + 1, mid);
		else dfs(nxt, x, count, mid);
	}
}
bool check (int mid){
	for (int i = 1; i <= n; ++i) vis[i] = 0; 
	sum = 0, cnt = 1;
	t = 0;
	dfs(1, 0, 0, mid);
	if (t == 1) return 0;
	return cnt <= k;
}
signed main (){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n >> k;
	for (int i = 1; i < n; ++i){
		cin >> x >> y >> w;
		G[x].push_back(Node{y, w});
		G[y].push_back(Node{x, w}); 
	}
	bfs();
	for (int i = 2; i <= n; ++i){
		if (G[i].size() == 1) leaf += 1;
	}
	l = 1, r = 1e18;
	while (l <= r){
		int mid = l + r >> 1;
		if(check(mid)){
			ans = mid;
			r = mid - 1;
		}else l = mid + 1;
	} 
	cout << ans << '\n';
	return 0;
}

---

## 作者：FJ_OIer (赞：0)

这道题还是非常有难度的，~~建议升蓝~~
# 正解：二分答案
首先我们考虑如何求**一个医护人员**的用时：

**家庭的访问是有序的**。设 $a$ 表示访问家庭的顺序数组，$d$ 表示树上每个点到根的距离。若一个医护人员访问 $[a_l,a_r]$ 之间的家庭，首先访问 $a_l$，此时用时 $d_{a_l}$。如果接着访问 $a_{l+1}$ ，那么就要求出 $a_l$ 到 $a_{l+1}$ 的距离，使用倍增求 LCA 计算即可。重复下去直到算完 $a_r$，用时要额外加 $d_{a_r}$（返回根的用时）

题目给了 $k$ 个医护人员，求最短的用时，其实就是最小化 $k$ 个医护人员中**用时最长的那个**（因为是同时出发）。考虑二分。下界就是树上最长链长度乘 $2$（一个医护人员只访问一个家庭），上界可以计算（只有一个医护人员），但我~~偷懒~~直接把树上所有边权和乘 $2$。

check 函数可以贪心：枚举 $a$ 数组，表示当前医护人员能否以 $a_i$ 作为**终止家庭**（即访问区间的 $a_r$）。如果可以就一直扩大访问区间，否则就用一个新的医护人员，重新统计用时。最后判断医护人员数是否小于 $k$ 即可。

```cpp
#include <bits/stdc++.h>
#define N 200001
#define int long long
using namespace std;
struct Tree{
	int v,w;
};
int n,k,u,v,w,lg,tot,l,r,p;
int a[N],d[N],de[N],f[N][30],lca[N];
vector<Tree> e[N];
int LCA(int x,int y){//倍增求 LCA
	if (de[x]<de[y]){
		swap(x,y);
	}
	for (int i=0,p=de[x]-de[y];p;i++,p>>=1){
		if (p&1){
			x=f[x][i];
		}
	}
	for (int i=lg;i>=0;i--){
		if (f[x][i]!=f[y][i]){
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
void dfs(int u){
	if (e[u].size()==1&&u>1){//叶子
		a[++tot]=u;
		l=max(l,d[u]*2);//计算二分下界
		return;
	}
	for (int i=0;i<e[u].size();i++){
		int v=e[u][i].v;
		if (v==f[u][0]){
			continue;
		}
		int w=e[u][i].w;
		f[v][0]=u;
		d[v]=d[u]+w;//距离
		de[v]=de[u]+1;//深度
		dfs(v);
	}
}
bool check(int x){
	int cnt=1,t=d[a[1]]*2;
	//注意是终止家庭，记得随时加上返回的时间！！！（我就是因为这个死调了好久）
	for (int i=2;i<=tot;i++){
		int dis=2*d[a[i]]+d[a[i-1]]-2*d[lca[i]];//计算距离（含返回）
		if (t-d[a[i-1]]+dis<=x){
			t=t-d[a[i-1]]+dis;//先减去当前的返回时间
		}else{//重新计算时间
			cnt++;
			if (cnt>k){
				return 0;
			}
			t=d[a[i]]*2;
		}
	}
	return 1;
}
signed main(){
	cin>>n>>k;
	lg=log2(n);
	for (int i=1;i<n;i++){
		cin>>u>>v>>w;
		e[u].push_back({v,w});
		e[v].push_back({u,w});
		r+=w;
	}
	dfs(1);
	r*=2;//二分上界
	for (int j=1;j<=lg;j++){//预处理倍增数组
		for (int i=1;i<=n;i++){
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	for (int i=2;i<=tot;i++){//预处理“相邻”家庭的 LCA
		lca[i]=LCA(a[i],a[i-1]);
	}
	while (l<=r){
		int mid=(l+r)>>1;
		if (check(mid)){
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	cout<<l;
	return 0;
}
```

---

## 作者：Tjaweiof (赞：0)

# P6058 题解
两层二分答案：外层二分 **统计完所有家庭的最短时间**，判断这个时间是否能够满足要求时，二分 **每个医护人员访问的最后一个叶子节点**。

思路就是这样。怎么实现呢？

我们可以预处理出 **如果只有一个医护人员，走到第 $i$ 个叶子节点所需要的时间**。这样我们内层二分的时候判断就简单多了。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, k, u, v, nol;
long long w, s[200001], tmp;
vector <long long> e[200001];
struct Tjaweiof{
	long long num, val;
}a[200001];
long long dfs(long long x, long long sum){
	tmp += s[x];
	if (e[x].empty()){
		nol++;
		a[nol].num = tmp + sum;
		a[nol].val = sum;
		tmp += s[x];
		return (sum << 1);
	}
	long long res = 0;
	for (auto u : e[x]){
		res = max(res, dfs(u, sum + s[u]));
	}
	tmp += s[x];
	return res;
}
bool check(long long x){
	long long tmp = 1, res = 0;
	while (tmp <= nol){
		if (res >= k){
			return false;
		}
		long long L = tmp, R = nol;
		while (L < R){
			int mid = (L + R + 1) >> 1;
			if ((a[tmp].val << 1) + a[mid].num - a[tmp].num > x){
				R = mid - 1;
			} else {
				L = mid;
			}
		}
		tmp = L + 1;
		res++;
	}
	if (res <= k){
		return true;
	} else {
		return false;
	}
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    long long L, R = 0;
    cin >> n >> k;
    for (long long i = 1; i < n; i++){
    	cin >> u >> v >> w;
    	e[u].push_back(v);
    	s[v] = w;
    	R += w;
	}
	L = dfs(1, 0);
	R = R << 1;
	while (L < R){
		long long mid = (L + R) >> 1;
		if (check(mid)){
			R = mid;
		} else {
			L = mid + 1;
		}
	}
	cout << R;
    return 0;
}

```

---

## 作者：zzy0618 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P6058)

## 主要思路

首先，如果一个医护人员走在一条路径上，没能走到最下方的叶子，那么这是没有意义的，因为下一个医护人员还要在走一遍。所以我们只用考虑并记录最下方的叶子节点。

用 $num_i$ 表示从根按题目所说的**采集顺序**走到节点 $i$ 再返回所需的时间。如图红色路径的权值之和就是 $num_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/rhuocg7n.png)

用 $val_i$ 表示从根**直接**到节点 $i$ 所需时间的两倍。如图蓝色路径权值之和就是 $val_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/83btf4tl.png)

以上的 $num,val$ 可以用 dfs 一遍求出，并且按时间戳存放。

那么，从根节点走到节点 $u$，再走到节点 $v$，最后回去的距离就是 $val_u+num_v-num_u$。如图虚线便是减去的 $num_u$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z3wjh64b.png)

我们第一层对最短时间进行二分，在 check 中，我们每次二分这个医护人员可以在走多少个节点，依次向后推进，直到所有叶节点都被遍历，详见代码。

## 完整代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200005;
int n,k,res;
int l,mid,r;
vector<int> g[N];
int s[N],val[N],num[N],cnt;
inline void dfs(int u,int w){
	res+=s[u];
	if(g[u].size()==0){//叶节点 
		l=max(l,w*2);//时间至少为 max(w*2) 
		cnt++;//按时时间戳存放 
		num[cnt]=res+w;
		val[cnt]=w*2;
	}
	for(int i=0;i<g[u].size();i++)
		dfs(g[u][i],w+s[g[u][i]]);
	res+=s[u];
}
inline bool check(int x){
	int p=1,res=0;
	while(p<=cnt){
		if(res>=k)return 0;
		int l=p,r=cnt,mid;
		while(l<r){
			mid=(l+r+1)>>1;//二分细节请注意 
			if(val[p]+num[mid]-num[p]>x)r=mid-1;
			else l=mid;
		}
		p=l+1,res++;
	}
	return res<=k;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1,u,v,w;i<n;i++){
		cin>>u>>v>>w;
		g[u].push_back(v);
		s[v]=w,r+=w;
	}
	r<<=1;//时间最多也就一个医护人员走完全程 
	dfs(1,0);
	while(l<r){
		mid=(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	cout<<r;//注意l是不可行的部分，r是可行的 
	return 0;
}
```



---

## 作者：无钩七不改名 (赞：0)

## 二分 + dfs

+ 用 dfs 求出某个点到下一个点所需要的最短时间（即同一个人调查体温）和最长时间（即不同人调查体温）。

+ $2$ 次二分：第一次二分可能的最短时间，第二次二分下一个在该最短时间内所需要的调查员最少需要多少个。

+ 用 $ans_v$ 表示从根节点走到点 $v$ 并返回需要的时间，则 $ans_u-ans_v$（其中 $v$ 比 $u$ 先访问）表示 $v$ 和 $u$ 由同一个调查员运输时走到 $u$ 并走回去比走到 $v$ 并走回去多需要的时间。用一次 dfs 即可求出，具体原理可参照“时间戳”。

+ 用 $val_v$ 表示点 $v$ 到根所需要的时间的 $2$ 倍，设某调查员调查体温的范围为点 $v$~点 $u$，则需要的时间为 $val_v+ans_u-ans_v$，二分查找 $u$ 即可。

+ 关于 $val_v+ans_u-ans_v$：就是$v$ 到根所需要的时间的 $2$ 倍加上去运输时走到 $u$ 并走回去需要的时间减去走到 $v$ 并走回去需要的时间，整理一下就是从根节点走到 $v$ 的时间加上从根节点走到 $u$ 的时间再加上 $v$、$u$ 直接需要的时间

+ （注：上文中提到的 $val$ 和 $ans$ 是代码里面的结构体。）

+ ~~能补充都补充了，真的想不出还有什么需要证明的了啊喂 /ll~~


### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k;
long long ans;
long long l,r;

int val[200005];
vector<int> s[200005];

int cnt;
struct emm{
	long long val,ans;
	int num;
}a[200005];

void dfs(int u,long long w){
	ans+=val[u];
	if(s[u].empty()){
		l=max(w*2,l);
		a[++cnt].val=w*2;a[cnt].num=u;
		a[cnt].ans=ans+w;ans+=val[u];
		//cout<<u<<" "<<w*2<<" "<<a[cnt].ans<<endl;
		return;
	}
	for(int v:s[u])
		dfs(v,w+val[v]);
	ans+=val[u];
	return;
}

bool check(long long x){
	int i=1,aans=0;
	while(i<=cnt){//i还没选 
		if(i==cnt)return (aans+1)<=k;
		if(aans>=k)return 0;
		int li=i,ri=cnt,mid,res=cnt;
		while(li<=ri){
			mid=(li+ri)/2;
		//	cout<<li<<" "<<ri<<" mid:"<<mid<<" val:"<<a[i].val+a[mid].ans-a[i].ans<<endl;
			if(a[i].val+a[mid].ans-a[i].ans>x)ri=mid-1;
			else li=mid+1,res=mid;
		}
		i=res+1;//mid选了
		aans++;
	}
	return aans<=k;
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		s[u].push_back(v);
		val[v]=w;
		r+=w;
	}
	r*=2;
	dfs(1,0);
	if(k==1)return printf("%lld",r),0;
	while(l<r){
		long long mid=(l+r)/2;
	//	cout<<"***"<<l<<" "<<r<<"   mid:"<<mid<<endl;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%lld",l);
	return 0;
} 
```


感谢@[Buried_Dream](https://www.luogu.com.cn/user/396974) 和@[olegekei](https://www.luogu.com.cn/user/593613) 对本代码的 debug

qwq

**温馨提示**：[不开 long long 见祖宗](https://www.luogu.com.cn/record/list?pid=P6058&user=511609)

---


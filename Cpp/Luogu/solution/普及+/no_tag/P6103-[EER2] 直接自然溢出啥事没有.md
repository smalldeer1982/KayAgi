# [EER2] 直接自然溢出啥事没有

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/hu0gfpdv.png)

## 题目描述

给定一个整数 $n$，问有多少个长度为 $n$ 的字符串，满足这个字符串是一个“程序片段”。

具体定义如下：

单个分号 `;` 是一个“语句”。

空串 ` ` 是一个“程序片段”。

如果字符串 `A` 是“程序片段”，字符串 `B` 是“语句”，则 `AB` 是“程序片段”。

如果字符串 `A` 是“程序片段”，则 `{A}` 是“语句块”。

如果字符串 `A` 是“语句块”，则 `A` 是“语句”，`[]A` 和 `[]()A` 都是“函数”。

如果字符串 `A` 是“函数”，则 `(A)` 是“函数”，`A` 和 `A()` 都是“值”。

如果字符串 `A` 是“值”，则 `(A)` 是“值”，`A;` 是“语句”。

**注意：`A` 是 `B` 并不代表 `B` 是 `A`**。

## 说明/提示

### 样例一解释

合法的“程序片段”有：`;;;;`，`;;{}`，`;{;}`，`;{};`，`{;;}`，`{;};`，`{{}}`，`{};;`，`{}{}`。

注意：本题采用**捆绑测试**，只有当你通过一个 subtask 中的所有测试点后，你才能拿到这个 subtask 的分数。

子任务 1（$20$ 分）：$n\leq 10$。

子任务 2（$20$ 分）：$n\leq 100$。

子任务 3（$20$ 分）：$n\leq 2500$。

子任务 4（$40$ 分）：没有特殊限制。

对于 $100\%$ 的数据，$0\leq n\leq 10^4$。

## 样例 #1

### 输入

```
4```

### 输出

```
9```

## 样例 #2

### 输入

```
7```

### 输出

```
140```

# 题解

## 作者：Warriors_Cat (赞：35)

## 题解 P6103 【[EER2]直接自然溢出啥事没有】

最近一直在做树论和数论的题目，$\text{DP}$ 题倒是做得比较少，导致比赛的时候这道题没想出来。借这道题我再回顾一下我的 $\text{DP}$，顺便码一篇题解给大家。

### $Solution$:

这道题看似复杂，实际上我们一句一句来分析就很简单。

首先，我们定义状态如下：

$dp[i][0]$：表示长度为 $i$ 的字符串中 “语句” 的个数。

$dp[i][1]$：表示长度为 $i$ 的字符串中 “程序片段” 的个数。

$dp[i][2]$：表示长度为 $i$ 的字符串中 “语句块” 的个数。

$dp[i][3]$：表示长度为 $i$ 的字符串中 “函数” 的个数。

$dp[i][4]$：表示长度为 $i$ 的字符串中 “值” 的个数。

然后我们一句一句来分析：

$(i.)$ 单个分号 ``;`` 是一个“语句”。

那么 $dp\left[1\right]\left[0\right]=1$。

$(ii.)$ 空串 `` `` 是一个“程序片段”。

那么 $dp\left[0\right]\left[1\right]=1$。

$(iii.)$ 如果字符串 ``A`` 是“程序片段”，字符串 ``B`` 是“语句”，则 ``AB`` 是“程序片段”。

那么 $dp\left[1\right]\left[1\right]=1$，$dp\left[i\right]\left[1\right]=\sum_{j=0}^{i-1}dp\left[j\right]\left[1\right]\times dp\left[i-j\right]\left[0\right]$。

$(iv.)$ 如果字符串 ``A`` 是“程序片段”，则 ``{A}`` 是“语句块”。

那么 $dp\left[i\right]\left[2\right]=dp\left[i-2\right]\left[1\right]$。

$(v.)$ 如果字符串 ``A`` 是“语句块”，则 ``A`` 是“语句”，``[]A`` 和 ``[]()A`` 都是“函数”。

那么 $dp\left[i\right]\left[0\right]=dp[i][2]$，$dp\left[i\right]\left[3\right]=dp\left[i-2\right]\left[2\right]+dp\left[i-4\right]\left[2\right]$。

$(vi.)$ 如果字符串 ``A`` 是“函数”，则 ``(A)`` 是“函数”，``A`` 和 ``A()`` 都是“值”。 

那么 $dp\left[i\right]\left[3\right]+=dp\left[i-2\right]\left[3\right]$，$dp\left[i\right][4]=dp\left[i\right]\left[3\right]+dp\left[i-2\right]\left[3\right]$

$(vii.)$ 如果字符串 ``A`` 是“值”，则 ``(A)`` 是“值”，``A;`` 是“语句”。

那么 $dp\left[i\right][4]+=dp\left[i-2\right]\left[4\right]$，$dp\left[i\right]\left[0\right]+=dp\left[i-1\right]\left[4\right]$。

燃鹅这里有个问题，就是 $dp\left[i\right]\left[4\right]$ 加上 $dp\left[i-2\right]\left[4\right]$ 后可能会出现重复，所以这一 $part$ 要去掉。

总和以上分析，代码就呼之欲出啦0^_^0。

至于对 $2^{64}$ 取模，根据题目可得直接溢出即可。

### $Code$:

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int unsigned long long
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}//快读板板
inline void write(int x){
	if(x < 0) putchar('-'), x = -x;
	if(x / 10 == 0){
		putchar(x % 10 + 48);
		return;
	}
	write(x / 10);
	putchar(x % 10 + 48);
}//快输板板
int n, dp[100010][5];
// 0: 语句
// 1: 程序片段
// 2: 语句块
// 3: 函数
// 4: 值 
signed main(){
	n = read();
	dp[0][1] = dp[1][0] = dp[1][1] = 1;
	for(int i = 2; i <= n; ++i){
		dp[i][3] = dp[i - 2][2] + dp[i - 2][3];
		if(i >= 4) dp[i][3] += dp[i - 4][2];
		dp[i][2] = dp[i - 2][1];
		dp[i][0] = dp[i][2] + dp[i - 1][4];
		dp[i][4] = dp[i][3] + dp[i - 2][4];//注意这里
		for(int j = 0; j < i; ++j) dp[i][1] += dp[j][1] * dp[i - j][0];//根据上述情况模拟
	}
	write(dp[n][1]);//完结撒花-v-
	return 0;
}
```
## End

---

## 作者：NaCly_Fish (赞：32)

这里主要讲一下优化做法，最好在搞明白 $\Theta(n^2)$ 暴力递推后再看。

设 $A(x),B(x),C(x),D(x),E(x)$ 分别为 语句、程序片段、语句块、函数、值 这五种在字符串长度为 $n$ 时答案的生成函数。

那么容易列出如下函数方程组：

$$\begin{cases}B(x)=A(x)B(x)+1  \\ A(x)=C(x)+xD(x)+xE(x)+x \\ C(x)=x^2B(x) \\ D(x)=x^2C(x)+x^4C(x)+x^2D(x) \\ E(x)=x^2D(x)+x^2E(x) \end{cases}$$
接下来就是解这个五元方程组，看起来非常恶心但解并不很难。

由 $(3)$ 式代入 $(4)$ 式，得
$$D(x)=x^2D(x)+x^4B(x)+x^6B(x)$$
$$D(x)=\frac{x^4+x^6}{1-x^2}B(x)$$
再将解出的 $D(x)$ 代入 $(5)$ 式
$$E(x)=\frac{x^6+x^8}{1-x^2}B(x)+x^2E(x)$$
$$E(x)=\frac{x^6+x^8}{(1-x^2)^2}B(x)$$
将前面解出的结果一同代入 $(2)$ 式  
$$A(x)=x^2B(x)+\frac{x^5+x^7}{1-x^2}B(x)+\frac{x^7+x^9}{(1-x^2)^2}B(x)+x$$

$$A(x)=x^2B(x)+\frac{x^5+x^7}{(1-x^2)^2}B(x)+x$$
$$A(x)=\frac{x^2-2x^4+x^5+x^6+x^7}{1-2x^2+x^4}B(x)+x$$
最后回到 $(1)$ 式，已经胜利在望了！
$$B(x)=\frac{x^2-2x^4+x^5+x^6+x^7}{1-2x^2+x^4}B(x)^2+xB(x)+1$$
这是一个二次函数方程，暴力求解（指多项式开根）可以做到 $\Theta(n \log n)$。

但这样还是比较暴力，如果能 $\Theta(n)$ 算出这个二次方程中的 $\sqrt \Delta$，剩下的就能线性解决了。  
略去一堆麻烦的计算，能得到
$$\sqrt \Delta=\frac{\sqrt{1-2x-5x^2+4x^3+7x^4-6x^5-3x^6-4x^7}}{1-x^2}$$

分母很简单可以先不管，分子这个多项式比较短♂，可以利用这个式子快速开根（也适用于所有实数幂）：  
$$f(x)=g(x)^k$$
$$f'(x)g(x)=kf(x)g'(x)$$
过于显然就不证明了，提取系数就有
$$\sum_{i=0}^n(i+1)f_{i+1} g_{n-i}=k\sum_{i=0}^n(i+1)g_{i+1}f_{n-i}$$
$$(n+1)g_0f_{n+1}+\sum_{i=0}^{n-1}(i+1)f_{i+1}g_{n-i}=k\sum_{i=0}^n(i+1)g_{i+1}f_{n-i}$$
这样就能递推计算 $f(x)$ 的系数，别忘了 $g(x)$ 次数是个小常数，高次系数都为 $0$，所以算一项的复杂度为 $\Theta(1)$ 而非 $\Theta(n)$。  
至此就能 $\Theta(n)$ 计算 $\sqrt \Delta$ 的所有 $n$ 项系数了。 

最后还要除一个原方程的二次项系数（也是一个多项式），还可以用上面提到的方法求逆，然后暴力乘上分子就好了，同样是 $\Theta(n)$ 的，就不再赘述（

代码太丑就不贴了。

顺便提一句，可以证明 $B(x)$ 微分有限，那么 $b$ 为整式递推数列（这在 zzq 的 IOI2019 候选队论文中有证明），求其第 $n$ 项可以做到 $\Theta(\sqrt n \log n)$。  

这里它是一个 $14$ 阶 $1$ 次的的整式递推，感兴趣的同学可以把递推式搞出来。 

---

## 作者：xht (赞：6)

考虑递推，设 $f_i$ 表示长度为 $i$ 的「程序片段」，有 $f_0 = 1$。

注意到，「程序片段」只能是「程序片段」$+$「语句」，若设 $c_i$ 表示长度为 $i$ 的「语句」个数，则有 $f_{i} = \sum_{j=0}^{i-1} f_jc_{i-j}$，则可以 $\mathcal O(n^2)$ 递推。

考虑什么东西能当「语句」。

首先，`;` 为一个「语句」，因此有 $f_i \leftarrow f_{i-1}$。

除此之外，「语句」都必须由另外一个「程序片段」生成。

我们枚举这个「程序片段」的长度 $j$，设其为 `A`，则 `A` 的个数为 $f_j$。

它会生成 `{A}`「语句块」和 `{A}`「语句」，此时出现了「语句」，则有 $f_i \leftarrow f_{i-j-2} \times f_{j}$。

如果此时我们还想生成「语句」，那么只能走这样一条路：「语句」$\to$「函数」$\to$「值」$\to$「语句」 。

然后就无法再生成更多的「语句」了。

「语句」$\to$「函数」的过程实际上就是长度 $+2$ 或 $+4$。

「值」$\to$「语句」的过程实际上就是长度 $+1$。

我们只需要考虑「函数」$\to$「值」的过程，这也是最复杂的一个过程。

对于一个长度为 $l$ 的「函数」`A`，它会变成：

- 一个长度为 $l$ 的值 `A`；
- 两个长度为 $l+2$ 的值 `(A),A()`；
- 三个长度为 $l+4$ 的值 `((A)),(A()),(A)()`；
- 四个长度为 $l+6$ 的值 `(((A))),((A())),((A)()),((A))()`；
- $\cdots$
- $n$ 个长度为 $l+(n-1)\times 2$ 的值。

考虑到「语句」$\to$「函数」的过程长度 $+2$ 或 $+4$，「值」$\to$「语句」的过程长度 $+1$。

将这些信息整合起来可以得到 $f_i \leftarrow f_j \sum_{k=1}^{i-j-4} [k \bmod 2 = 1]k \cdot f_{i-j-4}$。

于是我们可以写出下面这个 $\mathcal O(n^3)$ 的程序：

```cpp
const int N = 1e4 + 7;
int n;
ul f[N];

int main() {
	rd(n), f[0] = 1;
	for (int i = 1; i <= n; i++) {
		f[i] = f[i-1];
		for (int j = 0; i - j - 2 >= 0; j++) {
			ul o = f[i-j-2];
			for (int k = 1; i - j - k - 4 >= 0; k += 2)
				o += f[i-j-k-4] * k;
			f[i] += o * f[j];
		}
	}
	print(f[n]);
	return 0;
}
```

然而，数据范围要求我们在 $\mathcal O(n^2)$ 的时间复杂度内解决。

考虑优化，注意到 $\sum_{k=1}^{i-j-4} [k \bmod 2 = 1]k \cdot f_{i-j-4}$ 这玩意儿可以前缀和优化 $\mathcal O(1)$ 得到，于是时间复杂度降为 $\mathcal O(n^2)$。

至于对 $2^{64}$ 取模，题目名已经告诉我们怎么做了。

```cpp
const int N = 1e4 + 7;
int n;
ul f[N], g[N];

int main() {
	rd(n), f[0] = g[1] = 1;
	for (int i = 1; i <= n; i++) {
		f[i] = f[i-1];
		for (int j = 0; i - j - 2 >= 0; j++)
			f[i] += f[i-j-2] * f[j];
		for (int j = 0; i - j - 4 >= 0; j++)
			f[i] += g[i-j-4] * f[j]; 
		for (int j = 1; i + 1 - j >= 0; j += 2)
			g[i+1] += f[i+1-j] * j;
	}
	print(f[n]);
	return 0;
}
```

---

## 作者：huangzirui (赞：6)

[题面](https://www.luogu.com.cn/problem/P6103)

乍一看题面有点长。

耐心读完可以发现是这样的关系：

(边上的数字是指某个状态转移为另一个状态需要多几个字符)
![](https://cdn.luogu.com.cn/upload/image_hosting/x9tl72j0.png)

例如从程序片段变为语句块需要加两个字符。

**特殊的是，语句转为程序片段需要加另外一个程序片段**。

数据范围 $\ \ n \leq 10^4\ $ 考虑 $\ O(n^2) dp$

**设状态 $\text{dp[i][1..5]}$ 分别为长度为 $\text{i}$ 的不同的语句，程序片段，语句块，函数和值的个数。**

然后我们很容易写出递推式：

（注意调整转移的顺序。）
```cpp
	dp[i][3]+=dp[i-2][2];
	dp[i][1]+=dp[i][3];
	dp[i][4]+=dp[i-2][3];
	if(i>=4)
		dp[i][4]+=dp[i-4][3];
	dp[i][4]+=dp[i-2][4];
	dp[i][5]+=dp[i][4];
	dp[i][6]+=dp[i-2][4];
	dp[i][5]+=dp[i-2][5];
	dp[i][1]+=dp[i-1][5];

	for(j=0;j<=i;j++)
		dp[i][2]+=dp[j][2]*dp[i-j][1];
	//此处是从语句到程序片段的转移，其中j枚举长度为j的程序片段。
```

~~然后测一下样例发现 WA 了。~~

我们在之前的考虑中只考虑了长度而并没有考虑实际的字符串。

**因此有可能出现有某些程序片段实际上算了两次。**

例如：

$\texttt{程序片段 NULL}\Rightarrow \texttt{语句块 \{\}}\Rightarrow \texttt{函数 []\{\}}\Rightarrow \texttt{函数 ([]\{\})}\Rightarrow \texttt{值 ([]\{\})}\Rightarrow \texttt{语句 ([]\{\});}\Rightarrow \texttt{程序片段 ([]\{\});}$

$\texttt{程序片段 NULL}\Rightarrow \texttt{语句块 \{\}}\Rightarrow \texttt{函数 []\{\}}\Rightarrow \texttt{值 []\{\}}\Rightarrow \texttt{值 ([]\{\})}\Rightarrow \texttt{语句 ([]\{\});}\Rightarrow \texttt{程序片段 ([]\{\});}$

我们的程序会把他们判断为不同的程序片段。

不过万幸的是，经过分析我们的程序只有这一处问题，于是我们可以加一个特判。

具体操作是新定义一个 $\ \text{dp[i][6]}\ $为末尾是 $\texttt{()}$ 的值。

然后修改一下转移：

```cpp
	dp[i][3]+=dp[i-2][2];
	
	dp[i][1]+=dp[i][3];
	dp[i][4]+=dp[i-2][3];
	if(i>=4)
	dp[i][4]+=dp[i-4][3];
	
	dp[i][4]+=dp[i-2][4];
	dp[i][5]+=dp[i][4];
	dp[i][6]+=dp[i-2][4];
	
//	dp[i][5]+=dp[i-2][5];
	dp[i][6]+=dp[i-2][6];	
	dp[i][1]+=dp[i-1][5]+dp[i-1][6];
	
	for(j=0;j<=i;j++)
		dp[i][2]+=dp[j][2]*dp[i-j][1];
```

就解决了。

~~我谔谔~~

---

## 作者：Konnyaku_ljc (赞：3)

[动态规划好题](https://www.luogu.com.cn/problem/P6103)（洛谷网校来的，mrsrz又珂愛又强！）。  
强烈建议先把题面多看几遍。读完题后，我们能发现以下结论——    
- 语句 $+$ 程序片段 $=$ 程序片段，程序片段只有这一种形式。  
- 程序片段的长度 $+2=$ 语句块。    
- #### 语句块就是语句。  
- 语句块的长度 $+2$ 或 $+4$ 是函数。     
- #### 函数的长度$+2$还是函数，函数的长度$+2$或不变都是值。    
- 值的长度$+2$还是值，值的长度$+1=$语句。  

加粗的两个提醒我们——  
- 语句块是语句，但语句不是语句块。  
- 函数都是值，但值不一定是函数。  

所以我们可以由语句块向语句转移，但不能反过来，函数与值同理。  
设$sen[N]$,$cod[N]$,$sens[N]$,$hs[N]$,$val[N]$分别代表语句,程序片段,语句块,函数,不是函数的值 。    
函数总数就是$hs_i+val_i$  
根据以上的6句~~废话~~写出以下转移方程    
 $$  sen_i = sens_i + hs_{i-1} + val_{i-1}  $$
 $$ cod_i = \sum_{j=1}^icod_{i-j}sen_i  $$
 $$ sens_i = cod_{i-2}  $$
 $$ hs_i = hs_{i-2} + sens_{i-2} + sens_{i-4}$$    
 $$ val_i = hs_{i-2} + val_{i-2}$$
 
#### 现在程序片段的数量就是之前所有片段的与此片段之后的语句的乘积总和  
别忘记初始化，长度为1时有一个语句“;”，长度为0是有一个程序片段“ ”。  
 天真的提问——怎样取模？  
 ull最大值为$2^{64}-1$，所以，当数值大于$2^{64}-1$时自动取模，即“直接自然溢出啥事没有”（我太菜了没看出来）。取模点题qwq。  
 
 代码
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll  unsigned long long
using namespace std;
const int N = 1e4+5;
ll n,sen[N],cod[N],sens[N],hs[N],val[N];
//分别为语句,程序片段,语句块,函数,不是函数的值 。
int main()
{
	cin >> n;
	sen[1] = 1 , cod[0] = 1;
	//初始化，长度为1时有一个语句“;”
	//长度为0是有一个程序片段“ ” 
	for ( int i = 1; i <= n; i++ )
	{
		sens[i] = cod[i-2];
		hs[i] = hs[i-2] + sens[i-2] + sens[i-4];
		val[i] = hs[i-2] + val[i-2];
		sen[i] += sens[i] + hs[i-1] + val[i-1];
		//sen必须在sens后更新
		//因为sen[1]=1，所以不是“=”而是“+=”。 
		for ( int j = 1; j <= i; j++ )
		{
			cod[i] += cod[i-j] * sen[j];
		}
	}
	cout << cod[n];
	return 0;
}
```
EE Round 果然够 EE。蒟蒻在此EE为敬！

---

## 作者：Guess00 (赞：3)

### 本题思路$\mathbb{:DP}$

~~个人认为部分分的搜索比正解还难写，就不讲了。~~

首先，做这道题得先把题面看清。(理清题面中总多名词中的联系)

下面开始推dp:

1. 用$a_i$数组表示长度为$i$的语句数。

   用$b_i$数组表示长度为$i$的程序片段数。

   用$c_i$数组表示长度为$i$的语句块数。

   用$d_i$数组表示长度为$i$的函数数。
 
   用$e_i$数组表示长度为$i$的值数。
   
   易得，最后输出的答案是$b_n\,.$

2. 一个语句可以通过一个语句块或一个值加上`;`得到。也就是说$a_i=c_i+e_{i-1}\,.$

3. 一个程序段可以由一个程序段和一个语句组成，即$b_i=\sum\limits_{j=1}^ia_jb_{i-j}($注意语句只能放在程序段的一段，如果两端都放会重复$).$

4. 一个语句块由一个程序片段加上`{}`得出，即$c_i=b_{i-2}\,.$

5. 一个函数可以由一个程序片段加上`[]`或一个程序片段加上`[]()`或一个函数加上`()`，即$d_i=c_{i-2}+c_{i-4}+d_{i-2}\,.$

6. 一个值由一个函数或一个函数加上`()`或一个值加上`()`，即$e_i=d_i+d_{i-2}+e_{i-2}$

这样实际上是有问题的，函数`[]`加上`()`是一个值，而函数`[]()`也是一个值，这就会出现重复，所以$e_i$应该等于$d_i+e_{i-2}\,,$这样就不会重复了。

最后还有个问题，就是模$2^{64}$这件事。根据题意(直接自然溢出啥事没有)，我们将所有`int`设成`unsigned long long int`,这玩意儿会自动模$2^{64}.$

时间复杂度$:\Theta(n^2)(b_i$的每次转移有一个$n).$

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
#define MAXN 10005
int n,i,j,a[MAXN],b[MAXN],c[MAXN],d[MAXN],e[MAXN];
inline void read(int &x)   //快读
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)  //快输
{
    if (x<0)
        putchar('-'),x=-x;
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n);
	b[0]=a[1]=b[1]=1;   //不要忘记赋初值
	for (i=2;i<=n;i++)   //dp转移
	{
		c[i]=b[i-2];
		if (i>=4)
			d[i]=c[i-2]+c[i-4]+d[i-2];
		else
			d[i]=c[i-2]+d[i-2];
		e[i]=e[i-2]+d[i];
		a[i]=e[i-1]+c[i];
		for (j=1;j<=i;j++)
			b[i]+=a[j]*b[i-j];
	}
	print(b[n]);
	return 0;
}
```

---

## 作者：liumuxin (赞：0)

## 前言
本人比较菜，考试时因为一点小问题死在了绿题上...  
考试时我写的记忆化搜索（~~打倒dp暴政，世界属于记搜~~），然后十分谔谔的调不出来第二组样例  
后来写了个正常的dp，过了，一对比发现多写了一条转移，一问才知道要去重....
这里先说记忆化搜索的方法吧，其实原理是一样的

## 思路
用五个数组分别记录五种类型的个数，当然记忆化搜索时还需要5个这样的函数
记忆化搜索的边界处理比较多
函数和数组分别定义为
```cpp
unsigned long long zh[1200000],yu[1200000],kuai[120000],han[1200000],che[1200000];
unsigned long long chengxu(unsigned long long len);
unsigned long long yujukuai(unsigned long long len);
unsigned long long hanshu(unsigned long long len);
unsigned long long zhi(unsigned long long len);
unsigned long long yuju(unsigned long long len);
```
一定有人问为啥要unsigned long long，看看题中取模的值，再看看题目就明白了  
根据题意，有如下转移

单个分号 ; 是一个“语句”，也就是说$yuju（1）=1$

空串 是一个“程序片段”。也就是说$chengxu(0)=1$

如果字符串 A 是“程序片段”，字符串 B 是“语句”，则 AB 是“程序片段”。也就是说$chengxu(len)+=\Sigma chengxu(i)*yuju(len-i)$

如果字符串 A 是“程序片段”，则 {A} 是“语句块”。也就是说$yujukuai(len)+=chengxu(len-2)$

如果字符串 A 是“语句块”，则 A 是“语句”，[]A 和 []()A 都是“函数”。也就是说$yujukua(len)+=yuju(len),hanshu[len]+=yujukuai(len-2)+yujukuai(len-4)$

如果字符串 A 是“函数”，则 (A) 是“函数”，A 和 A() 都是“值”。也就是$hanshu(len)+=hanshu(len-2),zhi(len)+=hanshu(len)+hanshu(len-2)$

如果字符串 A 是“值”，则 (A) 是“值”，A; 是“语句”。也就是说$zhi(len)+=zhi(len-2),yuju(len)+=zhi(len)$


按照这个实现就可以了，但是要注意值得计算时要去掉一条，否则会有重复的计算，所以值去重后的的全部计算如下
```cpp
unsigned long long zhi(unsigned long long len){
	//cout<<"zhi"<<len<<endl;
	if(len<=1||len>=10100)return 0;
	if(zh[len])return zh[len];
	unsigned long long ans=0;
	ans+=zhi(len-2);
	ans+=hanshu(len);
	return zh[len]=ans;
}
```
## 代码1 记忆化搜索版本
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n;
unsigned long long zh[1200000],yu[1200000],kuai[120000],han[1200000],che[1200000];
unsigned long long chengxu(unsigned long long len);
unsigned long long yujukuai(unsigned long long len);
unsigned long long hanshu(unsigned long long len);
unsigned long long zhi(unsigned long long len);
unsigned long long yuju(unsigned long long len);
int main(){
	cin>>n;
	cout<<chengxu(n)<<endl;
}
unsigned long long chengxu(unsigned long long len){//用于计算长度为len的程序片段个数的函数
//	cout<<"chengxu"<<len<<endl;
	if(len>=10100)return 0;
	if(che[len])return che[len];
	if(len==0||len==1)return 1;
	unsigned long long ans=0; 
	for(unsigned long long i=0;i<len;i++){
		ans+=chengxu(i)*yuju(len-i);
	} 
	return che[len]=ans;
}
unsigned long long yujukuai(unsigned long long len){//用于计算长度为len的语句块个数的函数
//	cout<<"yujukuai"<<len<<endl;
	if(len>=10100)return 0;
	if(kuai[len])return kuai[len];
	unsigned long long ans=0;
	ans+=chengxu(len-2);
	return kuai[len]=ans;
}
unsigned long long hanshu(unsigned long long len){//用于计算长度为len的函数个数的函数
	if(len<=0||len>=10100)return 0; 
	//	cout<<"hanshu"<<len<<endl;
	if(han[len])return han[len];
	unsigned long long ans=0;
	ans+=hanshu(len-2);
	ans+=yujukuai(len-2);
	ans+=yujukuai(len-4);
	return han[len]=ans; 
}
unsigned long long zhi(unsigned long long len){//用于计算长度为len的值个数的函数
	//cout<<"zhi"<<len<<endl;
	if(len<=1||len>=10100)return 0;
	if(zh[len])return zh[len];
	unsigned long long ans=0;
	ans+=zhi(len-2);
	ans+=hanshu(len);
	return zh[len]=ans;
}
unsigned long long yuju(unsigned long long len){//用于计算长度为len的语句个数的函数
	//cout<<"yuju"<<len<<endl;
	if(len==1)return 1;
	if(len==0)return 0;
	if(yu[len])return yu[len];
	unsigned long long ans=0;
	ans+=zhi(len-1);
	ans+=yujukuai(len);
	return yu[len]=ans;
}
```
这个代码的要点是处理边界，以及函数相互之间的嵌套很容易写错，还有就是开了Ull才能自然溢出通过此题

## 代码2 正常dp

```cpp
#include<iostream>
using namespace std;
const int maxn=1100000; 
unsigned long long n,yuju[maxn],chengxu[maxn],kuai[maxn],hanshu[maxn],zhi[maxn];
int main(){
    cin>>n;
    yuju[1]=1;
    chengxu[0]=1;
    chengxu[1]=1;
    for(int i=2;i<=n;i++){
		kuai[i]+=chengxu[i-2];
		if(i>=4)hanshu[i]+=kuai[i-4];//不要RE
        hanshu[i]+=kuai[i-2];
        hanshu[i]+=hanshu[i-2];
        zhi[i]+=zhi[i-2];
        zhi[i]+=hanshu[i];
    	yuju[i]+=zhi[i-1];
    	yuju[i]+=kuai[i]; 
        for(int j=0;j<=i;j++)//注意边界处理与代码1的不同
            chengxu[i]+=chengxu[j]*yuju[i-j];
    }
    cout<<chengxu[n]<<endl;
    return 0;
}
```
这版代码其实思路一样，但是好写一些，可是千万要注意枚举顺序，如果在计算一个数组时，要依赖于前面的数组，一定要先算完前面的才能进行更新
关于这种写法，其他的具体事项可以看前面几位大佬的题解

---

## 作者：引领天下 (赞：0)

这个题是真的善良……标题提示取模方式（

经过探索，我们发现这个对 $2^{64} $ 取模真的就是自然溢出，啥事没有。

考虑按题意模拟，但是需要注意更新顺序。

具体看代码：

```cpp
#include <bits/stdc++.h>
#define min(x,y) ((y)^(((x)^(y))&(-((x)<(y)))))
#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y)))))
using namespace std;
unsigned long long a[10001]={1}/*程序片段*/,b[10001]={0,1}/*语句*/,c[10001]/*语句块*/,d[10001]/*函数*/,e[10001]/*值*/;
int n;
inline void write(unsigned long long n){
    if(!n)return ;
    write(n/10);
    putchar(n%10+'0');
}
int main(){
    scanf("%d",&n);
    for (int i=0;i<=n;i++){
        if(i+2<=n)d[i+2]+=d[i];//A为函数，(A)为函数
        if(i+2<=n)e[i+2]+=e[i];e[i]+=d[i];if(i+2<=n)e[i+2]+=d[i];//A为函数，A是值，A()是值
        //↑注意坑点↑！一定要在更新e[i]之前更新e[i+2]，否则e[i+2]中d[i]将会被加两次！
        if(i+1<=n)b[i+1]+=e[i];//A是值，(A)是值，A;是语句
        b[i]+=c[i];if(i+2<=n)d[i+2]+=c[i];if(i+4<=n)d[i+4]+=c[i];//A是语句块，A是语句，[]A是函数，[]()A是函数
        for(int j=0;j<i;j++)a[i]+=a[j]*b[i-j];//A是程序片段，B是语句，AB是程序片段
        if(i+2<=n)c[i+2]+=a[i];//{A}是语句块
    }
    if(a[n])write(a[n]);
    else putchar('0');
    return 0;
}
```

---


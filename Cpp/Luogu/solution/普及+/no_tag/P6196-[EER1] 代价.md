# [EER1] 代价

## 题目背景

> 个人的遭遇，命运的多舛都使我被迫成熟，这一切的代价都当是日后活下去的力量。
——  三毛

小 Z 喜欢玩数字游戏。

## 题目描述

给出一个长度为 $n+2$ 的序列 $a_i$，其中第 $1$ 个数和第 $n+2$ 个数固定为 $1$。你每次可以选择序列中间的一个数删除（不能是第一个和最后一个），删除位置 $p$ 上的数的代价为 $a_{p-1} \times a_p \times a_{p+1}$。你需要执行这个操作直到无法操作为止。求最小的代价和。

## 说明/提示

样例一解释：

先删除 $3$，代价为 $6$，再删除 $2$，代价为 $2$，再删除 $1$，代价为 $1$。

总代价为 $6+2+1=9$。

---

**本题采用捆绑测试。**

对于 $100\%$ 的测试点：$1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^4$。

本题共 $6$ 个子任务，各子任务的分值及约定如下：

子任务 $1$（$1$ 分）：$a_i = 1$。

子任务 $2$（$14$ 分）：$1 \leq n \leq 10$。

子任务 $3$（$5$ 分）：$1 \leq a_i \leq 2$。

子任务 $4$（$14$ 分）：$1 \leq n \leq 40$。

子任务 $5$（$26$ 分）：$1 \leq n \leq 500$。

子任务 $6$（$40$ 分）：无特殊限制。

#### 特别感谢

idea：smrsky

solu：CYJian

data：iostream

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
9
```

## 样例 #2

### 输入

```
4
19 26 8 17```

### 输出

```
846```

## 样例 #3

### 输入

```
6
1 1 1 1 1 1```

### 输出

```
6```

# 题解

## 作者：xht (赞：33)

考虑一种简单的删除方法，按照 $1 \sim n$ 的顺序依次删除，这时的代价为 $\sum_{i = 1}^{n - 1} a_{i} \times a_{i+1} + a_{n}$。

实际上这已经是一个**较优解**了，事实上对于 $i \in [1,n)$，$a_i, a_{i+1}$ 在最终的答案中一定都要被相乘一次。原因在于假设不被相乘，就意味着 $a_i, a_{i+1}$ 其中有一个先被删除了，然而先被删除的时候一定有相乘过，因此矛盾。

现在我们找到了一个较优解 $\sum_{i = 1}^{n - 1} a_{i} \times a_{i+1} + a_{n}$，考虑如果变成最优解。

首先来看这个 $a_n$，显然可以变成 $\min_{i=1}^n a_i$，具体方法是，假设最小的位置为 $p$，我们先按照 $1 \sim p - 1$ 的顺序依次删除，再按照 $n \sim p + 1$ 的顺序依次删除即可。

再来看这个 $\sum_{i=1}^{n-1} a_i \times a_{i+1}$。

刚才提到每两个相邻的数一定要被相乘一次，但是相乘有两种情况。

上面的做法是从左往右依次删除，贡献为 $a_{i-1} \times a_i + a_i \times a_{i+1}$。

而如果从中间删除，贡献为 $a_{i-1} \times a_{i} \times a_{i+1}$。

通常情况下，前者要比后者小（因为前者只有两项相乘，而后者有三项），这也是为什么 $\sum_{i=1}^{n-1} a_i \times a_{i+1}$ 是个较优解。

但是这个「通常情况」指的是什么呢？

$a_{i-1} \times a_i + a_i \times a_{i+1} \le a_{i-1} \times a_{i} \times a_{i+1}$，即 $a_{i-1} + a_{i+1} \le a_{i-1} \times a_{i+1}$，然而后面这个等式必须要在 $a_{i-1},a_{i+1} > 1$ 的情况下才成立。

因此当某个 $a_{i} = 1$ 时，将会有更优解。

于是最终的贪心方法为：将序列从每个 $1$ 的位置分开成若干段，每一段内的代价为 $\sum a_{i} \times a_{i+1} + \min a_i$，最后再加上中间 $1$ 的个数即可。

```cpp
const int N = 1e6 + 7;
int n, a[N];
ll ans = -1;

int main() {
	rd(n), rda(a, n);
	for (int i = 0, j = 1; i <= n; i = j, j = i + 1) {
		while (j <= n && a[j] != 1) ++j;
		++ans;
		if (i + 1 != j) ans += *min_element(a + i + 1, a + j);
		for (int k = i + 1; k < j - 1; k++)
			ans += a[k] * a[k+1];
	}
	print(ans);
	return 0;
}
```

---

## 作者：StudyingFather (赞：27)

让我们一步一步来。

Note：公式如果炸的话，请在博客中查看以获得更好体验。

## Subtask 1

$a_i=1$ 时，答案显然是 $n$。

期望得分：$1$ pts。

## Subtask 2,4,5

如果做过 [能量项链](https://www.luogu.com.cn/problem/P1063) 的话，你会发现这题和那道题很像。

设 $f_{i,j}$ 为清除区间 $[i,j]$ 的最小花费，容易得到：

$$
f_{i,j}=\min f_{l,k}+f_{k,r}+a_l \times a_k \times a_r
$$

时间复杂度 $O(n^3)$，期望得分：$54$ pts，加上 Subtask 1 可得 $55$ pts。

~~后面你会发现这个做法和正解没啥关系~~

## Subtask 3

这个 Subtask 3 究竟有什么特殊性质呢？其实它才是解决本题的关键。

如果从中间开始删除 $2$ 的话，一次删除的代价可能是 $2^3=8$，而且有可能让删除别的数的代价上升（比如删除了两个 $2$ 之间的 $1$），不太划算；而如果从端点开始删除的话，代价最高也只是 $2^2=4$。

大胆猜想，我们先从左到右，删除连续的 $2$ 后，再删除剩下的 $1$，代价最小。

容易发现这确实是正确的。

期望得分：$5$ pts，加上前面的子任务可以得到 $60$ pts。

## 正解

做完了 Subtask 3 之后，你似乎已经猜到了贪心的结论：所有的 $1$ 将整个序列分为若干段，我们从左到右删除这些段的数字，最后删除 $1$，代价最小。

~~证明留给各位读者练习（其实是笔者不会严格证明）~~

```cpp
#include <iostream>
int a[1000005];
using namespace std;
int main()
{
 ios::sync_with_stdio(false);
 int n;
 long long ans=0;
 cin>>n;
 a[1]=a[n+2]=1;
 for(int i=2;i<=n+1;i++)
  cin>>a[i];
 int mina=100000;
 for(int i=2;i<=n+1;i++)
 {
  if(a[i]==1)ans++;
  else if(a[i+1]==1)
  {
   ans+=min(mina,a[i]);
   mina=100000;
  }
  else ans+=a[i]*a[i+1],mina=min(mina,a[i]);
 }
 cout<<ans<<endl;
}
```

---

## 作者：hfee (赞：10)

首先，subtask2，3，5是显然的区间DP,详情可参照P1063能量项链，这里不再赘述。

## Solution

分析一下三个数的情况：即$1,a,b,c,1$,假设$a,b,c≠1$

有以下几种情况：

$ab+bc+a,ab+bc+b,ab+bc+c$（从两边删）

$abc+ac+a,abc+ac+c$（从中间删）

$∵a,b,c\ge2$

$∴abc+ac-ab-bc = b(ac-a-c)+ac \ge 4$

$∴ab+bc<abc+ac$

所以上面一行比下面一行小，即先从两边删除小于从中间删

当数字增加，显然从中间删会比两边多乘一个数，所以我们应该从两边删。

注意到第一行唯一的区别就是最后一个删的数字，所以我们应该把最小的数留到最后，即优先删大的数

但上述的前提是不能有数为1，如果是

$1,2,3,4,1,5,6,1\ $呢？

如果按照刚才的策略，我们会依次删去$6,5,2,3,4,1$

但$6,5,4,3,2,1$是优于这个解的

我们可以把刚刚的方法推广，对于

$1,2,3,4,1$这一组单独处理，剩下的一组也单独处理

换句话说，就是以1为界，把整个数列分成一段一段的，每一段分别处理

## Code

```
#include<bits/stdc++.h>
using namespace std;
int n, a[1000005], lst = 1;
long long ans; 
void calc(int l, int r){
	lst = r + 2;
	if(l > r) return;
	while(l < r){
		if(a[l] > a[r]){ ans += a[l] * a[l + 1]; ++l;}
		else{ ans += a[r] * a[r - 1]; --r;}
	}
	ans += a[l];
}
int main(){
	scanf("%d", &n); a[0] = a[n + 1] = 1;
	for(int i = 1; i <= n; ++i){scanf("%d", &a[i]); ans += (a[i] == 1);}
    //按照刚才的策略，1肯定是最后被删去的，即每个1对答案的贡献就是1
	for(int i = 1; i <= n; ++i) if(a[i] == 1) calc(lst, i - 1); 
	calc(lst, n);
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：WYXkk (赞：6)

一看到这题，就感觉非常不可做，这个代价是什么奇奇怪怪的东西？

因此，我先写了个暴力准备找规律~~是的，我又开始找规律了~~

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=20;
ll l[N],r[N],a[N];bool del[N];int n;
int tmp[N],bst[N];
ll ans=0x3f3f3f3f3f3f3f3f;
void dfs(int x,ll now)
{
	if(x==n+1) {if(now<ans) {ans=now;F(i,1,n) bst[i]=tmp[i];}return;}
	F(i,2,n+1) if(!del[i])
	{
		del[i]=true;
		r[l[i]]=r[i];l[r[i]]=l[i];
		tmp[x]=i;
		dfs(x+1,now+a[i]*a[l[i]]*a[r[i]]);
		r[l[i]]=i;l[r[i]]=i;
		del[i]=false;
	}
}
int main()
{
	rd(n);
	F(i,1,n) rd(a[i+1]);
	a[1]=1,a[n+2]=1;
	F(i,2,n+1) l[i]=i-1,r[i]=i+1;
	dfs(1,0);
	printf("%lld\n",ans);
	F(i,1,n) printf("%d ",bst[i]-1);
	return 0;
}
```

就是一个 dfs。删除使用了双向链表模拟。同时记录了删除的顺序。

之后随机手敲了几组数据：

```plain
#1
input:
4
19 26 8 17
output:
846
1 2 4 3
--------------------
#2
input:
9
6 3 6 4 7 8 3 5 5
output:
211
1 2 3 4 5 6 9 8 7
--------------------
#3
input:
10
4 1 6 2 54 1 45 5 4 56
output:
601
1 3 5 4 2 7 8 10 9 6
```



发现删除顺序几乎都有如下规律：

- 每两个 $1$ 之间是独立的，所有 $1$ 最后处理。
- 在两个 $1$ 之间，都是先从左边开始删掉一段，然后从右边开始删干净。

然后这么写就过了。

简证：

- 假如所有 $1$ 不是最后处理，那么把它放在最后，代价一定会从一个较大的数（左右之数的积）变成较小的数（$1$）。不会更劣。
- 因此每两个 $1$ 之间的段相互独立。
- 假如某个数在两边至少一个是 $1$ 之前被删了，那么等到它两边都是 $1$ 时再删不会更劣。

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1000005;
ll a[N],pre[N],suf[N];
ll solve(int l,int r)
{
	if(l>r) return 0;
	F(i,l,r) pre[i]=pre[i-1]+a[i]*a[i+1];
	UF(i,r,l) suf[i]=suf[i+1]+a[i-1]*a[i];
	ll m=0x3f3f3f3f3f3f3f3f;
	F(i,l,r) m=min(m,pre[i-1]+suf[i+1]+a[i]);
	return m;
}
int main()
{
	int n;
	rd(n);
	F(i,1,n) rd(a[i]);
	a[0]=a[n+1]=1;
	ll ans=0;
	int lst=0,cnt=0;
	F(i,1,n+1) if(a[i]==1) {ans+=solve(lst+1,i-1);lst=i;++cnt;}
	ans+=cnt-1;
	printf("%lld\n",ans);
	return 0;
}
```

总而言之，**找 规 律 t x d y**

---

## 作者：George1123 (赞：3)

# 题解-代价

前置知识：前缀和，暴搜找规律。

**参考资料**
> 暂无

---

## 题目描述

> [代价](https://www.luogu.com.cn/problem/P6196)

> 有一个 $n+2$ 项的序列 $a_1,a_2,...,a_{n+2}$，给你 $a_2\sim a_{n+1}$，$a_1=a_{n+2}=1$，每删除一个数 $a_i$ 的代价是 $a_i\times a_{i-1}\times a_{i+1}$，求删除序列的最小代价。

> 数据范围：$1\le n\le 10^6$，$1\le a_i\le 10^4$。

---
考场上我没做出来，自闭了。

---
这题的暴力非常好写，可以写个双向链表，这样删数时维护 $a_{i+1}$ 和 $a_{i-1}$ 就非常方便了。代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
#define kk(i,n) "\n "[i<n]
const int inf=0x3f3f3f3f;
const lng Inf=1e17;

//&Data
const int N=1e6+10;
int n,l[N],r[N];
lng a[N],b[N],sm[N],tmp,ans=Inf;

//&Main
void dfs(int x,lng sum){//我写了一个ida*，但其实没必要
	if(sum+sm[(n+1-x)]>=ans) return;
	if(x==n+1){ans=sum;return;}
	for(int i=r[0];i!=n+1;i=r[i]){
		l[r[i]]=l[i],r[l[i]]=r[i];
		dfs(x+1,sum+a[i]*a[l[i]]*a[r[i]]);
		l[r[i]]=i,r[l[i]]=i;
	}
}
int main(){
	scanf("%d",&n);
	a[0]=a[n+1]=1;
	r[0]=1,l[n+1]=n;
	for(int i=1;i<=n;i++){
		scanf("%lld",a+i),b[i]=a[i];
		l[i]=i-1,r[i]=i+1;
		tmp=min(tmp,a[i]);
	}
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)
		sm[i]=sm[i-1]+b[i];
	dfs(1,0);
	printf("%lld\n",ans);
	return 0;
}

```

时间复杂度是必爆的，但是这种结论题，可以用**暴搜找规律**（我考场上没想到啊啊啊）。多造几个序列，最好小一点，要不然暴搜太慢。然后看暴搜最佳选择方案，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
#define kk(i,n) "\n "[i<n]
const int inf=0x3f3f3f3f;
const lng Inf=1e17;

//&Data
const int N=1e6+10;
int n,l[N],r[N],xuan[N],as[N];
lng a[N],tmp,ans=Inf;

//&Main
void dfs(int x,lng sum){
	if(sum+(n+1-x)*tmp>=ans) return;
	if(x==n+1){
		ans=sum;
		memcpy(as,xuan,sizeof xuan);
		return;
	}
	for(int i=r[0];i!=n+1;i=r[i]){
		l[r[i]]=l[i],r[l[i]]=r[i];
		xuan[x]=i;
		dfs(x+1,sum+a[i]*a[l[i]]*a[r[i]]);
		l[r[i]]=i,r[l[i]]=i;
	}
}
int main(){
	scanf("%d",&n);
	if(n>10) return printf("%d\n",n),0;
	a[0]=a[n+1]=1;
	r[0]=1,l[n+1]=n;
	for(int i=1;i<=n;i++){
		scanf("%lld",a+i);
		l[i]=i-1,r[i]=i+1;
		tmp=min(tmp,a[i]);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++) printf("%d%c",as[i],kk(i,n));
	printf("%lld\n",ans);
	return 0;
}
```

然后你会发现，最优删法大部分都是**从两边开始删**的，唯独类似于

```cpp
1 1 5 1 1 //n=3
```
这样的序列，不得不从中间把大的数去掉。

然后你能会脑洞大开，但是最终的正确方法是——**把每个两边是 $1$ 并且不包含 $1$ 的子序列从两边删，然后最后删 $1$。**

**大致证明:**

$\texttt{First}$ ... $1$ 必须最后取。

如果不最后取 $a_i=1$，那么取 $1$ 还会有 $a_{i-1}\times a_{i+1}$ 的代价，并且取走两边的数的代价肯定会有个因子 $a_{i-1}\times a_{i+1}$。

而最后取 $a_i=1$，代价为 $1$（因为最后只剩 $1$ 了），并且取 $a_{i-1}$ 和 $a_{i+1}$ 时也能把因子 $1$ 用上。

$\texttt{Second}$ ... 每个不包含 $1$ 并且两边是 $1$ 的序列从两边删最佳。

如果从两边删就相当于代价只有相邻两项的乘积（因为左边或右边一定是 $1$），然后如果不从两边删代价至少为三项相乘，最后总和总是要大一点的（**真是很口胡的证明，得出结论还是主要靠找规律**）。

---

然后要知道得到了一个不包含 $1$ 并且两边是 $1$ 的区间 $[L,R]$ 要怎么 $\Theta(R-L+1)$ 求最优取法（数据范围已经说明了时间复杂度）。

设 $[L,R]$ 最后取的数为 $a_t(L\le t\le R)$，那么从 $a_L$ 一直取到 $a_{t-1}$ 的代价是

$$\sum\limits_{i=L}^{t-1}a_i\times a_{i+1}$$

因为每次取的数左边肯定是 $1$。

同理，从 $a_R$ 向左取到 $a_{t+1}$ 的代价是 

$$\sum\limits_{i=t+1}^{R}a_i\times a_{i-1}$$

然后取 $a_t$ 的代价是 $1\times a_t\times 1=a_t$。

所以**总代价**是 

$$W_t=\sum\limits_{i=L}^{t-1}a_i\times a_{i+1}+\sum\limits_{i=t+1}^{R}a_i\times a_{i-1}+a_t$$

而这个式子的前两项可以**用前缀后缀和维护**。

区间 $[L,R]$ 最优取法的代价就是

$$\min\{W_t\}(t\in[L,R])$$

所以拿到区间 $[L,R]$ 求最优取法就是 $\Theta(R-L+1)$。

因为最后每取一个 $1$ 的代价是 $1$，所以最后答案是

$$\sum\limits_{[L,R]}\min\{W_t(t\in[L,R])\}+\sum\limits_{i=2}^{n+1}[a_i=1]$$

所以总时间复杂度 $\Theta(n)$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
#define kk(i,n) "\n "[i<n]
const int inf=0x3f3f3f3f;
const lng Inf=1e17;

//&Data
const int N=1e6+10;
int n;
lng a[N],sm[N],ms[N],ans;

//&Main
void solve(int l,int r){
	for(int i=l+1;i<=r;i++) sm[i]=sm[i-1]+a[i]*a[i-1]; //前缀和
	for(int i=r-1;i>=l;i--) ms[i]=ms[i+1]+a[i]*a[i+1]; //后缀和
	lng res=Inf;
	for(int i=l;i<=r;i++) res=min(res,a[i]+sm[i]+ms[i]);
	ans+=(res==Inf)?0:res; //如果序列长度为0，特判一下
}
int main(){
	scanf("%d",&n),a[0]=a[n+1]=1;//用0~n+1代替1~n+2
	for(int i=1;i<=n;i++) scanf("%lld",a+i);
	for(int lst=0,i=1;i<=n+1;i++)if(a[i]==1) solve(lst+1,i-1),lst=i,ans++;
	printf("%lld\n",ans-1);//为了方便统计区间，把n+2的1也算进去了，减掉
	return 0;
}
```
**祝大家学习愉快！**


---

## 作者：Azazеl (赞：3)

来晚了，只能写T3的题解了。  


------------
### 题意  
$\ \ \ \ \ \ \ $ 给定一个长度为 $n$ 的序列，删除第 $i$ 个数的代价为 $a_{i-1}\times a_i\times a_{i+1}$。其中 $a_0,a_{n+1}=1$且不可删除，求最小的删除 $n$ 个数的代价。  

### 题解  

#### 对于前5个subtask:
$\ \ \ \ \ \ \ $可以考虑一个 $\mathcal{O}(n^2)$ 的区间DP，在这里就不详述过程了。大体就是设 $dp_{i,j}$ 表示处理区间 $i,j$ 的最小代价，转移方程就是  
$$dp_{i,j}=dp_{i,k-1}+dp_{k+1,j}+dp_{k-1}\times dp_k \times dp_{k+1}$$  

$\ \ \ \ \ \ \ $这样应该就有 $60pts$,部分分很足很友好。  

#### 对于所有测试点  
$\ \ \ \ \ \ \ $由于需要最小代价，我们考虑到在这个序列中，删除所有相邻的数中有 $1$ 的数代价一定是比删除相邻的数中没有 $1$ 的数的代价小的。  

$\ \ \ \ \ \ \ $证明：删除第一个数的代价为 $a_1\times a_2$，删除第二个数的代价为 $a_1\times a_2\times a_3$,故当且仅当 $a_3=1$ 时删除第一个数的代价 $=$ 删除第二个数的代价。故当 $a_3 ≠ 1$ 时，删除第一个数一定比删除第二个数更优。同理可得删除第 $n$ 个数一定比删除第 $n-1$ 个数更优。而为了让两边的 $1$ 多发挥作用，一定是删除两边的数使得更多的数能利用 $1$ 。  

$\ \ \ \ \ \ \ $那么删除时，我们自然可以想到将由两个 $1$ 包裹的区间进行计算，而如果序列中有 $1$ 一定是留在最后删除，$ans\leftarrow ans+1\times1\times1=ans+1$  

$\ \ \ \ \ \ \ $而删除时，我们可以发现最大的问题在于是先删左边还是右边的数。鉴于这道题考虑大小，因此大小就是最需要考虑的问题。  

$\ \ \ \ \ \ \ $举个例子，```3 2```，这时我们可以发现先删 $3$ 更小，为什么呢？因为**更大的数留在最后越有可能参与对某个数的删除造成影响**。所以最后的**贪心**策略就很明显了：将每个被 $1$ 包裹的区间进行一次 ```solve()```，按照上面的策略进行删除，最后统计答案。因此遇到 $1$ 就得先划分区间，再 ```ans++```  

$\ \ \ \ \ \ \ \mathcal{CODE}$  
```cpp
#include <cstdio>
#define ll long long
int arr[1000005];
ll ans;
inline void solve(int l,int r)
{
	if(l>r) return;
	while(l<=r)//这里的边界要注意
	{
		if(l==r) ans+=arr[l],l++;//当重合时就只剩一个数以及两边的1了
		else if(arr[l]>arr[r]) ans+=arr[l]*arr[l+1],l++;
		else ans+=arr[r]*arr[r-1],r--;
	}
	return;
}
inline void read(int &x)
{
	int f=1;x=0;char c=getchar();
	while(!('0'<=c&&c<='9')){if(c=='-')f=-1;c=getchar();}
	while('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	x*=f;
}
int main() {
	int n;
	read(n);
	for(int i=1;i<=n;i++) read(arr[i]);
	register int last=1;
	for(register int i=1;i<=n;i++)
	{
		if(arr[i]==1)
		{
			solve(last,i-1);
			last=i+1;
			ans++;
		}
	}
	solve(last,n);
	printf("%lld",ans);
	return 0;
}
```
还清楚吗？清楚就点个赞嗷~，同时欢迎评论指出不足。

---

## 作者：FjswYuzu (赞：2)

因为我的“正解”只能过 Subtask 1 和 6，所以会把部分分全部打一遍，请见谅。

### Subtask 1

考虑到所有 $a_i \leq 1$，因此每个数的贡献为 $1$，答案为 $n$。


### Subtask 2,4,5

数据范围在 $O(n^3)$ 级别，考虑区间 dp。

定义 $dp_{i,j}$ 为消除区间 $[i,j]$ 的所有数的最小代价，有 dp 式：

$$dp_{i,j}=\min \{ dp_{l,mid-1}+dp_{mid,r}+a_{mid} \times a_{l-1} \times a_{r+1}\}$$

其中 $l \leq mid \leq r$。枚举区间并枚举划分点。

### Subtask 3

要让 $2$ 的代价尽量少，我们考虑每次找到全为 $2$ 的区间，设这段区间的长度为 $d$，其贡献为 $4 \times d-2$。

答案即为 $1$ 的个数加上每个全为 $2$ 的区间的代价。

### Subtask 6

要使答案最小，我们考虑让每一个数的代价最小。

以 $1$ 为突破口，如果我们放到最后删除，一定能使 $1$ 的代价最小。

每段 $1$ 的区间相互独立，考虑计算每一个没有 $1$ 的区间 $[l,r]$，此时 $a_{l-1}=a_{r+1}=1$。如果我们从中间划分，一定比从旁边划分大。

因而考虑分开统计，计算贡献即可。

注意：`calc(int,int)` 函数是有问题的，如果只看只能过第 6 个 Subtask。所以只能在月赛考场上所有部分分都打一遍了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
long long read()
{
	long long x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
long long a[1000005],dp[505][505];
int n;
long long calc(int l,int r)//Subtask 6
{
	long long ans=0;
	if(l>=r)	return 0;
	while(l<r)
	{
		if(a[l]<=a[r])	ans+=a[r]*a[r-1],--r;
		else	ans+=a[l]*a[l+1],++l;
	}
	ans+=a[l];
	return ans;
}
long long DP()//Subtask 2,4,5
{
	a[0]=1,a[n+1]=1;
	for(int i=1;i<=n;++i)	for(int j=i;j<=n;++j)	dp[i][j]=214748364788888ll;
	for(int dis=1;dis<=n;++dis)
	{
		for(int l=1,r=dis;r<=n;++l,++r)
		{
			for(int cut=l;cut<=r;++cut)
			{
				long long sth=a[cut]*a[l-1]*a[r+1];
				dp[l][r]=min(dp[l][r],dp[l][cut-1]+dp[cut+1][r]+sth);
			}
		}
	}
	return dp[1][n];
}
long long SpecialSolve()//Subtask 3
{
	long long ans=0;
	for(int i=1;i<=n;++i)	ans+=(a[i]==1);
	for(int i=1;i<=n;++i)
	{
		if(a[i]==2)
		{
			int l=i;
			int r=i;
			for(;a[r]==2 && r<=n;++r);
			ans+=4*(r-l)-2;
			i=r;
		}
	}
	return ans;
}
int main(){
	long long ans=0;
	bool flag=true,flag2=true;
	n=read();
	for(int i=1;i<=n;++i)	a[i]=read(),ans+=(a[i]==1),flag&=(a[i]==1),flag2&=(a[i]<=2);
	if(flag)	return printf("%d",n)&0;//Subtask 1
	if(n<=500)	return printf("%lld",DP())&0;
	if(flag2)	return printf("%lld",SpecialSolve())&0;
	int pre=1;
	for(int i=1;i<=n;++i)	if(a[i]==1)	ans+=calc(pre,i-1),pre=i+1;
	ans+=calc(pre,n);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：袁宇轩 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6196)

大致**题意**为：给出一个序列`a`，其中`a[1]`和`a[n+2]`为1，每次删掉一个数的代价为`a[i-1]*a[i]*a[i+1]`，如果`a[i-1]`或`a[i+1]`已经被删掉，则往两边继续寻找第一个没被删除的数，`a[1]`和`a[n+2]`不能被删，求代价和最小。

------------

那么我们发现 `1` 这个数字很特别，因为 `1*x=x` ，相当于对产生的代价没有作用，那么我们就以 `1` 作为突破口。

对样例手模后可以发现，删数的步骤都是**从两边往中间删**，因为每次的代价都只有两个数相乘，代价和肯定最小。

但不过要注意一点：**最后一个留下来的数必须是最小的**。这样相对于最后一次的代价肯定是最小的。

我们可以对上面做一个简单的**证明**：

    假如有序列 1,x,y,z,1 ,且 y<x<z 。

    那么从两边往中间去的代价和 sum1=xy+yz+y;

    那么从中间开始取的代价和 sum2=xyz+xz+x;

    ∵ xy<xyz，yz<xz，y<x
    
    ∴ sum1<sum2
    
那么我们就有了最开始的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)
inline ll read(){
	ll x=0;char ch=getchar();bool f=0;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return f?-x:x;
}
void write(ll x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);putchar(x%10+'0');
}
void writeln(ll x){write(x);puts("");}
void writep(ll x){write(x);putchar(' ');}

int const N=1e6+3;
int n,a[N];
ll ans;

int main(){
	n=read();
	for (int i=1;i<=n;i++)
	  a[i]=read();
	int l=1,r=n;
	while (l<r){
		if (a[l]>a[r]){
			ans+=a[l]*a[l+1];
			l++;
		}
		else{
			ans+=a[r]*a[r-1];
			r--;
		}
	}
	ans+=a[l];
	writeln(ans);
	return 0; 
}
```
但不过这样子只有1分的好成绩。

随后经过我长达1小时的思考，终于发现序列中也是可能有1的。

那么之前的方案就可以用到两个1中的区间里，我们可以顺着思路把序列分成若干个区间，对每个区间做一次。

时间复杂度是优秀的 `O(n）`。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)
inline ll read(){
	ll x=0;char ch=getchar();bool f=0;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return f?-x:x;
}
void write(ull x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);putchar(x%10+'0');
}
void writeln(ull x){write(x);puts("");}
void writep(ull x){write(x);putchar(' ');}

int const N=1e6+3;
int n,a[N];
ull ans;

int main(){
	n=read();
	for (int i=1;i<=n;i++)
	  a[i]=read();
	int l=1,r;//左右指针 
	a[n+1]=1;//末尾加上一个1，方便之后的处理 
	for (int i=1;i<=n+1;i++)
	  if (a[i]==1){//找到1 
	  	  r=i-1;//框定区间 
	  	  if (l<=r) ans++;//如果区间为1 ... 1那么就要加上1的代价，否则1的代价会在下面的ans+=a[l]被处理 
		  while (l<r){//对区间处理 
		  	  if (a[l]>a[r] || a[l]==a[r] && a[l]*a[l+1]<a[r]*a[r-1]){//从两边往中间取，并取相对大的数 
				  ans+=a[l]*a[l+1];
				  l++;
			  }
			  else{
				  ans+=a[r]*a[r-1];
				  r--;
			  }
		  }
		  ans+=a[l];//加上最后一取的数 
		  l=i+1;//左指针指到下一个区间 
	  }
	writeln(ans-1);//因为我们把最后一个1也算了进去（实际上是不用的，所以要-1） 
	return 0; 
}
```


---

## 作者：Warriors_Cat (赞：1)

## 题解 P6196 【[EER1]代价】

### $Solution:$

其实这道题我已经想到了半正解了……

考场 $1$ 分代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long 
#define R register
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
inline void write(int x){
	if(x / 10 == 0){
		putchar(x % 10 + 48);
		return;
	}
	write(x / 10);
	putchar(x % 10 + 48);
}
int n, a[1000010], l, r, ans, x = 0x7fffffff, y = 0x7fffffff; 
signed main(){
	n = read();
	for(R int i = 1; i <= n; ++i) a[i] = read(), x = min(x, a[i]);
	for(R int i = 1; i < n; ++i) ans += a[i] * a[i + 1];
	ans += x;
	write(ans);
	return 0;
}
```
其实这就是一道贪心，也就是说，您每次只能选与 $1$ 相邻的，要不然这个数有三次，会很大。

然后左右指针往中间扫，我们就能发现，当 **没有1的时候**，答案就是：

$$\sum_{i=1}^{n-1}a_i a_{i+1} + \min\{a_i\}$$

但，这里中间有 $1$ 啊……

那还不简单，就把 $1$ 当“隔板”，分成若干块，每一块都像上面求一下就可以啦。

最后把所有的 $1$ 再删掉，整道题就做完惹QWQ。

下面附 $100$ 分代码：

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long 
#define R register
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
int n, a[1000010], l, r, ans, num;//num 存 1 的个数 
inline int work(int l, int r){
	int sum = 0, x = 0x7fffffff;
	for(R int i = l; i < r; ++i) sum += a[i] * a[i + 1], x = min(x, a[i]);
	sum += min(x, a[r]);
	return sum;
}//跟上面的很像
signed main(){
	n = read();
	for(R int i = 1; i <= n; ++i){
		a[i] = read();
		if(a[i] == 1){
			if(l == i - 1){
				l = i;
				num++;
				continue;
			}//如果两个相邻的 1 就不用删了
			ans += work(l + 1, i - 1);
			l = i;
			num++;
		}
	}
	if(l < n) ans += work(l + 1, n);//注意最后还要做一次
	printf("%lld", ans + num);//输出
	return 0;//完结撒花-v-
}
```
## End

---

## 作者：VinstaG173 (赞：1)

首先有两个 $1$ 在两端是一个提示了……

其实这题的子任务提示性很强，如果你想通了 $6$ 分做法并且会了样例 $2$ 就离正解不远了……

我们都知道你删的数最好有一边是 $1$，这样代价是二次级别的，比三次级别不知道高到哪去了。

所以我们把一段连续均不为 $1$ 的看作一个子序列，对于每个子序列分别求解。

然后我们知道一个子序列删除掉一些元素，产生的代价为其中每相邻两个数的和，最终会有一个数留下，这个数被删除时的代价为其数值。于是我们只要让其中最小数最终留下来就行了。注意每个 $1$ 的代价是 $1$。

Code:
```cpp
#pragma GCC target("avx")
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<cstdio>
#define ll long long
int n,x[1000007],l,m;
ll ans;
inline char rc()
{
	static char buf[262147],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,262145,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
int main()
{
	n=read();
	l=1;
	for(register int i=1;i<=n;++i)
	{
		x[i]=read();
		if(x[i]==1)
		{
			if(l<i)
			{
				m=x[l++];
				for(;l<i;++l)
				{
					ans+=x[l]*x[l-1],(x[l]<m)&&(m=x[l]);
				}
				ans+=m;
			}
			++ans,++l;
		}
	}
	if(l<=n)
	{
		m=x[l++];
		for(;l<=n;++l)
		{
			ans+=x[l]*x[l-1],(x[l]<m)&&(m=x[l]);
		}
		ans+=m;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：lxy__ (赞：1)

## Solution

假设存在一个数列，$a_1,a_2,a_3,a_4,a_5$

考虑删除 $a_4,a_5$ 的顺序：

若先删除 $a_4$，代价为 $a_3*a_4*a_5 + a_3*a_5$

若先删除 $a_5$，代价为 $a_4*a_5 + a_3*a_4$

第一种显然不比第二种优，所以得出结论：每次都删除两边的数（这里的两边是指与 $1$ 相邻的数）。

并且可以证明，按照上面的规则，无论删除的顺序如何，删完 $n-1$ 个数后答案总是相同的，即为：$a_1*a_2 + a_2*a_3 + ... + a_{n-1}*a_n$

若现在还剩最后一个数字，它的值会直接加到答案中。我们肯定希望这个数字越小越好，所以直接在数列中找到一个最小值作为最后删除的数。

需要注意的是，数列中若出现 $1$，可以看作是把序列切割成了几段，每一段要分别处理。这些 $1$ 最终也要删除并计入答案。

## Code

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const long long INF = 0x3f3f3f3f;
long long n, ans = 0, a[2000000], min_ = INF;
int main()
{
	scanf("%lld", &n);
	a[0] = a[n + 2] = 1;
	for(int i = 1; i <= n; i++)
	{
		scanf("%lld", &a[i]);
		if(a[i] == 1)
		{
			if(min_ != INF) ans += min_;
			ans++, min_ = INF;
			continue;
		}
		if(a[i - 1] != 1) ans += a[i] * a[i - 1];
		min_ = min(min_, a[i]);
	}
	if(min_ == INF) min_ = 0;
	printf("%lld", ans + min_);
	return 0;
}
```

---


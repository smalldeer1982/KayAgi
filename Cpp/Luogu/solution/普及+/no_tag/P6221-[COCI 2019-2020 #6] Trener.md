# [COCI 2019/2020 #6] Trener

## 题目背景

题目翻译来自 [LOJ3270](https://loj.ac/problem/3270)。

## 题目描述

**译自 [COCI 2019/2020 Contest #6](https://hsin.hr/coci/archive/2019_2020/) T5.** ***[Trener](https://hsin.hr/coci/archive/2019_2020/contest6_tasks.pdf)***

我们已经知道了学生们喜欢睡觉。Patrik 是这一记录的保持者。在最后一个梦中，他发现自己成为了他最喜欢的球队的队长。

为了参加一场比赛，他把自己的所有球员分为 $N$ 组，每组 $K$ 名球员，对于第 $i$ 组的球员，他们的姓氏长度都为 $i$。

现在，他要开始规划上场的球员组合了。一个组合有 $N$ 名球员，并且组委会对上场的球队还有有以下要求：

- 所有球员的姓氏长度必须不同。

- 所有球员的姓氏必须为其他姓氏比他长一个字符的球员的连续子序列。

Patrik 想知道，自己最多能把这些球员分为多少支可以上场的队伍。答案对 $10^9+7$ 取模。

## 说明/提示

#### 样例 $1$ 说明：
可以分为如下队伍：

`(a, ab, abc), (a, ab,abd), (b, ab, abc), (b, ab, abd), (b, bd, abd)`。

----

#### 数据范围：

对于 $100\%$ 的数据，$1\le N\le 50$，$1\leq K\leq 1500$。

|任务编号|特殊限制|分值|
|:-:|:-:|:-:|
|$0$|为样例|$0$|
|$1$|$N=5,K=10$|$20$|
|$2$|$N=50,K=100$|$30$|
|$3$|无特殊限制。|$50$|

## 样例 #1

### 输入

```
3 2
a b
ab bd
abc abd```

### 输出

```
5```

## 样例 #2

### 输入

```
3 3
a b c
aa ab ac
aaa aab aca```

### 输出

```
6```

## 样例 #3

### 输入

```
3 1
a
bc
def```

### 输出

```
0```

# 题解

## 作者：naturelyf (赞：4)

##### 题外话
这套题考的模拟赛，三四题都稍显抽象（没考第一题），就二和五题能做一下，但还被背刺了，DFS 直接爆栈了，~~学校 OJ 翻译不全真是晦气~~是道好题。
### 题目大意
给定 $n$ 组人，每组选一人，要求前一组人的姓名必须是后一组的连续子串，求有多少种合法答案。
### 解题思路
考虑建图。我们可以将问题看作一第一组为起点，走到最后一组，算做一种解，理论可行，开始实践。
### 代码思路
#### 暴力
首先考虑暴力，强行判断是不是下一组的连续子串，最后简单动态规划统计方案，也可以用记忆化。期望时间复杂度 $O(nk^3)$，代码如下（有注释）：
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;
const int N=2000,MOD=1e9+7;
string s[51][1500];
int n,k;
bool check(string a,string b){
	int l=a.size();
	int fl=0;
	for(int i=0,j=0;i<l;i++,j++){
		if(a[i]!=b[j]){
			fl++;
			break;	
		}
	}//这里是看看是第一个不同还是最后一个不同
	for(int i=0,j=1;i<l;i++,j++){
		if(a[i]!=b[j]){
			fl++;
			break;	
		}
	}
	if(fl==2)return false;
	return true;
}
vector<int> edge[N*N];
int f[N*N];
void add(int u,int v){
	edge[u].push_back(v);
}
int dfs(int u){
	if(f[u])return f[u];
	for(int v:edge[u]){
		f[u]+=dfs(v);
		f[u]%=MOD;
	}
	f[u]%=MOD;
	return f[u];
}//状态转移方程式太难辣，直接记忆化
signed main(){
	freopen("trener.in","r",stdin);
	freopen("trener.out","w",stdout);
	cin>>n>>k;
	for(int i=1;i<=k;i++)f[i]=1;
	for(int i=1;i<=k;i++)add(i,0);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++)
			cin>>s[i][j];
	}
	for(int i=1;i<n;i++){
		for(int j=1;j<=k;j++){
			string s1=s[i][j];
			for(int p=1;p<=k;p++)
				if(check(s1,s[i+1][p])){
					add(p+i*k,j+(i-1)*k);
				}//从下向上连边，方便搜索。
		}//这里相当于将二位平铺成一维，方便建图。
	}
//	for(int i=0;i<=n*k;i++){
//		for(int j:edge[i])
//			cout<<i<<" "<<j<<'\n';
//	}
	int ans=0;
	for(int i=k*n;i>k*(n-1);i--)ans+=dfs(i),ans%=MOD;
//	for(int i=1;i<=n*k;i++)
//	cout<<f[i]<<" ";
	cout<<ans;
	return 0;
}
```
#### 优化
打完之后恭喜你，获得 $50$ 分！仔细观察就能发现大有优化的余地。输入是 $O(nk^2)$，没有优化空间，枚举也是如此，只有判断相等开销大并且可以优化，回想我们学过的方法，有没有什么能 $O(1)$ 判断字符串相同呢，对啦，就是哈希，想到这点十分开心，直接把代码打出来：
```cpp
#include<bits/stdc++.h>
#define int long long

#define ull unsigned long long

using namespace std;
const int N=51*1510,mod=1e18+9,MOD=1e9+7,base=131;
string s;
int n,k;
ull Hash[52][1510][3];
int HASH(string a){
	ull pr=base,res=0;
	int l=a.size();
	for(int i=0;i<l;i++){
		res=res+pr*(ull)(a[i]-'a'+1)%mod;
		res%=mod;
		pr*=base;
		pr%=mod;
	}
	return res;
}
bool check(int x,int y,int xx,int yy){
	if(Hash[x][y][2]==Hash[xx][yy][0]||Hash[x][y][2]==Hash[xx][yy][1])
		return true;
	return false;
}
vector<int> edge[N];
int f[N];
void add(int u,int v){
	edge[u].push_back(v);
}
int dfs(int u){
	if(f[u])return f[u];
	for(int v:edge[u]){
		f[u]+=dfs(v);
		f[u]%=MOD;
	}
	f[u]%=MOD;
	return f[u];
}
int in[N];
signed main(){
	freopen("trener.in","r",stdin);
	freopen("trener.out","w",stdout);
	cin>>n>>k;
	for(int i=1;i<=k;i++)f[i]=1,in[i]=1;
	for(int i=1;i<=k;i++)add(i,0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++){
			cin>>s;
			Hash[i][j][2]=HASH(s);
			if(i==1){
				Hash[i][j][0]=base*(ull)(s[0]-'a'+1);
				Hash[i][j][1]=base*(ull)(s[0]-'a'+1);
				continue;
			}
			char c=s.front();
			s.erase(s.begin());
			Hash[i][j][0]=HASH(s);
			s.insert(s.begin(),c);
			s.pop_back();
			Hash[i][j][1]=HASH(s);
		}
	for(int i=1;i<n;i++){
		for(int j=1;j<=k;j++){
			if(!in[j+(i-1)*k])continue;
			for(int p=1;p<=k;p++)
				if(check(i,j,i+1,p)){
					add(p+i*k,j+(i-1)*k);
					in[p+i*k]=1;
				}
		}
	}
//	for(int i=0;i<=n*k;i++){
//		for(int j:edge[i])
//			cout<<i<<" "<<j<<'\n';
//	}
	int ans=0;
	for(int i=k*n;i>k*(n-1);i--)ans+=dfs(i),ans%=MOD;
	cout<<ans;
	return 0;
}
```
$Hash[i][j][0]$ 存的是后几位的哈希值，$Hash[i][j][1]$ 存的是前几位的，$Hash[i][j][2]$ 存的是整个串的哈希值，这样就可以优化掉一个 $k$ 了。这也是我的考场代码，自信以为可以 $200$ 分的，但是被背刺了。


#### 正解（能过）
仔细思考，这个代码为什么 MLE，原因可能有三：一， vector 动态数组自动二倍空间直接炸了；二，想要省力全开 long long 炸了；三，记忆化爆栈。于是开始找问题，第一步先优化掉 vector 用链式前向星存图，没有效果，然后开始精挑细选换类型，依旧错了，所以只能是记忆化爆栈。


找到问题了，考虑优化。我们发现在建新层的时候不会对原先的图有更改，于是可以选择边建图边计算，这样不仅可以节约存图的空间，还不用调用大量递归以至于爆栈，代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
using namespace std;
const int N=51*1510,mod=1e9+9,MOD=1e9+7,base=131;
string s;
int n,k;
ull Hash[52][1510][3];
vector<int> edge;
int HASH(string a){
	ull pr=base,res=0;
	int l=a.size();
	for(int i=0;i<l;i++){
		res=res+pr*(ull)(a[i]-'a'+1)%mod;
		res%=mod;
		pr*=base;
		pr%=mod;
	}
	return res;
}
bool check(int x,int y,int xx,int yy){
	if(Hash[x][y][2]==Hash[xx][yy][0]||Hash[x][y][2]==Hash[xx][yy][1])
		return true;
	return false;
}
int f[N];
int in[N];
signed main(){
//	freopen("trener.in","r",stdin);
//	freopen("trener.out","w",stdout);
	cin>>n>>k;
	for(int i=1;i<=k;i++)f[i]=1,in[i]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=k;j++){
			cin>>s;
			Hash[i][j][2]=HASH(s);
			if(i==1){
				Hash[i][j][0]=base*(ull)(s[0]-'a'+1);
				Hash[i][j][1]=base*(ull)(s[0]-'a'+1);
				continue;
			}
			char c=s.front();
			s.erase(s.begin());
			Hash[i][j][0]=HASH(s);
			s.insert(s.begin(),c);
			s.pop_back();
			Hash[i][j][1]=HASH(s);
		}
	for(int i=1;i<n;i++){
		for(int j=1;j<=k;j++){
			if(!in[j+(i-1)*k])continue;
			for(int p=1;p<=k;p++)
				if(check(i,j,i+1,p)){
					edge.push_back(p+i*k);
					in[p+i*k]=1;
				}
			for(int v:edge)
				f[v]+=f[j+(i-1)*k]%MOD;
			edge.clear();
		}//现在这里的edge存的就是这个点能走到下一层的哪个位置
	}
	int ans=0;
	for(int i=k*n;i>k*(n-1);i--)ans+=f[i],ans%=MOD;
	cout<<ans;
	return 0;
}
```
完结撒花！

---

## 作者：tangml (赞：3)

一道水题（我真是太弱了啊啊啊啊。

众所周知，看到这个题立刻知道他是要选名字长度为 $1$ 到 $N$ 的，而我们知道他每一个名字，所以可以直接用字符哈希去做，因为他每一个名字的字符数是上一层名字的字符数加一，所以对于哈希每个字符串只需要跑三次，分别是自己的这个序列的哈希，以及去头，去尾的两个哈希值，目的是为了与上一个字符比较。

然后我想的是用加法原理一层层去跑出答案（其实和图论的思想差不多）。

易看出时间复杂度为三次方级别的，在两秒的时限下可以过掉此题。

然后模拟赛时我全部 MLE 到飞起。

### $50$ 昏
```
#include<bits/stdc++.h>
#define int long long

#define pb push_back

#define P 1145141

#define ULL unsigned long long


using namespace std;

const int N=51,K=2000,mod=1e9+7;

int n,k;
vector<int> G[N][K];
int sum;
int ans[N][K];

ULL dt[N][K][3];
ULL Hash(char s[],int i,int len)
{
	ULL res=0;
	for(;i<len;i++)
		res=res*P+s[i]-'a'+1;
	return res;
}

signed main()
{
	freopen("trener.in","r",stdin);
	freopen("trener.out","w",stdout);
	
	char a[K];
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>a;
		dt[1][i][2]=Hash(a,0,strlen(a));
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			cin>>a;
			dt[i][j][0]=Hash(a,0,strlen(a)-1);
			dt[i][j][1]=Hash(a,1,strlen(a));
			dt[i][j][2]=Hash(a,0,strlen(a));
			for(int t=1;t<=k;t++)
			{
				if(dt[i-1][t][2]==dt[i][j][0] || dt[i-1][t][2]==dt[i][j][1])
					G[i][j].pb(t);
			}
		}
	}
	
	for(int i=1;i<=k;i++)	ans[1][i]=1;
	for(int i=2;i<=n;i++)
		for(int j=1;j<=k;j++)
			for(auto t:G[i][j])	
				ans[i][j]+=ans[i-1][t],ans[i][j]%=mod;
				
	for(int i=1;i<=k;i++)	sum+=ans[n][i],sum%=mod;
	
	cout<<sum<<endl;
	return 0;
}
```

赛后 $5$ 分钟,我发现了我存图的动态数组的空间复杂度也是三次方级别的，直接炸掉。

然后我才看见我原来是可以把这个问题做成一个几乎在线的做法，就是把我向上递推的过程与输入合并在一起，这样就可以使我的数组减少一维。

### CODE
```
#include<bits/stdc++.h>
#define int long long

#define pb push_back

#define P 1145141

#define ULL unsigned long long


using namespace std;

const int N=51,K=1600,mod=1e9+7;

int n,k;
int sum;
int ans[N][K];
vector<int> G[K];
ULL dt[N][K][3];
ULL Hash(char s[],int i,int len)
{
	ULL res=0;
	for(;i<len;i++)
		res=res*P+s[i]-'a'+1;
	return res;
}

signed main()
{
	freopen("trener.in","r",stdin);
	freopen("trener.out","w",stdout);
//	
	char a[K];
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>a;
		dt[1][i][2]=Hash(a,0,strlen(a));
	}
	
	for(int i=1;i<=k;i++)	ans[1][i]=1;
	
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			cin>>a;
			dt[i][j][0]=Hash(a,0,strlen(a)-1);
			dt[i][j][1]=Hash(a,1,strlen(a));
			dt[i][j][2]=Hash(a,0,strlen(a));
			for(int t=1;t<=k;t++)
				if(dt[i-1][t][2]==dt[i][j][0] || dt[i-1][t][2]==dt[i][j][1])
					G[j].pb(t);
		}
		for(int j=1;j<=k;j++)
			for(auto t:G[j])	
				ans[i][j]+=ans[i-1][t],ans[i][j]%=mod;
		for(int j=1;j<=k;j++) G[j].clear();
	}
				
	for(int i=1;i<=k;i++)	sum+=ans[n][i],sum%=mod;
	
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：Nefelibat_a (赞：3)

# 前言

话说 $COCI$ 的题解是真的少。笔者把 $hash$ 分装成了函数，个人觉得会更加美观，方便。同时当中还有一些笔者之前犯过的错误，应该会有些参考意义（望过审orz）

考试的时候打这道题，居然忘了 $hash$ 在 c++11开`algorithm`的时候是关键字
，直接CE，原地裂开

# 思路

看到这道题，其实第一反应就是DP。（因为它没有后效性）~~骗分也可以DFS~~

设 $dp[i][j]$ 表示在取名字长度为 $i$ 的人的选取中，选了第 $j$ 个人的方案数。

$dp[i][j] = \sum_{1-k} dp[i - 1][z]$ 当且仅当姓$j$为$z$的连续子序列时


# 优化
如果用暴力，来确定两个人的名字是否相同，再加上dp那么时间复杂度应该是$\Theta(n^2 \times k^2)$ 回

所以我们需要用字符串hash来进行时间复杂度的优化

为了减少$hash$冲突，将字符串转化为13331(质数)进制数。


# 代码

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
const int maxn = 55;
const int Ha = 13331;
int n, k;
int dp[maxn][1505];
long long ha1[maxn][1505], ha2[maxn][1505], ha3[maxn][1505]; 

long long ksm(int x, int y){
	int ans = 1, sum = x;
	while(y){
		if(y & 1)ans *= sum;
		ans %= mod;
		sum *= sum;
		sum %= mod;
		y >>= 1;
	}
	return ans;
}
int HHash(char a[maxn], int head, int end){
	long long tot = 0;
	for(int i = head; i <= end; i ++){
		tot += (a[i] - 'a' + 1) * ksm(Ha, i + (head == 2 ? -1 : 0));  //当没有头的时候，不减1会对hash结果产生影响
		tot %= mod;
	}
	return tot;
}

int no_head(char a[maxn], int len){
	return HHash(a, 2, len);
}

int no_end(char a[maxn], int len){
	return HHash(a, 1, len - 1);
}

int all_have(char a[maxn], int len){
	return HHash(a, 1, len);
}
signed main() {
//	freopen("trener.in","r",stdin);
//	freopen("trener.out","w",stdout);
	scanf("%d %d", &n, &k);
	char a[maxn];
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= k; j ++){
			scanf("%s", a + 1);
			ha1[i][j] = all_have(a, i);
			ha2[i][j] = no_head(a, i);
			ha3[i][j] = no_end(a, i);
		}
	}
	for(int i = 1; i <= k; i ++){
		dp[1][i] = 1;
	}
	long long ans = 0;
	for(int i = 2; i <= n; i ++){
		for(int j = 1; j <= k; j ++){
			for(int z = 1; z <= k; z ++){
				if(ha2[i][j] == ha1[i - 1][z] || ha3[i][j] == ha1[i - 1][z] && !(ha2[i][j] == ha1[i - 1][z] && ha3[i][j] == ha1[i - 1][z])){
					
					dp[i][j] += dp[i - 1][z];
					dp[i][j] %= mod;
				}
			}
			if(i == n){
				ans += dp[i][j];
				ans %= mod;
			}
		}
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：iyaang (赞：2)

[没人看的阅读体验](https://www.cnblogs.com/LittleTwoawa/p/17254190.html)

[题目链接](https://www.luogu.com.cn/problem/P6221)

本人于三月二十四日模拟赛本题中使用 $\mathcal O(n^2 k + n k^2)$ 哈希+DP，因神秘常数原因竟打不过 $\mathcal O(n^2 k^2)$，甚至被卡的 TLE 飞起，怒挂五十分。赛后交了一页的 TLE，最后换成自然溢出才能过，~~铭记贰点贰叁~~。

不会吧不会吧不会还有人这个题写 $\mathcal O(n^2 k + n k^2)$ 吧。![/kel](https://cdn.luogu.com.cn/upload/pic/62226.png)

平凡的做法其他题解说的很清楚了，注意到我们 $O(k^2)$ 的判断前后缀是否相等其实没有必要，这里可以将哈希值从小到大排序并记下编号，使用双指针优化只扫一遍，将前后缀相同的记录在一起，然后再去重累加上答案，时间复杂度 $\mathcal O(n^2 k + n(k + n \log k))$，瓶颈在于排序。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define mp make_pair
#define pb push_back
using namespace std;

bool Mbe;

namespace LgxTpre
{
	static const int MAX=1510;
	static const int INF=4557430888798830399;
	static const int mod=1e9+7;
	static const int bas=151;
	
	inline void Madd(int &a,int b) {a=a+b>=mod?a+b-mod:a+b;}
	inline void Mdel(int &a,int b) {a=a-b<0?a-b+mod:a-b;}
	inline int  Cadd(int a,int b)  {return a+b>=mod?a+b-mod:a+b;}
	
	int n,k,ans,len;
	string s;
	ull suf[MAX][MAX],pre[MAX][MAX],all[MAX][MAX],tmp1[MAX],tmp2[MAX];
	int dp[MAX][MAX],vis[MAX],id[MAX],idd[MAX],cas[MAX],num;
	vector<int> buc[MAX];
		
	inline void lmy_forever()
	{
		cin>>n>>k;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=k;++j)
			{
				cin>>s; len=s.size();
				for(int h=0;h<len;++h) 
				{
					all[i][j]=all[i][j]*bas+s[h];
					if(h!=0) pre[i][j]=pre[i][j]*bas+s[h];
					if(h!=len-1) suf[i][j]=suf[i][j]*bas+s[h];
				}
			}
		for(int i=1;i<=k;++i) dp[1][i]=1;
		for(int i=1;i<n;++i)
		{
			for(int j=1;j<=k;++j) buc[j].clear(),id[j]=idd[j]=j;
			sort(idd+1,idd+k+1,[i](int a,int b){return all[i][a]<all[i][b];});
			for(int j=1;j<=k;++j) tmp1[j]=all[i][idd[j]];
			sort(id+1,id+k+1,[i](int a,int b){return pre[i+1][a]<pre[i+1][b];});
			for(int j=1;j<=k;++j) tmp2[j]=pre[i+1][id[j]];
			for(int j=1,iter=1;j<=k;++j)
			{
				while(iter<=k&&tmp2[iter]<tmp1[j]) ++iter;
				for(int con=iter;con<=k&&tmp2[con]==tmp1[j];++con) buc[idd[j]].pb(id[con]); 
			}
			sort(id+1,id+k+1,[i](int a,int b){return suf[i+1][a]<suf[i+1][b];});
			for(int j=1;j<=k;++j) tmp2[j]=suf[i+1][id[j]];
			for(int j=1,iter=1;j<=k;++j)
			{
				while(iter<=k&&tmp2[iter]<tmp1[j]) ++iter;
				for(int con=iter;con<=k&&tmp2[con]==tmp1[j];++con) buc[idd[j]].pb(id[con]); 
			}
			for(int j=1;j<=k;++j)
			{
				num=0;
				for(auto it:buc[j]) if(!vis[it]) vis[it]=1,cas[++num]=it;
				buc[j].clear();
				for(int p=1;p<=num;++p) vis[cas[p]]=0,buc[j].pb(cas[p]);
			}
			for(int j=1;j<=k;++j)
				if(dp[i][j])
					for(auto it:buc[j])
						Madd(dp[i+1][it],dp[i][j]);	
		}
		for(int i=1;i<=k;++i) Madd(ans,dp[n][i]);
		cout<<ans<<endl;
		return;
	}
}

bool Med;

signed main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	fprintf(stderr,"%.3lf MB\n",(&Med-&Mbe)/1048576.0);
	LgxTpre::lmy_forever();
	cerr<<1e3*clock()/CLOCKS_PER_SEC<<" ms\n";
	return (0-0);
}
```

事实上我们也可以不使用哈希。对于这种多个字符串记录相同前后缀数量的问题，我们更容易想到使用 $\text{Trie}$ 树操作。我们记以当前节点的答案数量为 $cnt_i$，依次将每个字符串插入 $\text{Trie}$ 树，然后直接在 $\text{Trie}$ 树中查找其前后缀的位置并累加 $cnt$ 的值。这里注意当查找前后缀所在的节点最后相同时，说明出现了重复，我们只累加一遍。由于在 $\text{Trie}$ 树上多个串共用一个节点位置，所以我们最后统计的答案实则为累加一个串前后缀 $cnt$ 操作的增量。时间复杂度 $\mathcal O(n^2 k)$，瓶颈在于读入。![/jk](https://cdn.luogu.com.cn/upload/pic/62234.png)

```cpp
#include<bits/stdc++.h>
#define int long long
#define mp make_pair
#define pb push_back
using namespace std;

bool Mbe;

namespace LgxTpre
{
	static const int MAX=1510*1510;
	static const int INF=4557430888798830399;
	static const int mod=1e9+7;
	
	inline void Madd(int &a,int b) {a=a+b>=mod?a+b-mod:a+b;}
	inline void Mdel(int &a,int b) {a=a-b<0?a-b+mod:a-b;}
	inline int  Cadd(int a,int b)  {return a+b>=mod?a+b-mod:a+b;}
	
	int n,k,ans;
	int now,pre,suf;
	
	string s;
	int ch[MAX][30],cnt[MAX],tot=1;
	inline int insert()
	{
		int len=s.size(),now=1;
		for(int i=0;i<len;++i)
		{
			int to=s[i]-'a';
			if(!ch[now][to]) ch[now][to]=++tot;
			now=ch[now][to];
		}
		return now;
	}
	inline int find(int cas)
	{
		int len=s.size(),now=1;
		for(int i=cas;i<len-(1-cas);++i)
		{
			int to=s[i]-'a';
			if(!ch[now][to]) return 0;
			now=ch[now][to];
		}
		return now;
	}
		
	inline void lmy_forever()
	{
		cin>>n>>k; cnt[1]=1;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=k;++j)
			{
				cin>>s;
				now=insert();
				pre=find(0);
				suf=find(1);
				if(i==n) Mdel(ans,cnt[now]);
				if(pre==suf) Madd(cnt[now],cnt[pre]);
				else Madd(cnt[now],Cadd(cnt[pre],cnt[suf]));
				if(i==n) Madd(ans,cnt[now]);
			}
		cout<<ans<<endl;
		return;
	}
}

bool Med;

signed main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	fprintf(stderr,"%.3lf MB\n",(&Med-&Mbe)/1048576.0);
	LgxTpre::lmy_forever();
	cerr<<1e3*clock()/CLOCKS_PER_SEC<<" ms\n";
	return (0-0);
}
```

最后放一张评测图片，高下立判：

![7_OPBX__X_`R_H_RJX@W2_E.png](https://s2.loli.net/2023/03/25/VmvgFyQRhaoWfcY.png)

---

## 作者：ClearluvXL (赞：1)

# Trener

## 思路

本题要求所有球员长度各不相同，并且还保证每一行球员的长度是相同的。那么我们可以知悉，一个组合其实就是在每一行的球员里面选出一个人。

考虑 DP，令 $f_{i,j}$ 选到为第 $i$ 行第 $j$ 个人的方案数，考虑从上一行开始转移。

那么令从上一行的第 $lst$ 列转移，首先这个 $(i-1,lst)$ 对应的的名字应该为字符串 $(i,j)$ 的前后缀，如果我们从上一行一个一个找，并且一个字符一个字符比较的话，时间复杂度大约为 $O(n^{2}\times k^{2})$。

现在我们考虑先从比较字符优化，可以使用哈希。预处理处每一个人名的哈希值，大约为 $O(n^{2}k)$ 的时间复杂度。

那么这样，我们就可以节省一位维 $n$ 的时间。

事实上，我们还可以优化掉一维 $k$，使得我们的 DP 转移的时间复杂度变为 $O(nk)$。那么我们怎么做呢？

我们现在已经能在 $O(1)$ 的时间得出该字符串的前后缀了。那么，如果此时我们已经将上一行是他前缀和后缀的人的答案都统计在一起了，那么我们就能 $O(1)$ 转移了。

所以此时，引入一个 $g$ 数组，$g_{i,j}$ 表示第 $i$，所有第 $j$ 种字符串的方案总和。

此时的 $f$ 数组的转移变为：$f_{i,j}=f_{i,j}+g_{i-1,z}$。$z$ 为 $j$ 字符串的前后缀。

## 代码

```c++
#include<bits/stdc++.h>
#define endl '\n' 

using namespace std;

const int N=55;
const int INF=0x3f3f3f3f;
const int mod=1e9+7;
const int p=131;

typedef long long ll;
typedef pair<int,int> pii;
typedef unsigned long long ull;

int n,k;
char a[N][1510][N];
ull hs[N][1510][N];

map<ull,int> has[N];
vector<int> v[N][1510];

ull pp[N];
int sum[N]; 

void pre(){
	pp[0]=1;
	for(int i=1;i<=n;i++) pp[i]=pp[i-1]*p;
	for(int i=1;i<=n;i++){
		int cnt=0;
		for(int j=1;j<=k;j++){
			for(int x=1;x<=i;x++){
				hs[i][j][x]=hs[i][j][x-1]*p+(a[i][j][x]-'a'+1);
			}
			ull hsh=hs[i][j][i];
			if(!has[i][hsh]) has[i][hsh]=++cnt;
			v[i][has[i][hsh]].push_back(j);
		}
		sum[i]=cnt;
	}
}//end

ull get(int i,int j,int l,int r){
	int len=r-l+1;
	return hs[i][j][r]-hs[i][j][l-1]*pp[len];
}//end

ll f[N][1510];
ll g[N][1510];

int main(){
	freopen("trener.in","r",stdin);
	freopen("trener.out","w",stdout);
	
	ios::sync_with_stdio(0);
	
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			cin>>a[i][j]+1;
		}
	}	
	
	pre();
	
	for(int i=1;i<=k;i++) f[1][i]=1;
		
	for(int j=1;j<=sum[1];j++){
		for(int y:v[1][j]){
			g[1][j]+=f[1][y];
			g[1][j]%=mod;
		}
	}
	
	for(int i=2;i<=n;i++){
		for(int j=1;j<=k;j++){
			ull h[2];
			h[0]=get(i,j,1,i-1);
			h[1]=get(i,j,2,i);
			int fl=0;
			if(h[0]==h[1]) fl=1;
			for(int x=0;x<2-fl;x++){
				int id=has[i-1][h[x]];
				if(!id)	continue;
				f[i][j]+=g[i-1][id];
				f[i][j]%=mod;
			}
		}
		for(int j=1;j<=sum[i];j++){
			for(int y:v[i][j]){
				g[i][j]+=f[i][y];
				g[i][j]%=mod;
			}
		}
	}
	
	ll ans=0;
	for(int i=1;i<=k;i++) ans=(ans+f[n][i])%mod;
	
	cout<<ans<<endl;
	
	return 0;
}//end
```

---

## 作者：Chen_Henry (赞：1)

看到这个我就直接想到了 DP。

$DP_{i,j}$ 表示只考虑前 $i$ 组，且第 $i$ 组选第 $j$个 的方案数。

那么状态怎么转移呢？

很明显，如果第 $i$ 层第 $j$ 个字符串包含第 $i-1$ 层第 $x$ 个字符串，那么就让

$$DP_{i,j}\gets DP_{i,j}+DP_{i-1,x}$$

当然，对于所有 $i=1,j\in[1,k]$ 的， $DP_{i,j}$ 值为 $1$。

最后答案是

$$\sum _ {i = 1} ^ n DP_{n,i}$$

**注意答案可能很大，记得对 $10^9+7$ 取模，因为全部是加法，所以可以在过程中取模，具体定理：$(a+b)\bmod p=(a\bmod p+b\bmod p)\bmod p$。**

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[55][1505];
string a[55][1505];
const int MOD=1e9+7;
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			cin>>a[i][j];
			string s=a[i][j];
			if(i==1) dp[i][j]=1; //如果是第一层，就直接把值赋为1
			else for(int l=1;l<=k;l++) if(s.find(a[i-1][l])!=s.npos) dp[i][j]=(dp[i][j]+dp[i-1][l])%MOD;//否则循环寻找上一层符合要求的，并把dp值加起来，注意为了防止超int，这里选择在加的过程中取模
		}
	}
	int sum=0;
	for(int i=1;i<=k;i++) sum=(sum+dp[n][i])%MOD;//寻找答案，注意取模
	cout<<sum<<endl;
	return 0;
}
```
时间复杂度非常明显的 $O(nk^2)$，能过。

---

## 作者：_Vix_ (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P6221)

## 前言
考场上忘记了 Hash 是怎么个搞法，临时胡了一个乱搞的，其实也[不差](https://www.luogu.com.cn/record/90507810)。

## 题意
有 $N$ 组队伍，每一组都有 $K$ 个人。其中第 $i$ 组队伍每个人的名字长度都为 $i$。现在求选一支 $N$ 个人的队伍的方案数，满足：

1. 每个人名字长度互不相等。
2. 所有人的名字都必须是名字长度比他长一个的人的名字的子串。

范围：$1 \le N \le 50$，$1 \le K \le 1500$。

## 分析
易知这选出来的 $N$ 个人名字长度分别为 $1 \dots N$。

## Subtask1
直接爆搜出每一支队伍的所有人，按照名字长度由小到大的顺序搜索，在搜索时判断下一个人是否能加入队伍，期望得分 $20pts$。

## Subtask2
考虑 DP。设 $dp[i][j]$ 表示队伍中第 $i$ 个人选第 $i$ 组的第 $j$ 个人的方案数。则转移时考虑第 $i - 1$ 行的第 $k$ 个人的名字是不是第 $j$ 个人的名字的字串即可转移：
$$dp[i][j] = \sum dp[i - 1][k]$$
初始条件为：$dp[1][i] = 1$，其中 $i\in [1, K]$。
那么最后的答案即为：
$$\sum_{i = 1}^K dp[N][i]$$

直接 $O(N)$ 判断字串，时间复杂度 $O(N^2K^2)$，期望得分 $50pts$。

## Subtask3
依然是 DP，我们发现判断字串时可以使用 Hash 优化到 $O(1)$，时间复杂度 
$O(NK^2)$，期望得分 $100pts$。

## Code
考场上脑糊，Hash 都整不会了，写了两个 Hash，一个从前开始 $pre$，一个从后开始 $suc$，反正效果应该是不差？我这里 Hash 用的质数是 $131$，也可以用 $13331$ 等等，这里就不赘述了。由于本人码风较怪，这里就不贴[代码](https://www.luogu.com.cn/paste/8u4cgl00)了。

---

## 作者：STrAduts (赞：1)

很明显是一道 $dp$ 题。

可以图论去解决，也可以字符串 Hash。这里采用的是字符串 Hash。

大概分析一下。每一组一定要选一个才能凑齐一个队。

假设 $dp[i][j]$ 表示第 $i$ 组选第 $j$ 个人的总方案数。

那么就会发现，如果上一组第 $k$ 个人的姓氏是当前这个人的姓氏的连续子序列，则一定会有 $dp[i][j] = \sum{dp[i - 1][k]}$。

再思考如何 $O(1)$ 的去判断是否是当前姓氏的连续子序列。此时考虑 Hash。因

为是连续子序列，且上一个与当前长度的差一定为 1，那么分别将当前的去头或去尾判断是否和上一个相等即可。

但这道题很 ex。它 卡 常。所以只能将 Hash 写在判断内，而不是单独一个函数。当然顺便优化掉一个乘法。

Hash 表的构造采用自然溢出。

```cpp
#include <cstdio>

typedef unsigned long long ULL;
int read() {
    int k = 1, x = 0;
    char s = getchar();
    while (s < '0' || s > '9') {
        if (s == '-')
            k = -1;
        s = getchar();
    }
    while (s >= '0' && s <= '9') {
        x = (x << 3) + (x << 1) + s - '0';
        s = getchar();
    }
    return x * k;
}

void write(int x) {
    if(x < 0) {
    	putchar('-');
		x = -x;
    }
    if(x > 9)
		write(x / 10);
    putchar(x % 10 + '0');
}

void print(int x, char s) {
	write(x);
	putchar(s);
}

const int MAXN = 55;
const int MAXK = 1505;
const int mod = 1e9 + 7;
const int p = 13331;

int dp[MAXN][MAXK];
char s[MAXN][MAXK][MAXN];
ULL Hash[MAXN][MAXK][MAXN], w[MAXN];

/*
ULL Query(int i, int j, int l, int r) {
	return Hash[i][j][r] - Hash[i][j][l - 1] * w[r - l + 1];
}
*/

inline bool check(int x, int y, int z) {
	// (x, y) (x - 1, z)	
	return (Hash[x - 1][z][x - 1] == Hash[x][y][x - 1] || Hash[x - 1][z][x - 1] == Hash[x][y][x] - Hash[x][y][1] * w[x - 1]);
}

int main() {
	int n = read(), len = read();
	w[0] = 1;
	for(int i = 1; i <= n; i++)
		w[i] = w[i - 1] * p;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= len; j++) {
			scanf ("%s", s[i][j] + 1);
			for(int k = 1; k <= i; k++)
				Hash[i][j][k] = Hash[i][j][k - 1] * p + (s[i][j][k] - 'a' + 1);
		}
	for(int i = 1; i <= len; i++)
		dp[1][i] = 1;
	for(int i = 2; i <= n; i++) 
		for(int j = 1; j <= len; j++) 
			for(int k = 1; k <= len; k++)
				if(check(i, j, k))
					dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod;
	int ans = 0;
	for(int i = 1; i <= len; i++)
		ans = (ans + dp[n][i]) % mod;
	print(ans, '\n');
	return 0;
}

/*
3 3 
a b c 
aa ab ac 
aaa aab aca
*/
```

---

## 作者：HDWR (赞：0)

题目里有一个关键条件：前一个字符串必须是后一个字符串的子串。

这意味着，只要后一个字符串确定了，那么前一个字符串至多只有两种可能。

所以我们有一个初步的想法：**确定后面的即可缩小前面的范围**。于是有一个暴力的想法，就是枚举最后的选谁，然后往前搜索，逐层确定。

这个东西的复杂度我不会分析（想了一下，暴力是指数复杂度，记搜和下面的 DP 似乎是一个做法），考场上实现了一下也不大好写（因为我比较菜）。但是我们能从这个想法里感觉出来两个点：

1. 往前搜索的过程中每个点只能从长的字符串往短的字符串走，也就是不能形成环
2. 一个合法的方案就是把搜索过程中经过的点倒序输出

发现了什么？如果我们把搜索图画出来，那么**这就是一个反向的 DAG，求答案的过程实际上就是在求路径的条数！**

于是本题的做法就呼之欲出了：考虑两个长度差为 $1$ 的字符串 $a,b(|a| < |b|)$，如果 $a$ 是 $b$ 的子串，那么就在图中加一条 $a$ 的编号到 $b$ 的编号的点，最终形成一个 DAG，在 DAG 上跑 DP 求所有起点（长度为 $1$ 的串代表的点）到每个点的路径条数，把所有终点（长度为 $n$ 的串代表的点）的答案加起来即可。

复杂度分析？

我也不大会分析这个复杂度，但是有两点是知道的：

1. 总点数为 $NK$
2. 每个点至多会连进来两条入边，比如 `abcde` 这个字符串，两个可能的子串是 `abcd` 和 `bcde`，从这两个点连边到这个字符串

实现起来跑得飞快，截止到发表时最优解第二名。

```cpp
const int MAXN = 50 + 10;
const int MAXK = 1500 + 10;
const int MAXNODE = MAXN * MAXK;
const int HA = 1e9 + 7;

std::map<std::string, int> mp[MAXNODE], idx[MAXNODE];

int n, k;

struct E {int v, w;};
int cnt = 0;
std::vector<E> G[MAXNODE];
int ind[MAXNODE];

void addEdge(int u, int v, int w) {
    // DEBUG(u); DEBUG(v); DEBUG(w);
    G[u].push_back({v, w});
    ++ind[v];
}

lli dp[MAXNODE];

void DP() {
    std::queue<int> q;
    // for (int i = 1; i <= cnt; ++i) {
    //     if (!ind[i]) {
    //         dp[i] = 1; q.push(i);
    //     }
    // }
    for (auto ids : idx[1]) {
        dp[ids.second] = 1; q.push(ids.second);
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto e : G[u]) {
            int v = e.v; lli w = e.w;
            dp[v] += dp[u] * w % HA;
            dp[v] %= HA;
            --ind[v];
            if (!ind[v]) q.push(v);
        }
    }
}

int main() {
    std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n >> k;
    rep (i, 1, n) rep (j, 1, k) {
        std::string ss; cin >> ss;
        mp[i][ss]++;
        idx[i][ss] = 0;
    }
    rep (i, 1, n) {
        for (auto it = idx[i].begin(); it != idx[i].end(); it++) {
            it->second = ++cnt;
            // DEBUG(it->first); DEBUG(cnt);
        }
    }
    for (int len = 2; len <= n; ++len) {
        for (auto strp : mp[len]) {
            // DEBUG(strp.first);
            std::string sub = strp.first.substr(0, len - 1);
            if (mp[len - 1].count(sub)) {
                // DEBUG(sub);
                // DEBUG(mp[len - 1][sub]);
                addEdge(idx[len - 1][sub], idx[len][strp.first], mp[len - 1][sub]);
            }
            if (sub == strp.first.substr(1, len - 1)) continue;
            sub = strp.first.substr(1, len - 1);
            if (mp[len - 1].count(sub)) {
                // DEBUG(sub);
                // DEBUG(mp[len - 1][sub]);
                // G[idx[len - 1][sub]].push_back({idx[len][strp.first], mp[len - 1][sub]});
                addEdge(idx[len - 1][sub], idx[len][strp.first], mp[len - 1][sub]);
            }
        }
    }
    DP();
    lli ans = 0;
    for (auto strp: mp[n]) {
        ans += dp[idx[n][strp.first]] * 1ll * strp.second;
        ans %= HA;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：神秘番茄厂长 (赞：0)

##### 动态规划+哈希
用 $dp[i][j]$ 表示能合法到达第 $i$ 列第 $j$ 个字符串的方案数。
初始化将 $dp[1][1$ ~ $m]$全设置为$1$ $(m$即为题中的$k)$。

那如何转移呢？

只有当一个长度为 $len$ 的字符串与一个长度为 $(len+1)$ 的字符串中的 $1$~$len$ 子串或 $2$~$(len+1)$ 子串相同时,这个 $len$ 长度的字符串才能够转移到那个 $(len+1)$ 长度的字符串那里去。
(也就是掐头去尾)

运用哈希，本人是用 $hx[i][j]$ 表示第 $i$ 列第 $j$ 个字符串的哈希值，用  $hxl[i][j]$ 表示这个字符串删去最后一个字符的哈希值，用 $hxr[i][j]$ 表示这个字符串删去第一个字符的哈希值，这些都可以在输入的时候处理完。

接着我们就可以三重循环枚举 $i$ ， $j$ ， $k$ ，

若
$$hx[i][j]=hxl[i+1][k]$$
或
$$hx[i][j]=hxr[i+1][k]$$
则可以转移，也就是
$$ dp[i][k]+=dp[i][j]$$

## 代码
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N=55,K=15e2+10,mod=1e9+7;
const ll B=43;
char s[N];
int n,m,dp[N][K],ans;
ll hx[N][K],hxl[N][K],hxr[N][K];

int main()
{
//	freopen("trener.in","r",stdin);
//	freopen("trener.out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
	for(int j=1;j<=m;++j)
	{
		dp[1][j]=1;
		scanf("%s",&s);
		hx[i][j]=s[0]-'a'+1;
		hxr[i][j]=0;
		for(int k=1;k<i-1;++k)
		{
			hx[i][j]=(hx[i][j]*B+s[k]-'a'+1)%mod;
			hxr[i][j]=(hxr[i][j]*B+s[k]-'a'+1)%mod;
		}
		hxl[i][j]=hx[i][j];
		if(i>1)
		{
			hx[i][j]=(hx[i][j]*B+s[i-1]-'a'+1)%mod;
			hxr[i][j]=(hxr[i][j]*B+s[i-1]-'a'+1)%mod;
		}
	}
	for(int i=1;i<n;++i)
	for(int j=1;j<=m;++j)
	for(int k=1;k<=m;++k)
	if(hx[i][j]==hxl[i+1][k]||hx[i][j]==hxr[i+1][k])
	{
		dp[i+1][k]+=dp[i][j];
		if(dp[i+1][k]>=mod) dp[i+1][k]-=mod;
	}
	for(int j=1;j<=m;++j)
	{
		ans+=dp[n][j];
		if(ans>=mod) ans-=mod; 
	}
	printf("%d\n",ans);
	return 0;
}
```

---


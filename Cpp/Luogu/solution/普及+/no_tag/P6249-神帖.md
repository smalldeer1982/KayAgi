# 神帖

## 题目背景

zrl 的生日在 3.14。出生在神帖迭起的日子，他的快乐自然很多。这不，他又要收取来着神帖的馈赠了。

## 题目描述

神帖分布在讨论区的一些页面上，每个页面最多有一个神帖。假设他正在浏览的页面设为 $0$ 号页面。向左一页为 $-1$ 号页面，向右一页为 $1$ 号页面，以此类推。第 $i$ 个神帖在 $x_i$ 号页面上，并且有特定的封禁的时间 $t_i$ 和快乐值 $v_i$，超过了这个时间 $t_i$ 浏览就不能得到他的快乐值了。zrl 向左或向右翻一页需要 $1$ 单位时间，浏览神帖不需要时间。问：zrl 最多能得到多少快乐值。

注：在 $t_i$ 个单位时间浏览第 $i$ 个神贴仍能得到 $v_i$ 的快乐值。

**另注：每个神帖的快乐值最多只能得到一次。**

## 说明/提示

#### 样例解释：

样例 1：$0 \rightarrow -1 \rightarrow 0 \rightarrow 1 \rightarrow 2 \rightarrow 3$  
样例 2：$0 \rightarrow -1 \rightarrow 0 \rightarrow 1 \rightarrow 2 \rightarrow 3$  
样例 3：$0 \rightarrow -1 \rightarrow -2 \rightarrow -3 \rightarrow -4 \rightarrow -5$ 

---

#### 数据范围：

| 测试点 | 特殊性质 |
| :-----------: | :-----------: |
| $1-2$ | $x_i \ge 0$ |
| $3-4$ | $0 \le t_i \le 20$ |
| $5-6$ | $n \le 20$ |
| $7$ | $-10 \le x_i \le 10$ |
| $8-9$ | $t_i=$\|$x_i$\| |
| $10-13$ | 所有 $t_i$ 均相等 |
| $14-17$ | $n \le 60$ |
| $17-22$ | 无 |

对于 $100\%$ 的数据，$n \le 200$，$-500 \le x_i \le 500$，$0 \le v_i \le 10^9$，$0\le t_i \le 500$。

Hint：新增两组 Hack 数据，贪心/模拟已经过不去了。

## 样例 #1

### 输入

```
5
-5 1 5
-3 1 5
-1 1 5
1 1 5
3 2 5
```

### 输出

```
4```

## 样例 #2

### 输入

```
5
-5 2 5
-3 1 5
-1 1 5
1 0 5
3 4 5
```

### 输出

```
5```

## 样例 #3

### 输入

```
5
1 1 1
2 1 2
3 1 3
4 1 5
-5 5 5
```

### 输出

```
5```

# 题解

## 作者：kradcigam (赞：12)

Update 2021.8.4：修改了图1的错误，感谢[___balalida___](https://www.luogu.com.cn/user/237541)！

这道题目我一看到就想起了经典题——[关路灯](https://www.luogu.com.cn/problem/P1220)

但是时间好像不太好搞啊！

我们可以枚举时间qwq

考虑 $4$ 维 $dp$ $f_{i,j,t,0/1}$ 表示 $zrl$ 看了第 $i$ 页到第 $j$ 页，此时时间为 $t$。

最后一维

- 如果是 $0$ 就是在第 $i$ 页。

- 如果是 $1$ 就是在第 $j$ 页。

为什么这样是对的？

我们会发现，首先为了最优 $zrl$ 绝对不会刻意地去浪费时间，像这样

![360截图18430707839661.jpg](https://i.loli.net/2020/03/29/7CFxNZ5Td934PfQ.jpg)

**要往左走，一定会超过之前走到最左的点**

**要往右走，一定会超过之前走到最右的点**

所以，我们可以开始转移了。

- 按照上面的结论 $f_{i,j,t,1}$ 有 $2$ 种可能

	- 一种是 $f_{i+1,j,t-(a_{i+1}-a_i),0}$

	![8y6AYmiXVOZE3eC.png](https://i.loli.net/2021/08/04/6HMh2qGBZ5cDPk8.png)

	- 一种是 $f_{i+1,j,t-(a_j-a_i),1}$

	![360截图178606015699100.jpg](https://i.loli.net/2020/03/29/3pXduqao6vD8kcW.jpg)

- 按照上面的结论 $f_{i,j,t,0}$ 有 $2$ 种可能

	- 一种是 $f_{i,j-1,t-(a_j-a_{j-1}),1}$

	![360截图17860531464236.jpg](https://i.loli.net/2020/03/29/D2pEfsChBbWP65N.jpg)

	- 一种是 $f_{i,j-1,t-(a_j-a_i),0}$

	![360截图17411024463469.jpg](https://i.loli.net/2020/03/29/8y6AYmiXVOZE3eC.jpg)

代码就很好写了：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct node{
	int x,v,t;
}a[210];
ll f[210][210][510][2],n,ans;//不开long long见祖宗！
bool cmp(node a,node b){
	return a.x<b.x;
}
int work(int x,int y){//算能否get到快乐值
	if(a[y].t>=x)return a[y].v;
	return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].v>>a[i].t;
	n++;//这里的话，我来解释一下，首先有可能所有帖子的页面都>0或<0，zrl也可能只向左走或只向又走。
	sort(a+1,a+n+1,cmp);
	for(int len=1;len<=n;len++)
		for(int i=1;i+len<=n;i++){
			int j=i+len;
			if(a[i].x>0||a[j].x<0)continue;
			int x=min(abs(a[i].x),abs(a[j].x))+a[j].x-a[i].x;
			for(int t=x;t<=500;t++){
				f[i][j][t][0]=max(f[i+1][j][max(t-(a[i+1].x-a[i].x),0)][0],f[i+1][j][max(t-(a[j].x-a[i].x),0)][1] )+work(t,i);//优美的转态转移方程。
				f[i][j][t][1]=max(f[i][j-1][max(t-(a[j].x-a[i].x),0)][0],f[i][j-1][max(t-(a[j].x-a[j-1].x),0)][1] )+work(t,j);
				ans=max(ans,max(f[i][j][t][0],f[i][j][t][1]));//优美的转态转移方程。
			}
		}
	cout<<ans;//输出
	return 0;
}
```

---

## 作者：__Watcher (赞：10)

这题是一道基础 dp 题，部分分给的很足，并且很有趣。

$1-2$：神贴都在当前页右边，因此一直往右翻页即为最优。

$3-4$：暴力搜索每一步向左翻页还是向右翻页即可。

$5-6$：每一次看完一个神贴，搜索看左边的神贴还是右边的神贴。

$7$：容易看出，第七个数据点也有 $n \le 20$。方法多样。

$8-9$：只有一直向左走和一直向右走两种方法。试想：为什么？

$10-13$：贪心。必是向左一段后一直向右或向右一段后一直向左。证明略。

$14-17$：允许复杂度大一些。转移允许 $O(\operatorname{N})$。

满分：

先把神贴按位置排序。

考虑 dp。本题有三个要素：位置、时间、价值。对于任意的时间，我们翻过的页总是连续的一段。因此位置这个要素可以用两维表示左端点和右端点。时间这个要素，再开一维记录。价值即为映射出来的值。因此，状态设计如下：  

$f_{i,j,k}$ 表示当前走过第 $i$ 到 $j$ 号神贴，花了 $k$ 个单位时间，所能得到的最大价值。

状态转移：

由数据 $3-4$ 的启发，每一步只能往左走直到遇到未经过神贴，或者往右走遇到未经过的神贴。但是 $f(i,j,k)$ 并未表示出当前位置，因此再加一维变成 $f_{i,j,p,k}$，$p=0$ 表示目前在第 $i$ 号神贴，$p=1$ 表示目前在第 $j$ 号神贴，则转移如下：

$f_{i,j,1,k}=\max(f_{i,j-1,1,k-(x_j-x_{j-1})},f_{i,j-1,0,k-(x_j-x_i)})+(k\le t_k)v_k$

$(k\le t_k)$ 表示若 $k\le t_k$ 则为 $1$，否则为 $0$。

$f_{i,j,0,k}$ 的转移与上面类似，请读者思考。~~（想不出来可以看代码）~~

边界：

边界问题比较麻烦。考虑在 0 号节点创建一个快乐值为 0 的神贴，设这是从左到右第 $root$ 个神贴，那么就有初始状态 $f_{root,root,0,0}=f_{root,root,1,0}=0$

code：

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n;
ll f[205][205][2][505], ans;
struct AB{
	int x, v, t;
	bool operator < (const AB &A) const{
		return x < A.x;
	}
}a[205]; 
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d%d%d", &a[i].x, &a[i].v, &a[i].t);//a[i].x=read(), a[i].t=read(), a[i].v=read(); 
	a[n+1].x=0, a[n+1].v=0, a[n+1].t=0;
	sort(a+1, a+n+2);
	int root;
	for(int i=1;i<=n+1;i++) {
		if(a[i].x==0) {
			root=i;
			break;
		}
	}
	for(int i=root;i>=1;i--) {
		for(int j=root;j<=n+1;j++) {
			if(i==j) {
				continue;
			}
			for(int k=a[j].x-a[j-1].x;k<=500;k++) {
				f[i][j][1][k]=f[i][j-1][1][k-(a[j].x-a[j-1].x)];
			}
			for(int k=a[j].x-a[i].x;k<=500;k++) {
				f[i][j][1][k]=max(f[i][j][1][k], f[i][j-1][0][k-(a[j].x-a[i].x)]);
				if(k<=a[j].t) f[i][j][1][k]+=a[j].v; 
				ans=max(ans, f[i][j][1][k]);
			}
			for(int k=a[i+1].x-a[i].x;k<=500;k++) {
				f[i][j][0][k]=f[i+1][j][0][k-(a[i+1].x-a[i].x)];
			}
			for(int k=a[j].x-a[i].x;k<=500;k++) {
				f[i][j][0][k]=max(f[i][j][0][k], f[i+1][j][1][k-(a[j].x-a[i].x)]);
				if(k<=a[i].t) f[i][j][0][k]+=a[i].v; 
				ans=max(ans, f[i][j][0][k]);
			}
		}
	}
	cout<<ans;
}

```


---

## 作者：Konnyaku_LXZ (赞：3)

## 前言：~~（以下都是废话）~~
比赛前我本来打算去做关路灯的，可是来不及做，结果比赛就考了一道和关路灯及其类似的题。~~（当场自闭了）~~

于是，比赛之后我去做了一下P1220关路灯，再回头来看这题，其实没什么区别，大体思路都是一样的。

## 正解：
我们考虑一个dp。具体分为以下几个步骤进行。
### 一：如何判断这题的dp类型：

这题是dp应该是显然的。题目叫我们求最大值而且不用输出方案，数据范围模拟也过不去，所以我们很自然的联想到了dp。由于神帖的线性分布，这题**不是一般线性dp就是区间dp**。

我们有一个起点，还有一堆数不清的神帖。这些神帖不是在起点的左边，就是在起点的右边，而我们每次看完一个神帖，要么继续沿着之前的方向看下一个神帖，要么调头看另一边的神帖。而调头这一动作，一般线性dp是无法做到的，所以这只能是一个**区间dp**。

### 二：如何设计状态定义：

既然是区间dp，那么我们常用的套路就是：设 $f[i][j]$ 表示看区间 $i$ 到 $j$ 的神帖所取得的最大快乐值。而题目还有要求每个神帖要在一定的时间内看完，所以我们再加一维， $f[i][j][k]$ 表示看区间 $i$ 到 $j$ 的神帖用了 $k$ 的时间。而我们又发现以最优方案看完任意一个区间的神帖，**当前的位置不是在区间的左端点就是在区间的右端点**，而这对状态的转移是有影响的，所以我们考虑记录下端点。于是，我们最终的状态定义为: **$f[i][j][k][0/1]$ 表示看区间 $i$ 到 $j$ 的神帖，用了 $k$ 的时间，看完后所在的位置为区间的左/右端点**。为了方便大家理解，我们用 $L$ 表示在左端点， $R$ 表示在右端点。

### 三：如何设计初始值以及如何找出状态转移方程：

**初始值**：初始值的事情比较好办。结合我们做关路灯的经验，我们希望起点 $start$ 的位置上也能有一个神帖，这样初始值就为  $f[start][start][0][L]=f[start][start][0][R]=0$ ，然而起点位置上并没有神帖，所以我们要**在起始位置上加一个神帖**，加神帖的具体操作见代码。

**状态转移方程**：不难得出， $f[i][j][k][L]$ 的值与 $f[i+1][j][k-move1][L]$ 和 $f[i+1][j][k-move2][R]$ 的值有关系，其中 $move1,move2$ 表示从当前位置移动到第 $i$ 个神帖的位置所需要的时间。如果第 $i$ 个神帖能在规定时间内被看到，则我们再加上它的快乐值。 $f[i][j][k][R]$ 也与 $f[i][j][k][L]$ 同理。

于是，我们得出最后的状态转移方程为：

### $f[i][j][k][L]=max(f[i+1][j][k-move1][L],f[i+1][j][k-move2][R])+(k<=a[i].t?a[i].v:0)$

### $f[i][j][k][R]=max(f[i][j-1][k-move1][L],f[i][j-1][k-move2][R])+(k<=a[j].t?a[j].v:0)$

Code：~~（代码有点丑别在意哈）~~

	#include<iostream>
	#include<cstdio>
	#include<cmath>
	#include<algorithm>
	#include<cstring>
	#define rg register
	using namespace std;
	const int MAXN=205;
	typedef long long LL;
	struct node{ 
		int loc;
		int x;
		int t;
	};
	int N,L=0,R=1;//L表示左端点，R表示右端点 
	LL f[MAXN][MAXN][505][2],ans=0;//记得开long long，ans记录最大值 
	node a[MAXN];
	inline bool cmp(node x,node y){return x.loc<y.loc;}//比较函数 
	inline int find(){for(int i=1;i<=N;i++) if(a[i].loc==0) return i;}//找起点的函数 
	int main()
	{
		scanf("%d",&N);
		for(int i=1;i<=N;i++) scanf("%d%d%d",&a[i].loc,&a[i].x,&a[i].t);
		N++;a[N]=node{0,0,0};//加神帖 
		sort(a+1,a+1+N,cmp);//先将神帖按位置排序 
		int start=find();//找到起点位置 
		memset(f,0,sizeof(f));//等价于f[start][start][0][L]=f[start][start][0][R]=0 
		for(rg int i=start;i>=1;i--)//i从起点往左找 
			for(rg int j=start;j<=N;j++){//j从起点往右找 
				if(i!=j){//这里需要特判一下，因为当i=j=start时,当前dp状态已经有值了（初始值）,所以我们不用再做一遍 
					for(rg int k=a[i+1].loc-a[i].loc;k<=500;k++) f[i][j][k][L]=f[i+1][j][k-a[i+1].loc+a[i].loc][L];//状态转移方程 
					for(rg int k=a[j].loc-a[i].loc;k<=500;k++){ f[i][j][k][L]=max(f[i][j][k][L],f[i+1][j][k-a[j].loc+a[i].loc][R]);if(k<=a[i].t) f[i][j][k][L]+=a[i].x;ans=max(ans,f[i][j][k][L]);}
					for(rg int k=a[j].loc-a[j-1].loc;k<=500;k++) f[i][j][k][R]=f[i][j-1][k-a[j].loc+a[j-1].loc][R];
					for(rg int k=a[j].loc-a[i].loc;k<=500;k++){ f[i][j][k][R]=max(f[i][j][k][R],f[i][j-1][k-a[j].loc+a[i].loc][L]);if(k<=a[j].t) f[i][j][k][R]+=a[j].x;ans=max(ans,f[i][j][k][R]);}
				}
			}
		printf("%lld\n",ans);//输出最大值 
		return 0;
	}

---

## 作者：MSqwq (赞：1)

初三一年没写过区间 DP 了，做了这题又让我重新认识了这玩意，这题就当是区间 DP 的板子吧。  
首先这题和 [关路灯](https://www.luogu.com.cn/problem/P1220)，基本一样吧。    
首先这题因为你看到，让你求一堆过程的最值，而且很显然这个东西是有后效性的，所以考虑 DP，再看到 $n$ 很小，$a_t$ 也很小，所以空间是够我们开三维的，那么再想，这个东西怎么转移，你会发现他一定不能往返，因为这样很浪费时间，好的，所以想到区间 DP，区间越来越大，已经讨论过的东西，不需要再讨论，只需要扩大区间就行，那么我们开四维，$f_{i,j,t,0/1}$，意思就是我们已经讨论了 $i$ 到 $j$ 的所有页，当前用了 $t$ 的时间，如果是 $0$ 就是当前位置在 $i$，如果是 $1$，当前位置就是在 $j$。  
我做 DP 题比较喜欢分析为什么用 DP，和为什么用这种 DP，我觉得这个切入点可能会更好一点，所以我会更详细的说明为啥本题用区间 DP。  
好的，那么我们首先可以发现一个很重要的性质，就是他不会往返的读，因为很浪费时间，他只会一会向右，一会向左读。那么我们就可以写出对应在两个位置的状态转移方程。  
对于当前在 $i$ 位置：  
那么这个位置可以是 $i+1$ 的位置转移,而且时刻是 $t-\left| a[i].x-a[i+1].x\right|$,转移过来的。  
那么就是 $f_{i+1.j.t-\left| a[i].x-a[i+1].x\right|,0}$。  
那么也可以从上一个状态在 $j$ 走过来，花费的时间就是 $i$ 到 $j$ 的距离。    
那么就是 $f_{i+1.j.t-\left| a[i].x-a[j].x\right|,1}$。    
对于当前在 $j$ 位置（其实就是仿照上面的写）：  
那么这个位置可以是 $j-1$ 的位置转移,而且时刻是 $t-\left| a[j].x-a[j-1].x\right|$,转移过来的。  
那么就是 $f_{i.j-1.t-\left| a[j].x-a[j-1].x\right|,1}$。  
那么也可以从上一个状态在 $i$ 走过来，花费的时间就是 $i$ 到 $j$ 的距离。  
那么就是 $f_{i,j-1.t-\left| a[i].x-a[j].x\right|,0}$。    
其实这类 DP 大多数都是很对仗的，大多数情况考虑一边另一边就可以模仿的写出来了。    
代码如下：  
```
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iostream>
#include<vector>
#include<set>
#include<string>
#include<map>
#include<queue>
#include<stack>
#include<cmath>
#include<functional>
#define ll long long
using namespace std;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;

inline ll read()
{
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0',c=getchar();}
	return x*f;
}
const int N=220,M=510;
struct qwq{
	ll x,v,t;
}a[N];
bool cmp(qwq x,qwq y){return x.x<y.x;}
ll f[N][N][M][2];
int main()
{
	int n=read();
	for(int i=1;i<=n;i++)a[i].x=read(),a[i].v=read(),a[i].t=read();
	sort(a+1,a+2+n,cmp);
	
	ll ans=0;
	for(int len=1;len<=n+1;len++)
	{
		for(int i=1;i+len<=n+1;i++)
		{
			int j=i+len;
			for(int t=500;t>=abs(a[i].x-a[j].x)+min(abs(a[i].x),abs(a[j].x));t--)
			{
				f[i][j][t][0]=max(f[i+1][j][t-abs(a[i].x-a[i+1].x)][0],f[i+1][j][t-abs(a[i].x-a[j].x)][1])+(t<=a[i].t?a[i].v:0);
				f[i][j][t][1]=max(f[i][j-1][t-abs(a[j].x-a[j-1].x)][1],f[i][j-1][t-abs(a[i].x-a[j].x)][0])+(t<=a[j].t?a[j].v:0);
				ans=max(ans,max(f[i][j][t][0],f[i][j][t][1]));
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：gyh20 (赞：1)

区间 DP 裸题。

如果做过 
- [P1220 关路灯 ](https://www.luogu.com.cn/problem/P1220)

这道题就很简单了（顺便请求降低那道题的难度）。

设 $dp_{i,j,k,0/1}$ 表示区间 $i\sim j$，花费 $k$ 的时间，最终停留在左、右端点的最大收益。

转移就是从一个位置走到另一个位置，时间（$k$）小于等于 $t_i$ 的就增加 $v_i
$。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define re register
inline int read() {
	re int t=0,f=0;
	re char v=getchar();
	while(v<'0')f|=(v=='-'),v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return f?-t:t;
}
using namespace std;
long long dp[202][202][502][2],ans;
int n,p;
struct node{
	int x,t,v;
}a[202];
inline bool cmp(re node x,re node y){
	return x.x<y.x;
}
inline long long max(re long long x,re long long y){
	return x>y?x:y;
}
signed main(){
	n=read();
	for(re int i=1;i<=n;++i)a[i].x=read(),a[i].v=read(),a[i].t=read();
	a[++n].x=0;a[n].t=-1;a[n].v=0;
	sort(a+1,a+n+1,cmp);
	for(re int i=1;i<=n;++i)if(a[i].t==-1)p=i;
	for(re int i=p;i;--i)for(re int j=p;j<=n;++j)for(re int k=0;k<=500;++k)dp[i][j][k][0]=dp[i][j][k][1]=-(1ll<<61);
	memset(dp[p][p],0,sizeof(dp[p][p]));
	for(re int i=p;i;--i){
		for(re int j=p;j<=n;++j){
			for(re int k=0;k+a[j].x-a[i].x<=500;++k){
				dp[i][j][k+a[j].x-a[i].x][0]=max(dp[i][j][k+a[j].x-a[i].x][0],dp[i][j][k][1]);
				dp[i][j][k+a[j].x-a[i].x][1]=max(dp[i][j][k+a[j].x-a[i].x][1],dp[i][j][k][0]);
			}
			for(re int k=1;k<=500;++k){
				dp[i][j][k][0]=max(dp[i][j][k][0],dp[i][j][k-1][0]);
				dp[i][j][k][1]=max(dp[i][j][k][1],dp[i][j][k-1][1]);
			}
			for(re int k=0;k+a[j+1].x-a[j].x<=500;++k)dp[i][j+1][k+a[j+1].x-a[j].x][1]=max(dp[i][j+1][k+a[j+1].x-a[j].x][1],dp[i][j][k][1]+(k+a[j+1].x-a[j].x<=a[j+1].t?a[j+1].v:0));
			for(re int k=0;k+a[i].x-a[i-1].x<=500;++k)dp[i-1][j][k+a[i].x-a[i-1].x][0]=max(dp[i-1][j][k+a[i].x-a[i-1].x][0],dp[i][j][k][0]+(k+a[i].x-a[i-1].x<=a[i-1].t?a[i-1].v:0));
		ans=max(ans,max(dp[i][j][500][0],dp[i][j][500][1]));}
	}
	printf("%lld\n",ans);
}
```


---

## 作者：0x3F (赞：0)

DP 题。

首先将 $x$ 离散化，然后预处理出在时刻 $t$ 到达点 $i$ 可以获得的快乐值为 $tmp_{i,t}$。

考虑 $dp_{i,c,d}$ 表示在 $i$ 时刻，当前在 $c$ 位置，最远到达过 $d$ 点时可以得到的快乐值的最大值。

转移有三种方法：

$dp_{i+dis(c,d),d,c}=dp_{i,c,d}$

$dp_{i+dis(c,c+1),c+1,d}=dp_{i,c,d}+tmp_{c+1,i+dis(c,c+1)}$ 当 $c \geq d$

$dp_{i+dis(c,c-1),c-1,d}=dp_{i,c,d}+tmp_{c-1,i+dis(c,c-1)}$ 当 $c \leq d$

然后没了。代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define _ 210
#define __ 510
using namespace std;
int n, nn, X[_], V[_], T[_];
int pos[_];
long long tmp[_][__];
long long dp[__][_][_];
long long ans;
void chkmax(long long& a, long long b) {
	a = (a>b?a:b);
}
int main() {
	scanf("%d", &n);
	n++;
	for (int i = 2; i <= n; i++) {
		scanf("%d%d%d", X+i, V+i, T+i);
		pos[i] = X[i];
	}
	sort(pos+1, pos+n+1);
	nn = unique(pos+1, pos+n+1) - pos - 1;
	for (int i = 1; i <= n; i++) {
		X[i] = lower_bound(pos+1, pos+n+1, X[i]) - pos;
		tmp[X[i]][T[i]] += V[i];
	}
	n = nn;
	for (int i = 1; i <= n; i++) {
		for (int j = 499; j >= 0; j--) {
			tmp[i][j] += tmp[i][j+1];
		}
	}
	memset(dp, 0xFF, sizeof(dp));
	ans = dp[0][X[1]][X[1]] = tmp[X[1]][0];
	for (int i = 0; i <= 500; i++) {
		for (int c = 1; c <= n; c++) {
			for (int d = 1; d <= n; d++) {
				if (dp[i][c][d] != -1) {
					if (dp[i][c][d] > ans) {
						chkmax(ans, dp[i][c][d]);
					}
					if (c >= d) {
						if (i+pos[c]-pos[d] <= 500) {
							chkmax(dp[i+pos[c]-pos[d]][d][c], dp[i][c][d]);
						}
						if (c != n && i+pos[c+1]-pos[c] <= 500) {
							chkmax(dp[i+pos[c+1]-pos[c]][c+1][d], dp[i][c][d] + tmp[c+1][i+pos[c+1]-pos[c]]);
						}
					}
					if (c <= d) {
						if (i+pos[d]-pos[c] <= 500) {
							chkmax(dp[i+pos[d]-pos[c]][d][c], dp[i][c][d]);
						}
						if (c != 1 && i+pos[c]-pos[c-1] <= 500) {
							chkmax(dp[i+pos[c]-pos[c-1]][c-1][d], dp[i][c][d] + tmp[c-1][i+pos[c]-pos[c-1]]); 
						}
					}
				}
			}
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```


---


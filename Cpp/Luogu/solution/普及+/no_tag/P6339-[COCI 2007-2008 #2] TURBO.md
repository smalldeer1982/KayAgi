# [COCI 2007/2008 #2] TURBO

## 题目描述

给定一个长度为 $n$ 的 $1\sim n$ 的排列，你需要对其进行从小到大的排序，排序的规则如下：

- 第一个阶段，将数字 $1$  通过与和它相邻的数字的交换来放置到 $1$ 号下标上。
- 第二个阶段，将数字 $n$ 进行如上同样的操作来放置到 $n$ 号下标上。
- 第三个阶段，将数字 $2$ 进行如上同样的操作来放置到 $2$ 号下标上。
- 第四个阶段，将数字 $n-1$ 进行如上同样的操作来放置到 $n-1$ 号下标上。

以此类推。

对于每一个阶段，输出交换的次数。


## 说明/提示

#### 数据规模与约定

- 对于 $70\%$ 的数据，保证 $n<100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^5$。
#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #2](https://hsin.hr/coci/archive/2007_2008/contest2_tasks.pdf) *T4 TURBO***。

## 样例 #1

### 输入

```
3
2
1
3```

### 输出

```
1
0
0```

## 样例 #2

### 输入

```
5
5
4
3
2
1```

### 输出

```
4
3
2
1
0```

## 样例 #3

### 输入

```
7
5
4
3
7
1
2
6```

### 输出

```
4
2
3
0
2
1
0```

# 题解

## 作者：All_Wrong_Answer (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P6339)

## 思路与算法：

**线段树**。

先观察，发现一个数在执行完它的排序步骤后不会对接下来的排序产生影响，由于题目需要分大于等于 $\frac{n+1}{2}$ 下取整的值和大于这个值两种，所以线段树的 $sum$ 要有两个，一个是把这个数从当前位置向前移到指定位置所需步数，另一个则是向后移动到指定位置所需的步数。


线段树定义与建树：
```cpp

struct xds{
	int l;
	int r;
	int sum1,sum2;//两个方向到指定位置的步数 
	int add1,add2;//同理，有两个sum当然就需要两个懒标记 
	void oin1(int a,int b){
		l=a;
		r=b;
		add1=add2=0;
	}
	void oin2(int c){
		sum1=(c-1);
		sum2=(x-c);
		//初始化输入时的位置 
	}
	
}tre[500005];//线段树 

void js(int q,int l,int r){
	tre[q].oin1(l,r);
	if(l==r) {
		tre[q].oin2(l);
		return ;
	}
	int mid=l+r>>1;
	js(q*2,l,mid);
	js(q*2+1,mid+1,r);
}//建树，与模板基本无异 
```

接下来处理区间加法，显然的，在一个数向前移动以实现排序时，会对这个数位置后面的所有数的 $sum_2$ 产生 $-1$ 的贡献，对这个数前面的所有数的 $sum_1$ 产生 $-1$ 的贡献，这个很显然，不懂的画个图模拟一下样例即可。

区间加：


```cpp
void qjjf(int q,int ml,int mr,int k,int t){
	if(ml<=zqj&&mr>=yqj){
		if(t==1){
			tre[q].sum1+=((yqj-zqj+1)*k);
		    tre[q].add1+=k;
		}
		else{
			tre[q].sum2+=((yqj-zqj+1)*k);
		    tre[q].add2+=k;
		}
		//分辨对sum1操作还是对sum2操作 
		return ;
	}
	pushdown(q);
	int mid=(zqj+yqj)/2;
	if(ml<=mid) qjjf(left,ml,mr,k,t);
	if(mr>mid) qjjf(right,ml,mr,k,t);
}
```

最后是单点查询，很简单，与模板无异：


```cpp
int qjqh(int q,int mb,int dc){
	if(zqj==mb&&yqj==mb){
		if(dc<=(x+1)/2) return tre[q].sum1;//判断这个数是向前移还是向后移的 
		else return tre[q].sum2;
	}
	pushdown(q);
	int mid=(zqj+yqj)/2;
	if(mb<=mid) return qjqh(left,mb,dc);
	if(mb>mid) return qjqh(right,mb,dc); 
}
```

**一点细节：**

1. 在输出距离时与 $0$ 取大值，防止输出负数。
2. pushdown 要同时处理两个 $sum$ 的值。
3. 对位置不要直接写成输入时的值了，记得映射一个位置。
4. 本题不用处理区间和，不用写 pushup。


## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;

#define left q*2
#define right q*2+1
#define zqj tre[q].l
#define yqj tre[q].r

int x;
int m[100005];

int wz[100005];

struct xds{
	int l;
	int r;
	int sum1,sum2;//两个方向到指定位置的步数 
	int add1,add2;//同理，有两个sum当然就需要两个懒标记 
	void oin1(int a,int b){
		l=a;
		r=b;
		add1=add2=0;
	}
	void oin2(int c){
		sum1=(c-1);
		sum2=(x-c);
		//初始化输入时的位置 
	}
	
}tre[500005];//线段树 

void pushdown(int q){
	if(tre[q].add1!=0){
		tre[q*2].sum1+=((tre[q*2].r-tre[q*2].l+1)*tre[q].add1);
		tre[q*2].add1+=tre[q].add1;
		tre[q*2+1].sum1+=((tre[q*2+1].r-tre[q*2+1].l+1)*tre[q].add1);
		tre[q*2+1].add1+=tre[q].add1;
	}
	if(tre[q].add2!=0){
		tre[q*2].sum2+=((tre[q*2].r-tre[q*2].l+1)*tre[q].add2);
		tre[q*2].add2+=tre[q].add2;
		tre[q*2+1].sum2+=((tre[q*2+1].r-tre[q*2+1].l+1)*tre[q].add2);
		tre[q*2+1].add2+=tre[q].add2;
	}
	tre[q].add1=tre[q].add2=0;
}

void js(int q,int l,int r){
	tre[q].oin1(l,r);
	if(l==r) {
		tre[q].oin2(l);
		return ;
	}
	int mid=l+r>>1;
	js(q*2,l,mid);
	js(q*2+1,mid+1,r);
}//建树，与模板基本无异 
void qjjf(int q,int ml,int mr,int k,int t){
	if(ml<=zqj&&mr>=yqj){
		if(t==1){
			tre[q].sum1+=((yqj-zqj+1)*k);
		    tre[q].add1+=k;
		}
		else{
			tre[q].sum2+=((yqj-zqj+1)*k);
		    tre[q].add2+=k;
		}
		//分辨对sum1操作还是对sum2操作 
		return ;
	}
	pushdown(q);
	int mid=(zqj+yqj)/2;
	if(ml<=mid) qjjf(left,ml,mr,k,t);
	if(mr>mid) qjjf(right,ml,mr,k,t);
}

int qjqh(int q,int mb,int dc){
	if(zqj==mb&&yqj==mb){
		if(dc<=(x+1)/2) return tre[q].sum1;//判断这个数是向前移还是向后移的 
		else return tre[q].sum2;
	}
	pushdown(q);
	int mid=(zqj+yqj)/2;
	if(mb<=mid) return qjqh(left,mb,dc);
	if(mb>mid) return qjqh(right,mb,dc); 
}

signed main(){
	cin>>x;
	for(int i=1;i<=x;i++){
		cin>>m[i];
		wz[m[i]]=i;//映射位置 
	}
	js(1,1,x);
	int s=0;
	int mq1=0,mq2=x+1;
	while(1){
		if(s==x) break;
		if(s%2==0){
			mq1++;
			cout<<max(0,qjqh(1,wz[mq1]/*不要写成m[mq1]，下同*/,mq1))<<endl;
			if(wz[mq1]!=x) qjjf(1,wz[mq1]+1,x,-1,1);//对后面数的sum1产生贡献 
			if(wz[mq1]!=1) qjjf(1,1,wz[mq1]-1,-1,2);//对前面数的sum2产生贡献 
			s++;
		} 
		else{
			mq2--;
			cout<<max(0,qjqh(1,wz[mq2],mq2))<<endl;
			if(wz[mq2]!=1) qjjf(1,1,wz[mq2]-1,-1,2);//对前面数的sum2产生贡献 
			if(wz[mq2]!=x) qjjf(1,wz[mq2]+1,x,-1,1);//对后面数的sum1产生贡献 
			s++;
		}
	}
	return 0; 
}
```

---

## 作者：_edge_ (赞：3)

这题目的话，其实可以先考虑一下操作的性质。

考虑当前如果说是 $1$ 要被换到最前面，那么必然当前 $1$ 所在的位置之前的地方都要 $+1$，同理，如果说是 $n$ 要被换到最后面，那么 $n$ 后面的所有位置地方都要 $-1$，那么考虑将这两个排好之后，所有之后的操作显然是不会影响他们两个了，这时候就把他们两个忽略掉。

这时候我们再考虑 $2$ 和 $n-1$ 也是进行同样的操作。

然后是 $3$ 和 $n-2$。

以此类推。

那么知道了这个就比较好想了，维护当前序列所出现过的位置所对应的加减，这个可以用线段树或者树状数组来维护，应该是区间加，单点查询。

注意这里的线段树不用维护除叶子节点的区间和，因为它并没有要求。

然后就可以愉快地写数据结构了。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define ls(x) x<<1
#define rs(x) x<<1|1
using namespace std;
const int INF=1e5+5;
int n,a[INF],b[INF],ans;
struct _node_tree {
        int l,r,sum,lazy;
} tree[INF<<4];
void build(int l,int r,int id) {
        tree[id].l=l; tree[id].r=r;
        if (l==r) {tree[id].sum=0; return;}
        int Mid=(l+r)>>1;
        if (l<=Mid) build(l,Mid,ls(id));
        if (Mid<r) build(Mid+1,r,rs(id));
        return;
}
void push_down(int id) {
        if (tree[id].lazy==0) return;
        int idd=ls(id); tree[idd].lazy+=tree[id].lazy; tree[idd].sum+=tree[id].lazy;
        idd=rs(id); tree[idd].lazy+=tree[id].lazy; tree[idd].sum+=tree[id].lazy;
        tree[id].lazy=0;
        return;
}
int query(int x,int id) {
        int ll=tree[id].l,rr=tree[id].r;
        if (ll==rr) return tree[id].sum;
        push_down(id);
        int Mid=(ll+rr)>>1,res=0;
        if (x<=Mid) res=query(x,ls(id));
        else res=query(x,rs(id));
        return res;
}
void updata(int l,int r,int id,int x) {
        int ll=tree[id].l,rr=tree[id].r;
        if (l<=ll && rr<=r) {
                tree[id].sum+=x;
                tree[id].lazy+=x;
                return;
        }
        push_down(id);
        int Mid=(ll+rr)>>1;
        if (l<=Mid) updata(l,r,ls(id),x);
        if (Mid<r) updata(l,r,rs(id),x);
        return;
}
signed main()
{
        scanf("%d",&n);
        for (int i=1; i<=n; i++)
                scanf("%d",&a[i]);
        for (int i=1; i<=n; i++)
                b[a[i]]=i;
        build(1,n,1);
        for (int i=1,j=n,k=1; i<=j; k++) {
                if (k&1) {
                        // 1~b[i]
                        int xx=query(b[i],1)+b[i];
                        // cout<<xx<<" over\n";
                        updata(1,b[i]-1,1,1);
                        ans+=abs(xx-i);
                        i++;
                }
                else {
                        int xx=query(b[j],1)+b[j];
                        updata(b[j]+1,n,1,-1);
                        ans+=abs(xx-j);
                        j--;
                }
                cout<<ans<<"\n";
                ans=0;
        }
        return 0;
}

```

~~线段树其实还可以用标记永久化，但是我不会。~~

如果有问题还请指正。

---

## 作者：ycy1124 (赞：2)

### 前置知识
[平衡树](https://oiwiki.org/ds/bst/)。
### 题意
题目写的很清楚，这里不过多赘述，只需要注意每个点只能交换相邻的就行了。
### 思路
考虑题目是要让我们实现什么，根据操作顺序每次求出每个点在他前面或者后面有多少个数，然后删掉这个数。

发现这个很好用平衡树来维护。将每个点的权值设为点的下标，对于每个数前面或后面有多少个数可以直接用排名查询来维护，只需要用一个数组映射一下每个数的位置即可。
### 代码
这里实现是用的 fhq-Treap。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int l,r,key,val,len;
}a[100001];
int tot=0,rot;	
void push_up(int p){
	a[p].len=a[a[p].l].len+a[a[p].r].len+1;
}
//-----------------------------------------合并 
int merge(int rot1,int rot2){
	if(rot1==0){
		return rot2;
	}
	else if(rot2==0){
		return rot1;
	}
	if(a[rot1].key<a[rot2].key){
		a[rot1].r=merge(a[rot1].r,rot2);
		push_up(rot1);
		return rot1;
	}
	else{
		a[rot2].l=merge(rot1,a[rot2].l);
		push_up(rot2);
		return rot2;
	}
}
//-----------------------------------------按权值拆 
void val_split(int now,int k,int &rot1,int &rot2){
	if(now==0){
		rot1=0;
		rot2=0;
		return;
	}
	else if(a[now].val<=k){
		rot1=now;
		val_split(a[rot1].r,k,a[rot1].r,rot2);
	}
	else{
		rot2=now;
		val_split(a[rot2].l,k,rot1,a[rot2].l);
	}
	push_up(now);
}
//-----------------------------------------按排名拆 
void k_split(int now,int k,int &rot1,int &rot2){
	if(now==0){
		rot1=0;
		rot2=0;
		return;
	}
	push_up(now);
	if(a[a[now].l].len<k){
		rot1=now;
		k_split(a[rot1].r,k-a[a[rot1].l].len-1,a[rot1].r,rot2);
	}
	else{
		rot2=now;
		k_split(a[rot2].l,k,rot1,a[rot2].l);
	}
	push_up(now);	
}
//-------------------------------------新建节点 
void New_Node(int val){
	a[++tot].key=rand()%114514+1;
	a[tot].l=0;
	a[tot].r=0;
	int rot1,rot2,now=tot;
	a[tot].len=1;
	a[tot].val=val;
	val_split(rot,val,rot1,rot2);
	rot=merge(merge(rot1,now),rot2);
}
//-------------------------------------删除 
void Erase(int val){
	int rot1,rot2,rot3,rot4;
	val_split(rot,val-1,rot1,rot2);
	k_split(rot2,1,rot3,rot4);
	rot=merge(rot1,rot4);
}
//-------------------------------------查找 
int Find_k(int val){
	int rot1,rot2;
	val_split(rot,val-1,rot1,rot2);	
    int x=a[rot1].len+1;
	rot=merge(rot1,rot2);
    return x;
} 
int A[100005]；
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	srand(time(NULL));
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
        int w;
        cin>>w;
        A[w]=i;//映射每个数的下标
        New_Node(i);
	}
    int js=n;
    for(int i=1;i<=(n+1>>1);i++){
        int x=Find_k(A[i]);
        cout<<x-1<<'\n';//前面的数所以要排名减一
        Erase(A[i]);
        --js;
        if(n%2==1&&i==(n+1>>1)){//奇数个数的时候不能多算
            continue;
        }
        x=Find_k(A[n-i+1]);
        cout<<js-x<<'\n';//后面的数就是剩余的数减去这个数的排名
        --js;
        Erase(A[n-i+1]);
    }
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/191560508)。

---

## 作者：wkjwkj (赞：2)

我们可以先跟着样例模拟一下。

这里取样例三来模拟：

```php
7
5
4
3
7
1
2
6
```

第一次操作后，原数列变为 `1 5 4 3 7 2 6` 。

第二次操作后，原数列变为 `1 5 4 3 2 6 7` 。

不难发现，每次操作过后，都会有一个数字被踢出队列，不再对其余数的交换产生影响，若将这些数删去，我们的规律会更加明显。

一次操作， `5 4 3 7 2 6` 。

二次操作， `5 4 3 2 6` 。

设被操作的数为 $x$ ，即每次操作所求的答案就是数字 $x$ 所在的位置与队头（或队尾）的距离。

这样说可能还不太直观，我们将问题抽象一下，即原问题等价于：

**给定一个数列，长度为 $n$ ，一共进行 $n$ 次操作，设当前所操作的次数为 $x$ 。**

**若 $x$ 为奇数，则输出数字 $x/2+1$ 前有多少个有效元素，然后将数字 $x/2+1$ 标为无效元素。**

**若 $x$ 为偶数，则输出数字 $n-x/2+1$ 后有多少个有效元素，然后将数字 $n-x/2+1$ 标记为无效元素。**

这样问题就很清晰了，只要用一个树状数组便可维护上述答案。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int c[100005];
int n;
int ask(int x)
{
	int ans=0;
	for(;x;x-=x&-x)ans+=c[x];
	return ans;
}
void add(int x,int y)
{
	for(;x<=n;x+=x&-x)c[x]+=y;
}
int a[100005];
int cnt[100005];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),cnt[a[i]]=i,add(i,1);
	for(int i=1;i<=n;i++)
	{
		int x;
		if(i%2==1)
		{
			x=i/2+1;
			printf("%d\n",ask(cnt[x])-1);
		}
		else{
			x=n-i/2+1;
			printf("%d\n",ask(n)-ask(cnt[x])); 
		}
		add(cnt[x],-1);
	}
	return 0;
}
```





---

## 作者：hxuwna (赞：1)

## 题面
给定一个长度为 $n$ 的 $1\sim n$ 的排列，你需要对其进行从小到大的排序，排序的规则如下：

- 第一个阶段，将数字 $1$  通过与和它相邻的数字的交换来放置到 $1$ 号下标上。
- 第二个阶段，将数字 $n$ 进行如上同样的操作来放置到 $n$ 号下标上。
- 第三个阶段，将数字 $2$ 进行如上同样的操作来放置到 $2$ 号下标上。
- 第四个阶段，将数字 $n-1$ 进行如上同样的操作来放置到 $n-1$ 号下标上。

以此类推。

对于每一个阶段，输出交换的次数。

## 分析
首先，在不考虑已经进行过操作的数的情况下，显然所有数的相对位置是不变的。

因为对于每次交换，交换的两个数与其他数的相对位置不变。

而对于每个阶段，由于没操作过的数的下标的集合是一个区间，所以我们可以吧每次操作看作把区间的左（或右）端点到操作的数的下标的区间范围内的数向右（或左）移动一位（不需要对当前阶段需要操作的数进行代码上的操作，因为后面的阶段都已经与它无关了）。

于是，问题就转换为了区间修改加单点查询，显然可以用线段树。

## 具体实现
对于每个阶段，我们先得到操作的数的下标，输出的答案就是 $\left |  x-i \right | $（$x$ 是下标），再进行 1 到 $x$ 或 $x$ 到 $n$ 的区间加减（注意左右端点为 1 和 $n$ 且是全部加减，因为识别出未进行过操作的数再加减的操作过于复杂，而经过操作的数后续并不会被查询到，显然对答案无影响）

## 码
由于我是直接用的板子，所以代码上会有一些不必要的运算，但对答案无影响。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N=1e5+5;
int n,a[N],b[N];
struct SGT{
	struct info{
		int w;
		void set(int x){w=x;}
	}s[N<<2];
	struct tag{
		int add;
		void reset(){add=0;}
	}tg[N<<2];
	info merge(const info &x,const info &y){
		return {0};
	}
	tag compose(const tag &x,const tag &y){
		return {x.add+y.add};
	}
	info apply(const info &x,const tag &y){
		return {x.w+y.add};
	}
	void pushup(int p){s[p]=merge(s[p<<1],s[p<<1|1]);}
	void maketag(int p,const tag &k){s[p]=apply(s[p],k),tg[p]=compose(tg[p],k);}
	void pushdown(int p){maketag(p<<1,tg[p]),maketag(p<<1|1,tg[p]),tg[p].reset();}
	void modify(int p,int l,int r,int nl,int nr,const tag &k){
		if(nl<=l&&r<=nr){maketag(p,k);return;}
		int mid=(l+r)>>1;pushdown(p);
		if(nl<=mid) modify(p<<1,l,mid,nl,nr,k);
		if(nr>mid) modify(p<<1|1,mid+1,r,nl,nr,k);
		pushup(p);
	}
	info ask(int p,int l,int r,int nl,int nr){
		if(nl<=l&&r<=nr) return s[p];
		int mid=(l+r)>>1;pushdown(p);
		if(nr<=mid) return ask(p<<1,l,mid,nl,nr);
		if(nl>mid) return ask(p<<1|1,mid+1,r,nl,nr);
		return merge(ask(p<<1,l,mid,nl,nr),ask(p<<1|1,mid+1,r,nl,nr));
	}
	void build(int p,int l,int r){
		tg[p].reset();
		if(l==r) return s[p].set(l);
		int mid=(l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
		pushup(p);
	}
}T1;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],b[a[i]]=i;
	T1.build(1,1,n);
	for(int l=1,r=n,cnt=1;cnt<=n;cnt++){
		if(cnt&1){
			int x=T1.ask(1,1,n,b[l],b[l]).w;
			cout<<x-l<<"\n";
			T1.modify(1,1,n,1,b[l],{1});
			l++;
		}else{
			int x=T1.ask(1,1,n,b[r],b[r]).w;
			cout<<r-x<<"\n";
			T1.modify(1,1,n,b[r],n,{-1});
			r--;
		}
	}
	return 0;
}
```
时间复杂度 $O(n\log_{}{n})$。

---

## 作者：huyangmu (赞：1)

作者只会很板的线段树，同学都用高级的平衡树和树状数组过了。

首先对于每一个数 $x$，它要么往左移，要么往右移，如果往左移，那么下标比它小的数下标都要增加 $1$，它自己的下标变成 $x$，其余下标不变。如果往右移，那么下标比它大的数下标都减少 $1$，它自己的下标变成 $x$，其余位置不变。

对于每个数 $x$，它的新位置即为 $x$ 的下标加上右边往左移的数的个数，再加上它左边往右移的数的个数，用两棵线段树维护即可。

### AC Code


```cpp

#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int n, a[N], pos[N], tree[4 * N], tree2[4 * N], l, r;
void pushup (int x){
	tree[x] = (tree[(x << 1)] + tree[(x << 1) + 1]);
	return ;
}
int query (int l, int r, int x, int y, int cur){
	if (l > y || r < x) return 0;
	if (x <= l && r <= y) return tree[cur];
	int mid = l + r >> 1;
	return query(l, mid, x, y, (cur << 1)) + query(mid + 1, r, x, y, (cur << 1) + 1);
}
void update (int l, int r, int x, int y, int cur, int val){
	if (l > y || r < x) return ;
	if (x <= l && r <= y){
		tree[cur] = val;
		return ;
	}
	int mid = l + r >> 1;
	update(l, mid, x, y, (cur << 1), val);
	update(mid + 1, r, x, y, (cur << 1) + 1, val);
	pushup(cur);
	return ;
} 
void pushup2 (int x){
	tree2[x] = (tree2[(x << 1)] + tree2[(x << 1) + 1]);
	return ;
}
int query2 (int l, int r, int x, int y, int cur){
	if (l > y || r < x) return 0;
	if (x <= l && r <= y) return tree2[cur];
	int mid = l + r >> 1;
	return query2(l, mid, x, y, (cur << 1)) + query2(mid + 1, r, x, y, (cur << 1) + 1);
}
void update2 (int l, int r, int x, int y, int cur, int val){
	if (l > y || r < x) return ;
	if (x <= l && r <= y){
		tree2[cur] = val;
		return ;
	}
	int mid = l + r >> 1;
	update2(l, mid, x, y, (cur << 1), val);
	update2(mid + 1, r, x, y, (cur << 1) + 1, val);
	pushup2(cur);
	return ;
}
signed main (){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i){
		cin >> a[i];
		pos[a[i]] = i;
	}
	l = 1, r = n;
	while (l <= r){
		cout << abs(pos[l] + query(1, n, pos[l], n, 1) - query2(1, n, 1, pos[l] - 1, 1) - l) << '\n';
		update(1, n, pos[l], pos[l], 1, 1);
		l += 1;
		if (l > r) return 0;
		cout << abs(pos[r] + query(1, n, pos[r], n, 1) - query2(1, n, 1, pos[r] - 1, 1) - r) << '\n';
		update2(1, n, pos[r], pos[r], 1, 1);
		r -= 1;
	}
	return 0;
}

---

## 作者：lw393 (赞：0)

观察一下，我们发现在移动数字 $k$ 时，可以不用考虑已经动过了的数。

举个例子，就如样例 3 中，动了 $1$ 以后，无论如何你都不会再去动 $1$ 了，因为它已经在序列的开头。

由题中要求，我们不妨以 $\lceil\frac n2\rceil$ 为界作为区分是往前面挪动还是往后面挪动（你想的话也可以下取整，不影响）。取整主要是为了方便于思考在 $n$ 为奇数时，中位数的答案，而它只能为 $0$。

我们看到数 $k$，假设 $k\le\lceil\frac n2\rceil$，那么，它需要往前挪动的次数应为：在原始序列中位置在数 $k$ 前的，值域位于 $[k+1,n-k+1]$ 的数的个数。

反之，若 $k > \lceil\frac n2\rceil$，则往后挪动次数为：在 $k$ 位置后边的，值域位于 $[n-k+2,k-1]$ 的数的个数。

树状数组可以很轻松完成这个问题。

参考代码，时间复杂度为 $O(n\log n)$：

```cpp
#include<bits/stdc++.h>
using namespace std;

struct fenwick{
  vector<int>tree;
  int n;
  int lowbit(int x) { return x & (-x); }
  void build(int x) { n = x; tree.resize(x + 1); }
  void add(int k, int x) { for(int i = k; i <= n; i += lowbit(i)) tree[i] += x; }
  int sum(int k) { int ans = 0; for(int i = k; i > 0; i -= lowbit(i)) ans += tree[i]; return ans; }
  int query(int l, int r) { if(l > r) return 0; return sum(r) - sum(l - 1); }
}t1;

const int N = 1e5 + 5;

int p[N];
int ans[N];

void solve(){
  int n; cin >> n; t1.build(n);
  for(int i = 1; i <= n; i++)
    cin >> p[i];
  for(int i = 1; i <= n; i++){
    t1.add(p[i], 1); 
    if(p[i] <= (n + 1) / 2) { ans[p[i]] = t1.query(p[i] + 1, n - p[i] + 1);  }
    else { ans[p[i]] = 2 * p[i] - n - 2 - t1.query(n - p[i] + 2, p[i] - 1); }
  }
  for(int i = 1; i <= n; i++) cout << ans[i % 2 == 1 ? (i + 1) / 2 : n - (i + 1) / 2 + 1] << '\n';
}

int main(){
  int t = 1;
  //cin >> t;
  while(t--){
    solve();
  }
  return 0;
}
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6339)
## 思路
容易发现，每次操作其实就是求一个元素到队头或队尾的距离，然后删除这个元素。

这个操作显然可以用平衡树维护，每个节点的权值设为下标，用数组映射一下，到队头队尾的距离通过排名来求。

注意输出时要对 $0$ 取 $\max$。
## 代码
使用替罪羊树实现。
```cpp
#include<bits/stdc++.h>
using namespace std;
const double line=0.74751;
struct Node {
	int l,r,dat,size,same;
} tree[100000];
int node[100000],p[100000];
int root,cnt,longth;
int n,opt,a;
void make(int &pos,int val) {
	tree[++cnt].dat=val;
	tree[cnt].size=1;
	tree[cnt].same=1;
	pos=cnt;
}
void up(int pos) {
	tree[pos].size=tree[tree[pos].l].size+tree[tree[pos].r].size+tree[pos].same;
}
bool bug(int pos) {
	return max(tree[tree[pos].l].size,tree[tree[pos].r].size)>tree[pos].size*line;
}
void under(int pos) {
	if(pos==0)return;
	under(tree[pos].l);
	if(tree[pos].same!=0)node[++longth]=pos;
	under(tree[pos].r);
}
int build(int l,int r) {
	if(l>=r)return 0;
	int mid=(l+r)/2;
	tree[node[mid]].l=build(l,mid);
	tree[node[mid]].r=build(mid+1,r);
	up(node[mid]);
	return node[mid];
}
void debug(int &pos) {
	if(bug(pos)) {
		longth=0;
		under(pos);
		pos=build(1,longth+1);
	}
}
void take(int val,int &pos) {
	if(pos==0)make(pos,val);
	else if(val<tree[pos].dat)take(val,tree[pos].l);
	else if(val>tree[pos].dat)take(val,tree[pos].r);
	else tree[pos].size++,tree[pos].same++;
	up(pos);
	debug(pos);
}
void del(int val,int &pos) {
	if(pos==0) {
		return;
	} else if(val<tree[pos].dat)del(val,tree[pos].l);
	else if(val>tree[pos].dat)del(val,tree[pos].r);
	else {
		tree[pos].size--;
		tree[pos].same--;
		return;
	}
	up(pos);
	debug(pos);
}
int wrank(int val) {
	int pos=root,rnk=1;
	while(pos) {
		if(tree[pos].dat==val) {
			rnk+=tree[tree[pos].l].size;
			break;
		}
		if(val<=tree[pos].dat)
			pos=tree[pos].l;
		else {
			rnk+=tree[tree[pos].l].size+tree[pos].same;
			pos=tree[pos].r;
		}
	}
	return rnk;
}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>a;
		p[a]=i;//映射到数组
		take(i,root);
	}
	for(int i=1;i<=n;i++) {
		if(i%2==1) {
			cout<<max(wrank(p[i/2+1])-1,0)<<endl;
			del(p[i/2+1],root);
		}
		else {
			cout<<max(n-i+1-wrank(p[n-i/2+1]),0)<<endl;
			del(p[n-i/2+1],root);
		}
	}
}
```

---

## 作者：thh_loser (赞：0)

# P6339 [COCI2007-2008#2] TURBO

 [题目链接](https://www.luogu.com.cn/problem/P6339)
 
 ## 关于题意
 
 简单来说就是给你一个 $1\sim n$ 的乱序排列，按 $1$，$n$，$2$，$n-1$ 的顺序将其复原成递增的排列，每次交换只能交换相邻的两个数，询问复原每个数时所需的交换次数，也就是当前位置与实际位置坐标之差。
 
 ## 思路
 看到题意很容易能想到维护每个数的下标，然而在 $n$ 能够达到 $10^{5}$ 的情况下暴力维护显然会超时，所以我们需要一种更高效的修改查询方式，于是我们就想到了线段树。（[如果不会线段树请看这](https://oi-wiki.org/ds/seg/)
 
 具体来说就是对于每一个数，先查询线段树中存储的位置修改的信息，将得到的位置与实际位置对比，如果需要往前移，就将前面的数位置向后移，反之将后面的数位置向前移。
 
 
 ## code
 ```cpp
 #include<bits/stdc++.h>
#define N 100010
using namespace std;
struct node{
	int l,r,cj,laz;
}tr[4*N];
int n;
int a[N],pos[N],ans[N],tot;
void build(int x,int l,int r){//线段树建树 
	tr[x].l=l,tr[x].r=r;
	if(l==r){
		return;
	}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
}
void spread(int x){//lazy标记下传 
	tr[x<<1].laz+=tr[x].laz;
	tr[x<<1|1].laz+=tr[x].laz;
	tr[x].laz=0;
}
int work(int x,int gr){//查询位置变换信息 
	if(tr[x].l==tr[x].r){
		return tr[x].laz;
	}
	spread(x);
	if(tr[x<<1].r>=gr){
		return work(x<<1,gr);
	}
	else{
		return work(x<<1|1,gr);
	}
}
void fun(int x,int l,int r,int va){//修改 
	if(tr[x].l>r||tr[x].r<l){
		return;
	}
	if(tr[x].l>=l&&tr[x].r<=r){
		tr[x].laz+=va;
		return;
	}
	spread(x);
	fun(x<<1,l,r,va);
	fun(x<<1|1,l,r,va);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		pos[a[i]]=i;//记录初始位置 
	}
	build(1,1,n);
	for(int i=1,j=n;i<=j;i++,j--){//我习惯将要输出的数先按顺序储存下来，实际上不需要 
		ans[++tot]=i;
		if(i==j){
			break;
		}
		ans[++tot]=j;
	}
	for(int i=1;i<=n;i++){
		int mot=work(1,pos[ans[i]])+pos[ans[i]];//现在的位置 
		printf("%d\n",abs(mot-ans[i]));//位置之差就是答案 
		if(mot>ans[i]){//如果要向前移 
			fun(1,1,pos[ans[i]]-1,1);//因为以前修改的一定在当前操作之前就已经确定并输出了，所以改到端点不影响结果 
		}
		else if(mot<ans[i]){//向后移 
			fun(1,pos[ans[i]]+1,n,-1);
		}
	}
	return 0;
}
 ```

---

## 作者：analysis (赞：0)

又是随机跳题的一天。

## 题解

很明显，让你维护在到某步操作时此数字的前（或后）有多少个没有归位的数。

容易想到树状数组。

用一颗树状数组表示某个数前面有多少个数，另一颗表示后面有多少个数（容易想到把 $pos$ 变成 $n - pos + 1$ 来让后缀和变为前缀和）。

没了。

时间复杂度：查询次数 $O(N)$，树状数组带上一个 $O(\log N)$，总时间即为 $O(N\log N)$。

```cpp
#include <bits/stdc++.h>
#define pii pair<int, int>
#define mp make_pair
using namespace std;
int n;
int a[100005];
int d[100005];
inline int lowbit(int x) { return x & -x; }
inline void add(int pos, int v)
{
    for (pos; pos <= n; pos += lowbit(pos))
        d[pos] += v;
    return;
}
inline int getsum(int pos)
{
    int r = 0;
    for (pos; pos >= 1; pos -= lowbit(pos))
        r += d[pos];
    return r;
}
int d1[100005];
inline void add1(int pos, int v)
{
    for (pos; pos <= n; pos += lowbit(pos))
        d1[pos] += v;
    return;
}
inline int getsum1(int pos)
{
    int r = 0;
    for (pos; pos >= 1; pos -= lowbit(pos))
        r += d1[pos];
    return r;
}
int ans[100005];
int main()
{
    cin >> n;
    for (int i = 1, x; i <= n; i++)
    {
        cin >> x;
        a[x] = i;
        add(i, 1);
        add1(i, 1);
    }
    for (int i = 1; i <= n / 2; i++)
    {
        ans[i] = getsum(a[i] - 1);
        add(a[i], -1);
        add1(n - a[i] + 1, -1);
        ans[n - i + 1] = getsum1(n - a[n - i + 1]);
        add(a[n - i + 1], -1);
        add1(n - a[n - i + 1] + 1, -1);
    }
    for (int i = 1; i <= n / 2; i++)
        cout << ans[i] << endl
             << ans[n - i + 1] << endl;
    if (n & 1)
        cout << ans[n / 2 + 1];
}


```

---

## 作者：xiaolilsq (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P6339)

首先分析题目，我们不难发现**如果一个数字所在的阶段已经过去了，它无论如何都不会对后面的数字造成影响**。

更具体的，记数字$i$被操作的阶段是$time_i$，数字$i$所在位置为$pos_i$，如果一个数字$i$会对数字$j$造成影响（即让数字$j$所在阶段的操作次数加一）当且仅当：

$$time_i>time_j\&\&\begin{cases}pos_i<pos_j(j\le\lfloor\frac{n}{2}\rfloor)\\pos_i>pos_j(j>\lfloor\frac{n}{2}\rfloor)\end{cases}$$

于是把小于等于$\lfloor\frac{n}{2}\rfloor$和大于$\lfloor\frac{n}{2}\rfloor$的分开考虑。

考虑$j\le\lfloor\frac{n}{2}\rfloor$的情况，先按$time$从小到大排序，然后从小到大扫一遍，数字$i$所在阶段操作次数是$1$到$i-1$这个范围内已经被扫过的数量，相当于是单点加，区间求和，可以用树状数组维护。

$j>\lfloor\frac{n}{2}\rfloor$的情况类似，请读者自己思考。

代码就不放了（~~写得太丑了~~）。

---


# [COCI 2007/2008 #3] CUDAK

## 题目描述

求出在区间 $[A,B]$ 中有多少个整数的各位数字之和是 $S$。并请找出最小的那个整数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le A,B\le 10^{15}$，$1\le S\le 135$。
#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T5 CUDAK***。

## 样例 #1

### 输入

```
1 9 5```

### 输出

```
1
5```

## 样例 #2

### 输入

```
1 100 10```

### 输出

```
9
19```

## 样例 #3

### 输入

```
11111 99999 24```

### 输出

```
5445
11499```

# 题解

## 作者：wangyutian111 (赞：3)

## 想法一：暴力

很明显，这道题第一反应就是暴力，枚举区间 $\left [ A,B \right ]$，逐位拆分，判断和是否等于 $S$，可以得到 $30$ 分。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long//开 long long
using namespace std;
signed main(){
	int a,b,s,minn,sum=0;
	scanf("%lld%lld%lld",&a,&b,&s);
	for(int i=a;i<=b;i++){//枚举 A 到 B
		int x=i,ans=0;
		while(x){
			ans+=x%10;
			x/=10;
		}
		if(ans==s){
			if(sum==0) minn=i;
			sum++;
		}
	}
	printf("%lld\n%lld",sum,minn);
	return 0;
}
```
## 想法二：正解

我们看一下数据范围：对于 $100\%$ 的数据，保证 $1\le A,B\le 10^{15}$，$1\le S\le 135$。

显然，枚举区间 $\left [ A,B \right ]$，时间复杂度过高。

------------

前置信息：[数位dp](https://oi-wiki.org/dp/number/)。

**简单介绍一下数位 dp：**

用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：

- 要求统计满足一定条件的数的数量（即，最终目的为计数）。

- 这些条件经过转化后可以使用「数位」的思想去理解和判断。

- 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制。

- 上界很大（比如 $10^{18}$），暴力枚举验证会超时。

**——引用于 OI-WIKI**


------------


所以显然易见，这是一道数位 dp 模板题。

设 $f_{i,j}$ 表示前 $i$ 位数位和为 $j$ 的方案总数，随后跑模板即可。

第二问可以采用二分，如果 $l$ 到 $mid$ 之间有满足条件的数，就让 $r \gets mid-1$，否则让 $l \gets mid+1$。

AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long//开 long long
using namespace std;
const int maxn=20,maxs=150;
int f[maxn][maxs]/*这里第二维要开maxs ，否则第三组样例过不去*/,digit[maxn];
int a,b,s;
int dfs(int pos,int pre,int limit,int lead){
	if(pos==0&&pre==s) return 1;
	if(pre+pos*9<s) return 0;	
	if(!lead&&!limit&&f[pos][pre]!=-1) return f[pos][pre];
	int sum=0,up;
	if(limit) up=digit[pos];
	else up=9;
	for(int i=0;i<=up;i++){
		if(pre+i>s) break;
		sum+=dfs(pos-1,pre+i,(limit&&i==up),lead&&(i==0));
	}
	if(!limit&&!lead) f[pos][pre]=sum;
	return sum; 
}
int solve(int x){
	memset(f,-1,sizeof(f));//清空
	memset(digit,0,sizeof(digit));
	int cnt=0;
	while(x){
		digit[++cnt]=x%10;
		x/=10;
	}
	return dfs(cnt,0,1,1);
}
signed main(){
	scanf("%lld%lld%lld",&a,&b,&s);
	int x=solve(a-1);
	printf("%lld\n",solve(b)-x);
	int l=a,r=b,ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(solve(mid)-x>0){//如果区间内还有满足条件的数字
			r=mid-1;//右指针左移
			ans=mid;//保存答案
		}
		else l=mid+1;//否则左指针右移
	}
	printf("%lld",ans);//输出答案
	return 0;//完美结束
}
```





















---

## 作者：A_B_ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P6356)

~~万事先暴力，然后TLE。~~

数位分离一下，再 `for` 循环枚举。
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int a, b, s, cnt, minn = 0x7fffffff;

int digit_sum(int num)
{
    int sum = 0;
    while(num != 0)
    {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}

signed main()
{
    cin >> a >> b >> s;
    for(int i = a; i <= b; i++)
    {
        if(digit_sum(i) == s)
        {
            cnt++;
            minn = min(minn, i);
        }
    }
    cout << cnt << endl << minn << endl;
}
```
$20$ 分代码。

___
# 思路
$dp_{ijk}$ 表示的是从高到低考虑到第 $ i $ 位时，前 $ i $ 位的数字之和模 $ S $ 为 $ j $，且前 $ i $ 位是否已经小于 $ b $ 的上界为 $ k $ 的方案数。其中 $ k $ 可以取 $ 0 $ 或 $ 1 $，表示是否小于上界。其中的枚举选用记忆化搜索，最后使用二分答案 $mid$ 去查找满足条件的最小值

补充：

上面思路中的 $S$ 指的是 $pre - i$，这个表达式就是计算前缀和模 $ S $ 的余数的。

二分答案中如果 $l - mid$ 之间找到了就把右边界设成 $ mid $，否则把左边界设成 $ mid + 1 $ 即可。

AC代码：

```cpp
#include <bits/stdc++.h> //万能头，妈妈再也不用担心我CE了
#define int long long    // 十年oi一场空，不开long long见祖宗

using namespace std;

const int N = 20, M = 150;

int digit[N], sum[N], dp[N][M][2];
int a, b, s;
// 初始化

int dfs(int pos, int pre, int limit) // 记忆化搜索dfs, pos表示当前搜索的位置，pre表示前缀和，limit表示是否限制最高位
{
    if (pos == 0) // 如果搜索到最低位，判断前缀和是否为0，是则返回1，否则返回0
    {
        return pre == 0 ? 1 : 0;
    }
    if (dp[pos][pre][limit] != -1) // 如果当前状态已经计算过(dp数组的数值不为-1)，直接返回结果
    {
        return dp[pos][pre][limit];
    }
    int up = limit ? digit[pos] : 9; // 根据是否限制最高位，确定当前位置可以取的最大值
    int ans = 0;
    for (int i = 0; i <= up; i++) // 遍历当前位置可以取的所有值
    {
        ans += dfs(pos - 1, pre - i, limit && i == up); // 转移到下一位，并更新前缀和和限制条件，累加答案
    }
    dp[pos][pre][limit] = ans; // 存答案
    return ans;
}

int split(int n) // 数位分离，把每一个整数分解，存在digit数组里
{
    int len = 0;
    while (n > 0) // 简单的数位分离
    {
        digit[++len] = n % 10;
        n /= 10;
    }
    return len;
}

int solve(int n, int s)
{
    if (n == 0) // 特判
    {
        return 0;
    }
    int len = split(n);
    memset(dp, -1, sizeof(dp)); // memset时间超时警告
    return dfs(len, s, 1);
}

int find(int a, int b, int s) // 二分查找，调用之前的函数找到满足条件的最小值
{
    int l = a, r = b;
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (solve(mid, s) - solve(a - 1, s) > 0)
        {
            r = mid;
        }
        else
        {
            l = mid + 1;
        }
    }
    return l;
}

signed main()
{
    cin >> a >> b >> s;
    cout << solve(b, s) - solve(a - 1, s) << endl;
    cout << find(a, b, s) << endl;
    return 0; // 养成好习惯
}


```
本文思路来自 `decoqwq`，TA的[blog](https://www.luogu.com.cn/blog/decoqwq/solution-p6356)。

谢谢您的观看。

---

## 作者：decoqwq (赞：2)

数位 dp 板子题，`dp[i][j]` 代表进行到第 $i$ 位数位和为 $j$ 的方案数，枚举当前位选什么记忆化搜索即可。

对于第二问，考虑二分答案 $mid$，如果 $l-mid$ 之间有数位和为 $s$ 的数就减少右边界，否则增加左边界即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int l,r,s,cnt,dig[20],dp[20][150],qwq[20][150];
int dfs(int pos,int sum,int lead,int limit)
{
	if(pos==0&&sum==s)
	{
		return 1;
	}
	if(sum+pos*9<s)
	{
		return 0;
	}
	if(!lead&&!limit&&dp[pos][sum]!=-1)
	{
		return dp[pos][sum];
	}
	int ans=0,up=limit?dig[pos]:9;
	for(int i=0;i<=up;i++)
	{
		if(sum+i>s)
		{
			break;
		}
		ans+=dfs(pos-1,sum+i,lead&&(i==0),(limit&&i==up));
	}
	if(!limit&&!lead)
	{
		dp[pos][sum]=ans;
	}
	return ans;
}
int calc(int x)
{
	memset(dp,-1,sizeof(dp));
	cnt=0;
	while(x)
	{
		dig[++cnt]=x%10;
		x/=10;
	}
	return dfs(cnt,0,1,1);
}
int now[20],tot;
signed main()
{
	cin>>l>>r>>s;
	int ans=calc(l-1);
	cout<<(calc(r)-ans)<<"\n";
	int nl=l,nr=r,rans;
	while(nl<=nr)
	{
		int mid=(nl+nr)>>1;
		if(calc(mid)-ans)
		{
			nr=mid-1;
			rans=mid;
		}
		else
		{
			nl=mid+1;
		}
	}
	cout<<rans;
}
```

---

## 作者：__Ginka__ (赞：0)

## 数位 DP 统计符合条件的数

### 状态定义

递归函数 dfs 表示处理到第 pos 位时：

- sum：已选数字之和。
- ld：是否为前导零状态（避免前导零影响和的计算）。
- li：当前位是否被原数对应位限制。

### 边界条件和转移

当 $pos=0$ 时，检查 sum 是否等于目标值。若成立返回 $1$，否则返回 $0$。

根据 li 确定当前位的上限 up：

1. 若 $li=1$，$up=d_{pos}$（原数当前位的值）。
2. 否则，$up=9$。

遍历当前位可能的值 $i\in[0,up]$：

1. 若 $sum+i>S$，跳过后续更大的 $i$（剪枝）。
2. 递归计算下一位状态：

更新 sum 为 $sum+i$。

更新 ld：若 $ld=1$ 且 $i=0$，保持前导零状态；否则退出前导零状态。

更新 li：若当前 $i=up$，则下一位继续受限；否则解除限制。

### 记忆化剪枝

仅当 $ld=0$ 且 $li=0$ 时，结果可复用（此时状态与具体数无关）。

### 剪枝条件

若剩余位数全取最大也无法满足要求，直接返回。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long l,r,s,c,d[22],f[22][155],a1,a2,nl,nr,rans;
long long dfs(long long pos,long long sum,long long ld,long long li)
{
    if(pos==0)
    {
        //处理完所有位，检查sum是否等于s
        if(sum==s) return 1;
        else  return 0;
    }
    //剪枝：剩余位全取9也无法达到s，直接返回0
    if(sum+pos*9<s) return 0;
    if(!ld&&!li&&f[pos][sum]!=-1) return f[pos][sum];
    //计算当前位的上限
    long long up;
    if(li) up=d[pos];
    else up=9;
    long long ans=0;
    for(long long i=0;i<=up;i++)
    {
        if(sum+i>s) break;//当前和超过s，后续更大i无需处理
        //递归处理下一位，更新ld和li状态
        ans+=dfs(pos-1,sum+i,ld&&(i==0),li&&(i==up));
    }
    //保存记忆化结果
    if(!ld&&!li) f[pos][sum]=ans;
    return ans;
}
long long calc(long long x)
{
    memset(f,-1,sizeof(f));
    c=0;
    //分解x到数组d，低位在前
    while(x)
    {
        d[++c]=x%10;
        x/=10;
    }
    if(c==0) d[++c]=0;//处理x=0的情况
    return dfs(c,0,1,1);//从最高位开始搜索
}
int main()
{
    cin>>l>>r>>s;
    a1=calc(l-1);//计算[0,l-1]中的数目
    a2=calc(r);//计算[0,r]中的数目
    cout<<a2-a1<<"\n"; // 输出区间内的数目
    //二分查找最小的
    nl=l;
    nr=r;
    rans=r;//初始化答案为r
    while(nl<=nr)
    {
        long long mid=(nl+nr)/2;
        long long tmp=calc(mid)-a1;//mid是否在区间内
        if (tmp>0)
        {
            //存在解，尝试更小的mid
            rans=mid;
            nr=mid-1;
        }
        else nl=mid+1;//无解,增大mid
    }
    cout<<rans;
    return 0;
}
```

---

## 作者：junee (赞：0)

# P6356 [COCI2007-2008#3] CUDAK 题解

## 前置知识

数位 dp。

## 题目分析

首先很容易看出是数位 dp。

我们记 $f_{i,j}$ 表示考虑到第 $i$ 位，和为 $j$ 的合法方案数，然后用记忆化搜索做一下就可以了。

考虑怎么做第二问，发现这个方案数具有单调性，二分一下即可。

## Code

```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<random>
#include<chrono>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
typedef long long LL;
const int N=20,M=200;
LL A,B,S;
int a[N],tt;
LL f[N][M];//f_{i,j} 表示考虑到第 i 为，当前合为 j 的方案数 
LL dp(int len,int s,int lim,int zer){
	if(!len)return (s==S)&&!zer;
	if(f[len][s]!=-1&&!lim&&!zer)return f[len][s];
	LL res=0;
	for(int i=0;i<=((lim)?a[len]:9);i++){
		res+=dp(len-1,s+i,lim&&i==a[len],zer&&(i==0));
	}
	if(!lim&&!zer)f[len][s]=res;
	return res;
} 
LL get(LL x){
	memset(f,-1,sizeof f);
	tt=0;
	while(x){
		a[++tt]=x%10;
		x/=10;
	}
	return dp(tt,0,1,1);
}
LL get_ans(LL l,LL r){
	return get(r)-get(l-1);
}
bool check(LL l,LL r){
	return get_ans(l,r)>=1;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>A>>B>>S;
	cout<<get_ans(A,B)<<'\n';
	LL l=A,r=B;
	while(l<r){
		LL mid=(l+r)>>1;
		if(check(A,mid))r=mid;
		else l=mid+1;
	}
	cout<<l;

	return 0;
}
```

---

## 作者：Slient_QwQ (赞：0)

## Main Meaning

求出 $\left [A, B \right]$ 之间有几个数它的数码之和为 $S$，并求出第一个满足该条件的数。

## Solution

观察到 $1 \le A,B \le 10 ^ {15}$，同时 $S$ 较小，那么很容易想到数位 dp。
设 $f_{i, j}$ 为前 $i$ 位数码之和为 $j$ 的情况数，那有一个极其好想的转移方程，这里就不写了。

设 $g(x)$ 为 $\left [1, x \right]$ 之间有几个数满足数码之和为 $S$，第一问答案明显为 $g(B) - g(A - 1)$。

现在考虑第二问。

明显有一个结论，设第一个满足该条件的数为 $X$, 则 $g(X) = g(A - 1) + 1$。
问题就转化成找到第一个大于 $g(A - 1)$ 的位置。明显是一个二分。

于是这题就结束了，[Code](https://www.luogu.com.cn/paste/05ydyoen)。

---

## 作者：Autream (赞：0)

#### 题意简述
给定闭区间 $[a,b]$，以及一个整数 $s$，求区间 $[a,b]$ 中有多少个数的各数位之和为 $s$ 和最小的满足条件的数。

---
#### 题目分析
这道题看起来和[[入门赛 #21] 星云 hard ver.](https://www.luogu.com.cn/problem/P1708)有点像，所以我们考虑使用数位 DP。

设 $dp_{step,sum}$ 表示当前枚举到第 $step$ 位，数位之和为 $sum$ 的满足条件的数的个数，因为 $step \leq 15,sum \leq 135$，所以考虑记忆化搜索。

第一个问~~很水~~，就是模板，接下来考虑第二个问。~~（其实也很水）~~

直接枚举肯定不可能。因为求的数一定在 $[a,b$] 之间，而这个区间内的数满足单调性，所以可以二分查找，找到最小值。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=20;
int a,b,s,num[N],dp[N][150];
int dfs(int step,int sum,int st,int limit) {
    if(step>num[0]) {
        if(sum==s) {
            return 1;
        } else {
            return 0;
        }
    }
    if(!st&&!limit&&dp[step][sum]!=-1) {
        return dp[step][sum];
    }
    int up=limit?num[num[0]-step+1]:9;
    int ans=0;
    rep(i,0,up) {
        if(sum+i>s) {
            break;
        }
        ans+=dfs(step+1,sum+i,st&&i==0,limit&&i==up);
    }
    if(!st&&!limit) {
        dp[step][sum]=ans;
    }
    return ans;
}
int solve(int x) {
    num[0]=0;
    while(x) {
        num[++num[0]]=x%10;
        x/=10;
    }
    mem(dp,-1);
    return dfs(1,0,1,1);
}
signed main() {
    std::cin>>a>>b>>s;
    std::cout<<solve(b)-solve(a-1)<<"\n";
    int l=a,r=b,ans=0;
    while(l<=r) {
        int mid=(l+r)>>1;
        if(solve(mid)-solve(a-1)>0) {
            r=mid-1;
            ans=mid;
        } else {
            l=mid+1;
        }
    }
    std::cout<<ans;
    return 0;
}
```

---

## 作者：djh0314 (赞：0)

~~水道简单题的题解~~。

[**传送门**](https://www.luogu.com.cn/problem/P6356)。

## 分析
首先从数据范围出发 $1\le A,B\le 10^{15}$，并且提问方式 $\left [ A,B \right ] $ 可以发现，这就是一道数位 dp 的题目。

接着看数位 dp 的满足条件，和一定，那就更加确信是一道数位 dp 了。

至于第二问，我们可以通过二分答案来解决，答案是最早的到 $A$ 中和为 $S$ 的点。

~~~cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 5e2+5;
int n, m,sum,L,R;
int f[N][N],num[N];
inline int dfs(int now,int tot,int flag) {
	if(!flag&&~f[now][tot]) return f[now][tot];
	if(tot>sum) return 0;
	if(now==0) return tot==sum;
	int res=0,up=flag?num[now]:9;
	for(int i=0;i<=up;++i) res+=dfs(now-1,tot+i,flag&&(i==num[now]));
	if(!flag) f[now][tot]=res;
	return res;
}

inline int query(int x) {
	int cnt=0;
	while(x) {
		num[++cnt]=x%10;
		x/=10;
	}
	return dfs(cnt,0,1);
}

signed main() {
	cin>>L>>R>>sum;
	memset(f,-1,sizeof f);
	cout<<query(R)-query(L-1)<<"\n";
	int l=L,r=R,res=0,x=query(L-1);
	while(l<=r) {
		int mid=l+r>>1;
		if(query(mid)==x) l=mid+1;
		else r=mid-1,res=mid;
	}
	cout<<res<<"\n";
	return 0;
}
~~~

---


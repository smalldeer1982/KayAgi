# [COCI 2007/2008 #3] REDOKS

## 题目描述

给定一串长度为 $n$ 的数字，数字为 $0\sim 9$ 之间的任意一个，下标从 $1$ 记起。

然后进行 $m$ 次区间查询，每次查找区间 $[A,B]$ 的区间和，并在查询结束后将区间里的每一个数都 $+1$。特殊地，如果 $+1$ 前的数字为 $9$，那么 $+1$ 之后就变成了 $0$。

请输出每次查询的区间和。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 2.5\times 10^5$，$1\le m\le 10^5$，$1\le A,B\le n$。
#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T6 REDOKS***。

## 样例 #1

### 输入

```
4 3
1234
1 4
1 4
1 4```

### 输出

```
10
14
18```

## 样例 #2

### 输入

```
4 4
1234
1 1
1 2
1 3
1 4```

### 输出

```
1
4
9
16```

## 样例 #3

### 输入

```
7 5
9081337
1 3
3 7
1 3
3 7
1 3```

### 输出

```
17
23
1
19
5```

# 题解

## 作者：ycy1124 (赞：3)

### 题意
有一个长度为 $n$ 的数，现在有 $m$ 次询问，每次询问这个数第 $l\sim r$ 位上的各位数字之和。每次询问后 $l\sim r$ 之间的数位上的每个数位增加一，$9$ 增加一变成 $0$。
### 思路
我们发现这个问题可以转换为区间查询和区间修改的问题，于是我们可以用线段树来解决。

首先我们记录每个区间内 $0\sim 9$ 分别出现的次数，每次询问时给区间打上懒标记，除了 `Push_down` 操作，其余基本与普通线段树相同。对于转换，由于我们可能需要一次进行多次转换，转换方式为转换后的数字等于转换前的数字加上转换次数在模 $10$。
### 代码
```cpp
#include<bits/stdc++.h>
#define N 250000
using namespace std;
struct Node{
    int l,r,bj ,w[10];
}a[8*N];
int n,m;
string s;
inline void Push_down(int p){
    int w[10];
    for(int i=0;i<=9;i++){
        w[(i+a[p].bj)%10]=a[p].w[i];
    }
    for(int i=0;i<=9;i++){
        a[p].w[i]=w[i];
    }
    if(a[p].l!=a[p].r){
        a[2*p].bj+=a[p].bj;
        a[2*p+1].bj+=a[p].bj;
    }
    a[p].bj=0;
}
inline void Push_up(int p){
    if(a[p].l==a[p].r){
        if(a[p].bj){
            Push_down(p);
        }
        return;
    }
    if(a[p*2].bj){
        Push_down(p*2);
    }
    if(a[p*2+1].bj){
        Push_down(p*2+1);
    }
    for(int i=0;i<=9;i++){
        a[p].w[i]=a[p*2].w[i]+a[p*2+1].w[i];
    }
}
inline void New_Tree(int p,int l,int r){
    a[p].l=l,a[p].r=r;
    if(l==r){
        a[p].w[s[l]-'0']++;
        return;
    }
    int mid=(l+r>>1);
    New_Tree(p*2,l,mid);
    New_Tree(p*2+1,mid+1,r);
    Push_up(p);
}
inline int sum(int p){
    int w=0;
    for(int i=1;i<=9;i++){
        w+=a[p].w[i]*i;
    }
    return w;
}
inline int find(int p,int l,int r){
    if(a[p].bj){
        Push_down(p);
    }
    if(l<=a[p].l&&r>=a[p].r){
        a[p].bj++;
        int x=sum(p);
        Push_down(p);
        return x;
    }
    int mid=(a[p].l+a[p].r>>1);
    int x;
    if(mid<l){
        x=find(p*2+1,l,r);
    }
    else if(mid>=r){
        x=find(p*2,l,r);
    }
    else{
        x=find(p*2,l,mid)+find(p*2+1,mid+1,r);
    }
    Push_up(p);
    return x;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    cin>>s;
    s=' '+s;
    New_Tree(1,1,n);
    for(int i=1;i<=m;i++){
        int l,r;
        cin>>l>>r;
        cout<<find(1,l,r)<<'\n';
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/197593421)

---

## 作者：mlvx (赞：3)

### 题意

给你一个序列，每次查询区间和，随后对区间每个元素加一并对十取模。

### 分析

只有十个数字，在线段树每个节点上维护每个数码出现次数即可。

加法就像平常普通的线段树一样，打个懒惰标记，并对数码出现次数进行修改，$0$ 的个数变成本来 $9$ 的个数，$1$ 的个数变成本来 $0$ 的个数，$2$ 的个数变成本来 $1$ 的个数，等等。

计算和的时候就直接把 $0$ 的个数乘 $0$，$1$ 的个数乘 $1$，等等。

就是直接拿个数乘以权值，最后求和即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pl (p<<1)
#define pr (p<<1|1)
const int N=2.5e5+10;
int n,q,x[10],a[N],add[N<<2],num[N<<2][10];char c;
void push_up(int p){for(int i=0;i<10;i++)num[p][i]=num[pl][i]+num[pr][i];}
void upd(int p,int k){
	if(k){
		memcpy(x,num[p],sizeof x);
		for(int i=0;i<10;i++)num[p][(i+k)%10]=x[i];
	}
}void push_down(int p){if(add[p])add[pl]+=add[p],upd(pl,add[p]),add[pr]+=add[p],upd(pr,add[p]),add[p]=0;}
void update(int l,int r,int le,int ri,int p){
	if(l>=le&&r<=ri)return ++add[p],upd(p,1);
	int mid=l+r>>1;push_down(p);
	if(le<=mid)update(l,mid,le,ri,pl);
	if(ri>mid)update(mid+1,r,le,ri,pr);
	push_up(p);
}int query(int l,int r,int le,int ri,int p){
	if(l>=le&&r<=ri){
		int ret=0;
		for(int i=1;i<10;i++)ret+=num[p][i]*i;
		return ret;
	}int mid=l+r>>1,ret=0;push_down(p);
	if(le<=mid)ret+=query(l,mid,le,ri,pl);
	if(ri>mid)ret+=query(mid+1,r,le,ri,pr);
	return ret;
}void build(int l,int r,int p){
	if(l==r)return num[p][a[l]]=1,void();
	int mid=l+r>>1;
	build(l,mid,pl),build(mid+1,r,pr),push_up(p);
}int main(){
	cin>>n>>q;
	for(int i=1;i<=n;i++)cin>>c,a[i]=c-'0';
	build(1,n,1);
	for(int l,r;q--;)cin>>l>>r,cout<<query(1,n,l,r,1)<<'\n',update(1,n,l,r,1);
	return 0;
}
```

---

## 作者：liaoxingrui (赞：3)

## Content

给你一个 $n$ 和一个 $m$。以及一个长度为 $n$ 的数字字符（每个字符之间没有空格）和两个数 $l$，$r$。

求 $l$ 到 $r$ 的区间和，每求一次就将 $l$ 到 $r$ 的数加 $1$。

注意：

如果是 $9$ 加上 $1$，就会变为 $0$。

## Solution

这道题主要是对 $9$ 加上 $1$ 的情况进行处理，其它就与线段树模板基本一样，对于暴力求一个块，我们可以判断值是否为 $9$。

而对于一个完整的块，我们可以把这个块每个数字的个数求出来，然后这个块的值就会加上这个块的长度，在减去 $9$ 的个数，每次算完后，要将每个数的个数进行调整，便可以快速解决。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5e4+5;
int n,m,l,r,size;
/*
n，m，l，r 很好理解。
size 是每一块的长。 
*/ 
int a[N],b[N],id[N],tot[505][10],cnt[505];
/*
a 是读入的值。
b 后面再讲。 
id 是指 i 在第几块。
tot 是指第 i 块中 j 的个数。 
*/ 
char c;
//读入。 
inline void update(int l,int r){
	int x=id[l],y=id[r],val;
	if(x==y){
	//同一块内，暴力求。 
		for(int i=l;i<=r;i++){
			val=(a[i]+b[x])%10;
			if(val==9){
				a[i]-=9;
				/*
				注意：
				不能等于 0，因为可能 a[i] 不为 9。 
				*/ 
				cnt[x]-=9; 
				tot[x][9]--;
				tot[x][0]++;
			}
			else{
				a[i]++;
				cnt[x]++;
				tot[x][val]--;
				tot[x][val+1]++;
			}
		}
		return;
	}
	for(int i=l;id[i]==x;i++){
	//前一块暴力求。 
		val=(a[i]+b[x])%10;
		if(val==9){
			a[i]-=9;
			cnt[x]-=9; 
			tot[x][9]--;
			tot[x][0]++;
		}
		else{
			a[i]++;
			cnt[x]++;
			tot[x][val]--;
			tot[x][val+1]++;
		}
	}
	for(int i=x+1;i<y;i++){
		val=tot[i][9];
		//记录一下，要把循环交换。 
		b[i]++;
		/*
		由于这是一整块，不可能一个一个加。
		就只能先用 b 数组存加的数，要用时再加上。 
		*/ 
		cnt[i]+=size;
		/*
		整块都要加 1，也就是加上 size。
		不用担心最后一块，长度可能不相等。
		因为最后一块每次都会单独跑。 
		*/ 
		for(int j=9;j>=1;j--)
			tot[i][j]=tot[i][j-1];
		tot[i][0]=val;
		cnt[i]-=val*10;
		//前面把所有的都加了，要减 10 而不是 9。 
	}
	for(int i=r;id[i]==y;i--){
	//后一块暴力求。 
		val=(a[i]+b[y])%10;
		if(val==9){
			a[i]-=9;
			cnt[y]-=9; 
			tot[y][9]--;
			tot[y][0]++;
		}
		else{
			a[i]++;
			cnt[y]++;
			tot[y][val]--;
			tot[y][val+1]++;
		}
	}
}
inline int query(int l,int r){
	int x=id[l],y=id[r],ans=0;
	if(x==y){
	//同一块内，暴力求。 
		for(int i=l;i<=r;i++)
			ans+=(a[i]+b[x])%10;
		return ans;
	}
	for(int i=l;id[i]==x;i++)
	//前一块暴力求。 
		ans+=(a[i]+b[x])%10;
	for(int i=x+1;i<y;i++)
		ans+=cnt[i];
	for(int i=r;id[i]==y;i--)
	//后一块暴力求。 
		ans+=(a[i]+b[y])%10;
	return ans;
}
signed main(){
	cin>>n>>m;
	size=sqrt(n);
	for(int i=1;i<=n;i++){
		cin>>c;
		a[i]=(c^48);
		id[i]=(i-1)/size+1;
		cnt[id[i]]+=a[i];
		tot[id[i]][a[i]]++;
	}
	while(m--){
		cin>>l>>r;
		cout<<query(l,r)<<endl;
		update(l,r);
	}
	return 0;
}
```

---

## 作者：lzh0220 (赞：0)

## 思路

题解区里基本上都是线段树做法，那我来说一下分块。

首先我们需要维护每个块内 $0$ 到 $9$ 分别出现的次数。对于每个块，维护一个类似懒标记的东西，记录这个整块 $+1$ 的次数。

查询时直接暴力修改散块，对于整块打上懒标记，求出答案即可。

时间复杂度 $O(n\sqrt n)$，实测跑的飞快。

## code


```cpp
const int N=250010,M=510;
int bl[N],sum[M][10],t[M],a[N],to[10][10];
signed main(){
	for(int i=0;i<=9;i++)for(int j=0;j<=9;j++)to[i][j]=(i+j)%10;
	int n=read(),m=read(),len=sqrt(n);
	for(int i=1;i<=n;i++){
		bl[i]=(i-1)/len+1;
		a[i]=getch()-'0';
		sum[bl[i]][a[i]]++;
	}
	while(m--){
		int l=read(),r=read();
		if(t[bl[l]]){
			for(int i=0;i<=9;i++)sum[bl[l]][i]=0;
			for(int i=bl[l]*len-len+1;i<=bl[l]*len;i++){
				a[i]=to[a[i]][t[bl[l]]];
				sum[bl[l]][a[i]]++;
			}t[bl[l]]=0;
		}
		if(t[bl[r]]){
			for(int i=0;i<=9;i++)sum[bl[r]][i]=0;
			for(int i=bl[r]*len-len+1;i<=bl[r]*len;i++){
				a[i]=to[a[i]][t[bl[r]]];
				sum[bl[r]][a[i]]++;
			}t[bl[r]]=0;
		}int ans=0;
		if(bl[l]==bl[r]){
			for(int i=l;i<=r;i++)ans+=a[i];
			printf("%lld\n",ans);
			for(int i=l;i<=r;i++){
				sum[bl[i]][a[i]]--;
				a[i]=to[a[i]][1];
				sum[bl[i]][a[i]]++;
			}continue;
		}
		for(int i=l;i<=bl[l]*len;i++)ans+=a[i];
		for(int i=bl[r]*len-len+1;i<=r;i++)ans+=a[i];
		for(int i=l;i<=bl[l]*len;i++){
			sum[bl[i]][a[i]]--;
			a[i]=to[a[i]][1];
			sum[bl[i]][a[i]]++;
		}
		for(int i=bl[r]*len-len+1;i<=r;i++){
			sum[bl[i]][a[i]]--;
			a[i]=to[a[i]][1];
			sum[bl[i]][a[i]]++;
		}
		for(int i=bl[l]+1;i<=bl[r]-1;i++){
			for(int j=0;j<=9;j++)ans+=to[j][t[i]]*sum[i][j];
			t[i]=to[t[i]][1];
		}printf("%lld\n",ans);
	}
	ret 0;
}
```

---

## 作者：Soh_paramEEMS (赞：0)

## 题意

给定一串长度为 $n$ 的数字，数字为 $0\sim 9$ 之间的任意一个，下标从 $1$ 记起。

然后进行 $m$ 次区间查询，每次查找区间 $[A,B]$ 的区间和，并在查询结束后将区间里的每一个数都 $+1$。特殊地，如果 $+1$ 前的数字为 $9$，那么 $+1$ 之后就变成了 $0$。

请输出每次查询的区间和。

## 思路
前面做过那么多势能线段树，肯定想要用势能线段树来做。然而发现这是一个区间修改（区间加），那 pushdown 要怎么办呢？如果要写 pushdown 就很难搞最大值，而且修改次数就是 $m$ 次，$m$ 次都可能干上最大值 $10$ ；如果不写 pushdown，等着我们的就是 T 飞！

但是我们发现，数字出现的范围是 $0\sim 9$，非常少，用一个桶来维护绰绰有余。

于是我们考虑维护区间中 $0\sim 9$ 分别有多少个的桶 $cnt$ 数组就好了。引入懒标记 $tag$ 表示修改次数，每次修改操作把该区间的 $tag+1$ ，做一次修改即可。

对于 $u$ 区间的修改，要进行 $k$ 次修改，集成为一个函数：每次先把原来桶复制一份到 $tem$ 数组，然后把按照$0\sim 9$的顺序顺次加 $k$ 模 $10$ 进行移位操作。
$$cnt_{(i+k) \bmod 10}\leftarrow tem_i,\ i\in[0,9]$$

```cpp
void modi(ll u,ll k)
{
	if(k==0)return;
	for(int i=0;i<P;i++)
	tem[i]=T[u].cnt[i],T[u].cnt[i]=0;
	for(int i=0;i<P;i++)
	T[u].cnt[(i+k)%P]=tem[i];
}
```
那么其他就是线段树的基本操作了。建树时每个数位上的数，桶置为 $1$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
#define ls u<<1
#define rs u<<1|1
const ll N=2.5e5+2,M=1e6+9,P=10;
ll n,m,a[N],tem[P+1];
char c[N];
struct SegT
{
	struct node
	{
		ll cnt[12],tag;
	}T[N<<4];
	void modi(ll u,ll k)
	{
		if(k==0)return;
		for(int i=0;i<P;i++)
		tem[i]=T[u].cnt[i],T[u].cnt[i]=0;
		for(int i=0;i<P;i++)
		T[u].cnt[(i+k)%P]=tem[i];
	}
	void pushup(ll u)
	{
		for(int i=0;i<=9;i++)
		T[u].cnt[i]=T[ls].cnt[i]+T[rs].cnt[i]; 
	}
	void pushdown(ll u)
	{
		if(T[u].tag)
		{
			T[ls].tag+=T[u].tag;
			modi(ls,T[u].tag);
			T[rs].tag+=T[u].tag;
			modi(rs,T[u].tag);
			T[u].tag=0;
		}
	}
	void build(ll u,ll l,ll r)
	{
		if(l==r)
		{
			T[u].cnt[a[l]]=1;
			return;
		}
		ll mid=(l+r)>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(u);
	}
	void modify(ll u,ll l,ll r,ll ql,ll qr)
	{
		if(qr<l||r<ql)return;
		if(ql<=l&&r<=qr)
		{
			T[u].tag++;
			modi(u,1);
			return;
		}
		ll mid=(l+r)>>1;
		pushdown(u);
		if(ql<=mid)modify(ls,l,mid,ql,qr);
		if(qr>mid)modify(rs,mid+1,r,ql,qr);
		pushup(u);
	}
	ll query(ll u,ll l,ll r,ll ql,ll qr)
	{
		if(qr<l||r<ql)return 0;
		if(ql<=l&&r<=qr)
		{
			ll ret=0;
			for(int i=0;i<=9;i++)
			ret+=T[u].cnt[i]*i;
			return ret;
		}
		ll mid=(l+r)>>1,ret=0;
		pushdown(u);
		if(ql<=mid)ret+=query(ls,l,mid,ql,qr);
		if(qr>mid)ret+=query(rs,mid+1,r,ql,qr);
		return ret;
	}
}A;
int main()
{
	scanf("%d%d%s",&n,&m,c+1);
	for(int i=1;i<=n;i++)
	a[i]=c[i]-'0';
	A.build(1,1,n);
	while(m--)
	{
		ll l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",A.query(1,1,n,l,r));
		A.modify(1,1,n,l,r);
	}
	return 0;
}
```

---

## 作者：zzy0618 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P6357)

### 大体思路

首先看维护区间查询，区间修改，应该想到线段树或分块。

然后考虑维护什么。首先区间和是必须的，为了方便修改，还需要统计区间内所有数字的个数。这会带来不小的常数，所以不建议使用分块。

设 $cnt_{p,i}$ 为 $p$ 子树内数字 $i$ 的个数，设我们加了 $k$ 次 $1$，那么 $cnt_{p,i}$ 就等于 $cnt_{p,(i-k)\bmod 10}$。

### 完整代码

```cpp
#include<bits/stdc++.h>
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define mid (l+r>>1)
using namespace std;
const int N=2.5e5+5;
int n,m;string a;
int tag[N<<2],ans[N<<2],st[N<<2][11];
inline void push_up(int p){
	ans[p]=ans[ls(p)]+ans[rs(p)];
	for(int i=0;i<=9;++i)
		st[p][i]=st[ls(p)][i]+st[rs(p)][i];
}
inline void make_tag(int p,int k){
	int num[11];ans[p]=0;
	for(int i=0;i<=9;++i)
		num[i]=st[p][i];
	for(int i=0;i<=9;++i)
		ans[p]+=i*(st[p][i]=num[((i-k)%10+10)%10]);
	tag[p]+=k;
}
inline void push_down(int p){
	make_tag(ls(p),tag[p]);
	make_tag(rs(p),tag[p]);
	tag[p]=0;
}
inline void build(int p,int l,int r){
	if(l==r){st[p][ans[p]=a[l]-'0']=1;return;}
	build(ls(p),l,mid),build(rs(p),mid+1,r);
	push_up(p);
}
inline int solve(int p,int l,int r,int L,int R){
	if(L<=l&&r<=R){
		int lans=ans[p];
		make_tag(p,1);
		return lans;
	}push_down(p);
	int sum=0;
	if(L<=mid)sum+=solve(ls(p),l,mid,L,R);
	if(mid<R)sum+=solve(rs(p),mid+1,r,L,R);
	push_up(p);
	return sum;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m>>a;a=" "+a;
    build(1,1,n);int l,r;
    while(m--)
    	cin>>l>>r,cout<<solve(1,1,n,l,r)<<'\n';
    return 0;
}
```

---

## 作者：huangrenheluogu (赞：0)

### 前言

感觉是一道比较重要的板子，对于一些范围比较小的，可以求数的种类。

### Solution

线段树显然。

记录每个节点 $p$ 对应的区间中，数字 $x$ 有 $t_{p,x}$ 个，总和为 $sum_p$。

但是，懒标记怎么办?

开始我想用 $tag_{p,x}$ 表示 $p$ 节点 $x$ 个数增加多少，但是有一个非常严重的问题，不能转移。

考虑换一种记录懒标记的方式。

考虑懒标记的定义，左子树和右子树都进行的操作，所以，不难想到用 $tag_p$ 表示 $p$ 子树中所有的数向右移动多少位。

然后就可以下传了。

```cpp
inline void f(int p, int k){
	for(int i = 0; i <= 9; i++) tem[(i + k) % 10] = t[p][i];
	for(int i = 0; i <= 9; i++){
		sum[p] += (tem[i] - t[p][i]) * i;
		t[p][i] = tem[i];
	}
}
inline void push_down(int p){
	f(ls, tag[p]);
	f(rs, tag[p]);
	tag[ls] += tag[p];
	tag[rs] += tag[p];
	tag[p] = 0;
}
```

总结一下，发现本题需要想到两点：

- 分开每一种数存储，这个应该不难想，因为要 $9$ 变成 $0$。

- 下传懒标记。

下面是完整代码：

```cpp
#include<bits/stdc++.h>
#define ls p << 1
#define rs p << 1 | 1
using namespace std;
const int N = 250005;
int n, m, a[N], t[N << 2][10], tag[N << 2], sum[N << 2], tem[N], l, r;
char c;
inline void f(int p, int k){
	for(int i = 0; i <= 9; i++) tem[(i + k) % 10] = t[p][i];
	for(int i = 0; i <= 9; i++){
		sum[p] += (tem[i] - t[p][i]) * i;
		t[p][i] = tem[i];
	}
}
inline void push_up(int p){
	sum[p] = sum[ls] + sum[rs];
	for(int i = 0; i <= 9; i++) t[p][i] = t[ls][i] + t[rs][i];
}
inline void push_down(int p){
	f(ls, tag[p]);
	f(rs, tag[p]);
	tag[ls] += tag[p];
	tag[rs] += tag[p];
	tag[p] = 0;
}
inline void build(int p, int l, int r){
	if(l == r){
		t[p][a[l]] = 1;
		sum[p] = a[l];
		return ;
	}
	int mid = l + r >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	push_up(p);
}
inline void modify(int p, int l, int r, int x, int y){
	if(x <= l && r <= y){
		f(p, 1);
		tag[p]++;
		return ;
	}
	if(tag[p]) push_down(p);
	int mid = l + r >> 1;
	if(mid >= x) modify(ls, l, mid, x, y);
	if(mid < y) modify(rs, mid + 1, r, x, y);
	push_up(p);
}
inline int query(int p, int l, int r, int x, int y){
	if(x <= l && r <= y) return sum[p];
	int mid = l + r >> 1, res = 0;
	if(tag[p]) push_down(p);
	if(mid >= x) res += query(ls, l, mid, x, y);
	if(mid < y) res += query(rs, mid + 1, r, x, y);
	return res;
}
int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++){
		c = getchar();
		while(c < '0' || c > '9') c = getchar();
		a[i] = c - 48;
	}
	build(1, 1, n);
	while(m--){
		scanf("%d%d", &l, &r);
		printf("%d\n", query(1, 1, n, l, r));
		modify(1, 1, n, l, r);
	}
	return 0;
}
```

---

## 作者：我是人999 (赞：0)

## 题意
给定一个长度为 $n$ 的序列 $a$，有 $m$ 次操作，要求支持区间加 $1$（每个数字分别对 $10$ 取模），求区间和。

$1\le n\le 2.5\times 10^5,1\le m\le 10^5$
 
## 做法
观察到值域很小，所以我们可以思考和值域有关的做法。

对于询问区间和操作，因为值域很小，所以我们可以先枚举所有的数字，再求这个数字在区间内出现的次数，答案就是：

$$\sum\limits_{v=0}^{9}v\times\sum_{i=l}^{r}[a_i=v]$$

根据这个式子，使用数据结构维护每个数字在区间内出现的次数即可；

对于区间加 $1$ 操作，设 $a_i'= (a_i+1) \bmod 10$，可以发现区间内每个数字的出现次数发生了平移，即对于数字 $v$，它在修改之后的区间的出现次数与数字 $(v-1+10)\bmod 10$ 在修改之前的区间的出现次数相同：

$$\sum_{i=l}^r[a_i'=v]\gets\sum_{i=l}^r[a_i=(v-1+10)\bmod10]$$

相当于每个数字的出现次数向后平移了一位，这也是可以使用数据结构维护（暴力平移）的。

以平衡树为例：对于询问我们开 $10$ 棵平衡树维护序列；对于修改我们也使用平衡树提取出所有数字对应的区间，再进行平移即可。因为值域较小可以看成常数，时间复杂度为 $O(n\log n)$。这与其他题解使用的线段树等做法本质上是相同的。
## 代码
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
const int INF=19260817;
char s[250005];
struct Splay
{
	int val,cnt,size,fa,son[2];
	Splay(int v=0,int c=0,int s=0,int f=0):val(v),cnt(c),size(s),fa(f)
	{
		son[0]=son[1]=0;
	}
}t[2500005];
int root[10],tot;
void update(int p)
{
	t[p].size=t[t[p].son[0]].size+t[t[p].son[1]].size+t[p].cnt;
	return;
}
int create(int val,int f=0)
{
	t[++tot]=Splay(val,1,1,f);
	return tot;
}
void build(int i)
{
	root[i]=create(-INF);
	t[root[i]].son[1]=create(INF,root[i]);
	update(root[i]);
	return;
}
bool get(int p)
{
	return t[t[p].fa].son[1]==p;
}
void rotate(int p)
{
	int f=t[p].fa,gf=t[f].fa;
	bool id=get(p);
	if(gf)
	{
		t[gf].son[get(f)]=p;
	}
	t[p].fa=gf;
	t[f].son[id]=t[p].son[id^1];
	if(t[p].son[id^1])
	{
		t[t[p].son[id^1]].fa=f;
	}
	t[p].son[id^1]=f;
	t[f].fa=p;
	update(f);
	update(p);
	return;
}
void splay(int p,int id,int pos=0)
{
	for(int f=0;(f=t[p].fa)!=pos;rotate(p))
	{
		if(t[f].fa!=pos)
		{
			rotate(get(f)==get(p)?f:p);
		}
	}
	if(!pos)
	{
		root[id]=p;
	}
	return;
}
void insert(int val,int id)
{
	int p=root[id],f=0;
	while(true)
	{
		f=p;
		p=t[p].son[val>t[p].val];
		if(!p)
		{
			p=t[f].son[val>t[f].val]=create(val,f);
			update(f);
			splay(p,id);
			break;
		}
	}
	return;
}
int pre(int v,int id)
{
	int p=root[id],pos=id*2+1;
	while(p)
	{
		if(t[p].val<v)
		{
			if(t[p].val>t[pos].val)
			{
				pos=p;
			}
			p=t[p].son[1];
		}
		else
		{
			p=t[p].son[0];
		}
	}
	splay(pos,id);
	return pos;
}
int nxt(int v,int id)
{
	int p=root[id],pos=id*2+2;
	while(p)
	{
		if(t[p].val>v)
		{
			if(t[p].val<t[pos].val)
			{
				pos=p;
			}
			p=t[p].son[0];
		}
		else
		{
			p=t[p].son[1];
		}
	}
	splay(pos,id);
	return pos;
}
int query(int l,int r,int id)
{
	int x=pre(l,id),y=nxt(r,id);
	splay(x,id),splay(y,id,x);
	return t[root[id]].son[1];
}
int n,m,tmp[10],l,r;
int main()
{
	scanf("%d%d%s",&n,&m,s+1);
	for(int i=0;i<=9;i++)
	{
		build(i);
	}
	for(int i=1;i<=n;i++)
	{
		insert(i,s[i]-'0');
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&l,&r);
		int ans=0;
		for(int j=0;j<=9;j++)
		{
			tmp[j]=query(l,r,j);
			ans+=t[t[tmp[j]].son[0]].size*j;
		}
		int x=t[tmp[0]].son[0];
		for(int j=9;j>=1;j--)
		{
			t[tmp[(j+1)%10]].son[0]=t[tmp[j]].son[0];
			if(t[tmp[j]].son[0])
			{
				t[t[tmp[(j+1)%10]].son[0]].fa=tmp[(j+1)%10];
			}
		}
		t[(tmp[1])].son[0]=x;
		if(x)
		{
			t[t[tmp[1]].son[0]].fa=tmp[1];
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

[~~无耻的推销博客~~](https://www.cnblogs.com/LcyRegister/p/17007886.html)

### 题目描述

给定一串长度为 $n$ 的数字，数字为 $0 \sim 9$ 之间的任意一个，下标从 $1$ 记起。

然后进行 $m$ 次区间查询，每次查找区间 $[l, r]$ 的区间和，并在查询结束后将区间里的每一个数都 $ + 1$。特殊地，如果 $ + 1$ 前的数字为 $9$，那么 $ + 1$ 之后就变成了 $0$。

输出每次查询的区间和。

### 题目分析

使用支持区间加和区间求和的数据结构即可。在这里使用分块和线段树。

#### 分块

感觉跑的飞快。题解区似乎有兄弟卡不过去。

$9 + 1 \to 0$ 这个限制非常的难搞。然而我们发现一共只有十个数字，因此不管怎么暴力搞都是没问题的（大不了乘个大常数）。

在每个块内维护以下信息：当前块内 $1 \sim 9$ 每个数出现的次数（$cnt_i$），当前块的懒标记（$add$）。那么一个块内的区间和就是：

$$sum = \sum_{i \in [0, 9]} cnt_i \times [(i + add) \bmod 10]$$

代码示例如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

using LL = long long;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;

const int N = 250010, M = (int)sqrt(N) + 20;
const int INF = 0x3f3f3f3f;

int n, m, len, w[N];
struct Block {
	int l = INF, r = -INF, add;
	int cnt[10];
}b[M];

int get(int x) {
	return (int)x / len;
}

void change(int k, int &x) {
	b[k].cnt[x] -- ;
	b[k].cnt[(x + 1) % 10] ++ ;
	x = (x + 1) % 10;
}

void modify(int l, int r) {
	int lc = get(l), rc = get(r);
	if (lc == rc) {
		for (int i = l; i <= r; i ++ )
			change(lc, w[i]);
		return;
	}
	for (int i = l; i <= b[lc].r; i ++ ) change(lc, w[i]);
	for (int i = r; i >= b[rc].l; i -- ) change(rc, w[i]);
	for (int i = lc + 1; i <= rc - 1; i ++ )
		b[i].add = (b[i].add + 1) % 10;
}

int query_block(int k) {
	int ans = 0;
	for (int i = 0; i <= 9; i ++ )
		ans += b[k].cnt[i] * ((i + b[k].add) % 10);
	return ans;
}

int query(int l, int r) {
	int lc = get(l), rc = get(r);
	int ans = 0;
	if (lc == rc) {
		for (int i = l; i <= r; i ++ )
			ans += (w[i] + b[lc].add) % 10;
		return ans;
	}
	for (int i = l; i <= b[lc].r; i ++ ) ans += (w[i] + b[lc].add) % 10;
	for (int i = r; i >= b[rc].l; i -- ) ans += (w[i] + b[rc].add) % 10;
	for (int i = lc + 1; i <= rc - 1; i ++ )
		ans += query_block(i);
	return ans;
}

int main() {
	scanf("%d%d", &n, &m); len = (int)sqrt(n);
    for (int i = 1; i <= n; i ++ )
        scanf("%1d", &w[i]);
    for (int i = 1; i <= n; i ++ ) {
    	b[get(i)].l = min(b[get(i)].l, i);
    	b[get(i)].r = max(b[get(i)].r, i);
    	b[get(i)].cnt[w[i]] ++ ;
	}
	
	while (m -- ) {
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", query(l, r));
		modify(l, r);
	}
	
	return 0;
}
```

单次询问复杂度为 $O(\sqrt{n})$，空间复杂度 $O(\sqrt{n})$

#### 线段树

思路与分块相同，即在每一个节点维护每个数出现的次数。注意 `pushup` 和 `pushdown` 的处理。

单次询问复杂度 $O(\log n)$ 明显快于分块。空间复杂度 $O(n)$ 略劣。

代码示例如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

const int N = 250010;

int w[N], n, m;
struct Tree {
    int l, r;
    int sum, add;
    int cnt[10];
}tr[N << 2];
#define ls u << 1
#define rs u << 1 | 1

void pushup(int u) {
    tr[u].sum = tr[ls].sum + tr[rs].sum;
    for (int i = 0; i <= 9; i ++ )
        tr[u].cnt[i] = tr[ls].cnt[i] + tr[rs].cnt[i];
}

void push(int u, int k) { // 这里需要注意
	tr[u].add += k;
    while (k -- ) {
        for (int i = 9; i; i -- )
            swap(tr[u].cnt[i], tr[u].cnt[i - 1]);
    }
    tr[u].sum = 0;
    for (int i = 1; i <= 9; i ++ )
        tr[u].sum += tr[u].cnt[i] * i;
}

void pushdown(int u) {
    if (tr[u].add) {
        tr[u].add %= 10;
        push(ls, tr[u].add);
        push(rs, tr[u].add);
        tr[u].add = 0;
    }
}

void build(int u, int l, int r) {
    tr[u] = {l, r};
    if (l == r) {
        tr[u].sum = w[r];
        tr[u].cnt[w[r]] ++ ;
        return;
    }
    int mid = l + r >> 1;
    build(ls, l, mid), build(rs, mid + 1, r);
    pushup(u);
}

void modify(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)
        return (void)push(u, 1);
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) modify(ls, l, r);
    if (r > mid) modify(rs, l, r);
    pushup(u);
}

int query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)
        return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1, sum = 0;
    if (l <= mid) sum += query(ls, l, r);
    if (r > mid) sum += query(rs, l, r);
    return sum;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
	    scanf("%1d", &w[i]);
	
    build(1, 1, n);
    
    while (m -- ) {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", query(1, l, r));
        modify(1, l, r);
    }
    return 0;
}
```

---

## 作者：Galex (赞：0)

这题就是一个裸的 **区间修改 + 查询** ，所以很容易想到用数据结构去维护它。本来我写的是分块，数据范围是 $10 ^ 5$ ，按理说不会炸，但是莫名其妙 T 了，只好改码线段树，过了此题。

其实与板子唯一的不同就是 pushup 和 pushdown 函数，具体看程序实现就行了 ~~还是挺水的~~ 。

```cpp
#include <bits/stdc++.h>
#define ls (p << 1)
#define rs (p << 1 | 1)
using namespace std;

int n, m;
int a[250005];
int cnt[1000005][10];
int sum[1000005], tag[1000005];

void push_up(int p){//大家重点看这里
	sum[p] = sum[ls] + sum[rs];
	for (int i = 0; i < 10; i++)
		cnt[p][i] = cnt[ls][i] + cnt[rs][i];
}

void build(int l, int r, int p){
	if(l == r){
		sum[p] = a[l];
		cnt[p][a[l]]++;
		return;
	}
	int mid = (l + r) >> 1; 
	build(l, mid, ls), build(mid + 1, r, rs);
	push_up(p);
}

void updnode(int p, int k){//这里
	for (int j = 1; j <= k; j++){
		int k = cnt[p][9];
		for (int i = 9; i > 0; i--)
			cnt[p][i] = cnt[p][i - 1], sum[p] += cnt[p][i];
		cnt[p][0] = k, sum[p] -= 9 * k;
	}
}

void push_down(int p){//以及这里
	if (!tag[p])
		return ;
	tag[p] %= 10;
	updnode(ls, tag[p]), updnode(rs, tag[p]);
	tag[ls] += tag[p], tag[rs] += tag[p];
	tag[p] = 0;
}

int query(int l, int r, int p, int x, int y){
	if (x <= l && r <= y) 
		return sum[p];
	push_down(p);
	int mid = (l + r) >> 1, ans = 0;
	if (x <= mid)
		ans += query(l, mid, ls, x, y);
	if (mid < y)
		ans += query(mid + 1, r, rs, x, y);
	return ans;
}

void change(int l, int r, int p, int x, int y){
	if (x <= l && r <= y){
		tag[p] = (tag[p] + 1) % 10;
		updnode(p, 1);
		return ;
	}
	push_down(p);
	int mid = (l + r) >> 1;
	if (x <= mid)
		change(l, mid, ls, x, y);
	if (mid < y)
		change(mid + 1, r, rs, x, y);
	push_up(p);
}

int main(){
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		scanf("%1d", &a[i]);
	build(1, n, 1);
	for (int i = 1; i <= m; i++){
		int l, r;
		scanf("%d %d", &l, &r);
		printf("%d\n", query(1, n, 1, l, r));
		change(1, n, 1, l, r);
	}
	return 0;
}
```
再附上我的分块代码，有大佬知道为什么 T 的请私信我，感激不尽！

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
int a[250005];
int t;
int bl[250005];
int l[1000] = {0}, r[1000] = {0};
int sum[1000] = {0}, cnt[1000][10] = {0};

void build_block(){
	t = sqrt(n);
	for (int i = 1; i <= t; i++)
		l[i] = r[i - 1] + 1, r[i] = r[i - 1] + t;
	if (r[t] < n)
		l[++t] = r[t - 1] + 1, r[t] = n;
	for (int i = 1; i <= t; i++)
		for (int j = l[i]; j <= r[i]; j++)
			cnt[i][a[j]]++, sum[i] += a[j];
}

int qrydir(int x, int y){
	int ans = 0;
	for (int i = x; i <= y; i++)
		ans += a[i];
	return ans;	
}

int qry(int x, int y){
	int lz = bl[x], rz = bl[y];
	if (lz == rz)
		return qrydir(x, y);
	int ans = qrydir(x, r[lz]) + qrydir(l[rz], y);
	for (int i = lz + 1; i <= rz - 1; i++)
		ans += sum[i];
	return ans;
}

void adddir(int x, int y){
	int z = bl[x];
	for (int i = x; i <= y; i++){
		cnt[z][a[i]]--;
		a[i] = (a[i] + 1) % 10;
		cnt[z][a[i]]++;
		if (a[i] == 0)
			sum[z] -= 9;
		else
			sum[z]++;
	}
}

void addran(int z){
	int k = cnt[z][9];
	for (int i = 9; i > 0; i--)
		cnt[z][i] = cnt[z][i - 1], sum[z] += cnt[z][i];
	cnt[z][0] = k, sum[z] -= 9 * k;
}

void add(int x, int y){
	int lz = bl[x], rz = bl[y];
	if (lz == rz){
		adddir(x, y);
		return ;
	}
	adddir(x, r[lz]), adddir(l[rz], y);
	for (int i = lz + 1; i <= rz - 1; i++)
		addran(i);
}

signed main(){
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		scanf("%1d", &a[i]);
	build_block();
	for (int i = 1; i <= m; i++){
		int L, R;
		scanf("%d %d", &L, &R);
		printf("%d\n", qry(L, R));
		add(L, R);
	}
	return 0;
}
```


---

## 作者：JK_LOVER (赞：0)

## 题意
给你一个长度为 $n$ 的序列，要求查询一个区间的和在 $(\mod 10)$ 的意义下，也就是
$$
ans = \sum_{L\le i \le R} (val[i]\mod 10) 
$$
再对该序列进行区间 $+1$ 。

[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p6357)
## 分析
- 我们可以发现，如果直接维护每个位置上的值，那么这道题就是一个 $RMQ$ 问题，但是 $\mod 10$ 是不满足结合与交换率的。那么是没法直接维护 $val[i]$ 的。

- 可以发现其实 $val$ 可以取的值是非常小的。那么考虑维护每种 $val$ 有多少个。那么答案为
$$
ans = \sum_{1\le i\le 9} (sum[i] \times i)
$$
- 那么只要注意一下细节就行了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
const int inf = 100000000;
const int N = 2100010;
struct Tree{
	int c[12];
	int lazy;
}t[N];
int a[N];
void updown(int x)
{
	if(t[x].lazy)
	{
		int old[12];
		for(int i = 0;i <= 9;i++) old[i] = t[x<<1].c[i];
		for(int i = 0;i <= 9;i++) t[x<<1].c[i] = old[(i-t[x].lazy+inf)%10];
		for(int i = 0;i <= 9;i++) old[i] = t[x<<1|1].c[i];
		for(int i = 0;i <= 9;i++) t[x<<1|1].c[i] = old[(i-t[x].lazy+inf)%10];//有可能为负数。划重点 
		t[x<<1|1].lazy += t[x].lazy;
		t[x<<1].lazy += t[x].lazy;
		t[x].lazy = 0;
	}
}
int query(int x,int L,int R,int l,int r,int i)
{
	if(l <= L && R <= r) return t[x].c[i];
	if(L > r || R < l) return 0;
	updown(x);
	int mid = L+R>>1;
	return query(x<<1|1,mid+1,R,l,r,i)+query(x<<1,L,mid,l,r,i);
}
void add(int x,int L,int R,int l,int r,int d)
{
	if(l <= L && R <= r) 
	{
		t[x].lazy += d;
		int old[12];
		for(int i = 0;i <= 9;i++) old[i] = t[x].c[i];
		for(int i = 0;i <= 9;i++) t[x].c[i] = old[(i-d+inf)%10];
		return;
	}
	if(L > r || R < l) return;
	updown(x);
	int mid = L+R>>1;
	add(x<<1|1,mid+1,R,l,r,d);
	add(x<<1,L,mid,l,r,d);
	for(int i = 0;i <= 9;i++)
	t[x].c[i] = t[x<<1].c[i]+t[x<<1|1].c[i];
}
void build1(int x,int L,int R)
{
	if(L==R) {
		t[x].c[a[L]]++;
		return;
	}
	int mid = L+R>>1; 
	build1(x<<1,L,mid);build1(x<<1|1,mid+1,R);
	for(int i = 0;i <= 9;i++)
	t[x].c[i] = t[x<<1].c[i]+t[x<<1|1].c[i];
}
char ch[N];
int main()
{
	int n = read(),m = read();
	scanf("%s",ch+1);
	for(int i = 1;i <= n;i++)
	{
		a[i] = ch[i]-'0';
	}
	build1(1,1,n);
	while(m--)
	{
		int l=read(),r=read();
		int ans = 0;
		for(int i = 1;i <= 9;i++)
		ans = ans+(query(1,1,n,l,r,i)*i);
		printf("%d\n",ans);
		add(1,1,n,l,r,1);
	}
	return 0;
}
```





---

## 作者：_7thRC_CB_CRP_ (赞：0)

这道题非常的经典。

首先，我们知道我们肯定不可以直接去磨十来做。所以我们可以处理一个区间内 $[0,9]$ 分别的数量，用线段树来处理区间求值，和“将他们存的数量后移一位”。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int tag;
    int cnt[10];
}t[2000001];
void updata(int i) { 
	t[i*2].tag+=t[i].tag;
	t[i*2+1].tag+=t[i].tag;
	t[i*2].tag%=10;
	t[i*2+1].tag%=10;
	t[i].tag%=10;
    while(t[i].tag) {
        int r=t[i].cnt[9];
        for(int j=9;j>=1;j--)
            t[i].cnt[j]=t[i].cnt[j-1];
        t[i].cnt[0]=r;
        t[i].tag--;
    }
}
void make(int i,int l,int r,int x,int y) {
    updata(i);
    if(l==x&&r==y) {
        t[i].tag++; 
	    updata(i);
        return;
    }
    int mid=(l+r)>>1;
    if(x>=mid+1)
        make(i*2+1,mid+1,r,x,y);
    else
        if(y<=mid)
            make(i*2,l,mid,x,y);
        else
            make(i*2,l,mid,x,mid),make(i*2+1,mid+1,r,mid+1,y);
    updata(i*2);
    updata(i*2+1);
    for(int j=0;j<=9;j++)
        t[i].cnt[j]=t[i*2].cnt[j]+t[i*2+1].cnt[j];
}
int ans(int i,int l,int r,int x,int y) {
    updata(i);
    if(l==x&&r==y) {
        int sum=0;
        for(int j=0;j<=9;j++)
            sum+=j*t[i].cnt[j];
        return sum;
    }
    int mid=(l+r)>>1;
    if(x>=mid+1)
        return ans(i*2+1,mid+1,r,x,y);
    else
        if(y<=mid)
            return ans(i*2,l,mid,x,y);
        else
            return ans(i*2,l,mid,x,mid)+ans(i*2+1,mid+1,r,mid+1,y);
}
void build(int i,int l,int r) {
    t[i].cnt[0]=r-l+1;
    if(l==r)
        return;
    int mid=(l+r)>>1;
    build(i*2,l,mid);
    build(i*2+1,mid+1,r);
}
int main() {
    int n,m;
    cin>>n>>m;
    build(1,1,n);
    for(int i=1;i<=n;i++) {
        char c;
        cin>>c;
        int j=c-'0';
        while(j) {
            make(1,1,n,i,i),j--;
        }
    }
    while(m--) {
        int l,r;
        cin>>l>>r;
        cout<<ans(1,1,n,l,r)<<endl;
        make(1,1,n,l,r);
    }

}

```

---


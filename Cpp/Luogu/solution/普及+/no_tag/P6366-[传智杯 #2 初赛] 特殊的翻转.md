# [传智杯 #2 初赛] 特殊的翻转

## 题目描述

k 老师在研究一段病毒程序的代码。这段代码是由一段长度不超过 $10^6$ 的十六进制字符（也就是 `0` 到 `9` 和 `A` 到 `F`）组成的信息。现在 k 老师要将其转换为二进制的 0/1 串（这个时候需要确保最高位是 1）。然后对这个 0/1 串进行“翻转”操作。

对于每次“翻转”操作，k 老师可以选择这个 0/1 串中的其中一位，将这一位和这一位相邻的两位，一共三位，分别进行“翻转”（也就是 0 变 1，1 变 0）。如果指定的这一位是序列的开头或者结尾，那么翻转这一位和存在的相邻位即可。

k 老师想知道，如何用最少的“翻转”步骤，将这个 0/1 串变为全 0 的串。

## 说明/提示

样例解释：

十六进制的 15 对应二进制的 10101，翻转第 1/3/5 位，就可以全部变为 0。

十六进制的 FF 对应二进制的 11111111，翻转第 2/5/8 位，就可以全部变为 0。

十六进制的 10 对应二进制的 10000，无法全变为 0。


## 样例 #1

### 输入

```
15```

### 输出

```
3```

## 样例 #2

### 输入

```
FF```

### 输出

```
3```

## 样例 #3

### 输入

```
10```

### 输出

```
No```

# 题解

## 作者：离散小波变换° (赞：12)

## 题目大意

给出一个 $16$ 进制串，要求转换为一个 $01$ 串并去掉前导零。现在可以用翻转操作，每次能翻转一个数字和它旁边的两个数字。询问最少需要翻转多少次才能使这个 $01$ 串变成 $0$。

## 题解

将原串转换为 $01$ 串，首先需要将读入的每个十六进制字符转换成对应数字。也就是说，

$$F(c)=\begin{cases}c-\texttt{'0'} & (c\in\tt\{'1','2',\cdots '9'\})\cr c-\texttt{'A'}+10 & (c\in\tt\{'A','B',\cdots,'F'\})\end{cases}$$

然后只要分别对这个数字的二进制位进行判断即可完成转换。

下面就是对$01$串进行翻转。有一个比较显然的结论是，**一个字符最多反转 $\bf 1$ 次**。不然，如果翻转两次，相当于没有翻转。

考虑下面这个例子：

$$\texttt{\{0,1,0,1,1,0,1\}}$$

假设我们第一步翻转第一个字符。

$$\texttt{\{1,0,0,1,1,0,1\}}$$

这时，考虑第二个字符。我们发现，它**不得不**翻转。因为如果不反转，那么第一个字符就**无法**变为 $0$。

$$\texttt{\{0,1,1,1,1,0,1\}}$$

此时考虑第三个字符。同理，我们发现，我们**不得不**翻转它。

$$\texttt{\{0,0,0,0,1,0,1\}}$$

这时候，我们考虑第四个字符。我们却发现，我们**不能**翻转它。因为，一旦翻转，那么第三个字符就会变成 $1$，那么就无法挽回。同样地，第五个字符也无法翻转，它受到第 $4$ 个字符的制约。

我们按照上述方法处理第六个字符，发现最终变成了：

$$\texttt{\{0,0,0,0,0,1,0\}}$$

很不幸的是，无论我们是否翻转第七个字符，都无法使整个字符串变为 $0$。

从上述例子，我们发现，只要决定了第一个字符是否翻转，那么后面**每一个**字符是否翻转都已经确定了。于是，只需要枚举第一个字符的两种情况即可。

具体做法是，复制一遍处理后的字符串，然后翻转它的第一个字符，进行一遍模拟；同时，将不翻转第一个字符的原字符串按照同样操作模拟即可。最后答案取两种方案的最小值。如果不存在合法方案，输出 $\tt No$。

另外，其实这条题目可以在常数大小的空间开销内解决，也就是每读入一个字符，就进行相应操作。但由于本题空间限制比较大，因此没有必要。读者可以留作思考。~~其实是我懒~~。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;
const int INF =2147483647;
const int MAXN =1e6+3;
bool S[MAXN*4],T[MAXN*4]; int p,q,ans,t;
int calc(bool *s,int p){
    int ret=0;
    up(p+2,q+1,i){
        if(s[i-2]) s[i-2]^=1,s[i-1]^=1,s[i]^=1,++ret;
    }
    if(s[q]) return INF/2; return ret;
}
int main(){
    char c;
    while((c=getchar())!='\n'&&c!='\r'){
        if(c>='A'&&c<='F') t=c-'A'+10; else t=c-'0';
        S[q++]=t&8,S[q++]=t&4,S[q++]=t&2,S[q++]=t&1;
    }
    for(p=0;!S[p];++p); --q; memcpy(T,S,sizeof(S));
    ans=calc(S,p),T[p]^=1,T[p+1]^=1,ans=min(ans,calc(T,p)+1);
    if(ans>=INF/2) puts("No"); else printf("%d\n",ans);
    return 0;
}
```



---

## 作者：YuJieSong (赞：6)

这道题感觉和P2327扫雷神似

首先十六进制转二进制，头部去零，基本操作即可

重点就在于翻转操作

首先看二进制串第一位（必然是1），它需要翻转成0

这时有两种方法：翻转1-2位和翻转1-3位

翻转之后再继续找后面为1的位置，只能连续翻转3位

到了最后剩两位的时候

如果是10或者01，即不可行

是11则再翻转一次，是00则ok

两种方式都尝试一遍之后，取优解即可

不开O2单样例最高耗时50ms，稳稳的

~~一开始用string来翻转，然后TLE~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[4000005],b[4000005];

int main() {
    int i,x=0,p=0,q=0,n;
    string s;
    cin >> s;
    for (i=0; i<s.length(); i++) { // 转二进制
        if (s[i] > 64) s[i] -= 7;
        a[i*4] = b[i*4] = ((s[i]-48)&8)/8;
        a[i*4+1] = b[i*4+1] = ((s[i]-48)&4)/4;
        a[i*4+2] = b[i*4+2] = ((s[i]-48)&2)/2;
        a[i*4+3] = b[i*4+3] = (s[i]-48)&1;
    }
    n = s.length()*4;
    for (i=0; i<n; i++) { // 头部去零
        if (a[i] == 1) {
            x = i;
            break;
        }
    }
    if (a[x] == 1) { // 第一步翻转1-3位
        a[x] = 0;
        a[x+1] ^= 1;
        a[x+2] ^= 1;
        p++;
    }
    for (i=x+1; i<n-2; i++) {
        if (a[i] == 1) {
            a[i] = 0;
            a[i+1] ^= 1;
            a[i+2] ^= 1;
            p++;
        }
    }
    if (a[n-2] != a[n-1]) p = -1; // 不可行
    else if (a[n-1] == 1) p++;
    if (b[x] == 1) { // 第二步翻转1-2位
        b[x] = 0;
        b[x+1] ^= 1;
        q++;
    }
    for (i=x+1; i<n-2; i++) {
        if (b[i] == 1) {
            b[i] = 0;
            b[i+1] ^= 1;
            b[i+2] ^= 1;
            q++;
        }
    }
    if (b[n-2] != b[n-1]) q = -1; // 不可行
    else if (b[n-1] == 1) q++;
    // 取优解
    if (p == -1 and q == -1) cout << "No" << endl;
    else if (p == -1) cout << q << endl;
    else if (q == -1) cout << p << endl;
    else cout << min(p,q) << endl;
}
```


---

## 作者：张泰来 (赞：4)

## 核心算法：进制转换 + 动态规划

### Step1：将十六进制数转化为二进制数

相信这个步骤大家都会，只要把十六进制数的每一位都转化为四位的二进制数再相连即可，记得要去除前导零。暂且用 $a_1-a_n$ 来表示这个 $01$ 串。

### Step2：动态规划


我们可以定义 $dp_{i,0/1,k}$ 为串的第 $i$ 位不翻转/翻转（分别对应 $0$ 和  $1$ ）后达到第 $i$ 位为 $k$ （ $k$ 取 $0$ 或 $1$ ），前 $i-1$ 位均为 $0$ 状态的最少翻转次数。

初始化条件： $dp_{1,0,1} = 0,dp_{1,1,0} = 1$ （第一位必须是 $1$）。

状态转移方程：

如果 $a_i$ 为 $0$：

$dp_{i,0,0} = dp_{i-1,0,0}$

$dp_{i,1,0} = dp_{i-1,1,1} + 1$

$dp_{i,1,1} = dp_{i-1,0,1} + 1$

$dp_{i,0,1} = dp_{i-1,1,0}$

如果 $a_i$ 为 $1$：

$dp_{i,0,0} = dp_{i-1,1,0}$

$dp_{i,1,0} = dp_{i-1,0,1} + 1$

$dp_{i,1,1} = dp_{i-1,1,1} + 1$

$dp_{i,0,1} = dp_{i-1,0,0}$

最后统计答案 $ans=\min(dp_{n,1,0},dp_{n,0,0})$ 即可。


### 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int a[4000005],f[1025];
int ans,cnt;
int dp[4000005][2][2];
bool flag;
int main()
{
    ios::sync_with_stdio(false);
    cin >> s;
    for (int i = 0;i <= 9; i++)
        f[i + '0'] = i;
    for (int i = 1;i <= 6; i++)
        f[i + 'A' - 1] = 9 + i;

    for (int i = 0;i < s.size(); i++)
    {
        int t = f[s[i]];
        for (int j = 3;j >= 0; j--)
        {
            if (t & (1 << j)) flag = true;
            if (flag) a[++cnt] = (t >> j) & 1;
        }
    }
    memset(dp,0x3f,sizeof(dp));
    dp[1][0][1] = 0,dp[1][1][0] = 1;
    for (register int i = 2;i <= cnt; i++)
    {
        if (a[i] == 0) 
        {
            dp[i][0][0] = dp[i - 1][0][0];
            dp[i][1][0] = dp[i - 1][1][1] + 1;
            dp[i][1][1] = dp[i - 1][0][1] + 1;
            dp[i][0][1] = dp[i - 1][1][0];
        } else {
            dp[i][0][0] = dp[i - 1][1][0];
            dp[i][1][0] = dp[i - 1][0][1] + 1;
            dp[i][1][1] = dp[i - 1][1][1] + 1;
            dp[i][0][1] = dp[i - 1][0][0];
        }
    }
    ans = min(dp[cnt][1][0],dp[cnt][0][0]);
    if (ans <= cnt) cout << ans << endl;
    else cout << "No" << endl;
    return 0;
}
```

---

## 作者：__3E24AC7002AD9292__ (赞：3)

比较简单的思维题。
### 思路
题目分为两部分：  

- 十六进制转二进制。
- 翻转操作的处理。

**先考虑十六进制转二进制：**

因为 $2^4=16$，而十六进制的每一位仅仅 $0\sim 15$，我们可以将十六进制每一位转化为四位的二进制，比如 $15$ 这个数，将每一位转化成二进制，可以变为 $\{0001,0101\}$，合并后就是 $00010101$，然后进行去除前导 $0$ 操作，就变为 $10101$。

**然后考虑翻转操作（重点）：**

假设这个数已经化为二进制，记为 $tmp$。

对于 $tmp$ 的任意一个位置，在最优的情况下必定只会翻转 $0$ 或 $1$ 次，因为 $\geq2$ 次的情况下（假设翻转 $x$ 次），$2\times \lfloor\dfrac{x}{2}\rfloor$ 次的操作都是多余的，因为每两次对于同一位置的翻转操作跟没翻转是一样的。

可以考虑从前往后遍历一遍这个数，然后判断每个位置是否要进行翻转。

显然，对于 $[2,n]$ 区间的所有位置，假设当前遍历的位置为 $i$，则如果在 $1\sim i-1$ 的位置都遍历完之后，$tmp_{i-1}$ 是 $1$，为了让它变为 $0$，则必须要进行翻转，否则遍历到后面永远也无法改变 $tmp_{i-1}$ 从而不能满足要求；如果 $tmp_{i-1}$ 是 $0$ 则显然不能翻转，否则后面也一样无法挽回。

但是 $i=1$ 的时候没有上述限制，而且根据上面所述可以得知，只要 $i=1$ 的时候确定了是否翻转，后面也就都确定了。

所以综上所述，只需要把 $i=1$ 的时候翻或不翻的两种情况枚举一遍，判断翻转次数和方案可行性就行了。如果遍历完之后 $tmp\bmod2=1$，即 $tmp$ 最后一位还是 $1$，就说明这种方式是不可行的。最后如果两种方案都不可行，则说明无解，否则给可行的方案取 $\min$ 输出即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline string read(){
	string res="";char c=getchar();
	while (c=='\n'||c==' ') c=getchar();
	while (c!='\n'&&c!=' ') res+=c,c=getchar();
	return res;
}
string s=read();
bitset<4000005>tmp,tmp2;
int n=s.size()*4,ans;
inline int clac(int op){
	int sum=0;
	if (op==1) tmp[1]=!tmp[1],tmp[2]=!tmp[2],sum++;
	for (int i=2;i<=n;i++) if (tmp[i-1]) tmp[i-1]=!tmp[i-1],tmp[i]=!tmp[i],tmp[i+1]=!tmp[i+1],sum++;
	if (tmp[n]) return 1e18;
	return sum;
}
signed main(){
	for (int i=0;i<s.size();i++){
		int ch;s[i]<='9'&&s[i]>='0'?ch=s[i]-'0':ch=s[i]-'A'+10;
		tmp[i*4+1]=(ch>>3)&1,tmp[i*4+2]=(ch>>2)&1,tmp[i*4+3]=(ch>>1)&1,tmp[i*4+4]=ch&1;
	}
	int w=1;while (tmp[w]==0) w++;
	for (int i=w;i<=n;i++) tmp[i-w+1]=tmp[i];n=n-w+1;
	for (int i=1;i<=n;i++) tmp2[i]=tmp[i];
	ans=clac(1);
	for (int i=1;i<=n;i++) tmp[i]=tmp2[i];
	ans=min(ans,clac(2));
	if (ans!=1e18) cout<<ans;
	else cout<<"No";
	return 0;
}
```

---

## 作者：wzkdh (赞：1)

## 题目大意:
题目给出一个十六进制的数字，要求转换成二进制并通过题目给出的反转操作使其变成0，求最少的步数。

## 分析：
初看此题，可能会认为这是一个求最优解的题目，但是我们稍加分析：对于第一个点，有翻转或者不翻转两个可能的操作。

但是对于第二个点，情况就不同了，如果第一个点是1的话，那么如果第二个点不翻转，则第一个点依旧是1，但是第三个点影响不到第一个点，所以之后无论怎么翻转都不可能使整个数变为0，因此，第二个点必须翻转以保证第一个点为0，之后的第三第四个点均是如此。

反之，如果第一个点是0的话，那么第二个点就必须不翻转，理由同第一种情况。

综上所述，整个数字只有第一个点是可以随意翻转的，因为它之前没有会受到影响的点，之后则是一种必定的情况，并不需要求最优解。

至于是否可以全部翻转成0，则只需要判断翻转完成后最后一个点是否为0就可以了，因为之前的按照这个规则必定全部为0了，只要最后一个也是0，那么就可以，反之不行。

至此，这个题的解决方法就很清楚了，枚举第一个点翻转或者不翻转两种情况，分别模拟，求出它们能否翻转至0和翻转的步数，最后如果两种情况均可以翻转成0，则输出最小值，否则输出可以的情况的答案或者没有可以的情况输出No。

### 蒟蒻代码：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int a[1000010],tot,ans1=1,ans2,bj1=1,bj2=1;
bool b[10000010],c[10000010];
int main()
{
	char x;
	while((x=getchar())!='\n'&&x!='\r')
	{
		int y;
		if(x>60)
		{
			y=(x-'A'+10);
			a[++tot]=y;
			continue;
		}
		y=(int)(x-'0');
		a[++tot]=y;
	}
	for(int i=1;i<=tot;i++)
	{
		b[(i-1)*4+1]=a[i]&8;
		b[(i-1)*4+2]=a[i]&4;
		b[(i-1)*4+3]=a[i]&2;
		b[(i-1)*4+4]=a[i]&1;
	}
	tot*=4;
	memcpy(c,b,sizeof(b));
	int st=1;
	while(!b[st])
		st++;
	c[st]=1-c[st];
	c[st+1]=1-c[st+1];
	for(int i=st+1;i<=tot;i++)
	{
		if(c[i-1])
		{
			c[i-1]=1-c[i-1];
			if(i+1<=tot)
				c[i+1]=1-c[i+1];
			c[i]=1-c[i];
			ans1++;
		}
	}
	for(int i=st;i<=tot;i++)
	{
		if(c[i])
		{
			bj1=0;
			break;
		}
	}
	for(int i=st+1;i<=tot;i++)
	{
		if(b[i-1])
		{
			b[i-1]=1-b[i-1];
			if(i+1<=tot)
				b[i+1]=1-b[i+1];
			b[i]=1-b[i];
			ans2++;
		}
	}
	for(int i=st;i<=tot;i++)
	{
		if(b[i])
		{
			bj2=0;
			break;
		}
	}
	if(bj1&&bj2)
		printf("%d",min(ans1,ans2));
	else if(bj1)
		printf("%d",ans1);
	else if(bj2)
		printf("%d",ans2);
	else
		printf("No");
	return 0;
}

---

## 作者：Tachibana27 (赞：0)

这题其实是 papertiger，用老师的话来说就是“诈骗题”。

------------

### 十六进制转二进制

不难发现 $2^{4}=16$，所以对于每一位上的十六进制字符 $C$，将其转化成二进制后可以表示 $4$ 位的。**然后去除掉前导 $0$ 即可**。

------------
### 翻转

首先我们注意到一个显然的结论：对于二进制上的一位，它不会同时被翻 $2$ 次，因为这样是不如不翻的。

接下来再推一个结论：设当前位为第 $i$ 位，若第 $i-1$ 位为 $1$ 则当前位必然翻转，否则不翻转。因为若不翻转后面就没有将其反转的机会了。

我们发现，有了上面两个结论，只要第 $1$ 位被确定，则后面的翻转是固定的，大家可以自己画一画理解理解。

至此，我们只需要考虑第 $1$ 位是否需要翻转，随后分开计算求最小值即可。

特别的，无解仅当翻转完后两种情况都剩下最后一位为 $1$。

code:

```cpp
std::string s;
bool t[4000086];
bool q[4000086];
int p;
int main(){
	std::cin>>s;
	int n=s.size();
	s=" "+s;
	p=1;
	for(int i=1;i<=n;i++)
		s[i]=((s[i]>='0' and s[i]<='9')?s[i]-'0':s[i]-'A'+10);
	for(int i=1;i<=n;i++){
		t[i*4]=s[i]&1;
		s[i]>>=1;
		t[i*4-1]=s[i]&1;
		s[i]>>=1;
		t[i*4-2]=s[i]&1;
		s[i]>>=1;
		t[i*4-3]=s[i]&1;
		s[i]>>=1;
	}//二进制转换
	while(not t[p])
		p++;//去除前导0
	for(int i=p;i<=4*n;i++){
		q[i]=t[i];
//		std::cout<<(t[i]?1:0);
	}
//	puts("");
	int st1=1;
	q[p]=(not q[p]);
	q[p+1]=(not q[p+1]);//反转第1位
	for(int i=p+2;i<=4*n;i++)
		if(q[i-1]){
			q[i-1]=(not q[i-1]);
			q[i]=(not q[i]);
			q[i+1]=(not q[i+1]);
			st1++;
//			i++;
		}
	for(int i=p;i<=4*n;i++)
		if(q[i]){
			st1=1145141919;//打上标记无解
			break;
		}
	int st2=0;
	for(int i=p+1;i<=4*n;i++)
		if(t[i-1]){
			t[i-1]=(not t[i-1]);
			t[i]=(not t[i]);
			t[i+1]=(not t[i+1]);
			st2++;
//			i++;
		}
	for(int i=p;i<=4*n;i++)
		if(t[i]){
			st2=1145141919;
			break;
		}//同上
	if(std::min(st1,st2)==1145141919)
		puts("No");//均为无解
	else
		std::cout<<std::min(st1,st2);
	return 0;//撒花
}
```

---

## 作者：zhongcy (赞：0)

[Problem](https://www.luogu.com.cn/problem/P6366)

------------


### Solution

------------

首先，将原十六进制转化为二进制。显然，每一位对应四个二进制数字。故先将十六进制字符转化为对应数值，再直接转化为四位二进制。

注意转化完后要去除前导零。

------------

接下来对 $01$ 串进行翻转。显然，要使次数最少，则每个字符最多反转 $1$ 次。

下面以样例 $3$ 为例。原来为 $10000$。

假设先翻转第 $1$ 个字符。则原 $01$ 串变为 $01000$。

再考虑第 $2$ 个字符。显然，我们**不能**翻转它。如果翻转，第 $1$ 个字符就变为 $1$。

同理，考虑第 $3$ 个字符。显然，我们**必须**翻转它。如果不翻转，第 $2$ 个字符不能就变为 $0$。则原 $01$ 串变为 $00110$。

再考虑第 $4,5$ 个字符。最后原 $01$ 串变为 $00001$。由于第一步之后每步都是**确定**的，所以此时它无解。

同理考虑不翻转第 $1$ 个字符的情况。

------------

于是，本题的具体做法就是分翻不翻转第 $1$ 个字符的情况讨论。最后答案取两种方案的最小值。如果都无解，输出 $\texttt{No}$。


### Code

------------

直接模拟即可。
```cpp
#include<bits/stdc++.h>
#define inf INT_MAX
#define N 4000001
using namespace std;
bool a[N],b[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	string s;
	cin>>s;
	int n=s.length(),pos,p=0,q=0;
	for(int i=0;i<n;i++)
	{
		if(s[i]>='A')
			s[i]-=7;
		a[i*4]=b[i*4]=((s[i]-'0')&8)/8;
		a[i*4+1]=b[i*4+1]=((s[i]-'0')&4)/4;
		a[i*4+2]=b[i*4+2]=((s[i]-'0')&2)/2;
		a[i*4+3]=b[i*4+3]=((s[i]-'0')&1);
	}
	n<<=2;	
	for(int i=0;i<n;i++)
		if(a[i]==1)
		{
			pos=i;
			break;
		}
		
	if(a[pos]==1)
	{
		p++;a[pos]=0;
		a[pos+1]^=1;a[pos+2]^=1;
	}
	for(int i=pos+1;i<n-2;i++)
		if(a[i]==1)
		{
			p++;a[i]=0;
			a[i+1]^=1;a[i+2]^=1;
		}
	if(a[n-2]!=a[n-1])
		p=inf;
	if(a[n-1]==1&&a[n-2]==1)
		p++;
		
	if(b[pos]==1)
	{
		q++;b[pos]=0;
		b[pos+1]^=1;
	}
	for(int i=pos+1;i<n-2;i++)
		if(b[i]==1)
		{
			q++;b[i]=0;
			b[i+1]^=1;b[i+2]^=1;
		}
	if(b[n-2]!=b[n-1])
		q=inf;
	if(b[n-1]==1&&b[n-2]==1)
		q++;
		
	if(p==inf&&q==inf)
		cout<<"No";
	else
		cout<<min(p,q);
	return 0;
}
```



---

## 作者：wtxy2006 (赞：0)

### Describe:
给一个16进制串，把它转化为2进制串，每次可以反转每个字符相邻的2个字符和本身，求多少次操作后字符串变为全0。
### Solution:
首先是16进制转2进制，这很简单，把每一个16进制的数字用4位二进制表示出来再替换。

发现可以把**反转 $f[i]$ 相邻的2个字符，变为反转 $f[i - 1]$ 后面2个字符。**

所以**反转后面的字符都不可能对前面造成影响。**

那么可得：**如果 $f[i]$ 是1，那么必须反转 $f[i]$。**

但是又发现如果想要反转 $f[1]$ 时会出现2种结果：
1. 反转 $f[1], f[2]$
2. 反转 $f[1], f[2],f[3]$
   
只需要对这两种情况分别讨论，再取最小值。

接下来再看无解的情况

易得（~~其实是我不会证明~~）无解时最后一位在反转过后是1。
### Code:
附上丑陋的代码~~
```cpp
// P6366 特殊的翻转
#include <cstdio>
#include <iostream>
#define MN 40000005
using namespace std;
int k[16][4] = {
    {0, 0, 0, 0}, {0, 0, 0, 1}, {0, 0, 1, 0}, {0, 0, 1, 1},
    {0, 1, 0, 0}, {0, 1, 0, 1}, {0, 1, 1, 0}, {0, 1, 1, 1},
    {1, 0, 0, 0}, {1, 0, 0, 1}, {1, 0, 1, 0}, {1, 0, 1, 1},
    {1, 1, 0, 0}, {1, 1, 0, 1}, {1, 1, 1, 0}, {1, 1, 1, 1},
};
int cnt, key, ans1, ans2 = 1, now, nk;
string s;
bool f[MN], a[MN];
int main() {
  cin >> s;
  for (int i = 0; i < s.length(); i++) {
    if ('0' <= s[i] && s[i] <= '9')
      key = s[i] - '0';
    else
      key = s[i] - 'A' + 10;
    for (int j = 0; j < 4; j++) f[cnt++] = k[key][j];
  }
  for (int i = 0; i < cnt; i++)
    if (!f[i])
      now++;
    else
      break;
  if (now == cnt - 1) {
    printf(f[now] ? "1" : "0");
    return 0;
  }
  for (int i = now; i < cnt; i++) a[i] = f[i];
  for (int i = now; i < cnt - 1; i++)
    if (f[i]) f[i] = !f[i], f[i + 1] = !f[i + 1], f[i + 2] = !f[i + 2], ans1++;
  if (f[cnt - 1]) ans1 = MN;
  for (int i = now; i < cnt; i++) f[i] = a[i];
  f[now + 1] = !f[now + 1];
  for (int i = now + 1; i < cnt - 1; i++)
    if (f[i]) f[i] = !f[i], f[i + 1] = !f[i + 1], f[i + 2] = !f[i + 2], ans2++;
  if (f[cnt - 1]) ans2 = MN;
  if (ans1 == MN && ans2 == MN)
    printf("No");
  else
    printf("%d", min(ans1, ans2));
  return 0;
}
```

---

## 作者：bluewindde (赞：0)

### 思路

将原串转换为 $0/1$ 串的操作很简单：发现 $16$ 是 $2$ 的整数次方，所以可以将十六进制的每一位转换为二进制的四位。

对于 $0/1$ 串的每一位，显然，它最多翻转一次（因为翻转两次等于没翻）。从两端开始翻显然不劣（因为从中间翻之后如果发现一端不能变成 $0$ 又要重新翻回去），所以我们可以逐位模拟翻的过程，每一次都尽量使得最高位为 $0$，如此直到最后一位，会出现这两种情况：

$$\left\{0,0,\dots,0,1\right\}$$

$$\left\{0,0,\dots,1,0\right\}$$

容易发现无论如何都不可能通过翻转使得整个串变为 $0$，输出 `No`。

为了防止漏掉情况，分别从第一位和第二位开始翻，答案取最小值。

### 代码

~~这么简单就不需要代码了。~~

```cpp
#include <iostream>
#include <string>
using namespace std;

string s;
int a[4000005];
int b[4000005];

int main() {
    int now=-1,ans1=0,ans2=0;
    cin>>s;
    for(int i=0;i<s.size();++i) {
        int x;
        if(s[i]>='A'&&s[i]<='F') x=s[i]-'A'+10;
        else x=s[i]-'0';
        a[i<<2]=b[i<<2]=(x&8)>>3;
        a[i<<2|1]=b[i<<2|1]=(x&4)>>2;
        a[i<<2|2]=b[i<<2|2]=(x&2)>>1;
        a[i<<2|3]=b[i<<2|3]=x&1;
    }
    int n=s.size()<<2;
    for(int i=0;i<n;++i) {
        if(a[i]) {
            now=i;
            break;
        }
    }
    if(now==-1||(now==n-2&&(a[n-2]^a[n-1]))) {
        cout<<"No";
        return 0;
    }
    if(a[now]) {
        a[now]^=1;
        a[now+1]^=1;
        a[now+2]^=1;
        ++ans1;
    }
    for(int i=now+1;i<n-2;++i) {
        if(a[i]) {
            a[i]^=1;
            a[i+1]^=1;
            a[i+2]^=1;
            ++ans1;
        }
    }
    if(a[n-2]^a[n-1]) ans1=1e9;
    else if(a[n-1]) ++ans1;
    if(b[now]) {
        b[now]^=1;
        b[now+1]^=1;
        ++ans2;
    }
    for(int i=now+1;i<n-2;++i) {
        if(b[i]) {
            b[i]^=1;
            b[i+1]^=1;
            b[i+2]^=1;
            ++ans2;
        }
    }
    if(b[n-2]^b[n-1]) ans2=1e9;
    else if(b[n-1]) ++ans2;
    int ans=min(ans1,ans2);
    if(ans>=1e8) cout<<"No";
    else cout<<ans;
    return 0;
}
```

---


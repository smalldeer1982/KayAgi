# [COCI 2007/2008 #4] POKLON

## 题目描述

给定 $n$ 个区间，Mirko 想要构造一些区间，满足后续的区间是前面区间的子区间，且区间里的每个数都包含在给定的区间里。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 10^5$，$1\le A<B\le 10^6$。
#### 说明

**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #4](https://hsin.hr/coci/archive/2007_2008/contest4_tasks.pdf) *T5 POKLON***。

## 样例 #1

### 输入

```
3
3 4
2 5
1 6```

### 输出

```
3
1 6
2 5
3 4```

## 样例 #2

### 输入

```
5
10 30
20 40
30 50
10 60
30 40```

### 输出

```
3
10 60
30 50
30 40```

## 样例 #3

### 输入

```
6
1 4
1 5
1 6
1 7
2 5
3 5```

### 输出

```
5
1 7
1 6
1 5
2 5
3 5```

# 题解

## 作者：harmis_yz (赞：2)

感谢 @$\color{#AEF}{\texttt{Celestial Cyan}}$ 大神对我的~~骚扰~~帮助。

## 分析

一眼 DP。

对于求最大满足条件区间数，我们定义状态函数 $\mathit{f}_{i}$ 表示在第 $1$ 到 $i$ 个区间中选择，且必选第 $i$ 个区间能够得到的最大长度。有转移方程：$\mathit{f}_{i}=\max\{f[j]|\mathit{a}_{j}\le\mathit{a}_{i} \land \mathit{b}_{j} \ge \mathit{b}_{i} \}+1$。

可以得到 $50$ 分的 $O(n^2)$ 的代码：

```cpp
for(re int i=1;i<=n;++i){
	f[i]=1;
	for(re int j=1;j<i;++j){
		if(a[i].l>=a[j].l&&a[j].r>=a[i].r){
			if(f[j]+1>f[i]) f[i]=f[j]+1,nxt[i]=j;
		}
	}
}
```

考虑优化 $\mathit{f}_{i}$ 的转移。这个代码与 LIS 模板几乎一致，所以很显然的也可以使用树状数组优化。因为我们需要记录方案，所以树状数组存 $2$ 维：价值与该价值对应的下标。

我们将 $\mathit{a},\mathit{b}$ 用一个结构体存放，按第一维从小到大排序。可以得到：对于每一个 $i$，都有 $1 \le j \le i,\mathit{a}_j \le \mathit{a}_i$。这样我们就消除了区间左端点的影响。剩下的就用树状数组查询 $ \ge \mathit{b}_i$ 的最大的 ${f}_j$ 的值与其下标。


## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register
#define il inline
#define PII pair<int,int>
#define x first
#define y second
const int N=1e5+10,MAXN=1e6+10;
int n;
PII f[N],tr[MAXN];
struct node{
	int l,r;
}a[N];
stack<int> st;
int id,maxx;
il bool cmp(node a,node b){return (a.l!=b.l)?(a.l<b.l):(a.r>b.r);}
il void insert(int x,int y,int id){
	while(x){
		if(tr[x].x<y) tr[x].x=y,tr[x].y=id;
		x-=x&(-x);
	}
	return ;
}
il PII query(int x){
	PII ans;ans={0,0};
	while(x<=MAXN){
		if(ans.x<tr[x].x) ans.x=tr[x].x,ans.y=tr[x].y;
		x+=x&(-x);
	}
	ans.x++;return ans;
}
il void read(){
	scanf("%lld",&n);
	for(re int i=1;i<=n;++i) scanf("%lld%lld",&a[i].l,&a[i].r);
	sort(a+1,a+n+1,cmp);
	return ;
}
il void solve(){
	for(re int i=1;i<=n;++i) f[i]=query(a[i].r),insert(a[i].r,f[i].x,i);
	for(re int i=1;i<=n;++i){
		if(maxx<f[i].x) maxx=f[i].x,id=i;
	}
	while(id!=0) st.push(id),id=f[id].y;
	return ;
}
il void print(){
	printf("%lld\n",maxx);
	while(!st.empty()){
		int now=st.top();st.pop();
		printf("%lld %lld\n",a[now].l,a[now].r);
	}
	return ;
}
signed main(){
	read(),solve(),print();
	return 0;
}
```


---

## 作者：f_hxr_ (赞：1)

[传送门](https://www.luogu.com.cn/problem/P6390)

敲珂耐的小清新线段树优化 DP。

### 题意

给定 $N$ 个区间。现在要选出若干区间，使得存在一种排列方式让前面的区间包含后面的区间。问最多能选出多少区间。还要输出方案。

人话：把最长不降子序列的数字换成了区间。~~我愿称之为最长嵌套区间链问题。~~

就像下面这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/urlal653.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/43tihmka.png)

不会最长不降子序列可以出门左转[膜板区](https://www.luogu.com.cn/problem/P1020)。~~不会二分优化也没关系，因为本题是用数据结构优化。~~

### 分析

先把输出方案这件事搁一边。

区间之间有包含关系，你是不是也想到了数字之间也有大小关系？虽然这两种关系非常不同（一个是要比较左端点和右端点两个数，一个是只比较一个数），但是这使得我们可以想到：是否可以“借鉴”一下 LIS 的状态转移方程呢？

想想 LIS 的状态定义：

>我们定义 $f_i$ 为：以第 $i$ 个数字结尾的最长不降子序列长度。

>枚举前面比它小的数字，并尝试从那些数字转移。

在那道题里，第 $i$ 个数字的状态从**前面**转移而来，而且是从前面那些比第 $i$ 个数字小的数字转移而来。

我们也模仿 LIS 的状态定义。我们定义 $f_i$ 为：以第 $i$ 个区间为结尾的最长不降子区间序列的长度。

在这道题中，区间的顺序是可以按照我们的意愿改变的。因为转移是从**前面的区间**选的，为了不漏掉区间，对于每一个区间我们需要保证**它的后面没有任何区间能被它包含**。于是我们就需要排序。

下面就是一个需要排序的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/nqktz2p5.png)

该怎么排序呢？

很简单。我们按 $L$ 从大到小排序，若 $L$ 相同就比较 $R$，$R$ 小的就站前面。

这样为什么是正确的呢？

你想啊，区间 $A$ 要想包含区间 $B$，那么肯定要满足 $A$ 的左端点在 $B$ 左端点的左边，$A$ 的右端点在 $B$ 右端点的右边。也就是 $A_L \le B_L$ 且 $ B_R \le A_R$。

对于一个区间 $X$ 和它前面的某个区间 $Y$，将 $L$ 从大到小排序，就保证了第一条 $X_L \le Y_L$。$L$ 相等时将 $R$ 从小到大排序也保证了 $Y_R \le X_R$。

排序拍好了，我们可以开始 DP 了。

还记得我们定义的状态吗？我们定义 $f_i$ 为：以第 $i$ 个区间为结尾的最长上升子区间序列的长度。

要计算 $f_i$，我们要从前面那些比 $i$“小”,即能被 $i$ 包含的区间转移过来。

令 $L_i$ 和 $R_i$ 为第 $i$ 个区间的左右端点，则有：

$$
f_i=\max_{L_i\le L_j \text{且}R_j\le R_i}f_j+1
$$

上式的含义是：枚举前面的能被 $i$ 包含的区间，将第 $i$ 个区间接到后面，就得到了新的不降升子序列。

等等，上面为什么有个 $L_i\le L_j$？我们排序的时候不是已经保证了这个吗？

的确是这样的，我们可以把它去掉。

$$
f_i=\max_{R_j\le R_i}f_j+1
$$

将这玩意直接套上去，你应该可以得到 50 分。考虑优化。

我们建立一个值域线段树。单点修改，区间查最值。

对于每一个 $f_i$，当它被计算完之后我们将它打在 $R_i$ 上面。

这样，当我们计算下一个 $f_p$ 时，在线段树上查询 $1$ 到 $R_p$ 的最大值，就能得到满足 $R_i \le R_p$ 的最大的 $f_i$ 了。

就像下面这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/asy4z2vz.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/xe6ucd4t.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hxd4c8f0.png)

当然，由于我们要求最大值，将 $f_i$ 打上去前要跟原来的数比一比。

怎么输出方案呢？也很简单。在线段树上顺带维护一下“取到最大值的位置”即可。

[AC](https://www.luogu.com.cn/record/155817132) 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=1e6+7,SZ=1e6;
int N,mx[SZ<<2],f[maxn],best[SZ<<2],last[maxn];
struct Range{int l,r;}R[maxn];
bool cmp(Range A,Range B){return A.l==B.l?A.r<B.r:A.l>B.l;}
void pushup(int p){
	//维护最大值的同时维护位置
 	if(mx[p<<1]>mx[p<<1|1])mx[p]=mx[p<<1],best[p]=best[p<<1];
	else mx[p]=mx[p<<1|1],best[p]=best[p<<1|1];
}
void update(int p,int L,int R,int inx,int xx,int pi){
	if(L>=R){
      //先比一比
      if(xx>=mx[p])mx[p]=xx,best[p]=pi;
      return;
	} 
	int mid=(L+R)>>1;
	if(inx<=mid)update(p<<1,L,mid,inx,xx,pi);
	else update(p<<1|1,mid+1,R,inx,xx,pi);
	pushup(p);
}
pair<int,int>query(int p,int L,int R,int ql,int qr){
	if(ql<=L&&R<=qr)return make_pair(mx[p],best[p]);
	int mid=(L+R)>>1;
	pair<int,int>ret,t;ret.first=0;
	if(ql<=mid){
		t=query(p<<1,L,mid,ql,qr);
		if(t.first>ret.first)ret=t;
	}
	if(mid+1<=qr){
		t=query(p<<1|1,mid+1,R,ql,qr);
		if(t.first>ret.first)ret=t;
	}
	return ret;
}
int main(){
	scanf("%d",&N);
	for(int i=1;i<=N;i++)scanf("%d %d",&R[i].l,&R[i].r);
	sort(R+1,R+N+1,cmp);
	//for(int i=1;i<=N;i++)cout<<R[i].l<<' '<<R[i].r<<endl;
	for(int i=1;i<=N;i++){
		pair<int,int>rt=query(1,1,SZ,1,R[i].r);
		f[i]=rt.first+1;last[i]=rt.second;
		update(1,1,SZ,R[i].r,f[i],i);
	}
	int ans=0,p;
	for(int i=1;i<=N;i++)if(f[i]>ans)ans=f[i],p=i;
	cout<<ans<<endl;
	while(p)cout<<R[p].l<<' '<<R[p].r<<endl,p=last[p];
	return 0;
}
}
```

---

## 作者：AlicX (赞：1)

## Solution 

此题算是一道小清新树状数组题了吧。 

类似最长上升子序列的方法，将原数组的 $l$ 从小到大排序，用树状数组计算大于 $r$ 的数量就可以了。

问题的关键在于如何求方案数，我们需要在树状数组上多增一维，表示这个值由哪一个小标更新。最后记录一下 $nxt$ 数组进行倒推就可以了。

```cpp
#include<bits/stdc++.h> 
#define int long long 
#define x first 
#define y second 
#define low(x) x&-x 
#define debug() puts("-------") 
using namespace std; 
typedef pair<int,int> pii; 
const int N=1e5+10,M=1e6+10; 
int n; 
pii a[N]; 
pii tr[M];  
int f[N],nxt[N]; 
int ans[N],cnt=0;
int read(){ 
	int x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-') f=-1; c=getchar(); }
	while(c>='0'&&c<='9'){ x=(x<<3)+(x<<1)+c-48; c=getchar(); }
	return x*f;
} 
bool cmp(pii a,pii b){ 
	return (a.x!=b.x)?a.x<b.x:a.y>b.y; 
} 
void add(int x,int w,int k){ 
	for(int i=x;i;i-=low(i)) if(tr[i].x<w) tr[i].x=w,tr[i].y=k; 
} 
pii query(int x){ 
	pii Max={0,0}; 
	for(int i=x;i<M;i+=low(i)) if(tr[i].x>Max.x) Max.x=tr[i].x,Max.y=tr[i].y;
	return Max; 
} 
signed main(){ 
	n=read(); pii Max={0,0}; 
	for(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();  
	sort(a+1,a+n+1,cmp); 
	for(int i=1;i<=n;i++){ 
		pii lst=query(a[i].y); 
		f[i]=f[lst.y]+1; nxt[i]=lst.y; 
		add(a[i].y,f[i],i); if(f[i]>Max.x) Max.x=f[i],Max.y=i; 
	} cout<<Max.x<<endl; int now=Max.y; 
	while(now) ans[++cnt]=now,now=nxt[now]; 
	for(int i=cnt;i>=1;i--) cout<<a[ans[i]].x<<" "<<a[ans[i]].y<<endl; 
	return 0; 
} 
```




---


# [COCI 2014/2015 #2] BOB

## 题目描述

Bob 是一位著名的建设者。他买了地，想盖房子。不幸的是，问题是土地的地形，土地不同地方的海拔不一定一样。

这块地呈长方形，宽 $n$ 米，长 $m$ 米。它可以分为 $n\times m$ 个方格（见图片）。Bob 的房子将被塑造成一个长方形，它的边与土地的边平行，其顶点与正方形的顶点重合。Bob 的房子所覆盖的所有土地必须具有相同的高度，以防倒塌。

![](https://cdn.luogu.com.cn/upload/image_hosting/aedp5fq2.png)

请计算出 Bob 建房的方法数。

**形式化地**，求出一个矩阵中所有元素均相等的子矩阵个数。

## 说明/提示

#### 样例 1 说明

一些可能的房屋位置是分别以 $(0,0)-(1,1),(0,0)-(0,2)$ （高度为 $2$）$(2,0)-(2,2),(1,2)-(2,2)$（高度为 $1$）为左上角顶点和右下角顶点的矩形。括号中的第一个数字表示行号，第二个数字表示列号（坐标以 $0$ 开始）。

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n,m\le 50$。
- 对于 $60\%$ 的数据，有 $1\le n,m\le 500$。
- 对于 $100\%$ 的数据，有 $1\le n,m\le 10^3$。

对于所有合法的 $a_{i,j}$，都有 $1\le a_{i,j}\le 10^9$。

#### 说明

**题目译自 [COCI2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST #2](https://hsin.hr/coci/archive/2014_2015/contest2_tasks.pdf) _T4 BOB_。**

## 样例 #1

### 输入

```
5 3
2 2 2
2 2 1
1 1 1
2 1 2
1 2 1```

### 输出

```
27```

## 样例 #2

### 输入

```
4 3
1 1 1
1 1 1
2 2 2
2 2 2```

### 输出

```
36```

# 题解

## 作者：Kevin_Wa (赞：36)

本题作者思考很久，感受颇深。认为比较有价值，故写题解尽量详细。

## 题目大意

给你一个矩阵，问你这个矩阵所包含的所有每个元素相等的子矩阵的个数。

## 20pts

非常显然，使用$O(n^4)$的$dp$。开一个四维数组$w[x1][y1][x2][y2]$来记录以$(x1,y1)$为左上角，$(x2,y2)$为右上角的这个矩形是否满足每个元素都相等。

转移方程为：

$w[i][j][x][y]=w[i][j][x-1][y]$ & $w[i][j][x][y-1]$ & $(a[i][j]==a[x][y])$

具体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010][1010];
int n,m,ans;
bool w[51][51][51][51];
template <typename T> void read(T &x) {
x = 0; char c = getchar();int f=1;
for (; !isdigit(c); c = getchar())if (c=='-') f=-1;
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
x*=f;
}
int main()
{
read(n);read(m);
for (int i=1;i<=n;i++)
  for (int j=1;j<=m;j++)
    read(a[i][j]);
if (n<=50 && m<=50)
  {
  	for (int i=1;i<=n;i++)
  	  for (int j=1;j<=m;j++)
  	    {
  	    w[i][j][i][j]=true;
  	    for (int x=0;x<i;x++)
  	      for (int y=0;y<=m;y++)
  	        w[i][j][x][y]=true;
  	    for (int x=0;x<=n;x++)
  	      for (int y=0;y<j;y++)
  	        w[i][j][x][y]=true;
  	    for (int x=i;x<=n;x++)
  	      for (int y=j;y<=m;y++)
  	        if (w[i][j][x-1][y] && w[i][j][x][y-1] && (a[i][j]==a[x][y])) w[i][j][x][y]=true;
  	    }
  	ans=0;
  	for (int i=1;i<=n;i++)
  	  for (int j=1;j<=m;j++)
  	    for (int x=i;x<=n;x++)
  	      for (int y=j;y<=m;y++)
  	        if (w[i][j][x][y]) ans++;
  	printf("%d\n",ans);
  	return 0;
  }

return 0;
}
```

 
## 理论上为60pts

$n^4$的复杂度对于这题是远远不够的，接下来我们先介绍我们要借助的两个数组。

> $up$数组：$up[i][j]$表示$a[i][j]$向上最多连续有几个点和$a[i][j]$的数值相等。

> $l$数组：$l[i][j]$表示$a[i][j]$向左最多连续有几个点和$a[i][j]$的数值相等。

接下来我们只要暴力枚举每个矩形的右下角的坐标，然后向上搜索，将整个与当前坐标的数值相等的这块东西扫描出来。

来张图思考一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/vrbh1hbw.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/pt6aa9u3.png)

但是这只是严格单调递减时候的情况，在实际上遇到的情况远远不会这么简单。

假如我们遇到了这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jlm5sjy9.png)

我们又一次很容易的发现，他只计算单调递减的部分。中途突出来的无法成为一个更大的矩形。

故我们向上扫描整个图形时，便可以顺带将$l[k][j]$的最小值记录一下 ($k=i->(i-up[i][j]+1)$)，而这个最小值便是该行和该右下角贡献的答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1010][1010],l[1010][1010],up[1010][1010];
int n,m,sum;
long long ans;
template <typename T> void read(T &x) {
x = 0; char c = getchar();int f=1;
for (; !isdigit(c); c = getchar())if (c=='-') f=-1;
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
x*=f;
}
int main()
{
//freopen("bob.in","r",stdin);
//freopen("bob.out","w",stdout);
read(n);read(m);
for (int i=1;i<=n;i++)
  for (int j=1;j<=m;j++)
    {
      read(a[i][j]);
      if (a[i][j]==a[i-1][j]) up[i][j]=up[i-1][j]+1;
      else up[i][j]=1;
      if (a[i][j]==a[i][j-1]) l[i][j]=l[i][j-1]+1;
      else l[i][j]=1;
	}
sum=0;
ans=0;
for (register int j=1;j<=m;j++)
  for (register int i=1;i<=n;i++)
    {
    	sum=l[i][j];
    	for (register int k=i;k>=i-up[i][j]+1;k--)
    	  {
    	  	if (sum>l[k][j]) sum=l[k][j];
    	  	ans+=sum;
		  }
	}
printf("%lld\n",ans);
return 0;
}
```


复杂度理论上是$O(n^3)$，但是数据水+洛谷的评测姬跑的飞快。居然卡过去了。~~所以题解完结撒花（大雾）。~~

当然是不可能的。

## 真正的100pts

我们发现，其实只要我们先做纵坐标的递增，我们的所需的最小值答案是可以部分被上面传下来的，这样就可以优化掉扫描图形的时间。故我们运用单调栈维护这个东西。

因为我们需要的答案是单调递减的，所以我们我们维护栈内的元素单调递增，栈顶元素最大。若我们当前这个元素比栈顶元素大，那就把他放入栈顶。如果比栈顶小，那么我们将栈中元素弹出（将弹出元素的数量记录），直到找到比他小的栈顶，最后把他放入栈中，过程中统计答案。（栈中除了要存储当前元素值以外，还有存储当前元素值相同的个数）

依旧举这个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/jlm5sjy9.png)

这是单调栈内的情况。

num指当前元素值，v指元素个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/yas9fnw6.png)


搞清了之后我们就可以看代码帮助理解了。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num,v;
}q[1010];
int a[1010][1010],l[1010][1010],up[1010][1010];
int n,m,sum,h,x;
long long ans;
template <typename T> void read(T &x) {
x = 0; char c = getchar();int f=1;
for (; !isdigit(c); c = getchar())if (c=='-') f=-1;
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
x*=f;
}
int main()
{
//freopen("bob.in","r",stdin);
//freopen("bob.out","w",stdout);
read(n);read(m);
for (register int i=1;i<=n;i++)
  for (register int j=1;j<=m;j++)
    {
      read(a[i][j]);
      if (a[i][j]==a[i-1][j]) up[i][j]=up[i-1][j]+1;
      else up[i][j]=1;
      if (a[i][j]==a[i][j-1]) l[i][j]=l[i][j-1]+1;
      else l[i][j]=1;
	}
sum=0;
ans=0;
/*for (register int j=1;j<=m;j++)
  for (register int i=1;i<=n;i++)
    {
    	sum=l[i][j];
    	for (register int k=i;k>=i-up[i][j]+1;k--)
    	  {
    	  	if (sum>l[k][j]) sum=l[k][j];
    	  	ans+=sum;
		  }
	}*/
for (register int j=1;j<=m;j++)
  {
  	h=0;sum=0;
  	for (register int i=1;i<=n;i++)
  	  {
  	  	if (up[i][j]==1) h=0,sum=0;
  	  	x=l[i][j];
  	  	q[++h].num=x;
  	  	q[h].v=1;
  	  	sum+=x;
		while (h>1 && q[h-1].num>=q[h].num)
		  {
		  	h--;
		  	sum=sum-q[h].num*q[h].v-q[h+1].num*q[h+1].v;
		  	q[h].v+=q[h+1].v;
		  	q[h].num=q[h+1].num;
		  	sum=sum+q[h].num*q[h].v;
		  }
		ans+=sum;
		}
  }
printf("%lld\n",ans);
return 0;
}
```
此题区分度明显，部分分足。不失为一道好题。

撰写不易，望君满意。



---

## 作者：HasNoName (赞：4)

### 思路

统计每一列的以一点为结尾的往上最大的相同高度的个数，对每一个高相同的底面，高度小于等于底面中每一个点的往上最大的相同高度的个数的最小值的长方形之前都没有计算过，将大案增加那个个数。

复杂度 $O(N^3)$。因为常数小所以能过。[记录](https://www.luogu.com.cn/record/153609674)。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1005;
ll f[N][N],a[N][N];//f 表示以一点为结尾的往上最大的相同高度的个数
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			if(a[i-1][j]==a[i][j])//用递推方式得到f
				f[i][j]=f[i-1][j]+1;
			else f[i][j]=1;
		}
	}
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			ll d=1e9;
			for(int k=j;a[i][k]==a[i][j];k--)//只在高度相同的情况下统计
			{
				d=min(d,f[i][k]);//最小的最大高度
				ans+=d;
			}
		}
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：__liujy (赞：3)

令 $h_{i,j}$ 为 $a_{i,j}$ 与 $a_{i+1,j}$ 到 $a_{i+h_{i,j}-1,j}$ 之间所有数相等。

有了 $h$，我们就可以枚举。当枚举到 $(i,j)$ 时，定义一个变量 $k$，满足 $a_{i,j}=a_{i,k}$，这样每次 $k$ 增加时，最终答案就加 $\min^{k}_{p=j} h_{i,p}$ 即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
typedef long long LL;
int n,m,a[N][N],h[N][N];
LL ans;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]!=a[i-1][j]) h[i][j]=1;
			else h[i][j]=h[i-1][j]+1;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			int minn=INT_MAX;
			for(int k=j;a[i][j]==a[i][k];k++)
			{
				minn=min(minn,h[i][k]);
				ans+=minn;
			}
		}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：JK_LOVER (赞：3)

## 题意
在一个 $n \times m$ 的矩阵中有多少个元素相同的子矩阵。
## 分析
按照题意可以写出朴素的 $O(n^3)$ 的转移方程。$len[i][j]$ 是点为 $(i,j)$ 可以向左可以延伸的最大长度。$sum[i][j]$ 是点为 $(i,j)$ 向上可以延伸的最大长度。$num[i][j]$ 是以点 $(i,j)$ 为右下角矩阵个数。
$$
num[i][j] = len[i][j] \times sum[i][j]  +num[i-1][j] -\sum_k^{i-1}num[k][j]
$$
$$
ans=\sum_i^n\sum_j^mnum[i][j]
$$
其中的 $k$ 满足 $len[i][j]$ 不可以完全包含 $len[k][j]$ 。
因为可以发现 $len$ 只会减去比他大的，而 $sum$ 只会加比他大的，考虑用单调栈优化。
如下：
```cpp
while(top && len[i][j] <= len[st[top]][j])
{
 	sum[i][j] += sum[st[top]][j];
 	num[i][j] -= len[st[top]][j] * sum[st[top]][j];
 	top--;
}
num[i][j] += len[i][j] * sum[i][j];
```
时间复杂度为  $O(n^2)$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3010;
inline int read()
{
    int t=0,f = 0;char a=getchar();
	while(a<'0'||a>'9'){if(a=='-')f=1;a=getchar();}
    while(a>='0'&&a<='9'){t=(t<<1)+(t<<3)+a-'0';a=getchar();}
	return f?-t:t;
}
int n,m,s[N][N],len[N][N],top = 0;
int st[N],sum[N][N];
long long ans = 0,to,num[N][N];
int main()
{
	n = read();m = read();
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			s[i][j] = read();
			if(s[i][j-1] == s[i][j])
			len[i][j] = len[i][j-1]+1;
			else len[i][j] = 1;
		}
 	}
 	for(int j = 1;j <= m;j++,top = 0)
 	{
 		for(int i = 1;i <= n;i++)
 		{
 			if(s[i][j] != s[st[top]][j]) top = 0;
 			sum[i][j] = 1;num[i][j] = num[st[top]][j];
			while(top && len[i][j] <= len[st[top]][j])
 			{
 				sum[i][j] += sum[st[top]][j];
 				num[i][j] -= len[st[top]][j] * sum[st[top]][j];
 				top--;
			}
			num[i][j] += len[i][j] * sum[i][j];
			ans += num[i][j];
			st[++top] = i;
		}
	}
	cout<<ans<<endl;
}
/*
4 3
1 1 1
1 1 1
2 2 2
2 2 2
*/
```
[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p6404)

---

## 作者：Swirl (赞：2)

难度中上位绿吧。

---

**单调栈**

记 $f(i, j)$ 为以 $(i, j)$ 为右下角的矩形个数。

直接楞转移好像涉及参数较多，时间不允许。

但是可以用一些~~奇妙的~~技巧。

记 $L(i, j)$ 为 $(i, j)$ 左边的与 $(i, j)$ 相同的位置个数，$U(i, j)$ 为 $(i, j)$ 上边的。

此时问题就变简单了。

将问题转化为确定右下角为 $(i, j)$ 的左上角个数。

那么有：

$$
f(i, j) = \sum _ {k = i - U(i, j) + 1} ^ {i} L(k, j)
$$

但是问题仍然是有的。

例如以下情况：

```example
1 1 1 3
2 1 1 3
```

在这种情况里，我们计算出来 $f(2, 3) = 5$，但实际上 $f(2, 3)$ 的值只有 $4$。

根本问题是我们无法确保所有的左上角都是合法的。

改写方程：

$$
f(i, j) = \sum _ {k = i - U(i, j) + 1} ^ {i} \min_{s = k}^{i} L(s, j)
$$

此时的方程就正确了。

再看时间问题，如果老老实实地按照方程做，时间复杂度是 $\Theta (n^4)$，直接 T 飞。

不过我们可以先枚举 $j$，再枚举 $i$，此时只需要在枚举 $i$ 的同时沿途计算最小值即可降到 $\Theta (n^3)$。

貌似这样就能过？

考虑单调栈优化，将所有的 $L(i, j)$ 放到单调栈里，每次枚举到 $i$，就将所有值比 $L(i, j)$ 大的弹出来计算。

有代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define FRE(x) freopen(x ".in", "r", stdin), freopen(x ".out", "w", stdout)
#define ALL(x) x.begin(), x.end()
using namespace std;

int _test_ = 1;

const int N = 1e3 + 5;

int n, m, a[N][N], b[N][N], c[N][N]; // L 和 U
pii stk[N]; // 分别存储 L 值和对应 L 值的个数
int top;

void init() {}

void clear() {}

void solve() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
			b[i][j] = c[i][j] = 1;
			b[i][j] += b[i][j - 1] * (a[i][j] == a[i][j - 1]);
			c[i][j] += c[i - 1][j] * (a[i][j] == a[i - 1][j]);
		}
	}
	int ans = 0;
	for (int j = 1; j <= m; j++) {
		int lst = 0;
		for (int i = 1; i <= n; i++) {
			if (c[i][j] == 1) top = 0; // 所有前面的都不需要了，清空栈
			int cnt = 0, tmp = 0; // cnt 为总弹出个数
            // tmp 为弹出的所有数取最小值之后减少了多少
			while (top && stk[top].first > b[i][j])
				cnt += stk[top].second, tmp += (stk[top].first - b[i][j]) * stk[top].second, top--;
			lst = (c[i][j] != 1) * (lst - tmp) + b[i][j]; // 如果 U(i, j) 为 1 则不考虑上一次
			ans += lst;
			stk[++top] = {b[i][j], cnt + 1};
		}
	}
	cout << ans;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
//	cin >> _test_;
	init();
	while (_test_--) {
		clear();
		solve();
	}
	return 0;
}
```

- 时间复杂度：均摊 $\mathcal O(n^2)$。
- 空间复杂度：$\mathcal O (n^2)$。

---

## 作者：zsyzsy_2012 (赞：2)

### 简要题意

给定一个矩阵，求有多少个子矩阵中所有元素完全一样。

### 算法分析

考虑每一列中的所有连通块，这里连通块的意思是连续相等的元素。用一个 $to$ 值代表从每个格子往下走，最远走到哪里，使得从起点到终点是一个连通块。

以下图为例，黑色代表元素值，红色代表 $to$ 值。

![](https://cdn.luogu.com.cn/upload/image_hosting/xiz6kr8l.png)

接下来，我们枚举合法矩阵的第一行与最后一行，分别设为 $l$ 和 $r$。再利用 $to$ 值判断每一列中行号属于 $[l,r]$ 的所有位置是否同属于一个连通块，如果是，这一列可以选，否则不能选。最后枚举所有列号中的一段区间，满足全部是可以选的，并且 $[l,r]$ 中每一列的元素与区间中其他列均一样，设它的长度为 $len$，则这种情况对答案的贡献显然为 $len \times (len - 1) / 2$。上述方法的时间复杂度是立方级别的，可以通过本题的所有测试点。

### AC代码

```
#include <bits/stdc++.h>
#define int long long
#define N 1010
using namespace std ;
int a[N][N] , to[N][N] , ok[N] ;
signed main() {
    int n , m , ans = 0 ;
    scanf("%lld%lld" , &n , &m) ;
    for(int i = 1 ; i <= n ; i++) {
        for(int j = 1 ; j <= m ; j++) {
            scanf("%lld" , &a[i][j]) ;
        }
    }
    for(int i = 1 ; i <= m ; i++) {
        for(int j = 1 ; j <= n ; j++) {
            int k = j ;
            while(a[k][i] == a[j][i]) k++ ;
            for(int u = j ; u < k ; u++) {
                to[u][i] = k - 1 ;
            }
            j = k - 1 ;
        }
    }
    for(int i = 1 ; i <= n ; i++) {
        for(int j = i ; j <= n ; j++) {
            for(int k = 1 ; k <= m ; k++) {
                if(to[i][k] >= j) ok[k] = 1 ;
                else ok[k] = 0 ;
            }
            for(int k = 1 ; k <= m ; k++) {
                if(!ok[k]) continue ;
                int u = k ;
                while(u <= m && ok[u] && (u == k || a[i][u] == a[i][u - 1])) u++ ;
                int len = u - k ;
                ans += ((len + 1) * len / 2) ;
                k = u - 1 ;
            }
        }
    }
    printf("%lld" , ans) ;
    return 0 ;
}
```


---

## 作者：Pro_Rexxar (赞：1)

$O(n^3)$~~的暴力优化后跑的巨快~~

首先我们可以预处理出对于每一个点可以往左延伸出和向上延伸出几个格子

然后对于每一个点先向左延伸，然后再考虑左边的每个点可以向上的格子

|  |  | 1 |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  | 1 | 1 |  |1  |
|  1| 1 | 1 | 1 |  1|

如图当统计右下角时，先把自己向上可延伸的加上，往左边扫的时候，发现会依次受到可向上延伸的格数的最小值的限制

因此为$2+1+1+1+1$

再举个例子

|  |  |  |  | 1 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 |

应为$3+2+2+1+1$

然后考虑优化，如果是一个很斑驳的图（即不同的格子很多），时间复杂度较优秀

但如果很整齐，我们发现可以借前一个格子的状态转移即如果我们当前向上可延伸的格子比前一个格子向上可延伸的格子多，那么可以直接拿前面的转移，就像上图
$3+6$

但如果它是这样的

| 1 |  |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 1 | 1 | 1 |  |
| 1 | 1 | 1 | 1 | 1 |

优化就没用了

这时我们可以考虑奇数行从左往右扫，偶数行从右往左扫，然后就可以卡过去了

```#include <bits/stdc++.h>
#define MAXN 1007
#define LL long long
using namespace std;
int n,m,a[MAXN][MAXN];
LL sum,s[MAXN][MAXN],h[MAXN][MAXN],ans[MAXN][MAXN];
inline int read()
{
	int s=0,w=1; char c=getchar();
	for (;!isdigit(c);c=getchar()) if (c=='-') w=-1;
	for (; isdigit(c);c=getchar()) s=(s<<3)+(s<<1)+(c^48);
	return (s*w);
}
int main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++) a[i][j]=read();
	for (int i=1;i<=n;i++)
		if (i&1)
		{
			for (int j=1;j<=m;j++)
			{
				s[i][j]=h[i][j]=1;
				if (a[i][j]==a[i-1][j]) s[i][j]=s[i-1][j]+1;
				if (a[i][j]==a[i][j-1]) h[i][j]=h[i][j-1]+1;
			}
		}
		else
		{
			for (int j=m;j;j--)
			{
				s[i][j]=h[i][j]=1;
				if (a[i][j]==a[i-1][j]) s[i][j]=s[i-1][j]+1;
				if (a[i][j]==a[i][j+1]) h[i][j]=h[i][j+1]+1;
			}
		}
	for (int i=1;i<=n;i++)
		if (i&1)
		{
			for (int j=1;j<=m;j++)
			{	
				bool b=1;
				ans[i][j]=s[i][j];
				for (int k=j-1;b&&k>=j-h[i][j]+1;k--)
					if (s[i][j]>=s[i][k]) ans[i][j]=ans[i][j]+ans[i][k],b=0;
					else ans[i][j]=ans[i][j]+s[i][j];
				sum=sum+ans[i][j];
			}
		}
		else
		{
			for (int j=m;j;j--)
			{	
				bool b=1;
				ans[i][j]=s[i][j];
				for (int k=j+1;b&&k<=j+h[i][j]-1;k++)
					if (s[i][j]>=s[i][k]) ans[i][j]=ans[i][j]+ans[i][k],b=0;
					else ans[i][j]=ans[i][j]+s[i][j];
				sum=sum+ans[i][j];
			}
		}
	printf("%lld\n",sum);
	return 0;
}
```


---

## 作者：_H17_ (赞：0)

## 题目分析

考虑 DP，但不是平常的矩阵 DP 而是类似于拍平矩阵的线性 DP。

设 $f_{i,j}$ 是前 $i-1$ 行和第 $i$ 行的前 $j-1$ 列，算完后以 $(i,j)$ 为右下角的矩阵。

预处理 $r_{i,j}$ 是 $(i,j)$ 往左（包括自己）的连续相同的数量。

同理 $c$ 表示往上的。

$f_{i,j}=f_{i,j-1}$

然后加上 $j-r_{i,j}+1\sim j$ 的 $c_{i,k}$ 前缀最小值。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,a[1001][1001],row[1001][1001],col[1001][1001],f[1001][1001];
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(a[i][j]!=a[i][j-1])
                row[i][j]=1;
            else
                row[i][j]=row[i][j-1]+1;
        }
    for(int j=1;j<=m;j++)
        for(int i=1;i<=n;i++){
            if(a[i][j]!=a[i-1][j])
                col[j][i]=1;
            else
                col[j][i]=col[j][i-1]+1;
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
        	f[i][j]=((j^1)?f[i][j-1]:f[i-1][m]);
            for(int k=j,minc=0x3f3f3f3f;k>j-row[i][j]&&k>0;k--)
                f[i][j]+=(minc=min(minc,col[k][i]));
            //cerr<<f[i][j]<<" \n"[j==m];
        }
    cout<<f[n][m];
    return 0;
}
```

---

## 作者：ModestCoder_ (赞：0)

一开始考虑到悬线法，但是我忘了，所以我就自己创新

假设我已经扣出了一个相同颜色的连通块
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201021204247874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vZGVzdENvZGVyXw==,size_16,color_FFFFFF,t_70#pic_center)

计算答案

对于第一列，答案贡献是$4*1$

第二列答案是$3*1$

第三列答案是$2*2$

第四列答案是$2*1$

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201021204450645.png#pic_center)

第一列答案是$2*4$

第二列答案是$2*3$

第三列答案是$3*2$

第四列答案是$4*1$

可以直接$O(n^2)$扫过来

对于每一列的点，用$upex_j$维护往上扩展最远能到哪里
用单调栈维护上述过程

我还加了个离散化，现在才发现离散了个寂寞

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1010
#define LL long long
using namespace std;
struct data{
	int val, id;
}val[maxn * maxn];
int n, m, a[maxn][maxn];
LL tot[maxn], upex[maxn], cnt, sum, ans, stk[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int id(int x, int y){ return (x - 1) * m + y; }
bool cmp(data x, data y){ return x.val < y.val; }

int main(){
	freopen("bob.in", "r", stdin);
	freopen("bob.out", "w", stdout);
	n = read(), m = read();
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j){
			int Id = id(i, j);
			val[Id].val = read(), val[Id].id = Id;
		}
	sort(val + 1, val + n * m + 1, cmp);
	int p = 0; val[0].val = val[1].val - 1;
	for (int i = 1; i <= n * m; ++i){
		if (val[i].val != val[i - 1].val) ++p;
		int Id = val[i].id, x = (Id - 1) / m + 1, y = (Id - 1) % m + 1;
		a[x][y] = p;
	}
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j){
			if (a[i - 1][j] != a[i][j]) upex[j] = i;
			if (a[i][j] != a[i][j - 1] || j == 1){
				sum = 0, cnt = 0;
			}
			int h = i - upex[j] + 1, newtot = 1;
			sum += h;
			while (cnt > 0 && stk[cnt] >= h) 
				sum -= tot[cnt] * (stk[cnt] - h), newtot += tot[cnt], --cnt;
			stk[++cnt] = h, tot[cnt] = newtot;
			ans += sum;
		}
	printf("%lld\n", ans);
	return 0;
}
```



---


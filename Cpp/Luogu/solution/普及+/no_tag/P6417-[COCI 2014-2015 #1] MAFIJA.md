# [COCI 2014/2015 #1] MAFIJA

## 题目描述

有 $n$ 个人，其中有一些人是平民，有一些人是坏蛋。

现在，平民们想揪出所有的坏蛋，于是 $n$ 个人都指认了一个人是坏蛋。

如果一个人是平民，他会随便乱指认，否则，他会指认一个平民。

求出最多的坏蛋个数。

## 说明/提示

#### 样例解释
#### 样例输入输出 1 解释
坏蛋可以是第 $2$ 个人和第 $3$ 个人。
#### 样例输入输出 2 解释
坏蛋可能是所有人，但是只能是其中的一个人，因为再多一个坏蛋的话会有坏蛋指控坏蛋的情况发生。

#### 数据范围与限制
- 对于 $40$ 分的数据，保证 $n\le 15$。
- 对于 $80$ 分的数据，保证 $n\le 2\times 10^4$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$1\le k\le n$。

#### 说明
**本题总分 $120$ 分。**

本题译自 [Croatian Open Competition in Informatics 2014/2015](https://hsin.hr/coci/archive/2014_2015) [Contest #1](https://hsin.hr/coci/archive/2014_2015/contest1_tasks.pdf) T4 MAFIJA。

## 样例 #1

### 输入

```
3
2
1
1
```

### 输出

```
2```

## 样例 #2

### 输入

```
3
2
3
1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
7
3
3
4
5
6
4
4```

### 输出

```
4```

# 题解

## 作者：Randyhoads (赞：11)

[更好的体验？](https://www.cnblogs.com/wlzs1432/p/13864339.html)

贪心

把指认的关系当做边连边，把坏蛋当做染成1，好人当做染成0

由于坏蛋不能连坏蛋，与1相连的点一定为0

假如是一条链的话，显然交叉染色，从链尾开始染更优

把链扩展成树，发现每次把入度为0的点染成1一定最优

但是实际上有可能出现环

考虑为环的情况，如果环上的点都没有限制，显然随便选一个点染成0，这个点两边染色就没有限制了，就断成链了

考虑环上的点有限制的情况，即为基环树的情况

还是从入度为0的点开始染，环上有点被确定染成了0那么这个环显然就被断成链了，就按找链的方式贪心即可

所以可以设计出这样一个贪心算法

每次把入度为0且没有确定下来的点染成1，这样最后剩下的一定是几个独立的环

每次随便选环上一点染成0，把环断成链即可


```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read()
{
    int f = 1,x = 0;
    char ch;
    do
    {
        ch = getchar();
        if(ch == '-') f = -1;
    }while(ch < '0'||ch > '9');
    do
    {
        x = (x<<3) + (x<<1) + ch - '0';
        ch = getchar();
    }while(ch >= '0'&&ch <= '9');
    return f*x;
}

const int MAXN = 5e5 + 10;

int n;
int a[MAXN];
int deg[MAXN]; 
bool vis[MAXN];
int ans;

inline void dfs(int x,int col)
{
    if(vis[x]) return;
    vis[x] = 1; 
    ans += col;
    deg[a[x]]--;
    if((!deg[a[x]])||col == 1) dfs(a[x],col^1);
}

int main()
{
    n = read();
    for(int i=1;i<=n;i++) a[i] = read(),deg[a[i]]++;
    for(int i=1;i<=n;i++) if(!deg[i]) dfs(i,1);
    for(int i=1;i<=n;i++) if(!vis[i]) dfs(i,0);
    cout << ans << endl;
}

```




---

## 作者：LJQ0808 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P6417)

# 题解
## 贪心
我们可以发现从没有被指认的人开始，可以像拓扑排序一样，分为一层层。

例如，

```
1 -> 3
2 -> 3
3 -> 4
```

则 $1,2$ 为第 $1$ 层，$3$ 为第 $2$ 层，$4$ 为第 $3$ 层。

将奇数层的人变为坏蛋，才能使坏蛋最多。这是为什么呢？

不妨设，第 $i$ 层的人数为 $s_i$，一共有 $k$ 层。

因为坏蛋指认一个平民，所以贪心选 $s_1 + s_3 + s_5 + ...... + s_{n \times 2 + 1} [n \times 2 + 1 \ge k]$ 或 $s_2 + s_4 + s_6 + ...... + s_{n \times 2} [n \times 2\ge k]$。

又因为每个人都只会指认一个人，有 $s_i\ge s_{i+1} [i < k]$。 

所以，选 $s_1 + s_3 + s_5 + ...... + s_{n \times 2 + 1} [n \times 2 + 1 \ge k]$ 最优。

但有可能有环该怎么办呢？

那我们可以让环的其中一个为平民，就变为了上面的情况。

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n;
int a[N];
bool vis[N];//vis[i] 表示第 i 个节点有没有访问过。 
int ans=0;//最后的答案。 
int deg[N];//deg[i] 表示第 i 个节点的入度。 
void dfs(int u,bool c){
	if(vis[u]){//已经访问过了。 
		return;
	}
	vis[u]=1;//标记。
	if(c){
		ans++;//加答案。
	} 
	int v=a[u];
	if(--deg[v]==0 || c){//入度为 0 时，像拓扑排序扩展；c 为 1 的时候要反色。 
		dfs(v,c^1);//反色。 
	} 
}
signed main(){
	//HAPPY!
	cin.tie(0);
	cout.tie(0);
	ios_base::sync_with_stdio(0);
	//平民为 0，坏蛋为 1。 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		deg[a[i]]++;
	}
	for(int i=1;i<=n;i++){
		if(!deg[i]){//入度为 0 时，像拓扑排序从叶子节点开始。 
			dfs(i,1);
		}
	} 
	for(int i=1;i<=n;i++){
		if(!vis[i]){//有环。 
			dfs(i,0);
		}
	} 
	cout<<ans<<"\n";
	return 0;
}
```

## 基环森林加树上 dp
我们可以发现此题为 $n$ 个点和 $n$ 条边，每个节点的出度为 $1$，如果图不连通但是每个连通块点数都等于边数的时候这个图，故为基环森林。

并且求最多的坏蛋个数，于是可以加上树上 dp。

设 $dp_{u,0/1}$ 表示以 $u$ 为子树，为平民或坏蛋的最多的坏蛋个数。

如果只算一次 dp，则有一组 hack。

hack:

input:
```
4
2 1 4 3
```

output:

```
2
```

所以对于每个基环树，都做树上 dp。

将所有的基环树的答案加起来就为总答案。

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n;
int fa[N];
int find(int x){
	if(fa[x]==x){
		return x;
	}
	return fa[x]=find(fa[x]);
} 
void join(int x,int y){
	int u=find(x),v=find(y);
	if(u!=v){
		fa[u]=v;
	}
}
int head[N],to[N<<1],nxt[N<<1],tot;
void init(){
	memset(head,-1,sizeof(head));
	tot=0;
}
void add_edge(int u,int v){
	to[++tot]=v,nxt[tot]=head[u],head[u]=tot;
}
void add_und_edge(int u,int v){
	add_edge(u,v);add_edge(v,u);
}
int dp[N][2];
void dfs(int u,int f){
	dp[u][0]=0,dp[u][1]=1;
	for(int i=head[u];~i;i=nxt[i]){
		int v=to[i];
		if(v!=f){
			dfs(v,u);
			dp[u][0]+=max(dp[v][0],dp[v][1]);
			dp[u][1]+=dp[v][0];
		}
	}
} 
int l[N],r[N];
int cnt=0;
signed main(){
	//HAPPY!
	cin.tie(0);
	cout.tie(0);
	ios_base::sync_with_stdio(0);
	init();
	cin>>n;
	for(int i=1;i<=n;i++){
		fa[i]=i;
	}
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		if(find(i)==find(x)){
			l[++cnt]=i,r[cnt]=x;
			continue;
		}
		join(i,x);
		add_und_edge(i,x);
	}
	int ans=0;
	for(int i=1;i<=cnt;i++){
		dfs(l[i],0);
		int mx=dp[l[i]][0];
		dfs(r[i],0);
		mx=max(mx,dp[r[i]][0]);
		ans+=mx;
	} 
	cout<<ans<<"\n";
	return 0;
}
```

用基环森林加树上 dp 时，存图要用链式前向星，不然会爆空间。

[二倍](https://qoj.ac/contest/2021/problem/10734)[经验](https://www.luogu.com.cn/problem/P11501)

---

## 作者：快斗游鹿 (赞：2)

## 思路

考虑贪心。按指认关系建图。注意到图上每个点出度均为 $1$，那么每次贪心地把入度为 $0$ 的点取出来，如果它能成为坏人，就让它成为坏人，这样显然是最优的。

但是图上可能会有环，但是如果一个点被确定为平民，那么它在环上也不会有什么影响，因为平民可以指认任何人，而任何人都可以指认平民，继续上述过程即可。

最后处理剩下的环即可。可以先钦定一个点为平民，剩下的点同样可以直接贪心。

代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n,d[N],e[N],vis[N],ans;
bool flag[N];
void solve(int u,int col){
    if(vis[u])return;
    vis[u]=1;
    d[e[u]]--;
    ans+=col;
    if(!d[e[u]]||col==1)solve(e[u],col^1);
}
int main(){
    //freopen("std.in","r",stdin);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>e[i];d[e[i]]++;
    }
    for(int i=1;i<=n;i++){
        if(!d[i])solve(i,1);
    }
    for(int i=1;i<=n;i++){
        if(!vis[i])solve(i,0);
    }
    cout<<ans;
    return 0;
}



```


---

## 作者：August_Light (赞：2)

# P6417 [COCI2014-2015#1] MAFIJA 题解

[题目传送门](https://www.luogu.com.cn/problem/P6417)

## 写在前面

这个典题除了贪心和 DP 难道还有其它做法吗？我两次因为解法重复被退回了（悲）。

管理大大给个通过罢。

## 题意简述

给定一个 $n$ 个节点的[基环内向森林](https://oi-wiki.org/graph/concept/#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%9B%BE)，每个点的权值为 $1$，求其最大独立集。

## 前置知识

- 树形 DP
  - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

## 解法

考虑 DP。DP 相对于贪心可以解决更一般的情况，即每个点的权值不一定相同。

首先我们要找到基环树上的环。可以参考这题 [Subway](https://www.luogu.com.cn/problem/CF131D)。（夹带私货：[Subway 题解](https://www.luogu.com.cn/blog/August-Light/CF131D-Solution)）

找到环之后基环树就被分成了一个环和一个一个一个树。

大致像这样。其中 $3-4-5-6$ 是一个环，红色的部分为一个一个一个树。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ux8mert.png)

然后我们对每个树做一遍没有上司的舞会。

此时所有的答案聚集到了这个环上。环上同样需要选出的是一个独立集。考虑环形 DP。

首先断环成链：考虑链上最大独立集。

你都会做树上最大独立集了，链上肯定会：

令 $f_{i,0/1}$ 为 $[1,i]$ 区间是否取第 $i$ 项的最大独立集。

转移方程：

$$f_{i,0}=\max(f_{i-1,0}, f_{i-1,1})$$

$$f_{i,1}=f_{i-1,0}+a_i$$

环上只需要特殊考虑 $1$ 和 $n$。如果 $1$ 选则 $n$ 不选，如果 $1$ 不选则 $n$ 选不选都行。

模板题：[T321589 环上最大独立集](https://www.luogu.com.cn/problem/T321589)

时间复杂度 $O(n)$。

## 代码

注意图不一定连通。

注意空间限制（32 MB）。（详情见这个帖子：[求调 or 请求开大空间限制？](https://www.luogu.com.cn/discuss/617560)）因为是 DP 做法而非其它题解中的贪心做法，所以空间常数较大，最后一个点可能 MLE。~~我的这份代码 31.95 MB 刚好 AC~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

// 省略快读快写的实现

const int MAXN = 5e5 + 100;
const int MAXM = MAXN << 1;
const LL INF = 0x7f7f7f7f7f7f7f7f;

int n, a[MAXN];

struct Edge {
    int to, nxt;
} e[MAXM];
int head[MAXN], cnt = 1;
void addedge(int u, int v) {
    e[++cnt].to = v;
    e[cnt].nxt = head[u];
    head[u] = cnt;
}

namespace find_ring {
    bool vis[MAXN], on_ring[MAXN];
    int fa[MAXN];
    vector<int> ring;
    void dfs(int u, int lst) {
        vis[u] = 1;
        for (int i = head[u]; i; i = e[i].nxt) {
            if (i == (lst ^ 1))
                continue;
            int v = e[i].to;
            if (!vis[v]) {
                fa[v] = u;
                dfs(v, i);
            } else if (!on_ring[v]) {
                on_ring[u] = 1; ring.push_back(u);
                int c = u; do {
                    c = fa[c];
                    on_ring[c] = 1; ring.push_back(c);
                } while (c != v);
            }
        }
    }
}
using find_ring::on_ring;
using find_ring::ring;

namespace P1352 { // 没有上司的舞会
    LL f[MAXN][2];
    void dfs(int u, int lst) {
        f[u][0] = 0;
        f[u][1] = a[u];
        for (int i = head[u]; i; i = e[i].nxt) {
            if (i == (lst ^ 1))
                continue;
            int v = e[i].to;
            if (on_ring[v])
                continue;
            dfs(v, i);
            f[u][0] += max(f[v][0], f[v][1]);
            f[u][1] += f[v][0];
        }
    }
}

namespace DP_on_ring {
    LL a[MAXN];
    LL f[MAXN][2];
    LL work() {
        int n = ring.size();
        for (int i = 1; i <= n; i++) {
            int u = ring[i-1];
            a[i] = P1352::f[u][1] - P1352::f[u][0];
        }
        // a[i] 为取和不取的答案之差，变为真正的环上最大独立集问题
        // 虽然有点蠢

        f[1][0] = -INF;
        f[1][1] = a[1];
        for (int i = 2; i <= n; i++) {
            f[i][0] = max(f[i-1][0], f[i-1][1]);
            f[i][1] = f[i-1][0] + a[i];
        }
        LL ans = f[n][0];

        memset(f, 0, sizeof(f));

        // 不选 1
        f[1][0] = 0;
        f[1][1] = -INF;
        for (int i = 2; i <= n; i++) {
            f[i][0] = max(f[i-1][0], f[i-1][1]);
            f[i][1] = f[i-1][0] + a[i];
        }
        ans = max(ans, max(f[n][0], f[n][1]));
        for (auto u : ring)
            ans += P1352::f[u][0];
        return ans;
    }
}

int main() {
    n = read();
    for (int u = 1; u <= n; u++) {
        a[u] = 1; int v = read();
        addedge(u, v); addedge(v, u);
    }
    LL ans = 0;
    for (int u = 1; u <= n; u++) {
        if (find_ring::vis[u])
            continue;
        ring.clear();
        find_ring::dfs(u, 0);
        for (auto u : ring)
            P1352::dfs(u, 0);
        ans += DP_on_ring::work();
    }
    cout << ans << endl;
}
```

## 三倍经验

DP 做法可过。

[P1453 城市环路](https://www.luogu.com.cn/problem/P1453)

[P2607 [ZJOI2008] 骑士](https://www.luogu.com.cn/problem/P2607)

---

## 作者：JK_LOVER (赞：2)

## 题意
$n$ 个点，连出 $n$ 条边。求基环树森林上的最的最大团。
## 分析
我们可以如果两点有边相连那么这俩个点是没法在同一个集合中的。（坏蛋是没法指向坏蛋的，所以有边的话就不会两个都是坏蛋了）。那么我们可以将构成环的点放入。
$$
dp[x][1] = \sum^{y\in son}_ y dp[y][0]+1
$$
$$
dp[x][0] = \sum_y^{y\in son}\max(dp[y][1],dp[y][0])
$$
$$
ans = \sum^{}_ {x,y\in U}\max(dp[x][0],dp[y][0])
$$
用并查集来维护环。$dp[x][1]$ 表示 $x$ 是坏蛋时，包括它和它的子树的最大团的个数。 $dp[x][0]$ 表示 $x$ 是平民时的最大值。
## 代码
```cpp
#include<bits/stdc++.h>
#define N 1000005
#define ll long long
using namespace std;
int head[N],nextt[N<<1],to[N<<1];
int n,cnt=1,num;

int fa[N],edg[N],a[N],b[N];
ll valu[N];
ll ans=0,f[N][2];
int vis[N<<1];
inline ll maxx(ll a,ll b)
{return a>b?a:b;}
inline void add(int u,int v)
{
    nextt[++cnt]=head[u];
    to[cnt]=v;head[u]=cnt;
}
inline int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    return x;
}
inline void dp(int u,int fa)
{
    f[u][0]=0;f[u][1]=valu[u];
    for(int i=head[u];i;i=nextt[i])
    {
        int v=to[i];
        if(vis[i]||vis[i^1]||v==fa) continue;
        dp(v,u);
        f[u][1]+=f[v][0];
        f[u][0]+=maxx(f[v][0],f[v][1]); 
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=n;i++)
    {
        int v;
        scanf("%d",&v);valu[i]=1;
        add(i,v);add(v,i);
        int f1=find(i),f2=find(v);
        if(f1==f2) 
        {
            a[++num]=i;b[num]=v;
            edg[num]=(cnt^1);
        }
        else fa[f1]=f2;
    }
    for(int i=1;i<=num;i++)
    {
        vis[edg[i]]=vis[edg[i]^1]=true;
        ll tmp=0;
        dp(a[i],0);tmp=f[a[i]][0];
        dp(b[i],0);tmp=maxx(tmp,f[b[i]][0]);
        ans+=tmp;
        vis[edg[i]]=vis[edg[i]^1]=false;
    }
    printf("%lld",ans);
    return 0;
}
```
[地址](https://www.luogu.com.cn/blog/xzc/solution-p6417)

---

## 作者：__Ginka__ (赞：0)

### 思路大意

可以将这些指认关系看作一个有向图，图中的每个节点代表一个人，图中的每条边代表一个人指认另一个人为坏蛋。每个人只指认一个人，因此图中每个节点的出度为 $ 1$，且图中有 $n$ 个节点和 $n$ 条边。

所以我们需要找出其中的强连通分量，并计算每个分量中最多的坏蛋数量。

#### 1.基环森林
每个人的指认关系可以看作图中的有向边，多个节点之间可能形成环。若一组节点之间相互指认，形成一个强连通分量（即基环）。对于每个环中的节点，若其中有坏蛋，则这些坏蛋的数量是我们需要计算的目标。

#### 2.拓扑

拓扑排序可以帮助我们找出有向图中哪些节点不属于环。拓扑排序按照节点的入度顺序逐步处理，每次选择入度为 $0$ 的节点，直到所有节点都被处理完。对拓扑排序的结果进行分析，可以识别出图中的强连通分量（环）。

#### 3.dp

动态规划的状态可以表示为：

$dp[u][0]$：以节点 $u$ 为根的子树中，假设节点 $u$ 为平民时，能够达到的最大坏蛋数量。

$dp[u][1]$：以节点 $u$ 为根的子树中，假设节点 $u$ 为坏蛋时，能够达到的最大坏蛋数量。

**状态转移方程：**

对于一个节点 $u$，假设它有指向节点 $v$ 的边：
   
$dp[u][0]=dp[v][0]+\max(dp[v][0],dp[v][1])$

$dp[u][1]=dp[v][0]+dp[v][1]$

相信思路已经解释的很清楚了，代码中就不放注释了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long maxn=5e5+10;
int to[maxn],dp[maxn][2],in[maxn],cc[maxn],hea[maxn],nxt[maxn],dir[maxn],ee,n,ans;
bool vis[maxn];
long long f[maxn][2];
void topo()
{
    queue<long long> q;
    for(long long i=1;i<=n;i++)
        if(in[i]==0) q.push(i);
    while(!q.empty())
    {
        long long u=q.front();
        q.pop();
        long long v=to[u];
        in[v]--;
        if(in[v]==0) q.push(v);
	}
    for(long long i=1;i<=n;i++)
        if(in[i]) cc[i]=1;
}
void dpf(long long u)
{
    dp[u][1]=1;
    for(long long i=hea[u];i;i=nxt[i])
    {
        long long v=dir[i];
        if(cc[v]) continue;
        dpf(v);
        dp[u][0]+=max(dp[v][0], dp[v][1]);
        dp[u][1]+=dp[v][0];
    }
}
void pre_dp(long long u)
{
    long long kaishi=u;
    vis[u]=1;
    dpf(u);
    u=to[u];
    while (u!=kaishi)
    {
        vis[u]=1;
        dpf(u);
        u=to[u];
    }
}
long long solve(long long u,long long op)
{
    long long kaishi=u,lst=u;
    f[u][op]=dp[u][op],u=to[u];
    for(;u!=kaishi;u=to[u])
    {
        f[u][0]=max(f[lst][0], f[lst][1])+dp[u][0];
        f[u][1]=f[lst][0]+dp[u][1];
        lst=u;
    }
    if(op==0) return max(f[lst][0],f[lst][1]);
    return f[lst][0];
}
void tc(long long u)
{
    while(vis[u]==0) vis[u]=1,u=to[u];
}
int main()
{
    scanf("%d",&n);
    for(long long i=1;i<=n;i++)
    {
        scanf("%d",&to[i]);
        ee++;
        long long u=to[i],v=i;
        dir[ee]=v;
        nxt[ee]=hea[u];
        hea[u]=ee;
        in[to[i]]++;
    }
    topo();
    for(long long i=1;i<=n;i++)
        if(cc[i]&&vis[i]==0)
            pre_dp(i);
    for(long long i=1;i<=n;i++) vis[i]=0;
    for(long long i=1;i<=n;i++)
        if(cc[i]&&vis[i]==0)
        {
            long long cnt=0;
            cnt=max(cnt,solve(i,0));
            cnt=max(cnt,solve(i,1));
            tc(i);
            ans+=cnt;
        }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Suite_No1_G (赞：0)

~~2024 年的第一篇题解：）~~

分析：

可以将指认关系看成有向边。$n$ 个点，$n$ 条边，所以这是一个基环森林。

所以对于每一个基环树，先找到它的环，这里可以用拓扑排序实现。环上的点即为入度不为 $0$ 的点。

然后，对于环上的每一个节点，通过 dp 把以它为根的子树内的情况求出来。

具体地，设 $dp_{i,0/1}$ 代表以 $i$ 为根，$i$ 不是/是坏蛋的情况的坏蛋最大个数。

然后，在环上任取一个点作为起点，在环上 dp，即可求出答案。

环上 dp 的状态：$dp_{i,0/1}$ 表示第 $i$ 个点不是/是坏蛋的最大坏蛋个数。

然后，因为这是一个环，记得保证起点和终点的关系合法。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=5e5+10;
int to[maxn];
int n;
int dp[maxn][2];
int in[maxn];
bool on_circle[maxn];
int head[maxn],nxt[maxn],dir[maxn];
int E=0;

bool vis[maxn];
int f[maxn][2];

void topo(){//拓扑排序，找环
	queue<int> q;
	for (int i=1;i<=n;i++){
		if (in[i]==0) q.push(i); 
	}
	
	while (!q.empty()){
		int u=q.front(); q.pop();
		int v=to[u];
		in[v]--;
		if (in[v]==0) q.push(v);
	}
	
	for (int i=1;i<=n;i++){
		if (in[i]) on_circle[i]=1;
	}
}

void DP(int u){
	dp[u][1]=1;
	for (int i=head[u];i;i=nxt[i]){
		int v=dir[i];
		if (on_circle[v]) continue;//dp 的节点应该是不在环上的节点
		
		DP(v);
		dp[u][0]+=max(dp[v][0],dp[v][1]);
		dp[u][1]+=dp[v][0]; 
	}
}

void pre_dp(int u){//将环上的每一个节点都做一遍 dp
	int start=u;
	vis[u]=1;
	DP(u);
	u=to[u];
	while (u!=start){
		vis[u]=1;
		DP(u);
		u=to[u];
	}
}

int solve(int u,int op){//求解，op=0代表u是好人，op=1代表坏蛋
	int start=u;
	f[u][op]=dp[u][op];
	int lst=u;
	u=to[u];
	
	for (;u!=start;u=to[u]){
		f[u][0]=max(f[lst][0],f[lst][1])+dp[u][0];
		f[u][1]=f[lst][0]+dp[u][1];
		lst=u;
	}
	
	if (op==0) return max(f[lst][0],f[lst][1]);//坏人和好人都可以指向好人
    return f[lst][0];//只有好人能指向坏人
}

void fill(int u){//打标记，避免重复遍历
	while (vis[u]==0){
		vis[u]=1;
		u=to[u];
	}
}

int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%d",&to[i]);
		E++;
		int u=to[i],v=i;
		dir[E]=v;
		nxt[E]=head[u];
		head[u]=E;//链式向前星，用vector会MLE
		
		in[to[i]]++;
	}
	
	topo();
//	for (int i=1;i<=n;i++) printf("%d ",on_circle[i]);
	for (int i=1;i<=n;i++){
		if (on_circle[i]&&vis[i]==0){
			pre_dp(i);
		}
	}
	
//	for (int i=1;i<=n;i++){
//		if (on_circle[i]) printf("%lld: %lld %lld\n",i,dp[i][0],dp[i][1]);
//	}
	
	int ans=0;
	for (int i=1;i<=n;i++) vis[i]=0;
	for (int i=1;i<=n;i++){
		if (on_circle[i]&&vis[i]==0){
			int cnt=0;
			cnt=max(cnt,solve(i,0));
			cnt=max(cnt,solve(i,1));
			fill(i);
			ans+=cnt;
		}
	}
	
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：xiaolu12356 (赞：0)

## 本篇题解来自百度
### 题意

给定一个 $ n $ 个节点的图，每个点有且仅有一条出边，选取最多的点使得没有边连接相邻两个选中点。
$ 1 \le n \le 600000 $。

### 思路

把图当无向图看，就是求无向图中的最大独立集。但这张图不是一般的图，它是一棵“基环内向树”，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/nw3zo2o4.png)

这种图最明显的特征就是每个点只有一条出边，根据这个性质，每个点按边的指向 $\operatorname{dfs}$，总能遇到一个环，基环外向树则反之。而对于一个连通块而言，拆去环上的一条边，形成的无向图是一棵树。这些性质为树形 $\operatorname{DP}$ 和贪心提供了条件。

树上的最大独立集就是简单的“取与不取”的转移，想要求解必须要转化成树的问题。我们可以通过分析答案来决定决策（终态分析），任意拆去环上的一条边 $ (a,b) $ 最后的答案中 $ a,b $ 中至少有一个点不取，那我们断去 $ (a,b) $ 边后，以 $ a $ 为根，以 $ b $ 为根分别 $\operatorname{dp}$ 一次，分别取 $dp_{a,0},dp_{b,0}$，再取 $\max$。最后把所有连通块的答案相加即可。其中因为只需任意拆一条边，也只用拆一条边，可以在并查集并边的时候，不连接将会成环的边，并存下这条边即可。这种写法在基环树转一般树的写法中有拓展性。

贪心的写法正确性不是那么显然。首先对于环外的情况，肯定是挑入度为零的点，可以证明假设挑入度更大的点没有入度为零的点优。那就可以按照这个步骤隔一个的挑点。假设标到了环上的点，那就可以直接把环剖开了，最后把没剖开的环重新剖一次。只需要用一个 $\text{vis}$ 数组去标记遍历过的点，然后传一个参数表示这个点选不选，同时统计答案。

### 代码
 
 
#### 树形DP
```cpp
#include<bits/stdc++.h>
#define FOR(i,x,y) for(int i=(x),i##END=(y);i<=i##END;++i)
#define DOR(i,x,y) for(int i=(x),i##END=(y);i>=i##END;--i)
typedef long long LL;
using namespace std;
const int N=1e6;
template<const int maxn,const int maxm>struct Linked_list
{
    int head[maxn],to[maxm],nxt[maxm],tot;
    void clear(){memset(head,-1,sizeof(head));tot=0;}
    void add(int u,int v){to[++tot]=v,nxt[tot]=head[u],head[u]=tot;}
    #define EOR(i,G,u) for(int i=G.head[u];~i;i=G.nxt[i])
};
Linked_list<N,N<<1>G;
int fa[N],n;
int getfa(int k){return k==fa[k]?k:fa[k]=getfa(fa[k]);}
bool mer(int x,int y){
    int fx=getfa(x),fy=getfa(y);
    if(fx==fy)return 0;
    fa[fx]=fy;
    return 1;
}
int To[N],dp[N][2],ans;
int ra[N],rb[N],cnt;
 
void dfs(int u,int f){
    dp[u][0]=0,dp[u][1]=1;
    EOR(i,G,u){
        int v=G.to[i];
        if(v==f)continue;
        dfs(v,u);
        dp[u][0]+=max(dp[v][0],dp[v][1]);
        dp[u][1]+=dp[v][0];
    }
}
 
int main(){
    G.clear();
    int n;
    scanf("%d",&n);
    FOR(i,1,n)fa[i]=i;
    FOR(i,1,n){
        scanf("%d",&To[i]);
        if(mer(i,To[i])){
            G.add(i,To[i]);
            G.add(To[i],i);
        }
        else cnt++,ra[cnt]=i,rb[cnt]=To[i];
    }
    FOR(i,1,cnt){
        dfs(ra[i],0);
        int maxer=dp[ra[i]][0];
        dfs(rb[i],0);
        maxer=max(maxer,dp[rb[i]][0]);
        ans+=maxer;
    }
    printf("%d\n",ans);
    return 0;
}
```

#### 贪心

```cpp
#include<bits/stdc++.h>
#define FOR(i,x,y) for(int i=(x),i##END=(y);i<=i##END;++i)
#define DOR(i,x,y) for(int i=(x),i##END=(y);i>=i##END;--i)
typedef long long LL;
using namespace std;
const int N=1e6;
int To[N],ind[N],n,ans;
bool vis[N];
 
void dfs(int u,bool kl){
    if(vis[u])return;
    vis[u]=1;
    ans+=kl;
    ind[To[u]]--;
    if(!ind[To[u]]||kl)dfs(To[u],!kl);
}
 
int main(){
    scanf("%d",&n);
    FOR(i,1,n)scanf("%d",&To[i]),ind[To[i]]++;
    FOR(i,1,n)if(!ind[i])dfs(i,1);
    FOR(i,1,n)dfs(i,0);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：ModestCoder_ (赞：0)

思路源自luogu初赛模拟卷

贪心从每个入度为0的点开始遍历，删边

整张图就剩下一个环，再处理一下环的情况

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 500010
using namespace std;
int n, d[maxn], nxt[maxn], vis[maxn], ans;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void dfs(int u, int sta){
	if (vis[u]) return;
	vis[u] = 1;
	if (!d[u] && sta) ++ans;
	--d[nxt[u]];
	if (!d[nxt[u]] || sta) dfs(nxt[u], sta ^ 1);
}

int main(){
	freopen("mafija.in", "r", stdin);
	freopen("mafija.out", "w", stdout);
	n = read();
	for (int i = 1; i <= n; ++i) nxt[i] = read(), ++d[nxt[i]];
	for (int i = 1; i <= n; ++i)
		if (!d[i]) dfs(i, 1);
	for (int i = 1; i <= n; ++i)
		if (!vis[i]) dfs(i, 0);
	printf("%d\n", ans);
	return 0;
}
```


---


# [COCI 2011/2012 #6] PASTELE

## 题目背景

## 警告：滥用本题评测将被封号。

Mirko 收到了一份礼物。



## 题目描述

这份礼物共包含 $n$ 支蜡笔。每只蜡笔的颜色由色光三原色组成：红、绿、蓝。分别用参数 $R_i,G_i,B_i$ 表示。这只蜡笔的颜色就由这三个参数来决定。

对于两支蜡笔 $i,j$，我们定义它们之间的差异值为 $\max(|R_i-R_j|,|G_i-G_j|,|B_i-B_j|)$。定义一些蜡笔的色彩值为这些蜡笔中任意两支蜡笔差异值的最大值。

给出这 $n$ 支蜡笔的特征值，请找出 $k$ 支蜡笔，使得色彩值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $R_i,G_i,B_i\le 20$；
- 对于另 $30\%$ 的数据，保证 $R_i,G_i,B_i\le 50$；
- 对于 $100\%$ 的数据，保证 $2\le k\le n\le 10^5$，$0\le R_i,G_i,B_i\le 256$，$0\le k_i\le m$。

#### 提示

请注意常数因子对程序效率造成的影响。

#### 说明

**题目译自 [COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #6](https://hsin.hr/coci/archive/2011_2012/contest6_tasks.pdf) *T5 PASTELE***。

## 样例 #1

### 输入

```
2 2
1 3 2
2 6 4```

### 输出

```
3
1 3 2
2 6 4```

## 样例 #2

### 输入

```
3 2
3 3 4
1 6 4
1 1 2```

### 输出

```
2
3 3 4
1 1 2```

## 样例 #3

### 输入

```
5 3
6 6 4
6 2 7
3 1 3
4 1 5
6 2 6```

### 输出

```
2
6 2 7
4 1 5
6 2 6```

# 题解

## 作者：b6e0_ (赞：9)

这题因为值域很小，所以可以三维前缀和（容斥）做。将一支蜡笔看作三维空间中的一个点 $(R_i,G_i,B_i)$。二分答案，设二分到了 $M$，枚举这三维区间的左端点 $i,j,k$，那么对点 $(x,y,z)$ 的限制就是 $x\in[i,i+M],y\in[j,j+M],z\in[k,k+M]$，用三维前缀和 $\mathcal O(1)$ 求出在这个空间内的点数，判断够不够即可。

对于构造方案，在判断时记下是哪个区间中的点数不小于这个答案，构造时扫描 $n$ 个点判断是否在这个区间即可。

三维前缀和的预处理公式是:

$$s_{i,j,k}=s_{i-1,j,k}+s_{i,j-1,k}+s_{i,j,k-1}-s_{i,j-1,k-1}-s_{i-1,j,k-1}-s_{i-1,j-1,k}+s_{i-1,j-1,k-1}+a_{i,j,k}$$

使用三维前缀和表示第一维在 $[i_1,i_2]$，第二维在 $[j_1,j_2]$，第三维在 $[k_1,k_2]$ 的点数为：

$$s_{i_2,j_2,k_2}-s_{i_1,j_2,k_2}-s_{i_2,j_1,k_2}-s_{i_2,j_2,k_1}+s_{i_2,j_1,k_1}+s_{i_1,j_2,k_1}+s_{i_1,j_1,k_2}-s_{i_1,j_1,k_1}$$

设 $R_i,G_i,B_i$ 的值域为 $m$，时间复杂度 $\mathcal O(m^3\log m)$。代码：
```cpp
#include<bits/stdc++.h>
using namepace std;
int m,a[260][260][260],s[260][260][260],R[100010],G[100010],B[100010],ansi,ansj,ansk;
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+c-'0';
		c=getchar();
	}
	return x;
}
void write(int x)
{
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
inline bool check(int M)
{
	for(int i=1;i+M<257;i++)//之所以i,j,k<=256-M是因为假如i超过了，那么点数明显小于为256-M的情况（区间更小）
		for(int j=1;j+M<257;j++)
			for(int k=1;k+M<257;k++)
				if(s[i+M][j+M][k+M]-s[i-1][j+M][k+M]-s[i+M][j-1][k+M]-s[i+M][j+M][k-1]+s[i+M][j-1][k-1]+s[i-1][j+M][k-1]+s[i-1][j-1][k+M]-s[i-1][j-1][k-1]>=m)
				{
					ansi=i;
					ansj=j;
					ansk=k;//记录下可行的区间
					return true;
				}
	return false;
}
int main()
{
	int n=read(),i,j,k,L=-1,r=255,M;
	m=read();
	for(i=1;i<=n;i++)
	{
		R[i]=read();
		G[i]=read();
		B[i]=read();
		a[R[i]+1][G[i]+1][B[i]+1]++;//这里把坐标+1是避免下标越界
	}
	for(i=1;i<257;i++)
		for(j=1;j<257;j++)
			for(k=1;k<257;k++)
				s[i][j][k]=s[i-1][j][k]+s[i][j-1][k]+s[i][j][k-1]-s[i-1][j-1][k]-s[i-1][j][k-1]-s[i][j-1][k-1]+s[i-1][j-1][k-1]+a[i][j][k];
	while(L+1<r)
	{
		M=(L+r)>>1;
		if(check(M))
			r=M;
		else
			L=M;
	}
	ansi--;
	ansj--;
	ansk--;
	write(r);
	putchar('\n');
	for(i=1;i<=n;i++)
		if(m&&ansi<=R[i]&&R[i]<=ansi+r&&ansj<=G[i]&&G[i]<=ansj+r&&ansk<=B[i]&&B[i]<=ansk+r)
		{
			write(R[i]);
			putchar(' ');
			write(G[i]);
			putchar(' ');
			write(B[i]);
			putchar('\n');
			m--;
		}
	return 0;
}
```

---

## 作者：☯☯枫☯☯ (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6441)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/14931233.html)

**算法分析：二分+前缀和**

答案的二分性是比较明显的，关注 “最大值”“最小值” 就可以看出来。因此最外层二分答案。

为了表述方便，记最大的颜色参数为 $col$。

注意到 $0\le R_x,G_x,B_x\le256$，范围较小，在没有思路的情况下可以直接 $col^3$ 枚举三者的最大值，然后再 $\mathcal{O}(n)$ 判断可行性。总体复杂度为 $\mathcal{O}(n\times col^3 \times \log_2(col))$。预计得分 $50pts$。

那么如何优化？外层二分无法优化，枚举 $col$ 的范围也只能有常数级别的优化，因此考虑优化掉 $\mathcal{O}(n)$ 的可行性检查。

当我们知道 $R_x,G_x,B_x$ 的范围时，是否可以考虑用前缀和 $\mathcal{O}(1)$ 算出符合范围的蜡笔数？当然可以。考虑使用**三维前缀和**，用 $f_{i,j,k}$ 表示满足 $R_x\le i,G_x\le j,B_x\le k$ 的蜡笔总数。我们类比二维前缀和，利用**容斥原理**计算三维前缀和，遵循 **“奇加偶减”** 原则，即：
$$f_{i,j,k}=f_{i,j,k}+f_{i-1,j,k}+f_{i,j-1,k}+f_{i,j,k-1}-f_{i-1,j-1,k}-f_{i-1,j,k-1}-f_{i,j-1,k-1}+f_{i-1,j-1,k-1}$$

于是可以 $\mathcal{O}(1)$ 计算出符合条件的蜡笔数量。

总时间复杂度 $\mathcal{O}(col^3 \times \log_2(col))$。

**注意：**颜色存在 "0"，输入时应将所有的编号**加 $1$**，便于前缀和处理。相应的，输出时应将所有编号**减 $1$**。

代码如下：

```cpp
#include<bits/stdc++.h>
#define reg register
#define F(i,a,b) for(reg int i=a;i<=b;++i)
using namespace std;
inline int read();
const int N=1e5+1,M=260;
int n,k,ans=1e9;
int f[M][M][M];
struct P {
	int r,g,b;
	inline void inp() {
		r=read()+1,g=read()+1,b=read()+1;
		//由于颜色存在 0 前缀和不易处理，因此+1 
	}
} a[N],Mx,Mi,rec;
inline P max(P a,P b) {
	return (P) {
		max(a.r,b.r),max(a.g,b.g),max(a.b,b.b)
	};
}
inline P min(P a,P b) {
	return (P) {
		min(a.r,b.r),min(a.g,b.g),min(a.b,b.b)
	};
}
inline void init() {
	F(i,1,n)++f[a[i].r][a[i].g][a[i].b];
	
	F(i,1,257) {
		F(j,1,257) {
			F(k,1,257) {

				f[i][j][k]+=f[i-1][j][k]+f[i][j-1][k]+f[i][j][k-1]
				            -f[i-1][j-1][k]-f[i-1][j][k-1]-f[i][j-1][k-1]
				            +f[i-1][j-1][k-1];

			}
		}
	}//统计三维前缀和 
}
inline bool check(int col) {
	//一点枚举边界小优化 
	F(r,Mi.r,Mx.r) {
		F(g,Mi.g,Mx.g) {
			F(b,Mi.b,Mx.b) {
				reg int lr=max(1,r-col),lg=max(1,g-col),lb=max(1,b-col);

				reg int s=f[r][g][b]-f[lr-1][g][b]-f[r][lg-1][b]-f[r][g][lb-1]
				      +f[lr-1][lg-1][b]+f[lr-1][g][lb-1]+f[r][lg-1][lb-1]
				      -f[lr-1][lg-1][lb-1];
				//容斥原理计算符合条件的数量。 
				if(s>=k){
					rec={r,g,b};
					return true;
				}
			}
		}
	}
	return false;
}
inline void output(){//输出方案 
	printf("%d\n",ans);
	reg int lr=rec.r-ans,lg=rec.g-ans,lb=rec.b-ans;
	F(i,1,n){
		if(a[i].r>=lr and a[i].r<=rec.r){
			if(a[i].g>=lg and a[i].g<=rec.g){
				if(a[i].b>=lb and a[i].b<=rec.b){
					//记得-1 
					printf("%d %d %d\n",a[i].r-1,a[i].g-1,a[i].b-1);
					--k;
					if(!k)return;
				} 
			}
		}
	}
}
int main() {
	n=read(),k=read();
	F(i,1,n)a[i].inp(),Mx=max(Mx,a[i]),Mi=min(Mi,a[i]);
	init();
	reg int ll=0,rr=max(Mx.b-Mi.b,max(Mx.g-Mi.g,Mx.r-Mi.r)),mid;
	while(ll<=rr) {
		mid=ll+rr>>1;
		check(mid)?rr=mid-1,ans=mid:ll=mid+1;
	}
	output();
	return 0;
}
inline int read() {
	reg int x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
```

[AC](https://www.luogu.com.cn/record/52041467)

欢迎交流讨论，请点个赞哦~


---

## 作者：A_Sunny_Day (赞：4)

​	第一眼看到这一题可能并没有什么思路。我们注意到 $R_i,G_i,B_i$ 的值域范围非常的小，所以我们可以从 $R_i,G_i,B_i$ 的值域入手。我们想到一个最暴力的方法：枚举答案，再枚举 $R,G,B$ 的下界。这样我们就可以得到 $R,G,B$ 的上界。再通过对 $N$ 支彩笔的遍历我们可以很轻松的检验此时我们能取到的笔的数量是否大于 $k$。对于这种方法，我们有一个很常规的优化：**二分**。

​	通过**二分**我们可以得到一个更优秀的复杂度：
$$
O(255^3\times n\log_2(255))
$$
​	但是这个复杂度明显过不了这个题目，我们得进一步优化。联想到之前解决这种**单个**元素具有**多个**属性的题目的解法，我们可以通过**排序**来进行优化

首先 $n$ 个彩笔按照 $R$ 的数值进行排序，那么我们在枚举时只需要枚举 $G$ ，$B$ 的下界，而在检验答案时，我们从左到右将符合条件的元素添加进一个队列里，由于我们已经通过排序使 $n$ 个彩笔的 $R$ 值有序，那么**队尾**的元素的 $R$ 值一定是最大的，而**队首**的元素的 $R$ 值一定是最小的。我们每添加进一个符合条件的元素在队尾，如果**队首**与**队尾**元素的 $R$ 值的差大于我们枚举的答案 $x$ ，那么就不断弹出队首直至**队首**与**队尾**元素的 $R$ 值的差小于我们枚举的答案 $x$ ，然后统计当前队列内元素的个数，如果个数大于 $k$  那么返回 true。由于 $n$ 个彩笔的 $R$ 值是单调递增的，我们可以通过这种方法得到满足条件的每一种选法。此时我们将复杂度降至：
$$
O(255^2\times \log_2(255) \times n + n\log_2n )
$$
此时我们可以拿到 60pts ，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+5;
int n,k1;
struct pen
{
    int val[4];
    bool operator < (const pen &x)const
    {
        return val[1]<x.val[1];
    }
}a[MAXN];
queue <int> q;
bool judge(int k,int i,int j,int x)
{
    if(a[k].val[2]>=i&&a[k].val[2]<=i+x&&a[k].val[3]>=j&&a[k].val[3]<=j+x) return true;
    return false;
}
bool check(int x)
{
    int ans=0;
    for(int i=0;i<=255;++i)
    {
        for(int j=0;j<=255;++j)
        {
            int cnt=0;
            while(!q.empty()) q.pop();
            for(int k=1;k<=n;++k)
            {
                if(q.empty()&&judge(k,i,j,x))
                {
                    ++cnt;
                    q.push(k);
                }
                else if(judge(k,i,j,x))
                {
                    q.push(k);
                    while(a[k].val[1]-a[q.front()].val[1]>x) q.pop(),--cnt;
                    ++cnt;
                }
                ans=max(ans,cnt);
            }
        }
    }
    return ans>=k1;
}
void print(int x)
{
    for(int i=0;i<=255;++i)
    {
        for(int j=0;j<=255;++j)
        {
            int cnt=0;
            while(!q.empty()) q.pop();
            for(int k=1;k<=n;++k)
            {
                if(q.empty()&&judge(k,i,j,x))
                {
                    ++cnt;
                    q.push(k);
                }
                else if(judge(k,i,j,x))
                {
                    q.push(k);
                    while(a[k].val[1]-a[q.front()].val[1]>x) --cnt,q.pop();
                    ++cnt;
                }
                if(cnt>=k1)//再做一遍得到符合题意的三个属性上下界。
                {
                    cnt=k1;
                    while(cnt--)
                    {
                        printf("%d %d %d\n",a[q.front()].val[1],a[q.front()].val[2],a[q.front()].val[3]);//输出队列里的元素。
                        q.pop();
                    }
                    return ;
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d",&n,&k1);
    for(int i=1;i<=n;++i)
        scanf("%d %d %d",&a[i].val[1],&a[i].val[2],&a[i].val[3]);
    sort(a+1,a+1+n);
    int l=1,r=255,ans=255;
    while(l<=r)
    {
        int mid=l+r>>1;
        if(check(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    printf("%d\n",ans);
    print(ans);
    return 0;
}
```

​	显然，$n$ 的数值太大了，我们必须想办法将 $n$ 优化掉。我们可以发现我们 $\text{check}$ 数里面实际上重复将 $n$ 个元素装进队列里多次。那么我们尝试可以将元素塞入 $\text{vector}$ 中。同样的，

​	我们以 $R$ 值排序，排序后，再一个个塞入以 $G,B$ 的值为下标的 $\text{vector}$ 中。在 check 函数中我们同样枚举三个属性的下界，并通过二分出的答案得到三个属性的上界。我们可以先枚举 $R$ 的上下界，然后接下来两个属性我们已经将他们当做下标，所以想象一个二维平面，对于一个点 $(x,y)$ 我们赋予它一个权值 $w$。$w$ 为 $R$ 值在枚举的上下界范围内，$G$ 为 $x$，$B$ 为 $y$ 的元素个数。这个我们可以在 $vec_{x,y}$ 二分上下界的位置并相减得到元素个数，但这样效率太低。我们考虑从小到大枚举 $R$ 值的下界，由于 $\text{vect}$ 中的元素 $R$ 有的，我们用一个队列来维护 $vec_{x,y}$ 中符合上下界元素的个数。具体可以见代码。

​	这样操作后我们会发现，我们需要判断是否有一个 $x\times x$ 大小的矩阵中所有点的权值 $w$ 之和大于等于 $k$。我们可以用二维前缀和来解决这样的问题。

​	同样的，上文中的方案是再算出符合答案的三个属性的上下界进行输出，这样有些慢，我们考虑开一个数组记录每次二分 $\text{check}$ 时得到的三个属性的上下界，而在输出方案时我们遍历 $n$ 个彩笔，符合条件的就输出。相当于我们使用了一个以空间来换时间的策略。

​	此时，我们将复杂度优化为
$$
O(255^3\times \log(255)+n+n\times \log(n))
$$
​	这个复杂度可以通过这道题目，代码如下：

```cpp
#include<bits/stdc++.h>
#define R register
using namespace std;
const int MAXN = 1e5+5;
int n,k1,lim;
struct pen
{
    int val[4];
}a[MAXN];
vector <int> vec[256][256];
int cnt[256][256],head[256][256],tail[256][256],ans[256][3],sum[256][256];
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
bool check(int x)
{
    memset(head,0,sizeof head);
    memset(tail,0,sizeof tail);
    for(R int i=0;i<=lim;++i)
    {
        for(R int j=0;j<=lim;++j)
        {
            for(R int k=0;k<=lim;++k)
            {
                while(head[j][k]<vec[j][k].size()&&vec[j][k][head[j][k]]<i) ++head[j][k];
                while(tail[j][k]<vec[j][k].size()&&vec[j][k][tail[j][k]]<=i+x) ++tail[j][k];//队列维护。
                cnt[j][k]=tail[j][k]-head[j][k];
                bool flag=0;
                sum[j][k]=(j?sum[j-1][k]:0)+(k?sum[j][k-1]:0)+cnt[j][k]-(j&&k?sum[j-1][k-1]:0);//二维前缀和。
                if(j>x&&k>x)
                    if(sum[j][k]-sum[j-x-1][k]-sum[j][k-x-1]+sum[j-x-1][k-x-1]>=k1) flag=true;
                else if(j>x&&k<=x)
                    if(sum[j][k]-sum[j-x-1][k]>=k1) flag=true;
                else if(j<=x&&k>x)
                    if(sum[j][k]-sum[j][k-x-1]>=k1) flag=true;
                else if(j<=x&&k<=x)
                    if(sum[j][k]>=k1) flag=true;
                if(flag)
                {
                    ans[x][0]=i,ans[x][1]=j,ans[x][2]=k;//记录此时三个属性的上下界。
                    return true;
                }
            }
        }
    }
    return false;
}
inline int Max(int a,int b,int c,int d)
{
    return max(max(a,b),max(c,d));
}
void print(int x)
{
    int a1,b,c;
    a1=ans[x][0],b=ans[x][1],c=ans[x][2];
    int cnt=0;
    for(R int i=1;i<=n;++i)
    {
        if(a[i].val[1]>=a1&&a[i].val[1]<=x+a1)
        {
            if(a[i].val[2]>=b-x&&a[i].val[2]<=b)
            {
                if(a[i].val[3]>=c-x&&a[i].val[3]<=c)
                {
                    ++cnt;
                    printf("%d %d %d\n",a[i].val[1],a[i].val[2],a[i].val[3]);
                    if(cnt==k1) return ;
                }
            }
        }
    }
}
bool cmp(pen a,pen b)
{
    return a.val[1]<b.val[1];
}
int main()
{
    n=read(),k1=read();
    for(R int i=1;i<=n;++i)
    {
        a[i].val[1]=read();
        a[i].val[2]=read();
        a[i].val[3]=read();
    }
    sort(a+1,a+1+n,cmp);
    lim=255;
    for(R int i=1;i<=n;++i)
        vec[a[i].val[2]][a[i].val[3]].push_back(a[i].val[1]);
    int l=1,r=lim,ans=lim;
    while(l<=r)
    {
        int mid=l+r>>1;
        if(check(mid))
        {
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    printf("%d\n",ans);
    print(ans);
    return 0;
}
```

​	这样我们就通过了这道题。其实我们可以优化掉 $\text{vector}$ 采取三维前缀和的方式。用 check 查找是否有一个边长为 $x$ 的立方体中所有点的权值之和大于 $k$ 。这种方法这里就不在赘述了。(~~其实是我也不会~~)

---

## 作者：lzyqwq (赞：2)

数据结构学傻了，来个逆天小丑做法。这是我们 CSP-S 的模拟赛题。

首先观察到时限 $7\text{s}$，因此往 $3\log$、$4\log$、根号 $\log$ 方面想。发现根号毫无道理。

单调性显然，考虑二分。如何检查二分的色彩值 $\text{mid}$ 是否合法？

考虑将所有点按照 $r_i$ 非降序排序。枚举 $r_i$ 最小的 $i$，那么能选的点形如一个区间，这个可以双指针维护。

然后还要求选出来 $k$ 个的 $g_i,b_i$ 极差 $\le \text{mid}$。把 $(g_i,b_i)$ 看成是平面上的一个点，则相当于有一个**边长**为 $\text{mid}$ 的正方形，放在平面的一个位置，是否能框住 $k$ 个点。考虑正方形的右上角，一定是一个整点且坐标在 $[0,|V|]$ 内，不然将其移动至坐标在 $[0,|V|]$ 内的整点时，不会少框住任何点。

维护以 $(x,y)$ 为右上角能框住多少点，那么要求这玩意最大值 $\ge k$。

这个离线扫描线很容易做，但是我们要求在线询问。考虑双指针加入/删除一个点时，只会对一个矩形内的 $(x,y)$ 产生影响。那么变成在线平面加、全局查 $\max$ 问题。KDT、树套树和二维分块估计都能做，但是模拟赛场上全忘记怎么写了。。。

注意到值域只有 $256$，而且时限这么大，考虑对每一个横坐标开线段树，修改暴力枚举横坐标在对应的线段树上区间加，查询暴力枚举横坐标查询最大值。

然后我们已经可以得到色彩值了。

考虑构造方案，我们记一下最小色彩值取到 $k$ 个点的时候是双指针的哪个区间，然后将区间内的点再次加入平面，维护二维前缀和，同时用 `vector` 存储每个坐标的点

注意 $(g_i,b_i)$ 可以重复，前缀和不能直接赋值 $1$ 而是要每次 $+1$。场上因为这个挂了 $80$ 分。

然后枚举平面上的点，查询以它为右上角能框住多少点，如果 $\ge k$ 了，就暴力遍历这个矩形，加入前 $k$ 个点。

时间复杂度为 $\mathcal{O}\left(n|V|\log^2 |V|\right)$，空间复杂度为 $\mathcal{O}\left(n+|V|^2\right)$。如果使用我没写出来的那些数据结构可能可以优化掉一个 $\log |V|$。只能说空间复杂度爆标了。

跑得比我想象中快。

[AC Link](https://www.luogu.com.cn/record/169102478)


```cpp
#include <bits/stdc++.h>
#define P pair
#define fi first
#define se second
#define mk make_pair
template<class T> void read(T &x) {
    x = 0; T f = 1; char c = getchar();
    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
    for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - 48; x *= f;
}
template<class T> void write(T x) {
    if (x > 9) write(x / 10); putchar(x % 10 + 48);
}
template<class T> void print(T x, char ed = '\n') {
    if (x < 0) putchar('-'), x = -x; write(x), putchar(ed);
}
using namespace std; const int N = 1e5 + 5, V = 257; int n, k, maxn, sum[V][V];
struct node { int r, g, b, id; } a[N]; vector<node> g[V][V], ans;
struct Seg {
    int a[V << 2], tg[V << 2];
    int ls(int x) { return x << 1; } int rs(int x) { return x << 1 | 1; }
    void build(int x, int l, int r) {
        a[x] = tg[x] = 0; if (l == r) return; int m = l + r >> 1;
        build(ls(x), l, m); build(rs(x), m + 1, r);
    }
    void mdf(int x, int l, int r, int ql, int qr, int v) {
        if (ql <= l && r <= qr) return a[x] += v, tg[x] += v, void();
        int m = l + r >> 1;
        if (ql <= m) mdf(ls(x), l, m, ql, qr, v);
        if (qr > m) mdf(rs(x), m + 1, r, ql, qr, v);
        a[x] = max(a[ls(x)], a[rs(x)]) + tg[x];
    }
    int val() { return a[1]; }
} sgt[V];
int qmx() {
    int ans = 0;
    for (int i = 1; i <= maxn; ++i) ans = max(ans, sgt[i].val()); return ans;
}
void mdf(int l, int r, int x, int y, int v) {
    for (int i = l; i <= r; ++i) sgt[i].mdf(1, 0, maxn, x, y, v);
}
P<int, bool> chk(int x) {
    for (int i = 0; i <= maxn; ++i) sgt[i].build(1, 0, maxn);
    for (int i = 1, j = 1; i <= n; ++i) {
        if (i > 1)
            mdf(a[i - 1].g, min(maxn, a[i - 1].g + x),
                a[i - 1].b, min(maxn, a[i - 1].b + x), -1);
        for (; j <= n && a[j].r - a[i].r <= x; ++j)
            mdf(a[j].g, min(maxn, a[j].g + x), a[j].b, min(maxn, a[j].b + x), 1);
        if (j - i >= k && qmx() >= k) return mk(i, 1);
    }
    return mk(0, 0);
}
int query(int l, int r, int x, int y) {
    int ans = sum[r][y];
    if (l) ans -= sum[l - 1][y]; if (x) ans -= sum[r][x - 1];
    if (l && x) ans += sum[l - 1][x - 1]; return ans;
}
void find(int x, int p) {
    int l = p; while (l <= n && a[l].r - a[p].r <= x) ++l;
    for (int i = p; i < l; ++i) {
        ++sum[a[i].g][a[i].b];
        g[a[i].g][a[i].b].emplace_back(a[i]);
    }
    for (int i = 0; i <= maxn; ++i)
        for (int j = 0; j <= maxn; ++j) {
            if (i) sum[i][j] += sum[i - 1][j]; if (j) sum[i][j] += sum[i][j - 1];
            if (i && j) sum[i][j] -= sum[i - 1][j - 1];
        }
    bool op = 0;
    for (int i = x; i <= maxn; ++i)
        for (int j = x; j <= maxn; ++j)
            if (query(i - x, i, j - x, j) >= k) {
                for (int u = i - x; u <= i; ++u)
                    for (int v = j - x; v <= j; ++v)
                        for (auto m : g[u][v]) {
                            ans.emplace_back(m); if (ans.size() == k) return;
                        }
            }
}
signed main() {
    read(n); read(k);
    for (int i = 1; i <= n; ++i)
        read(a[i].r), read(a[i].g), read(a[i].b), a[i].id = i,
        maxn = max({maxn, a[i].r, a[i].g, a[i].b});
    stable_sort(a + 1, a + n + 1, [&](node u, node v) { return u.r < v.r; });
    int l = 1, r = maxn, f, md, q; P<int, bool> p;
    while (l <= r) {
        md = l + r >> 1; p = chk(md);
        if (p.se) f = md, q = p.fi, r = md - 1; else l = md + 1;
    }
    print(f); find(f, q);
    stable_sort(ans.begin(), ans.end(), [&](node u, node v) {
        return u.id < v.id;
    });
    for (auto i : ans) print(i.r, ' '), print(i.g, ' '), print(i.b);
    return 0;
}
```

---

## 作者：xixisuper (赞：1)

# P6441 [COCI2011-2012#6] PASTELE 题解

我唐完了，没看标签不会做，看了标签一眼秒。

## 思路

注意到 $R,G,B$ 的值域很小，所以我们考虑开一个三维数组 $sum_{i,j,k}$ 表示有多少个蜡笔的 $R\le i$ 且 $G\le j$ 且 $B\le k$，这一部分的时间复杂度为 $O(V^3)$，其中 $V$ 为值域。

那么回看题目中 $\max\left\{|R_i-R_j|,|G_i-G_j|,|B_i-B_j|\right\}$，注意到最后要求的是**最小化这个最大值**，所以我们可以考虑二分答案。假设我们当前二分的答案是 $ans$，那么所有的点必然会在以某个 $(x,y,z)$ 和 $(x+ans,y+ans,z+ans)$ 这两点作为对角线所构成的立方体范围之内，所以我们只需要进行一个三位前缀和技能得到答案。二分一个答案的时间复杂度为 $O(\log V)$。

鉴于可能有些人不会用三维前缀和计算空间和，我这边提一嘴，假设你要计算一个以 $(x,y,z)$ 和 $(x',y',z')$ 作为对角线的长方体范围内的和 $S$，我们有如下公式：

$$
\begin{aligned}
S'&=sum_{x,y,z}\\
S''&=sum_{x'-1,y,z}+sum_{x,y'-1,z}+sum_{x,y,z'-1}\\
S'''&=sum_{x'-1,y'-1,z}+sum_{x'-1,y,z'-1}+sum_{x,y'-1,z'-1}\\
S''''&=sum_{x'-1,y'-1,z'-1}\\
\end{aligned}
$$

$$
S=S'-S''+S'''-S''''
$$

其实这个玩意现推是有技巧的，有意向学习的人可以参考[OI-wiki 前缀和](http://oi-wiki.com/basic/prefix-sum/)与[OI-wiki 容斥原理](http://oi-wiki.com/math/combinatorics/inclusion-exclusion-principle/)。

综上，总时间复杂度为 $O(V^3\cdot \log V)\le O(2^{24})$，实现的不丑就能直接过。

## 代码

代码如下：

```cpp
#include <iostream>
#include <algorithm>
#define ll int
using namespace std;
const ll N=1e5+10;
const ll V=257;
struct node{ll R,G,B;}ask[N];
ll sum[258][258][258],n,k;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(ll i=1;i<=n;i++){
		cin>>ask[i].R>>ask[i].G>>ask[i].B;
		ask[i].R++;ask[i].B++;ask[i].G++;
		sum[ask[i].R][ask[i].G][ask[i].B]++;
	} 
	for(ll i=1;i<=V;i++)
		for(ll j=1;j<=V;j++)
			for(ll k=1;k<=V;k++)
				sum[i][j][k]+=sum[i-1][j][k]+sum[i][j-1][k]+sum[i][j][k-1]-sum[i-1][j-1][k]-sum[i-1][j][k-1]-sum[i][j-1][k-1]+sum[i-1][j-1][k-1];
	ll l=0,r=V+1,mid;
	while(l<r){
		mid=(l+r)>>1;
		bool flag=0;
		for(ll i=1;i+mid<=V;i++){
			for(ll j=1;j+mid<=V;j++){
				for(ll q=1;q+mid<=V;q++){
					ll x=i+mid,y=j+mid,z=q+mid;
					ll x_=i,y_=j,z_=q;
					ll S_=sum[x][y][z];
					ll S__=sum[x_-1][y][z]+sum[x][y_-1][z]+sum[x][y][z_-1];
					ll S___=sum[x_-1][y_-1][z]+sum[x_-1][y][z_-1]+sum[x][y_-1][z_-1];
					ll S____=sum[x_-1][y_-1][z_-1];
					ll S=S_-S__+S___-S____;
					if(S>=k){
						flag=1;
						break;
					}
				}
			}
		}
		if(flag) r=mid;
		else l=mid+1;
	}
	cout<<l<<"\n";
	for(ll i=1;i+l<=V;i++){
		for(ll j=1;j+l<=V;j++){
			for(ll q=1;q+l<=V;q++){
					ll x=i+l,y=j+l,z=q+l;
					ll x_=i,y_=j,z_=q;
					ll S_=sum[x][y][z];
					ll S__=sum[x_-1][y][z]+sum[x][y_-1][z]+sum[x][y][z_-1];
					ll S___=sum[x_-1][y_-1][z]+sum[x_-1][y][z_-1]+sum[x][y_-1][z_-1];
					ll S____=sum[x_-1][y_-1][z_-1];
					ll S=S_-S__+S___-S____;
					if(S>=k){
						ll cnt=0;
						for(ll T=1;T<=n;T++){
							if(x_<=ask[T].R&&ask[T].R<=x&&y_<=ask[T].G&&ask[T].G<=y&&z_<=ask[T].B&&ask[T].B<=z){
								cout<<ask[T].R-1<<' '<<ask[T].G-1<<' '<<ask[T].B-1<<"\n";
								cnt++;
							}
							if(cnt==k) return 0; 
						}
					}
			} 
		} 
	}
	return 0;
}
```

---

## 作者：Lydia1010__ (赞：0)

## 本题思路：
这道题我们可以直接二分出最小彩色值是多少，判断合不合法的话因为值域很小，直接枚举一个点，看以当前点为正方体左下角，边长为枚举值的正方体内有没有 $k$ 个，有就合法。

看正方体中有没有 $k$ 个也是很典了，直接上三维前缀和即可。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int sum[257][257][257];
struct f{int x,y,z;}a[100005];
int xx,yy,zz;
int n,m;
int check(int summ){
	for(int i=1;i+summ<=256;i++){
		for(int j=1;j+summ<=256;j++){
			for(int k=1;k+summ<=256;k++){
				int x=i-1,y=j-1,z=k-1,
				ex=i+summ,ey=j+summ,ez=k+summ;
				int num=sum[ex][ey][ez]+sum[ex][y][z]
				+sum[x][ey][z]+sum[x][y][ez]-sum[ex][ey][z]
				-sum[ex][y][ez]-sum[x][ey][ez]-sum[x][y][z];
				if(num>=m){
					xx=i,yy=j,zz=k;return 1;
				}
			}
		}
	}
	return 0;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){cin>>a[i].x>>a[i].y>>a[i].z;sum[a[i].x+1][a[i].y+1][a[i].z+1]++;}
	for(int i=1;i<=256;i++)for(int j=1;j<=256;j++)for(int k=1;k<=256;k++)sum[i][j][k]+=sum[i-1][j][k];
	for(int i=1;i<=256;i++)for(int j=1;j<=256;j++)for(int k=1;k<=256;k++)sum[i][j][k]+=sum[i][j-1][k];
	for(int i=1;i<=256;i++)for(int j=1;j<=256;j++)for(int k=1;k<=256;k++)sum[i][j][k]+=sum[i][j][k-1];
	int l=-1,r=256,sum=256,x=1,y=1,z=1;
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)) r=mid-1,sum=mid,x=xx,y=yy,z=zz;
		else l=mid+1;
	}
	x--,y--,z--;
	cout<<sum<<endl;
	for(int i=1;i<=n;i++){
		if(a[i].x<x||a[i].y<y||a[i].z<z) continue;
		if(a[i].x<=x+sum&&a[i].y<=y+sum&&a[i].z<=z+sum){
			cout<<a[i].x<<" "<<a[i].y<<" "<<a[i].z<<endl;
			m--;if(m==0) return 0;
		}
	}
	return 0;
}
```

---


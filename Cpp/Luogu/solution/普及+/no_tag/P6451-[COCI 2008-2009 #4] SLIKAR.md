# [COCI 2008/2009 #4] SLIKAR

## 题目背景

Josip 是一个奇怪的画家。

## 题目描述

他想画一幅由 $n\times n$ 个像素点组成的画。其中 $n$ 是 $2$ 的幂次（如 $1,2,4,8,16,\dots$）。每个像素点将会被着色为黑色或者白色。Josip 目前已经知道他的理想画作了。

他将按照如下步骤作画：

- 如果整幅画是一个像素点，那么他将依照自己的目标把这个像素点涂成黑色或者白色。

- 否则，他会将正方形分为四个更小的正方形，然后：

1. 从中选择一个正方形全部涂成白色。
1. 再从剩下的三个正方形中选择一个全部涂成黑色。
1. 把剩下的两个正方形当成一幅新的画作，重复上述步骤。

很快他就发现把心目中的画作完完整整的画出来是不可能的。所以，他希望你来编写一个程序，使得画出的一幅画与他心目中的理想画作的差异尽量小。

两张画作之间的差异为颜色不同的像素点的数目。

## 说明/提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n\le 8$；
- 对于 $100\%$ 的数据，$1\le n\le 512$。

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #4](https://hsin.hr/coci/archive/2008_2009/contest4_tasks.pdf) *T4 SLIKAR***。

## 样例 #1

### 输入

```
4
0001
0001
0011
1110```

### 输出

```
1
0001
0001
0011
1111```

## 样例 #2

### 输入

```
4
1111
1111
1111
1111```

### 输出

```
6
0011
0011
0111
1101```

## 样例 #3

### 输入

```
8
01010001
10100011
01010111
10101111
01010111
10100011
01010001
10100000```

### 输出

```
16
00000001
00000011
00000111
00001111
11110111
11110011
11110001
11110000```

# 题解

## 作者：Cxny (赞：3)

显然，如果没有必须将两块较小块染成一黑一白的限制，我们一定可以染出目标矩阵。

因此，对于当前较大的一个块，我们可以先将四小块分别染色，再考虑如何染整块的 $0$ 和 $1$ 使得代价最小。

一种贪心是，将染成 $0$ 和 $1$ 的**额外**代价从小到大排序，将额外代价最小的染色。

但很明显，这种做法是错误的。对于如下矩阵：

$$\begin{matrix}
0,0,0,0\\
0,0,0,1\\
0,0,0,0\\
0,1,0,0
\end{matrix}$$

左上方子矩阵正常染色最小代价为 $1$ ，染成 $1$ 的额外代价为 $4$ ；而右上方子矩阵正常染色最小代价为 $0$ ，染成 $1$ 额外代价为 $3$ 。二者之差相等。

程序可能会将左上方子矩阵染成 $1$ 而将右上方子矩阵染成 $0$ ，算得最小代价为 $6$ 。

然而，最优解得到的矩阵可以是：

$$\begin{matrix}
0,0,1,1\\
0,0,1,1\\
0,0,0,0\\
0,1,0,1
\end{matrix}$$

最小代价为 $4$ 。

在考虑染整块时直接枚举将哪块染成 $0$ 或 $1$ 即可。

完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 513;
int n, a[maxn][maxn], ans[maxn][maxn], res[5][13], cnt1[5][13];
pair<int, int> tot[5];
int chosen[5], bst[5];
char s[maxn][maxn];
int count(int x, int y, int sz){
	int ret = 0;
	for(int i = 1; i <= sz; i++) for(int j = 1; j <= sz; j++)
		ret += a[x + i - 1][y + j - 1];
	return ret;
}
pair<int, int> getxy(int x, int y, int sz, int type){
	if(type == 2) x += sz;
	else if(type == 3) y += sz;
	else if(type == 4) x += sz, y += sz;
	return {x, y};
}
void color(int x, int y, int sz, int type, int col){
	auto tmp = getxy(x, y, sz, type);
	x = tmp.first, y = tmp.second;
	for(int i = 1; i <= sz; i++) for(int j = 1; j <= sz; j++)
		ans[x + i - 1][y + j - 1] = col;
}
int solve(int x, int y, int sz, int dep){
	if(sz == 1) return ans[x][y] = a[x][y], 0;//大小为 1 的矩阵可任意染色
	int mid = sz >> 1, ret = 0;
	
	//正常染子矩阵
	res[1][dep] = solve(x, y, mid, dep + 1), res[2][dep] = solve(x + mid, y, mid, dep + 1);
	res[3][dep] = solve(x, y + mid, mid, dep + 1), res[4][dep] = solve(x + mid, y + mid, mid, dep + 1);
	ret = sz * sz;
	auto tmp = getxy(x, y, mid, 1);
	cnt1[1][dep] = count(tmp.first, tmp.second, mid);
	tmp = getxy(x, y, mid, 2);
	cnt1[2][dep] = count(tmp.first, tmp.second, mid);
	tmp = getxy(x, y, mid, 3);
	cnt1[3][dep] = count(tmp.first, tmp.second, mid);
	tmp = getxy(x, y, mid, 4);
	cnt1[4][dep] = count(tmp.first, tmp.second, mid);
	for(int i = 1; i <= 4; i++) chosen[i] = i;
	
	//枚举
	do{
		int cur = mid * mid - cnt1[chosen[1]][dep] + cnt1[chosen[2]][dep] + res[chosen[3]][dep] + res[chosen[4]][dep];
		if(cur < ret){
			ret = cur;
			for(int i = 1; i <= 4; i++) bst[i] = chosen[i];
		}
	}while(next_permutation(chosen + 1, chosen + 5));
	
	color(x, y, mid, bst[1], 1);//染色
	color(x, y, mid, bst[2], 0);
	return ret;
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%s", s[i] + 1);
		for(int j = 1; j <= n; j++) a[i][j] = s[i][j] - '0';
	}
	printf("%d\n", solve(1, 1, n, 0));
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++) printf("%d", ans[i][j]);
		puts("");
	}
	return 0;
}


```

---

## 作者：Cells (赞：0)

## 题外话
由于此题代码较屎，本人考场没切出来，请各位做好赤石准备。
## 思路
首先能想到的做法一定是贪心，但是能够很快发现这个做法的不严谨之处在于题目要求每次必须选择一黑一白两个区块。没有思路的时候可以先看看数据范围。发现 $1 \le n \le 512$，我们记忆化搜索兴许能过。顺着这个思路，我们枚举每个区块中哪个区块染白，哪个染黑，剩下的两个区块我们可以递归处理。关于状态如何表示，我们注意到区块长度总是 $2$ 的整数次幂，所以我们记录区块左上角的坐标，然后用一个数表示区块长度即可，由于内存限制很小，所以可以类似哈希将状态压一压，这一点在插头 DP 有较广泛的应用，但是不优化也能过，所以我不优化。代码比较长。
## Code
```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 513;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n;
int s[N][N];

bitset<N> a[N], mp[N];

struct node{
	short w, b;
	int ans;
}dp[N][N][10];

il int query(int x, int y, int l){
	int x2 = x + (1 << l) - 1, y2 = y + (1 << l) - 1;
	return s[x2][y2] - s[x - 1][y2] - s[x2][y - 1] + s[x - 1][y - 1];
}

il int getdif(int x, int y, int l, bool c){//w0 b1
	int sum1 = query(x, y, l), sum0 = sqr(1 << l) - sum1;
	if(c) return sum0;
	return sum1;
}

il node getxyz(int x, int y, int l, int t){
	node res;
	res.ans = l - 1;
	if(t == 1 || t == 2) res.w = x;
	if(t == 3 || t == 4) res.w = x + (1 << res.ans);
	if(t == 1 || t == 3) res.b = y;
	if(t == 2 || t == 4) res.b = y + (1 << res.ans);
	return res;
}

int dfs(int x, int y, int l){
	if(dp[x][y][l].ans != INF1) return dp[x][y][l].ans;
	if(!l) return dp[x][y][l].ans = 0;
	
	int ans = INF1, sum, totw, totb, i, j;//iw0 jb1
	node tmp;
	
	rep(w, 1, 4){
		tmp = getxyz(x, y, l, w);
		totw = getdif(tmp.w, tmp.b, tmp.ans, 0);
		if(totw >= ans) continue;
		
		rep(b, 1, 4){
			if(w == b) continue;
			tmp = getxyz(x, y, l, b);
			totb = getdif(tmp.w, tmp.b, tmp.ans, 1);
			
			sum = totw + totb;
			if(sum >= ans) continue;
			
			rep(res, 1, 4){
				if(res == w || res == b) continue;
				tmp = getxyz(x, y, l, res);
				sum += dfs(tmp.w, tmp.b, tmp.ans);
			}
			
			if(sum < ans){
				ans = sum, i = w, j = b;
			}
		}
	}
	
	dp[x][y][l] = {i, j, ans};
	return ans;
}

il void paint(int x, int y, int l, bool c){
	rep(i, x, x + (1 << l) - 1){
		rep(j, y, y + (1 << l) - 1){
			a[i][j] = c;
		}
	}
}

void getmap(int x, int y, int l){
	if(!l){
		a[x][y] = mp[x][y];
		return;
	}
	
	node tmp;
	tmp = getxyz(x, y, l, dp[x][y][l].w);
	paint(tmp.w, tmp.b, tmp.ans, 0);
	tmp = getxyz(x, y, l, dp[x][y][l].b);
	paint(tmp.w, tmp.b, tmp.ans, 1);
	
	rep(res, 1, 4){
		if(res == dp[x][y][l].w || res == dp[x][y][l].b) continue;
		tmp = getxyz(x, y, l, res);
		getmap(tmp.w, tmp.b, tmp.ans);
	}
}

signed main(){ 
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	rep(i, 1, n){
		rep(j, 1, n){
			rep(k, 1, 10){
				dp[i][j][k].ans = INF1;
			}
		}
	}
	
	char ch;
	rep(i, 1, n){
		rep(j, 1, n){
			cin >> ch;
			mp[i][j] = ch - '0';
		}
	}
	
	rep(i, 1, n){
		rep(j, 1, n){
			s[i][j] = s[i][j - 1] + mp[i][j];
		}
	}
	
	rep(i, 1, n){
		rep(j, 1, n){
			s[i][j] += s[i - 1][j];
		}
	}
	
	cout << dfs(1, 1, log2(n)) << "\n";
	
	getmap(1, 1, log2(n));
	
	rep(i, 1, n){
		rep(j, 1, n){
			cout << a[i][j];
		}
		
		cout << "\n";
	}
	
	return 0;
}
```

---


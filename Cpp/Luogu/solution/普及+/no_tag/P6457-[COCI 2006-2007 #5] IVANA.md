# [COCI 2006/2007 #5] IVANA

## 题目描述

给定 $n$ 个整数排成一圈，两位玩家进行如下的取数规则：

- 第一次取数的玩家可以取任意一个数；
- 第二次取数的玩家只能从上一次取得数的左右两边相邻的两个数中取一个；
- 第三次取数的玩家可以从之前所有取过的任意一个数的左右两边相邻的两个数中取一个；

其中，与第一个数和第 $n$ 个数相邻的只有一个数。

两位玩家轮流取数。在所有的数都被取完之后，取得奇数多的玩家胜利。

请你找出，先手玩家有多少种不同的开局方法，使得自己能够赢得比赛。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 100$，读入的数字都在 $1\sim 1000$ 之间。

#### 说明

**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #5](https://hsin.hr/coci/archive/2006_2007/contest5_tasks.pdf) *T5 IVANA***。

## 样例 #1

### 输入

```
3
3 1 5```

### 输出

```
3```

## 样例 #2

### 输入

```
4
1 2 3 4```

### 输出

```
2```

## 样例 #3

### 输入

```
8
4 10 5 2 9 8 1 7```

### 输出

```
5```

# 题解

## 作者：封禁用户 (赞：11)

# 题目解析

一个取数游戏，有以下规则：

- 第一次取数的玩家可以取任意一个数；

- 第二次取数的玩家只能从上一次取得数的左右两边相邻的两个数中取一个；

- 第三次取数的玩家可以从之前所有取过的任意一个数的左右两边相邻的两个数中取一个；

其中，与第一个数和第 $n$ 个数相邻的只有一个数。

要你统计有多少种必赢的开局。

容易想到破环成链。

$numb_{i,j}$ 表示 $i-j$ 这条链可以从两边开始选，先手能比后手多拿到最多的奇数个数。

也就是说：当 $numb_{i,i} - numb_{i+1, i+n-1} > 0$ 符合时，就统计答案。

$AC$ 码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a[110],numb[210][210];cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]%=2;
		numb[i][i]=numb[i+n][i+n]=a[i];
	}
	for(int l=2;l<=n;l++){
		for(int i=1;i<=(n<<1);i++){
			int j=i+l-1;
			if(j>(n<<1)){
				break;
			}
			numb[i][j]=max(numb[i][i]-numb[i+1][j],numb[j][j]-numb[i][j-1]);
		}
	}
	int cnt=0;
	for(int i=1;i<=n;i++){
		if(numb[i][i]-numb[i+1][i+n-1]>0){
			cnt++;
		}
	}
	cout<<cnt;
}
```


---

## 作者：Unpretentious_Day (赞：6)

[原题链接](https://www.luogu.com.cn/problem/P6457)
# 分析

既然取得奇数多的玩家胜利，那么我们不妨以奇数为中心来定义状态。

定义 $f(i,j)$ 表示双方均采取最优策略的情况下，将此区间取完先手比后手多取的奇数的数量。

不难得到：
$$
\large f(i,j)=\max\{f(i,i)-f(i+1,j),f(j,j)-f(i,j-1) \}
$$
将取完区间 $[i,j]$ 的最后一个数的玩家成为我方，另一位成为对方。对于 $f(i,i)-f(i+1,j)$，$f(i+1,j)$ 是对方取完区间 $[i+1,j]$ 比我方多的奇数数量，$f(i,i)$ 是我方取完数字 $i$ 后比对方多的奇数数量。（可将 $[i+1,j]$ 看作一个整体）

要求得 $f(i,j)$，就要让我方在 $[i,i]$ 多的数量减去对方在 $[i+1,j]$ 比我方多的数量。如果在区间 $[i+1,j]$，即使对方使用了最优策略，取得的奇数数量仍少于我方的数量，那么 $f(i+1,j)$ 为负，方程依旧成立。

$f(j,j)-f(i,j-1)$ 同理。

最后 $f(i,i)-f(i+1,j)>0$ 或 $f(j,j)-f(i,j-1)>0$，则可行方案数加一。由于使用了破环成链，因此 $f(i,i)-f(i+1,j)>0$ 和 $f(j,j)-f(i,j-1)>0$ 只能选一个作为判定条件。否则会使答案被错误更新。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e2 + 5;
int dp[maxn][maxn], n, x, ans;
void solve(){
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i)
        scanf("%d", &x), dp[i][i] = dp[i + n][i + n] = x & 1; //初始化
    for(int len = 2; len < n; ++len)
        for(int i = 1, j; (j = i + len - 1) <= n << 1; ++i)
            dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]);
    for(int i = 1; i <= n; ++i){
        int j = i + n - 1;
        if(dp[i][i] - dp[i + 1][j] > 0) //统计答案
            ++ans;
    }
    printf("%d\n", ans);
}
int main(){
    solve();
    return 0;
}
```

---

## 作者：wei2013 (赞：2)

## 思路：
这是一道博弈论区间 dp，首先先做初始化，可以看到题目给的是环而非链，那么显然破环成链，比写链表更简单，破环成链不会的话，先去看[这题](https://www.luogu.com.cn/problem/P1880)。

状态定义：既然是区间 $dp$，那么可以假设 $dp_{l,r}$ 表示在 $l-r$ 中此时的先手所取到的奇数个数比后手最多多多少个。

初始化：顺理成章的想下去，长度为 $1$ 的区间内如果此时数值是奇数，那么先手把这个取了就会比后手多 $1$ 个。所以 `if(a[i]%2) dp[i][i]=1`。

状态转移方程：
$$dp_{l,r}=\max(dp_{l,l}-dp_{l+1_r},dp_{r_r}-dp_{l,r-1})$$
为什么？因为在取到 $l-r$ 区间的时候，先手可以先取 $a_{l-r}$，但是这些方案其实有一些是肯定不会更优的。首先 $dp_{l-r,l-r}$ 一定是 $1$ 或 $0$。所以只用分 $0$ 或 $1$ 两种方案即可。

答案得出：`if(dp[l][l]-dp[l+1][r]>0) ans++`。由于 $dp_{l,r}$ 显然是有重复的地方的，所以可以使用和动态转移方程类似的方式来记录答案避免重复计算。**注意：我们给的是环，破环成链后会重复两遍！**
## code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,a[205],dp[205][205],ans=0;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(int i=1;i<=2*n;i++){//初始化
		if(a[i]%2){
			dp[i][i]=1;
		}
	}
	for(int len=2;len<=n;len++){
		for(int l=1;l+len-1<=2*n;l++){
			int r=l+len-1;
			dp[l][r]=max(dp[l][l]-dp[l+1][r],dp[r][r]-dp[l][r-1]);//动态转移方程
		}
	}
	for(int l=1;l<=n;l++){//不能写 l+n-1<=2*n
		int r=l+n-1;
		if(dp[l][l]-dp[l+1][r]>0){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Rosick (赞：2)

### 题意
给出一个数环，有两人依次取数。第一个数任意取，随后只能取已取过数的相邻数。最终选择奇数多者获胜。两人都会做出每一次的最优选择，求问先手者有多少种开局能获胜。

### 分析
1. 每次取相邻，联想到边缘模型（即每个新的状态都是由左右分别少一位的旧状态转移过来）。
2. 统计奇数数，读入时对 $2$ 取模，奇数就变成 $1$，偶数就变成 $0$。
3. 思考状态定义要求：
	1. 每人都做出最优选择：把每人每次的选择都当作先手，都统计最优值。
	2. 环且左右两侧都可以成为下一个选择点：加倍为链，且注意每一个状态都是能左右选的。
4. 状态：`dp[i][j]` 代表已经选择了区间 $[i, j]$ 且先手（满足上述要求 1）选取左侧或右侧（满足上述要求 2）时最多的先手比后手多的奇数数。
5. 转移： `dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1])`，先手选择了左侧或右侧端点 $i$ 或 $j$，则剩余点就是另外一人先手选择，故减去。
6. 统计答案：最终遍历每个点，`dp[i][i] - dp[i + 1][i + n - 1] > 0` 判断先手选择这个点是否能获胜，为真则累计答案。不可以直接用 `dp[i][i + n - 1] > 0` 来判断，因为这样无法确定是左端点还是右端点，会导致重复。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e2 + 10;

int n, m, ans;
int dp[maxn << 1][maxn << 1];

void sol(){
	scanf("%d", &n);
	m = n << 1;
	for(int i = 1; i <= n; ++i){
		scanf("%d", &dp[i][i]);
		dp[i][i] %= 2;
		dp[i + n][i + n] = dp[i][i];
	}
		
	for(int len = 2; len < n; ++len)
		for(int i = 1, j = i + len - 1; j <= m; ++i, ++j)
			dp[i][j] = max(dp[i][i] - dp[i + 1][j], dp[j][j] - dp[i][j - 1]);
				
	for(int i = 1; i <= n; ++i)
		if(dp[i][i] - dp[i + 1][i + n - 1] > 0) ++ans;
	printf("%d", ans);
}

int main(){
	sol();
	return 0;
} 
```

---

## 作者：mozhao (赞：2)

# 题意
两个人取数，取数规则：

第一次取数的玩家可以取任意一个数。

第二次取数的玩家只能从上一次取得数的左右两边相邻的两个数中取一个。

第三次取数的玩家可以从之前所有取过的任意一个数的左右两边相邻的两个数中取一个。

要求找出先手玩家有多少种不同的开局方法，以保证他百分之百取胜。
## 主题思路：
这道题考虑破环成链。
### 具体方法：
$dp[i][j]$ 表示 $i\sim j$ 这条链可以从两边开始选，先手能比后手多拿到最多的奇数个数，显然应枚举取左边还是右边。

最后判断 $dp[i][i] - dp[i+1][i+n-1] > 0$ 时这个点可行，直接判断即可。

代码如下（一些细节注释在里面了）：
```cpp
#include<iostream>
using namespace std;
int n,a[105]={},b[205][205]={};
int main() { 
	cin>>n; //输入不必多说 
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		a[i]%=2;
		b[i][i]=b[i+n][i+n]=a[i];
	}
	for(int p=2; p<=n; p++) { //从2开始遍历 
		for(int i=1; i<=n*2; i++) {
			int j=i+p-1;
			if(j>n*2) {
				break; //直接弹出 
			}
			b[i][j]=max(b[i][i]-b[i+1][j],b[j][j]-b[i][j-1]); //记得取最大值 
		}
	}
	int ans=0;
	for(int i=1; i<=n; i++) {
		if(b[i][i]-b[i+1][i+n-1]>0) {
			ans++; //统计种类数 
		}
	}
	cout<<ans; //输出 
  return 0;
}
```
完结散花！

---

## 作者：decoqwq (赞：2)

考虑破环成链，`dp[i][j]` 表示 $i-j$ 这条链可以从两边开始选，先手能比后手多拿到最多的奇数个数，显然 `dp[i][j]=max(dp[i][i]-dp[i+1][j],dp[j][j]-dp[i][j-1])`，即枚举取左边还是右边。

然后当 `dp[i][i]-dp[i+1][i+n-1]>0` 时这个点可行，直接判断即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[110],dp[210][210];
int main()
{
	freopen("ivana.in","r",stdin);
	freopen("ivana.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]%=2;
		dp[i][i]=dp[i+n][i+n]=a[i];
	}
	for(int l=2;l<=n;l++)
	{
		for(int i=1;i<=(n<<1);i++)
		{
			int j=i+l-1;
			if(j>(n<<1))
			{
				break;
			}
			dp[i][j]=max(dp[i][i]-dp[i+1][j],dp[j][j]-dp[i][j-1]);
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(dp[i][i]-dp[i+1][i+n-1]>0)
		{
			ans++;
		}
	}
	cout<<ans;
}
```

---

## 作者：AZYDLL (赞：1)

# 题目

取数游戏，规则：（表述有些许改动，但意思不变）

* 第一个取数的玩家可取任意一数；
* 第二个取数的玩家只能在第一个玩家取得数的左右相邻的两个数中取一个；
* 第三个及以后取数的玩家可在两人取过的任意一数的左右相邻的两个数中取一个；

显然，两人取过的数会构成一个区间。于是考虑用区间 DP 求解。

# 思路

题目给的是环，于是不难想到断环成链。

定义 $dp_{i,j}$ 为将区间 $[i,j]$ 中的数字取完后，第一步取 $num_i$ 或 $num_j$ 的先手玩家能比后手玩家**多取**多少个奇数（假定两人都按最优的策略操作），则可得转移方程：

$$
\displaystyle dp_{i,j}=\max(dp_{i,i}-dp_{i+1,j} , dp_{j,j}-dp_{i,j-1})
$$

为什么呢？

我们可以画图模拟一下 $dp_{i,j}=dp_{i,i}-dp_{i+1,j}$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/2l8xdc0m.png)

如图，将链条还原为环。可发现，若先手玩家取了 $num_i$（红色），那么后手玩家只能取 $num_{i+1}$ 或 $num_j$（蓝色）。于是在区间 $[i+1,j]$ 中，后手玩家变成了先手，会比先手玩家多取 $dp_{i+1,j}$ 个奇数（若后手玩家取的少则 $dp_{i+1,j}$ 为负）。根据 $dp_{i,j}$ 的定义可推得转移方程。

区间扩张时，相当于将一个新的数字放入图中 $num_i$（红色）和 $num_j$（蓝色）之间，再进行相同的操作。

最后判断：若 $dp_{i,i}-dp_{i+1,i+n-1}>0$，则取 $num_i$ 开局可赢得比赛，更新答案。

# 代码

```cpp
#include<iostream>
#define MAXN 205

using namespace std;

int n,n1,dp[MAXN][MAXN],ans;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>dp[i][i];
		dp[i][i]%=2;// 初始化 
		dp[n+i][n+i]=dp[i][i];// 断环成链 
	}
	n1=n*2;
	
	for(int l=2;l<=n;l++){
		for(int i=1;i<=n1-l+1;i++){
			int j=i+l-1;
			dp[i][j]=max(dp[i][i]-dp[i+1][j],dp[j][j]-dp[i][j-1]);
		}
	}
	for(int i=1;i<=n;i++) if(dp[i][i]-dp[i+1][i+n-1]>0) ans++;// 注意一个点只能算一次 
	cout<<ans<<endl;
	
	return 0;
}
```

---

## 作者：Pratty (赞：1)

取数问题加数据范围不大，得结论：动态规划题目。

很明显，第一位玩家掌握主动权，因为他可以取任意数。

而第二位玩家只能从上一名玩家的左右两个数中取一个，方案数大大减少，所以第一位玩家取的地方很关键。

第三次取数的时候从之前的取过的数的左右取一个，也很局限。

假设第一位玩家取了 $1$ 或者 $n$，则后面的取数一定形成了一个链，因为每次只有一个位置，这种情况可以特判掉，也可以在动态规划中处理掉。

求：多少种必胜开局。

考虑区间动规，让 $dp[i][j]$ 表示 $i$ 到 $j$ 区间的**两边或者中间**开始选择，得到的答案数量，用 $f[i][j]$ 表示**只从两边**开始选，最后的答案数量。很明显，$dp[i][j]$ 是由 $f[i][j]$ 累加过来的。

初始化：

```c++
for (int i = 1; i <= n; i++) {
	dp[i][i] = 1;
	f[i][i] = 1;
}
```

直接用两个循环判断进行值的累加即可，其中 $dp[i][j]$ 由 $dp[i+1][j]$ 和 $dp[i][j-1]$ 进行更新：

```c++
for (int len = 2; len <= n; len++) {
	for (int l = 1; l + len - 1 <= n; l++) {
		int r = i + len - 1;
		//进行累加操作
	}
}
```

---

## 作者：zjzx_wcj (赞：1)

# 题解：P6457 [COCI2006-2007#5] IVANA

[题目传送门](/problem/P6457)

## 思路

经典的区间 dp（模板）。

由于题目里说是一条环，所以就可以自然的想到破环成链。

**重点来了！！！**

我们设 $f_{i,j}$ 为第 $i$ 个数到第 $j$ 个数的这段区间。由于题目只需要奇偶数的判断，所以 $a_i$ 只保留取余 $2$ 的结果。接着来看可行条件：$f_{i,i}-f_{i+1,i+n-1}>0$。就是当先手能取出比后手更多的奇数时，方案数 $+1$。

## 代码参考

```cpp
#include <bits/stdc++.h>
#define int long long
#define elif else if
#define fin(x) freopen (x,"r",stdin)
#define fout(x) freopen (x,"w",stdout)
#define rnt register int
#define reg(i,x,y) for (register int i=(x);i<=(y);++i)
#define Reg(i,x,y) for (register int i=(y);i>=(x);--i)
using namespace std;
namespace rwm {inline int read () {int s=0,w=0;char c=getchar ();while (!isdigit (c)){w|=(c=='-');c=getchar ();}while (isdigit (c)) {s=(s<<1)+(s<<3)+(c^48);c=getchar ();}return w?-s:s;}inline void write (int x) {if (x<0) putchar ( '-'),x=-x;if (x>9) write (x/10);putchar (x%10|48);}inline void writesp (int x) {write (x),putchar (' ');}inline void writeln (int x) {write (x),putchar ('\n');}inline int square (int x) {return x*x;}inline int floor (long double x) {return x;}inline int ceil (long double x) {return (int)(x+0.5);}inline int gcd (int x,int y) {int z=x%y;while (z) x=y,y=z,z=x%y;return y;}inline int lcm (int x,int y) {return x/gcd (x,y)*y;}};
using namespace rwm;
int n,ans,f[501][501];
signed main ()
{
	n=read ();
	reg (i,1,n) f[i][i]=f[i+n][i+n]=read ()%2;
	reg (d,2,n)
		reg (i,1,n*2)
		{
			int j=i+d-1;
			if (j>n*2) break;
			f[i][j]=max (f[i][i]-f[i+1][j],f[j][j]-f[i][j-1]);
		}
	reg (i,1,n)
		if (f[i][i]-f[i+1][i+n-1]>0) ++ans;
	write (ans);
	return 0;
}
```

---

## 作者：wandereman (赞：0)

## 题意
- 第一次取数的玩家可以取任意一个数；
- 第二次取数的玩家只能从上一次取得数的左右两边相邻的两个数中取一个；
- 第三次取数的玩家可以从之前所有取过的任意一个数的左右两边相邻的两个数中取一个；
- 取得最多奇数的玩家获胜；
- 求第一个取的玩家有几种获胜方式；
## 思路
所以我们想到了破坏成链，不会的可以看[这道题](https://www.luogu.com.cn/problem/P1880)。

经过推理，我们得到了如下 DP 式：  
$dp(i,j) = \max(dp(i,i) - dp(i + 1,j),dp(j,j) - dp(i,j - 1))$。

而当满足以下条件时，$cnt$ 自增1。  
$dp(i,i) - dp(i + 1,i + n - 1) > 0$。

最后即可敲出以下程序。
## AC code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll l,i;
ll n,a[110],dp[210][210];
int main(){
	cin>>n;
	for(i = 1;i <= n;i++){
		cin>>a[i];
		a[i]%=2;
		dp[i][i] = dp[i + n][i + n] = a[i];
	}
	for(l = 2;l <= n;l++){
		for(i = 1;i <= (n<<1);i++){
			ll j = i + l - 1;
			if(j > (n<<1)){
				break;
			}
			dp[i][j] = max(dp[i][i] - dp[i + 1][j],dp[j][j] - dp[i][j - 1]);
		}
	}
	ll cnt=0;
	for(i = 1;i <= n;i++){
		if(dp[i][i] - dp[i + 1][i + n - 1] > 0){
			cnt++;
		}
	}
	cout<<cnt;
}
```
##

---


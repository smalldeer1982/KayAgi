# [COCI 2008/2009 #6] CUSKIJA

## 题目描述

给定一个长度为 $n$ 的序列 $a$，请将其重新排序，新序列中任意相邻两个数之和都不能被 $3$ 整除。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^4$，$1 \leq a_i \leq 10^6$。

#### 【说明】

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #6](https://hsin.hr/coci/archive/2008_2009/contest6_tasks.pdf) *T4 CUSKIJA***，翻译与 SPJ 均来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。为了 SPJ 判定方便，输出格式较原题略有修改。

## 样例 #1

### 输入

```
3
1 2 3
```

### 输出

```
Yes
2 3 1```

## 样例 #2

### 输入

```
5
4 6 3 9 8
```

### 输出

```
Yes
3 4 6 8 9```

## 样例 #3

### 输入

```
6
3 7 6 4 2 8
```

### 输出

```
Yes
3 7 4 6 2 8
```

## 样例 #4

### 输入

```
3
3 12 9
```

### 输出

```
No```

# 题解

## 作者：Alex_Wei (赞：12)

> [题面传送门](https://www.luogu.com.cn/problem/P6470)。

> 题意简述：给定一个序列 $a$，求出是否有一种排列满足相邻两数之和不是 $3$ 的倍数。

一些约定：我们设
- 序列 $x$ 为 $a$ 中除三余 $0$ 的数。
- 序列 $y$ 为 $a$ 中除三余 $1$ 的数。
- 序列 $z$ 为 $a$ 中除三余 $2$ 的数。
- $|f|$ 表示序列 $f$ 的大小。

---

首先判断无解。

Case $1$：$|y|+|z|+1<|x|$。

有 $|y|+|z|+1$ 个 “空位” 可以放 $3$ 的倍数，根据抽屉原理，如果 $|x|>|y|+|z|+1$，则必然有两个 $3$ 的倍数放在同一个 “空位” 里，即相邻。故无解。

Case $2$：$|y|,|z|>0$ 且 $|x|=0$。

如果 $|y|,|z|>0$ 且 $|x|=0$，则必然会有一个除三余 $1$ 的数与除三余 $2$ 的数相邻。故无解。

---

接下来考虑构造。构造方法如下：

首先输出所有除三余 $1$ 的数。输出每个数前，如果 $|x|>1$，则先输出一个除三余 $0$ 的数 $x_1$，然后将其从 $x$ 中弹出（$x$ 的大小会减少，即 $|x|\gets|x|-1$）。

- 为什么是 $|x|>1$？因为除三余 $1$ 的数和除三余 $2$ 的数之间要有一个除三余 $0$ 的数隔开来。

接着输出所有除三余 $2$ 的数。输出每个数前，如果 $|x|>0$，则先输出一个除三余 $0$ 的数 $x_1$，然后将其从 $x$ 中弹出（$x$ 的大小会减少，即 $|x|\gets|x|-1$）。

最后可能还剩下一个除三余 $0$ 的数，输出即可。

```cpp
vector <int> b[3];

#define x b[0].size()
#define y b[1].size()
#define z b[2].size()
#define work cout<<b[0].back()<<" ",b[0].pop_back()

int main(){
	int n=read(),a;
	for(int i=1;i<=n;i++)a=read(),b[a%3].pb(a);
	if(y+z+1<x||y&&z&&!x)puts("No"),exit(0);
	puts("Yes");
	for(auto i:b[1]){if(x>1)work; cout<<i<<" ";}
	for(auto i:b[2]){if(x)work; cout<<i<<" ";}
	if(x)work;
	return 0;
}
```

---

## 作者：lvyichen0523 (赞：2)

# [P6470 [COCI2008-2009#6] CUSKIJA](https://www.luogu.com.cn/problem/P6470) 题解

## 题意分析

题目要求重新排序给定的序列 $a$，使得新序列中任意相邻两个数之和都不能被 $3$ 整除。如果存在解，则输出新序列；如果无解，则输出`No`。

## 思路与算法

### 分析原题

首先，我们需要明确一个性质：对于两个整数 $x$ 和 $y$，它们的和对 $3$ 取余等于 $0$，当且仅当 $x$ 和 $y$ 对 $3$ 取余的结果分别为 $1$ 和 $2$，或者分别为 $2$ 和 $1$。

换句话说，如果 $x + y \equiv 0 \pmod 3$，那么一定 $(x\bmod3)=1$ 且 $(y\bmod3)=2$，或者 $(x \bmod3)=2$ 且 $(y\bmod3)=1$。

### 深度优先搜索

基于上述性质，我们可以使用深度优先搜索来尝试构建符合条件的新序列。我们从第一个位置开始，依次尝试将 $1$、$2$、$0$（余数分别为  $1$、$2$、$0$）放入新序列的当前位置。

在每个位置，我们需要确保当前位置和前一个位置的元素之和不能被 $3$ 整除。通过递归搜索，我们可以尝试所有可能的排列。

## 代码实现

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int a[3][10005], d[3], e[3], f[10005], g;
bool h;

// 输出新序列
void print() {
    h = true;
    cout << "Yes\n";
    memset(e, 0, sizeof e);
    for (int i = 1; i <= g; i++) {
        cout << a[f[i]][++e[f[i]]] << " ";
    }
    return;
} 

// 深度优先搜索
void dfs(int x) {
    if (h) {
        return;
    }
    if (x > g) {
        print();
        return;
    }
    for (int i = 0; i < 3; i++) {
        if (d[i] <= 0) {
            continue; 
        }
        // 确保相邻元素之和不能被 3 整除
        if (x != 1 && (f[x - 1] + i) % 3 == 0) {
            continue; 
        }
        f[x] = i;
        d[i]--;
        dfs(x + 1);
        d[i]++; 
    }
    return;
}

int main() {
    // 读取序列长度
    scanf("%d", &g);

    // 读取序列元素，并统计每个余数的个数
    for (int i = 1; i <= g; i++) {
        int x = 0;
        scanf("%d", &x);
        d[x % 3]++;
        a[x % 3][d[x % 3]] = x;
    }

    // 深度优先搜索寻找解
    dfs(1);

    // 输出结果
    if (!h) {
        cout << "No\n"; 
    }
    return 0;
}
```
第一篇题解，望通过！

---

## 作者：Special_Judge (赞：2)

构造题，首先题目中的所有数可以模 $3$ ，这显然不影响对答案的构造。然后翻译题目的条件：$0$ 不能和 $0$ 相邻，$1$ 不能和 $2$ 相邻，于是我们可以先考虑把所有的 $1$ 和 $2$ 都放在一起，然后用一个 $0$ 把这一坨 $1$ 和 $2$ 隔开，于是形成一个类似于下面的序列：
$$
11 \dots 11022\dots22
$$
这样的序列显然是合法的。然后考虑剩下的 $0$ 应该怎么放就行了，显然我们可以把这些 $0$ 放在任意两个 $1$ 的中间或者最左边，也可以放在任意两个 $2$ 的中间或者最右边。一个一个放，放不下了就是无解。然后就是一大堆的特判，比如有 $1$ 有 $2$ 但是没有 $0$，再比如只有 $1$ 或者只有 $2$...

代码因为我写了一坨所以就不放了。

---

## 作者：Paris_Commune (赞：2)

### 分析

先按是否有解来分析。

两个数相加为 $3$ 的倍数时当且仅当都是 $3$ 的倍数或两个数除 $3$ 的余数是 $1$ 或 $2$。

- 无解 

不能被 $3$ 整除的数加 $1$ 小于 $3$ 的倍数，则必有两个数相邻。

没有 $3$ 的倍数但有除 $3$ 余数是 $1$ 的数和除 $3$ 余数是 $2$ 的数。

- 有解

考虑构造。

我们先用除 $3$ 余数是 $1$ 的数和 $3$ 的倍数交错出现，如果还有 $3$ 的倍数则用除 $3$ 余数是 $2$ 的数和 $3$ 的倍数交错出现，如果还剩余不能整除 $3$ 的数则输出即可。

如果没有 $3$ 的倍数，直接输出即可。

### AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[10005],cnt1,cnt2,cnt3,l1[10005],l2[10005],l3[10005];
main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]%3==0){
			cnt3++;
			l3[cnt3]=a[i];
		}
		else if(a[i]%3==1){
			cnt1++;
			l1[cnt1]=a[i];
		}
		else if(a[i]%3==2){
			cnt2++;
			l2[cnt2]=a[i];
		}
	}
	if(cnt3==0&&cnt1!=0&&cnt2!=0){
		cout<<"No";
		return 0;
	}
	if(cnt1+cnt2+1<cnt3){
		cout<<"No";
		return 0;
	}
	cout<<"Yes\n";
	if(cnt3==0){
		for(int i=1;i<=n;i++){
			cout<<a[i]<<' ';
		}
		return 0;
	}
	if(cnt3<cnt1){
		int tmp=cnt1-cnt3;
		for(int i=1;i<=tmp;i++){
			cout<<l1[i]<<' ';
		}
		for(int i=tmp+1;i<=cnt1;i++){
			cout<<l1[i]<<' '<<l3[i-tmp]<<' ';
		}
		for(int i=1;i<=cnt2;i++){
			cout<<l2[i]<<' ';
		}
		return 0;
	}
	if(cnt1+cnt2+1==cnt3){
		cout<<l3[cnt3]<<' ';
		cnt3--;
	}
//	cout<<cnt1<<' '<<cnt2<<' '<<cnt3<<'\n';
	for(int i=1;i<=cnt1;i++){
		cout<<l1[i]<<' '<<l3[i]<<' ';
	}
	for(int i=cnt1+1;i<=cnt3;i++){
		cout<<l2[i-cnt1]<<' '<<l3[i]<<' ';
	}
	for(int i=cnt3+1;i<=cnt2+cnt1;i++){
		cout<<l2[i-cnt3]<<' ';
	}
	return 0;
}
```

---

## 作者：Hulless_barley (赞：2)

[原题](https://www.luogu.com.cn/problem/P6470)

虽然这是道绿题，但其实难度也就和黄题差不多，主要考察数学思路。

我们先了解一下余数的可加性：

> $A$ 与 $B$ 的和除以 $C$ 的余数，等于 $A$、$B$ 分别除以 $C$ 的余数的和。
> 
>即 $((A\bmod C)+(b\bmod C))\bmod c=(A+B)\bmod C$

这有啥用呢？也就意味着每一个数字我们不需要考虑具体数值是多少，直接按除以 $3$ 的余数分类就可以了！

然后再思考一下什么情况下输出`No`：
1. 根据上述原理，除以 $3$ 的余数分别为 $1$、$2$ 的两个数中间必须有一个余数为 $0$ 的数隔开，否则无解；
2. 根据上述原理，$3$ 的倍数不能相邻，中间必须有一个非 $3$ 的倍数隔开，否则无解。

其余情况都有解，那如何凑出解呢？仍然是分两种情况讨论：
1. 如果没有 $3$ 的倍数，那么直接输出全部的数就行了，因为要么只有除以 $3$ 余 $1$ 的数，要么只有除以 $3$ 余 $2$ 的数（不然就已经输出`No`了）。
2. 插空法。把所有除以 $3$ 余 $2$ 的数放在除以 $3$ 余 $1$ 的数后面，放一个 $3$ 的倍数在两组数之间，其余的插空放。

虽然这题不难，但是代码写起来还是要注意细节，不然可能会[像我一样](https://www.luogu.com.cn/record/list?pid=P6470&user=1025958)。

用`mod[i]`保存除以 $3$ 余 $i$ 的数，用`top[i]`保存除以 $3$ 余 $i$ 的数的个数。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int mod[4][N],top[4];
int n,x;
int main(){
    cin>>n;
    for(register int i=1;i<=n;i++){
        scanf("%d",&x);
        mod[x%3][++top[x%3]]=x;
    }
    if(top[0]==0&&top[1]!=0&&top[2]!=0){puts("No");return 0;}
    else if(top[1]+top[2]+1<top[0]){puts("No");return 0;}
    puts("Yes");//puts输出自动换行 
    if(top[0]==0){//当top[0]==0时，top[1]和top[2]有一个也为0，直接输出 
        for(int i=1;i<=top[1];i++)printf("%d ",mod[1][i]);
        for(int i=1;i<=top[2];i++)printf("%d ",mod[2][i]);
        return 0;
    }
    for(int i=1;i<=top[1];i++){
        if(top[0]-1>0)printf("%d ",mod[0][top[0]--]);//保留一个3的倍数用来隔开mod[1]和mod[2]里面的数 
        printf("%d ",mod[1][i]);
    }
    printf("%d ",mod[0][top[0]--]);//输出这个数 
    for(int i=1;i<=top[2];i++){
        printf("%d ",mod[2][i]);//这里要反过来，先输出mod[2]，再输出mod[0]，不然可能会mod[0]与上一行输出的数相加是3的倍数 
        if(top[0]>0)printf("%d ",mod[0][top[0]--]);
    }
    return 0;
}
```


---

## 作者：ICU152_lowa_IS8 (赞：1)

本题是一道构造入门题。

思维难度其实不高，建议降黄甚至橙。

___

观察可以得到，本题构造的答案仅与 $a_i\bmod3$ 的值有关。

我们可以得出几个推论：

1.当 $a_i\bmod3=1$，$a_j\bmod3=2$ 时，$a_i$ 和 $a_j$ 不能放到一起；

2.当 $a_i\bmod3=0$，$a_j\bmod3=0$ 时，$a_i$ 和 $a_j$ 不能放到一起；

3.若 $a_i\bmod3=a_j\bmod3$ 且 $a_i\bmod3$ 的值不为 $0$ 时，$a_i$ 和 $a_j$ 可以放在一起；

4.若 $a_i\bmod3\not= a_j\bmod3$ 且 $a_i\bmod3=0$ 的情况时，$a_i$ 和 $a_j$ 可以放到一起。

有了这些推论就好做题了：

___

首先观察结果为 `No` 的情况：

当数列中只有 $a_i\bmod3=0$ 的数时，显然无解（第二条推得）；

当数列中包含 $a_i\bmod3=1$ 和 $a_i\bmod3=2$ 且不包含 $a_i\bmod3$ 的数时，无解（第一条推得）；

当数列中包含 $x$ 个 $a_i\mod3=1$ 的数和 $y$ 个 $a_i\mod3=2$ 的数和 $z$ 个 $a_i\mod3=0$ 的数且 $x+y<z$ 时，没有足够的数字隔开两个 $a_i\bmod3=0$ 的数，无解（第四条、第三条、第二条推得）（顺便说一句不加这个判断好像也能过）。

然后再讨论结果为 `Yes` 的情况：

根据第一条和第二条，可以得出 $a_i\bmod3=1$ 和 $a_i\bmod3=2$ 的两个数之间必然隔着一个且仅有一个 $a_i\bmod3=3$ 的数。

构造讲究的就是一个简单，所以直接选择分别扔到两端（第三条）并在中间放一个 $a_i\bmod3=0$ 的数即可。

然后可能还剩一堆 $a_i\bmod3=0$ 的数，根据第二条、第四条，直接插空即可。

代码写的很答辩，不建议参考：

```
#include<bits/stdc++.h>
using namespace std;
int a[100005];
int f[3];
int print[5][100005];
int ans[100005],p=0;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[a[i]%3]++;
//		cout<<a[i]<<endl;
	} 
	if(f[1]>0&&f[2]>0&&f[0]==0){
		cout<<"No";
		return 0;
	}
	if(f[1]==0&&f[2]==0&&f[0]>0){
		cout<<"No";
		return 0;
	}
	if(f[1]+f[2]<f[3]-1){//把这个注释了也能过 
		cout<<"No";
		return 0;
	}
	cout<<"Yes\n";
	while(f[2]>0){
		if(f[0]>1){
			ans[++p]=0;
			f[0]--;
		}
		ans[++p]=2;
		f[2]--;
	}
	if(f[0]>0)
	ans[++p]=0;
	f[0]--;
	while(f[1]>0){
		ans[++p]=1;
		if(f[0]>1){
			ans[++p]=0;
			f[0]--;
		}
		f[1]--;
	}
	for(int i=1;i<=n;i++){
//		cout<<a[i]<<" ";
		print[a[i]%3][++print[a[i]%3][0]]=a[i];
	}
	for(int i=1;i<=n;i++){
		cout<<print[ans[i]][print[ans[i]][0]--]<<" ";
	}
	return 0;
}

```


---

## 作者：Loser_Syx (赞：1)

考虑存储每个 $a_i$ 所属的 $a_i\bmod 3$ 的集合。  
首先肯定知道，$(1+2)\bmod 3 = 0$，所以 $a_i \bmod 3=1$ 与 $a_i \bmod 3=2$ 的绝对不能放一起。  
于是可以进行分类讨论：

- 当不存在 $a_i \bmod 3=0$ 的数，如果不是只存在一种 $\bmod3$ 的不同情况的话，那么就无解，否则就输出那唯一的那一些数字。

- 当 $a_i \bmod 3=0$ 的个数大于 $a_i \bmod 3=1$ 的个数 $a_i \bmod3=2$ 的个数 $+1$ 时，必定无解。（加一是因为可以是类如 `0 1 0 1 ... 0 ... 2 0 2 0` 的样子）

- 否则，考虑在 $a_i \bmod 3=1$ 和 $a_i \bmod 3=2$ 的集合内穿插若干个 $a_i \bmod 3=0$ 的数，注意 $a_i \bmod3 = 1$ 与 $a_i \bmod3 = 2$ 的连接处必须存在一个 $a_i \bmod 3=0$ 的数。

```cpp
#define eb emplace_back
signed main() {
	int n = read();
	vector<int> a(n);
	vector<int> mod0, mod1, mod2;
	for (auto&i : a) read(i);
	for (const auto&i : a) {
		if (i % 3 == 0) mod0.eb(i);
		else if (i % 3 == 1) mod1.eb(i);
		else mod2.eb(i);
	}
	if (mod0.empty()) {
		if (mod1.size() && mod2.size()) return puts("No"), 0;
		puts("Yes");
		if (mod1.size()) for (const auto&i : mod1) write(i, ' ');
		else for (const auto&i : mod2) write(i, ' ');
	} else if (mod0.size() - 1 > mod1.size() + mod2.size()) {
		puts("No");
	} else {
		puts("Yes");
		int len = mod0.size();
		int now = 1;
		for (int i = 0; i < (int)mod1.size(); ++i) {
			if (now != len) write(mod0[now++], ' ');
			write(mod1[i], ' ');
		}
		write(mod0[0], ' ');
		for (int i = 0; i < (int)mod2.size(); ++i) {
			write(mod2[i], ' ');
			if (now != len) write(mod0[now++], ' ');
		}
		if (now != len) write(mod0[now++], ' ');
	}
	return 0;
}
```

---

## 作者：船酱魔王 (赞：1)

# P6470 [COCI2008-2009#6]CUSKIJA 题解

## 题意回顾

将一个长度为 $ n $ 的序列 $ a $ 重排，使得任何相邻两数之和不能被 $ 3 $ 整除，或报告无解。

## 分析

一道分类讨论型构造题。

我们不关心原数值，只关心模 $ 3 $ 的余数。

我们记 $ c_i $ 表示模 $ 3 $ 余 $ i $ 的数的剩余个数。我们称 $ i $ 为模 $ 3 $ 余 $ i $ 的数。

当 $ c_0=0 $ 时，

* 如果 $ c_1 > 0 $ 且 $ c_2 > 0 $，我们必然会出现 $ 1 $ 和 $ 2 $ 相连的情况，模 $ 3 $ 余 $ 0 $，所以无解。

* 否则，$ c_1=0 $ 或 $ c_2=0 $，将所有的 $ 1 $ 或 $ 2 $ 直接排列即可。

当 $ c_0 > 0 $ 时，

* 如果 $ c_1+c_2 \ge c_0-1 $，意味着 $ 0 $ 可以不相邻，$ 1,2 $ 中间可以放 $ 0 $，也可以不相邻。如果 $ 1 $ 多我们就先在前面放 $ 1 $ 直到 $ c_1 \le c_0-1 $，接下来用 $ 0 $ 和 $ 1 $ 交替，如果 $ 1 $ 用完就用 $ 2 $ 和 $ 0 $ 交替，最后把所有多余的 $ 2 $ 都放到结尾即可。

* 否则，即 $ c_1+c_2 < c_0-1 $，意味着 $ 0 $ 一定会相邻，所以无解。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1e6 + 5;
int n;
int a[N];
int cnt[3];
struct link {
    int len;
    int num[N];
    void push(int x) {
        len++;
        num[len] = x;
    }
    void pop() {
        len--;
    }
    void popall() {
        len = 0;
    }
    void out() {
        printf("%d ", num[len]);
        len--;
    }
} tl[3];
int main() {
    int t1;
    while(scanf("%d", &n) != EOF) {
        for(int i = 0; i < 3; i++) {
            tl[i].popall();
            cnt[i] = 0;
        }
        for(int i = 1; i <= n; i++) {
            scanf("%d", &a[i]);
            cnt[a[i] % 3]++;
            tl[a[i] % 3].push(a[i]);
        }
        if(cnt[0] == 0) {
            if(cnt[1] == 0 || cnt[2] == 0) {
                printf("Yes\n");
                if(cnt[1] == 0) {
                    t1 = 2;
                } else {
                    t1 = 1;
                }
                for(int i = 1; i <= cnt[t1]; i++) {
                    tl[t1].out();
                }
                printf("\n");
            } else {
                printf("No\n");
            }
        } else {
            if(cnt[1] + cnt[2] >= cnt[0] - 1) {
                printf("Yes\n");
                if(cnt[1] >= cnt[0] - 1) {
                    for(int i = 1; i <= cnt[1] - cnt[0] + 1; i++) {
                        tl[1].out();
                    }
                    tl[0].out();
                    for(int i = 1; i <= cnt[0] - 1; i++) {
                        tl[1].out();
                        tl[0].out();
                    }
                    for(int i = 1; i <= cnt[2]; i++) {
                        tl[2].out();
                    }
                    printf("\n");
                } else {
                    tl[0].out();
                    for(int i = 1; i <= cnt[1]; i++) {
                        tl[1].out();
                        tl[0].out();
                    }
                    cnt[0]--;
                    cnt[0] -= cnt[1];
                    for(int i = 1; i <= cnt[0]; i++) {
                        tl[2].out();
                        tl[0].out();
                    }
                    cnt[2] -= cnt[0];
                    for(int i = 1; i <= cnt[2]; i++) {
                        tl[2].out();
                    }
                    printf("\n");
                }
            } else {
                printf("No\n");
            }
        }
    }
    return 0;
}
```

---

## 作者：I_will_AKIOI (赞：0)

题目让我们不能将相加被 $3$ 整除的数放在一起，所以我们先预处理出每个数对 $3$ 取模的值，放在不同的容器内。我这里使用队列，也可以换成 vector 等。

接下来特判无解的情况。我们知道，$1+2\equiv0\pmod 3,0+0\equiv 0\pmod 3$。所以如果只有 $1$ 和 $2$，或者 $0$ 超过一半，就不可能完成任务。

然后我们就开始填数了。我们将数字交叉放置，也就是在两个数中间填 $0$，就可以保证 $0$ 不相连、$1$ 和 $2$ 也不相连。举个例子，当数据是 $012012012$ 时，就是这样：$101010222$。

打出来后发现样例过不了。样例 $1$ 中我们先用了 $0$，导致 $1$ 和 $2$ 只能连在一起。所以我们规定：只有当 $0$ 的个数大于 $1$ 时，才能将 $0$ 放在 $1$ 的前面。这样后面的 $1$ 和 $2$ 才可以被隔开。

```
#include<bits/stdc++.h>
using namespace std;
queue<int>q[3];
int n,x;
void print(int x)
{
  cout<<q[x].front()<<" ";
  q[x].pop();
}//输出队头的数字并删除
int main()
{
  ios::sync_with_stdio(0);
  cin>>n;
  for(int i=1;i<=n;i++)
  {
  	cin>>x;
  	q[x%3].push(x);//分类
  }
  int x,y,z;
  x=q[0].size(),y=q[1].size(),z=q[2].size();
  if((x==0&&y&&z)||x>ceil(n/2.0)) cout<<"No";//不满足要求的特判出去
  else
  {
    cout<<"Yes\n";
    for(int i=1;i<=y;i++)
	{
	  if(q[0].size()>1) print(0);
      //当0的个数为1时，若放置，
      //会导致1和2连在一起，没有0用来断开
	  print(1);
    }
    for(int i=1;i<=z;i++)
	{
	  if(q[0].size()) print(0);
	  print(2);
	}
	if(q[0].size()) print(0);//输出多出的0
  }
  return 0;
}
```

---

## 作者：QianRan_GG (赞：0)

## 题目描述

给定一个序列，将其重新排序使得相邻两个数之和不能被三整除。

## 解题思路

做一道构造题，首先我们要知道什么时候有解，什么时候无解。

因为是被三整除，所以我们可以记录：

- $p_0$ 表示模三为 $0$ 的数的个数
- $p_1$ 表示模三为 $1$ 的数的个数
- $p_2$ 表示模三为 $2$ 的数的个数


------------


首先判断无解的情况。

当两个数之和可被三整除时，只有两种情况：

1. 两个数模三都为 $0$。

模三不为 $0$ 的数的个数为 $p_1 + p_2$。  
所以一共有 $p_1 + p_2 + 1$ 个位置可放模三为 $0$ 的数。  
所以若 $p_0 > p_1 + p_2 + 1$ 时，必有至少两个模三为 $0$ 的数相邻，无解。

2. 一个数模三为 $1$，另一个数模三为 $2$。

先不考虑模三为 $0$ 的数。  
我们将模三为 $1$ 的数放在一起，将模三为 $2$ 的数放在一起。  
当 $p_1,p_2 > 0$ 时，必有一处使模三为 $1$ 和模三为 $2$ 的数相邻。  
此时要用至少一个模三为 $0$ 的数来隔开。
所以若$p_1, p_2 > 0$，$p_3 = 0$ 时无解。


------------

然后考虑有解时的构造。

首先将模三为 $1$ 的数放在一起输出，将模三为 $2$ 的数放在一起输出。  
在其间用一个模三为 $0$ 的数将模三为 $1$，模三为 $2$ 的隔开。  
剩下的模三为 $0$ 的数随意插在任意两个模三不为 $0$ 的数中间。  
为保证构造成功，将模三为 $0$ 的数从左往右插。
这样就搞糟好了。

## 代码

```cpp
#include <iostream>

using namespace std;

const int N = 1e4 + 5;

int l0, l1, l2, x;
int p0[N], p1[N], p2[N];

int read()
{
	char c = getchar();
	int f = 1,sum = 0;
	while(c < '0' || c > '9')
	{
		if(c == '-') f = (~f) + 1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
		sum = (sum << 1) + (sum << 3) + c - '0', c=getchar();
	return f * sum;
}

void write(int x)
{
	if(x < 0)
		x = (~x) + 1, putchar('-');
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

void write_ (int x)
{
	write(x), putchar(' ');
}

int main()
{
	int n; n = read();
	for(int i = 1; i <= n; ++ i)
	{
		x = read();
		if(x % 3 == 0) p0[ ++ l0] = x;
		if(x % 3 == 1) p1[ ++ l1] = x;
		if(x % 3 == 2) p2[ ++ l2] = x;
	}
	if(l1 && l2 && !l0) return printf("No"), 0;
	if(l0 > l1 + l2 + 1) return printf("No"), 0;
	printf("Yes\n");
	for(int i = 1; i <= l1; ++ i)
	{
		if(l0 > 1) write_(p0[l0 -- ]); // 保证有一个数插在模三为 1 和模三为 2 的中间
		write_(p1[i]);
	}
	for(int i = 1; i <= l2; ++ i)
	{
		if(l0) write_(p0[l0 -- ]); // i = 1 时就能保证插在模三为 1 和模三为 2 的中间
		write_(p2[i]);
	}
	if(l0) write(p0[l0 -- ]); return 0; // 可能还剩一个数要放在末尾
}
```

#### 我讨厌构造题（虽然这题简单）

---

## 作者：allqpsi (赞：0)

### 题目大意：

这没必要写了吧……

### 思路：

- 暴力，枚举每一种排序，在判断。~~显然会爆。~~

- 我们其实可以发现：我们对于每个数的位置，只需要考虑他对三的余数。我们可以用此剪枝。~~显然还会爆。~~

- 正解：其实，我们不必枚举所有情况，只需发现一个可行方案就可以了。所以，我们可以根据余数，把每个数分配位置。

### 实现：

#### 情况一：没有可行方案，这有两种情况：

- 余数为二或一的数量加一小于余数为三的数量。这样意味应为不够位置，有两个余数为三的数会相邻，就没有可行方案。

- 余数为二或一的数量大于一，并且没有余数为三的数。这样意味应会有一个余数为一的数和一个余数为二的数会相邻，就也没有可行方案。

#### 情况二：有可行方案。

我们要事先分别把余数为一的数和余数为二的数和余数为三的数与处理出来。

这样，我们可以先用余数为一的数把余数为三的数分开，余数为一的数用完了，就用余数为二的数。再吧余数为一的数合在一起和余数为二的数合在一起。我们最后要留一个余数为三的数，吧余数为一的数和余数为二的数分开。

注意！如果只有余数为一的数或余数为二的数，就全部输出就可以了。

### 激动人心的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,vi[10005],f[10005],gi[10005],l0,l1,l2,r1,r2,r0;
struct node{
	int x,id;
};
node ai[10005];
bool cmp(node a,node b){
	return a.x<b.x;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>vi[i];
		ai[i].x=vi[i]%3;
		ai[i].id=i;
		f[vi[i]%3]++;
	}
	sort(ai+1,ai+1+n,cmp);
	if(f[0]==0&&f[1]>0&&f[2]>0){
		cout<<"No";
		return 0;
	}
	if(f[1]+f[2]+1<f[0]){
		cout<<"No";
		return 0;
	}
	cout<<"Yes"<<endl;
	l0=1;
	r0=f[0];
	l1=f[0]+1;
	r1=f[0]+f[1];
	l2=f[0]+f[1]+1;
	r2=f[0]+f[1]+f[2];
	while(l0<r0){
		cout<<vi[ai[l0].id]<<' ';
		l0++;
		if(l1<=r1){
			cout<<vi[ai[l1].id]<<' ';
			l1++;
		}
		else{
			cout<<vi[ai[l2].id]<<' ';
			l2++;
		}
	}
	while(l1<=r1){
		cout<<vi[ai[l1].id]<<' ';
		l1++;
	}
	if(f[0]>0){
		cout<<vi[ai[l0].id]<<' ';
	}
	while(l2<=r2){
		cout<<vi[ai[l2].id]<<' ';
		l2++;
	}
}
```


---

## 作者：syf2008 (赞：0)

这是一道构造题。（~~废话~~）

根据题意，我们需要构建一个新序列，使其中任意相邻两个数之和都不能被 $3$ 整除。

在什么情况下会出现相邻两个数之和被 $3$ 整除呢？

设其中一数为 $x$，另一数为 $y$。在 $x\%3==0$ 且 $y\%3==0$ 或 $x\%3==1$ 且 $y\%3==2$ 或 $x\%3==2$ 且 $y\%3==1$ 时会被 $3$ 整除。

所以我们要把 $\%3==1$ 和 $\%3==2$ 的数分开。（两个 $\%3==0$ 的数也要分开）

什么情况无解呢?

1. 没有足够的 $\%3==0$ 的数能将 $\%3==1$ 和 $\%3==2$ 的数分开。
1. 没有足够的 $\%3==1$ 和 $\%3==2$ 的数能将两个 $\%3==0$ 的数分开。

上代码
```
#include <bits/stdc++.h>
using namespace std;
int a[10005],b1[10005],b2[10005],b3[10005],n,s1,s2,s3;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(a[i]%3==1)//将%3==0，%3==1，%3==2的分割开来
		b1[++s1]=a[i];
	else if(a[i]%3==2)
		b2[++s2]=a[i];
	else b3[++s3]=a[i];
	}
	if((!s3&&s1&&s2)||s3>s1+s2+1)//无解1与无解2
	puts("No");
else{
		puts("Yes");
		while(s1&&s3>1)//构造，在每一个中间差一个%3==0的数（但要保留一个分割%3==1和%3==2的）
		{
			cout<<b3[s3]<<' '<<b1[s1]<<' ';
			s1--;
			s3--;
		}
		while(s1)//没有足够的%3==0放置（浪费）
		{
			cout<<b1[s1]<<' ';
			s1--;
		}
		while(s2&&s3)
		{
			cout<<b3[s3]<<' '<<b2[s2]<<' ';
			s2--;
			s3--;
		}
		while(s2)
		{
			cout<<b2[s2]<<' ';
			s2--;
		}
		while(s3)
		{
			cout<<b3[s3]<<' ';
			s3--;
		}
	}
}
```

---

## 作者：_edge_ (赞：0)

题目描述不用我多说了，题面上写得很明白。

首先思考这道题目，可以想出一个非常暴力的解法：

枚举所有的排列情况，然后一个一个验证过去。

这种情况下复杂度最坏是：$O(n! \times n)$。

对于这道题目 $n \le 10^4$ 显然不可能过去。

那么可以进一步思考一下，取模 $3$ 有多少种可能性？

只有 $0,1,2$ 这 $3$ 种可能性，那么对于一个数假设它是取模 $3$ 为 $0$，如果另一个数取模 $3$ 也是零，是不是两者就可以互相交换了？

那么根据 $a\bmod m + b \bmod m =(a+b)\bmod m$ 可以发现总和并不影响交换。

所以确定第 $1$ 个可以直接判断出下一个有多少种情况。

剪枝剪完之后就 A 了。

~~本蒟蒻只会敲暴力，对于这个的复杂度一无所知。~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int INF=1e4+5;
int sum[5][INF],num[5],numr[5],b[INF],n;
bool flag;
void print() {
        flag=true; cout<<"Yes\n"; memset(numr,0,sizeof numr);
        for (int i=1; i<=n; i++)
                cout<<sum[b[i]][++numr[b[i]]]<<" ";
        return;
}//如果成立了，直接输出。
void DFS(int x) {
        if (flag) return;
        if (x>n) {print(); return;}
        for (int i=0; i<3; i++) {
                if (num[i]<=0) continue;//判断当前这个 i 有没有取完。
                if (x!=1 && (b[x-1]+i)%3==0) continue;//判断当前这个位置填 i 是否合法。
                b[x]=i; num[i]--;
                DFS(x+1); num[i]++;//简单的回溯一下。
        }
        return;
}
signed main()
{
        scanf("%d",&n);
        for (int i=1; i<=n; i++) {
                int x=0; scanf("%d",&x);
                num[x%3]++; sum[x%3][num[x%3]]=x;//记录 %3 的一些信息。
        }
        DFS(1);
        if (!flag) cout<<"No\n";//如果找不到，那么输出 No 。
        return 0;
}

```

**谢谢观赏！**

---

## 作者：zh1221_qwq (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P6470)。


------------

 
## 题目简述
给定一个序列，求是否能将它重新排列，使得相邻数的和不能被 $3$ 整除。


------------
## 题目分析

考虑暴力：将原序列的全排列求出，并判断是否合法，会炸。

我们发现，题目只关心能不能被 $3$ 整除，并不在意除数，所以我们只需记录每个数模的 $3$ 余数。

我们令：

* 序列中模 $3$ 余 $0$ 的个数为 $a$。
* 序列中模 $3$ 余 $1$ 的个数为 $b$。
* 序列中模 $3$ 余 $2$ 的个数为 $c$。



------------


### 无解

 当 $b+c+1 < a$ 时，此时必然有两个余数为 $0$ 的数相邻。
 
 当 $b>0$，$c>0$ 且 $a=0$ 时，必然有一个余数为 $1$ 和一个余数为 $2$ 的数相邻。



------------


### 构造

先输出所有余数为 $1$ 的数，在每次输出后，若 $x>1$ 则再输出一个余数为 $0$ 的数。然后再输出余数为 $2$ 的数，在每次输出后，若 $x>0$ 则再输出一个余数为 $0$ 的数。注意，当 $b+c+1=a$ 时，需在开头在输出一个余数为 $0$ 的数。



------------


代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[3][10005],cnt[3]; 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		a[x%3][++cnt[x%3]]=x;
	}
	if(cnt[2]+cnt[1]+1<cnt[0]||(cnt[2]&&cnt[1]&&!cnt[0])){
		cout<<"No";
		return 0;
	}
	cout<<"Yes"<<endl;
	if(cnt[2]+cnt[1]+1==cnt[0])cout<<a[0][cnt[0]--]<<" ";
	while(cnt[0]||cnt[1]||cnt[2]){
		if(cnt[1]){
			cout<<a[1][cnt[1]--]<<" ";
			if(cnt[0]>1)cout<<a[0][cnt[0]--]<<" ";
			else if(cnt[0]&&!cnt[1])cout<<a[0][cnt[0]--]<<" ";
		}
		else {
			if(cnt[2]){
				cout<<a[2][cnt[2]--]<<" ";
				if(cnt[0])cout<<a[0][cnt[0]--]<<" ";
			}
			else 
				cout<<a[0][cnt[0]--]<<" ";
		}
	}
	return 0;
}

```


---


# [COCI 2010/2011 #6] ABECEDA

## 题目描述

人们发现一份字典序未知的单词表。其中共包含 $n$ 个单词。

虽然不知道具体的字典序，但大家已知这些单词在单词表上是按照字典序排列的。

你需要求出这份单词表所依照哪种字典序。

## 说明/提示

#### 样例 1 解释

根据第一列的字母可知，`a` `k` `u` 这三个字母的字典序是 `u` `k` `a`。再观察第二列可知，`l` 排在 `u` 之前。所以最终的字典序为 `luka`，且是唯一解。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 100$，所有的单词仅包含小写字母且最多包含 $10$ 个。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #6](https://hsin.hr/coci/archive/2010_2011/contest6_tasks.pdf) *T4 ABECEDA***。

## 样例 #1

### 输入

```
5
ula
uka
klua
kula
al```

### 输出

```
luka```

## 样例 #2

### 输入

```
4
jaja
baba
baja
beba```

### 输出

```
!```

## 样例 #3

### 输入

```
3
marko
darko
zarko```

### 输出

```
?```

# 题解

## 作者：Listedzero (赞：3)

[传送门](https://www.luogu.com.cn/problem/P6491)

### 题目分析

本题很需要留意细节。

题目会**给出多个字符串，且按照新的字典序排列**，如题目所给所示：

```
5
ula
uka
klua
kula
al
```

显然，在第一列由于 `u` 在 `k` 前出现，所以 `u` 的字典序在 `k` 前。

#### 动机

题目需要求出新字典序，那么，由多个字符串中存在的具有先后且会传递性的关系，我们可以试向建图方向考虑。若要用图的方法去表达并求出这个关系，我们要去联想到**拓扑排序**。

#### 建边

我们需要通过一些关系，建一条由字典序小的指向字典序大的边，且建议用邻接表，最简便。

分析字典序的性质，我们可以得到一个结论：

- 两个相邻字符串中，如果某一列的字符串中的两个字符相等，后一个字符串中同一列的字符不同，那么后一个字符串中的两者可以进行比较，如以下示例：

```cpp
aknoip
akioil
```

上面这连续两个子串中，前两列均相等，当遍历到第三列时不同，可以比较得到字典序关系，那么建边。需要注意的是，**如果此处一旦有不同，那么操作后就应该停止遍历，转而遍历下一对子串**。

#### 排序

![](https://cdn.luogu.com.cn/upload/image_hosting/swiylraj.png)

我们主要讨论以下的两种易错情况：

- **不存在答案**

如下样例：

```cpp
4
cae
cbf
ccf
abc
```

如**图一**所示，在图中 `a`,`b`,`c` 三点成环，会存在矛盾关系，因此我们可以从图上很直观的得出结论：**成环必矛盾**。

那么直接判断在在拓扑排序完后枚举**在图中**的点的入度即可。

- **有多解**

如下样例：

```cpp
6
ccf
cah
cac
cbe
ag
ac
```

如**图二**所示，在 `c` 处它的前驱有 `h` 和 `g`，忽视未在图上的点，那么就会出现 `gcab` 或 `hcab` 两种答案，不符合。

我们可以从图中看出它们的入度均为零。不仅是在第一次将起点入队，也有可能在后面的过程中遇到有多个零入度的点，所以需要在每次枚举后继点时，这里我是将其入队后再判断队中元素大小，若队中存在多个点，那么它**可能**就会是题目中说的多解情况。

这里为什么不直接退出结束呢？那又要回到**图一**中的无解情况。

是的，在后面的排序中还有可能出现成环的情况。而**无解的判断优先级比多解更高**。所以判断完元素后不能直接停止，仍应继续排序，防止因为后续有环出现而导致的误判。

梳理到这，如果将**图二**中删掉使其多解点就一定有确定的字典序吗？并不完全是，要留意**未在图中出现**的那两个点。它们没有任何依据关系来被排序，所以在读入时，需要累计不同字母的个数，再在拓扑排序的最后比较已排序的字母与所有出现的字母的个数即可。

而剩下的情况就可以直接输出。

### 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,rd[200],ans[30],cnt,c_cnt;//cnt字典序中个数/c_cnt出现的个数
vector<int>e[200];//建议用邻接表
bool have[200];//统计字母个数的
string c[120];
void topo(){
	bool cir=0;
	queue<int>q;
	for(int i=int('a');i<=int('z');i++)//可能可以作为起点,入队       
		if(rd[i]==0&&e[i].size()>0){ 
			q.push(i);
			ans[++cnt]=i;
		}
	while(q.size()){//如果入队后中的元素超过1个，那么可能多解，先记录      
		if(q.size()>1)
			cir=1;
		int top=q.front();
		q.pop();
		for(auto nxt:e[top])
			if(--rd[nxt]==0){
				q.push(nxt);
				ans[++cnt]=nxt;
			}
	}
	for(int i=int('a');i<=int('z');i++)//入度未归零，有环 		
      if(rd[i]){
			cout<<"！";
			exit(0);
		}
	if(cir){//顺序的冲突优先级高于多解的可能       
		cout<<"?";
		exit(0);
	}//已排序的字母个数少于出现过的字母的个数   
	if(cnt<c_cnt){
		cout<<"?";
		exit(0);
	}
	for(int i=1;i<=cnt;i++) cout<<char(ans[i]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1;i<=n;i++) 
		for(int j=0;j<c[i].size();j++) 
			if(!have[int(c[i][j])])//累计出现字母个数              
				have[int(c[i][j])]=1,c_cnt++;	
	for(int i=2;i<=n;i++){						
		for(int j=0;j<min(c[i].size(),c[i-1].size());j++){//每个子串首字母，互异则前者字典序更小           
			if(j==0&&c[i-1][0]!=c[i][0]){		
				int x=int(c[i-1][0]),y=int(c[i][0]);
				e[x].push_back(y);
				rd[y]++;
				break;
			}//各自前一个字符相同，则后一个可以比较大小 
			if(j!=0&&c[i-1][j-1]!=c[i][j-1]) 
				break;//某两行相比较，如果一旦其中某一列不同，那么即使后面相同，也不能进行关系比较 
			if(j!=0&&c[i-1][j]!=c[i][j]){
				int x=int(c[i-1][j]),y=int(c[i][j]);
				e[x].push_back(y);
				rd[y]++;
				break;							
			}
		}
	}
	topo();
	return 0;
}
```

---

## 作者：lyms_Hz17 (赞：1)

# trie 树建图 floyd 最长路 
[**我的博客**](https://www.cnblogs.com/lymsHz17/p/19049440)
## 正文：
容易知道它让我们求的是一个各个字符的总体大小顺序，这个东西在知道一定量的基础大小关系后是可以用 floyd 跑最长路求解的，下面给出解析。
***

### Trie 树求基础大小关系：

看到按照某种字典序排列，首先要了解字典序排列是怎么排的，我们认为读者都知道是怎么排的，就直接列出一个要用的事实。

- 前 $n$ 个字符相等的 $m$ 个字符串的第 $n+1$ 个字符的大小关系为其字符串的排名从大到小。

而我们可以将字符串按照输入的顺序插入 Trie，每建一个新节点就意味着新节点代表的字符要小于这个新节点的父亲节点插入的上一个儿子节点的字符，可以用这个得到一些基础的大小关系。

以样例为例，如下图：

1. 插入 `ula`。\
![](https://cdn.luogu.com.cn/upload/image_hosting/sgdlhay0.png)\
没有得到任何大小关系。

2. 插入 `uka`。\
![](https://cdn.luogu.com.cn/upload/image_hosting/zcn5uxnq.png)\
得到了 $l < k$。

以此类推便可以得到所有**基础**大小关系。

##### 这里给出示例代码：
```cpp
struct node {
    int ch[27], lasch;
} t[26 * 1001];
int cnt = 1;

inline void insert(string a) {
    int p = 1;
    for(uint i = 0; i < a.size(); i ++) {
        int c = a[i] - 'a' + 1; // 加一是和 0 区分
        if(t[p].ch[c]) p = t[p].ch[c];
        else {
            if(t[p].lasch) {
                dis[t[p].lasch][c] = e[t[p].lasch][c] = 1; // 这里建立大小关系
                if(e[c][t[p].lasch]) {
                    putchar('!');
                    exit(0);
                }
            }
            t[p].lasch = c; // 记录上一个
            p = t[p].ch[c] = ++cnt;
        }
    }
}
```
***
### floyd 求总大小关系

我们已经了解了一些字符之间的基础大小关系，那么就来扩展它们。举几个例子看一下吧。

如 $a > b$，$b > c$ 的简单关系。我们可以建图，建立以大小关系连接的边权为 $1$ 的有向图，如下。\
![](https://cdn.luogu.com.cn/upload/image_hosting/qvmy7hdi.png)\
从 $c$ 到 $a$ 的最长路径为 $2$，这是所有到达 $a$ 的路径中的最长路，容易注意到，这个 $2$ 也是所有小于 $a$ 的字符的数量。

再看无解的情况，如 $a > b$，$b > c$，$c > a$，如图。\
![](https://cdn.luogu.com.cn/upload/image_hosting/ytbjxkpb.png)\
容易发现出现了环。

最后是多组解的情况，如 $a > b$，$c > b$。\
![](https://cdn.luogu.com.cn/upload/image_hosting/6b7ayn0t.png)\
发现到达 $a$、$c$ 的最长路长度相同，都为 $1$。

稍微推广，我们就可以得到以下几个事实。

1. 对于任意点 $x$，到达 $x$ 的所有路径中的最长路经长度为点 $x$ 的排名数 $-1$。
2. 若图中存在环，或者说出现了最长路长度为无限的情况，这意味着一个数以某种传递方式大于了自己，也就是无解了。
3. 通过以上方式求出的每个点的排名都是唯一的，如果不唯一就意味着存在多组解，无法得到整体的大小关系。

故跑完 floyd 就可以得到**总体**大小关系。
##### 这里给出示例代码：
```cpp
for(int k = 1; k <= 26; k ++) {
    for(int i = 1; i <= 26; i ++) // 求最长路
        for(int j = 1; j <= 26; j ++) 
            if(i != j and k != i and k != j) 
                if(dis[k][j] and dis[i][k] and dis[i][j] < dis[i][k] + dis[k][j]) 
                    dis[i][j] = dis[i][k] + dis[k][j];

    for(int i = 1; i <= k; i ++) // 判断环
        for(int j = 1; j <= k; j ++) 
            if(dis[i][j] and e[j][k] and e[k][i]) {
                putchar('!');
                exit(0);
            }
}
int rk[27] = {}; // 记录排名
for(int i = 1; i <= 26; i ++) {
    for(int j = 1; j <= 26; j ++)
        if(hs[i]) // hs 代表某字符是否出现过
            rk[i] = max(rk[i], dis[i][j] + 1);
}
```
***
~~虽然把上面代码拼起来再写两笔就是完整代码但是我就是要单独贴出来完整代码。~~
### 完整代码（有注释）：
```cpp
// code by 樓影沫瞬_Hz17
#include <bits/stdc++.h>
#define int long long
#define en_ putchar('\n')
#define e_ putchar(' ')
using namespace std;
inline int in() { 
    int n = 0, p = getchar();
    while (p < '-')p = getchar();
    bool f = p == '-' ? p = getchar() : 0; //
    do n = n * 10 + (p ^ 48), p = getchar();
    while (isdigit(p));
    return f ? -n : n; //
    return n;
}
inline int in(int &a) { return a = in(); }
inline void out(int n) {
    if(n < 0) putchar('-'), n = -n;
    if(n > 9) out(n / 10);
    putchar(n % 10 + '0');
}

int n;
int hs[27]; // 记录某字母是否出现
string a[101]; // 字符串

struct node {
    int ch[27], lasch;
} t[26 * 1001]; // trie 结构体
int cnt = 1;
int dis[27][27], e[27][27]; // 记录边和最长路

inline void insert(string a) { // 见上文，不赘述
    int p = 1;
    for(uint i = 0; i < a.size(); i ++) {
        int c = a[i] - 'a' + 1;
        if(t[p].ch[c]) p = t[p].ch[c];
        else {
            if(t[p].lasch) {
                dis[t[p].lasch][c] = e[t[p].lasch][c] = 1;
                if(e[c][t[p].lasch]) {
                    putchar('!');
                    exit(0);
                }
            }
            t[p].lasch = c;
            p = t[p].ch[c] = ++cnt;
        }
    }
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("i", "r", stdin); // 自动关 freopen 说是
#endif
    in(n);
    for(int i = 1; i <= n; i ++) 
        cin >> a[i], insert(a[i]);
    for(int i = 1; i <= n; i ++) {
        int r = a[i].size() - 1;
        for(int j = 0; j <= r; j ++) 
            hs[a[i][j] - 'a' + 1] = 1;
    } // 就只是读入（我话好多）
    for(int k = 1; k <= 26; k ++) { // 见上文，不赘述
        for(int i = 1; i <= 26; i ++) 
            for(int j = 1; j <= 26; j ++) 
                if(i != j and k != i and k != j) 
                    if(dis[k][j] and dis[i][k] and dis[i][j] < dis[i][k] + dis[k][j]) 
                        dis[i][j] = dis[i][k] + dis[k][j];

        for(int i = 1; i <= k; i ++) 
            for(int j = 1; j <= k; j ++) 
                if(dis[i][j] and e[j][k] and e[k][i]) {
                    putchar('!');
                    exit(0);
                }
    }
    int rk[27] = {}; 
    for(int i = 1; i <= 26; i ++) {
        for(int j = 1; j <= 26; j ++)
            if(hs[i])
                rk[i] = max(rk[i], dis[i][j] + 1);
    }
    int ans[27] = {};
    // 下面是输出
    for(int i = 1; i <= 26; i ++) { 
        if(ans[rk[i]] and rk[i]) { // 如果有相同排名的就是多组解
            putchar('?');
            exit(0);
        }
        ans[rk[i]] = i;
    }
    stack<char> tans;
    for(int i = 1; i <= 26; i ++) {
        if(!ans[i]) break;
        tans.push(ans[i] + 'a' - 1);
    } 
    while(!tans.empty()) {
        putchar(tans.top());
        tans.pop();
    }
}
// 星間~ 干渉~ 融解~ 輪迴~ 邂逅~ 再生~ ララバイ~
// 这一句是给注释的注释：多次元宇宙融合論豪庭！！！
```
#### 时间复杂度：
令 $N$ 为输入字符总数，$M$ 为字母数（即 $26$）。\
复杂度为 $O(N + M ^ 3)$。

---

## 作者：Lucky_Cloud (赞：1)

## 前言

**[更好的阅读体验。](https://www.cnblogs.com/luckycloud/p/17847243.html)**

思维难度：绿。

代码难度：绿/蓝。

综合：绿/蓝。

带来两种做法。主要是预处理的部分不同，所以就来水一篇。

[传送门](https://www.luogu.com.cn/problem/P6491)。

[前置芝士](https://oi-wiki.org/graph/topo/)。

## 分析

我们很容易想到通过输入去确定大概的大小。具体地，对于两字符串，若前 $i - 1$ 位相同，那么我们要么通过第 $i$ 位确定大小，要么第 $i$ 位相同去比较后面。但我们有多个字符串，容易想到，用 `vector` 存前 $i - 1$ 位相同的 $s[j][i]$。然后根据先后顺序去大致确定粗略的大小。

```cpp
	for (int i = 0; i < len; i++) {
		string now = "";
		if (v.size()) v.clear();
		for (int j = 1; j <= n; j++) {
			if (s[j].size() < i + 1) continue;//若这一个字符串的大小小于当前枚举的位数，则跳过。
			v2[s[j][i] - 'a'] = 1;//记录在输入中出现过的字母。
			string sub = "";
			for (int k = 0; k < i; k++) sub = sub + s[j][k];
			if (sub != now) {//若前 i - 1 位不同，就进行处理。
				now = sub;
				for (int k = 0; k < (int)v.size() - 1; k++) //注意，一定是 (int)v.size() - 1，而不是 v.size() - 1，具体为什么可自行探究。
					if (v[k] != v[k + 1]) b[v[k] - 'a'][v[k + 1] - 'a'] = 1;//确定大致的大小关系。当然，也有其他写法
				v.clear();
			}
			v.push_back(s[j][i]);//存下当前位，与后面的字母比较
		}
		for (int k = 0; k < (int)v.size() - 1; k++) //最后可能有余下的，也要处理。
			if (v[k] != v[k + 1]) b[v[k] - 'a'][v[k + 1] - 'a'] = 1;
	}
```

然后若合法，我们这样可以将字典序大的连字典序小连成一个有向无环图，如样例一。

![图片走丢了](https://cdn.luogu.com.cn/upload/image_hosting/yptw2sdw.png)

若不合法，就如样例二，会有个环。

![图片走丢了](https://cdn.luogu.com.cn/upload/image_hosting/55o9hioj.png)

而如果说有多种情况，图是不连通的。

那么，我们就有两种方法去做。

### 利用 DFS

很容易，若图跑着跑着又回到了起点，那么一定又环，当然，我们**不走重复的路**，而且我们不用一次走完。然后，我们在走的时候，又可以将途经的点都给做标记，说明这个点小于起点，最终跑到出度为 $0$ 的点。

```cpp
void dfs(int now, int x) {
	v1[x] = 1;//标记点到过了。
	if (x != now) b[now][x] = 1;
	for (int i = 0; i < 26; i++) {
		if (b[i][now]) {
			if (i == x) {//到了起点，说明有环。
				cout << '!' << '\n';
				exit(0);
			}
			if (!v1[i]) dfs(i, x);
		}
	}
}
```

然后我们去找每一个字母字典序大于多少个字母，然后记录下来，最后将记录下来的数组排序。若一个字母字典序大于多少个字母的个数已经有过了，那么就一定不能确定。代码如下。

```cpp
	for (int i = 0; i < 26; i++) {
		int res = 0;
		memset(v1, 0, sizeof v1);
		dfs(i, i);
		for (int j = 0; j < 26; j++) 
			if (b[j][i]) res++;
		if (v2[i]) a[i].x = ++res;
		a[i].y = char(i + 'a');
		if (v3[res] && res != 0) {
			cout << '?' << '\n';
			return 0;
		}
		v3[res] = 1;
	}
	sort(a, a + 26, cmp);
	for (int i = 0; i < 26; i++) if (a[i].x != 0) cout << a[i].y;
```

### 利用拓扑排序

思想很简单。通过他去判环。若队列任意一刻，点的个数大于了 $1$，就有可能答案不确定，若有环，则一定有点的入度没减为零。

大佬讲的挺多，可以看一下他们的。我主要讲法一。

## 代码

### 法一

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 110;
int n, len, d[N];
string s[N];
vector<char> v;
bool b[30][30], v1[N], v2[N], v3[N];
struct node {
	int x;
	char y;
} a[N];
bool cmp(node x, node y) {return x.x < y.x; }
void dfs(int now, int x) {
	v1[x] = 1;
	if (x != now) b[now][x] = 1;
	for (int i = 0; i < 26; i++) {
		if (b[i][now]) {
			if (i == x) {
				cout << '!' << '\n';
				exit(0);
			}
			if (!v1[i]) dfs(i, x);
		}
	}
}

int main() {
    // ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> s[i];
	len = 10;
	for (int i = 0; i < len; i++) {
		string now = "";
		if (v.size()) v.clear();
		for (int j = 1; j <= n; j++) {
			if (s[j].size() < i + 1) continue;//若这一个字符串的大小小于当前枚举的位数，则跳过。
			v2[s[j][i] - 'a'] = 1;//记录在输入中出现过的字母。
			string sub = "";
			for (int k = 0; k < i; k++) sub = sub + s[j][k];
			if (sub != now) {//若前 i - 1 位不同，就进行处理。
				now = sub;
				for (int k = 0; k < (int)v.size() - 1; k++) //注意，一定是 (int)v.size() - 1，而不是 v.size() - 1，具体为什么可自行探究。
					if (v[k] != v[k + 1]) b[v[k] - 'a'][v[k + 1] - 'a'] = 1;//确定大致的大小关系。当然，也有其他写法
				v.clear();
			}
			v.push_back(s[j][i]);//存下当前位，与后面的字母比较
		}
		for (int k = 0; k < (int)v.size() - 1; k++) //最后可能有余下的，也要处理。
			if (v[k] != v[k + 1]) b[v[k] - 'a'][v[k + 1] - 'a'] = 1;
	}
	for (int i = 0; i < 26; i++) {
		int res = 0;
		memset(v1, 0, sizeof v1);
		dfs(i, i);
		for (int j = 0; j < 26; j++) 
			if (b[j][i]) res++;
		if (v2[i]) a[i].x = ++res;
		a[i].y = char(i + 'a');
		if (v3[res] && res != 0) {
			cout << '?' << '\n';
			return 0;
		}
		v3[res] = 1;
	}
	sort(a, a + 26, cmp);
	for (int i = 0; i < 26; i++) if (a[i].x != 0) cout << a[i].y;
	return 0;
}
```

### 法二

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 110;
int n, len, d[N];
string s[N];
vector<char> v;
vector<int> g[N], ans;

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> s[i];
	len = 10;
	for (int i = 0; i < len; i++) {
		string now = "";
		if (v.size()) v.clear();
		for (int j = 1; j <= n; j++) {
			if (s[j].size() < i + 1) continue;
			string sub = "";
			for (int k = 0; k < i; k++) sub = sub + s[j][k];
			if (sub != now) {
				now = sub;
				for (int k = 0; k < (int)v.size() - 1; k++) 
					if (v[k] != v[k + 1]) g[(int)v[k] - 'a'].push_back((int)v[k + 1] - (int)'a'), d[v[k + 1] - 'a']++;
                    //这代码换种写法
				v.clear();
			}
			v.push_back(s[j][i]);
		}
		for (int k = 0; k < (int)v.size() - 1; k++) 
			if (v[k] != v[k + 1]) g[v[k] - 'a'].push_back(v[k + 1] - 'a'), d[v[k + 1] - 'a']++;
	}
	queue<int> q;//拓扑
	int f = 0;
	for (int i = 0; i < 26; i++) {
		if (!d[i] && g[i].size()) q.push(i);
	}
	while (q.size()) {
		if (q.size() > 1) f = 1;
		int now = q.front();
		q.pop();
		ans.push_back(now);
		for (int to : g[now]) {
			d[to]--;
			if (!d[to]) q.push(to);
		}
	}
//	cout << d[9];
	for (int i = 0; i < 26; i++) if (d[i]) f = 2;
//	cout << f;
	if (!f) for (int i : ans) cout << char(i + 'a');
	if (f == 2) cout << '!';
	if (f == 1) cout << '?';
	return 0;
}
```

## 后记

法一自己想的，法二看了题解。

另外，我想过并查集，但不会，希望有大佬打脸。

---

## 作者：Sparkle_Infinity (赞：1)

因为本题要求输出单词表的字典序，所以可以想到深搜来写。

因为输入就是按照题中的特殊字典序给出的，所以不难发现如果相邻的两个字符串有相同的前缀（前缀长度可能为 $0$)，紧接着相同的前缀后面的那个字母就可以得出大小关系，如：

```cpp
ula
uka
```
可得出字母 l 的特殊字典序先于字母 k 的特殊字典序，进而建图。

明显地，搜索需要起点，如果要得出大小关系，就需要将图不重不漏地遍历，所以我们可以想到建图的同时用一个 $in$ 数组来记录每个点（字母）的入度，入度为 $0$ 的即为搜索起点。若有多个入度为 $0$ 的点，就可能出现多种可能的特殊字典序，则按照题意输出问号即可。

此外，若在搜索过程中遇到了环，便说明此情况不可能存在，按题意输出感叹号即可。

详细写法及细节处理请见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s[105];
bool a[30][30];
bool e[30]; //e数组记录出现的字母 
bool vis[30]; 
int in[30];
stack<int> ans; //用栈记录深搜访问顺序 
void dfs(int x)
{
    bool f=1;
    for(int i=1;i<=26;i++)
    {
        if(a[x][i]==1) {f=0;break;} //寻找出度为0的点作为终点 
    }
    if(f==1)
    {
        bool flag=1;
        for(int i=1;i<=26;i++)
        {
            if(e[i]==1&&vis[i]==0) {flag=0;break;} //该字母在单词列表中出现，但没有访问到。 
        }
        string s="";
        if(flag==1)
        {
            while(ans.size()!=0)
            {
                s=(char)(ans.top()+96)+s; //记得将数字转回字母。 
                ans.pop();
            }
            cout<<s;
            exit(0);
        }
    }
    for(int i=1;i<=26;i++)
    {
        if(a[x][i]==1&&vis[i]==1) //出现了环，直接结束。 
        {
            printf("!"); 
            exit(0);
        }
        if(a[x][i]==1)
        {
            vis[i]=1;
            ans.push(i);
            dfs(i);
            vis[i]=0;
            ans.pop();
        }
    }
}
int main()
{
    scanf("%d",&n);
    memset(in,-1,sizeof(in));
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        for(int j=0;j<s[i].size();j++)
        {
            in[s[i][j]-'a'+1]=0; //将字母转换成数字作为数组下标，下同。 
            e[s[i][j]-'a'+1]=1; 
        }
    }
    for(int i=2;i<=n;i++)
    {
        for(int j=0;j<min(s[i-1].size(),s[i].size());j++)
        {
            if(s[i-1][j]!=s[i][j])
            {
                a[s[i-1][j]-'a'+1][s[i][j]-'a'+1]=1;
                in[s[i][j]-'a'+1]++;
                if(a[s[i][j]-'a'+1][s[i-1][j]-'a'+1]==1) //重边提前判断 
                {
                    printf("!");
                    return 0;
                }
                break;
            }
        }
    }
    int root=0;
    for(int i=1;i<=26;i++)
    {
        if(in[i]==0&&root!=0) //找到了两个入度为0的点。 
        {
            printf("?");
            return 0;
        }
        else if(in[i]==0)
        {
            root=i;
        }
    }
    vis[root]=1;
    ans.push(root);
    dfs(root);
    printf("?"); //如果搜索结束还没有找到正确的字典序，说明有多解。 
    return 0;
}
```


---

## 作者：lzx1999 (赞：1)

同样是一份字典树的写法,不过对于内部处理还是比较暴力的

对于字符串根据字典序依次加入字典树的时候,如果走到了那个结点看看有多少已经存在的兄弟结点,那么这些的字母的字典序必然较小,因此我可以让字典序小的结点向字典序打的结点连一条边,
```cpp
#include <bits/stdc++.h>
using namespace std;
int tot;
int trie[10005][27], r[30]; // 字典树数组,计算建图后每个字母的入读

bool e[30][30], c[30]; // e数组存图, c数组表示这个字母是否出现
void insert(string s)
{
    int len = Len(s), p = 0;
    for(int i = 0; i < len ; i ++)
    {
        c[s[i] - 'a'] = true; // 后面s[i] - 'a'这种就用idx(s[i])表示了
        for(int j = 0 ; j < 26 ; j ++) if(trie[p][j]) e[j][idx(s[i])] = true; // 看看加入这个字母前是不是有字典序更低的
        if(!trie[p][idx(s[i])]) trie[p][idx(s[i])] = ++ tot;
        p = trie[p][idx(s[i])]; // 字典树模板
    }
}

int32_t main()
{
    int n; cin >> n;
    for(int i = 1 ; i <= n ; i ++)
    {
        string s; cin >> s;
        insert(s);
    }
    for(int i = 0 ; i < 26 ; i ++) e[i][i] = false; // 之间删除自环的存在
    for(int i = 0 ; i < 26 ; i ++)
        for(int j = 0 ; j < 26 ; j ++)
            if(e[i][j]) r[j] ++; // 如果有字典序小的指向字典序大的边时,字典序较大的字母入度+1
    queue <int> q, ans; // q 用来拓扑排序, ans记录答案
    for(int i = 0 ; i < 26 ; i ++) if(c[i] && !r[i]) q.push(i); // 查看有多少个入度为零的,并且存在过的字母
    int flag = 0; // flag=0 表示有唯一解 =1 表示存在多组解 =2表示无解
    if(Len(q) > 1) flag = 1; //如果存在某一个时刻入度为零,那么这些字典序的排列无法确定清楚
    while(!q.empty())
    {
        int Q = q.front(); q.pop();
        ans.push(Q); // 有唯一解的情况下, q里面一定只会有一个,并且按照在q中的先后顺序是真实的字典序排列
        for(int i = 0 ; i < 26 ; i ++)
        {
            if(e[Q][i]) r[i] --;
            if(e[Q][i] && !r[i]) q.push(i);
        }
        if(Len(q) > 1) flag = 1; // 同上
    }
    for(int i = 0 ; i < 26 ; i ++) if(r[i]) flag = 2; // 如果最后发现还有点入度不为零,那么一定存在环
    if(flag == 0) while(!ans.empty()) {cout << char(ans.front() + 'a'); ans.pop();}
    if(flag == 1) cout << "?";
    if(flag == 2) cout << "!";
    cout << endl;
    return 0;
}

```


---

## 作者：junee (赞：0)

# P6491 [COCI2010-2011#6] ABECEDA 题解

## 前置知识

字典树，拓扑排序。

## 题目分析

首先很容易看出这个题是拓扑排序的题。

考虑把字符串扔在字典树上做，我们按照顺序插入字符串，那么已经存在在字典树中的字母并且与当前节点是兄弟关系的节点在新字典序中一定大于他，连一条边。

考虑什么时侯无解，要么最后如果图中出现环，或者存在一个字符串是前面字符串的子串。

然后跑一个拓扑，由于你要确定有唯一序，则拓扑中间队列大小不应大于 1。

时间复杂度为 $O(\sum |s|)$，$\sum |s|$ 为字符串总长。

## Code

```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<random>
#include<chrono>
#include<queue> 
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
typedef long long LL;
const int N=1000;
int n;
string s;
int mp[N][N],din[N],dout[N],st[N];
int ans[N],cnt;
struct Trie{
	int idx=1;
	queue<int>q;
	struct node{
		int s[30];
	}tr[N*20];
	bool insert(string a){
		int p=1;
		for(int i=0;i<a.length();i++){
			int x=a[i]-'a'+1;
			st[x]=1;
			for(int j=1;j<=26;j++){
				if(j==x||!tr[p].s[j]||mp[j][x])continue;
				mp[j][x]=1;
				din[x]++;
			}
			if(!tr[p].s[x])tr[p].s[x]=++idx;
			p=tr[p].s[x];
		}
		for(int j=1;j<=26;j++){
			if(tr[p].s[j])return 1;
		}
		return 0;
	}
	int check(){
		int f=1;
		for(int i=1;i<=26;i++){
			if(!din[i]&&st[i])q.push(i);
		}
		if(q.size()>1)f=0;
		while(q.size()){
			auto ver=q.front();q.pop();
			ans[++cnt]=ver;
			for(int j=1;j<=26;j++){
				if(!mp[ver][j]||j==ver)continue;
				din[j]--;
				if(!din[j])q.push(j);
			}
			if(q.size()>1)f=0;
		}
		for(int i=1;i<=26;i++)if(din[i])return -1;
		return f;
	}
}trie;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	int f=1;
	for(int i=1;i<=n;i++){
		cin>>s;
		if(trie.insert(s))f=-1;
	}
	if(f==-1){
		cout<<'!';
		return 0;
	}
	f=trie.check();
	if(f==1)for(int i=1;i<=cnt;i++)cout<<char(ans[i]+97-1);
	else if(f==-1)cout<<"!";
	else cout<<"?";
	return 0;
}

```

---

## 作者：djh0314 (赞：0)

[**传送门**](https://www.luogu.com.cn/problem/P6491)。

## 分析

两个字符大小关系不变，并且具有传递性，我们可以联想到拓扑排序来解决。

因此，我们就通过字符串的大小关系，推断出一些字符的大小关系，然后拓扑排序即可。
~~~cpp
#include <bits/stdc++.h>
#include <vector>
#include <string>
#include <queue>
//#define int long long
using namespace std;
const int N = 1e5+5;
int n, m,top;
int d[N];
char st[N];
string s[N];
vector<int > lj[N];
bool vis[N];
inline void end1() {
	cout<<"?";
	exit(0);
}

inline void endd2() {
	cout<<"!";
	exit(0);
}
inline void fc(string s,string t) {
	int len=min(s.size(),t.size());
	for(int i=0; i<len; ++i) {
		if(s[i]==t[i]) continue;
		d[t[i]]++;
		lj[s[i]].push_back(t[i]);
		return ;
	}
	if(s.size()>t.size()) endd2();
	return ;
}


signed main() {
	cin>>n;
	for(int i=1; i<=n; ++i) {
		cin>>s[i];
		for(int j=0; j<s[i].size(); ++j) vis[s[i][j]]=1;
	}
	for(int i=1; i<n; ++i) for(int j=i+1; j<=n; ++j) fc(s[i],s[j]);
	queue<int > q;
	for(int i='a'; i<='z'; ++i) if(vis[i]&&!d[i]) q.push(i);
//	for(int i='a';i<='z';++i) cout<<d[i]<<" ";cout<<endl;
	while(!q.empty()) {
		int now=q.front();
		q.pop();
		if(!q.empty()) end1();
		st[++top]=now;
		for(auto to:lj[now]) if(!(--d[to])) q.push(to);
	}
	for(int i='a'; i<='z'; ++i) if(vis[i]&&d[i]) endd2();
	for(int i=1; i<=top; ++i) cout<<st[i];
	return 0;
}
~~~


---

## 作者：JohnJoeZhu (赞：0)

官方题解翻译+代码在本人思路后

[题面传送门](https://www.luogu.com.cn/problem/P6491)

### 分析题目
题意就是给定字典求字典序规律，而且数据还非常小

~~不会字典序请左转~~

从小数据就说明题目有很多~~乱搞玄学~~的东西

所以，从字典序，我们能够得到什么呢

是不是可以考虑把字母转化数值呢？

如果有

```
3
abc
acb
cab
```

说明

```
a<c b<c
```

既然是不等式，那就会有传递性（$a<b,b<c$，所以$a<c$）

自此，我们就找到了题目的第一个突破口

#### 不可能：！
有什么情况是不可能存在的呢

比如

```
4
jaja
baba
baja
beba
```

有

```
j<b b<j a<e
```

由传递性得，$j<j$

根据常识，这当然是不可能的

所以有$！$

注意，有另一个样例没有提示但是也是不可能的

比如

```
3
abbb
abb
ab
```

乍一看，好像可以

但是根据字典序的要求，你就会发现，这是不可能的

所以如果后者是前者的前缀且后者长度比前者小，那么就是$!$的

#### 多种情况：？
再来看样例

比如

```
3
marko
darko
zarko
```

如果一个字符出现了但是没有人给限制，那就是$?$

在比如

```
3
ab
ba
bc
```

可以得到

```
a<b a<c
```

但是b和c的关系是不确定的

也就是出现了$a<b,a<c,…,a<x$的情况，都是$?$

### 求正解

既然有不等式，我们可以想到什么？

因为有官方解法，所以我提供不同的思路

由上面的推导，发现不等式的关系与图十分密切

这里还有一道类似的题目：[P1347](https://www.luogu.com.cn/problem/P1347)

所以我们可以把$a<b$，建边$add(a,b)$

我们又可以探究样例，如果一个方案是可行的，那么建出来的图是DAG

既然是DAG，那就可以想到拓扑排序

那么上面的特殊情况就可以简化为以下几个关系：
- 所以如果后者是前者的前缀且后者长度比前者小，那么就是$!$的（这个是预处理就可以出来的）
- 如果图中有环，那么就是$!$的
- 如果图中没有入读为0的点，那么就是$?$的
- 如果图中出现一个点可以使多个点入队，那么就是$?$的

想必各位大佬还想要知道建图预处理

其实就是相邻两个字符串，寻找第一个不同的位置，再进行上面第一个特判$!$，然后建图即可

那么题目就这样子迎刃而解了

### 代码

```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
string a[110];
bool vis[26];
struct pp{
	int v,nex;
}edge[110*110];
int head[26],top=0,in[26];
void add(int u,int v)
{
	in[v]++;
	edge[++top].v=v;
	edge[top].nex=head[u];
	head[u]=top;
}//常规建图
int lans=0,Ans[26],cnt=0,dep[26],viss[26];
queue<int>q; 
void Topu()
{
	bool flag=0,unpd=0;//unpd指是否唯一解
	for(int i=0;i<26;i++) 
	{
		if(!in[i]&&vis[i]) 
		{
			q.push(i);
			if(!flag) flag=1;
			else unpd=1;
			Ans[++ans]=i;		
		}
	}
	if(q.empty()) {printf("!");return;}//特判3
	while(!q.empty())
	{
		int u=q.front();
		flag=0;
		q.pop();
		for(int i=head[u];i;i=edge[i].nex)
		{
			in[edge[i].v]--;
			if(!in[edge[i].v])
			{
				q.push(edge[i].v);
				if(!flag) flag=1;
				else unpd=1;//特判2
				Ans[++ans]=edge[i].v;
			 } 
		}
	}
	if(ans!=cnt) {printf("!");return;}//不是所有人都可以进队，特判4
	if(unpd) {printf("?");return;}//特判2
	for(int i=1;i<=ans;i++) printf("%c",Ans[i]+'a');//输出答案
}
int main()
{
	scanf("%d",&n);
	for(int i=1,j;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
		for(int j=0;j<a[i].length();j++) cnt+=!vis[a[i][j]-'a'],vis[a[i][j]-'a']=1;//cnt字典中字母个数 
	for(int i=1;i<n;i++)
	{
		int l=0,r=0;
		while(l<a[i].length()&&r<a[i+1].length()&&a[i][l]==a[i+1][r]) l++,r++;//建图方式上面已经说明了
		if(l<a[i].length()&&r<a[i+1].length()) add(a[i][l]-'a',a[i+1][r]-'a');
		if(l<a[i].length()&&r>=a[i+1].length())
		{
			printf("!");//特判1
			return 0;
		}
	}
	Topu();//拓扑排序 
	return 0;
 } 
```
### 官方题解翻译
考虑每对连续的单词，使任意一个单词都不是另一个单词的前缀。

让k作为两个单词第一个不同的位置。

设a为输入排名靠后的第k个字母，b为另一个单词的第k个字母。因此a字母的排名排在b之后。

让我们寻找一个给定字母的大小关系。

如果a按字母顺序在b之后，我们会说a大于b。注意这个关系是可传递的（如果a>b和b>c，那么a>c）。

利用Floyd-Warshall算法可以方便地计算出它的传递关系。

如果传递关系表示某个字母a>a，则顺序不存在$(!)$。

其次，如果有两个字母a和b，使得a>b或b>a都成立，则排序不是唯一的$(?)$。

否则，顺序确实存在并且是唯一的。

让k表示对于b，使得a<b的a的数量。

按照每个字母的k从小到大排序，输出即可

### 官方代码+无注释
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 100;
const int MAXLEN = 10;

int N, M;
char word[MAXN][MAXLEN + 1];
bool seen[26];
bool greater[26][26];
vector< pair< int, char > > ret;

int main(void)
{
  scanf("%d", &N);
  for (int i = 0; i < N; ++i)
    scanf("%s", word[i]);

  for (int i = 0; i < N; ++i)
    for (char *p = word[i]; *p; ++p) {
      M += !seen[*p - 'a'];
      seen[*p - 'a'] = true;
    }

  for (int i = 0; i < N - 1; ++i) {
    char *a = word[i];
    char *b = word[i + 1];
    while (*a && *b && *a == *b) {
      ++a;
      ++b;
    }
    if (*a && *b) 
      greater[*b - 'a'][*a - 'a'] = true;

    if (*a && !*b) {
      puts("!");
      return 0;
    }
  }

  for (int k = 0; k < 26; ++k)
    for (int i = 0; i < 26; ++i)
      for (int j = 0; j < 26; ++j)
        greater[i][j] |= greater[i][k] && greater[k][j];

  for (int i = 0; i < 26; ++i)
    if (greater[i][i]) {
      puts("!");
      return 0;
    }

  for (int i = 0; i < 26; ++i) {
    if (!seen[i]) continue;
    int out = 0;
    int in = 0;
    for (int j = 0; j < 26; ++j) {
      out += greater[i][j];
      in += greater[j][i];
    }
    if (out + in != M - 1) {
      puts("?");
      return 0;
    }
    ret.push_back(make_pair(out, 'a' + i));
  }

  sort(ret.begin(), ret.end());

  for (int i = 0; i < ret.size(); ++i)
    printf("%c", ret[i].second);
  printf("\n");

  return 0;
}
```
### 本人翻译代码+注释（一格缩进真是难受）
```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,dis[26][26],cnt=0,len=0;
string a[110];
bool vis[26];
struct pp{
	int sum,id;
}b[26];
bool cmp(pp x,pp y){return x.sum<y.sum;}
int main()
{
	scanf("%d",&n);
	for(int i=1,j;i<=n;i++) cin>>a[i],j=a[i].length(),len=max(len,j);
	for(int i=1;i<=n;i++)
		for(int j=0;j<a[i].length();j++) cnt+=!vis[a[i][j]-'a'],vis[a[i][j]-'a']=1;
	for(int i=1;i<n;i++)
	{
		int l=0,r=0;
		while(l<a[i].length()&&r<a[i+1].length()&&a[i][l]==a[i+1][r]) l++,r++;
		if(l<a[i].length()&&r<a[i+1].length()) dis[a[i+1][r]-'a'][a[i][l]-'a']=1;//dis表示大于关系 
		if(l<a[i].length()&&r>=a[i+1].length())
		{
			printf("!");
			return 0;
		}
	}
	for(int k=0;k<26;k++)
		for(int i=0;i<26;i++)
			for(int j=0;j<26;j++)
				dis[i][j]|=dis[i][k]&&dis[k][j];//弗洛伊德最短路
	for(int i=0;i<26;i++)
		if(dis[i][i]&&vis[i]) 
		{
			printf("!");
			return 0;
		}
	int ans=0;
	for(int i=0;i<26;i++)
	{
		if (!vis[i]) continue;
 	    int out=0,in=0;//out是比i小的，in是比i大的
   		for(int j=0;j<26;j++) 
		{
    	    out+=dis[i][j];
    	    in+=dis[j][i];
    	}
    	if(out+in!=cnt-1) 
		{
    		printf("?");
    	    return 0;
    	}
    	b[++ans].sum=out,b[ans].id=i;
	}
	sort(b+1,b+1+ans,cmp);//排序 
	for(int i=1;i<=ans;i++) printf("%c",b[i].id+'a');
	return 0;
 } 
```

---

## 作者：y0y68 (赞：0)

## 一、大致思路

根据输入得到若干个基础的形如 $a>b$ （$a,b$ 都为小写字母，这里表示字母 $a$ 的优先级大于字母 $b$ ，以后为了方便，都会这样表示）的不等式，然后通过 $\texttt{floyd}$ 求出所有能根据输入得到的上述形式的不等式，最后判一下无解或有多种解的情况，排列好优先级的顺序并输出就可以了。

--------

## 二、具体实现

$1$. 提出能从输入中直接得到的基础不等式：

令 $a$ 为第 $i$ 个字符串的第 $k$ 个字母， $b$ 为第 $j$ 个字符串的第 $k$ 个字母。显然，如果第 $i$ 个字符串排在第 $j$ 个前面，并且 $a \ne b$ ，那么 $a>b$ 。于是采用分治的思想，定义一个函数 $work(l,r,k)$ ，表示目前搜到了第 $l$ 到 $r$ 个字符串的第 $k$ 个字母，再定义一个 $\texttt{bool}$ 类型的二维数组 $f$ ，其中 $f[i][j]$ 表示第 $i$ 个小写字母是否大于第 $j$ 个，是为 $\texttt{true}$ ，否为 $\texttt{false}$ 。执行 $work(l,r,k)$ 时从 $l$ 到 $r$ 遍历，遇到就第 $i$ 个字符串排在第 $j$ 个前面，并且 $a \ne b$ 的情况就 `f[a-'a'+1][b-'a'+1]=true` （要把 $a$ 和 $b$ 转成 $\texttt{int}$ 类型）

$2$ . $\texttt{floyd}$

按照板子打就可以了，转移方程为

```
dp[i][j]|=dp[i][k]&dp[j][k];
```

这句话就相当于

```
if(dp[i][k]&&dp[k][j])dp[i][j]=true;
```

$3$. 输出

情况一：无解

如果发现对于某个数 $i$ ，第 $i$ 个字母在输入的字符串中出现过，且 $f[i][i]$ 为 $\texttt{false}$，也就是这个字母大于它本身，显然矛盾，输出 `!` 。

情况二：存在多组解

如果发现对于两个数 $i,j$ ，$i \ne j$ ，第 $i$ 和第 $j$ 个字母在输入的字符串中都出现过，且 $f[i][j]$ 和 $f[j][i]$ 都为 $\texttt{false}$ ，即这两个字母大小待定，显然有多组解，输出 `?` 。

情况三：存在唯一解

这时遍历每个字母，记录有多少字母比它们小，然后按降序排序，从前往后枚举排序后的字母，如果它在输入中出现过就输出它。

## 三、代码

```

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
char a[105][15];
bool p[30],f[30][30];
//p[i]表示第i个小写字母是否在输入中出现
struct Node{
	int w,id;
	//w表示有几个字母比它小
	//id表示它是第几个字母，记录这个因为要进行排序
}x[30];
inline int turn(char c){
	return c-'a'+1;
	//这是将小写字母转化成它对应的数字
}
inline void work(int l,int r,int k){
	if(k>10||l==r)return;
	//数据保证字符串长度不大于10，所以k>10即为越界
	//若l==r，只有一个字符串，在搜下去也就没意义了
	int lst=l,pos=-1;
	//lst表示目前区间起点，pos表示最后一段区间前第一个不被舍弃（一个字符串被舍弃即为k大于这个字符串的长度）的字符串的第k个字符
	for(int i=l;i<r;i++){
		if(k>strlen(a[i]+1)){//需要舍弃
			lst=i+1;continue;//注意更新lst
		}
		if(a[i][k]!=a[i+1][k]){//不相同说明能推出一个不等式
			f[turn(a[i][k])][turn(a[i+1][k])]=1;
			work(lst,i,k+1);
			lst=i+1;pos=i;//lst和pos都要更新
		}
	}
	if(pos>-1)f[turn(a[pos][k])][turn(a[r][k])]=1;
	//如果分出的区间不止一段，仍能推出不等式（好好想想）
	work(lst,r,k+1);//分最后一段区间
}
inline bool cmp(Node d,Node e){
	if(d.w==e.w)return d.id<e.id;
	return d.w>e.w;
}//根据先w后id的规则排序
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=10;j++)
			a[i][j]='{';//将a中的每个字符都赋为ASCII码比'z'大的字符，防止递归是出错
	for(int i=1;i<=n;i++){
		scanf("%s",a[i]+1);
		for(int j=1;j<=strlen(a[i]+1);j++)
			p[turn(a[i][j])]=1;//记录出现过的字符
	}
	work(1,n,1);
	for(int k=1;k<=26;k++)
		for(int i=1;i<=26;i++)
			for(int j=1;j<=26;j++)
				f[i][j]|=f[i][k]&f[k][j];//Floyd
	for(int i=1;i<=26;i++)
		if(f[i][i]){puts("!");return 0;}//无解情况
	for(int i=1;i<=26;i++)
		for(int j=1;j<=26;j++)
			if(i!=j&&p[i]&&p[j]&&!f[j][i]&&!f[i][j]){puts("?");return 0;}//多组解情况
	for(int i=1;i<=26;i++){
		x[i].id=i;
		if(p[i])//第i个小写字母不能出现过
			for(int j=1;j<=26;j++)
				if(p[j]&&f[i][j])x[i].w++;//统计
	}
	sort(x+1,x+27,cmp);
	for(int i=1;i<=26;i++)
		if(p[x[i].id])putchar(x[i].id+'a'-1);//要转成char类型
	puts("");return 0;
}
```

---


# [COCI 2010/2011 #6] STEP

## 题目描述

给定一个长度为 $n$ 的字符序列 $a$，初始时序列中全部都是字符 `L`。

有 $q$ 次修改，每次给定一个 $x$，若 $a_x$ 为 `L`，则将 $a_x$ 修改成 `R`，否则将 $a_x$ 修改成 `L`。

对于一个只含字符 `L`，`R` 的字符串 $s$，若其中不存在连续的 `L` 和 `R`，则称 $s$ 满足要求。

每次修改后，请输出当前序列 $a$ 中最长的满足要求的连续子串的长度。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, q \leq 2 \times 10^5$，$1 \leq x \leq n$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #6](https://hsin.hr/coci/archive/2010_2011/contest6_tasks.pdf) *T5 STEP***，翻译来自 @[一扶苏一](https://www.luogu.com.cn/user/65363)。

## 样例 #1

### 输入

```
6 2
2
4
```

### 输出

```
3
5```

## 样例 #2

### 输入

```
6 5
4
1
1
2
6
```

### 输出

```
3
3
3
5
6```

# 题解

## 作者：暗ざ之殇 (赞：88)

## 题解
首先题目中的 $L$ 和 $R$ 我们可以分别用 $0$ 和 $1$来代替； 

一个很自然的想法是**用线段树维护答案区间的左右端点**；

思路简单暴力，但是合并信息的时候需要考虑的情况较多，且复杂度较高，会$TLE$；
### 巧妙的思路
先介绍一下代码里的数组：

$len [ i ]$：线段树中第 $i$ 个节点所维护的区间的长度；

$L [ i ]$：线段树中第 $i$ 个节点所维护的区间的左端点；

$R [ i ]$：线段树中第 $i$ 个节点所维护的区间的右端点；

$S [ i ]$：线段树中第 $i$ 个节点所维护的区间的最左端开始最长的符合条件的区间长度（前缀）；

$H [ i ]$：线段树中第 $i$ 个节点所维护的区间的最右端开始最长的符合条件的区间长度（后缀）；

$ans [ i ]$：线段树中第 $i$ 个节点所维护的区间的最长符合条件的区间长度；

这样搞有什么好处呢？

可以 $O ( 1 )$ 完成信息的维护操作；

重点来考虑一下 $pushup$ 的操作怎么搞，我们可以将其分为两种情况：

**①. 当前区间的左儿子的右端点与右儿子的左端点相同：**
![](https://cdn.luogu.com.cn/upload/image_hosting/w365j0ev.png)

这种情况下大区间的最长符合条件的区间只可能是两个子区间中的最大值：
![](https://cdn.luogu.com.cn/upload/image_hosting/q5cxqqhm.png)

**②. 当前区间的左儿子的右端点与右儿子的左端点不同：**
![](https://cdn.luogu.com.cn/upload/image_hosting/o7gjp8d1.png)

这种情况相比于上一种情况来说要多考虑一种情况：

**就是左区间靠右的那一部分加上右区间靠左的那一部分所形成的新的符合条件的区间可能比左右区间中的都大 。**
![](https://cdn.luogu.com.cn/upload/image_hosting/9ekusn1h.png)

虽然这种情况看起来比较毒瘤，但是利用我们的 $S$ 数组和 $H$ 数组就轻松解决问题了；

**所拼成的区间的长度就是 $H [ node << 1 ($左儿子编号$) ] + S [ node<<1 | 1 ($右儿子编号$) ]$；**
```
if(R[node<<1]^L[node<<1|1])             //如果左区间的右端点和右区间的左端点不同 
{
    ans[node]=H[node<<1]+S[node<<1|1];  //考虑两端合并后的符合条件的区间长度 
    ans[node]=max(ans[node],ans[node<<1]);  //与左区间的进行比较 
    ans[node]=max(ans[node],ans[node<<1|1]);//与右区间的进行比较 
}
else ans[node]=max(ans[node<<1],ans[node<<1|1]);  //否则只用考虑左右区间中最长的区间
```
接下来考虑怎么维护 $S$ 和 $H$ 数组，也是分两种情况来考虑： 

**①. $S$ 和 $H$ 数组所维护的区间长度小于当前区间长度：**
![](https://cdn.luogu.com.cn/upload/image_hosting/v70hsqzv.png)

像上面左区间的 $S$ 并没有覆盖整个左区间，所以更新完信息后大区间的 $S$ 就是左区间的 $S$ 即可； 

维护右区间的 $H$ 同理； 

**②. $S$ 和 $H$ 数组所维护的区间长度等于当前区间长度：**
![](https://cdn.luogu.com.cn/upload/image_hosting/4e89jfvt.png)

此时有$ S [ node<<1 ] = len [ node<< 1 ]$ ；

为什么要把这种情况单独拿出来考虑呢？因为它毒瘤$qwq$ 。

如果此时有 $R [ node<<1 ]$  $^$   $L [ node<<1 | 1 ] = 1$（左区间的右端点与右区间的左端点不同），那么两段可以合成一个新段来作为大区间的 $S$：

![](https://cdn.luogu.com.cn/upload/image_hosting/niawax3o.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/c9zduxli.png)

维护右区间的 $H$ 同理；
```
if(S[node<<1]==len[node<<1]&&R[node<<1]^L[node<<1|1]) S[node]=S[node<<1]+S[node<<1|1];  //左区间的S包含整个区间并且左区间的右端点与右区间的左端点不同,则两个区间的S合并成大区间的S 
else S[node]=S[node<<1];                //否则就继承左区间的S             
if(H[node<<1|1]==len[node<<1|1]&&R[node<<1]^L[node<<1|1]) H[node]=H[node<<1|1]+H[node<<1]; //右区间的H包含整个区间并且左区间的右端点与右区间的左端点不同,则两个区间的H合并成大区间的H 
else H[node]=H[node<<1|1];              //否则就继承右区间的H 
```
pushup 操作讲完了，这个题就讲完了~

#### $Code:$
```
#include<iostream>
#include<cstdio>
using namespace std;
const int N=8e5+5;
int n,m;
int S[N],H[N],L[N],R[N],len[N],ans[N];
void work(int node,int k)                   //将node节点的值赋值为k,并更新一下该点信息 
{
	ans[node]=S[node]=H[node]=1;
	L[node]=R[node]=k;
}
void pushup(int node)
{
	if(R[node<<1]^L[node<<1|1])             //如果左区间的右端点和右区间的左端点不同 
	{
		ans[node]=H[node<<1]+S[node<<1|1];  //考虑两端合并后的符合条件的区间长度 
		ans[node]=max(ans[node],ans[node<<1]);  //与左区间的进行比较 
		ans[node]=max(ans[node],ans[node<<1|1]);//与右区间的进行比较 
	}
	else ans[node]=max(ans[node<<1],ans[node<<1|1]);  //否则只用考虑左右区间中最长的区间 
	L[node]=L[node<<1];R[node]=R[node<<1|1];//L和R数组的维护显而易见   
	if(S[node<<1]==len[node<<1]&&R[node<<1]^L[node<<1|1]) S[node]=S[node<<1]+S[node<<1|1];  //左区间的S包含整个区间并且左区间的右端点与右区间的左端点不同,则两个区间的S合并成大区间的S 
	else S[node]=S[node<<1];                //否则就继承左区间的S             
	if(H[node<<1|1]==len[node<<1|1]&&R[node<<1]^L[node<<1|1]) H[node]=H[node<<1|1]+H[node<<1]; //右区间的H包含整个区间并且左区间的右端点与右区间的左端点不同,则两个区间的H合并成大区间的H 
	else H[node]=H[node<<1|1];              //否则就继承右区间的H 
}
void build(int node,int l,int r)            
{
	len[node]=r-l+1;                        //区间长度 
	if(l==r)                                //递归到了叶子节点 
	{
		work(node,0);                       //将该点赋值0,并更新一下该点信息 
		return ;
	}
	int mid=(l+r)/2;
	build(node<<1,l,mid);
	build(node<<1|1,mid+1,r);
	pushup(node);
}
void change(int node,int l,int r,int x)
{
	if(l==r)                                //递归到了叶子节点 
	{
		work(node,!L[node]);                //将该节点赋值为!L[node],从而达到0变成1,1变成0的效果 
		return ;
	}
	int mid=(l+r)/2;
	if(x<=mid) change(node<<1,l,mid,x);
	else change(node<<1|1,mid+1,r,x);
	pushup(node);
}
int main()
{
	scanf("%d %d",&n,&m);
	build(1,1,n);                           //建树     
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		change(1,1,n,x);                    //单点修改 
		printf("%d\n",ans[1]);              //每次要输出最长的符合条件的区间 
	}
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：60)

# 一些闲扯
这道题说实话可以当作模板。  
我习惯称这类题为~~线段树左右前缀区间维护模板~~  
这种题的思想就是维护一个区间的前缀max和后缀max，然后转移的时候就判mid和mid + 1的条件，假如O了，那么就继续转移。其实这个思想挺有意思的，再加上这类题的思想又和最大子段和的分治做法很相似，所以……就没有所以啦！至少得熟练这种做法吧，毕竟用了这种思想的线段树题还是很多的（洛谷也还有只不过我忘了在哪里……）  
# 正题  
首先转人言，题目是要让我们搞一个维护最大不连续01的连续子串。  
我们要维护的东西我罗列一下
```cpp
一、一个区间的最大01连续子串
二、一个区间的前缀最大01连续子串
三、一个区间的后缀最大01连续子串
四、一个区间的左端点、右端点、总长
```  
对于四，我们只要在update的时候给push_up里面加个l,r参数就好了没必要单独开个数组啥的去维护。（不过你这样做也无妨，反正线段树的大部分题也不会刻意卡你空间）  
对于二、三我们要分类讨论：
```cpp  
一、左右区间不能合并：  
那么我们该区间的前缀最大01连续子串不就是左区间的前缀最大01连续子串？该区间的后缀最大01连续子串不就是右区间的后缀最大01连续子串？因为你没有新的可以合并的方法产生对吧，相当于左边还是左边右边还是右边，我即使合并了也互不影响；  
二、左右区间可以合并：
这时候就需要细心一点，假如左区间的最大01子串就是他本身的长度，换句话说就是这个区间很给力直接就把他自己全部拿出来贡献给答案了，这时由于合并了我们就要考虑右区间。现在右区间不是也可以合并了吗？那么我们直接加上有区间的前缀最大01连续子串就行了。后缀也是同理。
```
对于一也是类似的分类讨论：
```cpp
一、左右区间不能合并：  
既然不能合并的话那还管啥？我们直接把左右区间里面最大01连续子串长的那个给赋值过去不就完了？你又不能产生新的方法我鸟你有何用？  
二、左右区间可以合并：  
这时候我们思考：两个区间合并到底改变的是什么？其实就是他们的首尾相连，我们考虑一下左区间的最大后缀和右区间的最大前缀，这两个既然能合并那还等啥？赶紧判断一波max。
```
~~讲的貌似有点口水话不过我个人感觉挺详细的~~  
# 附上push_up代码：
```cpp
void push_up(int p,int l,int r)
{
	int mid = (l + r) >> 1;//求左儿子的右端点，推之则mid + 1是右儿子的左端点对吧 
	int L = (mid - l + 1),R = r - mid;//左孩子的长、右孩子的长 
	lsum[p] = lsum[ls(p)],rsum[p] = rsum[rs(p)],sum[p] = max(sum[ls(p)],sum[rs(p)]);//我们先全部都从左右孩子身上扒他们的最值，保证我们操作的正确性 
	if(a[mid] != a[mid + 1])//考虑连接情况 
	{
		sum[p] = max(sum[p],rsum[ls(p)] + lsum[rs(p)]);//维护最大值，这个应该都看的懂吧 
		if(sum[ls(p)] == L) lsum[p] = L + lsum[rs(p)];//如果等于了左孩子的长度，则说明我们大区间的max前缀01需要更大的空间，那就从右儿子那里扒他的max前缀01 
		if(sum[rs(p)] == R) rsum[p] = R + rsum[ls(p)];//如果等于了右孩子的长度	则说明我们大区间的max后缀01需要更大的空间，那就从左儿子那里扒他的max后缀01 
	} 
}
```
其他的函数其实就很简单了，要是这都搞不懂说明你连线段树最基本的一些东西都是没搞懂……当然也不是说你撇，至少也要先搞懂原理你再来做题……吧？  
# 附上代码~~供各位拍拍?~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int Len = 3e5 + 5;
int n,m,opt,a[Len],sum[Len << 2],lsum[Len << 2],rsum[Len << 2];//分别对应一个区间的最大01连续子串，一个区间前缀最大01连续子串、一个区间后缀最大01连续子串 
int ls(int x){return x << 1;}
int rs(int x){return x << 1 | 1;}//懒得打<<1了…… 
void push_up(int p,int l,int r)
{
	int mid = (l + r) >> 1;//求左儿子的右端点，推之则mid + 1是右儿子的左端点对吧 
	int L = (mid - l + 1),R = r - mid;//左孩子的长、右孩子的长 
	lsum[p] = lsum[ls(p)],rsum[p] = rsum[rs(p)],sum[p] = max(sum[ls(p)],sum[rs(p)]);//我们先全部都从左右孩子身上扒他们的最值，保证我们操作的正确性 
	if(a[mid] != a[mid + 1])//考虑连接情况 
	{
		sum[p] = max(sum[p],rsum[ls(p)] + lsum[rs(p)]);//维护最大值，这个应该都看的懂吧 
		if(sum[ls(p)] == L) lsum[p] = L + lsum[rs(p)];//如果等于了左孩子的长度，则说明我们大区间的max前缀01需要更大的空间，那就从右儿子那里扒他的max前缀01 
		if(sum[rs(p)] == R) rsum[p] = R + rsum[ls(p)];//如果等于了右孩子的长度	则说明我们大区间的max后缀01需要更大的空间，那就从左儿子那里扒他的max后缀01 
	} 
}
void build(int p,int l,int r)
{
	sum[p] = lsum[p] = rsum[p] = 1;//赋初始值，别忘了三个都要赋值…… 
	if(l == r) return;//递归结束 
	int mid = (l + r) >> 1;
	build(ls(p),l,mid);
	build(rs(p),mid + 1,r);
	push_up(p,l,r);//基本建树操作^ 
}
void update(int p,int l,int r,int idx)
{
	if(l == r && l == idx){a[l] ^= 1;return;}//找到了需要更改的节点 
	int mid = (l + r) >> 1; 
	if(idx <= mid) update(ls(p),l,mid,idx);
	else update(rs(p),mid + 1,r,idx);//类似于折半查找操作，也就是我们二分里面的找数那操作 
	push_up(p,l,r);
} 
int query(){return sum[1];}//直接return最大区间的sum值就好了 
int main()
{
	scanf("%d %d",&n,&m);
	build(1,1,n);//别忘了建树 
	while(m --)
	{
		scanf("%d",&opt);
		update(1,1,n,opt);
		printf("%d\n",query());
	}
	return 0;
}//完结撒花！！！
```
# 完结撒花！！！

---

## 作者：一扶苏一 (赞：35)

## 【线段树】【P6492】 [COCI2010-2011#6] STEP

### Analysis

为啥还要转化一步啊……直接维护就可以……

方便起见，约定 `L` 为 $0$，`R` 为 $1$。

与维护区间最大子段和的做法类似，对于每个区间维护前缀最长 `01` 串长度 $p$，后缀最长 `01` 串长度 $s$ ，和区间内最长 `01` 串长度 $v$。pushup 时，$p$ 和 $s$ 分别从左右孩子转移。如果左孩子的右端点的值与右孩子左端点的值不同，说明中间部分可以拼起来，用拼起来的长度更新一下 $v$ 即可。

需要注意的是如果左（右）孩子本身是一个连续 $01$ 串，并且两孩子中间部分可以拼起来的话，那么向上转移的 $p$（$s$）值需要加上右（左）孩子的 $s$（$p$）值。具体可以看代码里的 pushup 部分。

### Code

```cpp
namespace Fusu {

const int maxn = 200005;

int n, q;
int a[maxn];

struct Node {
  int l, r;
  int lv, rv, vv;  //lv means (the length of) the longest prefix, rv means the longest suffix, vv means the longest substring of this range.
  Node *ls, *rs;

  inline void pushup() {
    lv = ls->lv; rv = rs->rv;
    if (a[ls->r] != a[rs->l]) {
      if (ls->lv == (ls->r - ls->l + 1)) {
        lv += rs->lv;
      }
      if (rs->rv == (rs->r - rs->l + 1)) {
        rv += ls->rv;
      }
    }
    vv = std::max({(a[ls->r] != a[rs->l]) ? ls->rv + rs->lv : 0, ls->vv, rs->vv});
  }

  void upd(const int x) {
    if (l == r) return;
    if (ls->r >= x) {
      ls->upd(x);
    } else {
      rs->upd(x);
    }
    pushup();
  }
};
Node Mem[maxn << 1], *pool = Mem;
Node *New(const int l, const int r) {
  auto u = pool++;
  u->l = l; u->r = r;
  if (l != r) {
    int m = (l + r) >> 1;
    u->ls = New(l, m);
    u->rs = New(m + 1, r);
    u->pushup();
  } else {
    u->lv = u->rv = u->vv = 1;
  }
  return u;
}

void Main() {
  qr(n); qr(q);
  auto rot = New(1, n);
  for (int x; q; --q) {
    qr(x);
    a[x] ^= 1;
    rot->upd(x);
    qw(rot->vv, '\n');
  }
}

} // namespace Fusu
```

---

## 作者：Limit (赞：22)

这颗线段树上的节点如果只记录区间中的最长的符合条件的区间长度想必是无法转移的,所以需要记录一下的量:

 1. 当前区间最左端开始的最长的符合条件的区间的长度
 2. 当前区间最右端开始的最长的符合条件的区间的长度
 3. 当前区间中最长的符合条件的区间的长度
 4. 当前区间的最左边的数
 5. 当前区间的最右边的数
 6. 当前区间的长度
 
 然后就可以合并了.
 下面是几个合并时需要注意的地方:
 
 1. 整棵树的最左端的值就是左子树的最左端的值(右边同理)
 2. 整棵树的中间的最长分符合区间为左右子树的最长区间中的大值,但如果左右区间在相连处的数字不同,那么左子树的右边可以和右子树的左边相连,所以还有和这两个数相加的数去一个max
 3. 整颗子树的如果从头到尾都符合时需要特别处理:当左右子树可以相连时整颗树的左右最大值不能直接从单一一棵子树中获得,而需要一棵完整的子树加上另一棵子树的一部分(也可能是全部)
```cpp
如:
左子树:1 0 1
右子树 0 0 1
如果没有这个特判时那么整颗树的左边最长为3
但是如果相连后1 0 1 0 0 1,左边最长为4
```

以上内容可能有点抽象,具体见代码.

```cpp
#include<bits/stdc++.h>
#define rap(i,first,last) for(int i=first;i<=last;++i)
#define Lson now*2
#define Rson now*2+1
#define Middle (left+right)/2
#define Left Lson,left,Middle
#define Right Rson,Middle+1,right
using namespace std;
const int maxN=1e5+7;
struct Tree//保存整棵树
{
	int lmax,rmax,mmax,l,r,len;//如上所示的需要保留的值
}tree[maxN*4];
int N,M;
void PushUp(int now)
{
	tree[now].lmax=tree[Lson].lmax;//先直接将子树的左右最长赋值到整颗数中
	tree[now].rmax=tree[Rson].rmax;
	tree[now].l=tree[Lson].l;//整颗树的左右值
	tree[now].r=tree[Rson].r;
	tree[now].mmax=max(tree[Lson].mmax,tree[Rson].mmax);//先从左右子树中中间的最长符合区间中取一个最大的
	if(tree[Lson].r!=tree[Rson].l)//当左右可以相连时
	{
		tree[now].mmax=max(tree[now].mmax,tree[Lson].rmax+tree[Rson].lmax);//需要再取一个大值
		if(tree[Lson].mmax==tree[Lson].len)//如上注意3
		{
			tree[now].lmax=tree[Rson].lmax+tree[Lson].len;
		}
		if(tree[Rson].mmax==tree[Rson].len)
		{
			tree[now].rmax=tree[Lson].rmax+tree[Rson].len;
		}
	}
}
void Build(int now=1,int left=1,int right=N)//建树,不多说
{
	tree[now].len=right-left+1;
	if(left==right)
	{
		tree[now].lmax=tree[now].rmax=1;
		tree[now].mmax=1;
		tree[now].l=tree[now].r=1;
		return;
	}
	Build(Left);
	Build(Right);
	PushUp(now);
}
void UpData(int change,int now=1,int left=1,int right=N)//修改,因为只有单点修改所以也用不上懒标记,直接将覆盖需要修改位置的所有区间都修改就好了
{
	if(left>change||right<change)return;
	if(left==right)//到叶节点时
	{
		tree[now].l^=1;
		tree[now].r^=1;
		return;
	}
	UpData(change,Left);
	UpData(change,Right);
	PushUp(now);//合并
}
int Query()
{
	return max(tree[1].mmax,max(tree[1].lmax,tree[1].rmax));//全局查找,直接在整颗树中找一个最长的附和条件时区间
}
int main()
{
	scanf("%d%d",&N,&M);
	Build();//建树
	int change;
	rap(i,1,M)
	{
		scanf("%d",&change);
		UpData(change);//修改
		printf("%d\n",Query());//查询
	}
	return 0;
}
```

~~直接搬P2253的题解,不要在意改了码风~~

---

## 作者：Karry5307 (赞：12)

### 题意

给定一个长度为 $n$ 的字符序列 $a$，初始全为 `L`，有 $q$ 次操作，每一次可以将 `L` 变为 `R` 或者将 `R` 变为 `L`，每一次操作后求出最长交错子序列的长度。

$\texttt{Data Range:}1\leq n,q\leq 2\times 10^5$

### 题解

老年选手大概每天就只能做做这种题混混日子了吧。

来点不一样的解法。

考虑将 `L` 记作 $1$，`R` 记作 $0$，再构造序列 $b_i=a_i\operatorname{and}\ (l_i\operatorname{and}1)$，那么 $a$ 中一段交错子序列对应着 $b$ 中一段 $0$ 或是一段 $1$，那么只要维护一下这个东西的长度就好了。

这个的话就是跟 GSS 那个东西一样的，唯一有个不同的点（以维护最长的 $0$ 前缀为例）就是如果只有左子区间全为 $0$ 的时候才能让右子区间带来贡献。

细节有点多，建议沉下心来做。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51; 
struct SegmentTree{
	ll l,r,mx0,mx1,pr0,pr1,sf0,sf1,all0,all1;
};
SegmentTree tree[MAXN<<2];
ll n,qcnt;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
#define ls node<<1
#define rs (node<<1)|1
inline void update(ll node)
{
	ll lenl=tree[ls].r-tree[ls].l+1,lenr=tree[rs].r-tree[rs].l+1;
	tree[node].mx0=max(tree[ls].mx0,tree[rs].mx0);
	tree[node].mx1=max(tree[ls].mx1,tree[rs].mx1);
	tree[node].pr0=tree[ls].pr0,tree[node].pr1=tree[ls].pr1;
	tree[node].sf0=tree[rs].sf0,tree[node].sf1=tree[rs].sf1;
	tree[node].all0=tree[ls].all0&tree[rs].all0;
	tree[node].all1=tree[ls].all1&tree[rs].all1;
	tree[ls].all0?tree[node].pr0=max(tree[node].pr0,lenl+tree[rs].pr0):1;
	tree[ls].all1?tree[node].pr1=max(tree[node].pr1,lenl+tree[rs].pr1):1;
	tree[rs].all0?tree[node].sf0=max(tree[node].sf0,lenr+tree[ls].sf0):1;
	tree[rs].all1?tree[node].sf1=max(tree[node].sf1,lenr+tree[ls].sf1):1;
	tree[node].mx0=max(tree[node].mx0,tree[ls].sf0+tree[rs].pr0);
	tree[node].mx1=max(tree[node].mx1,tree[ls].sf1+tree[rs].pr1);
}
inline void create(ll l,ll r,ll node)
{
	tree[node]=(SegmentTree){l,r,0,0,0,0};
	if(l==r)
	{
		if(l&1)
		{
			tree[node].mx1=tree[node].pr1=tree[node].sf1=tree[node].all1=1;
		}
		else
		{
			tree[node].mx0=tree[node].pr0=tree[node].sf0=tree[node].all0=1;
		}
		return;
	}
	ll mid=(l+r)>>1;
	create(l,mid,ls),create(mid+1,r,rs),update(node);
}
inline void change(ll pos,ll node)
{
	if(tree[node].l==tree[node].r)
	{
		if(tree[node].mx1)
		{
			tree[node].mx1=tree[node].pr1=tree[node].sf1=tree[node].all1=0;
			tree[node].mx0=tree[node].pr0=tree[node].sf0=tree[node].all0=1;
		}
		else
		{
			tree[node].mx0=tree[node].pr0=tree[node].sf0=tree[node].all0=0;
			tree[node].mx1=tree[node].pr1=tree[node].sf1=tree[node].all1=1;
		}
		return;
	}
	ll mid=(tree[node].l+tree[node].r)>>1;
	change(pos,pos<=mid?ls:rs),update(node);
}
int main()
{
	create(1,n=read(),1),qcnt=read();
	for(register int i=0;i<qcnt;i++)
	{
		change(read(),1),printf("%d\n",max(tree[1].mx0,tree[1].mx1));	
	}	
}
```

---

## 作者：Michael_Kong (赞：7)

比较模板的线段树维护区间信息

如果对这个问题不是很熟悉的同学可以去看一下[这道题](https://www.luogu.com.cn/problem/SP1043) 或者是 can you answer these question 系列的题目，都是关于线段树维护区间各种值的题目

## 正篇
对于每一个区间，我们需要维护这个区间的
 
1. 左端点值

2. 右端点值

3. 左边开始的最大长度

4. 右边开始的最大长度

5. 区间长度

6. 区间最长的符合要求的s串

这道题的难点在于pushup函数该怎么写。我们可以先按部就班地更新一下，然后再根据我们合并的两个区间相连接处的值来进行进一步地判定。
更加准确的说，就是如果相连处的值相等就没有后续了，如果不相等就可以继续更新，更新的细节在代码里面可以自己看一下

剩下的就是一个很普通的线段树了

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=200005;
struct node{
	int lv,rv,lenl,lenr,sum,len;
}t[maxn<<2];
int n,m;
void pushup(int pos){
	t[pos].lv=t[pos<<1].lv;
	t[pos].rv=t[pos<<1|1].rv;
	t[pos].lenl=t[pos<<1].lenl;
	t[pos].lenr=t[pos<<1|1].lenr;
	t[pos].sum=max(t[pos<<1].sum,t[pos<<1|1].sum);
	if(t[pos<<1].rv!=t[pos<<1|1].lv){
		t[pos].sum=max(t[pos].sum,t[pos<<1].lenr+t[pos<<1|1].lenl);
		if(t[pos<<1].sum==t[pos<<1].len){
			t[pos].lenl=t[pos<<1].sum+t[pos<<1|1].lenl;
		}
		if(t[pos<<1|1].sum==t[pos<<1|1].len){
			t[pos].lenr=t[pos<<1|1].sum+t[pos<<1].lenr;
		}
	}
}
void build(int l,int r,int pos){
	t[pos].len=(r-l+1);
	if(l==r){
		t[pos].lv=t[pos].rv=1;
		t[pos].lenl=t[pos].lenr=1;
		t[pos].sum=1;
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,pos<<1);
	build(mid+1,r,pos<<1|1);
	pushup(pos);
}
void change(int x,int l,int r,int pos){
	if(l==r){
		t[pos].lv^=1;
		t[pos].rv=t[pos].lv;
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid) change(x,l,mid,pos<<1);
	if(x>mid) change(x,mid+1,r,pos<<1|1);
	pushup(pos);
}
int main(void){
	scanf("%d %d",&n,&m);
	build(1,n,1);
	int x;
	while(m--){
		scanf("%d",&x);
		change(x,1,n,1);
		printf("%d\n",max(t[1].sum,max(t[1].lenl,t[1].lenr)));
	}
}
```


---

## 作者：Gold14526 (赞：4)

看到题解区没有广义矩乘的，我来交一发。

### 题意简述

维护一个长度为 $n(1\le n \le 2 \times 10^5)$ 的 $01$ 序列，支持以下操作：

- 单点异或 $1$
- 查询最长的 $01$ 交替子串。

操作次数不超过 $2 \times 10^5$ 次。

### 广义矩乘

没学过矩乘请前往[矩乘模板](https://www.luogu.com.cn/problem/B2105)或看其它题解的思路。

我们先回顾常用的矩乘，假设 $A$ 为一个 $n \times k$ 的矩阵，$B$ 为一个 $k \times m$ 的矩阵，$C=A \times B$。

那么对于 $1\le i \le n,1 \le j \le m$ ，有：

$$C_{i,j}=\sum_{p=1}^k A_{i,p}\times B_{p,j}$$

广义矩乘就是把求和和乘法换成别的运算。

在广义矩阵乘法中，对于 $1\le i \le n,1 \le j \le m$ ，有：

$$C_{i,j}=\oplus_{p=1}^k A_{i,p}\otimes B_{p,j}$$

这里要求两种算法有分配律，即对于任意 $x,y,z$，满足：

$$(x\oplus y)\otimes z=(x\otimes z)\oplus(y\otimes z)$$

例如，在常用的矩乘中，有 $(x+y)\times z=(x\times z)+(y\times z)$.

### 本题做法

本题中，我们使用的广义矩阵乘法为 $C_{i,j}=\max_{p=1}^k A_{i,p}+ B_{p,j}$，两种运算显然满足分配律。

考虑直接 dp 怎么做。

令 $a_i$ 表示序列第 $i$ 位，设 $dp_i$ 表示以 $i$ 为结尾的最长 $01$ 交替子串。

那么分两种情况：

当 $a_i=a_{i-1}$ 时，$dp_i=1$；

当 $a_i\ne a_{i-1}$ 时，$dp_i=dp_{i-1}+1$。

特殊的，$dp_1=1$。

为记录答案，我们设 $ans_i$ 为区间 $[1,i]$ 的答案。

那么 $ans_i=\max(ans_{i-1},dp_i)$。

同样的，$ans_1=1$。

我们观察到，在转移过程中出现了 $ans_i,dp_i$ 和常数，所以以这三个量作为状态矩阵：

$$\begin{bmatrix} ans_i & dp_i &  0 \end{bmatrix}$$

那么转移矩阵呢？

考虑设其为 $T$，则有：

$$\begin{bmatrix} ans_{i-1} & dp_{i-1} &  0 \end{bmatrix}T=\begin{bmatrix} ans_i & dp_i &  0 \end{bmatrix}$$

首先，它一定是 $3\times 3$ 的。

其次，我们考虑转移方程。

对于常数项，显然有 $0=0$。

对于 $dp_i$ 和 $ans_i$，按照之前分的两种情况看：

若 $a_i=a_{i-1}$，则 $dp_i=1,ans_i=\max(ans_{i-1},1)$，所以转移矩阵为：

$$\begin{bmatrix} 0 & -\infty & -\infty \\ -\infty & -\infty & -\infty \\ 1 & 1 & 0 \end{bmatrix}$$

否则，$dp_i=dp_{i-1}+1,ans_i=\max(ans_{i-1},dp_{i-1}+1)$，则转移矩阵为：

$$\begin{bmatrix} 0 & -\infty & -\infty \\ 1 & 1 & -\infty \\ -\infty & -\infty & 0 \end{bmatrix}$$

其它的，单位矩阵为 $\begin{bmatrix} 0 & -\infty & -\infty \\ -\infty & 0 & -\infty \\ -\infty & -\infty & 0 \end{bmatrix}$，初始矩阵为 $\begin{bmatrix} 1 & 1 & 0 \end{bmatrix}$。

用线段树维护转移矩阵乘积即可。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int num;
char ch;
int read()
{
	num=0;
	ch=getchar();
	while(ch<'0'||ch>'9')
	{
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		num=(num<<1)+(num<<3)+ch-'0';
		ch=getchar();
	}
	return num;
}
const int inf=2147483647;
struct matrix{
	short n,m;
	int a[3][3];
}nothing,f,z,A,B;
matrix operator*(matrix x,matrix y){
	z.n=x.n;
	z.m=y.m;
	for(short i=0;i<x.n;++i)
	{
		for(short j=0;j<y.m;++j)
		{
			z.a[i][j]=-inf;
			for(short k=0;k<x.m;++k)
			{
				z.a[i][j]=max(1ll*z.a[i][j],1ll*x.a[i][k]+y.a[k][j]);
			}
		}
	}
	return z;
};
bool a[200001];
struct tree{
	int l,r;
	matrix mul;
}t[800001];
void build(int p,int l,int r)
{
	t[p].l=l;
	t[p].r=r;
	if(l==r)
	{
		t[p].mul=A;
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	t[p].mul=t[p<<1].mul*t[p<<1|1].mul;
}
void change(int p,int index)
{
	if(t[p].l>index||t[p].r<index)return;
	if(t[p].l==index&&t[p].r==index)
	{
		t[p].mul=(a[index]==a[index-1]?A:B);
		return;
	}
	change(p<<1,index);
	change(p<<1|1,index);
	t[p].mul=t[p<<1].mul*t[p<<1|1].mul;
}
matrix ask(int p,int l,int r)
{
	if(t[p].l>r||t[p].r<l||l>r)return nothing;
	if(t[p].l>=l&&t[p].r<=r)return t[p].mul;
	return ask(p<<1,l,r)*ask(p<<1|1,l,r);
}
void init()
{
	nothing.n=nothing.m=3;
	for(short i=0;i<3;++i)
	{
		for(short j=0;j<3;++j)
		{
			nothing.a[i][j]=-inf*(i!=j);
		}
	}
	A=nothing;
	A.a[1][1]=-inf;
	A.a[2][1]=1;
	B=A;
	B.a[1][1]=B.a[1][0]=1;
	f.n=1;
	f.m=3;
	f.a[0][0]=f.a[0][1]=1;
}
int n,q,x;
int main()
{
	init();
	n=read();
	q=read();
	build(1,2,n);
	while(q--)
	{
		x=read();
		a[x]=!a[x];
		if(x!=1)
		change(1,x);
		change(1,x+1);
		printf("%d\n",(f*ask(1,2,n)).a[0][0]);
	}
	return 0;
}

```

---

## 作者：珈乐唯毒 (赞：4)

本题理解：单点修改，区间查询

所以你以为算法是树状数组？

ko no 线段树 da！

这道题可以使用一个没有pushdown的线段树过掉。

### 思路：
线段树结构体中有5个变量：l,r(区间范围)，zc(左边最长),yc(右边最长),c(总共最长)

然后只有维护后三个值就可以了，这里需要分情况讨论。

1.左儿子和右儿子不能并到一起

这个时候 zc=左儿子的zc yc=右儿子的yc c=左右儿子的c中的较大值

2.左儿子和右儿子可以并到一起

这个时候又需要讨论。

如果左儿子的zc和它区间的长一样，zc=左儿子的zc+右儿子的yc

不然zc=左儿子的zc

yc同理

c=左儿子的c，右儿子的c，左儿子的yc+右儿子的zc中的最大值

然后就可以AC了

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tree{
	int yc,zc,c,l,r;
}tr[200005*4];
bool a[200005];
void xg(int k,int l){
	if(tr[k].l==tr[k].r)
		return;
	int mid=(tr[k].l+tr[k].r)>>1;
	if(mid>=l)
		xg(k<<1,l);
	else
		xg(k<<1|1,l);
	if(a[tr[k<<1|1].l]!=a[tr[k<<1].r]){
		if(tr[k<<1|1].yc==tr[k<<1|1].r-tr[k<<1|1].l+1)
			tr[k].yc=tr[k<<1].yc+tr[k<<1|1].yc;
		else
			tr[k].yc=tr[k<<1|1].yc;
		if(tr[k<<1].zc==tr[k<<1].r-tr[k<<1].l+1)
			tr[k].zc=tr[k<<1].zc+tr[k<<1|1].zc;
		else
			tr[k].zc=tr[k<<1].zc;
		tr[k].c=max(tr[k<<1].yc+tr[k<<1|1].zc,max(tr[k<<1].c,tr[k<<1|1].c));
	}
	else{
		tr[k].yc=tr[k<<1|1].yc;
		tr[k].zc=tr[k<<1].zc;
		tr[k].c=max(tr[k<<1].c,tr[k<<1|1].c);
	}
	return;
}
void build(int k){
	tr[k].yc=tr[k].zc=tr[k].c=1;
	if(tr[k].l==tr[k].r)
		return;
	int mid=(tr[k].l+tr[k].r)>>1;
	tr[k<<1].l=tr[k].l;tr[k<<1].r=mid;
	tr[k<<1|1].l=mid+1;tr[k<<1|1].r=tr[k].r;
	build(k<<1);
	build(k<<1|1);
	return;
}
int n,q,x;
int main(){
	cin>>n>>q;
	tr[1].l=1;
	tr[1].r=n;
	build(1);
	while(q--){
		scanf("%d",&x);
		a[x]^=1;
		xg(1,x);
		printf("%d\n",tr[1].c);
	}
	return 0;
} 
```


---

## 作者：HPXXZYY (赞：3)

$\color{blue}{\texttt{【思路】：}}$

首先，我们为了方便处理，把 `L` 抽象成一个数字 $0$，同理把 `R` 抽象成 $1$。

数据范围提示我们，我们需要一个时间复杂度为 $O(q \times \log n)$ 的算法 ~~（或者是 $O(n \times \log q)$，但是应该没有人能把询问给 $\log$ 掉）~~ 。想到了什么？对滴，线段树！

线段树的一个非常重要的操作就是 `pushup` 操作，也就是标记合并操作。我们考虑如何实现这个 `pushup` 操作。

记 $sum_o$ 为线段树上 $o$ 号节点所表示区间最长的满足要求的字符串。我们考虑 $sum_o$ 能取到什么值：

- 一种比较显然的是左右儿子的 $sum$ 值的较大值。
- 还有一种就是左儿子的结尾和右儿子的开头合并，产生了一个新的满足要求的字符串。

第一个非常好维护，重点在于第二个。如何方便而快捷地求出第二种情况的解呢？

显然，单独一个 $sum$ 不能维护第二种情况。我们考虑多引入几个变量：

- $le_o$：节点 $o$ 所表示区间的最左边的字符。
- $ri_o$：节点 $o$ 所表示区间的最右边的字符。
- $al_o$：节点 $o$ 所表示区间的最长满足条件的前缀字符串的长度。
- $ar_o$：节点 $o$ 所表示区间的最长满足条件的后缀字符串的长度。

它们有什么用？显然，前两个值可以方便的告诉我们第二种情况是否存在（如果左儿子的 $ri$ 值 $\neq$ 右儿子的 $le$ 值则有第二种情况，否则没有）。

后两个呢？也很显然，当有第二种情况时，第二种情况中的字符串的长度就是左儿子的 $ar+$ 右儿子的 $al$ 值。

到这里，我们便可以 $O(1)$ 完成 `pushup` 操作了。

$\color{blue}{\texttt{【代码】：}}$

```cpp
const int N=2e5+100,M=N<<2;
int sum[M],le[M],ri[M],al[M],ar[M],len[M];
inline void pushup(int o){
	if (ri[o<<1]!=le[o<<1|1]){
		sum[o]=ar[o<<1]+al[o<<1|1];
		sum[o]=max(sum[o],sum[o<<1]);
		sum[o]=max(sum[o],sum[o<<1|1]);
	}
	else sum[o]=max(sum[o<<1],sum[o<<1|1]);
	le[o]=le[o<<1];ri[o]=ri[o<<1|1];
	if (al[o<<1]==len[o<<1]&&ri[o<<1]!=le[o<<1|1])
		al[o]=al[o<<1]+al[o<<1|1];//特殊情况 
	else al[o]=al[o<<1];//否则直接继承左儿子 
	if (ar[o<<1|1]==len[o<<1|1]&&le[o<<1|1]!=ri[o<<1])
		ar[o]=ar[o<<1|1]+ar[o<<1];//一切同上 
	else ar[o]=ar[o<<1|1];//只是变成了右儿子 
}//不能理解？不妨画个图试试看~
inline void init_node(int o,int t){
	sum[o]=al[o]=ar[o]=1;le[o]=ri[o]=t;
}
void build(int o,int l,int r){
	len[o]=r-l+1;//区间长度 
	if (l==r){//到达叶节点 
		init_node(o,0);
		return;
	}
	register int mid=(l+r)>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	pushup(o);return;
}
void updata(int o,int l,int r,int p){
	if (l==r){
		init_node(o,!le[o]);
		return;
	}
	register int mid=(l+r)>>1;
	if (p<=mid) updata(o<<1,l,mid,p);
	else updata(o<<1|1,mid+1,r,p);
	pushup(o);return;
}
int main(){
	int n=read(),m=read();
	build(1,1,n);//建树 
	for(int i=1;i<=m;i++){
		register int x=read();
		updata(1,1,n,x);//修改 
		printf("%d\n",sum[1]);
	}
	return 0;
}
```

---

## 作者：JK_LOVER (赞：2)

如果格式有问题请见[这里](https://www.luogu.com.cn/blog/xzc/solution-p6489)
。

看见是问连续最长01子区间,第一反应是dp,但是这道题是要支持修改的.
~~(再看一下标签)~~
应该是线段树上的dp.
如果你直接统计01子区间的话,是会出错的(应该是我太菜)你应该会打出这样的代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 11400000
struct node{
	int l,r,Lmax,Rmax,tot,L,R;
}t[N];
int read()
{
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
void update(int x)
{
	if(t[x<<1].R != t[x<<1|1].L) t[x].tot = t[x<<1].Rmax + t[x<<1|1].Lmax;
	t[x].tot = max(max(t[x<<1].tot,t[x<<1|1].tot),t[x].tot);
	t[x].L = t[x<<1].L;
	t[x].R = t[x<<1|1].R;
	if(t[x<<1].R != t[x<<1|1].L && t[x<<1].Lmax == t[x<<1].r-t[x<<1].l+1) 
	t[x].Lmax = t[x<<1].tot + t[x<<1|1].Lmax;
	else t[x].Lmax = t[x<<1].Lmax;
	if(t[x<<1].R != t[x<<1|1].L && t[x<<1|1].Rmax == t[x<<1|1].r-t[x<<1|1].l+1)
	t[x].Rmax = t[x<<1].Rmax + t[x<<1|1].tot;
	else t[x].Rmax = t[x<<1|1].Rmax;
	t[x].tot = max(t[x].Lmax,max(t[x].Rmax,t[x].tot));
}
void build(int q,int l,int r)
{
	t[q].l = l;t[q].r = r;
	if(l == r)
	{
		t[q].Lmax=t[q].Rmax=t[q].tot=t[q].L=t[q].R=1;
		return ;
	}
	int mid = l + r>>1;
	build(q<<1,l,mid);
	build(q<<1|1,mid+1,r);
	update(q);
}
void change(int q,int l,int r,int key)
{
	if(key == l && key == r)
	{
		t[q].R = t[q].L = t[q].L^1;
		return;
	}
	int mid = l+r>>1;
	if(key <= mid) change(q<<1,l,mid,key);
	if(key > mid) change(q<<1|1,mid+1,r,key);
	update(q);
}
int n,m;
signed main()
{
	n=read();m=read();
	build(1,1,n);
	for(int i = 1;i <= m;i++)
	{
		int a = read();
		change(1,1,n,a);
		printf("%d\n",t[1].tot);
	}
}
```
然后就WA了.......

我们考虑一个套路将相同的字母为0,不相同的为1.就转化为求最长序列问题了,这道题也就迎刃而解了,用 $tot$ 表示这个区间最长的序列.则有以下转移:

$$
tot_x=\begin{cases}tot_{Lson}\\tot_{Rson}\\Rmax_{Lson}+Lmax_{Rson}\end{cases}
$$ 
但是当 $Rmax_{Lson} = tot_{Lson}$ 时是可以合并区间的( $Rson$ 同理)这样这道题就解决了

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 11400000
struct node{
	int l,r,Lmax,Rmax,tot;
}t[N];
int read()
{
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
void update(int q)
{
	t[q].Lmax = t[q<<1].Lmax;
	t[q].Rmax = t[q<<1|1].Rmax;
	if(t[q<<1].tot == t[q<<1].r+1-t[q<<1].l) t[q].Lmax = t[q<<1].tot + t[q<<1|1].Lmax;
	if(t[q<<1|1].tot == t[q<<1|1].r+1-t[q<<1|1].l) t[q].Rmax = t[q<<1|1].tot+t[q<<1].Rmax;
	t[q].tot = t[q<<1].Rmax+t[q<<1|1].Lmax;
	int M = max(max(t[q<<1|1].tot,t[q<<1].tot),max(t[q].Lmax,t[q].Rmax));
	t[q].tot = max(t[q].tot,M);
}
void build(int q,int l,int r)
{
	t[q].l = l;t[q].r = r;
	if(l == r)
	{
		t[q].Lmax=t[q].Rmax=t[q].tot=0;
		return ;
	}
	int mid = l + r>>1;
	build(q<<1,l,mid);
	build(q<<1|1,mid+1,r);
	update(q);
}
void change(int q,int l,int r,int key,int val)
{
	if(key == l && key == r)
	{
		t[q].tot = t[q].Rmax = t[q].Lmax = val;
		return;
	}
	int mid = l+r>>1;
	if(key <= mid) change(q<<1,l,mid,key,val);
	if(key > mid) change(q<<1|1,mid+1,r,key,val);
	update(q);
}
int n,m,Val[N];
signed main()
{
	n=read();m=read();
	build(1,1,n-1);
	for(int i = 1;i <= m;i++)
	{
		int a = read();
		if(a>1) change(1,1,n-1,a-1,Val[a-1]^=1);
		if(a<n) change(1,1,n-1,a,Val[a]^=1);
		printf("%d\n",t[1].tot+1);
	}
}

```


---

## 作者：yu__xuan (赞：1)

水点社区贡献。
### 题目
[P6492 [COCI2010-2011#6] STEP](https://www.luogu.com.cn/problem/P6492)
### 思路
线段树。先明确线段树要维护什么信息。

一个区间的最长的符合要求的序列有以下几种可能

* 该区间的左子区间的最右边的元素等于右子区间的最左边的元素，即两个区间无法合并，那么该区间的答案为左子区间和右子区间中最大的。
* 两个区间可以合并，那么该区间的答案为左子区间、右子区间、左子区间从最右边开始的答案加上右子区间从最左边开始的答案中的最大值。

所以我们的线段树要维护区间的答案，区间的最左边的元素，区间的最右边的元素，区间从最左边开始的答案，区间从最右边开始的答案。

### Code

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
#include<algorithm>
#define MAXN 200001
#define lson now<<1
#define rson now<<1|1

inline void read(int &T) {
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int n,q;
struct Node {
	int l,r,w,lw,rw;
	int lmax,rmax;
}tree[MAXN<<2];

int max(int a,int b) {return a>b?a:b;}

void build(int l,int r,int now) {
	tree[now].l=l,tree[now].r=r;
	if(tree[now].l==tree[now].r) {
		tree[now].w=tree[now].lw=tree[now].rw=1;
		tree[now].lmax=tree[now].rmax=1;return;
	}
	int mid=(tree[now].l+tree[now].r)>>1;
	build(l,mid,lson),build(mid+1,r,rson);
	tree[now].lw=tree[lson].lw,tree[now].rw=tree[rson].rw;
	if(tree[lson].lmax==tree[lson].r-tree[lson].l+1) {
		if(tree[lson].rw==tree[rson].lw) tree[now].lmax=tree[lson].lmax;
		else tree[now].lmax=tree[lson].lmax+tree[rson].lmax;
	}else tree[now].lmax=tree[lson].lmax;
	if(tree[rson].rmax==tree[rson].r-tree[rson].l+1) {
		if(tree[lson].rw==tree[rson].lw) tree[now].rmax=tree[rson].rmax;
		else tree[now].rmax=tree[lson].rmax+tree[rson].rmax;
	}else tree[now].rmax=tree[rson].rmax;
	tree[now].w=max(tree[lson].w,tree[rson].w);
	if(tree[lson].rw!=tree[rson].lw) {
		tree[now].w=max(tree[now].w,tree[lson].rmax+tree[rson].lmax);
	}
}

void update(int x,int now) {
	if(tree[now].l==tree[now].r) {
		tree[now].lw=tree[now].rw=tree[now].w^=1;
		tree[now].lmax=tree[now].rmax=1;return;
	}
	int mid=(tree[now].l+tree[now].r)>>1;
	if(x<=mid) update(x,lson);
	else update(x,rson);
	tree[now].lw=tree[lson].lw,tree[now].rw=tree[rson].rw;
	if(tree[lson].lmax==tree[lson].r-tree[lson].l+1) {
		if(tree[lson].rw==tree[rson].lw) tree[now].lmax=tree[lson].lmax;
		else tree[now].lmax=tree[lson].lmax+tree[rson].lmax;
	}else tree[now].lmax=tree[lson].lmax;
	if(tree[rson].rmax==tree[rson].r-tree[rson].l+1) {
		if(tree[lson].rw==tree[rson].lw) tree[now].rmax=tree[rson].rmax;
		else tree[now].rmax=tree[lson].rmax+tree[rson].rmax;
	}else tree[now].rmax=tree[rson].rmax;
	tree[now].w=max(tree[lson].w,tree[rson].w);
	if(tree[lson].rw!=tree[rson].lw) {
		tree[now].w=max(tree[now].w,tree[lson].rmax+tree[rson].lmax);
	}
}

int main() {
	read(n),read(q),build(1,n,1);
	for(int i=1,x;i<=q;++i) {
		read(x),update(x,1);
		printf("%d\n",tree[1].w);
	}
	return 0;
}
```

---

## 作者：HoshiuZ (赞：0)

~~这题好像就是之前那个啥腰鼓的那题..~~

既然其要求不存在连续的`L`和`R`，那么我们可以直接将初始序列弄成`L`与`R`相间的情况，这样问题就转化为求区间内连续最长全为`L`的长度与区间内连续最长`R`的长度的较大值，这个很好维护，有些类似 [[USACO08FEB]Hotel G](https://www.luogu.com.cn/problem/P2894) 。

线段树板子。

需要维护的信息:

1. 区间靠左端的连续最长`L`长度
2. 区间内连续最长`L`长度
3. 区间靠右端的连续最长`L`长度
4. 区间靠左端的连续最长`R`长度
5. 区间内连续最长`R`长度
6. 区间靠右端的连续最长`R`长度

### 代码
```cpp
#include<bits/stdc++.h>
#define N 20010

using namespace std;

int n,m,x;
struct node{
	int l,r,lmax0,rmax0,max0,lmax1,rmax1,max1;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define lm0(x) tree[x].lmax0
	#define rm0(x) tree[x].rmax0
	#define m0(x) tree[x].max0
	#define lm1(x) tree[x].lmax1
	#define rm1(x) tree[x].rmax1
	#define m1(x) tree[x].max1
	#define ls p<<1
	#define rs ls|1
}tree[N<<2];

void push_up(int p) {
	m0(p)=max(rm0(ls)+lm0(rs),max(m0(ls),m0(rs)));
	m1(p)=max(rm1(ls)+lm1(rs),max(m1(ls),m1(rs)));
	lm0(p)=(lm0(ls)==r(ls)-l(ls)+1)?lm0(ls)+lm0(rs):lm0(ls);
	rm0(p)=(rm0(rs)==r(rs)-l(rs)+1)?rm0(rs)+rm0(ls):rm0(rs);
	lm1(p)=(lm1(ls)==r(ls)-l(ls)+1)?lm1(ls)+lm1(rs):lm1(ls);
	rm1(p)=(rm1(rs)==r(rs)-l(rs)+1)?rm1(rs)+rm1(ls):rm1(rs);
}

void build(int p,int l,int r) {
	l(p)=l,r(p)=r;
	if(l==r) {
		lm1(p)=rm1(p)=m1(p)=l&1;		
		lm0(p)=rm0(p)=m0(p)=l&1^1;
		return ;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	push_up(p);
}

void change(int p,int x) {
	if(l(p)>x||r(p)<x) return ;
	if(l(p)==r(p)) {
		m1(p)^=1;
		lm1(p)^=1;
		rm1(p)^=1;
		m0(p)^=1;
		lm0(p)^=1;
		rm0(p)^=1;
		return ;
	}
	change(ls,x);
	change(rs,x);
	push_up(p);
}

int main() {
	cin>>n>>m;
	
	build(1,1,n);
	for(int i=1;i<=m;i++) {
		cin>>x;
		change(1,x);
		cout<<max(m0(1),m1(1))<<endl;
	}
	
	return 0;
}
```

---

## 作者：Retucl (赞：0)

对原序列$a$构建一个长度为其长度$n-1$的序列$b$。

若$a$中相邻两项相同，则$b$中那个位置为$0$，否则为$1$。

问题就转化为求$b$中最多连续$1$的个数。

线段树板子。

每次修改只需修改$b$中的两个数，注意特判$1$和$n$。

code:

```cpp
const int N = 2e5 + 5;

struct Segmenttr{
	int l , r , maxl , maxr , maxm , val;
}tr[N << 2];

int n , q , x;

void build(int rt , int l , int r){
	tr[rt].l = l , tr[rt].r = r , tr[rt].val = 0;
	if(l == r)
		return;
	int mid = (l + r) >> 1;
	build(rt << 1 , l , mid) , build(rt << 1 | 1 , mid + 1 , r);
}

void update(int rt , int k){
	if(tr[rt].l > k || tr[rt].r < k)
		return;
	if(tr[rt].l == tr[rt].r){
		tr[rt].val = 1 - tr[rt].val;
		if(tr[rt].val)
			tr[rt].maxl = tr[rt].maxm = tr[rt].maxr = 1;
		else
			tr[rt].maxl = tr[rt].maxm = tr[rt].maxr = 0;
		return;
	}
	update(rt << 1 , k) , update(rt << 1 | 1 , k);
	if(tr[rt << 1].maxl == tr[rt << 1].r - tr[rt << 1].l + 1)
		tr[rt].maxl = tr[rt << 1].maxl + tr[rt << 1 | 1].maxl;
	else
		tr[rt].maxl = tr[rt << 1].maxl;
	if(tr[rt << 1 | 1].maxr == tr[rt << 1 | 1].r - tr[rt << 1 | 1].l + 1)
		tr[rt].maxr = tr[rt << 1 | 1].maxr + tr[rt << 1].maxr;
	else
		tr[rt].maxr = tr[rt << 1 | 1].maxr;
	tr[rt].maxm = max(max(tr[rt << 1].maxm , tr[rt << 1 | 1].maxm),max(max(tr[rt].maxl , tr[rt].maxr) , tr[rt << 1].maxr + tr[rt << 1 | 1].maxl));
}

int main(){
	cin >> n >> q;
	build(1 , 1 , n - 1);
	while(q--){
		cin >> x;
		if(x != 1)
			update(1 , x - 1);
		if(x != n)
			update(1 , x);
		cout << tr[1].maxm + 1 << endl;
	}
	return 0;
}
```


---

## 作者：EternalEpic (赞：0)

看这道题，区间询问，答案具有可并性，于是考虑用线段树维护。

此题很像那种求区间最大子段，考虑维护一个线段树的节点。

每个节点维护如下信息：

1. $lmax$ 指最左端的连续最长子串长度。

2. $rmax$ 指最右端的连续最长子串长度。

3. $allmax$ 指连续最长子串长度。

4. $lsum$ 指最左端字符。

5. $rsum$ 指最右端字符。

6. $len$ 指区间长度。

考虑合并左右两个子节点并计算贡献。

lmax和rmax只需要考虑中间是否能拼接起来更新，
allmax则是各段allmax取最值，再考虑中间是否能拼接起来更新。

其余的值直接调用左右节点的值来贡献即可。

```cpp
inline Node operator + (const Node&rhs) const {
	return Node(
		allmax == len && rsum != rhs.lsum ? len + rhs.lmax : lmax,
		rhs.allmax == rhs.len && rsum != rhs.lsum ? rmax + rhs.len : rhs.rmax,
		max(rsum != rhs.lsum ? rmax + rhs.lmax : 0, allmax, rhs.allmax),
		lsum,
		rhs.rsum,
		len + rhs.len
	);
}
```

然后线段树就是常规操作。

```cpp
struct SegmentTree {
	struct Node {
		int lmax, rmax, allmax, lsum, rsum, len;
		Node() { lsum = rsum = 0; len = lmax = rmax = allmax = 1; }
		Node(int _lmax, int _rmax, int _allmax, int _lsum, int _rsum, int _len)
		: lmax(_lmax), rmax(_rmax), allmax(_allmax), lsum(_lsum), rsum(_rsum), len(_len) {}
		inline void Vary(void) { rsum ^= 1; lsum ^= 1; }
		inline Node operator + (const Node&rhs) const {
			return Node(
				allmax == len && rsum != rhs.lsum ? len + rhs.lmax : lmax,
				rhs.allmax == rhs.len && rsum != rhs.lsum ? rmax + rhs.len : rhs.rmax,
				max(rsum != rhs.lsum ? rmax + rhs.lmax : 0, allmax, rhs.allmax),
				lsum,
				rhs.rsum,
				len + rhs.len
			);
		}
	} t[Maxn];
	
	inline void pushup(int pos) { t[pos] = t[pos << 1] + t[pos << 1 | 1]; }
	inline void build(int pos, int l, int r) {
		if (l == r) return;
		int mid = l + r >> 1;
		build(pos << 1, l, mid);
		build(pos << 1 | 1, mid + 1, r);
		pushup(pos);
	}

	inline void change(int pos, int l, int r, int idx) {
//		cout << l << ' ' << r << endl;
//		if (l > idx || r < idx) return;
		if (l == r) { t[pos].Vary(); return; }
		int mid = l + r >> 1;
		if (idx <= mid) change(pos << 1, l, mid, idx);
		else change(pos << 1 | 1, mid + 1, r, idx);
		pushup(pos);
	}
	
	inline Node query1(int pos, int l, int r, int L, int R) {
		if (L <= l && R >= r) return t[pos];
		int mid = l + r >> 1; // Node ret;
		if (L <= mid && R > mid) return query1(pos << 1, l, mid, L, R) + query1(pos << 1 | 1, mid + 1, r, L, R);
		if (L <= mid) return query1(pos << 1, l, mid, L, R);
		if (R > mid) return query1(pos << 1 | 1, mid + 1, r, L, R);
	}
	
	inline int query(void) { return t[1].allmax; }
} T;
```




---


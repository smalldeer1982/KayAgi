# [COCI 2013/2014 #1] LOPOV

## 题目背景

有一些物品和一个小偷。

## 题目描述

有 $N$ 件物品，每件物品有质量 $M_i$ 和价值 $V_i$。

Mirko 有 $K$ 个袋子，每袋可容纳的最大质量为 $C_i$。

每袋仅能放一个物品，问最多可以带走多少价值的物品？

## 说明/提示

#### 【数据规模与约定】
- $1\le N,K\le 3\times 10^5$。
- $1\le M_i,V_i\le 10^6$。
- $1\le C_i\le 10^8$。

#### 样例 2 解释
Mirko 将第一件物品放在第二袋中，将第三件物品放在第一袋中。

-------
#### 【说明】
**题目译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #1](https://hsin.hr/coci/archive/2013_2014/contest1_tasks.pdf)  _T4 LOPOV_。**

## 样例 #1

### 输入

```
2 1
5 10
100 100
11 ```

### 输出

```
10```

## 样例 #2

### 输入

```
3 2
1 65
5 23
2 99
10
2```

### 输出

```
164```

# 题解

## 作者：cjh20090318 (赞：3)

大家好，我是 CQ-C2024 蒟蒻 CJH。

## 题意

~~[题目描述](https://www.luogu.com.cn/problem/P6538)很清楚了不说。~~

标签：排序，贪心。

## 分析

此题要让价值最大化，就要在每一个袋子的容量内选取最大价值的物品，这个可以使用手写[大根堆](https://oi-wiki.org//ds/binary-heap/)或是使用 `STL priority_queue`，~~具体使用方法请自行 BDFS。~~

## 注意事项

- 容量为 $C_i$ 的袋子中有可能会没有符合条件的物品，所以在取出堆顶前要判断堆中是否为空，~~就因为这个不起眼的判断我失去了一大半的分数~~。

- 根据数据范围 $1 \le N,K \le 3 \times 10^5$，$1 \le C_i \le 10^8$，答案需要用 `long long` 存储，~~不开 `long long` 见祖宗~~。

## 代码

```cpp
//the code is from chenjh
#include<cstdio>
#include<algorithm>
#include<queue>
#define MAXN 300003
using namespace std;
int n,k;
//int m[MAXN],v[MAXN];
struct BREAD{//每一个物体的重量和价值。
	int m,v;
}a[MAXN];
bool cmp(BREAD x,BREAD y){return x.m<y.m||(x.m==y.m&&x.v<y.v);}//每个物体按重量从小到大排序。
priority_queue<int> Q;//大根堆，存储物体的价值。
int c[MAXN];
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i].m,&a[i].v);
	for(int i=1;i<=k;i++) scanf("%d",&c[i]);
	sort(c+1,c+k+1);//将袋子按容量从小到大排序。
	sort(a+1,a+n+1,cmp);//见排序函数。
	long long ans=0;int j=1;
	for(int i=1;i<=k;i++){//从 1~k 进行枚举。
		for(;j<=n && a[j].m<=c[i];j++) Q.push(a[j].v);//将符合要求的物品的价值放入堆中。
		if(!Q.empty())ans+=Q.top(),Q.pop();//只有在堆不为空时才能取出堆顶（最大价值）！
	}
	printf("%lld\n",ans);
	return 0;
}
```

时间复杂度 $O(n \log n)$。

*谢谢大家 ！*


---

## 作者：⚡小林子⚡ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P6538)

------------

这题我刚看到的时候：

~~袋子，物品，这是背包啊！~~

把题读完才发现，这题是一道裸的贪心。

为什么是贪心：~~你没有发现这题跟纪念品分组挺像的吗~~

形容不好，大概就是一种直觉告诉我不是 DP，然后这题就是贪心了。

然后就可以想想怎么贪心了。

- 首先排序肯定是必不可少的，把物品按照重量从小到大排，把袋子按容量从小到大排。

- 然后 for 循环枚举每个袋子，在能装的物品里选价值最大的即可。

时间复杂度：枚举袋子 $\Theta(K)$，枚举物品 $\Theta(N)$，总复杂度 $\Theta(NK)$，

看一眼数据范围：

>$1\le N,K\le 3\times 10^5$

除非您会使用指令集，否则肯定会炸。

~~Let's think about other ways.~~

枚举袋子肯定是少不掉的，我们试着在枚举物品上面做优化。

这里有一种思路：用优先队列按价值从大到小维护当前体积不大于袋子的物品。

那就是在枚举第 i 个袋子的时候，将所有体积小于等于 $c_i$ 的物品放入优先队列中，然后取堆顶累加即可。

时间复杂度：枚举袋子 $\Theta(K)$，维护优先队列 $\Theta(\log N)$，总复杂度 $\Theta(K\times\log N)$，能水过去。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#define int long long
using namespace std;
int n,k,now=1,ans,c[300001];
struct Things{
	int m,v;
	bool operator < (const Things &rhs) const {
		return v<rhs.v; 
	}
}a[300001];
priority_queue<Things>pq;
bool cmp(const Things &x,const Things &y){
	return x.m<y.m;
}
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&a[i].m,&a[i].v);
	for(int i=1;i<=k;i++)
		scanf("%lld",&c[i]);
	sort(a+1,a+1+n,cmp);
	sort(c+1,c+1+k);
	for(int i=1;i<=k;i++){
		while(a[now].m<=c[i]&&now<=n)
			pq.push(a[now]),now++;
		if(pq.empty()) continue; 
		Things tmp=pq.top();pq.pop();
		ans+=tmp.v;
	}
	printf("%lld",ans);
	return 0;
}
```

[AC！](https://www.luogu.com.cn/record/35354065)

AC 以后，我开始了良（sang）心（xin）友（bing）好（kuang）的卡常，但是发现还是卡不过 liqingyang 大佬，慢了 20 多 ms。

upd：在 lmpp 大佬的指点下，代码速度又提升了 10ms ，达到了 172ms。

代码有亿点点长，就放[剪贴板](https://www.luogu.com.cn/paste/c9umdnj2)里了，想学卡常的可以看看。

## The End.

---

## 作者：Na2PtCl6 (赞：2)

这题的贪心做法很好想，相信大家都猜到了。

---

## 分析题目
贪心做法：

step 1:把物品从大到小进行排序；

step2:循环每个物品，找到背包容量 $\ge$ 这个物品的体积的背包中容量最小的背包并删除它，同时将总价值加上这个物品的价值。

证明：
对于 `step 1` ，因为我们希望取到的总价值最大，所以价值大的肯定要先拿。

对于 `step 2` ，因为我们要“勤俭持家”，为之后的物品留下更多空间

## 代码实现
用 std::multiset 实现维护背包
```cpp
#include<bits/stdc++.h>
#define msii multiset<int>::iterator
using namespace std;
const int maxn=300004;
int n,k;
long long res;
struct node{
	int m,v;
	bool operator < (const node &a){
		return v>a.v;
	}
}s[maxn];
multiset < int > c;

int read(){
	char f=0,c=getchar();int ret=0;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')
			f=1;
	for(;c>='0'&&c<='9';c=getchar())
		ret=(ret<<1)+(ret<<3)+(c^48);
	return f?-ret:ret;
}

int main(){
	n=read(),k=read();
	for(int i=0;i<n;i++)
		s[i].m=read(),s[i].v=read();
	sort(s,s+n);	
	for(int i=0;i<k;i++)
		c.insert(read());
	for(int i=0;i<n&&k>0;i++){
		msii it=c.lower_bound(s[i].m);
		if(it!=c.end()){
			--k;
			res+=s[i].v;
			c.erase(it);
		}
	}
	printf("%lld",res);
	return 0;
}
```

---

## 作者：毕瑞成 (赞：2)

难度：黄

做法：贪心

定义：$C_{k}$为第$k$个袋子的容量，$M_{i}$为第$i$个物品的质量，$V_{i}$是第$i$个物品的价值，袋子总数为$m$，物品总数为$n$

推导一：对于当前要装入袋子中的物品$i$，要装入$C_{k}$，如果有$C_{t}$满足$M_{i}\leq C_{t}<C_{k}$，则把$i$物品装入$t$袋子更优；如果有物品$j$满足$V_{j}>V_{i}$且$M_{j}\leq C_{k}$，则选$j$更优

对于两个$V$相等的值，需要先装$M$小的嘛？

显然是不需要的，假设当前两个值有不是最优解的，那么可以找到一个比它更优的解来替代。直至物品$i,j$都是袋子$k$最优解时，假设$V_{i}=V_{j}$且$M_{i}<M_{j}$。若最优解有$i,j$两个数（相对有$k$），则说明有两个袋子能够装下这两个物品，所以无需比较其$M$的大小；若最优解只包含其中一个，则$k$装的物品它产生的价值恒为$V$，所以不需要比较大小，如果都装不下，就违背了最优解的说法，所以不成立。

根据推导一，我们可以发现，对于当前解$i$，保证没有满足$V_{j}>V_{i}$的$j$就可以把它放进一个容量为$C_{k}$的袋子，并且不存在有$M_{i}<C_{t}<C_{k}$

我们考虑先按照$V$从大到小排序（手动保证当前操作的数$i$没有$j$满足$V_{j}>V_{i}$），对于当前物品，找到一个$k$满足不存在有$M_{i}<C_{t}<C_{k}$，即找到$M_{i}$的后继

我们可以维护$Set$/平衡树(因为$Set$好写所以就写$Set$了)

先讲袋子容量插入$Set$，再按照$V$讲物品排序，然后对于当前物品$i$，在$Set$中查找第一个质量大于等于$M_{i}$的袋子，如果有则删除次袋子并把$V_{i}$加入最终结果，没有的话就继续查找下一个袋子。

附代码：
```cpp
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include<cstdio>
#include<algorithm>
#include<set>
using namespace std;
const int maxn(3e5+5);
long long n,m,x;
long long ans=0;
struct node{ int w,v; }a[maxn];
multiset <int> s;
int read(){
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0' || ch>'9')	{if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9') {x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
bool cmp(node x,node y){ return x.v>y.v; }
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i].w=read(),a[i].v=read();
	for(int i=1;i<=m;i++) x=read(),s.insert(x);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		multiset<int>::iterator k=s.lower_bound(a[i].w);
		if(k!=s.end()) s.erase(k),ans+=a[i].v;	
	}
	printf("%lld\n",ans);
	return 0;
}
```
总结：这道题实现上还是比较水的，学贪心的朋友可以练练手，学平衡树和$Stl$朋友也可以写写代码，祝各位$AC$

（请不要帮助小偷！）

---

## 作者：lovely_fcukh (赞：1)

题意：  
有 $N$ 件物品，每件物品有质量 $M_i$ 和价值 $V_i$。给定 $K$ 个只能放一个物品且容量为 $C_i$ 的袋子，求最多可获得的价值。

思路：  
第一眼下去看起来很像一个 dp。但是看到每个袋子只能放一个物品时，就可以发现其实只是一道贪心。我们可以将物品价值由大到小先排个序，然后将所有背包的容量从小到大排个序，存入一个 multiset 的 $v$ 里。我们从 1 开始枚举每一个物品，二分找出最小可以装下这个物品的背包的下标。如果可以装下，将背包删掉，答案加上这个物品的价值。由于价值可能十分的大，所以我们要开 long long。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,c[300005],ans;
struct o{
	long long x,y;
}a[300005];
multiset<long long>v;
bool f(o x,o y){
	return x.y>y.y;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+1+n,f);
	for(int i=1;i<=k;i++)cin>>c[i];
	sort(c+1,c+1+k);
	for(int i=1;i<=k;i++)v.insert(c[i]);
	for(int i=1;i<=n&&k;i++){
		multiset<long long>::iterator x=v.lower_bound(a[i].x);
		if(x!=v.end()){
			k--;
			v.erase(x);
			ans+=a[i].y;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：听取MLE声一片 (赞：1)

本题主要思路为贪心，就是用最小的袋子装最大的物品，同时保证价值最大即可

首先，袋子和物品大小要先排列一下，用sort即可完成

然后是价值的存储问题，用一个优先队列即可

另外新创一个变量，表示正运行的袋子编号

sortf如果要逆序排列要新写一个cmp函数

注意：要把物品的数组的n+1定为inf

上代码：
```
#include<bits/stdc++.h>
using namespace std;
long long ans; 
int n,k,b=1,c[300001];
struct point{
	int m,v;
}a[300001];
priority_queue<int> s;
bool cmp(point x,point y){
	if(x.m==y.m)
		return x.v<y.v;
	return x.m<y.m;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i].m>>a[i].v;
	for(int i=1;i<=k;i++)
		cin>>c[i];
	sort(c+1,c+k+1);
	sort(a+1,a+n+1,cmp);
	a[n+1].m=2147483647;
	for(int i=1;i<=n+1;i++){
		while(a[i].m>c[b]){
			if(!s.empty())
				ans+=s.top(),s.pop();
			b++;
			if(b>k)
				break;
		}
		if(b>k)
			break;
		s.push(a[i].v);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：MC_Launcher (赞：0)

#### 两周没发题解了，~~来水一篇题解~~

题意:给你k个袋子,n个物品，分别有价值$V_i$和质量$W_i$，每个袋子只能装一个物品，问能装下的最大价值

很明显这玩意是贪心的策略，我先给大家提供一下思路：

先将袋子和物品从小到大排个序（物品按质量排），接着便利每个袋子，每次便利将能够装下都记录，找到最大的那个并标记。

给一个简单的证明（大佬勿喷）：

假如任意两个袋子所装的物品价值与重量都不同，那么每个袋子装的必定是其能装下的最大值，成立

假如两个袋子可以装重量相同的物品，那么用小的袋子装这个物品可以使大的袋子装更重的物品，可能价值会更高

那么怎么实现呢？暴力？

NO，NO，NO，暴搜复杂度$O(n^2)$，题目范围是在$10^5$以内，绝对TLE。

所以我们用一个优先队列(priority_queue)来实现

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct thing//物品 
{
	int m;//质量;
	int v;//价值
};
bool pai(thing a,thing b)
{
	return a.m<b.m;//定义thing结构体排序方式，按物品质量排序 
}
bool operator<(thing a,thing b)//重载thing结构体"<"运算符，按价值排 
{
	return a.v<b.v;
} 
priority_queue<thing>que; 
thing th[300002];//所有物品 
int bag[300002];//所有袋子 
int main()
{
	int n,k;//物品数量，袋子数量
	cin>>n>>k;//输入物品数量和袋子数量 
	long long ans=0;//记录答案 
	for(int i=0;i<n;i++)
	{
		cin>>th[i].m>>th[i].v;//获取物品质量和价值 
	}
	for(int i=0;i<k;i++)
	{
		cin>>bag[i];//获取袋子容量 
	}
	sort(th,th+n,pai);//将物品按重量从小到大排序 
	sort(bag,bag+k);//将袋子容量从小到大排序 
	int weizhi=0;//记录当前进队到第几个物品 
	for(int i=0;i<k;i++)//便利每个袋子
	{
		for(int j=weizhi;j<n;j++)//从上次入队的物品开始继续便利 
		{
			if(th[j].m<=bag[i])//如果能装下，则装进队列 
			{
				que.push(th[j]);
				weizhi++;//记录入队到第几个物品了 
			}
			else//装不下？由于按质量排序，所以接下来的也不行 
			{
				break;
			}
		}
		if(!que.empty())
		{
			ans+=que.top().v;//记录价值 
			que.pop();//出队 
		}
	} 
	cout<<ans;
}
```
#### 题解千万条，理解第一条。直接抄题解，棕名两行泪


---

## 作者：KadiaNEFU (赞：0)

一开始还真没想到用multiset，直到TLE几次后，才恍然大悟。
因为要不断是删除，所以用一个数组来二分的话是很复杂的 ~~（手撸dalao请忽略）~~ 所以我们用多元集合multiset会简单很多 ~~（stl真香）~~

**思路**

- 由于我们的袋子数量一定，且每个袋子最多装一个，那么我们就最多只能装走k个物品，于是我们**将所有物品按价格排个序，按照价值高的来拿** ~~(好坏呀!)~~ 。

- 对于每一个物品，我们要**选择一个最合适的袋子来装下它**，即在能装下它的前提下用一个容量最小的袋子，所以我们也需要对袋子排个序。

- 在查找最合适的袋子的时候我们**需要用的二分**，且袋子的容量可能会重复，**所以我们选择用multiset这个容器来装所有的袋子**，用去一个袋子就把它删去即可，直到所有的袋子用完或物品全部执行完。

- 注意！！！**开longlong  开longlong  开longlong**

```cpp
#include <bits/stdc++.h>

using namespace std;

struct _object
{
    int w;
    long long v;
}ob[300005];
bool cmp1(struct _object a,struct _object b)
{
    if(a.v!=b.v)
        return a.v>b.v;
    else
        return a.w<b.w;
}
int main()
{
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%lld",&ob[i].w,&ob[i].v);
    }
    multiset<long long>c;
    long long x;
    for(int i=1;i<=k;i++)
    {
        cin >> x;
        c.insert(x);
    }
    sort(ob+1,ob+1+n,cmp1);
    long long sum=0;
    int now=1;
    multiset<long long>::iterator it;
    while(c.size()&&now<=n)
    {
        it=c.lower_bound(ob[now].w);
        if(it!=c.end())
        {
            sum+=ob[now].v;
            c.erase(it);
        }
        now++;
    }
    printf("%lld\n",sum);
    return 0;
}
```





---


# [COCI 2010/2011 #7]  KUGLICE

## 题目背景

Mirko 和 Slavko 喜欢玩弹珠。 在一个激动人心的星期五，Mirko 发明了一个关于弹珠的游戏，他想向 Slavko 展示。

在游戏中，Mirko 构造了一个有向图，其中每个点出度不超过 $1$。然后他在其中一个点上放了一个弹珠，只要弹珠在某个顶点 $X$ 上，弹珠就会移动到由一条边连接的相邻顶点（没有就算了）。弹珠的运动一直持续到弹珠到达一个没有出度的点为止。弹珠也有可能因没有出度为 $0$ 的点而无限遍历图。为了确保 Slavko 能理解游戏规则，Mirko 会问一系列问题。

询问类型如下:

1. `1 X`：除非弹珠卡在一个循环，求弹珠被放在 $X$ 后最后的终止点序号。

2. `2 X`：删除顶点 $X$ 的出边。（保证存在）

注意：查询有序。

## 题目描述

给定一个有向图，其中每个点出度为 $0$ 或 $1$。

有如下询问：

1. `1 X`：给定弹珠起始点 $X$，求弹珠运动的终止点。

2. `2 X`：删除 $X$ 点出边。（保证存在）

弹珠运动规则：

从初始点沿着出边走直到一点出度为 $0$。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据 $1 \le n,Q \le 3 \times 10^5$。

#### 说明

本题满分 $120$ 分。

译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T5 KUGLICE。

## 样例 #1

### 输入

```
3
2 3 1
7
1 1
1 2
2 1
1 2
1 1
2 2
1 2```

### 输出

```
CIKLUS
CIKLUS
1
1
2```

## 样例 #2

### 输入

```
5
0 3 5 3 4
6
1 1
1 2
2 4
1 2
2 3
1 2```

### 输出

```
1
CIKLUS
4
3```

# 题解

## 作者：panxz2009 (赞：7)

## 解题思路
离线+并查集做法。

首先，如果没有删边的操作，那么这个有向图事实上只有两种可能，很简单，**有环**或**无环**。

对于**无环**的情况，注意到每个点出度为 $0$ 或 $1$，那么每个弹珠能到达的终止点全部相同，都是下图中的红色点。
![](https://cdn.luogu.com.cn/upload/image_hosting/k5lb47a8.png)
由上图中的遍历方式，容易想到**并查集的路径压缩**。对于**无环**的情况来说，只需要将相连的两条边加入同一个并查集里即可。  
对于**有环**的情况，
![](https://cdn.luogu.com.cn/upload/image_hosting/gy5p68ts.png)
其实与无环的情况类似，只不过在加入并查集的过程中，如果两个点已经在一个并查集中了，但还是要求合并，说明产生了环，此时只需把这个点的 `fa` 数组赋值为 $0$。

接下来考虑删边操作。考虑到离线，那么其实可以把询问顺序翻转，删边也就转换成了加边，那么加边的操作其实就与上述的并查集操作类似了。
## 代码
```cpp
#include<bits/stdc++.h>
#define pb push_back
#define pii pair<int,int>
#define mkp make_pair
#define ll long long
using namespace std;
const int maxn=3e5+10;
int n,Q,to[maxn],fa[maxn],ans[maxn];
bool t[maxn];
struct ask{int op,x;}ask[maxn];
int getfa(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=getfa(fa[x]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&to[i]);
		fa[i]=i;
	}
	scanf("%d",&Q);
	for(int i=1;i<=Q;i++)
	{
		scanf("%d%d",&ask[i].op,&ask[i].x);
		if(ask[i].op==2) t[ask[i].x]=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(t[i] || !to[i]) continue;
		int fx=getfa(i),fy=getfa(to[i]);
		if(fx!=fy) fa[fx]=fy;
		else fa[fx]=0;
	}
	for(int i=Q;i>=1;i--)
	{
		if(ask[i].op==1) ans[i]=getfa(ask[i].x);
		else
		{
			if(!to[ask[i].x]) continue;
			int fx=getfa(ask[i].x),fy=getfa(to[ask[i].x]);
			if(fx!=fy) fa[fx]=fy;
			else fa[fx]=0;
		}
	}
	for(int i=1;i<=Q;i++)
	{
		if(ask[i].op==1)
		{
			if(!ans[i]) puts("CIKLUS");
			else printf("%d\n",ans[i]);
		}
	}
    return 0;
}
```

---

## 作者：Piwry (赞：7)

## 解析

这里介绍几种在线做法（听[室友](https://www.luogu.com.cn/user/108047)讨论这个问题，于是就想了想qwq）

如果将图反向建边，则每个点最多只有一个入度；对于一个无环子图（其实它一定为树），其所有节点的答案即为该子图中没有父亲的结点，我们设该结点为根；对于一个有环子图（其实它一定为基环树），它是没有答案的

&nbsp;

现在考虑如何在删边后维护答案。

有一种方案是在某个子图变为树（或一开始就为树）时对它重链剖分建线段树，在删边时区间修改答案即可。但考虑在经过多次操作后，某个结点在**建线段树**时含有的子树可能已被分离出去，因此我们还需为每个结点记录它们所在树的根，在区间修改时，如果这个操作来自当前根之前的父亲，就不对答案做修改（但标记下传还是要的）

或者我们还可以考虑直接用 Splay 或 FHQ 维护，这样我们得为每个结点记录其子树的 dfs 序编号区间的右边界。但要注意这个右边界是可能失效的（含有右边界结点的子树被分离），所以我们考虑在分离区间时不查找和右边界编号相同的结点，而是查找最后一个小于等于右边界编号的结点（考虑 dfs 序的性质）

或着直接线段树分裂（估计要被卡空间）；因为在深入不存在的线段树结点时会直接返回，因此即使右边界结点所在子树缺失也不会出问题

又或者，可以考虑直接拿 lct 维护这个东西。由于 lct 支持查根操作，因此我们甚至不需要专门维护每个结点所在树的根，查询时 $\log n$ 回答即可

### lct 维护基环树

可以知道题目让我们维护的就是一个基环树

在加边时，

- 如果不形成环，直接连边

- 如果形成环，我们任选该边的一个结点作为根，并对所有结点开一个数组（设为 `ecir[]` ）记录这条多出来的边。本题根是指定（可以推出）的，那我们就把这条边的信息储存在连这条边前的根上

在删边时，

- 如果该边所在子图为树，直接断边

- 如果该边所在子图是基环树，我们分两种情况

1. 多余的边信息储存在该边的某个结点上；设该结点为 $x$，则有 `ecir[x] != 0`。我们直接将 `ecir[x]` 设为 `0` 即可

2. 多余的边信息不在该边的某个结点上。我们先找到该子图的 "根"，设为 `top`，可以知道 `ecir[top] != 0`（多余边信息储存在根上），然后再正常断边，判断 `top` 和 `ecir[top]` 是否连通。如果连通，则代表我们断掉了原来基环树的环，需要把这条多余的边 "接上"；否则只是从基环树上断下了一颗子树，不需要再做其它操作

连边删边时还需要注意对根的处理，因为基环树多出来的一条边信息储存在 "根" 上，我们不能把这个根丢掉。具体要看题目情况（对于树，有时不处理也可）

 _[参考](https://www.cnblogs.com/rir1715/p/8313181.html)，这道题应该也是内向基环树_

## CODE

这里仅给出 lct 做法的代码（我比较懒qaq）

```cpp
#include <cstdio>
//#pragma GCC target("avx")
//#pragma GCC optimize("Ofast")
//#pragma GCC optimize(2)

const int MAXN =3e5+50;

/*------------------------------LCT------------------------------*/

int c[2][MAXN], f[MAXN];
bool rev[MAXN], incircle[MAXN];

inline void pushdown(int x){
	if(rev[x]){
		rev[c[0][x]] ^=1, rev[c[1][x]] ^=1;
		c[0][x] ^=c[1][x] ^=c[0][x] ^=c[1][x];
		rev[x] =0;
	}
}

inline bool isroot(int x){ return (!(c[0][f[x]] == x || c[1][f[x]] == x) || f[x] == 0); }

inline bool get(int x){ return c[1][f[x]] == x; }

inline void rotate(int x){
	bool r =get(x), rf =get(f[x]);
	int y =f[x], z =f[y], a =c[!r][x];
	f[x] =z; if(!isroot(y)) c[rf][z] =x;
	f[y] =x, c[!r][x] =y;
	f[a] =y, c[r][y] =a;
}

inline void pushall(int x){
	if(!isroot(x)) pushall(f[x]);
	pushdown(x);
}

inline void splay(int x){
	pushall(x);
	for(; !isroot(x); rotate(x))
		if(!isroot(f[x])) rotate((get(f[x]) == get(x)) ? f[x] : x);
}

inline void access(int x){
	for(int pre =0; x; pre =x, x =f[x]){
		splay(x);
		c[1][x] =pre;
	}
}

inline void setroot(int x){
	access(x), splay(x);
	rev[x] =1;
}

inline int findroot(int x){
	access(x), splay(x);
	while(c[0][x]) x =c[0][x], pushdown(x);
	splay(x);
	return x;
}

/*连接后 y 作为 x 的父亲*/
inline void link(int x, int y){
	/*由题可得此时 x 为所在树的根*/
//	setroot(x);
	f[x] =y;
}

/*加了些操作，保留原来的根*/
inline void cut(int x, int y){
	int top =findroot(x);
	setroot(x), access(y);
	splay(x);
	c[1][x] =f[y] =0;
	setroot(top);
}

inline bool connected(int x, int y){
	access(x), splay(x);
	access(y), splay(y);
	return f[x] != 0;
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char cc =getchar(); bool ff =0;
	while(cc < '0' || cc > '9') (cc == '-') ? ff =1, cc =getchar() : cc =getchar();
	while(cc >= '0' && cc <= '9') x =(x<<3)+(x<<1)+(48^cc), cc =getchar();
	return (ff) ? -x : x;
}

int e[MAXN], ecir[MAXN];

int main(){
	int n =read();
	for(int i =1; i <= n; ++i){
		int v =read();
		e[i] =v;
		if(v != 0){
			if(connected(i, v))
				ecir[i] =v;/*由题可得此时 i 一定是所在树的根*/
			else
				link(i, v);
		}
	}
	int m =read();
	for(int i =0; i < m; ++i){
		int op =read(), x =read();
		if(op == 1){
			int top =findroot(x);
			if(ecir[top] != 0)
				puts("CIKLUS");
			else
				printf("%d\n", top);
		}
		else{
			if(ecir[x] != 0)
				ecir[x] =0;
			else{
				int top =findroot(x);
				cut(x, e[x]);
				if(ecir[top] != 0 && !connected(top, ecir[top])){
					link(top, ecir[top]);
					ecir[top] =0;
				}
			}
		}
	}
}
```

---

## 作者：JK_LOVER (赞：3)

## 题意
支持两种操作。

- 询问终止点的编号

- 删除一个点的边 [$QWQ$](https://www.luogu.com.cn/blog/xzc/solution-p6706)
## 分析

- 先不分析删边操作

每个点的出度非常的小 $\le 1$ 。那么这个图其实最复杂也就是个基环树森林。这使父亲关系相当简单，对于一个点也就三种情况。

- 在环上

- 指向儿子节点

- 叶子节点

后两种可以通过并查集维护，那么我们把在环上的点指向一个虚拟节点 $t$ 就可以了。

- 删边

一般的删边操作，其实如果没有 $LCT$ 这样的动态树维护其实是很难进行的。一般考虑将操作离线下来，反过来加边操作。这样这道题就做完了。时间复杂度为 $O(\alpha(n))$ 。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
const int N = 3e5+100;
struct Q{int opt,X;}St[N];
int top = 0,t,n;
int fa[N],vis[N],out[N],ans[N];
int find(int x){
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}
void merge(int x,int y){
	x = find(x);y = find(y);
	if(x == y){fa[x] = fa[y] = t;}
	else{fa[x] = fa[y];}
	return;
}
int main()
{
	n = read();t = n + 1;
	for(int i = 1;i <= n;i++)
	{
		out[i] = read();
		if(!out[i]) vis[i] = 1;
		fa[i] = i;
	}
	fa[t] = t;
	int T = read();
	for(int i = 1;i <= T;i++)
	{
		int opt = read(),X = read();
		if(opt == 2) vis[X] = 1;
		St[i] = (Q){opt,X};
	}
	for(int i = 1;i <= n;i++)
	{
		if(!vis[i]){merge(i,out[i]);} 
	}
	for(;T>=1;T--)
	{
		int opt = St[T].opt;
		if(opt == 2) {
			int x = St[T].X;
			merge(x,out[x]);
		}
		else {
			int x = find(St[T].X);
			ans[++top] = x;
		}
	}
	for(int i = top;i >= 1;i--) 
	ans[i]!=t?printf("%d\n",ans[i]):printf("CIKLUS\n");
	return 0;
}
```


---

## 作者：PanH (赞：2)

### 这是一个离线做法。

~~怎么在线啊，不会。。。~~

每个点最多一条出边，显然构成了一个存在**树**或**基环树**的森林。

设 $ans[i]$ 为小球从点 $i$ 出发时的答案（$0$ 为有环）。

首先观察一下，一棵基环树中所有点的 $ans$ 为 $0$ ，而对于树，每个点的 $ans$ 为根节点。

可是，这题存在删边的操作，删边可能使：

- 一棵树变成两棵树；

- 基环树变成树；

- 基环树变成基环树和树。

好像还挺麻烦的。于是，我们可以考虑反过来做。

当我们**把所有询问和修改离线，并按照时间从后往前枚举，删边就变成了加边！**

这样子题目就做完一大半了，我们只要考虑怎么维护每个点的答案。

~~剩下的部分应该不讲都可以了吧。~~

我们先把所有询问中要删的边删了，算出每棵树或基环树中的答案。

再用**并查集**维护每个点的答案。

从后往前扫询问和修改。对于询问直接从并查集里找答案；对于修改：

- 如果当前边的出发点（$u$）与终点（$v$）都在同一个集合中，说明该树变成了基环树，所以就可以 ```fa[find_fa(v)]=0```；

- 另一种情况就说明两棵树合并到了一起，直接 ```fa[find_fa(u)]=find_fa(v)``` 即可。

时间复杂度： $O(n+Q)$ 。~~其实还有并查集的的复杂度，但是就当一个常数吧，时间上还是挺宽裕的。~~

code：
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
template<class T>inline void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	while(!isdigit(ch))	f=ch=='-',ch=getchar();
	while(isdigit(ch))	x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=f?-x:x;
}
void write(int x)
{
	if(x>9)	write(x/10);
	putchar('0'+x%10);
}
const int N=3e5+5;
int fa[N],n,m,Fa[N],ans[N],head[N],cnt,Vis[N];
bool vis[N],asrt[N];
struct edge{
	int next,to;
}e[N<<1];
struct que{
	int op,X;
}q[N];
int find_fa(int x)	{return fa[x]==x?x:fa[x]=find_fa(fa[x]);}
void add(int u,int v)
{
	e[++cnt]={head[u],v};
	head[u]=cnt;
}
void dfs(int x,int Rt)//初始化每棵树的答案
{
	vis[x]=1,fa[find_fa(x)]=find_fa(Rt);
	for(int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(asrt[y]||vis[y])	continue;
		dfs(y,Rt);
	}
}
int main()
{
	read(n);
	for(int i=1;i<=n;i++)
	{
		read(Fa[i]),fa[i]=i;
		if(Fa[i])	add(Fa[i],i);
	}
	read(m);
	for(int i=1;i<=m;i++)
	{
		read(q[i].op),read(q[i].X);
		if(q[i].op==2)	asrt[q[i].X]=1;//对于需要删除的边，其实等价于给点打上标记。
	}
	for(int i=1,Rt=1;i<=n;i++,Rt=i)
		if(!vis[i])
		{
			while(!asrt[Rt]&&Fa[Rt])
			{
				Rt=Fa[Rt];
				if(Vis[Rt])	{fa[Rt]=0;break;}//判断一下存不存在环。
				Vis[Rt]=1;
			}
			dfs(Rt,Rt);
		}
	for(int i=m;i;i--)
		if(q[i].op==1)	ans[i]=find_fa(q[i].X);
		else
		{
			int u=find_fa(Fa[q[i].X]),v=find_fa(q[i].X);
			if(u==v)	fa[u]=0;
			else		fa[v]=u;
		}
	for(int i=1;i<=m;i++)
		if(q[i].op==1)
			if(ans[i])	write(ans[i]),putchar('\n');
			else		puts("CIKLUS");
	return 0;
}
```


---

## 作者：ycy1124 (赞：1)

### 题意
在一张每个节点的出度最多为 $1$ 的一张有向图上需要支持两种操作。

1. 查询从点 $x$ 开始一直沿着其出边走最终会到达哪个节点。如果在环内输出 `CIKLUS`。
2. 删除某个节点的出边。
### 思路
很套路的一道并查集。我们发现正着删边不好做，于是考虑倒着加边，我们先将所有的操作二的边删掉然后倒着遍历每个操作，这样子我们的操作二便会变成加入一条边。

我们考虑如何判断每个节点最终会到那里，我们可以将一个节点 $i$ 的 $to_i$ 设为自己的父亲，然后用并查集维护每个节点最早的祖先节点即可。考虑判环，由于每个点的出度最多为 $1$，所以不会存在有一条边从环内节点连向环外节点，只会有节点从环外连向环内。于是我们每次加入一条边的时候判断一下一条边的两个节点的祖先节点是否相同，如果相同说明他们在环内，只需要给他们的祖先节点打上一个标记即可。最后每次查询判断一下这个节点的祖先节点是否被打上标记，否则输出其祖先节点的编号即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define N 300000 + 39
#define flush() fwrite(obuf,1,O-obuf,stdout)
#define putchar(x) ((O==obuf+(1<<21))&&(flush(),O=obuf)),*O++=x
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
__inline__ int read(){
	register int x=0;
	register char ch=getchar();
	while(!(ch>='0'&&ch<='9'))
		ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+(ch^48),ch=getchar();
	return x;
}
__inline__ void write(register int x){
    (x>9)?write(x/10):void();
    putchar((x%10)^48);
}
struct Flush{
    ~Flush(){flush();}
}_;
using namespace std;
struct Node
{
	int op, x;
};
int f[N], to[N], n, p;
bool vis[N], Vis[N];
stack<int>ans;
stack<Node>q;
__inline__ int find(int x)//并查集查找祖先的操作
{
	return f[x] == x ? x : f[x] = find(f[x]);
}
__inline__ void hb(int x, int y)//这里的hb操作跟原始的并不一样。因为每个节点的出度为1所以x的祖先一定为x
{
	f[x] = y;
}
int main()
{
	n = read();
	for(int i = 1; i <= n; i ++)
	{
		to[i] = read();
		f[i] = i;
	}
	p = read();
	for(int i = 1; i <= p; i ++)
	{
		int op = read(), x = read();
		q.push({op, x});
		if(op == 2)
		{
			vis[x] = 1;//给被删除的边打上标记
		}
	}
	for(int i = 1; i <= n; i ++)
	{
		if(vis[i] || to[i] == 0)
		{
			continue;
		}
		if(i == find(to[i]))//判断
		{
			Vis[i] = 1;
		}
		else
		{
			hb(i, to[i]);
		}
	}
	while(q.size())
	{
		int op = q.top().op, x = q.top().x;
		q.pop();
		if(op == 2)//加边
		{
			if(x == find(to[x]))
			{
				Vis[x] = 1;
			}
			else
			{
				hb(x, to[x]);
			}
		}
		else
		{
			if(Vis[find(x)])//查询，-1表示在环内
			{
				ans.push(-1);
			}
			else
			{
				ans.push(find(x));
			}
		}
	}
	while(ans.size())//记得倒着输出答案
	{
		if(ans.top() == -1)
		{
			for(auto it : "CIKLUS")
			{
				putchar(it);
			}
		}
		else
		{
			write(ans.top());
		}
		putchar('\n');
		ans.pop();
	}
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/231574402)。

---

## 作者：VioletIsMyLove (赞：1)

首先第一个需要倒看，因为删边不好解决。再一个就是传球，
其实对于一个节点而言，就 $3$ 种情况，

$1$：叶节点。

$2$：在某条线路中。

$3$：在圈上。

对于 $1$ 和 $2$ 并查集没问题，我们可以通过并查集来实现的，就是让后者当祖先，这样就可以把球接住。对于 $3$ 我们把它引导到一个虚拟点上就OK了。

Code:

```cpp
#include<bits/stdc++.h>
#define maxn 300005
using namespace std;
int top,n,Q,fa[maxn],son[maxn],ans[maxn];
bool vis[maxn];
struct ZS{
	int flg,x;
}A[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return ret*f;
}
int Get(int x){return fa[x]==x?x:fa[x]=Get(fa[x]);}
void merge(int x,int y){
	int fx=Get(x),fy=Get(y);
	if (fx==fy) fa[fx]=fa[fy]=n+1;else fa[fx]=fy;
}
int main(){
	n=read();
	for (int i=1;i<=n;i++){
		son[i]=read();
		if(!son[i]) vis[i]=1;//真正的祖先，即最后接球那家伙，他没儿子节点所以不需要单独给他建图 
		fa[i]=i;
	}
	fa[n+1]=n+1;//虚拟的点，等下把有圈的都往这个虚拟点引导 
	Q=read();
	for (int i=1;i<=Q;i++){
		int flg=read(),x=read();
		if(flg==2) vis[x]=1;//等下倒建图用 
		A[i]=(ZS){flg,x};
	}
	for (int i=1;i<=n;i++)//先把没被干掉的边所构建的图搞出来 
	  if (!vis[i]) merge(i,son[i]);
	for (int i=Q;i>=1;i--)
	  if(A[i].flg==2) merge(A[i].x,son[A[i].x]);
	  else ans[++top]=Get(A[i].x);
	for (int i=top;i>=1;i--) ans[i]!=n+1?printf("%d\n",ans[i]):printf("CIKLUS\n");
	return 0;
}
```


---

## 作者：huhangqi (赞：0)

由于每一个节点最多只会连出一条边，所以一个连通的图必定是基环树或者树。

如果是基环树，那么一定会有环，且经过移动后必定在环内，直接按照有环的情况输出即可。

对于一颗树，我们可以将这一个节点连向的点视为父亲，那么最后的答案就是这棵树的根。

我们可以通过并查集来模拟建树的过程，但是拆树的过程并不好模拟，怎么办？

我们可以考虑离线操作，要拆掉的边先不连接，反过来处理就成为了建边的过程。

剩下的就是对并查集建树以及判断是否有环的简单运用了，这里就不过多说明了，可以自己看代码。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[300005],b[300005],fa[300005];
int find(int x){
	if(x==fa[x])return x;
	return fa[x]=find(fa[x]);
}
bool merge(int x,int y){
	y=find(y);
	if(y==x)return false;
	fa[x]=y;
	return true;
}
bool f[300005];
struct Q{
	int op,x,res;
}q[300005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)b[i]=a[i];
	cin>>m;
	for(int i=1;i<=m;i++)cin>>q[i].op>>q[i].x;
	for(int i=1;i<=m;i++){
		if(q[i].op==2){
			b[q[i].x]=0;
		}
	}
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=n;i++){
		if(!b[i])continue;
		if(!merge(i,b[i]))f[i]=1;
	}
	for(int i=m;i>=1;i--){
		if(q[i].op==1){
			int tmp=find(q[i].x);
			if(f[tmp])q[i].res=-1;
			else q[i].res=tmp;
		}
		else {
			if(!merge(q[i].x,a[q[i].x]))f[q[i].x]=1;
		}
	}
	for(int i=1;i<=m;i++){
		if(q[i].op==1){
			if(q[i].res==-1)puts("CIKLUS");
			else cout<<q[i].res<<endl;
		}
	}
	return 0;
}
``````

---

## 作者：koukilee (赞：0)

明显，此题正着很难维护，需要动态删边。

于是套路地考虑正难则反的做法。

先将所有查询离线，逆序循环，将删边的条件转化为加边。

***

考虑使用并查集动态维护这一过程。

钦定当前节点为 $x$，他的出点 $y=out[x]$。

如果 $x$ 与 $y$ 不在同一集合，将两个节点合并。

否则说明两个节点连起来一定构成一个环。

### Code 
```c++
i64 find (i64 x) noexcept {return x == s[x] ? x : s[x] = find (s[x]);}

inline void marge (i64 x, i64 y) noexcept {
	if (!x || !y) return;
	x = find (x), y = find (y);
	if (x != y) s[x] = y; else s[x] = 0;
}

int main() noexcept{
	read (n);
	for (i32 i = 1; i <= n; i++)
		read (out[i]), s[i] = i;
	read (q);
	for (i32 i = 1; i <= q; i++)
		read (opt[i].pos, opt[i].x), vis[opt[i].x] |= opt[i].pos == 2 ? 1 : 0;
	
	for (i32 i = 1; i <= n; i++){
		if (!vis[i])
			marge (i, out[i]);
	}
	
	for (i32 i = q; i; i--) {
		if (opt[i].pos == 1)
			Ans[i] =  find (opt[i].x);
		else
			marge (opt[i].x, out[opt[i].x]);
	}
	
	for (i32 i = 1; i <= q; i++)
		if (opt[i].pos == 1)
			if (Ans[i] == 0) puts ("CIKLUS");
			else put (Ans[i]);
    return 0;
}
```

---

## 作者：Iris_Aurora (赞：0)

发现删边操作很不好实现，考虑离线询问变成加边操作，

先把不删除的边加上，再倒序加边，并查集维护，设加入的边为 $(u,v)$，若 $u,v$ 在加边之前就属于同一个连通块了，那么就出现了环，把 $fa_u$ 设为 0，否则正常合并就行。

附上代码：

```cpp
#include<bits/stdc++.h>
#define FL(i,a,b) for(int i=(a);i<=(b);i++)
#define FR(i,a,b) for(int i=(a);i>=(b);i--)
#define ll long long
#define PII pair<int,int>
using namespace std;
const int MAXN = 3e5 + 10;
int n,q;
int a[MAXN],fa[MAXN],ans[MAXN];
PII b[MAXN];
bool del[MAXN];
int find(int x){
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
int main(){
	scanf("%d",&n);
	FL(i,1,n) fa[i]=i;
	FL(i,1,n) scanf("%d",&a[i]);
	scanf("%d",&q);
	FL(i,1,q) scanf("%d%d",&b[i].first,&b[i].second),del[b[i].second]|=(b[i].first==2);
	FL(i,1,n){
//		FL(i,1,n) printf("%d ",find(i));
//		puts("");
//		printf("del[%d]=%d\n",i,del[i]);
		if(!del[i]&&a[i]){
			int x=find(i),y=find(a[i]);
			if(x!=y) fa[x]=y;
			else fa[x]=0;
		}
	}
	FR(i,q,1){
//		FL(i,1,n) printf("%d ",find(i));
//		puts("");
		if(b[i].first==1) ans[i]=find(b[i].second);
		else{
			if(!a[b[i].second]) continue;
			int x=find(b[i].second),y=find(a[b[i].second]);
			if(x!=y) fa[x]=y;
			else fa[x]=0;
		}
	}
	FL(i,1,q){
		if(b[i].first==1){
			if(!ans[i]) puts("CIKLUS");
			else printf("%d\n",ans[i]);
		}
	}
}
```

---


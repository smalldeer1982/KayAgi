# [CEOI 2020] 花式围栏

## 题目背景

0.1s，32MB

## 题目描述

众所周知，Balázs 拥有整个城镇中最漂亮的围栏。围栏由 $N$ 个部分组成，每个部分均为矩形，且相邻的两个部分间均紧密相连。第 $i$ 部分矩形的高度为 $h_i$，宽度为 $w_i$，我们需要找到满足如下条件的花式矩形：

- 矩形的每条边均是水平的或竖直的，且每条边的长度为整数。
- 矩形与地面的距离为整数。
- 矩形与围栏第一部分的左侧边的距离为整数。
- 矩形完整包含在围栏中。

现在你需要求出花式矩形的总数。因为这个数字可能很大，请输出其对 $10^9+7$ 取模后的结果。

## 说明/提示

### 样例解释 1

围栏形状如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/o0w99om5.png)

形状如下的矩形有 $5$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/qvrh1vbs.png)

形状如下的矩形有 $3$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/hx15etpn.png)

形状如下的矩形有 $1$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/s01bhzfn.png)

形状如下的矩形有 $2$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/ee3kec7y.png)

形状如下的矩形有 $1$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/n26e8gyi.png)

### 样例 2

见附加文件。

### 子任务

所有测试点均满足：$1 \leq N \leq 10^5$，$1 \leq h_i,w_i \leq 10^9$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| $1$        | $0$  | 样例                                                         |
| $2$        | $12$ | $N \leq 50$，且 $\forall i \in [1,N]$，$h_i \leq 50$ 且 $w_i=1$ |
| $3$        | $13$ | $\forall i \in [1,N]$，$h_i=1$ 或 $h_i=2$                    |
| $4$        | $15$ | 所有的 $h_i$ 均相等                                          |
| $5$        | $15$ | $\forall i \in [1,N-1]$，$h_i \leq h_{i+1}$                  |
| $6$        | $18$ | $N \leq 1000$                                                |
| $7$        | $27$ | 无特殊约束                                                   |

## 样例 #1

### 输入

```
2
1 2
1 2```

### 输出

```
12```

# 题解

## 作者：Alex_Wei (赞：25)

> [题面传送门](https://www.luogu.com.cn/problem/P6801)。

> 题意简述：$n$ 个 $h_i\times w_i$ 的矩形从左往右排成一排，求出整个图形中共包含多少个小矩形。

---

看到题目，考虑维护一个**高度单调递增**的单调栈。

不妨设：
- 将当前要加入的矩形为 $a$，高度为 $h$。
- 单调栈栈顶矩形为 $x$，高度为 $h_1$，宽为 $w_1$。
- 单调栈栈顶前一个矩形为 $y$，高度为 $h_2$。

如果 $h_1\ge h$，那么将 $x$ 多余的高度 “削去”。具体而言，我们要将 $x$ 削到和「**$a,y$ 中高度较高的那个矩形**」一样高，即高度变为 $\max(h,h_2)$。

我们需要求出削去该矩形对答案的贡献，即求出「四边都落在 $x\ (h_1\times w_1)$ 内部（包括边界）且至少有一边落在被削去矩形 $((h_1-\max(h,h_2))\times w_1)$ 内部（**仅包括左，上，右边界**）」的矩形个数。

根据容斥原理，也就是求出「四边都落在 $x\ (h_1\times w_1)$ 内部（包括边界）」的矩形个数减去「四边都落在 $x$ 削去后剩下的矩形 $(\max(h,h_2)\times w_1)$ 内部（包括边界）」的矩形个数。

对于一个 $h\times w$ 的矩形，如何求出它包含了多少小矩形：因为任选两条横着的边，任选两条竖着的边，都能围成一个独一无二的小矩形，且一共有 $w+1$ 条横着的边，$h+1$ 条竖着的边，所以小矩形的个数为 $\binom{w+1}{2}\times\binom{h+1}{2}$。

需要注意考虑边界条件，可以适当在单调栈内添加矩形以避免特判。

根据上述思路，不难写出代码如下：

```cpp
stack <int> a,b;
int n,w[N],h[N],ans;

int calc(int x){return 1ll*x*(x+1)/2%mod;}
int main(){
	n=read(),a.push(-1);
	for(int i=1;i<=n;i++)h[i]=read(); 
	for(int i=1;i<=n;i++)w[i]=read();
	for(int i=1,s=0;i<=n+1;i++,s=0){
		while(h[i]<=a.top()){
			int hh=a.top(),ww=b.top(); a.pop(),b.pop(),s=(s+ww)%mod;
			ans=(ans+1ll*(calc(hh)-calc(max(h[i],a.top()))+mod)*calc(s))%mod;
		} a.push(h[i]),b.push((w[i]+s)%mod);
	} cout<<ans<<endl;
	return 0;
}
```

求赞 qwq。

---

## 作者：StudyingFather (赞：9)

考虑用单调栈维护高度单调递增的矩形。

现在假如我们需要将第 $i$ 个矩形插入单调栈中，如果该矩形比栈顶矩形高度更高则直接插入，否则我们需要将高出当前矩形的部分删除，并累加该部分的答案。

假如当前栈顶的矩形宽为 $w_p$，高为 $h_p$，栈顶下面的矩形宽为 $w_n$，高为 $h_n$，要插入的矩形宽为 $w_i$，高为 $h_i$。容易发现，我们需要将栈顶的矩形的高度降至 $\max(h_n,h_i)$ 才能不破坏单调性。

现在问题变成了如何计算被删除部分的贡献。

容易发现，这部分对答案的贡献为所有两个顶点落在被删除部分，其他两个顶点在被删除部分以外的矩形的个数。由容斥原理可知，答案即为栈顶矩形的子矩形个数，减去删除超高部分后的矩形的子矩形个数。

而根据组合数学知识可知，一个 $w \times h$ 的矩形，其子矩形个数为 $\dfrac{w \times (w+1)}{2} \times \dfrac{h \times (h+1)}{2}$。

就此问题得到解决。

```cpp
// Problem: P6801 [CEOI2020]花式围栏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6801
// Memory Limit: 32 MB
// Time Limit: 200 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <stack>
#define MOD 1000000007
using namespace std;
long long h[100005], w[100005];
stack<int> s;
long long C2(long long x) { return x * (x - 1) / 2 % MOD; }
int main() {
  int n;
  long long ans = 0;
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> h[i];
  for (int i = 1; i <= n; i++) cin >> w[i];
  s.push(0);
  for (int i = 1; i <= n + 1; i++) {
    int sw = 0;
    while (h[s.top()] > h[i]) {
      int u = s.top();
      s.pop();
      sw = (sw + w[u]) % MOD;
      ans = (ans +
             (C2(h[u] + 1) - C2(max(h[i], h[s.top()]) + 1)) * C2(sw + 1) % MOD +
             MOD) %
            MOD;
    }
    w[i] += sw;
    s.push(i);
  }
  cout << ans << endl;
  return 0;
}
```

---

## 作者：s_r_f (赞：9)

[我的CEOI作战记录&题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ceoi2020-zuo-zhan-ji-lu-ti-xie-shi-gong-zhong-post)

[我的CEOI作战记录&题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13581895.html)

记$f(x) = \frac{x(x+1)}{2}.$

不难发现答案为$\sum\limits_{i=1}^n f(w_i) * f(h_i)+\sum\limits_{1\leq l<r\leq n}  w_lw_rf(\min\limits_{i=l}^r(h_i))$

用单调栈优化即可$.$

代码$:$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 100050,P = 1e9 + 7;
int n,a[N],b[N],L[N],R[N],stk[N],_,ans;
inline bool cmp(int x,int y){ return a[x] == a[y] ? x < y : a[x] < a[y]; }
inline int F(int n){ return (LL)n * (n+1) / 2 % P; }
inline int calc(int l,int r){ return (b[r] - b[l-1] + P) % P; }
int main(){
	int i;
	cin >> n;
	for (i = 1; i <= n; ++i) cin >> a[i];
	for (i = 1; i <= n; ++i) cin >> b[i],b[i] = (b[i] + b[i-1]) % P;
	stk[_=1] = 1; for (i = 2; i <= n; ++i){ while (_ && cmp(i,stk[_])) R[stk[_]] = i-1,--_; stk[++_] = i; }
	while (_) R[stk[_]] = n,--_;
	stk[_=1] = n; for (i = n-1; i ; --i){ while (_ && cmp(i,stk[_])) L[stk[_]] = i+1,--_; stk[++_] = i; }
	while (_) L[stk[_]] = 1,--_;
	for (i = 1; i <= n; ++i){
		ans = (ans + (LL)F(calc(i,i)) * F(a[i]) % P) % P;
		ans = (ans + (LL)F(a[i]) * calc(L[i],i-1) % P * calc(i+1,R[i]) % P) % P;
		ans = (ans + (LL)F(a[i]) * calc(i,i) % P * calc(i+1,R[i]) % P) % P;
		ans = (ans + (LL)F(a[i]) * calc(L[i],i-1) % P * calc(i,i) % P) % P;
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：WorldBest丶牛顿 (赞：6)

# 写在前面
xdm写题目的时候如果要开 $long\;long$，记得把全部都改成 $long \;long$ 阿！！！  ——来自一个修了好半天代码只有12分的蒟蒻  

1. 本文不会出现$\sum$，因为我自己会被绕晕$qwq$  
2. 本文的举例会按输入格式表示，同时用（尽量偏暗的）色彩辅助理解  
3. 当然可能废话有点多，可以根据标题跳着看
4. 思路部分无代码，因为连贯性比较大，分开来我不太会讲，实在看不懂可以看看图

# 具体思路

题面用一句话来说，就是给一个图形，数其中的矩形个数  

### 标准的 x * y 矩形中包含的矩形个数

取出一个矩形，其实就是选择出连续的几行和连续的几列。  
行数为 $x$ 时，矩形的长度可以为 $1, 2 \ldots, x.$   
对于每种长度，根据起始行，不同的情况数为 $x, x - 1,\ldots,1.$   
相加后就是行数所占的所有不同的情况数：$\frac{(1 + x) * x}{2}$  
列数同理。那么包含的矩形个数就是  
$$f(x,y) = \frac{(1 + x) * x}{2} * \frac{(1 + y) * y}{2}$$

### 高度不同时数矩形的策略：容斥原理

看一个例子
```
input:
2
4 3
2 1
```
![](https://cdn.luogu.com.cn/upload/image_hosting/ow5fnkd8.png)

对于这个矩形，可以通过 $f(4,2)$（红+紫）$\;+\;$$f(3,3)$（紫+蓝）$\;-\;$$f(3,2)$（紫） 计算出总矩形个数  

不过写代码的时候直接使用容斥原理需要很多的加减法，很容易弄错，可以换一种思路理解这个式子：  
变换顺序为 $f(4,2) - f(3,2) + f(3,3)$  
$f(4,2)-f(3,2)$ 保证计算的矩形一定有红色（也就是红色部分对答案的贡献），接着我们就可以将红色部分从图形上剪去，余下$3*3$的蓝色和紫色部分直接用 $f(3,3)$ 计算  
 
这样，我们可以转化问题：**将一个图形，不断地剪去最高的连续最长矩形，剪去时计算他们的贡献并求和**  

(为了更好地理解这个东西，再来一个例子）
```
6
1 3 4 4 2 2
1 1 1 1 1 1
```
![](https://cdn.luogu.com.cn/upload/image_hosting/qrl7w8gj.png)

如图，每次计算包含红色的矩形个数并剪去它（紫色的部分是重复计算，需要减去）  
注意紫色部分的高度应该取峰两边的更大值，如图 $1$ 中左边高度为 $3 > 2$，图 $2$ 中右边高度更大为 $2>1$，这是为了只将突出的峰剪去，否则会导致重复计算

1. $ans += f(4,2) - f(3,2)$
2. $ans += f(3,3) - f(2,3)$
3. $ans += f(2,5) - f(1,5)$
4. $ans += f(1,6)$

最终 $ans = 81$

### 时间复杂度优化：单调栈 + 前缀和

因为 $1 \leq h_i \leq 10^9$，显然不能直接按高度循环（不过可以离散化后操作），我使用的是单调栈来优化  

#### 单调栈粗略介绍

单调栈的特征就是单调，以单调递增为例，栈中元素为$\{1,3,4\}$，下一个即将入栈的元素为 $2$，则先让 $4$ 和 $3$ 出栈，再使 $2$ 入栈，保证栈内元素的单调性

#### 单调栈在本题中的使用

由于每次都是剪去最高的部分，可以推想：  
1. 如果更高，那么可以直接入栈；
2. 如果一样高，那么可以和上一个矩形组成一个成宽的矩形，之后一起计算；
3. 如果更低，那么就会形成一个峰，这时需要不断地减去最高的部分，直到栈顶的矩形高度小于等于当前读入的矩形高度

#### 前缀和

对于相同高度的矩形，我们可以自然的将他们组合成更大的矩形，如上图 $2$ 中，高度为 $4$ 的矩形由第三块和第四块共同组成。在代码中，我们只需要用前缀和维护第三块和第四块矩形的宽度，就可以直接计算出
高度为 $4$ 的矩形长度

高度为 $3$ 同理，由二三四这三块组成。只要记录最前面（第二块）矩形入栈的位置，就可以直接计算出总宽度

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll mod = 1e9 + 7;
ll n, ans;
ll h[100001], w[100001], pre[100001];
//h是高度，w是宽度，pre是宽度的前缀和
stack<pair<ll, ll> > s;
//first是高度，second是第i个读入的矩形，配合宽度的前缀和可以将高度相等的矩形直接组合

ll cal(ll x, ll y)
{
	x %= mod; y %= mod;
	x = ((1 + x) * x % mod) * 500000004 % mod;//500000004是2关于膜1e9+7的乘法逆元
	y = ((1 + y) * y % mod) * 500000004 % mod;
	return x * y % mod;
}

int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i = 1; i <= n; ++i) cin >> h[i];
	for(int i = 1; i <= n; ++i)
	{
		cin >> w[i];
		pre[i] = pre[i - 1] + w[i];
	}
	ll tmp_h1, tmp_w1, tmp_h2;//这里，记得函数内开变量也要longlong
	for(int i = 1; i <= n; ++i)//此处代码压缩很严重
	{
		ll flag = i;//这个后面再说
		while(!s.empty() && h[i] < s.top().first)
		{
			//忘记判断栈空的话，会遇到段错误，而cpp是按从左至右顺序判断的
			//比较当前读入的矩形和栈顶矩形的高度
			flag = s.top().second;//后面再说
			tmp_h1 = s.top().first;//栈顶的矩形高度
			tmp_w1 = pre[i - 1] - pre[s.top().second - 1];
			s.pop();
			//当前读入的矩形还没有进栈，所以栈顶的矩形是第 i - 1 个读入的矩形
			//second是同高度的最前面的矩形入栈的位置
			
			tmp_h2 = h[i];//tmp_h2相当于需要减去的紫色部分的高度
			if(!s.empty()) tmp_h2 = max(s.top().first, h[i]);
			ans = (ans + cal(tmp_h1, tmp_w1) - cal(tmp_h2, tmp_w1) + mod) % mod;
			//这里记得与前后都进行比较，也要记得判断栈是否为空
		}
		if(s.empty()) s.push(make_pair(h[i], 1));
		else if(h[i] > s.top().first) s.push((make_pair(h[i], flag)));
		//如果栈空了，说明读入的矩形高度很低（或刚开始读入），但前面的矩形并不会悬空，所以从第一个格子开始数
		//如果栈没空，读入的矩形与栈顶高度相等，那么会自动组合，不用管
		//          读入的矩形比山顶矩形高，需要入栈，如果之前没有删去峰的话，同高度最前一块就是第i块
		//                                      如果之前删去了峰，说明前面还有同高度的矩形，用flag记录最前
	}
	while(!s.empty())//这个和循环里差不多，复制粘贴后改改就行
	{
		tmp_h1 = s.top().first;
		tmp_w1 = pre[n] - pre[s.top().second - 1];
		s.pop();
		if(!s.empty())
		{
			tmp_h2 = s.top().first;
			ans = (ans + cal(tmp_h1, tmp_w1) - cal(tmp_h2, tmp_w1) + mod) % mod;
		}
		else ans = (ans + cal(tmp_h1, tmp_w1)) % mod;
	}
	ans %= mod;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：big_news (赞：2)

提供一个傻做法，希望别被巨佬碾压...

[link](https://big-news.cn/2020/08/27/%E3%80%8C%E9%A2%98%E8%A7%A3%E3%80%8DFancy%20Fence/)

容易发现，一个长为 $N$ 宽为 $M$ 的矩形的合法子矩形的数量可以 $O(1)$ 算。具体来讲，设：
$$A=\dbinom{NM}{2}, B = M·\dbinom{N}{2},C=N·\dbinom{M}{2}$$ 
有该矩形的子矩形数量为： 
$$(A-B-C)/2+B+C$$
之所以要算的这么麻烦是为了去重...这个重复的问题考场上卡了我半小时/kk...

那么考虑对于每个 $h_i$ 拆开来算贡献。对于当前的高度 $h_i$ ，我们确定两个端点 $l_i$ 和 $r_i$，使得 $[l_i,r_i]$ 是极长的一段区间满足 $\min\limits_{l_i\le k\le r_i} h_k=h_i$，于是我们可以找到一个极大的矩形，然后就可以在这个矩形里面算答案了。

剩下的问题是考虑重复，即这个矩形下方存在一个 $h$ 更小的矩形（它应该是矮矮长长的这个样子），而它的贡献我们已经在前面算过了。我们强制令矩形的一个端点在这个矩形上方就好了。

于是就只剩下单调栈的复杂度了，总复杂度 $O(n)$。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<map>
using namespace std;

#define int long long // 惨痛经历

const int P = 1e9 + 7;
const int CN = 2e5 + 5;
const int i2 = 500000004;

int read(){
    int s = 0,ne = 1; char c = getchar();
    while(c < '0' || c > '9') ne = c == '-' ? -1 : 1, c = getchar();
    while(c >= '0' && c <= '9') s = (s << 1) + (s << 3) + c - '0', c = getchar();
    return s * ne;
}

int n, h[CN], w[CN], sum[CN], pr[CN], nt[CN], stk[CN], top = 0, ans = 0; 
map<int, bool> cal[CN];

int C(int x) {return (1ll * x * (x - 1) / 2ll) % P;}
int calc(int l, int a, int b){
    int ab = ((a - b) % P + P) % P;
    int rec = C(1ll * l * ab % P), t1 = C(ab), t2 = C(l);
    t1 = 1ll * t1 * l % P, t2 = 1ll * t2 * ab % P;
    rec = ((rec - t1 - t2) % P + P) % P, rec = 1ll * rec * i2 % P;
    rec = (rec + t1 + t2) % P;
    int t = C(l + 1); t = 1ll * t * b % P, t = 1ll * t * ab % P, t = (t + P) % P;
    return (rec + t) % P;
}

signed main()
{
    freopen("_in.in", "r", stdin);

    n = read();
    for(int i = 1; i <= n; i++) h[i] = read();
    for(int i = 1; i <= n; i++) w[i] = read(), sum[i] = (sum[i - 1] + w[i]) % P, ans = (1ll * w[i] * h[i] % P + ans) % P;

    stk[++top] = 1, pr[1] = 0;
    for(int i = 2; i <= n; i++){
        while(h[ stk[top] ] >= h[i]) top--;
        pr[i] = stk[top], stk[++top] = i;
    }
    stk[top = 1] = n + 1;
    for(int i = n; i; i--){
        while(h[ stk[top] ] >= h[i]) top--;
        nt[i] = stk[top], stk[++top] = i;
    }

    for(int i = 1; i <= n; i++){
        if(cal[ pr[i] ][ h[i] ]) continue; cal[ pr[i] ][ h[i] ] = true;
        int l = (sum[ nt[i] - 1 ] - sum[ pr[i] ] + P) % P, a = h[i], b = max(h[ pr[i] ], h[ nt[i] ]);
        ans = (ans + calc(l, a, b)) % P;
    }

    printf("%lld", ans);
}
```

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

一个由很多边长为 $1$ 的正方形组成的不规则图形，问该图形中有多少矩形。

### 题目分析

首先我们来看一个简单的例子：

![P6801-1](https://s21.ax1x.com/2024/04/24/pkClLu9.jpg)

$\hspace{3.7cm}\downarrow$

![P6801-2](https://s21.ax1x.com/2024/04/24/pkClOBR.jpg)

然后我们不妨按照矩形右上角的位置将其分类成若干个矩形区间，如下图：

![P6801-3](https://s21.ax1x.com/2024/04/24/pkClXH1.jpg)

不难发现，由于至多有 $n$ 个独立的高度，所以我们至多会分成 $n$ 块。于是问题就转换成了我们要快速计算右上角在一个矩形范围内的矩形个数。

我们先考虑简单化这个问题，不妨先考虑一个 $w \times h$ 的矩形里有多少个矩形。

对于这个问题，我们只需要不重复的枚举矩形左右界和上下界 $1 \le l \le r \le w, 1\le d\le u\le h$，共有 $\dfrac{w \times (w+1)}{2} \times \dfrac{h\times (h+1)}{2}$ 个矩形。

然后再考虑右上角在高 $h_1\sim h_2$，宽 $l\sim r$ 的矩形中的矩形个数。由于左下角可能在 $1\sim h2$，所以我们考虑容斥，即高 $1\sim h_2$，宽 $l\sim r$ 中的矩形个数减去高 $1\sim h_1$，宽 $l\sim r$ 中的矩形个数。即个数为：

$$\dfrac{h_2\times(h_2 + 1)}{2} \times \dfrac{(r-l+1)\times(r-l+2)}{2}-\dfrac{h_1\times(h_1 + 1)}{2} \times \dfrac{(r-l+1)\times(r-l+2)}{2}$$

即

$$(\dfrac{h_2\times(h_2 + 1)-h_1\times(h_1+1)}{2}) \times \dfrac{(r-l+1)\times(r-l+2)}{2}$$

然后考虑如何分离出所有矩形区域。这里可以使用类似单调栈的东西，如果新增一个矩形时，前面的矩形比当前矩形高，则把前面矩形比这个矩形高的那部分分离出来（因为这部分已经与后面断开，后面的矩形对此无影响），最后再按照高度将剩下的矩形区域分出即可。

时间复杂度 $\mathcal O(n)$。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#define int long long

using namespace std;

const int N = 1e5 + 5, MOD = 1e9 + 7;
int n, h[N], w[N], ans;
deque <int> q;

int solve(int hmx, int hmn, int len)
{
	return ((hmx * (hmx+1) - hmn * (hmn+1)) / 2) % MOD * (len * (len+1) / 2 % MOD) % MOD;
}

signed main()
{
	scanf("%lld", &n);
	for(int i = 1;i <= n;i++)
		scanf("%lld", &h[i]);
	for(int i = 1;i <= n;i++)
		scanf("%lld", &w[i]);
	for(int i = 1;i <= n;i++)
	{
		int sum = 0;
		while(!q.empty() && h[q.back()] > h[i])
		{
			int j = q.back();
			q.pop_back();
			(w[i] += w[j]) %= MOD, (sum += w[j]) %= MOD;
			(ans += solve(h[j], q.empty() ? h[i] : max(h[q.back()], h[i]), sum)) %= MOD;
		}
		q.push_back(i);
	}
	int sum = 0;
	while(!q.empty())
	{
		int j = q.back();
		q.pop_back();
		(sum += w[j]) %= MOD;
		(ans += solve(h[j], q.empty() ? 0 : h[q.back()], sum)) %= MOD;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：LiJoQiao (赞：1)

[更好的阅读体验](https://www.cnblogs.com/LiJoQiao/p/18085908)  

本题解中不区别长度和宽度的区别，它们在本题解中指的是同一个东西。  
本题解做法用到单调栈。  

看这个特殊性质好像是让我们在高度上进行研究一下。  

子任务 $4$ 的特殊性质是想让你搞明白在一个矩形中如何计算其内部的矩形个数。  

下面是一个  $4\times 5$ 大小的矩形。   
![](https://cdn.luogu.com.cn/upload/image_hosting/reu7oz6t.png)  

先来不考虑高度的影响，我们观察任一行的单位矩形，来统计该行的矩形。  
这样的问题可以看成是一条线段让你截出若干个不同的线段，每个格子相当于一个点，我们统计合法的左右端点对数即可。  
第 $1$ 个格子作为左端点可以有第 $1$，$2$，$\dots$，$5$ 个格子作为右端点与其匹配。  
第 $2$ 个格子则有 $2$，$\dots$，$5$。  
以此类推，设该行的长度为 $w$，我们可以在该行中找出 $\sum\limits_{i=1}^wi=\frac{w\times(w+1)}{2}$ 个矩形。  
接着我们来考虑高度的影响，高度上与长度是独立的，设这个矩形的高为 $h$，长度为 $w$，容易发现这个矩形内有 $\sum\limits_{i=1}^{w}i \times \sum\limits_{i=1}^{h}i=\frac{w\times(w+1)\times h\times (h+1)}{4}$。  

我们可以将这些矩形先看作一个整体，按照高度划分成若干的矩形进行统计。类似于下图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/jcwu6hrh.png)  

这样我们维护一个单调栈，栈里面存放的是一个若干递增的矩形的整体，当遇到一个比栈中最高的矩形要矮的矩形时或最后的时候进行出栈统计。  
这里的划分是指在维护过程中切掉突出的那一块，并将答案更新，使得最后的结果正确。  
不可以只计算突出的部分内部的矩形个数，会少一些突出部分与下面一些部分结合的矩形。  
可以采用容斥的方法计算，我这里把容斥剩余的部分给推了一下放代码里面，与直接容斥写法不同。  

注意 `long long` 和取模的问题。  

代码如下。  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr int MAXN=1e5+10,MOD=1e9+7,inv2=500000004;
int n,h[MAXN],w[MAXN];
ll sum[MAXN],ans;
int s[MAXN],p;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&h[i]);//高度
    }
    for(int i=1;i<=n;++i){
        scanf("%d",&w[i]);//宽度
        sum[i]=sum[i-1]+w[i];
    }
    for(int i=1;i<=n;++i){
        while(p&&h[i]<h[s[p]]){
            if(h[s[p-1]]>=h[i]){
                ans=(ans+
                ((((((sum[i-1]-sum[s[p]-1])%MOD)*
                    ((sum[i-1]-sum[s[p]-1]+1)%MOD))%MOD)*inv2)%MOD)*
                (((((((ll)h[s[p]]-h[s[p-1]])%MOD)*
                    (((ll)h[s[p]]+h[s[p-1]]+1)%MOD))%MOD)*inv2)%MOD)%MOD
                )%MOD;
                --p;
            }
            else{
                ans=(ans+
                ((((((sum[i-1]-sum[s[p]-1])%MOD)*
                    ((sum[i-1]-sum[s[p]-1]+1)%MOD))%MOD)*inv2)%MOD)*
                (((((((ll)h[s[p]]-h[i])%MOD)*
                    (((ll)h[s[p]]+h[i]+1)%MOD))%MOD)*inv2)%MOD)%MOD
                )%MOD;
                h[s[p]]=h[i];
            }
        }
        if(!p||h[i]>h[s[p]]){s[++p]=i;}
    }
    while(p){
        ans=(ans+
            ((((((sum[n]-sum[s[p]-1])%MOD)*
                ((sum[n]-sum[s[p]-1]+1)%MOD))%MOD)*inv2)%MOD)*
            (((((((ll)h[s[p]]-h[s[p-1]])%MOD)*
                (((ll)h[s[p]]+h[s[p-1]]+1)%MOD))%MOD)*inv2)%MOD)%MOD
            )%MOD;
        --p;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：1)

又没有我的做法，感觉要好想一点，还是记录一下吧。

考虑通过每个矩形右边界的位置来计数，依次加入每个围栏时就累加右边界在此围栏内的矩形数。

然后可以发现随着上边界的递减，左边界可以取的位置递增，如图，每个红色的位置表示上边界与左边界的交点：

![](https://cdn.luogu.com.cn/upload/image_hosting/ghig1qd3.png)

就是单调栈的形式，而下边界怎么取都可以，如果每次计算长为 1 的围栏部分就可以简单的计数了。

但由于有宽度，要整块的计数，直接算可能不好看。

考虑用右边界在此围栏内的所有矩形减去有部分在围栏外的矩形数来得到所求的。

所有矩形的计算只与当前围栏大小有关，可以简单算到。

有部分在围栏外的矩形随着上边界的递减，左边界可以取的位置递减，下图蓝色部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/v179loc9.png)

还是单调栈，下边界仍然随便取。

然后写个单调栈维护蓝色部分的数量和即可，具体计算可以看代码。

要注意的是：上边界对应的下边界之和是个公差为 1 的等差数列，计算所有矩形时右边界对应的左边界也是这样。

核心代码：

```cpp
for(i=1;i<=n;i++)
{
	for(;top&&ht[stk[top]]>=ht[i];top--)
	{//单调栈
		s1=Md((LL)(ht[stk[top-1]]+1+ht[stk[top]])*(ht[stk[top]]-ht[stk[top-1]])>>1);
		Add(sm,Mod-Ml(s1,wt[stk[top-1]]));
	}wt[stk[++top]=i]=Ad(wt[i-1],w=read());//宽度前缀和
	s1=Md((LL)(ht[stk[top-1]]+1+ht[stk[top]])*(ht[stk[top]]-ht[stk[top-1]])>>1);//等差数列
	Add(sm,Ml(s1,wt[stk[top-1]]));//围栏外的矩形数
	s1=Md((LL)(ht[i]+1)*ht[i]>>1);s2=Ml(Ml(wt[i-1]+1+wt[i],w),Inv2);//所有矩形：等差数列
	Add(ans,Ad(Ml(s1,s2),Mod-Ml(sm,w)));//整块计数
}writenum(ans,10);
```

---

## 作者：yxy666 (赞：1)

我们先一点一点分析一下题目。一个高度为H,宽度为1的柱子的方案数是$(H+1)$$*$$H/2$ 。因为 $1*1$ 的有 $H$ 个， $2*1$ 的有 $H-1$ 个， $1*H$ 的有 $1$ 个，那就是$(1+2+···+H)$ 。同理，高为 $1$ ，宽为 $W$ 的柱子就是$(W+1)*W/2$。那么高为 $H$ ,宽为 $W$ 的柱子方案数就是 $H*(H+1)/2*W*(W+1)/2$ 。

我们需要维护的就是单调上升的一个栈。因为只有比之前高，才对答案有共贡献。如果有一个比较矮的，那我们就可以算出之前的方案数了啊。先把最高的给削下来，再削第二高的，然后所有高度统一了，那就可以算出整个大块的方案数了。宽度通过后缀和的方式给求出来就好了。高度我们已经知道了吗。那就比较好求了。注意：有些地方记得要 $%TT$ 。

$code$ :
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
const int TT=1000000007;
int n,q[maxn],tot;
long long ans,h[maxn],w[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读
long long C(long long x){return (x*(x+1)/2)%TT;}//计算方案数
int main(){
	n=read();
	for(int i=1;i<=n;i++)h[i]=read();
	for(int i=1;i<=n;i++)w[i]=read();
	q[++tot]=0;
	for(int i=1;i<=n+1;i++){//因为最后一个不一定是最矮的，所有要往后搞一位
		long long s=0;
		while(h[q[tot]]>h[i]){
			int now=q[tot--];
			s=(s+w[now])%TT;//宽的后缀和
			ans=(ans+(C(h[now])-C(max(h[i],h[q[tot]])))*C(s)%TT)%TT;//计算方案数
		}
		w[i]=(w[i]+s)%TT;
		q[++tot]=i;
	}
	printf("%lld\n",ans);
	return 0;
} 
```


---

## 作者：wlzhouzhuan (赞：1)

对一个长方形内的贡献，长有 $\frac{w_i(w_i+1)}{2}$ 种，宽有 $\frac{h_i(h_i+1)}{2}$ 种，令 $gao(i)=\frac{i\times (i+1)}{2}$ ，则贡献为 $gao(w_i)\times gao(h_i)$ 。

考虑第 $i$ 个长方形和第 $j$ 个长方形之间的贡献，显然是 $gao(\min\limits_{k=i}^{j} h_k) \times w_i\times w_j$ ，这一步可以用单调栈计算。

总时间复杂度 $O(n)$ 。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define rep(i,l,r) for(rint i=l;i<=r;i++)
#define per(i,l,r) for(rint i=l;i>=r;i--)
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pb push_back
#define fir first
#define sec second
template<typename T1,typename T2>void ckmin(T1 &a,T2 b){if(a>b)a=b;}
template<typename T1,typename T2>void ckmax(T1 &a,T2 b){if(a<b)a=b;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
int read(){
  int x=0,f=0;
  char ch=getchar();
  while(!isdigit(ch))f|=ch=='-',ch=getchar();
  while(isdigit(ch))x=10*x+ch-'0',ch=getchar();
  return f?-x:x;
}
const int N=100005;
const int mod=1e9+7;
ll stk[N],tp;
ll h[N],w[N],pre[N];
int n;
ll ans=0,vals=0;
ll gao(ll x){
  return 1ll*x*(x+1)/2%mod;
}
int main(){
  //freopen("input1.txt","r",stdin);
  n=read();
  for(int i=1;i<=n;i++)h[i]=read();
  for(int i=1;i<=n;i++)w[i]=read(),pre[i]=(pre[i-1]+w[i])%mod;
  for(int i=1;i<=n;i++)ans=(ans+gao(w[i])*gao(h[i]))%mod;
  for(int j=1;j<=n;j++){
    while(tp>0&&h[stk[tp]]>=h[j]){
      vals=(vals-1ll*(pre[stk[tp]]-pre[stk[tp-1]])*gao(h[stk[tp]])%mod)%mod;
      tp--;
    }
    stk[++tp]=j;
    vals=(vals+1ll*(pre[stk[tp]]-pre[stk[tp-1]])*gao(h[j])%mod)%mod;
    ans=(ans+1ll*(vals-1ll*gao(h[j])*w[j]%mod)%mod*w[j])%mod;
  }
  ans=(ans%mod+mod)%mod;
  printf("%lld\n",ans);
  return 0;
}
```

---

## 作者：NATO (赞：0)

提供一种比较好想的做法。

### 思路浅析：

考虑当高度为 $1$ 的时候一个极长连续矩形的贡献。设其长度为 $m$，容易想到即是 $\frac{m(m-1)}{2}$，即是这个矩形的每一个只包含完整矩形的子段的数量。

然后我们把高度加上。

与宽度类似的，可以考虑到宽度为 $1$ 时，高度为 $n$ 的贡献即为 $\frac{n(n-1)}{2}$。

那么一个高度为 $n$，宽度为 $m$ 的矩形贡献即为 $\frac{n(n-1)m(m-1)}{4}$。

考虑如何统计答案。

容易想到扫描线，考虑从上往下扫，因为极长连续矩形的合并只可能在某个矩形的高度最高的位置发生，所以我们只需要按高度排个序，扫一扫，并查集简单维护一下极长连续矩形的长度及对应贡献即可。

注意由于当前的极长连续矩形的贡献在小于当前高度的位置仍然有贡献的，所以要一次算完从当前高度到底的贡献，所以维护的时候每次都是计算的新增矩形的总贡献。

时间复杂度瓶颈在于排序，$O(n\log n)$，但常数很小，所以能过。

#### 参考代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MOD 1000000007
using namespace std;
const ll inv2=500000004;
ll n;
ll ans=0,res=0;
ll f[100005],sz[100005];
struct px
{
	ll h,w,uid;
	bool operator<(const px&b)const
	{
		return (w^b.w?w>b.w:uid<b.uid);
	}
}a[100005],b[100005];
ll find(ll x)
{
	return (x==f[x]?x:f[x]=find(f[x]));
}
void merge(ll a,ll b)
{
	ll fa=find(a),fb=find(b);
	f[fb]=fa;
	res-=sz[fa]*(sz[fa]+1)%MOD*inv2%MOD;
	res=(res%MOD+MOD)%MOD;
	res-=sz[fb]*(sz[fb]+1)%MOD*inv2%MOD;
	res=(res%MOD+MOD)%MOD;
	sz[fa]+=sz[fb];
	sz[fa]%=MOD;
	res+=sz[fa]*(sz[fa]+1)%MOD*inv2%MOD;
	res%=MOD;
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	for(ll i=1;i<=n;++i)cin>>a[i].h,f[i]=i;
	for(ll i=1;i<=n;++i)cin>>a[i].w,a[i].uid=i,swap(a[i].h,a[i].w),b[i]=a[i],sz[i]=a[i].h;
	++n;f[n]=n;
	sort(a+1,a+1+n);
	ll lres=0;
	ll st=1;
	for(ll i=2;i<=n;++i)
	{
		if(a[i].w!=a[i-1].w)
		{
			for(ll j=st;j<i;++j)
			{
				res+=sz[a[j].uid]*(sz[a[j].uid]+1)%MOD*inv2%MOD;
				res%=MOD;
				if(b[a[j].uid-1].w>=a[j].w)merge(a[j].uid,a[j].uid-1);
				if(b[a[j].uid+1].w>a[j].w)merge(a[j].uid,a[j].uid+1);
			}
			ans=(ans+((res-lres)%MOD+MOD)%MOD*a[i-1].w%MOD*(a[i-1].w+1)%MOD*inv2%MOD)%MOD;
			st=i;lres=res;
		}
	}
	cout<<ans;
}
```

---


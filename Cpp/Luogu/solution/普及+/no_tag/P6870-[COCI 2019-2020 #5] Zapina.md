# [COCI 2019/2020 #5] Zapina

## 题目描述

有 $n$ 个**不同的**人和 $n$ 道**不同的**题。

第 $i$ 个人开心当且仅当他被分配到 $i$ 道题。

求让至少一个人开心的分配方案数。

## 说明/提示

### 数据范围

**本题捆绑测试。**

- 对于 $22$ pts 的数据，$2\leq n\leq 7$。
- 对于另外 $33$ pts 的数据，$1\leq n\leq 20$。
- 对于所有的数据，$1\leq n\leq 350$。

### 样例 #2 解释

有以下 $3$ 种方案：

- 第一题给第一个人，第二题给第二个人。

- 第二题给第一个人，第一题给第二个人。

- 两题都给第二个人。

### 说明

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T5 Zapina_** ，译者 [90693](/user/90693)。

## 样例 #1

### 输入

```
1
```

### 输出

```
1```

## 样例 #2

### 输入

```
2
```

### 输出

```
3```

## 样例 #3

### 输入

```
314
```

### 输出

```
192940893```

# 题解

## 作者：_•́へ•́╬_ (赞：23)

## 题意

有 $n$ 个**不同的**人和 $n$ 道**不同的**题。

第 $i$ 个人开心当且仅当他被分配到 $i$ 道题。

求让至少一个人开心的分配方案数。

## 思路

显然 dp。

设 $f(i,j)$ 表示前 $i$ 个人分配 $j$ 道题且至少已经有一个人开心的方案数。

考虑转移：

- 使 $i$ 开心：随便給他 $i$ 道，剩下 $j-i$ 道随便分給剩下的 $i-1$ 个人。
  方案数：$C(j,i)\times (i-1)^{j-i}$。
  
- 使 $i$ 不开心：随便給他 $k$ 道，剩下 $j-k$ 道給 $i-1$ 个人并使这 $i-1$ 个人中有人开心。
  方案数：$C(j,k)\times f(i-1,j-k)$。

官方题解也是这种思路。

## $code$

```cpp
#include<stdio.h>
#define N 351
#define mod 1000000007
int n,c[N][N],ans[N][N];
inline int ksm(long long a,int b)
{
	long long ans=1;
	for(;b;b>>=1,a*=a,a%=mod)if(b&1)ans*=a,ans%=mod;
	return ans;
}
main()
{
	scanf("%d",&n);
	for(int i=0;i<=n;++i)
	{
		c[i][0]=c[i][i]=1;
		for(int j=1;j<i;++j)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}
	ans[1][1]=1;
	for(int i=2;i<=n;++i)for(int j=1;j<=n;++j)
	{
		if(j>=i)ans[i][j]=1ll*c[j][i]*ksm(i-1,j-i)%mod;//使i开心
		for(int k=0;k<=j;++k)if(i!=k)//使i不开心
			ans[i][j]=(ans[i][j]+1ll*ans[i-1][j-k]*c[j][k])%mod;
	}
	printf("%d",ans[n][n]);
}
```



---

## 作者：封禁用户 (赞：17)

### 前置芝士：容斥原理

![容斥原理](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jcHBibG9nLmNvbS9pbWFnZXMvY3BwYmxvZ19jb20vdmljaS8wMDAucG5n?x-oss-process=image/format,png)

简记为：奇加偶减。

### 分析：

一道裸的计数 DP 题。

记 $dp_{i,j,k}$ 为前 $i$ 个人中，已经分配了 $j$ 道题，恰好使 $k$ 个人满足的方案数。

容易发现 $dp_{1,0,0}=1$。

有两组决策，让 $i$ 满足或者不让 $i$ 满足。

$dp_{i+1,j+i,k+1} = dp_{i+1,j+i,k+1} + dp_{i,j,k} \times \binom{n-j}{i}$。

$dp_{i+1,j,k} = dp_{i+1,j,k} + dp_{i,j,k}$。

根据容斥原理，最后的答案为，$\sum\limits_{j=1}^n\sum\limits_{k=1}^n (-1)^{k+1} \times dp_{n,j,k}$。

时间复杂度: $O(n^3)$。

空间复杂度：$O(n^3)$。

注意这样会爆空间，应采用滚动数组进行优化。

优化后空间复杂度：$O(n^2)$。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(register T &x)
{
	register T p = 1,num = 0;
	char c = getchar();
	while(c < '0'||c > '9')
	{
		if(c == '-') p = -1;
		c = getchar();
	}
	while('0' <= c&&c <= '9')
	{
		num = (num<<3)+(num<<1)+(c^48);
		c = getchar();
	}
	x = p * num;
}
template<typename T>inline void write(register T x)
{
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) write(x/10);
	putchar(x%10^48);
}
#define F(i,a,b) for(register int i=a;i<=b;++i)
#define D(i,a,b) for(register int i=b;i>=a;--i)
#define ll long long
#define N 355
const int mod = 1e9 + 7;
int n;
ll fac[N],inv[N],pw[N],ans = 0;
inline ll qp(ll x,int y)
{
	ll ret = 1;
	while(y)
	{
		if(y & 1) ret = ret * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ret;
}
ll dp[2][N][N];
int main()
{	
	read(n);
	inv[0] = inv[1] = fac[0] = fac[1] = pw[0] = 1;
	F(i,2,n) fac[i] = fac[i-1] * i % mod;
	F(i,2,n) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
	F(i,2,n) inv[i] = inv[i] * inv[i-1] % mod;
	dp[1][0][0] = 1;
	F(i,1,n)
	{
		memset(dp[i+1&1],0,sizeof(dp[i+1&1])); 
		F(j,0,n)
			F(k,0,n)
			{
				if(j+i <= n) dp[i+1&1][j+i][k+1] = (dp[i+1&1][j+i][k+1] + dp[i&1][j][k]*fac[n-j]%mod*inv[n-j-i]%mod*inv[i]) % mod;
				dp[i+1&1][j][k] = (dp[i+1&1][j][k] + dp[i&1][j][k]) % mod;
			}
	}
	F(j,1,n)
		F(k,1,n)
		{
			dp[n+1&1][j][k] = dp[n+1&1][j][k] * qp(n-k,n-j) % mod;
			if(k & 1) ans = (ans + dp[n+1&1][j][k]) % mod;
			else ans = (ans - dp[n+1&1][j][k] + mod) % mod;
		}
	write(ans);
	return 0;
}
```
### 最后

可以发现，输入只有 $n$ 一个数，又是一道打表好题。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans[]={0,1,3,16,147,1756,25910,453594,9184091,211075288,427652759,380254172,88525330,594308696,594582617,496808516,230533631,930048563,734906046,145824550,963104287,792576272,20842121,926710860,624063170,435324673,941196758,100412345,829823320,16604011,119246612,467453588,296507940,19474275,437566401,580597104,325614134,114081039,16970316,54942632,953074343,664503025,963474561,463988230,901088598,552316694,370315853,363024430,361814615,987969955,356909604,72317551,362905861,844210242,74494960,267374090,9829229,80574666,190779497,993501688,667880842,25921000,891056540,820027654,988133379,860424629,164712123,638551214,64068242,852828384,594849040,713709588,713810843,796807000,639934368,445930895,853650080,686849288,687485088,204732826,938270531,233180167,680119887,798575300,221191668,719754542,183970632,65159363,102009420,106900582,603406815,547850988,69043888,441404069,178108361,171613595,194519530,846734478,733143650,732291535,534460323,424030598,293484626,18815201,585676643,912726223,510270289,151012819,929291571,529049185,117076206,900078971,614777735,348106199,423774249,574430766,526570315,748176803,31818969,501560666,705499512,806457493,862367692,255090341,812275285,136149440,140879753,956968322,984467061,121221372,826702704,995609955,640463338,795423206,438017231,104878010,715195281,87713761,472145514,512444087,528010597,448216404,715864432,365209471,998258892,47038284,945845611,742836670,874752539,351178973,115572999,85498210,750445820,566986136,507422951,263280651,363746668,721379342,657233523,368070024,365517137,557356212,405385770,702731018,726524565,582672271,713823066,172539263,452254713,108837529,685050929,112599223,950160771,537791717,196634339,765215429,723039551,992336331,495498388,734598160,166618212,690246061,613497507,91548173,34919956,30705717,150505766,252695495,997416620,426419436,299460599,841765395,170108584,130185332,573662799,620823933,366877355,870627156,903422770,826307196,361255220,710936088,447319974,885230522,664999650,227183665,35153803,597619983,251027027,953802478,83703267,961654121,351763496,571777475,19373724,564323159,525846126,988983101,113976315,976654852,957177092,547018849,207894228,385473127,401477473,894388178,414921794,285963181,179455247,584525294,721286723,628695619,608638999,599226595,806938357,465644549,296878851,573944747,201107705,585546352,487718852,205357994,277758478,969139685,461220859,461004882,132504633,615131412,824346063,924255686,759290174,358422542,635725603,176609609,917792915,257455569,746184536,316402317,783793186,500434871,517428456,451399654,409643100,482863842,176126614,820640574,657068590,362058002,242650619,186901373,515265982,89328722,942695111,540996271,90622012,138665430,818615553,784975850,417957865,721662199,737792977,495770091,951382091,316267089,374149589,284673490,916782568,790954001,602629711,531192034,664953974,624778690,283568537,34602368,376162450,10239950,812647987,99619518,509861236,256514260,341204270,899013232,614243782,535500022,518807185,472039848,306389369,965790287,155402774,825826404,381603778,307185930,856889200,248603369,192940893,25534731,193328908,438514397,782463496,892910780,686315937,919983254,111131855,299340566,255665989,470190823,983178320,961595576,279565492,63447508,69379637,540261561,887203349,350550553,701031556,754173085,251426123,533498405,443766626,741119012,897485842,708580238,529660266,493526336,813446619,453474512,927471565,937547684,981739148,653129658,688023819};
int main()
{	
	scanf("%d",&n);
	printf("%d",ans[n]);
	return 0;
}

```




---

## 作者：JK_LOVER (赞：8)

# 分析
要求出，至少一个人满足合法。那么我发现这个比较难考虑。那么正难则反。我们可以考虑求出有多少不合法的方案，用总方案减去就可以了。那么总方案为 $n^n$ 。而对于不合法的方案我们可以考虑 $dp$ 求解。定义 $f_{i,j}$ 为，考虑前 $i$ 个人，一共花费了 $j$ 到题的不合法方案。那么我们有转移 $f_{i,j} = \sum_{k\le i} f_{i-1,j-k}\times {j\choose k}$ ，那么总的时间复杂度为 $O(n^3)$ 。[更差的阅读体验](https://www.luogu.com.cn/blog/xzc/solution-p6870) 。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
#define ll long long
int ksm(int a,int b) {
	int x = 1;for(;b;b>>=1,a=a*1ll*a%mod){
		if(b&1)x=1ll*x*a%mod;
	}return x;
}
const int N = 400,M = 350;
#define pii pair<int,int>
int fac[N],ifac[N],f[N][N],n;
int C(int a,int b) {return fac[a] *1ll* ifac[b] % mod *1ll* ifac[a - b] % mod;}
int main() {
	scanf("%d",&n);
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*1ll*i%mod;
	ifac[n]=ksm(fac[n],mod-2);
	for(int i=n-1;i>=0;i--)ifac[i]=ifac[i+1]*1ll*(i+1)%mod;
	f[0][0] = 1;
	for(int i = 1;i <= n;i++) {
		for(int j = 0;j <= n;j++) {
			for(int k = 0;k <= j;k++) {
				if(k == i) continue; 
				f[i][j] += 1ll*f[i - 1][j - k] * C(j,k) % mod;
				f[i][j] %= mod;	
			}
		}
	}
	cout << (ksm(n,n) - f[n][n] + mod) % mod << endl;
}	
```


---

## 作者：Leasier (赞：3)

本题解省略部分分做法以及代码。

正难则反。总方案为 $n^n$，考虑不合法方案数。

设 $dp_{i, j}$ 表示前 $i$ 个人已经分配了 $j$ 道题，则答案为 $n^n - dp_{n, n}$。

边界条件：$dp_{0, 0} = 1$，此时只有一种方案为什么也不分配。

状态转移：对于 $dp_{i, j}$，考虑第 $i - 1$ 个人分配到的题目数量。若 $0 \leq k \leq j$ 且 $j - k \neq i$，则需考虑其贡献。由于题目**不同**，所以考虑从余下的 $n - k$ 道题中为第 $i$ 个人选择 $j - k$ 道题。即：$dp_{i, j} = \displaystyle\sum_{k = 0}^j dp_{i - 1, k} \times C_{n - k}^{j - k}$。时间复杂度为 $O(n^3)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int mod = 1e9 + 7;
ll fac[357], inv_fac[357], dp[357][357];

inline ll quick_pow(ll x, ll p, ll mod){
	ll ans = 1;
	while (p){
		if (p & 1) ans = ans * x % mod;
		x = x * x % mod;
		p >>= 1;
	}
	return ans;
}

inline void init(int n){
	fac[0] = 1;
	for (register int i = 1; i <= n; i++){
		fac[i] = fac[i - 1] * i % mod;
	}
	inv_fac[n] = quick_pow(fac[n], mod - 2, mod);
	for (register int i = n - 1; i >= 0; i--){
		inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
	}
}

inline ll comb(ll n, ll m, ll mod){
	if (m > n) return 0;
	if (m == 0) return 1;
	return fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod;
}

int main(){
	int n;
	scanf("%d", &n);
	init(n);
	dp[0][0] = 1;
	for (register int i = 1; i <= n; i++){
		for (register int j = 0; j <= n; j++){
			for (register int k = 0; k <= j; k++){
				if (j - k != i){
					dp[i][j] = (dp[i][j] + dp[i - 1][k] * comb(n - k, j - k, mod) % mod) % mod;
				}
			}
		}
	}
	printf("%lld", ((quick_pow(n, n, mod) - dp[n][n]) % mod + mod) % mod);
	return 0;
}
```

---

## 作者：lyt_awa (赞：2)

## 思路
题目要求的是**至少一个人**开心的分配方案数，所以可以先求**没有一个人**开心的分配方案数，再用总数减去就是答案了。

很容易想到一个 dp 状态：

$dp(i, j)$ 表示前 $i$ 个人已经分配了 $j$ 道题使每个人都不开心的方案数。

然后是转移，对于 $dp(i, j)$ 考虑 $dp(i-1, k)_{(j- k\ne i)}$ 可以将这 $j-k$ 道题都给 $i$ 就可以使每一个人都不开心了。转移方程：

$dp(i, j)= \sum_{j-k\ne i} dp(i-1,k) \times C_{n-k}^{j-k}$

## $code$
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=1e9+7;
int n;
ll dp[405][405],c[405][405],ans;
ll quick_power(ll x,ll y)
{
	ll res=1;
	for (;y;y=y>>1,x=(x*x)%mod)
	{
		if (y&1)  res=(res*x)%mod;
	}
	return res;
}

void init(){
	dp[0][0]=1;
	for (int i=0;i<=n;i++)c[i][0]=c[i][i]=1;
	for(int i=2;i<=n;i++)
		for(int j=1;j<i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; 
}

int main()
{
	cin>>n;
	init();
	for (int i=1;i<=n;i++)
		for (int j=0;j<=n;j++)
			for (int k=0;k<=j;k++)
				if (j-k!=i)  dp[i][j]=(dp[i][j]+dp[i-1][k]*c[n-k][j-k])%mod;

	ans=((quick_power(n,n)-dp[n][n])%mod+mod)%mod;
	cout<<ans<<endl;
	
	return 0;
}
```
时间复杂度 $O(n^{3})$。

---

## 作者：Kelier_pkl (赞：2)

# P6870 Zapina 题解

## 题目大意

有 $n$ 个不同的人和 $n$ 道**不同**的题。

第 $i$ 个人开心**当且仅当**他被分配到 $i$ 道题。

求让**至少一个人开心**的分配方案数。

## 解析

我们会发现正着求解比较难。

所以我们可以用**反面计数**。

通过计算可得总方案为 $n^n$，所以答案就为 $n^n$ 减去不合法的方案总数。

那么接下来的就简单了。

状态设计：设 $dp_{i,j}$ 表示看前 $i$ 个人，已经分给他们 $j$ 道题的不合法方案数。

所以，答案就为 $n^n-dp_{n,n}$。

接下来，我们考虑一下状态转移。

对于每一个 $dp_{i,j}$，我们首先考虑第 $i-1$ 个人对 $dp_{i,j}$ 的贡献：对于每一个 $0 \leq k \leq j$ 且 $j-k \neq i$ 的 $k$，那么 $dp_{i-1,k}$ 就会对 $dp_{i,j}$ 有贡献。

根据题目具体分析，我们会发现在每一个 $dp_{i-1,k}$ 更新 $dp_{i,j}$ 的时候，剩下的 $j-k$ 道题目没有计算进去。

根据题目可知这 $j-k$ 道题目要从剩下的 $n-k$ 个人中选，有 $C_{n-k}^{j-k}$ 种选法。

所以，状态转移方程就的出来了：

$dp_{i,j}=\sum\limits_{k=0}^{j} [j-k \neq i] dp_{i,j} \times C_{n-k}^{j-k}$

草草计算一下时间复杂程度：$O(n^3)$。

能过了。

不过我们还是得优化一下：计算组合数字会涉及到除法，然而除法不能边乘边取余，得先乘再除最后取余。

所以我们还得用上[逆元](https://oi-wiki.org/math/number-theory/inverse/)，避免爆 long long。

## Code

```cpp
//the code is from pkl
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
#define MAXN 355
#define mod 1000000007
LL n,ans;
LL dp[MAXN][MAXN]={1};
LL inv[MAXN]={1,1},jc[MAXN]={1};
LL binpow(LL a,LL b){
	LL res=1;
    while(b){
        if(b&1)	res=(res*a)%mod;
        b>>=1;
        a=(a*a)%mod;
    }
    return res;
}//快速幂
void init(){//预处理 
	for(LL i=1;i<=n;i++){
		jc[i]=(jc[i-1]*i)%mod;
	}//预处理阶乘 
	for(LL i=2;i<=n;i++){
		inv[i]=((mod-mod/i)*inv[mod%i])%mod;
	}//每一个数的逆元 
	for(LL i=1;i<=n;i++){
		inv[i]=inv[i-1]*inv[i]%mod;
	}//每一个阶乘的逆元 
}
LL C(LL n,LL r){//组合数计算 
	return jc[n]%mod*inv[r]%mod*inv[n-r]%mod;
}
int main(){
	scanf("%lld",&n);
	init();
	for(LL i=1;i<=n;i++){
		for(LL j=0;j<=n;j++){
			for(LL k=0;k<=j;k++){
				if(j-k!=i){//状态转移 
					dp[i][j]=(dp[i][j]+dp[i-1][k]*C(n-k,j-k)%mod)%mod;
				}
			}
		}
	}
	ans=((binpow(n,n)-dp[n][n])%mod+mod)%mod;
	printf("%lld",ans);
}
```

---

## 作者：Supor__Shoep (赞：1)

一眼 DP 题。

首先看到这道题，感觉设 $dp_{i,j}$ 表示前 $i$ 个人分配 $j$ 道题且满足条件的做法有点恶心，利用动态规划中一种牛逼的思路，考虑到设 $dp_{i,j}$ 表示前 $i$ 个人分配 $j$ 道题并且没有人开心的方案数，输出答案时用 $n^n-dp_{n,n}$ 就可以了。

从转移入手，由于 $n$ 很小，所以放心大胆三重循环。枚举一个 $k$，表示 $i,j$ 的答案由 $i,k$ 转移。为了使第 $i$ 个人不会分配到第 $i$ 的题，显然得到条件判断 $j-k≠i$。接着选剩下的题，由于题互不相同，就想到用组合，在剩下的 $n-k$ 个题当中选择 $j-k$ 道题，也就是 $C_{n-k}^{j-k}$。所以转移方程为：

$$dp_{i,j}=\sum_{k=0}^{j}[i≠j-k]~dp_{i-1,k}\times C_{n-k}^{j-k}$$

注意取模就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=405;
void read(int &x)
{
	x=0;
	short flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')	flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	x*=flag;
}
const int MOD=1e9+7;
long long dp[MAXN][MAXN],C[MAXN][MAXN];//处理一个组合数组
int n;
long long quick_pow(int x,int y)//快速幂
{
	long long ans=1,sum=1ll*x;
	while(y)
	{
		if(y&1)	ans=ans*sum%MOD;
		sum=sum*sum%MOD;
		y>>=1;
	}
	return ans;
}
int main()
{
	read(n);
	C[0][0]=dp[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		C[i][0]=C[i][i]=1;
		for(int j=1;j<i;j++)	C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=n;j++)
		{
			for(int k=0;k<=j;k++)
			{
				if(i==j-k)	continue;
				dp[i][j]=(dp[i][j]+dp[i-1][k]*C[n-k][j-k]%MOD)%MOD;//取模！！
			}
		}
	}
	cout<<(quick_pow(n,n)-dp[n][n]+MOD)%MOD;//答案
	return 0;
}
```

---

## 作者：Tx_Lcy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P6870)
## 思路
简单的 DP，但是初始化较为恶心。

不妨设 $f_{i,j,0/1}$ 表示前 $i$ 个人，已经分配了 $j$ 道题目，是否有至少一个人开心的方案数。

接下来我们枚举 $k$，若 $j-k=i$，显然的，此时的方案不可能非法，所以 $f_{i,j,1}=(f_{i-1,k,0}+f_{i-1,k,1}) \times (_{j-k}^{n-k})$。若 $j-k ≠ i$，则当前枚举的这个值无法改变合法/不合法状态，所以 $f_{i,j,1}=f_{i-1,k,1} \times (_{j-k}^{n-k})$，$f_{i,j,0}=f_{i-1,k,0} \times (_{j-k}^{n-k})$。

初始值需要直接把所有 $i=1$ 的情况预处理出来，则 $f_{1,j,0/1}=(_{j}^{n})$。其中 $0/1$ 情况视 $j$ 是否为 $1$ 而定。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int const N=4e2+5;
int f[N][N][2],fac[N],c[N][N];
int const mod=1e9+7;
inline int C(int n,int m){return c[n][m];}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int n;cin>>n;
    for (int i=0;i<=n;++i){
        c[i][1]=c[i][i]=1;
        for (int j=0;j<i;++j) c[i][j]=c[i-1][j]+c[i-1][j-1],c[i][j]%=mod;
    }
    for (int i=0;i<=n;++i) f[1][i][(i==1)]=C(n,i);
    for (int i=1;i<=n;++i)
        for (int j=0;j<=n;++j){
            for (int k=0;k<=j;++k){
                if ((j-k)^i){
                    f[i][j][0]+=f[i-1][k][0]*C(n-k,j-k)%mod;
                    f[i][j][0]%=mod;
                    f[i][j][1]+=f[i-1][k][1]*C(n-k,j-k)%mod;
                    f[i][j][1]%=mod;
                }else{
                    f[i][j][1]+=f[i-1][k][1]*C(n-k,j-k)%mod+f[i-1][k][0]*C(n-k,j-k)%mod;
                    f[i][j][1]%=mod;
                }
            }
        }
    cout<<f[n][n][1]<<'\n';
    return 0;
}
```


---

## 作者：Emp7iness (赞：1)

设 $dp[i][j]$ 表示给前 $i$ 个人分配 $j$ 道题让至少一个人开心的分配方案数。

假设第 $i$ 个人开心：在 $j$ 道题中分配 $i$ 道题给他，再将剩下的 $j-i$ 道题任意分配给其他 $i-1$ 个人，方案总数即为 $C(j,i) \times (i-1)^{j-i}$（其中 $C$ 表示组合数）。

假设第 $i$ 个人不开心：在 $0$ 到 $j$ 中任选一个数 $k$，分配 $k$ 道题给他，再将剩下的 $j-k$ 道题分配给其他 $i-1$ 个人，使其他 $i-1$ 个人中有人开心，方案总数即为 $\sum_{k=0}^j C(j,k) \times dp[i-1][j-k]$（注意此时 $k$ 不能等于 $i$，不然就变成第一种情况了）。

$dp[i][j]$ 的值即为上面两种情况的方案数量之和。

代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long
const int N=355,M=1e9+7;
int n,c[N][N],f[N][N];
int qpow(int a,int b)
{
	int s=1;
	while(b)
	{
		if(b&1)	s=s*a%M;
		a=a*a%M;
		b>>=1;
	}
	return s;
}
signed main()
{
	cin>>n;
	c[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=i;j++)	c[i][j]=(c[i-1][j]+c[i-1][j-1])%M;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i<=j)	f[i][j]=c[j][i]*qpow(i-1,j-i)%M;
			for(int k=0;k<=j;k++)
			{
				if(k!=i)	f[i][j]=(f[i][j]+c[j][k]*f[i-1][j-k])%M;
			}
		}
	}
	cout<<f[n][n];
	return 0;
}
```

---


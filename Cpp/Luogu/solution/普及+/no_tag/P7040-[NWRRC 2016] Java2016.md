# [NWRRC 2016] Java2016

## 题目描述

John 喜欢学习晦涩的编程语言。最近他发现了概率编程语言 Java2K。Java2K 的内置函数只有一定的概率能够执行你想让它们做的事情。

Java2K 编程非常困难，所以 John 设计了一种更简单的语言用于训练：Java2016。Java2016 的内置运算符是确定性的，而它们的操作数是随机的。在 Java2016 中，每个值都是范围在 $0 \cdots 255$ 之间的正整数。

Java2016 支持三种优先级的六个运算符：

$$
\begin{aligned}
{\langle \mathrm{expression}\rangle}&\quad::=\quad{\langle \mathrm{expression}\rangle}\operatorname{`\texttt{min}\text'}{\langle \mathrm{sum}\rangle}\mid{\langle \mathrm{expression}\rangle}\operatorname{`\texttt{max}\text'}{\langle \mathrm{sum}\rangle}\mid {\langle \mathrm{sum}\rangle}\\
{\langle \mathrm{sum}\rangle}&\quad::=\quad{\langle \mathrm{sum}\rangle}\operatorname{`\texttt{+}\text'}{\langle \mathrm{term}\rangle}\mid{\langle \mathrm{sum}\rangle}\operatorname{`\texttt{-}\text'}{\langle \mathrm{term}\rangle}\mid{\langle \mathrm{term}\rangle}\\
{\langle \mathrm{term}\rangle}&\quad::=\quad{\langle \mathrm{term}\rangle}\operatorname{`\texttt{*}\text'}{\langle \mathrm{factor}\rangle}\mid {\langle \mathrm{term}\rangle}\operatorname{`\texttt{\/}\text'}{\langle \mathrm{factor}\rangle}\mid {\langle \mathrm{factor}\rangle}\\
{\langle \mathrm{factor}\rangle}&\quad::=\quad\operatorname{`\texttt{(}\text'}{\langle \mathrm{expression}\rangle}\operatorname{`\texttt{)}\text'}\mid `\texttt{?}\text'\mid {\langle \mathrm{macro}\rangle}
\end{aligned}
$$

最小值（`min`）和最大值（`max`）运算符的定义与通常相同。加法（`+`）、减法（`-`）和乘法（`*`）的定义是模 $256$。除法（`/`）的结果向零取整。如果除数为零，程序崩溃。运算符的参数是另一个运算符的结果、均匀分布的随机值（`?`）或宏替换。

例如，`?/?/?` 被评估为零的概率是 $98.2\%$，而崩溃的概率是 $0.8\%$。

Java2016 程序由零个或多个宏定义组成，后跟结果表达式。每个宏定义的形式为：

$$
\begin{aligned}
{\langle \mathrm{macrodef}\rangle}&\quad::=\quad{\langle \mathrm{macro}\rangle}\operatorname{`\texttt{=}\text'}{\langle \mathrm{expression}\rangle}\\
{\langle \mathrm{macro}\rangle}&\quad::=\quad\operatorname{`\texttt{a}\text'}\ldots\operatorname{`\texttt{z}\text'}
\end{aligned}
$$

宏应该在第一次使用之前定义。它不能被重新定义。宏在每次使用时扩展为其定义。例如，

```plain
a = ? max ?
(a max $a) / a
```

被扩展为 `((? max ?) max (? max ?)) / (? max ?)`。

John 打算向 Java2016 添加概率常量，因此对于每个可能的常量值，他需要一个程序，该程序能够以至少一半的概率成功评估为该值。崩溃被计入失败。

## 说明/提示

时间限制：2 秒，内存限制：512 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
0
```

### 输出

```
? /?/ ?
```

## 样例 #2

### 输入

```
1
```

### 输出

```
a = ? max ?
(a max a) / a
```

# 题解

## 作者：panyf (赞：10)

构造。

对很多个 ？ 取 $\max$ 得到的值有很大概率为 $255$，用 $255$ 除以 $255$ 就可以得到 $1$。

用 $2^k$ 和 $2^k$ 相加可以得到 $2^{k+1}$，因此用 $1$ 可以得到 $2$ 的幂次。

将 $c$ 转成二进制，用 $2$ 的幂次相加即可。

注意特判 $0$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int i,c;
	bool f=0;
	scanf("%d",&c),puts("a=? max ?"),c=c?c:256;
	for(i=0;i<10;++i)printf("%c=%c max %c\n",'a'+i+1,'a'+i,'a'+i);
	puts("l=k/j");
	for(i=0;i<10;++i)printf("%c=%c+%c\n",'l'+i+1,'l'+i,'l'+i);
	for(i=0;i<10;++i)if(c&(1<<i)){
		if(f)putchar('+');
		putchar('l'+i),f=1;
	}
	return 0;
}
```

---

## 作者：晴空一鹤 (赞：3)

~~好神奇的语言~~

### Solution

一眼构造题，然后发现只要能凑出 $1$ 就可以了。

为什么？有了 $1$，我们就可以用形如 $b=a+a$ 之类的语句造出二进制下任意位置的 $1$，而对于要求的数，直接二进制拆分再加起来即可。

至于如何凑出 $1$？ 可知一个数除以自己本身结果为 $1$，只要这个数不为 $0$，于是我们多取几次 $\max$ 就可以了。

最后，特判一下 $0$，其实就是样例输出。

#### CODE

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll c;
void inline r(ll &x)
{
	x=0;
	char c=getchar();
	while(c<'0'||c>'9')
	c=getchar();
	while(c<='9'&&c>='0')
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
}
int main()
{
	r(c);
	if(c==0)
	{
	cout<<"?/?/?\n";
	return 0;
	}
	cout<<"a=? max ?\n";
	cout<<"b=a max a\n";
    cout<<"k=b max b max b max b max b\n";
    cout<<"t=k max k max k max k max k max k max k max k max k max k max k max k\n";
    cout<<"u=t max t max t max t max t max t max t\n";
	cout<<"c=u / u\n";
	cout<<"d=c+c\n";
	cout<<"e=d+d\n";
	cout<<"f=e+e\n";
	cout<<"g=f+f\n";
	cout<<"h=g+g\n";
	cout<<"i=h+h\n";
	cout<<"j=i+i\n";
	if((c&1)){
	cout<<"c";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=1;
	}
	if((c&2)){
	cout<<"d";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=2;
	}
	if((c&4)){
	cout<<"e";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=4;
	}
	if((c&8)){
	cout<<"f";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=8;
	}
	if((c&16)){
	cout<<"g";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=16;
	}
	if((c&32)){
	cout<<"h";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=32;
	}
	if((c&64)){
	cout<<"i";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=64;
	}
	if((c&128)){
	cout<<"j";
	if(c-(c&(-c))!=0)
	cout<<"+",c-=128;
	}
}
```

---


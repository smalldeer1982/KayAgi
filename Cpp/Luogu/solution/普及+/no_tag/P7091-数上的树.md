# 数上的树

## 题目背景

**本题自动开启 O2 优化，时间限制 2s。**

## 题目描述

您需要构造一棵二叉树，根节点权值为 $n$，每个节点都有 $2$ 个或 $0$ 个儿子，且满足如下限制：

若该点有两个儿子，该点权值需等于两个儿子的权值之积。

若该点没有儿子，则该节点权值需为质数。

同时会给出 $m$ 条限制 $a_i$，表示树上的权值不能出现 $a_i$。

您构造的二叉树需要使：令 $k$ 为节点数， $\sum\limits_{i=1}^k\sum\limits_{j=i}^kval_{lca(i,j)}$ 最小，其中 $val_i$ 表示第 $i$ 个点的权值，$lca(i,j)$ 表示 $i,j$ 的最近公共祖先。

## 说明/提示

样例解释：

样例 $1$：最优方案如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/2dcec565.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

其中，黑色数字代表权值，红色数字代表标号（您不需要对树标号，这里的标号只是为了更方便解释样例）。

$ans=val_{lca(1,1)}+val_{lca(1,2)}+val_{lca(1,3)}+val_{lca(2,2)}+val_{lca(2,3)}+val_{lca(3,3)}$

$~~~~~~~~=val_1+val_1+val_1+val_2+val_1+val_3$

$~~~~~~~~=4+4+4+2+4+2=20$

Subtask 1（5 分）： $n\leq 20$。

Subtask 2（12 分）：$n\leq 10^6$。

Subtask 3（28 分）：$n\leq 10^{12}$。

Subtask 4（20 分）：$m=0$。

Subtask 5（35 分）：$n\leq 10^{15}$。

对于所有数据 $2\leq n\leq 10^{15}$，$0\leq m\leq \min(n,10^5)$，$2\leq a_i\leq n$， 且答案不超过 $4\times 10^{18}$。

## 样例 #1

### 输入

```
4 0```

### 输出

```
20```

## 样例 #2

### 输入

```
12 1
4```

### 输出

```
127```

## 样例 #3

### 输入

```
192 1
2```

### 输出

```
-1```

# 题解

## 作者：Alex_Wei (赞：13)

- Update on 2023.4.4 勘误：$g_i$ 实际上等于 $d_i$ 质因子数量的两倍减去 $1$。

[题目传送门](https://www.luogu.com.cn/problem/P7091)。

---

首先将 $n$ 分解质因数，用 DFS 求出 $n$ 的所有因数，记为 $d_1,d_2,\cdots,d_c$，跑一遍反素数那题的代码可知 $c\leq 23327$（

设 $f_i$ 表示根节点为 $d_i$ 时最小值。

显然，局部最优值可以保证整体最优值，且转移无后效性，即求 $f_i$ 时不会影响 $f_j\ (d_j<d_i)$，故答案可以用树形 DP 求出，将所有因数排序后可以转化为序列上的 DP。

**对于不能出现在树上的 $d_i$ 直接 skip 即可。**

设 $g_i$ 表示 $d_i$ 所含有的质因子个数。For example，$12=2\times 2\times 3$，所以 $12$ 有 $3$ 个质因子。**在本题中，$g_{i}$ 也表示以 $d_i$ 为根的子树的节点个数，不难发现其为定值。**

假设当前转移 $f_i$ 决策点为 $j,k\ (d_j\times d_k=d_i)$，那么对于 $d_j$ 和 $d_k$ 子树内两两组合出的 pairs 的贡献可以直接由 $f_j+f_k$ 推得，剩下来只有两种情况：

- Case 1：$d_j$ 和 $d_k$ 子树内各一个节点组合出的 pairs。因为它们的 LCA 是 $d_i$，且共有 $g_j\times g_k$ 对 pairs，故贡献为 $g_j\times g_k\times d_i$。
- Case 2：$d_i$ 和任意一个节点组合出的 pairs。显然贡献为 $g_i\times d_i$。

转移方程：

$$f_i=\min_{d_j\times d_k=d_i}f_j+f_k+(g_j\times g_k+g_i)\times d_i$$

其中 $g_i=g_j+g_k+1$ 可以在 DP 时一并求出。

这样子搞是 $\mathcal O(c^3)$ 的，显然无法接受。

- 剪枝 1：在枚举内层循环 $j$ 时发现 $k$ 有单调性，所以直接用指针代替 $k$ 即可。这样时间复杂度降为了 $\mathcal O(c^2)$。
- 剪枝 2：当 $j>k$ 时直接 break，减小常数。

综上，我们有了一个 ${\mathcal O}(\sqrt n+m\log c+c^2)$ 的算法（分解质因数 + 处理限制需要二分查找 + DP），代码如下：

```cpp
ll n,m,num[N],f[N];
ll cnt,pr[N],c[N],tot;
ll fc[N],il[N],d;
map <ll,int> isp;

void dfs(int pos,ll prod){
	if(pos>cnt){
		if(prod>1)fc[++d]=prod;
		return;
	} for(int i=0;i<=c[pos];i++)dfs(pos+1,prod),prod*=pr[pos];
}

int main(){
	
	cin>>n>>m;
	// factor
	ll tmp=n;
	for(ll i=2;i*i<=n;i++)
		if(n%i==0){
			pr[++cnt]=i,isp[i]=1;
			while(n%i==0)c[cnt]++,tot++,n/=i;
		}
	if(n>1)pr[++cnt]=n,tot++,c[cnt]=1,isp[n]=1;
	n=tmp;
	
	// find factors
	dfs(1,1);
	sort(fc+1,fc+d+1);
	
	// limit
	for(int i=1;i<=m;i++){
		ll val=read();
		int pos=lower_bound(fc+1,fc+d+1,val)-fc;
		if(pos<=d&&fc[pos]==val)il[pos]=1; // 表示 pos 不能出现
	}
	
	// dp
	for(int i=1;i<=d;i++){
		if(il[i])continue;
		if(isp[fc[i]]){
			num[i]=1,f[i]=fc[i];
			continue;
		} il[i]=1,f[i]=inf; // 如果无法由以前的 j,k 转移得到那么 i 也无法得到
		int p=i-1;
		for(int j=1;j<i;j++){
			if(fc[i]%fc[j])continue;
			while(fc[p]>fc[i]/fc[j])p--;
			if(j>p)break;
			if(!il[j]&&!il[p])f[i]=min(f[i],f[j]+f[p]+num[j]*num[p]*fc[i]+(num[i]=num[j]+num[p]+1)*fc[i]),il[i]=0;
		}
	} if(il[d])puts("-1");
	else cout<<(ll)f[d]<<endl;
	return 0;
}
```

---

## 作者：gyh20 (赞：9)

算法 $1$：搜索。

搜索树的形态，可过 Subtask1 期望得分 $5$。

接下来需要一个结论：

虽然以 $n$ 为根的子树答案不确定，但节点个数是确定的，因为其中包含多少个点只和质因子个数有关。

算法 $2$：DP。

设 $f_i$ 表示以 $i$ 为根的最小值，则 $f_i=\min(f_j+f_{i/j}[j|i])$，如果用 $\sqrt n$ 的检验质因子可以获得 $45$ 分。

算法 $3$：Subtask4

贪心，发现每次把最大质因子分出去一定最优，这样能使得当前节点的贡献最小且其他子树贡献最小，结合之前算法可获得 $65$ 分。

算法 $4$：

继续沿用算法 $2$ 的方法，考虑优化转移。

发现每一个数的因数一定是 $n$ 的因数，所以检验因数时只用判断 $n$ 的因数即可。

$n$ 的因数至多有一万多个，再加上每次只用枚举到根号，所以经测验是可过的，标程最大的点 $1s$ 能出解。

常数优化：$map$ 很慢，建议离散化用数组维护。

算法 $5$：

用 Pollard-Rho 优化分解，可能会被卡，但由于这是 CSP 难度的模拟赛，所以不做延伸。

```cpp
#include<cstdio>
#include<algorithm>
#include<map>
#include<cmath>
using namespace std;
#define re register
long long n,pri[1000002],num[1000002],dp[1000002];
map<long long,bool>vis;
map<long long,int>pos;
int cntt,cnttt,m,cnt;
inline int dfs(re long long x){
	if(pos.count(x))return pos[x];
	re int xx=sqrt(x);pos[x]=++cntt;re int y=cntt;
	dp[y]=4e18;
	for(re int i=1;i<=cnt&&pri[i]<=xx;++i){++cnttt;
		if(x%pri[i]==0){
			re int ls=dfs(pri[i]),rs=dfs(x/pri[i]);
			num[y]=num[ls]+num[rs]+1;
			dp[y]=min(dp[y],(num[ls]+1)*(num[rs]+1)*x+dp[ls]+dp[rs]);
		}
	}
	if(!num[y])num[y]=1,dp[y]=x;
//	printf("%lld %d\n",x,y);
	if(vis.count(x))dp[y]=4e18;
	return y;
}
signed main(){
//	freopen("a30.in","r",stdin);
//	freopen("a30.out","w",stdout);
	scanf("%lld%d",&n,&m);
	re long long x;
	for(re int i=1;i<=m;++i)scanf("%lld",&x),vis[x]=1;
	if(vis.count(n))return puts("-1"),0;
	re int xx=sqrt(n);
	for(re int i=2;i<=xx;++i)if(n%i==0)pri[++cnt]=i;
	dfs(n);
	printf("%lld",dp[pos[n]]==4e18?-1:dp[pos[n]]);
}
```


---

## 作者：Jerrywang09 (赞：0)

比较困难的绿题，建议升蓝。

首先考虑 DP 状态。设 $f(n),g(n)$ 表示当前子树的根结点的权值是 $n$，最小所求、子树大小。枚举 $d|n$，$d$ 是其中一棵子树的根结点权值，$\frac n d$ 则是另一棵子树的根结点权值。这两棵子树内各选一个点，这两个点的最近公共祖先的权值就是 $n$。因此有转移：

$$
f(n)=\min_{d|n}(f(d)+f(\frac n d)+(g(d)+1)(g(\frac n d)+1)n)
$$

其中 $+1$ 是因为要算上当前子树的根。

具体实现时，要注意先预处理出 $n$ 的所有因数集合，因为接下来的因数枚举只需要枚举这个集合里面的数即可。并且要使用 `unordered_map` 离散化。

```cpp
// Title:  数上的树
// Source: P7091
// Author: Jerrywang
#include <bits/stdc++.h>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=1000010; ll inf=4e18;
using namespace std;
char buf[1<<23], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline ll read()
{
    ll x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

ll n, m, a[N], d[N], cnt, f[N], g[N], tot;
unordered_map<ll, bool> ban;
unordered_map<ll, int> id;
void dfs(ll n)
{
    if(id[n]) return;
    id[n]=++tot;
    f[id[n]]=inf; bool pri=1;
    rep(i, 1, cnt) if(d[i]<=n/d[i] && n%d[i]==0)
    {
        pri=0;
        ll x=d[i], y=n/x;
        if(ban[x] || ban[y]) continue;
        if(f[id[x]]==inf || f[id[y]]==inf) continue;
        dfs(x);
        dfs(y);
        ll tmp=f[id[x]]+f[id[y]]+(g[id[x]]+1)*(g[id[y]]+1)*n;
        if(tmp<f[id[n]])
        {
            f[id[n]]=tmp, g[id[n]]=g[id[x]]+g[id[y]]+1;
        }
    }
    if(pri) f[id[n]]=n, g[id[n]]=1;
}

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin); ios::sync_with_stdio(0);
#endif
    n=read(), m=read();
    rep(i, 1, m)
    {
        ll x=read(); ban[x]=1;
    }
    if(ban[n]) return puts("-1"), 0;
    rep(i, 2, n/i) if(n%i==0)
    {
        d[++cnt]=i;
        if(i!=n/i) d[++cnt]=n/i;
    }
    sort(d+1, d+cnt+1);
    dfs(n);
    printf("%lld", f[id[n]]<inf?f[id[n]]:-1);

    return 0;
}
```

---


# 小 L 的零食

## 题目背景

小 L 很喜欢吃零食。

## 题目描述

**提交时自动开启 O2 优化**。

小 L 现在想把一些零食放在一个盒子里。但是零食没放稳就会摔坏，所以小 L 希望求出**有多少种稳定的堆放零食的方法**。

零食都可以抽象成一个 $1\times1$ 的正方形，而盒子的底部可以看成长度为 $n$ 的一维线段。准确地说，零食被分为 $n$ 堆，从左到右地放在盒子里面，依次记为第 $1,2,\ldots,n$ 堆。我们认为每一堆的高度 $h_i$ 是这一堆零食的数量，且任意一堆都可以不包含任何零食。

我们定义第 $i$ 堆零食是稳定的，当且仅当：

- $h_i\le m$，即这一堆零食高度不超过 $m$。
- 在满足上一条的同时，满足以下两条之一或同时满足：
  - $i=1$ 或 $i=n$，此时有一侧是盒子内壁所以这一堆不会倒下；
  - $\color{red}\max\{h_{i-1},h_{i+1}\}\ge h_i-d_i$，此时它两侧的两堆零食有一堆足够高可以支撑这一堆不倒下。

我们定义一种稳定的堆放零食的方法，是一个长度为 $n$ 的 $h_i$ 的序列，满足按这个序列堆放出来的零食每一堆都是稳定的。

显然盒子里最多放下 $n\times m$ 个零食，我们认为小 L 的零食数量不少于 $n\times m$，并且不必将所有零食全部放进盒子。额外地，我们认为**每一个零食都是完全一样的**。

## 说明/提示

本题采用如下计分策略：    
**subtask $1$**（#$1$~#$8$）：$10\%$，$n,m\le5$；  
**subtask $2$**（#$9$~#$12$）：$30\%$，$n,m\le5\times10^2$；  
**subtask $3$**（#$13$~#$16$）：$20\%$，$n,m\le3\times10^3$；  
**subtask $4$**（#$17$~#$24$）：$40\%$，$n,m\le7\times10^3$。  
对于 $100\%$ 的数据：$1\le n,m\le7\times10^3$，$0\le d_i\le m$。**你必须通过一个 subtask 内所有测试点，才被认为通过该 subtask。**

**本题开启子任务依赖。**

## 样例 #1

### 输入

```
3 3
3 1 1 ```

### 输出

```
59```

## 样例 #2

### 输入

```
10 13
12 13 1 4 5 9 7 0 3 8 ```

### 输出

```
851695394```

# 题解

## 作者：Alex_Wei (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P7132)。

> 题意简述：给定 $n,m,d_{1,2,\cdots,n}$，求有多少种序列 $h_{1,2,\cdots,n}$ 满足 $0\leq h_i\leq m$ 且对于所有 $i\in[2,n-1]$ 有 $\max(h_{i-1},h_{i+1})+d_i\ge h_i$。

---

首先，看到 $n,m\leq 7\times 10^3$ 考虑能否 $\mathcal{O}(nm)$ DP。

考虑第 $i$ 堆零食时，第 $i+1$ 堆零食的高度会影响方案的可行性（即有后效性），所以不能单纯设 $f_{i,j}$ 表示 $h_i=j$ 的合法方案数。

不难想到按照 **第 $i$ 堆零食是否靠到了第 $i-1$ 堆零食上（即 $h_{i-1}+d_i$ 与 $h_i$ 的关系）** 将 $h_i=j$ 时的合法方案数分成两类情况讨论：设 $f_{i,j}$ 表示 $h_i=j$ 且 $h_{i-1}+d_i\geq h_i$（即第 $i$ 堆零食靠到了第 $i-1$ 堆零食上，此时不关心 $h_{i+1}$ 的大小）的合法方案数，$g_{i,j}$ 表示 $h_i=j$ 且 $h_{i-1}+d_i<h_i$ 的合法方案数。

接下来推转移方程：**记 $l=\max(0,j-d_i),r=\min(m,j+d_{i-1})$**
。

$f_{i-1,k}\to f_{i,j}$：此时应满足 $k+d_{i}\geq j$，但因为 $f$ 的定义，**不需要满足** $j+d_{i-1}\geq k$，所以此时 $k$ 的限制为 $\max(0,j-d_i)\leq k\leq m$，即

$$f_{i,j}\gets f_{i,j}+\sum_{k=l}^m f_{i-1,k}$$

。$g_{i-1,k}\to f_{i,j}$：此时应满足 $k+d_i\geq j$ 且 $j+d_{i-1}\geq k$，即 $l\leq k\leq r$，即

$$f_{i,j}\gets f_{i,j}+\sum_{k=l}^r g_{i-1,k}$$

。综上，$f_{i,j}$ 的转移方程为：

$$f_{i,j}=\sum_{k=l}^m f_{i-1,k}+\sum_{k=l}^r g_{i-1,k}$$

。根据上面的思路，不难推出 $g_{i,j}$ 的转移方程：

$$g_{i,j}=\sum_{k=0}^{l-1}f_{i-1,k}+g_{i-1,k}$$

。补充说明：当 $g_{i-1,k}\to g_{i,j}$ 时，$k$ 应同时满足 $k\leq r$ 且 $k<l$，又因为 $d_i$ 的非负性有 $l\leq r$，所以此时 $k\leq l$。

由于最后一堆零食没有高度限制，所以最终答案为 $\sum f_{n,i}+g_{n,i}$。

最后前缀和优化 + 滚动数组优化即可，时间复杂度 $\mathcal{O}(nm)$。参考代码：

```cpp
const int N=7e3+5;

ll n,m,d[N],f[2][N],g[2][N];

int main(){
	cin>>n>>m; for(int i=1;i<=n;i++)cin>>d[i];
	for(int i=0;i<=m;i++)f[1][i]=i+1;
	for(int i=2;i<=n;i++){
		int p=i&1,q=p^1;
		for(int j=0;j<=m;j++){
			int l=max(0ll,j-d[i]),r=min(m,j+d[i-1]);
			f[p][j]=(f[q][m]+g[q][r]-(l?f[q][l-1]+g[q][l-1]:0)+(j?f[p][j-1]:0)+mod)%mod;
			g[p][j]=((l?f[q][l-1]+g[q][l-1]:0)+(j?g[p][j-1]:0))%mod;
		}
	} cout<<(f[n&1][m]+g[n&1][m])%mod<<endl;
	return 0;
}
```

---

## 作者：dead_X (赞：1)

## 前言
挺好的题。
## 思路
下文中 $x$ 靠住 $y$ 指 $h_y\geq h_x-d_x$

看到这个东西第一个想到的就是 dp。

发现这个东西状态其实挺好设的，我们直接设 $dp_{i,j,0}$ 为已经放好前 $i$ 个，前 $i-1$ 个已经满足要求，第 $i$ 个不满足要求的情况数，$dp_{i,j,1}$ 为已经放好前 $i$ 个，均满足要求的情况数。

然后考虑转移。转移显然分四种：$0\to 0,0\to1,1\to0,1\to1$（唐突开车），我们一种一种来。

我们来拿第一种情况举个例子：第 $i-1$ 个靠住右边。第 $i$ 个不能靠住左边。

列出不等式：

$$\left\{\begin{array}{l}
h_{i}\geq h_{i-1}-d_{i-1}\\h_{i-1}<h_{i}-d_i
\end{array}\right.$$

化简得

$$\left\{\begin{array}{l}
h_{i}\geq h_{i-1}-d_{i-1}\\h_i> h_{i-1}+d_i\end{array}\right.$$

然后我们就可以知道哪些 $h_{i-1}$ 可以转移到 $h_i$ 了。其余三类转移思路类似，这里就不写了。不难发现能转移的部分都是**连续的一段**，所以每次 dp 完要做一次前缀和。这样写空间可能吃不消，所以请使用滚动数组。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int d[7003];
long long ans[7003][2],pre[7003][2]; 
const long long p=998244353;
signed main()
{
	int n=read(),m=read();
	for(int i=1; i<=n; ++i) d[i]=read();
	for(int i=0; i<=m; ++i) pre[i][1]=i+1;
	for(int i=2; i<=n; ++i) 
	{
		for(int j=0; j<=m; j++)
		ans[j][1]=(pre[min(j+d[i-1],m)][0]+(j-d[i]<=0?0:p-pre[j-d[i]-1][0])+pre[m][1]+(j-d[i]<=0?0:p-pre[j-d[i]-1][1]))%p,
		ans[j][0]=(j-d[i]-1<0?0:(pre[j-d[i]-1][1]+pre[j-d[i]-1][0])%p);
		pre[0][1]=ans[0][1],pre[0][0]=ans[0][0];
		for(int j=1; j<=m; j++) pre[j][1]=(pre[j-1][1]+ans[j][1])%p,pre[j][0]=(pre[j-1][0]+ans[j][0])%p;
	}
	printf("%lld\n",(pre[m][0]+pre[m][1])%p);
	return 0;
}
```


---


# [COCI 2020/2021 #2] Sjekira

## 题目描述

有一棵 $n$ 个结点的树，每个结点有一个权值，删除一条边的费用为该边连接子树中结点权值最大值之和。问以任意顺序删除树中所有边的最小花费。

## 说明/提示

**【样例解释 #1】**

先删 $(2,3)$，再删 $(1,2)$，花费为 $5+3=8$。

**【数据范围】**

对于 $100\%$ 的数据，$1 \leq n \leq 100,000$，$1 \leq t_i \leq 10^9$。

Subtask #1（$10$ pts）：$n \leq 10$。  
Subtask #2（$10$ pts）：$i$ 与 $i-1$ 有边直接相连。  
Subtask #3（$30$ pts）：$n \leq 1000$。  
Subtask #4（$50$ pts）：无附加限制。

**【说明】**

译自 [Croatian Open Competition in Informatics 2020 ~ 2021 Round 2 D Sjekira](https://hsin.hr/coci/contest2_tasks.pdf)。

## 样例 #1

### 输入

```
3
1 2 3
1 2
2 3```

### 输出

```
8```

## 样例 #2

### 输入

```
4
2 2 3 2
1 3
3 2
4 3```

### 输出

```
15```

## 样例 #3

### 输入

```
5
5 2 3 1 4
2 1
3 1
2 4
2 5```

### 输出

```
26```

# 题解

## 作者：tommymio (赞：13)

两种做法。一种 $O(n \log n)$，另一种是 $O(n)$。

这个题显然考虑贪心。每次从连通块大小不为 $1$ 的连通块中删去一个最大的点是最优的，因为我们希望权值大的点尽可能少的被计入答案。那我们逆序模拟这个过程就好了。具体来说将所有点按权值从小到大排序，考虑加入每个点 $x$ 和它的连边，如果它的出边指向的 $y_i$ 已加入，那么就合并 $x$ 与 $y_i$ 所在的连通块。这个过程中使用 $\text{dsu}$ 维护连通块权值最大值即可。算法瓶颈在排序处 $O(n\log n)$。

第二种做法更有意思一点。我们尝试把贪心得到的值写成一个表达式：
$$
\sum_{i=1}^n t_i-\max_{1\leq i\leq n} t_i+\sum_{i=1}^{n-1}\max(t_{x_i},t_{y_i})
$$
证明如下：考虑任意一棵子树 $T$，第一个删除的点是 $T$ 中的 $x$ 点，它在 $T$ 中权值是最大的。那么，设 $id_i$ 为以 $i$ 为根的子树内取到点权最大值的点的编号，则删去 $x\to y_k$ 这条边的花费为 $val_x+val_{id_{y_k}}$。我们注意到 $val_x$ 会作为边上两点权值 $\max$ 被计入答案，并且每个 $T$ 内的点只会以非 $\max$ 的形式被计入一次（举例：处理以 $id_{y_k}$ 为根的子树统计答案时不再会将 $x$ 与 $id_{y_k}$ 以非 $\max$ 的形式计入）。于是证毕。

直接计算此式即可。时间复杂度为 $O(n)$。

此处只贴上第一种做法的代码，第二种这么简单大家都会写吧（

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
typedef long long ll;
int cnt=0;
std::vector<int> vec[100005];
int maxn[100005],vis[100005],fa[100005],id[100005]; 
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f; 
}
inline int max(const int &x,const int &y) {return x>y? x:y;}
inline int find(int x) {return x==fa[x]? x:fa[x]=find(fa[x]);}
inline bool cmp(int x,int y) {return maxn[x]<maxn[y];}
int main() {
	int n=read(); ll ans=0;
	for(register int i=1;i<=n;++i) maxn[i]=read(),fa[i]=id[i]=i;
	std::sort(id+1,id+1+n,cmp);
	for(register int i=1;i<n;++i) {int x=read(),y=read(); vec[x].push_back(y); vec[y].push_back(x);}
	for(register int i=1;i<=n;++i) {
		int x=id[i]; vis[x]=1;
		for(register int k=0;k<vec[x].size();++k) {
			int y=vec[x][k]; if(!vis[y]) continue;
			int fx=find(x),fy=find(y);
			if(fx!=fy) {
				ans+=maxn[fx]+maxn[fy];
				maxn[fx]=max(maxn[fx],maxn[fy]);
				fa[fy]=fx;
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：fengenrong (赞：13)

根据题目我们可以发现最优解为：先将权值大的的顶点优先与和它连接的点删除。
所以我们就得到了一个时间复杂度 $O(n)$ 的公式：

$\sum_{i=1}^{n}T-\max(T_i)+\sum_{i=1}^{n-1}\max(T_x,T_y)$

证明：因为每一个点至少要和其它数合并一次，所以 $\operatorname{ans}$ 需要加上 $\sum_{i=1}^{n}T$。并且最大的那个数只会被计算到一次（因为最开始就把它给删了），所以 $\operatorname{ans}$ 还需要减去 $\max(T_i)$。然后，权值大的那个数需要在它于小顶点删除的时候又要重新使用（因为题目说：断开一条边的代价为该边连接的两个连通块中各取一个最大权值的顶点之和），所以 $\operatorname{ans}$ 还要加上 $\sum_{i=1}^{n-1}\max(T_x,T_y)$。
#### $Code$
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,sum,maxa,a[1000005]/*权值*/;
signed main()
{
	cin>>n;//输入
	for(register int i=1;i<=n;i++)
	{
		cin>>a[i];
		sum+=a[i];//总和
		maxa=max(a[i],maxa);//最大值
	}
	sum-=maxa;//利用公式
	for(register int i=1;i<=n-1;i++)
	{
		int x,y;
		cin>>x>>y;
		sum+=max(a[x],a[y]);//利用公式
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：tjtdrxxz (赞：6)

首先，如果是一条链，这道题是非常轻松的，每次选最大的点，然后把他和左右两边的点断开并统计答案。

而现在，换成了树，但题目没给出根，怎么去统计子树呢？


如下图（就是样例三的图，），红边最先被删，黄边其次，绿边最后被删。
![](https://cdn.luogu.com.cn/upload/image_hosting/j5w5ulmu.png)
可以发现答案是 $ 8 + 9 + 6 + 3 = 26 $，即（$ 1 \to 3, 1 \to 2, 5 \to 2, 4 \to 2 $）。

如果根是 $ 2 $ 号点呢？很明显，答案还是 $ 8 + 9 + 6 + 3 = 26 $ 并没有对答案产生影响，边和刚刚一样的，所以不管以哪个点作为根，答案都是一样的。

通过样例三可以发现，每次选点权最大的顶点，把他的儿子和他的父亲断开并把答案加上这些点点权和就好了。

楼上的题解对统计答案讲的还是挺详细的，就不多叙述了。。。

code：
```cpp
# include <bits/stdc++.h>
# define int long long
using namespace std;
vector <int> e[100012];
int n, w[100012], ans;
int s[100012];
int depth[100012], fa[100012], mn[100012];
priority_queue <pair <int, pair <int, int> > > q;
int mx = 0;
signed main ()
{
	ios :: sync_with_stdio (0);
	cin.tie (0), cout.tie (0);
	cin >> n;
	for (int i = 1; i <= n; i ++) cin >> w[i], ans += w[i], mx = max (w[i], mx);
	for (int i = 1; i < n; i ++)
	{
		int u, v;
		cin >> u >> v;
		e[u].push_back (v);
		e[v].push_back (u);
		ans += max (w[u], w[v]); 
	}
	cout << ans - mx << endl;
}
```

---

## 作者：big_spider (赞：6)

#### 题意解读
[传送门](https://www.luogu.com.cn/problem/P7162)

由题意可知，最先将最大的权值删除时，所得的结果会最小。

但也会发现，直接按题意模拟的话，即使用并查集优化，也容易超时，因此，不妨转换一下思路（逆序模拟）：**将每个点先独立开来，以加边代替删边，即将最少权值的边加最多遍，将最多权值的边加最少遍，就可以得到答案。**

#### 并查集优化
```cpp
long long Find(long long h){
	if(kfc[h]==h) return h;
	return kfc[h]=Find(kfc[h]);
}//使用路径压缩
```


#### 先将权值进行排序
```cpp
bool cmp(long long a,long long b){
	return t[a]<t[b];//按权值进行排序
}
scanf("%lld",&n);
for(long long i=1;i<=n;i++){
	scanf("%lld",&t[i]); 
	kfc[i]=ask[i]=i;//初始化并查集数组，
}
sort(ask+1,ask+1+n,cmp);
```

#### 附上全部代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100010
vector<long long>g[N];//存图
long long n,t[N],ans,kfc[N],ask[N];
bool vis[N];//记录第i个点是否已经加过其他边
long long Find(long long h){
	if(kfc[h]==h) return h;
	return kfc[h]=Find(kfc[h]);
}
bool cmp(long long a,long long b){
	return t[a]<t[b];
}
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++){
		scanf("%lld",&t[i]); 
		kfc[i]=ask[i]=i;
	}
	sort(ask+1,ask+1+n,cmp);
	for(long long i=1;i<n;i++){
		long long x,y; scanf("%lld%lld",&x,&y);
		g[x].push_back(y); g[y].push_back(x);
	}
	for(long long i=1;i<=n;i++){
		long long x=ask[i]; vis[x]=1;
		for(long long j=0;j<g[x].size();j++){
			long long y=g[x][j]; 
			if(!vis[y]) continue;//若已经加过，则跳过
			long long fx=Find(x); long long fy=Find(y);
			if(fx!=fy){
				ans+=(t[fx]+t[fy]);
				kfc[fy]=fx;//将祖先更新
				t[fx]=max(t[fx],t[fy]);//更新目前的最大值
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：Rannio (赞：5)

**题目大意**：把一棵树完全分解，每次分解一条边的代价是这条边连接的两个连通块的最大点权之和，求最小代价。  
  
逆序模拟，既然题目要求将树完全分解，那我们就每次逆序连接当前权值最小的两个点，也就是贪心的思路。
  
尝试将贪心的值写成一个表达式：
$$\sum_{i=1}^n a_i+\sum_{(u,v)\in E} \max(a_u,a_v)-\max(a_i)$$

考虑转化为合并节点，设第一次合并的时候代价为 $a_i$，那如果 $a_i>a_j$​ 就要再操作一次 $a_i$，所以边加的就是两个端点的最大值（作为新的连通块的最大代价的点对答案产生贡献，但是发现多一项，减一个 $\max(a_i)$ 即可。
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a,s,d[100005],f;
ll ans,sum=-99999;
int main(){
	scanf("%lld",&a);
	for(int i=1;i<=a;i++){
		scanf("%lld",&d[i]);
		ans+=d[i];
		sum=max(sum,d[i]);
	}
	for(int i=1;i<a;i++){
		scanf("%lld%lld",&s,&f);
		ans+=max(d[s],d[f]);
	}
	printf("%lld",ans-sum);
	return 0;
}
```


---

## 作者：FastingRabble (赞：5)

### 这可能是最简单最清晰的代码
根据题意，原题为删除一条边的费用为该边连接子树中结点权值最大值之和。

于是联想到添加一条边。题目中已经说了是“树形结构”。 

**即添加边的次数恒定。根据这一点，可以想到如果求边的最小费用我们就希望每次加的最大值最小。同时，每个点必定至少加一次。**

于是问题转换为每次加有联通边的两个数$A$，$B$，贡献为$\max( A , B )$ 。

接着记录 **最大值** ,在下一次操作时,又重复操作。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100005],x,y;
long long sum;
struct node
{
    long st,to;
}l[100005];
bool cmp(const node &x,const node &y)
{
    return x.to<y.to;
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        sum+=a[i];
    }
    if(n-1==0)
    {
        printf("0");
        return 0;
        }
    for(int i=1;i<=n-1;i++)
    {
        scanf("%lld %lld",&x,&y);
        if(a[x]<a[y])
        {
            l[i].st=a[x];
            l[i].to=a[y];
        }
        else
        {
            l[i].st=a[y];
            l[i].to=a[x];
        }
    }
    sort(l+1,l+n,cmp);
    for(int i=1;i<n-1;i++)
    {
        sum+=l[i].to;
    }
    printf("%lld",sum);
    return 0;
}
```


---

## 作者：LittleYang0531 (赞：4)

### 题目描述:

M 先生是一个程序员，不过，他赚够了钱，来到了一个小村子定居。现在，凛冬将至，M 先生不得不砍伐木材生火过冬。

M 先生面前有一棵巨大的树。M 先生将这棵物理意义上的树抽象成了数据结构中的一棵树。树上的每一个节点存在一个坚硬程度 $t_i$。当 M 先生想要砍掉树上的一条边时，他的斧头的受损程度会增加 $t_x+t_y$。$x$ 和 $y$ 分别是砍去这条边后形成的两个子树内 $t_i$ 最大的节点。

你的任务是求出一个砍伐方案，将这棵树的所有边全部砍掉，使得 M 先生的斧头受到的损伤程度最小。

### 输入描述:

输入的第一行包含一个整数 $n$，表示树的大小，树的节点编号从 1 到 $n$。

第二行包含一个 $n$ 个整数，第 $i$ 个整数即为 $t_i(1\leq t_i\leq 10^9)$。含义见题面。

接下来的 $n-1$ 行，每一行由两个整数 $x$ 和 $y(1\leq x,y\leq n)$。表示这棵树上的边。

### 输出描述:

输出一行，一个整数，即最小的斧头磨损程度。

### 分析:

#### 40Pts:

此档数据范围 $n\leq 1000$，在 $O(n^2)$ 的时间复杂度下完全能够通过此题。不难发现，当从权值最大的节点开始砍直到权值最小的节点的最终的损伤程度一定不劣于随便砍后最终的损伤程度。

最后从根节点开始扫就行了，找到以当前节点为根的子树中权值最大的节点并将其砍掉，再从这个权值最大的点的子树开始扫，直到所有节点都被砍掉即可。

时间复杂度 $O(n^2)$。

#### 100Pts:

按照上述思路进行观察。若某一个节点被找到了的话，那么其所在的子树在上一轮被分割时的最大值一定是它。然后在分割时其又会对最终结果产生 $t_i\times g_i$ 的贡献(设 $g_i$ 为 $i$ 节点的没被砍掉的边的数量)。因此，除权值最大的节点外，其他节点对最终结果的贡献值为 $t_i\times (g_i+1)$。由于权值最大的节点是第一个被分割的，因此在此之前没有进行分割操作，其对最终结果的贡献应为 $t_i\times g_i$。这样我们就可以通过对节点的权值排序再去计算每个结点对最终结果的贡献。最终计算时的时间复杂度仅为 $O(n)$。

时间复杂度为 $O(n\log_2 n)$(主要是排序时间复杂度)。

### 代码:

```C++
#include<bits/stdc++.h>
#define van long long
#define N 100010
using namespace std;
van n,line[N],sum;vector<van> g[N];
struct node{van num,id;}ans[N];
bool cmp(node a,node b){return a.num>b.num;}
int main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>ans[i].num,ans[i].id=i;
	for (int i=1;i<n;i++){
		van f,s;
		cin>>f>>s;
		g[f].push_back(s);
		g[s].push_back(f);//建边
		line[s]++,line[f]++;//计算某个点所连接的边的数量
	}
    sort(ans+1,ans+n+1,cmp);
	sum+=line[ans[1].id]*ans[1].num;
	for (int i=0;i<g[ans[1].id].size();i++) line[g[ans[1].id][i]]--;//特殊处理权值最大的点
	for (int i=2;i<=n;i++){
		sum+=(line[ans[i].id]+1)*ans[i].num;
		for (int j=0;j<g[ans[i].id].size();j++) line[g[ans[i].id][j]]--;
	}//处理其他的点
	cout<<sum<<endl;
	return 0;
}
```

---

## 作者：zhoumurui (赞：1)

# 题面展示

有一棵 $n$ 个结点的树，点有点权，删除一条边的费用为该边连接子树中结点权值最大值之和。问以任意顺序删除树中所有边的最小花费。


# 题目思路

### 50 POINTS 

显然当我们删除一个联通块中的一条边时，这个联通块中权值最大的点肯定会被计算在内，考虑先把权值最大的点~~扒光~~连接的边优先拆除，这样答案肯定是最优的。

把权值最大的点扒掉以后，我们会扒权值第二大的点，以此类推。

但拆点的时候难以以优于 $ O(n^2) $ 的时间复杂度计算花费，于是写了 $ O(n^2) $ 的 $n$ 个 DFS。

[错解代码](https://www.luogu.com.cn/paste/0fvlo8tl)

> 不开 long long 见祖宗。

### 100 POINTS

让我们推个公式：

设权值最大的点为根，它的权值为 $ A_0 $，

它连出的 $K$ 个子树的最大权值为 $A_1,\dots,A_K$，

答案为 $S_1,\dots,S_K$。

那么整个树的答案为：

$ A_0 \times K + \sum_{i=1}^{K} (A_i + S_i) $。

$S_i$ 也可以用类似的方式拆开，然后我们发现：

每个数在总公式左半部分中出现的次数等于它连向**权值小于它的点**的边数，此外**除了最大权值的点以外**每个数在右半边出现一次。

于是我们的正解就呼之欲出：

# 核心代码

```cpp
ans=maxx=0;
for (int i=1;i<=n;i++){
    ans+=a[i];
    maxx=max(maxx,a[i]);
  }
  ans-=maxx;
  for (int i=1;i<n;i++){
    ans+=max(side[i].start,side[i].end);
  }
```

---

## 作者：HDZmessi (赞：1)

　　做模拟复赛的时候遇到的 T2，完全不会，发个题解纪念一下（T4 更难 P7967）。
  
由于实力有限，所以本篇题解只提供线性对数复杂度的做法，线性的做法蒟蒻康不懂，老师也没讲。

代码有两种写法，复杂度都一样，一种并查集，一种纯贪心

先说并查集，这是大多数题解的方法。核心思想就是把删除整个树看成看成把一些点用最小的花费组成一棵合法的树，具体方法第一篇题解已经讲得很清楚了，我就直接贴代码：

CODE：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,fa[100005],vis[100005],ans;
int find(int x){
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);//并查集 
}
int re[100005],id[100005];//必须开两个数组，不能用结构体 
bool cmp(int x,int y){
	return re[x]<re[y];//花费最小，就从小到大排序，先把少费的点连一起，这样多费的点只会算1~2次 
}
vector<int> G[100005];//vector存图 
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>re[i];
		id[i]=i;
		fa[i]=i;
	}
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	sort(id+1,id+1+n,cmp);//排序 
	//cerr<<a[find(3)].re<<" "<<find(3)<<endl; 
	for(int i=1;i<=n;i++){
		vis[id[i]]=1;
		for(int j:G[id[i]]){
			int x=id[i];
			if(!vis[j]||(find(x)==find(j))) continue;
			ans+=re[find(x)]+re[find(j)]; 
			//cerr<<j<<" "<<re[find(j)]<<" "<<x<<" "<<re[find(x)]<<" "<<ans<<endl;
			fa[find(j)]=find(x);//更新并查集 
			re[find(j)]=max(re[find(x)],re[find(j)]);
		}
		//cerr<<ans<<endl;
	}
	cout<<ans<<endl;
	return 0;
}
```
这是法一。

下面这种方法是考试时讲的正解：

题目既然说删掉一条边的费用为这两条边连接的子树中最大点权的和（考试时这句没康懂），那么一定要先把点权最大的点先解决掉，也就是删掉包含这个点的边全部删掉，这样后面删的边连接的子树中，一定不会在含有这个点权极大的点了，不难发现，这样点权最大的点被计算的次数一定是在能删完的情况下最少的。

所以代码实现需要计算每个点度数，每次按点权从大到小枚举，删掉第一个点的花费就是点权乘以点的度数，但后面的点都要用点权乘以度数加一，这很重要（也可以想想为什么）。剩下的步骤就是模拟了。

CODE：

```cpp
#include<bits/stdc++.h>
#define int long long//开long long !!! 
using namespace std;
int n,du[100005];//计算度数！ 
vector<int> G[100005];//存图 

struct node{
	int re,id;
}a[100005];//这里能用结构体 
bool cmp(node x,node y){
	return x.re > y.re ;//从大到小排序点权 
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].re;
		a[i].id=i;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<n;i++){
		int u,v;cin>>u>>v;
		du[u]++;//无向边，两个点度数都加一 
		du[v]++;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(i==1) ans+=a[i].re*du[a[i].id];//这一行和下一行很重要 
		else ans+=a[i].re*(du[a[i].id]+1);
	//	cerr<<du[a[i].id]<<" "<<a[i].re<<endl;
		for(int j:G[a[i].id]){
			du[j]--;//度数减一 
		}
	}
	cout<<ans<<endl;
	return 0;//华丽结束 
}
```
不要 CTJ 或 TFS（题解优先搜索）

管理员给过吧谢谢！

---

## 作者：novax (赞：1)

[题面](https://www.luogu.com.cn/problem/P7162)。

一个好想但复杂度不是最优的做法。

#### 思路

考虑一个贪心。把删边转化为加边，每次加边费用为连接的两个联通块内最大值之和，那么权值越大的点加入连通块的时间应该越靠后。

把所有点按权值排序，然后从小到大依次遍历所有点的所有出边。如果某两点间不连通，那么代价就加上此时两侧联通块中最大权值之和。

用并查集维护两点是否联通。并查集在祖先同时维护一个当前块内的最大权值，合并时在祖先更新即可。

此做法时间复杂度为 $O(n \log n)$。

#### 代码

```cpp
#include <cstdio>
#include <algorithm>
#define max(a,b) (((a)>(b))?(a):(b))
const int Nx=100010;
int N,A[Nx],idx[Nx],used[Nx];
struct edge{int to,nex;};
edge a[2*Nx];
int head[Nx],cnt;
void add(int u,int v)
{
	a[++cnt].to=v;
	a[cnt].nex=head[u];
	head[u]=cnt;
}
bool cmp(int x,int y){return A[x]<A[y];}
int fa[Nx],bm[Nx];
int find(int p)
{
	if(fa[p]!=p)
		fa[p]=find(fa[p]);
	return fa[p];
}
int main()
{
	scanf("%d",&N);
	int i,j,k,fx,fy;
	long long ans=0;
	for(i=1;i<=N;i++)
	{
		scanf("%d",&A[i]);
		idx[i]=i;
		fa[i]=i,bm[i]=A[i];
	}
	for(i=1;i<N;i++)
	{
		scanf("%d%d",&j,&k);
		add(j,k),add(k,j);
	}
	std::sort(idx+1,idx+N+1,cmp);
	for(i=1;i<=N;i++)
	{
		used[idx[i]]=1;
		for(j=head[idx[i]];j;j=a[j].nex)
		{
			fx=find(idx[i]),fy=find(a[j].to);
			if(fx==fy||used[a[j].to]==0)
				continue;
			ans+=(bm[fx]+bm[fy]);
			fa[fy]=fx;
			bm[fx]=max(bm[fx],bm[fy]);
		}
	}
	printf("%lld\n",ans);
}
```


---

## 作者：残阳如血 (赞：1)

### $\textbf{Description}$

有一棵 $n$ 个结点的树，每个结点有一个权值，删除一条边的费用为该边连接子树中结点权值最大值之和。问以任意顺序删除树中所有边的最小花费。

### $\textbf{Solution}$

手模一下样例，在构造第 $3$ 组样例时容易发现一个贪心策略：**要先将权值大的点的连边删完**。

但是这样的话我实现的复杂度是 $O(n^2)$ 的，[代码自取](https://www.luogu.com.cn/paste/jhbd0mqh)。

---

> 俗话说：正难则反。

如果倒着看这个题目，将删边视为加边，做法就出来了。

此时的贪心策略为：**最后加入权值大的点**（这样就更好证了）。

所以将权值**从小到大**排序，然后从前向后合并，合并时用并查集维护最大值即可，详见代码。

#### 时空复杂度

- 时间复杂度：瓶颈排序，$O(n\log n)$。
- 空间复杂度：显然 $O(n)$。

#### 实现细节

- 合并应该是与权值比自身小的连通块合并，故可以开一个 `vis` 数组，记录是否被访问过（即权值是否比自身小）。
- 又需要排序有需要记录，所以要开一个 $id$ 数组，对 $id$ 数组排序，而非对 $t$ 排序。

### $\textbf{Code}$

```cpp
#include <vector>
#include <iostream>
#include <algorithm>
#define max(a,b) ((a)>(b)?(a):(b))
using lint = long long;
const int N = 1e5 + 10;

lint ans;
bool vis[N];
std::vector<int> g[N];
int n, t[N], fa[N], id[N];

int find(int x) { // 并查集查询 
  return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void merge(int x, int y) { // 并查集合并
  int fx = find(x), fy = find(y);
  if (fx == fy) return ;
  ans += t[fx] + t[fy];
  fa[fx] = fy;
  t[fy] = max(t[fy], t[fx]);
}

int main() {
  std::cin.tie(0)->sync_with_stdio(0);
  std::cin >> n;
  for (int i = 1; i <= n; ++i)
    std::cin >> t[i], fa[i] = id[i] = i;
  std::sort(id + 1, id + n + 1, [](int x, int y){ // 排序
    return t[x] < t[y];
  });
  for (int i = 1, x, y; i < n; ++i) {
    std::cin >> x >> y;
    g[x].push_back(y);
    g[y].push_back(x);
  }
  for (int i = 1, u; i <= n; ++i) {
    u = id[i], vis[u] = true;
    for (auto v : g[u])
      if (vis[v]) merge(u, v);
  }
  std::cout << ans << std::endl;
  return 0;
}
```

---

## 作者：xuan_gong_dong (赞：0)

## 题面
[P7162 [COCI2020-2021#2] Sjekira](https://www.luogu.com.cn/problem/P7162)
## 分析
找规律，找到之后就基本把这个题秒了。

手玩了几组数据，发现无论怎么选择输入的两条边中有一个点早晚会被选择，且该点是此边所连接的两个点中的最大值。

注意到这是一棵树，所以选择的方法会使得有且仅有一次一条边不会对答案有贡献，所以直接选择点权最大的点所连出的边。
## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000010];
int n;;
signed main()
{
	scanf("%d",&n);
	int ans=0;
	int Max=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		Max=max(Max,a[i]);
		ans+=a[i];;
	}
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		ans+=max(a[u],a[v]); 
	}
	cout<<ans-Max;
	return 0;
}
```

---

## 作者：IYSY2009I (赞：0)

被某机构搬来作普及组 T4 了，我这个提高组 1= 的 差点没做出来，写篇题解纪念一下。

首先转化题意，把删边改成倒着加边，这样在保证答案不变的情况下方便用并查集维护连通性。

题意中的花费计算也不大方便，我们也转化一下：先把所有点权加起来，每次合并两个联通块就给答案加上两个联通块最大值，最后再减去所有点权最大值。初始点权和所有点权的最大值显然是一定的，于是只用考虑合并的代价就行。

发现 DP 不太好做，自然地想到贪心。通过手玩样例可以感觉到，点权越大的点的处理的优先级越靠后，于是想到一个贪心：将边按照两个端点的点权较大值从小往大加边，这是一个上界，接下来我们只需要证明这是一个下界就行。这个也是不难的，注意到上述方案的答案其实就是两个端点点权较大值之和（**所以在实现的时候连并查集都不用，直接做就行，但我考场上并没有意识到这一点**），而每次操作之后不会使合并两个联通块的代价更小，因此上述方案就是最小的。

给一下我考场写的[代码](https://www.luogu.com.cn/paste/786yafkm)（有数据分治），但由于实现较复杂，其实没有什么意义。

---

## 作者：lvchengze (赞：0)

# 解题思路：
### 方法：
这道题可以把删边变成加边，接着用并查集维护；同时也可以直接用公式： $ ans=\sum_{i=1}^{n}{a_i}-\max(a_i)+\max(a_{x_i},a_{y_i})$。这条公式的意义是除了最大值点之外的每一个点都会在作为某个最大值点被删之后某棵子树的最大值计算一次，这就是 $\sum_{i=1}^{n}{a_i}-\max(a_i)$，而每次删去一条边还会计算一次这条边连接的两个点中权值较大的一个，这就是 $\max(a_{x_i},a_{y_i})$。                        
$$Ans=\sum_{n}^{i=1} {c_i}+ \max({{c_{x_i},c_{y_i}}})-\max({c_i}) $$           

# 代码如下
时间复杂度 $O(n)$ ，只要会写树 ~~都会写树吧~~ 就能过。
~~自我感觉良好~~ 那我就用一下~~小小~~ $ O(n) $ 的树形 $dp$ 吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ans[100005],c[100001],maxn;
vector<int>G[100005];
void dfs(int u,int fa){
	maxn=max(maxn,c[u]);
	for(int i=0;i<G[u].size();i++){
		int v=G[u][i];
		if(v==fa)continue;
		dfs(v,u);
		ans[u]=ans[u]+max(c[u],c[v])+ans[v];
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for (int i=1;i<=n;++i){
		cin>>c[i];
		ans[i]=c[i];
	}
	for (int i=1,u,v;i<n;++i){
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1,0);
	cout<<ans[1]-maxn;
}
```

---

## 作者：z071202 (赞：0)

## 大致题意
首先，这道题很明显是一道贪心题。题目要求我们删除所有边，每条边删除的费用是两边的最大值之和。需要求出费用之和的最小值。


------------

### 思路
首先，我们可以看出，一定是先删除含有树上最大值的点。否则它会算更多次，答案一定不是最优。既然我们是想让大的值尽可能少的参加删边，所以我们感触逆运算删边，改为连接所有点。那么我们只需要先连接小的点，让大的点尽可能往后连接就行了。


------------

### 奉上代码
```#include<bits/stdc++.h>
using namespace std;
const int N = 100005;
typedef pair<int,int> ii;
int t[N],u,v,n;
vector<ii> e;
int uf[N], mv[N];
bool cmp(const ii& a, const ii& b)
	{
	int x = max(t[a.first], t[a.second]);
	int y = max(t[b.first], t[b.second]);
	return x<y;
	}
int fnd(int x)
	{
	if(x==uf[x]) return x;
	else return uf[x]=fnd(uf[x]);
	}
long long sol = 0;
void un(int x, int y)
	{
	x = fnd(x);
	y = fnd(y);
	if(x != y)
		{
		sol += mv[x] + mv[y];
		mv[y] = max(mv[y], mv[x]);
		uf[x] = y;
		}
	}
inline int read()
	{
	int a=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		{
		if(ch=='-') f=0;
		ch=getchar();
		}
	while(ch>='0'&&ch<='9')
		{
		a=(a<<1)+(a<<3)+(ch^48);
		ch=getchar();
		}
	return a*f;
	}
int main()
	{
	n=read();
	for(int i=0; i<n; i++)
		{
		t[i]=read();
		uf[i] = i;
		mv[i] = t[i];
		}
	for(int i=1; i<n; i++)
		{
		u=read(),v=read();
		e.push_back(ii(u-1, v-1));
		}
	sort(e.begin(), e.end(), cmp);
	for(vector<ii>::iterator i = e.begin() ; i != e.end() ; ++i)
		{
		un(i -> first, i -> second);
		}
	cout<<sol;
	}
    ```

---


# [COCI 2020/2021 #3] Sateliti

## 题目背景

为了得到进一步的探索进展，阿雷西博望远镜将拍下土星的卫星。研究团队必须区分卫星图像并将它们按卫星分组，但由于卫星从不同角度拍摄，因此并不容易。

## 题目描述

捕捉到的图像可以以一个 $n \times m$ 的矩阵呈现，其中 `*` 表示火山，而 `.` 表示平地。我们认为两个图像属于同一颗卫星，当且它们能**环形地互相通过向上下或左右平移得到**。

科研工作者想要找到**字典序最小**的与给定图像属于同一颗卫星的图像。我们把图像的所有行依次连接组成字符串，再判断字符串的字典序即可。

## 说明/提示

**【样例解释 #1】**

所有可能的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/ftrlc0tx.png)

**【数据范围】**

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $1 \le n,m \le 50$ |
| $2$ | $40$ | $1 \le n,m \le 300$ |
| $3$ | $60$ | 无 |

对于 $100\%$ 的数据，$1 \le n,m \le 1000$。

**【说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf)  _T3 Sateliti_。**

## 样例 #1

### 输入

```
3 3
.**
*..
.*.```

### 输出

```
**.
..*
*..```

## 样例 #2

### 输入

```
3 4
....
..*.
....```

### 输出

```
*...
....
....```

## 样例 #3

### 输入

```
3 5
.**..
.***.
..**.```

### 输出

```
***..
.**..
**...```

# 题解

## 作者：wsyhb (赞：7)

### 题解

可以进行行循环移位和列循环移位，因此只需确定左上角的格子是原来的哪个格子，即可确定对应图形。很自然想到将原矩阵复制成左上、右上、左下、右下四份，以方便求解答案。

二维 Hash 可以判断两个子矩阵相不相等，外层套个二分确定第一个不相同的位置，就可以比较字典序大小，总时间复杂度 $O(nm(\log{n}+\log{m}))$。

### 代码

PS：二维 Hash 可以将 $(i,j)$ 的权值赋为 $p^{(i-1)*m+(j-1)}$（从左到右、从上到下对格子进行编号），也可以将其赋为 $p^{i}q^{j}$（行列分别编号），其中 $p,q$ 为互不相同的质数。笔者使用的是前者，官方题解使用的是后者，故都贴一下代码。

**笔者代码**

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
const int inv2=5e8+4;
inline int get_sum(int a,int b)
{
	return a+b-(a+b>=mod?mod:0);
}
inline int get_power(int a,int n)
{
	int res=1;
	while(n>0)
	{
		res=n&1?1ll*res*a%mod:res;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
int n,m;
inline int id(int x,int y)
{
	return (x-1)*(m<<1)+(y-1);
}
const int max_n=1e3+5;
const int max_m=1e3+5;
char str[max_m];
int Map[max_n<<1][max_m<<1];
const int max_tot=4e6+5;
int pow2[max_tot],pow_inv2[max_tot],Hash[max_n<<1][max_m<<1];
inline int get_Hash(int a,int b,int c,int d) // calculate the hash value of the matrix that the upper left corner is (a,b) and the lower right corner is (c,d)
{
	return (1ll*Hash[c][d]-Hash[a-1][d]-Hash[c][b-1]+Hash[a-1][b-1]+2*mod)*pow_inv2[id(a,b)]%mod;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",str+1);
		for(int j=1;j<=m;++j)
			Map[i][j]=Map[i+n][j]=Map[i][j+m]=Map[i+n][j+m]=(str[j]=='.');
	}
	pow2[0]=1;
	for(int i=1;i<=(n*m<<2);++i)
		pow2[i]=get_sum(pow2[i-1],pow2[i-1]);
	pow_inv2[n*m<<2]=get_power(pow2[n*m<<2],mod-2);
	for(int i=(n*m<<2)-1;i>=0;--i)
		pow_inv2[i]=get_sum(pow_inv2[i+1],pow_inv2[i+1]); 
	for(int i=1;i<=(n<<1);++i)	
		for(int j=1;j<=(m<<1);++j)
			Hash[i][j]=(1ll*Map[i][j]*pow2[id(i,j)]+Hash[i-1][j]+Hash[i][j-1]-Hash[i-1][j-1]+mod)%mod;
	int ans_x=1,ans_y=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			int L=1,R=n,res_x=n+1,res_y=m+1;
			while(L<=R)
			{
				int mid=(L+R)>>1;
				if(get_Hash(i,j,i+mid-1,j+m-1)!=get_Hash(ans_x,ans_y,ans_x+mid-1,ans_y+m-1))
					res_x=mid,R=mid-1;
				else
					L=mid+1;
			}
			if(res_x==n+1)
				continue;
			L=1,R=m;
			while(L<=R)
			{
				int mid=(L+R)>>1;
				if(get_Hash(i+res_x-1,j,i+res_x-1,j+mid-1)!=get_Hash(ans_x+res_x-1,ans_y,ans_x+res_x-1,ans_y+mid-1))
					res_y=mid,R=mid-1;
				else
					L=mid+1;
			}
			if(!Map[i+res_x-1][j+res_y-1])
				ans_x=i,ans_y=j;
		}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
			putchar(Map[ans_x+i-1][ans_y+j-1]?'.':'*');
		putchar('\n');
	}
	return 0;
}
```

**官方 std**

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define TRACE(x) cerr << #x << " = " << x << endl
#define _ << " _ " <<

#define fi first
#define se second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef vector<int> vi;

const int MAXN = 1010, MOD = 1e9 + 7, P = 2, Q = 3;

int pq_pow[2 * MAXN][2 * MAXN];
int h[2 * MAXN][2 * MAXN];

int add(int a, int b) {
    int res = a + b;
    if (res >= MOD) res -= MOD;
    return res;
}
int sub(int a, int b) { return add(a, MOD - b); }
int mul(int a, int b) { return (ll)a * b % MOD; }

void precalc(const vector<string>& a) {
    for (int i = 0; i < 2 * MAXN; i++) {
        for (int j = 0; j < 2 * MAXN; j++) {
            if (i == 0 && j == 0) pq_pow[i][j] = 1;
            else if (i == 0) pq_pow[i][j] = mul(pq_pow[i][j - 1], Q);
            else pq_pow[i][j] = mul(pq_pow[i - 1][j], P);
        }
    }

    int n = a.size(), m = a[0].size();
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 0; j < 2 * m; j++) {
            int val = mul(a[i % n][j % m] == '.', pq_pow[i][j]);
            h[i + 1][j + 1] = sub(add(val,
                        add(h[i + 1][j], h[i][j + 1])),
                    h[i][j]);
        }
    }
}

int get_h(int x, int y, int dx, int dy) {
    return sub(add(h[x + dx][y + dy], h[x][y]),
            add(h[x][y + dy], h[x + dx][y]));
}

bool is_equal(int x1, int y1, int x2, int y2, int dx, int dy) {
    int val1 = mul(get_h(x1, y1, dx, dy), pq_pow[x2][y2]);
    int val2 = mul(get_h(x2, y2, dx, dy), pq_pow[x1][y1]);
    return val1 == val2;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<string> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    precalc(a);

    int sol_x = 0, sol_y = 0;
    for (int x = 0; x < n; x++) {
        for (int y = 0; y < m; y++) {
            int lo_dx = 0, hi_dx = n;
            while (lo_dx + 1 < hi_dx) {
                int dx = (lo_dx + hi_dx) / 2;
                if (is_equal(sol_x, sol_y, x, y, dx, m)) lo_dx = dx;
                else hi_dx = dx;
            }
            int dx = lo_dx;

            int lo_dy = 0, hi_dy = m;
            while (lo_dy + 1 < hi_dy) {
                int dy = (lo_dy + hi_dy) / 2;
                if (is_equal(sol_x + dx, sol_y, x + dx, y, 1, dy)) lo_dy = dy;
                else hi_dy = dy;
            }
            int dy = lo_dy;


            if (a[(x + dx) % n][(y + dy) % m] <
                a[(sol_x + dx) % n][(sol_y + dy) % m]) {
                sol_x = x;
                sol_y = y;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            cout << a[(sol_x + i) % n][(sol_y + j) % m];
        cout << '\n';
    }

    return 0;
}
```

---

## 作者：LittleYang0531 (赞：4)

### 题目描述:

一个科学团队正在使用科学望远镜观测土星的卫星。为此，科学家们必须对不同卫星的照片进行分类。这个任务相当困难，因为从不同角度上看过去，卫星的面貌是不一样的。 

卫星图片可以被看成是一个 $n\times m$ 的字符矩阵，矩阵上由两种字符 `*` 和 `.` 构成。我们说两个图片表示的是同一个卫星，表示通过一些**行列平移**，两张图片会变得完全相同。 

为了区分不同的卫星，科学家每需要找到每一个卫星的**字典序最小**的字符矩阵。注意，当我们比较两个字符矩阵的字典序的时候，你可以理解为比较两个字符矩阵**按行拼接**起来的字符串的字典序。你的任务是对于一个给定的字符矩阵，找出它经过行列平移后字典序最小的形式。

### 输入描述:

输入的第一行包含两个正整数 $n,m(q\leq n,m\leq 1000)$。表示字符矩阵的大小。

接下来的 $n$ 行，每行一个长度为 $m$ 的字符串，字符串仅由 `*` 和 `.`构成。

### 输出描述:

输出 $n$ 行，每行 $m$ 个字符，表示我们需要找到的字典序最小的字符矩阵。

### 分析:

由于涉及到比较字典序，考虑使用二维哈希算法。

设 $hash(c_{i,j})=p^i\times q^j\times c_{i,j}$，则一个二维矩阵的哈希值可以用这个矩阵中的每一个字符的哈希值之和来表示。至于如何求出某一矩阵中每一个字符的哈希值之和，可以考虑使用二维前缀和。设 $sum_{i,j}$ 为以 $(1,1)$ 为起始点的长为 $i$，宽为 $j$ 的矩阵中所有字符的哈希值之和。则一个起点为 $(x,y)$ 且长为 $l$，宽为 $w$ 的矩阵哈希为 $sum_{x+l-1,y+j-1}-sum_{x-1,y+j-1}-sum_{x+i-1,y-1}+sum_{x-1,y-1}$。

接下来两个二分查找就可以确定两个矩阵的最长公共前缀。先将两个矩阵移动到相同的位置，将整个矩阵乘上 $p^i\times q^j$ 即可。再比较两个矩阵最多有多少行是相等的，最后比较两个矩阵的下一行有多上个字符是相等的。

执行完以上操作之后，比较下一位的字符，更小的代表该矩阵的字典序最小。

时间复杂度为 $O(n^2\log_2 n)$。

### 代码:

```C++
#include<bits/stdc++.h>
#define van long long
#define N 3010
#define ywhin cin
#define ywhout cout
using namespace std;
const van p=131,q=133;
char ch[N][N];
van n,m,sx=1,sy=1;
unsigned van hash[N][N],sum[N][N];
unsigned van power(van a,van b) {
	unsigned van ans=1,base=a;
	while (b>0){
		if (b%2==1) ans*=base;
		base*=base,b>>=1; 
	}
	return ans;
}//计算乘方
unsigned van HashCalc(van i,van j) {
	return power(p,i)*power(q,j)*ch[i][j];
}//计算单点哈希
void init() {
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
			sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+hash[i][j];
		}
	}
}//计算二维前缀和
unsigned van Calc_Matrix(van sx,van sy,van height,van width) {
	van ex=sx+height-1,ey=sy+width-1;sx--,sy--;
	return sum[ex][ey]-sum[sx][ey]-sum[ex][sy]+sum[sx][sy];
}//查询矩阵哈希
//ifstream ywhin("sateliti.in");
//ofstream ywhout("sateliti.out");
int main() {
	ywhin>>n>>m;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			ywhin>>ch[i][j];
			ch[i][j+m]=ch[i+n][j]=ch[i+n][j+m]=ch[i][j];
		}
	}//开个四倍数组
	for (int i=1;i<=n*2;i++) {
		for (int j=1;j<=m*2;j++) {
//			cout<<power(2,2)<<endl;
			hash[i][j]=HashCalc(i,j);
		}
	}//计算单点哈希
	init();
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			if (i!=1||j!=1) {
				unsigned van base1=power(p,sx-i)*power(q,sy-j),
							 base2=power(p,i-sx)*power(q,j-sy);//移位
				van l=1,r=n,tmp=0;
				while(l<=r) {
					van mid=l+r>>1;
					unsigned van matrix1=Calc_Matrix(i,j,mid,m)*base1,
								 matrix2=Calc_Matrix(sx,sy,mid,m)*base2;
					if (matrix1==matrix2) {
						tmp=mid;l=mid+1;
					}
					else r=mid-1;
				}//计算最多有多少行是相等的
//				cout<<i<<" "<<j<<" "<<sx<<" "<<sy<<" "<<tmp<<endl;
				l=1,r=m;van tmp2=0;
				while (l<=r) {
					van mid=l+r>>1;
					unsigned van matrix1=Calc_Matrix(i+tmp,j,1,mid)*base1,
								 matrix2=Calc_Matrix(sx+tmp,sy,1,mid)*base2;
					if (matrix1==matrix2) {
						tmp2=mid,l=mid+1;
					}
					else r=mid-1;
				}//计算下一行有多少个相等的连续的字符
				if (ch[i+tmp][j+tmp2]<ch[sx+tmp][sy+tmp2]) sx=i,sy=j;//比较上述结果的下一位的字符
//				cout<<i<<" "<<j<<" "<<sx<<" "<<sy<<endl;
			}
		}
	}
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			ywhout<<ch[i+sx-1][j+sy-1];
		}
		ywhout<<endl;
	}
	return 0;
}
```

---

## 作者：xiaolu12356 (赞：1)


## 题解


核心考点是字符串排序。码量较大。

总的情况显然最多有 $n m$ 种，通过二维散列比较子矩阵可以达到 $\log{n}+\log{m}$，所以直接暴力枚举 + 比较大小即可。难点在比较大小的方法，我们设 $p_{[i][j]}=a_{[i][j]}\times 5^i \times 3^j$，$\operatorname{has}(i,j,i2,j2)=\sum^{i2}_{l1=i}\sum^{j2}_{l2=j} p_{[11][12]}$。这样前缀和可以方便地减去贡献。时间复杂度 $O(nm(\log{n}\log{m}))$。

## 代码

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <bitset>
#define PII pair<int,int>
#define ll long long
#define ull unsigned long long
using namespace std;
const int mx = 2005, P = 5, Q = 3;
int n, m;
char s[mx][mx];
ull p[mx][mx], h[mx][mx];
ull has(int i, int j, int i2, int j2) {
    return (h[i + i2][j + j2] - h[i][j + j2] - h[i + i2][j] + h[i][j]);
}
bool equal(int x, int y, int x2, int y2, int x3, int y3) {
    return has(x, y, x3, y3) * p[x2][y2] == has(x2, y2, x3, y3) * p[x][y];
}
int main() {
//      freopen("data.in","r",stdin);
    scanf("%d%d", &n, &m);

    for (int i = 0; i < n; i++) {
        scanf("%s", s[i]);
    }

    for (int i = 0; i < n << 1; i++) {
        for (int j = 0; j < m << 1; j++) {
            if (i == 0 && j == 0)
                p[i][j] = 1;
            else if (j == 0)
                p[i][j] = p[i - 1][j] * P;
            else {
                p[i][j] = p[i][j - 1] * Q;
            }
        }

    }

    for (int i = 0; i < n << 1; i++) {
        for (int j = 0; j < m << 1; j++) {
            h[i + 1][j + 1] = h[i][j + 1] + h[i + 1][j] - h[i][j] + (s[i % n][j % m]=='.') * p[i][j];
        }
    }

    int tx = 0, ty = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0)
                continue;

            int l = 1, r = n, res = 0;

            while (l <= r) {
                int mid = l + r >> 1;

                if (equal(tx, ty, i, j, mid, m))
                    res = mid, l = mid + 1;
                else
                    r = mid - 1;
            }

            l = 1, r = m;
            int res2 = 0;

            while (l <= r) {
                int mid = l + r >> 1;

                if (equal(tx, ty, i, j, res + 1, mid))
                    res2 = mid, l = mid + 1;
                else
                    r = mid - 1;
            }

            if (res == n && res2 == m)
                continue;

            if (s[(i + res) % n][(j + res2) % m] < s[(tx + res) % n][(ty + res2) % m])
                tx = i, ty = j;
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%c", s[(i + tx) % n][(j + ty) % m]);
        }

        printf("\n");
    }
}

```

---


# [COCI 2007/2008 #6] GEORGE

## 题目背景

T 先生来 Luka 所在的小镇玩，因为 T 先生是一个大人物，警察会对他将走过的路实行交通管制。

Luka 在镇上是一名送货的卡车司机。但是由于一些路正在进行交通管制，他无法及时交货，还因此差点丢掉了他的工作。

## 题目描述

Luka 知道 T 先生游玩的路线，并且他想要知道最短的交货时间。

该城市由若干十字路口和连接它们的道路连接，并且 Luka 知道他需要在某条路段上开多长时间（T 先生需要同样的时间以开过该路段）。

例如，如果 T 先生在第 $10$ 分钟进入一条路，并且需要 $5$ 分钟离开这条路，那么该街道将在第 $10 \sim 14$ 分钟时被封锁。Luka可以在第 $9$ 分钟或更早的时候，也可以在第 $15$ 分钟及以后进入该道路。

编写一个程序，计算 Luka 在 T 先生到达城市后 $k$ 分钟开始开车的最短时间。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据，$2 \le n \le 10^3$，$2 \le m \le 10^4$，$1 \le a, b \le n$，$0 \le k \le 10^3$，$ 0 \le g \le 10^3$。

#### 说明
- 本题满分 $60$ 分。
- 本题默认开启 O2 优化开关。
- 题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #6](https://hsin.hr/coci/archive/2007_2008/contest6_tasks.pdf) T4 GEORGE，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
6 5
1 6 20 4
5 3 2 4
1 2 2
2 3 8
2 4 3
3 6 10
3 5 15 
```

### 输出

```
21```

## 样例 #2

### 输入

```
8 9
1 5 5 5
1 2 3 4 5
1 2 8
2 7 4
2 3 10
6 7 40
3 6 5
6 8 3
4 8 4
4 5 5
3 4 23 
```

### 输出

```
40```

# 题解

## 作者：DicaprioD (赞：8)

#### 堆优化版 Dijkstra
这道题是刚学完最短路刷题时遇到了，感觉是一道板子题，只需要根据题意多加一些东西就可以了，并不难。

### 分析
首先，只需要把十字路口理解为点，路理解为边，时间作为权值，即可转化为一道较为传统的最短路问题。

再看一下数据范围，可以判断此题是一个稠密图，用邻接矩阵来存储十分方便。

然后，读题发现边的权值绝对不是负数，那么我们就可以来打一手 Dijkstra 了，最后再看时空限制，打一个堆优化更为稳妥。

但这道题不是纯板子，题目给到了我们一些限制，在 Luka 按照我们规划好的最短路前进时，可能会遇到 T 先生的干扰，如果赶到一个点时，恰好 T 先生也在这，那 Luka 只能等待，所以现在摆在我们面前的问题是：
- Luka 会在哪个点遇到 T 先生？
- Luka 会在那个点等多长时间？

相对应的我们给出如下解决措施：
- 预处理出 T 先生会经过的点，以及从 $x$ 到 $y$ 的时间，在跑 Dijkstra 时特判即可。
- 思考一下，如果 Luka 在从 $x$ 到 $y$ 路径上遇到了 T 先生，那么他花费的时间不仅是自己通过所用时间，还有等待 T 先生通过的时间，也就是说，总共所用时间是原本的双倍，需要注意的是，T 先生在 Luka 到达前就可能在这条路上走了一段时间，需要减去这段时间。
- 以上操作，详解看代码。

有了这些准备之后，就可以套模板了。
代码里可能还会有一些小细节。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+10;
typedef pair<int,int> PII;
int n,m;
int b,e,k,g;
int mp[N][N];//存图
int TT[N][N],past[N];//上面有解释
int d[N];
bool st[N];
//这个自定义函数来判断一下,y先生是否在这条路上以及Luka通过需要的时间
int ff(int x,int y){
  //这段代码几乎每篇题解都有，这里做一下详细的解释
	if(d[x]>=TT[x][y]&&d[x]<=TT[x][y]+mp[x][y]-1){//如果到达这条路时T先生正在这里游玩
		return TT[x][y]+mp[x][y]*2;//那么我们要在原本的等待时间上*2,因为Luka是在T先生走完这条路之后重新走一遍,相当于走了两遍.
   //至于为什么实在T先生的时间基础上操作,而不用d[x]+mp[x][y]*2,因为Luka到达时，T 先生可能已经在这条路上走了一会了.可以理解一下下面这个式子
   //return d[x]+mp[x][y]*2-(d[x]-TT[x][y])
    
	}
	else return d[x]+mp[x][y];
}
//下面是 Dijkstra 的模板
void Dijkstra(){
	memset(d,0x3f,sizeof d);
	d[b]=k;
	priority_queue<PII,vector<PII> ,greater<PII> > heap;
	heap.push(make_pair(k,b));
	while(heap.size()){
		auto t=heap.top();
		heap.pop();
		int ver=t.second;
		if(st[ver]) continue;
		st[ver]=1;
		for(int i=1;i<=n;i++){
			if(mp[ver][i]){
				int distance = ff(ver,i);
				if(distance<d[i]){
					d[i]=distance;
					heap.push(make_pair(distance , i));
				}
			}
		}
	}
}
int main(){
	cin>>n>>m;
	cin>>b>>e>>k>>g;
	for(int i=1;i<=g;i++){
		cin>>past[i];
	}
  //输入
	while(m--){
		int a,b,l;
		cin>>a>>b>>l;
		mp[a][b]=l;
		mp[b][a]=l;
	}
  //邻接矩阵存边
	int now=0;
	for(int i=1;i<g;i++){
		TT[past[i]][past[i+1]] = now;
		TT[past[i+1]][past[i]] = now;
		now += mp[past[i]][past[i+1]];
      //past 数组存放的是 T 先生经过的点
  //mp 数组是地图
  //TT[x][y] 表示 T 先生从 x 到 y 的时间 注意无向图双向存边
  //注意时间是在累加的 所以 now 的值在不断叠加
	}
	Dijkstra();
	cout<<d[e]-k;//注意减去初始时间
	return 0;
}
```
若有问题，欢迎大家指出。

**完结撒花 ！**

---

## 作者：☯☯枫☯☯ (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P7192)

~~不扯闲话了~~

## 进入正题

伟大的 $cpp$ 告诉我们，拿到题目一定要看一眼数据范围。于是我们先来看一下点数和边数。发现$n\le10^3$ ，$m\le10^4$，基本就是一个稠密图，而且点数不多，于是我们可以选择使用邻接矩阵来存图。

然后来考虑 $Luka$ 应该怎么走。显然应该让 $T$ 先生先走，于是我们考虑记录每条路的封锁时间。
```
int tt=0;
F(i,1,g-1) {
	t[c[i]][c[i+1]]=t[c[i+1]][c[i]]=tt;
	//考虑其是双向边，应当将其反向再记录一遍 
	//t[i][j]表示从路口i到路口j这一段路的管制开始时刻 
	tt+=f[c[i]][c[i+1]];//tt记录当前时刻 
}
```
然后我们用 $Dijkstra$ 跑一遍最短路即可。

细节见代码（稍微用了一点点宏）：
```cpp
#include<bits/stdc++.h>
#define rd(n) scanf("%d",&n);
#define F(i,a,b) for(register int i=a;i<=b;i++)
using namespace std;
const int N=1e3+10;
int n,m,a,b,k,g,f[N][N];
int c[N],t[N][N],dis[N];
bool vis[N];
struct P {
	int d,t;//d表示节点的编号，t表示到达该点的时间
	bool operator <(const P&a)const {
		return t>a.t;
	}
};
int drive(int u,int v) {
	if(dis[u]>=t[u][v]&&dis[u]<=t[u][v]+f[u][v]-1) {
		/*当到达时间恰好为管制时间
		最小时间为T先生到达时刻加上两倍过路时间
		（T先生过路的时间加上Luka过路的时间，恰好为两倍。） 
		*/
		return (f[u][v]<<1)+t[u][v];
	}
	return dis[u]+f[u][v];//否则就直接加过路需要的时间 
}
void Dij() {
	memset(dis,0x3f,sizeof(dis));//初始化为较大值
	dis[a]=k;
	priority_queue<P>q;//堆优化
	q.push({a,k});//从点a开始，时刻为k
	while(!q.empty()) {
		P t=q.top();
		q.pop();
		if(vis[t.d])continue;
		vis[t.d]=1;
		F(i,1,n) {
			if(f[t.d][i]) { //t.d与i之间存在一条边
				int pos=drive(t.d,i);//计算到达i点的最短时间
				if(dis[i]>pos) {//松弛操作 
					dis[i]=pos;
					q.push({i,dis[i]});
				}
			}
		}
	}
}
int main() {
	rd(n)rd(m)rd(a)rd(b)rd(k)rd(g)
	F(i,1,g)rd(c[i])//c是过路所需时间 
	int u,v,w;
	F(i,1,m) {//邻接矩阵存图 
		rd(u)rd(v)rd(w)
		f[u][v]=w;//双向边 
		f[v][u]=w;
	}
	int tt=0;
	F(i,1,g-1) {
		t[c[i]][c[i+1]]=t[c[i+1]][c[i]]=tt;
		//考虑其是双向边，应当将其反向再记录一遍
		//t[i][j]表示从路口i到路口j这一段路的管制开始时刻
		tt+=f[c[i]][c[i+1]];//tt记录当前时刻
	}
	Dij();
	printf("%d",dis[b]-k);//开车时间应当减去k 
	return 0;
}
```

[AC](https://www.luogu.com.cn/record/44712153)

### 完结撒花！

---

## 作者：Lyco_Reco (赞：1)

最短路好题。

预处理出 T 先生经过每一条路的时间段，在求最短路的过程中判断当前时刻这条路是否能走，如果不能走就等待，直到能走为止。

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <deque>
#include <queue>
#include <iomanip>
#include <map>
#include <unordered_map>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
#define maxn 20010
int n,m,a,b,k,g,dis[maxn],vis[maxn],head[maxn],nxt[maxn<<1],to[maxn<<1],val[maxn<<1],tot,lst[maxn],tag[maxn][2],p,pir[maxn];
struct node{
	int id,val;
	friend bool operator<(node a,node b){
		return a.val>b.val;
	}
};
priority_queue<node> q;
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	void add(int u,int v,int w){
		to[++tot]=v;
		val[tot]=w;
		nxt[tot]=head[u];
		head[u]=tot;
	}
	void bfs(){
		fill(dis+1,dis+n+1,inf);
		dis[a]=k;
		q.push((node){a,k});
		while(!q.empty()){
			int u=q.top().id;
			q.pop();
			if(vis[u]){
				continue;
			}
			vis[u]=1;
			for(int i=head[u];i;i=nxt[i]){
				int v=to[i];
				int delta=0;
				if((tag[i][0]!=tag[i][1])&&dis[u]>=tag[i][0]&&dis[u]<=tag[i][1]-1){
					delta=tag[i][1]-dis[u];
				}
				if(dis[v]>dis[u]+val[i]+delta){
					dis[v]=dis[u]+val[i]+delta;
					q.push((node){v,dis[v]});
				}
			}
		}
	}
	void MAIN(){
		n=rd();
		m=rd();
		a=rd();
		b=rd();
		k=rd();
		g=rd();
		for(int i=1;i<=g;i++){
			lst[i]=rd();
		}
		for(int i=1;i<=m;i++){
			int u=rd(),v=rd(),w=rd();
			add(u,v,w);
			add(v,u,w);
			pir[tot]=tot-1;
			pir[tot-1]=tot;
		}
		int now=0;
		for(int i=1;i<g;i++){
			int u=lst[i];
			for(int j=head[u];j;j=nxt[j]){
				int v=to[j];
				if(v==lst[i+1]){
					tag[j][0]=now;
					now+=val[j];
					tag[j][1]=now;
					tag[pir[j]][0]=tag[j][0];
					tag[pir[j]][1]=tag[j][1];
					break;
				}
			}
		}
		bfs();
		wrt(dis[b]-k);
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}

```

---

## 作者：mbzdf (赞：1)

# P7192 题解

[传送门](https://www.luogu.com.cn/problem/P7192)

## 题目大意
> 有一个 $n$ 点 $m$ 边的带权无向图（权值表示走这条边的耗时），有一个大佬从 $0$ 时刻开始按 $g$ 个点的顺序移动，求从 $k$ 时刻开始走路且不能与大佬同时刻处于同边的你从 $a$ 到 $b$ 的最短路。

## 分析一下

**最短路**题，考虑 Dijkstra。

如果当前拓展的边被占用，就等待至边未被占用。

感性理解一下，这并不影响 Dijkstra。

~~所以这道题的绿在哪？~~

#### 那么具体思路呢

使用 Dijkstra 算法，如果边被占用，则等待至边未被占用。

### 一个需要注意的事情

> 内存限制：**32 MB**

注意一下空间的使用。

## AC 代码 ~~（抄题解的不是好孩子）~~
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
struct line
{
	int l;
	int st, en;
	inline line()
	{
		l = 0x3fffffff;
		en = -1;
	}
}_map[1005][1005];
struct point
{
	int to;
	int l;
	inline bool operator < (point x)
	{
		return l < x.l;
	}
	inline bool operator >= (point x)
	{
		return l >= x.l;
	}
};
struct heap//手写二叉堆（优先队列）
{
	int r;
	inline heap()
	{
		r = 0;
	}
	point g[1000005];
	bool empty()
	{
		return r == 0;
	}
	void add(point x)
	{
		g[++r] = x;
		int i = r;
		while(i > 1)
		{
			if(g[i >> 1] < g[i]) break;
			swap(g[i >> 1], g[i]);
			i >>= 1;
		}
	}
	void add(int to, int l)
	{
		point x;
		x.to = to, x.l = l;
		add(x);
	}
	point pop()
	{
		point v = g[1];
		g[1] = g[r--];
		int i = 1;
		while(i << 1 <= r)
		{
			int son = i << 1;
			if(son < r && g[son + 1] < g[son]) ++son;
			if(g[son] >= g[i]) break;
			swap(g[i], g[son]);
			i = son;
		}
		return v;
	}
}h;
int n, m;
int st, en, tc, g;
int gz[1005];
int dis[1005];
bool vis[1005];
inline void dijkstra(int s)
{
	for(int i = 1; i <= n; ++i)
	{
		dis[i] = 0x3fffffff;
		vis[i] = 0;
	}
	dis[s] = tc;
	h.add(s, tc);
	while(!h.empty())
	{
		int x = h.pop().to;
		if(vis[x]) continue;
		vis[x] = 1;
		for(int i = 1; i <= n; ++i)
		{
			int l = dis[x];
			if(l >= _map[x][i].st && l <_map[x][i].en) l = _map[x][i].en;
			l += _map[x][i].l;
			if(dis[i] > l)
			{
				dis[i] = l;
				h.add(i, l);
			}
		}
	}
	return;
}
int main()
{
	cin >> n >> m;
	cin >> st >> en >> tc >> g;
	for(int i = 1; i <= g; ++i)
		cin >> gz[i];
	for(int i = 1; i <= m; ++i)
	{
		int go, to, l;
		cin >> go >> to >> l;
		_map[go][to].l = _map[to][go].l = l;
	}
	int sum = 0;
	for(int i = 2; i <= g; ++i)
	{
		line &l = _map[gz[i - 1]][gz[i]];
		l.st = sum;
		l.en = (sum += l.l);
		_map[gz[i]][gz[i - 1]] = l;
	}
	dijkstra(st);
	cout << dis[en] - tc << endl;
}
```

---

## 作者：chenhaoyou (赞：1)

## 题目大意
你是一名司机，你要从一个地方另外一个地方运货，一天镇上来了个大人物，给你他的路线，他在走的路都不能走。问你送货的最短时间。
## 思路
其实就是在最短路的模板上加了一个固定时间的限制，我们读入大人物的路线后得出道路封锁的时间，在最短路时如果当前的道路在封锁就在解封的时候再走。其他就是最短路的模板。这里我使用的是迪杰斯特拉加堆优化求最短路。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int w,s,n,m,b,e,k,g,t[1111],x,y,z,a[1111][1111],t1[1111][1111][3],d[1111];
bool vis[1111];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>b>>e>>k>>g;
	for(int i=1;i<=g;i++)
	{
		cin>>t[i];
	}
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		if(a[x][y]==0) a[y][x]=a[x][y]=z;
		else a[y][x]=a[x][y]=min(a[x][y],z);//邻接矩阵存图，注意也许有重边。
	}
	for(int i=1;i<g;i++)
	{
		if(i==1) t1[t[i]][t[i+1]][1]=t1[t[i-1]][t[i]][2];
		else t1[t[i]][t[i+1]][1]=t1[t[i-1]][t[i]][2]+1;
		t1[t[i]][t[i+1]][2]=t1[t[i]][t[i+1]][1]+a[t[i]][t[i+1]]-1;
		t1[t[i+1]][t[i]][1]=t1[t[i]][t[i+1]][1];
		t1[t[i+1]][t[i]][2]=t1[t[i]][t[i+1]][2];//记录道路封锁时间，t1[x][y] 记录从 x 到 y 的封锁时间，注意是双向图。
	}
	memset(d,127,sizeof(d));
	d[b]=k;//司机是从 k 开始的。
	q.push({k,b});
	while(q.size())//dijkstra
	{
		w=q.top().second;
		q.pop();
		if(vis[w]) continue;
		vis[w]=1;
		for(int i=1;i<=n;i++)
		{
			if(a[w][i]>0)
			{
				s=0;
				if(d[w]>=t1[w][i][1] && d[w]<=t1[w][i][2]) s=t1[w][i][2]-d[w]+1;//如果道路被封锁，就要加上等的时间。
				if(d[i]>d[w]+s+a[w][i])
				{
					d[i]=d[w]+s+a[w][i];
					q.push({d[i],i});
				}
			}
		}
		
	}
	cout<<d[e]-k;
	return 0;
}

```


---

## 作者：zhujiangyuan (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7192)

最短路好题。

把路口看作节点，道路看作边，从 $a$ 点到 $b$ 点跑最短路，用 Dijkstra 就行。

记录一下 T 先生到每个点的时间，$t_{x,y}$ 表示 T 先生在 $x$ 点，且准备走道路 $(x,y)$ 的时间。
```cpp
int now=0;
for(int i=1;i<g;i++)
{
	t[a[i]][a[i+1]]=t[a[i+1]][a[i]]=now;
	now+=f[a[i]][a[i+1]];//当前时间累加
}
```

跑 Dijkstra 时判断是否需要松弛，要计算到达 $y$ 点的时间。计算方式：判断到达 $x$ 点时 T 先生是否走上了道路 $(x,y)$，如果走上了，那么到达 $y$ 点的时间为 $t_{x,y}+f_{x,y}\times 2$，其中 $f_{x,y}$ 为经过道路 $(x,y)$ 的时间。如果 T 先生没有走上道路 $(x,y)$，时间为 $d_x+f_{x,y}$，$d_x$ 为到达 $x$ 点的时间。

```cpp
int js(int x,int y)
{
	if(d[x]>=t[x][y]&&d[x]<=t[x][y]+f[x][y]-1)//T 先生在道路上
		return t[x][y]+f[x][y]*2;
	return d[x]+f[x][y];
}
```
最开始在 $a$ 点的时间为 $k$，即 $d_k=k$，最后算出来 $d_b$ 后需要再减去 $k$。所以答案为 $d_b-k$。其余细节见代码。

完整代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define mp make_pair
using namespace std;
const int N=1e3+10;
int n,m,k,g,f[N][N],st,en,a[N],t[N][N];
int d[N];
bool vis[N];
int js(int x,int y)//计算到y点的时间
{
	if(d[x]>=t[x][y]&&d[x]<=t[x][y]+f[x][y]-1)
		return t[x][y]+f[x][y]*2;
	return d[x]+f[x][y];
}
void dijkstra()
{
	memset(d,10,sizeof(d));
	memset(vis,0,sizeof(vis));
	d[st]=k;
	priority_queue<pii,vector<pii>,greater<pii>>q;//小根堆
	q.push(mp(k,st));
	while(q.size())
	{
		int x=q.top().second;q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=1;i<=n;i++)
			if(f[x][i])
			{
				int dis=js(x,i);
				if(d[i]>dis)
				{
					d[i]=dis;//松弛操作
					q.push(mp(dis,i));
				}
			}
	}
}
int main()
{
//    freopen("input.in","r",stdin);
//    freopen("output.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>st>>en>>k>>g;
	for(int i=1;i<=g;i++) cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		f[u][v]=f[v][u]=w;//存双向边
	}
	int now=0;
	for(int i=1;i<g;i++)
	{
		t[a[i]][a[i+1]]=t[a[i+1]][a[i]]=now;//双向边
		now+=f[a[i]][a[i+1]];//累加时间
	}
	dijkstra();
	cout<<d[en]-k;//减去初始时间
    return 0;
}
```

时间复杂度 $O(m\log n)$。

---

## 作者：sieve (赞：0)

# 题解：[P7192 [COCI2007-2008#6] GEORGE](https://www.luogu.com.cn/problem/P7192)

## 思路

spfa 的模板题啊。

因为 Luka 要比 T 先生晚 $k$ 分钟出发，所以我们的初始值就是 $k$。然后储存结构体 $in_{i,j}$ 为 $i$ 到 $j$ 的路在 $l$ 到 $r$ 的时间封了，然后判断当前走的时候是不是封路了，如果是，就等 T 先生走完再走，否则直接通过。

注意在最后输出的答案要减去 $k$，因为是要算走的时间，不是从 T 先生开始走后的时间。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1005,inf=1e18;
int n,m,a,b,k,g,f[N],c[N],dis[N];
pair<int,int> in[N][N];
bool vis[N];
struct edge{
	int v,w;
};
vector<edge> G[N];
void spfa(int s)
{
	for(int i=1;i<=n;++i)
	{
		dis[i]=inf;
		vis[i]=0;
	}
	queue<int> q;
	q.push(s);
	dis[s]=k;
	vis[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(auto V:G[u])
		{
			int v=V.v;
			if(dis[u]>=in[u][v].first&&dis[u]<=in[u][v].second&&(in[u][v].first!=0||in[u][v].second!=0))
			{
				dis[v]=in[u][v].second+V.w;
				if(vis[v]==0)
				{
					q.push(v);
					vis[v]=1;
				}
				continue;
			}
			if(dis[v]>dis[u]+V.w)
			{
				dis[v]=dis[u]+V.w;
				if(vis[v]==0)
				{
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
	return;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>a>>b>>k>>g;
	for(int i=1;i<=g;++i) cin>>f[i];
	for(int i=1;i<=m;++i)
	{
		int x,y,z;
		cin>>x>>y>>z;
		G[x].push_back({y,z});
		G[y].push_back({x,z});
	}
	int lst=0;
	for(int i=2;i<=n;++i)
	{
		int x=f[i-1],y=f[i],tim=0;
		for(auto V:G[x])
		{
			if(V.v==y)
			{
				tim=V.w;
				break;
			}
		}
		in[x][y]={lst+1,lst+tim};
		in[y][x]={lst+1,lst+tim};
		lst=in[x][y].second;
	}
	spfa(a);
	cout<<dis[b]-k;
	return 0;
}
```

---

## 作者：Lydia1010__ (赞：0)

## 本题思路：
这道题其实很简单，我们只需要维护每条边被禁的时间，被禁的时候直接把时间加到没被禁，跑最短路就可以了。
## 实现：
因为每条边只会走一次，所以我们可以开两个数组维护每条边的封闭区间，然后 Dijkstra 跑一遍即可，没什么细节。
## 本题代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1005],pd[1005][1005],l[10005],r[100005];
struct f{int x,k;};
vector<f>s[1005];
int pd1[1005][1005],cnt;
int n,m,dis[1005],vis[1005];
priority_queue<pair<int,int> >q;
void dij(int S,int t){
	for(int i=1;i<=n;i++) dis[i]=1e18,vis[i]=0;
	dis[S]=t;q.push(make_pair(-dis[S],S));
	while(q.size()){
		int p=q.top().second;q.pop();
		if(vis[p]) continue;
		vis[p]=1;
		for(int i=0;i<s[p].size();i++){
			int y=s[p][i].x,k=s[p][i].k,sum=0,num=pd[p][y];
			if(dis[p]>=l[num]&&dis[p]<=r[num]){
				sum=r[num]-dis[p]+1;//cout<<0;
			}
			if(dis[y]>dis[p]+k+sum){
				dis[y]=dis[p]+k+sum;
				q.push(make_pair(-dis[y],y));
			}
		}
	}
}
signed main(){
	cin>>n>>m;
	int S,t,k,g;
	cin>>S>>t>>k>>g;
	for(int i=1;i<=g;i++){cin>>a[i];}
	for(int i=1;i<=m;i++){
		int x,y,k;cin>>x>>y>>k;
		pd[x][y]=++cnt;pd[y][x]=cnt;
		pd1[x][y]=pd1[y][x]=k;
		f op;op.x=y,op.k=k;s[x].push_back(op);op.x=x;
		s[y].push_back(op);
	}
	int t1=0;
	for(int i=1;i<g;i++){
		l[pd[a[i]][a[i+1]]]=t1;
		t1+=pd1[a[i]][a[i+1]];
		r[pd[a[i]][a[i+1]]]=t1-1;
//		cout<<l[pd[a[i]][a[i+1]]]<<" "<<r[pd[a[i]][a[i+1]]]<<endl;
	}
	dij(S,k);
	cout<<dis[t]-k;
	return 0;
}
```

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7192)
# 题目分析
一道图上动态规划问题。

首先观察题目，发现这道题与最短路的模板题唯一的区别是对于有些道路存在通行时间限制。这意味着我们不能用普通的最短路问题的方法。因此考虑类似最短路的图上动态规划。

与普通最短路不同的是，第一步建图的时候要预处理出每条边的时间限制，也就是从 $s$ 到 $t$ 这段时间不能走，这用邻接矩阵可以轻松实现。

令 $f_x$ 表示从起点走到节点 $x$ 所需最短时间。

下面是最短路模板的状态转移方程：
$$f_v=\min(f_v,f_u+dis_{u,v})$$

其中 $dis_{u,v}$ 表示从 $u$ 到 $v$ 的路径的长度。

注意到，这个方程没有时间要求，无法通过此题。但可以在这个方程上稍加修改。这里分两种情况：

1. 若 $u$ 到 $v$ 这条路径上没有通行时限或当前通行的时间不在禁止通行的时限内，那么原方程可以直接使用。
2. 若这条路径通过时正好在时限之内，具体地，设一条从 $u$ 到 $v$ 的路径在时间 $x$ 到 $y$ 之内不能通行，且 $f_u$ 正好满足 $x \leq f_u \leq y$，那么在原方程的基础上，在等式右边还要加上 $y-f_u+1$，也就是等待到 T 先生通过的时间。

因此最终的状态转移方程就是 
$$f_v=\min(f_v,f_u+dis_{u,v}+\max(0,y-f_u+1))$$

其余部分与最短路模板没有区别。

# SPFA 代码
```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
#define M 10001
#define N 1001
using namespace std;
struct edge{
	int u,v;
	int w;
	int id;
	int s,t;
};
edge edgeM[N][N];
vector<edge>e[N];
queue<int>q;
int dis[N],vis[N];
int Tc[N];
void spfa(int x,int k){
	fill(dis,dis+N,0x3ffffff);
	memset(vis,0,sizeof(vis));
	dis[x]=k;
	q.push(x);
	vis[x]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=0;i<e[u].size();i++){
			int v=e[u][i].v,t=0;
			if(dis[u]>=edgeM[u][v].s&&dis[u]<=edgeM[u][v].t){
				t=edgeM[u][v].t-dis[u];
			}
			if(dis[v]>dis[u]+t+e[u][i].w){
				dis[v]=dis[u]+t+e[u][i].w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	} 
	return;
}
int main(){
	int n,m,a,b,k,g;
	cin>>n>>m>>a>>b>>k>>g;
	for(int i=1;i<=g;i++){
		cin>>Tc[i];
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		edgeM[u][v].w=edgeM[v][u].w=w;
		edgeM[u][v].id=edgeM[v][u].id=i;
		e[u].push_back((edge){u,v,w});
		e[v].push_back((edge){v,u,w});
	}
	int nowT=1;
	for(int i=1;i<g;i++){
		int u=Tc[i],v=Tc[i+1];
		edgeM[u][v].s=edgeM[v][u].s=nowT;
		edgeM[u][v].t=edgeM[v][u].t=nowT+edgeM[u][v].w-1;
		nowT+=edgeM[u][v].w;
	}
	spfa(a,k);
	cout<<dis[b]-k;
	return 0;
}
```

---

## 作者：Dtw_ (赞：0)

# 思路
考虑 $n\leq 10^3$ 所以可以开一个数组，用 DFS 预处理出来每条边的限制时间，然后当走到这条边的时候，且正好在不能通行的时候，那就等到可以通行再走，跑一遍 dijkstra 就行。
# Code
```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'

#define TRACE 1
#define tcout TRACE && cout

#define IN(o) insert(o)

#define fi first
#define se second

#define int long long

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int INF = 0x3f3f3f3f3f3f3f3f;

const int P = 998244353;

const int N = 1e6 + 10, M = 1e3 + 10;

int n, m, s, e, k, g;

vector<pair<int, int>> G[M];

int a[M];
pair<int, int> t[M][M];

int p = 2;

void dfs(int u, int fa)
{
	for(auto o : G[u])
	{
		int v = o.fi, w = o.se;
		if(v == a[p])
		{
			t[u][v] = {t[fa][u].se, t[fa][u].se + w};
			t[v][u] = t[u][v];
			p++;
			dfs(v, u);
		}
	}
}

struct Node
{
	int p, d;
	bool operator < (const Node & b) const
	{
		return d > b.d;
	}
};

int d[M];
bool vis[M];

void dijkstra()
{
	for(int i=1; i<=n; i++) d[i] = INF;
	priority_queue<Node> q;
	d[s] = k;
	q.push({s, k});
	while(!q.empty())
	{
		int u = q.top().p;
		q.pop();
		if(vis[u]) continue;
		vis[u] = 1;
		for(auto o : G[u])
		{
			int v = o.fi, w = o.se;
			int now = d[u];
			int x = d[u] + w;
			if(t[u][v].fi <= now && now < t[u][v].se)
			{
				x = t[u][v].se + w;
			}
			if(vis[v] == 0 && d[v] > x)
			{
				d[v] = x;
				q.push({v, d[v]});
			}
		}
	}
}

signed main()
{
	cin >> n >> m >> s >> e >> k >> g;
	for(int i=1; i<=g; i++) cin >> a[i];
	for(int i=1; i<=m; i++)
	{
		int u, v, w;
		cin >> u >> v >> w;
		G[u].push_back({v, w});
		G[v].push_back({u, w});
	}
	dfs(a[1], 0);
	dijkstra();
	cout << d[e] - k;
	return 0;
}
```

---

## 作者：Chu_awa_xing (赞：0)

### P7192 题解
题目难度：
普及+/提高。

实际难度：普及/提高-。
### 题目概括

给定一张 $n$ 个节点，$m$ 条边的无向图，以及 T 先生的行动轨迹。在 T 先生出发 $k$ 分钟后 Luka 从 a 点出发，T 先生和 Luka 不能同时走一条路，求 Luka 从 a 点到 b 点的最短时间。

### 思路
这题的思路就是在 Dijkstra 算法的松弛操作上加一步，如果 Luka 要走的路 T 先生正在走，那就等待到 T 先生离开这条路再往前走。

那我们就要对每条路径的封锁时间进行预处理，用一个二位数组 $T$ 来表示，$T[i][j]$ 表示连接点 $i$ 和点 $j$ 的路径的开始封锁时间和结束封锁时间。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+5;
const int inf=2147483647;
int n,m,a,b,k,g,cnt,f[maxn],vis[maxn],head[maxn],vis2[maxn],waitt=0; 
queue<int> way;
struct mrt{
	int st,ed;
}T[maxn][maxn];
struct edge{
	int to,next,w;
}v[20005];
struct edge2{
	int to,w;
};
vector <edge2> v2[maxn];
void add(int u,int v2,int w){
	v[++cnt].next=head[u];
	v[cnt].to=v2;
	v[cnt].w=w;
	head[u]=cnt;
} 
struct node{
	int d,fd;
	friend bool operator<(node a,node b){  
		return a.fd>b.fd;
	}
}tmp; 
priority_queue<node> q; 
void dij(int s){
	for(int i=1;i<=n;i++){f[i]=inf;}
	f[s]=k;
	tmp.d=s,tmp.fd=0; 
	q.push(tmp);
	while(!q.empty()){
		int u=q.top().d;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=v[i].next){
			if(f[v[i].to]>(long long)f[u]+v[i].w){
				if(f[u]>=T[u][v[i].to].st&&f[u]<T[u][v[i].to].ed){ //如果当前时间处于封锁时间内 
					f[v[i].to]=f[u]+v[i].w+(T[u][v[i].to].ed-f[u]); //加上等待时间 
				}
				else f[v[i].to]=f[u]+v[i].w;
				tmp.fd=f[v[i].to],tmp.d=v[i].to; 
				q.push(tmp);
			}
		}
	}
}
int main(){
	cin>>n>>m;
	cin>>a>>b>>k>>g;
	for(int i=1;i<=g;i++){
		int x;
		cin>>x;
		way.push(x);
	}
	for(int i=1;i<=m;i++){
		int x,y,z;
		cin>>x>>y>>z;
		//双向边 
		add(x,y,z);
		add(y,x,z);
		v2[x].push_back((edge2){y,z});
		v2[y].push_back((edge2){x,z});
	}
	int temp=0;
	//处理T数组 
	while(!way.empty()){
		int x=way.front();
		way.pop();
		T[x][way.front()].st=temp;
		T[way.front()][x].st=temp; //双向边 
		for(int i=0,sz=v2[x].size();i<sz;i++){
			if(v2[x][i].to==way.front()){
				T[x][way.front()].ed=T[x][way.front()].st+v2[x][i].w;
				T[way.front()][x].ed=T[x][way.front()].st+v2[x][i].w;
			}
		}
		temp=T[x][way.front()].ed;
	}	
	
	dij(a);	
	cout<<f[b]-k<<endl; //别忘了答案要减去两个人出发的时间差 
	return 0;
}
```

---

## 作者：Zhuluoan (赞：0)

## 题目简述
给定一张 $n$ 个点 $m$ 条边的无向图，从 $u_i \rightarrow v_i$ 需要用时 $w_i$ 分钟。有一位 T 先生从 $0$ 时刻按有 $g$ 个点的序列顺序移动，即 $v_1 \rightarrow v_2 \rightarrow \cdots \rightarrow v_g$。还有一位卡车司机 Luka 从 $k$ 时刻开始从 $a$ 点出发，Luka 不能与 T 先生在同一时间走同一条路，问 Luka 从 $a$ 点到 $b$ 点的最短路。

## 题目分析

注意到 T 先生的移动顺序是一定的，所以我们可以先处理出每一个时刻 T 先生在哪一条边上。

接下来，我们考虑使用 Dijkstra 算法求最短路，设当前队首可以扩展的点为 $u$，从点 $a$ 到点 $u$ 所需的最短时间为 $dis_u$，与 $u$ 的连边为 $u \rightarrow v$，如果 T 先生在 $dis_u$ 时刻恰好走在 $u \rightarrow v$ 这条边上，我们可以让 Luka 等到 T 先生走开再走这条边，就是将边权增大在进行松弛。如果 T 先生没走的话直接松弛就好了。

最后答案是 $dis_b-k$，因为 Luka 是从 $k$ 时刻开始走的。

## 代码
```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int N=1e3+10;
const int M=1e4+10;
int n,m,a,b,k,g,t[N],cnt,head[N],cnt2,vis1[N],E[N][N],dis[N],vis2[N][N]; 
pair<int,int> vis[M*1000];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
struct edge
{
	int to,next,value;
}e[M*2];
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
	    if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
	    x=(x<<1)+(x<<3)+ch-48;
	    ch=getchar();
	}
	return x*f;
}
inline void write(int x)
{
    if(x<0)
	{
    	putchar('-');
		x=-x;
	}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
void addedge(int u,int v,int w)
{
	e[++cnt]={v,head[u],w};
	head[u]=cnt;
}
int main()
{
	n=read();
	m=read();
	a=read();
	b=read();
	k=read();
	g=read();
	for(int i=1;i<=g;i++)
	{
		t[i]=read();
	}
	for(int i=1;i<=m;i++)
	{
		int u=read();
		int v=read();
		int w=read();
		addedge(u,v,w);
		addedge(v,u,w);
		E[u][v]=E[v][u]=w;
	}
	for(int i=1;i<=g-1;i++)
	{
		for(int j=1;j<=E[t[i]][t[i+1]];j++)
		{
			vis[++cnt2]={t[i],t[i+1]};
		}
		vis2[t[i]][t[i+1]]=cnt2;
	}
	memset(dis,0x3f,sizeof dis);
	q.push({k,a});
	dis[a]=k;
	while(!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if(vis1[u]) continue;
		vis1[u]=1;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to,w=e[i].value; 
			if((vis[dis[u]].first==u&&vis[dis[u]].second==v)||(vis[dis[u]].first==v&&vis[dis[u]].second==u))
			{
				w+=vis2[vis[dis[u]].first][vis[dis[u]].second]-dis[u];
			}
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				q.push({dis[v],v});
			}
		}
	}
	write(dis[b]-k);
	return 0;
}
```

---

## 作者：_YyD_ (赞：0)

**题目大意（来自本人）：**

有一个无向图 $N$ 个点，$M$ 条边。 有一个领导从 $0$ 时刻开始在图中走，按顺序经过 $G$ 个点。 你从 $K$ 时刻开始走，要从 $A$ 走到 $B$，领导在某条路上走的时候，你不能走，但你可以等在那里等他走完这条路。 请问你至少要花多久。

**思路：**

考虑你走过某一条路时会不会受领导影响，再跑 $dijkstra$ 就好了。

**手把手实现：**

- 存图

关注数据范围 $2 \le n \le 10^3$。

从中可以看出邻接矩阵可以存的下。

Code：
```cpp
for(int i=1;i<=m;i++){
	int u,v,w;
	cin>>u>>v>>w;
	mp[u][v]=w;
	mp[v][u]=w;
}
```

- 领导通过某两个道路时的时刻

注意由于是按照顺序经过的，故需要累加。

Code：

```cpp
int tmp=0;
for(int i=1;i<g;i++){
	s[z[i]][z[i+1]]=tmp;
	s[z[i+1]][z[i]]=tmp;
	tmp+=mp[z[i]][z[i+1]];
}
```


- dijkstra 的改变

这里注意的就是领导对你的限制。

如果受到限制，结束时刻应加上领导和你两个人的时间，故需 $\times2$。

Code:
```cpp
int suan(int u,int v){
	if(dis[u]>=s[u][v]&&dis[u]<=s[u][v]+mp[u][v]-1)
   		return s[u][v]+mp[u][v]*2;//受到限制
	return dis[u]+mp[u][v];//自由活动
}
```

**完整 Code：**

```cpp
#include<bits/stdc++.h>
#define _ ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define lep(i,l,r) for(int i=l;i>=r;i--)
using namespace std;
const int N=1e3+10;
int n,m,a,b,k,g,mp[N][N],z[N],s[N][N],dis[N];
bool book[N];
struct node {
	int d,t;
	bool operator <(const node&a)const {
		return t>a.t;
	}
};
int suan(int u,int v) {
	if(dis[u]>=s[u][v]&&dis[u]<=s[u][v]+mp[u][v]-1)
		return s[u][v]+mp[u][v]*2;
	return dis[u]+mp[u][v];
}
void dijkstra() {
	dis[a]=k;
	priority_queue<node>q;
	q.push({a,k});
	while(!q.empty()) {
		node t=q.top();
		q.pop();
		if(book[t.d])continue;
		book[t.d]=1;
		rep(i,1,n) {
			if(mp[t.d][i]) {
				int pos=suan(t.d,i);
				if(dis[i]>pos) {
					dis[i]=pos;
					q.push({i,dis[i]});
				}
			}
		}
	}
}
//此处参考了楼上dalao的对列优化 
int main() {
	cin>>n>>m>>a>>b>>k>>g;
	rep(i,1,g) {
		cin>>z[i];
	}
	rep(i,1,1000) dis[i]=1145141919;
	int u,v,w;
	rep(i,1,m) {
		int u,v,w;
		cin>>u>>v>>w;
		mp[u][v]=w;
		mp[v][u]=w;
	}
	int tmp=0;
	rep(i,1,g) {
		s[z[i]][z[i+1]]=tmp;
		s[z[i+1]][z[i]]=tmp;
		tmp+=mp[z[i]][z[i+1]];
	}
	dijkstra();
	cout<<dis[b]-k;
	return 0;
}
```


---


# [COCI 2020/2021 #3] Vlak

## 题目描述

Nina 和 Emilija 在纸上做游戏。刚开始，纸是空白的。在一个回合里，一个玩家将一个字母加入到纸上一个单词的末尾。接着，二者交替顺序。规定 Nina 为先手。

玩家们选择字母时必须遵循这样的原则：每一次添加字母**后**的单词必须是该玩家最喜爱歌曲中某个单词的前缀。如果某个玩家无法继续执行它的回合，那么她就输了。

如果两位玩家选择的策略都是最佳的，请判断谁是赢家。

## 说明/提示

#### 样例 1 解释

如果 Nina 先写下字母 `b`，那么 Emilija 将必须写下 `b`，然后 Nina 将继续写下 `b`。则当前的单词为 `bbb`，而 Emilija 将无法继续执行下一步，因此 Nina 获胜。

如果 Nina 先写下字母 `a`，那么 Emilija 将写下 `b`。单词将变成 `ab`，因此 Nina 将无法继续执行下一步，因此她将输掉。

#### 数据规模与约定

对于其中 $40$ 分的数据，单词长度总和不超过 $2000$。

对于 $100\%$ 的数据，单词长度总和不超过 $200000$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf)  _T2 Vlak_。**

## 样例 #1

### 输入

```
2
aaa
bbb
3
aab
aba
bbb```

### 输出

```
Nina```

## 样例 #2

### 输入

```
2
acg
beh
2
adi
bfj```

### 输出

```
Emilija```

## 样例 #3

### 输入

```
3
ja
sam
vlak
5
sto
zgazit
ce
te
mali```

### 输出

```
Nina```

# 题解

## 作者：WIGYF (赞：7)

### 题目分析
两个人轮流写字符，组成的必须是自己持有的某一个单词的前缀，先写不了的人为败方，一个经典的博弈。

可以用一个字典树存储所有的输入单词，再在其之上进行一次搜索，作为先手的那个人只要有的单词中有至少一个可以保证必胜，既是胜者。

------------
### 奉上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int tr[200005][30],ss;
int f[200005];
string s;
bool b[2][200005];
inline void add(string st,int bo)
{
	int siz=st.size(),w=0;
	for(int k=0; k<siz; k++)
	{
		if(!tr[w][s[k]-'a'+1]) tr[w][s[k]-'a'+1]=++ss;
		w=tr[w][s[k]-'a'+1];
		b[bo][w]=1;
	}
	b[bo][w]=1;
}
int hanshu(int u,int r)
{
	if(~f[u]) return f[u];
	if(r==0)
	{
		for(int k=1; k<=26; k++)
		{
			if(!tr[u][k]||!b[0][tr[u][k]]) continue;
			if(!hanshu(tr[u][k],1)) return f[u]=0;
		}
		return f[u]=1;
	}
	else
	{
		for(int k=1; k<=26; k++)
		{
			if(!tr[u][k]||!b[1][tr[u][k]]) continue;
			if(hanshu(tr[u][k],0)) return f[u]=1;
		}
		return f[u]=0;
	}
}
int main()
{
	memset(f,-1,sizeof(f));
	cin>>n;
	for(int i=1; i<=n; ++i) cin>>s,add(s,0);
	cin>>m;
	for(int i=1; i<=m; ++i) cin>>s,add(s,1);
	hanshu(0,0);
	if(!f[0]) cout<<"Nina";
	else cout<<"Emilija";
	return 0;
}
```


---

## 作者：_determination_ (赞：4)

分析题目，看到前缀，联想到字典树。看到输赢，联想到博弈。

我们建好字典树，并且开数组存储这个字符串是谁的前缀。现在我们设计状态。

显然，叶子结点是必败态，然后 `dfs` 往下跑，找到叶子返回，剩下的节点直接跑即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define inf 1e18
#define endl '\n'
#define debug puts("IAKIOI")
int t[200010][30],tot,flag[200010][30][2];
bool SG[200010][2];
void insert(string s,int op)
{
	int node=0;
	for ( int i = 0 ; i < s.size() ; i++ )
	{
		SG[node][op]=1;
		flag[node][s[i]-'a'][op]=1;
		if(t[node][s[i]-'a']==0)
		{
			t[node][s[i]-'a']=++tot;
		}
		node=t[node][s[i]-'a'];
	}
	SG[node][op]=0;
}
string str[2]={"Emilija","Nina"};
void dp(int x,int op)
{
//	printf("dp %d %d:\n",x,op);
	if(SG[x][op]==0)
	{
//		printf("return 0\n");
		return;
	}
	for ( int i = 0 ; i < 26 ; i++ )
	{
		if(!flag[x][i][op])
		{
			continue;
		}
		dp(t[x][i],op^1);
		if(SG[t[x][i]][op^1]==0)
		{
//			printf("=1\n");
			SG[x][op]=1;
			return;
		}
	}
//	printf("=0\n");
	SG[x][op]=0;
}
signed main()
{
	freopen("vlak.in","r",stdin);
	freopen("vlak.out","w",stdout);
	int n,m;
	cin >> n ;
	for ( int i = 1 ; i <= n ; i++ )
	{
		string s;
		cin >> s;
		insert(s,0);
	}
	cin >> m;
	for ( int i = 1 ; i <= m ; i++ )
	{
		string s;
		cin >> s;
		insert(s,1);
	}
	dp(0,0);
	cout << str[SG[0][0]];
	return 0;
}
```

---

## 作者：Hasinon (赞：4)

## 题目大意
- 两个人轮流写字母，每个人写字母时必须满足写下此字母后总字符串是自己指定的单词的前缀。无法写下字母时对方获胜。 
- 单词长度总和小于等于 200000

## 题目解法
**这道题我们可以用字典树加一点贪心做出来**
[便于出门右转的门](https://blog.csdn.net/weixin_39778570/article/details/81990417) 

先把树建好，每条边额外记录下归属人信息。然后在树上 dfs。把当前进行选择的选手写字母的过程转换当前点选边，点的深度表示当前选手。且当前选手只能选属于自己的边。

### dfs 求答案思路
（设当前选择的选手是 Nina，简写为 N，他的对手是 Emilija，简写为 E。）  

**PART 1**  
dfs 中往下找边时，如果 N 找到一条边属于 N 而不属于 E 。那么 N 以最优策略选择这条边。E 在下一步进行选择的时候一定无边可选，N也就获胜了。
（如果一条边不属于 E，那这条边下面的边一定也不属于E） 

所以在进行选择的时候，我们如果找到一条边属于当前选手而不属于对手。那从起点选到这条边的过程就能使得当前选手胜利。直接返回选到达当前点的边能够使当前选手获胜。 

**PART 2**  
往下找边时。如果 N 找不到任何属于 N 的边（如果已经优先考虑 PART 1，那么此时应为压根没有任何边。即到达了字典树的叶子结点），也没法往下选了。E 也就获胜了

所以在进行选择的时候，我们如果任何属于当前选手的边。也应直接返回选到达当前点的边能够使对手获胜。 

**PART 3**  
往下找边时。如果 N 找得到一些边属于 N 也属于 E。那么我们每条边都选选试试。只要选其中一条边能使得 N 必胜，那么 N 一定会以最优策略选这条边。但如果没有任何边能使得 N 必胜，那么到达当前点以后 E 必胜。

所以在进行选择的时候，我们如果任何属于当前选手也属于对手的边。往这些边全部 dfs 一遍。只要其中一条边的返回值表示选它能使得当前选手必胜。那就直接返回选到达当前点的边能够使当前选手获胜。 但如果一条边都找不到。那就返回对手获胜。 

**代码就要比文字简洁多了**
## CODE
```cpp

#include<bits/stdc++.h> 
#define ll long long
#define G getchar() 
using namespace std; 
struct node{
	ll to;
	bool be,bn;
}; 
node tree[200005][26];
ll tto=0;
inline ll gt(){
	ll k=0,t=1;char c=G;
	while(c<'0'||'9'<c){if(c=='-') t=-1;c=G;}
	while('0'<=c&&c<='9'){k=k*10+c-'0';c=G;}
	return k*t;
}
// 选手选择的字符串，字符串下标，点编号，选手编号
inline void build(string s,ll sto,ll ord,bool spe){
	if(sto>=s.size()) return;
	if(tree[ord][s[sto]-'a'].to==0)	tree[ord][s[sto]-'a'].to=++tto;
	if(!spe) tree[ord][s[sto]-'a'].bn=1; else tree[ord][s[sto]-'a'].be=1;
	build(s,sto+1,tree[ord][s[sto]-'a'].to,spe);
}
// 根据深度判断当前选手，进而判断优胜选手
inline bool rt(ll dep){
	if(dep%2==0) return 0; else return 1;
}
bool dfs(ll ord,ll dep){
	queue <ll> q;
	for(register int i=0; i<26; i++)
	{
		// PART 1
		if(((!rt(dep)&&tree[ord][i].bn&&!tree[ord][i].be)||(rt(dep)&&tree[ord][i].be&&!tree[ord][i].bn)))
			return rt(dep);
		// PART 2找边
		else if(((!rt(dep)&&tree[ord][i].bn)||(rt(dep)&&tree[ord][i].be)))	
			q.push(i); 
	}
	if(q.size())// PART 2搜边
	{
		bool ab=0;
		while(q.size())
		{
			ll ti=q.front(); q.pop();
			bool aba=dfs(tree[ord][ti].to,dep+1);
			if(rt(dep)==aba)
			{
				ab=1;
				break;
			}
		}	
		if(ab==1) return rt(dep);
		else return !rt(dep);
	}
	else return rt(dep);// PART 3
}
int main(){
	ll n=gt(); string s;
	for(register int i=1; i<=n; i++){
		cin>>s;
		build(s,0,0,0); //建树
	}
	ll m=gt();
	for(register int i=1; i<=m; i++){
		cin>>s;
		build(s,0,0,1); //建树
	}
	if(!dfs(0,0))	printf("Nina");
	else printf("Emilija");
	return 0;
}	
	
``

---

## 作者：_zexal_ (赞：3)

看到题目中有**前缀**二字，且还要求我们在前缀上做操作，不妨先把所有单词放在字典树上。接下来，我们考虑博弈的过程，一方想要战胜另一方，只有可能是某方出完后，另一方的**前缀接不上了或单词到头了**两种情况。考虑使用搜索，模拟出先手和后手交替走即可，由于最优策略，当先手找到任何一条是自己结尾的路径时，则直接返回该状态下自己获胜，否则该状况下对手获胜。返回搜索上一层，继续按照这样的方法判断，直到返回最开始双方皆没开始时。

---

## 作者：RegisterFault (赞：0)

根据题意，由于单词需要是歌曲列表中的前缀，所以可以建出 Trie 树，在树上进行搜索。

将 Nina 的歌曲列表树记为 $N$，Emilija 的记为 $E$。当前节点在 $N$ 上为 $p$ 号节点，在 $E$ 上为 $q$ 号节点。下面分几种情况讨论：

 - 当前该 Emilija 走，$p$ 没有儿子。返回 Nina 赢。
 
 - 当前该 Nina 走，$p$ 有儿子 $v$ 而 $q$ 没有。Nina 赢。
 
 - 当前该 Nina 走，$p, q$ 都有儿子 $v$。往 $v$ 儿子走有 Nina 的必胜策略。Nina 赢。
 
 如果这三种情况都没有，则返回 Emilija 赢。
 
 对于 Emilija 的情况，反之亦然。
 
 参考代码使用指针写法。
 
```cpp
#include <iostream>
#include <cstring>

using namespace std;

string s; int n, m;
struct node {
	node *s[26]; bool ed;
	node() {
		for (int i = 0; i < 26; i ++ )
			s[i] = NULL;
		ed = false;
	}
}*root1, *root2;
void insert(node *p, string s) {
	node *u = p; 
	for (auto i : s) {
		int v = i - 'a';
		if (u -> s[v] == NULL) u -> s[v] = new node();
		u = u -> s[v]; u -> ed = false;
	} u -> ed = true;
}
bool dfs(node *p, node *q, int u) {
	if (u == 0 and p -> ed) return 1;
	if (u == 1 and q -> ed) return 0;
	if (u == 0) {
		for (int i = 0; i < 26; i ++ ) {
			if (p -> s[i] == NULL) continue;
			if (q -> s[i] == NULL) return 0;
			if (!dfs(p -> s[i], q -> s[i], u ^ 1)) return 0;
		} return 1;
	} else {
		for (int i = 0; i < 26; i ++ ) {
			if (q -> s[i] == NULL) continue;
			if (p -> s[i] == NULL) return 1;
			if (dfs(p -> s[i], q -> s[i], u ^ 1)) return 1;
		} return 0;
	}
}
int main() {
	root1 = new node(); root2 = new node();
	ios::sync_with_stdio(false); 
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	while (n -- ) cin >> s, insert(root1, s);
	cin >> m;
	while (m -- ) cin >> s, insert(root2, s);
	if (!dfs(root1, root2, 0)) puts("Nina");
	else puts("Emilija"); return 0;
}
```

---

## 作者：OIerBoy (赞：0)

# 分析
因为它要求必须是为喜欢的歌的前缀，那么我们就很容易想到建一个字典树记录所有歌。

在记录所有歌的同时，再用一个变量来表示这一段前缀是公共的，还是只有 Nina 或 Emilija 有。

例如样例数据：
```
2
aaa
bbb
3
aab
aba
bbb
```
建出的字典树如图:

![](https://cdn.luogu.com.cn/upload/image_hosting/w1ab3xe5.png)

这里的 $1$ 表示的是 Nina 的前缀，$2$ 表示的是 Emilija 的前缀，$3$ 表示是公共前缀。

因为是回合制的游戏，所以字典树的相邻两层是由不同的人来选择的。

我们只需要在字典树上跑一个 dfs，每一次来判断上一层的人的选择是否可行。

即如果第 $i$ 层的第 $j$ 个字符，如果这个人可以通过选**下一层**的一个字符获胜，那么就说明另一个人**不应该选择**第 $i$ 层的第 $j$ 个字符。

反之如果这个人怎么选都不可以获胜，那么就说明另一个人**可以**通过第 $i$ 层的第 $j$ 个字符获胜。

可能有点绕，细节请看代码。
# Code
```cpp
#include<bits/stdc++.h>
#define N 200005
#define Mod 1000000007
#define int long long
#define For(i,j,k) for(int i=j;i<=k;++i)
#define FoR(i,j,k) for(int i=j;i<k;++i)
#define FOR(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
struct Node{
	int i,k;
};
int n,m,tot,ans;
Node ch[N<<1][30];
string s;

void make(int k){//建字典树 
	int len=s.size(),u=0;
    For(i,0,len-1){
    	int c=s[i]-'a';
        if(!ch[u][c].i)ch[u][c].i=++tot;
		if(ch[u][c].k==0)ch[u][c].k=k;//如何没有出现过，那就只有这一个人 
        if(ch[u][c].k!=k)ch[u][c].k=3;//如何另一个人也有这个前缀，那这就是公共的 
		u=ch[u][c].i;
    }
    return;
}

bool dfs(int u,int p){
	int k=0;
	For(i,0,25)
	if(ch[u][i].i!=0){
		if(ch[u][i].k==3)k=dfs(ch[u][i].i,!p);
		if(ch[u][i].k==1&&p==0)return 0; 
		if(ch[u][i].k==2&&p==1)return 0;
		if(k)return 0;
		//如果p这个人可以获胜，即另一个人不应选u，返回0 
	}
	return 1;
	//如果p这个人怎么选都获胜不了，那么另一个人就可以选u，返回1 
}

signed main(){
	cin>>n;
	For(i,1,n){
        cin>>s;
        make(1);//1表示 Nina 
    }
    
	cin>>m;
	For(i,1,m){
		cin>>s;
		make(2);//2表示 Emilija 
	}
	
	For(i,0,25)
	if(ch[0][i].i!=0){
		ans=dfs(ch[0][i].i,1);
		//0表示 Nina 
		//1表示 Emilija 
		
		if(ans){//如何可以获胜就输出 Nina 
			cout<<"Nina";
			return 0;
		}
	}
	//如何 Nina怎么选都不能获胜，就输出 Emilija 
	cout<<"Emilija";
	return 0;
}
```

---

## 作者：Mu_leaf (赞：0)

简单贪心 dfs 题。

### 【思路】：
看到单词前缀就可以尝试用**字典树**来做。

有一个显而易见的结论就是当先手从一个节点可以走向一个有必胜策略的子树时，则先手必赢。

可以分成两种情况讨论：

### Part 1:

Nina 先手，则若 Nina 想要获胜则只需要有一颗子树有必胜策略即可，因为 Nina 只需要填能必胜的字母就可以了。

### Part 2:

Emilija 先手（即 Nina 已经行动完，轮到了 Emilija），则若 Nina 想赢，则必须所有子树对于 Nina 来说都是必胜态，不然只要有一个必败态则 Emilija 一定可以走向对于 Nina 来说的必败态。

根据上诉结论，用普通递归将子树对于 Nina 是否有必胜策略求出来转移到整棵树即可。

代码比文字简洁多了：

```cpp:

#include <bits/stdc++.h>

using namespace std;

inline void read(int &x){
	int f=1;x=0;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+c-48,c=getchar();
	x*=f;
}
const int N=2e5+5;
int n,m,siz,sum;
int a[N];
int f[N][2];
int cnt,trie[N][26],val[N],vis[2][N];
void inseter(int id,string s){
	int l=s.length();
	s=' '+s;
	for(int i=1;i<=l;i++) a[i]=s[i]-'a'+1;
	int root=0;
	for(int i=1;i<=l;i++){
		if(trie[root][a[i]]==-1){
			trie[root][a[i]]=++cnt;
		}
		root=trie[root][a[i]];
		vis[id][root]=1;
	}
}
int dfs(int x,int pd){
	int cnt1=0,ret;
	for(int i=1;i<=26;i++){
		if(vis[pd][trie[x][i]]) ret=i,cnt1++;
	}
	if(cnt1==0){
		if(pd) return 1;
		return 0;
	}
	if(cnt1==1){
		return dfs(trie[x][ret],pd^1);
	}int cur;
	if(pd){
		cur=1;
		for(int i=1;i<=26;i++){
			if(vis[pd][trie[x][i]]==0) continue;
			cur&=dfs(trie[x][i],pd^1); 
		}
	}else{
		cur=0;
		for(int i=1;i<=26;i++){
			if(vis[pd][trie[x][i]]==0) continue;
			cur|=dfs(trie[x][i],pd^1);
		}
	}return cur;
}
int main(){
//	freopen("vlak.in","r",stdin);
//	freopen("vlak.out","w",stdout);
	cin >> n;
	memset(trie,-1,sizeof(trie));
	memset(f,-1,sizeof(f));
	for(int i=1;i<=n;i++){
		string s;
		cin >> s;
		inseter(0,s);
	}
	cin >> m;
	for(int i=1;i<=m;i++){
		string s;
		cin >> s;
		inseter(1,s);
	}
	if(dfs(0,0)) puts("Nina");
	else puts("Emilija");
	
	
	
	return 0;
}
/*
2
aaa
bbb
3
aab
aba
bab
*/
```

---


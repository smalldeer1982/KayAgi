# [COCI 2020/2021 #4] Vepar

## 题目描述

给定两组正整数 $\{a,a+1,\cdots,b\}$ 和 $\{c,c+1,\cdots,d\}$。判断 $c \cdot (c+1)\cdots d$ 能否被 $a \cdot (a+1)\cdots b$ 整除。

## 说明/提示

#### 样例 1 解释

按照题意分别相乘得到 $9 \times 10=90$ 和 $3 \times 4 \times 5 \times 6=360$。由于 $90$ 能被 $360$ 整除，因此输出 `DA`。

我们得到 $2 \times 3 \times 4 \times 5=120$ 和 $7 \times 8 \times 9=504$。而 $120$ 不能被 $504$ 整除，因此输出 `NE`。

#### 数据规模与约定

本题**不采用捆绑评测**，通过对应测试点就可以拿到对应的分数，但有若干个约束。

| 约束编号 | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $a_i,b_i,c_i,d_i \le 50$ |
| $2$ | $20$ | $a_i,b_i,c_i,d_i \le 1000$ |
| $3$ | $10$ | $a_i=1$ |
| $4$ | $30$ | 无 |

对于 $100\%$ 的数据，$1 \le t \le 10$，$1 \le a_i \le b_i \le 10^7$，$1 \le c_i \le d_i \le 10^7$。

#### 说明

**本题分值按 COCI 原题设置，满分 $70$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf)  _T2 Vepar_。**

## 样例 #1

### 输入

```
2
9 10 3 6
2 5 7 9```

### 输出

```
DA
NE```

## 样例 #2

### 输入

```
6
1 2 3 4
1 4 2 3
2 3 1 4
1 3 2 4
19 22 55 57
55 57 19 22```

### 输出

```
DA
NE
DA
DA
DA
DA```

# 题解

## 作者：Silence_water (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P7281)

----

$Description$

> 给定两组正整数 $\{a,a+1,\cdots,b\}$ 和 $\{c,c+1,\cdots,d\}$。判断 $c·(c+1)\cdots d$ 能否被 $a·(a+1)\cdots b$ 整除。

----

$Analyse$

为了描述方便，令 $x=a·(a+1)\cdots b$，$y=c·(c+1)\cdots d$。

对于整除类的题目，容易想到当 $x\%y=0$ 时，对于每个在 $y$ 中出现的质因数 $p$ 必在 $x$ 中出现，且在 $x$ 中出现次数更多。那么我们可以对 $x$ 和 $y$ 进行分解质因数，然后计算质因数 $p$ 出现次数并比较。

对于本题，由于 $x$ 为多数相乘，且范围较大，考虑通过计算出质因子 $p$ 在 $b!$ 中出现的次数和在 $a-1$ 中出现的次数。那么将两者相减就是 $p$ 在 $x$ 中出现的次数。为了方便枚举质因子，这里用欧拉筛法将所有质数线性筛出。

----

$Pay~attention$

注意到 $n!$ 中质因子 $p$ 的数量等于 $1\sim n$ 中 $p$ 的数量和。

证明：（摘自 [网络](https://blog.csdn.net/qq_42815188/article/details/104760277)）

在 $1\sim n$ 中，$p$ 的倍数，即至少包含 $1$ 个质因子 $p$ 的有 $\lfloor \frac{n}{p} \rfloor$ 个。

而 $p^2$ 的倍数，即至少包含 $2$ 个质因子 $p$ 的有 $\lfloor \frac{n}{p^2}\rfloor$ 个。但其中至少包含 $1$ 个质因子已经在 $\lfloor \frac{n}{p} \rfloor$ 里统计过，所以只需要再统计第 $2$ 个质因子，即累加上 $\lfloor \frac{n}{p^2}\rfloor$，而不是 $2 \times \lfloor \frac{n}{p^2}\rfloor$。

综上所述，$n !$ 中质因子 $p$ 的个数为：

$$\lfloor \frac{n}{p}\rfloor+\lfloor \frac{n}{p^2}\rfloor+\lfloor \frac{n}{p^3}\rfloor+\lfloor \frac{n}{p^{\lfloor{\log_p} n\rfloor}}\rfloor=\sum\limits_{p^k\le n}{\lfloor \frac{n}{p^k}\rfloor}$$

----

$Solution$

欧拉筛法部分是板子，此处就不放了。

计算质因子出现次数部分如下：

```cpp
int count(int x,int a)
{
	int sum=0;
	while(x)
	{
		sum+=x/a;
		x/=a;
	}
	return sum;
}
```

判断整除部分如下：

```cpp
for(int i=1;i<=cnt&&pri[i]<=b;i++)
{
	int a_b=count(b,pri[i])-count(a-1,pri[i]);
	int c_d=count(d,pri[i])-count(c-1,pri[i]);
	if(a_b>c_d)
	{
		sol=false;
		break;
	}
}
```

---

$The~end$

客官看完别忘了点个赞哦~

---

## 作者：B天选之子B (赞：6)

## 题目描述如下

- 输入四个数，分别是两个区间的首和尾。

- 判断第一个区间所有数的乘积能否整除第二个区间所有数的乘积

## 解题思路

**因为数字比较大，不可以考虑最简单的模拟。**

- 从一乘到十的七次方，数字太大很难直接模拟。

- 这边考虑的比较每个质因子的个数。

- 由于十的七次方内的质因子巨多，直接找肯定会超时，所以用到欧拉筛法。

**最后解题方法就是欧拉筛法找质因子个数，然后比较每个质因子的个数。**

## 欧拉筛法

欧拉筛法时间复杂度是所有筛法最低的。

欧拉筛法就是筛掉每个质数的倍数，这样不会重复筛出。

```
void olsf(int n) {
	for(int i=2; i<=n; i++) {
		if(vis[i]==0)
			prime[++cnt]=i,vis[i]=1;
		for(int j=1; j<=cnt; j++) {
			if(prime[j]*i>n)break;
			vis[prime[j]*i]=1;
			if(i%prime[j]==0)break;
		}
	}
}
```

## 判断质因子个数

-  用欧拉筛法筛出质数后存进一个数组。

- 一个区间的质因数等于从一到区间末尾这个质数减去从一到这个区间起点减一。

**总的来说不是很难，但是要注意小细节。**

## 奉上代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int vis[10000010];
int prime[10000010];
int cnt;
int a,b,c,d;
void olsf(int n) {
	for(int i=2; i<=n; i++) {
		if(vis[i]==0)
			prime[++cnt]=i,vis[i]=1;
		for(int j=1; j<=cnt; j++) {
			if(prime[j]*i>n)break;
			vis[prime[j]*i]=1;
			if(i%prime[j]==0)break;
		}
	}
}
int mm(int a,int b) {//算出从一到 a 里面 b 的个数。
	int sum=0;
	while(a!=0) {
		sum+=a/b;
		a/=b;
	}
	return sum;
}
bool close() {
	int j=1,x,y,x1,y1;
	for(int i=1; i<=cnt&&prime[i]<=max(b,d); i++)
		if(mm(d,prime[i])-mm(c-1,prime[i])<mm(b,prime[i])-mm(a-1,prime[i]))
			return 0;
	return 1;
}
main() {
	olsf(1e7);
	scanf("%d",&t);
	for(int i=1; i<=t; i++) {
		scanf("%d%d%d%d",&a,&b,&c,&d);
		if(close()==0)
			printf("NE\n");
		else printf("DA\n");
	}
	return 0;
}
```
**还有不懂的可以私信我。**

---

## 作者：yxy666 (赞：3)

好不容易$A$ 了这道题，当然要用代码和想法造福人类啊！

题意：给我们 $T$ 组数据，每组给我们一个 $a,b,c,d$,如果  $a*(a+1)*…b$ 能整除 $c*(c+1)*...d$ 的话，输出 $DA$,否则输出 $NE$ 。

我一开始没有什么好的想法，就中规中矩地打暴力，从 $a$ 枚举到 $b$，分解质因数，然后把从 $c$ 枚举到 $d$，也分解质因数。如果有一个质因数在 $a*(a+1)*…b$ 中的次数比在  $c*(c+1)*...d$ 的次数高，那么就肯定是无法整除的，果断输出 $NE$ ，否则就输出 $DA$。

$code$ :
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000005,maxe=500005;
int T,a,b,c,d,k,tot,zhi[maxe],hash[2][maxe];
bool vis[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读
void make_p(){
	memset(vis,1,sizeof vis);
	vis[0]=vis[1]=0;
	for(int i=2;i<=sqrt(1000000);i++)if(vis[i])
	for(int j=2;j<=1000000/i;j++)vis[i*j]=0;
	for(int i=2;i<=1000000;i++)if(vis[i])zhi[++k]=i;
}//筛法挖素数
int find(int x){
	int L=1,R=k,mid;
	while(L<=R){
		mid=(L+R)/2;
		if(zhi[mid]==x)return mid;
		if(zhi[mid]>x)R=mid-1;else L=mid+1; 
	}
}//二分优化
void open(int id,int x){
	for(int i=1;i<=k;){
		if(x%zhi[i]==0)hash[id][i]++,x/=zhi[i];
		else i++;
		if(vis[x]){
			int where=find(x);
			hash[id][where]++;
			break;
		}
		if(x==1)break;
	}
}//分解质因数，因为怕x为大质数，耗时太多，所以用二分进行找位置，进行优化
string check(){
	for(int i=1;i<=k;i++)if(hash[0][i]>hash[1][i])return "NE";
	return "DA";
}//判断
int main(){
	T=read();make_p();//造质数
	while(T--){
		a=read(),b=read();
		c=read(),d=read();
		memset(hash[0],0,sizeof hash[0]);//初始化
		memset(hash[1],0,sizeof hash[1]);//初始化
		for(int i=a;i<=b;i++)open(0,i);//分解质因数
		for(int i=c;i<=d;i++)open(1,i);//分解质因数
		cout<<check()<<endl;
	}
	return 0;
}
```


但是以上代码较笨，顶多 $30$ 分。我们应该如何优化呢？

我想到了之前处理的一道题目，就有了想法（~~我才不会告诉你我是参考了大佬的想法呢~~）。

求 $n!$ 中有几个 $m$ :
```cpp
while(n)n/=m,ans+=n;
```

 那么我们可以枚举质数。那么题目便转化成了：对于每一个小于等于d的质数，它在$a*(a+1)*…b$ 中的次数要大于等于在 $c*(c+1)*...d$ 中的次数，否则即为 $NE$ 。
 
 设质数为 $x$ ,$check(n)$ 表示 $n!$ 中有几个 $x$。 
 则对于每一个$x$ $(2<=x<=d)$ ,需满足 $check(b)-check(a-1)≥check(d)-check(c-1)$ 。
 
 $code$ :
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000005,maxe=5000005;
int T,a,b,c,d,k,tot,zhi[maxe];
bool vis[maxn];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}//快读
void make_p(){
	memset(vis,1,sizeof vis);
	vis[0]=vis[1]=0;
	for(int i=2;i<=sqrt(10000005);i+=i%2==1?2:1)if(vis[i])
	for(int j=i*i;j<=10000005/i;j+=i)vis[j]=0;
	for(int i=2;i<=10000005;i+=i%2==1?2:1)if(vis[i])zhi[++k]=i;
}//筛法挖素数
string check(){
	int sx=a-1,Sx=0,Sy=0,sy=b;
	int px=c-1,py=d,Px=0,Py=0;
	for(int i=1;zhi[i]<=max(b,d)&&i<=k;i++){
		Sx=0,Sy=0;sx=a-1;sy=b;
		px=c-1,py=d;Px=0,Py=0;
		while(sx)sx/=zhi[i],Sx+=sx;//快速求出次数
		while(sy)sy/=zhi[i],Sy+=sy;//快速求出次数
		while(px)px/=zhi[i],Px+=px;//快速求出次数
		while(py)py/=zhi[i],Py+=py;//快速求出次数
		if(Sy-Sx>Py-Px)return "NE";//如果有质数的次数在除数里比被除数高，那么就返回 NE
	}
	return "DA";
}//判断，核心
int main(){
	T=read();make_p();
	while(T--){
		a=read(),b=read();
		c=read();d=read();
		cout<<check()<<endl;
	} 
	return 0;
}
```


---

## 作者：Naro_Ahgnay (赞：2)

## 题目大意

给定两组正整数 $\{a,a+1,\cdots,b\},\{a,a+1,⋯,b\}$ 和 $\{c,c+1,\cdots,d\},\{c,c+1,⋯,d\}$。判断 $c·(c+1)\cdots d$ 能否被 $a·(a+1)\cdots b$ 整除。

## 思路
如果形式为 $\frac{a}{b}$ 的分数为最简分数，说明此时 $a$ 和 $b$ 互质。众所周知，任意一个数都可以表示成 $p_1^{x1}p_2^{x2}\cdots p_n^{xn}$ 的形式（其中 $p$ 是质数），那么当 $\frac{a}{b}$ 的分数为最简分数时，说明 $a$ 和 $b$ 中有一个相同的质数的指数不同，且 $b$ 中该质数的指数大于 $a$ 中该质数的指数。

所以问题就转化为了将分子和分母分别进行质因数分解。

关键结论：$n!$ 中质因子 $p$ 的数量等于 $1\sim n$ 中 $p$ 的数量和。

证明引用一下：[证明在这里](https://blog.csdn.net/qq_42815188/article/details/104760277)

然后原式可以将分子转换成 $\frac{b!}{(a-1)!}$ 的形式，分母转换成 $\frac{d!}{(c-1)!}$ 的形式。以分子为例，$p_i$ 的数量就等于 $b!$ 中 $p_i$ 的数量减去 $(a-1)!$ 中 $p_i$ 的数量。分母同理。

这样就可以将分子和分母分别分解，最后将相同的质数的指数进行比较，如果分子中的较大说明不能被整除。

## code

```cpp
#include<cstdio>
#include<cstring>
int t,a,b,c,d,k,to;
int p[5000001],v[10000001];
void primes()
{
	std::memset(v,0,sizeof(v));
	for(int i=2;i<=10000001;i++)
	{
		if(!v[i]) p[++k]=v[i]=i;
		for(int j=1;j<=k;j++)
		{
			if(p[j]>v[i]||p[j]>10000001/i) break;
			v[i*p[j]]=p[j];
		}
	}
}
bool ck()
{
	int aa,bb,cc,dd,na,nb,nc,nd;
	to=(d>b?d:b);
	for(int i=1;p[i]<=to&&i<=k;i++)
	{
		aa=a-1,bb=b,cc=c-1,dd=d,na=nb=nc=nd=0;

		while(aa) aa/=p[i],na+=aa;
		while(bb) bb/=p[i],nb+=bb;
		while(cc) cc/=p[i],nc+=cc;
		while(dd) dd/=p[i],nd+=dd;

		if(nb-na>nd-nc) return 0;
	}
	return 1;
}
int main()
{
//	freopen("P7281.in","r",stdin);
//	freopen("P7281.out","w",stdout);
	scanf("%d",&t);
	primes();
	while(t--)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		ck()==1?printf("DA\n"):printf("NE\n");
	}
	return 0;
}
```


---

## 作者：LCuter (赞：1)

记 $v_p(n)$ 表示 $n!$ 中质因子 $p$ 的数量，易知其等价于 $1\sim n$ 中 $p$ 的数量和。

则有：

$$
v_p(n)=\sum_{k\ge 1}\lfloor\frac{n}{p^k}\rfloor
$$

可以在 $O(\log n)$ 的时间内计算。

考虑如果 $a|b$，则对于任意质数 $p$，它在 $a$ 中的幂次应小于等于它在 $b$ 中的幂次。

所以原问题等价于判断对于任意 $p$，是否有 $v_p(b)-v_p(a-1)\le v_p(d)-v_{p}(c-1)$。线性筛筛出 $1\sim 10^7$ 内的质数后直接枚举即可。

时间复杂度 $O(T\pi(U)\log U)=O(TU)$，其中 $u$ 为值域。

---

## 作者：_Trangle_ (赞：0)

此题考察的就是阶乘质因数分解。
### Introduction：

#### Example：

定义 $n$ 的阶乘为 $n!= \prod^{n}_{i=1}{i}$。

例：
* $1! = 1$
* $2! = 1 \times 2 = 2$
* $3! = 1 \times 2 \times 3 = 6$

求 $200!$ 末尾有几个零。

#### Analysis:

可以将 $200!$ 变为 $2^n \times 5^m \times k$，$k$ 不用管，此题可以变为求 $\min(n,m)$。

易得 $n > m$，所以此题就是求 $m$。

而求 $m$ 不用分解每个数的质因数，可以转化为 $\lfloor \dfrac{200}{5} \rfloor + \lfloor \dfrac{200}{5 ^ 2} \rfloor + \lfloor \dfrac{200}{5 ^ 3} \rfloor$。

为什么可以这样做呢？

设一数 $a$，假设 $5^k|a$，但 $5^{k + 1} \nmid k $，在计算过程中会 $\lfloor \dfrac{200}{5} \rfloor,\lfloor \dfrac{200}{5 ^ 2} \rfloor \cdots \lfloor \dfrac{200}{5 ^ k} \rfloor$ 均摊下来分别加一次。

然后求出结果就好了。

### Solution：

可以按 Introduction 思路，就是阶乘分解质因数做一些变化就好了。

### Code:

```cpp
#include <bits/stdc++.h> 
using namespace std;

int T, m;
const int MAXN = 1e7;
int prime[MAXN >> 2], pa[MAXN >> 2], pb[MAXN >> 2];
bool np[MAXN + 5];

int gt(int l, int r, int x) {return r / x - l / x - (l % x != 0) + 1;} //这里就是变化，求 l 到 r 里面有多少个能被 x 整除的数

void get_p(int l, int r, int *pr, int &n) { //pr[i] 代表 l * (l + 1) * ... * r 里含有多少个 prime[i]
	for (n = 1; n <= m && prime[n] <= r; n++)
		for (long long p = prime[n]; p <= r; p *= prime[n]) pr[n] += gt(l, r, p);
}

bool check(int* pa, int na, int* pb, int nb) {
	for (int i = 1; i <= max(na, nb); i++)
		if (pa[i] > pb[i]) return 0; //显然，当 a * (a + 1) * ... * b 含有某个质因子比 c * (c + 1) * ... * d 含有这个质因子多，那么输出 NE
	return 1;
} 

int main() {
    for (int i = 2; i <= MAXN; i++) {
		if (!np[i]) prime[++m] = i;
		for (int j = 1; i * prime[j] <= MAXN; j++) {
			np[i * prime[j]] = 1;
			if (i % prime[j] == 0) break;
		}
	}
	scanf("%d", &T);
	while (T--) {
		memset(pa, 0, sizeof pa);
		memset(pb, 0, sizeof pb);
		int a, b, c, d, na = 0, nb = 0;
		scanf("%d%d%d%d", &a, &b, &c, &d);
		if (c <= a && b <= d) {
			puts("DA");
			continue;
		} //小小的条件判断，因为满足判断条件可得 c * d = c * (c + 1) * ... * a * (a + 1) * ... * b * (b + 1) * ... * d
		get_p(a, b, pa, na); get_p(c, d, pb, nb);
		puts(check(pa, na, pb, nb) ? "DA" : "NE");
	}
	return 0;
}
```

---

## 作者：kkxacj (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7281)

#### 思路

数这么大，肯定不可能全部乘起来比较，考虑分解质因数，很明显，如果被除数的质因数 $i$ 没有除数的质因数 $i$ 多或相等，那么它就肯定不能被整除，区间内每一个数都分解时间复杂度 $n \sqrt{n}$ 肯定受不了，考虑枚举质因数，看区间里那些数能被它整除，注意：**不要暴力求一个数能被当前质因数除几次**，不然就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/t85cvabv.png)


所以考虑优化，求出 $1$ 到 $b$ 中每个 $p_i$ 的 $j$ 次方出现了几次，再减去 $1$ 到 $a - 1$ 中每个 $p_i$ 的 $j$ 次方出现了几次就可以了，$c,d$ 也类似。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,c,d,a1[8000010],o,l,z,sum,sum1,ll,oo,pp;
bitset<10000010>bb;
int main()
{
	scanf("%d",&n);
	ll = 10000000;//线性筛
	for(int i = 2;i <= ll;i++)
	{
		if(!bb[i]) a1[++o] = i;
		for(int j = 1;j <= o && a1[j] * i <= ll;j++)
		{
			bb[i * a1[j]] = 1;
			if(i % a1[j] == 0) break;
		}
	}
	while(n--)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d); 
		l = 0;
		for(int j = 1;j <= o;j++)
		{
			if(a1[j] > max(b,d)) break;
			sum = sum1 = 0;
			for(long long i = a1[j];i <= b;i *= a1[j]) sum += b / i - (a - 1) / i;//1 到 b 减去 1 到 a-1 
			for(long long i = a1[j];i <= d;i *= a1[j]) sum1 += d / i - (c - 1) / i;//小心 i 爆long long 
			if(sum > sum1)//不能被整除 
			{
				l = 1;
				break;
			}
		}
		if(!l) printf("DA\n");
		else printf("NE\n");
	}
    return 0;
}
```



---

## 作者：Linghua_dog (赞：0)

题意已经够简化了，我就不多加描述了。

让我们看看这题目究竟想让我们求什么。先考虑一个简单的问题，如何判断两个数 $a$ 和 $b$，$b$ 整除 $a$？很显然，只要把 $a$ 和 $b$ 质因数分解后，判断 $b$ 的每一个质因数个数是不是都大于 $a$ 的个数，如果是那就可以整除。

那么，让我们回到题目，由于每一个数都是相乘，所以算质因数的个数时可以分别算出来，再相加，但是 $ a \le 10^7$ 如果全部枚举过去一定会 TLE 所以我们想到了反向枚举，查询每个因子在 $a\sim b$ 和 $c\sim d$ 间出现了几次，最后在判断就好了。

至于如何查找出现次数，这个套路很普遍，只需要对着 $x$ 一直除以因子并同时求和就好了。

最后，直接上代码。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2e7 + 10;

int p[N], cnt;
bool st[N];

void prime(int n)
{
	for(int i = 2; i <= n; i++)
	{
		if(!st[i]) p[++cnt] = i;
		for(int j = 1; p[j] * i <= n; j++)
		{
			st[i * p[j]] = true;
			if(i % p[j] == 0) break;
		}
	}
}

int count(int x, int a)
{
	int ans = 0;
	while(x)
	{
		ans += x / a;
		x /= a;
	}
	return ans;
}//计算a在1~x中出现了几次

int main()
{
	prime(2e7);//筛质数
	
	int T;
	scanf("%d", &T);
	while(T--)
	{
		int a, b, c, d;
		scanf("%d%d%d%d", &a, &b, &c, &d);
		
		bool f = true;
		for(int i = 1; p[i] <= b; i++)
		{
			int cnt1 = count(b, p[i]) - count(a - 1, p[i]), cnt2 = count(d, p[i]) - count(c - 1, p[i]);
			if(cnt1 > cnt2)//判断能否整除
			{
				puts("NE");
				f = false;
				break;
			}
		}
		
		if(f) puts("DA");
	}
}
```

---


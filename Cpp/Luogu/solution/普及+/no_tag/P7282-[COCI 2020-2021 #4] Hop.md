# [COCI 2020/2021 #4] Hop

## 题目背景

> 杰瑞米是一个牛蛙，是我的一个好朋友。

## 题目描述

有 $n$ 片百合花，它们分别从 $1$ 到 $n$ 依次编号。第 $i$ 片上有一个整数 $x_i$，而序列 $(x_i)_{1 \le i \le n}$ 单调递增。

三只青蛙到来。

每对满足 $a \lt b$ 的百合 $(a,b)$ 必须属于青蛙 $1,2$ 或 $3$ 中的其中一只。

当百合 $(i,j)$ 属于一只青蛙且 $x_j$ 能被 $x_i$ 整除时（$j \gt i$），该青蛙可以从 $i$ 号百合跳动到第 $j$ 号。

请找出一种分类方案，使得任何一只青蛙都不会连续跳动超过 $3$ 次。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/d4bitfzs.png)

青蛙 $1,2,3$ 分别用蓝、绿和红色代替。

蓝蛙可以从 $x_1=3$ 跳动到 $x_4=9$，再跳动到 $x_7=36$，再到 $x_8=72$。该青蛙只能进行 $3$ 次连续的跳动。

绿蛙可以从 $x_2=4$ 跳动到 $x_5=12$，再跳动到 $x_7=36$。该青蛙只能进行 $2$ 次连续的跳动。

红蛙不能从 $x_2=4$ 跳动到 $x_3=6$，因为 $6$ 不能被 $4$ 整除。

#### 数据规模与约定

**本题采用捆绑评测。**

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $n \le 30$ |
| $2$ | $100$ | 无 |

对于 $100\%$ 的数据，$1 \le n \le 1000$，$1 \le x_i \le 10^{18}$。

#### 评分方式

在输出方案中，如果其中一只青蛙可以连续跳动 $k$ 次，其中 $k \gt 3$，而没有青蛙可以连续跳动 $k+1$ 次，则对应测试点的分数为 $f(k)·x$ 分，其中：

$$f(k)=\dfrac{1}{10}·
\begin{cases}
11-k & (4 \le k \le 5) \cr
8-\lfloor {\dfrac{k}{2}} \rfloor & (6 \le k \le 11) \cr
1 & (12 \le k \le 19) \cr
0 & (k \ge 20) \cr
\end{cases}$$

而 $x$ 为对应子任务的总分。每个子任务的得分等于该子任务中所有测试点得分的最小值。

因本题的评分方式特殊，因而启用非官方的自行编写的 [Special Judge](https://www.luogu.com.cn/paste/mfhbmugl)，也可以在附件中下载。欢迎大家 hack（可私信或直接发帖）。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf)  _T3 Hop_。**

## 样例 #1

### 输入

```
8
3 4 6 9 12 18 36 72```

### 输出

```
1
2 3
1 2 3
1 2 3 1
2 3 1 2 3
1 2 3 1 2 3
1 2 3 1 2 3 1```

## 样例 #2

### 输入

```
2
10 101```

### 输出

```
1```

# 题解

## 作者：RAY091016 (赞：11)

### 1. 题目解释

给定 $n$ 个点，在这 $n$ 个点内两两连边并给边染色，要求不能有连续的四条边颜色相同，求一个合法方案。

### 2. 思路

首先我们知道两个点中间若有连边，则必有倍数关系，不妨设 $x_i\mid x_j$，则有 $x_j=k\times x_i$ 且 $k$ 为大于大于 $2$ 的整数。

考虑一条链，其中点 $i$ 与点 $i+1$ 相连且点权 $w_{i+1}$ 为 $w_i$ 的两倍。

由于点权最大为 $1\times10^{18}$，故这条链最长有 $\log_21\times10^{18}\approx60$ 个点。

我们将这 $60$ 个点每 $4$ 个点分为一小组，每 $4$ 个小组分为一个大组，最后共有 $4$ 个大组。

我们再将同一小组内点的边全部染为红色，将同一大组但不同小组内点的边全部染为蓝色，不在一个大组内点的边全部染为绿色。

不难发现这种方式使得不存在连续四条边颜色相同。

我们强制令每一个 $a_i$ 的标号为其二进制下最高位的位数。

然后就做完了。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1010],v[1010];
int get(int x){
	int ret=1,tot=1;
	while(1){
		if(tot*2>x){
			return ret;
		}
		tot*=2;
		ret++;
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		v[i]=get(a[i]);
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			if(a[i]%a[j]==0){
				if(v[i]/4==v[j]/4){
					cout<<1<<" ";
				}
				else if(v[i]/16==v[j]/16){
					cout<<2<<" ";
				}
				else{
					cout<<3<<" ";
				}
			}
			else{
				cout<<1<<" ";
			}
		}
		cout<<endl;
	}
	return 0;
}

```

---

## 作者：gcwixsxr (赞：4)

### 题目大意

给定 $n$ 个点，两点之间有一条从编号小的点到编号大的点有向边，要求给这些边染上三种颜色，使得不存在一条长度超过 $3$ 的相同颜色的路径。

### 简单分析

首先可以注意到题目中的数字 $3$，为什么出题人要用 $3$ 这个数字而非 $2$ 呢？其实这个数字用得很妙。那么接下来请看笔者娓娓道来。

如果我们把所有边都染成一个颜色，由于 $x_i$ 的最大值不超过 $10^{18}$，那么可以发现从一个点开始，每走一步至少会乘 $2$，最多可以一口气走 $60$ 步，然后就不能走了。

我们不妨将这 $60$ 步形成的链提出来，然后将前 $20$ 步染成颜色 $1$，中间 $20$ 步染成颜色 $2$，最后 $20$ 步染成颜色 $3$，~~这样我们就有了 $0$ 分的成绩~~。

那我们也许可以将第 $i$ 步染成 $i\bmod 3+1$ ，但是实际上这条链并非与其他边没有关系，我们如果只考虑两者之间的相对关系，是可能影响正确性的。

考虑一个数的 $60$ 个二进制位，将其分块，每 $4$ 位分为一个小块，每 $4$ 小块分为一个大块，最后会分出 $4$ 个大块。可以将同一小块内的点两两连边染成颜色 $1$，同一大块内不同小块的点两两连边染成颜色 $2$，剩下的边染成颜色 $3$，这样做为什么是正确的呢？考虑从一个点开始走，如果要走三条相同颜色的边，那么第四步一定会走一条不同颜色的边。

```cpp
#include<iostream>
#include<cstdio>

using namespace std;
typedef long long ll;
const int N=1005;

int n;
ll a[N],val[N];
int color(int x,int y){
	if(x/4==y/4)return 1;
	else if(x/16==y/16)return 2;
	else return 3;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lld",a+i);
	for(int i=1;i<=n;i++)val[i]=63-__builtin_clzll(a[i]);
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			if(a[i]%a[j]==0)printf("%d%c",color(val[i],val[j])," \n"[j==i-1]);
			else printf("%d%c",rand()%3+1," \n"[j==i-1]);
		}
	}
	return 0;
}
```


---

## 作者：ClearluvXL (赞：3)

# hop
## 思路
注意到，序列是单调不减的，根据 $i$ 能跳到 $j$ 的必要条件为 $x_{i}|x_{j}$，所以 $x_{j}$ 最少也得是 $x_{i}$ 的 $2$ 倍。因为 $1e18\leq 2^{64}$，也就是说，就算我们满打满算，一条跳的路径上也最多只有 64 个点。

考虑怎么给这 $64$ 个点的连边附上颜色。

最多一个颜色跳三下，所以最多 $4$ 个点为一组。

考虑每四个点为 $1$ 个小组，小组内部的点之间用 $1$ 连接。

每 $4$ 个小组为一个大组，每 $4$ 个大组的不在同一大组的点之间用 $2$ 连接。

每 $4$ 个大组为一个超大组，每 $4$ 个超大组之间的不在同一超大组的点用 $3$ 连接。

其实到这我们已经分完了，因为 $4^{3}$ 已经是 $64$ 了。这样我们就能确保每种颜色最多连续跳三下后，下一条能跳的边一定是另外一个颜色的。感性理解即可，实在不行就手搓 $64$ 个点按照上述方式连边看会不会炸。

![](https://cdn.luogu.com.cn/upload/image_hosting/vlz0bnpy.png)

然后我们将每个点在链中的位置强制固定为他的最高位 $1$ 所在的位置，就算这条链中间有空的点，但是无所谓，我们上述的连边方法已经是在满打满算的情况下的得出来的合法方案了。
## 代码
```c++
#include<bits/stdc++.h>
#define endl '\n'

using namespace std;

typedef unsigned long long ull;

const int N=1e3+10;
const int INF=0x3f3f3f3f;

typedef long long ll;
typedef pair<int,int> pii;
	
int n;
ll a[N];
int val[N];
		
int calc(int i,int j){
	if(i/4==j/4) return 1;
	if(i/16==j/16) return 2;
	return 3;
}//end
		
int main(){
	freopen("hop.in","r",stdin);
	freopen("hop.out","w",stdout);
	
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) val[i]=63-__builtin_clzll(a[i]);
	
	for(int i=2;i<=n;i++){
		for(int j=1;j<i;j++){
			if(a[i]%a[j]==0){
				cout<<calc(val[i],val[j])<<" ";
			}		
			else cout<<1<<" "; 
		}
		cout<<endl;
	}	
	
	return 0;
}//end 
```

---

## 作者：Andy1101 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P7282)
# 思路
因为从 $i$ 跳到 $j$ 的条件是 $x_i \mid x_j$，所以 $x_j$ 至少是 $x_i$ 的两倍，因为 $10^{18} \le 2^{64}$，所以一直跳的路径也只有 $64$ 个点。

因为最多一个颜色跳三下，所以每 $4$ 个点一组（$4^3=64$）。

于是可以这样分组：

- 每 $4$ 个点为一个小组，小组内部的点之间用 $1$ 连接。
- 每 $4$ 个小组为一个中组，每 $4$ 个中组的不在同一中组的点之间用 $2$ 连接。
- 每 $4$ 个中组为一个大组，每 $4$ 个大组的不在同一大组的点之间用 $3$ 连接。

# AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e3+5;
int a[N];
int v[N];
int f(int x,int y)
{
	if(x/4==y/4) return 1;
	if(x/16==y/16) return 2;
	return 3;
}
signed main()
{
	int n;
	cin >>n;
	for(int i=1;i<=n;i++)
	{
		cin >>a[i];
		v[i]=63-__builtin_clzll(a[i]);
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(a[i]%a[j]==0) cout<<f(v[i],v[j])<<" ";
			else cout <<1<<" ";
		}
		cout<<'\n';
	}	
	return 0;
}
```
完结撒花~

---

## 作者：wandereman (赞：0)

## 思路
首先，我们注意到这个序列是单调不减的，又因为 $10$ 的 $18$ 次方小于 $2$ 的 $64$ 次方，所以一条路径上最多 $64$ 个点。    
接下来我们把 $4$ 个点为一个小组，再将 $4$ 个小组合为一个中组 （也就是 $16$ 个点），再将 $4$ 个中组合为一个大组 （也就是 $64$ 个点）。    
最后我们将每个点在链中的位置强制固定为他的最高位 $1$ 所在的位置。
## AC code
```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e3+5;
ll a[N],v[N];
ll f(ll x,ll y){
	if(x/4==y/4) return 1;
	if(x/16==y/16) return 2;
	return 3;
}
signed main(){
	int n;
	cin >>n;
	for(ll i = 1;i <= n;i++){
		cin>>a[i];
		v[i] = 63-__builtin_clzll(a[i]);
	}
	for(ll i = 2;i <= n;i++){
		for(ll j = 1;j < i;j++){
			if(a[i] % a[j] == 0){
				cout<<f(v[i],v[j])<<" ";
			}else{
				cout<<1<<" ";
			}
		}
		cout<<'\n';
	}	
	return 0;
}
```

## 一些补充
在第 16 行里有一个函数：
```cpp
63-__builtin_clzll
```
这是一个对于二进制数返回最高位的函数，如果我们将其简写为 $f()$,那么便有以下的举例：
$f(10) = 1$。
## 尾声
2025 年第一篇动笔的题解，~~求过~~。

---


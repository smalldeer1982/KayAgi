# 「EZEC-5」人赢 加强版

## 题目背景

> “我们在 小 Z 面前秀个恩爱吧。”\
>“好的。”

小 Z 发现他身边都是人赢，这使他非常自闭。

小 Z 又看着身边的潇，不禁陷入了沉思……

![](https://cdn.luogu.com.cn/upload/image_hosting/b1ij58kc.png)

## 题目描述

潇有一个数组 $k$，下标为 $1$ 到 $n$ 。

潇定义 $f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y) &x \ne y \\ k_x\times x&x=y \end{cases}$ 。

潇想知道对于任意的 $1 \le x,y \le n$，$f(x,y)$ 的最大值是多少。但是她不会做，于是就问了善良的 小 Z，然而非常想在妹子面前表现的 小 Z 发现他也不会做，就只能够求助善良的你了。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（10 points）：$1 \le n \le 50$。

- Subtask 2（20 points）：$1 \le n \le 5000$。

- Subtask 3（20 points）：$1 \le n \le 10^6$。

- Subtask 4（10 points）：保证所有 $k_{i}$ 都相等。

- Subtask 5（40 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^7$，$1 \le k_{i} \le 10^9$。

**本题建议使用较快的读入方式。**

std 使用的快读：

```cpp
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
```

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
5
3 4 5 4 3```

### 输出

```
28```

# 题解

## 作者：pigstd (赞：23)

**官方题解**

- $f(x,y)=k_x\times x (x = y)$ 直接扫一遍即可，接下来考虑 $x \ne y$ 的情况。
- 对于一个 $i$ 来说 ,如果 $j1 < j2$ 且 $k_{j1} < k_{j2}$，那么显然除了 $y= j2$ 的时候，$x = j1$没有$x=j2$ 更优， 则从后往前找 $k_i$ 最大值， 如果更新了就把当前位置和存入一个序列，对于每一个 $i$ 匹配这个序列里第一位置 $> i$ 的，然后更新最大值就可以。
- 正确性证明：实际上是对于每个 $k_i$ 作为较小值更新答案，对于 $i$ 来说只有那个序列第一个位置 大于它的才会对答案有效更新，不是中和 $<i$ 的肯定不会更优，而在序列中 $>i$ 的只有相邻是效更新答案，因为如果和后面的匹配更优，那后面的和这个相邻的匹配会比这个匹配更优。
- 具体实现：

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;

const int M=1e7+10;
int n,a[M],ans;

#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}

int f(int x,int y)
{
	return (x+y)*min(a[x],a[y]);
}

signed main()
{
	n=read();
	for (int i=1;i<=n;i++)a[i]=read(),ans=max(ans,a[i]*i);
	for (int i=n-1,l=n;i>=1;i--)
	{
		ans=max(ans,f(i,l));
		if (a[i]>a[l])l=i;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Alex_Wei (赞：22)

> [题目传送门](https://www.luogu.com.cn/problem/P7291)。

> 题意：给定长度 $n$ 与序列 $a$，求下列函数的最大值：

> $$f(i,j)=\begin{cases}\min(a_i,a_j)\times(i+j)\quad&i\neq j\\a_i\times i&i=j\end{cases}$$

这道题目的思维难度还是挺高的，好评。

---

解法 1：正序处理。

从前往后处理该序列，不难发现对于任意 $i,j,k$ 满足 $i<j<k$ 且 $a_i\leq a_j$，都有 $f(i,k)<f(j,k)$，也就是说如果有了 $a_j$，那么 $a_i$ 完全是无用的，用单调栈维护一下即可。

具体来说，如果当前的数 $a_i$ 大于等于栈顶的数 $a_k$，我们可以用 $f(i,k)$ 去更新答案，然后 $a_k$ 就无用了，将其弹出。重复上述过程直到栈空或者栈顶的数 $a_{k'}>a_i$，再用 $f(i,k')$ 更新答案即可（若栈空则用 $f(i,i)$ 更新）。因此，在栈中我们不仅要记录每个数的值，也要记录它原来的下标。

时空复杂度 $\mathcal {O}(n)$。

```cpp
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		k=read();
		while(top&&k>=st[top])ans=max(ans,1ll*st[top]*(ind[top]+i)),top--;
		ans=max(ans,1ll*k*(ind[top]+i)),ind[++top]=i,st[top]=k;
	} cout<<ans<<endl;
	return 0;
}
```

---

解法 2：倒序处理。

从后往前处理该序列，不难发现对于任意 $i,j,k$ 满足 $i<j<k$：

- 如果 $a_j\leq a_k$，那么 $f(i,j)<f(i,k)$，也就是说如果有了 $a_k$，那么 $a_j$ 基本上是无用的（除了可以用 $f(j,k)$ 更新答案）。
- 如果 $a_j>a_k$，那么 $f(i,k)<f(j,k)$，也就是说如果有了 $a_j$，那么 $a_k$ 基本上是无用的（除了可以用 $f(j,k)$ 更新答案）。

综合上述两种情况，不难发现我们只需实时维护从后往前的最大值即可。

```cpp
const int N=1e7+5;
int n,k[N],id;
long long ans;
int main(){
	id=n=read(); for(int i=1;i<=n;i++)k[i]=read(),ans=max(ans,1ll*i*k[i]);
	for(int i=n-1;i;i--)
		if(k[i]<=k[id])ans=max(ans,1ll*(i+id)*k[i]);
		else ans=max(ans,1ll*(i+id)*k[id]),id=i;
	cout<<ans<<endl;
	return 0;
}
```

说句题外话：作为曾经共同出过月赛的合作团队，很遗憾今天没能参加 EZEC 的月赛（周六下午有课，基本上把所有月赛都冲掉了，枯）。不过还是非常支持他们滴，也希望他们的比赛越办越好 /cy。

---

## 作者：山田リョウ (赞：13)

2021/6/15 update：突然发现 ClCN 说的是我把 $O(n\log_2n)$ 写成了 $O(n\log_nn)$，现在改了qwq。

---

题面：

给定一个数组 k，下标为 1 到 n 。

定义：
$$
f(x,y)=\begin{cases}\min(k_x,k_y) \times (x+y) & x \ne y\\k_x \times x & x=y \end{cases}
$$
求：
$$
\forall 1 \leq x,y \leq n \ max\{f(x,y)\}
$$

----

这道题的弱化版可以用$O(n\log_2n)$的做法水过，不知道的同学可以看一下我的这篇[题解](https://www.luogu.com.cn/blog/huaerxiao-nuo0930/post-ti-xie-p7286-ezec-5-ren-ying)。

首先，我们知道对于同一个x：




$$
\forall i<j ， k_i \leq k_j \\
f(x,i) \leq f(x,j)
$$




所以，我们考虑从后往前遍历 $k$ 数组，如果 $k_i$ 更新了目前的最大值的话（也就是说他比目前遍历到的值都大），就把它存入一个数组 $q$。对于每个 $i$ 就找 $q$ 数组中编号比它大且编号最小的就好了和自己本身匹配就好了。

Why？？？

因为如果 $k_i$ 不是目前最大值的话，它和一个点 $j$ 匹配一定不会比目前最大值和 $j$ 匹配更大，因为$i$比目前最大值的编号小，$k_i$ 也比目前最大值小。

如果 $k_i$ 是目前最大值的话，它和一个点 $j$ 匹配一定不会比目前第二大值和 $j$ 匹配更优，因为 $\operatorname{f(x,y)}$ 看的是 $\min(k_x,k_y)$，而不是 $\max(k_x,k_y)$。

由于只需要访问 $q$ 数组中的上一个元素，所以我们不需要开成数组，由于 $k_0$ 默认为 $0$,所以把 $q$ 初始化为 $0$

还有，切记切记，要开 $\text{long long}$，加快读（题目提供的那个快读，手写还是会TLE），还有，不要忘了最大值要和自己匹配。

AC代码:
```cpp
#include <cstdio>
#include <fstream>
using std::isdigit;
using std::printf;
const int maxn = 10000010;
int k[maxn];
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
inline int read() { 
    char c = getchar();
    int x = 0;
    bool f = 0;
    for (; !isdigit(c); c = getchar())
        f ^= !(c ^ 45);
    for (; isdigit(c); c = getchar())
        x = (x << 1) + (x << 3) + (c ^ 48);
    if (f)
        x = -x;
    return x;
}
inline long long max(long long a, long long b) {
    return a > b ? a : b;
}
inline long long min(long long a, long long b) {
    return a < b ? a : b;
}
inline long long f(long long x, long long y) {
    return ((x == y) ? ((long long)k[x] * x) : (min(k[x], k[y]) * (x + y)));
}
int main() {
    int q = 0;  //由于只需要访问q数组中的上一个元素，所以我们不需要开成数组,由于k[0]默认为0,所以把q初始化为0
    long long ans = 0;
    int n;
    n = read();
    for (int i = 1; i <= n; i++)
        k[i] = read();
    for (int i = n; i > 0; i--) {
        ans = max(ans, f(i, q));
        if (k[i] > k[q])
            q = i;
    }
    ans = max(ans, f(q, q));  //最大的那个元素要和自己匹配一下
    printf("%lld", ans);
    return 0;
}
```


如果本篇题解对您有帮助，请点一个赞，谢谢。

The end.

---

## 作者：cyffff (赞：5)

# P7291 人赢
「EZEC-5」人赢 加强版
#### [_弱化版传送门_](https://www.luogu.com.cn/problem/P7286)
#### [_传送门_](https://www.luogu.com.cn/problem/P7291)
~~本来想去弱化版发题解的，但是题解区一下就满了...~~

原题被最后几个点卡着的 dalao 们可以去 [_这里_](https://www.luogu.com.cn/problem/U149812) 测试，这几组就是我造的 hack 数据。

显然 $n\leqslant 10^7$ 的数据范围要求了我们用 $\texttt{O}(n)$ 的算法。

## 思路
#### $\texttt{O}(n^2)$
我们显然可以暴力枚举 $x,y$ 求最大值。
#### $\texttt{O}(n \log n)$
我们可以将每个数按照值域从大到小排序，从前到后扫一遍，在路上求出原始编号的前缀最大值，直接求 $f$ 函数即可。

正确性证明：由于现在扫到的数一定比前面的数小，所以要使编号尽量大才能使 $f$ 函数最大。

代码很好写，就~~咕~~了，想看可以去其它题解或原题题解。
#### $\texttt{O}(n)$
#### 方法 1
我们发现 $\texttt{O}(n \log n)$ 做法的扫一遍是 $\texttt{O}(n)$ 的，复杂度瓶颈在排序的 $\texttt{O}(n \log n)$，于是我们可以使用基数排序，期望复杂度 $\texttt{O}(n)$，但是常数巨大，无法通过本题。
#### 方法2
在 $\texttt{O}(n \log n)$ 的做法中，我们为了保证正确性，我们给原序列排了序，现在我们要在 $\texttt{O}(n \log n)$ 的做法中找到一个正确的做法保证正确性。

我在这里先给出方法：先取出 $k_x\times x$ 的最大值，再从前后分别扫一遍，分别取前后缀的 $k_i\times i$ 的最大值，再路上求 $(i+x)\times \min(k_i,k_x)$ 的最大值即可。

正确性证明：我们假设最终的答案为 $(x,y)$ ，如果我们在这种方法下我们没法取到 $(x,y)$ 当且仅当存在 $x<z<y$ 满足：

$$\begin{cases}k_z\times z >k_x \times x\\k_z\times z >k_y \times y\end{cases}$$

我们分类讨论：

- 1.当 $k_x>\min(k_x,k_y)$ 时，则将 $x$ 换为 $z$ 答案不会变劣，与最终的答案为 $(x,y)$ 矛盾。
- 2.当 $k_z\leqslant\min(k_x,k_y)$ 时，则 $k_z\times z \leqslant k_y \times y$ ，与假设矛盾。

所以一定能取到最优解。

这种方法给出代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int t,n,y;
long long now;
namespace IO{
	//read()
}using namespace IO;
ll a[10000010];
int x;
ll maxn;
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        now=max(now,a[i]*i);
        now=max(now,(i+x)*min(a[i],a[x]));
        if(a[i]*i>maxn) maxn=a[i]*i,x=i;
    }
    maxn=x=0;
    for(int i=n;i>=1;i--){
        now=max(now,(i+x)*min(a[i],a[x]));
        if(a[i]*i>maxn) maxn=a[i]*i,x=i;
    }
    printf("%lld",now);
    return 0;
}
```
卡了点常数，卡到了 $249ms$ 最优解。

这是一道思维题，对码量没什么要求。

那就再见了 $qwq$~

---

## 作者：囧仙 (赞：4)

## 题解

在其弱化版里，我们提到了加强版的做法：


> ### $\mathcal O(n)$ 小常数做法  
考虑维护一下候选的 $x$ ，然后枚举 $y$ 。  

>  - 可以发现，如果有一个 $x$ ，满足 $k_x\le k_y$ ，那么它只能和 $y$ 组成 $(x,y)$ 了。因为之后的一个数字 $z$ 和 $y$ 组合肯定比 $z$ 和 $x$ 组合要优。这时候我们就能把这样的 $x$ 移出去了。  

>  - 剩下来的 $x$ ，肯定满足 $k_x>k_y$ ，于是 $\min(k_x,k_y)=y$ 。我们要选择其中最大的一个 $x$ ，更新答案。  

>  为了很好的统计第二种情况的答案，我们当然希望 $x$ 集合是一个顺序结构了。事实上，由第一种情况，我们可以发现这个顺序结构中总是满足后一项的 $k$ 值严格小于前一项的 $k$ 值（不然就不会有前一项）。  
这是什么？**单调栈**。   

>  枚举 $y$ 的时候，弹出栈中满足 $k_x\le k_y$ 的 $x$ 与 $y$ 组成 $(x,y)$ 更新答案；剩下的栈顶的 $x$ 必然是最大的（因为我们按照顺序入栈），更新答案，然后把 $y$ 压到栈里作为下一个候选的 $x$ 。  

>  复杂度仍然是 $\mathcal O(n)$ 。但它的优势在于，任何时候我们都是顺序访问，减小了访问的常数。  

这边就来~~再水一篇题解~~讲讲它的实现细节。

举一个简单的栗子：

$$n=7,K=\{4,6,5,3,2,5,3\}$$

首先，我们可以计算出所有 $x=y$ 的情况时的函数值。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
x & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr \hline
k_x & 4 & 6 & 5 & 3 & 2 & 5 & 3\cr \hline
f(x) & 4 & 12 & 15 & 12 & 10 & 30 & 21 \cr  \hline
\end{array}$$

这时我们更新答案。

$$ans\gets \max_{i\le n} \{f(x_i)\}=30$$

下面考虑从左到右依次加入每个数字。同时，我们开一个栈 $S$ 用来维护下标。

- $1.$ 加入 $k_1$ 。

此时 $1$ 并不能与任何数字组成对。于是，我们直接加入 $K_1$ 就好了。 

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 1 & \cr\hline
K_{S_i} & 4 & \cr\hline
\end{array}$$

- $2.$ 加入 $k_2$ 。

这时候，由于 $k_2=6>k_1$ ，因此 $1$ 只能作为 $x$ 和 $2$ 组成对 $(1,2)$ 。否则 $1$ 将完全没用了。于是， $1$ 要出栈，然后，我们加入 $k_2$ 。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr \hline
S_i & 2 & \cr \hline
A_{S_i} & 6 & \cr \hline
\end{array}$$

- $3.$ 加入 $k_3$ 。

由于 $k_3=5<k_2$ ，于是直接将 $(2,3)$ 组成对，然后加入 $k_3$ 。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr \hline
S_i & 2 & 3 & \cr \hline
A_{S_i} & 6 & 5 & \cr \hline
\end{array}$$

- $4.$ 加入 $k_4$ 。

$k_4=3<k_3$ 。组成 $(3,4)$ 更新答案，再直接加入 $k_4$ 。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & 3 & 4 & \cr\hline
A_{S_i} & 6 & 5 & 3 & \cr\hline
\end{array}$$

- $5.$ 加入 $k_5$ 。

和 $4$ 一样操作。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & 3 & 4 & 5 & \cr\hline
A_{S_i} & 6 & 5 & 3 & 2 & \cr\hline
\end{array}$$

- $6.$ 加入 $k_6$ 。

我们发现， $k_6=5>k_5$ 。于是我们要弹出栈顶 $5$ ，组成 $(5,6)$ 更新答案。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & 3 & 4 & \cr\hline
A_{S_i} & 6 & 5 & 3  \cr\hline
\end{array}$$

同时， $k_6>k_4$ 。我们仍然弹出栈顶组成 $(4,6)$ ，更新答案。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & 3 &  & \cr\hline
A_{S_i} & 6 & 5 &  \cr\hline
\end{array}$$

注意：此时 $k_3=5\le k_6$ 。根据上文， $3$ 作为 $x$ 无论与谁组成对，都不如让 $6$ 与他组成对更好。所以我们仍然要弹出。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & &  & \cr\hline
A_{S_i} & 6 & &  \cr\hline
\end{array}$$

然后更新答案 $(2,6)$ ，加入 $k_6$。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & 6  \cr\hline
A_{S_i} & 6 & 5 \cr\hline
\end{array}$$

- $6.$ 加入 $k_7$ 。

最后只剩下个 $k_7$ 。

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{下标} & 1 & 2 & 3 & 4 & 5 & 6 & 7 \cr\hline
S_i & 2 & 6 & 7 \cr\hline
A_{S_i} & 6 & 5 & 3 \cr\hline
\end{array}$$

统计我们刚刚获得的所有更新，得到 $ans=45$ 。

其实还有些注意点：

- 无论什么时候，我们都应该让 $i$ 作为 $y$ 选择最优的 $x$ 更新答案。也就是说，弹出栈之后必须要与栈顶上的数字配对（如果不存在数字了，那么才跳过；因为此时已经和栈中所有最优的 $x$ 配过对了）。

不然，会有如下情况发生：

```plain
5
5 4 3 2 1
```

如果弹出后不与栈顶组成对，这种数据会出问题。

- 同理，先全部弹出后再配对而不是边弹出再配对也会遇到下面问题：

```plain
5
1 2 3 4 5
```

先弹出再配对，栈弹空了就没法配对了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =1e7+3;
int n,A[MAXN],S[MAXN][2],s; i64 ans;
int main(){
    n=qread(); up(1,n,i) A[i]=qread(),ans=max(ans,1ll*A[i]*i);
    up(1,n,i){
        while(s&&S[s][1]<=A[i]){
            ans=max(ans,1ll*(S[s][0]+i)*S[s][1]),--s;
        } 
        if(s) ans=max(ans,1ll*(S[s][0]+i)*A[i]);
        S[++s][0]=i,S[s][1]=A[i];
    }
    printf("%lld\n",ans);
    return 0;
}
/*
7
4 6 5 3 2 5 3
*/
```

---

## 作者：InformationEntropy (赞：3)

加强版 $n\leq10^7$，时限 249ms，很明显必须 $O(n)$ 解决 

$O(n)$ 算法：

由于取两数中的较小值，故只需确定每一个 $k_i$，找到 $\geq$ 它的所有数中下标最大的数 $k_j$ 即可。统计所有 $k_i\times (i+j)$，不断更新答案，得到最终答案。

考虑到在原数组中，越往后的数下标越大，不妨直接从后往前扫试试？

统计当前扫到的最大值，当扫到 $\geq$ 当前最大值的数时，由于前面已扫到的数肯定小于当前最大值，所以当前扫到的数就是大于等于原最大数中下标最大的。此时统计答案并更新当前最大值。

举个例子：

```2 3 5（现在扫到的数） 3 2 1 4(当前最大值) 2```

但如果现在扫到的数比当前最大值小时呢？

首先，如果之前被刷掉的旧的最大值没有 $\geq$ 当前数的，那么当前的最大数就是 $\geq$ 当前数中下标最大的。

而如果之前被刷掉的旧的最大值有比当前数大的，那么当前的最新最大数就不是所有 $\geq$ 当前数中下标最大的了，那么就不对了?

再仔细想想，发现这种情况对最终答案是无任何影响的。设之前被刷掉的一个旧最大值为 $k_a$，当前最大值为 $k_b$，当前扫到的数为 $k_c$，这种情况下满足 $c<b<a$ 且 $k_b>k_a>k_c$，则有 $f(a,b)=k_a\times(a+b),f(a,c)=k_c\times(a+c),f(b,c)=k_c\times (b+c)$，显然有 $f(a,b)>f(a,c)>f(b,c)$，而 $f(a,b)$ 在 $k_a$ 被 $k_b$ 刷下去后已经更新到最终答案里面的，所以这种情况对答案并无影响。


所以这种算法的正确性得到了证明

此外，这种算法无需在输入时统计 $k_i\times i$，只需最后统计全局最大数 $k_x\times x$ 即可，因为所有非最大数 $k_i$ 都会与比它大 $k_j$ 的一同参与运算，而 $k_i\times i$ 一定小于 $k_i\times (i+j)$。至于 $k_x$，它最大，并没有比它大的数与它一起运算得到答案，所以最后要统计一下以确保最终答案的正确性。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef double db;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
ll a[10000001];
int main()
{
    int n;
    n=read();
    ll ans=0;
    ll maxx=0, maxsub=0;
    for(int i=1; i<=n; i++)
    {
        a[i]=read();
    }
    for(int i=n; i>=1; i--)
    {
        if(a[i]>=maxx)
        {
            ans=max(ans, maxx*(maxsub+i));
            maxx=a[i];
            maxsub=i;
        }else{
            ans=max(ans, a[i]*(i+maxsub));
        }
    }
    ans=max(ans, maxx*maxsub);
    cout << ans;
    return 0;
}
```

---

## 作者：Jiyuu_no_Tsubasa (赞：2)

其实这题没有绿题难度，

只要稍作分析即可得出答案。

答案有 $2$ 种：
1. $x=y$
1. $x\ne y$

第一种情况输入时考虑即可，

考点在第二种。

第二种其实也不难：

对于每个数 $x$ ，  

决定式子 $f(x,y)$ 的值有 $2$ 个，

即 $k(x)$ 的值与编号 $x$。

若枚举 $y$，

匹配的 $x$ 在不影响两数较小值时自然下标越大越好。

因此在计算枚举到 $i$ 时，

所匹配的 $x$ 就是从$i+1$ 到 $n$ 中的值最大的元素。

+ 最大保持其不影响两数较小值

+ 在其后面枚举保持其编号较大

故可得主代码：

```
for(int i=n-1;i>=1;i--){
    ans=max(min(a[mann],a[i])*(mann+i),ans);
    if(a[mann]<a[i]) mann=i;
}
```

注意 $mann$ 就表示其后面的最大值下标，

故需更新。

这就是本题的 $O(n)$ 算法，

怎么样，是不是很简单？

最后放上完整代码：

```
#include<bits/stdc++.h>
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
long long a[10000010];
long long ans;
int main(){
    int n; cin>>n;
    for(int i=1;i<=n;i++){
        a[i]=read();
        ans=max(ans,a[i]*i);
    }
    int mann=n;
    for(int i=n-1;i>=1;i--){
        ans=max(min(a[mann],a[i])*(mann+i),ans);
        if(a[mann]<a[i]) mann=i;
    }
    cout<<ans;
    return 0;
}

```

还要提醒的一点是，一定要用快读，

本蒟蒻用 $50$ 分 $TLE$ 血的教训证明了：

本题卡的不是 $O(n^2)$ 算法，而是  ```cin``` 与 ```scanf``` ！

## 完结撒花

---

## 作者：TZMydl (赞：2)

先简单讲一下朴素做法。（赛场上AC了）

对于一个数，我们要想让它发挥最大作用，就要找到大于等于它的最靠右的数。

瓶颈在于怎么找到这个数，我太菜了，赛场上只想到暴力寻找，如果有大佬有 $ O(logn) $ 或 $ O(1)$ 的做法请告诉我，我想知道这个做法有没有靠谱的复杂度。

现在来讲正解。

考虑排除无效决策，可以发现一条比较显然的性质：

对于数组中的两个数 $ a_i $ 和 $ a_j $ ，若 $ i<j $ 且 $ a_i<a_j $ ，那么 $ a_i $ 没有 $ a_j $ 更优。

所以，对于一个数 $ a_i $ ，若存在一个数 $ a_j $ ，使得 $ i<j $ 且 $ a_i<a_j $ ，那么对于任意的 $ a_k $ ，$ f(i,k) $ 一定劣于 $ f(j,k) $ ，故在决策时可以排除 $ a_i $ 。

在排除所有这样的 $ a_i $ 后，剩下的 $ a_j $ 就组成了一个可供决策的序列。

决策序列的确定很简单，倒序扫描数组，维护当前最大值和其序号即可。

这时我们会发现决策数组有一个性质：里面所有元素的序号单调递减，而元素大小单调递增。

这时每一个元素只需要和它的后驱组合，即可发挥最大作用，因为它一定是更小的，而和它的后驱组合时序号和最大。

因此，我们只需在扫描时决策即可。

考虑到最优决策不一定就出现在决策数组中的元素的组合中，所以同时也要考虑决策数组外的元素，但是最优决策一定不会出现在两个都不属于决策数组的元素的组合中，所以我们可以用当前维护的元素（也即当前决策数组中最后一个元素）与扫描到的不在决策数组中的元素组合，这样就保证了在边扫描边决策的同时又能找到最优决策。

证明一下这种做法的正确性：

对于决策数组中的最后数 $ b_i $ ，当前扫描到的数为 $ a_j $ ，在从 $ b_1 $ 到 $ b_{i-1} $ 这些数中，它们与 $ a_j $ 的组合都会劣于它们与 $ b_i $ 的组合；

对于以后可能添加到决策数组中的数，因为决策数组中元素序号单调递减，元素大小单调递增，所以它们和 $ a_j $ 的组合也一定更劣。

故只需考虑 $ a_j $ 与 $ b_i $ 的组合即可；

这样的话，一次扫描即可完成上述过程，复杂度为 $ O(n) $ 。

code：

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cctype>
using namespace std;
typedef long long ll;
int n,a[10000005],maxx=0,k=0;
ll ans=0;
inline int read(){
	int num=0;char ch=getchar();bool f=0;
	while(!isdigit(ch)){
		f|=(ch=='-');
		ch=getchar();	
	}
	while(isdigit(ch)){
		num=(num<<1)+(num<<3)+(ch^48);
		ch=getchar();	
	}
	return f?-num:num;
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	maxx=a[n];k=n;
	ans=(ll)a[n]*n;
	for(int i=n-1;i>=1;--i){
		if(maxx<a[i]){
			ans=max(ans,(ll)maxx*(i+k));
			ans=max(ans,(ll)a[i]*i);
			k=i;
			maxx=a[i];
		}
		else ans=max(ans,(ll)a[i]*(k+i));
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：轻绘 (赞：1)

## 历史

一道好题，很考验思维。

~~像我这种没有思维的蒟蒻直接被卡爆~~

[血泪史](https://www.luogu.com.cn/paste/wvkcyf3z)

总计WA了35次。

[题目传送门](https://www.luogu.com.cn/problem/P7291)



# 题意

给定序列 $a_1 , a_2 , ... ,a_n$ 。 

从中任意挑选两个数 $a_x , a_y$。

分两种情况：

1. $x=y$，$f(x,y)=a_x*x$

2. $x \ne y$，$f(x,y)=min(a_x,a_y)*(x+y)$

# 思路

显然对于本题 $1e7$ 的数据，唯一正解为 $O(n)$


## 几个容易证得的引理

下面是几个证明，不需要的大佬可直接跳过看结论。

1. **对于任一 $a_i$ ，在大于它的数中，排在最后面(及位置序号最大）的一个与其组成数对最优。**

	（因为既然已经大于$a_i$，那么它的大小就不会对答案造成影响，只有位置对答案有影响。因此越往后的数能使答案越大）

2. **对于任意两个 $a_i , a_j$ ，若 $a_i<a_j$ 且 $i<j$ ，那么 $a_i$ 只有在最终答案为 $f(i,j)$ 的时候不可代替（因为 $i,j$ 都要用）。否则都可以被 $a_j$ 替换成更优答案。**

	换而言之，$a_i$ 其它情况中无用，这点至关重要，下文有体现。
    
   （若答案为 $f(i,k)$ 那么 $f(j,k)$ 定然更优）
    
    提示：可将 $k$ 分为三种情况讨论，
    
    $a_k<a_i<a_j$
    
    $a_i<a_k<a_j$
    
    $a_i<a_j<a_k$

	可以简单证明 $f(j,k)$ 恒大于 $f(i,k)$
    
3. **对于任意两个 $a_i , a_j$ ， 若$a_i>a_j$ 且 $i<j$	那么可以证明** 

	**对于任意 $k<i$ 的情况 $f(k,j)<f(i,j)$，即 $a_j$ 将无用，只需考虑 $f(i,k)$** 
		
   提示：可将 $a_k$ 分为三种情况
   	
  	令 $k<i<j$
   
	  - 因为 $a_k<a_j<a_i$  
      
     $(j+k)<(i+j)$ 且 $min(a_j,a_k)<min(a_i,a_j)$
      
    所以 $f(j,k)<f(i,j)$ 
    
    - 因为 $a_j<a_k<a_i$ 
    
    $(j+k)<(i+j)$ 且 $min(a_j,a_k)=min(a_i,a_j)$
    
    所以 $f(j,k)<f(i,j)$ 
    
    - 因为 $a_j<a_i<a_k$ 
    
    $(j+k)<(i+j)$ 且 $min(a_j,a_k)=min(a_i,a_j)$
    
    所以 $f(j,k)<f(i,j)$
    
    **综上所述：对于 $a_j$ 出现 $i<j$ 且 $a_i>a_j$ 后**
    
    **只要考虑 $f(i,j)$ 即可，之后不会再使用它。**
4. 对于引理 $2,3$ 进行合并后，假设最终答案为 $f(k,i)$( $k<i$ )，可以发现  $a_i$ 为 $k$ 之后，值最大的数。

	提示：
    
   - 根据引理 $2$ : 对于任意 $a_j<a_i$ 且 $j<i$ ，$f(k,i)>f(k,j)$ 
   
   - 根据引理 $3$ ：对于任意 $a_j<a_i$ 且 $j>i$ ，$f(i,j)>f(k,j)$
   
   所以对于任意不是最大值得 $a_j$ 都不可能是最终答案，无需考虑，只需考虑最大值 $a_i$ 即可。
    
    **综上所述：对于任意一个 $a_k$ 只需考虑排在它后面，且值最大的数即可。(需要特殊考虑的 $f(i,j)$ 在遍历到 $k$ 之前便已经尝试过。）** 

## 	最终解法

对于 $x=y$ 的情况 直接在输入时进行遍历即可。

对于 $x \ne y$ 的情况，则直接从后向前遍历数列。**假设当前遍历到 $a_k$** 

根据引理 $4$ 可得只有 $f(k,x)$ 时需要尝试更新答案，且 $a_x$ 为目前最大值。

若 $a_k>a_x$	那么更新最大值 $a_x$ ， $a_k$ 成为最大的数，即接下来的 $a_x$

# 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
int n,ans,now;
int k[20000000]; 
signed main(){
	n=read(); 
	for(register int i=1;i<=n;++i)
		k[i]=read(),ans=max(ans,k[i]*i);//遍历 x=y 情况
	now=n;
	for(register int i=n-1;i>=1;--i){
		ans=max(ans,min(k[now],k[i])*(now+i)); // 考虑引理中每个f（i,j）情况
		if(k[i]>k[now])	now=i; // 更新最大值
	}
	printf("%lld",ans);
	return 0;
}
```


# 后话

这是我迄今为止花费时间精力最多的一篇题解。

~~虽然写的题解也不多，而且这篇也不是多好。~~

有不足请指出。谢谢！


---

## 作者：Gorenstein (赞：1)

如果注意到了一些性质和结论，这题还是挺简单的qaq

$$
\quad
$$

看这个数据范围就知道要 $O(n)$ 做了。而且不会更快了，因为输入的复杂度就是 $O(n)$。

我们简单思考一下，发现 $x=y$ 的时候很好弄，直接输入的时候顺便计算即可。于是问题的关键在于 $x$ 不等于 $y$ 时如何做出计算。

显然当第一个变量 $x$ 确定之后，第二个变量 $y$ 也是可以确定下来的。我们枚举 $x$ 的时候能否快速确定 $y$？

我们发现决定 $f$ 的大小的有两个因素，分别是较小值和下标之和。因此我们有个显然的结论：当 $\min\{k_x,k_y\}$ 固定时，下标之和越大则函数值越大。

我们**强制枚举到位置 $i$ 时 $i$ 作为函数的第一个变量**。注意到 $f(x,y)=f(y,x)$，即二变量之间的先后顺序是不影响函数的值的。因此：

- 我们每枚举一个位置作为函数第一个变量时，**每次只需要在这个位置的同一侧寻找另一个变量**。因为当我们继续枚举的时候，这个位置会考虑作为函数的第二个变量，所以这样是不会遗漏的。
- 我们在**确定另一个变量的时候，要让这个变量尽可能的大**。

$$
\quad
$$

使用 $ans$ 实时记录答案，用 $y$ 记录第二个变量，从后往前枚举第一个变量 $i$。

卡常题，过不过看评测机心情。

```cpp
const ll SIZE=10000005;
ll n,ans,y,k[SIZE];
int main(){
	n=read();
	for(ll i=1;i<=n;i++)
		k[i]=read(),ans=max(ans,i*k[i]);
	y=n;
	for(int i=n-1;i>=1;i--){
		ans=max(ans,min(k[i],k[y])*(i+y));
		if(k[y]<k[i])y=i;
	}
	printf("%lld",ans);
	return 0;
}
```

给一张图qaq

![](https://cdn.luogu.com.cn/upload/image_hosting/6lfbwawz.png?x-oss-process=image/resize,m_lfit,h_670,w_825)

下面证明正确性：

- 若我们扫描到 $i$ 并更新 $ans$ 后，$k_i>k_y$。此时如果不更新 $y$ 的值，再向前枚举 $i$ 无论如何都不会优于当前的 $ans$ 值。所以此时决策后更新 $y$ 为当前的 $i$ 不会更劣。
- 若我们扫描到 $i$ 并更新 $ans$ 后，$k_i\leq k_y$。此时如果更新了 $y$ 的值为 $i$，则再向前枚举 $i$ 的时候，之后的二变量较小值不会更优，下标之和绝对更劣。所以此时不更新比更新更优。

这样正确性得到了保证。

---

## 作者：BotDand (赞：0)

# $\text{Problems}$
求$f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y)\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,x \ne y \\ k_x\times x\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,x=y \end{cases}$的最大值$(1\le x,y \le n)$
# $\text{Answer}$
* 当$x\not = y$时，不妨设$\min(k_x,k_y)=k_y$，则$\min(k_x,k_y) \times (x + y)=k_y \times x+k_y \times y$

  先保证$k_y\times y$最大，然后保证$y$的最大即可确定$y$。
  
  同理可以确定$x$。
  
* 当$x=y$时，暴力枚举即可。

时间复杂度$O(4n)$，疯狂卡常可过。
# $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,ma,am,n;
long long k[10000000];
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
inline void write(long long x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main()
{
    n=read();
    for(register int i=1;i<=n;++i) k[i]=read();
    for(register int i=1;i<=n;++i) if(k[i]*i>=ma||(k[i]*i==ma&&i>am)) ma=k[i]*i,am=i;
    for(register int i=1;i<=n;++i) if(i!=am) ans=max(ans,min(ma/am,k[i])*(i+am));
    for(register int i=1;i<=n;++i) ans=max(ans,k[i]*i);
    write(ans);
    return 0;
}
```

---

## 作者：Asdonel (赞：0)

#### 注：温馨提示：若要完成此题，请先完成 [「EZEC-5」人赢] 。(https://www.luogu.com.cn/problem/P7286)

### 题意简述
- 给定 $k$ 个数，下标从 $1$ 到 $n$。

- 你需要从中选取两个数。

- 按照 $f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y) &x \ne y \\ k_x\times x&x=y \end{cases}$ 的规则运算。

- 求出最大值。
      
- $1 \le n \le 10^7$，$1 \le k_{i} \le 10^9$。

- **时限$300ms$**。
## $O(n^2)$ 做法
看题可以很轻松的想到，我们可以把**每一种可能的组合全部枚举一遍，比较大小。**   
这样可以解决，同时时间复杂度会打到 $n^2$。
### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long int ll;
const ll mm=1e7+10;
ll n,k[mm],maxn,now;
inline ll read(){
	char ch=getchar();
	ll ans=0,cf=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-')cf=-1;
		ch=getchar(); 
	}
	while(ch>='0'&&ch<='9'){
		ans=(ans<<3)+(ans<<1)+(ch^48);
		ch=getchar(); 
	}
	return ans*cf;

}
int main(){
	n=read();
    for(ll i=1;i<=n;i+=1)k[i]=read();
    for(ll i=1;i<=n;i+=1){
    	for(ll j=1;j<=n;j+=1){
    		if(i==j)now=k[i]*i;
    		else now=min(k[i],k[j])*(i+j);
    		maxn=max(maxn,now);
		}
	}
	printf("%llu\n",maxn);
	return 0;
}
```
## $O(nlogn)$ 做法
更进一步思考。   
我们可以发现，**对于任何一个数 $k_i$ ，只要存在另外一个数 $k_j$ 比他小，且与它不同，那么它们的结果一定是 $(i+j)*k_i$** 。  
那么，我们就可以想到：对于任何一个数 $k_i$ ，我们只需要考虑**比它大的数中最大的下标是什么**，循环 $n$ 次，就可以得到最后答案。

那么怎么来判断大小呢？   
**排序**。
我们可以升序排列，这样后面的数就一定你前面的数大了。  
那么问题又来了。

**应该怎么判断所有比我大的数中下标最大的呢？**   
我们可以考虑排序后**倒序从 $n$ 到 $1$ 在进行一个后缀预处理**。  
我们可以判断，后 $n$ 个数中下标最大的是多少。   
即 $maxn_i=\max(maxn_{i+1},num_i)$。


最后就能实现以下效果。
### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
ll n,maxx[11000000],sum;
struct node{
	ll num,a;
}k[11000000];
bool cmp(node x,node y){
	return x.a<y.a;
}
inline ll read(){
	char ch=getchar();
	ll cf=1,ans=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')cf=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans=(ans<<3)+(ans<<1)+(ch^48);
		ch=getchar();
	}
	return ans*cf;
}
int main(){
	n=read();
	for(ll i=1;i<=n;i+=1)k[i].a=read(),k[i].num=i,sum=max(sum,k[i].num*k[i].a);
	sort(k+1,k+n+1,cmp);
	for(ll i=n;i>=1;i-=1){
		maxx[i]=max(maxx[i+1],k[i].num);
	}
	for(ll i=1;i<=n;i+=1){
		sum=max(sum,k[i].a*(k[i].num+maxx[i+1]));
	} 
	printf("%lld\n",sum); 
	return 0;
} 
```
## $O(n)$ 做法
在上一种做法的基础上，我们在进行进一步的思考。
可以发现。  
**如果存在一个数 $k_i$ 和另一个数 $k_j$。  
要与 $k_p$ 组合。      
$i<j$ 且 $k_i<k_j$**,你会选哪一个？

很显然， $k_j$ 一定优于 $k_i$。  

那么我们在选择时，就可以率先筛选出这样一个最优的选择。   
最后一一验证，即可。
### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long int ll;
const ll mm=1e7+20;
ll k[mm],n,now,nownum,maxn;
inline ll read(){
	char ch=getchar();
	ll ans=0,cf=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-')cf=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans=(ans<<1)+(ans<<3)+(ch^48);
		ch=getchar(); 
	}
	return ans*cf;
}
int main(){
    n=read();
    for(ll i=1;i<=n;i+=1){
        k[i]=read();
        now=max(now,max(k[i]*i,(i+nownum)*min(k[i],k[nownum])));
        if(k[i]*i>maxn)maxn=k[i]*i,nownum=i;
    }
    maxn=0;
    nownum=0;
    for(ll i=n;i>=1;i-=1){
        now=max(now,(i+nownum)*min(k[i],k[nownum]));
        if(k[i]*i>maxn)maxn=k[i]*i,nownum=i;
    }
    printf("%lld\n",now);
    return 0;
}
```
## 谢谢观看！

---

## 作者：赵悦岑 (赞：0)

# 题解 P7291

到博客观看效果更佳

## 非加强版

### 思路

先看这个公式：

 $f(x,y)=\begin{cases}min(k_x,k_y)\times(x+y)&x\ne y\\k_x\times x&x=y\end{cases}$
 
对于一个固定的 $x$ ，  $x\leqslant y$ 时 $f(x,y)$ 最大时， $y$ 一定是从后往前搜第一个大于 $x$ 的数。一旦搜到就换下一个 $x$ ，如没有比 $x$ 大的数则与 $k_x\times x$ 比较。对于 $x<y$ 的情况，一定有另一个 $x_0=y$ 的情况，所以不用单独考虑。


------------

### Code

```cpp

for(int i=1;i<=n;++i)
{
    s=max(s,a[i]*i);//直接比较也阔以
    for(int j=n;j>=1;--j)//从后往前
    {
        if(a[j]>=a[i]&&i!=j)//注意，i!=j才可以
        {
            s=max(s,a[i]*(i+j));
            break;//找到的第一个一定使值最大
        }
    }
}
```


------------

## 加强版

~~等到考试后来改，这也太……~~

万里长征第一步，先把题面上的快读打起，读入快到飞起。


------------

### 思路

我们先从后往前遍历数组；

1. 当当前这个数是目前最大的时候，和上一个最大值匹配、更新，并更新最大值。

2. 如果不是，也与之前的最大值匹配、更新。

现在解释一下：

假设有三个数： $k_a$ ， $k_b$ 和 $k_c$ ，如果 $k_a\geqslant k_b\geqslant k_c$ 且 $a<b<c$ ，现在只用匹配 $f(a,b)$ 与 $f(b,c)$ 即可求出最大值。因为 $a,c$ 匹配时， $min(k_a,k_c)=k_c$ ，而 $b,c$ 匹配时， $min(k_b,k_c)=c$ ，又因为 $a+c<b+c$ ，所以 $f(a,c)<f(b,c)$ ，只用比较 $f(a,b)$ 与 $f(b,c)$ 。

如果 $k_a\leqslant k_c\leqslant k_b$ 且 $a<b<c$ 时， $min(k_b,k_c)=k_c\geqslant min(k_a,k_c)$ ，又因为 $a+c<b+c$ ，所以 $f(a,c)\leqslant f(b,c)$ ，还是只用比较 $f(a,b)$ 与 $f(b,c)$ 。


------------

### Code
```cpp
for(int i=n;i>=1;--i)//从后往前
{
    if(a[i]>m)//如情况1
    {
        s=max(s,m*(x+i));//匹配、更新
        m=a[i];//更新最大值
        x=i;
    }
    else//如情况2
    {
    	s=max(s,a[i]*(x+i));//匹配、更新
    }
}
s=max(s,m*x);//最大的那个要单独比较、更新
```

------------

重要的事情说3遍：快读！快读！快读！



------------


---


# [COCI 2018/2019 #2] Deblo

## 题目描述

给定一个包含 $n$ 个结点的树，其中每个结点都有一个权值。一条路径的权值定义为该路径经过的所有结点的权值异或后的结果。

你的任务是求出所有路径的权值之和。

## 说明/提示

#### 样例 1 解释

路径 $1 \to 1$ 的权值为 $1$；

路径 $1 \to 2$ 的权值为 $1⊕2=3$；

路径 $1 \to 3$ 的权值为 $1⊕2⊕3=0$；

路径 $2 \to 2$ 的权值为 $2$；

路径 $2 \to 3$ 的权值为 $2⊕3=1$；

路径 $3 \to 3$ 的权值为 $3$。

所有路径的权值之和为 $1+3+0+2+1+3=10$。

#### 数据规模与约定

对于 $30\%$ 的数据，$N \le 200$。

对于 $50\%$ 的数据，$N \le 1000$。

对于另外 $20\%$ 的数据，$x=1,2,\cdots,N-1$ 中的每个结点都和结点 $x+1$ 之间有一条边。

对于 $100\%$ 的数据，$1 \le a_j,b_j \le N \le 10^5$，$0 \le v_i \le 3 \times 10^6$。

#### 说明

**本题分值按 COCI 原题设置，满分 $90$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #2](https://hsin.hr/coci/archive/2018_2019/contest2_tasks.pdf)  _T3 Deblo_。**

## 样例 #1

### 输入

```
3
1 2 3
1 2
2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 3 4 2 1
1 2
1 3
3 4
3 5```

### 输出

```
64```

## 样例 #3

### 输入

```
6
5 4 1 3 3 3
3 1
3 5
4 3
4 2
2 6```

### 输出

```
85```

# 题解

## 作者：dayz_break404 (赞：9)

注意到位运算每一位都是独立的，考虑将权值的每一位拆开，单独考虑每一位对答案的贡献。

先枚举每一位，这样原树就变成了一颗只有 $0$ 和 $1$ 的树。很明显只有当路径上的 $1$ 的个数为奇数时，这条路径才会对答案产生贡献。

记 $dp_{u,0}$ 表示路径的一个端点为 $u$，另一个端点在 $u$ 的子树，路径上的 $1$ 的个数为偶数时，这样的路径的条数。同理 $dp_{u,1}$ 为 $1$ 的个数为奇数。

转移时进行分类讨论：

- 若当前的节点 $u$ 第 $w$ 位是 $1$，那么对于其每一个子节点 $v$，有 $dp_{u,0}+=dp_{v,1},dp_{u,1}+=dp_{v,0}$。
- 若当前的节点 $u$ 第 $w$ 位是 $0$，那么对于其每一个子节点 $v$，有 $dp_{u,0}+=dp_{v,0},dp_{u,1}+=dp_{v,1}$。

考虑如何计算答案，显然对于一条路径只有两种情况：

- $lca_{a,b}$ 不为 $a$ 或者 $b$，有 $ans+=dp_{u,1}\times dp_{v,0}+dp_{u,0}\times dp_{v,1}$，其中 $v$ 是 $u$ 的子节点。
- $lca_{a,b}$ 为 $a$ 或者 $b$ 其中一个，有 $ans+=dp_{u,1}$。

时间复杂度 $O(n\log V)$，其中 $V$ 为值域。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
#define ll long long
const int maxn=1e5+20;
int a[maxn],n,head[maxn],idx,dp[maxn][2],mul[40];
ll ans;
struct node{
	int nxt,to;
}e[maxn<<1];
inline void add(int u,int v){
	e[++idx].to=v,e[idx].nxt=head[u],head[u]=idx;
}
void dfs(int u,int fa,int w){
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u,w);
		ans+=1ll*dp[u][1]*dp[v][0]*mul[w]+1ll*dp[u][0]*dp[v][1]*mul[w];
		if(a[u]&1) dp[u][0]+=dp[v][1],dp[u][1]+=dp[v][0];
		else dp[u][0]+=dp[v][0],dp[u][1]+=dp[v][1];
	}
	dp[u][a[u]&1]++;
	ans+=1ll*dp[u][1]*mul[w];
}
int main(){
	mul[0]=1;
	for(int i=1;i<=30;i++) mul[i]=mul[i-1]*2;
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	int u,v;
	for(int i=1;i<n;i++) u=read(),v=read(),add(u,v),add(v,u);
	for(int i=0;i<=30;i++){
		dfs(1,0,i);
		for(int j=1;j<=n;j++) a[j]>>=1,dp[j][0]=dp[j][1]=0;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：3)

点分。

发现每位独立，考虑位拆。

对于每位维护 $0/1$ 各有多少个。

然后你查询的时候把每一位的值取反后在这一位查询即可。

$O(n\log n\log V)$。

---

## 作者：zhaohongdi114514 (赞：3)

### 树形dp

> 若一道题看不出算法，那么大概率是 dp。
> —— XGH

因为答案为异或和之和，所以有显而易见的拆位处理，因此以下的内容均针对单个二进制位。

设 $dp_{u,i,j}$ 表示：

1. $i=0$ 时表示以 $u$ 为根的子树中，至少一端为 $u$，异或和为 $j$ 的路径条数。

2. $i=1$ 时表示以 $u$ 为根的子树中，无一端为 $u$，异或和为 $j$ 的路径条数。

考虑如何状态转移，显然某条路径可以由两条不同子树的路径拼接而成，所以有状态转移如下：

$$
dp_{u,0,j}=\sum dp_{v,0,j \otimes a_u }\\
dp_{u,1,j}=\sum dp_{v,0,j}+dp_{v,1,j}+\sum_{k\otimes p\otimes a_u=j} dp_{v_1,0,k}\times dp_{v_2,0,p}
$$

于是就可以愉快的 AC 本题了。

C++

```c++
#include<bits/stdc++.h>
#define geti(x,i) (((x)>>(i))&1) //获得x的第i个二进制位
using namespace std;
using ll=long long;
const int N=1e5+5,M=22;
int n;
int a[N];
vector<int> mp[N];
ll /*路径条数*/dp[N]/*以u为根的子树中*/[2]/*0 至少一端为根  1 无端点为根*/[2]/*异或和 0/1*/;
ll ans;
void dfs(int u,int fa,int i){
    dp[u][0][geti(a[u],i)]=1;//u与u本身为两端点构成的路径
    dp[u][0][!geti(a[u],i)]=0;//同上
    dp[u][1][0]=dp[u][1][1]=0;//清零
    for (int v:mp[u]){
        if (v==fa) continue;
        dfs(v,u,i);
    }
    ll sum0=0,sum1=0;
    //在v之前遍历的子树中以该子树为根的异或和为0/1的路径条数
    for (int v:mp[u]){
        if (v==fa) continue;
        dp[u][1][0]+=dp[v][0][0]+dp[v][1][0];
        dp[u][1][1]+=dp[v][0][1]+dp[v][1][1];
        //不以u为端点的路径中完全不经过u的部分
        if (geti(a[u],i)){
            dp[u][0][0]+=dp[v][0][1];
            dp[u][0][1]+=dp[v][0][0];
            dp[u][1][0]+=sum0*dp[v][0][1]+sum1*dp[v][0][0];
            dp[u][1][1]+=sum0*dp[v][0][0]+sum1*dp[v][0][1];
        }
        else{
            dp[u][0][0]+=dp[v][0][0];
            dp[u][0][1]+=dp[v][0][1];
            dp[u][1][0]+=sum0*dp[v][0][0]+sum1*dp[v][0][1];
            dp[u][1][1]+=sum0*dp[v][0][1]+sum1*dp[v][0][0];
        }
        //将两棵子树的答案拼接
        sum0+=dp[v][0][0];
        sum1+=dp[v][0][1];
    }
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for (int i=1;i<=n;i++) cin>>a[i];
    for (int i=1,u,v;i<n;i++){
        cin>>u>>v;
        mp[u].push_back(v);
        mp[v].push_back(u);
    }
    for (int i=0;i<=M;i++){
        dfs(1,-1,i);
        ans+=((dp[1][0][1]+dp[1][1][1])<<i);
    }
    cout<<ans;
}
```

---

## 作者：ycy1124 (赞：2)

### 题意
在一个有 $n$ 个点的树上，每个点都有一个权值 $v_i$，定义树上的一条路径的权值是其所经过的所有点的异或和，求所有路径的权值总和。
### 思路
直接去考虑所有位感觉是很难的，所以我们考虑一位一位的去计算。对于每一个点，我们使用 $dp_{u,0}$ 表示在点 $u$ 的子树内到达点 $u$ 最后一位异或和为 $1$ 的路径个数，$dp_{u,1}$ 表示在点 $u$ 的子树内到达点 $u$ 最后一位异或和为 $0$ 的路径个数。很容易就能够想到转移方程：
$$
\large dp_{u,0}=\sum^{点 u 的儿子节点}_i dp_{i,0\otimes w(v_u\equiv w \pmod 2)}
$$
$$
\large dp_{u,1}=\sum^{点 u 的儿子节点}_i dp_{i,1\otimes w(v_u\equiv w \pmod 2)}
$$
初始值设：
$$
\large dp_{u,w(v_u\equiv w \pmod 2)}=1,dp_{u,1\otimes w(v_u\equiv w \pmod 2)}=0
$$
并且答案也很好计算，我们只需要在转移的时候统计一下，每次将 $ans$ 加上 $(dp_{u,1}\times dp_{i,0}+dp_{u,0}\times dp_{i,1})\times2^{pos}$ 即可。记得加上初始值的贡献。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[100001][2],ans,n,v[100001],pos;
vector<int>a[100001];
inline void dfs(int p,int fa){
    dp[p][v[p]&1]++;
    for(auto it:a[p]){
        if(it==fa){
            continue;
        }
        dfs(it,p);
        ans+=(dp[p][0]*dp[it][1]+dp[p][1]*dp[it][0])*(1<<pos);
        dp[p][1]+=dp[it][1^(v[p]&1)];
        dp[p][0]+=dp[it][0^(v[p]&1)];
    }
    if(v[p]&1){
        ans+=(1<<pos);
    }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>v[i];
    }
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        a[u].push_back(v);
        a[v].push_back(u);
    }
    bool bj=1;
    while(bj){
        dfs(1,0);
        bj=0;
        for(int i=1;i<=n;i++){
            dp[i][0]=dp[i][1]=0;
            v[i]>>=1;
            if(v[i]){
                bj=1;
            }
        }
        pos++;
    }
    cout<<ans;
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/195949175)

---

## 作者：Cells (赞：2)

#### 前置知识

请先完成[这道题](https://www.luogu.com.cn/problem/P3917)。

#### 思路

因为异或是按位计算，所以我们只需要一位一位拆开来看。这里大概只有三十位。

通过完成异或序列，我们能发现这里的操作不过是从线性的变为了树上的。我们能联想到用树形 DP 来解决这个问题。

我们设 $dp_{u,i,j}$ 表示以 $u$ 这个节点为根的子树，异或值为 $i$ 的路径总数，注意这种路径必须全部包含在以 $u$ 这个节点为根的子树中，另外用 $j$ 表示这条路径是否至少有一个端点在根节点 $u$ 上。

首先，为什么要设是否至少有一个端点在根节点 $u$ 上这一维呢？因为我们发现两条路径是可以合并的。设根节点 $u$ 的儿子为 $v$，则两条端点在 $v$ 上的路径可以加上根节点进行合并。当然，这种合并以后的路径端点不能算是在根节点上。另外，一条端点在 $v$ 上的路径也可以与根节点合并。为了做到不重不漏，我们先将所有子节点深搜完毕，在进行转移，转移时记录 $dp_{v,0,1}$ 以及 $dp_{v, 1, 1}$ 的数量来转移。详见代码。

当然，每一次的答案贡献就是 $(dp_{root,1,0}+dp_{root,1,1}) \times 2^i$，$i$ 就是深搜外面枚举的位数。

**Code**

```c++
# include <bits/stdc++.h>
# define eb emplace_back
# define mem(a, b) memset(a, b, sizeof (a))
# define rep(i, a, b) for(int i = a; i <= b; i ++)
using namespace std;

using LL = long long;

const int N = 1e5 + 10;

int n;
int val[N];
LL ans, dp[N][2][2];//第二维表示路径异或值，第三维为1表示至少一个端点在根节点上，否则不在 

vector<int> e[N];

void dfs(int u, int fa, int w){
	int p = (val[u] >> w) & 1;//将根节点的这一位取出来，因为单独的根节点也算是一条路径 
	LL zero = 0, one = 0;//分别记录dp[v][0][1],dp[v][1][1] 
	
	dp[u][1][1] = p;
	dp[u][0][1] = dp[u][1][1] ^ 1;//只能有一个 
	
	for(int v : e[u]){
		if(v == fa) continue;
		dfs(v, u, w);//先dfs完毕 
	}
	
	for(int v : e[u]){
		if(v == fa) continue;
		dp[u][1][1] += dp[v][p ^ 1][1];//要想把路径与根节点合并，就需要让它的值为p^1 
		dp[u][0][1] += dp[v][p][1];//一样就是0 
		dp[u][1][0] += dp[v][1][0] + dp[v][1][1];//管你在没在v上，只要没有合并，就没在根节点 
		dp[u][0][0] += dp[v][0][0] + dp[v][0][1];
		dp[u][p ^ 1][0] += zero * dp[v][1][1] + one * dp[v][0][1];//p^1 就需要两条路径异或为1，所以0*1，1*0 
		dp[u][p ^ 0][0] += zero * dp[v][0][1] + one * dp[v][1][1];//同上 
		zero += dp[v][0][1];//即时记录 
		one += dp[v][1][1];
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	rep(i, 1, n) cin >> val[i];
	
	rep(i, 1, n - 1){
		int a, b;
		cin >> a >> b;
		e[a].eb(b);
		e[b].eb(a);
	}
	
	rep(i, 0, 30){
		mem(dp, 0);//记得清空数组 
		dfs(1, 0, i); 
		ans += (dp[1][1][1] + dp[1][1][0]) * (1 << i);//贡献答案 
	}
	
	cout << ans;
	
	return 0;
}
```

**感谢你能看到这里！！!**

---

## 作者：_anll_ (赞：1)

点分治好耶！

## 思路

首先，看见路径异或和，我们就应该想到用前缀异或和进行维护。于是这件事情就变成了点对的问题。暴力会有一个基础 $O(n^2)$ 的时间复杂度，如果用树剖或者倍增求 lca 会再多个 $\log$。对于这种点对问题，我们考虑用点分治来解决，这样时间复杂度就会陡降。

点分治在这里就不赘述，不会的指路：[P3806 【模板】点分治 1](https://www.luogu.com.cn/problem/P3806)

考虑拆位维护。具体地，我们拿 $cnt$ 存储当前子树内所有点到当前根节点的前缀异或和，开个桶 $s$ 按位存储一共有多少个点的前缀异或和的当前位为 $1$。

每次更新答案时，我们就枚举当前数 $x$ 的每一位。如果当前位为 $0$，说明当前位为 $1$ 有贡献；反之亦然。

最后统计答案时别忘了加上每个点的权值。总时间复杂度为 $O(n\log n\log V)$，其中 $V$ 为值域。

## 代码
比点分治板子短，注意细节。
```cpp
#include<vector>
#include<iostream>
#define int long long
using namespace std;
const int N=1e5+5;
int n,ans,si,num[N];
int rt,sum,maxn,siz[N];
int del[N],s[40];
vector<int> edges[N],cnt; 
void Findrt(int x,int fa,int an=0){
	siz[x]=1;
	for(auto l:edges[x]){
		if(l==fa||del[l]) continue;Findrt(l,x);
		siz[x]+=siz[l],an=max(an,siz[l]);
	}
	an=max(an,sum-siz[x]);
	if(maxn>an) maxn=an,rt=x;
}
void dfs(int x,int fa,int a){
	a^=num[x];cnt.push_back(a);
	for(auto l:edges[x])
		if(l!=fa&&!del[l]) dfs(l,x,a);
}
void add(int x){
	for(int i=0;i<30;i++) s[i]+=(x>>i&1);
}
void upd(int x){
	for(int i=0;i<30;i++){
		if(!(x>>i&1)) ans+=s[i]*(1<<i);
		else ans+=(si-s[i])*(1<<i);
	}
}
void calc(int x){
	del[x]=1;add(num[x]);si++;
	for(auto l:edges[x]){
		if(del[l]) continue;
		dfs(l,0,num[x]);
		for(auto a:cnt) upd(a^num[x]);//注意我们会多算一次根节点的权值 所以更新时我们应该再异或一次根节点的权值
		for(auto a:cnt) add(a);
		si+=cnt.size();cnt.clear();
	}
	for(int i=0;i<30;i++) s[i]=0;si=0;
}
void work(int x){
	calc(x);
	for(auto l:edges[x]){
		if(del[l]) continue;
		rt=l,sum=maxn=siz[l];
		Findrt(l,0);work(rt);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;int f,l;
	for(int i=1;i<=n;i++) cin>>num[i],ans+=num[i];
	for(int i=1;i<n;i++){
		cin>>f>>l;
		edges[f].push_back(l);
		edges[l].push_back(f);
	}
	sum=maxn=n,rt=1;
	Findrt(1,0);work(rt);
	cout<<ans;
	return 0;
}
```

---

## 作者：dutianchen1 (赞：1)

# [COCI2018-2019#2] Deblo

### 思路简析

题目要求所有路径异或和的和，显然我们可以对每一位单独进行计算异或和。

接下来考虑拆分路径。显然我们可以把一条 $(u,v)$ 的路径的异或和，拆分成 $(u,\text{lca}(u,v))$ 和 $(\text{lca}(u,v),v)$ 两条链的异或和的和。

我们考虑用 $val_{i,0/1}$ 表示：第 $i$ 个点到根节点异或值为 $0/1$ 的异或和。

我们所求的也就是 $\sum_{}val_{x,0} \times val_{y,1}+val_{x,1}\times val_{y,0}$。

简单解释下，当前节点的异或和肯定是由左侧子树异或和为 $0$ 与右侧节点异或和为 $1$ 或左右翻转贡献得到。 

转移也就好想了：（令 $num_{x,i}$ 为第 $x$ 个点第 $i$ 位在二进制下的值）
$$
val_{x,0} \rightarrow val_{x,0}+val_{y,num}\\
val_{x,1} \rightarrow val_{x,1}+val_{y,num}
$$
代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
ll n;
ll num[N];
ll val[N][2];
ll ans;
struct node{
	ll nxt,to;
}e[N<<1];
ll head[N],tot; 
void add(ll x,ll y){
	e[++tot].nxt=head[x];
	e[tot].to=y;
	head[x]=tot;
}
void dfs(ll x,ll fa,ll pos){
	val[x][((num[x]>>pos)&1)]=1;
	for(int i=head[x];i;i=e[i].nxt){
		ll y=e[i].to;
		if(y==fa)continue;
		dfs(y,x,pos);
		ans+=(val[x][0]*val[y][1])<<pos;
		val[x][0]+=val[y][((num[x]>>pos)&1)];
		ans+=(val[x][1]*val[y][0])<<pos;
		val[x][1]+=val[y][((num[x]>>pos)&1)^1];
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		num[i]=read();ans+=num[i];
	}
	for(int i=1;i<n;i++){
		ll x=read(),y=read();
		add(x,y);add(y,x);
	} 
	
	for(int i=0;i<=25;i++){
		memset(val,0,sizeof(val));
		dfs(1,0,i);
	}
	cout<<ans<<'\n';
    return 0;  
}
```

---

## 作者：Mr_罗 (赞：1)

现有的题解都是 dp 做法，提供一个点分治思路。

要求异或，可以拆位。转换成每一个点有一个 $0/1$ 的点权，求有多少条路径异或为 1 。这是经典点分治，维护一个有两个元素的桶，然后就做完了。

时间复杂度 $\mathcal{O}(n\log n\log V)$ ，其中 $V$ 是值域。

P.S. 需要轻微卡常，例如把 `vector` 换成链式前向星。

```cpp
#include <bits/stdc++.h>
using namespace std;

// #define CF

#define ll long long
#define ul unsigned ll
#define LL __int128_t
#define db double
#define DB long db
#define pii pair<int, int>
#define fi first
#define se second
#define rep(i, l, r) for (int i(l), i##End(r); i <= i##End; i = -~i)
#define per(i, r, l) for (int i(r), i##End(l); i >= i##End; i = ~-i)
#define TT(T) template<typename T>

constexpr int N = 100005, M = 200005;
constexpr ll mod = 998244353;
int n, m, rt;
ll ans, res;
int a[N];
int hd[N], ed[M], nt[M], cnt;
int sz[N], wt[N] = {N};
int t[2], p[2];
bool vis[N];

TT(T) void chkmx(T &a, ll b) { if (a < b) a = b; }
TT(T) void chkmn(T &a, ll b) { if (a > b) a = b; }
TT(T) void modad(T &a, ll b) { a += b; if (a >= mod) a -= mod; }
TT(T) void modsu(T &a, ll b) { a -= b; if (a < 0) a += mod; }
TT(T) void modml(T &a, ll b) { (a *= b) %= mod; }
ll mdadd(ll a, ll b) { a += b; return (a >= mod ? a - mod : a); }
ll mdsub(ll a, ll b) { return (a >= b ? a - b : a - b + mod); }
ll mdmul(ll a, ll b) { return a * b % mod; } // What's Montgomery Algorithm?

void addeg(int u, int v)
{
    ed[++cnt] = v, nt[cnt] = hd[u], hd[u] = cnt;
}

int getsz(int u, int ft)
{
    int res = 1;
    for (int i = hd[u]; i; i = nt[i]) if (int v = ed[i]; v != ft && !vis[v]) res += getsz(v, u);
    return res;
}

void getdis(int u, int ft, int d)
{
    #ifndef ONLINE_JUDGE
    printf("getdis(%d, %d, %d):\n", u, ft, d);
    #endif
    p[d]++;
    for (int i = hd[u]; i; i = nt[i]) if (int v = ed[i]; v != ft && !vis[v]) getdis(v, u, d ^ ((a[v] >> m) & 1));
}

void fdrt(int u, int ft, int tot)
{
    sz[u] = 1, wt[u] = 0;
    for (int i = hd[u]; i; i = nt[i]) if (int v = ed[i]; v != ft && !vis[v]) fdrt(v, u, tot), sz[u] += sz[v], chkmx(wt[u], sz[v]);
    chkmx(wt[u], tot - sz[u]); if (wt[rt] > wt[u]) rt = u;
}

void calc(int u)
{
    for (int i = hd[u]; i; i = nt[i])
    {
        int v = ed[i];
        if (vis[v]) continue;
        p[0] = p[1] = 0, getdis(v, u, (a[v] >> m) & 1);
        res += p[0] * t[1] + t[0] * p[1];
        if ((a[u] >> m) & 1) t[0] += p[1], t[1] += p[0];
        else t[0] += p[0], t[1] += p[1];
        #ifndef ONLINE_JUDGE
        printf("calc(%d): %d | %d %d | %d %d\n", u, v, p[0], p[1], t[0], t[1]);
        #endif
    }
    res += t[1] + ((a[u] >> m) & 1), t[0] = t[1] = 0;
}

void solve(int u)
{
    #ifndef ONLINE_JUDGE
    printf("solve(%d):\n", u);
    #endif
    vis[u] = 1, calc(u);
    for (int i = hd[u]; i; i = nt[i])
    {
        int v = ed[i];
        if (vis[v]) continue;
        rt = 0, fdrt(v, u, sz[v]), solve(rt);
    }
}

void solve()
{
    scanf("%d", &n);
    rep(i, 1, n) scanf("%d", a + i);
    rep(i, 2, n)
    {
        int u, v; scanf("%d%d", &u, &v);
        addeg(u, v), addeg(v, u);
    }
    for (m = 0; m <= 21; m++)
    {
        res = 0, memset(vis, 0, sizeof(vis));
        rt = 0, fdrt(1, 0, n), solve(rt);
        ans += (res << m);
    }
    printf("%lld\n", ans);
}

int main()
{
    #ifdef CF
    int _; scanf("%d", &_);
    while (_--) solve();
    #else
    solve();
    #endif
    return 0;
}
```

吐槽：满分 $90$ 是什么鬼？

---

## 作者：Viktley (赞：1)

# 题目大意：

- 给出一棵树，问树上所以路径的和。

- 一条路径的权值定义为该路径经过的所有结点的权值异或后的结果。

# 思路：

大佬都说是点分制再加上树的重心，

但我就是不会打，蒟蒻讲一下 DP 的做法。

首先，要定义一个 DP 数组，怎么定义呢？这就要看题目了。

题目要求我们求所有路径的异或和，

所以 DP 的第一维我们定义以 $i$ 为根的子树，

然后第二三位就是第 $j$ 位为 $1$ 或 $0$ 的方案数，

再者 $2^{22}$ 刚好大于 $v[i]$ 的最大值， $j<=22$ 。

那么 $dp[i][j][k]$ 就表示：

以 $i$ 为根的子树内有多少条路径的异或和的第 $j$ 位为 $k(0/1)$ 。（大家感性理解一下）

怎么转移呢，当然是从他的子树转移过来了。

下面是我的树形 DP ,具体看注释 ~~（我写了注释）~~

# Code:

```cpp
#include <cstdio>
#include <iostream>
#define ll long long
using namespace std;

const int N = 1e5 + 10;
struct node
{
	int u, v, next;
} e[N * 2];
int n, x, y, tot, h[N];
ll ans, v[N], dp[N][25][2];

void add(int x, int y)
{
	e[++tot] = (node){x, y, h[x]};
	h[x] = tot;
}

void Tree_dp(int x, int fa)
{
	for(int i = 0; i < 23; i++) //预处理v[x]本身的二进制的每一位是否为1/0
		dp[x][i][(v[x] >> i) & 1]++;
	for(int i = h[x] ; i; i = e[i].next)
	{
		int u = e[i].v;
		if(fa != u)
		{
			Tree_dp(u, x);
			for(int j = 0 ; j < 23; j++)
			{
				 ans += (dp[x][j][0] * dp[u][j][1] + dp[u][j][0] * dp[x][j][1]) * (1 << j);
				//这里十分令人费解，其实他就是想要把每条路径的每一位分开算，
				//所以在二进制意义下要把这一位扩大1<<j倍才能把这一位还原到原来的位置
				if ((v[x] >> j) & 1) //如果v[x]的第j位为1异或起来之后就能把1变成0，把0变成1
                    dp[x][j][0] += dp[u][j][1], dp[x][j][1] += dp[u][j][0];
                else
                    dp[x][j][0] += dp[u][j][0], dp[x][j][1] += dp[u][j][1];
			}
		}
	}
}

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) 
		scanf("%lld", &v[i]), ans += v[i];
	for(int i = 1; i < n; i++)
		scanf("%d%d", &x, &y), add(x, y), add(y, x);
	Tree_dp(1, 0);
	printf("%lld\n", ans);
	return 0;
}
```



---

## 作者：Shellchen (赞：0)

这题是我们机房模拟赛压轴题（~现在 Div.3 压轴题都这么水的吗~），被我场切了，于是来写篇题解。

看到异或运算可以想到拆位，于是问题就变成点权只有 $0$ 和 $1$ 的情况怎么做。考虑树形 dp。用 $dp_u$ 表示以 $u$ 为路径的一端向下走的答案之和，$siz_u$ 表示 $u$ 的子树大小，$v$ 是 $u$ 的子节点，$a_u$ 是 $u$ 的点权，于是有：

$$ dp_u = \begin{cases}
a_u = 0 & \sum dp_v \\
a_u = 1 & \sum (siz_v-dp_v)
\end{cases}$$

另外，还要考虑以 $u$ 为 LCA 的路径答案总和 $sum_u$。设 $v_1$，$v_2$ 为 $u$ 的不同子节点，于是不难推出：

$$ sum_u = \begin{cases}
a_u = 0 & \sum ((siz_{v_1}-dp_{v_1}) \times dp_{v_2} + \sum ((siz_{v_2}-dp_{v_2}) \times dp_{v_1}) \\
a_u = 1 & \sum (dp_{v_1} \times dp_{v_2} + (siz_{v_1}-dp_{v_1}) \times (siz_{v_2}-dp_{v_2}))
\end{cases}$$

可以用前缀和优化求解。完结撒花。

总复杂度 $O(n \log v_i)$。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
//#pragma GCC optimize(3,"Ofast","inline")
const int N=1e5+10,mod=1e9+7;
vector<int>adj[N];
int a[25][N];
int i;
int siz[N];
int dp[N];
int ans=0;
void init(int u,int fa)
{
	siz[u]=1;
	for(auto v:adj[u])
	{
		if(v==fa) continue;
		init(v,u);
		siz[u]+=siz[v];
	}
}
void dfs(int u,int fa)
{
	if(a[i][u]==1) dp[u]=1;
	for(auto v:adj[u])
	{
		if(v==fa) continue;
		dfs(v,u);
		if(a[i][u]==1) dp[u]+=siz[v]-dp[v];
		else dp[u]+=dp[v];
	}
	ans+=(dp[u]<<i);
	if(a[i][u]==1)
	{
		int sum=0;
		for(auto v:adj[u])
		{
			if(v==fa) continue;
			ans+=(sum<<i)*dp[v];
			sum+=dp[v];
		}
		sum=0;
		int x=0;
		for(auto v:adj[u])
		{
			if(v==fa) continue;
			x+=(sum<<i)*(siz[v]-dp[v]);
			sum+=siz[v]-dp[v];
		}
		ans+=x;
	}
	else
	{
		int sum=0;
		for(auto v:adj[u])
		{
			if(v==fa) continue;
			sum+=dp[v];
		}
		int x=0;
		for(auto v:adj[u])
		{
			if(v==fa) continue;
			x+=(sum-dp[v])*(siz[v]-dp[v])*(1<<i);
		}
		ans+=x;
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) 
	{
		int x;
		cin>>x;
		if(n==1)
		{
			cout<<x;
			return 0;
		}
		for(int j=0;j<=22;j++) if(x&(1<<j)) a[j][i]=1;
	}
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	init(1,0);
	for(i=0;i<=22;i++)
	{
		memset(dp,0,sizeof(dp));
		dfs(1,0);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Wei_Han (赞：0)

不会点分，我是菜批。

发现异或路径和不好一起处理，考虑拆位，把整棵树变成只有 01 的树，我们每次记录以每个点为根路径和为 0/1 的路径条数，记作 $s_{i,0/1}$。显然，当为叶子时，只有到自己这一条路径，考虑继续向上合并。

不考虑这一个点的情况下，以这个点为终点的路径就是各个子树之和，然后经过这个点的路径条数只需要再一遍枚举子树，记以当前节点为终点下 0/1 的路径条数为 $sum_{0,1}$，经过这个点的路径条数为 $p_{u,0/1}$，则有:

$p_{u,1} = \sum (s_{v,0}\times (sum_1-s_{v,1})+s_{v,1}\times(sum_0-s_{v,0}))$

$p_{u,0} = \sum (s_{v,1}\times (sum_1-s_{v,1})+s_{v,0}\times(sum_0-s_{v,0}))$

这个还是很好理解的，只是拼接一下两边的路径再计数，要注意这个 $p_{u,1/0}$ 是没去除重复路径的，需要对路径条数除以 $2$，然后还要考虑当前这个点为 $0/1$，就只是把 $s_{v,1/0}$ 交换一下就行了，具体实现可以参考代码。

时间复杂度 $O(n\log V)$，其中 $V$ 是值域。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define pr putchar('\n')
#define pp putchar(' ')
#define pii pair<ll,ll>
#define pdi pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define fi first
#define se second
#define pb push_back
//#pragma GCC optimize(2)
using namespace std;
typedef long long ll;
typedef double db;
const int N=5e5+10,M=1e7+5;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}

ll n,a[N],ans;
vector<ll> g[N];
inline pii dfs(ll x,ll fa,ll k){
	ll cnt=0;pii op,sum,summ;op={0,0};sum={0,0};summ={0,0};if(a[x]&(1<<k)) op.fi=1;else op.se=1;vector<pii > V;
	for(int v:g[x]){
		if(v==fa) continue;
		cnt++;pii now=dfs(v,x,k);
		if(a[x]&(1<<k)) op.fi+=now.se,op.se+=now.fi;
		else op.fi+=now.fi,op.se+=now.se;
		summ.fi+=now.fi,summ.se+=now.se; 
		V.push_back(now);
	}
	if(!cnt){ans+=(1<<k)*op.fi;return op;}ll opp=0;
	for(int v:g[x]){
		if(v==fa) continue;
		pii now=V[opp++];
		ll sum0=summ.se-now.se,sum1=summ.fi-now.fi;
		if(a[x]&(1<<k)) sum.fi+=now.se*sum0+now.fi*sum1,sum.se+=now.fi*sum0+now.se*sum1;
		else sum.fi+=now.fi*sum0+now.se*sum1,sum.se+=now.fi*sum1+now.se*sum0;
	}
	ans+=sum.fi*(1<<k)/2;
	ans+=op.fi*(1<<k);
	return op;
}
signed main(){
	read(n);fo(1,i,n) read(a[i]);
	fo(1,i,n-1){ll u,v;read(u),read(v);g[u].pb(v),g[v].pb(u);}
	fo(0,i,22) dfs(1,0,i);wr(ans);pr;
	return 0;
}	
``````

---

## 作者：yxy666 (赞：0)

我首先想到了一个比较差的想法，定义 $sum_{i}$ 表示i这个节点从上到根节点的异或和，$val_i$ 表示 i 这个节点的权值。我们就可以枚举两个节点，通过 LCA 来求出最近公共祖先 fa，然后这两个点的贡献就是 $sum_i $ ^ $ sum_j$ ^$val_{fa}$。时效较差。

接下来我们从答案的角度考虑问题。对于每一个节点的权值都可以转化成二进制的形式。定义$sum_{x,i,k}$ 表示从根节点到 x 这个节点二进制第 i 位为k的有多少个。那么一个树形 DP 就招之欲出了。$^$ 的运算规则是不同为 1。

我们接下来只需要从根节点往下遍历，对于 x 这个节点，它的父亲节点为 fa。
那么它的贡献就为 

$\sum_{i = 1}^{22}$$(sum_{x,i,0}\times sum_{fa,i,1}+sum_{fa,i,0}\times sum_{x,i,1})\times $ `1<<i` 。

就下来就要想 $sum_{x,i,k}$ 该如果求值了。除了当前节点的权值，还有上一状态。对于第 i 位，如果 为真，那么只改变，就反着继承父亲节点的值，否则就正常继承。

详见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005,maxk=23;
int n,tot,lnk[maxn],nxt[2*maxn],son[2*maxn],w[maxn];
bool vis[maxn];
long long ans,sum[maxn][maxk][2];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch))ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void add_e(int x,int y){son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;}
void dfs(int x){
	vis[x]=1;
	for(int i=0;i<=22;i++)sum[x][i][w[x]>>i&1]++;//统计当前节点
	for(int j=lnk[x];j;j=nxt[j]){
		if(vis[son[j]])continue;
		dfs(son[j]);//只能往下遍历
		for(int i=0;i<=22;i++){
			ans+=(sum[x][i][1]*sum[son[j]][i][0]+sum[x][i][0]*sum[son[j]][i][1])<<i;
            		//统计答案
			if(w[x]>>i&1)sum[x][i][1]+=sum[son[j]][i][0],sum[x][i][0]+=sum[son[j]][i][1];//如果有值，那么1/0就要取反
			else sum[x][i][1]+=sum[son[j]][i][1],sum[x][i][0]+=sum[son[j]][i][0];//否则就是不变
		}
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)w[i]=read(),ans+=w[i];
	int x,y; 
	for(int i=1;i<n;i++)x=read(),y=read(),add_e(x,y),add_e(y,x);
	dfs(1);
	printf("%lld\n",ans);
	return 0;
}
```


---


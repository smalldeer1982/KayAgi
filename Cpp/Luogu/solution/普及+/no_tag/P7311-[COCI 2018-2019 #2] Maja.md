# [COCI 2018/2019 #2] Maja

## 题目描述

蜜蜂 Maja 在一个神奇的牧场里为花朵传粉。牧场可用一个 $N \times M$ 的矩阵表示。在第 $i$ 行第 $j$ 列有 $C_{i,j}$ 朵未传粉的花。

Maja 从位于第 $A$ 行第 $B$ 列的蜂巢出发，并前往牧场的一些区域后返回。Maja 可以在 $1$ 步内从当前区域前往相邻的区域（即位于原区域的左、右、上或下方的区域），但不会离开牧场。每当 Maja 经过一个区域，它将会将该区域所有未传粉的花全部进行传粉。但牧场是神奇的！Maja 在离开区域 $(i,j)$ 后，所有传过粉的花将全部消失，而紧接着将会有 $C_{i,j}$ 朵未传粉的花重新生长。

由于 Maja 不能一直飞下去，因此它将在 $K$ 步后感到劳累。Maja 在 $K$ 步内从蜂巢出发并返回的途中，最多能为多少朵花传粉？

## 说明/提示

#### 样例 1 解释

Maja 从 $(1,1)$ 开始，先向下飞行，为 $2$ 朵花传粉，然后再返回。

#### 样例 2 解释

Maja 从 $(1,1)$ 开始，依次向右、下、上、左飞行。由于 Maja 经过了 $(1,2)$ 两次，因而它每经过一次，便可为 $5$ 朵花传粉。

#### 数据规模与约定

对于 $40\%$ 的数据，$K \le 10^4$。

对于 $100\%$ 的数据，$2 \le N,M \le 100$，$1 \le A \le N$，$1 \le B \le M$，$2 \le K \le 10^9$，$0 \le C_{i,j} \le 10^9$，$K \bmod 2=0$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #2](https://hsin.hr/coci/archive/2018_2019/contest2_tasks.pdf)  _T4 Maja_。**

## 样例 #1

### 输入

```
2 2 1 1 2
0 1
2 10```

### 输出

```
2```

## 样例 #2

### 输入

```
2 2 1 1 4
0 5
5 10```

### 输出

```
20```

## 样例 #3

### 输入

```
3 3 2 2 6
5 1 0
1 0 3
1 3 3```

### 输出

```
15```

# 题解

## 作者：伟大的王夫子 (赞：9)

看到本题没有题解，那就由我来写一篇吧。

首先，看到这题，我想到了一种十分暴力的 dp 做法。

令 $f_{i, j, k}$ 表示走了 $k$ 步，最后到达 $(i,j)$ 的最大数量。
状态转移较为简单，方程也不列了。不过，$K\le10^9$，很明显，这个算法是行不通的。

还好 $n,m$ 的数据范围较小。因为 $K$ 可以大于 $n\cdot m$，所以说，Maja 肯定要在几个点上来回走动，最后再回到终点。于是我们来考察一下这几个点的性质。

引理：Maja 一定是在一个点和与这个点相邻的权值最大的点周期性地来回地走动。

我们简单证明一下这个引理。假设 Maja 是在三个点上来回走动。这是不可能得到最优解的。因为此时，他不如选择其中权值最大的两个点进行走动，反而更优。

就比如说，这三个点分别是1,2,3，权值为$a,b,c$。如果这么来回走，那么就是$1 \to 2 \to 3 \to 2 \to 1 \to 2 \to 3 \to 2 \cdots$。

明显可以看出，周期为4，并且一个周期平均权值为 $\dfrac{2b+a+c}{4}$。

当然，我们还有两种决策，平均权值分别为 $\dfrac{a+b}{2}$ 与 $\dfrac{b+c}{2}$。

因为 $\dfrac{b+c}{2} + \dfrac{a+b}{2}=2 \cdot \dfrac{2b+a+c}{4}$。

所以这两者平均权值必有一个大于后者。

综上，我们证明了必须在相邻两个点来回走动。

然后还是 dp。状态类似，就是步数上限变成了 $n\cdot m$。中途根据引理统计答案。

$f_{i,j,k} = \max{f_{i-1,j,k-1},f_{i+1,j,k-1},f_{i,j-1,k-1},f_{i,j+1,k-1}} + a_{i, j}$

其中 $k$ 这一维用滚动数组可以优化掉。

计算过程中可以顺便统计一下答案，只要根据引理，取与当前这个点相邻的点中权值最大的即可。

时间复杂度 $O(n^2m^2)$，空间复杂度 $O(nm)$，足以通过此题。另外，很明显要开 long long。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[110][110], A, B;
typedef long long ll;
ll f[110][110][2], ans, K;
const int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, -1, 1};
bool valid(int x, int y) {
	return x >= 1 && x <= n && y >= 1 && y <= m;
}
int main() {
	scanf("%d%d%d%d%lld", &n, &m, &A, &B, &K);
	for (register int i = 1; i <= n; ++i)
		for (register int j = 1; j <= m; ++j) scanf("%d", a[i] + j);
	bool tag = 1;
	memset(f, 0xcf, sizeof f);
	f[A][B][1] = 0;
	for (register int k = 1; k <= min(1ll * n * m, K >> 1); ++k) {
		tag ^= 1;
		for (register int i = 1; i <= n; ++i)
			for (register int j = 1; j <= m; ++j) {
				ll maxc = 0;
				for (register int p = 0; p < 4; ++p) {
					int nx = i + dx[p], ny = j + dy[p];
					if (!valid(nx, ny)) continue;
					f[i][j][tag] = max(f[i][j][tag], f[nx][ny][tag ^ 1] + a[i][j]);
					maxc = max(maxc, 1ll * a[i][j] + a[nx][ny]);
				}
				ans = max(ans, (f[i][j][tag]) * 2 + (K / 2 - k) * maxc - a[i][j]);
			}
	} 
	printf("%lld", ans);
}
```


---

## 作者：HomuraAkemi (赞：1)

类似题：ABC358G。

不难发现，最优策略一定是走到某个地方之后，在两个格子之间反复横跳，然后返回原点。

感性理解就是如果 $k$ 很大的话，在两个和最大的格子反复横跳能够带来最高的收益。证明讨论一下即可。

这里显然要求 $k\gt nm$。我们得到 $k$ 的上界后直接做一个 DP：$f(i,j,k)$ 为从起点走 $k$ 步到 $(i,j)$ 的收益最大值，然后边 DP 边更新答案。DP 的转移是显然的。

视 $n,m$ 同阶。状态数 $\Theta(n^4)$，转移 $\Theta(1)$，故时间复杂度 $\Theta(n^4)$。

喜欢小圆 qwq。

---

## 作者：CaoSheng_zzz (赞：1)

### 思路
首先对于本题我们需要看出三个很关键的要素：

1. 最终一定是走过某些格子，然后原路返回到原点。

2. 为了最大化价值，人物如果产生循环节，那么必然是走到循环节，然后兜上几圈再原路返回。

3. 循环节大小为 $ 2 $。

对于 $ 3 $ 的证明：

假设 $ k $ 比较大 $ (k \geq n \times m) $ 必然是在某个环上绕圈，否则没地方走了。

然后，在某个长度大于 $ 2 $ 的环上绕圈必然不会比在该环相邻 $ 2 $ 个之和最大的两个点之间来回走更优。

我们把环上的相邻点两两分组，和最大的那组的平均值必然不小于总环的平均值。否则总和小于总和矛盾。

这些弄懂了之后我们就可以先设一个 DP 数组 $ f_{i,j,k} $，$ f_{i,j,k} $ 表示走了 $ k $ 步之后达到点 $ (i , j) $ 的最大值。

由此我们可以推出状态转移方程：$ f_{i,j,k} = \max(f_{i,j,k} , f_{i,j+1,k-1} , f_{i,j-1,k-1} , f_{i+1,j,k-1} , f_{i-1,j,k-1}) $。

我们的大致思路完了可以自己去尝试写代码了，记得开`longlong`。

Code：
```cpp
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <queue>
#define ll long long
#define prt printf
#define sc(ppt) scanf("%d" , &ppt)
#define scl(ppt) scanf("%lld" , &ppt)
using namespace std;

const ll IM = -9223372036854775807;
ll f[105][105][2] , w[105][105];
ll n , m , A , B , k , ans = IM;

ll Max(ll a , ll b , ll c , ll d){
	return max({a , b , c , d});
} 

signed main(){
	scl(n) ; scl(m) ; scl(A) ; scl(B) ; scl(k) ; k >>= 1;
	for(int i=0 ; i<=n+1 ; i++){
		for(int j=0 ; j<=m+1 ; j++) w[i][j] = f[i][j][0] = f[i][j][1] = IM;
	}
	for(int i=1 ; i<=n ; i++){
		for(int j=1 ; j<=m ; j++) scl(w[i][j]);
	}
	f[A][B][0] = 0;
	for(ll res=1 ; res<=min(k , n * m) ; res++){
		ll now = res & 1 ; ll opt = now ^ 1;
		for(int i=1 ; i<=n ; i++){
			for(int j=1 ; j<=m ; j++){
				ll Temp = Max(f[i - 1][j][opt] , f[i + 1][j][opt] , f[i][j - 1][opt] , f[i][j + 1][opt]);
				f[i][j][now] = max(Temp + w[i][j], IM * 1LL);
				if(f[i][j][now] < 0) continue ;
				ll dat = f[i][j][now] + Temp;
				dat += (k - res) * (w[i][j] + Max(w[i - 1][j] , w[i + 1][j] , w[i][j - 1] , w[i][j + 1]));
				ans = max(ans , dat);
			}
		}
	}
	prt("%lld" , ans);
	return 0;
}

```

---

## 作者：Handezheng (赞：0)

# 题解：P7311 [COCI2018-2019#2] Maja
[题目传送门](https://www.luogu.com.cn/problem/P7311)

[更垃圾的阅读体验](https://www.luogu.com.cn/article/7lt4a9k2)
## 题意
给定 $n\times m$ 的网格和起点，每个格子的权值为 $c_{i,j}$，共可以走 $k$ 步，求最大的 $\sum_{i,j}^{走过网格i,j}c_{i,j}$。

其中，有 $n,m\le100,k\le10^9,2\mid k$。
## 思路
应为 $k$ 很大，所以一定会在某一些位置**循环跑动**，而循环节的**长度为二时一定最优**，下面给出证明：

设循环节长度为三且三个点的权值分别为 $a,b,c$，而此时的平均权值为 $\frac{a+2b+c}4$。  
若循环节长度为二，会有两种方案，平均权值分别为 $\frac{a+b}2$ 和 $\frac{b+c}2$。  
能够发现，$\frac{a+b}2+\frac{b+c}2=2\times \frac{a+2b+c}4$，所以前两者必有一个大于等于后者（当且仅当 $a=b=c$ 时等号成立）。

循环节大于三时证明与其类似，这里不再赘述。

那我们便可以把 $k$ 步转化为 $n\times m$ 步，**在其范围内进行 DP**，对于每一个网格取其相邻的权值最大网格为循环节，取得它们和的最大值即为答案。

时间复杂度 $O(n^2m^2)$，空间复杂度 $O(nm) $。

### DP过程
设 $f_{k,i,j}$ 表示第 $k$ 步，网格坐标为 $(i,j)$ 时取得的最大值。

初始化 $f_{k,i,j}$ 为极大值，$f_{0,a,b}=0$。

转移：$f_{k,i,j}=\max{f_{k-1,i-1,j},f_{k-1,i+1,j},f_{k-1,i,j-1},f_{k-1,i,j+1}}+c_{i,j}$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define F(i,l,r) for(int i = l;i <= r;i++)
const int N = 1e6 + 50,M = 1e3 + 50;
const int INF = 0x3f3f3f3f3f3f3f3f,INT = 0x7fffffff;
const int mod = 1e9 + 7;

int n,m,stx,sty,q,ans=-INF;
int c[105][105],mx[105][105];
int f[3][105][105];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	
	memset(f,0xcf,sizeof f);
	cin>>n>>m>>stx>>sty>>q;
	F(i,1,n) F(j,1,m) cin>>c[i][j];
	F(i,1,n) F(j,1,m) mx[i][j]=max(max(c[i-1][j],c[i+1][j]),max(c[i][j-1],c[i][j+1]))+c[i][j];
	f[0][stx][sty]=0;
	for(int k=1;k<=min(q/2,n*m);k++){
		int t=k&1,l=t^1;
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
			f[t][i][j]=max(max(f[l][i-1][j],f[l][i+1][j]),max(f[l][i][j-1],f[l][i][j+1]))+c[i][j];
			ans=max(ans,f[t][i][j]*2 + (q/2-k)*mx[i][j] - c[i][j]);
		}
	}
	cout<<ans;

	return 0;
}
``````
——$2024.10.14,11:28$ 完笔。

---


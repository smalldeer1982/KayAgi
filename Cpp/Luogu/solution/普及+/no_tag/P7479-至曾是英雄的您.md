# 至曾是英雄的您

## 题目背景

YSGHYYDS

## 题目描述

YSGH 有一个 $n\times m$ 的围棋棋盘，初始时，每个位置要么是空的，要么有一个黑棋棋子。**保证黑棋是连通的。**

在围棋中，一个棋子的「气」是与它相邻的所有**空**位置构成的集合。

设棋盘上第 $i$ 行第 $j$ 个位置为 $(i,j)$。

两个分别在 $(i_1,j_1)$ 和 $(i_2,j_2)$ 的**同色**棋子如果满足 $|i_1-i_2|+|j_1-j_2|=1$，就认为是相邻的，也就是在同一个连通块里。

一个连通块的「气」是这个连通块中所有棋子的「气」的并集。

白方走一步棋是合法的，当且仅当走完这手棋之后这个棋子所在连通块的「气」大于等于 $1$ 或者黑棋连通块的「气」等于 $0$。

比如下图，绿色的位置都是黑棋连通块的「气」。

![](https://cdn.luogu.com.cn/upload/image_hosting/wzrjvpox.png)

「活棋」的定义：无论对方连续走多少手棋，在每步棋都是合法的情况下，该连通块的「气」都大于等于 $1$。

请你判断这个黑棋连通块是否是「活棋」。

如果是，输出 `YES`，否则输出 `NO`。

**本题有多测。**

## 说明/提示

**【样例解释 #1】**

第 1 组数据：

白棋依次走 $(1,1),(2,1),(3,2),(3,3),(3,4),(1,5),(2,5),(1,3)$ 即可使得黑棋连通块的「气」变成 $0$ 了。

不妨用 `@` 表示白棋，那么最终局面就是：

```plain
@*@*@
@***@
.@@@.
```

第 2 组数据：

比方说白棋先走 $(1,1)$ 那么白棋之后就再也走不到 $(1,3)$ 和 $(2,1)$ 了，导致黑棋的「气」永远大于等于 $1$，所以黑棋是「活棋」。

第 3 组数据：

最终使得黑棋连通块的「气」等于 $0$ 的局面：

```plain
@*@@.
@***@
**@**
*@.@*
**@**
*****
```

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le n, m \le 2 \times {10}^3$，$1 \le T \le {10}^5$。输入的初始棋盘的每个位置要么是 `.`，要么是 `*`，并且至少有一个 `.`，至少有一个 `*`。**保证黑棋是连通的。** 保证每个测试点的 $n \times m$ 之和都小于等于 $4 \times {10}^6$。

- Subtask 1（9 points）：$n = 1$。
- Subtask 2（10 points）：$n = 2$，$m = 3$。
- Subtask 3（16 points）：保证 `.` 的个数不超过 $7$，$n, m \le 10$，$T \le 50$。
- Subtask 4（24 points）：保证 `.` 的个数不超过 $14$，$n, m \le 10$，$T \le 50$。
- Subtask 5（15 points）：$n, m \ge 3$，输入局面的边界上都是 `.`。即 $\forall (i, j)$，如果 $i = 1 \lor i = n \lor j = 1 \lor j = m$，则 $(i, j)$ 一定是空地。 
- Subtask 6（26 points）：无特殊限制。 

---
---
---

P.S. Froggy 和 uyom 都是（很久没下棋的）业余四段哥，欢迎找我们然后把我们虐一顿。

## 样例 #1

### 输入

```
3
3 5
.*.*.
.***.
.....
2 5
.*.*.
.***.
6 5
.*...
.***.
**.**
*...*
**.**
*****```

### 输出

```
NO
YES
NO```

## 样例 #2

### 输入

```
1
1 3
.*.
```

### 输出

```
YES```

# 题解

## 作者：Jairon314 (赞：16)

$$ \textbf {P7479 [B]至曾是英雄的您} $$

~~业余五段来了~~

想不到我一个业余五段竟然被两个业余四段出的题卡了好久才过...

作为一个小学的时候（也好久不下了）下了六年围棋的选手，我上来看到这题的第一反应就是找眼。什么是眼呢？~~概念我也忘了~~就是指由黑棋与边界围成的范围（白棋不能把里面填满；黑棋与黑棋围起来的也行）

比如下面这几个图形中黑棋围起来的中间的部分就是眼

```
2 3
*.*
***
```

```
3 3
***
*.*
***
```

```
3 3
***
*.*
**.

```

```
3 4
****
*..*
****
```

知道了眼的概念以后，我们发现当黑棋与白棋交替下棋的时候，如果这块黑棋又两颗眼，那么白棋是不能杀掉黑棋的。可是我们发现这种方法马上被hack了——因为白棋是可以连续下的。看下面这个棋盘

```
7 5
*******
****.**
*.*...*
****.**
*******
```

这里黑棋有两颗眼，但是右边的梅花五中白棋可以把边界填上，在下一个棋子放入左边的眼中，黑棋就死了。

于是我又想到了一种方法，不考虑白棋能不能下，用白棋把黑棋的气都填上（如果白棋下的地方不是黑棋的气，那就对黑棋没有威胁了）。最后，如果白棋的方案是合法的，那黑棋一定是死的，否则是活的。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

#define int long long

#define rep(i,a,b) for(register int i(a);i^(b+1);++i)

/***************快读***************/

namespace IO {
char buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];
inline char gc () {return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}

#ifndef ONLINE_JUDGE
#endif

#define gc getchar

template<class I>
inline void read(I &x) {
    x = 0; I f = 1; char c = gc();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc(); }
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = gc(); }
    x *= f;
}

template<class I>
inline void write(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf1[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf1[--cnt]);
}

#define in(x) read(x)
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')

} using namespace IO;

/***************快读***************/

#define maxn 5010

int t,n,m;
char map1[maxn][maxn];
bool vis[maxn][maxn];
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};

//dfs求白棋的气判断死活
inline bool dfs(register int x,register int y){
	vis[x][y]=1;
	register bool flag=false;
	for(register int i=0;i^4;++i){
		register int NewX=x+dx[i];
		register int NewY=y+dy[i];
		if(map1[NewX][NewY]=='.'){
			flag=1;
		}
		if(NewX>0&&NewY>0&&NewX<=n&&NewY<=m&&!vis[NewX][NewY]&&map1[NewX][NewY]=='@'){
			flag|=dfs(NewX,NewY);
		}
	}
	return flag;
}

signed main(){
	read(t);
	while(t--){
		read(n),read(m);
		for(register int i=0;i<=n+1;++i){
			for(register int j=0;j<=m+1;++j){
				map1[i][j]=';';
				vis[i][j]=false;
			}
		}
		for(register int i=1;i<=n;++i){
			for(register int j=1;j<=m;++j){
				std::cin>>map1[i][j];
			}
		}
		for(register int i=1;i<=n;++i){
			for(register int j=1;j<=m;++j){
				if(map1[i][j]=='*'){
					if(map1[i][j+1]=='.'){
						map1[i][j+1]='@';
					}
					if(map1[i+1][j]=='.'){
						map1[i+1][j]='@';
					}
					if(map1[i][j-1]=='.'){
						map1[i][j-1]='@';
					}
					if(map1[i-1][j]=='.'){
						map1[i-1][j]='@';
					}
				}
			}
		}//这段代码把黑棋的气全变成白棋
		register int cnt=0;
		for(register int i=1;i<=n;++i){
			for(register int j=1;j<=m;++j){
				if(cnt>=2){//如果白棋有大于等于一个地方是非法的，直接退出，黑棋是活的
					j=m+1,i=n+1;
					continue;
				}
				if(map1[i][j]=='@'){
					if(!vis[i][j]&&!dfs(i,j)){
						++cnt;
						// std::cout<<i<<" "<<j<<endl;
					}
				}
			}
		}
		if(cnt>=2){
			puts("YES");
		}
		else{
			puts("NO");
		}
	}
	return 0;
}


/*
10
5 5
.****
*...*
*...*
*...*
*****
*/
```


---

## 作者：BrotherCall (赞：7)

## 以一个从未下过围棋者的视角，介绍一下做题思路：
### 涉及算法：DFS求连通块
在我反复观察样例解释之后，发现了以下特点：

$1.$ 每个黑棋四周的点必须由任意障碍堵上（包括黑棋/白棋/边界）。

由第一点可以推导出第二点：

$2.$ **最后剩下的空置的点，必须不能是四周存在黑棋的点。**

### 一个感性的理解：

由于最终空置的点，是防止整个连通块“失去元气”的点。因此我们感性的称之为“救世主”。“救世主”必须是四周不存在黑棋的点。如果一个连通块不存在任何一个点可以当“救世主”，那么这个连通块注定是会被“憋气”的。

由于围棋中还存在“一击毙命”的操作，我们得到以下结论：

**若有两个及以上的连通块不存在“救世主”，那么这盘棋注定为死棋。**

## 代码实现：
先使用DFS求连通块，再判断该连通块中是否存在“救世主”。若存在这输出 $YES$ ，反之输出 $NO$。

## Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;

int T;
char G[2010][2010];
int M[2010][2010];//M用于记录某点属于的连通块标号
bool alive[2010];
int n,m,tot = 0;
int xx[5] = {0,1,-1,0,0} ,
    yy[5] = {0,0,0,1,-1} ; 

void search(int x,int y){//DFS求连通块
	M[x][y] = tot;
	for(int i=1;i<=4;i++){
		int newx = x + xx[i], newy = y + yy[i];
		if(M[newx][newy] == 0 && G[newx][newy] == '.')search(newx,newy);
	}
}

int main(){
cin>>T;
while(T--){
	cin>>n>>m;
	for(int i=0;i<=n+1;i++){
		for(int j=0;j<=m+1;j++){
			G[i][j] = ' ';
			M[i][j] = 0;
		}
	}
	for(int i=1;i<=tot;i++)
		alive[i] = false;
	tot = 0;//以上均为初始化
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>G[i][j];
			if(G[i][j] == '*')M[i][j] = -1;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(M[i][j] != 0)continue;
			tot++;
			search(i,j);//调用DFS
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(M[i][j] == -1)continue;
			if(M[i+1][j] != -1 && M[i-1][j] != -1 && M[i][j+1] != -1 && M[i][j-1] != -1)
				alive[M[i][j]] = true;//若该连通块存在救世主，则标记为true
		}
	}
	int ss = 0;
	for(int i=1;i<=tot;i++)if(!alive[i])ss++;
	if(ss >= 2)cout<<"YES"<<endl;
	else cout<<"NO"<<endl;//结论
}
return 0;
}
```


---

## 作者：Miraik (赞：5)

谨以此题解，纪念我曾经六年的围棋时光和我即将结束的初中 OI 生涯。

作为一位曾经的围棋爱好者，读完题的第一反应就是“找眼”。

如果下过围棋，应该知道一块有 $\ge 2$ 只眼的棋一定是活棋。

写完提交，发现 WA 了。 ![/jk](https://cdn.luogu.com.cn/upload/pic/62234.png)

为什么呢？我们看下面这个例子（~~别问为什么用弈城，问就是野狐防沉迷~~

![](https://cdn.luogu.com.cn/upload/image_hosting/1gkdeytp.png)

按照围棋的定义，显然这块棋有 $2$ 只眼（实际上从围棋的角度还不止），那么它是活棋吗？

![](https://cdn.luogu.com.cn/upload/image_hosting/6dozqs81.png)

众所周知，围棋是轮流落子的。因此在围棋中，黑棋只需要：

![](https://cdn.luogu.com.cn/upload/image_hosting/0jtvw4qz.png)

就会

![](https://cdn.luogu.com.cn/upload/image_hosting/24lu55yu.png)

容易发现白棋无法鲨死黑棋。

但是我们发现，本题中 **活棋** 的定义是：

无论对方连续走多少手棋，在每步棋都是合法的情况下，该连通块的「气」都大于等于 $1$。

换句话说，在本题中，黑棋是没有权利落子的！

那么

![](https://cdn.luogu.com.cn/upload/image_hosting/98mhljpo.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hizafs3n.png)

这块棋没了。![/youl](https://cdn.luogu.com.cn/upload/pic/69020.png)

那我们的做法不对了啊！ ![/fad](https://cdn.luogu.com.cn/upload/pic/62250.png)

不要慌！

通过上面那个例子，我们容易发现：

这块棋是否活棋，不取决于它本身，而是围住它的白子是不是合法的！

例如：

![](https://cdn.luogu.com.cn/upload/image_hosting/cm3p3zxz.png)

我们发现上图两个画 X 的点是不可能同时占到的！

因此我们把黑棋周围的所有点全部放上白棋，然后判断是否存在 $\ge 2$ 块白棋没有「气」。如果存在，则这块棋是活棋。否则为死棋。

具体用 DFS 搜索连通块实现，并不困难，具体可以参照代码。

时间复杂度 $O(Tnm)$。

```cpp
/*
+   +   +   +    +++     +++++     ++++
 + +     + +      +         +      +   +
  +       +       +        +       +   +
 + +      +       +       +        +   +
+   +     +      +++     +++++     ++++
*/
#include<bits/stdc++.h>
//#define int ll
#define pb push_back
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
using namespace std;
typedef long long ll;
const int N=2005;
const int inf=1<<30;
const ll inff=1ll<<60;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
int n,m,a[N][N],b[N][N];
int cnt,vis[N][N];
char s[N];
const int fx[632410]={0,1,-1,0,0},fy[632410]={0,0,0,1,-1};
bool life(int x,int y){ // 判断这个子周围是否存在「气」
	if(x>1&&a[x-1][y] == 0 && b[x-1][y] == 0) return 1;
	if(x<n&&a[x+1][y] == 0 && b[x+1][y] == 0) return 1;
	if(y>1&&a[x][y-1] == 0 && b[x][y-1] == 0) return 1;
	if(y<m&&a[x][y+1] == 0 && b[x][y+1] == 0) return 1;
	return 0;
}
bool dfs(int x,int y){ //dfs搜索连通块
	vis[x][y] = 1;
	bool ok = 0;
	if(life(x,y)) ok = 1; // 这个子周围存在「气」，那么这个连通块必然有气
	for(int i=1;i<=4;i++){
		int xx = x+fx[i], yy = y+fy[i];
		if(xx>0 && xx<=n && yy>0 && yy<=m && !vis[xx][yy] && b[xx][yy]) ok= dfs(xx,yy) || ok ;
        // 注意 ： 不要写成 ok = ok || dfs(xx,yy) ！！！
        // 因为那样在 ok = 1 时不会继续dfs，
        // 导致一个连通块的vis数组未全部标记
	}
	return ok;
}
int main(){int tests=1;tests=read();//
while(tests--){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)
		    if(s[j]=='.')a[i][j]=0;
		    else a[i][j]=1;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		    vis[i][j]=b[i][j]=0;
            //vis数组标记这个点是否已在之前的连通块中搜过
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j])
				b[i+1][j]=b[i-1][j]=b[i][j-1]=b[i][j+1]=1;
                //标记，黑棋的周围全部是白棋
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		    if(a[i][j])b[i][j]=0;
            //如果这个位置已经有黑棋了，那就没有白棋
	/*
	for(int i=1;i<=n;i++,puts(""))
	    for(int j=1;j<=m;j++)
	        if(a[i][j])putchar('b');
	        else if(b[i][j])putchar('w');
	        else putchar('.');
	*/
	cnt = 0; // cnt 表示没有「气」的白棋连通块的个数
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	    	if(b[i][j] && !vis[i][j])cnt += !dfs(i,j);
            // dfs(i,j)返回这块白棋是否有「气」
	puts(cnt > 1 ? "YES" : "NO");
}	return 0;
}
/*
1
5 5
***..
*.***
....*
...**
.....
*/
```


---

## 作者：CGDGAD (赞：5)

### 题目大意

给你一个棋盘，棋盘里有一块连通的黑棋。要你在它的周围下白棋，但下的每一步白棋必须满足：

- 这个白棋下完以后所在的白棋连通块至少有一口气；

或

- 这个白棋下完以后黑棋已没有气。

如果最终能使黑棋没有气，输出 `NO`；否则输出 `YES`。

----

### 思路

以样例 3 为例。遍历每一个没有棋子的连通块。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gp90ma05y7j309i0pmab5.jpg)![](https://tva1.sinaimg.cn/large/008eGmZEgy1gp90pbtqz7j30a40uagmf.jpg)

图 2 是包围黑子所必须下的白棋。

图 1 是所有的没有棋子的连通块。

显然，左上角的红色连通块必须要放满白棋，中间的绿色连通块只用放四个角的四个就行，中间的那个格子不用。在蓝色连通块中，最右上角的那个格子也不用放白棋。

那么我们的下棋顺序可以是：绿色连通块的四个 → 蓝色连通块的三个 → 红色连通块。当红色连通块的最后一个棋子下完以后，虽然红色连通块没有气了，但黑棋也没有气了。是合法的。

当然，也可以蓝 → 绿 → 红，因为蓝和绿不用下满，无论怎么下，它上面的白棋至少有一口气可以呼吸。但红必须最后一个下。

-----

总结：

当一个连通块必须被下满的时候，它必须得放在最后一个下。

所以，当必须下满的连通块大于 1 个时，黑棋无法被包围，它是“活棋”。

否则，它不是“活棋”。

----

### 做法

遍历每一个没有棋子的连通块，然后对于每一个连通块，遍历它的每一个点。如果这个点与黑棋相邻，则标记这个点。最终，如果被标记的点的个数与连通块中点的总数相等（即这个连通块需要得被下满），则标记这个连通块。如果最终被标记的连通块总数大于 1，则输出 YES，否则输出 NO。

查找连通块可以用并查集实现；剩下的只需要模拟即可。

我的做法是超大常数的，使用了 `vector` + `set`，不开 O2 会 T 掉 6 个点。于是愉快地换成手写的 `vector`，过了。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1gp91e8c4ehj308u04kaa7.jpg)

----

### Code

[手写 Vec 部分](https://paste.ubuntu.com/p/RS8fvYqBZq/)

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <set>

// 手写 vector 部分见链接

const int N = 2001;
int n, m;
char map[N][N];
int father[N * N];
NSO::Vector<int> buck[N * N];
std::set<int> qwq;
int dX[4] = {0, 1, 0, -1};
int dY[4] = {1, 0, -1, 0};
inline int read() {
    int t = 0; char ch = getchar();
	while (ch < '0' || ch > '9') { ch = getchar(); }
    do { t = t * 10 + ch - '0'; ch = getchar(); } while (ch >= '0' && ch <= '9');
    return t;
}
inline char readChar() {
    char ch = getchar();
    while (ch != '*' && ch != '.') ch = getchar();
    return ch;
}
void init() {
    qwq = std::set<int>();
    for (register int i = 1; i <= n * m + 2; ++i)
        father[i] = i, buck[i] = NSO::Vector<int>();
}
int findFather(int x) {
    if (father[x] == -1)
        return -1;
    if (father[x] != x) {
        father[x] = findFather(father[x]);
    }
    return father[x];
}
void merge(int r1, int r2) {
    r1 = findFather(r1);
    r2 = findFather(r2);
    if (findFather(r1) != findFather(r2))
        father[r1] = r2;
}
bool isRelative(int r1, int r2) {
    return findFather(r1) == findFather(r2);
}
int convert(int x, int y) { // 并查集实现部分我将一个坐标编码为了一个整数，即 (行号 - 1) * 总列数 + 列号
    return (x - 1) * m + y;
}
void mian() {
    n = read(), m = read();
    init();
    
    // 读入
    for (register int i = 1; i <= n; ++i)
        for (register int j = 1; j <= m; ++j) {
            map[i][j] = readChar();
            if (map[i][j] == '*')
                father[ convert(i, j) ] = -1; // 不需要判黑棋连通块，所以全给 -1
        }

    // 并查集
    for (register int i = 1; i <= n; ++i) {
        for (register int j = 1; j <= m; ++j) {
            for (register int k = 0; k < 4; ++k) {
                int newX = i + dX[k];
                int newY = j + dY[k];

                if (newX >= 1 && newY >= 1 && newX <= n && newY <= m) {
                    if (map[newX][newY] == '.' && map[i][j] == '.') { // 合并
                        merge(convert(newX, newY), convert(i, j));
                    }
                }
            }
        }
    }
    
    // 找连通块
    for (register int i = 1; i <= n * m; ++i) {
        if (father[i] != -1) {
            buck[findFather(i)].push_back(i); // buck[i] 里装连通块编号为 i 的所有位置编号
            qwq.insert(findFather(i)); // 一个 set 记录所有的连通块编号
        }
    }

    // 遍历
    int qaq = 0;

    // 遍历每一个联通块
    for (int item : qwq) {
        int count = 0;

        for (register int i = 0; i < buck[item].size(); ++i) { // 遍历一个联通块中每一个点（手写 Vector 无法用 C++11（悲））
        	int pos = buck[item][i];
            int y = (pos % m) == 0 ? m : pos % m;
            int x = (pos - y) / m + 1; // 解码成坐标
            for (register int k = 0; k < 4; ++k) {
                int newX = x + dX[k];
                int newY = y + dY[k];

                if (newX >= 1 && newY >= 1 && newX <= n && newY <= m) {
                    if (map[newX][newY] == '*') { // 如果与黑棋子相邻
                        ++count;
                        break;
                    }
                }
            }
        }
        if (count >= buck[item].size())
            ++qaq;
    }
    if (qaq >= 2) fputs("YES\n", stdout);
    else fputs("NO\n", stdout);
}
// 【main 函数已被隐藏】
```

---

## 作者：__sxx (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7479)
# 大意
一块黑棋在白棋走任意步后仍为活棋是输出 `YES`，否则输出 `NO`。
# 思路
先枚举出每一口黑棋的气，用数组标记他们的位置，再用循环 $+$ BFS 求每一个连通块的气，最多只能有一个连通块的气为 $0$ 黑棋才不是活棋，输出 `YES`，否则输出 `NO`。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
struct node
{
	int x,y;
};
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
queue<node>q;
bool v[2005][2005];
int n,m,a[2005][2005],b[2005][2005],u=0,t1=0;
int c(int x,int y)
{
	
	if(a[x][y]==2&&b[x][y]==2) return 1;//如果当前那格不为黑棋且不为黑棋的气，则那格为白棋联通块的气，相反则不是
	else return 0;
}
int main()
{
   cin>>t;
   while(t--)
   {
   	 char h;
   	 cin>>n>>m;
   	 u=0;
   	 
   	 for(int i=1;i<=n;i++)
   	 {
   	 	for(int j=1;j<=m;j++)
   	    {
		  v[i][j]=true;
		 
   	    cin>>h;
		if(h=='*')a[i][j]=1;
		else a[i][j]=2; 	
		}
	 }
	 for(int i=1;i<=n;i++)
	 {
	 	for(int j=1;j<=m;j++)
   	    {
	 	  if(a[i][j]==2)//如果当前那格不是黑棋
		   {
		   	  if(a[i-1][j]==1||a[i][j-1]==1||a[i][j+1]==1||a[i+1][j]==1)b[i][j]=1;//如果当前那格不是黑棋且周围四格至少有一个是黑棋，则这格为黑棋的气
		   	  else b[i][j]=2;
		   }
	  	  else b[i][j]=2;
	    }
	 }
	 for(int i=1;i<=n;i++)
	 {
	 	for(int j=1;j<=m;j++)
	 	{
	 		if(b[i][j]==1&&v[i][j]==true)//如果当前那格是黑棋的气且没有计算过，就开始用BFS求当前连通块的气
	 		{
	 			q.push({i,j});
	 			int s=0;
	 			s=s+c(i-1,j)+c(i,j-1)+c(i,j+1)+c(i+1,j);
	 			while(!q.empty())
	 			{
	 				node d=q.front();
	 				q.pop();
	 				v[d.x][d.y]=false;
	 				for(int i=0;i<4;i++)
	 				{
	 					int nx=d.x+dx[i],ny=d.y+dy[i];
	 					if(nx<0||nx>n||ny<0||ny>m||v[nx][ny]==false||b[nx][ny]==2)continue;
	 					q.push({nx,ny});
	 					s=s+c(nx-1,ny)+c(nx,ny-1)+c(nx,ny+1)+c(nx+1,ny);//算出黑棋的气的连通块的气
					}
				 }
				 if(s==0) u++;
			 }
		 }
	 }
	 if(u<=1)cout<<"NO\n";
	 else cout<<"YES\n";
	 for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=0,b[i][j]=0;
   }

  return 0;
}
```

---

## 作者：Legitimity (赞：3)

首先不难发现，如果白棋要赢，至少要将黑棋所有的气都堵住（废话），那么我们就要保证在黑棋的气的地方下满白棋时这些白棋是合法的。

根据题目白棋合法的定义，其实就不难发现合法即是：要么所有的白棋联通块都有气，要么只允许有一个白棋联通块没有气（在最后下这个联通块的棋子，当自己没气的时候，恰好也将黑棋的气全部堵上，根据规则白棋胜）。那么就暴力统计白棋联通周围有没有空的棋格。

时间复杂度 $\Theta(Tnm)$

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define ll long long
#define inf 0x3f3f3f3f
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
inline char getc(){
    char ret=getchar();
    while(ret!='*'&&ret!='.') ret=getchar();
    return ret;
}
int t,n,m,mp[3005][3005],cnt,tot,now;
char a[3005][3005];
int dx[]={0,0,-1,1};
int dy[]={1,-1,0,0};
bool vis[3005][3005];
inline void dfs(int x,int y){
	vis[x][y]=1;
	for(rg int i=0;i<4;++i){
		if(mp[x+dx[i]][y+dy[i]]==0&&x+dx[i]>0&&y+dy[i]>0&&x+dx[i]<=n&&y+dy[i]<=m) now=1;
		if(!vis[x+dx[i]][y+dy[i]]&&mp[x+dx[i]][y+dy[i]]==1&&x+dx[i]>0&&y+dy[i]>0&&x+dx[i]<=n&&y+dy[i]<=m)
			dfs(x+dx[i],y+dy[i]); 
	}
}//查找一个白棋块周围的空格。
signed main(){
	t=read();
	while(t--){
		n=read(); m=read();
		cnt=0; tot=0;
		for(rg int i=1;i<=n;++i){
			for(rg int j=1;j<=m;++j){
				a[i][j]=getc();
				vis[i][j]=mp[i][j]=0;
			}
		}
		for(rg int i=1;i<=n;++i){
			for(rg int j=1;j<=m;++j){
				if(a[i][j]=='*'){
					mp[i][j]=2;
					for(rg int k=0;k<4;++k)
						if(a[i+dx[k]][j+dy[k]]=='.') 
							mp[i+dx[k]][j+dy[k]]=1;
				}
			}
		} //把黑棋的气找出来。
		for(rg int i=1;i<=n;++i){
			for(rg int j=1;j<=m;++j){
				if(mp[i][j]==1&&!vis[i][j]){
					now=0;
					dfs(i,j);
					cnt+=now; ++tot;
				}
			}
		}//判断有气的白棋联通块数量。
		if(cnt>=tot-1) puts("NO");
		else puts("YES");
	}
	return 0;
}
```


---

## 作者：Maxmilite (赞：2)

本题解思路有别于与其他题解。

### 简化版题意分析

白/黑棋快是由白/黑棋组成的连通块。

给您一副围棋黑棋块盘面，要求填上白棋块让黑棋块周围一格的空位都被填掉。

必须要保证周围一格没有空位白棋块的数量小于等于 $1$。

(这种题意可能会对未接触过围棋的选手~~我~~比较友好)

### 解法

我们先来讲一下总的做法：**找到所有需要填白棋的位置，判断这个位置的白棋块是否满足需求，填上白棋，计数，判断，输出答案。**

既然最终目标是填掉黑棋块周围一格的空位，那么我们首先要找到这一些空位。

这里我调用了一个函数 `checkLiberty`

```cpp
// (liberty 是气的英文单词)
// 使用字符串二维数组 a 记录棋盘，dx、dy 数组即为遍历当前位置周围一格的路径
// int dx[] = {0, 0, 1, -1}, dy[] = {-1, 1, 0, 0};
// char a[2005][2005];
// 返回值 0 意为这里不是符合要求的空位，1 意为这里是符合要求的空位

inline int checkLiberty(int i, int j)
{
	if (a[i][j] == '*' || a[i][j] == 'p')
		return 0;
	for (int k(0), nx, ny; k <= 3; ++k)
	{
		nx = i + dx[k];
		ny = j + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m)
			if (a[nx][ny] == '*')
				return 1;
	}
	return 0;
}
```

这里有一句 `a[i][j] == 'p'`，我们暂且一放，这个 `p` 会在下面用到。

我们先来看一下这段函数的作用。

如果当前位置是黑棋子，那么就返回 $0$。如果不是黑棋子，说明这里是空位，我们需要在周围一格找一下有没有黑棋子，如果有，那这个位置就是符合要求的空位。

找到了我们需要的空位，那么我们就要开始往这些空位里填白棋子了。

这里我调用了一个函数 `check`。

```cpp
// vis 数组记录走过的格子
// 返回值 0 意为这里无法按照题目要求放上白棋，1 意为这里可以
// 要求：这一白棋块周围至少有一个空位。

int check(int i, int j)
{
	vis[i][j] = 1;
	for (int k(0), nx, ny; k <= 3; ++k)
	{
		nx = i + dx[k];
		ny = j + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && vis[nx][ny] == 0)
		{
			if (a[nx][ny] == '.')
				if (checkLiberty(nx, ny) == 0)
				{
					vis[i][j] = 0;
					return 1;
				}
				else if (check(nx, ny) == 1)
				{
					vis[i][j] = 0;
					return 1;
				}
		}
	}
	vis[i][j] = 0;
	return 0;
}
```

我们先来看一下这段函数的作用。

对于这个位置，我们使用类似 DFS 的技巧，往外扩展搜索能让白棋合法放置的情况。

也就是说让这个位置放上白棋，之后一直往外铺，直到找到合适的空位能够让这个白棋放置成为合法的。

我们注意到这一段代码

```cpp
if (a[nx][ny] == '.')
	if (checkLiberty(nx, ny) == 0)
	{
		vis[i][j] = 0;
		return 1;
	}
	else if (check(nx, ny) == 1)
	{
		vis[i][j] = 0;
		return 1;
	}
```

我们在搜索的时候搜到了空位，但是我们并不知道这个位置是不是黑棋块周围一格的空位（需要被填充的空位），所以我们需要判断。

调用 `checkLiberty` 函数，如果这里不是黑棋块周围一格的空位，那么我们在这个位置放上白棋就是符合的。

否则这里也要放上白棋，那么我们以这个新的白棋为起点，继续搜索。

这样搜索过后，我们就找到了白棋的情况。（周围没有合适的空位/周围有合适的空位）

我用一个 `cur` 变量来记录不符合要求的白棋块的数量，用于最终的结果判断。

找到情况之后，我调用了一个 `extendArea` 函数，用来把白棋填上。

```cpp
inline void extendArea(int i, int j)
{
	a[i][j] = 'p';
	for (int k(0), nx, ny; k <= 3; ++k)
	{
		nx = i + dx[k];
		ny = j + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && a[nx][ny] != 'p')
			if (checkLiberty(nx, ny) == 1)
				extendArea(nx, ny);
	}
	return;
}
```

因为这个位置所在的白棋块在 `check` 函数中已经被判定完了，所以我们就要把这个白棋所在的白棋块全部填上。

然后我们的 `p` 就出现了。

> 这里有一句 `a[i][j] == 'p'`，我们暂且一放，这个 `p` 会在下面用到。
>
> ——来自于 `checkLiberty` 函数讲解部分。

我们可以回到这一句了，如果这个位置是一个白棋，那么这个位置肯定不是空位，所以返回为 $0$。

在判断 `cur` 和 $1$ 的关系后，我们就可以输出答案了。

**找到所有需要填白棋的位置，判断这个位置的白棋块是否满足需求，填上白棋，计数，判断，输出答案。**

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, t;
char a[2005][2005];
int vis[2005][2005];
int dx[] = {0, 0, 1, -1}, dy[] = {-1, 1, 0, 0};

inline int checkLiberty(int i, int j)
{
	if (a[i][j] == '*' || a[i][j] == 'p')
		return 0;
	for (int k(0), nx, ny; k <= 3; ++k)
	{
		nx = i + dx[k];
		ny = j + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m)
			if (a[nx][ny] == '*')
				return 1;
	}
	return 0;
}

int check(int i, int j)
{
	vis[i][j] = 1;
	for (int k(0), nx, ny; k <= 3; ++k)
	{
		nx = i + dx[k];
		ny = j + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && vis[nx][ny] == 0)
		{
			if (a[nx][ny] == '.')
				if (checkLiberty(nx, ny) == 0)
				{
					vis[i][j] = 0;
					return 1;
				}
				else if (check(nx, ny) == 1)
				{
					vis[i][j] = 0;
					return 1;
				}
		}
	}
	vis[i][j] = 0;
	return 0;
}

inline void extendArea(int i, int j)
{
	a[i][j] = 'p';
	for (int k(0), nx, ny; k <= 3; ++k)
	{
		nx = i + dx[k];
		ny = j + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && a[nx][ny] != 'p')
			if (checkLiberty(nx, ny) == 1)
				extendArea(nx, ny);
	}
	return;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> t;
	while (t--)
	{
		cin >> n >> m;
		for (int i(1); i <= n; ++i)
			cin >> (a[i] + 1);
		int cur = 0;
		for (int i(1); i <= n; ++i)
			for (int j(1); j <= m; ++j)
				if (checkLiberty(i, j))
				{
					if (check(i, j) == 0)
						++cur;
					extendArea(i, j);
				}
					
		if (cur <= 1)
			cout << "NO" << endl;
		else
			cout << "YES" << endl;
	}
	return 0;
}
```

---

## 作者：KSToki (赞：2)

大家的代码咋这么长啊，这里提供一种比较优美的方法，感觉这题黄差不多了。

大致思路是先将必须填上白棋的位置覆盖上，其它位置不管，这样先保证最优。再判断摆的白棋是否合法，即 dfs 每一个联通块，看周围是否有气，即周围是否有没有棋的格子，如果没气的联通块大于一个则不合法。

很好理解吧，看看代码吧，代码~~去掉宏定义~~非常简洁。

代码：
```cpp
#include<bits/stdc++.h>
#define R register
#define I inline
#define ll long long
#define ull unsigned long long
#define LL __int128
#define db double
using namespace std;
#define pii pair<int,int>
#define mp(x,y) make_pair(x,y)
#define piii pair<pair<int,int>,int>
#define mp3(x,y,z) make_pair(make_pair(x,y),z)
#define fi first.first
#define se first.second
#define th second
#define putint(x) printf("%d\n",x)
#define putll(x) printf("%lld\n",x)
#define putull(x) printf("%llu\n",x)
#define lowbit(x) ((x)&(-(x)))
#define inf (0x7fffffff)
#define INF (1e18)
#define eps (1e-8)
I int read()
{
	char ch=getchar();
	int res=0,flag=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=res*10+ch-'0';
		ch=getchar();
	}
	return res*flag;
}
int T,n,m,u[4]={1,0,-1,0},v[4]={0,1,0,-1};
char a[2001][2001];
bool vis[2001][2001],add;
I bool check(int x,int y)
{
	return x>0&&y>0&&x<=n&&y<=m&&a[x][y]=='.';
}
I bool check2(int x,int y)
{
	return x>0&&y>0&&x<=n&&y<=m&&a[x][y]=='@'&&!vis[x][y];
}
void dfs(int x,int y)
{
	vis[x][y]=1;
	for(R int i=0;i<4;++i)
		if(check(x+u[i],y+v[i]))
			add=0;
	for(R int i=0;i<4;++i)
		if(check2(x+u[i],y+v[i]))
			dfs(x+u[i],y+v[i]);
}
int main()
{
	T=read();
	while(T--)
	{
		n=read();
		m=read();
		for(R int i=1;i<=n;++i)
			scanf("%s",a[i]+1);
		for(R int i=1;i<=n;++i)
			for(R int j=1;j<=m;++j)
			{
				vis[i][j]=0;
				if(a[i][j]=='*')
					for(R int k=0;k<4;++k)
						if(check(i+u[k],j+v[k]))
							a[i+u[k]][j+v[k]]='@';
			}	
		int cnt=0;
		for(R int i=1;i<=n;++i)
			for(R int j=1;j<=m;++j)
				if(a[i][j]=='@'&&!vis[i][j])
				{
					add=1;
					dfs(i,j);
					cnt+=add;
				}
		if(cnt>1)
			puts("YES");
		else
			puts("NO");
	}
	return 0;
}
```

---

## 作者：EdisonBa (赞：2)

#### 题意简述

题目大意是给出一些黑棋，需要我们往里面依次放白棋，问是否可以满足无论怎么依次放白棋的过程中黑棋都能存活。

#### 题目分析

看到样例解释，我们可以想到把“白棋恰好将黑棋全部吃掉”的局面画出来。

对于下面这个输入数据：
```
.*.*.
.***.
.....
```

我们将白棋用 `@` 表示：
```
@*@*@
@***@
.@@@.
```

观察上面的图像，可以发现此时棋盘中最上面一行的第三个棋子被黑棋包围，称它目前处于“不合法”状态。所以，在依次放置白棋的过程中，这个“不合法”的连通块一定是最后放置，从而将黑棋提掉。

稍微思考一下可以得出：对于每一个白棋的连通块，此时它“不合法”（四周都有黑棋或者边界）的连通块数量必须 $\leq$ 1。否则，想要到达恰好吃掉黑棋的情况，白棋放置的过程中不能满足同时有两个连通块“不合法”。

也就是说，我们只需要先把恰好能吃掉全部黑棋时的白棋填上，再判断白棋“不合法”的连通块数量是不是大于 1 即可。

#### 代码

此代码的棋盘中 `.` 用 `0` 表示， `*` 用 `1` 表示， `@` 用 `2` 表示。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
inline ll read(){}

ll T,n,m;
int a[2004][2004]; //棋盘
int ok=0; //统计白棋“不合法”连通块的数量
int dx[4]= {0,0,1,-1},dy[4]= {1,-1,0,0}; 
bool ff=0; //搜索时的标记

inline void C() //清空
{
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            a[i][j]=0;
    ok=0;
}

inline void dfs(int x,int y)
{
    if(a[x][y]==1) return;
    if(a[x][y]==0) //如果白棋“存活”，标记设为1
    {
        ff=1;
        return;
    }
    a[x][y]=1;
    for(int i=0; i<4; ++i) 
    {
        int ny=dy[i]+y;
        int nx=dx[i]+x;
        if(ny<=0 || nx<=0 || ny>m || nx>n) continue;
        dfs(nx,ny);
    }
}

int main()
{
    T=read();
    while(T--)
    {
        n=read();
        m=read();
        C(); //初始化
        
        for(int i=1;i<=n;++i)
            for(int j=1;j<=m;++j) //处理棋盘
            {
                char ch;
                cin>>ch;
                if(ch=='.') 
                    a[i][j]=0;
                if(ch=='*')
                    a[i][j]=1;
            }

        for(int i=1;i<=n;++i)
            for(int j=1;j<=m;++j) //把恰好能吃掉全部黑棋时的白棋填上
            {
                if(a[i][j]==1)
                {
                    if(a[i-1][j]!=1) a[i-1][j]=2;
                    if(a[i+1][j]!=1) a[i+1][j]=2;
                    if(a[i][j-1]!=1) a[i][j-1]=2;
                    if(a[i][j+1]!=1) a[i][j+1]=2;
                }
            }

        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=m;++j)
            {
                ff=0; //先标记为“不合法”
                if(a[i][j]==2)
                {
                    dfs(i,j);
                    if(ff==0) 
                        ok++; //累加不合法的次数
                }   
                if(ok>=2) //不合法次数 >=2 了，代表黑棋能活
                {
                    puts("YES");
                    break;    
                }
            }
            if(ok>=2) break; //符合条件时及时跳出
        }
        if(ok<2) puts("NO"); //黑棋不能活
    }
    return 0;
}

```


---

## 作者：ChampionCyan (赞：1)

显而易见的是，白棋必然走黑棋“气”的位置，因为其他位置没有用。

如果白棋占了黑棋所有的“气”且“犯规”的连通块不超过两个，白棋必胜，否则黑棋必胜。

所以只需写黑棋有几个连通块的“气”不合法即可，小于等于 $1$ 白胜，否则黑胜，用 BFS 或 DFS 都可以解决连通块问题，不懂的左转[这题](https://www.luogu.com.cn/problem/P1451)。

---

## 作者：lqsy002 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P7479)。

## 解题思路

不是活棋的条件是黑棋最多有一个联通块，其不存在至少一个点满足其四面都没有黑棋。

所以判断一下并进行染色，最后看有多少个连通块没有被染色即可。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 2005
using namespace std;
int t,n,m,cnt;
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
char mp[maxn][maxn];
bool vis[maxn][maxn],flag[maxn][maxn];
bool check(int x,int y){
	for(int i=0;i<4;++i) 
		if(flag[x+dx[i]][y+dy[i]]) 
			return false;
	return true; 
}
void dfs(int x,int y){
	vis[x][y]=true;
	for(int i=0,nx,ny;i<4;++i){
		nx=x+dx[i];
		ny=y+dy[i];
		if(nx>=1&&ny>=1&&nx<=n&&ny<=m&&!vis[nx][ny])
			dfs(nx,ny);
	}
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>m;
		cnt=0;
		for(int i=1;i<=n;++i) 
			cin>>(mp[i]+1);
		for(int i=0;i<=n+1;++i)
			for(int j=0;j<=m+1;++j)
				if(mp[i][j]=='*')
					flag[i][j]=vis[i][j]=true;
				else
					flag[i][j]=vis[i][j]=false;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(mp[i][j]!='*'&&!vis[i][j]&&check(i,j)) 
					dfs(i,j); 
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(!vis[i][j]){
					++cnt;
					dfs(i,j);
				}
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				mp[i][j]=' ';
		if(cnt<=1) 
			cout<<"NO\n";
		else 
			cout<<"YES\n";
	}
	return 0;
}
```

---

## 作者：_Weslie_ (赞：0)

## Solution P7479

### Idea

作为学过围棋的 OIer，我的第一反应是找眼。众所周知在围棋中双眼就是活棋。然后如果只有一个眼就要判断，具体你们上网搜。但是你会发现这个题不一样。

因为：这个题中**白棋可以连续走**！

所以我们不能找眼。众所周知白棋只要把黑棋的气全堵住就可以让黑棋死了。我们需要把黑棋的气找出来，我们记为蓝棋。

然后需要判断由蓝棋组成的四连通块是否合法。所谓合法，就是指这一块蓝棋有气。例如：（下列 `@` 代表蓝棋）

```
***
*@*
***
```

是不合法的，

```
*****
*@@@*
*@.@*
*@@@*
*****
```

是合法的，因为 `@` 连通块有气。

所以可以用 bfs 判断一块蓝棋连通块是否合法。

### Code

下面代码中 `+` 代表蓝棋。

```
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
char ch[N][N];
int n,m;
bool vis[N][N];
const int dx[5]={0,1,-1,0,0};
const int dy[5]={0,0,0,-1,1};
bool in(int x,int y){
    if(x<0||x>n||y<0||y>m)return false;
    return true;
}
bool dfs(int x,int y){
    vis[x][y]=1;
    bool f=0;
    for(int i=1;i<=4;i++){
        int nx=x+dx[i],ny=y+dy[i];
        if(ch[nx][ny]=='.')f=1;
        if(in(nx,ny)&&ch[nx][ny]=='+'&&!vis[nx][ny])f|=dfs(nx,ny);
    }
    return f;
}
void solve(){
    cin>>n>>m;
    for(int i=0;i<=n+1;i++){
        for(int j=0;j<=m+1;j++){
            ch[i][j]='}';
            vis[i][j]=0;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>ch[i][j];
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(ch[i][j]!='*')continue;
            for(int k=1;k<=4;k++){
                int nx=i+dx[k],ny=j+dy[k];
                if(ch[nx][ny]=='.')ch[nx][ny]='+';
            }
        }
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(cnt>=2){
                i=n+1;
                j=m+1;
                continue;
            }
            if(ch[i][j]=='+'){
                if(!vis[i][j]&&!dfs(i,j))cnt++;
            }
        }
    }
    if(cnt<2)cout<<"NO\n";
    else cout<<"YES\n";
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int T;
    cin>>T;
    while(T--)solve();
}
```

---

## 作者：Eterna (赞：0)

围棋业余 $3$ 级。

看一眼题，好像是判断黑棋是否为活棋。

但好像不太一样？

又看了好久，发现实际上是在判断黑棋不能走棋的情况下是否为活棋。

一般的围棋中，一块棋（就是一个连通块）有至少两个眼（其实就是两个特别的洞），则称它是活棋。

在这里其实也一样，只不过对眼的限制更严格。

只要对于白棋来说是非法点的地方就是眼。

跑一遍联通块，然后判断黑棋的气是否能被合法的白旗堵住应该就行了。

###  ac代码
```cpp
#include<bits/stdc++.h>
#define rd read()
#define N 3005
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
  	while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
int T,n,m,mp[N][N],cnt,tot,ow,dx[4]={0,0,-1,1},dy[4]={1,-1,0,0};
char a[N][N];
bool vis[3005][3005];
void dfs(int x,int y)
{
	vis[x][y]=1;
	for(int i=0;i<4;i++)
	{
		if(mp[x+dx[i]][y+dy[i]]==0&&x+dx[i]>0&&y+dy[i]>0&&x+dx[i]<=n&&y+dy[i]<=m)ow=1;
		if(!vis[x+dx[i]][y+dy[i]]&&mp[x+dx[i]][y+dy[i]]==1&&x+dx[i]>0&&y+dy[i]>0&&x+dx[i]<=n&&y+dy[i]<=m)dfs(x+dx[i],y+dy[i]); 
	}
}//搜索白棋的气 
signed main()
{
	T=rd;
	while(T--)
	{
		n=rd,m=rd,cnt=0,tot=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
			{
				cin>>a[i][j];
				vis[i][j]=mp[i][j]=0;
			}//输入 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(a[i][j]=='*')
				{
					mp[i][j]=2;
					for(int k=0;k<4;k++)if(a[i+dx[k]][j+dy[k]]=='.') 
						mp[i+dx[k]][j+dy[k]]=1;
				}//找黑棋的气
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(mp[i][j]==1&&!vis[i][j])
				{
					ow=0;
					dfs(i,j);
					cnt+=ow,tot++;
				}//判断有气的白棋联通块数量。
		if(cnt+1>=tot)cout<<"NO\n";
		else cout<<"YES\n";
	}
	return 0;
}
```

嗯，过了。

~~但是黑棋为啥不能动。~~

---

## 作者：Jsxts_ (赞：0)

# 题解 P7479 【B】至曾是英雄的您
[传送门](https://www.luogu.com.cn/problem/P7479)

## 题解

我们可以看出，一块黑棋如果有两个或以上连着黑棋的非棋子的连通块，那么白棋就有可能在填其中一个气时因为自己没有气而不能继续下，黑棋就成为了活棋。

那要什么样的气才能让白棋填不完呢？我们想到如果白棋在里面能围成一块地（即不是这一块中每一个空地都靠着黑棋），就可以填完在这个连通块里每一个黑棋的气都堵掉，这就不符合条件，否则符合条件。

然后如果有两个或以上的连通块符合上面条件，白棋就不能同时堵上这几个连通块，就是活棋。

而连通块可以用 DFS 求，而每一块空地有没有靠着黑棋也可以在里面判断。具体细节可以见代码。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,t,pd;
char a[2010][2010];
int dx[] = {0,0,-1,1};
int dy[] = {-1,1,0,0};
void dfs(int x,int y) {//基础的DFS 
	if (!pd) {//判断是否靠着黑棋 
		int f = 0;
		for (int i = 0;i < 4;i ++ ) {
			int nx = x + dx[i],ny = y + dy[i];
			if (nx < 1 || ny < 1 || nx > n || ny > m) continue;
			if (a[nx][ny] == '*') f = 1;//靠着黑棋 
		}
		if (!f) pd = 1;
	}
	for (int i = 0;i < 4;i ++ ) {
		int nx = x + dx[i],ny = y + dy[i];
		if (nx < 1 || ny < 1 || nx > n || ny > m) continue;
		if (a[nx][ny] == '*' || a[nx][ny] == '#') continue;
		a[nx][ny] = '#';//在里面去重，#也可视为白棋 
		dfs(nx,ny);
	}
}
int main() {
	int t,cnt;
	scanf("%d",&t);//多组数据 
	while (t -- ) {
		scanf("%d%d",&n,&m);
		cnt = 0;
		for (int i = 1;i <= n;i ++ ) {
			scanf("%s",a[i]+1);//字符串输入 
		}
		for (int i = 1;i <= n;i ++ ) {
			for (int j = 1;j <= m;j ++ ) {
				if (a[i][j] == '.') {//是一个连通块中的一块空地 
					pd = 0;//初始化
					dfs(i,j);
					if (!pd) cnt ++;
					if (cnt == 2) {
						puts("YES");//有两个就满足条件 
						goto bre;
					}
				}
			}
		}
		puts("NO");//不满足条件 
		bre:;
	}
	return 0;
}
```
Time：509ms

---

## 作者：TZMydl (赞：0)

题目给出的棋盘被分成两部分：一个黑棋连通块和若干个空白连通块。

若黑棋连通块的“气”覆盖了超过一个空白连通块，那么无论如何都不能使黑棋连通块的“气”变为 $ 0 $ ，因为它的必要条件是用白棋填满任意一个属于黑棋连通块的“气”的空白连通块，而这是不合法的，因此不能满足。

若黑棋连通块的“气”覆盖了不超过一个空白连通块，则可以先将它的“气”未覆盖的空白连通块中的“气”全部吃掉，方法是以空白连通块中不是黑棋连通块的“气”的格子为白棋的“气”，不断蚕食黑棋连通块的“气”，这样一定是可以做到的。最后，若有一个属于黑棋连通块的“气”的空白连通块，则直接填满即可。

知道了判断的条件，代码写起来就比较容易了：直接广搜出空白连通块，判断它是否属于黑棋连通块的“气”，然后统计、判断即可。

code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=2005;
int T,n,m,cnt=0,dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
bool a[N][N],b[N][N],vis[N][N];
bool bfs(int i,int j){
	int qx[n*m+5],qy[n*m+5],h1=1,t1=1,h2=1,t2=1;
	bool f=1;
	vis[i][j]=1;
	if(!b[i][j])f=0;
	qx[1]=i;qy[1]=j;
	while(h1<=t1&&h2<=t2){
		int x=qx[h1++],y=qy[h2++];
		for(int i=0;i<4;++i){
			int ux=x+dx[i],uy=y+dy[i];
			if(ux<1||uy<1||ux>n||uy>m)continue;
			if(a[ux][uy]&&!vis[ux][uy]){
				qx[++t1]=ux;qy[++t2]=uy;
				vis[ux][uy]=1;
				if(!b[ux][uy])
					f=0;
			}
		}
	}
	return f;
}
int main(){
	scanf("%d",&T);
	while(T--){
		cnt=0;
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				vis[i][j]=a[i][j]=b[i][j]=0;
		for(int i=1;i<=n;++i){
			char s[N];
			scanf("%s",s+1);
			for(int j=1;j<=m;++j)
				if(s[j]=='.')a[i][j]=1;
		}
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(!a[i][j])
					b[i-1][j]=b[i][j-1]=b[i+1][j]=b[i][j+1]=1;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(a[i][j]&&!vis[i][j])
					cnt+=bfs(i,j);
		if(cnt>1)
			puts("YES");
		else puts("NO");
	}
	return 0;
}
```


---

## 作者：_caiji_ (赞：0)

首先标记出黑棋的「气」，不如就标记成 `F`。把所有 `F` 的联通块分成两类：一类是周围全是黑棋或墙的，简称 $a$ 类；另一类是周围不全是黑棋或墙的，简称 $b$ 类。举个例子：
```cpp
F*F*F F***F
F***F F***F
FF*FF .FFF.
```
左边这三个联通块都是 $a$ 类，它们中间被黑棋或墙隔开，没有任何 `.`；右边这三个联通块都是 $b$ 类，它们中间有两个 `.`。

我们发现，$a$ 类联通块必须最后下满。为什么？题目要求白棋下完这步棋之后**这个棋子所在连通块的「气」大于等于 $\bold{1}$ 或者黑棋连通块的「气」等于 $\bold{0}$**。换句话说，白棋如果在下完这步棋之后所在联通块的「气」$=0$，则黑棋联通块的「气」必须要 $=0$，也就是下完了。什么时候白棋的联通块的「气」会在下完之后 $=0$ 呢？是 $a$ 类联通块刚好下满的时候。下满之后，由于周围全是黑棋或墙，没有空格，也就没有「气」。

我们还发现，最多只能有一个 $a$ 类联通块。如果有 $2$ 个或以上，前一个下满的 $a$ 类联通块就不符合「$a$ 类联通块必须最后下满」这个条件。

至于 $b$ 类联通块，随便下啦，反正周围有空格，「气」一定不会 $= 0$。

于是，问题就变成了：统计所有 $a$ 类联通块个数，如果个数 $\leq 1$，说明能下满这些联通块，输出 `NO`，否则输出 `YES`。

代码实现很简单，首先 $O(nm)$ 暴力标记一下黑棋的「气」。然后写一个 bfs，它干两件事：下满联通块，判断是 $a$ 类还是 $b$ 类。 然后 $O(nm)$ 枚举每一个点跑 bfs，顺便统计 $a$ 类联通块个数。最后输出，注意一下大小写。

```cpp
#include <queue>
#include <cstdio>
using namespace std;
#define def for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)//不想打那么多for（
const int dx[]={0,-1,0,0,1},
          dy[]={0,0,-1,1,0};
int n,m;
char a[2010][2010];
struct point{//定义一个点的结构体，更方便
    int x,y;
    char& getval(){return a[x][y];}
    //加引用可以a.getval()='F'这样直接赋值
    bool check(){return 1<=x&&x<=n&&1<=y&&y<=m;}
};
queue<point> q;
int bfs(int sx,int sy){
    if(a[sx][sy]!='F') return 0;
    while(!q.empty()) q.pop();//清空队列
    int flg=1;//记录a还是b
    q.push((point){sx,sy});
    a[sx][sy]='@';
    while(!q.empty()){
        point tmp=q.front();q.pop();
        for(int i=1;i<=4;i++){
            point nxt=(point){tmp.x+dx[i],tmp.y+dy[i]};
            if(nxt.check()){
                if(nxt.getval()=='.') flg=0;//有空格，说明是b类
                if(nxt.getval()=='F') nxt.getval()='@',q.push(nxt);
            }
        }
    }
    return flg;//如果没标记成0，说明是a类，统计到个数里
}   
int mian(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
    def{//标记黑棋的「气」
        if(a[i][j]=='*'){
            for(int k=1;k<=4;k++){
                point tmp=(point){i+dx[k],j+dy[k]};
                if(tmp.check()&&tmp.getval()=='.') tmp.getval()='F';
            }
        }
    }
    int ans=0;
    def{//统计a类联通块的个数
        ans+=bfs(i,j);
    }
    puts(ans<=1?"NO":"YES");//输出
    return 0;
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--) mian();
    return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：0)

## 题目简述

给一个只含有黑棋块的部分棋盘，判断黑棋是否是活棋。

## 题目分析

玩过围棋的都知道只要一个联通的棋子有至少 2 口真气就是活棋。

那怎么判断是不是真气呢？

其实只要判断此空气块是否出现四面都是空气的情况，出现了就是假气，如果一个空气块里面都没有这样的空气就是 **一口** 真气。

如果出现了假气，其实跟用黑棋把此空气块填满没有区别，出现了就用 dfs 填黑棋。

## _Code_

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring> 
using namespace std;
#define ll long long
const int MAXN=2e3+3;
int t;
int n,m;
char a[MAXN][MAXN];
int dx[4]={-1,0,0,1};
int dy[4]={0,-1,1,0};
bool jq(int x,int y){//是否是真气
	bool is=1;
	if(a[x][y]=='*')
		 return false;//出口
	for(int i=0;i<=3;i++)
		is=(is&&a[x+dx[i]][y+dy[i]]!='*');//如果旁边都是空气，是假气
	return is;
}
void dfs(int x,int y){
	if(a[x][y]!='.')
		return;
	a[x][y]='*';
	for(int i=0;i<=3;i++)
		dfs(x+dx[i],y+dy[i]);
	return;
}
int main(){
	cin>>t;
	while(t--){
		int cnt=0;//记录气
		cin>>n>>m;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				cin>>a[i][j];
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(jq(i,j))//是否是真气
					dfs(i,j);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(a[i][j]=='.')
					cnt++,dfs(i,j);
		if(cnt>=2)
			cout<<"YES"<<endl;
		else
			cout<<"NO"<<endl;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				a[i][j]=' ';//清空啊，不然死的很惨
	}
}
```


---


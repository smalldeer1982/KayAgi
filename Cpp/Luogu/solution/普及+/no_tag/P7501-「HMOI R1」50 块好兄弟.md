# 「HMOI R1」50 块好兄弟

## 题目背景

Polaris_Dane 非常菜，他不仅沉迷于计数，而且喜欢玩星际争霸 2。

## 题目描述

「我的好兄弟无穷无尽，而你的虫子每时每刻都在消亡」

作为新上任爱民如子的指挥官，Polaris_Dane 充分领悟了雷诺指挥官的智慧，决定将此战术贯彻到底。

有 $N$ 个兵营，依次编号为 $1,2,3\cdots N$。现在需要把它们排列在一条数轴中位于 $[1,M]$ 间的整点处。每一个兵营都有一个生产范围 $r_i$，若兵营放在点 $x\ (1 \le x \le M)$ 处，那么它会在区间 $[x - r_i + 1, x + r_i - 1]$ 生产好兄弟。

当 $\rm type = 0$ 时，生产好兄弟的范围必须被区间 $[1,M]$ 完全包含；当 $\rm type = 1$ 时，生产好兄弟的范围可以落在 $[1,M]$ 之外，但是兵营必须放在 $[1,M]$ 内。

Polaris_Dane 不能让好兄弟们太挤了，所以任何两个兵营的生产范围 **都不能相交**，他想知道有多少种方案满足该条件。

若两个方案中存在一个编号为 $i$ 的兵营，其在两个方案中的放置位置不同，则称这两个方案不同。

由于答案可能很大，所以 Polaris_Dane 想请你输出答案对 $998244353$ 取模后的结果。

## 说明/提示

样例解释：

在样例 1 中，无论如何摆放兵营，生产范围都不会交叉，所以答案即为 $A_4^4 = 24$。

在样例 2 中，虽然生产范围可以出界，但是兵营的可选位置还是只有 $4$ 种，答案仍是 $A_4^4 = 24$。

--------

对于所有数据：
- $1 \le N, M \le 10^6$；
- $1 \le r_i \le 1000$。

-----------

**本题采用捆绑测试。**

| No. | Constraints                           | $\rm type$ | Score |
| ----------- | ------------------------------------- | ---------- | ----- |
| $1$         | $N = 2;\ M \le 1000;\ r_i = 1$          | $0$        | $10$  |
| $2$         | $N = 2;\ M \le 10^6;\ r_i = 1$          | $0$        | $10$  |
| $3$         | $N \le 40;\ M \le 10^6;\ r_i = 1$ | $0$        | $10$  |
| $4$         | No further constraints                | $0$        | $30$  |
| $5$         | $N, r_i \le 40$                 | $1$        | $20$  |
| $6$         | No further constraints                | $1$        | $20$  |

------

- Idea: Polaris_Dane
- Solution: Polaris_Dane
- Code: Polaris_Dane
- Data: Polaris_Dane

## 样例 #1

### 输入

```
4 4 0
1 1 1 1```

### 输出

```
24```

## 样例 #2

### 输入

```
4 4 1
1 1 1 1```

### 输出

```
24```

## 样例 #3

### 输入

```
3 47 1
4 8 9```

### 输出

```
10940```

## 样例 #4

### 输入

```
8 100000 1
21 37 23 13 32 22 9 39```

### 输出

```
405170260```

# 题解

## 作者：dead_X (赞：1)

## 思路
下文记 $R_i=2r_i-1$。

* $\text{type}=0$

显然如果答案存在，我们放完所有兵营后必定还剩下 $m-\sum R_i$ 个空位置。

因此，我们只需要在 $m-\sum R_i+n$ 个位置中，有序地选出 $n$ 个，依次将这些位置钦定为第 $i$ 个兵营，剩余位置定为空地，即可算出所有方法数。

* $\text{type}=1$

考虑钦定两侧兵营的 $r_i$。

若最左侧为第 $p$ 个兵营，最右侧为第 $q$ 个兵营，将 $m$ 向左延长 $R_p-r_p$ 格子，向右延长 $R_q-r_q$ 个格子，同时让所有兵营的摆放条件仍然按照 $\text{type}=0$ 时的条件计数，方法仍然可以形成一一对应，只需要将延长出来的格子去掉即可。

因此，我们可以做到 $O(n^2+m)$，但是过不去。

注意到 $r_i$ 的值域只有 $10^3$，我们可以转而枚举 $r_i$，这样的复杂度为 $O(r_i^2+m)$，即可通过。
## 代码
```cpp
//愿神 zhoukangyang 指引我。
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int a[1000003],b[1000003];
const int p=998244353;
int n=read(),m=read(),op=read();
int qp(int x,int y)
{
	int res=1;
	for(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;
	return res;
}
int fac[1000003],ifac[1000003];
int A(int n,int m)
{
	if(n<m) return 0;
	return fac[n]*ifac[n-m]%p;
}
int C(int n,int m)
{
	if(n<m) return 0;
	return fac[n]*ifac[n-m]%p*ifac[m]%p;
}
void solve0()
{
	int s=0;
	for(int i=1; i<=n; ++i) s+=a[i];
	if(s>m)
	{
		puts("0");
		return ;
	}
	int A=(m-s)+n,ans=1;
	for(int i=A; i>A-n; --i) ans=ans*i%p;
	printf("%lld\n",ans);
	return ;
}
int G[2003],S[1003];
void solve1()
{
	if(n==1)
	{
		printf("%lld\n",m);
		return ;
	}
	int s=0;
	fac[0]=ifac[0]=1;
	for(int i=1; i<=m; ++i) fac[i]=fac[i-1]*i%p,ifac[i]=qp(fac[i],p-2);
	for(int i=1; i<=n; ++i) s+=a[i];
	int ans=0;
	for(int i=1; i<=n; ++i) 
	{
		for(int j=0; j<=1000; ++j) G[b[i]+j]=(G[b[i]+j]+S[j])%p;
		++S[b[i]];
	}
	for(int i=0; i<=2000; ++i) if(G[i]) ans=(ans+G[i]*A(m+i-s+n,n)%p)%p;
	printf("%lld\n",ans*qp(C(n,n-2),p-2)%p);
	return ;
}
signed main()
{
	for(int i=1; i<=n; i++) b[i]=read(),a[i]=(b[i]<<1)-1,--b[i];
    if(op) solve1();
    else solve0();
    return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：0)

没意思。

先考虑 $type=0$：

那个 $r_i$ 的限制比较特殊，比较依赖位置，我们考虑将其转化为一个比较普适的形式：考虑先把点选出来然后再填空位进去（类似插板法“补一个”的思想）：在 $m-2\sum  r_i$ 个点中选出 $n$ 个放置兵营，这是 $\binom {m- 2 \sum r_i} n$ 的，由于兵营不同，还要 $\times n!$。

再考虑 $type=1$：我们枚举左边和右边长出去的长度是多少，在 $m$ 上加上额外的长度即可转化为前面的情况。注意，还要乘上达成额外长度的方案数。

细节看代码。

```cpp
const int N=1e7+3,M=2e3+3,p=998244353;
int n,m,s,Pow[N],Inv[N],a[N],b[N],f[M],g[M];
il int qpow(int a,int b)
{
	int c=1;
	for(;b;b&1&&((c*=a)%=p),(a*=a)%=p,b>>=1);
	return c;
}
il int A(int n,int k){return n<k?0:Pow[n]*Inv[n-k]%p;}
il int C(int n,int k){return n<k?0:Pow[n]*Inv[n-k]%p*Inv[k]%p;}
int Solve_1(int m){return s>m?0:A(n+m-s,n);}
int Solve_2()
{
	if(n==1) return m;
	for(int i=1;i<=n;++i) ++g[a[i]];
	for(int i=0;i<=1e3;++i) for(int j=0;j<=1e3;++j)	(f[i+j]+=i^j?g[i]*g[j]%p:g[i]*(g[j]-1)%p)%=p;
	int ans=0;
	for(int i=0;i<=2e3;++i) if(f[i]) (ans+=f[i]*Solve_1(m+i)%p)%=p;
	return ans*qpow(2*C(n,2)%p,p-2)%p;
}
void Solve()
{
	int o;
	rd(n,m,o),*Pow=1;
	for(int i=1;i<=n;++i) rd(a[i]),--a[i],b[i]=a[i]<<1|1,(s+=b[i])%=p;
	for(int i=1;i<N;++i) Pow[i]=Pow[i-1]*i%p;
	Inv[N-1]=qpow(Pow[N-1],p-2);
	for(int i=N-1;i;--i) Inv[i-1]=Inv[i]*i%p;
	wrt(o?Solve_2():Solve_1(m));
	return;
}
```

[$\color{green}\checkmark$](https://www.luogu.com.cn/record/113770016)。

---

## 作者：Pratty (赞：0)

题目给定：$1≤N,M≤1000000$

显然开```int```就足够了。

$∑r[i]$ 都会求，不会求得看[这里](https://blog.csdn.net/m0_37443131/article/details/81369938?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163255542516780269844911%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163255542516780269844911&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-81369938.first_rank_v2_pc_rank_v29&utm_term=%E2%88%91&spm=1018.2226.3001.4187)。

用 $m-∑r[i]$ 得到空的位置数量。

$type$ 可以用于 $bool$ 型变量。

任何两个兵营的生产范围**都不能相交**，不知道什么是相交的看[这里](https://blog.csdn.net/qq_40482358/article/details/86537747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163255556716780265478026%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163255556716780265478026&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-86537747.first_rank_v2_pc_rank_v29&utm_term=%E7%9B%B8%E4%BA%A4&spm=1018.2226.3001.4187)。

注意对答案输出 $\%998244353$ 的结果。

放兵营的地方在 $[1,M]$ 之间。

---


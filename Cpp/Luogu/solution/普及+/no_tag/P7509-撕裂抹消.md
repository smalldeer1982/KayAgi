# 撕裂抹消

## 题目背景

何以撕裂，何以抹消？

## 题目描述

给定一个长为 $n$ 的整数序列 $a_1,a_2,\dots,a_n$，再给定一个有理数序列 $p_1,p_2,\dots,p_n$。每个位置上有一个随机系数 $c_i \in \{0,1\}$，其中 $P(c_i =  1) = p_i$，$P(c_i = 0) = 1-p_i$。

注意到随机系数写作序列后可以划分为若干个极长的连续 $0$、$1$ 段，极长指不能再向两边扩展。定义一种系数序列的权值为：当系数序列中恰有 $k$ 个极长连续 $1$ 段时为 $\sum\limits_{i=1}^n c_i a_i$，否则为 $0$。

求这个系数序列的期望权值。答案对 $998244353$ 取模。

## 说明/提示

**样例解释**

对于第一组样例，$c_i$ 必然为 $1$，且必然恰有 $1$ 个极长连续段，故权值必然为 $1 + 2 + 3 + 4 + 5 = 15$。

对于第二组样例，仅有 $c_1 = 1,c_2 = 0,c_3 = 1$ 时权值不为 $0$，且此种情况的概率为 $\frac 12 \times \frac 12 \times \frac 12 = \frac 18$，故期望为 $\frac{1+3}8 = \frac 12 \equiv 499122177 \pmod {998244353}$。

**数据范围**

对于 $30\%$ 的数据，$n \le 20$。

对于 $60\%$ 的数据，$n \le 10^3$。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le k \le \min\left(20,\left\lfloor\frac{n+1}2\right\rfloor\right)$，$0 \le a_i,p_i < 998244353$。

## 样例 #1

### 输入

```
5 1
1 2 3 4 5
1 1 1 1 1```

### 输出

```
15```

## 样例 #2

### 输入

```
3 2
1 2 3
499122177 499122177 499122177```

### 输出

```
499122177```

# 题解

## 作者：cmll02 (赞：3)

提供一个 $O(nk\log p)$ 的做法。

显然 dp，用三维分别表示当前位置，当前连续段数，当前是否为 $1$。开一个数组表示期望乘上概率，再开一个表示概率。

代码中分别叫 `dp` 和 `qwq`。

对于一个状态，我们发现它最多由两个先前状态推出来。

我们算出这个状态的概率以及由每个状态转移过来的概率。

这样就可以算了。

具体的 dp 式子见代码。

代码在下面。由于中间的 `Mod` 写的很丑，就扔 [这里](https://www.luogu.com.cn/paste/59mpe2yn).

```cpp
#include <stdio.h>
inline int read()
{
	int num=0;char c=getchar();
	while(c<48||c>57)c=getchar();
	while(c>47&&c<58)num=(num<<3)+(num<<1)+(c^48),c=getchar();
	return num;
}
#define int long long
const int mod = 998244353;
int qp(int x,int p)
{
	int res=1;
	while(p)
	{
		if(p&1)res=res*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return res;
}
struct Mod{...};
Mod a[100005],p[100005],dp[100005][20][2],qwq[100005][20][2];
signed main()
{
	int n=read(),m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=n;i++)p[i]=read();
    //memset(dp,-0x3f,sizeof(dp));
    qwq[0][0][0]=1;
    Mod unit=1;
    for(int i=1;i<=n;i++)
    {
        for(int k=0;k<=m;k++)
        {
            if(k==0)
            {
                qwq[i][k][0]=qwq[i-1][k][0]*(mod+1-p[i].x);
                goto hidsa;
            }
            if(k+k-1>i)continue;
            else if(k+k-1==i)
            {
                qwq[i][k][1]=qwq[i-1][k-1][0]*p[i];
                //dp[i][k][1]=qwq[i][k][1]*a[i]+dp[i-1][k-1][0];
                dp[i][k][1]=a[i]+dp[i-1][k-1][0];
            }
            else
            {
                qwq[i][k][1]=qwq[i-1][k-1][0]*p[i]+qwq[i-1][k][1]*p[i];
                Mod wqw=qwq[i-1][k-1][0]+qwq[i-1][k][1];
                wqw=unit/wqw;
                dp[i][k][1]=a[i];//dp[i-1][k-1][0]*qwq[i-1][k-1][0]
                dp[i][k][1]+=dp[i-1][k-1][0]*qwq[i-1][k-1][0]*wqw;
                dp[i][k][1]+=dp[i-1][k][1]*qwq[i-1][k][1]*wqw;
                //dp[i][k][1]=qwq[i][k][1]*a[i]+dp[i-1][k-1][0]+dp[i-1][k][1];
                qwq[i][k][0]=(qwq[i-1][k][0]+qwq[i-1][k][1])*(mod+1-p[i].x);
                //dp[i][k][0]=qwq[i][k][0]*(dp[i-1][k][0]+dp[i-1][k][1]);
                wqw=qwq[i-1][k][0]+qwq[i-1][k][1];
                wqw=unit/wqw;
                dp[i][k][0]=dp[i-1][k][0]*qwq[i-1][k][0]*wqw;
                dp[i][k][0]+=dp[i-1][k][1]*qwq[i-1][k][1]*wqw;
            }
            
        /*    if(k*2-1>i)continue;
            if(k*2-1!=i){
            dp[i][k][0]+=dp[i-1][k][1]*(mod-p[i].x+1);
            dp[i][k][0]+=dp[i-1][k][0]*(mod-p[i].x+1);}
            //dp[i][k][1]=p[i]*a[i];
            dp[i][k][1]+=(a[i]+dp[i-1][k-1][0]+dp[i-1][k][1])*p[i];*/
            hidsa:;/*
            printf("dp[ %lld %lld %lld] = %lld\n",i,k,0ll,dp[i][k][0].x);
            printf("dp[ %lld %lld %lld] = %lld\n",i,k,1ll,dp[i][k][1].x);
            printf("qwq[ %lld %lld %lld] = %lld\n",i,k,0ll,qwq[i][k][0].x);
            printf("qwq[ %lld %lld %lld] = %lld\n",i,k,1ll,qwq[i][k][1].x);*/
        }
    }
    //printf("%lld\n",((dp[n][m][0]+dp[n][m][1])/qp(2,n)*(qp(2,n)-1)).x);
    printf("%lld\n",(dp[n][m][0]*qwq[n][m][0]+dp[n][m][1]*qwq[n][m][1]).x);
}
/*
2 1
3 5
0 1
*/
```

---

## 作者：xinxin2022 (赞：1)

现有题解的代码怎么都这么诡异...来一发简单的。

比较显然的期望DP，由题目容易设 $f_{i,j,0/1}$ 为考虑到 $i$ 极长连续段数为 $j$（若目前填 $1$ ，则目前段也算在内），目前填 $0/1$ 的期望。发现还需要知道概率，那么再设 $d_{i,j,0/1}$，意义与上面大致相同，不过表示的是概率。

分类讨论一下：

- 若当前位填 $0$
  
  - 显然不会增加连续段数，那么有：
  - $f_{i,j,0}=(1-p_i)\sum f_{i-1,j}$
  - $d_{i,j,0}=(1-p_i)\sum d_{i-1,j}$
 
- 若当前位填 $1$

  - 若延续当前极长连续段
    
    - 上一位必然填 $1$，又因为权值增加 $a_i$ 的概率为 $d_{i-1,j,1}$，所以有：
    - $f_{i,j,1}=p_i(f_{i-1,j,1}+a_id_{i-1,j,1})$
    - $d_{i,j,1}=p_id_{i-1,j,1}$
    
  - 若新开启一段极长连续段
 
    - 上一位填 $0$，权值增加 $a_i$ 的概率为 $d_{i-1,j-1,0}$，有：
    - $f_{i,j,1}=p_i(f_{i-1,j-1,0}+a_id_{i-1,j-1,0})$
    - $d_{i,j,1}=p_id_{i-1,j-1,0}$
    
  - 综上，有：
 
  - $f_{i,j,1}=p_i(f_{i-1,j,1}+f_{i-1,j-1,0}+a_i(d_{i-1,j,1}+d_{i-1,j-1,0}))$
  - $d_{i,j,1}=p_i(d_{i-1,j,1}+d_{i-1,j-1,0})$
 
转移式如上，注意给 $d_{i,0,0}$ 初始化为 $p_id_{i-1,0,0}$ 即可。

易分析时间复杂度为 $O(nk)$。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
const int K=25;
const int mod=998244353;
int n,k,a[N],p[N],f[N][K][2],d[N][K][2];
signed main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>p[i];
    d[0][0][0]=1;
    for(int i=1;i<=n;i++){
        d[i][0][0]=(1-p[i]+mod)*d[i-1][0][0]%mod;
        for(int j=1;j<=min(k,(i+1)/2);j++){
            f[i][j][0]=(1-p[i]+mod)*(f[i-1][j][0]+f[i-1][j][1])%mod;
            f[i][j][1]=p[i]*(f[i-1][j-1][0]+f[i-1][j][1]+a[i]*(d[i-1][j][1]+d[i-1][j-1][0])%mod)%mod;
            d[i][j][0]=(1-p[i]+mod)*(d[i-1][j][0]+d[i-1][j][1])%mod;
            d[i][j][1]=p[i]*(d[i-1][j-1][0]+d[i-1][j][1])%mod;
        }
    }
    cout<<(f[n][k][0]+f[n][k][1])%mod;
    return 0;
}
```

---

## 作者：SkyRainWind (赞：1)

更好的阅读体验：[my blog](https://www.cnblogs.com/SkyRainWind/p/17051926.html)

[这是官方题解](https://www.luogu.com.cn/blog/your-alpha1022/cooi-round-1-ti-xie)

题解：

设 $f[i][j][0/1]$ 表示考虑到第 $i$ 个位置，已经形成了极大的 $j$ 段，当前位置为 0/1 的期望值 ； $g[i][j][0/1]$ 也同理，不过维护的是概率。

（思考：这种不是求最优决策而是求某种固定的答案的问题，可以再开一个数组维护一下当前状态下的其它值，因为没有决策也就没有 max/min 之类的操作，因此维护比较方便）。

转移方程：

![转移方程](https://cdn.luogu.com.cn/upload/image_hosting/ohj7w8ew.png)

（from 官方题解）

解释：第一个方程就是当前位置取 $0$ 时的期望，可以由上一位是 0/1 转移过来，概率是 $1-p_i$。

第二个方程是当前取 $1$ 时的。显然也是由 0/1 转移过来，由期望的线性性可以相加。$f(i-1,j,1)+g(i-1,j,1)a_i$ 代表当前这个状态的期望（再次运用了期望的线性性），因为取 1 也有 $p_i$ 的概率，所以也要乘一个系数，加号后面的也同理。

注意维护一下 $j=0$ 的时候的 $g$ 就行了。

```cpp
// by SkyRainWind
#include <bits/stdc++.h>
#define mpr make_pair
#define debug() cerr<<"Yoshino\n"
#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define pii pair<int,int>

using namespace std;

typedef long long ll;
typedef long long LL;

const int inf = 1e9, INF = 0x3f3f3f3f, mod = 998244353, maxn = 2e5+5;

int n,k,a[maxn],p[maxn];
int dp[maxn][22][2], g[maxn][22][2];

ll pw(ll x,int y){
	if(!y)return 1;
	if(y == 1)return x%mod;
	ll mid=pw(x,y>>1);
	if(y&1)return 1ll*mid*mid%mod*x%mod;
	return 1ll*mid*mid%mod;
}

signed main(){
//	freopen("Luogu7509.in","r",stdin);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)scanf("%d",&p[i]);
	
	g[0][0][0] = 1;
	for(int i=1;i<=n;i++){
		dp[i][0][0] = 0;
		g[i][0][0] = 1ll * (1-p[i]+mod) * g[i-1][0][0] % mod;
		for(int j=1;j<=min(k, (i+1)/2);j++){
			(dp[i][j][0] += 1ll * (1-p[i]+mod) * (dp[i-1][j][1] + dp[i-1][j][0]) % mod) %= mod;
			(dp[i][j][1] += 1ll * p[i] * (dp[i-1][j-1][0] + 1ll * g[i-1][j-1][0] * a[i] % mod) % mod) %= mod;
			(dp[i][j][1] += 1ll * p[i] * (dp[i-1][j][1] + 1ll * g[i-1][j][1] * a[i] % mod) % mod) %= mod;
			(g[i][j][1] += 1ll * p[i] * (g[i-1][j][1]+g[i-1][j-1][0]) % mod) %= mod;
			(g[i][j][0] += 1ll * (1-p[i]+mod) * (g[i-1][j][1] + g[i-1][j][0]) % mod) %= mod;
		}
	}
	int bs = pw((g[n][k][1] + g[n][k][0])%mod, mod-2);
	cout<<(dp[n][k][1]+dp[n][k][0])%mod;

	return 0;
}
```

---

## 作者：小杨小小杨 (赞：1)

时间复杂度：$O(nk \log p)$。   
我们可以设置两个数组，分别为 $dp$ 和 $g$，$g$ 是作为概率进行辅助的计算，每一个状态都可在前一个状态进行转移。而 $dp$ 数组怎么打相信我不用多说了吧。        
根据题意，可以打出状态转移方程：   
$dp(i,j,0) = (1 - p(i)) \times (dp(i - 1,j,1) + p(i - 1,j,0))$     
$dp(i,j,1)=p(i) \times (dp(i - 1,j,1) + g(i - 1,j,1) \times a(i)) + p(i) \times (dp(i - 1,j - 1,0) + g(i - 1,j - 1,0) \times a(i))$   
$i$: 当前位置  
$j$: 当先连续的段数   
运算符重载中的除法重载用快速幂即可。  
附上最长本题代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mo=998244353;
const long long MAX_N=1e5+5,MAX_M=25;
inline int read(){
	long long x=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
	return x;
}//读入优化
long long kkksc03(long long x,long long y){
	long long s=1;
	while (y!=0){
		if (y%2==1) s=s*x%mo;
		x=x*x%mo;
		y/=2;
	}
	return s;
}//快速幂
struct kira{
	long long x;
	kira(long long x=0):x(x){};
	kira operator=(const long long &xx){
		x=xx;
		return *this;
	}
	kira operator+(const kira &b){
		return (kira)((x+b.x)%mo);
	}
	kira operator-(const kira &b){
		return (kira)((x-b.x+mo)%mo);
	}
	kira operator*(const kira &b){
		return (kira)((x*b.x)%mo);
	}
	kira operator/(const kira &b){
		return (kira)(x*kkksc03(b.x,mo-2)%mo);
	}
	kira operator^(const kira &b){
		return (kira)(kkksc03(x,b.x));
	}
	kira operator+=(const kira &b){
		return (kira)((x+b.x)%mo);
	}
	kira operator-=(const kira &b){
		return (kira)((x-b.x+mo)%mo);
	}
	kira operator*=(const kira &b){
		return (kira)((x*b.x)%mo);
	}
	kira operator/=(const kira &b){
		return (kira)(x*kkksc03(b.x,mo-2)%mo);
	}
	kira operator^=(const kira &b){
		return (kira)(kkksc03(x,b.x));
	}
	kira operator+(const long long  &b){
		return (kira)((x+b)%mo);
	}
	kira operator-(const long long &b){
		return (kira)((x-b+mo)%mo);
	}
	kira operator*(const long long &b){
		return (kira)((x*b)%mo);
	}
	kira operator/(const long long &b){
		return (kira)(x*kkksc03(b,mo-2)%mo);
	}
	kira operator^(const long long &b){
		return (kira)(kkksc03(x,b));
	}
	kira operator+=(const long long &b){
		return (kira)((x+b)%mo);
	}
	kira operator-=(const long long &b){
		return (kira)((x-b+mo)%mo);
	}
	kira operator*=(const long long &b){
		return (kira)((x*b)%mo);
	}
	kira operator/=(const long long &b){
		return (kira)(x*kkksc03(b,mo-2)%mo);
	}
	kira operator^=(const long long &b){
		return (kira)(kkksc03(x,b));
	}
	bool operator==(const long long b){
		return x==b;
	}
};//超级变态的运算符重载
long long n,m,i,k;
kira a[MAX_N],p[MAX_N],u,g[MAX_N][MAX_M][2],dp[MAX_N][MAX_M][2],gundam;
int main(){
	n=read();m=read();
	for (i=1;i<=n;i++)  a[i]=read();
	for (i=1;i<=n;i++)	p[i]=read();//手打读入
	g[0][0][0]=1;//初始化
	u=1;//因为某些灵异事件（类型不相等事件），必须要这么定一个。
	for (i=1;i<=n;i++)
		for (k=0;k<=m;k++)
			if (k==0)
				g[i][k][0]=g[i-1][k][0]*(mo+1-p[i].x);
			else{
				if (k+k-1>i) continue;
				else if (k+k-1==i){
					g[i][k][1]=g[i-1][k-1][0]*p[i];
					dp[i][k][1]=dp[i-1][k-1][0]+a[i];
				}
				else{
					g[i][k][1]=g[i-1][k-1][0]*p[i]+g[i-1][k][1]*p[i];
					gundam=u/(g[i-1][k-1][0]+g[i-1][k][1]);
					dp[i][k][1]=a[i]+dp[i-1][k-1][0]*g[i-1][k-1][0]*gundam+dp[i-1][k][1]*g[i-1][k][1]*gundam;
					g[i][k][0]=(g[i-1][k][1]+g[i-1][k][0])*(mo+1-p[i].x);
					gundam=u/(g[i-1][k][0]+g[i-1][k][1]);
					dp[i][k][0]=dp[i-1][k][0]*g[i-1][k][0]*gundam+dp[i-1][k][1]*g[i-1][k][1]*gundam;//都懂的
				}
			}
	printf("%lld\n",(dp[n][m][0]*g[n][m][0]+dp[n][m][1]*g[n][m][1]).x);
	return 0; 
}
```


---


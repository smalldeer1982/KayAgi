# [COCI 2010/2011 #5] DVONIZ

## 题目描述

当前 $K$ 个元素的和与最后 $K$ 个元素的和都不大于 $S$ 时，我们说这个 $2\times K$ 个元素的序列是有趣的。

给出一个长度为 $N$ 的序列 $A$。对于每个元素，输出从该元素开始的最长的有趣的子段。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$2\le N\le 10^5$，$1\le S\le 2\times 10^9$。

**【说明】**

本题分值按 COCI 原题设置，满分 $120$。

题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #5](https://hsin.hr/coci/archive/2010_2011/contest5_tasks.pdf)  _**T5 DVONIZ**_。

## 样例 #1

### 输入

```
5 10000
1
1
1
1
1 ```

### 输出

```
4
4
2
2
0 
```

## 样例 #2

### 输入

```
5 9
1
1
10
1
9 ```

### 输出

```
2
0
0
2
0 ```

## 样例 #3

### 输入

```
8 3
1
1
1
1
1
1
1
1 ```

### 输出

```
6
6
6
4
4
2
2
0 ```

# 题解

## 作者：A_Sunny_Day (赞：5)

## [COCI2010-2011#5] DVONIZ

题意：

​	定义长度为 $2\times K$ 并且前 $K$ 个元素之和不超过 $S$ 且后 $K$ 各元素之和也不超过 $S$ 的数列为 INTERESTING 串，给定长度为 $N$ 的数列 $A$ ，对于每个元素，求出以该元素为起点的最长 INTERESTING 串。($2 \le N \le 100000,1\le S \le 2\times10^9$) 

​	首先我们定义 $\text{mid}$ 为一个 INTERESTING 串的中心：即分界点。设 $\text{L}$,$\text{R}$ 分别为这个串的左端点和右端点，而这个串长度为 $2\times K$ 我们把 $\text{L}$ ~ $\text{mid}$ 这一段看作串的前 $K$ 个。而 $\text{mid}$ ~ $\text{R}$  这一段看作为串的后 $K$ 个。显然，当  $\text{mid}$ 不变时所有以 $\text{mid}$ 为中心点的且长度小于 $K$ 的串都是 INTERESTING 串。所以，我们只要找到对于每一个位置作为 $\text{mid}$ 时所能取到的最长的长度 $K$ 就可以通过递推得到每个位置作为起点时的答案。

​	递推式为：
$$
ans[i]=\max(ans[i-1]-2,ans[i]) (1\le i \le n)
$$
​	那么问题变成了求对于每个位置作为 $\text{mid}$ 时所能取到的最大的 $K$。 我们考虑从左到右枚举 $\text{mid}$。 注意到，当 $\text{mid}$ 向右移动时，它能取到最远的左端点和右端点$L,R$ 必定也会向右边移动。那么我们就可以用**双指针**（**尺取**）的方法来解决这个问题。时间复杂度为 $O(n)$。

​	在取完之后，我们根据左右指针所在的位置 $L,R$ 来得到此时能取到的最大的 $K$。 即：
$$
K=\min(R-mid,mid-l+1)
$$
​	而更新答案我们这样更新：
$$
ans[mid-K+1]=2\times K
$$
​	在结束后我们再遍历一遍，通过上文得到的递推式推出所有的 $\text{ans}$ 值。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e5+5;
int n;
ll s,a[MAXN],len[MAXN];
int main()
{
	scanf("%d %lld",&n,&s);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	int l=1,r=0;
	ll ls=0,rs=0;
	while(rs+a[r+1]<s&&r<n) rs+=a[++r];
	for(int i=1;i<=n;++i)
	{
		ls+=a[i];
		rs-=a[i];
		while(ls>s&&l<=i)
		{
			ls-=a[l];
			++l;
		}
		while(rs+a[r+1]<=s&&r<n) rs+=a[++r];
		int le=min(i-l+1,r-i);
		if(le>0) len[i-le+1]=le*2;
	}
	for(int i=1;i<n;++i) len[i]=max(len[i-1]-2,len[i]);
	for(int i=1;i<n;++i)
		printf("%lld\n",len[i]);
	printf("0\n");
	return 0;
}
```



---

## 作者：_H17_ (赞：3)

## 题目分析

首先分析下数据，$n \le 10^5$ 基本上肯定是 $O(n \log n)$ 的复杂度，$O(n^2)$ 使尽全力卡常可以（通常最多卡常卡掉 $100$ 倍）

看见 $\log$ 难道不会想起二分答案吗？

不过看着这种输出大概又像是 DP，所以大概就是向 LIS 那样借助二分进行 DP。

状态不说了，输出格式替你设好了。

对于 $f_i$ 肯定可以从 $f_{i-1}$ 去掉首尾得到，所以得到状态转移方程 $f_i=\max(f_i,f_{i-1}-2)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,a[3000001],l,r,mid,f[3000001];
bool check(int x,int y){
	return a[x]-a[x-y]<=m&&a[x+y]-a[x]<=m;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]+=a[i-1];
	}
	for(int i=1;i<=n;i++){
		l=0,r=min(i,n-i);
		while(l<r){
			mid=l+r+1>>1;
			if(check(i,mid))
				l=mid;
			else
				r=mid-1;
		}
		f[i-l+1]=max(f[i-l+1],2*l);
	}
	for(int i=1;i<=n;i++)
		f[i]=max(f[i],f[i-1]-2);
	for(int i=1;i<=n;i++)
		cout<<f[i]<<'\n';
	return 0;
}
```

## 加强版&双倍经验

[题目](/problem/P8049)、[题解](/blog/743014/coci2010-20115-dvoniz-jia-qiang-ban-post)

---

## 作者：zhaoyp (赞：2)

考虑维护中间位置 $\text{mid}$，即对于每个 $\text{mid}$，找到一个最大的 $x$，使得该 $\text{mid}$ 的前 $x$ 个元素（含 $\text{mid}$）的和与后 $x$ 个元素（不含 $\text{mid}$）的和均不大于 $m$，并用来更新该区间左端点的答案。

不难发现 $\text{mid}$ 左右段的长度具有单调性，对每一个位置进行二分答案即可，时间复杂度 $O(n \log n)$。

但是这样的维护是不完全的，因为有的答案可能是通过上法求得最长序列的部分。又注意到对于任意一个合法序列 $a$，去掉 $a$ 的第一个和最后一个元素，它依然是合法的。

于是就有如下递推式：

$$f_i=\max(f_{i - 1}-2,f_i)$$
其中 $f_i$ 表示从第 $i$ 个元素开始的最长的优美序列的长度，$\text{DP}$ 即可，总时间复杂度 $O(n \log n)$。

考虑时间复杂度更优的做法：

注意到，当 $\text{mid}$ 向右移动时，它能取到最远的左端点和右端点 $l,r$ 必定也会向右边移动。那么我们就可以用双指针（尺取法）来优化。时间复杂度 $O(n)$。


总时间复杂度 $O(n)$。

---

## 作者：ChengJY_ (赞：2)

### [题目](https://www.luogu.com.cn/problem/P7635)
------------
- 这道题的思路很暴力，通过优化的枚举就可以得到一个很不错的时间复杂度，只是坑点有点多，所有坑点我都会在接下来的文字中叙述。
- 前置芝士：二分答案(不会的先去学)。

- **第一种，暴力枚举 (最高54分)**
- 我们可以将每一个数元素所对应的 $K$ 从最大值开始向前枚举，这种算法可以得到[较高的分数](https://www.luogu.com.cn/record/52088500)，但肯定不是正解，~~但如果思路错了分数甚至没有暴力高~~。
```c
#include<bits/stdc++.h>
using namespace std;
long long n,s,x,sum[100005];
bool work(int i,int mid){
	if((sum[i+mid-1]-sum[i-1]>s)||(sum[i+mid*2-1]-sum[i+mid-1]>s))
		return false;
	return true;
}
int main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		sum[i]=sum[i-1]+x;
	}
	for(int i=1;i<=n;++i){
		int ans=0;
		for(int j=(n-i+1)/2;j>=1;j--) 
			if(work(i,j)){
				ans=j;break;
			}
		printf("%d\n",ans*2);
	}
	return 0;
} 
```


- **第二种，二分答案优化(~~其实也是暴力~~)(120分)**
- 我们很容易发现，每一个序列的前 $K$ 个元素之和随 $K$ 的减小而减小，是单调的。因此可以将满足“当前 $K$ 个元素的和小于 $S$ ”的 $K$ 的范围通过二分求出。
```
  int l=0,r=(n-i+1)/2/*小细节*/t=0;
  while(l<=r){//万能的二分答案板子 
      int mid=l+r>>1;
      if(sum[i+mid-1]-sum[i-1]>s)
          r=mid-1;
      else{
          l=mid+1;
          t=mid;	
      }
  }
```
-  $K$ 满足的第一个取值范围即为 $0≤K≤t$。
- 但是后 $K$ 个元素之和关于 $K$ 单调吗？其实不是的，这是个坑点(~~当时卡这里卡了一个晚自习~~)。
- 这里给出一组数据：1 2 2 9 5 1 1 1 
1. 当 $i=1$，$K=4$时，后 $K$ 个元素之和为8；
1. 当 $i=1$，$K=3$时，后 $K$ 个元素之和为15；
1. 当 $i=1$，$K=2$时，后 $K$ 个元素之和为11。
- 我们发现，后 $K$ 个元素之和关于 $K$ 并不单调，因此不能将后 $K$ 个元素带入二分求出范围！
- 因此我们求出 $K$ 的第一个范围之后，需要用其他方法求出满足第二个条件的 $K$ 的最值，我直接使用第一种暴力枚举的方法，然后惊奇的发现[过了](https://www.luogu.com.cn/record/52088779)，时间也很短，不知道是不是这题数据太水。

**AC code**
```c
#include<bits/stdc++.h>
using namespace std;
int n,s,x,sum[100005];
int main(){
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		sum[i]=sum[i-1]+x//前缀和优化;
	}
	for(int i=1;i<=n;++i){
		int l=0,r=(n-i+1)/2,ans=0,t=0;
		while(l<=r){ 
			int mid=l+r>>1;
			if(sum[i+mid-1]-sum[i-1]>s)
				r=mid-1;
			else{
				l=mid+1;
				t=mid;	
			}
		}
		for(int j=t;j>=1;j--)//从后向前枚举 
			if(sum[i+j*2-1]-sum[i+j-1]<=s){
				ans=j;break;
			}
		printf("%d\n",ans*2);
	}
	return 0;
}  
```
- 如果评论区有大佬有更好的算法欢迎指出^^。


---

## 作者：1232RvE (赞：1)

## 方法一：暴力
（没试过，但应该小于60分）
## 方法二：前缀和（72pts）
看到**求区间和**，想到“前缀和”做法，枚举中间指针，每一次枚举元素头，再枚举中间指针，用时间复杂度 $O(1)$ 的时间来算区间和（注意减去 `a[i-1]`）
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int a[N];
int n,s,tmp;
int ans;
int cnt(int l,int r){
	return a[r]-a[l-1]; 
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>s;
	a[0]=0;
	for(int i=1;i<=n;i++){
		cin>>tmp;
		a[i]=a[i-1]+tmp;
	}
	for(int i=1;i<n;i++){//O(n*n/2)=5*(10^9)
		ans=0;
		for(int j=(n-i-1)/2;j>=0;j--){
			if(cnt(i,i+j)<=s&&cnt(j+i+1,i+2*j+1)<=s){
				ans=j+1;
				break;
			}
		}
		cout<<ans*2<<"\n";
	}
	cout<<0;
}
```
时间复杂度约为$O(\frac{n^2}{2})$。
## 方法三：前缀和+二分答案
注意到区间和随着区间长度不断增大的单调性，可以使用二分答案。

时间复杂度由 $O(\frac{n^2}{2})$ 降至 $O({n \times \log n})$。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5; 
int n,s,tmp,a[N];
int ans;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n>>s;
	for(int i=1;i<=n;++i){
		cin>>tmp;
		a[i]=a[i-1]+tmp;
	}
	for(int i=1;i<=n;++i){
		int l=0,r=(n-i+1)/2;
		ans=0;
		while(l<=r){ //二分答案 
			int mid=l+r>>1;
			if(a[i+mid-1]-a[i-1]>s)
				r=mid-1;
			else{
				l=mid+1;
				tmp=mid;	
			}
		}
		for(int j=tmp;j>=1;j--)
			if(a[i+j*2-1]-a[i+j-1]<=s){
				ans=j;
				break;//剪枝 
			}
		cout<<ans*2<<"\n";
	}
	return 0;
}
```
感谢观看

---

## 作者：tangzirui1016 (赞：1)

不是怎么感觉巨佬们都把问题复杂化了呀。

这题不就是一个简简单单的双指针吗？

有趣的序列是形容**后面** $2\times K$ 个元素，所以一个指针可以**从后往前**枚举。

我们发现，当 $i$ 从后往前枚举时，它的答案点（即序列的右节点）也是从后往前的。因为 $a_i>0$，每次 $i$ 往前推只会使得和越来越大，不管是前 $K$ 个元素，还是后 $K$ 个。直到超过限制，答案点往前推。

答案点会不会往后走呢？

不会的，因为我们先判断的位置 $i+1$，再判断的 $i$，如果 $i$ 的答案点比 $i+1$ 的答案点更靠前，那么 $i+1$ 为什么不能选这个 $i$ 的答案点呢？

所以我们也可以用一个指针记录答案点。

其实不用前缀和优化也行。

时间复杂度为 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define r (pos+(pos-i+1))
using namespace std;
const int N=3e6;
int n,S,a[N+5],res[N+5],pos;
long long s[N+5];
//pos表示区间的中点（偏左），r表示答案点
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>S;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
	pos=n-1;
	for(int i=n-1;i>=1;i--){
		while(pos>=i&&(r>n||s[r]-s[pos]>S||s[pos]-s[i-1]>S)){
			pos--;
		}
		res[i]=2*(pos-i+1);
	}
	for(int i=1;i<=n;i++) cout<<res[i]<<'\n';
	return 0;
}
```

---

## 作者：Dream__Sky (赞：1)

考虑尺取法。

以下定义 $mid$ 为当前区间的中点下标，$l$ 为左端点下标，$r$ 为右端点下标。

普通暴力为，从 $1$ 到 $n$ 枚举中点 $mid$。从当前的 $mid$ 开始，向左枚举，直到和大于 $s$，求出 $l$。再向右枚举，直到和大于 $s$，求出 $r$。求出 $l$ 和 $r$ 之后，我们可以计算以 $mid$ 作为中点时的最大长度 $K$，即 $K=\min(mid-l+1,r-mid)$。但是题目要求的是作为开头时的最小值，那我们可以把它整体向左移 $k$ 位，开头下标变成 $mid-K+1$，将这个长度记录到这一位。时间复杂度 $O(n^2)$。

最后，可能有一些点还没有被更新答案，那我们考虑当前这一位与前一位的关系。考虑不取前一位，为了还满足是 $2 \times K$ 个元素，还得去掉最后一个。即前一位的最大长度减二。此时，该区间一定满足两边的和都小于 $s$，因为上次的区间都小于 $s$ 了，去掉两个数后和甚至都小于原值了，所以满足条件。

如何从暴力上优化？这就要提到尺取法了。当我们变动 $mid$ 后，$l$ 与 $r$ 一定都会向右移动（或者不动），那我们每次可以直接从上一次的 $l$ 与 $r$ 继续向右枚举，直到和大于 $s$。其它都与的与上面相同。时间复杂度 $O(n)$。

在尺取过程中，可以使用前缀和来快速计算区间和。当然也可以边尺取，边计算连续一段区间的和。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n,s,a[100010],t[100010],c[100010];
signed main()
{
	cin>>n>>s;
	for(int i=1;i<=n;i++) cin>>a[i],c[i]=c[i-1]+a[i];//前缀和
	
	int l=1,r=1;
	
	for(int i=1;i<=n;i++)//i即为mid
	{
		while(c[i]-c[l-1]>s) l++;//左端点移动
		while(c[r+1]-c[i]<=s&&r<n) r++;//右端点移动
		int K=min(i-l+1,r-i);//计算K
		t[i-K+1]=K*2;//记录长度
	} 
	for(int i=1;i<=n;i++) t[i]=max(t[i-1]-2,t[i]);//记录未被记录长度的点的长度（有点绕？
	for(int i=1;i<=n;i++) cout<<t[i]<<"\n";
	return 0;
}


```


---

## 作者：tongzhenxuan (赞：1)

## 思路解析：
#### 1.考虑暴力算法 $O(n^3)$。
枚举左右端点，遍历判断是否合法。最多只能拿 $N \le 200$ 的分数。
#### 2.暴力加上前缀和优化 $O(n^2)$。
可以省去遍历所需复杂度。能拿到 $N \le 5 \times 10^3$ 的分数。
#### 3.枚举中间点加二分答案 $O(nlogn)$。	
因为题目中说每个元素的值都为正整数。
可以考虑枚举中间点 $mid$，因而从 $mid$ 左右出发的元素加和是单调递增的。可以考虑运用二分答案，求出以 $mid$ 为中点的左右最远扩展程度（最远到达 $l,r$ 点），取较短的一边，即为此时 $mid$ 的最长长度。

即
```cpp
len=min(r-mid,mid-l+1);
tot[mid-len+1]=max(2*len,tot[mid-len+1]);
```

注：$mid$ 为左区间最后一个元素的下标。

但这样的做法是不完全的，有部分端点的值被更新到了，但是有一些端点没有被更新。考虑到将一个合法的区间去掉头尾两个元素，还是成立的，可以推出:

```cpp
tot[i]=max(tot[i],tot[i-1]-2);
```
最后这里要更新一边才能得到最终答案。
这样的做法可以拿到 $N \le 10^5$ 的分数。

#### 4.枚举中间点加尺取法 $O(n)$。
形同第三条，也是枚举 $mid$ 时找出最远到达的两点 $l,r$，但是发现在 $mid$ 往右移动的时候 $l,r$ 两点也在往右移动，所以可以使用尺取法优化掉二分答案的复杂度。当 $mid$ 右移后，若左区间的累加和已经大于 $S$，将左端点向右移动，直到左区间累加和小于等于 $S$。若右区间累加和小于 $S$，且右区间还能加入元素，那么将右端点向右移动，扩大右区间长度。因为 $l,r$ 最多经历每个端点一次，所以整体的时间复杂度是 $O(n)$ 的。可以通过 $N \le 3 \times 10^6$ 的数据。不要忘记第三条中说的最后更新哦。

## code:
```cpp
#include<bits/stdc++.h>
#define N 3000005
using namespace std;
int n,k;
int a[N],s[N],tot[N];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		s[i]=s[i-1]+a[i];
	}
	int len,head=1,tail=1;
	for(int mid=1;mid<=n;mid++)
	{
		while(s[mid]-s[head-1] > k)  head++;
		while(s[tail+1]-s[mid] <= k && tail < n) tail++;
		len=min(tail - mid , mid - head + 1);
		tot[mid-len+1]=max(tot[mid-len+1],len*2);
	}
	for(int i=1;i<=n;i++)
		tot[i]=max(tot[i],tot[i-1]-2);
	for(int i=1;i<=n;i++)
		printf("%d\n",tot[i]);
	return 0;
}
```

---

## 作者：Cells (赞：0)

## 思路

> 当前 $K$ 个元素的和与最后 $K$ 个元素的和都不大于 $S$ 时，我们说这个 $2 \times K$ 个元素的序列是有趣的。

这句话间接地提醒了我怎么做，试想一下某个子序列被分成了相等的两部分，由于 $A_i \in \mathbb{N}^+$，所以能够想到对于一个固定的中心点，它左右两边的元素和只会越来越大，换句话说，元素和具有单调性。既然这样，对于一个固定的中心点，可以二分 $K$ 值，使用前缀和 $O(1)$ 判断 $K$ 是否合法。

但是还有需要完善的地方，按照我们的思路，这样写只会更新子序列端点的 $K$，但是子序列内部我们还没管，能够想到，$ans_i = \max(ans_{i - 1} - 2, ans_i)$，相当于是这个数可以通过去掉前一个的数的左右端点的方式更新 $K$。

时间复杂度 $O(n \log{n})$，[加强版](https://www.luogu.com.cn/problem/P8049) 也是可以通过的，常数需要优秀而已。

但是写都写了，不如把最优秀的解法也说了。

考虑优化掉 $\log$，想象一下，离中心点的最远的端点 $l, r$ 都会随着中心点的向右移动而右移，而 $K = \min(i - l + 1, r - i)$，$i$ 是左半边的最右边的点，所以可以使用双指针模拟 $l, r$，直接算出 $K$，时间复杂度显然为 $O(n)$。

## Code

**二分**

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 3e6 + 10;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n;
int a[N], ans[N];

LL s, pre[N];

il bool check(int x, int len){
	return pre[x] - pre[x - len] <= s && pre[x + len] - pre[x] <= s;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> s;
	
	rep(i, 1, n) cin >> a[i], pre[i] = pre[i - 1] + a[i];
	
	rep(i, 1, n){
		int l = 0, r = min(i, n - i);
		while(l < r){
			int mid = l + r + 1 >> 1;
			if(check(i, mid)) l = mid;
			else r = mid - 1;
		}
		
		ans[i - l + 1] = l * 2;
	}
	
	rep(i, 1, n) ans[i] = max(ans[i], ans[i - 1] - 2), cout << ans[i] << "\n";
	
	return 0;
}
```

**双指针**

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 3e6 + 10;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n, l, r, k;
int a[N], ans[N];

LL s, pre[N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> s;
	
	rep(i, 1, n) cin >> a[i], pre[i] = pre[i - 1] + a[i];
	
	l = r = 1;
	rep(i, 1, n){
		while(pre[i] - pre[l - 1] > s) l ++;
		while(pre[r + 1] - pre[i] <= s && r < n) r ++;
		k = min(i - l + 1, r - i);
		ans[i - k + 1] = k << 1;
	}
	
	rep(i, 1, n) ans[i] = max(ans[i], ans[i - 1] - 2), cout << ans[i] << "\n";
	
	return 0;
}
```

---

## 作者：内拉组里 (赞：0)

# Pts 87

对 $ a $ 数组作一个前缀和，

然后暴力枚举以每个元素开始的奇数长子段右端点，一个一个 **tomax**，

当区间总和超过 $ 2s $ 时直接退出即可。

## Analyses：

> 总时间复杂度 $ \Theta (N^2) $。
>
> 总空间复杂度 $ \Theta (N) $。

***

# Pts 120

## Plain

枚举时用 **upper_bound** 求出可能的最右端点，从右往左枚举，

找到第一个合法右端点时直接退出。

原题就这么水过去了。

但加强版这样只能拿 **70pts**，还需要优化。

#### Analyses：

> 总时间复杂度 $ \Theta (N^2) $。
>
> 总空间复杂度 $ \Theta (N) $。

***

## Fread

如题，这种方法需要开快读。

考虑枚举中点。

由于 $ a $ 数组是单调递增的，

所以对于每个中点 $ mid $，可以二分出一对临界的 $ (l,r) $，满足 $ \sum\limits^{mid}_{i = l} a_i \le s $，$ \sum\limits^r_{i = mid + 1} a_i \le s $。

二者都能得到一个 **interesting** 序列的半径，取 **min** 即可。

然后在半径能扫到的区间的左半区间中更新答案。

显然地，更靠右的 $ mid $ 能得到更长的 **interesting** 序列，

故倒序枚举，当扫到一个更新过答案的位置时，直接退出即可。

这样每个位置的答案只会被更新一次。

#### Details：

- $ a $ 数组记得开 $ long \ long $，否则 $ \sum a_i + s $ 会炸。

#### Analyses：

> 总时间复杂度 $ \Theta (N \log{N}) $。
>
> 总空间复杂度 $ \Theta (N) $。

***

## Double Pointer

事实上，如果用 **cin**，**cout** 的话，单输入数据就 **TLE** 了。

所以要用 **scanf** 和 **printf**。

容易发现，当中点 $ mid $ 向右移动时，对应的临界 $ (l,r) $ 也是单调递增的。

故考虑用双指针维护 $ l $ 和 $ r $，然后求最大合法半径 $ R $ （跟上面的 $ R $ 是一个东西），

然后去更新 $ R $ 能扫到的最左边的位置的答案，

现在是正序遍历，故左端点答案一定不比之前的差，覆盖即可。

但显然，这里只更新了 $ n $ 次答案，

所以一定会有某些位置多次更新，从而造成其他的位置没有被更新。

拿样例 #2 模拟一下不难发现，这时 $ ans_i = ans_{i - 1} - 2 $，

即在上一个位置的答案序列中左右各去掉一个元素，这样肯定也合法。

所以最后要对答案作一个类前缀 **max** 的处理。

#### Analyses：

> 总时间复杂度 $ \Theta (N) $。
>
> 总空间复杂度 $ \Theta (N) $。

# Code：

```cpp
/* reference : @Luogu.huhangqi */
/* reference : @ZLOJ.luzexi */
#include	<algorithm>
#include	<iostream>
using namespace std;
using ll = long long;
constexpr int maxn = 3e6+4;

namespace pts87
{
	int n, s;
	int a[maxn];
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			cin >> a[i];
			a[i] += a[i - 1];
		}
		for (int i = 1; i <= n; i++)
		{
			int ans = 0;
			for (int j = i + 1; j <= n && a[j] - a[i - 1] <= (s << 1); j += 2)
			{
				int mid = (i + j) >> 1;
				if (a[mid] - a[i - 1] <= s && a[j] - a[mid] <= s) ans = max (ans, j - i + 1);
			}
			cout << ans << endl;
		}
		return 0;
	}
}

namespace pts120
{
	int n, s;
	int a[maxn];
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			cin >> a[i];
			a[i] += a[i - 1];
		}
		for (int i = 1; i <= n; i++)
		{
			int ans = 0;
			int j = upper_bound (a + 1, a + n + 1, (ll) a[i] + (s << 1)) - a - 1;
			if ((j - i + 1) & 1) j--;
			while (j > i)
			{
				int mid = (i + j) >> 1;
				if (a[mid] - a[i - 1] <= s && a[j] - a[mid] <= s)
				{
					ans = j - i + 1;
					break;
				}
				j -= 2;
			}
			cout << ans << endl;
		}
		return 0;
	}
}

namespace pts120_hard_fread
{
	int n, s;
	ll a[maxn];
	int ans[maxn];
	
	inline int read (void)
	{
		register int x = 0;
		register char c = getchar();
		while (c < '0' || c > '9') c = getchar();
		while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ '0'),c = getchar();
		return x;
	}
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			a[i] = read();
			a[i] += a[i - 1];
		}
		for (int i = n; i; i--)
		/* enumerate [mid] */
		{
			/* p[l - 1] >= p[mid] - s */
			int l = lower_bound (a, a + n + 1, a[i] - s) - a + 1;
			/* p[r] <= p[mid] + s */
			int r = upper_bound (a, a + n + 1, a[i] + s) - a - 1;
			int R = min (i - l + 1, r - i);
			for (int j = i - R + 1; j <= i && !ans[j]; j++) ans[j] = (i - j + 1) << 1;
		}
		for (int i = 1; i <= n; i++) printf ("%d\n", ans[i]);
		return 0;
	}
}

namespace pts120_hard_dbptr
{
	int n, s;
	int a[maxn];
	int ans[maxn];
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			scanf ("%d", a + i);
			a[i] += a[i - 1];
		}
		int l = 1;
		int r = 1;
		for (int i = 1; i <= n; i++)
		{
			while (a[i] - a[l - 1] > s) l++;
			while (a[r] - a[i] <= s && r <= n) r++;
			int R = min (i - l + 1, r - i - 1);
			ans[i - R + 1] = R << 1;
		}
		for (int i = 1; i <= n; i++) printf ("%d\n", ans[i] = max (ans[i], ans[i - 1] - 2));
		return 0;
	}
}

signed main (void)
{
//	freopen ("dvoniz.in.6", "r", stdin);
	return pts120_hard_dbptr::main ();
}
```

---

## 作者：Xiphi (赞：0)

本题解将会把我完整的思考过程写出来，所以可能有些繁杂。

首先，开题之后发现如果是要二分一个美丽的序列的前半段最长能是多少，这个很容易，用 [UVA1619](https://www.luogu.com.cn/problem/UVA1619) 类似的套路就行，但这样无法处理后半段的东西。

换个思路，类似二分找最大回文串的做法，枚举中间点，然后向两边二分+判断即可满足单调性以及正确性。

如此之后，就能求出**一些**点的答案的了，考虑怎么把**部分**推向**整体**，观察到如果一个子序列是美丽的，则把最左边和最右边的点删掉，则还是满足条件的，删掉的这个过程就等价于把左端点向右移动一个下标。

然后就可以递推了，每个点的最优答案就是 $f_i=\max(f_i,f_{i-1}-2)$。

有些细节见代码，不在此赘述：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,a[200005],sm[100005],f[200005];
int main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin>>n>>s;
	for(int i=1;i<=n;++i) cin>>a[i],sm[i]=sm[i-1]+a[i];
	for(int i=1;i<=n;++i){
		int l=0,ans=0,r=min(n-i,i);
		while(l<=r){
			int mid=l+r>>1;
			if(sm[mid+i]-sm[i]<=s&&sm[i]-sm[i-mid]<=s) {
				ans=mid,l=mid+1;
			}else r=mid-1;
		}
		f[i-ans+1] = max(f[i-ans+1],ans*2);
	}
	for(int i=1;i<=n;++i){
		f[i]=max(f[i],f[i-1]-2);
	}
	for(int i=1;i<=n;++i) cout<<f[i]<<'\n';
	return 0;
}




```

---

## 作者：aaa_lvzekai (赞：0)

## 题目描述

[题目链接](https://www.luogu.com.cn/problem/P7635)

当前 $len$ 个数的和不大于 $s$，并且后 $len$ 个数的和也不大于 $s$ 时，这 $len \times 2$ 个数是有趣的。

给定一个长度为 $n$ 的 $a$ 序列，对于每个数，求出当它为起始点时最长的有趣的序列的长度。

## 思路

### 43 分思路

算法：暴力枚举。

直接暴力枚举起始点，长度并求和，判断是否满足条件。

时间复杂度：$O(n ^ 3)$。

不开 $O2$ 43pts and 8.60s：[提交记录](https://www.luogu.com.cn/record/124537692)。

开 $O2$ 43pts and 8.45s：[提交记录](https://www.luogu.com.cn/record/124536276)。


#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100010;
ll n,m,a[N],sum,ans;
bool flag;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		ans=0;
		for(int len=(n-i+1)/2;len>=1;len--)
		{
			flag=true;
			sum=0;
			for(int now=i;now<=i+len-1;now++)
			{
				sum+=a[now];
			}
			if(sum>m)
			{
				flag=false;
			}
			sum=0;
			for(int now=i+len;now<=i+len*2-1;now++)
			{
				sum+=a[now];
			}
			if(sum>m)
			{
				flag=false;
			}
			if(flag)
			{
				ans=len*2;
				break;
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

### 65 分 or 87 分思路

算法：前缀和。

考虑在上一个思路求和时用前缀和优化。

时间复杂度：$O(n ^ 2)$。

不开 $O2$ 65pts and 6.95s：[提交记录](https://www.luogu.com.cn/record/124537725)。

开 $O2$ 87pts and 5.02s：[提交记录](https://www.luogu.com.cn/record/124537227)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100010;
ll n,m,a[N],ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]+=a[i-1]; 
	}
	for(int i=1;i<=n;i++)
	{
		ans=0;
		for(int len=(n-i+1)/2;len>=1;len--)
		{
			if(a[i+len-1]-a[i-1]<=m&&a[i+len*2-1]-a[i+len-1]<=m)
			{
				ans=len;
				break;
			}
		}
		cout<<ans*2<<"\n";
	}
	return 0;
}
```

### 100 分思路

算法：二分。

我们枚举中点 $mid$ 的位置，考虑二分答案，但是我们发现这样只有 32 分，考虑到将一个合法的序列去掉开头、结尾两个元素，还是合法的，可以得出以下转移方程。

## $dp_i = \max(dp_i , dp_{i-1} - 2);$

时间复杂度：$O(n \log n)$。

不开 $O2$ 100pts and 160ms：[提交记录](https://www.luogu.com.cn/record/124545480)。

开 $O2$ 100pts and 132ms：[提交记录](https://www.luogu.com.cn/record/124545625)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100010;
ll n,m,a[N],l,r,mid,ans,dp[N];
bool check(ll u,ll len)
{
	if(a[u]-a[u-len]<=m&&a[u+len]-a[u]<=m)
	{
		return true;
	}
	return false;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]+=a[i-1];
	}
	for(int i=1;i<=n;i++)
	{
		l=0,r=min((ll)i,(ll)n-i),ans=0;
		while(l<r)
		{
			mid=(l+r+1)/2;
			if(check(i,mid))
			{
				l=mid;
				ans=mid;
			}
			else
			{
				r=mid-1;
			}
		}
		dp[i-ans+1]=max(dp[i-ans+1],ans*2);
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=max(dp[i],dp[i-1]-2);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<dp[i]<<"\n";
	}
	return 0;
}
```

### 100 分思路

算法：尺取。

考虑在上一个思路上把二分改成尺取，从而优化时间复杂度。

我们枚举中点 $mid$ 的位置，考虑尺取，求出在 $mid$ 之前最长的序列，和小于等于 $s$，并求出在 $mid$ 之后最长的序列，和小于等于 $s$，最终以 $mid$ 为中点的答案就是二者的较小数。

时间复杂度：$O(n)$。

不开 $O2$ 100pts and 117ms：[提交记录](https://www.luogu.com.cn/record/124625484)。

开 $O2$ 100pts and 104ms：[提交记录](https://www.luogu.com.cn/record/124625505)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=100010;
ll n,m,a[N],up,sum,down,ans,dp[N]; 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	while(down<=n-1&&ans+a[down+1]<=m)
	{
		ans+=a[++down];
	}
	for(int i=1;i<=n;i++)
	{
		sum+=a[i];
		ans-=a[i];
		while(up<=i&&sum>m)
		{
			sum-=a[up++];
		}
		while(down<=n-1&&ans+a[down+1]<=m)
		{
			ans+=a[++down];
		}
		dp[i-min(i-up+1,down-i)+1]=max(min(i-up+1,down-i)*2,0ll);
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=max(dp[i],dp[i-1]-2);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<dp[i]<<"\n";
	}
	return 0;
}
```

---


# [COCI 2014/2015 #5] ZGODAN

## 题目描述

定义 Handsome 数：这个正整数中任意两个相邻的数位的奇偶性不同。

给你一个正整数 $n$，求与 $n$ 最近的 Handsome 数。如果有多个按从小到大的顺序输出。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^{1000}$。

译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
13```

### 输出

```
12 14```

## 样例 #2

### 输入

```
5801001```

### 输出

```
5810101```

# 题解

## 作者：Shanganze (赞：8)

## 题意：
给定一个数， 求离改数最近任意相邻两位奇偶性不同的数，若有多个，从小到大输出。
### 分析：
就分两种情况：

①找第一个比这个数大的 Handsome 数。
 
 从高位往下找，找第一个奇偶性和前一位相同，若该位不为 $9$，将该位加一，后面的数就根据上一位变，若上一位为奇则该位为 $0$，反之则为 $1$。
 
②找第一个比这个数小的 Handsome 数。

从高位往下找，找第一个奇偶性和前一位相同，若该位不为 $0$，就将该位减一，后面的数就根据上一位变，若上一位为奇则该位为 $8$，反之则为 $9$。

然后，用高精减法判断两个数哪个更近。

然后就愉快 WA 了：[72分](https://www.luogu.com.cn/paste/jf1np8qu) $\;$[评测记录](https://www.luogu.com.cn/record/86476701)

同机房大佬给出了两组 hack 数据 ：
 $1001 $ $\;$  $999$

还是要修改第一个奇偶相同的数为 $9$ 或 $0$ 的情况。 

如果为 $9$ 时，加一时就把该位变为 $0$，上一位加 $1$，一直进位到上一位不为 $9$。

如果为 $0$ 时，减一时就把该位变为 $9$，向上一位借位，一直借到不为零。

一天的奋斗终于 [AC](https://www.luogu.com.cn/record/86513338) 了。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct a1
{
	int x[100001];
	a1()
	{
		memset(x,0,sizeof(x));
	}
}x,y,z;
a1 operator - (const a1 a,const a1 b)//高精减高精
{
	a1 c;
	for(int q=1;q<=1201;q++)
	{
		c.x[q]=a.x[q]-b.x[q];
	}
	for(int q=1;q<=1201;q++)
	{
		if(c.x[q]<0)
		{
			c.x[q+1]--;
			c.x[q]+=10;
		}
	}
	return c;
}
void read()//读入
{
	string a;
	cin>>a;
	for(int q=1;q<=a.size();q++)z.x[q]=y.x[q]=x.x[q]=a[a.size()-q]-'0';
}
void print(a1 a)//高精输出
{
	int p=1021;
	while(a.x[p]==0)p--;//去除前导零
	for(int q=p;q>=1;q--)cout<<a.x[q];
}
int bi(a1 a,a1 b)
{
	for(int q=1021;q>=1;q--)
	{
		if(a.x[q]>b.x[q])return 2;
		if(a.x[q]<b.x[q])return 1;
	}
	return 0;
}
int main()
{
    read();
    int p=1201,l=0,k=0;
    while(z.x[p]==0)p--;
    for(int q=p-1;q>=1;q--)
    {
    	if(z.x[q]%2==z.x[q+1]%2)
    	{
    		if(z.x[q]!=0&&k!=1)
    		{
			    k=1;
    			x.x[q]-=1;
    			for(int w=q-1;w>=1;w--)
    		    {
    			    if(x.x[w+1]%2==0)
    			    {
    				    x.x[w]=9;
				    }
				    else x.x[w]=8;
			    }
			}
			else if(z.x[q]==0&&k!=1)//为0时特殊处理
    		{
			    k=1;
			    int l=q+1;
			    while(x.x[l]==0)l++;
			    x.x[l]-=1;
			    for(int w=l-1;w>=q;w--)x.x[w]=9;
//    			x.x[q]=9;
    			for(int w=q-1;w>=1;w--)
    		    {
    			    if(x.x[w+1]%2==0)
    			    {
    				    x.x[w]=9;
				    }
				    else x.x[w]=8;
			    }
			}
    		if(z.x[q]!=9&&l!=2)
    		{
			    l=2;
    			y.x[q]+=1;
    			for(int w=q-1;w>=1;w--)
    		    {
    			    if(y.x[w+1]%2==0)
    			    {
    				    y.x[w]=1;
				    }
				    else y.x[w]=0;
			    }
			}
			else if(z.x[q]==9&&l!=2)//为9时特殊处理
			{
				l=2;
				y.x[q+1]+=1;
				y.x[q]=0;
				for(int w=q;w>=1;w--)
    		    {
    			    if(y.x[w+1]%2==0)
    			    {
    				    y.x[w]=1;
				    }
				    else y.x[w]=0;
			    }
			}
		}
		if(l==2&&k==1)break;
	}
	for(int q=p-1;q>=1;q--)//最后再扫一边处理进位，借位。
	{
		if(y.x[q]%2==y.x[q+1]%2)
		{
			y.x[q]--;
			for(int w=q;w>=1;w--)
			{
				if(y.x[w+1]%2==0)
    			{
    			  y.x[w]=1;
			    }
				else y.x[w]=0;
			}
			break;
		}
	}
	for(int q=p-1;q>=1;q--)
	{
		if(x.x[q]%2==x.x[q+1]%2)
		{
			x.x[q]++;
			for(int w=q;w>=1;w--)
			{
				if(x.x[w+1]%2==0)
    			{
    			  x.x[w]=9;
			    }
				else x.x[w]=8;
			}
			break;
		}
	}
	a1 x1=z-x,y1=y-z;
//	print(x1);
	if(bi(x1,y1)==1)print(x);
	else if(bi(x1,y1)==2)print(y);
	else if(bi(x,y)==0)print(x);
	else 
	{
		print(x);
		cout<<" ";
		print(y);
	}
//	cout<<endl;print(x);
//	cout<<endl;print(y);
	return 0;
}
```



---

## 作者：peppaking8 (赞：3)

## 题意

给定正整数 $n(n\le 10^{1000})$。求与 $n$ 最相近的数，满足其相邻数位的奇偶性都不相同。

下面给出两种想法，时间复杂度都是 $O(\log_{10}n)$ 的。

## 解法 1

分为两个部分：求比 $n$ 大的最小满足条件的数；求比 $n$ 小的最大满足条件的数。这两个部分求法非常类似。

- 求 $\ge n$ 的最小满足条件的数 $P$

首先，如果给定位数 $k$，最小的数是多少呢？显然是 $10101...$ 交替排列构成的数。这告诉我们，可以从 $n$ 的高位向后依次构造，如果发现 $P$ 的这一位已经和 $n$ 不相同，那么剩下的部分直接用 $0$ 和 $1$ 交替构造即可。

对于每一位，$P$ 的这一位与 $n$ 不同，可能是如下原因：

1. $n$ 的这一位和上一位已经奇偶性相同；

2. 如果 $P$ 的这一位和 $n$ 相同，那么最大的 $P$ 会比 $n$ 小。

第 1 条很好理解，第 2 条是什么意思呢？举一个例子：$n=5899$，发现如果 $P$ 的前两位是 $58$，那么最大只能是 $5898$ 了，比 $n$ 要小。所以 $P$ 的第二位不能与 $n$ 相同。

如果发现不同的位 $i$，这时我们要把 $P$ 的这一位定为 $n$ 的这一位 $+1$ 或 $+2$（以满足奇偶交替的要求），剩下的位 $01$ 交替构造，然后就做完了。为什么此时一定可以呢？因为我们已经知道 $i-1$ 位是可以相同的，所以一定有更大的解。

- 求 $\le n$ 的最大满足条件的数 $P$

同理讨论，只不过需要知道最大的构造是 $8$ 和 $9$ 的交替。

## 解法 2

下面只说求 $\ge n$ 时的情况。

我们不去讨论上述第一种解法的判定这位不同的第二种情况，只判断更容易判断的第一种情况。如果发现 $n$ 的某个相邻位 $x,x+1$ 的奇偶性相同，那么此时一定需要将其 $+1$ 进位。但进位后就对了吗？来看下面的例子：

$58989899$

这时，进位后：

$58989900$

发现仍然存在两个相邻的奇偶性相同的情况！所以进位的时候有两个判定依据：

1. 这一位已经达到 $10$，应该进位；
2. 这一位是 $9$，但是前一位是奇数。

所以说，按照这种方式，进位后应为：

$60000000$

这时再次从高位到低位遍历整个数，发现奇偶性相同直接 $+1$，然后后几位 $01$ 交替构造即可。下面的代码就是用的这种方式。

## 注意

需要特判 $n$ 本来即为满足要求的数的情况。但是题目中没有，所以代码中没能体现。并且实现起来极其容易。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
char s[N];
int n;
int a[N],L[N],R[N],lenL,lenR;
int chaL[N],chaR[N];
int main(){
	scanf("%s",s);
	n=strlen(s);
	for(int i=0;i<n;i++) a[n-i]=s[i]-'0';//char转变int
	R[n]=a[n];//求解第一种
	for(int i=n-1;i>=1;i--){
		if((a[i]-a[i+1])&1){//如果奇偶性不同，跳过
			R[i]=a[i];
			continue;
		}
		if(a[i]!=9){//如果相同且该位不为9，直接+1然后后位赋值
			R[i]=a[i]+1;
			for(int j=i-1;j>=1;j--){
				if(R[j+1]&1) R[j]=0;
				else R[j]=1;
			}
			break;
		}
		else{//如果是9，根据上述两种判定进位
			R[i]=10;int qwq=i;
			while(R[qwq]==10 || (R[qwq]==9 && qwq<n && R[qwq+1]%2)) 
            			R[qwq]=0,R[qwq+1]++,qwq++;//进位步骤
			for(int j=min(qwq,n-1);j>=i;j--){//再次遍历
				if((R[j]-R[j+1])&1) continue;
				R[j]++;
				for(int l=j-1;l>=1;l--){
					if(R[l+1]&1) R[l]=0;
					else R[l]=1;
				}
				break;
			}
			break;
		}
	}
	if(R[n+1]) lenR=n+1;
	else lenR=n;
	L[n]=a[n];//求解第二种，与上面类似
	for(int i=n-1;i>=1;i--){
		if((a[i]-a[i+1])&1){
			L[i]=a[i];
			continue;
		}
		if(a[i]){
			L[i]=a[i]-1;
			for(int j=i-1;j>=1;j--){
				if(L[j+1]&1) L[j]=8;
				else L[j]=9;
			}
			break;
		}
		else{
			L[i]=-1;int qwq=i;
			while(L[qwq]==-1 || (L[qwq]==0 && qwq<n && L[qwq+1]%2==0)) L[qwq]=9,L[qwq+1]--,qwq++;
			for(int j=min(qwq,n-1);j>=i;j--){
				if((L[j]-L[j+1])&1) continue;
				L[j]--;
				for(int l=j-1;l>=1;l--){
					if(L[l+1]&1) L[l]=8;
					else L[l]=9;
				}
				break;
			}
			break;
		}
	}
	if(L[n+1]) lenL=n+1;
	else lenL=n;
	for(int i=1;i<=n+1;i++){
		chaL[i]+=a[i]-L[i];
		chaR[i]+=R[i]-a[i];
		if(chaL[i]<0) chaL[i]+=10,chaL[i+1]--;
		if(chaR[i]<0) chaR[i]+=10,chaR[i+1]--;
	}
	int i;
	for(i=n+1;i>=1;i--){
		if(chaL[i]<chaR[i]){
			for(int j=lenL;j>=1;j--) cout<<L[j];
			cout<<endl;
			break;
		}
		if(chaL[i]>chaR[i]){
			for(int j=lenR;j>=1;j--) cout<<R[j];
			cout<<endl;
			break;
		}
	}
	if(!i){
		for(int j=lenL;j>=1;j--) cout<<L[j];cout<<" ";
		for(int j=lenR;j>=1;j--) cout<<R[j];
	}
}
```

---

## 作者：max0810 (赞：2)

从前往后先扫一遍，找到第一个不满足条件的数（即第一个与前一个数奇偶相同的数）。然后分为两种情况处理。

1.将这个数位加 1 ，则后面数的肯定越小越好，要么是 $101010…\ $，要么是 $010101…\ $。

2.将这个数位减1，则后面的肯定越大越好，要么是 $989898…\ $，要么是 $898989…\ $。

然后比较这两个数与原数的差就行了。

要注意的是第一个不满足条件的数如果是 0 就只能用第一种办法处理，如果是 9 就只能用第二种办法处理。

具体请看代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
string n;
int x;
bool ma(string a,string b)//比较a和b的大小，相当于a>b 
{
	if(a.size() == b.size())
		return a == max(a,b)&&b != max(a,b);
	else return a.size()>b.size();
}
string f1()//第一种情况 
{
	string a = n;
	a[x]++;
	for(int i = x+1;i < a.size();i++)
		a[i] = 1-a[i-1]%2+'0';
	return a;
}
string f2()//第二种情况 
{
	string a = n;
	a[x]--;
	for(int i = x+1;i < a.size();i++)
		a[i] = 9-a[i-1]%2+'0';
	return a;
}
string jian(string a,string b)//高精减法 
{
	string c = a;
	int g = a.size(),h = b.size();
	for(int i = 1;i <= h;i++)
	{
		if(a[g-i]>=b[h-i])
			c[g-i] = a[g-i]-b[h-i]+'0';
		else
		{
			c[g-i] = a[g-i]+10-b[h-i]+'0';
			int j = g-i-1;
			for(;a[j]=='0';j--)
				a[j] = '9';
			a[j]--;
		}
	}
	c = a.substr(0,g-h)+c.substr(g-h);
	int f = 0;
	while(c[f] == '0')f++;
	c = c.substr(f);
	return c;
}
int main()
{
//	freopen("zgodan.in","r",stdin);
//	freopen("zgodan.out","w",stdout);
	cin >> n;
	for(int i = 1;i < n.size();i++)
		if(n[i]%2==n[i-1]%2)
		{x = i;break;}
	//找第一个不满足条件的数
	if(n[x] == '0')cout << f1();//0用第一种办法 
	else if(n[x] == '9')cout << f2();//9用第二种办法 
	else
	{
		string a = f1(),b = f2();
		string c = jian(a,n),d = jian(n,b);
		if(ma(c,d))cout << b;//比较两个数的差 
		else if(ma(d,c))cout << a;
		else cout << b << ' ' << a;
	}
	return 0;
}
```


---

## 作者：船酱魔王 (赞：1)

# P7662 [COCI2014-2015#5] ZGODAN 题解

## 题意回顾

我们定义帅气数为满足任意两个相邻的数位奇偶性不同的正整数。给定 $ n $，求与 $ n $ 最接近的帅气数。

$ 1 \le n \le 10^{1000} $。

## 分析

我们发现如果要让数最接近 $ n $，可以先贪心的先满足高位与 $ n $ 的高位相同。

我们定义 $ w $ 为 $ n $ 的前 $ w $ 位为帅气数，当 $ w+1 $ 位存在时（即 $ w < |n| $，可以这样构造：

* 将 $ w+1 $ 位减一以构造小于 $ n $ 的最大数，后面的位已经不可能使原数不小于 $ n $，所以帅气数最大即可，故按照此位奇偶性确定接下来放 ```89``` 交替还是 ```98``` 交替。

* 将 $ w+1 $ 位加一以构造大于 $ n $ 的最小数，后面的位已经不可能使原数不大于 $ n $，所以帅气数最小即可，故按照此位奇偶性确定接下来放 ```01``` 交替还是 ```10``` 交替。

否则直接输出 $ n $ 即可。

## AC 代码


```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
using namespace std;
const int N = 1005;
string s;
struct node {
    int len;
    int a[N];
} n, n1, n2, zero;
node dis1, dis2;
node operator-(node p1, node p2) {
    node res = zero;
    res.len = p1.len;
    for(int i = 1; i <= res.len; i++) {
        res.a[i] = p1.a[i] - p2.a[i];
    }
    for(int i = 1; i <= res.len; i++) {
        if(res.a[i] < 0) {
            res.a[i] += 10;
            res.a[i + 1]--;
        }
    }
    while(res.a[res.len] == 0) {
        res.len--;
    }
    return res;
}
bool operator<(node p1, node p2) {
    if(p1.len != p2.len) {
        return p1.len < p2.len;
    }
    for(int i = p1.len; i >= 1; i--) {
        if(p1.a[i] != p2.a[i]) {
            return p1.a[i] < p2.a[i];
        }
    }
    return false;
}
void out(node p1) {
    for(int i = p1.len; i >= 1; i--) {
        cout << p1.a[i];
    }
}
int main() {
    //freopen("number.in", "r", stdin);
    //freopen("number.out", "w", stdout);
    cin >> s;
    n.len = s.size();
    for(int i = 1; i <= s.size(); i++) {
        n.a[i] = s[s.size() - i] - '0';
    }
    int w = 1;
    for(int i = n.len; i >= 2; i--) {
        if(n.a[i] % 2 == n.a[i - 1] % 2) {
            w = i;
            break;
        }
    }
    if(w == 1) {
        cout << s << endl;
        return 0;
    }
    n1.len = n.len;
    n2.len = n.len;
    for(int i = w; i <= n.len; i++) {
        n1.a[i] = n.a[i];
        n2.a[i] = n.a[i];
    }
    n1.a[w - 1] = n.a[w - 1] - 1;
    n2.a[w - 1] = n.a[w - 1] + 1;
    for(int i = w - 2; i >= 1; i--) {
        if(n1.a[i + 1] % 2 == 0) {
            n1.a[i] = 9;
            n2.a[i] = 1;
        } else {
            n1.a[i] = 8;
            n2.a[i] = 0;
        }
    }
    if(n1.a[w - 1] < 0) {
        out(n2);
    } else if(n2.a[w - 1] > 9) {
        out(n1);
    } else {
        dis1 = n - n1;
        dis2 = n2 - n;
        if(dis1 < dis2) {
            out(n1);
        } else if(dis2 < dis1) {
            out(n2);
        } else {
            out(n1);
            cout << " ";
            out(n2);
        }
    }
    cout << endl;
    return 0;
}
```

## 总结与评价

校内提高模拟赛的一道 T1，一道小清新题，考察了对于十进制下按位贪心的理解和基础构造。

---

## 作者：wangyihao0411 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7662)

### 前言

[博客戳这里](https://www.luogu.com.cn/article/7qerlv6l)  
我只想的说，要用高精度（好像人人都就能看见吧）。  
[高精不会的点这里](http://39.99.183.126:8888/blog/2/6476bdf2e484fc1f9d301fef#1685503474385)

### 思路

其实很简单：

* 首先由于是奇偶数是正好隔一个，所以只要形式为（$2$ 进制位）$010101\dots$ 或 $101010\dots$ 即可。

* 由于要找最近的数，所以查找比 $n$ 大的数和比 $n$ 小的数。之后只要比较得出两数的大小即可，输出大的那个；如果两数一样大，那么先输出比 $n$ 小的数再输出比 $n$ 大的数。

### 代码

思路大家都看懂了吧，~~看不懂的话我也没办法了~~。  
在这里附上 $AC$ 代码，上面说的很详细了，应该不需要注释了~~吧~~。

```
#include <iostream>
#include <cstdio>
using namespace std;
string n;
int x;
bool ma(string a,string b)
{
	if(a.size()==b.size())
		return a==max(a,b)&&b!=max(a,b);
	else
		return a.size()>b.size();
}
string f1()
{
	string a=n;
	a[x]++;
	for(int i=x+1;i<a.size();i++)
		a[i]=1-a[i-1]%2+'0';
	return a;
}
string f2()
{
	string a=n;
	a[x]--;
	for(int i=x+1;i<a.size();i++)
		a[i]=9-a[i-1]%2+'0';
	return a;
}
string jian(string a,string b)
{
	string c=a;
	int g=a.size(),h=b.size();
	for(int i=1;i<=h;i++)
	{
		if(a[g-i]>=b[h-i])
			c[g-i]=a[g-i]-b[h-i]+'0';
		else
		{
			c[g-i]=a[g-i]+10-b[h-i]+'0';
			int j=g-i-1;
			for(;a[j]=='0';j--)
				a[j]='9';
			a[j]--;
		}
	}
	c=a.substr(0,g-h)+c.substr(g-h);
	int f=0;
	while(c[f]=='0')f++;
	c=c.substr(f);
	return c;
}
int main()
{
	cin >> n;
	for(int i = 1;i < n.size();i++)
		if(n[i]%2==n[i-1]%2)
		{
			x=i;
			break;
		}
	if(n[x] == '0')
		cout << f1();
	else if(n[x] == '9')
		cout << f2();
	else
	{
		string a=f1(),b=f2();
		string c=jian(a,n),d=jian(n,b);
		if(ma(c,d))
			cout << b;
		else if(ma(d,c))
			cout << a;
		else cout << b << " " << a;
	}
	return 0;
}
```

最后，感谢大家的耐心观看。

------------

### update

 $2024/5/31$：发布该题解

---


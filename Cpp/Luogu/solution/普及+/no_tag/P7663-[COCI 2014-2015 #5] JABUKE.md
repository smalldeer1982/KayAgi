# [COCI 2014/2015 #5] JABUKE

## 题目描述

给你一个 $n \times m$ 的矩阵，其中苹果树用 `x` 表示，空地用 `.` 表示。

有 $g$ 年，每年都会从天而降一个苹果，落在坐标 $(x_i,y_i)$ 上，要求出**这个苹果离最近一棵苹果树的距离的平方**。当然，一年后这个苹果会长成新的一颗苹果树，并参与一年后落下的那个苹果的计算。

## 说明/提示

对于 $30\%$ 的数据，$1 \leq g \leq 500$。

对于 $100\%$ 的数据，$1\leq n,m \leq 500,1 \leq g \leq 10^5$，保证初始矩阵至少包含一棵苹果树。

距离计算公式：$d((x_1,y_1),(x_2,y_2))=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。

## 样例 #1

### 输入

```
3 3
x..
...
...
3
1 3
1 1
3 2```

### 输出

```
4
0
5```

## 样例 #2

### 输入

```
5 5
..x..
....x
.....
.....
.....
4
3 1
5 3
4 5
3 5```

### 输出

```
8
8
4
1```

# 题解

## 作者：max0810 (赞：7)

思路还是比较简单的，完全没有蓝题的难度。

考虑bfs，每遇到一个点就往外广度搜索，去找最近的点。

时间看起来比较多，但到了后面有很多树，每个点的时间是非常快的，再加点优化，时间其实差不多是O(g)的。

具体请见代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
struct node
{
	int x,y;
}now,nex;
const int dir[4][2] = {0,-1,-1,0,0,1,1,0};
char a[505][505];
int r,s,g;
bool vis[505][505];
int f(int x1,int y1,int x2,int y2)//算距离 
{
	return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
}
int bfs(int x,int y)//bfs模板不用多讲吧 
{
	memset(vis,0,sizeof vis);
	queue<node> que;
	int ans = 0x7ffffff;
	now.x = x;now.y = y;
	que.push(now);
	while(!que.empty())
	{
		now = que.front();
		que.pop();
		if(f(now.x,now.y,x,y)>ans)continue;//比最小值大就没必要枚举下去了（优化） 
		for(int i = 0;i < 4;i++)
		{
			int xx = now.x+dir[i][0];
			int yy = now.y+dir[i][1];
			if(xx<1||xx>r||yy<1||yy>s||vis[xx][yy])continue;
			vis[xx][yy] = 1;
			int s = f(xx,yy,x,y);
			if(s >= ans)continue;//同上 
			if(a[xx][yy] == 'x')ans = s;//注意只有是当前位置有苹果树才更新答案 
			nex.x = xx;nex.y = yy;
			que.push(nex);
		}
	}
	return ans;
}
int main()
{
//	freopen("jabuke.in","r",stdin);
//	freopen("jabuke.out","w",stdout);
	cin >> r >> s;
	for(int i = 1;i <= r;i++)
		for(int j = 1;j <= s;j++)
			cin >> a[i][j];
	cin >> g;
	while(g--)
	{
		int x,y;
		cin >> x >> y;
		if(a[x][y] == 'x')//如果这个点是x就直接输出0（优化） 
		{
			cout << "0\n";
			continue;
		}
		cout << bfs(x,y) << endl;
		a[x][y] = 'x';//一定要记得 
	}
	return 0;
}
```


---

## 作者：封禁用户 (赞：3)

萌新写题解，欢迎 Hack！

我们可以使用二维前缀和（或称为二维累积和）来快速计算每个苹果落点周围苹果树的数量，并使用曼哈顿距离的平方来近似欧几里得距离的平方。由于题目只要求距离的平方，我们可以避免计算平方根，因为平方根是一个单调递增函数，不会影响距离的比较。然而，由于曼哈顿距离的平方通常小于或等于欧几里得距离的平方，我们可能需要调整曼哈顿距离的平方以匹配或超过实际的最小欧几里得距离的平方。这通常意味着我们需要将曼哈顿距离的平方乘以一个常数（比如 $2$，因为最大可能的方向差异是 $45$ 度角，此时曼哈顿距离是欧几里得距离的 $\sqrt 2$ 倍，平方后就是 $2$ 倍）。但是在这个特定问题中，由于我们只需要找出最小的距离平方，并且题目保证至少有一颗苹果树，我们可以简单地使用曼哈顿距离的平方作为欧几里得距离平方的近似。这是因为在曼哈顿距离最小的方向上，曼哈顿距离的平方将等于欧几里得距离的平方。
1. 遍历初始矩阵，对于每个苹果树的位置，更新其曼哈顿距离平方的二维前缀和。
2. 对于每个新的苹果落点，查询其曼哈顿距离平方的二维前缀和，找出最小的曼哈顿距离平方。
3. 输出该最小曼哈顿距离平方作为答案。

我们发现时间复杂度为 $\mathcal O(nmg)$，再交，直接 TLE，也就是说 $\mathcal O(nmg)$ 的复杂度会超时。

那么考虑优化，因为有 $g$ 次输入，于是我们只要跑 $g$ 遍 BFS 即可，注意我们在 BFS 的过程中要进行剪枝优化，不然必爆，这么一来，时间复杂度为 $\mathcal O(g)$。

~~然后我们就拿捏了水题。~~

完结撒花！

---

## 作者：GuuGuu (赞：3)

# Foreword

~~莫名其妙拿到了最优解，调了调参数还跑的飞快。~~

这么模板的题居然没人发 KD-Tree 的做法，这就来发一篇 KD-Tree 的题解。


# Problem

题目说得很清楚了，每次给出一个点，询问距离这个点的最近点。

并且每次询问后还要插入这个点。

# Solution

一道 KD-Tree 模板题。

询问最近点对直接可以考虑 KD-Tree 乱搞，详细来说可以见[P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)。

但是这里要动态加入点，怎么办呢？

其实这也是 KD-Tree 的常用套路，对于 KD-Tree 动态加点，其实我们发现 KD-Tree 如果直接暴力插入，复杂度并不优，会破坏掉原本的形态，从而使得效率降低。

像这种只能一次构建，多次插入后会破坏时间复杂度的数据结构，其实大多可以利用替罪羊树的思想，通过“暴力重构”来维持原本不错的结构，同时重构的复杂度也不是很高。

至此，询问平面内距离一个点最近的点的距离，以及动态加入一个点两个操作我们都可以维护了，问题得到解决。

时间复杂度是 $O($ 玄学 $)$ 的（也就是最坏 $O(n)$ 单次查询），因为询问操作是类似启发式搜索一样的复杂度，无法估计，但是从一般题目的表现来说实际运行效率不错（大致可以从那道加强版来估计这个操作的效率）。


# Code

笔者直接把模板给拷过来了。

这道题其实不重构也可以，因为反正询问的复杂度都是不太正确的。

但是似乎重构了要更快一点，这里平衡因子取到 0.93 效率优秀。


```cpp
#include <bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x) {
    x = 0;
    char ch = getchar();
    bool f = false;

    while (!isdigit(ch)) {
        if (ch == '-') {
            f = true;
        }

        ch = getchar();
    }

    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }

    x = f ? -x : x;
    return ;
}
template <typename T>
inline void write(T x) {
    if (x < 0)
        putchar('-'), x = -x;

    if (x > 9)
        write(x / 10);

    putchar(x % 10 ^ 48);
    return ;
}

const int N = 2e5 + 5, INF = 1e9 + 7;
const double alpha = 0.93;// KD-Tree 平衡因子 

namespace KDTree {
	
int root, cnt, cmptype;

int rub[N], Top, cur;

struct point {
    int d[2], id;
} p[N];

struct node {
int siz;
int Min[2], Max[2];
int lc, rc;
point tp;
bool operator < (const node &k1)const {return tp.d[cmptype] < k1.tp.d[cmptype];}
#define d(x,i) t[x].tp.d[i]
#define Min(x,i) t[x].Min[i]
#define Max(x,i) t[x].Max[i]
#define lc(x) t[x].lc
#define rc(x) t[x].rc
#define siz(x) t[x].siz
#define val(x) t[x].tp.val
#define tp(x) t[x].tp
} a[N], t[N];
inline void Init() {
    root = 0;
    Max(root, 0) = Max(root, 1) = -INF, Min(root, 0) = Min(root, 1) = INF;
    return ;
}
inline int NewNode() {
    if (Top)
        return rub[Top--];
    else
        return ++cur;
}
inline void Pushup(int x) {
    siz(x) = 1;

    if (lc(x))
        siz(x) += siz(lc(x));

    if (rc(x))
        siz(x) += siz(rc(x));

    for (int i = 0; i < 2; i++)
        Min(x, i) = Max(x, i) = d(x, i);

    for (int i = 0; i < 2; i++) {
        if (lc(x)) {
            Min(x, i) = min(Min(x, i), Min(lc(x), i)),
            Max(x, i) = max(Max(x, i), Max(lc(x), i));
        }

        if (rc(x)) {
            Min(x, i) = min(Min(x, i), Min(rc(x), i)),
            Max(x, i) = max(Max(x, i), Max(rc(x), i));
        }
    }

    return ;
}
inline bool cmp(point x, point y) {
    return x.d[cmptype] < y.d[cmptype];
}
void Build(int &x, int l, int r, int type) {
    if (l > r)
        return x = 0, void();

    int mid = (l + r) >> 1;
    cmptype = type, x = NewNode();
    nth_element(p + l, p + mid, p + r + 1, cmp), tp(x) = p[mid];
    Build(lc(x), l, mid - 1, type ^ 1);
    Build(rc(x), mid + 1, r, type ^ 1);
    Pushup(x);
    return ;
}
void dfs(int x, int num) {
    if (lc(x))
        dfs(lc(x), num);

    p[siz(lc(x)) + num + 1] = tp(x), rub[++Top] = x;

    if (rc(x))
        dfs(rc(x), num + siz(lc(x)) + 1);

    return ;
}
inline bool Balanced(int x) {
    return (double)max(siz(lc(x)), siz(rc(x))) <= (double)siz(x) * alpha;
}
void Rebuild(int &x, int now) {
    dfs(x, 0);
    Build(x, 1, siz(x), now);
    return ;
}
void Modify(int &x, point v, int now) {
    if (!x)
        return x = NewNode(), lc(x) = rc(x) = 0, tp(x) = v, Pushup(x), void();

    if (!now)
        Modify(v.d[0] <= d(x, 0) ? lc(x) : rc(x), v, now ^ 1);
    else
        Modify(v.d[1] <= d(x, 1) ? lc(x) : rc(x), v, now ^ 1);

    Pushup(x);

    if (!Balanced(x))
        Rebuild(x, now);

    return ;
}
inline int Dis(node k1, node k2) {
    return abs(k1.tp.d[0] - k2.tp.d[0]) + abs(k1.tp.d[1] - k2.tp.d[1]);
}
node T, Q;
int Ans;
int GuessMin(int x) {
    if (x == 0)
        return INF;

    int res = 0;

    for (int i = 0; i < 2; i++) {
        res += max(Min(x, i) - T.tp.d[i], 0),
               res += max(T.tp.d[i] - Max(x, i), 0);
    }

    return res;
}
inline int Distance(node x, node y) {
    return (x.tp.d[0] - y.tp.d[0]) * (x.tp.d[0] - y.tp.d[0]) + (x.tp.d[1] - y.tp.d[1]) * (x.tp.d[1] - y.tp.d[1]);
}
inline int KGuessMin(int x) {
    int res = 0;

    if (!x)
        return INT_MAX;

    if (Min(x, 0) > Q.tp.d[0])
        res += (Min(x, 0) - Q.tp.d[0]) * (Min(x, 0) - Q.tp.d[0]);

    if (Max(x, 0) < Q.tp.d[0])
        res += (Max(x, 0) - Q.tp.d[0]) * (Max(x, 0) - Q.tp.d[0]);

    if (Min(x, 1) > Q.tp.d[1])
        res += (Min(x, 1) - Q.tp.d[1]) * (Min(x, 1) - Q.tp.d[1]);

    if (Max(x, 1) < Q.tp.d[1])
        res += (Max(x, 1) - Q.tp.d[1]) * (Max(x, 1) - Q.tp.d[1]);

    return res;
}
struct Node {
    int val;
    int id;
    inline bool operator < (const Node &B)const {
        return (val == B.val) ? (id > B.id) : (val < B.val);
    }
    inline bool operator > (const Node &B)const {
        return (val == B.val) ? (id < B.id) : (val > B.val);
    }
};
priority_queue<Node>q;
void KQueryMin(int x, int Now) {
    if (!x)
        return;

    int now = Distance(Q, t[x]), dl = KGuessMin(lc(x)), dr = KGuessMin(rc(x));

    if (now < Ans && t[x].tp.id != Now)
        Ans = now;

    if (dl < dr) {
        if (dl < Ans)
            KQueryMin(lc(x), Now);

        if (dr < Ans)
            KQueryMin(rc(x), Now);
    } else {
        if (dr < Ans)
            KQueryMin(rc(x), Now);

        if (dl < Ans)
            KQueryMin(lc(x), Now);
    }

    return ;
}
void FindKthMin(int x, int y, int k, int qid) {
    Q.tp.d[0] = x, Q.tp.d[1] = y;
    KQueryMin(root, qid);
    return ;
}
};
using namespace KDTree;
int n, k, m, g, pos[N];
char str[N];
signed main() {
    read(n);
    read(m);
    Init();

    for (int i = 1; i <= n; i++) {
        scanf("%s", str + 1);

        for (int j = 1; j <= m; j++)
            if (str[j] == 'x')
                p[++cnt].d[0] = i, p[cnt].d[1] = j, p[cnt].id = cnt;
    }

    read(g);
    Build(root, 1, cnt, 0);
    Ans = INT_MAX;

    for (int i = 1 + cnt, x, y; i <= g + cnt; i++) {
        read(x), read(y);
        Ans = INT_MAX;
        FindKthMin(x, y, 1, i);
        write(Ans), putchar('\n');
        Modify(root, (point) {
            x, y, 1
        }, 0);
    }

    return 0;
}
```



---

## 作者：UperFicial (赞：3)

题解一血，纪念一下。

考虑设：

- $up[i,j]$ 为点 $(i,j)$ 正上方最近的苹果树的行号。

- $low[i,j]$ 为点 $(i,j)$ 正下方下面最近的苹果树的行号。

那我们在询问 $(x,y)$ 最近点的距离时，我们考虑在枚举第 $y$ 行的所有点 $j$，则答案为 $\min_{j=1}^m(\operatorname{dis}[(up[x,j],y),(x,y)],\operatorname{dis}([low[x,j],y),(x,y)])$

再考虑预处理 $up$ 和 $low$，我们可以枚举每一列，对于第 $j$ 列，我们从上到下更新 $up$，从下到上更新 $low$，至于怎么更新，我们记一个上次的苹果树的行号，遇到一个苹果树立刻更新，对于每个 $up$ 和 $low$ 都更新为标记的值。

别忘，每询问一次，也需要更新加入的这个点所在的这一列的所有点的 $up$ 和 $down$ 值。

然后一道水蓝就做完了。

---

## 作者：Xssion37_XY (赞：2)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P7663)

[更好的阅读体验](https://www.luogu.com.cn/blog/778802/solution-p7663)

### 题目大意

给你一个 $n \times m$ 的矩阵，其中苹果树用 `x` 表示，空地用 `.` 表示。

每年都会从天而降一个苹果，落在 $(x_i,y_i)$ 上。

求出这个苹果离最近一棵苹果树的距离的**平方**。

这道题特别要注意的是，一年后这个苹果掉下来的地方会长出一颗新的苹果树。

也就是说，苹果树的数量每年都会增加。

### 实际分析

这道题可以用 bfs，但是我觉得还有其他的类似贪心的做法。

~~反正我是不会。~~

因为苹果树到后面会越来越多，所以bfs配合剪枝跑的挺快。

那怎么剪枝呢？


```
if (distance(now.x, now.y, x, y) > sum) { //剪枝-超过了答案就跳过
	continue;
}
```

当我们此时的距离已经超过了现有的距离，那么就没有必要再搜索下去了，直接跳到下一棵树即可。

这个是很好理解的。

其他的细节只需要注意每次清空以及标记苹果树长大的地方就可以了。

### 代码部分

```
#include <iostream>
#include <cstring>
#include <queue>
#define answer "QwQ" == "QwQ"
using namespace std;
const int MAXX = 501;
const int MAXX_ = 1e9;
char map[MAXX][MAXX];
bool vis[MAXX][MAXX];
int dx[4] = {0, -1, 0, 1};//偏移数组
int dy[4] = {-1, 0, 1, 0};
int mx, my, sum;

struct node {
	int x, y;
} now, noww;

int distance(int x1, int y1, int x2, int y2) {//距离计算公式
	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

queue <node> Q;

int bfs(int x, int y) { //板子
	sum = MAXX_;
	memset(vis, 0, sizeof vis); //记得每次清空
	now.x = x;
	now.y = y;
	Q.push(now);
	while (!Q.empty()) {
		now = Q.front();
		Q.pop();
		if (distance(now.x, now.y, x, y) > sum) { //剪枝-超过了答案就跳过
			continue;
		}
		for (int i = 0; i < 4; i++) {
			int new_x = now.x + dx[i];
			int new_y = now.y + dy[i];
			if (new_x >= 1 and new_x <= mx and new_y >= 1 and new_y <= my and vis[new_x][new_y] == 0) { //没有越界且没有访问过
				vis[new_x][new_y] = 1;//设为访问过
				int dis = distance(new_x, new_y, x, y); //计算距离
				if (dis >= sum) {
					continue;
				}
				if (map[new_x][new_y] == 'x') { //这个点是苹果才更新答案
					sum = dis;
				}
				noww.x = new_x;
				noww.y = new_y;
				Q.push(noww);
			}
		}
	}
	return sum;
}
int main() {
	cin >> mx >> my;
	for (int i = 1; i <= mx; i ++) {
		for (int j = 1; j <= my; j ++) {
			cin >> map[i][j];
		}
	}
	int T;
	cin >> T;
	while (T-- and answer) {
		int x1, y1;
		cin >> x1 >> y1;
		if (map[x1][y1] == 'x') { //这个点有苹果直接输出0
			cout << 0 << '\n';
			map[x1][y1] = 'x';//长成了新的苹果树
		} else {
			cout << bfs(x1, y1) << '\n';
			map[x1][y1] = 'x';//长成了新的苹果树
		}
	}
	return 0;
}
```

完结撒花！

[AC记录](https://www.luogu.com.cn/record/list?pid=P7663&user=778802)

---

## 作者：Listedzero (赞：1)

### 题目分析

首先你需要意识到要用广搜，于是你下意识写下模板：

```cpp
while(q.size()){
  auto t=q.front();q.pop();
  int a=t.first,b=t.second;
  if(tree[a][b]){
    cout<<(x-a)*(x-a)+(y-b)*(y-b)<<endl;
    return;
  }
  for(int i=0;i<4;i++){
    int u=dx[i]+a,v=dy[i]+b;
    if(!vis[u][v]&&u>=1&&u<=n&&v>=1&&v<=m){
      q.push({u,v});
      vis[u][v]=1;
    }
  }
}
```

提交后发现全错，于是你突然想到，由于这里是距离，不一定先出队且符合要求的就是最小值，应该记录最小值，于是你做出了如下修改：

```cpp
  if(tree[a][b]) 
    ans=min(ans,(x-a)*(x-a)+(y-b)*(y-b));
```

提交后发现思路没有问题了，但是会超时。你发现这样广搜会把整个图搜满，但是事实上并没有必要，你于是又思考如何类似深搜剪枝那样去优化。你发现，显然，当记录了当前最小值后，最优解一定也在以出发点为圆心，圆弧过当前最优值的圆里。超出范围的完全可以不用搜。故可以判断：

```cpp
  if((x-a)*(x-a)+(y-b)*(y-b)>ans)  
    continue;
```

### 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,g;
bool tree[510][510],vis[510][510];
int dx[10]={0,0,-1,1},dy[10]={1,-1,0,0};
void bfs(int x,int y){
  queue<pair<int,int> >q;
  memset(vis,0,sizeof vis);
  vis[x][y]=1;
  q.push({x,y});
  int ans=0x7fffffff;
  while(q.size()){
    auto t=q.front();q.pop();
    int a=t.first,b=t.second;
    if((x-a)*(x-a)+(y-b)*(y-b)>ans) continue;
    if(tree[a][b]) ans=min(ans,(x-a)*(x-a)+(y-b)*(y-b));
    for(int i=0;i<4;i++){
      int u=dx[i]+a,v=dy[i]+b;
      if(!vis[u][v]&&u>=1&&u<=n&&v>=1&&v<=m){
        q.push({u,v});
        vis[u][v]=1;
      }
    }
  }
  cout<<ans<<endl;
}
int main(){
  cin>>n>>m;
  char tmp; 
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
      cin>>tmp;
      if(tmp=='x') tree[i][j]=1;
    }
  cin>>g;
  for(int i=1;i<=g;i++){
    int x,y;cin>>x>>y;
    bfs(x,y);
    tree[x][y]=1;
  }
  return 0;
}
```

---

## 作者：_czy (赞：1)

## 思路

有很多题解讲的都是 bfs，我表示根本不理解，明明一个个循环也一样。

首先将每一个苹果树的位置加入一个数组，然后每次的苹果都遍历一遍数组，找最小值。

可是，看似一样的 $O(nmg)$，却过不了。因为我们少了优化！！！

## 优化

### 1：

显而易见的，可以开一个二维 bool 数组，先看当前位置有没有树。

---

### 2：

又显而易见的，可以先判断周围四个，只有他们的距离为 $1$。然后，在循环时判断答案是否为 $2$，如果等于 $2$，显然可以退出，因为这是最小的了。

---

**然后，你就发现，你拿下了一道水题**

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,g,x,y,ans,l;
char c;
bool mp[502][502];
pair<int,int>app[250003];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		getchar();
		for(int j=1;j<=m;j++){
			c=getchar();
			if(c=='x'){
				mp[i][j]=1;
				app[++l]={i,j};
			}
		}
	}
	scanf("%d",&g);
	while(g--){
		scanf("%d%d",&x,&y);
		if(mp[x][y]){
			printf("0\n");
			continue;
		}//1
		if(mp[x-1][y]||mp[x+1][y]||mp[x][y-1]||mp[x][y+1]){
			printf("1\n");
			mp[x][y]=1;
			app[++l]={x,y};
			continue;
		}//2
		ans=1e9;
		for(int i=1;i<=l&&ans>2;i++){//2
			int X=app[i].first,Y=app[i].second;
			ans=min((X-x)*(X-x)+(Y-y)*(Y-y),ans);
		}
		printf("%d\n",ans);
		mp[x][y]=1;
		app[++l]={x,y};
	}
}
```

---

## 作者：ydkxj (赞：1)

## 前言

可以的话尽量不要用 memset 进行重置，它会把整个数组都跑一遍，可能会超时，不要省事，用循环更新。~~惨痛教训~~

## 题意

每次给出一个点，询问距离这个点的最近点，再把这个点标为已知点。

## Solution

共有 $g$ 次输入，就跑 $g$ 次 BFS 即可。

注意剪枝优化。

## CODE

```cpp
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int a[505][505];
bool vis[505][505];
int dx[4]={0,-1,0,1};
int dy[4]={-1,0,1,0};
int n,m,g;
struct node {
	int x, y;
}n1,n2;
int find_far(int x1, int y1, int x2, int y2) {
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);           //计算距离。 
}
queue <node>q;
int bfs(int x, int y){ 
	int sum=2e9;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){          //真的少用点memset。 
			vis[i][j]=false;
		}
	}
	//memset(vis, 0, sizeof vis); 
	n1.x=x;
	n1.y=y;
	q.push(n1);
	while(!q.empty()){
		n1=q.front();
		q.pop();
		if(find_far(n1.x,n1.y,x,y)>sum){ 
			continue;
		}
		for(int i=0;i<4;i++) {
			int d1=n1.x+dx[i];
			int d2=n1.y+dy[i];
			if (d1>=1 && d1<=n && d2>=1 && d2<=m && vis[d1][d2]==0){
				vis[d1][d2] = 1;
				int dis=find_far(d1, d2, x, y); 
				if(dis>=sum){
					continue;
				}
				if(a[d1][d2]==1){ 
					sum=dis;
				}
				n2.x=d1;
				n2.y=d2;
				q.push(n2);
			}
		}
	}
	return sum;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);               //快读优化。 
	cin>>n>>m;
	char c;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='x')a[i][j]=1;
			else a[i][j]=0;
		}
	}
	cin>>g;
	int x1,y1;
	while(g--){
		cin>>x1>>y1;
		if(a[x1][y1]==1){
		cout<<0<<endl;
		continue;
		}
		cout<<bfs(x1,y1)<<endl;
		a[x1][y1]=1;
	}
	return 0;
}
```

谢谢观看，喵。

---

## 作者：DFM_O (赞：0)

## [P7663 题目](https://www.luogu.com.cn/problem/P7663)

### 解题思路
首先，对于任意的两个点 $(x_1,y_1)$ 和 $(x_2,y_2)$，他们距离的平方即为 $(x_1-x_2)^2+(y_1-y_2)^2$。

对于每一行，用向量有序地存储每棵苹果树的位置，每次询问用二分找出每行距离 $(x_i,y_i)$ 最近的苹果树，即每行距离第 $y_i$ 列最近的苹果树，取最小值即可。

修改时直接在存储第 $x_i$ 行的向量加入新的苹果树并排序即可，总时间复杂度 $O(gn\log n)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
vector<int> g[501];
bool a[501][501];
signed main()
{
    ios::sync_with_stdio(false);
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
		for(int j=1;j<=m;j++)
		{
			char ch;
			cin>>ch;
			if(ch=='x')
				g[i].push_back(j),a[i][j]=1;
		}
	}
	int q;
	cin>>q;
	while(q--)
	{
		int x,y,minz=1e9+1;
		cin>>x>>y;
		if(a[x][y]==1)
		{
			cout<<"0\n";
			continue;
		}
		for(int i=1;i<=n;i++)
		{
			int len=g[i].size();
			if(len==0)
				continue;
			if(y>g[i][len-1])
			{
				minz=min(minz,(i-x)*(i-x)+(g[i][len-1]-y)*(g[i][len-1]-y));
				continue;
			}
			int st=lower_bound(g[i].begin(),g[i].end(),y)-g[i].begin(),minn;
			if(st==0)
				minn=g[i][st]-y;
			else
				minn=min(g[i][st]-y,y-g[i][st-1]);
			minz=min(minz,(i-x)*(i-x)+minn*minn);
		}
		cout<<minz<<"\n";
		g[x].push_back(y);
		sort(g[x].begin(),g[x].end());
	}
    return 0;
}
```

---

## 作者：llqw (赞：0)

### 题目大意

在一个矩阵中有几个关键点，给你 $g$ 次询问，对于每次询问，求距离询问的这个点最近的那个点与其距离的平方，每次询问之后的这个点会变成一个关键点，并参与之后的计算。

### 思路

模板题。这题真的不难，简单的 BFS 就可以搞定 AC，暴力枚举可以拿 $40$ 分。

### 做法

#### 一　暴力枚举（$40$ 分）

很简单，暴力枚举每一个点，求最小值。直接贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long g;
char e[505][505];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>e[i][j];
		}
	}
	cin>>g;
	long long qn,qm;
	while(g--){
		cin>>qn>>qm;
		long long ans=10000000000000000;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(e[i][j]=='x'){
					ans=min(ans,(long long)(pow((qn-i),2)+pow((qm-j),2)));
				}
			}
		}
		cout<<ans<<'\n';
		e[qn][qm]='x';
	}
	return 0;
}
```

#### 二　BFS（$100$ 分）

以当前落下的苹果为起点，向四周四个方向上下左右进行搜索，只要搜到有苹果树的位置，直接结束搜索，输出距离的平方即可，同时记得给落下的苹果位置做标记。


请结合注释享用。

```cpp
#include"bits/stdc++.h"
using namespace std;
int G;
int r, s;
bool vis[505][505];
char a[505][505];
const int moving[4][2] = {0, -1, -1, 0, 0, 1, 1, 0};
long long Dist(int x1, int y1, int x2, int y2) { //求距离。
	return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
}
struct node {
	long long x, y;
};
node nown, nextn;
long long bfs(int x, int y) { //bfs模板。
	memset(vis, 0, sizeof vis); //一定要记得清空。
	long long ans = INT_MAX;
	queue<node> q;
	nown.x = x;
	nown.y = y;
	q.push(nown);
	while (!q.empty()) {
		nown = q.front();
		q.pop();
		if (Dist(nown.x, nown.y, x, y) > ans) { //终止条件，如果大于就没必要算下去了。
			continue;
		}
		for (int i = 0; i < 4; i++) {
			int newx = nown.x + moving[i][0];
			int newy = nown.y + moving[i][1];
			if (newx < 1 || newx > r || newy < 1 || newy > s || vis[newx][newy] == 1) { //判断边界。
				continue;
			}
			vis[newx][newy] = 1;//标记。
			int f = Dist(newx, newy, x, y);
			if (f >= ans) { //剪枝优化。
				continue;
			}
			if (a[newx][newy] == 'x') { //只有当前位是苹果树才能更新答案。
				ans = f;
			}
			nextn.x = newx;
			nextn.y = newy;
			q.push(nextn);
		}
	}
	return ans;
}
int main() {
	cin >> r >> s;
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= s; j++) {
			cin >> a[i][j];
		}
	}
	cin >> G;
	while (G--) {
		int x, y;
		cin >> x >> y;
		if (a[x][y] == 'x') { //如果当前位就是苹果树直接输出0即可。
			cout << "0\n";
			continue;
		}
		a[x][y] = 'x';//依据题意标记。
		cout << bfs(x, y) << '\n';
	}
	return 0;
}
```

---

## 作者：QcpyWcpyQ (赞：0)

广搜大法好。

- 我们有距离计算公式：$d=(\Delta x)^2+(\Delta y)^2$。每次苹果落下时，往四个方向搜，找到最近的苹果树就停，将这个坐标标记为一颗苹果树。

- 因为 $n,m\leq500,g\leq 10^5$ 搜索到后期就基本上全是树了，再糊一点基本的剪枝优化会跑得很快。


核心代码：
```cpp
inline int bfs(int x,int y){
	memset(vis,false,sizeof vis);
	queue<node>Q;
	int ans=inf;
	now.x=x,now.y=y,Q.push(now);
	while(!Q.empty()){
		now=Q.front(),Q.pop();
		if(dis(now.x,now.y,x,y)>ans)
			continue;
		for(int i=0;i<4;i++){
			int X=now.x+dir[i][0],Y=now.y+dir[i][1];
			if(X<1 or X>n or Y<1 or Y>m or vis[X][Y])
				continue;
			vis[X][Y]=true;
			int s=dis(X,Y,x,y);
			if(s>=ans)
				continue;
			if(a[X][Y]=='x')
				ans=s;
			nxt.x=X,nxt.y=Y,Q.push(nxt);
		}
	}
	return ans;
}
```


---

## 作者：Mu_leaf (赞：0)

# 前言：

水题一道~

~~可以说是广搜的模板题~~。

## [思路]:

可以发现 $1\leq n,m \leq 500,1 \leq g \leq 10^5$。

考虑广搜。具体的就是每落下一个点就拿广搜往外搜索，去找最近的苹果树。

在略微剪枝，时间复杂度大概 $O(g)$ 。

具体细节看代码：


------------
## Code:

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N=505;
int T,n,m,n_x,n_y;
int fx[4][2]={{-1,0},{0,-1},{1,0},{0,1}};//方向数组 
int ans=1e9,res=1e9;
bool vis[N][N];
struct node{
	int x,y;
}last,now;
char a[N][N];
int far(int x1,int y1,int x2,int y2){//求距离 
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
}
int Bfs(int x,int y){//Bfs模板 
	ans=1e9;
	memset(vis,0,sizeof(vis));//初始化 
	queue<node> q;
	now.x=x;
	now.y=y;
	q.push(now);
	while(!q.empty()){
		now = q.front();
		q.pop();
		if(far(now.x,now.y,x,y)>ans) continue;//如果这次搜索到的苹果树已经大于答案了就没必要继续搜了。 
		for(int i=0;i<4;i++){
			int xx=now.x+fx[i][0];//往上，下，左，右四个方向搜索 
			int yy=now.y+fx[i][1];
			if(xx>=1 && xx<=n && yy>=1 && yy<=m && vis[xx][yy]==0){
				vis[xx][yy]=1;
				int s=far(xx,yy,x,y);
				if(s>=ans) continue;//同样剪枝 
				if(a[xx][yy]=='x') ans=s;
				//只有这个点是苹果树时才能算出答案。 
				last.x=xx;
				last.y=yy;
				q.push(last);//压入对列 
			}
		}	
	}return ans;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin >> a[i][j]; 
		}
	}
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n_x,&n_y);
		if(a[n_x][n_y]=='x'){
			printf("0\n");
			a[n_x][n_y]='x';
			continue;
		}
		printf("%d\n",Bfs(n_x,n_y));
		a[n_x][n_y]='x';//明年还是可以长出苹果树的~~ 
	}
	return 0;//华丽的结束 
}
```


---


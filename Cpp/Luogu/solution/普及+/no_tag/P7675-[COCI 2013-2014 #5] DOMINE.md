# [COCI 2013/2014 #5] DOMINE

## 题目描述

给出一个 $N\times 3$ 的棋盘，上面写有数字。给你 $K$ 块 $1\times 2$ 的多米诺骨牌，请你求出用这 $K$ 块骨牌能覆盖的棋盘上的数字之和的最大值。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/r38fixsz.png)

如图，总和为 $3+2+2+3+3+3=16$，可以证明这是最大的。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N,K\le 1000$。

**【说明】**

本题分值按 COCI 原题设置，满分 $120$。

题目译自[COCI2013_2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #5](https://hsin.hr/coci/archive/2013_2014/contest5_tasks.pdf) _**T4  DOMINE**_

## 样例 #1

### 输入

```
5 3
2 1 -1
1 3 2
0 2 3
2 1 1
3 3 0 ```

### 输出

```
16 ```

## 样例 #2

### 输入

```
2 2
0 4 1
3 5 1 ```

### 输出

```
13```

# 题解

## 作者：_lmh_ (赞：4)

### P7675 DOMINE
### 1.做法
~~COCI 出的题名字都是什么玩意~~

直接贪心显然不行，比如下面这组数据：
```
2 2
1 -100 -100
100 100 1
```

答案为 $202$，但是贪心会得到错误的 $101$。

正确的做法则是 $1\times2$ 骨牌的常见做法：状压 dp。

### 2.状压 dp
将几个状态压缩在一个 int 里面就是状压，比如：

几个球选或不选；

参加或不参加；

还有，棋盘中该位置是否为一个 $1\times2$ 骨牌的上半部分，也就是本题中的状态。

注意到宽度始终为 $3$，所以一共只有 $2^3=8$ 个状态。

时间复杂度 $O(nk)$，可以通过。

### 3.代码

将状态定义为一个二进制整数，从最低位开始数，第三，二，一位分别代表该行第一，二，三列是否为一个竖着放的骨牌的上半部分。

$f[i][j][k]$ 代表第 $i$ 行，已经放了 $j$ 个骨牌（半个骨牌也算），状态为 $k$。

有三种转移方法：

1：直接转移，不在该行放横着的骨牌；

2：在前两个位置放横着的骨牌；

3：在后两个位置放横着的骨牌。

放一张图片（转移处理的是中间一行）：

![](https://cdn.luogu.com.cn/upload/image_hosting/0cdzq37p.png)

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a1,a2,a3,f[1001][1001][8],k,t,cnt,cnt2;
const int INF=-1e18;
inline int read(){
	char c=getchar();bool f=0;t=0; 
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c))t=(t<<1)+(t<<3)+(c^48),c=getchar();
	if(f)t=-t;return t;
}
int get(int state){
    return ((state&4)?a1:0)+((state&2)?a2:0)+((state&1)?a3:0);
    //特定状态覆盖的数之和
}
int cont(int state){
	return ((state&4)>>2)+((state&2)>>1)+(state&1);
//特定状态需要骨牌数
}
int q(int state,int i,int j){
    t=INF;cnt2=cont(state);
    if (j<cnt2) return INF; //骨牌不够
    for (int st=0,a;st<8;++st){
        if (st&state) continue; //一个格子上两张牌
        a=st|state;cnt=cont(a);
        if (j<cnt) continue; //骨牌不够
        if (!(a&3)&&j>cnt){
            t=max(t,get(a)+f[i-1][j-cnt2-1][st]+a2+a3);
            //第三种方式转移
        }
        if (!(a&6)&&j>cnt){
            t=max(t,get(a)+f[i-1][j-cnt2-1][st]+a2+a1);
            //第二种方式
        }
        t=max(t,f[i-1][j-cnt2][st]+get(a));
        //第一种方式
    }
    if (t-INF<30) return INF;
    return t;
}
int main(){
    scanf("%d%d",&n,&k);
    for (register int i=0;i<=k;++i) for (register int j=0;j<8;++j) f[0][i][j]=INF;
    f[0][0][0]=0;
    for (register int i=1;i<=n;++i){
        a1=read();
        a2=read();
        a3=read();//三个变量重复利用
        for (register int j=1;j<=k;++j){
            for (register int l=0;l<8;++l) f[i][j][l]=q(l,i,j);
        }
    }
    cout<<f[n][k][0];
    return 0;
}
```

---

## 作者：ran_qwq (赞：3)

大分讨 dp。

设 $dp_{i,j,k}$ 为前 $i$ 行放了 $j$ 个骨牌，当前的状态为 $k$ 的最大值。

这里的状态表示的是这一行放的状态，是一个 $0\sim7$ 的数，第 $p$ 列放状态二进制从低到高第 $p$ 位为 $1$，否则为 $0$。

边界：$dp_{i,0,0}=0$，其他为正无穷。

转移方程有 $12$ 种情况，其中第 $4\sim12$ 种需要 $i\ge2$，第 $2\sim12$ 种需要 $j\ge1$，第 $7\sim12$ 种需要 $j\ge2$，第 $12$ 种需要 $j\ge3$：

1. 这一行不放任何骨牌，$dp_{i,j,0}=\max\limits_{k=0}^7dp_{i-1,j,k}$。

1. 这一行第 $1,2$ 列放一个横向的骨牌，$dp_{i,j,3}=\max dp_{i-1,j-1,k}+a_{i,1}+a_{i,2}$。

1. 这一行第 $2,3$ 列放一个横向的骨牌，$dp_{i,j,6}=\max dp_{i-1,j-1,k}+a_{i,2}+a_{i,3}$。

1. 上一行和这一行的第 $1$ 列放一个竖向的骨牌，此时上一行第 $1$ 列不能放，$dp_{i,j,1}=\max\limits_{k\cap1=0}dp_{i-1,j-1,k}+a_{i-1,1}+a_{i,1}$。

1. 上一行和这一行的第 $2$ 列放一个竖向的骨牌，此时上一行第 $2$ 列不能放，$dp_{i,j,2}=\max\limits_{k\cap2=0}dp_{i-1,j-1,k}+a_{i-1,2}+a_{i,2}$。

1. 上一行和这一行的第 $3$ 列放一个竖向的骨牌，此时上一行第 $3$ 列不能放，$dp_{i,j,4}=\max\limits_{k\cap4=0}dp_{i-1,j-1,k}+a_{i-1,3}+a_{i,3}$。

1. 上一行和这一行的第 $1$ 列放一个竖向的骨牌，这一行第 $2,3$ 列放一个横向的骨牌，此时上一行第 $1$ 列不能放，$dp_{i,j,7}=\max\limits_{k\cap1=0}dp_{i-1,j-2,k}+a_{i-1,1}+a_{i,1}+a_{i,2}+a_{i,3}$。

1. 上一行和这一行的第 $3$ 列放一个竖向的骨牌，这一行第 $1,2$ 列放一个横向的骨牌，此时上一行第 $3$ 列不能放，$dp_{i,j,7}=\max\limits_{k\cap4=0}dp_{i-1,j-2,k}+a_{i-1,3}+a_{i,1}+a_{i,2}+a_{i,3}$。

1. 上一行和这一行的第 $1,2$ 列每列放一个竖向的骨牌，此时上一行第 $1,2$ 列不能放，$dp_{i,j,3}=\max\limits_{k\cap3=0}dp_{i-1,j-2,k}+a_{i-1,1}+a_{i-1,2}+a_{i,1}+a_{i,2}$。

1. 上一行和这一行的第 $1,3$ 列每列放一个竖向的骨牌，此时上一行第 $1,3$ 列不能放，$dp_{i,j,5}=\max\limits_{k\cap5=0}dp_{i-1,j-2,k}+a_{i-1,1}+a_{i-1,3}+a_{i,1}+a_{i,3}$。

1. 上一行和这一行的第 $2,3$ 列每列放一个竖向的骨牌，此时上一行第 $2,3$ 列不能放，$dp_{i,j,6}=\max\limits_{k\cap6=0}dp_{i-1,j-2,k}+a_{i-1,2}+a_{i-1,3}+a_{i,2}+a_{i,3}$。

1. 上一行和这一行的每列放一个竖向的骨牌，此时上一行每列都不能放，$dp_{i,j,7}=dp_{i-1,j-3,0}+a_{i-1,1}+a_{i-1,2}+a_{i-1,3}+a_{i,1}+a_{i,2}+a_{i,3}$。

答案：$\max dp_{n,m,k}$。

代码不放了。

---

## 作者：Alcl000000 (赞：1)

对每一行状压，令 $f_{i,j,k}$ 表示到第 $i$ 行，放了 $j$ 个多米诺骨牌，第 $i$ 行状态为 $k$ 时的最大和。

对于每一行，可能有横着的骨牌，也可能没有。

若有，为以下 $4$ 种情况之一：

![](https://cdn.luogu.com.cn/upload/image_hosting/0h9x1pp1.png)

若没有，则枚举竖着的即可。注意，对于每一行，枚举竖着的骨牌时，条件为本行状压状态为 $1$ 且上一行为 $0$，因为枚举上一张时并没有考虑在这一行竖着放骨牌。

答案即为 $\max_{i=0}^{7}f_{n,k,i}$。

具体转移见代码。

```cpp
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
using namespace std;
const int N=1005;
long long n,K,dp[N][N][8];
long long ans=-100000;
int a[N][4]; 
signed main(){
	memset(dp,-0x3f,sizeof dp);
	cin>>n>>K;
	for(int i=1;i<=n;i++) for(int j=1;j<=3;j++) cin>>a[i][j];
	for(int i=1;i<=3;i++) a[0][i]=-1000000000; 
	dp[0][0][0]=dp[1][0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<8;j++){
			for(int k=0;k<8;k++){
				for(int g=0;g<=K;g++){
					int x[4],y[4];
					for(int l=1;l<=3;l++){
						x[l]=(j>>l-1)&1;
						y[l]=(k>>l-1)&1;
					}
					if(x[1]==1&&x[2]==1){
						if(x[3]==1&&y[3]==0&&g>=2) {
							dp[i][g][j]=max(dp[i][g][j],dp[i-1][g-2][k]+a[i][1]+a[i][2]+a[i][3]+a[i-1][3]);
						}
						if(x[3]==0&&g>=1){
							dp[i][g][j]=max(dp[i][g][j],dp[i-1][g-1][k]+a[i][1]+a[i][2]);
						}
					}
					if(x[2]==1&&x[3]==1){
						if(x[1]==1&&y[1]==0&&g>=2) {
							dp[i][g][j]=max(dp[i][g][j],dp[i-1][g-2][k]+a[i][1]+a[i][2]+a[i][3]+a[i-1][1]);
						}
						if(x[1]==0&&g>=1){
							dp[i][g][j]=max(dp[i][g][j],dp[i-1][g-1][k]+a[i][2]+a[i][3]);
						}
					}
					long long flag=1,sum=0,ans=0;
					for(int p=1;p<=3;p++){
						if(x[p]==1&&y[p]==1) flag=0;
						if(x[p]==1&&y[p]==0){
							sum++;
							ans+=(a[i][p]+a[i-1][p]);
						}
					}
					if(flag&&g>=sum){
						dp[i][g][j]=max(dp[i][g][j],dp[i-1][g-sum][k]+ans);
					}
				}
			}
		}
	}
	for(int j=0;j<8;j++) ans=max(ans,dp[n][K][j]);
	cout<<ans;
	return 0;
}
```

---

## 作者：CYZZ (赞：1)

# [P7675 DOMINE](https://www.luogu.com.cn/problem/P7675)
模拟赛出了，寄了。
## 思路
$n$ 很小，鉴定为状压 dp。

设 $dp_{i,j,k}$ 表示前 $i$ 行，放了 $j$ 个，第 $i$ 行**被覆盖的状态**为 $k$，$k\in [0,7]$。

分三种情况转移：

- 当前行的每一个都是竖起来放的。
- 当前行有一个横着的，有一个竖着的。
- 当前行只有一个横着的。

转移不难，注意不能和上一行的冲突。

仔细实现就行了，剩下的看代码。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define __b __builtin_popcount
int n,K,a[1005][8];
long long dp[1005][1005][8],ans=-1e18;
void Max(long long &x,long long y)
{
    if(y>x) x=y;
}
int main()
{
    scanf("%d%d",&n,&K);
    for(int i=1;i<=n;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        a[i][1]=x;a[i][2]=y;a[i][4]=z;a[i][3]=x+y;a[i][6]=y+z;a[i][5]=x+z;
        a[i][7]=x+y+z;
    }
    for(int i=0;i<=n;i++)
        for(int j=0;j<=K;j++)
            for(int k=0;k<8;k++)
                dp[i][j][k]=-1e18;
    dp[0][0][0]=dp[1][0][0]=0;//初始化
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=K;j++)
        {
            if(i>1)
            {
                for(int k=0;k<8;k++)//全是竖着
                {
                    if(j>=__b(k))
                    for(int p=0;p<8;p++)//上行的状态
                        if((p&(7^k))==p)
                            Max(dp[i][j][k],dp[i-1][j-__b(k)][p]+a[i][k]+a[i-1][k]);
                }
                if(j>1)//一个横着，一个竖着
                    for(int k=0;k<7;k++)
                        for(int p:{0,2})//考场上这里错了
                            if(!(k&(1<<p)))
                                Max(dp[i][j][7],dp[i-1][j-2][k]+a[i-1][1<<p]+a[i][7]);
            }
            if(j>0)//有一个横着
            {
                for(int p=0;p<8;p++)
                {
                    Max(dp[i][j][3],dp[i-1][j-1][p]+a[i][3]);
                    Max(dp[i][j][6],dp[i-1][j-1][p]+a[i][6]);
                }
            }
        }
    }
    for(int k=0;k<8;k++) Max(ans,dp[n][K][k]);//注意一定要放满K个
    printf("%lld",ans);
}
```

---


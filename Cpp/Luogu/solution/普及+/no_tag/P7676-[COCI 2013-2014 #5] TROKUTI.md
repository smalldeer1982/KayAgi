# [COCI 2013/2014 #5] TROKUTI

## 题目描述

给定 $N$ 条在平面直角坐标系内的直线，这些直线上的点满足 $A_ix+B_iy+C_i=0$。

请你求出这些直线围出的三角形个数，答案对 $10^9+7$ 取模。

保证没有三线共点。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/rrp71ksq.png)

上图即为所有直线在平面直角坐标系上的位置，共围出了 $10$ 个三角形。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 3\times 10^5$，$|A_i|,|B_i|,|C_i|\le 10^9$。

**【说明】**

本题分值按 COCI 原题设置，满分 $140$。

题目译自[COCI2013_2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #5](https://hsin.hr/coci/archive/2013_2014/contest5_tasks.pdf) _**T5 TROKUTI*_

## 样例 #1

### 输入

```
6
0 1 0
-5 3 0
-5 -2 25
0 1 -3
0 1 -2
-4 -5 29 ```

### 输出

```
10```

## 样例 #2

### 输入

```
5
-5 3 0
-5 -3 -30
0 1 0
3 7 35
1 -2 -1 ```

### 输出

```
10```

# 题解

## 作者：kouylan (赞：6)

给定平面上的若干条直线，求围成的三角形的个数。

首先考虑什么样的三条直线可以围成一个三角形。三条直线必须互不平行，也就是三条直线的斜率不相等。

那么我们可以枚举直线 $x$，假设斜率为 $k$，那我们要求出斜率小于 $k$ 的直线个数和斜率大于 $k$ 的直线个数，两者相乘就是直线 $x$ 的答案。最后再把这些相加即可。

这样做可以保证不重不漏，因为计算每一条直线时都当成中间斜率，所以不会重复也不会遗漏。

下面是 AC 代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int M = 1e9+7;

int n,ans,r[300005];
double k[300005];

signed main()
{
	cin>>n;
	for(int i=1,a,b,c;i<=n&&cin>>a>>b>>c;i++)
		k[i] = (b!=0 ? -1.0*a/b : 2e17);
	sort(k+1,k+1+n);
	int now=1;
	for(int i=1;i<=n;i++)
	{
		if(i<now) continue;
		while(k[now]==k[i])
			r[i] = now, now++;
	}
	for(int i=1;i<=n;i++)
		if(r[i]>0)
			ans += (i-1)*(n-r[i])%M*(r[i]-i+1)%M, ans %= M;
	cout<<ans<<endl;
	
	return 0;
}
```

祝大家 AC 愉快！

---

## 作者：Like_Amao (赞：1)

**前言**

[题目传送门](https://www.luogu.com.cn/problem/P7676)

**题目大意**

给定 $N$ 条平面上的直线，求可以围成的三角形的个数。

**思路**

首先，围城三角形的前提是：三条直线互不平行，换言之，三条直线的斜率并不相等。因此，我们可以枚举直线 $i$，假设斜率是 $x$，那我们要求出斜率小于 $x$ 的直线个数和斜率大于 $x$ 的直线个数，两者相乘就是直线 $i$ 的答案。最后再把每个 $i$ 的答案相加即可。

---

## 作者：Missa (赞：1)

这题最多评绿吧……

发现自己的做法和那篇题解不同，所以来发个题解。

题意：给定 $n$ 条直线，求这些直线两两交出的三角的个数。保证无三线共点。

明显任意三条不平行的直线能确定一个三角。所以有一个做法是先算全部再排除选了两条或三条斜率相同线的情况。然而这篇题解讲的并不是这个做法，而是另一个我先想到的做法。

观察样例解释，

![](https://cdn.luogu.com.cn/upload/image_hosting/rrp71ksq.png)

有三条平行直线，可不可以当做一条看待呢？

两条能与 $y=3$ 交出三角的直线，必然也能与 $y=2$ 交出三角。分配律一下，即可把两条直线合到一起。

这样的话，相当于给每条直线一个权值，表示有几条线与它斜率一致。每次选三条直线相乘，贡献即为三条直线权值之积。

约分给定斜率，用 `map` 判重，然后一遍背包，即可。

复杂度 $O(n \log n)$，瓶颈在判重。

```cpp
#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;
const int M = 300005, mod = 1000000007;
int n, a[M], b[M], c[M], h[M], cnt, dp[M][4];
map<pair<int, int> , int> t1; map<pair<int, int> , bool> t2;
pair<int, int> k[M];
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d %d %d", &a[i], &b[i], &c[i]);
        int g = __gcd(a[i], b[i]); k[i] = make_pair(a[i]/g, b[i]/g);
        if(k[i].first < 0) k[i].first = -k[i].first, k[i].second = -k[i].second;
        t1[k[i]]++;
    }
    for(int i = 1; i <= n; i++) {
        if(!t2[k[i]]) h[++cnt] = t1[k[i]]; t2[k[i]] = 1;
    }
    dp[0][0] = 1; 
    for(int i = 1; i <= cnt; i++){
        dp[i][0] = dp[i-1][0];
        for(int j = 1; j <= 3; j++){
            dp[i][j] = (1ll * dp[i-1][j-1] * h[i] % mod + dp[i-1][j]) % mod;
        }
    }
    printf("%d\n", dp[cnt][3]);
}
```

---

## 作者：Imerance1018 (赞：0)

### Description

[传送门](https://www.luogu.com.cn/problem/P7676)

### Solution

显然，三条直线能围成三角形当且仅当他们斜率两两不同。

所以，我们对每条直线的斜率 $k=- \frac{a}{b}$ 进行离散化，然后用 $cnt_i$ 记录离散化后斜率为 $i$ 的直线数量。

那么斜率为 $i$ 的直线对答案的贡献为

$$
  cnt_i \times (\sum_{j=1}^{i-1} {cnt_j}) \times (\sum_{j=i+1}^{n} {cnt_j})
$$

最后求和输出答案即可。

注意取模。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
#define eps 1e-6
using namespace std;
const int N=3e5+10,mod=1e9+7;
double k[N];
double lsh[N];
int cnt[N],pre[N];
int n,m,ans;
signed main()
{
	scanf("%lld",&n);
	m=n;
	for(int i=1;i<=n;i++)
	{
		int a,b,c;
		scanf("%lld%lld%lld",&a,&b,&c);
		k[i]=-a*1.0/b;
		lsh[i]=k[i];
	}
	sort(lsh+1,lsh+n+1);
	m=unique(lsh+1,lsh+m+1)-lsh-1;
	for(int i=1;i<=n;i++)
		k[i]=lower_bound(lsh+1,lsh+m+1,k[i])-lsh;
	for(int i=1;i<=n;i++)
		cnt[(int)k[i]]++;
	for(int i=1;i<=n;i++)
		pre[i]=pre[i-1]+cnt[i];
	for(int i=1;i<=n;i++)
	{
		ans=(ans+(pre[i-1])*(pre[n]-pre[i])%mod*cnt[i]%mod)%mod;
	}
	printf("%lld",ans);
	return 0;
}
``````

---

## 作者：dbxxx (赞：0)

[您可在我的博客中查看本文，谢谢！](https://www.cnblogs.com/crab-in-the-northeast/p/luogu-p7676.html)

首先考虑三角形的形成条件（注意到题面保证了无三线共点）：

- 三条边；
- 任意两条边不平行。

考虑补集，统计存在两条边平行的三元组数量，用总数 $\dbinom{n}{3}$ 减去即可。

存在两条边平行，也就是满足以下两种情况之一：

- 两条边平行，另一条边不与这两条边平行；
- 三条边均平行。

两条直线平行当且仅当它们的斜率相同（竖线可看做 $+\infty$），那么我们统计每种斜率出现的数量 $c$。

我们对于每种斜率都进行如下统计：

- $c \ge 2$ 时，数量 $\dbinom{c}{2} \times (n - c)$，代表在斜率为 $c$ 的这些平行直线中选取两条，和另外一条与其斜率不同的直线组成的三元组数量；
- $c \ge 3$ 时，可以构成满足条件二的三角形，数量 $\dbinom{c}{3}$，代表斜率为 $c$ 的这些平行直线中选取三条组成的三元组数量。

这样每个不合法的三元组都可以被不重不漏统计一次。

至于如何统计每种斜率出现的数量，应该采用 map。

```cpp
#include <bits/stdc++.h>
#define int long long
inline int read() {
    int x = 0;
    bool flag = true;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            flag = false;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    if(flag)
        return x;
    return ~(x - 1);
}

const int mod = (int)1e9 + 7;
const int maxn = 300005;

int a[maxn], b[maxn];

inline int C3(int x) {
    return x * (x - 1) / 2 * (x - 2) / 3;
}

inline int C2(int x) {
    return x * (x - 1) / 2;
}

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

typedef std :: pair <int, int> pii;
std :: map <pii, int> m;

signed main() {
    int n = read();
    for (int i = 1; i <= n; ++i) {
        int a = read(), b = read();
        read();
        
        if (a == 0)
            b = 1;
        else if (b == 0)
            a = 1;
        else {
            int d = gcd(a, b);
            a /= d;
            b /= d;
        }

        ++m[std :: make_pair(a, b)];
    }

    int ans = C3(n) % mod;
    for (auto it : m) {
        int cnt = it.second;
        if (cnt >= 2)
            ans -= C2(cnt) * (n - cnt) % mod;
        if (cnt >= 3)
            ans -= C3(cnt) % mod;
        (ans += mod) %= mod;
    }

    printf("%lld\n", ans);
    return 0;
}
```

如果觉得这篇题解有助于您，请不要忘记点赞，谢谢！

---


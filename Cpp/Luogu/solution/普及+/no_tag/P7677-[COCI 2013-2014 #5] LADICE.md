# [COCI 2013/2014 #5] LADICE

## 题目描述

有 $N$ 个物品，$L$ 个抽屉，每个抽屉只能放 $1$ 个物品，每个物品都能被放进抽屉 $A_i$ 或 $B_i$ 中。

放物品的规则如下（按照顺序执行，即满足条件 $1$ 时就立刻执行，不会执行条件 $2$；不满足条件 $1$ 时就判断条件 $2$）：

- $1.$ 如果抽屉 $A_i$ 是空的，就把这个物品放进抽屉 $A_i$ 中；

- $2$ 如果抽屉 $B_i$ 是空的，就把这个物品放进抽屉 $B_i$ 中；

- $3.$ 把抽屉 $A_i$ 中的物品移到它的另一个抽屉里；如果这个抽屉也满了，就把这个抽屉里的物品放到它的另一个抽屉里，直到你成功或回到之前遇到过的抽屉为止。如果成功了，就把这个物品放进这个抽屉中；

- $4.$ 把抽屉 $B_i$ 中的物品移到它的另一个抽屉里；如果这个抽屉也满了，就把这个抽屉里的物品放到它的另一个抽屉里，直到你成功或回到之前遇到过的抽屉为止。如果成功了，就把这个物品放进这个抽屉中；

- $5.$ 扔掉此物品。

对于给定的每件物品，请你求出哪些物品将被保存，哪些将被扔掉。

## 说明/提示

**【样例解释 #1】**

物品 $1$ 放入抽屉 $1$，物品 $2$ 放入抽屉 $3$，物品 $3$ 放入抽屉 $3$，物品 $1$ 和物品 $1$ 没有地方放。

**【样例解释 #2】**

物品 $1$ 放入抽屉 $1$，物品 $2$ 放入抽屉 $3$，物品 $3$ 放入抽屉 $5$，物品 $4$ 放入抽屉 $7$，物品 $5$ 放入抽屉 $9$，物品 $6$ 放入抽屉 $2$，物品 $8$ 放入抽屉 $8$。

物品 $7$ 的两个抽屉都满了，将抽屉 $1$ 里的物品 $1$ 移到抽屉 $2$ 里，将抽屉 $2$ 里的物品 $6$ 移到抽屉 $3$ 里，将抽屉 $3$ 里的物品 $2$ 移到抽屉 $4$ 里，抽屉 $4$ 是空的，成功放入。

物品 $9$ 的两个抽屉都满了，将抽屉 $7$ 里的物品 $4$ 移到抽屉 $8$ 里，将抽屉 $8$ 里的物品 $8$ 移到抽屉 $2$ 里，将抽屉 $2$ 里的物品 $1$ 移到抽屉 $1$ 里，将抽屉 $1$ 里的物品 $7$ 移到抽屉 $5$ 里，将抽屉 $5$ 里的物品 $3$ 移到抽屉 $6$ 里，抽屉 $6$ 是空的，成功放入。

**【数据范围】**

对于 $50\%$ 的数据，$1\le N,L\le 2000$；

对于 $100\%$ 的数据，$1\le N,L\le 3\times 10^5$，$1\le A_i,B_i\le L$。

**【说明】**

本题分值按 COCI 原题设置，满分 $160$。

题目译自[COCI2013_2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST #5](https://hsin.hr/coci/archive/2013_2014/contest5_tasks.pdf) _**T6  LADICE**_

## 样例 #1

### 输入

```
5 3
1 2
1 3
1 2
1 3
1 2 ```

### 输出

```
LADICA
LADICA
LADICA
SMECE
SMECE ```

## 样例 #2

### 输入

```
9 10
1 2
3 4
5 6
7 8
9 10
2 3
1 5
8 2
7 9 ```

### 输出

```
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA
LADICA```

# 题解

## 作者：JoeZYQ (赞：5)

## [先看题](https://www.luogu.com.cn/problem/P7677)
## 题目思路
我们设 $vis_i$ 表示第 $i$ 个抽屉有没有放置物品，以此来判断能放置下第 $i$ 个物品的抽屉 $a_i$ 和 $b_i$ 是否为空。

如果这个物品的一个抽屉 $a_i$ 已经放置了另一个物品，就占据这个物品的另一个抽屉 $b_i$，然后抽屉 $b_i$ 中如果原本有物品，那就查询这个物品的 $a_i$ 与 $b_i$ 抽屉，直到找到一个抽屉为空时，并查集便可以优化这一过程。

如果都没有抽屉可以存放物品，就只能将这个物品丢弃。
## 如果还没看懂，以下是代码的具体实现
```cpp
#include<iostream>
using namespace std;
int n,l;
const int N=3e5+5;
int vis[N],fa[N];
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void un(int x,int y){
	x=find(x),y=find(y);
	if(x!=y)
		fa[y]=x;
}//并查集基本操作 
int main(){
	cin>>n>>l;
	for(int i=1;i<=l;i++)fa[i]=i;//初始化 
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		if(vis[find(x)]==0||vis[find(y)]==0) {//放得下 
			cout<<"LADICA\n";
			if(vis[find(x)]==0){//可以执行条件1/3 
				vis[find(x)]=1;//标记 
				un(y,x);
			}
			else{//可以执行条件2/4 
				vis[find(y)]=1;//标记 
				un(x,y);
			}
		} 
		else cout<<"SMECE\n";//放不下 
	}
	return 0; 
}
```

---

## 作者：cqbztz2 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P7677)

# 思路：

对于一个物品，只有两个抽屉 A,B 可以放，那么如果能够放下，那么一定是放在其中一个，设放在 A 中，那么以后可以且只能将其移动到 B 中，所以我们建一条有向边由 A 指向 B，这样处理下去我们会发现对于每一条有向边一定是有物品的抽屉指向没有物品的抽屉，那么我们定义一个块为之间有边的点的集合，定义块的根为块中没有出边的点，那么一个块中只有根会是空的抽屉其他的一定是有物品的抽屉，那么每一个块就可以用一个并查集维护起来，每加一个物品(即加一条边)时，对于两个端点 A,B ，如果有 A 所在的并查集的根可以放那么就将 A 所在的并查集的根标记为有物品，将 A 所在的并查集连到 B 的并查集的根上，如果不行就再考虑 B ，如果都不行，就无法放入。对于连成环的情况其实就等价于根有物品。

# 代码：
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,m,father[300005],a,b;
  bool f[300005];
  int findset(int a){
      int i,t=a;
      for(;t!=father[t];t=father[t]);
      for(;a!=father[a];a=i){
          i=father[a];
          father[a]=t;
      }
      return t;
  }

  int main(){
      cin>>n>>m;
      for(int i=1;i<=m;i++){
          father[i]=i;
      }
      for(int i=1;i<=n;i++){
          cin>>a>>b;
          if (f[findset(a)]==false){
              f[father[a]]=1;
              if (father[a]!=findset(b)){
                  father[father[a]]=father[b];
              }
              cout<<"LADICA"<<endl;
          }
          else if(f[findset(b)]==false){
              f[father[b]]=1;
              cout<<"LADICA"<<endl;
          }
          else{
              cout<<"SMECE"<<endl;
          }
      }
      return 0;
  }
```


---

## 作者：langmouren (赞：1)

## 大概思路
题目给出的物品和柜子并没有区别，只需要维护有和没有两种状态，所以我们可以想到并查集。

对于每个物品，我们使用一个数组 $vis$ 判断它对应的两个柜子有没有东西，哪一个没有就把 $vis_i$ 更新为 true，并把它使用并查集合并到另一个当中。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MN=3e5+10;
int fa[MN];
bool vis[MN];
int n,l;

int find(int x){
	if(fa[x]!=x) fa[x]=find(fa[x]);
	return fa[x];
} 

void merge(int x,int y){
	x=find(x);
	y=find(y);
	fa[x]=y;
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>l;
	for(int i=1;i<=l;i++){
		fa[i]=i;
	}//初始化 
	
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		if(vis[find(x)]==false){
			cout<<"LADICA\n";
			vis[find(x)]=true;
			merge(x,y);
		}else if(vis[find(y)]==false){
			cout<<"LADICA\n";
			vis[find(y)]=true;
			merge(y,x);
		}else{
			cout<<"SMECE\n";
		}
	}
	return 0;
} 	
```

---

## 作者：Delov (赞：1)

## 思路

我们考虑在类似图的模型上解决这个问题，用并查集维护。 对于每个物品的两个可能柜子 $A_i,B_i$，我们尝试将它们连边，在这个图上，每个点代表一个柜子，每条边代表一个物品，每个物品可以放到他所连接的两个点之中，我们考虑合并两个联通块，若合并后边数小于点数，那么可以连接，也就是这个物品可以放进去，否则就要丢掉。

实际上我们并不关心对应的盒子是不是已经存在物品了。如果一个联通块的边数小于等于点数，至少我们可能能让每条边，也就是每个物品都能放进一个柜子里。我们感性证明一定有一种方案让每个物品都有柜子放。

考虑每个联通块是一个无向联通图，两两点直接互相可达，那么我们若某次合并合法，则说明之前的联通块里必定边数小于点数，或者说一定是边数等于点数减一，那么首先一定有一个抽屉是空的，我们考虑现在要放的这个物品的两个抽屉，如果都已经被占了，那么我们一定能让任意一个，用像接力的方式，传递过去，去占掉之前空着的那个抽屉并空出来我们想放的抽屉。如果之前边数已经等于点数了，那么每个抽屉都有物品，怎么挤都不可能挤出来一个空抽屉

### ACcode

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;

const int maxn=4e5+10;

#define gc if(++ip==ie)fread(ip=buf,1,SZ,stdin)
const int SZ=1<<20;
char buf[SZ],*ie=buf+SZ,*ip=ie-1;
inline int read(){
	gc;while(*ip<'-')gc;
	bool f=*ip=='-';if(f)gc;
	int x=*ip&15;gc;
	while(*ip>'-'){x*=10;x+=*ip&15;gc;}
	return f ? -x : x;
}

int f[maxn],siz[maxn],num[maxn];
int find(int x){return f[x]==x ? x : f[x]=find(f[x]);}

int n,m;

void init(){
	for(int i=1;i<=m;i++)f[i]=i,siz[i]=1;
}

bool trymerge(int x,int y){
	int fx=find(x),fy=find(y);
	if(fx==fy){
		if(num[fx]+1<=siz[fx]){
			num[fx]++;
			return true;
		}else return false;
	}
	else{
		if(num[fx]>=siz[fx] && num[fy]>=siz[fy])return false;
		siz[fx]+=siz[fy];
		num[fx]=num[fx]+num[fy]+1;
		f[fy]=fx;
		return true;
	}

}

void solve(){
	n=read();m=read();
	init();
	for(int i=1;i<=n;i++){
		int x,y;
		x=read();y=read();
		if(trymerge(x,y))puts("LADICA");
		else puts("SMECE");
	}
}

int main (){
	solve();
	return 0;
}
```

---

## 作者：Avocadooo (赞：1)

# 正经教学

### 1.题目类型判断

抽屉的 $ A_i $ 和 $ B_i $ 存在着一些**继承关系块**（便于理解作者起的名字）：

一旦抽屉 $ A_i $ 需要挪出物品给别人让位，那么这时该物品则会自然挪动到 $ B_i $ 的位置，而如果挪动到的   $ B_i $ 若又是物品 $ j $ 所在的位置 $ A_j $ ，那么又需要再一次挪动物品 $ j $ ，就像这样一直关联下去直到挪动到达的 $ B_k $ 不再有物品存在。

那么即到达了该**继承关系块**的**末端**（还是作者起的）。

加以图片说明：

![](https://z3.ax1x.com/2021/10/02/4qCro8.png)

而题目则是想要询问对于一个物品能否找到**末端**。（找不到就是已经放满了，再也放不进去一个物品）

再看题目数据范围 $  1 \leq L \leq 3 \times 10^5 $ ，爆搜找末端自然会~~去世~~TLE。

故想到使用**并查集路径压缩**来处理**继承关系块**的**末端**查找。

### 2.基本思路

想到了**并查集**，那么这道题自然是迎刃而解。 ~~（我是真不知道这题是如何成为蓝题的）~~

使用两个数组, vst 数组用作判断抽屉是否放置了物品， prt 则是并查集使用的数组，这里就是拿来存储两个抽屉的**继承关系块**（即在题目类型判断中提到的）。

每当我们读取到一个物品 $ r $ 的 $ A_r $ 和 $ B_r $ 后，利用路径压缩快速判断是否存在**末端**，输出对应结果，然后合并 $ A_r $ 和 $ B_r $ 所在的**继承关系块**。（为后面的物品放入作铺垫）

整个题目就完成了。

### 3.std代码

```cpp
#include<iostream>
#define N 300005
using namespace std;
int n,l;
int vst[N],prt[N];
int GetFather(int s)
{
	return s==prt[s]?s:prt[s]=GetFather(prt[s]);
}
int main()
{
	cin>>n>>l;
	for(int i=1;i<=l;i++) prt[i]=i;
	for(int i=1;i<=n;i++)
	{
		int A,B;
		cin>>A>>B;
		if(vst[GetFather(A)]==0||vst[GetFather(B)]==0)//存在末端 
		{
			cout<<"LADICA"<<endl;
			if(vst[GetFather(A)]==0) 
			{
				vst[GetFather(A)]=1;
				prt[GetFather(A)]=GetFather(B);
			}
			else 
			{
				vst[GetFather(B)]=1;
				prt[GetFather(B)]=GetFather(A);
			}
			continue;
		}
		//反之则找不到末端(即无法将该物品放入) 
		cout<<"SMECE"<<endl;
	}
}
```

---

## 作者：CaoXian (赞：1)

## P7677 [COCI2013-2014#5] LADICE 题解

~~这道题这么水怎么会有蓝题的难度？~~

首先，对于每一个物品，我们只用知道它能不能放在某一个抽屉里即可，所以并不需要跟题意一模一样的模拟。

那么如何判断一个物品是否能放在某一个抽屉里呢？使用并查集就可以很快解决这个问题。

对并查集就不过多解释了，具体可以看一下 [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367) 这一道题。

**初始化**环节。

对于每一个物品，用 `father` 数组保存这个物品对应的另一个抽屉，也就是这个物品可以存在哪一个别的抽屉里。

再用一个 `vis` 数组保存哪些抽屉里放有物品。

接下来是**并查集**遍历抽屉。

先看这个可以存放的抽屉 $A_i$ 。

如果这个物品的抽屉被另一个物品占用时，就顺着当前抽屉里的物品能到达的抽屉遍历，直到找到一个抽屉为空时。

如果并查集遍历到达终点时都没有抽屉可以存放物品，那么就按照遍历$A_i$同样的方式去遍历 $B_i$ 。

如果都没有抽屉可以存放物品，就只能将这个物品丢弃。

给出**关键代码**

```cpp
while(n--) {
	scanf("%d%d", &a, &b);
	x = findset(a), y = findset(b);
	if(!vis[x] || !vis[y]) {
		if(!vis[x]) vis[x] = true, father[x] = y;
		else vis[y] = true, father[y] = x;
		puts("LADICA");
	} else puts("SMECE");
}
```
 `findset` 函数记得加上优化，个人比较喜欢**路径压缩优化**，简单易懂实现方便。

---

## 作者：cjh_trailblazer (赞：0)

## 题目分析：
这道题乍一看没什么思路，$5$ 种操作有点难办，最难处理的在于第 $3$、$4$ 种操作，我们仔细思考一下，不难发现一个性质：

第 $3$、$4$ 种操作只会影响当前放的球，不会影响之前放的球，所以我们可以在线做。

我们还能发现抽屉编号是无所谓的（这是个坑点，本人做的时候因为这个罚坐一小时），只需关注该抽屉是否空闲即可。

为何编号是无所谓的？因为能否放下球的关键在于是否有空抽屉，编号之所以难处理，关键在于 $3$、$4$ 操作的变换。  
我们还能够发现一个事实：第 $3$、$4$ 操作本质上实在找联通块内是否有空位，因为移动先前的球就是在联通块内变换，只要联通块内有空位，就一定能放下，无需关注编号。

那么我们只需在线维护抽屉构成的联通块即可维护第 $3$、$4$ 操作，无需维护抽屉。

而并查集显然能够维护这些，上个并查集即可。
## Code：
```cpp
#include<bits/stdc++.h>
#define starrail main
#define re register
#define il inline
using namespace std;
typedef long long ll;
il int read(){
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') w=-1;ch=getchar();}
	while(isdigit(ch)){s=(s<<1)+(s<<3)+(ch^48);ch=getchar();}
	return w*s;
}
const int N=3e5+10;
int n,l,fa[N];
bool vis[N];
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
void merge(int x,int y){
	x=find(x),y=find(y);
	if(x!=y) fa[y]=x;
}
signed starrail(){
	n=read();l=read();
	for(int i=1;i<=l;i++) fa[i]=i;
	for(int i=1;i<=n;i++){
		int x=read(),y=read();
		if(vis[find(x)]==0||vis[find(y)]==0){
			printf("LADICA\n");
			if(vis[find(x)]==0){
				vis[find(x)]=1;
				merge(y,x);
			}
			else{
				vis[find(y)]=1;
				merge(x,y);
			}
		} 
		else printf("SMECE\n");
	}	
	return 0;
}//P7677
```

---

## 作者：_Delete_ (赞：0)

## Sol.

一道精妙的并查集好题。

题意是问一个物品，在可以不断调整已放进抽屉的物品的情况下，能否放下这一物品。

容易发现两个性质：

- 我们并不在意它究竟是放到了哪个抽屉，也不用维护一个抽屉里究竟放的是什么，只需要知道能否放下。

- 如果这两个抽屉都放满了，我们可以将某个抽屉中的物品放到另一个，再对于物品不断传递，找出是否在传递的途中有空的抽屉。

观察性质二，不难发现这个传递查找空抽屉的过程可以使用并查集维护。

我们可以在初始时将一个物品放入任何一个空的抽屉，然后将已放入物品的抽屉用并查集连向另一个，这样便可以简单维护未来物品的传递。

由于我们总是将满抽屉连向空抽屉，所以可以保证查找到的祖先是空的或者是满的。注意在实现过程中不要将并查集连成环，那会使你超时限。

## code


```cpp
#include<bits/stdc++.h>
#define endl "\n"
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
//value
int vis[300005],fa[300005];


//function 
int find(int a){
	if(fa[a]==a)return a;
	else return fa[a]=find(fa[a]);
}

 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0); 
	
	
	int n,l;
	cin>>n>>l;
	for(int i=1;i<=l;i++)fa[i]=i;
	for(int i=1;i<=n;i++){
		int a,b;
		cin>>a>>b;
		if(vis[find(a)]==0){
			vis[find(a)]=1;
			fa[find(a)]=find(b);
		} 
		else if(vis[find(b)]==0){
			vis[find(b)]=1;
			fa[find(b)]=find(a);
		}
		else {
			cout<<"SMECE"<<endl;
			continue;
		}
		cout<<"LADICA"<<endl;
	}
	
	
	
	
	
	
	return 0;
}
```

---


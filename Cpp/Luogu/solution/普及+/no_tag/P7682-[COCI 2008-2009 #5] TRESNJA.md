# [COCI 2008/2009 #5] TRESNJA

## 题目描述

Lana 住在一个快乐的小村庄里。主街旁边有一排樱桃树。Lana 注意到每棵树用从 $1$ 开始的连续整数编号。经过大量研究，Lana 注意到树的编号唯一地决定了树的樱桃数量。对于一棵树，考虑将树编号中的连续数字组拆分出来。对于每组数字，将这一组中唯一的数字乘以该组数字长度的平方。把这些数字加在一起就得到了树上的樱桃总数。例如，在编号为 $77744007$ 的树中，我们将编号中的连续数字组拆分出来，得到 $4$ 组数：$777$、$44$、$00$ 和 $7$。所以编号为 $77744007$ 的树中樱桃的数量为 $7\times 3^2+4\times 2^2+0\times2^2+7\times1^2=86$ 个。

到了摘樱桃的时候了，村民们同意把编号在区间 $[a,b]$ 中的树上的樱桃都摘下来。现在请你编写一个程序来计算采摘樱桃的总量。

## 说明/提示

**【数据范围】**

对于所有数据，$1\leqslant a\leqslant b\leqslant 10^{15}$。

**【题目来源】**

本题来源自 **_[COCI 2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST 5](https://hsin.hr/coci/archive/2008_2009/contest5_tasks.pdf) T5 TRESNJA_**，按照原题数据配置，满分 $120$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
1 9```

### 输出

```
45```

## 样例 #2

### 输入

```
100 111```

### 输出

```
68```

## 样例 #3

### 输入

```
7774407 7774407```

### 输出

```
86```

# 题解

## 作者：_edge_ (赞：9)

这题难度是不是稍微有点问题。

数位 DP 咋可能是黄题呢？

~~(如果有什么不用数位 DP 的方法当我没说)。~~

首先有几个很明显的特征，它的数据范围经常是 $10^9$ ~ $10^{18}$。

另外一个是区间查询。

我们可以考虑用前缀和一样的思路求出 $[1,n]$ 之间的数的和，然后减去 $[1,l)$ 即可。

我写的是记忆化搜索版本，对着每一位都枚举一下。

注意一下上限，以及要记录的前一个数的值，连续数的数量以及总和 (这边内存倒是不会爆掉，但应该有比我更优内存的)。

然后就是一道模板数位 DP 了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define int long long
using namespace std;
const int INFN=2035;
const int INF=17;
const int INFF=13;
int l,r,a[INF],tot,f[INF][INFF][INF][INFN];
// 第几位，有没有卡着上限，前一个数，连续的数多少个，总和多少？
int DFS(int b,int c,int d,int e,int p) {
        if (b<=0) return p+d*e*e;
        if (f[b][d][e][p]!=-1 && !c) return f[b][d][e][p];
        int Max=(c ? a[b] : 9),sum=0;
        for (int i=0; i<=Max; i++) {
                sum+=DFS(b-1,(c && i==Max),i,(i==d ? e+1 : 1),(i!=d ? p+d*e*e : p));
        }
        if (!c) f[b][d][e][p]=sum;
        return sum;
}
int calc(int xx) {
        memset(f,255,sizeof f);
        memset(a,0,sizeof a); tot=0;
        while (xx) {
                a[++tot]=xx%10;
                xx/=10;
        }
        return DFS(tot,1,10,0,0);
}
signed main()
{
        scanf("%lld %lld",&l,&r);
        cout<<calc(r)-calc(l-1)<<"\n";
        return 0;
}

```

**谢谢观赏。**

---

## 作者：Autream (赞：1)

#### 题意简述
每颗樱桃树都有一个编号，定义一颗樱桃树上的樱桃数量为所有连续的数字乘以长度的平方的和。

现给定区间 $[a,b]$，求这个区间内的樱桃数量。

---
#### 题目分析
看到这种数据范围自然而然地就会想到数位 DP。

不妨设 $dp_{step,last,cnt,sum}$ 表示当前填到第 $step$ 位，上一位数字是 $last$，当前连续数字的个数是 $cnt$，当前编号的樱桃数量是 $sum$。

对于枚举的每一位，考虑填 $0 \sim limit$，其中 $limit$ 为当前为的上界。更新的时候如果当前选的数字等于 $last$，那么 $cnt+1$，$ans$ 不变，否则更新 $ans=ans+last \times cnt^2$。使用记忆化搜索。 

**注意：如果你 `#define int long long` 一定要注意空间限制**。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=16;//卡空间
int a,b,num[N],dp[N][N][N][2005];
int dfs(int step,int last,int cnt,int sum,int limit) {
    if(step>num[0]) {
        return sum+last*cnt*cnt;
    }
    if(!limit&&dp[step][last][cnt][sum]!=-1) {
        return dp[step][last][cnt][sum];
    }
    int up=limit?num[num[0]-step+1]:9;
    int s=0;
    rep(i,0,up) {
        s+=dfs(step+1,i,i==last?cnt+1:1,i==last?sum:sum+cnt*cnt*last,limit&&i==up);
    }
    if(!limit) {
        dp[step][last][cnt][sum]=s;
    }
    return s;
}
int solve(int x) {
    num[0]=0;
    while(x) {
        num[++num[0]]=x%10;
        x/=10;
    }
    mem(dp,-1);
    return dfs(1,-1,0,0,1);
}
signed main() {
    std::cin>>a>>b;
    std::cout<<solve(b)-solve(a-1);
    return 0;
}
```

---

## 作者：Cells (赞：0)

## 思路

还是套路题没有什么新意，在 `dfs` 的时候多维护一个当前的答案，前一个数，前一个数的长度，如果 $i = pre$，$len$ 继续增加 $1$，否则更新 $res = res + pre \times len^2$，并且重置 $len = 1$，搜到尽头返回 $res + pre \times len^2$ 即可。

记搜真好写。

## Code

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int len, a[20];
LL l, r;
LL f[16][10][16][2050];

LL dfs(int pos, int pre, int len, int res, bool limit){
	if(!pos) return res + pre * sqr(len);
	if(!limit && ~f[pos][pre][len][res]) return f[pos][pre][len][res];
	
	LL sum = 0;
	int range = limit ? a[pos] : 9;
	rep(i, 0, range){
		if(i == pre) sum += dfs(pos - 1, i, len + 1, res, limit & (i == range));
		else sum += dfs(pos - 1, i, 1, res + pre * sqr(len), limit & (i == range));
	}
	
	if(!limit) f[pos][pre][len][res] = sum;
	return sum;
}

LL solve(LL x){
	len = 0;
	mem(f, -1);
	while(x) a[++ len] = x % 10, x /= 10;
	return dfs(len, 0, 0, 0, true);
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> l >> r;
	cout << solve(r) - solve(l - 1);
	
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题意：

- 将数字中的连续数字组拆分出来。对于每组数字，将这一组中唯一的数字乘以该组数字长度的平方，这个数的得分为其每组数字的得分和。

- 询问区间所有数字的得分和。

### 思路：

看到这个数据范围，感觉只能想到数位动态规划，如果你对数位 DP 不怎么熟悉的话，那么做数位 DP 的题，最好先是要写出爆搜的代码。

首先肯定是要当前在第 $pos$ 位，然后是上一位的数字 $last$，和当前连续的数字个数 $sum$，以及当前得到的得分 $ans$，最后是最高位限制 $limits$。

转移的时候，得到当前位能得到的最高位 $l$，枚举当前位的数字 $0 \sim l$，判断一下，如果当前位和上一位相等，则将 $sum+1$，$ans$ 不变（最后算），否则为 $sum=1$，$ans \to ans+last \times sum \times sum$（即将上一组连续的数字的得分算出来）。

这样你就可以拿到 $30pts$ 的好成绩。

[暴力搜索 30pts 代码。](https://www.luogu.com.cn/paste/nkphx4sd)

于是可以记忆化搜索一下，先想一下状态个数，$pos$ 和 $last$ 最高为 $9$，$sum$ 最多有 $15$ 位，$ans$ 的话，想一下其最大得分，$15$ 位全部为 $9$，则得分为 $15^2 \times 9 = 2025$，则总状态数应该为 $9 \times 9 \times 15 \times 2025=2460375$，只有 $2 \times 10^6$ 次方左右，可以记忆化搜索。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const ll N=18,M=2050;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,a,b;
ll dis[N];
ll dp[N][N][N][M];
ll check(ll x){
	ll cnt=0;
	while(x){
		dis[++cnt]=x%10;
		x/=10;
	}
	return cnt;
}
ll dfs(ll pos,ll last,ll sum,ll ans,bool limits){
	if(pos<=0)
	  return ans+last*sum*sum;
	if(dp[pos][last][sum][ans]&&!limits)
	  return dp[pos][last][sum][ans];
	ll l=(limits?dis[pos]:9),t=0;
	for(int i=0;i<=l;i++)
	  t+=dfs(pos-1,i,(i==last?sum+1:1),(i==last?ans:ans+sum*sum*last),(limits&&i==l));
	if(!limits)
	  dp[pos][last][sum][ans]=t;
	return t;
}
ll F(ll x){
	return dfs(check(x),-1,0,0,1);
}
int main(){
	a=read(),b=read();
	write(F(b)-F(a-1)); 
	return 0;
}
```


---


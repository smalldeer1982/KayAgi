# [COCI 2009/2010 #4] OGRADA

## 题目背景

Matjia 需要粉刷他的旧篱笆。

## 题目描述

篱笆是由 $n$ 块木板做成的，每块木板宽 $1$ 厘米，高度不一。为了方便快捷，他给自己买了一个宽 $x$ 厘米的超级油漆辊。然而超级油漆辊来了一个陷阱——Matija 必须始终使辊子紧密地整个接触木板，否则油漆会滴到四周并污渍所有东西。此外，辊子必须始终与地面平行，以防泄漏。这意味着为了让 Matija 安全地使用压路机，他需要选择 $x$ 块木板，并从最下面的木板的底部到顶部一次涂上油漆。然后，他选择一些其他的木板，油漆它们，以此类推。

这使得一些木板的部分没有上漆。Matija 必须用牙刷刷这些部分。这显然是相当乏味的，所以他请你帮他编写一个程序，求出他需要手动刷漆的最小面积。因为有不止一种方法可以做到这一点，他也想知道需要使用超级油漆辊的最少次数。

## 说明/提示

**【样例 1 解释】**

对于样例 $1$，Matjia 需要使用两次超级油漆辊。

- 第一次，用超级油漆辊粉刷第 $1,2,3$ 个木板，粉刷高度为 $3\text{ cm}$，因此粉刷面积为 $9\text{ cm}^2$。
- 第二次，用超级油漆辊粉刷第 $3,4,5$ 个木板，粉刷高度为 $4\text{ cm}$，因此粉刷面积为 $12\text{ cm}^2$。

因为两次粉刷有 $3\text{ cm}^2$ 的面积重叠，因此剩下的需要手动粉刷的面积为 $5+3+4+4+5-9-12+3=3\text{ cm}^2$。可以证明这样的方案需要手动粉刷的面积是最小的并且使用超级油漆辊的次数也是最少的。

具体可以结合下图理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/hrjc66u8.png)

**【数据范围】**

对于所有数据，$1\leqslant n\leqslant 10^6$，$1\leqslant x\leqslant 10^5$，$1\leqslant h_i<10^6$。

**【题目来源】**

本题来源自 **_[COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST 4](https://hsin.hr/coci/archive/2009_2010/contest4_tasks.pdf) T4 OGRADA_**，按照原题数据配置，满分 $100$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
5 3
5 3 4 4 5```

### 输出

```
3
2```

## 样例 #2

### 输入

```
10 3
3 3 3 3 3 3 3 3 3 3```

### 输出

```
0
4```

## 样例 #3

### 输入

```
7 4
1 2 3 4 3 2 1```

### 输出

```
4
4```

# 题解

## 作者：Hrz_OIer (赞：3)

~~P5186 和这道题怎么一模一样~~

# 思路 #

## 先考虑第一问 ##

显然这是个“滑动窗口”的模型。

但是把每个滑动窗口刷的面积加起来并不是答案，因为一个位置可能**会多次刷**。

考虑删去重复部分，当上一个滑窗高度为 $last$，这个为 $now$ 时，容易发现重合的部分为：

$$ \min \{{ last , now \}} \times (x − 1) $$

据此，就容易统计了。

code:

```cpp
//初始 sum 为木板高度和
	int lstans=0;
	for(int i=1;i<=n;++i){
		while(head<=tail&&a[q[tail]]>a[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		if(i>=x)
			mx[i-x+1]=a[q[head]]，//记录区间 [i-x+1,i] 的最小值，第二问用
			sum-=1ll*x*a[q[head]],
			sum+=1ll*min(a[q[head]],lstans)*(x-1),
			lstans=a[q[head]];}
```

## 考虑第二问 ##

我们记第一问求得区间 $[i, i + x − 1]$ 的最小值为 $mx_i$ 。
则位置 $i$ 被刷的高度 $color_i$ 为：

 $$ color_i = \max \{{mx_i−x+1, mx_i−x+2, · · · , mx_i\}} $$
 
这又是个单调队列的式子，可以单调队列优化。

最后，我们知道了每个位置要刷的高度，要求刷的次数。则用贪心可求出：

- 若 $color_i \ne color_i−1$，则肯定要分开来刷。

- 若有 k 个刷的高度相同的连续位置，要刷 $ \big\lceil \frac{k}{x} \big\rceil$ 次。

这样统计就行了。

code：

```cpp
	for(int i=1;i<=n;++i){
		while(head<=tail&&mx[q[tail]]<mx[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		brush[i]=mx[q[head]];}//记录刷的高度 
	int beg=-10000000,cnt=0;
	for(int i=1;i<=n;++i)
		//判断高度是否等于上一个，或者是太长刷不到了 
		if(brush[i]!=brush[i-1]||i>=beg+x)cnt++,beg=i;
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
#define int long long
int mx[N],q[N<<1],a[N],x,n,brush[N],head,tail,sum;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>x;
	for(int i=1;i<=n;++i)cin>>a[i],sum+=a[i];
	int lstans=0;
	for(int i=1;i<=n;++i){
		while(head<=tail&&a[q[tail]]>a[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		if(i>=x)
			mx[i-x+1]=a[q[head]],
			sum-=1ll*x*a[q[head]],
			sum+=1ll*min(a[q[head]],lstans)*(x-1),
			lstans=a[q[head]];}
	for(int i=1;i<=n;++i){
		while(head<=tail&&mx[q[tail]]<mx[i])tail--;
		while(head<=tail&&q[head]<=i-x)head++;
		q[++tail]=i;
		brush[i]=mx[q[head]];}
	int beg=-10000000,cnt=0;
	for(int i=1;i<=n;++i)if(brush[i]!=brush[i-1]||i>=beg+x)cnt++,beg=i;
	cout<<sum<<"\n"<<cnt;
	return 0;}
```

制作不易，点个赞吧！（ QAQ ）

---

## 作者：easy42 (赞：2)

来看一下这道题。
### 第一问
容易想到把所有面积减去涂了的面积。

那如何计算呢？

这似乎是“滑动窗口”的例题。

显然，每块区域涂的面积，就是这块高度的最小值再乘上 $k$。

这个东西，明显可用单调队列维护。

可是把所有的加起来，却有重复的情况。

看图：

![here](https://i.loli.net/2018/12/30/5c289875b3356.png)

设前一个高度为 $last$，当前高度为 $now$，$t$ 为 $last$ 与  $now$ 之间的最小值，则重叠部分就为 $t$ 与 $(k-1)$ 的积。

得到这个，跑一遍即可。

### 第二问
我们不是得到了要刷的面积吗？

直接扫一遍，如果这块不等于前面那块，或者刷子不够刷时，计数器加一。

### 代码
需要私信我。

---

## 作者：naroto2022 (赞：2)

# P7697 题解

### 前置知识

1. 单调队列求区间最值。（可以看后记）

### 题面

[原题传送门](https://www.luogu.com.cn/problem/P7697)

### 思路

#### 第一个答案

先看样例解析图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qpt1m21v.png)

我们需要满足题目刷的限制，保证刷子完全接触栅栏，也就是每次刷的时候不能刷到空的；

所以，我们可以求得在 $i$ 到 $i+x-1$ 刷的高度就是 $\min(a[j])(j\in[i,i+k-1])$。

我们用一个数组 $h$ 来记录这个值。

于是，两眼一瞪，就可以看出来这就是裸的单调队列求最小值嘛！简简单单的进行一次单调队列就可以求出 $h$。

当然，继续往下考虑，会发现，只有一个 $h$ 这个求区间的数组远远不够，我们需要的是一个能记录每个木板能刷到的最大值。

于是再设一个数组 $mx$ 来存每个木板能刷到的最大值。

由 $h,mx$ 数组的定义，我们可以知道 $mx[i]=\max(h[j])(j\in[i-k+1,i])$。

于是又一瞪，这不又是一个单调队列求区间最大值模板吗？简简单单解决了！

于是，第一问就解决了，只要累加一下 $a[i]-mx[i]$ 即可（原先高度减去最大能刷的高度）。

#### 第一问代码

```cpp
for(int i=1; i<=n; i++){//单调队列求最小值。
        while(head<=tail&&a[q[tail]]>a[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        if(i-x+1>=0) h[i-x+1]=a[q[head]];
    }
    head=1,tail=0;
    for(int i=1; i<=n; i++){//单调队列求最大值。
        while(head<=tail&&h[q[tail]]<h[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        mx[i]=h[q[head]];
    }
	for(int i=1; i<=n; i++) ans+=a[i]-mx[i];//记录第一个答案。
	printf("%lld\n",ans);
```


#### 第二个答案

来到了第二问，这一看，难道是要再写一遍？？？不不不，只要求出的 $mx$ 就足够了。有以下两种情况:

- $i\sim i+x-1$：如果遇到了 $mx[i]$ 不同的情况那就是要新刷一次，重新把不同的地方当 $i$ 来算。
- $i\sim i+x-1$：如果全部相同，那就新刷一次，把 $i+x$ 当做 $i$ 来算。

累加即可。

#### 第二问代码

```cpp
long long lst=0,nxt=0;
	for(int i=1; i<=n; i++){
		if(mx[i]!=lst||nxt<i){//长度超了或者两个不同 
			lst=mx[i];
			nxt=i+x-1;
			ans++;
		}
	}
```


### 总代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int MN=1000005;
long long n,x,a[MN],q[MN],h[MN],mx[MN],head=1,tail=0,ans;
int main(){
	scanf("%lld %lld",&n,&x);
	for(int i=1; i<=n; i++) scanf("%lld",&a[i]);
	for(int i=1; i<=n; i++){//单调队列求最小值。
        while(head<=tail&&a[q[tail]]>a[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        if(i-x+1>=0) h[i-x+1]=a[q[head]];
    }
    head=1,tail=0;//初始化。
    for(int i=1; i<=n; i++){//单调队列求最大值。
        while(head<=tail&&h[q[tail]]<h[i]) tail--;
        q[++tail]=i;
        while(head<=tail&&i-q[head]+1>x) head++;
        mx[i]=h[q[head]];
    }
	for(int i=1; i<=n; i++) ans+=a[i]-mx[i];//记录第一个答案。
	printf("%lld\n",ans);
	ans=0;//初始化。
	long long lst=0,nxt=0;
	for(int i=1; i<=n; i++){
		if(mx[i]!=lst||nxt<i){
			lst=mx[i];
			nxt=i+x-1;
			ans++;
		}
	}
    printf("%lld\n",ans);
	return 0;
}
```


### 后记

这是到练单调队列的好题，当然，你翻到这可能是你不咋了解单调队列，那我也来讲解一下吧。

#### 问题引入

[单调队列模板题](https://www.luogu.com.cn/problem/P1886)

#### 算法介绍

队列大家应该都知道，那单调队列单调队列，顾名思义就是要保持元素的单调性的队列。

#### 算法流程

其实由介绍就可以知道代码大概要怎么写了，我也不多说，会模拟的可以先自己去尝试尝试，实在不行，请自行理解下面的代码：

```cpp
//求最小值，最大值同理，代码不放，要自行思考才能完全理解这个算法 
head=1;tail=0;//为啥要这样呢?因为head要严格对应首元素，tail要严格对应尾元素，所以当tail>=head时，说明有元素。而一开始队列为空，说一要这样赋值。其实这跟普通队列一样。
for(int i=1; i<=n; i++){//a[i]表示当前要处理的值
    while(head<=tail&&q[tail]>=a[i]) tail--;//只要队列里有元素，并且尾元素比待处理值大，即表示尾元素已经不可能出场，所以出队。直到尾元素小于待处理值，满足"单调"。
    q[++tail]=a[i];//待处理值入队。
    p[tail]=i;//同时存下其编号
    while(p[head]<=i-k) head++;//如果队首元素已经"过时"，出队。
    if(i>=k) printf("%d ",q[head]);//输出最值，即队首元素。i>=k表示该输出，至于why就自己看题目。
}
```

#### 题目迁移

[好消息，坏消息](https://www.luogu.com.cn/problem/P2629)（值得一做的单调队列训练题）

---

## 作者：respect_lowsmile (赞：1)

同类题 [P5186 [COCI2009-2010#4] OGRADA](https://www.luogu.com.cn/problem/P5186)

单调队列问题。

### Solution:

首先，题目说了滚筒的宽度是固定的，而且每一次刷的高度是由最低的高度决定的。

也就是说我们每一次每一次刷的都是以当前点为起点的区间长度为 $ k $ 的最小值，还记的我们的滑动窗口吗？很明显就是求一段区间的最小值问题。


以样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/b67q56bp.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

区间长度为 $ 3 $，那么从 $ 1 $ 到 $ 3 $ 这个区间能刷到的最大高度就是 $ \min(a[i]) 1 \le i \le 3 $ 

类比一下，区间长度为 $ k $，第 $ i $ 到 $ i+k-1 $ 能刷到的最大高度就是 $ h[i]= \min(a[j]) $，$ j\le i $ 并且 $ j \le i+k-1 $，我们用单调队列维护即可。

我们发现在 $ 1-3 $ 这个区间的最小值是 $ 3 $，但是在 $ 3-5 $ 这个区间的最小值是 $ 4 $，所以 $ 3 $ 号木板能涂到的最大高度就是 $ 4 $，也就是说每个木板能涂到的最大高度 $ maxc[i]=max(h[j]) $,$ i-k+1 \le j $ 并且 $ j \le i $。

那第一问就非常简单了，用木板原来的长度减去能刷到的最大高度，就是需要用牙刷刷的面积。

现在我们考虑第二问：求用滚筒刷的次数。

还是以样例为例：


![](https://cdn.luogu.com.cn/upload/image_hosting/b67q56bp.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

我们可以发现刷了两次，因为在 $ 1-3 $ 这个区间中，$ maxc[1] \ne maxc[3] $，也就是说在一个区间内，如果两个木板刷的高度不同，是要多刷一次的。

还有一种情况，那就是超过了区间长度。

我们来看第二组样例：

```
10 3
3 3 3 3 3 3 3 3 3 3
```
很明显，每个木板刷的高度都一样，但是刷的次数却是 $ 4 $，因为每次最多只能刷 $ 3 $ 个木板。

所以我们得出结论：

如果木板刷的高度不同或者超出了区间长度，我们就要多刷一次。

我们可以开两个变量 $ hnow $ 和 $ bj $ ~~汉语拼音法造变量名~~，记录当前的边界和高度。

### code：
```cpp
/*
	单调队列
	date:2022.7.28
	worked by respect_lowsmile 
*/
#include<iostream>
#define int long long
using namespace std;
const int N=1e6+5;
int maxc[N],h[N],q[N],a[N];
int len,n,ans,cnt,head,tail;
signed main()
{
	scanf("%lld %lld",&n,&len);
	for(int i=1;i<=n;++i)
		scanf("%lld",&a[i]);
	head=1,tail=0;
	for(int i=1;i<=n;++i)
	{
		while(head<=tail&&q[head]<=i-len)  head++;
		while(head<=tail&&a[q[tail]]>a[i])  tail--;
		tail++;
		q[tail]=i;
		if(i-len+1>=0)  h[i-len+1]=a[q[head]];  
	}
	head=1,tail=0;
	for(int i=1;i<=n;++i)
	{
		while(head<=tail&&q[head]<=i-len)  head++;
		while(head<=tail&&h[q[tail]]<h[i])  tail--;
		tail++;
		q[tail]=i;
		maxc[i]=h[q[head]];
	}
	for(int i=1;i<=n;++i)
		ans+=a[i]-maxc[i];
	printf("%lld\n",ans);
	int hnow=0,bj=0;
	for(int i=1;i<=n;++i)
	{
		if(maxc[i]!=hnow||bj<i)
		{
			hnow=maxc[i];
			bj=i+len-1;
			cnt++;
		}
	}
	printf("%lld",cnt);
	return 0;
}
```

---

## 作者：ycy1124 (赞：0)

### 前言
[双倍经验](https://www.luogu.com.cn/problem/P5186)。
### 题意
现在有 $n$ 块宽度为 $1$，高度为 $h_i$ 的木板，他们的底边紧贴地面。现在你有一个宽为 $x$ 的刷子，你可以拿刷子来刷木板，但是你得保证刷的时候刷子不能超出木板的范围且刷子平行于地面。现在要求出刷子不能刷到的面积以及用刷子刷最多的面积时最少要刷的次数。
### 思路
先考虑如何求出刷子最多刷的面积。对于每个木板，这个木板所能刷到的最大面积为能覆盖他的所有长度为 $x$ 的区间内 $h_i$ 的最小值的最大值。考虑这个怎么求解，我们先跑一遍单调队列，求出每段区间刷的高度。再跑一遍单调队列求出每个点刷的高度即可。这样我们求出了第一问，接下来考虑第二问，我们现在已经得到了所有木板最终刷的高度，我们假设一段长为 $w$ 的被刷的高度相同的木板，那么这一段的最少刷的次数等于 $\lceil w/x \rceil$。证明我们可以用贪心，每次一定刷最多的木板，在可以不重叠的时候紧挨着上一次的右端继续刷。
### 代码
具体的单调队列实现以及求解见代码。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,x,sum,a[1000005],b[1000005],c[1000005],las,ans,js;
struct Node{
    int w,i;
};
deque<Node>q;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>x;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i];//求出总面积
    }
    for(int i=1;i<=n;i++){
        if(i<x){//还没有一段长度大于等于x的区间。
            while(!q.empty()&&q.front().w>=a[i]){//将前面比他大的木板弹掉，因为需要的是一段区间内最小的木板，所以他没有贡献
                q.pop_front();
            }
            q.push_front({a[i],i});
            continue;
        }
        while(!q.empty()&&q.front().w>=a[i]){
            q.pop_front();
        }
        q.push_front({a[i],i});
        while(!q.empty()&&q.back().i+x<=i){//将已经超出这个区间的点弹掉
            q.pop_back();
        }
        b[i-x+1]=q.back().w;//表示在i-x+1到i这段区间内最高能刷b[i-x+1]
        las=q.back().w;
    }
    while(!q.empty()){
        q.pop_back();
    }
    for(int i=1;i<=n-x+1;i++){//求每个木板最终被刷的高度
        while(!q.empty()&&q.front().w<=b[i]){//注意这里弹出的操作改了，每个木板最终被刷的高度为他所在的所有区间内刷的最大值。所以前面的小的就没贡献了。
            q.pop_front();
        }
        q.push_front({b[i],i});
        while(!q.empty()&&q.back().i+x<=i){//覆盖不到当前点的区间弹掉
            q.pop_back();
        }
        c[i]=q.back().w;//当前点最终被刷的高度
    }
    for(int i=n-x+2;i<=n;i++){//后面的一些点不会加入新的区间，可以画个图理解一下
        while(!q.empty()&&q.back().i+x<=i){
            q.pop_back();
        }
        c[i]=q.back().w;
    }
    js=1;//记录每段连续区间的长度
    sum-=c[1];
    for(int i=2;i<=n;i++){
        sum-=c[i];//问一求解
        if(c[i]!=c[i-1]){//当前连续段结束
            ans+=ceil(1.00*js/x);//计算答案
            js=1;//新的一段
        }
        else{
            js++;
        }
    }
    ans+=ceil(1.00*js/x);//别忘了结尾再加
    cout<<sum<<'\n'<<ans;
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/203634444)。

---

## 作者：1234567890sjx (赞：0)

为什么第一感觉是对序列分治啊啊啊。。。第一问：考虑正难则反，计算所有没有上色的区域的面积。显然若刷子刷的位置是 $[l,l+x-1]$，若该段区间内元素的最小值是 $w$，则对答案的贡献为 $w\times k$。但是这显然是不对的。考虑容斥掉重复贡献。容易发现若 $[l-1,l+x-2]$ 区间最小值为 $w_1$，$[l,l+x-1]$ 区间最小值为 $w_2$，则对答案重复的贡献了 $\min(w_1,w_2)\times k$，减去即可。可以使用 ST 表维护，但是因为定长不变区间可以使用单调队列做到 $O(n)$。

然后考虑第二问，这就很简单了。直接按照顺序扫描一遍答案，设当前刷到了位置 $i$，当前位置需要扫的高度是 $h_i$，则有两种情况：第一种是说上一次刷的位置宽度不够刷不到当前位置，第二种是说 $h_i$ 和 $h_{i-1}$ 不同（包括 $i=1$），需要额外再刷一次。同样可以使用单调队列做到 $O(n)$。

于是这个题就做完了。时间复杂度为 $O(n)$。（虽然但是我觉得不止绿吧）

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7697)。

## 解题思路

单调队列。

询问最小刷不到的面积，可以考虑极限情况。

把每一段长为 $k$ 的栅栏都刷一遍,如果刷不到那就无法刷到。

注意，因为刷子必须完全接触栅栏，所以刷子左端点有限制。

对于最小刷不到的面积，用单调队列 $O(n)$ 处理。

对于最少刷不到的次数，用贪心处理。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int n,x,high,r,h[maxn],minn[maxn],maxx[maxn];
long long ans;
deque<int>q;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>x;
    for(int i=1;i<=n;++i){
        cin>>h[i];
        ans+=h[i];
    }
    for(int i=1;i<x;++i){
        while(!q.empty()&&h[q.back()]>=h[i])
            q.pop_back();
        q.push_back(i);
    }
    for(int i=x;i<=n;++i){
        while(!q.empty()&&h[q.back()]>=h[i])
            q.pop_back();
        q.push_back(i);
        while(!q.empty()&&q.front()<=i-x)
            q.pop_front();
        minn[i-x+1]=h[q.front()];
    }
    for(int i=1;i<x;++i){
        while(!q.empty()&&minn[q.back()]<=minn[i])
            q.pop_back();
        q.push_back(i);
        maxx[i]=minn[q.front()];
        ans-=maxx[i];
    }
    for(int i=x;i<=n;++i){
        while(!q.empty()&&minn[q.back()]<=minn[i])
            q.pop_back();
        q.push_back(i);
        while(!q.empty()&&q.front()<=i-x)
            q.pop_front();
        maxx[i]=minn[q.front()];
        ans-=maxx[i];
    }
    cout<<ans<<'\n';
    ans=0;
    for(int i=1;i<=n;++i)
        if(maxx[i]!=high||r<i){
            ++ans;
            high=maxx[i];
            r=i+x-1;
        }
    cout<<ans;
    return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析——第一问

用牙膏涂的最少就是用滚筒刷的最多，相邻 $X$ 个木板最多能涂的高度 $t_i=\min_{i=j}^{j+x-1} \{h_i\}$（就是相邻 $X$ 块的最低高度）。

然后每个木板（一下假设编号是 $i(1\le i \le n)$）可以被 $(i-x,i]$ 和 $[i, i+x)$ 之间的所有区间包含。所以每一块木板的最多滚筒涂的面积就是这两个区间之间的所有区间最大值 $g_i$。


格式化的说：$g_i=\max_{j=i-x+1}^{i}t_j$。

提示：可以使用单调队列维护 $t,g$（俩都可以维护），代码里 $h,t,g$ 分别是 $a,g,h$。

## 代码实现——第一问

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,x,a[1000001],q[3000001],f,r,g[1000001],h[1000001],ans;//q是单调队列
signed main(){
    cin>>n>>x;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)//类似窗口滑动、出队
            f++;
        while(f<r&&a[i]<a[q[r]])//类似单调栈因单调性出队
            r--;
        q[++r]=i;
        if(i-x+1>=0)
            g[i-x+1]=a[q[f+1]];//i-x+1~i的最大涂量
    }
    f=r=0;//重制队列
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)
            f++;
        while(f<r&&g[i]>g[q[r]])
            r--;//出队类似上面
        q[++r]=i,h[i]=g[q[f+1]];//储存i块木板的涂量
    }
    for(int i=1;i<=n;i++)
        ans+=a[i]-h[i];//记住，求得是牙膏刷的最小面积
    cout<<ans<<'\n';
    return 0;
}
```

如何检测自己写的第一问是对的？

测试点全 WA，提示信息都是 `Wrong Answer.wrong answer Too short on line 2.`时表示第一问你做对了。

## 题目分析——第二问

再写一遍？不不不，太难写了。只需要根据第一问得到的 $g$ 进行推算就行。

首先从 $k \sim X+k-1$ 如果遇到与 $g_k$ 不同的就说明中途又刷了一次，重新把不同的地方当 $k$ 算。

第二如果 $k \sim X+k-1$ 全相同那就从新开始刷了，$X+k$ 当做新 $k$ 算。

## 代码实现——第二问

```cpp
ans=0;
for(int i=1,lst=0,nxt=0;i<=n;i++){//lst维护上面的k，nxt是X+k-1
    if(h[i]!=h[lst])//不同
        ans++,lst=i,nxt=i+x-1;
    if(nxt<i)//长度超了
        ans++,lst=i,nxt=i+x-1;
}
cout<<ans;
```

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,x,a[1000001],q[3000001],f,r,g[1000001],h[1000001],ans;
signed main(){
    cin>>n>>x;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)
            f++;
        while(f<r&&a[i]<a[q[r]])
            r--;
        q[++r]=i;
        if(i-x+1>=0)
            g[i-x+1]=a[q[f+1]];
    }
    f=r=0;
    for(int i=1;i<=n;i++){
        while(f<r&&q[f+1]<=i-x)
            f++;
        while(f<r&&g[i]>g[q[r]])
            r--;
        q[++r]=i,h[i]=g[q[f+1]];
    }
    for(int i=1;i<=n;i++)
        ans+=a[i]-h[i];
    cout<<ans<<'\n';
    ans=0;
    for(int i=1,lst=0,nxt=0;i<=n;i++){
        if(h[i]!=h[lst])
            ans++,lst=i,nxt=i+x-1;
        if(nxt<i)
            ans++,lst=i,nxt=i+x-1;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：WisNourx_ (赞：0)

## 题目大意
给定一个直方图，每次放一个以 $x$ 为宽度，高度不限的矩形，求不能被这些矩形覆盖的最小面积以及在最小面积的前提下最少放置多少个矩形。

## 分析
题目很易懂，一眼就是单调队列。

对于第一问，其实把样例图仔细看一看就知道怎么求了。

![](https://i.loli.net/2018/12/30/5c289875b3356.png)

第三块木板可以分别被一个高度为 $3$ 和一个高度为 $4$ 的矩形覆盖，而第三块木板的可以放置矩形的最大高度是 $4$。

所以对于每块木板，都有一个 $maxh_i$ 代表往右 $x$ 个可以放置矩形的最大高度。而对于一些被多个矩形覆盖的木板，则是取其中的最大值，记为 $max_i$，即为这块木板可以被覆盖的最大高度。 

第一问答案也就显而易见了，即为 $\sum^n_{i=1} h_i-max_i$。

$\ $

对于第二问，需要多观察。

发现一个很显然的结论：当木板的 $max_i$ 不相同时，一定会对答案产生一次贡献（要再刷一次）。

而样例 $2$ 又提醒了我们：在超出 $x$ 的时候，也会对答案产生一次贡献。

两者结合起来就是第二问答案。

套个滑动窗口，然后就这么做完了（）。

## Code
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

char buf[1<<20], *p1=buf, *p2=buf;
#define getchar() (p1==p2&&(p2=buf+fread(p1=buf, 1, 1<<20, stdin), p1==p2)?EOF:*p1++)
template <typename T>
void read(T &x)
{
	x=0;int f=1;char c=getchar();
	while (!isdigit(c)) f=(c=='-')?-1:1, c=getchar();
	while (isdigit(c)) x=(x<<1)+(x<<3)+c-'0', c=getchar();
	x*=f;
}

typedef long long LL;
const int N=1e6+10;
int n, k, a[N], b[N];
int q[N], l, r, maxx[N];

int main()
{
	read(n), read(k);
	for (int i=1;i<=n;i++) read(a[i]);
	l=1, r=0;
	for (int i=1;i<=n;i++)
	{
		while (l<=r&&i-q[l]+1>k) l++;
		while (l<=r&&a[q[r]]>a[i]) r--;
		q[++r]=i;
		if (i>=k) b[i-k+1]=a[q[l]];
	}
	l=1, r=0;
	for (int i=1;i<=n;i++)
	{
		while (l<=r&&i-q[l]+1>k) l++;
		while (l<=r&&b[q[r]]<b[i]) r--;
		q[++r]=i;maxx[i]=b[q[l]];
	}
	LL sum=0, ans=0;int last=0;
	for (int i=1;i<=n;i++) sum+=a[i]-maxx[i];
	for (int i=1, cnt=1;i<=n;i++)
	{
		if (last!=maxx[i]||cnt>k)
		{
			last=maxx[i];
			cnt=1;
			ans++;
		}
		cnt++;
	}
	printf("%lld\n%lld", sum, ans);
	return 0;
}
```

---

## 作者：xhz0311 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7697)   

## 思路分析
### 第一问
设 $h_{i}$ 表示第 $i$ 条木板的高度，$a_{i}$ 表示 $i \sim (i+x-1)$ 条木板中最低者。由于刷子不能离开木板，所以如果选择要刷 $i \sim (i+x-1)$ 条木板，那么能刷到的高度即为 $a_{i}$。   
由于在刷第 $i$ 条木板时，可以选择刷 $(i-x+1) \sim i$ 号或 $(i-x+2) \sim (i+1)$ 号或 $\dots$ 或 $i\sim (i+x-1)$ 号，所以第 $i$ 条木板能刷到的最大高度即为 $a_{i-x+1}\sim a_{i}$ 的最大值，设为 $ans_{i}$。      
那么第一问所求最小面积即为每一条高度减每一条所能刷到的最大高度的差之和。

也即：   
$a_{i}=\min h_{j} \ (i\le j \le i+x-1) \ \ \ ans_{i}=\max a_{j} \ (i-x+1\le j\le i)$，第一问答案为 $\sum(a_{i}-ans_{i})$。

只用先对 $h$ 跑一遍单调增队列得到 $a$，再对 $a$ 跑一遍单调减队列得到 $ans$ 即可。

### 第二问
思考什么时候需要再刷一次。

- 刷的高度发生变化的时候要重新刷一次（即 $ans_{i} \neq ans_{i+1}$ 时）。
- 虽然高度没变化，但刷子不够长了，需要再刷一次。

扫一遍 $ans$ 数组。记录下上次刷的高度 `lasth` 和上次是从第几号刷起 `lastn`，遇到上面两种情况时 `cnt++` 并更新 `lasth lastn` 即可。

### 注意
对 $h$ 的单调递增队列循环内注意 `if (i>=x)` 和 `a[i-x+1]`。这是因为要入队前 $i$ 项元素，才能求得 $a_{i-x+1}$（从 $(i-1+x)$ 号到 $i$ 号木条最短高度）。

要开 `long long`，[否则](https://www.luogu.com.cn/record/132360124)。
### 代码
```
#include <bits/stdc++.h>
#define int long long//第一次提交没开longlong见祖宗了
using namespace std;
int n,x,h[1000005],a[1000005],ans[1000005];
int q[1000005],l=1,r=0;
int cnt,sum,lasth,lastn;
signed main()
{
	scanf("%lld %lld",&n,&x);
	for (int i=1; i<=n; i++)
	{
		scanf("%lld",&h[i]);
	}
	
	//对h的单调递增队列
	for (int i=1; i<=n; i++)
	{
		while (l<=r && h[i]<=h[q[r]]) r--;
		q[++r]=i;
		while (l<=r && i-q[l]>=x) l++;
		if (i>=x) a[i-x+1]=h[q[l]];
	}
	/*
	for (int i=1; i<=n; i++)
	{
		cout<<a[i]<<" ";
	}
	*/
	
	memset(q,0,sizeof(q)); l=1,r=0;
	
	//对a的单调递增队列
	for (int i=1; i<=n; i++)
	{
		while (l<=r && a[i]>=a[q[r]]) r--;
		q[++r]=i;
		while (l<=r && i-q[l]>=x) l++;
		ans[i]=a[q[l]];
	}
	/*
	for (int i=1; i<=n; i++)
	{
		cout<<ans[i]<<" ";
	}
	*/
	
	for (int i=1; i<=n; i++)
	{
		sum+=h[i]-ans[i];
		if (ans[i]!=ans[i-1] || i-lastn>=x)
		{
			lasth=ans[i];
			lastn=i;
			cnt++;
		}
	}
	cout<<sum<<endl<<cnt;
	return 0;
}
```
[$\text{AC 记录}$](https://www.luogu.com.cn/record/133891341)

---


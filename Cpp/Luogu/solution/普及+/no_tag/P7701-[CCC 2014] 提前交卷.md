# [CCC 2014] 提前交卷

## 题目描述

你正在一个狭窄而又长的礼堂里考试，礼堂一共有 $n$ 排，标号从前到后分别为 $1$ 到 $n$。每排有 $6$ 个座位，左边 $3$ 个，右边 $3$ 个，中间是过道。每个座位都有一个从 A 到 F 的字母标识，其中最左的座位的标识是 A，最右的座位的标识是 F，过道在座位标识为 C 和 D 的座位之间，礼堂同时还有两个保密室，一个在最前面（第一排前面），一个在最后面（第 $n$ 排后面）。

礼堂里的每个座位一开始被刚好一个考生占用。然而，在考试过程中，$m$ 个不同的考生决定完成所有他们会做的题后依次离开礼堂。第 $i$ 个考生在座位 $r_ic_i$，其中 $c_i$ 是 A 到 F 的字母之一。当考生离开礼堂时，他们必须在任意一个保密室等待到考试结束。幸运的是，保密室能容下任意多的考生。

考生不仅关心试题本身，他们还关心怎么样可以最舒服的考试。因此，他们协作以最小化他们的不满度之和。一个考生的不满度的计算方式是 $Ax+By$，其中 $A,B$ 为常数，$x$ 为去往保密室时经过的考生人数，具体将在下面详述，$y$ 是在考生进入保密室之前保密室内的人数。注意如果一个考生不离开他的考位，那么他的不满度为 $0$。

当一个考生从一个考位走往保密室时，他在去往过道时必须先经过同排的考生，然后走过从这行到第一行或第 $n$ 行（取决于所选的保密室）的邻近过道的考生。注意走过空的座位不影响 $x$ 值。

你能帮助他们最小化他们的不满度之和吗？

## 说明/提示

其中一个最优策略是，第一个提前离开的考生去最前面的保密室，经过 $6$ 个考生（分别是 `3D`、`3C`、`2D`、`2C`、`1D`、`1C`），不满度为 $3\times6+4\times0=18$。第二个提前离开的考生也去最前面的保密室，只经过 $1$ 个考生，即 `1C`，然后他发现保密室里有 $1$ 个考生，不满度为 $7$。第三个提前离开的考生去最后面的保密室，经过 $1$ 个考生，不满度为 $3$。第四个提前离开的考生去最前面的保密室，经过 $1$ 个考生（因为座位 `1D` 是空的），不满度为 $11$。最后，第五个提前离开的考生去最后面的保密室，经过 $4$ 个考生，发现保密室里有 $1$ 个人，不满度为 $16$。所有考生总的不满度为 $55$。

对于 $60\%$ 的数据，$1\le m\le5000$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le m\le6n$，$1\le A,B\le 10^9$。

## 样例 #1

### 输入

```
5 5 3 4
3E
1D
5C
1E
4A```

### 输出

```
55```

# 题解

## 作者：Larryyu (赞：5)

## _Description_
在一个教室里有 $n$ 排座位，每排有 $6$ 个，从左至右标号分别为 ```ABCDEF```，其中 ```C``` 和 ```D``` 中有过道，通往教室前端和后端的两个房间，每个房间最开始没有人,每个座位上开始都有人。

有 $m$ 个不同的学生会**依次**提前交卷，先从这一排走到过道上，在从过道走到前面或后面的房间里。每个提前交卷的学生有一个不满度，表示为 $A\times x+B\times y$，其中 $A,B$ 是给定的常数，$x$ 为经过的同学数量，由过道两侧的同学以及在过道与座位之间的同学组成（不包含自己）。$y$ 为在到达房间前房间内的人数。

你需要安排这些学生是去前面还是后面的房间，求不满度之和的最小值。
## _Solution_
画个图：
```
  前端
ABC||DEF
ABC||DEF
ABC||DEF
  后端
```
暴力就是 ```dp``` 求解。

本题最关键的性质就是在确定两个房间最终分别有多少人后，可以直接算出不满度中 $B\times y$ 的部分，同时第 $i$ 个人去前面和去后面的人数是确定的。

设前面的房间有 $i$ 个人，后面的有 $m-i$ 个人，那么不满度之和的后半部分就是 $B\times(\dfrac{i\times(i-1)}{2}+\dfrac{(m-i)\times(m-i-1)}{2})$。

求经过了多少人，就先将其分为两个部分，走到过道经过多少人就直接分讨当前座位的编号，开 $vis_{i,j}$ 记录第 $i$ 排第 $j$ 个座位上还有没有人。过道上经过的人相当于一个前缀和，$sum_i$ 表示从第 $i$ 排走到教室前面经过的人数，如果在他之前过道上有人离开就实时更新，用树状数组维护。

注意如果他就是坐在过道上的，要先更新 $sum$ 再算值，不然会把自己也算进去。

这样我们只需要判断一个学生是去前面还是去后面，设去前面不满度为 $u_i$，去后面为 $d_i$。

假设所有人都先去了前面，将每个学生的 $u_i-d_i$ 从大到小排序，这样选前面 $k$ 个去后面肯定更优，然后枚举 $k$ 的所有情况（$0\sim m$），对于每种情况算出不满度之和，然后取最小即可。
## _Code_
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
long long A,B;
long long tr[100010];
bool vis[100010][8];
struct node{
	long long u,d;
}a[100010];
int lowbit(int x){
	return x&(-x);
}
void add(int x,int val){
	for(int i=x;i<=n;i+=lowbit(i)){
		tr[i]+=val;
	}
}
long long query(int x){
	int ans=0;
	for(int i=x;i>=1;i-=lowbit(i)){
		ans+=tr[i];
	}
	return ans;
}
void read(int &x,int &y){  //特殊读入方式
	x=0;
	string s;
	cin>>s;
	for(int i=0;i<s.size()-1;i++){  //得出排数
		x=(x<<3)+(x<<1)+s[i]-'0';
	}
	y=s[s.size()-1]-'A'+1;
}
bool cmp(node x,node y){
	return (x.u-x.d)>(y.u-y.d);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>A>>B;
	for(int i=1;i<=n;i++){
		add(i,2);
		for(int j=1;j<=6;j++){
			vis[i][j]=1;
		}
	}
	long long tmp=0;
	for(int i=1;i<=m;i++){
		int x,y;
		read(x,y);
		if(y==1) tmp+=vis[x][2];  //走到过道上要经过多少人
		if(y==6) tmp+=vis[x][5];
		if(y==3||y==4) add(x,-1);  //在过道上就更新sum
		vis[x][y]=0;  //记得赋为0
		a[i].u+=query(x),a[i].d+=query(n)-query(x-1);  //去前面和去后面，后面减的x-1是因为这一排的sum也要算
		tmp+=a[i].u;  //全都去前面经过的人数
	}
	sort(a+1,a+1+m,cmp);
	long long sum=0,ans=tmp*A+m*(m-1)/2*B;  //k=0时的情况
	for(int i=1;i<=m;i++){
		sum+=a[i].u-a[i].d;  //更新经过的人数
		ans=min(ans,tmp*A-sum*A+(i*(i-1)/2)*B+((m-i)*(m-i-1)/2)*B);  //记得加上B*y的部分
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：wjh2011 (赞：5)

由于考生是按顺序离开的，所以当他确定去前面还是去后面后， $x$ 是固定的，只要考虑 $y$ 的影响。

由于考生去前面还是去后面会影响 $y$ 的大小，不好考虑，所以我们考虑枚举有多少人去前面的保密室，多少人去后面的保密室。

我们先让所有人都去前面的保密室，然后枚举有多少人去后面的保密室。假设有 $i$ 人去后面的保密室。如果一个人去前面的保密室要经过 $a$ 个人，去后面的保密室要经过 $b$ 个人，那么我们应该让 $b-a$ 较小的人去后面的保密室。

假设第 $i$ 个人去前面经过 $a_i$ 个人，去后面经过 $b_i$ 个人，所以这题的解法就是按 $b_i-a_i$ 排序，其中 $a_i,b_i$ 可以用树状数组维护。

最后的答案为：
$$\min_{i=1}^m((\sum_{j=1}^ib_i+\sum_{j=i+1}^ma_i)\times x+(i\times(i-1)/2+((m-i)\times(m-i-1)/2))\times y)$$

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
#define lowbit(x) (x & (-x))
#define int long long
int n, m, a, b, ans, r[N * 6], f[N], x[N * 6], sum[N * 6];
bool ok[N][6];
char c[N * 6];
void update(int x, int y) { while (x <= n) f[x] += y, x += lowbit(x); }
int query(int l, int r) {
	l--; int ans = 0;
	while (l) ans -= f[l], l -= lowbit(l);
	while (r) ans += f[r], r -= lowbit(r);
	return ans;
}
signed main() {
	cin >> n >> m >> a >> b;
	for (int i = 1; i <= m; i++) cin >> r[i] >> c[i];
	for (int i = 1; i <= n; i++) update(i, 2);
	for (int i = 1; i <= m; i++) {
		int tmp1 = 0, tmp2 = 0;
		if (c[i] == 'A') tmp1 = tmp2 = !ok[r[i]][1];
		if (c[i] == 'F') tmp1 = tmp2 = !ok[r[i]][4];
		ok[r[i]][c[i] - 'A'] = 1;
		if (c[i] == 'C' || c[i] == 'D') update(r[i], -1);
		tmp1 += query(1, r[i]), tmp1 *= a;
		tmp2 += query(r[i], n), tmp2 *= a;
		ans += tmp1;
		x[i] = tmp2 - tmp1;
	}
	sort(x + 1, x + m + 1);
	for (int i = 1; i <= m; i++) sum[i] = sum[i - 1] + x[i];
	int minn = 1e18;
	for (int i = 0; i <= m; i++) minn = min(minn, sum[i] + (i * (i - 1) / 2 + (m - i) * (m - i - 1) / 2) * b);
	cout << ans + minn;
	return 0;
}
```

---

## 作者：modfish_ (赞：1)

我竟然在一道绿题上浪费了三个小时……好在还是做出来了。

## 思路
记 $fr_i$ 为第 $i$ 个离开的考生去前面保密室经过的考生数，$bc_i$ 为去后面保密室经过的考生数，$x_i$ 为在最优策略下每一个考生经过的考生数，$y_i$ 为第 $i$ 个考生到达的保密室内的考生数，则答案为：

$$\sum_{i=1}^{m}Ax_i+By_i$$

即：

$$\sum_{i=1}^{m}Ax_i+\sum_{i=1}^{m}By_i$$

看一看右边，只要确定了去前面保密室的学生人数 $p$，那么前面保密室产生的贡献就是 $0+1+\dots +(p-1)=\frac{p(p-1)}{2}$，后面保密室同理，为 $\frac{(m-p)(m-p-1)}{2}$。

再看左边，显然每一个 $fr_i$ 和 $bc_i$ 都可以处理出来，我当时没细想，就用了两棵树状数组维护从第 $i$ 排到最前和最后的差分数组，总之是 $O(m\log n)$ 的。

接下来就是要在所有考生中，选出 $p$ 个去前面，剩下 $m-p$ 个去后面，使总代价最小。

下面是教练思路：

先让所有人都去后面，这样算出总代价 $ans=\sum_{i=1}^{m}bc_i$，然后考虑让第 $i$ 个人去到后面，此时总代价变为 $ans+fr_i-bc_i$。为了使其最小，我们应使 $fr_i-bc_i$ 尽可能小。所以将所有考生按照 $fr_i-bc_i$ 的顺序排序，然后一边扫过去，对于每种情况的 $ans\times A+\frac{i(i-1)}{2}\times \frac{(m-i)(m-i-1)}{2}\times B$ 取最小值即可。

然后是我的玄学思路：

当时我是在考虑将所有考生排序，使得对于任意 $1\leq k<m$，使 $\sum_{i=1}^{k}fr_i+\sum_{i=k+1}^{m}bc_i$ 最小化，这样枚举去往前面的考生数目，然后就可以直接前后缀和得到当前情况的答案，最后取最小值。

接着，排序和贪心在一起，我灵（想）光（了）一（很）闪（久），就想用邻项交换试一试。

考虑任意一个 $1\leq k<m-1$，此时前 $k$ 个考生去前面的总代价为：

$$\sum_{i=1}^{k}fr_i+\sum_{i=k+1}^{m}bc_i$$

也就是：

$$\sum_{i=1}^{k-1}fr_i+\sum_{i=k+2}^{m}bc_i+fr_k+bc_{k+1}$$

若交换第 $k$ 个和第 $k+1$ 个考生，则总代价变为：

$$\sum_{i=1}^{k-1}fr_i+\sum_{i=k+2}^{m}bc_i+bc_k+fr_{k+1}$$

如果交换前的情况优于交换后的情况，则有：

$$\sum_{i=1}^{k-1}fr_i+\sum_{i=k+2}^{m}bc_i+fr_k+bc_{k+1}<\sum_{i=1}^{k-1}fr_i+\sum_{i=k+2}^{m}bc_i+bc_k+fr_{k+1}$$

也就是：

$$fr_k+bc_{k+1}<bc_k+fr_{k+1}$$

整理，得：

$$fr_k-bc_k<fr_{k+1}-bc_{k+1}$$

最后殊途同归，还是得出了按照 $fr_i-bc_i$ 排序的结论。~~但是我的做法的正确性我自己都证不出来~~，在此纯属图一乐，分享一下：邻项交换还是很好用的。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5 + 5;
const long long INF = 1e18;

struct node{
	long long fr, bc;
}st[maxn];
long long n, m;
long long a, b;
int ch[maxn][7];
long long tr[maxn][3], sum1[maxn], sum2[maxn];

bool cmp(node x, node y){
	if(x.fr - x.bc == y.fr - y.bc) return x.fr < y.fr;
	return x.fr - x.bc < y.fr - y.bc;
}
int lb(int x){
	return x & -x;
}
void update(int id, long long k, int d){
	for(int i = id; i <= n; i += lb(i)){
		tr[i][d] += k;
	}
}
long long query(int id, int d){
	if(id == 0) return 0;
	long long s = 0;
	for(int i = id; i > 0; i -= lb(i)){
		s += tr[i][d];
	}
	return s;
}
long long front(int x, int y){
	long long mi = 0;
	if(y <= 3) for(int i = y; i < 3; i ++) mi += ch[x][i];
	else for(int i = 5; i <= y; i ++) mi += ch[x][i];
	return mi + query(x, 1);
}
long long back(int x, int y){
	long long mi = 0;
	if(y <= 3) for(int i = y; i < 3; i ++) mi += ch[x][i];
	else for(int i = 5; i <= y; i ++) mi += ch[x][i];
	return mi + query(n - x + 1, 2);
}

int main(){
	scanf("%lld %lld %lld %lld", &n, &m, &a, &b);
	for(int i = 1; i <= n; i ++){
		for(int j = 1; j <= 6; j ++){
			ch[i][j] = 1;
		}
		update(i, 2, 1);
		update(n - i + 1, 2, 2);
	}
	long long ans = INF;
	for(int i = 1; i <= m; i ++){
		int x, y;
		char c;
		scanf("%d%c", &x, &c);
		y = c - 'A' + 1;
		ch[x][y] = 0;
		if(y == 3 || y == 4){
			update(x, -1, 1);
			update(n - x + 1, -1, 2);
		}
		st[i].fr = front(x, y), st[i].bc = back(x, y);
	}
	sort(st + 1, st + m + 1, cmp);
	for(int i = 1; i <= m; i ++) sum1[i] = sum1[i - 1] + st[i].fr;
	for(int i = m; i >= 1; i --) sum2[i] = sum2[i + 1] + st[i].bc;
	for(long long i = 0; i <= m; i ++){
		long long sans = (sum1[i] + sum2[i + 1]) * a + (i * (i - 1) / 2 + (m - i) * (m - i - 1) / 2) * b;
		ans = min(ans, sans);
	}
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：DDF_ (赞：0)

## 题面

有 $m$ 个人分布在 $6 \times n$ 的座位中，这 $m$ 人**按顺序**从它的座位走到位于中央的走廊，然后往前或往后走进第一排前或最后一排后的一个房间。设对于一个人，它经过的人数为 $x$，房间里人数为 $y$，那么它的不满度为 $Ax+By$。最小化所有人不满度的和。

## 题解

你好。

可以发现按顺序这一点很重要，由此推出对于每个人，它往前往后走所经过的人数总是不变。

所以可以预处理第 $i$ 个人往前走的代价 $a_{i}$，往后走的代价 $b_{i}$。

然后，若上面的房间有 $x$ 个人，则下面的房间就有 $m-x$ 个人，这样的代价为 $A(\sum_{i=0}^{x-1}i+\sum_{i=0}^{m-x-1}i)$，可以用等差数列求和公式直接推出。

于是就可以这样想：若 $m$ 个人全都去前面的房间，我们要从中抽取 $x$ 个人去后面的房间，那么如何使代价最小。

从贪心的角度，可以发现选取能省代价最多的 $x$ 个人即可，于是将 $a$ 数组和 $b$ 数组按照 $a_{i}-b_{i}$ 排序。

接着，枚举 $x \in [0,m]$，前 $x$ 个去后面，后 $m-x$ 个去前面，预处理排序后 $a_{i}$ 和 $b_{i}$ 的前缀和，就可以完整地计算代价了。

对于 $a$ 和 $b$ 数组的预处理，可以用数据结构进行维护。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+2;
ll n,m;
char s[10];
ll A,B,ans;
ll tr[N];
bool mp[N][8];
struct node{
	ll a,b;
} p[6*N];
int lowbit(int x) {return x&(-x);}
void add(int x,int val) {
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=val;
	return;
}
ll sum(int x) {
	int sum=0;
	for(int i=x;i;i-=lowbit(i)) sum+=tr[i];
	return sum;
}
bool cmp(node a,node b) {
	return (a.a-a.b)>(b.a-b.b);
}
int main() {
	scanf("%lld%lld%lld%lld",&n,&m,&A,&B);
	for(int i=1;i<=n;i++) {add(i,2);for(int j=1;j<=6;j++) mp[i][j]=true;}
	for(int i=1;i<=m;i++) {
		cin>>s;
		int x=0,y=s[strlen(s)-1]-'A'+1;
		for(int i=0;i<strlen(s)-1;i++) x=x*10+s[i]-'0';
		if(y==1) p[i].a+=mp[x][2],p[i].b+=mp[x][2];
		if(y==6) p[i].a+=mp[x][5],p[i].b+=mp[x][5];
		if(y==3||y==4) add(x,-1);
		mp[x][y]=false;
		p[i].a+=sum(x),p[i].b+=sum(n)-sum(x-1);
	}
	sort(p+1,p+1+m,cmp);
	for(int i=1;i<=m;i++) p[i].a+=p[i-1].a,p[i].b+=p[i-1].b;
	ans=1e16;
	for(ll i=0;i<=m;i++) ans=min(ans,A*(p[i].b+p[m].a-p[i].a)+B*(i*(i-1ll)/2ll+(m-i-1ll)*(m-i)/2ll));
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：tbdsh (赞：0)

# 题意简述

[题目传送门](https://www.luogu.com.cn/problem/p7701)

一个考场里有 $n$ 排，每排有 $6$ 个座位，从左至右依次编号为 $\text{A}\sim \text{F}$。过道在编号为 $\text{C},\text{D}$ 的座位中间。

现在有 $m$ 个人想提前交卷。他需要经过同排的考生走到这一排的过道，然后经过过道两侧的考生直接前往考场前、后的任意一个保管室。一个提前交卷的人的不满度为 $A\times x+B\times y$。其中，$A,B$ 为常数，$x$ 是他在去往保管室时经过的人的数量，$y$ 是在他之前就已经到达保管室的人的数量。

现在给定每个提前交卷的人的座位号。请你安排他们要去的保管室，使得每个人的不满度的和最小。输出这个最小值。

# 分析
因为 $A,B$ 是常数，所以我们暂时先不管。

对于 $x$ 来说，由于交卷顺序确定，所以这个考生向上走和向下走的不满值是确定的。

不难发现走过道时的值可以用前、后缀和求出，并且如果有交卷考生坐在走廊旁，之后交卷考生的代价需要修改，所以我们可以用树状数组实现。

我们令改考生往上走的代价是 $u$，往下走的代价是 $d$。

去走廊时就暴力确定经过的人数。

对于 $y$，它只受向上、下走的人数影响。

那么我们可以让所有人都先往上走，记此时 $cnt = A\times x$。然后枚举 $i = 1\sim m$，让 $i$ 个人往下走。

因为我们要让代价最小，那么我们优先选择 $u-d$ 大的往下走。那么此时的代价为 $cnt - u + d + (m - i)\times (n - i - 1)\div 2 \times B +i\times (i - 1) \div 2 \times B$。

对此取代价最小值即可。

时间复杂度：$O(n \log n)$。

空间复杂度：$O(n)$。

# Code
```cpp
#include<bits/stdc++.h>
#define WINDOWS
#define int long long

using namespace std;
const int MAXM = 6e5 + 5, MAXN = 1e5 + 5;
int n, m, A, B, ans;
int BMA, BMB;
bool vis[MAXN][6];
struct Node{
  int p;
  int q;
  void readchar(){
    char s;
    cin >> s;
    q = s - 'A' + 1;
  }
  int up, down;
  bool operator<(const Node&i)const{
    return -up + down < -i.up + i.down;
  }
}a[MAXM];
struct tree{
  #define lb(x) x & -x
  int tr[MAXN];
  void xg(int x, int p, int id){//id = 1 -> 前缀, id = 0 -> 后缀。
    if (id){
      for (; x <= n; x += lb(x)){
        tr[x] += p;
      }
    }else {
      for (; x; x -= lb(x)){
        tr[x] += p;
      }
    }
  }
  int find(int x, int id){//id = 1 -> 前缀, id = 0 -> 后缀。
    int cnt = 0;
    if (id){
      for (; x; x -= lb(x)){
        cnt += tr[x];
      }
    }else {
      for (; x <= n; x += lb(x)){
        cnt += tr[x];
      }
    }
    return cnt;
  }
}qz, hz;
int getzl(int x){
  int cnt = 0;
  if (a[x].q < 3){
    for (int i = a[x].q + 1; i < 3; i++){
      cnt += vis[a[x].p][i];
    }
  }else {
    for (int i = a[x].q - 1; i > 4; i--){
      cnt += vis[a[x].p][i];
    }
  }
  return cnt;
}
signed main(){
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifndef WINDOWS
  freopen(".in", "r", stdin);
  freopen(".out", "w", stdout);
  #endif
  cin >> n >> m >> A >> B;
  for (int i = 1; i <= n; i++){
    qz.xg(i, 2, 1);
    hz.xg(i, 2, 0);
    for (int j = 1; j <= 6; j++){
      vis[i][j] = 1;
    }
  }
  int tmp = 0;
  for (int i = 1; i <= m; i++){
    cin >> a[i].p;
    a[i].readchar();
    if (a[i].q == 3 || a[i].q == 4){
      qz.xg(a[i].p, -1, 1);
      hz.xg(a[i].p, -1, 0);
    }
    vis[a[i].p][a[i].q] = 0;
    int cnt = getzl(i) * A;
    a[i].up = cnt + qz.find(a[i].p, 1) * A, a[i].down = cnt + hz.find(a[i].p, 0) * A;
    tmp += a[i].up;
    ans += a[i].up + (i - 1) * B; 
  }
  sort(a + 1, a + m + 1);
  for (int i = 1; i <= m; i++){
    tmp -= a[i].up;
    tmp += a[i].down;
    ans = min(ans, tmp + (m - i) * (m - i - 1) / 2 * B + i * (i - 1) / 2 * B);
  }
  cout << ans;
  return 0;
}
```

---

## 作者：bluewindde (赞：0)

考场上：

>写 [Joker](https://www.luogu.com.cn/problem/AT_agc044_b)，考 [Joker](https://www.luogu.com.cn/problem/P7701)，当 Joker。

这题和 [\[AGC 044B\] Joker](https://www.luogu.com.cn/problem/AT_agc044_b) 十分相像，但是按 Joker 的解法（BFS）写只会成为 Joker。

### 思路

容易发现每个考生到过道的代价是**不会**被选择的保密室影响的，预处理这个代价。

因为考生从考位走到保密室**有且只有**一条路径，影响这条路径的贡献的**只有**考位 `C` 或 `D` 的考生，每次都暴力统计显然不现实，可以用支持单点修改、前后缀求和的数据结构（线段树、树状数组等）维护这条路径的贡献。

我们假设所有提前离开的考生全部走到前面的保密室，为了**最小化**把考生从前面的保密室调整到后面的保密室所增加的代价（也就是其去两个保密室的代价的差值），可以按差值从小到大排序，答案取最小值。

时间复杂度 $O(m\log m)$。

代码有注释。

### 代码

```cpp
#include <algorithm>
#include <iostream>
#include <set>

#define int long long

using namespace std;

int n, m, a, b;

int c[100005];  // 树状数组板子
                // 维护第 i 位之前在过道两侧（位置在 C 和 D）已经离开的人数
static inline int lowbit(int x) {
    return x & (-x);
}
static inline void add(int x, int v) {
    while (x <= n) {
        c[x] += v;
        x += lowbit(x);
    }
}
static inline int query(int x) {
    int ans = 0;
    while (x > 0) {
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}

struct node {
    int a, b;
    bool operator<(const node &b) const {
        return this->a - this->b < b.a - b.b;
    }
} student[100005];

set<pair<int, char> > st;

static inline int calc(int x) {
    if (x <= 1) return 0;
    return x * (x - 1) / 2 * b;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> a >> b;
    int sum = 0;
    for (int i = 1; i <= m; ++i) {
        int x;
        char ch;
        cin >> x >> ch;
        int base = 0;  // base 指到过道的距离
        if (ch == 'A') base = 1 - st.count(make_pair(x, 'B'));
        if (ch == 'F') base = 1 - st.count(make_pair(x, 'E'));
        if (ch == 'C' || ch == 'D') add(x, 1);
        student[i].a = base + x * 2 - query(x);                             // 去前面的保密室经过的人数
        student[i].b = base + (n - x + 1) * 2 - (query(n) - query(x - 1));  // 去后面的保密室经过的人数
        student[i].a *= a;
        student[i].b *= a;
        sum += student[i].b;          // 考虑全部去前面的保密室
        st.insert(make_pair(x, ch));  // 记录已经走了的考生
    }
    sort(student + 1, student + m + 1);  // 为了最小化答案，每次选择代价最小的
                                         // 按调整保密室的代价从小到大排序
    int ans = 1e18;
    for (int i = 0; i <= m; ++i) {  // i 个人走后面的保密室时的代价
        sum += student[i].a - student[i].b;
        ans = min(ans, sum + calc(i) + calc(m - i));
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：huyangmu (赞：0)

我们对题目中的 $x$ 和 $y$ 分别进行考虑。

如果是操作 $x$，因为交卷的先后顺序固定，所以对于每一位同学，走上或走
下的代价是确定的。

对于第 $i$ 行的考生，考虑代价为 $1$ 到 $i$ 排或 $i$ 到 $n$ 排 C 列和 D 列的总人数。

若在 A 或 F，则 B 或 E 有考生未交卷，把总代价加一。若在 C 或 D，则在计算前把 C 或 D 的代价消去即可。注意到这里是前缀和和后缀和，支持修改，可以用树状数组实现。

如果是操作 $y$，$y$的值取决于走上的总人数和走下的总人数。

我们先让所有人选择走上，然后枚举 $1$ 到 $m$ 个人走下，更新贡献。

考虑全部走上的情况，$x$ 部分的代价是 $ans$。对于任意一个人，设走上的
代价为 $u$，走下的代价为 $d$。则调整后对于 $x$ 的贡献为从 $u$ 修改为 $d$。

因为我们希望总代价最小，所以我们每次可以选择 $d-u$ 最小的那个。

这一部分可以在最开始通过排序实现。

### AC Code
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int NR=1e5+5;
int n,m,A,B,cnt1,cnt2,ans1,ans2,ans3,maxn,a[NR];
bool vis[NR][15];
string s;
struct node{
	int x,y;
}c[NR];
int lowbit (int x){
	return x&(-x);
}
void add (int x,int y){
	for (int i=x;i<=n;i+=lowbit(i)) a[i]+=y;
}
bool cmp (node x,node y){
	return x.y-x.x<y.y-y.x;
}
int sum (int x){
	long long sum1=0;
	for (int i=x;i;i-=lowbit(i)){
		sum1+=a[i];
	}
	return sum1;
}
signed main (){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>A>>B;
	for (int i=1;i<=n;++i) add(i,2);
	memset(vis,1,sizeof(vis));
	for (int i=1;i<=m;++i){
		cin>>s;
		int tmp=0;
		for (int j=0;j<s.size()-1;++j) tmp=tmp*10+(s[j]-'0');
		int len=s.size();
		--len;
		if (s[len]=='A'){
			ans1+=vis[tmp][1]*A;
			vis[tmp][0]=0;
		}
		if (s[len]=='B') vis[tmp][1]=0;			
		if (s[len]=='C'){
			vis[tmp][3]=0;
			add(tmp,-1);
		}
		if (s[len]=='D'){
			vis[tmp][4]=0;
			add(tmp,-1);
		}
		if (s[len]=='E') vis[tmp][5]=0;		
		if (s[len]=='F'){
			ans1+=vis[tmp][5]*A;
			vis[tmp][6]=0;
		}
		ans2+=c[i].x=sum(tmp);
		c[i].y=sum(n)-sum(tmp-1);
		ans3+=(i-1)*B+sum(tmp)*A;
	}
	sort(c+1,c+m+1,cmp);
	maxn=ans3;
	for (int i=1;i<=m;++i){
		ans2+=c[i].y-c[i].x;
		maxn=min(maxn,ans2*A+(m-i)*(m-i-1)/2*B+i*(i-1)/2*B);
	}
	return cout<<ans1+maxn<<'\n',0;
} 


---


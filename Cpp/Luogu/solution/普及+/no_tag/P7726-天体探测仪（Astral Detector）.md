# 天体探测仪（Astral Detector）

## 题目背景

通过远古档案馆的探索，你成功制出了天体探测仪，你需要用它发现潜藏的天体科技。


## 题目描述

想要找到天体科技，你需要先得到一串天体密码——它是一个 $1 \sim n$ 的**排列**。

天体探测仪允许对于给定的长度 $l$，返回密码中一个长度为 $l$ 的**区间的最小值**。

不幸的是，所有长度为 $l$ 的区间最小值混在了一起，你得到的只是 $n$ 个**可重集合** $S_1, \ldots , S_n$：

- $S_i$ 表示所有长度为 $i$ 的区间最小值构成的可重集合。

你需要根据这些 $S_i$，还原出一种可能的天体密码，保证至少存在一种正确的天体密码。

## 说明/提示

**【样例 1 解释】**

样例输出的天体密码为：$p = [3, 1, 2, 4]$。

长度为 $1$ 的区间最小值构成的可重集合：$S_1 = \{ 3, 1, 2, 4 \} = \{ 4, 3, 2, 1 \}$。

长度为 $2$ 的区间最小值构成的可重集合：$S_2 = \{ \min(3, 1), \min(1, 2), \min(2, 4) \} = \{ 1, 1, 2 \} = \{ 1, 2, 1 \}$。

长度为 $3$ 的区间最小值构成的可重集合：$S_3 = \{ \min(3, 1, 2), \min(1, 2, 4) \} = \{ 1, 1 \}$。

长度为 $4$ 的区间最小值构成的可重集合：$S_4 = \{ \min(3, 1, 2, 4) \} = \{ 1 \}$。

每一个 $S_i$ 都与输入对应。

其他可行答案也判为正确，如 $p = [4, 2, 1, 3]$。

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$2 \le n \le 800$。

| 子任务编号 | 分值 | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $26$ | $6$ | 无 |
| $2$ | $24$ | $16$ | 无 |
| $3$ | $12$ | $800$ | 对于每个 $i \in [1, n]$，$S_i$ 中不存在两个相同元素 |
| $4$ | $38$ | $800$ | 无 |

## 样例 #1

### 输入

```
4
4 3 2 1
1 2 1
1 1
1
```

### 输出

```
3 1 2 4
```

# 题解

## 作者：xh39 (赞：13)

注:文中所有 $/$ 符号表示整除。设 $a$ 表示所求排列。

从简单情况入手，一步步推，找规律。

## 如何确定 $1$ 的位置?

由于 $1$ 是最小的数，所以任何包含 $1$ 的区间最小值都是 $1$。

因此，在 $S_{(n+1)/2}$ 的集合中出现个数可以作为1的位置。如下图:

![](https://cdn.luogu.com.cn/upload/image_hosting/i1mb52m8.png)

如上图第 $n=4$ 的例子，查询长度为 $2$ 的区间。若 $1$ 在位置 $0,3$ 则重复出现 $1$ 次，在位置 $1,2$ 则出现 $2$ 次。

如上图 $n=5$ 的例子，查询长度为 $3$ 的区间。若 $1$ 在位置 $0,1,2,3,4$，则出现次数依次为 $1,2,3,2,1$ 。

如上图 $n=7$ 的例子，查询长度为 $4$ 的区间。若 $1$ 在位置 $0,1,2,3,4$，则出现次数依次为 $1,2,3,3,2,1$ 。

则出现次数为 $b$ ， 那么 $a[b+1]=a[n-b-1]=1$ 。

由与选取 $n-b-1$ 的位置就是选取 $b+1$ 的位置倒过来，所以实质上无影响。本篇题解默认选取 $b+1$ 位置。

## 如何确定 $2$ 的位置?

此时麻烦一些，因为包含 $2$ 的区间最小值可能是 $1$ 或 $2$ 。

由于出现了 $1$ 的区间最小值只可能是 $1$ 。所以选完 $1$ 以后，$1$ 的左右裂成了两个部分。所以判断到底是在哪个部分。然后就用之前的方法求解。

![](https://cdn.luogu.com.cn/upload/image_hosting/fj2kw6x2.png)

如何判断区间内是否有解?设区间长度为 $size$，则 $S_{size}$ 中一定出现了 $1$ 次最小值。而 $S_{size+1}$ 中一定没有出现最小值。所以就判断 $S_{size}$ 中 $2$ 的出现次数。

若两部分内都有解，此时两部分长度相等，那么选取任意一部分都是等价的，本题解选取左部分。

确定完部分就与选取 $1$ 时用同样的方法。
## 如何选取更多的数?(实现)

$2$ 又可以将排列划分，现在有了 $3$ 个部分。那么选取 $3$ 也是一样的操作。但以上步骤不好直接模拟。因为不能快速找到区间。复杂度会超。

假设当前要选取 $i$。考虑用一个链表记录当前已经确定了的数 1~$(i-1)$。同时记录这个数选取的位置 $id$。这样区间就是 [当前.id+1,下一个.id-1]。

这样一来，插入操作，查找操作都方便了很多。就可以在 $O(n^2)$ 的复杂度内出解。

## 参考代码
```cpp
#include<iostream>
using namespace std;
struct i_am_aking_ioi{
	int id,next;
}_[1000005]; //链表。
int mark[1005][1005]; //mark[i][j]:长度为i的区间(S[i])内出现了几次j。 
int main(){
	int n,i,j,A,ykb;
	cin>>n;
	for(i=1;i<=n;i++){
		for(j=i;j<=n;j++){
			scanf("%d"，&A);
			mark[i][A]++;
		}
	}
	_[0].next=n+1;
	_[0].id=-1;
	_[n+1].id=n; //初始化不能漏，一开始的区间是[0,n-1]，由于区间是[now.id+1,next.id-1]，所以要一开始要设为-1和n。
	for(i=1;i<=n;i++){ //依次插入1~n 
		for(j=0;j<=n;j=_[j].next){ //在每个区间内查找。  
			ykb=_[_[j].next].id-_[j].id; //区间长度
			if(!mark[ykb][i]&&mark[ykb-1][i]){
				_[i].id=_[j].id+mark[ykb+1>>1][i];//这个区间时从now.id+1开始编号的。所以需要加上_[j].id。同时+1-1抵消。
				_[i].next=_[j].next;
				_[j].next=i;
				break; //已经找到，不需要再找。因为多个可行区间任选一个。
			}
		}
	}
	for(i=_[0].next;i<=n;i=_[i].next){
		cout<<i<<" ";
	}
	return 0;
}
```
月赛过去了这么久都没有题解。于是就写一篇。

---

## 作者：丛雨 (赞：6)

## [P7726 天体探测仪(Astral Detector)](https://www.luogu.com.cn/problem/P7726)

> 存在一个排列 1 ~ n ，给出它的每个长度的**所有**子区间的最小值，请求出一种原排列
>
> $ 1 \leq n \leq 800 $

可能是因为这种题指向很明显,对于这类区间 $ \tt min/max $ 的问题首先得想到笛卡尔树

想想我们建笛卡尔树的方法:每次查询区间最小值，将其作为根，再将左右区间递归下去

这样给了我们启示：对于每个节点，我们可以通过它代表的区间大小和左右子树大小以及节点编号还原出一颗满足条件的笛卡尔树，进而还原原序列

首先，笛卡尔树中编号$n$代表的原区间大小就是 $ \tt min=n $ 的最长的一个区间长度 $ A $

求出 $ \tt min=n $ 的区间个数$B$,设左子树长度 $ L $ ,右子树 $ R $ 

$$

\begin{cases}
(L+1)(R+1)=B\\
L+R-1=A
\end{cases}
$$

解出左右子树大小后从后往前对应连边即可

时间复杂度 $O(n^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
# define ll long long
# define read read1<ll>()
# define Type template<typename T>
Type T read1(){
	T t=0;
	char k;
	bool vis=0;
	do (k=getchar())=='-'&&(vis=1);while('0'>k||k>'9');
	while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
	return vis?-t:t;
}
# define fre(k) freopen(k".in","r",stdin);freopen(k".out","w",stdout)
int s,a[805][805],Len[805],Sum[805],L[805],R[805];
pair<int,int>f[805];
stack<int>sta[805];
void print(int x){
	if(!x)return;
	print(L[x]);
	printf("%d ",x);
	print(R[x]);
}
int main(){
	s=read;
	for(int i=1;i<=s;++i)
		for(int j=1;i+j<=s+1;++j)
			++a[i][read];
	for(int i=1;i<=s;++i)
		for(int j=1;i+j<=s+1;++j)
			Len[j]=a[i][j]?i:Len[j],Sum[j]+=a[i][j];
	for(int i=1;i<=s;++i){
		double w=sqrt(pow(Len[i]+1,2)-4*Sum[i]);
		int x=round((Len[i]+1+w)/2),y=round((Len[i]+1-w)/2);
		f[i]=make_pair(x-1,y-1);
	}for(int i=s;i;--i){
		if(f[i].first)L[i]=sta[f[i].first].top(),sta[f[i].first].pop();
		if(f[i].second)R[i]=sta[f[i].second].top(),sta[f[i].second].pop();
		sta[Len[i]].push(i);
	}
	print(1);
	return 0;
}
```


---

## 作者：Dewier (赞：3)

# 题目大意：
一个长度为 $n$ 的排列，给出 $n$ 个可重集 $S_i$ 表示所有长度为 $i$ 的区间的最小值构成的集合。求构造这个排列（$2 \le n \le 800$）
# 思路：
对于一个数字，如果在 $S_i$ 中的出现次数小于 $i$ 时，证明包含它的区间中拥有不是它为最小值的情况。
所以每个数字我们找到出现次数小于 $i$ 的第一个 $S_i$，那么它离它左右两边比他小的数字的距离就是 $i-1$。
然后考虑再求出另一边的距离，当某个时候 $S_i$ 中不包含数字 $x$ 时那么证明 $x$ 距离两边的距离和小于 $i$，找到一个位置就可以算出另一边的距离。
然后直接从小到大找满足条件的位置插入即可。
时间复杂度：$O(n^2)$。
# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int c[810],l[810],r[810],ans[810];
set<int> s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		memset(c,0,sizeof(c));
		for(int j=1;j<=n-i+1;j++){
			cin>>x;
			c[x]++;
		}
		for(int j=1;j<=n;j++){
			if(!l[j]&&c[j]!=i){
				l[j]=i-1;
			}
			if(!r[j]&&!c[j]){
				r[j]=i-l[j];
			}
		}
	}
	r[1]=n-l[1]+1;
	s.insert(0);
	s.insert(n+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(ans[j]){
				continue;
			}
			int x=(*s.lower_bound(j))-j;
			int y=j-*(--s.upper_bound(j));
			if(x>y){
				swap(x,y);
			}
			if(x==l[i]&&y==r[i]){
				ans[j]=i;
				s.insert(j);
				break;
			}
		}
	}
	for(int i=1;i<=n;i++){
		cout<<ans[i]<<" ";
	}
	return 0;
}
```

---


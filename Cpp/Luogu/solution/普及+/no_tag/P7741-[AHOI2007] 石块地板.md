# [AHOI2007] 石块地板

## 题目描述

小可可来到了宫殿的正厅中。大厅的地面是由一块块大小一致的正方形石块组成的，这些石块分为黑、白两色，组成了一个   $m×n$ 的矩形，在其中一个石块的下面就是通往藏宝库的通道。小可可不可能一个一个石块的尝试，因为有些石块安装了机关，一碰就会触发，整个宫殿也随之倒塌。根据藏宝图记载，通道在某一特定的区域中，这个区域是一个由数个石块组成的面积不为 $0$ 的小矩形，它的四条边与大厅地面的边平行。如果对整个大厅地面任意划分矩形，那么在所有矩形中，这个区域的黑色石块数目减去白色石块数目所得的差是最大的。

小可可希望和你分工，由他来选择区域，你来计算黑、白两色石块的数目差 $S$ 。这样就能快速而准确的确认通道所在的区域。藏宝图上说这个区域中的石块都没有安装机关，只要确定了区域，就一定能找到通道。宝藏就在眼前了，加油吧！

（假设用 $1$ 表示黑色石块，用 $0$ 表示白色石块）

## 说明/提示

对于 $ 50\%$ 的数据：$1 \le m, n \leq200$。

对于 $100\%$ 的数据：$1 \le m, n \leq400$。

## 样例 #1

### 输入

```
3 4
1011
1111
1111```

### 输出

```
10```

## 样例 #2

### 输入

```
4 5
10110
01111
11110
10101```

### 输出

```
8```

# 题解

## 作者：ycw123 (赞：11)

简单来说这道题就是求一个 $N \times M$ 的矩阵的最大子矩阵和。
（因为求的是黑色石板与白色石板的数量差，所以代表白色石板的“0”可以看作 -1，这样就将问题转化为了求最大子矩阵和）

思路：

首先，这个子矩阵可以是任意大小的，而且起始点也可以在任何地方，所以，要把最大子矩阵找出来，我们要考虑多种情况。

假定原始矩阵的行数为 $M$，那么对于子矩阵，它的行数可以是 1 到 $M$ 的任何一个数，而且，对于一个 $K$ 行（$K \le M$）的子矩阵，它的第一行可以是原始矩阵的第 1 行到 $M - K + 1$ 的任意一行。

例子：

```cpp
1 -1 1 1 -1
-1 1 1 1 1
1 1 1 1 -1
1 -1 1 -1 1
```

对于样例二的矩阵，如果子矩阵的行数是 2，那么它可以是下面几个矩阵的子矩阵：

```cpp
1 -1 1 1 -1
-1 1 1 1 1
```
或者

```cpp
-1 1 1 1 1
1 1 1 1 -1
```
或者

```cpp
1 1 1 1 -1
1 -1 1 -1 1
```

在每一种情况里（我们这里有三种），我们还要找出一个最大的子矩阵，当然，这只是一种情况的最大子矩阵（局部最大），不一定是全局最大。

但是，如果我们知道每一种情况的最大，要找出全局最大，那就小菜一碟儿了。

在讲在一个特殊情况下求最大子矩阵之前，先讲一个事实：

假设这个最大子矩阵的维数是一维，要找出最大子矩阵, 原理与求“最大子段和问题”是一样的。最大子段和问题的递推公式是 ：

$$b[j]=\max(b[j-1]+a[j],a[j])$$

>$b[j]$ 指的是从1开始到 $j$ 的最大子段和。

例子：

假设原始矩阵为：[1 ，-1 ，1 ，1 ，-1]， 那么 $b[]$ = {1,0,1,2,1} , 那么最大子段和为 2，如果找最大子矩阵的话，那么这个子矩阵是 [1，-1，1，1] (或者[1，1]) 。


求最大子段和的代码如下：

```cpp
int b[1000]={};
for(int k=1;k<=n;k++){
	b[k]=max(a[k],b[k-1]+a[k]);
	ans=max(ans,b[k]);
}
printf("%d",ans);
```
但是，原始矩阵可以是二维的。假设原始矩阵是一个 $3 \cdot n$ 的矩阵，那么它的子矩阵可以是 $1 \cdot k$, $2 \cdot k$, $3 \cdot k$（$1 \leq k \leq n$）。 

如果是 $1 \cdot k$，这里有3种情况：子矩阵在第一行，子矩阵在第二行，子矩阵在第三行。

如果是 $2 \cdot k$，这里有两种情况，子矩阵在第一、二行，子矩阵在第二、三行。

如果是 $3 \cdot k$，只有一种情况。

为了能够找出最大的子矩阵，我们需要考虑所有的情况。

假设这个子矩阵是 $2 \cdot k$, 也就是说它只有两行，要找出最大子矩阵，我们要从左到右不断的遍历才能找出在这种情况下的最大子矩阵。**如果我们把这两行上下相加，情况就和求“最大子段和问题” 又是一样的了。**

为了找出在原始矩阵里的最大子矩阵，我们要遍历所有的子矩阵的可能情况，也就是说，我们要考虑这个子矩阵有可能只有 1 行，2 行……到 $n$ 行。而在每一种情况下，我们都要把它所对应的矩阵部分上下相加才求最大子矩阵（局部）。


所以我边输入，边预处理出了每一列的前缀和：

```cpp
cin>>n>>m;
for(int i=1;i<=n;i++){
	cin>>(s+1);
	for(int j=1;j<=m;j++){
		dp[j][i]+=dp[j][i-1];
		if(s[j]-'0') dp[j][i]++;
		else dp[j][i]--;
	}
}
//dp[j][i] 表示 第j列 1到第i行的前缀和
```

之后枚举矩阵的起点行和终点行，通过最大子段和的方法求最大子矩阵：

```cpp
for(int i=1;i<=n;i++){        //枚举起点行
	for(int j=i;j<=n;j++){      //枚举终点行
		int b[1000]={};
		for(int k=1;k<=m;k++){   //前缀和+最大子段和
			b[k]=max(dp[k][j]-dp[k][i-1],b[k-1]+dp[k][j]-dp[k][i-1]);
			ans=max(ans,b[k]);
		}
	}
}
```
完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
char s[1000];
int dp[1000][1000];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>(s+1);
		for(int j=1;j<=m;j++){
			dp[j][i]+=dp[j][i-1];
			if(s[j]-'0') dp[j][i]++;
			else dp[j][i]--;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			int b[1000]={};
			for(int k=1;k<=m;k++){
				b[k]=max(dp[k][j]-dp[k][i-1],b[k-1]+dp[k][j]-dp[k][i-1]);
				ans=max(ans,b[k]);
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Micnation_AFO (赞：9)

- [原题面](https://www.luogu.com.cn/problem/P7741)
- [更好的阅读体验](https://mcnt445.blog.luogu.org/solution-p7741)


------------

**题目大意** ：给出一个 $m \times n$ 的矩阵，求出这个矩阵的最大子矩阵和。（把题目中的 $0$ 在读入时当做 $-1$ 处理即可，下文不再赘述）

**具体思路** ：
1. 求出每一行前 $j$ 个数的前缀和。即：
	$$sum_{i,j} = sum_{i,j-1} + a_{i,j}$$
    其中，$sum_{i,j}$ 表示第 $i$ 行前 $j$ 个数的前缀和。
    
1. 进行枚举起始列 $i$ 与目标列 $j$，再把每一行中从 $i$ 到 $j$ 的和算出来（利用之前的前缀和），我们可以建立一个 **临时** 数组`f1`，则：
	$$f_k = sum_{k,j} - sum_{k,i-1}$$
    其中，$f_k$ 表示第 $k$ 行中从 $i$ 到 $j$ 的和。
1. 这时，我们已经把每一行（从 $i$ 到 $j$）的和存到了数组 $f$ 中，那么我们就可以把问题转化为 **最大子段和** 问题了。最大子段和的公式：
	$$f_k = \max(f_k, f_k + f_{k - 1})$$
    再用变量 $ans$ 打擂台求出 $f_k$ 的最大值即可。


**AC Code** ：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define maxn 405
int m, n, ans;
int sum[maxn][maxn], f[maxn];
char c;

signed main() {
    cin >> m >> n;
    //注意不是 n 行 m 列

    for (int i = 1; i <= m; i++) 
        for (int j = 1; j <= n; j++) {
            cin >> c;
            if (c == '1') sum[i][j] = sum[i][j - 1] + 1;
            else if (c == '0') sum[i][j] = sum[i][j - 1] - 1;
        }
    //求出每一行的前 j 个数的前缀和

    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++) {//枚举第 i 列到第 j 列
            
            for (int k = 1; k <= m; k++) 
                f[k] = sum[k][j] - sum[k][i - 1];//把每一行的和算出来

            for (int k = 1; k <= m; k++) {
                f[k] = max(f[k], f[k] + f[k - 1]);
                ans = max(ans, f[k]);
            }//最大子段和问题

        }
    cout << ans << endl;
    return 0;
}

```

---

## 作者：_111_ (赞：5)

##  题目大意
给定一个  $n \times m$  的 01 矩阵，求子矩阵中 1 的数量与 0 的数量之差最大的那个矩阵。

那么我们可以转化一下，因为求的是 1 和 0 的差值，所以我们可以把值为 0 的位置标记为 -1，然后求最大子矩阵和就好了。时间复杂度为 **$O(m ^2 n)$**，是可以过的。若有不会最大子矩阵和的朋友可以做一下 [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719) 和看一下 [**这个**](https://blog.csdn.net/weixin_45102820/article/details/107769179)，我认为比较好的 $blog$。
## code
```c
#include <bits/stdc++.h>
using namespace std;
int n,m,ans=0;
int a[401][401],b[401][401],dp[401];
int main(){ 
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        for(int j=1;j<=m;j++){
            a[i][j]=s[j-1]-'0';
            if(!a[i][j]){
                a[i][j]=-1;
            }//0转化为1
        }
    }
    for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			for(int k=1;k<=m;k++){
				b[i-1][k]=0;
				//因为下面一行的b[j-1][k]当j=i时可能不为0，所以这里初始化一下。 
				b[j][k]=b[j-1][k]+a[j][k];
				if(k==1){
					dp[k]=b[j][k];
				}
				dp[k]=max(dp[k-1]+b[j][k],b[j][k]);
				ans=max(ans,dp[k]);
			}
		} 
	}
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：fls233666 (赞：3)

看到这个题目，首先会想到一种 $O(m^2n^2)$ 的暴力做法：两重循环枚举子矩阵的左上角，两重循环遍历计算整个矩阵的权值。但是很显然，在 $1 \le n,m \le 400$ 的情况下，这题是过不去的。

我们注意到题目要求的是 **子矩阵中 $1$ 的数量与 $0$ 的数量之差**。换个角度思考，不难发现，**子矩阵中，每个 $1$ 对答案的贡献是 $+1$，每个 $0$ 对答案的贡献是 $-1$** 。于是我们把原问题转化一下：讲输入数据中所给的 $01$ 矩阵中每个 $0$ 的位置记为 $-1$，每个 $1$ 的位置记为 $-1$ 我们就得到了一个关于答案贡献的矩阵，而问题也转化为 **求这个答案贡献矩阵的最大加权子矩阵**。

转化之后，我们要处理的状态信息更少了，但是还不够，需要进一步简化。我们考虑另外再开一个数组存储每行的权值，在处理完第 $i$ 行后，将 $i+1$ 的权值累加到第 $i$ 的权值上，这时再扫一遍数组，我们就是在处理第 $i$ 行和第 $i+1$ 行的权值和的子矩阵了。于是，**最大加权子矩阵问题被我们通过降维变成了一维的最大子段和问题**。

考虑完降维后的状态，我们重新考虑程序的实现。于是，有了一个 $O(n^3)$ 的解法：第一重循环枚举从第几行开始处理，第二重循环和第三重循环处理从第一重循环枚举的位置开始到第 $m$ 行的矩阵部分。于是时间复杂度被我们成功降为 $O(m^2n)$，可以通过此题。

下面放出代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define rgt register int
#define qmx(a,b) a>b?a:b 
using namespace std;

const int mxn = 404;

int n,m,ans,s;
char mp[mxn][mxn];
int one_line[mxn];

inline void getmp(int line){
	char c=getchar();
	while(c!='0'&&c!='1')
		c=getchar();
	mp[line][1]=c;
	for(rgt i=2;i<=n;i++)
		mp[line][i]=getchar();
}  //读入矩阵的一行

int main(){
	scanf("%d%d",&m,&n);
	for(rgt i=1;i<=m;i++)
		getmp(i);  //读入矩阵
        
	for(rgt i=1;i<=m;i++){
		memset(one_line,0,sizeof(one_line));  //存储一行的状态
		for(rgt j=i;j<=m;j++){
        
			for(rgt k=1;k<=n;k++)
				one_line[k]+=(mp[j][k]=='1'?1:-1);  //累加权值，降维
                
			s=0;
			for(rgt k=1;k<=n;k++){
				s+=one_line[k];
				ans=qmx(ans,s);
				if(s<0)
					s=0;
			}  //最大子段和--->最大加权子矩阵
            
		}
	}
	printf("%d",ans);
	return 0;
}
```

相关题目链接：

- [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
- [P1719 最大子矩形](https://www.luogu.com.cn/problem/P1719)

---

## 作者：5k_sync_closer (赞：3)

## FBI Warning

此题是一道**思维题**，请不要"**对着题解调试程序**"(大雾
# 前置芝士
**一维**前缀和（就够了）

最大子段和（[P1115](https://www.luogu.com.cn/problem/P1115)）

二维数组（~~能做到蓝题的应该都会吧~~）
# 思路
**注意，这题的 $n$ 和 $m$ 是和其他题反过来的！**

这题明显是一个~~卡了我两天的~~最大子矩阵和板子题。

有同学就要问了：那为什么是“和”呢？问的是“差最大”啊？

但是这个“差最大”问题也可以转换成“和最大”问题。

黑（的数目） - 白（的数目）最大，即要求黑尽可能多，白尽可能少。

令黑色表示 $1$，白色表示 $-1$，即“$1$ 尽可能多，$-1$ 尽可能少”。

$1$ 尽可能多，所有 $1$ 和 $-1$ 的和就尽可能大。

$-1$ 尽可能少，所有 $1$ 和 $-1$ 的和也尽可能大。

反过来，只要所有 $1$ 和 $-1$ 的和尽可能大，$1$ 就多，$-1$ 就少，（数目的）差也就大。

所以保证矩阵内的 $1$ 和 $-1$ 的和尽可能大即可，差即为 $1$ 和 $-1$ 的和。

是不是恍然大明白？(~~我猜你没有~~

那么怎么找出这个“和最大”的子矩阵呢？枚举，但不是直接暴力。

首先，在矩阵上划定一个范围：

![](https://cdn.luogu.com.cn/upload/image_hosting/3i3gn924.png)

枚举这个范围需要 $n^2$ 的复杂度，子矩阵将在这个范围中确定。

将这个范围中每行的和算出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/hxh17w2j.png)

$s_i$ 表示第 $i$ 行每个数的和，灰框是一个临时的数组。

每行的和需要 $nm$ 的复杂度，但可以用前缀和优化成 $O(m)$。

那么，这个范围就被抽象成了灰框内的数组。

算这个数组的最大子段和，最大的子段就对应着最大的矩阵。

这样，最大矩阵就找到了，复杂度 $O(n^2m)$。
# 代码
```cpp
#include <iostream>
#define qjh(r, x, y) s[r][y] - s[r][x - 1]
using namespace std;
int s[401][401], t[401], m, n, ans;char c;
void get()
{
    for(int i = 1;i <= m;++i)
    {
        t[i] = max(t[i], t[i] + t[i - 1]);
        ans = max(ans, t[i]);
    }
}
int main()
{
    cin >> m >> n;
    for(int i = 1;i <= m;++i)
        for(int j = 1;j <= n;++j)
        {
            cin >> c;
            if(c == '1') s[i][j] = s[i][j - 1] + 1;
            if(c == '0') s[i][j] = s[i][j - 1] - 1;
        }
    for(int i = 1;i <= n;++i)
        for(int j = i;j <= n;++j)
        {
            for(int k = 1;k <= m;++k)
                t[k] = qjh(k, i, j);
            get();
        }
    cout << ans;
    return 0;
}
```


---

## 作者：Light_az (赞：1)

这不是一道最大矩阵和板子题吗？这道题目在两年半之前我的思路是这样的：枚举起点用 $O(n^2)$，枚举终点用 $O(n^2)$，成功使用 $O(n^4)$ 超时了这道题目。

直到最近，稍微学了一下前缀和，发现这道题目原来这么简单：我们枚举其中两行也就是 $i$ 和 $j$，保证 $i \le j$，那么 $i$ 和 $j$ 其实就是矩阵从第 $i$ 行开始，第 $j$ 行结束，之后再枚举矩阵的长度 $k$。这个时候我们已经确定了矩阵的顶点坐标，可以使用前缀和优化再求最大值。注意：因为 $i$ 和 $j$ 每更新一次矩阵的行和列也会发生变化，所以我们要使用两个最大值，一个统计答案，一个更新当前行和列的矩阵最大值。时间复杂度为 $O(n^3)$，下面是完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e7+10,NN=1e4+10;
ll n,m,k,y,u,v,w,cnt=0,ans=0,t=0,l,r,len;
ll mini=INT_MAX,maxi=0;
string s,s1,s2;
ll sum[NN][NN];
ll a[NN][NN];
char x;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>x;//由于输入没有空格，因此采用字符输入
			if(x=='1'){
				a[i][j]=1;
			}
			else{
				a[i][j]=-1;
			}
			sum[i][j]=sum[i-1][j]+a[i][j];//第 i 列的累加和
		}
	}
	for(int i=1;i<=n;i++){//确定行
		for(int j=i;j<=n;j++){//确定列
			ll tmp=0;
			for(int k=1;k<=m;k++){//确定长度
				tmp=max(tmp,(ll)0)+sum[j][k]-sum[i-1][k];//矩阵最大值
				ans=max(ans,tmp);//答案最大值
			}			
		}
	}
	cout<<ans;//撒花
	return 0;
}
```


---

## 作者：BetterGodPig (赞：1)

#### upd 2021-8-26：去掉了部分分解的代码，使文章更简洁美观。

----

### [题面](https://www.luogu.com.cn/problem/P7741)

### Description
> 给定一个只有 `0` 和 `1` 的矩阵，求一个子矩阵，使得该子矩阵中 $1$ 的个数与 $0$ 的个数差最大，并输出这个最大值。

### Solution

#### 解法一（20pts）
首先考虑暴力，枚举每个子矩阵左上角与右下角的位置（即枚举出每一个子矩阵，时间复杂度 $O(m^2n^2)$ ），将 `0` 储存为 `-1` ，用两个 `for` 循环扫一遍计算子矩阵内所有元素之和，并记录过程中的最大值,时间复杂度约 $O(mn)$。总计时间复杂度 $O(m^3n^3)$ ，数据给的 $1\le m,n \le 400$ ，妥妥的超时。

[Link](https://www.luogu.com.cn/record/56904165)

-----

#### 解法二（50pts）
考虑优化，枚举每一个子矩阵肯定是 $O(m^2n^2)$ 没得少了，所以就得考虑计算子矩阵的部分了。我们用前缀和的形式来储存这个矩阵，就成功地将 $O(mn)$ 优化至 $O(m)$ 了，在将计算最大值的方式换为一边计算一边更新最大值，就将整个算法优化成了 $O(m^2n^2)$ 了。对于本题，可以过一半的数据（ $1 \le m,n \le 200$ ）。

[Link](https://www.luogu.com.cn/record/56905109)



------------
#### 解法三（100pts）
接下来，进入正解的讲解。
这道题说白了，就是最大子矩阵的版子题，这不免让人联想到[最大子段和](https://www.luogu.com.cn/problem/P1115)，那子矩阵与子段的最大区别是什么？就是一个是二维的，而一个是一维的。我们尝试将二维转换为一维。二维和一维的区别是什么？就是多了一个不确定的量。所以，当我们确定一个子矩阵的宽后，每一行都会得到一个区间和，这样，就转换为了一个大小为 $m$ 的一维数组了。然后，我们只需有求出这个一维数组的最大子段和就行了。最后的算法出炉了，枚举一个子矩阵的宽，再求一次最大子段和，采用线性 $O(m)$ 的算法。最后，时间复杂度 $O(mn^2)$ 。

 _**Code:**_ 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
int m,n,a[405][405],ans = -0x3f3f3f3f;
inline int max(const int &a,const int &b){
	return a>b?a:b;
}
inline int get(int l,int r){
	int dp[2] = {0},res = -0x3f3f3f3f;
	for(int i = 1;i <= m;i++){
		int now = a[i][r] - a[i][l-1];
		if(i < 2) dp[1] = now;
		else dp[i&1] = max(now,dp[!(i&1)]+now);
		res = max(res,dp[i&1]);
	}
	return res;
}
inline void write(const int x){
	if(x < 0){
		putchar('-');
		write(-x);
	}
	if(x > 9){
		write(x/10);
	}
	putchar(x%10+48);
}
int main(){
	scanf("%d%d",&m,&n);
	for(int i = 1;i <= m;i++){
		for(int j = 1;j <= n;j++){
			int ch;
			scanf("%1d",&ch);
			if(ch) a[i][j] = a[i][j-1]+1;
			else a[i][j] = a[i][j-1]-1;
		}
	}
	for(int i = 1;i <= n;i++){
		for(int j = i;j <= n;j++){
//			for(int k = 1;k <= m;k++){
//				int now = 0;
//				for(int l = k;l <= m;l++){
//					now+=a[l][j] - a[l][i-1];
//					ans = max(now,ans);
//				}
//			}
			ans = max(ans,get(i,j));
		}
	}
	write(ans);
	return 0;
}
```
[Link](https://www.luogu.com.cn/record/56905701)

----

感谢阅读。

---

## 作者：SegTree (赞：0)

[题目传送门。](https://www.luogu.com.cn/problem/P7741)

## 题目分析
注：以下默认 $n$ 与 $m$ 同阶。
+ 每次暴力枚举左上和右下坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$ 并暴力两重循环计算 $0$ 与 $1$ 的差值，复杂度 $\mathcal{O}(n^6)$。[实际得分 $30\text{pts}$](https://www.luogu.com.cn/record/83717689)。
+ 预处理二维前缀和，每次暴力枚举左上和右下坐标，统计最大值，复杂度 $\mathcal{O}(n^4)$。[实际得分 $50\text{pts}$](https://www.luogu.com.cn/record/83709986)。
+ 预处理前缀和，每次计算最大子段和，复杂度 $\mathcal{O}(n^3)$，[实际得分 $100\text{pts}$](https://www.luogu.com.cn/record/83711709)。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[444][444],n,m,ans=-2e9;
int F(int i,int j,int k,int l){
    return a[k][l]+a[i-1][j-1]-a[k][j-1]-a[i-1][l];
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            scanf("%1d",&a[i][j]);
            if(!a[i][j])a[i][j]=-1;
            a[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1];
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=i;j<=n;++j){
            int sum=0;
            for(int k=1;k<=m;++k){
                sum+=F(i,k,j,k);
                ans=max(ans,sum);
                sum=max(sum,0);
            }
        }
    }
    printf("%d\n",ans);
}
```

---

## 作者：I_m_FW (赞：0)

来一个好理解的~~卡空间~~的动态规划算法

这个算法空间复杂度较大，但是比较好理解。

首先我们把序列中的 $0$ 初始化为 $-1$ ，那么问题就转化为求给定矩阵中的最大子矩阵。

我们首先需要预处理每一行从 $1$ 到 第 $x$ 列的前缀和。

我们用 $f_{i,j,k}$ 表示以第 $i$ 层，第 $j$ 列为顶点，右上角定点横坐标为 $k$ 的最大价值子矩阵。

那么对于矩形来说，它的宽会被第一次的决策定死，所以我们状态转移只能从上一行的同一列和相同宽度的矩阵转移过来，代价为 $s_{i,k}-s_{i,j-1}$ 。

那么容易得到状态转移方程：

$f_{i,j,k}=max(f_{i,j,k}+s_{i,k}-s_{i,j-1},f_{i-1,j,k}+s_{i,k}-s_{i,j-1})$ 

但是这个做法只能用短类型存，否则会爆空间！！！

代码：

```
#include <bits/stdc++.h>
using namespace std;
const int N=405;
short f[N][N][N];
short s[N][N],ans=0;
short n,m;
char c;
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>c;
			if(c=='0')s[i][j]=s[i][j-1]-1;
			else s[i][j]=s[i][j-1]+1;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int k=j;k<=m;k++){
				f[i][j][k]=max(f[i][j][k]+s[i][k]-s[i][j-1],f[i-1][j][k]+s[i][k]-s[i][j-1]);
				ans=max(f[i][j][k],ans);
			}
	cout<<ans;
	return 0;
}
```

---

## 作者：XL4453 (赞：0)

### 解题思路：

首先进行初步的问题转化，将 $1$ 的权值设置为 $1$，$0$ 的权值设置为 $-1$，问题也就是要求一个权值最大的矩形。

考虑这个问题的一维形式，也就是一维最大子段和，可以直接通过一个 $O(n)$ 的方法处理处理。具体为：$f_{i}$ 表示考虑到位置 $i$ 其中位置 $i$ 必须选择的最大子段和，有：$f_i=\max(f_{i-1}+a_i,a_i)$，由于每一个位置只和这个位置前面一个有关，其实一个变量就能解决问题了。

对于矩阵，则可以考虑枚举出最上面一行和最下面一行的位置，然后对于中间用一维对打子段和的形式处理。每一个位置的价值可以用二维前缀和做（一维也可以）。

这样的总复杂度是 $O(n^3)$ 的，可以接受。

---
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[404][404],sum[404][404],now,ans;
int SUM(int x1,int y1,int x2,int y2){
	return sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		scanf("%1d",&a[i][j]);
		if(a[i][j]==0)a[i][j]=-1;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j++){
		now=0;
		for(int k=1;k<=m;k++){
			now+=SUM(i,k,j,k);
			ans=max(ans,now);
			now=max(now,0);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：pinking_tree (赞：0)

# P7741 题解
## 1.前置~~芝士~~题意
有个藏宝地是由一块块大小一致的正方形石块组成的，这些石块分为黑、白两色，组成了一个 $m×n$ 的矩形，在其中一个石块的下面就是通往藏宝库的通道。根据藏宝图记载，通道在某一特定的区域中，这个区域是一个由数个石块组成的面积不为 $0$ 的小矩形，它的四条边与大厅地面的边平行。如果对整个藏宝地地面任意划分矩形，那么在所有矩形中，这个区域的黑色石块数目减去白色石块数目所得的差是最大的。
## 2.题目时间复杂度分析
我个人感觉这不该是道绿题，只能算黄题
~~（虽然我调了挺久）~~

暴力：枚举矩形的左上角点的坐标和右下角点的坐标， $O(N^4)$ 。再加上算矩形里数的总和，又乘一个 $O(N^2)$ 。时间总复杂度： $O(N^6)$ 。

妥妥的 TLE 。

我当时就想，能不能优化一下，把算矩形里数的总和这一步骤化成 $O(1)$ ?

每一行一次前缀和即可。时间总复杂度： $O(N^4)$ 。

想完之后，我惊奇的发现： $O(N^4)$ 也超了。 $O(N^3)$ 都顶天了， $O(N^4)$ 岂不是也是 TLE ？

那 $O(N^3)$ 的算法从何而来呢？还有，这里怎么前缀和呢？

## 3.转换一下

我们把黑石头的值设为 $1$ ，把白石头的值设为 $-1$ 。

这样做有什么好处呢？

首先，方便我们用前缀和。比方说，输入只有两行：
```
1 4
1101
```
这时前缀和一下为： $1$,$2$,$1$,$2$

当我们取到一个矩形时，我们只要对方阵的每一行前缀和即可，一行O(1)。

那么， $O(N^3)$ 的算法在哪里？

## 4.题目算法分析

首先，我们先枚举两条竖边分别过的长方形的端点的 $x$ 坐标。

比方说：

```cpp
for(int i=1;i<=n;i++){
	for(int j=i;j<=n;j++){
   		//计算局部最优解
	}
}
```
比方说输入是题目给的样例1（详情见[题目](https://www.luogu.com.cn/problem/P7741)），我们枚举到了 $i=2$ ， $j=3$ 。

这时，因为我们有前缀和，所以在这里面取矩形既是最大子段和（[P1115](https://www.luogu.com.cn/problem/P1115)）了。

综上，$O(N^3)$ 的算法出来了。

## Code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int zxt[405][405],n,m;
int sum(int l,int r,int i)
{
	return zxt[i][r]-zxt[i][l-1];
}
int maxtotal(int l,int r)
{
	int maxx=sum(l,r,1),cnt=maxx;
	if(cnt<=0)cnt=0;
	for(int i=2;i<=m;i++){
		cnt+=sum(l,r,i);
		maxx=(maxx>cnt?maxx:cnt);
		if(cnt<=0)cnt=0;
	}
	maxx=(maxx>cnt?maxx:cnt);
	return maxx;
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			int a;
			scanf("%1d" , &a);
			if(!a)a--;
			zxt[i][j]=zxt[i][j-1]+a;
		}
	}
	int maxx=-1;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			int mt=maxtotal(i,j);
			if(maxx<mt)maxx=mt;
		}
	}
	cout<<maxx;
	return 0;
}
```

---


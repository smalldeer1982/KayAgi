# [COCI 2016/2017 #5] Ronald

## 题目描述

一个国家的 $N$ 个城市通过双向航线相连。

规定一次操作为：

- 选定其中一个城市
- 开设该城市到其它所有城市的航线，同时取消该城市的原有航线

请问是否存在一种操作方式，使得每两个城市之间都存在直达航线（操作次数不限）。

## 说明/提示

**【样例 1 解释】**

选定城市 $1$（即开通 $1-2$ 的航线）即可。

**【样例 3 解释】**

原有航线为 $1-3$ 和 $2-4$。

第一次选定城市 $1$。此时航线 $1-3$ 被取消，同时新开设航线 $1-1,1-2,1-4$。

第二次选定城市 $3$。此时新开设航线 $3-1,3-2,3-4$。

**【数据规模与约定】**

对于 $100\%$ 的数据，$2 \le N \le 1000$，$0 \le M \lt \dfrac{N(N-1)}{2}$。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #5](https://hsin.hr/coci/archive/2016_2017/contest5_tasks.pdf) _T4 Ronald_。**

**本题分值按 COCI 原题设置，满分 $120$。**

## 样例 #1

### 输入

```
2
0```

### 输出

```
DA```

## 样例 #2

### 输入

```
3
2
1 2
2 3```

### 输出

```
NE```

## 样例 #3

### 输入

```
4
2
1 3
2 4```

### 输出

```
DA```

# 题解

## 作者：Naro_Ahgnay (赞：8)

难度建议：普及/提高。

## 题目描述
一个国家的 $N$ 个城市通过双向航线相连。

规定一次操作为：

+ 选定其中一个城市

+ 开设该城市到其它所有城市的航线，同时取消该城市的原有航线

请问是否存在一种操作方式，使得每两个城市之间都存在直达航线（操作次数不限）。

## 思路
我们假设用01串表示一个城市与第 $i$ 个城市之间是否有航路连接，用1表示有，0表示没有。以第三个样例为例：

第一个城市：0 0 1 0

第二个城市：0 0 0 1

第三个城市：1 0 0 0

第四个城市：0 1 0 0

假设我们对第一个城市进行一次操作，那么变成：

第一个城市：1 1 0 1

第二个城市：1 0 0 1

第三个城市：0 0 0 0

第四个城市：1 1 0 0

可以发现，为了使得题目有解，那么在面对第 $i$ 个城市时，如果此时第 $i$ 个城市和第 $j$ 个城市没有连接时（$i,j∈[1,n],j≠i$），反正不操作一次 $i$ 就肯定无解，不如就给第 $i$ 个城市来一次操作。这种算法类似于贪心，建议结合代码自己理解一下。

注意：因为第一个城市不能在后面的城市中操作到，所以建议工作两次，一次正常搞，另一次先把第一个城市操作一次再搞。
## code

```cpp
#include<cstdio>
#include<cstring>
int n,m,u,v;
bool b[1001][1001],d[1001][1001];
bool ckb()
{
	for(int i=2;i<=n;i++)
		if(!b[1][i]) 
			for(int j=1;j<=n;j++)
				if(j!=i) b[i][j]=b[j][i]=(!b[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(!b[i][j]) return 0;
	return 1;	
}
bool ckd()
{
	for(int i=2;i<=n;i++)
		if(!d[1][i]) 
			for(int j=1;j<=n;j++)
				if(j!=i) d[i][j]=d[j][i]=(!d[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(!d[i][j]) return 0;
	return 1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		b[u][v]=b[v][u]=1;
	}
	std::memcpy(d,b,sizeof(d));
	for(int i=2;i<=n;i++)
		d[i][1]=d[1][i]=(!d[i][1]);
		
	if(ckd()||ckb()) return printf("DA"),0;
	return printf("NE"),0;
}
```


---

## 作者：WRuperD (赞：7)

### 40pts
由题意我们可以发现，对于每个城市我们只有两种选择，**改变或不改变**，爆搜即可。


### 100pts
既然只有两种状态，且操作的先后顺序不影响结果，我们有端联想到 P1391 和 P1764.我们发现，对于第 $i$ 个城市，如果我们确定了它的状态，剩下的 $n-1$  个城市可以通过贪心求解出它们的答案。首先我们需要用 01 串来表示第 $i$ 个城市与其他城市的相连状态。 我们假设：

第一个城市: 0 1 0 

第二个城市: 1 0 0

第三个城市: 0 0 0


我们假设对第一个城市进行一次操作后变为：

第一个城市: 1 0 1 

第二个城市: 0 0 0

第三个城市: 1 0 0

对于第二个城市，它与第一个，第三个城市均不相连，我们不如给他操作一次才有可能游街。

即：对于第 $i$ 个城市，如果它与第 $j$ 个城市不相连，操作它一次。

最后，我们只需要对于第一个城市操作和不操作分别贪心一次即可获得答案。

---

## 作者：_xxxxx_ (赞：3)

### 分析

每次对点的操作为连出的所有边取反，因此对每个点的操作次数不会超过一次。所以每个点只有操作或不操作两个选择。

然后我们可以发现一个重要的性质，对于原图上已经有连边的两个点 $x$ 和 $y$，他们的奇偶性（操作与否）一定相同。

解释一下吧，$x$ 与 $y$ 有连边。此时 $x$ 进行一次操作，边被取消。那需要满足条件的话， $y$ 也必须进行一次操作以恢复这条边。

$x$ 与 $y$ 无连边也同理，即 $x,y$ 的操作奇偶性不相同。

因此原图可以形成若干个联通块，其中每个联通块奇偶性相同，而连通块中的边即为原图上的边。

需要维护联通块，考虑并查集。

发现 $n \le 10^{3}$，我们可以 $O(n^2)$ 的来枚举两个**不同**的点 $x,y$。判断条件即为上文所述性质，检查连边与联通块的奇偶性是否冲突。

现在已经可以得到 $116$ 分了。

我们之前考虑的都是点与点之间的性质，尝试考虑另外一个性质，联通块数量不会大于 $2$。

举个例子，对于 $3$ 个不同的连通块，其中任意两者奇偶性都需不同，无法实现。

加上去这个性质就能华丽的解决了。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m;
int fa[1010];//并查集维护
int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}
map<int, map<int, bool> > conn;//记录原图连通性
signed main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) fa[i] = i;
    for(int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        conn[x][y] = conn[y][x] = 1;
        int fx = find(x), fy = find(y);
        fa[fx] = fy;
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            if(i == j) continue;//不同的x,y
            int fx = find(i), fy = find(j);
            //有边奇偶性相同，无边奇偶性相反
            if((fx == fy) ^ (conn[i][j]) == 1) return cout << "NE\n", 0;
        }
    }
    int cnt = 0;//连通块数量不能大于2
    for(int i = 1; i <= n; i++) cnt += (fa[i] == i);
    cout << (cnt >= 3 ? "NE\n" : "DA\n");
    return 0;
}
```

---

## 作者：zgy_123 (赞：2)

假设每个点初始时操作次数都为 $0$，观察到如果一条边初始时没连，那么变成完全图后要连，这就必须使得两个端点的操作次数奇偶性不同。反过来，如果一条边初始连了，两个端点的操作次数必须奇偶性相同。

所以这个操作可以使用种类并查集来维护：将图存入邻接矩阵中，然后遍历所有元素（所有的 $(i,i)$ 除外），设当前元素为 $(x,y)$，分两种情况：

- 如果当前为 $1$ 也就是两点见有边，那么将 $x$ 和 $y$，$x+n$ 和 $y+n$ 分别合并为一个集合。

- 如果为 $0$，那么将 $x+n$ 和 $y$，$x$ 和 $y+n$ 分别合并为一个集合。

注意，在合并进行操作前，要判断两个点是否已经用外一种关系连接，这一点在代码中有体现。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[1005][1005];
int fa[2005];
int f(int x){return fa[x]==x?x:fa[x]=f(fa[x]);}
void add(int x,int y){fa[f(x)]=f(y);}
int main(){
	for(int i=1;i<=2003;i++) fa[i]=i;
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]=a[y][x]=1; 
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
//			cout<<a[i][j];
			if(i==j) continue;
			if(a[i][j]){
				if(f(i)==f(j+n)||f(i+n)==f(j)){
					cout<<"NE";
					return 0;
				}
				add(i,j),add(i+n,j+n);
			}
			else{
				if(f(i)==f(j)||f(i+n)==f(j+n)){
					cout<<"NE";
					return 0;
				}
				add(i,j+n),add(i+n,j);
			}
//			for(int k=1;k<=2*n;k++) cout<<f(k)<<' ';
//			cout<<endl;
		}
	cout<<"DA";
	return 0;
}

```

---

## 作者：Figo17 (赞：2)

# 本人第一篇题解，多多包涵！

~~机房蒟蒻一枚~~

废话不多说，直接开始吧。

------------

## 首先，

我们先考虑一件事情，对于任意一个城市，它是否会被进行两次操作呢？显然是不会的。我们可以把当前点 $i$ 的航线状态假想成一个二进制数 $d$（以 $n=5$ 为例），并设  $d$ 为任意状态（以 00100 为例，不考虑自身），则更改后的航线为：11011。假设经过若干其他点的更改后，$d$ 变成了 11111，再自身更改后便成为 00000。显然，这与直接在原状态 00100 上做修改所得的结果是一致的。也就是说，每个城市只有一种**更改状态**（改或不改）。

（这里说的有点啰嗦，可以直接把更改操作类比为亦或）

（这里的结论可以用作 40 分状压或暴搜的基础）

------------

## 其次，

我们再思考一个问题，对于当前城市 $i$ 的**更改状态**，若被唯一确定后，其所链接的其他所有城市的更改状态都是可以确定的吗？这是当然，因为一个城市的更改状态只与本身边的存否和对应边的另一城市的更改状态有关，所以就可以由此推出 AC 算法：随意确定一个基准城市，再搜边并作更改，最后 check 一下就可以了。

~~代码有点丑，还请谅解~~

```
#include<bits/stdc++.h>
using namespace std;
bool a[1005][1005][2];//0为本身不改，1为本身改 
int n,m,x,y;
void UpsideDown(int num, bool d)
{
	for(int i=1;i<=n;i++)
	{
		a[num][i][d]^=1;
		a[i][num][d]^=1;
	}
}
bool check()
{
	bool ans1=0,ans2=0;
	for(int i=2;i<=n;i++)
	{
		for(int j=2;j<=n;j++)
		{
			if(i==j) continue;
			if(!a[i][j][0]) ans1=1;
			if(!a[i][j][1]) ans2=1;
		}
	}
	return ans1&ans2;
}
int main()
{
	cin>>n>>m;
	while(m--)
	{
		cin>>x>>y;
		a[x][y][0]=1;a[y][x][0]=1;
		a[x][y][1]=1;a[y][x][1]=1;
	}
	//以1点为标准
	for(int i=2;i<=n;i++)
	{
		a[1][i][1]^=1;
		a[i][1][1]^=1;
		if(!a[1][i][0])
			UpsideDown(i,0);
		if(!a[1][i][1])
			UpsideDown(i,1);
	}
	if(check()) cout<<"NE";
	else cout<<"DA";
	return 0;
}

```

## 最后，

其实这就是两个完全图的构造存在性问题（~~反正也听不懂~~）

希望能过吧。。。谢谢观看！


---

## 作者：tanghg (赞：1)

本题与 P2962 思路很像。

首先我们可以发现，对于任何一个点我们不会操作两次，因为操作两次话边会回来。那么问题就转化成了我们必须要操作哪些点。

可以发现，如果两个点已经是相连的了，则这两个点的操作次数必须相同，否则它们的边就岔开了。

如果两个点未相连，则必然要有一个进行变换。否则也是岔开的。

所以就可以对图进行染色，原来就相连的边染相同的颜色，否则染另一种颜色。判断是否合法即可。

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
const ll MAXN=1000+5;
bool vis[MAXN][MAXN];
ll n,m;
ll color[MAXN];
void dfs(ll u,ll c){
    if(color[u]){
        if(color[u]!=c){
            cout<<"NE\n";
            exit(0);
        }
        return;
    }
    color[u]=c;
    for(int i=1;i<=n;++i){
        if(i==u){
            continue;
        }
        if(vis[u][i]){
            dfs(i,c);
        }else{
            dfs(i,-c);
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;++i){
        ll u,v;
        cin>>u>>v;
        vis[u][v]=vis[v][u]=true;
    }
    dfs(1,1);
    cout<<"DA\n";
    return 0;
}
```

---

## 作者：Feyn (赞：1)

[link](https://www.luogu.com.cn/problem/P7763)

首先从简单的问题开始思考。假如我们只有两个点，应该如何构造方案呢？显然，当两个点有连边时，我们不需要做任何事情（当然两个点各操作一次也是可以的但没有必要）；而两个点没有连边时，只需要选择其中任意一个进行一次操作即可。从这里得出了一个重要的结论，由于操作同一个点两次之后会导致某些对点的连接状态变过去再变回来，相当于没有操作，所以一个点的操作次数要么是零次，要么是零次。

推而广之，对于任意的两个点，要让最后有边连接这两个点，也需要分类讨论。假如一开始这两个点有边，那么要么两个点都不操作，要么两个点都操作一次；假如一开始两个点没有边，那么这两个点中应该只有一个操作过一次，另一个没有操作。然后可以抽离出模型来，可以把操作一次的点放在一个集合，没操作的放在另一个集合；两个点一开始没有连边的话代表这两个点不在同一集合，否则说明在一个集合，根据这个关系判断是不是二分图即可（一个点只能属于一个集合对吧）。

具体实现不用那么麻烦，由于一开始第一个点和其它所有点的连边情况是已知的，所以可以强制一号点属于某个集合，这样一来所有点的集合归属就已经确定了，然后扫描后面的点看有没有矛盾就可以了。

```cpp
#include<bits/stdc++.h>
//#define feyn
using namespace std;
const int N=1010;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int m,n;
bool e[N][N],a[N];

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);read(n);int s1,s2;
	while(n--){
		read(s1);read(s2);
		e[s1][s2]=e[s2][s1]=true;
	}
	for(int i=2;i<=m;i++)a[i]=e[1][i];
	for(int i=2;i<m;i++){
		for(int j=i+1;j<=m;j++){
			if(e[i][j]==true&&a[i]!=a[j]){
				printf("NE\n");return 0;
			}
			if(e[i][j]==false&&a[i]==a[j]){
				printf("NE\n");return 0;
			}
		}
	}
	printf("DA\n");
	
	return 0;
}
```

---

## 作者：EricWan (赞：1)

我们观察题目，发现操作一个点其实就是将没与这个点连边的点连边，连了边的切断这条边，于是我们可以这样转化：

**将一个点操作，相当于取反它与其他点的连边情况。**

之后我们发现：

操作两次一个点是没有用的，因此可以**只讨论一个点是否要被操作**。

将所有点操作一次，每个边被改变两次，原来有的还有，原来没有的还没有。

操作不分先后。

---

我们不妨设不操作 $1$ 号点。

发现本来没有连接边的两个点其中一定也最多有一个被操作。

连了边的两点要么都操作，要么都不。

---

dfs 进行染色即可，染色中途判定数据是否合法，染色都合法结束数据一定合法。

---

Code：

```
#include <bits/stdc++.h>
using namespace std;
int n, m, vis[1005], x, y;
set<int> e[1005];
void dfs(int id, int color) {
    if (vis[id] != -1) {
        if (vis[id] != color) {
            cout << "CSP-J is eazy";
            exit(0);
        }
        return;
    }
    vis[id] = color;
    for (int i = 1; i <= n; i++)
    {
        if (i == id) continue;
        if (e[id].count(i))
            dfs(i, color);
        else
            dfs(i, color ^ 1);
    }
}
int main() {
    memset(vis,-1,sizeof(vis));
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        cin >> x >> y;
        e[x].insert(y);
        e[y].insert(x);
    }
    dfs(1,0);
    cout << "EricWan AK CSP-J";
    return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

# P7763 [COCI2016-2017#5] Ronald 题解

## 题意回顾

对于 $ n $ 点无向图，定义一次操作为将一个点与其他点的连边状态全部取反。判定通过若干次操作让这张图变成完全图的可能性。

$ 2 \le n \le 1000 $。

## 分析

对于一个点，显然多于 $ 1 $ 次的操作是无意义的，因为两次操作会抵消。

故我们可以认为，一组操作解为一种点的染色方案，不操作为白色，操作为黑色。问题转化为对于两个初始即连边的点必须同色（$ 2 $ 次对于这条边的取反操作抵消），对于不连边的点必须异色。

对于连通子图 $ G $，任意两点 $ x,y $ 都可以通过若干条边互相到达，故 $ x,y $ 同色，他们必须初始即有边，故**任何连通子图都必须是完全子图**。

对于点 $ x,y,z $，若互不相连，则 $ x $ 的颜色与 $ y $ 相反，$ y $ 与 $ z $ 相反，则 $ x $ 与 $ z $ 同色，因为 $ x $ 与 $ z $ 不相连，所以出现矛盾。故**图的连通块不能多于 $ 2 $ 个**。

显然，如果初始即为完全图，显然有解；若图是 $ 2 $ 个不相连的完全子图组成的，可以把两个子图分别涂上两种颜色，显然满足要求。

故我们证明了图有不超过两个互不相连的完全子图组成是图可以转化为完全图的充要条件，直接判断即可，这里为了代码简洁我们使用了并查集判断连通块，使用总边数和其中一个完全子图的大小判断出连通块是否为完全子图。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 1005;
int n;
int m;
int fa[N];
int ct;
int getfa(int x) {
    if(fa[x] == x) return x;
    return fa[x] = getfa(fa[x]);
}
int main() {
    cin >> n >> m;
    int u, v;
    ct = n;
    for(int i = 1; i <= n; i++) fa[i] = i;
    for(int i = 1; i <= m; i++) {
        cin >> u >> v;
        u = getfa(u);
        v = getfa(v);
        if(u != v) {
            ct--;
            fa[u] = v;
        }
    }
    if(ct == 1) {
        if(n * (n - 1) / 2 == m) {
            cout << "DA" << endl;
        } else {
            cout << "NE" << endl;
        }
        return 0;
    }
    if(ct > 2) {
        cout << "NE" << endl;
        return 0;
    }
    for(int i = 1; i <= n; i++) fa[i] = getfa(i);
    int sz = 0;
    for(int i = 1; i <= n; i++) {
        if(fa[i] == fa[1]) sz++;
    }
    if(m == sz * (sz - 1) / 2 + (n - sz) * (n - sz - 1) / 2) {
        cout << "DA" << endl;
    } else {
        cout << "NE" << endl;
    }
    return 0;
}

```

---

## 作者：djh0314 (赞：0)

[**洛谷**](https://www.luogu.com.cn/problem/P7763)。

## 题意

显然。

## 分析

对于此题，我们可以从最终状态反推。

最终状态是什么，就是我们所有的节点两两链接（下命名为全联通），而最后一步的前一步的状态是什么呢，这明显是确定的，就是一个节点单独，其他节点仍然全联通，再操作一个节点呢，不难发现，现在是两个节点全联通，剩下的全联通。

以此类推，不难证明，我们回推的图必然是两个全联通图或者是本身就是满足。

由此得到结论，如果所有的节点与其边能够构成两个或一个全联通，那么就输出 DA。

怎么判断是否全联通呢？我们只用判断边数与点数的关系即可。

若 $siz\times (siz-1)=edge\times 2$，所有节点两两联通，即为全联通。

至于连接的过程，我们用并查集维护即可。

~~~cpp
for(int i=1; i<=m; ++i) {
	int u=read(),v=read();
	u=find(u),v=find(v);
	if(u==v) edge[u]++;
	else {
		fa[v]=u;
		siz[u]+=siz[v];
		edge[u]+=edge[v]+1;
	}
}
int cnt=0,flag=0;
for(int i=1; i<=n; ++i) {
	if(fa[i]==i) {
		++cnt;
		if((!check(i))||cnt>2) {
			cout<<"NE";
			return 0;
		}
	}
}
cout<<"DA";
~~~

---

## 作者：cenxinyang12 (赞：0)

## [原题传送门](https://www.luogu.com.cn/problem/P7763)
# 题意
有 $n$ 个点和 $m$ 条连接点的线段，每次操作可以将一个点和其他点的状态取反，求是否有一种方法，能使每个点都与其他至少一个点连接。
# 思路
## 暴力
由题意我们可以发现，对于每个点只有两种选择，改变或不改变，搜索即可。
## 正解
对于第 $i$ 个城市，如果我们确定了它的状态，剩下的 $n - 1$ 个城市可以通过贪心求解出它们的答案。为了解题方便，需要使用 01 串来表示第 $i$ 个城市与其他城市的相连状态。

例如样例三为：

![](https://cdn.luogu.com.cn/upload/image_hosting/p3kdahiy.png)

如果对第一个城市进行操作，那么状态变成：

![](https://cdn.luogu.com.cn/upload/image_hosting/p3kdahiy.png)

对于第二个城市，它与第三个城市不相连，可以对其操作一次。
# 总结
对于第 $i$ 个城市，如果它与第 $j$ 个城市不相连，操作它一次。本题可以采用异或进行处理。
# 代码
~~程序太丑了，那么多换行，凑合着看吧~~

```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
int n,m,i,x,y;
bool f[1010][1010],e[1010][1010];
//pd1是对f处理
bool pd1(){
    int i,j;
    for(i=2;i<=n;i++)
        if(!f[1][i]) 
            for(j=1;j<=n;j++)
                if(j!=i)
                    f[i][j]=f[j][i]^=1;
    for(i=1;i<=n;i++)
        for(j=i+1;j<=n;j++)
            if(!f[i][j])
            	return 0;
    return 1;
}
//pd2是对e处理
bool pd2(){
    int i,j;
    for(i=2;i<=n;i++)
        if(!e[1][i]) 
            for(j=1;j<=n;j++)
                if(j!=i)
                    e[i][j]=e[j][i]^=1;
    for(i=1;i<=n;i++)
        for(j=i+1;j<=n;j++)
            if(!e[i][j])
            	return 0;
    return 1;
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(i=1;i<=m;i++)
    	cin>>x>>y,f[x][y]=f[y][x]=e[x][y]=e[y][x]=1;
    //f为城市1不变的情况，e为城市1变的情况
    for(i=2;i<=n;i++)
    	e[i][1]=e[1][i]^=1;
    if(pd1()||pd2())
    	cout<<"DA";
    else
    	cout<<"NE";
    //判断并输出
    return 0;
}
```


---

## 作者：zero_range (赞：0)

## 题意

一个 $N$ 个顶点，$M$ 条边的无向图。

规定一次操作为：

1. 选定一个节点
2. 取消所有与此点相连的边，并且把原来没有和此点直接相连的点连边

如果这个无向图可以通过若干次操作变成一个完全图（每两个点都**直接**相连），则输出 `DA`，否则输出 `NE`。

## 思路

看上去使用正向思维有一点儿难度？我们不妨使用**反向思维**。

从最终状态**完全图**反推，第一步（最后一步）操作看起来应该像这样：（以 6 个顶点为例）

![img](https://cdn.luogu.com.cn/upload/image_hosting/gapcz8k5.png?x-oss-process=image/resize,m_lfit,h_113,w_150)![img](https://cdn.luogu.com.cn/upload/image_hosting/d9oeezav.png?x-oss-process=image/resize,m_lfit,h_113,w_150)![img](https://cdn.luogu.com.cn/upload/image_hosting/85xpuo4t.png?x-oss-process=image/resize,m_lfit,h_113,w_150)

简单观察就可以发现，第一步其实就是将完全图分解为一个完全连通块（与完全图同理）和一个单点（单点也可以理解成完全连通块）。

之后我们每一次操作，都可以理解如下：

1. 在任意一个完全连通块里取一个点
2. 断开它与原先完全连通块的**所有**连接
3. 把它和另一个完全连通块里的**所有**点连接

如图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/90xle2r5.png?x-oss-process=image/resize,m_lfit,h_113,w_150)![img](https://cdn.luogu.com.cn/upload/image_hosting/aol5pz3r.png?x-oss-process=image/resize,m_lfit,h_113,w_150)![img](https://cdn.luogu.com.cn/upload/image_hosting/be45cmgv.png?x-oss-process=image/resize,m_lfit,h_113,w_150)![img](https://cdn.luogu.com.cn/upload/image_hosting/aol5pz3r.png?x-oss-process=image/resize,m_lfit,h_113,w_150)![img](https://cdn.luogu.com.cn/upload/image_hosting/2050lw8w.png?x-oss-process=image/resize,m_lfit,h_113,w_150)

通过之前的推理可以得到，操作之前和之后原来的图形都有两个完全连通块（或者又回到了开始的情况）。

按这样的方法，从最终状态能够通过如上操作得到的所有状态（即有两个完全连通块的图或者完全图），都是合法的；如果不能得到，则不符合要求。（将反向操作步骤反过来便可以得到正向的操作步骤）

解法便显而易见了。

可以使用[并查集](https://www.luogu.com.cn/problem/P3367)，记录每一个连通块的大小与边的数量，然后判断连通块的个数以及每个连通块是否为完全连通块。

代码：

[提交记录](https://www.luogu.com.cn/record/114293870)

```cpp
#include<stdio.h>
#define M 1005
int n,m,cnt[M],fa[M],sz[M],k;
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) fa[i]=i,sz[i]=1; //初始化
	for(int i=1,u,v;i<=m;++i){
		scanf("%d%d",&u,&v),u=find(u),v=find(v),++cnt[u];
		if(u!=v) fa[v]=u,cnt[u]+=cnt[v],sz[u]+=sz[v]; //如果两个点在同一个连通块内则不需要更新
	}
	for(int i=1;i<=n;++i){
		if(find(i)==i){
			if((sz[i]*(sz[i]-1)/2)!=cnt[i]){ //判断是否为完全连通块
            	puts("NE");return 0;
        	}
			if((++k)>2){puts("NE");return 0;} //连通块个数不能大于2
		}
	}
	puts("DA");
}
```



---

## 作者：plank_black (赞：0)

## 前言

不算难的一个题，冷静下来思考还挺简单的，~~但是我考场上就是冷静不下来，少判断了一种情况~~，思路可能和大家的不太一样，有不严谨的地方还请多多包涵(^_^)

## 题意

有一个图，图中一些点间有边，每次操作选择一个点，将所有与此点相连的边去掉，再把原来没有和此点**直接相连**的点连边，问能否通过一个操作序列将原图变为一个每两点间都相连的图。

模拟一下样例 3 来理解一下题意。

![](https://cdn.luogu.com.cn/upload/image_hosting/pufl4av9.png)

## 思路

有两个显而易见的结论：

 - 选择点进行操作的顺序不同对答案没有影响。
 - 对于每个点，操作两次不如操作。


因此，由第二个结论，每个点我们只有操作与不操作两种选择。
 
重点在证明下一个命题。
 
 
 - 若此图能变为每两点之间都相连的图，则每个连通块内的点都两两相连。
 
 
这里我们使用反证法，若某个连通块内有两点没有两两相连（设为 $a$ 和 $b$）为了让 $a$ 和 $b$ 相连，我们必定要按下其中一个点，且只能按下一个点。假定我们按下的点为 $a$，为了使整个图符合要求，还需要按下与 $a$ 相连的所有点。
 
 
通过一系列类似于广搜的操作后，由于 $a$ 和 $b$ 在一个连通块内，一定会遍历到 $b$，所以 $a$ 和 $b$ 间的边一定会被操作两次，无法相连。
 
 
综上，每个连通块内的点都两两相连。

对于不同连通块之间，只需要将其中一个连通块全部操作一遍就可以相连。

接下来要做的事情就简单了，只需要判断每个联通块内的点是否两两相连即可。
 
## 代码

```cpp
#include<iostream>
using namespace std;

const int N = 1e3 + 10;
int edge[N][N];
int n, m;

void check( );

int main( ) {
	cin >> n >> m;
	if(m == 0) {
		cout << "NE" << endl;
		return 0;
	} 
	
	for(int i = 1; i <= n; i++) edge[i][i] = true;
	
	for(int i = 1; i <= m; i++) {
		int a, b;
		cin >> a >> b;
		edge[a][b] = edge[b][a] = true;
	}
	
	check( );
	
	return 0;
}

void check( ) {
	for(int i = 1; i <= n; i++) //枚举一个点
		for(int j = 1; j <= n; j++) //枚举另一个点
			if(edge[i][j]) //若两点相连
				for(int k = 1; k <= n; k++) // 判断两点所联通的点是否完全一样
					if(edge[i][k] ^ edge[j][k]) {
						cout << "NE" << endl;
						exit(0);
					}
	cout << "DA" << endl;
}
```


---


# [CSP-S 2021] 廊桥分配

## 题目描述

当一架飞机抵达机场时，可以停靠在航站楼旁的廊桥，也可以停靠在位于机场边缘的远机位。乘客一般更期待停靠在廊桥，因为这样省去了坐摆渡车前往航站楼的周折。然而，因为廊桥的数量有限，所以这样的愿望不总是能实现。

机场分为国内区和国际区，国内航班飞机只能停靠在国内区，国际航班飞机只能停靠在国际区。一部分廊桥属于国内区，其余的廊桥属于国际区。

L 市新建了一座机场，一共有 $n$ 个廊桥。该机场决定，廊桥的使用遵循“先到先得”的原则，即每架飞机抵达后，如果相应的区（国内/国际）还有空闲的廊桥，就停靠在廊桥，否则停靠在远机位（假设远机位的数量充足）。该机场只有一条跑道，因此不存在两架飞机同时抵达的情况。

现给定未来一段时间飞机的抵达、离开时刻，请你负责将 $n$ 个廊桥分配给国内区和国际区，使停靠廊桥的飞机数量最多。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/48wcffrv.png)

在图中，我们用抵达、离开时刻的数对来代表一架飞机，如 $(1, 5)$ 表示时刻 $1$ 抵达、时刻 $5$ 离开的飞机；用 $\surd$ 表示该飞机停靠在廊桥，用 $\times$ 表示该飞机停靠在远机位。

我们以表格中阴影部分的计算方式为例，说明该表的含义。在这一部分中，国际区有 $2$ 个廊桥，$4$ 架国际航班飞机依如下次序抵达：

1. 首先 $(2, 11)$ 在时刻 $2$ 抵达，停靠在廊桥。
2. 然后 $(4, 15)$ 在时刻 $4$ 抵达，停靠在另一个廊桥。
3. 接着 $(7, 17)$ 在时刻 $7$ 抵达，这时前 $2$ 架飞机都还没离开、都还占用着廊桥，而国际区只有 $2$ 个廊桥，所以只能停靠远机位。
4. 最后 $(12, 16)$ 在时刻 $12$ 抵达，这时 $(2, 11)$ 这架飞机已经离开，所以有 $1$ 个空闲的廊桥，该飞机可以停靠在廊桥。

根据表格中的计算结果，当国内区分配 $2$ 个廊桥、国际区分配 $1$ 个廊桥时，停靠廊桥的飞机数量最多，一共 $7$ 架。

**【样例解释 #2】**

当国内区分配 $2$ 个廊桥、国际区分配 $0$ 个廊桥时，停靠廊桥的飞机数量最多，一共 $4$ 架，即所有的国内航班飞机都能停靠在廊桥。

需要注意的是，本题中廊桥的使用遵循“先到先得”的原则，如果国际区只有 $1$ 个廊桥，那么将被飞机 $(1, 19)$ 占用，而不会被 $(3, 4)$、$(5, 6)$、$(7, 8)$、$(9, 10)$ 这 $4$ 架飞机先后使用。

**【数据范围】**

对于 $20 \%$ 的数据，$n \le 100$，$m_1 + m_2 \le 100$。  
对于 $40 \%$ 的数据，$n \le 5000$，$m_1 + m_2 \le 5000$。  
对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$m_1, m_2 \ge 1$，$m_1 + m_2 \le {10}^5$，所有 $a_{1, i}, b_{1, i}, a_{2, i}, b_{2, i}$ 为数值不超过 ${10}^8$ 的互不相同的正整数，且保证对于每个 $i \in [1, m_1]$，都有 $a_{1, i} < b_{1, i}$，以及对于每个 $i \in [1, m_2]$，都有 $a_{2, i} < b_{2, i}$。

【感谢 hack 数据提供】

- [xingxuxin](/user/393378)。
- [cyslngsul](/user/126765)。

## 样例 #1

### 输入

```
3 5 4
1 5
3 8
6 10
9 14
13 18
2 11
4 15
7 17
12 16
```

### 输出

```
7
```

## 样例 #2

### 输入

```
2 4 6
20 30
40 50
21 22
41 42
1 19
2 18
3 4
5 6
7 8
9 10
```

### 输出

```
4
```

## 样例 #3

### 输入

```
见附件中的 airport/airport3.in```

### 输出

```
见附件中的 airport/airport3.ans```

# 题解

## 作者：StudyingFather (赞：394)

让我们先忽略廊桥数量的限制来安排航班。我们维护一个空闲的廊桥队列，每到达一架航班，就给它安排编号最小的廊桥供其使用。

现在加上廊桥数量的限制。容易发现刚才的廊桥分配方法直接就帮我们解决了廊桥限制的问题：如果当前有 $n$ 个廊桥可供使用，则分配到 $n+1$ 号及以后的廊桥实质上就是分配到远机位了，不需要再做任何额外的处理。

到这里做法就很清晰了：我们按照开头提到的分配方法来安排航班的停靠位置，记录各廊桥停靠的航班数，做一个前缀和，最后枚举分配给某个区的廊桥数，算出各情况下两区实际使用廊桥的航班数总和，即可解决本题。

```cpp
// Problem: P7913 [CSP-S 2021] 廊桥分配（洛谷民间数据）
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7913
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
typedef pair<int, int> pii;
struct range {
  int x, y;
} a[100005], b[100005];
int res1[100005], res2[100005];
int n;
bool cmp(const range& a, const range& b) { return a.x < b.x; }
void calc(range* t, int m, int* res) {
  priority_queue<pii, vector<pii>, greater<pii> > lq; // 等待离港航班队列
  priority_queue<int, vector<int>, greater<int> > wq; // 空闲廊桥队列
  for (int i = 1; i <= n; i++) wq.push(i);
  for (int i = 1; i <= m; i++) {
    while (!lq.empty() && t[i].x >= lq.top().first) {
      wq.push(lq.top().second);
      lq.pop();
    }
    if (wq.empty()) continue;
    int dest = wq.top();
    wq.pop();
    res[dest]++;
    lq.push(make_pair(t[i].y, dest));
  }
  for (int i = 1; i <= n; i++) res[i] += res[i - 1];
}
int main() {
  int m1, m2;
  cin >> n >> m1 >> m2;
  for (int i = 1; i <= m1; i++) cin >> a[i].x >> a[i].y;
  for (int i = 1; i <= m2; i++) cin >> b[i].x >> b[i].y;
  sort(a + 1, a + m1 + 1, cmp);
  sort(b + 1, b + m2 + 1, cmp);
  calc(a, m1, res1);
  calc(b, m2, res2);
  int ans = 0;
  for (int i = 0; i <= n; i++) {
    ans = max(ans, res1[i] + res2[n - i]);
  }
  cout << ans << endl;
  return 0;
}
```

---

## 作者：SevenElevenThirteen (赞：156)

$\texttt{Upd On 2020/5/9}$：补充若干说明，规范 $\LaTeX$。

提供一种 **仅使用普及知识点，不用优先队列、`set`、`pair`、线段树、树状数组、分块** 的做法。 

[题目链接](https://www.luogu.com.cn/problem/P7913)

我们从样例 $1$ 入手。
![当你看到这行文字时，这张图片已经挂了。](https://cdn.luogu.com.cn/upload/image_hosting/huhkczmn.png)

观察图片，不难看出能共用一个廊桥的飞机一定是在时间上没有重叠的（例如上图国内航班第 $1,3, 5$ 架）。这启示我们将所有飞机不重不漏地分组，使得每个组内的飞机都可以用一个廊桥解决停靠问题。

由于国内航班和国际航班是各自独立的，在此只用国内航班说明。用 $arr_i$ 和 $lea_i$ 表示第 $i$ 架飞机的抵达、离开时刻，$id_i$ 表示第 $i$ 架飞机是否已被分组。首先将所有飞机按照抵达时间从小到大排序（下文所指均为排序后的飞机），然后从 $1$ 开始枚举飞机。

还是以样例 $1$ 为例，不妨把飞机 $1\;\left[ 1,5 \right]$ 分到第 $1$ 组，并把 $id_1$ 修改为 $1$。因为同组内飞机没有时间冲突，所以下一架可选飞机 $3\;\left[6,10\right]$、$4\;\left[9,14\right]$、$5\;\left[13,18\right]$。应该选哪一架呢？飞机遵循“先到先得”原则，贪心地想，当飞机 $3$ 降落时，至少有一座廊桥是空闲的（即飞机 $1$ 使用的），而它在哪里停靠都是一样的，因此把它和飞机 $1$ 分为一组不会改变答案。推广一下，假设飞机 $i$ 已经被分组，同组内的下一架应是所有满足 $arr_x > lea_i \; \land \; id_x = 0$ 中抵达时间最早的。由于事先已将飞机排序，可以用二分找出第一架抵达时间晚于 $lea_i$ 的飞机 $x$。不断重复这一过程，如果没有飞机可选，则这一组已经分完。

注意到 $id$ 数组并没有单调性，即有可能 $id_x \ne 0$。若从 $x$ 向后暴力枚举，复杂度可能退化成 $O\left(n^2\right)$，显然无法接受。我们借用并查集的路径压缩思想来巧妙地解决这一问题。定义 $c_i$ 为第一架降落时间晚于 $arr_i$ 且没有组的飞机编号，初始时 $c_i \gets i + 1$。重复执行 $x \gets c_x$，直到 $id_x = 0$，开一个 `vector` 存储所有经过的飞机编号。对于 `vector` 中的每个数 $num$，把 $c_{num} \gets c_x$，这样下次查找时就会跳过没用的飞机。（$\texttt{Upd}$：其实这就是并查集，此部分复杂度 $O\left( n\log n \right)$。当然你也可以同时使用路径压缩和按秩合并，复杂度几乎线性。）

假设我们已经分好组，如果你认为从中选择飞机数最多的 $n$ 个组即为答案，那就大错特错了。回顾算法流程，组与组之间其实有着时间上的先后。回到样例，第 $1,3,5$ 架为第一组，第 $2,4$ 架为第二组。若此时只有一个廊桥，则第二组是用不上的，因为飞机 $1$ 已经占用了！我们不用排序，直接处理出前 $i$ 个国内/国际航班的组的前缀和 $s_1,\,s_2$，答案为 $\max\left\{s_{1_i} + s_{2_{n - i}}\right\}$。

以下为考场代码。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

const int N = 1e5;
int n,m1,m2;
struct Node{
    int arr,lea,id;
    void read()
    {
        scanf("%d%d",&arr,&lea);
        return ;
    }
    bool operator < (const Node& x) const
    {
        return arr < x.arr;
    }
}a[N + 5],b[N + 5];
int g1[N + 5],g2[N + 5],top1,top2;//g1 : 国内航班  g2 : 国际航班
int c[N + 5];
int nxta(int x)//二分+路径压缩
{
    int l = 1,r = m1,res = -1;
    while (l <= r)
    {
        int mid = (l + r) >> 1;
        if (a[mid].arr >= x)
        {
            res = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    if (res < 0) return res;
    vector<int> upd;
    while (res > 0 && a[res].id != 0)
    {
        upd.push_back(res);
        res = c[res];
    }
    while (!upd.empty())
    {
        c[upd.back()] = c[res];
        upd.pop_back();
    }
    return res;
}
void pre1()
{
    for (int i = 1;i < m1;i++) c[i] = i + 1;
    c[m1] = -1;//-1表示没有飞机
    for (int i = 1;i <= m1;i++)
    {
        if (a[i].id != 0) continue;
        a[i].id = 1;
        int cnt = 1,x = a[i].lea + 1;
        int pos = nxta(x);
        while (pos > 0)
        {
            a[pos].id = 1;
            x = a[pos].lea + 1;
            cnt++;
            pos = nxta(x);
        }
        top1++;
        g1[top1] = cnt;
    }
    return ;
}
int nxtb(int x)
{
    int l = 1,r = m2,res = -1;
    while (l <= r)
    {
        int mid = (l + r) >> 1;
        if (b[mid].arr >= x)
        {
            res = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    if (res < 0) return res;
    vector<int> upd;
    while (res > 0 && b[res].id != 0)
    {
        upd.push_back(res);
        res = c[res];
    }
    while (!upd.empty())
    {
        c[upd.back()] = c[res];
        upd.pop_back();
    }
    return res;
}
void pre2()
{
    for (int i = 1;i < m2;i++) c[i] = i + 1;
    c[m2] = -1;
    for (int i = 1;i <= m2;i++)
    {
        if (b[i].id != 0) continue;
        b[i].id = 1;
        int cnt = 1,x = b[i].lea + 1;
        int pos = nxtb(x);
        while (pos > 0)
        {
            b[pos].id = 1;
            x = b[pos].lea + 1;
            cnt++;
            pos = nxtb(x);
        }
        top2++;
        g2[top2] = cnt;
    }
    return ;
}
int s1[N + 5],s2[N + 5];
void calc()
{
    for (int i = 1;i <= n;i++)
    {
        s1[i] = s1[i - 1] + g1[i];
    }
    for (int i = 1;i <= n;i++)
    {
        s2[i] = s2[i - 1] + g2[i];
    }
    return ;
}

int main()
{
    freopen("airport.in","r",stdin);
    freopen("airport.out","w",stdout);
    scanf("%d%d%d",&n,&m1,&m2);
    for (int i = 1;i <= m1;i++)
    {
        a[i].read();
    }
    for (int i = 1;i <= m2;i++)
    {
        b[i].read();
    }
    sort(a + 1,a + m1 + 1);
    sort(b + 1,b + m2 + 1);
    pre1();
    pre2();
    calc();
    int ans = 0;
    for (int i = 0;i <= n;i++)
    {
        ans = max(ans,s1[i] + s2[n - i]);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：zimujun (赞：102)

> Upd on 2021/11/1: 换上官方数据后，原来的代码被 hack 了，抱歉没有充分测试其他 OJ 上的数据，仅仅在代码完成后通过了 Infoj 和洛谷的民间数据（LibreOJ WA + RE），现已修复并删除原来存在的调试内容。

首先有一个关键结论：如果给廊桥编上号，每当一架飞机到达后，如果强制让它进入编号最小的廊桥，这样不会影响进入廊桥飞机的集合，且当廊桥总数增加后，原本在哪个廊桥的飞机，仍旧会进入原来的廊桥。

这个性质也很好理解：新加入廊桥可以视为原先的远机位的一部分，进入新加的这个廊桥的飞机可以视为在原来该进入远机位的飞机中贪心选择一轮。

至此本题已经有了优秀的解决方案：处理出每架飞机在廊桥充足的时候会进入哪个廊桥，然后在差分数组上统计一下即可。

考虑如何实现这个预处理过程：

考虑新建一个时间堆和空闲的编号堆，把所有的飞机按照到达时间排序，如果编号堆中有剩余就取出最小的编号，绑上这家飞机的离开时间扔进时间堆中，每当一架飞机进入之前，先把已经超过离开时间的飞机弹出，释放空闲的廊桥即可。

时间复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int Maxn = 1e5 + 5;

struct e {
	int st, ed;
} a[Maxn];
bool cmp(e x, e y) {
	return x.st < y.st;
}

std::priority_queue<int> hp_id;
std::priority_queue<std::pair<int, int> > hp_ed; 

int n, m1, m2, ca[Maxn], cb[Maxn];

int main() {
	scanf("%d%d%d", &n, &m1, &m2);
	for(int i = 1; i <= m1; ++i) scanf("%d%d", &a[i].st, &a[i].ed);
	std::sort(a + 1, a + m1 + 1, cmp);
	for(int i = 1; i <= n; ++i) hp_id.push(-i);
	for(int i = 1; i <= m1; ++i) {
		if(!hp_ed.empty()) {
            while(-hp_ed.top().first < a[i].st) {
                hp_id.push(-hp_ed.top().second), hp_ed.pop();
                if(hp_ed.empty()) break;
            }
        }
        if(!hp_id.empty()) {
			int x = -hp_id.top(); hp_id.pop();
			ca[x]++; hp_ed.push(std::make_pair(-a[i].ed, x));
		}
	}
    for(int i = 1; i <= n; ++i) ca[i] += ca[i - 1];
	while(!hp_ed.empty()) hp_ed.pop(); while(!hp_id.empty()) hp_id.pop();
	for(int i = 1; i <= m2; ++i) scanf("%d%d", &a[i].st, &a[i].ed);
	std::sort(a + 1, a + m2 + 1, cmp);
	for(int i = 1; i <= n; ++i) hp_id.push(-i); 
	for(int i = 1; i <= m2; ++i) {
		if(!hp_ed.empty()) {
            while(-hp_ed.top().first < a[i].st) {
                hp_id.push(-hp_ed.top().second), hp_ed.pop();
                if(hp_ed.empty()) break;
            }
        }
		if(!hp_id.empty()) {
			int x = -hp_id.top(); hp_id.pop();
			cb[x]++; hp_ed.push(std::make_pair(-a[i].ed, x));
		}
	}
	for(int i = 1; i <= n; ++i) cb[i] += cb[i - 1]; 
	
	int mx_ans = 0;
	for(int i = 0; i <= n; ++i) mx_ans = std::max(mx_ans, ca[i] + cb[n - i]);
	printf("%d", mx_ans);
	
	return 0;
}
```

---

## 作者：hensier (赞：80)

首先我们需要对原来形象的实际问题进行抽象化。

以样例 1 的国内航班抵达、离开时刻信息为例，我们可以通过区间来表示每架飞机位于机场的时间：

![](https://cdn.luogu.com.cn/upload/image_hosting/8hr0ne6d.png)

不妨先假设廊桥数量没有限制，那么当一个新的飞机抵达时，显然需要使用一个空闲的廊桥。当飞机离开时，就可以释放出一个空闲的廊桥。因此，我们可以记下所需廊桥的数量。当一架飞机抵达时计数器 $+1$，离开时 $-1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/79al6hlt.png)

具体流程如下：

|时刻|航班序号|抵达/离开|当前正在使用的廊桥数量（计数器）
| :----------: | :----------: | :----------: | :----------: |
|$1$|$1$|抵达|$0+1=1$|
|$3$|$2$|抵达|$1+1=2$|
|$5$|$1$|离开|$2-1=1$|
|$6$|$3$|抵达|$1+1=2$|
|$8$|$2$|离开|$2-1=1$|
|$9$|$4$|抵达|$1+1=2$|
|$10$|$3$|离开|$2-1=1$|
|$13$|$5$|抵达|$1+1=2$|
|$14$|$4$|离开|$2-1=1$|
|$18$|$5$|离开|$1-1=0$|

显然，所需的廊桥数量为计数器在所有时刻内的最大值，在本例中为 $2$。

接下来考虑增加廊桥限制时的操作方法：

在进行计数器 $+1$ 操作时，如果计数器在操作之后超过廊桥限制数量，那么就让该飞机不进入廊桥，同时进行标记以防后面操作时对该航班进行 $-1$ 操作。

如果廊桥数量限制为 $1$，那么示意图将会变成这样（灰色表示无法进入廊桥）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ikod8svd.png)

具体实现方法是先把读入的航班信息按照抵达时刻从小到大进行排序并对时刻进行离散化。然后在 $[0,n]$ 内枚举廊桥数量限制，并在限制条件下对每个离散化后的时刻进行 $+1/-1$ 处理，依次得到最大航班数量。最后进行统计即可：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m_1,m_2,ld,li,ans,td[200005],ti[200005],posd[200005][2],posi[200005][2];
bool vis[100005];
struct flight
{
    int a,b;
    bool operator<(const flight &x)const
    {
        return a<x.a;
    }
}dom[100005],inter[100005]; // domestic: 国内，international: 国际
int solve(int a[][2],int len,int x)
{
    int cnt=0,ans=0; // cnt 为廊桥数量计数器，ans 记录能够进入廊桥的航班数量
    memset(vis,false,sizeof(vis)); // vis 数组存储每个航班是否能够进入廊桥
    for(int i=1;i<=len;++i)
    {
        if(a[i][1]) // 判断是否为抵达
        {
            if(cnt<x) // 判断是否还可进入廊桥
            {
                ++cnt; // 当前廊桥数量 +1
                ++ans; // 可进入廊桥的航班数 +1
                vis[a[i][0]]=true; // 标记该航班能进入廊桥
            }
        }
        else if(vis[a[i][0]])--cnt; // 如果当前时刻有飞机离开且该飞机原来在廊桥中，则当前廊桥数量 -1
    }
    return ans;
}
template<typename T>void read(T &x)
{
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
int main()
{
    read(n),read(m_1),read(m_2);
    for(int i=1;i<=m_1;++i)
    {
        read(dom[i].a),read(dom[i].b);
        td[++ld]=dom[i].a;
        td[++ld]=dom[i].b;
        // 将时刻存入待离散化的数组中（国内、国际分开存储）
    }
    for(int i=1;i<=m_2;++i)
    {
        read(inter[i].a),read(inter[i].b);
        ti[++li]=inter[i].a;
        ti[++li]=inter[i].b;
    }
    sort(td+1,td+ld+1);
    sort(ti+1,ti+li+1);
    // 由于没有重复时刻，因此只需排序、无需去重
    sort(dom+1,dom+m_1+1);
    sort(inter+1,inter+m_2+1);
    // 按照抵达时刻从小到大进行排序（国内、国际分开）
    for(int i=1;i<=m_1;++i)
    {
        dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td;
        dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td;
        // 将航班的时刻修改为离散化后的数值，方便操作
        posd[dom[i].a][0]=posd[dom[i].b][0]=i;
        posd[dom[i].a][1]=1;
        // 第二维 0 下标存储航班序号、1 下标存储该时刻是否是飞机抵达
    }
    for(int i=1;i<=m_2;++i)
    {
        inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti;
        inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti;
        posi[inter[i].a][0]=posi[inter[i].b][0]=i;
        posi[inter[i].a][1]=1;
    }
    for(int i=0;i<=n;++i)ans=max(ans,solve(posd,ld,i)+solve(posi,li,n-i)); // [0,n] 枚举廊桥数量限制
    printf("%d",ans);
    return 0;
}
```

这样，我们便得到了一个 $\mathcal O(n(m_1+m_2)+m_1 \log m_1+m_2 \log m_2) \approx \mathcal O(n^2)$ 的做法，可以获得 $40$ 分的好成绩。

接着考虑如何对 $O(n^2)$ 做法进行优化。

原来的暴力程序采用先枚举限制再遍历时刻的方法。由于遍历时刻的操作不可优化，因此我们可以考虑先遍历时刻再枚举限制。

不妨用数组 $\{\text{sum}_i\}$ 来记录限制数量为 $i$ 时当前所需廊桥的数量，用数组 $\{\text{ans}_i\}$ 来记录限制数量为 $i$ 时当前可进入廊桥的航班数量。不难发现，这两个数组一定**单调不递减**。

在遍历时刻的过程中，对于每一个时刻，我们可以分两种情况讨论：

- 该时刻有飞机抵达。此时我们可以在 $\{\text{sum}_i\}$ 中进行二分，找到一个最大的 $p$，使得 $\text{sum}_p \lt p$（即飞机还可进入廊桥）。紧接着，我们把 $[p,n]$ 内的 $\text{sum}$ 值和 $\text{ans}$ 值全部加上 $1$。和暴力程序类似，我们在该航班的对应位置标记 $p$，方便后续操作。如果所有的 $\text{sum}$ 值都不小于 $p$，那么就标记 $-1$。

- 该时刻有飞机离开。由于该飞机的离开时刻一定晚于抵达时刻，因此我们可以查看之前所做的标记。如果标记 $\text{pos}$ 不为 $-1$，那么就把 $[\text{pos},n]$ 内的 $\text{sum}$ 全部减 $1$，完成还原操作。

如果每次进行暴力 $+1$ / $-1$，那么时间复杂度仍为 $\mathcal O(n^2)$。但考虑到修改都是区间性的，因此可以通过线段树、区修单查的树状数组或分块实现。

常数较大的 $\mathcal O(n \log^2n)$ 线段树代码：（最大时限 $\approx 200$ $\text{ms}$）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m_1,m_2,ld,li,cn,ANS,td[200005],ti[200005],posd[200005][2],posi[200005][2],pos[100005],ansd[100005],ansi[100005];
struct flight
{
    int a,b;
    bool operator<(const flight &x)const
    {
        return a<x.a;
    }
}dom[100005],inter[100005];
struct node
{
    int l,r,ls,rs,sum,tag;
};
struct segtree
{
    node t[200005]; // 这种线段树写法只需开 2 倍空间
    void build(int p,int l,int r) // 线段树建树的复杂度为 O(n)
    {
        t[p].l=l,t[p].r=r;
        if(l==r)return;
        int mid=(t[p].l+t[p].r)>>1;
        build(t[p].ls=++cn,l,mid);
        build(t[p].rs=++cn,mid+1,r);
    }
    void init()
    {
        cn=1;
        build(1,1,n);
    }
    void reset()
    {
        for(int i=1;i<=n<<1;++i)
        {
            t[i].sum=0;
            t[i].tag=0;
        }
    }
    void push_up(int p)
    {
        if(!t[p].tag)return;
        int l=t[p].ls,r=t[p].rs;
        t[l].sum+=(t[l].r-t[l].l+1)*t[p].tag;
        t[r].sum+=(t[r].r-t[r].l+1)*t[p].tag;
        t[l].tag+=t[p].tag;
        t[r].tag+=t[p].tag;
        t[p].tag=0;
    }
    void update(int p,int l,int r,int k) // 线段树区间修改的复杂度为 O(log n)
    {
        if(l<=t[p].l&&t[p].r<=r)
        {
            t[p].sum+=(t[p].r-t[p].l+1)*k;
            t[p].tag+=k;
            return;
        }
        push_up(p);
        int mid=(t[p].l+t[p].r)>>1;
        if(l<=mid)update(t[p].ls,l,r,k);
        if(r>mid)update(t[p].rs,l,r,k);
        t[p].sum=t[t[p].ls].sum+t[t[p].rs].sum;
    }
    int query(int p,int l,int r) // 线段树单点 / 区间查询的复杂度均为 O(log n)
    {
        if(l<=t[p].l&&t[p].r<=r)return t[p].sum;
        push_up(p);
        int mid=(t[p].l+t[p].r)>>1;
        if(l>mid)return query(t[p].rs,l,r);
        if(r<=mid)return query(t[p].ls,l,r);
        return query(t[p].ls,l,r)+query(t[p].rs,l,r);
    }
}sum,ans;
void solve(int a[][2],int len,bool flag)
{
    memset(pos,0,sizeof(pos));
    if(flag)sum.reset(),ans.reset();
    else sum.init(),ans.init();
    // flag 表示是否为第一次进行 solve 操作；如果为 false 就进行建树，否则重新赋值
    for(int i=1;i<=len;++i)
    {
        if(a[i][1])
        {
            int l=1,r=n,p=-1;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                if(sum.query(1,mid,mid)<mid)
                {
                    r=mid-1;
                    p=mid;
                }
                else l=mid+1;
            }
            // 二分查找最大的 p，使得 sum[p]<p
            pos[a[i][0]]=p;
            if(~p)
            {
                sum.update(1,p,n,1);
                ans.update(1,p,n,1);
                // +1 操作
            }
        }
        else if(~pos[a[i][0]])sum.update(1,pos[a[i][0]],n,-1); // -1 还原性操作
    }
    for(int i=1;i<=n;++i)
    {
        if(flag)ansi[i]=ans.query(1,i,i);
        else ansd[i]=ans.query(1,i,i);
        // 将答案存入对应数组中，方便后面进行 O(n) 统计
    }
}
template<typename T>void read(T &x)
{
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
int main()
{
    read(n),read(m_1),read(m_2);
    for(int i=1;i<=m_1;++i)
    {
        read(dom[i].a),read(dom[i].b);
        td[++ld]=dom[i].a;
        td[++ld]=dom[i].b;
    }
    for(int i=1;i<=m_2;++i)
    {
        read(inter[i].a),read(inter[i].b);
        ti[++li]=inter[i].a;
        ti[++li]=inter[i].b;
    }
    sort(td+1,td+ld+1);
    sort(ti+1,ti+li+1);
    sort(dom+1,dom+m_1+1);
    sort(inter+1,inter+m_2+1);
    for(int i=1;i<=m_1;++i)
    {
        dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td;
        dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td;
        posd[dom[i].a][0]=posd[dom[i].b][0]=i;
        posd[dom[i].a][1]=1;
    }
    for(int i=1;i<=m_2;++i)
    {
        inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti;
        inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti;
        posi[inter[i].a][0]=posi[inter[i].b][0]=i;
        posi[inter[i].a][1]=1;
    }
    solve(posd,ld,false);
    solve(posi,li,true);
    for(int i=0;i<=n;++i)ANS=max(ANS,ansd[i]+ansi[n-i]);
    printf("%d",ANS);
    return 0;
}
```

$\mathcal O(n \log n + n \sqrt n)$ 的分块代码：（最大时限 $\approx 100$ $\text{ms}$）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m_1,m_2,ld,li,len,ANS,td[200005],ti[200005],posd[200005][2],posi[200005][2],pos[100005],id[100005],ansd[100005],ansi[100005];
struct flight
{
    int a,b;
    bool operator<(const flight &x)const
    {
        return a<x.a;
    }
}dom[100005],inter[100005];
struct block
{
    int a[100005],b[325],block[325];
    void reset()
    {
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        memset(block,0,sizeof(block));
    }
    void update(int l,int r,int k) // 分块区间修改的复杂度为 O(sqrt(n))
    {
        int x=id[l],y=id[r];
        if(x==y)
        {
            for(int i=l;i<=r;++i)
            {
                a[i]+=k;
                block[x]+=k;
            }
            return;
        }
        for(int i=l;i<=len*x;++i)
        {
            a[i]+=k;
            block[x]+=k;
        }
        for(int i=x+1;i<y;++i)
        {
            b[i]+=k;
            block[i]+=len*k;
        }
        for(int i=len*(y-1)+1;i<=r;++i)
        {
            a[i]+=k;
            block[y]+=k;
        }
    }
}sum,ans;
void solve(int a[][2],int len,bool flag)
{
    if(flag)
    {
        memset(pos,0,sizeof(pos));
        sum.reset(),ans.reset();
    }
    for(int i=1;i<=len;++i)
    {
        if(a[i][1])
        {
            int l=1,r=n,p=-1;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                if(sum.a[mid]+sum.b[id[mid]]<mid)
                {
                    r=mid-1;
                    p=mid;
                }
                else l=mid+1;
                // 分块单点查询的复杂度为 O(1)
            }
            pos[a[i][0]]=p;
            if(~p)
            {
                sum.update(p,n,1);
                ans.update(p,n,1);
            }
        }
        else if(~pos[a[i][0]])sum.update(pos[a[i][0]],n,-1);
    }
    for(int i=1;i<=n;++i)
    {
        if(flag)ansi[i]=ans.a[i]+ans.b[id[i]];
        else ansd[i]=ans.a[i]+ans.b[id[i]];
    }
}
template<typename T>void read(T &x)
{
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
int main()
{
    read(n),read(m_1),read(m_2);
    for(int i=1;i<=m_1;++i)
    {
        read(dom[i].a),read(dom[i].b);
        td[++ld]=dom[i].a;
        td[++ld]=dom[i].b;
    }
    for(int i=1;i<=m_2;++i)
    {
        read(inter[i].a),read(inter[i].b);
        ti[++li]=inter[i].a;
        ti[++li]=inter[i].b;
    }
    sort(td+1,td+ld+1);
    sort(ti+1,ti+li+1);
    sort(dom+1,dom+m_1+1);
    sort(inter+1,inter+m_2+1);
    for(int i=1;i<=m_1;++i)
    {
        dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td;
        dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td;
        posd[dom[i].a][0]=posd[dom[i].b][0]=i;
        posd[dom[i].a][1]=1;
    }
    for(int i=1;i<=m_2;++i)
    {
        inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti;
        inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti;
        posi[inter[i].a][0]=posi[inter[i].b][0]=i;
        posi[inter[i].a][1]=1;
    }
    len=sqrt(n);
    for(int i=1;i<=n;++i)id[i]=(i-1)/len+1;
    solve(posd,ld,false);
    solve(posi,li,true);
    for(int i=0;i<=n;++i)ANS=max(ANS,ansd[i]+ansi[n-i]);
    printf("%d",ANS);
    return 0;
}
```

常数较小的 $\mathcal O(n \log^2 n)$ 树状数组代码：（最大时限 $\approx 50$ $\text{ms}$）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m_1,m_2,ld,li,ANS,td[200005],ti[200005],posd[200005][2],posi[200005][2],pos[100005],ansd[100005],ansi[100005];
struct flight
{
    int a,b;
    bool operator<(const flight &x)const
    {
        return a<x.a;
    }
}dom[100005],inter[100005];
struct BIT
{
    int t[100005];
    void update(int x,int k)
    {
        while(x<=n)
        {
            t[x]+=k;
            x+=x&-x;
        }
    }
    int query(int x)
    {
        int s=0;
        while(x)
        {
            s+=t[x];
            x-=x&-x;
        }
        return s;
    }
    // 这种树状数组的修改和查询复杂度均为 O(log n)
}sum,ans;
void solve(int a[][2],int len,bool flag)
{
    if(flag)
    {
        memset(pos,0,sizeof(pos));
        memset(sum.t,0,sizeof(sum.t));
        memset(ans.t,0,sizeof(ans.t));
    }
    for(int i=1;i<=len;++i)
    {
        if(a[i][1])
        {
            int l=1,r=n,p=-1;
            while(l<=r)
            {
                int mid=(l+r)>>1;
                if(sum.query(mid)<mid)
                {
                    r=mid-1;
                    p=mid;
                }
                else l=mid+1;
            }
            pos[a[i][0]]=p;
            if(~p)
            {
                sum.update(p,1);
                ans.update(p,1);
            }
        }
        else if(~pos[a[i][0]])sum.update(pos[a[i][0]],-1);
    }
    for(int i=1;i<=n;++i)
    {
        if(flag)ansi[i]=ans.query(i);
        else ansd[i]=ans.query(i);
    }
}
template<typename T>void read(T &x)
{
    char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
int main()
{
    read(n),read(m_1),read(m_2);
    for(int i=1;i<=m_1;++i)
    {
        read(dom[i].a),read(dom[i].b);
        td[++ld]=dom[i].a;
        td[++ld]=dom[i].b;
    }
    for(int i=1;i<=m_2;++i)
    {
        read(inter[i].a),read(inter[i].b);
        ti[++li]=inter[i].a;
        ti[++li]=inter[i].b;
    }
    sort(td+1,td+ld+1);
    sort(ti+1,ti+li+1);
    sort(dom+1,dom+m_1+1);
    sort(inter+1,inter+m_2+1);
    for(int i=1;i<=m_1;++i)
    {
        dom[i].a=lower_bound(td+1,td+ld+1,dom[i].a)-td;
        dom[i].b=lower_bound(td+1,td+ld+1,dom[i].b)-td;
        posd[dom[i].a][0]=posd[dom[i].b][0]=i;
        posd[dom[i].a][1]=1;
    }
    for(int i=1;i<=m_2;++i)
    {
        inter[i].a=lower_bound(ti+1,ti+li+1,inter[i].a)-ti;
        inter[i].b=lower_bound(ti+1,ti+li+1,inter[i].b)-ti;
        posi[inter[i].a][0]=posi[inter[i].b][0]=i;
        posi[inter[i].a][1]=1;
    }
    solve(posd,ld,false);
    solve(posi,li,true);
    for(int i=0;i<=n;++i)ANS=max(ANS,ansd[i]+ansi[n-i]);
    printf("%d",ANS);
    return 0;
}
```

---

## 作者：yaoxi (赞：53)

## CSP-S 2021的签到题 (不需要用堆的做法)

### 假掉的三分

先说下我刚开始想到的错误做法吧。

首先想到了三分答案，但是很显然这道题不一定是个单峰函数，于是一分钟后便弃掉了这个做法。

### 正确解法

我们不妨考虑每次加入一个廊桥对最终答案的贡献。由于题目中说“先到先得”，所以新加入一个廊桥肯定是不会影响到已经有廊桥的飞机，又因为先到先得，所以我们维护一下还没有分配到廊桥的飞机，从中取出最先到达的分配给当前的廊桥，等到这架飞机离开后取出在那之后最先到达的未分配的飞机，以此类推，直到没有更靠后到达的飞机为止。

这显然可以用 `set` 来维护未分配的飞机。答案存入 $cnt1$ 和 $cnt2$ 数组，分别表示国内和国际航班分配 $i$ 个廊桥的答案数。

最后答案就是 $\max\limits_{i=0}^{n}{(cnt1_i+cnt2_{n-i})}$ 

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define resetIO(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout)
#define debug(fmt, ...) \
	fprintf(stderr, "[%s:%d] " fmt "\n", __FILE__, __LINE__, ## __VA_ARGS__)
template<class T> inline T &read(T &x){
	bool f = true; x = 0; char ch = getchar();
	for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');
	for(; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	return f ? x : (x = -x);
}
template<class T> inline void write(T x){
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10);
	putchar((x % 10) ^ 48);
}
const int maxn = 1e5+5;
const int inf = 0x3f3f3f3f3f3f3f3f;
struct node{
	int l, r;
	bool operator<(const node &o)const{
		return l < o.l;
	}
};
int n, m1, m2, cnt1[maxn], cnt2[maxn];
node a1[maxn], a2[maxn];
set<node> st;
signed main(){
	// resetIO(airport);
	read(n); read(m1); read(m2);
	for(int i=1; i<=m1; i++)
		read(a1[i].l), read(a1[i].r);
	for(int i=1; i<=m2; i++)
		read(a2[i].l), read(a2[i].r);
	st.clear();
	for(int i=1; i<=m1; i++)
		st.insert(a1[i]);
	for(int i=1; i<=n; i++){
		int pos = 0, c = 0;
		while(true){
			auto it = st.lower_bound(node{pos, 0});
			if(it == st.end()) break;
			pos = it->r;
			st.erase(it); ++c;
		}
		cnt1[i] = cnt1[i - 1] + c;
	}
	st.clear();
	for(int i=1; i<=m2; i++)
		st.insert(a2[i]);
	for(int i=1; i<=n; i++){
		int pos = 0, c = 0;
		while(true){
			auto it = st.lower_bound(node{pos, 0});
			if(it == st.end()) break;
			pos = it->r;
			st.erase(it); ++c;
		}
		cnt2[i] = cnt2[i - 1] + c;
	}
	int ans = 0;
	for(int i=0; i<=n; i++)
		ans = max(ans, cnt1[i] + cnt2[n - i]);
	write(ans); putchar('\n');
	return 0;
}
```

~~感觉比去年的T1好多了qwq~~

update 2021.10.27: 去掉了两行毫无用处的代码~~（sort了个空数组）~~

---

## 作者：I_am_Accepted (赞：40)

考试写挂了 qwq。

作为 T1 好像有点难吧……

### 分析

飞机数量为 $10^5$ 级别，不是线性就是带 $\log$。

先将每一个航班飞机存为一个 `pair<int,int>`，为此航班飞机抵达、离开时刻。

然而最终所求停靠廊桥的飞机数量的最大值可以转化成 $\max(f(x)+g(n-x)) \quad (0\leqslant x\leqslant n)$，其中 $f(x),g(x)$ 分别表示将 $x$ 个廊桥分配给国内航班 / 国际航班，此类航班停靠廊桥的飞机数量的最大值。

下文只讲述 $f(x)$ 的求法，$g(x)$ 的求法类似，不再赘述。

边界值：$f(0)=0$

考虑将廊桥一条一条供应至国内航班，用 `std::set<pair<int,int> >` 维护当前还在远机位的飞机。

当一条廊桥加入后，从 `set` 中删去这些飞机：

* `set` 中最早抵达的飞机 $p$

* `set` 中在 $p$ 离开后最早抵达的飞机 $p'$

* `set` 中在 $p'$ 离开后最早抵达的飞机 $p''$

* $\dots$

（建议使用 `lower_bound`）

最后当前的 $f=m_1-set.size()$

这样就可以在 $O(m\log m)$ 内 A 过此题。

### Code

不加注释应该也看得懂吧……

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define ckmx(a,b) if(a<b){a=b;}
#define fir first
#define sec second
#define mkp make_pair
#define pii pair<int,int>
#define N 100010

int n,at,bt;
set<pii > a,b;
pii tmp;
set<pii >::iterator id;
int aa[N],bb[N];
int ma(){
	int res=0,now=0;
	while(true){
		id=a.lower_bound(mkp(now,now));
		if(id==a.end()) break;
		res++;
		now=id->sec;
		a.erase(id);
	}
	return res;
}
int mb(){
	int res=0,now=0;
	while(true){
		id=b.lower_bound(mkp(now,now));
		if(id==b.end()) break;
		res++;
		now=id->sec;
		b.erase(id);
	}
	return res;
}
signed main(){
	scanf("%d%d%d",&n,&at,&bt);
	For(i,1,at){
		scanf("%d%d",&tmp.fir,&tmp.sec);
		a.insert(tmp);
	}
	For(i,1,bt){
		scanf("%d%d",&tmp.fir,&tmp.sec);
		b.insert(tmp);
	}
	aa[0]=0;
	For(i,1,n)
		aa[i]=aa[i-1]+ma();
	bb[0]=0;
	For(i,1,n)
		bb[i]=bb[i-1]+mb();
	int ans=0;
	For(i,0,n)
		ckmx(ans,aa[i]+bb[n-i]);
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：AuCloud (赞：25)

写一发考场思路

比较显然的一件事就是**每架飞机最终停在哪个廊桥** 与 **分配的廊桥个数**无关，因为题目要求遵循先到先得。

所以可以求出每个飞机将会在哪个廊桥停下，从而得出每个廊桥能停靠的飞机数量，即对答案的贡献。

最终答案则可以表示为

$$Ans=max\{\sum_{x=1}^{i}g(x)+\sum_{x=1}^{n-i}u(n-x)\}$$

其中 $g(x)$ 表示在国内第 $x$ 号廊桥加入后承载的飞机数量， $u(x)$ 同理

然后这个东西可以用一个前缀和做到 $O(N)$ 求

问题是如何求每个飞机在哪个廊桥停靠

根据题意，我们可以知道每个飞机都会选择当前空闲的编号最小的廊桥

这个可以用堆来维护，建立一个堆里面放当前空闲的廊桥的编号，每次有飞机落地就`pop()`有起飞就`push()`

按起飞时间从小到大分别给两种航班排序，建立另一个堆，存放当前仍然停在机场的飞机

每次有新飞机落地时把所有起飞时间小于它落地时间的飞机`pop()`出去，把他们占用的廊桥重新加回第一个堆里

然后分配给新飞机一个最小空闲廊桥，记录这个廊桥编号并且`pop()`出第一个堆，给这个廊桥的贡献++。

上面的过程国内航班做一遍，国际航班再做一遍，求前缀和，就可以按上面的式子求得答案了

时间复杂度 $O(NlogN)$

~~人称`priority_queue`练习题~~

~~希望自己不要写挂分~~

---

## 作者：LinkZelda (赞：20)

- **做法**：

首先，我们思考一下。因为有“先到先得”这个条件，那么如果有 $k+1$ 个廊桥的话，最后一个廊桥一定是在原来只有 $k$ 个廊桥的基础上选的。

考虑归纳，容易知道 $0$ 个廊桥的时候答案为 $0$。那么我们只需要思考已知 $k$ 的答案如何计算 $k+1$ 的答案。

首先，最前面一个未选的区间肯定是要选的。接着由“先到先得”这个原则，我们肯定是选左端点离最后一个已选区间的右端点最近的那个未选区间。那么我们对所有区间的左端点开一棵平衡树，每次选右端点的后继即可。

每个区间最多进出平衡树一次，那么时间复杂度为 $O((m1+m2)\log n)$。

统计出来每边放的廊桥所对应的答案之后，枚举两边分别放多少个廊桥加起来取最大值即可。

- [代码](https://www.luogu.com.cn/paste/zx3f3x8o)

---

## 作者：_鱼非仙_ (赞：19)

## Observation 

 先只考虑一个区（比如国内区）。可以观察一下廊桥数从 $1$ 变为 $2$ 时答案的变化。

注意到，原有的飞机是不会删去的，而新增的飞机的存活时间是**互不相交**的。事实上，从任意 $i$ 转移到 $i + 1$ 这个性质都是成立的。

  反证。不妨设新增了两个相交的飞机 $[l_1, r_1], [l_2, r_2]$
  且 $l_1 < l_2 < r_1$。这意味着 $[l_2, r_1]$
  这段区间之前只存在至多 $i - 1$ 个飞机，那么 $[l_2, r_2]$ 在 $i$
  处就可以增加，而无需等到 $i + 1$。

## Solution

下面是本题的 $\Theta (n \log n)$ 做法。

考虑对 $i \in [1, m_1]$ 求出 $f_{1, i}$，表示国内航班有 $i$
个廊桥时，有 $f_{1, i}$ 架飞机可以停靠在廊桥。$f_{2, i}$
同理。答案则为
$$ \max_{i=0}^n (f_{1, i} + f_{2, n - i}) $$


求出 $f_1$ 只需枚举 $i$ 从 1 到 $m_1$；再用
`std::set<std::pair<int, int> >` 维护一个集合
$S$（初始为所有国内飞机），表示还未选中的飞机。根据上面的观察，$i$
的每次转移需要求出包含 $\min S$
的极大不交子集 $T$，并令 $S \gets S \backslash T$。详细看代码：

```cpp
#include <cstdio>
#include <vector>
#include <set>

const int MAXN = 100000;

int n, m1, m2;
std::set<std::pair<int, int> > a, b;
int f[3][MAXN];

inline void Work(std::set<std::pair<int, int> > &set, int *t) {
  for (int i = 1; i <= n; ++i) {
    std::vector<std::pair<int, int> > del;
    t[i] += t[i - 1];
    for (auto it = set.begin(); it != set.end(); it = set.lower_bound({it->second, 0})) {
      ++t[i];
      del.push_back(*it);
    }
    for (auto it : del)
      set.erase(it);
  }
}

int main() {
  scanf("%d%d%d", &n, &m1, &m2);
  for (int i = 1; i <= m1; ++i) {
    int l, r;
    scanf("%d%d", &l, &r);
    a.insert({l, r});
  }
  for (int i = 1; i <= m2; ++i) {
    int l, r;
    scanf("%d%d", &l, &r);
    b.insert({l, r});
  }
  Work(a, f[1]);
  Work(b, f[2]);
  int ans = 0;
  for (int i = 0; i <= n; ++i)
    ans = std::max(ans, f[1][i] + f[2][n - i]);
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：Mobius127 (赞：15)

[题传](https://www.luogu.com.cn/problem/P7913)

### 约定：


 _因为题目要求“先到先得”，所以事先对所有飞机分组后按左端点从大到小排序。_ 

### 题外话

以此纪念我在 CSP - S 2021 唯一一道过了的题目，以及我 2 年的初中 OI 生涯。

### 回到正题


拿到题目你先想：欸这个答案好像有单调性欸？珂不珂以二分？

不好意思，请你给我表演一下 `check` 怎么写。

思考：`check` 难做的原因是我们二分答案后，仍对两个长廊应该放国内/外飞机一无所知，所以，假设我们知道了用 $L$ 个长廊放国内飞机珂以放下的飞机数量，剩下 $n-L$ 放国外飞机珂以放下的飞机数量，并且枚举这个 $L$，我们就成功**抛开了长廊数量的干扰**，不是吗？

现在我们就是要求两个一模一样的子问题：有 $m_{0/1}$ 架飞机，到达和离开的时间分别为 $arr_i,lea_i$，求当有 $1 - n$ 个长廊时分别能放下的飞机数量 $sum$。

进一步思考：假设我们已经求出了 $1-(L-1)$ 的 $sum$，我们肯定不能晾那不管吧？肯定是有用的，不然我们还得暴力 $O(n)$ 做一遍。

经过~~多次试验~~思考珂以得出：记 $E_i$ 为用 $i$ 个长廊所能停放的飞机的集合，则对于 $\forall j >i$ 有 $E_i \subseteq E_j$，证明也不难：若存在一架飞机 $x \in E_i \wedge x\notin E_j$，则必然存在 $j$ 个不同的 $y \in E_j \wedge y \ne x$ 使得 $arr_x \in (arr_y, lea_y]$，这 $j$ 个 $y$ 必然会在 $i$ 个长廊时会比 $x$ 先选到，从而占了 $x$ 的位置，这与 $x \in E_i$ 矛盾。


也就是说，当我们得到了 $sum_{L-1}$ 和 $sum_{L-1}$， 我们只需要（从左往右）找到 $S-E_{L-1}$（也就是 $E_{L-1}$ 的补集）中被覆盖次数 $< L$ 的飞机加入 $E_{L}$ 中，并且把它对后面飞机产生的影响算上，最后再把 $E_{L-1}$ 丢进 $E_{L}$ 里，就得到了真正的 $E_L$，此时 $sum_L=|E_L|$。

考虑怎么维护集合 $E$，不难发现，我们每次都是找最左边的、覆盖次数 $< v$ 的数的位置，考虑在线段树上二分，记区间最小值 $Mn$，若 $Mn_{lc} < v$ 则递归左儿子，否则递归右儿子，这样做复杂度是 $O(\log n)$。

还有个问题：我们怎么把取出来的元素对后面的影响算上？

这个问题本质上就是询问 $x$ 飞机珂以影响到的飞机范围，因为珂影响的飞机的 $arr$ 都在当前飞机的区间里，所以预先离散化，取个前缀和就珂以得到其影响的区间，加上影响就是线段树上区间 +1，很容易做到。

由于每个数最多只会被取出一次，所以复杂度为 $O(n \log n)$。

细节：取出一个数后记得把值赋成无穷大。

以下是考场代码，无修。

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)) f=(ch=='-'?-1:f), ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0', ch=getchar();
	return x*f; 
}
//已知信息：
//1. 若某一区的机位数量增加，该区可停靠的数量只增不减，
//并且原来可停的机子一定不动，

//考虑用 L 个机位推出 L+1，维护一个还未进入廊桥的飞机集合 S，
//用树状数组维护单位时间内有多少飞机停靠，
//这样的话，每次扫一个新节点，只需看是否大于 L+1 即可
//判断这个新飞机是否能停靠在廊桥，如果能，则从集合中删去
//直接做 n^2 log n 
//考虑到每一次得到新飞机都是一次区间加，
//并且我们要找的是靠左边第一个覆盖次数 < i 的
//考虑在线段树上二分？ 似乎可行
//复杂度 O(nlogn) 
//2. 答案显然具有单调性
const int N=1e5+5;
int n, m1, m2, ans, sum[N][2], p[N*2], cnt, c[N*2];
pair <int, int> pl[N];
namespace SegmentTree{
	#define ls k<<1
	#define rs k<<1|1
	#define mid (l+r>>1)
	const int dfg=1e9; 
	int Mn[N*2], tag[N*2];
	void pushup(int k){Mn[k]=min(Mn[ls], Mn[rs]);}
	void upd(int k, int v){if(Mn[k]==dfg) return;Mn[k]+=v, tag[k]+=v;}
	void pushdown(int k){upd(ls, tag[k]), upd(rs, tag[k]);tag[k]=0;return ;}
	void build(int k, int l, int r){
		Mn[k]=tag[k]=0;if(l==r) return ;
		build(ls, l, mid), build(rs, mid+1, r);
	}
	void modify(int k, int l, int r, int x, int y){
		if(x<=l&&r<=y) return upd(k, 1);pushdown(k);
		if(x<=mid) modify(ls, l, mid, x, y);
		if(mid<y) modify(rs, mid+1, r, x, y);
		return pushup(k);
	}
	void change(int k, int l, int r, int x){
		if(l==r){Mn[k]=dfg;return ;}pushdown(k);
		if(x<=mid) change(ls, l, mid, x);
		else change(rs, mid+1, r, x);
		return pushup(k);
	}
	int query(int k, int l, int r, int V){
		if(Mn[k]>=V) return 0;
		if(l==r) return l&r;pushdown(k);
		if(Mn[ls]<V) return query(ls, l, mid, V);
		return query(rs, mid+1, r, V);
	}
	#undef ls
	#undef rs
	#undef mid
} 
void solve(int f, int m){
	cnt=0;memset(c, 0, sizeof(c));
	for(int i=1; i<=m; i++)
		p[++cnt]=pl[i].first=read(), p[++cnt]=pl[i].second=read();
	sort(p+1, p+cnt+1);
	cnt=unique(p+1, p+cnt+1)-p-1;
	for(int i=1; i<=m; i++)
		pl[i].first=lower_bound(p+1, p+cnt+1, pl[i].first)-p,
		pl[i].second=lower_bound(p+1, p+cnt+1, pl[i].second)-p;
	sort(pl+1, pl+m+1);
	for(int i=1; i<=m; i++)
		c[pl[i].first]++;
	for(int i=1; i<=cnt; i++)
		c[i]+=c[i-1];
	SegmentTree :: build(1, 1, m);
	int nw=0;
	for(int i=1; i<=n; i++){
		for(; ;){
			int fin=SegmentTree :: query(1, 1, m, i);
			if(!fin) break;nw++;int hw=c[pl[fin].second]-c[pl[fin].first];
			if(hw) SegmentTree :: modify(1, 1, m, fin+1, fin+hw);
			SegmentTree :: change(1, 1, m, fin);
		}
		sum[i][f]=nw;
	}
	return ;
}
signed main(){
	freopen("airport.in", "r", stdin);
	freopen("airport.out", "w", stdout);
	n=read(), m1=read(), m2=read();
	solve(0, m1);
	solve(1, m2);
	for(int i=0; i<=n; i++)
		ans=max(ans, sum[i][0]+sum[n-i][1]);
	printf("%d", ans);
	return 0;
} 
```





---

## 作者：Rubidium_Chloride (赞：11)

T3 比 T1 水 ![](//啧.tk/tuu)

## 做法

考虑国际，国内航班分别计算。

然后再考虑一手贪心，假设我们有足够多的廊桥，我们可以让尽量多的飞机停在尽量靠前的地方，这样一个前缀和就可得到当某一区分配了 $p$ 个廊桥的地方了。

考虑如何计算这玩意。

$a_i,b_i\le 10^8$，中间大部分没啥用，离散化一下，变成 $2\times 10^5$ 的数据范围。

用一个 `priority_queue` 维护当前可用的廊桥编号，用一个数组维护当前飞机如果停靠在廊桥上的话是几号。

**以下假设这个优先队列是小根堆。**

考虑每一个时间点，如果飞机飞入，取出队首，让这架飞机停靠。

如果飞机飞出，找到这架飞机停靠的廊桥然后压入。

做两遍这个操作就可以了。

时间复杂度 $\mathcal{n\log n}$。

小丑，好像前缀和的时候要求到 $10^5$。

## 代码

```
#include<bits/stdc++.h>
#define N 100009
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read(){
    ll x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
ll n,m[2],rk[2][2*N],in[2][2*N],out[2][2*N],nw[2][2*N],ans[2][N],ANS;
struct node2{
	ll id,k;
	bool operator<(const node2&x)const{return k<x.k;}
} q[2*N];
struct node{
	ll l,r;
	bool operator<(const node&x)const{return l<x.l;}
} a[2][N];
priority_queue<ll> qu[2];
void solve(ll x){
	for(int i=1;i<=m[x];i++) qu[x].push(-i);
	for(int i=1;i<=2*m[x];i++){
		if(in[x][i]){
			ll u=-qu[x].top();qu[x].pop();
			nw[x][in[x][i]]=u;
			ans[x][u]++;
		}
		else qu[x].push(-nw[x][out[x][i]]),nw[x][out[x][i]]=0;
	}
	for(int i=1;i<=100000;i++) ans[x][i]+=ans[x][i-1];
}
int main(){
	//freopen("airport.in","r",stdin);
	//freopen("airport.out","w",stdout);
	n=read(),m[0]=read(),m[1]=read();
	for(int i=1;i<=m[0];i++) q[2*i-1].k=read(),q[2*i-1].id=2*i-1,q[2*i].k=read(),q[2*i].id=2*i;
	sort(q+1,q+2*m[0]+1);
	for(int i=1;i<=2*m[0];i++) rk[0][q[i].id]=i;
	for(int i=1;i<=m[0];i++) a[0][i].l=rk[0][2*i-1],a[0][i].r=rk[0][2*i],in[0][a[0][i].l]=i,out[0][a[0][i].r]=i;
	for(int i=1;i<=m[1];i++) q[2*i-1].k=read(),q[2*i-1].id=2*i-1,q[2*i].k=read(),q[2*i].id=2*i;
	sort(q+1,q+2*m[1]+1);
	for(int i=1;i<=2*m[1];i++) rk[1][q[i].id]=i;
	for(int i=1;i<=m[1];i++) a[1][i].l=rk[1][2*i-1],a[1][i].r=rk[1][2*i],in[1][a[1][i].l]=i,out[1][a[1][i].r]=i;
	solve(0),solve(1);
	for(int i=0;i<=n;i++) ANS=max(ANS,ans[0][i]+ans[1][n-i]);
	printf("%lld\n",ANS);
	return 0;
}


```

---

## 作者：pengyule (赞：10)

这是一篇代码比较长的题解，但是思路很简单。

### 题意
> 给定 $n$ 和两条数轴，需要将给定的 $m_1$ 条线段选一些放在数轴一上，将给定的 $m_2$ 条线段选一些放在数轴二上，要求是第一条数轴上任意一个点至多被覆盖 $k$ 次，第二条数轴上任意一个点至多被覆盖 $(n-k)$ 次，你需要选定一个 $0\le k\le n$ 使放置的线段总数最大，只需输出这个最大值。
> 
> $1\le n,m_1+m_2\le 10^5$，$2(m_1+m_2)$ 个线段的端点互不相同。

### 题解
由于有“先到先得”的原则，在 $k=k_0$ 时选的线段在 $k=k_0+1$ 时也一定被选。实在不行，通过处理大样例找规律打印出如【样例解释#1】那样的表你也会发现它是会形成“钟乳石”或“石笋”状，得到同样的结论。

因此考虑 DP。设 $f1_i$ 表示数轴一上限制至多为 $i$ 时的覆盖线段条数，那么 $f1_i=f1_{i-1}+cnt1_i$，其中 $cnt1_i$ 是限制从 $i-1$ 到 $i$ 时新增的线段条数。主要矛盾转为算 $cnt1_i$。考虑手动模拟一下选的这个全过程。首先 $i=1$ 时第一条线段一定会选，然后就要选一个左端点 $>r_1$（$l_j,r_j$ 表示线段 $j$ 的左右端点，下同）的 $j$，跳到那里去，然后再选一个 $l_k>r_j$，依此类推，一直到我们无法可跳为止。接着我们开始第二轮，首先找到一个没有被选的作为起始位置，然后就像第一轮那样做，只不过选过的线段不能再选了。我们考虑可以用一个线段树维护区间的左端点最大值，每次跳的时候使用二分的方法找到应该跳往的位置，即如果 $\max_l[p,mid]>r_p$（$p$ 为现在的位置）就把右端点左调，否则左端点右调，最后右端点就是要跳到的位置。每一次选定一条线段就将线段树中它的值置为 $0$，就可以实现正确的跳跃。单次跳跃复杂度 $O(\log^2n)$。

由于每一个点至多选一次，因此总复杂度 $O(n\log^2n)$，[可以通过](https://www.luogu.com.cn/record/60744865)。

上面讲解的是 $cnt_1$ 的求法，显然 $cnt_2,f_2$ 的求法是完全一致的。我们最终的答案就是 $\max\limits_{i=0}^nf1_i+f2_{n-i}$。

```cpp
//代码易懂无注释
#include <bits/stdc++.h>
//#define int long long 
//typedef long long ll;
#define pii pair<int,int>
using namespace std;
inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x*f;
}
const int N=1e5+5;
int n,ma,mb,ans,T;
pii a[N],b[N];
int t[N<<2],cnta[N],cntb[N],f1[N],f2[N];
bool bk[N];
void pushup(int k){
	t[k]=max(t[k<<1],t[k<<1|1]);
}
void build1(int l,int r,int k){
	if(l==r){
		t[k]=a[l].first;
		return;
	}int mid=l+r>>1;
	build1(l,mid,k<<1),build1(mid+1,r,k<<1|1);
	pushup(k);
}
void build2(int l,int r,int k){
	if(l==r){
		t[k]=b[l].first;
		return;
	}int mid=l+r>>1;
	build2(l,mid,k<<1),build2(mid+1,r,k<<1|1);
	pushup(k);
}
void chg(int p,int v,int l,int r,int k){
	if(l==r){
		t[k]=v;return;
	}int mid=l+r>>1;
	if(p<=mid)chg(p,v,l,mid,k<<1);
	else chg(p,v,mid+1,r,k<<1|1);
	pushup(k);
}
int ask(int L,int R,int l,int r,int k){
	if(L<=l&&r<=R)return t[k];
	int mid=l+r>>1,ans=0;
	if(L<=mid)ans=max(ans,ask(L,R,l,mid,k<<1));
	if(R>mid) ans=max(ans,ask(L,R,mid+1,r,k<<1|1));
	return ans;
}
int main(){
	//freopen("airport.in","r",stdin);
	//freopen("airport.out","w",stdout);
	n=read(),ma=read(),mb=read();
	for(int i=1;i<=ma;i++)a[i].first=read(),a[i].second=read();
	for(int i=1;i<=mb;i++)b[i].first=read(),b[i].second=read();
	sort(a+1,a+ma+1),sort(b+1,b+mb+1);
	build1(1,ma,1);//for(int k=1;k<=ma;k++)printf("(%d)",ask(1,k,1,ma,1));
	for(int i=1;i<=ma;i++)if(!bk[i]){
		T++;
		for(int j=i;j<=ma;){//cout<<j<<','<<a[j].second<<' ';
			cnta[T]++;bk[j]=1;
			chg(j,0,1,ma,1);
			int L=j,R=ma+1,mid;
			
			while(L<R-1){
				mid=L+R>>1;
				if(ask(j,mid,1,ma,1)>=a[j].second)R=mid;
				else L=mid;
			}
			if(R==ma+1)break;
			j=R;
		}//puts("");
	}T=0;build2(1,mb,1);memset(bk,0,sizeof(bk));
	for(int i=1;i<=mb;i++)if(!bk[i]){
		T++;
		for(int j=i;j<=mb;){
			cntb[T]++;bk[j]=1;
			chg(j,0,1,mb,1);
			int L=j,R=mb+1,mid;
			while(L<R-1){
				mid=L+R>>1;
				if(ask(j,mid,1,mb,1)>=b[j].second)R=mid;
				else L=mid;
			}
			if(R==mb+1)break;
			j=R;
		}
	}
	for(int i=1;i<=n;i++)f1[i]=f1[i-1]+cnta[i];
	for(int i=1;i<=n;i++)f2[i]=f2[i-1]+cntb[i];
	for(int i=0;i<=n;i++)ans=max(ans,f1[i]+f2[n-i]);
	cout<<ans;
	return 0;
}
```

---


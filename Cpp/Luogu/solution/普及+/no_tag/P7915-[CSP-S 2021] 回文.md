# [CSP-S 2021] 回文

## 题目描述

给定正整数 $n$ 和整数序列 $a_1, a_2, \ldots, a_{2 n}$，在这 $2 n$ 个数中，$1, 2, \ldots, n$ 分别各出现恰好 $2$ 次。现在进行 $2 n$ 次操作，目标是创建一个长度同样为 $2 n$ 的序列 $b_1, b_2, \ldots, b_{2 n}$，初始时 $b$ 为空序列，每次可以进行以下两种操作之一：

1. 将序列 $a$ 的开头元素加到 $b$ 的末尾，并从 $a$ 中移除。
2. 将序列 $a$ 的末尾元素加到 $b$ 的末尾，并从 $a$ 中移除。

我们的目的是让 $b$ 成为一个**回文数列**，即令其满足对所有 $1 \le i \le n$，有 $b_i = b_{2 n + 1 - i}$。请你判断该目的是否能达成，如果可以，请输出字典序最小的操作方案，具体在【**输出格式**】中说明。

## 说明/提示

**【样例解释 #1】**

在第一组数据中，生成的的 $b$ 数列是 $[4, 5, 3, 1, 2, 2, 1, 3, 5, 4]$，可以看出这是一个回文数列。

另一种可能的操作方案是 `LRRLLRRRRR`，但比答案方案的字典序要大。

**【数据范围】**

令 $\sum n$ 表示所有 $T$ 组测试数据中 $n$ 的和。

对所有测试点保证 $1 \le T \le 100$，$1 \le n, \sum n \le 5 \times {10}^5$。

| 测试点编号 | $T \le$ | $n \le$ | $\sum n \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 7$ | $10$ | $10$ | $50$ | 无 |
| $8 \sim 10$ | $100$ | $20$ | $1000$ | 无 |
| $11 \sim 12$ | $100$ | $100$ | $1000$ | 无 |
| $13 \sim 15$ | $100$ | $1000$ | $25000$ | 无 |
| $16 \sim 17$ | $1$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 无 |
| $18 \sim 20$ | $100$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 有 |
| $21 \sim 25$ | $100$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 无 |

特殊性质：如果我们每次删除 $a$ 中两个相邻且相等的数，存在一种方式将序列删空（例如 $a = [1, 2, 2, 1]$）。

**【hack 数据提供】**  
@[潜在了H2O下面](/user/264490)。

## 样例 #1

### 输入

```
2
5
4 1 2 4 5 3 1 2 3 5
3
3 2 1 2 1 3
```

### 输出

```
LRRLLRRRRL
-1
```

## 样例 #2

### 输入

```
见附件中的 palin/palin2.in```

### 输出

```
见附件中的 palin/palin2.ans```

# 题解

## 作者：I_am_Accepted (赞：283)

~~比 T2 简单的 T3 这辈子不多了……~~

感觉我的做法挺简单的。

### 分析

由于每一步只能从 $\{a\}$ 的两端之一取一个数字放在 $\{b\}$ 的末尾，所以**对第一步的操作分类**。

**这里只考虑第一步取 `'L'` 的情况**，第一步取 `'R'` 的情况就不再赘述（除字典序外思路相同）。

找到有且仅有的那个 $x$ 满足 $1<x\leqslant 2n \ and \ a_1=a_x$。

由于 $b_1$ 对应 $a_1$，则必然 $b_{2n}$ 对应 $a_x$，即 $\{a\}$ 中 $a_x$ 最后一个被取到。

于是题目转化成：

$c$ 是一个元素**从顶至底**为 $a_2\to a_{x-1}$ 的栈。

$d$ 是一个元素**从底至顶**为 $a_{x+1}\to a_{2n}$ 的栈。

`'L'`表示取出 $c$ 的栈顶元素，`'R'`表示取出 $d$ 的栈顶元素，求**使得两个栈的取出序列回文**的**字典序最小**的操作序列。

突然变简单了……

把 $c$ 和 $d$ 都看作双端队列（即栈底可以取出元素）。

重复作这两个步骤直至 $c,d$ 皆为空：

1. 找到一个既存在于 $c,d$ 的（一个或两个）栈顶，又存在于 $c,d$ 的（一个或两个）栈底的元素，若有两个这样的元素，优先选择存在于 $c$ 栈顶的那个（字典序最小）。若找不到，输出 $-1$ 表示无解。

2. 栈顶和栈底各删掉一个这个元素，更新操作序列。

晕了？举个例子（样例 palin1.in 中第一组）：

![](https://cdn.luogu.com.cn/upload/image_hosting/iwut78l6.png)

$O(n)$ 解决问题。

### Code

冗长的考场代码 qwq。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define Rof(i,j,k) for(register int i=j;i>=k;i--)
#define N 1000010
int n;
int v[N];
char ans[N],cur[N];
struct sta{
	int s[N],l,r;
	int L(){return s[l];}
	int R(){return s[r-1];}
	void push(int x){s[r++]=x;}
	void pL(){l++;}
	void pR(){r--;}
	void clear(){l=r=0;}
	bool empty(){return r==l;}
	int size(){return r-l;}
}a,b;
int see(int l,int r,int val){
	For(i,l,r)
		if(v[i]==val)
			return i;
	return -1;
}
void check(){
	int now=2;
	while(1){
		if(a.empty() && b.empty()){
			break;
		}else if(b.empty()){
			if(a.L()!=a.R()){
				cur[1]='Z';
				return ;
			}
			cur[now]=cur[2*n-now+1]='L';
			a.pL();
			a.pR();
		}else if(a.empty()){
			if(b.L()!=b.R()){
				cur[1]='Z';
				return ;
			}
			cur[now]=cur[2*n-now+1]='R';
			b.pL();
			b.pR();
		}else{
			if(a.R()==a.L() && a.size()>1){
				cur[now]=cur[2*n-now+1]='L';
				a.pL();
				a.pR();
			}else if(a.R()==b.L()){
				cur[now]='L';
				cur[2*n-now+1]='R';
				b.pL();
				a.pR();
			}else if(b.R()==a.L()){
				cur[now]='R';
				cur[2*n-now+1]='L';
				a.pL();
				b.pR();
			}else if(b.R()==b.L() && b.size()>1){
				cur[now]='R';
				cur[2*n-now+1]='R';
				b.pL();
				b.pR();
			}else{
				cur[1]='Z';
				return ;
			}
		}
		now++;
	}
}
bool pan(){
	int id=1;
	while(id<=2*n && cur[id]==ans[id]) id++;
	return id<=2*n && cur[id]<ans[id];
}
signed main(){
	int T;
	scanf("%d",&T);
	int pos;
	while(T--){
		ans[1]='Y';
		scanf("%d",&n);
		For(i,1,2*n) scanf("%d",v+i);
		
		a.clear();
		b.clear();
		pos=see(2,2*n,v[1]);
		Rof(i,pos-1,2) a.push(v[i]);
		For(i,pos+1,2*n) b.push(v[i]);
		cur[1]='L';
		cur[2*n]='L';
		check();
		if(pan()){
			For(i,1,2*n) ans[i]=cur[i];
		}
		
		a.clear();
		b.clear();
		pos=see(1,2*n-1,v[2*n]);
		Rof(i,pos-1,1) a.push(v[i]);
		For(i,pos+1,2*n-1) b.push(v[i]);
		cur[1]='R';
		cur[2*n]='L';
		check();
		if(pan()){
			For(i,1,2*n) ans[i]=cur[i];
		}
		
		if(ans[1]=='Y'){
			printf("-1\n");
		}else{
			For(i,1,2*n) printf("%c",ans[i]);
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：tommymio (赞：132)

是名副其实的签到题，可是这只猫猫考试的时候居然没有签到。

考虑确定了 $s_1$ 以后的情况，不妨令 $s_1=\texttt{L}$。

那么，找出与 $a_1$ 的唯一一个位置，记作 $p$。则序列被划分为两段，$a[2\cdots p-1]$ 和 $a[p+1\cdots2n]$。可以将这两段分别看成两个栈：栈 $T_1$：$a[2\cdots p-1]$ 的栈顶为 $2$，栈底为 $p-1$；栈 $T_2$：$a[p+1\cdots 2n]$ 的栈顶为 $2n$，栈底为 $p+1$。

则问题转化为每次可以取走这两个栈之一的栈顶，令最终得到的串是回文串。

自然，只有存在某个数 $x$，既在栈顶，又在栈底才能取走。否则无解。可以分类讨论一下：如果数 $x$ 在栈 $T_i$ 的栈顶和栈 $T_i$ 的栈底，可以先取走 $T_i$ 栈顶，当另一个栈取空后，再取空 $T_i$，这样的方案显然是合法的。如果数 $x$ 在栈 $T_i$ 栈顶和栈 $T_{3-i}$ 的栈底，可以先取走 $T_i$ 栈顶，当 $T_i$ 被取空后，再取空 $T_{3-i}$，显然也是合法的。

这样就可以从两个栈中直接消除掉数 $x$ 的影响，归纳构造方案。由于要求字典序最小，所以可以每次优先取 $T_1$ 的栈顶。如果过程中找不到可以取的栈顶，则无解。

代码很短。

```cpp
#include<cstdio>
int n;
char res[1000005];
int a[1000005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f; 
}
inline bool work(int l1,int r1,int l2,int r2) {
	for(register int i=1;i<n;++i) {
		if(l1<=r1&&((l2<=r2&&a[l1]==a[l2])||(l1<r1&&a[l1]==a[r1]))) {
			if(l1<r1&&a[l1]==a[r1]) {
				++l1; --r1;
				res[i]='L'; res[2*(n-1)-i+1]='L';
			}
			else {
				++l1; ++l2;
				res[i]='L'; res[2*(n-1)-i+1]='R';	
			}
		}
		else if(l2<=r2&&((l1<=r1&&a[r2]==a[r1])||(l2<r2&&a[l2]==a[r2]))) {
			if(l2<r2&&a[l2]==a[r2]) {
				++l2; --r2;
				res[i]='R'; res[2*(n-1)-i+1]='R';
			}
			else {
				--r2; --r1;
				res[i]='R'; res[2*(n-1)-i+1]='L';
			}
		}
		else {return 0;}
	}
	return 1;
}
int main() {
	int T=read();
	while(T--) {
		n=read();int p1=-1,p2=-1; 
		for(register int i=1;i<=2*n;++i) a[i]=read();
		for(register int i=1;i<=2*n+1;++i) res[i]=0;
		for(register int i=2;i<=2*n;++i) {if(a[1]==a[i]) {p1=i; break;}}
		for(register int i=1;i<2*n;++i) {if(a[2*n]==a[i]) {p2=i; break;}}
		if(work(2,p1-1,p1+1,2*n)) {printf("L%sL\n",res+1);}
		else if(work(1,p2-1,p2+1,2*n-1)) {printf("R%sL\n",res+1);}
		else {printf("-1\n");}
	}
	return 0;
}

```

	

---

## 作者：code_hunter (赞：93)

## 十四行诗
- 根据题意，我们第一次要么取出 $a_1$ , 要么取出 $a_{2n}$.

- 由对称性，我们只需研究取出 $a_1$ 时的情况.

- 根据题意，$\exists k \in (1,2n]$ $s.t.$ $a_1=a_k$

- 由回文性，$a_k$ 是我们最后取出的数。

- 在此之前，我们只能从左取出 $a_{2\cdots k-1}$ 中的数，也只能从右取出 $a_{k+1\cdots 2n}$ 中的数.

- 现在问题转化为如何顺次往 $a_{2\cdots k-1}$ 中插入   $a_{2n \cdots k + 1}$ 中的数，形成回文串.

- 初始时令数列 $u = a_{2\cdots k-1}$ , $v = a_{2n \cdots k + 1}$

- 这里我们只讨论$u$ , $v$ 大小均不小于二且 $u_1\ne v_1$ 的非平凡情况，其他平凡情况留作习题.

- 若 $\left\{u_1,v_1\right\}=\left\{u_{-1},v_{-1}\right\}$ , 那么如果先取 $v_1$ 可行，那么我们可以先取 $u_1$ 再取 $v_1$ 从而也可行，也更优，出于贪心，应先取 $u_1$.

- 另外，若 $u_1\in\left\{u_{-1},v_{-1}\right\}$,则先取 $u_1$.

- 否则，若 $v_1\in\left\{u_{-1},v_{-1}\right\}$,则先取 $v_1$.

- 否则，判为无解.

- 然后问题化小，继续处理两数列，直至平凡情况，可以求解.

- 时间复杂度严格线性.





---

## 作者：Mobius127 (赞：63)

[题传](https://www.luogu.com.cn/problem/P7915)

很有意思的一道题，不过我考场上一直刚 T2 导致压根没时间看（）。

这题拿到看起来很离谱的样子，先考虑怎么暴力吧。

最朴素的暴力显然就是 $2^n \times n$ 的暴力搜索判断，无法通过所有测试数据。

思考：我们每次都是搜完所有方案再去判断是否正确，这十分耗时，能否用一种方法，边搜边判呢？

继续往下思考：我们怎么判断这是一个解，肯定是拿个指针从两边向中间扫，如果有不匹配的就返回非解，那么搜索的时候能不能也像这样做呢？

我们珂以枚举 $b$ 中开头的值（显然它只能是 $a$ 的开头和末位），然后在 $a$ 中找到与之对应的值 （即 $b$ 的末位），这就相当于一个区间往里面缩，一个区间往外拓展，这样搜索的复杂度是 $O(2^{n/2})$。

考虑对其再来一个贪心，显然优先级为 `LL` --> `LR` --> `RL` --> `RR`，只要有一个可行我们就只搜这一条路，那么复杂度为 $O(n)$ （每次只移动一次，每移动一次数组长度 -2 ），但是这么做正确性？比较显然，无论怎样最终的指针还是会匹配到这个位置，所以前面无论怎样改，不行就是不行。

然后你就发现这其实跟 T1 一样是个猜了结论就会做的题。。。

### Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mo=1e9+7;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)) f=(ch=='-'?-1:f), ch=getchar();
	while(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0', ch=getchar();
	return x*f; 
}
const int N=5e5+5;
int n, L[N], R[N], a[2*N], b[2*N];
char ans[2*N];
bool doit(int lst, int Li, int Ri){
	if(Li==2) ans[1]='L';
	else ans[1]='R';
	int l=lst, r=lst, st=2, ed=2*n-1;
	for(int i=1; i<n; i++){
		if(R[a[Li]]==l-1) l--, Li++, ans[st++]='L', ans[ed--]='L';
		else if(R[a[Li]]==r+1) r++, Li++, ans[st++]='L', ans[ed--]='R';
		else if(L[a[Ri]]==l-1) l--, Ri--, ans[st++]='R', ans[ed--]='L';
		else if(L[a[Ri]]==r+1) r++, Ri--, ans[st++]='R', ans[ed--]='R';
		else return 0;
	}
	ans[2*n]='L';printf("%s\n", ans+1);return 1;
}
void solve(){
	memset(L, 0, sizeof(L));
	memset(R, 0, sizeof(R));
	memset(b, 0, sizeof(0));
	memset(ans, 0, sizeof(ans));
	n=read();for(int i=1; i<=2*n; i++)
	a[i]=read(), L[a[i]]?R[a[i]]=i:L[a[i]]=i;
	if(doit(R[a[1]], 2, 2*n)) return ;
	if(doit(L[a[2*n]], 1, 2*n-1)) return ;
	puts("-1");return ;
}
signed main(){
	int T=read();while(T--) solve();
	return 0;
}
```




---

## 作者：Danno0v0 (赞：60)

感谢机房大佬@[嘉年华](https://www.luogu.com.cn/user/85994)让这个 $O(n^2)$ 的暴力优化到了近似于 $O(n)$ (可恶为什么我没在考试的时候优化出来)

然后这个题解思路清奇（就是暴力加上了一堆优化然后跑过了），相较于 std 可能会有所不同。

-----------------------------

首先一看，回文，好耶， Hash —— 然而并不是。

众所周知，了解一道题的最好方法就是手推样例（瞎说的），所以我们来手推一下。

样例一的第一组数据的 $a$ 和 $b$:

![](https://cdn.luogu.com.cn/upload/image_hosting/swljkm9f.png)

然后手模一下怎么生成 $b$ 的：

![](https://cdn.luogu.com.cn/upload/image_hosting/btpv7o83.png)

~~嗯，连得密密麻麻的不想看，做 T4 去了。~~

这当然是不可以的，但是这样看确实看不出来什么东西。

想一下题上有什么提示……

_$b$ 是一个回文数列。_

既然 $b$ 是一个好观察的回文数列那就从 $b$  入手吧。

$b$ 前后相等，那就把前后分开看看？

![](https://cdn.luogu.com.cn/upload/image_hosting/r25nor7n.png)

好像也没有什么。

不对，看一看后半段 $b$  。

这是由连续的一段 $a$ 组成的。

想一想，不论什么 $b$ 的后半段都是由 $a$ 中一段连续的，长度为 $n$ 的数列组成的。

就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/6m5bcflk.png)

（长度不准确请忽视）

有了这个，我们就可以开始我们优雅の暴力了。

1.暴力枚举每一个后半段区间位置。

2.判断是否合法。

3.输出。

然后这个时候有人就会跑上来说，你这个暴力是 $O(n^3)$ 的啊不是 $O(n^2)$ 的啊。

( $n^3$ ： 枚举 $n$ 个区间、记录每个区间 $n$ 个数，判断是否合法要 $n$ 次判断)

所以我们需要对暴力进行优化。

### 优化一

首先我们想，一个后半段区间假若有机会成为解，那么必要条件是……

当然是这个区间里包含了 $1,2,...,n$ 啦（不然你怎么回文）。

那么我们在枚举一个后半段区间时可以顺便来看看它是否包含了 $1,2,...,n$ ，没有则直接跳到下一个区间，否则来判断是否合法以及假如合法则方案是否是字典序最小的。

当然这个优化对于随机数据收益巨大，能大幅消减判断的 $n$ 以至于能看成 $O(n^2)$ ，因为减少了很多不必要的判断；但是对于构造的数据，比如说这个：

$1,2,...,10000,1,2,...,10000$

那这个优化就什么用都没有，直接退化 $O(n^3)$ 。

### 优化二

所以再来一个显而易见的优化：每个区间都是在上一个区间基础上挪了一个罢了，所以可以直接在上一个区间的基础上进行改动，这样就把记录每个区间的数的 $n$ 就消掉了，这样就是一个完全的 $O(n^2)$ 暴力了。加上前面的优化，对于随机数据能直接跑到近似于 $O(n)$ 乘上一个大常数。

$O(n^2)$ code:~~（民间数据能 AC ，不得不说真的有点水）~~ 现在只有 $80$ 分了悲伤

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,tot,now,check,qrs;
int num[1000001],cnt;
int in[1000001];
char ans[1000001],maybeans[1000001];
stack<int>castle_3;
stack<int>lancet_2;
int main()
{
//	freopen("palin.in","r",stdin);
//	freopen("palin.out","w",stdout);
	cin>>t;
	while(t--)
	{
		memset(ans,0,sizeof(ans));
		memset(in,0,sizeof(in));
		cnt=0;
		qrs=0;
		cin>>n;
		for(int i=1;i<=2*n;i++)
		{
			cin>>num[i];
		}
		int l=1,r=n;
		for(int i=l;i<=r;i++)
		{
			in[num[i]]++;
			if(in[num[i]]==1)
			{
				cnt++;
			}
		}
		while(r<=2*n)
		{
			if(cnt==n)
			{
				memset(maybeans,0,sizeof(maybeans));
				check=0;
				for(int i=1;i<l;i++)
				{
					castle_3.push(num[i]);
				}
				for(int j=2*n;j>r;j--)
				{
					lancet_2.push(num[j]);
				}
				int ll=l,rr=r;
				int a,b;
				int now=0;
				while(ll<=rr)
				{
					a=-1;
					b=-1;
					if(castle_3.size()) a=castle_3.top();
					if(lancet_2.size()) b=lancet_2.top();
					if(b==num[ll])
					{
						maybeans[n-now]='R';
						maybeans[n+1+now]='L';
						lancet_2.pop();
						now++;
						ll++;
					}
					else if(b==num[rr])
					{
						maybeans[n-now]='R';
						maybeans[n+1+now]='R';
						lancet_2.pop();
						now++;
						rr--;
					}
					else if(a==num[ll])
					{
						maybeans[n-now]='L';
						maybeans[n+1+now]='L';
						castle_3.pop();
						now++;
						ll++;
					}
					else if(a==num[rr])
					{
						maybeans[n-now]='L';
						maybeans[n+1+now]='R';
						castle_3.pop();
						now++;
						rr--;
					}
					else
					{
						check=1;
						break;
					}
				}
				if(!check)
				{
					if(!qrs)
					{
						for(int i=1;i<=n*2;i++)
						{
							ans[i]=maybeans[i];
						}
						qrs=1;
					}
					else
					{
						int i=1;
						int checks=0;
						for(;i<=n*2;i++)
						{
							if(ans[i]!=maybeans[i])
							{
								checks=1;
								break;
							}
						}
						if(maybeans[i]=='L'&&checks)
						{
							for(int j=1;j<=n*2;j++)
							{
								ans[j]=maybeans[j];
							}
						}
					}
				}
				while(!lancet_2.empty()) lancet_2.pop();
				while(!castle_3.empty()) castle_3.pop();
			}
			in[num[l]]--;
			if(!in[num[l]]) cnt--;
			l++;
			r++;
			in[num[r]]++;
			if(in[num[r]]==1) cnt++; 
		}
		if(!qrs)
		{
			cout<<-1<<endl;
		}
		else
		{
			for(int i=1;i<=n*2;i++)
			{
				cout<<ans[i];
			}
			cout<<endl;
		}
	}
}
```

_判断可行性解释：用两个栈记录左边前半部分与右边前半部分，然后和后半部分尝试匹配。每匹配成功就把它们加入maybeans方案中。对于这个“匹配”，请好好读读，因为后半段优化是基于这个“匹配”的。_

_代码解释： in 数组是用来记录区间内所有数的个数， cnt 是用来记录区间内有多少个不同的数；对于  in 和 cnt 的变化规律为什么是这样，手推一遍就很容易明白。然后是让每个区间生成最优解：因为我们需要让操作 $R$ 尽可能在后，那么我们就先让 前半部分的右端先进行匹配，这样对于每个枚举的后半段区间，生成的答案就是局部最优解_

然后机房大佬 FJN 因为没有打出暴力 T3 感到非常悲伤，然后听说我打出了一个随机化数据能跑 $O(n)$ ,构造能跑 $O(n^2)$ 的暴力于是来找我看看代码。

看着看着然后他就来了一句：你这个可以再优化成 $O(n)$ 的。

对，这就是最后一个优化。

### 优化三

概括一下就是：倒序枚举后半段区间，当找到第一个解时就一定是最优解。

为甚么呢？

首先我们想一个基础事实：假如 $a$ 中有 $2$ 个或以上的符合要求的后半段区间，那么它们一定是有重合部分的。

(例外： $1,2,3,1,2,3$ 中前一个 $1,2,3$ 和后一个  $1,2,3$ 不重合，但是看一眼就知道选后面一个答案更优。)

就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/n1ie3k83.png)

为什么会重合？因为两段区间都包含 $1$ 至 $n$ 中所有数，而 $1$ 至 $n$ 每个又只有两个，所以一定会重合。

上图的红绿线段就是两个符合要求的后半段区间，那么显而易见的可以知道，没有重叠的部分是相同的。（你问为什么？ $A-B=A-B$ ）

那么，在进行回文配对时，红色没有重叠部分一定是跟绿色没有重叠部分进行配对。毕竟含有相同的数。

那么，假若我们选择红色作为后半段区间，那么绿色的未重叠部分则是用 $R$ 操作弹出。（假如可行）

假若我们选择绿色作为后半段区间，那么红色的未重叠部分则是用 $L$ 操作弹出。（假如可行）

回看匹配过程，不管我们选择红色还是绿色，我们一定是先将不属于红色或绿色的是跟红绿重合部分匹配（你不把它们匹配完怎么匹配中间的啊），那么它们的在方案中位置及方案是固定的，那么就剩红色和绿色不重叠部分了。

假如我们选择是红色且红色可行，那么在这里我们会全部用 $R$ 进行剩余匹配。

假如是绿色且绿色可行，那么在这里我们会全部用 $L$
进行剩余匹配。

显而易见的，绿色更优。

所以两段后半部分区间都可行时，那么选择后面那段作为后半区间更优。

于是乎，倒着枚举区间，遇到第一个可行的区间就输出答案，正确性证明完毕，于是就开心滴砍掉了大部分判断这个  $n$ 。结合前面的优化，一个近似于 $O(n)$ 就这么搞出来啦~

当然，如果真的要专门构造数据来卡当然是可以退化到 $O(n^2)$ 的（悲）

$O(n)$ code：（再来两个优化：去掉了栈/记录了每个可行区间位置不再挨个枚举区间了）
```cpp
#include<bits/stdc++.h>
#define ooffof 1000001
using namespace std;
int t,n,tot,now,check,qrs;
int num[ooffof],cnt;
int in[ooffof];
char ans[ooffof],maybeans[ooffof];
int l[ooffof],r[ooffof],klk=0;;
int main()
{
//	freopen("palin.in","r",stdin);
//	freopen("palin.out","w",stdout);
	cin>>t;
	while(t--)
	{
		memset(ans,0,sizeof(ans));
		memset(in,0,sizeof(in));
		cnt=0;
		qrs=0;
		klk=0;
		cin>>n;
		for(int i=1;i<=2*n;i++)
		{
			cin>>num[i];
			in[num[i]]++;
			if(in[num[i]]==1)
			{
				cnt++;
			}
			if(i>n)
			{
				in[num[i-n]]--;
				if(in[num[i-n]]==0)
				{
					cnt--;
				}
			}
			if(cnt==n)
			{
				l[++klk]=i-n+1;
				r[klk]=i;
			}
		}
		for(int q=klk;q>=1;q--)
		{
			memset(maybeans,0,sizeof(maybeans));
			check=0;
			int ll=l[q],rr=r[q],sl=l[q]-1,rl=r[q]+1;
			int a,b;
			int now=0;
			while(ll<=rr)
			{	
				a=-1;
				b=-1;
				if(sl>=1) a=num[sl];
				if(rl<=2*n) b=num[rl];	
				if(b==num[ll])
				{
					maybeans[n-now]='R';
					maybeans[n+1+now]='L';
					rl++;
					now++;
					ll++;
				}
				else if(b==num[rr])
				{
					maybeans[n-now]='R';
					maybeans[n+1+now]='R';
					rl++;
					now++;
					rr--;
				}
				else if(a==num[ll])
				{
					maybeans[n-now]='L';
					maybeans[n+1+now]='L';
					sl--;
					now++;
					ll++;
				}
				else if(a==num[rr])
				{
					maybeans[n-now]='L';
					maybeans[n+1+now]='R';
					sl--;
					now++;
					rr--;
				}
				else
				{
					check=1;
					break;
				}
			}
			if(!check)
			{
				for(int i=1;i<=n*2;i++)
				{
					cout<<maybeans[i];
					qrs=1;
				}
				cout<<endl;
			}
			if(qrs)
			{
				break;
			}
		}
		if(!qrs)
		{
			cout<<-1<<endl;
		}
	}
}
```

~~好长的TJ~~




---

## 作者：言琢დ (赞：44)

结论：

> 有解的序列中间必须存在一个排列 $1\sim n$。

证明：最后取出来的回文串形如

$$1,2,3,\cdots,n,n,\dots,3,2,1$$

所以后面取走的 $n$ 个元素形成一个排列。

所以上面结论显然正确。

考虑一种暴力的搜索，设计四个指针，$x,y,i,j$ 分别表示：

- 外面的排列选择左右端点 $x,y$
- 里面的排列选择左右端点 $i,j$

这个做法可以通过 $100\%$ 的民间数据，而官方数据对这个做法进行了一定的 Hack。

考虑 Hack 原理，构造一种“看上去”可行的无解情况，让搜索树跑满。

那么我们这里就需要对它进行一些剪枝，也就是优化成正解。

结论：

> 如果左边可以取出，一直向右转移，直到不能取出时被迫选择右边。

证明：

假设我们最后外面向里面移动了 $k$，那么里面向外面也移动了 $k$ 步。

这里我们考虑假如其中第 $k'(<k)$ 步不走 L，走 R，这样也能到达这个状态。

而这个状态的要求是字典序最小，所以我们只走这一边也一定最优。

有人说这是贪心，私以为是对结论的再次加工。

时间复杂度 $O(n)$。

---

## 作者：OMG_wc (赞：25)

~~感觉CF某场比赛有类似的题~~，这题放在T3的位置肯定是不合适的，放T1的话应该就会更大胆地去想。

首先第一步有两种取法`L` 和`R` ，第一个数其实决定了最后一个数（因为是回文），并且最后一次的操作一定是`L`。

下面假设第一步为`L`，为`R`的情况同理，并且只会在第一步`L`行不通的情况下才会尝试，不再赘述。

为了方便起见，我预处理了每个数和它相等的那个数的位置。假设和 $a_1$ 匹配的位置是 $a_t$，那么我们构造两个`deque` $q_1$ 和 $q_2$，分别把 $a_2\sim a_{t-1}$ 和 $a_{n}\sim a_{t+1}$ 从头到尾装进队列的。这样，我们每次选`L` 相当于取 $q_1$ 的头部，选`R`相当于取 $q_2$ 的头部。

设 $x_1,y_1$ 分别为 $q_1$ 的头和尾，$x_2,y_2$ 分别为 $q_2$ 的头和尾。

根据字典序最小的原则，我们尽量把 $x_1$ 取出，但要满足回文，必须在 $y_1$ 和 $y_2$ 中有一个数和其匹配（匹配是唯一的，不必担心会同时匹配），在 $x_1$ 不行的时候再尝试 $x_2$ ，若都不行就说明无解。注意都行的情况，先取了 $x_1$ 不会因为顺序造成无解。

用了 $y_1$ 后意味着倒着有个`L`操作，用了 $y_2$ 后意味着倒着有个`R`操作，也记录下来最后反转后加到答案里。

这样，每一轮其实就是从 $q_1$ 和 $q_2$ 里一共`pop`出两个元素，而且整个取出过程是唯一的路径。

时间复杂度 $O(n)$，代码如下：

```c++
int a[N], b[N], c[N], n;
bool solve(char cc) {
    deque<int> q1, q2;
    string ans, s;
    ans.push_back(cc);
    s.push_back('L');
    if (cc == 'L') {
        for (int i = 2; i < c[1]; i++) q1.push_back(i);
        for (int i = n; i > c[1]; i--) q2.push_back(i);
    } else {
        for (int i = 1; i < c[n]; i++) q1.push_back(i);
        for (int i = n - 1; i > c[n]; i--) q2.push_back(i);
    }
    while (q1.size() > 0 || q2.size() > 0) {
        int x1 = q1.size() ? q1.front() : 0;
        int x2 = q2.size() ? q2.front() : 0;
        int y1 = q1.size() ? q1.back() : 0;
        int y2 = q2.size() ? q2.back() : 0;
        if (c[x1] == y1) {
            ans.push_back('L');
            s.push_back('L');
            q1.pop_front();
            q1.pop_back();
        } else if (c[x1] == y2) {
            ans.push_back('L');
            s.push_back('R');
            q1.pop_front();
            q2.pop_back();
        } else if (c[x2] == y1) {
            ans.push_back('R');
            s.push_back('L');
            q2.pop_front();
            q1.pop_back();
        } else if (c[x2] == y2) {
            ans.push_back('R');
            s.push_back('R');
            q2.pop_front();
            q2.pop_back();
        } else {
            return false;
        }
    }
    reverse(s.begin(), s.end());
    ans += s;
    cout << ans << endl;
    return true;
}
int main() {
    int _;
    scanf("%d", &_);
    while (_--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) b[i] = 0;
        n *= 2;
        c[0] = -1;
        for (int i = 1; i <= n; i++) {
            scanf("%d", &a[i]);
            if (b[a[i]]) {
                c[b[a[i]]] = i;
                c[i] = b[a[i]];
            } else {
                b[a[i]] = i;
            }
        }
        if (!solve('L') && !solve('R')) puts("-1");
    }
    return 0;
}
```

### 

---

## 作者：巴菲特 (赞：24)

# Palin 题解

## 连续

由于取出来的数字序列 ${b}$ 是回文的，所以当 $a[p] = x$ 被取出时，序列 ${a}$ 中的 $\rm a[q] = a[p] = x$ 在何时取出其实已经确定了。依照题意，任意时刻，序列 ${a}$ 一定是开头连续的一部分和结尾连续的一部分被取出，我们设当前序列 ${a}$ 中区间 $[1, l] \bigcup [r, 2 * n] $ 中的数字已经被取出。可以保证的是这两段区间内没有重复取出的数字。容易发现，当我们已经取出了 $n$ 个数字时，$[1, n]$ 的所有数字都被取了一遍，而最终的 ${b}$ 序列以及操作串也已经确定了。每当一个数字 $a[p] = x$ 在开头或是结尾被取出时，我们将 $a[q] = a[p] = x$ 也取出。一个重要的性质是：任意时刻，所有取出的 $a[q]$ 是连续的一段。

这个东西其实也很好理解。${b}$ 结尾的一段对应了序列 ${a}$ 中间的一部分。考虑序列 ${b}$ 的后 $\rm n$ 个数一定是随着前 $\rm n$ 个数被取出的，并且为了保证回文，这后 $\rm n$ 个数一定是从后往前生成的。也就是说序列 ${b}$ 前 $\rm n$ 个数生成的连续性决定了他后 $\rm n$ 个数生成的连续性，只不过是反序。

## DP

我们设当前状态 $(l,i,j,r)$ 表示 ${a}$ 中区间 $[1, l] \bigcup [i, j] \bigcup [r, 2*n]$ 被取出，考虑接下来我们能干什么。无外乎四种情况：

*   当 $a[l+1]==a[i-1]$ 的时候，可以从开头取出 $a[l+1]$ 这个元素，同时把 $a[i-1]$ 取出；
*   当 $a[l + 1] == a[j + 1]$ 的时候，可以从开头取出 $a[l + 1]$ 这个元素，同时把 $a[j + 1]$ 取出；

*   当 $a[r-1]==a[i-1]$ 的时候，可以从结尾取出 $a[r - 1]$ 这个元素，同时把 $a[i-1]$ 取出；
*   当 $a[r-1] == a[j + 1]$ 的时候，可以从结尾取出 $a[r - 1]$ 这个元素，同时把 $a[j + 1]$ 取出。

可以使用 BFS 进行转移。准备一个队列，在一开始找到 $pos1$ 和 $pos2$ 满足 $a[1]=a[pos1],a[pos2]=a[2*n]$，依照题意要么取开头要么取结尾。初始有两种状态，取开头的 $a[1]$ 就是 $(1,pos1,pos1,2*n+1)$ ，取结尾的 $a[2*n]$ 就是 $(0, pos2, pos2, 2*n)$。接下来按照上述方式进行转移，只要队列不为空，就弹出旧状态，插入新状态。终止状态满足 $l + 1 == i \And j + 1 == r$。

由于已经取出 $n$ 个数字的时候整个操作序列已经确定了，所以让操作序列的字典序最小等价于让取出前 $n$ 个数字的操作序列最小，也即取出 $[1,l] \bigcup [r, 2*n]$ 的操作序列而不用管 $[i,j]$ 是怎么取的。所以我们总是优先地考虑取出 $a[l + 1]$。 那么，一旦我们找到一个终止状态，便可以保证是字典序最小的，结束转移，直接输出即可。如果搜空了队列都没有到达终止状态，那么无解。

以上是考场上的我两个小时瞪眼的结果。



## ~~DP~~ 贪心

考虑上述 $4$ 中转移最多只有两种是可行的，因为不可能出现 $a[i-1]$ 同时和 $a[l+1]、a[r - 1]$ 相等，或是 $a[j + 1]$ 同时和 $a[l+1]、a[r - 1]$ 相等。故 DP 的时间复杂度上限是 $O(2^n)$，相当于我两个小时写了一个爆搜。当时我对这个程序的认识是：“时间复杂度一定很难跑满，并且策略是正确的，可以找到解” ，也就没往下想。但是事实上这个题是线性的贪心，接下来证明在上述 $4$ 种转移中只需要选择一种就能得到正确的操作序列。

当抉择分支出现时，也就是一种状态可以转移到两种新状态时，一共有如下两种情况：

*   $a[l + 1] == a[i - 1] \And a[j + 1] == a[r - 1]$ 
*   $a[l + 1] == a[j + 1] \And a[i - 1] == a[r - 1]$ 

这里我们以第一种情况为例进行讨论，第二种同理。我们只进行开头 $a[l + 1]$ 的转移，而暂且不管 $a[r - 1]$，那么状态变为 $(l + 1, i - 1, j, r)$。接下来假如出现 $a[l + 2] == a[i - 2]$ ，那么我们依旧进行开头的转移而不管，这样下去，直到开头不能取出，设此时的状态是 $(l+k,i-k,j,r)$。这个时候我们急不可耐地取出结尾，状态变为 $(l+k,i-k,j+1,r-1)$。考虑这个过程，我们的操作序列是 $L...LR$，是所有能得到状态 $(l+k,i-k,j+1,r-1)$ 里面字典序最小的一个。

也就是说如果在一开始我们就进行结尾的转移得到 $(l+1,i-1,j+1,r-1)$，然后再进行后续的操作，最终的操作序列是 $LRL...$，而现在我们已经找到了一个更优秀的替代品 $L...LR$ 同样也能够得到最终的状态，那么结尾的转移便是完全无用的了。贪心得证。当且仅当开头无法转移时，我们才进行结尾的转移。

这就是一个大贪心，时间复杂度 $O(n)$。（虽然但是，我考场上并没有想出来，而是拿剩下的 30min 写了一个 T2 的爆搜并最终取得了 0 分的好成绩。

实现起来也很简单，队列的部分不用变，一旦我们找到一个合法转移，continue 掉就好了，这样可以保证线性。

## 输出

接下来考虑如何输出操作序列。我是开了一个结构体：

```cpp
struct Op{
	int l, r, i, j, tp1, tp2, pre;
}P[10000010];
```

$\rm P$ 相当于一个内存池。$\rm l, \rm r, \rm i, \rm j$ 无需多说，$\rm tp1$ 和 $\rm tp2$ 代表从上一个状态转移过来时的操作，$tp1 = 1/2$ 代表取出了 $a[l]$ 还是 $a[r]$，$tp2 = 1/2$ 代表取出了 $a[i]$ 还是 $a[j]$。$pre$ 记录上一个状态在内存池中的位置，用于最后的输出。注意是先输出 $\rm n$ 个 $tp1$，再输出 $\rm n$ 个 $tp2$，二者的输出顺序是相反的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int rd(){
	int res(0), fl(1);
	char c=getchar();
	while(!isdigit(c)){ if(c=='-') fl=-1; c=getchar();}
	while(isdigit(c)){ res=(res<<3)+(res<<1)+c-'0'; c=getchar();}
	return res*fl;
}
const int maxn = 1000010;
int t, n, a[maxn], b[maxn], pos1, pos2, Flg, top, N, ans1[maxn], ans2[maxn], cnt1, cnt2;
struct Op{
	int l, r, i, j, tp1, tp2, pre;
}P[10000010];
int Q[10000010], hd, tl;
void prnt(int op){
	ans1[++cnt1] = P[op].tp1; ans2[++cnt2] = P[op].tp2;
	if(P[op].pre) prnt(P[op].pre);
	return;
}
void Prnt(int op){
	cnt1=0, cnt2=0, Flg=1;
	prnt(op);
	for(int i(cnt1); i >= 1; --i) if(ans1[i] == 1) printf("L"); else printf("R");
	for(int i(1); i <= cnt2; ++i) if(ans2[i] == 1) printf("L"); else printf("R");
	printf("\n");
	return;
}
int main(){
	t = rd();
	for(;t--;){
		top=0, Flg=0; memset(ans1, 0, sizeof(int)*n); memset(ans2, 0, sizeof(int)*n);
		n = rd(); N = n * 2;
		for(int i(1); i <= N; ++i) a[i]=rd();
		for(int i(2); i <= N; ++i) if(a[i] == a[1]){ pos1 = i; break; } 
		for(int i(1); i < N; ++i) if(a[i] == a[N]){ pos2 = i; break; } 
		tl = 0, hd = 1; 
         P[++top] = Op{1, N+1, pos1, pos1, 1, 1, 0}; Q[++tl] = 1;
		P[++top] = Op{0, N, pos2, pos2, 2, 1, 0}; Q[++tl] = 2;
		while(hd <= tl){
			int op = Q[hd++];
			if(P[op].l + 1 == P[op].i && P[op].j + 1 == P[op].r){
				Prnt(op); break;
			}
			if(P[op].l + 1 < P[op].i - 1 && a[P[op].l + 1] == a[P[op].i - 1]){
				P[++top] = Op{P[op].l + 1, P[op].r, P[op].i - 1, P[op].j, 1, 1, op};
				Q[++tl] = top; continue;
			}
			if(P[op].l + 1 < P[op].i && P[op].j + 1 < P[op].r && a[P[op].l + 1] == a[P[op].j + 1]){
				P[++top] = Op{P[op].l + 1, P[op].r, P[op].i, P[op].j + 1, 1, 2, op};
				Q[++tl] = top; continue;
			} 
			if(P[op].i - 1 > P[op].l && P[op].r - 1 > P[op].j && a[P[op].i - 1] == a[P[op].r - 1]){
				P[++top] = Op{P[op].l, P[op].r - 1, P[op].i - 1, P[op].j, 2, 1, op};
				Q[++tl] = top; continue;
			} 
			if(P[op].j + 1 < P[op].r - 1 && a[P[op].j + 1] == a[P[op].r - 1]){
				P[++top] = Op{P[op].l, P[op].r - 1, P[op].i, P[op].j + 1, 2, 2, op};
				Q[++tl] = top; continue;
			} 
		} 
		if(!Flg) printf("-1\n");
	}
	return 0;
}
```



---

## 作者：Karl_Aurora (赞：24)

**[~~无耻地推销个人博客qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7915)**

**[题目传送门](https://www.luogu.com.cn/problem/P915)**

------------

## 题意

给定一个正整数序列 $ a $ 和一个空序列 $ b $ ，每次可以从 $ a $ 的左端或右端取出一个正整数放入 $ b $ 的左端，并分别记为 ```L``` 和 ```R ``` ，求使 $ b $ 成为回文串且操作序列字典序最小的操作方案。

## 解法

考虑到最终得到的是一个回文串，可知第 $ i $ 次和第 $ 2n - i + 1 $ 次取出的数应相同，则我们可以考虑每次同时分析并处理第 $ i $ 次与第 $ 2n - i + 1 $ 次操作。 

又有每次只能从 $ a $ 的左端或右端取数，则 $ a $ 实际上被分成了两个连续的部分，一部分只能从左端取出，另一部分只能从右端取出，接下来我们要考虑的就是这两个部分应当如何划分的问题。

我们由题意易得最后一个取的数与第一个取的数必须相同，而最后一个取的数也正是最后一个从左段取出的数，所以从左端取出的数的范围是可以由第一个取出的数确定的。而又因为第一个数可以从左端取，也可以从右端取，所以我们需要分类讨论，按照优先级先处理第一个数取左边的情况，不行的话再考虑取右边的情况。

而我们取数时又需要同时分析并处理第 $ i $ 次与第 $ 2n - i + 1 $ 次操作，即需要同时处理两部分中当前最先被取出与最后被处理的数（可以在同一部分取，也可以在不同部分取，具体参照下文对操作的分类），也就是两部分分别的两端，所以我们可以考虑用双端队列存储这两个部分，从出序列方向的正向出队列代表第 $ i $ 次操作，从出序列方向的反向出队列代表第 $ 2n - i + 1 $ 次操作。

现在我们不妨令双端队列 $ L , R $ 按顺序分别存储从左端取出的数和从右端取出的数，则第 $ i $ 次操作按照优先级有如下四种情况：

>
> 1. $ L $ 的左端等于 $ L $ 的右端，则 $ L $ 的左端与 $ L $ 的右端出队列，第 $ i $ 次操作为```L```，第 $ 2n - i + 1 $ 次操作为```L```；
>
> 1. $ L $ 的左端等于 $ R $ 的左端，则 $ L $ 的左端与 $ R $ 的左端出队列，第 $ i $ 次操作为```L```，第 $ 2n - i + 1 $ 次操作为```R```；
>
> 1. $ R $ 的右端等于 $ L $ 的右端，则 $ R $ 的右端与 $ L $ 的右端出队列，第 $ i $ 次操作为```R```，第 $ 2n - i + 1 $ 次操作为```L```；
>
> 1. $ R $ 的右端等于 $ R $ 的左端，则 $ R $ 的右端与 $ R $ 的左端出队列，第 $ i $ 次操作为```R```，第 $ 2n - i + 1 $ 次操作为```R```；
>

则对于每次操作我们只需按照优先级进行判断，优先执行高优先级的操作，不断重复，如果有哪次操作一种都执行不了，则输出```-1```，否则一直执行到结束位置，最终输出生成的操作序列即可。

最后丑陋的代码如下：  ~~(这是我的考场代码，实现比较丑陋，不具有多大实际参考价值，还是建议大家手打一遍)~~

```cpp
#include <bits/stdc++.h>
#define maxn 500010
//time:O(Tn) expect score:100
using namespace std;
inline int read()
{
	int X = 0; bool f = false; char ch = getchar();
	while (ch > '9' || ch < '0') {f |= ch == '-'; ch = getchar();}
	while (ch <= '9' && ch >= '0') {X = (X << 3) + (X << 1) + (ch ^ 48); ch = getchar();}
	return f ? -X : X;
}
int T, n, x[2 * maxn], step;
deque < int > a, b;
char ch[2 * maxn];
bool f;
void getin()
{
	n = read();
	for (int i = 1; i <= 2 * n; ++i) x[i] = read();
	a.clear(); b.clear(); memset(ch, 0, sizeof(ch));
	a.push_back(x[1]); a.push_back(x[2]);
	for (int i = 3; i <= 2 * n; ++i) {if (a.front() != a.back()) a.push_back(x[i]); else b.push_back(x[i]);}
	f = false;
	step = 0; 
	while (step < n)
	{
		if (f) break;
		f = true;
		if (a.size() > 1 && a.front() == a.back()) {f = false; ++step; ch[step] = 'L'; ch[2 * n - step + 1] = 'L'; a.pop_front(); a.pop_back(); continue;}
		if (a.size() && b.size() && a.front() == b.front()) {f = false; ++step; ch[step] = 'L'; ch[2 * n - step + 1] = 'R'; a.pop_front(); b.pop_front(); continue;}
		if (a.size() && b.size() && a.back() == b.back()) {f = false; ++step; ch[step] = 'R'; ch[2 * n - step + 1] = 'L'; a.pop_back(); b.pop_back(); continue;}
		if (b.size() > 1 && b.front() == b.back()) {f = false; ++step; ch[step] = 'R'; ch[2 * n - step + 1] = 'R'; b.pop_front(); b.pop_back(); continue;}
	}
	if (!f) {for (int i = 1; i <= 2 * n; ++i) putchar(ch[i]); putchar('\n'); return;}
	a.clear(); b.clear(); memset(ch, 0, sizeof(ch));
	b.push_front(x[2 * n]); b.push_front(x[2 * n - 1]);
	for (int i = 2 * n - 2; i > 0; --i) {if (b.front() != b.back()) b.push_front(x[i]); else a.push_front(x[i]);}
	a.push_back(b.front()); b.pop_front();
	f = false;
	step = 0; 
	while (step < n)
	{
		if (f) {printf("-1\n"); return;}
		f = true;
		if (a.size() > 1 && a.front() == a.back()) {f = false; ++step; ch[step] = 'L'; ch[2 * n - step + 1] = 'L'; a.pop_front(); a.pop_back(); continue;}
		if (a.size() && b.size() && a.front() == b.front()) {f = false; ++step; ch[step] = 'L'; ch[2 * n - step + 1] = 'R'; a.pop_front(); b.pop_front(); continue;}
		if (a.size() && b.size() && a.back() == b.back()) {f = false; ++step; ch[step] = 'R'; ch[2 * n - step + 1] = 'L'; a.pop_back(); b.pop_back(); continue;}
		if (b.size() > 1 && b.front() == b.back()) {f = false; ++step; ch[step] = 'R'; ch[2 * n - step + 1] = 'R'; b.pop_front(); b.pop_back(); continue;}
	}
	for (int i = 1; i <= 2 * n; ++i) putchar(ch[i]); putchar('\n');
	return;
}
int main()
{
//	freopen("palin.in", "r", stdin);
//	freopen("palin.out", "w", stdout);
	T = read();
	for (int i = 1; i <= T; ++i) getin();
	return 0;
}

```

至此，愉快AC，完结撒花0v0

---

## 作者：an_ancient_ghoul (赞：18)

# 题解P7915 【CSP-S T3】
我赛时写挂了~~是根本没看~~，现在一雪前耻！  

------------
## solution：

首先枚举第一次操作是 L 或 R，因为字典序要尽可能小，所以 L 优先。但一旦扩展了$a$ ，就必须**对称地**扩展第二个$a$，因此，我们知道了第一个，就可以找到倒数第一个被扩展的元素，以此类推。  
相应地，第二个必然接在第一个的后面，或是在序列的另一端。倒数第二个则必须和倒数第一个相邻。否则不符合秩序了。
由此，则有三个连通块。  
   
从原序列的左右两头向内扩展，直到三个连通块合为一个（及操作完成）。

## code：
```cpp
#include<bits/stdc++.h>
#define maxn (int)5e5+10
using namespace std;
int t, n, cnt, le1, le2, lr1, lr2, to;
//le1、lr1 代表边缘两块的内侧边界
//le2、lr2 代表中间块的边界
int a[2 * maxn], l1[maxn], l2[maxn];
//l1、l2：每个元素第一、二次出现的位置
char sol[2*maxn];
bool st(int x)
{
	le1 = 0, lr1 = 2 * n + 1;
	memset(sol, 0, sizeof sol);
	cnt = 1;
	if (x == 1)sol[1] = 'L', le1++, le2 = lr2 = l2[a[1]];
	else sol[1] = 'R', lr1--, le2 = lr2 = l1[a[2 * n]];
	sol[2 * n] = 'L';
	while (cnt < n)
	{
		if (le1 < le2) 
		{
			to = a[le1 + 1];
			if (l2[to] - 1 == lr2)
			{
				le1++, lr2++, cnt++;
				sol[cnt] = 'L';
				sol[2 * n - cnt+1] = 'R';
				continue;
			}
			if (l2[to] + 1 == le2)
			{
				le1++, le2--, cnt++;
				sol[cnt] = 'L';
				sol[2 * n - cnt+1] = 'L';				
				continue;
			}
		}
		if (lr1 > lr2)
		{
			to = a[lr1 - 1];
			if (l1[to] - 1 == lr2)
			{
				lr1--, lr2++, cnt++;
				sol[cnt] = 'R';
				sol[2 * n - cnt+1] = 'R';
				
				continue;
			}
			if (l1[to] + 1 == le2)
			{
				lr1--, le2--, cnt++;
				sol[cnt] = 'R';
				sol[2 * n - cnt+1] = 'L';
				continue;
			}
		}
		return 0;
	}
	return 1;
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin >> t;
	while (t--)
	{               
		memset(l1, 0, sizeof l1);memset(l2, 0, sizeof l2);
		cin >> n;
		for (int i = 1; i <= 2 * n; i++)
		{
			cin >> a[i];
			if (l1[a[i]])l2[a[i]] = i;
			else l1[a[i]] = i;			
		}
		if (st(1))cout << sol+1 << endl;
//分别枚举第一次为 L 或 R
		else if (st(2 * n))cout << sol+1 << endl;
		else cout << -1 << endl;
	}
	return 0;
}
```

---

## 作者：Micnation_AFO (赞：10)

## $\texttt{Description}$

给定一个长度为 $2 \times n$ 的数列 $A$ 和一个空数列 $B$，每次可以从 $A$ 数列的最左边或最右边拿出一个数并放入 $B$ 数列的末尾，求字典序最小的方案。无方案则输出 `-1`。

## $\texttt{Brute Force}$

这里给出 $28\texttt{pts}$ 的做法，也是最容易想的暴力深搜~~以及我在考场上骗分的思路~~。对于每一次操作，先从左往右扫描一遍，然后标记第一个没有被使用的数字，同时记录答案。然后再从右往左扫（为了保证字典序）。放一下这部分的[代码](https://www.luogu.com.cn/paste/tg2lg8az)。

## $\texttt{Solution}$

首先可以想到，第一步只能从最左边或最右边选。此处讨论选最左边的方法。

![](https://cdn.luogu.com.cn/upload/image_hosting/ifqk73zy.png)

如上图，若把开头的 $4$ 移走，为了保证回文，另外一个 $4$ 一定是最后一个移走的。因此，我们需要把红色方框内的数字全部移走才能保证合法。

现在考虑进行第二次操作。

显然，第二次操作**只能拿走左边红框的第一个元素 $1$，或者右边红框最后的元素 $5$**。到底应该取哪一个呢？

我们可以从倒数第二次操作来分析。在上图中，第二个 $4$ 是最后移走的，又因为每次只能移动最左边或最右边的元素，因此**倒数第二个移走的一定是上图中第二个 $4$ 左边的 $2$ 或者右边的 $5$**。

为了保证回文，**第二次操作和倒数第二次操作移走的数必须相同**。因此，这里只能移走 $5$（在代码中，这里要把两个 $5$ 同时移走，防止后面重复访问）。

--------------------------

结合刚才的具体例子，我们来归纳一下：

1. 找到序列中与第一个元素相同的元素，记录其位置 $i$。
2. 把 $A_1$ 到 $A_{i - 1}$ 放入一个数组，把 $A_{i +1}$ 到 $A_{2 \times n}$ 放入另一个数组（这两个数组模拟上图中的红框）。
3. 此时可以移走的数字是左边红框的第一个元素和右边红框的最后一个元素。而与之对应的是左边红框的最后一个元素以及右边红框的第一个元素。若前两个元素中有一个与后两个元素中的一个相同，则删除这两个元素（如果没有相同的，就说明无法操作）。并且分别记录答案（左红框就记为 `L`，右红框就记为 `R`）。
4. 如果第三步无法操作，那么就找到序列中与最后一个元素相同的元素，记录位置 $j$。并重复类似于步骤 $2$ 和步骤 $3$ 的操作。

细节很多，其中红框可以通过双端队列（`deque`）实现。

$\texttt{AC Code}$：

```cpp
#include <iostream>
#include <cstring>
#include <deque>
using namespace std;

const int N = (5e5 + 10) * 2;
int T;
int a[N];
char ans[N], ans1[N];
deque<int> c, d;
bool flag, v;

void output(int cnt) {
    printf("%c", (v ? 'R' : 'L'));
    for (int i = 1; i <= cnt; i++) printf("%c", ans[i]);
    for (int i = cnt; i >= 1; i--) printf("%c", ans1[i]);
    printf("%c\n", 'L');
}

void check() {
    int cnt = 0;
    while (c.size() && d.size()) {
        int a, b, x, y;
        a = c.front(), b = c.back();
        x = d.front(), y = d.back();
        if (a == b && c.size() != 1) {
            ans[++cnt] = 'L', ans1[cnt] = 'L';
            c.pop_front(), c.pop_back();
            continue;
        }
        if (a == y) {
            ans[++cnt] = 'L', ans1[cnt] = 'R';
            c.pop_front(), d.pop_back();
            continue;
        }
        if (x == y && d.size() != 1) {
            ans[++cnt] = 'R', ans1[cnt] = 'R';
            d.pop_back(), d.pop_front();
            continue;
        }
        if (b == x) {
            ans[++cnt] = 'R', ans1[cnt] = 'L';
            c.pop_back(), d.pop_front();
            continue;
        }
        flag = true;
        return;
    }
    
    while (c.size()) {
        int a = c.front(), b = c.back();
        if (a == b) {
            ans[++cnt] = 'L', ans1[cnt] = 'L';
            c.pop_front();
            c.pop_back();
        }
        else {
            flag = true;
            return;
        }
    }
    while(d.size()) {
        int a = d.front(), b = d.back();
        if (a == b) {
            ans[++cnt] = 'R', ans1[cnt] = 'R';
            d.pop_front();
            d.pop_back();
        }
        else  {
            flag = true;
            return;
        }
    }
    output(cnt);
}

int main() {
    scanf("%d", &T);
    while (T--) {
        flag = false, v = false;
        while (c.size()) c.pop_back();
        while (d.size()) d.pop_back();
        memset(ans, 0, sizeof(ans));
        int n, val;
        scanf("%d%d", &n, &a[1]);
        for (int i = 2; i <= 2 * n; ++i) {
            scanf("%d", a + i);
            if (a[i] == a[1]) val = i;
        }
        
        for (int i = 2; i < val; i++) c.push_back(a[i]);
        for (int i = 2 * n; i > val; i--) d.push_back(a[i]);

        check();
        if (flag == false) continue;
        
        flag = false, v = true;
        while (c.size()) c.pop_back();
        while (d.size()) d.pop_back();
        memset(ans, 0, sizeof(ans));

        for (int i = 2 * n - 1; i >= 1; i--) 
            if (a[i] == a[2 * n]) val = i;
        for (int i = 1; i < val; i++) c.push_back(a[i]);
        for (int i = 2 * n - 1; i > val; i--) d.push_back(a[i]);
        check();

        if (flag == true) printf("-1\n");
    }
    return 0;
}
```







---

## 作者：郑朝曦zzx (赞：10)

# 一 关于今年的这道 T3
- 比想象中的简单（可我不看题解依然不会，我太弱了）
- 和 T2 差不多吧，甚至更难一些（T2就是个套路区间动规）
- 涉及的算法只有普及难度，但思维含量还是有的。

# 二 解题思路
## part1 暴力
没啥好说的暴力枚举每次是 L 还是 R 再判一下是否回文。

时间复杂度：$O(2^n\times n)$

期望得分：$28pts$

## part2 区间动态规划
也是套路，小区间被大区间包含。

时间复杂度：$O(n^2)$

期望得分：$60pts$

## part3 正解：双向队列

您看到了正解所需的算法时可能和我当初看题解时的心情一样，怎么这么简单！

我们来分析一下这道题目是如何被转化为双向队列的：

由于第一个取左边和取右边的思路相似，此处只分析取左边的情况：

1. 第一步：找到唯一的位置 $x$，使得 $a_1 = a_x$。

- 举例：再样例一中，$x = 4$。

2. 第二步：我们可以把这个数列分成两个部分：$2\sim x-1$ 和 $x + 1 \sim 2n$。

为了方便说明，我们设第一个队列为 $P$，第二个为 $Q$。
- 举例：样例一就被分成两截：
```cpp
P:1 2
Q:5 3 1 2 3 5
```
3. 第三步重复以下操作纸质两个队列均为空：

**分类讨论（重点）第 $i$ 次取有一下几种情况：**

- - $P$ 的队首元素和它的队尾元素相同，那么先取 $P$ ,并记录 $ans_i = L$ 以及 $ans_{2(n - 1) - i + 1} = L$，同时弹出队首和队尾。

注： 此处解释一下：$ans_{2(n - 1) - i + 1}$ 是指倒数第 $i$ 次操作。

- - $P$ 的队首元素和 $Q$ 的队尾元素相等，先取 $P$（L）， 倒数第 $i$ 次取 $Q$（R），并弹出相应元素。
- - $P$ 的队尾和元素和 $Q$ 的队首元素相等，先取 $Q$（R）， 倒数第 $i$ 次取 $P$（L），并弹出相应元素。

- - $Q$ 的队首元素和它的队尾元素相同，那么先取 $Q$ ,并记录 $ans_i = R$ 以及 $ans_{2(n - 1) - i + 1} = R$，同时弹出队首和队尾。

> 你需要输出所有方案对应的字符串中字典序最小的一个。

情况 1 和情况 4 是有可能同时出现的，情况 2 和情况 3 可能同时出现，故需要按照一定的顺序枚举四种情况，即 1 在 4 前，2 在 3 前。


**说着有点绕，强烈建议大家画图理解，而不仅仅是复制代码，毕竟真题挺珍贵的。**

# 三 代码

说了这么多，上代码吧：

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 500010;
int t, n, l, r;
int a[maxn << 1];
char ans[maxn << 1];
bool solve(int l1, int r1, int l2, int r2)
{
	for (int i = 1; i < n; ++i)
	{
		if (l1 < r1 && a[l1] == a[r1])
		{
			ans[i] = 'L'; l1++;
			ans[2 * (n - 1) - i + 1] = 'L'; --r1;
		}
		else if (l1 <= r1 &&l2 <= r2 && a[l1] == a[l2])
		{
			ans[i] = 'L'; ++l1;
			ans[2 * (n - 1) - i + 1] = 'R'; ++l2;
		}
		else if (l2 <= r2 && l1 <= r1 && a[r2] == a[r1])
		{
			ans[i] = 'R'; --r2;
			ans[2 * (n - 1) - i + 1] = 'L'; --r1;
		}
		else if (l2 < r2 && a[l2] == a[r2])
		{
			ans[i] = 'R'; ++l2;
			ans[2 * (n - 1) - i + 1] = 'R'; --r2;
		}
		else return 0;
	}
	return 1;
}
int main()
{
	scanf("%d", &t);
	while (t--)
	{
		int x1, x2;
		scanf("%d", &n);
		for (int i = 1; i <= 2 * n; ++i)
			scanf("%d", &a[i]);
		memset(ans, '\0', sizeof(ans));
		for (int i = 2; i <= 2 * n; ++i)
			if (a[1] == a[i]) {x1 = i; break;}
		for (int i = 2; i < 2 * n; ++i)
			if (a[2 * n] == a[i]) { x2 = i; break;}
		if (solve(2, x1 - 1, x1 + 1, 2 * n))
			printf("L%sL\n", ans + 1);
		else if(solve(1, x2 - 1, x2 + 1, 2 * n - 1))
			printf("R%sL\n", ans + 1);
		else printf("-1\n");
	}	
	return 0;
} 
```


---

## 作者：Elma_ (赞：9)

**Update**：修了下代码的小 bug


------------

发现赛时做法有个地方假了，寄了。只能希望能少挂点分吧。写一个看起来很对的做法。

首先因为操作只能取 $a$ 的头或尾，那么我们取任意次后所取出的数一定是 $a$ 的一段前缀和一段后缀，并且若想要使 $b$ 回文，显然 $b_{1\cdots n}$ 和 $b_{n+1 \cdots 2 \times n}$ 都应该是一个 $1 \sim n$ 的排列。所以存在合法操作的必要条件是存在某个 $1\leq k \leq n$ 满足对于 $a_{1\cdots k}$ 和 $a_{2 \times n-(n-k)+1 \cdots2 \times n}$ 拼接成的序列，$1 \sim n$ 中的所有数恰好在其中出现一次。

对于这一步，我们可以预处理出 $p_i$ ，满足对于任意 $1 \leq i \leq 2 \times n$ 都有 $i \neq p_i$ 且 $a_i = a_{p_i}$。考虑按照下面的方法求出 $k$  的范围 $1 \leq k \leq q$：从左往右扫一遍 $a_i$，若其在 $a$ 中第一次出现，那么 $q = \min(q,p_i - 1)$，这是因为每个数最多只能出现一次。不难发现 $k$ 的合法取值可能有多个，因此可以对所有 $1 \leq k \leq q$ 扫一遍，若不存在合法的排列，那么直接输出 $-1$。

考虑取数的过程，为了保证最后的序列 $b$ 是个回文串，对于前缀和后缀两段的取数顺序事实上决定了在中间那一段 $1\sim n$ 的排列中取数的顺序。具体地，若当前是第 $i$ 次操作，取出了前缀/后缀的某个位置 $j$，那么对于之后的第 $2 \times n - i + 1$ 次操作就需要取出 $p_j$ 位置上的数。而位置 $p_j$ 上的数能被取出当且仅当位置 $p_j + 1$ 或 $p_j -1$ 中的某个数已经被取出，也就是说，任意时刻被确定顺序的数都应该是一个连续段。

贪心地想，我们假设第一个取出 $a_1$，考虑在这样的情况下能够得到的最小操作串 $s$。记 $g_i$ 表示位置 $i$ 上的数是否已经被确定取数顺序，并且存下 $rk_i$ 表示位置 $i$ 被确定的顺序，那么只需要维护两个指针 $\mathrm{pre}$ 和 $\mathrm{suf}$ 表示当前前缀/后缀分别取到哪里，每次贪心地移动指针即可，并且可以简单地证明贪心的正确性。如果第一个取出 $a_1$ 不合法，那么就第一个取出 $a_{2 \times n}$ 再做一遍；如果都不合法，答案就是 $-1$。

关于最后一段的实现，不难发现按照贪心填数后 $\mathrm{pre}$ 和 $\mathrm{suf}$ 的位置就是中间连续段的两个端点，因此也按照 $rk$ 移动指针更新答案即可。时间复杂度 $O(n)$。

```cpp
int T, N, M, A[MN], pos[MN], vis[MN], B[MN], C[MN], D, Ans[MN], rk[MN];

signed main(void) {
	// freopen("palin.in", "r", stdin);
	// freopen("palin.out", "w", stdout);
	T = read();
	while (T--) {
		N = read(), M = 0;
		for (int i = 0; i <= N + 1; i++) vis[i] = pos[i] = rk[i] = B[i] = 0;
		for (int i = 1; i <= 2 * N; i++) A[i] = read(), Ans[i] = 0;
		int p = Inf;
		for (int i = 1; i <= 2 * N; i++) {
			if (!vis[A[i]]) vis[A[i]] = 1;
			else pos[A[i]] = i;
		}
		for (int i = 1; i <= N; i++) p = min(p, pos[i]);
		p--;
		int cnt = 0;
		for (int i = 1; i <= p; i++) B[A[i]]++;
		for (int i = 2 * N - (N - p) + 1; i <= 2 * N; i++) B[A[i]]++;
		for (int i = 1; i <= N; i++) cnt += (B[A[i]] > 0);
		if (cnt < N) {
            // puts("-1");
            // continue;
            int l = p, r = 2 * N - (N - p), o = 0;
			for (int i = 1; i <= p; i++) {
                if ((--B[A[l]]) == 0) cnt--;
                if ((++B[A[r]]) == 1) cnt++;
                if (cnt == N) {
                    o = 1;
                    break;
                }
                l--, r--；
            }
            if (!o) {
                puts("-1");
                continue;
            }
		} 
		for (int i = 0; i <= 2 * N; i++) vis[i] = pos[i] = 0;
		for (int i = 1; i <= 2 * N; i++) {
			if (!vis[A[i]]) vis[A[i]] = i;
			else pos[i] = vis[A[i]];
		}
		for (int i = 0; i <= N + 1; i++) vis[i] = 0;
		for (int i = 2 * N; i >= 1; i--) {
			if (!vis[A[i]]) vis[A[i]] = i;
			else pos[i] = vis[A[i]];
		} 
//		for (int i = 1; i <= N; i++) printf("%lld%c", B[i], " \n"[i == N]);
//		for (int i = 1; i <= N; i++) printf("%lld%c", C[i], " \n"[i == N]);
		for (int i = 0; i <= 2 * N + 1; i++) vis[i] = 0;
		vis[pos[1]] = 1, Ans[1] = 1, rk[pos[1]] = N;
		int pre = 2, suf = 2 * N, fail = 0;
		//1~p p+1~n
//		for (int i = 1; i <= 2 * N; i++) printf("%lld%c", pos[i], " \n"[i == 2 * N]);
		for (int i = 2; i <= N; i++) {
//			for (int j = 1; j <= N; j++) {
//				printf("%lld%c", vis[j], " \n"[j == N]);
//			}
			if (!vis[pre]) {
				if (vis[pos[pre] + 1] || vis[pos[pre] - 1]) {
					Ans[i] = vis[pos[pre]] = 1, rk[pos[pre]] = N - i + 1;
					pre++;
				} else if (vis[suf]) {
					fail = 1;
					break;
				} else {
					if (vis[pos[suf] + 1] || vis[pos[suf] - 1]) {
						Ans[i] = 0, vis[pos[suf]] = 1, rk[pos[suf]] = N - i + 1;
						suf--;
					} else {
						fail = 1;
						break;
					}
				}
			} else {
				if (vis[pos[suf] + 1] || vis[pos[suf] - 1]) {
					Ans[i] = 0, vis[pos[suf]] = 1, rk[pos[suf]] = N - i + 1;
					suf--;
				} else {
					fail = 1;
					break;
				}
			}
		}
//		for (int i = 1; i <= N; i++) printf("%lld%c", Ans[i], " \n"[i == N]);
		if (fail) {
//			puts("!");
			for (int i = 0; i <= 2 * N + 1; i++) vis[i] = 0;
			fail = 0;
			vis[pos[2 * N]] = 1, pre = 1, suf = 2 * N - 1, Ans[1] = 0, rk[pos[2 * N]] = N;
			for (int i = 2; i <= N; i++) {
				if (!vis[pre]) {
					if (vis[pos[pre] + 1] || vis[pos[pre] - 1]) {
						Ans[i] = vis[pos[pre]] = 1, rk[pos[pre]] = N - i + 1;
						pre++;
					} else if (vis[suf]) {
						fail = 1;
						break;
					} else {
						if (vis[pos[suf] + 1] || vis[pos[suf] - 1]) {
							Ans[i] = 0, vis[pos[suf]] = 1, rk[pos[suf]] = N - i + 1;
							suf--;
						} else {
							fail = 1;
							break;
						}
					}
				} else {
					if (vis[pos[suf] + 1] || vis[pos[suf] - 1]) {
						Ans[i] = 0, vis[pos[suf]] = 1, rk[pos[suf]] = N - i + 1;
						suf--;
					} else {
						fail = 1;
						break;
					}
				}
			}
			if (fail) {
				puts("-1");
				continue;
			}
			for (int i = 1; i <= N; i++) {
				if (rk[pre] == i) {
					pre++, Ans[N + i] = 1;
				} else {
					suf--, Ans[N + i] = 0;
				}
			}
			for (int i = 1; i < 2 * N; i++) {
				printf("%c", "RL"[Ans[i]]);
			}
			puts("L");
			continue;
		}
//		for (int i = 1; i <= N; i++) printf("%lld%c", rk[i], " \n"[i == N]);
		for (int i = 1; i <= N; i++) {
			if (rk[pre] == i) {
				pre++, Ans[N + i] = 1;
			} else {
				suf--, Ans[N + i] = 0;
			}
		}
		for (int i = 1; i < 2 * N; i++) {
			printf("%c", "RL"[Ans[i]]);
		}
		puts("L");
	}
	return 0;
}
/* 
2 
5
4 1 2 4 5 3 1 2 3 5
3
3 2 1 2 1 3
*/
```


---

## 作者：zbk233 (赞：5)

## 解题思路

先拿样例举例：

```
下标：  1 2 3 4 5 6 7 8 9 10

原数组：4 1 2 4 5 3 1 2 3 5
```

首先，我们考虑取 $a_1$，即 $4$。

$a_1$ 的 $4$ 成为了 $b$ 数组的第一个元素，那么，由于 $b$ 数组是回文数列，$a_4$ 的 $4$ 就一定会成为 $b$ 数组的最后一个元素。

此时，$a_1$ 被取掉，那么就只能取 $a_2$ 的 $1$ 或 $a_{10}$ 的 $5$。

不过，要注意此时 $a_4$ 的位置已经确定了，是 $b$ 数组的最后一个元素。

那么，用倒推法，可以推出删去 $a_3$ 或 $a_5$ 后的 $a_4$ 才会变成最后一个元素，也就是说，在 $a_4$ 之前删去的一定是 $a_3$ 的 $2$ 或 $a_5$ 的 $5$。

所以，整理一下，$b$ 数组的第二个元素只能是 $a_2$ 的 $1$ 或 $a_{10}$ 的 $5$，倒数第二个元素只能是 $a_3$ 的 $2$ 或 $a_5$ 的 $5$。

因此第二个元素只能选择 $a_{10}$ 的 $5$。

这样的方法可以通过指针来实现：外部的指针指向左、右端点，向内移动；内部的指针指向左、右端点，向外扩张。

---

## 作者：WeLikeStudying (赞：4)

- 作者应该全面看题目的，杠第二题去了，考好差……

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P7915)。
- 给定数列 $a$，里面是 $1$ 到 $n$ 的数，每个数出现两次，形成一个排列。
- 构造一个回文数列满足这个数列的任何一个后缀，都可以在 $a$ 中找到一个完整的数列与它不计顺序相同，如果存在这样的回文数列还要使得操作序列的字典序最小化。
- 无解输出 $-1$。
- 多测，$\sum n\le 5\times 10^5$。

**分析**
- 一看就有点像构造题对吧。
- 反正只会出现两次，咱们一开始随便拿一个数吧，比如最开头的 $a$，另外的 $a$ 可能出现在最末尾，那么按顺序取如果不能成为回文串的话显然不行。
- 也可能出现在中间：
![](https://cdn.luogu.com.cn/upload/image_hosting/p64384tq.png)
- 中间的那个肯定是最后的对吧。
- 那么有一些相同的数字可能不经过中间的 $a$，也可能越过。
![](https://cdn.luogu.com.cn/upload/image_hosting/wph66obe.png)
- 接下来的这两个那就是妥妥的双端队列构造。
- 否则显然可以构造出一种方案符合题意。
- [代码实现](https://www.luogu.com.cn/paste/xssq3w09)。
- 作者想它还是想得挺复杂的。

---

## 作者：Plozia (赞：3)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/120960080)

这道题我考场上的时候敲了个 $O(2^n)$（不是 $O(2^{2n})$） 的代码，然后成功搞到 40pts。

进入正题。

我们设 $Match_i$ 表示互相相等的两个数，另外那个数的位置，也就是说如果 $a_i=a_j$，那么 $Match_i=j,Match_j=i$。

然后我们就可以得到一个奇怪的性质：设每次取出 $a_i$ 之后我们在 $Match_i$ 位置上打个标记，那么除第一个数之外，每次取出的数 $a_j$ 其 $Match_j$ 位置左右两边有且仅有一个位置是有标记的。

证明的话其实也比较简单：

![在这里插入图片描述](https://img-blog.csdnimg.cn/e2f19eca9cc640f796130ce882ed9b91.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGxvemlh,size_20,color_FFFFFF,t_70,g_se,x_16)

我们发现箭头指的那个点左右两边都被打标记了，这个数所匹配的另一个数比左右两个数都要迟一点取出，由于取出的数列是个回文串，那么这个打箭头的数必须要先被取出，可是这样的话左右两边就有一个数要被取出了，这样就打破了回文串的性质。

至于说左右两边一个都没有为什么不可行（第一个数除外），也是可以类似证明的，因为有数字被你卡在里面了。

然后我们根据上述性质贪心的从左边选，找到解就输出，没了。

这个复杂度是 $O(T\sum n)$ 的，但是我不会证qwq

---

## 作者：Booksnow (赞：3)

# 回文

**吐槽：这题的字典序最小是答案字符串的字典序最小。**

[更好的阅读体验](https://www.cnblogs.com/Defoliation-ldlh/p/15456996.html)

## 题目大意

给定一个长为 $2n$ 的序列，由数字 $1\rightarrow n$ 组成，且每个数字有两个。

每次操作要么选择左端点要么选择右端点，选择后将该数字从序列里删除并加入另一个序列的末尾，要求最后得到的序列是一个回文串。

输出一个长为 $2n$ 的字符串，为每一次的选择，选左端点为 $L$ ，选右端点为 $R$ 。

若有多种方案，输出字典序最小的那一个。

## 分析

手玩一下样例，可以发现以下性质：

- 每当我们取一个数，我们必定能在序列中间的某个位置找到与这个数相同的数。

- 由于是回文串，我们可以将其分为两半取，先考虑前一半，发现前一半越先取后一半就要越后取。

于是，我们能够推出一个比较重要的性质。

假设我们取了一个数，在中间某个位置找到了它，又取了另外一个数，同样在中间某个位置找到了和它相同的那个数。这两个对应位置如果不相连，必然可以相信，它们中间的数会在未来某个位置被我们取到，根据上述性质 $2$ ，我们要在**两个后取的数的包裹下取一个先取的数**，显然是不合题意的。

所以，我们可以把序列分为两部分，一部分是端点，一部分是已经选的数的映射区间，要保证，该区间必须连续，所以每次选的数必须要在这个区间的两边扩展，也就是说只能选这个区间的两边对应的数。简单的，如果无法进行扩展，说明我们的匹配失败了。

我们可以维护四个指针，然后能选左就选左，否则考虑选右，由于最开始我们没有区间，于是我们进行两次这个操作，第一次最开始选择左端点，第二次最开始选择右端点，若第一次已经成功那么就是最优解，否则进行第二次。
若两次都失败，则无解。

## CODE

```
#include <bits/stdc++.h>
using namespace std;
const int N=5e5+10;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w*=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;	
}
int T,n;
int R[N],a[2*N];
int num[N];
char ans[2*N],temp[2*N];
bool flag;
inline void Solve(int x,int y,int A,int B) //记录目前的位置 
{
	int cnt=1;
	while(cnt<n){ //选完为止
		//理论上两边都能选
		//先选小的
		int tx=x;
		if(a[x]==a[B]&&x<=A&&B<=y) B++,x++;
		else if(a[x]==a[A]&&x<A) A--,x++;
		else if(a[y]==a[B]&&B<y) B++,y--;
		else if(a[y]==a[A]&&x<=A&&B<=y) A--,y--;
		else return;
		if(tx!=x) temp[++cnt]='L';
		else temp[++cnt]='R';
	}
	flag=true; //匹配成功 
}
inline void out()
{
	int x=1,y=2*n,tot=0;
	for(register int i=1;i<=n;i++){
		if(temp[i]=='L') R[++tot]=a[x],x++;
		else R[++tot]=a[y],y--;
	}
	for(register int i=n+1;i<=2*n;i++){
		if(R[tot]==a[x]) temp[i]='L',x++;
		else temp[i]='R',y--;
		tot--;
	}
	for(register int i=1;i<=2*n;i++){
		if(ans[i]<temp[i]) return;
		if(temp[i]<ans[i]) break;
	}
	for(register int i=1;i<=2*n;i++) ans[i]=temp[i];
}
inline void update()
{
	
	flag=false;
	int p;
	for(register int i=2;i<=2*n;i++)
		if(a[i]==a[1]) { p=i; break; }
	temp[1]='L',Solve(2,2*n,p-1,p+1);
	if(flag) { out(); return; }
	for(register int i=1;i<=2*n-1;i++)
		if(a[i]==a[2*n]) { p=i; break; }
	temp[1]='R',Solve(1,2*n-1,p-1,p+1); //从两个位置出发做一遍 
	if(flag) { out(); return; }
}
int main()
{
//      freopen("palin.in","r",stdin);
//      freopen("palin.out","w",stdout);
	T=read();
	while(T--){
		ans[1]='Z'; //初始值 
		n=read();
		for(register int i=1;i<=2*n;i++) a[i]=read();
		update();
		if(ans[1]=='Z') printf("-1\n");
		else{
			for(register int i=1;i<=2*n;i++) printf("%c",ans[i]);
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：JiaY19 (赞：3)

这应该算一道结论题吧。

我们考虑模拟序列来发现规律。

#### 思路

由于回文串的特殊性质，我们可以发现。

第一个取出的数的另一个相同的数，一定是最后一个取出。

大家可以感性理解一下。

例如：

```
序列 ：     4 1 2 4 5 3 1 2 3 5

顺序（倒序）
```

我们先将四取出。

```
序列 ：     1 2 4 5 3 1 2 3 5

顺序(倒序）：    1
```
看到了吗，另一个四被打上标记，表示要最后一个选。

然后，我们发现，我们现在既可以选一，又能选五。

我们都来试一试。

```
序列 ：     2 4 5 3 1 2 3 5

顺序(倒序）：  1     2
```

假如选了一，那么另一个一就要倒数第二个被选。

此时，我们就能发现，中间的五和三就永远不会被选了。

所以可以得出结论，中间必须得是连续一段的数。

#### 细节

知道了大体思路，我们就能思考一些细节。

我们可以发现。

由于中间的序列是向左右不断拓展。

所以对于原序列，我们可以不断的进行判断，能选左边一定选左边，不能选左边则选右边。

但要注意，以上思路是需要我们确定第一个选的是什么。

反正只有两种情况。

我们可以先跑左边，如果合法，直接输出答案。

如果不合法，再去跑右边。

如果仍然不合法，则输出-1。

#### 实现

预处理出每个数字的另一个的对应位置。

判断过程四个指针进行维护。

用一个栈和一个动态数组统计答案。

#### Code

考场代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t , n , l , r , l1 , r1 , a[1000010] , ton1[1000010] , ton[1000010] , vis[1000010];
//pair<int , int> l[500010];
stack<int> q;
vector<int> q1;

int read()
{
	int asd = 0 , qwe = 1; char zxc;
	while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
	while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
	return asd * qwe;
}

int dfs(int k)
{
//	cout << k << " " << l1 << " " << r1 << " " << l << " " << r << " " << q.size() << endl;
	if(k == n / 2)
	{
		for(int i = 0;i <= n / 2 - 1;i++)
		{
			if(q1[i] == 1) cout << "L";
			else cout << "R";
		}
		while(q.empty() == 0)
		{
			int x = q.top(); q.pop();
			if(a[l] == x) cout << "L" , l++;
			else cout << "R" , r--;
		}
		cout << endl;
		return 1;
	}
	else
	{
//		cout << ton[l1 + 1] << l - 1 << ton[l1 + 1] << r + 1 << endl;
		if(vis[a[l1 + 1]] == 0 && (ton[l1 + 1] == l - 1 || ton[l1 + 1] == r + 1))
		{
			l1++;
			if(ton[l1] == l - 1) l--;
			else r++;
			q1.push_back(1);
			q.push(a[l1]);
			vis[a[l1]] = 1;
			return dfs(k + 1);
		}
		else if(vis[a[r1 - 1]] == 0 && (ton[r1 - 1] == l - 1 || ton[r1 - 1] == r + 1))
		{
			r1--;
			if(a[ton[r1]] == a[l - 1]) l--;
			else r++;
			q1.push_back(2);
			q.push(a[r1]);
			vis[a[r1]] = 1;
			return dfs(k + 1);
		}
		else return 0;
	}
}

int main()
{
//	freopen("palin.in" , "r" , stdin);
//	freopen("palin.out" , "w" , stdout);
	t = read();
	while(t--)
	{
		n = read() * 2 , l1 = 0 , r1 = n + 1;
		while(q.empty() == 0) q.pop(); q1.clear();
		for(int i = 1;i <= n;i++) vis[i] = ton1[i] = ton[i] = 0;
		for(int i = 1;i <= n;i++) 
		{
			a[i] = read();
			if(ton1[a[i]]) ton[i] = ton1[a[i]] , ton[ton1[a[i]]] = i;
			else ton1[a[i]] = i;
		}
		vis[a[++l1]] = 1 , l = r = ton[l1] , q1.push_back(1) , q.push(a[l1]);
		if(dfs(1) == 0)
		{
			for(int i = 1;i <= n;i++) vis[i] = 0;
			q1.clear() , l1 = 0 , r1 = n + 1;
			while(q.empty() == 0) q.pop();
			vis[a[--r1]] = 1 , l = r = ton[r1] , q1.push_back(2) , q.push(a[r1]);
			if(dfs(1) == 0) cout << -1 << endl;
		}
	}
	return 0;
}
```

---

## 作者：HohleFeuerwerke (赞：3)

[引流](https://www.cnblogs.com/AllWeKnow/p/15487176.html)。

## 题目大意

给定一个 $2*n$ 个数字的序列，每个数字都在 $\{1,2,3,...,n\}$ 内，并且出现且仅出现两次。

求一个操作序列，使得其满足按序取出的数字序列为回文序列。操作分为两种：
1. `L`：将原序列左端点处的数取出加入新序列尾部，并将原序列左端点处的数删除。
2. `R`：将原序列右端点处的数取出加入新序列尾部，并将原序列右端点处的数删除。

多测，数据组数 $T\leq 100$，$1\leq n,\sum n \leq 2\times 10^5$。

## 分析

以下对于所有操作/指针，只需要分析左边，右边完全对称。

首先必然考虑第一次操作。无论如何操作，我们都能找到与第一次取出的数 $x$（$x$ 必然在左端点和右端点中取一个） 相同的数。我们不妨假设我们在下标 $i$ 出找到了另外一个 $x$。

手玩下样例：
```
5
4 1 2 4 5 3 1 2 3 5
```
这里我们第一次取出的是左端点，那么我们找到与左端点相同的那个数 $4$，它的下标正好也在第 $4$ 位。

并且，正因为我们第一次取出的是 $4$，因此我们显然必须将内部第 $i$ 位的那个 $4$ 放在最后一位取出。

与此同时，我们得到了把这两个 $4$ 给搞定的操作：
- 由于从左端点取出了一个 $4$，那么第一步操作为 `L`。
- 由于最终的这个 $4$ 无论如何都是在只有一个元素的序列中取出的，那么答案无论怎么变都是 `L`。

搞定了这两个 $4$ 我们接着来看剩下的序列。

```
(4) 1 2 (4) 5 3 1 2 3 5
```

由于每次只能取剩下的左端点和右端点，所以这里只能取 $1$ 和 $5$ 中间的一个。

我们发现这里另外 $1$ 根本不在中间那个 $4$ 的左右，而如果这一步取 $1$，那么倒数第二步必然得取 $1$，那么最后几步将无法操作。

考虑取一下 $5$，我们发现 $5$ 在 $4$ 旁边，那么这一步取 $5$ 就是非常合法的，（至少对于现在已经处理的前两步和倒数两步而言）。

这里我们来思考一下这两个 $5$ 是由什么样的操作得到的：
- 由于从右端点取出了一个 $5$，那么第二步操作为 `R`。
- 由于从 $4$ 的右边取出了另外一个 $5$，考虑最终剩下来应该长成什么样，大概是：`4 5` 这样，那么倒数第二步也应该是 `R`。

这时候应该找到一些规律了。但我们接着把这个样例讲完，剩下：

```
(4) 1 2 (4 5) 3 1 2 3 (5)
```

发现右端有一个 $3$，$5$ 右边有一个 $3$，那么把这两个 $3$ 给取出来。这两步应该都是 `R`。

```
(4) 1 2 (4 5 3) 1 2 (3 5)
```

左端点和 $3$ 的右边都是 $1$，因此都取出来，这两步应该一个是 `L`，一个是 `R`。

```
(4 1) 2 (4 5 3 1) 2 (3 5)
```

这个时候取两个 `L` 就行。

---

观察上面的手模过程，我们发现：
1. 每一步可以确定两个位置及其操作。
2. 从第二步开始，每个数必然只能从内部已经取过的数的两边来扩展。

形象地来说，内部已经取过的数字可以构成一根“线段”。

由于第一步无法确定从左开始取还是从右开始取，分类讨论即可。

这两个性质无论对于第一步为 `L` 还是对于第一步为 `R` 都是成立的。通过这两个性质我们可以 $O(1)$ 的计算出一个序列下一步的操作。

**另外，如果一个序列在经过若干次扩展后无法继续扩展，那么无解，因为优先扩展左边和右边对于其余部分无影响，如果能够扩展就一定会在某一时刻进行扩展。**

---

具体实现呢？

首先，对于第一步分类讨论，找到左端点或右端点所对应的内部点（最后一个被取出来的位置），打上标记。我们不妨称其为 $\operatorname{inner}$。

接下来我们同时维护四根指针：
- $\operatorname{outl}$ 和 $\operatorname{outr}$，负责维护在执行完前继操作后两端端点在原序列中的位置。
- $\operatorname{inl}$ 和 $\operatorname{inr}$，负责维护在执行完前继操作后内部已操作线段的两端端点在原序列中的位置。

在执行完每一步操作后对这四根指针进行更新。我们优先进行 $\operatorname{outl}$ 对于 $\operatorname{inl}$ 和 $\operatorname{inr}$ 的匹配，原因是输出字典序最小的。

注意如果在某一时刻 $\operatorname{inl}\leq\operatorname{outl}$，那么不能继续扩展，否则会将已经扩展过的部分再反向扩展一遍。

## 代码

```cpp
#include <bits/stdc++.h>
#define HohleFeuerwerke using namespace std
#define int long long
HohleFeuerwerke;
inline int read() {
    int s = 0, f = 1;
    char c = getchar();

    for (; !isdigit(c); c = getchar())
        if (c == '-')
            f = -1;

    for (; isdigit(c); c = getchar())
        s = s * 10 + c - '0';

    return s * f;
}
inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;

    if (x >= 10)
        write(x / 10);

    putchar('0' + x % 10);
}
const int MAXN = 1e6 + 5;
int T, n;
int a[MAXN], ans[MAXN];
inline void solve() {
    char Ans[MAXN];
    memset(Ans, 0, sizeof(Ans));
    int cnt = 0;
    memset(ans, 0, sizeof(ans));
    int inner = 0;
    int outl = 1, outr = 2 * n;

    for (int i = 2; i <= 2 * n; i++) {
        if (a[i] == a[1]) {
            inner = i;
            break;
        }
    }

    int inl = inner, inr = inner;

    for (int i = 1; i <= n; i++) {
        if (a[inl] == a[outl] && inl > outl) {
            if (inl == inr)
                inl--, inr++, outl++;
            else
                inl--, outl++;

            ans[++cnt] = a[inl + 1];
            ans[2 * n - cnt + 1] = a[inl + 1];
            Ans[cnt] = 'L', Ans[2 * n - cnt + 1] = 'L';
        } else if (a[inr] == a[outl] && inr != outl) {
            if (inl == inr)
                inl--, inr++, outl++;
            else
                inr++, outl++;

            ans[++cnt] = a[inr - 1];
            ans[2 * n - cnt + 1] = a[inr - 1];
            Ans[cnt] = 'L', Ans[2 * n - cnt + 1] = 'R';
        } else if (a[inl] == a[outr] && inl != outr) {
            inl--;
            outr--;
            ans[++cnt] = a[inl + 1];
            ans[2 * n - cnt + 1] = a[inl + 1];
            Ans[cnt] = 'R', Ans[2 * n - cnt + 1] = 'L';
        } else if (a[inr] == a[outr] && inr < outr) {
            inr++;
            outr--;
            ans[++cnt] = a[inr - 1];
            ans[2 * n - cnt + 1] = a[inr - 1];
            Ans[cnt] = 'R', Ans[2 * n - cnt + 1] = 'R';
        } else
            goto End;
    }

    printf("%s\n", Ans + 1);
    return;
End:
    ;
    cnt = 0;
    memset(ans, 0, sizeof(ans));
    memset(Ans, 0, sizeof(Ans));
    inner = 0;
    outl = 1, outr = 2 * n;

    for (int i = 2; i <= 2 * n; i++) {
        if (a[i] == a[2 * n]) {
            inner = i;
            break;
        }
    }

    inl = inner, inr = inner;

    for (int i = 1; i <= n; i++) {
        if (a[inl] == a[outl] && inl > outl) {
            inl--, outl++;
            ans[++cnt] = a[inl + 1];
            ans[2 * n - cnt + 1] = a[inl + 1];
            Ans[cnt] = 'L', Ans[2 * n - cnt + 1] = 'L';
        } else if (a[inr] == a[outl] && inr != outl) {
            inr++, outl++;
            ans[++cnt] = a[inr - 1];
            ans[2 * n - cnt + 1] = a[inr - 1];
            Ans[cnt] = 'L', Ans[2 * n - cnt + 1] = 'R';
        } else if (a[inl] == a[outr] && inl != outr) {
            if (inl == inr)
                inl--, inr++, outr--;
            else
                inl--, outr--;

            ans[++cnt] = a[inl + 1];
            ans[2 * n - cnt + 1] = a[inl + 1];
            Ans[cnt] = 'R', Ans[2 * n - cnt + 1] = 'L';
        } else if (a[inr] == a[outr] && inr < outr) {
            if (inl == inr)
                inl--, inr++, outr--;
            else
                inr++, outr--;

            ans[++cnt] = a[inr - 1];
            ans[2 * n - cnt + 1] = a[inr - 1];
            Ans[cnt] = 'R', Ans[2 * n - cnt + 1] = 'R';
        } else {
            puts("-1");
            return;
        }
    }

    printf("%s\n", Ans + 1);
}
signed main() {
    freopen("palin.in", "r", stdin);
    freopen("palin.out", "w", stdout);
    T = read();

    while (T--) {
        n = read();

        for (int i = 1; i <= 2 * n; i++)
            a[i] = read();

        solve();
    }
}
```


---

## 作者：约瑟夫用脑玩 (赞：3)

听说有四指针却不是线性的搜索算法，大受震撼，都想到四指针了还做不对是真的离大谱。

为了方便，假设给定序列为 $p$，构造序列为 $q$

先枚举第一个操作是 `L` 还是 `R`，这样我们就可以知道最后一个数在 $p$ 序列的哪个位置。

设为 $x$，发现倒数第二个数必定在 $x-1/x+1$。

否则，设倒数第二个数在 $y,|x-y|>1$，那么 $x,y$ 中间存在数并且应该在倒数第二个和最后一个之间出去，显然矛盾。

若倒数第二个在 $z=y-1$，那么倒数第三个数必在 $z-1=y-2/y+1$，反之或推广都同理。

于是我们可以轻易的设计一个算法来解决这个问题了，先用两个指针 $a,b$ 表示正向操作到 $p$ 序列的外侧哪里了，再用两个指针 $c,d$ 表示逆向操作到 $p$ 序列内侧的哪里了。

暂不考虑 $a>c$ 或是 $d>b$，即指针已经越过另一个指针的情况。

设当前考虑正向考虑到第 $i$ 个操作，逆序考虑到倒数第 $i$ 个操作，若 $p_a=p_c\land p_b\neq p_d$，那么我们直接将 $a\to a+1,c\to c-1$。

那么有一对相同的 $p_a=p_d\land p_b\neq p_c$、$p_a\neq p_c\land p_b=p_d$、$p_a\neq p_d\land p_b=p_c$ 也是同理。

如果是两对都不同的 $p_a\neq p_c\land p_a\neq p_d\land p_b\neq p_c\land p_b\neq p_d$直接返回无解即可。

否则就只剩下两对相同的了，即：$p_a=p_c\land p_b=p_d$、$p_a=p_d\land p_b=p_b$。

这种情况我们肯定先取 `L` 操作让字典序最小，直到取不了就是只有一对或没有相同的了，回到前两步。

以上三步可以用四个判断直接实现，即按照 $p_a=p_c,p_a=p_d,p_b=p_c,p_b=p_d$ 的顺序依次判定，成功则递归下一层然后返回即可。

这样和搜索的区别在于两对相同的只走了其中一对，如果有解即字典序最小，如果无解也不必搜另一边，道理很简单。

举其中一种为例，另一种同理，假设有 $p_a=p_c,p_{a+1}=p_{c-1},p_{a+2}=p_{c-2},\cdots,p_{a'-1}= p_{c'+1},p_{a'}\neq p_{c'}$，对于 $d',b'$ 的定义同理。

我们直接去掉外面的部分，只剩下新的四个指针 $a',b',c',d'$，发现对于有解的判断还是一样的，而去掉过后的状态必定在我们往下递归的必经之路上。

因为我们会挨着将 $a,c\to a',c'$，然后由于 $p_b=p_d,\cdots$，所以直到移到 $b',d'$ 另一边都动弹不得，故正确性并没有问题，总共只用一次 $O(n)$ 的递归即可。

补充说明一下边界条件，若 $a>c\land d>b$ 即可判定有解，否则当 $a>c\lor d>b$ 时都需将另一边继续下去，上面的四个判断也可以实现。

最后在回溯过程中记录即可得出 $q$ 数组，再模拟一下就可以知道操作步骤了。

总复杂度 $O(\sum n)$，是一道很简单的递归模拟实现+贪心的题目。

自认为写的还不错的[代码](https://www.luogu.com.cn/paste/y2v3mio6)

---

## 作者：Piwry (赞：2)

## 解析

首先枚举第一次操作（原因之后会说明）

当我们确定了前 $i$ 次取的位置后，考虑倒过来的操作序列，发现后 $i$ 次取的位置也确定了

显然后缀取的位置也必须是连续的。这相当于说：每当我们取一个数时，都必须保证截止目前取的所有数的另一个位置的序列，为一个连续的子串。于是可以维护这个子串，每次选择操作 `L` 还是 `R` 时，必须保证取的数的另一个位置和子串是相邻的，才合法

但注意到有时 `L`, `R` 均合法。我们断定，此时取 `L` 一定是最优的：即若给出的序列（在枚举第一次操作后）存在解，那么此时取 `L` 也一定能找到解

考虑证明这是对的，即需要证明此时选 `R` 能找到解但选 `L` 不能找到解的情况不存在。注意到，当 `L` 可选时，刚才提到的维护的子串一定已经和 `L` 对应的数相邻，且无论怎么选 `R` 都不会影响这个事实（或者说，**可以注意到 `L`、`R` 的可选性互不干扰**，即选择 `L`/`R` 后不会影响 `R`/`L` 的可选性）；这意味着，从当前时刻开始，`L` 总是可选的。因此，从当前时刻之后（含当前时刻选择），若有合法操作序列 `RRR..X..L..Y`，那么把第一个 `L` 移到最前面得到的操作序列 `LRRR..X..Y` 显然也一定是合法的，由此证毕

接着我们就能注意到第一次操作的特殊之处了：由于第一次操作前维护的子串还完全不存在，于是选择 `R`/`L` 之后并不能保证 `L`/`R` 一直可选，因此第一次操作必须枚举

## CODE

```cpp
#include <cstdio>
#include <cstring>

namespace IO_base{
	const int MAXB =1<<10;
	char gbuf[MAXB], *ps =gbuf, *pt =gbuf;
	char pbuf[MAXB+1], *pp =pbuf;
	struct Flusher{
		~Flusher(){
			fwrite(pbuf, 1, pp-pbuf, stdout);
		}
	}flusher;
	
	inline char Getchar(){
		if(ps == pt){
			ps =gbuf;
			pt =gbuf+fread(gbuf, 1, MAXB, stdin);
		}
		return (ps == pt) ? EOF : *ps++;
	}
	inline void Putchar(const char &ch){
		if(pp == pbuf+MAXB){
			pp =pbuf;
			fwrite(pbuf, 1, MAXB, stdout);
		}
		*pp++ =ch;
	}
}
#define getchar IO_base::Getchar
#define putchar IO_base::Putchar

namespace IO_number{
	int read(){
		int x =0; char c =getchar(); bool f =0;
		while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
		while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
		return (f) ? -x : x;
	}
	
	void write(const int &x){
		if(x < 0){
			putchar('-');
			write(-x);
		}
		else{
			if(x/10)
				write(x/10);
			putchar('0'+x%10);
		}
	}
}
using namespace IO_number;

const int MAXN =5e5+20;

int a[MAXN<<1], pos[MAXN<<1], lst[MAXN<<1];
char ans[MAXN<<1];

int main(){
	freopen("palin.in", "r", stdin);
	freopen("palin.out", "w", stdout);
	
	memset(lst, -1, sizeof(lst));
	for(int _t =0, T =read(); _t < T; ++_t){
		const int n =read();
		for(int i =0; i < 2*n; ++i){
			a[i] =read();
			if(lst[a[i]] == -1)
				lst[a[i]] =i;
			else{
				pos[lst[a[i]]] =i;
				pos[i] =lst[a[i]];
				lst[a[i]] =-1;
			}
		}
		
		for(int __t =0, tot, l1, r1, l2, r2; __t < 2; ++__t){
			if(__t == 0){
				tot =0, l1 =1, r1 =2*n-1, l2 =pos[0], r2 =pos[0];
				ans[0] ='L', ans[2*n-1] ='L', tot =1;
			}
			else{
				tot =0, l1 =0, r1 =2*n-2, l2 =pos[2*n-1], r2 =pos[2*n-1];
				ans[0] ='R', ans[2*n-1] ='L', tot =1;
			}
			
			auto check =[&](const int &_pos, const int &val, const int &qaq){
				return (_pos >= l1 && _pos <= r1 && _pos != qaq && a[_pos] == val);
			};
			for(int i =1; i < n; ++i){
				if(check(l2-1, a[l1], l1))
					ans[tot] ='L', ans[2*n-1-tot] ='L', ++tot, ++l1, --l2;
				else if(check(r2+1, a[l1], l1))
					ans[tot] ='L', ans[2*n-1-tot] ='R', ++tot, ++l1, ++r2;
				else if(check(l2-1, a[r1], r1))
					ans[tot] ='R', ans[2*n-1-tot] ='L', ++tot, --r1, --l2;
				else if(check(r2+1, a[r1], r1))
					ans[tot] ='R', ans[2*n-1-tot] ='R', ++tot, --r1, ++r2;
				else
					break;
			}
			if(tot == n){
				for(int i =0; i < 2*n; ++i)
					putchar(ans[i]);
				break;
			}
			else if(__t == 1)
				putchar('-'), putchar('1');
		}
		putchar('\n');
	}
}
```

---

## 作者：Demoe (赞：2)

[$\large\text{题目传送门}$](https://www.luogu.com.cn/problem/P7915)

## $\text{Description}$

- 给定序列 $a_1\sim a_{2n}$，满足所有 $1\sim n$ 的数字恰好出现两次。
- 每次你有两种操作：
	- 将 $a$ 队首元素扔到 $b$ 队尾，操作记为 $\texttt{L}$。
    - 将 $a$ 队尾元素扔到 $b$ 队尾，操作记为 $\texttt{R}$。
- 你要使得 $b$ 最终为回文串。输出字典序最小的操作序列（即 $\texttt{LLRLRLRL} $ 类似的东西），或无解输出 $-1$。

## $\text{Solution}$

有一个显然的结论：对于前 $n$ 个删除的序列 $p_1\sim p_n$，有对于剩下的 $n$ 个数满足对于 $p$ 的任意长前缀都在其中为一段区间，此为**充要条件**。（手模一下样例就能发现。）

考虑到第一个删的一定是 $a_1$ 或 $a_{2n}$，那么我们枚举一下，然后就有了那段区间的雏形。

然后由于是充要条件，只要贪心能删左边就删掉就行了，不能删的时候看看右边能不能删就行了，同时拓展区间。

最后把剩下 $n$ 个的删除序列整一下就好了。

## $\text{Code}$

考场代码不忍直视的丑。

```cpp
const int N=5e5+5;
int T,n,l[N],r[N],ans[N<<1],a[N<<1],tag[N<<1],f[N<<1];

// ---------- IO ---------- //

int main(){
	rd(T);
	while(T--){
		rd(n);
		for(re i=1;i<=n;++i) l[i]=r[i]=0;
		for(re i=1;i<=n*2;++i){
			rd(a[i]);
			if(!l[a[i]]) l[a[i]]=i;
			else r[a[i]]=i;
		}
		int L=2,R=n*2,cnt=1,LL,RR;ans[1]=0;
		LL=RR=r[a[1]];
		while(cnt<n){
			bool fl=0;
			while(L<LL&&cnt<n&&r[a[L]]!=L){
				bool ok=0;
				if(r[a[L]]==LL-1) --LL,++L,ok=fl=1,ans[++cnt]=0;//,cout<<L<<' '<<R<<" L"<<endl;
				else if(r[a[L]]==RR+1) ++RR,++L,ok=fl=1,ans[++cnt]=0;//,cout<<L<<' '<<R<<" L"<<endl;
				if(!ok) break;
			}
			if(cnt==n) break;
			if(l[a[R]]==LL-1) --LL,--R,fl=1,ans[++cnt]=1;//,cout<<L<<' '<<R<<" R"<<endl;
			else if(l[a[R]]==RR+1) ++RR,--R,fl=1,ans[++cnt]=1;//,cout<<L<<' '<<R<<" R"<<endl;
			if(!fl){cnt=-1;break;}
		}
		if(cnt==-1){
			ans[1]=1;L=1,R=n*2-1;cnt=1;
			LL=RR=l[a[n*2]];
			while(cnt<n){
				bool fl=0;
				while(L<LL&&cnt<n&&r[a[L]]!=L){
					bool ok=0;
					if(r[a[L]]==LL-1) --LL,++L,ok=fl=1,ans[++cnt]=0;//,cout<<L<<' '<<R<<" L"<<endl;
					else if(r[a[L]]==RR+1) ++RR,++L,ok=fl=1,ans[++cnt]=0;//,cout<<L<<' '<<R<<" L"<<endl;
					if(!ok) break;
				}
				if(cnt==n) break;
				if(l[a[R]]==LL-1) --LL,--R,fl=1,ans[++cnt]=1;//,cout<<L<<' '<<R<<" R"<<endl;
				else if(l[a[R]]==RR+1) ++RR,--R,fl=1,ans[++cnt]=1;//,cout<<L<<' '<<R<<" R"<<endl;
				if(!fl){cnt=-1;break;}
			}
			if(cnt==-1){puts("-1");continue;}
		}
		L=1;R=n*2;
		for(re i=1;i<=n;++i){
			if(ans[i]) f[i]=f[2*n+1-i]=a[R--];
			else f[i]=f[2*n+1-i]=a[L++];
		}
		L=1;R=n*2;
		for(re i=1;i<=n;++i){
			if(ans[i]) putchar('R'),--R;
			else putchar('L'),++L;
		}
		for(re i=n+1;i<=n*2;++i){
			if(a[L]==f[i]) putchar('L'),++L;
			else putchar('R'),--R;
		}
		puts("");
	}
	return 0;
}

// ---------- Main ---------- //
```

---

## 作者：Prean (赞：2)

奇怪的乱搞做法（？

首先我们枚举序列的每一个位置，从这个位置劈开，假设这个位置是 $ i $，那么按照题意模拟，我们能够构造一个最终序列有 $ i $ 个 L 和 $ n-i $ 个 R 的符合题意的序列。

于是我们枚举所有位置，这样就有了 $ O(n^2) $ 暴力，能够在考场上拿到 65pts，性价比相当高。

然后思考正解。

我们对着样例输出可行的位置，发现这个位置的值和整个序列的第一个值一样。于是我们找到这个位置来做这个暴力，能够在洛谷数据获得 92 分的高分。

再思考一下，我们应该还要找一个位置，并且这个位置的值和整个序列的最后一个位置的值相同。

然后这题就被草过去了。。。

如果有老哥知道正确性的在麻烦评论区补充一下（
```cpp
#include<algorithm>
#include<cstdio>
typedef unsigned ui;
const int M=1e6+5,mod=1e9+7;
int n,T,a[M];ui p[M],ip[M],hash[M];
ui l[M],r[M];int top,stk[M];char ans[M],s[M];bool f,vis[M];
int L,R;
inline ui Hash(const int&L,const int&R){
	return 1ull*(hash[R]-hash[L]+mod)*ip[L]%mod;
}
inline bool check(const int&L,const int&R){
	int i,h1(0),h2(0),tp;
	for(tp=0,i=L;i<=R;++i)if(!vis[i])h1=(h1+1ull*a[i]*p[++tp])%mod;
	for(tp=0,i=R;i>=L;--i)if(!vis[i])h2=(h2+1ull*a[i]*p[++tp])%mod;
	return h1==h2;
}
inline void end(){
	if(f){
		for(int i=1;i<=n;++i){
			if(s[i]<ans[i]){
				for(i=1;i<=n;++i)ans[i]=s[i];
			}
			if(s[i]>ans[i])break;
		}
	}
	else{
		f=true;for(int i=1;i<=n;++i)ans[i]=s[i];
	}
}
inline bool todo(int L1,int R1,int L2,int R2){
	if(Hash(L1,R1)==Hash(L2,R2)){
		R1-=L1-1;while(R1--)s[++L]='L';
		R2-=L2-1;while(R2--)s[R--]='R';
		return end(),true;
	}
	return false;
}
inline void make(int L1,int R1,int L2,int R2){
	int i,pL1,pR1,pL2,pR2;L=0;R=n;
	while(true){
		pL1=L1;pR1=R1;pL2=L2;pR2=R2;if(todo(L1,R1,L2,R2))return end();
		for(i=1;L1+i-1<=R1&&L1+i-1<R1-i+1;++i)if(a[L1+i-1]^a[R1-i+1])break;
		if(i^1){
			while(--i)s[++L]='L',s[R--]='L',++L1,--R1;if(todo(L1,R1,L2,R2))return end();
			if(R1+1==L1&&R2+1==L2)return end();continue;
		}
		for(i=1;L1+i-1<=R1&&L2+i-1<=R2&&L1;++i)if(a[L1+i-1]^a[L2+i-1])break;
		if(i^1){
			while(--i)s[++L]='L',s[R--]='R',++L1,++L2;if(todo(L1,R1,L2,R2))return end();
			if(R1+1==L1&&R2+1==L2)return end();continue;
		}
		for(i=1;L2+i-1<=R2&&L2+i-1<R2-i+1;++i)if(a[L2+i-1]^a[R2-i+1])break;
		if(i^1){
			while(--i)s[++L]='R',s[R--]='R',++L2,--R2;if(todo(L1,R1,L2,R2))return end();
			if(R1+1==L1&&R2+1==L2)return end();continue;
		}
		for(i=1;L1+i-1<=R1&&L2+i-1<=R2;++i)if(a[R1-i+1]^a[R2-i+1])break;
		if(i^1){
			while(--i)s[++L]='R',s[R--]='L',--R1,--R2;if(todo(L1,R1,L2,R2))return end();
			if(R1+1==L1&&R2+1==L2)return end();continue;
		}
		if(L1==pL1&&R1==pR1&&L2==pL2&&R2==pR2)return;
	}
}
signed main(){
//	freopen("palin.in","r",stdin);
//	freopen("palin.out","w",stdout);
	int i;scanf("%d",&T);p[0]=ip[0]=1;p[1]=13331;ip[1]=133822550;
	for(i=2;i<=500000;++i)p[i]=13331ull*p[i-1]%mod,ip[i]=133822550ull*ip[i-1]%mod;
	while(T--){
		scanf("%d",&n);n<<=1;f=false;
		for(i=1;i<=n;++i)scanf("%d",a+i);
		for(i=1;i<=n;++i)hash[i]=(hash[i-1]+1ull*p[i]*a[i])%mod;
		for(i=2;i<=n;++i)if(a[i]==a[1])break;
		for(int j=-1;j<=1;++j)if(i+j>=1&&i+j<=n)make(1,i+j,i+j+1,n);
		for(i=1;i<=n-1;++i)if(a[i]==a[n])break;
		for(int j=-1;j<=1;++j)if(i+j>=1&&i+j<=n)make(1,i+j,i+j+1,n);
		ans[n]='L';
		if(!f)printf("-1\n");
		else{
			for(i=1;i<=n;++i)printf("%c",ans[i]);printf("\n");
		}
	}
}
```

---


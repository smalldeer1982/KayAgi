# [COCI 2007/2008 #5] BARICA

## 题目描述

Barica 是一只非同寻常的青蛙。她住在一个池塘里，有 $N$ 片漂浮在水面上的荷叶。这些荷叶的编号为 $1$ 到 $N$，位置可以用一对坐标表示。Barica 可以在这些荷叶上跳来跳去，但是她害怕斜着跳和朝负方向跳。

准确的说，她可以从坐标 $(x_1,y_1)$ 跳到另一个坐标 $(x_2,y_2)$ 仅当：

- $x_2>x_1$ 且 $y_2=y_1$ 或者

- $y_2>y_1$ 且 $x_2=x_1$。

对于每一片荷叶，我们知道其附近的苍蝇数量。Barika 可以吃掉所有在她荷叶附近的苍蝇。

Barica 每吃一只苍蝇会获得 $1$ 个单位的能量，每进行一次跳跃消耗 $K$ 个单位的能量。如果 Barica 没有足够的能量，她就不能进行跳跃。

Barica 想通过 $1$ 号植物到达 $N$ 号植物，并获得尽可能多的能量。Barica 开始时没有能量，必须通过吃掉 $1$ 号植物附近的苍蝇来获取能量。

找到使得 Barica 达到目标的一种可行路径。

## 说明/提示

对于 $100\%$ 的数据，$2\le N\le 3\times 10^5$，$1\le K\le 1000$，$0\le x_i,y_i\le 10^5$，$0\le z_i\le 1000$。

输入数据保证有解，但不保证有唯一解。

本题分值按照原比赛设置，满分 $70$ 分。

## 样例 #1

### 输入

```
6 5
1 1 5
2 1 5
1 2 4
2 3 5
3 2 30
3 3 5 ```

### 输出

```
5
4
1 1
2 1
2 3
3 3 ```

## 样例 #2

### 输入

```
8 10
1 1 15
2 2 30
1 2 8
2 1 7
3 2 8
2 3 7
4 2 100
3 3 15```

### 输出

```
36
5
1 1
1 2
2 2
3 2
3 3```

## 样例 #3

### 输入

```
9 5
5 5 10
6 5 2
7 5 1
5 6 2
6 6 6
7 6 2
5 7 1
6 7 2
7 7 1 ```

### 输出

```
2
3
5 5
7 5
7 7 ```

# 题解

## 作者：_edge_ (赞：6)

这题目其实一看就应该知道是一个比较基本的 DP 模型。

我们先考虑不存在 "如果 Barica 没有足够的能量，她就不能进行跳跃。" 的条件下。

这种情况下，我们发现这个 Barica 只能是向下或者向右走。

然后我们又发现这个 $n$ 比较大，坐标不可能一个一个枚举过去。

由此明白，复杂度大概是依赖于 $n$ 的，并且状态大概是 $f_i$ 表示当前到达这个坐标所有的能量的最大。

往这边去向，发现对于那两个限制条件，只需要取一个前缀最小值就可以了。

当然我们要对初始的数组进行坐标下的排序。

然后我们再来考虑 "如果 Barica 没有足够的能量，她就不能进行跳跃。" 。

想到这里其实可以在每一个转移下都特判一下是否大于等于 $K$。

于是这样就写掉了。

这边要稍微注意一下细节。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF=3e5+5;
struct _node_data {
        int x,y,z,id;
} aa[INF];
int n,k,f[INF],fx[INF][2],fy[INF][2],f1[INF],tot,ans[INF][5];
bool cmp(_node_data xx,_node_data yy) {
        if (xx.x!=yy.x) return xx.x<yy.x;
        else return xx.y<yy.y;
}
void updata(int x,int y,int z,int p) {
        if (fx[x][0]<p)
                fx[x][0]=p,fx[x][1]=z;
        if (fy[y][0]<p)
                fy[y][0]=p,fy[y][1]=z;
        return;
}
void print(int x) {
        if (!x) return;
        print(f1[x]);
        tot++;
        ans[tot][0]=aa[x].x;
        ans[tot][1]=aa[x].y;
        return;
}
signed main()
{
        memset(fx,-63,sizeof fx);
        memset(fy,-63,sizeof fy);
        scanf("%d %d",&n,&k);
        for (int i=1; i<=n; i++) {
                scanf("%d %d %d",&aa[i].x,&aa[i].y,&aa[i].z);
                aa[i].z-=k; aa[i].id=i;
        }
        sort(aa+1,aa+1+n,cmp);
        int ii=0;
        for (int i=1; i<=n; i++)
                if (aa[i].id==1)
                        f[i]=aa[i].z+k,
                        fx[aa[i].x][0]=aa[i].z+k,
                        fy[aa[i].y][0]=aa[i].z+k,
                        fx[aa[i].x][1]=i,
                        fy[aa[i].y][1]=i,ii=i;
        for (int i=ii+1; i<=n; i++) {
                int xx=fx[aa[i].x][0],yy=fx[aa[i].x][1];
                if (xx<fy[aa[i].y][0])
                        xx=fy[aa[i].y][0],yy=fy[aa[i].y][1];
                f1[i]=yy;
                if (xx<k) {f[i]=-1e9; continue;}
                f[i]=xx+aa[i].z;
                updata(aa[i].x,aa[i].y,i,f[i]);
        }
        int fl=0;
        // cout<<f[5]<<"\n";
        for (int i=1; i<=n; i++)
                if (aa[i].id==n && f[i]>0) {
                        cout<<f[i]<<"\n";
                        print(i); fl=1;
                }
        // if (!fl) cout<<"-1000000000\n";
        cout<<tot<<"\n";
        for (int i=1; i<=tot; i++)
                cout<<ans[i][0]<<" "<<ans[i][1]<<"\n";
        return 0;
}

```

如果有问题，还请指出。

---

## 作者：helium347 (赞：3)

# 线性dp && 维护前缀和



------------

## 题意
- 告诉你 $n$ 个点的点权、坐标。
- 你可以从 $(x,y)$ 移动到 $(x + i, y)$ 或 $(x, y + i)$ , $i$ > 0。
- 每次移动到另一个点需要消耗 $k$ 点能量。
- 移动后可以补充该点点权的能量。

求从点 $1$ 到点 $n$ 的一条路径，并打印路径。



------------

## 思路
1. 线性dp
	- 无后效性：每次移动，横纵坐标只会变大或不变。
	- 最优子结构： 显然。

1. 前缀和
	- $ n < 10 ^ 5$，所以 $n^2$ 枚举超时。

1. 排序
	- 保证dp顺序。
	- 维护前缀和。

## 实现
- $f[i]$ : 移动到节点 $i$ 的最大剩余能量。
- $pre[i]$ : 最优解的情况下，节点 $i$ 的前驱。
- $prex[i]$ : 当前状态下，第 $i$ 行的前缀中，使 $f[i]$ 最大的下标。
- $prey[i]$ : 当前状态下，第 $i$ 列的前缀中，使 $f[i]$ 最大的下标。

于是有：
## $f[i] = max(f[j] - cost + w[i])$

## 代码

```cpp
// https://www.luogu.com.cn/problem/P7936
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
using ll = long long;
const int inf = 0x3f3f3f3f;
#define rf(i, n) for (int i = 1; i <= (n); ++i)
int rad(); // read int
const int max_size = 5 + 1e5;
const int maxn = 5 + 3e5;

int n, cost;
struct Pos {
    int x, y, w, id;
    bool operator<(const Pos &other) const {
        if (x != other.x) return x < other.x;
        return y < other.y;
    }
} pos[maxn];

int pre[maxn];              // pre[i]: 到达 node i  的最优解的前一步
int f[maxn];                // 到达节点 i 所剩能量的最大值
int prex[maxn], prey[maxn]; //
// f[i] = max(f[j] - cost + w[i]), j to i

void show(int now, int dep = 0) {
    if (now == 0) {
        printf("%d\n", dep);
        return;
    };
    show(pre[now], dep + 1);
    printf("%d %d\n", pos[now].x, pos[now].y);
}

void update(int now, int from) {
    if (from == 0 || f[from] < cost) return;
    if (f[now] < f[from] - cost + pos[now].w) {
        f[now] = f[from] - cost + pos[now].w;
        pre[now] = from;
    }
}

int main() {
    n = rad(), cost = rad();
    rf(i, n) {
        pos[i].x = rad(), pos[i].y = rad(), pos[i].w = rad();
        pos[i].id = i;
    }
    sort(pos + 1, pos + 1 + n);
    int start = 1, finish = 1; // 找到起点，终点
    while (pos[start].id != 1)
        start++;
    while (pos[finish].id != n)
        finish++;

    f[start] = pos[start].w, prex[pos[start].x] = start, prey[pos[start].y] = start;
    for (int i = start + 1; i <= finish; ++i) {
        update(i, prex[pos[i].x]);
        update(i, prey[pos[i].y]);
        if (f[i] > f[prex[pos[i].x]]) prex[pos[i].x] = i;
        if (f[i] > f[prey[pos[i].y]]) prey[pos[i].y] = i;
    }
    printf("%d\n", f[finish]);
    show(finish);
}

int rad() {
    int back = 0, ch = 0, neg = 0;
    for (; ch < '0' || ch > '9'; ch = getchar())
        neg = ch == '-';
    for (; ch >= '0' && ch <= '9'; ch = getchar())
        back = (back << 1) + (back << 3) + (ch & 0xf);
    return (back ^ -neg) + neg;
}
```








---

## 作者：sjr3065335594 (赞：1)

## 题意简述

有 $n$ 个点，每次能从一个点走到同一行或者同一列的点，花费为 $k$，且能获得该点的权值，询问从 $1$ 号点走到 $n$ 号点的权值和最大值以及方案。

## 思路

首先一看就知道要按一定顺序将这些点排序，可以先想想 dp 状态再思考一下如何排序可以方便转移。

令 $f_i$ 表示跳到第 $i$ 个叶子时所能得到的权值之和最大值。要转移 $f_i$ 肯定是要从这一列和这一行的最大的 $f_j$ 转移过来，于是排序便是先按照横坐标排序，相同则按纵坐标排序，然后在转移的时候维护每一行每一列的最大值，要注意如果转移之后的值为负数是不可行的，即使走到 $n$ 之后可能是正的。

输出方案可以通过记录每个点是由哪个点转移过来的，再递推回去。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp(x,y) make_pair(x,y)
#define CLR(a,x) memset(a,x,sizeof(a))
//#define int long long
//#define int __int128
using namespace std;
const int N=1e6+5;
const int M=1e6+5;
const int INF=2e9+5;
int n,k,f[N],last[N];
struct Node {
	int x,y,z,id;
	bool operator < (const Node &rhs) const {
		if(x==rhs.x)return y<rhs.y;
		return x<rhs.x;
	}
}a[N];
int maxx[N],maxy[N];
struct Ans {
	int x,y;
}ans[N];
void update(int now,int from) {
	if(from==0||f[from]<k)return;
	if(f[now]<f[from]-k+a[now].z) {
		f[now]=f[from]-k+a[now].z;
		last[now]=from;
	}
}
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) {
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	int start=1,end=1;
	while(a[start].id!=1)start++;
	while(a[end].id!=n)end++;
	f[start]=a[start].z;
	maxx[a[start].x]=start;
	maxy[a[start].y]=start;
	for(int i=start+1;i<=end;i++) {
		update(i,maxx[a[i].x]);
		update(i,maxy[a[i].y]);
		if(f[i]>f[maxx[a[i].x]])maxx[a[i].x]=i;
		if(f[i]>f[maxy[a[i].y]])maxy[a[i].y]=i;
	}
	printf("%d\n",f[end]);
	int i=end,tot=0;
	ans[++tot]={a[i].x,a[i].y};
	while(i!=start) {
		ans[++tot]={a[last[i]].x,a[last[i]].y};
		i=last[i];
	}
	printf("%d\n",tot);
	for(int i=tot;i>=1;i--) {
		printf("%d %d\n",ans[i].x,ans[i].y);
	}
	return 0;
}

```


---

## 作者：Cells (赞：0)

## 题外话

我第一眼就是图论建模，不知道我的同学是怎么想到 DP 的做法的。虽然我听了他的讲解以后确实觉得 DP 做就是简单宝宝题，可能是我这几天网络流刷多了吧。

另外这道题的题面已经说了：

> 输入数据保证有解，但不保证有唯一解。

但是数据没有 SPJ，所以我没有过，但是实测在本校 OJ 通过了，所以申请管理加一下 SPJ 的同时，还请各位大佬轻喷。

## 思路

首先我们确定要跑最长路，一般来说最长路有拓扑排序和 SPFA 两种做法，我还是简单说一下，拓朴排序直接将一开始入度就为 $0$ 放到队列里，除起点距离设为 $0$ 外，其他全部设成负无穷。SPFA 更简单，直接边权取负，然后最短路，最后答案再取负。

我写的 SPFA，但你也不要想着卡我，我也用拓朴写过，只是这里 SPFA 更简单，而且我喜欢 SPFA。

根据题意，我们只能在横坐标和纵坐标相同的点之间跑，所以我们对每个横纵坐标记录在这条直线上的所有点，然后就是建模的问题。

如果数据将所有点全部堆到一个横或纵坐标上，$n ^ 2$ 的时间空间毫无疑问炸了，就像这样（编号就是横坐标从小到大，边权为 $-k$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/1yal71z7.png)

那怎么优化，我们考虑像网络流那样建立一些中转点（超级源点），或者你可以看看所驼门王的宝藏这道题，对我有一定启发，我们发现可以这样建图。

![](https://cdn.luogu.com.cn/upload/image_hosting/tqwbz1c1.png)

这样就可以完美解决问题，新建的点数可以控制在 $n$ 个。

代码比较简单，就不放了，最后记得该卡的空间的卡一下，远古 COCI 是这样的。

---

## 作者：_zuoqingyuan (赞：0)

# 题面：
[题目传送门](https://www.luogu.com.cn/problem/P7936)

题目中给出了 $n$ 个点，每个点都有对应的 $x,y,z$；$x,y$ 表示点的坐标，$z$ 表示点的权值。

有一只小青蛙会从点 $1$ 开始跳，一直跳到点 $n$，每次跳动只能**水平向右或水平向上跳**，每跳到一个点当前的能量值都会上升当前点的权值，每次跳动都有一个消耗 $k$，如果当前能量值不到 $k$，就不能进行跳跃。
    
试问从 $1$ 点跳到 $n$ 点的所有路径中是的能量值最大的一条路线，要求输出这条路线的能量总值，经过点的个数以及经过点的坐标（要保持先后顺序）。

# 分析：
看一眼数据范围：$2 \le n \le 3\times10^5$，果断考虑 $O(n)$ 的做法。仔细思考会发现，给出的每一个点可以通过其它点转移的方式来求最大值。想通这些，这道题就变成了一道很水的 dp 题。

**梳理点转移的条件：**

1. 被转移点必须位于当前点的正下方或正左方。
2. 被转移点的最大能量值必须大于 $k$。

我们可以处理点先后的转移顺序，让 $x$ 坐标小的先转移，如果 $x$ 相同就让 $y$ 坐标小的优先。

用 $fx_i$ 表示当前第 $i$ 行最佳的，可进行转移的点的下标，用 $fy_j$ 表示第 $j$ 列最佳的，可进行转移的点的下标，$dp_t$ 表示点 $t$ 到点 $1$ 的最大能量值。则转移方程可以写成这样：
$$dp_t=\max(dp_{fx_i}+w_{fx_i},dp_{fy_j}+w_{fy_j})-k$$

转移完点后，在更新 $fx,fy$ 数组，用 $from$ 数组记录路径即可。最后用递归程序输出。

# Code:
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=3e5+10,M=1e5+10;
struct node{
    int x,y,z,idx;
}a[N];
int n,k,st=1,ed=1,dp[N],fx[M],fy[M],from[N];
bool cmp(node a,node b){
    if(a.x==b.x)return a.y<b.y;
    else return a.x<b.x;
}
void print(int id,int num){
    if(!from[id]){printf("%d\n%d %d\n",num,a[id].x,a[id].y);return;}
    print(from[id],num+1);
    printf("%d %d\n",a[id].x,a[id].y);//应该都能看懂吧
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].z);
        a[i].idx=i;//记录编号
    }
    sort(a+1,a+1+n,cmp);//排序，先后顺序
    while(a[st].idx!=1)st++;//找到第一个点
    while(a[ed].idx!=n)ed++;//找到最后一个点
    dp[st]=a[st].z,fx[a[st].x]=st,fy[a[st].y]=st;//记录最初状态
    for(int i=st+1;i<=ed;i++){//这里舍弃掉了一些无法转移的点，这些点不可能从第一个点转移或转移到最后一个点
        int xx=a[i].x,yy=a[i].y,w=a[i].z,prex=fx[xx],prey=fy[yy];//提取点的信息
        if(prex&&dp[prex]>=k&&dp[prex]+w-k>dp[i])dp[i]=dp[prex]+w-k,from[i]=prex;//从同行的点转移
        if(prey&&dp[prey]>=k&&dp[prey]+w-k>dp[i])dp[i]=dp[prey]+w-k,from[i]=prey;//从同列的点转移
        if(dp[i]>dp[fx[xx]])fx[xx]=i;
        if(dp[i]>dp[fy[yy]])fy[yy]=i;//更新fx,fy
    }
    printf("%d\n",dp[ed]);//输出最大能量值
    print(ed,1);//输出最大路径
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/135863328)

如有错误，请指出。

---


# [COCI 2014/2015 #6] NEO

## 题目描述

一个矩阵 $A$ 是「YF 矩阵」当且仅当满足：

- $r,s>1$
- $A_{1,1}+A_{r,s}\le A_{1,s}+A_{r,1}$

$r,s$ 分别表示矩阵 $A$ 的行数和列数。

此外，如果一个矩阵的每个大小至少为 $2\times2$ 的子矩阵都是「YF 矩阵」，我们就说这个矩阵是「Sept 矩阵」。

给定一个矩阵 $A$，你需要求出 $A$ 的含有最多元素的是「Sept 矩阵」的子矩阵所含的元素数量。

## 说明/提示

#### 样例 3 说明

最大的是「Sept 矩阵」的子矩阵的左上角与右下角坐标分别为 $(3,2),(5,6)$。

#### 数据规模与约定

- 对于 $60\%$ 的数据，有 $R,S\le 350$。
- 对于 $100\%$ 的数据，有 $2\le R,S\le 10^3$，$A_{i,j}\in[-10^6,10^6]$。

#### 说明

按原题配置，满分 140 分。

译自 **[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/)** [Contest #6](https://hsin.hr/coci/archive/2014_2015/contest6_tasks.pdf) Task E _**NEO**_。

## 样例 #1

### 输入

```
3 3
1 4 10
5 2 6
11 1 3```

### 输出

```
9```

## 样例 #2

### 输入

```
3 3
1 3 1
2 1 2
1 1 1```

### 输出

```
4```

## 样例 #3

### 输入

```
5 6
1 1 4 0 3 3
4 4 9 7 11 13
-3 -1 4 2 8 11
1 5 9 5 9 10
4 8 10 5 8 8```

### 输出

```
15```

# 题解

## 作者：114514wxy (赞：2)

解法很简单：先跑出来满足 YF 条件的 $2 \times 2$ 矩阵，把左上角置为 $1$，最后求全为 $1$ 的矩阵的最大值。

来论证两个东西：全为  1  的矩阵为什么是 Sept 矩阵以及怎么求最大值。
------------

那么第一个，我们不妨以一个 $2 \times 3$ 的矩阵入手，这个矩阵的两个子 $2 \times 2$ 矩阵都是 YF 矩阵。那么就有 

 $a_{1,1}+a_{2,2} \le a_{1,2}+a_{2,1}$  和 

 $a_{1,2}+a_{2,3} \le a_{2,2}+a_{1,3}$。

不等式两边同时相加并消去一下，可以得到 

 $a_{1,1}+a_{2,3} ≤ a_{2,1}+a_{1,3}$  

这个就是满足 YF 的 $2 \times 3$ 矩阵了。

同理也可以推广到更大的矩阵。

第一个证毕。

------------
至于第二个，求解本类 $01$ 矩阵中全为 $0 / 1$ 的矩阵的最大面积可以用悬线法。对于一个 $n \times m$ 的 $01$ 矩阵，具体操作如下：

随着枚举到第 $i$ 行的过程，我们可以对于每一列 $j$ 想象一条悬线，从 $(i,j)$ 的位置向上延伸，直到第一个位置（也就是**最靠下的位置**）使得 $ a_{i-x,j}=0$，其中 $x\in[0,i-1]$。**将这条悬线的长记为** $h_j$。接下来，**对于本** $h_j$，分别定义

 $l_j=\text{max}(k) \text{ 其中}k\in[1,j-1]\text{ 且 } h_{k-1}<h_j$ 

以及

 $r_j=\text{min}(k) \text{ 其中}k\in[j+1,m]\text{ 且 } h_{k+1}<h_j$ 


这分别意味着这条悬线可以向左或向右“推广到”的距离。

同时，可以认为 $h_0 = h_{m+1} = 0$。

至于计算过程，以 $l_j$ 数组举例，应当先赋值 $l_j=j$，之后尝试向左推广。不难发现，

若 $h_{l_j-1} \ge h_j $ 

则可以有 $l_j=l_{l_j-1}$ 

这是因为由上面的条件可以知道：**至少一直到** $l_{l_j-1}$ **的位置，对于** $h_k \text{ } k\in[l_{l_j-1},j]$ **都会满足** $h_k \ge h_j$。边界终止条件为 $l_j = 1$。

对于 $r$ 数组的计算同理。

如此，对于一个 $j$，用其上的悬线“推广”出来的矩阵面积就是 $(r_j-l_j+1) \times h_j$。

注意到我们是在缩水过的 $01$ 矩阵上进行的悬线，**最终得出的面积应当是上式两个乘数各自** $+1$ **后的值。**

代码很简单。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;

int n,m,a[N][N],ans;
int h[N],l[N],r[N];
bool cd[N][N];

int main(){
	
	cin>>n>>m;
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
	    scanf("%d",&a[i][j]);
	
	--n,--m;
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
	    cd[i][j]=(a[i][j]+a[i+1][j+1]<=a[i][j+1]+a[i+1][j]);
	
	for(int i=1;i<=n;++i){
	    for(int j=1;j<=m;++j)
	        l[j]=r[j]=j,h[j]=(cd[i][j])?h[j]+1:0;
		
	    for(int j=1;j<=m;++j)
		    while(l[j]!=1&&h[l[j]-1]>=h[j]) l[j]=l[l[j]-1];
	    for(int j=m;j>=1;--j)
		    while(r[j]!=m&&h[r[j]+1]>=h[j]) r[j]=r[r[j]+1];
		
	    for(int j=1;j<=m;++j)
		    ans=max(ans,(r[j]-l[j]+2)*(h[j]+1));
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：编程小贝壳 (赞：1)

[原题](https://www.luogu.com.cn/problem/P7958)

 _前排提示：本题目侧重于证明和提供使用悬线法之前的思路，如要学习悬线法请移步其他题解_ 
 
###  分析

题意很好理解，不再解释。注意到如果一个矩阵是「Sept 矩阵」，那么只需满足每个大小为 $2 \times 2$ 的子矩阵均为「YF 矩阵」即可。证明如下：

假定有一个 $2 \times 4$ 的网格，保证每个大小为 $2 \times 2$ 的子矩阵均为「YF 矩阵」，如图所示
| $a_1$ | $b_1$ | $a_3$ | $b_4$ |
| -----------: | -----------: | -----------: | -----------: |
| $b_2$ | $a_2$ | $b_3$ | $a_4$ |

根据假设，有：

$ \begin{matrix}
  &a_1 +a_2 <b_1+b_2\\
  &b_1 + b_3 <a_2+a_3\\
  & a_3+a_4<b_3+b_4
\end{matrix}$

三式相加，移项消元即可得到

$a_1+a_4<b_2+b_4$

因此整个矩阵是「Sept 矩阵」。

因此最大的「Sept 矩阵」必是由最多的大小为 $2 \times 2$ 的「YF 矩阵」构成的。那么思路就很简单了。

### 思路

要找到由最多的大小为 $2 \times 2$ 的「YF 矩阵」构成的矩阵，可以将每个大小为 $2 \times 2$ 的「YF 矩阵」简化为一个点。

具体的，以 $(i,j)$ 为左上角顶点的 $2 \times 2$ 矩阵若是「YF 矩阵」，那么 $(i,j)$ 点标记为 $1$ ，否则标记为 $0$ 。

处理过后可以将 $n \times m$ 的矩阵转化为一个 $(n-1) \times (m-1)$ 的矩阵，最后在01矩阵上找出最大的全为1的子矩阵即可，我们使用悬线法解决。

### 悬线法

这里提供两道悬线法的板子题：

[P5943 最大的园地](https://www.luogu.com.cn/problem/P5943)

[P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
int n,m,a[MAXN][MAXN],ans;
int l[MAXN],r[MAXN],h[MAXN];
bool tg[MAXN][MAXN];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j) scanf("%d",&a[i][j]);
	}
	for(int i=1;i<n;++i){
		for(int j=1;j<m;++j){
			if(a[i][j]+a[i+1][j+1] <= a[i+1][j]+a[i][j+1]) tg[i][j] = 1;
		}
	}
	for(int i=1;i<n;++i){
		for(int j=1;j<m;++j){
			r[j] = j;l[j] = j;
			if(tg[i][j]) h[j]++;
			else h[j] = 0;
		}
		for(int j=1;j<m;++j){
			while(l[j]!=1&&h[l[j]-1]>=h[j]) l[j] = l[l[j]-1];
		}
		for(int j=m-1;j>=1;--j){
			while(r[j]!=m-1&&h[r[j]+1]>=h[j]) r[j] = r[r[j]+1];
		}
		for(int j=1;j<m;++j){
			ans = max(ans,(h[j]+1)*(r[j]-l[j]+2));
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zzx0102 (赞：1)

随机跳题跳到的好题。

题解一血（好像是我第一次题解一血

不难把所有的 $2\times 2$ 的 YF 矩阵全部处理出来，即 $a_{i,j}+a_{i+1,j+1}\le a_{i+1,j}+a_{i,j+1}$ 的点 $(i,j)$。

我们把这些点标记成 $1$，然后直接求发现能新建一个 $(n-1)\times (m-1)$ 的矩阵，矩阵上的元素为 $0$ 或 $1$。

然后我们发现，所有 $2\times 2$ 的子矩阵都是 YF 矩阵的 Sept 矩阵，在新矩阵上对应的是一个全 $1$ 子矩阵。

直接在新矩阵上跑全 $1$ 子矩阵即可，可以直接上悬线法。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define W while
#define I inline
const int N = 1010;
int a[N][N];
int n, m; bool s[N][N]; int sum[N][N], l[N], r[N], mx;
I void cmin(int &x, int y) {if(x > y) x = y;}
I void cmx(int &x, int y) {if(x < y) x = y;}
int main() {
	ios::sync_with_stdio(0);
	cin >> n >> m;
	
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			cin >> a[i][j];
		}
	}
	n--;
	m--;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(a[i][j] + a[i + 1][j + 1] <= a[i + 1][j] + a[i][j + 1]) {
//				cout << i << ' ' << j << '\n';
				s[i][j] = 1;
			}
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			int x = s[i][j];
			if(x) sum[i][j] = sum[i - 1][j] + x;
			else sum[i][j] = 0;
		}
	}
	
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			l[j] = j;
			W(l[j] && sum[i][j] <= sum[i][l[j] - 1]) cmin(l[j], l[l[j] - 1]);
		}
		for(int j = m; j; j--) {
			r[j] = j;
			W(r[j] < m && sum[i][j] <= sum[i][r[j] + 1]) cmx(r[j], r[r[j] + 1]);
		}
		for(int j = 1; j <= m; j++) cmx(mx, (sum[i][j] + 1) * (r[j] - l[j] + 2));
	}
	cout << mx;
	return 0;
}
```

---

## 作者：Planetary_system (赞：0)

## 题面解释：
求出给定矩阵中面积最大的一个子矩阵，满足其任意子矩阵左上角与右下角的和不比左下角和右上角的和大。

## 思路分析：
首先，由于我一开始漏看“至少”，认为条件是一个子矩阵中任意 $2\times2$ 的子矩阵满足条件即可。结果歪打正着，产生了本题重要性质，即有没有“至少”是等价的。

也就是说，$A_{1,1}+A_{r,s}\le A_{1,s}+A_{r,1}$ 这个式子可以由小到大扩展。我们以 $3\times3$ 的矩阵为例。如此矩阵 $\begin{bmatrix}
  a&  b& c\\
  d&  e& f\\
  g&  h& i
\end{bmatrix}$ 如今其 $2\times2$ 的子矩阵均满足了条件，即：$\left\{\begin{matrix} a+e\le d+b\\b+f\le e+c\\d+h\le g+e\\e+i\le h+f\end{matrix}\right.    $。将四个式子相加可消去无关变量得到 $a+i\le g+c$。以此类推，对于所有 $2\times2$ 子矩阵都满足条件的矩阵，将所有不等式全部相加就可以得到我们需要的条件，即证明了此矩阵满足条件。

那么我们将满足条件的 $2\times2$ 矩阵设为 $1$，反之为 $0$，获得了一个 $(R-1)\times(S-1)$ 的 $01$ 矩阵。问题充要为找到 $01$ 矩阵中最大面积的全为 $1$ 的子矩阵，计算面积时长宽都在原基础上 $+1$。

本蒟蒻第一反应是 $O(n^3)$ 的唐人做法，即枚举上下两条线，同一列进行与运算，找到最长的一段 $1$。然后发现枚举上界是不必要的，我们只需要钦定一列取到顶，往两边找第一个达不到此高度的位置。

然后学傻了的作者选择了单调栈……不过肯定也能过就当练习了。这类问题其实是单调栈非常套路的一种应用了（或者说就是模板？），不知道的可以先做 [P2947 [USACO09MAR] Look Up S](https://www.luogu.com.cn/problem/P2947)。

于是本题就被一个唐人莫名其妙地解决了呢！
## AC Code:
这里只放核心部分了，没什么细节，放心食用。
```cpp
for(int i=1;i<R;i++)
	for(int j=1;j<S;j++)
		mp[i][j]=(a[i][j]+a[i+1][j+1]<=a[i][j+1]+a[i+1][j]);
for(int i=1;i<R;i++){
	for(int j=1;j<S;j++)
		h[j]=(h[j]+1)*mp[i][j];
	while(!s.empty())s.pop();
	for(int j=1;j<=S;j++){
		while(!s.empty()&&h[j]<h[s.top()])r[s.top()]=j,s.pop();
		s.push(j);
	}
	while(!s.empty())s.pop();
	for(int j=S-1;j>=0;j--){
		while(!s.empty()&&h[j]<h[s.top()])l[s.top()]=j,s.pop();
		s.push(j);
	}
	for(int j=1;j<S;j++)
		if(h[j])ans=max(ans,(h[j]+1)*(r[j]-l[j]));
}
```
完结撒花！！！

---


# [COCI 2013/2014 #4] SUMO

## 题目描述

有 $N$ 个选手参加 $M$ 场 $1$ 对 $1$ 的比赛，比赛顺序已经定好。

现在让你将这些选手分成 $2$ 队，使选手尽可能晚地碰到同队的选手。

输出最优方案下第一次有选手碰到同队的的选手的比赛序号。

## 说明/提示

**【样例解释 #1】**

$[1,3,5]$ 一队， $[2,4]$ 一队。

可以证明这是最优方案。

**【数据范围】**

对于 $100\%$ 的数据，$1\le A_i,B_i\le N\le 10^5$，$1\le M\le 3\times 10^5$。

**【来源】**

本题分值按 COCI 原题设置，满分 $100$。

题目译自 [COCI2013-2014 CONTEST #4](https://hsin.hr/coci/archive/2013_2014/contest4_tasks.pdf) _**T3 SUMO**_。

## 样例 #1

### 输入

```
5
5
1 2
2 3
3 4
4 5
5 1```

### 输出

```
5```

## 样例 #2

### 输入

```
6
8
1 2
3 4
5 6
1 3
1 6
4 5
2 4
2 6
```

### 输出

```
6```

# 题解

## 作者：Zilljy258 (赞：17)

#### 一道简单的并查集......

[题目传送门](https://www.luogu.com.cn/problem/P8014)

--------

### 大体思路：

其实我一开始也没有想到这是并查集的题目，还想了半天，一看题解，恍然大悟——原来这么简单！

主要思想就是从第一场开始，让 PK 的两人尽可能不在一队，这样就能保证同一队的 PK 尽可能地靠后了。

也就是说，如果第 $i$ 场时，两人还没有关系（还没标记为同一队），那么就将互相放到敌队中去；如果两人已经是同一队的关系了，那么输出 $i$（找到答案了），直接结束程序就好了。

思想很简单，但确实难想到（对我这个小蒟蒻来说 QAQ）。

----------

### 代码：

```
#include<iostream>
using namespace std;
int f[100001]={0};
int d[100001]={0};
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
void hb(int x,int y){
	f[x]=y;
}
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) f[i]=i; //初始化 father 数组。
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x;
		cin>>y;
		int xx=find(x); //这里我提前查找了，能为后面节约一点点时间（虽然就一点点）。
		int yy=find(y);
		if(xx==yy){ //判断是否找到答案，即正在 PK 的两人是否已经是同一队。
			cout<<i<<endl;
			break;
		}
		if(find(d[x])!=yy&&d[x]!=0){ //d[x]!=0 是判断是否还是初始状态。
			hb(find(d[x]),yy);
		}
		if(find(d[y])!=xx&&d[y]!=0){
			hb(find(d[y]),xx);
		}
		d[x]=yy; //标记为敌人。
		d[y]=xx;
	}
	return 0;
} 
```

-----

### 总结：

其实这道题还有一点点贪心的成分在，不知道大家有没有感觉到，就是让正在 PK 的两人尽可能不在一队这一操作......

---

## 作者：cjh20090318 (赞：4)

大家好，我是 CQ-C2024 蒟蒻 CJH。

## 题意

~~题目描述写得很清楚了。~~

标签：并查集。

## 分析题目

此题就是一道近似于模板的一道**并查集**的题。

在这里我用 $fa_i$ 表示 $i$ 是属于哪一队的，用 $d_i$ 表示 $i$ 的敌队。

在 $m$ 次比赛中，需要判断 $A_i$ 和 $B_i$ 是否为相同的队伍，如果是就直接输出此场比赛 $i$。

否则当 $A_i$ 的敌队不为初始状态时，合并 $d_{A_i}$ 和 $B_i$；同样再对 $d_{B_i}$ 和 $A_i$ 执行此操作。

## 代码实现

```cpp
//the code is from chenjh
#include<cstdio>
#define MAXN 100001
using namespace std;
int fa[MAXN],d[MAXN];
inline int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){fa[x]=y;}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) fa[i]=i;//初始化 fa 数组。
	for(int t=1,x,y;t<=m;t++){
		scanf("%d%d",&x,&y);
		int rx=find(x),ry=find(y);//获得两队队伍。
		if(rx==ry) return printf("%d\n",t),0;//如果两队队伍相同则输出并结束程序。
		if(d[x] && find(d[x])!=ry) merge(find(d[x]),ry);//合并
		if(d[y] && find(d[y])!=rx) merge(find(d[y]),rx);
		d[x]=ry,d[y]=rx;//记录敌队
	}
	return 0;
}
```

*谢谢大家！*

---

## 作者：yeshubo_qwq (赞：3)

## 题意
有 $N$ 个选手参加 $M$ 场 $1$ 对 $1$ 的比赛，比赛顺序已定。

要求将这些选手分成 $2$ 队，使选手尽可能晚地碰到同队的选手。

问：最优方案下第一次有选手碰到同队的的选手的比赛序号。
## 思路
明显的并查集，和[P1892 [BOI2003]团伙](https://www.luogu.com.cn/problem/P1892)一题类似。

同样适用**对手的对手是队友**这一规则。

如果一个人有两个或更多对手，这些对手就应该被合并成一队的人。

具体实现：用一个数组存每个人的第一个对手，当出现更多的对手时，与第一个对手合并。

似乎这题还能用搜索判环来做？
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,x,y,f[100005],e[100005];
int find(int x){//查 
	if(f[x]==x)return x;
	else return f[x]=find(f[x]);
}
void merge(int x,int y){//并
	int fx=find(x),fy=find(y);
	if(fx!=fy)f[fy]=fx;
}
int main(){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)f[i]=i;//并查集初始化 
    for(i=1;i<=m;i++){
    	scanf("%d%d",&x,&y);
    	if(find(x)==find(y)){//遇到同队PK 
    		printf("%d",i);
    		return 0;
		}
        //对手的对手是队友 
		if(e[x]!=0)merge(e[x],y);
		else e[x]=y;
		if(e[y]!=0)merge(e[y],x);
		else e[y]=x;
	}
    return 0;
}
```

---

## 作者：0xFF (赞：2)

#### 题目大意


------------
有一场 $n$ 位选手，$m$ 轮的比赛，比赛顺序已经固定，现在要将这 $n$ 名选手分成两组，使得选手尽可能晚的遇到同组的选手，求出最优策略下在第几轮必然会有同组间的竞争。

#### 思路分析


------------
此题与 [P1892](https://www.luogu.com.cn/problem/P1892) 思路相似。

考虑用并查集将选手分组，用 $a$ 数组记录每个人的对手，如果第 $i$ 轮的选手 $a$ 数组为空，即表示该选手是第一次出现，所以就让这一轮的两名选手成为对手就能尽可能晚的出现同组选手之间的竞争。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>

using namespace std;
const int N = 100010;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
    return x*f;
}

int fa[N],a[N];
int find(int x){
	if(fa[x] == x) return x;
	else return fa[x] = find(fa[x]);
}
void merge(int x,int y){
	int fx = find(x) , fy = find(y);
	if(fx != fy){
		fa[fx] = fy;
	}
}

int main(){
	int n = read() , m = read();
	for(int i=1;i<=n;i++){
		fa[i] = i;
	}
	for(int i=1;i<=m;i++){
		int x = read() , y = read();
		if(find(x) == find(y)){
			printf("%d",i);
			return 0;
		}
		if(a[x] != 0) merge(a[x],y);
		else a[x] = y;
		if(a[y] != 0) merge(a[y],x);
		else a[y] = x;
	}
	return 0;
}

```


---

## 作者：piggy123 (赞：2)

这道题就是关押罪犯的弱化版，很显然，和关押罪犯一样有两种做法来做。第一种是二分+染色，比较通用但码量大，第二种是种类并查集，思维巧妙，码量小。

显然，我们把并查集分为两个种类，对于每个 $i$ ，他的敌人为 $f(i+n)$ 和朋友为 $f(i)$ （定义 $f(x)$ 为 $x$ 的祖先），每场比赛我们都贪心地将对手设为敌人（因为要尽可能不同队），如果实在不能再设了，冲突了（即两人已经归为一队了）即结束。

AC Code：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll f[200005];
ll find(ll a){
	if (f[a]!=a)f[a]=find(f[a]);
	return f[a];
}

void merge(ll a,ll b){
	f[find(a)]=find(b);
}

int main(){
	ll n,m;
	cin >> n >> m;
	for (ll i=1;i<=n;i++)f[i]=i,f[i+n]=i+n;
	for (ll i=1;i<=m;i++){
		ll a,b;
		cin >> a >> b;
		if (find(a)==find(b)){
			cout << i << endl;
			return 0;
		}
		
		else{
			merge(a,b+n);
			merge(a+n,b);
		}
		
	}
	return 0;
}

```


---

## 作者：封禁用户 (赞：0)

### 并查集~~~      

话说这是我的一道考场题~~没想到正解真开心~~。     

很明显这是一道并查集，两个队伍，问最晚的冲突。 

显然，优先满足前面的使答案更好。

我的脑海里马上跳出了[这题](https://www.luogu.com.cn/problem/P1892)。      

依葫芦画瓢，我们把 $father_{i}$ 开两倍，第二倍表示“敌对的关系”。加入 $x$ 与 $y+n$ 和 $x+n$ 与 $y$。如果 $x$ 与 $y$ 的队伍相同**或者** $x+n$ 与 $y+n$ 的队伍相同就结束。      

### AC code    
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,father[200005],x,y;
int get(int k){
	if (father[k]==k) return k;
	return father[k]=get(father[k]);
}
void append(int x,int y){
	int A=get(x),B=get(y);
	father[A]=father[B];
}
signed main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n<<1;i++)
		father[i]=i;
	for (int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		if (get(x)==get(y)||get(x+n)==get(y+n)){
			printf("%d",i);
			return 0;
		} append(x,y+n),append(x+n,y);
	}
	return 0;
} 
```

---

## 作者：zhijinyu (赞：0)

## 题意简述：
有n个选手参加m场 1 对1的比赛，比赛顺序已定。

要将这n名选手分成两组，使得选手尽可能晚的遇到同组的选手。

求最优方案下第一次有选手碰到同队的的选手的比赛序号。

## 解题思路：
这明显是一道简单的并查集。

如果一个人有两个及以上的对手，那么这些对手应该合并成一队。

用数组存储每个人的第一个对手。如果有更多对手，与第一个合并。

## AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100001;
int n,m;
int f[N],c[N];
int find(int a)
{
    if(f[a]!=a)return f[a]=find(f[a]);
    else return a;
}
void merge(int a,int b){
     if(find(a)!=find(b))f[find(b)]=find(a);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int a,b;
        cin>>a>>b;
        if(find(a)==find(b))
        {
            cout<<i;
            return 0;
        }
        if(c[a]!=0) merge(c[a],b); else c[a]=b;
        if(c[b]!=0) merge(c[b],a); else c[b]=a;
    }
    return 0;
}
```


---

## 作者：404Not_Found (赞：0)

## 题意

给你 $m$ 场 $1$ 对 $1$ 的比赛关系，要你把 $n$ 名选手分成两队，使第一次遇到同队的选手最晚。

## 解法

- ###   解法一
二分+二分图染色，这也是我第一个想到的解法。

首先二分答案，把问题变成一个判定性问题：是否有方法满足二分的前面比赛能不能把选手分成两队且不互相冲突？而判定合法只用判断能不能形成一个二元关系。

更具体的，设二分值为 $k$，把选手抽象成点，比赛关系抽象成边，只需判定$n$ 个选手和前 $k$ 条边是不是一个二分图。而判定二分图可以用二分图染色。注意只能遍历前 $k$ 条边。

时间复杂度： $O((n+m)\log n)$。代码在后面一起放。

- ### 解法二

一种神奇的并查集解法，码量和效率都比解法一要好很多。

对于每一个比赛关系，可以用扩展域并查集来维护。所谓扩展域并查集，就是开两个并查集，不妨记作 $S_1$ 和 $S_2$。当 $x$ 和 $y$ 为比赛对手时，就往 $S_1$ 的 $x$ 到 $S_2$ 的 $y$ 以及 $S_2$ 的 $x$ 和 $S_1$ 的 $y$ 连一条边。

像这样： 

![](https://cdn.luogu.com.cn/upload/image_hosting/c5fkjeg5.png)

图什么的别在意啦 QwQ

显然，如果 $x,y$ 在同一集合内（可以是 $S_1$ 或者是 $S_2$），$x,y$ 只能在一队，这也是最后的答案。

时间复杂度：$O(n+m)$。

### code

二分图染色：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 3e5+5;
struct edge{
	int to,nxt,id;
} e[MAXN<<1];
int head[MAXN],cnt;
inline void add(int u,int v,int id)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].id=id;
	head[u]=cnt;
}
int n,m,col[MAXN];
bool dfs(int u,int x)
{
	for(int i=head[u];i;i=e[i].nxt)
		if(e[i].id<=x)
		{
			int v=e[i].to;
			if(col[u]==col[v]) return 0;
			if(!col[v])
			{
				col[v]=3-col[u];
				if(!dfs(v,x)) return 0; 
			}
		}
	return 1;
}
bool check(int x)
{
	for(int i=1;i<=n;i++)
    	if(!col[i])
		{
			col[i]=1;
			if(!dfs(i,x)) return 0;
		}
    return 1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v,i); add(v,u,i);
	}
	int l=1,r=m;
	while(l<r)
	{
		memset(col,0,sizeof(col));
		int mid=(l+r)>>1;
		if(check(mid)) l=mid+1;
		else r=mid;
	}
	printf("%d\n",l);
	return 0;
}
```
扩展域并查集：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 3e5+5;
int fa[MAXN<<1],n,m;
int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}
void merge(int x,int y){fa[find(y)]=find(x);}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=(n<<1);i++) fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(find(x)==find(y)||find(x+n)==find(y+n)){printf("%d\n",i);return 0;}
		merge(x,y+n); merge(x+n,y);
	}
	return 0;
}
```
又短又快是不是。

感谢观看。


---


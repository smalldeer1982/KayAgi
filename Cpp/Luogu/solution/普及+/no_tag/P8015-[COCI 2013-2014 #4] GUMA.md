# [COCI 2013/2014 #4] GUMA

## 题目描述

给出一个 $N+1$ 列的矩形，第 $i$ 列必须通过水平切割 $A_i-1$ 次被等分成 $A_i$ 份，请你求出最少需要几次切割才能按要求分割完。

$Tips:$ 一次切割一次可以在一个或多个不一定连续的列上进行分割。

## 说明/提示

**【样例解释 #3】**

![](https://cdn.luogu.com.cn/upload/image_hosting/v45dq77p.png)

共 $7$ 次切割。

**【数据范围】**

对于 $20\%$ 的数据，$1\le N\le 100$；

对于 $100\%$ 的数据，$1\le N,A_i\le 10^5$。

**【来源】**

本题分值按 COCI 原题设置，满分 $120$。

题目译自 [COCI2013-2014 CONTEST #4](https://hsin.hr/coci/archive/2013_2014/contest4_tasks.pdf) _**T4 GUMA**_。

## 样例 #1

### 输入

```
1
2
5```

### 输出

```
5```

## 样例 #2

### 输入

```
2
3
7
14```

### 输出

```
15```

## 样例 #3

### 输入

```
9
4
2
4
1
2
2
2
8
4
2 ```

### 输出

```
7```

# 题解

## 作者：lichengyun (赞：5)

~~看到没人发题解，就来水一发（doge)~~

[P8015题目](https://www.luogu.com.cn/problem/P8015)



------------


题意翻译：有k个真分数集 $S_1 , S_2 , \ldots , S_n $ ，

式中，对 $\forall i(i \in [1,n] )$ 都有 $S_i= \lbrace \frac{1}{i} , \frac{2}{i} , \ldots , \frac{n-1}{i} \rbrace$。

求 $|S_1 \cup S_2 \cup \ldots S_n|$。



------------


解法：考虑对每一个分数，都将其简化为既约分数。对于一个给定的整数 $x (x > 1)$，共有 $ φ(i) $ 个既约真分数以 $x$ 为分母。

又对于一个给定的分数，显然有且仅有一个既约分数等于原数。

于是我们这就得到了本题的正解！

枚举每一个 $A_i$ 的约数集合。对于不同集合中的相同约数 $d_j$，只计算其贡献 $φ(d_j)$ 一次。


------------

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool v[1919810];
bool vis[314514];
int pr[29999],phi[314514],ptr=0;
int euler(int n){//线筛，筛phi函数
	memset(v,1,sizeof(v));
	v[0]=v[1]=false;
	for(int i=2;i<=n;i++){
		if(v[i]){
			pr[ptr++]=i;
			phi[i]=i-1;
		}
		for(int j=0;j<=ptr && (pr[j]*i<n);j++){
			v[i*pr[j]]=false;
			phi[i*pr[j]]=phi[i]*phi[pr[j]];
			if(i%pr[j]==0){
				phi[i*pr[j]]=phi[i]*pr[j];
				break;
			}
		}
	}
	return 0;
}
int main(int argc,char *argv[]){
	ios::sync_with_stdio(0);
	euler(131072);
	int n,ans=0;cin>>n;n++;
	while(n--){
		int A;cin>>A;//每次处理一个数
		for(int i=1;i*i<=A;i++){
			if(A%i==0){
				int j=A/i;
				//判重+算贡献
				ans+=(1-vis[i])*phi[i];vis[i]=1;
				ans+=(1-vis[j])*phi[j];vis[j]=1;
				cout<<i<<' '<<j<<'\n';
			}
		}
	}
	
	cout<<ans;
	return 0;
}
```



---

## 作者：SRated (赞：3)

若要切成 $\rm X$ 份 , 那么需要在

$$\rm \dfrac{1}{X} , \dfrac{2}{X} , \cdots ,\dfrac{X-2}{X},\dfrac{X-1}{X}$$

处切分

将这些分数约分后考虑 , 分母 $\rm d$ 仅可能为 $\rm X$ 的因子

根据欧拉反演有 $\displaystyle \rm X = \sum_{d \mid X} \varphi(d)$

即上述共有 $\displaystyle \rm \Big(\sum_{d \mid X} \varphi(d)\Big) - 1$ 项

考虑延长节省的切分

对于 $\rm X$ 而言 , 其因子 $\rm d$ 若已出现则直接延长

如 $\rm X = 16$ 时有 $\rm d = 4$ , 需要在 $\rm \dfrac{1}{4},\dfrac{3}{4}$ 处切分

若前面出现 $\rm X' = 8 , d' = 4$ , 则其也在 $\rm \dfrac{1}{4},\dfrac{3}{4}$ 处切分

那么对于当前 $\rm X,d = 4$ 时的切分 , 直接延长即可

具体而言:

对于每个 $\rm A_i$ 求出其因子 $\rm d$

若 $\rm d$ 未出现过 , 累加 $\rm \varphi(d)$ 并标记

若出现则忽略

记 $\rm A_i$ 值域为 $\rm V$

若线性预处理欧拉函数 , 时间复杂度 $\rm O(V + N \sqrt{V})$

---

## 作者：Erica_N_Contina (赞：1)

## 我的博客

本文知识点参考于：[oi-beats 筛法](https://ntsc-yrx.github.io/oi-beats/site/%E6%95%B0%E5%AD%A6/%E7%AD%9B%E6%B3%95/)，[个人博客](https://ntsc.flowus.cn/)。

## 做法

注意虽然题目中分割方式很随意，但是要求等分是一个很强的条件。

我们考虑什么情况下一列可以和其他列一起分割。我们将一列的长度具体化为 $1$，那么我们第 $i$ 列就应该在 $k\times \frac{1}{A_i}$ 处分割。

于是问题转化为对于所有的 $A_i$，将所有的 $k\times \frac{1}{A_i}$ 加入一个集合后有多少个不同的数值。

我们考虑顺序加入 $A_i$，并且同时标记集合中是否出现了数值 $k\times \frac{1}{A_i}$。但是不同的 $i$ 对应了不同的分母，这很难办。

考虑枚举 $A_i$ 的约数 $x$，假设我们知道了 $x$ 之前已经被作为分母分割了一遍，我们就可以忽略掉 $k\times \frac{1}{A_i}$ 中的一些情况了。

因此我们记录 $x$ 是否被作为分母过。如果 $x$ 没有被作为分母，那么我们就需要将答案加上一个值。那么这个值是多少呢？应该是 $\frac{y}{x}$ 的个数。但是如果 $y$ 是 $x$ 的约数，那么在将 $\frac{x}{y}$ 作为**分母**时，我们已经统计过了。因此我们需要统计的 $\frac{y}{x}$ 应当满足 $y$ 和 $x$ 互质。

所以，请出我们的 $\varphi$ 函数！

我们枚举了 $A_i$ 的所有约数后（含 $1$ 和 $A_i$），所有的 $k\times \frac{1}{A_i}$ 我们就都考虑过了。所以这样统计答案不重不漏。

```C++
#include <bits/stdc++.h>
#define rep(l, tagr, i) for (int i = l, END##i = tagr; i <= END##i; ++i)
#define per(tagr, l, i) for (int i = tagr, END##i = l; i >= END##i; --i)
using namespace std;
#define pb push_back
// #define mpy make_pair
#define int long long
#define pii pair<int, int>
#define ps b
#define pf a

#define X(j) i[j]
#define Y(j) (dp[j] + (i[j] + L) * (i[j] + L))
#define lc tr[x][0]
#define rc tr[x][1]
#define rd read()
int read() {
  int xx = 0, ff = 1;
  char op = getchar();
  while (op < '0' || op > '9') {
    if (op == '-')
      ff = -1;
    op = getchar();
  }
  while (op >= '0' && op <= '9')
    xx = xx * 10 + (op - '0'), op = getchar();
  return xx * ff;
}
void write(int out) {
  if (out < 0)
    putchar('-'), out = -out;
  if (out > 9)
    write(out / 10);
  putchar(out % 10 + '0');
}

const int N = 200000;
const int MOD = N-1;
const int INF = 1e9;


bool v[N];
bool vis[N];
int pr[N],phi[N],ptr=0;

int shai(int n){
	memset(v,1,sizeof(v));
	v[0]=v[1]=false;
	for(int i=2;i<=n;i++){
		if(v[i]){
			pr[ptr++]=i;
			phi[i]=i-1;
		}
		for(int j=0;j<=ptr && (pr[j]*i<n);j++){
			v[i*pr[j]]=false;
			phi[i*pr[j]]=phi[i]*phi[pr[j]];
			if(i%pr[j]==0){
				phi[i*pr[j]]=phi[i]*pr[j];
				break;
			}
		}
	}
	return 0;
}
signed main(){
	shai(N-1);
	int n=rd+1,ans=0;
	while(n--){
		int x=rd;
		for(int i=1;i*i<=x;i++){
			if(x%i==0){
				int j=x/i;
				ans+=(1-vis[i])*phi[i];vis[i]=1;
				ans+=(1-vis[j])*phi[j];vis[j]=1;
			}
		}
	}
	
	cout<<ans;
	return 0;
}
```

---


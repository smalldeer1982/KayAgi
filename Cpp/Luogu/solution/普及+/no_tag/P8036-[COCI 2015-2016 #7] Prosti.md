# [COCI 2015/2016 #7] Prosti

## 题目描述

现有 $Q$ 组询问，每次给出正整数 $K,L,M$。定义全体高兴数的集合为 $\{x|x \le M$ 或 $x$ 为质数$\}$。

对于每次询问，求一个正整数 $i$，使得 $[i,i+K-1]$ 内恰好有 $L$ 个高兴数。如果不大于 $10^7$ 的 $i$ 值不存在，输出 $-1$。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$1 \le Q \le 10^5$，$1 \le K_i,M_i \le 150$，$0 \le L_i \le K_i$。

**【提示与说明】**

欢迎大家通过私信或发帖对自行编写的 [Special Judge](https://www.luogu.com.cn/paste/rj308p4r) 进行 hack。

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [#7](https://hsin.hr/coci/archive/2015_2016/contest7_tasks.pdf) _Task 5 Prosti_。**

**本题分值按 COCI 原题设置，满分 $140$。**

## 样例 #1

### 输入

```
3
1 1 1
2 0 2
3 1 1```

### 输出

```
1
8
4```

## 样例 #2

### 输入

```
3
4 1 1
5 2 3
5 0 3```

### 输出

```
6
4
24```

## 样例 #3

### 输入

```
4
7 2 5
6 1 1
10 4 5
6 2 2```

### 输出

```
6
20
5
4```

# 题解

## 作者：Demeanor_Roy (赞：3)

- [原题链接](https://www.luogu.com.cn/problem/P8036)


------------
- 考虑到其余题解人均打表，这里来一篇不一样的做法。

- 当然正解是不可能正解的，那太人类智慧了，想学的请转 COCI 官网。


------------
### Part 1
- 首先我们可以发现，对于一个具体的询问，我们用 $L$ 和 $R$ 分别表示答案区间左右端点，那么可能的答案区间分为三种：

1. $R\leq M_i$：这种情况较为简单，只有 $K = L$  且 $K \leq M_i$ 时才可能成立，$O(1)$ 判断即可。

2. $L\leq M_i,R>M_i$: 这种情况也不复杂，考虑到 $K$  的范围，那么这样的区间最多不会超过 $150$ 个，直接暴力枚举判断即可。

3. $L>M_i$: 这就是本题的难点所在了，由于满足条件的区间过多，我们不可能一个个去试，那样的时间复杂度是 $10^{12}$，完全不可接受，接下来我们便一步一步去优化第三种情况。

### Part 2
- 很自然地，我们想到了预处理，预处理出长度为 $k$ 的高兴数（因为是第三类情况，也可以说成质数）个数为 $L$ 的区间,询问时直接查表即可，这样做只需要对每一个区间长度扫一遍全集，时间复杂度能做到 $ 150 \times 10^7 $，无疑优秀了许多。可这样做有一个限制是我们没有考虑到的，那就是 $M$。
- 怎样才能忽略 $M$ 的限制呢？考虑贪心，对于满足长度为 $i$，区间内质数个数为 $j$ 的区间，我们只保留起始位置最大的那个。这是因为 $M$ 对答案的限制只是区间左端点必须大于 $M$，那左端点当然是越大越好！
- 于是，我们成功地完成了优化地第一步。

### Part 3
- 在进入最重要的优化前，先讲几个更容易想到，但似乎用处不太大的 trick：
1. 只预处理询问中出现过的区间长度。
2. 预处理时倒序查找，如果对当前 $K$ 值，所以合法的 $L$ 都找到了区间，则中断循坏。
3. 各种常数优化。

### Part 4
- 其实若是这道题时限给到 $2 s$，那本篇题解也就到此为止了，可惜呀！
- 当我们发现其余地方都做到了极致时，似乎忘记考虑一个被我们忽略的细节：那就是我们真的需要 $10^7$ 的全集吗？ 
- 让我们思考一下，对于确定的 $K$ 值，$L$ 能否取到只关乎与区间质数密度，而质数密度的范围与全集大小的关系并不是完全对应的，有没有这样一种可能，用更小的全集规模就能筛出 $10^7$ 所能筛出的所有 $L$ 的取值？
- 这时，你就可以愉快地人肉二分了！！！（正好正解也是二分）
- 这里直接放结论，$3\times 10^6$ 就足够了。


------------
- 于是，你愉快地通过了此题。
- 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=3e6,M=5e5+10,G=155;
int Q,k,l,m;
int v[N],prime[M],id,ans[G][G];
bool st[G];

inline int read()
{
	int x=0;char ch=getchar();
	while(!isdigit(ch))	ch=getchar();
	while(isdigit(ch))	x=x*10+ch-'0',ch=getchar();
	return x;
}
inline void write(int x)
{
	if(!x)	return;
	write(x/10);
	putchar(x%10+'0');
}
inline void init()
{
	for(register int i=2;i<=N-10;i++)
	{
		if(!v[i])	v[i]=i,prime[++id]=i;
		for(int j=1;j<=id;j++)
		{
			if(i*prime[j]>N-10||prime[j]>v[i])	break;
			v[i*prime[j]]=prime[j];
		}
	}
  	 //欧拉筛筛质数
	for(register int i=1;i<=N-10;i++)	v[i]=v[i-1]+(v[i]==i);
  	 //质数前缀和
}
inline void get(int len)
{
	int cnt=0;
	for(register int sta=N-160;sta>=1;sta--)
	{
		if(ans[len][v[sta+len-1]-v[sta-1]])	continue;
		cnt++;
		ans[len][v[sta+len-1]-v[sta-1]]=sta;
		if(cnt==len+1)	break;
	}	
	//对每一个 k 值进行预处理
}
int main()
{
	init();
	Q=read();
	for(register int i=1;i<=Q;i++)
	{
		k=read(),l=read(),m=read();
		if(k==l&&k<=m)
		{
			putchar('1');
			putchar('\n');
			continue;	
		}
		//情况一
		bool flag=false;
		for(register int j=max(1,m-k+2);j<=m;j++)	
			if(m-j+1+v[j+k-1]-v[m]==l)
			{
				write(j);
				putchar('\n');
				flag=true;
				break;
			}
		if(flag)	continue;
		//情况二
		if(!st[k])	st[k]=true,get(k);
		if(ans[k][l]>m)	
		{
			write(ans[k][l]);
			putchar('\n');
		}
		//情况三
		else
		{
			putchar('-');
			putchar('1');
			putchar('\n');
		}
		//无解
	}
	return 0;
}
```

- 完结撒花~

---

## 作者：Feyn (赞：2)

[link](https://www.luogu.com.cn/problem/P8036)

蒟蒻只会打表。

由于题目中 $K$ 和 $M$ 都很小，那么我们可以考虑找出一个长度为 $K$ 的区间满足其中刚好有 $L$ 个质数，保存下来到时候输出即可。给出打表程序的代码，代码中有注释：

```cpp
#include<bits/stdc++.h>
#define feyn
const int N=10001000;
const int S=1e7-200; 
const int M=200;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int p[N/3],sum[N],cnt,ans[M][M];
bool s[N];

signed main(){
	
	#ifdef feyn
	freopen("out.txt","w",stdout);
	#endif
	
	for(int i=2;i<N;i++){
		sum[i]=sum[i-1];
		if(s[i]==false)p[++cnt]=i,sum[i]++;
		for(int j=1;j<=cnt;j++){
			if(i*p[j]>=N)break;
			s[i*p[j]]=true;
			if(i%p[j]==0)break;
		}
	}
	//线性筛并对质数的数量求前缀和（sum[i]表示[1,i]中质数个数） 
	
	//ans[i][j]代表长度为i的、区间内有j个质数的一种可能的方案 
	for(int i=2;i<N;i++){
		for(int j=1;j<=i&&j<=150;j++){
			//j：区间长度 
			int now=sum[i]-sum[i-j];
			if(i-j+1<=S)ans[j][now]=i-j+1; 
		}
	}
	
	//输出 
	printf("{");
	for(int i=1;i<=150;i++){
		printf("{");
		for(int j=0;j<=i;j++){
			if(ans[i][j]){
				if(j!=0)printf(",");
				printf("%d",ans[i][j]);
			}
			//如果方案不存在则不输出，否则会超出代码长度限制 
		}
		printf("},");
	}
	
	return 0;
}
```

上述程序需要运行两三秒的样子。然后考虑如何求得答案。明显答案可能有两种情况，一种是答案对应的区间和区间 $[1,M]$ 有交集，这部分可以暴力枚举验证；另一种是没有交集，这部分的答案等价于求定长区间内恰好有 $L$ 个质数的方案，直接输出保存的答案即可。

```cpp
#include<bits/stdc++.h>
//#define feyn
const int N=200; 
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}

int ans[N][N]=;//刚才程序输出的东西 
 
inline bool p(int wh){
	if(wh<2)return false;
	for(int i=2;i*i<=wh;i++){
		if(wh%i==0)return false;
	}
	return true;
}
int sum[N<<2];

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	int m,a,b,c;
	read(m);
	while(m--){
		read(a);read(b);read(c);
		bool ok=false;
		memset(sum,0,sizeof(sum));
		for(int i=1;i<=(a+c)*2;i++){
			sum[i]=sum[i-1];
			if(i<=c||p(i))sum[i]++;
		}
		for(int i=a;i<=(a+c)*2;i++){
			if(sum[i]-sum[i-a]==b){
				ok=true;
				printf("%d\n",i-a+1);
				break;
			}
		}
		//以上代码对应第一种决策 
		if(ok)continue;
		printf("%d\n",(ans[a][b]==0||ans[a][b]<=c)?-1:ans[a][b]);
		//如果第一种不行那么找第二种 
	}
	
	return 0;
}
```

当然呢，打表是万不得已的方法，能写正解还是写正解比较好。

---

## 作者：_yolanda_ (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P8036)

[博客园食用更佳](https://www.cnblogs.com/yolanda-yxr/p/16520317.html)

## 题目分析

我太菜了，只会打表，但是打表也要优雅！（正解似乎是二分）

一看数据范围如此之小，才 $150$ 打表肯定可以鸭！

把考虑两种情况：

1. 连续区间中有小于等于 $m$ 的数。
2. 没有小于 $m$ 的，即全是大于 $m$ 的质数。

前者可以在每个询问中得到，或者为了方便，所有的起点小于 $150$ 的答案都在每个询问中单独完成。

code

```cpp
int sol(int k,int l,int m){
	int cnt=0;
	for(int i=1;i<=k;++i)
		if(i<=m || !vi[i])	++cnt;
	if(cnt==l)	return 1;
	for(int i=1;i<150;++i){
		if(i<=m || !vi[i])	--cnt;
		if(i+k<=m || !vi[i+k])	++cnt;
		if(cnt==l)	return i+1;
	}
	return -1;
}
```



对于情况 $2$ 考虑先处理出 $10^7$ 以内所有质数，然后枚举 $10^7$ 内所有长度小于等于 $150$ 的区间，并且统计其中的高兴数的个数。

这里为了方便用，令 `st[i][j]` 表示连续 $i$ 个数中有 $j$ 个高兴数的起点。

code

```cpp
memset(st,-1,sizeof st);
for(int i=1;i<=150;++i){
    int cnt=0;
    for(int j=151;j<=150+i;++j)
        if(!vi[j])	++cnt;
    st[i][cnt]=151;

    for(int j=151;j<=5e5;++j){
        if(!vi[j])	--cnt;
        if(!vi[j+i])	++cnt;
        if(st[i][cnt]==-1)	st[i][cnt]=j+1;
    }
}
```

再输出，就得到了一张表，这样答案就可以很快得到了。但是直接复制会有点大，代码也不美观。

仔细观察可以发现，表中的答案只有 `st[138~150][1]` 的结果是大于 $5\times 10^5$ 的，而 $0.5s$ 的时限也只支持枚举到 $5\times10^5$。 

![](https://cdn.luogu.com.cn/upload/image_hosting/jbff8grn.png)

所以我们在程序中只需要枚举到 $5\times10^5$ 即可，再直接把上面得到的值赋给对应的就好了。

main 函数  code

```cpp
int main(){
	
	pri();//线性筛
	
	memset(st,-1,sizeof st);
	for(int i=1;i<=150;++i){
		int cnt=0;
		for(int j=151;j<=150+i;++j)
			if(!vi[j])	++cnt;
		st[i][cnt]=151;
		
		for(int j=151;j<=5e5;++j){
			if(!vi[j])	--cnt;
			if(!vi[j+i])	++cnt;
			if(st[i][cnt]==-1)	st[i][cnt]=j+1;
		}
	}
	st[138][1]=1357194;
	st[139][1]=1357194;
	for(int i=140;i<=150;++i)	st[i][1]=1561892;//打表得到的值
	
	int q=read();
	while(q--){
		int k=read(),l=read(),m=read();
		int tmp=sol(k,l,m);//上面给了代码的
		if(tmp!=-1)	printf("%d\n",tmp);
		else	printf("%d\n",st[k][l]);
	}
	
	return 0;
}
```

至此，打表的方法完美通过。

---

## 作者：Computer1828 (赞：0)

乱搞：

考虑 $K,L$ 很小，所以直接打表计算。注意此处只计算答案大于 $150$ 的部分。

```cpp
int ans[151][151]
for(i = 151->1e7){
	for(j = 1->150 && i+j-1 <= 1e7){
    	if(先前未搜到答案) 更新ans
    }
}
输出ans
```

注意一点，如果直接将答案排成 $151\times 151$ 的数据扔进 `ans` 里，会超过你谷的代码长度上限，所以考虑优化。

我们可以用一个 `vector` 来储存所有不是 $-1$ 的答案。这点基于你对打出来的表的观察：所有不是 $-1$ 的数都在一起，每一排最后都有一大堆 $-1$。

有了这点，你会发现表长大大减少（$100k \rightarrow 40k$），于是你就可以仅仅特判掉不在表中的那一部分了。

```cpp
#include<bits/stdc++.h>
#define N 10000005
#define ll long long
#define pb push_back
using namespace std;
int q,k,l,m;
bool vis[N];
int pri[800005],cnt,spri[N];
vector<int> vc[151];
int main(){
	//你的表，格式：vc[x].pb(y); 
	for(int i = 2;i<=N-5;++i){
		if(!vis[i]) pri[++cnt] = i;
		for(int j = 1;j<=cnt;++j){
			int tm = i*pri[j];
			if(tm > N-5) break;
			vis[tm] = true;
			if(i%pri[j] == 0) break;
		}
	}
	vis[1] = true;
	for(int i = 1;i<=N-5;++i) spri[i] = spri[i-1]+(!vis[i]);
	scanf("%d",&q);
	while(q--){
		scanf("%d%d%d",&k,&l,&m);
		bool flg = false;
		for(int i = 1;i<=150;++i){
			int j = i+k-1,res;
			if(j <= m) res = j-i+1;
			else if(i <= m) res = m-i+1 + spri[j]-spri[m];
			else res = spri[j]-spri[i-1];
			if(res == l){
				printf("%d\n",i);
				flg = true;
				break;
			}
		}
		if(!flg){
			if(vc[k].size() < l+1) printf("-1\n");
			else printf("%d\n",vc[k][l]);
		}
	}
	return 0;
}
```

正解：

设 $f(i)$ 表示 $[i,i+K-1]$ 的高兴数个数。

有引理：

若 $f(a) \leq L \leq f(b)$，则 $\exists x\in [a,b],f(x) = L$。

> "The proof of this lemma is simple and is left as an exercise to the reader."

所以我们可以二分满足 $f(x_0) = L$ 的 $x_0$ 的位置。具体就是设 $l = 1$，找到一个最大的位置 $r$ 满足 $r$ 开始的长度为 $K$ 的区间无高兴数，设 $m = \dfrac{l+r}{2}$。

那么就会满足如下两个的其中一个：

$f(l) \leq L \leq f(m) \leftrightarrow l \leq x_0 \leq m$

$f(m) \leq L \leq f(r) \leftrightarrow m \leq x_0 \leq r$

---


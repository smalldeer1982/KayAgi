# [COCI 2010/2011 #5] DVONIZ（加强版）

## 题目背景

题面与[原题P7635 [COCI2010-2011#5] DVONIZ](https://www.luogu.com.cn/problem/P7635)无异，仅有数据范围，时空限制与分值不同。

## 题目描述

当前 $K$ 个元素的和或最后 $K$ 个元素的和都不大于 $S$ 时，我们说这个 $2\times K$ 个元素的序列是有趣的。

给出一个长度为 $N$ 的序列 $A$。对于每个元素，输出从该元素开始的最长的有趣的子序列。

## 说明/提示

**【样例解释#1】**

对于样例 $1$ 的第一个位置，一共有 $4$ 个子序列，且都满足条件，故取最长的长度为 $4$ 的子序列。

**【数据范围】**

对于 $30\%$ 的数据，$2\le N \le 200$。

对于 $50\%$ 的数据，$2\le N \le 5 \times 10^3$。

对于 $70\%$ 的数据，$2 \le N \le 2 \times 10^5$。

对于 $100\%$ 的数据，$2\le N \le 3 \times 10^6$，$1\le S \le 10^9$，$1\le A_i \le 10^9$。

## 样例 #1

### 输入

```
5 10000
1
1
1
1
1 ```

### 输出

```
4
4
2
2
0 ```

## 样例 #2

### 输入

```
5 9
1
1
10
1
9 ```

### 输出

```
2
0
0
2
0 ```

## 样例 #3

### 输入

```
8 3
1
1
1
1
1
1
1
1 ```

### 输出

```
6
6
6
4
4
2
2
0 ```

# 题解

## 作者：zhaoyp (赞：8)

对于 $30\%$ 的数据，暴力枚举即可，时间复杂度 $O(n^3)$。

对于 $50\%$ 的数据，加入前缀和优化即可，时间复杂度 $O(n^2)$。

对于 $70\%$ 的数据：

考虑维护中间位置 $\text{mid}$，即对于每个 $\text{mid}$，找到一个最大的 $x$，使得该 $\text{mid}$ 的前 $x$ 个元素（含 $\text{mid}$）的和与后 $x$ 个元素（不含 $\text{mid}$）的和均不大于 $m$，并用来更新该区间左端点的答案。

不难发现 $\text{mid}$ 左右段的长度具有单调性，对每一个位置进行二分答案即可，时间复杂度 $O(n \log n)$。

但是这样的维护是不完全的，因为有的答案可能是通过上法求得最长序列的部分。又注意到对于任意一个合法序列 $a$，去掉 $a$ 的第一个和最后一个元素，它依然是合法的。

于是就有如下递推式：

$$f_i=\max(f_{i - 1}-2,f_i)$$
其中 $f_i$ 表示从第 $i$ 个元素开始的最长的优美序列的长度，$\text{DP}$ 即可，总时间复杂度 $O(n \log n)$。

对于 $100\%$ 的数据：

注意到，当 $\text{mid}$ 向右移动时，它能取到最远的左端点和右端点 $l,r$ 必定也会向右边移动。那么我们就可以用双指针（尺取法）来优化。时间复杂度 $O(n)$。


总时间复杂度 $O(n)$。

---

## 作者：_H17_ (赞：5)

## 题目分析

首先分析下数据，$n \le 3 \times 10^6$ 基本上肯定是 $O(n \log n)$ 的复杂度或 $O(n)$。

看见 $\log$ 难道不会想起二分答案吗？

不过看着这种输出大概又像是 DP，所以大概就是向 LIS 那样借助二分进行 DP。

状态不说了，输出格式替你设好了。

对于 $f_i$ 肯定可以从 $f_{i-1}$ 去掉首尾得到，所以得到状态转移方程 $f_i=\max(f_i,f_{i-1}-2)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,a[3000001],l,r,mid,f[3000001];
bool check(int x,int y){
	return a[x]-a[x-y]<=m&&a[x+y]-a[x]<=m;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]+=a[i-1];
	}
	for(int i=1;i<=n;i++){
		l=0,r=min(i,n-i);
		while(l<r){
			mid=l+r+1>>1;
			if(check(i,mid))
				l=mid;
			else
				r=mid-1;
		}
		f[i-l+1]=max(f[i-l+1],2*l);
	}
	for(int i=1;i<=n;i++)
		f[i]=max(f[i],f[i-1]-2);
	for(int i=1;i<=n;i++)
		cout<<f[i]<<'\n';
	return 0;
}
```

## 弱化版&双倍经验

[题目](/problem/P7635)、[题解](/blog/743014/coci2010-20115-dvoniz-post)。

---

## 作者：Dream__Sky (赞：2)

[本题弱化版](https://www.luogu.com.cn/problem/P7635)

弱化版可用二分答案的算法来求解，但是这题的数据就不支持 $O(n\log n)$ 的解法了。

考虑尺取法。

以下定义 $mid$ 为当前区间的中点下标，$l$ 为左端点下标，$r$ 为右端点下标。

普通暴力为，从 $1$ 到 $n$ 枚举中点 $mid$。从当前的 $mid$ 开始，向左枚举，直到和大于 $s$，求出 $l$。再向右枚举，直到和大于 $s$，求出 $r$。求出 $l$ 和 $r$ 之后，我们可以计算以 $mid$ 作为中点时的最大长度 $K$，即 $K=\min(mid-l+1,r-mid)$。但是题目要求的是作为开头时的最小值，那我们可以把它整体向左移 $k$ 位，开头下标变成 $mid-K+1$，将这个长度记录到这一位。时间复杂度 $O(n^2)$。

最后，可能有一些点还没有被更新答案，那我们考虑当前这一位与前一位的关系。考虑不取前一位，为了还满足是 $2 \times K$ 个元素，还得去掉最后一个。即前一位的最大长度减二。此时，该区间一定满足两边的和都小于 $s$，因为上次的区间都小于 $s$ 了，去掉两个数后和甚至都小于原值了，所以满足条件。

如何从暴力上优化？这就要提到尺取法了。当我们变动 $mid$ 后，$l$ 与 $r$ 一定都会向右移动（或者不动），那我们每次可以直接从上一次的 $l$ 与 $r$ 继续向右枚举，直到和大于 $s$。其它都与的与上面相同。时间复杂度 $O(n)$。

在尺取过程中，可以使用前缀和来快速计算区间和。当然也可以边尺取，边计算连续一段区间的和。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n,s,a[100010],t[100010],c[100010];
signed main()
{
	cin>>n>>s;
	for(int i=1;i<=n;i++) cin>>a[i],c[i]=c[i-1]+a[i];//前缀和
	
	int l=1,r=1;
	
	for(int i=1;i<=n;i++)//i即为mid
	{
		while(c[i]-c[l-1]>s) l++;//左端点移动
		while(c[r+1]-c[i]<=s&&r<n) r++;//右端点移动
		int K=min(i-l+1,r-i);//计算K
		t[i-K+1]=K*2;//记录长度
	} 
	for(int i=1;i<=n;i++) t[i]=max(t[i-1]-2,t[i]);//记录未被记录长度的点的长度（有点绕？
	for(int i=1;i<=n;i++) cout<<t[i]<<"\n";
	return 0;
}


```

---

## 作者：tongzhenxuan (赞：2)

## 思路解析：
#### 1.考虑暴力算法 $O(n^3)$。
枚举左右端点，遍历判断是否合法。最多只能拿 $N \le 200$ 的分数。
#### 2.暴力加上前缀和优化 $O(n^2)$。
可以省去遍历所需复杂度。能拿到 $N \le 5 \times 10^3$ 的分数。
#### 3.枚举中间点加二分答案 $O(nlogn)$。	
因为题目中说每个元素的值都为正整数。
可以考虑枚举中间点 $mid$，因而从 $mid$ 左右出发的元素加和是单调递增的。可以考虑运用二分答案，求出以 $mid$ 为中点的左右最远扩展程度（最远到达 $l,r$ 点），取较短的一边，即为此时 $mid$ 的最长长度。

即
```cpp
len=min(r-mid,mid-l+1);
tot[mid-len+1]=max(2*len,tot[mid-len+1]);
```

注：$mid$ 为左区间最后一个元素的下标。

但这样的做法是不完全的，有部分端点的值被更新到了，但是有一些端点没有被更新。考虑到将一个合法的区间去掉头尾两个元素，还是成立的，可以推出:

```cpp
tot[i]=max(tot[i],tot[i-1]-2);
```
最后这里要更新一边才能得到最终答案。
这样的做法可以拿到 $N \le 10^5$ 的分数。

#### 4.枚举中间点加尺取法 $O(n)$。
形同第三条，也是枚举 $mid$ 时找出最远到达的两点 $l,r$，但是发现在 $mid$ 往右移动的时候 $l,r$ 两点也在往右移动，所以可以使用尺取法优化掉二分答案的复杂度。当 $mid$ 右移后，若左区间的累加和已经大于 $S$，将左端点向右移动，直到左区间累加和小于等于 $S$。若右区间累加和小于 $S$，且右区间还能加入元素，那么将右端点向右移动，扩大右区间长度。因为 $l,r$ 最多经历每个端点一次，所以整体的时间复杂度是 $O(n)$ 的。可以通过 $N \le 3 \times 10^6$ 的数据。不要忘记第三条中说的最后更新哦。

## code:
```cpp
#include<bits/stdc++.h>
#define N 3000005
using namespace std;
int n,k;
int a[N],s[N],tot[N];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		s[i]=s[i-1]+a[i];
	}
	int len,head=1,tail=1;
	for(int mid=1;mid<=n;mid++)
	{
		while(s[mid]-s[head-1] > k)  head++;
		while(s[tail+1]-s[mid] <= k && tail < n) tail++;
		len=min(tail - mid , mid - head + 1);
		tot[mid-len+1]=max(tot[mid-len+1],len*2);
	}
	for(int i=1;i<=n;i++)
		tot[i]=max(tot[i],tot[i-1]-2);
	for(int i=1;i<=n;i++)
		printf("%d\n",tot[i]);
	return 0;
}
```

---

## 作者：aaa_lvzekai (赞：1)

### 题目描述

[题目链接](https://www.luogu.com.cn/problem/P8049)

当前 $len$ 个数的和不大于 $s$，并且后 $len$ 个数的和也不大于 $s$ 时，这 $len \times 2$ 个数是有趣的。

给定一个长度为 $n$ 的 $a$ 序列，对于每个数，求出当它为起始点时最长的有趣的序列的长度。

### 思路

#### 40 分思路

算法：暴力枚举。

直接暴力枚举起始点，长度并求和，判断是否满足条件。

时间复杂度：$O(n ^ 3)$。

不开 O2 40pts and 8.47s：[提交记录](https://www.luogu.com.cn/record/124629374)。

开 O2 40pts and 8.48s：[提交记录](https://www.luogu.com.cn/record/124629402)。


#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=3000010;
ll n,m,a[N],sum,ans;
bool flag;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		ans=0;
		for(int len=(n-i+1)/2;len>=1;len--)
		{
			flag=true;
			sum=0;
			for(int now=i;now<=i+len-1;now++)
			{
				sum+=a[now];
			}
			if(sum>m)
			{
				flag=false;
			}
			sum=0;
			for(int now=i+len;now<=i+len*2-1;now++)
			{
				sum+=a[now];
			}
			if(sum>m)
			{
				flag=false;
			}
			if(flag)
			{
				ans=len*2;
				break;
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

#### 50 分思路

算法：前缀和。

考虑在上一个思路求和时用前缀和优化。

时间复杂度：$O(n ^ 2)$。

不开 O2 50pts and 7.04s：[提交记录](https://www.luogu.com.cn/record/124629722)。

开 O2 50pts and 7.04s：[提交记录](https://www.luogu.com.cn/record/124629741)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=3000010;
ll n,m,a[N],ans;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]+=a[i-1]; 
	}
	for(int i=1;i<=n;i++)
	{
		ans=0;
		for(int len=(n-i+1)/2;len>=1;len--)
		{
			if(a[i+len-1]-a[i-1]<=m&&a[i+len*2-1]-a[i+len-1]<=m)
			{
				ans=len;
				break;
			}
		}
		cout<<ans*2<<"\n";
	}
	return 0;
}
```

#### 90 分思路

算法：二分。

我们枚举中点 $mid$ 的位置，考虑二分答案，但是我们发现这样会错，考虑到将一个合法的序列去掉开头、结尾两个元素，还是合法的，可以得出以下转移方程。

### $dp_i = \max(dp_i , dp_{i-1} - 2);$

时间复杂度：$O(n \log n)$。

不开 O2 90pts and 2.24s：[提交记录](https://www.luogu.com.cn/record/124630017)。

开 O2 90pts and 2.23s：[提交记录](https://www.luogu.com.cn/record/124630032)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=3000010;
ll n,m,a[N],l,r,mid,ans,dp[N];
bool check(ll u,ll len)
{
	if(a[u]-a[u-len]<=m&&a[u+len]-a[u]<=m)
	{
		return true;
	}
	return false;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]+=a[i-1];
	}
	for(int i=1;i<=n;i++)
	{
		l=0,r=min((ll)i,(ll)n-i),ans=0;
		while(l<r)
		{
			mid=(l+r+1)/2;
			if(check(i,mid))
			{
				l=mid;
				ans=mid;
			}
			else
			{
				r=mid-1;
			}
		}
		dp[i-ans+1]=max(dp[i-ans+1],ans*2);
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=max(dp[i],dp[i-1]-2);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<dp[i]<<"\n";
	}
	return 0;
}
```

#### 100 分思路

算法：尺取。

考虑在上一个思路上把二分改成尺取，从而优化时间复杂度。

我们枚举中点 $mid$ 的位置，考虑尺取，求出在 $mid$ 之前最长的序列，和小于等于 $s$，并求出在 $mid$ 之后最长的序列，和小于等于 $s$，最终以 $mid$ 为中点的答案就是二者的较小数。

时间复杂度：$O(n)$。

不开 O2 100pts and 1.50s：[提交记录](https://www.luogu.com.cn/record/124630394)。

开 O2 100pts and 1.51s：[提交记录](https://www.luogu.com.cn/record/124630377)。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=3000010;
ll n,m,a[N],up,sum,down,ans,dp[N]; 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	while(down<=n-1&&ans+a[down+1]<=m)
	{
		ans+=a[++down];
	}
	for(int i=1;i<=n;i++)
	{
		sum+=a[i];
		ans-=a[i];
		while(up<=i&&sum>m)
		{
			sum-=a[up++];
		}
		while(down<=n-1&&ans+a[down+1]<=m)
		{
			ans+=a[++down];
		}
		dp[i-min(i-up+1,down-i)+1]=max(min(i-up+1,down-i)*2,0ll);
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=max(dp[i],dp[i-1]-2);
	}
	for(int i=1;i<=n;i++)
	{
		cout<<dp[i]<<"\n";
	}
	return 0;
}
```

---

## 作者：Cells (赞：0)

## 思路

> 当前 $K$ 个元素的和与最后 $K$ 个元素的和都不大于 $S$ 时，我们说这个 $2 \times K$ 个元素的序列是有趣的。

这句话间接地提醒了我怎么做，试想一下某个子序列被分成了相等的两部分，由于 $A_i \in \mathbb{N}^+$，所以能够想到对于一个固定的中心点，它左右两边的元素和只会越来越大，换句话说，元素和具有单调性。既然这样，对于一个固定的中心点，可以二分 $K$ 值，使用前缀和 $O(1)$ 判断 $K$ 是否合法。

但是还有需要完善的地方，按照我们的思路，这样写只会更新子序列端点的 $K$，但是子序列内部我们还没管，能够想到，$ans_i = \max(ans_{i - 1} - 2, ans_i)$，相当于是这个数可以通过去掉前一个的数的左右端点的方式更新 $K$。

时间复杂度 $O(n \log{n})$，[加强版](https://www.luogu.com.cn/problem/P8049) 也是可以通过的，常数需要优秀而已。

但是写都写了，不如把最优秀的解法也说了。

考虑优化掉 $\log$，想象一下，离中心点的最远的端点 $l, r$ 都会随着中心点的向右移动而右移，而 $K = \min(i - l + 1, r - i)$，$i$ 是左半边的最右边的点，所以可以使用双指针模拟 $l, r$，直接算出 $K$，时间复杂度显然为 $O(n)$。

## Code

**二分**

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 3e6 + 10;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n;
int a[N], ans[N];

LL s, pre[N];

il bool check(int x, int len){
	return pre[x] - pre[x - len] <= s && pre[x + len] - pre[x] <= s;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> s;
	
	rep(i, 1, n) cin >> a[i], pre[i] = pre[i - 1] + a[i];
	
	rep(i, 1, n){
		int l = 0, r = min(i, n - i);
		while(l < r){
			int mid = l + r + 1 >> 1;
			if(check(i, mid)) l = mid;
			else r = mid - 1;
		}
		
		ans[i - l + 1] = l * 2;
	}
	
	rep(i, 1, n) ans[i] = max(ans[i], ans[i - 1] - 2), cout << ans[i] << "\n";
	
	return 0;
}
```

**双指针**

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 3e6 + 10;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n, l, r, k;
int a[N], ans[N];

LL s, pre[N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> s;
	
	rep(i, 1, n) cin >> a[i], pre[i] = pre[i - 1] + a[i];
	
	l = r = 1;
	rep(i, 1, n){
		while(pre[i] - pre[l - 1] > s) l ++;
		while(pre[r + 1] - pre[i] <= s && r < n) r ++;
		k = min(i - l + 1, r - i);
		ans[i - k + 1] = k << 1;
	}
	
	rep(i, 1, n) ans[i] = max(ans[i], ans[i - 1] - 2), cout << ans[i] << "\n";
	
	return 0;
}
```

---

## 作者：tangzirui1016 (赞：0)

不是怎么感觉巨佬们都把问题复杂化了呀。

这题不就是一个简简单单的双指针吗？

有趣的序列是形容**后面** $2\times K$ 个元素，所以一个指针可以**从后往前**枚举。

我们发现，当 $i$ 从后往前枚举时，它的答案点（即序列的右节点）也是从后往前的。因为 $a_i>0$，每次 $i$ 往前推只会使得和越来越大，不管是前 $K$ 个元素，还是后 $K$ 个。直到超过限制，答案点往前推。

答案点会不会往后走呢？

不会的，因为我们先判断的位置 $i+1$，再判断的 $i$，如果 $i$ 的答案点比 $i+1$ 的答案点更靠前，那么 $i+1$ 为什么不能选这个 $i$ 的答案点呢？

所以我们也可以用一个指针记录答案点。

其实不用前缀和优化也行。

时间复杂度为 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define r (pos+(pos-i+1))
using namespace std;
const int N=3e6;
int n,S,a[N+5],res[N+5],pos;
long long s[N+5];
//pos表示区间的中点（偏左），r表示答案点
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>S;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i];
	pos=n-1;
	for(int i=n-1;i>=1;i--){
		while(pos>=i&&(r>n||s[r]-s[pos]>S||s[pos]-s[i-1]>S)){
			pos--;
		}
		res[i]=2*(pos-i+1);
	}
	for(int i=1;i<=n;i++) cout<<res[i]<<'\n';
	return 0;
}
```

---

## 作者：内拉组里 (赞：0)

# Pts 87

对 $ a $ 数组作一个前缀和，

然后暴力枚举以每个元素开始的奇数长子段右端点，一个一个 **tomax**，

当区间总和超过 $ 2s $ 时直接退出即可。

## Analyses：

> 总时间复杂度 $ \Theta (N^2) $。
>
> 总空间复杂度 $ \Theta (N) $。

***

# Pts 120

## Plain

枚举时用 **upper_bound** 求出可能的最右端点，从右往左枚举，

找到第一个合法右端点时直接退出。

原题就这么水过去了。

但加强版这样只能拿 **70pts**，还需要优化。

#### Analyses：

> 总时间复杂度 $ \Theta (N^2) $。
>
> 总空间复杂度 $ \Theta (N) $。

***

## Fread

如题，这种方法需要开快读。

考虑枚举中点。

由于 $ a $ 数组是单调递增的，

所以对于每个中点 $ mid $，可以二分出一对临界的 $ (l,r) $，满足 $ \sum\limits^{mid}_{i = l} a_i \le s $，$ \sum\limits^r_{i = mid + 1} a_i \le s $。

二者都能得到一个 **interesting** 序列的半径，取 **min** 即可。

然后在半径能扫到的区间的左半区间中更新答案。

显然地，更靠右的 $ mid $ 能得到更长的 **interesting** 序列，

故倒序枚举，当扫到一个更新过答案的位置时，直接退出即可。

这样每个位置的答案只会被更新一次。

#### Details：

- $ a $ 数组记得开 $ long \ long $，否则 $ \sum a_i + s $ 会炸。

#### Analyses：

> 总时间复杂度 $ \Theta (N \log{N}) $。
>
> 总空间复杂度 $ \Theta (N) $。

***

## Double Pointer

事实上，如果用 **cin**，**cout** 的话，单输入数据就 **TLE** 了。

所以要用 **scanf** 和 **printf**。

容易发现，当中点 $ mid $ 向右移动时，对应的临界 $ (l,r) $ 也是单调递增的。

故考虑用双指针维护 $ l $ 和 $ r $，然后求最大合法半径 $ R $ （跟上面的 $ R $ 是一个东西），

然后去更新 $ R $ 能扫到的最左边的位置的答案，

现在是正序遍历，故左端点答案一定不比之前的差，覆盖即可。

但显然，这里只更新了 $ n $ 次答案，

所以一定会有某些位置多次更新，从而造成其他的位置没有被更新。

拿样例 #2 模拟一下不难发现，这时 $ ans_i = ans_{i - 1} - 2 $，

即在上一个位置的答案序列中左右各去掉一个元素，这样肯定也合法。

所以最后要对答案作一个类前缀 **max** 的处理。

#### Analyses：

> 总时间复杂度 $ \Theta (N) $。
>
> 总空间复杂度 $ \Theta (N) $。

# Code：

```cpp
/* reference : @Luogu.huhangqi */
/* reference : @ZLOJ.luzexi */
#include	<algorithm>
#include	<iostream>
using namespace std;
using ll = long long;
constexpr int maxn = 3e6+4;

namespace pts87
{
	int n, s;
	int a[maxn];
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			cin >> a[i];
			a[i] += a[i - 1];
		}
		for (int i = 1; i <= n; i++)
		{
			int ans = 0;
			for (int j = i + 1; j <= n && a[j] - a[i - 1] <= (s << 1); j += 2)
			{
				int mid = (i + j) >> 1;
				if (a[mid] - a[i - 1] <= s && a[j] - a[mid] <= s) ans = max (ans, j - i + 1);
			}
			cout << ans << endl;
		}
		return 0;
	}
}

namespace pts120
{
	int n, s;
	int a[maxn];
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			cin >> a[i];
			a[i] += a[i - 1];
		}
		for (int i = 1; i <= n; i++)
		{
			int ans = 0;
			int j = upper_bound (a + 1, a + n + 1, (ll) a[i] + (s << 1)) - a - 1;
			if ((j - i + 1) & 1) j--;
			while (j > i)
			{
				int mid = (i + j) >> 1;
				if (a[mid] - a[i - 1] <= s && a[j] - a[mid] <= s)
				{
					ans = j - i + 1;
					break;
				}
				j -= 2;
			}
			cout << ans << endl;
		}
		return 0;
	}
}

namespace pts120_hard_fread
{
	int n, s;
	ll a[maxn];
	int ans[maxn];
	
	inline int read (void)
	{
		register int x = 0;
		register char c = getchar();
		while (c < '0' || c > '9') c = getchar();
		while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ '0'),c = getchar();
		return x;
	}
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			a[i] = read();
			a[i] += a[i - 1];
		}
		for (int i = n; i; i--)
		/* enumerate [mid] */
		{
			/* p[l - 1] >= p[mid] - s */
			int l = lower_bound (a, a + n + 1, a[i] - s) - a + 1;
			/* p[r] <= p[mid] + s */
			int r = upper_bound (a, a + n + 1, a[i] + s) - a - 1;
			int R = min (i - l + 1, r - i);
			for (int j = i - R + 1; j <= i && !ans[j]; j++) ans[j] = (i - j + 1) << 1;
		}
		for (int i = 1; i <= n; i++) printf ("%d\n", ans[i]);
		return 0;
	}
}

namespace pts120_hard_dbptr
{
	int n, s;
	int a[maxn];
	int ans[maxn];
	
	signed main (void)
	{
		cin >> n >> s;
		for (int i = 1; i <= n; i++)
		{
			scanf ("%d", a + i);
			a[i] += a[i - 1];
		}
		int l = 1;
		int r = 1;
		for (int i = 1; i <= n; i++)
		{
			while (a[i] - a[l - 1] > s) l++;
			while (a[r] - a[i] <= s && r <= n) r++;
			int R = min (i - l + 1, r - i - 1);
			ans[i - R + 1] = R << 1;
		}
		for (int i = 1; i <= n; i++) printf ("%d\n", ans[i] = max (ans[i], ans[i - 1] - 2));
		return 0;
	}
}

signed main (void)
{
//	freopen ("dvoniz.in.6", "r", stdin);
	return pts120_hard_dbptr::main ();
}
```

---

## 作者：C_Pos_Princess (赞：0)

# 题解：P8049 [COCI2010-2011#5] DVONIZ（加强版）

这道题其实很好想，（练习过字符串专题的同学应该会很熟悉），这就是相当于一个字符串的题，处理起来有点像马拉车的处理方式，只是没有马拉车的过程。

只需要求出以每个点为中心的答案，然后转移，对于没有算到的点，可以推出公式：
$$
f_i = \max(f_i,f_{i-1}-2)
$$

计算即可。

代码奉上：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int n, s;
const int N = 3e6 + 10;
ll a[N], f[N];
#define LF putchar('\n')

template <typename T>
void read(T& x) {
	x = 0;
	char ch = getchar();
	long long f = 1;
	while (!isdigit(ch)) {
		if (ch == '-')
			f *= -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	x *= f;
}
template <typename T, typename... Args>
void read(T& first, Args&... args) {
	read(first);
	read(args...);
}
template <typename T>
void write(T arg) {
	T x = arg;
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) {
		write(x / 10);
	}
	putchar(x % 10 + '0');
}

template <typename T, typename... Ts>
void write(T arg, Ts... args) {
	write(arg);
	if (sizeof...(args) != 0) {
		putchar(' ');
		write(args...);
	}
}




bool check(int x, int y) {
	return a[x] - a[x - y] <= s && a[x + y] - a[x] <= s;
}

int main() {
	cin >> n >> s;

	for (int i = 1; i <= n; i++) {
		read(a[i]);
		a[i] += a[i - 1];
	}
	for (int i = 1; i <= n; i++) {
		int l = 0, r = min(i, n - i);
		ll ans = 0;
		while (l <= r) {
			int mid = l + r >> 1;
			if (check(i, mid)) {
				ans = mid;
				l = mid + 1;
			} else r = mid - 1;
		}
		f[i - ans + 1] = max(f[i - ans + 1], 2 * ans);
	}
	for (int i = 1; i <= n; i++) {
		f[i] = max(f[i], f[i - 1] - 2);
	}
	for (int i = 1; i <= n; i++) {
		write(f[i]);
		LF;
	}



	return 0;
}

```

---

## 作者：zhouyuhang (赞：0)

现有几篇题解（原题和加强）都是考虑 $\rm mid$ 的移动。实际上不用如此麻烦。

考虑左端点从右向左时最远右端点的相对变化。容易发现下述结论：

若在左端点为 $l$ 时，最远右端点为 $r$，则左端点为 $l-1$ 时的最远右端点 $r'\le r+1$。（证明见最后的注 1）。

![这里本来想放一个示意图，但因为我画得太丑就不放了](1145141919810)

于是可以维护双指针配合前缀和在序列上移动。注意到右指针每次要么右移一个，要么左移，因此从感觉上讲应该是线性的（实际上也的确是，详证见注 2）。

Code（自己去加快读）：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define N 6000005 
int n, s;
int a[N], sum[N], ans[N];
int getsum(int l, int r) { return sum[r] - sum[l - 1];}
bool check(int l, int r) {
	int mid = (l + r) >> 1;
	return getsum(l, mid) <= s && getsum(mid + 1, r) <= s;
}

int main() {
	ios::sync_with_stdio(false);
	cin >> n >> s;
	for(int i = 1; i <= n; ++i) cin >> a[i], sum[i] = sum[i - 1] + a[i];
	
	int p = n, q = 0;
	while(p--) {
		if(!q) {//q=0 表示在 p+1 处不存在满足要求的 q
			if(check(p, p + 1)) q = p + 1, ans[p] = 2; 
		} else if(q < n && check(p, q + 1)) ++q, ans[p] = q - p + 1;
		else {
			--q;
			while(p < q && !check(p, q)) q -= 2;
			if(p > q) q = 0;
			else ans[p] = q - p + 1;
		}
	}
	
	for(int i = 1; i <= n; ++i) cout << ans[i] << endl;
	return 0;
}
```

注 1：考虑反证。假设存在 $r' > r+1$ 满足题目要求。由于 $[l-1,r']$ 满足要求，则 $[l,r'-1]$ 也满足要求；又 $r''=r'-1>r$，故 $r''$ 是以 $l$ 为左端点的最远右端点，与 $r$ 是最远右端点相矛盾。故不存在 $r'>r+1$ 满足要求，即 $l-1$ 时的最远右端点 $r'\le r+1$。

注 2：考虑右指针每次左移的距离 $d_i$ 与右移的次数 $k$。则有 $\sum d_i-k<n$，移项即 $\sum d_i<k+n<2n$。故移动总次数 $cnt=\sum d_i+k=O(n)$。

---


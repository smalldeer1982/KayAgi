# [COCI 2009/2010 #7] SVEMIR

## 题目描述

太空帝国要通过建造隧道来联通它的 $N$ 个星球。

每个星球用三维坐标 $(x_i,y_i,z_i)$ 来表示，而在两个星球 $A,B$ 之间建造隧道的价格为 $\min\{|x_A-x_B|,|y_A-y_B|,|z_A-z_B|\}$。

现要建造 $N-1$ 条隧道使得所有的星球都能直接或间接相连。求完成该任务所需的最小总价。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，$1 \le N \le 10^5$，$-10^9 \le x_i,y_i,z_i \le 10^9$。

**【提示与说明】**

**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 4 SVEMIR_。**

**本题分值按 COCI 原题设置，满分 $100$。**

## 样例 #1

### 输入

```
2
1 5 10
7 8 2```

### 输出

```
3```

## 样例 #2

### 输入

```
3
-1 -1 -1
5 5 5
10 10 10```

### 输出

```
11```

## 样例 #3

### 输入

```
5
11 -15 -15
14 -5 -15
-1 -1 -5
10 -4 -1
19 -4 19```

### 输出

```
4```

# 题解

## 作者：Xeqwq (赞：17)

前置知识：最小生成树。

---

给出 $n$ 个点的三维坐标，可计算出所有点两两之间的距离。  
这道题的难点在于存边。  
如果 $n$ 个点两两之间的所有边都存下来，那么一共要存 $\frac{n \times (n-1)}{2}$ 条边。  
而我们发现数据范围： $n \leqslant 10^{5}$  
那么这样我们要存 $5 \times 10^{9}$ 条边，显然会 MLE 。

---

考虑优化存边方法。  
必须删边。  
删边，就要删掉那些对于答案没有贡献的边，这些边可有可无。  
我们来看一个例子：  
```
3
1 1 1
1 1 2
1 1 3
```  
我们实际上并不需要连三条边，我们只用在第一个点和第二个点、第二个点和第三个点之间各连一条边就可以了。  
得出思路：分别按照x、y、z从小到大排三次序，排完后再数组中相邻两项之间建边。  
这样我们最多只用建 $3 \times n$ 条边，当 $n=10^{5}$ 时，边数也只会达到 $300000$。  

显然这道题建立的是一个稀疏图，我们用 Kruskal 求解最小生成树。  
代码奉上：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int n,m;//m为最后的边数
const int Maxn=1e5+5,Maxm=1e6+5;
struct Node//存点，num为点的编号
{
	int x,y,z,num;
}node[Maxn];
struct Edge//存边
{
	int u,v,w;
}graph[Maxm];
//前三个cmp是用在建边时的排序的，最后一个是用在kruskal中的排序的
bool cmpx(Node n1,Node n2) {return n1.x<n2.x;}
bool cmpy(Node n1,Node n2) {return n1.y<n2.y;}
bool cmpz(Node n1,Node n2) {return n1.z<n2.z;}
bool cmpw(Edge e1,Edge e2) {return e1.w<e2.w;}
int fa[Maxn];//并查集优化
int mst;
int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
void merge(int x,int y) {fa[find(x)]=find(y);}
void kruskal()
{
	for(int i=1;i<=n;i++) fa[i]=i;
	int count=0;
	sort(graph+1,graph+m+1,cmpw);
	for(int i=1;i<=m;i++)
	{
		Edge e=graph[i];
		int u=e.u,v=e.v,w=e.w;
		if(find(u)!=find(v)) 
		{
			merge(u,v);
			mst+=w;
			count++;
			if(count==n-1) return;
		}
	}
}
void add(int u,int v,int w)
{
	graph[++m].u=u;
	graph[m].v=v;
	graph[m].w=w;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&node[i].x,&node[i].y,&node[i].z);
		node[i].num=i; 
	}
	sort(node+1,node+n+1,cmpx);
	for(int i=1;i<n;i++) add(node[i].num,node[i+1].num,node[i+1].x-node[i].x);
	sort(node+1,node+n+1,cmpy);
	for(int i=1;i<n;i++) add(node[i].num,node[i+1].num,node[i+1].y-node[i].y);
	sort(node+1,node+n+1,cmpz);
	for(int i=1;i<n;i++) add(node[i].num,node[i+1].num,node[i+1].z-node[i].z);
	kruskal();
	cout<<mst;
	return 0;
}
```

---

## 作者：Suzt_ilymtics (赞：7)

[题面，嘿嘿，题面](https://www.luogu.com.cn/problem/P8074)

> **Discover the key or change the direction.**

### Solution

题目的意思就是给你 $n$ 个点，任意两个点连边有一定代价，求它的最小生成树。

这看上去很像一个板子，一看数据范围还是算了，$\mathcal O(n^2)$ 的 $\text{prim}$ 算法指定过不去。

那如果把所有边建出来跑 $\text{Kruskal}$ 呢？边数足足有 $\frac{(n-1)n}{2}$ 条也过不去。

我们知道最小生成树只需要 $n-1$ 条边，那这里肯定有很多边是“废边”。

考虑如何减少废边？我们从边权的条件下手。

对于两个点 $a,b$，它们相连的代价为 $ w(a,b) = \min \{|a_x-b_x|, |a_y-b_y|, |a_z-b_z|\}$。

只取最小值啊。。。

并且还只是三个维度中的一个维度。

考虑三个点 $a,b,c$ 且 $a_x < b_x < c_x$ 且任意两点的代价都是由 $x$ 这一维产生的，那显然连接 $(a,b)$ 和 $(b,c)$ 更优，且 $w(a,b) + w(b,c) = w(a,c)$。也就是说如果我们按照 $x$ 排个序，可能相连的只有相邻的两个点。那我们只把这些边拿出来就好了嘛。

$y,z$ 维度同理。

这样一番处理后，所用边数只有 $3n$ 条，$\text{Kruskal}$ 算法可以通过。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

struct edge { int u, v, w; }e[MAXN << 2];
struct node { int x, y, z, id; }a[MAXN];

int n, m, sum = 0;
int fa[MAXN];

int read() {
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0', ch = getchar();
    return f ? -s : s;
}

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
int Dis(int x, int y) { return min(abs(a[x].x - a[y].x), min(abs(a[x].y - a[y].y), abs(a[x].z - a[y].z))); }
bool cmp1(node x, node y) { return x.x < y.x; }
bool cmp2(node x, node y) { return x.y < y.y; }
bool cmp3(node x, node y) { return x.z < y.z; }
bool cmp4(edge x, edge y) { return x.w < y.w; }

signed main()
{
    n = read();
    for(int i = 1; i <= n; ++i) a[i].x = read(), a[i].y = read(), a[i].z = read(), a[i].id = i;
    sort(a + 1, a + n + 1, cmp1);
    for(int i = 1; i < n; ++i) e[++m] = (edge){a[i].id, a[i + 1].id, Dis(i, i + 1)};
    sort(a + 1, a + n + 1, cmp2);
    for(int i = 1; i < n; ++i) e[++m] = (edge){a[i].id, a[i + 1].id, Dis(i, i + 1)};
    sort(a + 1, a + n + 1, cmp3);
    for(int i = 1; i < n; ++i) e[++m] = (edge){a[i].id, a[i + 1].id, Dis(i, i + 1)};
    sort(e + 1, e + m + 1, cmp4);
    for(int i = 1; i <= n; ++i) fa[i] = i;
    for(int i = 1, cnt = 0; i <= m; ++i) {
        int uf = find(e[i].u), vf = find(e[i].v);
        if(uf != vf) {
            fa[uf] = vf;
            sum += e[i].w;
            if(++cnt == n - 1) break;
        }
    }
    printf("%lld\n", sum);
    return 0;
}
```



---

## 作者：Naro_Ahgnay (赞：4)

## 题目大意

有 $n$ 个点，每个点用三维坐标 $(x,y,z)$ 来表示。现在要把它们用 $n-1$ 条边连起来，连接 $A,B$ 需要花费 $\min\{|x_a-x_b|,|y_a-y_b|,|z_a-z_b|\}$。求出最小的总价格。

## 思路

前置知识：最小生成树。

普通的最小生成树只需要排一次序，即每两个点之间的距离。

但是由于这道题中两个点的距离跟三个值有关，即点的三维坐标。

所以我们需要将所有的点分别按照 $x$ 轴、$y$ 轴和 $z$ 轴排序三次。

以 $x$ 轴为例。假设现在有两个点 $A$ 和 $B$，$x_a<x_b$，点 $A$ 和点 $B$ 在 $x$ 轴上相邻。如果此时来了一个点 $C$，且点 $A$ 或点 $B$ 到点 $C$ 的距离小于点 $A$ 到点 $B$ 的距离 $dis_{a,b}$，那么说明点 $C$ 一定是在 $y$ 轴或 $z$ 轴上跟点 $A$ 或点 $B$ 相邻。

这就证明了要使距离最短，那么连接的两点必定在 $x$ 轴或 $y$ 轴或 $z$ 轴相邻。

所以我们在将所有的点分别按照 $x$ 轴、$y$ 轴和 $z$ 轴排序三次之后，还需要按照 $x$ 轴、$y$ 轴和 $z$ 轴相邻两点之间的距离进行一次排序。

此时若点 $A$ 和 $B$ 之间的 $dis_{a,b}$ 最小，就把它们用并查集存在一个集合中，即 $fa_a=fa_b$。

然后向后继续遍历。如果 $fa_x≠fa_y$，就将答案 $ans$ 加上 $dis_{x,y}$。

最后这道题就解决了。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	long long x,y,z;
	int id;
}a[100001];
struct ${
	int idx,idy;
	long long dis;
};
int n,si,p,q;
int fa[100001];
long long ans;
vector<$> v;
int fd(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=fd(fa[x]);
}
long long dis(int x,int y)
{
	return min(abs(a[x].x-a[y].x),min(abs(a[x].y-a[y].y),abs(a[x].z-a[y].z)));
}
bool cmp1(node x,node y)
{
	return x.x<y.x;
}
bool cmp2(node x,node y)
{
	return x.y<y.y;
}
bool cmp3(node x,node y)
{
	return x.z<y.z;
}
bool cmp($ x,$ y)
{
	return x.dis<y.dis;
}
int main()
{
//	freopen("P8074.in","r",stdin);
//	freopen("P8074.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].z);
		a[i].id=fa[i]=i;
	}
	sort(a+1,a+1+n,cmp1);
	for(int i=2;i<=n;i++) 
		v.push_back(($){a[i-1].id,a[i].id,dis(i-1,i)});
	sort(a+1,a+1+n,cmp2);
	for(int i=2;i<=n;i++) 
		v.push_back(($){a[i-1].id,a[i].id,dis(i-1,i)});
	sort(a+1,a+1+n,cmp3);
	for(int i=2;i<=n;i++) 
		v.push_back(($){a[i-1].id,a[i].id,dis(i-1,i)});
	si=v.size();
	sort(v.begin(),v.end(),cmp);
	for(int i=0;i<si;i++)
	{
		p=fd(v[i].idx),q=fd(v[i].idy);
		if(p!=q) {ans+=v[i].dis;fa[p]=q;}
	}
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：qiutianqwq (赞：1)

### P8074 [COCI2009-2010#7] SVEMIR题解

[题目传送门](https://www.luogu.com.cn/problem/P8074)
#### 1. 题目大意

在一个三维坐标系中，给你 $n$ 个点，建造一个连接 $i$、$j$ 的边的代价是 $\min\{|x_A-x_B|,|y_A-y_B|,|z_A-z_B|\}$，在使得整个图连通时代价最小。

#### 2. 分析

如果打一遍 Prim，时间复杂度为 $O(n^2)$,$1 \le N \le 10^5$，无法 AC。

我们考虑 Kruskal：如果每个点两两建一条边，空间会炸，要优化空间。

我们看一下样例 #2:

```
3
-1 -1 -1 //一号
5 5 5	 //二号
10 10 10 //三号
```

如果两两建边，会计算大量的无效数据，就像一号和三号点，我们只需要连接一号和二号，那为什么要连一号和三号呢？不难得出，当 $x_a \le x_b \le x_c$ 时，只需连接 $a$，$b$ 和 $b$，$c$，不需要关心 $a$，$c$。$y$，$z$ 也是这样，这样只需建 $3n$ 条边。也就是说，我们按 $x$，$y$，$z$ 从小到大排序再建一条连接相邻两个点的边，最后在跑一遍 Kruskal。

#### 3. Code

```c
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5, MAXM = 1e7;

int n, m, ans, k;
int f[MAXN];
struct Edge {int u, v, w;}edge[MAXM];
bool operator < (const Edge &a, const Edge &b) {return a.w < b.w;}
struct Planet
{
	int x, y, z, id;
	void input (int i) {scanf ("%d%d%d", &x, &y, &z);id = i;}
}planet[MAXN];
bool cmpx (Planet a, Planet b) {return a.x < b.x;}
bool cmpy (Planet a, Planet b) {return a.y < b.y;}
bool cmpz (Planet a, Planet b) {return a.z < b.z;}

void init ()
{
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++)	planet[i].input (i);
	for (int i = 1; i <= n; i++)	f[i] = i;
}

// 并查集 
int find (int x)
{
	if (x != f[x])	f[x] = find (f[x]);
	return f[x];
}

void add (Planet a, Planet b)
{
	edge[++m].u = a.id;edge[m].v = b.id;
	edge[m].w = min (abs (a.x - b.x), min (abs (a.y - b.y), abs (a.z - b.z))); // 计算代价 
}

// 最小生成树 
void Kruska ()
{
	sort (edge + 1, edge + m + 1);
	for (int i = 1; i <= m; i++)
	{
		int r1 = find (edge[i].u), r2 = find (edge[i].v);
		if (r1 == r2)	continue;
		f[r2] = r1;
		k++;ans += edge[i].w;
		if (k == n - 1)	return;// 建好了树就退出 
	}
}

int main()
{
	init ();
	// 排序 + 建一条连接相邻两个点的边
	sort (planet + 1, planet + n + 1, cmpx);
	for (int i = 2; i <= n; i++)	add (planet[i - 1], planet[i]);
	sort (planet + 1, planet + n + 1, cmpy);
	for (int i = 2; i <= n; i++)	add (planet[i - 1], planet[i]);
	sort (planet + 1, planet + n + 1, cmpz);
	for (int i = 2; i <= n; i++)	add (planet[i - 1], planet[i]);
	Kruska ();
	printf ("%d", ans);
    return 0;
}
```


---

## 作者：eastcloud (赞：1)

## P8074 [COCI2009-2010#7] SVEMIR 题解

### 题意
给出 n 个点的坐标，问将所有点连通所需的最小花费。

### 朴素做法

首先，看到连通和最小花费，想到这题要求图的最小生成树，用并查集实现 kruskal 算法，以此得出这个图的最小生成树。

kruskal 算法流程：

1. 建立并查集，每个点自己为一个集合

2. 输入边并按照权值由小到大排序

3. 扫描每一条边，如果两端点在同一集合则忽略，否则合并他们的集合，将这条边的权值累加进答案

很明显，这种做法的空间复杂度无法达到题目 32 MB 的要求，原因在于此题的图为完全图，任意两点之间都有边连接。

### 优化
再仔细看看题目，而从权值的计算公式中我们可以得到思路，将三个坐标分别存于不同数组并排序，计算相邻两点边权然后存边排序，这样也能保证边最小且点连通，代码如下。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
ll len=0;
struct planet{
	ll val,num;
}x[100001],y[100001],z[100001];
struct road{
	ll l,r,val;
}roa[1000001];
ll edge(ll a,ll b){//存边。
	ll tmpx=abs(x[a].val-x[b].val);
	ll tmpy=abs(y[a].val-y[b].val);
	ll tmpz=abs(z[a].val-z[b].val);
	roa[++len]=((road){x[a].num,x[b].num,tmpx});
	roa[++len]=((road){y[a].num,y[b].num,tmpy});
	roa[++len]=((road){z[a].num,z[b].num,tmpz});
}
ll k[100001];
ll find(ll x){
	if(x==k[x]) return k[x]=x;
	else return k[x]=find(k[x]);
}
bool cmp(planet a,planet b){
	return a.val<b.val;
}
bool cmp2(road a,road b){
	return a.val<b.val;
}
int main(){
	ll n;
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>x[i].val>>y[i].val>>z[i].val;
		x[i].num=i;y[i].num=i;z[i].num=i;//记录编号，存边用。
		k[i]=i;
	}
	sort(x+1,x+n+1,cmp);
	sort(y+1,y+n+1,cmp);
	sort(z+1,z+n+1,cmp);
	ll tot=0,ans=0;
	for(ll i=2;i<=n;i++){
		edge(i-1,i);//一个循环搞定，效率高还省空间。
	}
	sort(roa+1,roa+len+1,cmp2);
	for(ll i=1;i<=len;i++){
		ll x=roa[i].l,y=roa[i].r;
		ll tmpx=find(x),tmpy=find(y);
		if(tmpx!=tmpy){
			tot++;
			k[tmpx]=tmpy;
			ans+=roa[i].val;
		}
		if(tot==n-1) break;
	}//kruskal
	cout<<ans;
}
```

---


# [COCI 2012/2013 #2] POPUST

## 题目背景

**本题分值按 COCI 原题设置，满分 $120$。**

## 题目描述

Mirko 像熊一样饥饿，发现了一家当地餐馆。这家餐厅提供 $N$ 顿饭，并且有一个有趣的定价政策：每顿饭都有两个指定价格，$A_i$ 和 $B_i$。Mirko 点的第一道菜只需要付 $A$ 元，其他菜都需要付 $B$ 元。

Mirko 无法决定点多少菜。为了更简单地作出决定，他向你求助。对于任意 $k\in[1,N]$，点 $k$ 道菜最少要付的钱。Mirko 不在乎他点了哪些特别的饭菜，也不管他点菜的顺序，但他不会点两道同样的菜。

## 说明/提示

#### 样例#1 解释/说明

- $k=1$: Mirko 开始点第 $2$ 道菜，共花费 $A_2=9$ 元。

- $k=2$: Mirko 开始点第 $1$ 道菜，接着点第 $2$ 道菜，共花费 $A_1+B_2=13$ 元。

- $k=3$: Mirko 开始点第 $1$ 道菜，接着点第 $2,3$ 道菜，共花费 $A_1+B_2+B_3=18$ 元。


## 样例 #1

### 输入

```
3
10 5
9 3
10 5```

### 输出

```
9
13
18```

## 样例 #2

### 输入

```
2
100 1
1 100```

### 输出

```
1
2```

## 样例 #3

### 输入

```
5
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000```

### 输出

```
1000000000
2000000000
3000000000
4000000000
5000000000```

# 题解

## 作者：int_R (赞：9)

## 贪心好题

[P8298 [COCI2012-2013#2] POPUST](https://www.luogu.com.cn/problem/P8298)

### 前记

蒟蒻第一篇题解

upd 2023.8.1 修缮细节

### 题目描述

Mirko 像熊一样饥饿，发现了一家当地餐馆。这家餐厅提供 $N$ 顿饭，并且有一个有趣的定价政策：每顿饭都有两个指定价格，$A_i$ 和 $B_i$。Mirko 点的第一道菜只需要付 $A$ 元，其他菜都需要付 $B$ 元。

Mirko 无法决定点多少菜。为了更简单地作出决定，他向你求助。对于任意 $k\in[1,N]$，点 $k$ 道菜最少要付的钱。Mirko 不在乎他点了哪些特别的饭菜，也不管他点菜的顺序，但他不会点两道同样的菜。

------------

## 贪心思想

观察此样例

    3
    10 5
    9 3
    10 5

这道题的突破点在于：由题意得，我们**并不关注点菜顺序**，所以对于每个 $k\in[1,N]$，**只需要取出 $1$ 个 $a_i$ 和 $k-1$ 个 $b_i$ 即可**。

所以我们先按照 $b_i$ 排序。

    9 3
    10 5
    10 5
    
排序后我们可以看出，由于 $b_i$ 为有序的，所以尽可能选取编号较小( $b_i$ 较小)的是较优的。**取出前 $k-1$ 个 $b_i$，再在后 $n-k+1$ 取出一个 $a_i$。**
   
$ans=(\sum\limits_{i=1}^{k-1} b_i) + (\min\limits_{i=k}^n a_i)$
   
但是我们发现，面对下面这个样例，这样就是错误的。
   
    3
    1 3
    114514 7
    1919810 9

按照上面的式子计算，当 $k=2$，$ans=3+114514=114517$，而明显可见，$ans=b_2+a_1=7+1=8$ 更为优。因为在第一个式子中我们选出的 $a$ 的编号是 $\geqslant k$ 的，**然而在后面的 $a_i$ 值较大时，这样就不够优了。**

**这时我们要取出前 $k$ 个 $b_i$，再在前 $k-1$ 个中去掉一个 $b_i$，取出一个 $a_i$。**

设取出 $a_j$。

$ans=(\sum\limits_{i=1}^k b_i) - b_j + a_j (j<k)$

贪心使 $a_j-b_j$ 最小。

得

$ans=(\sum\limits_{i=1}^k b_i) + (\min\limits_{i=1}^{k-1} a_i - b_i)$

### 综上所述，两种方案取较小值。

$\boxed{ ans=min( (\sum\limits_{i=1}^{k-1} b_i) + (\min\limits_{i=k}^n a_i),(\sum\limits_{i=1}^k b_i) + (\min\limits_{i=1}^{k-1} a_i - b_i) )}$

#### **总结就是两种情况：**

1.**完完全全选择最小的 $b_i$** ——先选前 $k-1$ 个 $b_i$，然后在后 $n-k+1$ 取出一个 $a_i$；

2.**选择一个较大的 $b_i$ 以换取一个较小的 $a_i$** ——取出前 $k$ 个 $b_i$，再在前 $k-1$ 个中去掉一个 $b_i$，取出一个 $a_i$。

------------

## 代码实现

根据上面的式子，我们发现我们只需要维护三个东西

$b_i$ 的前缀和————很显然直接前缀和就行

$a_i$ 的最小值————从后往前预处理一遍，记录当前节点到最后的最小值

$a_i-b_i$ 的最小值————从前往后预处理，记录从最开始到当前节点的最小值

然后边更新边输出就好了，~~其实代码非常简单，而且也没什么可说的~~

```cpp
#include<cstdio>
#include<algorithm>
#define int long long//要long long
using namespace std;
const int MAXN=5e5+10;
struct d{int a,b;}p[MAXN];//a[i]和b[i]
int n,pre[MAXN],MIN[MAXN],c[MAXN];//三个数组分别对应上面的三个
inline bool cmp(d x,d y){return x.b<y.b;}//以b[i]为关键字排序
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld%lld",&p[i].a,&p[i].b);
	sort(p+1,p+1+n,cmp);MIN[n+1]=0x3f3f3f,c[0]=0x3f3f3f;//赋初值
	for(int i=1;i<=n;i++)//正着预处理
	{
		pre[i]=pre[i-1]+p[i].b;
		c[i]=min(c[i-1],p[i].a-p[i].b);
	}
	for(int i=n;i>=1;i--) MIN[i]=min(MIN[i+1],p[i].a);//反向预处理
	for(int i=1;i<=n;i++) printf("%lld\n",min(pre[i-1]+MIN[i],pre[i]+c[i-1]));//输出
	return 0;
}
```

---

## 作者：Miraik (赞：6)

~~来水题解啦~~

为了方便，我们先把数组第一次排序，让 $a_i$ 单调不降。

再定义新二元组 $d_i = (b_i,i)$，按照 $b_i$ 升序排序。

再作这个二元组的前缀和 $s_i$，记 $c_i=a_{y_i}-b_{y_i}$ （ $y_i$ 为二元组的第二关键字）

对于选择 $i$ 道菜的答案，有两种情况：

1. 选择二元组的前 $i$ 项，再将其中一项的 $b$ 改为 $i$。

2. 选择二元组的前 $i-1$ 项，再选择后面最小的一个 $a$。

整理一下即为：

$ans_i = \min (s_i + \min\{c_1,c_2,\cdots,c_i\},s_{i-1} + a_{mex} )$

这里的 $mex$ 为 $y_1,y_2,\cdots,y_i$ 中最小的未出现的正整数。

总复杂度 $O(nlogn)$，瓶颈在于排序。

```cpp
#include<bits/stdc++.h>
//#define int ll
#define pb push_back
#define mp make_pair
#define sec second
#define fir first
#define pii pair<int,int>
#define piii pair<int,pair<int,int> >
using namespace std;
typedef long long ll;
const int N=500005;
const int inf=(1<<30)-1;
const ll inff=1ll<<60;
const int mod=1e9+7;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
int n;
int c[N],minc[N];
ll s[N],ans[N];
int f[N],mex;
struct Popust{
	int x,y;
}a[N],b[N];
bool cmp(Popust a,Popust b){
	return a.x<b.x;
}
int main(){int tests=1;//tests=read();
while(tests--){
	n=read();
	for(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) b[i].x=a[i].y,b[i].y=i;
	sort(b+1,b+n+1,cmp);
	for(int i=1;i<=n;i++) c[i]=a[b[i].y].x-a[b[i].y].y;
	for(int i=1;i<=n;i++) s[i]=s[i-1]+b[i].x;
	minc[0]=inf;
	for(int i=1;i<=n;i++) minc[i]=min(minc[i-1],c[i]);
	mex=1;
	for(int i=1;i<=n;i++){
		ans[i]=min(s[i-1]+a[mex].x,s[i]+minc[i]);
		f[b[i].y]=1;
		while(f[mex]) mex++;
	}
	for(int i=1;i<=n;i++) printf("%lld\n",ans[i]);
}	return 0;
}

```


---

## 作者：Listedzero (赞：2)

### 题目分析

本题需要注意性质：只有一个与 $A_i$ 有关，其余都是累加 $B_i$，换而言之，每次要找在对应个数内，先假设全是 $B_i$，再将其中一个换成 $A_i$，所以可以先依照 $B_i$ 从小到大排序，再分类讨论：

- 首个：直接取 $A_i$ 最小值；
- 前 $i$ 个中取 $A_i - B_i$ 的最小值，与 $B_i$ 的前缀和相加；
- 取前 $i-1$ 个 $B_i$ 的前缀和，再从后面未选的找出最小的 $A_i$ 值，再相加。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
int n,sumb[N],cst[N],mina[N];
//sumb:Bi的前缀和
//cst:从前向后推的最小Ai-Bi值
//mina：从后向前推的最小Ai值
struct node{int a,b;}f[N];
bool cmp(node x,node y){
	return x.b<y.b;
}
signed main(){
	cin>>n;
	int tmp=0x7fffffff;
	for(int i=1;i<=n;i++){
		cin>>f[i].a>>f[i].b;
		tmp=min(tmp,f[i].a);
	}
	cout<<tmp<<'\n';

	sort(f+1,f+1+n,cmp);
	cst[0]=mina[n+1]=0x7fffffff;
	for(int i=n;i;i--) mina[i]=min(mina[i+1],f[i].a);
	for(int i=1;i<=n;i++) cst[i]=min(cst[i-1],f[i].a-f[i].b);
	for(int i=1;i<=n;i++) sumb[i]=sumb[i-1]+f[i].b;

	for(int i=2;i<=n;i++){
		int ct1=0,ct2=0;
		ct1=sumb[i]+cst[i];
		ct2=sumb[i-1]+mina[i];
		cout<<min(ct1,ct2)<<'\n'; 
	}
//第二种与第三种情况取最小值
	return 0;
}
```

---

## 作者：htlhtlhtl (赞：2)

## 题意简述
有 $n$ 个二元组 $(a_i,b_i)$，选出 $k$ 个二元组，其中有且仅有一个二元组取值为 $a_i$，剩余的都取 $b_i$，把它们加在一起得到一个值 $ans$。\
对于所有的 $k\in [1,n]$，都求出最小的 $ans$。

## 题目解析（保姆级）
道理其实其他题解都说明白了，但有些说得比较复杂，有些又比较简略 ~~不适合我这种蒟蒻理解~~，这篇题解会尽量说的易懂一点，同时给出具体的代码实现解释。\
其实思路非常简单。对于每一种 $k$，我们肯定要选出 $k-1$ 个 $b_i$，这 $k-1$ 个 $b_i$ 也肯定是要尽量小的。\
所以显然**存在一种选择**，就是选择了最小的 $k-1$ 个 $b_i$。那么 $a_i$ 就不能在这里面选重复的，只能在剩下的二元组中选出最小的 $a_i$。\
那么就很显然**有另一种选择**，就是“$a_i$ 在里面选”。具体而言，就是在 $k-1$ 个 $b_i$ 最小的二元组中，选择一个不要取 $b_i$，而是改成取 $a_i$。那么 $b_i$ 就还差一个，就只能在 $k-1$ 以外的里面选最小，很显然就是第 $k$ 小的 $b_i$ 了。\
现在的问题是，在前面 $k-1$ 个最小的 $b_i$ 中，要选哪一个换成 $a_i$ 呢？\
这里大多数题解直接说了结论一笔带过，但我相信有跟我一样的蒟蒻一时转不过弯来，所以帮你们理一理：\
其实也很简单，如果把一个 $b_i$ 换成 $a_i$，就相当于给原来的值先减去 $b_i$ 再加上 $a_i$，也就是给原来的值加上了 $a_i-b_i$。因为要最小，所以也应当让这个 $a_i-b_i$ 最小。（有点废话，大佬别笑）

两种选择取 $\min$。

然后就做完了。

我知道很多人看到题解如释重负地说完这句话就结束了，但自己动手写代码还是不知所措。所以给大家解释一下代码的构思过程。
## 代码实现
对于上述的第一种选择，需处理：
- 前 $k-1$ 个最小的 $b_i$，而且根据题目，我们得计算出他们的和。显然是给 $b_i$ 排序再计算前缀和。
- 剩余的 $a_i$ 中的最大值……先思考什么叫剩余的。其实是去掉前 $k-1$ 个，也就是**第 $k$ 到第 $n$ 个没有被选中的 $b_i$，它们所在的二元组就是剩余的**。那么这些二元组的 $a_i$ 的最小值就是我们要的。“$b_i$ 所在的二元组中的 $a_i$”，我们发现 $a_i$ 和 $b_i$ 紧密捆绑在了一起，所以在代码中可以把他们**放在一个结构体中，按照 $b_i$ 排序**，就可以直接取第 $k$ 到第 $n$ 个结构体中的 $a_i$ 的最小值了。注意到可以用**后缀最大值**处理。

然后我们发现，将 $a_i$ 跟 $b_i$ 捆绑在一起也很方便处理第二种选择：
- 上面说到一句话叫“给原值加上 $a_i-b_i$”。这个“原值”是什么呢？就是 **$k-1$ 个最小的 $b_i$ 的和**。显然在第一种选择中已经处理了 $b_i$ 的前缀和了，那么现在就是要处理“$k-1$ 个最小的 $b_i$ 所在的二元组中，最小的 $a_i-b_i$”，和原值加起来就好了。注意到我们已经把 $a_i$ 和 $b_i$ 放在一起了，所以也很方便，计算出 **$a_i-b_i$ 的前缀最小值**就可以了。因为还要加上第 $k$ 小的 $b_i$，跟前 $k-1$ 个 $b_i$ 合并一下，就是第 $k$ 个的前缀和。

如果你去看过别人的题解，会发现有些虽然没说明，但写法和我是一样的（我自己写之前还没看过别人的代码，看到有大佬写的跟我几乎一模一样也挺惊喜）。\
然后就做完了（这是真做完了）。\
其实这就是思路实现为代码的能力，俗称码力。信息学作为一种比较倾向于解决实际问题的学科，将想法转化为现实是非常重要的。\
~~下面是现实~~\
下面是代码：
## AC code
```cpp
//非常蒟蒻的码风，应该不难看懂。 
#include<bits/stdc++.h>
#define int long long   //十年___，不开___。 
using namespace std;
const int inf=3e12;
int n;
struct eryuanzu{				//把a和b捆绑在一起 
	int b,a;
	bool operator<(const eryuanzu &x){
		return b<x.b;
	}
}b[500005]; //因为排序等事情主体都是b，所以干脆就管这个数组叫b了。
			//后面的注释中的b指的都是是二元组中的b[i]。 
int sumb[500005]; //b[i]的前缀和 
int mba[500005];//a[i]的后缀最小值，min_back_a，简称mba。 
int mamb[500005];//a[i]-b[i]的前缀最小值，min_a_minus_b，简称mamb。 
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>b[i].a>>b[i].b;
	}
	sort(b+1,b+n+1);		//先排序，别搞忘了 
	mamb[0]=mba[n+1]=inf;
	for(int i=1;i<=n;++i){
		sumb[i]=b[i].b+sumb[i-1];		//处理前缀和 
		mamb[i]=min(mamb[i-1],b[i].a-b[i].b);//处理a[i]-b[i]前缀最小值 
	}
	for(int i=n;i>=1;--i){
		mba[i]=min(mba[i+1],b[i].a);//处理a[i]后缀最小值 
	}
	for(int i=1;i<=n;++i){
		cout<<min(sumb[i-1]+mba[i],sumb[i]+mamb[i-1])<<"\n";//比较两种选择，取较小值
			//min(前k-1个b[i]+剩下的最小a[i],前k个最小b[i]+以最优方式替换掉一个b[i]变为对应的a[i])
	}
	return 0;
}
```
完结撒花！

---

## 作者：why_cb (赞：1)

好久没写贪心题了，~~水一篇题解~~。

拿到题目发现无从下手，观察样例我们可以大胆猜想：

> 加入的菜就不会再被删除。


---
可以简单证明：

我们可以发现，将菜按 $B$ 升序排序后，第 $k$ 次点菜的答案只有前 $k-1$ 个菜加上后面菜中的 $A$ 最小的作为第一个菜或前 $k$ 个菜中选出 $A-B$ 最小的作为第一个菜，即：

$$\min(\sum_{i=1}^{k-1}b_i+\min_{i=k}^{n}a_i,\sum_{i=1}^{k}b_i+\min_{i=1}^{k}(a_i-b_i))$$

- 如果当前选择的是后者，那么由于 $k$ 的波动仅为 1，所以前 $k$ 个菜必然不会删去。

- 如果当前选择的是前者，那么可能被删去的只有后面选的作为第一个菜的菜，我们有：

$$\sum_{i=1}^{k-1}b_i+\min_{i=k}^{n}a_i<\sum_{i=1}^{k}b_i+\min_{i=1}^{k}(a_i-b_i)$$

整理可得：

$$\min_{i=k}^{n}a_i<b_k+\min_{i=1}^{k}(a_i-b_i)$$

当后面的 $k'$ 大于所选的第一个菜时，归约到选择后者的情况，则这个菜也必选；否则 $k'$ 的答案为：

$$\min(\sum_{i=1}^{k'-1}b_i+\min_{i=k'}^{n}a_i,\sum_{i=1}^{k'}b_i+\min_{i=1}^{k'}(a_i-b_i))$$

即比较：

$$\min_{i=k'}^{n}a_i$$ 
与 
$$b_{k'}+\min_{i=1}^{k'}(a_i-b_i)$$

因为

$$\min_{i=k}^{n}a_i\le\min_{i=k'}^{n}a_i\le b_k+\min_{i=1}^{k}(a_i-b_i)<b_{k'}+\min_{i=1}^{k}(a_i-b_i)$$

所以只需证明

$$\min_{i=k}^{n}a_i\le b_{k'}+\min_{i=k+1}^{k'}(a_i-b_i)$$

易得

$$b_{k'}+\min_{i=k+1}^{k'}(a_i-b_i)=\min_{i=k+1}^{k'}(a_i-b_i+b_{k'})\ge\min_{i=k+1}^{k'}a_i\ge \min_{i=k}^{n}a_i$$

所以不删这个菜不劣。

综上，加入的菜就不会再被删除。

---

推导过程可能较复杂，但结论较为简洁，这样我们确定第一个菜一定是 $A$ 最小的之后，每次只需维护未选择的菜中的最小的 $A$（替换当前第一个）与最小的 $B$（直接加），进行比较即可。可用两个优先队列与一个布尔数组记录是否被选，时间复杂度 $O(n\log n)$。

---

## 作者：geven (赞：1)

# [COCI2012-2013#2] POPUST 题解
## 题意
有 $N \thinspace (2 \leq N \leq 5 \times 10^5)$ 个物品，每个物品的原价是 $b_i$ 元。每次选物品时，第一件选出的物品 $i$ 价格变为 $a_i$ 元，问选 $i \thinspace (1 \leq i \leq N)$ 个互不相同的物品最少需要多少钱。
## 思路
### 错误思路
很容易就可以想出一种贪心。

先对每个物品的价格按照 $b_i$ 从小到大排序。

在选择拿出 $i$ 个物品时，先选出前 $i-1$ 个物品按照价格 $b$ 作为之后购买的物品，再在 $i \sim N$ 个物品中选择价格 $a$ 最小的物品作为第一个购买的物品。

此时答案即为 $\sum \limits_{j=1}^{i-1} b_j + \min \{ a_i,a_{i+1},a_{i+2},\cdots,a_N \}$。

求和时可用前缀和优化时间，取最小值时可统计后缀最小值优化时间。
### 正确思路
很显然可以发现，只选择上述贪心策略是不对的。

除了可以在 $i \sim N$ 个物品中选择价格 $a$ 最小的物品作为第一个购买的物品外，还可以在 $1 \sim i$ 个物品中选择价格 $a$ 与价格 $b$ 差值最小的物品，将其变为第一个购买的物品。

此时答案即为 $\sum \limits_{j=1}^{i} b_j + \min \{ a_1-b_1,a_2-b_2,a_3-b_3,\cdots,a_i-b_i \}$。

求和时依然可用前缀和优化时间，取最小值时可用前缀最小值进行优化。

将两种综合起来取最小值，就是最终的答案。

__注意：__ 由于 $1 \leq a_i,b_i \leq 10^9$,所以数据类型要选择 `long long`。
## 代码
```cpp
#include<stdio.h>
#include<algorithm>
typedef long long ll;
const int N=5e5+5;
const ll inf=0x3f3f3f3f3f3f3f3f;
struct node{
	ll x,y;
	bool operator < (const node &a) const{return y<a.y;}
}a[N];
int n;
ll minn[N],minx[N];
int main(){
	scanf("%d",&n);
	ll ans=inf;
	for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i].x,&a[i].y),ans=std::min(ans,a[i].x);
	printf("%lld\n",ans);//选择1个物品的答案 
	std::sort(a+1,a+n+1);
	minx[n+1]=inf;
	for(int i=n;i;i--) minx[i]=std::min(minx[i+1],a[i].x);//统计后缀最小值 
	minn[1]=a[1].x-a[1].y;
	ans=a[1].y;
	ll ans1=0;
	for(int i=2;i<=n;i++){
		minn[i]=std::min(minn[i-1],a[i].x-a[i].y);//统计前缀最小值 
		ans+=a[i].y;//情况2前缀和 
		ans1+=a[i-1].y;//情况1前缀和 
		printf("%lld\n",std::min(ans+minn[i],ans1+minx[i]));//最终答案 
	}
	return 0;
}
```


---

## 作者：Nicrobot (赞：1)

关键词：贪心。

和 [NOIP2015 普及组] 推销员 很类似，非常类似。

第一道菜很特殊，我们先不管，贪心地选择作为后面的菜时价格最小的 $i$ 道菜，并选择作为第一道菜的价格比作为后面的菜便宜最多（贵的最少）的菜作为第一道，这样的方案，选 $i$ 道菜时值为：

$$(\sum_{j=1}^ib_i ) +\min_{j=1}^i\{a_j-b_j\}~(b_j \le b_{j+1})$$

这样一定正确吗？不。

当选择 前 $i$ 道菜时，后 $(n-i)$ 道菜中的一道作为第一道的价格可能会更好（$a_i$ 可能更小）。因此，我们选择后 $n-i$ 道中作为第一道菜价格最小的那一道，剩下 $(i-1)$ 道只需选择 $b_i$ 最小的即可。此时答案为：

$$(\sum_{j=1}^{i-1}b_i ) +\min_{j=n}^{i}\{a_j\}~(b_j \le b_{j+1})$$

两种方案，取最小值即可。

实现上，先排序，然后 $\sum b_j$  可以用前缀和维护，最小值也可以递推计算。

因此，时间复杂度为 $O(n \log n)$.

另外，累加时数据类型应使用 `long long`.

代码如下： 

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5e5 + 10;
struct food {
	long long a, b;  
} s[N];
int n;
long long s1[N], s2[N], s3[N]; //不开 long long _____________ .
//分别是前缀和，前 i 道中选择那一道作为第一道，第 i 道至第 n 道那一道 a_i 最小 

bool cmp(food x, food y) { return x.b < y.b; } 

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> s[i].a >> s[i].b;
	sort(s + 1, s + n + 1, cmp); //按作为后面的菜时的价格 b_i 排序
	
	s3[0] = 1e18, s2[n + 1] = 1e18; // 取最小值，初始赋值为无穷大。 
	for(int i = 1; i <= n; i++)
		s1[i] = s1[i - 1] + s[i].b, // 维护 b 前缀和 
		s3[i] = min(s3[i - 1], s[i].a - s[i].b); //选哪个作为第一道最好 
	for(int i = n; i; i--) //注意从后往前 
		s2[i] = min(s2[i + 1], s[i].a); //选择 最适合作为 第一道的
	
	for(int i = 1; i <= n; i++) 
		cout << min(s1[i] + s3[i], s1[i - 1] + s2[i]) << endl; // 两种方案,取最小值. 
	return 0;
}
```



---

## 作者：ycy1124 (赞：1)

### 题意
有 $n$ 个菜，每个菜有两种价值 $a_i,b_i$，现在想请你计算对于所有的 $k(k\le n)$ 求出最小的一个 $a_i$ 加上 $k-1$ 个 $b_i$，相同的菜品不能在一种方案中重复选择。
### 思路
首先发现，由于只需要选一个 $a_i$，所以我们可以考虑先将其他的 $b_i$ 全部选出来再考虑选这个 $a_i$ 所带来的变化。对于选 $b_i$ 的价值，我们可以先按 $b_i$ 全部排一个序，然后计算一个前缀和就可以快速计算最小的几个 $b_i$ 的和。此时考虑 $a_i$ 的贡献。此时我们所选的 $b_i$ 将整个数列分成了两段，一段是 $i\le k-1$ 的，另一端是 $i\ge k$ 的。我们考虑在前面选出一个 $a_i$，选出来之后 $b_i$ 不够了，所以我们可以先将第 $b_{k}$ 选上，那么此时我们只需要选出前面 $b_i-a_i$ 最大的那一个就行。至于在后面选就更简单了，只需要选一个最小的 $a_i$ 即可。

于是我们可以在给 $b_i$ 排序后分别求出 $b_i$ 的前缀和，$b_i-a_i$ 的前缀最大值，$a_i$ 的后缀最小值，然后每次对两种方案取个最小值输出即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define N 500005
#define int long long 
using namespace std;
struct Node{
    int a,b;
}w[N];
inline bool cmp(Node x1,Node x2){
    return x1.b<x2.b;
}
int n,ans[N],qzh[N],qzma[N],hzmi[N];
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    int sum=0;
    for(int i=1;i<=n;i++){
        cin>>w[i].a>>w[i].b;
    }
    sort(w+1,w+n+1,cmp);
    int ma=w[1].b-w[1].a;
    for(int i=1;i<=n;i++){
        ma=max(ma,w[i].b-w[i].a);//前缀最大值
        qzma[i]=ma;
        qzh[i]=qzh[i-1]+w[i].b;//前缀和
    }
    int mi=w[n].a;
    for(int i=n;i>=1;i--){
        mi=min(mi,w[i].a);
        hzmi[i]=mi;//后缀最小值
    }
    for(int i=1;i<=n;i++){
        cout<<min(qzh[i-1]+hzmi[i],qzh[i]-qzma[i])<<'\n';//方案取最小值
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/196342048)

---

## 作者：Fire_Raku (赞：0)

[P8298 [COCI2012-2013#2] POPUST](https://www.luogu.com.cn/problem/P8298)

贪心

考虑当前选 $k$ 道菜，如果我们先选出了付 $A$ 元的菜，那么剩下选 $B$ 元的一定是前 $k-1$ 大的 $B_i$。

这启发我们先将序列按 $B_i$ 排序。那么可以看到两种情况：

1. 如果选 $A$ 元的菜在 $k$ 道菜之外，那么一定选前 $k-1$ 道菜付 $B_i$ 元，$A$ 就从剩下的里面选最小的。
2. 如果选 $A$ 元的菜在前 $k$ 道菜之内，那么我们选的 $k$ 道菜一定就是前 $k$ 道菜，选 $A$ 元的菜就是 $A_i-B_i$ 最小的那道（因为 $val=\sum\limits_{i=1}^kB_i+\min\limits_{1\le i\le k}(A_i-B_i)$。 

从小到大枚举，不断维护即可。

复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define pii std::pair<int, int>
#define mk std::make_pair
#define fi first
#define se second
#define pb push_back

using i64 = long long;
using ull = unsigned long long;
const i64 iinf = 0x3f3f3f3f, linf = 0x3f3f3f3f3f3f3f3f;
const int N = 5e5 + 10;
int n;
struct node {
	i64 a, b;
	friend bool operator < (node a, node b) {
		return a.b < b.b;
	}
} a[N];
i64 min[N];
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
	std::cin >> n;

	for(int i = 1; i <= n; i++) {
		std::cin >> a[i].a >> a[i].b;
	}

	std::sort(a + 1, a + n + 1);
	min[n + 1] = iinf;
	for(int i = n; i >= 1; i--) {
		min[i] = std::min(min[i + 1], a[i].a);
	}

	i64 mn = linf, ans = 0;
	for(int i = 1; i <= n; i++) {
		mn = std::min(mn, a[i].a - a[i].b);
		ans += a[i].b;

		std::cout << std::min(ans + mn, (ans - a[i].b) + min[i + 1]) << "\n";
	}
	return 0;
}
```

---

## 作者：jr_zch (赞：0)

# [POPUST](https://www.luogu.com.cn/problem/P8298)
## by [jr_zch](https://www.luogu.com.cn/blog/jr-zch-code-garden/) 博客食用更佳喵~
## Part 1: 题目大意 
给你 $n$ 道菜 每道菜有两个价格 输出选 $k$ 道菜所需要的最小价格 其中价格 $a$ 能且只能购买一次。
## Part 2: 解题思路
### $O(2^n):$ 直接爆搜 不加以阐述。
### $O(n \log_2n):$ 正解如下
因为 $2 \leq N \leq 5 \times 10^5$ 所以要往线性方向想 再加上是要求**最小值** 价格 $a$ 只能用一次 不妨试试贪心?

先把输入存进一个结构体 并记录下 $a,b$ 间的差价 然后按价格 $b$ 
升序排序。

统计价格 $b$ 的**前缀和** $s$ 以及**差价**的**前缀最大值** $maxx$ 然后统计价格 $a$ 的**前缀最小值** $minn$。

对于每一个 $k$ 肯定是选择排序后的前 $k$ 道菜 先假设全都用价格 $a$ 接下来有两种选择 $:$

1. 用后面 $n - k$ 道菜的其中一个的价格 $a$ 来替换掉第 $k$ 道菜 $($ 因为第 $k$ 道菜最贵 $)$。

这时的代价为 $s_k - (d_k.b - minn_{i+1})$。

2. 把前面中的一道菜换成价格 $a$。

这时的代价为 $s_k - maxx_i$。

在这两者间取 $\min$ 即可。

#### tips:
* 输入是无序的 要先排序。
* 最值数组要赋初值。
* $1 \leq A_i,B_i \leq 10^9$ 肯定会爆 `int` 所以记得开 `long long` ~~不然会见祖宗的~~。

## Part 3: Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=5e5+7;
const int inf=1e18;
int n;
int s[maxn],maxx[maxn],minn[maxn];
struct node{
	int a,b,pr;
}d[maxn];

bool cmp(node x,node y){
	return x.b<y.b;
}

void init(){
	for(int i=0;i<maxn;i++) maxx[i]=-inf,minn[i]=inf;
	return ;
}

signed main(){
	init();
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld%lld",&d[i].a,&d[i].b),d[i].pr=d[i].b-d[i].a;
	sort(d+1,d+1+n,cmp);
	for(int i=1;i<=n;i++){
		s[i]=s[i-1]+d[i].b;
		maxx[i]=max(maxx[i-1],d[i].pr);
	}
	for(int i=n;i>=1;i--) minn[i]=min(minn[i+1],d[i].a);
	for(int i=1;i<=n;i++) printf("%lld\n",s[i]-max(maxx[i],d[i].b-minn[i+1])); //把上文中的式子前面部分提出来了 
	return 0;
}
```
## $\text Thanks~for~your~reading$

---


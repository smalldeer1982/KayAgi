# [COCI 2021/2022 #6]  Naboj

## 题目描述

Šikić 先生是一位化学老师，他正在用 $n$ 个金属球和 $m$ 根铜导线做实验。他将一些对金属球用导线相连，使这些球（直接或间接地）与其他球都相连。他想要教学生关于电荷的知识，因此他将通过按顺序给金属球充电来演示它。

Šikić 先生可以让每个球带上正负电荷的一种。当一个金属球带负电荷时，与这个金属球相连的所有导线中的电子都将被排斥到与该导线相连的另一个金属球上。反过来，当一个金属球带正电荷时，与这个金属球相连的所有导线中的电子都将受这个金属球的吸引。无论导线的先前状态如何，给球充电对导线的影响都相同。

在刚上课的时候，所有的金属球都不带电，导线中的电子不动。对于每根导线，Šikić 先生都想让它其中电子的流向是某一个确定的方向。请帮他确定一个给金属球充电的顺序，使得最后电子的流向是他想要的。

## 说明/提示

### 样例解释 1：

首先，我们给金属球 $2$ 充正电荷。金属球 $1,2$ 和金属球 $2,3$ 之间的导线中的电子现在更靠近 $2$。金属球 $1,3$ 之间的导线仍保持中性。

现在我们给金属球 $3$ 充负电荷。金属球 $2,3$ 之间的导线状态不变，金属球 $1,3$ 之间的导线中的电子更靠近金属球 $1$。

最后我们给金属球 $1$ 冲正电荷。金属球 $1,3$ 之间的导线状态不变，但金属球 $1,2$ 之间的导线现在将更靠近金属球 $1$，目标流向达成。

### 数据范围：

对于全部数据，$1 \le n\le 200000$，$1\le m\le 500000$，$1 \le a_i,b_ i\le n,a_i\neq b_i$

本题分值与 [COCI 2021-2022#6](https://hsin.hr/coci/contest6_tasks.pdf) 分值相同，满分 $110$ 分

## 样例 #1

### 输入

```
3 3
1 2
2 3
1 3```

### 输出

```
3
2 1
3 0
1 1
```

## 样例 #2

### 输入

```
4 3
1 2
3 2
2 4
```

### 输出

```
4
2 1
4 0
3 1
1 1```

## 样例 #3

### 输入

```
5 10
2 4
3 4
1 4
4 5
3 2
2 1
5 2
1 3
5 3
1 5```

### 输出

```
-1```

# 题解

## 作者：Demeanor_Roy (赞：4)

- [原题链接](https://www.luogu.com.cn/problem/P8405)

- 小清新构造题。

------------

- 一开始拿到题可能比较没有头绪，这时有一个小技巧：从特殊情况入手，先看看什么时候无解。

- 我们将一条导线看作一条有向边，边的方向是从离电子远的点到离电子近的点。这时如果你随便在草稿纸上手玩几个样例就会发现：似乎图有环就无解！

- 让我们来严格证明一下这个结论：考虑一个环上最后一个被充电的点，无论我们给它充正电还是负电，它连接的两条边由于需求冲突，都会有一条边在充电后不满足要求。而环上的边只有环上的点能影响，这时我们就推出只要给环上的点充电，就一定不满足要求。而如果不给环上的任意一个点充电，当然也是不合法的，所以结论得证。

- 那此时我们就可以先把环判掉，接下来就是在 $DAG$ 上解决问题。

- 由于是 $DAG$ ，不难想到先将整张图按拓扑序排好，我们按拓扑序顺序考虑每个点，发现与这个点相连的边分为两类：一类是连向之前已经考虑过的点，一类是连向还未考虑的点，前一类边要求这个点充正电，后一类则相反。由于后一类边还有挽救的余地，那对当前点来说，我们当然是先满足前者。

- 于是我们就得到一个策略，按拓扑序给每一个点充正电。

- 让我们证明这个策略的正确性：对于每一条边，一定是它通向的点后考虑，而它通向的点一定会满足它的需求，正确性得证。

- 注意事项：

1. 判环可以在拓扑排序中判定，不需要专门判断。

2. 可能有人会疑惑我有环就无解这个结论只证明了充分性，可实际上后面构造方案时其实就相当于顺便证明了必要性。

- 于是这道题就结束了，下附代码：

```cpp

#include<bits/stdc++.h>
using namespace std;

const int N=2e5+10,M=5e5+10;
int n,m,din[N],q[N];
int h[N],e[M],ne[M],idx;
vector<int> ans;
inline void add(int a,int b)
{
	e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
inline bool topsort()
{
	int head=1,tail=0;
	for(int i=1;i<=n;i++)	if(!din[i])	q[++tail]=i;
	while(head<=tail)
	{
		int now=q[head++];
		for(int i=h[now];~i;i=ne[i])
		{
			din[e[i]]--;
			if(!din[e[i]])
			{
				q[++tail]=e[i];
				ans.push_back(e[i]);			
			}
		}
	}
	return tail==n;
}
int main()
{
	memset(h,-1,sizeof h);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(v,u);din[u]++;
	}
	if(!topsort())	puts("-1");
	else	
	{
		printf("%d\n",(int)ans.size());
		for(auto now:ans)	printf("%d 1\n",now);
	}
	return 0;
}
```

- 完结撒花~


---

## 作者：XuYueming (赞：3)

## 题意简述

给定一张无向图，每条边有个哨兵，初始在边的中间。你可以把某个结点旁边的哨兵全部吸引或远离这个结点。给出最后每个哨兵在边的哪一端，请构造出一种可能的操作方案或报告无解。多种情况输出任意解，**你不需要最小化操作步数**。

## 题目分析

发现一个哨兵和且仅和最后一次关联这条边的操作有关，考虑使用“浮水法”反转操作，即假定一个哨兵在被定向后就不会再发生变化，那么把这样的方案倒序输出就是原问题答案了。

那么如何求解这个问题呢？发现一开始操作的点一定是哨兵最终要全部靠近或远离这个点的，为简化讨论，不妨令一开始操作的点连出的所有边，哨兵都在这个点一侧。那么给它设为吸引哨兵后，它对其他节点就没有了影响。所以考虑删去这个点和其连出的边，循环此过程。

发现这就是在跑一个拓扑排序。既然是拓扑排序，无解的时候当且仅当出现了环，也就是最后还有的边不能被确定。

于是这道~~水~~题就愉快地过掉啦。

## 代码（已略去快读快写）

> 目前[最优解 rank1](https://www.luogu.com.cn/record/151994782)

```cpp
//#pragma GCC optimize(3)
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx", "sse2", "sse3", "sse4", "mmx")
#include <iostream>
#include <cstdio>
#define debug(a) cerr << "Line: " << __LINE__ << " " << #a << endl
#define print(a) cerr << #a << "=" << (a) << endl
#define file(a) freopen(#a".in", "r", stdin), freopen(#a".out", "w", stdout)
#define main Main(); signed main(){ return ios::sync_with_stdio(0), cin.tie(0), Main(); } signed Main
using namespace std;

int n, m;

struct Graph{
	struct node{
		int to, nxt;
	} edge[500010 << 1];
	int eid, head[500010];
	inline void add(int u, int v){
		edge[++eid] = {v, head[u]};
		head[u] = eid;
	}
	inline node & operator [] (const int x){
		return edge[x];
	}
} xym;

int du[500010], Q[500010], top;
int ans[500010], tot;

signed main(){
	read(n, m);
	for (int i = 1, u, v; i <= m; ++i) read(u, v), xym.add(u, v), ++du[v];
	for (int i = 1; i <= n; ++i) !du[i] && (Q[++top] = i);
	while (top){
		int now = Q[top--]; ans[++tot] = now;  // 给这个点设为吸引哨兵
		for (int i = xym.head[now]; i; i = xym[i].nxt)
			if (!--du[xym[i].to]) Q[++top] = xym[i].to;  // 拓扑排序
	}
	for (int i = 1; i <= n; ++i) du[i] && (write(-1), exit(0), yzh_i_love_you);
	// 无解当且仅当最后出现了环
	write(tot, '\n');
	for (int i = tot; i >= 1; --i) write(ans[i], ' ', 1, '\n');  // 逆序输出
	return 0;
}
```

## 总结 & 后话

对于这种最终结果依赖于最后一次操作的时候，考虑使用“浮水法”，反转操作顺序，它被操作后就不再变化了，而实际操作顺序就是新操作顺序的逆序。

---

## 作者：2017gdgzoi999 (赞：1)

考虑到每条边的偏向取决于最后一次影响到这条边的操作，状态的覆盖难以维护。考虑反转操作顺序，将末次有效变为首次有效，于是问题变为：

每次选定一个点 $u$，将与 $u$ 相连的 **未确定偏向** 的电荷偏向全部变成朝向 $u$ 点、远离 $u$ 点中的一种，问是否在若干操作后得到目标状态。

显然如果一个点相连的所有 **未确定偏向** 边的 **目标偏向状态** 全部为朝向该点或全部为远离该店，那么才能对这个点进行操作。维护一个队列存储可操作的点，每次操作完将因这次操作新增的可操作点加入队列。最终各点进入队列的顺序反过来就是实际操作顺序。如果队列在所有边被确定偏向前就被排空了，那么无法达成目标状态。

```cpp
// cb[u] : 与 u 相连未确定偏向边中目标状态为偏向 u 的边数
// ca[u] : 与 u 相连未确定偏向边中目标状态为远离 u 的边数
void addedge(int u, int v) { // 因为函数调用顺序，此边目标状态为偏向 v
	ed[++ed_cnt]=(edge){v,head[u]}; head[u]=ed_cnt;
	ed[++ed_cnt]=(edge){u,head[v]}; head[v]=ed_cnt;
	++ca[u]; ++cb[v];
}
int main() {
	int n=read(), m=read(); 
	while (m--) addedge(read(),read());
	for (int i=1; i<=n; ++i) {
		if ((!ca[i])||(!cb[i])) { // 相连边目标状态偏向全部一致，可进行操作
			vis[i]=true; q.push(i);
		}
	}
	int tot = 0;
	while (!q.empty()) {
		int u=q.front(); q.pop();
		c[++tot]=u; if (!ca[u]) d[tot]=1;
		for (int i=head[u]; i; i=ed[i].nxt) {
			int v=ed[i].to; if (vis[v]) continue;
			if (!ca[u]) --ca[v];
			else --cb[v];
			if ((!ca[v])||(!cb[v])) { // 判断本次操作是否新增了可操作点
				vis[v]=true; q.push(v);
			}
		}
	}
	for (int i=1; i<=n; ++i) {
		if (!vis[i]) { // 本程序中，每条边都被确定偏向 <=> 每个点都进行了操作
			printf("-1"); return 0;
		}
	}
	printf("%d", tot);
	for (int i=tot; i>=1; --i) printf("\n%d %d",c[i],d[i]);
	return 0;
}
```

---


# 射命丸文的取材之旅

## 题目背景

射命丸文（Syameimaru Aya）是一只鸦天狗。她不定期制作名为「文文。新闻」的报纸，而为此，她需要对她收集到的新闻进行剪裁。

## 题目描述

射命丸文现在收集到了 $2n$ 条新闻。她想要将其刊登于自己的报刊之上。然而，自己的报刊最多只能刊登 $n$ 条新闻。

为了能在 $n$ 条新闻的篇幅中让自己的报刊得到最大的吸引力，她将这 $2n$ 条新闻**等分**成**两份**，即每一份中均有 $n$ 条新闻。

每一条新闻自然有着其吸引力。在**第一份**中，第 $i$ 条新闻有着吸引力 $a_i$，而在**第二份**中，第 $i$ 条新闻有着吸引力 $b_i$。这两份新闻的划分在输入时已经给定。

现在射命丸文要从中选取新闻放入自己的报刊。报刊上的第 $i$ 条新闻，将选择**第一份**新闻的第 $i$ 条或**第二份**新闻的第 $i$ 条。这样，报刊上的新闻就可以构成一个长度为 $n$ 的序列，第 $i$ 项也就是第 $i$ 条新闻有着吸引力 $c_i \in \{a_i,b_i\}$。

而这样的一份报刊有着其综合影响力。根据射命丸文的经验，对于她这样的一份含有 $n$ 条新闻的报刊，其综合影响力为：

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

其中 $\operatorname{mex}\{c_l,c_{l+1},\dots,c_{r-1},c_r\}$ 指的是 $c_l,c_{l+1},\dots,c_{r-1},c_r$ 中没有出现过的**最小非负整数**。

现在她希望知道，在进行这些操作之后，自己的报刊的**最大**的综合影响力会是多少呢？由于她还要继续取材，因此她把这个任务交付给了你。

【形式化题意】

给定序列 $\{a_n\},\{b_n\}$，求一个序列 $\{c_n\}$ 满足 $\forall i\in[1,n],c_i\in\{a_i,b_i\}$，最大化

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

并输出该式子可能的最大值。

## 说明/提示

**【样例解释和说明】**

射命丸文可以让自己的 $5$ 条新闻分别取第二份的第 $1$ 条，第一份的第 $2$ 条，第一份的第 $3$ 条，第一份的第 $4$ 条和第二份的第 $5$ 条。这样一来，她的报刊每条新闻的吸引力 $c_i$ 分别为 $0,1,0,1,0$。令 $l=1,r=5$，则 $\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=2$，$r-l+1-\operatorname{mex}\{c_1,c_2,c_3,c_4,c_5\}=3$，不难证明其为数列 $c$ 的综合影响力，也是**所有的可能的** $c$ 的最大综合影响力。

**【数据范围】**

对于 $20\%$ 的数据，满足 $1 \leq n\leq 10$。

另外 $40\%$ 的数据满足 $a_i=b_i$。

对于 $100\%$ 的数据，满足 $1 \leq n\le 10^6$，$0
\leq a_i,b_i\leq n$。

## 样例 #1

### 输入

```
5
0 1 0 1 2
0 2 0 1 0```

### 输出

```
3```

# 题解

## 作者：retep (赞：31)

## 题目简述

给定序列 $\{a_n\},\{b_n\}$，求一个序列 $\{c_n\}$ 满足 $\forall i\in[1,n],c_i\in\{a_i,b_i\}$，最大化

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

并输出该式子可能的最大值。

其中 $\operatorname{mex}\{c_l,c_{l+1},\dots,c_{r-1},c_r\}$ 指的是 $c_l,c_{l+1},\dots,c_{r-1},c_r$ 中没有出现过的**最小非负整数**。

数据范围：$1\le n \le 10^6$，$0\le a_i,b_i \le n$

题目传送门：[P8445 射命丸文的取材之旅](https://www.luogu.com.cn/problem/P8445)

## 题目分析

这是道最优化问题，关键点在于枚举对象的选择。

枚举 $l$ 与 $r$ 显然是不可行的，因为枚举子区间本身就是 $O(n^2)$，再加上区间内还要抉择选 $a_i$ 还是 $b_i$ 让复杂度进一步上升。

看到数据范围，我们发现了异常：$0\le a_i,b_i \le n$，为什么是 $n$ 呢，为什么不是 $1e9$ 或 $1e18$ 呢？这其中一定有蹊跷，**并且一定是解题的关键**。

通常的思路为枚举区间，然后计算其中 $\operatorname{mex}$ 的最小值，但我们已经知道这个方法是行不通的，于是反其道而行之，**考虑是否可以枚举 $\operatorname{mex}$ 的值，然后计算区间的最大长度呢**？数据范围更是告诉我们这个方法的时间复杂度是足够小的，提示我们进一步思考如何操作。

枚举得到 $\operatorname{mex}$ 的值后如何计算其最大区间长度呢？通过观察容易发现，如果在一个子区间中没有 $a_i=b_i=x$ 的情况出现，那么其 $mex$ 值一定小于等于 $x$。

这是很好理解的，可以将 $a_i=b_i=x$ 看成一个针对 $x$ 的**屏障**，如果没有屏障的话，我们就可以在选择时用在 $a_i$ 与 $b_i$ 之间来回“走位”的方法避开所有的 $x$，从而让它成为 $\operatorname{mex}$ 的值，当然前提是没有比 $x$ 更小的可行解。

那么我们就可以记录 $x$ 为任意值时的屏障。这不会超时，因为屏障最多就 $n$ 个。屏障会把整个区间分成若干份，这些分出来的子区间的最大长度就是 $r-l+1$ 的最大值了，然后再减去 $\operatorname{mex}$ 即可。

但是有个问题，就如我们刚才所说，$\operatorname{mex}$ 的值为 $x$ 的前提是没有更好的可行解，所以这样算出来的值不一定是区间真实的值。而这其实是杞人忧天了，因为如果有更好的解的话，也一定会被枚举到的，并且虚假的值一定小于真实答案，所以对答案不造成影响，硬着头皮算就行了。

## code

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define ll long long
using namespace std;

int n,a[N],ans=-1e9;
vector<int> pos[N];

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1,b;i<=n;i++){
		b=read();
		if(b==a[i])pos[b].push_back(i); //记录x=b时的屏障的位置
	}
	for(int i=0;i<=n;i++){
		pos[i].push_back(n+1); //对所有的x在区间末尾加一个屏障，方便计算
		for(int j=0,before=1;j<pos[i].size();j++){
			ans=max(ans,pos[i][j]-before-i);
			before=pos[i][j]+1;
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：5k_sync_closer (赞：6)

题意：给定 $\{a_n\},\{b_n\}$，求 $\max\limits_{1\le l\le r\le n,c_i\in\{a_i,b_i\}}\{r-l+1-\mathop{\operatorname{mex}}\limits_{i=l}^rc_i\}$。
# Subtask 1
特殊条件：$1\le n\le 10$。$O(2^nn^2)$ 暴力枚举 $c_i,l,r$ 取值即可。
# Subtask 2
特殊条件：$a_i=b_i$。问题转化为给定 $\{c_n\}$，求 $\max\limits_{1\le l\le r\le n}\{r-l+1-\mathop{\operatorname{mex}}\limits_{i=l}^rc_i\}$。

注意到 $0\le c_i\le n$，考虑枚举 $x=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$，对每个 $x\in[0,n]$ 求出满足条件的最大 $r-l+1$。

$\forall i\in[l,r],c_i\neq x$ 是 $x=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$ 的必要条件，但我们可以升序枚举 $x$，然后把它当成充分条件来用。

证明：如果有 $\forall i\in[l,r],c_i\neq x\bigwedge x\neq\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$，那么一定有 $x>\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$，

而更小的 $x'=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$ 已经枚举过，且 $r-l+1-x'>r-l+1-x$，$x$ 不会对答案造成影响。

问题转化为对每个 $x\in[0,n]$ 求 $\max\limits_{1\le l\le r\le n,\forall i\in[l,r],c_i\neq x}r-l+1$。

考虑正序扫一遍 $\{c_n\}$，记录 $p_k$ 为 $k$ 上次出现的位置，$s_k$ 为当前 $\max\limits_{1\le l\le r\le n,\forall i\in[l,r],c_i\neq k}r-l+1$；

扫到 $c_i$ 时，用 $i-p_{c_i}-1$ 更新 $s_{c_i}$（$l=p_{c_i}+1,r=i-1$），再更新 $p_{c_i}\gets i$。

$\forall k\in[0,n],p_k=0$，这样就考虑了 $l=1$ 的情况；扫完后，用 $n-p_{k}$ 更新 $s_k$，这样就考虑了 $r=n$ 的情况。

以上，我们对每个 $x\in[0,n]$ 求出了满足 $x=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$ 的最大 $r-l+1$，$O(n)$ 枚举 $x$ 即可。
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, q, c[1000050], p[1000050], s[1000050];
int main()
{
    scanf("%d", &n);
    for(int i = 1;i <= n;++i) scanf("%d", c + i),
    s[c[i]] = max(s[c[i]], i - p[c[i]] - 1), p[c[i]] = i;
    for(int k = 0;k <= n;++k) s[k] = max(s[k], n - p[k]);
    for(int x = 0;x <= n;++x) q = max(q, s[x] - x);
    return printf("%d", q), 0;
}
```
# Subtask 3
仍然考虑枚举 $x=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$，对每个 $x\in[0,n]$ 求出满足条件的最大 $r-l+1$。

$\forall i\in[l,r],a_i\neq x\bigvee b_i\neq x$ 是 $x=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$ 的必要条件，升序枚举 $x$，可以把它当成充分条件来用。证明同上。

考虑正序扫一遍 $\{a_n\},\{b_n\}$，当 $a_i=b_i$ 时更新 $s_{a_i}$ 和 $p_{a_i}$。注意考虑 $l=1$ 和 $r=n$ 的情况。

以上，我们对每个 $x\in[0,n]$ 求出了满足 $x=\mathop{\operatorname{mex}}\limits_{i=l}^rc_i$ 的最大 $r-l+1$，$O(n)$ 枚举 $x$ 即可。
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, q, a[1000050], b[1000050], p[1000050], s[1000050];
int main()
{
    scanf("%d", &n);
    for(int i = 1;i <= n;++i) scanf("%d", a + i);
    for(int i = 1;i <= n;++i) scanf("%d", b + i);
    for(int i = 1;i <= n;++i) if(a[i] == b[i])
    s[a[i]] = max(s[a[i]], i - p[a[i]] - 1), p[a[i]] = i;
    for(int k = 0;k <= n;++k) s[k] = max(s[k], n - p[k]);
    for(int x = 0;x <= n;++x) q = max(q, s[x] - x);
    return printf("%d", q), 0;
}
```


---

## 作者：Mars_Dingdang (赞：3)

赛后 VP 的时候 AK 了，补题解。整套比赛题解[见此](https://www.cnblogs.com/Mars-LG/p/16516484.html)。

## 题目大意
给定序列 $\{a_n\},\{b_n\}$，求一个序列 $\{c_n\}$ 满足 $\forall i\in[1,n],c_i\in\{a_i,b_i\}$，最大化

$$\max\{r-l+1-\operatorname{mex}\{c_l,c_{l+1},\dots, c_{r-1},c_r\}\}(1\le l\le r\le n)$$

并输出该式子可能的最大值。

$1\le n\le 10^6$，$0\le a_i, b_i\le n$。

## 大体思路
由于 $c_i=\{a_i, b_i\}$，显然当 $a_i=b_i$ 的时候 $c_i$ 唯一确定，其他情况 $c_i$ 均有两种选择。

由于数据范围中 $a_i,b_i\le n$，启示我们可以枚举 $\text{mex}$。

具体地，假设当前枚举的 $\text{mex}=v$，我们记录所有 $a_i=b_i=v$ 的位置。这些位置是必然影响 $\text{mex}$ 取值的，而其他 $a_i\neq b_i$ 但其中一个为 $v$ 的位置，令 $c_i=a_i+b_i-v$ 即可避免影响。同时，这些位置 $i$ 将序列划分成若干段，选择长度最大的一段作为 $len_v=r-l+1$，答案为 $len_v-v$。

这样有一个问题，就是选择的一段的 $\text{mex}$ 可能 $\le v$。不过，如果整段中都存在 $v'=\text{mex}<v$，其贡献至少为 $len_v-v'>len_v-v$，而题目要求最大化这一值，因此 $len_v-v$ 也就不会产生贡献了。因此这样直接计算也能保证正确性。

```cpp
	read(n);
	rep(i, 1, n) read(a[i]);
	rep(i, 1, n) {
		read(b[i]);
		if(a[i] != b[i]) continue;
		len[a[i]] = max(len[a[i]], i - lst[a[i]] - 1);
		lst[a[i]] = i;
	}
	rep(v, 0, n) {
		len[v] = max(len[v], n - lst[v]);
		ans = max(ans, len[v] - v);
	}
	writeln(ans);
```

---

## 作者：cmk666 (赞：3)

[题目链接](/problem/P8445)

题意简述：给定序列 $a$，$b$，构造 $c_i\in\{a_i,b_i\}$ 并从中选一段区间，最大化 $\operatorname{len}-\operatorname{mex}$。

发现 $\operatorname{mex}$ 这个东西很难搞，再加上值域 $[0,n]$，考虑枚举 $\operatorname{mex}$。接下来就是选一段区间来最大化 $\operatorname{len}$。

显然，当 $a_i=b_i$ 时，$c_i$ 也就随之确定。

那么，当 $a_i=b_i=\operatorname{mex}$ 时选的区间一定不包含 $c_i$。换句话说，所有满足 $a_i=b_i=\operatorname{mex}$ 的 $i$，把序列分成了许多小区间，每次只能在一个小区间里选。为了最大化 $\operatorname{len}$，我们选择最大的那一整个区间。最大的块只要预处理一下即可。这时候就有一个问题：

$Q$：这个小块里实际的 $\operatorname{mex}$ 要是和枚举的 $\operatorname{mex}$ 不一样怎么办呢？

$A$：把枚举的 $\operatorname{mex}$ 记作 $x$，实际的 $\operatorname{mex}$ 记作 $y$。首先，因为 $x$ 一定没有出现过，故 $y$ 不大于 $x$。其次，当 $y<x$ 时，对于这个区间，选 $y$ 的答案要比选 $x$ 的要大（因为 $\operatorname{len}$ 不减少而 $\operatorname{mex}$ 变小）。又因为 $y$ 也会被枚举到，因此这个答案肯定会被更新掉。所以没必要考虑 $x\not=y$ 的问题。

总时间复杂度 $O(n)$。主要代码如下：
```cpp
int n, a[1000009], b[1000009], c[1000009] = { 0 }, l[1000009], ans;
int main()                   //c[i]是以i分割最大块长
{
	read(n); For(i, 0, n) l[i] = 1;
	For(i, 1, n) read(a[i]); For(i, 1, n) read(b[i]);
	For(i, 1, n) if ( a[i] == b[i] )             //分割出一个块
		c[a[i]] = max(c[a[i]], i - l[a[i]]), l[a[i]] = i + 1;
	For(i, 0, n) c[i] = max(c[i], n + 1 - l[i]); //最后一个块
	For(i, 0, n) ans = max(ans, c[i] - i);
	return printf("%d\n", ans), 0;
}
```
彩蛋：这个蒟蒻把值域 $[0,n]$ 搞成 $[1,n]$ 然后 $\text{AK}\to390$……

---


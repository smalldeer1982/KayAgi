# 虹色的北斗七星

## 题目背景

**【题目背景与题意无关，可以直接阅读题目描述】**

（本题目背景部分改编自真实案例）

宇佐见莲子是外界的一名大学生，在京都的一所大学中专攻超统一物理学，最近在做弦论方面的研究。

莲子与梅莉一同经营着名为秘封俱乐部的社团。进行着在科学世纪探寻遍布四处的结界的活动。

这个月梅莉和莲子又商量着去进行新一轮的探索与发现与贴贴，但是在两人手牵手出门的时候甜腻腻的气氛却被一通电话打破。

莲子因为经常外出探险，同时与梅莉增进感情交流，所以作业一拖再拖。她的物理学教授忍无可忍（毕竟莲子可是拖了一个学期的物理作业一个字都没有动呢），规定她必须在 $\sqrt9$ 天之内交上一篇学习报告，然后才同意给她的“课外实践活动”报备。

这可就没有办法了呢（笑），莲子只好先努力在 deadline 之前糊弄完她的学习报告，然后才能执行她们观赏夜空的计划。

## 题目描述

由于前两天都被莲子用来进行活动的筹备工作了，所以现在她只有几分钟的时间糊弄作业。尽管这样不太好，但是她别无选择，只能从之前的课堂笔记中摘取一段内容。

莲子的课堂笔记共有 $n$ 章，每章分别记着不同的内容。她可以选择其中任意连续的一段 $[l,r]$（表示选取了第 $l$ 章到第 $r$ 章）作为最终的成果。

每一章的内容各不相同，老师对每章内容有一个评价分 $a_i$。因为学习报告要体现出学生的进步，所以老师的满意度将会加上其中最差（$\min\{a_i\}$）和最好章节（$\max\{a_i\}$）的评价分差距。因为直接把冗长的课堂笔记作为报告提交显得太敷衍，所以每存在一章内容，老师的满意度就会 $-1$。

形式化地来说，如果莲子提交了 $[l,r]$ 这一段区间的笔记，老师的满意度将会是 $\max\{a_l,a_{l+1},\cdots,a_r\}-\min\{a_l,a_{l+1},\cdots,a_r\}-(r-l+1)$。

莲子希望你能帮她找出一种使得老师的满意度最大的方案。因为她非常聪明，所以只需要你告诉她这个最大的满意度，她就会知道应该怎么做。

**【形式化题意】**

你有一个长度为 $n$ 的序列 $a$，它的一个区间 $[l,r]$ 的价值是 $\max\{a_l,a_{l+1},\cdots,a_r\}-\min\{a_l,a_{l+1},\cdots,a_r\}-r+l-1$。求这个序列价值最大的子区间并输出这个价值。

## 说明/提示

**【样例解释和说明】**

令 $l=4,r=5$，则有 $\min\{a_4,a_5\}=2$，$\max\{a_4,a_5\}=8$，贡献值为 $4$。易证这是满意度最大的子区间。

**【数据范围】**

- 对于 $20\%$ 的数据，$n\leq 5\times 10^3$。
- 另有 $20\%$ 的数据，所有的 $a_i$ 都相等。
- 对于 $100\%$ 的数据，$1\le n\le 4\times10^6$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
6
5 2 4 2 8 8```

### 输出

```
4```

# 题解

## 作者：retep (赞：28)

## 题目简述

你有一个长度为 $n$ 的序列 $a$，它的一个区间 $[l,r]$ 的价值为：

$\max\{a_l,a_{l+1},\cdots,a_r\}-\min\{a_l,a_{l+1},\cdots,a_r\}-r+l-1$。

求这个序列价值最大的子区间并输出这个价值。

数据范围：$1\le n\le 4\times10^6$，$1 \leq a_i \leq 10^9$

题目传送门：[P8446 虹色的北斗七星](https://www.luogu.com.cn/problem/P8446)

## 题目分析

这是道最优化问题，关键点在于对问题的转化。

题目中最显而易见的一点是 $\max$ 与 $\min$ 的位置一定是该区间的两个端点。

说实话这题本蒟蒻在比赛时想了很久，从动态规划到二分答案甚至连分治都考虑过，不过全部以不可行告终 ~~要不是普及组不能超纲，我肯定浪费更多时间~~。

我发现自己在之前的思考中都潜意识地将 $r-l+1$ 视作一个整体，也就是区间的长度，毕竟题目中也是用长度的意义来叙述的。

意识到这点后我开始想，是不是可以将 $r-l+1$ 分开呢？$1$ 很好说，只是个常量。关键在于 $r-l$，它俩其中一个是 $\max$ 的下标，另一个则是 $\min$ 的下标。

如果可以将 $r$ 与 $l$ 和 $\max$ 与 $\min$ 融合在一起就好了，因为那样的话就不用再受区间长度所困扰，只要求最大值和最小值就行了。可惜的是我们并不知道 $\max$ 和 $\min$ 哪个对应 $r$ 哪个对应 $l$ ......

于是乎，分类讨论！

1. 当 $\max$ 对应的下标是 $r$，也就是 $\max$ 在 $\min$ 右边时：$(\max-r)-(\min-l)-1$

2. 当 $\max$ 对应的下标是 $l$，也就是 $\max$ 在 $\min$ 左边时：$(\max+l)-(\min+r)-1$

解释一下，如果是第一种情况的话，我们建立 $b$ 数组，使 $b_i=a_i-i$，然后计算区间价值时，直接计算:

$$b_i-b_j-1=a_i-a_j-i+j-1$$

可以看出这时算出来的值正好是区间的价值。第二种情况的话使 $b_i=a_i+i$ 然后同理。 

到这儿，我们已经可以将原问题转换为两个子问题了：

1. $b_i=a_i-i$，求 $b_i-b_j-1$ 的最大值，保证 $i>j$。

2. $b_i=a_i+i$，求 $b_j-b_i-1$ 的最大值，保证 $i>j$。

最后将两个子问题合并，既取其中的最大值，就得到了问题的最终答案。

## code
```cpp
#include<bits/stdc++.h>
#define N 4000005
#define ll long long
using namespace std;

int n,a[N],b[N],ans=-1;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}

int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),b[i]=a[i]-i;
	for(int i=1,mn=1e9;i<=n;i++){
		mn=min(b[i],mn);
		ans=max(ans,b[i]-mn);
		b[i]=a[i]+i;
	}
	for(int i=1,mx=-1e9;i<=n;i++){
		mx=max(b[i],mx);
		ans=max(ans,mx-b[i]);
	}
	cout<<ans-1;
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：11)

题意：给定 $\{a_n\}$，找出一个区间，使得其极差减长度最大。
# Subtask 1
特殊性质：$n\le5\times10^3$。$O(n^2)$ 枚举 $l,r$ 即可。
# Subtask 2
特殊性质：所有的 $a_i$ 都相等。注意到所有区间的极差都是 $0$，最小区间长度为 $1$，输出 $-1$ 即可。
# Subtask 3
不难发现，所求区间的两个边界一定对应两个最值。

证明：考虑反证法，设最优区间的一个边界不是最值。

将这个边界位置删除后，区间极差不变，长度 $-1$，得到了更优的区间，假设不成立。

分类讨论左右边界 $l,r$ 对应的最值。

- $a_l=\min\limits_{_i=l}^ra_i,a_r=\max\limits_{i=l}^ra_i$ 时 $\max\limits_{i=l}^ra_i-\min\limits_{_i=l}^ra_i-r+l-1=(a_r-r)-(a_l-l)-1$。

- $a_l=\max\limits_{i=l}^ra_i,a_r=\min\limits_{_i=l}^ra_i$ 时 $\max\limits_{i=l}^ra_i-\min\limits_{_i=l}^ra_i-r+l-1=(a_l+l)-(a_r+r)-1$。

问题转化为两个子问题：

- 找出 $l,r$，使得 $1\le l\leq r\leq n$ 且 $(a_r-r)-(a_l-l)-1$ 最大。
- 找出 $l,r$，使得 $1\le l\leq r\leq n$ 且 $(a_l+l)-(a_r+r)-1$ 最大。

原问题结果为两个子问题结果的最大值。

对于子问题一，枚举 $r$，维护前缀最小值 $x=\min\limits_{i=1}^r\{a_i-i\}$，用 $(a_r-r)-x-1$ 更新答案。

对于子问题二，枚举 $r$，维护前缀最大值 $y=\max\limits_{i=1}^r\{a_i+i\}$，用 $y-(a_r+r)-1$ 更新答案。
# Code
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, x = 1e9, y = -1e9, q = -1e9;
int main()
{
    scanf("%d", &n);
    for(int i = 1, a, b, c;i <= n;++i)
    {
        scanf("%d", &a);
        x = min(x, b = a - i);y = max(y, c = a + i);
        q = max(q, b - x - 1);q = max(q, y - c - 1);
    }
    return printf("%d", q), 0;
}
```


---

## 作者：Svemit (赞：10)

[cnblogs](https://www.cnblogs.com/Svemit/p/17375216.html)

[传送门](https://www.luogu.com.cn/problem/P8446 "传送门")
### 前言：
很久之前做的一道题目了，当时并没有想出来怎么做，随便猜了个结论交上去发现过了。（~~好像还是第一道自己做出来的绿~~）

### 简要题意：
你有一个长度为 $n$ 的序列 $a$，一个区间 $[l, r]$ 的价值定义为当前区间的极差减去区间长度，求出最大的价值。

### $Solution$：
看了看题解，发现大多数都是说 $l, r$ 对应的数字一定是一个最大一个最小，然后枚举其中一个端点。

真的需要大力分讨吗？？？

考虑单调队列的思想（~~当时还没学欸~~)，不能用的答案我们就及时排除掉。
假设当前最大值的位置是 $mxpos$，最小是 $mnpos$，最大数最小数分别是 $mx, mn$，并且此时遍历到 $a_i$，如果 $a_i < mn$ 的话，那么 $mn$ 就变成 $a_i$，贡献是很好算的，如果 $a_i > mn$ 的话，相当于区间长度增加了 $1$，怎么做呢？将 $mn = mn + 1$ 就行了，最大值用相似的方法处理就行了，就等价与贡献减小了 $1$，遍历过程中用 $res = \max (mx - mn - 1, res)$ 更新答案即可。

### code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5, INF = 1 << 30;
const ll mod = 1e9 + 7;
int n, mn = INF, mx = -INF, res = -1;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for(int i = 1, x;i <= n;i ++)
	{
		cin >> x;
		mn = min(mn + 1, x), mx = max(mx - 1, x);
		res = max(res, mx - mn - 1);
	}
	cout << res;
    return 0;
}
```


---

## 作者：minstdfx (赞：5)

UPD: 晚上脑子抽了打错字了，感谢铃酱纠错
### 简要题意
给定一个长度为 $n$ 的序列，求一个区间使得极差减长度最大。
### 分析题目
设区间 $[i,j]$ 的端点之差减长度为 $A_{i,j}$，极差减长度为 $B_{i,j}$，则 $A_{i,j} \le B_{i,j}$。

假设我们现在访问到一个区间 $[l,r]$，最小值的位置在 $a$，最大值在 $b$。  
显然如果我们把 $s$ 和 $t$ 作为左右端点，那么区间长度变小，极差不变，答案 $B_{l,r} \le B_{\min\{a,b\},\max\{a,b\}}=A_{\min\{a,b\},\max\{a,b\}}$ 更优。

因此作为答案的子区间一定满足极值在端点处取到。

同理，如果作为答案的子区间是 $[l,r](A_{l,r}=B_{l,r})$，那么它显然也是所有子区间里面，$A_{l,r}$ 最大的。

证明考虑反证法，假设此时 $[s,t]$ 更优（$B_{s,t}>B_{l,r}$）但 $A_{l,r}>A_{s,t}$，则 $A_{s,t} = B_{s,t}$，推出矛盾。

这样只要找到最小的 $A_{i,j}$ 就可以 $\Theta(n^2)$ 解决问题了。

稍微随手优化一下就线性了。
### 算法流程
考虑找每一个区间最大的 $A_{i,j}(i\le j)$。以下令 $l=j-i+1$。

$$\because A_{i,j}=|a_i-a_j|-l=\max\{a_i-a_j-l,a_j-a_i-l\}$$

$$\therefore ans=\max_{1 \le i \le j \le n}\{\max\{a_i-a_j-l,a_j-a_i-l\}\} $$

$$\therefore ans=\max\{\max_{1 \le i \le j \le n}\{a_i-a_j-l\},\max_{1 \le i \le j \le n}\{a_j-a_i-l\}\}$$

对于 $\max_{1 \le i \le j \le n}\{a_j-a_i-l\}$ 我们可以令 $b_k=a_k-k$，这样 $a_j-a_i-l=a_j-a_i-j+i-1=b_j-b_i-1$。

另一项同理。

随便扫两次就出来了喵。
### 代码
超，原来我没有提交这道题啊，又嘴巴验题可太刑了，大家不要学。
### 后话
看到题目背景的改编自真实案例吗？

可惜我还是没有像秘封组一样的同伴。

---

## 作者：南阳刘子骥 (赞：4)

贪心好题。

----

首先我们可以确定一点，就是我们选取的区间肯定是越短越好。

那么我们对于一个随机选定的区间，在确定了其最大值和最小值之后，我们可以尝试缩小这个区间的长度，在不改变区间最值的前提下，我们的答案较之前肯定会更优，因为区间长度对答案是有着负贡献的。

借着这个思想，我们可以不断缩小区间长度，直到再次缩小就会改变区间长度为止。  
这种情况肯定就是遇到了区间最值了，此时区间的最值就在区间的左右端点处。

但我们并不知道到底哪个是最大值，哪个是最小值。

我们发现可能的情况只有两种，那就直接大力讨论。

对于右端点大于左端点的情况，我们的式子就是 $a_r - a_l - r + l - 1$。  
结合一下，可以得到 $(a_r - r)-(a_l - l)-1$。  
我们可以以 $O(n)$ 的时间复杂度扫一遍 $a_i - i$ 来求出答案。我们可以贪心地认为每一个扫到的值都只从当前最小值取得贡献，所以我们只需要扫出来一个最小值，同时对于每一个扫到的值更新答案即可。

对于左端点大于右端点的情况，我们的式子就是 $a_l - a_r - r + l - 1$。  
结合一下，可以得到 $(a_l + l)-(a_r + r)-1$。
这一次我们仍然用扫的，只不过倒着扫，因为右端点需要更小。或者不扫最小值改为扫最大值也可以。

别忘了最后答案需要减去 $1$。

然后就是放代码了：

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 4000010;
int n;
int a[N];
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	int minn = 0x3f3f3f3f, maxn = -0x3f3f3f3f;
	for(int i = 1; i <= n; i++)
	{
		minn = min(minn, a[i] - i);
		maxn = max(maxn, a[i] - i - minn);
	}
	int res = maxn;
	minn = 0x3f3f3f3f, maxn = -0x3f3f3f3f;
	for(int i = n; i >= 1; i--)
	{
		minn = min(minn, a[i] + i);
		maxn = max(maxn, a[i] + i - minn);
	}
	res = max(res, maxn);
	printf("%d\n", res - 1);
	return 0;
}
```



---

## 作者：Miraik (赞：3)

没脑子不会推性质，丢一个不用脑子的做法。

容易发现：若答案段为 $i$ 到 $j$，那么 $a_i$ 和 $a_j$ 必然一个为区间最大值，一个为区间最小值。

然后枚举 $a_i$ 作为最大值，考虑前面的 $j$ 与 $k$，化简得 $j$ 到 $i$ 比 $k$ 到 $i$ 优当且仅当 $a_j-j < a_k-k$，根据这个维护单调队列即可。

注意我们一般维护单调队列队首是通过长度限制，在此题中是通过数字大小限制（若 $a_i$ 能作为最大值，那么显然 $a_j \le a_i$）

你珂能会问这样为什么能保证队列保持单调性？为什么能保证每次队列中的值都是合法的？那是因为 $j$ 在队列中比 $k$ 靠前当且仅当 $a_j-j < a_k-k$，而 $j<k$，易得 $a_j<a_k$，这样就保证了每次留在队列的值都是**单调且合法**的，也就证明了这个做法的正确性。

同理再枚举一遍 $a_i$ 作为最小值，最后得到的就是答案。

[代码](https://www.luogu.com.cn/paste/19dbwefk)

---

## 作者：cmk666 (赞：1)

[题目链接](/problem/P8446)

题意简述：给你一个序列 $a$，选择一段区间，最大化 $\max-\min-\operatorname{len}$。

为方便起见，下文把 $\max-\min-\operatorname{len}$ 记作 $W$。

显然在答案区间中，$\max$一定在区间的一端。如果 $\max$ 不在区间的一端，我们假设 $\min$ 在 $\max$ 左边，则把 $\max$ 右边的数全部删掉，$\operatorname{len}$ 会减小而 $\max$ 和 $\min$ 都不变，那么 $W$ 变大，即存在一个更好的答案。当 $\min$ 在 $\max$ 右边时同理。

由于 $\max$ 在区间左端或右端是本质一样的问题，只需正反各做一遍即可，所以下文只会讲述 $\max$ 在区间右端的做法。

首先，我们可以枚举 $\min$，并找到 $\min$ 右边对 $W$ 贡献最大的 $\max$，所有答案取最大值即可。现在有两个问题：

$Q_1$：怎么保证 $\min\sim\max$ 这段区间内没有值在 $[\min,\max]$ 之外的数？

$A_1$：没必要保证。假设区间里有比 $\min$ 小的数 $\min'$，那肯定存在一种方案，选择 $\min'\sim\max$ 这段区间，它的 $\min$ 和 $\operatorname{len}$ 值都比原来小，则 $W$ 增大。若区间里有比 $\max$ 大的数时同理。所以如果有值在 $[\min,\max]$ 之外的数的话，那么当前选择的区间一定不会成为答案，会被更新掉。

$Q_2$：怎么找 $\min$ 右边对 $W$ 贡献最大的 $\max$？

$A_2$：设 $\min=a_l$，$\max=a_r$。令 $f_i$ 表示 $a_i$ 右边对 $W$ 贡献最大的值为 $a_{f_i}$。易知 $W=a_r-a_l-(r-l+1)=(a_r-r)-(a_l-l)-1$。考虑令 $b_i=a_i-i$，那么 $W=b_r-b_l-1$。显然 $b_l$ 不变，只需要找 $b$ 里在第 $l$ 个及以后且最大的 $b$ 值的下标作为 $f_l$。预处理即可。

总时间复杂度 $O(n)$，可以通过本题 ~~（虽然常数贼大）~~。

主要代码：
```cpp
int n, a[4000009], b[4000009], f[4000009], ans = -1, maxn, maxp;
const int N = 1145141919;
inline void work()
{
	maxn = -N, maxp = N; //这里maxn一定要足够小，因为b[i]=a[i]-i可能会小于0
	For(i, 1, n) b[i] = a[i] - i;
	Fol(i, n, 1)         //预处理f
	{
		f[i] = maxp;
		if ( maxn < b[i] ) maxn = b[i], maxp = i;
	}
	For(i, 1, n) if ( f[i] != N ) ans = max(ans, b[f[i]] - b[i] - 1);
}
int main()
{
	read(n); For(i, 1, n) read(a[i]);
	work(); reverse(a + 1, a + n + 1), work(); //正反各做一遍
	return printf("%d\n", ans), 0;
}
```

---

## 作者：_lmh_ (赞：1)

### 做法

注意到左右端点必须一个最大一个最小，否则将两边的部分删掉结果一定更好。

用四个变量记录最大值及其编号，和最小值及其编号。

#### 注意最大值和最小值并非整个已遍历数组的最大最小值，而是把它作为左端点并且是最大最小值时最优的两个数

比如说，$a_1=5,a_2=2,a_3=4,a_4=2$，在遍历到第三个数的时候，因为将它作为左端点（最大值）的时候满意度比第一个数高，所以将它作为左端点。

对于可能的最大值 $a_u$ 和 $a_v(u<v)$，设右端点，即最小值为 $a_r$，那么第一个的分数为 $a_u-a_r-r+u-1$，第二个的分数为 $a_v-a_r-r+v-1$，所以当 $a_u+u<a_v+v$ 的时候，即使 $a_v$ 可能小于 $a_u$，我们仍然认为它更好。

对于最小值则同理，但条件为 $v-a_v>u-a_u$。

同时，如果右端点不再是真正的最小（最大）值，根据先前的推导可知它一定小于正确答案，因此不用考虑。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=4000007;
inline int read(){
	int x=0;bool flag=1;char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') flag=0;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return (flag?x:~(x-1));
}
int n,a[N],ans=-1,mx,mxnum,mn,mnnum;
int main(){
	n=read();
	for (int i=1;i<=n;++i) a[i]=read();
	mx=mn=a[1];mxnum=mnnum=1;
	for (int i=2;i<=n;++i){
		ans=max(ans,max(mx-a[i]-i+mxnum-1,a[i]-mn-i+mnnum-1));
		if (a[i]-mx>mxnum-i){
			mx=a[i];mxnum=i;
		}
		else if (mn-a[i]>mnnum-i){
			mn=a[i];mnnum=i;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：rzh123 (赞：0)

# P8446 题解  

题目链接：[P8446 虹色的北斗七星](https://www.luogu.com.cn/problem/P8446)  

就是找一个区间 $[l,r]$，使 极差 $-$ 长度 最大。  

首先，区间的边界一定是最大值或最小值。证明：  

反证法，设最优的区间为 $[l,r]$，$a_l\neq \max\{a_l,a_{l+1},\cdots,a_r\}$ 且 $a_l\neq \min\{a_l,a_{l+1},\cdots,a_r\}$，则对于区间 $[l+1,r]$，只删除 $a_l$，不影响最大值、最小值，极差不变，长度 $-1$，所以 $[l+1,r]$ 比 $[l,r]$ 更优，假设不成立，所以 $a_l$ 必须是最小值或最大值。  

同理可以证明 $a_r$ 必须是最小值或最大值。  

然后，拆开题目的式子。  

分两种情况：  

当 $a_l=\min\{a_l,a_{l+1},\cdots,a_r\}$ 时，  

$$
\begin{aligned}
& \max\{a_l,a_{l+1},\cdots,a_{r}\}-\min\{a_l,a_{l+1},\cdots,a_{r}\}-r+l-1 \\ 
= & (\max\{a_l,a_{l+1},\cdots,a_{r}\}-r)-(\min\{a_l,a_{l+1},\cdots,a_{r}\}-l)-1 \\
= & (a_r-r)-(a_l-l)-1
\end{aligned}
$$  

当 $a_l=\max\{a_l,a_{l+1},\cdots,a_r\}$ 时，  

$$
\begin{aligned}
& \max\{a_l,a_{l+1},\cdots,a_{r}\}-\min\{a_l,a_{l+1},\cdots,a_{r}\}-r+l-1 \\ 
= & (\max\{a_l,a_{l+1},\cdots,a_{r}\}+l)-(\min\{a_l,a_{l+1},\cdots,a_{r}\}+r)-1 \\
= & (a_l+l)-(a_r+r)-1
\end{aligned}
$$  

先预处理出 $a_i-i$ 的前缀最大值、$a_i+i$ 的后缀最大值，然后分类讨论。  

预处理出以下内容：  

$b_i=a_i-i$  

$c_i=a_i+i$

$b_i$ 的前缀最大值 $\text{bf}_i=\max\{b_1,b_2,\cdots,b_i\}$  

$c_i$ 的后缀最大值 $\text{cf}_i=\max\{b_i,b_{i+1},\cdots,b_n\}$  

其中 $\text{bf}_i$ 可以由 $\text{bf}_{i-1}$ 递推得到，$\text{cf}_i$ 可以由 $\text{cf}_{i+1}$ 递推得到。  

第一种情况，枚举 $r$，用 $b_r-\text{bf}_{r-1}-1$ 更新答案。  

第二种情况，枚举 $l$，用 $c_l-\text{cf}_{l+1}-1$  更新答案。  

时间复杂度 $\mathcal{O}(n)$。  

代码：  

```cpp
#include <bits/stdc++.h>
#define gc getchar()
#define pc(c) putchar(c)
using namespace std;
constexpr int N=4000007,LGN=23;
int n,a[N],b[N],c[N];
int bf[N],cf[N];
inline int read(){
	register int t=0,f=1;
	register char c=gc;
	while(c!='-'&&(c<'0'||c>'9')) c=gc;
	if(c=='-') c=gc,f=-1;
	while(c>='0'&&c<='9') t=10*t+(c^48),c=gc;
	return f*t;
}
void write(int x){
	if(!x) return (void)pc('0');
	if(x<0) pc('-'),x=-x;
	static char c[23]={""};
	static int cc=0;
	while(x) c[++cc]=x%10,x/=10;
	while(cc) putchar(c[cc--]|48);
}
signed main(){
	long long ans=-1;
	n=read();
	if(n==1){
		return puts("-1"),0;
	}
	for(int i=1;i<=n;++i){
		a[i]=read();
		b[i]=a[i]-i;
		c[i]=a[i]+i;
	}
	bf[0]=INT_MAX;
	cf[n+1]=INT_MAX;
	for(int i=1;i<=n;++i){
		bf[i]=min(bf[i-1],b[i]);
	}
	for(int j=n;j>=1;--j){
		cf[j]=min(cf[j+1],c[j]);
	}
	for(int i=n;i>=2;--i){
		ans=max(ans,1ll*b[i]-bf[i-1]-1);
	}
	for(int i=1;i<=n-1;++i){
		ans=max(ans,1ll*c[i]-cf[i+1]-1);
	}
	write(ans),puts("");
	return 0;
}
```

---

## 作者：Bot_wxt1221 (赞：0)

[题目传送门](/problem/P8446)

题意：
你有一个长度为 $n$ 的序列 $a$，它的一个区间 $[l,r]$ 的价值是 $\max\{a_l,a_{l+1},\cdots,a_r\}-\min\{a_l,a_{l+1},\cdots,a_r\}-r+l-1$。求这个序列价值最大的子区间并输出这个价值。

~~为什么又是区间~~
看到区间的题，有一种非常常用的方法是枚举右端点，确定左端点。这道题也不例外。

举个栗子：求区间最大值，我的做法是记录前面前缀和的最大值，再用当前的前缀和减前面的前缀和更新答案。

代码片段（非本题）：
```cpp
ans=0;
_min=0;
for(int i=1;i<=n;i++){
	now+=a[i];
	_min=min(_min,now);
	ans=max(ans,now-_min);
}
```

这个算法将答案分成两部分，分别是前面的前缀和以及后面的前缀和。
回到本题，先对式子一顿折腾：$(\max\{a_l,a_{l+1},\cdots,a_r\}+l)-(\min\{a_l,a_{l+1},\cdots,a_r\}+r+1)$~~没有太折腾~~

再分析一下题，区间的端点应该在最大值和最小值上，因为他要是区间越小越好。

假设说最小值的端点在右边，那么在前面找到$\max\{a_l,a_{l+1},\cdots,a_r\}+l$的最大值，再减去$\min\{a_l,a_{l+1},\cdots,a_r\}+r+1$，为什么是这样的？

因为一旦确定最小值就相当于$\min\{a_l,a_{l+1},\cdots,a_r\}+r+1$已经被确定了。那只要让$\max\{a_l,a_{l+1},\cdots,a_r\}+l$（被减数 ）最大。

最小值的端点在左边怎么办？

翻转一遍就好了。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){
		c=='-'?f=-1:1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return f*x;
}
int a[4000005];
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int n=read();
	int ans=0;
	int mx=-1,re=-1;
	for(int i=1;i<=n;i++){
		a[i]=read();
		mx=max(mx,a[i]+i);
		re=max(re,mx-a[i]-i-1);
	}
	reverse(a+1,a+n+1);
	mx=-1;
	for(int i=1;i<=n;i++){
		mx=max(mx,a[i]+i);
		re=max(re,mx-a[i]-i-1);
	}
	printf("%lld",re);
	return 0;
}



```


---


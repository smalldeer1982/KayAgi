# [LSOT-1] 逆序对

## 题目背景

逆序对真好玩

## 题目描述

你需要维护一个数列，支持以下 $4$ 种操作：

1. 区间交换；
2. 把一个区间**向后**移动到第 $k$ 个数字与第 $k+1$ 个数字之间；
3. 在最后插入一个数 $x$；
4. 在开头插入一个数 $x$。

每个数数的序号为新序列重新从第一个数到第 $k$ 个数编号为 $1$ 到 $k$。

现在每次操作过后，请你输出整个数列逆序对数量的奇偶性。

## 说明/提示

【样例解释】

第一次操作将区间 $[1,1]$ 和区间 $[2,2]$ 交换，序列变为 `3 4 5 7 2 6`。

第二次操作将区间 $[1,1]$ 移动到第 $3$ 和第 $4$ 个数中间。序列变为 `4 5 3 7 2 6`。

第三次操作在序列末端插入 $11$，序列变为 `4 5 3 7 2 6 11`。

第四次操作在序列开头插入 $1$，序列变为 `1 4 5 3 7 2 6 11`。

【数据范围】

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(10 pts): }n,m\le 10^2$；
- $\texttt{Subtask 2(15 pts): }n,m\le 10^3$；
- $\texttt{Subtask 3(20 pts): }$没有一二操作；
- $\texttt{Subtask 4(20 pts): }$没有三四操作；
- $\texttt{Subtask 5(35 pts): }$无特殊限制。

对于 $100\%$ 的数据，$1\le n,m \le 2\times 10^5,a_i\le 2\times10^6$，保证在任意时刻 $a$ 中的数均互不相同。

## 样例 #1

### 输入

```
6 4
4 3 5 7 2 6
1 1 1 2 2
2 1 1 3
3 11
4 1```

### 输出

```
odd
odd
odd
odd```

# 题解

## 作者：sinestrea (赞：7)

我们应该如何求逆序对呢？那当然是——归...无旋 Treap！

对于每次插入一个新的数，新增的逆序对个数，就是左（或右）子树大小，那么我们在每一次插入新的节点时，返回左（或右）子树的大小就可以惹。

对于初始时输入的数据，每输入一个数字就插入到无旋 Treap 里，那么按值分裂后的两棵子树，左子树所有的值一定都小于这个值，右子树所有的值一定都大于这个值（题目保证在任意时刻 $a$ 中的数均互不相同），那么返回右子树的值就可以惹。

那么，对于操作 3 和操作 4，就是返回左右子树大小就好惹。

对于操作 1 和操作 2，我们可以看到，如果我们假设把一个数向一个方向移动，那么逆序对数量一定是增加 $1$ 或减少 $1$，所以奇偶性只和移动次数和移动距离多少有关，我们定义左区间为 $[L_1,R_1]$，右区间为 $[L_2,R_2]$，那么两个区间中间的区间就为 $[R_1 + 1,L_2 - 1]$，将其定义为 $[L,R]$；

那么对于操作 1：

$$( ((R_1-L_1+1) \times (R_2-L_2+1) + (R-L+1) \times (R_1-L_1+1) + (R-L+1) \times (R_2-L_2+1)) \bmod 2)$$

的值如果为 $1$，那么奇偶性改变，反之则不改变；

对于操作 2, 我们可以看到可以将其转化为操作 1，将第二个区间 $[R_1 + 1,K]$ 定义为 $[L_2, R_2]$；

那么对于操作 2：

$$((R_2 - L_2 + 1) \times (R_1 - L_1 + 1) \bmod 2)$$

的值如果为 $1$，那么奇偶性改变，反之则不改变；

代码：

```cpp
#include <bits/stdc++.h>

const int MAX = 5e5 + 5;

std::mt19937 GetRand(233);
// 生成伪随机数;

class CNode
{
public:
	int Data{}, Rand{}, Size{}, L{}, R{};
	// Data:数据项;
	// Rand:随机值;
	// Size:子树大小;
	// L:左子结点;
	// R:右子节点;
} Node[MAX];

class Treap
{
private:
	int Root{}, RootX{}, RootY{}, RootZ{}, Cnt{};
	// Root:根节点;
	// RootX ~ RootZ:以后要用到的暂存根节点;
	// Cnt:计数器（数组下标）;
public:
	inline int NewNode(int Data)
	{
		Node[++Cnt].Data = Data;
		Node[Cnt].Rand = GetRand();
		Node[Cnt].Size = 1;
		return Cnt;
	}
	// 新建节点

	inline void Update(int Now)
	{
		Node[Now].Size = Node[Node[Now].L].Size + Node[Node[Now].R].Size + 1;
	}
	// 更新节点左右子树大小;

	void Split(int Now, int Data, int &X, int &Y)
	{
		if (!Now)
		{
			X = Y = 0;
			return;
		}
		else if (Node[Now].Data <= Data)
		{
			X = Now;
			Split(Node[Now].R, Data, Node[Now].R, Y);
		}
		else
		{
			Y = Now;
			Split(Node[Now].L, Data, X, Node[Now].L);
		}
		Update(Now);
	}
	// 按值分裂，将"Now"节点，按照"Data"分裂成左子树"X"和右子树"Y";

	int Merge(int X, int Y)
	{
		if (!X || !Y)
			return X | Y;
		else if (Node[X].Rand <= Node[Y].Rand)
		{
			Node[X].R = Merge(Node[X].R, Y);
			Update(X);
			return X;
		}
		else
		{
			Node[Y].L = Merge(X, Node[Y].L);
			Update(Y);
			return Y;
		}
	}
	// 合并两棵树"X"和"Y";

	inline int Insert(int Data, bool Opt)
	{
		// Opt:操作;
		Split(Root, Data, RootX, RootY);
		int Ret{};
		if (Opt == 0)
			Ret = Node[RootY].Size;
		else if (Opt == 1)
			Ret = Node[RootX].Size;
		Root = Merge(Merge(RootX, NewNode(Data)), RootY);
		return Ret;
		// 如果输入为0，返回右子树大小，如果输入为1，返回右子树大小;
	}
	// 插入;
} Treap;

int N, M, Num, Opt, L1, L2, R1, R2, L, R, K;

bool Ans;

unsigned long long Test;

int main()
{
#ifndef ONLINE_JUDGE
	freopen("C:\\Users\\Guozhi\\CIO\\IN", "r", stdin);
	freopen("C:\\Users\\Guozhi\\CIO\\OUT", "w", stdout);
#endif
	// BEGIN
	std::cin >> N >> M;
	for (int i = 1; i <= N; i++)
	{
		std::cin >> Num;
		if (Treap.Insert(Num, 0) % 2)
			Ans ^= 1;
	}

	for (int i = 1; i <= M; i++)
	{
		std::cin >> Opt;
		if (Opt == 1)
		{
			std::cin >> L1 >> R1 >> L2 >> R2;
			L = R1 + 1;
			R = L2 - 1;
			if ((((R1 - L1 + 1) * (R2 - L2 + 1) + (R - L + 1) * (R1 - L1 + 1) + (R - L + 1) * (R2 - L2 + 1)) % 2))
				Ans ^= 1;
			if (Ans)
				std::cout << "odd" << std::endl;
			else
				std::cout << "even" << std::endl;
		}
		else if (Opt == 2)
		{
			std::cin >> L1 >> R1 >> K;
			L2 = R1 + 1;
			R2 = K;
			if (((R2 - L2 + 1) * (R1 - L1 + 1)) % 2)
				Ans ^= 1;
			if (Ans)
				std::cout << "odd" << std::endl;
			else
				std::cout << "even" << std::endl;
		}
		else if (Opt == 3)
		{
			std::cin >> Num;
			if (Treap.Insert(Num, 0) % 2)
				Ans ^= 1;
			if (Ans)
				std::cout << "odd" << std::endl;
			else
				std::cout << "even" << std::endl;
		}
		else if (Opt == 4)
		{
			std::cin >> Num;
			if (Treap.Insert(Num, 1) % 2)
				Ans ^= 1;
			if (Ans)
				std::cout << "odd" << std::endl;
			else
				std::cout << "even" << std::endl;
		}
	}
	// END
}
```

---

## 作者：Dr_Gilbert (赞：6)

# P8449 [LSOT-1] 逆序对

【题目大意】

你需要维护一个数列，支持以下 $4$ 种操作：

1. 区间交换；
2. 把一个区间**向后**移动到第 $k$ 个数字与第 $k+1$ 个数字之间；
3. 在最后插入一个数 $x$；
4. 在开头插入一个数 $x$。

现在每次操作过后，请你输出整个数列逆序对数量的奇偶性。

$n,m\le 2\times 10^5,a_i\le 2\times 10^6$，保证任意时刻 $a_i$ 互不相同。

---

第一眼看到这个题时，我想这是不是什么十分困难的数据结构题，事实上发现一些性质后这题就变得无比简单（

首先，假如没有操作 $1,2$，那相信大家应该都会做，只需要插入数时用树状数组统计一下新产生的逆序对数量即可。所以解决这道题目的关键就在于操作 $3,4$。我们又注意到，事实上并不需要真的求出逆序对个数，只询问当前逆序对个数的奇偶性，所以不妨考虑如何操作会让逆序对数的奇偶性发生变化。

经过一些观察，可以发现，交换任意两个数，都会使得逆序对数的奇偶性改变。不妨设交换 $a_i,a_j(i<j)$，按 $a_i,a_j$ 大小关系分类讨论：若 $a_i<a_j$，则交换后增加一个逆序对，奇偶性改变；若 $a_i>a_j$，则交换后减少一个逆序对，奇偶性改变。注意，这个结论成立的前提是 $a_i$ 互不相同。

所以对于操作 $1,2$，只需要计算执行操作需要进行多少次两数的交换即可。操作 $2$ 比较好考虑，交换数就是 $(r-l+1)\times (k-r)$。操作 $1$ 可以考虑成先让 $[l_1,r_1]$ 就位，再让 $[l_2,r_2] $ 就位计算即可。代码实现比较简单，参考代码如下：

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define lowbit(x) ((x)&(-x))
using namespace std;
const int N=2e6+10;
int bit[N],maxx,n;
void update(int x, int dlt){
	for (;x<=maxx;x+=lowbit(x)){
		bit[x]+=dlt;
	}
	return;
} 
int query(int x){
	int ret=0;
	for (;x;x-=lowbit(x)) ret+=bit[x];
	return ret;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);cout.tie(nullptr);
	int n,m,par=0;maxx=2e6;cin>>n>>m;
	for (int i=1;i<=n;i++){
		int x;cin>>x;
		int tmp=query(maxx)-query(x);
		par^=(tmp&1);update(x,1);
	}
	while (m--){
		int opt,l1,r1,l2,r2,x;cin>>opt;
		if (opt==1){
			cin>>l1>>r1>>l2>>r2;
			long long tmp=(r1-l1+1)*(l2-r1-1);
			tmp+=(r2-l2+1)*(l2-l1);par^=(tmp&1);
		}else if (opt==2){
			cin>>l1>>r1>>l2;
			long long tmp=(r1-l1+1)*(l2-r1);
			par^=(tmp&1);
		}else if (opt==3){
			cin>>x;int tmp=query(maxx)-query(x);
			par^=(tmp&1);update(x,1);
		}else if (opt==4){
			cin>>x;int tmp=query(x);
			par^=(tmp&1);update(x,1);
		}
		if (par) cout<<"odd"<<endl;
		else cout<<"even"<<endl;
	}
	return 0;
}
```



---

## 作者：Na2PtCl6 (赞：4)

### 寻找突破口
因为我们只关注答案的奇偶性，所以原数列长什么样已经不重要了，因此注意到所有操作都无后效性。

既然我们无法知道原序列的样子，我们就要想办法根据所给的区间长度来推算答案奇偶性变化。

### 严格证明
假设 $A$，$B$ 为需要交换的区间。设 $A$，$B$，$D$ 长度分别为 $n_1$，$n_2$，$n$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pcwl0nj4.png)

$A$，$C$，$E$ 整体位置位置不变，$B$，$C$，$E$ 整体位置也不变，故不贡献。

#### 对 $A$，$D$，$B$ 整体分析。

 对区间 $A$ 中每个元素，设 $D$ 中大于 $A_i$ 的元素个数为 $x_i$ 个，则 $D$ 中小于 $A_i$ 的元素个数为 $n-x_i$。

 对区间 $B$ 中每个元素，设 $D$ 中大于 $B_i$ 的元素个数为 $y_i$ 个，则 $D$ 中小于 $B_i$ 的元素个数为 $n-y_i$。

 故交换前这里有 $\displaystyle \sum^{r_1}_{i=l_1}(n-x_i)+\sum^{r_2}_{i=l_2}y_i$ 对逆序对,交换后有 $\displaystyle\sum^{r_1}_{i=l_1}x_i+\sum^{r_2}_{i=l_2}(n-y_i)$
 对。

 前 $-$ 后 $=\displaystyle2\sum^{r_1}_{i=l_1}x_i-2\sum^{r_2}_{i=l_2}y_i+n(n_2-n_1)$
 故这部分奇偶性由 $n(n_2-n_1)$ 决定。

#### 对 $A$，$B$ 整体分析。
 对区间 $A$ 中每个元素，设 $B$ 中小于 $A_i$ 的元素个数为 $c_i$ 个。

 对区间 $B$ 中每个元素，设 $A$ 中大于 $B_i$ 的元素个数为 $d_i$ 个，则 $A$ 中小于 $B_i$ 的元素个数为 $n_1-d_i$个。

 交换前有 $\displaystyle \sum^{r_1}_{i=l_1}c_i$ 对逆序对，交换后有 $\displaystyle\sum^{r_2}_{i=l_2}(n_1-d_i)$ 对逆序对。
 
 $$∵\sum^{r_1}_{i=l_1}c_i=\sum^{r_2}_{i=l_2}d_i$$
 $$∴\sum^{r_1}_{i=l_1}c_i-\sum^{r_2}_{i=l_2}(n_1-d_i)=2\sum^{r_1}_{i=l_1}c_i-n_1n_2$$
 故这部分的奇偶性由 $n_1 n_2$ 决定。

至此，我们证明了操作一给奇偶性带来的变化由 $n(n_2-n_1)+n_1n_2$ 决定，只是写代码的时候为了避免出现负数，写成 $n(n_2+n_1)+n_1n_2$。

操作二可以转化为交换 $[l,r]$ 和 $[r+1,k]$。

操作三和操作四用树状数组维护即可。
### 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2000004;
int res,n,m,a,tr[maxn]; 

void add(int p,int v){
	while(p<=maxn-2){
		tr[p]+=v;
		p+=p&-p;
	}
}

int sum(int p){
	int ret=0;
	while(p){
		ret+=tr[p];
		p-=p&-p;
	}
	return ret;
} 

signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a);
		res^=sum(maxn-2)-sum(a);
		add(a,1);
	}
	while(m--){
		int op,k,l1,r1,l2,r2,n1,n2,N,x;
		scanf("%lld",&op);
		if(op==1){
			scanf("%lld %lld %lld %lld",&l1,&r1,&l2,&r2);
			n1=r1-l1+1,n2=r2-l2+1,N=l2-r1-1;
			res^=N*(n1+n2)+n1*n2;
		}
		if(op==2){
			scanf("%lld %lld %lld",&l1,&r1,&k);
			n1=r1-l1+1,n2=k-r1;
			res^=n1*n2;
		}
		if(op==3){
			scanf("%lld",&x);
			res^=sum(maxn-2)-sum(x);
			add(x,1);
		}
		if(op==4){
			scanf("%d",&x);
			res^=sum(x);
			add(x,1);
		}
		puts(res&1?"odd":"even");
	}
	return 0;
}
```


---

## 作者：Purslane (赞：4)

## Solution

求逆序对的过程很简单 , 只需要从左到右扫描线 , 这里不多赘述 .

来看下面的操作 .

$3$ 操作和 $4$ 操作很简单 :

- $3$ 操作要知道序列中有多少个数比它大

- $4$ 操作要知道序列中有多少个数比它小

树状数组解决 .

对于 $2$ 操作 , 不难发现 , 其实就是将 $[l,r]$ 与 $[r+1,k]$ 互换位置 , 转化为 $1$ 操作 .

我们不妨使用整体法 , 将 $1$ 操作看做三个序列的运作 : $[l_1,r_1]$ , $[r_1+1,l_2-1]$ , $[l_2,r_2]$ . 将中间那个序列叫做 $[L,R]$ .考虑到排序前后 , 外部与这三个区间的相对关系不变 , 也就是逆序对数不变 ; 每个区间内部也不变 . 所以只有横跨两个区间的逆序对会变 . 这一共涉及到 $(r_1-l_1+1)(R-L+1)+(r_1-l_1+1)(r_2-l_2+1)+(R-L+1)(r_2-l_2+1)$ 个区间 .

因为所有数都不相同 , 所以是/不是逆序对前后必发生转化 . 所以判断上式奇偶性即可 .

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,MAXM=2e6+10;
int n,m,a[MAXN],tr[MAXM];
int lowbit(int k) {return k&-k;}
void update(int pos,int val) {while(pos<=2000000) tr[pos]+=val,pos+=lowbit(pos);return ;}
int Query(int pos) {int ans=0;while(pos) ans+=tr[pos],pos-=lowbit(pos);return ans;}
int query(int l,int r) {return Query(r)-Query(l-1);}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	int flg=0;
	ffor(i,1,n) cin>>a[i]; ffor(i,1,n) flg^=(query(a[i]+1,2000000)&1),update(a[i],1);
	ffor(i,1,m) {
		int op;cin>>op;
		if(op==1) {
			int l,r,L,R;cin>>l>>r>>L>>R;
			int ll=r+1,rr=L-1;
			flg^=(((r-l+1)*(R-L+1)+(rr-ll+1)*(r-l+1)+(rr-ll+1)*(R-L+1))&1);
		}
		if(op==2) {
			int l,r,k,L,R;cin>>l>>r>>k;
			L=r+1,R=k;
			flg^=(((r-l+1)*(R-L+1))&1);
		}
		if(op==3) {
			int x;cin>>x;flg^=(query(x,2000000)&1),update(x,1);
		}
		if(op==4) {
			int x;cin>>x;flg^=(query(1,x)&1),update(x,1);
		}
		if(flg) cout<<"odd\n";
		else cout<<"even\n";
	}
	return 0;
}
```

---

## 作者：jijidawang (赞：4)

# **逆序对**

**Key Observation**：一个排列 $\{a\}$，任意交换两个位置 $p_1,p_2$ 上的数，逆序数奇偶性改变（$p_1\neq p_2$）.

证明：

不失一般性，令 $p_1<p_2$ .

当 $p_2=p_1+1$ 时（交换相邻的两个数），这一对数相对顺序改变，所以逆序数加一或减一，于是奇偶性改变 .

下面把一次交换相邻的两个数称作一次「操作」.

若不然，令 $l = |p_1-p_2|-1$，则可以先通过 $l+1$ 次操作把 $p_1$ 移动到 $p_2$ 位置上，此时原先 $p_1+1\dots p_2$ 位置上的数全部左移一位 .

于是再用 $l$ 次操作就可以将 $p_2$ 移动到 $p_1$ 位置上，共用 $2l+1$ 次操作 .

例如：

排列 `1 8 2 5 7 3 6 4`，要交换 8 和 3，具体步骤如下：
1. 交换第 2, 3 位，排列变成 `1 2 8 5 7 3 6 4` .
2. 交换第 3, 4 位，排列变成 `1 2 5 8 7 3 6 4` .
3. 交换第 4, 5 位，排列变成 `1 2 5 7 8 3 6 4` .
4. 交换第 5, 6 位，排列变成 `1 2 5 7 3 8 6 4` .
5. 交换第 4, 5 位，排列变成 `1 2 5 3 7 8 6 4` .
6. 交换第 3, 4 位，排列变成 `1 2 3 5 7 8 6 4` .
7. 交换第 2, 3 位，排列变成 `1 3 2 5 7 8 6 4` .

而根据前面的推导，我们知道交换奇数次逆序数奇偶性一定改变 .

命题获证 .

***

于是我们考虑一次区间翻转对于排列 $\{a\}$ 逆序数 $N(a)$ 的影响 .

设翻转区间长度为 $n$，则：
- 当 $n=2k$（$k\in\mathbb N_+$）时，显然可以将翻转换为 $k$ 次交换 .
- 当 $n=2k+1$（$k\in\mathbb N_+$）时，同样也可以将翻转换为 $k$ 次交换 .

于是有翻转后序列的逆序数满足 $N(a')\equiv N(a)+\left\lfloor\dfrac k2\right\rfloor\pmod 2$ .

于是区间翻转对于排列逆序数的影响就被解决了 .

***

于是，1 操作（区间交换）可以拆成 4 次区间翻转操作 .

具体的，若交换区间 $[l_1,r_1],[l_2,r_2]$（$l_1\le r_1< l_2\le r_2$），则可以依次翻转区间 $[l_1,r_2]$，$[l_1,l_1+r_2-l_1+1]$，$[l_1+r_2-l_2+1,r_2-r_1+l_1-1]$（若 $l_2=r_1+1$，则不翻转这个），$[r_2-r_1+l_1,r_2]$

大概就像这样（下面是 $l_2\neq r_1+1$ 的情况）：
```plain
A : [l1, r1] ; B : [r1+1, l2-1] ; C : [l2, r2]

 A  B  C    原始序列
~C ~B ~A   第一次操作后（~L 表示原来 L 区间翻转过来）
 C ~B ~A   第二次操作后
 C  B ~A   第三次操作后
 C  B  A   第四次操作后
```

于是 1 操作对于逆序对的影响解决，2 操作是 1 操作的特例，自然也解决（将 $[l,r]$ 向后移动到第 $k$ 个数字与第 $k+1$ 个数字之间可以看做交换区间 $[l,r]$ 和 $[r+1,k]$）.

3, 4 操作是平凡的，考虑在排列 $\{p\}$ 的开头插入一个数 $x$，它对逆序数的贡献必然为 $\{p\}$ 中比 $x$ 小的数的数量，这个可以树状数组维护 .

在末尾插入（4 操作）可以换成一次全局翻转和一次 3 操作然后再全局翻转一次 .

于是所有问题被解决，时间复杂度 $O(q\log n)$ .

---

## 作者：DeepSleep_Zzz (赞：2)

**begin**

[P8449 [LSOT-1] 逆序对](https://www.luogu.com.cn/problem/P8449)

# 思路

这题让你求奇偶性肯定是有他的原因的，所以你就不要想着每次都求一次逆序对判断奇偶。要不然直接 T 到你怀疑人生。所以我们将这道题的突破口放在奇偶性上。

### 关于操作 $1$ 和操作 $2$

首先观察到操作 $2$ 可以直接转换为将区间 $[l,r]$ 与区间 $[r+1,k]$ 整体交换，变成操作 $1$。

随后我们不难想出，如果想对答案有影响，那么该数对必须跨越 $[l_1,r_1]$ 或 $[r_1+1,l_2-1]$ 或 $[l_2,r_2]$ 其中的任意两个区间。

而这三个区间一共能够产生贡献的数对有：

$$res=(r_1-l_1+1)\times(l_2-r_1-1)+(r_1-l_1+1)\times(r_2-l_2+1)+(r_2-l_2+1)\times(l_2-r_1-1)$$
在这些数对中，原本的顺序对会变成逆序对，同理，原本的逆序对也会变成顺序对。

所以我们只需要根据 $res$ 的奇偶性和原本的逆序对数量奇偶性算出答案即可。（至于怎么算，去看小学数学的奇偶性去。。）

### 关于操作 $3$ 和操作 $4$

这就更简单了，因为是在头和尾加数，所以我们直接用树状桶数组算一下当前数组中 $>x$ 或 $<x$ 元素数量（逆序对数量），然后再更新一下树状桶数组即可。

# Code


```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=2e6+10;
ll n,m,a,op,l1,r1,l2,r2,k,ans;
ll tree[N];//类似于桶的树状数组
void upd(ll x,ll k){for(;x<N;x+=x&-x)tree[x]+=k;}
ll qry(ll x){ll res=0;for(;x;x-=x&-x)res+=tree[x];return res;}//最基本的操作
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(ll i=1;i<=n;i++)
    {
        cin>>a;
        ans+=i-1-qry(a);//总元素个数减去<=a[i]的元素个数等于>a[i]的元素个数
        upd(a,1);//更新桶数组
    }
    ans&=1;//初始逆序对数量的奇偶性
    while(m--)
    {
        cin>>op;
        ll len1,len2,len3,res;
        if (op==1)
        {
            cin>>l1>>r1>>l2>>r2;
            len1=r1-l1+1;
            len2=l2-r1-1;
            len3=r2-l2+1;
            res=((len1*len2+len1*len3+len2*len3)&1);//算贡献
        }
        else if (op==2)
        {
            cin>>l1>>r1>>k;
            len1=r1-l1+1;
            len3=k-r1;
            res=((len1*len3)&1);
        }
        else if (op==3)
        {
            cin>>k;
            res=qry(N-1)-qry(k);
            upd(k,1);
            res&=1;
        }
        else
        {
            cin>>k;
            res=qry(k-1);
            upd(k,1);
            res&=1;
        }
        ans^=res;//更新答案
        cout<<(ans?"odd\n":"even\n");
    }
    return 0;
}
```

**end**

---

## 作者：ziyistudy (赞：2)

## 前言

> 昨天 MX 学了平衡树。
>
> 第一眼：这不一眼平衡树吗？
>
> ~~哦，我不会板子~~。只能想想其他办法了。

## 正言

我们观察到题目的两个特性：

1. $a$ 中的数均不相同。这意味着一旦发生交换，所有逆序对必然翻转。
2. 只用求出逆序对奇偶性。这意味着我们并不需要求出（应该也求不出来）逆序对的数量。

后两个操作比较好想，对于操作 $3$ 和操作 $4$，我们都可以用树状数组（线段树）来快速实现。

对于第 $2$ 个操作，其实本质上也可以理解为区间交换。及交换 $[l,r]$ 和 $[r+1,k]$ 这两个区间。

这样一来，我们只需要考虑操作 $1$ 了。

我们先将问题变得简单：考虑交换区间 $[l,k]$ 和 $[k+1,r]$。发现交换两个区间内部的相对位置不会发生改变，只有不同区间两个元素相对位置发生了改变，且一旦发生了改变，它们的逆序对状态一定会改变。我们不妨设有 $cnt$ 个数的相对位置发生了改变，其中 $x$ 个由逆序对变为非逆序对，$cnt-x$ 个由非逆序对变为逆序对。设原来有 $S$ 个逆序对，则新的逆序对个数为 $S-x+(cnt-x)=S-2x+cnt$。$2x$ 必然为偶数，所以奇偶性只与 $cnt$，及区间改变相对位置的数有关。这个数量显然为 $(k-l+1)\times (r-k)$。

回到操作 $1$，改变相对位置的数有：$(r_1-l_1+1)\times (r_2-r_1)+(l_2-r_1-1)\times (r_2-l_2+1)$，只需要考虑这个东西的奇偶性即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
#define eb emplace_back
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll MOD=1e9+7;
// head
const int N=2e6+5;
int lowbit(int x){return x&-x;}
struct BIT
{
    int c[N<<2];
    void modify(int x,int k) {for(;x<N;x+=lowbit(x)) c[x]+=k;}
    int query(int x) {int sum=0;for(;x;x-=lowbit(x)) sum+=c[x];return sum;}
}tree;
int a[N];
signed main() 
{
    cin.tie(nullptr);
    ios::sync_with_stdio(false);

    int n,q;cin>>n>>q;
    int ans=0;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
        ans+=tree.query(N-1)-tree.query(a[i]);
        tree.modify(a[i],1);
    }
    ans=ans%2;
    while(q--)
    {
        int opt;cin>>opt;
        if(opt==1){
            int l1,r1,l2,r2;cin>>l1>>r1>>l2>>r2;
            ans+=(r1-l1+1)*(r2-r1)+(l2-r1-1)*(r2-l2+1);
        }
        else if(opt==2){
            int l,r,k;cin>>l>>r>>k;
            int l1=l,r1=r,l2=r+1,r2=k;
            ans+=(r1-l1+1)*(r2-r1)+(l2-r1-1)*(r2-l2+1);
        }
        else if(opt==3){
            int x;cin>>x;
            ans+=tree.query(N-1)-tree.query(x);
            tree.modify(x,1);
        }
        else {
            int x;cin>>x;
            ans+=tree.query(x-1);
            tree.modify(x,1);
        }
        ans%=2;
        if(ans) cout<<"odd"<<endl;
        else cout<<"even"<<endl;
    }
}
```

---

## 作者：ni_ju_ge (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8449)
## 思路
可以使用 fhq treap 维护加入数后新增的逆序对个数。在末尾加入数，新增的逆序对个数就是大于它的数，也就是分裂后的右树；在开头加入数同理。

这样就解决了三四操作，最开始的数列可以视作是进行 $n$ 次三操作形成的数列。

发现由于所有数互不相同，所以将一个数与旁边的数交换，逆序对个数的奇偶性必然改变。一操作要将区间 $[l_1,r_1]$ 与区间 $[l2,r2]$ 交换，记这两个区间与中间的区间 $[r_1+1,l_2-1]$ 分别为 $A,B,C$，则初始时区间的顺序为 $A,C,B$，要得到 $B,C,A$。那么需要先将 $A$ 中的 $(r_1-l_1+1)$ 个数与右侧的数交换 $(r_2-r_1)$ 次，此时区间的顺序变为 $C,B,A$。再将 $B$ 中的 $(r_2-l_2+1)$ 个数与右侧的数交换 $(l_2-r_1-1)$ 次就得到了 $B,C,A$。

因此交换次数就是 $(r_1-l_1+1)(r_2-r_1)+(l_2-r_1-1)(r_2-l_2+1)$，那么若它是奇数，则逆序对个数的奇偶性改变，否则不变。

二操作可以转化为将 $[l,r]$ 与 $[r+1,k]$ 交换。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,opt,m;
int a,ans;
int l1,r1,l2,r2;
struct node {
	int l,r;
	int dat,key;
	int size;
} treap[2*N];
int cnt,root;
int x,y,z;
int make(int val) {
	treap[++cnt].dat=val;
	treap[cnt].key=rand();
	treap[cnt].size=1;
	return cnt;
}
void up(int pos) {
	treap[pos].size=treap[treap[pos].l].size+treap[treap[pos].r].size+1;
}
void cut(int val,int pos,int &c1,int &c2) {
	if(!pos)c1=c2=0;
	else {
		if(treap[pos].dat<=val) {
			c1=pos;
			cut(val,treap[pos].r,treap[pos].r,c2);
		} else {
			c2=pos;
			cut(val,treap[pos].l,c1,treap[pos].l);
		}
		up(pos);
	}
}
int join(int r1,int r2) {
	if(!r1||!r2)return r1+r2;
	else {
		if(treap[r1].key>treap[r2].key) {
			treap[r1].r=join(treap[r1].r,r2);
			up(r1);
			return r1;
		} else {
			treap[r2].l=join(r1,treap[r2].l);
			up(r2);
			return r2;
		}
	}
}
int take1(int val) {
	cut(val,root,x,y);
	int k=treap[x].size;
	root=join(join(x,make(val)),y);
	return k;
}
int take2(int val) {
	cut(val,root,x,y);
	int k=treap[y].size;
	root=join(join(x,make(val)),y);
	return k;
}
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++) {
		cin>>a;
		ans=(ans+take2(a))%2;
	}
	for(int i=1;i<=m;i++) {
		cin>>opt;
		if(opt==1) {
			cin>>l1>>r1>>l2>>r2;
			ans=(ans+(r1-l1+1)*(r2-r1)+(l2-r1-1)*(r2-l2+1))%2;
		}
		if(opt==2) {
			cin>>l1>>r1>>a;
			ans=(ans+(r1-l1+1)*(a-r1))%2;
		}
		if(opt==3) {
			cin>>a;
			ans=(ans+take2(a))%2;
		}
		if(opt==4) {
			cin>>a;
			ans=(ans+take1(a))%2;
		}
		if(ans==0) cout<<"even"<<endl;
		else cout<<"odd"<<endl;
	}
}
```

---

## 作者：liuChF (赞：1)

## 思路

首先对于操作 $3$ 和 $4$，就是普通逆序对的求法，用权值树状数组就行，复杂度 $O(n \log A)$，其中 $A$ 为 $a_i$ 的值域。然后考虑操作 $1$ 和 $2$，复杂度期望 $\le O(\log A)$，但是真的进行区间交换的复杂度至少 $O(n)$，但是不进行区间交换的数组就不满足后续更多的操作，这就矛盾了，再考虑到 **逆序对的奇偶性**、**保证在任意时刻 $a$ 中的数均互不相同** 这些性质，考虑对性质进行分析。

比较显然的，**对于任意的 $a_i$ 和 $a_j$ 两个数，要么是逆序要么是正序**，这是第二点性质保证的，其次，**当这两个数进行交换，就一定对答案的奇偶性产生影响**，也就是奇数变偶数，奇数变偶数。所以对于操作 $1$ 和 $2$，只要考虑有多少对 (pair) 数进行了交换，有知道了其对答案的影响。考虑对于两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 的交换会有多少对数的顺序变了，大致可以**不重不漏**地分成 $2$ 类：

- 两个区间中**各**选一个数进行交换。共 $(r_1-l_1+1) \times (r_2-l_2+1)$ 种。
- $[r_1+1,l_2-1]$ 中选一个数和两个区间中选一个数。共 $((l_2-1)-(r_1+1)+1) \times ((r_1-l_1+1)+(r_2-l_2+1))$ 种。

括号没拆，方便理解。

然后将这两种方案种类数之和与原来的答案加起来再判断奇偶性就行了。

## 做法

操作 $1$ 和 $2$ 本质是一样的，操作 $2$ 可以改为 $[l_1,r_1]$ 和 $[r_1+1,k]$ 的操作 $1$。操作 $3$ 和 $4$，每次查询原数组有多少个大于/小于 $x$ 的数，然后进行计算就行了。

有几点易错的：

1. `add` 操作时，上限是值域 $A$，而不是个数 $n$。
2. 操作 $3$ 和 $4$ 想清楚要怎么操作，完成后要在树状数组再加上 $x$ 这个数，并将个数 $n$ 加 $1$ 。
3. 式子不要打错。

## 代码

```cpp
#include <bits/stdc++.h>
#define lowbit(i) i & -i
using namespace std;
const int N = 4e6 + 10;
int n, m, a, c[N], op, l1, r1, l2, r2, ans;
void add(int i) {
	for (; i < N; i += lowbit(i)) c[i]++;
}
int query(int i) {
	int ans = 0;
	for (; i; i -= lowbit(i)) ans += c[i];
	return ans;
}
void solve(int l1, int r1, int l2, int r2) {
	int cnt = 0;
	cnt += (r1 - l1 + 1) * (r2 - l2 + 1);
	cnt += (l2 - r1 - 1) * (r1 - l1 + 1 + r2 - l2 + 1);
	ans = (ans + cnt) & 1;
}
signed main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a;
		ans = ans + query(a); // 正序对个数
		add(a);
	}
	ans = (n * (n - 1) / 2 - ans) & 1; // 转成逆序对个数
	while (m--) {
		cin >> op;
		if (op == 1) {
			cin >> l1 >> r1 >> l2 >> r2;
			solve(l1, r1, l2, r2);
		} else if (op == 2) {
			cin >> l1 >> r1 >> a;
			solve(l1, r1, r1 + 1, a);
		} else {
			cin >> a;
			int cnt = query(a);
			ans = (ans + (op == 3 ? n - cnt : cnt)) & 1;
			add(a);
			n++;
		}
		if (ans & 1) cout << "odd" << '\n';
		else cout << "even" << '\n';
	}
	return 0;
}
```

---

## 作者：Hooch (赞：1)

### 基本思路

这道题我们发现它需要求出的并不是逆序对的数量，而是逆序对数量的奇偶性，那么我们就可以抓住这点为突破口，解决此题。

***

#### 关键性质：一个排列中任意两个数对换，逆序对数量将改变奇偶性。

证明：

先证明相邻两个元素对换的情形。设排列为 $a_1a_2\cdots a_labb_1b_2\cdots b_m$，那么交换 $a,b$ 后变成 $a_1a_2\cdots a_lbab_1b_2\cdots b_m$。显然能够得到 $a_1\cdots a_l$ 和 $b_1\cdots b_m$ 的逆序对数量不变，而 $a,b$ 两元素的逆序对数变为：当 $a<b$ 时，$a$ 的逆序对数增加 $1$，而 $b$ 的逆序对数不变。而当 $a>b$ 时，$a$ 的逆序对数量不变而 $b$ 的逆序对数量减少 $1$。所以 $a_1a_2\cdots a_lbab_1b_2\cdots b_m$ 和 $a_1a_2\cdots a_labb_1b_2\cdots b_m$ 两个排列的奇偶性不同。

接着证不相邻两数对换的情况。设排列为 $a_1\cdots a_lab_1\cdots b_mbc_1\cdots c_n$，把它做 $m$ 次相邻对换，变成 $a_1\cdots a_labb_1\cdots b_mc_1\cdots c_n$，在做 $m+1$ 次相邻对换，变成 $a_1\cdots a_lbb_1\cdots ac_1\cdots c_n$。最后，经 $2m+1$ 次相邻对换，将排列变为 $a_1\cdots a_lbb_1\cdots b_mac_1\cdots c_n$，由于每次相邻对换都会改变奇偶性，那么最后序列改变奇偶性。

证毕。

***

那么显然 $1,2$ 操作便很好做了。而对于 $3,4$ 操作，我们需要求出来对答案的影响，那么就求插入的数增加了多少逆序对数。

于是我们发现 $3$ 操作就是求有多少个数比他大，$4$ 操作就是求序列中有多少个数比他小。赛时蒟蒻脑子抽了，写的平衡树~~喜提常数最大~~，其实简单的权值树状数组就能解决。

### 代码细节

我们先看操作 $2$，使用性质非常好做，将一个区间 $[l,r]$ 移到 $k$ 后，那么其实就是将 $r-l+1$ 个数全体挪动 $k-r$ 次。它对答案的贡献就是 $(r-l+1)\times (k-r)$。



再看操作 $1$，区间对换，我们来模拟一下这个情况：

```
1 2 3 4 5 6 7 8
```

这里我们交换区间 $[2,3]$ 和 $[5,7]$。

变成了：

```
1 5 6 7 4 2 3 8
```

那么我们发现这个操作可以拆为这样：

```
1 2 3 4 5 6 7 8
将 [2,3] 插在 [5,7] 后
1 4 5 6 7 2 3 8
将 [5,7] 挪到原来序列的 3 后。
1 5 6 7 4 2 3 8
```
我们把操作 $1$ 分解成了两个操作 $2$。这样就能解决了。
它对答案的贡献是 $(r_2-r_1)\times(r_1-l_1+1)+(r_2-l_2+1)\times (l_2-r_1-1)$。

这里我亮一下我的赛时~~垃圾~~ $\operatorname{Treap}$ 代码：

```cpp
#include <bits/stdc++.h>
#define rep1(i, l, r) for (register int i(l); i <= r; ++i)
#define rep2(i, l, r) for (register int i(l); i >= r; --i)
#define int long long
using namespace std;
const int N = 4e5 + 5;
int n, tot, m, root;
struct node {
	int son[2], val, sz, num, rd;
} t[N];
inline void pushup(int x) {
	t[x].sz = t[t[x].son[0]].sz + t[t[x].son[1]].sz + t[x].num;
}
inline void rotate(int &x, int d) {
	int k = t[x].son[!d];
	t[x].son[!d] = t[k].son[d];
	t[k].son[d] = x;
	pushup(x);
	pushup(k);
	x = k;
}
inline void insert(int &x, int val) {
	if (!x) {
		x = ++tot;
		t[x].son[0] = t[x].son[1] = 0;
		t[x].val = val;
		t[x].sz = t[x].num = 1;
		t[x].rd = rand();
		return ;
	}
	if (val == t[x].val) {
		++t[x].sz;
		++t[x].num;
		return ;
	}
	int d = (val > t[x].val);
	insert(t[x].son[d], val);
	if (t[t[x].son[d]].rd > t[x].rd) rotate(x, !d);
	pushup(x);
}
inline int Rank(int x, int val) {
	if (!x) return 0;
	if (val == t[x].val) return t[t[x].son[0]].sz;
	else if (val < t[x].val) return Rank(t[x].son[0], val);
	else return t[t[x].son[0]].sz + t[x].num + Rank(t[x].son[1], val);
}
long long sum;
signed main(void) {
	srand(time(0));
	scanf("%lld%lld", &n, &m);
	rep1(i, 1, n) {
		int x;
		scanf("%lld", &x);
		insert(root, x);
		int k = i - Rank(root, x) - 1;
		sum += k;
	}
	while (m--) {
		int op;
		scanf("%lld", &op);
		if (op == 1) {
			int l1, r1, l2, r2; scanf("%lld%lld%lld%lld", &l1, &r1, &l2, &r2);
			int res = (r2 - r1) * (r1 - l1 + 1);
			(sum += res) %= 2;
			res = (r2 - l2 + 1) * (l2 - r1 - 1);
			(sum += res) %= 2;
		} else if (op == 2) {
			int l, r, k; scanf("%lld%lld%lld", &l, &r, &k);
			int res = (k - r) * (r - l + 1);
			(sum += res) %= 2;
		} else if (op == 3) {
			int x;
			scanf("%lld", &x);
			++n;
			insert(root, x);
			int k = n - Rank(root, x) - 1;
			(sum += k) %= 2;
		} else {
			int x;
			scanf("%lld", &x);
			++n;
			insert(root, x);
			int k = Rank(root, x);
			(sum += k) %= 2;
		}
		puts((sum & 1) ? "odd" : "even");
	}
}
```

---

## 作者：sybs1145 (赞：0)

# Solution

[题目传送门](https://www.luogu.com.cn/problem/P8449)。
## 思路

这道题首先要实现的就是求逆序对个数，不懂的读者可以去看一看 [P1908](https://www.luogu.com.cn/problem/P1908) 这道题。

由于这题数据范围不大，不需要离散化，所以求逆序对肯定首选树状数组。

这时候操作 3、4 就很容易实现了，用树状数组维护即可。

我们注意到，本题只需要求逆序对数的奇偶性，所以我们可以在**逆序对数的奇偶性**这方面作文章。

我们可以先从只交换 2 两个数这方面考虑，在如下情况中：
$$
  \dots a\dots b\dots c\dots
$$
假设我们交换 $a,c$，先讨论对于 $b$ 的逆序对数：

1. $b>a,c$，则逆序对数不变。

2. $b<a,c$，则逆序对数不变。

3. $a<b<c$，则逆序对数 $+2$。

4. $c<b<a$，则逆序对数 $-2$。

对于 $x,y$ 来说，交换后的逆序对数一定 $+1$ 或 $-1$。

综上：在序列中交换任意两个数，逆序对数的奇偶性**一定会变化**。

我们在交换区间 $[L,R],[X,Y](L<R<X<Y)$ 时考虑一位一位交换，即令 $[L,R],[R+1,X-1],[X,Y]$ 分别进行交换。

我们定义区间 $[L,R],[X,Y](L<R<X<Y)$ 为区间 $1、2、3$，过程即为：$1$ 先与 $2$ 交换，$1$ 再与 $3$ 交换，最后 $2$ 与 $3$ 进行交换。

显然，在交换区间时对于任意一组 $L,R,X,Y(L<R<X<Y)$，交换的次数为 $(R-L+1)\times(Y-X+1)$。

然后我们计 $len_i$ 为第 $i$ 个区间的长度。

答案即为 $len_1\times len_2+len_1\times len_3+len_2\times len_3$。

操作 $2$ 即等价于 $[l,r]$ 于 $[r+1,k]$ 交换。

完美收官。

## AC code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e5 + 5, M = 2e6 + 5;
int n, m, a[N], t[M], len = 2e6, ans;
int lowbit(int X)
{
    return X & (-X);
}
void add(int X, int Y)
{
    for (int i = X; i <= len; i += lowbit(i))
        t[i] += Y;
}
int sum(int X)
{
    int rt = 0;
    for (int i = X; i; i -= lowbit(i))
        rt += t[i];
    return rt;
}
int query(int L, int R)
{
    return sum(R) - sum(L);
}
int exchange(int L, int R, int X, int Y)
{
    int l = R + 1, r = X - 1, len1 = (R - L + 1) % 2, len2 = (Y - X + 1) % 2, len3 = max(0, r - l + 1) % 2;
    return len1 * len2 + len2 * len3 + len1 * len3;
}
int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        ans += query(a[i], len);
        add(a[i], 1);
        ans %= 2;
    }
    while (m--)
    {
        int op, in1, in2, in3, in4;
        cin >> op;
        if (op == 1)
        {
            cin >> in1 >> in2 >> in3 >> in4;
            ans += exchange(in1, in2, in3, in4);
        }
        if (op == 2)
        {
            cin >> in1 >> in2 >> in3;
            ans += exchange(in1, in2, in2 + 1, in3);
        }
        if (op == 3)
        {
            cin >> in1;
            ans += query(in1, len);
            add(in1, 1);
        }
        if (op == 4)
        {
            cin >> in1;
            ans += sum(in1 - 1);
            add(in1, 1);
        }
        ans %= 2;
        if (ans)
            cout << "odd\n";
        else
            cout << "even\n";
    }
    return 0;
}
```

---

## 作者：Dtw_ (赞：0)

# Solution
先想一个问题：在一个序列中，任意交换两个数逆序对数量的奇偶性会发生什么改变？注意，序列中元素两两不同。

$$\dots x,\dots,a,\dots,y\dots$$

考虑交换 $x,y$，分情况讨论一下关于 $a$ 的逆序对数：

如果 $a > x,y$ 那么逆序对数不变。

如果 $a < x,y$ 逆序对数不变。

如果 $x < a < y$ 那么逆序对数 $+2$。

如果 $y < a < x$ 那么逆序对数 $-2$。

综上，被交换两个数之间的数不影响逆序对的奇偶性。

那之外的显然也不影响逆序对数量，所以只考虑 $x,y$ 就行。

那 $x,y$ 交换后要么 $+1$ 要么 $-1$，所以交换后奇偶性一定改变。

那回到这个题，$1,2$ 操作直接用上述结论处理就行，后面两个用权值线段树或者权值树状数组维护。

$1,2$ 操作我们有了上述结论后还应有操作次数，现在考虑怎么求这个操作次数。

给一个最不好处理的例子：

$$[l_1,r_1]=[1,2,3]$$

$$[l_2,r_2]=[6,7]$$

$${\color{Red} 1,2,3},{\color{Orange} 4,5}  ,{\color{Green} 6,7} $$

考虑一位一位交换。

第一次交换，先将 ${\color{Red} 1,2,3}$ 和 ${\color{Orange} 4,5}$ 交换，原序列变成：

$${\color{Orange} 4,5},{\color{Red} 1,2,3},{\color{Green} 6,7} $$

当前交换了 $6$ 次，对于 $[l_1,r_1]$ 每个数都进行了 $2$ 次交换，所以 $3\times 2 = 6$。

继续对 ${\color{Red} 1,2,3}$ 和 $\color{Green} 6,7$ 进行交换。

$${\color{Orange} 4,5},{\color{Green} 6,7}, {\color{Red} 1,2,3}$$

此时又进行了 $6$ 次交换，对于 $[l_1,r_1]$ 里的每一个数都进行了 $2$ 次交换。

对 $\color{Orange} 4,5$ 和 $\color{Green} 6,7$ 进行交换：

$${\color{Green} 6,7},{\color{Orange} 4,5},{\color{Red} 1,2,3}$$

此时交换完毕，最后一次交换进行了 $2\times2=4$ 次交换。

发现对于任意 $[l,r]$ 和 $[x,y]$ 两个区间进行交换，次数为 $(r-l+1)\times (y-x+1)$。

所以记 $[l,r],[r+1,x-1],[x,y]$ 这三个区间进行交换就行，记 $\text{len}_i$ 为上面三个区间其中第 $i$ 个区间的长度，那么答案为 $\text{len}_1 \times(\text{len}_2+\text{len}_3)+\text{len}_2\times \text{len}_3$。

操作 $2$ 可以看做 $[l,r]$ 和 $[r+1,k]$ 进行交换。

然后就做完了。
# Code

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'

#define int long long

#define lb(o) (o)&(-o)

#define fst ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);

const int N = 2e5 + 10, M = 2e6 + 10;

int n, m, a[N], c[M];

void upd(int x, int d)
{
	for(; x<=M-10; x+=lb(x)) c[x] += d;
}

int query(int x)
{
	int res = 0;
	for(; x; x-=lb(x)) res += c[x];
	return res;
}

int query(int l, int r)
{
	return query(r) - query(l);
}


inline int change(int l, int r, int x, int y)
{
	int L = r + 1, R = x - 1;
	int len1 = r - l + 1, len2 = y - x + 1, len3 = max(0ll, R - L + 1);
	len1 %= 2, len2 %= 2, len3 %= 2;
	return len1 * len2 + len1 * len3 + len2 * len3;
}

signed main()
{
	fst;
    cin >> n >> m;
    for(int i=1; i<=n; i++) cin >> a[i];
    int res = 0;
    for(int i=1; i<=n; i++)
    {
    	res += query(a[i], M - 10);
    	upd(a[i], 1);
    	res %= 2;
	}
	for(int i=1; i<=m; i++)
	{
		int op;
		cin >> op;
		if(op == 1)
		{
			int l1, r1, l2, r2;
			cin >> l1 >> r1 >> l2 >> r2;
			res += change(l1, r1, l2, r2);
			res %= 2;
		}
		if(op == 2)
		{
			int l, r, k;
			cin >> l >> r >> k;
			res += change(l, r, r+1, k);
			res %= 2;
		}
		if(op == 3)
		{
			int x;
			cin >> x;
			res += query(x, M-10);
			res %= 2;
			upd(x, 1);
		}
		if(op == 4)
		{
			int x;
			cin >> x;
			res += query(x - 1);
			res %= 2;
			upd(x, 1);
		}
		if(res) puts("odd");
		else puts("even");
	}
	return 0;
}



```

---

## 作者：C_Pos_Princess (赞：0)

### 题意
求动态逆序对，包括添加和区间移动。
### 题解
序列是动态的。但是一个序列的逆序对奇偶性是有规律的。如果当前是奇数个逆序对，那么将一个数移动一位以后一定会变成偶数个，反之亦然。

我们很容易将操作 2 转换为操作 1，那么对于两个区间的移动，设两个区间为 $[l_1,r_1]$ 和 $[l_2,r_2]$，中间隔着区间 $[L,R]$。任意两个数字不相同，那么移动所产生的代价即为区间长度乘积 $(r_1-l_1+1)\times (R-L+1) + (r_2-l_2+1)\times (R-L+1) + (r_1-l_1+1)\times (r_2-l_2+1)$。

我们可以发现，这时的答案跟具体的数字没有关系，只是处理区间相对位置就行了。

剩下的就是模板题了，树状数组板子就够了。

### 代码
```cpp
int tr[N];
int lowbit(int x) {
	return x & -x;
}
void update(int x, int k) {
	for (int i = x; i <= N - 10; i += lowbit(i)) {
		tr[i] += k;
	}
}

int query(int x) {
	int ans = 0;
	for (int i = x; i; i -= lowbit(i)) {
		ans += tr[i];
	}
	return ans;
}
int get_ans(int l, int r) {
	return query(r) - query(l - 1);
}
int n, m;
int a[N];
int main() {
	read(n, m);
	int flag = 0;
	for (int i = 1; i <= n; i++) {
		read(a[i]);
		flag ^= (get_ans(a[i] + 1, N - 10) & 1);
		update(a[i], 1);
	}
	for (int i = 1; i <= m; i++) {
		int op;
		read(op);
		if (op == 1) {
			int l, r, L, R;
			read(l, r, L, R);
			int ls = r + 1, rs = L - 1;
			flag ^= (((r - l + 1) * (R - L + 1) + (rs - ls + 1) * (r - l + 1) + (rs - ls + 1) * (R - L + 1)) & 1);
		}
		if(op == 2){
			int l,r,k;
			read(l,r,k);
			int L = r+1;
			int R = k;
			flag^=(((r-l+1)*(R-L+1))&1);
		}
		if(op == 3){
			int x;
			read(x);
			flag^=get_ans(x,N-10)&1;
			update(x,1);
		}
		if(op == 4){
			int x;
			read(x);
			flag^=get_ans(1,x)&1;
			update(x,1);
		}
		if(flag) puts("odd");
		else puts("even");
	}

	return 0;
}


```

---


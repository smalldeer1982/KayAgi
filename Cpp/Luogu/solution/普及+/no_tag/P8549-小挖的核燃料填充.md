# 小挖的核燃料填充

## 题目描述

小挖做 Web 设计的时候，剧情里插入了酷炫的核填充情节！但很可惜，受制于技术，情节对应的游戏竟然是数独……

一开始，会给定你一个有 $n\times n$ 个**宫**，每个宫中有 $n \times n$ 个元素，且**早已全部正确填好**的 $n$ 阶数独。本题中数独游戏的详细表示与玩法见下方 **“补充说明”** 。

但小挖会把其中**一些宫向左或者向右转 90 度/180 度**。比如，若一个宫初始为

```cpp
087
654
321
```

那么它向左旋转 $90$ 度后会变成：

```cpp
741
852
063
```
你在恢复数独时，也**只能将一些宫向左转 $90$ 度**，一次旋转算作一步。现在小挖想考考你：如果把操作后的数独重新恢复成合法的数独，最少需要多少步呢？

如果一开始小挖给出的数独局面不可以通过任意次、任意位置的左旋得到，则输出 $-1$ 。~~为什么呢？因为小挖给出的是“自认为完全正确的”数独，但实际不一定。~~

## 说明/提示

对于 $40\%$ 的数据，$2 \le n\leq 3$。

对于 $100\%$ 的数据，$2 \le n\leq 4$。

## Hint

$n$ 阶数独合法的条件：每一行、每一列、每一个粗线宫 $(n\times n)$ 内的数字均含 $0\sim  n^2-1$，且不重复。

需要注意的是，本题内对于 $4$ 阶数独的表示方式中 $>9$ 的数字采用了十六进制表示法。准确来说 $\mathrm A=10$，$\mathrm B=11$，$\mathrm C=12$，$\mathrm D=13$，$\mathrm E=14$，$\mathrm F=15$。


## 样例 #1

### 输入

```
3
701210842
832478367
564653501
386648785
457235610
021170423
410702257
327514806
685368341```

### 输出

```
12
1 1
1 1
1 2
1 3
2 1
2 2
2 3
2 3
3 1
3 1
3 3
3 3```

## 样例 #2

### 输入

```
4
36952EA1CF74857C
18E207C9B36D0419
4DAC56BF8209DFE2
B07FD3485AE1BA36
36B5B7CA6E5839FE
A4985620FD32A8B7
01CF94DF1B7C0564
7DE283E14A09C21D
B46D729D0F7246B0
8CF560154BCA159E
1327AB8459D8D278
EA09FC3E6E31A3CF
8E910623C5622B60
320BF7EDB847CDFE
45AF5A18310F183A
6CD7B9C4A9ED7459
```

### 输出

```
17
1 1
1 1
1 2
1 2
1 3
1 3
1 4
2 2
2 3
2 4
3 1
3 2
3 2
3 3
4 1
4 2
4 4
```

# 题解

## 作者：zplqwq (赞：15)

不错的dfs练手题。因为作者的 dfs 很菜，所以我们从头讲起。

前情提要：这篇题解建议配合代码食用，可以根据题解一行一行理解代码，我基本上都有讲。

首先我们考虑怎么搜索。单独考虑每一个元素显然是困难的，但是题目给了 $n\times n$ 个 $n \times n$ 的矩阵，又因为每次旋转的时候是在一个将一个小矩阵作为整体旋转的，所以可以考虑把一个 $n \times n$ 的小矩阵看作一个元素，这样的话会好搜索很多。

我们搜索的时候考虑传三个参数 $x,y,s$，分别代表着这个小矩阵的行、列、花费的代价。

小矩阵的行、列可能不是特别好理解，举个例子，在样例一中。

$(1,1)\rightarrow$  $\begin{Bmatrix}
						7 & 0 & 1\\
                 8 & 3 & 2\\
                 5 & 6 & 4
                 \end{Bmatrix}$
                 
$(2,2)\rightarrow$ $\begin{Bmatrix}
						2 & 1 &0\\
                 4 & 7 & 8\\
                 6 & 5 & 3
                 \end{Bmatrix}$
                 
这个具体如何实现呢？其实只需要正常按照 $n$ 来枚举，用到判断特定元素时再 $\times n$ 即可，具体可以见代码。

回到搜索本身，我们先按枚举行，再在行确定的情况下枚举列，那么 dfs 的结束条件就是当 $x=n+1$ 时。这时，我们只需要判断当前矩阵是否为合法矩阵并记录答案即可。

那么这引入了一个问题，如何记录答案。STL 中有这样一个容器 pair，大概可以理解为一个类似结构体的东西，只不过结构体里面只有两个元素。这个刚好就可以用来解决这个问题，pair 当中的两个元素分别用于计算这个矩阵的行和列。

但是单用 pair 肯定是不够的，因为一个 pair 显然没办法记录整个答案。那么我们考虑再加一个容器，想到搜索实际上是用栈来实现的，所以可以考虑用栈。数组也是可以的，但是记录答案的大小，也就是代价不如栈方便，数组还要单独开一个变量记录大小并且实时更新而栈直接压进去就好了。
再次回到搜索，我们考虑枚举一个小矩阵转 $i$ 次 $90\degree$ 来算代价。每次递归到后面那个小矩阵即可，具体地，把 $y$ 加上 $1$，$s$ 加上 $i$ 。之后我们在将当前这个矩形旋转 $90\degree$ 。这时候有个问题，为什么是先往下搜索再旋转呢？因为当前这个矩形可能可以不用旋转。那么为什么旋转过后不用再搜一次呢？因为这个改过之后当前的这个矩阵会继承到下一次搜索的状态去，就默认改了。然后再记录一下答案。当我们枚举结束了过后就意味着当前这种情况枚举完了，清空临时记录答案的栈，准备下一种情况。

接下来怎么搜索解决了，问题还有两个，第一个是如何判断合法，第二个是如何旋转。

首先判断合法是容易的，根据题目要求，只需判断这个矩阵里有没有重复的数字即可。为什么不用判断缺少的数字？因为有重复数字代表着有缺少的数字。

如何旋转是类似于一个坐标变换的东西，在题解刚开始的时候提到过获取小矩阵内每一个元素的位置只需要将其 $\times n$ 。那么整体枚举这个小矩阵的每一个元素就是，$(x-1)\times n+1 \le x \le n\times x$ 且 $(y-1)\times n+1 \le x \le n\times y$ ，这个不懂得可以手动模拟一下位置。这里有一个重点就是要取模于 $n$ ，可以理解为这是一个类似循环节的东西，如果不模 $n$ 的话就是一个 $1\times n^2$ 的矩阵了。

至此，这道题就被解决了。有一个小优化，因为每行之间是独立的，所以如果上一个矩阵改完是不合法的，那么就直接返回。

细节还是很多的，大家可以参考一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100;
char c;
int a[N][N];
int vis[N];
int tmp1[N][N];
int tmp2[N][N];
int ans=0x3f3f3f3f;
int n;
stack<pair<int,int> > an,da;
void change(int x,int y)//反转第 i 行，第 j 列的矩阵
{
	memset(tmp1,0,sizeof(tmp1));
	memset(tmp2,0,sizeof(tmp2));
	for(int i=(x-1)*n+1;i<=n*x;i++)
	{
		for(int j=(y-1)*n+1;j<=n*y;j++)
		{
			tmp1[(i-1)%n+1][(j-1)%n+1]=a[i][j];
		}
	}
		
	for(int i=1;i<=n;i++)
	{
			for(int j=1;j<=n;j++)
			{
				tmp2[n+1-j][i]=tmp1[i][j];
			}
			
	}
	
	for(int i=(x-1)*n+1;i<=n*x;i++)
	{
		for(int j=(y-1)*n+1;j<=n*y;j++)
		{
			a[i][j]=tmp2[(i-1)%n+1][(j-1)%n+1];
		}
			
	}
	
}
bool check(int x,int y) //判断第 i 行，第 j 列的矩阵是否合法
{
	for(int i=1;i<=n*x;i++)
	{
		memset(vis,0,sizeof(vis));
		for(int j=1;j<=n*y;j++)
		{
			if(vis[a[i][j]]) return 0;
			vis[a[i][j]]=1;
		}
	}
	for(int j=1;j<=n*y;j++)
	{
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=n*x;i++)
		{
			if(vis[a[i][j]]) return 0;
			vis[a[i][j]]=1;
		}
	}
	return 1;
}
void dfs(int x,int y,int cnt)	//搜索
{
//	cout<<x<<" "<<y<<" "<<cnt<<endl;
	if(x==n+1)//结束条件
	{
//		cout<<check(n,n)<<endl;
		if(check(n,n))
		{
//			cout<<1<<endl;
			if(cnt<ans)//如果当前的代价小于答案的话更新
			{
				ans=cnt;
				da=an;
			}
		}
		return ;
	}
	if(check(x,y-1)==0) return ;
	if(y==n+1) dfs(x+1,1,cnt);
	for(int i=0;i<4;i++)
	{
		dfs(x,y+1,cnt+i);
		change(x,y);
		an.push(make_pair(x,y));
	}
	for(int i=0;i<4;++i)	an.pop();
}
int main()
{
	cin>>n;
	for(int i=1;i<=n*n;i++)
	{
		for(int j=1;j<=n*n;j++)
		{
			cin>>c;
			if(c>='0' and c<='9') a[i][j]=c-'0';
			else a[i][j]=c-'A'+10;//进制转换
		}
	}
	dfs(1,1,0);
	int sz=0;
	if(ans==0x3f3f3f3f) cout<<"-1\n";
	else
	{
		cout<<ans<<endl;
		pair<int,int>AA[N];//输出答案
		while(da.size())
		{
			AA[++sz]=da.top();
			da.pop();
		}
		for(int i=sz;i;i--) cout<<AA[i].first<<" "<<AA[i].second<<endl;
	}
	return 0;
}
```

---

## 作者：strlen_s_ (赞：3)

## 分析

考虑将一个 $1$ 到 $n^2$ 的方格旋转完后，已经操作了的所有方格肯定是合法的，每行每列的数不重复。

所以根据这个性质，大力 **dfs+剪枝** 就可以过了。

思维难度不大，但代码细节较多。

## code

```
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0,f=1;
	char c;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
const int N=25;
int a[N][N],b[N][N];
int n,m,ans=0x3f3f3f3f;
int l[N*4],r[N*4];
int p[N*4],q[N*4];
bool bj[N];
char c[N];
int check(int x,int y){		//检查已填好的方格是否合法 
	x*=n,y*=n;
	for(int i=1;i<=x;i++){
		memset(bj,0,sizeof(bj));
		for(int j=1;j<=y;j++){
			if(bj[a[i][j]])return 0;
			bj[a[i][j]]=1;
		}
	}
	for(int i=1;i<=y;i++){
		memset(bj,0,sizeof(bj));
		for(int j=1;j<=x;j++){
			if(bj[a[j][i]])return 0;
			bj[a[j][i]]=1;
		}
	}
	return 1;
}
void tl(int x,int y){		//将当前方格左转90度 
	int u=n*(x-1)+1,l=n*(y-1)+1;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			b[n-j-1][i]=a[i+u][j+l];
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			a[i+u][j+l]=b[i][j];
}
void tr(int x,int y){		//将当前方格右转90度（回溯用） 
	int u=n*(x-1)+1,l=n*(y-1)+1;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			b[j][n-i-1]=a[i+u][j+l];
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			a[i+u][j+l]=b[i][j];
}
void dfs(int x,int y,int cnt){
	if(cnt>ans)return;		//最优性剪枝 
	if(y>n)x++,y=1;
	if(x>n){
		if(check(n,n)){		//统计答案 
			ans=min(ans,cnt);
			for(int i=1;i<=cnt;i++)p[i]=l[i],q[i]=r[i];
		}return;
	}
	if(y==1)if(!check(x-1,n))return;	//判断已填的是否合法 
	else if(!check(x,y-1))return;
	dfs(x,y+1,cnt);
	for(int i=1;i<=3;i++){
		l[cnt+i]=x,r[cnt+i]=y;
		tl(x,y);dfs(x,y+1,cnt+i);
	}
	tr(x,y),tr(x,y),tr(x,y);
}
int ok(){					//判断每个宫格是否有重复的数字 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			memset(bj,0,sizeof(bj));
			for(int l=n*(i-1)+1;l<=n*i;l++)
				for(int k=n*(j-1)+1;k<=n*j;k++){
					if(bj[a[l][k]])return 0;
					bj[a[l][k]]=1;
				}
		}
}
int main(){
	n=read();m=n*n;
	for(int i=1;i<=m;i++){
		scanf("%s",c+1);
		for(int j=1;j<=m;j++){
			if(c[j]>='A')a[i][j]=c[j]-'A'+10;
			else a[i][j]=c[j]-'0';
		}
	}
	if(!ok()){puts("-1");return 0;}
	dfs(1,1,0);
	if(ans==0x3f3f3f3f){puts("-1");return 0;}
	printf("%d\n",ans);
	for(int i=1;i<=ans;i++)printf("%d %d\n",p[i],q[i]);
	return 0;
}
```

这就做完了，一百行都没有

---

## 作者：FReQuenter (赞：2)

## 思路：

观察数据范围，$n\leq4$，所以可以暴搜+剪枝过。

------------

考虑如何搜索：

1. dfs 中的三个状态：当前是第 $i$ 行第 $j$ 块，共花费了 $k$ 次操作达成。

2. 边界条件：已经填充完了所有块。

3. 递归下降：填下一块时可以转一次、两次、三次、不转（即转四次）。

------------

但是容易发现这样写时间复杂度是 $O(4^{n^2})$，无法通过。
所以考虑剪枝：

1. 最优性剪枝：若当前搜索使用的步数大于等于当前答案，则一定无法产生贡献。

2. 每次进入递归时检查当前填法是否可行（即当前所填是否是一个“不完整的数独”，如果当前无法通过补全一些数形成数独，那当前状态一定也无法产生贡献）。

## 代码

```cpp
#include<cstdio>
#include<utility>
#include<vector>
#include<cstring>
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
char s[20];
int a[20][20],tmp[20][20],n,ans=0x3f3f3f3f;
bool mp[40];
std::pair<int,int> anses[70],anstmp[70];
void turn_left(int idxx,int idxy){
	int sx=n*(idxx-1)+1,sy=n*(idxy-1)+1;
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) tmp[n-j-1][i]=a[i+sx][j+sy];
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) a[i+sx][j+sy]=tmp[i][j];
}
void turn_right(int idxx,int idxy){
	int sx=n*(idxx-1)+1,sy=n*(idxy-1)+1;
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) tmp[j][n-i-1]=a[i+sx][j+sy];
	for(int i=0;i<n;i++) for(int j=0;j<n;j++) a[i+sx][j+sy]=tmp[i][j];
}
//矩阵整体旋转右转
//idxx和idxy表示第i列第j个宫
//通过把a按一定顺序写入到tmp，再把tmp写入到a实现旋转 
void turn_left(int idxx,int idxy,int t){
	while(t--) turn_left(idxx,idxy);
}
void turn_right(int idxx,int idxy,int t){
	while(t--) turn_right(idxx,idxy);
}
//左右转t次 
bool check(int idxx,int idxy){
	idxx*=n,idxy*=n;
	for(int i=1;i<=idxx;i++){
		memset(mp,0,sizeof(mp));
		for(int j=1;j<=idxy;j++){
			if(mp[a[i][j]]) return false;
			mp[a[i][j]]=true;
		}
	}
	for(int i=1;i<=idxy;i++){
		memset(mp,0,sizeof(mp));
		for(int j=1;j<=idxx;j++){
			if(mp[a[j][i]]) return false;
			mp[a[j][i]]=true;
		}
	}
	return true;
}//检查从第一行到第idxx行及第idxx行的第一列到第idxy列否是一个“不完整”的数独
void dfs(int idxx,int idxy,int sum){
	if(sum>ans) return;//最优性剪枝 
	if(idxy>n) idxy=1,idxx++;//转向下一列 
	if(idxx>n){//边界条件 
		if(check(n,n)&&sum<ans){
			for(int i=1;i<=sum;i++) anses[i]=anstmp[i];
			ans=sum;
		}
		return;
	}
	if(idxy==1&&!check(idxx-1,n)) return;
	if(!check(idxx,idxy-1)) return;
	//否是一个“不完整”的数独
	dfs(idxx,idxy+1,sum);
	for(int i=1;i<=3;i++){
		anstmp[sum+i]={idxx,idxy};
		turn_left(idxx,idxy);
		dfs(idxx,idxy+1,sum+i);
	}
	turn_right(idxx,idxy,3);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n*n;i++){
		scanf("%s",s+1);
		for(int j=1;j<=n*n;j++){
			if(s[j]>='A') a[i][j]=s[j]-'A'+10;
			else a[i][j]=s[j]-48;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			memset(mp,0,sizeof(mp));
			int x=n*(i-1)+1,y=n*(j-1)+1;
			for(int k=x;k<=n*i;k++){
				for(int l=y;l<=n*j;l++){
					if(mp[a[k][l]]) return printf("-1"),0;
					mp[a[k][l]]=true;
				}
			}
		}
	}//如果一宫里有重复数字一定不能达成 
	dfs(1,1,0);
	if(ans==0x3f3f3f3f) return printf("-1"),0;
	printf("%d\n",ans);
	for(int i=1;i<=ans;i++) printf("%d %d\n",anses[i].first,anses[i].second);
	return 0;
}
```

---

## 作者：luoyx (赞：1)

考场这道题写挂了，其实仔细想想还是挺简单的。

 $n\leq 4$ 的范围，不是状压就是爆搜。~~因为这是普及组~~，所以肯定是爆搜。
 
 接下来想一下爆搜的思路。我最初的思路是把合法数独的所有可能性全部列举出来，然后再判断是否可以通过宫格旋转得到。但粗算一下复杂度，在不加剪枝的情况下为 $O(20^n)$ 。所以再换一种思路，枚举每个宫格旋转的次数，这样的复杂度就变成了 $O(16^n)$ ，再加一点剪枝就可以轻松通过了。
 
 这道题的另一个难点是就是旋转的公式。其实可以只推转 $90$ 度的公式，然后多用几次。但我头比较铁，就把三个公式都算出来了。~~果不其然这题就是因为公式推错挂了。~~
 
 至于剪枝策略也是比较好想的。因为合法的数独的数量很少，所以我们用一个不太强力的剪枝就能换来很大的效果，这里我用的是每枚举完一行的宫格，就判断一次是否成立。也可以每枚举一个宫格就判断一次，但是这个剪枝毕竟是 $n^2$ 的，所以到底哪个快也是看数据，总之两种应该都能过就是了。
 
 到了快乐的放代码时间了：
 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
const int N=20;
char c;
int a[N][N],a2[N][N];
int step[N][N];
int cnt[N];
int min_ans=90900;
int ans[N][N];
int f_ans[N][N];
bool flag=false;
bool check(int x,int y){
	bool flag=true;
	for(int i=1;i<=x*n;i++){
		for(int j=1;j<=n*n;j++){
			cnt[a2[i][j]]++;
			if(cnt[a2[i][j]]>1) flag=false;
		}
		for(int j=1;j<=n*n;j++){
			cnt[a2[i][j]]--;
		}
	}
	if(flag==false) return false;
	for(int j=1;j<=n*n;j++){
		for(int i=1;i<=x*n;i++){
			cnt[a2[i][j]]++;
			if(cnt[a2[i][j]]>1) flag=false;
		}
		for(int i=1;i<=x*n;i++){
			cnt[a2[i][j]]--;
		}
	}
	if(flag==false) return false;
	return true;
}
void dfs(int x,int y,int k){
	if(y>n){
		if(check(x,y-1)==false) return ;
		if(x==n){
			if(min_ans>k){
				for(int i=1;i<=n;i++){
					for(int j=1;j<=n;j++){
						ans[i][j]=f_ans[i][j];
						flag=true;
					}
				}
				min_ans=k;
			}
			return ;
		}
		dfs(x+1,1,k);
		return ;
	}
	int nxtx=x,nxty=y;
	nxty++;
	f_ans[x][y]=0;
	for(int i=n*(x-1)+1;i<=n*x;i++){
		for(int j=n*(y-1)+1;j<=n*y;j++){
			a2[i][j]=a[i][j];
		}
	}
	dfs(nxtx,nxty,k);
	f_ans[x][y]=1;
	for(int i=n*(x-1)+1;i<=n*x;i++){
		for(int j=n*(y-1)+1;j<=n*y;j++){
			a2[n*x-(j-(n*(y-1)+1))][n*(y-1)+1+(i-(n*(x-1)+1))]=a[i][j];
		}
	}
	dfs(nxtx,nxty,k+1);
	f_ans[x][y]=2;
	for(int i=n*(x-1)+1;i<=n*x;i++){
		for(int j=n*(y-1)+1;j<=n*y;j++){
			a2[n*x-(i-(n*(x-1)+1))][n*y-(j-(n*(y-1)+1))]=a[i][j];
		}
	}
	dfs(nxtx,nxty,k+2);
	f_ans[x][y]=3;
	for(int i=n*(x-1)+1;i<=n*x;i++){
		for(int j=n*(y-1)+1;j<=n*y;j++){
			a2[n*(x-1)+1+(j-(n*(y-1)+1))][n*y-(i-(n*(x-1)+1))]=a[i][j];
		}
	}
	dfs(nxtx,nxty,k+3);
}
int main(){
	cin>>n;
	for(int i=1;i<=n*n;i++){
		for(int j=1;j<=n*n;j++){
			cin>>c;
			if(c>='0'&&c<='9') a[i][j]=c-'0';
			else a[i][j]=c-'A'+10;
		}
	}
	dfs(1,1,0);
	if(!flag){
		cout<<-1;
		return 0;
	}
	cout<<min_ans<<endl;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			while(ans[i][j]--)
				cout<<i<<' '<<j<<endl;
		}
	}
}
```


---

## 作者：违规用户名^3Zj=Oha (赞：1)

## 一、题目简述
给定一个$n \times{n} \times{n}$的数组，然后让你用若干次操作(一些宫向左或者向右转 90 度/180 度)，使它变成了一个合法的n阶数独。

## 二、思路


首先，我们把 $n \times{n} \times{n}$ 的矩阵看成由 $n $   个 $n \times{n}$ 的矩阵组成的，这样去处理会方便一些。 然后我们用 dfs 递归枚举每一个矩阵的翻转，每次把反转代价和行列传递下去，最终使得每一行和每一列没有相同的数即可。


## 三、构造代码
代码如下：

```
#include<bits/stdc++.h>
using namespace std;
char a[20][20],b[20][20],e[20];
int n,ans=INT_MAX,sx1[17],sy1[17],sx2[17],sy2[17],c[17],used1[17][17],used2[17][17];
int d(char x)//将字符转换为数字
    if(x>='0'&&x<='9') return x-'0';
    else return x-'A'+10;
}
bool f(int c,int x1,int y1){
    for(int i=1;i<=n*n;i++){
        for(int j=1;j<=n*n;j++) b[i][j]=a[i][j];
    }
    while(c--){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++) a[x1+i-1][y1+j-1]=b[x1+n-j][i-1+y1];
        }
        if(c!=0){
            for(int i=1;i<=n*n;i++){
                for(int j=1;j<=n*n;j++) b[i][j]=a[i][j];
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(used1[x1+i-1][d(a[x1+i-1][y1+j-1])]) return 0;
            else used1[x1+i-1][d(a[x1+i-1][y1+j-1])]=1;
            if(used2[y1+j-1][d(a[x1+i-1][y1+j-1])]) return 0;
            else used2[y1+j-1][d(a[x1+i-1][y1+j-1])]=1;
        }
    }
    return 1;
}
bool check(){//判断是否为合法数独
    bool used[17];
    for(int i=1;i<=n*n;i++){
        memset(used,0,sizeof(used));
        for(int j=1;j<=n*n;j++){
            if(0<=d(a[i][j])<n*n){
                if(used[d(a[i][j])]) return 0;
                used[d(a[i][j])]=1;
            }
            else{
                puts("-1");
                exit(0);
            }
        }
    }
    for(int j=1;j<=n*n;j++){
        memset(used,0,sizeof(used));
        for(int i=1;i<=n*n;i++){
            if(0<=d(a[i][j])<n*n){
                if(used[d(a[i][j])]) return 0;
                used[d(a[i][j])]=1;
            }
            else{
                puts("-1");
                exit(0);
            }
        }
    }
    return 1;
}
void dfs(int nx){
    if(nx==n*n+1){//到达边界
        if(check()){//如果是合法数独，就覆盖过程数组
            int cnt=0;
            for(int i=1;i<=n*n;i++) cnt+=c[i];
            if(ans>cnt){
                ans=cnt;
                for(int i=1;i<=nx;i++) e[i]=c[i];
            }
        }
        return ;
    }
    for(int i=0;i<=3;i++){//填数
        char y[20][20];
        for(int j=1;j<=n*n;j++){
            for(int k=1;k<=n*n;k++) y[j][k]=a[j][k];//覆盖原数组
        }
        bool flag=f((3-i+1)%4,sx1[nx],sy1[nx]);
        if(!flag){
            int x1=sx1[nx],y1=sy1[nx];
            for(int j=1;j<=n;j++){
                for(int k=1;k<=n;k++){
                    used1[x1+j-1][d(a[x1+j-1][y1+k-1])]=0;
                    used2[y1+k-1][d(a[x1+j-1][y1+k-1])]=0;
                    a[x1+j-1][y1+k-1]=y[x1+j-1][y1+k-1];
                }
            }
            continue;
        }
        c[nx]=i;
        dfs(nx+1);//继续递归
        c[nx]=0;
        int x1=sx1[nx],y1=sy1[nx];
        for(int j=1;j<=n;j++){//填入数字
            for(int k=1;k<=n;k++){
                used1[x1+j-1][d(a[x1+j-1][y1+k-1])]=0;
                used2[y1+k-1][d(a[x1+j-1][y1+k-1])]=0;
                a[x1+j-1][y1+k-1]=y[x1+j-1][y1+k-1];
            }
        }
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n*n;i++) scanf("%s",a[i]+1);
    for(int i=1;i<=n*n;i++) sx1[i]=n*((i-1)/n)+1,sy1[i]=n*((i-1)%n)+1;//初始化
    dfs(1);
    if(ans!=INT_MAX){//如果有，就输出过程
        printf("%d\n",ans);
        for(int i=1;i<=n*n;i++){
            while(e[i]--) printf("%d %d\n",(i-1)/n+1,(i-1)%n+1);
        }
        return 0;
    }
    puts("-1");
    return 0;
}
```

---


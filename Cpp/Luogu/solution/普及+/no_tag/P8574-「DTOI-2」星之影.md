# 「DTOI-2」星之影

## 题目背景

>闻是白极影，见时方立竿。

## 题目描述

白极影化为立竿之人莅临人间，带来了星之函数 $f(x)$，它的值为最接近于 $\sqrt[4]x$ 的整数$\\$（即 $f(x)=\left\lfloor\sqrt[4]x+\dfrac12\right\rfloor$；$\lfloor u\rfloor$ 为对 $u$ 向下取整后的值）。

现有 $t$ 个数字 $n$，对于每个 $n$，立竿人想知道 $\sum\limits_{i=1}^n\dfrac1{f(i)}$ 的值是多少，请你告诉它吧。

---
~~因为立竿人很急，所以~~本题的 $t$ 组询问强制在线，后一个询问需通过前一个询问的答案生成。

可用以下 `C++` 代码生成（其他语言同理；需包含 `<stdio.h>`）：
```cpp
typedef long long ll;
char buf_ans[114];
ll next_n(double last_ans=0,ll get_n=0){
	//last_ans<n<=1e18
	sprintf(buf_ans,"%.6f",last_ans);
	for(ll i=0,x=0;;i++){
		if(buf_ans[i]=='.')return get_n^x;
		if(i&1)x*=10;
		else x=x*10+(buf_ans[i]^48);
	}
}
```
该函数第一个参数为上一次询问的答案（第一次询问时该值为 $0$，也就是说第一个数未经加密），第二个参数为这一次读入的被加密的数，函数返回解密后的 $n$。

## 说明/提示

### 样例解释

样例#1 解密后各组询问分别是：
$$
\def\r{\cr\hline}
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|}\hline
\textbf{t}&1&2&3&4&5&6&7\r
\textbf{n}&1&4&8&89&2022&1145141919810&1\r
\end{array}
$$
### 数据范围

**本题采用捆绑测试。**
$$
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & t= & n\le&\bm{\textbf{Score}} \cr\hline
1 & 10&10^6 & 2 \cr\hline
2&1000&10^6&13\cr\hline
3&100&10^9&15\cr\hline
4 &1000&10^{18}&40\cr\hline
5 &%\text{No Special Constraints}
5\times10^5&10^{18}& 30 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$10 \le t \le 5\times10^5$，$1 \le n \le 10^{18}$。

### 计分规则

本题采用 $\textbf{Special Judge}$，令你输出的答案为 $\text{pans}$，标答答案为 $\text{jans}$，如果 $\vert \text{pans}-\text{jans}\vert<\text{jans}\times10^{-5}$ 那么该组数据通过，在一个测试点内只有所有 $t$ 组数据通过该测试点才算通过。

注意后一个 $\text{Subtask}$ 对前一个 $\text{Subtask}$ 有依赖关系，即如果你没有在前一个 $\text{Subtask}$ 拿到分，那么你即使通过后一个 $\text{Subtask}$ 的所有测试点，你也无法拿到后面的分数。

## 样例 #1

### 输入

```
7
1
5
12
95
2040
1145141920209
1070909051```

### 输出

```
1.000000
4.000000
6.500000
38.666667
403.857143
1475989956.412959
1.000000```

# 题解

## 作者：封禁用户 (赞：4)

注：本题解中的做法为出题人原做法，并不代表最优。

考虑对于 $\forall k$，有多少 $n$ 使得 $f(n)=k$。

因为 $f(n)$ 为整数，且 $(k+\frac{1}{2})^4$ 不为整数，可知 $k+\frac{1}{2} \le f(n) \le k+\frac{1}{2}$，即 $n$ 有 $(k+\frac{1}{2})^4-(k-\frac{1}{2})^4$ 种取值，化简得 $4k^3+k$。

所以设 $p(t)=\sum_{i=1}^{t} \frac{4i^3+i}{i}$，$q(t)=\sum_{i=1}^{t} 4i^3+i$，其中 $t$ 满足 $q(t) \le n < q(t+1)$，则答案为 $p(t)+\frac{n-q(t)}{t+1}$，复杂度为 $\log$ 级别的，能通过此题。

这里给出计算的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t,n;
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		long double ans=0.0;
		int sum=0,cnt=0;
		while(true){
			cnt++;
			if(sum+4*cnt*cnt*cnt+cnt>n)break;
			ans+=4*cnt*cnt+1;
			sum+=4*cnt*cnt*cnt+cnt;
		}
		ans+=1.0*(n-sum)/cnt;
		cout<<fixed<<setprecision(6)<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：spdarkle (赞：4)

# P8574 「DTOI-2」星之影 题解

提供一个数学做法，单次询问复杂度$O(1)$，无预处理

简而言之，本题题意为求：

$$\sum_{x=1}^n\frac{1}{\lfloor\sqrt[4]x+\frac{1}{2}\rfloor}$$

观察这个式子，我们会发现， $\sqrt[4]x$  增长非常慢，于是可以采用类似于数论分块的思想

很明显， ${\lfloor\sqrt[4]x+\frac{1}{2}\rfloor}$ 的值是非严格单调递增的，且取$1,2,3,4,……$

下面我们来思考这个式子的值为 $m$ 的时候， $x$ 的取值范围，容易发现， $x$ 最小可以是当 $\sqrt[4]x+\frac{1}{2}=m$ ,也即 $x=(\frac{2m-1}{2})^4$  由于 $m$ 是整数， $x$ 是整数，可以知道 $x$ 最大取到 $x=(\frac{2m+1}{2})^4-1$ ,这里一共有取值总数：

$$(\frac{2m+1}{2})^4-1-(\frac{2m-1}{2})^4+1=4m^3+m$$

故对于一个足够大的 $n$ ,当 ${\lfloor\sqrt[4]x+\frac{1}{2}\rfloor}=m$ 时，$m$的总贡献为： $4m^2+1$ ,所以说，我们设 $a$ 是对于 $n$ 来说，满足 $\sum_{k=1}^a(4k^3+k)\le n$ 的最大的 $a$ ,这意味着我们可以直接对 $1\sim a$ 的贡献进行求和，写成式子即这部分贡献为：


$$\sum_{k=1}^a\frac{1}{k}·(4k^3+k)=4\sum_{k=1}^ak^2+\sum_{k=1}^a1=\frac{2a(a+1)(2a+1)+3a}{3}$$

那么对于答案来说，剩下的部分即为值为 $a+1$ 的部分，这个部分的总数量即为 $1\sim n$ 的数量减去 $1\sim a$ 中每个数出现的次数，写成式子即为：

$$n-\sum_{m=1}^a(4m^3+m)=n-4\sum_{m=1}^am^3-\frac{a(a+1)}{2}=n-a^2(a+1)^2-\frac{a(a+1)}{2}$$

其总贡献为：

$$\frac{1}{a+1}\left(n-a^2(a+1)^2-\frac{a(a+1)}{2}\right)$$

故，此时我们便可以计算出答案：

$$\frac{2a(a+1)(2a+1)+3a}{3}+\frac{1}{a+1}\left(n-a^2(a+1)^2-\frac{a(a+1)}{2}\right)$$

我们发现，现在我们的问题就是如何求出 $a$ 的值

笔者在考场上，暂时没有想出，于是由于 $a$ 的值具有单调性于是二分答案做的，此种做法已经可以通过本题，但本题还有$O(1)$做法

我们想想，对于 $a$ 的定义是什么，很明显，是满足 $\sum_{k=1}^a(4k^3+k)\le n$ 的最大的 $a$ ，化简这个和式，有：

$$a^2(a+1)^2+\frac{a(a+1)}{2}\le n$$

我们使用换元法求解这个方程，很明显，令 $t=a(a+1)$ ,则原方程化为： $t^2+\frac{t}{2}\le n$ ,由于$t$肯定是一个正数，可以解得 $0<t\le \frac{\sqrt{1+16n}-1}{4}$ ,带回 $a$ ,可以解得 $0<a\le \frac{\sqrt[4]{1+16n}-1}{2}$ ,根据 $a$ 的定义，有 $a=\left\lfloor\frac{\sqrt[4]{1+16n}-1}{2}\right\rfloor$ 也即 $a+1=\left\lfloor\frac{\sqrt[4]{1+16n}+1}{2}\right\rfloor$ 

所以说，我们可以 $O(1)$ 的计算每一次的答案，不需要任何的预处理，这道题的答案写成最终形式就是：


$$\sum_{i=1}^n\frac{1}{\lfloor\sqrt[4]x+\frac{1}{2}\rfloor}=\frac{2a(a+1)(2a+1)+3a}{3}+\frac{1}{a+1}\left(n-a^2(a+1)^2-\frac{a(a+1)}{2}\right)$$

其中 $a=\left\lfloor\frac{\sqrt[4]{1+16n}-1}{2}\right\rfloor$

那么程序也就不难实现了：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define int long long
int n,m,t;
int get(int x){//求1/1~1/n的所有项的和 
	return (2*x*(x+1)*(x*2+1)+3*x)/3;
}
int count(int x){
	return x*x*(x+1)*(x+1)+x*(x+1)/2;
} 
int find(int n){//寻找第n个数是属于a的哪一个元素 
	return (sqrt(sqrt(1.0+16.0*n))+1)/2;
} 
double solve(int t){
	double ans=0;
	int now=find(t);
//	printf("%lld \n",now);
	ans+=get(now-1);
	ans+=1.0*(t-count(now-1))/now;
	return ans;
}
typedef long long ll;
char buf_ans[114];
ll next_n(double last_ans=0,ll get_n=0){
	//last_ans<n<=1e18
	sprintf(buf_ans,"%.6f",last_ans);
	for(ll i=0,x=0;;i++){
		if(buf_ans[i]=='.')return get_n^x;
		if(i&1)x*=10;
		else x=x*10+(buf_ans[i]^48);
	}
}
signed main(){
	scanf("%lld",&t);
	double lst=0;
	while(t--){
		int x;
		scanf("%lld",&x);
		x=next_n(lst,x);
		printf("%.6f\n",lst=solve(x));
	}
}
```
注：
1. 程序中代码是求的a+1
2. $\sum_{i=0}^ni^2=\frac{n(n+1)(2n+1)}{6}$
3. $\sum_{i=0}^{n}i^3=\frac{n^2(n+1)^2}{4}$
4. 前面两个式子可以试着推一推


鸣谢：

1. 感谢@y_kx_b 提供的解不等式的思路

2. 感谢《具体数学》中《底和顶的和式》一节给予我的思路

3. 感谢出题组给了这样一道练手好题




练习题：

求：

1.

$$\sum_{k=0}^n\lfloor\sqrt{k}\rfloor$$

2.

$$\sum_{k=1}^n\frac{1}{\lfloor\sqrt{k}\rfloor}$$


这个甚至比上一个更加简单，只需要套一下就行

---

## 作者：y_kx_b (赞：2)

Preface
-

我太 $\text{cabbage}$ 了，看不懂出题人的代码/kk 

可能有一些地方写的不是很清楚，欢迎提出修改意见。

What to do
-
给定 $n\in[1,10^{18}]$，求 $\sum\limits_{i=1}^n\dfrac1{ \left\lfloor\sqrt[4]x+0.5\right\rfloor}$ 的值。

Analysis
-

首先对于 $f(x)=\left\lfloor\sqrt[4]x+0.5\right\rfloor$ 有一个非常显然的性质：很多个 $x$ 可能共用一个 $f(x)$（因为 $\sqrt x$ 增长速度一直在变慢，$\sqrt[4]x$ 就变得更慢了）。所以一个显然的思路是对于每个函数值 $val$ 倒着算有多少个自变量的值与之对应，设其为 $\operatorname{cnt}(val)$，那么只需求出 $\sum\limits_{val=1}^{f(n)}\dfrac{\operatorname{cnt}(val)}{val}%\quad(-)$ （其实考虑边界情况还要减去一个 $\left(\dfrac{\operatorname{cnt2}\!\big(f(n)\big)-n}{f(n)}\right)$，因为这里都把 $n$ 当作相同的 $f(n)$ 中自变量的最大值了）即可。单次询问时间复杂度 $\mathcal O(\sqrt[4]n)$，因为 $f(10^{18})=31623$，这是可以接受的（仅针对 $t\leqslant1000%，后面有个简单的优化$）。

接下来思考如何求 $\operatorname{cnt}(val)$。令 $\operatorname{cnt2}(val)%\operatorname{arc}f(x)=x^4$ 为函数值不大于 $val$ 的自变量数量，那么因为 $f(x
)$ 单调递增，我们有 $\operatorname{cnt}(val)=\operatorname{cnt2}(val)-\operatorname{cnt2}(val-1)$。又 $\operatorname{cnt2}(val)=\left\lfloor(val+0.5)^4\right\rfloor%+c$ $%（c 为常数，\operatorname{cnt2}(val)-\operatorname{cnt2}(val-1) 时可消去）$那么直接带入计算即可。

（马蜂稍丑敬请见谅。）

```python
def arcf(x):
    return int(x**4)
a=[[_+1,0] for _ in range(40000)]
for _ in range(1,40000):
    a[_-1][1]=arcf(_+0.5)-arcf(_-0.5)
T=int(input())
while(T):
    T-=1
    n=int(input())
    ans=0
    for p in a:
        x=p[0];y=p[1]
        n-=y
        ans+=y/x
        if(n<=0):
            ans+=n/x
            break
    print("%f" % ans)#以默认保留六位小数的格式输出
```
但这种方法不能通过 $t\leqslant5\times10^5$ 的数据，还需要进一步的优化。$%（upd：发现和上述做法一样的 `c++` 代码已经足以通过此题，于是我加强了数据，把 t 加到了 5\times10^5。）$

发现每次询问如果都是 $10^{18}$ 量级那么每次询问都需要遍历整个数组，但是遍历数组都是从下标 $1$ 开始连续访问的，于是考虑前缀和优化。设 $sum_i=\sum\limits_{val=1}^i\dfrac{\operatorname{cnt}(val)}{val}$ 则单次询问直接输出 $sum_{f(x)}$（仍需处理边界情况）即可，预处理复杂度 $\mathcal O(\sqrt[4]n)$，单次询问复杂度 $\mathcal O(1)%（\`sqrt\` 函数应该可以看成 \$\mathcal O(1)\$ 吧……？）$，可以通过此题所有数据。

$%（未完待续……？）$
```python
a=[int((i+0.5)**4) for i in range(40000)]
Sum=[(a[i]-a[i-1])/i if i else 0 for i in range(40000)]
for i in range(1,40000):
    Sum[i]+=Sum[i-1]
T=int(input())
for _ in range(T):
    n=int(input());r=int(n**0.25+0.5)
    print("%f" % float(Sum[r]-(a[r]-n)/r))
```

Afterword
---
`python` 常数还是有点大，正规比赛中不建议使用。

---

## 作者：Tracy_Loght (赞：1)

观察到这里对整个函数下取整了，则函数必定是一段段的。

那么考虑求这些段的右端点。

而这是显然的，函数取值为 $x$ 时，右端点是 $(x+ 0.4\overline{9})^4$。

既然知道了函数段的右端点，那么再推答案也是显然的。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ld double 
using namespace std;
const ll Mx=40000;
ll t,n,m,k,o[Mx];
ld z[Mx],ln,jl;
ld cost(ld x){
    ld r=(x+0.4999999999999999999999999);
    //我们既然无法表示，那么尽量接近即可 
    return r*r*r*r;
} 
ll find_log(ll l,ll r,ll x){//二分读入 
	if(l==r) return l;
	else if(l>r) return 0;
	ll mid=l+(r-l)/2;
	if(o[mid]>x&&o[mid+1]<=x) return mid-1;
	else if(o[mid]<=x&&o[mid+1]>x) return mid;
	else if(o[mid]>x) return find_log(l,mid-1,x);
	else return find_log(mid+1,r,x);
}
char buf_ans[114];
ll next_n(double last_ans=0,ll get_n=0){
	sprintf(buf_ans,"%.6f",last_ans);
	for(ll i=0,x=0;;i++){
		if(buf_ans[i]=='.')return get_n^x;
		if(i&1)x*=10;
		else x=x*10+(buf_ans[i]^48);
	}
}
int main(){
	ios::sync_with_stdio(0);
    std::cin.tie();
	std::cout.tie();
	for(int i=1;i<=32000;i++){
		ld x=cost(i);
		o[i]=(ll)(x/1);
		ld p=o[i]-o[i-1],v=1;
		p=p*(v/i);
		z[i]=z[i-1]+p;
	}
	cin>>t;
	while(t--){
		cin>>n;
		n=next_n(ln,n);
		ll x=find_log(1,32000,n);
		jl=z[x];		               //计算预处理过的 
		ld yoi=n-o[x],v=1;
		jl=jl+yoi*(v/(x+1.0000000000));//计算不在预处理范围之外的 
		printf("%.6f\n",jl);
		ln=jl;						   //下一次 
	}
    return 0;
}
```

---

## 作者：Poitry (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8574)

写篇题解，纪念一下赛场写出来的一道题，~~顺便水点社贡~~

### 法一：暴力（$15$ 分）

首先从 $1$ 到 $n$ 跑一遍循环预处理一下，求出 $f_i$，然后打个前缀和，每次询问时直接输出答案即可。

注意开浮点数就行。

### 法二（正解）

考虑到对于很多的 $i$，$f_i$ 的值都相等（比如 $1$ 和 $2$），所以可以预处理一下每个 $f_i$ 的值可以对应多少 $i$，并且求一下和，再求个前缀和就行了。

具体应该怎么做呢？

实际运算一下后我发现，对于每个 $i$，$(i+0.5)^4$ 的小数部分为 $0.625$，刚好可以作为两个不同 $f_i$ 之间的分割线，那么就好办了，具体可以见如下代码；

```cpp
//ls[i]、rs[i] 为 f(i) 值相等的左右边界 
ls[1] = 1;
for(int i = 1; i <= sqrt(sqrt(1e18)) + 10; i ++) {
	double x = (i + 0.5) * (i + 0.5);
	x *= x;
	int w = x;
	rs[i] = w;
	ls[i + 1] = w + 1; // i多一点f(i)就变成不一样的值了 
	a[i] = 1.0 / i;
	c[i] = a[i] * (double)(rs[i] - ls[i] + 1); // 每个f(i) 相等的时候，1 / f(i) 值的总和 
	b[i] = b[i - 1] + c[i]; // 前缀和
}
```

那么为什么我在循环的时候是到 $10$ 的 $18$ 次方的四次方根号再加 $10$ 终止呢？因为这个数字的四次方根号并不是一个整数，再开个四次方就会比原数小一点，所以要往后再处理几次。

否则就只有[30分QAQ](https://www.luogu.com.cn/record/88662223)。

那么处理完以后这个题就解决了，每次询问时先加整块前缀和，再加上当前块的部分就行了。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
int n, ls[1000010], rs[1000010];
double a[1000010], c[1000010], b[1000010], lans;
typedef long long ll;
char buf_ans[114];
ll next_n(double last_ans = 0, ll get_n = 0) {
	//last_ans<n<=1e18
	sprintf(buf_ans, "%.6f", last_ans);
	for(ll i = 0, x = 0; ; i ++) {
		if(buf_ans[i] == '.') {
			return get_n ^ x;
		}
		if(i & 1) {
			x *= 10;
		}
		else {
			x = x * 10 + (buf_ans[i] ^ 48);
		}
	}
}
signed main() {
	cin >> n;
	ls[1] = 1;
	for(int i = 1; i <= sqrt(sqrt(1e18)) + 10; i ++) {
		double x = (i + 0.5) * (i + 0.5);
		x *= x;
//		if(x > 1e18) {
//			break;
//		} 
		int w = x;
//		cout << w << ' '; 
//		printf("%0.10f\n", x);
		rs[i] = w;
		ls[i + 1] = w + 1;
		a[i] = 1.0 / i;
		c[i] = a[i] * (double)(rs[i] - ls[i] + 1);
		b[i] = b[i - 1] + c[i];
//		cout << a[i] << ' ' << c[i] << ' ' << ls[i] << ' ' << rs[i] << endl;
//		if(w > 1e18) {
//			break;
//		}
	}
	for(int i = 1; i <= n; i ++) {
		int x;
		cin >> x;
		x = next_n(lans, x);
		double ww = sqrt(sqrt(x)) + 0.5;
		int w = ww;
		lans = b[w - 1];
//		for(int j = 1; j < w; j ++) {
//			lans += c[j];
//		}
		lans += a[w] * (double)(x - ls[w] + 1);
		printf("%0.6f\n", lans);
	}
	return 0;
}
```

---

## 作者：tangzirui1016 (赞：0)

前排的大佬怎么用一大堆公式？我用暴力预处理加数学就过了。

相信大家应该都会 $O(\sqrt{n})$ 枚举从 $[1,n]$ 的完全平方数。只需要枚举是哪个数的平方就行了。即 `for(int i=1;i*i<=n;i++)`。

所以，我们也可以用同样的方法枚举四次方数。发现对于一个正整数 $i$，在 $[R_{i-1}+1,R_i=\lfloor(i+0.5)^4\rfloor]$ 的正整数 $x$ 经过 $f(x)$ 操作后等于 $i$，其中 $R_i$ 表示这样的第 $i$ 个区间的上界。

为什么？首先看下界，不用说，因为是整数序列，且是连续的，所以区间 $i$ 的下界肯定是上个区间的上界 $+1$。再来看上界，为什么 $R_i=\lfloor(i+0.5)^4\rfloor$？

对于 $x$，题目说了 $f(x)$ 为最接近 $\sqrt[4]{x}$ 的整数。设 $f(x)=i$，那么 $\sqrt[4]{x}$ 是不是最远可以达到 $i+0.4999\cdots$（**四舍五入**）。当然这个数可能不是整数，所以要**向下取整**（**不然就往右溢出了**）。所以 $x_{max}=\lfloor(i+0.49\cdots)^4\rfloor$。那我为什么要写成 $\lfloor(i+0.5)^4\rfloor$。第一，加 $0.49\cdots$ 代码难写；其次发现这个稍微调整一点不会错，因为结果一定是小数，但是这玩意向右动一定是下个区间的下界（**四舍五入**），那向左（向下取整）就是这个区间的上界了。

还要记录这个区间的前缀和 $s_i$。

为什么要记录前缀和，因为题目问你的就是一个前缀和的东西。

注意，如果区间为 $i$，那么 $s_i=s_{i-1}+\sum_{j=R_{i-1}+1}^{R_i} \frac{1}{f(j)}=s_{i-1}+\frac{1}{i}\times (R_i-R_{i-1})$。后半部分理解为区间 $[R_{i-1}+1,R_i]$ 有 $(R_i-R_{i-1})$ 个数，每个数对答案的贡献为 $\frac{1}{i}$，总贡献即为上式。

时间复杂度为 $O(\sqrt[4]{n})$。

查询：发现对于一个 $x$，通过我们的预处理，我们这要找到 $f(x)$ 就行了。令 $k=f(x)$，如果求出了 $k$，那么 $ans_x=s_{k-1}+(x-R_{k-1})\times \frac{1}{k}$。和前缀和是一个原理。然后发现他已经告诉我们 $f(x)$ 的求法了，然后就做完了。

**Code**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL N=1e18;
LL a[100005],n;
double ans[100005];
int t;
char buf_ans[114];
inline LL read(){
	LL x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=x*10+(ch-'0'),ch=getchar();
	return x*f;
}
LL next_n(double last_ans,LL get_n){
	sprintf(buf_ans,"%.6f",last_ans);
	for(LL i=0,x=0;;i++){
		if(buf_ans[i]=='.') return get_n^x;
		if(i&1) x*=10;
		else x=x*10+(buf_ans[i]^48);
	}
}
int main(){
	for(LL i=1;i*i*i*i<=N;i++){
		LL k=floor((i+0.5)*(i+0.5)*(i+0.5)*(i+0.5)); //上界
		a[i]=k; 
		ans[i]=ans[i-1]+(k-a[i-1])*1.0/i*1.0; //前缀和
	}
	t=read(),n=read();
	while(t--){
		LL s=floor(sqrt(sqrt(n))+0.5);
		double h=ans[s-1]+(n-a[s-1])*1.0/s;
		printf("%.6lf\n",h);
		if(t>0){
			n=read();
			n=next_n(h,n); //注意这个鬼畜的输入方式
		}
	}
	return 0;
}
```

---

## 作者：Ryder00 (赞：0)

## 思路 ##  
容易发现，当 $n$ 越大时，$\sqrt[4]{n}$ 变化的速度就会越来越慢。考虑从这个性质入手。怎么做呢？由计算器可得，$\sqrt[4]{10^{18}} \approx 31622.5$，其函数值为 $31623$。我们可以对每一个不同的根号值进行预处理，统计出所有根号值对于答案的贡献，复杂度 $O(\sqrt[4]{n})$。进行前缀和优化，实现 $O(1)$ 查询。  
PS：注意使用 long double，不然会出现莫名其妙的精度错误。  
## CODE ##
  
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db long double
ll T=1,n,cnt,st[32000];
db dis[32000],sum[32000],llst,lst;
char buf_ans[114];
ll next_n(double last_ans,ll get_n){
	sprintf(buf_ans,"%.6lf",last_ans);
	for(ll i=0,x=0;;i++){
		if(buf_ans[i]=='.') return get_n^x;
		if(i&1) x*=10;
		else x=x*10+(buf_ans[i]^48);
	}
}
void init(){
	for(db i=0.5;i<=31623.5;i+=1.0){
		if((ll)floor(i)) dis[cnt]=((ll)floor(i*i*i*i+0.5)-llst+1.0)/floor(i);
		if(cnt) sum[cnt]=sum[cnt-1]+dis[cnt];
		llst=ceil(i*i*i*i+0.5);
		st[cnt+1]=llst;
		cnt++;
	}
	cnt--;
}
void solve(){
	scanf("%lld",&n);
	n=next_n(lst,n);
	db p=pow(n,1.0/4.0);
	if(p-(db)floor(p)<0.5){
		lst=sum[(ll)floor(p)-1]+(n-st[(ll)floor(p)]+1.0)/floor(p);
	}
	else{
		lst=sum[(ll)floor(p)]+(n-st[(ll)floor(p)+1]+1.0)/(floor(p)+1.0);
	}
	printf("%.6LF\n",lst);
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	init();
	scanf("%lld",&T);
	while(T--){
		solve();
	}
	return 0;
}
```

---


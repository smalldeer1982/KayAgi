# [蓝桥杯 2014 省 B] 小朋友排队

## 题目描述

$n$ 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。

每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是 $0$。

如果某个小朋友第一次被要求交换，则他的不高兴程度增加 $1$，如果第二次要求他交换，则他的不高兴程度增加 $2$（即不高兴程度为 $3$），依次类推。当要求某个小朋友第 $k$ 次交换时，他的不高兴程度增加 $k$。

请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。

如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。

## 说明/提示

【样例说明】

首先交换身高为 $3$ 和 $2$ 的小朋友，再交换身高为 $3$ 和 $1$ 的小朋友，再交换身高为 $2$ 和 $1$ 的小朋友，每个小朋友的不高兴程度都是 $3$，总和为 $9$。

【数据规模与约定】

对于 $10\%$ 的数据，$1 \le n \le 10$；

对于 $30\%$ 的数据，$1 \le n \le 1000$；

对于 $50\%$ 的数据，$1 \le n \le 10000$；

对于 $100\%$ 的数据，$1 \le n \le 100000$，$0 \le H_i \le 1000000$。

时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
9```

# 题解

## 作者：ZVitality (赞：14)

貌似本来用树状数组做，但是归并也能求。

题目看完后首先想到的应该是冒泡排序，每次直接枚举交换两个相邻的数，然后就可以求解，时间复杂度为 $O(n^2)$。由于 $n\le10^{5}$，不可行。

考虑像分治求逆序对的想法，能否根据两块的结果求出来一个大的结果？显然是可以的，它们之间的距离为 $l-r+1$，那我们就可以像在求逆序对一样，一边分治，一边求答案。

时间复杂度为 $O(n \log n)$，能够稳稳地过。

由于结论很短，我就给点代码理解吧。

```.cpp
void Merge( Point *a , int first , int end ) { //归并排序
	int tmp = first , mid = first + end >> 1 , p = first , q = mid + 1;
	while( p <= mid && q <= end ) 
		if( a[ p ].h > a[ q ].h ) {
			a[ q ].t += mid + 1 - p; //记录答案
			c[ tmp++ ] = a[ q++ ];
		}
		else {
			a[ p ].t += q - 1 - mid; //记录答案
			c[ tmp++ ] = a[ p++ ];
		}
	while( q <= end ) c[ tmp++ ] = a[ q++ ];
	q--;
	while( p <= mid ) a[ p ].t += q - mid , c[ tmp++ ] = a[ p++ ];
	for( int i = first ; i <= end ; i++ ) a[ i ] = c[ i ];
}

void MergeSort( Point *a , int first , int end ) {//分治主程序
	if( first == end ) return;
	int mid = first + end >> 1;
	MergeSort( a , first , mid ) , MergeSort( a , mid + 1 , end );
	Merge( a , first , end );
}
```

难度建议评定：绿/蓝。

---

## 作者：DengDuck (赞：10)

我们考虑求出每个数字的交换次数。

对于一个数字，它一定会和前面比它大的数字交换，后面比它小的数字也一定会和它交换，这非常显然。

所以我们考虑用两个树状数组分别求出前面比它大的数字和后面比它小的数字，最后统计出交换次数。

根据题目，假设一个数字交换了 $k$ 次，那么它的代价就是：
$$
1+2+3+...+(k-2)+(k-1)+k
$$

结合等差数列求和公式，得：

$$
\frac{k(k+1)}2
$$

```cpp
#include<bits/stdc++.h>
using namespace std;

long long n,a[500005],b[500005],t[500005],cnt[500005],ans;
map<long long,int>m;
long long lowbit(long long x)
{
    return x&(-x);
}
long long getsum(long long x)
{
    long long sum=0;
    while(x)
    {
        sum+=t[x];
        x-=lowbit(x);
    }
    return sum;
}
void update(long long x,long long y)
{
    while(x<=500000)
    {
        t[x]+=y;
        x+=lowbit(x);
    }
}
int main()
{
    scanf("%lld",&n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld",&a[i]);
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++)
    {
        m[b[i]]=i;
    }
    for(int i=1;i<=n;i++)
    {
        a[i]=m[a[i]];
    }
    for (int i = 1; i <= n; i++)
    {
        update(a[i],1);//数字可以是0，所以要加1
        cnt[i]+=(i-getsum(a[i])); //统计前面比它大的数字
    }
    memset(t,0,sizeof(t));
    for (int i = n; i >= 1; i--)
    {
        update(a[i],1);
        cnt[i]+=getsum(a[i]-1); //统计后面比它小的数字
    }
    for(int i=1;i<=n;i++)
    {
    	ans+=(cnt[i]+1)*cnt[i]/2;//算出这个数字的代价
    }
    printf("%lld",ans);
    return 0;
}
```

Upd：根据 lawrence142 的反馈，原来的“后面比它大”应该为“后面比它小”，进行更新，重新提交。

Upd:离散化之后确实没有 0。

---

## 作者：_Weslie_ (赞：4)

一道逆序对题目。

## Solution P8613

### Idea

逆序对模板：[P1908](https://www.luogu.com.cn/problem/P1908)。

这道题不难想到的就是冒泡排序。

只要两个数不符合要求，就交换，这样一定可以做到以最少的次数完成。

但是冒泡排序的时间复杂度是 $\operatorname{O}(n^2)$ 的，在 $n\le 10^5$ 的数据范围下不可能通过。

我们来考虑这个冒泡排序的本质过程。

假如有 $H=\{1,5,4,7,2,6,3\}$，$G_i$ 为 $H_1,H_2,\cdots,H_i$ 的有序序列，$t_i$ 为第 $i$ 个小朋友的不满意次数，那么在冒泡排序中会发生什么？

首先对于第一个小朋友，直接进来，不受阻碍。$G_1=\{1\}$，$G_2=\{1,5\}$。

第二个小朋友也不受阻碍。

第三个开始受阻碍了。他需要跨越 $5$，此时 $t_2=t_3=1$，$G_3=\{1,4,5\}$。

第四个不受阻碍，$G_4=\{1,4,5,7\}$。

第五个受阻碍，需要跨越 $4$、$5$ 和 $7$ 三个元素，所以 $t_2=t_3=2$，$t_4=1$，$t_5=3$。$G_5=\{1,2,4,5,7\}$。

第六个受阻碍，不难发现 $t_6=1$，$t_4$ 更新为 $2$。$G_6=\{1,2,4,5,6,7\}$。

第七个直接模拟。留给读者自己手搓。

最后结束发现规律：$t_i=les_i+mor_i$，其中 $les_i$ 指 $a$ 序列中 $i$ 之前的大于 $i$ 的数，$mor_i$ 指 $a$ 序列中 $i$ 之后的小于 $i$ 的数。

证明一下：因为把这个数加入序列的就要跨越所有在它之前比它大的元素，而在它加入序列之后就要被所有在它之后又比它小的元素超过。

再剖析一下就是求与 $i$ 相关的逆序对数。

分成两部分：第一部分求 $a_j>a_i$，其中 $j<i$，这一部分比较朴素。第二部分求 $a_i>a_k$，其中 $i<k$，这一部分倒着求。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005,MAX=1000005;
int n,a[N],tr[MAX];
int lowbit(int x){
	return x&(-x);
}
void add(int x){
	while(x<MAX){
		tr[x]++;
		x=x+lowbit(x);
	}
}
int query(int x){
	int res=0;
	while(x){
		res+=tr[x];
		x-=lowbit(x);
	}
	return res;
}
int ans[N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i]++;
	}
	for(int i=1;i<=n;i++){
		add(a[i]);
		ans[i]=i-query(a[i]);
	}
	memset(tr,0,sizeof(tr));
	for(int i=n;i>=1;i--){
		add(a[i]);
		ans[i]+=query(a[i]-1);
	}
	long long anss=0;
	for(int i=1;i<=n;i++){
//		printf("%lld ",ans[i]);
		anss+=1ll*ans[i]*(ans[i]+1)/2;
	}
	printf("%lld",anss);
	return 0;
}
```

---

## 作者：执着之幻 (赞：1)

### 题意：

给出一个序列，求序列里的每一个数和其他的数构成逆序对的数量，记第 $i$ 个数的逆序对数量为 $f_i$，求 $\sum_{i = 1}^{n}\sum_{j = 1}^{f_i}j$。

### 思路：

题目要求逆序对，而这道题的数据范围达到 $10^5$ ，如果采用暴力的方法会超时，所以需要采用更优的时间复杂度的算法来解，所以可以用一些数据结构进行维护，其他题解大多使用树状数组，这里采用的是线段树（虽然树状数组无论从时间复杂度和码量上看都比线段树好），但这也是一种方法，其时间复杂度为 $ O(n\log n)$，可通过此题。

此题既要从前往后逐个加入并查询每个数前面有多少个和自己成为逆序对，也要从后往前逐个加入并查询每个数后面有多少个和自己成为逆序对，而它们之和即为每个数的逆序对数量。

计算完逆序对数量后，我们可以发现那个式子其实就是求每个数从 $1$ 开始一直加到自己的那个数，这是一个等差数列，可用等差数列公式求解，此求解过程的时间复杂度为 $O(n)$。

注意事项：可用离散化优化空间复杂度和时间复杂度，求两次逆序对数量时记得要把线段树清零，记得开 long long。

总时间复杂度：$O(n\log n)$。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[110000],b[110000];
long long tr[410000],ans,s[110000];
void add(int l,int r,int p,int x)
{
	if(x<l||r<x)return;
	if(l==r)
	{
		tr[p]++;
		return;
	}
	int mid=(l+r)>>1;
	add(l,mid,p*2,x);
	add(mid+1,r,p*2+1,x);
	tr[p]=tr[p*2]+tr[p*2+1];
}//常规线段树加入操作 
long long qy(int l,int r,int p,int x,int y)
{
	if(y<l||r<x)return 0;
	if(x<=l&&r<=y)return tr[p];
	int mid=(l+r)>>1;
	return qy(l,mid,p*2,x,y)+qy(mid+1,r,p*2+1,x,y);
}//常规线段树查询操作 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	int k=unique(b+1,b+1+n)-b-1;//离散化 
	for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+1+k,a[i])-b;
	for(int i=1;i<=n;i++)
	{
		s[i]+=qy(1,k,1,a[i]+1,k);//查询前面有多少数比自己大 
		add(1,k,1,a[i]);//在线段树中加入当前这个数
	}
	memset(tr,0,sizeof(tr));
	for(int i=n;i>=1;i--)
	{
		s[i]+=qy(1,k,1,1,a[i]-1);//查询后面有多少数比自己小 
		add(1,k,1,a[i]);//在线段树中加入当前这个数 
	}
	for(int i=1;i<=n;i++)ans=ans+(s[i]+1)*s[i]/2;//等差数列求解答案 
	cout<<ans;
	return 0;
}
```

---

## 作者：BugGod (赞：1)

记得以前做过一个类似的题，大概就是模拟冒泡排序的过程，求左边大的和右边小的个数，这些都是要交换的，这个过程是 $O(n^2)$ 的，不能通过此题。很快想到可以用树状数组优化此过程，类似于求逆序对，同时题目中 $k$ 次交换的数代价为 $1+2+\cdots+k-1+k=\frac{k(k+1)}{2}$，记录交换次数，代入即可。

CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,h[100010],ans[100010],sum;
struct BIT//树状数组
{
    int tree[1000010];
    int lowbit(int x)
    {
        return x&-x;
    }
    void add(int i,int x)
    {
        for(;i<=1000000;i+=lowbit(i))tree[i]+=x;
    }
    int query(int i)
    {
        int sum=0;
        for(;i>0;i-=lowbit(i))sum+=tree[i];
        return sum;
    }
}bit;
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>h[i];
    for(int i=1;i<=n;i++)
    {
        bit.add(h[i]+1,1);
        ans[i]+=i-bit.query(h[i]+1);
    }
    memset(bit.tree,0,sizeof bit.tree);//这里注意一定要清空，不然会重复计算。
    for(int i=n;i>=1;i--)
    {
        bit.add(h[i]+1,1);
        ans[i]+=bit.query(h[i]);
    }
    for(int i=1;i<=n;i++)sum+=ans[i]*(ans[i]+1)/2;
    cout<<sum;
    return 0;
}
```

---

## 作者：zzx0102 (赞：1)

可以看作是 [P1908](/problem/P1908) 的双倍经验。

显然对于一个小朋友，他一定会和前面比他高的小朋友交换，也会和后面比它矮的小朋友交换。

于是使用树状数组统计前后身高比小朋友高的和后面身高比小朋友低的就可以了。

本题 $H_i$ 较小，直接统计就行，无需离散化。

树状数组代码：

```cpp
int lbt(int x) {return x & (-x);}
void add(int x, int k) {for(; x <= n; x += lbt(x)) tr[x] += k;}
int ask(int x) {int sum = 0; for(; x; x -= lbt(x)) sum += tr[x]; return sum;}
```

---

## 作者：chatoudp (赞：0)

# P8613 题解

## 如何计算每人交换几次？？？

### 结论：
前面比他大的数的个数 $+$ 后面比他小的数的个数

### 原因：
因为前面比他大的数要排在他的后面，但前面比他大的数在他的前面，所以那个数不断往后，他不断往前，在相邻时发生交换。
同样后面比他小的数与他交换也证明类似。

这不就是逆序对吗？？？

来！平衡树！

有些读者：平衡树？？？码量有点大。

介绍一下一个冷门的~~芝士~~知识：

## pb_ds
### 头文件
pb_ds 需要一个头文件（管你是不是万能头，都要有）：
```cpp
#include <bits/extc++.h>
```
但 Dev-c++ 用不了，所以还是背所有头文件吧：
```cpp
#include <ext/pb_ds/assoc_container.hpp>//pb_ds基本的头文件 
#include <ext/pb_ds/tree_policy.hpp>//平衡树 
#include <ext/pb_ds/hash_policy.hpp>//哈希 （分为gp_hash_table和cc_hash_table） 
#include <ext/pb_ds/priority_queue.hpp>//优先队列 
```
### 定义平衡树：

```cpp
__gnu_pbds::tree<//平衡树 
	pair<int,int>,//类型，pair让它不去重
	__gnu_pbds::null_type,//映射的类型，这里不需要，所以为空类型 
	less<pair<int,int> >,//比较
	__gnu_pbds::rb_tree_tag,//红黑树
	__gnu_pbds::tree_order_statistics_node_update//让他统计排名	 
> s;//名字
```

### 平衡树的功能：

其中平衡树与 set 类似，却多了一些功能：

order_of_key() 参数为一个类型为平衡树数据的类型的数，求的是在平衡树内排名，该数排在第几，注意：他是从 $0$ 开始排的。

当然还有一些添加的，不过在这题用处不大。

其余与 set 功能一样。

### 注意：
平衡树会像 set 一样去重，所以无需去重时，可以把 int 变成 pair，第二个位置存一个不同的数。

#### 接下来就是 AC 时间！！！：
```cpp
#include <bits/stdc++.h>
//#include <bits/extc++.h>//Dev-c++用不了，但在CSP可以用 
#include <ext/pb_ds/assoc_container.hpp>//pb_ds基本的头文件 
#include <ext/pb_ds/tree_policy.hpp>//平衡树 
#include <ext/pb_ds/hash_policy.hpp>//哈希 （分为gp_hash_table和cc_hash_table） 
#include <ext/pb_ds/priority_queue.hpp>//优先队列 
using namespace std;
typedef long long ll;
__gnu_pbds::tree<//平衡树 
	pair<int,int>,//类型，pair让它不去重
	__gnu_pbds::null_type,//映射的类型，这里不需要，所以为空类型 
	less<pair<int,int> >,//比较
	__gnu_pbds::rb_tree_tag,//红黑树
	__gnu_pbds::tree_order_statistics_node_update//让他统计排名	 
> s;//名字
int n,a[100005];
ll ans=0,b[100005];//十年oi一场空，不开longlong见祖宗  b表示交换次数 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){//边输入，边统计前面比它大的数 
		scanf("%d",&a[i]);
		b[i]=(i-1)-s.order_of_key({a[i],1000000000});//排名，求出有几个小于等于它的数，再用总数减
		s.insert({a[i],i}); //加入 
	} 
	s.clear();//清空 
	for(int i=n;i>=1;i--){//统计后面比它小的数 
		b[i]+=s.order_of_key({a[i],-1});//排名，求出有几个小于它的数
		ans+=b[i]*(b[i]+1)/2;//加上此人的不开心值 
		s.insert({a[i],i}); //加入 
	} 
	printf("%lld",ans);
	return 0;
}//码量很少QWQ 
```

---

## 作者：IkeveLand (赞：0)

### 归并排序求解

~~烤炉~~考虑求出每个小朋友前后比它大或小的数。

每个小朋友需要交换的次数是前面比它大的数和后面比它小的数，因为前面有比它大的数，它必定和前面的交换一次，使得前面大的数排到后面去，同理可得比它小的数一定要和它交换到前面去。

合并时，我们都同时算出前面比它大的数和后面比它小的数即可。

## Code:

```c
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e6+114;

int a[N], s[N];
int sum[N];
int n;

int lbit (int x) {
    return x & -x;
}

int query (int x) {
    int res=0;
    for(int i=x;i ;i-=lbit (i)) res+=s[i];
    return res;
}

void auid (int x,int v) {
    for(int i=x;i<N;i+=lbit (i)) s[i]+=v;
}
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
		a[i]++;
	} 

    for(int i=1;i<=n;i++) {
        sum[i]=query(N-1)-query(a[i]);
        auid (a[i],1);
    }

    memset (s,0,sizeof (s));
    for(int i=n;i>0;i--){
        sum[i]+=query (a[i]-1);
        auid (a[i],1);
    }

    ll as=0;
    for(int i=1;i<=n;i++) as+=(ll)sum[i]*(sum[i]+1)/2;
    cout<<as;
    return 0;
}
```

---

## 作者：Hyc_ (赞：0)

题意十分明确，就直接讲做法吧。

要通过交换邻项使这个无须的队伍变得有序，那么，每个数必然要和在它前面比它大的数换位一次，和在它后面比他小的数交换一次。所以这题和逆序对有关。

再看下数据范围 $1\le n \le 10^5$，所以考虑树状数组或归并排序，这里只讲解树状数组。

可以通过两次树状数组求出在它前面比它大的数与在它后面比他小的数的个数和。

但是直接这样写可能只有 [$30$ 分](https://www.luogu.com.cn/record/115039260)，数据范围是为 $0 \le H_i \le 10^6$，不需要离散化，但是在树状数组中插入 $0$ 的操作会无限循环导致 TLE，所以可以把每个数加一。

接下来是~~你们最爱的~~代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e6+5,m=1e6+1;
ll n,a[N],t[N],cnt[N],ans;
inline ll lowbit(ll x){return x&-x;}
inline void add(int i){
	for(;i<=m;i+=lowbit(i))
		++t[i];
}
inline ll query(int i){
	ll sum=0;
	for(;i;i-=lowbit(i))
		sum+=t[i];
	return sum;
}
template<typename T>inline T read(){
	T ret=0,fh=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')fh=-1;ch=getchar();}
	while(isdigit(ch))ret=(ret<<1)+(ret<<3)+(ch^48),ch=getchar();
	return ret*fh;
}
int main(){
	n=read<ll>();
	for(int i=1;i<=n;++i)
		a[i]=read<ll>()+1;
	for(int i=1;i<=n;++i){
		cnt[i]+=i-query(a[i])-1;
		add(a[i]);
	}
	memset(t,0,sizeof(t));
	for(int i=n;i;--i){
		cnt[i]+=query(a[i]-1);
		add(a[i]);
	}
	for(int i=1;i<=n;++i)
		ans+=((cnt[i]+1)*cnt[i])>>1;
	printf("%lld\n",ans);
	return 0;
}
```

---


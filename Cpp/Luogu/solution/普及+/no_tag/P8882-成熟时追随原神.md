# 成熟时追随原神

## 题目背景

可莉喜欢生活在树上。

![](https://img2.huashi6.com/images/resource/2021/04/29/8945867h9p0.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)

画师 pid：4787895

## 题目描述

可莉生活在一颗有根树上，初始节点从 $1$ 到 $n$ 编号。为了方便可莉的出行，蒙德人决定从每个非叶子节点出发，修建一条新道路。具体而言，对与每个非叶子节点 $u$，蒙德人会从其子节点中均匀随机选取一个点 $v$，并在 $u$ 和 $v$ 之间修建一条新道路。显然，这些新修建的道路连成了许多的连通块。为了帮助他们的修建，你需要告诉蒙德人，连通块个数的期望是多少。

可莉听说这个任务后，认为它对于你而言太简单了。因此，她决定添加一些对于树的修改操作：

- $\text{Add}\ u$：在节点 $u$ 下添加一子结点，编号为 $n+i$，其中 $i$ 为操作编号。保证操作前结点 $u$ 存在。
- $\text{Del}\ u$：删除结点 $u$。保证操作前结点 $u$ 存在且为叶子结点。
- $\text{Upd}\ u$：将树根变为 $u$。保证操作前结点 $u$ 存在。

同时，对于任意时刻，保证树不会被删空。

对于初始的树和每次修改之后所得的树，你都需要回答一遍上述的问题。注意，$m$ 次修改之间不独立，但是蒙德人每次修建的新道路不受上一次结果的影响。

## 说明/提示

$$
\begin{array}{|c|c|c|c|}\hline
\textbf{测试点编号}& { n\le} & {m\le} & \textbf{特殊性质} \cr\hline
1\sim 3 & 5 & 5 & - \cr\hline
4\sim 7 & 1000 & 1000 &- \cr\hline
8\sim 10 & 10^5 & 0 & - \cr\hline
11\sim 13 & 10^5 & 2\times 10^5 & \textbf{AB}\cr\hline
14\sim 16 & 2\times 10^5 & 5\times 10^4 & \textbf{A} \cr\hline
17\sim 20 & 2\times 10^5 & 2\times 10^5 & - \cr\hline
\end{array}
$$

- 特殊性质 $\textbf{A}$：保证不存在 $\text{Upd}$ 操作。
- 特殊性质 $\textbf{B}$：保证不存在 $\text{Del}$ 操作。

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$。保证 $1\le f_i<i$。

## 样例 #1

### 输入

```
2
1
4
Add 1
Upd 2
Del 3
Del 1```

### 输出

```
1
2
1
1
1
```

# 题解

## 作者：gan1234 (赞：11)

## 分析

首先我们要知道，一个图里连通块的数量是点数减去边数。

分析题目，每个非叶结点都从子结点中选取一个点 $v$ 与之连接，也就是说有多少非叶结点就有多少条边。
我们令 $x$ 为叶结点数量，那么 $n-x$ 就是边的数量，连通块的数量就是 $n-(n-x)$，也就是 $x$。

我们发现叶结点有多少，连通块就有多少，题目就简化为求叶结点的数量。

## 做法

如何求叶结点数量？首先用一个变量，储存初始树的叶结点数量，再分别对于每个操作更新答案。

* Add 操作：如果 $u$ 是非叶结点，叶结点数量加一，如果 $u$ 是叶结点，叶结点总数不变。
* Del 操作：如果 $u$ 的父结点是非叶结点，叶结点数量减一，如果 $u$ 的父亲是叶结点，叶结点总数不变。
* Upd 操作：如果原来的根只有一个儿子，那么操作后就会变成叶结点，叶结点数就加一。如果新的根原来是叶结点，操作后叶结点数就减一。

因为要进行删边和访问父结点操作，所以可以用 set 来维护每个点的邻点。如果一个点只有一个邻点，那么这个点就是叶结点。叶结点的父结点就是唯一的邻点。

## 代码

最多 $n+m$ 个点和删边 $m$ 次，所以复杂度为 $O(n+m\log(n+m))$

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_set<int>s[400005];
int n,m,rt=1;
int ans;
int f(int x){//判断是否是叶结点
    return (x==rt&&s[x].size()==0)||(x!=rt&&s[x].size()==1);
}
int main(){
    cin>>n;
    int x;
    for(int i=2;n>=i;i++){
        cin>>x;
        s[i].insert(x);s[x].insert(i);
    }
    for(int i=2;n>=i;i++)
        if(s[i].size()==1)ans++;
    cout<<ans<<endl;
    cin>>m;
    string str;
    for(int i=1;m>=i;i++){
        cin>>str>>x;
        if(str=="Add"){
            if(!f(x))ans++;
            s[x].insert(n+i);s[n+i].insert(x);
        }
        if(str=="Del"){
            s[*s[x].begin()].erase(x);
            if(!f(*s[x].begin()))ans--;
        }
        if(str=="Upd"){
            int y=rt;rt=0;
            if(f(x)&&!f(y))ans--;
            if(!f(x)&&f(y))ans++;
            rt=x;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```



---

## 作者：H2ptimize_AFO (赞：6)

upd on 2024/01/29：修改一处笔误。

---
~~很好的一道题，使我草元素充盈。~~

看一眼样例：似乎没有需要乘逆元的结果。

加上比赛声明：本次比赛的题目较为特别，不属传统 OI 题目的范畴。

再回顾上一道 P8881，基本确定又是诈骗题。

---
定义「树形框架」等价于初始给出的那棵树。

先重新把题面理解一下：给定一个树形框架，进行若干次操作。对于每次操作，你需要查询当前框架下，进行连边操作后的连通块个数。

而根据题目描述，连边操作即为：对于每个非叶子节点 $u$，随机选取一个子结点 $v$，并在 $u$ 和 $v$ 之间连边。

显然，连边操作次数等于非叶子结点数目，并且所连边不存在自环或重边。由于连边操作次数明显小于当前结点总数，因此连通块个数即为节点总数与连边条数之差，即**叶子结点**数目。

于是我们发现，连通块个数的期望与连边方式没有任何关系，它等于叶子结点个数。对于每次操作，只需要维护当前树形框架的叶子结点数量即可。

设当前状态下叶子结点数量为 $klee$（注意叶子结点是度数为 $1$ 的充分不必要条件，两者并不等价）：
- Add：如果 $u$ 不是叶子结点，$klee\gets klee+1$；如果 $u$ 是叶子结点，$klee$ 不变。
- Del：如果 $u$ 的父结点在删掉 $u$ 后变为叶子结点，$klee\gets klee-1$；否则 $klee$ 不变。
- Upd：如果原来的根度数为 $1$，那么操作后就会变成叶子结点，$klee\gets klee+1$；如果新的根原来是叶子结点，$klee\gets klee-1$。

用 set 代替 vector 进行存图，可以在 $n\log n$ 级别的复杂度内解决。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int MAXN=2e5+10,P=998244353;

int n,root=1,klee,m;
set<int>T[MAXN*2];

bool check(int u)
{
	if((u==root&&T[u].empty())||(u!=root&&T[u].size()==1))return true;
	else return false;
}

int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		int fa;
		cin>>fa;
		T[i].insert(fa);
		T[fa].insert(i);
	}
	for(int i=2;i<=n;i++)
	{
		if(T[i].size()==1)klee++;
	}
	cout<<klee<<'\n';
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		string op;
		int u;
		cin>>op>>u;
		if(op=="Add")
		{
			if(!check(u))klee++;
			T[u].insert(n+i);
			T[n+i].insert(u);
		}
		if(op=="Del")
		{
			T[*T[u].begin()].erase(u);
			if(!check(*T[u].begin()))klee--;
		}
		if(op=="Upd")
		{
			if(T[u].size()==1&&T[root].size()!=1)klee--;
			if(T[u].size()!=1&&T[root].size()==1)klee++;
			root=u;
		}
		cout<<klee<<'\n';
	}
	return 0;
}
```

---

## 作者：CWzwz (赞：4)

有个 [hack 帖](https://lglg.top/543133)，但是当时没处理，可以的话请管理看看吧。

（我加了代码公开计划，但是看不到任何人代码，所以没法验证，只好麻烦管理。不知道为啥，bug or feature？）

### [P8882](https://www.luogu.com.cn/problem/P8882) 题解

------------

先考虑静态情况。

树形 dp，设 $f_u$ 表示 $u$ 的子树内连通块个数的期望。则叶子节点的 $f$ 值为 $1$。

转移：随机取一条边连上，那么不管连哪里，都只会将下面的某个连通块扩大 $1$，不影响个数。所以 $f_u = \sum_{v\in\operatorname{son}_u}f_v$。

这其实就是叶子结点个数，问题转化为求叶子结点个数，和期望什么的没关系了就。这样诈骗真的有意思吗（

------------

定义：

下文“叶子节点”表示无根树意义下的叶子。即，“当前根”的度数 $\le1$ 时，也可能被认为是“叶子节点”。

“度数”表示一个节点所连边的数量。

------------

先搜出初始树中的叶子数量 $k$，然后维护它：后续只要某个点的度数被**改为了** $1$ 或 $0$ 就增加 $k$，只要某个点的度数**不再是** $1$ 或 $0$ 就减少 $k$。

输出答案的方法：根据题目中叶子节点的定义，当前的根节点视为不算叶子。所以，如果当前根是“叶子节点”，就输出 $k-1$，否则输出 $k$ 即可。

- $\text{Add u}$：给 $u$ 增加一个儿子，那么这个儿子一定是叶子，$k\leftarrow k+1$，并更新 $u$ 和新点的度数。

- $\text{Del u}$：删除 $u$，由于保证是叶子而且树不会删空，所以 $u$ 的度数肯定是 $1$。那么就把它所连的这个点 $v$ 的度数减少 $1$，并标记 $u$ 为已删除，不再管它。

- $\text{Upd u}$：换根，直接 $rt \leftarrow u$ 即可。$rt$ 是记录当前根的。

$\Theta(n+m)$。

（已过讨论区 hack）

用了 306ms，几乎最优解，但是有一个完隐老哥好快啊啊啊，卡不过/fn/ll

放个简洁点的，卡常代码太抽象了（

```cpp
// Problem: 8882
#include<iostream>
#include<stdio.h>
#define fore(i,u,v) for(int i=head[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)
const int N = 4e5 + 10;

int n, q, cnte, rt = 1;
int head[N], deg[N], del[N]; // deg 度数，del 是否被删掉了
char opt[5];

struct edge {
    int v, nxt;
} e[N << 1];

void adde(int u, int v) {
    e[++cnte] = (edge){v, head[u]};
    head[u] = cnte;
}
bool leaf(int u) {
    return deg[u] <= 1;
}

int main() {
    std::cin >> n;
    for(int i = 2, f; i <= n; i++) {
        scanf("%d", &f);
        adde(i, f);
        adde(f, i);
        deg[i]++, deg[f]++;
    }
    std::cin >> q;
    int k = 0;
    for(int i = 1; i <= n; i++) if(leaf(i)) k++;
    printf("%d\n", k - leaf(1));
    for(int i = n + 1, x; i <= n + q; i++) { // 为了方便，循环的是插入节点的编号
        scanf(" %s %d", opt, &x);
        if(opt[0] == 'A') {
            if(!leaf(x)) k++;
            adde(i, x);
            adde(x, i);
            deg[i]++, deg[x]++;
        } else if(opt[0] == 'D') {
            if(leaf(x)) k--;
            del[x] = 1;
            fore(j, x, v) { // 找到 u 的连边
                if(del[v]) continue;
                deg[v]--;
                if(leaf(v)) k++;
            }
        } else {
            rt = x;
        }
        printf("%d\n", k - leaf(rt));
    }
    return 0;
}
```

---

## 作者：hyx761 (赞：2)

# 理解题意
注意到对于每一个非叶节点，它与它的儿子之间都会被连接上一条道路，而对于一棵树来说，任意两个节点之间只有一种走法，连接两个节点，联通块数一定 $-1$。

而原先没有道路时，每一个节点都是一个独立的联通块，减去了非叶节点数，那么题目问的本质上就是：**叶节点数！**

然后分别看三种操作：  

- $\text{Add}$ $u$ 操作：如果 $u$ 原来是叶节点，那么增加的节点就会取代它成为叶节点，叶节点数不变；如果 $u$ 不是叶节点，那么增加的节点就是新的叶节点，叶节点数 $+1$。
- $\text{Del}$ $u$ 操作：删除了一个叶节点，叶节点数 $-1$，如果删除的节点的父亲在删除后也是叶节点，那么叶节点数 $+1$。
- $\text{Upd}$ $u$ 操作：如果在换根后原来的根成为了叶节点，那么叶节点数 $+1$，而如果原来的叶节点变成了新的根，那么叶节点数 $-1$。

还要注意一个点，就是对于叶节点的判定有 $2$ 种情况，一种是只与父亲相连，还有一种是只有一个节点的时候它自己也是叶节点。

# 算法实现
使用邻接表存储，并且维护叶节点数以及根节点（判叶节点的时候用到）

# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, u, leaf, root = 1, tmp;
string op;
vector <int> to[400010];
bool check(int x)
{
    return x == root and to[x].size() == 0 or x != root and to[x].size() == 1;
}
signed main()
{
    ios :: sync_with_stdio(false); cin.tie(0);
    cin >> n;
    for (int i = 2; i <= n; i++)
    {
        cin >> u;
        to[i].push_back(u);
        to[u].push_back(i);
    }
    for (int i = 1; i <= n; i++) if (check(i)) leaf++;
    cout << leaf << endl;
    cin >> m;
    for (int i = 1; i <= m; i++)
    {
        cin >> op >> u;
        if (op == "Add")
        {
            if (not check(u)) leaf++;
            to[u].push_back(n + i);
            to[n + i].push_back(u);
        }
        if (op == "Del") 
        {
            to[to[u][0]].erase(remove(to[to[u][0]].begin(), to[to[u][0]].end(), u), to[to[u][0]].end());
            if (not check(to[u][0])) leaf--;
        }
        if (op == "Upd")
        {
            tmp = root;
            root = -1;
            if (check(tmp)) leaf++;
            if (check(u)) leaf--;
            root = u;
        }
        cout << leaf << endl;
    }
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：2)

诈骗。

先放结论：只用统计叶子节点个数即可。

## 证明

很明显连一条边后连通块个数会 $-1$。

所以树上的连通块个数为 $n-\text{有向下的边的节点个数}$，即没有向下的边的节点个数。

而所有没有向下的边的节点肯定都是叶子，所以题目转化成求叶子个数 $ans$。

## 实现

对于每个操作，分开考虑：

- $\texttt{Add}$：如果 $x$ 是叶子，$ans$ 不变，否则 $ans\leftarrow ans+1$。
- $\texttt{Del }$：如果 $x$ 的父亲得出度 $=1$，那么 $ans$ 不变，否则 $ans\leftarrow ans-1$。
- $\texttt{Upd}$：如果 $x$ 是叶子，那么 $ans\leftarrow ans-1$。如果之前祖先入度为 $1$，那么 $ans\leftarrow ans+1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n,m,ans,num;
set<int> v[1000005];
int root=1;

bool leaf(int x){
	return (x==root)?v[x].size()==0:v[x].size()==1;
}

signed main(){
	cin>>n;
	num=n;
	int x;
	for(int i=2;i<=n;i++){
		cin>>x;
		v[i].insert(x);
		v[x].insert(i);
	}
	for(int i=2;i<=n;i++){
		if(leaf(i)) ans++;
	}
	cout<<ans<<endl;
	cin>>m;
	string s;
	int rroot;
	for(int i=1;i<=m;i++){
		cin>>s>>x;
		if(s=="Add"){
			if(!leaf(x)) ans++;
			v[n+i].insert(x);
			v[x].insert(n+i);
		}
		if(s=="Del"){
			v[(*v[x].begin())].erase(x);
			if(!leaf((*v[x].begin()))) ans--;
		}
		if(s=="Upd"){
			rroot=root;
			root=0;
			if(leaf(x)) ans--;
			if(leaf(rroot)) ans++;
			root=x;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：Lacuna (赞：1)

### 思路：

在图中没有边时，显然每个点都是一个联通块，我们考虑连边，显然，每连一条边，联通块个数减 $1$。则联通块的个数就是没有出度的结点的个数，即叶子结点，所以本题本质上是求叶子结点的个数。

### 实现：

我们设叶子结点的个数是 $cnt$，则对于三种操作：

- Add：增加一个结点，若它的父亲不是根结点，则它会成为一个新的叶子结点，$cnt$ 加 $1$。

- Del：若这个结点删去后，它的父亲不是叶子结点，则叶子结点的个数减 $1$，$cnt$ 减 $1$。

- Upd：若这个点原来是叶子结点，则成为根后叶子结点的个数减 $1$，$cnt$ 减 $1$，若原来的根的度数是 $1$，则它会变成一个叶子结点，$cnt$ 加 $1$。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar
template<typename T>inline void read(T&x){x=0;char ch=gc();while(ch<'0'||ch>'9')ch=gc();while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
const int ri=2e5+5;
int n,fa,m; set<int> e[2*ri]; char opt[5]; int x,cnt,rt=1;
bool check(int u){//判断是否为叶子结点 
  return (u==rt&&!e[u].size())||(e[u].size()==1&&u!=rt);
}
int main(){
  read(n);
  for(int i=2;i<=n;i++){
  	read(fa);
  	e[i].insert(fa); e[fa].insert(i);
  }
  for(int i=2;i<=n;i++) if(e[i].size()==1) cnt++;//统计原本叶子结点的个数 
  printf("%d\n",cnt);
  read(m);
  for(int i=1;i<=m;i++){
    scanf("%s%d",opt+1,&x);
    if(opt[1]=='A'){
      if(!check(x)) cnt++;//若它的父亲不是根结点，则它会成为一个新的叶子结点 
      e[x].insert(n+i);//连边 
      e[n+i].insert(x);
	}else if(opt[1]=='D'){
	  e[*e[x].begin()].erase(x);//从他父亲那删去这个结点 
	  if(!check(*e[x].begin())) cnt--;//若这个结点删去后，它的父亲不是叶子结点 
	}else{
	  int v=rt; rt=0;
	  if(check(v)) cnt++;//若这个点原来是叶子结点
	  if(check(x)) cnt--;//若原来的根的度数是 1
	  rt=x;//更新 
	}
	printf("%d\n",cnt); 
  }
  return 0;
}
```

---


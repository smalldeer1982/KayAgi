# [RC-06] ijk

## 题目描述

给定一个序列 $[a_1,a_2,a_3,\dots,a_n]$，保证 $\forall i\in [2,n], a_i\ge a_{i-1}$。

计算有多少整数三元组 $(i,j,k)$ 满足：

- $1\le i,j,k\le n$。
- $a_i\times j\times a_k=i+a_j+k$。

## 说明/提示

本题有三个子任务。

所有数据均满足：$1\le n\le 10^6$，$1\le a_i\le 10^6$，$a_i\ge a_{i-1}$。

- 子任务 $1$（$5$ 分）：$n\le 500$。
- 子任务 $2$（$5$ 分）：$a_i\le 10 $。
- 子任务 $3$（$90$ 分）：无特殊限制。

## 样例 #1

### 输入

```
5
2 3 3 4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
10
1 1 2 2 3 3 4 4 5 8```

### 输出

```
25```

# 题解

## 作者：pikiuk (赞：6)

注意到 $i+a_j+k$ 有上界 $m\leq 3\times 10^6$，因此我们可以大胆枚举左边的 $a_i,j,a_k$ 的值，这部分的复杂度不超过 $m\log^2 m$。

之后我们相当于要求出有多少个 $i,k$ 满足 $i+j=a_i\times j\times a_k - a_j$，又因为序列有单调性，$i,j$ 的取值范围都是一段区间，这个很容易用桶记一下求出具体的区间。

现在相当于求解 $x+y=z$ 且 $x\in [l_1,r_1]$，$y\in[l_2,r_2]$ 的解的个数，不难 $\mathcal{O}(1)$ 求解。

---

## 作者：翟翟 (赞：3)

第一次读题的时候没看到 $a_i\ge a_{i-1}$，不过后来发现其实没有这个限制也可以（因为三元组 $(i,j,k)$ 满足 $1\le i,j,k\le n$，所以自己排序一下也可以）。


记 $maxx=\max a_i$，$l_x$ 为 $x$ 第一次出现的位置，$r_x$ 为 $x$ 最后一次出现的位置，$f_x$ 记录 $x$ 是否存在于数列中。

我们先观察等式 $a_i\times j\times a_k=i+a_j+k$。

我们发现等式右侧有最大值 $n\times 2+maxx \le 3\times 10^6$。
所以我们尝试枚举 $a_i$ 的值、$j$ 和 $a_k$ 的值。枚举时，我们记 $s=a_i\times j \times a_k-a_j$，然后求有多少组 $i,k$ 满足 $i+k=s$，此时 $[s-r_{a_i},s-l_{a_i}]$ 为可取的 $k$ 的区间，$[l_{a_k},r_{a_k}]$ 为 $a_k$ 实际存在的区间。可 $\mathcal{O}(1)$ 求解。

记 $m=n+\max a_i$，枚举的时间复杂度即为总复杂度为 $\mathcal{O}(m \log^2 m)$。

## Code

```
#include<bits/stdc++.h>
using namespace std;
namespace IO{
	static const int buf_size=1000000;
	static unsigned char buf[buf_size];
	static int buf_len,buf_pos;
	bool isEOF(){
		if(buf_pos==buf_len){
			buf_pos=0;
			buf_len=fread(buf,1,buf_size,stdin);
			if(buf_pos==buf_len)return 1;
		}
		return 0;
	}
	inline char gc(){
		return isEOF()?EOF:buf[buf_pos++];
	}
	template<typename T>
	inline void read(T&x){
		x=0;
		char c=gc();
		for(;c<48||c>57;c=gc());
		for(;c>=48&&c<=57;c=gc())
			x=(x<<1)+(x<<3)+(c^48);
	}
	template<typename T,typename...Ts>
	inline void read(T&x,Ts&...rest){
		read(x);
		read(rest...);
	}
}
using namespace IO;
const int N=1e6+1;
int n,a[N],l[N],r[N],s;
bool f[N];
long long ans;
int cnt(int a,int b,int l,int r){//可去的 $k$ 是一段区间
	int h=0;
	if(a>=l&&b<=r)h=b-a+1;
	else if(a<=l&&b>=r)return r-l+1;
	else if(a>=l&&a<=r&&s>=r)h=r-a+1;
	else if(a<=l&&b>=l&&b<=r)return b-l+1;	
	return h;
}
int main(){
	read(n);
	for(int i=1;i<=n;++i){
		read(a[i]);
		f[a[i]]=1;
		if(a[i]>a[i-1]){
			l[a[i]]=i;
			r[a[i-1]]=i-1;
		}
	}
	r[a[n]]=n;
	for(int i=1;i<=n;++i)//此处i,k为a[i],a[k]的值
		for(int j=1;j<=n&&i*j<=n*3;++j)
			for(int k=1;k<=n&&i*j*k<=n*3;++k){
				if(!f[i]||!f[k])continue;
				s=i*j*k-a[j];
				//s=i+k=a[i]*j*a[k]-a[j]
				ans+=cnt(s-r[i],s-l[i],l[k],r[k]);
				//可取k的范围，k实际存在的范围 
			}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：moon_set (赞：2)

# P8912 [RC-06] ijk 题解

引言：最后一个要消灭的敌人是 ~~TLE~~ long long。

## 子任务一思路

很直白，暴力搜索即可。

代码如下。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;

int a[N],n,cnt;

int main(){
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                if(i+a[j]+k==a[i]*j*a[k]) cnt++;
    cout<<cnt<<endl;
    return 0;
}
```

结果：TLE $16$ 个点，$5$ 分。

---

## 子任务二思路

开始没有什么灵感，没想到 $a_i$ 的大小为什么会影响大方向。于是很长一段时间都给用来给上一种做法优化了。

（如果暴力+上下界优化有大佬能弄出来记得留言）

---

## 子任务三思路（AC 思路）

注意到 $a_i$ 和 $n$ 数据规模相同，都 $\le 10^6$。于是就有了这个思路——**正难则反**。

**正难则反**即不枚举下标，而是直接枚举数。因为给出的序列单调不降。所以相等的数都**在一起**。所以我们用 $l$ 和 $r$ 两个数组储存每个数开始与结束的下标。这样就可以用数来逆求出坐标范围，为下面统计答案奠定基础。

（注意用一个 bool 数组储存这个数是否存在）

```c++
for(int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
        v[a[i]]=1;
        if(a[i]!=a[i-1]) l[a[i]]=i,r[a[i-1]]=i-1;
    }
r[a[n]]=n;  //这句话一定要加
```

---

接下来用三层循环来搜索答案：$j$ 枚举其下标，$i,k$ 枚举 $a_i,a_k$ 的值。

上界就是 $a_i \times j \times a_k$ 最大的时侯，即 $3 \times 10^6$ 时，退出循环。

注意要判断 $i,k$ 是否在 $a$ 数组中，若没有要跳过。

```c++
for(int j=1;j<=n;j++){
        for(int i=1;i<=a[n];i++){
            if(j*i>3000000) break;  //上界
            if(!v[i]) continue;  //没有这个数跳过
            for(int k=1;k<=a[n];k++){
                int t=j*i*k;
                if(t>3000000) break;  //上界
                if(!v[k]) continue;  //没有这个数跳过
                t-=a[j];
                ans+=q(t-r[i],t-l[i],l[k],r[k]);  //两个限制条件取交集
            }
        }
    }
```

---

最后说一下如何统计答案。

当 $i,j$ 的值固定时，$k$ 的取值是有范围的，有两个限制条件：

1. 题目中的等式
2. $l$ 和 $r$ 数组中存储 $k$ 的上界和下界

将这两个限制条件取交集，保留整数解，就可以得到在当前的 $i,j$ 的条件下 $k$ 的数量。

```c++
int q(int l1,int r1,int l2,int r2){
    if(l1<=l2&&r2<=r1) return r2-l2+1;
    if(l2<=l1&&r1<=r2) return r1-l1+1;
    if(l2<=l1&&r2>=l1) return r2-l1+1;
    if(l2<=r1&&r2>=r1) return r1-l2+1;
    return 0;  //没有交集，没有答案
}
```

然后只需枚举所有可能的 $i,j$，统计出答案总数即可。~~（不要见祖宗）~~

总体时间复杂度为 $O(n\log^2n)$，$3s$ 的时间限制够跑了。

---

## AC Code

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;

int a[N],n,l[N],r[N];
long long ans;
bool v[N];

int q(int l1,int r1,int l2,int r2){
    if(l1<=l2&&r2<=r1) return r2-l2+1;
    if(l2<=l1&&r1<=r2) return r1-l1+1;
    if(l2<=l1&&r2>=l1) return r2-l1+1;
    if(l2<=r1&&r2>=r1) return r1-l2+1;
    return 0;  //没有交集，没有答案
}

int main(){
    cin>>n;
    int cnt=0;
    for(int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
        v[a[i]]=1;
        if(a[i]!=a[i-1]) l[a[i]]=i,r[a[i-1]]=i-1;  //统计开始和结束的下标
    }
    r[a[n]]=n;  //这句话一定要加
    for(int j=1;j<=n;j++){
        for(int i=1;i<=a[n];i++){
            if(j*i>3000000) break;  //上界
            if(!v[i]) continue;  //没有这个数跳过
            for(int k=1;k<=a[n];k++){
                int t=j*i*k;
                if(t>3000000) break;  //上界
                if(!v[k]) continue;  //没有这个数跳过
                t-=a[j];
                ans+=q(t-r[i],t-l[i],l[k],r[k]);  //两个限制条件取交集
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

若有不对的地方留言，第一时间改正 QwQ。

---


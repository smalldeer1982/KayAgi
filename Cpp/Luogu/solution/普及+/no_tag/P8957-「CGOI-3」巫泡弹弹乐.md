# 「CGOI-3」巫泡弹弹乐

## 题目背景

mc 正在挑战弹弹乐。

![](https://cdn.luogu.com.cn/upload/image_hosting/yaye0cgu.png)

## 题目描述

弹弹乐由 $n$ 个弹力菇组成，每个弹力菇有 $a,b$ 两个属性。

对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\max(a_i,a_j)+\max(b_i,b_j)$ 的双向弹力通道。现在 mc 想知道弹力菇组成的图的最小生成树，以便他打破记录。

## 说明/提示

#### 数据范围

**「本题采用捆绑测试」**

$$\def\arraystretch{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & n\le 500 & \text{无} & 20 \cr\hline
2 & n\le 5\times 10^4 & \text{无} & 20\cr\hline
3 & \text{无特殊限制} & \text{数据随机} & 20\cr\hline
4 & \text{无特殊限制} & \text{无} & 40 \cr\hline
\end{array}$$

- 对于 $100\%$ 的数据，满足：$1\le n\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
3
1 2 1
3 2 3```

### 输出

```
9
1 2
1 3```

# 题解

## 作者：MCRS_lizi (赞：5)

贪心思路，简洁明了。

## 题目分析
我们都~~应该~~学过最小生成树的计算方式，这里就不多讲了。

我们考虑一个点一个点的加入进来，这样肯定会和之前某个点产生连接，最简单的贪心思路就是使这条新产生的连边尽可能小就可以了。由于加入点的顺序并不会产生影响，我们不妨按数列 $a$ 从小到大排序，这样加入第 $i$ 个点时数列 $a$ 产生的贡献一定是 $a_i$，这时只需要考虑数列 $b$ 产生的贡献即可。

其实我们只需要找到已经加入的点之中对应 $b_i$ 最小的那个，与其连边即可。这个直接记录之前的最小值即可。

问题来了，怎么证明这个贪心思路的正确性？

首先我们令数列 $A,B$ 分别为 $a,b$ 从小到大排完序后的结果。

很显然，数列 $a$ 产生的贡献就是 $\sum_{i=2}^n A_i$，并且这个贡献值是对于 $a$ 可以取到的最小贡献。

那么对于数列 $b$，我们每加入一个新的 $b_i$，无非有两种情况：

1. 比数列中最小的大，只会计算一次；
2. 比数列中最小的小，不计算，替代最小的，在之后被计算一次后丢弃。

考虑到 $B_1$ 不可能被计算，贡献依然是 $\sum_{i=2}^n B_i$。

这道题就算是搞定了。

## CODE：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans;
struct edge
{
	int u,v;
}l[1000010];
struct num
{
	int a,b,xh;
}p[1000010],minn;
bool cmp(num u,num v)
{
	return u.a<v.a;
}
signed main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].a;
		p[i].xh=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>p[i].b;
		p[i].xh=i;
	}
	sort(p+1,p+n+1,cmp);
	minn=p[1];
	for(int i=2;i<=n;i++)
	{
		ans+=p[i].a;
		num u=minn;
		ans+=max(u.b,p[i].b);
		if(p[i].b<minn.b)
		{
		    minn=p[i];
		}
		l[i].u=p[i].xh,l[i].v=u.xh;
	}
	cout<<ans<<"\n";
	for(int i=2;i<=n;i++)
	{
		cout<<l[i].u<<" "<<l[i].v<<"\n";
	}
 	return 0;
}

```


---

## 作者：jiangjiangQwQ (赞：3)

### 思路
看到边权取得两 $\max$，所以可以给其中一个数组升序排序去掉一重限制。这里排的是 $a$ 数组，这一部分的贡献显然是 $\sum_{i=2}^{n}{a_i}$，并且达到最优情况，那么这个情况下如果 $b$ 数组也能达到最优贡献那么总贡献就是最小的。这个时候最小贡献在升序后也是 $\sum_{i=2}^{n}{b_i}$，所以我们要看怎么连边能使贡献凑到 $\sum_{i=2}^{n}{b_i}$。
![](https://cdn.luogu.com.cn/upload/image_hosting/w1pjgwnk.png)
先给出结论：每个 $i$ 向前缀最小的 $b_j,j<i$ 连边就是最小的，如何证明？

看到上方的图片，假设 $b$ 数组中的元素分别为 $6,5,3,2,1,4$。那么对于最小值 $1$ 而言，$4$ 直接向 $1$ 连边就好了，这样 $4$ 就加到了 $sum$ 里面，现在我们先不考虑 $1$ 会怎么连，即使 $1$ 要连那增加的贡献也只能是前面的某一个数 $x \in \{2,3,5,6\}$。问题变为一个子问题，如何在前四个数连边到达最优？根据前面的铺垫可以知道前面四个数的最优贡献 $sum=6+5+3=14$。那么最小值 $2$ 无论怎么连都必定不会算入贡献中，因为你取 $\max$ 怎么都不会取 $2$ 吧。那么现在回到 $1$，要想使得前五个数连边达到最优，$1$ 只能连 $2$。

更严谨的证明应该是使用数学归纳法，当 $n=2$ 时，两数直接连边。现在假设 $n=k$ 用连前缀最小的方法能够达到最优，现在考虑 $k+1$ 怎么连。

分情况讨论：
1. 如果 $b_{k+1}$ 不是前缀最小值，那么连前缀最小值 $b_j,j<k$，新增贡献为 $b_{k+1}$，只会被计算一次。
2. 如果 $b_{k+1}$ 成为新的前缀最小值，往前连不会计入贡献，当后续新的前缀最小值要连它时，才会被计入并且也只会计算一次，后续不会再有结点连它，因为出现了更优的选择，自然就被抛弃了。

综上所述，除了最小值的那个 $b_i$ 不会被计算，其余只会被算一次，达到最优情况。

---

## 作者：irris (赞：3)

## Preface

贪心。

## Solution

如果只有数列 $a$，将其升序排序，我们知道能产生的代价最小值就是 $\sum\limits_{i=2}^n a_i$。

> **证明**：因为这是一棵树，所以代价排序后的第 $k$ 小的最小值是 $a_{k+1}$，如果更小，则无法构成一棵树，因为前 $k$ 条边仅联通了 $\leq k$ 个节点。

现在有了数列 $b$。我们不妨让 $a$ 数列依旧对答案贡献它能产生的代价最小值，而排序后不难发现，**这其实就是 $\bm i$ 向 $\bm{[1, i - 1]}$ 内任选一条边即可**。考虑 $b$ 数列。贪心地考虑这个问题，我们不需要管到底谁大，只要让选的这条边对应的 $b$ 是前缀最小即可，这样答案一定不劣。

那么怎么证明这个最优呢？我们有两种证法：

> **证明 1**：我们试图证明这样做，对于 $b$ 数列产生的也是代价最小值。
> + 显而易见地，如果某一次的 $b_i$ 不是前缀最小值，它只会被计算一次，此后也不会有向它连的边；
> + 否则它是前缀最小值，它在第一次连的时候不会被计算，但在之后被计算的时候，它同样会被新的前缀最小值替代。
> 
> 于是我们就证明了这是最优解。

---

> **证明 2**：还是放到前缀最小上去看，如果我们把 $1$ 看做树根的话，那么只有这些 $b$ 前缀最小的节点有叶子节点（除非它是 $a$ 最大，$b$ 最小），其它的节点都是连向了一个 $a, b$ 都比本身小的父亲，并只有一条连向父亲的边，也就是只会被计算一次。\
> 对于为了让这个节点和整棵树联通来说，这条边是不劣的，没有比它代价更小的边了。\
> 对于剩下的节点，形成了一个 $a$ 不降，$b$ 不增的序列，显然按照我们的顺次连边方式，可以做到代价最小（排序后都是最大的 $n - 1$ 个值，根据上文，这是最优的）。\
> 两个最优拼起来，当然还是最优。

其实证明 1 就是考场上我的思路，证明 2 就是官方题解。

---

## 作者：TJB_LHY (赞：2)

### 信息化题意

有 $n$ 个点，每个点 $i$ 有两个点权 $a_i$、$b_i$。任意两点 $i$、$j$ 有一条边权为 $\max(a_i,a_j)+\max(b_i,b_j)$。要求所有点的最小生成树。

# 思路

一道贪心题。我们先将所有点按 $a_i$ 升序排序（若相同，再按 $b_i$ 升序排序）。容易想到排序后 $a_1$ 是不可能做出贡献的（因为 $a_1$ 最小）。又因为总共只要 $n-1$ 条边，所以所有 $a_i$ 的贡献和为 $\sum_{i=2}^n a_i$。接下来我们考虑 $b_i$：因为我们在 $a_i$ 的基础上为 $b_i$ 排了序，所有我们可以~~贪心地~~认为当前点 $i$ 应该与前面 $b$ 最小的 $j$ 连边。事实上，我们的贪心是正确的：因为若点 $i$ 与后面的点 $j$ 连边，就会导致 $a_j$ 作出两倍的贡献，$a_i$ 贡献丢失，不符上述设定；若在前面选择 $b_i$ 更大的点 $j$，$a_i$ 的贡献不变（因为 $a_i$ 排过序），所以选择 $b_i$ 更小的可能更优；证毕。来到代码实现，我们用 $\min n$ 记录 $b_i$ 最小的点，枚举 $i$，将 $i$ 与 $\min n$ 连边，计算贡献，输出即可。

```cpp
#include <bits/stdc++.h>
#define int long long
#define U unsigned
using namespace std;
struct node{
    int a,b,i;
}mg[1000005],minn;
queue<node>q;
int n,num;
bool cmp(node x,node y){
    if(x.a!=y.a)return x.a<y.a;
    return x.b<y.b;//排序
}
signed main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>mg[i].a;
    for(int i=1;i<=n;i++){
        cin>>mg[i].b;
        mg[i].i=i;//记录点的编号
    }
    sort(mg+1,mg+n+1,cmp);
    minn=mg[1];
    for(int i=2;i<=n;i++){
        num+=mg[i].a+max(minn.b,mg[i].b);//记录贡献
        q.push({minn.i,mg[i].i,0});//记录连边
        if(mg[i].b<minn.b) minn=mg[i];//更新最小值
    }
    cout<<num<<'\n';
    while(q.size()){
        cout<<q.front().a<<' '<<q.front().b<<'\n';//输出
        q.pop();
    }
	return 0;
}
```

完结撒花。

---

## 作者：Accepetd (赞：2)

### 大致思路

需要求两个东西，一个是最小生成树的边权和，一个是最小生成树的边。

对于最小生成树的边权和，每次建边都取了 $\max$ 值，一共有 $n-1$ 条边。因此最小生成树的边权和为：

$$\sum_{i=1}^{n}(a_i+b_i)-\min a_i-\min b_i$$

即所有数的和减去最小的 $a$ 和最小的 $b$。

对于最小生成树的边，对 $a$ 从小到大排序，接着顺序遍历一遍，让每个 $a_i$ $(2 \leq i \leq n)$ 与当前最小的 $b$ 建边，这样得到的生成树边权和最小。

### Code

~~代码像 shi，请谨慎观看。~~
```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(register int i=a;i<=b;i=-~i)
#define ad(k) (k=-~k)
#define min(a,b) (a<b?a:b)
using namespace std;typedef long long ll;
const int N=5e6+2;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)//神秘的重定义 
char *p1,*p2,buf[N];
inline int read(){int x=0,f=1;char ch=getchar();for(ch;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;for(ch;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);return x*f;}
template<typename T>void write(T x){if(x<0)x=-x,putchar('-');if(x>9)write(x/10);putchar(x%10+48);}//快读快写

int n,j=1;ll sum,mina=LLONG_MAX,minb=LLONG_MAX;
struct num{int a,b,id;}k[N];
inline bool cmp(num x,num y){return x.a<y.a;}//自定义排序

signed main(){
	n=read();
	F(i,1,n){k[i].a=read(),k[i].id=i;sum+=k[i].a,mina=min(mina,k[i].a);}//读入a id记录编号 sum累加 mina求a的最小值
	F(i,1,n){k[i].b=read();sum+=k[i].b,minb=min(minb,k[i].b);}//读入b sum累加 minb求b的最小值
	write(sum-mina-minb),putchar('\n');//输出最小生成树的边权和 
	sort(k+1,k+n+1,cmp);//对a排序 从小到大 
    F(i,2,n){
		write(k[i].id),putchar(' ');//两个节点 表示一条边 
		write(k[j].id),putchar('\n');
        if(k[i].b<k[j].b)j=i;//b当前的最小值 
    }return 0;
}
```

---

## 作者：_Auror_ (赞：2)

## 思路

考虑贪心。

由 Kruskal 算法可知，每次都选出一条最短的边就能构成最小生成树。所以问题转换为 $\max(a_i,a_j) + \max(b_i,b_j)$ 的前 $n - 1$ 小的和。

首先按 $a$ 数组顺序排序，由 $\max(a_i,a_j)$ 可以得到最小的 $a$ 将一定不会被取到，所以从 $2$ 开始枚举，并记录 $b$ 数组的前缀最小值。

为什么要这样做？我们可以知道，枚举到第 $i$ 个位置时，前 $i - 1$ 个位置联通，因为 $a$ 已经递增，所以根据贪心，向前 $i - 1$ 个点中 $b$ 值最小的点连边。因为如果与其他节点连边，$\max(b_i,b_j)$ 可能更大，而取 $b$ 的前缀最小值可以避免这种情况的发生。若当前的 $b$ 值小于前缀最小值，$\max(b_i,b_j)$ 仍然最优。

最后记录每次连边的原始编号输出就做完啦！

## 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &ff){
    T rr=1; ff=0; char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')rr=-1;ch=getchar();}
    while(isdigit(ch)){ff=(ff<<1)+(ff<<3)+(ch^48);ch=getchar();}
    ff*=rr;
}
template<typename T,typename ...T1>
inline void read(T& x,T1 &...x1){
	read(x);
	read(x1...);
}
template<typename T> inline void write(T x) {
    if (x<0) putchar('-'),x=-x;
    if (x>9) write(x/10);
    putchar(x%10+'0');
}
template<typename T> inline void writed(T x) {
    write(x);
    puts("");
}
#define int long long
#define inl inline
#define ri register int
#define rep(i,a,b) for(ri i=a;i<=b;i++)
#define per(i,a,b) for(ri i=a;i>=b;i--)
#define N 1000005
int n;
struct ss{
    int a, b, id;
    bool operator <(ss &x){
        return a < x.a;
    }
}y[N];
struct zz{
    int u, v;
}g[N];
int tot;
signed main(){
    read(n);
    rep(i, 1, n) read(y[i].a), y[i].id = i;
    rep(i, 1, n) read(y[i].b);
    sort(y + 1, y + 1 + n);
    int ans = 0;
    int mn = y[1].b, mi = y[1].id;
    rep(i, 2, n){
        ans += y[i].a + max(mn, y[i].b);
        g[++ tot].u = y[i].id;
        g[tot].v = mi;
        if(mn > y[i].b){
            mn = y[i].b;
            mi = y[i].id;
        }
    }
    writed(ans);
    rep(i, 1, tot) cout << g[i].u << " " << g[i].v << endl;
	return 0;
}
```

---

## 作者：wuzr (赞：2)

贪心地考虑，将每个点 $i$ 向点 $j$ 满足 $a_j\le a_i,b_j\le b_i$ 连边，连完边之后将点 $i$ 删掉，因为点 $j$ 一定比点 $i$ 更优。

我们可以钦定每个点 $i$ 连向以 $a_j$ 为第一关键字，$b_j$ 为第二关键字排序后的第一个满足条件的点。

我们发现贪心连边之后剩下点的序列，是一个排序后 $a$ 单调递增，$b$ 单调递减的序列，将排序后相邻的两点连边一定最优。

```cpp
#include <bits/stdc++.h>
#define rep(i, l, r) for(int i=l, _=r; i<=_; ++i)
using namespace std;
const int N = 1e6 + 5;
struct Point {
	int a, b, id;
} p[N];
int n, m = 1, u[N][2], tot;
long long ans;
int main() {
	scanf("%d", &n);
	rep(i, 1, n) scanf("%d", &p[i].a);
	rep(i, 1, n) scanf("%d", &p[i].b), p[i].id = i;
	sort(p + 1, p + n + 1, [](Point x, Point y) {return x.a != y.a ? x.a < y.a : x.b < y.b;});
	rep(i, 2, n)
	if (p[i].b >= p[m].b) u[++tot][0] = p[m].id, u[tot][1] = p[i].id, ans += p[i].b + p[i].a;
	else p[++m] = p[i];
	rep(i, 2, m) u[++tot][0] = p[i - 1].id, u[tot][1] = p[i].id, ans += max(p[i - 1].a, p[i].a) + max(p[i - 1].b, p[i].b);
	printf("%lld\n", ans);
	rep(i, 1, tot) printf("%d %d\n", u[i][0], u[i][1]);
	return 0;
}
```


---

## 作者：违规用户名1310428 (赞：1)

这题我们一步步来想：  
直接暴力建图+最小生成树，就可以得到：
### 20pts 做法：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long fa[1000006],a[1000006],b[1000006];
struct node{
    long long q,s,z;
};
bool cmp(node x,node y){
    return x.z<y.z;
};
long long get(long long x){
    if (fa[x] != x) {
        fa[x]=get(fa[x]);
    }
    return fa[x];
}
void hb(long long x,long long y){
    x=get(x);
    y=get(y);
    fa[y]=x;
    return;
}
void mintree(){
    long long n,h,c;
    h=c=0;
    vector<node> g,d;
    cin>>n;
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    //读入
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            g.push_back(node{i,j,max(a[i],a[j])+max(b[i],b[j])});//建图
        }
    }
    sort(g.begin(),g.end(),cmp);
    for(int i=0;i<g.size();i++){
        if(get(g[i].q)!=get(g[i].s)){
            c++;
            h+=g[i].z;
            hb(g[i].q,g[i].s);
            d.push_back((node){g[i].q,g[i].s,0});//存入路径
            if(c==n-1)break;
        }
    }
    //最小生成树模版
    cout<<h<<endl;
    for(int i=0;i<n-1;i++)cout<<d[i].q<<" "<<d[i].s<<endl;
    //输出
}

int main(){
    mintree();
    return 0;
}
```
现在来考虑优化．．．．．．吗？  
我们可以发现，无论怎么样，只要我们选出了 $n-1$ 条路径，且它们不会构成环，无论怎么样都可以构成一个最小生成树。那么问题就变成了：  
**选出最小的 $n-1$ 条不会构成环的路径。**  
所以我们直接删掉最小生成树，让每个节点会且仅会有一条路径通向 $id$ 小于自己的点（1 除外），这样就得到了 $n-1$ 条不会构成环的路径。那么如何保证最小呢？  
**直接开贪！**  
因为有 $a_i,b_i$ 两个值，所以我们可以先按 $a_i$ 排序，由于每个节点有一条路径通向 $id$ 小于自己的点，所以这条路径的 $\max(a_i,a_j)$ 一定是 $a_i$，无法改变，所以我们只用前面贪 $b_j$ 最小的就行了。可以写一个前缀最小值来处理。于是你就得到了：
### 40pts 做法：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct note{
    long long a,b,id;
}s[1000006];
bool cmp(note x,note y){
    return x.a<y.a;
};
void mintree(){
    long long n,h,q[1000006],d[1000006][2];
    h=0,q[1]=1;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>s[i].a;
    for(int i=1;i<=n;i++){cin>>s[i].b;s[i].id=i;}
    //读入（记得把原来的i储存好）
    sort(s+1,s+n+1,cmp);//排序
    for(int i=2;i<=n;i++){
        if(s[q[i-1]].b>s[i].b)q[i]=i;
        else q[i]=q[i-1];
    }
    //求前缀最小值
    for(int i=n;i>1;i--)h+=s[i].a+max(s[q[i-1]].b,s[i].b),d[i][0]=s[i].id,d[i][1]=s[q[i-1]].id;//计算+储存
    cout<<h<<endl;
    for(int i=2;i<=n;i++)cout<<d[i][0]<<" "<<d[i][1]<<endl;
    //输出
}
int main(){
    mintree();
    return 0;
}
```
（注：以下思路来自用户 [Accepetd](https://www.luogu.com.cn/user/1072849)，且已经过其本人允许）  
但还是超时了~~其实优化下输入输出就过了~~，我们回顾代码可以发现，除了排序后的节点 1，也就是最小的 $a_i$，所有的 $a_i$ 都算过了一遍，而对于所有的$b_i$，如果它不是 $1 \sim i$ 里最小的，它会在 $i$ 连线的时候被算一次，如果它是，他会在后面的第一个小于自己的 $i$ 连线的时候被算一次，也就是除了最小的 $b_i$，所有的 $b_i$ 也都算过了一遍，所以我们可以直接输出：  
$\sum_{i=1}^{n}a+\sum_{i=1}^{n}b-\min a-\min b$    
然后再求前缀最小值的时候输出路径就可以了。
### 100pts 做法核心代码（来自 Accepetd）：

```cpp
    cin>>n;
	F(i,1,n){cin>>k[i].a,k[i].id=i;sum+=k[i].a,mina=min(mina,k[i].a);}
	F(i,1,n){cin>>k[i].b;sum+=k[i].b,minb=min(minb,k[i].b);}
	cout<<sum-mina-minb<<'\n';
	sort(k+1,k+n+1,cmp);
    F(i,2,n){
    	cout<<k[i].id<<' '<<k[j].id<<'\n';
        if(k[i].b<k[j].b)j=i;
    }
	return 0;
```

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8957)

校内模拟赛 T1，场切成功。

## 思路：

最小生成树大家应该都会了吧，但是这题 $n\le10^6$，暴力 $O(n^2)$ 连边必然会 TLE，如果你那么做了可以得到 Subtask1 的 $20$ pts，这里不再赘述。

考虑贪心，先按 $a_i$ 从小到大排序，显然对于排完序后的点 $j$ 和点 $j-1$ 之间的边就会有 $a_j$ 贡献 $(2\le j\le n)$ 因为 $a_j > a_{j-1}$ 嘛。

那么 $a_i$ 的贡献即为 $\sum^{n}_{i=2} a_i$，接下来考虑 $b_i$ 的贡献，对于一个新加入的 $b_k$，会造成 $\max(\min^{k-1}_{t=1} b_t,b_k)$ 直接正常维护即可。

最后注意本题输入输出量非常大，可以使用快读快写加快效率防止被卡常。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
long long x;
struct node{
	long long a,b;
	long long bh;
}m[1000005];
bool cmp(node q,node p){
	return q.a<p.a;
}
inline long long read()
{
	long long x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void out(long long x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else out(x/10),putchar(x%10+'0');
}
long long da1[1000005],da2[1000005];
int main(){
	x=read();
	for(long long i=1;i<=x;i++){
		m[i].a=read();
		m[i].bh=i;
	}
	for(long long i=1;i<=x;i++) m[i].b=read();
	sort(m+1,m+1+x,cmp);
	long long ans=0;
	long long mina=m[1].b,wz=m[1].bh;
	for(long long i=2;i<=x;i++){
		ans+=m[i].a;
		ans+=max(mina,m[i].b);
		da1[i-1]=m[i].bh;
		da2[i-1]=wz;
		if(m[i].b<mina){
			mina=m[i].b;
			wz=m[i].bh;
		}
	}
	cout<<ans<<endl;
	for(long long i=1;i<x;i++){
		out(da1[i]);
		cout<<" ";
		out(da2[i]);
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：Tjaweiof (赞：1)

# P8967 题解
[题目传送门](https://www.luogu.com.cn/problem/P8957)

首先容易发现边权和 $\ge\sum(a_i+b_i)-\min a_i-\min b_i$。即，$a$ 从小到大排序后第 $2$ 个到第 $n$ 个的和加 $b$ 从小到大排序后第 $2$ 个到第 $n$ 个的和。

按照 $a$ 的值从小到大排序，然后考虑每一个 $i\ge2$，$i$ 与使 $b_j$ 的值最小的 $j(j<i)$ 连边。这样产生的树边权和达到 $\sum(a_i+b_i)-\min a_i-\min b_i$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define FILE(x) freopen(x".in", "r", stdin);freopen(x".out", "w", stdout);
int n, mink = 1;
long long min1 = 1e9, min2 = 1e9, ans;
pair <pair <long long, long long>, int> a[1000001];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> a[i].first.first;
		ans += a[i].first.first;
		min1 = min(min1, a[i].first.first);
		a[i].second = i;
	}
	ans -= min1;
	for (int i = 1; i <= n; i++){
		cin >> a[i].first.second;
		ans += a[i].first.second;
		min2 = min(min2, a[i].first.second);
	}
	ans -= min2;
	cout << ans << "\n";
	sort(a + 1, a + n + 1);
	for (int i = 2; i <= n; i++){
		cout << a[mink].second << " " << a[i].second << "\n";
		if (a[i].first.second < a[mink].first.second){
			mink = i;
		}
	}
	return 0;
}

```

---

## 作者：Lacuna (赞：0)

### 题意：

给 $n$ 个点，要连 $n-1$ 条边，使得产生的贡献最小。

### 思路：

考虑贪心。

先考虑 $a$，显然最小的一定取不到，所以考虑按 $a$ 的大小排序，然后按从小到大的顺序连边，显然最小的贡献是：
$$
\sum_{i=2}^{n} a_i
$$

然后在考虑 $b$。由于点连边的顺序已经确定，我们只要考虑向谁连边。此时有两种情况：

- 当前点的 $b$ 比连了边的点的 $b$ 都小，想要产生的贡献最小我们只能连次小的那个点。
  
- 否则，我们只能比当前点的 $b$ 值最小的点连边，因为向更大的点连边一定不优。

这个过程可以用堆实现。

### 最后考虑证明：

显然 $a$ 的贡献是最优的，我们只要看看 $b$。

对于除第一个点外的每个点，我们只会有两种情况。

- 加上已连边的点的最小的 $b$。
  
- 加上该点的 $b$。

显然，除最小的点之外，每个点都会被加一次。具体点说就是第一种情况的点必定会被更小的点替代，并加入贡献，只有最小的点永远无法被替代。设最小的 $b$ 是 $minb$，则产生的贡献就是：
$$
\sum_{i=1}^{n} b_i - minb
$$

为何这样是最优的，因为每个小点都不能去限制比他大的点，换句话说我们连边就只能连比它小的边。这样产生的贡献就是这个点自身的。否则产生的贡献必定更大。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define gc getchar
#define pc putchar
#define pb push_back
#define ls u<<1
#define rs u<<1|1
#define mp(i,j) make_pair(i,j)
const int ri=1e6+5;
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
struct _{
	int a,b,id;
	bool operator>(const _ &t)const{
		return b>t.b;
	}
}e[ri];
bool cmp(_ x,_ y){
	return x.a<y.a;
}
int sum,n;
priority_queue<_,vector<_>,greater<_>> q; 
vector<pair<int,int> > ans;
signed main(){
    read(n);
    for(int i=1;i<=n;i++){
    	read(e[i].a);
	}
	for(int i=1;i<=n;i++){
		read(e[i].b);
		e[i].id=i;
	}
	sort(e+1,e+n+1,cmp);
	for(int i=1;i<=n;i++){
		if(!q.size()){
			q.push(e[i]);
			continue;
		}
		_ tp=q.top();
		sum+=e[i].a+max(e[i].b,tp.b);
		ans.pb(mp(tp.id,e[i].id));
		q.push(e[i]);
	}
	printf("%lld\n",sum);
	for(auto [x,y]:ans){
		printf("%lld %lld\n",x,y);
	}
	return 0;
}
```

---

## 作者：__Ginka__ (赞：0)

神秘树树题。

### 计算最小生成树的边权和：

最小生成树的边权和为所有 $a$ 和 $b$ 的总和减去 $a$ 和 $b$ 的最小值之和。

即 $ans = \sum_{i=1}^n a_i + \sum_{i=1}^n b_i - \min(a_i) - \min(b_i)$。

### 排序：

将所有弹力矩按照 $a$ 属性从小到大排序。

### 输出最小生成树的边：

初始化 $id$ 为 1，表示当前最小 $b$ 值的弹力矩。

遍历排序后的弹力矩，从第二个开始，输出当前 $id$ 和当前弹力矩的 $id$。

如果当前弹力矩的 $b$ 值小于 $id$ 对应的 $b$ 值，则更新 $id$ 为当前弹力矩的 $id$。

代码（相信足够简洁明了，思路已单独列出，恕不打注释）：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct nd{int a,b,id;}d[1000005];int n;long long ans,ma,mb;
bool cmp(nd x,nd y)
{
    return x.a<y.a;
}
int main()
{
    cin>>n;
    ma=1e9;
    mb=1e9;
    for(int i=1;i<=n;++i)
    {
        cin>>d[i].a;
        ans+=d[i].a;
        if(d[i].a<ma)
        {
            ma=d[i].a;
        }
        d[i].id=i;
    }
    for(int i=1;i<=n;++i)
    {
        cin>>d[i].b;
        ans+=d[i].b;
        if(d[i].b<mb)
        {
            mb=d[i].b;
        }
    }
    ans-=ma+mb;
    sort(d+1,d+n+1,cmp);
    cout<<ans<<"\n";
    int id=1;
    for(int i=2;i<=n;++i)
    {
        cout<<d[id].id<<" "<<d[i].id<<"\n";
        if(d[id].b>d[i].b)
        {
            id=i;
        }
    }
    return 0;
}
```

---

## 作者：dci66666 (赞：0)

有趣的思维（构造）题。

对于弹力菇 $i$ 会向弹力菇 $j$ 连一条边权为 $\max(a_i,a_j)+\max(b_i,b_j)$ 的双向弹力通道。

这个题目有 $a_i$ 和 $b_i$ 两个变量，有点难办。不妨先考虑只有一个变量 $a_i$。

如果只有一个变量，由于边数恒定为 $n-1$ 条，所以可以让权值最小的点连上所有点，这样最优。

可以用反证法证明：假设有更有的边由 $i$ 指向 $j$，且其中没有权值最小的点（点 $i$ 已经加入最小生成树内，而 $j$ 没有，设 $k$ 为最小权值点），那么有 $\max(a_i,a_j) \ge\max(a_k,a_j)$，当且仅当 $a_i\le a_j$ 时取等，故假设不成立。

所以根据以上贪心思想，想想怎么扩展至二元。

显然，我们的策略可以使除了最小权值点以外的所有点权全部贡献一次，可以证明不存在更有解（因为无论最小权值点给谁连边都不会有自己的贡献）。只要我们将两元各自尽力保持这个性质就可以算是最优。

对于第一维 $a_i$ 我们可以排序处理，可以保证在非最小点连边时自己无论连上任意点时一定会贡献一次，这样一定可以保持最优的性质。对于第二维，我们考虑贪心地将所有点插到当前 $b_i$ 最小的点。我们可以惊奇地发现，由于这样做肯定不会使 $a_i$ 的答案劣，但是 $b_i$ 一定是优的。

考虑以下情况：当前已连的点假设是最优的，也就是说除了里面最小的权值点外其他所有点都产生了贡献。我们当前操作的点如果比所有已连的点都小时连上最小值可以维护最优的性质，使之前的最优点产生贡献。否则大于等于当前最小权值时连上最小点自己贡献一次也能维护最优性质。总之，最后的序列也一定满足最优的性质。

所以我们最后可以保证 $a_i$ 和 $b_i$ 都有最优的性质，答案一定最优，随便维护一下就行了。

下面是代码，没有看懂的可以看代码再理解一下：
```cpp
#include<bits/stdc++.h>
using namespace std;//很短的代码（
const int N=1e6+50;
struct node{
	int a,b,id;
	friend bool operator<(const node &x,const node &y){
		if(x.a!=y.a)return x.a<y.a;
		return x.id<y.id;
	}
}t[N];
int n;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return x*f;
}
struct Edge{
	int u,v;
}edge[N];
int minb,minid,tot;
#define ll long long
ll ans=0;
int main(){
	n=read(); 
	for(int i=1;i<=n;i++)t[i].a=read(),t[i].id=i;
    for(int i=1;i<=n;i++)t[i].b=read();
    sort(t+1,t+1+n);
    minb=t[1].b,minid=t[1].id;
    for(int i=2;i<=n;i++){
    	edge[++tot]={t[i].id,minid};
    	ans+=t[i].a+max(minb,t[i].b);
		if(t[i].b<minb){
    		minid=t[i].id;minb=t[i].b;
		}
	}
	printf("%lld\n",ans);
	for(int i=1;i<=tot;i++){
		printf("%d %d\n",edge[i].u,edge[i].v);
	}
    return 0;
}
```

---

## 作者：JackMerryYoung (赞：0)

# 前言

诈骗 T2。

~~但是由于被 T1 卡了 2.5h 所以没写完（）~~

# 正文

考虑先按 $a, b$ 顺序作关键字排升序，把 $a_i < a_j$ 且 $b_i < b_j$ 的 $j$ 连向 $i$。这样子一定不劣。

然后剩下的 $K$ 个蘑菇一定 $a$ 上升 $b$ 下降，所以直接相邻两个连起来即可。

复杂度 $\mathcal{O}(N \log_2 N)$，瓶颈在于排序和读入。

# 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define rll register ll

ll N;

struct Rushmoon { // Mushroom
    ll a, b, num;
} arr[2000005];

bool operator < (Rushmoon lhs, Rushmoon rhs) 
{
    return lhs.a != rhs.a ? lhs.a < rhs.a : lhs.b < rhs.b;
}

ll ans = 0;

vector< pair<ll, ll> > edge;

signed main()
{
    scanf("%lld", &N);
    for(ll i = 1; i <= N; ++ i) 
        scanf("%lld", &arr[i].a), arr[i].num = i;
    
    for(ll i = 1; i <= N; ++ i) 
        scanf("%lld", &arr[i].b), arr[i].num = i;

    sort(arr + 1, arr + N + 1);
    int cnt = 1;
    for(int i = 2; i <= N; ++ i)
    {
        if(arr[i].b >= arr[cnt].b)
        {
            edge.push_back(make_pair(arr[i].num, arr[cnt].num));
            ans += (arr[i].a + arr[i].b);
        }
        else
        {
            arr[++ cnt] = arr[i];
        }
    }
    
    for(int i = 1; i < cnt; ++ i)
    {
        edge.push_back(make_pair(arr[i].num, arr[i + 1].num));
        ans += (max(arr[i].a, arr[i + 1].a) + max(arr[i].b, arr[i + 1].b));
    }

    printf("%lld\n", ans);
    for(auto i : edge)
        printf("%lld %lld\n", i.first, i.second);

    return 0;
}
```

# 后言

感谢【丑国】题森出题组提供的优质题目！

---

## 作者：Saka_Noa (赞：0)

不妨考虑弱化版只有 $a$ 这一维的问题。

考虑 `Prim` 的过程，我们维护一个点集 $S$，每次向外连一条代价最小的边。很自然的想到将 $a$ 排序，从小到大选择点对，这样答案是 $\sum _{i=2}^n a_i$。

加上 $b$ 这一维，我们仍然按 $a$ 排序，这样就可以不考虑 $a$ 这一维对答案的贡献。维护点集 $S$，这时的最小出边是满足 $b_j = \min_{i \in S} b_i $ 的 $j$ 向枚举到的点的连边。

这样每个最大值只会贡献一次，贡献是 $\sum_{i=2}^n b_i$。


关键代码

```cpp

	fin >> n;
    ll ans = 0, ma = 1e9, mb = 1e9;
    for(int i=1;i<=n;++i) fin >> d[i].a, ans += d[i].a, ma = min(ma, (ll)d[i].a), d[i].id = i;
    for(int i=1;i<=n;++i) fin >> d[i].b, ans += d[i].b, mb = min(mb, (ll)d[i].b);
    ans -= ma + mb;
    sort(d + 1, d + n + 1, [](node a, node b) {return a.a < b.a; });
    fout << ans << "\n";
    int id = 1;
    for(int i=2;i<=n;++i) {
      fout << d[id].id << " " << d[i].id << endl; 
      if(d[id].b > d[i].b) id = i;
    }
    
```

---

## 作者：sbno333 (赞：0)

这道题其实不需要什么高深的算法，但是你需要知道意思(会的可以跳过)：

* 树：若一个图有 $n$ 个点，有 $n-1$ 条边，且连通（无向图），则我们称这是一个树。
* 生成树：去掉一个图的一些边（点不变），而且最后形成了一个树，则我们称这是这个图的一个生成树。
* 最小生成树：边的权值之和最小的生成树。

虽然有求最小生成树的算法，但我们不需要。

不难发现，除了某一个节点以外每个点都至少延伸 $1$ 条边。

由于它说 $\max(a_i,a_j)+\max(b_i,b_i)$ 最小，因此点 $i$ 延伸的边至少为 $a_i+b_i$。

我们可以让每个点都延伸一条边，对于 $a_i$，我们可以排序，延伸至 $a_j<a_i$ 时的 $j$，对于 $b_i$，我们可以延伸到之前最小的 $b_j$，可以通过打擂台来求最小值，当然，是筛到几，就打到几，时间复杂度 $O(n)$。
# $CODE$
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tt{
	long long a,b,t;//排序用
}s[1000009];
long long mi;
long long mii;
long long ans;
long long bb[1000009][2];
bool cmp(tt a1,tt a2){
	return a1.a<a2.a;
}
int main(){
	long long n;
	scanf("%lld",&n);//输入
	for(long long i=1;i<=n;i++){
		scanf("%lld",&s[i].a);
	}
	for(long long i=1;i<=n;i++){
		scanf("%lld",&s[i].b);
		s[i].t=i;
	}
	sort(s+1,s+1+n,cmp);//按 a 排序
	mi=s[1].b;
	mii=1;
	for(long long i=2;i<=n;i++){
		ans+=s[i].a;//延伸至a小的边
		ans+=max(s[mii].b,s[i].b);//延伸至之前b的最小值
		bb[i-1][0]=s[mii].t;//记录边
		bb[i-1][1]=s[i].t;
		if(s[i].b<mi){//记录b的最小值
			mi=s[i].b;
			mii=i;
		}
	}
	
	printf("%lld\n",ans);
	for(long long i=1;i<n;i++){//输出
		printf("%lld %lld\n",bb[i][0],bb[i][1]);
	}
	return 0;
} 
```

---


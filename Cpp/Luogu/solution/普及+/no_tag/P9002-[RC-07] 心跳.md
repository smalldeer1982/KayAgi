# [RC-07] 心跳

## 题目描述

对正整数 $x$，设 $f(x,B)$ 表示 $x$ 在 $B$ 进制下的数位和。说一个正整数 $p$ 是 $B$-好的，当且仅当对于任意正整数 $q<p$ 都有 $f(p,B)\ge f(q,B)$。

给定正整数 $n$ 和 $B$，计算有多少个 $\le n$ 的正整数是 $B$-好的。

## 说明/提示

**样例解释**

这里只解释第二组询问的输出。三进制下，$1,2,3,4,5,6,7,8,9$ 的数位和分别为 $1,2,1,2,3,2,3,4,1$，据此容易看出只有 $1,2,4,5,7,8$ 是 $3$-好的，所以输出 $6$。

**数据范围**

所有数据均满足：$1\le T\le 10^5$，$1\le n\le 10^{18}$，$2\le B\le 10^{18}$。

- 子任务 $1$（$50$ 分）：$T\le 10^4$，$n,B\le 100$。
- 子任务 $2$（$30$ 分）：$B=2$。
- 子任务 $3$（$20$ 分）：无特殊限制。

## 样例 #1

### 输入

```
6
4 2
9 3
1000 2
1000 20
28238934 154154154154154
23389348458425 5```

### 输出

```
3
6
49
60
28238934
760```

# 题解

## 作者：Demeanor_Roy (赞：13)

- 个人感觉略显套路。

------------

考虑怎样一个数才能称作 $B$-好的，这里给出结论：

- 当且仅当数 $x$ 在 $B$ 进制下，去除最高位最多有一位为 $B-2$，其余均为 $B-1$ 时，我们称数 $x$ 是 $B$-好的。

证明的话考虑对每个数 $x$，构造一个小于 $x$ 且 $B$ 进制下数位和最大的数，不难发现将最高位减一，其余位全取 $B-1$ 即可得到，所以如果 $x$ 是 $B$-好的，其在 $B$ 进制下数位和必须大于等于这个数的数位和。于是简单讨论可得以上结论。

对于数 $x$，令其 $B$ 进制下位数为 $len$，最高位为 $m$，接下来分两种情况计算答案：

1. 最高位未满，显然可以直接列出式子：$ans = \frac{len(len-1)(B-1)}{2} + (m-1)len$。其中前者是位数小于 $len$ 的答案求和，后者是最高位为 $[1,m-1]$ 的答案求和。不懂的可以看 [这儿](https://www.luogu.com.cn/paste/qicq803k)。

2. 最高位已满，这样的答案只有 $\log$ 个，暴力比较是否合法即可。

时间复杂度 $O(T \log n)$。下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long 
const int N=65;
int T;
LL n,B,now,ans,num[N];
inline void solve()
{
	scanf("%lld%lld",&n,&B);
	now=0;
	while(n) num[++now]=n%B,n/=B;
	ans=(B-1)*now*(now-1)/2+(num[now]-1)*now;
	for(int i=now-1;i>=1;i--)
	{
		if(num[i]==B-1) ans+=(i==1)+1;
		else if(num[i]==B-2)
		{
			bool flag=true;
			for(int j=i-1;j>=1;j--)	if(num[j]!=B-1) {flag=false;break;}
			if(flag) ans++;break;
		}
		else break;
	}
	printf("%lld\n",ans+(now==1));
}
int main()
{
	scanf("%d",&T);
	while(T--)	solve();
	return 0;
}
```


---

## 作者：_lqs_ (赞：4)

本题解应该与其他题解略有不同，可能较长，我会讲对于结论题没有思路时如何打表寻找规律。最后才会有结论的证明。也谨以此题解记录我 OI 生涯第一次赛时切绿。

# solution

以下的变量除特殊说明外都是题目中的变量名称。注意到如此庞大的数据范围，我又没有各路神仙那么强大到可以直接发现性质并证明，所以直接~~打表出奇迹~~！

如何打表呢？对于这种题来说当然是观察所有 $B-$ **好的**数之间的关系啦。

- 当 $B=2$ 时。我们令 $n=30,B=2$，然后掏出我们的暴力代码，将所有合法的答案输出，是这个东西：```1 2 3 5 6 7 11 13 14 15 23 27 29 30 31```。然后我们对这串答案相邻的数取差，可得 ```1 1 1 2 1 1 4 2 1 1 8 4 2 1 1```，好像有点规律？我们继续观察其他情况。

- 当 $B=3$ 时。我们令 $n=90,B=3$，所有合法答案求差后可得 ```1 1 2 1 2 1 6 2 1 6 2 1 18 6 2 1 18 6 2 1```。

- 当 $B=4$ 时。我们令 $n=70,B=4$，所有合法答案求差后可得 ```1 1 1 3 1 3 1 3 1 12 3 1 12 3 1 12 3 1```。

以上三种情况求差的第一个数是 $0$ 和第一个合法数的差值，现在我们[把以上三种进制整理一下](https://www.luogu.com.cn/paste/2s76gyvj)，规律其实很明显了：对于给出的 $B$ 进制数，设数据大小位于 $B^k$ 和 $B^{k+1}-1$ 之间，其 $B-$ **好的**数之间差值为 $(m-1) \times B^{k-1}$、$(m-1) \times B^{k-1} \div m^1$、$(m-1) \times B^{k-1} \div m^2$ $\cdot \cdot \cdot \cdot \cdot \cdot$ $1$。这里最后的 $1$ 和前面的没什么关系，特判计算即可。

当然了，作为~~职业打表人~~，只找到这点规律哪够呢？我们还可以统计某一段区间内合法的答案数！上面的整理链接中还整理了特定区间内答案数，其实可以发现就是等差数列，所以我们提前计算 $B^k \le n$ 中最大的 $k$ 值，直接等差数列求出这一段的答案数，剩下如果还有多余的就用上面找到的差值间的规律求就行了。

实现这些需要快速幂等等操作，基本都是 $\log$ 的复杂度。

最后讲一下结论及其证明，以下内容均为赛后向 [@lzqy_](https://www.luogu.com.cn/user/288716)  和 [@Demeanor_Roy](https://www.luogu.com.cn/user/297806) 两位大佬请教而得知。

先给出结论：当一个数 $m$ 转为 $B$ 进制后，当且仅当去除最高位后，每一位的大小都为 $B-1$ 或仅有一位为 $B-2$ 时 $m$ 为合法数。

证明：我们让 $m$ 最高位减 $1$，其他位为 $B-1$。容易证明，这个数是小于 $m$ 的数中 $B$ 进制下数位和最大的。所以可见只要这个数的数位和大于等于转换后的数位和即为合法数。至于为什么至多可以有一位为 $B-2$ 呢？显然 $B-2$ 与 $B-1$ 是相邻两个数，都是合法的。

实现的话可以枚举可能的位数，设当前有 $s$ 位，除去最高位外还有 $s-1$ 位，$B-2$ 可能存在于任意位上，加上全是 $B-1$ 这种情况。而最高位有 $B-1$ 个情况，所以位数为 $s$ 的答案即为 $s \times (B-1)$。设共有 $w$ 种可能的位数，那么答案即为：
$$\sum\limits_{s=1}^ws \times (B-1)$$

最后把 $n$ 转换 $B$ 进制后最高位特殊处理一下就好了，不懂的话可以去看其他题解，讲得已经很清楚了，代码中有简单注解。

# code

[找规律](https://www.luogu.com.cn/paste/frjifuqi)

[运用性质](https://www.luogu.com.cn/paste/m6n4xpqz)

每次询问都是 $\log$ 的，所以总复杂度为 $\mathcal {O}(T \log n)$。

大概就讲完了，当没有头绪时打表找一下答案间的关系也是不错的方法哟。


---

## 作者：BotDand (赞：2)

# $\text{Problems}$

对正整数 $x$，设 $f(x,B)$ 表示 $x$ 在 $B$ 进制下的数位和。说一个正整数 $p$ 是 $B$-好的，当且仅当对于任意正整数 $q<p$ 都有 $f(p,B)\ge f(q,B)$。

给定正整数 $n$ 和 $B$，计算有多少个 $\le n$ 的正整数是 $B$-好的。

# $\text{Answer}$

考虑特殊情况的处理。

取 $B=10$，其他值也可以。

不难发现满足条件的数有 `1,2,3,...,7,8,9`，`18,19;28,29;...;88,89,98,99`，`189,198,199;289,298,299...`。

按位数分组，一位数有 $9\times 1=9$ 种，两位数有 $9\times 2=18$ 种，三位数有 $9\times 3=27$ 种，扩展到任意 $B$ 可以发现 $k$ 位数（**必须取满**）的方案数为 $(B-1)\times k$。

回到题目，既然我们知道了方案数与位数的关系，那么我们可以先将 $n$ 转换为 $B$ 进制的形式，记位数为 $w$，那么 $1$ 到 $w-1$ 的方案数就可以求了，因为这些数一定可以取满，即 $ans=\sum_{i=1}^{w-1}(B-1)\times i$。

再考虑 $w$ 位数时的方案数怎么求。

令 $n$ 转成 $B$ 进制时最高位为 $x$，不难发现当最高位为 $1$ 到 $x-1$ 时也是可以取满的，这时的方案数为 $(x-1)\times w$。

那么现在只用求当位数为 $w$ 且最高位为 $x$ 时的方案数。

再看看刚才列举出的数，可以发现 $2$ 到 $w$ 位不是 $B-2$ 就是 $B-1$，且 $B-2$ 的数量**小于等于** $1$。

考虑到这个性质，我们可以枚举 $B-2$ 所在的位置，判断在当前位置是否合法即可。

注意要特判全是 $B-1$ 的情况。

时间复杂度 $O(\log n)$。

# $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int n,B;
int a[102],b[102];
// a 数组表示 n 转为 B 进制数后各位上的数
// b 数组表示枚举 B-2 的位置时各位上的数
int w;
bool cmp()// 比较 a，b 数组，判断是否合法
{
	for(int i=w;i>=1;--i)
	{
		if(a[i]==b[i]) continue;
		if(a[i]>b[i]) return 1;
		return 0;
	}
	return 1;
}
void work()
{
	cin>>n>>B;
	if(n<=B-1)  // 加不加特判都没关系
	{
		cout<<n<<"\n";
		return;
	}
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	int N=n;
	w=0;
	while(N)
	{
		a[++w]=N%B;
		N/=B;
	}
	int ans=0;
	for(int i=1;i<=w-1;++i) ans+=(B-1)*i;// 1 到 w-1 位的方案数
	ans+=(a[w]-1)*w;// w 位数且最高位小于等于 x 时的方案数
	b[w]=a[w];
	for(int i=1;i<w;++i) b[i]=B-1;
	if(cmp()) ans++;// 特判全是 B-1 的情况
	for(int i=1;i<w;++i)// 枚举 B-2 的位置
	{
		b[i]=B-2;
		if(cmp()) ans++;
		b[i]=B-1;
	}
	cout<<ans<<"\n";
}
signed main()
{
	cin>>t;
	while(t--) work();
}
```

---


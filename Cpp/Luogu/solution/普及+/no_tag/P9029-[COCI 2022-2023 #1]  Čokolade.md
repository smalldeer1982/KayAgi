# [COCI 2022/2023 #1]  Čokolade

## 题目背景

Lana 和 Fran 正在参观一家巧克力工厂，现在他们想买些巧克力。

## 题目描述

巧克力工厂里有 $n$ 块不同的巧克力，其中第 $i$ 块的价格为 $c_i$。Lana 和 Fran 想买 $m$ 块巧克力。

Fran 有一个消费方案：

•如果巧克力价格低于 $k$ 元，这块巧克力的费用将全部由 Lana 支付。

•否则，Lana 将支付 $k$ 元，而 Fran 将支付其余的部分，即 $c_i−k$ 元。

Lana 对 Fran 的方案不满意，想要报复 Fran。设 $l$ 为 Lana 需要支付的金额，$f$ 为 Fran 需要支付的金额。Lana 将选择使 $l−f$ 的值最小的购买方案。

由于 Fran 还在犹豫，不知道要买多少巧克力，所以 Lana 想知道对于给出的 $q$ 种不同的购买方案 $k_i$ 和 $m_i$，每种方案 $l−f$ 的最小值。

## 说明/提示

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n,q \leq 1000,c_i,k_i\leq 10^6$ |
| $2$ | $20$ | 所有询问的 $k$ 都相等 |
| $3$ | $35$ | 无特殊性质 |

对于 $100\%$ 的数据，$1\leq m_i\leq n,q\leq 10^5,1\leq c_i,k_i \leq 10^9$。

本题满分 $70$ 分。

## 样例 #1

### 输入

```
5 2
1 9 22 10 19
18 4
5 2```

### 输出

```
34
-21```

## 样例 #2

### 输入

```
7 4
1 5 4 3 7 11 9
5 4
5 7
7 3
4 5```

### 输出

```
4
16
7
1```

## 样例 #3

### 输入

```
3 3
5 6 7
10 1
5 3
3 3```

### 输出

```
5
12
0```

# 题解

## 作者：Morax2022 (赞：7)

# Solution
首先，观察发现巧克力的顺序是无关紧要的，所以可以先从
小到大排序。

对于 $l - f$ 的值，对巧克力分类讨论：

1. $c_i < k$ 的巧克力对 $l - f$ 值的影响是 $c_i$。
1. $c_i > k$ 的巧克力对 $l - f$ 值的影响是 $2 \times k - c_i$。

观察上面两种情况，不难发现，对 $c_i < k$ 的巧克力，越便宜越好；对 $c_i \ge k$ 的巧克力，越贵越优。

将从小到大的排序处理成对 $l - f$ 的贡献。


假设一开始全部选左边的，若不是最优的，考虑用右边的代替左边的。

左右两边的分界线是 $k$，设左边选取 $x$ (不超过左边的个数）个，观察发现，要找到最小的 $x$，使得左边（从左往右数）第 $x$ 个的贡献小于右边（从右往左数）第 $m - x + 1$ 个的贡献，即不断使用右边的替换左边的，直到替换后变差。

当左边第 $x$ 个的贡献小于第 $m - x + 1$ 的贡献时，左边第 $y$ 个的贡献一定小于第 $m - y + 1$ 的贡献，所以可二分 $x$。

时间复杂度为 $O(q\log{n})$。
# Code
```cpp
#include <bits/stdc++.h>
#define int long long//坏习惯
using namespace std;
const int maxn = 1e5 + 5;
int a[maxn], sum[maxn], n, q;
main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);//优化 
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];//前缀和 
	while (q--)
	{
		int k, m; cin >> k >> m;
		int rr = lower_bound(a + 1, a + n + 1, k) - a - 1;
		int l = 0, r = min(m, rr), mid;
		while (l < r)
		{
			mid = l + r + 1 >> 1;
			int x = lower_bound(a + 1, a + n + 1, k * 2 - a[mid]) - a - 1;
			//依次枚举选的边界 
			if (n - x + mid <= m) l = mid;
			else r = mid - 1;
			//若变差则变大，变好则变小 
		}
		cout << sum[l] + 2 * k * (m - l) + sum[n - m + l] - sum[n] << "\n";
		//前r个的和（在原始r以内）加上m-r个后面数的和 
	}
}
```


---

## 作者：hnczy (赞：3)

对题目的分析很容易得知可以使用二分的方法。

二分什么就是关键。

通过分析可知在 $K$ 相等的情况下，巧克力代价从小到大的权值应该是一个单峰函数。

而随选取在 $K$ 左边的数量不断的增加，$l-f$  的值也是一个单峰函数。

为什么是单峰函数呢？在小于 $K$ 的这一段区间是单调递增的，因为 $l$ 是单调递增的，而 $f$ 是不变的，而当大于等于 $K$ 时， $l$ 不变，而 $f$ 单调递增，所以在这一段是单调递减的，所以是单峰函数。

那我们就可以是用二分的方法来二分在 $K$ 左边的数量，通过比较 $mid$ 与 $mid+1$ 的大小来找到这一个峰值的点，随而找到答案。

当然也可以用三分，但是三分不能处理不严格递增递减的单峰函数，所以这里我使用二分。
（比如 CF2046C Adventurers 就只能用二分）

时间复杂度 $O(q \log n)$ 。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,q,a[N],pre[N];
inline int cal(int x,int k,int m) {
	return pre[x]+ 2*k*(m-x) - (pre[n]-pre[n-m+x]);
}inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    int a[30];
    a[0] = 0;
    do {
        a[++a[0]] = x % 10;
        x /= 10;
    } while (x);
    for (int i = a[0]; i; i--) putchar(a[i] + '0');
    return;
}
inline void read(int &a) {
	char c = getchar();
	int f = 1;
	a = 0;
	while (!isdigit(c)) {
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (isdigit(c)) {
		a = (a << 1) + (a << 3) + (c ^ 48);
		c = getchar();
	}
	a *= f;
	return;
}
signed main() {
	read(n),read(q);
	for(int i=1; i<=n; i++)
		read(a[i]);
	sort(a+1,a+n+1);
	for(int i=1; i<=n; i++)
		pre[i]=pre[i-1]+a[i];
	for(int i=1,k,m; i<=q; i++) {
		read(k),read(m) ;
		int x=upper_bound(a+1,a+n+1,k)-a;
		int l= max(0ll,m-(n-x+1));
		int r= min(m,x-1);
		while(l<r) {
			int mid=l+r>>1;
			if(cal(mid,k,m)<cal(mid+1,k,m))
				r=mid;
			else l=mid+1;
		}
		write(cal(r,k,m));puts("");
	}
	return 0;
}

```

---

## 作者：lin135152 (赞：3)

看到 $10^5$ 的数据范围，我们马上就想到了二分或者关于二分的算法。那么这题是什么想法呢，我们首先肯定是要将巧克力的价格进行排序，因为我们发现他给的价格分界线的话，我们的价格离这个分界线的 $\text{abs}$ 值越大，$\text{diff}(l,f)$ 的值也就越小，所以我们肯定是要取两端的边缘。那么怎么取呢？

我们想到，如果我们左边要取一个数字的话，那我们是不是可以取右边跟它差不多价值甚至比他价值还小的替代品呢？因此我们可以二分当前我们要取的价值在右边有几个，能不能作为替代品最终和左端取的那么多数字的数目大于或者等于我们需要取的数字的多少呢？由于右端我们二分的数字都是小于或者等于我们要取的数字的，所以我们的左边要取的数字要尽量小。
代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int a[100005];
struct node{
	int x,y;
}ques[100005];
int sum[100005];
int n,q;
int check(int x,int y,int k){//x是左边的数目
	int res=sum[x];
	res+=2*k*(y-x)-sum[n]+sum[n-(y-x)];
	return res; 
}
signed main(){
 	ios::sync_with_stdio(false);
 	cin>>n>>q;
 	for(int i=1;i<=n;i++)
 		cin>>a[i];
 	sort(a+1,a+1+n);
 	for(int i=1;i<=q;i++){
 		cin>>ques[i].x>>ques[i].y;
 	}
 	for(int i=1;i<=n;i++){
 		sum[i]=sum[i-1]+a[i];
 	}
 	int cnt=0;
 	for(int i=1;i<=q;i++){
 		int x=lower_bound(a+1,a+1+n,ques[i].x+1)-a;
 		int l=0,r=min(x-1,ques[i].y);
 		int res=1e18;
 		while(l<r){
 			int mid=(l+r+1)/2;
 			int y=a[mid];
 			int y1=lower_bound(a+1,a+1+n,2*ques[i].x-y)-a;
 			int cnt=n-y1+1;//当前可替代的有这么多
			if(cnt+mid<=ques[i].y)
				l=mid;
			else
				r=mid-1; 
 		}
 		res=check(l,ques[i].y,ques[i].x);
 		cout<<res<<endl;
 	}
 }
```


---

## 作者：Walrus (赞：2)

**注：题目中阈值 $K$ 用大写表示。**

## Trick

首先对每个 $c_i$ 对 $l-f$ 的贡献分析，题目中明确给出了两段贡献：

- 若 $c_i\leq K$，则 $l-f$ 的贡献增加 $c_i$。
- 若 $c_i > K$，则 $l-f$ 的贡献增加 $K-(c_i-K)=2\times K - c_i$。

所以不难发现答案选择的巧克力区间一定是以阈值 $K$ 以端点，左边从 $0$ 开始向右依次选，右边从 $n$ 开始向左依次选，**也即 $c_i\leq K$ 的越小越优，反之越大越优**。



即答案大概是形如这样的（一共要选 $m$ 个数，假设 $c_i\leq K$ 的数有 $t$ 个）：

$$\min_{1\leq k \leq t}(\sum_{i=1}^{k}c_i+\sum_{i=n-(m-k)+1}^{n} 2\times K - c_i)$$

上面的式子可能有点毛病请见谅（似乎没问题），大概是计算 $c_i\leq K$ 和 $c_i>K$ 两部分的贡献。

考虑如何求上面的式子。

发现可以暴力枚举每一个 $k$，然后计算那个式子的值取 $\min$。

由于巧克力的 $c_i$ 值顺序没影响所以直接排序做前缀和，就可以 $O(1)$ 算出每一个 $k$ 的答案。

这部分的 code 如下：
```cpp
int calc(int mid, int k, int m) {//mid 是上述式子中的 k，而 k 是题目中给的阈值 K，注意区分
	return pre[mid] + 2 * k * (m - mid) - (pre[n] - pre[n - m + mid]); 
}
```

但是直接这么做复杂度大概是 $O(q \times N)$ 的，不可取。考虑优化。发现上述枚举的过程可以看作一个双指针在移动，每次枚举相当于两个指针分别移动一位，形式化来说，**每次指针移动相当于用一个左部分的 $c_i$ 替换掉一个右部分的 $c_i$。（左右部分分别指 $c_i\leq K$ 和 $c_i > K$ 的两部分）**

我们挖掘一下这个「替换」的性质。

举个例子，若 $n=7,m=3$，假设 $c_1\sim c_4$ 是左部分，又假设我们先选 $c_5 \sim c_7$。

在上述讲解中提到了 $c_i>K$ 的越大越优，所以我们第一次替换一定是用 $c_1$ 去换 $c_5$。

如果替换后更优，那么一定满足 $c_1< 2\times K - c_5$，这里假设是满足的。

下一步是用 $c_2$ 换 $c_6$，如果这里有 $c_2>2\times K - c_6$，那么直接停止交换，为什么？因为如果继续交换，要想答案更优，则必须要有 $c_3<2\times K-c_7$，显然与上式矛盾了，故交换停止（且这里如果交换了答案会更劣）。

上述的「替换」操作提示了我们在「替换」的过程中答案一定是**先越换越优再越换越劣**。故显然这是一个单峰函数，直接三分即可。

### 补充：

对于其他题解的疑惑，为何其他题解求单峰函数的峰值是用二分？

在我看来，对于浮点三分我们应该是这么写的：
```cpp
const double eps = 1e-6;
double l = L, r = R;
while(l + eos < r) {
  double mid = (l + r) / 2.0;
  double ql = mid - eps, qr = mid + eps;
  if(f(ql) < f(qr)) ...
  else ...
}
```

但这是整数三分，有的题解是在上述代码的基础上，没有用 $mid-eps$ 和 $mid+eps$ 去比，而是用 $mid$ 和 $mid+1$ 去比，我认为这是三分而不是二分，所以我认为部分题解有失妥当。

---

## 作者：__xxy_free_ioi__ (赞：1)

好题。

约定：设 $c_i$ 对答案的贡献为 $\operatorname{d}(c_i)$。

我们读题可得：

- 当 $c_i < k$ 时，$\operatorname{d}(c_i) = c_i = k - (k - c_i)$
- 当 $c_i \ge k$ 时，$\operatorname{d}(c_i) = 2k - c_i = k - (c_i - k)$。
- 综上，$\operatorname{d}(c_i) = k - \vert k - c_i \vert$，所以答案为 $\sum(k - \vert k - c_i \vert) = mk - \sum\vert k - c_i\vert$。那么要求答案最小化，就是让 $\sum\vert k-c_i\vert$ 最大化，让它最大化，就是让 $c_i$ 离 $k$ 越远越好。

所以考虑二分 $c_i$ 离 $k$ 的距离，判断是否满足存在 $m$ 个数。这里可以使用系统的二分函数查找（~~二分里面套二分？套娃？~~）。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
#define PII pair<int, int>
#define VI vector<int>
#define all(a) a.begin(), a.end()
#define up(i, s, t) for (int i = s; i < t; i++)
#define dw(i, s, t) for (int i = s - 1; i >= t; i--)

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	int n, q, k, m; cin >> n >> q;
	VI c(n), s(n + 1); // 注意，我这里的 s 是从一开始的
	up(i, 0, n) cin >> c[i];
	sort(all(c));
	up(i, 1, n + 1) s[i] = s[i - 1] + c[i - 1];
	auto lb = [&](int x) { return (int)(lower_bound(all(c), x) - begin(c)); };
	auto ub = [&](int x) { return (int)(upper_bound(all(c), x) - begin(c)); };
	while (q-- && cin >> k >> m) {
		int l = 0, r = 1e9, res = 0;
		while (l <= r) {
			int mid = (l + r) / 2;
            // 看看左边的和右边的是否可以选出 m 以上个满足条件的数
			if (ub(k - mid) + n - lb(k + mid) >= m) l = mid + 1, res = mid;
			else r = mid - 1;
		}
		int cntl = ub(k - res), pr = lb(k + res), cntr = n - pr;
		int sum = cntl * k - s[cntl] + // 左边的贡献，注意，s 从 1 开始！
				  s[n] - s[pr] - cntr * k - // 右边的贡献
				  (cntl + cntr - m) * res; // 多余的减去
		cout << m * k  - sum << '\n'; // 答案
	}
	
	return 0;
}
```

---

## 作者：内拉组里 (赞：1)

# Pts 15

> 暴力模拟デス～
>
> 首先对 $ c_i $ 进行排序，
>
> 由题意得：
> $$
> \begin{aligned}
> 	&\because
> 		\begin{cases}
> 			l = \min\{c_i,k\}
> 			\\
> 			f = c_i - l	
> 		\end{cases}
> 	\\
> 	&\ \begin{aligned}
> 	\therefore l - f	&= 2l - c_i 
> 						\\
> 						&=
> 						\begin{cases}
> 							c_i			&& c_i \le k
> 							\\
> 							2k - c_i	&& c_i \gt k
> 						\end{cases}
> 	\end{aligned}
> \end{aligned}
> $$
> 用双指针 $ l,r $ 动态逼近，
>
> 每次取 $ \min\{c_l,2k - c_r\} $ デス～

## Analyses :

> 总时间复杂度 $ \Theta (N \log{N} + QM) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

***

# Pts 35

> 对于特殊性质 `所有询问的 k 都相等` 可以发现，
>
> 当 $ k $ 作为一个常数时，每一个 $ c_i $ 对答案的贡献是固定的。
>
> 所以考虑预处理出每一个 $ c_i $ 对答案的贡献，
>
> 然后排个序再加一个前缀和デス～

## Analyses :

> 相应时间复杂度 $ \Theta (N \log{N} + Q) $ 
>
> 相应空间复杂度 $ \Theta (N) $ 

***

# Pts 100

> 说实话 $ 35pts $ 的特殊性质没什么卵用，和正解一点关系都没有。
>
> 满分做法需要在 $ 15pts $ 的暴力做法上进行优化。
>
> 显而易见的，我们可以在一定的范围内枚举 $ c_l $ 的 $ _l $，
>
> 此时 $ n - r + 1 \equiv m[i] - l $。
>
> 既然是枚举 $ \cdots $ 
>
> 那就二分喽 $ \cdots $ 
>
> 就知道你想不到，
>
> 在考场上也是跟自己耗了 $ 20min $ 才想出来的解法。
>
> 其实不然，可以这样想：
>
> 对于一个确定的 $ k $，求出了一组最优解 $ (l,m - l) $。
>
> 令 $ r = m - l $，则 $ ans = \sum\limits^l_{i = 1} c_i + r \sum\limits^n_{i = n -  r + 1} c_i $。
>
> 那么当 $ l $ 增大时，$ \sum\limits^l_{i = 1} c_i $ 单调递增，$ r \sum\limits^n_{i = n - r + 1} c_i $ 单调递减，
>
> 不难发现这里的 $ ans $ 是关于 $ l $ 的单峰函数，二分也就显而易见了吧。
>
> 这里说的 `一定的范围` 是指做枚举的 $ l $ 满足
> $$
> \begin{cases}
> 	c_l \le k
> 	\\
> 	c_{n - r + 1} \gt k
> 	\\
> 	l + r = m
> \end{cases}
> $$
> 其实总结起来也就只有两行代码。

## Analyses :

> 总时间复杂度 $ \Theta (QN \log{N}) $ 
>
> 总空间复杂度 $ \Theta (N) $ 

# Code :

```cpp
#include	<algorithm>
#include	<iostream>
#define		int		long long
using namespace std;
constexpr int maxn = 1e5+4;

int n, q;
int b[maxn];
int c[maxn];
int k[maxn];
int m[maxn];
int p[maxn];

inline int k_all (void)
{
	for (int i = 2; i <= q; i++) if (k[i] != k[i - 1]) return 0;
	return 1;
}

inline int calc (int pre, int k, int m)
{
	return p[pre] + (k << 1) * (m - pre) - (p[n] - p[n - (m - pre)]);
}

signed main (void)
{
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i <= q; i++) cin >> k[i] >> m[i];
	if (k_all ())
	{
		for (int i = 1; i <= n; i++)
		{
			int l = min (k[1], c[i]);
			int f = c[i] - l;
			c[i] = l - f;
		}
		sort (c + 1, c + n + 1);
		for (int i = 1; i <= n; i++) c[i] += c[i - 1];
		for (int i = 1; i <= q; i++) cout << c[m[i]] << endl;
	}
	else if (n <= 1000)
	{
		sort (c + 1, c + n + 1);
		for (int i = 1; i <= q; i++)
		{
			int l = 1;
			int r = n;
			int ans = 0;
			while (m[i]--)
			{
				if (c[l] < (k[i] << 1) - c[r] && c[l] <= k[i]) ans += c[l++];
				else ans += (k[i] << 1) - c[r--];
			}
			cout << ans << endl;
		}
	}
	else
	{
		sort (c + 1, c + n + 1);
		for (int i = 1; i <= n; i++) p[i] = p[i - 1] + c[i];
		for (int i = 1; i <= q; i++)
		{
			int l = max (0ll, m[i] - (n - (int) (upper_bound (c + 1, c + n + 1, k[i]) - c) + 1));
			int r = min (m[i], (int) (upper_bound (c + 1, c + n + 1, k[i]) - c - 1));
			while (l < r)
			{
				int mid = (l + r) >> 1;
				if (calc (mid, k[i], m[i]) < calc (mid + 1, k[i], m[i])) r = mid;
				else l = mid + 1;
			}
			cout << calc (r, k[i], m[i]) << endl;
		}
	}
	return 0;
}
```

---

## 作者：qwer6 (赞：0)

## 题意概述

给定一个序列 $c$，对于每个询问，给定两个值 $k$ 和 $m$。

对于每个给定的 $k$，$c$ 可以对应一个序列 $a$，其中 $a_i=\min(k,c_i)-\max(0,c_i-k)$。

要求从序列 $a$ 中取出 $m$ 个数，使这 $m$ 个数和最小。

## 思路

首先，巧克力的排列顺序显然是无关紧要的，所以我们先排一遍序，方便处理。

我们容易知道，$c_i$ 对应到 $a_i$ 有两种值：
$$
a_i=c_i\ \ (c_i\le k)\\
a_i=2\times k-c_i\ \ (c_i>k)
$$
那么显然我们的答案是选一部分 $a_i=c_i$ 和一部分 $a_i=2\times k-c_i$ 加和得到的。

因此，我们将  $c$ 序列拆成两个序列 $c_1$ 和 $c_2$，其中 $c_1$ 和原序列相同，$c_2$ 中的每一个元素是 $c$ 序列中元素的相反数，并分别做一次前缀和，用 $pre_1$ 和 $pre_2$ 表示两个序列的前缀和序列。

那么假设我们在 $c_1$ 中取 $x$ 个数，那么得到的答案就是 $pre_{1,x}+2\times k \times (m-x)+pre_{2,m-x}$。

而我们知道，最后的答案序列应当为单峰函数，所以我们可以进行二分找到控制点，具体为，二分在 $c_1$ 中取几个数，然后比较多取一个数会不会更优。

## Code

```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define int long long
#define Nxt puts("")
#define Spa putchar(32)
#define Line cout<<"______________________________"<<endl
namespace FastIO{
	inline void read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		a*=f;
		return ;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		int a[30];
		a[0]=0;
		do{
		   a[++a[0]]=x%10;
		   x/=10;
		}while(x);
		for(int i=a[0];i;i--)putchar(a[i]+'0');
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int N=1e5+5;
int n,q,m,k;
int c1[N],c2[N],pre[2][N];
inline int cal(int cnt,int m,int k){
	return pre[0][cnt]+k*2*(m-cnt)+pre[1][m-cnt];
}
signed main(){
	read(n),read(q);
	for(int i=1;i<=n;i++)read(c1[i]);
	sort(c1+1,c1+n+1);
	for(int i=1;i<=n;i++)c2[i]=-c1[n-i+1];	
	for(int i=1;i<=n;i++){
		pre[0][i]=pre[0][i-1]+c1[i];
		pre[1][i]=pre[1][i-1]+c2[i];
	}
	for(int i=1,x,y;i<=q;i++){
		read(k),read(m);
		x=upper_bound(c1+1,c1+n+1,k)-c1-1;
		if(x==n){
			write(pre[0][m]),Nxt;
			continue;
		}
		y=n-x;
		int l=0,r=min(m,x);
		while(l<r){//注意这里 l<r 而不是 l<=r
			int mid=l+r>>1;
			if(cal(mid,m,k)<cal(mid+1,m,k))r=mid;
			else l=mid+1;
		}
		write(pre[0][r]+2*k*(m-r)+pre[1][m-r]),Nxt;
	}
}
```

---

## 作者：DengDuck (赞：0)

比较直观的做法是三分。

首先考虑离线解决询问，按 $k$ 排序。

我们利用双指针，在 $k$ 增大的同时将数组分成两个区域，小于等于 $k$ 的和大于 $k$ 的，显然最优策略一定是从这两个区域的边缘开始选。

那么这就是一个类似于廊桥分配的问题。

不过这题具有单峰性质，假设我们在峰上，左边去多少个，右边都得去掉对应数量的元素，而右边这些元素的贡献是前 $m$ 的，而左边的贡献都不是前 $m$ 的，所以值会单调不升，右边同理。

因此考虑三分寻找分配方案。

时间复杂度为 $\mathcal O(n\log^2_3n)$。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const LL N = 1e5 + 5;
struct query {
    LL k, m, id;
} Q[N];
LL n, q, a[N], ans[N], sum[N], sum2[N];
bool cmp(query x, query y) { return x.k < y.k; }
LL gt(LL x, LL m, LL k) {
    LL t = m - x;
    return sum[x] + 2 * t * k - sum[n] + sum[n - t];
}
int main() {
    scanf("%lld%lld", &n, &q);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
    }
    for (int i = 1; i <= q; i++) {
        scanf("%lld%lld", &Q[i].k, &Q[i].m);
        Q[i].id = i;
    }
    sort(a + 1, a + n + 1);
    sort(Q + 1, Q + q + 1, cmp);
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i - 1] + a[i];
    }
    LL t = 0;
    for (int i = 1; i <= q; i++) {
        while (Q[i].k >= a[t + 1] && t + 1 <= n) t++;
        LL l = max(Q[i].m - n + t, 0ll), r = min(t, Q[i].m);
        while (l + 10 < r) {
            LL lmid = (2 * l + r) / 3, rmid = (2 * r + l) / 3;
            if (gt(lmid, Q[i].m, Q[i].k) < gt(rmid, Q[i].m, Q[i].k))
                r = rmid;
            else
                l = lmid;
        }
        LL mn = 1e15;
        for (LL j = l; j <= r; j++) {
            mn = min(mn, gt(j, Q[i].m, Q[i].k));
        }
        ans[Q[i].id] = mn;
    }
    for (int i = 1; i <= q; i++) {
        printf("%lld\n", ans[i]);
    }
}
```

---

## 作者：__log__ (赞：0)

# P9029 [COCI2022-2023#1] Čokolade
[折跃门](https://www.luogu.com.cn/problem/P9029)
## $\text{Part1}$：题意简述
~~[677](https://www.luogu.com.cn/user/318422) 的硬币工厂~~

给出 $n$ 个数 $a_i(1 \le i \le n)$ 和 $k,m$ 两个数，在 $n$ 个数中选出 $m$ 个数，这些数中若 $a_{b} > k$ 的要承担 $2 k - a_{b}$ 的代价，否则要承担 $a_b$ 的代价，求最小代价（$a_b$ 为选出来的数）。

## $\text{Part2}$：简单分析
分开讨论 $a_b \le k$ 与 $a_b > k$ 两种情况。
* $a_b \le k$ 可以得知取比较小的值更优。
* $a_b > k$ 这时取比较大的值反而更优。

所以当我们知道取几个比 $k$ 小的值，就知道当前取法最少要多少代价（剩下的你只能选比 $k$ 大的数）。
## $\text{Part3}$：Subtask1
排序，然后二分查找比 $k$ 小的最大的数，这样就把比 $k$ 小的数与比 $k$ 大的数分开了。

枚举选择比 $k$ 小的数的个数，不妨假设有 $pos$ 个比 $k$ 小的数，选择了 $p$ 个比 $k$ 小的个数，那 $p$ 的范围为 $[\max(0, m-n+pos),\min(pos,m)]$。
* 对 $m-n+pos$ 的解释：比 $k$ 大的有 $n-pos$ 个，如果全选，剩下的比 $k$ 小的数就只能选 $m-n+pos$，再与 $0$ 取最大值是因为可能 $m$ 太小，根本取不完 $n-pos$ 个比 $k$ 大的数。

然后取最小的 $p$ 个比 $k$ 小的数的和 $S_1$，最大的 $m-p$ 个比 $k$ 大的数的和 $S_2$（前后缀和：你好），算出 $ans_p=S_1+2k(m-p)-S_2$，最后给所有 $ans_p$ 求最小值后输出（别忘了 $p$ 是那个要枚举的数）。
* 事实上由于有了值域限制，所以可以认为 $p$ 个最小的数就是 $p$ 个比 $k$ 小的数，$m-p$ 个最大的数就是 $m-p$ 个比 $k$ 大的数。

时间复杂度 $O(nq)$（$pos$ 最多为 $n$）。
## $\text{Part4}$：Subtask3:
写这么辛苦只能拿 15pts，肯定不能溜了啊！！！

先手造一组数据，感性理解一下这个 $ans_p$ 的轨迹可能是条抛物线（反正是一个单峰的东西），然后就可以三分 $p$ 了。

### 证明（不想看可以切走）：
不妨假设 $ans_p < ans_{p-1}$，那么：
$$preSum_p + 2k \times (m-p) - nxtSum_{m-p}<preSum_{p-1} + 2k \times (m-p+1)-nxtSum_{m-p+1}$$
其中 $preSum_i$ 表示前 $i$ 个数的前缀和，$nxtSum_i$ 表示后 $i$ 个数的后缀和。
$$\because \begin{cases}
preSum_p = preSum_{p-1}+a_p\\
nxtSum_{m-p+1}=nxtSum_{m-p}+a_{n-m+p-1}
\end{cases}$$
$$\therefore a_p < 2k-a_{n-m+p-1}$$
又
$$\because \begin{cases}
......<a_{p-2}<a_{p-1}<a_{p}\\
......<a_{n-m+(p-2)-1}<a_{n-m+(p-1)-1}<a_{n-m+p-1}
\end{cases}$$
易得：$ans_p<ans_{p-1}<ans_{p-2}<......$（把去掉的几项前后缀和加上就ok了）。

$ans_p<ans_{p+1}$ 类似，所以就不展开了。
得到 $ans_p <ans_{p+1}<......$。
### 好了证完了
直接在线跑就完了，[跑得飞快](https://www.luogu.com.cn/record/129146114)。
## $\text{Part5}$：$\text{Code}$
```cpp
# include <bits/stdc++.h>
# define int long long
using namespace std;

int n, q, k, m;
int a[100100];
int preSum[100100], nxtSum[100100];

int calc(int x) {
	return preSum[x] + nxtSum[n - (m - x) + 1] + (m - x) * k * 2;
}

signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	// freopen("cokolade.in", "r", stdin);
	// freopen("cokolade.out", "w", stdout);
	cin >> n >> q;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; ++i) preSum[i] = preSum[i - 1] + a[i];
	for(int i = n; i >= 1; --i) nxtSum[i] = nxtSum[i + 1] - a[i];
	for(int i = 1; i <= q; ++i) {
		cin >> k >> m;
		int pos = upper_bound(a + 1, a + n + 1, k) - a - 1;
		int l = max(m - n + pos, 0ll), r = min(pos, m);
		while(l <= r) {
			if(l + 1 == r || l == r) {
				int ans1 = calc(l);
				int ans2 = calc(r);
				cout << min(ans1, ans2) << '\n';
				break;
			}
			int mid1 = (l * 2 + r) / 3, mid2 = (l + r * 2) / 3;
			int ans1 = calc(mid1);
			int ans2 = calc(mid2);
			if(ans1 <= ans2) r = mid2 - 1;
			else if(ans1 > ans2) l = mid1 + 1;
		}
	}
	return 0;
}
```
## $\text{Part6}$：？？？
![](https://cdn.luogu.com.cn/upload/image_hosting/0lo9rv1s.png)

nxtSum：为什么上下下标不是一样的？？？

as a result：0pts。

---


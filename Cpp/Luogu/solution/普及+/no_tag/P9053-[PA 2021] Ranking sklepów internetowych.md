# [PA 2021] Ranking sklepów internetowych

## 题目描述

给定长为 $n$ 的**排列** $a$。

定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$），$y$ 为区间中位数，则该区间的权值为 $x + 2y$。

求所有 $\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。

------------

中位数的定义：

以一个长为 $n$ 的**单调递增**的序列 $a$ 为例。

- 当 $n$ 为奇数，中位数为 $a_{\frac{n + 1}{2}}$。
- 当 $n$ 为偶数，中位数为 $\frac{a_{\frac{n}{2}} + a_{\frac{n}{2} + 1}}{2}$。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq a_i \leq n$。

## 样例 #1

### 输入

```
5
1 4 3 5 2```

### 输出

```
11 5```

# 题解

## 作者：LYBT (赞：8)

## 思路
许多同学第一眼看到这道题可能会无从下手，因为这个权值与**序列长度**和**中位数**这两个看似毫无关系的变量有关，很难处理出最大值，似乎除了暴力便没有其他做法了。  
但是，题目中提到这个大序列是一个 $1$ 到 $n$ 的排列，或许我们可以从此入手，这个最大值是否可能是个定值，看到这的同学可以自行思考一下。
* * *
~~**没想到的同学看这里。**~~  
通过一个数学很好的同学，我了解到这个最大值的确是个定值，我根据自己的理解做了一个简单的推理，希望同学们能够理解。   
我们希望求的是最大值，所以我们应当使这个序列的长度和中位数最大。很显然，我们可以发现当确定一个中位数时，能构成序列最大长度是可以确定的。设这个中位数是 $x$，必然满足 $1\le x \le n$。且在序列最大长度为奇数时，$x\in\mathbb{N}^+$；在序列最大长度为偶数时，$x=p+ \frac{1}{2}$ 且 $p\in\mathbb{N}^+$。  
容易想到，在构造序列最大值时，大于 $x$ 的数和小于 $x$ 的数的个数应当相等。所以当 $x\le \frac{n}{2}$ 时，小于 $x$ 的数少于大于其的数，所以我们应让所有小于 $x$ 的数来构造这个序列，此时序列最大长度表示出来是 $2(x-1)+1$；当 $x>\frac{n}{2}$ 时，大于 $x$ 的数少于小于其的数，所以我们应让所有大于 $x$ 的数来构造这个序列，此时序列最大长度表示出来是 $2(n-x)+1$。此时，$x$ 无论是否取整数，式子均成立。  
由于题目中提到，权值为 **$2$ 倍中位数加序列长度**，所以当 $x\le\frac{n}{2}$ 时，权值为 $2(x-1)+1+2x$，即 $4x-1$；当 $x>\frac{n}{2}$ 时，权值为 $2(n-x)+1+2x$，即 $2n+1$。经比较后可发现，最大值必然是 $2n+1$，也就是说它与 $x$ 无关，即为定值。  
那么最大值必然存在吗？  
显然当 $x=n$ 时，或者构造序列为整个序列时，均取最大值。通过这个推理过程，我们也可以发现取最大值时序列的特征：中位数大于 $\frac{n}{2}$，且包括**整个大序列所有大于中位数的整数**以及相等个数的**小于中位数**的数。
## 编码
通过上述，我们应该有了大体的思路。  
我们所构造的序列均带有大于等于中位数的所有整数，所以我们从此入手，先预处理出所有数处在数列的位置，然后从 $n$ 始，每次增加一个**小一的数**，一直到 $\frac{n}{2}$，其中只包含整数，在同时我们也应注意数列长度的奇偶，将循环写成 `for(int i=n;i>=n/2;i--)`，每次将 $i$ 和 $i+\frac{1}{2}$ 当做中位数，并计一个 $l$ 和 $r$，表示当前 $i$ 到 $n$ 所有数字的最左位置和最右位置，区间 $[l,r]$ 便是我们通过寻找 $i$ 到 $n$ 的整数所构造的初级序列。这个序列可能已经不符合要求，即目前长度超过目标长度；这个序列可能缺少元素，这时可以向左右扩展，计 $tem$ 为序列缺少元素的个数，则向左向右最多需要扩展 $tem$ 个位置，当然也需要我们同时判断边界问题。最后我们计 $tl$ 和  $tr$ 分别为向左向右能够扩展的最大长度，向左向右取任意长度补充保证和始终为 $tem$，显然方案增加个数为 $tr+tl-tem+1$。当然不排除极端情况，$tr+tl-tem+1$ 的值可能为负，此时方案数增加 $0$。
## 代码部分
部分叙述抽象的部分，请参考代码。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int max(int x,int y){return x>y? x:y;}
int min(int x,int y){return x<y? x:y;}
inline int read(){
	char c=getchar();
	int sum=0,flag=1;
	while(!isdigit(c)){if(c=='-')flag=-1;c=getchar();}
	while(isdigit(c)){sum=(sum<<1)+(sum<<3)+(c^48),c=getchar();}
	return sum*flag;
}
inline void write(int x){
	if(x<0) x=(~x)+1,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10|48); 
}
const int N=1e6+5;
int n=read(),a[N],pos[N],l,r,ans;
signed main(){
	for(int i=1;i<=n;i++){
		a[i]=read();
		pos[a[i]]=i;
	}
	write(n*2+1),putchar(' ');
	l=n+1;
	for(int i=n;i>=n/2;i--){
		int len,tem,tl,tr;
		l=min(l,pos[i]);
		r=max(r,pos[i]);
		len=r-l+1;
		tem=(n-i)*2+1-len;
		if(tem>=0){
			tl=min(r+tem,n)-r;
			tr=l-max(l-tem,1);
			ans+=max(tl+tr-tem+1,0);
		}
		if(i==n)
			continue;
		tem=(n-i)*2-len;
		if(tem>=0){
			tl=min(r+tem,n)-r;
			tr=l-max(l-tem,1);
			ans+=max(tl+tr-tem+1,0);
		}
	}
	write(ans);
	return 0;
}
```
### The end.

---

## 作者：__rnfmabj__ (赞：7)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P9053)

给定长为 $n$ 的**排列** $a$。

定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$）$y$ 为区间中位数，则该区间的权值为 $x + 2y$。

求所有 $\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。

## 理清思路
首先很显然的一件事是最大值一定是 $2 \times n +1$，因为它取全部的数字之后的值就是 $2 \times n +1$。

然后我们仔细想想，若是想要最大值是 $2 \times n+1$，我们取的中位数 $k$ 一定要**大于** $ \frac{n}{2} $。

既然知道了最大值以及中位数 $k$ 的值，我们就可以找出序列的长度，手搓几个样例之后，我们发现这其中**有一半的值是大于我们所找到的中位数 $k$ 的，而在整个序列中大于这个中位数 $k$ 的值恰好就只有该序列长度的一半个**。

知道了这一点后，我们就可以预处理出大于该中位数 $k$ 的最左边的和最右边的值，并将它们的下标用 $l,r$ 表示，如果 $r-l+1>$ 该序列的长度，则没有答案，否则就有 序列长度 $-(r-l+1)+1$ 个答案，最后，我们在判断一下越界情况，就 $A$ 了一道绿题了！

## 代码
有了综上所述的思路之后，第一个问题时候怎样找左值 $l$ 和右值 $r$，用递推的思路，去找上一个中位数的左值 $l$ 和右值 $r$，取 $l$ 与自身坐标的最小值作为自己的 $l$，右值 $r$ 则取最大值。

第二个问题是如何判越界，如果我们当前要补 $s$ 个数才可以达到需要的长度，当 $l≤s$ 是说明是左边越界，要将答案减去 $s-l+1$ 个（至于为什么，读者可以自行想想）。当 $r+s>n$ 时说明是右边越界，此时，答案就要减去 $r+s-n$ 个。
## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,ans,ansl,a,bot[3000010],l=INT_MAX,r=1,k,L,s;
//ans为所求最大值，bot用于存每个数字的位置，l和r代表最左值和最右值，L是区间长度，k是所需长度，s代表要补几位
int main(){
	scanf("%lld",&n);
	ans=2*n+1;//z计算最大值
	for (int i=1;i<=n;i++){
		scanf("%lld",&a);
		a*=2;//我直接乘二存的，便于后面求值
		bot[a]=i;//记录下标
	}
	for (int i=n*2;i>n;i--){//枚举所有可行的中位数
		if (bot[i]==0)bot[i]=bot[i-1];//如果没有被标记过，说明是中位数是，让他的下标等于比他大的值，再去求 l 和 r
		r=max(bot[i],r);
		l=min(bot[i],l);//寻找左值和右值
		k=ans-i,L=r-l+1,s=k-L;//计算
		if (L<=k){
			ansl+=s+1;//统计答案
			if (l<=s)ansl-=(s-l+1);
			if (r+s>n)ansl-=(r+s-n);//判断越界
		}
	}
	printf("%lld %lld",ans,ansl);//输出
	return 0;//完结撒花
}
```

---

## 作者：superl61 (赞：2)

## 题意

定义一个区间的权值是 “区间长度与2倍中位数的和”。求一个**排列**的所有子区间权值的最大值，以及最大值的个数。

## 算法一

对于一个平凡的区间，动态维护中位数可能需要对顶堆之类的技巧，时间复杂度无法通过本题。但可以用这个做法打个表，然后发现第一问就是 $2n + 1$。

第二问的关键恰恰就在于这个区间是一个 $1 \sim n$ 的**排列**。

考虑**排列**有什么性质。考虑固定子区间长度 $m$，一个最贪心的想法是我们选择 $n - m + 1 \sim n$，但实际上很难存在这样的选法。继续挖掘题目条件，发现并不需要子区间的每个数都尽量大，只需要满足**中位数是尽可能大的**。

考虑中位数是怎么得到的，它其实是前 $\lceil \frac{m}{2} \rceil$ 大的数里面最小的，所以我们只需要必选 $n - m + \lceil \frac{m}{2} \rceil \sim n$ ，剩下一半随便选，因为对中位数取值根本没影响。

考虑安排好必选之后，还剩哪些位置可供我们选择。手玩样例可以发现，我们需要记录每个必选点在原序列中的位置，记最靠左的位置是 $l$，最靠右的位置是 $r$，那么可以选 $1 \sim l - 1$ 和 $r + 1 \sim n$ 中的数。

而且求的是子区间，得连续，所以我们还要拿式子计算一下选法，具体看代码，这个有点儿难调，大概思路就是固定一侧可以随意调整，然后算另一侧的上下界，这个取值范围就是贡献。

同时我们发现，**递增**枚举 $m$ 时，必选区间也是不断扩大的，代码就这么实现。

时间复杂度 $O(n)$。

## 算法二

同机房大佬还有一种思考方式，是在原区间基础上考虑每次**删去**一个数怎么保证中位数最大。结论是只能删比**当前中位数**小的数。

这个做法理解第一问也很自然。我们假设原区间的权值一定是最大值，看删去若干个数后能否推出矛盾。先删一个数，发现 $m$ 会 $- 1$，而中位数最多 $+1$，继续删数是同理的。由此证明**删数并不会使权值变大**。

参考代码用的算法一。

```cpp
#include<bits/stdc++.h>
#define F(i,l,r) for(int i(l);i<=(r);++i)
#define G(i,r,l) for(int i(r);i>=(l);--i)
#define int ll
using namespace std;
using ll = long long;
const int N = 1e6 + 5;
int n, p[N], pos[N], pw[N]; 
signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n;
	F(i, 1, n) cin >> p[i], pos[p[i]] = i;
	int l = n + 1, r = 0, ans = 0;
	F(m, 1, n){
		int nw = n - m + (m + 1) / 2;
		l = min(l, pos[nw]);
		r = max(r, pos[nw]);
		int t = m - (r - l + 1);
		if(t < 0) continue;	
		int yul = l - 1;
		int yur = n - r;
		int most = min(t, yul);
		int least = max(0ll, t - yur);
		ans += most - least + 1;
	}
	cout << 2 * n + 1 << ' ' << ans << '\n';
	return fflush(0), 0;
}
```

---

## 作者：zhm080507 (赞：1)

#### 题面大意

即要求区间长度与中位数两倍的和的最大值，以及其情况数。

#### 算法分析

首先我们来考虑 $x+2y$ 的最大值：容易发现，对于一串长度为 $n$ 的排列，这个最大值一定为 $2n+1$，也就是单个数 $n$ 的值。（可以多尝试几组样例，这个性质还是很容易发现的）

然后我们考虑最大值的个数：我们发现，如果给定序列的长度 $len$，那么只要确定了这个序列的后一半（即 $n$ 到 $n-len/2$），那么这个串的权值就是我们要求的 $\max$。

结合以上信息，我们发现对答案的统计就是从 $n$ 的位置开始向两边延伸，首先我们可以用桶存下各个数的位置：

```c++
	for(ll i=1;i<=n;i++){
		a[i]=read();
		ps[a[i]]=i;
	}
```

然后就像上面说的，找到必须确定的值所在的左端点和右端点（这一步在枚举时 $O(1)$ 转移），然后再通过一些数学计算求得当前长度可行的方案数（具体看代码注释）：

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long

const ll N=1100000;
ll n,a[N],ans,s,b[N],bt,lt,rt,mx,tp,ps[N];

ll read(){
	ll res=0;
	char ch=getchar();
	while(!isdigit(ch)){
		ch=getchar();
	}while(isdigit(ch)){
		res=(res<<1)+(res<<3)+ch-'0';
		ch=getchar();
	}
	return res;
}

void sol(){
	ans=n*2+1;s=1;
	lt=rt=ps[n];
	for(ll i=2;i<=n;i++){//枚举区间长度 
		ll mi=i/2;
		ll ds=n-mi;//ds就是要确定的最小值 
		if(ps[ds]<lt) lt=ps[ds];
		if(ps[ds]>rt) rt=ps[ds];//持续更新左端点和右端点 
		
		if(rt-lt+1>i) continue;//如果长度不够，就不合法 
		else{//一点计算 
			ll rs=n-rt;//考虑左、右两边还剩多少数可以加入区间 
			ll ls=lt-1;
			ll ln=i-(rt-lt+1);
			//ln是还差多少数可以随意安排在固定区间的两边 
			if(ls<rs) swap(ls,rs);
			//我们让ls成为长的 
			if(ls>=ln&&rs>=ln){
				s+=ln+1;//如果都能放下，那显然方案就是ln+1 
			}else{
				s+=(min(ln,ls)-(ln-rs)+1);
				//min(ln,ls)是最多能放多少
				//(ln-rs)是最少得放多少
				//方案数就是作差 
			}
		}
	}
}

int main(){
	n=read();
	for(ll i=1;i<=n;i++){
		a[i]=read();
		ps[a[i]]=i;
	}
	sol();
	printf("%lld %lld\n",ans,s);
	return 0;
}
```

---

## 作者：lwwwb_555 (赞：0)

# 思路
首先我们来看一个完全的排列，他的中位数的两倍就是 $n+1$，序列长度是 $n$，所以完全排列第一个问题的答案便是 $2\times n+1$。当它不是完全排列的时候，例如在完全排列上删去一个数时，若你删去的是中位数之前的一个数，那么中位数的两倍就会加一，若删去的是中位数之后的一个数，那么中位数的两倍就会减一。又因为你的序列长度减少了 $1$，所以最后删去一个数的序列的权值最大就是 $2\times n+1$。

解决了第一个问题，那么我们来考虑如何解决第二个问题。

我们把中位数维护成两个（若中位数只有一个则维护的两个中位数都是它）。那么这两个数加起来便是中位数的两倍。每次多删一个数，就相当于把较小的那个中位数加一。然后我们来枚举删多少个数，那么小于最小的那个中位数的数是都可以被删掉的。由于题目要求连续，所以只能从头和尾分别删一部分，我们只需要把头和尾分别最多能删多少个数算出来，然后稍微组合一下就好了。

时间复杂度：$O(n)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000500];
long long ans=1,n;//答案有可能爆int
int read(){
	int res=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		res=(res<<3)+(res<<1)+c-'0';
		c=getchar();
	}
	return res*f;
}//快读
int main(){
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	printf("%d ",2*n+1);
	int p,pp;
	if(n%2==0) p=n/2+1,pp=p;
	else p=(n+1)/2,pp=p+1;
	long long l=0,r=n+1;
	for(long long i=1;i<=n-1;i++){
		while(a[l+1]<p) l++;//算从头开始最多能删多少个数
		while(a[r-1]<p) r--;//算从尾开始最多能删多少个数
		ans+=max(min(n+1-r,i)+min(i,l)-i+1ll,0ll);//注意：假如你现在要删i个数，你从头或从尾开始最多只能i个数，但能删的个数可能会超过i，所以要取min
		if(p==pp) pp++;
		else p++;//动态维护中位数
	}
	printf("%lld",ans);
	return 0;
}
```

---


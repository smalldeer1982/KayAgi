# [省选联考 2023] 火车站

## 题目描述

有 $n$ 个火车站排成一条直线，从 $1$ 到 $n$ 编号。一共有 $m$ 条火车轨道，每条轨道覆盖一段火车站区间 $[l_i, r_i]$。

对于一个被多条火车轨道覆盖的火车站，火车在经过这里的时候，可以在此处改变轨道。但是火车无法掉头，只能朝着一个方向运行（即只能一直往 $1$ 的方向开或者一直往 $n$ 的方向开）。

小 A 从火车站 $x$ 出发，即搭上了经过 $x$ 的任意一列火车（这列火车也可能是从车站 $x$ 出发）。这列火车可能行驶在火车站 $x$ 所处的任一条轨道上，其运行方向既可能是往 $1$ 的方向开，也可能是往 $n$ 的方向开。小 A 上车后就开始昏睡，直到乘坐的火车到达某条线路的终点站停下，他才醒过来。问小 A 最后可能到达的车站。

注意：火车应运行至少一个车站，且火车切换轨道后不会立刻停下来，而是会继续沿着当前轨道前进。


## 说明/提示

**【样例 1 解释】**

火车从车站 $4$ 出发，沿着第一条轨道可以运行到终点 $3$，也可以接着沿第三条轨道运行到终点 $1$。

火车从车站 $4$ 出发，沿着第二条轨道可以运行到终点 $6$，也可以在车站 $5$ 换到第四条轨道运行到终点 $7$。

所以最终按顺序输出 $1, 3, 6, 7$。

**【数据范围】**

对于所有的数据，保证 $1 \le n, m \le 2 \times 10^5$，$1 \le x \le n$，$1 \le l_i < r_i \le n$。

|测试点|$n, m \le$|特殊性质|
|:-:|:-:|:-:|
|1|$50$|无|
|2|$50$|无|
|3|$5000$|无|
|4|$5000$|无|
|5|$5000$|无|
|6|$2 \times 10^5$|A|
|7|$2 \times 10^5$|A|
|8|$2 \times 10^5$|无|
|9|$2 \times 10^5$|无|
|10|$2 \times 10^5$|无|

特殊性质 A：保证 $x = 1$。


## 样例 #1

### 输入

```
7 5 4
3 4
4 6
1 3
5 7
4 6
```

### 输出

```
1 3 6 7
```

# 题解

## 作者：Light_az (赞：42)


# 模拟大法好！

今年省选赛时看了旁边神仙一眼，第一题用了 $300$ 多行代码写了个线段树 ，赛后发现还有使用并查集和树状数组的人，但是个人认为此题没有这么麻烦，我们直接采用模拟的方式来完成这一题。
## 简化题意

由于原题面有点复杂，因此我稍微化简题意：给定 $m$ 条线段，覆盖点 $x$ 的线段我们定义为该线段合法，与合法的线段有任何重合的线段也合法（包括端点重合），求合法线段的端点。

## 解法

首先通过分析样例我们可以得到这样一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hy69shm1.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

（图丑请见谅）

看完这张图片也许你会有一个疑问，为什么 $5$ 号点是合法线段端点，却不是正确答案呢？再次阅读题目后，我们知道：`火车无法掉头，只能朝着一个方向运行`，也就是说，火车是往 $7$ 号点的方向开去的，不能掉头或者瞬间停下到 $5$ 号点。由此我们可以得出结论：

- 如果合法线段在点 $x$ 的右侧，那么答案编号一定是它的右端点（因为方向是往右的）

- 如果合法线段在点 $x$ 的左侧，那么答案编号一定是它的左端点（因为方向是往左的）

- 如果合法线段覆盖了点 $x$，那么答案编号一定是它的左，右端点（因为火车从中间出发，方向可以往左也可以往右）


在处理完之后，我们就要把步骤退回来求合法线段了，我们假设你正在玩搭桥游戏，有很多木板可以搭桥，那么你搭桥的形状一定是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/9p6hpxhf.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

由上图我们发现每一块木板的端点一定是在上一块木板上，那么我们可以用这个思路寻找合法线段，首先定义 $l,r$ 分别是合法线段的最大左端点和最大右端点，如果说一个线段的左端点或者右端点处于这个区间内（即与合法线段重合），那么这个线段也合法，于是我们可以使用两个循环，分别求出 $l,r$ 的最值，即：

```cpp
F1(i,1,n) if(a[i].l>=mini&&a[i].l<=maxi) maxi=max(maxi,a[i].r);//线段左端点位于合法区间内，该线段合法，更新右端点的最值
F2(i,n,1) if(a[i].r>=mini&&a[i].r<=maxi) mini=min(mini,a[i].l);//同上，但是需要倒推，因为线段排序后的上升性，后面有讲
```

（为了方便理解，将 $l,r$ 换成了 $mini,maxi$ ）

当然，当某一条线段覆盖了 $x$ 号点时，根据前面的定义那么该线段是合法的，左右端点都是答案，所以也要更新最两端的大值，即：

```cpp
if(a[i].l<=x&&x<=a[i].r){//覆盖 x 号点
		mini=min(mini,a[i].l);//取最值
		maxi=max(maxi,a[i].r);
		v[a[i].l]=v[a[i].r]=1;//标记合法
} 
```

在完成以上处理之后，如果一条线段没有**完全**覆盖在 $l,r$ 之间时，这一条线段一定不合法。

最后根据上面搭桥的那一张图片，我们发现从左到右的每一块木板的左端点和右端点一定是不下降的，首先来看一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/49m9ayzb.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

我们发现第 $3$ 条线段应该是合法的，但是由于我们遍历线段的顺序是按照编号的，所以它的遍历顺序应该是左，右，中。此时第 $3$ 条线段就不合法了，因为它与唯一的合法线段也就是第 $1$ 条线段没有重合部分。

然后我们对线段进行排序后，就得到了下面这张图片：



![](https://cdn.luogu.com.cn/upload/image_hosting/2xrz0206.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

此时第 $3$ 条线段就是合法的，因为它与第 $2$ 条线段有重合部分，而第 $2$ 条线段又与合法线段 $1$ 有重合部分，由此我们可以得出结论：线段要采取排序，从而保证端点的不下降性



最后输出时我们套用上第一步的样例结论做最后的特判即可（还需要标记数组给答案打标记，说明此点是合法线段的端点），后面是代码部分：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F1(i,j,n) for(int i=j;i<=n;i++)
#define F2(i,j,n) for(int i=j;i>=n;i--)
using namespace std;
const int N=1e6+10,NN=1e4+10;
ll n,m,k,x,y,u,w,cnt=0,ans=0,t=0,l,r,len,T;
ll mini=INT_MAX,maxi=0,Mod;
bool v[N];
struct Node{
	ll l,r; 
}a[N];
bool cmp(Node a,Node b){
	if(a.l==b.l) return a.r<b.r;
	return a.l<b.l;
}
int main(){
	cin>>m>>n>>x; 
	F1(i,1,n){
		cin>>a[i].l>>a[i].r;//双端编号
		if(a[i].l<=x&&x<=a[i].r){//覆盖x号点，即合法区间 
			mini=min(mini,a[i].l);//更新合法端点最值 
			maxi=max(maxi,a[i].r);
			v[a[i].l]=v[a[i].r]=1;//线段两端标记为答案 
		} 
	}
	sort(a+1,a+1+n,cmp);//排序 
	F1(i,1,n) if(a[i].l>=mini&&a[i].l<=maxi) maxi=max(maxi,a[i].r);//左端与合法线段有重合部分，更新最大值
	F2(i,n,1) if(a[i].r>=mini&&a[i].r<=maxi) mini=min(mini,a[i].l);//右端与合法线段有重合部分，更新最大值
	F1(i,1,n){
		if(a[i].l<mini||a[i].r>maxi) continue;//不是合法线段 
		if(a[i].r<x) v[a[i].l]=1;//由结论得，该合法线段在x号点左边时，左端点是答案 
		else v[a[i].r]=1;//同上 
	}
	F1(i,1,m) if(v[i]&&i!=x) cout<<i<<" ";//此编号标记为答案且不是起点 
	return 0;
}

```


---

## 作者：joyslog (赞：8)

在草稿纸上模拟题意：

![image](https://cdn.luogu.com.cn/upload/image_hosting/f5qeyr06.png)

容易发现，题意其实就是找到 $x$ 所在的连通块。连通块包含的铁路的左端点只要在 $x$ 左边即可纳入答案，右端点只要在 $x$ 右边即可纳入答案。

连通块可以用并查集维护。

具体的，我们把区间排序后额外加入一个区间 $[x,x]$ 并编号，便于之后用并查集找到 $x$ 点所在的集合。然后从左到右做区间并，把相交的区间并入同一个集合。

然后再扫一遍区间得到答案。

时间复杂度 $\mathcal{O}(m\log m)$。

参考代码：

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;

inline ll read() {...}
char buf[50];
inline void write(ll x) {...}

const int MAX_N = 5e5 + 10;
int n, m, x, cnt, L, R;
pii line[MAX_N];
int fa[MAX_N], ans[MAX_N];

inline bool check(pii x, pii y) {
    int l1 = x.first, r1 = x.second;
    int l2 = y.first, r2 = y.second;
    return (r1 >= l2 && l1 <= r2);
}

inline int find(int x) {
    if(fa[x] == x)  return x;
    return fa[x] = find(fa[x]);
}

inline void merge(int x, int y) {
    fa[find(x)] = find(y);
}

int main() {
    n = read(), m = read(), x = read();
    for(int i = 1; i <= m; i++)
        line[i].first = read(), line[i].second = read();
    line[++m] = make_pair(x, x);
    sort(line + 1, line + m + 1);
    m = unique(line + 1, line + m + 1) - line - 1; 
    for(int i = 1; i <= m; i++)
        fa[i] = i;
    L = line[1].first, R = line[1].second;
    for(int i = 2, lst = 1; i <= m; i++) {
        if(check(make_pair(L, R), line[i])) {
            merge(i, lst);
            R = max(R, line[i].second);
        }
        else {
            L = line[i].first;
            R = line[i].second;
            lst = i;
        }
    }
    int pos = lower_bound(line + 1, line + m + 1, make_pair(x, x)) - line;
    int fx = find(pos);
    for(int i = 1, l, r; i <= m; i++)
        if(i != pos && find(i) == fx) {
            l = line[i].first, r = line[i].second;
            if(l < x)   ans[++cnt] = l;
            if(r > x)   ans[++cnt] = r;
        }
    sort(ans + 1, ans + cnt + 1);
    cnt = unique(ans + 1, ans + cnt + 1) - ans - 1;
    for(int i = 1; i <= cnt; i++)
        write(ans[i]), putchar(' ');
    putchar('\n');
    return 0;
}
```



---

## 作者：elbissoPtImaerD (赞：7)

一个比较暴力的做法。

首先发现：编号比 $x$ 小的点能最后到达的必要条件是其为某条铁路线的左端点，编号比 $x$ 大的点同理。

我们考虑：对于一条铁路线 $[l,r]$，直接 $\forall i\in[l,r)$，连无向边 $(i,i+1)$。

这样只有在最终构成的图上与起点 $x$ 在同一连通块上的点才可能是答案。  
不难发现结合上面的性质就是充要条件了。

但是直接暴力建是 $\mathcal{O(n^2)}$ 的，不够优。

发现有很多重复边，实际上每个点最多只有两条边是有用的，即向左右相邻连的两条边。

类似[这个题](https://www.luogu.com.cn/problem/P2391)，我们可以利用并查集来优化区间覆盖。

具体实现看代码：

```cpp
const int N=2e5+3;
int n,m,st,fa[N],vis[N];
std::vector<int>G[N];
bool L[N],R[N];
il int get(int x)
{
	for(;x^fa[x];x=fa[x]=fa[fa[x]]);
	return x;
}
il void dfs(re int u)
{
	vis[u]|=1;
	for(re int v:G[u]) !vis[v]&&(dfs(v),7);
}
void Solve()
{
	rd(n),rd(m),rd(st);
	for(re int i=1;i<=n;++i) fa[i]=i;
	for(re int l,r;m--;)
	{
		rd(l),rd(r),L[l]|=1,R[r]|=1;
		for(;l<r;r=fa[r])
			if(get(r)==r) G[r].pb(r-1),G[r-1].pb(r),fa[r]=get(r-1);
	}
	dfs(st);
	for(re int i=1;i<st;++i) vis[i]&&L[i]&&(prt(i,' '));
	for(re int i=st+1;i<=n;++i) vis[i]&&R[i]&&(prt(i,' '));
	return;
}
```

---

## 作者：strcmp (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P9166)

因为这题一个边界写挂了，测样例全过，感觉样例强度还行没对拍，成功被送出省队，喜大普奔。

% 同校进队的 dalao Orz。

提供一个**被诈骗**的做法，相对于正解时间复杂度和码量上**双劣**，就当一个教训罢了。

### Solution

考虑对每个区间内的结点互相连边。

注意到，对于 $x$，直接坐上火车，且**不换道**，能走到最左的位置显然就是**包含 $x$ 的，左端点最小的区间左端点**。这样我们可以从该区间的右端点 $r$ 出发，直接覆盖到左端点 $l$，容易想到 $[l,\,x)$ 中所有火车站必然都可以走到。

接下来考虑走到 $[l,\,x)$ 这个区间怎么转车。由于我们已经向左走了，因此必然不可能向右走，因此我们可以直接找**右端点包含于 $[l,
\,x）$ 中左端点最小的区间**，覆盖到这个区间的左端点，记为 $nl$。区间 $[nl,\,x)$ 的所有位置，即为向左走，转车一次之后能到达的所有位置，记录一下答案。

以此类推，继续查找右端点在区间 $[nl,\,l)$ 的区间的左端点最小的左区间，然后继续覆盖……

对于边界条件，当且仅当扩展到的左端点不小于当前的左端点，或者新的区间满足右端点大于左端点时结束。

对于向右走的，将序列翻转之后就转化成了向左走的情况，同理。

对于查找右端点在一个区间内的最小左端点，可以对右端点建立一个桶，存右端点在当前位置上最小的左端点，可以在读入的时候处理一下。然后在这个桶上 RMQ 即可。向右走的同理。

对于区间覆盖，可以直接暴力，分析一下时间复杂度，右端点每次必然变成原来的左端点减 $1$，左端点单调减少，暴力覆盖的时间复杂度是均摊 $\Theta(n)$ 的。

对于 RMQ，虽然是静态区间问题，但实际上查询 RMQ 的次数在一般情况下远远小于序列长度，最多也是 $\Theta(n)$ 级别的，可以使用好写常数又小的 zkw 线段树做 RMQ。

分析时间复杂度，最多查询 $\Theta(n)$ 次 RMQ，总时间复杂度是 $\Theta(n \log_2 n)$ 的。转化成约束 RMQ 可以做到 $\Theta(n)$，但实际情况下常数较小，这是没有必要的。

以下经过是改动之后可以通过的考场代码，注意对于向右走的情况直接进行了与左端点类似的分讨，细节很多。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 3e5 + 10;
const ll mod = 998244353LL;
int n, m, x, M = 1; ll l[maxn], r[maxn], mx[maxn], mi[maxn], d1[maxn << 3], d2[maxn << 3];
vector<int>a[maxn], b[maxn]; int vis[maxn];
void prepare(){
	while (M <= n)M <<= 1;
	for (int i = 1; i <= (M << 1); i++)d2[i] = 2147483647LL;
	for (int i = 1; i <= n; i++)d1[i + M] = mx[i], d2[i + M] = mi[i];
	for (int i = M; i >= 1; i--){
		d1[i] = max(d1[i << 1], d1[i << 1 | 1]);
		d2[i] = min(d2[i << 1], d2[i << 1 | 1]);
	}
}
inline ll MaxRMQ(int l, int r){
	ll ans = 0; 
	for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l >>= 1, r >>= 1){
		if (~l & 1)ans = max(ans, d1[l ^ 1]);
		if (r & 1)ans = max(ans, d1[r ^ 1]);
	}
	return ans;
}
vector<int>stat;
inline ll MinRMQ(int l, int r){
	ll ans = 2147483647;
	for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l >>= 1, r >>= 1){
		if (~l & 1)ans = min(ans, d2[l ^ 1]);
		if (r & 1)ans = min(ans, d2[r ^ 1]);
	}
	return ans;
}
int u = 0;
int main(){
	scanf("%d%d%d", &n, &m, &x);
	for (int i = 1; i <= n; i++)mi[i] = 2147483647LL;
	for (int i = 1; i <= m; i++){
		scanf("%lld%lld", &l[i], &r[i]);
		//printf("%lld %lld\n", l[i], r[i]);
		u |= (x >= l[i] && x <= r[i]);
		mx[l[i]] = max(mx[l[i]], r[i]);
		mi[r[i]] = min(mi[r[i]], l[i]);
		a[l[i]].push_back(r[i]);
		b[r[i]].push_back(l[i]);
	}
	if (!u)exit(0);
	prepare();
	/*
	for (int i = 1; i <= m; i++){
		if (!a[i].empty())printf("%d:", i);
		for (int j = 0; j < a[i].size(); j++)printf("%d ", a[i][j]);
		if (!a[i].empty())puts("");
	}
	*/
	int nl = MinRMQ(x, n);
	int nr = MaxRMQ(nl, x); 
	//右端点覆盖了 x 中 l 最小的区间
	//puts("one:");
	while (1){
		//printf("%d %d\n", nl, nr);
		for (int i = nl; i <= nr; i++){
			for (int j = 0; j < a[i].size(); j++){
				if(a[i][j] > x)vis[a[i][j]] = 1;
			}
		}
		if (nl > nr)break;
		int wr = MaxRMQ(nl, nr);
		if (wr == nr)break;
		else nl = nr + 1, nr = wr;
	}
	nr = MaxRMQ(1, x);
	nl = MinRMQ(x, nr);
	//puts("two:");
	while (1){
		//printf("%d %d\n", nl, nr);
		for (int i = nl; i <= nr; i++){
			for (int j = 0; j < b[i].size(); j++){
				if (b[i][j] < x)vis[b[i][j]] = 1;
			}
		}
		if (nl > nr)break;
		int wl = MinRMQ(nl, nr);
		if (wl == nl)break;
		else nr = nl - 1, nl = wl;
	}
	for (int i = 1; i <= n; i++){
		if (vis[i])stat.push_back(i);
	}
	for (int i = 0; i < stat.size(); i++){
		if(stat[i] != x)printf("%d ", stat[i]);
	}
	puts("");
	return 0;
}
```


---

## 作者：shinzanmono (赞：4)

# \[省选联考 2023 D1T1\] 火车站

#### 纪念一下第一次省选！

## 此处用「一步」表示「一站」！

看到题目，有一种图论的感觉……

废话不多说。

对于一个点是否可以向 $n$ 点走，取决于经过他的铁路上是否有可以继续往右走的铁路。

同理，对于一个点是否可以向 $1$ 点走，取决于经过他的铁路上是否有可以继续往左走的铁路。

而小 A 能到达的点取决于该点是否有铁路不能继续往下走：

于是我们继续简化条件：

对于任意的 $x\in[1,n]$，如果能从 $x$ 向左走一步，那么必然存在一条铁路 $p$ 使得 $l_p\not=x$，如果能从 $x$ 向右走一步，那么必然存在一条铁路 $p$ 使得 $r_p\not=x$。

小 A 向 $1$ 走能到达某个点 $x$（注意不是经过）的充要条件是存在一条经过 $x$ 的铁路 $p$ 使得 $l_p=x$，向 $n$ 走能到达某个点 $x$ 的充要条件是纯在一条经过 $x$ 的铁路 $p$ 使得 $r_p=x$。

看下数据范围，$n,m\leq2\times10^5$，我们考虑找到结点然后丢进 `set` 里，进行去重排序，这是 $O(n\log n)$ 的，如果你用桶排序，那么可以做到 $O(n)$。

对于每个点 $i$，我们维护 $i$ 是否是某些铁路的左端点，是否是某些铁路的右端点，有多少铁路的非右端点经过点 $i$（即有点 $i$ 可以通过几条路向右走一步），有多少铁路的非左端点经过点 $i$（同上）。

对于上面的数组，我们分别命名为：$learr$，$rearr$，$rsarr$，$lsarr$。

对于 $rsarr$ 和 $lsarr$ 我们用差分维护（线段树也行，这题不卡 $\log n$），$learr$ 和 $rearr$ 可以直接赋值维护。

然后考虑贪心搜索：对于一个点，如果他正在向右走，且他能向右走一步，那就向右走一步；如果他正在向左走，且他能向左走一步，那么就向左走一步。如果他正在向左走，且当前节点是一些铁路左端点的所在点，那么这个点就是可达的；如果他正在向右走，且当前节点是一些铁路右端点的所在点，那么这个点就是可达的。

于是我们得到贪心搜索的关键代码：

```cpp
enum dir {ls, rs};
int lsarr[sz], rsarr[sz], rearr[sz], learr[sz], ans[sz], n, m;
void dfs(int s, int d) {
    if (s < 1 || s > n) return;
    if (d == ls && learr[s] == 1) ans[s] = 1;
    if (d == ls && lsarr[s] != 0) dfs(s - 1, d);
    if (d == rs && rearr[s] == 1) ans[s] = 1;
    if (d == rs && rsarr[s] != 0) dfs(s + 1, d);
}
```

然后维护四个序列的代码：

```cpp
for (int i = 1; i <= m; i++) {
    std::cin >> r[i].l >> r[i].r;
    rearr[r[i].r] = 1, learr[r[i].l] = 1;
    rsarr[r[i].l]++, rsarr[r[i].r]--;
    lsarr[r[i].l + 1]++, lsarr[r[i].r + 1]--;
}
for (int i = 1; i <= n; i++)
    rsarr[i] += rsarr[i - 1], lsarr[i] += lsarr[i - 1];
```

最后是总代码：

```cpp
#include<iostream>
#include<algorithm>
const int sz = 2e5 + 10;
struct railway {
    int l, r;
} r[sz];
enum dir {ls, rs};
int lsarr[sz], rsarr[sz], rearr[sz], learr[sz], ans[sz], n, m;
void dfs(int s, int d) {
    if (s < 1 || s > n) return;
    if (d == ls && learr[s] == 1) ans[s] = 1;
    if (d == ls && lsarr[s] != 0) dfs(s - 1, d);
    if (d == rs && rearr[s] == 1) ans[s] = 1;
    if (d == rs && rsarr[s] != 0) dfs(s + 1, d);
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int s;
    std::cin >> n >> m >> s;
    for (int i = 1; i <= m; i++) {
        std::cin >> r[i].l >> r[i].r;
        rearr[r[i].r] = 1, learr[r[i].l] = 1;
        rsarr[r[i].l]++, rsarr[r[i].r]--;
        lsarr[r[i].l + 1]++, lsarr[r[i].r + 1]--;
    }
    for (int i = 1; i <= n; i++)
        rsarr[i] += rsarr[i - 1], lsarr[i] += lsarr[i - 1];
    if (s != 1) dfs(s, ls);
    if (s != n) dfs(s, rs);
    for (int i = 1; i <= n; i++) {
        if (i == s) continue;
        if (ans[i] == 1) std::cout << i << " ";
    }
    return 0;
}
```

总共 36 行，应该是比较短的写法了吧。

### ~~赛后听到有人拿双指针做，不知道是如何做的，还望各位佬不吝赐教！~~

---

## 作者：zymooll (赞：4)

### 题目大意

在一个数轴上，有 $n$ 个点和 $m$ 个线段，当线段重合（包括端点）时，可以从一个线段转到另外一个线段，求出从点 $x$ 出发，能够到达的线段端点.

### 思路简述

参考染色问题，故对于每次操作，即相当于在数轴上涂色，又因为在各个点可以更换线段，所以只需要用一种颜色上色，特别注意，本题要为线段涂色而不是对点涂色.

又因为题目要求求线段端点，所以对于每个线段的端点，将左右端点分别打上不同的标记，最后查询时，从 $x$ 向左出发查询带左端点标记的点，同时，从 $x$ 向右出发查询带右端点标记的点，排序后输出，注意查询时要求点之间的线段联通.

### 算法选择

本题为多次修改之后接一次查询，故我们可以采用修改复杂度 $O(1)$，查询复杂度 $O(n)$ 的差分算法.

对于最后查询，向左查询时可以获得从大到小的答案，故可以倒序输出，向右查询时可以获得从小到大的答案，所以可以直接输出，此处可以减少一次排序操作.

### 参考代码

```cpp
int n,m,x;
int qzh[200010];
int cf[200010];
int flag[200010];//01:L 10:R 11:L+R
const int L=1,R=2;
int ansl[200010],ansr[200010];
int cntl,cntr;
signed main(){
	n=read(),m=read(),x=read();
	for(int i=1;i<=m;i++){
		int l=read(),r=read();
		flag[l]|=L;
		flag[r]|=R;
		cf[l]++,cf[r]--;
	}
	for(int i=1;i<=n;i++){
		qzh[i]=qzh[i-1]+cf[i];
	}
	//to 1
	for(int i=x-1;i>=1;i--){
		if(!qzh[i])break;
		if(flag[i]&L)ansl[++cntl]=i;
	}
	//to n
	for(int i=x+1;i<=n;i++){
		if(!qzh[i-1])break;
		if(flag[i]&R)ansr[++cntr]=i;
	}
	for(int i=cntl;i>=1;i--){
		print(ansl[i]),putchar(' ');
	}
	for(int i=1;i<=cntr;i++){
		print(ansr[i]),putchar(' ');
	}
	return 0;
}
```

### 注释

为排版整洁，参考代码中略去了快读快写和头文件.

本文所指差分查询复杂度指查询预处理的复杂度，预处理后查询复杂度为 $O(1)$.

算法时间复杂度 $O(n+m)$.

本人为云省选，题解有不周到敬请谅解！

大概是最优解吧，66 ms [Link](https://www.luogu.com.cn/record/107782812).

---

## 作者：Anaxagoras (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P9166)

### 0x01 思路

我们可以让轨道连续，这样我们从起点向左和右搜下去，存下端点即可。

具体实现：先将轨道按左端点从小到大排序，然后往后搜。要往后搜，需要满足左端点在已到达最后的站台之前，存下右端点。

然后将轨道按右端点从大到小排序，然后同理往前搜。

### 0x02 AC Code
```cpp
//by olkieler
#include <bits/stdc++.h>
#define int long long
#define linf LLONG_MAX
#define iinf INT_MAX
#define ios ios::sync_with_stdio(0);cin.tie(0);
#define N 200005
#define M 200005
#define mod 1000000007
#define pint pair<int, int>
#define mp make_pair
#define fi first
#define se second
using namespace std;
inline int r(){int x;cin >> x;return x;}
inline void w(int x){cout << x << '\n';}
inline void W(int x){cout << x << ' ';}
pint a[N];
bool ans[N];
signed main()
{
    ios;
    int n = r(), m = r(), x = r();
    for (int i = 1; i <= m; i ++)
      {
        a[i].fi = r();
        a[i].se = r();
      }
    sort(a + 1, a + m + 1);
    for (int i = 1, ls = x; i <= m && a[i].fi <= ls; i ++)
      {
        if (a[i].se > x)
          {
            ls = max(a[i].se, ls);
            ans[a[i].se] = 1;
          }
      }//往前
    sort(a + 1, a + m + 1, [](pint x, pint y){return x.se > y.se;});
    for (int i = 1, ls = x; i <= m && a[i].se >= ls; i ++)
      {
        if (a[i].fi < x)
          {
            ls = min(a[i].fi, ls);
            ans[a[i].fi] = 1;
          }
      }//往后
    for (int i = 1; i <= n; i ++)
      {
        if (ans[i])
          {
            W(i);
          }
      }
    cout << '\n';
    return 0;
}

```

---

## 作者：wangjiajian (赞：3)

# [P9166 省选联考 2023 火车站](https://www.luogu.com.cn/problem/P9166)

## 题目大意
给定 $n$ 个点、$m$ 条线段和出发点 $x$

任意选择经过出发点的一条线段。到达一条线段后，可以选择去到另一与该线段有重合区间的线段，也可以选择去到该线段的终点。到达另一线段后，重复这种操作。

注意：方向不能变。如一开始是沿着该线段向左走，则到达另一线段后也只能向左走。

问：最终可以到达哪几个点？

## 解题思路
可以分开为两部分进行处理（出发点左边和出发点右边），分别遍历一遍。

1. 如果该点无任何线段覆盖，则退出遍历。这样就可以保证，已经遍历到的点，必然可以从出发点经过若干线段到达。

2. 这样如果该点为一条线段的终点，则可以到达。

## 题解代码
```cpp
#include <bits/stdc++.h>
#define N (int)(2e5+5)
using namespace std;

bool vis[N];  // 记录该点可否到达，便于输出
int n, m, x, l, r, lcnt, rcnt;
// lcnt 是目前覆盖该点的线段数量（左边），rcnt 是右边
vector<bool> station[N];  // 用以记录该点是否有线段端点

int main() {
	scanf("%d%d%d", &n, &m, &x);
	for(int i=1; i<=m; i++) {
		scanf("%d%d", &l, &r);
		station[l].push_back(1);  // 该点是线段左端点
		station[r].push_back(0);
		if(l<x && r>=x)  lcnt++;  // 从出发点向左线段数
		if(l<=x && r>x)  rcnt++;
	}
	for(int i=x-1; i>=1; i--) {
		for(bool j: station[i]) {
			if(j == 1) {  // 该点是线段左端点，则线段数量减少，并记为可以到达
				vis[i] = true;
				lcnt--;
			} else  // 该点是线段右端点，则覆盖的线段增加
				lcnt++;
		}
		if(lcnt == 0)  // 该点后无线段覆盖
			break;
	}
	for(int i=x+1; i<=n; i++) {
		for(bool j: station[i]) {
			if(j == 0) {
				vis[i] = true;
				rcnt--;
			} else
				rcnt++;
		}
		if(rcnt == 0)
			break;
	}
	for(int i=1; i<=n; i++) {
		if(vis[i] == true)
			printf("%d ", i);
	}
	puts("");
	return 0;
}
```


---

## 作者：xcrr (赞：3)

分析题意，我们可以发现一个做法：
* 每个点记录两个数 $l,r$，$l$ 代表覆盖这个节点的所有区间的左端点中，距离最远（最左）的一个，$r$ 代表覆盖它的所有区间的右端点中，距离最远（最右）的一个。
* 我们从 $x$ 出发，分别做向左走到头和向右走到头的情况。我用向左走举例：我们从 $x$ 一个一个向左扫，维护一个数 $t$，代表当前走过的节点更换若干次轨道，能到达最远（最左）点的编号。每个节点都有可能导致 $t$ 的更新：
  
设当前节点为 $now$，如果 $l_{now} < t$，那么更新 $t=l_{now}$。

这个不难理解。首先，我们可以发现，我们的路程中，要想到一个节点，从起点到这个节点之间的所有节点都要走过；又因为我们能到 $now$ 点，从 $now$ 最远能到 $l_{now}$ 点，如果 $l_{now}<t$，就意味着从起点 $x$ 最远能到 $l_{now}$ 点而不再是 $t$ 点，那么就需要用这个点更新 $t$。

* 只要我们没有走到 $t$，我们就一直走，因为一定能走，边走边进行上述更新。因为所有的 $l_{now}$ 构成了终点站的集合，记录下它们，就是答案。
* 向右走的情况同理。整个模拟的过程时间复杂度是 $O(n)$。
* 现在我们要求 $l,r$，发现更改产生于读入区间时，而且不过是区间更改最大最小值的操作。我的做法是用线段树。时间复杂度 $O(m\log n)$。

线段树代码量略大，但是很好想。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N=2e5+10;
int nl[N],nr[N];
int n,m,x;
const int inf=0x3f3f3f3f;
struct nod{
    int l,r,lazy,mx;
}tl[N<<2];
struct nod2{
    int l,r,lazy,mn;
}tr[N<<2];
void lpushdown(int x)
{
    int lz=tl[x].lazy;
    tl[x].lazy=0;
    int l=(x<<1),r=(x<<1|1);
    tl[l].lazy=max(tl[l].lazy,lz);
    tl[l].mx=max(tl[l].mx,lz);
    tl[r].lazy=max(tl[r].lazy,lz);
    tl[r].mx=max(tl[r].mx,lz);
}
void rpushdown(int x)
{
    int lz=tr[x].lazy;
    tr[x].lazy=inf;
    int l=(x<<1),r=(x<<1|1);
    tr[l].lazy=min(tr[l].lazy,lz);
    tr[l].mn=min(tr[l].mn,lz);
    tr[r].lazy=min(tr[r].lazy,lz);
    tr[r].mn=min(tr[r].mn,lz);
}
void lbuild(int id,int l,int r)
{
    tl[id].l=l,tl[id].r=r;
    if(l==r)return;
    int mid=l+r>>1;
    lbuild(id<<1,l,mid);
    lbuild(id<<1|1,mid+1,r);
    tl[id].mx=max(tl[id<<1].mx,tl[id<<1|1].mx);
}
void rbuild(int id,int l,int r)
{
    tr[id].l=l,tr[id].r=r;tr[id].lazy=tr[id].mn=inf;
    if(l==r)return;
    int mid=l+r>>1;
    rbuild(id<<1,l,mid);
    rbuild(id<<1|1,mid+1,r);
    tr[id].mn=min(tr[id<<1].mn,tr[id<<1|1].mn);
}
void updl(int l,int r,int id,int d)
{
    if(tl[id].l>=l&&tl[id].r<=r){tl[id].mx=max(tl[id].mx,d),tl[id].lazy=max(tl[id].lazy,d);return;}
    lpushdown(id);
    int mid=tl[id].l+tl[id].r>>1;
    if(l<=mid)updl(l,r,id<<1,d);
    if(r>mid)updl(l,r,id<<1|1,d);
    tl[id].mx=max(tl[id<<1].mx,tl[id<<1|1].mx);
}
void updr(int l,int r,int id,int d)
{
    if(tr[id].l>=l&&tr[id].r<=r){tr[id].mn=min(tr[id].mn,d),tr[id].lazy=min(tr[id].lazy,d);return;}
    rpushdown(id);
    int mid=tr[id].l+tr[id].r>>1;
    if(l<=mid)updr(l,r,id<<1,d);
    if(r>mid)updr(l,r,id<<1|1,d);
    tr[id].mn=min(tr[id<<1].mn,tr[id<<1|1].mn);
}
void askl(int id)
{
    if(tl[id].l==tl[id].r)
    {
        nl[tl[id].l]=tl[id].mx;
        return;
    }lpushdown(id);
    askl(id<<1);
    askl(id<<1|1);
}
void askr(int id)
{
    if(tr[id].l==tr[id].r)
    {
        nr[tr[id].l]=tr[id].mn;
        return;
    }rpushdown(id);
    askr(id<<1);
    askr(id<<1|1);
}
int main()
{
    cin>>n>>m>>x;
    lbuild(1,1,n);
    rbuild(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        cin>>u>>v;
        updl(u+1,v,1,u);
        updr(u,v-1,1,v);
    }
    askl(1),askr(1);
    if(nl[x]==0&&nr[x]==inf)return 0;
    set<int>ans;
    if(nl[x]!=0)ans.insert(nl[x]);
    if(nr[x]!=inf)ans.insert(nr[x]);
    int mn=nl[x];
    if(mn!=0)
    for(int i=x-1;i>=mn;i--)
    {
        if(nl[i]!=0)
        ans.insert(nl[i]);
        if(nl[i]!=0)
        mn=min(mn,nl[i]);
    }
    int mx=nr[x];
    if(mx!=inf)
    for(int i=x+1;i<=mx;i++)
    {
        if(nr[i]!=inf)
        ans.insert(nr[i]);
        if(nr[i]!=inf)
        mx=max(mx,nr[i]);
    }
    for(auto cc:ans)if(cc!=x)cout<<cc<<' ';
}

```

---

## 作者：Phartial (赞：3)

可以发现，由于一条车轨是连续的一段，所以我们最后能到达的位置也应该是连续的。

于是考虑求我们向左和向右最远能走到哪里，以下只求解最右端，最左端同理。

考虑把车轨按左边界排序，那么对于当前的车轨，我们只想要知道它能不能接在之前的车轨上，即这些车轨是否有公共部分，考虑维护最右能走到的位置，直接看当前的左边界是不是位于最右端之前即可。

由于左边界有单调性，所以若一个车轨选不了了，那么后面的车轨必定都选不了了，换句话说，后面的车轨必定在前面的车轨之后选择，这就保证了正确性。

一个细节：我们能到的第一个车轨应当能够覆盖 $x$。

一个坑点：我们不能待在原来的车站，所以只有终点不在当前点的车轨才能记录终点。

```cpp
#include <algorithm>
#include <iostream>

using namespace std;
using Pii = pair<int, int>;

const int kN = 2e5 + 1;

int n, m, x;
Pii a[kN];
bool v[kN];

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> x;
  for (int i = 1; i <= m; ++i) {
    cin >> a[i].first >> a[i].second;
  }
  sort(a + 1, a + m + 1);
  for (int i = 1, mr = x; i <= m && a[i].first <= mr; ++i) {  // 向右不断扩张
    if (a[i].second > x) {
      mr = max(mr, a[i].second);
      v[a[i].second] = 1;
    }
  }
  sort(a + 1, a + m + 1, [](Pii i, Pii j) { return i.second > j.second; });
  for (int i = 1, ml = x; i <= m && a[i].second >= ml; ++i) {  // 向左不断扩张
    if (a[i].first < x) {
      ml = min(ml, a[i].first);
      v[a[i].first] = 1;
    }
  }
  for (int i = 1; i <= n; ++i) {
    if (v[i]) {
      cout << i << ' ';
    }
  }
  return 0;
}
```

---

## 作者：Xy_top (赞：3)

作为联合省选的第一题还是十分良心的，VP 时 $15$ 分钟爆杀了。

首先这题有个显然的结论就是：如果你从 $s$ 坐火车到 $t$ 了，那么 $s$ 到 $t$ 中的所有铁轨都可以切换到，因为是一站一站走的。

接着发现有一个特殊性质 A，这是帮助我们推导出正确答案的。
考虑特殊性质 A 的做法，先把所有铁路按照左端点排序，然后另 $r$ 为最远能到的节点，初始时为 $1$。

第 $i$ 轮我们取出第 $i$ 个铁轨，看下这个铁轨的左端点 $l$ 是否 $\leq r$，如果是，那么这个铁轨可能会坐到，``set`` 中把铁轨的右端点放进去，并且最远可达点 $r$ 更新一下。最后输出 ``set`` 中的所有元素就行了。

现在再来考虑一般情况，我们把起点左边的铁轨忽略算一下，不就是特殊性质吗？起点右边的忽略一下，就相当于起点为 $n$，和刚刚的做法相反一下就行，于是这题就解决了。

代码：（虽然长但是它大部分都可以复制啊！）

```cpp
#include <set>
#include <iostream>
#include <algorithm>
using namespace std;
int n, m, x, k;
int l, r = 1;
struct Node {int l, r;}a[200005], b[200005];
bool cmp (Node n1, Node n2) {return n1.l < n2.l;}
bool cmp1 (Node n1, Node n2) {return n1.r > n2.r;}
set <int> s;
int main () {
	cin >> n >> m >> x;
	for (int i = 1; i <= m; i ++) cin >> a[i].l >> a[i].r;
	sort (a + 1, a + m + 1, cmp);
	if (x == 1) {
		for (int i = 1; i <= m; i ++) {
			if (a[i].l <= r) {
				s.insert (a[i].r);
				r = max (r, a[i].r);
			}
		}
		set <int>::iterator it;
		for (it = s.begin (); it != s.end (); it ++) cout << *it << " ";
		return 0;
	}
	else {
		for (int i = 1; i <= m; i ++) if (a[i].r >= x) b[++ k] = a[i];
		r = x;
		sort (b + 1, b + k + 1, cmp);
		for (int i = 1; i <= k; i ++) {
			if (b[i].l <= r && b[i].r != x) {
				s.insert (b[i].r);
				r = max (r, b[i].r);
			}
		}
		l = x;
		k = 0;
		for (int i = 1; i <= m; i ++) {
			if (a[i].l <= x) b[++ k] = a[i];
		}
		sort (b + 1, b + k + 1, cmp1);
		for (int i = 1; i <= k; i ++) {
			if (l <= b[i].r && b[i].l != x) {
				s.insert (b[i].l);
				l = min (l, b[i].l);
			}
		}
		set <int>::iterator it;
		for (it = s.begin (); it != s.end (); it ++) cout << *it << " ";
	}
	return 0;
}
```


---

## 作者：HYdroKomide (赞：1)

参加省选祭，写篇题解纪念一下（~~话说是我校首位参加省选的学生呢~~）

签到题，考场上很激动，于是曲线救国。

### 题意：

线段上有 $n$ 个点，给定一些可能重合的铁路，求到 $x$ 有不中断铁路线段路径的点中，在 $x$ 前的铁路起点与在 $x$ 后的铁路终点。

### 思路：

观察到 $n$ 并不大，因此可以使用 $O(n)$ 求解。先判断一个点与前后哪些点有线段相连，用并查集维护，求出每个点所在的集合，最后将起始位置 $x$ 向前后移动，找到所有可能到达的点。具体地：

首先将铁路以左端点为关键字从小到大排序。

对于一段铁路，将它经过的所有点放入路径左端点所在的集合中，然后更新当前集合的最右端点 $r$。对于下一段铁路，若其左端点在 $r$ 右，则新开一个集合。否则直接跳到当前已经分配集合的终点位置 $cnt$，继续向后分配集合到该铁路右端点。

最后，从 $x$ 点向前找同一集合中的铁路左端点，向后找同一集合中的铁路右端点即可。

显然，要加强的话，可以把 $n$ 调大，强制离散化，同时 ban 了这类做法。

### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=2e5+1;
struct RAIL{int l,r;}a[N];
int n,m,x,f[N],sta[N],bel[N],cnt,ans[N],lst[N];
bool cmp(RAIL x,RAIL y){return x.l==y.l?x.r<y.r:x.l<y.l;}
int fnd(int x){
    if(f[x]==x)return x;
    return f[x]=fnd(f[x]);
}
int main(){
    scanf("%d%d%d",&n,&m,&x);
    for(int i=1;i<=m;i++)scanf("%d%d",&a[i].l,&a[i].r);
    sort(a+1,a+m+1,cmp);
    for(int i=1;i<=m;i++)f[i]=i;
    for(int i=1;i<=m;i++){
        if(a[i].l<=lst[f[i-1]]&&i>1)f[i]=fnd(f[i-1]);//判断是否超出上一个集合
        lst[f[i]]=max(lst[f[i]],a[i].r);
        cnt=max(cnt,a[i].l);
        for(int j=cnt;j<=a[i].r;j++)bel[j]=f[i];//从cnt向后给每个点分配所在集合
        cnt=max(cnt,a[i].r+1);
        sta[a[i].l]|=1,sta[a[i].r]|=2;//记录铁路左右端点
    }
    int blk=bel[x];
    cnt=0;
    for(int i=x+1;i<=n;i++)//遍历x后
        if(bel[i]==blk&&(sta[i]&2)!=0)
            ans[++cnt]=i;
    for(int i=1;i<x;i++)//遍历x前
        if(bel[i]==blk&&(sta[i]&1)!=0)
            ans[++cnt]=i;
    sort(ans+1,ans+cnt+1);
    for(int i=1;i<=cnt;i++)printf("%d ",ans[i]);
    puts("");
    return 0;
}
```

### THE END

---

## 作者：huangrenheluogu (赞：1)

~~真没想到省选还有水题。~~

左右很明显是一样的，$n \le 2 \times 10^5$，直接模拟好了。

存储答案？用 $ans$ 存储一下就可以了。

我以右边为例。

- 维护左端点单调递增。

- 一个一个点枚举可以到达的点。

- 尺取法判断是否需要更新端点。

我用 $back$ 变量代表可以到达的最右端点。

```cpp
inline bool cmp1(data x, data y){return x.l < y.l;}

//下面是main里的内容
sort(a + 1, a + m + 1, cmp1);
back = x;
for(i = 1; i <= n; i++){//找到最右边的back
	if(a[i].l <= x && x < a[i].r) back = max(back, a[i].r), ans[a[i].r] = 1;
	if(a[i].l > x) break ;
}
for(int j = x + 1; j <= back; j++){
	while(a[i].l <= j && i <= m){
		if(a[i].r >= j){
			back = max(back, a[i].r);//注意更新back
			ans[a[i].r] = 1;
		}
		i++;
	}
}
```

然后，左边同理。

`Code`:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int n, m, x, back, tot, i;
bool ans[N];
struct data{int l, r;}a[N];
inline bool cmp1(data x, data y){return x.l < y.l;}
inline bool cmp2(data x, data y){return x.r > y.r;}
int main(){
//	freopen("station.in","r",stdin);
//	freopen("station.out","w",stdout);
	scanf("%d%d%d", &n, &m, &x);
	for(int j = 1; j <= m; j++) scanf("%d%d", &a[j].l, &a[j].r);
	
	sort(a + 1, a + m + 1, cmp1);
	back = x;
	for(i = 1; i <= n; i++){
		if(a[i].l <= x && x < a[i].r) back = max(back, a[i].r), ans[a[i].r] = 1;
		if(a[i].l > x) break ;
	}
	for(int j = x + 1; j <= back; j++){
		while(a[i].l <= j && i <= m){
			if(a[i].r >= j){
				back = max(back, a[i].r);
				ans[a[i].r] = 1;
			}
			i++;
		}
	}
	
	sort(a + 1, a + m + 1, cmp2);
	back = x;
	for(i = 1; i <= m; i++){
		if(a[i].r >= x && a[i].l < x) back = min(back, a[i].l), ans[a[i].l] = 1;
		if(a[i].r < x) break ;
	}
	for(int j = x - 1; j >= back; j--){
		while(a[i].r >= j && i <= m){
			if(a[i].l <= j){
				back = min(back, a[i].l);
				ans[a[i].l] = 1;
			}
			
			i++;
		}
	}
	for(i = 1; i <= n; i++) if(ans[i]) printf("%d ",i);
	return 0;
} 
```

---

## 作者：novax (赞：1)

提供一种线性做法。

[题目链接](https://www.luogu.com.cn/problem/P9166)

#### 思路

下文称一座车站可达，当且仅当存在火车行驶方案可以在经过车站 $X$ 后经过这座车站。

任何火车经过车站 $X$ 前的行程都无关答案，不妨令所有火车都从 $X$ 出发。

对于所有跨过起点车站 $X$ 的轨道，其整条轨道上的所有车站都是可达的，且其轨道的两端点都是合法的终点站，可以直接将其端点加入答案。

因为火车不能转向，因此对于所有不经过车站 $X$ 的轨道，只有其远离 $X$ 一端的终点车站才有可能从 $X$ 出发通过改变轨道到达作为合法的终点站。

对于一条不经过车站 $X$ 的轨道，我们考虑其是否可以被可经过 $X$ 的火车到达：当且仅当这条轨道靠近车站 $X$ 一端的车站可达，整条轨道上的所有车站都可达。

简单证明：所有可达车站为车站序列的一个包含车站 $X$ 的连续子区间，而整条轨道靠近 $X$ 一端的车站是该轨道上距离 $X$ 最近的车站，如果 $X$ 不可达，则这条轨道上一定不存在任何可达的车站。

若一条轨道的近 $X$ 端车站可达，则整条铁路覆盖的车站都可达。

则对于不覆盖车站 $X$ 的轨道，我们只需要维护其近 $X$ 端车站是否可达，如果可达则这条轨道的所有车站也都是可达的。

#### 实现

所有可达的车站是一个连续区间，所以只需要维护当前可达区间的左右端点即可。

右端点在 $X$ 左侧的轨道不会对 $X$ 右侧的答案产生影响，左端点在 $X$ 右侧的轨道也不会对 $X$ 左侧的答案产生影响。因此对于以上两种情况分开考虑。

初始时记录了所有直接覆盖 $X$ 的轨道，此时可达区间的左/右端点分别是这些轨道左端点的最小值和右端点的最大值。

对于 $X$ 左侧的轨道，将其按照右端点从大到小排序，然后从 $X$ 开始右向左依次遍历所有车站：如果当前车站可达，则将当前车站为右端点的轨道全部可达，将这些轨道的左端点加入答案，并将可达区间的左端点与这些区间的左端点取最小值；如果当前车站不可达，则所有右端点在当前点及当前点左侧的轨道上都不存在可达车站，那么就不需要继续做下去了。

右侧与左侧同理。

由于火车站编号的值域是 $1\sim n$，所以可以对每个车站开一个 ``vector`` 或链表记录以这座车站作为靠近 $X$ 的一端的轨道编号，这样就省去了排序的时间消耗。

记录每个点是否可以作为合法的终点站，最后输出即可。

#### 代码
```cpp
#include <cstdio>
#include <vector>
const int Nx=200010;
int N,M,X,L[Nx],R[Nx],vis[Nx];
std::vector<int> id[Nx];
int main()
{
	scanf("%d%d%d",&N,&M,&X);
	int i,ll=X,rr=X;
	for(i=1;i<=M;i++)
	{
		scanf("%d%d",&L[i],&R[i]);
		if(L[i]<=X&&R[i]>=X)
		{
			vis[L[i]]=vis[R[i]]=1;
			ll=std::min(ll,L[i]),rr=std::max(rr,R[i]);
		}
		if(R[i]<X) id[R[i]].push_back(i);
		if(L[i]>X) id[L[i]].push_back(i);
	}
	for(i=X-1;i>=1;i--)
	{
		if(ll>i) break;
		for(auto ax : id[i])
			ll=std::min(ll,L[ax]),vis[L[ax]]=1;
	}
	for(i=X+1;i<=N;i++)
	{
		if(rr<i) break;
		for(auto ax : id[i])
			rr=std::max(rr,R[ax]),vis[R[ax]]=1;
	}
	for(i=1;i<=N;i++)
		printf((vis[i]&&i!=X)?"%d ":"",i);
}
```


---

## 作者：许多 (赞：0)

##  前言

差分好题，然而放在省选貌似水了点。

考场写挂了，但我们要永远相信：~~CCF 用脚造数据~~。

## 正文

维护一个序列，对于每一条轨道，我们将覆盖区间加一。这个很显然可以用差分维护。

最后我们从 $x$ 向左右两边跑就可以了。

## 注意事项


对于一段轨道的末端，如果没有其他火车轨道覆盖，则不能换轨道继续前行。~~本蒟蒻就是这里写挂了~~。

我们用数据说话：

当有两段轨道为：

```
1 2
3 4
```
很显然从 1 出发只能走到 2，但我们维护的序列并没有出现 0。所以我们需要特判一下。

# 代码

```cpp
#include<bits/stdc++.h>
#include<cstdio>
#define N 300000
#define LL int
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
LL n,m,x;
LL a[N],l[N],r[N];
LL ans[N];
int main(){
    //freopen("station.in","r",stdin);
    //freopen("station.out","w",stdout);
    n=read();m=read();x=read();
    for(LL i=1;i<=m;i++){
        LL L=read(),R=read();
        l[L]++,r[R]++;
        a[L]--;a[R+1]++;
    }
    for(LL i=1;i<=n;i++){
        a[i]=a[i-1]-a[i];
        //printf("%d ",a[i]);
    }
    if(!a[x])return 0;
    for(LL i=x-1;i>=1;i--){
        if(!a[i]||(a[i]==r[i]))break;//特判
        if(l[i])ans[++ans[0]]=i;
    }
    for(LL i=x+1;i<=n;i++){
        if(!a[i]||(a[i]==l[i]))break;
        if(r[i])ans[++ans[0]]=i;
    }
    sort(ans+1,ans+1+ans[0]);
    for(LL i=1;i<=ans[0];i++)
        printf("%d ",ans[i]);
    return 0;
}
```


---

## 作者：千早爱音 (赞：0)

因为考场的时候不会正解，所以提供一种暴力做法。

首先两个有交点的区间合并之后显然还是连续，因此考虑分别维护向左走和向右走的答案。

不断暴力扫描所有区间，对于一个区间，如果能与当前区间合并且不完全位于当前区间的右边则合并区间，然后将区间端点加入答案即可，然后标记此区间，当没有区间被选中则结束，向右走同理。注意初始区间是 $ [x,x] $，而 $ x $ 不能被加入答案。

这么做的时间复杂度最差是 $ \mathcal{O}(m^2) $ 的，但是随机数据跑不满可以通过。hack 数据可以直接构造一堆长度为 $ 2 $ 的区间。

考场代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int now=0;
    char ch=getchar();
    while(!isdigit(ch))
    ch=getchar();
    while(isdigit(ch))
    now=now*10+ch-'0',ch=getchar();
    return now;
}
vector<int>ans;
const int maxn=2e6+10;
int l[maxn],r[maxn],n,m,x;
bool vis[maxn];
int query_merge(int l1,int l2,int r1,int r2)
{
    return (min(r1,r2)-max(l1,l2)>=0);
}
int vis2[maxn];
void add(int k)
{
        if(k==x)
        return;
    if(!vis2[k])
    ans.push_back(k),vis2[k]=1;
}
void calc_left()
{
    bool ok=1;
    int nowl=x,nowr=x;
    while(ok)
    {
        ok=0;
        for(int i=1;i<=m;i++)
        if(!vis[i])
        {
            if(query_merge(nowl,l[i],nowr,r[i]))
            nowl=min(nowl,l[i]),add(l[i]),vis[i]=1,ok=1;
        }
    }
}
void calc_right()
{
    memset(vis,0,sizeof vis);
    bool ok=1;
    int nowl=x,nowr=x;
    while(ok)
    {
        ok=0;
        for(int i=1;i<=m;i++)
        if(!vis[i])
        {
            if(query_merge(nowl,l[i],nowr,r[i]))
            nowr=max(nowr,r[i]),add(r[i]),vis[i]=1,ok=1;
        }
    }
}
main()
{
        //freopen("station.in","r",stdin);
        //freopen("station.out","w",stdout);
    n=read(),m=read(),x=read();
    for(int i=1;i<=m;i++)
    l[i]=read(),r[i]=read();
    calc_left();
    calc_right();
    sort(ans.begin(),ans.end());
    for(auto x:ans)
    cout<<x<<' ';
}
/*
7 5 4
3 4
4 6
1 3
5 7
4 6
*/
```


---

## 作者：osfly (赞：0)

简单题，但是我考场写炸了。$100\rightarrow70$。

我们读入的时候，先开两个数组 $ls,rs$ 来记录当前这个点是否为某条线段左端点或右端点。

我们发现，每一条线段都是连续的，因此可以直接差分记录当前这个点能否走到。

然后你提交上去发现你能过。

实际上这种做法是假的。

为什么呢？

如果遇到 $[1,2],[3,4]$ 这样的线段，实际上 $1$ 号点是无法到达 $4$ 号点的，但是直接差分是能直接到达。

因此差分的正解是应该处理的时候把下标乘 $2$ 以此来制造空点。

时间复杂度 $O(n)$。

~~为什么有人考场会把这道题写炸啊。~~

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,x;
int cf[200010<<1];
int a[200010<<1];
int ls[200010],rs[200010];
bool vis[200010];
int ans[200010],tot;
int main()
{
    scanf("%d%d%d",&n,&m,&x);
    for(int i=1;i<=m;i++)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        ls[l]=1,rs[r]=1;
        cf[(l<<1)-1]++,cf[r<<1]--;
    }
    for(int i=1;i<=n<<1;i++) a[i]=a[i-1]+cf[i];
    for(int i=(x<<1)-1;i<=n<<1;i++)
    {
        if(a[i]<=0) break;
        if(rs[(i+1)>>1]&&!vis[(i+1)>>1]&&((i+1)>>1)!=x)
        {
            vis[(i+1)>>1]=1;
            ans[++tot]=(i+1)>>1;
        } 
    }
    for(int i=(x<<1)-1;i>=1;i--)
    {
        if(a[i]<=0) break;
        if(ls[(i+1)>>1]&&!vis[(i+1)>>1]&&((i+1)>>1)!=x)
        {
            vis[(i+1)>>1]=1;
            ans[++tot]=(i+1)>>1;
        }
    }
    sort(ans+1,ans+1+tot);
    for(int i=1;i<=tot;i++) printf("%d ",ans[i]);
    return 0;
}
```

---

## 作者：rmzls (赞：0)

### **思路**

废话不多说，我们先看题

我们只需要注意到两个点：

$1.$ 最后到达的车站一定是终点站，即每条轨道的端点，所以我们只需要考虑端点。

$2.$ 车只会一直沿着一条路线走，所以我们可以考虑只向左走的做法，再向右做一次。

再看看数据范围，大概是$n\log n$的做法。因为输入的轨道顺序与答案无关，所以我们可以先给他排个序。


------------
### **做法**

先考虑从左向右的做法：

我们先将轨道左端点按从小到大排序，这样的话枚举每条轨道的时候就可以实现从左到右遍历车站。我们用 $l$ 表示考虑这个轨道的左端点，$r$ 表示考虑这个轨道的右端点。

这样的话轨道可以分为四种：

$1.$ 全轨道都在 $x$ 点左边的，即 $r<x$。这个时候无论如何也到不了这个轨道上（因为是从左往右走），所以可以直接抛弃。

$2.$ 轨道里面包含了 $x$，即 $l\le x\le r$。这个时候可以到达 $r$，所以我们给 $r$ 打上一个能到达的标记。

$3.$ 轨道在 $x$ 的右边，但无法通过转线到达。这个时候我们可以和第一种一样抛弃。

$4.$ 轨道在 $x$ 的右边，但可以通过转线到达。显而易见，这个时候右边端点也能走到，所以我们给 $r$ 打上一个能到达的标记。现在问题来了，怎么区分第三种和第四种？我们发现，假如任意一条 $x$ 能转到的轨道 $p$ 里面包含了我们现在正在考虑的轨道的一部分，我们就能转到这条轨道上。因为我们是从左往右走的，所以我们可以设置一个变量 $rr$，表示我们目前最远能走到的右端点。每一次给 $r$ 打标记的时候令 ```rr=max(rr,r)``` 就可以了。这样当 $l>x$ 的时候，只要 $r\le rr$ 我们就判定它为第四种铁路。

代码如下：
```cpp
for(int i=1;i<=m;i++){
	if(d[i].l<=x){
		if(d[i].r>x){
			is[d[i].r]=1;
			rr=max(rr,d[i].r);
		}
	}
	else if(d[i].l<=rr){
		is[d[i].r]=1;
		rr=max(rr,d[i].r);
	}
}
```
对于从右向左的，只要把上面的反过来就行了。记得初始化 $lr$ 为无限大，每次取 ```min()```。


------------
### **接下来看完整代码吧**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int lr=INT_MAX,rr,x,is[N],n,m;
struct node{
	int l,r;
}d[N];
bool cmp1(node a,node b){
	return a.l<b.l;
}
bool cmp2(node a,node b){
	return a.r>b.r;
}
int main(){
//	freopen("station.in","r",stdin);
//	freopen("station.out","w",stdout);
	scanf("%d%d%d",&n,&m,&x);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&d[i].l,&d[i].r);
		if(d[i].l>d[i].r){
			swap(d[i].l,d[i].r);
		}
	}
	//printf("\n");
	sort(d+1,d+1+m,cmp1);
	for(int i=1;i<=m;i++){
		if(d[i].l<=x){
			if(d[i].r>x){
				is[d[i].r]=1;
				rr=max(rr,d[i].r);
			}
		}
		else if(d[i].l<=rr){
			is[d[i].r]=1;
			rr=max(rr,d[i].r);
		}
	}
	sort(d+1,d+1+m,cmp2);
	for(int i=1;i<=m;i++){
		if(d[i].r>=x){       
			if(d[i].l<x){
				is[d[i].l]=1;
				lr=min(lr,d[i].l);
			}
		}
		else if(d[i].r>=lr){
			is[d[i].l]=1;
			lr=min(lr,d[i].l);
		}
	}
	for(int i=1;i<=n;i++){
		if(is[i]){
			printf("%d ",i);
		}
	}
	return 0;
}
```


---


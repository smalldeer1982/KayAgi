# [COCI 2022/2023 #4] Vrsta

## 题目描述

Domagoj 最喜欢的课是体育课。每节体育课都以热身运动开始。体育老师有一个有趣的方法来选择带领其他同学做热身运动的学生。学生们按身高从低到高的顺序站成一排，老师会选择站在队伍中间的学生。如果有两个学生在中间，他将选择较矮的那个。例如：如果学生的身高为 $1, 3, 5, 7, 11$，身高为 $5$ 的学生将带领其他同学做热身运动。

Domagoj 记不住他同学的身高。幸运的是，站在他旁边的 Lovro 十分擅长估计他人的身高。他给了 Domagoj $n$ 条信息：「有 $a_i$ 个身高为 $v_i$ 的学生进入了体育馆。」在 Lovro 说完每条信息之后，Domagoj 都对带领其他同学做热身运动的那个同学的身高感兴趣。假定所有进入体育馆的同学都是来上体育课的。请帮他回答他的问题！

## 说明/提示

|子任务编号|	附加限制|	分值|
|:-:|:-:|:-:|
| $0$ | 是样例 | $0$ |
| $1$ | $n,v_i\le 1000$ | $17$ |
| $2$ | $a_1=a_2=\ldots=a_n=1$ | $24$ |
| $3$ | $v_1<v_2<\ldots <v_n$ |	$26$ |
| $4$ |	无附加限制 |	$33$ |

## 样例 #1

### 输入

```
3
2 1
3 1
1 1```

### 输出

```
2
2
2```

## 样例 #2

### 输入

```
4
17 2
23 5
11 4
9 5```

### 输出

```
17
23
17
11```

## 样例 #3

### 输入

```
3
10 20
100 5
1000 5```

### 输出

```
10
10
10```

# 题解

## 作者：lwwwb_555 (赞：6)

题目传送门：[P9176](https://www.luogu.com.cn/problem/P9176)

看到 dalao 们都写的平衡树或树状数组，此蒟蒻在这里写一篇线段树的。
# Solution
先将所有人的身高离线下来，构建权值线段树，用线段树记录身高在 $l$ 到 $r$ 内的总人数，对于每一个信息，先将线段树上每一个包括了 $v_i$ 的区间的权值加上 $a_i$，然后再进行查询。

我们可以用 $sum$ 记录从第一条信息到第 $i$ 条信息的总人数，当 $sum \bmod 2=1$ 时查找第 $sum/2+1$ 个人的身高，否则就要找中间的身高较矮的那个人即 $sum/2$ 的身高。

其他的细节详见代码注释。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,btot,ctot;
long long c[200005],bb[200005];
struct node{
	long long v;
	long long a;
}t[200005];
struct nn{
	int ll,rr;
	long long w;
}tt[800005];
void b(int p,int l,int r){
	tt[p].ll=l;
	tt[p].rr=r;
	tt[p].w=0ll;
	if(l==r){
		return;
	}
	int mid=(l+r)>>1;
	b(p*2,l,mid);
	b(p*2+1,mid+1,r);
}
void add(int p,int l,long long k){
	if(tt[p].ll==tt[p].rr){
		tt[p].w+=k;
		return;
	}
	int mid=(tt[p].ll+tt[p].rr)>>1;
	if(l<=mid){
		add(p*2,l,k);
	}else{
		add(p*2+1,l,k);
	}
	tt[p].w=tt[p*2].w+tt[p*2+1].w;
}
int ans=0;
void query(int p,long long l){
	if(tt[p].ll==tt[p].rr){
		ans=tt[p].ll;//已经搜索到叶子节点了,此时将ans更新为离散化后的身高
		return;
	}
	if(l<=tt[p*2].w){//先判断第l个数是否在左区间里,如果在,就直接进入左区间查找,否则就计算第l个数为右区间的第几个,再进入右区间查找
		query(p*2,l);
	}else{
		query(p*2+1,l-tt[p*2].w);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&t[i].v,&t[i].a);
		bb[++btot]=t[i].v;
	}
	sort(bb+1,bb+btot+1);
	for(int i=1;i<=btot;i++){
		if(i==1 || bb[i]!=bb[i-1]){
			c[++ctot]=bb[i];//离散化
		}
	}
	b(1,1,ctot);//建树
	long long sum=0;
	for(int i=1;i<=n;i++){
		int p=lower_bound(c+1,c+ctot+1,t[i].v)-c;//身高在离散化后的值就为p
		add(1,p,t[i].a);
		sum+=t[i].a;
		ans=0;
		if(sum%2ll==1ll){
			query(1,sum/2ll+1ll);
		}else{
			query(1,sum/2ll);
		}
		printf("%lld\n",c[ans]);
	}
	return 0;
}
//不开long long见祖宗
```
蒟蒻的第一篇题解，如有描述得不清楚的地方欢迎各位 dalao 指出，蟹蟹！

---

## 作者：zhangjiting (赞：6)

## 思路

我非常喜欢暴力数据结构，于是我用值域分块通过了这道题。

可以看见 $a_i$ 很大，先离散化一下。$s_i$ 表示当前身高为 $i$ 的人的个数，$sum_i$ 表示值域在第 $i$ 个块的身高的总数。当查询 $k$ 小值时，步步逼近，$k$ 先一块一块地减去 $cnt_{now}$，确定答案的在哪一块，然后，暴力查询这一块，每次减去一个 $s_i$。当 $k \le 0$ 时，我们就找到了 $k$ 小值。本题中，第 $i$ 次操作中，$\lfloor k=\frac{all}{2} \rfloor$，其中，$all=\sum_{j=1}^{i} a_i$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5,M=5e2+5;
int a[N],v[N],tmp[N],belong[N],rt[M],lt[M],block,tot,n,m;
int all,s[N],sum[M];
void build(){
	block=(int)sqrt((double)n);
	tot=n/block;
	if(n%block) tot++;
	for(int i=1;i<=tot;i++){
		lt[i]=(i-1)*block+1;
		rt[i]=i*block;
	}rt[tot]=n;
	for(int i=1;i<=n;i++){
		belong[i]=(i-1)/block+1;
	}
}
void change(int x,int k){
	s[x]+=k;
	sum[belong[x]]+=k;
	all+=k;
}
int ask(int k){
	int now=0;
	while(sum[now]<k){
		k-=sum[now];
		now++;
	}
	for(int i=lt[now];i<=rt[now];i++) {
		k-=s[i];
		if(k<=0) return tmp[i];
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>tmp[i]>>a[i];
		v[i]=tmp[i];
	}
	sort(tmp+1,tmp+n+1);
	int len=unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i=1;i<=n;i++) v[i]=lower_bound(tmp+1,tmp+n+1,v[i])-tmp;
	build();
	for(int i=1;i<=n;i++){
		change(v[i],a[i]);
		cout<<ask((all+1)/2)<<endl;
	}
	return 0;
}
```

---

## 作者：Oracynx (赞：6)

## P9176 [COCI2022-2023#4] Vrsta 题解

### 思路分析

很自然的想到了离散化和线段树二分。

我们先将输入的身高离散化，离散化后的最大值即为 $n$。

我们再建立一个权值线段树，维护区间内的人数，权值为身高。（或者你也可以选择动态开点，这样就不需要离散化了）

对于每一个询问，我们进行单点修改后更新沿途节点。

接着求出中间的人是第几矮的，然后在线段树上二分即可。

线段树上二分代码：

```cpp
int query(int c, int s, int t, long long v)
{
    if (s == t)
    {
        return s;
    }
    int mid = (s + t) / 2;
    if (v <= tree[c * 2])
    {
        return query(c * 2, s, mid, v);
    }
    else
    {
        return query(c * 2 + 1, mid + 1, t, v - tree[c * 2]);
    }
}
```

### 代码实现

注意人数的最大值为 $2 \times 10 ^ 5 \times 10 ^ 9 = 2 \times 10 ^ {14}$，需要使用 `long long`。

```cpp
#include <algorithm>
#include <cstdio>
constexpr int MaxN = 2e5 + 5;
class student
{
  public:
    int h;
    long long cnt;
    student()
    {
        h = 0;
        cnt = 0;
    }
};
int n;
int sl;
int s[MaxN];
student ask[MaxN];
long long tree[MaxN * 4];
inline int link(int x)
{
    return std::lower_bound(s + 1, s + 1 + sl, x) - s;
}
void change(int c, int s, int t, int w, long long v)
{
    if (s == t)
    {
        tree[c] += v;
        return;
    }
    int mid = (s + t) / 2;
    if (w <= mid)
    {
        change(c * 2, s, mid, w, v);
    }
    else
    {
        change(c * 2 + 1, mid + 1, t, w, v);
    }
    tree[c] = tree[c * 2] + tree[c * 2 + 1];
}
int query(int c, int s, int t, long long v)
{
    if (s == t)
    {
        return s;
    }
    int mid = (s + t) / 2;
    if (v <= tree[c * 2])
    {
        return query(c * 2, s, mid, v);
    }
    else
    {
        return query(c * 2 + 1, mid + 1, t, v - tree[c * 2]);
    }
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%lld", &ask[i].h, &ask[i].cnt);
        s[i] = ask[i].h;
    }
    std::sort(s + 1, s + 1 + n);
    sl = std::unique(s + 1, s + 1 + n) - s - 1;
    for (int i = 1; i <= n; i++)
    {
        ask[i].h = link(ask[i].h);
    }
    for (int i = 1; i <= n; i++)
    {
        change(1, 1, n, ask[i].h, ask[i].cnt);
        long long sum = tree[1];
        if (sum % 2 == 1)
        {
            sum = sum / 2 + 1;
        }
        else
        {
            sum = sum / 2;
        }
        printf("%d\n", s[query(1, 1, n, sum)]);
    }
    return 0;
}
```

---

## 作者：slzx2022YuYihan (赞：5)

# Solution

这题其实比较简单，不需要什么平衡树。

首先，离散化是肯定的。处理出所有身高的排名。

然后，我们在询问中二分排名，求出当前排名及以前的学生个数，与中位数进行比较。求和就可以用树状数组来维护，单点修改，区间查询。

总时间复杂度：$O(n\log^2n)$。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
	x = 0; T w = 1; char ch = getchar();
	while (!isdigit(ch)){if (ch == '-')	w = -1; ch = getchar();}
	while (isdigit(ch))	x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	x *= w;
}
template<typename T>inline void write(T x){
	if (x < 0)	putchar('-'), x = ~(x - 1);
	if (x > 9)	write(x / 10);
	putchar(x % 10 ^ 48);
}

const int N = 2e5 + 5;

ll n, a[N], b[N], m, sum, R[N];
struct qry{
	ll gs, hei;
}Q[N];

ll tree[N];
void upd(ll x, ll k){
	for (; x <= n; x += (x & (-x)))
		tree[x] += k;
}
ll que(ll x){
	ll res = 0;
	for (; x; x -= (x & (-x)))
		res += tree[x];
	return res;
}

ll l, r, mid, rk;

int main(){
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

	read(n);
	for (int i = 1; i <= n; ++i)
		read(Q[i].hei), read(Q[i].gs), a[i] = b[i] = Q[i].hei;
	sort(a + 1, a + n + 1);
	m = unique(a + 1, a + n + 1) - (a + 1);
	for (int i = 1; i <= n; ++i)
		Q[i].hei = lower_bound(a + 1, a + m + 1, Q[i].hei) - a, R[Q[i].hei] = b[i];
	for (int i = 1; i <= n; ++i){
		sum += Q[i].gs, upd(Q[i].hei, Q[i].gs);
		l = 1, r = n, rk = 0;
		while (l <= r){
			mid = l + r >> 1;
			if (que(mid) >= ((sum + 1) >> 1))	r = mid - 1, rk = mid;
			else	l = mid + 1;
		}
		write(R[rk]), putchar('\n');
	}

	return 0;
}
```

---

## 作者：Mu_leaf (赞：5)

给大家提供一种 $O(n \log n)$ 的算法，没怎么卡常就到了最优解第一页。

## [思路]
考虑以每个身高作为下标，维护每个身高的数量，很显然不同的身高最多有 $2 \times 10^5$ 个，考虑离散化。

用线段树维护每种身高数量的和，线段树上二分即可，具体细节看代码。

### [细节]

- 考虑到要求的是身高，直接记录一下身高 $x$ 离散化前的数字即可。
- 在线段树叶子结点记录下当前节点代表的身高是多少。

## Code:

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls (x<<1)
#define rs (x<<1|1)
#define mid ((l+r)>>1) 
using namespace std;
inline int read(){
	int f=1,x=0;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+c-48,c=getchar();
	return x*f;
}
const int N=2e5+5;
int n;
struct node{
	int v,a,id;
}a[N];
int ans[N],b[N],tot;
int vis[N];
int tr[N<<2],cnt[N<<2];
void build(int x,int l,int r){
	if(l==r){
		cnt[x]=l;
		return;
	}
	build(ls,l,mid);build(rs,mid+1,r);
}
void change(int x,int l,int r,int k,int v){
	if(l==r){
		tr[x]+=v;
		return;
	}
	if(k<=mid) change(ls,l,mid,k,v);
	else change(rs,mid+1,r,k,v);
	tr[x]=tr[ls]+tr[rs];
}
int query(int x,int l,int r,int k){
	if(l==r){
		return vis[cnt[x]];
	}
	if(tr[ls]<k) return  query(rs,mid+1,r,k-tr[ls]);
	else return query(ls,l,mid,k);
}
signed main(){
// 	freopen("physical.in","r",stdin);
// 	freopen("physical.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=(node){read(),read(),i};
		b[++tot]=a[i].v;
	}
	sort(b+1,b+tot+1);
	int idx=unique(b+1,b+tot+1)-b-1;
	for(int i=1;i<=n;i++){
		int x=a[i].v;
		a[i].v=lower_bound(b+1,b+idx+1,a[i].v)-b;
		vis[a[i].v]=x;
	}
	build(1,1,n);
	int res=0;
	for(int i=1;i<=n;i++){
		change(1,1,n,a[i].v,a[i].a);
		res+=a[i].a;
		cout << query(1,1,n,res/2+res%2) << "\n";
	}
	return 0;
}
/*
3
2 1
3 1
1 1

4
17 2
23 5
11 4
9 5

3
10 20
100 5
1000 5
*/


```

---

## 作者：Flame_HuTao (赞：3)

## 给大家提供一种 $FHQ-Treap$ 的做法
### 题目大意
有 $n$ 次操作，第 $i$ 次操作给出 $v_i$ 和 $a_i$，表示进来 $a_i$ 个身高为 $v_i$ 的人，对于第 $i$ 次操作，将所有人按身高升序排列后问中间那个人的身高。
### 大体思路
题目要求维护一个支持插入的上升序列，一眼丁真考虑用平衡树，支持插入和询问第 $k$ 大值。对于每次操作，只需要插入新节点然后查询 $(size_{root}+1)/2$。
### 细节
由于 $a_i\leq 10^9$ 所以我们不能一个一个插入。于是需要对身高为 $v_i$ 的一起处理。因此，在询问第 $k$ 大值时，当搜到 $cur$ 节点时，如果 $lson_{cur}$ 的大小小于 $k$ 且 $cur$ 的子树大小大于 $k$，就直接返回 $cur$。
### 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long 
#define Maxn 500001 
//不开就会WA
using namespace std;
int read() {
	int f=1,g=0;
	char a=getchar();
	while(a<'0'||a>'9') {
		if(a=='-') f=-1;
		a=getchar();
	}
	while(a<='9'&&'0'<=a) {
		g=(g<<3)+(g<<1)+a-'0';
		a=getchar();
	}
	return f*g;
}
void write(int x) {
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int sz[Maxn],cnt[Maxn],val[Maxn],prio[Maxn],lson[Maxn],rson[Maxn],root,tot;
int NewNote(int k,int w)
{
	val[++tot]=k;
	prio[tot]=rand();
	sz[tot]=w;
	cnt[tot]=w;
	return tot;
}
void pushdown(int x) {
	sz[x]=sz[lson[x]]+sz[rson[x]]+cnt[x];
}
void split(int now,int bound,int &x,int &y)
{
	if(!now) return x=y=0,void();
	if(val[now]<=bound) {
		x=now;
		split(rson[now],bound,rson[now],y);
	}
	else {
		y=now;
		split(lson[now],bound,x,lson[now]);
	}
	pushdown(now);
}
int merge(int x,int y)
{
	if(!x||!y) return x+y;
	if(prio[x]<prio[y]) {
		rson[x]=merge(rson[x],y);
		pushdown(x);
		return x;
	}
	else {
		lson[y]=merge(x,lson[y]);
		pushdown(y);
		return y;
	}
}
void Insert(int k,int w)
{
	int x,y,z=NewNote(k,w);
	split(root,k,x,y);
	root=merge(x,merge(z,y));
}
int randk(int v)
{
	int cur=root,fa=0;
	while(cur&&v) {
		fa=cur;
		if(sz[lson[cur]]<v&&sz[lson[cur]]+cnt[cur]>v)
			return val[cur];
		if(sz[lson[cur]]+cnt[cur]>v)
			cur=lson[cur];
		else {
			v-=sz[lson[cur]]+cnt[cur];
			cur=rson[cur];
		}
	}
	return val[fa];
}
signed main()
{
	srand(time(0));
	int n=read();
	for(int i=1;i<=n;i++)
	{
		int u=read(),w=read();
		Insert(u,w);
		int pre=(sz[root]+1)/2;
		write(randk(pre));
		puts("");
	}
	return 0;
  //华丽结束！
 } 
```

---

## 作者：FJ_OIer (赞：2)

权值树状数组练手题。

就是每次加入一些相同的数到一个数列中，然后排序，求中间的数（如果有两个就取最小值）。但是数据范围不允许我们使用排序。

怎么求呢？设当前数列 $a$ 中有 $n$ 个数，则答案 $x=a_{\frac{(n+1)}{2}}$，也就是说有 $\frac{(n+1)}{2}$ 个数小于等于 $x$。那我们就可以用桶记录每个数出现的次数，再对其求前缀和，这样就可以得到小于等于某个数的元素个数。使用权值树状数组维护前缀和，然后二分求出答案即可。

还有一个问题：这道题的值域太大了（$v_i\le10^9$），数组存不下，需要离散化。

时间复杂度 $O(n \log^2 n)$。
```cpp
#include <bits/stdc++.h>
#define N 200001
#define int long long//十年 OI 一场空
using namespace std;
int n,sum;
int v[N],a[N],b[N],c[N];
//树状数组
void add(int x,int k){
    for (int i=x;i<=n;i+=i&(-i)){
        c[i]+=k;
    }
}
int qry(int x){
    int cnt=0;
    for (int i=x;i;i-=i&(-i)){
        cnt+=c[i];
    }
    return cnt;
}
int bin(){
    int l=1,r=n;
    while (l<=r){
        int mid=(l+r)>>1;
        if (qry(mid)>=(sum+1)/2){
            r=mid-1;
        }else{
            l=mid+1;
        }
    }
    return l;
}
signed main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>v[i]>>a[i];
        b[i]=v[i];
    }
    sort(b+1,b+n+1);
    for (int i=1;i<=n;i++){
        v[i]=lower_bound(b+1,b+n+1,v[i])-b;//离散化
        sum+=a[i];//更新当前人数
        add(v[i],a[i]);//维护前缀和
        cout<<b[bin()]<<endl;//注意二分的答案是离散化后的，需要还原
    }
    return 0;
}
```

---

## 作者：Phobia (赞：2)

首先先将题目中的高度离散化，显然不影响答案。

考虑用一颗树状数组维护前缀和，那么答案就是满足第 $i$ 个位置的前缀和 $\geq$ 当前总人数的一半向上取整的最小的那个 $i$。

树状数组和倍增有着很好的适配性，具体可以在网上查找，所以最终时间复杂度为 $O(n\log{n})$，空间复杂度 $O(n)$。

~~~cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long i64;

const int maxn = 200005;

int a[maxn], b[maxn], v[maxn], n, logn; // a 对应题目中的 v，v 对应题目中的 a

i64 tre[maxn];

int read()
{
	int res = 0, ch = getchar();
	for (; !isdigit(ch); ch = getchar())
		;
	for (; isdigit(ch); ch = getchar())
		res = (res << 3) + (res << 1) + (ch & 15);
	return res;
}

void add(int x, int v)
{
	for (; x <= n; x += x & -x)
		tre[x] += v;	
}

int get(i64 x)
{
	int ans = 0;
	for (int i = logn; i >= 0; --i)
	{
		if (ans + (1 << i) <= n && x > tre[ans + (1 << i)]) // 树状数组上做倍增，仔细想想不难理解
		{
			x -= tre[ans + (1 << i)];
			ans += 1 << i;
		}
	}
	return ans + 1;
}

int main()
{
	n = read(), logn = log2(n);
	for (int i = 1; i <= n; ++i)
		a[i] = b[i] = read(), v[i] = read();
	sort(b + 1, b + n + 1);
	i64 sum = 0; 
	for (int i = 1; i <= n; ++i)
	{
		add(lower_bound(b + 1, b + n + 1, a[i]) - b, v[i]);
		sum += v[i];
		printf("%d\n", b[get(sum + 1 >> 1)]);
	}
	return 0;
} 
~~~

---

## 作者：do_it_tomorrow (赞：2)

[更好的阅读体验](https://www.doittomorrow.xyz/post/coci2022-20234-vrsta-de-ti-jie/)
# 题目描述
有一个序列，初始为空。
有 $n$ 次操作，每次添加 $k$ 个值为 $a$ 的数到序列中。
对于每次操作，你需要输出当前序列的中位数，中位数有 $2$ 个输出较小的一个。其中 $1\le n\le 2\times 10^5$，$1 \le a_i \le 10^9$。
# 思路
因为对于一个数 $x$，其中有小于 $x$ 的书的个数大于 $\frac{1}{2}n $ 而且对于任意小于 $x$ 的数都不成立，那么这个数就是这个序列的中位数，所以这道题目可以使用二分求解。为了快速统计一个序列中小于 $x$ 的数的个数，可以使用树状数组。将输入在离散化之后一次插入树状数组即可。

# AC Code
```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int n,cnt,ans;
struct edge{int x,id;}b[N];
struct node{int x,num;}a[N];
bool cmp(edge a,edge b){return a.x<b.x;};
struct rmq{
	int s[N];
	#define lowbit(x) x&-x
	void updata(int x,int v){
		for(int i=x;i<=n;i+=lowbit(i)) s[i]+=v;
	}int sum(int x){
		int ans=0;
		for(int i=x;i>=1;i-=lowbit(i)) ans+=s[i];
		return ans;
	}
}x;
bool ck(int mid){
	if(x.sum(mid)>=cnt/2+(cnt%2!=0)) return 1;
	return 0;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].num;
		b[i].x=a[i].x,b[i].id=i;
	}sort(b+1,b+1+n,cmp);
	for(int i=1;i<=n;i++) a[b[i].id].x=i;
	for(int i=1;i<=n;i++){
		x.updata(a[i].x,a[i].num),cnt+=a[i].num;
		int l=1,r=n;
		while(l<=r){
			int mid=(l+r)/2;
			if(ck(mid)) ans=mid,r=mid-1;
			else l=mid+1;
		}cout<<b[ans].x<<endl;
	}return 0;
}
```

---

## 作者：lao_wang (赞：1)

## 题意转化
这道题动态的查询当前序列从大到小的序列中的中位数，我们可以浅浅的转化一下，转化成一个求插入值之后求全部序列中的第 $K$ 小问题。

那么问题来了，这个 $K$ 的值是多少？根据题目所说，如果为单数则直接取最中间数，如果为双数则取中间两数之值中较小的值，所以 $K=\lfloor \frac{num+1}{2} \rfloor$ 其中 $num$ 为其中当前数列数字个数，所以这就被我们成功的转化成了一个经典的动态第 $K$ 小问题，所以整体二分启动（不会整体二分的可以参考我的[博客](https://blog.csdn.net/Yale_dd/article/details/138281672?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22138281672%22%2C%22source%22%3A%22Yale_dd%22%7D)）。


## 代码
~~~cpp
#include<bits/stdc++.h>
#define int long long
using namespace std ;
const int N=812345 ;
int n , ans[N] , cnt=0 , now_peoplesum=0 ;
struct node{
	int l , r , opt , k , i ;
}a[N],q1[N],q2[N];
void solve(int l,int r,int L,int R){
	if(L>R) return ;
	if(l==r){
		for(int i=L;i<=R;i++)
			if(a[i].opt==2) ans[a[i].i] = l ;
		return ;
	}
	int mid=(l+r)>>1 , tot1=0 , tot2=0 , sum=0 ;
	for(int i=L;i<=R;i++){
		if(a[i].opt==1){
			if(a[i].l<=mid) sum += a[i].r , q1[++tot1] = a[i] ;
			else q2[++tot2] = a[i] ;
		}else{
			if(a[i].k<=sum)	q1[++tot1] = a[i] ;
			else a[i].k -= sum , q2[++tot2] = a[i] ;
		}
	}
	for(int i=1;i<=tot1;i++) a[i+L-1] = q1[i] ;
	for(int i=1;i<=tot2;i++) a[i+L+tot1-1] = q2[i] ;
	solve(l,mid,L,tot1+L-1) ;
	solve(mid+1,r,tot1+L,R) ;
}
signed main(){
	cin >> n ;
	for(int i=1;i<=n;i++){
		int num , sum ;
		scanf("%lld%lld",&num,&sum) ;
		cnt++ ;
		a[cnt].l = num ;
		a[cnt].r = sum ;
		a[cnt].opt = 1 ;
		now_peoplesum += sum ;
		cnt++ ;
		a[cnt].i = i ;
		a[cnt].k = (now_peoplesum+1)/2 ;
		a[cnt].opt = 2 ;
	}
	solve(-1e9,1e9,1,cnt) ;
	for(int i=1;i<=n;i++)
		printf("%lld\n",ans[i]) ;
	return 0 ;
}

~~~

如果你没事干，可以尝试将他离散化，但是可能离散化完，~~这个代码都跑完了~~

---

## 作者：cjh20090318 (赞：1)

## 题意

有一个序列，初始为空。

有 $n$ 次操作，每次添加 $k$ 个值为 $a$ 的数到序列中。

对于每次操作，你需要输出当前序列的中位数，中位数有 $2$ 个输出较小值。

## 分析

$a$ 较大，离线离散化后再处理。

统计每个 $a$ 出现的次数，可以用树状数组。

设当前加入的数个数为 $c$，那么中位数即第 $\left\lceil\dfrac{c+1} 2\right\rceil$。

设中位数为 $x$，那么小于等于 $x$ 的个数必须大于等于 $\left\lceil\dfrac{c+1} 2\right\rceil$。

个数具有单调性，所以二分。

离散化复杂度 $O(n \log n)$，总体复杂度 $O(n \log^2 n)$。

## 注意事项

记得开 `long long`。

## 代码

```cpp
//the code is from chenjh
#include<cstdio>
#include<cstring>
#include<cassert>
#include<algorithm>
#define MAXN 200002
using namespace std;
typedef long long LL;
template<typename T>
struct fenwick_tree{//树状数组。
    public:
		fenwick_tree(int _SIZE=0):SIZE(_SIZE){dt=new T[SIZE+1]();memset(dt,0,sizeof(T)*(SIZE+1));}
		fenwick_tree(const fenwick_tree& y):SIZE(y.size()),dt(new T[y.size()+1]){memcpy(dt,y.get_dt(),sizeof(T)*(SIZE+1));}
		~fenwick_tree(){delete[] dt;}
		const T&operator [] (const int&x)const{assert(0<x&&x<=SIZE);return dt[x];}
		fenwick_tree&operator = (const fenwick_tree&y){if(this!=&y){SIZE=y.size();T*new_dt=new T[SIZE+1]();memcpy(new_dt,y.get_dt(),sizeof(T)*(SIZE+1));delete[] dt;dt=new_dt;}return *this;}
		void resize(int _SIZE){T*new_dt =new T[_SIZE+1]();memcpy(new_dt,dt,sizeof(T)*((SIZE<_SIZE?SIZE:_SIZE)+1));delete[] dt;dt=new_dt,SIZE=_SIZE; }
		void clear(){SIZE=0;delete[] dt;dt=new T[SIZE+1]();memset(dt,0,sizeof(T)*(SIZE+1));}
		int size()const{return SIZE;}
		T* get_dt()const{return dt;}
		void add(int x,const T&v){assert(0<x&&x<=SIZE);for(;x<=SIZE;x+=x&-x)dt[x]+=v;}
		T sum(const int l,const int r)const{assert(0<l&&l<=r&&r<=SIZE);return sum(r)-sum(l-1);}
	private:
		T*dt;
		int SIZE;
		T sum(int x)const{assert(0<=x&&x<=SIZE);T ret(0);for(;x;x^=x&-x)ret+=dt[x];return ret;}
};
int n,k[MAXN],a[MAXN],b[MAXN];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",&a[i],&k[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	int m=unique(b+1,b+n+1)-b-1;//离散化。
	fenwick_tree<LL> T(m);
	LL c=0;
	for(int i=1;i<=n;i++){
		c+=k[i],T.add(lower_bound(b+1,b+m+1,a[i])-b,k[i]);
		int l=1,r=m;
		for(int mid;l<r;){//二分答案。
			if(T.sum(1,mid=(l+r)>>1)>=((c+1)>>1)) r=mid;
			else l=mid+1;
		}
		printf("%d\n",b[l]);
	}
	return 0;
}

```



---

## 作者：slzx2021zjx (赞：1)

看到楼下写平衡树，蒟蒻不会...

然后磕了 $ 1h $ ...
## 简化题意
每次加入 $a_i$ 个身高为 $v_i$ 的人后，这些人身高的中间值（偶数时取较小的值）。
## 分析
由于不断插入数据很麻烦，于是可以考虑不断删除数据，求中间值。我们可以采取离线算法。

首先离散化，是为了能让数组保存在某一身高的人数。

然后寻找中间数，我们可以考虑二分。那怎么维护不断删除后的人数呢？这不是树状数组的板子吗？

我们可以用树状数组维护区间和，并支持单点修改的操作。

详见[树状数组](https://www.luogu.com.cn/problem/P3374)。

代码如下：
## CODE
```cpp
#include<bits/stdc++.h>
#define int long long
#define F freopen("vrsta.in","r",stdin);freopen("vrsta.out","w",stdout);
#define maxn 200005
using namespace std;
int n,c[maxn],cnt,ans[maxn],num;
struct zjx{
	int h,p;
}a[maxn];
int b[maxn],s[maxn];
int lowbit(int x){return x&-x;}
void add(int x,int k){
	for(int i=x;i<=n;i+=lowbit(i)) s[i]+=k;
}
int qu(int x){
	int ans=0;
	for(int i=x;i;i-=lowbit(i)) ans+=s[i];
	return ans;
}
int sum(int x,int y){
	return qu(y)-qu(x-1);
}
int sol(){
	int l=1,r=n;
	while(l<=r){
		int mid=(l+r)>>1;
		int tmp=sum(1,mid);
		if(tmp<num-tmp) l=mid+1;
		else r=mid-1;
	}
	return l;
}
void ex(int l){
	add(a[l].h,-a[l].p);
	num-=a[l].p;
} 
signed main()
{
	scanf("%lld",&n);
	int k=n;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&a[i].h,&a[i].p);
		b[i]=a[i].h;num+=a[i].p;
	}
	sort(b+1,b+n+1);
	cnt=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++){
		int tmp=lower_bound(b+1,b+cnt+1,a[i].h)-b;
		c[tmp]=a[i].h,a[i].h=tmp;
	}
	for(int i=1;i<=n;i++){
		add(a[i].h,a[i].p);
	}
	for(int l=k;l;l--){
		ans[l]=sol();
		ex(l);
	}
	for(int i=1;i<=k;i++){
		printf("%lld\n",c[ans[i]]);
	}
}
```


---

## 作者：Rainsleep (赞：0)

其实就是动态中位数，先要离散化不然维护不了。线段树二分显然可以直接做，但是不好写。

考虑类似第 $k$ 大的 $\log^2$ 做法，权值树状数组维护前 $i$ 次操作的人数情况，然后二分中位数 $mid$ 并查询 $\leq mid$ 的人数。

瓶颈在树状数组和二分，复杂度 $O(n\log^2n)$。

[code](https://www.luogu.com.cn/paste/xwywhl3b)

---

## 作者：ProzacPainkiller (赞：0)

一道挺板子的平衡树题，而且只需要支持两个操作：

1. 插入 $a_i$ 个值为 $v_i$ 的结点；
2. 求第 $\lceil\frac{n}{2} \rceil$ 个结点（中位值结点）。

对于第一个操作，我们可以稍微改一改 insert 函数把 $a_i$ 个结点一起插进去。

对于第二个操作，我们对于每个结点可以多记录一下左子树和右子树的大小。而对于操作具体实现的详细说明请见代码的 find 函数注释。

代码（写的旋转式 Treap）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+2;
int n,rt,tot;
ll alsiz;
struct node
{
	int lc,rc,val,ord;
	ll lsiz,rsiz,w;
}t[N];
inline void rturn(int &o)
{
	int tem=t[o].lc;
	t[o].lsiz=t[tem].rsiz;
	t[o].lc=t[tem].rc;
	t[tem].rc=o;
	t[tem].rsiz=t[o].lsiz+t[o].rsiz+t[o].w;
	o=tem;
}
inline void lturn(int &o)
{
	int tem=t[o].rc;
	t[o].rsiz=t[tem].lsiz;
	t[o].rc=t[tem].lc;
	t[tem].lc=o;
	t[tem].lsiz=t[o].lsiz+t[o].rsiz+t[o].w;
	o=tem;
}
void insert(int &o,int val,ll w)
{
	if(!o)
	{
		o=++tot;
		t[o].w=w;
		t[o].lc=t[o].rc=t[o].lsiz=t[o].rsiz=0;
		t[o].val=val;
		t[o].ord=rand();
		return;
	}
	if(t[o].val==val)	t[o].w+=w;
	else if(t[o].val<val)
	{
		t[o].rsiz+=w;
		insert(t[o].rc,val,w);
		if(t[o].ord>t[t[o].rc].ord)	lturn(o);
	}
	else
	{
		t[o].lsiz+=w;
		insert(t[o].lc,val,w);
		if(t[o].ord>t[t[o].lc].ord)	rturn(o);
	}
}
int find(int o,ll get=0)	// get 是已经确定在中位值结点右边的结点的数量
{
	if(t[o].rsiz+get>alsiz>>1)	return find(t[o].rc,get);	// 如果右边的子树大小加上 get 比一半大就往右递归。
	if(t[o].rsiz+get+t[o].w>alsiz>>1)	return t[o].val;
// 此时右边的子树大小加上 get 再加上自己的大小大于一半，而上面的情况不成立，说明中位值结点就在这里，返回。
	return find(t[o].lc,get+t[o].rsiz+t[o].w);	//都不成立就说明在左边，往左递归。
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	srand(141414);
	cin>>n;
	ll a;
	for(int i=0,v;i<n;i++)
	{
		cin>>v>>a;
		alsiz+=a;
		insert(rt,v,a);
		cout<<find(rt)<<'\n';
	}
	return 0;
}
```

tips:不开 long long 见祖宗。

---


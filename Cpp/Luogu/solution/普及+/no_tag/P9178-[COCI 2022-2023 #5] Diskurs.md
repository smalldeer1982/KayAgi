# [COCI 2022/2023 #5] Diskurs

## 题目描述

给你 $n$ 个非负整数 $a_1, a_2, \cdots a
_n$，任何一个都小于 $2^m$。

对于其中的每一个数，你都要找出它与数组中其他元素之间的最大哈明距离。

两个非负整数的哈明距离被定义为在这些数字的二进制表示中，它们之间有多少个不同的位置（如果有必要，加上前导零）。

形式上，对于每个 $i$ 求：

$$\max\limits_{1\leq j\leq n} hamming(a_i,a_j)$$

## 说明/提示

| Subatask | $pts$ | 限制 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 是样例 |
| $1$ | $20$ | $m\leq 10$ |
| $2$ | $25$ | $m\leq 16$ |
| $3$ | $25$ | 无 |


## 样例 #1

### 输入

```
4 4
9 12 9 11
```

### 输出

```
2 3 2 3```

## 样例 #2

### 输入

```
4 4
5 7 3 9```

### 输出

```
2 3 2 3
```

## 样例 #3

### 输入

```
4 4
3 4 6 10
```

### 输出

```
3 3 2 3```

# 题解

## 作者：slzx2022YuYihan (赞：6)

# Solution

看到此题，相信很多人会想到字典树。但是写到一半，突然发现写不下去了。这道题求的是最多的不同位，而不是异或最大值。异或最大值可以用字典树来实现，而且挺好理解的，可以自行学习一下。接下来，我们对问题进行一个转化。

根据题意，$m$ 为最大的二进制位数，那么有如下定理。

**引理：$a_i$ 与 $x$ 的哈明距离加上 $a_i$ 取反与 $x$ 的哈明距离等于 $m$。**

证明可以自行脑补一下所以，我们只要知道最小的 $a_i$ 取反与 $x$ 的哈明距离，就能求出答案。时间复杂度 $O(2^mm)$。具体实现还是比较简单的，用状压的思路。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

template<typename T>inline void read(T &x){
	x = 0; T w = 1; char ch = getchar();
	while (!isdigit(ch)){if (ch == '-')	w = -1; ch = getchar();}
	while (isdigit(ch))	x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	x *= w;
}
template<typename T>inline void write(T x){
	if (x < 0)	putchar('-'), x = ~(x - 1);
	if (x > 9)	write(x / 10);
	putchar(x % 10 ^ 48);
}

const int M = 21;

ll n, m, a[1 << M], ham[1 << M];

int main(){
//	freopen(".in", "r", stdin), freopen(".out", "w", stdout);
//	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);

	read(n), read(m);
	memset(ham, 0x3f, sizeof ham);
	for (int i = 1; i <= n; ++i)
		read(a[i]), ham[a[i]] = 0;
	for (int i = 0; i < m; ++i)
		for (int j = 0; j < (1 << m); ++j)
			ham[j ^ (1 << i)] = min(ham[j ^ (1 << i)], ham[j] + 1);
	for (int i = 1; i <= n; ++i){
		ll res = ((1 << m) - 1) ^ a[i];//a[i]取反
		write(m - ham[res]), putchar(' '); 
	}

	return 0;
}
```

---

## 作者：FFTotoro (赞：5)

本题可以使用**广度优先搜索**。

定义两个“相邻”的整数 $a,b$ 为满足如下条件的整数：

- $a\bigoplus b$ 是 $2$ 的非负整数次幂。也就是说，它们的二进制表示下仅有一位不同。

考虑广搜，对于每个给出的整数为源点开始搜。每次搜相邻的整数，若该整数没被搜过，该整数步数 $+1$，将该整数放入队列。

最后对于每个 $a_i$，求出 $b=2^m-1-a_i$（即 $a_i$ 从右往左数 $m$ 位按位取反的值）的“步数”$x$，答案即为 $m-x$。

原理：“最大的异或 $\operatorname{popcount}$”（即汉明距离）即为总位数 $m$ 减去“$b$ 最小的异或 $\operatorname{popcount}$”，而最小的答案即为广搜出来 $b$ 的步数。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  ios::sync_with_stdio(false);
  int n,c; cin>>n>>c;
  vector<int> a(n),m(1<<c,-1);
  queue<pair<int,int> > q;
  for(auto &i:a)
    cin>>i,q.emplace(i,m[i]=0);
  while(!q.empty()){
    auto [u,w]=q.front(); q.pop();
    for(int i=0;i<c;i++)
      if(int v=u^(1<<i);m[v]==-1)
        q.emplace(v,m[v]=w+1);
  }
  for(int i:a)cout<<c-m[(1<<c)-1^i]<<' ';
  return 0;
}
```

---

## 作者：wuhan1234 (赞：4)

## 1. 编程思路。

一个二进制数 $X$ 与二进制数 $Y$ 对应位的值不相同的位数越多，它们之间的哈明距离越大。

$X$ 与 $Y$ 不相同的二进制数位越多，意味着 $X$ 与 $Z$ 不相同的二进制位数越少，相同的二进制数位数越多，$Z$ 是 $Y$ 的各位变反所对应的二进制数。也就是说，若  $X$ 与 $Y$ 的哈明距离越大，则 $X$ 与 $Z$ 的哈明距离越小。

设给定的 $n$ 个非负整数构成了一个集合 $A$，我们定义 $dest_i$ 表示非负整数 $i$ 与集合 $A$ 的全体元素之间的最小哈明距离。

显然，若 $i$ 在集合 $A$ 中，则 $dist_i=0$，因为它跟集合中的整数 $i$ 相同，这样二进制数的各位也相同，不同的位数为 $0$，哈明距离也为 $0$。

若 $i$ 不在集合 $A$ 中，则置 $dest_i$ 的初始值为一个最大的整数。

之后，通过改变 $m$ 位中的每一位的方式，求出各个 $dist_i $ 的值（$0\le i \le 2^m-1$）。

以题目给定的样例 #$2$ 进行说明。

集合 $A$ 中有四个整数 $3,5,7,9$，因此 $dist_3=dist_5=dist_7=dist_9=0$。

$3,5,7,9$ 对应的 $4(m=4)$ 位二进制数分别为 $0011,0101,0111,1001$。

先改变最低位的数字，则有 $0010,0100,0110,1000$，由此可得 

$dist_2=dist_3+1=1$，$dist_4=dist_5+1=1$，
$dist_6=dist_7+1=1$，$dist_8=dist_9+1=1$。

再改变次低位的数字，$3,5,7,9$ 对应的二进制数更改次低位分别可得 $0001,0111,0101,1011$。为此可得，
$dist_1=dist_3+1=1$；$dist_7$ 的现值比 $dist_5+1$ 还小，不修改；同样，$dist_5$ 也不修改；$dist_{11}=dist_9+1=1$。

$2,4,6,8$ 对应的二进制数更改次低位分别可得 $0000,0110,0100,1010$，其中，$dist_0=dist_2+1=2$，$dist_{10}=dist_8+1=2$，$dist_4$ 和 $dist_6$ 不修改。

之后，修改次高位，可得 $dist_{13}=dist_9+1=1$，$dist_{12}=dist_8+1=2$，$dist_{15}=dist_{11}+1=2$。

最后修改最高位可得，$dist_{14}=dist_6+1=2$。

求得了所有的 $dist_i $ 的值后（$0\le i \le 2^m-1$），某个数 $a_i$ 与数组中其他元素之间的最大哈明距离就很方便求出了，设 $a_i$ 对应的 $m$ 位二进制数各位变反后对应的整数为 $x$，则所求的最大哈明距离为 $m-dist_x$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int a[1 << 20];
int dist[1 << 20];
int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    int  n,m;
    scanf("%d%d",&n,&m);
    int i,j;
    for (i = 0; i < n; ++i)
    {
        scanf("%d",&a[i]);
    }
    memset(dist,0x3f,sizeof(dist));
    for (i=0;i<n;i++)
        dist[a[i]]=0;
    for (j=0;j<m;j++)
        for (i=0;i<(1<<m);i++)
            dist[i ^ (1 << j)] = min(dist[i ^ (1 << j)], dist[i] + 1);
    for (i = 0; i < n; i++)
    {
        j = ((1 << m) - 1) ^ a[i];
        printf("%d ",m - dist[j]);
    }
    printf("\n");
    return 0;
}
```




---

## 作者：ClearluvXL (赞：3)

# diskurs
## 思路
- 本题中定义了 $ham[i,j]$ 为二进制表示下 $i$ 和 $j$ 的不同位数的个数。那么我们可以想到在本题 $m \le 20$ 的限制下，大概率会使用状压做，那么一个数与那个数具有最大的 $ham$ 距离呢？我们肯定能想到的是在 $m$ 的范围下对 $x$ 按位取反之后得到的数 $y$ 时，$ham[x,y]$ 最大，为 $m$。

- 但是 $y$ 不一定在给出的数据中呀，对吧。我们这样想，我们用 $ham[stat]$ 表示 $stat$ 这个数在给出的数中的所能取到的最小 $ham$ 距离(最少有几位不同)，如果 $stat$ 本身就在数据中的话，$ham[stat]$ 就是0，初始化 $ham$ 数组为正无穷。最后我们按位取反 $x$ 得到 $y$ ，$ham[y]$ 肯定会被算出来的，因为此时 $ham[y]$ 所表示的含义为最少有几位不同，而 $y$ 与 $x$ 有 $m$ 位不同(最多)，所以 $m-ham[y]$ 就是最终的答案，因为 $ham[y]$ 肯定是由给出的数据中的数推出来的，所以能保证答案的正确性。

- 记 $x$ 取反为 $fx$，其实也就是 $ham[x,y]+ham[fx,y]=m$。
- 时间复杂度为 $O(2^{m} \times m)$。
## 代码
```c++
#include<bits/stdc++.h>                                                                                                       #include<bits/stdc++.h>
using namespace std;

#define endl '\n'

const int N=(1<<20)+10;
const int INF=0x3f3f3f3f;

int n,m;
int a[N];

int num[N];
int ham[N]; 

int main(){

	cin>>n>>m;
	
	memset(ham,INF,sizeof ham);
	
	for(int i=1;i<=n;i++){
		cin>>a[i];
		ham[a[i]]=0;
	} 
	
	for(int i=0;i<m;i++){
		for(int stat=0;stat<1<<m;stat++){
			ham[stat^(1<<i)]=min(ham[stat^(1<<i)],ham[stat]+1);
		}
	}
	
	for(int i=1;i<=n;i++){
		int res=((1<<m)-1)^a[i];
		cout<<m-ham[res]<<" ";
	}
	
	
	return 0;
}//end
```

---

## 作者：DDF_ (赞：1)

## 题面

给一个长度为 $n$ 的整数数组 $a$，求对于每个 $a_i$，$\max(\operatorname{popcount}(a_i \oplus a_j))(1 \le j \le n)$。

## 题解

一开始看到题目可能会想到用 Trie 树，但是用 Trie 树只可求异或的最大值，不能求异或后 $\operatorname{popcount}$ 的最大值，因此不能用 Trie 树写。

那么我们该怎么办呢？

首先，开个数组储存 $1$ 到 $2^{m}-1$ 中 $\operatorname{popcount}$ 等于 $i$ 的所有数，记为 $v_{i,j}$。

然后可以发现：对于所有 $a_{i}$ 相同的 $i$ ，答案也相同，所以可以去重，$n$ 越大，去重的效果越好，因此我们可以对每个不同的 $a_{i}$，处理一遍答案即可。

最后，对于每个不同的 $a_{i}$，在 $v$ 寻找一个 $\operatorname{popcount}$ 最大的数作为异或值，然后检查这个值异或 $a_{i}$ 有没有在 $a$ 数组里出现，将 $a_{i}$ 的答案设为这个 $\operatorname{popcount}$ 即可。

那么我们可以从最大的 $\operatorname{popcount}$ 直接往下枚举，找到答案即可。

暴力+优化直接跑过。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pop(x) __builtin_popcount(x)
using namespace std;
const int N=2e6+2;
int n,m,l;
int a[N],ans[N];
bool vis[N],f[N];
char ch[22];
vector<int> v[22];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		vis[a[i]]=1;
		l=max(l,(int)log2(a[i])+1);
	}
	m=min(m,l);
	for(int i=0;i<(1<<m);i++) v[pop(i)].push_back(i);
	for(int i=1;i<=n;i++) {
		if(f[a[i]]) continue;
		f[a[i]]=1;
		for(int j=m,pd=0;j>=0;j--) {
			for(int k=0;k<v[j].size();k++) if(vis[v[j][k]^a[i]]) {pd=1;break;}
			if(pd) {ans[a[i]]=j;break;}
		}
	}
	for(int i=1;i<=n;i++) printf("%d ",ans[a[i]]);
	return 0;
}
```

---

## 作者：nahidaa (赞：0)

## [传送门](https://www.luogu.com.cn/problem/P9178)

## 正文
我们求与 $k$ 最大的哈明距离，即为求与 $((2^{m+1}-1)\oplus k)$（即为 $k$ 的所有二进制位取反后的值）最小的哈明距离。

那么我们可以用 BFS 预处理 $0,1,\cdots ,2^{m+1}-1$ 的数与题目给出的 $n$ 个数之间的最小哈明距离，BFS 中只需要将目前处理到的数的一个位取反，然后得出答案。

最后，用（$m-((2^{m+1}-1)\oplus k)$ 的哈明距离 $+1$）即可得出答案。


## 代码：

```cpp
include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[2100000],ge[2100000],m1,suan;
queue<int>i;
int main()
{
    /*ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);*/
    cin>>n>>m;
    m1=1<<m;
    memset(ge,63,sizeof(ge));//将所有值预处理为极大
    for(int g=1;g<=n;g++){//本人循环变量习惯用g，凑合着看吧
        cin>>a[g];
        i.push(a[g]);//加入队列（用于BFS）
        ge[a[g]]=0;//自身与自身的哈明距离为0
    }
    while(i.size()){
        for(int g=0;g<=m;g++){//枚举任意一个二进制位
            suan=i.front()^(1<<g);//计算亦或一位之后的值
            if(ge[i.front()]+1<ge[suan]){//若更优（如果之前已经被访问过，则一定之前的最优，此时不用再加入队列）
                ge[suan]=ge[i.front()]+1;//记录哈明距离
                i.push(suan);//
            }
        }
        i.pop();
    }
    m1=1<<(m+1);
    m1--;//预先计算（常数较小）
    for(int g=1;g<=n;g++){
        cout<<m-ge[m1^a[g]]+1<<" ";//答案输出
    }
    return 0;
}
/*

*/
```

---

## 作者：Andy1101 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P9178)
# 思路
## 题目大意
求出每一个数与数组中其他元素之间的最大哈明距离。
### 哈明距离
对于两个数 $a$ 和 $b$，$hamming(a,b)$ 就是两个数在二进制表示下有多少个不同的位置。
## 做法
本蒟蒻本想暴力求，但 $O(2^mnm)$ 的时间复杂度似乎并不行。于是在我深（guan）思（kan）熟（ti）虑（jie）之后，发现可以取反后求最小的哈明距离。

注意到每两个数之间的哈明距离不可能超过 $m$，于是可以转移 $m$ 次，每一次只通过在二进制下对应的位置转移即可，时间复杂度为 $O(m2^m)$，可以通过此题。
# Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read()
{
	ll x=0;
	ll k=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-') k=-1;
		ch=getchar(); 
	}
	while(ch>='0' && ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*k;
}
const int N=(1<<21);
const int INF=0x7f7f7f7f;
ll a[N];
ll h[N];
int main()
{
	memset(h,INF,sizeof h);
	int n,m;
	n=read(); m=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		h[a[i]]=0;
	}
	for(int i=0;i<m;i++)
	{
		for(int j=0;j<(1<<m);j++)
		{
			h[j^(1<<i)]=min(h[j^(1<<i)],h[j]+1);
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<m-h[(1<<m)-a[i]-1]<<" ";
	}
	return 0;
}
```

---

## 作者：xixisuper (赞：0)

# P9178 [COCI2022-2023#5] Diskurs 题解

模拟赛寄了，属以题解以记之。

## 思路

正难则反，由于求最大距离难求，于是我们考虑对每个数取个反，去求最小哈明距离。

注意到每两个数之间的哈明距离不可能超过 $m$，于是考虑转移 $m$ 次，每一次只通过在二进制下对应的位置转移即可，理论上使用多源 bfs 会更快，但是这个题无需顾虑这些事情，只需要暴力枚举每个数的转移即可，时间复杂度为 $O(m2^m)$，可以通过此题。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const ll N=(1<<21);
const ll INF=2147483647;
ll n,m,dis[N],a[N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(ll i=0;i<N;i++) dis[i]=INF;
	for(ll i=1;i<=n;i++){cin>>a[i];dis[a[i]]=0;}
	for(ll i=0;i<m;i++)
		for(ll j=0;j<(1<<m);j++)
			dis[j^(1<<i)]=min(dis[j^(1<<i)],dis[j]+1);
	for(ll i=1;i<=n;i++) cout<<(m-dis[(1<<m)-1-a[i]])<<' ';
	return 0;
} 
```

---

## 作者：KohaD_SEGA (赞：0)

暴力做这道题的时间复杂度是 $O(2^mnm)≈O(n^2m)$ ,只能得到 $20$ 分。

我们使用广度优先搜索的方法，创建一个队列 $\text q$ 并将初始数字插入队列中。我们知道在这个集合中与一个数 $a$ 的最大的 $\text{Hamming}$ 距离加与 $2^{m+1}-1-a$ 的最小 $\text{Hamming}$ 距离等于 $m$ 。

而与一个数最小的 $\text{Hamming}$ 距离我们就很容易使用 BFS 了。例如距离为 $1$ 相当于两个数的二进制表示只有一位不同，距离为 $2$ 就可以通过搜索距离为 $1$ 的那些数得出，依此类推。

这种方式的时间复杂度是 $O(nm)≈O(2.1\times 10^7)$，通过很轻松。

代码：

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

inline void read(int &x) {
    x = 0;
    int w = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            w = -1;
        ch = getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    x *= w;
}

int main() {
    int n, m;
    read(n);
    read(m);

    vector<int> arr(n); // 存储输入数组
    queue<int> q; // 用于广度优先搜索的队列
    vector<int> hammingDist(1 << (m + 1), m + 1); // 存储Hamming距离

    for (int i = 0; i < n; i++) {
        read(arr[i]);
        q.push(arr[i]);
        hammingDist[arr[i]] = 0; // 初始数字的Hamming距离设为0
    }

    while (!q.empty()) {
        int num = q.front(); // 取出队首数字
        q.pop(); // 弹出队首数字

        for (int bit = 0; bit <= m; bit++) { // 遍历二进制表示的每一位
            int nextNum = num ^ (1 << bit); // 翻转当前位
            if (hammingDist[num] + 1 < hammingDist[nextNum]) { // 如果通过翻转当前位得到的数字的Hamming距离更小
                hammingDist[nextNum] = hammingDist[num] + 1; // 更新Hamming距离
                q.push(nextNum); // 将新数字插入队列
            }
        }
    }

    int k = (1 << (m + 1)) - 1;
    for (int i = 0; i < n; i++) {
        int maxHammingDist = m - hammingDist[k ^ arr[i]] + 1; // 计算与给定数字的最大Hamming距离
        cout << maxHammingDist << " ";
    }

    return 0;
}
```

---


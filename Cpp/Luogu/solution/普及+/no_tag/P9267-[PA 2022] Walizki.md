# [PA 2022] Walizki

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Walizki](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wal/)**

有没有想过，你在机场办理完了登机手续，你的行李箱会去哪里？就在它们消失的帘子后面，有一个巨大的大厅，里面布满了错综复杂的平台和传送带，对你的行李进行相应的分类。

Byteasar 负责评估新规划的 Byteburg Bitom 机场的行李大厅的设计。根据规划，大厅里将有 $n$ 个平台，用 $1$ 到 $n$ 的整数编号，每个行李箱最初都要运输到第一个平台。一些单向传送带可以从平台出发，连接到编号严格更大的平台。如果一个平台没有传送带出口，在这个平台的行李箱将由机场工作人员手动拿走并转移到相应的飞机上。另一方面，如果平台接有多条出口传送带，那么传送带的顺序就很重要——第一个行李箱遇到这样的平台，就会从第一条传送带上离开，第二个就会从第二条上离开，以此类推。当行李箱从最后一条传送带离开平台时，下一个行李箱又会从第一条传送带离开，如此循环往复。

一旦一个行李箱被送到第一个平台，它在传送带上的运输和工作人员的收集都在下一个行李箱放在第一个平台之前进行。换句话说，在任何时候，最多只有一个行李箱在传送带上运输。

可以想见，在处理了一定数量的行李箱后，这个行李系统会「复位」，即回到对于每个有出口传送带的平台，行李箱到达平台后都从第一条出口传送带离开的状态。Byteasar 想知道最少处理多少行李箱之后，系统将自我复位。请帮他计算出这个值！

## 说明/提示

对于 $100\%$ 的数据，满足：

$1\le n\le 100, i<l_{i,1}<l_{i,2}<\ldots<l_{i,r_i}$。

## 样例 #1

### 输入

```
7
3 2 3 5
2 3 6
3 5 6 7
1 6
1 7
0
0
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3
0
1 3
0
```

### 输出

```
1
```

# 题解

## 作者：meyi (赞：0)

对于每个有传送带的平台 $i$，系统复位的条件是，到达该平台的行李箱数恰好是 $r_i$​ 的倍数。

直接计算到达每个平台的行李箱数是困难的，但是根据上面的结论，到达每个平台的行李箱数都是其传送带数量的倍数，因此其连接的每条传送带传出的行李箱数也一定相等。

将最开始放在 $1$ 号平台上的一个单位流量视作整体处理过程的基准。接下来，每个平台 $i$ 接收到的流量（记作 $flow_i$）则可以表示：如果我们放出一个单位流量的行李箱，那么平台 $i$ 最终收到的箱子为 $flow_i$ 个单位流量，显然这是个有理数。  

对于一个拥有 $r_i$ 条传送带的平台，传送箱子时均分给每条传送带，所以每条传送带传出的流量为  
$$
f_i = \frac{flow_i}{r_i}.
$$
传送带仅从较小编号的平台通向编号更大的平台，这保证了整个系统构成一个 DAG，使得我们可以按编号从小到大开始依次计算 $flow_i$。

对于每个有传送带的平台 $i$，总共处理了 $X$​ 个行李箱后，该平台收到的行李箱数为
$$
X \times \mathit{flow}_i.
$$
由于平台的传送带采用循环调度，只有当上面这个数是 $r_i$ 的倍数时，平台的状态才会复位。换句话说，我们要求  
$$
X \times \frac{flow_i}{r_i} \in \mathbb{Z}.
$$
也即
$$
X \times f_i \in \mathbb{Z}.
$$
不妨假设 $f_i$ 的最简分数表示为 $\frac{p_i}{q_i}$，其中 $p_i,q_i\in \mathbb{Z}^+$ 且 $\gcd(p_i,q_i)=1$，那么上式等价于
$$
q_i \mid X.
$$
可知
$$
X = \mathop{\text{lcm}}\limits_{i=1}^n\ q_i.
$$
即为答案。

显然 $X$ 的值可能很大，又因本题涉及到分数运算，因此使用 Python 实现。

```python
from fractions import Fraction
from math import lcm

n = int(input())
to = []
for i in range(n):
    to.append([j - 1 for j in list(map(int, input().split()))[1:]])
flow = [Fraction(1)] + [Fraction(0)] * (n - 1)
X = 1
for i in range(n):
    if to[i]:
        f = flow[i] / len(to[i])
        X = lcm(f.denominator, X)
        for j in to[i]: flow[j] += f
print(X)
```

---


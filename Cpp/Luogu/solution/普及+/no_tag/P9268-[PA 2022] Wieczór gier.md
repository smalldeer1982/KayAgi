# [PA 2022] Wieczór gier

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Wieczór gier](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wie/)**

Bytie 喜欢在晚上玩他最喜欢的棋盘游戏。幸运的是，这个游戏是单人游戏，Bytie 不需要和朋友一起玩这个游戏。

棋盘共 $n$ 行，每行有 $m$ 个方格，整个棋盘共有 $nm$ 个方格。棋盘上有 $k$ 个无法区分的棋子，最多只有 $8$ 个。 棋盘的边缘有装饰性的标记，这些标记表明了棋盘的上下左右方位。每个方格可能是空的，也可能放有一个棋子，但棋盘上总是至少有一个棋子，而且至少有一个方格是空的。换句话说，满足 $1\le k\le nm-1$。游戏中一步棋指的是选择一个包含棋子的方格和与之相邻的另一个不包含棋子的方格，然后将棋子从这个方格移到相邻的空方格中。

Bytie 喜欢这个不复杂但令人兴奋的规则，他可以花几个小时来移动棋子。一天晚上，他坐在棋盘前，在棋盘上摆了 $k$ 个棋子，并想到了一种棋子的排布方式，这种排布方式也许与开始时不同。他说，每次他要走一步棋时，他都会确定现在所有棋子的所有可能走法，并从这些走法中随机选出他要怎么走棋。例如，如果棋盘上有两个棋子，第一个棋子有一种走法，第二个棋子有两种走法，那么 Bytie 将以 $\frac{1}{3}$ 的概率从这三种走法中选出一种来走下一步棋。

Bytie（正如我们已经提到的）非常喜欢玩这个游戏，所以他已经确定他会正好走 $100^{100^{100^{100}}}$ 步棋。在走了这么多步之后，棋盘上的棋子排布和目标排布相同的概率是多少？

## 说明/提示

对于 $100\%$ 的数据，满足：

$1\le n,m\le 8$。

## 样例 #1

### 输入

```
1 5
O....

....O
```

### 输出

```
0.25```

## 样例 #2

### 输入

```
2 2
O.
.O

OO
..
```

### 输出

```
0
```

# 题解

## 作者：262620zzj (赞：0)

题目里给的步数可以认为是无穷。但是这是个偶数，所以如果起始与结束状态奇偶性都不一样直接输出 $0$。

现在考虑下奇偶性一样的情况。由于走了无穷步，所以棋盘中中间的格子，边上的格子，角上的格子可以认为是互相等价的。或者说，相邻的格子数量相等的格子是等价的。这样的话，我们计算下结束前一步有多少种走到结束状态的本质不同的方法，注意这里本质不同是指**最后一步走的方法不一样**而不是棋子位置不一样。再除以最后一步的总方案数就可以了。这样看起来是错的，但实际上很合理。虽然有一些状态，棋子们相对靠近中间，到达这个状态的概率会高一些，但是下一步，这种状态可选的走法也更多，平均下来每种本质不同的走法其实概率是一样的。

具体的计算方法的话，首先奇偶性判断只需要将横纵坐标求和判断奇数还是偶数。然后计算最后一步可以达到最终状态的方案数，先枚举最后一步挪动了哪个棋子，然后枚举从哪个方向过来，然后其余的棋子位置要求与最终状态一样，所以枚举完这两点之后有且仅有一种方案合法。总共的方案数也是先枚举这两点，但是这时其他棋子可以任意摆放，有 $\binom{nm-2}{k-1}$ 种合法方案。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef pair<int,int> pii;
#define fi first
#define se second
int n,m,k;
char c[10][10];
const pii d[4]={{-1,0},{0,1},{1,0},{0,-1}};
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    int sum1=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>c[i][j];
            if(c[i][j]=='O'){
                k++;
                sum1+=i+j;
            }
        }
    }
    int sum2=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>c[i][j];
            if(c[i][j]=='O'){
                sum2+=i+j;
            }
        }
    }
    if(sum1%2!=sum2%2)return cout<<0,0;//判断奇偶性
    int fz=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(c[i][j]=='O'){
                for(int a:{0,1,2,3}){
                    int x=i+d[a].fi,y=j+d[a].se;
                    if(x>=1&&x<=n&&y>=1&&y<=m&&c[x][y]=='.')fz++;
                }
            }
        }
    }
    int c=1;
    for(int i=0;i<k-1;i++)c*=n*m-2-i;
    for(int i=1;i<=k-1;i++)c/=i;
    // cerr<<c<<endl;
//计算组合数 C(n*m-2,k-1)
    int fm=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int deg=0;
            for(int a:{0,1,2,3}){
                int x=i+d[a].fi,y=j+d[a].se;
                if(x>=1&&x<=n&&y>=1&&y<=m)deg++;
            }
//上一步总共的方案数，枚举i,j表示最后一步动了哪个位置的棋子，a枚举向哪个方向动，
//确定了这两点之后其他位置上任意放其余的棋子。
            fm+=deg*c;
        }
    }
    // assert(fm%2==0);
    fm/=2;
//别忘了上一步的奇偶性必须不同于结束状态，所以要减半。
    cout<<fixed<<setprecision(13)<<1.0*fz/fm;
    return 0;
}
```

---


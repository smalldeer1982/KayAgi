# ZHY 的生成树

## 题目描述

ZHY 有一个 $n$ 个点的完全图，点 $u$ 与点 $v$ 的距离为 $\gcd(u,v)$，求这个完全图的最大生成树的边权之和。

## 说明/提示

**本题采用捆绑测试。**

$\text{Subtask}$ $0\kern{3pt}$(10pts)：$n\le 5$。

$\text{Subtask}$ $1\kern{3pt}$(20pts)：$n\le 1000$。

$\text{Subtask}$ $2\kern{3pt}$(30pts)：$n\le 10^{6}$。

$\text{Subtask}$ $3\kern{3pt}$(40pts)：$n\le 10^{7}$。

对于所有测试数据，$1\le n \le 10^{7}$。

## 样例 #1

### 输入

```
4```

### 输出

```
4```

## 样例 #2

### 输入

```
30```

### 输出

```
183```

## 样例 #3

### 输入

```
100```

### 输出

```
1916```

# 题解

## 作者：封禁用户 (赞：16)

最大生成树，考虑 Kruskal 过程。

从大到小加边，假设已经添加了所有边权大于 $i$ 的边，现在添加所有边权为 $i$ 的边。发现边权为 $i$ 的边一定是所有编号为 $i$ 的倍数的节点组成的。如果编号为 $a\times i$ 的点与编号为 $b\times i$ 的点不连通，则 $\gcd(a\times i,b\times i) \leq i$，即 $\gcd(a,b)=1$，故所有 $i$ 的合数倍的节点都与一个 $i$ 的质数倍的节点相连。

将节点 $i$ 与所有 $i$ 的质数倍的节点连边，就使得所有 $i$ 的倍数的节点全部连通，故能连的所有长度为 $i$ 的边都连上了。只需要维护一个并查集，使用路径压缩和按秩合并。

根据素数分布定理，即可在 $O(n \log \log n \alpha(n))$ 的复杂度内得到答案，不卡常。

---

## 作者：fuqingchen (赞：13)

# 原题链接

[P9488 ZHY 的生成树](https://www.luogu.com.cn/problem/P9488)

# 题目简述

ZHY 有一个 $n$ 个点的完全图，点 $u$ 与点 $v$ 的距离为 $\gcd(u,v)$，求这个完全图的最大生成树的边权之和。

# 解题思路

### $30 pts$

直接暴力建图，跑一遍 $kruskal$。
不会 $kruskal$ 的点[这里](https://www.luogu.com.cn/problem/P3366)。

### $60 pts$

这时候你离正解已经很近啦！

首先考虑 $n \le 10^6$。$n^2$ 建图纯属浪费（因为只有 $n-1$ 条边是有用的），我们可以先枚举这条边的边权，然后由 $i$ 向 $i$ 的倍数进行连边，就可以拿到 $60 pts$ 了。

### $100 pts$

在 $60 pts$ 上优化，主要的重复在于枚举倍数时重复了。为了尽量减少这种情况，在枚举时可以只枚举倍数为质数的情况，稍微卡一卡就能过了。

# 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e7 + 10;
int n, m, fa[N], tot;
int prime[6000100], q, x, k;
bool isp[N];
void Prime() {
	for (register int i = 2; i <= 10000000; ++i) {
		if (isp[i] == 0) prime[++k] = i;
		for (register int j = 1; j <= k && i * prime[j] <= 10000000; ++j) {
			isp[i * prime[j]] = 1;
			if (!(i % prime[j])) break;
		}
	}
}
int find(int x) {
	if(x == fa[x]) return x;
	else return fa[x] = find(fa[x]);
}
void kruskal() {
	int cnt = 0;
	long long sum = 0;
	for(register int i = n / 2; i >= 1; --i) {
		int len = n / i;
		for (int u = 1; prime[u] * i <= n; ++u) {
			int x = find(i), y = find(prime[u] * i);
			++tot;
			if (x != y) {
				++cnt;
				sum += i;
				fa[y] = x;
				if (cnt == n - 1) {
					cout << sum;
					return;
				}
			}
		}
	}
}
signed main() {
	cin >> n;
	Prime();
	for (int i = 1; i <= n; ++i) fa[i] = i;
	kruskal();
	return 0;
}
```

---

## 作者：柠檬布丁吖 (赞：8)

[传送门](https://www.luogu.com.cn/problem/T350817?contestId=117064)

题目非常清新。对于一个 $n$ 个点的完全图，点 $u$ 和点 $v$ 的距离为 $\gcd(u,v)$，求完全图的最大生成树的边权之和。

简单概念：

- 完全图：每对不同的顶点之间都恰连有一条边相连。对于一个 $n$ 个点的完全图，完全图的边数为 $\frac{n\times(n-1)}{2}$（对于无向图）。

- 对于两个正整数 $a$ 和 $b$，$\gcd(a,b)$ 表示 $a$ 和 $b$ 的最大公约数，即能同时整除 $a$ 和 $b$ 的最大正整数。

- 最大生成树：与最小生成树类似。一个图的所有生成树中边权值和最大的生成树为最大生成树。

# 30pts

暴力做法。用 kruskal 求出最大生成树。能过掉前 $2$ 个 $\text{Subtask}$。

```cpp
const int N=3000055;
struct node {
	int from;
	int to;
	int w;
} a[N*10];
bool cmp(node aa,node bb) {
	return aa.w>bb.w;
}
int n,m,k,t;
int f[N];
int getf(int v) {
	if(f[v]==v) return f[v];
	else return f[v]=getf(f[v]);
}
int Kruskal() {
	sort(a,a+k,cmp);
	int ans=0,countt=1;
	for(int i=0; i<k; i++) {
		int t1=getf(a[i].from);
		int t2=getf(a[i].to);
		if(t1!=t2) {
			ans+=a[i].w;
			f[t2]=t1;
			countt++;
			if(countt==n)
				break;
		}
	}
	if(countt==n)
		return ans;
	else
		return -1;
}
signed main(void) {
	int kkk;
	cin>>kkk;
	n=kkk,k=n*(n-1);
	int o=0;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			if(i==j) continue;
			
			a[o].from=i;a[o].to=j;a[o].w=__gcd(i,j);
			o++;
		}
	}
	for(int i=0; i<=N; i++){
		f[i]=i;
   }
	int kk=Kruskal();
	printf("%d\n",kk);
	return 0;
}
```
------------------------

# 60pts

对于 $u$ 点向 $u$ 的倍数点连边。可以排除无用边。

# 100pts

和最小生成树一样，找最大生成树就是利用并查集不断加入和查询来构造最大生产树的过程。在这个图中，为了找到最大生成树，我们需要从编号较大的数开始考虑，因为较大的数的 $\gcd$ 值更大。

手玩几组样例。以下的是 $n=4$ 时的图。红色的是生成树。

![](https://cdn.luogu.com.cn/upload/image_hosting/3ul94rjn.png)



再来一组：

（$n=6$。从左到右为 $u,v,w$）
```cpp
1 2 1
1 3 1
1 4 1
1 5 1
1 6 1
2 3 1
2 4 2
2 5 1
2 6 2
3 4 1
3 5 1
3 6 3
4 5 1
4 6 2
5 6 1
```

前 $5$ 行为最大生成树的边。
```cpp
6 3
4 2
6 4
5 6
5 1
ans=9
```
![](https://cdn.luogu.com.cn/upload/image_hosting/int0y1wf.png)


根据 Kruskal 的加边顺序，先添加的边一定大于后添加的边。对于一个当前准备添加的边的边权 $w$，因为 $w=\gcd(u,v)$，显然若 $u$ 和 $v$ 连边且 $u<v$，则 $v=p\times u$ 且 $p$ 为质数。

容易发现，如果编号 $u\times w$ 的点与编号 $v\times w$的点不相连，则 $\gcd(u\times w,v\times w)≤w$。

所以 $\gcd(u,v)=1$;故所有编号 $w$ 的合数倍的点都与编号 $w$ 的质数倍的点连通。

将点 $w$ 与所有 $w$ 的质数倍的点连边，相当于把所有 $w$ 的倍数的点全部连通。
所以说只要枚举点 $w$ 与 $w$ 的质数倍的点连边即可。

核心代码：

```cpp
   for (int i = num / 2; i >= 2; i--) {
        for (int j = 1; primes[j] <= num / i; j++) {
            bool connected = unite(i, i * primes[j]);
            if (connected) {
                answer += (ll)i;
                --total;
            }
        }
    }
```

（$num$ 为题意中的 $n$）

为什么第一层循环要从 $\frac{n}{2}$ 开始枚举呢？

因为对于任何大于 $\frac{n}{2}$ 的数 $u$，$\gcd(u,v)$ 将小于 $u$，其中 $v$ 是小于等于 $n$ 的数。因此，我们只需要考虑 $\frac{n}{2}$ 到 $2$ 之间的数。

-----------------------------

**ACcode:**

```cpp
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <algorithm>

#define MAXN 10000005

using namespace std;

typedef long long ll;

int num, parent[MAXN], size[MAXN], total, primeCount, primes[MAXN];
ll answer;
bool notPrime[MAXN];

void initialize() {
    for (int i = 1; i <= num; i++) {
        parent[i] = i;
        size[i] = 1;
    }
    return;
}

int find(int x) {
    while (x != parent[x]) {
        x = parent[x] = parent[parent[x]];
    }
    return x;
}

bool unite(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX == rootY) {
        return false;
    }
    if (size[rootX] < size[rootY]) {
        swap(rootX, rootY);
    }
    parent[rootY] = rootX;
    size[rootX] += size[rootY];
    return true;
}

int main() {
    scanf("%d", &num);
    total = num - 1;
    for (int i = 2; i <= num; i++) {
        if (!notPrime[i]) {
            primes[++primeCount] = i;
        }
        for (int j = 1; j <= primeCount; j++) {
            if ((ll)i * (ll)primes[j] > (ll)num) {
                break;
            }
            notPrime[i * primes[j]] = true;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
    initialize();
    for (int i = num / 2; i >= 2; i--) {
        for (int j = 1; primes[j] <= num / i; j++) {
            bool connected = unite(i, i * primes[j]);
            if (connected) {
                answer += (ll)i;
                --total;
            }
        }
    }
    answer += (ll)total;
    printf("%lld\n", answer);
    return 0;
}
```

写题解不易，求过！谢谢题管。

---

## 作者：Meny__love (赞：8)

# **传送门**
[P9488 ZHY 的生成树](https://www.luogu.com.cn/problem/P9488)
# **解题思路**
## $30$ 分
这道题暴力解题，用上一个 Kruskal 算法，得了 $30$ 分。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[10000005],ans,x,sum,len;
struct lol{
	int from,to,val;
}l[10000010];
bool cmp(lol a,lol b){
	return a.val>b.val;
}
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
void Kuskal(){
	int a,b;
	sort(l+1,l+1+len,cmp);
	for(int i=1;i<=len;i++){
		a=find(l[i].from);
		b=find(l[i].to);
		if(a==b) continue;
		sum+=l[i].val;
		f[a]=b;
		x++;
		if(x==n)return;
	}
}
int main(){
	int i;
	cin>>n;
	for(i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			l[++len].from=i;
			l[len].to=j;
			l[len].val=__gcd(i,j);
		}
	}
	Kuskal();
	printf("%d",sum);
	return 0;
}
```
## $60$ 分
在 Kruskal 的基础上，因为非 $i$ 点倍数的点与i点连成的边都是值不大的边，在之后都要舍去，所以建立图的时候就可以直接不建这样的边，只与为 $i$ 为倍数关系的点建边即可。
## AC
通过自己手动模拟，可以发现，为 $i$ 倍数的点中，非质数倍数的点都会被舍去，所以再次优化，只与为 $i$ 质数倍数的点建边即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e7+5;
int n,f[maxn],ans,x,prime[maxn<<1],len;
long long sum;
bool vis[maxn];
inline int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
inline void isPrime(int x){
    for (int i=1;x*prime[i]<=n&&i<=len;++i) {
		vis[x*prime[i]]=1;
		if(!x%prime[i]) return;
	}
	
}
int main(){

	scanf("%d",&n);
	for(int i=2;i<=n;++i){
		isPrime(i);
		if(!vis[i]) prime[++len]=i;
	}
	for(register int i=1;i<=n;++i) f[i]=i;
	for(register int i=n/2;i;--i){
		for(int j=1;i*prime[j]<=n&&j<=len;++j){
			int form=i,to=i*prime[j],val=i;
			int son=find(form),father=find(to);
			if(son!=father) {
				sum+=val;
				f[son]=father;
			}
		}
	}
	printf("%lld",sum);
	return 0;
}
```
（本蒟蒻的第一篇题解，望通过。）

---

## 作者：wangif424 (赞：5)

~~论一个刚结束集训的OIer有多傻~~。

这道题考场上有两种不同的思路，它们十分完美~~指只有十分~~。

### 错误思路集锦（千万别学）

#### 错误思路一

直观的，从较大点权连接到较小点权的角度考虑。

当边权和最大时，每个点都连接到除去自己的最大因数。

证伪：

+ 考虑到点 $1,3,7,21$ 的连接方案，按照此思路的连法，边权和为 $9$，而正确答案是 $11$。

+ 这是因为 $3 \rightarrow 1$ 的连接只能产生 $1$ 的贡献，而如果 $3 \rightarrow 21$ 则会产生 $3$ 的贡献。

于是想到从较小点权从较大点权连边。

#### 错误思路二

每个点连接到一个自己的倍数，再用并查集判环~~离正解只有一步之遥~~。

证伪思路同上。

### 正解

还是从较小点权连接到较大点权，但只要是自己的倍数而且没有环就连，再用质数倍数减少重复，就能过了这道题。

#### 正解代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define R(x) x=read()
#define P(x) put(x)
#define ENDL putchar('\n');
#define SPACE putchar(' ');
#define mp make_pair
using namespace std;
inline int read(){
	register int r=0,f=1;register char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		r=(r<<3)+(r<<1)+(c^'0');
		c=getchar();
	}
	return f*r;
}
inline void put(int x){
	if(x<0){
		x=-x;
		putchar('-');
	}
	if(x>9){
		put(x/10);
		x=x%10;
	}
	putchar(x^'0');
	return;
}
int n;
int prime[10001000],len;
bitset<10001000> vis;
template<int const _N=10001000>
struct union_find{
	int f[_N];
	inline int find(int x){
		while(x^f[x])x=f[x]=f[f[x]];
		return x;
	}
	inline void mrg(int x,int y){
		x=find(x);y=find(y);
		if(x^y)f[x]=y;
		return;
	}
	union_find(){
		for(int i=1;i<=_N-1;i++){
			f[i]=i;
		}
		return;
	}
};
union_find<> f;
int ans,cnt;
signed main(){
	R(n);
	for(int i=2;i<=n;i++){
		if(!vis[i])prime[++len]=i;
		for(int j=1;j<=len&&i*prime[j]<=n;j++){
			vis[i*prime[j]]=1;
		}
	}
	for(int i=n/2;i>0;i--){
		for(int j=1;prime[j]*i<=n;j++){
			int x=f.find(i),y=f.find(i*prime[j]);
			if(x^y){
				++cnt;
				ans+=i;
				if(cnt==n-1){
					P(ans);
					return 0;
				}
				f.mrg(x,y);
			}
		}
	}
	return 0;
}
```

---

## 作者：cogimyun (赞：5)

## 题目内容
ZHY 有一个 $n$ 个点的完全图，点 $u$ 与点 $v$ 的距离为 $\gcd(u,v)$，求这个完全图的最大生成树的边权之和。
## 思路
### 方法一
很明显这道题目是在求最大生成树，但由于数据中 $1≤n≤ 10^{7} $ ,明显不能使用暴力枚举每两个点之间的 $\gcd$，那么我们可以从每个点 $i$ 出发去找它的倍数 $j$，那 $ \gcd(i,j)=i$ ，当然由于最大生成树要求从边权大的边开始加边，所以 $i$ 应该从 $ \frac{n}{2} $ 开始递减寻找倍数(至于从 $ \frac{n}{2} $ 开始而不是从 $n$ 开始是因为 $ \frac{n}{2}+1 $ 到 $n$ 的所有数的倍数均超过了 $n$，无需枚举)但这个方法的时间复杂度仍然拿不了 100pts。
### 方法二
在方法一的基础上我们可以通过数论唯一分解定理，发现点 $i$ 与点 $j$ 之间，$j$ 只能是 $i$ 的质数倍，因为如果 $j$ 是 $i$ 的合数倍，$j$ 就会与它的所有因数存在连边，它的所有因数又会和 $i$ 存在连边，从而就形成了环，所以我们可以先进行一次欧拉筛，算出所有的质数，再从  $ \frac{n}{2} $  开始递减寻找质数倍数 $j$，跑一遍最大生成树即可。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[10000005];
typedef long long ll; 
const int N=1e7+5;
int cnt;
int book[N],prim[N],a,b;
int getf(int x)
{
	if(f[x]==x)
		return x;
	return f[x]=getf(f[x]);
}
void ol(int x)
{
	for(ll i=2;i<=x;i++)
	{
		if(book[i]==0)
		{
			prim[++cnt]=i;
		}
		for(int j=1;1ll*i*prim[j]<=x;j++)
		{
				book[i*prim[j]]=1;
				if(i%prim[j]==0)
					break;
		}	 
	 } 
} 
int main()
{
	int sum=0;
	cin>>n;
	ol(n); 
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
	}
	long long ans=0,m=0;
	for(int i=n;i>=1;i--)
	{
		for(int j=1;prim[j]*i<=n;j++)
		{
			int fx=getf(i),fy=getf(prim[j]*i);
			if(fx!=fy)
			{
				m++;
				f[fy]=fx;
				ans+=i;
				if(m==n-1)
				{
					cout<<ans;
					return 0;
				}
			}	
		}
	}
	return 0;
}
```

---

## 作者：Elairin176 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P9488)   
有意思。    
## 题意
一个 $n$ 个点的完全图，$i,j$ 两点之边的权值为 $\gcd(i,j)$，求最大生成树的权值和。   
## 解法
### $30pts$ 做法
我会模拟！我们直接模拟一遍题意就可以了。   
但是 $1\le n\le 10^7$，我们开不下数组，只能拿到 $30pts$。        
这个做法的复杂度是 $O(n^2\log n^2\alpha(n^2))$，时间也不行。
### $60pts$ 做法
我会观察！   
发现一棵树不能存在环，那么我们对于所有的 $i(1\le i\le n)$ 只需要和它的非本身倍数建边就可以了，这样可以排除许多无用边。   
之后，我们不需要进行 MST 算法了，直接放在循环中枚举即可。     
但是这样的复杂度是 $O(n\log n\alpha(n))$，对于 $100\%$ 的数据仍然 TLE。
### $100pts$ 做法
我懂数论！    
我们发现，一个结点一定不能和它合数倍的结点建边。    
- 为什么？

根据唯一分解定理，这个结点一定已经连接了新结点编号的一个质因子的结点，这个质因子也一定会连接这个合数结点。   

那么我们用这个方法建边就可以了。   
时间复杂度 $O(n\log\log n\alpha(n))$，可以通过。     
[CODE](https://www.luogu.com.cn/paste/izx4pg5v)

---

## 作者：COsm0s (赞：3)

## $\mathcal{Solution}$

+ 对于暴力，暴力最大生成树即可，采用 Kruskal。

	复杂度 $O(n^2)$。

+ 对于 $60$ 分，因为暴力的建边是 $n^2$ 的，我们对其进行优化。

	因为一棵树不能出现环，所以我们只需要将一个数本身与其倍数相连，这样既能保证最优，又优化了建图。
    
    此时复杂度 $O(n\log n\alpha (n))$。
 
+ 对于满分做法，我们在上面的基础上再次优化。

	我们知道任意自然数的唯一分解定理，即
    
    $n=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$。
    
    那么一个数就必定不能和其合数倍的数相连。
    
    因为任意一个合数都会和它的因数相连，而那个因数又和当前数相连，因此形成环。
    
    所以我们只需要让当前边与其质数倍的数连边即可。
    
    那么线性筛即可。
    
    复杂度 $O(n\log n\log n\alpha (n))$。

+ 最后注意，本题卡 `#define int long long`，只需要将答案的 $ans$ 设为 `long long` 类型即可。

## $\mathcal{Code}$

```cpp
#include<bits/stdc++.h>

using namespace std;

//#define int long long

const int N = 1e7 + 5;

int n;
long long ans;
int f[N];
int cnt, p[N];
bitset<N> prime;
struct node {
	int x, y, z;
} a[N];
int find(int x) {
	if (x == f[x]) return x;
	return f[x] = find(f[x]);
}
void merge(int x, int y) {
	int u = find(x), v = find(y);
	if (u == v) return ;
	f[v] = u;
}

signed main() {

	ios_base::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	for (int i = 2; i <= n; i ++) {
		if (!prime[i]) p[++ cnt] = i;
		for (int j = 1; j <= cnt && i * p[j] <= n; j ++) {
			prime[i * p[j]] = true;
			if (i % p[j] == 0) break;
		}
	}


	for (int i = 1; i <= n; i ++) f[i] = i;
	for (int i = n; i; i --)
		for (int j = 1; j <= cnt && i * p[j] <= n; j ++) {
			int x = i * (p[j] - 1), y = i * p[j];
			if (find(x) != find(y)) ans += i, merge(x, y);
		}
	//kruskal();

	cout << ans;
	return 0;
}
```



---

## 作者：NBest (赞：2)

[P9488 ZHY 的生成树](https://www.luogu.com.cn/problem/P9488)
## 前言
这道题就非常的巧，下午上午上课刚讲完筛法，下午就考到了一个很像筛法的题。当时看到这个数据范围尽往线性做法想了，后面实在想不到就开始想如何带 $\log$ 做，先拿个 $60$pts 再说。
# 思路
看到这样的求最大生成树，首先先排除真的两两连边跑 Prim，当然你可以通过这样拿到 $30$pts，但是我觉得码量太大不如想贪心做法。

一开始想到从大到小枚举每个数的每个因数和因数的倍数计算 $\gcd$，但是考虑到这样不一定最优，得把所有情况都枚举出来并且还得排序，不如把 $n$ 折半，然后从大到小枚举倍数，这样我们可以保证连的边最大并且值就是本身。

如果你直接这么打，显然会连第二个样例都过不了，会发现大了不少，这是为什么呢？因为题目让你求的是一棵树啊，每个点至少要连一条边，如果这样枚举会导致大质数不被连到。那如果你再加个数组判断每个数有没有被连到，还是会发现大了不少，因为树要保证点与点之间的联通性，你直接盲目连会导致最后出现的不是一棵树，而是一片森林。

在我把后面的暴力打完之后，我重新来思考这道题。联通性？那不如直接先把所有点连到 $1$，然后再用上面的方法直接改变两条边的连接方式使其仍然联通，也就是判断两个点之间是否已经连过，然后断掉其中一个点连向 $1$ 的边，建一个两点之间的边。如何判断是否连过？当然是并查集啊！判断两个点是否不经过 $1$ 联通即可。
#### $60$ pts $Code$
```cpp
ll n,ans,fa[10000006];
inline ll find(ll x){
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
int main(){
    cin>>n;ans=n-1;
    for(ll i=1;i<=n;i++)fa[i]=i;
    for(ll i=n/2;i>1;--i){
        for(ll j=i*2;j<=n;j+=i){
            if(find(i)!=find(j))fa[find(i)]=find(j),ans+=i-1;
        }
    }
    cout<<ans;
}
```
之后我一直以为瓶颈在并查集，因为我发现去掉并查集后跑的飞快。结果赛后参考了一下题解，发现每次乘的时候不应该一个一个乘，发现有很多次重复，发现如果加的是合数，那肯定前面已经有是你的倍数比你贡献大的连过了，那此时肯定会出现连过的情况。所以我们直接每次乘质数即可，与埃氏筛神似。
#### $Code$
```cpp
int n,tot,fa[10000006],prime[10000004];
bool vis[10000004];
ll ans;
inline int find(int x){
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
inline void init(){
    for(int i=2;i<=10000000;i++){
        if(!vis[i])prime[++tot]=i;
        for(int j=1;j<=tot&&i*prime[j]<=10000000;j++){
            vis[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
}
int main(){
    cin>>n;  
    ans=n-1;
    init();
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=n/2;i>1;--i){
        for(int j=1;j<=tot&&i*prime[j]<=n;j++){
            if(find(i)!=find(prime[j]*i))fa[find(i)]=find(prime[j]*i),ans+=i-1;
        }
    }
    cout<<ans;
}
```

---

## 作者：zzy0618 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P9488)

### 解题思路

以 Kruskal 为基础。如果暴力建边，可以过前两个点。代码就不多说。

Kruskal 其中并查集的思想我们可以继续使用。我们发现，对于节点 $i$，如果向 $i$ 的倍数延伸边，其贡献最大。所以我们从大到小枚举节点，向其倍数延伸边，遇到不属于同一集合的，便建边，将 $ans+i$。

```cpp
for(i=n/2+1;i>=1;i--){
	for(j=2;i*j<=n;j++){
		if(find(i)!=find(i*j)){
			fa[find(i)]=find(i*j);
			ans+=i;
		}
	}
}
```

这个代码的复杂度为 $O(n\log n \alpha (n))$，可以拿到 $60$ 分。

观察以上代码，会发现同一节点被枚举了多次，有一些多余的计算。但这个循环，怎么有点眼熟呢？

对了，这很像埃氏筛。既然质数筛有优化，我们的枚举为什么不能有优化？我们可以提前用欧拉筛处理好 $10^7$ 以内的质数，再仿照欧拉筛的方式进行质数倍数枚举，但又稍有不同，具体方式见代码。

这时有的同学就会有疑问了，凭什么按质数枚举呢？难道不会遗漏吗。设当前节点为 $i$，如果有一个合数 $j$ 倍数，那么不如将 $j$ 因子提出来，乘到 $i$ 中，对 $ans$ 但贡献更大。而更大的节点，我们已经枚举过了。

### 完整代码

几点提醒：

- 要开 ```long long```。

- 质数的数组不要开大了，不然会爆空间。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=10000005;
int n,ans=0,fa[N],cnt;
int prime[N>>2];
bool st[N];
inline int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}//并查集
signed main(){
	register int i,j;
    cin>>n;
	for(i=2;i<=n;i++){
    	if(st[i]==0)prime[cnt++]=i;
    	for(j=0;prime[j]*i<=n&&j<cnt;j++){
        	st[prime[j]*i]=1;
        	if(i%prime[j]==0)break;
    	}
	}//O(n)初始质数
    for(i=1;i<=n;i++)
		fa[i]=i;
    for(i=n;i>=1;i--){
		for(j=0;i*prime[j]<=n&&j<cnt;j++){
			if(find(i)!=find(i*prime[j])){
				fa[find(i)]=find(i*prime[j]);
				ans+=i;
			}//这里的 break 要去掉，所以复杂度不是严谨的 O(n)
		}
	}
	cout<<ans;
    return 0;
}
```



---

## 作者：RyanRyan (赞：0)

## 洛谷P9488

[更好的阅读体验](https://www.luogu.com.cn/blog/679623/p9488-zhy-di-sheng-cheng-shu-ti-xie)

[题目链接](https://www.luogu.com.cn/problem/P9488)

既然要求一个图的最大生成树，可以用 $\texttt{kruskal}$ 算法的思想：

按边权从大到小加边，具体过程如下

假设已经枚举完了边权为 $i + 1$ 的边，现在枚举边权为 $i$ 的边。容易发现，边权为 $i$ 的边的两个端点一定是 $i$ 的倍数。如果第 $x \times i$ 个点与第 $y \times i$ 个点不连通，则 $\gcd(x \times i, y \times i) \leq i$ 且 $\gcd(x, y) = 1$，也就是将 $i$ 与 $i$ 的素数倍的点连一条长度为 $i$ 的边。

将 $i$ 与 $i$ 的素数倍的点连一条长度为 $i$ 的边，就可以将 $i$ 的倍数的所有点连通。可以维护一个并查集，使用按秩合并和路径压缩即可。

$\texttt{c++}$代码:
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e7 + 10;
int n;
int p[N];
bool f[N];
int primes[N], cnt;
bool st[N];
int gcd(int a, int b){
    return b ? gcd(b, a % b) : a;
}
int find(int x){ // 并查集查找 + 路径压缩
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
void get_primes(int n){ // 可以先预处理出1~n的所有质数
    for (int i = 2; i <= n; i ++ ){
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ ){
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
int main(){
    cin >> n;
    get_primes(n);
    for (int i = 1; i <= n; i ++ ) p[i] = i;
    long long res = 0; // 答案有可能爆int, 注意开long long
    for (int i = n; i >= 1; i -- )
        for (int j = 0; j < cnt && primes[j] <= n / i; j ++ )
            if(find(i) != find(i * primes[j])){
                res += i;
                p[find(i * primes[j])] = find(i);
            }
    cout << res << "\n";
}
 
```

---


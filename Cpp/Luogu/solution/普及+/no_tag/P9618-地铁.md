# 地铁

## 题目背景

> 两年级生 孤单一人
>
> 仰望上空 陋市苍穹
>
> 在宇宙这个约会室中
>
> Maybe 我们只是刚好没能邂逅呢

## 题目描述

著名工程学专家 625OutContradiction 设计了一张地铁交通网 $G$．$G$ 拥有 $n$ 个站点和 $m$ 条地铁线路．

第 $i$ 条地铁线路 $P_i$ 会经过交通网上的若干站点，形如 $P_i=(u_1,u_2,u_3,...,u_{k_i})(k_i>0)$：每两个相邻站点 $u_j,u_{j+1}(j<k_i)$ 之间存在一段属于线路 $i$ 的从 $u_j$ 通向 $u_{j+1}$ 的单向地铁轨道．保证一条地铁线路不重复经过同一站点．但一个站点可能被若干条地铁线路经过．

丹羽和艾莉欧准备从 $1$ 号站点前往 $n$ 号站点．然而他们的自行车坏掉了，只好准备乘坐地铁．现在他们需要决定出行的方案．

一种出行方案具体是这样的：从 $1$ 号站点出发，选定一条经过 $1$ 号站点的地铁线路并开始乘坐地铁．沿当前地铁线路乘坐地铁的过程中，可以选择换乘其他任意一条经过当前站点的地铁线路．要求最终到达 $n$ 号站点．乘坐地铁过程中重复经过某一站点或某段地铁轨道是被允许的．

**请注意：从 $1$ 号站点出发，第一次乘坐地铁不被算作换乘．**

艾莉欧提出了 $q$ 个问题．对于每个问题，艾莉欧会提供三个参数 $a, b, c$．在这次问题中，一个出行方案如果经过了 $x$ 段地铁轨道并进行了 $y$ 次换乘，那么它的疲惫值为 $ax+by$．您需要回答换乘次数不超过 $c$ 的出行方案中最小的疲惫值是多少．

## 说明/提示

### 样例 #1 说明
$1\rightarrow 2\rightarrow 3\rightarrow 4\rightarrow 5$ 是给出的第一条地铁线路，$1\rightarrow 3$，$2\rightarrow 4\rightarrow 5$ 是第二三条地铁线路．

对于第一二组询问，均存在一种最优的出行方案为，在 $1$ 站点搭乘第二条地铁线路到达 $3$ 站点，在 $3$ 站点换乘第一条地铁线路到达终点；共经过 $3$ 段地铁轨道，并进行了 $1$ 次换乘，故第一二组询问的答案分别为 $3\times 1+1\times 1=4$，$3\times 3+1\times 0=9$．对于第三组询问，由于换乘的代价较大，最优的方案为顺着第一条地铁线路一直通向终点，途径 $4$ 段地铁轨道，答案为 $4$．

### 数据点约束
对于所有数据满足：

$1\le n \le 10^5$，$1\le m \le 10^4$，$1\le q \le 10^5$，$\sum k_i \le 3\times 10^5$．

$0 \le a,b \le 10^6$，$0 \le c \le 20$．

---
对于 $10\%$ 的数据满足：$n \le 20$，$\sum k_i \le 40$，$q \le 30$．

---

对于另外 $20\%$ 的数据满足：$c=0$．

---

对于另外 $30\%$ 的数据满足：$q=1$．

---

题目中可能存在只经过一个地铁站的地铁线路．这种线路可以直接忽视．数据保证：对于任意一组询问，存在一条合法的路线可以到达终点．

## 样例 #1

### 输入

```
5 3 3
5 1 2 3 4 5
2 1 3
3 2 4 5
1 1 1
3 0 2
1 5 2
```

### 输出

```
4
9
4
```

## 样例 #2

### 输入

```
10 7 10
10 1 2 3 4 5 6 7 8 9 10
5 3 8 5 1 6
2 1 6
4 3 7 8 5
1 1
2 10 2
6 8 4 7 3 1 5
5 10 6
17 14 0
11 14 5
8 8 3
8 13 9
11 2 9
7 1 6
11 11 8
15 3 0
0 17 4
```

### 输出

```
35
153
69
48
53
57
36
66
135
0
```

## 样例 #3

### 输入

```
10 7 10
10 1 2 3 4 5 6 7 8 9 10
3 2 7 1
3 5 10 9
2 2 7
5 4 8 1 7 2
3 10 9 4
4 2 1 7 8
18 6 0
16 11 0
18 1 0
14 0 0
19 14 0
3 2 0
18 15 0
5 18 0
2 17 0
20 10 0
```

### 输出

```
162
144
162
126
171
27
162
45
18
180
```

# 题解

## 作者：Suite_No1_G (赞：4)

建议评绿/蓝。

分析：

一看就是很明显的最短路问题。

观察到讯问中的 $c ≤ 20$，所以可以用 $O(qc)$ 的复杂度处理询问。

设 $dp_i,_j$ 表示到第 $i$ 个点，换乘了 $j$ 次的最短路径长度，于是答案就成为了所有 $a \times dp_n,_i + b \times i$ 的最小值。

由于有换乘，可以想到分层图。

由于 $m$ 可能会很大，所以不可能对一条地铁线路建一层。

建一个不到 $20$ 层的分层图，因为如果换乘次数超过 $20$ 的话询问不会考虑到。

用分层图跑一下最短路即可。为了节省内存，我们对 $n$ 个节点都建了一个虚点处理换乘。详细做法见代码。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=4e5+10;//注意数组范围，最大为sigma(ki)+n，即4e5 
int a[maxn];//输入顺序的第i个点的实际点为a[i] 
int tot=0;

struct edge{//边，to表示到哪个点，tran表示是否换乘，d表示边的长度 
	int to;
	int tran;
	int d;
};

vector<edge> G[maxn];//图 
int dist[maxn];
vector<int> belong[maxn];//输入顺序的第i个点的真实点 
int n,m,q;

struct point{//点，用于dijkstra算法。 
	int u;//节点编号 
	int tran;//换乘了几次 
	int d;//距离 
	
	bool operator <(const point &cmp) const{//重载运算符 
		return d>cmp.d;
	}
};

int dp[maxn][25];

void dij(){//dijkstra 
	priority_queue<point> q;
	while (!q.empty()) q.pop();
	
	for (int i=1;i<=4e5;i++){
		for (int j=0;j<25;j++) dp[i][j]=1e9+7;//初始化成极大值 
	}
	
	//将编号为1的点放入优先队列 
	for (int i=1;i<=tot;i++){
		if (a[i]==1){//a[i]的定义见主函数。 
			q.push((point){i,0,0});
			dp[i][0]=0;
		}
	}
	
	while (!q.empty()){
		point f=q.top(); q.pop();
		int u=f.u,tran=f.tran,d=f.d;
		
		if (d>dp[u][tran]) continue;//减少很多无用的松弛 
		
		for (int i=0;i<(int)G[u].size();i++){
			int v=G[u][i].to;
			if (tran+G[u][i].tran>21) continue;//特判，如果超过20则无意义 
			
			if (dp[v][tran+G[u][i].tran]>dp[u][tran]+G[u][i].d){//松弛 
				dp[v][tran+G[u][i].tran]=dp[u][tran]+G[u][i].d;
				q.push((point){v,tran+G[u][i].tran,dp[v][tran+G[u][i].tran]});
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	 
	
	for (int i=1;i<=m;i++){
		int cnt;
		scanf("%d",&cnt);
		if (cnt==1){//如果地铁线路长度为1，则这条地铁没有意义 
			int unu; scanf("%d",&unu); continue;
		}
		
		int u;
		scanf("%d",&u);
		a[++tot]=u;//输入的第tot个点，真实点为u 
		belong[u].push_back(tot);
		cnt--;
		
		
		while (cnt--){//前面一个点向后面的点连边 
			int now;
			scanf("%d",&now);
			a[++tot]=now;
			belong[now].push_back(tot);//输入的第tot个点，真实点为now 
			G[tot-1].push_back((edge){tot,0,1});//路程为1，不需要换乘 
			
		}
	}
	
	for (int i=1;i<=n;i++){
		int to=i+tot;//虚点 
		for (int j=0;j<(int)belong[i].size();j++){
			int u=belong[i][j];
			G[u].push_back((edge){to,0,0});
			G[to].push_back((edge){u,1,0});
			//如果a[x]=a[y]，那么这两条单向边保证了从x到y需要换乘1次，距离为0 
		}
	}
	
	dij();
	for (int i=0;i<=30;i++) dist[i]=1e9+7;//dist[i]为到n点换乘i次的最短路径长度，初始化为极大值 
	for (int i=0;i<(int)belong[n].size();i++){
		int u=belong[n][i];
		
		for (int j=0;j<=20;j++) dist[j]=min(dist[j],dp[u][j]);//更新到n点换乘j次的最短距离 
	}
	
	while (q--){
		int k1,k2,c;
		scanf("%d%d%d",&k1,&k2,&c);
		long long ans=1e12;
		for (int i=0;i<=c;i++){//枚举换乘几次 
	//		printf("%d %d\n",dist[i],i);
			ans=min(ans,1ll*k1*dist[i]+1ll*k2*i);
		}
		printf("%lld\n",ans);
	}
	return 0;
} 
```
开 O2 就能过了。

---

## 作者：TianLuen (赞：2)

关键词：最短路、图论建模

## 题意简述

- 给定 $n$ 个地铁站。给定 $m$ 条单向地铁，每条地铁给定 $k_i$ 个站点。
- 给定 $q$ 次查询。
- 对于每次查询，给定 $a,b,c$ 三个数。$a$ 代表每坐一站的代价，$b$ 代表每换乘一次的代价，$c$ 代表至多只能换乘 $c$ 次。输出从 $1$ 坐车到 $n$ 的最小代价。保证有解。

## 题意分析

突破口在于 $c$ 的范围。发现 $c$ 是不超过 $20$ 的，这代表着最多只会换乘 $20$ 次。

先看看如何计算代价。

我们可以预处理出数组 $t$：经过 $i$ 次换乘，从 $1$ 走到 $n$ 最少需要坐多少站。查询时枚举换乘的次数，代价为 $(a\times t_i+b\times i)$，取最小值。预处理交给单源最短路。

接下来是如何建图。也是本题关键点。

首先想到的是分层图模型。当然，本题直接建分层图很可能让空间过不去。（显然，是按换乘的次数进行分层，同一层内不能换地铁线路。）

鉴于每一层的图是完全一致的，不妨在同一层上跑很多遍最短路（而非在很多层上跑一遍最短路）。跑完一次后，将 $1$ 号点与其它点连一条边，长度为刚刚算出来的最短距离。这样，就维护好了结果，可以继续跑下一轮最短路了。

以下直接给出我的建图方法：

1. 对于 $n$ 个点，每个点拆成源、汇两点。
2. 每条地铁线的每个站都**单独**开一个点，依次连接，长度 $1$。
3. 每个源点，它向所有对应的站连边，长度 $0$。
4. 每个汇点，所有对应的站向它连边，长度 $0$。
5. 每次跑完最短路之后，$1$ 号源向其他所有源连边，长度为上一轮 $1$ 号源到 $i$ 号汇的最短距离。

因为 $c$ 最大 $20$，所以跑 $21$ 遍 dijkstra 即可。

时间复杂度正确，注意常数优化。

## 参考代码

这里给出主函数部分。

```
#include<bits/stdc++.h>
using namespace std;
const int C=21;
int aans[30];
int main()
{
    G::init();
    int n,m,q;
    n=read();
    m=read();
    q=read();
    G::total_point=n;
    int sum=n*2;
    for(int i=0;i<m;i++)
    {
        int k=read();
        int lst=read();
        G::link(lst,sum+1,0);
        for(int j=1;j<k;j++)
        {
            int x=read();
            G::link(sum+1,sum+2,1);
            G::link(x,sum+2,0);
            G::link(sum+2,x+n,0);
            sum++;
        }
        sum++;
    }
    G::dijkstra(1);
    aans[0]=G::distance[n+n];
    for(int i=1;i<C;i++)
    {
        for(int j=2;j<=n;j++)
            G::link(1,j,G::distance[n+j]);
        G::dijkstra(1);
        aans[i]=G::distance[n+n];
    }
    while(q--)
    {
        long long a=read();
        long long b=read();
        long long c=read();
        long long ans=LONG_LONG_MAX;
        for(int i=0;i<=c;i++)
            if(aans[i]!=INT_MAX)
                ans=min(ans,1ll*aans[i]*a+i*b);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：Nine_Suns (赞：1)

赛时没看见 $c\le20$ 的条件白想了半天。

由于 $c\le20$，考虑枚举 $c$，将询问按照 $c$ 的大小离线计算。

对于一个询问，考虑小于 $c$ 的每个 $y$，显然此时令 $x$ 最小即可。

假设此时求出了换乘不超过 $k$ 次时的最短距离，由于只有一次换乘，所以不会存在 $A$ 更新 $B$，$B$ 用被更新的值再更新 $C$ 的情况，所以直接枚举每条地铁线路维护乘上车的最短距离进行朴素递推即可。

复杂度 $O(c\sum k_i)$。

[Code](https://www.luogu.com.cn/paste/c5xg7k1t)

---

## 作者：qzmoot (赞：1)

# 题意
给 $n$ 个地铁，$m$ 条边，每个地铁有 $k$ 个站点。

问你 $q$ 次，每次给你做车的代价，换乘的代价，最多能换乘的次数。
# 分析一波
很重要一个点啊，（敲黑板），**$c$ 不超过 $20$**。

有了这一点之后，你就不用再担心时间复杂度上的问题了，但是如果无脑甩分层图，可能会空间爆炸，最好的办法是对每条地铁建。

最后直接写 dijkstra 加上优先队列优化，并记录下转车次数即可。

---

## 作者：SnowTrace (赞：1)

咱就是说，你把这玩意放在**对标 NOIP 难度**比赛的 T1 是不是不大合理啊...

std 的分层图最短路根本看不懂，自己来写一发.

发现题中有个限制是 $c\leq20$，是分层图最短路，比较显然，我们可以直接固定转车次数再算出次数最少需要经过多少条轨道.

发现转车的这个限制其实并不好处理，因为很难说清楚现在是处于哪个轨道上，所以我们考虑直接枚举转车点，也就是，在转车点直接连一些边再算出这一条边上经过了多少个轨道，也就是相当于每走过这样一条边转车次数加一.

然后我们发现如果真的把所有的处在同一条轨道上的**可以转车**的点连起来的话好像有点麻烦，还不如直接把处在同一条轨道上的任意两点连一条边.这样会多连一些边（也就是明明从一个转车点走到另一个转车点，但是实际上走的轨道却并没有发生变化，这样的边显然没有意义，所以也不会影响答案.对于所有点两两连边复杂度显然会炸，但是我们显然可以写一个前缀优化建图.

具体来说对于长度为 $n$ 的一条链 $a$ 新建 $n-1$个 $suf$ 节点.$suf_i$ 表示这个点和在链中位置在 $i$ 和 $i$ 以后的点都可以相连，然后 $suf_i$ 连向 $suf_{i+1}$，$suf_i$ 连向 $a_i$，$a_{i-1}$ 连向 $suf_i$，这样建图可以使得对于$a_i$，它可以到达任意 $a_k$，其中 $k\geq i $.

然后我们按照上面所说的层数和边数的意义给这个建出来的新图重新赋边权就可以了，最后跑个最短路，每次查询先枚举转车多少次，然后根据求得的最短路取最小值.

出题人素质比较低不给我开 O2，然后我写了个 deque，跑的巨慢.

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
int dis[500005][23],a[500005];
vector<pair<int,pair<int,int> > >p[500005];
//p[now][i].second.first 是层数的权值
//p[now][i].second.second 是边数的权值
int nw;
void solve(){
	memset(dis,63,sizeof(dis));dis[1][0] = 0;
	deque<pair<int,int> >q;q.push_back({1,0});
	while(!q.empty()){
		int now = q.front().first,j = q.front().second;q.pop_front();
		if(j>=22)continue;//如果转车次数超过22次那么对于答案肯定没用了，直接剪枝，但是注意这里不能用break，因为我们保证了边数的值是单调的，但没有保证层数的值是单调的
		for(int i =0;i<p[now].size();i++){
			int to = p[now][i].first,cost = p[now][i].second.second,c = p[now][i].second.first;
			if(dis[now][j]+cost<dis[to][j+c]){
				dis[to][j+c] = dis[now][j]+cost;
				if(!cost)q.push_front({to,j+c});
				else q.push_back({to,j+c});
			}
		}
	}//最短路板子，因为发现边数的权值只有0和1，所以可以直接bfs，但是写了个deque常数比较大
}signed main(){
	cin >> n >> m >> q;nw = n;
	for(int i = 1;i<=m;i++){
		int k;cin >> k;
		for(int j = 1;j<=k;j++)cin >> a[j];
		for(int j = k;j>1;j--){
			int now = ++nw;
			p[nw].push_back({a[j],{0,1}});
			p[a[j-1]].push_back({nw,{1,0}});
			if(j!=k)p[nw].push_back({nw-1,{0,1}});
        //前缀优化建图
		}
	}solve();
	while(q--){
		long long a,b,c;cin >> a >> b >> c;
		long long ans = 1e18;
		for(int i = 1;i<=c+1;i++){
			ans = min(ans,a*(dis[n][i])+b*(i-1));
		}cout << ans << '\n';
	}
}
```


---

## 作者：ztrztr (赞：0)

写个题解记录一下思路。

感谢 [@TianLuen](https://www.luogu.com.cn/user/239988) 大佬提供了一些思路。

## 思路
我们可以先考虑不换乘的情况：这种情况下直接每一条地铁的车站都作为独立的点（也就是即使编号相同也不是同一个点），然后暴力跑最短路就行。

如果要换乘，假设最多换乘一次。那么我们假设在 $x$ 这个点换乘，换到第 $i$ 条地铁，令 $dis[1][x]$ 为从 $1$ 到 $x$ 的最短路径，$s[i][x][n]$ 为第 $i$ 个地铁从 $x$ 到 $n$ 的距离。

我们发现换乘意味着 $dis[1][x] + s[i][x][n]$ 比原本的 $dis[1][n]$ 更优，所以可以直接枚举所有有可能的换乘，然后取最优情况。

我们发现，每一次换乘都可以按照这个规律来弄，而且题目规定了换乘最多换乘 $20$ 次，那么我们遍历换乘次数从 $0$ 到 $20$，然后计算答案统计一下就行，因为在 $y$ 一定的情况下，由于 $a$ 和 $b$ 都是正数，所以 $x$ 越小 $ax + by$ 就最小。

但是这样的话会发现复杂度有可能太大，导致超时，于是我们需要想一个办法，不用每次都遍历一遍所有可能的换乘点和换乘地铁。我们发现，如果换乘更优，那么我们可以考虑在图上面建一条从 $1$ 到 $x$ 的边，边权为 $dis[1][x]$，那么如果换乘更优，答案就会更新。

## 实现
为了简化我们的代码，我们可以考虑把每个点分成“源点”和“汇点”（感谢 [@TianLuen](https://www.luogu.com.cn/user/239988) 大佬在题解中提供了这个思路），每个源点连接所有对应的站点，所有站点连接对应的汇点，这两种边的边权都为 $0$。

答案就是从 $1$ 的源点出发到 $n$ 的汇点。

这样，可以有效的简化代码，也可以保证代码的正确性（不能换乘的话怎么都不可能换乘）。

还有一个优化就是在重跑最短路的时候，不要直接加边，因为之前加的边的边权一定大于等于新加的边，所以我们可以先删掉原来的边，再加边。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
/*
*/
int n, m, q, k[1000005], u[1000005], kk[1000005], uu[1000005];
map <int, vector<int> > mp, a, b, mpp;
vector <int> e[500005], v[500005];
int tot = 0;
int vx[1000005], vy[1000005];
int vis[1000005];
struct node {
    int d, p;
    const bool operator <(const node x) const {
        return d > x.d;
    }
};
int dis[1000005];
int cnt = 0;
void dij(int s) {
    priority_queue <node> q;
    for(int i = 1; i <= cnt; i ++) dis[i] = 2147483647;//
    memset(vis, 0, sizeof vis);
    dis[s] = 0;
    q.push((node){0, s});
    while (q.size()) {
        int nw = q.top().p;
        // cout << nw << " " << q.top().d << "\n";
        q.pop();
        if (vis[nw]) continue;
        vis[nw] = 1;
        for (int i = 0; i < e[nw].size(); i ++) {
            int to = e[nw][i];
            if (dis[to] > dis[nw] + v[nw][i]) {
                dis[to] = dis[nw] + v[nw][i];
                if (vis[to] == 0) q.push((node){dis[to], to});
            }
        }
    }
}
int anss[1000005];
signed main() {
    // ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n >> m >> q;
    for (int i = 1; i <= m; i ++) {
        int tmp; cin >> tmp;
        for (int j = 1; j <= tmp; j ++) {
            cin >> u[j];
            cnt ++;
            mp[u[j]].push_back(i);
            mpp[u[j]].push_back(cnt);
            a[i].push_back(u[j]);
        }
    }
    int tmp = cnt; cnt = n * 2;
    for (int i = 1; i <= m; i ++) {
        cnt ++;
        e[a[i][0]].push_back(cnt);
        v[a[i][0]].push_back(0);
        // e[cnt].push_back(a[i][0] + n);
        for (int j = 1; j < a[i].size(); j ++) {
            int x = a[i][j];
            cnt ++;
            e[cnt - 1].push_back(cnt);
            e[x].push_back(cnt);
            e[cnt].push_back(x + n);
            v[cnt - 1].push_back(1);
            v[x].push_back(0);
            v[cnt].push_back(0);
        }
    }
    // for (int i = 1; i <= cnt; i ++) {
    //     if (e[i].size()) {
    //         cout << i << " : ";
    //         for (int j = 0; j < e[i].size(); j ++) {
    //             cout << e[i][j] << " ";
    //         }
    //         cout << "\n";
    //     }
    // }
    dij(1);
    anss[0] = dis[n * 2];
    int C; C = 21;
    vector <pair<int, int> > olde;
    for (int j = 1; j <= 20; j++) {
        olde.clear();
        for (int i = 0; i < e[1].size(); i++) {
            if (v[1][i] == 0) { 
                olde.emplace_back(e[1][i], 0);
            }
        }
        e[1].clear();
        v[1].clear();
        for (auto &edge : olde) {
            e[1].push_back(edge.first);
            v[1].push_back(edge.second);
        }
        for (int i = 2; i <= n; i++) {
            if (dis[i+n] < 2147483647) {
                e[1].push_back(i);
                v[1].push_back(dis[i+n]);
            }
        }
        dij(1);
        anss[j] = dis[2*n];
    }
    // cout << tot << "\n";
    // for (int i = 0; i <= C; i ++) {
    //     cout << anss[i] << " " << i << "\n";
    // }
    for (int i = 1; i <= q; i ++) {
        int aa, bb, cc;
        cin >> aa >> bb >> cc;
        int ans = 1e18;
        for (int j = 0; j <= cc; j ++) {
            ans = min(ans, aa * anss[j] + bb * j);
        }
        cout << ans << "\n";
    }
    return 0;
}
```

---


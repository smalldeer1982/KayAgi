# [CSP-J 2023] 旅游巴士

## 题目描述

小 Z 打算在国庆假期期间搭乘旅游巴士去一处他向往已久的景点旅游。

旅游景点的地图共有 $n$ 处地点，在这些地点之间连有 $m$ 条道路。其中 $1$ 号地点为景区入口，$n$ 号地点为景区出口。我们把一天当中景区开门营业的时间记为 $0$ 时刻，则从 $0$ 时刻起，每间隔 $k$ 单位时间便有一辆旅游巴士到达景区入口，同时有一辆旅游巴士从景区出口驶离景区。

所有道路均只能**单向通行**。对于每条道路，游客步行通过的用时均为恰好 $1$ 单位时间。

小 Z 希望乘坐旅游巴士到达景区入口，并沿着自己选择的任意路径走到景区出口，再乘坐旅游巴士离开，这意味着他到达和离开景区的时间都必须是 **$k$ 的非负整数倍**。由于节假日客流众多，**小 Z 在旅游巴士离开景区前只想一直沿着景区道路移动，而不想在任何地点（包括景区入口和出口）或者道路上停留**。

出发前，小 Z 忽然得知：景区采取了限制客流的方法，对于每条道路均设置了一个
“开放时间”$a _ i$，游客只有**不早于 $a _ i$ 时刻**才能通过这条道路。

请帮助小 Z 设计一个旅游方案，使得他乘坐旅游巴士离开景区的时间尽量地早。

## 说明/提示

**【样例 #1 解释】**

小 Z 可以在 $3$ 时刻到达景区入口，沿 $1 \to 3 \to 4 \to 5$ 的顺序走到景区出口，并在 $6$ 时刻离开。

**【样例 #2】**

见附件中的 `bus/bus2.in` 与 `bus/bus2.ans`。

**【数据范围】**

对于所有测试数据有：$2 \leq n \leq 10 ^ 4$，$1 \leq m \leq 2 \times 10 ^ 4$，$1 \leq k \leq 100$，$1 \leq u _ i, v _ i \leq n$，$0 \leq a _ i \leq 10 ^ 6$。

| 测试点编号 | $n \leq$ | $m \leq$ | $k \leq$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ |$15$ | $100$ | $a _ i = 0$ |
| $3 \sim 5$ | $10$ | $15$ | $100$ | 无 |
| $6 \sim 7$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $1$ | $a _ i = 0$ |
| $8 \sim 10$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $1$ | 无 |
| $11 \sim 13$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | $a _ i = 0$ |
| $14 \sim 15$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | $u _ i \leq v _ i$ |
| $16 \sim 20$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | 无 |

## 样例 #1

### 输入

```
5 5 3
1 2 0
2 5 1
1 3 0
3 4 3
4 5 1```

### 输出

```
6```

# 题解

## 作者：Genius_Star (赞：172)

### 题意：

给出一个有向图，当前在 $1$ 号点，初始在时间 $0$，必须在 $k$ 的倍数的时间出发，且到终点的时间也必须是 $k$ 的倍数。

每条边有一个边权 $w_i$，只有在当前时间 $\ge w_i$ 时才可以通过，且不能在原地不动，即每一个时间点必须走一条边。

问从 $1$ 号点出发到 $n$ 号时最早的时刻。（没有方案则输出 $-1$）

### 思路：

因为 $k \le 100$ 很小，所以我们可以从 $k$ 入手。

注意到，如果我当前到达了 $u$ 号点，且当前时间为 $p$，这条边边权为 $w$，如果 $p < w$，那么显然当前不能通过。

但是因为如果当前可以走到这个点，那么可以晚一些 $k$ 的倍数的时间出发，依然可以走到这个点，则我们可以在入口处等待一些时间，使得可以通过这条边，等待时间为 $\lceil \frac{w-p}{k} \rceil \times k$，即等待 $\lceil \frac{w-p}{k} \rceil$ 个 $k$ 的倍数，这样就可以通过这条边了，耗费时间为 $\lceil \frac{w-p}{k} \rceil \times k+p$。

现在通过每条边的时间更出发点为 $k$ 的倍数有关系，则我们可以建立以下状态：定义 $dis_{i,j}$ 为到达 $i$ 号点的时间 $\bmod k$ 的值为 $j$ 时的最短消耗时间。

那么答案显然是 $dis_{n,0}$。

然后看一下转移，如果 $p \ge w$ 了，那么可以直接通过，则 $dis_{v,(p+1) \bmod k} \to \min(dis_{v,(p+1) \bmod k},p+1)$。

否则的话，令 $t=\lceil \frac{w-p}{k} \rceil \times k+p$，即我们在入口处等待一些时间，使得可以走到这条边，转移为 $dis_{v,(t+1) \bmod k} \to \min(dis_{v,(t+1) \bmod k},t+1)$。

可以运用 dijkstra 算法的思想来进行转移，每次去堆顶选取耗时最短的那个点，然后逐层松弛。

时间复杂度为：$O(n \times k \log n)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=10010,M=105;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,k;
ll dis[N][M];
bool f[N][M];
vector<pair<ll,ll>> E[N];
priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> q;
void add(ll u,ll v,ll w){
	E[u].push_back({v,w});
}
void dijkstra(ll s){
	dis[s][0]=0;
	q.push({0,s});
	while(!q.empty()){
		ll u=q.top().second,p=q.top().first;
		q.pop();
		if(f[u][p%k])
		  continue;
		f[u][p%k]=1;
		for(auto d:E[u]){
			ll v=d.first,w=d.second,t=(p+1)%k;
			if(p>=w)
			  t=p;
			else
			  t=((w-p+k-1)/k)*k+p;
			if(dis[v][(t+1)%k]>t+1){
				dis[v][(t+1)%k]=t+1;
				q.push({t+1,v});
			}
		}
	}
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	n=read(),m=read(),k=read();
	for(int u,v,w,i=0;i<m;i++){
		u=read(),v=read(),w=read();
		add(u,v,w);
	}
	dijkstra(1);
	if(!f[n][0])
	  puts("-1");
	else
	  write(dis[n][0]);
	return 0;
}
```


---

## 作者：OMG_wc (赞：101)

>这题如果啥都不会，千万别忘了输出 $-1$ 祈求 CCF 的施舍，能骗多少分就看缘分了

注意到 $k\le 100$，显然是一个分层图问题，即图上每个点要拆分成 $k$ 个状态。

对所有满足特殊性质 $a_i=0$ 的点，没有时间限制，那肯定是 $0$ 时刻来到起点啊。直接在分层图上用 BFS 跑最短路即可，这样就有 $35$ 分啦！

具体地，设 $d_{i,j}$ 表示到 $i$ 这个点满足时间 $\bmod k=j$ 的最短时间，初始 $d_{1,0}=0$，目标求 $d_{n,0}$，参考代码如下：

```c++
vector<pair<int, int>> G[N];
int d[N][105];
int main() {
    int n, m, kk;
    scanf("%d%d%d", &n, &m, &kk);
    while (m--) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        G[u].push_back({v, w});
    }
    memset(d, -1, sizeof d);
    queue<pair<int, int>> q;
    d[1][0] = 0;
    q.push({1, 0});
    while (q.size()) {
        auto [u, i] = q.front();
        q.pop();
        for (auto [v, w] : G[u]) {
            int j = (i + 1) % kk;
            if (d[v][j] == -1) {
                d[v][j] = d[u][i] + 1;
                q.push({v, j});
            }
        }
    }
    printf("%d\n", d[n][0]);
    return 0;
}
```

每条边有了时间限制，其实也不用怕，可以原地等待 $k$ 的倍数时间来达到这个限制，等价于起点的出发时间往后偏移了这么多。

比如当前的边需要的时间是 $w$ 大于目前时间  $t$ ，那么就需要让出发时间延后 $\lceil {w -t\over k} \rceil \cdot k$ 单位时间。

然后这样普通 BFS 就不行了，得用优先队列来贪心选取当前最小状态来拓展，本质上就是 Dijkstra 算法。

时间复杂度 $O(nk\log nk)$，完整代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 10005;

vector<pair<int, int>> G[N];
int d[N][105];
int vis[N][105];
struct Node {
    int u, i, d;
    bool operator<(const Node &rhs) const {
        return d > rhs.d;
    }
};
int main() {
    int n, m, kk;
    scanf("%d%d%d", &n, &m, &kk);
    while (m--) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        G[u].push_back({v, w});
    }
    memset(d, 0x3f, sizeof d);
    priority_queue<Node> q;
    q.push({1, 0, d[1][0] = 0});
    while (q.size()) {
        int u = q.top().u, i = q.top().i;
        q.pop();
        if (vis[u][i]) continue;
        vis[u][i] = 1;
        for (auto [v, w] : G[u]) {
            int t = d[u][i], j = (i + 1) % kk;
            if (t < w) t += (w - t + kk - 1) / kk * kk;
            if (d[v][j] > t + 1) q.push({v, j, d[v][j] = t + 1});
        }
    }
    if (d[n][0] == INF) d[n][0] = -1;
    printf("%d\n", d[n][0]);
    return 0;
}
```

---

## 作者：OIer_Automation (赞：33)

**这是我 AK 的第一步**

赛时将思路想出来了，至今还觉得不可思议。

第一眼看到这个题，发现边权全为 $1$，赛前复习的时候看见了一句话

**边权全为 $1$ 的最短路可以用 bfs 实现 $O(n)$ 的时间复杂度**

这不刚好撞上了吗？虽然这题似乎不太像最短路，但总之先打一下吧。

接着我总结分析出了几个点：

1. 出发时刻和结束时刻都是 $k$ 的非负整数倍意味着走过的路径数也应当是 $k$ 的非负整数倍。
2. 小 Z 不愿意停留在任何地点（包括景区入口和出口）或者道路上停留意味着当目前抵达某个节点的时间不成立时，只能够将出发时间推迟 $k$ 的整数倍。

于是，我们可以得到如下的 bfs 代码：

```cpp
void bfs(int st){
	priority_queue<node>que;
	memset(vis,0x3f,sizeof vis);
	que.push((node){0,0,st});
	vis[1][0]=0;
	while(!que.empty()){
		node h=que.top();
		que.pop();
		int u=h.id,tim=h.t,dis=h.d;
		if(u==n&&dis%k==0){
			ans=tim+dis;
			break;
		}
		for(int i=head[u];i;i=e[i].to){
			int v=e[i].v,w=e[i].w;
			if(tim+dis>=w){
				que.push((node){tim,dis+1,v});
			}else{
				int time=tim+((w-tim-dis-1)/k+1)*k;
				que.push((node){time,dis+1,v});
			}
		}
	}
}
注：因为我们不可能枚举出每一条合法的路径，因此应当采用优先队列得到最优解。
```

运行大样例，发现死循环，原因在于一直在跑环。所以我们必须采取一些措施。

首先跑环是无可厚非的，考虑如下图所示的情景，当 $k=5$ 时，不走环显然无法满足题意，但我们可以通过走环来得到一条合法路径。

![1](https://cdn.luogu.com.cn/upload/image_hosting/g1yot0wt.png)

于是我们想到记忆化，考虑现在有两种不同的路径抵达了同一条点，记第一条路径为 $road_{1}$，其对应的出发时间与路径数为 $t_{1}$ 和 $dis_{1}$，第二条路同理。

若设 $t_{1}\le t_{2}$，$dis_{1}\equiv dis_{2} \pmod k$ 且 $road_{1}$ 在 $road_{2}$ 之前被处理（即 $t_{1}+dis_{1}\le t_{2}+dis_{2}$），则在之后的选择里一定存在一条路径是的两条路径抵达终点时一定符合条件，那么此时考虑后面的路径。

若两者出发时间在后面的路径均不符合要求，则一定会上升至同一高度，考虑优先队列的性质，先入队的应排在前方，则 $dis_{1}\le dis_{2}$，则 $road_{1}$ 更优；若两者出发时间在后面的路径均符合要求，则 $road_{1}$ 更优；若出发时间较早的不符合条件，则在上升后出发时间也不会超过出发时间较晚的那一条，但由于路径数量的偏差让我们无法肯定哪一条更为优势，但如果 $road_{2}$ 的那一条出发时间较晚，因为优先队列先入队的会排在前，则其路径数量不会使 $t_{1}+dis_{1}=t_{2}+dis_{2}$，所以 $t_{1}+dis_{1}<t_{2}+dis_{2}$，所以 $dis_{1}\le dis_{2}$，所以 $road_{1}$ 更优。

综上，在上述情况，更优的总是 $t$ 较小的那一条，因此加入记忆化，结合优先队列即可找出最优解。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e4+5;
int n,m,k,cnt=1,ans;
int head[maxn],vis[maxn][105];

struct edge{
	int v,to,w;
}e[maxn<<1];

struct node{
	int t,d,id;
	bool operator <(const node &x)const{
		return t+d>x.t+x.d; 
	}
};

void add(int u,int v,int w){
	e[cnt].v=v,e[cnt].w=w,e[cnt].to=head[u];
	head[u]=cnt++;
}

void bfs(int st){
	priority_queue<node>que;
	memset(vis,0x3f,sizeof vis);
	que.push((node){0,0,st});
	vis[1][0]=0;
	while(!que.empty()){
		node h=que.top();
		que.pop();
		int u=h.id,tim=h.t,dis=h.d;
		if(u==n&&dis%k==0){
			ans=tim+dis;
			break;
		}
		for(int i=head[u];i;i=e[i].to){
			int v=e[i].v,w=e[i].w;
			int mod=(dis+1)%k;
			if(tim+dis>=w){
				if(vis[v][mod]<=tim)continue;
				vis[v][mod]=tim;
				que.push((node){tim,dis+1,v});
			}else{
				int time=tim+((w-tim-dis-1)/k+1)*k;
				if(vis[v][mod]<=time)continue;
				vis[v][mod]=time;
				que.push((node){time,dis+1,v});
			}
		}
	}
}

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	ans=-1;
	bfs(1);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Register_int (赞：32)

先考虑 $k=1$ 的时候怎么做，此时相当于找一条最短的满足边权限制的路径。不过，这相当于要求有下界的可行路，~~完全做不了~~。不妨倒着考虑，建成反图，二分到达终点的时刻 $x$，原问题的 $dis_u\ge w$ 就转化为了 $x-dis_u>w$，也即 $dis_u<x-w$。这样就变成了最短路径的限制，可以直接广搜做掉。

再考虑 $k$。我们可以将一个点 $u$ 拆成 $k$ 个点 $u_0,u_1,\cdots,u_{k-1}$，分别表示路径长度 $\bmod\ k = i$ 时的情况，要求的即为起点 $1_0$ 终点 $n_0$ 的答案。时间复杂度 $O(k(n+m)\log (m+V/k))$。

# AC 代码

赛时代码直接贺了，没删 freopen。

```cpp
#include <bits/stdc++.h>

typedef long long ll;

using namespace std;

const int MAXN = 1e6 + 10;
const int MAXM = 2e6 + 10;

/*
咋做呢就是，拆点是容易想到的，但是边上的限制有点麻烦。
可行路不大于边权是难做的，但是负权可行路大于边权是好做的，显然最长路满足要求。 
所以考虑反图。相当于是正权最短路要 < kx - dis_u，松弛时已经是最优了所以不劣。 
哦跑啥 dij 啊，无权直接跑 bfs 算，限制用二分解决。
好像可以更简单，因为只要判连通性，但懒得想了。 
时间复杂度 O(k(n+m)log(V/k+m))，跑得好慢，极限数据 0.74s。
希望 ccf 大慈大悲。 
*/

inline 
int read() {
	int x = 0; char c = getchar();
	for (; isspace(c); c = getchar());
	for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ '0');
	return x;
}

struct node { int v, w; }; vector<node> g[MAXN];

int n, m, k;

inline 
int pos(int u, int p) {
	return (u - 1) * k + p;
}

int dis[MAXN]; bool vis[MAXN]; queue<int> q;

inline 
bool check(ll p) {
	memset(dis, 0xff, sizeof dis), memset(vis, 0, sizeof vis);
	dis[pos(n, 0)] = 0, vis[pos(n, 0)] = 1, q.push(pos(n, 0));
	for (int u; !q.empty();) {
		u = q.front(), q.pop();
		for (node x : g[u]) {
			if (dis[u] >= p * k - x.w) continue;
			if (!vis[x.v]) dis[x.v] = dis[u] + 1, vis[x.v] = 1, q.push(x.v);
		}
	}
	return ~dis[pos(1, 0)];
}

ll l, r, mid;

int main() {
	freopen("bus.in", "r", stdin);
	freopen("bus.out", "w", stdout);
	n = read(), m = read(), k = read();
	for (int i = 1, u, v, w; i <= m; i++) {
		u = read(), v = read(), w = read(), r = max<ll>(r, w);
		for (int j = 0; j < k; j++) g[pos(v, (j + 1) % k)].push_back({ pos(u, j), w });
	}
	r = (r - 1) / k + m + 1;
	for (; l < r; check(mid = l + r >> 1) ? r = mid : l = mid + 1);
	if (!check(l)) puts("-1");
	else printf("%lld", l * k);
}

/*
Register_int AK CSP

orz ZZP
orz MCW
orz CYZ
orz HHX
orz HYT
*/
```

---

## 作者：yhx0322 (赞：16)

upd on $2023.12.12$：更新了标题行的内容。
## Solution
这道题的数据范围提示我们： $k \le 100$，显然是分层图，图上每个点都会拆成 $n$ 个状态。

这道题有 $35$ 分的特殊限制都是 $a_i = 0$，代表没有时间的限制，我们就直接分层图跑 BFS。

现在，考虑有时间限制的情况。

可以原地等待 $k$ 的倍数时间来达到这个限制，等价于起点的出发时间往后偏移了这么多。

这样就需要用到 Dijkstra + 堆优化，时间复杂度 $O(nk \log nk)$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e4 + 10;

vector<pair<int, int>> G[N];
int d[N][105];
int vis[N][105];
int u, v, w;
struct Node {
    int u, i, d;
    bool operator<(const Node &rhs) const {
        return d > rhs.d;
    }
};
priority_queue<Node> q;
int main() {
    int n, m, kk;
    scanf("%d%d%d", &n, &m, &kk);
    while (m--) {
        scanf("%d%d%d", &u, &v, &w);
        G[u].push_back({v, w});
    }
    memset(d, 0x3f, sizeof(d)); // 初始化为无穷大
    q.push({1, 0, 0});
    d[1][0] = 0;
    while (!q.empty()) { // 标准的模版
        int u = q.top().u, i = q.top().i;
        q.pop();
        if (vis[u][i]) continue;
        vis[u][i] = 1;
        for (auto _ : G[u]) {
            int v = _.first, w = _.second;
            int t = d[u][i], j = (i + 1) % kk;
            if (t < w) t += (w - t + kk - 1) / kk * kk;
            if (d[v][j] > t + 1) q.push({v, j, d[v][j] = t + 1});
        }
    }
    if (d[n][0] == INF) d[n][0] = -1;
    printf("%d", d[n][0]);
    return 0;
}
```

---

## 作者：Fire_flame (赞：15)

[题目传送门](https://www.luogu.com.cn/problem/P9751)

没开 long long 导致的！！！

爆挂 15 分！！！

## $\mathtt{Solution}$

首先思考一下，发现这个不早于 $a_i$ 时刻才能通过这条道路的性质很烦。

所以我们建一个反图，从终点出发，跑一遍广搜。

为了满足约束，每一次跑的时候还需要二分一个答案，每次经过一条边时间减一。如果当前时间小于 $0$，那么就不能把该节点入队。

为了保证广搜复杂度 $O(nk)$，需要一个数组 $used_{i,j}$ 表示节点 $i$，时间模 $k$ 余 $j$ 时有没有到过。

时间复杂度 $O(nk\log w)$，其中 $w$ 为二分答案上界。

代码：

```cpp
/*
于2023.10.21 10:31 完成此题作答

望我AK！ 
*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	int s = 0, f = 1;char ch = getchar();
	while(!isdigit(ch)){if(ch == '-')f = -1;ch = getchar();}
	while(isdigit(ch)){s = s * 10 + ch - '0';ch = getchar();}
	return s * f;
}
const int MAXN = 1e4 + 5, MR = 2e4 + 5, MN = 105;
struct edge{
	int from, to, len, nxt;
}e[MR];
struct ZRX{
	int x, t;
};
int n, m, k, cnt, head[MAXN], used[MAXN][MN];
void add_edge(int u, int v, int w){
	e[++ cnt] = {u, v, w, head[u]};
	head[u] = cnt;
}
int bfs(int s){
	memset(used, 0, sizeof(used));
	used[n][0] = 1;
	queue<ZRX>q;
	q.push({n, s});
	while(!q.empty()){
		int px = q.front().x, pt = q.front().t;
		q.pop();
		for(int i = head[px];i;i = e[i].nxt){
			int v = e[i].to, w = e[i].len;
			if(pt == 0 || used[v][(pt - 1) % k] || pt - 1 < w)continue;
			if(v == 1 && (pt - 1) % k == 0)
				return 1;
			used[v][(pt - 1) % k] = 1;
			q.push({v, pt - 1});
		}
	}
	return -1;
}
signed main(){
// 	freopen("bus.in", "r", stdin);
// 	freopen("bus.out", "w", stdout);
	n = read(), m = read(), k = read();
	for(int i = 1;i <= m;i ++){
		int u = read(), v = read(), w = read();
		add_edge(v, u, w);
	}
	int l = 0, r = 5000000, res = -1;
	while(l <= r){
		int mid = (l + r) / 2;
		if(bfs(mid * k) != -1)res = mid * k, r = mid - 1;
		else l = mid + 1;
	}
	printf("%lld", res);
	return 0;
}
```

---

## 作者：TernaryTree (赞：15)

因为写了 `bool bfs` 但是没返回值喜提 RE $100\to 0$，痛失 AK，火大。

---

先考虑起终点都是 $k$ 倍数的限制，由于不能在边上停留，所以相当于问你从 $1\to n$ 有没有 $k$ 的倍数长度的路径。看起来很困难，但是注意到 $nk$ 似乎是一个很可行的数字，暴力建 $k$ 个图表示每个点走到的时候模 $k$ 的距离，所以一条边是由每张图的 $u$ 连向下个图的 $v$。判断能不能到，就是第一张图也就是模 $k$ 为 $0$ 的图中 $1\sim n$ 的可达性。在这张图中，任意一条路径都是满足长度为 $k$ 倍数的，所以我们省去了一个条件。

接下来考虑每条边开放时间，正着做好像非常不好做。枚举到达终点的时间，然后建反图，倒着逆推回去，判断每个点最晚什么时候到，看看能不能在非负整数时间内到达结点 $1$。显然答案具有单调性，那么套上一个二分即可。并且这边倒着逆推的过程中，因为边权都是 $1$，所以直接 bfs 复杂度即为 $k(n+m)$。

总复杂度 $\Theta(k(n+m)(\log (n+m)+\log k))$。

考场机子要跑 $1.16s$/ruo

```cpp
/*
big sample 1.16s /ll

TernaryTree is so vegetable.

i love ccf please give me full pts 
*/

#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e4 + 2;
const int maxm = 2e4 + 2;
const int maxk = 1e2 + 2;
const int inf = 1e7;

struct edge {
	int to, next, w;
};

int n, m, k;
int head[maxn * maxk];
edge e[maxm * maxk];
int cnt;

void add_edge(int u, int v, int w) {
	e[++cnt].to = v;
	e[cnt].next = head[u];
	e[cnt].w = w;
	head[u] = cnt;
}

int q[maxn * maxk];
int hd, tl;
//queue<int> q;
int dis[maxn * maxk];

void bfs(int d) {
	memset(dis, -0x3f, sizeof(dis));
	hd = tl = 1;
	q[1] = n;
	dis[n] = d;
	while (hd <= tl) {
		int v = q[hd++];
		for (int i = head[v]; i; i = e[i].next) {
			int u = e[i].to;
			if (dis[v] > e[i].w && dis[u] == dis[0]) {
				dis[u] = dis[v] - 1;
				q[++tl] = u;
			}
		}
	}
}

signed main() {
	//freopen("bus.in", "r", stdin);
	//freopen("bus.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> k;
	for (int i = 1, u, v, w; i <= m; i++) {
		cin >> u >> v >> w;
		for (int j = 0; j < k - 1; j++) add_edge(v + (j + 1) * n, u + j * n, w);
		add_edge(v, u + (k - 1) * n, w);
	}
	bfs(inf);
	if (dis[1] < 0) {
		cout << -1 << endl;
		return 0;
	}
	int l = 0, r = inf;
	while (l < r) {
		int mid = l + r >> 1;
		bfs(mid);
		if (dis[1] >= 0) r = mid;
		else l = mid + 1;
	}
	bfs(l);
	cout << l + (dis[1] + k - 1) / k * k - dis[1] << endl;
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：13)

# Solution

- 能在起点等 $k$ 的非负整数倍相当于能在任意点等 $k$ 的非负整数倍。
- 由于离开的时间要是 $k$ 的非负整数倍，将每个点拆成 $k$ 个点，$dis_{i,j}$ 表示到了第 $i$ 个点长度 $\bmod\text{ }k\equiv j$ 的最短路径。 
- 转移时若时间未到，直接在原地等 $k$ 的非负整数倍时间直至可以通过。易证这样一定是最优的。注意到这样边权不全是 $1$，跑 Dijkstra 即可。

时间复杂度 $\mathcal{O}(mk\log(nk))$。

# Code

考场代码，写得有些丑：

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<int, int> pii;
	const int N = 1e6 + 5;
	LL n, m, k, u, v, w, dis[N];
	vector<pii> G[N];
	bool vis[N];
	int id(int u, int k) { return n * k + u; }
	LL updiv(LL a, LL b) { return (a + b - 1) / b; }
	int main() {
		cin >> n >> m >> k;
		REP(i, 1, m)
			cin >> u >> v >> w, G[u].push_back(pii(v, w));
		auto Dijkstra = [&]() {
			memset(dis, 0x3f, sizeof dis);
			priority_queue<pii, vector<pii>, greater<pii>> q;
			dis[1] = 0, q.push(pii(dis[1], 1));
			while (!q.empty()) {
				pii tmp = q.top(); q.pop();
				int u = tmp.se;
				if (vis[u]) continue;
				vis[u] = 1;
				for (pii qwq : G[(u - 1) % n + 1]) {
					int v = id(qwq.fi, (dis[u] + 1) % k), d = qwq.se;
					int w = max(updiv(d - dis[u], k), 0LL) * k + 1;
					if (dis[v] > dis[u] + w) {
						dis[v] = dis[u] + w;
						if (!vis[v]) q.push(pii(dis[v], v));
					}
				}
			}
		};
		Dijkstra();
		if (dis[n] > 1e9) cout << "-1\n";
		else cout << dis[n] << '\n';
		return 0;
	}
}
int main() {
//	freopen("bus.in", "r", stdin);
//	freopen("bus.out", "w", stdout);
	int T = 1;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：lizhous (赞：8)

发现 $k\le 100$。

假如有一条在时刻 $m$ 到达点 $u$ 的路径，那么我在起始点晚 $k$ 时刻到，也就是一定存在一条时刻 $m+k$ 到达点 $u$ 的路径。

观察到这两条路径的时刻在 $\operatorname{mod} p$ 意义下是一致的，也就是对于所有到达 $u$ 且 $\operatorname{mod} p$ 相同时刻的路径，我们只关心最早到的那条，剩下的都可以由这条路衍生而来，我们设其时间为 $f_{u,m\operatorname{mod}p}$。

$a$ 的限制的处理办法也就显而易见了。对于每个余数 $j$，我们要找到最小的 $\operatorname{mod}p=j$ 的数 $x$ 满足 $x\ge a$，那么经过这条边余数为 $j$ 的最早时刻就是 $x$。

这是一个图上的 DP，我们可以使用类似 SPFA 的方法 BFS 更新。即枚举每条遍历到的边 $(u,v,w)$，如果 $f_u$ 更新了 $f_v$，那么继续遍历 $v$ 的出边并更新。

时间复杂度是 SPFA 的。

---

## 作者：WaterSun (赞：7)

# 思路

定义 $d_{i,j}$ 表示从 $1$ 走到 $i$，并且满足 $t \bmod k = j$ 的最小的符合题意的 $t$。

然后就可以直接跑一遍 Dijkstra 即可。

当要计算一条 $u \to v$ 的边 $w$ 时，如果当前时间不够无法达到 $w$，那么需要将时间提到第一个时间大于 $w$，并且模 $k$ 相同的 $x$ 即可。

# code

```cpp
#include <bits/stdc++.h>
#define fst first
#define snd second
#define re register

using namespace std;

typedef pair<int,int> pii;
const int N = 1e4 + 10,M = 2e4 + 10,K = 110,inf = 0x3f3f3f3f;
int n,m,k;
int d[N][K];
int idx,h[N],ne[M],e[M],w[M];
bool vis[N][K];

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

inline void add(int a,int b,int c){
    ne[idx] = h[a];
    e[idx] = b;
	w[idx] = c;
    h[a] = idx++;
}

inline int up(int a,int b){
	if (a % b == 0) return a / b;
	return a / b + 1;
}

inline int get(int x,int y){
	if (x >= y) return x;
	return up(y - x,k) * k + x;
}

inline void dijkstra(int s){
    priority_queue<pii,vector<pii>,greater<pii>> q;
    d[s][0] = 0;
    q.push({0,s});
    while (!q.empty()){
        pii t = q.top();
        q.pop();
		int dist = t.fst % k;
        if (vis[t.snd][dist]) continue;
		vis[t.snd][dist] = true;
		for (re int i = h[t.snd];~i;i = ne[i]){
			int j = e[i],lim = w[i];
			int ndist = (dist + 1) % k,ntim = get(t.fst,lim) + 1;
			if (d[j][ndist] > ntim){
				d[j][ndist] = ntim;
				q.push({d[j][ndist],j});
			}
		}
    }
}

int main(){
    memset(h,-1,sizeof(h));
    memset(d,inf,sizeof(d));
    n = read();
    m = read();
    k = read();
    for (re int i = 1;i <= m;i++){
        int a,b,c;
        a = read();
        b = read();
		c = read();
        add(a,b,c);
    }
    dijkstra(1);
    if (d[n][0] >= inf) puts("-1");
    else printf("%d",d[n][0]);
    return 0;
}
```

---

## 作者：Inui_Sana (赞：7)

在我校同级唯一好过别人的就是这题没挂。

假设我们已经固定了路径，考虑一条边 $(u,v,w)$ 对于到达 $v$ 时间的影响是什么。设到达 $u$ 时的时间是 $t_u$。如果 $t_u>w$，那么显然 $t_v=t_u$。否则我们要在起点多等若干个长为 $k$ 的时间，可以分两种情况：

- $t_u\bmod k\ge w \bmod k$ 时，需要等到 $\left\lfloor \dfrac{w}{k}\right\rfloor\times k+t_u\bmod k$。

- $t_u\bmod k< w\bmod k$ 时，要在上面的基础上再额外加上 $k$。

称上面结果为 $w_i'$。

综上，有转移 $t_v=\max(t_u,w_i')$

有个可能的疑问是为什么 $t_v$ 不能直接加到 $w$。这是因为你在起点时，时间 $t \bmod k=0$ 是恒定的，当我们又固定了路线时，路径长度固定，所有 $t_u\bmod k$ 也就不会变了。

然后就可以发现，只要 $t_u\bmod k$ 不变，那么 $t_v=\max(t_u,w_i')$ 就不会变。但是有可能从起点到一个点 $u$ 不止一条路径，意味着 $t_u\bmod k$ 可能有不止一种取值。观察到 $k\le 100$，$k\times n\le10^6$。这种问题就可以建一个分层图解决。

具体的，将每个点 $i$ 拆成二元组 $(i,j),j\in[0,k)$。每次在原图上有边 $(u,v,w)$ 则 $\forall i\in[0,k)$，建边 $((u,i),(v,(i+1)\bmod k),w')$。其中 $w'$ 的意义和上文的类似。然后直接跑一遍类似 dij 的转移即可。

这里给初学者讲一下为什么可以 dij。首先你要知道，dij 是基于贪心实现的。选出当前 $dis$ 最小的点，那么其他 $dis\ge$ 它的点一定不会再向它转移，因为全部都是正权边。然后就可以发现，这题的取 $\max$ 也契合这样的转移。所以时可以的。

由于本人抽象的代码习惯，可能不太可读，所以仅供参考，还是要真正理解做法。

code：

```cpp
#define ID(i,j) (i+j*n)
int n,m,k,dis[N];
bool vis[N];
int tot,head[N];
struct node{int to,nxt,cw;}e[M];
priority_queue<pii> q;
il void add(int u,int v,int w){e[++tot]={v,head[u],w},head[u]=tot;}
void Yorushika(){
	scanf("%d%d%d",&n,&m,&k);
	rep(i,1,m){
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		rep(j,0,k-1)add(ID(u,j),ID(v,(j+1)%k),k*(w/k)+j+(j<w%k?k:0));
	}
	mems(dis,0x3f);
	dis[ID(1,0)]=0;
	q.push(Mp(0,ID(1,0)));
	while(q.size()){
		int u=q.top().se;
		q.pop();
		if(vis[u])continue;
		vis[u]=true;
		go(i,u){
			int v=e[i].to,w=max(dis[u],e[i].cw)+1;
			if(vis[v]||dis[v]<=w)continue;
			q.push(Mp(-(dis[v]=w),v));
		}
	}
	printf("%d\n",dis[ID(n,0)]>1e9?-1:dis[ID(n,0)]);
}
signed main(){
	//freopen("bus.in","r",stdin);
	//freopen("bus.out","w",stdout);
	int T=1;
//	scanf("%d",&T);
	while(T--)Yorushika();
}
```

---

## 作者：_Ch1F4N_ (赞：5)

场外口胡选手的题解。

发现时间 $x$ 之前不能通过不好处理，不妨建反图，从终点往前走，这样限制变成时间 $y$ 之后不能通过，那么到这个点的最短时间就一定是可以通过的。换言之到的越早越好，直接跑最短路，由于边权只有 $1$ 所以考虑广搜即可。

至于倍数限制直接套路地拆点即可，因为要出去最早所以二分出门时间往前广搜看能不能搜到起点即可。

至此两个限制和最早出门时间都被解决，时间复杂度 $O(k \times n \log V)$。

下面是信息课上抽时间写的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+114;
const int top = 1e7+114514;
vector< pair<int,int> > edge[maxn];
int dis[maxn],n,m,k;
inline int pos(int x,int r){return x*k+r;}
bool vis[maxn];
queue<int> q;
inline bool check(int ending){
    memset(dis,0x3f3f3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[pos(n,0)]=0;
    q.push(pos(n,0));
    while(q.size()>0){
        int u=q.front();
        q.pop();
        if(vis[u]==true) continue;
        vis[u]=true;
        for(pair<int,int> nxt:edge[u]){
            int v=nxt.first;
            if(ending-dis[u]-1>=nxt.second){
                dis[v]=min(dis[v],dis[u]+1);
                q.push(v);
            }
        }
    }
    return dis[pos(1,0)]<=0x3f3f3f;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++){
        int u,v,a;
        cin>>u>>v>>a;
        swap(u,v);
        for(int tm=0;tm<k-1;tm++) edge[pos(u,tm)].push_back(make_pair(pos(v,tm+1),a));
        edge[pos(u,k-1)].push_back(make_pair(pos(v,0),a));
    }
    int l=-1,r=top/k;
    while(l+1<r){
        int mid=(l+r)>>1;
        if(check(mid*k)==true) r=mid;
        else l=mid;
    }
    cout<<(r==top/k?-1:r*k)<<'\n';
    return 0;
}
```


---

## 作者：xiaoming007 (赞：4)

观察题面，发现 $n \leq 10^4$ 且 $k \leq 100$，易想到对于每个点的，建立 $k$ 个维度，其中 $dis_{i,j}$ 表示 $i$ 号点总花费时间模 $k = j$ 的最小花费。

然后考虑分层进行 `Dijkstra`，设当前层数为 $j$，则穿过这条边后层数变成 $(j+1) \bmod k$，于是就可以进行转移取 $\min$。

但是发现转移过程中出现当前花费小于开放时间的情况，于是可以补若干个 $k$，使得其满开放时间。

然后做完了。

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
namespace FastIO {
	inline int read() {
		int x = 0, f = 1;
		char c=getchar();
		while (c > '9' || c < '0') {
			if (c == '-') f=-1;
			c=getchar();
		}
		while (c >= '0' && c <= '9') {
			x = (x << 1) + (x << 3) + (c - '0');
			c=getchar();
		}
		return x*f;
	}
	void Write(int x) {
		if (x > 9) Write(x / 10);
		putchar(x % 10 + '0');
	}
	inline void write(int x, char c) {
		if (x < 0) {
			putchar('-');
			x = -x;
		}
		Write(x);
		putchar(c);
	}
} using namespace FastIO;
const int N = 1e4 + 19, K = 119;
int dp[N][K];
int n, m, k;
struct pii {
	int x, y, z;
	bool operator < (const pii &a) const {
		if (y == a.y) return x > a.x;
		return y > a.y;
	}
};
vector<pii> g[N];
priority_queue<pii> q;
bool vis[N][K];
int main(){
	n = read(), m = read(), k = read();
	for (int i = 1; i <= m; ++i) {
		int u = read(), v = read(), t = read();
		g[u].push_back({v, t, t % k});
	}
	for (int i = 1; i <= n; ++i) for (int j = 0; j <= k; ++j) dp[i][j] = 1e9;
	dp[1][0] = 0;
	q.push({1, 0, 0});
	while (!q.empty()) {
		pii u = q.top();
		q.pop();
		//cout << u.x << ' ' << u.y << ' ' << u.z << '\n';
		if (vis[u.x][u.z]) continue;
		vis[u.x][u.z] = 1;
		for (pii i : g[u.x]) {
			int pay = u.y;
			if (pay < i.y) {
				pay += (i.y - pay + k - 1) / k * k;
			}
			++pay;
			int tp = pay % k;
			if (pay < dp[i.x][tp]) {
				dp[i.x][tp] = pay;
				//cout << i.x << ' ' << pay << ' ' << tp << '\n';
				q.push({i.x, pay, tp});
			}
		}
	}
	write(dp[n][0] == 1e9 ? -1 : dp[n][0], '\n');
	return 0;
}
```

---


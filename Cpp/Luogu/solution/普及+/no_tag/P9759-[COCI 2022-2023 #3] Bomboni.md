# [COCI 2022/2023 #3] Bomboni

## 题目描述

Iva 是一个狂热的糖果迷！在她面前是一块填满糖果和障碍的 $n\times n$ 的土地。Iva 目前在左上角。通过向右或向下移动，她要前往右下角。Iva 目前所在的格子没有障碍。

在每个格子中写了一个数字表示此地为糖果或障碍。Iva 会吃掉所有经过的糖果（包括起点和终点的糖果）并且将糖果对应的数字相乘。Iva 知道她自己最喜欢的数字是 $k$，所以她希望这个乘积结果能被 $k$ 整除。她想知道一共有多少条这样的路径。由于答案可能很大，她只想知道答案模 $998244353$ 的结果。

## 说明/提示

**【样例解释 #2】**

共有三条这样的路线：
- 5-2-3-3-1
- 5-2-3-6-1
- 5-7-3-6-1

**【数据范围】**

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $13$ | $n,k,a_{i,j} \leq 20$ |
| $2$ | $17$ | $n,k \leq 20$ |
| $3$ | $33$ | $k\le 20$ |
| $4$ | $47$ | 无特殊性质 |

对于 $100\%$ 的数据，满足 $1\leq n \leq 500,1\le k\le 10^6, -1\le a_{i,j}\le 10^6$。

本题满分 $110$ 分。

## 样例 #1

### 输入

```
2 2
3 2
1 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3 6
5 2 -1
7 3 6
-1 3 1```

### 输出

```
3```

# 题解

## 作者：FFTotoro (赞：4)

对于 $k\le 20$ 的部分分我们有一个比较简单的动态规划做法：令 $f_{i,j,w}$ 为从 $(1,1)$ 走到 $(i,j)$ 且路径上乘积除以 $k$ 的余数为 $w$ 的方案数，对于 $a_{i,j}\ge 0$ 的 $(i,j)$ 显然有 $f_{i,j,x\times a_{i,j}\bmod k}=f_{i-1,j,x}+f_{i,j-1,x}$，答案为 $f_{n,n,0}$。

但 $k=10^6$ 的时候这个做法是 $O(n^2k)$ 的，无法通过。

维护余数肯定是不行了；那么换个角度想，让上文 $w$ 的含义变为路径上的乘积 $p$ 与 $k$ 的最大公约数 $\gcd(p,k)$：只有 $\gcd(p,k)=k$ 时才有 $k|p$。因为 $\gcd(p,k)|k$，所以第三维的大小为 $k$ 的因数个数，可以证明在 $k\le 10^6$ 的情况下不超过 $300$ 个。

在转移过程中求最大公约数的时候会带个 $\log$，会被卡。可以先预处理一下 $k$ 的所有因数两两之间乘积与 $k$ 的最大公约数，然后对于每个输入的 $a_{i,j}\ge 0$ 都执行 $a_{i,j}\leftarrow\gcd(a_{i,j},k)$。转移为 $f_{i,j,\gcd(x\times a_{i,j},k)}=f_{i-1,j,x}+f_{i,j-1,x}$。

对于每个因数映射下标，方便转移。设 $k$ 映射的下标是 $x$，则答案为 $f_{n,n,x}$。时间复杂度 $O(k+d^2\log k+n^2d)$，其中 $d=300$，可以通过。

$63\mathrm{pts}$ 部分分代码（第一种思路）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int main(){
  ios::sync_with_stdio(false);
  int n,k; cin>>n>>k;
  vector a(n,vector<int>(n));
  for(auto &i:a)for(auto &j:i)cin>>j;
  vector f(n,vector(n,vector<int>(k)));
  f[0][0][a[0][0]%k]=1;
  for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
      if(a[i][j]>=0)
        for(int l=0;l<k;l++){
          if(i)(f[i][j][1ll*l*a[i][j]%k]+=f[i-1][j][l])%=mod;
          if(j)(f[i][j][1ll*l*a[i][j]%k]+=f[i][j-1][l])%=mod;
        }
  cout<<f[n-1][n-1][0]<<endl;
  return 0;
}
```

$110\mathrm{pts}$ 满分代码（第二种思路）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
int main(){
  ios::sync_with_stdio(false);
  int n,k; cin>>n>>k;
  vector<int> p,m(k+1);
  for(int i=1;i<=k;i++)
    if(!(k%i))m[i]=p.size(),p.emplace_back(i);
  vector g(p.size(),vector<int>(p.size()));
  for(int i=0;i<p.size();i++)
    for(int j=0;j<p.size();j++)
      g[i][j]=m[gcd(1ll*p[i]*p[j],k)];
  vector a(n,vector<int>(n));
  for(auto &i:a)for(auto &j:i)if(cin>>j;j>=0)j=m[gcd(j,k)];
  vector f(n,vector(n,vector<int>(p.size())));
  f[0][0][a[0][0]]=1;
  for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
      if(a[i][j]>=0)
        for(int l=0;l<p.size();l++){
          if(i)(f[i][j][g[l][a[i][j]]]+=f[i-1][j][l])%=mod;
          if(j)(f[i][j][g[l][a[i][j]]]+=f[i][j-1][l])%=mod;
        }
  cout<<f[n-1][n-1].back()<<endl;
  return 0;
}
```

---

## 作者：egg_boy (赞：4)

前置芝士：[最大公因数](https://oi-wiki.org/math/number-theory/gcd/)。  

  为了不引起歧义，我们将题目中的 $k$ 用 $m$ 代替。

  首先考虑部分分，很简单，用一个三维 dp，表示走到第 $i$ 行，第 $j$ 列时余数为 $k$ 的路径个数。状态转移方程：  
  
  $dp_{i,j,k\times a_{i,j} \bmod m} \gets (dp_{i,j,k\times a_{i,j} \bmod m}+dp_{i-1,j,k}+dp_{i,j-1,k}) \bmod 998244353$。  

  接着考虑优化，我们可以发现一个数字在模 $m$ 意义下的贡献值只有他与 $k$ 相同的因数的乘积，这刚好符合最大公因数的定义，因此可以将暴力代码中的 dp 定义中的第三维从余数为 $k$ 改为与 $m$ 的最大公因数为 $k$。    
  
  跟着思路往下走，由于与 $m$ 的最大公约数种类很少。所以不用担心超时，具体操作如下。  
  
  预处理 $1$ 到 $10^6$ 中所有数与 $m$ 的最大公约数，接着用 map 来存储 dp 数组即可。这里动态转移方程可以类比暴力代码：  
  
  设 $x=k\times a_{i,j} \bmod m$。   
  $dp_{i,j,gcd(x, m)} \gets (dp_{i,j,gcd(x, m)}+dp_{i-1,j,k}+dp_{i,j-1,k}) \bmod 998244353$。  

# Code

```cpp
dp[1][1][vis[a[1][1]]] = 1;

for(int i = 1; i <= n; i++)
	for(int j = 1; j <= n; j++)
	{
		if(a[i][j] == -1) continue;

        这里因为用的是map 所以要分开处理
		for(auto& k : dp[i - 1][j])
		{
			int x = vis[k.first * a[i][j] % m];
			dp[i][j][x] = (dp[i][j][x] + dp[i - 1][j][k.first]) % mod;
		}

		for(auto& k : dp[i][j - 1])
		{
			int x = vis[k.first * a[i][j] % m];
			dp[i][j][x] = (dp[i][j][x] + dp[i][j - 1][k.first]) % mod;
		}
	}
		
cout << dp[n][n][m];
```
感谢观看。

---

## 作者：末然Ender (赞：2)

# 题解：P9759 [COCI2022-2023#3] Bomboni

一个地图，求所有能走到终点的方案中所经过的点权值之积是 $k$ 的倍数的方案数。

## 思路

我们看到这个题不难发现这是一个 dp。

先暴力的想部分分，不难想到用 $f_{i,j,t}$ 来表示当前走到 $a_{i,j}$ 这个位置时权值乘积等于 $t$ 的路径总数，转移是 $$f_{i,j,t}=f_{i-1,j,\frac{t}{a_{i,j}}}+f_{i,j-1,\frac{t}{a_{i,j}}}$$，结果只需要输出 $f_{n,n}$ 即可。

但是 $t$ 可能非常大，我们即使对 $k$ 取模 $O(n^2k)$ 的空间我们依然是接受不了的。

我们考虑到，一个点为最后的乘积做了贡献，当且仅当这个点权值的因数提供了 $k$ 的因数，也就是说**一个值对最后乘积的贡献和其与 $k$ 最大公因数所提供的的贡献是完全相同的**。同时我们发现 $10^6$ 以内因数最多的数的因数个数只有不到 $250$ 个，只要我们将 $f$ 的第三维表示为这条路的权值的乘积与 $k$ 的最大公因数，我们成功将空间压缩为 $O(n^2\cdot d(k))$，其中 $d(k)$ 表示为 $k$ 的因数的个数。

我用的是一个节点往后转移的方式，是这样的：

$$\begin{cases}f_{i+1,j,gt(\gcd(k,ys(t)\cdot a_{i+1,j})}=f_{i+1,j,gt(\gcd(k,ys(t)\cdot a_{i+1,j})}+f_{i,j,t}\\f_{i,j+1,gt(\gcd(k,ys(t)\cdot a_{i,j+1})}=f_{i,j+1,gt(\gcd(k,ys(t)\cdot a_{i,j+1})}+f_{i,j,t}\end{cases}$$

这里 $ys(x)$ 表示 $x$ 是 $k$ 的第几个因数，$gt(x)$ 表示 $k$ 的第 $x$ 个因数是多少，用来压缩空间。

时间和空间复杂度都是 $O(n^2\cdot d(k))$。


注意一下为了防止炸空间，最好不要开 long long,为了防止冗余的运算我们遇到不能走的 `-1` 的点就跳过，另外取模运算很慢，我们可以判断如果大于 $998244353$ 就减去之。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T& x) {
	x=0;
	char ch=getchar();
	long long f=1;
	while(!isdigit(ch)) {
		if(ch=='-')f*=-1;
		ch=getchar();
	}
	while(isdigit(ch)) {
		x=x*10+ch-48;
		ch=getchar();
	}
	x*=f;
}
template<typename T,typename... Args>
void read(T& first,Args&... args) {
	read(first);
	read(args...);
}
template<typename T>
void write(T arg) {
	T x=arg;
	if (x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9) {
		write(x/10);
	}
	putchar(x%10+'0');
}
template<typename T,typename... Args>
void write(T arg,Args... args) {
	write(arg);
	if(sizeof...(args) !=0) {
		putchar(' ');
		write(args...);
	}
}
typedef long long ll;
const int N=500+5,mod=998244353;
int n,h;
int a[N][N];
int ys[N],idx=0,gt[1000005];
int f[N][N][N];
void init(ll n,ll h){
	for(int i=1;i<=h;i++){
		if(h%i==0){
			ys[++idx]=i;
			gt[i]=idx;
		}
	}
	ys[++idx]=h;
	gt[h]=idx;
}
ll gcd(ll a,ll b){
	return __gcd(a,b);
}
int T;
int main() {
	read(n,h);
	memset(a,-1,sizeof a);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){
		read(a[i][j]);
		if(-1!=a[i][j])a[i][j]=gcd(a[i][j],h);
	}
	init(n,h);
	f[1][1][gt[gcd(a[1][1],h)]]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]==-1)continue;
			for(int k=1;k<=idx;k++){
				if(!f[i][j][k])continue;
				if(-1!=a[i+1][j]&&i<n){
					T=gcd(h,1ll*ys[k]*a[i+1][j]);
					f[i+1][j][gt[T]]=(f[i+1][j][gt[T]]+f[i][j][k]);
					if(f[i+1][j][gt[T]]>=mod)f[i+1][j][gt[T]]-=mod;
				}
				if(-1!=a[i][j+1]&&j<n){
					T=gcd(h,1ll*ys[k]*a[i][j+1]);
					f[i][j+1][gt[T]]=(f[i][j+1][gt[T]]+f[i][j][k]);
					if(f[i][j+1][gt[T]]>=mod)f[i][j+1][gt[T]]-=mod;
				}
			}
		}
	} 
	write(f[n][n][idx]);
	putchar('\n');
	return 0;
}
```

---

## 作者：weilycoder (赞：2)

这题有蓝？

首先一眼考虑动态规划，但是暴力状态范围是 $n\times n\times S$ 的，这里 $S$ 是值域。

但是考虑样例，

```txt
3 6
5 2 -1
7 3 6
-1 3 1
```

将 $5$，$7$ 改为 $1$ 是显然不影响答案的，换句话说，在第三维只有 $k$ 的公因数可以贡献到答案。

那状态空间大小变成 $n^2\times d(k)$，这里 $d$ 是因数个数函数。

$10^6$ 以内因数个数不会超过 $300$，套个 `unordered_map` 做就是了。upd：`map` 似乎略快。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int64_t P = 998244353;
const int64_t N = 507;
int64_t n, H, G[N][N];
unordered_map<int64_t, int64_t> F[N][N];

int64_t gcd(int64_t a, int64_t b) { return b ? gcd(b, a % b) : a; }

inline int64_t mul(int64_t a, int64_t b) { return gcd(a * b, H); }

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  cin >> n >> H;
  for (int64_t i = 1; i <= n; ++i) {
    for (int64_t j = 1; j <= n; ++j) {
      cin >> G[i][j];
      if (G[i][j] != -1)
        G[i][j] = gcd(G[i][j], H);
    }
  }
  F[1][1][G[1][1]] = 1;
  for (int64_t i = 1; i <= n; ++i) {
    for (int64_t j = 1; j <= n; ++j) {
      if (G[i][j] == -1)
        continue;
      for (const auto &[k, v] : F[i - 1][j])
        (F[i][j][mul(k, G[i][j])] += v) %= P;
      for (const auto &[k, v] : F[i][j - 1])
        (F[i][j][mul(k, G[i][j])] += v) %= P;
    }
  }
  cout << F[n][n][H] << '\n';
  return 0;
}
```

后记：

依照管理要求，补一下 dp 转移。

设 $f_{i,j}$ 为从起点到 $(i,j)$，路径乘积和与 $k$ 的最大公因数，设 $a_{i,j}$ 为 $(i,j)$ 位置上权值与 $k$ 的最大公因数，显然有

$$
\begin{aligned}
f_{i,j,\gcd(a_{i,j},x)}\gets f_{i,j,\gcd(a_{i,j},x)} + f_{i,j-1,x}\\
f_{i,j,\gcd(a_{i,j},x)}\gets f_{i,j,\gcd(a_{i,j},x)} + f_{i-1,j,x}
\end{aligned}
$$

这里 $x$ 是枚举的因数。

初始状态为 $f_{1,1,a_{1,1}}=1$，其余为 $0$。

---

## 作者：huangrenheluogu (赞：2)

在看下面的内容之前，我们先了解一个性质：**$1\sim10^6$ 里面的因数最多的数因数个数最多有 $240$ 个。**

那么，我们就可以利用“状压”描述一个状态，就是记录每个因数的个数。

但是这个状压是一个变进制的状压，考虑到这种题目比较少，大家不经常写，下面我会详细讲一下变进制的过程。

下面的 状压dp 就比较简单了。

这里先注意一下，下面 dp 我们要用一个数组先预处理两个状态 $x,y$ 合成之后的状态（记为 $g_{i,j}$），不然复杂度会达到 $1.2\times10^9$，会 TLE。


-----------------------------

下面是状压的过程。

先看一张图片：（数字是我的 uid）

![](https://cdn.luogu.com.cn/upload/image_hosting/lwzaqlf8.png)

发现每一个数字代表一个 $base_i$ 和 $num_i$ 的乘积，而数字就是这些乘积之和。

$461359=0\times10^7+0\times10^6+4\times10^5+6\times10^4+1\times10^3+3\times10^2+5\times10^1+9\times10^0$。

那么，我们显然可以换一个 $base$。

而 $base$ 的选择不一定要 $n^k$，而是可以用一个数组存储。

选什么数字呢？

比如我们取一个 $12$，然后质因数分解，发现 $12=2^2\times3$。

那么，储存 $2$ 的应该可以存 $3$ 个整数，$0,1,2$，存储 $3$ 的应该用 $2$ 个整数 $0,1$。

所以，我们先预处理出 $\{base\}$ 数组。

显然，$\{base\}$ 数组是用 $k$ 处理出来的。

我们令第 $i$ 位的权值是 $base_{i-1}$。

令一个 $cnt$，代表我们处理到了第 $cnt$ 位，而 $base_1=0$。

令 $sum_i$ 表示第 $i$ 位最多有多少个数，$num_i$ 表示第 $i$ 位的数字。

如果枚举到一个质因数 $a^b$。

这以为需要 $b+1$ 个。

下面写出伪代码：

```
cnt 增加
sum[cnt] = b
算出 base[cnt]
num[cnt]=a
```

$base_{cnt}$ 怎么算呢？发现第 $cnt$ 位需要满足存 $b+1$ 个值，所以 $b_{cnt}=b{cnt-1}\times(b+1)$。

好了，可以写出预处理代码了：

```cpp
inline void init(){
	base[0] = tot = 1;
	for(int i = 2; i * i <= k; i++){
		if(k % i) continue ;
		cnt++, tot = 0;
		while(k % i == 0) tot++, k /= i;
		base[cnt] = base[cnt - 1] * (tot + 1);
		sum[cnt] = tot;
		num[cnt] = i;
	}
	if(k > 1){
		cnt++;
		sum[cnt] = 1;
		base[cnt] = base[cnt - 1] * 2;
		num[cnt] = k;
	}
}
```

对于给定的 $a_{i,j}$，也要转成我们定义的进制，所以可以写一个转的伪代码：

```
枚举i:
    算出 num[i] 有多少个，记为 x 个
    则 res += x * base[i-1]
返回 res
```

代码应该不难，注意每一位不能太大。

```cpp
inline int calc(int val){
	for(int i = 1; i <= cnt; i++) b[i] = 0;
	for(int i = 1; i <= cnt; i++){
		while(val % num[i] == 0) b[i] ++, val /= num[i];
	}
	int res = 0;
	for(int i = 1; i <= cnt; i++){
		if(b[i] >= sum[i]) b[i] = sum[i];
		res += b[i] * base[i - 1];
	}
	return res;
}
```

然后是处理 $x,y$ 之和是多少，应该比较简单。

分解成两个数组，然后累加起来就好了。

代码如下：

```cpp
inline int work(int x, int y){
	for(int i = cnt; i >= 1; i--){
		b[i] = x / base[i - 1];
		x -= b[i] * base[i - 1];
		c[i] = y / base[i - 1];
		y -= c[i] *base[i - 1];
	}
	for(int i = 1; i <= cnt; i++){
		b[i] += c[i];
		if(b[i] >= sum[i]) b[i] = sum[i];
	}
	int res = 0;
	for(int i = 1; i <= cnt; i++){
		res += b[i] * base[i - 1];
	}
	return res;
}
```

状压 dp 的过程感觉还是比较模板的，这里就不赘述了。

下面是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 505, mod = 998244353;
bool f1;
int n, k, f[N][N][N >> 1], base[25], num[25], a[N][N], tot, cnt, x, b[25], sum[25], c[N], g[245][245];
bool f2;
inline void init(){
	base[0] = tot = 1;
	for(int i = 2; i * i <= k; i++){
		if(k % i) continue ;
		cnt++, tot = 0;
		while(k % i == 0) tot++, k /= i;
		base[cnt] = base[cnt - 1] * (tot + 1);
		sum[cnt] = tot;
		num[cnt] = i;
	}
	if(k > 1){
		cnt++;
		sum[cnt] = 1;
		base[cnt] = base[cnt - 1] * 2;
		num[cnt] = k;
	}
}
inline int calc(int val){
	for(int i = 1; i <= cnt; i++) b[i] = 0;
	for(int i = 1; i <= cnt; i++){
		while(val % num[i] == 0) b[i] ++, val /= num[i];
	}
	int res = 0;
	for(int i = 1; i <= cnt; i++){
		if(b[i] >= sum[i]) b[i] = sum[i];
		res += b[i] * base[i - 1];
	}
	return res;
}
inline int work(int x, int y){
	for(int i = cnt; i >= 1; i--){
		b[i] = x / base[i - 1];
		x -= b[i] * base[i - 1];
		c[i] = y / base[i - 1];
		y -= c[i] *base[i - 1];
	}
	for(int i = 1; i <= cnt; i++){
		b[i] += c[i];
		if(b[i] >= sum[i]) b[i] = sum[i];
	}
	int res = 0;
	for(int i = 1; i <= cnt; i++){
		res += b[i] * base[i - 1];
	}
	return res;
}
int main(){
//	freopen("bomboni.in.2g", "r", stdin); 
//	printf("Memory : %.2lfMB\n", (&f2 - &f1) * 1.0 / 1024.0 / 1024.0);
	scanf("%d%d", &n, &k);
	init();
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			scanf("%d", &x);
			if(x == -1) a[i][j] = -1;
			else a[i][j] = calc(x);
		}
	}
	for(int i = 0; i < base[cnt]; i++){
		for(int j = 0; j < base[cnt]; j++){
			g[i][j] = work(i, j);
		}
	}
	if(~a[1][1]) f[1][1][a[1][1]] = 1;
	for(int i = 1; i <= n; i++){
		for(int j = (i == 1 ? 2 : 1); j <= n; j++){
			if(a[i][j] == -1) continue ;
			for(int k = 0; k < base[cnt]; k++){
				f[i][j][g[k][a[i][j]]] += (f[i][j - 1][k] + f[i - 1][j][k]) % mod;
				f[i][j][g[k][a[i][j]]] %= mod;
			}
		}
	}
	printf("%d", f[n][n][base[cnt] - 1]);
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：1)

- [原题链接](https://www.luogu.com.cn/problem/P9759)。

------------

首先不妨考虑一个暴力 dp，$f_{i,j,x}$ 表示走到 $(i,j)$ 目前权值乘积模 $k$ 余 $x$ 的方案数。

这样做转移是显然的，而最后的答案就是 $f_{n,n,0}$。

想想怎么优化。我们发现权值在转移过程中进行的只有乘法运算，而我们又只关心最后权值是否是 $k$ 的倍数，这启示我们，有很多状态其实是等价的。

具体来说，我们关心的只是当前乘积与 $k$ 的最大公约数是多少，其他的都是无关紧要的。于是我们便可以把第三维压缩到 $k$ 的约数个数大小。

对于 $x \in [1,10^6]$，$d_x$ 的最大值为 $240$，故足以通过本题。

实现上，我直接用了 `unordered_map`，并且现算 $\gcd$，实际上这些都可以通过预处理避免。~~但谁叫这样最好写呢（~~

核心代码：

```cpp
mp[1][1][__gcd(v[1][1],m)]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(auto it=mp[i][j].begin();it!=mp[i][j].end();++it)
			{
				if(i+1<=n&&v[i+1][j]!=-1)
					(mp[i+1][j][__gcd(1ll*m,1ll*it->first*v[i+1][j])]+=it->second)%=mod;
				if(j+1<=n&&v[i][j+1]!=-1)
					(mp[i][j+1][__gcd(1ll*m,1ll*it->first*v[i][j+1])]+=it->second)%=mod;
			}
```


---

## 作者：MrPython (赞：0)

这题放普及组 t4 刚刚好。

$O(n^2k)$ 的做法相信大家都能做出来，这里就不讲了。

一个数的因数个数肯定不会太多。查阅经典表格发现 $10^6$ 范围内因数最多的数，其因子只有 $240$ 个。

若两个数相乘后是否能被 $h$ 整除，只和这个两个数与 $h$ 的 $\gcd$ 有关，而与 $h$ 互质的部分不会发挥作用，对后续计算不会产生影响。

综上，设已经走过的路径上所有数的乘积为 $t$。我们设计 $dp$ 的第三个维度 $k$ 为满足 $\gcd(t\bmod h,h)$ 的方案个数。最后的答案即 $f_{n,n,k}$。

```cpp
using mi = modint<998244353>;
int main(void) {
  ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
  size_t n;
  ui h;
  fin >> n >> h;
  vector<ui> d;
  array<size_t, size_t(1e6) + 1> rd;
  rd.fill(~0);
  for (ui i = 1; i <= h; ++i)
    if (h % i == 0) rd[i] = d.size(), d.emplace_back(i);
  vector<ui> gcd(h);
  for (ui i = 0; i < h; ++i) gcd[i] = rd[__gcd(i, h)];
  vector<vector<ui>> mp(n, vector<ui>(n));
  for (auto& i : mp)
    for (auto& j : i) {
      int x;
      fin >> x;
      j = x;
    }
  auto calc = [&d, h, &gcd](vector<mi> const& f, ui v) {
    if (!~v) return vector<mi>(d.size());
    vector<mi> g(d.size());
    for (size_t i = 0; i < d.size(); ++i) g[gcd[(uli)d[i] * v % h]] += f[i];
    return g;
  };
  auto merge = [](vector<mi> f, vector<mi> const& g) {
    for (size_t i = 0; i < f.size(); ++i) f[i] += g[i];
    return f;
  };
  vector<vector<vector<mi>>> dp(n, vector<vector<mi>>(n));
  dp[0][0] = vector<mi>(d.size()), dp[0][0][gcd[mp[0][0] % h]] = 1;
  for (size_t i = 1; i < n; ++i) dp[0][i] = calc(dp[0][i - 1], mp[0][i]);
  for (size_t i = 1; i < n; ++i) dp[i][0] = calc(dp[i - 1][0], mp[i][0]);
  for (size_t i = 1; i < n; ++i)
    for (size_t j = 1; j < n; ++j)
      dp[i][j] =
          merge(calc(dp[i][j - 1], mp[i][j]), calc(dp[i - 1][j], mp[i][j]));
  fout << dp.back().back().back();
  return 0;
}
```

---

## 作者：makerlife (赞：0)

[更好的阅读体验](https://blog.makerlife.top/post/dp-problems/#P9759-COCI2022-2023-3-Bomboni) | [Problem Link](https://www.luogu.com.cn/problem/P9759)

题意略。

### Solution

考虑从因数角度分析，发现只要一条路径上覆盖了 $k$ 的因数，这条路径就是合法的。

设 $f_{i, j, t}$ 为前 $(i, j)$ 位置时 $k$ 的因数剩余 $t$ 的路径数量。那么每次转移，从上一步去掉 $(i, j)$ 能贡献的因数，作为这次的答案。

最终答案即为 $f_{n, n, 1}$。

### Core Code

```cpp
f[1][1][k / __gcd(a[1][1], k)] = 1;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        if (i - 1 >= 1 && a[i][j] != -1) {
            for (auto x : f[i - 1][j]) {
                int nw = x.first / __gcd(x.first, a[i][j]);
                f[i][j][nw] = (f[i][j][nw] + x.second + mod) % mod;
            }
        }
        if (j - 1 >= 1 && a[i][j] != -1) {
            for (auto x : f[i][j - 1]) {
                int nw = x.first / __gcd(x.first, a[i][j]);
                f[i][j][nw] = (f[i][j][nw] + x.second + mod) % mod;
            }
        }
    }
}
```

---

## 作者：xixisuper (赞：0)

# P9759 [COCI2022-2023#3] Bomboni 题解

这么简单的计数题，水发题解。

## 思路

首先我们有一个很简单的思路，设 $f_{i,j,d}$ 表示走到位置 $(i,j)$ 时乘积为 $d$ 的方案数，然后就有一个显然的转移：

$$
f_{i,j,d}=f_{i-1,j,\frac{d}{a_{i,j}}}+f_{i,j-1,\frac{d}{a_{i,j}}}
$$

这时暴力转移的时间复杂度是 $O(n^2k)$，显然过不了，考虑优化。

不难发现所有对答案有贡献的 $d$ 一定是 $k$ 的因数，所以我们把第三维的定义修改一下，设 $f_{i,j,d}$ 表示走到位置 $(i,j)$ 时**乘积与 $k$ 的最大公约数为 $d$ 的方案数**。此时的转移方程式与原来是一样的，但是时间复杂度被优化至 $O(n^2\cdot d(k)\cdot \log k)$。

最后我们考虑对其进行空间上的优化和常数优化。

- 首先，我们的第三维的 $d$ 可以再次被修改为 **$k$ 与乘积的最大公约数为 $k$ 的第 $d$ 大的因数**，这样空间复杂度被优化至 $O(n^2\cdot d(n))$。
- 最后，我们注意到如果某个 $f_{i-1,j,d}$ 与 $f_{i,j-1,d}$ 都为 $0$，那么我们没有必要去计算它们对最终答案的贡献，直接 `continue` 掉即可。

然后你交一发就会发现你过了这个题。

## 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#define ll long long
using namespace std;
const int MOD=998244353;
const int N=502;
const int V=1e6+10;
ll gcd(ll a,ll b){
	if(!b) return a;
	return gcd(b,a%b);
}
int n,H,a[N][N],dp[N][N][241];
int ying[V],tag[N],tot;
void init(){
	for(int i=1;i<=H;i++){
		if(H%i) continue;
		tot++;
		ying[i]=tot;
		tag[tot]=i;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>H;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>a[i][j];
	init();
	dp[1][1][ying[gcd(a[1][1],H)]]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==1&&j==1) continue;
			for(int k=1;k<=tot;k++){
				if(a[i][j]==-1){
					dp[i][j][k]=0;
					continue;
				}
				if(!dp[i][j-1][k]&&!dp[i-1][j][k]) continue;
				int mob=gcd((ll)tag[k]*a[i][j],H);
				if(j!=1){
					dp[i][j][ying[mob]]+=dp[i][j-1][k];
					if(dp[i][j][ying[mob]]>MOD) dp[i][j][ying[mob]]-=MOD;
				}
				if(i!=1){
					dp[i][j][ying[mob]]+=dp[i-1][j][k];
					if(dp[i][j][ying[mob]]>MOD) dp[i][j][ying[mob]]-=MOD;
				}
			}
		}
	}
	cout<<dp[n][n][tot];
	return 0;
}
```

---

## 作者：Kreado (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9759)。

## 思路

我们能很容易想到一个 $O(n^2k)$ 的做法，设计状态 $f_{i,j,p}$ 表示方格 $(i,j)$ 当前余数为 $p$ 的方案数，但显然不能通过。

考虑每个 $a_{i,j}$ 对答案的贡献，显然，仅当 $\gcd(a_{i,j},k)>1$ 时有贡献，不妨对每个 $a_{i,j}\gets \gcd(a_{i,j},k)$，对于 63pts 做法，有很多 $p$ 是不必要状态，只有当 $p\mid k$ 时才是有效状态，而这种状态最多只有 $240$ 个，对于转移，我们只需从一个有效状态转移到另一个有效状态，我们不妨枚举一个可能的有效状态 $x$，那么有转移 $f_{i,j,\gcd(x\times a_{i,j},k)}\gets f_{i,j,\gcd(x\times a_{i,j},k)}+f_{i-1,j,x}+f_{i,j-1,x} $。

注意直接用 $\gcd$ 函数可能会超时，因此我们需要预处理一部分 $\gcd$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int Maxn=502,Mod=998244353,Maxm=5e6+7;
int n,k,a[Maxn][Maxn];
ll f[Maxn][Maxn][250];
int num[Maxm],cnt,pcd[1010][1010];
int gcd(ll a,ll b){
	if(a==b) return a;
	if(!a) return b;
	if(!b) return a;
	if(a<=1000&&b<=1000) return pcd[a][b];
	return gcd(b,a%b);
}
vector<int>d; 
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=1000;i++)
		for(int j=i+1;j<=1000;j++)
			pcd[i][j]=pcd[j][i]=__gcd(i,j);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]),a[i][j]=a[i][j]==-1?-1:gcd(a[i][j],k);
	for(int i=1;i<=k;i++) if(!(k%i)) d.emplace_back(i),num[i]=cnt++;
	f[1][1][num[a[1][1]]]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]!=-1){
				for(int p=0;p<d.size();p++){
					f[i][j][num[gcd(1ll*d[p]*a[i][j],k)]]=(f[i][j][num[gcd(1ll*d[p]*a[i][j],k)]]+
					f[i-1][j][p]+f[i][j-1][p])%Mod;
				}
			}
	printf("%d",f[n][n][d.size()-1]);
	return 0;
}


```


---

## 作者：Spouter_27 (赞：0)

可以只保留数字与 $k$ 的最大公约数。而 $k$ 的因数不超过 $240$ 个，于是可以直接 dp。

设 $dp_{i,j,l}$ 表示走到 $(i,j)$，目前乘积与 $k$ 的最大公约数是 $k$ 的第 $l$ 个因数。

转移枚举上一位的乘积是什么，预处理每个因数之间相乘会转移到哪个因数。

需要滚动数组优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=510,K=310,mod=998244353;
inline ll read(){
	ll a=0,x=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	x=-x;
		c=getchar();
	}
	while(isdigit(c)){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*x;
}
ll n,k,dp[2][N][K];
ll w[K][K];
ll dsc[1000010],psc[K];
signed main(){
	ll n=read(),k=read(),cnt=0;
	for(int i=1;i<=k;i++){
		if(k%i==0){
			dsc[i]=++cnt;
			psc[cnt]=i;
		}
	}
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=cnt;j++){
			w[i][j]=dsc[__gcd(k,psc[i]*psc[j])];
		}
	}
	dp[0][1][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int l=1;l<=cnt;l++)	dp[i&1][j][l]=0;
			ll x=read();
			x=dsc[__gcd(k,x)];
			if(x==-1)	continue;
			for(int l=1;l<=cnt;l++){
				(dp[i&1][j][w[x][l]]+=dp[(i-1)&1][j][l]+dp[i&1][j-1][l])%=mod;
			}
		}
	}
	printf("%lld\n",dp[n&1][n][cnt]);
	return 0;
}

```


---


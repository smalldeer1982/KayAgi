# [HUSTFC 2023] 新取模运算

## 题目描述

在这道题中，我们定义一个新的运算符号 $\oplus$ 并将其称为新取模运算。

当计算 $x \oplus y$ 时，如果 $x$ 不是 $y$ 的倍数，则得到 $x$ 除以 $y$ 的余数; 否则令 $x$ 不断除以 $y$ 直到 $x$ 不再是 $y$ 的倍数，假设它为 $x'$，然后得到 $x'$ 除以 $y$ 的余数。例如，$4\oplus 5=4$，$20\oplus 5=4$，$100\oplus 5=4$。

给定一个质数 $p$，接下来会有多组询问，对于每次询问会给出一个整数 $n$，你需要计算出 $n!\oplus p$ 的值。其中 $n!$ 是 $n$ 的阶乘，即所有小于等于 $n$ 的正整数的乘积。

## 样例 #1

### 输入

```
3 7
11
45
14```

### 输出

```
4
1
2
```

## 样例 #2

### 输入

```
2 10007
1919
810```

### 输出

```
3152
3679
```

# 题解

## 作者：sky_chen (赞：3)

【HUSTACM】此题解为官方题解。

将每个数字根据其因子内 $p$ 的最高次幂进行分组，即 $1,2,3\dots,p-1,p+1,p+2,\dots$ 为一组，$p,2p,3p,\dots,(p-1)p,(p+1)p,(p+2)p$ 为一组，以此类推。不难发现每一组内对 $p$ 的新取模运算的结果呈现 $1,2,\dots,p-1$ 循环出现，因为预处理 $1$ 到 $p-1$ 的阶乘即可。

使用快速幂的时间复杂度是 $O(p+T\log^2n)$，用威尔逊定理可以优化至 $O(p+T\log n)$。

---

## 作者：fish_love_cat (赞：2)

推柿子。~~但是卡了好久谔谔。~~

---

我们设 $f(x)=x!\oplus p$。

展开

$$f(x)=(1\times 2\times \dots \times (x-1)\times x)\oplus p$$

把 $p$ 的倍数提出来并且进行一个变形

$$f(x)=\{[(0\times p+1)\times \dots \times (1\times p-1)]\times[(1\times p+1)\times\dots\times(2\times p-1)]\times\dots\times[(\lfloor\frac{x-p}{p}\rfloor\times p+1)\times\dots\times(\lfloor\frac{x}{p}\rfloor\times p-1)]\times[(\lfloor\frac{x}{p}\rfloor\times p+1)\times \dots \times x]\times(\lfloor \frac{x}{p} \rfloor!\times p) \}\oplus p$$

化简

$$f(x)=\{[1\times 2 \times \dots \times (p-1)]^{\lfloor \frac{x}{p} \rfloor}\times (1\times 2 \times \dots \times (x\bmod p))\times(\lfloor \frac{x}{p} \rfloor!\oplus p)\}\oplus p$$

再化简

$$f(x)=\{[(p-1)!]^{\lfloor \frac{x}{p} \rfloor}\times (x\bmod p)!\times f(\lfloor \frac{x}{p} \rfloor)\}\bmod p$$

根据威尔逊定理化简得

$$f(x)=[(p-1)^{\lfloor \frac{x}{p} \rfloor}\times (x\bmod p)! \times f(\lfloor \frac{x}{p} \rfloor)]\bmod p$$

我们可以快速幂求出 $(p-1)^{\lfloor \frac{x}{p} \rfloor}$，预处理 $(x\bmod p)!$，然后递归计算结果。

做完了。

核心代码：

```cpp
int f(int x){
    if(x<p)return sum[x];
    int ans=qpow(p-1,x/p,p);
    return ans*sum[x%p]%p*f(x/p)%p;
}
```

---

## 作者：emptysetvvvv (赞：2)

### 背景

高二时出的题目，恍惚间已经四年了啊。

### 思路

记 $f(n)$ 为题目意义下 $n!\oplus p$ 的结果。注意到 $p$ 很小，可以预处理出 $k!$ 对 $p$ 常规意义下取模的结果 $g(k)$，其中 $1\le k<p$.

考虑 $1,2,3,\ldots,n$ 的组成，按照是否是质数 $p$ 的倍数分为两类。

| 模 $p$ 余 $1$ | 模 $p$ 余 $2$ | $\cdots$ | 模 $p$ 余 $k(k=n\bmod p)$ | $\cdots$ | 模 $p$ 余 $p-1$ | 模 $p$ 余 $0$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $\cdots$ | $k$ | $\cdots$ | $p-1$ | $p$ |
| $p+1$ | $p+2$ | $\cdots$ | $p+k$ | $\cdots$ | $2p-1$ | $2p$ |
| $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ |
| $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\lfloor\frac{n}{p}\rfloor p$ |
| $\lfloor\frac{n}{p}\rfloor p+1$ | $\lfloor\frac{n}{p}\rfloor p+2$ | $\cdots$ | $n$ | $\cdots$ |  |  |


首先考虑不为 $p$ 的倍数的那些数的贡献，由于这些数都不是质数 $p$ 的倍数，他们相乘的结果自然也不是 $p$ 的倍数，直接相乘取模即可。

注意到这些数对 $p$ 取模的结果由$\lfloor \frac{n}{p}\rfloor$ 组 $\{1,2,3,\ldots,p-1\}$ 与一组 $\{1,2,3,\ldots,n\bmod p\}$ 组成，因此贡献就是 $g(p-1)^{\lfloor \frac{n}{p}\rfloor}g(n\bmod p)$，这个值用快速幂可以直接算出来，最后乘到答案上就行。

然后考虑 $p$ 的倍数们的贡献，按照定义，对于其中的每一个数，我们都先让他除以 $p$，不然正常取模就是 $0$ 了。也就是说，$\{p,2p,3p,\cdots,\lfloor\frac{n}{p}
\rfloor p\}$ 的贡献，完全等价于 $\{1,2,3,\cdots,\lfloor\frac{n}{p}
\rfloor\}$ 的贡献，那么这个值不正是 $f(\lfloor\frac{n}{p}
\rfloor)$ 吗，我们要解决的问题转化为了一个形式完全一致，但规模只有原先 $\frac{1}{p}$ 的子问题，递归解决即可。

复杂度 $O(p+T\log n)$.

### 代码

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 1000005;
int T, p, fac[maxn];
long long n;
long long power(long long x, long long k) {
    long long ans = 1;
    while(k) {
        if(k & 1) ans = ans * x % p;
        x = x * x % p;
        k >>= 1;
    }
    return ans;
}
int solve(long long n) {
	if(n < p) return fac[n];
	return power(fac[p-1], n/p) * fac[n%p] % p * solve(n/p) % p;
}
int main() {
    cin >> T >> p;
	fac[0] = 1;
	for(int i = 1; i < p; ++i)
		fac[i] = (long long)fac[i-1] * i % p;
	while(T--) {
		cin >> n;
        cout << solve(n) << endl;
	}
}
```

### p.s

由威尔逊定理 $(p-1)!\equiv -1\pmod p$ 可知 $g(p-1)=-1$，这样就只用考虑 $-1$ 的多少次方而无需快速幂了。

_(话说审核把题解打回说"!=“要用”\not"，但是此处真的是阶乘符号”!“）_


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int maxn = 1000005;
int T, p, fac[maxn];
long long n, ans;
int main() {
    cin >> T >> p;
	fac[0] = 1;
	for(int i = 1; i < p; ++i)
		fac[i] = (long long)fac[i-1] * i % p;
	while(T--) {
		cin >> n;
        ans = 1;
        while(n) {
            ans = ans * fac[n%p] % p;
            if(n/p & 1) ans = p - ans;
            n /= p;
        }
        cout << ans << endl;
	}
}
```

此外，这个题目的点子源于一道证明题，大致写一下：

题目求，$n!$ 中去除所有素因子 $p$，求对 $p$ 取模的结果。

即 **$n!$ 表示为 $p$ 进制后，从低位往高位第一个非 $0$ 数字**。

为了与传统意义下的 $\text{lowbit}$ 相互区别，我们不妨把 $(x)_p$ 从低位往高位第一个非 $0$ 数字记为 $\text{lobit}(x)$.

显然，$\text{lobit(}n!)$ 与 $1,2,3,\ldots,n$ 中每个数字的 $\text{lobit}$ 有关。

更准确的说，是 $\prod_{i=1}^n\text{lobit}(i)\bmod p$.

尽管 $n$ 的可能相当大，但是 $\log_pn$ 不超过 $63$，这个 $p$ 进制数的位数很小。

我们可以考虑从低到高每一位是否作为 $\text{lobit}$ 产生贡献。

设 $(n)_p=(a_m\cdots a_2a_1a_0)_p$，其中

$$a_k=\left\lfloor\frac{n}{p^k}\right\rfloor\mod p$$

以最低位为例，我们发现，最低位会依次取 $1,2,...,p-1$，若干个循环后，取 $1,2,...,a_0$ 结束。

进一步的，循环回合数就是 $(a_m\cdots a_2a_1)_p$，即 $\displaystyle\lfloor n/p\rfloor$.

那么最低位作为 $\text{lobit}$ 的贡献是多少呢？

$$\displaystyle{(p-1)!}^{\lfloor\frac{n}{p}\rfloor}a_0! \mod p$$

$$=\displaystyle(-1)^{\lfloor\frac{n}{p}\rfloor}a_0! \mod p$$

则总贡献为

$$\displaystyle(-1)^{\lfloor n/p\rfloor+\lfloor n/p^2\rfloor+\cdots+\lfloor n/p^m\rfloor}a_0!a_1!\cdots a_m!\mod p$$

$$=\displaystyle(-1)^{\varepsilon_p{(n)}}\prod_{i=0}^m a_i!\mod p$$

这个等式还是蛮有趣的。

---

## 作者：xuezhiyu (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9774)

# 分析题目

首先很明显这个 $\oplus$ 运算满足分配律，即满足 $(a \times b) \oplus c=[(a \oplus c) \times (b \oplus c)] \oplus c$。

乍一看数据范围 $10^{18}$ 不知道从何下手，我们不妨先来分析一组案例。

## $n=9,p=4$

我们要求 $9!\oplus4$，先把式子展开变成：

$$(1 \times 2 \times 3 \times 4 \times 5 \times 6 \times 7 \times 8 \times 9) \oplus 4$$

我们可以发现在这个式子中有两个 $4$ 的倍数：$4$ 和 $8$，于是我们就需要给它提出来并且除以一个 $4$ 把 $(4 \times 8)\oplus4$ 通过结合律拆成 $[(4 \oplus 4) \times (8 \oplus 4)] \oplus 4=(1 \times 2) \oplus 4$，相当于对于所有 $4$ 的倍数都除以 $4$，就又变成了一个阶乘新取模上 $p$ 的形式，具体就是 $(\lfloor \frac{n}{p} \rfloor)! \oplus p$。我们愉快地发现这个问题又成为了原来我们要求解的问题，只不过 $n$ 变成了 $\lfloor \frac n p \rfloor$ 而已。

之后这个式子还剩下

$$(1 \times 2 \times 3 \times 5 \times 6 \times 7 \times 9) \oplus 4$$

因为此时左边的式子中已经没有 $4$ 的倍数了，所以左边的式子也不会是 $4$ 的倍数，所以此时新取模运算就成为了普通的取模运算。我们带入取模运算的分配律 $(a \times b) \bmod c=((a \bmod c) \times (b \bmod c)) \bmod c$ 就可以将原式子变成

$$[(1 \times 2 \times 3) \times (1 \times 2 \times 3) \times (1)] \oplus 4$$

我们发现这里被拆成了 $[(n-1)!]^k \times m!$ 的形式，那么这个 $k$ 和 $m$ 分别是什么呢？每个 $(n-1)!$ 都对应着一个 $4$ 的倍数，所以 $k=\lfloor \frac{n}{p} \rfloor$；至于剩下的这个 $m$，自然就是 $n \bmod p$ 了。

结合上面的，我们就可以发现：

$$
\begin{aligned}
9! \oplus 4 &= [(\lfloor \frac 9 4 \rfloor)! \oplus 4] \times [(n-1)!]^{\lfloor \frac n p \rfloor} \times (9 \bmod 4)! \bmod p \\
            &= (2! \oplus 4) \times (3!)^2 \times 1! \bmod 4
\end{aligned}
$$

在这里 $2! \oplus 4$ 因为 $2<4$ 的缘故所以 $2!$ 中不可能有 $4$ 的倍数，于是我们可以直接求解；但是在其它情况中可能不满足这个条件，我们就需要一直递归求解。递归的终止条件就是当 $n! \oplus p$ 中的 $n<p$ 时，直接返回 $n! \bmod p$。

至于后面的两项，可以直接用快速幂求。

---

最后，我们就可以总结出通项公式：

$$
n!\oplus p=

\left \{
\begin{aligned}
&n! \bmod p&,~n<p \\
&[(\lfloor \frac{n}{p} \rfloor)! \oplus p]\times [(p-1)!]^{\lfloor \frac n p \rfloor} \times (n \bmod p)! &,~n
\ge p
\end{aligned}
\right.
$$

---

注意到 $p$ 值的范围很小，只有 $10^6$，所以预处理出来 $i! \bmod p~(1 \le i < p)$ 是可以接受的。

于是我们递归处理这个式子，总的时间复杂度 $O(P+T \log_2 \frac N P \log_p N)$，足以通过本题。

## 拓展

如果使用[威尔逊定理](https://oi-wiki.org/math/number-theory/wilson/)可以让复杂度降到 $O(P+T \log_p N)$ 的。这个定理就是在说 $\forall p \text{ 是质数},~(p-1)! \equiv -1 \pmod p$。于是上面的 $[(p-1)!]^k=(-1)^k$，可以 $O(1)$ 算出。

至于证明吗，自己去看 [OI Wiki](https://oi-wiki.org/math/number-theory/wilson/)。~~绝对不是因为我不会~~

# 代码时间

## 不带威尔逊定理的

时间复杂度 $O(P+T \log_2 \frac N P \log_p N)$。

```cpp
#include <iostream>
#define int long long
#define endl '\n'

using namespace std;

constexpr int N = 1e6 + 10;
int T, p, fac[N];

int quick_power(int base, int power) {
	int res = 1;
	while (power) {
		if (power & 1) res = res * base % p;
		base = base * base % p;
		power >>= 1;
	}
	return res;
}

int calc(int n) {
	if (n < p) return fac[n];
	return quick_power(fac[p - 1], n / p) * calc(n / p) % p * fac[n % p] % p;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> T >> p;
	fac[0] = 1;
	for (int i = 1; i < p; i++) fac[i] = fac[i - 1] * i % p;
	while (T --> 0) {
		int n;
		cin >> n;
		cout << calc(n) << endl;
	}
	return 0;
}
```

## 带威尔逊定理优化的

时间复杂度 $O(P+T \log_p N)$

```cpp
#include <iostream>
#define int long long
#define endl '\n'

using namespace std;

constexpr int N = 1e6 + 10;
int T, p, fac[N];

int calc(int n) {
	if (n < p) return fac[n];
	return (((n / p) & 1) ? p - 1 : 1) * calc(n / p) % p * fac[n % p] % p;
  // 注：这里用 p - 1 代替 -1 是为了不用负数取模
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> T >> p;
	fac[0] = 1;
	for (int i = 1; i < p; i++) fac[i] = fac[i - 1] * i % p;
	while (T --> 0) {
		int n;
		cin >> n;
		cout << calc(n) << endl;
	}
	return 0;
}
```

---

## 作者：XIAOWANGCHAI (赞：1)

什么威尔逊定理，我不到啊。

---

### 题意
给你一个新定义运算，说白了就是把一个数一直除以 $p$ 后取模 $p$ 的余数，让你求 $T$ 组 $n!$ 下的结果。

### 正文
考虑到要先除以 $p$，我们分开讨论以下 $\text{ans}$ 的组成：

1. 原本 $n!$ 中本来就不是 $p$ 的倍数的。
2. 原本 $n!$ 中是 $p$ 的倍数。

第二部分我们待会讨论，假设第二部分已经求完了，只差取模了，对于第一部分很好求，就是一堆 $\displaystyle \prod_{i=1}^{p-1}i$ 再乘起来。注意，由于周期不完整，最后还钓了一个尾巴没算。

> 说白点就是 $(1 \times 2 \times 3 \times 4 ... \times (p-1)) \times ((p+1) \times (p+2) ... \times (2 \times p-1))...$，取模后就是 $(1 \times 2 \times 3 \times 4 ... \times (p-1)) \times (1 \times 2 \times 3 \times 4 ... \times (p-1)) ...$

先算完整周期，具体多少个呢？$n$ 个数中每 $p$ 个数都出现了一次周期，所以共有 $\lfloor \dfrac{n}{p} \rfloor$ 个周期，所以第一部分的答案为 $\displaystyle (\prod _{i=1}^{p-1}i)^{\lfloor \dfrac{n}{p} \rfloor}$，至于阶乘怎么求，$p$ 是固定的，直接预处理即可。最好还要把钓的尾巴乘上来，那么还剩 $n \bmod p$ 个数，直接乘上 $\displaystyle \prod _{i=1}^{n \bmod p} i$ 即可。

接下来考虑第二部分。

无疑来讲，第二部分的组成就是：

$$
p,2 \times p,3 \times p,4 \times p...
$$

既然要除以 $p$，注意，题目说的是先除以 $p$ 再取模，我们全部除以**一个** $p$ 后：

$$
1,2,3,4...
$$

没错，剩下的数又变成了一段连续的数，范围为 $[1,\lfloor \dfrac{n}{p} \rfloor]$，至于剩下怎么做，当然是回到前面再把答案分为两部分处理啦~递归即可，唯一注意的就是记得把 $n$ 除以个 $p$，因为剩下还有 $\lfloor \dfrac{n}{p} \rfloor$ 个数。

这个题就可以愉快的做完了。

由于 $n$ 很大，需要实现快速幂。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define code using
#define by namespace
#define XWC std;
#define f first
#define s second
#define debug(a,n)\
		cerr<<#a<<":";\
		for(int i=1;i<=n;i++) cerr<<#a<<"["<<i<<"]="<<a[i]<<" ";\
		cerr<<"\n";
#define debug2(a,n,m)\
		cerr<<#a<<":\n";\
		for(int i=1;i<=n;i++){\
			for(int j=1;j<=m;j++) cerr<<#a<<"["<<i<<"]["<<j<<"]="<<a[i][j]<<" ";\
			cerr<<"\n";\
		}\
		cerr<<"\n";
#define ls (k<<1)
#define rs (k<<1|1)
code by XWC
template<typename T>
inline void read(T &x){
	x=0;
	char ch=getchar();
	bool f=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(f) x=-x;
}
template<typename T,typename ...Args>
inline void read(T &tmp,Args &...tmps){
	read(tmp);
	read(tmps...);
}
int t,p;
int n;
const int N=1e6+10;
int mul[N];
void init(){//初始化阶乘
	mul[0]=1;
	for(int i=1;i<N;i++) mul[i]=mul[i-1]*i%p;
}
int qpow(int a,int b,int p){//快速幂
	int ret=1;
	while(b){
		if(b&1){
			ret*=a;
			ret%=p;
		}
		a*=a;
		a%=p;
		b>>=1;
	}
	return ret;
}
signed main(){
	read(t,p);
	init();
	while(t--){
		read(n);
		int ans=1;
		while(n){//递归处理
			ans=ans*qpow(mul[p-1],n/p,p)%p*mul[n%p]%p;
			n/=p;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：lihl (赞：1)

### 题意
若有正整数 $x,y$，其中 $x = ky + b$，定义
$$x\oplus y = \begin{cases}
b & b\ne 0 \\
k & b = 0
\end{cases}$$

多组询问求 $n!\oplus p$，其中 $p$ 为一质数。
### 分析
显然该运算满足分配律。

>**Lemma 1** 若 $n<p$，则有 $n!\oplus p = n!\bmod p$ 成立。
>
>**Proof 1** 显然 $\forall i\in[1,n],p\nmid i$。则易得。

于是 $n<p$ 时直接判断即可。

考虑

$$\begin{aligned}
n!\oplus p &= (\prod_{i=1}^n i)\oplus p \\
&= \prod_{i=1}^n (i\oplus p) \\
&= (\lfloor\frac{n}{p}\rfloor! \times (p-1)!^{\lfloor\frac{n}{p}\rfloor}\times (n\bmod p)!)\oplus p \\
&= (\lfloor\frac{n}{p}\rfloor!\oplus p)\times (p-1)!^{\lfloor\frac{n}{p}\rfloor}\times (n\bmod p)!
\end{aligned}$$

简单解释第三步。

> 不难发现，在 $n!$ 中，会有 $\lfloor\frac{n}{p}\rfloor$ 个数是 $p$ 的倍数。这些数的乘积是 $\lfloor\frac{n}{p}\rfloor!$。
>
> 在其余数中，由于模的性质 $ab\equiv(a\bmod x)(b \bmod x)\pmod x$，它们构成一个以 $\lfloor\frac{n}{p}\rfloor$ 为周期的 $1\sim p-1$ 的排列，显然它们的乘积是 $(p-1)!^{\lfloor\frac{n}{p}\rfloor}$。
>
> 若 $p\nmid n$，则显然有 $n\bmod p$ 个数不在周期内，它们也是一个 $1\sim n\bmod p$ 的排列，显然它们的乘积是 $(n\bmod p)!$。

$(p-1)!$ 可以 Wilson 维护跳过快速幂 $\log$，$n!\bmod p$ 可以预处理维护。

时间复杂度 $\mathcal{O}(p + T\log_{p} n)$。

---

## 作者：破壁人罗辑 (赞：0)

题目传送门
[P9774 新取模运算](https://www.luogu.com.cn/problem/P9774)

### 前置知识：

威尔逊定理：

当 $p$ 为素数时，$p-1$ 的阶乘和 $-1$ 模 $p$ 同余，即 $(p-1)!\equiv -1\pmod p$。

### 解题思路：

我们可以把 $1$ 到 $n$ 中不是 $p$ 的倍数的前 $p\times\left[\frac np\right]$ 个数分为 $\left[\frac np\right]$ 组乘积为 $-1$ 的数，剩余的不是 $p$ 的倍数的数乘积为 $(n \bmod p)!$。

然后我们把 $n$ 除以 $p$，继续用上述方法处理是 $p$ 的倍数的数，循环这种处理方式，直到 $n$ 小于 $p$。

因为 $p$ 较小，我们可以用 $O(p)$ 的复杂度预处理 $1$ 到 $p$ 中每个数的阶乘。

程序的总时间复杂度为 $O(p+T\log n)$。

注意 $1\leq n\leq 10^{18}$，需要开 long long。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long p,pj[1000000];
int main(){
	int T;
	scanf("%d%llu",&T,&p);
	pj[0]=1;pj[1]=1;
	for(unsigned long long i=2;i<p;i++)pj[i]=i*pj[i-1]%p;
	while(T--){
		unsigned long long ans=1,n;scanf("%llu",&n);
		while(n){
			ans=ans*pj[n%p]%p;
			ans=(n/p)&1?p-ans:ans;
			n/=p;
		}
		printf("%llu\n",ans);
	}
	return 0;
}
```


---


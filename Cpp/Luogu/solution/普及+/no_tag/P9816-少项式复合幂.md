# 少项式复合幂

## 题目背景

> I have won everything except your heart.

终于，小 Z 可以玩一年原神了。但在此之前，他决定做出这道题，以纪念自己对【数据删除】的感情。

## 题目描述

给定多项式 $f(x)=\sum_{i=1}^ma_ix^{b_i}$。定义 $f_1(x)=f(x)$，$f_n(x)=f(f_{n-1}(x))$。

给定模数 $p$。有 $q$ 次询问，每次给出 $x,y$，查询 $f_y(x)\bmod p$ 的值。

**请注意 $m,p$ 的特殊数据范围。**

## 说明/提示

#### 样例解释

样例 1 中 $f(x)=3x^3+x+1$。以第 3 次询问为例，$f_1(10)=f(10)=3\times10^3+10+1=3011\equiv 29 \pmod {71}$。

#### 数据范围与约定

|测试点编号|$y$|$m$|$q$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1\sim 3$|$\le 10$|$\le 20$|$\le 10^3$|无|
|$4\sim 7$|$\le 10^3$|$\le 20$|$\le 10^4$|无|
|$8,9$|$\le 10^7$|$\le 1$|$\le 3\times 10^5$|A|
|$10$|$\le 10^7$|$\le 1$|$\le 3\times 10^5$|无|
|$11,12$|$\le 10^7$|$\le 2$|$\le 10^5$|A、B|
|$13$|$\le 10^7$|$\le 2$|$\le 10^5$|B|
|$14\sim 16$|$\le 10^7$|$\le 20$|$\le 500$|无|
|$17\sim 20$|$\le 10^7$|$\le 20$|$\le 3\times 10^5$|无|
- 特殊性质 A：保证 $p$ 为质数。
- 特殊性质 B：保证 $b_i\le 1$。

对于所有数据，保证 $1\le m\le 20$，$0\le a_i,b_i\le 10^5$，$2\le p\le 10^5$，$1\le q\le 3\times 10^5$，$1\le x,y\le 10^7$。

## 样例 #1

### 输入

```
3 5 71
1 1
3 3
1 0
7 5
9 6
10 1
5 6
7 6```

### 输出

```
27
11
29
2
5```

# 题解

## 作者：znszns (赞：17)

# P9816 少项式复合幂题解
[题目传送门](https://www.luogu.com.cn/problem/P9816)

## $35$ 分做法

先注意题目加粗的字，提示我们应该考虑 $p$ 的范围。

### 预处理

显然 $f(x)\equiv f(x\bmod\ p)(\bmod\ p)$，所以考虑预处理 $f(x)\bmod p$，$f(x)=\sum_{i=1}^ma_ix^{b_i}$，$x$ 范围为 $0$ 到 $p-1$，时间复杂度为 $\Theta(mp\log{bi})$。

### 查询操作

直接一次一次跳，暴力跳 $y$ 次找到 $f_y(x)\bmod p$，时间复杂度为 $\Theta(qy)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
int m,q;
ll mod,f[N],a[N],b[N];
ll qpow(ll x,ll y)
{
	ll res=1;
	for(;y;y>>=1,x=x*x%mod)
	{
		if(y&1) res=res*x%mod;
	}
	return res;
}
int main()
{
	scanf("%d%d%lld",&m,&q,&mod);
	for(int i=1;i<=m;i++) scanf("%lld%lld",&a[i],&b[i]);
	for(int i=0;i<mod;i++)
	{
		for(int j=1;j<=m;j++)
		{
			f[i]=(f[i]+a[j]*qpow(i,b[j])%mod)%mod;
		}
	}
	ll x,y,ans;
	for(int i=1;i<=q;i++)
	{
		scanf("%lld%lld",&x,&y);
		ans=f[x%mod];
		for(int j=2;j<=y;j++)
		{
			ans=f[ans];
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
## $100$ 分做法

可以发现查询操作若为 $\Theta(q\log{y})$ 是可以过的，于是先求出 $y$ 的二进制表示，比如说要跳 $10$ 次，相当于先跳 $2^1$ 次，再跳 $2^3$ 次。

### 预处理
用 $dp(i,j)$ 表示 $f(x)$ 跳 $2^j$ 次的结果，转移为 $dp(i,j)=dp(dp(i,j-1),j-1)$。

### 查询操作

把 $y$ 用二进制表示，最低位是第 $0$ 位，若第 $i$ 位为 $1$，设当前答案为 $ans$，$ans$ 则跳到 $dp(ans,i)$，表示跳了 $2^i$ 次，最后输出 $ans$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10,M=25;
int m,q;
ll mod,f[N][M],a[N],b[N];
ll qpow(ll x,ll y)
{
	ll res=1;
	for(;y;y>>=1,x=x*x%mod)
	{
		if(y&1) res=res*x%mod;
	}
	return res;
}
int main()
{
	scanf("%d%d%lld",&m,&q,&mod);
	for(int i=1;i<=m;i++) scanf("%lld%lld",&a[i],&b[i]);
	for(int i=0;i<mod;i++)
	{
		for(int j=1;j<=m;j++)
		{
			f[i][0]=(f[i][0]+a[j]*qpow(i,b[j])%mod)%mod;
		}
	}
	for(int j=1;j<M;j++)
	{
		for(int i=0;i<mod;i++)
		{
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	ll x,y,ans,cnt;
	for(int i=1;i<=q;i++)
	{
		scanf("%lld%lld",&x,&y);
		cnt=0;
		ans=x%mod;
		while(y)
		{
			if(y&1) ans=f[ans][cnt];
			cnt++;
			y>>=1;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：zhouyuhang (赞：15)

注意到 $f(x)\equiv f(y)\pmod p$ 当 $x\equiv y\pmod p$。那么考虑有向图 $G$：$x\to f(x)\bmod p$，则一次询问 $(x,y)$ 的答案即为 $G$ 上从点 $x\bmod p$ 走 $y$ 步后的结果。倍增即可做到 $\Theta(mp\log b_i+(q+n)\log y)$。

---

## 作者：过氧化氢_syq0057 (赞：6)

## 题外话

调试了半天原来是数组越界了，我是不该退役了 /ch。

## Solution

转化题意：$f_y(x)$ 即为 $f(f(f(f(...))))$ 做 $y$ 次 $f(x)$。其中 $f(x)= \sum_{i=1}^m a_ix^{b_i}$

这里我们很容易想到倍增。

但还有一个问题，直接倍增预处理 $x$ 是 $xm \log x \log b_i$ 的复杂度，显然过不了。不过我们观察到一个性质，也是出题人提到的一点：$f(x) \equiv f(y)(\bmod p)$ 当 $x \equiv y(\bmod p)$。注意到 $p\le 10^5$，所以我们按 $p$ 倍增，像树那样，做 $x \rightarrow f(x)$ 然后倍增即可。

其中 $f[x][y]$ 表示 $x$ 走 $2^y$ 步的结果。

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
const int N = 100005;
const int M = 300005;
#define ll long long
const int INF = 0x3f3f3f3f;
//const int mod = 1000000007;
int m, q;
ll mod;
ll a[N], b[N];
ll f[M][24];//f[x][y]:x做2^y次f(x) 
ll ksm(ll x, ll y) {
	ll res = 1;
	while (y) {
		if (y & 1) res = res * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return res;
}
ll F(ll x) {
	ll res = 0;
	for (int i=1; i<=m; i++)
		res = (res + a[i] * ksm(x, b[i]) % mod) % mod;
	return res;
}
int main() {
	scanf("%d%d%lld", &m, &q, &mod);
	for (int i=1; i<=m; i++)
		scanf("%lld%lld", &a[i], &b[i]);
	for (ll i=0; i<mod; i++)
		f[i][0] = F(i);
	for (int j=1; j<=23; j++)
		for (int i=0; i<mod; i++)
			f[i][j] = f[f[i][j - 1]][j - 1];
	ll x, y, ans;
	while (q--) {
		scanf("%lld%lld", &x, &y);
		ans = x % mod;
		for (int i=23; i>=0; i--)
			if ((y >> i) & 1)
				ans = f[ans][i];
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：int_R (赞：2)

[P9816 少项式复合幂](https://www.luogu.com.cn/problem/P9816)

[更好的阅读体验](https://www.cnblogs.com/int-R/p/P9816.html)

给定多项式 $f(x)=\sum_{i=1}^ma_ix^{b_i}$。定义 $f_1(x)=f(x)$，$f_n(x)=f(f_{n-1}(x))$。

就是初始将 $x$ 代入多项式，再将结果代入，总共代入 $y$ 次。

根据提示发现模数 $p$ 是 $10^5$ 级别的，于是对于 $x\in[0,p-1]$ 暴力计算出 $f(x)\bmod p$ 的值。然后既然知道了每个 $x$ 带入一次的值，之后倍增处理一下即可。时间复杂度 $O(mp\log p+(p+q)\log y)$。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
int m,q,p,a[25],b[25],f[MAXN][25];
inline long long ksm(long long a,int b)
{
    long long ans=1;
    while(b)
    {
        if(b&1) ans=ans*a%p;
        a=a*a%p,b>>=1;
    }
    return ans;
}
int main()
{
#ifdef ONLINE_JUDGE
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
#endif
    cin>>m>>q>>p;
    for(int i=1;i<=m;++i) cin>>a[i]>>b[i];
    for(int x=0;x<p;++x)
    {
        long long sum=0;
        for(int i=1;i<=m;++i)
            sum+=ksm(x,b[i])*a[i]%p;
        f[x][0]=sum%p;
    }
    for(int j=1;j<25;++j)
        for(int i=0;i<p;++i)
            f[i][j]=f[f[i][j-1]][j-1];
    while(q--)
    {
        int x,y;cin>>x>>y;x%=p;
        for(int j=24;j>=0;--j)
            if(y&(1<<j)) x=f[x][j];
        cout<<x<<'\n';
    }
    return 0;
}
```

---

## 作者：hikariyo_ (赞：1)

官解是转化成了图论问题，但是我看不出来，只好考虑嗯造柿子了。

观察到 $p$ 的范围是 $10^5$，然后 $f(x)$ 是一个多项式，因此有：

$$
f(x)\equiv f(x\text{ mod } p)\pmod p
$$

所以说我们只需要把 $x\in[0,p),f(x)$ 的值全都打表出来就好了，接下来考虑如何处理复合多项式，即 $f_n(x)$。

观察题面的 $f_n(x)=f(f_{n-1}(x))$ 不难知道：

$$
f_n(x)=f_{t_1}(f_{t_2}(\cdots))\text{ when }n=\sum t_i
$$

因此考虑将 $n$ 二进制拆分，预处理出所有 $f_{2^i}(x)$ 就可以做到单次查询 $O(\log y)$。

预处理 $f(x)$ 复杂度是 $O(pm\log b)$，$f_{2^i}(x)$ 复杂度是 $O(p\log y)$，拆分的时候可以用 `lowbit` 取出每一位然后求个对数，也可以直接枚举所有位数，我这里用了前者。

注意读入 $x$ 后先取模，我前几次交的时候因为这个直接[全部 RE](https://www.luogu.com.cn/record/132248541)。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define lowbit(x) ((x)&(-x))

template<typename T>
void read(T& res) {
    char ch = getchar();
    T sig = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-') sig = -1;
        ch = getchar();
    }
    res = 0;
    while ('0' <= ch && ch <= '9') {
        res = res*10 + (ch&15);
        ch = getchar();
    }
    res *= sig;
}

const int N = 1e7+10, P = 1e5+10;
int f[24][P], lg2[N];
int m, q, p;

int qmi(int a, int k) {
    int res = 1;
    while (k) {
        if (k & 1) res = 1LL * res * a % p;
        a = 1LL * a * a % p;
        k >>= 1;
    }
    return res;
}

void init() {
    vector<int> a(m), b(m);
    for (int i = 0; i < m; i++) read(a[i]), read(b[i]);
    for (int x = 0; x < p; x++) {
        for (int i = 0; i < m; i++)
            f[0][x] = (f[0][x] + 1LL * a[i] * qmi(x, b[i])) % p;
    }

    for (int k = 1; k <= 23; k++)
        for (int x = 0; x < p; x++)
            f[k][x] = f[k-1][f[k-1][x]];
    
    for (int k = 0; k <= 23; k++)
        lg2[1 << k] = k;
}

int main() {
    read(m), read(q), read(p);
    init();

    while (q--) {
        int x, y;
        read(x), read(y);
        x %= p;
        while (y) {
            x = f[lg2[lowbit(y)]][x];
            y -= lowbit(y);
        }
        printf("%d\n", x);
    }
    
    return 0;
}
```


---

## 作者：Spouter_27 (赞：1)

对于 $i\in[0,p)$，直接暴力求出 $f(i)$ 的值。然后考虑倍增的思想，$f_x(i)=f_{\frac{x}{2}}(f_{\frac{x}{2}}(i))$，预处理出来所有 $k=2^p$，$f_k(i)$ 的值，询问的时候对 $y$ 二进制拆分一下就好了。

注意处理之前要先对 $x$ 取一下模，不然会全 RE。

```cpp
ll qpow(ll a,ll b){
	ll ans=1,base=a;
	while(b){
		if(b&1)	ans=ans*base%p;
		base=base*base%p;
		b>>=1;
	}
	return ans;
}
ll m,a[N],b[N],q,x,y;
ll f[N][35];
signed main(){
	m=read(),q=read(),p=read();
	for(int i=1;i<=m;i++){
		a[i]=read(),b[i]=read();
	}
	for(int i=0;i<p;i++){
		for(int j=1;j<=m;j++){
			(f[i][0]+=a[j]*qpow(i,b[j]))%=p;
		} 
	}
	for(int i=1;i<=30;i++){
		for(int j=0;j<p;j++){
			f[j][i]=f[f[j][i-1]][i-1];
		}
	}
	while(q--){
		x=read()%p,y=read();
		for(ll i=0;i<30;i++){
			if((y>>i)&1)	x=f[x][i];
		}
		printf("%lld\n",x);
	}
	return 0;
}
```


---

## 作者：Union_Find (赞：1)

呃，其实没那么难吧，就是亿个预处理，但思维量还是有的。

首先考虑到模。因为 $m$ 和 $p$ 都很小，不是什么 $\le 1e9$，那就说明突破口在 $p$ 和 $m$。

先考虑快速幂优化，但是 $y$ 太大了，不能全枚举，所以考虑倍增。

倍增精髓在预处理，也是这题的重要考点，要预处理出所有 $x,y \le p$ 的 $f_y(x)$ 的值，然后询问时通过~~神奇~~计算算出结果。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
ll m, T, P, a[35], b[35], x, y, p[35], f[35][100005], ans;
il ll ksm(ll x, ll r, ll P){
	ll ans = 1;
	while (r){
		if (r & 1) ans = ans * x % P;
		x = x * x % P;
		r >>= 1;
	}
	return ans;
}
int main(){
	scanf ("%lld %lld %lld", &m, &T, &P);
	p[0] = 1;
	for (int i = 1; i <= 25; i++) p[i] = (p[i - 1] << 1);
	for (int i = 1; i <= m; i++) scanf ("%lld %lld", &a[i], &b[i]);
	for (int i = 0; i < P; i++)
		for (int j = 1; j <= m; j++)
			f[0][i] = (f[0][i] + a[j] * ksm(i, b[j], P)) % P;
	for (int i = 1; i <= 25; i++)
		for (int j = 0; j < P; j++)
			f[i][j] = f[i - 1][f[i - 1][j]];
	while (T--){
		scanf ("%lld %lld", &x, &y), ans = 0, y--;
		for (int i = 1; i <= m; i++) ans = (ans + a[i] * ksm(x, b[i], P)) % P;
		for (int u = 25; y; u--)
			if (p[u] <= y)
				ans = f[u][ans], y -= p[u];
		printf ("%lld\n", ans);
	} 
	return 0;
}

```

---

## 作者：sbno333 (赞：0)

~~感谢出题人提醒数据范围~~

我们看 $f$ 函数，不难证明若 $a$ 与 $b$ 在模 $p$ 的意义下相同，则 $f(a)$ 与 $f(b)$ 在模 $p$ 的意义下相同。

由于 $p\le10^5$，因此可以用 $f_i$ 表示 $f(i)$ 的值，其中 $i$ 为模 $p$ 意义下。

因此 $f(f(i))$ 的值为 $f_{f_i}$。

想象中可以构件一个又向图，第 $i$ 节点仅只有一条出边，即 $f_i$，因此 $f_y(x)$ 为从 $x$ 沿着有向边走 $y$ 次。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int f[100009];
int p,m,q;
int a[39];
int b[39];
int pwo(int a,int b){
	int ans;
	ans=1;
	while(b){
		if(b&1){
			ans*=a;
		}
		a*=a;
		b/=2;
		ans%=p;
		a%=p;
	}
	return ans;
}
void mk(int s){
	for(int i=1;i<=m;i++){
		f[s]+=a[i]*pwo(s,b[i]);
		f[s]%=p;
	}
}
int qu(int x,int y){
	if(y==0){
	    return x;
	}
	return qu(f[x],y-1);
}
signed main(){
	cin>>m>>q>>p;
	for(int i=1;i<=m;i++){
		cin>>a[i]>>b[i];
	}
	for(int i=0;i<p;i++){
		mk(i);//计算f[i]
	}
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		x%=p;
		cout<<qu(x,y)<<endl;//表示一次询问
	}
	return 0;
}
```

显然，只是这样的话太慢了，分数只有 $35$，因此我们需要用一些算法来加快速度。

倍增是个好东西 $f_{i,j}$ 表示 $f_{2^j}(i)$。

原来的 $f_i$ 变为 $f_{i,0}$。

```cpp
void mk(int s){
	for(int i=1;i<=m;i++){
		f[s][0]+=a[i]*pwo(s,b[i]);
		f[s][0]%=p;
	}
}
```
显然，$f_{j,i}=f_{f_{j,i-1},i-1}$。

```cpp
for(int i=1;i<=25;i++){
	for(int j=0;j<p;j++){
		f[j][i]=f[f[j][i-1]][i-1];
	}
}
```
计算 $f_y{x}$ 是也不难，答案为 $f_{f_{...f_{x,v_1}},v_{d-1}},v_{d}$。

其中 $2^{v_1}+2^{v_2}......+2^{v_{d-1}}+2^{v_d}=y$。

可以很快算出。

```cpp
int qu(int x,int y){
	int inn;
	inn=0;
	while(y){
		if(y&1){
			x=f[x][inn];
		}
		y/=2;
		inn++;
	}
	return x;
}
```
因此代码就出炉啦。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int f[100009][29];
int p,m,q;
int a[39];
int b[39];
int pwo(int a,int b){
	int ans;
	ans=1;
	while(b){
		if(b&1){
			ans*=a;
		}
		a*=a;
		b/=2;
		ans%=p;
		a%=p;
	}
	return ans;
}
void mk(int s){
	for(int i=1;i<=m;i++){
		f[s][0]+=a[i]*pwo(s,b[i]);
		f[s][0]%=p;
	}
}
int qu(int x,int y){
	int inn;
	inn=0;
	while(y){
		if(y&1){
			x=f[x][inn];
		}
		y/=2;
		inn++;
	}
	return x;
}
signed main(){
	cin>>m>>q>>p;
	for(int i=1;i<=m;i++){
		cin>>a[i]>>b[i];
	}
	for(int i=0;i<p;i++){
		mk(i);
	}
	for(int i=1;i<=25;i++){
		for(int j=0;j<p;j++){
			f[j][i]=f[f[j][i-1]][i-1];
		}
	}
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		x%=p;
		cout<<qu(x,y)<<endl;
	}
	return 0;
}
```


---

## 作者：_XHY20180718_ (赞：0)

## 简要题意：
给你一个 $m$ 项式 $f(x)$，$q$ 次询问，每次询问问你 $f_y(x)$ 的值是多少？

## 具体做法：
观察数据范围，发现模数不大于 $10^5$，发现肯定有循环节，深入思考，发现循环节不止一个，如果把 $f(x)$ 看做父亲，则会形成一个基环树森林，那么我们可以把图建出来，然后再暴力跳倍增即可。

时间复杂度：$O(p(m+\log y)+q\log y)$。

空间复杂度：$O(p\log y)$。

现在这个做法已足以通过本题，但是这个 $\log y$ 的复杂度看起来很可优化。

容易发现可以用基环树 dp + 树上 $k$ 级祖先算法来算出每个节点到环的距离以及在环上的起点，可以大大优化复杂度。

时间复杂度：$O(p(m+\log y)+q)$。

空间复杂度：$O(p)$。

~~那现在是不是可以加强数据范围了，调到 $q\leq 10^7$。~~

## AC 代码：
赛时写的代码，有点丑请见谅：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int k,m,q,p,a[N],b[N];
int jp[N][24],to[N];
bool vis[N];
struct edge{
    int v,nxt;
}egs[N<<1];
inline int fpm(int x,int y){
    int res=1;
    for(;y;y>>=1,(x*=x)%=p)
        if(y&1)(res*=x)%=p;
    return res;
}
inline int f(int x){
    int res=0;
    for(int i=1; i<=m; ++i)
        (res+=a[i]*fpm(x,b[i]))%=p;
    return res;
}
void dfs(int u){
    if(vis[u])return;
    vis[u]=1;dfs(to[u]);
    jp[u][k]=jp[jp[u][k-1]][k-1];
}
signed main(){
    cin>>m>>q>>p;int x,y;
    for(int i=1; i<=m; ++i)
        cin>>a[i]>>b[i];
    for(int u=0; u<p; ++u)
        jp[u][0]=to[u]=f(u);
    for(k=1; k<=23; ++k){
        memset(vis,0,sizeof vis);
        for(int u=0; u<p; ++u)dfs(u);
    }
    while(q--){
        cin>>x>>y,x%=p;
        for(int i=23;~i;--i)
            if((1<<i)<=y)x=jp[x][i],y-=(1<<i);
        cout<<x<<'\n';
    }
    return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

很好的一道题。真心赞美出题人。

对于这种多次运算且模数很小的题目，很容易就能够想到一个性质：一个数按照如上方式算多次之后，一定会进入一个环。之后不管怎么算都在这个环里转。

所以我们可以想象一下，将每个数 $x(x \in [1, p))$ 都看做编号为 $x$ 的点，每个点向 $f(x) \bmod p$ 连边。这样构成一张图，每个点有且仅有一个出度。换言之，这个图构成一棵基环树森林。

可以通过记搜的方式记录环的位置以及环长。这样可以直接在环上倍增跳。这样的复杂度是优秀的 $O(q \log p)$。

然后我们发现可以不处理环长及其位置，直接暴力倍增跳就行了。尽管复杂度略劣为 $O(q \log y)$，但是代码复杂度及常数都比较小。

```cpp
int f(int x) {
	int ans = 0;
	rep(i, 1, m) (ans += a[i] * qpow(x, b[i]) % p) %= p;
	return ans;
}
signed main() {
	read(m, q, p);
	rep(i, 1, m) read(a[i], b[i]);
	rep(i, 0, p - 1) t[i][0] = f(i);
	rep(j, 1, 25) rep(i, 0, p - 1)
		t[i][j] = t[t[i][j - 1]][j - 1];
	while (q -- ) {
		int x, y; read(x, y);
		x = f(x); y -- ;
		for (int i = 25; i >= 0; i -- ) if (y >= (1ll << i))
			y -= (1 << i), x = t[x][i];
		write('\n', x);
	} return 0;
}
```

---

## 作者：Z_X_D_ (赞：0)

~~Genshin，启动！~~
# 题意简述
给定序列 $a,b$，定义对以一个 $x$ 的操作 $f(x)=\Sigma_{i=1}^{m}{a_ix^{b_i}}$，多次操作时后一次操作的 $x$ 为前一次操作的结果。

$q$ 次询问，每次给定 $y$ 和 $x$，表示询问对于 $x$ 操作 $y$ 次得到的结果。
# 思路
显然地，每次操作的 $a,b$ 是固定的，也就是说对于确定 $x$，单次操作的答案是确定的，因此可以预处理每个 $x$ 对应的答案，每次询问只需要 $O(y)$，这样的总复杂度是 $O(mx\log_{2}b+qy)$ 的（**注意：$0^0=1$ 所以 $0$ 的处理结果不一定为 $0$，因此 $0$ 也需要预处理**）。
## 优化
因为 $x^y\equiv (x\mod{p})^y$，有 $f(x)=f(x\mod{p})$，因此只需要预处理到 $p-1$ 就可以，预处理的复杂度降为 $O(mp\log_{2}b)$。

考虑到每个 $x$ 对于固定 $a,b$ 做若干操作的答案固定，因此考虑用倍增优化查询，
定义 $f_{x,j}$ 表示对于 $i$ 操作 $2^j$ 次得到的结果，易得 $f_{i,j}=f_{f_{i,j-1},j-1}$，这样查询的复杂度降为 $O(q\log_{2}y)$，最终总复杂度为 $O(mp\log_{2}b+(p+q)\log_{2}y)$。
# $Code$
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100010
#define pii pair<int,int>
#define fi first
#define se second
#define otto auto
using namespace std;
namespace dsa
{
	int p,to[N][27],a[25],b[25];
	int qp(int b,int n)
	{
		int ans=1;
		while(n)
		{
			if(n&1)ans=ans*b%p;
			b=b*b%p;
			n>>=1;
		}
		return ans;
	}
	void main()
	{
		int n,q,x,y,i,j;
		scanf("%lld%lld%lld",&n,&q,&p);
		for(i=1;i<=n;i++)
			scanf("%lld%lld",a+i,b+i);
		for(i=0;i<p;i++)
			for(j=1;j<=n;j++)
				to[i][0]=(to[i][0]+a[j]*qp(i,b[j])%p)%p;
		for(i=1;i<=25;i++)
			for(j=0;j<p;j++)
				to[j][i]=to[to[j][i-1]][i-1];
		for(i=1;i<=q;i++)
		{
			scanf("%lld%lld",&x,&y);
			x%=p;
			for(j=25;j>=0;j--)
				if(y>=(1<<j))
				{
					x=to[x][j]%p;
					y-=(1<<j);
				}
			printf("%lld\n",x);
		}
		return;
	}
};
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	dsa::main();
	return 0;
}
```

---

## 作者：AlexandreLea (赞：0)

## 题目大意

设函数

$$f_n(x)=
\begin{cases}
\displaystyle\sum_{k=1}^ma_kx^{b_k}&n=1\\
f_1(f_{n-1}(x))
\end{cases}$$

求 $T$ 个 $f_y(x)\bmod p$ 的值。

## 题目思路

注意到 $p$ 和 $m$ 都很小，并且根据模运算定理（即取模对于加法，减法和乘法运算没有影响），那么我们可以对于所有的 $x\in[0,p)$，求出 $f(x)\bmod p$ 的值，而后调用 $y$ 次已经计算好的结果即可。由于输入输出的范围都在 $[0,p)$ 之内（对 $x$ 模 $p$！），所以这样做没有问题。

不幸的是这样做会 TLE，因为 $y$ 有一点大。因此，我们把 $f_n(x)$ 做二进制分组，设 $g_n(x)=f_{2^n}(x)$，我们只需要根据式子 $g_n(x)=g_{n-1}(g_{n-1}(x))$ 推出 $n\le 25$ 时的所有 $g$ 然后对 $y$ 进行二进制分解后进行类似于树上倍增的做法即可。

代码如下。

```cpp
#include <iostream>
#include <vector>
#define int long long
using namespace std;
const int SIZE=25;
int m,q,p,a[SIZE],b[SIZE];
int genf[(int)1e5+10][25];
int pow(int a,int b,int p){
    int ans=1;
    for(;b;b/=2,a=a*a%p) if(b%2==1) ans=ans*a%p;
    return ans%p;
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>m>>q>>p;
    for(int i=1;i<=m;i++) cin>>a[i]>>b[i];
    for(int i=0;i<p;i++){
        for(int j=1;j<=m;j++)
            genf[i][0]+=(a[j]*pow(i,b[j],p))%p,genf[i][0]%=p;
    }
    for(int ce=1;ce<=23;ce++){
        for(int i=0;i<p;i++){
            genf[i][ce]=genf[genf[i][ce-1]][ce-1];
        }
    }
    while(q--){
        int x,y;
        cin>>x>>y;
        x%=p;
        for(int i=0;i<=25;i++) if(y&(1<<i)) x=genf[x][i];
        cout<<x<<endl;
    }
    return 0;
}
```

**EOF**

---

## 作者：fengziyi (赞：0)

[更好的阅读体验](https://yttriumwillow.github.io/2023/10/29/P9816-%E5%B0%91%E9%A1%B9%E5%BC%8F%E5%A4%8D%E5%90%88%E5%B9%82-%E9%A2%98%E8%A7%A3/)
### 简要题意

称一个项数小于等于 $20$ 的多项式为一个**少项式**。

求一个少项式的 $y$ 次复合函数在 $x$ 点上 $f_{y}(x)\bmod p$ 的值。

### 解题思路

题目强调注意 $m,p$ 的范围，观察发现 $p$ 的范围在 $10^5$ 之内。

关于模运算，它拥有以下显然的性质：

$$
(x + y)\bmod p = (x\bmod p + y\bmod p)
$$

$$
(x \times y)\bmod p = ((x\bmod p)\times (y\bmod p))\bmod p
$$

所以对于一个多项式函数有等式 $f(x) \bmod p = f(x\bmod p)\bmod p$ 存在。不明白的想想你的快速幂为什么对。

$$
f(x)\bmod p = \sum_{i = 1}^{m} a_i x^{b_i} \bmod p = \sum_{i = 1}^{m} (a_i (x\bmod p)^{b_i} \bmod p) \bmod p
$$

如上柿我们可以用 $O(m\log\max\{b\})$ 的时间预处理出所有 $0\le x < p$ 的 $f(x)\bmod p$，$O(1)$ 地快速进行回答。

然后应该初学者都能想到通过 $y$ 次迭代求得 $f_y(x)\bmod p$，关键在于将迭代的复杂度降低。

考虑进行倍增，因为有 $f_{2^k}(x) = f_{2^{k - 1}}(f_{2^{k - 1}}(x))$。

令 $st_{x,k} = f_{2^k}(x)$ 则我们可以通过 $O(\log y)$ 的迭代求得答案。

$$
st_{x,k} = 
\begin{cases}
	f(x)\bmod p & k = 0 \\
	st_{st_{x,k - 1},k - 1} & \mathrm{Otherwise.}\\
\end{cases}
$$

需要注意的是，因为 $y\le 10^7$，因此枚举 $k$ 直到 $2^k > 10^7$。

### 贴个代码

这里令 $f_{x,k} = st_{x,k}$。

```cpp
#define rep(i, l, r) for (int i = (l); i <= (r); ++i)
constexpr int Y = 1e7 + 10;

rep (i, 0, p - 1)
    rep (j, 1, m)
        f[i][0] = (f[i][0] + 1ll * a[j] * fpow(i, b[j]) % p) % p;

for (int j = 1; (1 << j) <= Y; ++j)
    rep (i, 0, p - 1)
        f[i][j] = f[f[i][j - 1]][j - 1];

rep (i, 1, q)
{
    cin >> x >> y; x %= p;
    for (int k = 30; ~k; --k)
        if ((1 << k) & y) x = f[x][k];
    cout << x << endl;
}
```

---

## 作者：KingPowers (赞：0)

注意到以下两个性质：

- $f_i(x)\equiv f_i(x\bmod p)\pmod p$，这里 $i$ 是任意一个非负整数。

- $f_a(f_b(x))=f_{a+b}(x)$，也就是两个嵌套的函数可以合并。

由于询问嵌套的层数比较大，而函数的嵌套又满足上面提到的可合并性，因此考虑倍增：记 $f_{i,x}$ 表示 $f_{2^i}(x)$ 的结果，那么我们有

$$
f_{i,x}\equiv
\begin{cases}
f(x),&i=0 \\
f_{i-1,f_{i-1,x}},&\text{otherwise}
\end{cases}
\pmod p
$$

对于询问，将其在二进制下拆开，用若干个 $f_{i,x}$ 拼起来即可。

时间复杂度 $O(p\log y+q\log y)$，这里 $y$ 就是题目中询问的嵌套层数 $y$。

注意因为 $y$ 最大在 $10^7$ 级别所以倍增要至少预处理到 $2^{23}$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i,a,b) for(int i=(a);i<=(b);i++)
#define Rof(i,a,b) for(int i=(a);i>=(b);i--)
#define fi first
#define se second
#define eb emplace_back
using namespace std;
typedef pair<int,int> pii;
const int N=1e6+5;
int m,q,mod,a[N],b[N],f[24][N];
int qpow(int x,int y){
	int res=1;
	for(;y;x=x*x%mod,y>>=1)
		if(y&1) res=res*x%mod;
	return res;
}
int calc(int x){
	int res=0;
	For(i,1,m) res=(res+a[i]*qpow(x,b[i])%mod)%mod;
	return res;
}
int query(int x,int n){
	int now=x%mod;
	For(i,0,23) if((n>>i)&1)
		now=f[i][now];
	return now;
}
void Main(){
	cin>>m>>q>>mod;
	For(i,1,m) cin>>a[i]>>b[i];
	For(i,0,23) For(j,0,mod-1){
		if(!i) f[i][j]=calc(j);
		else f[i][j]=f[i-1][f[i-1][j]];
	}
	while(q--){
		int x,y;cin>>x>>y;
		cout<<query(x,y)<<'\n';
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int T=1;//cin>>T;
	while(T--) Main();
	return 0;
}
```

---

## 作者：andyli (赞：0)

倍增，预处理每个 $0\le x< p$ 的 $x$ 的 $f_n(x) \bmod p$，其中 $n = 2^k, k \in \mathbf{N}$，查询时枚举位跳即可。  

```cpp
using Z = ArbitraryModInt;
int main() {
    dR(int, m, q, p);
    Z::set_mod(p);
    vi a(m), b(m);
    _for (i, m)
        io.read(a[i], b[i]);
    constexpr int LG = 24; // 2^24 > y_max = 10^7
    int fa[p][LG];
    _for (x, p) {
        Z t;
        _for (i, m)
            t += a[i] * power(Z(x), b[i]);
        fa[x][0] = t.val();
    }
    _for (i, LG - 1)
        _for (x, p)
            fa[x][i + 1] = fa[fa[x][i]][i];
    _for (q) {
        dR(int, x, y), x %= p;
        _for (i, LG)
            if (y >> i & 1)
                x = fa[x][i];
        print(x);
    }
    return 0;
}
```

---

## 作者：_radio_ (赞：0)

# p9816 少项式复合幂题解
## 题意
给定一个函数 $f(x)$ 的内容，对于每次询问，给出 $x$ 在函数中迭代 $y$ 次后的结果。
## 思路
暴力肯定是不行的，我们想到的第一个优化就是快速幂。但有快速幂还不够，关注到模数的范围很小，因此可以利用倍增的方式提前打表，询问时查询即可。
## code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x,y,m,q,p,a[30],b[30],f[100010][30],L[30];
int pow(int x,int y){//快速幂
    int a=1,b=x;
	while(y>0){
		if(y%2==1) a=a*b%p;
		b=b*b%p;
		y>>=1;
	}
	return a;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); 
    cout.tie(0);
    L[0]=1;
    for(int i=1;i<=23;i++) L[i]=L[i-1]<<1;//打表2的次幂
	cin>>m>>q>>p;
    for(int i=1;i<=m;i++) cin>>a[i]>>b[i];
	for(int i=0;i<p;i++)
		for(int j=1;j<=m;j++) f[i][0]=(f[i][0]+a[j]*pow(i,b[j]))%p;//初始打表
    for(int i=1;i<=23;i++)
        for(int j=0;j<p;j++) f[j][i]=f[f[j][i-1]][i-1];//利用倍增的方法打表
    while(q--) {
        cin>>x>>y;
        int ans=0;
        for(int i=1;i<=m;i++) ans=(ans+a[i]*pow(x,b[i]))%p;//初始先算一次，因为x的值不在p的范围内
        y--;
        int now=23;
        while(y){//不断寻找最接近的答案
            if(L[now]<=y){
                ans=f[ans][now];
                y-=L[now];
            }
			now--;
        }
        cout<<ans<<"\n";
    }
    return 0;
}
```


---


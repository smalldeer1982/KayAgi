# [POI 2021/2022 R2] lic

## 题目背景

翻译自 [POI2021~2022R2 Day1T2](https://szkopul.edu.pl/problemset/problem/kQ5ExYNkFhx3K2FvVuXAAbn4/statement/)。

## 题目描述

定义 $a$ 的「不友好数」$b$ 为 $\gcd(a,b)=1$ 的数。

现在你知道了数字 $n$，你需要求出它的「不友好数」升序排序第 $k$ 个开始后的 $c$ 个数。

## 说明/提示

样例解释：

$10$ 的「不友好数」依次为 $1,3,7,9,11,13,17\ldots$。

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------- | :----------- | :----------- |
| $1$ | $n \leq 10^6$ 且 $M \leq n$ | $10$ |
| $2$ | $f(n) \leq 10^6$ 且 $M \leq n$ | $36$ |
| $3$ | $c \leq 100$ | $30$ |
| $4$ | 无特殊限制 | $24$ |

上述 $M$ 为输出的最大值，$f(n)$ 为 $\leq n$ 的「不友好数」数量。

## 样例 #1

### 输入

```
10 3 4```

### 输出

```
7 9 11 13```

# 题解

## 作者：bianshiyang (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P9865)

## 题目简意：

给定正整数 $n$，将所有与 $n$ 互质（包括 $1$）的正整数按照升序排列，并输出第 $k∼k+c-1$ 个正整数。

## 分析：

首先我们要知道那些数字是和 $n$ 不互质的，那么筛去这些数，剩下的就是满足条件的。首先 $n$ 的因子（$1$ 除外）和 $n$ 都是不互质的，并且当一个数是 $n$ 的因子的倍数时，它和 $n$ 也不互质。那么我们可以找到 $n$ 的所有质因子，然后把这些质因子的所有倍数筛去，剩下的就是我们要找的。

接下来考虑筛法，我们可以用 $O(\sqrt{n})$ 的复杂度找到 $n$ 的所有质因子。但是接下来扩张倍数就是个问题，因为直接  $O(n)$  扩张会超时，假设第 $k$ 位的数字为 $x$，那么考虑能不能算出来 $1∼x$ 之间有多少个要筛去的，记做 $res$，那么用 $x-res$ 就是所求得到结果。我们会发现如果 $n$ 只有一个因子，那么 $x-res$，而当因子大于 $1$ 时，肯定会筛重复的，考虑容斥原理。

记 $n$ 的因子为 $p_{1}$，$p_{3}\cdots p_{m}$，现在抽象出几个集合，每个集合的元素个数就是 $\lfloor \frac{x}{p_{1}}\rfloor$，$\lfloor \frac{x}{p_{2}}\rfloor\cdots\lfloor \frac{x}{p_{m}}\rfloor$，那么我们要求的是这几个集合的并集的元素个数，根据容斥原理：

$|A_{1}\cup A_{2} \cup \cdots\cup A_{m}|$

$=\displaystyle\sum_{1\le i\le m}|A_{i}|-\displaystyle\sum_{1\le i< j\le m}|A_{i}\cap A_{j}|+\displaystyle\sum_{1\le i< j< k\le m}|A_{i}\cap A_{j}\cap A_{k}|$

$-\cdots +(-1)^{m-1}|A_{1}\cap A_{2}\cap\cdots\cap A_{m}|$

此时，我们已经解决了当第 $k$ 位的数字为 $x$，筛去的个数为 $res$，但是这里 $x$ 是未知的，我们考虑 $x$ 与 $k$ 之间的关系：

$res=\displaystyle\sum_{1\le i\le m}\lfloor \frac{x}{p_{i}}\rfloor\displaystyle\sum_{1\le i< j\le m}\lfloor \frac{x}{p_{i}\cdot p_{j}}\rfloor+\displaystyle\sum_{1\le i< j< k\le m}\lfloor \frac{x}{p_{i}\cdot p_{j}\cdot p_{k}}\rfloor$

$-\cdots +(-1)^{m-1}\lfloor \frac{x}{p_{i}\cdot p_{j}\cdots p_{m}}\rfloor$

$x-res=k$

考虑构造函数 $f(x)=x-res-k$，容易证明这个函数是单调不减的，那么可以用二分法来确定 $x$，但由于单调不减，所以最后二分出来的两个端点 $l$ 和 $r$ 都有可能，只需要在判断一下就好了。

现在知道了第 $k$ 位上的数 $x$ 是多少，那么怎么求 $k∼k+c-1$ 上的每个数是多少呢。这里有两种办法：

1. 是对于每个点都进行二分，得到结果 $i$，这只适合每个 $i$ 比较稀疏的分布。

2. 从第 $k$ 位的 $x$ 开始往后找，每次一个数 $i$ 判断 $\gcd(i,n)$ 是否等于 $1$，是的话输出，输出 $c$ 位后结束循环，适合每个 $i$ 比较稠密的分布。

事实证明，此题解法 $2$ 能通过，以下是评测记录：

[解法1](https://www.luogu.com.cn/record/138440701)

[解法2](https://www.luogu.com.cn/record/138439889)

## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long//记得开long long
using namespace std;
int n,k,c,l,r,meici;
int a[1111],cnt;//a数组存储质因子
bool pd;

void dfs(int x,int y,int dep,int ceshi)//递归求解容斥，x表示循环到第几层，y表示上一轮第几个质数参与运算，dep表示每一项的分母是多少，ceshi表示分子是多少
{
	if(x==0)
	{
		meici+=ceshi/dep;
		return;
	}
	for(int i=y+1;i<=cnt;i++)
	{
		dfs(x-1,i,dep*a[i],ceshi);
	}
}

int judge(int x)//求解res
{
	int res=0;
	for(int i=1;i<=cnt;i++)
	{
		meici=0;
		dfs(i,0,1,x);
		if(i&1) res+=meici;
		else res-=meici;
	}
	res=x-res;
	res-=k;
	return res;
}

bool pdd(int x)//判断是否合法
{
	for(int i=1;i<=cnt;i++) 
	{
		if(x%a[i]==0)
		{
			return false;
		}
	}
	return true;
}

int work(int x)//朴素二分
{
	l=1;
	r=1e18;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		int op=judge(mid);
		if(op>=0) r=mid-1;
		else l=mid+1;
	}
	if(pdd(l)&&judge(l)>=0) return l;//判断取l还是r
	else return r;
}

int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}

signed main()
{
	scanf("%lld%lld%lld",&n,&k,&c);
	int nn=n;
	for(int i=2;i*i<=n;i++)//拆质数
	{
		if(n%i==0)
		{
			a[++cnt]=i;
			while(n%i==0) n/=i;
		}
	}
	if(n>1) a[++cnt]=n;
	int st=work(k);
	for(int i=st;;i++)
	{
		if(gcd(i,nn)==1)
		{
			printf("%lld ",i);
			c--;
		}
		if(c<=0) break;
	}
	return 0;
}
```



---

## 作者：UserJCY (赞：1)

[P9865 [POI2021~2022R2] lic](https://www.luogu.com.cn/problem/P9865)

# 前置知识

## 欧拉函数

[欧拉函数——OI-wiki](https://oi-wiki.org/math/number-theory/euler-totient/)

欧拉函数（Euler's totient function），即 $\varphi(n)$，表示的是小于等于 $n$ 和 $n$ 互质的数的个数。——OI-wiki

即 $\varphi(n)=\sum_{i=1}^{n} [gcd(i,n)=1]$

求法：

设 $n$ 有 $k$ 个质因数，分别为 $p_1,p_2,\dots ,p_k$

则$\varphi(n)=n \Pi_{i=1}^{k} (1-\frac{1}{p_i})$

```cpp
int phi(int x){
	int ret=x;
	for(int i=2;i*i<=x;i++){
		if(x%i==0)(ret/=i)*=i-1;
		while(x%i==0)x/=i;
	}
	if(x!=1)(ret/=x)*=x-1;
	return ret;
}
```

## 容斥

[容斥原理——OI-wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)

这里就自己理解，不多讲了。

# 本题

先求出 $d=\varphi(n)$ ，得到 $lft=\lfloor\frac{k}{d}\rfloor$，即最终答案要加上 $sum=lft\times n$。

再求出余数 $rst=k-lft$，用二分求 $n$ 的第 $rst$ 个与其互质的数。

在二分的 `check(x)` 中，枚举所有的 $n$ 的质因数，减去它们的倍数个数，但是会重算。例如在统计 $2$ 的倍数是会将 $6$ 删去一遍，在计算 $3$ 时又会算一遍。所以我们要利用容斥原理去重，这里用 dfs 实现：

```cpp
void dfs(int pos,int x,int dep,int c,int &t){
	if(pos==0){
		t+=c/dep;
		return;
	}
	for(int i=x+1;i<=cnt;i++){
		dfs(pos-1,i,dep*prime[i],c,t);
	}
}
```

最后通过二分求出第 $k$ 个数（也就是起始数）后，暴力往后遍历 $c$ 个数，判断是否与 $n$ 互质，加上 $sum$，就是答案。

## 完整代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,c;
int prime[100010];
int cnt;
int gcd(int a,int b){
	return !b?a:gcd(b,a%b);
}
int phi(int x){
	int ret=x;
	for(int i=2;i*i<=x;i++){
		if(x%i==0)(ret/=i)*=i-1,prime[++cnt]=i;
		while(x%i==0)x/=i;
	}
	if(x!=1)(ret/=x)*=x-1,prime[++cnt]=x;
	return ret;
} 
void dfs(int pos,int x,int dep,int c,int &t){
	if(pos==0){
		t+=c/dep;
		return;
	}
	for(int i=x+1;i<=cnt;i++){
		dfs(pos-1,i,dep*prime[i],c,t);
	}
}
bool check(int x,int ma){
	int ret=0;
	for(int i=1;i<=cnt;i++){
		int t=0;
		dfs(i,0,1,x,t);
		if(i&1)ret+=t;
		else ret-=t;
	}
	ret=x-ret;
	return ret>=ma;
}
signed main(){
	cin>>n>>k>>c;
	int d=phi(n);
	int lft=k/d,rst=k%d;
	if(rst==0)lft--,rst=d;
	int ans=lft*n;
	int lmt=sqrt(n);
	int l=0,r=n,mid;
	while(l<r){
		mid=(l+r)>>1;
		if(check(mid,rst)){
			r=mid;
		}
		else{
			l=mid+1;
		}
	}
	for(int i=1;i<=c;i++,r++){
		while(gcd(r,n)!=1)r++;
		cout<<ans+r<<' ';
	}
	return 0;
}
```

---

## 作者：100Accepted (赞：1)

容斥不用都说。

二分查找第 $k$ 个与 $n$ 互质的数，用$O(\sqrt{n})$的复杂度找到 $n$ 的所有质因子，问题就转化为求第 $k$ 个不是这些质因子中任意一个倍数的数，可以用容斥求解，接下来可以继续二分查找，或遍历枚举，作者使用枚举。

```cpp
#include<cstdio>
using namespace std;
long long n,k,l,r,mid,nn,sum,js,i;
long long c,z[62],cnt=0;
bool ld(long long a){
	for(i=1;i<=cnt;i++){
		if(a%z[i]==0)return 0;
	}
	return 1;
}
void dfs(long long x,long long y,long long fz){
	if(x==0){
		sum+=mid/fz;
		return;
	}
	for(long long k=y+1;k<=cnt;k++){
		dfs(x-1,k,fz*z[k]);
	}
}
int main(){
	scanf("%lld%lld%lld",&n,&k,&c);
	if(k==1&&c==1){
		printf("1");
		return 0;
	}
	nn=n;
	for(i=2;i*i<=n;i++){
		if(n%i==0){
			z[++cnt]=i;
			while(n%i==0){
				n/=i;
			}
		}
	}
	if(n!=1)z[++cnt]=n;
	l=1;r=1e18;
	while(l<r){
		mid=(l+r)>>1;
		n=0;
		for(i=1;i<=cnt;i++){
			sum=0;
			dfs(i,0,1);
			if(i&1==1)n+=sum;
			else n-=sum;
		}
		if(mid-n<k)l=mid+1;
		else r=mid;
	}
	if(mid-n==k)l=mid;
	r=0;
	while(r<c){
		if(ld(l)==1){
			printf("%lld ",l);
			r++;
		}
		l++;
	}
	return 0;
}

```

---

## 作者：mango2011 (赞：1)

一眼看过去，好像得到答案的第一个数，接下来暴力枚举就可以 AC 了。所以，这道题的难点就在于如何得到这第一个数。其实不难，我们要看出这道题所谓的“单调性”，所以，考虑二分答案，每次二分第一个数，然后就到了一个关键的问题：check 函数怎么写，换句话说，这个值的大小如何判断？

这个时候，我们就要重新开始理性分析了：把问题转化成：求在 $[1,k]$（$k$ 是二分的答案）中有多少个数满足 $p$ 满足 $(n,p)=1$。

这个问题比较复杂，我们可以考虑有多少个数不满足条件，因此答案用容斥原理根据 $n$ 的每个质因子来计算（这一步就不证明了，有兴趣的可以去往上搜一搜）。然后，我们用 $k$ 减去这个值就是答案。

实现细节：最终一定要特判左端点是否符合要求，不符合要求才返回右端点。

~~代码就不放了~~

```c
#include<bits/stdc++.h>
using namespace std;
long long b[51],p,temp,res;
void init(long long n)
{
	long long i,t=n;
	for(i=2;i*i<=t;i++)
	{
		if(n%i==0)
		{
			p++;
			b[p]=i;
		}
		while(n%i==0)
		{
			n/=i;
		}
	}
	if(n>1)
	{
		p++;
		b[p]=n;
	}
}
void dfs(long long n,long long dq,long long v,long long id)
{
	if(p-id+1<temp-dq)
	{
		return;
	}
	if(dq==temp)
	{
		if(temp&1)
		{
			res+=n/v;
		}
		else
		{
			res-=n/v;
		}
		return;
	}
	dfs(n,dq+1,v*b[id],id+1);
	dfs(n,dq,v,id+1);
}
void check1(long long n)
{
	res=0;
	for(temp=1;temp<=p;temp++)
	{
		dfs(n,0,1,1);
	}
	res=n-res;
}
bool check2(long long data)
{
	int i;
	for(i=1;i<=p;i++)
	{
		if(data%b[i]==0)
		{
			return false;
		}
	}
	return true;
}
long long ef(long long n,long long num)
{
	init(n);
	long long l=0,r=1e18,mid;
	while(l+1<r)
	{
		mid=(l+r)>>1;
		check1(mid);
		//printf("%lld\n",res);
		if(res>num)
		{
			r=mid;
		}
		else
		{
			if(res==num)
			{
				r=mid;
			}
			else
			{
				l=mid;
			}
		}
		//cout<<l<<' '<<r<<' '<<mid<<endl;
	}
	check1(l);
	//cout<<l<<endl;
	if(res>=num&&check2(l))
	{
		return l;
	}
	return r;
}
int main()
{
	long long n,k,f,c=0,i,l;
	cin>>n>>k>>f;
	l=ef(n,k);
	//cout<<l<<endl;
	for(i=l;;i++)
	{
		//cout<<i<<endl;
		if(__gcd(n,i)==1LL)
		{
			c++;
			printf("%lld ",i);
			if(c>=f)
			{
				break;
			}
		}
	}
	printf("\n");
	return 0;
}
```

写得比较~~干净~~长，但是跑得飞快。

血泪史：
------------

第一发：忘记用 $k$ 减去得到的值了，WA 了 $100$ 个点，AC 了 $1$ 个点（样例），并且算质数写错了。

第二发到第三发：用 $k$ 减去值，WA 了 $32$ 个点，AC 了 $69$ 个点（有 $1$ 个是样例）。

最后几发：修改了算质数的部分，AC 了 $101$ 个点（其中 $1$ 个是样例），WA 了 $0$ 个点。

总结：更惨的是，本题在 AC 之前，每个 Subtask 都浅浅的 WA 几个，所以一直得到了 $0$ 分，要是这是 CSP 考试，那么就会得到 $0$ 分的好成绩。~~^_^~~

---


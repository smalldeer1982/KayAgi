# [COCI 2023/2024 #1] AN2DL

## 题目描述

当在 21 号楼下转悠的时候，你遇到了一面完全被数字覆盖的墙，这些数字被排成一个 $n$ 行 $m$ 列的表格。然后你发现了有一个可以框柱 $r$ 行 $s$ 列的框靠在墙边，并且在框的旁边你发现了一支铅笔和一张纸，纸上有一个空白的表格。

你因为纸上的表格是空的而感到难过，所以你决定使用这个框来填充这个表格。

你把框靠在墙上，使第 $i$ 行第 $j$ 列的数字位于左上角，相框的边框与墙的边缘平行。考虑到相框内的数字，而且你喜欢大数，你决定把其中最大的数写在纸上表格的第 $i$ 行第 $j$ 列。

你对框在墙壁上的每一个可能位置（使框完全位于墙壁上，且框内正好有 $r \times s$ 个数字）重复上述过程，并确保相框边缘与墙壁边缘平行。

在你结束之后，纸上的表格甚至比墙壁还要漂亮。在纸上的表格中的数字是什么呢？

## 说明/提示

### 【样例解释#1】

只有一个 $3\times 3$ 的子矩阵，且是整个矩阵，它的元素最大值是 $4$。

### 【样例解释#2】

矩阵和它的每个 $2\times 1$ 的子矩阵如下图所示，其中标红的数为最大值：

![](https://cdn.luogu.com.cn/upload/image_hosting/89liqsac.png)

### 【数据范围】

对于 $100\%$ 的数据，$1\leq n,m\leq 4000$，$\lvert A_{i,j}\rvert\leq 10000$，$1\leq r\leq n$，$1\leq s\leq m$。

**本题采用捆绑测试。**

| 子任务 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n,m\leq 40$，$r=n$，$s=m$ | $12$ |
| $2$ | $n,m\leq 40$ | $17$ |
| $3$ | $n,m\leq 1000$ | $25$ |
| $4$ | 无特殊性质 | $56$ |

### 【说明】

本题分值按 COCI 原题设置，满分 $110$。

题目译自 [COCI2022-2023](https://hsin.hr/coci/) [CONTEST #1](https://hsin.hr/coci/contest1_tasks.pdf) _**T3 AN2DL**_。

## 样例 #1

### 输入

```
3 3
1 1 2
2 3 4
4 3 2
3 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3 3
1 1 2
2 3 4
4 3 2
2 1```

### 输出

```
2 3 4
4 3 4```

## 样例 #3

### 输入

```
5 5
-1 -3 -4 -2 4
-8 -7 -9 -10 11
5 2 -8 -2 1
13 -3 -2 -6 -9
11 6 2 7 4
2 3```

### 输出

```
-1 -2 11
5 2 11
13 2 1
13 7 7```

# 题解

## 作者：Little_x_starTYJ (赞：9)

### 解题思路
这道题目我们一看，咦？怎么有点像[滑动窗口](https://www.luogu.com.cn/problem/P1886)呢？于是就想到了单调队列。

我们定义一个单调队列，对于每一个数，我们判断队头的数字是否小于等于当前数，如果是，那么当前数一定更优，因为他不仅可以在队列里多待一会且贡献大于等于队头，所以我们循环弹出队头，直到队头大于当前数，然后入队清除过时的元素即可。

由于是二维的，所以需要跑两遍。

CODE：
```cpp
#include <stdio.h>
#include <string.h>
int a[4001][4001], ans[4001][4001], b[4001][4001], q[2];
inline int read() {
	int f = 1, k = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		k = k * 10 + c - '0';
		c = getchar();
	}
	return f * k;
}
inline void write(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
	return;
}
int main() {
	int n = read(), m = read();
	int i, j;
	for (i = 1; i <= n; i++)
		for (j = 1; j <= m; j++)
			a[i][j] = read();
	int r = read(), s = read();
	int k = n - r + 1, k2 = m - s + 1;
	for (i = 1; i <= n; i++) {
		int hh = 0, tt = -1;
		for (j = 1; j <= m; j++) {
			while (hh <= tt && a[i][q[tt]] <= a[i][j])
				tt--;
			q[++tt] = j;
			while (hh <= tt && q[hh] <= j - s)
				hh++;
			if (j >= s)
				b[i][j - s + 1] = a[i][q[hh]];
		}
		memset(q, 0, sizeof(q));
	}
	for (j = 1; j <= k2; j++) {
		int hh = 0, tt = -1;
		for (i = 1; i <= n; i++) {
			while (hh <= tt && b[q[tt]][j] <= b[i][j])
				tt--;
			q[++tt] = i;
			while (hh <= tt && q[hh] <= i - r)
				hh++;
			if (i >= r)
				ans[i - r + 1][j] = b[q[hh]][j];
		}
		memset(q, 0, sizeof(q));
	}
	for (i = 1; i <= k; i++, puts(""))
		for (j = 1; j <= k2; j++)
			write(ans[i][j]), putchar(' ');
	return 0;
}
```

---

## 作者：_zuoqingyuan (赞：5)

太抱歉了，一篇题解竟然让管理员审核了四遍。

# 前言
其实就是 [P2216 [HAOI2007] 理想的正方形](https://www.luogu.com.cn/problem/P2216)这道题。但我个人感觉稍难，做 P2216 时用的是二维 st 表，但因为这题略有不同，就用的是单调队列。
# 题面
[传送门](https://www.luogu.com.cn/problem/P9905)

给定 $n,m,r,s$ 和一个 $n×m$ 的整数矩阵 $A$，求它每个 $r×s$ 的子矩阵的元素最大值。

其中 $1 \le n,m \le 3000$，$\left\vert A_{i,j}\right\vert \le10000$，$1\le r\le n$，$1\le s\le m$。

# 思路
暴力算法很好写，就是枚举每一个右端点，再遍历求最大值，枚举的时间复杂度为 $n^2$，遍历的复杂度也是 $n^2$，所以暴力算法的时间复杂度为 $O(n^4)$，当 $n=3000$ 时，暴力算法显然无法通过。思考特殊做法。

我们会发现，这题和[滑动窗口](https://www.luogu.com.cn/problem/P1886)很像，只不过是把问题拓展到了一个二维矩阵中，那我们是否可以向这道题一样，用一个 $r\times s$ 的“滑动窗口”来求解呢？

其实是可行的，只是要分步解决，跑两趟单调队列。

### 步骤一:
对这个 $n\times m$ 的矩阵的每一行，都跑一趟单调队列，使其变为一个 $n \times (m-s+1)$ 大小的矩阵 $B$，其中 $B_{i,j}=\max\limits_{j\leq y\leq j+s-1}A_{i,y}$。

### 步骤二：
对矩阵 $B$ 的每一列，再跑一趟单调队列，使其变为一个 $(n-r+1)\times (m-s+1)$ 的矩阵 $C$，其中 $C_{i,j}=\max\limits_{i\leq x\leq i+r-1}B_{x,j}$。

因为 $C_{i,j}=\max\limits_{i\leq x\leq i+r-1}B_{x,j}=\max\limits_{i\leq x\leq i+r-1,j\leq y\leq j+s-1}A_{x,y}$，所以矩阵 $C$ 即为所求。

如果不懂可以看下面的例子（样例 $3$）：

矩阵 $A$：
```latex
-1 -3 -4 -2 4
-8 -7 -9 -10 11
5 2 -8 -2 1
13 -3 -2 -6 -9
11 6 2 7 4
```
矩阵 $B$：
```latex
-1 -2 4
-7 -7 11
5 2 1
13 -2 -2
11 7 7
```
矩阵 $C$：
```latex
-1 -2 11
5 2 11
13 2 1
13 7 7
```
这道题有个小坑点，虽然说 $1 \le n$，$m \le 3000$，但数组只开 $3000$ 会 RE，要开到 $4000$ 才行。至于原因，~~蒟蒻我也不知道为什么~~。

# Code
码风不好，勿抄
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
int a[4005][4005],n,m,r,s;
vector<int>v1[4005],v2[4005];
deque<int>q;
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
    scanf("%d %d",&r,&s);
    for(int i=1;i<=n;i++){
        v1[i].push_back(0);
        for(int j=1;j<=m;j++){
            while(q.size()&&q.front()<=j-s)q.pop_front();
            while(q.size()&&a[i][q.back()]<a[i][j])q.pop_back();
            q.push_back(j);
            if(j>=s)v1[i].push_back(a[i][q.front()]);
        }
        q.clear();
    }
    m=m-s+1;
    for(int i=1;i<=m;i++){
        v2[i].push_back(0);
        for(int j=1;j<=n;j++){
            while(q.size()&&q.front()<=j-r)q.pop_front();
            while(q.size()&&v1[q.back()][i]<v1[j][i])q.pop_back();
            q.push_back(j);
            if(j>=r)v2[i].push_back(v1[q.front()][i]);
        }
        q.clear();
    }
    n=n-r+1;
    for(int i=l;i<=n;i++){
        for(int j=l;j<=m;j++)printf("%d ",v2[j][i]);
        printf("\n");
    }
    return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/140522583)。

如有错误，请指出。

---

## 作者：Cute__yhb (赞：2)

## 思路
单调队列。

首先，对于每个点 $a_{i,j}$，求出这个点往**后** $s$ 个点的最大值，存到另一个数组 $b$ 中，$b$ 数组有 $n$ 行 $m-s+1$ 列。

接着，先枚举列坐标，再从 $b$ 数组上计算出这个点所在的那一列往**后** $r$ 个点的最大值，存到数组 $c$ 中，$c$ 数组就是我们的答案数组。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[4005][4005],ans[4005][4005],r,s,b[4005][4005];
int main(){
	//输入
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	cin>>r>>s;
	//第一遍单调队列
	for(int i=1;i<=n;i++){
		deque<int>q;
		for(int j=1;j<=m;j++){
			while(!q.empty()&&a[i][q.back()]<=a[i][j]){
				q.pop_back();
			}
			q.push_back(j);
			while(!q.empty()&&q.front()<=j-s){
				q.pop_front();
			}
			if(j>=s) b[i][j-s+1]=a[i][q.front()];
		}
	}
   //第二遍
	for(int j=1;j<=m-s+1;j++){//反着枚举行和列
		deque<int>q;
		for(int i=1;i<=n;i++){
			while(!q.empty()&&b[q.back()][j]<=b[i][j]){
				q.pop_back();
			}
			q.push_back(i);
			while(!q.empty()&&q.front()<=i-r){
				q.pop_front();
			}
			if(i>=r) ans[i-r+1][j]=b[q.front()][j];
		}
	}
   //输出,n-r+1行,m-s+1列
	for(int i=1;i<=n-r+1;i++){
		for(int j=1;j<=m-s+1;j++){
			cout<<ans[i][j]<<' ';
		}
		cout<<endl;
	}
    return 0;
}
```


---

## 作者：f_hxr_ (赞：1)

[传送门](https://www.luogu.com.cn/problem/P9905)

[双倍经验](https://www.luogu.com.cn/problem/P2216)

[三倍经验](https://www.luogu.com.cn/problem/CF846D)

看见矩阵上的滑动窗口，很容易想到[一维序列上的滑动窗口问题](https://www.luogu.com.cn/problem/P1886)。

怎么把一维的单调队列放到二维的矩阵上呢？

首先，对每一行开个长为 $s$ 的滑动窗口，这样我们就得到了每一行的每个滑动窗口的最大值。

然后将每 $r$ 个窗口拼在一起，就是一个 $r \times s$ 的窗口了。

怎么将窗口拼在一起？同样可以用单调队列。将最大值单独拎出来，再做一遍滑动窗口就行了。

不会滑动窗口出门左转[膜版区](https://www.luogu.com.cn/problem/P1886)或[ NOI Online](https://www.noi.cn/pxsp/2020-09-22/717311.shtml)。

下面是 [AC](https://www.luogu.com.cn/record/148624386) 代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=4003;
int N,M,R,S;
int a[maxn][maxn],ans[maxn][maxn],fo[maxn];
struct dp{
	int dat[maxn<<1],head=1,tail=0;
	bool empty(){return head>tail;}
	void push_back(int xx){dat[++tail]=xx;}
	void pop_front(){++head;}
	void pop_back(){--tail;}
	void clear(){head=1;tail=0;}
	int front(){return dat[head];}
	int back(){return dat[tail];}
}q[maxn],q3;
int get(int inx,int xx){//横向滑动窗口:长度:S 
	int ret=-1;
	while(!q[inx].empty()&&q[inx].front()<xx-S+1)q[inx].pop_front();
	while(!q[inx].empty()&&a[inx][q[inx].back()]<=a[inx][xx])q[inx].pop_back();
	q[inx].push_back(xx);
	if(xx>=S)ret=q[inx].front();
	return ret;
}
int main(){
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;i++)for(int j=1;j<=M;j++)scanf("%d",&a[i][j]);
	scanf("%d%d",&R,&S);
	for(int i=1;i<=M;i++){//从前往后推进 
		q3.clear();fo[0]=0;
		for(int j=1;j<=N;j++){//枚举每一行:处理最大值将其单独拿出来
			int p=get(j,i);
			if(p==-1){fo[0]=1;continue;}
			fo[j]=a[j][p];
		}
		if(fo[0])continue;//列数不到S列
		//合并
		for(int j=1;j<=N;j++){
			while(!q3.empty()&&q3.front()<j-R+1)q3.pop_front();
			while(!q3.empty()&&fo[q3.back()]<=fo[j])q3.pop_back();
			q3.push_back(j);
			if(j<R)continue;//行数没满R行
			ans[j-R+1][i-S+1]=fo[q3.front()];
		}	
	}
	for(int i=1;i<=N-R+1;i++,putchar('\n'))
		for(int j=1;j<=M-S+1;j++)
			printf("%d ",ans[i][j]);
	return 0;
}
```

---

## 作者：kkxacj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9905)

#### 思路

由于每次重新求最大值肯定很麻烦，不难发现每次都会算重很多，所以可以考虑用双堆，每次删掉一部分，新加入一部分，每次的答案就是栈顶最大值。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,r,s,a[4010][4010],l,ans[4010][4010],c[4010][4010];
priority_queue<int>q,q1,q2; 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			scanf("%d",&a[i][j]);
	scanf("%d%d",&r,&s);
	for(int i = 1;i <= m;i++)
	{
		for(int j = 1;j <= n;j++)//小优化，之后每次只用加入一部分值
		{
			q.push(a[j][i]);
			while(!q.empty() && !q1.empty() && q.top() == q1.top()) q.pop(),q1.pop();
			if(j >= r) c[j - r + 1][i] = q.top(),q1.push(a[j - r + 1][i]);
		}
		while(!q.empty()) q.pop();
		while(!q1.empty()) q1.pop();
	}
	for(int i = 1;i <= s;i++) q.push(c[1][i]);
	q2 = q;
	ans[1][1] = q2.top();
	for(int i = r;i <= n;i++)
	{
		for(int j = s + 1;j <= m;j++)
		{
			q.push(c[i - r + 1][j]);
			q1.push(c[i - r + 1][j - s]);
			while(!q.empty() && !q1.empty() && q.top() == q1.top()) q.pop(),q1.pop();
			ans[i - r + 1][j - s + 1] = q.top();
		}
		while(!q2.empty()) q2.pop();
		while(!q1.empty()) q1.pop();
		for(int j = 1;j <= s;j++) q2.push(c[i - r + 2][j]);
		ans[i + 2 - r][1] = q2.top();
		q = q2;
	}
	for(int i = 1;i <= n - r + 1;i++,puts(""))
		for(int j = 1;j <= m - s + 1;j++)
			printf("%d ",ans[i][j]);
	return 0;
}

```

---

## 作者：STARSczy (赞：1)

第一眼，一个数是可以且只能影响以当前点为右下角的 $r \times s$ 的区间的，所以当一个数超出这个区间，就要消去，使用滑动窗口即可。但是，这样不好保存信息，所以可以使用类似高维前缀和的方法即可，先横着做一遍，再竖着做一遍。

说一句，这道题数据比较水，不然输出量太大了，AC 代码用超级快读快吐都要T飞，没有办法的事情。所以只要时间复杂度是 $(n-r)^2\times (m-c)^2$ 都可以过。

```cpp
#include<bits/stdc++.h>
//#define int long long
#define rep(i,l,r) for(int i=(l),i##end=(r);i<=i##end;++i)
#define per(i,r,l) for(int i=(r),i##end=(l);i>=i##end;--i)
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int maxn=4e3+10,maxm=2e4+10,mod=1e9+7;

int n,m,h,w,l,r,ans[maxn][maxn],a[maxn][maxn],d[maxn][maxn];
pii wd[maxm];
vector<pii> id[maxm];

signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	rep(i,1,n) rep(j,1,m) cin>>a[i][j],id[a[i][j]+=1e4].push_back({i,j});
	cin>>h>>w;
	rep(i,0,2e4) for(pii a:id[i]) d[a.fi][a.se]=i-1e4;
	rep(i,1,n){
		l=1,r=0;
		per(j,m,1){
			if(l<=r&&wd[l].se>=j+w) ++l;
			while(l<=r&&wd[r].fi<d[i][j]) --r;
			wd[++r]={d[i][j],j},ans[i][j]=wd[l].first;
		}
	}
	rep(j,1,m){
		l=1,r=0;
		per(i,n,1){
			if(l<=r&&wd[l].se>=i+h) ++l;
			while(l<=r&&wd[r].fi<ans[i][j]) --r;
			wd[++r]={ans[i][j],i},ans[i][j]=max(ans[i][j],wd[l].first);
		}
	}
	rep(i,1,n-h+1){
		rep(j,1,m-w+1) cout<<ans[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：Mu_leaf (赞：0)

## [思路]

考虑到 $r,s$ 固定，所以可以尝试上线段树维护。

首先建 $n$ 颗线段树，维护第 $i$ 行的最大值。

再建 $m-s+1$ 颗线段树，维护第 $i$ 行到 $i+r-1$ 行的最大值。可以吧第 $k$ 颗线段树上的节点看做代表了第 $k$ 列上第 $i \sim i+r-1$ 这段区间的最大值;

然后就做完了，具体细节可以看代码。

## CODE:

```cpp
#include <bits/stdc++.h>
#define ls (x<<1)
#define rs (x<<1|1)
#define mid ((l+r)>>1)
#define inf 10000
#define int short
using namespace std;
inline int read(){
	int f=1,x=0;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x*f;
}
void write(int x){
	if(x<0)x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
const int N=5005;
int tr[N][N<<2],a[N][N];
int Mx[N][N<<2]; 
int n,m,h,w;
inline void pushup(int rt,int x){
	tr[rt][x]=max(tr[rt][ls],tr[rt][rs]);
}
void build(int rt,int x,int l,int r){
	if(l==r){
		tr[rt][x]=a[rt][l];
		return;
	}
	build(rt,ls,l,mid);
	build(rt,rs,mid+1,r);
	pushup(rt,x);
}
int Max(int rt,int x,int l,int r,int lp,int rp){
	if(l>=lp && r<=rp){
		return tr[rt][x];
	}
	int ans=-inf;
	if(lp<=mid) ans=max(ans,Max(rt,ls,l,mid,lp,rp));
	if(rp> mid) ans=max(ans,Max(rt,rs,mid+1,r,lp,rp));
	return ans;
}
void build1(int rt,int x,int l,int r){
	if(l==r){
		Mx[rt][x]=Max(l,1,1,m,rt,rt+w-1);
		return;
	}
	build1(rt,ls,l,mid);
	build1(rt,rs,mid+1,r);
	Mx[rt][x]=max(Mx[rt][ls],Mx[rt][rs]);
}
int Max1(int rt,int x,int l,int r,int lp,int rp){
	if(l>=lp && r<=rp){
		return Mx[rt][x];
	}
	int ans=-inf;
	if(lp<=mid) ans=max(ans,Max1(rt,ls,l,mid,lp,rp));
	if(rp> mid) ans=max(ans,Max1(rt,rs,mid+1,r,lp,rp));
	return ans;
}

signed main(){
//	freopen("submatrix.in","r",stdin);
//	freopen("submatrix.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) a[i][j]=read();
	}
	h=read(),w=read();
	for(int i=1;i<=n;i++) build(i,1,1,m);
	for(int i=1;i<=m-w+1;i++){
		build1(i,1,1,n);
	}
	for(int i=1;i<=n-h+1;i++,puts("")){
		for(int j=1;j<=m-w+1;j++){
			write(Max1(j,1,1,n,i,i+h-1));
			putchar(' ');
		}
	}
	
	return 0;
}
/*
20,236,502,250,000

*/
```

---

## 作者：U•ェ•*U (赞：0)

[我的 CSDN 原文地址（转载请标明）](https://blog.csdn.net/LZXLSMLTZLLM/article/details/136431688)
## 思路
首先考虑暴力算法，枚举每一个右端点，再遍历求最大值，枚举的时间复杂度为 $O(n^2)$，遍历复杂度同样 $O(n^2)$。显然，在 $n=3000$ 时无法通过，考虑更优解法。

~~大眼观察~~，发现这道题和[ P1886 滑动窗口 /【模板】单调队列 ](https://www.luogu.com.cn/problem/P1886)是几乎一样的；也就是把一维单调队列变成了二维的单调队列。

当然，也可以理解成多个窗口在二维矩阵上面滑动；也就是一个 $r\times s$ 的滑动窗口。

分析发现，这种算法是可以通过的，我们不妨分步解决，跑两次单调队列就可以完美解决问题！

### 操作流程：
对 $n\times m$ 的矩阵每行都跑一次单调队列。

跑完后可以发现形成了一个 $n\times (m-s+1)$ 的矩阵 $A$，根据题意，不难发现，$A_{i,j}= \max\limits_{j\le y \le (j+s-1)}^{}\times C_{i,y}$（设 $C$ 为题目输入的矩阵）

对 $A$ 矩阵每列都跑一次单调队列（这样就形成了一个二维的单调队列结果）。

跑完后可以发现形成了一个 $(n-r+1)\times (m-s+1)$ 的矩阵 $B$，根据题意，不难发现，$B_{i,j}= \max\limits_{i\le x \le (i+r-1)}^{}\times A_{x,y}$

此时的 $B$ 矩阵就是所期望的啦！

## 代码：
**在 `_zuoqingyuan` 的代码基础上优化了码风，并增加了细节注释。**
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[4005][4005], n, m, r, s; // a表示原始矩阵，n和m表示矩阵的行列数，r和s表示滑动窗口的大小。
vector <int> v1[4005], v2[4005]; // v1和v2用来存储中间结果和最终结果。
deque <int> q; // 双端队列用来维护滑动窗口。

int main() {
	ios :: sync_with_stdio(false); // 禁用cin和cout的同步，提高I/O效率。
	cin >> n >> m; // 输入矩阵的行和列。
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++) cin >> a[i][j]; // 输入矩阵元素。
	cin >> r >> s; // 输入滑动窗口的大小。
	
	for (int i = 1; i <= n; i ++) {
		v1[i].push_back(0); // 初始化v1的每一行。
		for (int j = 1; j <= m; j ++) {
			while (q.size() && q.front() <= j - s) q.pop_front(); // 若队列头部的元素已不在窗口内，弹出。
			while (q.size() && a[i][q.back()] < a[i][j]) q.pop_back(); // 若当前元素大于队尾元素，弹出队尾，维持队列单调递减。
			q.push_back(j); // 将当前列加入队列。
			if (j >= s) v1[i].push_back(a[i][q.front()]); // 若已到窗口大小，加入v1中。
		}
		q.clear(); // 清空队列为下一行做准备。
	}
	m = m - s + 1; // 更新列的有效长度。
	
	for (int i = 1; i <= m; i ++) {
		v2[i].push_back(0); // 初始化v2的每一列。
		for (int j = 1; j <= n; j ++) {
			while (q.size() && q.front() <= j - r) q.pop_front(); // 类似上面的操作，但是这次是行。
			while (q.size() && v1[q.back()][i] < v1[j][i]) q.pop_back(); // 维持队列单调递减。
			q.push_back(j); // 将当前行加入队列。
			if (j >= r) v2[i].push_back(v1[q.front()][i]); // 若已到窗口大小，加入v2中。
		}
		q.clear(); // 清空队列为下一列做准备。
	}
	n = n - r + 1; // 更新行的有效长度。
	
	// 输出最终结果。
	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= m; j ++) cout << v2[j][i] << endl;
		cout << endl;
	}
	return 0;
}
```

---

## 作者：xxboyxx (赞：0)

**温馨提示：本题解会使用算法单调队列，若未学过请学习[模版](https://www.luogu.com.cn/problem/P1886)，此处不讲。**

普通单调队列可以求出一个序列中相同长度窗口中的最值，但是此题是一个矩阵，所以需要二维单调队列。

## 一、暴力算法

### 思路

对于每一个子矩阵，暴力算出其内的元素最大值。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int r,s;
int a[4005][4005];
int b[4005][4005];
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>r>>s;
	for (int i=1;i<=n-r+1;i++)
	{
		for (int j=1;j<=m-s+1;j++)
		{
			int maxx=-1e9;
			for (int k=i;k<=i+r-1;k++)
				for (int l=j;l<=j+s-1;l++)
					if (a[k][l]>maxx)
						maxx=a[k][l];
			b[i][j]=maxx;
		}
	}
	for (int i=1;i<=n-r+1;i++)
	{
		for (int j=1;j<=m-s+1;j++)
			cout<<b[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

### 得分

时间复杂度 $O(nmrs)$，预估 $29$ 分。

## 二、一维单调队列

### 思路

对于每一行，进行单调队列，再暴力枚举行。

![](https://cdn.luogu.com.cn/upload/image_hosting/r8pmcteo.png)

如上是第三个样例，如果要求左上角的那个矩阵的最大值，就是黑色区域最大值与红色区域的最大值，而每一行是可以进行单调队列快速求解的。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,r,s;
int a[4005][4005];
int b[4005][4005];
int c[4005][4005];
deque<int> q;
signed main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>r>>s;
	for (int i=1;i<=n;i++)
	{
		while (!q.empty())
			q.pop_back();
		for (int j=1;j<=m;j++)
		{
			while (!q.empty() && j-q.front()>=s)
				q.pop_front();
			while (!q.empty() && a[i][q.back()]<a[i][j])
				q.pop_back();
			q.push_back(j);
			b[i][j]=a[i][q.front()];
		}
	}
	for (int i=1;i<=n-r+1;i++)
	{
		for (int j=1;j<=m-s+1;j++)
		{
			int maxx=-1e9;
			for (int k=i;k<=i+r-1;k++)
				if (b[k][j+s-1]>maxx)
					maxx=b[k][j+s-1];
			c[i][j]=maxx;
		}
	}
	for (int i=1;i<=n-r+1;i++)
	{
		for (int j=1;j<=m-s+1;j++)
			cout<<c[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

### 得分

时间复杂度 $O(nmr)$，预估 $54$ 分。

## 三、二维单调队列

### 思路

在一维单调队列的基础上进行改进，在一维单调队列中，要计算每一个子矩阵的最大值，需要把 $r$ 行的单调队列全部都计算最大值，既然也是最大值，不如把之前的使用一维单调队列得到的矩阵再进行一次单调队列求最大值，这样就可以通过了。

### 注意

第一次单调队列是每一行进行一次的，而第二次单点队列是每一列进行一次。同时要注意因为子矩阵是 $r \times s$ 的，所以答案数组是 $(n-r+1) \times (m-s+1)$ 的。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,r,s;
int a[4005][4005];
int b[4005][4005];
int c[4005][4005];
deque<int> q;
signed main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>r>>s;
	for (int i=1;i<=n;i++)//第一次单调队列 
	{//使用原数组进行单调队列 
		while (!q.empty())
			q.pop_back();
		for (int j=1;j<=m;j++)
		{
			while (!q.empty() && j-q.front()>=s)
				q.pop_front();
			while (!q.empty() && a[i][q.back()]<a[i][j])
				q.pop_back();
			q.push_back(j);
			b[i][j]=a[i][q.front()];//得到b数组 
		}
	}
	for (int i=s;i<=m;i++)//第二次单调队列 
	{//使用b数组进行单调队列 
		while (!q.empty())
			q.pop_back();
		for (int j=1;j<=n;j++)
		{
			while (!q.empty() && j-q.front()>=r)
				q.pop_front();
			while (!q.empty() && b[q.back()][i]<b[j][i])
				q.pop_back();
			q.push_back(j);
			c[j][i]=b[q.front()][i];//得到答案数组 
		}
	}
	for (int i=r;i<=n;i++)
	{
		for (int j=s;j<=m;j++)
			cout<<c[i][j]<<' ';
		cout<<'\n';
	}
	return 0;
}
```

### 得分

时间复杂度 $O(nm)$，预估 $110$ 分。

## 多倍经验

[P2216 [HAOI2007] 理想的正方形](https://www.luogu.com.cn/problem/P2216)

---

## 作者：Oracynx (赞：0)

## P9905 [COCI 2023/2024 #1] AN2DL 题解

### 思路分析

考虑优先队列。

由于本题的 $n, m \le 4000$，所以我们先横着跑一遍优先队列。我们便获得了每一行中的每一个 $i$ 到 $i + s - 1$ 中的最大值。

此时，我们在**上一次求出的横向最大值**竖着跑一边优先队列，我们就获得二维矩阵的最大值，如果不是很理解可以看下图。

第一个优先队列：

![](https://cdn.luogu.com.cn/upload/image_hosting/lrassb3l.png)

优先队列的值保存在 A 列上，则我们在 A 列跑优先队列个踹而求出二维最大值。

### 代码实现

```cpp
#include <algorithm>
#include <cstdio>
#include <queue>
#define int short
constexpr int MaxN = 4e3 + 5;
int n, m;
int r, s;
int p[MaxN][MaxN];
int line[MaxN][MaxN];
int answer[MaxN][MaxN];
std::priority_queue<std::pair<int, int>> queue;
signed main()
{
    scanf("%hd%hd", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            scanf("%hd", &p[i][j]);
        }
    }
    scanf("%hd%hd", &r, &s);
    for (int i = 1; i <= n; i++)
    {
        for (; !queue.empty();)
        {
            queue.pop();
        }
        for (int j = 1; j <= s - 1; j++)
        {
            queue.push({p[i][j], j});
        }
        for (int j = 1; j <= m - s + 1; j++)
        {
            queue.push({p[i][j + s - 1], j + s - 1});
            for (; queue.top().second < j;)
            {
                queue.pop();
            }
            line[i][j] = queue.top().first;
        }
    }
    for (int j = 1; j <= m + s - 1; j++)
    {
        for (; !queue.empty();)
        {
            queue.pop();
        }
        for (int i = 1; i <= r - 1; i++)
        {
            queue.push({line[i][j], i});
        }
        for (int i = 1; i <= n - r + 1; i++)
        {
            queue.push({line[i + r - 1][j], i + r - 1});
            for (; queue.top().second < i;)
            {
                queue.pop();
            }
            answer[i][j] = queue.top().first;
        }
    }
    for (int i = 1; i <= n - r + 1; i++)
    {
        for (int j = 1; j <= m - s + 1; j++)
        {
            printf("%hd ", answer[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

提示：本代码常熟过大，大部分时间过不去，如有需有可以加上[我的快读](https://www.luogu.com.cn/paste/m60rpro7)，可以通过此题。

---


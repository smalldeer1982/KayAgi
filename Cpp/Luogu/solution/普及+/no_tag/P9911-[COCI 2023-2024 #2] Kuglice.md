# [COCI 2023/2024 #2] Kuglice

## 题目描述

一个双端队列里面有 $n$ 个球，每个球有一个颜色。A 和 B 玩一个游戏：

A 先手，两个人轮流操作，每次从队列的最左端或者最右端拿出一个球，如果这种颜色的球是第一次被拿出，拿出它的人获得 $1$ 分。所有球都拿完后游戏结束。

假设 A 和 B 都以最优策略操作，请求出最终得分是多少。

## 说明/提示

### 数据范围
|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$17$|$a_i\le 2$|
|$2$|$10$|$n\le 20$|
|$3$|$26$|$a_i\le 20$|
|$4$|$15$|$n\le 300$|
|$5$|$42$|无|

对于所有数据，$1\le n\le 3000$，$1\le a_i\le n$。

## 样例 #1

### 输入

```
5
1 1 2 1 1```

### 输出

```
1:1```

## 样例 #2

### 输入

```
6
1 2 3 1 2 3```

### 输出

```
2:1```

# 题解

## 作者：zjpwwc (赞：7)

# P9911 Kuglice 题解


## 前言：

1. 第一次写题解，有写的不好的地方可以私信我指出，谢谢。

2. 题目难度估计在 **绿**。

---

## 题目大意：

题意很好懂，看两个人谁第一次拿走某种颜色的球，输出比分。

---

## 题目思路：

我们可以把这个双端队列看作一个 **长度为 $n$ 的区间**，这个大区间可以划分成很多个 **小区间**。

---

#### 首先：编号为 $a_i$ 的球在哪段区间拿会得到一分？

注：题目说了两端都能拿球。

其实很简单，我们假定一个区间 $[l,r]$，如果编号为 $a_i$ 的球第一次出现在 $2$ 号位，最后一次出现在 $10$ 号位，区间为 $[4,7]$，那么这个球早在 $4$ 号位的前面或者 $7$ 号位的后面拿过了。原因是区间最左边和最右边的外面就有 **想要的球** 了。

如果区间 $[l,r]$ 不能把编号为 $a_i$ 的球 **第一次出现的位置** 和 **最后一次出现的位置** 囊括。那么这一段区间一定不能得分。

这一步，我们只需要记录每种球 **第一次出现的位置** 和 **最后一次出现的位置**，判断区间 $[l,r]$ 是否囊括球的位置即可。

---

#### 其次：怎样拿球双方都最优？

使用记忆化和 DP。

$dp_{l,r}$ 表示在区间 $[l,r]$ 内 **自己得到的加分**。

什么叫加分？

如果 $k$ 种球的话，双方加起来就是 $k$ 分。

你在队列里拿球比对手会多的分数就是加分（**加分可能是负数**）。

小学数学告诉我们，总分为 $k$，你比对手多 $a$，你的分数就是 $\large \frac{k + a}{2}$。

现在，我们知道，球数是 $k$，加分为 $dp_{1,n}$。

所以，我们求 $\large \frac{k + dp_{1,n}}{2}$ 就行了。

现在我们来看如何求 DP。

DP 思路很简单，**从左边拿和从右边** 拿哪样贡献大，求 $\max$ 再转移就行。 

这时有人会说一个大状态就有两个小状态, $n$ 最大 $1000$，这样跑搜索数时间复杂度大概是 $4^n$ 级别,会爆。

确实，但我们可以用记忆化来优化，一开始赋一个极小的初值，如果跑搜索数跑到这里发现 **初始值没有更新**，说明这条路不能给我们带来贡献，从而返回上一级。

#### 状态转移方程归纳

```
dp[l][r] = max(check(l, r, k[l]) - del(l+1, r), check(l, r, k[r]) - del(l, r-1)));
```

`check()` 就是检查第一步的合法性，如果合法就返回 $1$，分数  $+1$，如果不合法就返回 $0$，分数不变。

`del()` 就是递归函数，计算 $dp_{l,r}$ 的。

有些地方可能你没看懂，这里给上参考代码帮助你理解，代码也有注释。

---

## 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int len=3e3+10;
int INF=1<<31;
int n,cnt,a,b;
int k[len],lid[len],rid[len],dp[len][len];
int check(int l,int r,int k){
	return lid[k]>=l&&rid[k]<=r;//检查区间合法性
}
int del(int l,int r){
	if(l>r) return 0;
	if(dp[l][r]==INF) dp[l][r]=max(check(l,r,k[l])-del(l+1,r),check(l,r,k[r])-del(l,r-1));
	return dp[l][r];
}//带剪枝的递归
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>k[i];
		if(!lid[k[i]]){
			cnt++;//球的种类数
			lid[k[i]]=i;//第一次出现的位置
		}
		rid[k[i]]=i;//最后一次
	}
	fill(dp[0],dp[0]+len*len,INF);//初始化极小值
	del(1,n);//开始递归
	a=(cnt+dp[1][n])/2;
	b=cnt-a;
	printf("%d:%d",a,b);//计算比分
	return 0;
}
``````
* * *
## 总结：

一道不错的思维题，做法也很灵活，有不懂可以私信我，谢谢大家。




---

## 作者：dongrunxuan (赞：3)

# 洛谷 P9911 题解

## 前言

建议评蓝，~~这样我就能水蓝题了~~。

## 思路

### 先讲算法结论 dfs 记忆化搜索

首先考虑朴素 dfs 算法：每一个小球对每个人来说有拿与不拿两种选择，搜索时对每种选择做深一步 dfs，预计时间复杂度 $2^n$。

#### 如何进行优化呢？

观察数据范围，发现只有 $n^2$ 的复杂度能够通过。再仔细思索，我们可以将序列分为多个小区间，记录每种球第一次出现的位置和最后一次出现的位置，再枚举每一个区间是否能够满足包括两个位置的条件，就可以使用动态规划算法解决。

#### 为什么是 dfs 记忆化搜索呢？

~~由于我是个蒟蒻，想不到状态转移方程，于是只能靠记忆化搜索来代替动态规划。~~ 因为在使用记忆化搜索时，可以让两个人使用一个函数，这样可以满足双方都拿到最优方式。最坏时间复杂度为填满记忆数组的时间消耗，可以通过本题。

## 代码（码风较丑勿喷）

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=3005;
int n,sum;
int a[maxn],lid[maxn],rid[maxn];
int dp[maxn][maxn];
bool check(int l,int r,int k)
{
	return l<=lid[k]&&rid[k]<=r;//区间是否能够满足包括两个位置
}
int dfs(int l,int r)//记忆化搜索
{
	if(l>r)
	{
		return 0;
	}
	if(dp[l][r]==-maxn)
	{
		dp[l][r]=max(check(l,r,a[r])-dfs(l,r-1),check(l,r,a[l])-dfs(l+1,r));
	}
	return dp[l][r];
}
int main()
{
	fill(dp[0],dp[0]+maxn*maxn,-maxn);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(!lid[a[i]])
		{
			sum++;
			lid[a[i]]=i;//第一次出现的位置
		}
		rid[a[i]]=i;//最后一次出现的位置
	}
	int a=(sum+dfs(1,n))/2;
	int b=sum-a;
	cout<<a<<":"<<b;
	return 0;	
}
```
有问题私信我哦。



---

## 作者：tiantianyang (赞：2)

[ 题目传送门](https://www.luogu.com.cn/problem/P9911)
### 题目大意
有一个双端队列，你可以在队列头尾拿一个数，如果这个数是第一次拿出来就加一分，最后比分数多少（题意还是很好理解的）。
### 思路
**首先分析大致复杂度**

看数据范围 $n=3000$ 这样的话 $O(n^{2})$ 的复杂度就可以跑过。

**接着找最优策略**

很明显总分是一定的，那么我的得分每一次高，最后一定高。

**然后算法分析**

我们把这一个队列看成一个从 $l\sim r$ 的区间，我们每一次取的时候可以让这个区间变成 $l+1\sim r$ 或者是 $l\sim r-1$ 那么我们只需要查看一下这两个区间哪一个更优就选哪一个，相信到这里大家可以看出这就是个记搜。

**最后具体实现**

我们想当总分为 $k$ 然后我比对手高 $h$ 分时 **（这个 $h$ 可能为负）**，我的分数是多少？肯定就是 $\frac{k+a}{2}$ 这不就出来了吗！

把这个代入到这道题中我们先记录一下有 $k$ 种不同的数字，以及当前我比对手大的分数 $dp_{1,n}$ 这样易得出的 $\frac{k+dp_{1,n}}{2}$ 是我分数，紧接着就是如何求 $dp$ 呢？

这个 $dp$ 的思路其实就是我前面说的在两个区间之中取最大值，但是直接搜索会超时，优化就是我们在这个 $dp$ 之中如果已经有数了，就不用接着搜下去直接返回这里面的值。

**方程转移式最后就是：**

```dp[l][r]=max(win(l,r,a[l])-dfs(l+1,r),win(l,r,a[r])-dfs(l,r-1));```

### 代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e3+5;
int n,much,maxa;
int a[N],head[N],tail[N],tong[N],dp[N][N];
int win(int l,int r,int val){//判断这个数是否是第一次出现，是的话返回一否则是零 
	if(head[val]>=l&&tail[val]<=r) return 1;
	else return 0;
}
int dfs(int l,int r){//记搜找最优方案 
	if(l==r) return win(l,r,a[l]); //如果区间只剩一个数，那么直接看这个数满不满足 
	if(dp[l][r]!=-1) return dp[l][r];//如果已有记录，就直接返回 
	dp[l][r]=max(-dfs(l+1,r)+win(l,r,a[l]),-dfs(l,r-1)+win(l,r,a[r]));//状态转移 
	return dp[l][r];
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];//读入 
	for(int i=1;i<=n;i++){//从前向后看每一个数，第一次出现的位置 
		if(!tong[a[i]]) head[a[i]]=i;
		tong[a[i]]=1;
	}
	memset(tong,0,sizeof(tong));
	for(int i=n;i>=1;i--){//从后向前看每一个数，第一次出现的位置 
		if(!tong[a[i]]) tail[a[i]]=i,much++;
		tong[a[i]]=1;
	}
	memset(dp,-1,sizeof(dp));//先给出初值 
	maxa=dfs(1,n);
	cout<<(much+maxa)/2<<":"<<(much-maxa)/2;//算出我的和对方的分数 
	return 0;
}//完美收官 
```

---

## 作者：huhangqi (赞：2)

由于两个人都会选择最优方案，因此可以考虑使用动态规划来模拟进行选择。

我们可以记录第一个人的得分，然后通过总得分减去第一人得分得到第二人得分。

首先我们考虑处理出每次取出什么位置会得到分数。

由于是从左右两边取出，因此可以得分的情况只能够是这一种球的最左端或者最右端。

我们可以先离散化再处理。

之后可以选择动态规划或者选择记忆化搜索。

我这边选择记忆化搜索，因为比较好思考。

记录左右两端取到哪里了，然后再记录是哪个人行动。

由于记录第一个人的值，因此第一个人行动时选择最优情况，并记录是否有得分，第二个人只需要求这次行动可以给第一个人造成最小收益即可。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[3005],L[3005],R[3005],dp[3005][3005],tmp[3005],cnt;
bool vis[3005][3005];
int dfs(int l,int r,bool f){
	if(l>r)return 0;
	if(vis[l][r])return dp[l][r];
	vis[l][r]=1;
	int &res=dp[l][r];
	if(f){
		res=0;
		if(l+1==L[a[l+1]]&&r>R[a[l+1]])res=max(res,dfs(l+1,r,0)+1);
		else res=max(res,dfs(l+1,r,0));
		if(r-1==R[a[r-1]]&&l<L[a[r-1]])res=max(res,dfs(l,r-1,0)+1);
		else res=max(res,dfs(l,r-1,0));
	}
	else {
		res=min(dfs(l+1,r,1),dfs(l,r-1,1));
	}
	return res;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		tmp[++cnt]=a[i];
	}
	sort(tmp+1,tmp+cnt+1);
	cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(tmp+1,tmp+cnt+1,a[i])-tmp;
		if(!L[a[i]])L[a[i]]=i;
		R[a[i]]=i;
	}
	int tmp=dfs(0,n+1,1);
	cout<<tmp<<':'<<cnt-tmp;
	return 0;
}
``````

---

## 作者：Oracynx (赞：2)

## P9911 [COCI 2023/2024 #2] Kuglice 题解

### 思路分析

一道典型的博弈论题目，我们设 $f_{l, r} = {x, y}$，$x$ 为先手的得分，$y$ 为后手的得分，每次转移时交换两个即可。

然后我们就可以优 （bào） 化 （lì） 地写出记忆化搜索了，因为总的复杂度只有 $O(n^2)$。

### 代码实现

非常简单明了的代码。

```cpp
#include <algorithm>
#include <cstdio>
constexpr int MaxN = 3e3 + 5;
int n;
int p[MaxN];
bool vis[MaxN];
std::pair<int, int> m[MaxN][MaxN];
std::pair<int, int> dfs(int l, int r)
{
    if (m[l][r] != std::make_pair(-1, -1))
    {
        return m[l][r];
    }
    if (l == r)
    {
        if (!vis[p[l]])
        {
            m[l][r] = {1, 0};
            return {1, 0};
        }
        else
        {
            m[l][r] = {0, 0};
            return {0, 0};
        }
    }
    std::pair<int, int> left, right;
    if (!vis[p[l]])
    {
        vis[p[l]] = true;
        left = dfs(l + 1, r);
        vis[p[l]] = false;
    }
    else
    {
        left = dfs(l + 1, r);
    }
    std::swap(left.first, left.second);
    left.first += (!vis[p[l]] ? 1 : 0);
    if (!vis[p[r]])
    {
        vis[p[r]] = true;
        right = dfs(l, r - 1);
        vis[p[r]] = false;
    }
    else
    {
        right = dfs(l, r - 1);
    }
    std::swap(right.first, right.second);
    right.first += (!vis[p[r]] ? 1 : 0);
    if (left.first - left.second > right.first - right.second)
    {

        m[l][r] = left;
        return left;
    }
    else
    {
        m[l][r] = right;
        return right;
    }
}
int main()
{
    scanf("%d", &n);
    int max_color = 0;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &p[i]);
        max_color = p[i] > max_color ? p[i] : max_color;
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            m[i][j] = {-1, -1};
        }
    }
    auto res = dfs(1, n);
    printf("%d:%d\n", res.first, res.second);
    return 0;
}
```

---

## 作者：内拉组里 (赞：1)

一道区间 dp 板题。

# Thoughts :

> 这里的**最优策略**直接决策很难推，但是所谓**最优策略**，一定满足当前决策比其他的决策更优。
>
> 所以考虑倒着做。
>
> 对于这题而言创造价值的条件是**这种颜色的球是第一次被拿出**，
>
> 所以用两个数组 $ fst $ 和 $ lst $ 分别记录每种颜色在最左端和最右端出现的位置，
>
> 同时应记录球的颜色种类数，因为题中 $ a + b $ 就是颜色种类数，这样只要求出其中一个デス～
>
> 方便起见，考虑求 $ a $，因为 $ A $ 先手。
>
> 记 $ dp[l][r] $ 表示将 $ [l,r] $ 的球轮流取完 $ A $ 所能获得的最大得分。
>
> 显而易见地，当 $ n $ 为奇数并且某一种颜色的球只有一个，即 $ fst_i = lst_i \neq 0 $ 时，$ dp[i][i] = 1 $，否则 $ dp[i][i] = 0 $。
>
> 然后正常的区间 dp デス～
>
> ***
>
> 关于判断某一个球是否系度第一次出现，这里提供一种思路：
>
> 事实上，我们只需要判断是否有 $ [fst_i,lst_i] \in [l,r] $ デス～
>
> 证明略。

# Analyses :

> 总时间复杂度 $ \Theta (N^2) $ 
>
> 总空间复杂度 $ \Theta (N^2) $ 

# Code :

```cpp
/* reference : @SYZOJ.donny */
#include	<iostream>
using namespace std;
constexpr int maxn = 3e3+4;

int n, kind;
int a[maxn];
int fst[maxn];			/* where it appear for the first time */
int lst[maxn];			/* where it appear for the last time */
int dp[maxn][maxn];

inline int first (int l, int r, int knd)
{
	return l <= fst[knd] && lst[knd] <= r;
}

signed main (void)
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) if (!fst[a[i]])
	{
		fst[a[i]] = i;
		kind++;
	}
	for (int i = n; i; i--) if (!lst[a[i]]) lst[a[i]] = i;
	
	if (n & 1) for (int i = 1; i <= n; i++) if (lst[i] == fst[i]) dp[fst[i]][lst[i]] = 1;
	for (int len = 2; len <= n; len++)
	{
		for (int l = 1; l + len - 1 <= n; l++)
		{
			int r = l + len - 1;
			if ((len ^ n) & 1) dp[l][r] = min (dp[l + 1][r], dp[l][r - 1]);									/* second turn */
			else dp[l][r] = max (dp[l + 1][r] + first (l, r, a[l]), dp[l][r - 1] + first (l, r, a[r]));		/* first turn */
		}
	}
	printf ("%lld:%lld\n", dp[1][n], kind - dp[1][n]);
	return 0;
}
```

---

## 作者：ClearluvXL (赞：1)

# Kuglice
## 思路
很显然，一个颜色的贡献一定会归属于两个人中的其中一个。也就是说，两个人的得分是固定的，为礼物中不同颜色的数量。

那么，只考虑一个人的选择方式。另外一个人的得分为总分减去这个人的得分。

什么意思呢？我们现在只用考虑第一次先手的那个人 $a$ 的所有步骤。

初始的操作区间为 $[1,n]$。那么此时先手可以选择 $1$，也可以选择 $n$。那么此时，本来该下一个人操作，我们直接跳过下一个人的操作。那么这个人下一次操作的区间分下面两种情况。
* 如果选择 $1$：
	* 可能是 $[3,n]$，即另外一个人也选择左端点。
	* 可能是 $[2,n-1]$，即另外一个人选择了右端点。
	* 因为每个人都会走最优的策略，而一个区间内的总分是固定的，所以，$b$ 这个人的最优策略相当于是让 $a$ 在 $[2,n]$ 内获得最少的贡献。
	* 那么此时就会应该选择 $val_{l}=\min(solve(3,n),solve(2,n-1))$。
*   如果选择 $n$：
	* 可能是 $[2,n-1]$，即另外一个人选择了左端点。
	* 可能是 $[1,n-2]$，即另外一个人选择了右端点。
	* 因为每个人都会走最优的策略，而一个区间内的总分是固定的，所以，$b$ 这个人的最优策略相当于是让 $a$ 在 $[2,n]$ 内获得最少的贡献。
	* 那么此时就会应该选择 $val_{r}=\min(solve(2,n-1),solve(1,n-2))$。

根据最优性，$a$ 的第一步会选择令自己得分最大的操作，也就是 $\max(val_{1}+val_{l},val_{n}+val_{r})$。

怎么计算 $val$ ？假设现在的操作区间为 $[l,r]$，那么 $[1,l-1],[r+1,n]$ 都是被选择了的。如果当前选择的端点的颜色已经被选择过了，贡献为 $0$，否则贡献为 $1$。

至于统计颜色，可以用 bitset 把左右区间当成一个二进制数判断。

最后为了避免超时，用个记忆化搜索即可。
## 代码
```c++
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N=3005;

typedef long long ll;
typedef pair<int,int> pii;

const int INF=0x3f3f3f3f;

int n;
int a[N],sum;
bool col[N];

bitset<N> g[N][3];

void pre(){
	for(int i=1;i<=n;i++) g[i][0]|=g[i-1][0];
	for(int i=n;i;i--) g[i][1]|=g[i+1][1];
}//end

bool sg[N][N];
int f[N][N];

int dfs(int l,int r){
	if(l>r) return 0;
	if(sg[l][r]) return f[l][r];
	sg[l][r]=1;
	
	int l1=1*(!g[l-1][0][a[l]]&&!g[r+1][1][a[l]]);
	l1+=min(dfs(l+2,r),dfs(l+1,r-1));
	
	int r1=1*(!g[l-1][0][a[r]]&&!g[r+1][1][a[r]]);
	r1+=min(dfs(l+1,r-1),dfs(l,r-2));
	
	f[l][r]=max(l1,r1);
	return f[l][r];
}//end

int main(){

	freopen("kuglice.in","r",stdin);
	freopen("kuglice.out","w",stdout);
	
	ios::sync_with_stdio(0);
	
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(!col[a[i]]) sum++;
		col[a[i]]=1;
		g[i][0][a[i]]=1;
		g[i][1][a[i]]=1;
	}
	
	pre();
	
	int ans=dfs(1,n);
	
	cout<<ans<<":"<<sum-ans<<endl;
	
	return 0; 
}//end
```

---

## 作者：ZBH_123 (赞：1)

## 题目分析

一道很简单的区间 DP。

看到可以从左右两端取球，立刻就可以想到区间 DP。设 $f_{i,j}$ 表示取完区间 $[i,j]$ 内的球，先手比后手多出来的分数。设 $cnt$ 为 $[1,n]$ 内能得到的总分，那么先手能得到的总分就是 $\frac{cnt+f_{1,n}}2$。

接下来来看状态转移。因为只能从左右两端取球，所以 $f_{i,j}$ 就一定与 $f_{i+1,j}$ 和 $f_{i,j-1}$ 有关。另外，在本题中，只有第一次拿到一种颜色的球才会加分，因此我们应该判断编号为 $i$ 和 $j$ 的球的颜色是否在区间外出现过。这个判断很好处理，设 $l_{k}$ 表示颜色 $k$ 首次出现的位置，$r_{k}$ 表示颜色 $k$ 最后一次出现的位置，那么只要满足 $l_{a_i} \ge i$ 且 $r_{a_i} \le j$，第 $i$ 个球的颜色就一定只在区间内出现过。接下来，假设先手取走了 $i$ 号球，那么对于区间 $[i+1,j]$，先手就变成了原来的后手，所以应该用取走 $i$ 号球的得分减去 $f_{i+1,j}$；先手取走了 $j$ 号球同理。这样，我们就得到了如下状态转移方程：

$$f_{i,j}=\max{(\operatorname{calc}(i,j,a_i)-f_{i+1,j},\operatorname{calc}(i,j,a_j)-f_{i,j-1})}$$

其中，$\operatorname{calc}(i,j,k)$ 表示计算在 $[i,j]$ 内取走颜色为 $k$ 的球的得分。

综上所述，这样做的时间复杂度为 $\Theta(n^2)$，可以通过本题。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int n,a[3005],dp[3005][3005],L[3005],R[3005];
bool vis[3005];

bool check(int l,int r,int x){
	return L[x]>=l&&R[x]<=r;
}

int main(){
	int tot=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(!vis[a[i]]){
			tot++,vis[a[i]]=true,L[a[i]]=i;
		}
		R[a[i]]=i;
	}
	
	for(int len=1;len<=n;len++){
		for(int l=1;l+len-1<=n;l++){
			int r=l+len-1;
			dp[l][r]=max(check(l,r,a[l])-dp[l+1][r],check(l,r,a[r])-dp[l][r-1]);
		}
	}
	
	int sc=(tot+dp[1][n])/2;
	printf("%d:%d",sc,tot-sc);
	return 0;
}
```

---

## 作者：djh0314 (赞：1)

[**传送门**](https://www.luogu.com.cn/problem/P9911)。


## 分析

首先，观察数据范围：$1\le n\le 3000$，也就是说，时间复杂度应当在 $O(n^2)$ 左右。

其次，观察我们取球的顺序，是只能从左或右取，因此，我们每次留下的必然是连续的一段。

所以，我们显然可以采用区间 DP 来解决这道题。

确定状态：$f_{i,j}$ 表示现在取了剩下 $i\sim j$，先手的最大得分。

考虑转移：由于我们是先后手易手的取数，所以我们当前的状态是从小 $1$ 的区间的对立面转移过来，这里有两种方式，一种是直接记录对立面，另一种，我们可以记录区间能够取到的价值的总和，显然这个是和取法无关的。

~~~cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
const int N = 3e3+5;
inline int read() {
	int x;
	scanf("%d",&x);
	return x;
}
int n, m,a[N],qzh[N][N],tot[N][N],fr[N],en[N],f[N][N];
inline int val(int L,int R,int x) {
	if(x) return L<=fr[a[R]]&&(en[a[R]]==R);
	else  return (fr[a[L]]==L)&&en[a[L]]<=R;
}
signed main() {
	n=read();
	memset(fr,0x3f,sizeof fr);
	for(int i=1; i<=n; ++i) a[i]=read(),fr[a[i]]=min(fr[a[i]],i),en[a[i]]=i;
	for(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) qzh[i][j]=qzh[i-1][j]+(a[i]==j);
	for(int i=1; i<=n; ++i) if(fr[i]<=en[i]) tot[fr[i]][en[i]]++;
	for(int i=2; i<=n; ++i) {
		for(int j=1; j+i-1<=n; ++j) {
			int L=j,R=j+i-1;
			tot[L][R]=tot[L][R]+tot[L+1][R]+tot[L][R-1]-tot[L+1][R-1];
		}
	}
	for(int i=1; i<=n; ++i) {
		for(int j=1; j+i-1<=n; ++j) {
			int L=j,R=i+j-1;
			f[L][R]=max(val(L,R,0)+tot[L+1][R]-f[L+1][R],tot[L][R-1]-f[L][R-1]+val(L,R,1));
		}
	}
	cout<<f[1][n]<<":"<<tot[1][n]-f[1][n];
	return 0;
}
~~~

---

## 作者：Autream (赞：0)

#### 题意简述
一个长度为 $n$ 的序列中有 $n$ 个球，每个球有一个颜色。现在 `A` 和 `B` 轮流从两端取球，如果取的球的颜色之前没有取过就得一分，输出最终比分。

---
#### 题目分析
因为这个序列是不断缩小的，且两端都可以删除，所以可以看成一个区间，考虑使用区间 DP。

如何设状态？

既然是区间 DP，那么状态肯定是 $dp_{l,r}$，表示当前取的人比另外一个多得的分数。设颜色总数为 $s$，那么这个人的得分就是 $\frac{s+dp_1,n}{2}$。

如何转移？

观察数据范围 $1 \leq n \leq 3000$，可以支持 $O(n^2)$ 的算法，考虑记忆化搜索。我们暴力地去枚举当前这个人是从前面取还是从后面取，对求出来的值取最大值即可。如果 `B` 比 `A` 多 $k$ 分，`A` 就比 `B` 多 $-k$分，那么如果 `A` 取的这个球可以得分，那么 `A` 就比 `B` 多 $-k+1$ 分；反之亦然。

如何判断这个球是否可以得分？

用数组记录每种颜色的球的第一次出现的位置 $idl,idr$（从左到右和从右到左），设当前取的球的区间在 $[l,r]$，如果 $idl_{a_l} \leq [l,r] \leq idr_{a_r}$ 那么就得不到分，因为之前已经取过了；反之亦然。

设当前的得分为 $k \in [0,1]$，状态转移方程：

$$
dp_{l,r}=\max(k-dp_{l+1,r},k-dp_{l,r-1})
$$

最后的答案是 $\frac{s+dp_{1,n}}{2} : \frac{s-dp_{1,n}}{2}$。

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=3005;
int n,sum,cnt1,cnt2,a[N],idxl[N],idxr[N],dp[N][N];
int dfs(int l,int r){
    if(l>r){
        return 0;
    }
    if(dp[l][r]==-1){
        dp[l][r]=std::max((l<=idxl[a[l]]&&r>=idxr[a[l]])-dfs(l+1,r),(l<=idxl[a[r]]&&r>=idxr[a[r]])-dfs(l,r-1));
    }
    return dp[l][r];
}
signed main() {
    mem(dp,-1);
    std::cin>>n;
    arrin(a,n);
    rep(i,1,n){
        if(!idxl[a[i]]){
            sum++;
            idxl[a[i]]=i;
        }
    }
    dep(i,n,1){
        if(!idxr[a[i]]){
            idxr[a[i]]=i;
        }
    }
    std::cout<<(sum+dfs(1,n))/2<<":"<<(sum-dfs(1,n))/2;
    return 0;
}
```

---


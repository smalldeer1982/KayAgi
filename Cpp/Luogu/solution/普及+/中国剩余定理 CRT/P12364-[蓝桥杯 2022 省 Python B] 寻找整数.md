# [蓝桥杯 2022 省 Python B] 寻找整数

## 题目描述

有一个不超过 $10^{17}$ 的正整数 $n$，知道这个数除以 $2$ 至 $49$ 后的余数如下表所示，求这个正整数最小是多少。

| $a$ | $n \bmod a$ | $a$ | $n \bmod a$ | $a$ | $n \bmod a$ | $a$ | $n \bmod a$ |
|:---:|:-----------:|:---:|:-----------:|:---:|:-----------:|:---:|:-----------:|
| $2$ | $1$         | $14$| $11$        | $26$| $23$        | $38$| $37$        |
| $3$ | $2$         | $15$| $14$        | $27$| $20$        | $39$| $23$        |
| $4$ | $1$         | $16$| $9$         | $28$| $25$        | $40$| $9$         |
| $5$ | $4$         | $17$| $0$         | $29$| $16$        | $41$| $1$         |
| $6$ | $5$         | $18$| $11$        | $30$| $29$        | $42$| $11$        |
| $7$ | $4$         | $19$| $18$        | $31$| $27$        | $43$| $11$        |
| $8$ | $1$         | $20$| $9$         | $32$| $25$        | $44$| $33$        |
| $9$ | $2$         | $21$| $11$        | $33$| $11$        | $45$| $29$        |
| $10$| $9$         | $22$| $11$        | $34$| $17$        | $46$| $15$        |
| $11$| $0$         | $23$| $15$        | $35$| $4$         | $47$| $5$         |
| $12$| $5$         | $24$| $17$        | $36$| $29$        | $48$| $41$        |
| $13$| $10$        | $25$| $9$         | $37$| $22$        | $49$| $46$        |


# 题解

## 作者：syx_2014 (赞：5)

~其实就是暴力啦。~

假设要求的数为 $x$。

我们观察表格，发现 $x$ 除以很多数的余数都是 $11$，通过计算得知这些模数的最小公倍数是 $59598$。

将除 $x$ 余数相同除数合并，也就是求最小公倍数就行了。

合并结果如下：



|$a_i$|$x \bmod a_i$|
|:-:|:-:|
|$187$|$0$|
|$328$|$1$|
|$9$|$2$|
|$35$|$4$|
|$564$|$5$|
|$400$|$9$|
|$13$|$10$|
|$59598$|$11$|
|$15$|$14$|
|$16$|$15$|
|$29$|$16$|
|$408$|$17$|
|$19$|$18$|
|$27$|$20$|
|$37$|$22$|
|$78$|$23$|
|$224$|$25$|
|$31$|$27$|
|$180$|$29$|
|$38$|$37$|
|$44$|$33$|
|$48$|$41$|
|$49$|$46$|

于是乎，我们就可以写出一个~无脑~暴力代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	for(long long j=11;j<=1e17;j+=59598){
		if(j%9==2
		 &&j%187==0
		 &&j%564==5
		 &&j%328==1
		 &&j%400==9
		 &&j%35==4
		 &&j%13==10
		 &&j%15==14
		 &&j%46==15
		 &&j%29==16
		 &&j%408==17
		 &&j%19==18
		 &&j%27==20
		 &&j%37==22
		 &&j%78==23
		 &&j%224==25
		 &&j%31==27
		 &&j%180==29
		 &&j%38==37
		 &&j%44==33
		 &&j%48==41
		 &&j%49==46){
		 	cout<<j<<'\n';
		 	return 0;
		 } 
	}
	return 0;
}
```

跑了两个半小时后，得出答案 $2022040920220409$。

~（反正蓝桥杯有四个小时，不影响我们做其他题）。~

---

## 作者：Clare613 (赞：3)

## 思路：
这道题就是直接用遍历来使这个数符合要求，就是说每一次更新一次数后要保证依旧符合以前的数的要求，所以每一次就加前面数的最小公倍数，最后得到答案为 $2022040920220409$，输出就完事了，这里给大家贴上算答案代码。\
最小公倍数的求法就是用两数之积除以最大质因数即可，有的人肯定会问，为什么是加最小公倍数？答案其实很明显，因为要让前面的数都能保持余数正确，所以只能加所有数的倍数，也就是最小公倍数了。
## code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100]={0,0,1,2,1,4,5,4,1,2,9,0,5,10,11,14,9,0,11,18,9,11,11,15,17,9,23,20,25,16,29,27,25,11,17,4,29,22,37,23,9,1,11,11,33,29,15,5,41,46};
signed main(){
	int ans=0,q=1;
	for(int i=2;i<=49;i++){
		for(int j=0;j<i&&ans%i!=a[i];ans+=q,j++){}
		q=q*i/__gcd(q,i);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：XXXL_jzl (赞：3)

# 题解：P12364 [蓝桥杯 2022 省 Python B] 寻找整数

## 分析

这一题，简单一个模拟，通过循环遍历的方式，暴力求出 $n$ 的值。\
此时，仔细一看。会发现有很多个模数对 $n$ 取模得到 $11$， ~~这点很关键~~ 。\
这个时候，有一个点要注意，每一次遍历改变的是我们模拟 $n$ 的变量，但对这个变量的取模结果不能改变。\
那么，我们可以用上小学就学过的最小公倍数，每一次都加上最小公倍数不就行了。\
说回上文对 $n$ 取模得到 $11$ 的数，求出它们的最小公倍数，即 $59598$。在暴力求解过程中，可以假设 $n$ 为 $ i \times 59598 + 11 $，不断暴力枚举。

## 注意事项

$n \le 10^{17}$ 这个范围应该开 ```long long```。

## 答疑

为什么将 $n$ 假设为 $ i \times 59598 + 11 $，为什么要加上 $11$。\
首先，这里假设 $n$ 为 $ i \times 59598 + 11 $ 是由于上文中我们提及的最小公倍数与取模得数不变的问题。\
想要让取模得数不变，每次加上最小公倍数就好了。\
而在求出的结果上加 $11$ 是因为这些数对 $n$ 取模得到 $11$。要想还原，需加上 $11$。

## AC Code

```python
print(2022040920220409)
```

---

## 作者：ArenaBreakout78 (赞：3)

# 题解：P12364 [蓝桥杯 2022 省 Python B] 寻找整数

首先，要做这道题，我们需要知道**中国剩余定理 CRT**，不知道的看[这里](https://blog.csdn.net/weixin_57383443/article/details/145906908)。

## 思路：

1. 从最小的模数开始，逐步合并每个同余方程。每次合并两个同余方程，得到一个新的同余方程，直到所有方程合并完毕。

2. 对于两个同余方程 $n \equiv a \pmod m$ 和 $n \equiv b \pmod k$，我们需要找到 n 满足这两个方程。这可以通过解线性同余方程来实现。

3. 使用扩展欧几里得算法来求解线性同余方程的解。如果模数不互质，需要检查是否有解，并调整解的形式。

最后，将这几步组合起来，就能够得到代码：

## C++ AC Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long qj(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long long g = qj(b, a % b, y, x);
    y -= a / b * x;
    return g;
}
bool hb(long long a, long long m, long long b, long long n, long long &r, long long &l) {
    long long x, y;
    long long g = qj(m, n, x, y);
    if ((b - a) % g != 0) return false;
    l = m / g * n;
    r = (a + (b - a) / g * x % (n / g) * m) % l;
    if (r < 0) r += l;
    return true;
}
int main() {
    int MOD[][2] = {
        {2, 1}, {3, 2}, {4, 1}, {5, 4}, {6, 5}, {7, 4}, {8, 1}, {9, 2}, {10, 9},
        {11, 0}, {12, 5}, {13, 10}, {14, 11}, {15, 14}, {16, 9}, {17, 0}, {18, 11},
        {19, 18}, {20, 9}, {21, 11}, {22, 11}, {23, 15}, {24, 17}, {25, 9}, {26, 23},
        {27, 20}, {28, 25}, {29, 16}, {30, 29}, {31, 27}, {32, 25}, {33, 11}, {34, 17},
        {35, 4}, {36, 29}, {37, 22}, {38, 37}, {39, 23}, {40, 9}, {41, 1}, {42, 11},
        {43, 11}, {44, 33}, {45, 29}, {46, 15}, {47, 5}, {48, 41}, {49, 46}
    };
    int MODn = sizeof(MOD) / sizeof(MOD[0]);

    long long cnta = MOD[0][1];
    long long cntm = MOD[0][0];
    for (int i = 1; i < MODn; ++i) {
        long long nsa, nsm;
        if (!hb(cnta, cntm, MOD[i][1], MOD[i][0], nsa, nsm)) return 0;
        cnta = nsa;
        cntm = nsm;
    }
    cout << cnta << endl;
    return 0;
}

```

## Python AC Code：

```python
print(2022040920220409)
```

---

## 作者：chen_zi_lang (赞：2)

# 题解
# [题目传送门](https://www.luogu.com.cn/problem/P12364)

## 一、题面描述
找到一个正整数 $n$（$0 \leq n \leq 10^{17}$），要求满足题目表格中 $2$ 到 $49$ 的余数，如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/aqt6ab4b.png)

## 二、思路
这题其实有一个很简单的方法——枚举。但是纯粹暴力绝对会超时，于是不难想到，可以使用逐步满足法。

只要一直加目前枚举到所有数的最小公倍数，直到满足下一个数的余数。

之所以加最小公倍数，是因为它可以整除前面的所有数，保持前面的余数不变。  
即：  
$$\text{now} \equiv 0 \pmod{x-1, x-2, \ldots, 2}$$

所以，先枚举除数 $x$，接着一直加前面所有数的最小公倍数，一旦满足下一个除数的余数就跳出，然后再更新最小公倍数 $\text{now}$，最后输出。

## 三、代码
```cpp
#include <bits/stdc++.h>//万能头文件
#define int long long//宏定义：快速把int转换成long long
using namespace std;
int mod[51]={0,0,1,2,1,4,5,4,1,2,9,0,5,10,11,14,9,0,11,18,9,11,11,15,17,9,23,20,25,16,29,27,25,11,17,4,29,22,37,23,9,1,11,11,33,29,15,5,41,46};
//mod 数组存储余数
int res,now=1;//结果，当前最小公倍数
inline int lcm(int x,int y){//最小公倍数函数（两数之积/最大公因数）
    return x*y/__gcd(x,y);//__gcd为c++库函数
}
signed main(){//signed=int（main函数必须为int类型）
    for(int x=2;x<=49;x++){//枚举除数
        while(mod[x]!=res%x){//一直加之前的最小公倍数，直到符合下一个条件
            res+=now;
        }
        now=lcm(now,x);//更新最小公倍数
    }
    printf("%lld",res);//输出答案
    return 0;
}
```

### 时间复杂度
这段代码时间复杂度接近 $O(n)$，而最坏情况是每一个内层循环 $x$ 次，时间复杂度约为 $O(n^2)$，不过由于正常数字余数分布随机，实际会更快。
### 答案
当然，这题有固定答案：$2022040920220409$。

所以，直接输出也行：  
（**但是，我们不应该提倡这种行为，应该认真地做代码**）

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
  cout<<"2022040920220409";//答案
  return 0;
}
```

---

## 作者：XsIeEiKcEk (赞：2)

我们发现，有很多 $n\bmod a$ 的结果为 $11$，所以这个数一定为 $59598\times k+11$（$59598$ 为那些取余结果为 $11$ 的数的最小公倍数）。

接着暴力，模拟剩下的每一个数，看是否满足条件，并用 `bool` 变量记录，若都满足，输出。

### CODE：
```python
sum = 1
while True:#一直循环
    num = 59598 * sum + 11
    flag = True
    if num % 2 != 1:
        flag = False
    elif num % 3 != 2:
        flag = False
    elif num % 4 != 1:
        flag = False
    elif num % 5 != 4:
        flag = False
    #以下省略
    if flag:#若都满足
        print(num)
        break
    sum += 1
```
答案为 $2022040920220409$。

### AC CODE
```python
print(2022040920220409)
```

---

## 作者：封禁用户 (赞：2)

# 题目大意 ：
在 $10^{17}$ 内里寻找一个整数满足：

| $a$ | $n \bmod a$ | $a$ | $n \bmod a$ | $a$ | $n \bmod a$ | $a$ | $n \bmod a$ |
|:---:|:-----------:|:---:|:-----------:|:---:|:-----------:|:---:|:-----------:|
| $2$ | $1$         | $14$| $11$        | $26$| $23$        | $38$| $37$        |
| $3$ | $2$         | $15$| $14$        | $27$| $20$        | $39$| $23$        |
| $4$ | $1$         | $16$| $9$         | $28$| $25$        | $40$| $9$         |
| $5$ | $4$         | $17$| $0$         | $29$| $16$        | $41$| $1$         |
| $6$ | $5$         | $18$| $11$        | $30$| $29$        | $42$| $11$        |
| $7$ | $4$         | $19$| $18$        | $31$| $27$        | $43$| $11$        |
| $8$ | $1$         | $20$| $9$         | $32$| $25$        | $44$| $33$        |
| $9$ | $2$         | $21$| $11$        | $33$| $11$        | $45$| $29$        |
| $10$| $9$         | $22$| $11$        | $34$| $17$        | $46$| $15$        |
| $11$| $0$         | $23$| $15$        | $35$| $4$         | $47$| $5$         |
| $12$| $5$         | $24$| $17$        | $36$| $29$        | $48$| $41$        |
| $13$| $10$        | $25$| $9$         | $37$| $22$        | $49$| $46$        |

### 本题思路 ：
想到逐级满足法。

$$
\begin{cases}
x\equiv a_1\pmod{m_1}\\
x\equiv a_2\pmod{m_2}\\
\vdots\\
x\equiv a_k\pmod{m_k}
\end{cases}
$$
 $1$. 从第一个方程开始：将解表示为第一个方程的通解形式。
  
 $2$. 代入下一个方程：将通解代入第二个方程，解出新的参数。
  
  $3$.合并方程：将新参数代回通解，得到前两个方程的合并通解。
  
$4$.  重复步骤 $2-3$：继续合并后续方程，直到所有方程都被处理。

第一个方程的通解为：$x=a_1+k⋅m_1$，

代入第二个方程：$a_1+k⋅m_1\equiv$ $a_2(\bmod$ $m_1$ $)$，

整理得：$k⋅m_1\equiv a_2−a_1$($ \bmod$ $m_2)$。

这是一个关于 $k$ 的线性同余方程，当且仅当 $\gcd(m_1,m_2)∣(a_2−a_1)$ 时有解。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
ll s,t,a[50],m[50];
signed main(){
    for(int i=1;i<=48;i++){
      ll x,y;
      cin>>x>>y;
      a[i]=x;
      m[i]=y;
    }
    s=a[1],t=m[1];
    for(int i=2;i<=48;i++){
    	while(s%m[i]!=a[i]) s+=t;
    	t=t/__gcd(t,m[i])*m[i];
    }
    cout<<s;
}
```
所以得出答案 $2022040920220409$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  cout<<2022040920220409;
  return 0;
}
```

---

## 作者：chrispang (赞：1)

## 题目大意

在 $10^{17}$ 内里寻找一个满足：

| $a$ | $n \bmod a$ | $a$ | $n \bmod a$ | $a$ | $n \bmod a$ | $a$ | $n \bmod a$ |
|:---:|:-----------:|:---:|:-----------:|:---:|:-----------:|:---:|:-----------:|
| $2$ | $1$         | $14$| $11$        | $26$| $23$        | $38$| $37$        |
| $3$ | $2$         | $15$| $14$        | $27$| $20$        | $39$| $23$        |
| $4$ | $1$         | $16$| $9$         | $28$| $25$        | $40$| $9$         |
| $5$ | $4$         | $17$| $0$         | $29$| $16$        | $41$| $1$         |
| $6$ | $5$         | $18$| $11$        | $30$| $29$        | $42$| $11$        |
| $7$ | $4$         | $19$| $18$        | $31$| $27$        | $43$| $11$        |
| $8$ | $1$         | $20$| $9$         | $32$| $25$        | $44$| $33$        |
| $9$ | $2$         | $21$| $11$        | $33$| $11$        | $45$| $29$        |
| $10$| $9$         | $22$| $11$        | $34$| $17$        | $46$| $15$        |
| $11$| $0$         | $23$| $15$        | $35$| $4$         | $47$| $5$         |
| $12$| $5$         | $24$| $17$        | $36$| $29$        | $48$| $41$        |
| $13$| $10$        | $25$| $9$         | $37$| $22$        | $49$| $46$        |

## 题目分析

如果暴力枚举，则程序运算次数可达 $10^{17}\times 48$，明显不行。

### 优化暴力

因为 $1\bmod 2=1$，所以先让 $ans=1$。

之后枚举后面的 $47$ 个算式。设当前枚举到第 $i$ 个算式。设前面 $i-1$ 个 $a$ 的最小公倍数为 $q$。则在当前 $ans$ 的基础上不停的加上 $q$，直至 $ans\equiv 0 \pmod {a_i} $，之后更新 $q$ 即可。

这是一个神奇的方法，不仅时间较短，且代码复杂度较低（但是不建议常使用）。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, a1, m1, res;
signed main() {
    cin >> n >> a1 >> m1;
    res = m1;
    for (int i = 1, qp = a1, a2, m2; i < n; i++) {
        cin >> a2 >> m2;
        while (res % a2 != m2) res += qp;
        qp = qp / __gcd(qp, a2) * a2;
    }
    cout << res << endl;
    return 0;
}
```

### 中国剩余定理

中国剩余定理处理的方程长相如下：

$$\begin{cases}x\equiv a_1\pmod{m_1}\\x\equiv a_2\pmod{m_2}\\\dots\\x\equiv a_n\pmod{m_n}\end{cases}$$

那么，我们只需要把相对应的数据放入即可，具体操作请看[本人的详细讲解](https://www.luogu.com.cn/article/ytuvckg3)。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int exgcd(int a, int b, int &x, int &y) {
	if(b == 0) {
		x = 1, y = 0; //b = 0的情况 
		return a;
	}
    int x1, y1;
    int d = exgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - a / b * y1;
	return d;
}

int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(b, a % b);
}

int mod(int a, int b) {
    return ((a % b) + b) % b;
}

int n, a1, m1;
signed main() {
	scanf("%lld%lld%lld", &n, &a1, &m1);
	for (int i = 1, a2, m2; i < n; i++) {
		scanf("%lld%lld", &a2, &m2);
		int c = m2 - m1, k1 = 0, k2 = 0;
		int d = exgcd(a1, -a2, k1, k2); //扩展欧几里得 
		if((m2 - m1) % d) { //不能整除 
			cout << -1 << endl;
			return 0;
		}
		k1 = mod(k1 * (m2 - m1) / d, abs(a2 / d)); //前面是为了找解，后面是为了找最小解
		m1 = abs(a1 * k1 + m1); //为了下一次做准备 
		a1 = abs(a1 / d * a2); 
	}
	cout << m1 << endl;
	return 0;
}
```

## 代码实现

可以得到答案为 $2022040920220409$，于是有了最终的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

signed main() {
    cout << 2022040920220409 << endl;
    return 0;
}
```

---

## 作者：tonghaoxuan (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12364)

## 本题思路：

### 想法：

本题的想法很简单，通过枚举 $ n $ 来满足 $ n \bmod a $ 的要求。虽然可以一个一个枚举，但是作为一道绿题（水），这显然不合适，实在太慢了。

### 做法：

众所周知，$ n \equiv n + k \times a \pmod a $（其中，$ k $ 为任意正整数）。

所以，如果我们知道目前 $ n $ 满足了哪个 $ n \bmod a $ 的条件，我们就可以通过使 $ n $ 加 $ a $ **的倍数**来继续枚举却不影响这个条件的满足，因而我们可以不断加**所有满足条件的** $ a $ **的最小公倍数**来快速得出答案。

## 代码：

### 代码 $ 1 $，得出答案：

得出答案的代码如下，因为最大 $ n \le 10 ^ {17} $ 次方，所以记得开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int mod[50];
signed main(){
	//我这里采用输入的方式代替手动赋值mod列表。 
	for(int i=1;i<=48;i++){
		int x,y; 
		cin>>x>>y;
		mod[x]=y;
	}
	int jia=1; 
	for(int n=0;;n+=jia){
		int sum=0;
		for(int a=2;a<=49;a++){
			if(n%a==mod[a]){//判断n是否满足a的余数条件。
				sum++;
				jia=jia*a/__gcd(jia,a);//使加数更新为原加数和i的最小公倍数。 
			}
		}
		if(sum==48){ 
			cout<<n;//得出答案 
			return 0;
		}
	}
}
``````

### 代码 $ 2 $，输出答案：

在得出答案之后，只要再写一个代码输出答案 $ 2022040920220409 $ 就可以了。

```cpp
#include<bits/stdc++.h>
int main(){std::cout<<2022040920220409;}
``````

## 结尾：

如果不想分开成两份代码，可以把第一份代码的输入部分改为手动赋值，这样就只需第一份代码。

~~本蒟蒻的第一份题解就这样结束啦！~~

（第六次修改）

---

## 作者：easy42 (赞：1)

**注：可以在两分钟内跑出。**

看到这题，暴力枚举跑不出来。如果你有没有充分的数学知识，那又怎么办呢？

### 减少枚举量

首先，注意到许多余数都是 $11$，有图为证：

![](https://cdn.luogu.com.cn/upload/image_hosting/in1nmq6j.png)

设这个数为 $n$，则有：

$$
n \bmod 14 = n \bmod 18 =n \bmod 21 = n \bmod 22 = n \bmod 33 = n \bmod 42 = n \bmod 43  = 11
$$

直接把以上除数的最小公倍数求出，为 $59598$。

枚举时，我们设 $n$ 为 $i \times 59598+11$，$i$ 为循环变量。

它是满足所有以上 $
n \bmod 14 = n \bmod 18 =n \bmod 21 = n \bmod 22 = n \bmod 33 = n \bmod 42 = n \bmod 43  = 11
$ 的。

现在 $i$ 只需枚举到 $10^{13}$ 即可，因为 $n$ 不超过 $10^{17}$。

### 暴力枚举

因为这个数肯定存在，所以只要使用一些（不一定要全部）条件，只搜出一个解即为答案。

需要注意的点：

1. 上界为 $10^{13}$。
2. 条件多加。
3. **耐心等待**。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main(){
	for(long long i=0;i<=10000000000000;i++){
		if((i*59598+11)%38==37&&(i*59598+11)%31==27&&(i*59598+11)%39==23&&(i*59598+11)%46==15&&(i*59598+11)%48==41&&(i*59598+11)%13==10&&(i*59598+11)%41==1&&(i*59598+11)%11==0&&(i*59598+11)%19==18&&(i*59598+11)%37==22&&(i*59598+11)%49==46&&(i*59598+11)%5==4&&(i*59598+11)%41==1&&(i*59598+11)%17==0){
			cout<<i<<" "<<i*59598+11<<endl;
            exit(0);
		}
	}
	return 0;
} 
```

最终代码：

```python
print(2022040920220409)
```

求赞！

---

## 作者：YZren (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12364)

# 思路

- 此题就一个板子[拓展中国剩余定理](https://www.luogu.com.cn/problem/P4777)不会的可以先学一下。

- 发现此题没有输入，先将所有数据手动存一下，毕竟是输出答案题，答案说一下是 $2022040920220409$。

- 做此题还有用拓展欧几里得定理，不会的也可以先学一下，这里我直接给出代码。

## Code


```cpp
inline void Exgcd(int a,int b,int &d,int &x,int &y){
	if(b==0) d=a,x=1,y=0;
	else{
		int x0,y0; Exgcd(b,a%b,d,x0,y0);
		x=y0; y=x0-(a/b)*y0;
	}	
}
```
- 再说拓展中国剩余定理，由于是形如 
$$\begin{cases}n\equiv b_1\pmod{a_1}\\n\equiv b_2\pmod{a_2}\\\dots\\n\equiv b_{48}\pmod{a_{48}}\end{cases}$$ 
的问题，转化一下便可得 
$$n=x_1\times a_1+b_i=x_2\times a_2+b_2=\dots=x_{48}\times a_{48}+b_{48}$$ 
这一方程。

- 定义 $con$ 是常数，另外 $coe$ 是系数，每次算一个方程时，将满足之前所有方程的条件带入当前方程，更新两个数 $con=con+coe\times x$ 和 $coe=coe\times (a_i\div \gcd(coe,a_i))$ 其中 $x$ 是通过拓展欧几里得定理算出来的特解，最后输出最后一步的 $con$ 就可以了。

## Code

```cpp
inline int ExCRT(){
	int coe=1,con=0,gc,x,y;
	f(i,1,n){
		Exgcd(coe,a[i],gc,x,y);
		x=(b[i]-con)/gc*x;
		con+=coe*x; coe*=a[i]/gc;
		con=(con%coe+coe)%coe;
	}
	return con;
}
```

# Code

```cpp
#include<bits/stdc++.h>
#define int __int128
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void Exgcd(int a,int b,int &d,int &x,int &y){
	if(b==0) d=a,x=1,y=0;
	else{
		int x0,y0; Exgcd(b,a%b,d,x0,y0);
		x=y0; y=x0-(a/b)*y0;
	}	
}
int n=48,a[50],b[50]={0,1,2,1,4,5,4,1,2,9,0,5,10,11,14,9,0,11,18,9,11,11,15,17,9,23,20,25,16,29,27,25,11,17,4,29,22,37,23,9,1,11,11,33,29,15,5,41,46};
inline int ExCRT(){
	int coe=1,con=0,gc,x,y;
	f(i,1,n){
		Exgcd(coe,a[i],gc,x,y);
		x=(b[i]-con)/gc*x;
		con+=coe*x; coe*=a[i]/gc;
		con=(con%coe+coe)%coe;
	}
	return con;
}
inline void work(){
	f(i,1,n) a[i]=i+1;
	write(ExCRT());
}
signed main(){work();return !!!!!("YZren");}
```

# python Code

```python
print(2022040920220409)
```

---

## 作者：XXXXD__TB_XZH (赞：0)

# 题解：P12364 \[蓝桥杯 2022 省 Python B] 寻找整数

## 题目介绍

题目一看就是暴力枚举求答案，给定某个数对多个数求得到的余数，粗略一看，有许多余数为 $11$，求原数应先优先满足此条件。\
那么只需要求这些除数的最小公倍数再加上 $11$，就可以满足这部分条件。\
但并未全部满足。\
为了在满足这部分条件的基础上求符合更多条件的数，只需每次循环加上此最小公倍数 $59598$，判断此时这个数即 $i\times59598+11$ 是否满足其他的条件，直到满足所有条件为止。\
经过漫长的等待，得出答案为 $2022040920220409$。

### 注意

数字这么大，且 $n \le 10^{17}$ 当然要开 `long long`。

## AC code:

```python
print(2022040920220409)
```

---

## 作者：wjl1100 (赞：0)

## [原题传送门](https://www.luogu.com.cn/problem/P12364)

## 思路

### 前置知识

[P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.com.cn/problem/P4777)

当我们把 P4777 做出来后，这道题就迎刃而解了。

我们假设方程的解为 $coe \times x+con$ 其中 $coe$ 为系数，$con$ 为常数，把他带入下一个方程 $x≡b\pmod a$ 中可以得到 $(coe \times x+con)+a \times y=b$，则 $coe \times x+a \times y=b-con$。

运用拓展欧几里得算法可求出 $x=x_0+k \times a\div\gcd(a,aoe)$ 其中 $x_0$ 为特解，$k$ 为整数，再带入 $x$ 的值可得出方程解为 $coe \times a\div\gcd(a,coe) \times k+coe \times x_0+con$，那么 $k$ 的系数为 $coe \times a\div\gcd(a,coe)$，常数为 $coe \times x_0+con$ 然后继续往后推直至最后一个方程。

## 实现代码

```cpp
#include<bits/stdc++.h>
#define int __int128
#define inf 0x7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x) {
	if(x < 0) x = ~(x - 1) , putchar('-');
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
inline void writeh(int x) {
	write(x);
	putchar('\n');
}
inline void writek(int x) {
	write(x);
	putchar(' ');
}
int n , a[maxn] = {0 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49};
int b[maxn] = {0 , 1 , 2 , 1 , 4 , 5 , 4 , 1 , 2 , 9 , 0 , 5 , 10 , 11 , 14 , 9 , 0 , 11 , 18 , 9 , 11 , 11 , 15 , 17 , 9 , 23 , 20 , 25 , 16 , 29 , 27 , 25 , 11 , 17 , 4 , 29 , 22 , 37 , 23 , 9 , 1 , 11 , 11 , 33 , 29 , 15 , 5 , 41 , 46};
inline void exgcd(int a , int b , int &gcd , int &x , int &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		gcd = a;
		return;
	}
	int x0 , y0;
	exgcd(b , a % b , gcd , x0 , y0);
	x = y0;
	y = x0 - (a / b) * y0;
}
inline int excrt() {
	int coe = 1 , con = 0 , x , y , d;
	for(int i = 1; i <= n; i++) {
		exgcd(coe , a[i] , d , x , y);
		x = (b[i] - con) / d * x;
		con += coe * x;
		coe *= a[i] / d;
		con = (con % coe + coe) % coe;
	}
	return con;
}
signed main(){
	n = 48;
	writeh(excrt());
	return !("wjl1100 qwq");
} 
```

可算出答案为 $2022040920220409$。

输出即可。

## **AC\_CODE**

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
#define mod 1000000007
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x) {
	if(x < 0) x = ~(x - 1) , putchar('-');
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
inline void writeh(int x) {
	write(x);
	putchar('\n');
}
inline void writek(int x) {
	write(x);
	putchar(' ');
}
signed main(){
	writeh(2022040920220409);
	return !("wjl1100 qwq");
} 
```

## Python 代码

```python
print(2022040920220409)
```

---

## 作者：ouxiyao (赞：0)

昨天紧急学了 CRT，来一波 CRT 题解。                               
[前置知识](https://www.luogu.com.cn/problem/P1495) [前置知识的前置知识](https://www.luogu.com.cn/problem/P1082)                   
还记得 CRT 的4个步骤吗？            
- **计算总模数**：$M=m_1m_2......m_n$;         
- **计算每个子模数**：对于每个 $i$，计算 $M_i = \frac{M}{m_i}$。
- **求逆元**：对于每个 $M_i$，找到 $t_i$ 满足：

$$
M_it_i\equiv1\pmod{m_i}
$$
- **构造解**：最终解为

$$
x=\sum_{i=1}^ka_iM_it_i \pmod{M}
$$
不用举例了吧？                    
但是，你可能会说，二到四十九不互质呀！其实，将数据筛选一下，只留下 $a$ 为质数的，就好了。                    
给出筛选后的数据：

```
15
2 1
3 2
5 4
7 4
11 0
13 10
17 0
19 18
23 15
29 16
31 27
37 22
41 1
43 11
47 5
```
再给出此题代码（请输入上面的数据）：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100010],b[100010],m[100010],t[100010];
long long x,y;
void jfc(long long xx,long long yy){
	if(yy==0){
		x = 1,y = 0;
		return ;
	}
	jfc(yy,xx%yy);
	long long f = x;
	x = y;
	y = f-xx/yy*y;
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cout.tie(0);
	int n;
	long long M = 1,xf = 0;
	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>a[i]>>b[i];
		M*=a[i]; 
	}
	for(int i = 1;i<=n;i++){
		m[i] = M/a[i];
		x = 0,y = 0;
		jfc(m[i],a[i]);
		t[i] = (x%a[i]+a[i])%a[i];
		xf = (b[i]*m[i]%M*t[i]%M+xf)%M;
	}
	cout<<xf%M;
	return 0;
}//此题代码过不了P1495的hack，但是能做对此题
```
输入数据后，得出答案为 `2022040920220409`。输出，完事。

---

## 作者：yanmingqian (赞：0)

这不是我们中国剩余定理的板子吗。下面简单介绍一下中国剩余定理。

## 定义

中国剩余定理可以用于求解如下形式关于 $x$ 的一元线性同余方程组（其中 $m_1,m_2,...,m_k$ 两两互质）：

$$
\begin{cases}
 x \equiv a_1\pmod {m_1}\\
 x \equiv a_2\pmod {m_2}\\
 ...\\
 x \equiv a_k\pmod {m_k}
\end{cases}
$$

## 过程

1. 计算所有模数的积 $M$；
2. 遍历每个方程，对于第 $i$ 个方程：\
   a. 计算 $m_{now}=\frac{M}{m_i}$；\
   b. 计算 $m_{now}$ 在模 $m_i$ 意义下的逆元 $m_{now}^{-1}$（使用 exgcd 算法）；\
   c. 计算 $c_i=m_{now}\times m_{now}^{-1}$；
3. 方程组在模 $M$ 意义下的唯一解为：$x=\sum^k_{i=1} a_ic_i \pmod M$。

## 代码实现

```cpp
int CRT(){
    int ans=0;
    for(int i=1;i<=n;i++){
        int m_now=M/m[i],x,y;
        exgcd(m_now,m[i],x,y);
        ans=((ans+m_now*x*a[i])%M+M)%M;
    }
    return ans;
}
```

```py
def CRT(n, m, a, M):
    ans = 0
    for i in range(n):
        m_now = M // m[i]
        x, y = exgcd(m_now, m[i])
        ans = ((ans + m_now * x * a[i]) % M + M) % M
    return ans

```

（以上内容摘自我的全站推荐文章[数论](https://www.luogu.com.cn/article/l60ov7h3)，python 代码为本题解专有）

然后这题就做完了。答案是 `2022040920220409`，直接输出即可。~~（不知道场上有没有蒙过的）~~

---


# 后缀数组

## 题目描述

后缀数组 (SA) 是一种重要的数据结构，通常使用倍增或者 DC3 算法实现，这超出了我们的讨论范围。

在本题中，我们希望使用快排、Hash 与二分实现一个简单的 $O(n\log^2n)$ 的后缀数组求法。

详细地说，给定一个长度为 $n$ 的字符串 $S$（下标 $0 \sim n-1$），我们可以用整数 $k(0 \le k < n)$ 表示字符串 $S$ 的后缀 $S(k \sim n-1)$。

把字符串 $S$ 的所有后缀按照字典序排列，排名为 $i$ 的后缀记为 SA[i]。

额外地，我们考虑排名为 $i$ 的后缀与排名为 $i-1$ 的后缀，把二者的最长公共前缀的长度记为 Height[i]。

我们的任务就是求出 SA 与 Height 这两个数组。

## 样例 #1

### 输入

```
ponoiiipoi```

### 输出

```
9 4 5 6 2 8 3 1 7 0
0 1 2 1 0 0 2 1 0 2```

# 题解

## 作者：Weekoder (赞：9)

### 思路

求取 $\text{SA}$ 数组，容易想到排序。但是直接比较字符串的字典序将会使排序的时间复杂度达到 $\mathcal{O}(n^2
\log n)$，超时，考虑优化。

这里用到的技巧是：比较两个字符串的字典序，可以通过哈希 + 二分的优化达到单次询问 $\mathcal{O}(\log n)$。原理很简单：模拟手动比较字符串字典序的顺序，容易发现以下过程：

1. 从第一个字符开始比较。

2. 如果当前字符不相等，就直接比较这两个字符，即可得出答案。

3. 否则，继续比较下一个字符。

这个过程实际上就是在寻找两个字符串的**最长公共前缀**，而下一个字符就一定不相等。两个字符串的最长公共前缀如何求取？同 [P10479 匹配统计](https://www.luogu.com.cn/problem/P10479)，这是具有单调性的（事实上，你可以在 P10479 里看到我的题解，与下面的描述一样）：如果前 $x$ 个字符串可以匹配，则前 $y(y<x)$ 个字符串也可以匹配；如果前 $x$ 个字符串不可以匹配，则前 $y(y>x)$ 个字符串也不可以匹配。可以通过二分来寻找最大的 $x$，配合哈希，可以做到 $\mathcal{O}(\log n)$ 的时间复杂度。这样，就可以把排序优化到 $\mathcal{O}(n\log^2n)$ 的时间复杂度了，符合要求。

而 $\text{Height}$ 数组的求取也就易如反掌了：单次哈希 + 二分求最长公共前缀 $\mathcal{O}(\log n)$，这部分的总时间复杂度为 $\mathcal{O}(n\log n)$。

代码：

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std; 

typedef unsigned long long ull;

const int N = 3e5 + 5, base = 1e9 + 7;

string s;

int n, SA[N], Height[N];

ull hs[N], pw[N];

ull get_hash(int l, int r) {
	return hs[r] - hs[l - 1] * pw[r - l + 1];
}

int find_pos(int x, int y) {
	int l = -1, r = min(n - x + 1, n - y + 1) + 1;
	while (l + 1 < r) {
		int mid = l + r >> 1;
		if (get_hash(x, x + mid - 1) == get_hash(y, y + mid - 1))
			l = mid;
		else	
			r = mid;
	}
	return l;
}

bool cmp(int x, int y) {
	int pos = find_pos(x, y);
	return s[x + pos] < s[y + pos];
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> s;
	n = s.size();
	s = '#' + s;
	pw[0] = 1;
	for (int i = 1; i <= n; i++) {
		SA[i] = i;
		pw[i] = pw[i - 1] * base;
		hs[i] = hs[i - 1] * base + s[i];
	}
	sort(SA + 1, SA + 1 + n, cmp);
	for (int i = 1; i <= n; i++)
		cout << SA[i] - 1 << " "; // 注意题目中的下标从0开始
	cout << "\n";
	for (int i = 1; i <= n; i++) 
		cout << find_pos(SA[i], SA[i - 1]) << " ";
	return 0;
}
```

---

## 作者：tjtdrxxz (赞：8)

好像题解里没有倍增的？来一发（逃。

### 前置芝士：
倍增，基数排序。

### 倍增求 SA：

首先，朴素思路大家肯定都知道，就是从最后一位开始枚举，然后每次存下当前枚举到的字符串，最后排序并输出就 OK 辣！

但是时间复杂度是我们接受不了的，枚举字符串 $ O (n ^ 2) $，排序 $ O (n ^ 2 \log {n}) $，所以倍增的思路就是每次枚举长度（当然是从 $ 1 \to 2 ^ k (2 ^ k \le n)$）。

所以我们的排序画成图的是这样的（下文称字符串为 $ s $）：

第一次就相当于是按每个后缀的首字母排序。
![](https://cdn.luogu.com.cn/upload/image_hosting/wvfs4863.png)

第二次向后了一位，因为已经根据首字母拍了一次序，所以现在就根据后面的排序，类似于第一关键字，第二关键字。
![](https://cdn.luogu.com.cn/upload/image_hosting/v6ubkaxt.png)

好，第三次，向后扩展了两位，不就是上一次的排序结果加上最后一位（就是第一次的）排序结果吗？所以也是轻松得到。
![](https://cdn.luogu.com.cn/upload/image_hosting/10p32jao.png)

第四次，扩展了四位，欸，好像向后扩展的都在之前被更新过了，所以直接就可以用之前的结果和当前的 $ s_i $ 的排名把现在的更新就好了，大概是 $ O (\log ^ 2n) $ 的。
![](https://cdn.luogu.com.cn/upload/image_hosting/zexkcukf.png)

warning：图片出处（[here](https://blog.csdn.net/w4149/article/details/72972180)）。

注：这里我们每次都会借助更新后的 $ rank $ 数组辅助排序，避免每次重新暴力排，所以每次相当于是**上一次的排序结果加上这一次的排序结果**。

但本题还要我们求出 $ height $ 数组，这时候直接利用 $ sa $ 数组以及他的 $ rank $ 数组求就好了（逃。

code:

```cpp
# include <bits/stdc++.h>
# define rank chtolly
using namespace std;
int sa[300011], t1[300011], t2[300011], c[300011], n, rank[300011], heigh[300011];
char s[300011];
void build (int m = 300)
{
	int *x = t1, *y = t2;
	for (int i = 1; i <= m; i ++) c[i] = 0;
	for (int i = 1; i <= n; i ++) c[x[i] = s[i]] ++;
	for (int i = 1; i <= m; i ++) c[i] += c[i - 1];
	for (int i = n; i >= 1; i --) sa[c[x[i]] --] = i;
	for (int j = 1; j <= n; j <<= 1)
	{
		int p = 0;
		for (int i = n - j + 1; i <= n; i ++) y[++ p] = i; 
		for (int i = 1; i <= n; i ++) if (sa[i] > j) y[++ p] = sa[i] - j;
		for (int i = 1; i <= m; i ++) c[i] = 0;
		for (int i = 1; i <= n; i ++) c[x[y[i]]] ++;
		for (int i = 1; i <= m; i ++) c[i] += c[i - 1];
		for (int i = n; i >= 1; i --) sa[c[x[y[i]]]-- ] = y[i];
		swap (x, y);
		p = 1;
		x[sa[1]] = 1;
		for (int i = 2; i <= n; i ++)
		{
			x[sa[i]] = y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + j] == y[sa[i] + j] ? p : ++ p;
		}
		if (p >= n) break;
		m = p;
	}
}
void make ()
{
	int k = 0;
	for (int i = 1; i <= n; i ++) rank[sa[i]] = i;
	for (int i = 1; i <= n; i ++)
	{
		if (rank[i] == 1) continue;
		if (k) k --;
		int j = sa[rank[i] - 1];
		while (j + k <= n and i + k <= n and s[i + k] == s[j + k])
		{
			++ k;
		}
		heigh[rank[i]] = k;
	}
}
int main ()
{
	scanf ("%s", s + 1);
	n = strlen (s + 1);
	build ();
	for (int i = 1; i <= n; i ++) printf ("%d ", sa[i] - 1);
	puts ("");
	make ();
	for (int i = 1; i <= n; i ++) printf ("%d ", heigh[i]);
	puts ("");
}
```

---

## 作者：hfjqwq (赞：5)

## 算法：
哈希，二分。

## 思路：
先预处理出哈希前缀和，以及 $BASE$ 的 $n$ 次幂，哈希用来判断某个区间的字符串是否相等。然后对数组 $sa$ 排一遍序，任意两个下标为开头的后缀字符串比较字典序时，先二分找到它们两最长公共前缀的长度，然后再比较最长公共前缀的后一个字母的大小即可。`cmp` 中二分是带 log 的，因此时间复杂度是 $O(n \log ^ 2 n)$ 。

## CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
const int N=3e5+10;
const int BASE=131;
char s[N];
int n;
ull hash1[N],pw[N],sa[N];
ull gethash(int l,int r){
	return hash1[r]-hash1[l-1]*pw[r-l+1];
}
int getlen(int a,int b){ // a,b 最长公共前缀长度 
	int l=0,r=min(n-a,n-b)+1;
	while(l<r){
		int mid=(l+r+1)/2; 
		if(gethash(a,a+mid-1)==gethash(b,b+mid-1)) l=mid;
		else r=mid-1;
	}
	return l;
}
// 以下标 a,b 为开头的会字典序比较 
bool cmp(int a,int b){
	int len=getlen(a,b);
	return s[a+len]<s[b+len]; // 比较最长公共前缀的后一个字母的大小
}
signed main(){
	cin>>(s+1);
	n=strlen(s+1);
	pw[0]=1;
	for(int i=1;i<=n;i++){
		hash1[i]=hash1[i-1]*BASE+s[i];
	}
	for(int i=1;i<=n;i++){
		pw[i]=pw[i-1]*BASE;
		sa[i]=i;
	}
	sort(sa+1,sa+1+n,cmp);
	for(int i=1;i<=n;i++){
		cout<<sa[i]-1<<" ";
	}
	cout<<"\n";
	for(int i=0;i<n;i++){
		cout<<getlen(sa[i],sa[i+1])<<" ";
	}
	cout<<"\n";
	return 0;
}
```

---

## 作者：Cypher_404 (赞：4)

# 题解：P10469 后缀数组
学习了最简单的 $O(n\ \log^2 n)$ 倍增做法，发一篇题解纪念一下。

## 题意
虽然题目说的十分清晰，但我还是来细说一下：

设字符串长度为 $n$。

后缀：字符串中从某个地方开始**一直到结尾**的**字串**成为后缀，本题要求对所有的后缀进行排序，也可以说是将以 $x$ 开头的后缀排序（$1\le x\le n$）。

**注意：求解的是每一个后缀的开头的位置（根据后缀的排名依次输出，记得是从 $0$ 开始的）**。

$Height$ 数组：（排名为 $i$ 和 $i-1$ **的后缀**）的最长公共前缀称为：$Height[i]$。

## 做法
即本文开头所提及的倍增做法。

声明一下每一个数组的含义：

- $sa[i]$，字符串中 $i$ 开头的后缀的排名的开头位置。
- $rk[i]$，在第一问中：每个后缀的前半部分的排名（后文将会细说）。在第二问中：字符串中 $i$ 开头的后缀的排名。
- $rk2[i]$，用于暂时存储总排名。
- $ht[i]$，就是 $Height$ 数组。
- 变量 $k$，当前比较的长度，用于倍增。

### 我们先来谈谈第一问

第一问需要求解后缀数组，在第二问中我们也要用到这个。

由于知道要按照字典序排列，所以肯定是比较每一个字符的大小（ASCII 码而不是长度）。

我们可以使用以前的信息，也就是 $rk$ 数组。

首先，$rk$ 数组的初始值就是当前后缀第一个字母的排名，也就是字符串 $str$ 离散化以后每一个字母的排名（当然是可以重复的）。这是 $k=1$ 的情况也可以理解为是 $2^0$ 的情况。

既然是倍增，那么接下来就是考虑 $2^1$ 的情况了。

请看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tvbktf53.png)

其中我们比较的是前两位的字典序，但是如何将此类情况推广一下到 $2$ 的更多次方呢？

答案是：复用 $rk$ 数组。将 $2p$ 拆解为 $p+p$。

就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/10ips46i.png)

蓝色部分是 $rk[i]$，红色的部分是 $rk[i+k]$。

我们可以分别比较蓝色部分和红色部分就可以知道下一次排序的结果了，然后再合并，合并后继续进行进行上述操作，直至结尾。

在此处先放预处理代码和得到后缀数组的代码：

预处理原字符串（离散化）：

```cpp
void init()
{
	for(int i=1;i<=n;i++)
	{
		d[i]=s[i];
	}
	sort(d+1,d+n+1);
	for(int i=1;i<=n;i++)
	{
		if(d[i]!=d[i-1])
		{
			tot++;
		}
		vis[d[i]]=tot;
	}
	for(int i=1;i<=n;i++)
	{
		a[i]=vis[s[i]];
//		cout<<a[i]<<' ';
	}
//	exit(0);
}
```

得到后缀数组：

```cpp
bool cmp(int x,int y)//比较两个字符串的大小，效果和上方图片一致。
{
	if(rk[x]!=rk[y])
	{
		return rk[x]<rk[y];
	}
	int rx=(x+k<=n)?(rk[x+k]):(-1);
	int ry=(y+k<=n)?(rk[y+k]):(-1);
	return rx<ry;
}
void solve_sa()
{
	for(int i=1;i<=n;i++)
	{
		rk[i]=a[i];
		sa[i]=i;
	}
	for(k=1;k<=n;k*=2)
	{
		sort(sa+1,sa+n+1,cmp);
		rk2[sa[1]]=1;
		for(int i=2;i<=n;i++)
		{
			rk2[sa[i]]=rk2[sa[i-1]]+cmp(sa[i-1],sa[i]);
		}
		for(int i=1;i<=n;i++)
		{
			rk[i]=rk2[i];
		}
	}
}
```

### 下面讲解第二问

第二问的技术含量就比第一问差了不少，直接使用基础的双指针就可以做到了。

```cpp
void solve_ht()
{
	for(int i=1;i<=n;i++)
	{
		rk[sa[i]]=i;
	}
	int h=0;
	//ht[1]=0//可以省略 
	for(int i=1;i<=n;i++)
	{
		int j=sa[rk[i]-1];//注意：是rk[i]-1不是rk[i-1] 
		if(h>0)
		{
			h--;
		}
		while(j+h<=n&&i+h<=n)
		{
			if(a[j+h]!=a[i+h])
			{
				break;
			}
			h++;
		}
		ht[rk[i]]=h;
	}
}
```

## 总代码（后缀数组部分记得减一）。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
int rk[N],rk2[N],sa[N];
int n;
char s[N],d[N];
int a[N];
int vis[150];
int k;
bool cmp(int x,int y)
{
	if(rk[x]!=rk[y])
	{
		return rk[x]<rk[y];
	}
	int rx=(x+k<=n)?(rk[x+k]):(-1);
	int ry=(y+k<=n)?(rk[y+k]):(-1);
	return rx<ry;
}
void solve_sa()
{
	for(int i=1;i<=n;i++)
	{
		rk[i]=a[i];
		sa[i]=i;
	}
	for(k=1;k<=n;k*=2)
	{
		sort(sa+1,sa+n+1,cmp);
		rk2[sa[1]]=1;
		for(int i=2;i<=n;i++)
		{
			rk2[sa[i]]=rk2[sa[i-1]]+cmp(sa[i-1],sa[i]);
		}
		for(int i=1;i<=n;i++)
		{
			rk[i]=rk2[i];
		}
	}
}
int ht[N];
void solve_ht()
{
	for(int i=1;i<=n;i++)
	{
		rk[sa[i]]=i;
	}
	int h=0;
	//ht[1]=0//可以省略 
	for(int i=1;i<=n;i++)
	{
		int j=sa[rk[i]-1];//注意：是rk[i]-1不是rk[i-1] 
		if(h>0)
		{
			h--;
		}
		while(j+h<=n&&i+h<=n)
		{
			if(a[j+h]!=a[i+h])
			{
				break;
			}
			h++;
		}
		ht[rk[i]]=h;
	}
}
int tot;
void init();
int main()
{
	cin>>s+1;
	n=strlen(s+1);
	init();
	solve_sa();
	for(int i=1;i<=n;i++)
	{
		cout<<sa[i]-1<<' ';
	}
	solve_ht();
	cout<<'\n';
	for(int i=1;i<=n;i++)
	{
		cout<<ht[i]<<' ';
	}
	return 0;
}
void init()
{
	for(int i=1;i<=n;i++)
	{
		d[i]=s[i];
	}
	sort(d+1,d+n+1);
	for(int i=1;i<=n;i++)
	{
		if(d[i]!=d[i-1])
		{
			tot++;
		}
		vis[d[i]]=tot;
	}
	for(int i=1;i<=n;i++)
	{
		a[i]=vis[s[i]];
//		cout<<a[i]<<' ';
	}
//	exit(0);
}
```

因为蒟蒻在学习的时候遇到了许多的麻烦，踩了挺多坑的，学习还在初步阶段，如果有部分写错了，欢迎私信我。

希望本题解能帮到大家让大家少走点弯路！

---

## 作者：QQzhi (赞：2)

## 返朴归真法求后缀数组

既然题目希望我们使用快排、哈希与二分暴力求解，那么若先抛开标准做法不谈，我们该如何求后缀数组呢？

### $O(n\log^2n)$ 解法

先看看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wfh0dult.png)

可以发现本质上我们是要根据后缀字典序大小，排序好一份下标数组，~~朴素暴力做法 $O(n^2\log n)$ 完全不可接受~~。这里我们直接用 STL 排序函数加上自定义排序函数即可实现，后缀的最长公共前缀长度可采用二分法求解。

本题解将字符串读入为 $s[1...len]$，字符串长度为 $len$。

#### 字符串哈希部分

选取一个素数 $P$，拿到字符串后，递推计算字符串 $s$ 前 $i$ 位的哈希值 $h_i=h_{i-1}\cdot P+s_i$，并维护一份素数幂表。

由递推式反推即可得到 $s$ 任意区间 $[l,r]$ 的哈希值。

本题数据较小，手打简易哈希加上自然溢出取模就足以保证哈希可靠性。可实现 $O(1)$ 比较字符串两段异同。

```cpp
using ull=unsigned long long;
constexpr int P=233,N=3e5+2;
char s[N];int len=1;
namespace Hash{
	ull h[N],mul[N]={1};
	void init(){
		for (int i=1;i<=len;i++)
			h[i]=h[i-1]*P+s[i]-'0',mul[i]=mul[i-1]*P;
	}
	ull get(int l,int r){
		return h[r]-h[l-1]*mul[r-l+1];
	}
}
```

#### 后缀数组部分

**最长公共前缀 LCP 二分求解**

当我们要比较两个字符串时，只需要比较第一个不同的字符即可，因此每次比较字符串可以先二分计出最长公共前缀再比较，将单次比较由暴力 $O(n)$ 降到 $O(\log n)$。

计算机中，字符串以 $0$ 作为结尾，其一定比其他字符要小，我们在二分求解时将其纳入二分范围。查找时 $l$ 不断靠近两字符串中最长公共前缀的下界，每轮 $mid$ 均向 $l$ 移近，写二分时要注意区间关系。

需注意：本题解自下标为 $1$ 始存入字符串，后缀数组则以 $0$ 开始，后续比较等操作时需要转换一下。

**SA 与 Height 数组求解**

既然是用暴力方法做的题，就直接使用 STL 排序与二分 LCP 比较函数来求 SA 数组。STL 排序 $O(n\log n)$，单次比较 $O(\log n)$，故时间复杂度为 $O(n\log^2n)$，为总体时间复杂度最大贡献部分。

求 Height 数组这里提供两种方法：

第一种方法非常直接无脑，直接根据 $height_i=\operatorname{lcp}(sa_i,sa_{i-1})$ 求解。

第二种方法回归标准流程，再次回看上图，发现求得 SA 数组后，可以反求出 Rank 数组 $rk_{sa_i}=i$，Rank 数组 $rk[i...len]$ 依次储存 $s[i...len]$ 位于 SA 数组的下标。

这里需要一个引理：$height_{rk_i}\ge height_{rk_{i-1}}-1$，详情请看 [OI Wiki 对于该引理的证明](https://oi-wiki.org/string/sa/#on-%E6%B1%82-height-%E6%95%B0%E7%BB%84%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BC%95%E7%90%86)，或结合图例自行快速理解。优化后时间复杂度为 $O(n)$，但实际上对整体时间复杂度影响不大，本代码运行时间影响最大的仍为 SA 数组的强行暴力求解。

```cpp
namespace SA{
	int sa[N],height[N],rk[N];
	int lcp(int a,int b){
		int l=0,r=std::min(len-a,len-b)+1;
		while (l<r){
			int mid=(l+r)>>1;
			if (Hash::get(a+l,a+mid)==Hash::get(b+l,b+mid))
				l=mid+1;
			else
				r=mid;
		}
		return l;
	}
	bool cmp(int a,int b){
		int t=lcp(++a,++b);
		return s[a+t]<s[b+t];
	}
	void init(){
		Hash::init();
		std::iota(sa+1,sa+len+1,0);
		std::sort(sa+1,sa+len+1,cmp);
		for (int i=1;i<=len;i++)
			rk[sa[i]+1]=i;
		for (int i=1,k=0;i<=len;i++){
			if (rk[i]==1) continue;
			if (k) k--;
			while (s[i+k]==s[sa[rk[i]-1]+1+k])k++;
			height[rk[i]] = k;
		}
//		for (int i=2;i<=len;i++)
//			height[i]=lcp(sa[i]+1,sa[i-1]+1);
	}	
}
```

以上即为核心代码，输入输出部分略。

## 本题更优的做法

1. 采用倍增思想进行排序（虽然时间复杂度仍为 $O(n\log^2n)$，但常数远小于直接排序）
2. 采用计数排序与基数排序进行单次排序（将单次排序时间复杂度由 $O(n\log n)$ 降至 $O(n)$，总体为 $O(n\log n)$，已经相当优秀）。
3. ~~还有其他一些非常变态的 $O(n)$ 算法，参见国家队相关论文。~~
---
看完本文即可简单·快速·暴力 AC 本题（虽然复杂度依然爆炸，但本题时限两秒无所畏惧）。

---

## 作者：Hrz_OIer (赞：2)

## 后缀排序简单做法

**第一步：**
读取字符串 $s$，并预处理出 $s$ 的哈希前缀和与 $Base^n$。

**第二步：** 

对 $sa$ 数组进行排序，任意两个下标为开头的后缀字符串比较时，用 `get_h` 函数二分找到它们两最长公共前缀的长度，然后再比较最长公共前缀的后一个字母。

**第三步：**

输出 $sa$ 数组与 `get_h(sa[i],sa[i+1])`。

**分析**

`cmp` 函数调用 `get_h` 函数是 $O(\log n)$ 的，因此时间复杂度是 $O(n\log ^2n)$。

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long
const int N=3e5+10;
const int base=131;
char s[N];
int n;
ull h[N],B[N],sa[N];
ull gethash(int l,int r){return h[r]-h[l-1]*B[r-l+1];}
int get_h(int a,int b){
	int l=0,r=min(n-a,n-b)+1;
	while(l<r){
		int mid=(l+r+1)/2; 
		if(gethash(a,a+mid-1)==gethash(b,b+mid-1)) l=mid;
		else r=mid-1;}
	return l;}
bool cmp(int a,int b){
	int len=get_h(a,b);
	return s[a+len]<s[b+len];}
signed main(){
	cin>>(s+1);
	n=strlen(s+1);
	B[0]=1;
	for(int i=1;i<=n;i++)h[i]=h[i-1]*base+s[i];
	for(int i=1;i<=n;i++)B[i]=B[i-1]*base,sa[i]=i;
	sort(sa+1,sa+1+n,cmp);
	for(int i=1;i<=n;i++)cout<<sa[i]-1<<" ";
	cout<<"\n";
	for(int i=0;i<n;i++)
		cout<<get_h(sa[i],sa[i+1])<<" ";
	return 0;}
```
可练习提升[【模板】后缀排序](https://www.luogu.com.cn/problem/P3809)。

---

## 作者：Stone_Xz (赞：2)

## [传送门：P10469 后缀数组](https://www.luogu.com.cn/problem/P10469)

## 简要题意：

 - 本题可以看作两问：

> 给定一个长度为 $n$ 字符串 $S$，下标从 $0$ 至 $n - 1$。将 $S$ 的所有后缀（即截取 $i\sim n - 1$ 这段子串）按字典序排序后，假设排名为 $i$ 的后缀是从 $j$ 这个位置截取到 $n - 1$ 的，则数组 $sa_i = j$，求出 $sa$ 数组。

> 求出 $sa$ 数组之后，还有一个 $Height$ 数组，$Height_i$ 的值为：排名为 $i$ 的后缀与排名为 $i - 1$ 的后缀的最长公共前缀长度。$Height_1 = 0$。

## 分析：

1. 我们首先要求出 $sa$ 数组，一开始 $sa_i = i$ 即可，然后按每个后缀的字典序从小到大排序 $sa$ 数组，重点是如何排序。

2. 因为快排的时间复杂度已经 $O(n \log n)$ 了，快排中直接暴力比较两个后缀的字典序的话，单次比较时间复杂度就为 $O(n)$，显然会超时，考虑优化。

3. 两个字符串 $A$、$B$ 的字典序的比较可以看成：分别去掉他们的最长公共前缀后，它们的第一个字符进行比较。我们发现，$A$、$B$ 的最长公共前缀的长度 $len$ 具有单调性：$A$ 和 $B$ 比 $len$ 短的长度的前缀肯定一样，比 $len$ 长的长度的前缀肯定不一样，可以二分。但是比较两个前缀字符串的时间还是 $O(n)$，可以用哈希优化。这样快排中单次比较的时间优化为 $O(\log n)$，排序的总时间复杂度刚好是题目中的 $O(n \log^2 n)$，可以过。

4. 接下来是 $Height$ 数组的处理，要求排名为 $i$ 的后缀与排名为 $i - 1$ 的后缀的最长公共前缀长度。发现没？也要求两个字符串的最长公共前缀长度，前面说了，可以用二分 + 哈希实现 $O(\log n)$ 的求取时间，$Height$ 数组的处理总时间就为 $O(n \log n)$，轻松过掉。

5. 总时间复杂度：$O(n \log^2 n)$，具体实现看代码。

## 代码：

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;

const int N = 3e5 + 5, base = 13331;
string s;
int sa[N], n;
ull pw[N], hs[N];

ull get_hs(int l, int r)
{
	return hs[r] - hs[l - 1] * pw[r - l + 1];
}

bool cmp(int x, int y)
{
	int len_x = (n - x + 1); // 两个前缀的长度 
	int len_y = (n - y + 1);
	int lt = -1, rt = min(len_x, len_y) + 1;
	while(lt + 1 < rt)
	{
		int mid = (lt + rt) / 2;
		if(get_hs(x, x + mid - 1) == get_hs(y, y + mid - 1))
		// 如果 X 与 Y 的前 mid 个字符相同，说明它们的最长公共前缀长度 >= mid 
			lt = mid;
		else
			rt = mid;
	}
	return s[x + lt] < s[y + lt]; // 按字典序从小到大 
}

int main()
{
	cin >> s;
	n = s.size();
	s = "%" + s; // 注意下标必须从 1 开始
	pw[0] = 1;
	for(int i = 1; i <= n; i++)
	{
		hs[i] = hs[i - 1] * base + s[i];
		pw[i] = pw[i - 1] * base;
		sa[i] = i;                          // 记录 sa 数组
	}
	sort(sa + 1, sa + 1 + n, cmp);
	for(int i = 1; i <= n; i++)
		cout << sa[i] - 1 << " "; // 我们一开始让下标从 1 开始了，要 -1
	cout << "\n0 ";
	for(int i = 2; i <= n; i++) 
	// 求出 sa[i - 1] 和 sa[i] 两个后缀串的最长公共前缀长度 
	{
		int len_x = (n - sa[i - 1] + 1); // 两个字符串的长度 
		int len_y = (n - sa[i] + 1);
		int lt = -1, rt = min(len_x, len_y) + 1;
		while(lt + 1 < rt)
		{
			int mid = (lt + rt) / 2;
			if(get_hs(sa[i - 1], sa[i - 1] + mid - 1) == get_hs(sa[i], sa[i] + mid - 1))
			// 如果 X 与 Y 的前 mid 个字符相同，说明它们的最长公共前缀长度 >= mid 
				lt = mid;
			else
				rt = mid;
		}
		cout << lt << " ";
	}
	return 0;
}
```

---

## 作者：Limitless_lmw (赞：2)

先考虑如何求出 SA。

我们可以将每一个后缀存出来暴力 sort，字符串比较的复杂度是 $O(n)$ 的，所以总的是 $O(n^2\log n)$ 的复杂度，题目也说明了这道题需要 $O(n\log^2 n)$ 的复杂度，考虑优化。

题目提示了要使用快排、Hash 与二分。那么显然还是要有一个 sort 的 $\log$ 复杂度的，于是考虑从字符串比较的方向优化。

考虑 Hash，迎来了本题的难点：**如何用 Hash 值比较两个子串的大小**。

先用朴素方法比较，一位一位的去比较，相同继续比较下一位，否则直接比较出大小。这时想到 Hash 可以帮助我们快速判断两个子串是否相等，就可以使用二分快速找到第一位不一样的字符，再比较两个子串在这一位上的大小。

假设现在比较 $p$ 和 $q$ 两个后缀，每次二分时利用 Hash $O(1)$ 地判断 $p$ 到 $p+mid-1$ 与 $q$ 到 $q+mid-1$ 这两段是否相等，最终求出 $p$ 与 $q$ 两个后缀的最长公共前缀的长度（而这恰好是 Height），并比较第一个不相等的位置。

每次比较的复杂度是 $O(\log n)$，sort 的复杂度是 $O(n\log n)$，所以总的复杂度就是 $O(n\log^2 n)$。

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

using ull = unsigned long long;

string str;
ull base[300005];
ull pre[300005];
int SA[300005];
int Height[300005];

inline ull get_hash(int l,int r){
    return pre[r]-pre[l-1]*base[r-l+1];
}

inline bool cmp(int p, int q){
    int l = 0;
    int r=max(str.size()-p,str.size()-q);
    while(l<r){
        int mid=l+r+1>>1;
        if(get_hash(p,p+mid-1)==get_hash(q,q+mid-1)){
            l=mid;
        }else{
            r=mid-1;
        }
    }
    return str[p+l]<str[q+l];
}

inline int get_Height(int p, int q){
    int l = 0;
    int r=max(str.size()-p,str.size()-q);
    while(l<r){
        int mid=l+r+1>>1;
        if(get_hash(p,p+mid-1)==get_hash(q,q+mid-1)){
            l=mid;
        }else{
            r=mid-1;
        }
    }
    return l;
}

int main(){
    cin>>str;
    str.resize(str.size()+1);
    for(int i = str.size()-1; i>=1; i--) str[i]=str[i-1];
    str[0]='\0';
    base[1]=1145141ull;
    for(int i = 2; i<str.size(); i++){
        base[i]=base[i-1]*1145141ull;
    }
    for(int i = 1; i<str.size(); i++){
        pre[i]=pre[i-1]*1145141ull+str[i];
        SA[i]=i;
    }
    sort(SA+1,SA+str.size(),cmp);
    for(int i = 1; i<str.size(); i++) cout<<SA[i]-1<<' ';
    puts("");
    for(int i = 1; i<str.size(); i++){
        Height[i]=get_Height(SA[i],SA[i-1]);
    }
    for(int i = 1; i<str.size(); i++){
        cout<<Height[i]<<' ';
    }
    return 0;
}
```

---

## 作者：DrDuck (赞：1)

# 基本思路 #
过早的优化是万恶之源。

先考虑最无脑的方法。对于后缀的字典序排列，利用 `string` 自带的比较运算符，然后对于最长公共前缀，直接暴力一个个比对过去。

但是如果只是这么写，你将会得到 40 分的高分。

考虑进行优化。我们发现对于字符串直接的比对可以用哈希实现，所以在求最长公共前缀的时候，先预处理出原字符串各个子串的哈希值，然后对公共前缀的长度进行二分，比对所截取子串的哈希值就好了。可以写出如下代码。
```cpp
char s[maxn];
int f[maxn], g[maxn];
int len = 0;
void hs()//哈希模板
{
	g[0] = 1;
	for (int i = 1; s[i]; i++)
	{
		f[i] = f[i - 1] * base + s[i];
		g[i] = g[i - 1] * base;
		len++;
	}
}
int ret(int l, int r)//查询哈希值
{
	return f[r] - f[l - 1] * g[r - l + 1];
}
int lon(int psa, int psb)//二分找最长公共前缀
{
	int ans = 0;
	int l = 1;
	int r = len - max(psa, psb) + 1;
	while (l <= r)
	{
		int mid = (l + r) / 2;
		if (ret(psa, psa + mid - 1) == ret(psb, psb + mid - 1))
		{
			l = mid + 1;
			ans = mid;
		}
		else
		{
			
			r = mid - 1;
		}
	}
	return ans;
}
```
但是如果只是这样的话，在将后缀字符串排序的过程中还是会超时，考虑继续进行优化。

在比较两个字符串的字典序时，可以先用上面的方法求出最长公共前缀的长度，然后再比较两字符串最长公共前缀后一个字符的字典序就好了。比如你要比较 `abcde` 和 `abcdf` 的字典序，先求出最长公共前缀的长度为 4，然后再比对 `e` 和 `f`，发现 `e` 要小于 `f`，所以 `abcde` 的字典序要小于 `abcdf`。根据上述思路，给出以下代码。
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
const int base = 233;
const int maxn = 3e+5 + 5;
char s[maxn];
int f[maxn], g[maxn];
int len = 0;
void hs()
{
	g[0] = 1;
	for (int i = 1; s[i]; i++)
	{
		f[i] = f[i - 1] * base + s[i];
		g[i] = g[i - 1] * base;
		len++;
	}
}
int ret(int l, int r)
{
	return f[r] - f[l - 1] * g[r - l + 1];
}
int lon(int psa, int psb)
{
	int ans = 0;
	int l = 1;
	int r = len - max(psa, psb) + 1;
	while (l <= r)
	{
		int mid = (l + r) / 2;
		if (ret(psa, psa + mid - 1) == ret(psb, psb + mid - 1))
		{
			l = mid + 1;
			ans = mid;
		}
		else
		{
			
			r = mid - 1;
		}
	}
	return ans;
}
bool cmp(int a, int b)
{
	a++;
	b++;
	int ms = lon(a, b);
	return s[a + ms] < s[b + ms];
}
vector<int> sa;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> s + 1;
	hs();
	for (int i = 0; i < len; i++)
	{
		sa.push_back(i);
	}
	sort(sa.begin(), sa.end(), cmp);
	for (int i = 0; i < sa.size(); i++)
	{
		cout << sa[i] << " ";
	}
	cout << endl;
	cout << 0 << " ";
	for (int i = 1; i < sa.size(); i++)
	{
		int psa = sa[i] + 1;
		int psb = sa[i - 1] + 1;
		cout << lon(psa, psb) << " ";
	}
	cout << endl;
	return 0;
}
```
拒绝抄袭！

---

## 作者：Miracle_1024 (赞：1)

## 思路：
很明显的字符串哈希好吧。

实现方法大致为输入字符串 $s$，然后对 $s_x$ 与 $s_y$ 的最长公共前缀进行二分。


二分时结合一下哈希来比较 $s_x$ 到 $s_{x+mid}$ 和 $s_y$ 到 $s_{y+mid}$ 的前缀是否一样。其中 $x,y$ 为 cmp 中的参数，是需要进行比较的字符串首位下标。

这里的二分求的是两个串的最长公共前缀长度，在求高度时也可以用到。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define PII pair<ll,ll>
using namespace std;
const int N=1e6+10;
const int M=131;
const int INF=0x3f3f3f3f;
inline int read(){ll x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
ll h[N], p[N],a[N], n;
string s;
int Hash(ll l,ll r){
    return h[r]-h[l-1]*p[r-l+1];
}
int sumsub(ll x,ll y){
    ll l=0,r=min(n-x+1,n-y+1);
    while(l<r){
        ll mid=(l+r+1)>>1;
        if(Hash(x,x+mid-1)!=Hash(y, y+mid-1))r=mid-1;
        else l=mid;
    }
    return r;
}
bool cmp(ll x,ll y){
    ll l=sumsub(x,y),xx=x+l>n?-1e9:s[x+l],yy=y+l>n?-1e9:s[y+l];
    return xx<yy;
}
int main() {
    cin>>s;
    s=' '+s;
    n=s.size();
    p[0]=1;
    for(int i=1;i<=n;i++){
        h[i]=h[i-1]*M+s[i]-'a'+1;
        p[i]=p[i-1]*M;
        a[i]=i;
    }
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++)printf("%d%c", a[i]-1,i==n?'\n':' ');
    for(int i=2;i<=n;i++)printf("%d%c", sumsub(a[i], a[i-1]),i==n?'\n':' ');
}

```

---

## 作者：SilVeR__WolF (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10469)

## 题目大意

给定一个字符串 $S$（设其长度为 $n$，下标从 $1$ 开始）。第一问要求先将 $S$ 的全部后缀（用一个编号 $i$ 来表示一个后缀，此时该后缀为 $S_{i∼n},i=1,2,...,n$。前缀同理）按字典序排序后按顺序输出每个后缀的编号。第二问要求输出排序后相邻两个子串间的最长公共前缀长度。

## 题目思路

容易想出暴力思路：先用结构体将每一个后缀字串与其编号存储起来，然后使用结构体排序，最后暴力寻找相邻两个字符串间的最长公共前缀即可。但是这样做的时间复杂度约为 $O(n^2\log n+n^2)$，在本题 $n \le 3 \times 10^5$ 的情况下显然无法通过。

首先尝试优化第一问中的快排，由于需要比较两个字符串的大小，所以快排中每一次比较的时间复杂度为 $O(n)$，整个快排的时间复杂度就为 $O(n^2 \log n)$，怎么优化呢？当我们手动比较两个字符串时，我们会从两个字符串的第一位开始比较，如果第一位不同就可以结束了，但如果第一位相同就需要继续比较第二位，以此类推，直到第 $i$ 位不同时停止比较。此时，两个字符串的前 $i-1$ 位应当是相同的。换句话说，只要找到了这两个字符串的最长公共前缀长度 $k$，就可以直接比较第 $k+1$ 个字符。于是我们将每一次比较两个字符串的大小转换为了寻找这两个字符串的最长公共前缀长度，也就是第二问的任务。

现在需要优化的事情变成了寻找两个字符串的最长公共前缀。可以从题面中给的复杂度入手：$O(n \log^2 n)$，再配合上题面中给的算法：快排、二分、哈希。问题就解决了：对于两个字符串，二分最长公共前缀长度（证明单调性：假设最长公共前缀长度为 $x$，则对于 $y \le x$，一定有两个字符串的前 $y$ 位相同；对于 $z > x$，一定有两个字符串的前 $z$ 位不同），对于每一次的 $mid$，利用哈希计算两个字符串的前 $mid$ 位的哈希值是否相同。若相同，则扩大二分范围；若不同，则缩小二分范围。这样就可以在 $O(\log n)$ 的时间复杂度下找出两个字符串的最长公共前缀长度。

其余细节见代码注释。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=300005,P=131;
string s;
int len,h1[N],mul[N],sa[N];
int get(int l,int r){
	return h1[r]-h1[l-1]*mul[r-l+1];
}
int longest_sub(int a,int b){
	int l=0,r=min(len-a+1,len-b+1);
	while(l<r){//注意是靠右查找
		int mid=(l+r+1)>>1;
		if(get(a,a+mid-1)==get(b,b+mid-1))	l=mid;
		else	r=mid-1;
	}
	return l;
}
bool cmp(int a,int b){
	int pos=longest_sub(a,b);
	return s[a+pos]<s[b+pos];
}
signed main(){
	cin>>s;
    len=s.size();
	s=" "+s;//做对齐处理
    s=s+char(10);//当一个字符串包含另一字符串时，函数cmp中会出现越界，由于此时应判定为被包含的字符串字典序小，所以这里需要在s末尾添加一个比小写字母都小的字符，等同于在被包含的字符串后添加了一个比小写字母都小的字符。
	mul[0]=1;
	for(int i=1;i<=len;i++){//字符串哈希预处理
		sa[i]=i;
		h1[i]=h1[i-1]*P+s[i];
		mul[i]=mul[i-1]*P;
	}
	sort(sa+1,sa+len+1,cmp);
	for(int i=1;i<=len;i++)	cout<<sa[i]-1<<" ";//由于我们的下标从1开始，所以此处需要-1
	cout<<"\n";
	for(int i=1;i<=len;i++){
		if(i==1)	cout<<0<<" ";
		else	cout<<longest_sub(sa[i],sa[i-1])<<" ";
	}
	return 0;
}
```

---

## 作者：W_Sibo (赞：1)

笑纳蒟蒻的第一篇题解

# 题目：P10469 后缀数组
[题目链接](https://www.luogu.com.cn/problem/P10469)

### solution：
我们发现，$S$ 的所有后缀的总长度在 $O(n^{2})$ 级别。
如果我们直接对这 $n$ 个后缀进行快排，对于两个字符串的大小比较采取逐字符扫描的方式，最坏情况下时间复杂度将达到 
$O(n^{2}logn)$。这肯定会导致 TLE。

我们可以通过前缀哈希在 $O(1)$ 时间内查询任意一个子串的 hash 值。我们可以使用快速排序比较两个后缀 $p$，$q$ 时，使用二分法，每次利用二分查找 $s_{p  ,p+mid-1}$ 与 $s_{q,q+mid-1}$ 是否相等。求得公共前缀后，下一个字符的比较就可以反应出字典序大小关系。

单次比较时间复杂度：$O(\log{n})$

总体时间复杂度：$O(n\log^{2}{n})$

下面是 AC code：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N=3e5+5;
ull n,p[N],h[N],k[N];
string s;
int gmcp(int a,int b){//二分查找公共前缀长度
	int l=0,r=n-max(a,b)+1,mid;
	while(l<r){
		mid=(l+r+1)>>1;
		if((h[a+mid-1]-h[a-1]*p[mid])==(h[b+mid-1]-h[b-1]*p[mid])){
			l=mid;
		}else{
			r=mid-1;
		}
	}
	return l;
}
bool cmp(int a,int b){
	int l=gmcp(a,b);
	int av=a+l>n?-1:s[a+l];//如果下一个字符位置为空，则令其为-1，一定会被排在前面。
	int bv=b+l>n?-1:s[b+l];
	return av<bv; 
}
int main(){
	cin>>s;
	n=s.length();
	s=' '+s;//空出最开头的0位置
	p[0]=1;
	for(int i=1;i<=n;i++){
		p[i]=p[i-1]*29;//质数选择29，29的倍数
		h[i]=h[i-1]*29+s[i]-'a';//hash计算
		k[i]=i;//k存储的是某一个后缀的开始的位置
	}
	sort(k+1,k+n+1,cmp);//排序
	for(int i=1;i<=n;i++){
		cout<<k[i]-1<<' ';//因为i从一开始，所以减一
	}
	cout<<"\n0";//规定第一项为0
	for(int i=2;i<=n;i++){
		cout<<' '<<gmcp(k[i],k[i-1]);//两个相邻字符串前缀长度
	} 
} 
```
thanks！

---

## 作者：MoonCake2011 (赞：1)

简单题。

# Part 1

首先，对于第一个问，考虑倍增。

我们倍增 $\lceil \log n\rceil$ 轮。

第 $i$ 轮结束后代表已经对一个位置后 $2^i$ 位排好序了。

所以结束后，就有想要的结果了。

设 $rk_i$ 为第 $i$ 个后缀所对应的排名。

由此可见，最后的时候 $rk_{sa_i}=sa_{rk_i}=i$。

但在中间排序的时候，$rk$ 可能相同，因为这些串有可能完全相同。

每次怎么排序 $sa$ 呢。

第 $x$ 个位置可以以 $[x,x+2^{i-1}-1]$ 与 $[x+2^{i-1},x+2^i-1]$，其中 $i$ 为轮数。

也就是通过 $rk_x$ 与 $rk_{x+2^{i-1}}$ 双关键字排序。

通过这个序排来的 $sa$ 即正确。

然后我们继续求下一轮的 $rk$。

首先 $sa$ 已经排过序了。

所以按 $sa$ 的顺序来，就只用判重了。

判重也简单呀，那就是 $rk_x$ 与 $rk_{x+2^{i-1}}$ 双关键字完全等于 $rk_y$ 与 $rk_{y+2^{i-1}}$ 双关键字。

于是就做完了。

代码。

```cpp
int sa[600010],rk[600010],o[600010],n,w;//开两倍的原因是有可能出现越一倍界的情况（相当于空与有值比较），这样才能分出长短 
inline bool cmp(int x,int y){//双关键字排序
	if(rk[x]==rk[y]) return rk[x+w]<rk[y+w];
	return rk[x]<rk[y];
}
inline void binary(){
	for(int i=1;i<=n;i++) sa[i]=i,rk[i]=s[i];
	for(w=1;w<n;w<<=1){//枚举 2^(i-1)
		sort(sa+1,sa+n+1,cmp);//先排一遍 
		memcpy(o,rk,sizeof o);//记录以前的 rk，防止被修改 
		for(int p=0,j=1;j<=n;j++)
			if(o[sa[j]]==o[sa[j-1]] && o[sa[j]+w]==o[sa[j-1]+w]) rk[sa[j]]=p;//判重 
			else rk[sa[j]]=++p;//下一排名 
	}
	for(int i=1;i<=n;i++) printf("%d ",sa[i]-1);//输出 
	cout<<"\n";
}
```

# Part 2

Height 数组，相邻两个后缀的最长公共前缀。

LCP，直接考虑 Hash。

通过 Hash 与 倍增的方法直接可以比较了。

二分最长公共前缀的长度，用哈希 $O(1)$ 比较。

```cpp
unsigned int sp[600010],q[600010];
inline void Hash(){
	q[0]=1;
	for(int i=1;i<=n;i++) q[i]=q[i-1]*131,sp[i]=sp[i-1]*131+s[i];
}
inline unsigned int get(int l,int r){
	return sp[r]-sp[l-1]*q[r-l+1];
}
int h[600010];
inline void height(){
	h[1]=0;
	for(int i=2;i<=n;i++){
		int x=sa[i-1],y=sa[i];//相邻后缀
		int len=max(n-x+1,n-y+1);//长度 
		int p=0;
		for(int j=30;j>=0;j--){//倍增 
			if(p+(1<<j)-1>len) continue;
			if(get(x,x+p+(1<<j)-1)==get(y,y+p+(1<<j)-1)) p+=(1<<j);//一样就直接加 
		}
		h[i]=p;
	}
	for(int i=1;i<=n;i++) printf("%d ",h[i]);
}
```
# Part EX

SA 可以解决 [AC](https://www.luogu.com.cn/problem/P5357) 问题。

并且是在线的。

先求 $S$ 的 $SA$ 数组。

然后每次在 $SA$ 上二分进行比较，这样二次二分可以得出 $T$ 在所有后缀上的出现次数，也就是在原串中出现次数。

比较用二分哈希比较。

可以简单的做出。

---

## 作者：CommandSR (赞：1)

## 题意简化

给定一个字符串，将其所有后缀按字典序排序，输出排名为 $i$ 的后缀，以及排名相邻两个后缀的公共前缀长度。

## 基本思路：二分+哈希

首先，我们记 $id_i$ 为排名为 $i$ 的后缀的起始位置。

显然，需要一个比较两个后缀的函数。

### cmp 函数

显然，按字典序比较两个后缀，需要找到他们从左到右第一个不相同的位置，再进行 $O(1)$ 的比较。

你会说 STL 有更简单的方法，但这方便我们统计 $height$ 数组。

```cpp
bool cmp(int x, int y)
{
	int pos = getPos(x, y);
	return s[x + pos] < s[y + pos];
}
```

### getPos 函数

这个函数用于返回两个字符串第一个不同的位置。

显然，我们可以二分+哈希。

二分目标位置，如果当前区间内两字符串对应的哈希值不同，就将右端点左移尝试更短的区间，反之将左端点右移尝试更长的区间。

这个函数也可以轻松得到第二问 $height$ 数组。

```cpp
int getPos(int x, int y)
{
	int l = 0, r = min(n-x+1, n-y+1) + 1, mid;
	while (l + 1 < r)
	{
		mid = (l + r) >> 1;
		if (getHash(x, x+mid-1) == getHash(y, y+mid-1)) 
			l = mid;
		else 
			r = mid;
	}
	return l;
}
```

### 字符串哈希

这里不多加阐述，如果不会请先完成模板题 [P3370](https://www.luogu.com.cn/problem/P3370) 再来研究此题。

```cpp
void init()
{
	p[0] = 1;
	for (int i = 1; i <= n; i++)
	{
		p[i] = p[i-1] * K;
		val[i] = val[i-1] * K + s[i];
		id[i] = i;
	}
}
int getHash(int l, int r)
{
	return val[r] - val[l-1] * p[r-l+1];
}
```

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
const int N = 300010;
const int K = 13331;
string ss;
int n;
int s[N];
int p[N], val[N];
int id[N];
void init()
{
	p[0] = 1;
	for (int i = 1; i <= n; i++)
	{
		p[i] = p[i-1] * K;
		val[i] = val[i-1] * K + s[i];
		id[i] = i;
	}
}
int getHash(int l, int r)
{
	return val[r] - val[l-1] * p[r-l+1];
}
int getPos(int x, int y)
{
	int l = 0, r = min(n-x+1, n-y+1) + 1, mid;
	while (l + 1 < r)
	{
		mid = (l + r) >> 1;
		if (getHash(x, x+mid-1) == getHash(y, y+mid-1)) 
			l = mid;
		else 
			r = mid;
	}
	return l;
}
bool cmp(int x, int y)
{
	int pos = getPos(x, y);
	return s[x + pos] < s[y + pos];
}
signed main() 
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> ss;
	n = ss.length();
	for (int i = 1; i <= n; i++)
		s[i] = ss[i-1];
	init();
	sort(id + 1, id + 1 + n, cmp);
	for (int i = 1; i <= n; i++) 
		cout << id[i] - 1 << ' ';
	cout << '\n';
	for (int i = 1; i <= n; i++) 
		cout << getPos(id[i-1], id[i]) << ' ';
	cout << '\n';
	return 0;
}
```

---


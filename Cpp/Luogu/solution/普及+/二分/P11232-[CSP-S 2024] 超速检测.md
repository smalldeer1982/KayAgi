# [CSP-S 2024] 超速检测

## 题目描述

小 D 新入职了某国的交管部门，他的第一个任务是负责国家的一条长度为 $L$ 的南北主干道的车辆超速检测。为了考考小 D，上司首先需要他解决一个简化的场景。

这个周末，主干道上预计出现 $n$ 辆车，其中第 $i$ 辆车从主干道上距离最南端 $d_i$ 的位置驶入，以 $v_i$ 的初速度和 $a_i$ 的加速度做匀加速运动向北行驶。我们只考虑从南向北的车辆，故 $v_i > 0$，但 $a_i$ 可正可负，也可以为零。当车辆行驶到主干道最北端（即距离最南端为 $L$ 的位置）或速度降为 $0$（这只可能在 $a_i < 0$ 时发生）时，我们认为该车驶离主干道。

主干道上设置了 $m$ 个测速仪，其中第 $j$ 个测速仪位于主干道上距离最南端 $p_j$ 的位置，每个测速仪可以设置开启或关闭。当某辆车经过某个开启的测速仪时，若这辆车的瞬时速度**超过**了道路限速 $V$，那么这辆车就会被判定为超速。注意当车辆驶入与驶出主干道时，如果在对应位置有一个开启的测速仪，这个测速仪也会对这辆车进行测速。

上司首先想知道，如果所有测速仪都是开启的，那么这 $n$ 辆车中会有多少辆车被判定为超速。

其次，为了节能，部门想关闭一部分测速仪。然而，他们不希望漏掉超速的车，也就是说，当 $n$ 辆车里的某辆车在所有测速仪都开启时被判定为超速，他们希望在关闭一部分测速仪以后它依然被判定为超速。上司还想知道在这样的条件下最多可以关闭多少测速仪。

由于 $n$ 很大，上司允许小 D 使用编程解决这两个问题，于是小 D 找到了你。

如果你对于加速度并不熟悉，小 D 贴心地在本题的“提示”部分提供了有关加速度的公式。

## 说明/提示

**【样例 1 解释】**

在该组测试数据中，主干道长度为 $15$，限速为 $3$，在距离最南端 $2, 5, 8, 9, 15$ 的位置各设有一个测速仪。
- 第一辆车在最南端驶入，以 $3$ 的速度匀速行驶。这辆车在整个路段上都没有超速。
- 第二辆车在距离最南端 $12$ 的位置驶入，以 $4$ 的速度匀速行驶。在最北端驶离主干道时，它会被距离最南端 $15$ 的测速仪判定为超速。
- 第三辆车在距离最南端 $1$ 的位置驶入，以 $1$ 的初速度、$4$ 的加速度行驶。其在行驶了 $\frac{3^2-1^2}{2\times 4}=1$ 的距离，即到达 $2$ 的位置时，速度变为 $3$，并在之后一直超速。因此这辆车会被除了距离最南端 $2$ 的测速仪以外的其他测速仪判定为超速。
- 第四辆车在距离最南端 $5$ 的位置驶入，以 $5$ 的初速度、$-2$ 的加速度行驶。其在行驶了 $\frac{3^2-5^2}{2\times (-2)}$ 的距离，即到达 $9$ 的位置时，速度变为 $3$。因此这辆车在距离最南端 $[5, 9)$ 时超速，会被距离最南端 $5$ 和 $8$ 的两个测速仪判定为超速。
- 第五辆车在距离最南端 $6$ 的位置驶入，以 $4$ 的初速度、$−4$ 的加速度行驶。在其行驶了 $\frac{3^2-4^2}{2\times (-4)}=\frac{7}{8}$ 的距离后，即这辆车到达 $6\frac{7}{8}$ 的位置时，其速度变为 $3$。因此这辆车在距离最南端 $[6,6\frac{7}{8})$ 时超速，但这段区间内没有测速仪，因此不会被判定为超速。

因此第二、三、四辆车会被判定为超速，输出的第一个数为 $3$。

我们可以关闭距离最南端 $2, 8, 9$ 的三个测速仪，保留 $5$ 和 $15$ 的两个测速仪，此时三辆之前被判定为超速的车依然被判定为超速。可以证明不存在更优方案，因此输出的第二个数为 $3$。

**【样例 2】**

见选手目录下的 detect/detect2.in 与 detect/detect2.ans。

该组样例满足 $n, m \leq 10$。

**【样例 3】**

见选手目录下的 detect/detect3.in 与 detect/detect3.ans。

该组样例满足特殊性质 A，其中前十组测试数据满足 $n, m \leq 3000$。

**【样例 4】**

见选手目录下的 detect/detect4.in 与 detect/detect4.ans。

该组样例满足特殊性质 B，其中前十组测试数据满足 $n, m \leq 3000$。

**【样例 5】**

见选手目录下的 detect/detect5.in 与 detect/detect5.ans。

该组样例满足特殊性质 C，其中前十组测试数据满足 $n, m \leq 3000$。

**【数据范围】**

对于所有测试数据，保证：

- $1 \leq T \leq 20$；
- $1 \leq n, m \leq 10^5$，$1 \leq L \leq 10^6$，$1 \leq V \leq 10^3$；
- $0 \leq d_i < L$，$1 \leq v_i \leq 10^3$，$|a_i| \leq 10^3$；
- $0 \leq p_1 < p_2 < \dots < p_m \leq L$。

::cute-table{tuack}

| 测试点 | $n,m\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | 无 |
| $2$ | $20$ | ^ |
| $3$ | $3000$ | A |
| $4$ | $10^5$ | ^ |
| $5$ | $3000$ | B |
| $6$ | $10^5$ | ^ |
| $7$ | $3000$ | C |
| $8$ | $10^5$ | ^ |
| $9$ | $3000$ | 无 |
| $10$ | $10^5$ | ^ |

特殊性质 A：保证 $a_i = 0$。

特殊性质 B：保证 $a_i > 0$。

特殊性质 C：保证 $a_i < 0$，且所有车都不在最北端驶离主干道。

**【提示】**

与加速度有关的定义和公式如下：

- 匀加速运动是指物体在运动过程中，加速度保持不变的运动，即每单位时间内速度的变化量是恒定的。
- 当一辆车的初速度为 $v_0$、加速度 $a\neq 0$，做匀加速运动，则 $t$ 时刻后它的速度 $v_1 = v_0 + a \times t$，它的位移（即行驶路程）$s=v_0\times t+0.5\times a\times t^2$。
- 当一辆车的初速度为 $v_0$、加速度 $a \neq 0$，做匀加速运动，则当它的位移（即行驶路程）为 $s$ 时，这辆车的瞬时速度为 $\sqrt{v_0^2+2\times a\times s}$。
- 当一辆车的初速度为 $v_0$、加速度 $a \neq 0$，在它的位移（即行驶路程）为 $\frac{v_1^2-v_0^2}{2a}$ 时，这辆车的瞬时速度为 $v_1$。

如果你使用浮点数进行计算，需要注意潜在的精度问题。

## 样例 #1

### 输入

```
1
5 5 15 3
0 3 0
12 4 0
1 1 4
5 5 -2
6 4 -4
2 5 8 9 15```

### 输出

```
3 3```

# 题解

## 作者：szh_AK_all (赞：90)

通过了民间数据。

首先对于每辆车，能够判定它为超速的测速仪肯定是一段区间，如果这段区间不在 $1\sim m$ 的范围内，则这辆车不会被判定为超速。否则，我们可以将这段区间看成一个限定条件，即我们在所选出来的测速仪中，对于每一个限定条件 $l_i,r_i$，至少有一个测速仪（假设这个测速仪的位置为 $x$）满足 $l_i\le x\le r_i$，并且我们希望选出来的测速仪尽可能少。

下面进行分类讨论，得出限定区间。

对于每个车子 $i$，其超速情况分为以下两种：

- 当 $a_i>0$ 时，若 $v_i>V$，则这辆车在一开始就超速了，那么限定区间的左端点即为满足 $p_j>d_i$ 的最小的 $j$；否则，根据公式，这辆车驶入 $d_i+\frac{V^2-v_i^2}{2a_i}$ 这个位置时，其速度会到达 $V$，那么限定区间的左端点即为满足 $p_j>d_i+\frac{V^2-v_i^2}{2a_i}$ 的最小的 $j$。而以上情况的区间右端点显然都为 $m$，因为车子的速度是单调递增的。

- 当 $a_i\le 0$ 时，若 $v_i\le V$，则代表这辆车的速度永远都不会超过 $V$，所以这辆车不会被判定为超速；反之则代表 $v_i>V$，限定区间的左端点即为满足 $p_j>d_i$ 的最小的 $j$，再根据公式，二分出最大的满足 $\sqrt{v_i^2+2a_i\times(p_k-d_i)}>V$ 的 $k$，作为限定区间的右端点。

接下来考虑如何选出最少的点使得对于每个限定区间，至少有一个测速仪在该区间内。

首先将所有区间以左端点为第一关键字、右端点为第二关键字排序（左端点按照从小到大的顺序，右端点按照从大到小的顺序排序）。对于两个区间 $[l_i,r_i]$ 及 $[l_j,r_j]$，若 $l_i\le l_j,r_i\ge r_j$，那么 $[l_i,r_i]$ 这个区间是没有用的，因为一个点若在 $[l_j,r_j]$ 内，它也必定在 $[l_i,r_i]$ 内，所以对于这样的区间，是可以不考虑的。

那么在处理之后就满足所有区间的左端点、右端点都是按照升序排序的，再每次贪心的选当前区间的右端点，覆盖到不能覆盖的区间为止。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005], d[100005], v[100005], p[100005];
int del[100005];

struct node {
	int ql, qr;
	friend bool operator<(node l, node r) {
		if (l.ql != r.ql)
			return l.ql < r.ql;
		return l.qr > r.qr;
	}
} s[100005];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int t;
	cin >> t;
	while (t--) {
		int n, m, L, V;
		cin >> n >> m >> L >> V;
		for (int i = 1; i <= n; i++)
			cin >> d[i] >> v[i] >> a[i];
		for (int i = 1; i <= m; i++)
			cin >> p[i];
		int tot = 0;
		for (int i = 1; i <= n; i++) {
			if (a[i] <= 0 && v[i] <= V)
				continue;
			if (a[i] > 0) {
				int wei = V * V - v[i] * v[i];
				wei /= (2 * a[i]);
				wei += d[i];
				if (v[i] > V)
					wei = d[i] - 1;
				int l = 1, r = m, ans = 0;
				while (l <= r) {
					int mid = (l + r) / 2;
					if (p[mid] > wei) {
						r = mid - 1;
						ans = mid;
					} else
						l = mid + 1;
				}
				if (!ans)
					continue;
				s[++tot].ql = ans, s[tot].qr = m;
			} else {
				int l = 1, r = m, pos = 0;
				while (l <= r) {
					int mid = (l + r) / 2;
					if (p[mid] >= d[i]) {
						r = mid - 1;
						pos = mid;
					} else
						l = mid + 1;
				}
				if (!pos)
					continue;
				l = pos, r = m;
				int ans = 0;
				while (l <= r) {
					int mid = (l + r) / 2;
					double su = sqrt(v[i] * v[i] * 1.0 + 2.0 * a[i] * (p[mid] - d[i]));
					if (su > V) {
						l = mid + 1;
						ans = mid;
					} else
						r = mid - 1;
				}
				if (ans < pos)
					continue;
				s[++tot].ql = pos, s[tot].qr = ans;
			}
		}
		sort(s + 1, s + tot + 1);
		int mr = 1000000000;
		for (int i = tot; i >= 1; i--) {
			if (mr <= s[i].qr)
				del[i] = 1;
			mr = min(mr, s[i].qr);
		}
		int ans = 0, fu = 0;
		for (int i = 1; i <= tot; i++) {
			if (del[i]) {
				del[i] = 0;
				continue;
			}
			if (fu < s[i].ql) {
				ans++;
				fu = s[i].qr;
			}
		}
		cout << tot << " " << m - ans << "\n";
	}
}
```

---

## 作者：chenxi2009 (赞：46)

**Upd 2024.12.11：修正一处公式错误。**\
**Upd 2025.7.23: 做了一些修改，调整观感。**
## 思路
显然每辆车要么不超速，要么超速在一段连续的区间。二分查找在该区间左端点右侧的第一个测速仪，检查它是否在区间之内就可以判断此车是否超速。

再写一个二分找在区间右端点左侧的第一个测速仪，对于这辆车我们要在这两个测速仪之间（含）的所有测速仪中保留至少一个。参考[一道贪心经典题目](https://www.luogu.com.cn/problem/P1250)，这道题甚至还更加简单，已经告诉了你要保留一个。于是就可以 AC 了。
### 细节实现
**注：本文分类讨论在边界条件下可能出现区间表示仅含一个元素的情况，鉴于其不影响程序实现，请忽略。**
#### 求超速区间
唯一需要用到的物理公式如下：
$$
\Delta x=\frac{v^2-v_0^2}{2a}
$$
表达了一段匀变速直线运动中位移 $\Delta x$、初速度 $v_0$、末速度 $v$ 和加速度 $a$ 的关系。\
顺着特殊性质来思考，我们可以分三种情况讨论：
##### 匀速运动：$a_i=0$
- 若 $v_i\le V$，此车没有超速。
- 若 $v_i>V$，此车从进入干道起超速，超速区间为 $[d_i,L]$。
##### 匀加速运动：$a_i>0$
- 若 $v_i>V$，此车从进入干道起一直超速，超速区间为 $[d_i,L]$。
- 若 $v_i\le V$，令 $x=d_i+\frac{V^2-{v_i}_0^2}{2a_i}$，此车在 $x$ 处速率升至 $V$。于是再分情况：\
若 $x>L$，该车驶出干道前没有超速。\
若 $x\le L$，该车超速区间为 $(x,L]$。
##### 匀减速运动：$a_i<0$
- 若 $v_i\le V$，此车没有超速。
- 若 $v_i>V$，令 $x=d_i+\frac{V^2-{v_i}_0^2}{2a_i}$，此车在 $x$ 处速率降至 $V$。于是再分情况：\
若 $x>L$，此车在驶出前一直超速，超速区间为 $[d_i,L]$。\
若 $x\le L$，此车在 $x$ 前超速，区间表示为 $[d_i,x)$。
#### 存储超速区间
如果要用整型存储，可以用一个 bool 变量存储区间左右的开闭，适当向上向下取整即可。二分时注意开闭。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int l,r;
};
int T,n,m,len,mv,d[100001],v[100001],a[100001],p[100001],ans,cnt,las;
node dtc[100001];
bool cmp(node a,node b){
	return a.r != b.r ? a.r < b.r : a.l < b.l;
}
inline void input(){
	scanf("%d%d%d%d",&n,&m,&len,&mv);
	for(int i = 1;i <= n;i ++) scanf("%d%d%d",&d[i],&v[i],&a[i]);
	for(int i = 1;i <= m;i ++) scanf("%d",&p[i]);
}
inline void pre(){
	ans = cnt = las = 0;
	memset(dtc,0,sizeof(dtc));
}
int main(){
	scanf("%d",&T);
	while(T --){
		pre();
		input();
		for(int i = 1;i <= n;i ++){
			int ls,rs;//区间端点 
			bool zk,yk;//区间端点是否为开 
			if(a[i] > 0){
				rs = len,yk = false;//加速度大于零且超速时，右端一定为干道终点 
				if(v[i] >= mv){
					ls = d[i],zk = (v[i] == mv);//速度相等，则出发之后才超速 
				}
				else if(d[i] + ((mv * mv - v[i] * v[i]) + 2 * a[i] - 1) / (2 * a[i]) > len)continue;//结尾之后才超速 
				else{
					ls = d[i] + ((mv * mv - v[i] * v[i]) + 2 * a[i] - 1) / (2 * a[i]);//此区间左开，所以可以向上取整，如果有取整就要闭合 
					zk = (ls == d[i] + (mv * mv - v[i] * v[i]) / (2 * a[i])); 
				}
			}
			else if(a[i] == 0){
				if(v[i] <= mv)continue;
				zk = yk = false,ls = d[i],rs = len;
			}
			else{
				if(v[i] <= mv)continue;
				ls = d[i],zk = false;
				if(d[i] + (mv * mv - v[i] * v[i]) / (2 * a[i]) >= len)rs = len,yk = false;//右开，向下取整；全程超速
				else{//到了这个位置就不超速了，但是需要判断区间是否开：速度到这里刚好降为零就是开 
					rs = d[i] + (mv * mv - v[i] * v[i]) / (2 * a[i]);
					yk = !((v[i] * v[i] - mv * mv) % (2 * a[i]));
				} 
			}
			int lp = 1,rp = m,mid;
			while(lp < rp){//左侧二分 
				mid = lp + rp >> 1;
				if(p[mid] > ls || p[mid] == ls && !zk)rp = mid;//二分时判断端点是否为开 
				else lp = mid + 1;
			}
			if(p[lp] < ls || p[lp] == ls && zk || p[lp] > rs || p[lp] == rs && yk)continue;//未被检测到超速 
			dtc[++ ans].l = lp; 
			lp = 1,rp = m;
			while(lp < rp){//右侧二分 
				mid = lp + rp + 1 >> 1;
				if(p[mid] < rs || p[mid] == rs && !yk)lp = mid;
				else rp = mid - 1;
			}
			dtc[ans].r = lp;
		}
		printf("%d ",ans);
		sort(dtc + 1,dtc + ans + 1,cmp);//贪心 
		for(int i = 1;i <= ans;i ++){
			if(dtc[i].l <= las) continue;
			las = dtc[i].r;
			cnt ++;
		}
		printf("%lld\n",m - cnt); 
	}
	return 0; 
}
```
## 总结
主要考察二分和贪心法，码量及实现难度不算太大；但是解题或需一些高中物理思维，对于低龄选手难度会增大。

---

## 作者：wmrqwq (赞：46)

# 题目链接

[[CSP-S 2024] 超速检测](https://www.luogu.com.cn/problem/P11232)

# 解题思路

感觉写完三个特殊性质就会满分了。

由于初始速度，加速度均确定，那么容易看出对于每辆汽车，他们的行驶速度都是单调不增或单调不降的。

因此容易得出超速的区间是连续的一段区间。

因此我们可以二分出是否有合法的区间。

这样就完成了第一问。

考虑第二问，我们发现可以把超速的这个区间转化成可以检测出这个汽车超速的左右端点。

发现我们可以再次二分得出这段区间的左右端点。

此时第二问就转化成了有 $n$ 条线段，至少选择即可端点才能使得每段区间都至少包含一个点。

这个问题类似于线段覆盖。

  我们考虑先将右端点从小到大排序，然后如果此时线段内没有端点，那么我们就可以选取这个右端点，发现这样一定是最优的，于是我们依次选取右端点优先队列维护即可。

时间复杂度 $O(Tn \log n)$。

# 参考代码

```cpp
/*

time:2024/10/19

contest : https://codeforces.com/contests/2024

Tips:

你数组开小了吗？
你 MLE 了吗？
你觉得是贪心，是不是该想想 dp？
一个小时没调出来，是不是该考虑换题？
打 cf 不要用 umap！！！

记住，rating 是身外之物。

该冲正解时冲正解！

Problem:

如果你会：
 取模取了吗？
 算法对拍了吗？
 有没有保留小数据的暴力？
 有没有清空？
 精度够吗？
 时间复杂度真的正确嘛？
 会不会炸空间？
 最大数据会不会炸？
 自己造数据！

如果你不会：
 有没有想最低分的dp？ dp 也是一种暴力
 会不会写暴力分？
 暴力能否优化？
 暴力打表看看有没有非常明显的规律，有的黑题的规律就是cout<<N*N;
 能否分块暴力？
 有没有想最低分的dp？
 那个dp能否优化？
 不要往深的地方思考，想浅一点多想点

冷静冷静再冷静！

对拍对拍再对拍！

思路：

*/
#include<bits/stdc++.h>
using namespace std;
//#define map unordered_map
#define re register
#define ll long long
#define forl(i,a,b) for(re ll (i)=(a);i<=(b);(i)++)
#define forr(i,a,b) for(re ll (i)=(a);i>=(b);(i)--)
#define forll(i,a,b,c) for(re ll (i)=(a);i<=(b);(i)+=(c))
#define forrr(i,a,b,c) for(re ll (i)=(a);i>=(b);(i)-=(c))
#define forL(i,a,b,c) for(re ll (i)=(a);((i)<=(b)) && (c);(i)++)
#define forR(i,a,b,c) for(re ll (i)=(a);((i)>=(b)) && (c);(i)--)
#define forLL(i,a,b,c,d) for(re ll (i)=(a);((i)<=(b)) && (d);(i)+=(c))
#define forRR(i,a,b,c,d) for(re ll (i)=(a);((i)>=(b)) && (d);(i)-=(c))
#define pii pair<ll,ll>
#define mid ((l+r)>>1)
#define lowbit(x) (x&-x)
#define pb push_back
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl '\n'
#define QwQ return 0;
#define db long double
#define ull unsigned long long
#define lcm(x,y) (1ll*(x)/__gcd(x,y)*(y))
#define Sum(x,y) (1ll*((x)+(y))*((y)-(x)+1)/2)
#define x first
#define y second
#define aty cout<<"Yes\n";
#define atn cout<<"No\n";
#define cfy cout<<"YES\n";
#define cfn cout<<"NO\n";
#define xxy cout<<"yes\n";
#define xxn cout<<"no\n";
#define printcf(x) x?cout<<"YES\n":cout<<"NO\n";
#define printat(x) x?cout<<"Yes\n":cout<<"No\n";
#define printxx(x) x?cout<<"yes\n":cout<<"no\n";
#define maxqueue priority_queue<ll>
#define minqueue priority_queue<ll,vector<ll>,greater<ll>>
#define bug cout<<"---------------------------------------\n";
//ll pw(ll x,ll y,ll mod){if(y==0)return 1;if(x==0)return 0;ll an=1,tmp=x;while(y){if(y&1)an=(an*tmp)%mod;tmp=(tmp*tmp)%mod;y>>=1;}return an;}
template<typename T1,typename T2>bool Max(T1&x,T2 y){if(y>x)return x=y,1;return 0;}
template<typename T1,typename T2>bool Min(T1&x,T2 y){if(y<x)return x=y,1;return 0;}
ll _t_;
void _clear(){}
ll n,m,len,V;
ll l[100010],r[100010];
ll d[100010],v[100010],a[100010];
ll p[100010];
ll ans1,ans2;
__int128 V2;
priority_queue<pii,vector<pii>,greater<pii>>q;
__int128 f(__int128 v0,__int128 a,__int128 s){
	return v0*v0+2*a*s;
}
void solve()
{
	ans1=ans2=0;
    _clear();
	while(!q.empty())
		q.pop();
	cin>>n>>m>>len>>V;
	V2=V;
	V2*=V;
	forl(i,1,n)
		cin>>d[i]>>v[i]>>a[i];
	forl(i,1,m)
		cin>>p[i];
		
	forl(i,1,n)
	{
		if(a[i]==0)
		{
			ll L=1,R=m;
			while(L<R)
			{
				ll Mid=(L+R)/2;
				if(p[Mid]<d[i])
					L=Mid+1;
				else
					R=Mid;		
			}
			if(p[L]<d[i] || v[i]<=V)
			{
				l[i]=r[i]=-1;
				continue;
			}
			l[i]=L;
			r[i]=m;
		}
		else if(a[i]<0)
		{
			ll L=d[i],R=len;
			while(L<R)
			{
				ll Mid=(L+R+1)/2;
				if(f(v[i],a[i],Mid-d[i])<=V2)
					R=Mid-1;
				else
					L=Mid;
			}
//			cout<<"["<<L<<','<<R<<"]\n";
			if(f(v[i],a[i],L-d[i])<=V2)
			{
				l[i]=r[i]=-1;
				continue;
			}
			ll ansr=L;
			ll ansl=d[i];
//			cout<<"["<<ansl<<','<<ansr<<"]\n";
			L=1,R=m;
			while(L<R)
			{
				ll Mid=(L+R)/2;
				if(p[Mid]<ansl)
					L=Mid+1;
				else
					R=Mid;			
			}
			if(p[L]<ansl || p[L]>ansr)
			{
				l[i]=r[i]=-1;
				continue;
			}
			l[i]=L;
			
			L=1,R=m;
			while(L<R)
			{
				ll Mid=(L+R+1)/2;
				if(p[Mid]>ansr)
					R=Mid-1;
				else
					L=Mid;
			}
			r[i]=L;
		}
		else
		{
			ll L=d[i],R=len;
			while(L<R)
			{
				ll Mid=(L+R)/2;
				if(f(v[i],a[i],Mid-d[i])<=V2)
					L=Mid+1;
				else
					R=Mid;
			}
			if(f(v[i],a[i],L-d[i])<=V2)
			{
				l[i]=r[i]=-1;
				continue;
			}
			ll ansl=L;
			ll ansr=len;

			L=1,R=m;
			while(L<R)
			{
				ll Mid=(L+R)/2;
				if(p[Mid]<ansl)
					L=Mid+1;
				else
					R=Mid;			
			}
			if(p[L]<ansl || p[L]>ansr)
			{
				l[i]=r[i]=-1;
				continue;
			}
			l[i]=L;
			
			L=1,R=m;
			while(L<R)
			{
				ll Mid=(L+R+1)/2;
				if(p[Mid]>ansr)
					R=Mid-1;
				else
					L=Mid;
			}
			r[i]=L;			
		}
	}
//	forl(i,1,n)
///		cout<<l[i]<<' '<<r[i]<<endl;
//		
	forl(i,1,n)
		if(l[i]!=-1)
			q.push({r[i],l[i]}),
			ans1++;
	ll nr=-1;
	while(!q.empty())
	{
		pii now=q.top();
		q.pop();
		if(nr<now.y)
			nr=now.x,
			ans2++;
	}
	cout<<ans1<<' '<<m-ans2<<endl;
}
int main()
{
//    freopen("tst.txt","r",stdin);
//    freopen("sans.txt","w",stdout);
    IOS;
    _t_=1;
    cin>>_t_;
    while(_t_--)
        solve();
    QwQ;
}
```

---

## 作者：2huk (赞：31)

跟物理啥的没任何关系啦，题面给的一坨公式是为了让你看懂样例解释，虽然我没看。

我知道后面的贪心是经典问题。但是我不会于是自己造了个别的贪心。

## Description

一条长度为 $L$ 的道路上，有 $n$ 辆车和 $m$ 个测速仪。其中：

- 第 $i$ 辆车将从 $d_i$ 的位置出现，以 $v_i$ 的初速度和 $a_i$ 的加速度从左向右做匀加速运动。
- 第 $i$ 个测速仪在 $p_i$ 的位置。

若车 $i$ 经过某个测速仪 $j$ 时，其瞬时速度（$\sqrt {v_i^2 + 2a_is}$，其中 $s$ 为位移，即 $s = p_j - d_i$）大于 $V$，则车 $i$ 被判定为超速。若一辆车没有被任何一个测速仪判定为超速，它就没有超速。

求：

- 有多少辆车被判定为超速；
- 最多删掉多少个测速仪，能使得每辆车的超速情况都不发生改变。（实际上就是 $n - $ 最少保留几个。）

$1 \le n,m \le 10^5$，$1 \le L \le 10^6$。

## Solution

先考虑如何快速搞定第一问，即判断车 $i$ 能否被任意一个测速点判定为超速。

设 $f(i)$ 表示车 $i$ 在测速点 $f(i)$ 时速度**最大**，显然 $f(i) \in [1, m]$。那么车 $i$ 在任意一个测速点被判定超速，等价于 $\sqrt {v_{f(i)}^2 + 2a_{f(i)}(p_{f(i)}-d_i)} > V$。于是我们考虑求解所有 $f(i)$。

不妨对 $a_i$ 的正负分类讨论。

$$
f(i) = \begin{cases}
m & a_i \ge 0 \\
\min\limits_{p_j\ge i}j & a_i < 0
\end{cases}
$$

原因？

- $a_i \ge 0$，即速度越来越快。那么路程越远速度越大，而最远的测速点是 $m$。
- $a_i < 0$，即速度越来越慢。那么路程越短速度越大，而最近的测速点是 $\min\limits_{p_j\ge i}j$。

后者可以二分快速求解。于是第一问的复杂度我们可以做到 $\mathcal O(n \log n)$。

考虑第二问。

有了上面的思考，不难发现能将车 $i$ 判定为超速的测速仪是一段区间。具体地，当 $a_i \ge 0$ 时是一段以 $f(i)$ 为结尾的区间，当 $a_i < 0$ 时是一段以 $f(i)$ 为开头的区间。而这个区间的另一个端点可以通过二分求出。

我们将这些区间 $([l_1,r_1],[l_2,r_2],\dots,[l_m,r_m])$ 求出来后，问题变成了：

- 求在 $[1, n]$ 中最少选几个整数，能使得对于所有区间 $[l_i,r_i]$，都存在一个选择的整数 $j \in [l_i, r_i]$。

首先如果存在 $[l_i,r_i] \subseteq [l_j,r_j]$（即 $l_j \le l_i \le r_i \le r_j$），那么 $[l_j,r_j]$ 的存在是没有意义的。因为当区间 $i$ 覆盖一个整数时区间 $j$ 也一定覆盖了，但反过来不一定。

于是我们可以把像这样的“大区间 $j$”取出来删掉。此时剩下的区间就会满足：

- 左端点 $l$ 互不相同。
- 将所有区间按照左端点 $l$ 排序后，右端点 $r$ 严格递增。

显然考虑这样一种贪心策略：

- 首先将所有区间按照左端点 $l$ 排序。
- 从左往右扫描每个区间 $i$。如果当前区间 $i$ 已经覆盖了某个选择的整数那么忽略其不管。否则选择整数 $r_i$。

正确性显然。总复杂度 $\mathcal O(n \log n)$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

typedef long long ll;

int n, m, L, V;

struct Car {
	int d, v, a;
}car[N];

int pos[N];

bool chk(int x, int y) {
	if (car[x].d > pos[y]) return false;
	int s = pos[y] - car[x].d;
	int a = car[x].a, v = car[x].v;
	return v * v + 2 * a * s > V * V;
}

struct Seg {
	int l, r;
}p[N];
int cnt;

bool st[N];

pair<int, int> solve() {
	cin >> n >> m >> L >> V;
	
	for (int i = 1; i <= n; ++ i ) {
		cin >> car[i].d >> car[i].v >> car[i].a;
	}
	
	for (int i = 1; i <= m; ++ i ) {
		cin >> pos[i];
	}
	
	cnt = 0;
	for (int i = 1; i <= n; ++ i )
		if (car[i].d <= pos[m]) {
			int l, r;
			
			if (car[i].a >= 0) {
				r = m;
				if (!chk(i, r)) continue;
				
				int lo = 1, hi = m;
				while (lo <= hi) {
					int mid = lo + hi >> 1;
					if (chk(i, mid)) {
						l = mid;
						hi = mid - 1;
					} else {
						lo = mid + 1;
					}
				}
			} else {
				l = lower_bound(pos + 1, pos + m + 1, car[i].d) - pos;
				if (!chk(i, l)) continue;
				
				int lo = l, hi = m;
				while (lo <= hi) {
					int mid = lo + hi >> 1;
					if (chk(i, mid)) {
						r = mid;
						lo = mid + 1;
 					} else {
 						hi = mid - 1;
 					}
				}
			}
			
			p[ ++ cnt] = {l, r};
		}
	
	sort(p + 1, p + cnt + 1,
		[&](Seg x, Seg y) {
			return x.l == y.l ? x.r > y.r : x.l < y.l;
		});
	
	int mn_r = 1e9;
	for (int i = cnt; i; -- i )
		if (p[i].r < mn_r) {
			st[i] = true;
			mn_r = p[i].r;
		} else {
			st[i] = false;
		}
	
	int res = 0;
	int lst = -1;
	
	for (int i = 1; i <= cnt; ++ i ) {
		if (st[i] && p[i].l > lst) {
			res ++ ;
			lst = p[i].r;
		}
	}
	
	return {cnt, m - res};
}

signed main() {
	int T;
	cin >> T;
	while (T -- ) {
		auto t = solve();
		cout << t.first << ' ' << t.second << '\n';
	}
	return 0;
}
```

---

## 作者：Lysea (赞：28)

## Upd on 2024.11.4

附上考场代码。

## Solution

个人感觉这个 T2 还是蛮板子的。

我们可以将所有车的 $a$ 按正负分为两部分，$a=0$ 归在正数那一类（不然后面会出现除以 $0$ 的情况）。

先考虑 $a$ 非负的情况，此时车的瞬时速度 $v$ 单调不降，所以若在某一时刻 $v>V$，则对于**后面**任意时刻都同样有 $v>V$，满足要求的测速仪区间就形如 $[i,m]$，二分即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/qp11amob.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

那如果 $a$ 为负呢？此时我们就还要考虑减速为 $0$ 的情况了。

我们可以先二分求出每辆车能够行驶超过的最远测速仪 $x$，位置位于车前且最小的测速仪 $k$，满足要求的测速仪就一定处于区间 $[k,x]$ 内。

而又因为车的瞬时速度 $v$ 单调递减，所以若在某一时刻 $v>V$，则对于**前面**任意时刻都同样有 $v>V$，满足要求的测速仪区间就形如 $[k,i]$，再写个二分即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/rpm7dehf.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

最后存在多少个取值区间，就有多少车是能够被测出超速的。

这样我们就用 $O(n\log n)$ 的时间复杂度~~附加极大的常数~~解决了第一问。

下面来看第二问，其实就是个比较经典的贪心模型。

我们考虑将所有区间 $[l,r]$ 按 $r$ 从小到大排序，维护一个变量 $R$ 表示当前拓展到的最右端点，然后按顺序对每个区间 $i$ 执行以下策略：

- 初始 $R=0$。

- 若 $l_i \le R$，则跳过。

- 否则令 $R \leftarrow r_i$，累加答案。

这样做的本质就是尽可能选每个区间最靠右的数（也就是 $r_i$），那么为什么这样做是最优的呢？

假如说枚举到区间 $i$，你选择了 $r_i-1$ 号测速点，那么这个测速点就可以被之后的若干区间共用，假设为 $i$ 至 $j_0$ 号测速点。

若你此时选择了 $r_i$ 号测速点，你就会发现能够共用的区间个数变得更多了。若假设为 $i$ 至 $j$ 号测速点，则有 $j_0\le j$。

所以选择更靠右的点可以保证答案不劣的同时产生新的贡献，自然也就是最优的。

总体时间复杂度 $O(n\log n)$。

## Code

细节还是挺多的，等公示出来后再说吧。

先提醒几个点：

- 二分一定要给左右指针**留空位**，不然就相当于默认有解。

- 不要用浮点数计算，将所有的除法都乘至一边，同时注意**变号**。


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005
#define INF 1e18
using namespace std;
struct car{
    int d,v,a;
}e[N];
struct node{
    int l,r;
}d[N];
int n,m,L,V,p[N],l,r,ll,rr,lll,rrr,mid,ans1,ans2,fnt;
int spe(int id,int pos){
    if(e[id].d>pos) return -INF;
    return 2*e[id].a*(pos-e[id].d)+e[id].v*e[id].v;
}
bool cmp(node x,node y){
    return x.r<y.r;
}
void solve(){
    cin>>n>>m>>L>>V,ans1=ans2=0; 
    for(int i=1,d,v,a;i<=n;i++){
        cin>>d>>v>>a;
        e[i]=car{d,v,a};
    }
    for(int i=1;i<=m;i++) cin>>p[i];
    for(int i=1,k;i<=n;i++){
        if(e[i].a>=0){
            l=1,r=m+1;
            while(l<r){
                mid=l+r>>1;
                if(spe(i,p[mid])>V*V) r=mid;
                else l=mid+1;
            }
            if(l!=m+1){
                d[++ans1]=node{l,m};
            }
            continue;
        }
        ll=0,rr=m;
        while(ll<rr){
            mid=ll+rr+1>>1;
            if(2ll*p[mid]*e[i].a>=2ll*e[i].d*e[i].a-e[i].v*e[i].v) ll=mid;
            else rr=mid-1;
        }
        if(!ll) continue;
        lll=1,rrr=m+1;
        while(lll<rrr){
            mid=lll+rrr>>1;
            if(p[mid]<e[i].d) lll=mid+1;
            else rrr=mid;
        }
        if(lll==m+1) continue;
        l=lll-1,r=ll;
        while(l<r){
            mid=l+r+1>>1;
            if(spe(i,p[mid])>V*V) l=mid;
            else r=mid-1;
        }
        if(l==lll-1) continue;
        d[++ans1]=node{lll,l};
    }
    cout<<ans1<<" ";r=0;
    sort(d+1,d+ans1+1,cmp);
    for(int i=1;i<=ans1;i++){
        if(r>=d[i].l) continue;
        ans2++,r=d[i].r;
    }
    cout<<m-ans2<<'\n';
}
signed main(){
    int T; cin>>T;
    while(T--) solve();
    return 0;
}
```

---

## 作者：ivyjiao (赞：26)

八倍经验：P1250，P1645，P1986，P10934，SP116，UVA1723，AT_abc216_g（强化版），P11232（第二问）。

类似题目：P2207。

赛时思路：

考虑到预处理出 $s_i,t_i$，就是第 $i$ 辆车的起始超速点和终止超速点，若从未超速则为 $s_i=-1,t_i=-1$。

- 先看第一问：

1. CCF 经典艺能之特殊性质给结论，看到有特殊性质 ABC 考虑分成 $a_i=0,a_i>0,a_i<0$ 三类处理。
2. 考虑 $a_i=0$，转化为匀速直线运动，若 $v_i>V$，则 $s_i=d_i,t_i=L$，否则 $s_i=-1,t_i=-1$。
3. 考虑 $a_i>0$，转化为加速直线运动，此时一定这辆车一定越开越快，一旦超速之后全超速，且不会提前拐出主干道（CCF 在题面中都直接告诉你了），若 $v_i>V$，则一直超速，$s_i=d_i,t_i=L$，否则若 $\sqrt{{v_i}^2+2\times a_i\times (L-d_i)}\leq V$，则一定一直不超速，$s_i=-1,t_i=-1$，否则 $s_i=\lfloor\dfrac{V^2-{v_i}^2}{2\times a_i}\rfloor+1,t_i=L$，因为加速到 $V$ 后瞬时没有超速，所以要 $+1$。
4. 本题难点来了：考虑 $a_i<0$，转化为减速直线运动，此时这辆车一定越开越慢，一旦不超速之后全不超速，$v=0$ 时拐出主干道，若 $v_i\leq V$，则一直不超速，$s_i=-1,t_i=-1$，否则若 $\sqrt{{v_i}^2+2\times a_i\times (L-d_i)}>V$，则一直超速，$s_i=d_i,t_i=L$，否则若 $(V^2-{v_i}^2)\bmod 2\times a_i=0$，则 $s_i=d_i,t_i=\lfloor\dfrac{V^2-{v_i}^2}{2\times a_i}\rfloor-1$，因为减速到 $V$ 后瞬时已不超速，所以要 $-1$，否则 $s_i=d_i,t_i=\lfloor\dfrac{V^2-{v_i}^2}{2\times a_i}\rfloor$。

然后这题的核心就做完了，之后枚举每辆车在 $[s_i,t_i]$ 区间内有没有摄像头，如果有就判定为超速，如果没有 $s_i=-1,t_i=-1$。

至此第一问结束。

第二问在洛谷有剩余七倍经验：P1250，P1645，P1986，P10934，SP116，UVA1723，AT_abc216_g，太典了，不讲。推销一下我的题解 [AT_abc216_g](https://www.luogu.com.cn/article/2kl4op9g)，[P10934](https://www.luogu.com.cn/article/3jphz6ip)，题解用的差分约束，场上写的贪心，当然也可以用差分约束做就是了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+1;
int t,n,m,L,V,b[N],c[N],ans1,ans2,lst;
bool isa,isb;
struct car{
    int d,v,a,s,t;
}a[N];
int check(int x){
    if(b[m]<x) return -1;
    int l=1,r=m;
    while(l<r){
        int mid=(l+r)/2;
        if(b[mid]<x) l=mid+1;
        else r=mid;
    }
    return b[l];
}
int check1(int x){
    int l=1,r=m;
    while(l<r){
        int mid=(l+r+1)/2;
        if(b[mid]>x) r=mid-1;
        else l=mid;
    }
    return l;
}
bool cmp(car x,car y){
    if(x.t!=y.t) return x.t<y.t;
    return x.s>y.s;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>t;
    while(t--){
        memset(c,0,sizeof c);
        ans1=0,ans2=0;
        lst=0;
        isa=1,isb=1;
        cin>>n>>m>>L>>V;
        for(int i=1;i<=n;i++){
            cin>>a[i].d>>a[i].v>>a[i].a;
            if(a[i].a==0){
                if(a[i].v>V) a[i].s=a[i].d,a[i].t=L;
                else a[i].s=-1,a[i].t=-1;
                isb=0;
            }
            else if(a[i].a>0){
                if(a[i].v>V) a[i].s=a[i].d,a[i].t=L;
                else if(1.0*sqrt(1.0*a[i].v*a[i].v+2*a[i].a*(L-a[i].d))<=1.0*V) a[i].s=-1,a[i].t=-1;
                else a[i].s=a[i].d+(V*V-a[i].v*a[i].v)/(2.0*a[i].a)+1,a[i].t=L;
                isa=0;
            }
            else{
                if(a[i].v<=V) a[i].s=-1,a[i].t=-1;
                else if(1.0*sqrt(1.0*a[i].v*a[i].v+2*a[i].a*(L-a[i].d))>1.0*V) a[i].s=a[i].d,a[i].t=L;
                else{
                    if((V*V-a[i].v*a[i].v)%(2*a[i].a)==0) a[i].t=a[i].d+(V*V-a[i].v*a[i].v)/(2*a[i].a)-1;
                    else a[i].t=a[i].d+(V*V-a[i].v*a[i].v)/(2*a[i].a);
                    a[i].s=a[i].d;
                }
                isa=0,isb=0;
            }
        }
        for(int i=1;i<=m;i++) cin>>b[i];
        for(int i=1;i<=n;i++){
            if(a[i].s==-1||a[i].t==-1) continue;
            int p=check(a[i].s);
            if(p!=-1&&p<=a[i].t) ans1++;
            else a[i].s=-1,a[i].t=-1;
        }
        if(isa||isb){
            if(ans1) ans2=m-1;
            else ans2=m;
        }
        else{
            ans2=m;
            sort(a+1,a+1+n,cmp);
            for(int i=1;i<=n;i++){
                if(a[i].s==-1||a[i].t==-1) continue;
                if(lst&&a[i].s<=b[lst]&&b[lst]<=a[i].t) continue;
                lst=check1(a[i].t);
                ans2--;
            }
        }
        cout<<ans1<<" "<<ans2<<'\n';
    }
}
```

---

## 作者：ykzzldz (赞：22)

首先对 $a$ 的三种情况进行分类讨论，带公式求出每个车能被检测出超速的区间 $[l,r]$，可以预处理出两个数组 $L_i,R_i$，分别表示 $i$ 位置左右的第一个测速仪，那么这辆车被检测出超速的测速仪的区间即为 $[R_l,L_r]$，下面所说的区间均为**测速仪的区间**。

将所有区间按右端点从小到大排序，遍历每个区间，若此区间内没有测速仪，则加上右端点处的测速仪。例如，有 $[1,4],[2,5],[6,7]$ 三个区间，第一次选 $4$，然后遍历到 $[2,5]$ 这个区间，发现其中的 $4$ 被选过了，就不用选，$[6,7]$ 这个区间没选，选上 $7$。下面给出考场代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,M=1e6+10;
int T,n,m,L,V,l[M],r[M],d[N],v[N],a[N];
struct node{
    int l,r;
};
vector<node>jl;
bool cmp(node a,node b){
    return a.r<b.r;
}
signed main(){
    cin>>T;
    while(T--){
        jl.clear();
        scanf("%lld%lld%lld%lld",&n,&m,&L,&V);
        for(int i=0;i<M;i++){
            l[i]=r[i]=0;
        }
        for(int i=1;i<=n;i++){
            scanf("%lld%lld%lld",&d[i],&v[i],&a[i]);
        }
        for(int i=1;i<=m;i++){
            int p;
            scanf("%lld",&p);
            l[p]=r[p]=p;
        }
        for(int i=1;i<=L;i++){
            if(l[i])continue;
            l[i]=l[i-1];
        }
        for(int i=L;i>=0;i--){
            if(r[i])continue;
            r[i]=r[i+1];
        }
        for(int i=1;i<=n;i++){
            if(a[i]==0){
                if(!r[d[i]]||v[i]<=V)continue;
                jl.push_back({r[d[i]],l[L]});
            }
            if(a[i]>0){
                if(!r[d[i]])continue;
                if(v[i]>V){
                    jl.push_back({r[d[i]],l[L]});
                }
                else{
                    int s=(V*V-v[i]*v[i])/(2*a[i])+1;
                    s+=d[i];
                    if(s>L||!r[s])continue;
                    jl.push_back({r[s],l[L]});
                }
            }
            if(a[i]<0){
                if(!r[d[i]]||v[i]<=V)continue;
                int s=(V*V-v[i]*v[i])/(2*a[i]);
                if((V*V-v[i]*v[i])%(2*a[i])==0)s--;
                s+=d[i];
                if(s>L)s=L;
                if(r[d[i]]>l[s])continue;
                jl.push_back({r[d[i]],l[s]});
            }
        }
        sort(jl.begin(),jl.end(),cmp);
        int p=-1,ans=0;
        cout<<jl.size()<<' ';
        for(int i=0;i<jl.size();i++){
            if(i&&jl[i].l<=jl[i-1].l)continue;
            if(p<jl[i].l)p=jl[i].r,ans++;
        }
        cout<<m-ans<<'\n';
    }
    return 0;
}
```

---

## 作者：yanbinmu (赞：20)

## 前言

没想到有一天蒟蒻也能场切 T2。

发篇题解庆祝一下。

会更多体现蒟蒻的~~唐氏想法~~心路历程。

## 分析

看到题第一眼：

三种状态？分类讨论……

1. 减速  在遇见的第一个测速点时速度时最大的。
2. 加速  在最后一个测速点速度最大。
3. 匀速  不变，直接和 $V$ 比较。

那不就知道有多少车超速了嘛！

去掉多少点？

它是一个范围？（别听，不是）

然后就写了一个维护最大超速点和最小超速点的唐氏代码……

就不放了。

发现不对，去写 T3 暴力，写完了回来，发现超速区间是一段段的线段。

思考：

1. 找被所有区间覆盖的点？不对
2. 用最少的点去覆盖所有区间？好像是对的。怎么做呢？
3. 统计被覆盖次数然后贪心的取？那如何维护剩下的区间？动态？不对，会 T 飞。
4. 想到某一本书中提及的用点覆盖线段的问题，好像是了。

那么，就是我们将所有的区间当作线段，然后按找右端点排序，乱贪不止。

### 证明

如果一个点不放在右端点，那么放到右端点，一定不会更劣。为什么？

感性理解，如果按照右端点进行排序，那么放到右端点更可能覆盖到别的区间。

#### 不知道是否理性的分析：

考虑如果从不放到右端点，到放到右端点，那么少覆盖到的右端点一定小于当前区间的右端点，那么就会先处理到。

那么如果移开这个点会使答案变劣，那么一定是那些先处理过的区间，而那些已经处理了，所以不会变劣。

## 代码

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 100005;

int n, m, L, V;
int a[N], d[N], p[N], v[N];
struct area {
	int l, r;
	bool operator < (const area & a) const { //重载运算符
		if(r == a.r) return l < a.l;
		return r < a.r;
	}
};
vector<area> line;

bool check(int mid, int i) {
	int dis = p[mid] - d[i];
	int vt = v[i] * v[i] + 2 * a[i] * dis;
	if(vt > V * V) return true;
	return false;
}

int main() {
//	freopen("detect.in", "r", stdin);
//	freopen("detect.out", "w", stdout);
	ios :: sync_with_stdio(false);//好像不加会 T 赛时没加时大样例跑了 1.7s
	cin.tie(nullptr);
	cout.tie(nullptr);
	int T;
	cin >> T;
	while(T -- ) {
		cin >> n >> m >> L >> V;
		for(int i = 1;i <= n;i ++ ) {
			cin >> d[i] >> v[i] >> a[i]; 
		} 
		for(int i = 1;i <= m;i ++ ) {
			cin >> p[i];
		}
		sort(p + 1, p + m + 1);
		int cnt = 0;
		for(int i = 1;i <= n;i ++ ) {
			if(d[i] > p[m]) continue;
			if(a[i] == 0) {
                // 匀速，那么超速的区间就是上路后第一个点到第 m 个点
				if(v[i] > V) {
					int s = lower_bound(p + 1, p + m + 1, d[i]) - p;
					line.push_back((area){s, m});
					cnt ++ ;
				}
			}
			else if(a[i] < 0) {
				int s = lower_bound(p + 1, p + m + 1, d[i]) - p;//上路后第一个测速点
				int dis = p[s] - d[i];
				int vt = v[i] * v[i] + 2 * a[i] * dis;//v2 - v02 = 2ax
				if(vt > V * V) {
					cnt ++ ;
					int l = s;
					int r = m;
					int ans = 0;
                	// 匀减速，那么超速区间一端为第一个测速点，第二个可以二分求得
					while(l <= r) {
						int mid = (l + r) >> 1;
						if(check(mid, i)) {
							l = mid + 1;
							ans = mid;
						}
						else r = mid - 1;
					}
					line.push_back((area){s, ans});
				}
			}
			else {
				int s = lower_bound(p + 1, p + m + 1, d[i]) - p;
				int dis = p[m] - d[i];
				int vt = v[i] * v[i] + 2 * a[i] * dis;
				if(vt > V * V) {
					cnt ++ ;
					int l = s;
					int r = m;
					int ans = 0;
                    //匀加速同理啦
                    //二分求得超速后遇到的第一个测速点，另一个就是 m
					while(l <= r) {
						int mid = (l + r) >> 1;
						if(check(mid, i)) {
							ans = mid;
							r = mid - 1;	
						}
						else l = mid + 1;
					}
					line.push_back((area){ans, m});
				}
			}
		}
		
		sort(line.begin(), line.end());//贪心
		int ans = 0, last = 0;
		for(auto i : line) {
			if(i.l <= last && last <= i.r) continue;
			last = i.r;
			ans ++ ;
		}
		cout << cnt << " " << m - ans << "\n";
		line.clear();//多测要清空
	}
	return 0;
}
```

---

## 作者：_determination_ (赞：20)

首先考虑处理出每辆车的超速区间，注意到最后一个公式，那么每辆车的超速区间是可以 $O(1)$ 算的。

具体一点，我们考虑分讨加速度的正负，先判掉永远超速或者永远不超速的情况。

首先根据公式，我们有“速度为 $V$ 的点距离起点的距离是 $\frac{V^2-v^2}{2a}$”这个显然的结论。称他为 $l$，那么当 $a>0$ 的时候有超速区间 $[d+l,L)$，当 $a<0$ 的时候有超速区间 $[d,d+l)$，将其转化为整数是好做的，判断区间内是否有测速点自然也是一个前缀和搞定的事情。第一问已经解决。

考虑如何做第二问，这是个典的贪心，但是我菜不会贪心，于是我决定 dp。

设每个可以被检测到的车化为整数之后的超速区间为 $[l_i,r_i]$，$f_i$ 表示保存了第 $i$ 个测速点，$l_i\leq a_i$ 的区间全部被选中的最小保存的测速点数量。

显然能够转移到 $f_i$ 的 $f_j$ 是扔掉所有 $l_i\leq a_i \leq r_i$ 的区间后所有区间的 $l_i$ 的 $\max \leq a_j$ 的全部 $f_j$。然后你就会 $O(n^2)$ 了。

考虑如何优化。首先包含其他区间的区间全部扔掉，这个是容易 $O(n)$ 做到的。然后你把剩下的区间按照 $l$ 排序，那么可以贡献 $\max l$ 的区间是一段前缀，考虑双指针维护这个 $\max l$。

然后你发现转移区间的左端点和右端点都不会向左移，然后你就直接单调队列优化即可。

复杂度 $O(n\log n)$，复杂度瓶颈在排序。考场上想了想好像可以把排序省掉？不知道，反正如果真想卡复杂度你把 `sort` 换成桶排就是 $O(n)$ 了。

公开代码之后放出来自己的代码，实在不想再调一坤时了。

---
家人们代码下发了。
```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
void debug(string s){cout << "debug " << s << endl;}
void debug(int x){cout << "debug " << x << endl;}
const int mod=998244353,inf=0x3f3f3f3f3f3f3f3f;
const int N=1e5+10,M=1e6+10;
mt19937 rnd(time(0));
int n,m,L,V;
vector<pair<int,int>>vec,vec2;//需要测速的区间,处理后互不包含的区间
int cmp(pair<int,int>p,pair<int,int>q){return p.second>q.second;}
int cmp2(pair<int,int>p,pair<int,int>q){return p.second<q.second;}
int p[N],s[M];
int f[M];
void solve()
{
    cin >> n >> m >> L >> V;
    vec.clear(),vec2.clear();
    memset(s,0,sizeof(s));
    while(n--)
    {
        int d,v,a;
        cin >> d >> v >> a;
        if(a>0)
        {
            if(v>V)vec.push_back({d+1,L+1});
            else{
                int l=d+(V*V-v*v)*1.0/(2*a)+1;
                if(l<=L)vec.push_back({l+1,L+1});
            }
        }else if(a<0)
        {
            if(v<=V)continue;
            double lim=d+(V*V-v*v)*1.0/(2*a);
            // cout << fixed << lim << endl;
            int r=lim;
            if(r==lim)r--;
            r=min(r,L);
            if(d<=r)vec.push_back({d+1,r+1});
        }else{
            if(v>V)vec.push_back({d+1,L+1});
        }
    }
    L++;
    for ( int i = 1 ; i <= m ; i++ )
    {
        cin >> p[i];
        p[i]++;
        s[p[i]]=1;
    }
    for ( int i = 1 ; i <= L ; i++ )s[i]+=s[i-1];
    int cnt=0;
    // for ( auto p:vec )cout << p.first << " " << p.second << endl;
    for ( auto p:vec )if(s[p.second]-s[p.first-1])cnt++,vec2.push_back({p.first,p.second});
    cout << cnt << " ";
    //q2
    sort(vec2.begin(),vec2.end(),cmp);
    n=vec2.size();
    memset(f,0x3f,sizeof(f));
    for ( auto p:vec2 )f[p.first]=min(f[p.first],p.second);
    for ( int i = L ; i >= 1 ; i-- )f[i]=min(f[i],f[i+1]);
    vec.clear();
    for ( auto p:vec2 )if(f[p.first]>=p.second)vec.push_back({p.first,p.second});
    // else cerr << p.first << " " << f[p.first] << " " << p.second << endl;
    sort(vec.begin(),vec.end(),cmp2);
    vec2.clear();
    n=vec.size();
    if(n==0)return cout << m << endl,void();
    int mx=vec[0].first;
    for ( int i = 1 ; i < n ; i++ )
    {
        if(vec[i].second==vec[i-1].second)mx=max(mx,vec[i].first);
        else{
            vec2.push_back({mx,vec[i-1].second});
            mx=vec[i].first;
        }
    }
    vec2.push_back({mx,vec[n-1].second});
    n=vec2.size();
    sort(vec2.begin(),vec2.end());
    for ( int i = 0 ; i < n-1 ; i++ )assert(vec2[i].first<vec2[i+1].first);
    for ( int i = 0 ; i < n-1 ; i++ )assert(vec2[i].second<vec2[i+1].second);
    if(n==0)return cout << m << endl,void();
    int tot=0,maxl=0;
    memset(f,0,sizeof(f));
    deque<int>dq;
    while(!dq.empty())dq.pop_front();
    dq.push_back(0);
    for ( int i = 1 ; i <= m ; i++ )
    {
        while(tot<n&&p[i]>vec2[tot].second)
            maxl=max(maxl,vec2[tot++].first);
        if(i==1)
        {
            f[i]=1;
            while(!dq.empty()&&f[dq.back()]>1)dq.pop_back();
            dq.push_back(1);
            continue;
        }
        while(p[dq.front()]<maxl)dq.pop_front();
        f[i]=f[dq.front()]+1;
        while(!dq.empty()&&f[dq.back()]>f[i])dq.pop_back();
        dq.push_back(i);
        // int mn=inf;
        // for ( int j = 0 ; j < i ; j++ )if(maxl<=p[j])mn=min(mn,f[j]+1);
        // f[i]=mn;
    }
    int ans=inf;
    // for ( auto p:vec2 )cerr << p.first << " " << p.second << endl;
    // cerr << endl;
    // for ( auto p:vec )cerr << p.first << " " << p.second << endl;
    // cerr << endl;
    // for ( int i = 1 ; i <= m ; i++ )cerr << f[i] << " ";
    // cerr << endl;
    for ( int i = 0 ; i <= m ; i++ )if(vec2[n-1].first<=p[i])ans=min(ans,f[i]);
    // cerr << ans << endl;
    cout << m-ans;
    //q2end
    cout << endl;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    int T;
    cin >> T;
    while(T--)solve();
	return 0;
}
/*
考虑处理出每个车的超速区间，那么q1是简单的
q2考虑dp，我现在会了但是感觉很狗屎
剩余2.25h，正在调
问题规约方式有些问题，把覆盖别的区间的区间全部去掉怎么做？
好好好，调出来了，开始加优化。
完蛋，过不去最后一个大样例
剩余1h，开始红温。
难崩。找到了。
*/
```

---

## 作者：Walrus (赞：13)

upd：添加更多的补充说明。

upd：删除文章无意义内容。

智慧题。

## Solution

直接枚举关掉哪些开哪些显然不可取，考虑预处理出每辆车超速区间。

由于题目中明确指出**只需要考虑从南向北的车辆，也就是说初速度 $v_0\geq0$**，于是可以考虑对加速度 $a$ 分三种情况讨论。

注：本篇文章主要只用到了 $x=v_0\times t+\dfrac{1}{2}a\times t^2$ 这个公式。

具体地：

- 若 $a_i=0$，直接判断是否超速即可（从上道路的位置到道路末端）。
- 若 $a_i>0$，分两种情况，一种是初速度已经超了，一种是初速度还没超需要你算的。

	根据运动学知识，$\Delta v = a\times \Delta t$，再利用位移公式 $x=v_{0}\times t + \dfrac{1}{2}\times a \times t^2$ 易求，$\Delta v$ 和 $a$ 是已知的，弄出 $\Delta t$ 代入第二个式子就可以得到位移 $x$。
    
- 若 $a_i<0$，同上，只是注意若初速度大于题目中所给 $V$ 较为复杂，可以采用物理中称为**逆向思想**的方法，即假设速度为 $0$，反推当速度加到 $v_i$ 和 $V$ 时的位移，二者作差加上 $d_i$ 即可求出区间。

注意，有些区间里可能没有监控，判断一个区间内是否有点可以采用二分实现。具体地，二分找到**第一个在区间左端点右方**的监控，判断此监控是否包含在区间内即可。

第一步完成，还有第二步。

现在题目转化为了给你 $n$ 个区间，让你选出 $k$ 个点 $pos_i$，使得对于每条线段都至少存在一个 $pos_i$ 使得 $l \leq pos_i \leq r$。

这就是典型的贪心模型。考虑按右端点从小到大排序，每次贪心的选尽量靠右端点的监控，具体操作可以通过二分实现。

以上便是该题目的两步操作。

**注意到开区间的存在，我们可以考虑给开区间加上或减去一个极小浮点值 $eps$ 来避免。**

时间复杂度 $O(TN  \log N)$。

code

upd：更改代码为考场代码。


```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr)
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define PII pair<int, int>
#define fi first
#define se second
#define inf 0x3fffffff

using namespace std;

const int N = 1e5 + 5;
const double eps = 1e-8;

struct Cars {
	double d, v, a;
	#define d(p) b[p].d
	#define v(p) b[p].v
	#define a(p) b[p].a
} b[N];

struct node {
	double l, r;
	#define l(p) c[p].l
	#define r(p) c[p].r
	
	bool operator < (const node &a) const {return r == a.r ? l < a.l : r < a.r;}
} c[N];

int n, m, res;
double L, V, p[N];

void init() {
	res = 0;
//	cin >> n >> m >> L >> V;
	scanf("%d %d %lf %lf", &n, &m, &L, &V);
	rep(i, 1, n) scanf("%lf %lf %lf", &d(i), &v(i), &a(i)), l(i) = r(i) = -1;
	rep(i, 1, m) scanf("%lf", &p[i]);
}




void sol() {
	init(); 
	rep(i, 1, n) {
		if(a(i) == 0) {
//			cout << i << '\n';
			if(v(i) > V) l(i) = d(i), r(i) = L;
		}
		else if(a(i) > 0) {
			if(v(i) > V) l(i) = d(i), r(i) = L;
			else {
				double lt = V - v(i);
				double t = lt / a(i);
				double sum = v(i) * t + 0.5 * a(i) * t * t;
				l(i) = d(i) + sum + eps, r(i) = L;
			}
		}
		else if(a(i) < 0) {
			if(v(i) > V) {
//				cout << i << ' ';
				a(i) = fabs(a(i));
				double lmt = v(i) / a(i);
				double lms = 0.5 * a(i) * lmt * lmt;
				
				double lt = V;
				double t = lt / a(i);
				double sum = 0.5 * a(i) * t * t;
				l(i) = d(i), r(i) = d(i) + (lms - sum) - eps;
			}
		}
	}
//	cerr<<1;
//	return;
//	exit(0);
	
	int tot = n; n = 0;
	rep(i, 1, tot) {//检查区间内是否有监控（first question）
//		printf("%.3lf %.3lf\n", d(i), r(i));
		if(l(i) > r(i) || (l(i) == r(i) && r(i) == -1)) continue;
		int id = lower_bound(p + 1, p + 1 + m, l(i)) - p;
		if(id == m + 1) continue;
		if(p[id] > r(i)) continue;
		++n;
		l(n) = l(i), r(n) = r(i); r(n) = min(r(n), L);
	}
	
//	cout << n << ' '; 
	printf("%d ", n);
	if(n == 0) return printf("%d\n", m), void();
	sort(c + 1, c + 1 + n);
//	rep(i, 1, n) printf("%.3lf %.3lf\n", l(i), r(i));
	int id = upper_bound(p + 1, p + 1 + m, r(1)) - p - 1;
	double pos = p[id];//开始贪心选点（second question）
//	cout << pos << '\n';
	rep(i, 2, n) {
		if(l(i) <= pos && pos <= r(i)) continue;
		else {
			id = upper_bound(p + 1, p + 1 + m, r(i)) - p - 1;
			pos = p[id];
//			cout << i << ' ' << pos << '\n';
			++res;
		}
	}
	printf("%d\n", m - res - 1);
//	cout << m - res - 1;
//	cout << '\n';
//	exit(0);
}


signed main() {
//	FASTIO;
	
// 	freopen("detect.in", "r", stdin);
// 	freopen("detect.out", "w", stdout); 
	
	int _; cin >> _;
	while(_--) sol();
	
	
	
	return 0;
}
```

## 后记

考场上因为大量输入 `double` 本地 TLE 了调了很久，`cin` 输入 `double` 会非常慢，正确的做法应该是输入 `int` 在计算时转为 `double`，将 `cin` 换为 `scanf` 读入在本地会快一点，但是实测在各大 OJ 包括 CCF 机子上用 `cin` 都可以过，可以看我提交记录。

---

## 作者：Nasaepa (赞：13)

考场上想了好久。切完这题和 T1 时间已经过半了，遗憾离场。考完来洛谷递交民间数据全 WA 了，吓了一跳，再仔细一看数据有误，只能说 $(110)_2$ ，到最后还是 AC 了可喜可贺。

---

首先说明一件事情：$\lceil \frac{a}{b}\rceil = \lfloor \frac{a + b - 1}{b}\rfloor ~ (b \ne 0)$ 以方便你读懂代码，这里不做证明。

我们知道一辆车要么一直加速，要么一直减速，要么匀速行驶。因此，第 $i$ 车要么一直不超速，要么能划定一块区间 $[lq_i,rq_i]$ 使这辆车的位置在这个**路段**的区间内时，这辆车是超速的。为了方便处理，我们可以认为一直不超速的车在路段的 $[L+1,L+1]$ 段是超速的。

那我们怎么求 $lq_i$ 和 $rq_i$ 呢？首先，分类讨论。我们要分为四种情况：

1. $v_i > V,a_i \ge 0$
2. $v_i > V,a_i < 0$
3. $v_i \le V,a_i > 0$
4. $v_i \le V,a_i \le 0$

对于第一种情况，很明显这辆车是**一直超速**的，因此，$lq_i = d_i,rq_i $ 随便取一个比 $L$ 大的数字秒了，为了方便，下文所有类似本处 $rq_i$ 的因为需要而取比 $L$ 大的数字都取 $L+1$。

第二种情况，我们就要算汽车到哪里不会超速了。设汽车到整数 $fs$ 处时速度 $\le V$，根据题面提供的公式，$fs =d_i + \lceil \frac{V^2 - {v_i}^2}{2a_i} \rceil$ 由于这里存在负数，不好考虑，因此，$fs = d_i + \lceil \frac{{v_i}^2 - V^2}{-2a_i} \rceil$。则这个位置 $-1$ 就是这辆车最后一个超速的位置了（注意，有可能 $fs - 1 > L + 1）$。所以，$lq_i = d_i,rq = \min(fs-1,L+1)$。

第三种情况，我们仍然需要计算，只不过这一次是计算汽车到哪里会超速了。仍然定义 $fs$ 为这辆车最后一个不超速的位置，按照公式，$fs = d_i + \lfloor \frac{V^2 - {v_i}^2}{2a_i} \rfloor$，这个位置 $+1$ 就是超速的位置。所以，$lq_i = \min(L+1,fs+1),rq_i = L+1$ 。

第四种情况就是全程都不超速了，$lq_i = rq_i = L+1$。

这样我们就知道了每一辆车在哪些位置会超速了。我们提前设置一个 $cnta$ 代表超速车辆的数量。通过前缀和判断一下区间里面有没有测速器，有的话就 $cnta \gets cnta+i$，并储存起这辆车，没有的话就不做处理。

这样，这道题就被转化成了这样一题：

已知 $cnta$ 条线段，$m$ 个节点，要求在这 $m$ 个节点选择 $k$ 个节点对 $cnta$ 条线段进行**监管**，**监管**定义为被线段包含。要求求出最小的 $k$ 使得每一条线段均被某一个节点**监管**。

贪心 + 二分。

定义数组 $mlq$ 并初始全部设为极小值，$mlq_i$ 表示第 $i$ 个节点所需要**监管**的所有线段的左界中最靠右的一个。我们找到第 $i$ 条线段中所包含的所有节点中最靠右的节点，编号为 $pos$，$mlq_{pos} \gets \max(mlq_{pos},lq_i)$，即每条线段都选择让自己包含的节点中最靠右的**监管**自己。

随后从后往前遍历每一个节点。如果 $p_{i-1} \le  mlq_{i}$，则表示第 $i-1$ 个节点能够监管第 $i$ 个节点所监管的所有线段，此时可以选择将第 $i$ 个节点所监管的线段交给第 $i-1$ 个节点监管。此时应做出如下操作：

$$
mlq_{i-1} \gets \max(mlq_{i-1},mlq_{i}) \\
mlq_i \gets -\infty
$$

最后，找出所有满足 $mlq_i < 0$ 的节点，这些节点没有监管任何线段，可以被删去。

完整代码如下：

```cpp
// #pragma GCC optimize(2) // 开启O2优化
#include<bits/stdc++.h>
using namespace std;
#define N 100010
#define M 1000010
#define INF 0x3f3f3f3f // 无穷大
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
int T;
int n,m,cnta,cntb;
ll d[N],v[N],a[N];
int pres[M];
int p[N],L;
int lq[N],rq[N];
int mlq[N];
ll V;

// 输入函数
void input(){
    scanf("%d%d%d%lld",&n,&m,&L,&V);
    memset(pres,0,(L<<2)+20);
    memset(mlq,-0x3f,(m<<2)+20);
    for(int i = 1;i <= n;++i)scanf("%lld%lld%lld",d+i,v+i,a+i);
    for(int i = 1;i <= m;++i)scanf("%d",p+i),++pres[p[i]];
    for(int i = 1;i <= L + 1;++i)pres[i] += pres[i-1];
}

// 处理函数
void solve(){
    // 计算每个节点的 lq,rq
    for(int i = 1;i <= n;++i){
        // 如果开局超速
        if(v[i] > V){
            lq[i] = d[i];
            if(a[i] >= 0) {
                rq[i] = L + 1;
                continue;
            }
            ll fs = d[i] + (v[i] * v[i] - V * V - 2*a[i] - 1) / (-2*a[i]);// 这个点前一个绝对超速！？
            rq[i] = min(L+1ll,fs - 1);
            continue;
        }
        // 永远不会超速
        if(a[i] <= 0){
            lq[i] = rq[i] = L + 1;
            continue;
        }
        ll fs = d[i] + (V * V - v[i]*v[i])/(2*a[i]) + 1;// 这个位置+1绝对超速
        lq[i] = min(fs,L+1ll),rq[i] = L+1;
    }
    cnta = cntb = 0;
    for(int i = 1;i <= n;++i){
//        printf("used:%d [%d,%d]\n",i,lq[i],rq[i]);
        if(!(pres[rq[i]] - pres[lq[i] - 1]))continue;
        ++cnta;
        int pos = upper_bound(p+1,p+m+1,rq[i]) - p - 1;
        mlq[pos] = max(mlq[pos],lq[i]);
    }

    for(int i = m;i >= 2;--i){
        if(p[i-1] < mlq[i])continue;
        // 可以监管
        mlq[i-1] = max(mlq[i],mlq[i-1]);
        mlq[i] = -INF;
    }
}

// 输出函数
void output(){
    for(int i = 1;i <= m;++i) {
        if (mlq[i] >= 0)++cntb;
//        printf("mlq[%d] = %d\n",i,mlq[i]);
    }
    printf("%d %d\n",cnta,m - cntb);
}

// 多组测试样例
void task(){
	input();
	solve();
	output();
}

// 主函数
int main(int argc,char* argv[]){
	scanf("%d",&T);
	while(T--)task();
	return 0;
}
```

---

## 作者：Sving1024 (赞：11)

### 题外话
场上用了好多没必要的东西（比如树状数组），其实这道题用不到任何提高级算法/数据结构。
### 第一小问
题面翻到最后，你会看到：
> 当一辆车的初速度为 $v_0$、加速度 $a \neq 0$，在它的位移（即行驶路程）为 $\frac{v_1^2-v_0^2}{2a}$ 时，这辆车的瞬时速度为 $v_1$。

于是想到可以将每辆车瞬时速度为 $V$ 时行驶的路程算出来，然后就可以算出每辆车的超速区间，记作 $R_i=[l_i,r_i]$。

具体的，假设算出来的路程为 $s$。   
如果 $s_i<0$，经过简单的代数推导（或者感性理解），显然是一下两种情况之一：
- $a_i>0,v_i>V$，这辆车全程超速，$R_i=[d_i,L]$。
- $a_i<0,v_i\leq V$，这辆车全程不超速。

剩下就是 $s_i>0$ 的情况：
- $a_i>0$，显然车子会越走越快，并且在这之后一直超速，直到到达终点，$R_i=(d_i+s,L]$。
- $a_i<0$，显然这车会越走越慢，并且在这之前一直超速（由于速度减少到 $0$ 肯定在减少到 $V$ 之后，所以根本不需要考虑离开车道的情况），$R_i=[d_i,d_i+s)\cap [0,L]$。

特判 $a_i=0$ 的情况，如果 $v_i>V$ 则全程超速，反之全程不超速。

记录下每辆车超速的区间，问题转化为求 $[l_i,r_i]$ 之间测速仪的个数是否大于 $0$，对测速仪个数做一遍前缀和即可。由于测速仪只会在整数点上出现，因此只要对每个开区间的左端点向上取整，右端点向下取整即可。

需要注意，如果算出来的路程大于 $0$，汽车在 $d_i+s$ 处速度刚好为 $V$，根据题意并不超速，如果算出来这恰好是一个整数，作为左端点时应该 $+1$，作为右端点时应该 $-1$。

### 第二小问
简单将题意转化为保证超速的区间内至少有一个开启的测速仪。发现这个问题类似于 [P1325 雷达安装](https://www.luogu.com.cn/problem/P1325)，考虑使用类似的贪心方法。

将这些区间按右端点从小到大排序，
- 如果上一个开启的测速仪在这个区间里面，跳过这个区间。
- 否则，尽可能将右侧的测速仪开启。

此方法的证明可以看 P1325 的题解区，过程大同小异，在这里不在重复提及。

总共的复杂度是 $O(T(n\log n+L))$，瓶颈在于前缀和和排序。如果使用计数排序则可以到 $O(T(n+L))$。

### 难度
整个过程不需要用到任何提高级算法，整体思维难度不高，贪心策略的思维难度可以参考 P1325（这是道黄题），鉴于实现起来有各种细节，比较麻烦，建议评绿。

实现的时候注意变量名的大小写的问题。

### 参考代码
~~等 js 把代码公示的压缩包密码发出来之后附上。~~

由于宇宙射线提前附上代码。

[题解方法](https://www.luogu.com.cn/paste/79lx1jbc)      
[赛时方法](https://www.luogu.com.cn/paste/310pl40d)

最后祝各位一分不挂，取得理想成绩。
~~不给看代码公示好难受啊啊啊啊~~

---

## 作者：wangif424 (赞：8)

## 简化题意

- 给定 $n$ 辆车，每辆车有加速度，起始速度和进场位置。

- 给定一条 $[0,L]$ 的公路。

- 给定 $m$ 个测速仪，保证给定位置升序排列，且测速仪都在公路上。

你需要求出如下两个问题的答案。

1. 当所有测速仪都打开时，有多少个超速的车辆被检测到。

2. 最多可以关闭多少测速仪，使得在所有测速仪都打开时能被检测到的超速的车辆仍能被检测到。

## 做法

### 第一问

先考虑当一辆车超速时，需要满足什么条件，由于题目中给出了瞬时速度的公式，我们尝试稍作变形后直接沿用。

首先将位移转化成在公路上的位置，即 $s\leftarrow s-d_i$。

再平方消掉不好处理的根号，得到 $v_0^2+2a(s-d)\gt V^2$。

此时，我们再考虑上“被测速仪判定到”的条件，即 $\exist i\in[1,m],v_0^2+2a(s-p_i)>V^2 $。

于是想到将不等式解集求出，然后二分查找是否存在合适的测速仪。

于是根据 $a,v_0$ 的取值分类讨论：

1. $a>0,v_0>V$，此时显然车辆从上路开始就一直超速，超速区间 $[d,L]$。

2. $a>0,v_0=V$，此时车辆仅仅在上路的一瞬间不超速，超速区间 $(d,L]$。

3. $a>0,v_0<V$，此时不等式真正派上用场，移项作商得 $(\dfrac{V^2-v_0^2}{2a}+d,L]$。

4. $a=0,v_0>V$，同情况一，超速区间 $[d,L]$。

5. $a\le0,v_0\le V$，这四种情况相同，都是遵纪守法得好车辆，永远不会超速。

6. $a<0,v_0>V$，同情况三运用不等式，但注意不等号变向，超速区间 $[d,\min\{\dfrac{V^2-v_0^2}{2a}+d,L\})$。

由上述得到车辆超速区间后，二分查找是否存在能够检测到其得测速仪，即可得出第一问答案。

### 第二问

我们将第一问中，能被检测到的超速区间存下来，然后梳理一下已知信息和问题。

- 现在有一些区间，有一些点。

- 要选择一些点，使得所有区间都分别至少包括一个点。

- 满足上述要求时，需要最小化选点数量。

这是一道很典的贪心。

- 我们对左端点排序，从大往小扫，记录当前选上的最小的测速仪位置 $P$。

- 若 $P$ 不属于当前区间，则再选上最小的大于等于区间左端点的测速仪，并更新 $P$。

故，第二问解决。

## AC代码(原代码出了点锅，已更新)
```cpp
#include <bits/stdc++.h>
#define R(x) x = read()
#define int long long
#define pii pair<int,int>
using namespace std;
char pbuf[1<<20], *pp=pbuf;
inline void push(const char &c){(pp-pbuf==1<<20)?fwrite(pbuf,1,1<<20,stdout),pp=pbuf,*pp++=c:*pp++=c;}
class io {public:~io() {fwrite(pbuf, 1, pp - pbuf, stdout);}} _;
inline void write(int x) {
	x<0&&(push('-'),x=-x);
	static int sta[60]={},top=0;
	do{sta[top++]=x%10,x/=10;}while(x);
	while(top)push(sta[--top]^'0');
}
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){ch=='-'&&(f=-1);ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
constexpr int N=1e5+100;
int T;
int n,m,L,V;
int a[N],v[N],d[N];
int p[N];
set<int> s;
vector<pii >seq;
int cnt;
signed main(){
	R(T);
	while(T--){
		R(n);R(m);R(L);R(V);
		for(int i=1;i<=n;i++)R(d[i]),R(v[i]),R(a[i]);
		s.clear();
		for(int i=1;i<=m;i++)s.emplace(R(p[i]));
		cnt=0;
		seq.clear();
		for(int i=1;i<=n;i++){
			if(a[i]==0){
				if(v[i]>V){
					auto it=s.lower_bound(d[i]);
					if(it!=s.end())cnt++,seq.emplace_back(d[i],L);
				}
			}else if(a[i]>0){
				if(v[i]>V){
					auto it=s.lower_bound(d[i]);
					if(it!=s.end())cnt++,seq.emplace_back(d[i],L);
				}else if(v[i]==V){
					auto it=s.lower_bound(d[i]+1);
					if(it!=s.end())cnt++,seq.emplace_back(d[i]+1,L);
				}else{
					double be=(V+v[i])*1.0*(V-v[i])/2/a[i]+d[i];
					if((int)be==be)be+=1;
					be=ceil(be);
					auto it=s.lower_bound(be);
					if(it!=s.end())cnt++,seq.emplace_back((int)be,L);
				}
			}else{
				if(v[i]>V){
					double ed=(V+v[i])*1.0*(V-v[i])/2/a[i];
					if((int)ed==ed)ed-=1;
					ed=float(ed);
					auto it=s.upper_bound(ed+d[i]);
					it--;
					if(it!=s.end()&&*it>=d[i]&&*it<=(int)ed+d[i])cnt++,seq.emplace_back(d[i],min(L,(int)ed+d[i]));
				}
			}
		}
		write(cnt);push(' ');
		cnt=0;
		sort(seq.begin(),seq.end());
		int pos=m,pp=L+1;
		for(auto it=seq.rbegin();it!=seq.rend();it++){
			if(it->second<pp){
				while(p[pos]>=it->first)pos--;
				pp=p[pos+1];
				cnt++;
			}
		}
		write(m-cnt);
		push('\n');
		for(int i=1;i<=n;i++)d[i]=v[i]=a[i]=0;
		for(int i=1;i<=m;i++)p[i]=0;
	}
    return 0;
}
```

PS: 赛后写这份代码时，把赛场上犯没犯过的错都犯了一车。

---

## 作者：_H17_ (赞：7)

## 题目分析

考虑使用区间表示，对于每个车 $[l,r]$ 表示 $l\sim r$ 的检测能查出来超速。

然后就变成求有实质长度的区间数和最少的点数使得每个区间都包含至少 $1$ 个选择的点。

第一问使用分类讨论，二分（通常是进高速第一个到最后一个二分，主要不同就是加减量）。

第二问维护相同的 $r$ 的最大 $l$。如果上一个选择的点可以包含所有当前 $r$ 的就不更新，否则加一个。

## 代码实现


```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
constexpr int N=1e5+1,INF=0x3f3f3f3f3f3f3f3fll;
int T,n,m,l,v,p[N],ans1,ans2,maxl[N];
struct Car{
	int d,v,a;
	Car(int d=0,int v=0,int a=0):d(d),v(v),a(a){}
}a[N];
struct Segment{
	int l,r;
	Segment(int l=0,int r=0):l(l),r(r){}
}s[N];
int find_id(int d){
	int l=1,r=m,mid;
	while(l<r){
		mid=(l+r)>>1;
		if(p[mid]>=d)
			r=mid;
		else
			l=mid+1;
	}
	if(p[r]<d)
		return m+1;
	return r;
}
int get_leave(int d,int v,int a){
	int l=find_id(d),r=m,mid;
	while(l<r){
		mid=(l+r)>>1;
		if(-v*v<(p[mid]-d)*(2*a))
			l=mid+1;
		else
			r=mid; 
	}
	return r;
}
int get_speed(int v,int a,int s){
	return v*v+2*a*s;
}
void Main(){
	cin>>n>>m>>l>>v;
	ans1=ans2=0;
	for(int i=1,d,v,ad;i<=n;i++){
		cin>>d>>v>>ad;
		a[i]=Car(d,v,ad);
	}
	for(int i=1;i<=m;i++)
		cin>>p[i];
	for(int i=1;i<=n;i++){
		if(a[i].a==0){
			int id=find_id(a[i].d);
			if(a[i].v>v&&id<=m)
				s[i]=Segment(id,m);//超速、可检测区间 
			else
				s[i]=Segment(INF,-INF);//没超速、不能检测 
		}
		else if(a[i].a<0){
			int first_id=find_id(a[i].d),last_id=get_leave(a[i].d,a[i].v,a[i].a),mid_id;//驶入第一个&驶出前一个 
			if(first_id>last_id){
				s[i]=Segment(INF,-INF);
				continue;
			}
			while(first_id<last_id){
				mid_id=(first_id+last_id+1)>>1;
				if(get_speed(a[i].v,a[i].a,p[mid_id]-a[i].d)>v*v)
					first_id=mid_id;
				else
					last_id=mid_id-1;
			}
			if(get_speed(a[i].v,a[i].a,p[first_id]-a[i].d)>v*v)
				s[i]=Segment(find_id(a[i].d),first_id);
			else
				s[i]=Segment(INF,-INF);
		}
		else{
			int first_id=find_id(a[i].d),last_id=m,mid_id;
			if(first_id>last_id){
				s[i]=Segment(INF,-INF);
				continue;
			}
			while(first_id<last_id){
				mid_id=(first_id+last_id)>>1;
				if(get_speed(a[i].v,a[i].a,p[mid_id]-a[i].d)>v*v)
					last_id=mid_id;
				else
					first_id=mid_id+1;
			}
			if(get_speed(a[i].v,a[i].a,p[last_id]-a[i].d)>v*v)
				s[i]=Segment(last_id,m);
			else
				s[i]=Segment(INF,-INF);
		}
//		cerr<<s[i].l<<' '<<s[i].r<<'\n';
	}
	for(int i=1;i<=n;i++)
		if(s[i].l!=INF||s[i].r!=-INF)
			ans1++;
	memset(maxl,-0x3f,sizeof(maxl));
	for(int i=1;i<=n;i++){
		if(s[i].r!=-INF&&s[i].l!=INF)
			maxl[s[i].r]=max(maxl[s[i].r],s[i].l);
	}
	for(int i=1,lstr=-1;i<=m;i++){
		if(maxl[i]<0)
			continue;
		if(maxl[i]<=lstr)
			continue;
		else
			ans2++,lstr=i;
	}
	cout<<ans1<<' '<<m-ans2<<'\n';
	return;
}
signed main(){
	ios::sync_with_stdio(0);
	/*freopen("detect.in","r",stdin),
	freopen("detect.out","w",stdout);*/
	for(cin>>T;T;--T)
		Main();
	return 0;
} 
```

---

## 作者：guoziyang21 (赞：6)

# 题面

**【题目链接】**

[CSP-S 2024 T2](https://www.luogu.com.cn/problem/P11232)

**【题目大意】**

有一条最高限速为 $ V $，长为 $ L $ 的主干道，上有 $ m $ 个测速仪，其中第 $ j $ 个到道路最南端的距离为 $ p_j $，每个测速仪可以设置为开启或关闭。开启的测速仪可以对经过的车（包括恰好驶入和驶出主干道的车）进行测速，如果这辆车的瞬时速度**超过**了限速 $ V $，那么这辆车被判定为超速。

有 $ n $ 辆车，其中第 $ i $ 辆车将在 $ d_i $ 的位置驶入主干道，初速度为 $ v_i $，加速度为 $ a_i $。当车辆行驶到 $ L $ 的位置或速度降为 $ 0 $ 时，认为该车辆驶出主干道。

回答两个问题：

1. 当所有测速仪开启时，将会有多少辆车被判为超速？
2. 关闭尽可能多的测速仪，使得原本被判为超速的车仍然被判为超速。

**【数据范围】**

题目中出现的所有字母均为整数。

* $ 1 \le T \le 20 $；
* $ 1 \le n,m \le 10^5 $，$ 1 \le L \le 10^6 $，$ 1 \le V \le 10^3 $；
* $ 0 \le d_i <L $，$ 1 \le v_i \le 10^3 $，$ |a_i| \le 10^3 $；
* $ 0 \le p_1<p_2< \cdots <p_m \le L $。

# 考场思路

1. 由于是匀加速直线运动，所以超速的区间一定是连续的，而且是可以被计算出来的（注意**开闭**）。
2. 我们可以把超速的区间变成测速仪的分布区间，例如对于样例 $ 1 $，第四辆车的超速区间为 $ [5,9) $，转换为测速仪的分布区间为 $ [2,3] $。
3. 第二点的实现：首先对 $ a_i $ 的正负分类讨论得到车的超速区间：
   * $ a_i=0 $：若 $ v_i>V $，则超速区间为 $ [d_i,L] $；否则不超速；
   * $ a_i>0 $：若 $ v_i>V $，则超速区间为 $ [d_i,L] $；否则车会在位移为 $ x=\frac{v_i^2-V^2}{2a} $ 时提升到限速 $ V $，之后开始超速，此时超速区间为 $ (d_i+x,L] $；
   * $ a_i<0 $：若 $ v_i>V $，则车会在位移为 $ x=\frac{v_i^2-V^2}{2a} $ 时下降到限速 $ V $，之后开始减速，此时超速区间为 $ [d_i.d_i+x) $；否则不超速。
4. 在输入 $ p_i $ 时，预处理主干道每个位置左侧和右侧距离它最近的测速仪，根据第三点讨论得到车的超速区间后，轻松解决第一小问，然后根据预处理的结果直接转化为测速仪的分布区间（具体流程可参见下方代码）。
5. 于是第二小问可以变成一个多区间的贪心问题：一条长线段上有若干条短线段（可以重叠也可以不完全覆盖长线段），请在长线段上选取尽可能少的点，使得每条短线段上（含端点）都有被选取的点。
6. 贪心的实现：按照右端点排序（从小到大），然后在尽可能少的右端点处开测速仪。

综上，这题有两点，一是计算每辆车的超速区间并转换成测速仪的分布区间，二是贪心。

（橙+橙=绿）

# 时间复杂度

对于每组数据：

1. 在输入 $ p_i $ 时预处理主干道每个位置左侧和右侧距离它最近的测速仪，时间复杂度 $ O(L+m) $。
2. 计算每辆车的超速区间，并将超速区间转化为测速仪分布区间，由于需要对 $ a_i $ 的正负进行讨论，所以常数可能较大，时间复杂度 $ O(kn) $（$ k $ 是待定的常数）。
3. 然后进行贪心，需要对数据进行排序，时间复杂度 $ O(n\log n) $。

总时间复杂度：$ O(T(n\log n+m+L)) $。

# 代码

[AC记录](https://www.luogu.com.cn/record/186981806)

```cpp
# include<iostream>
# include<cstdio>
# include<algorithm>
using namespace std;

const int N=1e5+2,L=1e6+2;
int t,n,m,l,V,tmp,ans1,ans2;
int d[N],v[N],a[N],p[N];
int lft[L],rgt[L]; //距离最近的测速仪编号 
int ld[N],rd[N]; //每辆车超速区间的左、右端点
int g[N]; //所有超速的车的编号
int id; //后面贪心用的 

bool cmp(int x,int y){
	return rd[x]<rd[y];
}

void solve(){
	//1.常规读入+初始化
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	ans1=ans2=0,id=-1;
	cin>>n>>m>>l>>V;
	for(int i=1;i<=n;++i)
		cin>>d[i]>>v[i]>>a[i];
	for(int i=1;i<=m;++i){
		cin>>p[i];
		lft[p[i]]=rgt[p[i]]=i; //这一行是2.的步骤，提前到这 
	}
	//2.预处理距离最近的测速仪编号 
	p[0]=0,p[m+1]=l+1;
	for(int i=0;i<=m;++i)
		for(int j=p[i]+1;j<p[i+1];++j)
			lft[j]=i,rgt[j]=i+1;
	//3.计算每辆车的超速区间（本题核心）
	for(int i=1;i<=n;++i){
		if(d[i]>p[m]) continue; //如果驶入的位置之后没有测速仪就不理它了 
		if(a[i]==0){
			if(v[i]>V){
				g[++ans1]=i;
				ld[i]=rgt[d[i]];
				rd[i]=m;
			} //一开始就超速 
		}
		else if(a[i]>0){
			if(v[i]>V){
				g[++ans1]=i;
				ld[i]=rgt[d[i]];
				rd[i]=m;
			} //一开始就超速
			else{
				//开始超速的地方是：d[i]+位移向下取整+1
				tmp=V*V-v[i]*v[i];
				tmp=d[i]+tmp/(2*a[i])+1;
				//对超速的位置判断 
				if(tmp<=p[m]){
					g[++ans1]=i;
					ld[i]=rgt[tmp];
					rd[i]=m;
				} 
			} //加速了一会儿才超速 
		}
		else{
			if(v[i]>V){
				//开始超速的地方是：d[i]+位移向上取整-1
				tmp=v[i]*v[i]-V*V;
				if(tmp%(-2*a[i])==0)
					tmp=d[i]+tmp/(-2*a[i])-1;
				else
					tmp=d[i]+tmp/(-2*a[i]);
				//对超速的位置判断
				if(tmp>=p[m]){
					g[++ans1]=i;
					ld[i]=rgt[d[i]];
					rd[i]=m;
				}
				else{
					ld[i]=rgt[d[i]];
					rd[i]=lft[tmp];
					//有可能出现超速区间恰好夹在两个测速仪之间的情况 
					if(rd[i]>=ld[i]) g[++ans1]=i;
				}
			} //一开始超速，后面减速 
		} 
	}
	//4.计算最少需要开启的测速仪数量（贪心）
	sort(g+1,g+1+ans1,cmp); //按照右端点从小到大排序
	for(int i=1;i<=ans1;++i)
		if(ld[g[i]]>id){
			id=rd[g[i]];
			++ans2;
		} //如果左端点没有被覆盖到，那就在右端点覆盖 
	cout<<ans1<<" "<<m-ans2<<endl;
}

int main(){
	cin>>t;
	while(t--) solve(); 
	return 0;
}
```

---

update：

2024.10.26 完成初稿，提交审核。

2024.11.05 官方数据出来后，对代码进行了简化和重测，对其他内容进行了部分修改。

---

## 作者：Happy_mouse (赞：6)

# [P11232 [CSP-S 2024] 超速检测](https://www.luogu.com.cn/problem/P11232) 题解

[AC 证明](https://www.luogu.com.cn/record/185087051)

## 分析与解答
先说第一问，将车子分两类讨论：

1. 匀加速或匀速，即 $a_i \ge 0$，它们在途经最后一个检测点时一定最快；
2. 匀减速，即 $a_i<0$，它们在途经第一个点时一定最快。

第一类，所途经的最后一个一定是全线的最后一个点，即 $p_m$。而第二类，用出发点在检测点坐标中二分，找到途经的第一个点。然后用该检查点与出发点的距离套公式算，与限速比较即可。

然后看第二问，考虑贪心：

我们知道，关掉最多，即留下最少。而留下最少的点，就得让一堆超速的车子共用一个点。

前面说了，第一类可以找一个点“一步到位”，需要着重处理的仍然是第二类。

将所有会超速的第二类车按出发点排序，对于每个车子，寻找能留下超速证据，又离出发点最远的检测点（因为这样可以让靠后的点一起用），这里也用二分。

从第一辆二类车开始，将求出的检测点取最小值（为了保证存下的车子都能用这个点），直到下一辆车的出发点比该最小值更靠后，统计答案并重复这一过程。

最后判断剩下的第一类车，能不能在前面求出坐标最靠后的检测点中判断超速，否则就新建一个点，输出即可。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fi first
#define se second
#define st setprecision 
const int N=1e5+5;
const int mod=1e9+7;
int d[N],v[N],a[N],p[N];
struct nd{
	int d,v,a;
	bool operator <(const nd&x)const{return d<x.d;};
} up[N],dw[N];
void solve(){
	int n,m,L,V;
	cin>>n>>m>>L>>V;
	for(int i=1;i<=n;i++) cin>>d[i]>>v[i]>>a[i];
	for(int i=1;i<=m;i++) cin>>p[i];
	int c1=0,c2=0;
	for(int i=1;i<=n;i++){
		//判可行性
		//坐标不行，直接跳过
		if(d[i]>p[m]) continue;
		//第一类
		if(a[i]>=0){
			//求速度
			double v1=sqrt(v[i]*v[i]+2*a[i]*(p[m]-d[i]));
			//判超速，保存
			if(v1>V) up[++c1]={d[i],v[i],a[i]};
		}
		//第二类
		else{
			//二分
			int l=1,r=m;
			while(l<r){
				int mid=(l+r)>>1;
				//注意下面不取等，因为是找大于等于出发点坐标的点
				if(p[mid]<d[i]) l=mid+1;
				else r=mid;
			}
			//求速度
			double v1=sqrt(v[i]*v[i]+2*a[i]*(p[l]-d[i]));
			//判超速，保存
			if(v1>V) dw[++c2]={d[i],v[i],a[i]};
		}
	}
	//处理第二类
	//排序
	sort(dw+1,dw+c2+1);
	//初始化
	int wz=m+1,ma=0,cnt=0;
	dw[c2+1].d=L+1;
	for(int i=1;i<=c2;i++){
		//求最远距离
		double dis=(V*V-dw[i].v*dw[i].v)*1.0/(2*dw[i].a)+dw[i].d;
		//二分
		int l=1,r=m+1;
		while(l<r){
			int mid=(l+r)>>1;
			//注意这里也不取等，因为是找小于于出发点坐标的点
			if(p[mid]<dis) l=mid+1;
			else r=mid;
		}
		//取最小值
		wz=min(wz,l-1);
		//判断下一个不可用
		if(p[wz]<dw[i+1].d){
			//统计答案
			ma=wz;
			wz=m+1;
			cnt++;
		}
	}
	//处理第一类
	for(int i=1;i<=c1;i++){
		//坐标不行，直接加点
		if(up[i].d>p[ma]){
			cnt++;
			break;
		}
		//求速度
		double v1=sqrt(up[i].v*up[i].v+2*up[i].a*(p[ma]-up[i].d));
		//判速度，如果在这个位置没超速则加点
		if(v1<=V){
			cnt++;
			break;
		}
	}
	//输出
	cout<<c1+c2<<' '<<m-cnt<<'\n';
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：5)

这题跟纯模拟也没啥区别了。

如果不会高中课内物理还可以看提示，不管怎么着先算出每辆车的超速区间。这部分分讨一下即可。

直接求判定超速的数量，看超速区间内有没有测速点。没超速或者超速没被发现的可以直接扔掉。这部分可以二分，也可以排序后双指针。

然后变成了板子：给定 $n$ 个区间，$m$ 个给定的点，求使用最少点使得所有区间中都包含点。这是一类经典的序列上贪心问题。首先把区间按右端点排序，然后对每个区间讨论：如果已经包含了之前选过的点（直接用上一个选的点判断）就跳过，否则选一个最靠近右端点的点。

可能有精度问题，然后还有一系列的细节。总之这题想到不难，写起来还有点难度。尤其是算区间的过程，一不小心就会漏一两种情况（我一开始就是这样）。

代码先不放了，不想再敲一遍了。

Update：代码如下，原来的考场代码还过不了民间数据，好像是一个地方复杂度假了，现在改了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int t,n,m,l,lim;
int d[100010],v[100010],a[100010],p[100010];
const double eps=1e-6;
struct seg{
    int l,r;
}b[100010];
bool cmp(const seg &x,const seg &y){
    return x.r<y.r;
}
inline int fl(double x)
{
    if(x-(int)x<eps)return (int)x-1;
    else return (int)x;
}
inline int ce(double x)
{
    if((int)x+1-x<eps)return (int)x+2;
    else return (int)x+1;
}
int main()
{
    //freopen("detect.in","r",stdin);
    //freopen("detect.out","w",stdout);
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%d%d",&n,&m,&l,&lim);
        for(int i=1;i<=n;i++)
            scanf("%d%d%d",&d[i],&v[i],&a[i]);
        for(int i=1;i<=m;i++)scanf("%d",&p[i]);
        for(int i=1;i<=n;i++)
        {
            if(a[i]>0)
            {
                if(v[i]>lim)
                {
                    b[i].l=d[i];
                    b[i].r=l;
                }
                else
                {
                    double tt=(lim-v[i])*1.0/a[i];
                    b[i].l=min(l+1,ce(d[i]+v[i]*tt+0.5*a[i]*tt*tt));
                    b[i].r=l;
                    //zuo kai you bi
                }
            }
            else if(a[i]==0)
            {
                if(v[i]>lim)
                {
                    b[i].l=d[i];
                    b[i].r=l;
                }
                else
                {
                    b[i].l=1;
                    b[i].r=0;
                }
            }
            else if(v[i]>lim)
            {
                double tt=(lim-v[i])*1.0/a[i];
                b[i].l=d[i];
                b[i].r=min(l,fl(d[i]+v[i]*tt+0.5*a[i]*tt*tt));
                //zuo bi you kai
            }
            else
            {
                b[i].l=1;
                b[i].r=0;
            }
        }
        sort(b+1,b+n+1,cmp);
        int now=0,cnt=0,ans=0;
        p[0]=-1;
        for(int i=1;i<=n;i++)
        {
            int pos=lower_bound(p+1,p+m+1,b[i].l)-p;
            if(pos>m||p[pos]>b[i].r)continue;
            if(p[now]>=b[i].l)
            {
                cnt++;
                continue;
            }
            int nnow=now;
            while(nnow<m&&p[nnow+1]<=b[i].r)nnow++;
            if(p[nnow]<b[i].l)continue;
            now=nnow,ans++,cnt++;
        }
        printf("%d %d\n",cnt,m-ans);
    }
    return 0;
}
```

---

## 作者：koobee (赞：5)

这里给大家介绍一种与众不同的做法。

考场上：这个题怎么做？看起来是区间问题。

线段树维护？不太会。

贪心？蒟蒻没想到。

动态规划？貌似可以。

先把所有被判为超速的车找出来，在把每个车的“超速区间”（如果一辆车的超速区间中有摄像头，那么这辆车被判为超速）算出来，设为 $[l_1,r_1]$ 到 $[l_{ans},r_{ans}]$。（$ans$ 为初始被判为超速的车辆）

问题被我们转换了：有 $ans$ 个区间，$m$ 个位置，每个区间里面必须有位置被选，求最少的被选位置的数量。

初始的状态设计：$dp_{i,j}$ 为考虑前 $j$ 个区间，前 $i$ 个位置（$1\le i\le m$）中最少被选位置的数量。

这个做法可以拿 $80$ 分，但空间时间都炸了。尝试优化空间。

改进的状态设计：$dp_i$ 表示 **考虑右端点 $\le$ $i$ 的区间**，在前 $i$ 个位置中最少的被选点数量。

这个做法很难被卡，民间和官方都能拿 $100$ 分，但我还是建议大家用树状数组优化成时间复杂度符合要求的代码。

这是刚才那个思路的代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5, M = 1e6+5;
int T, n, m, l, v, ans, mn, sz, st, s[M], t[M], p[N], dp[M];
struct node{
    int d, v, a, l, r, f;
} c[N];
struct npd{
    int l, r;
    bool operator >(const npd &b) const{
        if(l != b.l) return l < b.l;
        return r < b.r;
    }
} x[N];
bool cmp(npd x, npd y){
    if(x.r != y.r) return x.r < y.r;
    return x.l < y.l;
}
int main(){
    //freopen("detect.in", "r", stdin);
    //freopen("detect.out", "w", stdout);
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin>>T;
    while(T--){
        memset(s, 0, sizeof(s));
        memset(t, 0, sizeof(t));
        memset(dp, 0, sizeof(dp));
        mn = 1e9, ans = 0, sz = 0, st = 0;
        cin>>n>>m>>l>>v;
        for(int i = 1; i <= n; i++) c[i].f = 0, c[i].l = c[i].r = -1;
        for(int i = 1; i <= n; i++){
            cin>>c[i].d>>c[i].v>>c[i].a;
            if(c[i].a <= 0 && c[i].v <= v) continue;
            if(c[i].a == 0) c[i].l = c[i].d, c[i].r = l;
            else{
                double t = 1.0 * fabs((v - c[i].v)) / fabs(c[i].a) * 1.0;
                if(c[i].a > 0){
                    if(c[i].v > v) c[i].l = c[i].d, c[i].r = l;
                    else{
                        double len = t * (1.0 * v + c[i].v) / 2.0 + c[i].d;
                        if(int(len) + 1 <= l) c[i].l = int(len) + 1, c[i].r = l;
                    }
                }
                else{
                    double len = t * (1.0 * v + c[i].v) / 2.0 + c[i].d;
                    c[i].l = c[i].d, c[i].r = min(int(ceil(len) - 1), l);
                }
            }
            
        }
        for(int i = 1; i <= m; i++){
            cin>>p[i];
            t[p[i]] = 1;
        }
        for(int i = 1; i <= l; i++) t[i] += t[i-1];
        for(int i = 1; i <= n; i++){
            int num;
            if(c[i].l == 0) num = 0;
            else num = t[c[i].l-1];
            if(c[i].l >= 0 && c[i].r >= 0 && t[c[i].r] - num > 0) c[i].f = 1, ans++, x[++sz] = {c[i].l, c[i].r}, st = max(st, c[i].l);
        }
        cout<<ans<<" ";
        sort(x+1, x+1+sz, cmp);
        int j = 1, k = 1;
        priority_queue<npd, vector<npd>, greater<npd> > q;
        for(int i = 1; i <= m; i++){
            while(j <= sz && x[j].r < p[i]) q.push((npd){x[j].l, x[j].r}), j++;
            while(k < i && !q.empty() && p[k] < q.top().l) k++;
            if(!q.empty() && k < i){
                int tmp = 1e9;
                for(int ll = k; ll < i; ll++) tmp = min(tmp, dp[ll]);
                dp[i] = tmp + 1;
            }
            else dp[i] = 1;
        }
        st = lower_bound(p+1, p+1+m, st) - p;
        for(int i = st; i <= m; i++) mn = min(mn, dp[i]);
        if(ans != 0) cout<<m - mn<<"\n";
        else cout<<m<<"\n";
    }
    return 0;
}
```

---

## 作者：玄学OIER荷蒻 (赞：5)

我们不妨先分析，在公路无限长的情况下，每辆车会不会超速，会在什么时间超速。

第一种情况，车永远不会超速。明显当且仅当初速度合规，并且加速度 $\le 0$，这个车才永远不超速。

第二种情况，车最开始不超速，一段时间后开始超速，并且会一直超速下去。明显是当初速度合规，加速度 $> 0$ 时会这样。

第三种情况，车最开始超速，后来逐渐变的不超速。这种是初速度不合规，但是加速度 $< 0$。

第四种情况，车是一直超速的，对应初速度不合规，加速度 $\ge 0$ 的情况。 

我们把一些超出 $L$ 范围的部分删掉（有的可能直接全删没了，因为超速的时候都在这条路范围外，就直接丢掉就可以了），整理所有超速区间。

然后在这个所有超速时间的区间里二分找到对应的的测速仪区间，注意有可能对应到的区间为空，这代表没有测速仪能抓到这辆车，直接视为没有超速，统计超速的车辆，完成第一问。

第二问只需要贪心求出最少选择的然后一减就可以了。

可以求出每个右端点对应最大的左端点，按右端点遍历，如果一个区间没被覆盖到，就选择这个区间的右端点覆盖。

然后你就做完了这道题，代码还要注意一下边界问题。

我会放出我自己的代码（在公开代码之后）

---

## 作者：Cure_Wing (赞：4)

[P11232 [CSP-S 2024] 超速检测](https://www.luogu.com.cn/problem/P11232)

### 解析

先做第一问，分类讨论。

当 $a_i\ge0$ 时，只需判断在最后一个测速仪上是否超速即可。

当 $a_i<0$ 时，只需判断它后面离它最近的测速仪到达时是否超速即可。

这样两者答案相加就是第一问。

考虑第二问，还是分类。

对于 $a_i\ge 0$ 且超速的，都只需要开启第 $m$ 个测速仪即可。但是如果这些超速的都会被 $a_i<0$ 的所需要的测速仪抓拍到，那么第 $m$ 个是不需要加的。

因此我们考虑第 $a_i<0$ 且超速的车。贪心地对这些车按照到达速度 $v$ 的坐标从小到大排序，从小往大考虑每一辆车。如果这辆车此时没有测速仪抓拍，那么选取靠近汽车速度到达 $v$ 时所在位置最近的 $p_j$ 安装测速仪。原因显然，这可以覆盖到更多的车且考虑到前面的车；如果有测速仪抓拍了，显然可以忽略。最后注意判断一下是否所有 $a_i\ge 0$ 且超速的车都被考虑到了即可。

至于判断大小，直接根据公式计算即可。因为计算过程数字大小不超过 $2^{31}$，不会掉精度。

时间复杂度 $O(Tn\log_2n)$，空间复杂度 $O(n)$。

[代码](https://www.luogu.com.cn/paste/n6jk1emh)。

---

## 作者：Genius_Star (赞：3)

### 思路：

题目已经给了提示了，位移为 $s$ 的瞬时速度为 $\sqrt{v_0^2 + 2 as}$，若超速了，即：
$$
\sqrt{v_0^2 + 2 as} > V \\
v_0^2 + 2 as > V^2  \\
\begin{cases}
s > \frac{V^2  - v_0^2}{2a} & a > 0 \\ 
s < \frac{V^2 - v_0^2}{2a} & a < 0 \\
v_0 > V & a = 0 \\
\end{cases}
$$
然后将 $p$ 从小到大排序，这样我们可以二分找到最小和最大的 $[l,r]$ 使得在这些测速仪内会被判定为超速。

现在转化为了经典问题，给定一些区间，每个区间内必须至少选一个点，问能选的最少的点数。

两种做法，一种按左端点排序后贪心，一种转化为前缀和后差分约束即可。

时间复杂度为 $O(n \log m + m \log m)$。

给定一个赛后重写的 Code。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(register int i=l;i<=r;i++)
#define _For(i,l,r) for(register int i=r;i>=l;i--)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1e5 + 10; 
inline ll read(){
    register ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(register ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	int l, r;
	bool operator<(const Node&rhs)const{
		if(l ^ rhs.l)
		  return l < rhs.l;
		return r < rhs.r;
	}
}f[N];
int T, n, m, cnt, L, V, ans1, ans2;
int d[N], v[N], a[N], p[N];
void solve(){
	ans1 = ans2 = cnt = 0;
	n = read(), m = read(), L = read(), V = read();
	for(int i = 1; i <= n; ++i){
		d[i] = read();
		v[i] = read();
		a[i] = read();
	}
	for(int i = 1; i <= m; ++i)
	  p[i] = read();
	for(int i = 1; i <= n; ++i){
		if(a[i] > 0){
			if(v[i] > V){
				int it = lower_bound(p + 1, p + m + 1, d[i]) - p;
				if(it != m + 1){
					++ans1;
					f[++cnt] = {it, m};
				}
			}
			else{
				int h = d[i] + (V * V - v[i] * v[i]) / (a[i] << 1);
				int it = upper_bound(p + 1, p + m + 1, h) - p;
				if(it != m + 1){
					++ans1;
					f[++cnt] = {it, m};
				}
			}
		}
		else if(a[i] < 0){
			if(v[i] <= V)
			  continue;
			int h = d[i] + (v[i] * v[i] - V * V - 2 * a[i] - 1) / (-2 * a[i]);
			int it = lower_bound(p + 1, p + m + 1, d[i]) - p;
			if(it != m + 1 && p[it] < h){
				++ans1;
				f[++cnt].l = it;
				it = lower_bound(p + 1, p + m + 1, h) - (p + 1);
				f[cnt].r = it;
			}
		}
		else{
			if(v[i] <= V)
			  continue;
			int it = lower_bound(p + 1, p + m + 1, d[i]) - p;
			if(it != m + 1){
				++ans1;
				f[++cnt] = {it, m};
			}
		}
	}
	sort(f + 1, f + cnt + 1);
	int Min = 1e5 + 10;
	for(int i = 1; i <= cnt; ++i){
//		cerr << f[i].l << ' ' << f[i].r << '\n';
		if(f[i].l > Min){
			++ans2;
			Min = f[i].r;
			continue;
		}
		Min = min(Min, f[i].r);
	}
	if(Min != 1e5 + 10)
	  ++ans2;
	write(ans1);
	putchar(' ');
	write(m - ans2);
	putchar('\n');
}
bool End;
int main(){
//	open("A.in", "A.out");
	T = read();
	while(T--)
	  solve();
	cerr<<'\n'<<abs(&Begin-&End)/1048576<<"MB";
	return 0;
}
```

---

## 作者：yyrwlj (赞：3)

## 解题思路
首先容易发现每个车辆肯定都是在一段区间内会被检测出超速，可以使用二分求出这些区间。

然后题意可以转化为给定一些区间，选择尽量少的点使得每个区间内至少有一个选择的点。

考虑 dp，设 $f_i$ 表示选取第 $i$ 个点，且让前 $i$ 个点涉及到的区间满足要求的最小选点数。

考虑枚举上一个选择的点，我们不能让这两个点中间存在区间，所以可以把区间按右端点排序，然后二分找到满足右端点小于 $i$ 的区间前缀 $[1,p]$。

我们可以预处理区间的前缀左端点最大值 $Lmax$，那么上一个选择的点 $j$ 必须满足 $j \ge Lmax_p$。

发现可以转移的状态处于一个区间，于是用线段树维护区间最小值即可。

后来发现这部分也可以单调队列维护。

## tips

对于计算瞬时速度，可以把根号运算转化为不等式另一侧的平方运算，从而避免浮点数运算。

```cpp
#include <bits/stdc++.h>
#define lowbit(o) o & -o
#define pb push_back
#define x first
#define y second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int, int> PII;
typedef pair<LL, LL> PLL;
const int N = 100005;
const int mod = 998244353;
const int inf = 5e5;
const LL INF = 1e18;
int d[N], v[N], a[N], p[N];
struct Line{
	int l, r;
}c[N];
int w[N << 2], Lmax[N], f[N];
bool cmp(Line A,Line B)
{
	if (A.r != B.r)
		return A.r < B.r;
	return A.l < B.l;
}
LL calc(LL v,LL a,LL d,LL pos)
{
	LL s = pos - d;
	return v * v + 2 * a * s;
}
inline void pushup(int u)
{
	w[u] = min(w[u << 1], w[u << 1 | 1]);
}
void build(int u,int l,int r)
{
	if (l == r)
	{
		w[u] = 1000000;
		if (!l)
			w[u] = 0;
		return;
	}
	int mid = (l + r) >> 1;
	build(u << 1, l, mid);
	build(u << 1 | 1, mid + 1, r);
	pushup(u);
}
void update(int u,int l,int r,int x,int v)
{
	if (l == r)
	{
		w[u] = v;
		return;
	}
	int mid = (l + r) >> 1;
	if (x <= mid)
		update(u << 1, l, mid, x, v);
	else
		update(u << 1 | 1, mid + 1, r, x, v);
	pushup(u);
}
int query(int u,int l,int r,int L,int R)
{
	if (L <= l && r <= R)
		return w[u];
	int mid = (l + r) >> 1, res = 1000000;
	if (L <= mid)
		res = query(u << 1, l, mid, L ,R);
	if (mid < R)
		res = min(res, query(u << 1 | 1, mid + 1, r, L, R));
	return res;
}
void work()
{
	int n, m, L;
	LL V;
	cin >> n >> m >> L >> V;
	for (int i=1;i<=n;i++)
		cin >> d[i] >> v[i] >> a[i];
	for (int i=1;i<=m;i++)
		cin >> p[i];
	int tot = 0;
	for (int i=1;i<=n;i++)
	{
		if (p[m] < d[i])
			continue;
		int l = lower_bound(p + 1, p + m + 1, d[i]) - p, r = m, res = 0;
		if (a[i] > 0)
		{
			while (l <= r)
			{
				int mid = (l + r) >> 1;
				if (calc(v[i], a[i], d[i], p[mid]) > V * V)
					res = mid, r = mid - 1;
				else
					l = mid + 1;
			}
			if (res)
			{
				c[++ tot] = {res, m};
				//cout << "1\n";
			}
		}
		else if (a[i] == 0)
		{
			if (v[i] > V)
				c[++ tot] = {l, m};
			//cout << "2\n";
		}
		else
		{
			int L = l;
			while (l <= r)
			{
				int mid = (l + r) >> 1;
				if (calc(v[i], a[i], d[i], p[mid]) > V * V)
					res = mid, l = mid + 1;
				else
					r = mid - 1;
			}
			if (res)
			{
				c[++ tot] = {L, res};
				//cout << "3\n";
			}
		}
	}
	cout << tot << ' ';
	if (!tot)
	{
		cout << m << '\n';
		return;
	}
	sort(c + 1, c + tot + 1, cmp);
	for (int i=1;i<=tot;i++)
		Lmax[i] = max(Lmax[i - 1], c[i].l);
	build(1, 0, m);
	for (int i=1;i<=m;i++)
	{
		int l = 1, r = tot, res = 0;
		while (l <= r)
		{
			int mid = (l + r) >> 1;
			if (c[mid].r < i)
				res = mid, l = mid + 1;
			else
				r = mid - 1;
		}
		f[i] = query(1, 0, m, Lmax[res], i - 1) + 1;
		update(1, 0, m, i, f[i]);
	}
	int ans = 1000000;
	for (int i=1;i<=m;i++)
		if (i >= Lmax[tot])
			ans = min(ans, f[i]);
	cout << m - ans << '\n';
}
signed main()
{
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    int _T = 1;
    cin >> _T;
    while (_T--)
        work();
    return 0;
}
```

---

## 作者：FreedomKing (赞：2)

赛时二分写挂，补个题解记录一下。

### 思路

考虑将问题以两个输出分为两部分。

对于第一部分，显然我们可以依据题目中给出的式子得出以下结论：

$$t_i=\tfrac{V-v_i}{a_i}$$

$$\Delta d=v_it_i+\tfrac{1}{2}a_it_i^2$$

其中 $t_i$ 代表第 $i$ 辆车在经过 $t_i$ 的时间后速度达到限速 $V$，$\Delta d$ 代表这段时间中的位移，这时的 $d'_i$ 便等于 $d_i+\Delta d$，考虑如下分讨：

- 若初速度大于限速，即 $v_i>V$，存在两种情况：若 $a_i\ge 0$ 显然第 $i$ 辆车超速了且能被检测到超速的区间是 $(d_i,L]$；若 $a_i<0$ 则第 $i$ 辆车超速了但能被检测到超速的区间只有 $[d_i,d'_i)$。

- 否则就是 $v_i\le V$，也存在两种情况：若 $a_i\le 0$ 则一定不会超速；若 $a_i>0$ 则可被检测到超速的区间为 $(d'_i,L]$，注意这里与第一类的第一种情况不同。

处理出来了每辆车的超速区间考虑如何统计可以被检测到的车辆，发现可以直接使用类似双指针的东西，将区间按照以 $l_i<l_j$ 为第一关键字，$r_i>r_j$ 为第二关键字排序，然后全部依次入队，有序枚举检测点 $f_i$，把一定不合法的或已经确定可以被检测的车辆出队即可。

对于第二部分，依然考虑使用上面处理出来的超速区间求解，发现直接做是不好做的，考虑一个经典 trick，显然若一个区间包含另一个区间，则若另一个区间中存在保留的检测点，这个区间一定也能被检测到，所以可以只考虑那个被包含的区间。这样问题就转换成了若干个允许相交但不存在包含关系的线段的点覆盖问题，一个显然的贪心就是对于最左边的没有被覆盖的线段，保留其线段上最靠右的检测点，一定更有可能对后边的线段产生贡献，记一个 last 表示最靠右的被确定保留的检测点即可。

乐子：这个人因为第二部分的 lowerbound 边界写挂了导致此题分数处于 $[0,80]$。

### 代码

懒得 remake 了等有了下发数据了再更新。

---


# 西湖有雅座

## 题目背景

>江湖路上走走停停，翻开年少漂泊的回忆。
如今走过这世间，万般留恋，风吹起了从前 。

## 题目描述

孙亦谐准备建西湖雅座来开饭馆。

他有 $n$ 个零件，零件的大小均为 $h\times w$。零件从 $1 \sim n$ 编号。

对于一个大小为 $h \times w$ 的零件，其可视为一个 $h$ 行 $w$ 列的矩阵 $w$。若用 $a_{i,j}$ 来表示这个矩阵中第 $i$ 行第 $j$ 列的元素。对于 $\forall a_{i,j}$，都有 $a_{i,j}\in \left \{  0,1\right \} $。

则编号为 $i$ 的零件的面积为： $S\left(i\right) = \sum_{i = 1}^{h}\sum_{j = 1}^{w}a_{i,j} $。

若编号为 $l$ 和 $r$ 的两个零件的分别表示为矩阵 $a$ 和 $b$，其在同一座楼的稳固程度可表示为： 

$$f\left(l,r\right) = \sum_{i = 1}^{h} \sum_{j = 1}^{w} \left [ (a_{i,j} = 1) \text{ and } (b_{i,j} = 1) \right ]$$

孙亦谐需要将这 $n$ 个零件先选取若干个按照任意顺序排列搭成大楼，然后把剩余的零件搭成小楼。若没有剩余零件，则可以不搭小楼。

设 $U$ 表示某座楼选取的零件编号的集合，则这座楼能成功搭建的条件是：

$$\forall i,j \in U,f\left (i,j\right) \ge \lceil \frac{ \min \left ( S\left(i \right),S\left(j\right) \right) }{2}\rceil$$

孙亦谐想知道在保证两座楼能成功搭建的条件下，让大楼使用的零件数尽量多。若无法成功搭建，则直接输出 `-1`。




## 说明/提示

**【样例1解释】**

可以证明最优方案是用第一个零件和第三个零件搭大楼，用第二个零件搭小楼。

**【数据范围】**

**本题采用捆绑测试**。

- Subtask 1（30 points）：$n \le 20$。
- Subtask 2（5 points）：$w = h = 1$。
- Subtask 3（65 points）：无特殊限制。

对于所有测试数据，$1 \le n \le 1000$，$1 \le w,h \le 6$。

## 样例 #1

### 输入

```
3 2 2
0 1 
1 1
1 0
0 0
0 1
0 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 2 2
0 1
1 0
0 0
0 1
1 0
0 0
```

### 输出

```
-1```

# 题解

## 作者：wangyizhi (赞：7)

[**题目传送门**](https://www.luogu.com.cn/problem/P11409)

简单的图论题。

~~赛时竟然一发过了，难以置信。~~

## 题目分析

注意到题目中有这个条件：当 $f(i,j)\ge\lceil\frac{\min(S(i),S(j))}{2}\rceil$ 时，$i$，$j$ 可以放在一起。对于这样的二元关系，很容易想到用图论建模。

先尝试将所有可以放在一起的对连边。由于一座楼要成功搭建需要其中的任意不相同点对之间有边，所以我们需要将这个图划分成两个完全图（其中一个可以为空），答案就是较大的那一半的点数。

但很多和完全图有关的问题都是较难做的。因此我们需要进一步转化。注意到我们要将原图划分成**两**个完全图，所以可以联想到将它转化成二分图（好吧其实应该是个板子）。原图和二分图肯定没啥关系，于是尝试建补图。通过手模可以发现，**如果补图是二分图，那么就原图可以划分成两个完全图**。下面略微证明一下：

假设补图不是二分图，那么一定存在奇环。奇环的最小长度为 $3$，因此奇环上的任意三个点在原图上都没有边，所以这三个点只能被划分在三个完全图中。故原命题成立。

那接下来只需判断补图是否是二分图了。这就非常简单了，直接二分图染色就行了（赠送[板子题链接](https://www.luogu.com.cn/problem/P1330)）。然后对于二分图的每个连通块，取两个颜色中最多的加到答案里。

然后就做完了。

建图时间复杂度 $O(n^2hw)$，染色复杂度 $O(n)$。总的时间复杂度为 $O(n^2hw)$。

## AC Code

```cpp
// by wangyizhi(571247)
// link: https://www.luogu.com.cn/record/194622542
// 不要试图直接复制哦！
#include<iostream>
#include<vector>
using namespace std;
int a[1001][18][18],s[1001];
vector<int> g[1001];
int c[1001],to[1001],k[1001][3];
void dfs(int u,int st)
{
	to[u]=st,k[st][c[u]]++; // 统计在 st 的这个连通块中的两种颜色的数量
	for(int v:g[u])
	{
		if(c[v]==c[u]) // 如果相邻两点被染了相同的颜色，则有奇环，不成立
		{
			cout<<-1;
			exit(0);
		}
		if(to[v]) continue;
		c[v]=3-c[u]; // 相邻两点颜色不相同 1->2 2->1
		dfs(v,st);
	}
}
int main()
{
	int n,h,w;
	cin>>n>>h>>w;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=h;j++)
			for(int k=1;k<=w;k++)
			{
				char c;
				cin>>c;
				a[i][j][k]=c-'0',s[i]+=a[i][j][k];
			}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) if(i!=j)
		{
			int cnt=0;
			for(int x=1;x<=h;x++)
				for(int y=1;y<=w;y++)
					cnt+=(a[i][x][y]&a[j][x][y]);
			if(cnt<(min(s[i],s[j])+1)/2) // 建图：对不满足条件的点对连边
				g[i].push_back(j);
		}
	for(int i=1;i<=n;i++) if(!to[i]) c[i]=1,dfs(i,i); // 如果没染色过就从这开始染
	int ans=0;
	for(int i=1;i<=n;i++)
		ans+=max(k[i][1],k[i][2]); // 取较大的加进去
	cout<<ans;
	return 11;
}
```

---

## 作者：tuntunQwQ (赞：4)

前置知识：染色法判二分图。

容易想到，我们可以将所有满足 $f\left (i,j\right) \ge \lceil \frac{ \min \left ( S\left(i \right),S\left(j\right) \right) }{2}\rceil$ 的两个零件 $i,j$ 连一条无向边。最后判断整张图是否可以拆分成两个完全图，若可以，输出点数更多的那个完全图的点数；否则输出 $-1$。

但我们很难判断整张图是否可以拆分成两个完全图。注意到一个完全图的补图边数为 $0$，也就是说，如果一张图可以拆分成两个完全图，那么这张图的补图就一定是二分图；如果一张图的补图就一定是二分图，那么这张图就一定可以拆分成两个完全图。

那我们就可以将所有满足 $f\left (i,j\right) < \lceil \frac{ \min \left ( S\left(i \right),S\left(j\right) \right) }{2}\rceil$ 的两个零件 $i,j$ 连一条无向边，最后用染色法判断整张图是否为二分图，若是，输出最多能有多少点可以染成相同的颜色；否则输出 $-1$。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,h,w,a[N][10][10],cnt1,cnt2;
int color[N],e[N*N],hh[N],nxt[N*N],idx;
void add(int a,int b){
	e[++idx]=b,nxt[idx]=hh[a],hh[a]=idx;
}
bool dfs(int u,int c){
	color[u]=c;
	if(c==1)cnt1++;
	else cnt2++;
	for(int i=hh[u];i;i=nxt[i]){
		int v=e[i];
		if(!color[v]){
			if(!dfs(v,3-c))return false;
		}
		else if(color[v]==c)return false;
	}
	return true;
}
int s(int u){
	int sum=0;
	for(int i=1;i<=h;i++){
		for(int j=1;j<=w;j++){
			sum+=a[u][i][j];
		}
	}
	return sum;
}
int f(int l,int r){
	int sum=0;
	for(int i=1;i<=h;i++){
		for(int j=1;j<=w;j++){
			sum+=(a[l][i][j]&a[r][i][j]);
		}
	}
	return sum;
}
int main(){
	cin>>n>>h>>w;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=h;j++){
			for(int k=1;k<=w;k++){
				cin>>a[i][j][k];
			}
		}
	}
	for(int l=1;l<=n;l++){
		for(int r=1;r<=n;r++){
			if(l!=r&&f(l,r)<ceil(1.0*min(s(l),s(r))/2)){
				add(l,r);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(!color[i]){
			if(!dfs(i,1)){
				ans=-1;
				break;
			}else{
				ans+=max(cnt1,cnt2);
				cnt1=cnt2=0;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：yingxilin (赞：3)

# 题解：P11409 西湖有雅座
[题目转送带](https://www.luogu.com.cn/problem/P11409)
## 简洁思路
由于数据比较小，可以先预处理出任何两个零件是否能出现在同一栋大楼上。即枚举所有的两个零件，根据题意去模拟判断条件是否满足： 
$$\forall i,j \in U,f\left (i,j\right) \ge \lceil \frac{ \min \left ( S\left(i \right),S\left(j\right) \right) }{2} \rceil$$  
若不符合则连一条边。然后便可以直接转化为二分图染色问题求解。
## 关于二分图染色的简洁说明
把二分图中不能处于同一集合的点连一条边，在该边两端染上不同颜色，即 0 和 1 。若出现矛盾则说明不能成立，直接返回。（这只是笔者自己的简洁理解，若要掌握二分图染色还是要自己去找博客系统学习）
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h,w;
const int N=1005;
int a[1000+5][10][10];
int t[N];
vector<int>g[N];
int k[N];
int s[N];
int ans;
bool dfs(int u,int c){
	k[u]=c;s[c]++;
	for(auto v:g[u]){
		if(k[v]==k[u]) return false;
		if(k[v]==-1&&!dfs(v,1-c)) return false;
	}
	return true; 
}
int main(){
	cin>>n>>h>>w;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=h;j++)
			for(int k=1;k<=w;k++){
				cin>>a[i][j][k];
				t[i]+=a[i][j][k];
			}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(i==j) continue;
			int f=0;
			for(int x=1;x<=h;x++)
				for(int y=1;y<=w;y++){
					f+=a[i][x][y]&&a[j][x][y];
				}
			if(f<(min(t[i],t[j])+1)/2){
				g[i].push_back(j);
				g[j].push_back(i);
			}
		}
	memset(k,-1,sizeof k);
	for(int i=1;i<=n;i++){
		int p0=s[0];
		int p1=s[1];
		if(k[i]==-1&&!dfs(i,1)){
			cout<<-1<<endl;
			return 0;
		}
		ans+=max(s[0]-p0,s[1]-p1);
	}
	cout<<ans<<endl;
	return 0;
}
```
## 本题后记 
本题为 2024 年 12 月的 [[DHOI] Round 1](https://www.luogu.com.cn/contest/218668) 洛谷比赛中,数据实在过水。同机房的 [QC](https://www.luogu.com.cn/user/690795) dalao 直接写了个假贪心过了第二和第三个包（难以想象），而 [FRZ](https://www.luogu.com.cn/user/1134636) dalao 则写出了第一个包，于是……  
超级缝合怪。
## 水数据点AC_code
```cpp
#ifndef ONLINE_JUDGE
#define FRZ_29
#endif

#include <bits/stdc++.h>

using namespace std;

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned;
//using i128 = __int128;

const int N = 1005;

#define PRINT(x) cout << #x << " = " << x << "\n"
#define LF(i, l, r) for (int i = (l); i <= (r); i++)
#define RF(i, r, l) for (int i = (r); i >= (l); r++)

int n, h, w, s[N], f[N][N];
int m[N][10][10], ans;
vector<int> U;
bool vis[N];

bool check() {
  LF(i, 0, U.size() - 1) {
    LF(j, i + 1, U.size() - 1) {
      if (f[U[i]][U[j]] < (min(s[U[i]], s[U[j]]) + 1) / 2) {
        return false;
      }
    }
  }

  LF(i, 1, n) {
    if (vis[i]) continue;
    LF(j, i + 1, n) {
      if (vis[j]) continue;
      if (f[i][j] < (min(s[i], s[j]) + 1) / 2) return false;
    }
  }

  return true;
}

void dfs(int d) {
  if (d == n + 1) {
    if (check()) ans = max(ans, max((int)(n - U.size()), (int)(U.size())));
    return;
  }

  U.push_back(d);
  vis[d] = 1;
  dfs(d + 1);
  U.pop_back();
  vis[d] = 0;
  dfs(d + 1);
}
int a[1005][15][15];
int sum[1005];//f[1005][1005];
int num[1005][1005];
struct node
{
    int id,s;
}frz[1005];
bool cmp(node x,node y){return x.s<y.s;}
inline int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-'){f=-1;}c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(int)(c-'0');c=getchar();}
    return x*f;
}
inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
inline void solve()
{   
//    cin>>n>>h>>w;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=h;j++)
            for(int k=1;k<=w;k++) cin>>a[i][j][k],sum[i]+=a[i][j][k];
    for(int oi=1;oi<=n;oi++)
    {
        for(int oj=1;oj<=n;oj++)
        {
            if(oj==oi) continue;
            for(int i=1;i<=h;i++)
                for(int j=1;j<=w;j++) f[oi][oj]=f[oi][oj]+(a[oi][i][j]&a[oj][i][j]);
        }
    }
    for(int i=1;i<=n;i++)
    {
        frz[i].id=i;
        for(int j=1;j<=n;j++)
        {
            // if(i==j) continue;
            // cout<<f[i][j]<<" "<<((min(sum[i],sum[j])+1)/2)<<endl;
            if(f[i][j]<((min(sum[i],sum[j])+1)/2))
            {
                num[i][j]=1;
            }
            frz[i].s+=num[i][j];
        }
    }
    sort(frz+1,frz+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        int kkk=frz[i].id;
        if(vis[kkk]==0)
        {
            ans++;
            for(int j=1;j<=n;j++)
            {
                if(num[kkk][j]==1)
                {
                    vis[j]=1;
                }
            }
        }
    }
    if(ans==1) cout<<-1<<endl;
    else cout<<ans<<endl;

}

int main() {
//#ifdef FRZ_29
//  freopen("code.in", "r", stdin);
//  freopen("code.out", "w", stdout);
//#endif

  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  
  cin >> n >> h >> w;
	if(n>20) {solve();return 0;} 
  LF(i, 1, n) LF(j, 1, h) LF(k, 1, w) {
    cin >> m[i][j][k];
    s[i] += m[i][j][k];
  }

  LF(i, 1, n) LF(j, i + 1, n) LF(k, 1, h) LF(p, 1, w)
    f[i][j] += (m[i][k][p] & m[j][k][p]);
  
  dfs(1);
  cout << (ans == 0 ? -1 : ans);
  return 0;
}


// START AT 2024 / 12 / 15 13 : 56 : 15
```
水完了。  
yingxilin  
Qian·JX のjoker   
2024-12-18 于玉山一中

---

## 作者：Beihai_Jiang (赞：1)

# P11409 西湖有雅座

[P11409 西湖有雅座 - 洛谷](https://www.luogu.com.cn/problem/P11409)

## 题目描述

孙亦谐准备建西湖雅座来开饭馆。

他有 $n$ 个零件，零件的大小均为 $h\times w$。零件从 $1 \sim n$ 编号。

对于一个大小为 $h \times w$ 的零件，其可视为一个 $h$ 行 $w$ 列的矩阵 $w$。若用 $a_{i,j}$ 来表示这个矩阵中第 $i$ 行第 $j$ 列的元素。对于 $\forall a_{i,j}$，都有 $a_{i,j}\in \left \{  0,1\right \} $。

则编号为 $i$ 的零件的面积为：$S\left(i\right) = \sum_{i = 1}^{h}\sum_{j = 1}^{w}a_{i,j} $。

若编号为 $l$ 和 $r$ 的两个零件的分别表示为矩阵 $a$ 和 $b$，其在同一座楼的稳固程度可表示为： 
$$
f\left(l,r\right) = \sum_{i = 1}^{h} \sum_{j = 1}^{w} \left [ (a_{i,j} = 1) \text{ and } (b_{i,j} = 1) \right ]
$$
孙亦谐需要将这 $n$ 个零件先选取若干个按照任意顺序排列搭成大楼，然后把剩余的零件搭成小楼。若没有剩余零件，则可以不搭小楼。

设 $U$ 表示某座楼选取的零件编号的集合，则这座楼能成功搭建的条件是：
$$
\forall i,j \in U,f\left (i,j\right) \ge \lceil \frac{ \min \left ( S\left(i \right),S\left(j\right) \right) }{2}\rceil
$$
孙亦谐想知道在保证两座楼能成功搭建的条件下，让大楼使用的零件数尽量多。若无法成功搭建，则直接输出 `-1`。

## Solution

首先观察数据范围，$1\leq n\leq 1000$。

容易想到 $O(n^2)$ 预处理出每个零件之间是否满足成功搭建条件。

以每个零件为点，若两个零件满足条件，则两点连一条边。

建图后，原问题可转化成图中是否有两个连通子图。若有，最大连通子图的点数是多少。

要解决这个问题，我们需要建**补图**。

注意到连通图的补图中，点之间没有边，恰好满足二分图中两个点集内部没有边的定义。

所以若原图的补图是二分图，则原图中有两个连通子图。点染色判断即可。

再对每个二分图连通块取较大的点集的点数相加即为答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,h,w;
int g[N][10][10];
int s[N];
int f[N][N];
bool solve(int x,int y){
	if(x==y) return true;
	int res=0;
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++)
			res+=g[x][i][j]&g[y][i][j];
	return (res>=(min(s[x],s[y])+1)/2);
}
int c[N];
int val[3][N],cnt;
bool dfs(int x){
	for(int y=1;y<=n;y++){
		if(!f[x][y]) continue;
		if(!c[y]){
			c[y]=3-c[x];
			val[c[y]][cnt]++;
			if(!dfs(y)) return false;
		}
		else if(c[x]==c[y]) return false;
	}
	return true;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>h>>w;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=h;j++)
			for(int k=1;k<=w;k++)
				cin>>g[i][j][k],s[i]+=g[i][j][k];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(solve(i,j)) f[i][j]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=!f[i][j];
	for(int i=1;i<=n;i++)
		if(!c[i]){
			c[i]=1;
			val[c[i]][++cnt]++;
			if(!dfs(i)){
				cout<<-1;
				return 0;
			}
		}
	int ans=0;
	for(int i=1;i<=cnt;i++)
		ans+=max(val[1][i],val[2][i]);
	cout<<ans;
	return 0;
}
```

---


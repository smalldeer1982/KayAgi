# 昆明之泪

## 题目描述

给定一串长度为 $n$ 的数对序列 $(x_i,y_i)$，其中 $x_i, y_i$ 都是整数。

有 $m$ 次询问，每次给定一个两个整数 $a, b$，你需要先选定一个整数 $k$（注意 $k$ 可以为 $0$），然后再选定一个正整数序列 $1 \le p_1 < p_2 < \cdots < p_k \le n$（若 $k = 0$ 则该序列为空），使得
$$
\min\left(a + \sum\limits_{i = 1}^{k} x_{p_i} , b + \sum\limits_{i = 1}^{k} y_{p_i}\right)
$$ 

最大，输出这个最大值。



## 说明/提示

$1\le n \le 10^3$，$0\le \sum \lvert x_i\rvert \le 10^5$，$0\le \lvert y_i \rvert \le 10^{12}$，$1\le m \le 2\times 10^5$，$0\le \lvert a\rvert, \lvert b\rvert \le 10^{12}$。

## 样例 #1

### 输入

```
2
2 -3
3 -2
1
1 6```

### 输出

```
4```

# 题解

## 作者：BrotherCall (赞：5)

这里是官方题解。

题目名由来：这题是作者打完昆明站痛定思痛在返程飞机上随出来的题。

题解：对于数对 $(x_i,y_i)$，一共只有四种情况。为了方便讨论，以下均不考虑 $x_i = 0$ 且 $y_i = 0$ 的情况（对结果没影响）。

1. $x_i \ge 0$ 且 $y_i \ge 0$，这种情况的数对是必定要选的，直接加入贡献。
2. $x \le 0$ 且 $y_i \le 0$，这种情况的数对是必定不选的，直接舍弃。
3. $x_i > 0$ 且 $y_i < 0$，由于 $\sum\lvert x_i\rvert \le 10^5$ 且 $n \le 10^3$，可以用 $O(n\cdot \sum\lvert x_i\rvert)$ 的 $\text{dp}$ 预处理出来“凑出 $\sum x \ge i$ 的最大的 $\sum y$”。处理询问的时候二分即可。
4. $x_i < 0$ 且 $y_i > 0$，先将该数对加入贡献，再取反成 $(-x_i,-y_i)$，这样就转化成了第三种情况的样子。

设 $s = \sum \lvert x_i\rvert$，则总复杂度为 $O(ns+m\log s)$。

---

验题的时候发现情况 1 可以并入情况 3，情况 2 可以并入情况 4。

这样只需要分 $x_i$ 的正负后 $\text{dp}$ 套二分即可，做法同上。

---

难度评估：绿。

---

## 作者：Night_sea_64 (赞：3)

这题比较简单，但我场上因为来晚+中途离开导致最后没调出来。

基本上看到数据范围就能会这道题了。发现 $x$ 之和很小，所以直接考虑背包，$f(j)$ 为 $x$ 之和为 $j-10^5$，$y$ 之和的最大值。转移一下即可，唯一需要注意的就是 $x$ 的正负需要分类。

然后看那个询问。把式子整体减去 $b$，变成了

$$\min\left(a - b + \sum\limits_{i = 1}^{k} x_{p_i}, \sum\limits_{i = 1}^{k} y_{p_i}\right)$$

这里 $\sum\limits_{i = 1}^{k} y_{p_i}$ 就是 $f\left(\sum\limits_{i = 1}^{k} x_{p_i}\right)$ 的值。考虑二分答案为 $mid$，则 $\sum\limits_{i = 1}^{k} x_{p_i}\ge mid+b-a$，满足这个情况的前提下还要找到至少一个 $\sum\limits_{i = 1}^{k} x_{p_i}$，使得 $f\left(\sum\limits_{i = 1}^{k} x_{p_i}\right)\ge mid$。

这样的话，给 $f$ 数组做一个后缀 max，就可以求出了。

时间复杂度为 $O(nW_x+m\log W_y)$。其中 $W_x=10^5,W_y=10^{12}$。

```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;
int n,m,x[1010],y[1010];
int f[200010];
bool chk(int a,int b,int k)
{
    if(k+b-a>200000)return 0;
    return f[max(0ll,k+b-a)]>=k;
}
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
    memset(f,-999999,sizeof(f));
    f[100000]=100000;
    for(int i=1;i<=n;i++)
    {
        if(x[i]>=0)
        {
            for(int j=200000;j>=x[i];j--)
                f[j]=max(f[j],f[j-x[i]]+y[i]);
        }
        else
        {
            for(int j=0;j<=200000+x[i];j++)
                f[j]=max(f[j],f[j-x[i]]+y[i]);
        }
    }
    for(int i=200000;i>=0;i--)f[i]=max(f[i],f[i+1]);
    cin>>m;
    while(m--)
    {
        int a,b;
        cin>>a>>b;
        int l=-1e12,r=200000+a-b,ans=100000-b;
        while(l<=r)
        {
            int mid=(l+r)/2;
            if(chk(a,b,mid))l=mid+1,ans=mid;
            else r=mid-1;
        }
        cout<<ans-100000+b<<endl;
    }
    return 0;
}
```

---

## 作者：lcfollower (赞：1)

今天模拟赛 T4。

可以考虑无脑 dfs，时间复杂度为 $\mathcal O(2^nm)$，不能通过。

然后观察数据范围中：

- $1\le n\le 10^3$，猜测 $\mathcal O(mn)$。

- $0\le \sum \lvert x_i\rvert\le10^5$ 但是 $0\le \lvert y_i\rvert \le 10^{12}$，猜测时间复杂度与 $x$ 的值域有关。

然后怎么想都不会 $\mathcal O(mn)$，于是考虑第二种。

套路，设 $f_{i ,j}$ 表示前 $i$ 个序列 $\left(x,y\right)$ 中选出 $k$（$k$ 在题目中已知）个，使得  $\sum\limits_{num=1}^k x_{p_{num}}=j$ 时 $\sum\limits_{num=1}^k y_{p_{num}}$ 的最大值。

转移方程如下：

- 不选这对序列，则 $f_{i ,j} = f_{i - 1 ,j}$。

- 选这对序列，则 $f_{i ,j} = f_{i - 1 ,j - x_i} + y_i$。

观察到此时第一维只与 $i - 1$ 有关，于是考虑和背包一样的滚动套路，则有 $f_{j} = \max\{f_j,f_{j-x_i}\ + y_i\}$。

此时需要注意转移是从**没有**更新过的转移到当前状态，所以需要按 $x$ 的正负性讨论，如下：

$\begin{cases}f_j = \max\limits_{j=x_i}^{V}\{f_{j - x_i} + y_i ,f_j\}^{\textcircled{1}} & x_i > 0\\ f_j = \max\limits_{0}^{j=V+x_i}\{f_{j - x_i} + y_i ,f_j\}^{\textcircled{2}} & x_i\le 0 \end{cases}$

其中 $\textcircled{1}$ 为倒序枚举，$\textcircled{2}$ 为顺序枚举。

其中 $V$ 是值域，为 $2\times 10^5$。

因为 $x_i$ 可能为负数，所以考虑偏移 $10^5$，即设 $f_{j}$ 表示 $\left(x,y\right)$ 中选出 $k$（$k$ 在题目中已知）个，使得  $\sum\limits_{num=1}^k x_{p_{num}}=j-10^5$ 时 $\sum\limits_{num=1}^k y_{p_{num}}$ 的最大值。

把这堆东西预处理，询问的时候即输出 $\max\limits_{j = 0}^{V}\left(\min\{a+j,b+f_j\}\right)$。

时间复杂度为 $\mathcal O((n+m)V)$，是个~~劣质~~的复杂度，会超时。

---

考虑优化。

首先对 $f$ 进行一遍后缀最大值，此时 $f_j$ 代表 $\left(x,y\right)$ 中选出 $k$（$k$ 在题目中已知）个，使得  $\sum\limits_{num=1}^k x_{p_{num}}\ge j-10^5$ 时 $\sum\limits_{num=1}^k y_{p_{num}}$ 的最大值。

此时可以发现 $x=\min(a+j,b+f_j)$ 是个三分函数，直接套上三分即可。

注意控制上限和下限，不然会出错。

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e18

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

const int N = 1005 ,V = 2e5 ,mod = 1e9 + 7;
int n ,under = 1e5 ,above = 1e5,x[N] ,y[N] ,f[V + 10]; 

inline void fre (){
  freopen ("make.in" ,"r" ,stdin);
  freopen ("make.out" ,"w" ,stdout);
} inline void init (){
  up (i ,under ,above) f[i] = -inf;

  f[100000] = 0;
  
  up (i ,1 ,n){
  	if (x[i] > 0) dn (j ,above ,x[i]) f[j] = max (f[j] ,f[j - x[i]] + y[i]);
  	else up (j ,under ,above + x[i]) f[j] = max (f[j] ,f[j - x[i]] + y[i]);
  } 

  dn (i ,above - 1 ,under) f[i] = max (f[i] ,f[i + 1]);
  
} inline int check (int a ,int b ,int mid){
  return min (a + mid - 100000 ,b + f[mid]);
} inline void solve (){
  int a = read () ,b = read () ,l = under ,r = above ,ans = -inf;
  while (r - l > 5){
    int mid1 = (l + (r - l) / 3) ,mid2 = (r - (r - l) / 3);
    if (check (a ,b ,mid1) < check (a ,b ,mid2)) l = mid1;
    else r = mid2;
  } up (i ,l ,r) ans = max (ans ,check (a ,b ,i));
  writeln (ans);
} signed main (){
//  fre ();
  
  n = read () ;
  
  up (i ,1 ,n){
  	x[i] = read () ,y[i] = read ();
  	above += (x[i] > 0) * x[i];
  	under += (x[i] < 0) * x[i];
  }
  
  init ();
  
  int Q = read ();
  while (Q --) solve ();

  return 0;
}
```

---

## 作者：wei2013 (赞：0)

## 思路：
$x$ 很小，显然选择键值对换，设计状态：$dp_j$ 表示 $\sum x=j-1e5$ 时，$\sum y$ 的最大值。

预处理背包后，如果暴力查询显然是 $\mathcal{O(nm)}$ 的。

求的是最小值的最大值，是一个显然的二分模型。

小的肯定对最终答案没有贡献，所以对 $dp$ 数组做后缀最大值，使其具有单调性。

然后二分即可。
## code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=1005,MAXV=2e5+5;
int n,m,dp[MAXV],x[MAXN],y[MAXN],a,b;
bool check(int x){
	if(x+b-a-200000>0){
		return 0;
	}
	return dp[max(x+b-a,0ll)]>=x;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
	}
	memset(dp,0xc0,sizeof(dp));
	dp[100000]=100000;
	for(int i=1;i<=n;i++){
		if(x[i]>=0){
			for(int j=200000;j>=x[i];j--){
				dp[j]=max(dp[j],dp[j-x[i]]+y[i]);
			}
		}else{
			for(int j=0;j<=200000+x[i];j++){
				dp[j]=max(dp[j],dp[j-x[i]]+y[i]);
			}
		}
	}
	for(int i=200000;i>=0;i--){
		//if(i<=1000)cerr<<dp[i]<<" ";
		dp[i]=max(dp[i],dp[i+1]);
		
	}
	cin>>m;
	while(m--){
		cin>>a>>b;
		int l=-1e12,r=200000+a-b,ans=100000-b;
		while(l<=r){
			int mid=(l+r)>>1;
			if(check(mid)){
				ans=mid;
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		cout<<ans+b-100000<<endl;
	}
	return 0;
}
```

---

## 作者：gyyyyx (赞：0)

注意到 $\sum\left|x_i\right|\leq 10^5$，可以考虑用 DP 求出 $\sum x_{p_i}=t$ 时，$\sum y_{p_i}$ 的最大值。

设 $f_t$ 表示这个最大值。

那么答案就是 $\max\limits_{t}\{\min(a+t,b+f_t)\}$。

这个东西不好算，但是我们发现可以对 $f_t$ 求一遍后缀最大值，这样 $f_t$ 代表的就是 $\sum x_{p_i}\geq t$ 时，$\sum y_{p_i}$ 的最大值。

可以证明正确性不受影响。

这样的话 $y=\min(a+x,b+f_x)$ 就是一个单峰函数，可以用三分求出最大值。

时间复杂度 $O(n\sum x_i+m\log(\sum x_i))$。

最后注意如果用滚动数组要注意 $x_i$ 的正负。

代码：

```cpp
#include<bits/stdc++.h>
#define N 1005
#define P 100000
#define LL long long
using namespace std;
#define Calc(x) min(a+x-P,b+f[x])
int n,m,x[N],s(P),t(P);
LL y[N],f[(P<<1)+5];
int main(){
	scanf("%d",&n);
	for(int i(1);i<=n;++i){
		scanf("%d%lld",&x[i],&y[i]);
		if(x[i]<0) s+=x[i];else t+=x[i];
	}
	for(int i(s);i<=t;++i) f[i]=-1e18;f[P]=0;
	for(int i(1);i<=n;++i){
		if(x[i]>=0){
			for(int j(t);j>=x[i];--j)
				f[j]=max(f[j],f[j-x[i]]+y[i]);
		}
		else{
			for(int j(s);j<=t+x[i];++j)
				f[j]=max(f[j],f[j-x[i]]+y[i]);
		}
	}
	for(int i(t-1);i>=s;--i) f[i]=max(f[i],f[i+1]);
	scanf("%d",&m);
	while(m--){
		LL a,b,ans(-1e18);scanf("%lld%lld",&a,&b);
		int l(s),r(t);
		while(r-l>5){
			int m1(l+(r-l)/3),m2(r-(r-l)/3);
			Calc(m1)<Calc(m2)?l=m1:r=m2;
		}
		for(int i(l);i<=r;++i) ans=max(ans,Calc(i));
		printf("%lld\n",ans);
	}
	return 0;
}
```

其实还有一种做法。

我们可以把柿子减去 $b$，那么答案就是 $\max\limits_{t}\{\min(a−b+t,f_{t})\}+b$。

显然 $a-b$ 越大，最终答案的 $t$ 值越小。

可以把询问离线下来排序之后枚举 $t$，这样复杂度是 $O(n\sum x_i+m\log m+m)$。

---

## 作者：analysis (赞：0)

### P11470 昆明之泪

---

先不管 $a$、$b$，我们把 $\sum x$ 压入状态 DP，求出 $f_v$ 表示 $\sum x_i=v$ 时最大的 $\sum y_i$，可以做到 $O(nV)$，$V=10^5$。

问题就变成了对于所有二元组 $(a+v,b+f_v)$ 求 $\min(a+v,b+f_v)$。

不妨扩展为三元组 $(x,y,z)=(a+v,b+f_v,(b+f_v)-(a+v))=(a+v,b+f_v,(b-a)+(f_v-v))$。对于第三维，若 $z \leq 0$ 则贡献为 $y$，否则为 $x$。

由于常数 $b-a$ 的加减不会影响相对大小，所以我们可以先把三元组按照 $f_v-v$ 排序，每次询问时二分出分界点 $mid$ 使得前面的三元组都满足 $z \leq 0$，后面的都满足 $z>0$。预处理出前缀最大 $f_v$ 以及后缀最大 $v$ 后容易 $O(\log{n})$ 回答询问。

```cpp
#include<bits/stdc++.h>
const int N=2e5+10,py=1e5;
using ll=long long;
const ll inf=1e16;
using namespace std;
ll f[N],*g=(f+py);
int l,r;
inline void chkmax(ll &x,ll y){if(x<y)x=y;}
inline void rsh(int x,ll vl){
    for(int i=r;i>=l;i--)chkmax(g[i+x],g[i]+vl);
    r+=x;
}
inline void lsh(int x,ll vl){
    for(int i=l;i<=r;i++)chkmax(g[i-x],g[i]+vl);
    l-=x;
}
int n,m;
ll tpx,tpy,a,b,sx;
struct node{int a;ll b,c;}v[N];
int tot;
ll pre[N],sub[N];
signed main(){
    fill(f,f+N,-inf);
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;g[0]=0;
    for(int i=1;i<=n;i++){
        cin>>tpx>>tpy;
        if(tpx>=0)rsh(tpx,tpy);
        else lsh(-tpx,tpy);
    }
    for(int i=l;i<=r;i++)v[++tot]={i,g[i],g[i]-i};
    sort(v+1,v+1+tot,[](node a,node b){return a.c<b.c;});
    pre[0]=sub[tot+1]=-inf;
    for(int i=1;i<=tot;i++){
        pre[i]=pre[i-1];
        chkmax(pre[i],v[i].b);
    }
    for(int i=tot;i>=1;i--){
        sub[i]=sub[i+1];
        chkmax(sub[i],v[i].a);
    }
    cin>>m;
    while(m--){
        cin>>a>>b;sx=b-a;
        int l=0,r=tot;
        while(l<r){
            int mid=(l+r+1)>>1;
            if(v[mid].c+sx<0)l=mid;
            else r=mid-1;
        }
        ll ans=max(pre[l]+b,sub[l+1]+a);
        cout<<ans<<'\n';
    }
    return 0;
}
```

---


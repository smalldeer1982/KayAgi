# [CSP-J2022 山东] 宴会

## 题目背景

受疫情影响，山东省取消了 CSP-J 2022 认证活动，并于次年三月重新命题，在省内补办比赛。

## 题目描述

今人不见古时月，今月曾经照古人。梦回长安，大唐风华，十里长安花，一日看尽。

唐长安城是当时世界上规模最大、建筑最宏伟、规划布局最为规范化的一座都城。其营建制度规划布局的特点是规模空前、创设皇城、三城层环、六坡利用、布局对称、街衢宽阔、坊
里齐整、形制划一、渠水纵横、绿荫蔽城、郊环祀坛。而所谓的十里长安街，位于长安城的中轴线上，即唐长安城的朱雀大街，又称承天门大街。唐朝官员们住在各个“坊”里，上朝下朝都需要通过朱雀大街。

为了保持各大家族的联系和友谊，各官员往往会每月办一次宴会。为了方便描述，我们把朱雀大街看成一个数轴，各官员所居住的“坊”缩略为数轴上的一个坐标点。大家决定选一处地点（该地点是数轴上的某一个点，不一定坐标点）办宴会。由于唐朝宵禁严格，大家又都希望交流时间尽可能长，因此想要使宴会开始时间尽可能早。又因为大唐注重礼仪，因此，参加宴会的官员会花一定时间盛装打扮过后才前往宴会地点（不一定是坐标点）。

更具体地，一条纵向的街道上（相当于一维坐标）有 $n$ 个人居住，其中第 $i$ 个人居住在 $x_{i}$ （非负整数）位置（坐标点）上。每月他们会选择在 $x_{0}$（数轴上的某一个点，不一定坐标点）出举办宴会。

已知第 $i$ 个人从 $x_{i}$ 出发前往宴会地点 $x_{0}$ 处需要花费 $\left|x_{i}-x_{0}\right|$ 的时间，另外，他还需要花费 $t_{i}$ 的时间进行打扮，换言之，他共需要花费 $\left|x_{i}-x_{0}\right|+t_{i}$ 的时间到达宴会举办处。

假设**初始时刻为 $0$**。这 $n$ 个人开始打扮和出发前往宴会处，他们想要使得宴会的开始时间尽可能早，于是向你求助，请你帮助他们确定好最优的宴会举办地点 $x_{0}$。

注：$\left|x_{i}-x_{0}\right|$ 表示 $x_{i}$ 与 $x_{0}$ 之差的绝对值，且题目中 $n$ 个人的居住地点坐标均为整数。

## 说明/提示

### 样例说明

初始时刻为 $0$。

对于第一组测试数据只有 $1$ 个人，坐标为 $0$，打扮时间为 $3$，很显然 $x_{0}$ 就定在坐标 $0$ 处，使得宴会开始时间为 $3$ 且最早。

对于第二组测试数据有 $2$ 个人，坐标分别为 $3$、$1$，打扮时间均为 $0$，很显然 $x_{0}$ 定在坐标 $2$ 处，使得宴会开始时间为 $1$ 且最早。

对于第三组测试数据有 $2$ 个人，坐标分别为 $1$、$4$，打扮时间均为 $0$，很显然 $x_{0}$ 定在坐标 $2.5$ 处，使得宴会开始时间为 $1.5$ 且最早。

### 数据范围

对于 $30\%$ 的数据，$T=1,n\le100,0\le x_{i},t_{i}\le1000$；

对于 $60\%$ 的数据，$n\le10^{4},0\le x_{i},t_{i}\le10^{5}$；

对于 $100\%$ 的数据，$1\le T\le10^{3},n\le10^{5},0\le x_{i},t_{i}\le10^{8}$，且保证所有测试数据的 $n$ 加起来不超过 $2\times10^{5}$。


## 样例 #1

### 输入

```
7
1
0
3
2
3 1
0 0
2
1 4
0 0
3
1 2 3
0 0 0
3
1 2 3
4 1 2
3
3 3 3
5 3 3
6
5 4 7 2 10 4
3 2 5 1 4 6```

### 输出

```
0
2
2.5
2
1
3
6```

# 题解

## 作者：TainityAnle (赞：17)

### 题意

给定长度为 $n$ 的序列 $x$ 和 $t$，求出一个最小的 $x_0$，使得 $\max(t_i+|x_0-x_i|)$ 最小。

### 思路

这个题是大原题，[CF1730B](https://www.luogu.com.cn/problem/CF1730B)，连样例都一样。

发现无论 $x_0$ 怎么取，$t_i$ 对答案都没有影响。所以考虑把它转化一下。

如果没有 $t_i$ 的话，肯定是最左边的和最右边的中点最优。$t_i$ 可以这样转化：我们不妨考虑先把 $t_i$ 转成都往左走，取这时的最左边；再让所有人先往右走 $t_i$，取这时的最右，就可以得到答案。

因为 $x_i+t_i$ 最大的一定在最右边，$x_i-t_i$ 最小的一定在最左边，如果取最小的 $x_i-t_i$ 和最大的 $x_i+t_i$ 是正确的。

答案就是 $\dfrac{\max(x_i+t_i)+\min(x_i-t_i)}{2}$。

注意保留一位小数。

### AC Code

代码很简短。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[114514],n,x,T,maxx,minn;
double ans;
int main() {
	cin>>T;
	while(T--) {
		cin>>n;
		for(int i=1; i<=n; i++) cin>>a[i];
		maxx=-1000000007,minn=1000000007;
		for(int i=1; i<=n; i++) {
			cin>>x;
			maxx=max(maxx,a[i]+x);
			minn=min(minn,a[i]-x);
		}
		ans=(maxx+minn)/2.0;
		if(floor(ans)==ans) printf("%d\n",(int)ans);
		else printf("%.1f\n",ans);
	}
	return 0;
}
```

---

## 作者：Starry_Sky_135 (赞：8)

# 思路

不妨将问题转化一下：加上打扮的时间 $t_i$，相当于 $x_i$ 和举办地点 $x_0$ 之间的距离增加 $t_i$。

接下来的做法就显而易见了。枚举 $x_i-t_i$，求出最左端的点；同时枚举 $x_i+t_i$，求出最右端的点；再求出两者的中点得出答案。

# AC 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+8;
int n,T;
int x[N],t[N];
int main()
{
    cin>>T;
    while(T--)
    {
        cin>>n;
        for(int i=1;i<=n;i++) cin>>x[i];
        int l=1e9,r=0;
        for(int i=1;i<=n;i++)
        {
            cin>>t[i];
            l=min(l,x[i]-t[i]);
            r=max(r,x[i]+t[i]);
        }
        cout<<(l+r)/2.0<<endl;
    }
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：3)

容易证明，宴会的开始时间为：

$$
\max_{i}\{|x_i - x_0| + t_i\}.
$$

我们不妨设定开始时间为 $T$，那么：

$$
\begin{aligned}
\forall 1 \le i \le n, |x_i - x_0| \le T - t_i &\Rightarrow x_0 \in \Big[x_i - (T - t_i), x_i + (T - t_i)\Big] \\
&\Rightarrow x_0 \in \bigcap_{i = 1} ^ n \Big[x_i - (T - t_i), x_i + (T - t_i)\Big] \\
&\Rightarrow x_0 \in \Big[\max_{i}(x_i + t_i) - T, \min_{i}(x_i - t_i) + T\Big] \\
&\Rightarrow T = \frac{\max_{i}(x_i + t_i) - \min_{i}(x_i - t_i)}{2}.
\end{aligned}
$$

此时将 $T$ 带入原式：

$$
\begin{aligned}
x_0 &= \max_{i}(x_i + t_i) - T \\
&= \frac{\max_{i}(x_i + t_i) + \min_{i}(x_i - t_i)}{2}.
\end{aligned}
$$

时间复杂度 $O(n)$。

代码如下：

```cpp
int main() {
#if MULTI_TEST == 1
    LL T;
    std::cin >> T;
    while (T--) {
        // Test cases...
        auto Solve = [&]() -> void {
            int n;
            std::cin >> n;
            VLL x(n + 1, 0), t(n + 1, 0);
            for (int i = 1; i <= n; ++i)
                std::cin >> x[i];
            for (int i = 1; i <= n; ++i)
                std::cin >> t[i];
            LL a = -1e18, b = 1e18;
            for (int i = 1; i <= n; ++i) {
                cmax(a, x[i] + t[i]);
                cmin(b, x[i] - t[i]);
            }
            double x_0 = (a + b) / 2.0;
            if (fabs(x_0 - round(x_0)) < 1e-9)
                std::cout << (LL)round(x_0) << "\n";
            else
                std::cout << std::fixed << std::setprecision(1) << x_0 << "\n";
            };
        Solve();
    }
#else
#endif
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11854)

~~用三分做的，码了挺多的，应该不是正解。~~

也就黄？因为[三分模板](https://www.luogu.com.cn/problem/P1883)是黄。

因为所有官员到达某点的最晚时间关于该点坐标的函数是一个单峰函数，所以可以使用三分查找来找到这个函数的最小值点。我们计算一下每个官员到达该地点所需的时间（包括打扮时间），其中的最大值即为该地点对应的最晚时间。然后三分是板子，最后整数直接输出，小数保留一位输出。

```cpp
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cmath>
using namespace std;

const int N = 1e5 + 5;
const double eps = 1e-7;

int T, n, x[N], t[N];

double Calc(double mid) {
  double ans = 0;
  for (int i = 1; i <= n; i++) {
    double tim = abs(x[i] - mid) + t[i];
    ans = max(ans, tim);
  } return ans;
}

double Find() {
  double l = *min_element(x + 1, x + 1 + n); // 懒得用循环求了
  double r = *max_element(x + 1, x + 1 + n); // 同上
  while (r - l > eps) {
    double mid1 = l + (r - l) / 3;
    double mid2 = r - (r - l) / 3;
    double tim1 = Calc(mid1);
    double tim2 = Calc(mid2);
    if (tim1 < tim2) r = mid2;
    else l = mid1;
  } return ((l + r) / 2);
}

int main() {
  ios::sync_with_stdio(false);
  ios_base::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  
  cin >> T;
  while (T--) {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i];
    for (int i = 1; i <= n; i++) cin >> t[i];
    double ans = Find();
    if (abs(ans - round(ans)) < eps) cout << (int)round(ans) << "\n";
    else cout << fixed << setprecision(1) << ans << "\n";
  } return 0;
}
```

---

## 作者：Vct14 (赞：2)

这题绿？建议这题和[原题](https://www.luogu.com.cn/problem/CF1730B)都降橙。

题目即使 $\max\limits_{i=1}^n\{|x_i-x_0|+t_i\}$ 尽量小。由 $|a-b|=\max\{a-b,b-a\}$，$\max\limits_{i=1}^n\{|x_i-x_0|+t_i\}=\max\limits_{i=1}^n\{\max\{x_i-x_0,x_0-x\}+t_i\}=\max\limits_{i=1}^n\{\max\{t_i+x_i-x_0,x_0-(x_i-t_i)\}\}$。

分别将 $x_i+t_i$，$x_i-t_i$ 看作一个新的点，再删去 $x_i$ 这个点，则题目即求选择一个点 $x_0$ 使得所有点中距离该点最远的点离该点尽量近。答案为 $\dfrac{\max\{x_i+t_i\}+\min\{x_i-t_i\}}{2}$。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+2;
int x[N],t[N];

int main(){
	int T;cin>>T;
	while(T--){
		int n;cin>>n;
		int mx=-1e9,mn=1e9;
		for(int i=1; i<=n; i++) cin>>x[i];
		for(int i=1; i<=n; i++) cin>>t[i];
		for(int i=1; i<=n; i++) mx=max(mx,x[i]+t[i]),mn=min(mn,x[i]-t[i]); 
		cout<<(mx+mn)/2.0<<"\n";
	}
	return 0;
}
```

---

## 作者：Lacuna (赞：2)

中等题。

打回原因：说明一下为什么可以三分，以及怎么算 $tim1$ 和 $tim2$。

被打回了，补充说明一下：三分函数适用于单峰函数算极值的问题，观察一下题目给出的时间计算函数，可以证明它是一个下凸函数，具有唯一的最小值点，是符合这个条件的，所以可以进行三分。

至于 $tim$ 的计算方法题面上有讲。

思路：对于所有可能的坐标 $\begin{bmatrix}0 , 10^8  \end{bmatrix}$，我们对其进行三分，具体流程如下：

设查找区间 $\begin{bmatrix}l , r \end{bmatrix}$，取两个中间点 $mid1$ 和 $mid2$，计算所有人到达 $mid1$ 和 $mid2$ 的时间 $tim1$ 和 $tim2$。当 $tim1$ 小于 $tim2$ 时，则去左边的区间继续查找，否则去右边的区间查找。当找到足够精确的答案后，返回 $l$，此时 $l$ 就是最优的宴会举办处。

最后注意输出问题，我们可以将答案四舍五入之后的值和答案取绝对值，若差值为零，则答案为整数，但由于计算机自身原因，这个差值可能存在，但非常微小，我们可以取一个接近零的数进行判断，若小于这个值，那么我们就认为答案在当前精度下可以看做是一个整数。

时间复杂度 $O(n \log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar
#define pc putchar
#define LL long long
#define the return
#define end 0
const int N=1e5+5;
int T,n,x[N],t[N];
inline LL read(){
  LL x=0;char ch=gc();int f=1; 
  while(!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
  while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=gc();
  return x*f;
}inline void write(LL x){
  if(x<0) x=-x,pc('-');
  if(x>9) write(x/10);
  pc(x%10+'0');
}double times(double e){//计算时间
  double tim=0;
  for(int i=1;i<=n;i++)tim=max(tim,fabs(x[i]-e)+t[i]);
  return tim;
}double search(){
  double l=0,r=1e8;
  while(r-l>1e-6){
  	double mid1=l+(r-l)/3,mid2=r-(r-l)/3;
  	double tim1=times(mid1),tim2=times(mid2);
  	if(tim1<tim2) r=mid2;
  	else l=mid1;
  }
  return l*1.0;
}void solve();
int main(){T=read();while(T--) solve();the end;}
void solve(){
  n=read();
  for(int i=1;i<=n;i++) x[i]=read();
  for(int i=1;i<=n;i++) t[i]=read();
  double res=search();
  if(fabs(res-round(res))<1e-6) write((int)round(res)),pc('\n');
  else printf("%.1lf\n",res);
}
```

---

## 作者：JoyLosingK (赞：1)

介绍一个既不用贪心也不用二分的简单做法。

显然先将每个人按照 $x$ 坐标排序。

现在有一个摆在眼前的问题：我们并不知道有哪些人在答案的左边，有哪些人在答案的右边。

为了解决这个问题，我们考虑枚举答案在哪两个人之间，这样我们就知道了有哪些人在答案的左边和右边。

预处理出 $q_i$ 表示当答案在 $i$ 的右边时 $i$ 及 $i$ 前面的人至少需要多少时间，即所需时间的最大值。

左边同样，预处理出 $h_i$ 表示当答案在 $i$ 的左边时 $i$ 及 $i$ 后面的人所需时间的最大值。

这样，当答案在 $i-1$ 和 $i$ 之间时，我们可以通过 $q_{i-1}$ 和 $h_i$ 来计算答案。

具体地，设答案为 $x_{i-1}+y$，为了使左右两边保持平衡，应有：

$q_{i-1}+y=h_i+(x_i-x_{i-1}-y)$

解得 $y=\frac{h_i+x_i-x_{i-1}-q_{i-1}}{2}$，用 $y$ 来更新答案即可。

时间复杂度 $O(Tn\log n)$，瓶颈在排序。

具体细节见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define endl '\n'
const int N = 1e5 + 5;
int n, q[N], h[N];
double r, ans, res = 1e9 + 6.0;
struct note {
	int x, t;
} a[N];
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * f;
}
inline bool cmp(note a, note b) {
	if (a.x == b.x) return a.t < b.t;
	return a.x < b.x;
}
inline void slove() {
	n = read();
	ans = 0, res = 1e9 + 6.0;
	for (int i = 1; i <= n; i++) a[i].x = read();
	for (int i = 1; i <= n; i++) a[i].t = read();
	sort(a + 1, a + n + 1, cmp);
	q[1] = a[1].t;
	for (int i = 2; i <= n; i++)
		q[i] = max(q[i - 1] + (a[i].x - a[i - 1].x), a[i].t);
	h[n] = a[n].t;
	for (int i = n - 1; i >= 1; i--)
		h[i] = max(h[i + 1] + (a[i + 1].x - a[i].x), a[i].t);
	for (int i = 2; i <= n; i++) {
		r = (h[i] + a[i].x - a[i - 1].x - q[i - 1]) / 2.0;
		r = max(r, 0.0), r = min(r, a[i].x - a[i - 1].x + 0.0);
		if (max(q[i - 1] + r, h[i] + a[i].x - a[i - 1].x - r) < res) {
			res = max(q[i - 1] + r, h[i] + a[i].x - a[i - 1].x - r);
			ans = min(a[i - 1].x + r, (double)a[i].x);
		}
	}
	cout << ans << endl;
}
int main() {
	for (int t = read(); t--;) slove();
	return 0;
}
```
希望能对大家有所帮助。

---

## 作者：_Weslie_ (赞：0)

我是当年补测选手（这也是我到现在都没有 J 组认证记录的原因）。看到这个题的确回忆涌上心头，但是这个题怎么这么裸啊。

## Solution P11854

### Idea

我们把人的行为转化一下：第 $t_i$ 秒从 $x_i$ 位置出发。

由于每秒运动速度为 $1$，所以这个行为就等价于：如果选定的点在 $x_i$ 右侧，一开始就从 $x_i-t_i$ 位置出发向右；反之从 $x_i+t_i$ 位置出发向左。

不难发现：这两种情况是等价的。

接下来我们考虑一个贪心策略：如果人从 $x_i$ 位置出发（前提我们已经通过原来的操作消除了 $t_i$ 的影响），就不难发现我们应该选择的位置是 $x_i$ 最大值和最小值的中点，形象化表示为 $\dfrac{\max\{x_i\}+\min\{x_i\}}{2}$。这个很好理解：如果我们稍有偏移，就会使其中一方距离增大，是不利的。

有了这个就很好做了：我们求出 $x_i-t_i$ 的最小值和 $x_i+t_i$ 的最大值，然后取中点即可。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
#define ll long long
ll x[N],t[N];
int n;
void solve(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%lld",&x[i]);
    for(int i=1;i<=n;i++)scanf("%lld",&t[i]);
    ll minn=0x3f3f3f3f,maxx=-0x3f3f3f3f;
    for(int i=1;i<=n;i++){
        minn=min(minn,x[i]-t[i]);
        maxx=max(maxx,x[i]+t[i]);
    }
    cout<<1.0*(minn+maxx)/2<<endl;
}
int main(){
    int T;scanf("%d",&T);
    while(T--)solve();
}
```

---

## 作者：shuqiang (赞：0)

这是一道~~很水的~~二分。

因为答案有可能是实数，且需要保留一位小数，所以我们可以把坐标和时间全部乘 $100$，这样我们就不用开 double 了。

然后考虑二分答案，假设现在答案是 $y$，显然满足 $y \ge \max(t_i)$，那么每一个人可以接受的宴会地点是 $[x_i-(y-t_i),x_i+(y-t_i)]$，我们取出这些点的交集，如果没有交集，这个答案就是不合法的，有交集，那么答案就是这个交集中的任意一个点，显然，最优情况的交集左端点和右端点一定是一样的。

时间复杂度 $\mathcal{O}(n \log V)$，可以通过。

```cpp
#include<iostream>
#include<iomanip>

using namespace std;
typedef long long ll;

const int N = 1e5 + 10;
ll T, n, x[N], t[N];

ll abs(ll num){
	if(num < 0) return -num;
	return num;
}

int check(ll md){
	ll l = 0, r = 1e10;
	for(int i = 1; i <= n; i++){
		l = max(l, x[i] - md + t[i]);
		r = min(r, x[i] + md - t[i]);
		if(l > r) return -1; // 没有交集。 
	}
	return l; // 有交集，左端点和右端点是一样的。 
}

int main(){
	cin >> T;
	while(T--){
		cin >> n; ll l = 0, r = 1e15, ans;
		for(int i = 1; i <= n; i++) cin >> x[i];
		for(int i = 1; i <= n; i++) cin >> t[i];
		for(int i = 1; i <= n; i++){
			x[i] *= 100; t[i] *= 100;
			l = max(l, t[i]); // 答案大于等于 max(t[i])。 
		}
		while(l <= r){
			ll mid = (l + r) / 2;
			ll res = check(mid);
			if(res != -1){
				ans = res; 
				r = mid-1;
			}
			else{
				l = mid+1;
			}
		}
		if(ans % 100 == 0) cout << ans / 100 << '\n'; // 是整数 
		else cout << fixed << setprecision(1) << ans / 100.0 << '\n';
		// 不是整数，保留一位小数。 
	}
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P11854 题解

## 思路

对**宴会开始时间**进行二分，使宴会开始时间尽可能早，并通过这个宴会开始时间求得聚会地点 $x_0$。

判断 $mid$ 作为宴会开始时间是否可行，$l,r$ 表示可行的宴会坐标的区间，只有 $l \le r$ 才有解。

题目不卡精度，只需 $1$ 位小数，因此当 $l$ 和 $r$ 的差值的绝对值不超过一个较宽松的 $eps$ 值，则解已确定。

## 代码

```cpp
const int N=100005;
const double eps=1e-9;

int T,n,x[N],t[N];

int sign(double k) {
    if (fabs(k)<=eps) return 0;
    else if (k>0) return 1;
    else return -1;
}

int cmp(double a,double b) {
    if (fabs(a-b)<=eps) return 0;
    else if (a>b) return 1;
    else return -1;
}

double check(double mid) {
    double l=0,r=2e9;
    _rep(i,1,n) {
        l=max(l,x[i]-(mid-t[i]));
        r=min(r,x[i]+(mid-t[i]));
        if (cmp(l,r)>0) return -1;
    }
    return l;
}

int main() {
    read(T);
    while (T--) {
        read(n);
        _rep(i,1,n) read(x[i]);
        _rep(i,1,n) read(t[i]);
        double l=0,r=2e9,s;
        while (cmp(l,r)<0) {
            double mid=(l+r)/2.0;
            double res=check(mid);
            if (sign(res)>=0) r=mid,s=res;
            else l=mid+eps;
        }
        // cout<<l<<" "<<r<<endl;
        s*=10.0;
        int ans=round(s);
        if (!ans) writeln(0);
        else if (ans%10) printf("%d.%d\n",ans/10,ans%10);
        else writeln(ans/10);
    }
    return 0;
}
```

---

## 作者：Priestess_SLG (赞：0)

容易观察到若以聚会点 $x_0$ 为自变量，$x_0$ 所对应的所需时间 $y_0$ 为因变量，则该函数为没有连续相同值的单峰函数。因此考虑对答案三分，对于每一个三分到的值直接暴力 $O(n)$ 求解所需花费的时间即可。时间复杂度为 $O(n\log n)$ 可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1000010;
const int mod = 998244353;
int x[N], t[N];
signed main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        for (int i = 1; i <= n; ++i) cin >> x[i];
        for (int i = 1; i <= n; ++i) cin >> t[i];
        double l = 0, r = 1e9;
        for (int i = 0; i < 400; ++i) {
            double m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;
            double c1 = 0, c2 = 0;
            for (int j = 1; j <= n; ++j) c1 = max(c1, abs(m1 - x[j]) + t[j]);
            for (int j = 1; j <= n; ++j) c2 = max(c2, abs(m2 - x[j]) + t[j]);
            if (c1 > c2) l = m1; else r = m2;
        }
        if (abs(l - round(l)) < 1e-9) cout << fixed << setprecision(0) << l << '\n';
        else cout << fixed << setprecision(1) << l << '\n';
    }
    return 0;
}
```

---


# [JSOI2008] 最大数

## 题目描述

现在请求你维护一个数列，要求提供以下两种操作：

1.  查询操作。

语法：`Q L`

功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。

限制：$L$ 不超过当前数列的长度。$(L > 0)$

2. 插入操作。

语法：`A n`

功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。

限制：$n$ 是整数（可能为负数）并且在长整范围内。

注意：初始时数列是空的，没有一个数。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq M \leq 2 \times 10^5$，$1 \leq D \leq 2 \times 10^9$。

## 样例 #1

### 输入

```
5 100
A 96
Q 1
A 97
Q 1
Q 2
```

### 输出

```
96
93
96
```

# 题解

## 作者：SaoFish (赞：246)

2019.7.28

upd:今天突然发现了一个错误...真的非常抱歉，本人当时很菜（现在也是），请各位见谅

这道题中，st表应该是用$f[i][j]$**表示**区间$[i....i-(2^j)+1]$的最值，否则就不能支持插入一个数这样的修改了。

对此感到很抱歉

---------------------------------------------------

看了很多AC的OIer基本是用**线段树**的。

这里就感觉用线段树有点**大材小用**了。

这里我就讲一下**ST表**的方法。

题目有**插入**和**询问**两个操作。

注意看题面，每次的插入是**无脑在序列的尾端插入**的，所以就可以用ST表了。

那么，这是为什么呢？

我们先看ST表的**定义**：

ST算法是用来求解**给定区间RMQ的最值**，用**f[i][j]**表示**区间[i....i+(2^j)-1]**的最值。

从中我们可以看出，当在尾端插入一个新数时，并不会**影响之前所建立的ST表**。
所以我们就可以用**log(n)的时间复杂度**来修改ST表了。

附上代码。

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#define ll long long
using namespace std;
ll a[200001],f[200001][21],t,D;
int n,m;
bool flag;
void change(int u){  //用change函数来进行修改
    f[u][0]=a[u];
    for(int i=1;u-(1<<i)>=0;i++) f[u][i]=max(f[u][i-1],f[u-(1<<(i-1))][i-1]);
}
ll find(int x,int y){
    double t=log(y-x+1)/log(2);
    int K=t;
    return max(f[y][K],f[x+(1<<K)-1][K]);
}
int main(){
    memset(f,0,sizeof(f));
    scanf("%d%lld",&m,&D);
    for (int i=1;i<=m;i++){
        char c;
        cin>>c;
        ll x;
        if (c=='A'){  //根据题面的操作，注意细节。
            scanf("%lld",&x);
            a[++n]=(x+t)%D;
            change(n);
        }else{
            int L; scanf("%d",&L);
            ll ans;
            if (L==1){
                printf("%lld\n",a[n]);
                t=a[n]; continue;
            }
            ans=find(n-L+1,n);
            printf("%lld\n",ans); t=ans;
        }
    }
    return 0;
}
```
完结散花

---

## 作者：Excim (赞：125)

谁说没有线段树做法的？虽然说时间上不大行，但是AC还是可以的。

主要是有个坑点，那就是查询一个长度为0的区间。。。

因为一开始数列中没有数字，所以线段树甚至不需要建树，整个题只需要查询和修改两个操作即可完美解决

每个点只修改一次，而且是单点修改，标记什么的也不需要。但是查询的时候要先把a,b赋一个非常小的值，来应对负数的情况。

区间长度的话，假设所有的操作都是修改，这样区间长度就是操作数。

其他细节见代码吧（讲真这是我写过的最短的线段树题目）

```cpp
    #include<cstdio>
    const long long inf=-(1<<62);
    int m,cnt;
    char op[2];
    long long data[800005],x,t,p;
    long long max(long long a,long long b)
    {
        return a>b?a:b;
    }
    void add(int s,int k,int o,int l,int r)
    {
        if(l==r)
        {
            data[o]=k;
            return;
        }
        int mid=(l+r)>>1;
        if(mid>=s) add(s,k,o<<1,l,mid);
        if(mid<s) add(s,k,o<<1|1,mid+1,r);
        data[o]=max(data[o<<1],data[o<<1|1])%p;
    }
    long long ask(int ll,int rr,int o,int l,int r)
    {
        if(ll<=l&&rr>=r) return data[o];
        int mid=(l+r)>>1;
        long long a=inf,b=inf;
        if(mid>=ll) a=ask(ll,rr,o<<1,l,mid);
        if(mid<rr) b=ask(ll,rr,o<<1|1,mid+1,r);
        return max(a,b);
    }
    int main()
    {
        scanf("%d %lld",&m,&p);
        for(int i=0;i<m;i++)
        {
            scanf("%s %lld",op,&x);
            if(op[0]=='A')
            {
                add(cnt+1,(x+t)%p,1,1,m);
                cnt++;
            }
            if(op[0]=='Q')
            {
                if(x==0) t=0;
                else t=ask(cnt-x+1,cnt,1,1,m)%p;
                printf("%lld\n",t);
            }
        }
        return 0;
    }

```

---

## 作者：单曦增 (赞：71)

## 算法：单调栈，并查集。
单调栈的部分就不用讲了，楼下的dalao们使用的单调栈加二分查找，已经讲的够清楚的了，所以我们直接讲并查集部分。

------------

### 并查集
在将一个数插入单调队列时，我们可以将被删除的数的父亲标记为插入的数，在查找时只需要找到查找的数的根，根上的数值即为答案。

证明：略~~（看个图就明白了）~~


![](https://cdn.luogu.com.cn/upload/pic/15273.png)
![](https://cdn.luogu.com.cn/upload/pic/15274.png)



时间复杂度：O（n）

------------

代码：
```cpp
#include<cstdio>
using namespace std;
const int Maxn=200010;
struct node
{
	long long x;
	int y;
}a[Maxn];
int m,tot,cnt,f[Maxn];
long long d,t,x,num[Maxn];
char ch[3];
int find(int x)
{
	if(x!=f[x])f[x]=find(f[x]);
	return f[x];
}
int main()
{
	scanf("%lld%lld",&m,&d);
	for(int i=1;i<=m;i++)
	{
		getchar();
		scanf("%s",ch);
		scanf("%lld",&x);
		if(ch[0]=='A')
		{
			x+=t;
			x%=d;
			tot++;
			num[tot]=x;
			f[tot]=tot;
			while(x>a[cnt].x&&cnt)
			{
				f[a[cnt].y]=tot;
				cnt--;
			}
			a[++cnt].x=x;
			a[cnt].y=tot;
		}
		else
		{
			x=tot-x+1;
			int y=find(x);
			t=num[y];
			printf("%lld\n",t);
		}
	}
	return 0;
}
```

---

## 作者：Spasmodic (赞：58)

### 为啥没有线性做法 那我就补充一下吧
观察到查询等都在末尾进行,所以采用特殊做法

维护一个单调队列q,意义是**以最后一个数字结束的一个单调递减的数组极大值**

末尾增加一个点:将单调队列小于等于这个数的全部扣除,然后末尾增加一个数

查询[l,size]:从l往后找第一个在单调队列里的数就是结果

总不能一个一个找吧,于是采用二分查找,复杂度O(nlogn),代码贼短~
```cpp
#include<bits/stdc++.h>
#define M 200005
using namespace std;
int m,p,t,x,sz,r,a[M],q[M];
char ch;
int main() {
	scanf("%d%d",&m,&p);
	for(int i=1; i<=m; i++) {
		scanf("%s%d",&ch,&x);
		if(ch=='A') {
			a[++sz]=(x+t)%p;
			while(r&&a[q[r-1]]<a[sz])r--;
			q[r++]=sz;
		} else if(ch=='Q')printf("%d\n",t=a[*lower_bound(q,q+r,sz-x+1)]);
	}
	return 0;
}
```
但这个是O(nlogn)的,离线性还差一步

于是再次开脑洞......

**将i与从i往后找第一个在单调队列里的数的下标合并在一个集合,并使这个集合的根为后者**

于是查询时只需找它所在集合的根就行了

容易发现可以通过并查集来实现

什么时候进行并操作时呢?很简单,只要在出队时合并就行了

这是因为每个数都会进队一次,在出队时它一定是队列的尾部,所以直接向i合并就可以了

这个时间复杂度就是O(nalpha(n))可以视为O(n),因为alpha(n)<=4,只是一个较小常数

代码也就长了一行,而且是线性的
```cpp
#include<bits/stdc++.h>
#define M 200005
using namespace std;
int m,p,t,x,sz,r,a[M],q[M],id[M];
inline int getr(int i){return i==id[i]?i:id[i]=getr(id[i]);}
inline void unite(int u,int v){id[getr(u)]=getr(v);}
char ch;
int main() {
	scanf("%d%d",&m,&p);
	for(int i=1; i<=m; i++) {
		scanf("%s%d",&ch,&x);
		if(ch=='A') {
			a[++sz]=(x+t)%p;id[sz]=sz;
			while(r&&a[q[r-1]]<a[sz])unite(q[r-1],sz),r--;
			q[r++]=sz;
		} else if(ch=='Q')printf("%d\n",t=a[getr(sz-x+1)]);
	}
	return 0;
}
```
不过如果是任意区间查询的话,那就不行了,因为答案可能不在单调队列里面,例如a={1,2,3,4,5},则q={5},要查max[1,1],那就挂了

不过如果要求的是和,那怎么办呢?

这就很简单啦,根本不需要用这种方法,直接前缀和就行了,千万别去写线段树哦!

---

## 作者：Goes (赞：51)

真的不喜欢线段树，所以。找了个好方法。


有个写题解的人号称这个做法叫“单调栈”…….？

反正第一次抄的时候是因为它短………emm…….

现在写博客是因为发现用这个方法才应该是我们应该学的。

而我想把这个做法应该是…….用单调栈把问题转化成一个二分答案题╮(╯▽╰)╭


简解：【其实自己想或者直接看代码可能更有助于思维emmm】

先开两个栈。第一个栈存储在队列里的位置，第二个栈存储这个数字的大小


每当有新元素要入队的时候，我们可以把排在这个元素前的比它小的数直接忽略了（因为查询的区间永远都是后L个数，所以…….）然后更新一下两个栈。


接下来我们就可以二分栈的下标，直到二分到一个下标i，使stack[2][i]表示的队列位置在所求的区间里，那么答案就有了。


代码：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#if 0
```
Writers: Goes && G.S.M.
Have falled in love

```cpp
#endif
#define ll long long 
inline ll read(){
    char ch=getchar();ll sum=0,f=1;
    while(ch<'0'||ch>'9'){
        ch=getchar();
        if(ch=='-') f=-1;}
    while(ch>='0'&&ch<='9')
        sum*=10,sum+=ch-'0',ch=getchar();
    return sum*f;
}
const int N=200005;
ll m,MO,t;
ll stack[2][N],top,cnt;
void add(int k){//添加元素
    cnt++;
    while(k>stack[1][top]&&top>0) top--;
    stack[0][++top]=cnt;
    stack[1][top]=k;
}
void query(int emm,int l,int r){//查询
    while(l<r){
        int mid=(l+r)/2;
        if(stack[0][mid]<emm) l=mid+1;
        else r=mid;
    }t=stack[1][r];
    printf("%lld\n",t);
}
int main()
{
    m=read(),MO=read();
    while(m--){
        char ch=getchar();
        while(ch!='A'&&ch!='Q') ch=getchar();
        if(ch=='A') add((t+read())%MO);
        else query(cnt-read()+1,1,top);
    }
}
```

---

## 作者：teafrogsf (赞：34)

## 我真的没想到，分块居然过了这题而且跑得比线段树快得多233333

由于本题询问有m个，则我们假定会增加m/2个数，那么就可以块的长度就可以假定为sqrt(m/2)（但我的代码好像分的是sqrt(m)/2，不过跑的也挺快我就没改了，大家可自行比对效率，本人数学不好不会证明ORZ）

更新的时候直接建块和Max值就可以了，而查询则是裸的分块，按块查询即可。注意处理边角块与负数问题。

还有，需要注意cin，洛谷输入格式依然坑爹。

在块大小sqrt(m)/2的情况下，复杂度应该是O(x\*sqrt(m))，其中x为加入的数的个数。~~说不定比mlogx快呢~~

```cpp
#include<cstdio>
#include<iostream>
#include<cmath> 
#define neko 200010
#define chkmin(a,b) ((a)<(b)?(a):(b))
#define chkmax(a,b) ((a)>(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))
using std::cin;
typedef long long ll;
int p,blk,m,bl[neko];
ll mod,t,a[neko],Max[neko];
template<typename T>
void read(T &x)
{
    char c=getchar();x=0;
    while(!isdigit(c))c=getchar();
    while(isdigit(c))
    {
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
}
void update(ll x)
{
    if(x>=mod)x%=mod;
    if(x<0)x+=mod;
    bl[++p]=(p-1)/blk+1,a[p]=x;
    Max[bl[p]]=chkmax(Max[bl[p]],x);
}
ll query(int l,int r)
{
    ll tmp=-3e9;
    f(i,l,chkmin(bl[l]*blk,r))tmp=chkmax(tmp,a[i]);
    f(i,bl[l]+1,bl[r]-1)tmp=chkmax(tmp,Max[i]);
    f(i,chkmax((bl[r]-1)*blk+1,l),r)tmp=chkmax(tmp,a[i]);
    return t=tmp;
}
int main()
{
    std::ios::sync_with_stdio(false);
    char c;
    int x;
    ll y;
    cin>>m>>mod;blk=sqrt(m)/2;
    f(i,1,m)
    {        
        cin>>c; 
        if(c=='A')cin>>x,update(x+t);
        if(c=='Q')cin>>y,printf("%lld\n",query(p-y+1,p));
    }return 0;
}
```

---

## 作者：MoXiaodu (赞：27)

扫一眼题面：这不是一道线段树板子题吗？

~~然而数据过水导致暴力n方能过？~~ 请求管理加强数据QAQ

所以我们还是要用正解来做这一道题啦（线段树求区间最大值）！

主要内容是单点修改和区间查询，尤其要主要L==0的情况，不然会RE

[这是用线段树做这道题的结果](https://www.luogu.org/record/25572848)

这道题和线段树模板不同的是，我们的线段树的底部每次都需要新插入一个值，实际上就是对一个值为0的地方作出单点修改。也就是下面的代码：

```cpp
void pplus(long long p,long long l,long long r,long long w,long long v){//加入函数
	if(l==r){t[p]=v;return;}//如果到了底部，直接赋值
	long long mid=(l+r)/2;//取中点
	if(w<=mid)pplus(p*2,l,mid,w,v);//如果在左边查询左节点
	else pplus(p*2+1,mid+1,r,w,v);//同上
	t[p]=max(t[p*2],t[p*2+1]);//当前点的值等于两个儿子节点中较大的值
}
```
如图（我相信关于这一点许多线段树题解都没有写到）：

![](https://cdn.luogu.com.cn/upload/image_hosting/chlh57oq.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
long long modd,m,tt,line;//modd:模数 m:操作数 line:长度 tt：题中t
long long t[2000001];//线段树，存最大值
//十年OI一场空，不开long long……
inline long long read(){//快读优化数据读入（数据大不能忘记）
	long long f=1,outt=0;char a=getchar();
	while(a>'9'||a<'0'){if(a=='-')f=-1;a=getchar();}
	while(a<='9'&&a>='0'){outt*=10;outt+=a-'0';a=getchar();}
	return f*outt;
}
void js(long long p,long long l,long long r){//初始化建树
	t[p]=-0x3ffffffff;//赋极小值
	if(l==r)return;
	long long mid=(l+r)/2;
	js(p*2,l,mid);//向左节点修改
	js(p*2+1,mid+1,r); //向右节点修改
}
long long ask(long long p,long long l,long long r,long long nl,long long nr){//查询函数
	if (nl<=l&&r<=nr)return t[p];//如果区间被包含，返回最大值
    long long mid=(l+r)/2;//取中点
    long long minn=-0x3ffffffff;//赋极小值
    if (nl<=mid)minn=ask(p*2,l,mid,nl,nr);//如果查询区间左节点大于等于mid，查询左区间
    if (nr>mid)minn=max(minn,ask(p*2+1,mid+1,r,nl,nr));//同上
    return minn;//返回最小值
}
void pplus(long long p,long long l,long long r,long long w,long long v){//加入函数
	if(l==r){t[p]=v;return;}
	long long mid=(l+r)/2;
	if(w<=mid)pplus(p*2,l,mid,w,v);
	else pplus(p*2+1,mid+1,r,w,v);
	t[p]=max(t[p*2],t[p*2+1]);
}
int main(){
	m=read(),modd=read();//读入操作数和模数
	for(int i=1;i<=m;i++){
		char s;//读取操作
		cin>>s;
		if(s=='A'){
			long long ls=read();
			line++;//长度++，记录当前值是第几个
			pplus(1,1,m,line,(tt+ls)%modd);//将新的值加入线段树
		}
		else {
			long long ls=read();
			if(!ls)tt=0;//如果查询为空，直接得到答案
			else
			tt=ask(1,1,m,line-ls+1,m);//进入查找
			printf("%lld\n",tt);
		}
	}
	return 0;//成功AC！
}
```



---

## 作者：Atlicd (赞：26)

##看到了每次都在区间最后加入一个值,我想到了树状数组!  

~~看了很多讨论和题解,发现都是用 *线段树* 或者 *单调栈* 或者 *分块*做的~~  
但是我却想到的是用树状数组维护最大值,看看题解,竟然没有!!!  
那我来~~水~~一篇树状数组的题解吧  

首先我们需要明确的是,树状数组是支持区间减法操作的  
区间减法的含义就是在已知 `[1,l-1]`和`[1,r]`的情况下可以求解出`[l,r]`的区间值  
但是取max和求和操作是不一样的,求和支持区间减法,但是取max不支持.  

~~**这个时候就是展现人类智慧的时候了**~~  

我们可以分类讨论一下:  
当`max[1,r]` $\gt$ `max[1,l-1]` 时,我们可以推出 `max[l,r] == max[1,r]`,因为`max[1,l-1]`不贡献最大值  
当`max[1,l-1] == max[1,r]` 时,我们不能直接得到`max[l,r] == max[1,r]`,因为`max[1,l-1]`参与贡献最大值了,但是我们可以枚举每个 `i `$\in$ ` [l,r]` 从中寻找最大值,而树状数组的优势就在于可以在`i - l `$\ge$` lowbit(i) `直接获取`max[i+1-lowbit(i) , i]`

于是问题迎刃而解!!!  

因为上面说的很明白,代码中就是上面分类讨论的实现,就没有再多费时间码字了~~(就是懒,没别的)~~  
###Code:
```
#include <algorithm>
#include <iostream>
#include <cstdio>

const int maxn = 2e5+7 ;
#define lowbit(x) (x & (-x))
using namespace std ;

int n,mod;
int T,tot;
int num[maxn];
//num[i]表示在i这个位置的数 
int t[maxn] ;
//t[]是树状数组,也就是储存max[1,i] 

inline int query(int l , int r)
{
	int ans = 0;
	while(l <= r)
	{
		ans = max(ans , num[r]) ;
		for(--r ; r-l >= lowbit(r) ; r-=lowbit(r))
		//枚举i的过程 
			ans = max(ans,t[r]);
	}
	return ans ;
}
inline void add(int x)
{
	num[++tot] = (x+T)%mod;
	t[tot] = max(num[tot],query(tot+1-lowbit(tot) , tot-1));
	//更新数状数组 
}

int main()
{
	scanf("%d%d",&n,&mod);
	while(n--)
	{
		char in;
		int x;
		cin >> in;
		scanf("%d",&x);
		if(in == 'A') add(x);
		else printf("%d\n",T=query(tot+1-x,tot));
	}
	没什么说的了 
}
```

---

## 作者：Reaepita (赞：18)

竟然没人写平衡树
那我就来一发splay吧~~

操作Q查询区间最大值;

操作A加点;

splay的基础操作

刚开始第九个点反复TLE o(╥﹏╥)o

后来发现随便splay一下就好了.
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=200020;
struct splay_node
{
	int son[2],fa;
	long long maxl,v;
}tree[maxn];
int n,tot=1,root;//tot总结点数+1 
long long t=0;
long long mod;
void update(int now)
{
	int lc=tree[now].son[0],rc=tree[now].son[1];
	tree[now].maxl=tree[now].v;
	if(lc)tree[now].maxl=max(tree[now].maxl,tree[lc].maxl);
	if(rc)tree[now].maxl=max(tree[now].maxl,tree[rc].maxl);
}
void rotate(int now)
{
	int f=tree[now].fa,g=tree[f].fa;
	int flag=tree[f].son[1]==now;
	tree[now].fa=g;
	tree[g].son[tree[g].son[1]==f]=now;
	tree[f].son[flag]=tree[now].son[flag^1];
	tree[tree[now].son[flag^1]].fa=f;
	tree[now].son[flag^1]=f;
	tree[f].fa=now;
	update(f);update(now);
}
void splay(int now,int goal)
{
	while(tree[now].fa!=goal)
	{
		int f=tree[now].fa,g=tree[f].fa;
		if(g!=goal)
		(tree[f].son[0]==now)^(tree[g].son[0]==f)?rotate(now):rotate(f);
		rotate(now);
	}
	if(!goal)root=now;
}
void insert(long long value,int number)
{
	int now=root,f=0;
	while(now)
	{
		f=now;
		now=tree[now].son[now<number];
	}
	tot++;
	now=number;
	tree[now].fa=f;
	tree[f].son[f<number]=now;
	tree[now].v=value;update(now);
	splay(now,0);
}
long long query(int l)
{
	if(l==tot-1)
	{
		splay(1,0);
		long long ans=tree[1].maxl;
		splay(tot-1,0);\\随便splay一下，因为1结点没有左子树，以1结点为根，会导致整颗树极不平衡 
		return ans;
	}
	splay(tot-l-1,0);\\将第tot-l-1个点旋转到根,根的右子树即为tot-l——tot-1区间; 
	return tree[tree[root].son[1]].maxl;
}
int main()
{
	char op;
	long long x;
	scanf("%d%lld",&n,&mod);
	while(n--)
	{
		scanf("\n%c%lld",&op,&x);
		if(op=='Q')printf("%lld\n",t=query(x));
		if(op=='A')insert((x+t)%mod,tot);
	}	
	return 0;
}
```

---

## 作者：Timothy (赞：14)

线段树华丽丽的登场了！

【题目大意】

1、查询操作。语法：Q L功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。

2、 插入操作。语法：A n功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。

【算法讨论】

运用线段树的算法。首先建树，把所有的节点的值赋成min\_int。用[i,j]表示该区间的最大值。

1）读入Q L操作。用len表示区间的大小，在len+1的位置放入（L+T)%D的值。

2）读入A n操作。输出区间[len-n+1,len]这个区间中的最大值，并把t的值进行更新。

得分：100

时间复杂度：O(nlogn)

空间复杂度：O(4\*n)

【C++代码】

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
#define maxn 200001
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;
const int n=maxn-1;
int ma[maxn<<2],t,d,m,len;
void build(int l,int r,int rt)
{
    ma[rt]=-2147283647;
    if (l==r)return;
    int mid=(l+r)>>1;
    build(lson);build(rson);
}
void update(int l,int r,int rt,int i,int j)
{
    if (l==r){ma[rt]=j;return;}
    int mid=(l+r)>>1;
    if (i<=mid)update(lson,i,j);
    else update(rson,i,j);
    ma[rt]=max(ma[rt<<1],ma[rt<<1|1]);
}
int query(int l,int r,int rt,int i,int j)
{
    
    if (i<=l && r<=j)return ma[rt];
    int mid=(l+r)>>1,o=-2147483647;
    if (i<=mid)o=query(lson,i,j);
    if (j>mid)o=max(o,query(rson,i,j));
    return o;
}
int main ()
{
    scanf ("%d%d",&m,&d);
    build(1,n,1);
    for (int b=1;b<=m;++b)
    {
        char c;int i;
        cin >>c;scanf ("%d",&i);
        if (c=='A'){len++;update(1,n,1,len,(i+t)%d);}
        else {t=query(1,n,1,len-i+1,len);printf ("%d\n",t);}
    }
    return 0;
}

```

---

## 作者：Reqwey (赞：12)

**小广告: 在[此处](https://linhk1606.github.io/2020/01/15/solution-luogu-1198/)食用最佳**

# 背景

初二蒟蒻的第一篇题解...

# 解题思路

* ST表

令 $st[ i ][ j ]$ 为 $\max \limits_{1 \leq t \leq (i + 2^j - 1)} arr[t]$

每在序列 $arr$ 的后面加入一个新值(假设是 $arr[ n ]$)时

它只会影响到一类 $st[ i ][ j ]$ 当且仅当

$$i + 2^j - 1 = n$$

也就是说，只会影响到所有**终点为$n$的区间**

将上述式子变形得:

$$i = n - 2^j + 1$$

所以，我们可以穷举这个$j$，使得 $1 \leq 2^j \leq n$

那么就可以定出这个长为$j$，终点为$n$的区间:

$$st[ i ][ j ] = st[ n - 2^j + 1 ][j]$$

# Talk is cheap, show me the code.
## Insert 函数 (区间修改)

```cpp
void insert(ll num) {
    n++;
    st[n][0] = num; //初始化
    for (int i = 1; (1 << i) <= n; i++) {
        int tmp = n - (1 << i) + 1;
        st[tmp][i] = max(st[tmp][i - 1], st[tmp + (1 << (i - 1))][i - 1]); //这里的tmp其实就是原文中的i, 同理，这里的i是原文中的j
    }
}
```
## Solve 函数 (区间求最值)

```cpp
// 参数l代表返回的是长度为 l ，终点为 n 的区间最大值
ll solve(int l) {
    int k = (int)(log(double(l)) / log(2.0)); // 不懂log换底公式的请自行翻阅高中必修四
    return max(st[n - l + 1][k], st[n - (1 << k) + 1][k]);
}
```

## 完整代码:

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;
typedef long long ll;
const int ASK_SZ = 200001, LOG = 50;

int m;
ll d, last_ans;
int n;
ll st[ASK_SZ][LOG];

ll solve(int l);
void insert(ll num);

int main() {
    char op;
    ll num;
    cin >> m >> d;
    for (int i = 1; i <= m; i++) {
        cin >> op >> num;
        if (op == 'Q') {
            cout << (last_ans = solve(num)) << '\n';
        }
        else {
            insert((num + last_ans) % d);
        }
    }
    return 0;
}

ll solve(int l) {
    int k = (int)(log(double(l)) / log(2.0));
    return max(st[n - l + 1][k], st[n - (1 << k) + 1][k]);
}

void insert(ll num) {
    n++;
    st[n][0] = num;
    for (int i = 1; (1 << i) <= n; i++) {
        int tmp = n - (1 << i) + 1;
        st[tmp][i] = max(st[tmp][i - 1], st[tmp + (1 << (i - 1))][i - 1]);
    }
}

```

---

## 作者：moongazer (赞：10)

# 题解 P1198 【[JSOI2008]最大数】
[$\mathfrak{View\space it\space on\space my\space Blog}$](https://blog.seniorious.cc/2020/luogu-5395/)
## 思路
显而易见，后入队的结点如果比前面的大，那么前面的一定对答案没有贡献(如果查询的区间包括前面的，则一定包括后面的)

可以考虑维护单调性

### 算法1
维护一个递增的单调栈，每次询问二分查找第一个在询问范围内的

#### 复杂度分析
1. 每个元素只会入栈一次
2. 每次查询的复杂度是$O(log_2n)$的
3. 总复杂度$O(n+qlog_2n)$

期望得分100分

### 算法2
考虑对算法1进行优化

我们发现算法1的查询较慢，考虑是否能$O(1)$查询，考虑不将对答案无贡献的点删去，而是维护比他大的点中最新插入进序列的

发现可以用并查集维护，每次插入将和它相邻并比它小的合并

每个集合的集合代表设为最左边的，集合权值为最右边的值，这样下次维护时对于一个集合可以直接跳到它的左边，而查询末尾$k$个数的值就是从右往左第$k$个数所属集合代表的权值

#### 复杂度分析
1. 每个元素作为右端点只会被合并一次，所以一次插入的复杂度均摊为$O(\alpha(n))$
2. 查询操作只需查询它所对应的集合的权值，所以一次查询的复杂度为$O(\alpha(n))$
3. 总复杂度$O(\alpha(n)\cdot(n+q))$

期望得分100分

## 参考代码

此处只提供算法2的代码(省略预处理和快读快输)
```cpp
const int N = 200005;

int find(int);
void uni(int, int);

int fa[N], maxi[N]; // 集合代表和权值
int id; // 数列的大小

int main () {
	int n, m;
	read(n), read(m);
  int lastans = 0;
  for (int i = 1; i <= n; ++i) {
    char ch = getchar();
    if (ch != 'A' && ch != 'Q') {
      ch = getchar();
    }
    ll a;
    read(a);
    if (ch == 'A') {
      ++id;
      fa[id] = id;
      maxi[id] = (a + lastans) % m;
      int fi = id; // 目前集合的最左端，fi - 1就是下次考虑是否合并的集合的最右端
      while (fi > 1 && maxi[fi] > maxi[find(fi - 1)]) {
        uni(fi - 1, fi);
        fi = find(id);
      }
    } else {
      lastans = maxi[find(id - a + 1)];
      write(lastans), EL;
    }
  }
  return 0;
}

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}
void uni(int x, int y) {
    int fx = find(x), fy = find(y);
    fa[fy] = fx; // 将集合代表设为左边的
    maxi[fx] = maxi[fy]; // 将集合权值设为右边的值
}
```

---

## 作者：royzhu (赞：8)

这道题是一道线段树的裸题，推荐刚学线段树的同学来练一练

**思路（题意）：**

1，A操作：改（加）点

2，Q操作：找（len2-x）到（len2)中的最大值 
(Q 0是一个很坑的数据点，要特判，输出0)
（坑了我三次提交QAQ）
```cpp
#include<cstdio>
#include<cstring>

struct nod{int l,r,ll,rr;long long c;}a[400010];
//因为最多有n个操作，所以最多加n个点，要开2*n左右的数组 
int len,len2=0;long long t=0,m;int n;
//len表示树有多少个点，len2表示一共有多少加个点，t如题意 
long long max(long long x,long long y){return x>y?x:y;}

void bt(int l,int r)//建树 
{
    len++;int now=len;
    a[len].l=l;a[len].r=r;a[len].ll=a[len].rr=a[len].c=-2147483647;
    if(l<r)
    {
        int mid=(l+r)/2;
        a[now].ll=len+1;bt(l,mid);
        a[now].rr=len+1;bt(mid+1,r);
        a[now].c=max(a[a[now].ll].c,a[a[now].rr].c);
    }
}

void change(int now,int x,long long k)//加点（相当于把这个点改成k） 
{
    if(a[now].l==a[now].r)//左儿子等于右儿子表示插入的第l（r）个数 
    {
        a[now].c=k;//printf("%d %d\n",now,k);
        return;
    }
    int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
    if(x<=mid) change(ll,x,k);
    else if(x>mid) change(rr,x,k);
    a[now].c=max(a[ll].c,a[rr].c);//维护最大值 
}

long long findsum(int now,int l,int r)//找最大值 
{
    if(a[now].l==l&&a[now].r==r) return a[now].c;
    int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
    if(r<=mid) return findsum(ll,l,r);
    else if(l>mid) return findsum(rr,l,r);
    else return max(findsum(ll,l,mid),findsum(rr,mid+1,r));
}

int main()
{
    scanf("%d %lld",&n,&m);
    len=0;bt(1,n);//因为最多有n个操作，所以最多加n个点，要建2*n左右个点的树 
    for(int i=1;i<=n;i++)
    {
        char v[10];scanf("%s",v);//scanf只能用%s输入，因为%c会读回车
        if(v[0]=='A')//输入用v+1的同学要用v[1] 
        {
            long long c;scanf("%lld",&c);
            ++len2;change(1,len2,(c+t)%m);
        }
        else//找（len2-x）到（len2)中的最大值 
        {
            int x;scanf("%d",&x);if(x==0){printf("0\n");continue;}
            t=findsum(1,len2-x+1,len2);t%=m;printf("%lld\n",t);
        }
        
    }
    return 0;
}
```

---

## 作者：exit0 (赞：7)

让我们来挑战一下线段树最短代码！

[AC记录](https://www.luogu.com.cn/record/29704756)

起初，我打了一个大暴力，思路就是每一次更新重新建一次线段树，就像这个样子：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 10000100
inline int read ()
{
	int ans=0;
	int flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')flag=-1;
		ch=getchar ();
	}
	while(ch>='0'&&ch<='9')ans=(ans<<1)+(ans<<3)+(ch^48),ch=getchar ();
	return ans*flag;
}
int mx[N*3];int a[N];
inline void Build( int k , int l , int r )
{
	if(l==r)
	{
		mx[k]=a[l];
		return ;
	}
	int mid=l+r>>1;
	Build(k*2,l,mid);
	Build(k*2+1,mid+1,r);
	mx[k]=max(mx[k*2],mx[k*2+1]);
	return ;
}
inline int ask_max( int k , int l , int r , int x, int y )
{
	if(l==x&&r==y)return mx[k];
	int mid=l+r>>1;
	if(y<=mid)return ask_max(k*2,l,mid,x,y);
	if(x>mid)return ask_max(k*2+1,mid+1,r,x,y);
	return max( ask_max(k*2,l,mid,x,mid), ask_max(k*2+1,mid+1,r,mid+1,y) );
}
int m,d,x,n,now;
char op;
int main ()
{
	m=read();d=read();
	for(int i=1;i<=m;i++)
	{
		cin>>op;
		if(op=='A')
		{
			x=read();
			x+=now;
			x%=d;
			a[++n]=x;
			Build(1,1,n);
			continue;
		}
		//if(op=='Q')
		x=read();
		now=ask_max(1,1,n,n-x+1,n);
		printf("%d\n",now);
	}
	return 0;
}
```
emmm，只过了两个点，其余的TLE。

在尝试暴力失败后，开始打正解，标准的单点修改，区间查询线段树。

先说说在此题中线段树的几种操作：

区间查询：

```cpp
inline int ask_max( int k , int l , int r , int x, int y )
{
	if(l==x&&r==y)return mx[k];
	int mid=l+r>>1;
	if(y<=mid)return ask_max(k<<1,l,mid,x,y);
	if(x>mid)return ask_max(k<<1|1,mid+1,r,x,y);
	return max( ask_max(k<<1,l,mid,x,mid), 	 ask_max(k<<1|1,mid+1,r,mid+1,y) );
}
```
单点修改：

```cpp
void Build(int k,int l,int r,int x)
{
	if(l==r&&l==x)
	{
	mx[k]=a[l];return;
	}
	int mid=l+r>>1;
	if(x<=mid) Build(k*2,l,mid,x);
	else Build (k*2+1,mid+1,r,x);
	mx[k]=max(mx[k*2],mx[k*2+1]);
}
```

然后，记录一下查询得到的答案，方便在下一次用，查询的范围可以从1到m，AC代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int mx[10000100*3],a[10000100],m,d,x,n,now;char op;
inline void Build(int k,int l,int r,int x)
{
	if(l==r&&l==x)
	{
	mx[k]=a[l];return;
	}
	int mid=l+r>>1;
	if(x<=mid) Build(k<<1,l,mid,x);
	else Build (k<<1|1,mid+1,r,x);
	mx[k]=max(mx[k<<1],mx[k<<1|1]);
}
inline int ask_max( int k , int l , int r , int x, int y )
{
	if(l==x&&r==y)return mx[k];
	int mid=l+r>>1;
	if(y<=mid)return ask_max(k<<1,l,mid,x,y);
	if(x>mid)return ask_max(k<<1|1,mid+1,r,x,y);
	return max( ask_max(k<<1,l,mid,x,mid), ask_max(k<<1|1,mid+1,r,mid+1,y) );
}
int main ()
{
	cin>>m>>d;
	for(int i=1;i<=m;i++)
	{
		cin>>op;
		if(op=='A')
		{
			cin>>x,x+=now,x%=d,a[++n]=x;
			Build(1,1,m,n);
			continue;
		}
		cin>>x;
		now=ask_max(1,1,m,n-x+1,n);
		printf("%d\n",now);
	}
}
```

这样就AC了，望采纳~

---

## 作者：littleseven (赞：6)

## 题解：

**线段树**

线段树维护区间最值 + 单点修改。

由于这道题十分优秀~~毒瘤~~的修改方式，我们需要对于每次询问都记下当前询问的值，因为下一次修改又会用到。同时我们又要记录修改次数（当前点），同样修改对于询问也是有贡献的，所以我们需要在`cnt`和`pr`之间来回操作，那么主函数中对于这部分的处理代码如下：

```cpp
if (c == 'A') {
	int x = rd();
	cnt ++ ;
	x = (x + pr) % mod;
	fix(1, 1, m, cnt, x);
}
else {
	int x = rd();
	pr = query(1, 1, m, cnt - x + 1, cnt);
	printf("%d\n", pr);
}
```

其他的就是线段树的修改、查询模板，直接套用即可。这里手写了一下宏定义的`Max`据说会快！！！

修改：

```cpp
void fix(int pos, int l, int r, int id, int val) {
	int mid = (l + r) >> 1;
	if (l == r) {
		tree[pos] = val;
		return ;
    }
	if (id <= mid) {
		fix(lson, l, mid, id, val);
	}
	else {
		fix(rson, mid + 1, r, id, val);
	}
	tree[pos] = Max(tree[lson], tree[rson]);
}
```

查询：

```cpp
int query(int pos, int l, int r, int x, int y) {
	if (x <= l && r <= y) {
		return tree[pos];
    }
	int mid = (l + r) >> 1;
	int ans = 0;
	if (x <= mid) {
		ans = max(ans, query(lson, l, mid, x, y));
	}
	if (mid < y) {
		ans = max(ans, query(rson, mid + 1, r, x, y));
	}
	return ans;
}
```



对了不要忘记最开始需要把`tree[]`数组赋一个极小值！！！！

## AC代码

```cpp
#include <bits/stdc++.h>

#define lson pos << 1

#define rson pos << 1 | 1

#define Max(x, y) ((x) > (y) ? (x) : (y))

using namespace std;

typedef long long ll;

const int inf = 0x3f3f3f3f;

const int N = 200020;

char s[10];

ll tree[N * 4], mod;

int m, cnt, pr;

char *p1, *p2, buf[100000];

#define nc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1 ++ )

int rd() {
	int x = 0, f = 1;
	char c = nc();
	while (c < 48) {
		if (c == '-')
			f = -1;
		c = nc();
	}
	while (c > 47) {
		x = (((x << 2) + x) << 1) + (c ^ 48), c = nc();
	}
	return x * f;
}

ll rd2() {
	ll x = 0;
	char c = nc();
	while (c < 48) {
		c = nc();
	}
	while (c > 47) {
		x = (((x << 2) + x) << 1) + (c ^ 48), c = nc();
	}
	return x;
}

void fix(int pos, int l, int r, int id, int val) {
    int mid = (l + r) >> 1;
    if (l == r) {
        tree[pos] = val;
        return ;
    }
    if (id <= mid) {
        fix(lson, l, mid, id, val);
    }
    else {
        fix(rson, mid + 1, r, id, val);
    }
    tree[pos] = Max(tree[lson], tree[rson]);
}

int query(int pos, int l, int r, int x, int y) {
    if (x <= l && r <= y) {
        return  tree[pos];
    }
    int mid = (l + r) >> 1;
	int ans = 0;
	if (x <= mid) {
		ans = max(ans, query(lson, l, mid, x, y));
	}
	if (mid < y) {
		ans = max(ans, query(rson, mid + 1, r, x, y));
	}
	return ans;
}

int main() {
    memset(tree, -inf, sizeof tree);
	m = rd(), mod = rd2();
    for (int i = 1; i <= m; i ++ ) {
		char c = nc();
		while (c != 'A' && c != 'Q') {
			c = nc();
		}
        if (c == 'A') {
            int x = rd();
            cnt ++ ;
            x = (x + pr) % mod;
            fix(1, 1, m, cnt, x);
        }
        else {
            int x = rd();
            pr = query(1, 1, m, cnt - x + 1, cnt);
            printf("%d\n", pr);
        }
    }
    return 0;
}
```

 

---

## 作者：Sol1 (赞：6)

# What，题解里没有树状数组的做法？？

线段树多难写啊……~~一看就不想写~~，于是我就写了一个BIT……

进入正题：用BIT维护整个数列，A操作相当于在BIT的第$n+1$个位置执行更新，Q操作相当于查询后$L$个数的最大值。注意这里要实现的是后缀BIT而不是前缀BIT。BIT具体怎么实现，~~在P3688里已经写明了，自己看去就好了。~~

注意点：
1.要开long long。题目中说了$n+t$在长整型范围内。
2.BIT数组初始化要初始化为$-INF$。

my code:

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

long long a[200005], n;

inline long long LowBit(long long x) {
	return x & -x;
}

inline void Update(int i, long long x) {
	for (int j = i;j >= 1;j -= LowBit(j)) {
		a[j] = max(a[j], x);
	}
}

inline long long Query(int i) {
	long long ans = 0xcfcfcfcfcfcfcfcf;
	for (int j = i;j <= n;j += LowBit(j)) {
		ans = max(ans, a[j]);
	}
	return ans;
}

void Solve() {
	int m;
	long long d, t = 0;
	scanf("%d%lld", &m, &d);
	memset(a, 0xcf, sizeof(a));
	for (int i = 1;i <= m;i++) {
		char op;
		long long x;
		cin >> op >> x;
		if (op == 'A') {
			Update(++n, (x + t) % d);
		} else {
			printf("%lld\n", t = Query(n - x + 1));
		}
	}
}

int main() {
	Solve();
	return 0;
}
```

---

## 作者：咯咯咯 (赞：6)

~~**NOIP一日祭**~~

首先看题目..嗯，区间最大数

在看一眼，n=2e5，~~线段树模板~~

但是这里我们用非递归版线段树（zkw线段树）

~~事实证明完爆递归线段树~~

Q：什么是zkw线段树

A：就是张昆玮线段树（逃

Q：它和普通线段树有什么差？

A: ~~它不递归~~ ~~它短~~ ~~它好调~~

   **最重要的是常数小（可以媲美树状数组）**
   
   那怎么写呢？
   
   首先会发现堆存储有个特点
   
   就是第一个叶子节点的编号等于叶子节点的数量
   
  **EX：询问[L,R]? **
   
   我们可以很快知道L和R最在叶子节点，然后逐层向上寻找/查询
   
   **这里把第一个叶子节点记作M**

**（第二个叶子节点才是真正存值的，第一个和最后一个都是虚点）**
   
   怎么实现？
   
```cpp
LL z[4*N],M;
void Build()
{
	for(M=1;M<m+2;M<<=1);
}
```

好了我们已经建完了一颗空树

**然后？添加一个数！（实际上就是将原本为0的地方加上一个数）
**

**PS：这题事实上是单点修改，不过我用的是区间修改的写法**

```cpp
void update(int l,int r,LL x)
{
	LL temp;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1)
	{
		if (~l&1) z[l^1]+=x;
		if (r&1) z[r^1]+=x;
		temp=max(z[l],z[l^1]);z[l]-=temp;z[l^1]-=temp;z[l>>1]+=temp;
		temp=max(z[r],z[r^1]);z[r]-=temp;z[r^1]-=temp;z[r>>1]+=temp;
	}
	for(l;l!=1;l>>=1)
	{
		temp=max(z[l],z[l^1]);z[l]-=temp;z[l^1]-=temp;z[l>>1]+=temp;
	}
	return ;
}
```

这里用到了差分，把节点和他父节点差分

并且用到了一个小技巧 将[L,R]变为(L-1,R+1)

这样你会发现只有当L为左孩子时，其右兄弟在被[L,R]包含（R同理）

修改实际上就是先修改叶子，然后再逐层向上维护差分的过程

**再然后？区间查询！**
```cpp
LL query(int l,int r)
{
	LL L=-INF,R=-INF,ans;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1)
	{
		L+=z[l];R+=z[r];
		if (~l&1) L=max(L,z[l^1]);
		if (r&1) R=max(R,z[r^1]);
	}
	ans=max(L+z[l],R+z[r]);
	for(l>>=1;l;l>>=1)
	{
		ans+=z[l];
	}
	return ans;
}
```

这里每次让L+=z[l],R+=z[r]实际上就是让让加上当前节点与父节点的差值 然后在和兄弟比较…


实际上和修改是一个道理

Code ：
```cpp
#include<iostream>
#include<cstdio>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define LL long long
#define N 201000
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
void read(LL &x)
{
	LL t=0,opt=1;
	char c=getchar();
	while (c<'0'||c>'9') (c=='-'?opt=-1:0),c=getchar();
	while ('0'<=c&&c<='9')
	{
		t=t*10+c-'0';
		c=getchar();
	}
	x=t*opt;return ;	
} 
void print(LL x)
{
	if (x<0) putchar('-'),print(-x);
	else
	{
		if (x>9) print(x/10);
		putchar('0'+x%10);
	}
}
LL m,mod,last_ans=0,cnt=0,temp,len,z[N*4],M;
char opt;
void Build()
{
	for(M=1;M<m+2;M<<=1);
}
LL query(int l,int r)
{
	LL L=-INF,R=-INF,ans;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1)
	{
		L+=z[l];R+=z[r];
		if (~l&1) L=max(L,z[l^1]);
		if (r&1) R=max(R,z[r^1]);
	}
	ans=max(L+z[l],R+z[r]);
	for(l>>=1;l;l>>=1)
	{
		ans+=z[l];
	}
	return ans;
}
void update(int l,int r,LL x)
{
	LL temp;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1)
	{
		if (~l&1) z[l^1]+=x;
		if (r&1) z[r^1]+=x;
		temp=max(z[l],z[l^1]);z[l]-=temp;z[l^1]-=temp;z[l>>1]+=temp;
		temp=max(z[r],z[r^1]);z[r]-=temp;z[r^1]-=temp;z[r>>1]+=temp;
	}
	for(l;l!=1;l>>=1)
	{
		temp=max(z[l],z[l^1]);z[l]-=temp;z[l^1]-=temp;z[l>>1]+=temp;
	}
	return ;
}
int main()
{
	read(m);read(mod);
	Build();
	For(i,1,m)
	{
		scanf(" %c",&opt);
		if (opt=='Q')
		{
			read(len);
			last_ans=query(cnt-len+1,cnt);
			print(last_ans),putchar('\n');
		}
		else
		{
			read(temp);
			temp=((temp+last_ans)%mod)%mod;
			++cnt;update(cnt,cnt,temp);
		}
	}
	return 0;
}
```


---

## 作者：KagurazakaLorna (赞：5)

看到各种佛算法和数据结构，诸如线段树、分块之类的。

**但是，**由于本题数据似乎有点水，所以我可以轻松水过去。

~~（楼下有人写了一个号称单调栈的方法，我觉得思路有部分相同呢）~~

我们定义一个数组mx，其中mx[i]表示从第i个数到最后一个数的最大值。

每次加入一个新的数时，从后向前更新mx即可，当遇见第一个不可以被更新的位置时break。

然后我们可以O(1)回答。

之所说和“单调栈”做法思路类似，原因在于我们显然可以发现mx数组**单调不增**，这也是为什么我们可以直接break的原因。

当然，这个算法很显然在遇到一些极端数据时会T。

虽然我轻松水过去，但还是建议那些想要练习线段树等数据结构的同学不要像我一样水，~~不然会变成和我一样的蒟蒻~~。

下面是代码~~（Ugly）~~：

```cpp
#include <bits/stdc++.h>
using namespace std;

int num[200003],mx[200003],len=0;

int main() {
    ios::sync_with_stdio(0);
    int m,d; cin>>m>>d;
    int t=0; 
    for (int i=1;i<=m;i++) {
        char ch; cin>>ch;
        int x; cin>>x;
        if (ch=='Q') {
            cout<<mx[len+1-x]<<endl;
            t=mx[len+1-x]%d;
        }
        else {
            num[++len]=((long long)t+x)%d;
            mx[len]=num[len];
            for (int i=len-1;i>=1;i--) 
                if (mx[i]<num[len]) mx[i]=num[len];
                else break;
        }
    }
    return 0;
}

```

---

## 作者：前排吃瓜 (赞：5)

### 树状数组写法
看见那么多的dalao用单调栈，线段树，本蒟蒻觉得那些代码太长，于是用树状数组来解这道题。~~算是一种巧妙的解法吧~~，可奈何本蒟蒻代码能力差，写题10分钟，debug一小时。不懂树状数组可以看我的博客https://www.cnblogs.com/KyleDeng/p/9368201.html

#### 为什么会想到用树状数组呢？
读题后发现题目就是一个区间查询加上单点插入操作。所以很自然想到了树状数组，

### 思路

**1）建树状数组  **
拿到题就发现这道题是查询方向是反着来的“查询当前数列中末尾L个数中的最大的数”所以建数组的时候我们就把k（k是加的点的个数）作为起始点，1作为终点，然后更新区间的最大值，
具体方式如下
```cpp
void change(int x,long long c)
{
	while(x>0)//只要x大于0(没到终点）就一直往后更 ,x是插入元素的位置,每插一次更新一次 
	{
		c_tree[x]=max(c_tree[x],c);//更新当前区间的最大值， 
		x=x-lowbit(x);//继续往后更新 
	}
}
```
**2）查询 **   
查询也是一个坑点，此时末尾l个数实际上是开头l个数，如果我们从l开始查询的话意味这1就是起点了，所以需要倒着来用k-l+1扫到k
```cpp
int getsum(int x)
{
	long long MAXN=-9999;
	while(x<=k)//k为起点,只要没有到k,那就继续搞最大值 
	{
		//cout<<"1: "<<x<<endl;debug用 
		MAXN=max(c_tree[x],MAXN);//c_tree[x]只能代表区间最大值,所以要多次比较 
		x=x+lowbit(x);//继续向上 
	}
	return MAXN;
} 

//传入过程
flag=getsum(k-l+1);//玄学反向操作，我们的第一个数是k,最后一个数是1
```
### 完整ac代码
请勿抄袭
```cpp
#include<bits/stdc++.h>
using namespace std;

long long c_tree[200005];
long long m,d;//m次操作，%d 
int k=0;

int lowbit(int x)
{
	return x&-x;
}

int getsum(int x)
{
	long long MAXN=-9999;
	while(x<=k)//k为起点,只要没有到k,那就继续搞最大值 
	{
		//cout<<"1: "<<x<<endl;debug用 
		MAXN=max(c_tree[x],MAXN);//c_tree[x]只能代表区间最大值,所以要多次比较 
		x=x+lowbit(x);//继续向上 
	}
	return MAXN;
} 

void change(int x,long long c)
{
	while(x>0)//只要x大于0(没到终点）就一直往后更 ,x是插入元素的位置,每插一次更新一次 
	{
		c_tree[x]=max(c_tree[x],c);//更新当前区间的最大值， 
		x=x-lowbit(x);//继续往后更新 
	}
}

long long flag;
int main()
{
	cin>>m>>d; 
	for(int i=1;i<=m;i++)
	{
		char cz;
		int l;
		cin>>cz
		>>l;
		if(cz=='A')
		{
			k++;
			change(k,(l+flag)%d);
		}
		if(cz=='Q')
		{
			flag=getsum(k-l+1);//玄学反向操作，我们的第一个数是k,最后一个数是1 
			cout<<flag<<endl;
		}
	}
	return 0;
} 
```


---

## 作者：hongzy (赞：5)

看了下所有题解，貌似只有一篇讲了倍增的思路

这题倍增好像比线段树简单点

---

【思路】

f[i][j]表示以i结尾的长度为2^j的区间最大值（跟ST表几乎一模一样）

插入：数列长度++，循环j，更新f数组

f[l][i] = max(f[l][i-1], f[l-(1<<i-1)][i-1]) % D;

询问：像ST表一样，把区间拆成可以重叠的两段，返回这两段的最小值

j = log2(k);  return max(f[l][j], f[l-k+(1<<j)][j]) % D;

.

---

【参考程序】

```cpp
#include <iostream>
#include <cmath>
using namespace std;

typedef long long LL;

LL N, D;
LL f[200010][18], l; //l是当前数列长度 

void Add(LL k) { //数列尾加上一个数 
	LL j = log2(++l);
	f[l][0] = k % D;
	for(LL i=1; i<=j; i++) //更新f[l][i]
		f[l][i] = max(f[l][i-1], f[l-(1<<i-1)][i-1]) % D;
}

LL Query(LL k) { //询问后k个数的最大值
	if(k == 0) return 0; //注意这个特判 
	LL j = (LL)log2(k); 
	return max(f[l][j], f[l-k+(1<<j)][j]) % D; //直接返回最小值 
}

int main() {
	char opt;
	LL k, t = 0;
	cin >> N >> D;
	for(LL i=1; i<=N; i++) {
		cin >> opt >> k;
		if(opt == 'A') Add((t+k) % D); 
		else if(opt == 'Q') cout << (t = Query(k)) << endl;
	}
	return 0;
}

```

---

## 作者：a999999 (赞：4)

这题不难吧

解法和[最大异或和](https://www.luogu.org/problemnew/show/P4735)差不多

### 解法：
1. 先不管插入，只有查询

	这时候我们可以跑ST表，线段树······
    
    但是我用了Trie
    
    将$int$以$32$位01串插入(以下将$Trie$中数字称为"串")
    
    设$latest[x]$为以$x$为根的子树的$latest[]$的最大值
    $$ latest[x]=max\{latest[trie[x][0],latest[trie[x][1]\}$$
    
    然后我们对所有串建立可持久化$Trie$，$root[n]$就是第n次插入串后的$Trie$的根，查询时从$root[n]$出发就好了
    
    查询时，要使答案更大，就要尽量走$trie[x][1]$,(在$Trie$中即向右走)，同时不能超过$[N-L+1,N]$的区间
    
    这时候$latest[]$就有用了
    
    当我们走到节点$x$时(设$latest[x]>N-L+1$)，如果$latest[trie[x][1]]>N-L+1$，那么$x=trie[x][1]$(向右走)
    
    否则只能放弃这一位，$x=trie[x][0]$(向左走)
    
    走到叶子节点后，从根到当前节点形成的串就是答案
2. 查询&插入
	
    查询都解决了，插入还难吗
    
    回到上面，我们在初始化的时候是将每个数字按顺序插入的
    
    我们把插入指令和初始化一样处理，不就好了吗
    
至此，问题就~~玄学~~解决啦

---

$$Talk\ is\ cheap\ ,show\ you\ the\ code.$$
```cpp
#include<algorithm>
#include<cstdio>
#include<cctype>
#define N 200010
using namespace std;
int trie[N*32][2],latest[N*32];
int s[N],root[N],n,m,mod,tot;
inline int cread()
{char c=getchar();while(!isupper(c))c=getchar();return c=='A';}
void insert(int k,int p,int q)//可持久化Trie
{
	if(k<0){latest[q]=n;return;}
	int c=s[n]>>k&1;
	if(p)trie[q][c^1]=trie[p][c^1];
	trie[q][c]=++tot;
	insert(k-1,trie[p][c],trie[q][c]);
	latest[q]=max(latest[trie[q][0]],latest[trie[q][1]]);//计算latest[]
}
int ask(int p,int k,int limit)
{
	if(k<0)return s[latest[p]];
	if(latest[trie[p][1]]>=limit)return ask(trie[p][1],k-1,limit);//贪心
	else return ask(trie[p][0],k-1,limit);
}
int main()
{
	int x,t=0;
	latest[0]=-1;root[n=0]=++tot;
	scanf("%d%d",&m,&mod);
	while(m--)
	{
		if(cread())
		{
			scanf("%d\n",&x);root[++n]=++tot;s[n]=(x+t)%mod;//不打括号出人命
			insert(31,root[n-1],root[n]);
		}
		else
		{
			scanf("%d",&x);
			t=ask(root[n],31,n-x+1);printf("%d\n",t);
		}
	}
    return 0;//养成好习惯
}
```
## 思路改进：
通过分析可以发现，因为查询的右边界始终是当时状态下的$n$，所以我们可以直接用$Trie$代替可持久化$Trie$.

代码略.

---

## 作者：subarude (赞：3)

# 单调栈 + 二分查找


题意大致为：

$\texttt{往一个空的队列的一端不断加数}$

$\texttt{维护最近加的 L 个数的最大值}$


------------

 _注意：**下文中的“下标”均指原数组的下标， 同时指栈中元素**_


我们可以维护一个保存原数组中数的**下标**的栈

使得这个栈中从栈底到栈顶的下标所对应的原数组中的数单调递减

换句话说，维护一个单调递增的栈

这个栈有什么~~优美的~~性质呢？

设这个栈中有两个元素`i`和`j`，原数组为`a[]`

__如果`i < j`则一定有`a[i] > a[j]`__



所以每次查询时找到栈中最小的比查询区间的左端点的的下标，答案就是这个下标所对应的数

又因为下标是从小到大加入栈的，所以每次查询时可以二分


------------


注意使用`scanf`输入单个字符时不会跳过空格

可以直接把字符当成字符串输入

------------
code：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

inline int read() {
    int op = 1, a = 0; char c = getchar();
    for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
    for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
    return op * a;
}

const int maxn = 2e5 + 5;
int m, mod;
int a[maxn], cnt;

struct HumdrumStack {
    int s[maxn], tail = 0;
    void insert(int x) { for (; tail && a[s[tail]] < a[x]; tail--); s[++tail] = x; }
    int query(int pos) { return *lower_bound(s + 1, s + tail + 1, pos); }
} sta;

int main() {
    m = read(), mod = read();
    int pre_ans = 0;
    for (; m; m--) {
        char opt[10]; scanf("%s", &opt);
        int x = read();
        if (opt[0] == 'A') { a[++cnt] = (1ll * x + pre_ans) % mod; sta.insert(cnt); }
        else if (opt[0] == 'Q') { pre_ans = a[sta.query(cnt - x + 1)]; cout << pre_ans << '\n'; }
    }
    return 0;
}
```

_by subarude_

---

## 作者：usqwedf (赞：3)

其实 本题除了单调栈+二分/线段树

也可以使用树状数组

在时间复杂度上是殊途同归的 均为 O(nlogn)

相信各位同学对于树状数组是熟悉的

因此我们只需修改一下求和即可

不过对于Pascal莫名其妙的取模和STD是C++的无奈

建议进行如下处理[因此WA了数次80]

```delphi
if p<=maxlongint then a[m]:=p mod k else a[m]:=(-(not p+1)) mod k; 
```

---

## 作者：king_xbz (赞：2)

拿到这道题，先审题，总共有两个操作：查询与插入。

查询是当前数列中末尾L个数中的最大的数，并输出这个数的值。

插入则是将n加上t，其中t是最近一次查询操作的答案，并将所得结果对一个固定的常DD取模，将所得答案插入到数列的末尾。

这两个操作明显符合栈的先进后出的特点：把数字往栈底堆，晚堆入的先被查询。

而可以支持查询与放入的数据结构有很多：这里我选择较为简单不易出错的树状数组

树状数组部分 code：
```cpp
inline void adds(int x,int y)
{
	for(fint i=x;i<=m;i+=lowbit(i))
	tree[i]=max(tree[i],y);
}
inline int ask(int x)
{
	int tot=0;
	for(fint i=x;i;i-=lowbit(i))
	tot=max(tot,tree[i]);
	return tot;
}
inline int lowbit(int x)
{
	return x&(-x);
}
```
不会树状数组的朋友[请戳这儿](https://www.luogu.com.cn/blog/kingxbz/solution-p3368)

这样我们就完成了处理查询与插入的函数

接下来我们就该利用栈先进后出的特性来解决问题了。

因为这里我们需要做到区间查询，而STL中的栈只支持读取栈顶元素，所以我们选择手写栈

初始栈顶为1，进栈的元素和为m，

我们每次插入将栈顶元素减一，然后在查询时读入栈顶向下b个位置的元素最大值

结合树状数组，我们可以得到以下代码：
```cpp
int top=1;

top+=m;

for(fint i=1;i<=m;i++)
	{
		cin>>a;
		b=read();
		if(a=='A')
		adds(--top,(b+t)%d);
		else
		if(a=='Q')
		{
		t=ask(top+b-1);
		cout<<t<<endl;
		}
	}
```
这样我们就完成了这道题。这道题数据并不毒瘤，多种方法均可，ac难度不大，祝大家ac愉快

---

## 作者：_蒟蒻__ (赞：2)

这个题，大佬们有用线段树的，ST表的，分块的……

蒟蒻感觉大佬们的数据结构有些大材小用了……

区间查询，单点修改……

糟了，是树状数组！！！

加入一个数，就是把原来为0的地方改成这个数呗。但是，问题来了，人家是从后往前区间查询……那好办！我们也从后往前加数。记一个队尾指针tail，每次查询区间长度为l的不就是查询前it+l-1吗。

人生苦短，直接放代码。

```cpp
#include<iostream>
#define lowbit(x) (x&(-x))
#define int long long // 我为何如此怠惰 
using namespace std;
const int N=200010;
int n,mod,it,la,t[N]; // 这里的it相当于上面的tail-1 (要往哪里填数)

inline void update(int x,int k)
{
	for(int i=x;i<=n;i+=lowbit(i))
		t[i]=max(t[i],k);
}

inline int query(int x)
{
	int ans=0;
	for(int i=x;i;i-=lowbit(i))
		ans=max(ans,t[i]);
	return ans;
}

signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>mod; it=n;
	for(int i=1;i<=n;i++)
	{
		char c[2]; int k;
		cin>>c>>k;
		if(c[0]=='A') update(it,(k+la)%mod), it--;
		else la=query(it+k), cout<<la<<'\n';
	}
	return ~~ (0 - 0) ;
}
```


---

## 作者：jokers (赞：2)

# 本题如果用线段树的话会很好想
## 直接将线段树中区间和变成区间最大值就好了
### 但是本题坑比较多，自己想完发现很多问题都没了

首先回顾一下题目：

维护一个序列，两个操作：

1、添加：前一次查询结果（初始为零）加上一个数n再模D，然后加到序列最后面

2、查询：输入一个数L，查询序列后L个数中的最大值；

### 思路
因为本来就是练线段树的，所以看完题直接往线段树上想

结果旁边一个*边缘ob一手，当然用树状数组啊，结果想了快半小时一直在树状数组和线段树间摇摆，最后玄学bp一手，发现线段数贼简单

### 正题
我们可以考虑维护一个最终的线段树

意思就是将所有的查询和添加操作用两个数组记下，然后可以得到最终序列的长度（用tot表示）

然后开始线段树模板的添加操作，我们按照时间线开始添加查询就o**k了

因为没有lazytag，所以个人认为这只是一个较简单的二叉树的应用

这是第一次的代码（80分加两个MLE）
```
#include <iostream>
#include <cstdio>
#include <cstring>
const int maxn=200010;
typedef long long ll;
using namespace std;
ll m,D,c[maxn<<2],a[maxn],bef,ans,tot,al[maxn],num[maxn];
inline ll read(){
    char c=getchar();
    ll x=0,f=1;
    while(c<'0'||c>'9'){
        if(c=='-') f=-1;
        if(c=='A') return 65;
        if(c=='Q') return 81;
        c=getchar();
    }
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
inline int ls(int k){
    return k<<1;
}
inline int rs(int k){
    return k<<1|1;
}
inline ll ma(ll x,ll y){
    return x>y?x:y;
}
inline void add(ll k,ll p,ll l,ll r){
    if(l==r&&l==p){
        c[k]=a[p];
        return;
    }
    c[k]=ma(c[k],a[p]);
    ll mid=(l+r)>>1;
    if(p<=mid) add(ls(k),p,l,mid);
    else add(rs(k),p,mid+1,r);
    return;
}
inline void qes(ll k,ll ql,ll qr,ll l,ll r){
    if(ql<=l&&qr>=r){
        ans=ma(ans,c[k]);
        return;
    }
    ll mid=(l+r)>>1;
    if(ql<=mid) qes(ls(k),ql,qr,l,mid);
    if(qr>mid) qes(rs(k),ql,qr,mid+1,r);
    return;
}
int main(){
    m=read();
    D=read();
    tot=0;
    bef=0;
    int sum=0;
    for(int i=1;i<=m;i++){
        ll s=read(),y=read();
        al[i]=s;
        num[i]=y;
        if(al[i]==65) tot++;
    }
    for(int i=1;i<=m;i++){
        ans=0;
        if(al[i]==65){
            a[++sum]=(num[i]+bef)%D;
            add(1,sum,1,tot);
        }
        if(al[i]==81){
            ll j=sum-num[i]+1;
            qes(1,j,sum,1,tot);
            bef=ans;
            printf("%lld\n",ans);
        }
    }
//	for(int i=1;i<=15;i++) printf("%lld ",c[i]);
    return 0;
}
```
然而我意识到三个二十万一个八十万的数组确实大了，所以不能建一个完全标准的线段树

我们退而求其次，因为m代表了操作个数，显然这个序列的长度会<=m

所以我们贪心一手，用[1,m]的区间来建树，这样就直接可以边输入边建树
代码如下
```
#include <iostream>
#include <cstdio>
#include <cstring>
const int maxn=200010;
typedef long long ll;
using namespace std;
ll m,D,c[maxn<<2],a[maxn],bef,ans,tot;
inline ll read(){
    char c=getchar();
    ll x=0,f=1;
    while(c<'0'||c>'9'){
        if(c=='-') f=-1;
        if(c=='A') return 65;
        if(c=='Q') return 81;
        c=getchar();
    }
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
inline int ls(int k){
    return k<<1;
}
inline int rs(int k){
    return k<<1|1;
}
inline ll ma(ll x,ll y){
    return x>y?x:y;
}
inline void add(ll k,ll p,ll l,ll r,ll t){
    if(l==r&&l==p){
        c[k]=t;
        return;
    }
    ll mid=(l+r)>>1;
    if(p<=mid) add(ls(k),p,l,mid,t);
    else add(rs(k),p,mid+1,r,t);
    c[k]=ma(c[ls(k)],c[rs(k)]);
    return;
}
inline void qes(ll k,ll ql,ll qr,ll l,ll r){
    if(ql<=l&&qr>=r){
        ans=ma(ans,c[k]);
//		printf("%lld %lld %lld\n",l,r,c[k]);
//		printf("%lld ",ans);
        return;
    }
    ll mid=(l+r)>>1;
    
    if(ql<=mid) qes(ls(k),ql,qr,l,mid);
    if(qr>mid) qes(rs(k),ql,qr,mid+1,r);
    return;
}
int main(){
    m=read();
    D=read();
    tot=0;
    bef=0;
    for(int i=1;i<=m;i++){
        ll s=read(),y=read();
        if(s==65){
            tot++;
            add(1,tot,1,m,(y+bef)%D);
        }
        if(s==81){
            ans=0;
            if(y==0){
                bef=0;
                printf("%lld\n",bef);
            }
            else{
            ll j=tot-y+1;
//			printf("%lld\n",j);
            qes(1,j,tot,1,m);
//			printf("\n");
            bef=ans;
            printf("%lld\n",ans);
            }
        }
    }
//	for(int i=1;i<=15;i++) printf("%lld ",c[i]);
    return 0;
}
```
会发现其实没有什么改变的（90分）最后一个点TLE

只是刷题的同学可以走了，记得把快读改成cin scanf随你

开始bb（洛谷||出题人）

最后一个点变成了TLE，这时我意识到可能这么简朴的算法无法解决非常大的数据

所以尝试去写了一手树状数组，额，老实说写到一半心态崩鸟

老老实实的回去改线段树，将第一个数据点刷到100ms后，心态再次崩塌

然后不诚实的我用题解交了一遍。。。

过了是过了，但是第一个点有三百多ms！！！

回头看了看只有100ms的我，果断把快读改成scanf
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
const int maxn=200010;
typedef long long ll;
using namespace std;
ll m,D,c[maxn<<2],a[maxn],bef,ans,tot;
inline ll ma(ll x,ll y){
    return x>y?x:y;
}
inline void add(ll k,ll p,ll l,ll r,ll t){
    if(l==r&&l==p){
        c[k]=t;
        return;
    }
    ll mid=(l+r)>>1;
    if(p<=mid) add((k<<1),p,l,mid,t);
    else add(k<<1|1,p,mid+1,r,t);
    c[k]=ma(c[k<<1],c[k<<1|1]);
    return;
}
inline void qes(ll k,ll ql,ll qr,ll l,ll r){
    if(ql<=l&&qr>=r){
        ans=ma(ans,c[k]);
//		printf("%lld %lld %lld\n",l,r,c[k]);
//		printf("%lld ",ans);
        return;
    }
    ll mid=(l+r)>>1;
    if(ql<=mid) qes(k<<1,ql,qr,l,mid);
    if(qr>mid) qes(k<<1|1,ql,qr,mid+1,r);
    return;
}
int main(){
    scanf("%lld%lld",&m,&D);
    tot=0;
    bef=0;
    for(int i=1;i<=m;i++){
        ll y;
        char s;
        cin>>s;
        scanf("%lld",&y);
        if(s=='A'){
            tot++;
            add(1,tot,1,m,(y+bef)%D);
        }
        if(s=='Q'){
            ans=0;
            if(y==0){
                bef=0;
                printf("%lld\n",bef);
            }
            else{
            ll j=tot-y+1;
//			printf("%lld\n",j);
            qes(1,j,tot,1,m);
//			printf("\n");
            bef=ans;
            printf("%lld\n",ans);
            }
        }
    }
//	for(int i=1;i<=15;i++) printf("%lld ",c[i]);
    return 0;
}
```
恩 过了。。。

woc过了，这里吐槽一手lg（可以认为是log，不针对任何人，单纯在讨论数学），明明最后一点卡了读入，结果还因为版权问题不给数据！！！

怪不得那么多oIers无故猝死

---

## 作者：henrytb (赞：1)

这道题就是线段树的简单应用啦~

因为一开始数组里一个数都没有，所以不用建树

标记也不用打qwq

注意区间长度为$0$的情况就AC啦qwq

附上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=200005;
int n,m;
long long d,t;
long long s[8*N];
void pluss(int l,int r,int x,int a,long long pl){
	if(l==r){
		s[x]+=pl;
		return;
	}
	int midd=(l+r)/2;
	if(a<=midd)pluss(l,midd,x*2,a,pl);
	if(a>midd)pluss(midd+1,r,x*2+1,a,pl);
	s[x]=max(s[x*2],s[x*2+1]);
}
long long ask(int l,int r,int x,int a,int b){
	if((a<=l)&&(b>=r))return s[x];
	long long summ=-2147483647;
	int midd=(l+r)/2;
	if (a<=midd)summ=max(summ,ask(l,midd,x*2,a,b));
	if (b>midd)summ=max(summ,ask(midd+1,r,x*2+1,a,b));
	return summ;
}
int main(){
	//freopen("in.txt","r",stdin);
	scanf("%d %lld\n",&m,&d);
	for(int i=1;i<=m;i++){
		char kkk;
		scanf("%c ",&kkk);
		if(kkk=='A'){
			n++;
			long long x;
			scanf("%lld\n",&x);
			pluss(1,m,1,n,(x+t)%d);
		}
		if(kkk=='Q'){
			int x;
			scanf("%d\n",&x);
			if(x==0){
				printf("0\n");
				continue;
			}
			t=ask(1,m,1,n-x+1,n);
			printf("%lld\n",t);
		}
	}
	return 0;
}
```

---

## 作者：kma_093 (赞：1)

不行困死了我先去睡觉起床了再把题解补上~~（然后就忘了）~~

我丢个代码在这先**（毒瘤数据害死人 B站一遍过 洛谷卡10回）**


------------
好我回来了。我们来口胡一下这道难（luo）题的题解。

首先我们来看一下题面：
```cpp
现在请求你维护一个数列，要求提供以下两种操作：

1、 查询操作。

语法：Q L

功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。

限制： L 不超过当前数列的长度。 (L > 0)

2、 插入操作。

语法：A n

功能：将 n 加上 t ，其中 t 是最近一次查询操作的答案（如果还未执行过查询操作，则 t=0 )，并将所得结果对一个固定的常数 D 取模，将所得答案插入到数列的末尾。

限制： n 是整数（可能为负数）并且在长整范围内。

注意：初始时数列是空的，没有一个数。
```
注意到查询操作的内容：**查询当前数列中末尾L个数中最大的数**，很自然联想到线段树维护区间最大值。

查询操作和模板好像差不多，输出query(1,总数-L+1，总数)走人，这道题主要是需要搞定插入操作。

看了看楼上的题解好像都是用朴素的数组存储线段树？

我来吹一波结构体大法好（大雾）

也就是这么个东西：
```cpp
struct segmentree{int l;int r;long long dat;}tree[800005];
```
其中l和r分别表示这个节点覆盖区间的左边界和右边界，dat表示这个节点存储的区间最大值。

这样在建树，更新数据，查询数据的时候就能用一个变量p表示节点编号，来囊括节点编号、节点覆盖区间左边界、节点覆盖区间右边界了。（反正我是觉得这么写比较简洁舒服）

添加操作也比较简单，大体思想就是从顶向下递归到叶节点更新叶节点的值，再一层一层地把最大值传上来即可。具体的解释放在代码里。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct segmentree{int l;int r;long long dat;}tree[800005];
long long a[800005],cnt=0;
int mod,m;
long long x,ans=0;
char operation;
void build_tree(int p,int l,int r){
	tree[p].l=l;tree[p].r=r;
	if(l==r){tree[p].dat=a[l];return;}
	int mid=l+r>>1;
	build_tree(p<<1,l,mid);
	build_tree(p<<1|1,mid+1,r);
	tree[p].dat=max(tree[p<<1].dat,tree[p<<1|1].dat);
}
void update(int val,int p,int cnt){
	if(tree[p].l==tree[p].r){tree[p].dat=val;return;}//如果到了叶节点，则更新叶节点的值，然后返回
	int mid=tree[p].l+tree[p].r>>1;
	if(cnt<=mid)update(val,p<<1,cnt);//如果要添加的值的位置（即数列添加后的长度）在左子树，则在左子树上递归查找
	if(cnt>mid)update(val,p<<1|1,cnt);//右子树同理
	tree[p].dat=max(tree[p<<1].dat,tree[p<<1|1].dat);//从子节点向父节点传递最大值信息
}
int query(int p,int l,int r){
	if(l<=tree[p].l&&r>=tree[p].r) return tree[p].dat;
	int mid=tree[p].l+tree[p].r>>1;
	int val=-(1<<30);
	if(l<=mid)val=max(val,query(p<<1,l,r));
	if(r>mid)val=max(val,query(p<<1|1,l,r));
	return val;
}
int main(){
	memset(tree,0,sizeof(tree));
	scanf("%d%d",&m,&mod);
	for(int i=1;i<=m;i++)a[i]=-(1<<60);
	build_tree(1,1,m);
	while(m--){
		cin>>operation>>x;
		if(operation=='Q'){
			if(x==0){printf("0");}
			else{
			ans=query(1,cnt-x+1,cnt);
			printf("%d\n",ans);
			}
		}
		if(operation=='A'){
			x%=mod;ans%=mod;x=(x+ans)%mod;
			update(x,1,++cnt);
		}
	}
	return 0;
}
```

---

## 作者：nekko (赞：1)

写了那么多XX树和单调队列后，不如试试爽翻天的倍(R)增(M)吧(Q)。

对于每一个点，维护从它为起点向左2^j长度的最大值。

查询的时候从大往小枚举2^j更新最大值就行。

（这不就是RMQ么为什么又复述了一遍啊喂）（划掉）

代码？http://www.cnblogs.com/KingSann/articles/7296397.html


---

## 作者：Mr_Wolfram (赞：1)

首先这是一道**线段树**裸题，但是线段树长度不确定，那么我们可以在建树的时候，将每一个节点初始化为-INF，每次往队尾加一个元素即一次单节点更新，注意本题的数据范围，其实并不用开 long long，具体请看注释。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
using namespace std;
const int MAXN=200005;
int read(){
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}
int MOD,m,t,ma[MAXN<<2],n;
void PushUp(int rt){
    ma[rt]=max(ma[rt<<1],ma[rt<<1|1]);
}
void build(int l,int r,int rt){
    if(l==r){
        ma[rt]=-0x7fffffff;
        return;
    }
    int mid=l+((r-l)>>1);
    build(lson);
    build(rson);
    PushUp(rt);
}
void Update(int add,int loc,int l,int r,int rt){
    if(r==loc&&l==loc){
        ma[rt]=add;
        return;
    }
    int mid=l+((r-l)>>1); //这样取平均数可以防溢出
    if(loc<=mid) Update(add,loc,lson);
    else Update(add,loc,rson);
    PushUp(rt);
}
int query(int L,int R,int l,int r,int rt){
    if(L<=l&&r<=R){
        return ma[rt];
    }
    int mid=l+((r-l)>>1);
    int q=-0x7fffffff;
    if(L<=mid){
        q=max(q,query(L,R,lson));
    }
    if(mid<R) q=max(q,query(L,R,rson));
    return q;
}
int main(){
    freopen("in.txt","r",stdin);
    m=read();MOD=read();
    build(1,m,1);
    for(int i=1;i<=m;i++){
        char c;
        scanf(" %c ",&c);
        int k=read();
        if(c=='A'){
            n++;
            k=((long long)k+t)%MOD;//注意防止溢出
            Update(k,n,1,m,1);
        }else {
            t=query(n-k+1,n,1,m,1);
            printf("%d\n",t);
        }
    }
    fclose(stdin);
    return 0;
}
```
等等。。本题只要求在队尾加入元素，而且要求的是队尾几个元素的最小值，那么这道题就可以用单调栈+二分来做，

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN=200005;
int read(){
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}
int m,MOD,t,stack[MAXN],head,num[MAXN],cnt;
int main(){
    freopen("in.txt","r",stdin);
    m=read();MOD=read();
    for(int i=1;i<=m;i++){
        char c;
        scanf(" %c ",&c);
        int k=read();
        if(c=='A'){
            k=((long long)k+t)%MOD;
            cnt++;
            while(stack[head]<=k&&head) head--;
            head++;
            stack[head]=k;
            num[head]=cnt;
        }else {
            int l=1,r=head,mid;
            k=cnt-k+1;
            while(l<=r){
                mid=(l+r)>>1;
                if(num[mid]<k){
                    l=mid+1;
                }else {
                    r=mid-1;
                }
            }
            t=stack[l];
            printf("%d\n",t);
        }
    }

    fclose(stdin);
    return 0;
}
```

---

## 作者：小黑AWM (赞：0)

# 学分块后切的第一题
### 这题竟然是蓝题
#### 考虑到题解中已经有了很多的线段树，单调栈，分块的题解。但草草看了一遍貌似并没有对操作进行分块的写法，于是水一篇题解。

该解法，码量较低，思路简单，解法自然，速度还行。

本解法的核心在于我们需要维护一个**后缀最大值**，利用$maxv[l]$表示从$l$到数列的末尾，这个区间中的最大值。

显然维护这样一个东西是$O(m)$的(因为是后缀所以每一次添加一个数都要从后往前重新维护一遍)，我们又有$m$次操作，复杂度就变成了$O(m^2)$

考虑分块（毕竟我今天刚学分块），如何使这个维护变得更容易呢？我们可以将**操作暂存**当暂存数达到一个量级$S$了就把maxv这个数组重构，

听着好像这个做法很混蛋，并没有什么用，复杂度貌似还是很大。

不过我们来推导一下，由于A和Q的操作总数加起来是M那可以认为A和Q的操作数的期望都是$M/2$

很容易可以算出该算法的复杂度的渐进上界约为$$O(M*{M\over S}+MS)\ge O({M\sqrt{M}})$$均值一下，再省略个常数就差不多了（如果有算错的地方请私信我QQ965296197）根据均值不等式易知，当这两项相等时，可取到等号。此时$$S={\sqrt{M}}$$（可以通过求根公式推出）粗略认为这是最优的~~虽然就是块大小取其他有可能会快一点~~。

这样的话算法的时间复杂度就被我们$O(M^2)$打到了$O(M\sqrt{M})$ yeah！这个复杂度其实对于这一题就足够了！

然后没当存储的操作数达到S就重构一下maxv数组，对于一个询问就先在暂存数组中暴力扫，然后多余的再在maxv中查询，这种分块还是很好写的，而且码量非常小。（对了单调栈我是真的没想到）

std:1092ms 2.14MB 比大部分的线段树还是要好一些的


```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int maxn = 2e5 + 20;
const long long minINF = (1<<64);
int m, d, m_size, top;
long long temp, n, maxv[maxn];//maxv是一个后缀最大值 maxv[l]表示区间[l,top]中的最大值
vector<long long> val;
char opt[3];

void reverse(){//每S个A操作进行一次约为O(M/2S)
    for(int i = 0; i < val.size(); i++)//O(S)
        maxv[++top] = val[i];
    for(int i = top-1; i >= 1; i--)
        maxv[i] = max(maxv[i], maxv[i+1]);;//O(M/2)
    val.clear();
}

long long query(int len){//可算作M/2次操作O(M/2)
    long long ans = minINF;
    for(int i = val.size() - 1; i >= 0 && len >= 0; len--,i--)
        ans = max(ans, val[i]);//先在当前存储的操作中查找O(S)
    if(len > 0)//如果len很大继续在maxv中O(1)查找
        ans = max(ans, maxv[top-len+1]);//maxv[top-(len-1)]表示倒数len个数中的最大值
    return ans;
}

int main(){
    scanf("%d%d", &m, &d);
    m_size = (1+(int)sqrt(1+2*m));
    while(m--){
        scanf("%s%lld", opt, &n);
        if(opt[0] == 'A'){
            val.push_back((n+temp)%d);
            if(val.size() > m_size)
                reverse();
        }else{
            scanf("%lld", &n);
            temp = query(n);
            cout << temp <<endl;
        }
    }
    return 0;
}

```

---

## 作者：EightSixSun (赞：0)

这道题可以用线段树离线做

不难想到，如果在插入第ii个数之前进行了11次查询，在插入第jj个数之前又要进行查询，那么题中的+t+t操作等价于给区间[i,j−1][i,j−1]加上插入第ii个数之前进行的查询的结果 

这样一来思路就比较明晰了

用q1记录插入的不经过+t处理的原数 

用q2记录查询的L 

用duan[i]来记录这个插入这个位置上的数之前要查询几次 

然后直接按q1来建树，然后从前向后扫一遍，用pre来记录上一个插入之前进行查询的位置，然后按上面说的来即可 

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define For(i,l,r) for(int i=l;i<=r;++i)
#define ls (x<<1)
#define rs ((x<<1)|1)
#define mid ((l+r)>>1)
#define lo long long
#define MAXN 200010
using namespace std;
lo int read()
{
    char c;bool t=0;lo int a=0;
    while((c=getchar())==' '||c=='\n'||c=='\r');
    if(c=='-'){t=1;c=getchar();}
    while(isdigit(c)){a*=10;a+=(c-'0');c=getchar();}
    return a*(t?-1:1);
}
lo maxx[MAXN*4],ans=-2147483647;
int q1[MAXN],q2[MAXN],D,l1=1,l2=1,m,duan[MAXN];
void build(int l,int r,int x)
{
    if(l==r)maxx[x]=q1[l];
    else
    {
        build(l,mid,ls);
        build(mid+1,r,rs);
        maxx[x]=max(maxx[ls],maxx[rs]);
    }
}
void modify(int l,int r,int x,int ll,int rr,int k)
{
    if(l==r)maxx[x]=(maxx[x]+k)%D;
    else
    {
        if(ll<=mid)
         modify(l,mid,ls,ll,rr,k);
        if(mid<rr)
         modify(mid+1,r,rs,ll,rr,k);
        maxx[x]=max(maxx[ls],maxx[rs]);
    }
}
void ask(int l,int r,int x,int ll,int rr)
{
    if(ll<=l&&r<=rr)ans=max(ans,maxx[x]);
    else
    {
        if(ll<=mid)
         ask(l,mid,ls,ll,rr);
        if(mid<rr)
         ask(mid+1,r,rs,ll,rr);
    }
}
int main()
{
    int pre=1,t2=1;
    char c;
    m=read();D=read();
    For(i,1,m)
    {
        while((c=getchar())==' '||c=='\n'||c=='\r');
        if(c=='A')//插入 
        {
            q1[l1]=read();++l1;
        }
        else//查询 
        {
            duan[l1]++;q2[l2]=read();++l2;//modify(pre,l1-1,ans)
        }
    }
    build(1,l1-1,1);
    For(i,1,l1)
    {
        if(duan[i])
        {
            if(ans!=-2147483647)//之前没有查询
             modify(1,l1-1,1,pre,i-1,ans);
            pre=i;
        }
        while(duan[i])
        {
            ans=-2147483647;
            ask(1,l1-1,1,i-q2[t2],i-1);
            printf("%lld\n",ans);
            ++t2;
            --duan[i];
        }
    }
    return 0;
}
```

---

## 作者：henry_y (赞：0)

# [推荐使用博客阅读](https://www.cnblogs.com/henry-1202/p/9090699.html)

题面

Description

　　现在请求你维护一个数列，要求提供以下两种操作：
  
  1、 查询操作。语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。
  
  2、 插入操作。语法：A n 功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取
模，将所得答案插入到数列的末尾。

限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个
数。

Input

　　第一行两个整数，M和D，其中M表示操作的个数(M <= 200,000)，D如上文中所述，满足D在longint内。接下来
M行，查询操作或者插入操作。

Output

　　对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。

Sample Input

5 100

A 96

Q 1

A 97

Q 1

Q 2

Sample Output

96

93

96

题解

这里提供两种做法，单调队列和线段树

先说一下线段树解法

一.线段树解法
首先看到这道题就能想到线段树吧

这道题的线段树代码也很容易打，毕竟都没有lazy标记，就是单纯的点修改

然后建树函数也可以不打的..这道题的插入其实就是一个建树的过程，如果不打建树函数的话代码前面memset一下-inf就好

下面是代码：
```
#include <cstdio>
#include <cstring>
#define ll long long
#define inf 0x7fffffff
#define il inline 
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll abs(ll x){return x>0?x:-x;}
il void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
il void read(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
using namespace std;
/*===================Header Template=====================*/
#define N 200010
ll t[N<<2],n,mod,len=0,T=0;
void update(ll L,ll c,ll l,ll r,ll rt){
    if(l==r){t[rt]=c;return;}
    ll mid=(l+r)>>1;
    if(L<=mid)update(L,c,l,mid,rt<<1);
    else update(L,c,mid+1,r,rt<<1|1);
    t[rt]=max(t[rt<<1],t[rt<<1|1]);
}
ll query(ll L,ll R,ll l,ll r,ll rt){
    if(L<=l&&R>=r)return t[rt];
    ll mid=(l+r)>>1,ans=-inf;
    if(L<=mid)ans=max(ans,query(L,R,l,mid,rt<<1));
    if(R>mid)ans=max(ans,query(L,R,mid+1,r,rt<<1|1));
    return ans;
}
int main(){
    memset(t,128,sizeof(t));
    read(n);read(mod);
    for(ll i=1;i<=n;i++){
        char c=getchar();
        ll num;read(num);
        if(c=='A'){
            len++;
            update(len,(num+T)%mod,1,n,1);
        }else {
            if(num){
                T=query(len-num+1,len,1,n,1)%mod;
                printf("%lld\n",T);
            }else {
                printf("0\n");
                T=0;
            }
        }
    }
    return 0;
}
 
```
　　

 

然而这道题是很玄学的，你把这个代码扔到洛谷上面会发现全部点MLE，然后在bzoj是能ac的...

如果要在洛谷提交就看一下我的代码理解一下思路自己试着打一个，或者说看看下面的单调队列写法

二.单调队列解法
 单调队列的写法就很简单了，但是很难想到这个做法，毕竟如果学过线段树第一时间想到的也会是线段树吧

这里维护一下最大值就好

 ```

#include <cstdio>
#include <cstring>
#define ll int
#define inf 1<<30
#define il inline 
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll abs(ll x){return x>0?x:-x;}
il void swap(ll &x,ll &y){ll t=x;x=y;y=t;}
il void read(ll &x){
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x*=f;
}
using namespace std;
/*===================Header Template=====================*/
#define N 200010
ll mx[N],a[N],p,m,mod,t,l=0;
char c[1];
int main(){
	read(m);read(mod);
	while(m--){
		scanf("%s%d",c,&p);
		if(c[0]=='A'){
			a[++t]=(l+p)%mod;
			for(ll i=t;i;i--){
				if(mx[i]<a[t])mx[i]=a[t];
				else break;
			}
		}else printf("%d\n",l=mx[t-p+1]);
	}
	return 0;
}
 ```

---

## 作者：Nero_Claudius (赞：0)

说起来这还是蒟蒻AC的第一道省选线段树呢。

这道题和其他线段树最大的不同就是在于本题数组一直在增大。

寻常的线段树蒟蒻习惯用如下的结构体储存，然而对于此题就不行了：

```cpp
struct node{
	int l, r;
	int val;
} tree[maxn << 2];
```

这是因为这道题没有用建树，因此l, r就不存在啊！

那么解决方法就是用朴实的tree数组储存val, l和r则手动传入函数！！

所以根据这个原理，稍微修改一下模板就可以得出全新的两个函数！！

```cpp
void Update(ll l, ll r, ll index, ll value, ll pos) {
    if(l == r) {
    	tree[pos] = value;
    	return ;
	}
    ll mid = (l + r) >> 1;
	if(mid >= index) Update(l, mid, index, value, pos << 1);
    if(mid < index) Update(mid + 1, r, index, value, pos << 1 | 1);
    tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1]);
}

ll Query(ll L, ll R, ll l, ll r, ll pos) {
    if(L >= l && R <= r) return tree[pos];
    ll mid = (L + R) >> 1;
    ll ans = 0;
    if(mid >= l) ans = max(ans, Query(L, mid, l, r, pos << 1));
    if(mid < r) ans = max(ans, Query(mid + 1, R, l, r, pos << 1 | 1));
    return ans;
}
```

注明：第二个函数中，L,R表示当前区间，l,r表示寻找的区间。

完整AC代码献上：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long ll;
const int maxn = 200200;

ll tree[maxn << 2];

ll m, d, t = 0, len = 0, x;
char op;

void Update(ll l, ll r, ll index, ll value, ll pos) {
    if(l == r) {
    	tree[pos] = value;
    	return ;
	}
    ll mid = (l + r) >> 1;
	if(mid >= index) Update(l, mid, index, value, pos << 1);
    if(mid < index) Update(mid + 1, r, index, value, pos << 1 | 1);
    tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1]);
}

ll Query(ll L, ll R, ll l, ll r, ll pos) {
    if(L >= l && R <= r) return tree[pos];
    ll mid = (L + R) >> 1;
    ll ans = 0;
    if(mid >= l) ans = max(ans, Query(L, mid, l, r, pos << 1));
    if(mid < r) ans = max(ans, Query(mid + 1, R, l, r, pos << 1 | 1));
    return ans;
}

int main() {
    cin >> m >> d;
    for(ll i = 0; i < m; i++){
        cin >> op >> x;
        if(op == 'Q') {
        	if(x == 0) {
        		t = 0;
        		cout << t << endl;
			} else {
				t = Query(1, m, len - x + 1, len, 1);
				cout << t << endl;
			}
		} else {
            len++;
            Update(1, m, len, (x + t) % d, 1);
        }
    }
}
```

------------

本代码1776ms， 氧化后1276ms。

比较玄学的一件事就是用cin过了，用scanf和快读却TLE了。【滑稽】

---

## 作者：何俞均 (赞：0)

# $splay$板子题呀。。。
## 楼下居然没有人写？？？

------------

### $splay$只要支持两个操作就行了：
#### 1、插入
#### 2、查询区间最大值
### 如果不会$splay$可以看下[这里](https://www.luogu.org/problemnew/show/P2042)和[这里](https://www.luogu.org/problemnew/show/P3391)
#### 不多说了，插入第一个值时注意一下就行了
## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>
#include<map>
#include<set>
#include<vector>
#include<queue>
#include<stack>
#include<algorithm>
#include<ctime>
#define RG register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
#define ll long long 
inline ll gl(){
    RG ll data=0,w=1;
    RG char ch=0;
    while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch>='0'&&ch<='9') data=(data<<1)+(data<<3)+(ch^48),ch=getchar();
    return w*data;
}

#define INF 999999999999999
#define N 200010
ll _t=0,MOD;
struct Node{int fa,ch[2],size;ll val,maxv;}t[N];
int root=0,total=2;
inline void update(RG int x){
	t[x].size=t[t[x].ch[0]].size+t[t[x].ch[1]].size+1;
    t[x].maxv=t[x].val;
    if(t[x].ch[0]) t[x].maxv=max(t[t[x].ch[0]].maxv,t[x].maxv);
    if(t[x].ch[1]) t[x].maxv=max(t[t[x].ch[1]].maxv,t[x].maxv);
}
inline int get(int x){return t[t[x].fa].ch[1]==x;}
void rotate(int x){
	int y=t[x].fa,z=t[y].fa,k=get(x);
	t[z].ch[get(y)]=x,t[x].fa=z;
	t[t[x].ch[k^1]].fa=y,t[y].ch[k]=t[x].ch[k^1];
	t[x].ch[k^1]=y,t[y].fa=x;
	update(y),update(x);
}
void splay(int x,int goal){
	while(t[x].fa!=goal){
		int y=t[x].fa,z=t[y].fa;
		if(z!=goal) (get(x)^get(y))?rotate(x):rotate(y);
		rotate(x);
	}
	if(!goal) root=x;
}
int k_th(int k){
	int x=root;
	while(1){
		if(t[t[x].ch[0]].size+1==k) return x;
		else if(t[t[x].ch[0]].size+1<k) k-=(t[t[x].ch[0]].size+1),x=t[x].ch[1];
		else if(t[t[x].ch[0]].size+1>k) x=t[x].ch[0];
	}
}
void insert(int k,ll v){
	total++;
	if(k==1){
		root=3;
		t[1].fa=t[2].fa=3;
		t[3].ch[0]=1,t[3].ch[1]=2;
		t[3].val=t[3].maxv=v;
		t[1].ch[0]=t[1].ch[1]=t[2].ch[0]=t[2].ch[1]=0;
		update(1),update(2),update(3);
	}
	else{
	    int nx0=k_th(k),nx1=k_th(k+1);
	    splay(nx0,0);splay(nx1,root);
	    t[t[root].ch[1]].ch[0]=total;
	    t[total].size=1,t[total].val=t[total].maxv=v;
	    t[total].fa=nx1;
    }
}
ll query(int l,int r){
	l=k_th(l);r=k_th(r+2);
	splay(l,0);splay(r,root);
	return t[t[r].ch[0]].maxv;
}
int main(){
	int T=gl();MOD=gl();
	t[1].val=t[2].val=t[1].maxv=t[2].maxv=-INF;
	t[1].size=1,t[1].fa=2;
	t[2].ch[0]=1,t[2].size=2;root=2;
	while(T--){
		char ch[10];
		scanf("%s",ch);
		if(ch[0]=='A') {
			ll v=(gl()+_t)%MOD;
			insert(total-1,v);
		}
		if(ch[0]=='Q'){
			int L=gl();
			_t=query(total-L-1,total-2);
			printf("%lld\n",_t);
		}
	}
	return 0;
}
```
~~常数有点大，最后一个点过不去~~

---

## 作者：王小宇 (赞：0)

## 这道题并不需要提前建树，只要按照输入的顺序挨个添加就好啦

### 要是不会线段树的话，可以先去看一下线段树模板1

我觉得自己的这个写法还是挺简单的呀


```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
#include<math.h>
#include<queue>
#include<cstdio>
#define MAXN 200000
#define LL long long
#define INF 20000010
using namespace std;
int last,m,d,t;
int tree[MAXN*4];//不要忘了，线段树要开到4倍的大小
int query(int now,int l,int r,int check_l,int check_r)//查询操作，now代表当前搜索的线段的编号，l和r是当前线段的左右端点，check_l和check_r是左右边界，也就是每次题目输入中给定的范围 
{
    if ((l>=check_l)&&(r<=check_r)) return tree[now];//如果当前线段全部在范围内直接return
    int ans=-1*INF,mid;//ans要初始化为一个大负数，因为有的边可能是负数
    mid=(l+r)>>1;//取中点
    if (mid>=check_l) ans=max(ans,query(now<<1,l,mid,check_l,check_r));
    if (mid<check_r) ans=max(ans,query(now<<1|1,mid+1,r,check_l,check_r));//和线段树模板查询部分一样的操作，只不过是由求和变成求最大值
    return ans;//返回ans
}
void pushup(int now,int l,int r,int position,int num)//插入操作，now也是当前线段的编号，l和r是当前线段的两个端点，position是要插入的值在数列中的编号，num是要插入的值的大小
{
    if ((l==position)&&(r==position)) //如果找到了要插入的点的位置
    {
        tree[now]=num;
        return;//赋值一下并且return
    }
    int mid;
    mid=(l+r)>>1;//取中点
    if (position<=mid) pushup(now<<1,l,mid,position,num);
    if (position>mid) pushup(now<<1|1,mid+1,r,position,num);//依旧是与模板一样的操作，往左子树或者右子树搜索
    tree[now]=max(tree[now<<1],tree[now<<1|1]);//不要忘记更新一下最大值
}
int main()
{
    char c;
    int i,j;
    LL n;
    scanf("%d%d",&m,&d);
    for (i=1;i<=m;i++) tree[i]=-1*INF;
    for (i=1;i<=m;i++)
    {
        cin>>c;
        scanf("%lld",&n);
        if (c=='Q')
        { 
            int ans;
            ans=query(1,1,m,last-n+1,last);//后n个数的范围应该是  总个数-n+1   ->   数列末尾
            printf("%d\n",ans);
            t=ans;//更新一下t值，下一次操作可能会用到
        }
        if (c=='A')
        {
            last++;//last记录的是一共有多少个线段，也就是这一个新插入的线段在数列中的位置
            int num;
            num=(n+t)%d;
            pushup(1,1,m,last,num);
        }
    }
    return 0;
} 
```
认真仔细一下就好了，不是太难吧


---

## 作者：东寺丶闲人 (赞：0)

##最大数maxnumber


####题解


显然这道题是一道线段树的题。

题意为有两种操作。第一种是询问区间后n个元素中最大值，第二种是在区间后添加一个值为n的数。

那么怎么在线段树的末尾插入一个元素呢，

我们可以把问题转化为在建树的时候把线段树的末尾添加若干的0,然后更新单个节点的值。之后的问题就很显然了。

切记开long long!!!

还有，输入数据行末有若干的空格！！！！！！！（调了好久。。。。）


####代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL n,m,num,mod,last_ans;
char kg,opt;
struct Point{
    LL l,r,maxx;
    Point *son1,*son2;
    Point(){l=0,r=0,maxx=0,son1=NULL,son2=NULL;}
    void init(LL l,LL r,Point *p){
        if(l>=r) return;
        p->son1=new Point();
        p->son2=new Point();
        LL m=(l+r)>>1;
        p->son1->l=l;p->son1->r=m;
        p->son2->l=m+1;p->son2->r=r;
        init(l,m,p->son1);
        init(m+1,r,p->son2);
    }
    void add(Point *p,LL x,LL num){
        if(p->l==p->r){ p->maxx=num;return;}
        LL m=(p->l+p->r)>>1;
        if(x<=m) add(p->son1,x,num);
        else add(p->son2,x,num);
        p->maxx=max(p->son1->maxx,p->son2->maxx);
    }
    LL ask(LL l,LL r,Point *p){
        if(l<=p->l&&r>=p->r){
            return p->maxx;
        }
        LL m=(p->l+p->r)>>1;
        LL x1=0,x2=0;
        if(l<=m) x1=ask(l,r,p->son1);
        if(r>m) x2=ask(l,r,p->son2);
        return max(x1,x2);
    }
}*point;
int main(){
    scanf("%lld%lld",&m,&mod);
    point=new Point();
    point->l=1;point->r=m;
    point->init(1,m,point);
    for(LL i=1;i<=m;i++){
        scanf("%c%c%lld",&kg,&opt,&num);
        if(opt=='A'){
            num+=last_ans;
            num%=mod;
            n++;
            point->add(point,n,num);
        }
        else{
            last_ans=point->ask(n-num+1,n,point);
            printf("%lld\n",last_ans);
        }
    }

    return 0;
}

```

---

## 作者：cacfov (赞：0)

这是我第一道线段树题目，刚开始把t当成上一次添加的数了，然后wa了两次。。。。手动滑稽。

题比较裸，听说线段树算暴力。。。好吧可能是，我没有像楼下一样存下来问题，我觉得直接处理比较简单。其实和模拟差不多。弱弱的我不会动态添加树，所以直接建成最大状态，所有点初始值为0.用tot记录现在为止有多少个数。如果不会线段树的话可以看看这个博客http://blog.csdn.net/metalseed/article/details/8039326，我感觉还是写的很详细的。因为直接最大状态，所以代码里没有建树的操作，直接读入，加点，询问，自己写了max使用了一些位运算，（看讨论里说线段树会tle所以就多此一举了，其实没毕要）代码有注释。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
char s;
int n,d,tot;
long long x,t,tree[800010];
int  Max(int a,int b){//手写max其实好像没什么影响
    if(a<=b)
    return b;
    else
    return a;
}
void add(int id,int be,int en,int pos,int ad){//加数的函数，be和en代表每个tree[id]所管的区间，pos是新加入点所在的位置。ad为它的值
    if(be==en){
        tree[id]=ad;因为初始为0，所以直接直接赋值
        return ;
    }
    int m=(be+en)/2;
    if(pos<=m){
        add(id<<1,be,m,pos,ad);//这里是看pos在左还是右
    }
    else
        add((id<<1)+1,m+1,en,pos,ad);
    tree[id]=Max(tree[id<<1],tree[(id<<1)+1]);//回溯修改父亲
}
int qu(int id,int be,int en,int l,int r){//询问函数，l和r表示询问区间
    int p1,p2;
    if(l>en||r<be)return -1;//不符合要求直接返回
    if(be>=l&&r>=en)//线段数的这个节点在区间内，返回答案
        return tree[id];
    int m=(be+en)/2;
    p1=qu(id<<1,be,m,l,r);
    p2=qu((id<<1)+1,m+1,en,l,r);
    if(p1==-1)return p2;//对返回的答案进行比较
    if(p2==-1)return p1;
    if(p1>p2)return p1;
    else return p2;
}
int main(){
    cin>>n>>d;
    for(int i=1;i<=n;i++){
        cin>>s>>x;
        if(s=='A'){
            x=(x+t)%d;
            add(1,1,200000,++tot,x);
        }
        else{
            x=tot-x+1;
            x=qu(1,1,200000,x,tot);
            t=x;
            cout<<x<<endl;
        }
    }
    return 0;
}
```
自认为代码写得比较美观。。。。。。
//第一份题解。。。。


---

## 作者：xzyxzy (赞：0)

做完之后看了那么多题解。。。

只有我用线段树没打成功然后用的单调栈？！

可以这么想，反正查询的是后面的，就在后面加元素嘛

那么假设加入元素到top位置，但是top-1比加入的元素要小

于是我们就可以愉快地把top-1那个位置删掉了

为什么呢，，自己想

然后因为这是一个递减的单调栈查找用二分会快一些

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define ll long long
using namespace std;
ll m,mod;
ll zhan[2][200001];//[0]存标号[1]存数值
ll top=0;
ll cnt=0;//标号
ll x,k,t;
int main()
{
    scanf("%lld%lld\n",&m,&mod);
    for(register int Q=1;Q<=m;Q++)
    {
        //cout<<"Q="<<Q<<endl;
        register char sort1[10];
        scanf("%s%lld\n",sort1,&x);
        if(sort1[0]=='A')
        {
            k=((x+t)%mod+mod)%mod;
            cnt++;
            while(k>=zhan[1][top]&&top>0)top--;
            zhan[0][++top]=cnt;
            zhan[1][top]=k;            
        }
        else
        {
            if(x==0){printf("0\n");t=0;continue;}
            register int l=1,r=top,res;
            while(l<=r)
            {
                register int mid=(l+r)>>1;
                if(zhan[0][mid]<cnt-x+1)l=mid+1;
                else r=mid-1,res=mid;
            }
            t=zhan[1][res];
            printf("%lld\n",t);
        }
        //for(int i=1;i<=top;i++)printf("zhan[%d]:[0]=%d,[1]=%d\n",i,zhan[0][i],zhan[1][i]);
    }
    return 0;
}

```
好吧如果k在top位置那么比k小的在top-1，当要统计top-1到cnt的最大值的时候

一定会算到top位置，于是k比前一个数大那么前一个数就没卵用了


现在数据加强了，大家主意有L=0的情况另外字符串读入要用scanf，非常感谢@milkfilling的提醒！


---

## 作者：斯德哥尔摩 (赞：0)

这题就是一个 裸的线段树，但 线段树 每个节点存 一段区间中的最大值，

这样就可以保证每次询问都不用再扫一遍数据，否则除了 TLE 就是 30%AC 。。。

话说 线段树 除了常数大了之外好像没有什么缺点。。。（因为我只会写线段树，吃枣药丸）

**不要复制代码！不要复制代码！！不要复制代码！！！重要的事情说3遍！**

附代码（缩进不喜勿喷）：

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#define LSON rt<<1
#define RSON rt<<1|1//方便实用的宏。。。
#define max(a,b) a>b?a:b//STL的函数比手写的慢，所以为了减小被卡常数的几率，手写。。。
#define MAXN 200005
using namespace std;
int m,d;
long long t=0,a[MAXN<<2];//线段树 的空间是 原数据 的 4 倍，这是一定的
inline long long read(){//弱弱的读入优化，但好像没有什么用。。。防止被卡常吧
       long long date=0,w=1;char c=0;
       while(c!='-'&&(c<'0'||c>'9'))c=getchar();
       if(c=='-'){w=-1;c=getchar();}
       while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
       return date*w;
}
void pushup(int rt){
     a[rt]=max(a[LSON],a[RSON]);//每个节点存 区间最大值
}
void update(int l,int r,int rt,int x,long long y){//针对题目的输入，建树与插入的合体。。。
     int mid;
     if(l==r){
              a[rt]=y;//叶子结点时赋 区间最大值
              return;
              }
     mid=l+r>>1;//位运算，经验靠诉我们 >>1 比 /2 快很多。。。
     if(x<=mid)update(l,mid,LSON,x,y);
     else update(mid+1,r,RSON,x,y);//分 左子树 与 右子树 建立
     pushup(rt);//一定不要忘记这句话！！！很重要！！！
}
long long query(int l,int r,int rt,int x,int y){
     int mid;
     long long ans=-2147483647;//注意，千万不要设成 0 ，当初我提交3次，2次被卡
     if(x<=l&&y>=r)//出了范围就返回区间最大值
     return a[rt];
     mid=l+r>>1;
     if(x<=mid)ans=max(ans,query(l,mid,LSON,x,y));
     if(mid<y)ans=max(ans,query(mid+1,r,RSON,x,y));//还是 左子树 与 右子树 处理
     return ans;//不同上！！！一定要返回答案！！！
}
int main(){
    int x,s=0;
    char c[2];
    m=read();d=read();
    for(int i=1;i<=m;i++){
            scanf("%s",c);//每行首字为 字符，为避免读入 回车符 ‘\n’ 或者 "\r\n"，用 %s ，这是一个很实用的东东。。。
            if(c[0]=='A'){//分情况处理。。。
                          x=read();
                          s++;
                          x=(x+t)%d;
                          update(1,m,1,s,x);//询问范围是 1 到 m
                          }
            if(c[0]=='Q'){
                          x=read();
                          t=query(1,m,1,s-x+1,s);//这里只是为了 t 能在下一次询问时使用
                          printf("%lld\n",t);//注意，t 为 long long，不然会炸。。。
                          }
            }
    return 0;//收尾。。。
}

```

---

## 作者：Anoxiacxy (赞：0)

# 树状数组维护前缀最大值

看到这一个数据结构大战题，我也来发一波题解

考虑到树状数组维护的是一个前缀的关系，那么对于这一题，也是可以维护前缀的最大值的

```cpp
LL sz[300100];
int lowbit(int x){return x&(-x);}
```
以下是维护前缀最大值的查询与添加代码，相对于之前的树状数组，

我们只需要将加值改为取max即可

```cpp
LL query(int x){//查询操作
    LL rtn=0;
    for(int i=x;i;i-=lowbit(i))
        rtn=max(rtn,sz[i]);
    return rtn;
}
LL updata(int x,LL v){
    for(int i=x;i<=m;i+=lowbit(i))
        sz[i]=max(sz[i],v);
}
```
当然，这个程序不支持值的修改，不过对于这道只在尾部添加元素的题目来说已经够用了

下面是AC代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define LL long long
using namespace std;
int m,size;LL d;
LL sz[300100];
int lowbit(int x){
    return x&(-x);
}
LL query(int x){
    LL rtn=0;
    for(int i=x;i;i-=lowbit(i))
        rtn=max(rtn,sz[i]);
    return rtn;
}
LL updata(int x,LL v){
    for(int i=x;i<=m;i+=lowbit(i))
        sz[i]=max(sz[i],v);
}
int main(){
    scanf("%d%lld",&m,&d);
    LL t=0; size=m;
    for(int i=1;i<=m;i++){
        char ch[2];scanf("%s",ch);
        if(ch[0]=='A'){
            LL n;scanf("%lld",&n);
            n=(n+t)%d;
            updata(size,n);
            size--;
        }
        else {
            int L;scanf("%d",&L);
            printf("%lld\n",t=query(size+L));
        }
    }
    return 0;
}
```

---

## 作者：bobble (赞：0)

### 思路

###### 线段树小试牛刀！qwq


[骗访问量233](http://www.cnblogs.com/tonylim/p/6596186.html)


> 先建一颗空的线段树，然后每次把值插入，
> 用num统计个数
> 然后每次查询num-n+1到num这个区间的
> 最大值输出就是啦

### 代码


``` pascal 

program maxnumber;
const
  inf='maxnumber.in';
  outf='maxnumber.out';
type
  tree=^node;
  node=record
          lc,rc:tree;
          l,r,val:longint;
       end;

var
  i,m,n,d,ctot,num,l:longint;
  ch:char;
  t:tree;
  s,e,a:array[1..200000] of longint;

function max(aa,bb:longint):longint;
begin
  if aa>bb then exit(aa)
    else exit(bb);
end;

function min(aa,bb:longint):longint;
begin
  if aa>bb then exit(bb)
    else exit(aa);
end;

procedure add(apple:longint);
begin
    inc(num);
    a[num]:=apple mod d;
end;

procedure add(var t:tree; seat:longint; data:longint);
begin
    if t^.l=t^.r then begin
                        t^.val:=max(t^.val,data);
                        exit;
                      end;
    if seat<=t^.lc^.r then add(t^.lc,seat,data)
    else add(t^.rc,seat,data);
    t^.val:=max(t^.val,data);
end;

procedure build(var t:tree; l,r:longint);
var
  mid:longint;
begin
    new(t);
    t^.l:=l;    t^.r:=r;
    if l=r then begin
                  t^.val:=a[l];
                  exit;
                end;
    mid:=(l+r) div 2;
    build(t^.lc,l,mid);
    build(t^.rc,mid+1,r);
    t^.val:=max(t^.lc^.val,t^.rc^.val);
end;

function query(var t:tree; l,r:longint):longint;
var
  mm:longint;
begin
   if (t^.l=t^.r) or ((t^.l>=l) and (t^.r<=r)) then exit(t^.val);
   mm:=-maxlongint;
   if l<=t^.lc^.r then mm:=query(t^.lc,l,min(t^.lc^.r,r));
   if r>=t^.rc^.l then mm:=max(mm,query(t^.rc,max(t^.rc^.l,l),r));
   exit(mm);
end;

begin
 // assign(input,inf);    assign(output,outf);
  reset(input);     rewrite(output);

  readln(m,d);
  build(t,1,m);
  l:=0;
  for i:= 1 to m do
   begin
     readln(ch,n);
     if ch='A' then begin num:=num+1;   add(t,num,(n+l) mod d);   end
       else begin
              l:=query(t,num-n+1,num);
              writeln(l);
            end;
   end;

  close(input);
  close(output);
end.


```

---

## 作者：腾飞 (赞：0)

树状数组

设原数列为c,树状数组为a.

(实际编程时c是用不到的)

a中存最大值

先算出数列总长len。

建立树状数组的时候反向建立。

num存数列为空的长度，

即a[1]到a[num]为-maxlongint，a[num+1]到a[len]存有数据。

对于Q操作，即求c[1]到c[num+L]的最大值

对于A操作，在c[num]处更新。

附上pascal代码

```cpp
const
  oo=-maxlongint;
var
  a:array[1..200000] of longint;
  s:char;
  d,i,j,m,t,len,num:longint;
  b:array[1..200000,1..2] of longint;
function max(x,y:longint):longint;
  begin
    if x>y then exit(x)
    else exit(y);
  end;
function lowbit(x:longint):longint;
  begin
    lowbit:=x and -x;
  end;
procedure update(n,x:longint);//更新操作（操作A）
  begin
    while n<=len do
    begin
      a[n]:=max(a[n],x);
      n:=n+lowbit(n);
    end;
  end;
function ask(x:longint):longint;//询问操作（操作Q）
  begin
    ask:=oo;
    while x>0 do
    begin
      ask:=max(ask,a[x]);
      x:=x-lowbit(x);
    end;
  end;
begin
  readln(m,d);
  len:=0;
  for i:=1 to m do
  begin
    read(s);
    readln(b[i,2]);
    if s='Q' then  b[i,1]:=1
    else if s='A' then
    begin
      b[i,1]:=2;
      b[i,2]:=b[i,2] mod d;
      inc(len);  //有一个A长度就+1
    end;
  end;
  t:=0;
  for i:=1 to len do
    a[i]:=oo;
  num:=len;//刚开始所有数都是-maxlongint
  for i:=1 to m do
  begin
    if b[i,1]=1 then//Q操作
    begin
      t:=ask(num+b[i,2]);
      writeln(t);
    end
    else if b[i,1]=2 then//A操作
    begin
      update(num,(b[i,2]+t) mod d);
      dec(num);//更新一个数，num就减一
    end;
  end;
end.
```

---


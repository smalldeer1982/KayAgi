# [XJTUPC 2025] 结束乐队

## 题目描述

**「我是来结束乐队的」**

某个少女乐队正在进行合照，可摄影师不怀好意，她打算对拍出的照片进行处理后再发布社交媒体，引起粉丝们的不满，这会导致乐队中某些成员人气的升降。她觉得这样就能结束这支乐队了。她的计划如下：

已知少女乐队有 $n$ 个成员，从左到右排成一排照相，其中每个成员的初始人气排名并不相同，分别从排名第 $1$ 到第 $n$。摄影师打算拍 $k$ 张照片并在每次拍完之后公开到社交媒体，她的每张照片只包含乐队成员排列中连续的一段，这样这段照片中未出现成员中的人气排名最靠前的成员的粉丝就会红温脱粉，导致这名成员的排名下降一名（原低一名的成员排名会上升）。通过 $k$ 次操作，她成功打乱了乐队成员的排名，她的目的就达到了。 

但现在她遇到了一个问题，因为乐队的成员太多了，对于每次截取下来的某一段照片，她不能判断哪个未出现的成员排名最靠前，所以她求助于你，希望你帮她解决问题。

形式化的，给定一个从 $1$ 到 $n$ 的排列 $a_1, a_2, \dots, a_n$，进行 $k$ 次操作，每次操作：

- 给定一个区间 $[l,r]$，求 **当前排列中区间 $[l,r]$ 上未出现的最小正整数** 是多少，并设此数为 $x$（即 $x=\min\{p\mid \forall i \in [l,r],p\neq a_i,p\geq 1\}$）；
  - 若 $x<n$，则输出 $x$，并交换当前排列 $a_1, a_2, \dots, a_n$ 中数字 $x$ 与 $x+1$ 的位置；
  - 若 $x\ge n$，则输出字符串 $\tt{peace}$。

其中，从 $1$ 到 $n$ 的排列 $a_1, a_2, \dots, a_n$，是指满足 $\{a_1, a_2, \dots, a_n\} = \{1, 2, \dots n\}$ 的一组数。

## 说明/提示

对于第一组样例：

第一次操作 $[2,4]$，当前排列为 $4,3,1,2,5$。

区间 $[2,4]$ 内未出现的最小正整数为 $4$，输出 $4$ 并交换排列中 $4$ 和 $5$ 的位置。

第二次操作 $[2,5]$，当前排列为 $5,3,1,2,4$。

区间 $[2,5]$ 内未出现的最小正整数为 $5$，输出 $\tt{peace}$，排列不变。

第三次操作 $[1,3]$，当前排列为 $5,3,1,2,4$。

区间 $[1,3]$ 内未出现的最小正整数为 $2$，输出 $2$ 并交换排列中 $2$ 和 $3$ 的位置。

第四次操作 $[1,3]$，当前排列为 $5,2,1,3,4$。

区间 $[1,3]$ 内未出现的最小正整数为 $3$，输出 $3$ 并交换排列中 $3$ 和 $4$ 的位置。

第五次操作 $[1,5]$，当前排列为 $5,2,1,4,3$。

区间 $[1,5]$ 内未出现的最小正整数为 $6$，输出 $\tt{peace}$，排列不变。

## 样例 #1

### 输入

```
5
4 3 1 2 5
5
2 4
2 5
1 3
1 3
1 5```

### 输出

```
4
peace
2
3
peace```

## 样例 #2

### 输入

```
10
10 9 4 3 2 1 6 5 8 7
3
1 10
2 9
3 9```

### 输出

```
peace
7
8```

# 题解

## 作者：Amiyawasdonkey (赞：4)

~~作为少女乐队痴，我必须来写一写这个题解。~~

因为题目已有形式化题目描述，因此直接给出思路。

# 思路

我们可以看到，该题目包含**区间查询**与**单点修改**的要素，因此我们想到线段树。事实上，这是一道非常好的线段树板子题，可以拿来练手。

题目要点是查询在 $[l,r]$ 上**未出现的最小正整数**，假如我们从正面入手，很难想到该怎样在每个子节点存下这个值，但我们应该有**正难则反**的思维意识，想到查询在 $[1,l-1]$ 与 $[r+1,n]$ 上出现的**最小值**也是同样的效果。这样，我们可以在每个子节点存储该区间上出现的最小值，从而方便地查询到答案。

注：在进行单点修改操作时，我们可以维护一个数组来存储每个数字所在的位置，在修改操作完成时一并修改操作的数的位置，从而方便地进行单点修改操作。

# Code

```cpp
#include<bits/stdc++.h>
#define Iseri namespace
#define Nina std
#define Kawaragi int
#define Momoka main
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define ll long long
#define ull unsigned long long
#define endl "\n"
const int maxn=500005;

using Iseri Nina;

inline ll read(){//快读
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

//===========================================================

struct node{
	ll l,r;
	ll mn;
}t[maxn*4];

ll n,a[maxn],l,r,m,ans=0,pos[maxn];//pos是每个数的位置

inline void pushup(ll p){//更新区间最小值
	t[p].mn=min(t[ls(p)].mn,t[rs(p)].mn);
	return;
}

inline void build(ll p,ll l,ll r){//建树
	t[p].l=l,t[p].r=r;
	if(l==r){
		t[p].mn=a[l];
		return;
	}

	ll mid=(l+r)>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	pushup(p);
	return;
}

inline ll ask(ll p,ll dl,ll dr){//查询操作
	if(t[p].l>=dl&&t[p].r<=dr)return t[p].mn;

	ll mid=(t[p].l+t[p].r)>>1,ans=1145141919;
	if(mid>=dl)ans=min(ans,ask(ls(p),dl,dr));
	if(mid<dr)ans=min(ans,ask(rs(p),dl,dr));
	return ans;
}

inline void change(ll p,ll x,ll d){//修改操作
	if(t[p].l==x&&t[p].r==x){
		t[p].mn=d;
		return;
	}

	ll mid=(t[p].l+t[p].r)>>1;
	if(mid>=x)change(ls(p),x,d);
	else change(rs(p),x,d);
	pushup(p);
	return;
}

Kawaragi Momoka(){
	n=read();
	for(ll i=1;i<=n;i++)a[i]=read(),pos[a[i]]=i;
	build(1,1,n);

	m=read();
	while(m--){
		l=read(),r=read();
		ll x=1145141919,y=1145141919;//设极大值
		if(l>1)x=ask(1,1,l-1);//注：在l=1的情况下，不能进行左边区间查询，无意义
		if(r<n)y=ask(1,r+1,n);//同理，r=n的情况下，不能进行右边区间查询，无意义
		ans=min(x,y);
		if(ans>=n)printf("peace\n");
		else{
			printf("%lld\n",ans);
			change(1,pos[ans],ans+1);//修改操作
			change(1,pos[ans+1],ans);
			swap(pos[ans],pos[ans+1]);//更新数字所在位置
		}
	}
	return 0;
}
```

提交记录：[这里](https://www.luogu.com.cn/record/217853372)

---

## 作者：Sunrise_up (赞：4)

这题看上去很难，实则不然。

我们首先看到数据范围很大，所以我们应该写个单次查询 $O(1)$ 或者是近似的算法。

那有什么算法呢？我们很容易想到答案是 st 表和线段树。

注意到这是查询后就会变换的（动态），所以我们应该用线段树。

那这题怎么用呢？很简单。这题实际上单词查询就是求 $(1,l]$ 和 $[r,n)$ 的最小值。如果没有数或者是最小值是 $n$ 那么就输出  $\tt{peace}$。

这里实际上还有一个优化的点，就是预处理数字所在的位置，因为这题不是数列，是排序。

然后用个快读或者关闭同步输入输出流（或者其他的）就行了。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=1e6;
int n,k,l,r,lm,rm;
struct Tree{
    int n;
    vector<int> tree;
    Tree(int size){
        n=1;
        while(n<size)n<<=1;
        tree.resize(2*n,INF);
    }
    void upd(int pos,int val){
        pos+=n-1;
        tree[pos]=val;
        while(pos>1){
            pos>>=1;
            tree[pos]=min(tree[2*pos],tree[2*pos+1]);
        }
    }//动态更新数组
    int query(int a,int b){
        a+=n-1;
        b+=n-1;
        int res=INF;
        while(a<=b){
            if(a%2==1)res=min(res,tree[a++]);
            if(b%2==0)res=min(res,tree[b--]);
            a>>=1,b>>=1;
        }
        return res;
    }//a到b区间的最小值
};
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;
    vector<int> a(n+1);
    vector<int> pos(n+2);//节约空间，pos代表位置
    for(int i=1;i<=n;i++){
        cin>>a[i];
        pos[a[i]]=i;
    }
    Tree st(n);
    for(int i=1;i<=n;i++)st.upd(i,a[i]);
    cin>>k;
    while(k--){
        cin>>l>>r;
        lm=rm=INF;
        if(l>1)lm=st.query(1,l-1);
        if(r<n)rm=st.query(r+1,n);
        int x=min(lm,rm);
        if(x>=n){
            cout<<"peace"<<endl;
        }else{
            cout<<x<<endl;
            swap(a[pos[x]],a[pos[x+1]]);
			st.upd(pos[x],x+1),st.upd(pos[x+1],x);
			swap(pos[x],pos[x+1]);//一定要放在上一句的后面，我在这卡了好久q_q
        }
    }
    return 0;
}
```

点个赞吧qwq！

---

## 作者：The_foolishest_OIer (赞：3)

很典的线段树。

找出不在区间 $[l,r]$ 上的最小值，实际上就是找 $[1,l-1]$ 和 $[r+1,n]$ 上的最小值的最小值，在用一个 `id` 数组维护每个数出现的位置即可。

时间复杂度：$O(q \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
void close(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
}
const int N = 5e5 + 10;
const int M = 2e7 + 10;
const int inf = 1e9;
const int mod = 998244353;

int T;
int n,q,tot;
int a[N],id[N];
int mi[N << 2];

void pushup (int o){
	mi[o] = min(mi[o << 1],mi[o << 1 | 1]);
}
void build (int o,int l,int r){
	if (l == r){
		mi[o] = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(o << 1,l,mid);
	build(o << 1 | 1,mid + 1,r);
	pushup(o);                  
}
void update (int o,int l,int r,int x,int y){
	if (l == r){
		mi[o] = y;
		return;
	}
	int mid = (l + r) >> 1;
	if (x <= mid) update(o << 1,l,mid,x,y);
	else update(o << 1 | 1,mid + 1,r,x,y);
	pushup(o);
}
int query (int o,int l,int r,int ql,int qr){
	if (ql <= l && r <= qr)
		return mi[o];
	int ret = inf;
	int mid = (l + r) >> 1;
	if (ql <= mid) ret = min(ret,query(o << 1,l,mid,ql,qr));
	if (qr > mid) ret = min(ret,query(o << 1 | 1,mid + 1,r,ql,qr));
	return ret;
}
void solve(){
	cin >> n;
	for (int i = 1 ; i <= n ; i++) cin >> a[i];
	for (int i = 1 ; i <= n ; i++) id[a[i]] = i;
	build(1,1,n);
	cin >> q;
	while (q--){
		int l,r;
		cin >> l >> r;
		if (l == 1 && r == n){
			cout << "peace\n";
			continue;
		}
		int x = inf;
		if (l != 1) x = min(x,query(1,1,n,1,l - 1));
		if (r != n) x = min(x,query(1,1,n,r + 1,n));
		if (x == n){
			cout << "peace\n";
			continue;
		}
		cout << x << endl;
		update(1,1,n,id[x],x + 1);
		update(1,1,n,id[x + 1],x);
		swap(id[x],id[x + 1]);
	}
}
signed main(){
	close();
	T = 1; 
    //cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 作者：Misserina (赞：2)

和一些同学交流了一下，大多是线段树做的。我的思路比较新颖，没有使用线段树，而是使用二分法。

首先，预处理排列中包含 $1 \sim x$（$x \in [1,n]$）的全部数字的最小连续区间 $[L_x,R_x]$（例如排列 `2 6 3 1 4 5` 中包含 $1 \sim 4$ 的最小连续区间 $[L_4,R_4] = [1,5]$），每次询问通过二分查找找出最小的不满足 $[l,r] \subseteq [L_x,R_x]$ 的 $x$，此即为 $[l,r]$ 中最小未出现的正整数。

对 $x$ 分类讨论：

- 如果 $x \ge n$，输出 $\tt{peace}$，对排列不做处理。

- 如果 $x < n$，输出 $x$，并交换排列中的 $x$ 与 $x+1$。

因为排列中只有 $x$ 与 $x+1$ 两个数的位置有变化，因此重新维护数组 $L,R$ 时，只需要更新 $L_x,R_x,L_{x+1},R_{x+1}$ 的位置。

代码如下，时间复杂度 $O(k \log n)$，常数较小，可轻松通过全部测试点，最大测试点时长约为 $80ms$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a,k,l,r,lt[500005],rt[500005],pt[500005];
int Find(int l,int r) { //二分查找最小的未出现的正整数
	int L=1,R=n;
	while (L<=R) {
		int mid=(L+R)>>1;
		if (lt[mid]>=l && rt[mid]<=r) L=mid+1;
		else R=mid-1;
	}
	return L;
}
void deal(int x) { //交换数字
	swap(pt[x],pt[x+1]);
	for (int i=x;i<=min(x+2,n);i++) {
		lt[i]=min(lt[i-1],pt[i]);
		rt[i]=max(rt[i-1],pt[i]);
	}
}
int main() {
	lt[0]=10002184; //x=1 时 deal 函数会取到这个位置，因此初始化 inf
	rt[0]=-1;
	scanf("%d",&n);
	for (int i=1;i<=n;i++) {
		scanf("%d",&a);
		pt[a]=i;
	}
	lt[1]=pt[1];
	rt[1]=pt[1];
	for (int i=2;i<=n;i++) {
		lt[i]=min(lt[i-1],pt[i]);
		rt[i]=max(rt[i-1],pt[i]);
		//printf("%d %d %d\n",i,lt[i],rt[i]);
	}
	scanf("%d",&k);
	for (int i=1;i<=k;i++) {
		scanf("%d%d",&l,&r);
		int res=Find(l,r);
		if (res>=n) printf("peace\n");
		else {
			printf("%d\n",res);
			deal(res);
		}
	}
}
```

---

## 作者：complexly (赞：2)

###  根号连接大脑，分块代替思考。

~~这道题可以直接用分块创过去。~~

-----------

首先你注意到 $k \le 10^5$ 。

好的，我们可以开始根号了。

我们直接考虑下面这个更强的问题（保证是一个排列）：

1. 区间 $\operatorname{mex}$。
2. 交换俩个数（单点修改）。

这有一个很简单的分块做法。

序列分块，值域分块。

维护：

$block\_col_{i,j}$  表示第序列 $1 \sim i$ 块内在第 $j$ 个值域块内的数的数量。

$col_{i,j}$ 表示第序列 $1 \sim i$ 块内在数值为 $j$ 的数的数量。

查询：

先跳值域整块，再跳值域散块。

序列散块暴力，就不多说了。

修改：

由于你维护的是块的前缀和，无论是 $block\_col_{i,j}$ 还是 $col_{i,j}$ 都只有 $\sqrt n$ 个要修改的地方，暴力修改即可。

但是，$n = 5\times 10^5$ ， $col_{i,j}$ 的空间是 $n \sqrt n$ 的，初始化也是 $n\sqrt n$ 的，过不去（其实可以用 bitset）

所以你考虑跳值域散块的时候不用 $col_{i,j}$ 了，你发现只要 $l \le pos_x \le r$，$x$ 就在 $[l , r]$ 中（ $pos_i$ 表示 $i$ 这个值的出现位置）。

所以你维护一下 $pos_i$ 就行了。

所以根本用不到交换的俩个值的性质，就做完了。

总复杂度 $O(n + k\sqrt n)$ 最慢点 313 ms ，没卡常。

```cpp
#include<bits/stdc++.h>
#define f(i , l , r) for(int i = (l);i <= (r);++ i)
#define d(i , l , r) for(int i = (r);i >= (l);-- i)
#define pii pair<int,int>
#define pb push_back
#define fi first
#define sc second
#define lowbit(x) ((x)&-(x))
#define fre(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)
using namespace std;
const int N = 5e5 + 10 , B = 1024;//1024位运算，方便卡常
int n , k , a[N] , col[N/B+10][N/B+10] , bl[N] , L[N] , R[N] , pos[N] , t[N];
void change(int u,int v){
    f(i , bl[u] , bl[n])col[i][bl[a[u]]] -- , col[i][bl[a[v]]] ++;
    f(i , bl[v] , bl[n])col[i][bl[a[v]]] -- , col[i][bl[a[u]]] ++;
    swap(a[u] , a[v]) , swap(pos[a[v]] , pos[a[u]]);
}
signed main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0) , cout.tie(0);
    cin >> n;
    f(i , 1 , n)cin >> a[i] , pos[a[i]] = i;
    f(i , 1 , n)bl[i] = (i - 1) / B + 1 , R[bl[i]] = i , L[bl[i]] = R[bl[i]-1] + 1;
    f(i , 1 , bl[n]){
        f(j , 1 , bl[n])col[i][j] = col[i-1][j];
        f(j , L[i] , R[i])col[i][bl[a[j]]] ++;
    }
    cin >> k;
    // cerr << "ok\n";
    f(i , 1 , k){
        int l , r , p = 1;
        cin >> l >> r;
        if(bl[l] == bl[r]){
            f(j , 1 , bl[n])t[j] = 0;
            f(j , l , r)t[bl[a[j]]] ++;
            // int p = 1;
            while(p < bl[n] && t[p] == R[p] - L[p] + 1)p ++;
            p = L[p];
            while(l <= pos[p] && pos[p] <= r)p ++;
        }
        else {
            int rb = bl[r] , lb = bl[l];
            f(j , 1 , bl[n])t[j] = col[rb-1][j] - col[lb][j];
            f(j , l , R[lb])t[bl[a[j]]] ++;
            f(j , L[rb] , r)t[bl[a[j]]] ++;
            // int p = 1;
            while(p < bl[n] && t[p] == R[p] - L[p] + 1)p ++;
            // cerr << p << "\n";
            p = L[p];
            while(l <= pos[p] && pos[p] <= r)p ++;
        }
        if(p >= n)cout << "peace\n";
        else cout << p << "\n" , change(pos[p] , pos[p + 1]);
        // f(j , 1 , n)cout << a[j] << " ";cout << "\n";
    }
}
```

---

## 作者：yedalong (赞：1)

我对这道题的评价：线段树模板题。

## Solution

由于要求区间外的最小正整数，考虑将 $[l,r]$ 这个区间拆成这两个区间：$[1,l)$ 和 $(r,n]$，在这两个区间取最小值就可以了，因而考虑维护区间最小值，使用线段树。

由于要交换位置，因此可以记录下来每一个数字的位置，在交换时跟着交换就可以了。

时间复杂度 $O(n\log n)$，可以通过此题。

注意判断 $[1,l)$ 和 $(r,n]$ 这两个区间是否合法。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,q,a[500005],minn[2000005],l,r,wz[500005];
inline int lc(int x){return x<<1;}
inline int rc(int x){return x<<1|1;}
inline void push_up(int now){minn[now]=min(minn[lc(now)],minn[rc(now)]);}
inline void build(int l,int r,int now){
	if(l==r){
		minn[now]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(l,mid,lc(now));
	build(mid+1,r,rc(now));
	push_up(now);
}
inline void update(int l,int r,int now,int x,int y){
	if(r<x||l>x) return;
	if(l==r){
		minn[now]=y;
		return;
	}
	int mid=l+r>>1;
	update(l,mid,lc(now),x,y);
	update(mid+1,r,rc(now),x,y);
	push_up(now);
}
inline int query(int l,int r,int now,int ql,int qr){
	if(l>qr||r<ql) return 1e9;
	if(l>=ql&&r<=qr) return minn[now];
	int res=1e9,mid=l+r>>1;
	res=min(res,query(l,mid,lc(now),ql,qr));
	res=min(res,query(mid+1,r,rc(now),ql,qr));
	return res;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i = 1;i<=n;i++) cin>>a[i],wz[a[i]]=i;
	build(1,n,1);
	cin>>q;
	while(q--){
		cin>>l>>r;
		int tmp=1e9;
		if(l>1) tmp=query(1,n,1,1,l-1);
		if(r<n) tmp=min(tmp,query(1,n,1,r+1,n));
		if(tmp>=n){
			cout<<"peace\n";
			continue;
		}
		cout<<tmp<<'\n';
		update(1,n,1,wz[tmp],tmp+1);
		update(1,n,1,wz[tmp+1],tmp);
		swap(wz[tmp],wz[tmp+1]);
	}
	return 0;
}
```

---

## 作者：Chen_Borui (赞：1)

# 思路
首先看题目，有区间操作，可以马上联想到 st 表或者线段树，再一看是动态的，马上想到线段树。

题目中有区间修改和区间查询，很像板子题，只是在查询时注意一下，查询的是 $x \notin [l,r]$ 的最小值，那也就是说查询我们可以分两次，一次为 $[1,l-1]$ 另一次为 $[r+1,n]$ 上的最小值。

那么话不多说，直接上代码（~~应该没有人直接复制的线段树板子题吧，应该都是纯手打的吧~~）。

# 代码

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
#define int long long//这玩意老好用了
inline void read(int& a){
    int s=0, w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if (ch=='-')
            w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
    s=s*10+ch-'0';
        ch=getchar();
    }
    a=s*w;
}//快读
void write(int x){
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}//快写
const int MAXN=500005;
int n,k;//n 和 k 均为题目意思
struct node{
    int l,r;//l r分别为左右端点
    int minn;//储存最小值
}t[MAXN<<2];
int a[MAXN],f[MAXN];//为了两点交换，f数组来存数的下标
void build(int l,int r,int p){
    t[p].l=l,t[p].r=r;
    if(l==r){
        t[p].minn=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,p<<1);
    build(mid+1,r,p<<1|1);
    t[p].minn=min(t[p<<1].minn,t[p<<1|1].minn);
}//建树，不过多赘述
int ans(int l,int r,int p){
    if(l<=t[p].l && t[p].r<=r)
        return t[p].minn;
    int cnt=1e9;
    int mid=(t[p].l+t[p].r)>>1;
    if(l<=mid) cnt=min(cnt,ans(l,r,p<<1));
    if(r>mid) cnt=min(cnt,ans(l,r,p<<1|1));
    return cnt;
}//查询，和线段树板子一样
void change(int x,int y,int p){
    if(t[p].l==x && t[p].r==x){
        t[p].minn=y;
        return;
    }
    int mid=(t[p].l+t[p].r)>>1;
    if(x<=mid) change(x,y,p<<1);
    if(x>mid) change(x,y,p<<1|1);
    t[p].minn=min(t[p<<1].minn,t[p<<1|1].minn);
}//建议不熟悉线段树的好好看看这一块
signed main(){
    read(n);
    for(int i=1;i<=n;i++)
        read(a[i]),f[a[i]]=i;
    build(1,n,1);
    read(k);
    for(int i=1;i<=k;i++){
        int x,y;
        read(x),read(y);
        int ans1=ans(1,x-1,1);//左半边最小值
        int ans2=ans(y+1,n,1);//右半边最小值
        int res=min(ans1,ans2);//总的最小值
        if(res>=n)
            printf("peace\n");
        else{
            write(res);
            printf("\n");
            change(f[res],res+1,1);
            change(f[res+1],res,1);
            swap(f[res],f[res+1]);//交换
        }
    }
    return 0;//完美结束
}
```
# 后记

不要看这题是个蓝题或者题目长就觉得很难，细细读完题目发现真的不难。

线段树的时间复杂度为 $O(klogn)$ 不大，可以轻松过此题。

---

## 作者：iChen (赞：0)

形式化的题意题面中已经给出了，可以很容易发现这是一个求区间 $\mathrm{mex}$ 的问题，于是便自然地想到使用线段树来维护序列信息。

但是序列中的每个元素的大小，也就是每个成员的排名，这个数一定是在 $1$ 到 $n$ 中的，并且每个数只会在序列中出现一次。

根据这个性质，要求区间 $l$ 到 $r$ 的 $\mathrm{mex}$，只需要在区间 $1$ 到 $l-1$ 和 $r+1$ 到 $n$ 中都取最小值，在比较出更小的一个值就行了。

再定义一个 $mp$ 数组维护每个值在区间的位置，建立一颗线段树维护区间信息和区间最小值，每次寻找到区间 $\mathrm{mex}$，将它判断输出，再维护更新 $mp$ 和线段树就可以了。

详细的注释见代码。

```cpp
#include <iostream>

using namespace std;

const int N = 5e5 + 5;
int n, k, a[N];
// n，k见题意，a 为序列 
int mnn[N << 2];
// 维护线段树的区间最小值 
int mp[N];
// 维护每个数值在区间中的位置 

inline void pushup (int p) { // 更新区间最小值 
	mnn[p] = min(mnn[p << 1], mnn[p << 1 | 1]);
}
void build (int p, int l, int r) {
	if (l == r) // 叶子节点，出口 
		return mnn[p] = a[l], void();
	int mid = l + r >> 1;
	build(p << 1, l, mid); // 左区间建树 
	build(p << 1 | 1, mid + 1, r); // 右区间建树 
	pushup(p); // 更新当前区间信息 
}
void update (int p, int l, int r, int pla, int dt) { // 单点更新 
	if (l == r) // 叶子节点，出口，更新节点信息后退出 
		return mnn[p] = dt, void();
	int mid = l + r >> 1;
	if (pla <= mid) // 更新位置在左区间 
		update(p << 1, l, mid, pla, dt);
	else // 否则在右区间 
		update(p << 1 | 1, mid + 1, r, pla, dt);
	pushup(p); // 更新当前区间信息 
}
int query_min (int p, int l, int r, int x, int y) { // 查询区间最小值 
	if (l >= x and r <= y) return mnn[p]; // 全覆盖，返回当前区间最小值 
	int mid = l + r >> 1, val = 1 << 30;
	if (x <= mid) // 尝试往左区间寻找答案 
		val = min(val, query_min(p << 1, l, mid, x, y));
	if (y > mid) // 尝试往右区间寻找答案 
		val = min(val, query_min(p << 1 | 1, mid + 1, r, x, y));
	return val; // 返回 
}

int main () {
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i]; // 输入序列 
		mp[a[i]] = i; // 保存此元素位置 
	}
	build(1, 1, n); // 建树 
	cin >> k;
	int l, r, ans;
	while (k --) {
		cin >> l >> r; // 输入处理区间 
		ans = 1 << 30; // ans 定义为无限 
		if (l > 1) // 保护措施，左边有区间才去寻找 
			ans = min(ans, query_min(1, 1, n, 1, l - 1));
		if (r < n) // 同上 
			ans = min(ans, query_min(1, 1, n, r + 1, n));
		if (ans >= n) { // 特判 
			cout << "peace\n";
		} else {
			cout << ans << '\n'; // 输出答案 
			int pa = mp[ans], pb = mp[ans + 1]; // 记录两个元素位置 
			update(1, 1, n, pa, ans + 1); // 更新线段树 
			update(1, 1, n, pb, ans);
			mp[ans] = pb, mp[ans + 1] = pa; // 更新 mp 
		}
	}
	return 0;
}
```

---

## 作者：copper_ingot (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12539)

可以用线段树做。题目即为单点修改和区间查询 $\text{mex}$。

因为 $a$ 是个排列，所以在区间 $[l,r]$ 上求 $\text{mex}$ 可以转为求区间 $[1,l-1]$ 和 $[r+1,n]$ 上的最小值。做两次区间查询 $\text{min}$ 即可。

可以用一个数组 $b$ 记录 $x$ 在 $a$ 中的位置，修改操作后直接交换 $b_x$ 和 $b_{x+1}$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int, int>
pii mkp(int x, int y){pii p; p.first = x, p.second = y; return p;}
int n, a[500001], b[500001], m;
struct node{int l, r, val;}tree[2000001];//线段树的结构体
void build(int u, int l, int r){
	tree[u].l = l, tree[u].r = r;
	if (l == r){tree[u].val = a[l]; return;}
	int mid = (l + r) >> 1;
	build(u << 1, l, mid);
	build((u << 1) | 1, mid + 1, r);
	tree[u].val = min(tree[u << 1].val, tree[(u << 1) | 1].val);
}//建树
void modify(int u, int pos, int v){
	if (tree[u].l == tree[u].r){tree[u].val = v; return;}
	int mid = (tree[u].l + tree[u].r) >> 1;
	if (pos <= mid) modify(u<< 1, pos, v);
	else modify((u << 1) | 1, pos, v);
	tree[u].val = min(tree[u << 1].val, tree[(u << 1) | 1].val);
}//单点修改
int query(int u, int l, int r){
	if (l <= tree[u].l && tree[u].r <= r) return tree[u].val;
	int mid = (tree[u].l + tree[u].r) >> 1, ans = 2147483647;
	if (l <= mid) ans = min(ans, query(u << 1, l, r));
	if (r > mid) ans = min(ans, query((u << 1) | 1, l, r));
	return ans;
}//区间求min
signed main(){
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++){scanf("%lld", &a[i]); b[a[i]] = i;}
	scanf("%lld", &m);
	build(1, 1, n);
	for (int i = 1; i <= m; i++){
		int l, r; scanf("%lld%lld", &l, &r);
		int ans = 2147483647;
		if (l > 1) ans = min(ans, query(1, 1, l - 1));
		if (r < n) ans = min(ans, query(1, r + 1, n));//此处ans即为mex
		if (ans >= n){puts("peace"); continue;}
		printf("%lld\n", ans);
		modify(1, b[ans], ans + 1);
		modify(1, b[ans + 1], ans);
		swap(b[ans], b[ans + 1]);//修改
	}
    return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

虽然没时间打但是还是简单看了一下。

题目非常简单，就是求区间 $mex$。考虑特殊性质排列，即每个数**出现刚好一次**，这启示我们可以用值域线段树来求区间内的答案。

具体而言，我们记录 $pos_i$ 表示数 $i$ 的出现位置，线段树维护其最小 / 最大值，然后外层二分第一个位置使其不合法，查询对应结果，再做对应修改交换，时间复杂度 $O(n \log n)$。

然而，由于求的实际上是一个前缀，我们可以用线段树二分的方法省去外层二分，做到 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5;
struct Point{
	int maxn,minn;
	Point operator+(const Point &x)const{
		return (Point){max(maxn,x.maxn),min(minn,x.minn)};
	}
}c[N<<2];
int n,m,a[N],pos[N];
void updata(int x){
	c[x]=c[x<<1]+c[x<<1|1];
}
void build(int x,int l,int r){
	if(l==r){
		c[x]=(Point){pos[l],pos[l]};
		return;
	}int mid=(l+r)>>1;
	build(x<<1,l,mid),build(x<<1|1,mid+1,r),updata(x);
}
void change(int x,int l,int r,int s,int k){
	if(l==r){
		c[x]=(Point){k,k};
		return;
	}int mid=(l+r)>>1;
	if(s<=mid)change(x<<1,l,mid,s,k);
	else change(x<<1|1,mid+1,r,s,k);updata(x);
}int tim;
int query(int x,int l,int r,int s,int t){
	if(l==r)return l;int mid=(l+r)>>1,maxn=c[x<<1].maxn,minn=c[x<<1].minn;
	if(minn>=s&&maxn<=t)return query(x<<1|1,mid+1,r,s,t);
	return query(x<<1,l,mid,s,t);
}int l,r;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++)cin >> a[i],pos[a[i]]=i;
	cin >> m;build(1,1,n);
	for(int i = 1;i <= m;i++){if(i==3)tim=1;
		if(i!=3)tim=0;
		cin >> l >> r;
		int val=query(1,1,n,l,r);
		if(val>=n)cout << "peace\n";
		else{
			swap(pos[val],pos[val+1]);
			change(1,1,n,val,pos[val]);
			change(1,1,n,val+1,pos[val+1]);
			cout << val << "\n";
		}
	}
	return 0;
}
```

---

## 作者：jdfz2251533 (赞：0)

## 题解：P12539 [XJTUPC 2025] 结束乐队
## 思路
形式化题意可以转化一下：由于 $a$ 是一个 $1$ 到 $n$ 的排列，那么 $[l,r]$ 上未出现的最小正整数就是 $[1,l-1]$ 和 $[r + 1, n]$ 上的最小值，也就是两个区间求最小值，线段树可以做。细节上注意区间不能超过 $1$ 到 $n$ 的范围。

我们再考虑交换怎么做，其实是两个单点修改，开个数组记录一下对应值的下标，用线段树可以做，记得两个点修改完互换一下下标。

那么做法就是实现一个区间最小值和单点改的线段树，求出 $x$ 后按要求判断一下 $x$ 的范围进行对应操作，这题就结束了。

## code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;

int n, k, a[N], vis[N];
struct node {
	int l, r, mi;
} t[N << 2];

int ls(int p) {
	return p << 1;
}

int rs(int p) {
	return p << 1 | 1;
}

void pushup(int p) {
	t[p].mi = min(t[ls(p)].mi, t[rs(p)].mi);
}

void build(int p, int l, int r) {
	t[p].l = l;
	t[p].r = r;
	if (l == r) {
		t[p].mi = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(ls(p), l, mid);
	build(rs(p), mid + 1, r);
	pushup(p);
}

void update(int p, int x, int val) {
	if (t[p].l == x && t[p].r == x) {
		t[p].mi = val;
		return;
	}
	int mid = (t[p].l + t[p].r) >> 1;
	if (mid >= x) {
		update(ls(p), x, val);
	} else {
		update(rs(p), x, val);
	}
	pushup(p);
}

int query(int p, int l, int r) {
	if (l <= t[p].l && r >= t[p].r) {
		return t[p].mi;
	}
	int ans = 1e9;
	int mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid) {
		ans = min(ans, query(ls(p), l, r));
	}
	if (r > mid) {
		ans = min(ans, query(rs(p), l, r));
	}
	return ans;
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		vis[a[i]] = i;
	}
	cin >> k;
	build(1, 1, n);
	while (k--) {
		int l, r, x = 1e9, y = 1e9;
		cin >> l >> r;
		if (l > 1) {
			x = query(1, 1, l - 1);
		}
		if (r < n) {
			y = query(1, r + 1, n);
		}
		int ans = min(x, y);
		if (ans >= n) {
			cout << "peace\n";
		} else {
			cout << ans << '\n';
			update(1, vis[ans], ans + 1);
			update(1, vis[ans + 1], ans);
			swap(vis[ans], vis[ans + 1]);
		}
	}
	return 0;
}
```

---

## 作者：modfish_ (赞：0)

## 思路
题意是求一个排列的区间 $\text{mex}$，有单点修改。

可以记录每个值 $i$ 的出现位置 $b_i$，每次相当于查询 $\displaystyle\min_{b_i<l\lor b_i>r} i=\min(\min_{b_i<l}i,\min_{b_i>r}i)$，对 $b$ 建线段树然后二分即可。

时间复杂度 $O(k\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 5e5 + 5;

int a[maxn], loc[maxn];

namespace seg{
#define l(x) (x << 1)
#define r(x) (x << 1 | 1)
int mn[maxn << 2], mx[maxn << 2];
void up(int x){
    mn[x] = min(mn[l(x)], mn[r(x)]);
    mx[x] = max(mx[l(x)], mx[r(x)]);
}
void build(int x, int l, int r){
    if(l == r){
        mn[x] = mx[x] = loc[l];
        return;
    }
    int mid = l + r >> 1;
    build(l(x), l, mid), build(r(x), mid + 1, r);
    up(x);
}
void update(int x, int l, int r, int id, int k){
    if(l == r){
        mn[x] = mx[x] = k;
        return;
    }
    int mid = l + r >> 1;
    if(id <= mid) update(l(x), l, mid, id, k);
    else update(r(x), mid + 1, r, id, k);
    up(x);
}
int query1(int x, int l, int r, int k){
    if(l == r) return l;
    int mid = l + r >> 1;
    if(mn[l(x)] < k) return query1(l(x), l, mid, k);
    else return query1(r(x), mid + 1, r, k);
}
int query2(int x, int l, int r, int k){
    if(l == r) return l;
    int mid = l + r >> 1;
    if(mx[l(x)] > k) return query2(l(x), l, mid, k);
    else return query2(r(x), mid + 1, r, k);
}}

int main(){
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) scanf("%d", &a[i]), loc[a[i]] = i;
    int q;
    scanf("%d", &q);
    seg::build(1, 1, n);
    while(q --){
        int l, r;
        scanf("%d %d", &l, &r);
        int x = min(seg::query1(1, 1, n, l), seg::query2(1, 1, n, r));
        if(x >= n){
            printf("peace\n");
            continue;
        }
        printf("%d\n", x);
        int z1 = loc[x], z2 = loc[x + 1];
        seg::update(1, 1, n, x, z2), seg::update(1, 1, n, x + 1, z1);
        loc[x + 1] = z1, loc[x] = z2;
    }
    return 0;
}
```


---

哇，还有结束乐队

---

## 作者：Scean_Tong (赞：0)

## P12539 [XJTUPC 2025] 结束乐队

### Problem

给定一个从 $1$ 到 $n$ 的排列 $a_1, a_2, \dots, a_n$，进行 $k$ 次操作，每次操作：

- 给定一个区间 $[l,r]$，求 **当前排列中区间 $[l,r]$ 上未出现的最小正整数** 是多少，并设此数为 $x$（即 $x=\min\{p\mid \forall i \in [l,r],p\neq a_i,p\geq 1\}$）；
  - 若 $x<n$，则输出 $x$，并交换当前排列 $a_1, a_2, \dots, a_n$ 中数字 $x$ 与 $x+1$ 的位置；
  - 若 $x\ge n$，则输出字符串 $\tt{peace}$。

### Solution

考虑怎么找到 $[l,r]$ 中未出现过的最小的正整数，因为 $a_n$ 是一个排列，所以区间中没出现过的数就是区间外的数，$[l,r]$ 中未出现过的最小的正整数即为 $[1,l-1]$ 和 $[r+1,n]$ 这两个区间的最小值的较小值。

然后考虑之后的操作，如果 $n \leq x$ 是容易的因为后面不用管。否则交换数字 $x$ 和 $x+1$ 的位置。这个典中典了吧属于是，直接开一个 $pos_i$ 表示 $i$ 的位置，初始时 $pos_{a_i}=i$，每次操作就只需要在线段树上将 $pos_x$ 的位置改为当前线段树上 $x+1$ 的值，反之亦然，做完了。

因为笔者只会贺板子，所以采用的是两个位置分别做单点覆盖，可能存在更好的写法。

### Code


```cpp
#include <bits/stdc++.h>
#define int long long
#define file(x) {freopen(x".in", "r", stdin); freopen(x".out", "w", stdout);}
namespace Fastio{struct Reader{template<typename T>Reader&operator>>(T&x){x=0;short f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();x*=f;return*this;}Reader&operator>>(double&x){x=0;double t=0;short f=1,s=0;char c=getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(long double&x){x=0;long double t=0;short f=1,s=0;char c=getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(__float128&x){x=0;__float128 t=0;short f=1,s=0;char c=getchar();while((c<'0'||c>'9')&&c!='.'){if(c=='-')f*=-1;c=getchar();}while(c>='0'&&c<='9'&&c!='.')x=x*10+(c^48),c=getchar();if(c=='.')c=getchar();else{x*=f;return*this;}while(c>='0'&&c<='9')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}Reader&operator>>(char&c){c=getchar();while(c==' '||c=='\n'||c=='\r')c=getchar();return*this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==' '||c=='\n'||c=='\r')c=getchar();while(c!=' '&&c!='\n'&&c!='\r')str[len++]=c,c=getchar();str[len]='\0';return*this;}Reader&operator>>(std::string&str){str.clear();char c=getchar();while(c==' '||c=='\n'||c=='\r')c=getchar();while(c!=' '&&c!='\n'&&c!='\r')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl='\n';struct Writer{const int Setprecision=6;typedef int mxdouble;template<typename T>Writer&operator<<(T x){if(x==0){putchar('0');return*this;}if(x<0)putchar('-'),x=-x;static short sta[40];short top=0;while(x>0)sta[++top]=x%10,x/=10;while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(double x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(double)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(long double x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(long double)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(__float128 x){if(x<0)putchar('-'),x=-x;mxdouble _=x;x-=(__float128)_;static short sta[40];short top=0;while(_>0)sta[++top]=_%10,_/=10;if(top==0)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;putchar('.');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_>0)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar('0');while(top>0)putchar(sta[top]+'0'),top--;return*this;}Writer&operator<<(char c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}using namespace Fastio;
int T = 1;
constexpr int maxn = 1e6 + 7;
int v[maxn], n, m;
namespace covaddSGT{
	const int L = 0, R = 1;
	struct node{
		int maxx, minn;
		int covtag = 1e18;
		int son[2];
	}SGT[maxn << 2];
	inline void pushup(int k){
		SGT[k].minn = std::min(SGT[SGT[k].son[L]].minn, SGT[SGT[k].son[R]].minn);
	}
	int k, cnt;
	inline void build(int &k, int l, int r){
		k = ++cnt;
		if(l == r){
			SGT[k].maxx = v[l];
			SGT[k].minn = v[l];
			SGT[k].covtag = 1e18;
			return ;
		}
		int mid = (l + r) >> 1;
		build(SGT[k].son[L], l, mid);
		build(SGT[k].son[R], mid + 1, r);
		pushup(k);
	}
	inline void covtag(int k, int l, int r, int val){
		SGT[k].maxx = val;
		SGT[k].minn = val;
		SGT[k].covtag = val;
	}
	inline void pushdown(int k, int l, int r){
		int mid = (l + r) >> 1;
		if(SGT[k].covtag != 1e18){
			covtag(SGT[k].son[L], l, mid, SGT[k].covtag);
			covtag(SGT[k].son[R], mid + 1, r, SGT[k].covtag);
			SGT[k].covtag = 1e18;
		}
	}
	inline void covmodify(int k, int l, int r, int ql, int qr, int val){
		if(ql == l&&qr == r){
			covtag(k, l, r, val);
			return ;
		}
		pushdown(k, l, r);
		int mid = (l + r) >> 1;
		if(qr <= mid){
			covmodify(SGT[k].son[L], l, mid, ql, qr, val);
		}
		else if(ql > mid){
			covmodify(SGT[k].son[R], mid + 1, r, ql, qr, val);
		}
		else{
			covmodify(SGT[k].son[L], l, mid, ql, mid, val);
			covmodify(SGT[k].son[R], mid + 1, r, mid + 1, qr, val);
		}
		pushup(k);
	}
	int querymin(int k, int l, int r, int ql, int qr){
		if(ql == l&&qr == r){
			return SGT[k].minn;
		}
		int mid = (l + r) >> 1;
		pushdown(k, l, r);
		int ret =  1e18;
		if(qr <= mid){
			ret = std::min(ret, querymin(SGT[k].son[L], l, mid, ql, qr));
		}
		else if(ql > mid){
			ret = std::min(ret, querymin(SGT[k].son[R], mid + 1, r, ql, qr));
		}
		else{
			ret = std::min(ret, querymin(SGT[k].son[L], l, mid, ql, mid));
			ret = std::min(ret, querymin(SGT[k].son[R], mid + 1, r, mid + 1, qr));
		}
		return ret;
	}

}
int root, k, a[maxn], p[maxn];

inline void solve() {
	Fastio::cin >> n;
	for(int i = 1; i <= n; i++){
		Fastio::cin >> v[i];
		p[v[i]] = i; 
	}
	covaddSGT::build(root, 1, n);
	Fastio::cin >> k;
	for(int ca = 1, l, r; ca <= k; ca++){
		Fastio::cin >> l >> r;
		int x;
		if(l == 1 && r == n){
			puts("peace");
			continue;
		}
		if(l - 1 == 0) x = covaddSGT::querymin(root, 1, n, r + 1, n);
		else if(r + 1 == n + 1) x = covaddSGT::querymin(root, 1, n, 1, l - 1);
		else x = std::min(covaddSGT::querymin(root, 1, n, 1, l - 1), covaddSGT::querymin(root, 1, n, r + 1, n));
		if(x >= n){
			puts("peace");
			continue;
		}
		Fastio::cout << x << '\n';
		int y = x + 1;
		x = p[x]; 
		y = p[y];
		int ax = covaddSGT::querymin(root, 1, n, x, x);
		int ay = covaddSGT::querymin(root, 1, n, y, y);
		covaddSGT::covmodify(root, 1, n, x, x, ay);
		covaddSGT::covmodify(root, 1, n, y, y, ax);
		std::swap(p[ax], p[ay]);
	}
}
int32_t main() {
//	file("A");
//	Fastio::cin  >>  T;
	while(T--) {
		solve();
	}
	return 0;
}




```

---


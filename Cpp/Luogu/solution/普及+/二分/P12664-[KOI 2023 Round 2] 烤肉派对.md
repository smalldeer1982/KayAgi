# [KOI 2023 Round 2] 烤肉派对

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

今天是烤肉派对的日子。为了配合派对的氛围，在一条很长的烤架上总共放了 $N$ 块烤得很香的肉。

将这条烤架视为一条长度为 $10^9$ 的线段，左端为坐标 $0$，右端为坐标 $10^9$。每块肉都占据烤架上的某个区间，并且拥有一个用正整数表示的“美味值”。第 $i$ 块肉（$1 \leq i \leq N$）占据区间 $[s_i, e_i]$，其美味值为 $t_i$。多块肉可能重叠放置。

派对共有 $M$ 个人参加。每个人按照编号从 $1$ 到 $M$ 依次站到烤架前，各自领取要吃的烤肉。领取方法如下：

- 第 $j$ 个人（$1 \leq j \leq M$）带来了两根长签子，并分别插入坐标 $a_j + 0.1$ 和 $b_j + 0.9$ 的位置（其中 $a_j \leq b_j$）。插入坐标 $x$ 的签子会贯穿所有满足 $s_i \leq x \leq e_i$ 的第 $i$ 块肉。
- 然后，他会整根地拔起签子带回座位。此时，只要有一块肉被两根签子都贯穿，就可以被带走并从烤架上移除。
- 如果只有一根签子贯穿了一块肉，那么这块肉在途中会掉到地上，无法带回座位吃。
- 也就是说，只有同时被两根签子贯穿的肉才能顺利被带走并吃掉。

你是这场派对的主办者，对每个人究竟带走了哪些肉感到好奇。请计算出每个人最终能够吃掉的肉的美味值总和（注意不包括在途中掉落的肉）。

## 说明/提示

**限制条件**

- 所有给定数值均为整数。
- $1 \leq N, M \leq 250\,000$
- $0 \leq s_i < e_i \leq 10^9 \quad (1 \leq i \leq N)$
- $1 \leq t_i \leq 10^9 \quad (1 \leq i \leq N)$
- $0 \leq a_j \leq b_j \leq 10^9 - 1 \quad (1 \leq j \leq M)$

**子任务**

1. （5 分）$N, M \leq 1\,000$  
2. （9 分）$e_i - s_i \leq 5 \quad (1 \leq i \leq N)$  
3. （11 分）$s_i < s_{i+1},\ e_i > e_{i+1} \quad (1 \leq i \leq N - 1)$  
4. （23 分）$e_i - s_i = e_1 - s_1 \quad (2 \leq i \leq N)$  
5. （52 分）无额外限制

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
5 3
2 7 3
5 6 9
3 5 2
1 3 6
4 8 7
3 6
2 4
5 5```

### 输出

```
3
0
9```

## 样例 #2

### 输入

```
6 3
1 12 1
2 11 10
3 10 100
4 9 1000
5 8 10000
6 7 100000
1 11
5 9
6 8```

### 输出

```
1
110
0```

## 样例 #3

### 输入

```
5 2
1 5 5
2 6 2
4 8 3
5 9 4
7 11 6
4 5
8 10```

### 输出

```
5
6```

# 题解

## 作者：jinminghao (赞：1)

首先，我们发现在线去找每个人能够拿到和掉在地上的烤肉比较难实现，所以我们可以把每个询问离线下来，然后枚举所有的烤肉，把每一块烤肉分给某个人。

对于第 $i$ 块烤肉，我们需要找出一个人，使这个人的任意一个签子与这块肉产生交集，且这个人在所有签子与这块肉产生交集的人中访问时间最早。

我们先把 $a$ 数组与 $b$ 数组分别从小到大排序，当我们枚举到第 $i$ 块烤肉时，我们分别二分出 $a$ 数组和 $b$ 数组第一个大于等于 $s_i$ 且 小于 $e_i$ 的位置，这样我们对于 $a$ 数组和 $b$ 数组分别得到两个区间，紧接着我们求出这两个区间中编号（指排队领肉的顺序）最小的数的编号就是这块肉被谁叉走的，最后我们再判断一下这个人能不能叉走这块肉就行。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define min(a,b) (a<b?a:b)
#define int long long
using namespace std;
const int N=3e5+10;
struct Node{
	int val,id;
	bool operator<(const Node &x)const{
		return val<x.val;
	}
}a[N],b[N];
int s[N],e[N],w[N],ans[N],sl1[N],sl2[N],st1[N][20],st2[N][20],n,m;
void init(int (&st)[N][20]){
	for(int j=1;(1<<j)<=m;j++){
		for(int i=1;i<=m-(1<<j)+1;i++){
			st[i][j]=min(st[i][j-1],st[i+(1<<j-1)][j-1]);
		}
	}
}
int query(int l,int r,int (&st)[N][20]){
	if(l>r) swap(l,r);
	int k=log2(r-l+1);
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld",&s[i],&e[i],&w[i]);
	}
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&a[i].val,&b[i].val);
		a[i].id=b[i].id=i;
	}
	sort(a+1,a+m+1);
	sort(b+1,b+m+1);
	for(int i=1;i<=m;i++){
		st1[i][0]=a[i].id;
		st2[i][0]=b[i].id;
		sl1[a[i].id]=i;
		sl2[b[i].id]=i;
	}
	init(st1);
	init(st2);
	for(int i=1;i<=n;i++){
		if(s[i]>e[i]) swap(s[i],e[i]);
		int l=1,r=m,res1=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(s[i]<=a[mid].val&&a[mid].val+1<=e[i]){
				res1=mid;
				r=mid-1;
			}else if(a[mid].val<s[i]){
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		l=1,r=m;
		int res2=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(s[i]<=a[mid].val&&a[mid].val+1<=e[i]){
				res2=mid;
				l=mid+1;
			}else if(a[mid].val<s[i]){
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		l=1,r=m;
		int ret1=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(s[i]<=b[mid].val&&b[mid].val+1<=e[i]){
				ret1=mid;
				r=mid-1;
			}else if(b[mid].val<s[i]){
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		l=1,r=m;
		int ret2=-1;
		while(l<=r){
			int mid=l+r>>1;
			if(s[i]<=b[mid].val&&b[mid].val+1<=e[i]){
				ret2=mid;
				l=mid+1;
			}else if(b[mid].val<s[i]){
				l=mid+1;
			}else{
				r=mid-1;
			}
		}
		int t=0x7f7f7f7f;
		int flag=0;
		if(~res1) t=query(res1,res2,st1),flag=1;
		if(~ret1){
			int h=query(ret1,ret2,st2);
			if(h<t){
				t=h;
				flag=2;
			}
		}
		if(t!=0x7f7f7f7f){
			int le=a[sl1[t]].val,ri=b[sl2[t]].val;
			if(le+1>s[i]&&ri+1<=e[i]){
				ans[t]+=w[i];
			}
		}
	}
	for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
	return 0;
}

---

## 作者：tuntunQwQ (赞：1)

一块烤肉要么被不被带走，要么被带走但没有被吃，要么被带走又被吃了。因为只有最后一种情况对答案有影响，所以我们只需要求出每一块烤肉被哪个人吃了再更新他的美味值总和就可以了。

我们先对 $a,b$ 数组排序，二分找到最小的大于等于 $s_i$ 的 $a_{j_1}$ 和最大的小于 $e_i$ 的 $a_{j_2}$，可以发现处于 $[a_{j_1},a_{j_2}]$ 区间内的 $a_j$ 均满足 $s_i≤a_j+0.1≤e_i$，而这其中只有一个人的签子插走了第 $i$ 块肉，即该区间内在原 $a$ 数组中下标最小的一个。用 pair 存储签子的位置和编号，我们要快速求出区间最小值，可以写一个 ST 表。

$b$ 数组也是同样的求法，最后如果第 $i$ 块肉会被同一个人的两个签子插走，我们就要更新答案。代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ft first
#define sd second
using namespace std;
const int N=3e5+10;
int n,m,s[N],e[N],t[N],l,r,ans[N],f[N][25],f1[N][25];bool b[N];
pair<int,int> p1[N],p2[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>s[i]>>e[i]>>t[i];
	for(int i=1;i<=m;i++)cin>>l>>r,p1[i]={l,i},p2[i]={r,i};
	sort(p1+1,p1+m+1);
	sort(p2+1,p2+m+1);
	for(int j=0;(1<<j)<=m;j++){
		for(int i=1;i+(1<<j)-1<=m;i++){
			if(j==0)f[i][j]=p1[i].sd;
			else f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
	for(int j=0;(1<<j)<=m;j++){
		for(int i=1;i+(1<<j)-1<=m;i++){
			if(j==0)f1[i][j]=p2[i].sd;
			else f1[i][j]=min(f1[i][j-1],f1[i+(1<<(j-1))][j-1]);
		}
	}
	for(int i=1;i<=n;i++){
		int l=1,r=m,mid,d1=-1,d2=-1,d3=-1,d4=-1,lent,aout=-1,bout=-1;
		while(l<=r){
			mid=l+r>>1;
			if(p1[mid].ft>=s[i])d1=mid,r=mid-1;
			else l=mid+1;
		}
		l=1,r=m;
		while(l<=r){
			mid=l+r>>1;
			if(p1[mid].ft<e[i])d2=mid,l=mid+1;
			else r=mid-1;
		}
		l=1,r=m;
		while(l<=r){
			mid=l+r>>1;
			if(p2[mid].ft>=s[i])d3=mid,r=mid-1;
			else l=mid+1;
		}
		l=1,r=m;
		while(l<=r){
			mid=l+r>>1;
			if(p2[mid].ft<e[i])d4=mid,l=mid+1;
			else r=mid-1;
		}
		if(d1!=-1&&d2!=-1&&d1<=d2){
			lent=log2(d2-d1+1);
			aout=min(f[d1][lent],f[d2-(1<<lent)+1][lent]);
		}
		if(d3!=-1&&d4!=-1&&d3<=d4){
			lent=log2(d4-d3+1);
			bout=min(f1[d3][lent],f1[d4-(1<<lent)+1][lent]);
		}
		if(aout==bout&&aout!=-1)ans[aout]+=t[i];
	}
	for(int i=1;i<=m;i++)cout<<ans[i]<<'\n';
	return 0;
}
```

---


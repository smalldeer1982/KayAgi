# 书的复制

## 题目背景

大多数人的错误原因：尽可能让前面的人少抄写，如果前几个人可以不写则不写，对应的人输出 `0 0` 。

不过，已经修改数据，保证每个人都有活可干。

## 题目描述

现在要把 $m$ 本有顺序的书分给 $k$ 个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。

现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。

## 说明/提示

$1\le k \le m \le 500$。

## 样例 #1

### 输入

```
9 3
1 2 3 4 5 6 7 8 9
```

### 输出

```
1 5
6 7
8 9
```

# 题解

## 作者：MuelsyseU (赞：169)

## 1. 前言

所以本魔芋最近由于开始学习二分答案，看到自己的思路貌似比较清奇（输出十分奇葩）。

于是立即来这边水一水……

不久前在学习$DP$魔芋卡在线性动规无法理解，所以这里用二分法。用$DP$者疑似不能通过[UVA714](https://www.luogu.com.cn/problem/UVA714)（备用链接[$vjudge$](https://vjudge.net/problem#&title=Copying%20Books)）

> 因为据老师而言二分答案模版不宜大动，刚开始想的在$check$中边遍历边调整输出的数组，后来改成在输出时做一$check$的模拟来方便地输出。

## 2. 二分答案思想

_简述二分答案的基本思想，$dalao$可跳过_

二分答案的理解疑似是来自二分查找 ~~（并不）~~，二分查找的理解疑似是来自“猜数游戏”。

`1 2 4 10 29 30 31 65`

假设预选一个数作为答案，让玩家每次对其中一个数进行询问。

每个询问可能回答：该数比答案大、比答案小或猜中答案。

如果该数即是答案则游戏结束。

那么，希望用最少的询问次数猜出答案，就可以用二分查找法。

由于数列**单调上升**，试想先取一中间数如$10$，如果回答“太小”，则“嫌疑”范围肯定是$10-65$（方便起见这里把$10$考虑进去）这一段$4$个数；如果“太大”则嫌疑范围会取到$1-10$。

可以再在新的嫌疑范围中取该范围的中间数来询问，比如询问$10-65$中的$30$；之后再在新的范围中取中间数……可以预见，最多询问$3$次（从实际编码角度可能理解为$4$次）就能确定这个答案。

------------

简单讲讲代码实现。二分，顾名思义要将数据分成两类，比如小于等于$X$和大于$X$两类。分类要求不重不漏且满足单调。

定义$low$和$high$表示“嫌疑范围”的上下界，由于可知当“嫌疑范围”确定到一点时即结束，所以循环条件为$low+1<high$。（技巧：初始化$low=0,high=n+1$）

结束时，可发现数据已被分成了$[a[0],a[low]]$和$[a[high],a[n]]$两类。这时就可据$low,high$找到“最接近$X$的、次接近$X$的、大于$X$且最接近$X$的”值等。

其实做这道题应该对二分查找有较深理解的，所以这里只是简述一下，接下来不再讲。

------------

二分答案基于二分原理，即用二分的思想快速“猜出”最合适的答案。当且仅当：

1. 题目难以用直接数学方法解出；
2. 题目用逐步验证的方法相对容易解出，但暴力枚举又容易超时；
3. 答案有明显的范围，且范围时间上允许二分答案（时间复杂度一般近似$O[log_2(right-left+1)]$）；
4. 问题的答案是**单调**的（反复强调的重点），即当验证答案$X$满足条件，则$[n,right]$或$[left,n]$也一定满足；不满足时，也可表明$[left,n]$或$[n,right]$也一定不满足。

满足以上条件时，二分答案就可以使用且可能显著优化时间复杂度。

注意一点，二分答案实际上仍然属于穷举的优化，其基本思路也是需要一个个查找验证，所以$check$验证函数的编写是二分答案的核心。比较容易地是采用贪心法验证。

由于仍然是需要分界，因此分成可行与不可行两类。比以下模板是最后找到的$low$就是可行的最大值。

------------

接下来有个无需$ans$的蒟蒻模版，也就是将一般$low=mid+1,high=mid-1$改成直接赋值为$mid$。

实际上可发现$mid$本身是不需再确定的，所以此模板把时间复杂度略微抬高但较容易理解。

```cpp
int find(int low,int high) {
	int mid;
	while(low+1<high){			//找到可行与不可行的分界
		mid=low+(high-low)/2;	//此处是(low+high)/2的防爆优化
		if(check(mid))			//check函数检查可行性
			low=mid;			//当可行时[left,mid]也可行
		else
			high=mid;			//当不可行时[mid,high]也不可行
	} 
	return low;					//由于low表示可行，返回low
}
```
关于二分答案，最适合练手的个人认为是[木材加工](https://www.luogu.com.cn/problem/P2440)。

## 3. 二分解题思路

关于[P1281](https://www.luogu.com.cn/problem/P1281)，可抽象为求将一个数列分成指定份时每份和的“最大值最小”的方案。

从“最大值最小”可以从两个角度看，首先“最大值最小”“最小值最大”一般是二分答案的典型（~~裸~~）特征，所以此题的二分思想并不复杂；

另一方面，由于此题显然是一个最优解问题，数据范围不大所以动态规划也是可行的。

前面提过[UVA714](https://www.luogu.com.cn/problem/UVA714)这个多组数据版，可以发现$DP$在数据大时中超时几率大，因此正解个人认为是二分答案法。

下面讲此题的基本思路。

##### 注：代码中变量$n$表示题中$m$，$m$表示题中$k$。

------------

首先明确我们要二分**查找什么**？这似乎是其它题解几乎没有提到的。顾名思义，要二分的一般是“答案”。

但是此题答案不是一个数，而是在 **“抄写页数最多的人”** 抄写的页数最少时的具体方案。当我们要求出这个方案时，是不是首先要得到这个最小值？所以可以直接先二分这个值。

现在倒回去看二分答案的四个要素。这个值肯定很难用数学方式或暴力枚举来解$(1,2$-$2)$，并且这个最小值也存在范围$(3)$：从**页数最多那本书的页数**到**所有书页数的和**。

这个范围也容易理解。首先任何一本书都**必须**要被抄写，所以无论如何得有一个人抄写那本页数最多的书；当然，从极端情况下（只有$1$人抄写），最多可能有一个人抄写完全部的书，而不可能更多。

粗略计算可发现这个范围用二分答案是完全允许的。（大约只需数十次验证）

现在只剩两个要素$(4,2$-$1)$，也就是**单调性**和**如何逐步验证**。

------------

先考虑单调性。设想我们已经验证，抄写页数最多者的页数的最小值小于等于$30$页，那么是不是肯定小于等于$31$页？

再假设已知这个最小值肯定大于$11$页，那么是不是肯定也会大于$10$页？

换言之，当某个答案可行时，比它大的答案也肯定可行，无需再验证，上界就可以减小；同理，当某个答案不可行，比它小的答案也肯定不可行，下界就要上移。

所以单调性是完全满足的。

------------

最后考虑，我们如何验证答案是否可行？如前所述，由于我们**假想已知**这个“抄写页数最多者的页数”，可以使用贪心法。

由于答案本身是最大值，也就是不允许超过的，那么我们可以遍历整个数组，逐个取书给某人抄写，直到发现再抄就会超过上限时，就换下一个人来取。

这样，在遍历结束时，就可知道这个上限对应最少需要多少人抄写。如果这个数量超过了$k$，即总人数不足抄写完全部的书，表示答案是**不可行的**；反之，如果这个值**小于等于**$k$，这个答案就是可行的。

上述内容有两个细节需提示。首先，按理说，不是需要人数恰好等于$k$才表示可行吗？

实际上，题中**没有强制**每人必须有活干（虽然数据隐式转化为满足此条件）。也就是说，假设一部分人抄写就达到最小值，那也就不需要更多的人。

另一个点是遍历的方向。根据上述内容容易看出，这个方法是优先先遍历的人抄写，也就是如果只需一部分人抄写，那么优先让先遍历的人抄得多些。

而对应题中是要求**尽可能让前面的人少抄写**（~~走后门？~~），同时本身数据是升序的（顺便一提，如果不是升序也需排序成升序），所以需要倒序遍历。

至此，我们已理出了二分答案的大部分框架。

## 4. 二分代码实现

个人比较喜欢把二分玩得清奇一些，所以首先我们看$find$函数。

向前翻$100$行回去看二分答案的框架。由上所述，可知在满足条件时移动的是**上界**，反之移动**下界**。

由此，十分容易就写出了以下函数：

```cpp
int find(int low,int high) {
	int mid;
	while(low+1<high){
		mid=low+(high-low)/2;
		if(check(mid))	//检查可行性
			high=mid;	//上界下移
		else
			low=mid;	//否则下界上移
	} 
	return high;		//high表示可行最小值
}
```
------------

一般二分答案重点就在于$check$函数。但由于我们上面已理清思路（有不明白可以多读几遍），写起来会发现并不太困难。

设$num$累计总共所需的人数，$t$保存当前的人抄写的总页数。由于一开始就有$1$个人，$num$初始化为$1$。

有一个细节要注意，由于我们计算时是不允许超过上限的，所以首先判定当前的人抄写此书是否超出上限，只有在确定不会超出时才进行累加。

顺便提醒一下，注意前面的范围从**页数最大值**开始，所以保证每本书累加后都不会一本书直接超出上限，即每人至少可抄写一本书。

```cpp
bool check(int s) {				//传入mid
	int num=1,t=0;				//num=需要人数，t=当前人总页数
	for(int i=n;i>=1;i--) {		//倒序遍历
		if(t+a[i]>s) t=0,num++;	//如超出则换下一人
		t+=a[i];				//累加入此书
	}
	return num<=m;				//如果人数足够则答案可行
}
```

## 5. 输出

写到这里就不知所云了？

是不是已经忘记题目要求我们输出的：**方案**？

但是到现在我们只求出了“抄写页数最多的人的页数最小值”。现在，要如何从这个最小值求出具体的方案？

等等！是不是感觉似曾相识？的确，刚刚我们刚打完根据某个“答案”求出具体方案的方法。也就是$check$函数中的那个**倒序**循环，正好可用于生成答案。

（实际上，个人感觉其它大部分题解在输出上都复杂化了）

------------

于是，现在我们设置两个数组$x[505],y[505]$表示各人负责书的起始编号和结束编号。注意，假设前面有部分人不必使用时存储的就是$0$ $0$，所以需要初始化为$0$。

那么我们在何时给这个数组赋值？显然是在“换人”时。也就是在`if(t+a[i]>s)`的时候。

仔细思考（~~或试错~~），由于在此时表示第$i$本已经不能给当前的人抄写了，所以`x[num]=i+1`；那么第$i$本书应归下一人抄写，所以`y[++num]=i`。

注意，以上均是建立于**从后往前遍历**的基础上的，所以每个人的结束编号在开始编号之前确定。这里必须花一点时间确保理解。

最后注意一点，由于第一个人的结束编号（即书的总本数）和最后一个人的起始编号（即第一本）无法在循环中设定，所以最后还需增加`y[1]=n,x[num]=1`。

------------

小结一下，实际上我们完全可以直接复制$check$中的部分，然后在判断处增加数组的处理，同时前后注意初始化即可获得一个完整的输出数组。

```cpp
int s=find(low,high);
int t=0,num=1;
for(int i=1;i<=m;i++)
	x[i]=y[i]=0;		//初始化
	
y[1]=n;					//第一个人从第n本开始
for(int i=n;i>=1;i--) {	//倒序遍历
	if(t+a[i]>s) {		//当前书无法给第num人抄写
		t=0;			//重置
		x[num]=i+1;		//第num人开始编号定为i+1
		y[++num]=i;		//第num+1人结束编号为i
	}
	t+=a[i];
}
x[num]=1;				//最后一个人从第1本开始
```
最后根据这个数组输出，注意由于数组是**倒序**的（同样反复强调），所以输出时也应从$m$到$1$倒序输出。

```cpp
for(int i=m;i>=1;i--)	//注意倒序
	cout<<x[i]<<" "<<y[i]<<endl;
```

## 6. 总结

参考代码如下（建议开$long$ $long$）：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

long long n,m;
long long a[505];
int x[505],y[505];				//记录输出

bool check(int s) {				//检查
	int num=1,t=0;
	for(int i=n;i>=1;i--) {		//倒序
		if(t+a[i]>s) t=0,num++;	//换下一人
		t+=a[i];
	}
	return num<=m;				//人数是否足够
}

int find(int low,int high) {	//二分
	int mid;
	while(low+1<high){
		mid=low+(high-low)/2;
		if(check(mid))
			high=mid;
		else
			low=mid;
	} 
	return high;				//注意返回high
}

int main() {
	long long low=0,high=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		high+=a[i];				//上界为所有书的和
		low=max(low,a[i]);		//下界为最厚书的页数
	}
	int s=find(low,high);		//获取最优值
	int t=0,num=1;
	for(int i=1;i<=m;i++)		//初始化输出数组
		x[i]=y[i]=0;
		
	y[1]=n;						//第一人结束点为n
	for(int i=n;i>=1;i--) {		//倒序
		if(t+a[i]>s) {
			t=0;
			x[num]=i+1;			//第num人开始编号定为i+1
			y[++num]=i;			//第num+1人结束编号为i
		}
		t+=a[i];
	}
	x[num]=1;					//最后一人起始点为1
	
	for(int i=m;i>=1;i--)		//倒序
		cout<<x[i]<<" "<<y[i]<<endl;
	return 0;
}
```
嗯……看起来并不太长？

当然，也可以进行一些花式操作，比如在$check$中直接调整输出数组，最终由于最后一次$check$~~我猜~~肯定是可行的（不然不会结束），所以至少在$[1,m]$的范围内答案是正确的。

感觉这个思路最与众不同的地方（~~仅仅~~）是输出……虽然魔芋不能理解递归输出（我太蒻了），但是此文也仅算抛砖引玉，顺便聊以复习。

当然还是感谢读完这$300$行的诸位，希望能对大家有一些帮助，谢谢！

以上。

---

## 作者：Star_Wind (赞：52)

我必需要说一句

## **这题怎么就是DP了？看我DFS切了它！！！**

好吧，事实证明

## **我是对的！！！**

emmm其实Dp思想还是要用到的，我们必须要求一个f数组，这样才可以dfs

首先，参考楼上大佬们的做法，可以简单写出状态转移方程

不过这里要提醒一下，前缀和必须用到，不然TLE就等着你了

还需要初始化，f[1][i]=s[i],不然WA就等着你了

接下来就可以写出方程

```
f[i][j]=min(f[i][j],max(f[i-1][k],s[j]-s[k]));
//还有就是注意到这里出现了min，所以f数组要提前赋3f
```

好了，~~激动人心~~贼难的dfs来了！！

首先这题要倒着搜，所以结束条件是n==0就结束了

还有就是n==1,那么就是从第一本书开始抄了，抄到t结束

这个t是什么呢，现在就要来求了

首先指定一个和s1，然后不断加页数，直到大于f[n][m]

每加一次，就说明要多加一本书了，那么下一次要抄的编号p--，p原来就是等于t

接着n--倒着dfs，t就变成了p

最后输出这个人要抄的就是p+1本到t本

附上AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[310],s[310],f[310][310];
void dfs(int k,int t)
{
    if(k==0) return;
    if(k==1) {cout<<1<<" "<<t<<endl;return;}
    int p=t,s1=a[p];
    while(s1<=f[n][m])
    {
        p--;
		s1+=a[p];
    }
    dfs(k-1,p);
    cout<<p+1<<" "<<t<<endl;
}
int main()
{
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&a[i]);
		s[i]=s[i-1]+a[i];
    }
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=m;i++) f[1][i]=s[i];
    for(int i=2;i<=n;i++)
      for(int j=1;j<=m;j++)
        for(int k=1;k<=j-1;k++) f[i][j]=min(f[i][j],max(f[i-1][k],s[j]-s[k]));
    dfs(n,m);
    return 0;
} 
```
博客食用更佳o：[MYBLOG](https://www.luogu.org/blog/my-SlDyiche/)

各位点个赞哦，祝大家CSP.rp++

---

## 作者：皎月半洒花 (赞：30)

一个区间$DP$

## $\rm{OxO1}$ 前言

事实上，如果按照常规思路的话……这个题应该是一个$\Theta(n^4)$的区间$DP$——首先两遍循环枚举左端点$L\&R$，一重循环枚举中间点，一重之后枚举$K$……

$\rm{However}$，有动规经验的人都知道……左端点是可以不枚举的，因为我们最终询问的是$[1,N]$的，所以可以优化到$\Theta(n^3)$……方程如下：

$$dp_{i,j}=\min\{\max(dp_{k,j-1},\rm{S}[k+1,i])\}_{(0\leq k < i)}$$

其中$\rm{S}$表示求区间和。

我写的代码大概长这样：

```cpp
int main(){
    memset(dp, 63, sizeof(dp)) ;
    cin >> N >> M ; dp[0][0] = 0 ;
    for (i = 1 ; i <= N ; ++ i) 
        cin >> base[i], S[i] = S[i - 1] + base[i] ;
    for (i = 1 ; i <= N ; ++ i)
        for (j = 1 ; j <= M ; ++ j)
            for (k = 0 ; k < i ; ++ k){
                if (dp[i][j] > (t = max(dp[k][j - 1], S[i] - S[k])))
                    dp[i][j] = t, F[i][j] = k + 1 ;
            }
    t = N, i = M, k = 0 ;	
    while (F[t][i])
        s.push(t), t = ((1 & k)) ? t - 1 : F[t][i], i = ((1 & k)) ? i - 1 : i, ++ k ; 
    while (1){
        if (!s.empty())
            cout << s.top() << " ", s.pop() ; 
        else break ;
        if(!s.empty())
            cout << s.top() << endl, s.pop() ;
        else break ;
    }
}
```
呃，至于输出路径，看个人喜好……但是笔者这里想说的问题是这个代码只有$70pts$……原因是题目里有个很坑人的地方：

>如果有多解，则尽可能让前面的人少抄写。

这就很$GG$……不知道为什么，似乎我这种方法$DP$出来的东西和std不同……并且好像std自动带了解决这个问题的功能……于是——

## $\rm{OxO2}$ 乱搞

下面进入乱搞环节。

起初我想的是一个贪心：如果相邻两个区间的长度都不是答案，那么他们对答案没有贡献，那么我们就可以在合理的范围内让前面的区间的$value$更小，后面的$value$更大，所以我一开始把区间存了下来，并写了个$for$循环：
```cpp
inline void update(int x){
	r[x].Len = S[r[x].R] - S[r[x].L - 1] ;
}
************
while (1){
	if (!s.empty()) r[++ j].L = s.top(), s.pop() ; 
	if (!s.empty()) r[j].R = s.top(), s.pop() ; else break ;update(j) ;
}
for (i = 1 ; i < j ; ++ i){
    while (r[i].Len <= Max && r[i + 1].Len <= Max && r[i].L < r[i].R) {
        r[i].R --, r[i + 1].L --, update(i), update(i + 1) ; 
    }
    if (r[i + 1].Len > Max) r[i].R ++, r[i + 1].L ++,  update(i), update(i + 1) ;
}
```

事实上，他依旧不对，只有$80pts$。原因也很简单，相邻的区间可以互相补给，但是如果之后的区间发生了改变，单纯的$for$无法处理……所以我又写了个$dfs$:

```cpp
inline void dfs(int E){
	for (int ii = 1 ; ii < E ; ++ ii){
		int mark = 0 ;
		while (r[ii].Len <= Max && r[ii + 1].Len <= Max && r[ii].L < r[ii].R) 
			r[ii].R --, r[ii + 1].L --, update(ii), update(ii + 1), mark ++ ;
		if (r[ii + 1].Len > Max) 
			mark --, r[ii].R ++, r[ii + 1].L ++, update(ii), update(ii + 1) ;
		if (mark) dfs(E - 1) ;
	}
}
```

然后他就$AC$了……2333……不过其实这个输出只是个小暴力而已.

所以，这篇题解是一篇乱搞题解……$qwq$

$Code:$

```cpp
#include <stack>
#include <cstdio>
#include <cstring>
#include <iostream>

#define MAXN 600
struct range{
    int L, R, Len ;
}r[MAXN] ; int Max ;

using namespace std ; int i, j, k, t ; stack <int > s ;
int N, M, base[MAXN], S[MAXN], F[MAXN][MAXN], dp[MAXN][MAXN] ;

inline void update(int x){
    r[x].Len = S[r[x].R] - S[r[x].L - 1] ;
}
inline void dfs(int E){
    for (int ii = 1 ; ii < E ; ++ ii){
        int mark = 0 ;
        while (r[ii].Len <= Max && r[ii + 1].Len <= Max && r[ii].L < r[ii].R) 
            r[ii].R --, r[ii + 1].L --, update(ii), update(ii + 1), mark ++ ;
        if (r[ii + 1].Len > Max) 
            mark --, r[ii].R ++, r[ii + 1].L ++, update(ii), update(ii + 1) ;
        if (mark) dfs(E - 1) ;
    }
}
int main(){
    memset(dp, 63, sizeof(dp)) ;
    cin >> N >> M ; dp[0][0] = 0 ;
    for (i = 1 ; i <= N ; ++ i) 
        cin >> base[i], S[i] = S[i - 1] + base[i] ;
    for (i = 1 ; i <= N ; ++ i)
        for (j = 1 ; j <= M ; ++ j)
            for (k = 0 ; k < i ; ++ k){
                if (dp[i][j] > (t = max(dp[k][j - 1], S[i] - S[k])))
                    dp[i][j] = t, F[i][j] = k + 1 ;
            }
    Max = dp[N][M], t = N, i = M, k = 0, j = 0 ;	
    while (F[t][i]) s.push(t), t = ((1 & k)) ? t - 1 : F[t][i], i = ((1 & k)) ? i - 1 : i, ++ k ; 
    while (1){
        if (!s.empty()) r[++ j].L = s.top(), s.pop() ; 
        if (!s.empty()) r[j].R = s.top(), s.pop() ; else break ; update(j) ;
    }
    dfs(j) ;
    /*for (i = 1 ; i < j ; ++ i){
        while (r[i].Len <= Max && r[i + 1].Len <= Max && r[i].L < r[i].R) {
            r[i].R --, r[i + 1].L --, update(i), update(i + 1) ; 
        }
        if (r[i + 1].Len > Max) r[i].R ++, r[i + 1].L ++,  update(i), update(i + 1) ;
    }*/
    for (i = 1 ; i <= j ; ++ i) cout << r[i].L << " " << r[i].R << endl ;
}
```


---

## 作者：梦里调音 (赞：23)

我这是有几百年没写题解了（落泪

~~其实这是一道很有趣的题，对吧？其实挺有画面感的~~

那么，很多$dalao$都选择了使用**动态规划**，但本蒟蒻的做法是**二分**。

但看到没有一篇题解是很好的二分讲解啊，那么我来吧~

来先理解一下题意。

简而言之，就是：

> 把m个数分成k组，使每组数的和尽量平均。

那么，我们需要二分的其实是这个“平均”的值，也就是**复制时间**。

把二分出来的**复制时间**代到输入数据中，就可以判断这个**复制时间**是否可行。根据题目要求：

> 尽可能让前面的人少抄写

emmm这个怎么实现呢？

其实啊，我们这么想：我们面前有一面长长的桌子，桌子上从左到右整整齐齐摆着$m$本书，有$k$个可怜的娃要去抄书。要使前面的人少抄写，也就是抄靠右边的书的娃要多抄。那么，就要从抄靠右边的书的娃开始枚举，让他尽量多抄。

```

伪代码：

for m~1//给娃加书
{
	if 当前这个娃抄的书超过选择的复制时间 
    	then 把这本书留下，换下一个娃来抄
        if 没有娃能来抄书了，就说明复制时间太短了
}
	
最后要特判：最后抄书最少的娃能不能抄完书，不能的话也是失败的！

```
于是，通过以上操作变可以二分出我们心心念念的**复制时间**了！！

然后，又是一个代入的过程，我们把得出的**复制时间**代入输入数据，再次从右到左枚举一次，就可以得出每个人抄书的范围。

但是，答案要从左往右输出，所以拿个数组记录下来就好惹！！

还有一些细节要注意，代码里都有注释了

完整代码：

```
/*
	m个数分成k组，使每组数的和尽量平均
*/

~written by 梦里调音~

#include <iostream>
#include <stdio.h>
using namespace std;
const int N = 505;
int m, k, a[N], ans;
int res[N][2];
bool lovemok(int p)
{
	int now = k;//还剩多少人能抄书(包括正在抄书的人)
	int cnt = 0;//这个人要抄书的页数
	for (int i = m; i > 0; i--)
	{
		cnt += a[i];
		if (cnt > p)
		{
			cnt = a[i], now--;
		}
			
		if (now <= 0)return false;//书还没抄完，但已经没有人可以去抄书了
	}
	if(cnt > p)return false;
	return true;
}
void print()
{
	int id = k, cnt = 0, st = m;//这个人的编号，当前这个人已经抄的页数，这个人开始抄书的起点
	for (int i = m; i > 0; i--)
	{
		cnt += a[i];
		if (cnt > ans)
		{
			cnt = a[i];
			res[id][0] = i + 1;
			res[id][1] = st;
			st = i;
			--id;
		}
	}
	//最后一个人的特殊处理
	res[1][0] = 1;
	res[1][1] = st;

	//输出
	for (int i = 1; i <= k; i++)
		cout << res[i][0] << " " << res[i][1] << endl;
	return;
}
signed main()
{
	int l = 0, r = 0, mid;
	scanf("%d%d", &m, &k);
	if (!m) {//特判注意一下
		cout << "0\n";
		return 0;
	}
	for (int i = 1; i <= m; i++)
		scanf("%d", &a[i]), r += a[i];
	while (l <= r)
	{
		mid = (l + r) / 2;
		if (lovemok(mid))
			r = mid - 1, ans = mid;
		else
			l = mid + 1;
	}
	print();
	return 0;
}
```


---

## 作者：Dry_ice (赞：18)

动态规划就是：
> 设字母，写式子。你怎么讲，我怎么写。

看有很多 $dalao$ 写了**二分**，我来一波**基础动规**。

## 整体思路：动态规划
### 具体步骤（状态的设置与应用）
1. 定义状态：设 $F_{i,j}$ 表示前 $i$ 个人分 $j$ 本书的最短时间。

1. 答案位置：根据状态 $F_{i,j}$ 的含义，我们可以知道最短用时是 $F_{k,m}$ 。

1. 状态转移

仔细阅读题目，我们会发现所用时间并不是所有人用时之和，而是所有人中用时最多的那个人的用时。

所以转移方程也就出来了：
$$F_{i,j}=\min\{\max(F_{i-1,l},\sum\limits_{h=l+1}^jC_h)\}(l=1,2,...,j-1)$$

4. 初始化（简单却不可省略）

$F_{i,j}=\left\{
\begin{aligned}
& +\infty & i\neq1\\
& \sum\limits_{l=1}^jC_l & i=1
\end{aligned}
\right.
$

### 打印答案
只需要写一个 $void$ 类型的 $print$ 递归函数利用**贪心**思想进行 **倒序递归，正序打印** 。

## CODE
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
int m,k;
int c[505], s[505];
int f[505][505];
inline void init() {
	memset(f, 127 / 3, sizeof f);
    scanf("%d %d", &m, &k);
	for (int i = 1; i <= m; ++i) {
        scanf("%d", &c[i]);
        s[i] = s[i - 1] + c[i];
        f[1][i] = s[i];
    }
}
inline void work() {
	for (int i = 2; i <= k; ++i)
		for (int j = 1; j <= m; ++j)
			for (int l = 1; l < j; ++l)
				if (std:: max(f[i - 1][l], s[j] - s[l]) < f[i][j]) 
      				f[i][j] = std:: max(f[i - 1][l], s[j] - s[l]);
}
inline void print(int i, int j) {
	if(j == 0) return;
	if(j == 1) {
		printf("1 %d\n",i);
		return ;
	}
	int p = i, q = c[i];
	while(q + c[p - 1] <= f[k][m]) {
        q += c[p - 1];
        --p;
    }
	print(p - 1, j - 1);
	printf("%d %d\n", p, i);
}
int main(void) {
	init();
	work();
	print(m, k);
	return 0;
}
```
~~（不要抄题解~~

## The end. Thanks.


---

## 作者：lingerleaf (赞：12)

一道很好的二分题

非常详细了，二分查找。

注释几乎是打得淋漓尽致了，但是可能有一些东西也许还是 意之所随者，不可以言传也
```cpp
#include<cstdio>
/*
* 整体概括：
* check(maxn) 检查每组最大为maxn的规则分组，能不能分
* binary_search(l,r) 找出分成k组，一组最大页数的最小值
* sort_print(maxn) 在找出了真正的maxn的情况下，输出
*/

/*
*书本的from,to区间的和
*/
#define _Count(from,to) (s[to]-s[from-1])

using namespace std;
/*
*一组书本的分割信息
*/

struct once{
	int from,to;
};
/*
* p:当前i本书的页数
* s:当前1,i本书的总页数
* m:如题
* s:如题
*/
int m,k,p[510],s[510];

once sep[510];/**书本每一组的分割信息*/ 

/*
* 假设当前单组最大页数是maxn，检查是否有可以满足要求的分法
*/
bool check(int maxn){ 
	int group=0;
	for(int i=1;i<=m;++i){
		group++;
		if(group==k+1)	return false;/**这种情况说明了在maxn的范围内分到极限，仅仅用k组根本不够。所以不满足，false*/
		for(int j=i;j<=m;++j){
			if(_Count(j,j)>maxn)	return false;/**单个都比maxn大，绝对不满足，false。之所以要加这一段是为了防止死循环*/
			/**当前组已经分到极限了，重新开一组来分*/
			if(_Count(i,j)>maxn){
				i=j-1;/**由于i后面要+1所以设置为j-1，i就会从j开始，重新分组*/
				break;
			}
			if(j==m)	i=m;/**已经分到了最后，防止重来，i设置为m，终止所有循环*/
		}
	}
	return true;/**前面已经过滤了好多，能执行到这里说明是满足的. 但是group有可能是比k来的小的，但比k来的小表明在maxn内分是满足得了的，也是true*/
}

/*
* sort_print() : 按照每组最大值为maxn的规则有顺序地分割并输出
* 虽然我们已经发现了maxn的最小值，但是可能有多组. 
* 按照题目的意思得前面的组抄的少. 但是由于我们只能直接控制尽可能大，不能直接控制尽可能小.所以从后往前，控制后面的组来的大即可
*/
void sort_print(int maxn){
	int group=0;
	for(int i=m;i>=1;--i){
		group++;
		for(int j=i;j>=1;--j){
			if(_Count(j,i)<=maxn){
				sep[group]=(once){j,i};
			}else{
				i=j+1;
				break;
			}
			if(j==1)	i=1;
		}
	}
}

/*
* 二分查找
*/
void binary_search(int l,int r){
	int mid;
	while(l<=r){
		mid=(l+r)/2;
		if(check(mid)){
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	sort_print(l);/**查找出来的l就是每组的最小值了，按照这个最小值的规则，有顺序地输出*/
}

int main(){
	scanf("%d %d",&m,&k);
	if(m==0)	return 0;/**题目的某个数据点的RE陷阱*/
	for(int i=1;i<=m;++i){
		scanf("%d",p+i);
		s[i]=s[i-1]+p[i];
	}
	binary_search(_Count(1,m)/k,_Count(1,m));
	/**由于前面是数组1~k先是后面的组，再是前面的组，这里倒序输出即可*/
	for(int i=k;i>=1;--i){
		printf("%d %d\n",sep[i].from,sep[i].to);
	}
}
```

---

## 作者：LevenKoko (赞：11)

[原题链接__戳我噢](https://www.luogu.org/problemnew/show/P1281)

##【思路】
>（区间）DP
>F[I][J]表示前i本书分给j个人用的最短时间
>由于每一次j的状态由比j小的状态得出，所以要先枚举j，然后枚举i，接着枚举上一次抄书的人是谁

###我觉得，难点在于输出
具体见代码
~~压行压到手抽筋~~
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
inline int read(){
	char chr=getchar();int f=1,ans=0;
	while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr))  {ans=ans*10;ans+=chr-'0';chr=getchar();}
	return ans*f;
}
int a[505],f[505][505],n=read(),m=read(),s=0,&ans=f[n][m],num=0,w=n,pre[505],x;
void output(int x){
	if(x>0) output(pre[x]-1); else return; if(pre[x]<=0) return;printf("%d %d\n",pre[x],x);}//这里递归输出
int main(){
	memset(f,127/2,sizeof(f));memset(pre,0,sizeof(pre));f[0][1]=0;
	if(!n&&!m) return 0;//坑点！！！
	for(int i=1;i<=n;i++)
		a[i]=read(),f[i][1]=f[i-1][1]+a[i];//前i本书都交给第一个人抄(即a[i]的前缀和)
	for(int j=2;j<=m;j++)
		for(int i=j;i<=n;i++)
			for(int k=j;k<=i;k++){
				int x=max(f[k-1][j-1],f[i][1]-f[k-1][1]);//取两者最长的抄书时间
				if(f[i][j]>x) f[i][j]=x;//取最小值
			}
	for(int i=n;i>=1;i--){//这里贪心，因为后面的人抄尽量多，前面少，所以倒过来枚举
		s+=a[i];
		if(s>ans) s=a[i],pre[w]=i+1,w=i;//pre[w]记录这个人抄书的开始位置
	}
	printf("%d %d\n",1,w);//第一组特判
	output(n);//递归输出
	return 0;
}
```
##打完收工
hia~hia~hia~


---

## 作者：Forward_Star (赞：9)

没有人写四边形不等式吗。。。


http://blog.csdn.net/weixin\_39872717/article/details/78805153

（我的CSDN博客）

这题和邮局（http://blog.csdn.net/weixin\_39872717/article/details/78765532）

一样是一道区间dp，容易写出状态转移方程f[i][j]=min{max{f[i][k-1],sum[j]-sum[k]}}，其中f[i][j]表示前i本书由j个人抄写的最短时间，sum表示前缀和，sum[i]表示前i本书的总页数。


四边形不等式的优化在邮局post office讲过一遍，这题的决策变量显然也是符合区间单调性的。嗯……真的没什么好说的，这题和邮局的类型一模一样。


不过最后输出的不是最优解，而是方案，就不是dp解决的了。dp求出的是最优解，方案其实从s[m][n]回溯也是可以求的。但多个最优解方案时让前面的人尽量少抄这个条件就比较难处理了，我用s[m][n]回溯的方法调了很久，还是没调出来，所以就用了另一个思路：贪心。


倒着枚举，只要后面的人还能抄就尽量让他多抄些，直到不能抄（设他当前抄的是i至l(i<=l)段且符合要求，则i--；直到sum[l]-sum[i-1]>最优解f[m][n]，那么说明他最多可以抄i+1到l段）。


解释得不太好……看看代码吧：（注释不打了，对照邮局post office，dp过程是几乎一样的）



```cpp
    #include<cstdio>  
    #include<cstring>  
    #include<algorithm>  
    using namespace std;  
        int m,n;  
        int a[501];  
        int ans[501][2];  
        int f[501][501];  
        int s[501][501];  
    int main()  
    {  
        scanf("%d%d",&m,&n);  
        if (m==0&&n==0) return 0;  
        for (int i=1;i<=m;i++)  
        {  
            int x;  
            scanf("%d",&x);  
            a[i]=a[i-1]+x;  
        }  
        for (int i=1;i<=m;i++)  
        {  
            s[i][1]=1;  
            f[i][1]=a[i];  
        }  
        int INF=2147483647;  
        for (int j=2;j<=n;j++)  
        {  
            s[m+1][j]=m;  
            for (int i=m;i>=j;i--)  
            {  
                f[i][j]=INF;  
                for (int k=s[i][j-1];k<=s[i+1][j];k++)  
                    if (f[i][j]>max(f[k][j-1],a[i]-a[k]))  
                    {  
                        s[i][j]=k;  
                        f[i][j]=max(f[k][j-1],a[i]-a[k]);  
                    }  
            }  
        }  
        int last=m;  
        int tot=0;  
        for (int i=m;i>=1;i--)  
            if (a[last]-a[i-1]>f[m][n])  
            {  
                ans[++tot][0]=i+1;  
                ans[tot][1]=last;  
                last=i;  
            }  
        printf("%d %d\n",1,last);  
        for (int i=tot;i>=1;i--)  
            printf("%d %d\n",ans[i][0],ans[i][1]);  
        return 0;  
}
```

---

## 作者：HoshiuZ (赞：8)

定义$f[i][j]$表示将前$j$本书分给$i$个人的最短复制时间，那么易得
$$
f[i][j]=min\{max(f[i-1][k],f[1][j]-f[1][k])\}
$$
其中
$$
1<=k<j
$$
具体含义：将前$j$本书分给$i$个人的最短复制时间，等同于将前$k$本书分给$i-1$个人的最短复制时间与将第$k+1$到第$j$本书分给一个人的最短复制时间的最大值，枚举$k$，取这其中的最小值。



这样复制最后的复制时间即为$f[k][m]$。接着的操作就是如何判断每个人的抄的书。题目中说，如果有多解，则尽可能让前面的人少抄写。因此可以采用贪心，从末尾开始向前加，加到不能再加了时（即再加后就超过了$f[k][m]$）就把这一组分给一个人。这样递归输出即可。

```c++
#include<bits/stdc++.h>

using namespace std;

int m,k,page[510],dp[510][510];

void printp(int x,int to) {
	if(!to) return ;
	int sum=0,t=1;
	for(int i=to;i>=1;i--) {
		sum+=page[i];
		if(sum>x) {
			sum-=page[i];
			t+=i;
			break;
		}
	}
	printp(x,t-1);
	cout<<t<<" "<<to<<endl;
}

int main() {
	memset(dp,127,sizeof(dp));
	cin>>m>>k;
	dp[1][0]=0;
	for(int i=1;i<=m;i++) {
		cin>>page[i];
		dp[1][i]=dp[1][i-1]+page[i];
	}
	
	for(int i=2;i<=k;i++) {
		for(int j=1;j<=m;j++) {
			for(int k=1;k<j;k++) {
			dp[i][j]=min(dp[i][j],max(dp[i-1][k],dp[1][j]-dp[1][k]));
			}
		}
	}
	
	printp(dp[k][m],m);
	
	return 0;
}
```



---

## 作者：Ajwallet (赞：6)

思路
本题有两种做法，其一为二分答案，另一种为动态规划，在这里介绍的是动态规划。

用f[n][m]表示前n本书，m个人做时的最短时间。

动态转移方程

f[j][i]=min(f[j][i],max(f[l][i-1],pa[j]-pa[l]));

ps:pa为前缀和

代码
```cpp
#include<cstdio>
#define k freopen//文件输入输出
#define r(i,a,b) for(int i=a;i<=b;i++)//循环
#define pk putchar(32)//空格
#define ph putchar(10)//换行
using namespace std;int n,m,f[501][501],pa[501];//Prefix and 前缀和 
int max(int x,int y)//最大值
{
    return x>y?x:y;
}
int min(int x,int y)//最小值
{
    return x<y?x:y;
}
void read(int &a)//输入流
{
    char c;int d=1,f=0;
    while (c=getchar(),c<'0'||c>'9') if (c=='-') d=-1;f=f*10+c-48;//因为这个卡了半天，书本页数竟然有负数。。。
    while (c=getchar(),c>='0'&&c<='9') f=f*10+c-48;
    a=d*f;return;
}
void write(int x)//输出流
{
    if(x)write(x/10);else return;
    putchar(x%10+48);
}
void print(int i,int j)//输出每个人从哪抄到哪
    int t,x;
    if (i<=0) return;
    if (!j)     return;
    if(j==1)
     {write(1);pk;write(i);ph;return;}
    t=i;x=pa[i]-pa[i-1];
    while (x+pa[t-1]-pa[t-2]<=f[n][m]&&t>1)
    {
     x=x+pa[t-1]-pa[t-2];
     t--;
    }
    print(t-1,j-1);
    write(t);pk;write(i);if (i!=n) ph;
}
int main()
{
    read(n);read(m);int x;
    r(i,0,500)
     r(j,0,500)
      f[i][j]=2147483647;//初值
    r(i,1,n) {read(x);pa[i]=pa[i-1]+x;f[i][1]=pa[i];}//第一个人抄的就是前缀和
    r(i,2,m)
     r(j,1,n)
      r(l,1,j-1)
       f[j][i]=min(f[j][i],max(f[l][i-1],pa[j]-pa[l]));//动态转移
  print(n,m);//输出
  //write(f[n][m]);可以用来理解
}
```

---

## 作者：路依然远 (赞：3)

先来分享一首纯音：intro:the down

边听边看


------------


首先，为造福广大Pascal用户，~~本蒟蒻~~就来写一篇Pascal题解吧

这道题目 为什么我想到的是尺取法？？？

各位大佬见笑了······

~~如果用尺取法的话，应该好像似乎也许可能大概也不会炸吧~~

**反正上面别管，下面是正解：**

于是~~本蒟蒻~~又想到了一种名叫DP的解法

就像这样：
```pascal
uses math;
var
 f:array[0..500,0..500]of longint;
 s,a,b,c:array[0..500]of longint;
 n,m,i,j,k,l,t:longint;
begin
 readln(n,m);
 for i:=1 to n do
  begin
   read(a[i]);
   s[i]:=s[i-1]+a[i];//前缀和
   f[i,1]:=s[i];//初始化
  end;
 for i:=2 to n do//DP
  for j:=2 to m do
   begin
    f[i,j]:=maxlongint;
    for k:=j-1 to i do
     f[i,j]:=min(f[i,j],max(f[k,j-1],s[i]-s[k]));//状态转移方程
   end;
 j:=n+1;l:=n;
 for i:=1 to m do//贪心，因为要给后面的人尽可能多的书，所以j从后面搞
  begin
   t:=0;
   while (t+a[j-1]<=f[n,m])and(a[j-1]<>0) do
    begin
     dec(j);
     t:=t+a[j];
    end;
   b[i]:=j;c[i]:=l;
   l:=j-1;
  end;
 for i:=m downto 1 do//很恶心的倒序输出
  writeln(b[i],' ',c[i]);
end.

```
AC啦啦啦

~~这是一篇有声音的题解????~~


---

## 作者：yu__xuan (赞：3)

### 题目
[P1281 书的复制](https://www.luogu.com.cn/problem/P1281)

### 思路
二分答案。先使用二分答案求出复制时间（抄写页数最多的人用去的时间）最短是多少。然后使用一定的小技巧使得前面的人尽量少抄写。

**二分答案**的部分应该都会吧，简略的讲一下：
二分复制时间，判断在当前复制时间的限制下抄完 $m$ 本书需要几个人，如果需要的人数小于等于 $k$ 的话就可以见小复制时间，如果大于 $k$ 的话就要增加复制时间。

**小技巧**：
我们二分答案求出最少的复制时间，然后从第 $k \sim 1$ 个人、第 $m \sim 1$ 本书开始给他们布置任务，如果当前人不能再抄更多的书了（再抄更多的书就要超出我们二分出的最短复制时间了）就换下一个人，这样使得后面的人抄尽可能多的书，前面的人就可以抄尽可能少的书。

### $Code$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#define MAXN 501

inline void read(int &T) {
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int m,k,a[MAXN];
int ans1[MAXN],ans2[MAXN];

bool check(int x,int tot=1) {
	for(int i=1,cnt=0;i<=m;++i) {
		if(a[i]>x) return false;
		if(tot>k) return false;
		if(a[i]+cnt<=x) cnt+=a[i];
		else cnt=a[i],++tot;
	}
	return tot<=k;
}

int main() {
	read(m),read(k);
	for(int i=1;i<=m;++i) read(a[i]);
	int l=0,r=100000001;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(check(mid)) r=mid-1;
		else l=mid+1;
	}
	int num=k;ans1[1]=1,ans2[k]=m;
	for(int i=m,cnt=0;i>=1;--i) {
		if(cnt+a[i]>l) {
			ans1[num]=i+1;
			ans2[--num]=i;
			cnt=a[i];
		}else cnt+=a[i];
	}
	for(int i=1;i<=k;++i) printf("%d %d\n",ans1[i],ans2[i]);
	return 0;
}
```

---

## 作者：江yyyz1911 (赞：2)

首先，这是一个DP（多阶段决策问题）；（由题意得，注意重点：“m本有***顺序的***书分给k给人复制”）

那么就要考虑一下求什么：“使得复制时间最短”；

那么f[i][j]就表示前i个人抄j本书的最短时间

有三种可能是最小时间：

1.原先所求

2.前i-1个人抄k本书

3.抄k到j本书的总页数所花时间（若将时间与页数的数值看成相同的）

边界：

一个人抄任意第i本书的时间都是第i本书的前缀和

其次，这是一个递归

求：“设计一种方案”

边界：没人直接return ；

          只有一个人 输出1 当前这本书
 
 根据递归特性，倒着做能正着输出
 
 从最后一个人往前找直到时间比f[n][m]大
 
 先找后输出
 
 详细请看代码
 ```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[155],b[155],f[150][150];
int sc(int x,int y)//x个人,y本书 
{
	if(x==0) return 0;//没人了 
	if(x==1)//只有一个人 
	{
		cout<<1<<" "<<y<<endl;//1到y本书 
		return 0;
	}
	int tt=y,xx=b[y];
	while(xx+b[tt-1]<=f[n][m])
	{//如果第y本书的页数和+当前-1本书比求出来的最小值小 
		xx+=b[tt-1];//加上这本书的页数***倒着来 
		tt--;//看下一本书数是不是 
	}
	sc(x-1,tt-1);//人-1，书 
	cout<<tt<<" "<<y<<endl;
	return 0;
}
int main()
{
	cin>>m>>n;//n人m本书 
	for(int i=1;i<=m;i++)
	{
		cin>>b[i];//表示第i本书的页数 
		a[i]=a[i-1]+b[i];
	}
	
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=m;i++) 
	{
		f[1][i]=a[i]; 
	}
	for(int j=2;j<=n;j++)//j个人 
	for(int i=j;i<=m;i++)//i本书 
	for(int k=j;k<i;k++)//前k本书 
	{
		int ma=max(f[j-1][k],a[i]-a[k]);
		f[j][i]=min(f[j][i],ma);
	 }
	//前j个人抄i本书的最小时间 
	sc(n,m);//n个人,m本书 
	return 0;
}
```


---

## 作者：HeartBlock_Love (赞：2)

本题可以用动态规划解决，设f(k,m)为前m本书交由k个人抄写，需要的最短时间，则状态转移方程为  
            f[k][m]=min{max{f[k-1][i],          }, i=1, 2, …, m-1}

       动态规划求出的仅仅是最优值，如果要输出具体方案，还需根据动态规划计算得到的最优值，做一个贪心设计。具体来说，设最优值为T，那么k个人，每个人抄写最多T页。从最后一本书开始按逆序将书分配给k人去抄写，从第k个人开始，如果他还能写，就给他；否则第k个人工作分配完毕，开始分配第k-1个人的工作；以后再是第k-2个、第k-3个、……直至第1个。一遍贪心结束后，具体的分配方案也就出来了。



------------
```


#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int max1(int,int);
int print(int,int);
int x,y,i,j,m,n,k,t,l;
int a[501],f[501][501],d[501];
int main()
{
  cin>>m>>k;
  for (i=0;i<=500;i++)
   for (j=0;j<=500;j++)
    f[i][j]=10000000;  
  for (j=1;j<=m;j++)
   {
     cin>>a[j];                           //输入m本书的页数
     d[j]=d[j-1]+a[j];                      //d[j]为前j本书总的页数
     f[1][j]=d[j];                          //f[i][j]为一个人抄前j本书所需时间
   } 
  for (i=2;i<=k;i++)               //f[k][m]为前m本书交由k个人抄写，需要的最短时间
   for (j=1;j<=m;j++)
    for (l=1;l<=j-1;l++)
     if (max1(f[i-1][l],d[j]-d[l])<f[i][j]) 
      f[i][j]=max1(f[i-1][l],d[j]-d[l]);
print(m,k);                             //从第k个开始分配抄写方案

int max1(int x,int y)                         //求x和y中最大值
{
  if (x>y) return x; else return y;    
}
int print(int i,int j)                           //递归输出抄写页数的方案
{
    int t,x;
    if (j==0) return 0;
    if (j==1)                               //第1个人抄写1到i本书
     {
        cout<<1<<" "<<i<<endl;
        return 0;     
     }
    t=i;x=a[i];
    while (x+a[t-1]<=f[k][m])  //从最后一本书按逆序分配第j个人抄写，只要能写，就给他
     {
       x+=a[t-1];
       t--;   
     } 
    print(t-1,j-1);             //用递归过程给第j-1个人分配抄写方案，这时只有t-1书了
    cout<<t<<" "<<i<<endl;    //递归返回时输出，因为递归过程是最后1个人先分配抄书
} 
```


---

## 作者：konjacq (赞：2)

```
一本书不允许给两个(或以上)的人抄写,分给每一个人的书,必须是连续的,比如不能把第一,第三,第四本书给同一个人抄写.
```
显然这道题具有典型区间DP的特征,状态很容易想出来:用f[i][j]表示已经分配了i份书稿,分配给了j个人.然而我不想去想状态转移方程,再一看
```
使得复制时间最短
```
求最小值当然也可以用二分啊!

于是就是对细节的处理:

- 二分时要注意上下界,防止舍去了正确答案.谨防在减小上界时舍去当前mid,因为可能当前mid即是最短时间.

- 要求前面的人尽量少抄,所以检验答案可以顺向搜索,但输出时要反向输出

代码:
```cpp
#include <cstdio>
using namespace std;

int m, k, s[505], lft, rgt = 300000, mid, now, cnt, f[505], t[505];

int main()
{
    scanf("%d%d", &m, &k);
    for (int i = 0; i < m; i++)
        scanf("%d", &s[i]);
    while (lft < rgt)
    {
        mid = (lft + rgt) >> 1;
        now = 0, cnt = 1;
        for (int i = 0; i < m; i++)
        {
            if (now + s[i] <= mid)
                now += s[i];
            else
                now = s[i], cnt++;
        }
        if (cnt > k)
            lft = mid + 1;
        else
            rgt = mid;
    }
    now = 0, cnt = k - 1, f[0] = 1, t[k - 1] = m;
    for (int i = m - 1; i >= 0; i--)
    {
        if (now + s[i] <= rgt)
            now += s[i];
        else
            f[cnt--] = i + 2, t[cnt] = i + 1, now = s[i];
    }
    for (int i = 0; i < k; i++)
        printf("%d %d\n", f[i], t[i]);
    return 0;
}
```

然而当你交上去这份代码,你会发现**只有90分**.下载测试数据来看,这个数据点最后一本书页数远大于前面所有书的总和.发现是自己对最后一本书能否抄完的判断不完善,故想出解决办法:

### 再加一本书

具体操作是将
```cpp
for (int i = 0; i < m; i++)
```
改为
```cpp
for (int i = 0; i <= m; i++)
```
这样就多出了一本页数为0的书s[m],避开了对数据中最后一本书的处理.

AC代码:
```cpp
#include <cstdio>
using namespace std;

int m, k, s[505], lft, rgt = 300000, mid, now, cnt, f[505], t[505];

int main()
{
    scanf("%d%d", &m, &k);
    for (int i = 0; i < m; i++)
        scanf("%d", &s[i]);
    while (lft < rgt)
    {
        mid = (lft + rgt) >> 1;
        now = 0, cnt = 1;
        for (int i = 0; i <= m; i++)
        {
            if (now + s[i] <= mid)
                now += s[i];
            else
                now = s[i], cnt++;
        }
        if (cnt > k)
            lft = mid + 1;
        else
            rgt = mid;
    }
    now = 0, cnt = k - 1, f[0] = 1, t[k - 1] = m;
    for (int i = m - 1; i >= 0; i--)
    {
        if (now + s[i] <= rgt)
            now += s[i];
        else
            f[cnt--] = i + 2, t[cnt] = i + 1, now = s[i];
    }
    for (int i = 0; i < k; i++)
        printf("%d %d\n", f[i], t[i]);
    return 0;
}
```

---

## 作者：wtong (赞：2)

标准的二分查找


跟[P1182](https://www.luogu.org/problemnew/show/P1182)很像
```
#include<iostream>
#include<cmath>
#include<cstring>

using  namespace std;

int n,m,a[100005];
//n本书,m个人
//a[]为每本书的时间

bool check(int x){
//这个函数是用来检查是否可以在x的时间内
//由m个人抄完整本书的
	int s=0,w=0;
    //s是最少所需人数,w是目前的人抄写时间
	for(int i=1;i<=n;i++){
		if(x<a[i]) return 0;
        //若这本书耗费的时间比x还长,直接return false
		if(w+a[i]>x){
			s++;
			w=0;
            //超出x,计下一个人
		}
		w+=a[i];
		if(s>m) return 0;
        //人数超了,false
	}
	if(w!=0) s++;
    //最后一个人
	if(s>m) return 0;
    //人数超了,false
	return 1;
}

int main()
{ 
	int l=0,r;
    //将时间的最小的可能计为l(下限)
	int f[600][5];
	int x,y,cnt=0,w=0;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		r+=a[i];
        //将时间的最大的可能计为r(上限)
	} 
	while(l<r){//二分
		int mid=(l+r)/2;
		if(check(mid)) r=mid;
        //若在目前的“最短时间”下m个人可以完成,
        //将上限变小,缩小范围
		else l=mid+1;
        //若在目前的“最短时间”下m个人不可以完成,
        //将下限变大,缩小范围
	}
    //得出最短时间(l) P1182就输出这个值就可以了
    //开始输出我们的方案
    //x是每一个人的范围的右端点
    //w是目前的人抄写时间
	x=n;
	for(int i=n;i>=1;i--){
		if(w+a[i]>l){
			f[++cnt][2]=x;
			f[cnt][1]=i+1;
            //将每个人的范围存到一个数组里
			x=i;
            w=0;
            //超出x,计下一个人
		}
		w+=a[i];
	}
	if(w!=0){
        //最后一个人
		f[++cnt][1]=1;
		f[cnt][2]=x;
	}
	for(int i=m;i>=1;i--) //输出
        cout<<f[i][1]<<" "<<f[i][2]<<endl;
     
    return 0;
}
```



---

## 作者：wky32768 (赞：2)

开始乱搞

其实也是二分

枚举每一个人看了多少页

然后为了让前面的人最少倒着输出。

用can函数判断这种页数是否可行。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1200],n,k,mid;
int printx[1200],printy[1200],printa[1200],printb[1200];
bool can(int x) {
	int at=1,num=0;
	for(int i=1; i<=k; i++) {
		num=0;
		while(num+a[at]<=x) {
			num+=a[at];
			at++;
		}
	}
	if(at==n+1) return true;
	else return false;
}
int main() {
	cin>>n>>k;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
	}
	a[n+1]=0x3f3f3f3f;
	int l=1,r=0x3f3f3f3f;
	while(l<r) {
		mid=(l+r)/2;
		if(can(mid)==true)
			r=mid;
		else l=mid+1;
	}
	int ans=l;
	int start=n,num=0;

//	cout<<l;
	for(int i=k; i>=l; i--) {
		num=0;
		int q=start;
		while(num+a[start]<=ans){num+=a[start];start--;if(start<=0) break;}
		printx[i]=start+1;
		printy[i]=q;
		q=start;
	}
	for(int i=l;i<=k;i++)
		cout<<printa[i]<<" "<<printb[i]<<endl;
}

```

---

## 作者：Drinkkk (赞：2)

/\*
P1281 题解

动态规划与递归的应用


思路：

首先先考虑搜索，但是$k<=m<=500$，搜索是过不了的。

那我们考虑$DP$，那么现在问题来了，如何$DP$？

先考虑我们的$dp$要用到的$f$数组表示什么，是$1$维还是$2$维，如何实现。

当$f$数组是$2$维时，我们可以假设$f[i][j]$为将前$i$本书分给$j$个人抄的最优解，因为这样好实现我们的代码，那如果我们用$su[i]$来表示前$i$本书的页数和的话，动态转移方程就是：

$f[i][j]=min(f[i][j],max(f[k-1][j-1],su[i]-su[k-1]));$

在这里，$f[i][j]$表示的是当前的状态。

$k$是我们要循环寻找的断点，来表示$k$~$i$给第$k$个人抄，$j-1$个人抄前$k-1$本书的最优解。


这样，我们就有了一个答案：$f[n][m]$（我用了$n$表示$m$，并用$m$表示$k$）。

但是，题目要求的是第每个人抄写的书的起始编号和终止编号哦，怎么求呢，很显然，我们可以用递归来输出，因为每个人抄的书是连续的，且当有多个最优解时，后面的人抄的书越多越好，所以我们要从后往前递归，且只要这个人还能抄，就让他抄，然后在回溯时就会输出答案了，只是要注意一下当$n=0$的时候直接$exit(0)$就好了。


下面上AC代码：

\*/
```cpp
#include <cstdio>
#include <cstdlib>
int f[1001][1001],su[1001],a[1001];
int n=0,m=0;
int min(int x,int y)
{
    return x<y?x:y;
}
int max(int x,int y)
{
    return x>y?x:y;
}
void read()
{
    scanf("%d %d",&n,&m);
    if(n==0)
    {
        exit(0);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        su[i]=su[i-1]+a[i];
        f[i][1]=su[i];
    }
}
void dp()
{
    for(int j=2;j<=m;j++)
    {
        for(int i=j;i<=n;i++)
        {
            f[i][j]=999999999;
            for(int k=j;k<=i;k++)
            {
                f[i][j]=min(f[i][j],max(f[k-1][j-1],su[i]-su[k-1]));
            }
        }
    }
}
void print(int l,int r)
{
    int da=0;
    for(int i=r;i>=l;i--)
    {
        if(da+a[i]>f[n][m])
        {
            print(l,i);
            printf("%d %d\n",i+1,r);
            return ;
        }
        da+=a[i];
    }
    printf("%d %d\n",l,r);
    return ;
}
int main()
{
    read(),dp();
    print(1,n);
    return 0;
}
```

---

## 作者：ShineEternal (赞：2)

【问题分析】
       本题可以用动态规划解决，设f(k,m)为前m本书交由k个人抄写，需要的最短时间，则状态转移方程为  
       
       f[k][m]=min{max{f[k-1][i],Σ}, i=1, 2, …, m-1}

       动态规划求出的仅仅是最优值，如果要输出具体方案，还需根据动态规划计算得到的最优值，做一个贪心设计。具体来说，设最优值为T，那么k个人，每个人抄写最多T页。从最后一本书开始按逆序将书分配给k人去抄写，从第k个人开始，如果他还能写，就给他；否则第k个人工作分配完毕，开始分配第k-1个人的工作；以后再是第k-2个、第k-3个、……直至第1个。一遍贪心结束后，具体的分配方案也就出来了。
       
**by 一本通**(养成写明出处的好习惯)
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int max1(int,int);
int print(int,int);
int x,y,i,j,m,n,k,t,l;
int a[501],f[501][501],d[501];
int main()
{
  cin>>m>>k;
  for (i=0;i<=500;i++)
   for (j=0;j<=500;j++)
    f[i][j]=10000000;  
  for (j=1;j<=m;j++)
   {
     cin>>a[j];                           //输入m本书的页数
     d[j]=d[j-1]+a[j];                      //d[j]为前j本书总的页数
     f[1][j]=d[j];                          //f[i][j]为一个人抄前j本书所需时间
   } 
  for (i=2;i<=k;i++)               //f[k][m]为前m本书交由k个人抄写，需要的最短时间
   for (j=1;j<=m;j++)
    for (l=1;l<=j-1;l++)
     if (max1(f[i-1][l],d[j]-d[l])<f[i][j]) 
      f[i][j]=max1(f[i-1][l],d[j]-d[l]);
}
 print(m,k);                             //从第k个开始分配抄写方案

int max1(int x,int y)                         //求x和y中最大值
{
  if (x>y) return x; else return y;    
}
int print(int i,int j)                           //递归输出抄写页数的方案
{
    int t,x;
    if (j==0) return 0;
    if (j==1)                               //第1个人抄写1到i本书
     {
        cout<<1<<" "<<i<<endl;
        return 0;     
     }
    t=i;x=a[i];
    while (x+a[t-1]<=f[k][m])  //从最后一本书按逆序分配第j个人抄写，只要能写，就给他
     {
       x+=a[t-1];
       t--;   
     } 
    print(t-1,j-1);             //用递归过程给第j-1个人分配抄写方案，这时只有t-1书了
    cout<<t<<" "<<i<<endl;    //递归返回时输出，因为递归过程是最后1个人先分配抄书
} 
```

---

## 作者：doby (赞：2)

f[i][j]表示第i个人抄到第j页时的最优解

状态转移方程:f[i][j]=min(f[i][j],max(f[i-1][l],d[j]-d[l]))

```cpp
#include<cstdio>
using namespace std;
int m,k,a[509],d[509],f[509][509],out,fh;
char cc;
int read()
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
int max(int a,int b)
{
    if(a>b){return a;}
    else{return b;}
}
int min(int a,int b)
{
    if(a<b){return a;}
    else{return b;}
}
```
/\*以上是毫无卵用系列\*/
```cpp
void print(int i,int j)//递归找最优解
{
    if(j==0){return;}
    if(j==1)
    {
        printf("1 %d\n",i);//第一个人只能从第一页抄
        return;
    }
    int t=i,x=a[i];
    while(x+a[t-1]<=f[k][m])
    {
```
t--,
```cpp
        x=x+a[t];
    }
    print(t-1,j-1);//因为倒着输出，先递归后输出
    printf("%d %d\n",t,i);
}
int main()
{
    m=read(),k=read();
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=233333333;
        }
    }
    for(int i=1;i<=m;i++)
    {
        a[i]=read(),
        d[i]=d[i-1]+a[i],//前缀和
        f[1][i]=d[i];//第一个人抄的最时间固定
    }
    for(int i=2;i<=k;i++)
    {
        for(int j=1;j<=m;j++)
        {
            for(int l=1;l<j;l++)
            {
                f[i][j]=min(f[i][j],max(f[i-1][l],d[j]-d[l]));//转移
            }
        }
    }
    print(m,k);
    return 0;
}
```

---

## 作者：ysner (赞：2)

此题可用二分答案。

如果这个时间点（mid）刚好可以满足：每个人都有活干，每本书都复制完了，每个人花的时间都不超过mid，那么，就是一个合法解，记录一下，然后再看有没有更小的值，即可。

怎么判断是否合法呢？

我们可以按照这个时间点模拟。

因为题目要求：前面的人少干活。所以我们要让后面的人多干一些活。

又因为题目要求：必须连着抄，

所以，我们只需要一股脑地把书塞给排名靠后的人，只要花的时间不超过mid，那么，你就干活去吧！

这样就可以保证前面的人最少了。

但是，如果不合法呢？

就说明这时间不够用，还需要每个人干更重的活！

说了这么多，就详见代码吧：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>  
using namespace std;  
int ans[666],n,m,book[666],sum,now_ans[666];  
//ans[i]表示第i个人抄的书的开始序号  
bool check(int mid)  
{  
    int who=1,now=m,worked=0;  
    while(who<=n and now>=1)//枚举每个人who，每本书now  
    {  
        worked=0,now_ans[who]=now;//worked是此人花费的时间  
        while(worked+book[now]<=mid and now>=1)//为此人分配任务  
            worked+=book[now],now--;  
        //如果抄了这本书，没有超过时限的话，就抄吧！  
        who++;//此人任务分配完毕，换下一个人  
    }  
    if(who<=n+1 and now==0) return 1;  
    else return 0;  
}  
void double_cut(int l,int r)  
{  
    int mid=(l+r)/2;  
    if(l>r) return;  
    if(check(mid))  
    {  
        for(int i=1;i<=n;i++) ans[i]=now_ans[i];  
        double_cut(l,mid-1);  
    }  
    else double_cut(mid+1,r);  
}  
int main()  
{  
    scanf("%d %d",&m,&n);  
    for(int i=1;i<=m;i++)  
    {  
        scanf("%d",&book[i]);  
        sum+=book[i];  
```
}//读入每本书需要的时间
```cpp
    double_cut(1,sum);//开始二分答案  
    for(int i=n;i>=1;i--)   
    {  
        printf("%d %d",ans[i+1]+1,ans[i]);  
        if(i!=1) printf("\n");//处理多余空格  
    }  
   return 0;
}
```

---

## 作者：EarthGiao (赞：1)

## 【思路】
二分答案    

### 【吐槽】 
二分答案模板题目    
但他的输出却很恶心人    
因为要让后面的人尽量多抄的嘛   
所以就要从后往前枚举    
这样才能让后面的人尽量多抄    
但是输出的时候却是从1-k依次输出每个人到底抄哪个范围内的书    
所以很讨厌    

### 【核心思路】
这是让抄的页数最多的人抄的最少    
最大值最少     
所以二分答案为什么要用就很显然了    
二分抄的最多那个人抄了多少   
然后从后往前枚举    
check一下是不是满足在抄的最多的那个人抄的页数小于等于二分出来的这个数的情况下    
可以被小于等于k个人抄完    
如果能就返回真   
反之返回假    
这样就可以轻轻松松的二分一下一下了     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;
const int Max = 505;
int a[Max];
int xx[Max],yy[Max];
int k,m;
bool check(int x)
{
	int tot = 0;
	int js = 0;
	for(register int i = m;i >= 1;i --)
	{
		if(a[i] > x)
			return false;
		tot += a[i];
		if(tot > x)
		{
			if(js == k - 1)
				return false;
			else
				tot = a[i],js ++;
		}
		if(js == k && i != 1)
			return false;
	}
	return true;
}

int main()
{
	int tot = 0;
	cin >> m >> k;
	for(register int i = 1;i <= m;++ i)
		cin >> a[i],tot += a[i];
	int l = 0,r = tot;
	while(l < r)
	{
		int mid = (r + l) >> 1;
		if(check(mid))
			r = mid;
		else
			l = mid + 1;
	}
	yy[k] = m;
	int sum = k;
	int ans = 0;
	a[0] = 9999999;
	for(register int i = m;i >= 0;i --)
	{
		ans += a[i];
		if(ans > l)
		{
			ans = a[i];
			xx[k] = i + 1;
			k --;
			yy[k] = i;
		}
	}
	for(register int i = 1;i <= sum;++ i)
		cout << xx[i] << " " << yy[i] << endl;
	return 0;
}
```

---

## 作者：666DHG (赞：1)

这道题可以用DP，也可以用二分搜索

假如二分还是不太懂的话可以看[这里](https://www.luogu.org/blog/666DHG/Solution005-SP2715)

其实这道题的重点在于**输出**

我是这样想的：

1. 从后往前查，减少前面的工作量

2. 定义一个变量$\text{ }last\text{ }$来记录下一个人结束的书本编号（不懂的话看代码）

完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,l,r,mid,a[505],t1[505],t2[505],ans1[505],ans2[505];

bool check(int x)
  {
  	int cnt=1,t=0,last=n;
  	for (int i=n;i>=1;i--) //为了让前面的人抄得越少越好,所以从后往前推 
  	  {
  	  	if (a[i]>x) return false; //如果单本书的时间都比限时要大,就直接退出 
  	  	if (t+a[i]>x)
  	  	  {
  	  	  	t1[cnt]=i+1,t2[cnt]=last; //存第 m-cnt+1 个人的誊写范围 
  	  	  	cnt++,t=a[i];
  	  	  	last=i; //下一个人要誊写到第 i 本书 
		  }
  	  	else t+=a[i];
	  }
	if (cnt>m) return false;
	t1[cnt]=1,t2[cnt]=last; //存第 1 个人的誊写范围 
	for (int i=cnt+1;i>=1;i--) ans1[i]=t1[i],ans2[i]=t2[i]; 
	return true;
  }

int main()
  {
  	ios::sync_with_stdio(false);
  	cin.tie(0);
  	cin>>n>>m;
  	for (int i=1;i<=n;i++) cin>>a[i],r+=a[i]; //右边界为全部时间的和 
  	if (m==1) //如果只有一个人就让他抄全部 
  	  {
  	  	cout<<"1 "<<n<<"\n";
  	  	return 0;
	  }
  	while (r-l>1) //二分:最大值最小 
  	  {
  	  	mid=(r+l)>>1;
  	  	if (check(mid)) r=mid;
  	  	else l=mid;
	  }
	for (int i=m;i>=1;i--) cout<<ans1[i]<<" "<<ans2[i]<<"\n";
	return 0;
  }
```

---

## 作者：曹有毒 (赞：1)

小蒟蒻第一次写题解

欢迎私信指教


个人觉得还算是一道比较经典的二分答案


代码：

- 定义变量

int ye[500+1];       \_  //第i本书的页数\_

int m,k;

int ans[500+1][3];    \_//第i个人 从第ans[i][1]本书 抄到第 ans[i][2]本书\_

- 读入

```cpp
    cin>>m>>k; 
    int l=1,r=0;             _ //定义二分的左右端点_
    for(int i=1;i<=m;++i)
    {
    scanf("%d",&ye[i]);
    r+=ye[i];           _  //右端点的计算_
    }
```
- 二分  得到一个人抄写的最大页数
        

              
                 
```cpp
 while(l<r)
    {
        int mid=(l+r)/2;
        if(can(mid))                 _  //can是判断当前值能不能作为答案的函数 返回值bool_
            r=mid;
        else 
            l=mid+1;
    }   
bool can(int x)                       //x为每个人抄写的最大页数            
{
    int shu=1;   //shu为抄完所有书所需人数                    
    int nextbook=m;   //下一本抄哪本书    从m到1   从1到m也可以
    while(1)
    {
        int now=x;    //目前这个人抄写的页数 
        while(now-ye[nextbook]>=0)            //每个人抄写的页数不能超过x  如果加上下一本书之后超过了x（即now-ye[nextbook]<0）  那么需要的人数+1  写在后面了（shu++）  
        {
            now-=ye[nextbook];
            nextbook--;    
            if(nextbook<1&&shu<=k)return 1;           //如果书抄完了  此时需要的人数小于等于k  那么x是一个可以成立的答案值    但不一定是最优  返回true
        }
        shu++;       
        if(shu>k)return 0;    //如果需要的人数比k多 说明x不可以作为答案
    }
}
```
- 根据之前得到的最大页数  计算每个人抄写哪几本书
- 因为要让前面的人抄写的尽量少  所以从最后一个人开始数

int maxx=l;      //maxx就是前面得到的最大抄写页数


```cpp
    int nextbook=m;   //从最后一本书开始
    ye[0]=2147483647;      //这个不加的话  会导致第一个人从”-1“本书开始抄 我也不知道怎么解释好
    for(int i=k;i>=1;--i)          //与之前的can类似
    {
        int now=maxx;    //目前这个人抄写的页数
        ans[i][2]=nextbook; 
        while(now-ye[nextbook]>=0)  
        {
            now-=ye[nextbook];
            nextbook--;    
        } 
        ans[i][1]=nextbook+1;
    } 
```
- 输出答案

 for(int i=1;i<=k;++i)

        printf("%d %d\n",ans[i][1],ans[i][2]);

完

---

## 作者：jhsg (赞：1)




    
    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int m,k;
int haha[500][2],p[500][2],a[500];
bool check(int x)//若一个人至多抄mid页，所需人数，若大于k,返回0，反之返回1// 
{
    int s=0,t=1;
    p[k-1][1]=m-1;p[0][0]=0;//初始化，否则头尾无法标记// 
    for(int i=m-1;i>=0;i--)
    {
        s+=a[i];
        if (s>x)
        {
            t++;
            if (t>k) return 0;
            p[k-t+1][0]=i+1;//即每一行输出的首个输出// 
            p[k-t][1]=i;//即每一行输出的第二个输出//
            s=a[i];
        }
    }
    memcpy(haha,p,sizeof(int)*(k*2));//复制// 
    return 1;
}
int main()
{
    scanf("%d %d",&m,&k);
    int max=0;
    for(int i=0;i<m;i++)
    {
        scanf("%d",&a[i]);
        if (a[i]>max) max=a[i];//取最大数// 
    }
    if (k>=m)
    {
        for(int i=0;i<m;i++) printf("%d %d\n",i+1,i+1);
        return 0;    
    }    //贪心算法一部分，如果人数多于书本数，直接输出。// 
    if (k==1)
    {
        printf("1 %d",m);
        return 0;    
    }   //如果只有一个人，直接输出// 
    int sum=0;
    for(int i=0;i<m;i++) sum+=a[i];//求和（天数在最大数与和之间）// 
    int r=sum;
    for(int i=0;i<k;i++) r-=a[i]; //每一个人都至少抄一本书，即最多抄m-k+1，可节省时间，但可省// 
    int l=max,mid,ans;
    while(l<=r)//二分法// 
    {
        mid=(r+l)/2;
        if (check(mid)){ans=mid;r=mid-1;}//如果mid满足条件，ans指向mid,在mid左边查找是否有比mid小的// 
        else l=mid+1;//反之查mid右是否有满足条件的数// 
    }
    for(int i=0;i<k;i++) printf("%d %d\n",haha[i][0]+1,haha[i][1]+1);
    return 0;
}
```

---

## 作者：zclzslz (赞：1)

思路：二分+贪心

首先，二分一个r，但这个r并不是最大值的最小值。

那些认为自己二分的是最大值的最小值的同胞们，可以试一下这一组数据：

10 5
10 8 4 5 2 34 4 5 2 4

在这组数据中，二分出来的答案是15，但是我们发现，其中有一页书的页数竟然是34！这样一来因为书不能被分开抄写，所以实际我们应该抄写的最大页数的最小值应该是34，但却是15！

这与贪心思路有关。对于一个值r，我们总是从n~1循环能放就放，这样一来，34放出来的组数会比5小（放3组），所以会往小的方向二分。

这里二分出来的r，应该是满足分成k组的各种方案中最优的r，即使前面的人抄的少的r。

其实这里的r不必仔细深究，我的想法也可能会很SB，但提出这个问题的原因，主要是一直A不了，然后很颓，随便出了一组数据，结果发现了这个问题，随便说说而已。

不多说了，下面，贴上代码，和楼下的思路基本一样（这道题比较简单）

```cpp
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,k;
int a[1005];
int l=1,r=0;
struct p
{
        int x,y;
}ans[10005];
int tot(0);
void handle()
{
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++)
    {
            scanf("%d",&a[i]);
            r+=a[i];//定好边界
    }
    while(l<r)
    {
        int mid=(l+r)/2;
        int now(0);
        int times(0);
        for(int i=n;i>=1;i--)
        {
            now+=a[i];
            if(now>mid)
            {
                times++;
                now=a[i];
            }
        }
        if(now)times++;
        if(times<=k)
        {
            r=mid;
        }
        else
        if(times>k)
        {
            l=mid+1;
        }
    }
    int now(0);//处理答案
    for(int i=n;i>=1;i--)
    {
        now+=a[i];
        if(now>r)
        {
            tot++;
            ans[tot].x=i+1;//左边界等于i+1，这个不解释，因为倒叙循环
            if(tot==1)
            ans[tot].y=n;//如果是第一个，那么右边界等于n
            else
            ans[tot].y=ans[tot-1].x-1;//不是的话就等于上一个的左边界-1
            now=a[i];
        }
    }
    if(now)
    {
        tot++;
        ans[tot].x=1;
        if(tot==1)
        ans[tot].y=n;
        else
        ans[tot].y=ans[tot-1].x-1;
    }                                 
    for(int i=tot;i>=1;i--)
    printf("%d %d\n",ans[i].x,ans[i].y);//输出来
    return ;
}
int main()
{
    handle();
    return 0;
}
```

---

## 作者：Kwork (赞：1)

很明显答案是单调的，所以可以采取二分，每次验证是否合法知道l=r。效率大概【nlogn】，比DP好，(PS：才不是DP写起来太难了)

先贴个90分的题解。

```cpp

#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn=1000;
int n,m,book[maxn];
int l,r,mid,ans;

void write(){//统计每个人的抄写的过程倒着来，能抄就抄，不能抄就换下一个人。记录起始与终止点。
    int out[maxn][2];
    int cnt=n,now=ans;
    for(int i=m;i>=1;i--){
        out[i][2]=cnt;
        while(now-book[cnt]>=0){
            now-=book[cnt];
            cnt--;
            if(cnt==0) break;
        }
        out[i][1]=cnt+1;
        now=ans;
    }
    for(int i=1;i<=m;i++)
        cout<<out[i][1]<<" "<<out[i][2]<<endl;
}
bool check(int now){//统计满足二分的now所需的抄写员个数，如果超过了，那么说明无法满足，答案不合法。
    int tool=1;
    int tot=0;
    for(int i=1;i<=n;i++){
        if(tot+book[i]>now){
            tool++;
            tot=book[i];
        }
        else
            tot+=book[i];
    }
    if(tool>m) return false;
    return true;
}
void solve(){
    while(r>l){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    ans=l;
    write();
    return;
}
int main(){
    freopen("book.in","r",stdin);
    freopen("book.out","w",stdout);
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    l=0;r=0;
    for(int i=1;i<=n;i++){
        cin>>book[i];
        r+=book[i];
    }
    solve();
    return 0;
}

```
题目要求我们前面的人尽量抄的少，那么，在二分的check过程中也要注意书的枚举要倒着来。否则会导致一个点WA。

至于为什么这样，我也不知道。

```cpp

#include <cstring>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxn=1000;
int n,m,book[maxn];
int l,r,mid,ans;

void write(){
    int out[maxn][2];
    int cnt=n,now=ans;
    for(int i=m;i>=1;i--){
        out[i][2]=cnt;
        while(now-book[cnt]>=0){
            now-=book[cnt--];
            if(cnt==0) break;
        }
        out[i][1]=cnt+1;
        now=ans;
    }
    for(int i=1;i<=m;i++)
        cout<<out[i][1]<<" "<<out[i][2]<<endl;
}
bool check(int now){
    int tool=1;
    int tot=0;
    for(int i=n;i>=1;i--){
        if(tot+book[i]>now){
            tot=book[i];
            tool++;
        }
        else
            tot+=book[i];
    }
    if(tool>m) return false;
    return true;
}
void solve(){
    while(r>l){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    ans=l;
    write();
    return;
}
int main(){
    freopen("book.in","r",stdin);
    freopen("book.out","w",stdout);
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    l=0;r=0;
    for(int i=1;i<=n;i++){
        cin>>book[i];
        r+=book[i];
    }
    solve();
    return 0;
}

```

---

## 作者：Skywalker_David (赞：1)

本题可以用动态规划解决，设F（k，m）为前m本书交由k个人抄写，需要的最短时间，则状态转移方程为：f（k，m）=min{max{f[k-1,i],Tj},i=1,2,```,m-1}

【标程】:
```delphi


```cpp
var
    i,j,m,k,l:longint;
    a,d:array[0..500] of longint;
    f:array[0..500,0..500] of longint;
function max(x,y:longint):longint;
begin
    if x>y then max:=x else max:=y;
end;
procedure print(i,j:longint);
var
    t,x:longint;
begin
    if j=0 then exit;
    if j=1 then begin
        writeln(1,' ',i);
        exit;
    end;
    t:=i;
    x:=a[i];
    while x+a[t-1]<=f[k,m] do begin
        x:=x+a[t-1];
        dec(t);
    end;
    print(t-1,j-1);
    writeln(t,' ',i);
end;
begin
    readln(m,k);
    fillchar(f,sizeof(f),$7f);
    fillchar(d,sizeof(d),0);
    for j:=1 to m do begin
        read(a[j]);
        d[j]:=d[j-1]+a[j];
        f[1,j]:=d[j];
    end;
    for i:=2 to k do
        for j:=1 to m do
            for l:=1 to j-1 do
                if max(f[i-1,l],d[j]-d[l])<f[i,j] then f[i,j]:=max(f[i-1,l],d[j]-d[l]);
    print(m,k);
end.
```
```cpp

---

## 作者：darkgodz (赞：1)

这道题应该是DP+贪心或者二分+贪心，DP或二分求出来分段和的最大值的最小值（方法和“数列分段section2”一样），主要说贪心。


设求出来的最大值的最小值是lim，由于题目要求“尽可能让前面的人少抄写”，所以从最后一个人倒序贪心，从当前还没有抄的最后一本书开始往前算，直到这些书的页数的和超过lim，跳出循环，并且保存当前第i个人的答案


```cpp

a[0]=2147483647;//对a[0]初始化，意义结合下面程序理解
int now=n;//now表示当前还没有抄的最后一本书，最开始是最后一本
for (int i=k; i>=1; i--)
    {
        int sum=0;//累加变量
        for (int j=now; j>=0; j--)//循环到0的原因自行思考
        {
                   sum+=a[j];
            if (sum>lim) 
                        {
                                ansleft[i]=j+1;//第j本超过上限，说明第j+1本是第i个人能抄到的最靠前的书
                        ansright[i]=t;//第i个人从第j+1本书抄到第t本书
                        now=j;//当前没有被抄的最后一本是第j本
                                break;//超过上限，跳出循环
                        }      
        }
        
}

---

## 作者：yangshirui (赞：1)

【问题分析】

本题可以用动态规划解决，设f(k,m)为前m本书交由k个人抄写，需要的最短时间，则状态转移方程为

f[k][m]=min{max{f[k-1][i],          }, i=1, 2, …, m-1}


动态规划求出的仅仅是最优值，如果要输出具体方案，还需根据动态规划计算得到的最优值，做一个贪心设计。具体来说，设最优值为T，那么k个人，每个人抄写最多T页。从最后一本书开始按逆序将书分配给k人去抄写，从第k个人开始，如果他还能写，就给他；否则第k个人工作分配完毕，开始分配第k-1个人的工作；以后再是第k-2个、第k-3个、……直至第1个。一遍贪心结束后，具体的分配方案也就出来了。


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int max1(int,int);
int print(int,int);
int x,y,i,j,m,n,k,t,l;
int a[501],f[501][501],d[501];
int main()
{
  cin>>m>>k;
  for (i=0;i<=500;i++)
   for (j=0;j<=500;j++)
    f[i][j]=10000000;  
  for (j=1;j<=m;j++)
   {
     cin>>a[j];                           //输入m本书的页数
     d[j]=d[j-1]+a[j];                      //d[j]为前j本书总的页数
     f[1][j]=d[j];                          //f[i][j]为一个人抄前j本书所需时间
   } 
  for (i=2;i<=k;i++)               //f[k][m]为前m本书交由k个人抄写，需要的最短时间
   for (j=1;j<=m;j++)
    for (l=1;l<=j-1;l++)
     if (max1(f[i-1][l],d[j]-d[l])<f[i][j]) 
      f[i][j]=max1(f[i-1][l],d[j]-d[l]);
}
print(m,k);                             //从第k个开始分配抄写方案
int max1(int x,int y)                         //求x和y中最大值
{
  if (x>y) return x; else return y;    
}
int print(int i,int j)                           //递归输出抄写页数的方案
{
    int t,x;
    if (j==0) return 0;
    if (j==1)                               //第1个人抄写1到i本书
     {
        cout<<1<<" "<<i<<endl;
        return 0;     
     }
    t=i;x=a[i];
    while (x+a[t-1]<=f[k][m])  //从最后一本书按逆序分配第j个人抄写，只要能写，就给他
     {
       x+=a[t-1];
       t--;   
     } 
    print(t-1,j-1);             //用递归过程给第j-1个人分配抄写方案，这时只有t-1书了
    cout<<t<<" "<<i<<endl;    //递归返回时输出，因为递归过程是最后1个人先分配抄书
} 

```

---

## 作者：jxpxcsh (赞：0)

【设】

f[i,j]表示前i个人抄前j本书的最小花费时间

s[i]表示前i本书的抄写时间总和。

【方程】

边界1：f[1,i]=s[i]  (1<=i<=m)

边界2：f[i,i]= max(f[i-1,i-1],s[i]-s[i-1])  (2<=i<=k)

f[i,j]=min(s[j]-s[t],f[i-1,t])  (2<=i<=k，i+1<=j<=m，1<=t<=j-1)

本题可以用四边形不等式优化。

【方案输出】

在我们的到最优值f[k,m]后，我们可以根据这个时间，贪心求出每个人的抄写时间，每个人花费时间的上限为f[k,m]

【源程序】

```delphi

Program book;
Var
   f,g:array[0..500,0..500]of longint;
   a:array[0..500]of longint;
   m,k:longint;
   i,j,t:longint;
   s:array[0..500]of longint;
   ans1,ans2:array[1..500]of longint;y:longint;
function max(a,b:longint):longint;
   begin if a>b then exit(a)else exit(b);end;
Begin
readln(m,k);
for i:=1 to m do
   begin read(a[i]);s[i]:=a[i]+s[i-1];end;
for i:=1 to m do f[1,i]:=s[i];
for i:=2 to k do f[i,i]:=max(f[i-1,i-1],s[i]-s[i-1]);
for i:=2 to k do
   for j:=i+1 to m do
      begin
      f[i,j]:=maxlongint;
      for t:=1 to j-1 do
         if max(s[j]-s[t],f[i-1,t])<=f[i,j] then
            f[i,j]:=max(s[j]-s[t],f[i-1,t]);
      end;
a[0]:=maxlongint div 3; t:=m;
for i:=k downto 1 do
   begin
   y:=0;
   for j:=t downto 0 do
      begin
      inc(y,a[j]);
      if y>f[k,m] then break;
      end;
   ans1[i]:=j+1;ans2[i]:=t;
   t:=j;
   end;
for i:=1 to k do writeln(ans1[i],' ',ans2[i]);
End.

```
from网络，来源：http://zhurui250.blog.163.com/blog/static/1372705202010497142226/


---

## 作者：JosephDai (赞：0)

	这道题，二分的部分十分简单，但输出就有点困难了
    我看了看题解，大佬们用的都是递归输出，高级是高级，但是太难理解
    我的想法：既然是有多种情况时，越前面花费的时间越少，那自然是越后面的值越大，也就是越靠近最大值ans。
    所以这道题就很简单了——先二分求出最小的最大值ans，再倒序枚举这n个数，用数组存储每一组的下标，最后倒序输出下标数组（因为负负得正hhh）
    最后贴上ac代码
    
    
   
   ```cpp
#include <iostream>
using namespace std;
int l,r;
int n,m;
int ans;
int le[100001],ri[100001];
int a[100001];
bool check(int mid){
	int sl=1;
	int sum=0;
	for(int i=1;i<=n;i++){
		sum+=a[i];
		if(a[i]>mid){
			return 0;
		}
		if(sum>mid){
			sum=a[i];
			sl++;
		}
	}
	return sl<=m;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		r+=a[i];
	}
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}
		else{
			l=mid+1;
		}
	}
	int sum=0;
	int cnt=1;
	for(int i=n;i>=1;i--){
		sum+=a[i];
		if(sum>ans){
			sum=a[i];
			le[cnt]=i+1;
			cnt++;
			ri[cnt]=i;
		}
	}
	le[m]=1;
	ri[1]=n;
	for(int i=m;i>=1;i--){
		cout<<le[i]<<" "<<ri[i]<<endl;
	}
	return 0;
}
```


---

## 作者：不存在之人 (赞：0)

思路

既然是让求每个人抄写的书数，其实也就是求所有人抄写页数中的最大值，我们只要保证前面的人抄写的页数尽量最少即可，故我们可以从后往前遍历，让后面的人尽量多复制几本。其中，抄写的页数是关键，我们可以利用二分来实现遍历。
```cpp
#include<cstdio>
using namespace std;
int a[505];
int m,k;
bool judge(int x)
{
	int sum=0,num=0;
	for(int i=m;i>=1;i--)
	{
		sum+=a[i];
		if(sum>x)
		{
			num++;
			sum=a[i];
		}
	}
	num++;
	return num<=k; 
}
struct node
{
	int l,r;
}s[505];
int main()
{
	scanf("%d%d",&m,&k);
	int sum=0,i,num;
	for(i=1;i<=m;i++)
	{
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	int l=0,r=sum;
	while(r>=l)
	{
		int mid=(l+r)/2;
		if(judge(mid))r=mid-1;
		else l=mid+1;
	}
	sum=0,num=m;
	int p=k;
	for(int i=m;i>=1;i--)
	{
		sum+=a[i];
		if(sum>l)
		{
			sum=a[i];     
			s[p].l=i+1;s[p--].r=num;
			num=i;
		}
	}
	s[1].l=1;s[1].r=num;
	for(int i=1;i<=k;i++)
		printf("%d %d\n",s[i].l,s[i].r);
	return 0;
}
```

---


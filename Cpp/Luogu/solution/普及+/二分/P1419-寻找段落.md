# 寻找段落

## 题目描述

给定一个长度为 $n$ 的序列 $a$，定义 $a_i$ 为第 $i$ 个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在 $[S, T]$ 之间的连续序列。最有价值段落是指平均值最大的段落。

**段落的平均值** 等于 **段落总价值** 除以 **段落长度**。

## 说明/提示

【数据范围】

对于 $30\%$ 的数据有 $n \le 1000$。

对于 $100\%$ 的数据有 $1 \le n \le 100000$，$1 \le S \le T \le n$，$-{10}^4 \le a_i \le {10}^4$。

【题目来源】

tinylic 改编


## 样例 #1

### 输入

```
3
2 2
3
-1
2
```

### 输出

```
1.000```

# 题解

## 作者：kkksc03 (赞：190)

By tinylic

首先看出答案满足单调性，可以二分答案，转化为判定性问题。

令最优平均值为k,对于所有合法序列[l..r],


尝试将分式变为整式：s[l..r]＞k\*(r-l+1)无解。

移项，令b[i]=a[i]-k，s’[i]为b[1]..b[n]的和，则有


寻找长度在[s,t]内的子段和的最大值可以用单调队列解决，参考POJ2823。

这样就能通过O(n)的时间判定k是否可行，总复杂度O(nlogn)。

具体实现的细节参考标程。

```cpp


#include <iostream>
#include <cstdio>
#include <cstdlib>
#define maxn 100010

using namespace std;

int n, s, t, i;
double l, r, mid, ans;
double a[maxn];
int b[maxn];
double sum[maxn];
int q[maxn];

bool check(double x) {
    int i, l = 1, r = 0;
    for (i = 1; i <= n; i++)
        a[i] = (double)b[i] - x;
    sum[0] = 0;
    for (i = 1; i <= n; i++)
        sum[i] = sum[i - 1] + a[i];
    for (i = 1; i <= n; i++) {
        if (i >= s) {
            while (r >= l && sum[i - s] < sum[q[r]])    r--;
            q[++r] = i - s;
        }
        if (l <= r && q[l] < i - t) l++;
        if (l <= r && sum[i] - sum[q[l]] >= 0) return true;
    }
    return false;
}

int main() {

    scanf("%d", &n);
    scanf("%d%d", &s, &t);
    for (i = 1; i <= n; i++)
        scanf("%d", &b[i]);
    ans = l = -10000; r = 10000;
    while (r - l > 1e-5) {
        mid = (l + r) / 2;
        if (check(mid))
            ans = l = mid;
        else r = mid;
    }

    printf("%.3lf\n", ans);
    return 0;
}


```

---

## 作者：抽空的太阳 (赞：117)

思路：

首先二分答案，即：二分最大平均值。

我们将a全部减去mid，问题转化为判断是否存在一个长度在s~t范围内的区间它的和为正，如果有说明还有更大的平均值。

用前缀和和单调队列维护。

然后用单调队列求出sum[i]-min(sum[i-t]~sum[i-s]),然后判断是否大于0即可。

核心代码：

```cpp
bool can(double mid)
{
    for(int i=1;i<=n;i++)
    sum[i]=sum[i-1]+double(a[i])-mid;
    int head=1,tail=0,q[maxn];
    for(int i=s;i<=n;i++)
    {
        while(head<=tail&&sum[q[tail]]>sum[i-s]) tail--;
        q[++tail]=i-s;
        while(head<=tail&&q[head]<i-t) head++;
        if(head<=tail&&sum[i]-sum[q[head]]>=0) return 1;
    }
    return 0;
}
```

---

## 作者：Remake_ (赞：43)

前缀和优化的暴力大家都会吧，复杂度$\operatorname{O}(n^2)$。

但是这样显然会超时，怎么办？

于是我们可以在```for```语句中添加``` (double)clock() / CLOCKS_PER_SEC <= 0.95```来让程序在跑完$0.95s$之后直接退出循环然后输出此时的最优解。

为啥这个做法可行呢？因为依照贪心的思路我们选择段落长度越小，平均值越容易做到最大（这个思路在大多时候是对的），所以我们从最小的段落长度开始枚举，时间快跑完的时候停止，有非常大概率是对的。

贼短的Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, s, t, a[100005], qzh[100005];
double maxx = -0x7fffffff;
int main()
{
    cin >> n >> s >> t;
    for (register int i = 1; i <= n; i++)
        cin >> a[i];
    for (register int i = 1; i <= n; i++)
        qzh[i] = qzh[i - 1] + a[i];
    for (register int i = s; i <= t && (double)clock() / CLOCKS_PER_SEC <= 0.95; ++i)
        for (register int j = i; j <= n; ++j)
            maxx = max(maxx, (qzh[j] - qzh[j - i]) / (1.0 * i));
    printf("%.3f", maxx);
}
```

或许可以被神仙数据卡掉？


---

## 作者：Harry27182 (赞：24)

首先，最朴素的暴力就是枚举长度和左端点，然后把中间的数加在一起除以长度再取最大值。时间复杂度 $O(n^3)$ ,妥妥 TLE 。

我们考虑前缀和优化暴力枚举，可以优化到 $O(n^2)$ 。但是它仍然是不够优秀的，所以，我们可以在程序前面加一个卡时，这个东西就是在跑了 $0.95s$ 后跳出程序。然后，我们可以神奇的发现，这就过了。这个之所以能过是因为我们长度是从小到大搜的，长度小的时候容易取最大值（不信可以自己推一下），所以这种思路，有很大概率是对的。

# AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r;
double a[100005],sum[100005];
double ans;
int main()
{
	scanf("%d",&n);
	scanf("%d%d",&l,&r);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	for(int k=l;k<=r;k++)
	{
		if(double(clock())/CLOCKS_PER_SEC>0.99)break;
		for(int i=1;i+k<=n;i++)
		{
			if((sum[i+k-1]-sum[i-1])/(double)k>ans)ans=(sum[i+k-1]-sum[i-1])/(double)k;
		}
	}
	printf("%.3lf",ans);
	return 0;
}
```


---

## 作者：山蛙or山兔 (赞：23)


二分平均值，然后判断是否存在S~T的区间和大于0，这个转换就不解释了。

关于单调队列的构建，可以更深入的理解一下:
对于一个终止点为i，起始点为i-t到i-s的区间都是合法的区间，然后这些合法的区间里，设L为区间长度，S为区间和，如果L1>L2且S1<=S2,那么区间1就没有意义了，可以删除。

这样就能保证队列最前面的区间一定是值最大且合法的，每个i能找到以i为终止点的最大合法区间，答案自然就出来了。

代码如下：

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <queue>
#define eps 1e-6
#define INF 0x3f3f3f3f
#define maxn 100010
using namespace std;

int n,s,t,q[maxn];
double arr[maxn],sum[maxn];

int solve(double m)
{
	int l=1,r=0;
	sum[0]=0;
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+arr[i]-m; 
	for (int i=s,p=0;i<=n;i++,p++)
	{
		while (l<=r && sum[q[r]]>sum[p]) r--;
		q[++r]=p;
		if (i-q[l]>t) l++;
		if (sum[i]-sum[q[l]]>eps) return 1;
	}
	return 0;
}

int main()
{
	cin >> n >> s >> t;
	for (int i=1;i<=n;i++) cin >> arr[i];
	double l=-10000,r=10000; 
	while (r-l>eps)
	{
		double m=(l+r)/2;
		if (solve(m)) l=m;
		else r=m;
	}
	printf("%.3lf\n",l);
	return 0;
}
```


---

## 作者：Space_Gold_Trash (赞：18)

比较明显的二分答案

我们二分枚举最后的结果

很显然是满足单调性的

那关键就是```check```函数了


这题要用前缀和,很显然,对于当前的**i**这个位置,我们必须在前**t**个前缀和中最小的一个，设其为**j**,然后```sum[i]-sum[j]```便是前缀和最大的那一个

第一印象是数据结构,但是他的复杂度是$O(nlogn)$，貌似可以过,但我们还有更优的方法

我们可以考虑在查找最大值那里做文章

我们可以用队列来维护最优值

很显然,对于

$sum[i]>sum[j]\&i<j$

                   
第**i**个是没什么用的,所以我们可以
                   
```
while(r>=l&&sum[q[r]]>sum[p])--r;
```   

很显然,队首是最小的

当前最大便是```sum[i]-sum[q[l]]```

但是万一这个序列长度大于**T**了呢?

那么我们需要维护长度

```
while(i-q[l]>T)++l;
```

代码

```
#include<bits/stdc++.h>
#define N 100101
#define il inline
using namespace std;
int n;
int S,T,a[N];
double sum[N];
int q[N];
il bool check(double k){
	int i,l=1,r=0,p;
	for(i=1;i<=n;++i)sum[i]=sum[i-1]+a[i]*1.0-k;
	for(i=S,p=0;i<=n;++i,++p){
		while(r>=l&&sum[q[r]]>sum[p])--r;
		q[++r]=p;
		while(i-q[l]>T)++l;
		if(sum[i]-sum[q[l]]>=0)return 1;
	}
	return 0;
}
int main( ){
	scanf("%d%d%d",&n,&S,&T);
	int i;
	for(i=1;i<=n;++i)
	scanf("%d",&a[i]);
	double l(-1e4),r(1e4),mid;
	while(r-l>1e-4){
		mid=(l+r)/2;
		if(check(mid))l=mid;
		else r=mid;
	}
	printf("%.3f\n",l);
}
```

---

## 作者：autoint (赞：17)

# 前言
鉴于这题的题解质量~~（连LaTeX公式都没有）~~，我决定再发一篇详细的题解，不仅方便大家，还可以作为我学习单调队列优化dp的小结~~（尽管这题不是dp）~~。
# 分析
题目要求求一个最大的实数$x$，使得某长度在$[S,T]$之间的区间$[L,R]$满足
$$\frac{\sum_{i=L}^{R}a_i}{R-L+1}=x$$
即
$$\sum_{i=L}^{R}a_i=x*(R-L+1)$$
由于答案满足单调性，所以可以二分$x$，转化为判断问题，即判断
$$\sum_{i=L}^{R}a_i\geq x*(R-L+1)$$
$\rightarrow$
$$\sum_{i=L}^{R}\left(a_i-x \right)\geq0$$
对这个式子求前缀和，就可快速算出一段区间的和，令
$$sum_i=\sum_{i=1}^{i}\left(a_i-x \right)$$
则区间$[L,R]$合法的条件为
$$sum_R-sum_{L-1}\geq0$$
转化成这种形式，已经很好做了。维护一个单增的单调队列，然后判断当前遍历元素是否大于等于队首元素即可。
### 时间复杂度
假设数据范围为$A$，则二分答案是$O(\log A)$的，判断一次用了前缀和和单调队列，是$O(n)$的，总时间复杂度为$O(n\log A)$。
# 小优化
题目要求保留3位小数，而对浮点数的操作很麻烦，所以不妨对每个数乘10000（多一位是因为要四舍五入），然后算答案时再除10000.0就行了。
# 代码
用STL的deque实现单调队列，嫌慢手打，使用相同API即可~~（然而这题不卡可以水^_^）~~。
```cpp
#include<iostream>
#include<cstdio>
#include<deque>
#include<cstring>
#define rg register
template<typename T>inline T read(T&x)
{
	T data=0;
	int w=1;
	char ch=getchar();
	while(ch!='-'&&!isdigit(ch))
		ch=getchar();
	if(ch=='-')
		w=-1,ch=getchar();
	while(isdigit(ch))
		data=data*10+ch-'0',ch=getchar();
	return x=data*w;
}
using namespace std;
typedef long long ll;

const int MAXN=1e5+7;
int n,S,T;
int a[MAXN];
ll sum[MAXN]; // prefix sum
int L=1e8,R=-1e8;

deque <int> Q;

inline bool judge(int x)
{
//	cerr<<"judging x="<<x<<endl;
	memset(sum,0,sizeof(sum));
	for(rg int i=1;i<=n;++i)
	{
		sum[i]=sum[i-1]+a[i]-x;
//		clog<<"sum["<<i<<"]= "<<sum[i]<<endl;
	}
	Q.clear();
	for(rg int i=S,p=0;i<=n;++i,++p)
	{ // 只有一段不包括本身的区间内合法，就开两个扫描线
		while(!Q.empty()&&sum[Q.back()]>sum[p])
			Q.pop_back();
		Q.push_back(p);
		while(Q.front()<i-T) // 这里不用判空是因为p一定存在
			Q.pop_front();
		if(sum[i]-sum[Q.front()]>=0)
			return 1;
	}
//	cerr<<"failed"<<endl;
	return 0;
}

int main()
{
	read(n);read(S);read(T);
	for(rg int i=1;i<=n;++i)
	{
		read(a[i]);
		a[i]*=1e4;
//		cerr<<"a["<<i<<"]= "<<a[i]<<endl;
		L=min(L,a[i]);
		R=max(R,a[i]);
	}
	while(L<R)
	{
		int M=(L+R+1)>>1;
		if(judge(M))
			L=M;
		else
			R=M-1;
	}
	printf("%.3f",L/1e4);
}
```
# Hint
最后说一下单调队列的边界问题。合法区间$[L,R]$满足
$$S\leq R-L+1\leq T$$
由于使用前缀和，那么$i$，$p$应满足
$$S+1\leq i-p+1\leq T+1$$
也就是说应弹掉$p<i-T$的那些点。

还有就是二分答案的边界。求最后一个类型应该int M=(L+R+1)>>1;

---

## 作者：Treaker (赞：6)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$

## 二分答案 + 单调队列优化

一看题面，显然是个二分答案。

但是check函数怎么写呢？考虑暴力的话，是$O(n^2)$，时间复杂度不能接受。

肿么办呢？我们肯定要$O(n)$check，而且题里有区间限制，类似于滑动窗口。。

然后按照滑动窗口的做法做就完事了。


完整代码如下：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 100005;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , s , t;
int q[N] , a[N];
double ans;
double sum[N];
bool check(double mid)
{
	memset(q,0,sizeof q);
	for(int i = 1;i <= n;i ++)	sum[i] = sum[i-1] + (double)a[i] - mid;
	int head = 1 , tail = 0;
	for(int i = s;i <= n;i ++)
	{
		while(head <= tail && sum[q[tail]] >= sum[i-s])	tail --;
		q[++tail] = i - s;
		while(head <= tail && q[head] < i - t)	head ++;
		if(head <= tail && sum[i] - sum[q[head]] >= 0)	return 1;	
	}
	return 0;
}
int main()
{
	n = read(); s = read(); t = read();
	for(int i = 1;i <= n;i ++)	a[i] = read();
	double l = -10000.0 , r = 10000.0;
	while(r - l >= 1e-4)
	{
		double mid = (l + r) / 2.0;
		if(check(mid))	ans = mid , l = mid;
		else r = mid;
	}
	printf("%.3f\n",ans);
	return 0;
}
```


---

## 作者：return_CE (赞：5)

## 思路 
### 二分 单调队列
由于数据给的比较大，所以不可以直接爆力求解，只有 $ 30 $ 分。

因为结果具有单调性，而且平均值一定在每个数的最大与最小范围内，所以采用二分求解优化时间复杂度。
## 实现
每一次二分得到值域中点的 $ mid $，将值域分为两半，判断是否有段落的平均值能达到 $ mid $。如果可以，那么对右半部分再次求解，反之求解左侧。直到左右之差满足精度要求后返回结果。

在每次检验中，将每个值减去 $ mid $  后记录前缀和，可以将数据大小减小，而且更容易判断是否符合要求。只要数列的数值和大于 $ 0 $ 就满足要求。

但是如果在每次二分中判断是否有符合要求的段落时都分别枚举段落长度和起始端点，那么每次二分的时间复杂度都为 $ n^2 $。整个程序的时间复杂度就在  $\ n^2 \log{n}$，本蒻蒟亲测只有 $ 30 $ 分，和纯暴力没有什么区别。白打一个二分，时间复杂度还更差了。

因此这里需要用到单点队列优化。维护前缀和    $ summ [i] $ 为前 $ i $ 个数之和减去  $ mid \cdot i $。单调队列的板单调队列的板子不多说。
单调队列维护是否有序列的 $ summ [ i ]  $  大于   $ 0 $。如果存在，则说明 $ mid $ 成立，继续二分查询右侧数值。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,t;
double a[100005],ans;
double err(double minn,double maxx)
{
	if(minn>maxx-1e-5){
		ans=maxx;
		return 0;
	}
	double mid=(minn+maxx)/2;
	double b[100005],summ[100005];
	int hh=1,tt=0;
	int q[100005];
	for(int i=1;i<=n;i++){
		b[i]=a[i]-mid;
	}
	for(int i=1;i<=n;i++){
		summ[i]=summ[i-1]+b[i];
	}
	for (int i=1;i<=n;i++){
        if(i>=s){
            while(tt>=hh&& summ[i-s]<summ[q[tt]])tt--;
            q[++tt]=i-s;
        }
        if(hh<=tt&& q[hh]<i-t) hh++;
        if(hh<=tt&& summ[i]-summ[q[hh]]>=0) return err(mid,maxx);
    }
    return err(minn,mid);
}
int main()
{
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
	}
		err(-10010,10010);
	printf("%.3lf",ans);
	return 0;
}

---

## 作者：夏色祭 (赞：3)

#没有P的，哎。。。

#还是我来补一发吧

简单的题目。。。

先二分答案，然后每次判断当前mid是否可行时有点难度。。。

我们用sum[i]表示前i个数减去过当前mid的总和。。。

然后对于第i个数，其实就是前面i-y~i-x这个区间中的sum[j]最小值和当前sum[i]比较。。。

如果sum[i]>=min{sum[i-y]~sum[i-x]}，则说明当前方案可行。。。

对于min{sum[i-y]~sum[i-x]}，我们用一个单调队列维护就行了。。。

**注意：对于每个a[i]最好先乘10000，首先题目说要要保留3位小数，而且不乘的话，二分答案的时候就会很麻（e）烦（xin）**

#妖怪吧！！！

#这是最骚的

献上丑陋Pas代码：

```cpp
var 
  a,tt:array[0..100001]of longint;
  c,sum:array[0..100001]of int64;
  n,i,x,y,l,r,mid,ans:longint;
function check(k:longint):boolean;
var
  i,j,h,t:longint;
begin
  fillword(c,sizeof(c) div 2,0);
  fillword(tt,sizeof(tt) div 2,0);
  for i:=1 to n do sum[i]:=sum[i-1]+a[i]-k;//sum[i]表示前i个数减去过当前mid的总和
  h:=1;
  t:=0;
  for i:=1 to n do 
    begin
      j:=i-x;
      if j<0 then continue;
      while (sum[j]<c[t])and(h<=t) do dec(t);
      inc(t);
      c[t]:=sum[j];
      tt[t]:=j;
      if tt[h]<(i-y) then inc(h);
      if sum[i]>=c[h] then exit(true);
    end;//简单的用单调队列维护
  exit(false);
end;//判断当前方案是否可行
begin
  readln(n);
  readln(x,y);
  for i:=1 to n do 
    begin
      read(a[i]);
      a[i]:=a[i]*10000;//先乘上10000主要是为了接下来的二分
    end;
  l:=-trunc(1e9);
  r:=trunc(1e9);
  while l<=r do
    begin
      mid:=(l+r) >> 1;
      if check(mid) then begin l:=mid+1;ans:=mid; end
        else r:=mid-1;
    end;//二分答案
  writeln(ans/10000:0:3);
end.
```

---

## 作者：是羊驼鸭 (赞：3)

明显可以看出答案具有单调性，所以考虑二分答案，变为判定性问题。

对于可能的答案k，设b[i]=a[i]-k。

就是求b数组一段长度在s，t之间的和的最大值，判断其是否大于等于0，用前缀和+单调队列维护即可。

```cpp
#include<iostream>  
#include<cstdio>  
using namespace std;  
const int N=100005;  
int n,s,t,a[N],q[N];  
double b[N],sum[N];  
bool check(double k)  
{  
    for(int i=1;i<=n;i++)  
        b[i]=(double)a[i]-k;  
    for(int i=1;i<=n;i++)  
        sum[i]=sum[i-1]+b[i];  
    int head=1,tail=0;  
    for(int i=1;i<=n;i++)  
    {  
        if(i>=s)  
        {  
            while(head<=tail&&sum[i-s]<sum[q[tail]])  
                tail--;  
            q[++tail]=i-s;  
        }  
        if(head<=tail&&q[head]<i-t)  
            head++;  
        if(head<=tail&&sum[i]-sum[q[head]]>=0)  
            return true;  
    }  
    return false;  
}  
int main()  
{  
    scanf("%d%d%d",&n,&s,&t);  
    for(int i=1;i<=n;i++)  
        scanf("%d",&a[i]);  
    double l=-10000,r=10000,mid;  
    while(r-l>1e-5)  
    {  
        double mid=(l+r)/2;  
        if(check(mid))  
            l=mid;  
        else  
            r=mid;  
    }  
    printf("%.3f\n",l);  
    return 0;  
}
```

---

## 作者：_int_me (赞：2)



#### 题意简述

给定一段长度为 $10^5$ 的序列 $A$，并且给我们一个范围 $[S, T]$, 要求我们求出一段长度在这个范围内的连续子序列，并且要使这个连续子序列的平均值最大，要求输出这个平均值。



#### 题目分析

一开始想的是连续子段和相关，于是好久都没有想到正解。


- 这个题首先可以确定能够使用二分答案的方法，因为“符合条件的最大平均值”是单调的。


- 之后考虑如何检查序列中符合条件的子序列的平均值是否能达到给定的 k。


  - 因为我们计算的平均值取自 $A$ 的一段连续子序列，所以检验成功的表达式为

$$
A[L...R] / (R - L + 1) \ge k
$$

  - 变换可得

$$
A[L...R] \ge k * (R - L + 1)
$$

  - 看上去我们只需要先求前缀和，然后对每个 R，计算 $\max\limits_{1 \le L \le R}A[L...R]$ 然后比较，但是问题在于我们保证了左边最大的同时，右边的 $(R - L + 1)$ 却有可能很大而使得可行解不在 $\max\limits_{1 \le L \le R}A[L...R]$ 处取到


  - 所以再变换一次，得

$$
A[L...R] - k * (R - L + 1) \ge 0
$$

  - 这样我们每次检验时，先把 $A$ 全部元素 -k 得到 $A'$ 数组，(前缀和数组也同时更新)，然后对每个 $R$，计算 $\max\limits_{1 \le L \le R}A'[L...R]$，此时的最大值就是 $\max\limits_{1 \le L \le R}{(A[L...R] - k * (R - L + 1))}$, 然后与 0 比较，就可以正确寻找可行解。


  - 求最值的过程，由于子区间长度范围为$[S, T]$，所以我们求最值的范围事实上是

$$
 \max\limits_{R - t \le i \le R - s}{sum_R - sum_i}
$$

也就是需要求长度为 $t - s + 1$ 的区间上的 $sum_i$ 的最小值，固定区间长度的最值问题，使用单调队列。



- 之后就是二分了，注意精度就可以

#### 代码


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const double ff = 1e-4;

double su[100005];
int n, s, t, m;

struct ab
{
	int l;
	double v;
} que[100005];

bool chk(double k)
{
	for (int i = 1; i <= n; ++i)
	{
		su[i] -= i * k;
	}
	su[0] = 0;

	bool fl = false;
	int hd = 1, tl = 1;
	for (int i = 0; i < m; ++i)
	{
		while (tl > hd && que[tl - 1].v >= su[i])
		{
			--tl;
		}
		que[tl].l = i;
		que[tl++].v = su[i];
		if (su[i + s] - que[hd].v >= 0)
		{
			fl = true;
			break;
		}
	}
	
	if (!fl)
	{
		for (int i = m; i <= n - s; ++i)
		{
			while (hd < tl && que[hd].l + m <= i)
			{
				++hd;
			}
			while (tl > hd && que[tl - 1].v >= su[i])
			{
				--tl;
			}
			que[tl].l = i;
			que[tl++].v = su[i];
			if (su[i + s] - que[hd].v >= 0)
			{
				fl = true;
				break;
			}
		}
	}
	
	for (int i = 1; i <= n; ++i)
	{
		su[i] += i * k;
	}
	return fl;
}

int main()
{
	scanf("%d", &n);
	scanf("%d%d", &s, &t);
	m = t - s + 1;
	su[0] = 0;
	double ll = 0, rr = 0;
	for (int i = 1; i <= n; ++i)
	{
		double xx;
		scanf("%lf", &xx);
		su[i] = su[i - 1] + xx;
		ll = min(ll, xx);
		rr = max(rr, xx);
	}
	while (ll + ff * 5 <= rr)
	{
		double mid = (ll + rr) / 2;
		if (chk(mid))
		{
			ll = mid;
		}
		else
		{
			rr = mid;
		}
	}
	while (chk(ll))
	{
		ll += ff;
	}
	printf("%.3f", ll - ff);
	return 0;
}

```

---

## 作者：早右昕 (赞：1)

由题意得： (s[r]-s[l-1])/(r-l+1) >= lmt (0<l<=r<=n)


整式化：   (s[r]-s[l-1]) >= lmt\*(r-l+1) (0<l<=r<=n)


移项化简： (s[r]-lmt\*r) >= (s[l-1]-lmt\*(l-1)) (0<l<=r<=n)


令：       ss[i]=s[i]-lmt\*i (0<=i<=n)


则：       ss[r] >= ss[l-1] (0<l<=r<=n)


即存在:    ss[i] >= ss[j] (0<=j<i<=n)


其中s[i]是序列前缀和， lmt是二分给出的平均值。再乱搞一下就好了。


---


# 【模板】最长公共子序列

## 题目描述

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

## 说明/提示

- 对于 $50\%$ 的数据， $n \le 10^3$；
- 对于 $100\%$ 的数据， $n \le 10^5$。

## 样例 #1

### 输入

```
5 
3 2 1 4 5
1 2 3 4 5
```

### 输出

```
3```

# 题解

## 作者：皎月半洒花 (赞：3697)

# 一、$DP$的意义以及线性动规简介
动态规划自古以来是$DALAO$凌虐萌新的分水岭，但有些OIer认为并没有这么重要——会打暴力，大不了记忆化。但是其实，动态规划学得好不好，可以彰显出一个$OIer$的基本素养——**能否富有逻辑地思考一些问题**，以及更重要的——**能否将数学、算筹学（决策学）、数据结构合并成一个整体并且将其合理运用$qwq$**。

而我们首先要了解的，便是综合难度在所有动规题里最为简单的**线性动规**了。线性动规既是一切动规的基础，同时也可以广泛解决生活中的各项问题——比如在我们所在的三维世界里，四维的时间就是**不可逆式线性**，比如我们需要决策在相同的时间内做价值尽量大的事情，该如何决策，最优解是什么——这就引出了动态规划的真正含义：
### 在一个困难的嵌套决策链中，决策出最优解。

# 二、动态规划性质浅谈

首先，动态规划和递推有些相似（尤其是线性动规），但是不同于递推的是：

**递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。**

其次，由于每个状态均可以由之前的状态演变形成，所以动态规划有**可推导性**，但同时，动态规划也有**无后效性**，即**每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责**，可以浅显的理解为——

### _ $\mathcal{Future \ \  never  \ \  has \ \  to \ \  do \ \  with \ \  past \ \  time \ \ ,but \ \ present \ \ does}.$_
### _现在决定未来，未来与过去无关。_

# 三、扯正题——子序列问题

## （一）一个序列中的最长上升子序列（$LIS$）
例：由6个数，分别是： 1  7  6  2  3  4，求最长上升子序列。

评析：首先，我们要理解什么叫做最长上升子序列：1、最长上升子序列的元素不一定相邻 2、最长上升子序列一定是原序列的子集。所以这个例子中的$LIS$就是：1  2  3  4，共4个

### 1、$n^2$做法

首先我们要知道，对于每一个元素来说，最长上升子序列就是其本身。那我们便可以维护一个$dp$数组，使得**$dp[i]$表示以第$i$元素为结尾的最长上升子序列长度**，那么对于每一个$dp[i]$而言，初始值即为$1$；

那么dp数组怎么求呢？我们可以对于每一个$i$，枚举在$i$之前的每一个元素$j$，然后对于每一个$dp[j]$,如果元素$i$大于元素$j$，那么就可以考虑继承，而最优解的得出则是依靠对于每一个继承而来的$dp$值，取$max$.

```cpp
	for(int i=1;i<=n;i++)
	{
		dp[i]=1;//初始化 
		for(int j=1;j<i;j++)//枚举i之前的每一个j 
		if(data[j]<data[i] && dp[i]<dp[j]+1)
		//用if判断是否可以拼凑成上升子序列，
		//并且判断当前状态是否优于之前枚举
		//过的所有状态,如果是，则↓ 
		dp[i]=dp[j]+1;//更新最优状态 
		
	}
```

最后，因为我们对于$dp$数组的定义是到i为止的最长上升子序列长度，所以我们最后对于整个序列，只需要输出$dp[n]$($n$为元素个数)即可。

从这个题我们也不难看出，状态转移方程可以如此定义：
###  下一状态最优值=最优比较函数（已经记录的最优值，可以由先前状态得出的最优值） 
### ——即动态规划具有 _判断性继承思想_ 

### 2、$nlogn$ 做法

我们其实不难看出，对于$n^2$做法而言，其实就是暴力枚举：将每个状态都分别比较一遍。但其实有些没有必要的状态的枚举，导致浪费许多时间，当元素个数到了$10^4-10^5$以上时，就已经超时了。而此时，我们可以通过另一种动态规划的方式来降低时间复杂度：

将原来的dp数组的存储由数值换成**该序列中，上升子序列长度为i的上升子序列，的最小末尾数值**

这其实就是一种几近贪心的思想：我们当前的上升子序列长度如果已经确定，那么**如果这种长度的子序列的结尾元素越小，后面的元素就可以更方便地加入到这条我们臆测的、可作为结果、的上升子序列中。**

qwq一定要好好看注释啊！
```cpp
int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		f[i]=0x7fffffff;
		//初始值要设为INF
		/*原因很简单，每遇到一个新的元素时，就跟已经记录的f数组当前所记录的最长
		上升子序列的末尾元素相比较：如果小于此元素，那么就不断向前找，直到找到
		一个刚好比它大的元素，替换；反之如果大于，么填到末尾元素的下一个q，INF
                就是为了方便向后替换啊！*/ 
	}
	f[1]=a[1];
	int len=1;//通过记录f数组的有效位数，求得个数 
	/*因为上文中所提到我们有可能要不断向前寻找，
	所以可以采用二分查找的策略，这便是将时间复杂
    度降成nlogn级别的关键因素。*/ 
	for(int i=2;i<=n;i++)
	{
		int l=0,r=len,mid;
		if(a[i]>f[len])f[++len]=a[i];
		//如果刚好大于末尾，暂时向后顺次填充 
		else 
		{
		while(l<r)
		{	
		    mid=(l+r)/2;
		    if(f[mid]>a[i])r=mid;
	//如果仍然小于之前所记录的最小末尾，那么不断
	//向前寻找(因为是最长上升子序列，所以f数组必
	//然满足单调) 
			else l=mid+1; 
		}
		f[l]=min(a[i],f[l]);//更新最小末尾 
     	}
    }
    cout<<len;
```

______

$Another \ \  Situation$

但是事实上，$nlogn$做法偷了个懒，没有记录以每一个元素结尾的最长上升子序列长度。那么我们对于$n^2$的统计方案数，有很好想的如下代码（再对第一次的$dp$数组$dp$一次）：
```cpp
for(i = 1; i <= N; i ++){
	if(dp[i] == 1) f[i] = 1 ;
	for(j = 1; j <= N: j ++)
		if(base[i] > base[j] && dp[j] == dp[i] - 1) f[i] += f[j] ;
		else if(base[i] == base[j] && dp[j] == dp[i]) f[i] = 0 ;
	if(f[i] == ans) res ++ ;
	}
```
但是$nlogn$呢？虽然好像也可以做，但是想的话会比较麻烦，在这里就暂时不讨论了$qwq$，但笔者说这件事的目的是为了再次论证一个观点:**时间复杂度越高的算法越全能**

_________


### $3$、输出路径

只要记录前驱，然后递归输出即可（也可以用栈的）

下面贴出$n ^ 2$的完整代码qwq

```cpp
#include <iostream>
using namespace std;
const int MAXN = 1000 + 10;
int n, data[MAXN];
int dp[MAXN]; 
int from[MAXN]; 
void output(int x)
{
	if(!x)return;
	output(from[x]);
	cout<<data[x]<<" ";
	//迭代输出 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>data[i];
	
	// DP
	for(int i=1;i<=n;i++)
	{
		dp[i]=1;
		from[i]=0;
		for(int j=1;j<i;j++)
		if(data[j]<data[i] && dp[i]<dp[j]+1)
		{
			dp[i]=dp[j]+1;
			from[i]=j;//逐个记录前驱 
		}
	}
	
	int ans=dp[1], pos=1;
	for(int i=1;i<=n;i++)
		if(ans<dp[i])
		{
			ans=dp[i];
			pos=i;//由于需要递归输出
	//所以要记录最长上升子序列的最后一
	//个元素，来不断回溯出路径来 
		}
	cout<<ans<<endl;
	output(pos);
	
	return 0;
}
```

## （二）两个序列中的最长公共子序列（$LCS$）

1、譬如给定2个序列：

```cpp
1 2 3 4 5

3 2 1 4 5
```
试求出最长的公共子序列。

$qwq$显然长度是$3$，包含$3 \ \   4   \ \ 5$ 三个元素（不唯一）

解析：我们可以用$dp[i][j]$来表示第一个串的前$i$位，第二个串的前j位的$LCS$的长度，那么我们是很容易想到状态转移方程的：

如果当前的$A1[i]$和$A2[j]$相同（即是有新的公共元素）
那么

#### $dp[ i ] [ j ] = max(dp[ i ] [ j ], dp[ i-1 ] [ j-1 ] + 1);$

如果不相同，即无法更新公共元素，考虑继承：

#### $dp[ i ] [ j ] = max(dp[ i-1 ][ j ] , dp[ i ][ j-1 ] $

那么代码:

 ```cpp
#include<iostream>
using namespace std;
int dp[1001][1001],a1[2001],a2[2001],n,m;
int main()
{
	//dp[i][j]表示两个串从头开始，直到第一个串的第i位 
	//和第二个串的第j位最多有多少个公共子元素 
	cin>>n>>m;
	for(int i=1;i<=n;i++)scanf("%d",&a1[i]);
	for(int i=1;i<=m;i++)scanf("%d",&a2[i]);
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	  {
	  	dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
	  	if(a1[i]==a2[j])
	  	dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);
	  	//因为更新，所以++； 
	  }
	cout<<dp[n][m];
}
```

$2$、而对于洛谷$P1439$而言，不仅是卡上面的朴素算法，也考察到了全排列的性质：

对于这个题而言，朴素算法是$n^2$的，会被$10^5$卡死，所以我们可以考虑$nlogn$的做法：

因为两个序列都是$1~n$的全排列，那么两个序列元素互异且相同，也就是说只是位置不同罢了，那么我们通过一个$map$数组将$A$序列的数字在$B$序列中的位置表示出来——

因为**最长公共子序列是按位向后比对的，所以a序列每个元素在b序列中的位置如果递增，就说明b中的这个数在a中的这个数整体位置偏后**，可以考虑纳入$LCS$——那么就可以转变成$nlogn$求用来记录新的位置的map数组中的**$LIS$**。

最后贴$AC$代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100001],b[100001],map[100001],f[100001];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){scanf("%d",&a[i]);map[a[i]]=i;}
	for(int i=1;i<=n;i++){scanf("%d",&b[i]);f[i]=0x7fffffff;}
	int len=0;
	f[0]=0;
	for(int i=1;i<=n;i++)
	{
		int l=0,r=len,mid;
		if(map[b[i]]>f[len])f[++len]=map[b[i]];
		else 
		{
		while(l<r)
		{	
		    mid=(l+r)/2;
		    if(f[mid]>map[b[i]])r=mid;
			else l=mid+1; 
		}
		f[l]=min(map[b[i]],f[l]);
     	}
    }
    cout<<len;
    return 0
}
```

## _  $\mathcal{Although  \ \  there're  \ \ difficulties \ \ ahead \ \  of \ \  us \ \ , \ \ remember \ \ :}$ _ 

>## 就算出走半生，归来仍要是少年

---

## 作者：阮行止 (赞：1745)

关于为什么可以转化成LIS问题，这里提供一个解释。

A:3 2 1 4 5 

B:1 2 3 4 5

我们不妨给它们重新标个号：把3标成a,把2标成b，把1标成c……于是变成：

A: a b c d e  
B: c b a d e

这样标号之后，LCS长度显然不会改变。但是出现了一个性质：

两个序列的子序列，一定是A的子序列。而A本身就是单调递增的。  
因此这个子序列是单调递增的。

换句话说，只要这个子序列在B中单调递增，它就是A的子序列。

哪个最长呢？当然是B的LIS最长。

自此完成转化。

---

## 作者：heey (赞：948)

看了看其他人写的题解，感觉有点冗杂，我想以最简单，通俗得写一下自己的理解，希望大家能得到我的帮助！

首先看到这道题很容易一下就想到dp（n^2），但是看看数据范围，放弃dp，再看一看它题目给出的，这两串数都是1到n的全排列，说白了就上下两个串中的元素都是相同的，只有顺序不同而已，那么知道这个，我们又怎么来解决这道题呢？

我们可以以第一个串为标准，用第二个串来匹配第一个串，看能匹配多少，所以，其实第一个串的每个数字其实影响不大，只有知道它对应了第二串的哪个数字就好了，那么我们为什么不把他给的串重新定义一下？

比如他的样例：3 2 1 4 5 我们把他变成 1 2 3 4 5 用一个数组记录一下每个数字变成了什么，相当于离散化了一下3-1；2-2；1-3；4-4；5-5；

现在我们的第二串1 2 3 4 5 按我们离散化的表示：3 2 1 4 5

可能有些人已经懂了，我们把第一个串离散化后的数组是满足上升，反过来，满足上升的也就是满足原串的排列顺序的，（如果你不懂的话可以多看几遍这个例子）O(∩\_∩)O~

好了 ，现在的问题就变成了求一个最长不下降序列！好了！解决完成！

    

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
int a1[100010],a2[100010];
int belong[100010];
int f[100010],b[100010],len;
int main()
{
    freopen("a.in","r",stdin);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a1[i]);
        belong[a1[i]]=i;
    }
    for(int i=1;i<=n;i++)
    scanf("%d",&a2[i]);
    for(int i=1;i<=n;i++)
    {
        if(belong[a2[i]]>b[len])
        {
            b[++len]=belong[a2[i]];
            f[i]=len;
            continue;
        }
        int k=lower_bound(b+1,b+len+1,belong[a2[i]])-b;
        b[k]=belong[a2[i]];
        f[i]=k;
    }
    printf("%d\n",len);
    return 0;
}

```

---

## 作者：I_AM_HelloWord (赞：228)

二分法求最长上升子序列这种东东大家难道没见过嘛= =

先简单讲下怎么O(nlogn)搞一个最长上升子序列吧。

考虑一个数列5 2 3 1 4

首先，把5加入答案序列中，然后加2，发现2<5所以显然2替换5不会使结果更差，

那么答案序列就是{2},然后加3，发现3>2，所以直接把3加到答案序列中：{2,3}

然后加1，我们发现1<3，于是我们找到一个最小的但是比1大的数字2，然后把1替换2，为什么这么做不会影响结果呢？你可以这么想，我们当前已经求出了一个当前最优的序列，如果我们用1替换2，然后后面来一个数字替换了3，那么我们就可以得到一个更优的序列，而如果没有数字替换3，那么这个1替换2也就是没有贡献的，不会影响我们结果的最优性。至于，如何找到一个最小的但是大于某个数字的数字，弄个二分查找就行了，因为我们的答案序列是有序的呀。

然后考虑如何解决这道题。

首先，我们可以想到，最长公共子序列，就是两段所含数字完全一样，并且数字的顺序也是完全一样的序列。

而顺序，我们可以想到类似哈希的思想，考虑建立一个类似map的关系数组f[ai]=i，那么我们找到的序列只要是上升的，顺序就是一样的，然后考虑数字完全一样，由于我们已经有了一个f[ai]=i,所以我们把对应的bi改成f[bi]，就可以确保数字相等了呀！

这时，就是在f[bi]的数组中求个最长上升子序列了，二分搞一搞就好了。STL大法好！


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=101000;
int b[N],idx[N],n;
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main(){
    n=read();
    memset(b,0x3f,sizeof(b));
    for (int i=1;i<=n;i++)
        idx[read()]=i;
    for (int i=1;i<=n;i++){
        int x=idx[read()];
        *lower_bound(b+1,b+n+1,x)=x;
    }
    printf("%d",lower_bound(b+1,b+n+1,b[0])-b-1);
    return 0;
}
```

---

## 作者：_ztyqwq (赞：87)

# 首先声明2个名词：

# LIS：Longest Increasing Subsequence，最长递增子序列

# LCS：Longest Common Subsequence，最长公共子序列

（因为我（肯定不止我一个）经常弄混，所以要声明一下）

下面进入正题：

我们知道，用朴素的DP解LIS和LCS，复杂度都是 $ O(n^2) $ 的，而且很容易写出来。我们还知道，用另一种DP解LIS，复杂度是 $ O(nlogn) $ 的，这种方法的本质就是换一种状态定义法，使其可以进行二分，具体怎么做，[戳这里](https://www.luogu.org/blog/ztyluogucpp/lis-di-onlogn-suan-fa-ge-ren-li-xie)

But！这题是求LCS，不是LIS！

LIS有 $ O(nlogn) $ 解法，LCS表示很嫉妒，于是打算效仿一下LIS，搞出一个 $ O(nlogn) $ 解法来。

于是，他想：LIS不就是一个长度为n的数列，和{1,2,3,...,n}的LCS吗！既然LIS可以变成LCS，那LCS也一定可以变成LIS！

是的，其实只要重新定义“大小”关系就行了。例如：求

2 5 4 3 1

和

1 2 4 5 3

的LCS，只要在数列1中重新定义“大小”关系，让4 < 3（因为在数列2中，4在3前面），5 < 3（5在3前面）就行了。

也就是说，只要i在数列2的位置，与j在数列2的位置相比，i的位置更加靠前，我们就说i < j，然后利用这种大小关系，求数列1的LIS就OK了（因为是1~n的一个全排列，所以每个数必定都在数列2出现过）。

说得再清楚一些，就是定义一个p数组，p[i] = x 代表b[x] = i，然后将LIS算法中的 i < j 都改成 p[i] < p[j] 就可以了。

（事实上，这就是某些大佬所说的“离散化”，不过本蒟蒻并不会，而且我觉得这样更加易懂一些）

于是就愉快的解决啦~

### update on 2019.11.11: 不知为什么之前代码里面 ```bound``` 函数没写 ```return``` ？？？感谢评论区dalao

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int len=0;
int a[100001],p[100001],f[100001];
int bound(int x)
{
	int L=1,R=len;
	while(L<R)
	{
		int mid=(L+R)>>1;
		if(p[f[mid]]>p[x])
			R=mid;
		else
			L=mid+1;
	}
	return L;
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		p[x]=i;
	}
	for(int i=1;i<=n;i++)
	{
		if(p[a[i]]>p[f[len]])
			f[++len]=a[i];
		else
			f[bound(a[i])]=a[i];
	}
	cout<<len<<endl;
	return 0;
}
```

---

## 作者：Mine_King (赞：67)

## 前置知识：最长上升子序列（不懂的自行百度）  
### 这题看似很难，其实只需要一个**神**转化。  
首先，我们来看这样一个问题：给你一个这样的序列：1,2,3,……,n，再给你一个1—n的排列，求他们的最长公共子序列。  
这个问题很简单，因为第一个序列是一个严格递增的，所以只要在第二个序列中找到一个上升子序列，那么一定会在第一个序列中出现，这个很好证明。如果要求最长公共子序列，那求最长上升子序列就行了。那回到原来的这个问题，这个问题第一个序列并不是严格递增的。但我们可以给他标号。  
如下：
```
原序列：3 2 1 4 5
  标号：1 2 3 4 5
```
那我们就把第一个序列变成了刚才的那个问题。注意了，第二个序列如果不做任何改变，那么你就会出问题。而第二个序列的改变方式也是标号。标号方式是和第一个序列一一对应。
```
p1
原序列：3 2 1 4 5
  标号：1 2 3 4 5
p2
原序列：1 2 3 4 5
  标号：3 2 1 4 4
```
上面p1中1标号为3，则p2中1的标号也是3。

这样，再对第二个序列的标号求最长上升子序列，就能得出答案了。

**上代码吧**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
int ans,ma,c[100005],b[100005],r[100005];
int fen(int x)//二分
{
	int le=0,ri=ma,mid;
	while(le<ri)
	{
		mid=(le+ri)/2+1;
		if(r[mid]>=x) ri=mid-1;
		else le=mid;
	}
	return le;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],c[a[i]]=i;//如果直接二重循环枚举的话肯定会超时的，所以借助一个c[]暂时存储c[i]的标号（a[i]的编号就是i）
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		b[i]=c[x];
	}
	for(int i=1;i<=n;i++)
	{
		int l=fen(b[i])+1;
		ans=max(ans,l);
		r[l]=(!r[l]?b[i]:min(r[l],b[i]));
		ma=max(ma,l);
	}//最长上升子序列
	cout<<ans;
	return 0;
}
```
如果觉得这个[蒟蒻](https://www.luogu.org/blog/yhdhg1395754790/)写得好的话，能不能点个赞呢/kel

---

## 作者：ljc20020730 (赞：63)

P1439 【模板】最长公共子序列 题解
## 适合下面没有读懂的OIer不适用于dalao。。
我打算写一发通俗易懂的题解。。
首先dp是n^2暴力算法显然只能拿50%的分数，我这里就贴下代码：
```cpp
# include <iostream>
# include <cstring>
# include <cstdio>
using namespace std;
int a[5000],b[5000],f[5000][5000];
int max(int a,int b)
{
    return a>b?a:b;
}
int main()
{
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    for (int i=1;i<=n;i++) scanf("%d",&b[i]);
    for (int i=0;i<=n;i++)
     for (int j=0;j<=n;j++)
      {
      	if ((i==0)||(j==0)) {
      		f[i][j]=0;continue;
          }
      	if (a[i]==b[j]) f[i][j]=f[i-1][j-1]+1;
      	if (a[i]!=b[j]) f[i][j]=max(f[i][j-1],f[i-1][j]);
      }
      printf("%d\n",f[n][n]);
    return 0;
}
```
n^2暴力算法只能拿50分。。不满意。。

然而我们有一种优秀的 n log n 算法来解决这道LCS问题，就是单调队列优化，这是基于一个贪心。首先我们来考虑这样一个问题：

   假设有t[]数组，求t[]的最长上升子序列。（LIS）
   
我们可以这么考虑（n^2就不用赘述了）
我们设一个单调递增的队列来存我们目前最优的LIS序列，什么是最优呢？
包括数字最小、长度最大（这样才最有可能接受下一个比较小的数字变成更长的LIS），

那么问题就简单化了。具体来说如果有一个数组a是{4,5}（上述的单调队列a）我现在有一个数字3插入进去那么我只要把4改为3就行了（反正没有损失又使我们的数字小了）。

不巧的是后来有了个4来了，那么把5改为4（满足递增），这样a数组就变成了{3,4}那么相对于{4,5}有什么好处呢？

假设我们又来了数字5那么对于原来最优的{4,5}我的5是不满足最长上升子序列的，而对{3,4}来说5是可以加入拖长这个最优解LIS长度的，现在我们最优值变成{3,4,5}==>ans=3.

   好了对于上述LIS问题我们有一个n log n的解法了：
   
   设t[]为原数组，a[]为单调递增的最优解法队列，枚举n个元素如果t[i]>a[i]，直接吧t[i]加入a[i]；如果t[i]<a[i]在a[]中二分法（a有序！）找到一个比t[i]大的最小数，并将其替换为t[i]满足最优解法（虽然不是更优LIS解但是相比其他相同LIS长度解法它更有优势）
   
   
回到本题求LCS的长度，怎样把他转移到LIS问题呢？

我们设A,B分别为两个数组的值，那么我只要保存A的元素在B中的位置，B 中的元素在A中的位置不就可以解决了吗？

好，我设t[]表示A数组B[i]元素在A中的位置（序号），那么这个序号在B中出现本来就有先后位置，再保存A中的位置那么就可以表示出A的序列了。

举个例子。
序号 1 2 3 4 5
 A[]=3 2 1 4 5
 B[]=1 2 3 4 5
按照上述算法映射后t[]=3 2 1 4 5 

那么很显然t中的数字如果递增

那么表示A中的序号递增就表示这个递增的序列就是A的子序列，
并且我们在B中一直的顺序遍历（从前向后）那么显然这个序列也是B的子序列，
那么这个序列就是A,B公共子序列，

那么最大化这个子序列就是最大化t数组中的最长上升子序列LIS算法，

这样我们就把LCS问题变成LIS问题用n log n解决了。


代码：

//tips：手写lower_bound比调用algorithm快一些。。

```cpp
# include <iostream>
# include <cstdio>
# include <cstring>
# include <algorithm>
using namespace std;
int a[100005],t[100005],A[100005],B[100005],f[100005];
bool cmp(int a,int b)
{
    return a<b;
}
int solve(int l,int r,int x)
{
    int mid=(l+r)/2;;
    if (l==r) return l; 
    if (a[mid]>x) return solve(l,mid,x);
    if (a[mid]<=x) return solve(mid+1,r,x);
}
int main()
{
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&A[i]);
    for (int i=1;i<=n;i++) scanf("%d",&B[i]);
    for (int i=1;i<=n;i++) f[A[i]]=i;
    for (int i=1;i<=n;i++) t[i]=f[B[i]];
    memset(a,0,sizeof(a));
    for (int i=1;i<=n;i++) {
        if ((i==0)||(t[i]>a[a[0]])) a[++a[0]]=t[i];
        else if (t[i]<a[a[0]]) a[solve(1,a[0],t[i])]=t[i];
//a[lower_bound(a+1,a+a[0]+1,t[i])-a]=t[i];(替换a[solve(1,a[0],t[i])]=t[i];也行但是会稍微慢一点。。)
    }
    printf("%d\n",a[0]); 
    return 0;
}
```

我们可以扩展一下这个算法，把它扩展为普通字符串的最大LCS问题，采用map数组（最大长度MAXN，最多重复次数MAXT），算法大概是这样的：我们把a序列中的每个元素在b中出现的位置保存起来，再按照降序排列，排列后再代入a的每个对应元素，那就转化为了求这个新的序列的最长上升子序列了。如：a[] = {a, b, c,} b[] = {a,b,c,b,a,d},那么a中的a，b，c在b中出现的位置分别就是

{0,4},{1,3},{2}分别按降序排列后代入a序列就是{4,0,2,3,1},之所以要按照降序排列，目的就是为了让每个元素只取到一次。

接下来的问题就是要求最长升序子序列问题了，也就是求LIS。

但是有人认为这种转化并没有多大意义，因为当数据比较大时，举一个例子来说：a[]= “aaaaaaaaaaa”,b[] = "aaaaaaaaaaa",他们都有n个a，那么a[]中‘a’在b[]出现了n次那么替换之后的a就变为了n-1...1,n-1...1,... ...这样a[]就有了n^2个数了这样不仅是空间，就连时间也比原来n^2要大。所以感觉这种转化还是要慎用。

那么我还是贴一下代码吧：
(我比较蒟蒻想不出更加高深的算法那么假装这个是kn log n算法了，常数k应该比较大。。。)
```cpp
# include <iostream>
# include <cstdio>
# include <cstring>
# include <algorithm>
# include <map>
using namespace std;
const int MAXN=100000,MAXT=1000;
int a[MAXN+1],t[MAXN+1];
char A[MAXN+1],B[MAXN+1],T[MAXN+1];
int f[MAXN+1][MAXT+1];
int n,m;
map<char,int>key;
bool cmp(int a,int b)
{
	return a>b;
}
void copy(int cnt)
{
	for (int i=1;i<=f[cnt][0];i++)  
	  t[++t[0]]=f[cnt][i];
}
void swap(int &a,int &b)
{
	int t=a;a=b;b=t;
}
void change()
{
	memcpy(T,A,sizeof(A));memcpy(A,B,sizeof(B));memcpy(B,T,sizeof(T));
}
int main()
{
	scanf("%d",&n);getchar();
	for (int i=1;i<=n;i++) scanf("%c",&A[i]);getchar();
	scanf("%d",&m);getchar();
	for (int i=1;i<=m;i++) scanf("%c",&B[i]);getchar();
	if (n>m) { change(); swap(n,m); }
	int tot=0;
	for (int i=1;i<=n;i++)  {
		if (key.count(A[i])==0) key[A[i]]=++tot;
		f[key[A[i]]][++f[key[A[i]]][0]]=i;
	}
	for (int i=1;i<=tot;i++)  sort(f[i]+1,f[i]+f[i][0]+1,cmp);		
	memset(t,0,sizeof(t));
	for (int i=1;i<=m;i++) {
		if (key.count(B[i])==0) continue;
		else  copy(key[B[i]]);
	} 	
	memset(a,0,sizeof(a));
	for (int i=1;i<=t[0];i++) 
		if ((t[i]>a[a[0]])) a[++a[0]]=t[i];
		else if (t[i]<a[a[0]]) a[lower_bound(a+1,a+a[0]+1,t[i])-a]=t[i];
	printf("%d\n",a[0]); 
	return 0;
}
```

---

## 作者：青葱 (赞：45)

# 关于LIS的几种解法

## **一、LIS的朴素做法O($n^2$)**

------------

**f[ i ]:以第i个数为结尾的最长升长度**

**w[ i ]:第i个数的权值**

------------

考虑新加入一个数 j 在原序列后，所有权值小于w[ j ]的数所形成的最长升都能扩展一个位置

换句话说，j 的最长升是从**以比它小且在它左边的数为末尾的最长升**加一个数 j 得到的

------------


### **动态转移方程如下:**

### ***f[ j ]=max{ $\sum_{i=1}^j$ f[ i ] | w[ i ] > w[ j ] }+1***
------------

```cpp
for(int i=1;i<=n;i++){
   for(int j=1;j<=i;j++){
   	if(w[j]<=w[i])
	  f[i]=max(f[i],f[j]+1);	
   }
}
```

### **其特点在于：**

#### 1. 	简单又暴力的美学
#### 2.	可以求出以每个数为结尾的最长升长度
#### 3. 	可以顺手求出最长升原序列


------------

## **二、LIS单调栈做法O($nlog^{}_{2}n$)**
------------
假设这里有一个序列是递增的，我们显然可以很好地求出最长升的长度

而对于非递增的序列，我们也可以通过**维护一个单调栈**来使其递增

------------

### **单调栈一般流程：**
#### 1. 二分找到栈中小于它的第一个数
#### 2. 如果存在，替换它，否则压新数入栈
#### 3. 当前数所在栈中的编号即为以它为结尾的最长升长度

------------

### **单调栈设计思路的由来：**
------------
#### 从第一个数到第 n 个数依次插入序列，分析题目的单调性：
设当前要插入第 j 个数，其权为w[ j ]


------------


1、我们可以轻易的知道，在以第一个数到第 j -1个数为末尾的最长升在位置上是允许被扩展的，第 j 个数可以插入到以它之前所有权值小于w[ j ]的数所形成的最长升后

即：**只要是权值小于等于w[ j ]的数，我们都一视同仁为可扩展数，以其为结尾的最长升，一视同仁为可扩展序列**


------------

2、我们还可以发现，对于一个数的插入是没有后效性的

即：确定了以w[ j ]为结尾的最长升，**无论在它后面插入多少个数，以w[ j ]为结尾的最长升是不变的**


------------

3、于是，我们很自然地想，要确定最长升，就要有最长的可扩展序列

即：如果我们能够知道在第1个数到第 j -1个数所形成的不同长度的最长升中，
**长度最长且结尾数字小于等于w[ j ]的最长升**，即找到了最优扩展位置，就可以求出以第 j 个数为结尾的最长升

4、更秒的是，我们可以证明，更长的上升子序列的结尾数字一定不小于更短的上升子序列（我们可以通过舍弃长的上升子序列的前几个数得到短的上升子序列）

即：**我们维护的这个栈是单调的**，我们可以二分找到最佳扩展位置

------------
### 需要注意的是：

单调栈内在不同位置上的数 即：
#### **在第 j 个数之前不同长度上升子序列的最小结尾数字**

而实际上，**我们维护的单调栈并非维护的一个序列，而是不同长度下结尾数字最小的多个序列**

但是，我们在维护单调栈的同时，改变了位置关系，所以，对于单调栈内维护的序列，只有长度与最小末尾数字是可以确定的

------------

```cpp
for(int i=1;i<=n;i++){
        if(b[i]>m[top]) m[++top]=b[i];
        else m[lower_bound(m+1,m+top+1,b[i])-m]=b[i];
    }
```

------------

### **其特点在于：**

#### 1. 	简洁而又睿智的美学
#### 2.	可以求出以每个数为结尾的最长升长度
#### 3.	不能很有效的求出最长升序列

------------

## **三、LIS的DP优化O($nlog^{}_{2}n$)**
基于朴素DP和单调栈的思想：

我们插入到一个数时，仅仅需要知道以比它小的数结尾的最长上升子序列长度

那么我们可以用数据结构维护这个性质

即：**我们需要一种数据结构维护区间最大值和单点插入**

比如：树状数组、线段树


------------
### **一般流程：**
我们以w[ j ]作为下标，以第 j 个数能形成的最长升长度为权值

当插入到第 j +1个数时，只需要询问1~w[ j +1]之间的长度最大值

之后插入第 j +1个数，继续下面的数


------------
```
for(int i=1;i<=n;i++){
	int p=_map[read()];
	f[i]=query(p)+1;
	ans=max(ans,f[i]);
	add(p,f[i]);
}

```
答案即为以各个数为结尾的最长升中的最大值


------------

### 需要注意的是：
1、如果我们用：pair<int.int>(第一维维护最大值，第二维维护对应的位置下标)，代替最大值的int，**就能够层层向上，找到原序列**

2、因为下标为权值，所以**对于一般题目需要离散化**

------------

### **其特点在于：**

#### 1. 	精简而又巧妙的美学
#### 2.	可以求出以每个数为结尾的最长升长度
#### 3.	可以很有效的求出最长升序列

---

## 作者：cyborg (赞：28)

假设ans[i]代表当公共最长子序列长度为i时所需要序列a的长度，那么ans当中，就是一个上升序列，方便二分查找，line[i]表示i这个数字在第一个序列中的位置。

每当读入第二个序列的数字m时，我们就在ans里用二分查找找到ans[r]<line[m]<ans[l]，接着就可以将ans[l]的值降低为line[m]的值。当然，如果说ans中最大的数小于line[m]，就可以给最长公共子序列长度加一

代码如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    //freopen("test.cpp","r",stdin);
    int n,m,line[100001]={0},ans[100001]={0},total=0;//total表示最长公共子序列长度
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>m;
        line[m]=i;//line[m]是m在第一个序列中的位置
    }
    for(int i=1;i<=n;i++)
    {
        cin>>m;
        int search=line[m];
        if(search>ans[total])ans[++total]=search;else
        {
            int l=0,r=total;
            while(l<=r)
            {
                int mid=ans[(l+r)/2];
                if(search<mid)r=(l+r)/2-1;else
                l=(l+r)/2+1;
            }
            ans[l]=search;//因为之前最长公共子序列长度为l时所需要的第一个序列的长度大于长度为l-1时再包括了数字m时（同样最长公共子序列长度为l）所需要第一个序列的长度
        }
    }
    cout<<total;
}
```

---

## 作者：rankoo (赞：27)

首先，一开始，本蒟蒻是WA+TLE的，除了样例过去了QAQ

然后还是感谢楼下几位红名大佬的思路，才发现了希望。

首先是利用映射，我们定义A，B两个子序列，将A存到b数组里（即序列里每个数的出现顺序），

然后再将B与A公共的数（即同时拥有的自然数）映射回a数组里，使得a数组里存放公共自然数出现的顺序，

接着就是求最长上升子序列啦！（思路类似于友好城市）。

最后，附上本蒟蒻代码（文笔不好勿喷QAQ）：

```cpp
#include<iostream>
using namespace std;
const int maxv=2000100;
int a[maxv],b[maxv],f[maxv];
int n,ans=0;
int main()
{
 cin>>n;
 for(int i=1;i<=n;++i)
 {
  int k;
  cin>>k;
  b[k]=i;
 }
 for(int i=1;i<=n;++i)
 {
  int k;
  cin>>k;
  a[i]=b[k];
 }
 for(int i=1;i<=n;++i)
 {if(a[i]==0) continue;
  if(f[ans]<a[i]) f[++ans]=a[i];
  else
  {
   int l=0,r=ans,mid;
   while(l<r)
   {
    mid=(l+r)/2;
    if(f[mid]>a[i]) r=mid;
    else l=mid+1;   
   }
   if(l!=0) f[l]=a[i];
  }
 }
 cout<<ans;
 return 0;
}
```

---

## 作者：hjsjhn (赞：14)

/\*
\* 这题可以先把最长公共子序列转化成最长上升子序列来做

** 因为这题若用DP求LCS需要O(N2), 但是转化成LIS可以二分做到O(NlogN)

*** LIS详见白书65, 下面也有简略方法

\* LIS 实现方法

** dp[i]: 以a[i]为结尾的最长上升子序列长度s

*** 以a[i]为结尾的最长上升子序列有:s

****       只包含a[i]的子序列ss

****       在满足j<i并且a[j] < a[i]的以a[i]为结尾的上升子序列末尾， 追加上a[i]后得到的子序列s

** 这二者之一。就能得到如下的递推关系:s

***              dp[i] = max{1, dp[j] + 1 | j < i && a[j] < a[i]}

*** 然而， 这样只能拿50分

\* 所以我们用O(NlogN)的二分LIS

** 代码理解可能不是很容易， 用到了lower\_bound来优化

** 这里需要重新定义dp数组

** dp[i]: 长度为i + 1的上升子序列中末尾元素的最小值(不存在的话就是INF)

*** 对于每个a[j], 如果i = 0或dp[i - 1] < a[j]的话，就用min(dp[i], a[j])进行更新。最终找出使得dp[i] < INF的最大的i + 1就是结果

** 优化:首先dp数列中除INF外是单调递增的， 所以可以知道对于每个a[j]最多只需要一次更新。对于这次更新在和位置直接lower\_bound二分

\*/



```cpp
#include <cstdio>
#include <algorithm>
#define MAX_N 1000001
#define INF 2147483647
using namespace std;
int N, s[MAX_N], t[MAX_N];
int dp[MAX_N], top = 0;
int q;
void solve () {
  fill(dp, dp + top, INF);
  for (int i = 0;i < top; i++) {
    *lower_bound(dp, dp + top, t[i]) = t[i];
  }
  printf("%d\n", lower_bound(dp, dp + top, INF) - dp);
}
int main() {
  scanf("%d", &N);
  for(int i = 1;i <= N; i++) {scanf("%d", &q); s[q] = i;}
  for(int i = 1;i <= N; i++) {scanf("%d", &q); if(s[q] > 0) t[top++] = s[q];}
  solve();
  return 0;
}
```

---

## 作者：Brian_WBY (赞：13)

$update$ 2020/4/6：更正了一些错别字，增加了$LIS$的$O(n^2)$的做法的代码

------------

### 题解区很多大佬都已经把$LIS$和$LCS$讲的非常明白了，我只是谈谈我自己的理解，以及这个问题的时间和空间的优化，~~其实就是卡了一点常数~~。

先说$LIS$（提醒一下，最长上升子序列是不要求连续的）：

$LIS$问题有两种做法，一种是$O(n^2)$的，一种是$O(nlogn)$的。

首先说$O(n^2)$做法：

记$dp_x$为以$a_x$结尾的$LIS$长度，考虑比$x$小的每一个$p$：如果$a_p<a_x$，那么$dp_x$可以取$dp_p+1$，因为我们把$a_x$接在$a_p$后面，肯定能构造一个以$a_x$结尾的上升子序列，长度比以$a_p$结尾的$LIS$大$1$.

那么状态转移方程就是：$dp(x)=\max_{p<x,a_p<a_x}\{dp(p)\}+1$.

两层for循环，复杂度$o(n^2)$.代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[10001];
int dp[10001];
int main()
{
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		dp[i]=1;
	}
	for (int x=1;x<=n;x++)
		for (int p=1;p<x;p++)
			if  (a[p]<a[x]) dp[x]=max(dp[x],dp[p]+1);
	int ans=0;
	for (int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	printf("%d",ans);
	return 0;
```

而$O(nlogn)$的做法主要思路就是用$dp_i$记录以$i$为长度的最长上升子序列的末尾元素的最小值，以$len$记录目前的最长上升子序列，这样可以保证$dp$数组单调递增。对于每个$a_i$，如果$dp_{len}<a_i$，那么就可以暂时把$a_i$接在$dp_{len}$的后面，即$len\gets len+1,dp_{len}\gets a_i$。如果$dp_{len}>=a_i$，由于dp数组单调递增，所以我们可以通过二分法找到$a_i$应该去的位置，这里不太好理解，我尝试用一组样例给大家解释一下。

对于一个长度为6的序列：1 3 5 2 4 5，求最长上升子序列：

我们先暂时让$dp_1=a_1=1$，$len=1$，然后开始往后扫：

首先扫描$a_2$，$dp_1<a_2$，那么我们暂时把$a_2$接在$dp$数组后面，此时$dp$数组为1 3，$len=2$；

然后是$a_3$：$dp_2<a_3$，继续往后接，此时$dp$数组为1 3 5，$len=3$；

接下来是$a_4$：这个时候$dp_3>a_4$，我刚刚说了要二分：我们二分找到的是在$dp$数组中**大于等于$a_i$的最小数**~~（其实就是lower_bound）~~，原因是：我们希望每一个$dp_i$更小，这样方便我们继续往后接，而我们回顾$dp$数组的定义，有$i-1$个元素的最长上升子序列的最后一个元素一定小于有$i$个元素的最长上升子序列的最后一个元素（因为第$i$个元素实际上就接在第$i-1$个元素后面），所以我们要维护序列的单调性，于是我们找到的是大于等于$a_i$的最小数，这样$dp_i$仍可以接在$dp_{i-1}$后面。我们找到了$dp_2=3$，把$dp_2$替换为$a_4=2$，此时$dp$数组为1 2 5，$len=3$；

然后是$a_5$：$dp_3>a_5$，继续二分，找到了$dp_3=5$，把$dp_3$替换为$a_5=4$，此时$dp$数组为1 2 4，$len=3$

最后是$a_6$：$dp_3<a_6$，我们把$a_6$接在后面，此时$dp$数组为1 2 4 5，$len=4$。

最终我们得出答案，最长上升子序列的长度是4。

### 这里我想说一下，我发现很多题解都给$dp$数组赋了初值INF，然后在二分出来的数和$a_i$求最小值，我认为没必要，因为我们二分出来的结果一定大于等于$a_i$，所以直接替换就可以，这样就省掉了一个循环

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100001];
int dp[100001];
int main()
{
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	dp[1]=a[1];
	int len=1;//让dp[1]=a[1],len=1，即暂时把第1号元素放在dp数组的首位
	for (int i=2;i<=n;i++)//从第2位开始寻找
	{
		if  (dp[len]<a[i])  dp[++len]=a[i];//如果可以继续接，那就接在后面
		else
		{
			int l=1,r=len,mid;//如果不能，那就二分，原因已经在前面说的很清楚了
			while (l!=r)//二分
			{
				mid=l+r>>1;//位运算，把(l+r)的二进制向右移一位，相当于mid=(l+r)/2
				if  (dp[mid]>a[i])  r=mid;//如果dp[mid]仍大于a[i]，那就在左半边找
				else    l=mid+1;//否则在右边找
			}//整个二分过程可以用int x=lower_bound(dp+1,dp+len+1,a[i])-dp一步实现，需要包括头文件algorithm
			dp[l]=a[i];
		}
	}
	printf("%d",len);//最终的长度一定是答案
	return 0;
}
```
搞定了$LIS$后，我们再来说$LCS$，其实$LCS$的可以转换成$LIS$的，因为题目中说了这是一个$1,2,\ldots,n$的一个全排列，我们可以通过标号直接转化。

就比如样例：

$p_1$:3 2 1 4 5

$p_2$:1 2 3 4 5

我们不妨标一个号$3\gets1$,$2\gets2$,$1\gets3$,$4\gets4$,$5\gets5$

那么两个序列就变成了：

$p_1$:1 2 3 4 5

$p_2$:3 2 1 4 5

那么这两个序列的$LCS$一定是$p_1$的子序列，而$p_1$单调递增，所以只需这个序列在$p_2$中单调递增，于是转换为求此时的$p_2$数组的$LIS$问题，于是完成转化。**而且对应$p_1$的数组根本不用开，只需要开一个$map$数组记录每个数的编号即可，这样就省掉一个数组！**

那$LCS$的代码就可以直接写出来了：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100001];
int map[100001],dp[100001];//map记录每个数对应的编号
int main()
{
	int n;
	scanf("%d",&n);
	int x;
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		map[x]=i;//记录编号
	}
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		a[i]=map[a[i]];//把每个数换成对应编号，然后求LIS
	}//以下与LIS问题完全相同，不再解释
	int len=1;
	dp[1]=a[1];
	for (int i=2;i<=n;i++)
	{
		if	(dp[len]<a[i])	dp[++len]=a[i];
		else
		{
			int l=1,r=len,mid;
			while (l!=r)
			{
				mid=l+r>>1;
				if	(dp[mid]>a[i])	r=mid;
				else	l=mid+1;
			}
			dp[l]=a[i];
		}
	}
	printf("%d",len);
    return 0;
}
```
然后就可以愉快的[AC](https://www.luogu.com.cn/record/32403988)了。

---

## 作者：pmt2018 (赞：12)

大家好，我是数据结构选手，我选择用线段树写这道题。

首先考虑到$O(n^2)$的朴素dp做法的本质。

![image.png](https://i.loli.net/2019/11/10/S16xVaQl3jsWrKt.png)

如图，求``lcs``的过程本质上就找一条最长路径的过程，每次可以向右或向下走长度为$0$的边，或在决策点处向右下走一条长度为$1$的边。

我们用一个坐标$(i,j)$表示一个决策点，这里的决策点是指$(a_i==b_j)$时的点。

注意到这里两个数组都是$1-n$的排列，决策点的数量只有$n$个。

我们忽略向下向右走得过程，对某一点$(i,j)$状态方程显然

$\huge{dp_{(i,j)}=\max\limits_{i'<i,j'<j}\{dp_{(i',j')}\}}+1$

进一步考虑图形意义，可以得到

$\huge{\forall P(i_1,j)Q,(i_2,j)(i_1>i_2)\rightarrow dp[P]\ge dp[Q]}$

所以我们考虑对x轴扫描线，对y轴建一颗线段树。

若当前扫到$x_0$线段树节点内存的就是$y\in[l,r],x\in[1,x_0]$的$dp$最大值

~~其实可以用树状数组实现。~~

对于某一个决策点$(i,j)$，我们查询线段树上$y\in[1,j-1]$的最大值，并将其插入线段树。

复杂度$O(n\ \log\ n)$

这种做法更好的体现了dp的本质意义，有较强的扩展价值。

```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define fi first
#define se second
using namespace std;
typedef vector<int > vi;
typedef pair<int ,int > pii;
typedef vector<pii> vii;
const int inf=0x3f3f3f3f, maxn=50007, mod=1e9+7;
const ll linf=0x3f3f3f3f3f3f3f3fLL;
const ll P=19260817;
struct SGT{
    int t[maxn<<2];
    void pushup(int id){t[id]=max(t[id<<1],t[id<<1|1]);}
    void update(int id,int l,int r,int pos,int val){
        if(l==r){
            t[id]=val;
            return ;
        }
        int mid=l+r>>1;
        if(pos<=mid)update(id<<1,l,mid,pos,val);
        else update(id<<1|1,mid+1,r,pos,val);
        pushup(id);
    }
    int query(int id,int l,int r,int L,int R){
        if(L<=l&&r<=R){
            return t[id];
        }
        if(L>R)return 0;
        int mid=(l+r)>>1;
        int ans=0;
        if(L<=mid)ans=max(ans,query(id<<1,l,mid,L,R));
        if(R>mid) ans=max(ans,query(id<<1|1,mid+1,r,L,R));
        return ans;
    }
}T;
bool cmp(const pii& a,const pii &b ){
    if(a.first==b.first)return a.second>b.second;
    return a.first<b.first;
}//注意这里转移顺序应自下而上，防止同一列的点对转移产生影响 
int n;
int a[maxn],b[maxn];
int pos[maxn];
pii P[maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),pos[a[i]]=i;
	for(int i=1;i<=n;i++)scanf("%d",&b[i]),P[i]=mp(pos[b[i]],i);//找出所有决策点 
	sort(P+1,P+n+1);
	for(int i=1;i<=n;i++){
		int x=P[i].fi,y=P[i].se;
		int rt=T.query(1,1,n,1,y-1);
		T.update(1,1,n,y,rt+1);
	}
	printf("%d",T.t[1]);
    return 0;
}
```



---

## 作者：wbhpig (赞：11)

# P1439 【模板】最长公共子序列——题解
## 题目描述
	给出1-n的两个排列P1和P2，求它们的最长公共子序列。

## 输入输出格式
### 输入格式：
	第一行是一个数n，
	接下来两行，每行为n个数，为自然数1-n的一个排列。

### 输出格式：
	一个数，即最长公共子序列的长度

放眼望去，这道题明显是用LCS求解，于是打了一个LCS
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int a[100010];
int b[100010];
int lcs[1000010];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	//LCS
	//滚存：从n~2*n-1开始 
	for(int i=1,l=n;i<=n;i++,l--)
	{
		cin>>b[i];//在LCS中输入，节省时间
		for(int j=l;j<l+n;j++)
		{
			if(a[j-l+1]==b[i])
				lcs[j]=max(lcs[j],max(lcs[j+1],lcs[j-1]))+1;//出现公共字符
			else
				lcs[j]=max(lcs[j],max(lcs[j+1],lcs[j-1]));
		}
	}
	int s=0;
	for(int i=1;i<=n;i++)
	{
		if(s<lcs[i])
			s=lcs[i];
	} 
	cout<<s<<endl;
	return 0;
}

```
但是！！！

当[评测结果](https://www.luogu.org/record/show?rid=13617956)出现后，被惊住了——TLE

算一下时间复杂度：O(n^2)，当n=100000时肯定超时

怎么办呢？

看到题目（好心的作者直接把它放到了本题解顶端，[想看原题的点这里](https://www.luogu.org/problemnew/show/P1439)）。

它居然在单个字串内没有重复的字符！！！

不用说，用1串的序列重新给2串排序

如输入：

	5
	3 2 1 4 5
	1 2 3 4 5

根据1串与自然数的对应关系

	3 2 1 4 5
	| | | | |
	1 2 3 4 5
得到2串的新序列：3 2 1 4 5

然后求它的最长上升子序列

时间复杂度时O(nlogn)

开心！！！

在题目范围内不会TLE了！！！

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[100001],b[100001],m[100001],f[100001];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);//输入
		m[a[i]]=i;//设置对应新序列
	}
    for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);//输入
		f[i]=0x7fffffff;//初始化
	}
    int s=0;
    f[0]=0;
    for(int i=1;i<=n;i++)//求最长上升子序列
    {
        int l=0,r=s,mid;
        if(m[b[i]]>f[s])
			f[++s]=m[b[i]];
        else 
        {
        	while(l<r)
        	{   
            	mid=(l+r)/2;
            	if(f[mid]>m[b[i]])
					r=mid;
            	else 
					l=mid+1; 
        	}
        	f[l]=min(m[b[i]],f[l]);
        }
    }
    cout<<s<<endl;//输出
    return 0;
}
```
然后总而言之言而总之幸运地通过了^_^

最后推一下本人的[洛谷博客](https://wbhpig.blog.luogu.org/)，可能龟速更新，但希望大家能够与我一同进步，一同AC全场^_^

---

## 作者：天泽龟 (赞：10)

 被luogu群里面的dalao坑了……我本来想找LIS模板结果他说**LCS模板转换一下就是LIS**了，害得我根本没有考虑好LCS与LIS的**转换关系**就交了，结果就过了一个点qwq。
 
 ### LCS转LIS条件也确实很简单：一个数组先用编号i来映射a[i]，再通过这种映射关系转换b[i]，从而使b[i]有序，通过LIS可得出结论。
 
我这样一讲觉得一定很多人都会云里雾里~~，一脸蒙蔽，因为我这种蒟蒻第一眼也没理解~~。这时候就要
## 手动模拟一组数据来边观察变分析了！


------------


我们取

- 8
- 3 7 8 5 6 4 1 2
- 8 2 4 3 6 5 7 1  
- 答案是 3（3,5,1或3,7,1等）

因为LCS要控制对应数字相同，顺序相同，**两个变量不确定时候我们就控制一个**，因为这是1~n的全排列，数字虽然确定是1~n但却不对应，那么当然想到用**map这种映射的方法**，把a[i]与b[i]每一个数字都通过同一个映射关系对应，就能控制了**数字相同**：
```
a[i]   a1[i]
3-		1
7-		2
8-		3
5-		4
6-		5
4-		6
1-		7
2-		8
```
 现在a[i]与a1[i]已经通过确立了一个**映射关系**变得有序了（什么是映射关系？3对应1,7对应2,8对应3……这就是我们这题确立的对应关系，具体有什么用待会讲到），**我们再把b[i]与b1[i]用这种关系建立起来**：

```
b[i]   b1[i]
8-		3
2-		8
4-		6
3-		1
6-		5
5-		4
7-		2
1-		7
```
你看，既然a[i]和b[i]用了同一种映射关系变成了a1[i]和b1[i]，那么：
### 只需求出a1[i]和b1[i]的LCS不就可以了吗OwO?
由于映射关系相同，变化出来的新数组已经控制了数字的相等，现在只要顺序都是不下降的就好了。又因为已经控制了a1[i]是升序（现在知道为啥映射关系控制是他的编号对应了吧），所以：
## 就是求b1[i]的最长不下降子序列！
对于3 8 6 1 5 4 2 7，用LIS走一遍就好了。

这就是LCS转LIS的思路全过程，所以说搞不懂的题手动摸一个数据就可以方便理解的。

具体的LIS可以去导弹拦截那题学学nlogn的方法，我这里就用树状数组过了（毕竟这题难点在于转换的部分），贴上丑陋的代码。
```cpp
#include <iostream>
#include<algorithm>
using namespace std;
struct node{
	int a;
	int b;
}a[200000];
int n,ans,t[200000],f[100000],ha[100000];
bool cmp(node a,node b)
{
	return a.a<b.a;
}

int find(int a)
{
	int k=a,p=0;
	while (k>0){
		p=max(p,t[k]);
		k-=(-k)&k;
//		cout<<k<<endl;	
	}
	return p;
}

void update(int a,int p)
{
	int k=a;
	while (k<=100000){
		t[k]=max(t[k],p);
		k+=(-k)&k;	
	} 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].a,ha[a[i].a]=i;
	for (int i=1;i<=n;i++) cout<<ha[a[i].a]<<" ";
	cout<<endl;
	for (int i=1;i<=n;i++) cin>>a[i].b; 
	int l=1;
	for (int i=1;i<=n;i++) a[i].b=ha[a[i].b];  //核心转换语句
	for (int i=1;i<=n;i++)
	{
		f[i]=find(a[i].b)+1;
		update(a[i].b+1,f[i]);
		ans=max(ans,f[i]);
	}
	cout<<ans<<endl;
	return 0;
}



```

---

## 作者：subarude (赞：10)

**求两个序列的$LCS$的长度**

数据范围**1e5**

----------------------------

假设我们有两个序列为 `a[]` 和 `b[]`

其实题目要求的就是**在 `b[]` 中找到一个最长的子序列使得这个子序列在 `a[]` 中对应的下标单调递增**

![](https://cdn.luogu.com.cn/upload/image_hosting/wf36jhbf.png)

**_上图为合法的情况_**

![](https://cdn.luogu.com.cn/upload/image_hosting/ndn4jqke.png)

**_上图为不合法的情况_**


然而暴力枚举这个子序列显然是很蠢的做法

要怎么办呢$\texttt{qwq}$

----------------------------

我们来看看这个子序列有什么要求

先定义两个数组

`c[]` 表示这个子序列

`posa[]` 表示一个数在 `a[]` 中的下标，即 `posa[a[i]] = i`

`c[]` 需要满足的条件为

- 是 `b[]` 的子序列
- 在 `a[]` 中的对应下标单调递增，即对于任意的满足 `i < j` 的 `c[i] c[j]`，都有 `posa[c[i]] < posa[c[j]]`
- `c[]` 的长度最大

--------------------------

刚才的做法我们先满足了第一个条件

现在我们考虑先满足第二个条件

$\text{在a[]中对应的下标单调递增}$

我们珂以发现在 `b[]` 中选择的数的大小并不重要

所以如果我们把 `b[]` 这个数组中的元素直接改为它在 `a[]` 中的下标

更改后的 `b[]` 数组的任意一个上升子序列都满足了我们所说的第二个条件

又因为我们要满足这个子序列最长的条件

所以答案即为更改后的 `b[]` 的 $LIS$

珂以$O(nlogn)$实现


code：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int read() { // 慢读
    int op = 1, a = 0; char c = getchar();
    for (; c < '0' || c > '9'; c = getchar()) if (c == '-') op = -1;
    for (; c >= '0' && c <= '9'; c = getchar()) a = a * 10 + c - '0';
    return op * a;
}

const int maxn = 1e5 + 5;
int n, a[maxn], b[maxn];
int t[maxn];
int lis[maxn], r;

int main() {
    n = read();
    for (int i = 1; i <= n; i++) { a[i] = read(), t[a[i]] = i; } // t[]数组即为上面说到的posa[]
    for (int i = 1; i <= n; i++) { b[i] = read(), b[i] = t[b[i]]; } // 把b[]中的元素替换成它在a[]中的下标
    for (int i = 1; i <= n; i++) { // 然后求最长上升子序列即可
        int pos = lower_bound(lis + 1, lis + r + 1, b[i]) - lis;
        lis[pos] = b[i], r = max(r, pos);
    }
    cout << r << '\n';
    return 0;
}

```

_by subarude_

---

## 作者：shadowice1984 (赞：9)

写一发树状数组题解

先想一个朴素的dp

设上边的数组为a，下面的数组为b

设dp[j]为最长公共子序列的结束元素在b中位置为j时

这个最长公共子序列的长度

那么我们可以想到一个朴素的想法

设pos【i】表示值为i的元素在b中的位置

枚举每一个小于 pos【a【i】】的j

然后更新dp【pos【a【i】】；

//这里默认你理解啥叫滚动数组优化

可以看到，刚才的操作是在求前缀最小值而且更改值的操作只升不降

好像可以用树状数组维护

然后就可以啦

上代码~


```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int n;
    struct treearray//树状数组
    {
        int ta[200010];
        inline void ub(int& x){x+=x&(-x);}
        inline void db(int& x){x-=x&(-x);}
        inline void c(int x,int t)
        {for(;x<=n;ub(x))ta[x]=max(ta[x],t);}
        inline int ma(int x)
        {int res=0;for(;x>0;db(x))res=max(res,ta[x]);return res;}
    }ta;
    int a[100010];
    int b[100010];
    int pos[100010];
    int main()
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)scanf("%d",&a[i]);
        for(int i=1;i<=n;i++){scanf("%d",&b[i]);pos[b[i]]=i;}
        for(int i=1;i<=n;i++)
        {
            int now=ta.ma(pos[a[i]]);//寻找前缀最大值
            ta.c(pos[a[i]],now+1);//更新
        }
        printf("%d",ta.ma(n));return 0;//拜拜程序~
}
```

---

## 作者：XHCuteDog (赞：8)

前台查看
|
H1
H2
H3
H4
H5
H6
|
|
|
|

1
# 这道题虽然是道模板题,but
2
## 异常套路！！！！！！
3
#### 先见说一说刚拿到这道题时候的想法吧，因为这是学校训练时候的老师发的题，做这道题之前做过一道类似的求最长公共子序列的题
4
###### 有想法的和我一样的蒟蒻可以先看一看```
5
## 最长公共子序列
6
## 【问题描述】
7
## 一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>
8
 
9
### 例如，序列Z=<B,C,D,B>是序列X=<A,B,C,B,D,A,B>的子序列，相应的递增下标序列为<2,3,5,7>。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X=<A, B, C, B, D, A, B>和Y=<B, D, C, A, B, A>，则序列<B, C, A>是X和Y的一个公共子序列，序列<B, C, B, A>也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。
10
### 给定两个序列X=<x1, x2, …, xm>和Y=<y1, y2, … , yn>，要求找出X和Y的一个最长公共子序列。
11
### 【输入】
12
### 输入文件共有两行，每行为一个由大写字母构成的长度不超过200的字符串，表示序列X和Y。
13
### 【输出】
14
### 输出文件仅一行为一个非负整数，表示所求得的最长公共子序列的长度，若不存在公共子序列，则输出文件仅有一行输出一个整数0
15
### 【样例】
16
### 输入：
17
### abcdefghijklmn
18
### kxmdyfliju
19
### 输出：
20
### 4
21
​
22
```
23
```
24
## 如果你已经很轻松的解决了上面的题，那么恭喜你！！！
25
# 你可能会被它误导！
26
### 本蒟蒻就是如此，对这道题我进行了四次修正，我称之为基准无优化版，转字符无优化版，空间优化版，以及最终版本！
27
#### 话不多说，上代码，通过在四段代码中插入的讲述，我想作为蒟蒻，应该能成为一名小小牛……
28
## 基准无优化版……
29
###这道题虽然是道模板题,but
####异常套路！！！！！！
####先见说一说刚拿到这道题时候的想法吧，因为这是学校训练时候的老师发的题，做这道题之前做过一道类似的求最长公共子序列的题

####有想法的和我一样的蒟蒻可以先看一看```

####最长公共子序列
#####【问题描述】
###一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>
###例如，序列Z=<B,C,D,B>是序列X=<A,B,C,B,D,A,B>的子序列，相应的递增下标序列为<2,3,5,7>。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X=<A, B, C, B, D, A, B>和Y=<B, D, C, A, B, A>，则序列<B, C, A>是X和Y的一个公共子序列，序列<B, C, B, A>也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。
###给定两个序列X=<x1, x2, …, xm>和Y=<y1, y2, … , yn>，要求找出X和Y的一个最长公共子序列。
###【输入】
###输入文件共有两行，每行为一个由大写字母构成的长度不超过200的字符串，表示序列X和Y。
###【输出】
###输出文件仅一行为一个非负整数，表示所求得的最长公共子序列的长度，若不存在公共子序列，则输出文件仅有一行输出一个整数0
###【样例】
###输入：
###abcdefghijklmn
###kxmdyfliju
###输出：
###4
###如果你已经很轻松的解决了上面的题，那么恭喜你！！！
###你可能会被它误导！
###本蒟蒻就是如此，对这道题我进行了四次修正，我称之为基准无优化版，转字符无优化版，空间优化版，以及最终版本！
###话不多说，上代码，通过在四段代码中插入的讲述，我想作为蒟蒻，应该能成为一名小小牛……

##基准无优化版……
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=8000;
string x,y; 
int a[maxn],b[maxn];//利用上面那道题的思路.
int f[maxn][maxn];//存储i位X字符串和j位Y字符串的公共最长子序列的长度
int main()
{
    //freopen("numlcs.in","r",stdin);
    //freopen("numlcs.out","w",stdout);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    //简单的读入
    for(int i=0;i<=n;i++)
      f[i][0]=0;
    for(int j=0;j<=n;j++)
      f[0][j]=0;
    //当x,y任意一个字符串的长度为零时候，那么公共子序列即为零。
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      {
        if(a[i]==b[j])//若此时俩字符串的末尾字符相同，则冻柜方程容易写出
          f[i][j]=f[i-1][j-1]+1;
        else
          f[i][j]=max(f[i-1][j],f[i][j-1]);
          //如果不相等，那么分为两种情况，1字符串前移一位，2号不变时候的公共子序列长度和反之的长度比较，取长者。
      }
      printf("%d",f[n][n]);//结果就出现在了f[n][n]啦！果断输出
      //system("pause");
      return 0;
}
```

###上面代码看着没什么毛病，但是为什么说是不成熟的呢？

##问题在于冻柜方程以及对问题的分析。
#至于第二种做法转字符版本，，，，只是对输入进行了处理，就不再赘述了
```cpp

    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    for(int i=1;i<=n;i++)
    {  
      x+=(a[i]+'0');
      y+=(b[i]+'0');
    }
    string c,v;
    c=x;
    v=y;       
    int len1=c.length()-1;
    int len2=v.length()-1;
    for(int i=0;i<=len1;i++)
      f[i][0]=0;
    for(int j=0;j<=len2;j++)
      f[0][j]=0;
    for(int i=1;i<=len1;i++)
      for(int j=1;j<=len2;j++)
      {
        if(c[i]==v[j])
          f[i][j]=f[i-1][j-1]+1;
        else
          f[i][j]=max(f[i-1][j],f[i][j-1]);
      }
      printf("%d",f[len1][len2]);
##下面才是大场面的开始……
cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    for(int i=0;i<=n;i++)
      f[i%2][0]=0;
    for(int j=0;j<=n;j++)
      f[0][j]=0;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      {
        if(a[i]==b[j])
          f[i%2][j]=f[(i+1)%2][j-1]+1;
        else
          f[i%2][j]=max(f[(i+1)%2][j],f[i%2][j-1]);
      }
      printf("%d",f[n%2][n]);
      ```
###在这段代码中对冻柜转移方程虽然没有进行调整，但是对空间进行了一定程度的压缩，对本题n<=100000的大数据有了一战之力

###那么真正的地方begin！
#先来举一个栗子吧:
#[思路讲解]
##在读入第一行数据时候，我们使用一个数组A[i]记录读入的第X个数据i的位置，记录其是X，那么对于第一行数据A[i]的值是单调递增的。说到这里，有些人应该也已经有一些思路了，如果你走到了这里似懂非懂，我建议你最好先自己思考，不妨去做一做洛谷的友好城市这道题，相信你会开放你的思路。
##ok，下面，在读入第二行数据时候，根据所读入的数字，在A数组中找到其在第一行数据中的位置，进行记录，
##用样例数据来讲：
##5
##第一行数据    3	2	1	4	5
##第二行数据	1	2	3	4	5
##A数组分别这样记录：A[3]=1,A[2]=2,A[1]=3,A[4]=4,A[5]=5;
##那么在第二行数据读入时,根据其数字可以在A数组中得到这样一个序列：
##3 2 1 4 5 注意！这个3 2 1 4 5并非是上方数据，仅仅是数据设计的巧合罢了，
##对于这个新的数列，我们在其中求最长上升序，其长度就是我们的目标。
##之所以能这么说，大家应该注意题中告诉我们的一个看似不重要又极其重要的条件：每行为n个数，为自然数1-n的一个排列。
##这说明，上下两行数字数量相等，且每行数据不存在重复数据，因此说我们上面的思路是可行的
##说了这么多，是时候上AC代码啦（蒟蒻哭泣）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=300000;
int f[maxn],a[maxn];
int n;
int find(int l,int r,int x)
{
    int ans=0;
    while(l<=r)
    {
       int mid=(l+r)/2;
       if(x<f[mid])
         ans=mid,r=mid-1;
       else
          l=mid+1;
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
       int x;
       scanf("%d",&x);
       a[x]=i;
    }
    memset(f,0x3f,sizeof(f));
    int len=0;
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        int y=a[x];
        int k=find(1,len+1,y);
        f[k]=y;
        if(k>len)
           len++;
    }
    printf("%d",len);
    return 0;
}
```
最后留下一个极棒的建议

一定要写好二分！！！！！
飘过链接博客

---

## 作者：Krystallos (赞：7)

这道题其实是一个变相的最长上升子序列。

~~本来想到lg找一道最长上升/下降子序列做的结果找到了这道题~~

读完题目我们可以发现，题中的两个序列均为全排列。所以我们可以找出一个序列中的每一个元素在另一个序列中的位置。最后的答案就是这个处理过的序列的最长上升子序列。

因为公共子序列的每一个元素在这两个序列中的位置都是递增的，所以当我们构造出表示一个序列中的每一个元素在另一个序列中的位置的序列后，公共序列的每个元素所在的位置在这个新构造出来的序列中的值一定递增。

于是我们就需要用$O(n\ log\ n)$的最长上升子序列来做这道题。既然这样，代码就很好写了：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int nn = 1e6 + 5;
int n, a[nn], book[nn], f[nn], len = 0;
int main() {
	scanf("%d", &n);
	for (int i = 1, x; i <= n; i++) {
		scanf("%d", &x);
		book[x] = i;//标记位置
	}
	for (int i = 1, x; i <= n; i++) {
		scanf("%d", &x);
		a[i] = book[x];//置换序列
	}
	f[++len] = a[1];
	for (int i = 2; i <= n; i++) {//最长上升子序列基本操作
		if (a[i] > f[len])
			f[++len] = a[i];
		else {
			int p = upper_bound(f + 1, f + len + 1, a[i]) - f;
			f[p] = a[i];
		}
	}
	printf("%d", len);
}
```

---

## 作者：孑彧 (赞：6)

# P1439 [模板]最长公共子序列 解题报告

### 题意

求两个长度为n的序列的最长公共子序列（要求$O(nlogn)$）

### 思路

刚看到这个题：？？？这个东西可以用这种复杂度来做？？？

第二眼：等等，这两个序列的长度是一样的？

最后：这不是友好城市么？？

[这里]: https://www.luogu.org/problem/P2782

众所周知，~~友好城市是一道黄题~~，它可以用一个最长公共子序列来做，也可以根据对应关系，通过一个最长不下降子序列来做，而又众所众所周知的是，一个最长不下降子序列可以从一个$O(n^2)$通过记录当前长度的最小值来把它优化到$O(nlogn)$，所以这个题我们就可以用一个类似的方法来记录一下它的对应关系，然后就可以去跑一个最长不下降子序列来做啦！

是不是很简单！！！

### 代码

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,a[1000100],b[1000100],c[1000100],d[1000100];
int f[1000100],r[1000100];
int find(int z,int o,int x){
	int mid=(o+z)/2;
	if(x<r[1])
	return 0;
	if(z==o){
		return z-1;
	}
	if(r[mid]==x)
	return mid-1;
	if(x>r[mid]){
		return find(mid+1,o,x);
	}
	if(x<r[mid]){
		return find(z,mid,x);
	}
}
int main(){
	memset(r,127,sizeof(r));
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&b[i]);
	}
	for(int i=1;i<=n;i++){
		c[b[i]]=i;
	}
	for(int i=1;i<=n;i++){
		d[i]=c[a[i]];
	}
	for(int i=1;i<=n;i++){
		int fx=find(1,n,d[i]);
		f[i]=fx+1;
		if(d[i]<r[fx+1])
			r[fx+1]=d[i];
	}
	int maxx=0;
	for(int i=1;i<=n;i++){
		if(f[i]>maxx)
		maxx=f[i];
	}
	printf("%d",maxx);
}

```

卑微HYBJ在线求赞

---

## 作者：SovietPower✨ (赞：6)

感觉前面写的略乱。。总结一下


数据规模最大为30万，而对于一般LCS复杂度都在n^2，是没有nlogn的，所以肯定要换一种思路。


注意题中的“保证每个序列中的各个元素互不相同”，可以将每个a[i]映射成 i (或是其他的数，保证递增以方便求)，那如果想构成公共子序列，对于同样映射后的每个b[i]的值r[i]，r[i]一定在序列a的映射中出现过(a中存在该元素)，且r一定要是递增的(保证出现顺序一致 公共)。那么问题就转化为求r[i]的最长上升子序列。


(总体思路其实同P1439，不过数据规模更大)


求最长上升子序列LIS有 O(nlogn) 做法 符合题目要求，在此不赘述，可以看 http://blog.csdn.net/wall\_f/article/details/8279733 ;



对于映射可以用map(偷懒)或是Hash，当然Map( 3799 ms )效率比Hash( 880 ms )低很多，但是方便


Map实现：

```cpp
#include<map>
#include<cstdio>
#include<cctype>
using namespace std;
const int N=300005;

int n,m,a,b,f[N],len;
map<int,int>r;

inline int read()
{
    int now=0;bool f=0;char c=getchar();
    for(;!isdigit(c);c=getchar())
      if(c=='-') f=1;
    for(;isdigit(c);c=getchar())
      now=(now<<3)+(now<<1)+c-'0';
    return f?-now:now;
}

int Search(int x)
{
    int l=1,r=len;
    while(l<r)
    {
        int m=l+r>>1;
        if(x>f[m])
          l=m+1;//缩小左边界
        else
          r=m;
    }
    return l;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
      a=read(),r[a]=i;
    for(int i=1;i<=m;++i)
    {
        b=read();
        int x=r[b];
        if(!x) continue;//没有该元素，不可能构成答案，跳过
        if(x>f[len])
            f[++len]=x;
        else
        {
            int p=Search(x);//二分查找f中第一个小于等于x的元素的位置，替换，优化LCS的关键
            f[p]=x;
        }
    }
    printf("%d",len);
    return 0;
}
```
Hash：

```cpp
#include<cstdio>
#include<cctype>
using namespace std;
const int N=300005,mod=1000007;
const int seed[12]={13,17,31,37,131,133,137,171,313,233,1313,2333};

int n,m,a,b,f[N],len,Hash[mod+10],val[mod+10];

inline int read()
{
    int now=0;bool f=0;char c=getchar();
    for(;!isdigit(c);c=getchar())
      if(c=='-') f=1;
    for(;isdigit(c);c=getchar())
      now=(now<<3)+(now<<1)+c-'0';
    return f?-now:now;
}

int GetHash(int x)
{
    long long res=1;
    int t=0;
    while(x)
      res=(res+(long long)x*seed[t++]%mod)%mod,x/=10;//减少冲突可能性
    return res;
}
void Insert(int x,int v)
{
    int now=GetHash(x);
//    printf("x:%d r:%d\n",x,now);
    while(Hash[now])//拉链法
    {
        ++now;
        if(now==mod) now=1;
    }
    Hash[now]=x;
    val[now]=v;//映射后的值
}
int Find(int x)
{
    int now=GetHash(x);
//    printf("x:%d r:%d\n",x,now);
    while(Hash[now]&&Hash[now]!=x)
    {
        ++now;
        if(now==mod) now=1;
    }
    if(Hash[now]==x) return val[now];//a的映射中存在x，返回其值
    return 0;//不存在该元素
}
int Search(int x)//同样的二分查找
{
    int l=1,r=len;
    while(l<r)
    {
        int m=l+r>>1;
        if(x>f[m])
          l=m+1;
        else
          r=m;
    }
    return l;
}

int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
      a=read(),Insert(a,i);
    for(int i=1;i<=m;++i)
    {
        b=read();
        int x=Find(b);
//        printf("i:%d val:%d\n",GetHash(b),x);
        if(!x) continue;
        if(x>f[len])
            f[++len]=x;
        else
        {
            int p=Search(x);
            f[p]=x;
        }
    }
    printf("%d",len);
    return 0;
}
```

---

## 作者：单曦增 (赞：4)

最长公共子序列，首先可以想到$n^2$的dp，但是这个dp是要被卡掉的，所以我们要进行优化。

首先观察$n^2$的dp方程，$f[i][j]=max(f[i-1][k])+1,k<j$题目里说到序列是1到n的一个排列，所以两个序列中的元素可以产生两两映射，在转移时可以用线段树维护前面的值，再将值插入到线段树中，时间复杂度$O(n log n)$。

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int Maxn=110000;
int tl[Maxn*4],tr[Maxn*4],tn[Maxn*4],bj[Maxn*4];
int a[Maxn],b[Maxn],n,x,y,z,ans;
void build(int l,int r,int root)
{
	tl[root]=l;
	tr[root]=r;
	if(l==r)
		return;
	int mid=l+r>>1;
	build(l,mid,root<<1);
	build(mid+1,r,(root<<1)|1);
}
int search(int l,int r,int root)
{
	int lc=tl[root],rc=tr[root],mid=lc+rc>>1;
	if(l<=lc&&r>=rc)
		return tn[root];
	if(bj[root])
	{
		tn[root<<1]=tn[(root<<1)|1]=tn[root];
		bj[root]=0;
	}
	int ans=0;
	if(l<=mid)
		ans=search(l,r,root<<1);
	if(r>mid)
		ans=max(ans,search(l,r,(root<<1)|1));
	return ans;
}
void change(int l,int root,int k)
{
	int lc=tl[root],rc=tr[root],mid=lc+rc>>1;
	tn[root]=max(tn[root],k);
	if(lc==rc)
		return;
	if(l<=mid)
		change(l,root<<1,k);
	else
		change(l,(root<<1)|1,k);
}
int main()
{
//	freopen("2.in","r",stdin);
	scanf("%d",&n);
	build(1,n,1);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		b[x]=i;
	}
	for(int i=1;i<=n;i++)
	{
		x=a[i];
		y=b[x];
		z=search(1,y,1)+1;
		ans=max(ans,z);
		change(y,1,z);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：凯特琳 (赞：4)

正常来讲LIS复杂度近乎O(N^2)；

然而 做题发现了一种O(N\*log2N)的做法，这个做法奇奇怪怪，但也是可以理解的；

先上题：

给出1-n的两个排列P1和P2，求它们的最长公共子序列。

输入输出格式 Input/output

输入格式：

第一行是一个数n，

接下来两行，每行为n个数，为自然数1-n的一个排列。

输出格式：

一个数，即最长公共子序列的长度

输入输出样例 Sample input/output

样例测试点#1

输入样例： 在线IDE

5 3 2 1 4 5

1 2 3 4 5

输出样例：

3
说明 description

【数据规模】

对于50%的数据，n≤1000

对于100%的数据，n≤100000




ps：第一眼看到N个数的两个全排列 求LCS有没有感觉和数论挂边？？？

看看这个数据范围吧 N<=10^5;

如果用普通的LCS 或者排序后求LIS ，不管空间怎么优化，你时间肯定得爆吧？

先介绍50分算法：

1.
走LCS路线，F数组开滚动的，完美的解决了空间的问题；代码：





```cpp
program exam1;
var a,b:array[1..100000]of longint;
var m,n,l,i,j,ans:longint;
var f:array[0..3,0..100000]of longint;
function max(s,k:longint):longint;
begin
max:=s;
if k>s then
max:=k;
end;
begin
read(n);
for i:=1 to n do
read(a[i]);
for i:=1 to n do
read(b[i]);
for i:=1 to n do
for j:=1 to n do
if (a[i]=b[j])
then f[i mod 4,j]:=f[(i-1) mod 4,j-1]+1
  else f[i mod 4,j]:=max(f[(i-1) mod 4,j],f[i mod 4,j-1]);
writeln(f[n mod 4,n]);
end.
```
2.
走LIS路线，把第一个全排列的数字 认为先出现的大于后出现的，那么可以用类似桶的思想，把每个数第几个出现的记录在a数组里

在把b数组的元素按照a的对应法则 转换过来 求LIS，也漂亮的避开了空间的问题：附上代码：


```cpp
   program exam1;
    var a,b:array[1..100000]of longint;
    var m,n,l,i,j,ans:longint;
    var f:array[0..100000]of longint;
    function max(s,k:longint):longint;
    begin
    max:=s;
    if k>s then
    max:=k;
    end;
    begin
    read(n);
    for i:=1 to n do
    begin
    read(l);
    a[l]:=i;
    end;
    for i:=1 to n do
    read(b[i]);
    for i:=1 to n do
    b[i]:=a[b[i]];
    for i:=1 to n do
    f[i]:=1;
    for i:=2 to n do
    for j:=1 to i-1 do
    if (b[j]<b[i])
    then f[i]:=max(f[j]+1,f[i]);
    for i:=1 to n do
    if f[i]>ans then
    ans:=f[i];
    writeln(ans);
    end.
```
那么现在讲AC代码：也是LIS的思路：像上面的初始化数组b之后，用一种O(N\*log2N)的算法：
开一个栈，每次读入一个元素，如果比栈尾元素大，那么直接入栈，如果比栈尾元素小，那么替换掉第一个比他大的元素，可以用单调队

列来写。最后统计栈中有几个元素，即为LIS答案。不要问我为什么。我也不懂，反正代码、思想都简单，记下来就好。

代码：program exam1;




```cpp
var a,b:array[1..100000]of longint;
var m,n,l,i,j,t,w,ans:longint;
var f:array[0..100000]of boolean;
procedure search(s:longint);
var i,j:longint;
begin
for i:=s+1 to w do
if f[i] then
begin
f[i]:=false;
break;
end;
end;
begin
read(n);
for i:=1 to n do
begin
read(j);
a[j]:=i;
end;
for i:=1 to n do
read(b[i]);
for i:=1 to n do
b[i]:=a[b[i]];
t:=b[1];
f[b[1]]:=true;
w:=b[1];
for i:=2 to n do
begin
f[b[i]]:=true;
if b[i]<t then
begin
f[t]:=false;
t:=b[i];
end
else
if b[i]>w then
w:=b[i]
else search(b[i]);
end;
for i:=t to w do
if f[i] then inc(ans);
writeln(ans);
end.
```
最后：力挺P党

---

## 作者：Npse_D (赞：4)

利用**序列都是从1~n的自然数**这个特性，我们可以把其中一个序列**映射成1~n的自然数等差数列**，那么另一个序列根据该映射变成另一个序列，显然，在第二个序列里面找第一个序列的最长公共子序列，就是在第二个序列里面找最长上升子序列。这个问题的转化使得求解序列在求解时单调递增，那么可以使用二分优化了。由于输入数据是10w左右，可以考虑读入优化/关闭同步流/printf。

```cpp
#include<bits/stdc++.h>
#define Forn for(register int i=1;i<=n;i++)
using namespace std;
int f[100005],a[100005],b[100005],lit[100005];
int main(){
    int n,cnt=0,k;
    cin>>n;
    Forn cin>>a[i];
    Forn cin>>b[i];
    Forn f[a[i]]=i;
    Forn b[i]=f[b[i]];
    Forn{
        if(lit[k=lower_bound(lit,lit+cnt,b[i])-lit]>=b[i])lit[k]=b[i];
        else lit[cnt++]=b[i];
```
}//该LIS是浙大的模板。
    cout<<cnt;

}
注意：LCS转LIS+二分优化，当且仅当两序列不是同一集合的时候可行。若两序列相同，就算不是等差数列，或者单个序列中有相同元素，也可以使用，但是那样你需要思考一下：怎样写一个可以判重的映射。


---

## 作者：hsfzLZH1 (赞：4)

观察此题的数据范围，如果使用最长公共子序列的传统DP算法（时间复杂度为O(N^2)）肯定会超时，所以，我们需要另寻他路。

考虑此题的另一个条件，两个序列都为1...n的一个排列，考虑特殊情况：

如果其中一个排列为(1,2,...,n)，另一个排列为(a1,a2,...,an)，那么对于两者的任意公共子序列(a[b1],a[b2],...,a[bk])，必有a[b1]<a[b2]<...<a[bk]，则两序列的最长公共子序列为排列(a1,a2,...,an)的最长上升子序列。

那么，对于两个一般的排列(a1,a2,...,an)和(b1,b2,...,bn)的最长公共子序列怎么求？

我们定义映射f(ai)=i，那么两个排列可以转换为(f(a1),f(a2),...,f(an))=(1,2,...,n)和(f(b1),f(b2),...,f(bn))，我们进行这样的转换之后，就把本题转换为求最长上升子序列的长度的题目了。

最长上升子序列存在O(N log N)时间复杂度的算法，概述如下：

考虑两个数a[x]和a[y]，若x<y且g[x]==g[y]，那么在转移的过程中，选择a[x]更有潜力（证明是显而易见的，可以自己设计几组数据加深理解），可以获得最优的值，所以当g数组的值一样时，应选择最小的数。

按照g[i]==k分类，记录g[i]==k的所有i的最小值，g有两个特点：

1)f[i]在计算过程中单调不升

2)f数组是有序的，g[i]<=g[i+1]

根据这些性质，可以方便地求解：

1)设当前求出的LIS（最长上升子序列的简称，以后同此）长度为ans（初始值为1），当前元素为a[x]

2)如果a[x]>g[ans]，直接加入f数组的末尾，且ans++；否则在f数组中二分查找，找到第一个比a[x]小的数字g[k]（使用二分查找实现），g[k+1]=a[x]，这样做保证a[x]<=g[k+1]（根据性质1，2）

3)最后的ans即为答案

总的时间复杂度为处理映射O(N)，求LIS长度为O(N log N)，总的时间复杂度为O(N log N)，如果常数不是特别大的话可以通过此题。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,a[maxn],f[maxn],g[maxn],ans=1,cur;
inline int bs(int k,int l,int r)//二分查找
{
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(k>=g[mid])l=mid+1;
        else r=mid;
    }
    return l;
}
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)scanf("%d",a),f[a[0]]=i;//建立映射关系
    for(register int i=0;i<n;i++)scanf("%d",a+i),a[i]=f[a[i]];//输入并同时处理映射
    g[1]=a[0];
    for(register int i=1;i<n;i++)
    {
        if(g[ans]<a[i])cur=++ans;
        else cur=bs(a[i],1,ans+1);
        g[cur]=a[i];
    }
    printf("%d\n",ans);
    return 0;
}
```
最后我们来总结一下解决此类题目（有现成的算法，但是时间复杂度较高，需要通过限制较为严格的特殊条件，需要转化数学模型求解，类似题目为无序字母对）的思路：

1)观察题目的数据范围，看传统思路算法能否通过

2)从题目给出的特殊条件入手，转化数学模型（从一个经典模型转化为另一个经典模型，常用方法为映射和图论中的点化边），降低求解算法的时间复杂度


---

## 作者：李白莘莘学子 (赞：3)

# LIS最长上升子序列讲解&&洛谷P1439 【模板】最长公共子序列 题解

开始瞎扯：

LCS：最长公共子序列
LIS：最长上升子序列
LCIS：最长公共上升子序列

以及许许多多同类的搞不清的东西。。。。。。

 

## LIS：

最长上升子序列。

例如：

1 5 3 6 3 3 6 2中

能够组成的最长上升子序列长度为5（1 3 3 3 6）。

1 7 3 5 9 4 8中最长上升子序列长度为4（1 3 4 8,1 3 5 8，1 3 5 9.。。。）

有可能很多。

重点来了（敲！）如何求呢？

 

### 动态规划DP：

动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。

可以用动态规划求解的问题要满足无后效性原则，也就是你可以整段问题划分成子阶段，或者子状态，每一个状态都可以满足由之前的状态推得，并且之前的状态在已经确定最优解的情况下在后面的状态或者新的元素被考虑到时没有任何影响，那么这个题就可以用动态规划求解。

我们对LIS进行分析，很容易发现：

我们从第一个元素往后推，很明显前面最长子序列不会对后面的答案造成影响。

那么考虑用动态规划来做：

## 思路及推导：

从**0**开始想思路：

现在数列中只有1个元素：2，那么自然的，LIS长度为1。

加入1个元素，接着可以想，这个元素会对结果造成什么影响呢?

如果这个元素大于等于2的话，很明显最长上升子序列的长度就变为2了。

如果这个比2小，那么最长上升子序列长度还是1，只不过变成了两个了。

我们设加入的元素为0（比2小）放在序列里。

2个元素还是不能体现出规律来，我们继续：

设再加入个1:，那么序列变成2 0 1。

人眼观察，可以得知最长上升子序列变成了2。

#### 为什么会这样呢？

1比0大，而0在1之前序列中，我们我们可以考虑“接上”以0为末尾数的最长子序列，然后加入当前的这个数，使序列的长度+1。以0为末尾数的最长子序列很明显是在满足上升这一条件的情况下到当前元素最长的子序列。

于是我们按照思路来设：dp[i]表示以第i个数为结尾的，最长上升子序列的长度。

要找到当前元素前面的序列中最长的子序列，只需要在之前的，满足结尾元素小于当前元素的，dp数组中寻找一个maxdp值。

找到后，我们把当前这个数接上去（++）。

如果前面的数都不如当前数小，那么这个数只能从自己开始另起一个子序列了。长度为1，dp值也就为1。

综上可得：

dp[i]=max(dp[j])+1,a[j]<=a[i]且,0<j<i.

i需要从开始到结尾O（n）枚举一遍，j需要从1到i枚举一遍。复杂度为双层for的O（n^2）

例题：

有n个数，求LIS：

输入：第一行n的值，第二行为n个数

输出：LIS长度。

代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define ll long long
using namespace std;
int read()
{
    int ans=0;
    char ch=getchar(),last=' ';
    while(ch<'0'||ch>'9')last=ch,ch=getchar();
    while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+ch-'0',ch=getchar();
    return last=='-'?-ans:ans;
}
int dp[100],a[100];
int n;
//1 7 3 5 9 4 8
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
    }
    dp[1]=1;
    for(int i=2;i<=n;i++)
    {
        int maxn=-10;
        for(int j=1;j<i;j++)
        {
            if(a[j]<=a[i])maxn=max(maxn,dp[j]);
        }
        dp[i]=maxn==-10?1:maxn+1;
    }
    int maxn=-10;
    for(int i=1;i<=n;i++)
    {
        maxn=max(dp[i],maxn);
    }
    printf("%d",maxn);
    return 0;
}
```

 

P1439 【模板】最长公共子序列
思路：看似是求公共子序列，实际上我们可以做这样1个转化：

我们把上面的序列顺次编号：




1  2 3  4  5

这样就变成的一个顺次递增的序列，并且我们获得了原序列和编号后的序列的转换法则：3对1,2对2,1对3。

我们在用这个法则处理一下下面的序列

 

 得到3 2 1 4 5

因为上面的序列1 2 3 4 5满足单调递增，所以只要下面的转换后的序列也满足单调递增，这个序列就是两个原序列的公共子序列，，

神奇吧。。。

于是我们只要求转化后的下面的序列的LIS就是答案。

O（n^2）算法：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define ll long long
#define N 100007
using namespace std;
int read()
{
    int ans=0;
    char ch=getchar(),last=' ';
    while(ch<'0'||ch>'9')last=ch,ch=getchar();
    while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+ch-'0',ch=getchar();
    return last=='-'?-ans:ans;
}
int n,a[N],b[N],c[N],d[N];
int main(){
    n=read();
    for(int i=1;i<=n;i++)a[i]=read(),c[a[i]]=i+10;
    for(int i=1;i<=n;i++)b[i]=read();
    d[1]=1;
    for(int i=2;i<=n;i++)//求最长上升子序列 
    {
        int maxn=-1000;
        for(int j=1;j<i;j++)
        {
            if(c[b[j]]<=c[b[i]])
                maxn=max(maxn,d[j]);
        }
        d[i]=(maxn==-1000?1:maxn+1);
    }
    int maxn=-1000;
    for(int i=1;i<=n;i++)
    {
        maxn=max(d[i],maxn);
    }
    printf("%d\n",maxn);
    return 0;
}
```


喜提：


![](https://img2018.cnblogs.com/i-beta/1606916/201912/1606916-20191229115146876-681280778.png)

 
考虑优化：


如果O（n^2）过了，你就可以踩标算了！ 你可能用的神威太湖之光吧。

## LIS优化:

我们上面的思路用的是枚举的方法，枚举之前最大的dp[i]。

事实上我们不用这么枚举，只需按照题目要求维护最大的长度len即可。

在之前，我已讲到了把上面的序列编号后对下面的序列进行转换，求最长上升子序列，我们继续：

考虑模拟一个栈stack，记录栈的深度len，

1.如果当前元素比栈顶大，就入栈，len++；

2.如果当前元素比栈顶小，二分查找第一个大于它的数，比较大小后插入栈。

因为第一个操作的缘故，所以栈中的元素始终满足单调递增，这也是可以二分的原因。

那么一个十分重要的问题：为什么这个方法可行？

#### 上网搜了一些人的博客，好像都说简单易懂，什么立志讲解明白，但又好像都没讲懂。只能自己想了。

对于第一个操作，考虑每一个加入栈顶的元素，栈中的元素都比它小，它的到来肯定能使最长上升子序列的长度加一，所以len++；

对于第二个操作，考虑一个类似贪心的东西：你目前子序列长度就那样了（在不大于栈顶元素的情况下，自然对长度没啥影响），如果要使后面还没考虑到的部分能加入尽量多的元素来扩充长度，当前元素又比栈顶小，如果你二分后这个数的值比二分到栈中的值小，那么你何尝不替换掉和它，为后面的len++做准备呢？二分插入的元素

想到这，我又想到了一个问题：前面的元素数值又不会对len造成什么影响，你替换他干什么？

一个宏观的考虑：经过一系列替换，栈中的元素数值很定会普遍变小，最后影响len的栈顶也被替换变小。那么自然，更有利于后面的len++喽。

代码：


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define ll long long
#define N 100007
using namespace std;
int read()
{
    int ans=0;
    char ch=getchar(),last=' ';
    while(ch<'0'||ch>'9')last=ch,ch=getchar();
    while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+ch-'0',ch=getchar();
    return last=='-'?-ans:ans;
}
int n,a[N],b[N],c[N],d[N],len=0;
int main(){
//    freopen("P1439_2.in","r",stdin);
    n=read();
    for(int i=1;i<=n;i++)a[i]=read(),c[a[i]]=i+10;
    for(int i=1;i<=n;i++)b[i]=read(),d[i]=214748364;
    d[0]=0;
    for(int i=1;i<=n;i++)
    {
        int l=0,r=len,mid;
        if(c[b[i]]>d[len])d[++len]=c[b[i]];
        else 
        {
            while(l<r)
            {   
                mid=(l+r)/2;
                if(d[mid]>c[b[i]])r=mid;
                else l=mid+1; 
               }
            d[l]=min(c[b[i]],d[l]);
        }
    }
    printf("%d",len);
    return 0;
}
```
![](https://img2018.cnblogs.com/i-beta/1606916/201912/1606916-20191230171820574-587803144.png)

 过呢了是。（滑稽）

完结，希望对大家的理解和学习有所帮助。

安利自己博客园：https://www.cnblogs.com/lbssxz/


---

## 作者：yanghaokun (赞：3)

# 题解 P1439 【【模板】最长公共子序列】

##  1、LIS的O（n^2）做法
### 显然的一道DP
设DP[i]表示以i这个点为结尾的LIS最大长度（一定包含第i个数）

那么，我们就有dp[i]=max(dp[j])+1,j<i&&a[j]<a[i],a[i]表示第i个数的大小

```cpp
for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i;j++)
        {
            if(a[i]>a[j])
            {
                dp[i]=dp[i]>dp[j]+1?dp[i]:dp[j]+1;
            }
        }
        maxx=maxx>dp[i]?maxx:dp[i];
    }

```
## 2、LIS的O(nlogn)做法
### 一般都是二分，在这里david-alwal为了保证博客不被拒，特意打了一个树状数组的优化 ~~其实也是david-alwal不会二分版本的 ~~
我们发现，上述做法时间低效的原因主要是因为找那一个max的时间复杂度太大了

所以我们考虑用树状数组优化

我们每一次的查找都是源于比a[i]小的dp[i]的值

所以，我们在查出dp[i]的时候，就将a[i]的值加上dp[i]

查询时可以只看min (dp[k]),k=[(1,a[i-1])

显然的树状数组可以解决

但是有时候a[i]太大了，而我们显然不希望开一个1e18的数组

所以我们就要用到离散化

一个结构体sort来获得相对大小

一起欣赏离散化

```cpp
struct node
{
	int num,daxiao,pos;//num存的是这个数本身，daxiao无需多言，pos存原来的位置 
}t[1001001];
inline bool cmp(const node a,const node b)
{
	return a.num<b.num;
}
inline bool cmp2(const node a,const node b)
{
	return a.pos<b.pos;
}
inline void make()
{
	sort(t+1,t+n+1,cmp1);
	int cnt=0;
	for(int i=1;i<=n;i++)
	{
		if(i==1||t[i].num!=t[i-1].num)cnt++;
		t[i].daxiao=cnt;
	}
	sort(t+1,t+n+1,cmp2);
}
```
树状数组LIS
```cpp
for(int i=1;i<=n;i++)
{
	y[i]=t[i].daxiao;
	int t=query(y[i]-1)+1;
	maxx=max(maxx,t);
	modify(y[i],t);
}
```
## 3、打击你一下
### 你有没有发现今天的主角LCS还没有上场？？

## 4、LCS的闪亮登场

### 终于来了

这种LCS超级简单

你可以将它看成一个在二串LIS，只不过相对大小是由一串决定的

像样例：：
```cpp

5 
3 2 1 4 5
1 2 3 4 5
```

你可以在2串上跑LIS，唯一的不同是正常的LIS是1<2<3<4<5,而这里的LIS是3<2<1<4<5

也就是说，我们换了一种离散化的策略

原先是按num的大小排序

现在按A串[num]排序

完了。

完了？

真完了

就差一个代码了

```cpp
#include<bits/stdc++.h>
using namespace std;
int max(int a,int b){return a>b?a:b;}
int n;
int c[1001001];
inline int lowbit(int x){return x&(-x);}
inline void modify(int x,int v){for(;x<=n;x+=lowbit(x))c[x]=max(c[x],v);}
inline int query(int x)
{
	int ans=0;
	for(;x;x-=lowbit(x))ans=max(ans,c[x]);
	return ans;
}
struct node
{
	int x,y;
}poi[1001001];
int y[1001001];
int yy[1001001];
bool cmp(const node a,const node b)
{
	return a.y<b.y;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&poi[i].x),poi[i].y=i;
	for(int i=1;i<=n;i++)scanf("%d",&y[i]);
	sort(poi+1,poi+n+1,cmp);
	for(int i=1;i<=n;i++)yy[poi[i].x]=poi[i].y;
	int maxx=0;
	for(int i=1;i<=n;i++)
	{
		y[i]=yy[y[i]];
		int t=query(y[i])+1;
		maxx=max(maxx,t);
		modify(y[i],t);
	}
	printf("%d",maxx);
}
```

---

## 作者：pluszero (赞：3)

首先感谢最下面那位神犇的思路。

其实就是把第一个数列每一个数的位置做一个映射，把它当成1 2 3 4 5 6...，再把它放到第二个数列里。我们以样例为例：

5
3 2 1 4 5 把3当成1，把2当成2。。。以此类推

那么1 2 3 4 5就变成了3 2 1 4 5


对后一个数列做最长不下降子序列就得出答案。原因就是第一个数列是一个不下降序列，第二个数列的不下降子序列一定能在第一个数列中找到。


我用的是树状数组求最长不下降子序列，下面是代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<vector>
using namespace std;

vector<int> ve;
int n,b[1000001],a[1000001],d[1000001];

int lb(int x)
{
    return x & (-x);
}

void qmax(int x,int v)
{
    while(x<=n)
    {
        d[x]=max(d[x],v);
        x+=lb(x);
    }
}

int query(int x)
{
    int ans=0;
    while(x>0)
    {
        ans=max(ans,d[x]);
        x-=lb(x);
    }
    return ans;
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int c;
        scanf("%d",&c);
        b[c]=i;
    }
    int maxx=0;
    for(int i=1;i<=n;i++)
    {
        int k;
        scanf("%d",&k);
        a[i]=b[k];
    }
    for(int i=1;i<=n;i++)
    {
        int f=query(a[i])+1;
        qmax(a[i],f);
        maxx=max(maxx,f);
    }
    printf("%d",maxx);
    return 0;
}
```

---

## 作者：lgnotus (赞：3)

### 题目描述

给出$1-n $的两个排列$P1$和$P2$，求它们的最长公共子序列。

### 思路

可以先把$P1$序列按某个映射法则映射成`1 2 3 ... n`的这样一个序列

然后再把$P2$序列按这个映射法则再映射成一个新的序列

举个例子：

$P1:$ ` 2 3 1`

$P2:$`3 2 1`

把$P1$序列映射成 `1 2 3`

再把$P2$序列按照$f(2)=1,f(3)=2,f(1)=3$这个映射法则映射成`2 1 3`

可以发现：$P1$和$P2$的最长公共子序列长度就是$P2$序列的最长上升子序列的长度。

但是$O(n^2)$的求最长上升子序列的长度的dp算法是不能通过的，所以可以用二分查找优化，

令$dp[i]$表示长度为$i$的所有上升子序列中，尾部的最小值现在，有一个数$x$，要把它加入到一个上升子序列中，可以用lower_bound去寻找第一个大于等于$x$的数的位置，然后把$x$加到这个数的后面就可以了

### code

```c++
#include<bits/stdc++.h>
using namespace std;
int n,dp[200005];
struct node
{
    int a,b;
}arr[200005];
bool cmp(node a,node b)
{
    return a.a<b.a;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>arr[i].a>>arr[i].b;
    sort(arr+1,arr+n+1,cmp);
    for(int i=1;i<=n;i++)dp[i]=INT_MAX;
    for(int i=1;i<=n;i++)
        *lower_bound(dp+1,dp+n+1,arr[i].b)=arr[i].b;
    int t=lower_bound(dp+1,dp+n+1,INT_MAX)-dp;
    cout<<t-1<<endl;
    return 0;
}

```

### 时间复杂度

$O(n log n)$



撒花

---

## 作者：封禁用户 (赞：3)

这个题各位大佬们都用的O(nlogn)的方法，我自创了一个挺暴力的介于O(nlogn）和O(n^2logn)之间的方法：首先读入第一个序列，然后记录他们的初始位置，然后从小到大排序（这样做是为了二分查找）。接着读入第二个序列，每读入一个数就在第一个序列中二分查找这个数的位置r，如果有的话就说明从这里开始的若干数前面有一个最长的公共子序列就是我们找到的这个，把结果数组dp[r]~dp[n]的位置全部赋为dp[r]+1，中途如果遇到大于等于dp[r]的数则停止循环（为什么要这样做呢？这是因为，如果遇到了这种情况，就说明，从这个数再往后就有更优的公共子序列了，而且它和当前的子序列互不影响，所以不能再往后叠加了，这也是这个方法的时间比暴力n^2快的原因）。最终dp[n]就是最终结果。（这里dp[i]的意义是到序列1的第i个的最长公共子序列的长度），但是，当两个序列的相似度很高时，此法的时间复杂度接近于O(n^2logn）（比如第二个测试点甚至就是两个相同的100000序列，花了我将近1000ms，这是因为，这样就很少或根本不会出现上面可以停止循环的情况），不过对于一般性数据还是不错的。

代码如下（没敢用STL，排序什么的甚至读入都是手写的）：

```cpp
    #include<cstdio>
    using namespace std;
    int datas[100001];//序列1
    int indexs[100001];//序列1各元素的初始位置
    int ints[100001];//序列2（其实没用）
    int dp[100001];//到序列1的第i个时最长公共子序列长度
    int num;//要查找的数（供二分使用）
    int get(){//读入优化
        int n;
        char c;
        while(1){
            c=getchar();
            if(c>='0'&&c<='9')break;
        }
        n=c-'0';
        while(1){
            c=getchar();
            if(c>='0'&&c<='9'){
                n=n*10+c-'0';
            }
            else{
                return(n);
            }
        }
    }
    int isort(int left,int right){//手写的快排
        int index=(left+right)>>1;
        int i=left,j=right;
        int mid=datas[index];
        while(i<=j){
           while(datas[i]<mid)i++;
           while(datas[j]>mid)j--;
            if(i<=j){
                 int tmp=datas[i];
            datas[i]=datas[j];
            datas[j]=tmp;
            tmp=indexs[i];
            indexs[i]=indexs[j];
            indexs[j]=tmp;
            i++;
            j--;
            }
        }
       if(j>left)isort(left,j);
       if(i<right)isort(i,right);
    }
    int find(int l,int r){//二分查找，返回序列i中的num的初始位置
        if(l==r){
            if(datas[l]==num)return(indexs[l]);
            return(-1);//没找到就返回-1
        }
        int mid=(l+r)>>1;
        if(datas[mid]==num)return(indexs[mid]);
        if(num<datas[mid])return(find(l,mid-1));
        return(find(mid+1,r));
    }
    int main(){
        int n=get();
        register int i=0;
        register int j=0;
        for(i=1;i<=n;i++){
            datas[i]=get();
            indexs[i]=i;
        }
        isort(1,n);
        for(i=1;i<=n;i++){
            num=get();
            int r=find(1,n);
            if(r>0){
                int newd=dp[r]+1;
                for(j=r;j<=n;j++){//更新后面的结果
                    if(dp[j]>=newd)break;//发现更优的解就不再更新
                    dp[j]=newd;
                }
            }
        }
        printf("%d",dp[n]);
        return(0);
    }

```

---

## 作者：pyyyyyy (赞：2)

# 题目链接

[P1439 【模板】最长公共子序列](https://www.luogu.org/problemnew/show/P1439)

# 思路

##第一种 $O(N^2)$

用f[i][j]表示第一个排列取到i位和第2个排列取到j位的公共子序列长度

$$f[i][j]=max(f[i-1][j],f[i][j-1],f[i-1][j-1])$$

**最后一种情况需满足$a[i]==b[i]$**

对于$50%$的数据，$n≤1000$，应该可以过


##第二种 $O(n \cdot log(n) )$

把a重新标号$1$到$n$,把b中和a相同的元素跑一遍最长上升子序列就好了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<string>
#include<cstring>
using namespace std;
inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * f;
}
int n;
int a[100005],lcs[100005];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		int x;
		cin>>x;
		a[x]=i;//标记 
	}
	int len=0;
	lcs[0]=-999;
	for(int i=1;i<=n;++i)
	{
		int x;
		cin>>x;
		int now=a[x];
		if(now>lcs[len])
		{
			lcs[++len]=now;
		}
		else
		{
			int j=lower_bound(lcs+1,lcs+len+1,now)-lcs;
			lcs[j]=now; 
		}
	}
	cout<<len;
	return 0;
}
```

关于lower_bound请看这篇博客[点这里](https://www.cnblogs.com/pyyyyyy/p/10770939.html)

###手打二分的代码:


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],c[100001],s;
int main(int argc, char const *argv[])
{
    int n,xx;
    a[0] = -100000;
    cin>>n;
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d",&xx);
        a[xx] = i;
    }
    int t;
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d",&t);
        t = a[t];
        if (t > c[s])
        {
            c[++s] = t;
        }
        else{
            int l = 1,h = s,m;
            while(l <= h){
                m = (l + h) / 2;
                if(t > c[m]) l =m + 1;
                else h = m - 1;
            }
            c[l] = t;
        }
    }
    cout<<s<<endl;
    return 0;
}
```

---

## 作者：da32s1da (赞：2)

这道题显然$n^2$的暴力(???)是不行的，所以考虑将数据进行转化。
```
若有一组数据
2
4 2 5 1 3
2 5 4 1 3
那么我们令
4 2 5 1 3
| | | | |
1 2 3 4 5
第三行的数据就变成
2 3 1 4 5
很明显，答案是4==2 3 4 5，即原数列的2 5 1 3。
```
分析到这里，怎么做就一目了然了。我们查询$1-i$的最值，即为$i$的最长公共子序列长度，然后将区间$i-n$的最值修改即可。
```
我们考虑树状数组来求区间最值。
#include<cstdio>
#include<algorithm>
#define N 100010
using namespace std;
struct zz{int fir,sec,thr;}s[N];
int n,ss[N],lcs[N],ans;
inline int max(int a,int b)
{return a&((b-a)>>31)|b&(~(b-a)>>31);}
bool mmp(zz u,zz v){return u.fir<v.fir;}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&s[i].fir),s[s[i].fir].thr=i;
    for(int i=1;i<=n;i++) scanf("%d",&s[i].sec),s[i].sec=s[s[i].sec].thr;
    //以上为处理数据，sec中存的是处理后的值。
    for(int i=1;i<=n;i++){
    	for(int j=s[i].sec-1;j;j-=(j&(-j))) 
        lcs[i]=max(lcs[i],ss[j]);//查询最值
    	lcs[i]++;//加上自己
    	for(int j=s[i].sec;j<=n;j+=(j&(-j))) 
        ss[j]=max(ss[j],lcs[i]);//修改最值
    	ans=max(ans,lcs[i]);//答案更改
    }
    printf("%d\n",ans);//输出
    return 0;
}
```

---

## 作者：ysner (赞：2)

为什么前面的神牛都用了STL函数upper——bound，我这个小蒟蒻不懂。。。

于是乎，我写了个没用这个STL函数的代码，速度慢到爆（最后一个点0.9s+）。

此题难点是

1、数据范围过大，这需要用不定长数组map（不懂看度娘）

2、此题数据是用来卡AC的，所以要先将其转化为一个子序列（map的映射功能），再用优化算法——LIS的n\*logn算法。

3、LIS的n\*logn算法：D[i]保留满足F[i] = k的所有A[i]中的最小值。F[i]表示从1到i这一段中以i结尾的最长上升子序列的长度。设当前已经求出的最长上升子序列长度为len。先判断A[i]（一个子序列）与D[len],若A[i] > D[len]，则将A[i]接在D[len]后将得到一个更长的上升子序列,len = len + 1,D[len+1] = A[i];否则,在D[1]..D[len]中,找到最大的j,满足D[j] < A[i].令k = j + 1,则有D[j] < A[i] <= D[k]，将A[i]接在D[j]后将得到一个更长的上升子序列,同时更新D[k] = A[i].最后，len即为所要求的最长上升子序列的长度。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<string>
#include<cmath>
#include<algorithm>
#include<map>
using namespace std;
map<int,int>f;//不定长数组，相当于一种映射，具体请问度娘 
int  a[300009]={},n,m,c[400009]={},d[260000]={},aa,bb;
int lcs()
{
    int w,i,j;
    for(i=1;i<=n;i++)
        c[i]=f[a[i]];//c数组记录下第一个子序列中的数在第二个子序列中的位置 
    int s=1;
    while(c[s]==0)//c数组元素为0说明第一个子序列的数在第二个子序列中不存在，即是在第一个子序列有，
    //第二个子序列没有的数
    c[s]=999999,s++;//先把前面的数二分时扔到最后面，直到发现第一个两子序列共有数为止
    //ps:前三句话其实都没必要，只是不剪点枝肯定TLE 
    d[1]=c[1];//第一个数当然直接放第一个   
    int t=1;    
    for(i=2;i<=n;i++)//二分找出一个个公共子序列元素所在位置 
    {
        int l=1,r=t,mid;//因为从1开始，比最小两子序列共有数小的数（如0）被放在d[0]不断覆盖（遗忘） 
        while(l<=r)
        {
            mid=(l+r)>>1;//>>1等价于/2 
            if(d[mid]<c[i])
                l=mid+1;
            else r=mid-1;
        }
        d[l]=c[i];
        if(l>t)//如果发现找出的位置在最后面，那就加长度 
            t++;
    }
    return t;
}
int main()
{        
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    int q;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&q);
        f[q]=i;//第二个子序列记录下位置 
    }
    int ans=lcs();//LIS的n*logn算法 
    cout<<ans<<endl; 
    return 0;
}
```

---

## 作者：courage (赞：2)

看到10W的规模，大致可以断定此题应该用O(nlogn)的解法，朴素的LCS算法时间复杂度为O(n^2)，明显不可行。


首先简化一下问题，假设P1恰好为单调递增的1,2,3,...n，那么很显然答案就是P2的最长上升子序列的长度（想一想，为什么？）


问题是P1并非单调递增的，但我们可以假定它就是1,2,3,...,n，将P1[1]映射到1，P1[2]映射到2，……然后再将P2作相同的变换即可，这样只要求P2的最长上升子序列了。


最长上升子序列是有O(nlogn)算法的，大致过程如下：

建立栈a,每读入一个元素x，若x比栈顶元素大则x进栈，否则在栈中二分找到第一个大于x的元素a[k]，并用x替换它，做完以后栈的大小就是序列的最长上升子序列的长度。


代码：

```cpp

#include<cstdio>
int a[100010],b[100010],n,p,x;
int search(int l,int r,int x){
    int m=(l+r)>>1;
    while (l<r){
        if (a[m]<=x) l=m+1;
        if (a[m]>x) r=m;
        m=(l+r)>>1;
    }
    return m;
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&x);
        a[x]=i;
    }
    for (int i=1;i<=n;i++){
        scanf("%d",&x);
        b[i]=a[x];
    }
    p=1;
    a[1]=b[1];
    for (int i=2;i<=n;i++){
        if (b[i]>a[p]){
            p++;
            a[p]=b[i];
            continue;
        }
        a[search(1,p,b[i])]=b[i];
    }
    printf("%d\n",p);
}

```

---

## 作者：YWY_wys (赞：2)

# 线段树学傻了的我....

##  题意：给两个排列a,b,求LCS

##  题解：
### 读完题之后接触过LCS的人应该都会想到LCSdp模板直接套了，然而一看数据范围100000，瞬间炸裂emmm...。
### 但蒟蒻的我仍然考虑LCS dp。

### 仔细观察了一波题目之后发现一个重要条件：两个序列都是1-n的一个排列，那么我们考虑通过这个条件写一个优化dp。

- 状态：f[i]表示以a[i]为结尾的最长公共子序列的长度。
- 转移：那么很明显 **f[i]=max(f[j])+1 (1<=pos[a[j]]<pos[a[i]])(其中pos[i]表示i在b序列中的位置)**
- 优化：在转移时单纯的枚举（O（n^2））肯定是不行的。注意到我们转移时需要查询区间最值，单点修改，于是这里我写了一个线段树。这样转移的时候**f[i]=query(1,pos[a[i]]-1)+1;**线段树维护的是1->n位置内的最值（这里的位置指的是pos[i]）。然后就做到了nlogn。可以通过此题。

### code：
```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

const int maxn=100005;
const int size=400005;

struct sgt{
	int sum[size];
	void build(int o,int l,int r) {
		sum[o]=0;
		if(l>=r) return ;
		int mid=l+r>>1;
		int lson=o<<1;
		int rson=lson|1;
		build(lson,l,mid);
		build(rson,mid+1,r);
		sum[o]=max(sum[lson],sum[rson]);
	}
	void updata(int o,int l,int r,int k,int x) {
		if(l>=r) {
			sum[o]=x;
			return;
		}
		int mid=l+r>>1;
		int lson=o<<1;
		int rson=lson|1;
		if(k<=mid) updata(lson,l,mid,k,x);
		else updata(rson,mid+1,r,k,x);
		sum[o]=max(sum[lson],sum[rson]);
	}
	int query(int o,int l,int r,int a,int b) {
		if(a<=l && r<=b) return sum[o];
		int res=0;
		int mid=l+r>>1;
		int lson=o<<1;
		int rson=lson|1;
		if(a<=mid) res=max(res,query(lson,l,mid,a,b));
		if(b>mid) res=max(res,query(rson,mid+1,r,a,b));
		return res;
	}
} t;

int n,ans;
int a[maxn],b[maxn],pos[maxn],f[maxn];

int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) {
		scanf("%d",&b[i]);
		pos[b[i]]=i;
	}
	t.build(1,1,n);
	for(int i=1;i<=n;i++) {
		f[i]=t.query(1,1,n,1,pos[a[i]])+1;
		t.updata(1,1,n,pos[a[i]],f[i]);
		if(ans<f[i]) ans=f[i];
	}
	printf("%d",ans);
}
```



---

## 作者：P500 (赞：1)

这题的方向是把最长公共子序列转化成最长上升子序列 
前者复杂度为O(N2),后者为O(NlogN). 

具体思路及实现见代码注解(较详细)
```
#include <iostream>
using namespace std;

const int maxn=100005, inf=200005; //设立最大值 
int a[maxn],b[maxn],c[maxn],f[maxn],dp[maxn],n;//数组意思在下面有注解 
int myfind(int l,int r,int x){//二分搜索 (返回值为: dp[l~r]中第一个不小于x的数的下标)(注:dp[]中的数按升序排列)  
	if(l==r) return l;  //搜索范围已足够小,已找到目标下标! 
	int mid=(l+r)>>1;   //二分搜索范围    ( ">>1" 的意思是 "/2" ) 
	if(x>dp[mid]) return myfind(mid+1,r,x);   //在左边搜索 
	else          return myfind(l,mid,x);     //不然就在右边搜索
}
int main(){
	cin>>n; //读入n 
	for(int i=1;i<=n;i++) cin >> a[i];  //读入第一个排列 
	for(int i=1;i<=n;i++) cin >> b[i];  //读入第二个排列 
	for(int i=1;i<=n;i++) f[b[i]]=i;    //将第二个排列基数排序 
	for(int i=1;i<=n;i++) c[i]=f[a[i]]; //c[i]表示a[i]在b[i]中出现的位置 
	for(int i=1;i<=n;i++) dp[i]=inf, dp[myfind(1,i,c[i])]=c[i]; //原问题变为求最长上升子序列长度
	cout << myfind(1,n+1,inf) - 1;//输出答案
	return 0;//结束
}
```

---

## 作者：封禁用户 (赞：1)

因为根据题目描述这n个数是一个排列也就是说不会重复而且每个元素出现一次，所以可以将其转化为一个最长上升子序列来做。而最长上升子序列有一个基于栈和二分优化的nlogn的算法。

代码如下

```cpp
#include<iostream>
#include <cmath>
using namespace std;
int n,a[1000000],b[1000000],f[1000000],flag[1000000],d,ans;
int rf(int x)
    {
        if (x>flag[d]) {d++;flag[d]=x;return d;}
        int l,r,m;
        l=1;r=d;m=(l+r)/2;
        while (l<r)
        {
            if (flag[m]<x) l=m+1; else r=m;
            m=(l+r)/2;
        }
        flag[l]=x;
        return l;
    }
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        a[x]=i;
    }
    for (int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        b[i]=a[x];
    }
    flag[0]=0;
    for (int i=1;i<=n;i++)
    {
        f[i]=rf(b[i]);
        ans=max(ans,f[i]);
    }
    cout<<ans;
    return(0);
}

```

---

## 作者：G_A_TS (赞：1)

离散化。。。  
惊奇地发现它变成了求LIS  
LIS不是n^2吗？  
[神奇的操作](https://blog.csdn.net/qq_40160605/article/details/80150252)  
上代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s1[100010],s2[100010],s[100010],f[100010],now;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s1[i];
        s[s1[i]]=i;
    }
    for(int i=1;i<=n;i++)
    {
        cin>>s2[i];
    }
    for(int i=1;i<=n;i++)
    {
        if(s[s2[i]]>f[now])
        {
            f[++now]=s[s2[i]];
        }
        else
        {
            int k=lower_bound(f+1,f+now+1,s[s2[i]])-f;
            f[k]=s[s2[i]];
        }
    }
    cout<<now;
}
```

---

## 作者：2002chenhan (赞：1)

# 树状数组走一走！

f[i]表示在b中以i结尾的最长公共子序列。

很容易可以求到b中值为a[i]的位置，记为x。

在保证a[i]=b[x]时，$$f[x]=\max_{1\leq j <i}f[j]+1$$这个东西可以用树状数组维护。

来考虑一下正确性，因为i从小到大枚举，所以填进树状数组的是用A中1~i-1做出来的，能保证任意一个j都可以转移到当前状态来。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=100010;

int n,a[MAXN],pos[MAXN];
int f[MAXN];

int mx[MAXN];
void change(int x,int c)
{
	for(;x<=n;x+=x&-x) mx[x]=max(mx[x],c);
}
int getmax(int x)
{
	int re=0;
	for(;x>=1;x-=x&-x) re=max(re,mx[x]);
	return re;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		int x;scanf("%d",&x);
		pos[x]=i;
	}
	
	for(int i=1;i<=n;i++)
	{
		int x=pos[a[i]];
		f[x]=getmax(x)+1;
		change(x,f[x]);
	}
	printf("%d\n",getmax(n));
	return 0;
}
```

---

## 作者：v__v (赞：1)

这题方法都是那样，如有雷同是我抄袭。！好吧，我只是想用简短的语句描述出解法，看题解的描述都好长，解法如下：
转换成最长递增子序列，自然就可以用二分+单调队列来优化时间。具体是"导弹拦截"这道题
转换是有条件的，要求2个序列中，某个序列是互不相同的数字组成设它是A，另一个是B，B的字符集必须被A包含，这样就能建立A的索引，ind[i]代表A数组某个等于i的数的下标，把B的字符用索引去替换，求索引的后的B序列最长不减子序列即可。正确性是由于,索引代表A每个数的位置，在B里替换后，ind[B]的递增子序列就代表了B和A按顺序重合部分。


---

## 作者：盧鋅 (赞：0)

## LCS?????LIS!!!!!
为什么可以这样说呢
我们发现题干是两个1-n的排列，
那么我们把两个排列转换成一个排列不就好了吗？（~~还是有点晕，看不懂没关系，我们继续~~）

先定义两个数组s1[],s2[]
然后我们读入两个排列，并根据他们的数值把他们读入的顺序~~映射~~到数组里
```
for(int i=1;i<=n;i++)cin>>m,s1[m]=i;
```
大概就是这样了s2和s1同理。

然后我们用a[]，把这两个数组转移到同一数组里，就转换为求LIS的问题了
```cpp
for(int i=1;i<=n;i++)a[s2[i]]=s1[i];
```
是不是还是有些~~懵逼~~
```cpp
5 
3 2 1 4 5
1 2 3 4 5
```
那题目给出的数组模拟下
```
s1[ ]={3,2,1,4,5};
s2[ ]={1,2,3,4,5};
a[ ]={3,2,1,4,5};
```
其实我们做了什么呢？？以一数组为基准，定义顺序，求另一数组的LIS。
（假如还是不懂的话，找多个输入，手模（~~或者编程~~）一下就明白了）

```cpp
	for(int i=1;i<=n;i++)cin>>m,s1[m]=i;
//	for(int i=1;i<=n;i++)cout<<s1[i]<<" ";
	for(int i=1;i<=n;i++)cin>>m,s2[m]=i;
//	for(int i=1;i<=n;i++)cout<<s2[i]<<" ";
	for(int i=1;i<=n;i++)a[s2[i]]=s1[i];
//	for(int i=1;i<=n;i++)cout<<a[i]<<" ";
```


然后nlogn求下LIS就好了。
```cpp
	for(int i=1;i<=n;i++){
		if(k[top]<a[i])k[++top]=a[i];
		else *upper_bound(k+1,k+top,a[i])=a[i];
	}
```
思想就是这些了，然后就不放代码了，

---

## 作者：a2956331800 (赞：0)

## 不用映射后LIS的做法
（不过复杂度完全一样）

$dp[i][j]$ 表示第一个序列到$i$，第二个到$j$的最长公共子序列。

首先$dp$数组可以压到一维，即表示对当前循环到的$i$，第二个序列到$j$的最长公共子序列。

枚举$i$需要$O(n)$优化不动，考虑优化更新$dp$数组的过程。

根据$dp$数组的定义看，$dp$数组一定是个**单调不降**的序列，因为匹配到$x$后，即使后面一个不匹配，匹配数也**不会减少**，所以$dp$数组可以用**树状数组**来维护（不需要特殊的那种维护任意序列的max写法，直接写**普通**树状数组把+改成max即可，因为$dp$单调不降，到第$i$位的前缀最大值一定等于$dp[i]$）

现在考虑怎么修改：对第二个序列记一个$p$数组，$p[i]$表示序列中为$i$的数出现的位置

求$p$直接在读入时处理即可
```cpp
for(i=1;i<=n;i++)
	  read(b[i]),p[b[i]]=i;
```
回想一下$O(n^2)$的dp，只有当前两个位置的数相等时dp值才会+1，所以直接找到当前的$a[i]$（第一个序列）对应的数在$b[i]$中的位置（即$p[a[i]]$）,求出原本的$dp$值并+1更新回树状数组即可。最后求一下$dp[n]$就是答案
code：（不算快读&&大括号换号=37行代码）
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define lowbit(x) x&-x
using namespace std;

int n,a[100005],b[100005],i,p[100005],x;

int t[800005];
void add(int x,int p)
{
	while(p<=n)
	  t[p]=max(t[p],x),p+=lowbit(p);
}
int sum(int p)
{
	int ret=0;
	while(p)
	  ret=max(ret,t[p]),p-=lowbit(p);
	return ret;
}

char Getchar()
{
	return getchar();
	static const int len=10000000;
	static char space[len],*p=space,*t=space;
	if(p==t)
	  t=space+fread(p=space,sizeof(char),len,stdin);
	return *(p++);
}
char rc;int flag;
void read(int &x)
{
	x=0;rc=Getchar();flag=1;
	while(rc<'0'||rc>'9')
	  flag=(rc=='-'?-1:1),rc=Getchar();
	while(rc>='0'&&rc<='9')
	  x=x*10+rc-'0',rc=Getchar();
	x*=flag;
}

int main()
{
	read(n);
	for(i=1;i<=n;i++)
	  read(a[i]);
	for(i=1;i<=n;i++)
	  read(b[i]),p[b[i]]=i;
	for(i=1;i<=n;i++)
	{
		x=sum(p[a[i]]);
		add(x+1,p[a[i]]);
	}
	cout<<sum(n);
	return 0;
}
```

---


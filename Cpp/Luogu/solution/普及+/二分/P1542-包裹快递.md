# 包裹快递

## 题目描述

小 K 成功地破解了密文。但是乘车到 X 国的时候，发现钱包被偷了，于是无奈之下只好作快递员来攒足路费去 Orz 教主……

一个快递公司要将 $n$ 个包裹分别送到 $n$ 个地方，并分配给邮递员小 K 一个事先设定好的路线，小 K 需要开车按照路线给的地点顺序相继送达，且不能遗漏一个地点。小 K 得到每个地方可以签收的时间段，并且也知道路线中一个地方到下一个地方的距离。若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收，但不能晚于签收的时间段，可以认为签收的过程是瞬间完成的。

为了节省燃料，小 K 希望在全部送达的情况下，车的最大速度越小越好，就找到了你给他设计一种方案，并求出车的最大速度最小是多少。


## 说明/提示

#### 数据范围
- 对于 $20\%$ 的数据，$0 < n \le 10$。   
- 对于 $30\%$ 的数据，$0<x_i,y_i,s_i \le 1000$。   
- 对于 $50\%$ 的数据，$0<n \le 1000$。   
- 对于 $100\%$ 的数据，$0<n \le 2\times10^5$，$x_i \le y_i \le 10^8$，$s_i \le10^7$。

-----
#### 样例解释
第一段用 $1$ 的速度在时间 $2$ 到达第 $1$ 个地点，第二段用 $0.5$ 的速度在时间 $6$ 到达第 $2$ 个地点，第三段用 $2$ 的速度在时间 $8$ 到达第 $3$ 个地点。

## 样例 #1

### 输入

```
3
1 2 2
6 6 2
7 8 4
```

### 输出

```
2.00```

# 题解

## 作者：Koakuma (赞：58)

[博客食用更佳](https://82494.blog.luogu.org/)

## $Structure$

本题要求我们求出 `车的最大速度最小值` 。

像求 `最大值最小`、`最小值最大` 这种类型的题目，我们很自然地就能想

到用`二分答案`（一般情况）来求解。

## $Solution$

做二分题目时，我们要弄清楚这样几点：

1. 二分什么

2. 如何判断是否可行 ( 即check函数的内容 )

3. 当二分到一个满足条件的解时，$L$ , $R$ 该如何移动

针对以上三个问题，我们来一步一步解决。

$S1.$ 题目求速度，所以我们可以直接二分最大速度的值

$S2.$ 在check函数中可以直接进行模拟送包裹，在模拟过程当中进行

判断（具体见代码）

$S3.$ 可能我们做二分题目会形成了思维定式，例如求最 大/小 值解的时

候，若 $mid$ 满足题意，则就将 $L = mid + 1$ 或将 $R = mid - 1 $


然而，由于此题考虑到精度问题，如果按照上述操作，那么我们就会

错过 $1 / 0.01 = 100$（及以上）个可能满足条件的解 （保留两位小

数）。

所以正确的格式应是：

```cpp
mid = (l + r) / 2;
if (check(mid)) Res = mid, r = mid;
else l = mid;
```

另外，由于本题数据原因对精度要求较高，所以在定义实数类型时要

用 `long double` ，相与之搭配的输出应是 `printf("%Lf")` .

到此为止，问题都已经解决。

下面给出朴实代码

## $Code$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
const int maxn = 2e5 + 100;
using namespace std;
int x[maxn], y[maxn], s[maxn];
int N;
long double Res;
inline bool check(double k)
{
	long double sum = 0;   // sum记录进行时间
	for (int i = 1 ; i <= N ; ++i)
	{
		sum += s[i]/k;    //加上到达下个地点的时间
		if (sum > y[i]) return false; // 若超出签收时间右端点（即来晚了），说明以此速度不可行，直接返回false
		if (sum < x[i]) sum = x[i]; // 如果小于签收时间左端点（即来早了），则等待至签收时间
	}
	return true;  //若至始至终没有迟到，则说明以此速度的方案可行
}
int main()
{
	cin >> N;
	for (int i = 1 ; i <= N ; ++i)
	 scanf("%d%d%d", &x[i], &y[i], &s[i]);
	long double l, r, mid;
	l = 0, r = 1e9;
	while (r-l >= 0.00001)  // 二分控制精度
	{
		mid = (l + r) / 2;
		if (check(mid)) Res = mid, r = mid;
		else l = mid;
	}
	printf("%0.2Lf\n", Res); //保留两位小数
	
    return 0;
}

```

## $After\ Writing$

希望此题解能让泥萌有所收获

最后感谢管理大大的审核qaq

再见~

---

## 作者：E_tc (赞：15)

# 看到其他大佬没有和我的雷同的，就索性发个题解。。
#### 本题看到最大值最小，自然而然就是二分答案了。。
思路在这不再多少，详情请见代码：
```cpp
//用二分答案，在check检查函数中做一下改动，开一个变量储存一下上一个快递送完的时间，计算出送本次物品所用的时间，
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
double maxn=0.0,ans,sh;
struct express
{
	double x,y,s;
}a[200000];
bool check(double v)
{
	double t;
    double start_last=0.0;
    for(int i=1;i<=n;i++)
    {
        t=a[i].s/v;
        if(t > a[i].y-start_last)//如果超出了时间上限就直接 false
        	return false;
        else if(t < a[i].y-start_last && t > a[i].x-start_last)//如果送完本次物品的时间恰好在开头时间和结束时间之间，就
            start_last+=t;//就直接更新 
         else if(t < a[i].x-start_last)//如果时间小于的话，说明送完上次物品之后按照当前速度，到达本次物品的时候还没有到
         	start_last+=a[i].x-start_last;//可以开始接收的时间，更新的时候就还要加上等待的时间
    }
    return true;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		cin>>a[i].x>>a[i].y>>a[i].s;
	double l=0.00;
	double r=10000001.00;
	while(l<=r)
	{
        double mid=(l+r)/2.0;
        if(check(mid))
        {
        	ans=mid;
        	r=mid-0.001;
        }
        else
        	l=mid+0.001;
	}
	printf("%.2lf",ans);//按要求输出
	return 0;
}
```
觉得好久点个赞呗~~~~


---

## 作者：RainShalder (赞：12)

#二分法题解

-其实这个题一开始做的时候被题目说明误导了...天真的以为把两个人最晚时间加起来除以距离就是这一段的速度，再比较一下就好

-结果发现问题并没有这么简单

-二分速度，如果速度可以到达，就把右端点赋给k；否则就赋值左端点

-这个题有几个坑：

-1、数据类型必须用long double，否则无法AC

-2、精度必须精确到0.00001以下，否则会出现部分点过不去的情况

-3、不要用cin！否则第九个点TLE！

-下面放代码：

```cpp
#include<iostream>
#include<iomanip>  //我习惯使用cout精确小数位输出，printf精确小数位也可
#include<cstdio>
#include<cmath>
#define N 200010
using namespace std;
int placenum;  //地点个数
long double flag,usedtime,L,R,k,times[N],timee[N],dis[N];  //变量解释：flag：标志变量，usedtime：当前速度下已用时间，L、R、K：二分的左端点、右端点、中点，times、timee、dis：时间区间起点、终点、分段的距离
bool speedtest(long double k)   //注意这里是long double
{
    for(int i=1;i<=placenum;i++)
    {
        usedtime=usedtime+dis[i]/k;
        if(usedtime<=timee[i])
        {
            usedtime=max(usedtime,times[i]);  //如果提前到，需要等待一会儿，所以要用一个max来判断是否等待了。如果等待，则把等待后的时间(times[i])赋给已用时间
            flag=1;
        }
        else
        {
            flag=0;
            break;
        }
    }
    usedtime=0;
    if(flag)
        return true;
    else
        return false;
}
int main()
{
    scanf("%d",&placenum);
    for(int i=1;i<=placenum;i++)
    {
        scanf("%llf%llf%llf",&times[i],&timee[i],&dis[i]);
    }
    R=2000000000;  //此处为了保证不出错，把初始速度定的大一些。不要定太大，否则容易TLE
    while(R-L>0.000000001)  //保证精度
    {
        k=(L+R)/2;
        if(speedtest(k))
            R=k;
        else
            L=k;
    }
    cout<<fixed<<setprecision(2)<<L<<endl;   //输出2位小数。等价于printf("%llf",L); 因为用printf输出long double时用的说明符在不同系统的机器可能不同，为保险起见用cout.
return 0;
}
-萌新瑟瑟发抖=-=
```

---

## 作者：recoders (赞：9)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
double x[200010],y[200010],s[200010];
int n;
bool solve(long double v)
{
    long double t=0;
    for(int i=1;i<=n;i++)
    {
        t+=s[i]/v;
        if(t>y[i])
            return false;
        if(t<x[i])
            t=x[i];
        }
    return true;
}
 double sec(long double l,long double r)
{
    if(r-l<1e-9)
        return (l+r)/2.00;
     double mid=(l+r)/2.0000000;
    if(solve(mid)==false)
        return sec(mid,r);
    else
        return sec(l,mid);
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i]>>s[i];
     double ram=sec(0,1e9);
    printf("%.2lf",ram);
    return 0;
}
```
这个题第十个点剧毒，long double不能输入输出但你还必须要用，所以在不涉及输入输出的变量上要开long double,要输入和输出的开double
因为这个改了一晚上orz


---

## 作者：Starlight237 (赞：6)

算法本质：二分+模拟

本题解将给出一些代码优化的技巧。最终代码114ms。
- 原则1：对于读入量大的题目，使用fread将会使运行速度飙升。
- 原则2：顺序访问数组时，指针永远比for循环快。
- 原则3：浮点数（尤其是long double）运算严格慢于整数。

note：本篇题解默认：
```cpp
#define reg register
#define ll long long
```

首先，对于原则1，我们使用如下的模板：
```cpp
static char in[10000000],*p=in,*t=ch;
inline int read(){
	reg int x=0;
	while(*p<48)++p;
	while(isdigit(*p))x=(x+(x<<2)<<1)+(*p++^48);
	return x;
}
```
注：因为除了数字字符只有空格和回车，两者的ASCII码均小于'0'的ASCII码。故可以直接使用```*p<48```而不是isdigit。

对于原则2，本质上就是如下的for循环变换：
```cpp
for(reg int i=1;i<=n;++i)work(a[i]);
化为：
_T *S=a,*E=a+n;
while(S!=E)work(*++S);
```
## 重点：原则3
为了用long long代替long double，我们将读入的整数乘上一个很大的数，这样精度范围内可以认为它已经没有了小数数位。

事实上，只要乘上10000，精度就足够了。但是乘法很慢，我们发现$2^{13}<10000<2^{14}$，所以可以将乘10000换成左移14位。

考虑到用到long double的只有s数组和二分出的答案，所以只需要将s数组和左右边界乘$2^{14}$。然后全部用long long运算。

显然如果数据合理，有$\max\{x_i,y_i\}=y_n$（时间如果不递增岂不是无解），而显然最大速度达到它的时候必然能满足条件，所以我们将右边界可以设为$y_n*2^{14}+1$，即$(y[n]<<14)+1$。

最终答案在long double类型下乘以$2^{-14}=0.00006103515625$，再强转为double保留两位小数输出。
# 最终代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define reg register
#define ll long long
static char in[10000000],out[20],ch[20],*p=in,*q=out,*t=ch;
static int n;
static ll x[200001],y[200001],s[200001],ans;
inline long double mx(long double a,long double b){return a>b?a:b;}
inline int read(){
	reg int x=0;
	while(*p<48)++p;
	while(isdigit(*p))x=(x+(x<<2)<<1)+(*p++^48);
	return x;
}
int main(){
	fread(in,1,10000000,stdin);
	n=read();
	reg ll *s1=x,*s2=y,*s3=s,*e1=s1+n,*e2=s2+n,*e3=s3+n;
	while(s1<e1)*++s1=read(),*++s2=read(),*++s3=(ll)(read())<<14;
	reg ll l=0,r=((*s2)<<14)+1,mid;
	while(l<=r){
		mid=l+r>>1;
		reg long double tm=0;
		s1=x,s2=y,s3=s;
		while(s1<e1){
			tm+=(long double)(*++s3)/mid;
			if(tm<=*++s2)tm=mx(tm,*++s1);
			else {l=mid+15;goto end;}
		}ans=mid,r=mid-15;
		end:;
	}
	printf("%.2lf",double((long double)ans*0.00006103515625));
	return 0;
}
```
这份代码（暂时是）最优解Rank2。至于Rank1？~~没办法2017的评测机永远那么快，还有0ms的点？！~~

---

## 作者：zjy111 (赞：4)

这是一道二分答案题(标签上明明白白的写着呢)

简单介绍一下二分: ~~(大佬请自行跳过)~~

所谓二分答案, 就是一种暴力枚举的升级版(个人见解), 

每次寻找可能的所有答案中最中间的那个并和标准答案满足的条件进行比较, 

由不同的比较结果推出最终答案.

比如说大家应该都玩过的猜数字游戏, 

每次都是猜范围两个端点的平均数以筛掉一半的错解, 

使总体复杂度(猜的次数)最优$(logn)$.

.

那么我们自然就可以想到将车的速度从$0$到$1e7$进行二分, 

(因为距离最大$1e7$, 而且保证初始时间$x[i]$递增且为整数, 那么总时间最低为1, 所以速度最大就是$1e7$啦)

并且如果发现这个速度使得在某段路中其到达时间$t$大于结束时间$y[i]$, 那么就说明这个速度过慢, 

继续在比这个速度快那一半区间查找, 否则速度过慢, 

当左右边界值差小于一个设定的数值$opt$时, 终止循环即可

## 坑点注意:
- 这道题说"若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收", 所以如果到达时$t<x[i]$, 那么必须等到$x[i]$才能继续出发

- 这道题说保留两位小数, 但是我在上文中说的$opt$却不可以设置成$1e-2$或$1e-3$, 至少要$1e-5$, 否则会被**卡精度**

- 就算注意到了以上两点, 这道题也只有90分, 最后一个点玄学WA是因为double精度不够, **要开long double**, 并且使用对应的输入输出函数!

献上码风奇特的代码(含注释)
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x[200005],y[200005],s[200005]; //变量描述如题
long double opt=1e-8;  //这里我开了1e-8反正不会TLE
int main() {
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d%d%d",&x[i],&y[i],&s[i]);
	long double l=0,r=1e7,ans=0;  //准备二分
	while(r-l>opt){ //这里如果设成r>l容易进入类似死循环的过程
		long double mid=(long double)(l+r)/2.0,t=0;  
		bool ck=1;
		for(int i=1;i<=n;i++){ //对于当前"答案"mid进行判断
			t+=(long double)s[i]*1.0/mid; //模拟运送包裹的过程
			if(t<x[i])t=x[i]; //见坑点1
			if(t>y[i]){
				ck=0;break; //速度太慢,加速
			}
		}
		if(ck)r=mid-opt; //速度可以再慢一些
		else ans=max(ans,mid),l=mid+opt; //要加速
	}
	printf("%.2LF",ans); //long double 输出
	return 0;
}
```

---

## 作者：Hercules (赞：1)

## 题解：P1542 包裹快递

妥妥的一道二分答案，一般来说，每年NOIP大概都会有和二分有关的题，属于重要的知识点。

题目不再赘述，要求的就是一个最小的速度。

我们写一个$check$函数来判断当前$mid$的速度是否可以满足题意。

其中有3种情况：

$\ \ \ \ $1.满足到达$i$地的时间恰好在$xi[i]$和$yi[i]$的区间内。

$\ \ \ \ $2.到达的时间早于$xi[i]$，需等待客人来签收。

$\ \ \ \ $3.到达的时间晚于$yi[i]$，速度太小不满足题意。



```c
#include <bits/stdc++.h>
#define int long long    //犯懒了直接这么写的，会浪费一些空间和时间

typedef long double db;
const db eps = 1e-3;
const int MAXN = 2e5 + 10;
db l, r, sum[MAXN];
int n, xi[MAXN], yi[MAXN], si[MAXN];

inline int read() {
    //快读
	int X = 0, flag = 0;
	char ch = 0;
	while (!isdigit(ch))
		flag |= ch == '-', ch = getchar();
	while (isdigit(ch))
		X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
	return flag ? -X : X;
}

inline bool check(db x) {
    db Timeclock = 0;    //意思是到达i地的时间
    for (register int i = 1; i <= n; i++) {
        Timeclock += (db)si[i] / x;
        if (Timeclock > yi[i])
            return false;
        if (Timeclock < xi[i])
            Timeclock = xi[i];
    }
    return true;
}

signed main() {
	n = read();
	for (register int i = 1; i <= n; i++) {
		xi[i] = read(), yi[i] = read(), si[i] = read();
        r += (db)si[i], sum[i] = sum[i - 1] + (db)si[i];
	}
    while (r - l >= eps) {
        db mid = (l + r) / 2;
        if (check(mid))
            r = mid;
        else
            l = mid;
    }
    printf("%0.2Lf\n", r);    //long double所以用Lf
    return 0;
}
```



---

## 作者：rfsfreffr (赞：1)

分析题目:
1.要求的是最大速度的最小值

2.当我们到达一个地点的时候，还没到这个地点的签货时间，可以等到地点签货时间开始了再走

3.xi单调递增

很明显，我们可以全程保持着最大速度，这样可以更加的有机会抵达后面的,签货地点。

而且如果当速度为v的时候，可以抵达所以签货地点，那么当速度为(v+x)的时候，也可以抵达所有地点。所以这个问题是有单调性的，可以二分答案。具体细节看代码注释

**注:我开了long double 才过**

# 代码:

```cpp
#include <bits/stdc++.h>
#define double long double
using namespace std;
struct oi{
	double x,y,s;
}a[2000001];
int n;
bool check(double v){
	double t=0;
	for(int i=1; i<=n; i++){
		t=t+(double)(a[i].s)/(double)(v); //计算到下一个地方的最早的时间
		if(t>a[i].y) {//如果全程保持最大速度还来晚了，那就直接return 0;
			return 0;
		}
		if(t<a[i].x){//如果来早了，那就等到可以开始签收的时间再走
			t=a[i].x;
		}
	}
	return 1;
}
int main(){
	cin>>n;
	for(int i=1; i<=n; i++)	scanf("%LF%LF%LF",&a[i].x,&a[i].y,&a[i].s);
	double l=0,r=2e9;//二分速度
	while(l<=r){
		double mid=(l+r)/2;
		if(check(mid)){//如果当前速度有解，那么所有速度大于当前速度的数值就都有解，直接放弃那些数值，搜比当前数值更小的数值 所以是r=mid-(derla)
			r=mid-0.00001;
		} else l=mid+0.000001;
	}
	printf("%0.2LF",l);
	return 0;
} 
```

---

## 作者：__int (赞：1)

一道二分水题：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct wp{int x,y,s;}a[210005];
double r=1.1e7,l=0,eps=1e-6;
bool check(long double x)
{
	long double t=0;
	for(int i=1;i<=n;++i)
	{
		t+=a[i].s/x; //开始模拟，t代表当前时间
		if(t>a[i].y)return 0; //晚了，送不到
		if(t<a[i].x)t=a[i].x; //早了，要再等会
	}
	return 1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i].x>>a[i].y>>a[i].s;
	while(r-l>eps)
	{	//由于在R内，只要r-l的差大于设置好的eps值，就继续二分
		long double mid=(l+r)/2;//为防止精度丢失，得用long double
		if(check(mid)) r=mid;
		else l=mid;
	}
	cout<<setprecision(2)<<fixed<<r;//其实cout也可以像这样保留位数
	return 0;
}
```


---

## 作者：tifa (赞：0)

第一次发题解，看了看其他人觉得自己写的很通俗易懂，本质上就是二分法用double搜索，直到抵达一个精度。这里精度设置成1e-4。代码写的很清楚了。


```cpp
#include <iostream>
#include <cstring>
#include <stdio.h>
#include <algorithm>
#include <stdlib.h>
int read() {
    int sum = 0, fl = 1;
    int ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-') fl = -1;
    for (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';
    return sum * fl;
}
const int N = 2e5 + 100;
int n;
double ans = 0x3f3f3f3f,eps = 1e-4;//精度设置1e-4,因为只用保留两位小数
struct node{
    double x,y,s;
}arr[N];

bool test(double a){
    double t = 0;//t指的是前一个目的地，最快用当前速度a可以什么时候到
    for(int i = 1; i <= n; i++){
        if (arr[i].s > (arr[i].y - t) * a) return false; //如果我前一个地方连现在这个地方的最晚时间都到不了，就false
        t = std::max(arr[i].x, t + arr[i].s / a);//很关键，如果从上一个t连这个目的地的x都到不了，那t就是x，否则就是t + arr[i].s/a
    }
    return true;
}


int main(){
    n = read();
    for(int i = 1;i <= n; i++) scanf("%lf%lf%lf",&arr[i].x, &arr[i].y, &arr[i].s);
    double left = 0, right = 1e7;//开始binary search
    while(right - left > eps){
        double mid = (right + left) / 2;
        if (test(mid)) right = mid,ans = std::min(ans,mid);
        else{
            left = mid + 1e-4;
        }
    }
    printf("%.2lf\n",ans);
    return 0;
}


```


---

## 作者：那一条变阻器 (赞：0)

一看到最小的最大就能知道是二分啦

------------

对于这道题，我们要二分的值肯定是可以知道的：行驶速度，因为求的是速度，而边界条件就为$0$和最大的速度也就是路程总和了，对于精度，一般开在题目要求的精度上加$4$就行。$cheak$函数当然就是看以这个速度行走，能否到达终点即可。注意：题目虽然是说每一次的速度可以不一样，但是我们都按最大值的话，可以到达后等待一会儿，效果是一样的。能达到$r$就往$mid$移，缩小，反之。


知道了这些后，代码就好写了：
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	double s , t , dis;	//起点 终点 距离 
};
int n;
double l , r , mid , eps = 1e-6;
node a[200010];
bool cheak(double speed){
	double time = 0;
	for(int i = 1; i <= n; i++){
		time += a[i].dis / speed;	//求时间 
		if(time < a[i].s){	//等待 
			time = a[i].s;
			continue;
		}
		if(time > a[i].t) return false;	//无法到达 
	}
	return true;
}
int main(){
	scanf("%d" , &n);
	for(int i = 1; i <= n; i++) scanf("%lf%lf%lf" , &a[i].s , &a[i].t , &a[i].dis) , r += a[i].dis;	//求上界 
	while(r - l > eps){
		mid = (l + r) / 2;
		if(cheak(mid)) r = mid;
		else l = mid;
	}
	printf("%.2f" , l);
	return 0;
}
```

交上去后，最后一个点被卡了对吧，是精度问题，于答案差$0.01$，咋办？这时就要请出比double更厉害的类型，long double，所有都改成long double即可过。（注意，用scanf的话搭配的输入应该是scanf("%Lf")）。

AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	long double s , t , dis;
};
int n;
long double l , r , mid , eps = 1e-6;
node a[200010];
bool cheak(long double speed){
	long double time = 0;
	for(int i = 1; i <= n; i++){
		time += a[i].dis / speed;
		if(time < a[i].s){
			time = a[i].s;
			continue;
		}
		if(time > a[i].t) return false;
	}
	return true;
}
int main(){
	scanf("%d" , &n);
	for(int i = 1; i <= n; i++) scanf("%Lf%Lf%Lf" , &a[i].s , &a[i].t , &a[i].dis) , r += a[i].dis;
	while(r - l > eps){
		mid = (l + r) / 2;
		if(cheak(mid)) r = mid;
		else l = mid;
	}
	printf("%.2Lf" , l);
	return 0;
}
```


---


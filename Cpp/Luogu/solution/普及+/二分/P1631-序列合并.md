# 序列合并

## 题目描述

有两个长度为 $N$ 的**单调不降**序列 $A,B$，在 $A,B$ 中各取一个数相加可以得到 $N^2$ 个和，求这 $N^2$ 个和中最小的 $N$ 个。

## 说明/提示

对于 $50\%$ 的数据，$N \le 10^3$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le a_i,b_i \le 10^9$。

## 样例 #1

### 输入

```
3
2 6 6
1 4 8```

### 输出

```
3 6 7```

# 题解

## 作者：Red_w1nE (赞：368)

最近有点忙 没时间贴代码了==

【分析】

首先，把A和B两个序列分别从小到大排序，变成两个有序队列。这样，从A和B中各任取一个数相加得到N2个和，可以把这些和看成形成了n个有序表/队列：

A[1]+B[1] <= A[1]+B[2] <= … <= A[1]+B[N]

A[2]+B[1] <= A[2]+B[2] <= … <= A[2]+B[N]

……

A[N]+B[1] <= A[N]+B[2] <= … <= A[N]+B[N]

接下来，就相当于要将这N个有序队列进行合并排序：

首先，将这N个队列中的第一个元素放入一个堆中；

然后；每次取出堆中的最小值。若这个最小值来自于第k个队列，那么，就将第k个队列的下一个元素放入堆中。

时间复杂度：O(NlogN)。


priority\_queue<int, vector<int>,greater<int> >  q;


---

## 作者：雷州半岛岛主 (赞：290)

~~**各位，我发现有一种新奇的做法就能解决此题~**~~
#  39行实测AC代码+思路
## 先讲思路。
- 很显然我们有 _a和b两个数组_ 。
- 很显然我们要用一个 _c数组存和_ 。
- 很显然要用heap堆排(**实际上是只用了向下维护操作**)。
- 我们的c[ i ][ j ]，用来存储**a中第i个数分别和b中的所有数相加得到的结果**。很显然 会 爆空间，所以等下会有优化。

```cpp
		for (int i = 1;i <= n;i++)
        	for (int j = 1;j <= n;j++)
        		c[i][j] = a[i]+b[j];//a中第i个数分别和b中的所有数相加得到的结果
    	
```
- 依题意得：a是有序数列，b也是有序数列，则对于任意c[ i ]也会是一个有序数列。
- 那么我们就把c[ i ]的第一个数存入heap。

```cpp
		for (int i = 1;i <= n;i++)
        		heap[i] = c[i][j];	
    	
```
- 然后维护一下heap
- while（没有输出够n个数）
- {
- 输出；
- 放入 **堆顶数所在的数组的下一个数**（好好咀嚼一下） 
- 维护
- }

### 优化
- 经过arfa同志的提醒，我们发现定义的c数组会爆空间。
- 于是我们开始了优化之旅。
- 首先我们知道，heap[ i ]只需要用一个值，那我们可不可以在heap需要的时候再把c[ i ][ j ]算出来呢？
- 然后我们发现 c[ i ][ j ] = a[ i ]+b[ j ]中i相当于目前对顶数所在的数组，j就表示下一个数的下标。
- 于是优化就出来了。

```cpp
    for (int i = 1;i <= n;i++) heap[i] = a[i]+b[1]
     ……
    int t = from[1];
    step[t]++;
    heap[1]=a[t] + b[ step[t] ];

```
- 有人可能看不懂。我做一个比喻吧。假如你是拱野驾校隔壁的老王肠粉店店长，因为拱野驾校的学员很多，所以你的生意很红火。但是他们想要各种口味的。你想了一个办法：买来几个碟子，先把各种肠粉都做几份，再卖出去。实际上，你只需要现做现卖的合成就~~ojbk~~了。


## 上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100000],b[100000],heap[100000],from[100000],step[100000],n,sum=1;
void swap(int x,int y)//手打swap交换，同时交换来源数组。
{
	int k = heap[x];
	heap[x] = heap[y];
	heap[y] = k;
	k = from[x];
	from[x] = from[y];
	from[y] = k;
}
int main()
{
	scanf("%d",&n);
	for (int i = 1;i <= n;i++) scanf("%d",&a[i]);
	for (int i = 1;i <= n;i++) scanf("%d",&b[i]);
	for (int i = 1;i <= n;i++) heap[i] = a[i]+b[1],from[i] = i,step[i] = 1; 
    //这一步就是优化。把c去掉了，取而代之的是现做现卖的合成。
	while (sum <= n)
	{
		printf("%d ",heap[1]);
		int t = from[1];
		step[t]++;
		heap[1]=a[t] + b[ step[t] ];//现做现卖的合成。
		int x = 1,s;
		while (x<<1 <= n)//经典的下传
		{
			s = x<<1;
			if (heap[s] > heap[s + 1] && s + 1 <= n) s++;
			if (heap[x] > heap[s])
			{
				swap(x,s);
				x = s;	
			}else break;
		}
		sum++;	
	}
	return 0;
}
```


---

## 作者：ysner (赞：154)

首先声明，我想发题解是因为我觉得我的代码最短、最简洁，并运用了将两个优先队列绑定起来的数据结构（pair）。

这道题和果子合并非常像，每次都是取2个最小的数，但是本题中每个数可以取多次，但是数对不能重复，但是算法还是一样的，利用优先队列.

由于本题中的数据已经排好序了，所以如果选取了坐标为i,j的两个数，那么下一次可能选i+1,j或i,j+1,这样的话由于每个数可以取多次容易重复，所以使用SET判重，这样的话由于要使用两个结构体，比较容易写错.

还有一种比较简单的方式，首先不管怎么样,A序列中的第一个数绝对要选，那么这个数可能和B序列中的任何一个数组成的数对被选，全部加入优先队列中，这样处理了i,j+1的情况，但是还有i+1,j的情况，每次输出一个和之后，将B序列中的第i个数对应的A序列中的第j个数的j++.

但是这样数对还是容易重复，怎么办呢？可以用一个数组记录一下，to[i]表示B序列中的第i个数与A序列中的第几个数相加，每次入队的时候累加to数组就不会造成重复了！

```cpp
#include<cstdio>  
#include<queue>   
using namespace std;
int a[100005]={}, b[100005]={}, to[100005]={},i, n;
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >q;
int main()
{
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (i = 1; i <= n; i++)
    {
        scanf("%d", &b[i]); to[i] = 1;
        q.push(pair<int, int>(a[1] + b[i], i));
    }
    while (n--)
    {
        printf("%d ", q.top().first);
        i = q.top().second; q.pop();
        q.push(pair<int, int>(a[++to[i]] + b[i], i));
    }
    return 0;
}
```

---

## 作者：TonyBrown148 (赞：114)

本篇题解不是严格的$O(nlogn)$，实际上，它是$O(nlog^2n)$的，但是，AC了

进入正题：

我一开始想用一个暴力先骗点分，于是，就想到了枚举所有和并把答案存在优先队列里，差不多这个样子（码风还好，不太需要解释）：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<queue>
using namespace std;
priority_queue<int>q;
int n,a[100005],b[100005],ans[100005];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
    	scanf("%d",&b[i]);
    }
    sort(a+1,a+n+1);
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=n;j++){
    		int x=a[i]+b[j];
    		if(q.size()<n){
    			q.push(x);
    		}
    		else{
    			if(q.top()>x){
    				q.pop();
    				q.push(x);
    			}
    		}
    	}
    }
    for(int i=n;i>=1;i--){
    	ans[i]=q.top();
    	q.pop();
    }
    for(int i=1;i<=n;i++){
    	printf("%d ",ans[i]);
    }
    return 0;
}
```

复杂度$O(n^2logn)$，60分

现在开始优化

仔细想想，若$a_i+b_j$没有放入优先队列，那$a_i+b_{j+1}$呢？

不会，因为$b_{j+1}>b_j$，所以$a_i+b_{j+1}>a_i+b_j>q.top$，无法放入

所以在$a_i+b_j$没有放入优先队列时，$a_i+b_{j+n}(n>0)$也都不会被放入，可以直接break一下跳到$a_{i+1}+b_1$继续枚举

于是：
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<queue>
using namespace std;
priority_queue<int>q;
int n,a[100005],b[100005],ans[100005];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
    	scanf("%d",&b[i]);
    }
    sort(a+1,a+n+1);
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=n;j++){
    		int x=a[i]+b[j];
    		if(q.size()<n){
    			q.push(x);
    		}
    		else{
    			if(q.top()>x){
    				q.pop();
    				q.push(x);
    			}
    			else{
    				break;
    			}
    		}
    	}
    }
    for(int i=n;i>=1;i--){
    	ans[i]=q.top();
    	q.pop();
    }
    for(int i=1;i<=n;i++){
    	printf("%d ",ans[i]);
    }
    return 0;
}
```

这个代码AC了

时间复杂度吗，下面给出我的思路，证明不是太难：

第一行至多扫完它的$\dfrac{1}{1}$

第二行变为$\dfrac{1}{2}$

以此类推，第$i$行至多$\dfrac{1}{i}(1 \le i \le n)$

合在一起，共$\dfrac{1}{1}+\dfrac{1}{2}+\cdots+\dfrac{1}{n}$

欧拉证明过，上面的无穷级数的增长率为$O(lnn)$的

因此，总复杂度为$O(n\ logn\ lnn)$也就是$O(nlog^2n)$的，证毕

---

## 作者：csyakuoi (赞：94)

#有不用优先队列，代码不到30行的做法~~（P党福利）~~。

当$i*j>n$时，$A_i+B_j$一定不是前$n$小的数。

理由：因为两个序列均有序，所以如果$x<=i$而且$y<=j$那么$A_x+B_y<A_i+B_j$。于是至少有$i*j$个数小于等于$A_i+B_j$。
当$i*j>n$时，一定有多余$n$个数小于等于$A_i+B_j$，所以$A_i+B_j$一定不是前$n$小的数。

于是，我们可以枚举可能成为前$n$小的数的$A_i+B_j$，然后排序输出~~（P党不用手写优先队列拉）~~。

---

## 作者：KryptonAu (赞：56)

# 朴素解法
直接把n^2个和都插入堆中，然后输出，复杂度为O(N^2logN)，本题数据N<100000,肯定过不了。

```
#include<queue>
#include<cctype>
#include<cstdio>
using namespace std;
template<class T>
inline void read(T &x)
{
    x=0; int sign=1; char c;
    do{ c=getchar(); if(c=='-') sign=-1;}while(!isdigit(c));
    do{ x=x*10+c-'0',c=getchar();}while(isdigit(c));
    x*=sign;
}
int n,a[100001],b[100001];
int main()
{
    read(n);
    for(register int i=1;i<=n;++i) read(a[i]);
    for(register int i=1;i<=n;++i) read(b[i]);
    priority_queue<int> q;
    for(register int i=1;i<=n;++i)
    for(register int j=1;j<=n;++j)
    q.push(-a[i]-b[j]);
    for(register int i=0;i<n;++i)
    {
        printf("%d ",-q.top());
        q.pop();
    }
    return 0;
}

```
- 事实上，只要在朴素算法的代码上加一个小优化就行了。
- 两个长度为N的数列，和的总数为N^2，而答案只要输出其中最小的N个即可，那容易想到，在往堆中插入时就排除掉一些绝对不可能是答案的数。
- 假设此时要把 $a[i]+b[j]$ 插入堆，且$(i-1)*(j-1)>N$,那么这个数一定不会是最后的答案，因为对于$1<=s<i,1<=t<j$，可组成的和已经超过N个，且都要比$a[i]+b[j]$小。

## AC代码

```
#include<queue>
#include<cctype>
#include<cstdio>
using namespace std;
template<class T>
inline void read(T &x)
{
    x=0; int sign=1; char c;
    do{ c=getchar(); if(c=='-') sign=-1;}while(!isdigit(c));
    do{ x=x*10+c-'0',c=getchar();}while(isdigit(c));
    x*=sign;
}
int n,a[100001],b[100001];
int main()
{
    read(n);
    for(register int i=1;i<=n;++i) read(a[i]);
    for(register int i=1;i<=n;++i) read(b[i]);
    priority_queue<int> q;
    for(register int i=1;i<=n;++i)
    for(register int j=1;(i-1)*(j-1)<=n&&j<=n;++j) //这里加一句就行了
    q.push(-a[i]-b[j]);
    for(register int i=0;i<n;++i)
    {
        printf("%d ",-q.top());
        q.pop();
    }
    return 0;
}

```


---

## 作者：huainan_marquis (赞：46)

高票答案普遍采用一种做法，如图（用画图做的，看起来不是很好）。
![](https://cdn.luogu.com.cn/upload/pic/46110.png)
由图意，因为每一行每一列都是按顺序从小到大，所以
			a1+b1<a2+b1;
            a1+b1<a1+b2;
即按着箭头的方向从小到大，但不能判断a1+b2和a2+b1谁大，所以呢，他们想出来一个办法，最开始把第一行
a1+b1,a2+b1,a3+b1,a4+b1,a5+b1全部压入堆,此时想当然a1+b1这个最小，把这个弹出来输出，再把下面的a1+b2压进去，这个时候，自然就能判断他与a2+b1谁大谁小，所以呢，再将最小的取出，将他下面的那个压入。

因为本专题是堆，这当然是个很不错的做法，不过实现上略有麻烦，本题完全可以采取下面我这个思路。

主程序非常短，那是采取了什么思路呢？
如图所示：
![](https://cdn.luogu.com.cn/upload/pic/46095.png)

由图意，只有我涂的那些地方可能是前n小的，假如a3+b2是前n小的，那么从a1+b1到a3+b2全都是小于等于a3+b2，很明显这就不对了，所以可以得出一个结论:对于第i行第j列，他至少是第i*j 大的数，左、上方的肯定都比他小或者等于；所以，不难得出要把哪些压进堆里了。 

```cpp
#include <iostream>
#include <queue>
#include <cstdio>
#include <math.h>

using namespace std;

#define LL int

const int maxn = 1e5+10;

LL a[maxn],b[maxn];

priority_queue<LL,vector<LL>,greater<LL> >p1;

int main()
{
    int n;
    cin>>n;
    for(int i = 1;i<=n;i++) scanf("%d",&a[i]);
    for(int i = 1;i<=n;i++) scanf("%d",&b[i]);

    for(int i =1;i<=sqrt(n);i++){
        for(int j =i;j<=n/i;j++) p1.push(a[j]+b[i]);
        for(int j =i+1;j<=n/i;j++) p1.push(a[i]+b[j]);
    }

    for(int i =0;i<n;i++){
        printf("%d ",p1.top());
        p1.pop();
    }
    return 0;
}

```
最后说一下时间复杂度，小于O(n(logn)^2)，不过n/1+n/2+n/3+...+n/sqrt(n)复杂度是多少？肯定小于nlogn的.

---

## 作者：laorui (赞：42)

二分答案
把答案在这N^2个数中逐排比较
遇到大于答案的或符合条件的数超了就break
最后选出小于答案的sort一下输出前N个就行了
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100007],b[100007],answer[1000007];int n;//注意answer要开大，因为可能有重复 
bool judge(int x)
{int sum=0;
for(int i=1;i<=n;++i)
{if(sum>n||a[i]+b[1]>x)break;
for(int j=1;j<=n;++j)
{if(a[i]+b[j]<x)
{++sum;if(sum>n)break;}
if(a[i]+b[j]>x)break;}}
if(sum>=n)return 1;
else return 0;
}
int main()
{cin>>n;
for(int i=1;i<=n;++i)
cin>>a[i];
for(int i=1;i<=n;++i)
cin>>b[i];
int l=a[1]+b[1],r=a[n]+b[n];
while(l!=r)//二分模板 
{int mid=(l+r)/2;
if(judge(mid)==1)
r=mid;
else l=mid+1;}
--l;
int s=0;
for(int i=1;i<=n;++i)
{if(a[i]+b[1]>l)break;//注意超了不要跳 
for(int j=1;j<=n;++j)
{if(a[i]+b[j]<=l)
{++s;answer[s]=a[i]+b[j];}
else break;}}
sort(answer+1,answer+s+1);
for(int i=1;i<=n;++i)
cout<<answer[i]<<" ";
return 0;
}
```

---

## 作者：梦回还 (赞：19)

本人的思路同楼下众大佬一致，就是做法不太一样，可以参考参考。

我们发现对于两个序列中的数，a[i]+b[j]<a[i+1]+b[j]，a[i]+b[j]<a[i]+b[j+1]；

并且很明显有a[1]+b[1]<a[2]+b[2]<……那么我们将其和（N个）压入优先队列。

只要有 i==j 的点被弹出，我们就把 a[i+1]+b[i] 与a[i]+b[i+1] 压入优先队列,

否则，当 i<j 时，将 a[i]+b[j+1] 压入即可； 当 i>j 时，将 a[i+1]+b[j] 压入。

为什么 i<j 时不压入  a[i+1]+b[j] ？我们考虑到此时 a[i+1]+ b[j-1] 及之前的数字可能依旧在优先队列中并且更优，就不必更新。

i>j 时不压入  a[i]+b[j+1],同理。



```cpp
#include<queue>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 100005;
struct data{
    int x, y, v;
    bool operator <(const data &y) const{
        return v > y.v;
    }
};
int n, a[N], b[N], X[N], Y[N];
priority_queue<data> pq;
//在结构体中重定义小于号，维护一个小根堆
int read()
{
    int x = 0;
    bool f = 0;
    char ch = getchar();
    while(!isdigit(ch)) {
        if(ch == '-') f = 1;
        ch = getchar();
    }
    while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ '0'), ch =getchar();
    return !f ? x : -x;
}
//优雅的读入优化
int main()
{
    scanf("%d",&n);
    data x, y, k;
    int tot = n;
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
    for(int i = 1; i <= n; i++) scanf("%d",&b[i]);
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);
    for(int i = 1; i <= n; i++) k.x = k.y = i, k.v = a[i] + b[i], pq.push(k);
    for(int i = 1; i <= n; i++)
    {
        k = pq.top(); pq.pop();
        printf("%d ", k.v);
        if(k.x == k.y)
        {
            x.x = k.x; x.y = k.y + 1; x.v = a[x.x] + b[x.y]; pq.push(x);
            y.x = k.x + 1; y.y = k.y; y.v = a[y.x] + b[y.y]; pq.push(y);
        }
        else
        {
            if(k.x > k.y) y.x = k.x + 1, y.y = k.y, y.v = a[y.x] + b[y.y], pq.push(y);
                else x.x = k.x, x.y = k.y + 1, x.v = a[x.x] + b[x.y], pq.push(x);
        }
    }
    return 0;
}
```

---

## 作者：微雨燕双飞 (赞：18)

看楼下题解几乎都是STLpriority_queue的，只有一份手写堆（当然dalao写得是比蒟蒻好得多的）。我在此发布一份纯手写堆的，供大家参考（至少时空效率还是很有保证地，嘻嘻）程序中用的是大根堆（因为如果用小根堆会无法比较，其原因是小根堆的堆顶元素是堆中的最小值，而最后最小的n个和可能比堆顶小）
好，来看优美（chou lou）的代码，本人最近练二叉堆练到疯，最简单的题也硬是写出了平衡树的代码量，不过应该不影响阅读，请大家海涵：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+10;
int n,a[maxn],b[maxn],heap[maxn],size=0;
long long ans[maxn]; //这里其实没必要开到int64
void up(int p) //二叉堆向上调整（非递归版）
{
  while(p>1)
  {
    if(heap[p]>heap[p/2])
    {
      swap(heap[p],heap[p/2]);
      p/=2;
    }
    else break;
  }
}
void insert(int val) //将新元素插入堆底并不断向上调整
{
  heap[++size]=val;
  up(size);
}
void down(int p) //二叉堆向下调整（非递归版）
{
  int s=p*2;
  while(s<=size)
  { //这句话是选择左右儿子中更大的一个交换
    if(s<size&&heap[s+1]>heap[s]) s++;
    if(heap[s]>heap[p])
    {
      swap(heap[s],heap[p]);
      p=s; s=p*2; //不断向下
    }
    else break;
  }
}
void change(int val) //置换堆顶，向下调整
{
  heap[1]=val;
  down(1);
}
void extract() //删除堆顶，向下调整
{ //注意此函数与change功能不同
  heap[1]=heap[size--];
  down(1);
} 
int gettop() //返回堆顶
{
  return heap[1];
}
int main()
{
  cin>>n;
  for(int i=1; i<=n; i++) cin>>a[i];
  for(int i=1; i<=n; i++) cin>>b[i];
  for(int i=1; i<=n; i++) insert(a[1]+b[i]); //建堆
  for(int i=2; i<=n; i++)
    for(int j=1; j<=n; j++)
    {
      if(a[i]+b[j]>=gettop()) break; //如果比堆顶大，就退出
      change(a[i]+b[j]); //置换堆顶（最大元素）
    }
  for(int i=1; i<=n; i++) 
  {
    ans[i]=gettop(); //取出堆顶 
    extract(); //向下调整，维护大根堆
  }
  for(int i=n; i>=1; i--) cout<<ans[i]<<" "; //倒序输出
  return 0;
}
```

---

## 作者：ZhuMingYang (赞：9)

这道题居然没人写这种简单的算法

可能是答案的$a_i+b_j$一定满足$j\le\frac ni$

因为若$j>\frac n i$的话一定可以用$a_p+b_q(p\le i,q<j)$填满这n个数且小于$a_i+a_j$

再用堆维护

时间复杂度$O(n\ln n\log n)$

~~~c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
#include<map>
#include<bitset>
#include<set>
#include<queue>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define dwn(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
typedef long long ll;
int n,tmp,a[100010],b[100010];
priority_queue<int,vector<int>,greater<int> > pque;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=n;++i) b[i]=read();
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n/i;++j)
        {
            pque.push(a[i]+b[j]);
        }
    }
    for(int i=1;i<=n;++i)
    {
        printf("%d ",pque.top());
        pque.pop();
    }
    return 0;
}
~~~

---

## 作者：心非 (赞：7)

因为A和B是递增的，所以最小的n个数肯定是A和B前几个数的组合

话不多说，看代码:
```cpp
#include <cstdio>
#include <queue>
using namespace std;
int A[100005],B[100005];
priority_queue<int,vector<int>,greater<int>> pq;
int main(){
    int n,l=0,r=0;//设置两个指针，各指向数组的开头
	scanf("%d",&n);
	for(int i=0;i<n;i++) scanf("%d",&A[i]);
	for(int i=0;i<n;i++) scanf("%d",&B[i]);
	pq.push(A[l]+B[r]);//这个肯定最小，放进堆里
	while(pq.size()<3*n){//多选一些然后从堆里面输出最小的n个
		if(A[l]<=B[r]){//每次比较指针指向的数，小的那个指针向后移
			l++;
			for(int i=0;i<=r;i++) pq.push(A[l]+B[i]);//然后下一个指向的数与B的前r个数组合，扔进堆里
		}else{
			r++;
			for(int i=0;i<=l;i++) pq.push(A[i]+B[r]);//同上
		}
	}
	for(int i=0;i<n;i++) printf("%d ",pq.top()),pq.pop();//输出
    return 0;
}
```

---

## 作者：songhn (赞：5)

首先对于两个序列$a,b$最小的肯定是$a_1+b_1$，而次小的就有两种可能$min(a_1+b_2,a_2+b_1)$，假如现在次小是$a_1+b_2$，那么最小的比他大的数就是$min(a_1+b_3,a_2+b_2)$，再与之前的$a_2+b_1$一起更新第三小的值。

由此我们可以发现可以用优先队列来维护最小值，先把二元组$(1,1)$压入，在取出当前值$(x,y)$的时侯这个值对后面的答案产生了贡献$(x+1,y)$和$(x,y+1)$，我们便把他们一起压入，循环$n$次我们就得到了前$n$小的值。

但是我们又发现$(x,y+1)$和$(x+1,y)$可能产生$(x+1,y+1)$
这样情况相同，可以用$map$进行判重，这样就可以做出来了

这道题还可以拓展为有$m$个序列的情况（poj2442）其实是一样处理，先处理两个序列得到前$n$小的值把他当作一个新的序列，再和序列$c d e...$进行相同的操作便可以得到答案

另外由于优先队列默认是大根堆排序，所以在重载小于号时候是反着来的。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500010;
typedef pair<int,int> pp;
inline int read()
{
	int x=0,t=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')t=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*t;
}
int n,a[maxn],b[maxn];
map<pp,int> p;
struct node{
	int x,y;
	bool operator<(const node&t) const
	{
		if(a[x]+b[y]<a[t.x]+b[t.y]) return false;
		return true;
	}
	node(int X,int Y){x=X,y=Y;}
};
priority_queue<node> q;
int main()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) b[i]=read();
	q.push(node(1,1));
	for(int i=1;i<=n;i++)
	{
		while(p[make_pair(q.top().x,q.top().y)]) q.pop();
		int xx=q.top().x,yy=q.top().y;
		printf("%d ",a[xx]+b[yy]);
		p[make_pair(xx,yy)]=1;
		q.push(node(xx+1,yy));
		q.push(node(xx,yy+1));
	}
	return 0;
}
```

---

## 作者：command_block (赞：5)

不要问我从哪里来~

我的[$AC$](https://www.luogu.org/recordnew/show/17984953)在远方……

无脑数据结构选手携89行代码前来报到！

推性质是不可能推性质的，这辈子都不可能推性质的……

正解又不会写，只能够做经典题这种东西，才能维持得了生活的样子。

~~没看见A,B序列有序这么明显的提示~~

------------

这个解法需要写一个ST表维护区间最小值，再写一个堆维护全局最小值。

我们设一个答案元为$\{ans,p,l,r,f\}$

分别表示{答案，答案位置，B序列中元素区间[左，右]，A序列中元素号}

答案：用$A[f]$去加上$B[l...r]$能得到的最小和；

答案位置：上述最小和的B序列中元素号；

一开始有$n$个答案元，分别为{答案，i，$[1,n]$} (1<=i<=n)

预处理也很方便，贪心地查询$B[1...n]$的最小值与$A[f]$相加即可。

然后拿一个全局堆来维护这些答案元，即可做到不遗漏。

我们输出了一个答案元，就要把它枪毙，于是我们由

答案元$\{ans,p,l,r,f\}$

分裂成两个答案元$\{ans',p',l,p-1,f\}$和$\{ans'',p'',p+1,r,f\}$

那么就不包含$A[f]$与$B[p]$相加的情况了。

如果区间为空则不放进全局堆。

具体见代码吧。

(由于我懒，把ST表换成了线段树)

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define MaxN 100500
using namespace std;
inline unsigned int read()
{
  register unsigned int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,b[MaxN],ax[MaxN];
struct Data
{
  int f,l,r,p,ans;
  bool operator < (const Data B)const
  {return ans>B.ans;}
}sav,tsav;
priority_queue<Data> t;
struct Node
{int x,p;}a[MaxN<<2];
inline void up(int num)
{
  if (a[num<<1].x<a[num<<1|1].x)
  	a[num]=a[num<<1];
  else a[num]=a[num<<1|1];
}
void build(int l,int r,int num)
{
  if (l==r){
    a[num].x=b[l];
    a[num].p=l;
    return ;
  }int mid=(l+r)>>1;
  build(l,mid,num<<1);
  build(mid+1,r,num<<1|1);
  up(num);
}
int wfl,wfr,ansx,ansp;
void query(int l,int r,int num)
{
  if (wfl<=l&&r<=wfr){
  	if (a[num].x<ansx){
  	  ansx=a[num].x;
  	  ansp=a[num].p;
  	}return ;
  }int mid=(l+r)>>1;
  if (wfl<=mid)query(l,mid,num<<1);
  if (wfr>mid)query(mid+1,r,num<<1|1);
}
inline void getans(Data &A)
{
  wfl=A.l;wfr=A.r;
  ansx=1<<30;
  query(1,n,1);
  A.ans=ansx+ax[A.f];
  A.p=ansp;
}
int main()
{
  scanf("%d",&n);
  for (int i=1;i<=n;i++)ax[i]=read();
  for (int i=1;i<=n;i++)b[i]=read();
  build(1,n,1);
  for (int i=1;i<=n;i++){
  	sav.f=i;sav.l=1;sav.r=n;
  	getans(sav);
    t.push(sav);
  }
  for (int i=1;i<=n;i++){
  	sav=t.top();
    printf("%d ",sav.ans);
    t.pop();
    int np=sav.p;
  	if (np+1<=sav.r){
  	  tsav=sav;
  	  tsav.l=np+1;
  	  getans(tsav);
  	  t.push(tsav);
    }if (np-1>=sav.l){
      tsav=sav;
      tsav.r=np-1;
      getans(tsav);
      t.push(tsav);
    }
  }return 0;
}
```


---

## 作者：___new2zy___ (赞：5)

# 题解 P1631 【序列合并】

题目传送门：

**https://www.luogu.org/problemnew/show/P1631**

========================================================我是分割线=================


这个题，很模板，~~显而易见的~~**小根堆**(STL优先队列也可以)

今天上课老师的第一道例题，直接跳过了，都没讲~~（但是我很弱，打了一天）~~

不得不说，STL真好用，但是我用的手打堆很好，至少不会TLE~~~

===============以上是废话=================

这个题目本人认为属于**小根堆**的一个应用吧
= =~~(看不出来)~~

根据某知名刘ru jia(蓝书)的说法，我们如下不妨考虑::

先push(M=A[1~n]+B[1])入堆，记录b的下b_hand，然后从堆中弹出值最小的一个，push一个M=b[b_hand]+b[b_hand+1]入堆,一定是能得到所有最小的前n个经A，B组合之后的数。

以上算是大概思路了吧= =

**注意**我们在枚举元素时有两个参量数值（k）和序号（numb），大多数小伙伴都会用struct，但是本人用的是STL pair（其实我是拒绝的，因为很慢= =）也许看了不舒服，可以改回来的~~

普及一下：**pair所在库<utility>**（STL黑科技）

详细点的解释见下面的代码即可 :D

========================================================以下是code=================


请收下本人丑陋的代码，如有问题请dalao指出，先受我一%



    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<queue>
    #include<utility>//pair所在库
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;
    const int mod=10000;
    inline int read()//拙劣的快读
    {
        int p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
        while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return f*p;}
    int n,heap_size,A[100009],B[100009];//A,B如题,heap_size记录堆大小 
    pair <int ,int > Heap[300018];//定义pair小根堆
    bool operator < (pair <int ,int > &x,pair <int ,int > &y)//重载运算符"<" 
    {return x.first>y.first;//便于小根堆比较的函数(注意以数值k为第一关键字) 
    inline void put_in(int k,int numb)//小根堆插入元素 
    {
	    Heap[++heap_size]=make_pair(k,numb);
        int now=heap_size,next;
	    while(now>1)
	         {
	            next=now/2;
		        if(Heap[next]<=Heap[now])return ;
		        swap(Heap[next],Heap[now]);
		        now=next;
	         }
    }
    inline void insert_top()//小根堆删除堆顶 
    {
	    int now=1,next;
	    Heap[1]=Heap[heap_size--];
	    while(now*2<=heap_size)
	          {
	      	   next=now*2;
	      	   if(next<heap_size&&Heap[next]>Heap[next+1])next++;
	      	   if(Heap[now]<=Heap[next])return ;
	      	   swap(Heap[next],Heap[now]);
	      	   now=next;
	          }
    }
    inline void Init_()//读入各种数据 
    {
	    n=read();
	    for(int i=1;i<=n;i++)
	        A[i]=read();
	    sort(A+1,A+1+n);
	    for(int i=1;i<=n;i++)
	        B[i]=read();
	    sort(B+1,B+1+n);
	    //注意数据无序,要排序 
    }
    inline void pre_work()//把a[1~n]+b[1]放到堆中(初始)
    {
	    for(int i=1;i<=n;i++)
	        put_in(A[i]+B[1],1);
    }
    inline void Solve()//开始求解 
    {
	    pre_work();//见上
	    for(int i=1;i<=n;i++)
	        {
	    	    pair <int ,int > p=Heap[1];//取出堆顶 
	    	    insert_top();//删除堆顶 
	    	    printf("%d ",p.first);//输出值k(从小到大) 
	    	    int c=p.first,b_hand=p.second;
	    	    if(b_hand+1<=n)//构造新的b序号
	    	       put_in(c-B[b_hand]+B[b_hand+1],b_hand+1);
	    	    //这样求解保证最小
		    }
    }
    int main()//看,简洁的主函数= =
    {
	    Init_();
	    Solve();
	    return 0;
    }


希望大家能懂一些了吧= =，有什么bug给我私信哦

顺便推广我的博客：：
https://www.luogu.org/blog/new2zy/

拜拜┏(＾0＾)┛~~~



---

## 作者：0xC00000FD (赞：4)

本题最初始的想法就是O(n\*n)求出每一种组合:

	a[1]+b[1],a[1]+b[2],...,a[2]+b[1],a[2]+b[2],...,a[n]+b[n] 

(emmm...小蒟蒻打不来数学符号...)

但是n上到了100000,n\*n铁定T到飞起(当然也M到飞起)

我们遇到这种情况,第一个想法肯定是想一个数据结构什么的来优化时空间,我们马上想到一个插入删除方便的数据结构:二叉堆(不过显然只能删掉第一个元素)

众大佬:你这逗我呢?复杂度不还是O(n\*n\*log2(n\*n))吗!

别打!这次我们采用"逆向思维",小根堆解不了我们用大根堆!那么是怎么想到用大根堆的呢?请看:

	a[1]<=a[2]<=a[3]<=...<=a[n]
	b[1]<=b[2]<=b[3]<=...<=b[n]

所以我们假设堆中目前最大的元素是x,若插入一个a[i]+b[j]后发现:

	x<=a[i]+b[j]

那么,根据a组与b组的单调性,我敢说:
	a[i]+b[j+1]绝不会优于x

那么,反正a[i]+b[j]也不优于x,a[i]+b[j]可以出堆了,a[i]+b[j+1],...,a[i]+b[n]都没必要看了,i++,j=1即可

而且,根据单调性,之后要入堆判断的数量绝对会很快退化成常数

那么记住限制好堆的大小为n,不然内存会爆,建议手码,理由:

	1.也没几个字
	2.输出答案前可以直接调sort(偷懒)
	3.STL优先队列是用动态数组的,我个人不太喜欢,也容易一不小心忘记限制空间

好吧,再跟你讲吧,这个想法也可以A爆 P2085...

~~WA~~AC代码:

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
int n,size;
int a[100005],b[100005],hep[100005];
int read(){
	int res=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) res=res*10+ch-'0',ch=getchar();
	return res;
}
int top(){return hep[1];}
int get(){
	int res=hep[1];
	hep[1]=hep[size--];
	int fa=1,son;
	while((fa<<1)<=size){
		if((fa<<1|1)>size||hep[fa<<1]>hep[fa<<1|1])
		son=fa<<1; else son=fa<<1|1;
		if(hep[fa]>hep[son]) break;
		swap(hep[fa],hep[son]); fa=son;
	}return res;
}
void put(int x){
	hep[++size]=x;
	int son=size;
	while((son>1)&&(hep[son]>hep[son>>1]))
	swap(hep[son],hep[son>>1]),son>>=1;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
	a[i]=read();
	for(int i=1;i<=n;i++)
	b[i]=read();
	for(int i=1;i<=n;i++)
	put(a[1]+b[i]);
	for(int i=2;i<=n;i++)
	for(int j=1;j<=n;j++){
		int x=a[i]+b[j];
		put(x);
		if(top()==x){get();break;}
		else get();
	}
	sort(hep+1,hep+1+n);
	for(int i=1;i<=n;i++)
	printf("%d%c",hep[i],i==n?'\n':' ');
	return 0;
}
```


---

## 作者：君玘 (赞：4)

朴素算法求解，双重循环n的平方，会炸吧。所以就优化一下。

若有i个a序列数，j个b序列数，则有i×j个和，所以当i×j>n时break就行。因此，我们选出1个a，则需要n个b和它凑成n个和；如果选出2个a，则需要n/2个b和它凑成n个和；故不需要循环到n次。

题目中的两序列都是有序的，故选出前i个a，再找出n/i个b即可，后面的b就完全无用了。

上代码，各位看看罢(自认码风还行)：

```cpp
#include<bits/stdc++.h>
#define gc ch=getchar()
#define pc putchar(32)
using namespace std;
const int N=1e5+5;
template <class T>void read(T &s){
	s=0;T f=1;char gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;gc;}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';gc;}
	s*=f;	
}
template <class T>void put(T s){
	if(s<0) putchar('-'),s=-s;
	if(s>9) put(s/10);
	putchar(s%10+'0');
}
priority_queue<int,vector<int>,greater<int> >q;//小根堆 
int n,x,a[N],b[N];
int main(){
	read(n);
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=1;i<=n;++i) read(b[i]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j){   //双重循环暴力 
			q.push(a[i]+b[j]);    
			if(i*j>=n) break;    //最精髓的优化 
		}
	//n+n/2+n/3+n/4+...+1 当n=100000时,只会循环一百多万次，算不错啦，简单吧？ 
	for(int i=1;i<=n;++i) put(q.top()),pc,q.pop();
}
```

---

## 作者：zhangyuhan (赞：3)

# 一道很好的堆优化题

如果暴力把所有$n^2$个和求出来，再排序，最后输出，时间复杂度就为$n^2$个和从小到大排序的时间复杂度：$O(n^2\log{n})$，显然超时。

# 如何优化

首先，把$a$序列和$b$序列从小到大排序，然后建一个小根堆，数据结构类型是一个结构体。这个结构体里应该有3个变量:

```cpp
struct Note
{
	int id_a,id_b,sum;
    //id_a为当前a序列的元素下标
    //id_b为当前b序列的元素下标
    //sum为何两个元素之和
};

```

**为什么这么定义？**

我的思路是这样的：

首先，将$a$序列的所有数与$b$序列的第一个数（即$b$序列最小的数）相加，按照这些和的大小放入一个小根堆中。

接着，输出$n$个最小的值。

首先取出堆顶元素，将堆顶元素中的和输出，然后将这个堆顶元素的$id_b++$,就是将$id_a$对应的值与更大的$b$序列的值相加，再将$sum$更新，再放入堆内，这样循环$n$次就可以了。

# 时间复杂度

要输出$n$个最小的数，堆的$pop$和$push$操作都是$O(\log{n})$,所以总复杂度为$O(n\log{n})$，可过。

$AC$ $Code$

```cpp
#include <iostream>
#include <queue>//STL是个好东西
#include <algorithm>
using namespace std;

struct Note
{
	int id_a,id_b,sum;
	//id_a为当前a序列的元素下表
    //id_b为当前b序列的元素下表
    //sum为何两个元素之和
	bool operator < (const Note& a) const{
		return sum>a.sum;
	}//STL的堆需要重载运算符
};

priority_queue<Note> pq;//小根堆
int n,a[100010],b[100010];

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
		cin>>b[i];
	sort(a+1,a+1+n);//a序列排序
	sort(b+1,b+1+n);//b序列排序
	for(int i=1;i<=n;i++){
		pq.push((Note){i,1,a[i]+b[1]});
	}//往堆里放值
	for(int i=1;i<=n;i++){
		Note now=pq.top();
		pq.pop();
		cout<<now.sum<<" ";
		now.id_b++;
		now.sum=a[now.id_a]+b[now.id_b];
		pq.push(now);
	}//输出+更新堆
	cout<<endl;//强迫症带换行
	return 0;//完结撒花！
}
```

# 秋豆麻袋！还没讲完！

有人会对这段代码发出疑问：
```cpp
  now.id_b++;
  now.sum=a[now.id_a]+b[now.id_b];
  pq.push(now);
```
如果$id_b>n$了怎么办？$AC$程序里没有加特判啊！

其实不用加。

**Why?**

因为你只取$n$个值，最坏的情况是你对于这个$id_a$的$id_b=n$时，已经取了$n$个值，会自动跳出循坏。

# 真·完结撒花！

---

## 作者：小柯 (赞：2)

这里提供一种~~神奇~~的思路(当然是错的，只是为了拿分)：

因为我们要得到$n$个最小的，所以$a$、$b$序列后面的都很大，基本上是不可能被选上的（概率很小）。所以借助这一点我们可以贪心的选择$a$、$b$序列前面的较小的一部分来求乘积，即$\sqrt{n}*\sqrt{n}=n$
但是这并不一定正确，比如

3

1 9 10

2 3 4

贪心选到了1$*$2、1$*$3、9$*$2、9$*$3

但并不是，所以可以考虑多选几个（$k$）

选$a$序列和$b$序列的前$\sqrt{n}+k$项取前$n$小的（$k$是一个常数）

最后，经~~人工亲测~~得出当$k$取$300$时可以$\colorbox{white}{\color{yellowgreen}{AC}}$

$code$

```cpp
#include<iostream>
#include<queue>
#include<cmath>
using namespace std;
priority_queue<int>q;
int n,m,k;
int a[100005],b[100005],c[100005];
int mian(){
	cin>>n;
	m=min(n,sqrt(n)+300);
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)q.push(a[i]+b[j]);
	while(q.size()>n)q.pop();
	while(!q.empty())c[++k]=q.top(),q.pop();
	for(int i=n;i>=1;i--)cout<<c[i]<<" ";
	return 0;
} 
```
危(zhen)险(ai)操(sheng)作(ming)，请勿模仿！！！

---

## 作者：jackeylove_ (赞：2)

【题目描述】：
有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2个和，求这N^2个和中最小的N个。

【输入描述】：
第一行一个正整数N；

第二行N个整数Ai, 满足Ai<=Ai+1且Ai<=10^9;

第三行N个整数Bi, 满足Bi<=Bi+1且Bi<=10^9.

【输出描述】：
输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。

【样例输入】：
3
2 6 6
1 4 8
【样例输出】：
3 6 7
【时间限制、数据范围及描述】：
时间：1s 空间：128M

对于50%的数据中，满足1<=N<=1000；

对于100%的数据中，满足1<=N<=100,000

第一次A绿题，有点激动，这题我本来准备用老贾说的结构体堆做，后来发现那是不可能的，编译都过不了（我绝不会说我上课没听的2333），然后我在洛谷荡题解的时候意外发现了一个大佬发了一个priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >q;这样的写法可以在堆里压两个变量，所以我就用这个A了

上面是代码部分，再说一下思路吧，就a[0]+b[i],然后如果a[0]+b[j]被选走了,就把它拿出来，把a[1]+b[i]压进去，以此类推

下附标程

```cpp
#include <cstdio>
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;

int i,j,k;
int n;
int a[100005],b[100005];
int jl[100005];

priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > >q;
    
int main()
{
    scanf("%d",&n);
    for(i=0;i<n;i++)
    scanf("%d",&a[i]);
    for(j=0;j<n;j++)
    scanf("%d",&b[j]);
    sort(a,a+n);
    for(i=0;i<n;i++){
    q.push(pair<int, int>(a[0]+b[i],i));
    }
    for(i=0;i<n;i++){
    printf("%d ",q.top().first);
    j=q.top().second;
    q.pop();
    q.push(pair<int, int>(a[++jl[j]]+b[j],j));
    }
    return 0;
}
    
```


---

## 作者：Rachel·Gardner (赞：2)

**题目描述**

有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2个和，求这N^2个和中最小的N个。

输入格式：

第一行一个正整数N；

第二行N个整数A[i],满足A[i]≤A[i+1] 且A[i]<=10^9

第三行N个整数B[i],满足B[i]≤B[i+1] 且B[i]<=10^9

**【数据规模】**

对于50%的数据中，满足1<=N<=1000；

对于100%的数据中，满足1<=N<=100000。

**输出格式：**

输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。

**输入样例**

3

2 6 6

1 4 8

**输出样例**

3 6 7

**思路：**

首先，把A和B两个序列分别从小到大排序，变成两个有序队列。这样，从A和B中各任取一个数相加得到N2个和，可以把这些和看成形成了n个有序表/队列：

A[1]+B[1] <= A[1]+B[2] <= … <= A[1]+B[N]

A[2]+B[1] <= A[2]+B[2] <= … <= A[2]+B[N]

……

A[N]+B[1] <= A[N]+B[2] <= … <= A[N]+B[N]

接下来，就相当于要将这N个有序队列进行合并排序：

首先，将这N个队列中的第一个元素放入一个堆中；

然后；每次取出堆中的最小值。若这个最小值来自于第k个队列，那么，就将第k个队列的下一个元素放入堆中。

代码：

```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int N=100010;

int n;
int a[N],b[N];

priority_queue<int,vector<int>,greater<int> >p1;

int main() {
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
        scanf("%d",&a[i]);
    for(int i=1; i<=n; i++)
        scanf("%d",&b[i]);
    for(int i=1; i<=sqrt(n); i++) {
        for(int j=i; j<=n/i; j++)
            p1.push(a[j]+b[i]);
        for(int j=i+1; j<=n/i; j++)
            p1.push(a[i]+b[j]);
    }
    for(int i=0; i<n; i++) {
        printf("%d ",p1.top());
        p1.pop();
    }
    printf("\n");
    return 0;
}

```




---

## 作者：ghj1222 (赞：2)

有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2个和，求这N^2个和中最小的N个。（这题面多简洁啊）

题解：我们令$f_0(x)=b_x$，由于b数组中元素不下降，所以函数是不下降的，然后我们再令$f_i(x)=a_i+b_x$，所以我们可以得到i个单调的函数，这题就变得像[luogu2085](https://www.luogu.org/problemnew/show/P2085)了，一开始令所有函数的自变量x=1，把n个函数以函数值为关键字扔进小根堆里，每次弹出一个函数，输出函数值，自变量x++再扔回去。

代码：#include

上面的那个include是骗你的
```cpp
#include<cstdio>
#include<iostream>
#include<set>
#include<algorithm>
#include<queue>
using namespace std;
int n;int a[100010],b[100010];
struct s
{
    int i,j;
    bool operator<(const s v)const
    {
        return a[i]+b[j]<a[v.i]+b[v.j];
    }
    bool operator>(const s v)const
    {
        return v<*this;
    }
};
priority_queue<s,vector<s>,greater<s> >q; 
int main()
{
     cin>>n;
     for(int i=1;i<=n;i++)
     	cin>>a[i];
    for(int i=1;i<=n;i++)
     	cin>>b[i];
    for(int i=1;i<=n;i++)
     	q.push((s){i,1});
    for(int i=1;i<=n;i++)
    {
        s x=q.top();
        q.pop();
        cout<<a[x.i]+b[x.j]<< ' ';
        x.j++;
        q.push(x);
    }
    return 0l;
}
```
还要注意到的是STL中如果想要使用greater<结构体>的话要重载一个大于号。greater是个仿函数模板：
```
template <class T>
struct greater:binary_function<T,T,bool>
{
    bool operator() (const T& x, const T& y)const
    {
        return x>y;
    }
};
```

---

## 作者：a1048576 (赞：2)

发现各位神犇的题解都是堆的正解。。

然而本人是那么蒟蒻，以至于不会写堆，也记不住stl的priority\_queue，只好编(xia)出(bai)一些奇怪的做法。

直接暴力显然50分

线性复杂度不现实

只好在复杂度中编(xia)出(bai)一个log，于是想到了二分答案

事实上，这题的优化就是拒绝访问一些不可能成为前n个最小的和的和(有点绕)，我们可以考虑二分出这n个和的最大值，也就是这n^2个和中第n小的和。

对于每个数x，我们可以在线性时间内统计出这n^2个和中小于等于x的和的数量sum：

由于a，b两数组均有序，对于任意i，我们找出使a[i]+b[j]<x的最大j，显然对于1-j中的数t，均有a[i]+b[t]<x，即对答案的贡献为j，对每一个i得到的j求和就是sum，另外注意到a数组单调递增，则j随着i的增大单调递减，从而可将复杂度降至O(n)

这n个和的最大值显然在区间[ a[1]+b[1] , a[n]+b[n] ]中，对这一区间二分，找到最小的x，使sum大于等于n

得到x后，我们把小于x的数取出，排序，在不足n个时补上上x(防止x重复过多，浪费时空)，然后输出即可。

贴上蒟蒻丑陋的代码：

···cpp




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int a[131072],b[131072],f[13001072],sum,top=0,n,ans;
inline int read()
{
    int x=0;
    char p=getchar();
    while(p<'0'||p>'9') p=getchar();
    while(p>='0'&&p<='9') x=x*10+p-'0',p=getchar();
    return x;
}
inline void write(int x)
{
    if(x<0) x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
    return;
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=1;i<=n;i++) b[i]=read();
    int l=a[1]+b[1],r=a[n]+b[n];
    while(l<=r){
        unsigned int mid=(l+r)>>1,j=n,sum=0;
        for(int i=1;i<=n;i++){
            while(a[i]+b[j]>mid&&j>0) j--;
            sum+=j;            
        }
        if(sum>n) r=mid-1,ans=mid;
        if(sum<n) l=mid+1;
        if(sum==n) l=mid,ans=mid,r=mid-1;
    }
    l=ans;
    int j=n;
    for(int i=1;i<=n;i++){
        while(a[i]+b[j]>=l&&j>0) j--;
        for(int k=1;k<=j;k++)
            f[++top]=a[i]+b[k];
    }
    for(int i=top+1;i<=n;i++)
        f[i]=l;
    sort(f+1,f+n+1);
    for(int i=1;i<=n;i++)
        write(f[i]),putchar(' ');
    return 0;
}
···
```

---

## 作者：柠檬味丶 (赞：2)

首先看题意，是所有数都要相加，意思就是说用第一排的数每次都加上第二排的数就完成所有数的相加，接下来进行操作。

1  用第一排第一个数字遍历相加第二排所有数字得到N个数字，用这N个数字建立一个大根堆。

2  接着用第一排剩下的数字遍历相加第二排数字，如果这个数字比大根堆的堆顶都还要大的话，那么就代替它并且重新排序（用stl..）否则就break（因为要求最小的N个数，如果这个数比最大的堆顶还要大，那么就不用继续下去了。）

下面是代码实现

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int a[100001],b[100001];
int c[100001];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    scanf("%d",&b[i]);
    int k=a[1];
    for(int i=1;i<=n;i++)
    {
        c[i]=k+b[i];
    }
    make_heap(c+1,c+1+n);
    for(int i=2;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(a[i]+b[j]<c[1])
        {
            c[1]=a[i]+b[j];
            pop_heap(c+1,c+1+n);
        }
        else
        break;
    }
    make_heap(c+1,c+1+n,greater<int>());
    k=n;
    for(int i=1;i<=n;i++)
    {
        cout<<c[1]<<" ";
        pop_heap(c+1,c+1+k,greater<int>());
        k--;
    }
}
```

---

## 作者：Only_My_Whisper (赞：2)

这道题也可以用c++STL中的集合来完成类似于堆的工作。

```cpp
#include<algorithm>
#include<cmath>
#include<iostream>
#include<set>
using namespace std; 
struct node{
    int n;
    int k;
    bool operator > (const node& a) const{
        return this->n>a.n;
    }
    bool operator < (const node& a) const{
        return this->n<a.n;
```
}//重载
```cpp
};
int main(){
    int n;
    cin>>n;
    long long c,d,k=0;
    int i,j;
    multiset<node>s;
    node f;
    long long a[n+1],b[n+1],p[n+1];
    for(i=1;i<=n;i++){
        cin>>a[i];
        p[i]=1;
    }
    a[0]=0;
    for(i=1;i<=n;i++){
        cin>>b[i];
    }
    b[0]=0;
    sort(a,a+n+1);
    sort(b,b+n+1);
    for(i=1;i<=n;i++){
        f.n=a[i]+b[p[i]];
        f.k=i;
        s.insert(f);
    }
    for(i=1;i<=n;i++){
        f=*s.begin();
        cout<<f.n<<' ';
        p[f.k]++;
        s.erase(s.begin());
        f.n=a[f.k]+b[p[f.k]];
        s.insert(f);
    }
    return 0;
}
```

---

## 作者：易极feng (赞：2)

发现我的思路与楼下的楼下差不多……

那位大神的讲解已经挺明了了。

为弥补他没有代码的缺陷，本蒟蒻无耻地发上代码……

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;

struct node{
    int v,ai,bi;
};

bool operator <(node a,node b){return a.v>b.v;}

int n;
int a[100005],b[100005];
priority_queue<node>q;

int main(){
    int i,j;
    scanf("%d",&n);
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    for(i=1;i<=n;i++)scanf("%d",&b[i]);
    
    for(i=1;i<=n;i++)q.push((node){a[1]+b[i],1,i});
    
    node t;
    for(i=1;i<=n;i++){
        t=q.top();
        printf("%d ",t.v);
        q.pop();
        q.push((node){a[t.ai+1]+b[t.bi],t.ai+1,t.bi});
    }
    
    //for(i=1;i<=n;i++)printf("%d ",q.top()),q.pop();
    
    return 0;
}
```

---

## 作者：paper_plane (赞：1)

## 【题目描述】：

有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2个和，求这N^2个和中最小的N个。

### 【输入描述】：

第一行一个正整数N；

第二行N个整数Ai, 满足Ai<=Ai+1且Ai<=10^9;

第三行N个整数Bi, 满足Bi<=Bi+1且Bi<=10^9.

### 【输出描述】：

输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。

####         解题思路：
           对于第i小的数，确定第i小的数的范围，存入到栈里面，进行查找操作
           输出的则为栈顶元素
####            代码如下：
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<cstring>
#include<iostream>
using namespace std;
const int N=100005;
struct Node{
	int x,y,sum;
};
priority_queue < Node,vector<Node>,greater<Node> > q;
int a[N],b[N];

bool operator >(const Node &aa,const Node &bb){
	return aa.sum>bb.sum;
}
int main(){
	int n,cur=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)q.push((Node){1,i,a[1]+b[i]});
	while(cur<n){
		int SUM=q.top().sum,X=q.top().x,Y=q.top().y;
		printf("%d ",SUM);
		q.pop();
		X++;
		q.push((Node){X,Y,a[X]+b[Y]});
		cur++;
	}
	return 0;
}

```


---

## 作者：Starlight237 (赞：1)

P.S.这个方法的灵感来自P1392，看到没人提到，赶紧水一发。

首先，最小的一个和显然是$a[1]+b[1]$。

然后，我们尝试找第二个和。不难想到，因为a数组中大于等于$a[1]$的最小数为$a[2]$，b数组也类似。因此，第二个和显然为$\min\{a[1]+b[2],a[2]+b[1]\}$，假设第二个和为$a[1]+b[2]$，则第三个和为$\min\{a[1]+b[3],a[2]+b[2],a[2]+b[1]\}$。

我们将这个情况推广到一般，则：**若$a[i]+b[j]$是第k个和，则$a[i]+b[j+1],a[i+1]+b[j]$是第k+1个和的备选答案，在求出$a[i]+b[j]$时被淘汰的备选答案也是第k+1个和的备选答案，没有其他的备选答案了**。

知道了这个结论，一切就好办了。

我们先令$a[1]+b[1]$进入二叉堆，然后按照规则，不断地添加备选答案，丢入二叉堆求出第k小。

因此我们需要在结构体中添加一个标记，标识是否由$a[i]+b[j+1]$转移过来。这一点很重要，请仔细体会代码。

最后我加入了一些简单的常数优化，顺利卡到暂时的2019rk1。

最后附上开O2 64ms的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define ri register int
#define IOSIZE 10000000
static char in[IOSIZE],*p=in,out[IOSIZE],*q=out,ch[20],*t=ch;
inline int read(){
    reg int x=0;
    while(*p<48)++p;
    while(*p>47)x=(x<<1)+(x<<3)+(*p++^48);
    return x;
}
inline void write(int x){
    !x&&(*q++=48);
    while(x)*t++=x%10+48,x/=10;
    while(t!=ch)*q++=*--t;
}
const int n=2;
static int m,a[100001],b[100001],c[100001];
struct Node{
    int x,y,sum,pre;
};
struct cmp{
    inline bool operator()(Node a,Node b){return a.sum>b.sum;}
};
int main(){
    fread(in,1,IOSIZE,stdin);
    priority_queue<Node,vector<Node>,cmp>Q;
    m=read();
    for(reg int *i=c+1,*j=c+m+1;i!=j;++i)*i=read();
    for(reg int i=1;i<n;++i){
        for(reg int *j=a+1,*e=a+m+1,*k=b+1,*l=c+1;j!=e;++j,++k,++l)
            *j=*l,*k=read();
        while(!Q.empty())Q.pop();
        Q.push(Node{1,1,a[1]+b[1],0});
        for(reg int j=1;j<=m;++j){
            Node now=Q.top();Q.pop();
            int x=now.x,y=now.y,sum=now.sum,pre=now.pre;
            Q.push(Node{x,y+1,a[x]+b[y+1],1});
            pre||(Q.push(Node{x+1,y,a[x+1]+b[y],0}),0);
            c[j]=sum;
        }
    }
    for(reg int *i=c+1,*j=c+m+1;i!=j;++i)write(*i),*q++=' ';
    fwrite(out,1,q-out,stdout);
    return 0;
}
```
码字不容易，觉得不错请点个赞吧！

---

## 作者：Akihito (赞：1)

### ~~看到没什么人用make_heap()，所以水一个用堆函数+简单优化AC的题解~~
# STL+堆函数+优化=AC


------------

## 关于algorithm里面的make_heap函数：
#### 建立堆

make_heap(_First, _Last, _Comp)

默认是建立最大堆的。对int类型，可以在第三个参数传入greater<int>()得到最小堆。

 

#### 在堆中添加数据

push_heap (_First, _Last)

要先在容器中加入数据，再调用push_heap()

 

#### 在堆中删除数据

pop_heap(_First, _Last)

要先调用pop_heap()再在容器中删除数据

#### 代码实现：
```cpp
vector<int> heap;

make_heap(heap.begin(), heap.end());
//建堆

heap.push_back(x);
push_heap(heap.begin(), heap.end());
//压入

pop_heap(heap.begin(), heap.end());
heap.pop_back();
//弹出
```
#### ~~根据堆的性质以及如何来维护这个堆就不难明白为什么先push_back后用push_heap还有先pop_heap再pop_back~~
## 分析题意：
#### 给你两个长度为n的序列,合并后变成一个n*n的序列，要你从小到大输出前n项，很显然这是用堆来排序的~~近似模板的题~~根据这个想法不难直接打出这样的代码:
```cpp
make_heap(h.begin(), h.end(), greater<int>());
//堆顶为最小值

for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
        h.push_back(a[i] + b[j]);
        push_heap(h.begin(), h.end(), greater<int>());
    }
}

for(int i = 1; i <= n; i++) {
    printf("%d ", h.front());
    pop_heap(h.begin(), h.end(), greater<int>());
    h.pop_back();
}
```
#### ~~然后就会愉快的爆掉，在MLE之前先TLE~~
## 一个简单的优化：
#### 既然只要我输出序列的前n项，那我不如只建立一个大小为n的堆，然后一直维持它的大小为n。为了维护它的大小不变而又能输出序列前n项，则建立一个堆顶为最大值的堆,每次访问到有a[i]+b[j]小于堆顶就把它压入，同时弹出堆顶，这样就有了第二种代码：
```cpp
make_heap(h.begin(), h.end());
//堆顶默认为最大值

for(int i = 1; i <= n; i++) {
    h.push_back(a[1] + b[i]);
    push_heap(h.begin(), h.end());
    //先读入一个大小为n，堆顶为最大值的堆
}

for(int i = 2; i <= n; i++) {
    for(int j = 1; j <= n; j++) {
        if(a[i] + b[j] < h.front()) {
            h.push_back(a[i] + b[j]);
            push_heap(h.begin(), h.end());
                
            pop_heap(h.begin(), h.end());
            h.pop_back();
        }
    }
}
```
#### 不难发现这样的做法也会有n^2logn的
#### 进一步优化：可以发现，如果将a[],b[]排序后组成的序列都会有一下规律：
### 1.a[i+k]+b[1]>a[i]+b[1] (k>0)
### 2.a[i]+b[j+k]>a[i]+b[j] (k>0)
#### 这样以来 只要a[i]+b[1]已经大于堆顶了，那之后的元素都会大于堆顶，就不必在循环下去了。而当a[i]+b[j]已经大于堆顶，则之后的a[i]+b[j+1]~a[i]+b[n]都会大于堆顶，就可以退出这层循环了
```cpp
sort(a + 1, a + 1 + n);
sort(b + 1, b + 1 + n);
make_heap(h.begin(), h.end());

for(int i = 1; i <= n; i++) {
    h.push_back(a[1] + b[i]);
    push_heap(h.begin(), h.end());
}

for(int i = 2; a[i] + b[1] < h.front(); i++) {
    for(int j = 1; a[i] + b[j] < h.front(); j++) {
        h.push_back(a[i] + b[j]);
        push_heap(h.begin(), h.end());
        pop_heap(h.begin(), h.end());
        h.pop_back();
    }
}
```
## ~~废话好多~~直接上代码：
```cpp
//序列合并 by Akihito
//P1631
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;

int n;
int a[100001], b[100001], ans[100001];

vector<int> h;

void init() {
    cin >> n;

    for(int i = 1; i <= n; i++)
        scanf("%d", &a[i]);

    for(int i = 1; i <= n; i++)
        scanf("%d", &b[i]);

    sort(a + 1, a + 1 + n);
    sort(b + 1, b + 1 + n);
    make_heap(h.begin(), h.end());

    for(int i = 1; i <= n; i++) {
        h.push_back(a[1] + b[i]);
        push_heap(h.begin(), h.end());
        //先读入一个大小为n，堆顶为最大值的堆
    }
}

int main() {
    init();

    for(int i = 2; a[i] + b[1] < h.front(); i++) {
        for(int j = 1; a[i] + b[j] < h.front(); j++) {
            //在sort之后，当a[i]+b[1]>h.front时 则a[i]之后的所有元素都会大于堆顶，整个循环终止
            //同理当a[i]+b[j]>h.front时，b[j]之后的元素+a[i]都会大于堆顶，这层循环就可以终止
            h.push_back(a[i] + b[j]);
            push_heap(h.begin(), h.end());
            pop_heap(h.begin(), h.end());
            h.pop_back();
            //加入这个比堆顶要小的元素 弹出堆顶元素 维护堆的大小始终为n
        }
    }

    for(int i = n; i >= 1; i--) {
    	//这里的堆顶是当前最大值 
        ans[i] = h.front();
        pop_heap(h.begin(), h.end());
        h.pop_back();
    }

    for(int i = 1; i <= n; i++) printf("%d ", ans[i]);

    return 0;
}
```

---

## 作者：Orina_zju (赞：1)

比较朴素的二叉堆思路，在输出A[i]+B[j]分别将A[i+1]+B[j]和A[i]+B[j+1]加入优先队列，注意去重。
还有哪位dalao能告诉我那句注释掉的tie(val, ai, bi) == tpl;为啥不能正常工作……
```cpp
#include <cstdio>
#include <algorithm>
#include <tuple>
#include <queue>

using namespace std;

const int maxN = 100000 + 5;

using Tuple = tuple<int, int, int>;

int N;
int A[maxN], B[maxN];
//tuple: (A[i] + B[j], i, j)
priority_queue<Tuple, vector<Tuple>, greater<Tuple>> pque;

void input()
{
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
        scanf("%d", A + i);
    for (int i = 0; i < N; i++)
        scanf("%d", B + i);
}

void solve()
{
    sort(A, A + N);
    sort(B, B + N);
    pque.push(make_tuple(A[0] + B[0], 0, 0));

    int val, ai, bi;
    for (int i = 0; i < N; i++)
    {
        auto tpl = pque.top();
        //tie(val, ai, bi) == tpl;
        val = get<0>(tpl);
        ai = get<1>(tpl);
        bi = get<2>(tpl);
        pque.pop();

        while (!pque.empty() && pque.top() == tpl)
            pque.pop(); //remove repeating elements

        printf("%d ", val);
        pque.push(make_tuple(A[ai + 1] + B[bi], ai + 1, bi));
        pque.push(make_tuple(A[ai] + B[bi + 1], ai, bi + 1));
    }
}

int main()
{
    input();
    solve();
    return 0;
}
```

---

## 作者：water_mi (赞：1)

AC过后，发现自己的思路竟然和楼下某位大佬差不多？（雾）

但是，要说的是，虽然楼下那位大佬思路挺清晰，但写出来的代码貌似有点复杂啊，我担心可能会看不懂，所以这里写一个简化版的

分析：

同样是将$a_1+b_1,a_1+b_2,.....,a_1+b_n$压入堆中，然后取出最小元素，再维护这个堆，再将$a_i_+_1+b_j$压入堆中。

因为a，b均为序列，故满足$a_i+b_j>=a_i_+_1+b_j$，所以我们只需要取出前n个数字。

由于压堆和取堆的时间复杂度均为$log_2n$，而每轮操作均需要2次（第一次取堆，第二次压堆），再加上之前的输入压堆操作，要操作n次，所以总的时间复杂度为$nlog_2n$。

为了存储i，我们用了一个二维堆：建立一个二维小根堆heap[100010][2]，$heap_i_0$用于存储堆中原有的数据，$heap_i_1$用于存储i（这样才能做到i+1）

代码很简单，但要弄懂的是思想。

代码（务必看完分析）：

```cpp
#include<cstdio>
void swap(int &a,int &b){int tmp = a;a = b;b= tmp;}
int n,heap[100010][2],a[100010],b[100010],heap_size;
void put(int value,int i){
    heap[++heap_size][0] = value,heap[heap_size][1] = i;
    int now = heap_size,next;
    while(now > 1){
        next = now >> 1;
        if(heap[now][0] >= heap[next][0]) return;
        swap(heap[now][0],heap[next][0]);
        swap(heap[now][1],heap[next][1]); 
        now = next;
    }
}
int get(){
    int value = heap[1][0],flag = heap[1][1],now = 1,next;
    heap[1][0] = heap[heap_size][0],heap[1][1] = heap[heap_size--][1];
    while(now << 1 <= heap_size){
        next = now << 1;
        if(next < heap_size && heap[next + 1][0] < heap[next][0]) next++;
        if(heap[next][0] >= heap[now][0]) break;
        swap(heap[now][0],heap[next][0]);
        swap(heap[now][1],heap[next][1]); 
        now = next; 
    }
    put(value - a[flag++] + a[flag],flag);
    return value;
}
//正常压堆，取堆操作 
int main(){
    scanf("%d",&n);
    for(int i = 1;i <= n;i++) scanf("%d",&a[i]);//读入序列a 
    for(int i = 1;i <= n;i++){
        scanf("%d",&b[i]);//读入序列b 
        put(a[1] + b[i],1); //将a[1]+b[i]压堆 
    }
    while(n--) printf("%d ",get());//循环n次输出结果 
    return 0;
}
```

---

## 作者：Michael_Li (赞：1)

还是比较推荐大家使用手打堆，不仅可以练代码能力，也可以对堆的原理有更好的理解，如果真正掌握了堆，打的时间不必stl慢，而在noip时可以大大的减小常数，多拿点分。

我做这题的思想是这样的，先将a[1]+b[1],a[1]+b[2]+.....+a[1]+b[n]压入堆中，每次取出堆顶（维护小根堆），将a[i]改成a[i+1]，压回堆中，鉴于刚开始时a,b均为单调向上，所以a[i]+b[j]必定优于a[i+1]+b[j]，所以这种想法可以实现，而每次只动a而不动b则可保证没有重复。

一下注释略需堆的一些基础知识，若对堆一窍不通则可先做一些知识铺垫


```cpp
#include<cstdio>
#include<algorithm>
#define N (100000+10)
using namespace std;
int a[N],b[N],size;
struct node{
    int ia,ib,data;
}q[N*2];//对于堆中的每一个点，我存三个参数，其实只用两个，ia表示a中的第几个，ib同理，data表示这两个数的和
void up(int x){//up操作
    while (q[x].data<q[x/2].data){//当我比父亲节点小的时候就将我上移
        node t;
        t=q[x];//上移即为交换
        q[x]=q[x/2];
        q[x/2]=t;
        x=x/2;//继承父亲节点的编号，继续上移，直到移到改移的位置
    }
}
void down(int x){//下移操作
    while (x*2<=size){//在两个儿子中找小的继承，剩下的原理同up
        int c=x*2;
        if (x*2+1<=size){
            if (q[x*2+1].data<q[c].data) c=x*2+1;
        }
        if (q[x].data>q[c].data){
            node t;
            t=q[x];
            q[x]=q[c];
            q[c]=t;
            x=c;
        }
        else return;
    } 
}
node pop(){//弹出堆顶
    node r;;//这种方法做堆的删除比较常见，即把堆顶和堆最后的size点互换，讲size--，自然删除，然后继续维护
    r.ia=q[1].ia;
    r.ib=q[1].ib;
    r.data=q[1].data//这里为弹出，接下来为删除
    node t;
    t=q[1];
    q[1]=q[size];
    q[size]=t;
    size--;
    down(1);//这里实现的是删除堆顶的操作，若要删除堆内任意元素则先上移后下移，方法和删除堆顶相同
    return r;
}
void ins (int ia,int ib,int data){//插入操作，插入后维护小根堆
    q[++size].ia=ia; q[size].ib=ib; q[size].data=data;
    up(size);
}
int main(){
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    for (int i=1;i<=n;i++) scanf("%d",&b[i]);
    for (int j=1;j<=n;j++) ins(1,j,a[1]+b[j]);
    int tot=n;
    while (tot>0){
        tot--;
        node c=pop(),e;
        e.ia=c.ia+1; e.ib=c.ib; e.data=c.data-a[c.ia]+a[e.ia];//算法在开头部分已做解释
        printf("%d ",c.data);
        ins(e.ia,e.ib,e.data);        
    }
    //printf("\n%d\n",size);
    //for (int i=1;i<=size;i++) printf("%d %d %d\n",q[i].ia,q[i].ib,q[i].data);
    return 0;
}
```

---

## 作者：oscar123 (赞：1)

其实我一开始写的时候以为这只是一个50分程序之类的，结果做了一个小小的优化，就过了。

由于题意说从a中取一个，从b中取一个，运用一个mark数组记录当前每个a匹配到哪个b了，当第i次寻找时直接从mark处开始

不过这也没有根本性解决问题，依旧是n^2时间复杂度，于是乎我加了一个小小的优化（估计出数据的人没想到）

每次寻找最小值的时候，当a[j]+b[mark[n]]>当前最小值时即终止查询（易知mark[n]是mark数组中最小的，因为数列是有序的，所以当此终止条件成立时，之后不可能找到新的最小值）

其实应该最坏时间复杂度还是o(n^2)，不过出题者数据之间间隔较大，所以这就过了23333

```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;
int mark[100010];
int a[100010];
int b[100010];
int main()
{
    int n;
    cin>>n;
    for (int i=1;i<=n;i++)
        cin>>a[i];
    for (int i=1;i<=n;i++)
        cin>>b[i];
    for (int i=1;i<=n;i++) mark[i]=1;
    for (int i=1;i<=n;i++)
    {
        int temp=1;
        int mini=1000000000;
        for (int j=1;j<=n;j++)
        {
            if (a[j]+b[mark[j]]<mini)
            {
                temp=j;
                mini=a[j]+b[mark[j]];
            }
            if (a[j]+b[mark[n]]>mini)
            {                
                mark[temp]++;
                break; 
            }
        }
        cout<<mini<<" ";
    }
}
```

---

## 作者：Ghost_lzy (赞：1)

在刘汝佳的蓝书上的优先队列有详细的证明——先把S=a[1-n]+b[1]放到堆中，记录b的下标p，然后弹出一个，就装一个S1=S-b[p]+b[p+1],一定是可以得到正解的。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct sd{
    int s,bb;
};
int a[100005],b[100005],n;
bool operator < (const sd &v1,const sd &v2)
{
    return v1.s>v2.s;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    scanf("%d",&b[i]);
    sort(a+1,a+1+n);
    sort(b+1,b+1+n);
    priority_queue<sd>q;
    for(int i=1;i<=n;i++)
    {
        sd t;
        t.s=a[i]+b[1];
        t.bb=1;
        q.push(t); 
    }
    for(int i=1;i<=n;i++)
    {
        sd t=q.top();q.pop();
        int B=t.bb,S=t.s;
        printf("%d ",S);
        if(B+1<=n) 
        {
         t.s=S-b[B]+b[B+1];
         t.bb=B+1;
         q.push(t);
        }
    }
}
```
/\*
5
1 3 2 4 5

6 3 4 1 7

\*/

---

## 作者：pupuvovovovovo (赞：1)

十万级数据，要么是O（n）,要么是O（n log n）。

很明显前者不现实，所以考虑后者。

此题可以拿堆做。

由于题中说a与b都是有序的，所以不用排序。

维护小根堆即可。

```cpp
type rec=record
x,y:longint;
end;{每个堆节点有两个性质，a与b得和与b值的标号}
var a,b:array [1..100000] of longint;
dui:array [1..100000] of rec;
n,i:longint;
procedure swap(var x,y:longint);
begin
  x:=x+y;
  y:=x-y;
  x:=x-y;
end;
function min(x,y:longint):longint;
begin
  if y>n then exit(x);
  if dui[x].y<dui[y].y then exit(x);
  exit(y);
end;
procedure down(x:longint);//把调整过程打进子程序会清楚
var k,i:longint;
begin
  i:=x;
  while 2*i<=n do
  begin
    k:=min(2*i,2*i+1);
    if dui[k].y<dui[i].y then
    begin
      swap(dui[k].x,dui[i].x);
      swap(dui[k].y,dui[i].y);
      i:=k;
    end
    else exit;
  end;
end;
begin
  read(n);
  for i:=1 to n do
    read(a[i]);
  for i:=1 to n do
    read(b[i]);
  for i:=1 to n do
  begin
    dui[i].x:=1;
    dui[i].y:=a[i]+b[1];
  end;
  for i:=n div 2 downto 1 do{这其实有一个很小的常数优化，而且能少打up}
    down(i);
  for i:=1 to n do
  begin
    write(dui[1].y,' ');
    inc(dui[1].x);
    dui[1].y:=dui[1].y-b[dui[1].x-1]+b[dui[1].x];
    down(1);
  end;{主体}
end.
```

---

## 作者：Patchuli_Go (赞：1)

第一个解毋庸置疑是两个序列首元素的和。

然后呢？我们发现如果a[i]与b[j]被选择了，那么a[i+1]b[j]和a[i]b[j+1]就成了新的有可能被选择的解。因此每进行一次选择，就将那两个新的可能性push进堆里，每次选择取堆顶即可。

然而这样可能会把同一对数字重复push进堆，因此我们再建一个set（也可以用哈希表）维护一堆数字是否进过堆，每次往堆里push数对时同时也把它们insert进集合中。

这样时间复杂度O（nlogn）就可以过了。

```cpp
#include<queue>
#include<cstdio>
#include<set>
#define gm 100001
using namespace std;
int a[gm],b[gm],n;
struct cp
{
    int x,y;
    int val(){return a[x]+b[y];}
    bool operator < (const cp &z) const
    {return a[z.x]+b[z.y]<a[x]+b[y];}
}now;
struct dt
{
    int x,y;
    void set(const cp &z)
    {x=z.x;y=z.y;}
    bool operator < (const dt &z) const
    {return x<z.x||(x==z.x&&y<z.y);}
}k;
priority_queue<cp> h;
set<dt> s;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    scanf("%d",&a[i]);
    for(int i=0;i<n;i++)
    scanf("%d",&b[i]);
    h.push((cp){0,0});
    for(int i=1;i<=n;i++)
    {
        now=h.top();h.pop();
        printf("%d ",now.val());
        now.x++;
        k.set(now);
        if(!s.count(k))
        h.push(now),s.insert(k);
        now.x--;now.y++;
        k.set(now);
        if(!s.count(k))
        h.push(now),s.insert(k);
    }
    return 0;
}
```

---

## 作者：iYuer (赞：1)

100000的数据很大，你不可能先把100000^2个和给算出来啊。

所以需要动态求和 和 更新最小堆。


下面用的是related[]数组 来记录b[i]是与第几个a[] 相加的。

初始化：d[i]=a[1]+b[i],related[i]=1;


每输出一个最小值后 就更新 该最小值的a[]关系：


d[1]=d[1]-a[related[1]]+a[++related[1]];

然后维护最小堆：ShitDown(1,n);

```cpp

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#define LEFT(x) (x<<1)
#define RIGHT(x) ((x<<1)+1)
using namespace std;
const int maxn=100000+10;
int n;
int a[maxn],b[maxn],d[maxn],related[maxn];
void ShitDown(int low,int hight)
{
    int i=low;
    int j=LEFT(i);
    int base=d[i],tr=related[i];
    while(j<=hight)
    {
        if(j<hight&&d[j+1]<d[j])j++;
        if(base<d[j]) break;
        else
        {
            d[i]=d[j];
            related[i]=related[j];
            i=j;
            j=LEFT(i);
        }
    }
    d[i]=base;
    related[i]=tr;
}
int main()
{
    freopen("s.in","r",stdin);
    freopen("s.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)scanf("%d",&b[i]);    
    sort(a+1,a+1+n);sort(b+1,b+1+n);
    for(int i=1;i<=n;i++){
        d[i]=a[1]+b[i],related[i]=1;
    }
    for(int i=n/2;i>=1;i--)    ShitDown(i,n);
    for(int i=1;i<=n;i++)
    {
        printf("%d ",d[1]);
        d[1]=d[1]-a[related[1]]+a[++related[1]];
        ShitDown(1,n);
    }
    return 0;
}

```

---

## 作者：lych (赞：1)

这道题目如果没有数据的话，基本上用暴力就可以解决了，但是如果数据放大到100000，一看就知道


使用O(NlogN)的算法解决。

如果使用堆的话，思路应该来说是非常清楚的。首先对两个数组进行排序，自然使用最快的快排。接


下来是重点，[u]首先需要明白：如果选择了a[i]，那么首先肯定是a[i]+b[1]，其次是a[i]+b[2]，直到


a[i]+b[n]为止。所以，我们用一个数组sum[i]表示用了a[i]之后现在的和的大小，q[i]表示现在使用


的a[i]，与其配对的是b[q[i]]。[/u]**注意：这个i不一定是原来顺序下的第i个，而是指在小根堆中的


编号为i的。**

然后建立一个最小堆，首先输出sum[1]，也就是现在最少的，然后是q[1]加上一，更新sum[1]的值，


然后维护队即可。

[color=red]注意：维护时不要忘了q数组。[/color]


```delphi
type
  arr=array[0..100001] of longint;
var
  a,b,q,sum:arr;
  i,n,m,k,t:longint;
procedure qsort(r,l:longint; var x:arr);
var
  i,j,mid,t:longint;
begin
  i:=r; j:=l;
  mid:=x[random(j-i+1)+i];
  repeat
    while x[i]<mid do i:=i+1;
    while x[j]>mid do j:=j-1;
    if i<=j then
      begin
        t:=x[i]; x[i]:=x[j]; x[j]:=t;
        i:=i+1; j:=j-1;
      end;
  until i>j;
  if i<l then qsort(i,l,x);
  if r<j then qsort(r,j,x);
end;//排序
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  readln;
  for i:=1 to n do read(b[i]);
  readln;
  qsort(1,n,a);
  qsort(1,n,b);
  for i:=1 to n do
    begin
      q[i]:=1;
      sum[i]:=a[i]+b[1];//初始化sum和q的值
    end;
  for i:=1 to n do
    begin
      k:=i;
      while (k>1) and (sum[k]<sum[k shr 1]) do
        begin
          t:=sum[k];
          sum[k]:=sum[k shr 1];
          sum[k shr 1]:=sum[k];
          t:=q[k];
          q[k]:=q[k shr 1];
          q[k shr 1]:=q[k];
          k:=k shr 1;
        end;
    end;//建立最小堆
  m:=n;
  for i:=1 to n do
    begin
      write(sum[1],' ');//输出最小值
      q[1]:=q[1]+1;//q数组加一
      sum[1]:=sum[1]-b[q[1]-1]+b[q[1]];//更新sum[1]值
      k:=1;
      while (k shl 1<=m) and ((sum[k]>sum[k shl 1]) or (sum[k]>sum[k shl 1+1])) do
        begin
          if k shl 1=m then k:=k shl 1 else
            if sum[k shl 1]<sum[k shl 1+1] then
              k:=k shl 1 else k:=k shl 1+1;
          t:=sum[k];
          sum[k]:=sum[k shr 1];
          sum[k shr 1]:=t;
          t:=q[k];
          q[k]:=q[k shr 1];
          q[k shr 1]:=t;
        end;//维护堆
    end;
end.
```

---


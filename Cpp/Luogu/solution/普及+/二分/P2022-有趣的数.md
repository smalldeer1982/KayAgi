# 有趣的数

## 题目描述

让我们来考虑 $1$ 到 $N$ 的正整数集合。让我们把集合中的元素按照字典序排列，例如当 $N=11$ 时，其顺序应该为：$1,10,11,2,3,4,5,6,7,8,9$。

定义 $K$ 在 $N$ 个数中的位置为 $Q(N,K)$，例如 $Q(11,2)=4$。现在给出整数 $K$ 和 $M$，要求找到最小的 $N$，使得 $Q(N,K)=M$。

## 说明/提示

【数据约定】


$40\%$ 的数据，$1 \le K,M \le 10^5$；

$100\%$ 的数据，$1 \le K,M \le 10^9$。


## 样例 #1

### 输入

```
2 4
```

### 输出

```
11
```

## 样例 #2

### 输入

```
100000001 1000000000```

### 输出

```
100000000888888879```

# 题解

## 作者：Akashicw (赞：64)

首先感谢一下王乃广老师的耐心讲解！


其次感谢一下@友邻牧鸡同学的指正。


考虑特殊的数字:1,10,100...


可以发现，无论n取何值(n足够大)，我们均可得出第一条结论:**10^n(n>=0)总是会排在i+1号位置上**。


定义一个数组mi[i]表示排在第i位上的最大数值，显然一定为10^n(n>=0)。


在草稿纸上枚举一下，我们可以得出第二条结论:**对于给出的k，随着n的增加，q(n,k)的值总是不下降的**。


注：q(n,k)的意义同题目给出，为k在n个数中的位置。


那么我们可以计算出k的最小位置，定义为base。


怎么求base呢？枚举一下排在k前边的数字（包括自己）！


例如：k=234。


- 一位数：1,2(2)-> 2-1+1=2;


- 两位数：10~23(14) ->23-10+1=14;


- 三位数：100~234(135) ->234-100+1=135;


###有没有发现什么？


**我们可以一位一位计算，只需要将当前的前n位数字，减去10^(n-1)后加1(别忽略10^(n-1))。最后再累加。**


接下来拿base与m作比较，


- 如果base==m，那么我们的结果就恰好为k。


- 如果base>m，那么肯定不存在满足条件的n，直接输出0。


- 如果m>base，要在k=234之前增加m-base个元素。


注意，由于按照字典序排序，我们增加的元素，只能从这n位数的第n+1位(10^(n+1))开始枚举，还是拿234做例子。


增加元素的过程，和之前求**k的最小位置**是类似的。


- 四位数：1000~2339(1340)个元素。


如果仍然达不到m，我们再让m减去刚才增加的元素个数，继续枚举五位数，这样是乘10地枚举的，速度是对数级别的，可以跑得很快。


那么，如何统计答案呢？


因为从234以后的三位数即使加进去也不影响234之前的排序，所以我们可以这样做：


答案记录当前枚举的位数（记为x）的前一位所有的数字，也就是10^x-1个数字（在这里我们一开始先不删除，最后一并处理）。


如果当前的位数还不符合，就继续枚举下一位。ans乘10。


直到枚举的数字大于了m，我们再让结果加上m减去1(正如之前所说，乘上10的时候，包括了当前一位的10^x，需要删除)，就是ans啦~


代码如下(copy了一下老师的)：


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int k,m;
int base,len;
long long mi[20];
long long ans;
//计算k的最小位置 
int calc(int k){ 
    char s[12];
    sprintf(s,"%d",k);
    int ans=0,w=0;
    len=strlen(s);
    for(int i=0;i<len;i++)
    {
        w=w*10+s[i]-'0';
        ans+=w-mi[i]+1;
    }
    return ans; 
}
int main()
{
    mi[0]=1;
    for(int i=1;i<19;i++) mi[i]=mi[i-1]*10;
    scanf("%d%d",&k,&m);
    //1,10,100的位置是固定的 
    for(int i=0;i<10;i++){
        if(k==mi[i]&&m!=i+1){
            printf("0\n"); return 0;
        }
    }
    base=calc(k);
    if(m<base){
        printf("0\n"); return 0;
    }
    if(m==base){
        printf("%d\n",k); return 0;
    }
    ans=mi[len];
    m-=base;
    for(int i=1;;i++)
    {
        long long tmp=k*mi[i]-mi[len+i-1];
        if(m>tmp)
        {
            m-=tmp; 
            ans*=10;
        }
        else break;
    }
    ans+=m-1;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Mr_Li (赞：48)

       由于答案可能非常大，所以这道题显然不能用枚举，即便用二分，时间复杂度{O[N(logN)^2]}也特别大。我们可以设所有字典序比K小的数中的第M-1个为X，N就等于K与X的最大值，怎么求X呢？[delete]当然是枚举。[/delete]我们把所有字典序比K小的数分成无穷大个集合。集合Ai里的任意两个数j,k，都满足i=floor(log10(j))=floor(log10(k))（floor(a)表示取a的整数部分，log10(a)表示以10为底，以a为真的对数值），其中最大值为ai。我们可以发现，设K的左数第i位是pi,qi=∑pj\*(i-j+1)(1<=j<=i),当j<=log10(K)，|Aj|=qj-1，aj=qj-1；当j>log10(K)，|Aj|=|A(j-1)|\*10（请读者自己证明）。由此我们可求出X所在集合Ai，且X=ai+[M-∑|Aj|(1<=j<=i)]-1。求X所在集合的时间复杂度和求出X所在集合后求X的值的时间复杂度均为O[log10(N)]，总的时间复杂度为O[log10(N)]。
```cpp

#include<iostream> 
using namespace std;
long long k,m,i,number=0,n;
int main ()
{
    cin>>k>>m;
    for (i=1;i<=k;i*=10)
    number+=k/i-i+1;
    number--;
    if (number>=m||k-(i/10)==0&&number<m-1)
    cout<<0;
    if (number>=m||k-(i/10)==0&&number<m-1)
    return 0;
    for (i=k-(i/10),n=k;number<m-1;i*=10,number+=i,n*=10);
    cout<<max(n-number+m-2,k);
    return 0;
}

```

---

## 作者：大奕哥 (赞：16)


这道题目是让我们求一个数的字典序排名，我们通过字典序定义可以发现，

大于原数且字典序比他小的一定是他的原数减一在后面添9（10^n除外）

eg:
比233大且字典序比他小的是 1000~2329 10000~23299 .....

个数就是1330 13300 133000....每次做差比较即可，

细节见代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long pow10(int x)
{
    long long ans=1;
    for(int i=1;i<=x;++i)ans*=10;return ans;
}int s[1000],a[1000];
int main()
{
   int k;
   long long m;
   scanf("%d%lld",&k,&m);
   int kk=k,cnt=0,tmp=0;
   while(kk)
   {
          int y=kk%10;
         s[++cnt]=y;
         kk/=10;
   }
   if(k==1&&m!=1)cout<<0<<endl;
   else if(k==10&&m!=2)cout<<0<<endl;
   else if(k==100&&m!=3)cout<<0<<endl;
   else if(k==1000&&m!=4)cout<<0<<endl;
   else if(k==10000&&m!=5)cout<<0<<endl;
   else if(k==100000&&m!=6)cout<<0<<endl;
   else if(k==1000000&&m!=7)cout<<0<<endl;
   else if(k==10000000&&m!=8)cout<<0<<endl;
   else if(k==100000000&&m!=9)cout<<0<<endl;
   else if(k==1000000000&&m!=10)cout<<0<<endl;
   else
   {
   for(int i=1;i<=cnt;++i)
   a[i]=s[cnt-i+1];
  kk=1;long long pre=0;//记录原数
   for(int i=1;i<=cnt;++i)
   {
      pre=1ll*pre*10+a[i];
      tmp+=pre-pow10(i-1)+1;
   }//统计小于等于他的且字典序比他小的个数
   if(tmp>m)cout<<0<<endl;
   else if(tmp==m)cout<<k<<endl;
   else{    
          kk=1;m-=tmp;
          long long num=1ll*pre*10-1ll*pow10(cnt+kk-1);
             while(num<m)//注意不能等于，否则答案会乘十减一
            {
                 m-=num;num*=10;kk++;
            }
          printf("%lld\n",(pow10(kk+cnt-1)+m-1));
       } 
   }
    return 0;
}
```

---

## 作者：mochenbo (赞：11)

看不懂其它题解的过来我一定给你们十分简短的容易理解地讲懂。

这道题花了我很多时间,其实是很有意义的，这里我给大家讲下我的思路；

因为这是按字典序排列的，而位数相同的自然数我们可以看到它们按字典序排是符合大小关系的比如10，11，12，13，14......;其它依此类推.所以我们发现不能扩展时才有可能无解。再进一步发现数字abc如果不扩展前面一共有abc-100+1+ab-10+1+a-1+1的位数，如1,2,3,4,5时5排第5位，扩展是指前面有比它大的，如1,2,3,41,5;这个自己可以推，再进一步发现可扩展的扩展完了总共的数字将达到9,99,999,9999......;所以可以找到第一个大于规定位数的地方；再通过相减得到位数差然后补上去，就是答案了，具体细节将写在代码中；(如果还有疑问可以再问我);

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
 long long k,m;
 long sum,ke,gx,tt=1;
 long long fd(long long pos, long long fr)
{
  long long po=0;
  while(fr!=0)
  {
      po+=pos-fr+1;
      pos/=10;
      fr/=10;
  }
   return po;
   //类似于：1234的未扩展前位数=(1234-1000+1)+(123-100+1)+(12-10+1)+(1-1+1)； 
}
int main()
{
    scanf("%lld%lld",&k,&m);
    if(k==1)
    {
    if(m==1)
    cout<<1;
    else
    cout<<0;
```
}//当k等于1时可能会无解所以特判；
```cpp
    else
    {
    long long gy=k;
    while(gy!=0)
    {
    tt*=10;
    gy=gy/10;
    }
    tt/=10;//tt:得到数字长度； 
    gx=k-tt;
    sum=fd(k,tt);// 找到未扩展时当前数字排第几位； 
    if(sum>m)
    cout<<0;// 如果已经大于未扩展位置，就跳出； 
    else
    if(sum==m)
    cout<<k;//如果 已经等于直接跳出 ； 
    else
  {
      if(gx==0)//如果可扩展的为0，跳出； 
      cout<<0;
      else
      {
    while(sum<m)// 找到第一个大于题目要求位数的位置; 
    {
    tt*=10;
    sum=sum+gx*10;
    gx=gx*10;
    }
    gx=gx/10;
    sum=sum-gx*10;//退回一步 
    ke=m-sum;// 算出差值； 
    cout<<tt+ke-1;//补上位数； 
    }
  }
    }
    return 0;
}
```

---

## 作者：夏色祭 (赞：6)

由于我太菜了，就写了个无脑二分，似乎没有大佬发过？我就趁机来水一发。

不难发现，n越大，字典序比k小的数就越多，也就满足了单调性，那么我们可以直接二分答案。

每次check的话就是判断1~mid之间有几个数字典序比k小。

然后感觉好像可以直接无脑数位dp下。

我就是分两种情况讨论了下：

1.位数与mid的位数相同的数字典序比k小的数的数量。
```
    int i=a[0],j=b[0];
    while (a[i]==b[j]&&i&&j){
        ans+=p[j]*max(a[i]-(i==a[0]),0);
        i--,j--;
    }
    if (i&&j)
        if (a[i]>b[j]) ans+=p[j]*(b[j]-(j==b[0]))+x%p[j]+1;
        else for (register int k=i;k;k--) ans+=p[j]*max(a[k]-(k==a[0]),0),j--;
```
(a数组里存的是k，a[0]代表k的位数，b数组里存的是mid,b[0]代表mid的位数，$p[i]=10^{i-1}$）

2.位数小于mid的位数的数字典序比k小的数的数量。
```
   for (register int k=b[0]-1;k;k--) {
        j=k;
        for (register int k=a[0];k;k--) {
            ans+=p[j]*max(a[i]-(i==a[0]),0);
            if (--j==0) break;
        }
        if (k<a[0]) ans++;
    }
```

核心代码段就是上面这两段。

代码太丑，所以我就不发全部了。[![TIM图片20180418224805.gif](https://i.loli.net/2018/04/18/5ad75ad842259.gif)](https://i.loli.net/2018/04/18/5ad75ad842259.gif)

---

## 作者：LT123456 (赞：4)

看了一圈，好像没人和我的方法一样，虽然我的代码可能不是最短的，但我的方法也算非常简单并且好理解的啦（并且非常详细），haha~。~~新人手打不易，求过QAQ~~

先贴出代码再讲解
```cpp
#include<bits/stdc++.h>
#include<math.h>
using namespace std;
int main()
{
	long long k, m, i = 0, j, l = 0, a[30], b = 0, d, c, e, n = 0, aa = 0, bb;
	cin >> k; //输入k
	cin >> m; //输入m
	c = k;  //将k赋给c，不让k变化
	while (c)  //将k存到数组a[]里
	{
		a[i] = c % 10;
		c = c / 10;
		i++;
	}
	b = 0;
	e = i;
	d = e;
	for (d; n <= i + 1; d--)
	{
		for (j = 1; j <= d; j++)
		{
			l = pow(10, j - 1) + l;
		}
		if (n == 0)
			b = (a[i - 1 - n] - 1)*l + b;
		else
			b = a[i - 1 - n] * l + b;
		n++;
		l = 0;
	}
	b = b + i;//最小值为k时，k的排名
	if (b == m) {
		cout << k;
	}
	else if (m < b) { cout << 0; }
	else
		for (e = i;;e++)
		{
			bb = k * pow(10, e - i + 1) - pow(10, e) + aa;
			if (m - b <= bb)
			{
				cout << setprecision(30) << m - b - 1 - aa + pow(10, e);
				break;
			}
			aa = k * pow(10, e - i + 1) - pow(10, e) + aa;
		}
	return 0;
}
```

# 方法

先考虑当最大的整数为k时，k的位置。
代码如下：
```cpp
for (d; n <= i + 1; d--)
	{
		for (j = 1; j <= d; j++)
		{
			l = pow(10, j - 1) + l;
		}
		if (n == 0)
			b = (a[i - 1 - n] - 1)*l + b;
		else
			b = a[i - 1 - n] * l + b;
		n++;
		l = 0;
	}
	b = b + i;//最小值为k时，k的排名
```

其中数组a[ ]里存着k

这段代码的讲解如下，为方便理解，令k=453，则有四种数字在k前边： 
- （1）首位以1、2、3开头的数字，个数为（1+10+100）×（4-1）
- （2）首位为4的数，次位小于5的数，个数为(1+10)×（5-0)+1 
- （3）首位为4，次位为5，第3位小于3的数，个数为1×（3-0）  
- （4）首位或第二位与K相同，但总位数小于k。两个，分别为4、45
 
通过这种方法就求出来了最大值为k时的排名b。 
- 如果m=b，那显然最小值n=k; 
- 如果m<b，则不存在n，因为该组数的最小值肯定是>=k的。
- 如果m>b,则一定存在n。

#### 下面讨论m>b的情况。 

分析易知，若m>b,则n的位数肯定大于k的位数。K=453有3位，分析知4位数里排在453前边的数字有：
- 1000-1999,2000-2999,3000-3000,4000-4529

数字的数量 用代码表示为
```cpp
453*pow(10,4-3+1)-pow(10,4) 
//pow(10,4-3+1)中的4代表4位数
3代表K的位数，pow(10,4)里的4代表4位数
```

若
- （m-3位数字中k的排名）<4位数里排在453前边的数字个数时
-  则所求数字n必然为四位数字，且n在1000-1999,2000-2999,3000-3000,4000-4529范围内 
- n=（m-3位数字中k的排名-1）+1000。 
若
- （m-3位数字中k的排名）>4位数里排在453前边的数字个数，则应继续判断（m-4位数字中k的排名）与5位数里排在453前边的数字个数大小，直到 （m-i位数字中453的排名）<与(i+1)位数里排在453前的数字量，此时即可得到所求的最小数字
- n=(m-i位数字中453的排名-1）+pow(10, i);

以上就是这道题的题解，比较遗憾的是，这道题我并没有AC，只有86分，当m较大时，可能出现WA，由于我是新手，所以也没有学优化之类的。。。所以还请各位告诉我该怎么AC啊，哈哈哈哈

~~手打不易，求过QAQ~~

---

## 作者：Thunder_S (赞：3)

# Solution

首先从特殊往一般想。

考虑当 $K=10^i$ 的时候的情况。由于其字典序最小，因此位置是固定的，即 $i+1$ ，那么只要 $M$ 不是这个位置都是无解。

既然是位置，可以考虑先求出 $K$ 的最小位置。

思考在 $K$ 前面的会有多少。假设 $K=114514$ 。

1. $114514-100000+1=14515$ 。这是在位数一样的情况下。
2. $11451-10000+1=1452$ 。这是在少一位的情况下。
3. $1145-1000+1=146$ 。同上，以此类推。
4. $114-100+1=15$ 。同上，以此类推。
5. $11-10+1=2$ 。同上，以此类推。
6. $1-1+1=1$ 。同上，以此类推。

因此可以发现，在比 $K$ 少 $i$ 位的情况下，将会有（设 $K$ 的长度是 $len$） $\lfloor\dfrac{K}{10^i}\rfloor-10^{len-i}+1$ 个数的字典序比 $K$ 小。

统计出 $K$ 的最小位置 $num$ 后，将 $num$ 和 $M$ 进行比较。

若 $num=M$，那么只要出现了 $K$ 就可以使得 $K$ 的位置是 $M$，因此 $N$ 的最小值就是 $K$ 。

若 $num>M$ ，就无解了，因为 $num$ 是 $K$ 的最小位置。不存在其他的位置比 $num$ 还要小。

若 $num<M$ ，就说明还有比 $K$ 前面的数，但是位数小于等于 $K$ 的已经穷举完了，因此肯定有位数大于 $K$ 的在 $K$ 前面。逐步增加位数，同时更新最小位数。当某个时刻 $num\ge M$ ，先将 $num$ 减回去，算出 $M$ 与 $num$ 之间的差。再加上 $10^{x}$ ，这个 $x$ 是当前位数。最后减去 1（因为从 0 开始算），就是 $N$ 的大小。

# Code

```cpp
#include<cmath>
#include<cstdio>
using namespace std;
int len;
long long k,m,num,p[20];
int main()
{
	scanf("%lld%lld",&k,&m);
	p[0]=1;
	for (int i=1;i<=18;++i)
		p[i]=p[i-1]*10;
	for (int i=0;i<=18;++i)
		if (k==p[i])
		{
			if (m==i+1) printf("%lld\n",k);
			else printf("0\n");
			return 0;
		}
	len=(int)log10(k);
	for (int i=len;i>=0;--i)
		num+=k/p[i]-p[len-i]+1;
	if (num==m)	printf("%lld\n",k);
	else if (num>m) printf("0\n");
	else
	{
		for (int i=1;i<=10;++i)
		{
			k*=10;
			num+=k-p[len+i];
			if (num>=m)
			{
				num-=k-p[len+i];
				printf("%lld\n",m-num+p[len+i]-1);
				return 0;
			}
		}
	}
	return 0;
}
```





---

## 作者：shellfish (赞：3)

花2秒想通的题居然花了几个小时才通过，细枝末节太多了。为不停TLE和WA的提供几个我当初栽的坑：

1.TLE可能是因为k刚好是10的幂次，10的幂次位置是定值

2.数本身前后差别，如12在123前而1230在123后，前面计数需要+1

3.9999和10000这种类似的节点很容易算错

如果不追求完美的话，全都long long时间也不会超

下面的代码是每发现一个漏考虑点后加了个if完成的，既不简洁又不漂亮，但是懒得改了

```
#include<stdio.h>
#include<math.h>
int main(){
    int t;
    long long k,m;
    scanf("%lld %lld",&k,&m);
    long long k1,k2,k3;
    int t1;
    long long before,after;
    before=0;
    k3=k1=k;
    k2=10*k;
    t=0;
    long small; //比它小的最大的100... 
	long long large;//比它大的最小100.... 
    while(k){
        k/=10;
        t++;
    }//t:位数 
    large=pow(10,t);
    small=pow(10,t-1);    
	//printf("%d %d\n",m,t);
    if(small==k3){
    	if(t==m) printf("%d",k3);
    	else printf("0");
    	return 0;
	} 
    t1=t;
    while(t1>0){    	
        before+=k1-small+1;//相同位数时在它前面的 
        k1/=10;
        small/=10;
        t1--;    
    }
    after=m-before;//还需要多少在它前面的 
    if(after<0){//不存在 
        printf("0");
        return 0;
    }
	if(after==0){
		printf("%lld",k3);
		return 0;
	} 
    while(1){
        if(after<k2-large)	break;     
		after-=k2-large;  
        k2*=10;
        large*=10;        
    }
	if(after==0) {
		printf("%lld",k2/10-1);
		return 0;
		}	//刚好在上一位完成 
    printf("%lld",after+large-1);
}
```


---

## 作者：huainan_marquis (赞：3)

我要写一篇题解！

这个问题可以分类讨论，对于Q(N,K)=M可以得知N一定是大于等于K的，根据这一条就可以分类讨论：


已知k，求小于k并且字典序在k前面的数：

举个栗子，k=2334那么符合要求的数有哪些呢？

左为具体的数，右为具体数量

1--2      ：2-1+1

10--23    ：23-10+1

100--233  ：233-100+1

1000--2334：2334-1000+1

等等，2334的字典序不比他自己小呀，那好，我们得出结果后把他减一就行~~（自己编了一遍的话就发现没必要，因为在别的地方会把它加上，这个自己实战一下就明白了，因为。。。实在理解不了多输出几次看看）~~

之后呢，把m减去刚才求的这个res。接下来会发生什么呢？

m == 0 ：K即为N；

m<n :不存在。

m>n:

假设减去后m=15000，那该怎么求？

很显然，这个时候N大于2334，那么我们求出大于他的最小的10的次方（10的次方乃是字典序最小的呀因为0不能开头），10000.

那好，结果就是10000+15000=25000.

假设减去后m=23535232，那该怎么求？

这时你会发现，比k大字典序却比他小的数是怎么样的呢？

还是以2334为例：

左为具体的数，右为具体数量

10000-23339 ：2334*10^1

100000-233399:2334*10^2

100000-2333999:2334*10^3

…………………………………………

做法：如果m>具体数量，那么把m减去具体数量，否则结果为m+10的多少此方啦。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
#define int long long

int getlowbit(int num){//比K小的字典序在她前面的数量
    int conversion[11];
    int bit =0;
    while(num){
        conversion[bit++] = num;
        num /= 10;
    }
    
    int res=0,bitnum;
    for(int i =0;i<bit;i++){
        res += conversion[i]-pow(10,bit-i-1)+1;
    }
    return res;
}

signed main(){
    int k,m,highnum;
    cin>>k>>m;
    
    int lownum = getlowbit(k);
    int bignum;
    
    m -= lownum;
    if(m<0){printf("0"); return 0;}
    if(m == 0){printf("%d",k); return 0;}

    for(int i =1;;i*=10)
        if(k/i<10){bignum = i; highnum = k - i; break;}
    if(highnum == 0){printf("0");return 0;}
    bignum *= 10;highnum *=10;
    //cout<<bignum<<" "<<highnum<<" "<<m<<endl;//同学们可以输出一下看看结果
    
    int lastnum=0,num[11],bit=0;
    while(m > highnum){
        m-=highnum;
        highnum *= 10;
        bignum  *= 10;
    }
    
    printf("%lld",bignum+m-1);
    return 0;
    
    
}
```


---

## 作者：mrwalking (赞：3)

//程序特点：纯C语言编写，可以C或C++提交。 目标：大家花时间尽量能看懂的代码(跟踪程序，更容易看懂代码) 。

//题解：该程序的编写，建立在3个样例上(m-1指的是m的前一位)，提供给大家：

```cpp
//样例1
//输入:456 397
//输出:456
//样例2
//输入:456 398
//输出:1000
//样例3
//输入:10 10
//输出:0
//样例1：
//对于456而言，从100~455 都可以，有456-100=356个。
//从10~45 也可以 有45-10+1 =36个 //45是可以的，以为456还有后面的数，所以45也小于456（字典序）
//从1~4中也都可以，有更正4-1+1=4//原因同上
//最大数到456，比456字典序小的个数为(456-100+1)-1+(45-10+1)+(4-1+1)个,即 (456-100+1)+(45-10+1)+(4-1+1)-1个,即396个，getcount函数因此算法编出 
//样例2：
//同样例1思路，但第397个数在小于456里面找不到了，只能从1000~(4560-1)里面进行寻找，可寻找的数目(4560-1)-1000+1=3560个，while(cnt<m-1)里面的内容由此编出
//多算个数cnt-(m-1)，如样例2，cnt=396+3560 m-1=398-1 cnt-(m-1)=3560+396-(398-1)=3599。
//多算个数的数字，属 1000~(4560-1)区间，故m-1位置处数字是，(4560-1)-(3560+396-(398-1))=1000, 过m-1位置处数字是(c-1)-(cnt-(m-1)) 
//在m-1，m位数字间取最大值，即为答案,如样例2,1000 456最大值为1000;样例1 455 456 最大值为456
//样例3的原因是，10最多只能有1字典序比10小，再也找不到满足题意的其他数，字典序比10小了，故要添加 k==base&&cnt<m-1的判断，否则 测试点9,14,16,34,48TLE
#include <stdio.h>
long long base,cnt=0;//如456 base=100 
void getcount(long long x){//获得小于x的，且字典序小于x的数的个数
    long long base1=1,x1=x,x2=x;
    while(x1){//数出x的位数，如456 计算得出base1=100
        x1/=10;
        base1*=10; 
    }
    base1/=10;//因为多 一次*10，故此处 一次/10 
    base=base1;//如456 base=100  
    while(x2){//最大数到456，比456字典序小的个数为(456-100+1)-1+(45-10+1)+(4-1+1)个,即 (456-100+1)+(45-10+1)+(4-1+1)-1个,即396个，getcount函数因此算法编出 
        cnt+=x2-base1+1;
        x2/=10;
        base1/=10;
    }
    cnt-=1;//cnt计算小于x，且字典序小于x的数的个数 
}
long long max(long long a,long long b){
    return a>b?a:b;
}
int main(){
    long long k,m,c,p;
    scanf("%lld%lld",&k,&m);
    getcount(k);
    if(cnt>m-1||k==base&&cnt<m-1){//1 此处写成 if(cnt>m-1)漏了一种情况 10 10 无输出结果。 
        printf("0\n");//无解 
        return 0;
    }
    c=k,p=k-base;
    while(cnt<m-1){//计算大于x，且字典序小于x的数的个数。 //同样例1思路，但第397个数在小于456里面找不到了，只能从1000~(4560-1)里面进行寻找，可寻找的数目(4560-1)-1000+1=3560个，while(cnt<m-1)里面的内容由此编出
        c*=10;
        p*=10;
        cnt+=p;
    }
    printf("%lld\n",max(k,(c-1)-(cnt-(m-1))));
    return 0;
}

```

---

## 作者：Loser_Syx (赞：2)

upd 2023-9-2：修改了 $k$ 与 $m$ 关系混乱的问题。

先不讲做法，考虑 $n = [1, \infty)$ 的每一种情况。易发现如果存在 $Q(n,k) = m$ 的情况，则一定存在这么样子的几个点和区间：

![](https://cdn.luogu.com.cn/upload/image_hosting/p2m757j0.png)

记 $q(n,m) = k$ 为 $1 \sim n$，排名 $m$ 的数是 $k$。

其中 $[1,L)$ 表示 $q(n,m) > k$ 的情况，$[L,R]$ 表示 $q(n,m) = k$ 情况的区间，$(R,\infty)$ 表示 $q(n,m) < k$ 的情况（此处大小比较均为字典序比较）。

具体很好证明，随着 $n$ 的扩大，$1 \sim n$ 的数字越来越多，则字典序 $< m$ 的数字也越来越多。

然后我们发现此处的 $L$ 是我们要求的答案，且 $q(n,m)$ 的结果在字典序比较中具有单调不升的性质，于是可以二分 $n$。

考虑已知 $n$ 和 $m$，需要快速求出对应排名 $m$ 的数，于是就需要一种快速计算 $q(n,m)$ 的方法，考虑字典序的基本定义，如果存在两个数字 $a,b$ 且 $a < b$，那么 $a$ 在一棵十叉的字典树（如下图）中的先序遍历一定是早于 $b$ 的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipr6yujz.png)

（每个节点其实都连接了 $0 \sim 9$ 这些子节点，具体因为长度原因而不在图中体现）

于是可以从根开始枚举以 $p$ 为前缀，定义 $size(p)$ 为以 $p$ 为前缀时 $1 \sim n$ 中的个数，具体计算方法如下：

- 此处定义 $|x|$ 为 $x$ 的位数。

- 依次枚举长度 $i$ 从 $|p|$ 到 $|n|$，则添加的长度为 $i - |p|$。

- 分类讨论当前 $i$，如果当前 $i < |n|$ 或 $p$ 的字典序小于 $n$ 的 $|p|$ 长度前缀的话，则肯定存在 $10^{i - |p|}$ 个数满足 $p$ 是他们的前缀。

- 否则若 $i = |n|$ 且 $p$ 是 $n$ 的前缀，那么就只存在 $n \bmod 10^{i- |p|}+1$ 个数满足 $p$ 为这些数前缀。加一是因为存在要填的位上面都填 $0$ 的情况。

然后开始计算 $q(n,m)$，如果当前已经遍历过的节点数量加上 $size(p)$ 大于等于 $m$ 的话，说明此时答案的前缀就是 $p$，于是可以让当前的 $p$ 作为根，继续遍历下面的节点，如果加起来小于 $m$，说明当前前缀还不是我所想要的，令遍历过的节点个数 $+ size(p)$，同时 $p+1$。

注意如果遍历过的节点个数 $=m$ 的话 $p$ 就是答案。

具体计算方法也可参考[此题](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)。

然后若得到的答案 $ans > m$ 的话，符合 $[1,L)$ 的条件，令 $l$ 指针移动，否则缩小 $r$，注意若 $ans = m$ 需记录答案。

最后输出答案即可。

```cpp
#include <iostream>
#define int long long
int need, m;
int getnum(int pre, int n) {
	int cnt = 0, mul = 1;
	while (pre * mul <= n) {
		if (n / mul == pre) {
			cnt += n % mul + 1;
		} else {
			cnt += mul;
		}
		mul *= 10;
	}
	return cnt;
}
bool small(int x, int y) {
    std::string s1 = "", s2 = "";
    while (x) {
        s1 = (char)(x % 10 + '0') + s1;
        x /= 10;
    }
    while (y) {
        s2 = (char)(y % 10 + '0') + s2;
        y /= 10;
    }
    return s1 < s2;
}
int check(int n, int k) {
    int ans = 1, now = 1;
	while (now < k) {
		int cnt = getnum(ans, n);
		if (k >= now + cnt) {
			now += cnt;
			ans++;
		} else {
			ans *= 10;
			now++;
		}
	}
    if (ans == need) {
        return 2;
    }
    return small(ans, need);
}
signed main() {
    std::cin >> need >> m;
    int l = std::max(need, m), r = 1e18, ans = 0;
    while (l < r) {
        int mid = l + r >> 1;
        int result = check(mid, m);
        if (result) {
            if (result == 2) ans = mid;
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    std::cout << ans << '\n';
	return 0;
}
```

如有不理解可以私信作者，我会一一回复。

---

## 作者：Clu3ter (赞：2)

题目传送门：[P2022 有趣的数](https://www.luogu.com.cn/problem/P2022)

------------


这是一道有趣的题

用自己的*乱搞*解法过了，写一篇题解，说不定就被 hack 了呢？(

------------

根据题意画出如下的图：
![](https://cdn.luogu.com.cn/upload/image_hosting/ck7nweh9.png)

这实际上是一棵十叉树，**深度等于位数，每深一层数量 ×10**(性质1)，每组子节点等于父节点后面分别接上 0 ~ 9 。而**树的每一层恰好就是按照数字大小排序的**(性质2)。

然后我们要考虑如何计算初始的排序位置，也即最小的位置。

### **· Step 1 : 计算最小位置**

以 234
 为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/5730uoj8.png)

容易得出每层为：1~2 + 10~23 + 100~234 。

即 $(2-1+1) + (23-10+1) + (234-100+1)$

由此可见，计算方法就是：

记 $d_k$ 为不大于 $k$ 的最大的 $10^n$ , 
有$base = \sum_\text{k' 为k的前缀} k' - d_{k'} + 1$ 。

根据这个最小值，我们可以初步判断输入是否有解。

### **· Step 2 : 计算增量**

同样以 234 为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/blsmof57.png)

可以发现，后面增加数字时，只有 $[100000\dots , 233999\dots]$ 会使 234 的位置增加。

根据之前提到的 **性质1** 可以得到每次增加一层，位置的增量是按 10 的倍数增长的 ( 134→1340→13400→... )，于是我们可以每次减去最初的差值 ( 记为 $add$ , 即 $k-d_k$  ) 乘上 $10^n$ ，最终再运用 **性质2** 用 $10^n+rest$ 
直接得到最终结果。

### **· Step 3 : 特判**

容易得到:

1. 当 $m<base$ 时，无解。
2. 当 $m=base$ 时，$Ans=k$。

然后当我们输入 ```1 3``` 后会陷入死循环。调试后发现原因出在 $1,10,100,1000$ 等 $10^n$ 的特殊性上，**可以发现 $10^n$ 的位置将始终保持在 $n$ 上**,于是有:

3. 当 $k=d_k$ 时，若 $m \ne base$ ，无解。


------------

下面是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define lint long long

lint n,m,k;
lint base,add,digit; 
lint ans=0;

int main(){
	scanf("%d%d",&k,&m);
	
   //Step1:找到最小值
	lint k0=k,d;
	for(d=1;d*10<=k;d*=10);//计算d_k 
	digit=d;add=k0-d;//计算add 
	while(k0){
		base+=k0-d+1;
		k0/=10;d/=10;
	}//计算base 
//	printf("add:%lld\n",add);
//	printf("digit:%lld\n",digit);
//	printf("base:%lld\n",base);
	
   //Step2:计算增量
	m-=base;
	if(m<0){//特判1 
		printf("0\n");
		return 0;
	}
	if(m==0){//特判2
		printf("%d\n",k);
		return 0;
	}
	if(k==digit && m){//特判3
		printf("0\n");
		return 0;
	}
	add*=10;digit*=10;
	while(m-1>=add){
		m-=add;
		add*=10;digit*=10;
	}//不断减去 
	ans=digit+m-1;//最终加上余量,注意这里的-1,因为是从10..0开始计算的! 
	printf("%lld\n ",ans);
}
```


------------

感谢阅读~☆

---

## 作者：FallR (赞：2)

**确实是很有趣的一道题目**
- **拿到题目的时侯我们会先看数据范围，一眼望去10的9次方（而且还是400ms），如果你有足够的做题经验的话会猜到这一题正解复杂度应该是有个log的**

- **然后可以往二分分治什么的方面去想**

- **题目要求一个序列按照字典序从小到大排序，对于一个固定的k，当序列长度n变大的时候，k在一个序列中的位置只能是不变或者向后移**

- **分析到这里就大概能想到是一个二分答案了**

- **对于judge函数我们需要计算出k在当前长度为mid的序列里的位置，这个计算有很多种计算方向，但耗时有很大的区别，这里分享一个我手摸了~~很久~~一会后发现的**

	对于一个k我们可以把他进行从前到后拆位（12345，可以拆成1,12,123，1234,12345）
    
	对于一个mid我们也可以把他从前到后拆位
    
   拆位有什么作用呢我们可以看到下面的例子
   如果我们要求出k=19在一个mid=20时位置的位置
   
   那么那个序列是：1 10 11 12 13 14 15 16 17 18 19 2 20 3 4 5 6 7 8 9
   
  	19的位置是11
   
   我们可以观察19以及它之前的数，其中一位数的有1，共1个。两位数的有10，11，12，13，14，15，16，17，18，19，共9个
   
   1-1+1=1；
   
   19-10+1=10；
   
   1+10=11；
   
   是不是感觉自己发现了什么

- **我们对于k拆分，然后用k每一个拆分出来的数（假设这个数有p位）去减去10的p次方，然后加起来，就能得带k在一个序列中的位置**
- **这里是拆分一个数的代码**

```cpp
	long long ret=1; int ck=k;
	while(ck)
	{
		++ct;
		ck/=10;
	}//求出k有多少位
	for(register int i=1;i<=18;++i)
	{
		f10[i]=ret;
		ret*=10;
	}//预处理出10各个次方，下标位i的地方存的是10的i-1次方
	for(register int i=1;i<=ct;++i) fk[i]=k/f10[ct-i+1];//fk[i]即为k的前i位
```

- **如果你看到这里，欣喜的写完代码交上去，你可能会获得0分的好成绩**

	我们再考虑一组当k=2，mid=19，的时候，你算出来的k的位置是2，但实际上是12，仔细想一想会发现：
    
    2-1+1=2； 
    
    19-10+1=10；
    
    2+10=12；
	
    我们还需要把mid拆分，然后用mid减去对应的10的某一次方，再加上去。
    
    但是这样写仍旧不对，我们如果把mid设为35，然后我们得到的k的位置就是28，但是实际上k的位置仍旧是12；
    
    对于一个mid我们不能直接用他的位数去减，而需要用k的相应位数（不够在后面补0）减10的某一次方。
    这样的话
    
    2-1+1=2；
    
    20-10=10；
    
    10+2=12；
    
    然后还有一点，当mid和k有相同位数的时候，我们选择其中较小的一个；
    
- **还是把代码贴一下吧，这个题里面很多细节，希望对你理解能有帮助，注释部分是我调试查错的时候写的，忽略即可**

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int tag,k,m,ct;
int fk[11];
long long l,r,ans,fp[20],f10[20];
inline int judge(long long n)
{
	if(n<k) return 0;
	long long pt=0,op=n,cnt=0;
	for(register int i=1;i<ct;++i) cnt+=fk[i]-f10[i]+1;
	cnt+=min(fk[ct]-f10[ct]+1,n-f10[ct]+1);
//	cout<<cnt<<endl;
	while(op)
	{
		++pt;
		op/=10;
	}
	for(register int i=ct;i<=pt;++i) fp[i]=n/f10[pt-i+1];
//	for(int i=ct;i<=pt;++i) cout<<fp[i]<<' ';
//	cout<<endl;
	for(register int i=ct+1;i<pt;++i) cnt+=fk[ct]*f10[i-ct+1]-f10[i];
	if(ct<pt) cnt+=min(fk[ct]*f10[pt-ct+1]-f10[pt],fp[pt]-f10[pt]+1);
//	cout<<cnt<<endl;
	if(cnt>m) return 1;
	else if(cnt==m)
	{
		tag=1;
		return 1;
	}
	else return 0;
}
int main()
{
	scanf("%d%d",&k,&m);
	long long ret=1; int ck=k;
	while(ck)
	{
		++ct;
		ck/=10;
	} 
	for(register int i=1;i<=18;++i)
	{
		f10[i]=ret;
		ret*=10;
	}
	for(register int i=1;i<=ct;++i) fk[i]=k/f10[ct-i+1];
	l=1; r=100000000888888880;
	while(l<=r)
	{
		tag=0;
		long long mid=(l+r)>>1;
		if(judge(mid))
		{
			r=mid-1;
			if(tag) 
			{
				ans=mid;
//				cout<<"mid="<<mid<<endl;
			}
		}
		else l=mid+1;
	}
	printf("%lld",ans);
	return 0;
}
```
- **完结**






---

## 作者：kyel (赞：2)

**题解都好玄啊。。说一个（可能）好理解一点的。**

首先理解一下题意：在K前面按字典序从小到大插入M-1个字典序小于K的数，**求最后一个插入的数的字典序**；若**不存在M-1个字典序小于K的数字**或者**最后一个数在数值上小于K**，则输出0。

暂先不考虑输出0的情况。

显然，我们需要先把数值上小于K的数字算出来，因为这些数字必须要被插入到K前。这个应该不困难，按数位去算就好了。

算出来之后**更新M**，进而考虑**找出M个数值大于K但字典序小于K的数**。

若M = 0，输出K就好了。

考虑所有位数和K相同且字典序小的数，显然我们可以**在这些数后面加0~9来得到一个字典序同样小于K的数**。

```cpp
例如 24 ， 和它位数相同且字典序小的数有
10, 11, 12, ..., 19
20, 21, 22, 23
在上面两行数中任选一个，在其后添上任何数字，字典序都小于K。
如20，可以通过添加0~9变为200,201,202,...,209,都字典序小于24。
注意在24后添加数字，所得到的数字字典序定大于K。
```
那么我们记这些“位数且字典序小”的数个数为fulllen，显然fulllen也容易算出来。

那么我在(K-1)的字符串后面添加x个"9"，就**相当于在K前插入了fulllen \* 10^x 个字典序小于K的数字**。

```cpp
例如，24的fulllen = 14, 那么在23后面添加一个9，得到N=249，则相当于插入了
1 : 100, 101, ..., 109,
2 : 110, 111, ..., 119,
...,
14: 230, 231, ..., 239
总计插入了14 * 10 个数字
```
显然如果添"9"可以解决问题，那么这个解是最优的。但同样显而易见的是，**只添"9"并不一定能恰好插入M个数, 而这也并不意味着无解**。

假定每次添加"9"之后**更新M为还剩下要插入的数**，若添加了一些"9"之后，再添加所插入的数大于了M，那么答案一定是10000....0 + M - 1。

```cpp
例如，在24后添加了一定的9之后，得到了
23999999999
而还剩下233个数字没有插入，那么最优解就是
100000000000 + 233 - 1

放在一起比较两者的位数能方便理解：
A = 23999999999
B = 100000000000
C = 233
D = B + C - 1
首先B大于A，而再加上(C-1)后在24前新插入了C个数字，这些数字是：
100000000000
100000000001
100000000002
...
100000000222
恰好补上了所缺的233个数字。
```

那么，只要能在K-1后添加9就添加9，还有剩下的就用10000...0 + M - 1的方式补上，若有解的话就能得到最优解了。

考虑无解。

最容易想到的当然是取出数值小于K的数后，M小于0.

其次，类似10000的数字是不存在“数值上大于它而字典序小于它”的数字的，特判掉就好了。

```
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

namespace kyel {
	typedef long long lint;
	lint n, m, pow[20];
	int num[20];
	int getnum(lint v, int num[]) {
		int len(0);
		while (v) num[len++] = v % 10, v /= 10;
		return len;
	}
	void work() {
		int len(getnum(m, num));
		lint fulllen(0), tem(m);
		for (int i(len - 1); i; --i) {
			tem /= 10;
			n -= tem - pow[i - 1] + 1;
		} n -= (fulllen = m - pow[len - 1]) + 1;
		if (n < 0) { printf("0\n"); return; }
		if (n == 0) { printf("%lld\n", m); return; }
		lint sub(fulllen * 10), cnt(0);
		if (sub == 0) { printf("0\n"); return; }
		while (n > sub) {
			n -= sub, sub *= 10, ++cnt;
		}
		if (n == sub) printf("%lld\n", pow[cnt + 1] * m - 1);
		else printf("%lld\n", pow[len + cnt] + n - 1);
	}
	void kyel() {
		scanf("%lld%lld", &m, &n);
		pow[0] = 1;
		for (lint i(1); i <= 19; ++i) {
			pow[i] = pow[i - 1] * 10;
		}
		work();
	}
}
int main() {
	kyel::kyel();
	return 0;
}
```


---

## 作者：AtomAlpaca (赞：1)

# 「题解」 P2022 有趣的数

## 题目

[link](https://www.luogu.com.cn/problem/P2022)

## 分析

这道题目要求我们做这样几件事：
1. 判断是否存在$N$使 $Q\left(N,K\right)=M$；
2. 如果存在，求出$N$的最小值。
3. 如果不存在，输出 $0$

通过分析[字典序的定义](https://zh.wikipedia.org/zh-cn/%E5%AD%97%E5%85%B8%E5%BA%8F)，我们可以得到：

$ Q\left(I,K\right) \ge Q\left(N,K\right), I > N $

这是显然的，因为随着$I$的增大，$K$字典序前面的数字绝对不会跑到它后面去。对于不是$10^n$的形式的数字，它前面的数字显然会可能增加。

这意味着，$K$ 一定时，$ Q\left(M,K\right)  $随着$ M $ 的增大而增大。

由于 $ K $ 必须要出现在字典序列中， $ M  $ 的最小值为 $ K $，此时$ Q\left(M,K\right) $也最小。

因此我们得到：
1. 如果 $ Q\left(K,K\right) > M $ ，那么一定不存在 $ N $ 使 $ Q \left( N, K \right) = M $
2. 如果 $ Q\left(K,K\right) = M $ ，那么所求的 $ N = K $

对于形如 $ 10 ^ {n} $的数字$ K $，显然$ Q\left(K,K\right) = n + 1 $。
但对于一般数字，我们首先需要设法求 $ Q \left(K,K\right) $

如果我们求出在 $ k  $ 前的数字的数量，加 $ 1  $ 便是 $ Q \left(K,K\right) $。

我们从位数从小到大的角度讨论在其字典序前的数字。根据字典序的定义，对于位数为 $ l_n $ 的数字 $ n $，我们只需要与 $ K $ 的前$ l_n $位进行比较。

我们预先处理出$ K $的前 $ l $ 位 $ K_l  $，此时不难发现当且仅当 $ n \le K_l $ 时，$ n $ 在 $ K $ 前，或 $ n $ 就是 $ K $本身。

又考虑到任意数字开头不为零，因此，在所有位数为 $ l $ 的数字中，排在 $ K $ 前或与 $ K $相等的有 $ K_{l} - 10^{l - 1} + 1$个。

因此我们得到：
$$
 	\begin{aligned}
		Q\left(K,K \right) = \sum_{ l = 1 }^{ L } {K_l - 10 ^ {l - 1}} + 1
	\end{aligned}
$$
其中 $ L $ 是 $ K $ 的位数。

注意这里其实算进来了一个等于 $K$ 的数，但是因为最后要加 $1$，所以二者可相互抵消，从而得出上述式子。

当 $ Q\left(K,K\right) < M $ 时，我们还要求出一个 $ N $ 令 $ Q\left(N,K\right) = M $。

考虑到对于任意$ L $ 位数 $ n $，若 $ n > K $ ，$ n $ 一定排在 $ K $的字典序之后，因此我们直接开始讨论  $ L + 1 $ 位数。

我们发现，所有小于 $ K $ 的 $ L $ 位数，在后面加上一个数字后，得到的数字的字典序一定还在 $ K $ 的字典序之后，因此每增加一位数，  $ K $ 字典序前的数字增加的量就等于上一位数 $ K $ 字典序前的数字增加的量的 $ 10 $ 倍。

由此我们得到，将序列增加到 $ L + i $ 位数时， $ K $ 字典序前的数字会增加 $ K_{l} \times 10 ^ {i} - 10^{l + i - 1} $ 个。

令 $ P = M - Q\left(K,K\right) $ ， 我们不断枚举 $ i $ ，让 $ P $ 每次减 $ K_{l} \times 10 ^ {i} - 10^{l + i - 1} $ ，当第 $ r $ 次减去后 $ P < 0 $ 时，记录 $ r - 1 $ 及当时的 $ P $ ，则答案为

$$ 10^{r - 1} + P - 1 $$

这是因为，当枚举到 $ r - 1 $ 时，我们距离目标 $ M $ 还有 $ P $ 个数字，这时我们加上这 $ P $ 个$ r $ 位数，在减去与 $ K $ 相等的那个数，我们就能得到答案。

## 代码
请在 C++ 11 或之后的版本运行
``` cpp
#include <iostream>

using std::cin;
using std::cout;

long long k, m, min, now, len;
long long power[20],  nums[20];
int main()
{
	cin >> k >> m;
	power[0] = 1;

	for (int i = 1; i <= 20; ++i)
	{
		power[i] = power[i - 1] * 10;
	}

	for (int i = 0; i <= 20; ++i)
	{
		if (k == power[i] and m != i + 1)
		{
			cout << 0;
			return 0;
		}
	}

	std::string str;
	str = std::to_string(k);
	len = str.length();

	for (int i = 1; i < len; ++i)
	{
		nums[i] = k / power[(len - i)];
	}

	nums[0] = 0;
	nums[len] = k;

	for (int i = 1; i < 11; ++i)
	{
		if (k < power[i - 1])
		{
			break;
		}
		min += nums[i] - power[i - 1] + 1;
	}

	if (min > m)
	{
		cout << 0;
	}
	else if (min == m)
	{
		cout << k;
	}
	else
	{
		m -= min;
		long long ans = power[len];
		int i = 1;
		while (true)
		{
			long long tmp = k * power[i] - power[len + i - 1];
			if (m > tmp)
			{
				m -= tmp;
				ans *= 10;
				++i;
			}
			else
			{
				break;
			}
		}
		ans += m - 1;
		cout << ans;
	}
	return 0;
}
```


---

## 作者：_ajthreac_ (赞：1)

## 0.绪论
感觉很多题解讲得不是很清楚，特此撰写一篇。    
如有雷同，纯属……~~其实我也没想好该怎么办~~
## 1.思路
已知$Q(N,K)=M$，求$N$。        
一个很自然的想法：求出$K$的最小排名。        
我们可以按位枚举所有小于$K$的数。  
```cpp
int len=(int)log10(k);
for(rg int i=len;i>=0;i--){
	cnt+=k/p10[i]-p10[len-i]+1;
}
```
其实就是依次枚举前缀，统计与该前缀位数相同并小于该前缀的个数。                
那么接下来分三种情况：           
### 1.$cnt=M$
直接输出$K$。
### 2.$cnt>M$
计数君数错了，无解！
### 3.$cnt<M$
肯定还有更多位数，继续按位枚举，   
枚举到了就统计。
```cpp
for(rg int i=1;i<=10;i++){
	k*=10;
	cnt+=k-p10[len+i];
	if(cnt>=m){
		cnt-=k-p10[len+i];
		cout<<m+p10[len+i]-cnt-1;
		return 0;
	}
}
```
## 2.细节
### 1.枚举前缀的式子
```k/p10[i]-p10[len-i]+1;```     
可以这样拆解：           
当前数的前缀-和前缀位数相同的最小数+1        
例如$11451-10000+1$         
+1的原因是要算上自己（例如$11451$本身）。   
### 2.增加位数的式子
```cnt+=k-p10[len+i];```       
这次不能像之前那样+1了，因为这次本身的字典序比原数大了（例如$11451400$不能放在$114514$前面）。     
### 3.最后输出的式子
```m+p10[len+i]-cnt-1```       
此式~~自我感觉~~较难理解，建议细细品味。    
可以这样拆解：                     
当前排名+前面位数比原数多的占用的资源-重复计算的
## 3.代码
前面太长的缺省源请至[我的博客](https://www.cnblogs.com/juruoajh/)寻找     
```cpp
int n,k,m,p10[20],cnt;
signed main(){
//	freopen("funny.in","r",stdin);
//	freopen("funny.out","w",stdout);

	//一些预处理和特判 
	p10[0]=1;
	for(rg int i=1;i<=18;i++)p10[i]=p10[i-1]*10;
	Read(k),Read(m);
	for(rg int i=0;i<=18;i++){
		if(k==p10[i]){
			cout<<((m==i+1)?k:0)<<endl;
			return 0;
		}
	}
	
	//计算前面有多少数 
	int len=(int)log10(k);
	for(rg int i=len;i>=0;i--){
		cnt+=k/p10[i]-p10[len-i]+1;
	}
	
	if(cnt==m){//欧皇行为 
		cout<<k<<endl;
		return 0;
	}else if(cnt>m){//官方计数君数少了？那对不起了 
		cout<<0<<endl;
		return 0;
	}else {//官方计数君数多了？那肯定还有更多位数 
		for(rg int i=1;i<=10;i++){
			k*=10;
			cnt+=k-p10[len+i];//不能+1 
			if(cnt>=m){
				//加过了要减回去 
				cnt-=k-p10[len+i];
				//此处建议多手玩一下，就很好理解了 
				cout<<m+p10[len+i]-cnt-1;
		 		return 0;
			}
		}
	}
//	fclose(stdin),fclose(stdout);
	return 0;
}
```
注意```#define int long long```
## 4.完结撒花
希望多多滋磁蒟蒻！[~~再次臭不要脸宣传博客~~](https://www.cnblogs.com/juruoajh/)


---

## 作者：QDK_Storm (赞：1)

#### 数学找规律
1. 计算数k前至少有多少个数：分位数进行讨论，可以发现：

	排在k前面的一位数的个数恰好是 k的 前一位-1+1
    
   排在k前面的两位数的个数恰好是 k的 前两位-10+1
   
   排在k前面的三位数的个数恰好是 k的 前三位-100+1
   
   ……
   排在k前面的p位数的个数恰好是 k的 前p位- $10^{p-1}$ +1
2. 判断是否有解
	
   令sum=排在k前面的数的最少个数
   
   易得m$\ge$sum时有解，m$<$时无解
3. 与第一步类似，枚举位数判断解的范围，具体见代码


记得特判k=$10^{p}$的情况，没有特判只有90分。（~~不要问我怎么知道的~~
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
long long m,k,po[19],bef;
int main()
{
	scanf("%lld%lld",&k,&m);
	po[18]=1000000000000000000;//po数组预处理10的乘方
	for(int i=17;i>=0;i--)
		po[i]=po[i+1]/10;
	for(int i=0;i<=10;i++)//特判k为10的乘方的情况
		if(k==po[i])
		{
			if(m==i+1)
				printf("%lld",k);
			else
				printf("0");
			return 0;
		}
	int i;
	for(i=10;i>=0;i--)//确定k的位数
		if(po[i]<=k)
			break;
	for(int j=i;j>=0;j--)//确定k前至少有几个数
	{
		long long temp=k/po[j];
		bef+=temp-po[i-j]+1;
	}
	if(bef==m)//无解的判断
	{
		printf("%lld",k);
		return 0;
	}
	if(bef>m)
	{
		printf("0");
		return 0;
	}
	for(int j=1;j<=10;j++)//同第一步确定解的范围
	{
		k*=10;
		bef+=k-po[i+j];
		if(bef>=m)
		{
			bef-=k-po[i+j];
			printf("%lld",po[i+j]+m-bef-1);
			return 0;
		}
	}
}
```


---

## 作者：Ciel_bleu (赞：1)

温馨提示：能用long long尽量用long long，毕竟这题不卡空间。

（啰嗦下...必须要小小吐槽下这道题，想出大思路，一打全wa，网上还没有题解，根本无法验证思路好么，，而且细节贼多，让我这种蒟蒻交了五遍，不过好在也是A了，作为人生中第一次尝试的省选题，还是发个题解纪念下。）

再说下自己的思路：10^9，明显不能枚举，于是我们考虑刚好枚举到该数时，每一位上的数字对答案的贡献，显然的，除第一位外，其他位对答案贡献即他本身的大小\*10的剩余位数次方（如“ABC",B使得该数排的次序增加B\*10^2），于是到这里我们便可判断该问题是否有解（很简单，就不浪费篇幅了）....若问题有解，我们考虑在结尾补零，知道在他前面的数超过我们要求的名次为止，在计算差值即可，思想很简单，各位看看那就好，列举下细节，细节正确性各位一定能知道，就不说了。

细节：计算的答案要与原数比较大小，要开long long，常数加减等等。

**附AC代码：**


    
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace    std;
int main()
{
    string a;
    long long k;
    long long tot=0;
    cin>>a>>k;
    long long sum=0;
    long long z=0;
    for(int i=0;i<a.length();i++)
    z=z*10+a[i]-'0';
//cout<<z<<endl;
    for(int j=a.length();j>=1;j--) 
    {
     sum=0;
     for(int i=0;i<j;i++)
    if(i==0)sum=a[i]-'0'-1;
    else sum=sum*10+a[i]-'0';
    tot+=sum;
    }
    tot+= a.length()-1;
    /*for(int i=a.length()-1;i>=0;i--)
    {
    if(a[i]!='0') {a[i]--; break;}
    }*/
    for(int i=0;i<a.length();i++)
    if(i==0) sum=a[i]-'0'-1;
    else sum=sum*10+a[i]-'0';
   if(tot>=k||(sum==0&&tot<k-1)){cout<<0; return 0;}
   long long r=z;
    while(tot<k-1)
    {
    sum*=10;
    z*=10;
    tot+=sum;
    }
    //cout<<z<<endl;
    long long ans=z-(tot-k)-2;
    //cout<<a;
    cout<<max(r,ans);
    return 0;            
}
```

---


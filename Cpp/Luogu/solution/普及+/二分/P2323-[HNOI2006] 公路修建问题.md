# [HNOI2006] 公路修建问题

## 题目描述

OI island 是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER Association 组织成立了，旨在建立 OI island 的交通系统。

OI island 有 $n$ 个旅游景点，不妨将它们从 $1$ 到 $n$ 标号。现在，OIER Association 需要修公路将这些景点连接起来。一条公路连接两个景点。公路有，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。

OIER Association 打算修 $n-1$ 条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率， OIER Association 希望在这 $n-1$ 条公路之中，至少有 $k$ 条 $(0 \le k \le n-1)$ 一级公路。OIER Association 也不希望为一条公路花费的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。

而你的任务就是，在给定一些可能修建的公路的情况下，选择 $n-1$ 条公路，满足上面的条件。

## 样例 #1

### 输入

```
4 2 5 
1 2 6 5
1 3 3 1
2 3 9 4
2 4 6 1```

### 输出

```
6 
1 1 
2 1 
4 1```

# 题解

## 作者：旅人杜 (赞：27)

**首先，题目应该是有些水的。**
先说思路，其实非常清晰，因为它至少要有k条一级公路，所以先将一级公路的花费排序，用kruskal进行处理。然后再将剩下的公路根据二级公路的花费排序，用kruskal2进行处理，之后再将答案按题目要求排序即可。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct node
{
       int u;
       int v;
       int w1;
       int w2;
       int num;//num记读入边的顺序，后面的输出会用到 
}road[20005];
struct nodee
{
       int bh;
       int gl;
}ans[20005];
int flag=0;
int book[20005];//book存这条路有没有建造过 
int father[20005];//父节点 
int n,k,m,minn=0;//n，m，k如题 minn存花费最多的点的价值 
bool merge(int ,int );
int getfather(int );
void kruskal1();//建一级公路 
void kruskal2();//建二级公路 
bool cmp1(node ,node);//按一级公路花费排序 
bool cmp2(node ,node);//按二级公路花费排序 
bool cmp3(nodee ,nodee);//把答案按公路的序号顺序排序 
int main()
{
    scanf("%d%d%d",&n,&k,&m);
    memset(book,0,sizeof(book));
    for(int i=1;i<=n;i++)
            father[i]=i;
    for(int i=1;i<=m-1;i++)
    {
            scanf("%d%d%d%d",&road[i].u,&road[i].v,&road[i].w1,&road[i].w2);
            road[i].num=i;
    }//初始化准备 
    sort(road+1,road+m,cmp1);
    kruskal1();
    sort(road+1,road+m,cmp2);
    kruskal2();
    sort(ans+1,ans+n,cmp3);
    printf("%d\n",minn);
    for(int i=1;i<=n-1;i++)
            printf("%d %d\n",ans[i].bh,ans[i].gl);
    getchar();
    getchar();
    return 0;
}
bool cmp1(node x,node y)
{
      return x.w1<y.w1;
}
bool cmp2(node x,node y)
{
     return x.w2<y.w2;
}
bool cmp3(nodee x,nodee y)
{
     return x.bh<y.bh;
}
int getfather(int x)
{
    if(x==father[x])
                    return x;
    else
    {
        father[x]=getfather(father[x]);
        return father[x];
    }
}
bool merge(int x,int y)
{
     int f1=getfather(x),f2=getfather(y);
     if(f1==f2)
               return false;
     else
     {
         father[f2]=f1;
         return true;
     }
}
void kruskal1()
{
     int step=0;
     for(int i=1;i<=m-1;i++)
     {
             if(book[road[i].num]==0)//这个公路的序号在book中没有被用过 
                           if(merge(road[i].u,road[i].v))
                           {
                                                         book[road[i].num]=1;
                                                         flag++;
                                                         step++;
                                                         minn=max(minn,road[i].w1);
                                                         ans[flag].bh=road[i].num;
                                                         ans[flag].gl=1;
                           }
             if(step==k)
                        return ;
     }
}
void kruskal2()
{
     int step=0;
     for(int i=1;i<=m-1;i++)
     {
             if(book[road[i].num]==0)//这个公路的序号在book中没有被用过 
                           if(merge(road[i].u,road[i].v))
                           {
                                                         book[road[i].num]=1;
                                                         flag++;
                                                         step++;
                                                         minn=max(minn,road[i].w2);
                                                         ans[flag].bh=road[i].num;
                                                         ans[flag].gl=2;
                           }
             if(step==n-1-k)
                        return ;
     }
}
```
下来说说题水在何处

- 题目的要求（即二分答案）在测试数据中根本没有体现，因为题目只说至少k条一级公路，没说不能超过k条。万一有要建造的二级公路的花费比前面k条一级公路花费高怎么办？那就只能再建一条一级公路（保证建的这条比另一条二级公路花费少）
- 没有要求建造公路的总费用最小，kruskal求最小生成树的一个特性直接被忽略了

接下来大致说一下如果这题不水该怎么合理ac

大致思路：
**唯一不同：建两个邻接表 一个存一级公路花费时间 一个存二级公路花费时间**
```cpp
void kruskal1()
{
     int step=0;
     for(int i=1;i<=m-1;i++)
     {
             if(book[road[i].num]==0)//这个公路的序号在book中没有被用过 
                           if(merge(road[i].u,road[i].v))
                           {
                                                         book[road[i].num]=1;
                                                         flag++;
                                                         step++;
                                                         minn=max(minn,road[i].w1);
                                                         ans[flag].bh=road[i].num;
                                                         ans[flag].gl=1;
                           }
             if(step==k)//此处改为找到一个就返回
                        return ;
     }
}
```
这样 先循环k次kruskal1，这个过程中要删除已经建了的边，然后循环完毕后，再用sort1排序一次存一级公路花费的邻接表，再用sort2。然后比较现在的最小的一级公路花费和二级公路花费。如果前小于后，继续建造一级公路，重复上述操作，直到二级公路花费大于一级公路。然后用一次kruskal2.

这里其实就用了**贪心**或者说**二分答案**的思想，两者在此题中都可以解释。

---

## 作者：pengyule (赞：10)

这题大体有两种做法：Kruskal和二分答案，复杂度分别为$O(m\log m)$和$O(m\log_2(30000) )$，其实差不多。

## Kruskal

我们既然要想费用尽可能的少，但是他又必须至少有$k$个一类公路，所以说，我们就尽可能少的取一类公路，即，只取$k$条一类公路。我们用Kruskal生成$k$条一类公路并不会出现浪费（回路）。剩下的道路我们就选$n-1-k$条二号公路，也用Kruskal在剩下的公路中解决（注意两次排序的依据不同）。所有选的边代价取一个最大值就好。
```
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+5,M=2e4+5;
int fa[N];
struct type {
	int u,v,w,tt;
	int ididi,choo;
}a[M],b[M];
vector<type> o;
int find(int x){
	if(x==fa[x]) return x;
	else return fa[x]=find(fa[x]);
}
void unite(int x,int y){
	fa[find(x)]=find(y);
}
bool cmp(type a,type b){
	return a.w<b.w;
}
bool cmp_(type a,type b){
	return a.tt<b.tt;
}
bool _cmp(type a,type b){
	return a.ididi<b.ididi;
}
int main()
{
	int n,k,m,ta,tb,tc1,tc2,m1=0,m2=0,ans=0;
	cin>>n>>k>>m;
	for(int i=1;i<=m-1;i++){
		cin>>ta>>tb>>tc1>>tc2;
		a[++m1].u=ta,a[m1].v=tb;
		a[m1].w=tc2,a[m1].tt=tc1,a[m1].ididi=i;
	}
	for(int i=1;i<=n;i++) fa[i]=i;
	sort(a+1,a+m1+1,cmp_);
	int y=n-1-k,i;
	for(i=1;i<=m1&&k;i++){
		if(find(a[i].u)!=find(a[i].v)){
			unite(a[i].u,a[i].v);
			ans=max(ans,a[i].tt);
			k--;
			a[i].choo=1;
			o.push_back(a[i]);
		}
	}
	sort(a+i,a+m1+1,cmp);
	for(;i<=m1;i++){
		if(find(a[i].u)!=find(a[i].v)){
			unite(a[i].u,a[i].v);
			ans=max(ans,a[i].w);
			a[i].choo=2;
			o.push_back(a[i]);
		}
	}
	cout<<ans<<endl;
	sort(o.begin(),o.end(),_cmp);
	for(int i=0;i<o.size();i++)
	    cout<<o[i].ididi<<' '<<o[i].choo<<endl;
	return 0;
}
```
## 二分答案

大体思路是，对于二分到的这个值$mid$，看看我们在每次所需费用不超过$mid$的情况下尽量多地选择一类公路，如果还没有达到$n-1$那么剩下的用二类公路。如果既满足一类公路条数大于等于$k$又满足总共选择大于等于$n-1$条路，那么这个$mid$应该是满足的。否则说明$mid$小了。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int m1;
int n,k,m,ta,tb,tc1,tc2;
const int N=1e4+5,M=2e4+5;
int fa[N],vis[M],ans[M];
struct type {
	int u,v,w1,w2;
}a[M],b[M];
int find(int x){
	if(x==fa[x]) return x;
	else return fa[x]=find(fa[x]);
}
void unite(int x,int y){
	fa[find(x)]=find(y);
}
bool check(int pp){
    int cnt=0,ss=0;
	for(int i=1;i<=n;i++) fa[i]=i;
	memset(vis,0,sizeof(vis));
    for(int i=1;i<=m1;i++){
        if(find(a[i].u)!=find(a[i].v)){
			if(a[i].w1<=pp){
				vis[i]=1;
        	    cnt++;
        	    ss++;
        	    unite(a[i].u,a[i].v);
        	}
        }
    }
    for(int i=1;i<=m1;i++){
        if(find(a[i].u)!=find(a[i].v)){
        	if(a[i].w2<=pp){
        		vis[i]=2;
        		unite(a[i].u,a[i].v);
        		ss++;
			}
    	}
    }
    if(cnt>=k&&ss>=n-1){
        for(int i=1;i<=m1;i++) ans[i]=vis[i];
        return true;
    }
    else return false;
}
int main(){
	cin>>n>>k>>m;
	for(int i=1;i<=m-1;i++){
		cin>>ta>>tb>>tc1>>tc2;
		a[++m1].u=ta,a[m1].v=tb;
		a[m1].w1=tc1,a[m1].w2=tc2;
	}
	int l=0,r=30000,mid;
	while(l<r-1){
	    mid=(l+r)/2;
	    if(check(mid)) r=mid;
	    else l=mid;
	}
	cout<<r<<endl;
	for(int i=1;i<=m1;i++){
		if(ans[i]) cout<<i<<' '<<ans[i]<<endl;
	}
	return 0;
}
```

---

## 作者：Drinkkk (赞：8)

【参考资料】

liusu201601的博客：https://blog.csdn.net/liusu201601

【题目描述】

OI island是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER Association组织成立了，旨在建立OI island的交通系统。

OI island有$n$个旅游景点，不妨将它们从1到n标号。现在，OIER Association需要修公路将这些景点连接起来。一条公路连接两个景点。公路有两种类型，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。 

OIER Association打算修$n-1$条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率, OIER Association希望在这$n-1$条公路之中,至少有$k(0 \leq k \leq n-1)$条一级公路。OIER Association也不希望为一条公路花费太多的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。而你的任务就是，在给定一些可能修建的公路的情况下，选择$n-1$条公路，满足上面的条件。

【输入输出格式】

- 输入格式

第一行有三个数$n(1 \leq n \leq 10000),k(0 \leq k \leq n-1),m(n-1 \leq m \leq 20000)$，这些数之间用空格分开。

$N$和$k$如前所述，$m$表示有$m$对景点之间可以修公路。

以下的$m-1$行，每一行有$4$个正整数$a,b,c1,c2(1 \leq a,b \leq n,a \not= b,1 \leq c2 \leq c1 \leq 30000)$。

表示在景点$a$与$b$之间可以修公路，如果修一级公路，则需要$c1$的花费，如果修二级公路，则需要$c2$的花费。

**注意，在实际评测时，将只会有$m-1$条公路。**

- 输出格式

输出的第一行有一个数据，表示花费最大的公路的花费。

接下来的$n-1$行，每行有两个正整数$t$和$p$，$t$和$p$表示在输入的第$t$对（按照输入的顺序，从1开始标号）景点之间修建$p$级公路。

$n-1$条公路的输出必选$t$的大小递增，如果有多个方案使花费最大的公路花费最小，那么输出任意一个都可以。

【输入输出样例】

- 输入样例
```
4 2 5 
1 2 6 5
1 3 3 1
2 3 9 4
2 4 6 1
```
- 输出样例
```
6
1 1
2 1
4 2
```

感谢@lutaiye dalao提出的建议，已修改样例。

【题解】

- 我会搜索！

考虑直接搜索判断用那一条边，代码实现难度不高，但时间复杂度过高，期望得分$0$~$35$分。

- 我会最小生成树！

我们可以先选$k$条高价路，$c1$小的边优先选（在这里我使用了$px1()$函数来进行排序）。由于考虑到$m \leq 20000$，所以我们在排序的时候要用快排。选完了这$k$条高价路后我们还要选$(n-1)-k$条低价路，由于$c2 \leq c1$，也即高价路一定比低价路要贵，所以选择低价路一定是最优的，在这里我们还要排一次快排，$c2$小的边优先选择（在这里我使用了$px2()$函数来进行排序），在选编的时候要将方案存到数组$fa[][]$里面去。在这里我用了$fa[][0]$来表示$t$，并且我用了$fa[][1]$来表示$p$，在这里我用了$f[i].su$来表示排序后的第$i$条边的输入的编号是多少。最后再按$t$的大小来排下序即可（在这里我用了函数$px3()$来实现这一部分）。由于我是用手写快排的，所以我的代码可能会长一些。下面上快排的部分（$px1()$和$px2()$以及$px3()$），以及最小生成树的部分（$kruskal()$，在这里我用$kruskal(1)$来表示选择那$k$条高价路的部分，并用$kruskal(2)$来表示选择那$(n-1)-k$条低价路的部分，并且我用了一个变量$ans$来记录答案，也即花费最多的那条公路的花费最小是多少）。还有要注意的是，如果在排$c1$的时候有相同的，那么$c2$大的优先。因为如果有边的$c1$的权值相同的话，那么肯定是留下那个$c2$小的边，因为这样子会更加的优哦。

下面上AC代码~
```
#include <cstdio>
struct node{ int x,y,c1,c2,su; } e[1000001];
int len=0,ans=0,n=0,m=0,k=0;
int fa[10001][2],f[10001];
int max(int x,int y)
{
	return x>y?x:y;
}
void px1(int l,int r)
{
	int x=l,y=r,mid=e[(l+r)/2].c1,t=e[(l+r)/2].c2;
	while(x<=y)
	{
		while(e[x].c1<mid || (e[x].c1==mid && e[x].c2>t))
		{
			x++;
		}
		while(e[y].c1>mid || (e[y].c1==mid && e[y].c2<t))
		{
			y--;
		}
		if(x<=y)
		{
			node t=e[x];
			e[x]=e[y];
			e[y]=t;
			x++;
			y--;
		}
	}
	if(l<y)
	{
		px1(l,y);
	}
	if(x<r)
	{
		px1(x,r);
	}
}
void px2(int l,int r)
{
	int x=l,y=r,mid=e[(l+r)/2].c2;
	while(x<=y)
	{
		while(e[x].c2<mid)
		{
			x++;
		}
		while(e[y].c2>mid)
		{
			y--;
		}
		if(x<=y)
		{
			node t=e[x];
			e[x]=e[y];
			e[y]=t;
			x++;
			y--;
		}
	}
	if(l<y)
	{
		px2(l,y);
	}
	if(x<r)
	{
		px2(x,r);
	}
}
int find(int x)
{
	if(x==f[x])
	{
		return x;
	}
	else
	{
		return f[x]=find(f[x]);
	}
}
void kruskal(int x)
{
	if(x==1)
	{
		int p=0;
		for(int i=1;i<=m;i++)
		{
			int tx=find(e[i].x);
			int ty=find(e[i].y);
			if(tx!=ty)
			{
				f[tx]=ty;
				fa[++len][0]=e[i].su;
				fa[len][1]=1;
				ans=max(ans,e[i].c1);
				p++;
				if(p==k)
				{
					break;
				}
			}
		}
	}
	else if(x==2)
	{
		int p=k;
		for(int i=1;i<=m;i++)
		{
			int tx=find(e[i].x);
			int ty=find(e[i].y);
			if(tx!=ty)
			{
				f[tx]=ty;
				fa[++len][0]=e[i].su;
				fa[len][1]=2;
				ans=max(ans,e[i].c2);
				p++;
				if(p==n-1)
				{
					break;
				}
			}
		}
	}
}
void px3(int l,int r)
{
	int x=l,y=r,mid=fa[(l+r)/2][0];
	while(x<=y)
	{
		while(fa[x][0]<mid)
		{
			x++;
		}
		while(fa[y][0]>mid)
		{
			y--;
		}
		if(x<=y)
		{
			int t=fa[x][0];
			fa[x][0]=fa[y][0];
			fa[y][0]=t;
			t=fa[x][1];
			fa[x][1]=fa[y][1];
			fa[y][1]=t;
			x++;
			y--;
		}
	}
	if(l<y)
	{
		px3(l,y);
	}
	if(x<r)
	{
		px3(x,r);
	}
}
int main()
{
	scanf("%d %d %d",&n,&k,&m);
	m--;
	for(int i=1;i<=m;i++)
	{
		e[i].su=i;
		scanf("%d %d %d %d",&e[i].x,&e[i].y,&e[i].c1,&e[i].c2);
	}
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
	}
	px1(1,m);
	kruskal(1);
	px2(1,m);
	kruskal(2);
	printf("%d\n",ans);
	px3(1,len);
	for(int i=1;i<=len;i++)
	{
		printf("%d %d\n",fa[i][0],fa[i][1]);
	}
	return 0;
}
```

---

## 作者：一扶苏一 (赞：7)

## Description

给定 $n$ 个点 $m - 1$ 条无向边，每条边有两种边权，贵一点的和便宜一点的。要求至少选择 $k$ 条贵边使得图联通且花费最大的边权值最小。

## Input

第一行是三个整数 $n,m,k$。

下面 $m - 1$ 行每行描述一条边。

## Output

输出最小花费与方案。

## Hint

$1~\leq~n~\leq~10000,1~\leq~m~\leq~20000$ ，边权 $\leq~30000$

## Solution

两种做法。

首先题面已经非常明显的提示二分答案，于是我们二分最大花费，然后对两种边分别跑克鲁斯卡尔即可。由于较贵的边有限制，所以我们优先跑较贵的边的克鲁尔卡尔，跑完再跑便宜的边。

这样做的正确性是因为对于一条合法的两个不同的联通块之间的边，他被枚举到的时候是一定会被选择的。

注意到克鲁斯卡尔的复杂度为排序 $O(m \log m)$，主算法 $O(m~\alpha(n))$，本题不需要排序，但是一共跑了 $O(\log c)$ 次主算法，所以总体时间复杂度为 $O(m~\alpha(n)~\log c)$

看起来那个 $O(\alpha(n)~\times~\log c)$ 非常不优美，直觉告诉我这一部分是可以被去掉的，于是我们考虑优化上述算法。

注意到我们在上述算法中对边权是否排序是不影响答案的，所以我们不妨对贵的边进行排序。然后我们发现对贵的边跑 MST 的时候等价于选择出至少 $k$ 条不同联通块之间的边。于是我们直接贪心的选出 $k$ 条边权最小的且能构成合法联通块的边。即对贵的边跑 MST 直到选出 $k$ 条边。

我们发现剩下的边选贵的还是便宜的是无所谓的，于是我们将他们混在一起排序，再对剩下的边跑一遍 MST 即可得答案。

这样做我们一共进行了 $O(1)$ 次克鲁斯卡尔 $O(m~\alpha(n))$ 的主算法，排序复杂度为 $O(m~\log m)$。由于 于是总复杂度 $O(m~(\log m + \alpha(n))$。成功的去掉了乘积

## Code

$O(m~\alpha(n)~\log c)$:

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
    const int L = 1000000;
    char buf[L], *front=buf, *end=buf;
    char GetChar() {
        if (front == end) {
            end = buf + fread(front = buf, 1, L, stdin);
            if (front == end) return -1;
        }
        return *(front++);
    }
}

template <typename T>
inline void qr(T &x) {
    char ch = IPT::GetChar(), lst = ' ';
    while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
    while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
    if (lst == '-') x = -x;
}

namespace OPT {
    char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
    if (x < 0) {x = -x, putchar('-');}
    int top=0;
    do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
    while (top) putchar(OPT::buf[top--]);
    if (pt) putchar(aft);
}

const int maxn = 10010;
const int maxm = 20010;

struct Edge {
    int from, to, v, id;
    
    inline void build(int x, int y, int z, int w) {
        from = x; to = y; v = z; id = w;
    }

    inline bool operator<(const Edge &_others) const {
        return this->v < _others.v;
    }
};
Edge com[maxm], expen[maxm];

int n, m, k, dn;
std::vector< std::pair<int, int> > MU;
int ufs[maxn], rk[maxn];

bool check(int, bool);
int find(ci);
void  unionn(int, int);

int main() {
    freopen("1.in", "r", stdin);
    qr(n); qr(k); qr(m); dn = n - 1;
    for (int i = 1, a, b, c; i < m; ++i) {
        a = b = c = 0; qr(a); qr(b); qr(c);
        expen[i].build(a, b, c, i);
        c = 0; qr(c);
        com[i].build(a, b, c, i);
    }
    int l = 1, r = 30000, mid, ans = 0; 
    while (l <= r) {
        mid = (l + r) >> 1;
        if (check(mid, false)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    qw(ans, '\n', true); check(ans, true); std::sort(MU.begin(), MU.end());
    for (int i = 0; i < dn; ++i) {
        qw(MU[i].first, ' ', true); qw(MU[i].second, '\n', true);
    }
    return 0;
}

bool check(int x, bool rec) {
    for (int i = 1; i <= n; ++i) ufs[i] = i, rk[i] = 1;
    int cnt = 0;
    for (int i = 1; i < m; ++i) if (expen[i].v <= x) {
        int fa = find(expen[i].from), fb = find(expen[i].to);
        if (fa == fb) continue;
        unionn(fa, fb);
        if (rec) MU.push_back(std::make_pair(expen[i].id, 1));
        ++cnt;
    }
    if (cnt < k) return false;
    for (int i = 1; i < m; ++i) if (com[i].v <= x) {
        int fa = find(com[i].from), fb = find(com[i].to);
        if (fa == fb) continue;
        unionn(fa, fb);
        if (rec) MU.push_back(std::make_pair(com[i].id, 2));
        ++cnt;
        if (cnt == dn) return true;
    }
    return cnt == dn;
}

int find(int x) {return ufs[x] == x ? x : ufs[x] = find(ufs[x]);}

void unionn(int fa, int fb) {
    if (rk[fa] < rk[fb]) ufs[fa] = fb;
    else if (rk[fb] < rk[fa]) ufs[fb] = fa;
    else ufs[fb] = fa, ++rk[fa];
}
```

$O(m (\log m + \alpha(n)))$:

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	int top=0;
	do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 20010;
const int maxm = 40010;

struct Edge {
	int from, to, v, id, tp;
	
	inline void build(int x, int y, int z, int w, int u) {
		from = x; to = y; v = z; id = w; tp = u;
	}

	inline bool operator<(const Edge &_others) const {
		return this->v < _others.v;
	}
};
Edge expen[maxn], tmp, edge[maxm];
std::vector< std::pair<int, int> >ans;

int n, k, m, ecnt, maxans;
int ufs[maxn], rk[maxn];

int find(int);
void unionn(int, int);
void printans();

int main() {
	freopen("1.in", "r", stdin);
	qr(n); qr(k); qr(m); int dn = n - 1;
	for (int i = 1, a, b, c; i < m; ++i) {
		a = b = c = 0; qr(a); qr(b); qr(c);
		expen[i].build(a, b, c, i, 1); c = 0; qr(c);
		edge[++ecnt].build(a, b, c, i, 2);
	}
	std::sort(expen + 1, expen + m);
	int cnt = 0;
	for (int i = 1; i <= n; ++i) ufs[i] = i, rk[i] = 1;
	for (int i = 1; i < m; ++i) {
		int fa = find(expen[i].from), fb = find(expen[i].to);
		if (fa == fb) {
			edge[++ecnt] = expen[i];
		} else {
			unionn(fa, fb);
			maxans = expen[i].v;
			ans.push_back(std::make_pair(expen[i].id, 1));
			if ((++cnt) == k) break;
		}
	} 
	std::sort(edge + 1, edge + 1 + ecnt);
	for (int i = 1; cnt !=  dn; ++i) {
		int fa = find(edge[i].from), fb = find(edge[i].to);
		if (fa == fb) continue;
		unionn(fa, fb);
		maxans = std::max(maxans, edge[i].v);
		ans.push_back(std::make_pair(edge[i].id, edge[i].tp));
		++cnt;
	}
	printans();
	return 0;
}

int find(int x) {return ufs[x] == x ? x : ufs[x] = find(ufs[x]);}

void unionn(int a, int b) {
	if (rk[a] < rk[b]) ufs[a] = b;
	else if (rk[a] > rk[b]) ufs[b] = a;
	else ufs[b] = a, ++rk[b];
}

void printans() {
	qw(maxans, '\n', true);
	std::sort(ans.begin(), ans.end());
	for (auto i : ans) {
		qw(i.first, ' ', true); qw(i.second, '\n', true);
	}
}
```



---

## 作者：KagurazakaLorna (赞：6)

做法是Kruskal。

首先按照c1排序，选出前k条边。

然后按照c2排序，选出剩下n-1-k条边。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,k,m;
struct type {
	int t,u,v,c1,c2;
} path[20003];
void init() {
	cin>>n>>k>>m; m--;
	for (int i=1;i<=m;i++) {
		cin>>path[i].u>>path[i].v>>path[i].c1>>path[i].c2;
		path[i].t=i;
		if (path[i].u>path[i].v) swap(path[i].u,path[i].v);
	}
	return;
}

bool cmp1(struct type x,struct type y) {
	return (x.c1<y.c1)||((x.c1==y.c1)&&(x.c2>y.c2));
}

int tree[10003];

int father(int son) {
	if (tree[son]==son) return son;
	int temp=father(tree[son]);
	tree[son]=temp;
	return temp;
}

bool cmp2(struct type x,struct type y) {
	return x.c2<y.c2;
}

int ans=INT_MIN;
pair<int,int> rec[10003];
void kruskal() {
	for (int i=1;i<=n;i++) tree[i]=i;
	int now=1;
	for (int i=1;i<=k;i++) {
		while (father(path[now].u)==father(path[now].v)) now++;
		ans=max(ans,path[now].c1); tree[father(path[now].v)]=father(path[now].u);
		rec[i].first=path[now].t; rec[i].second=1; 
		now++;
	}
	sort(path+now,path+1+m,cmp2);
	for (int i=k+1;i<=n-1;i++) {
		while (father(path[now].u)==father(path[now].v)) now++;
		ans=max(ans,path[now].c2); tree[father(path[now].v)]=father(path[now].u);
		rec[i].first=path[now].t; rec[i].second=2; 
		now++;
	}
	return;
}

bool cmp3(pair<int,int> x,pair<int,int> y) {
	return x.first<y.first;
}

int main() {
	ios::sync_with_stdio(0);
	init();
	sort(path+1,path+1+m,cmp1);
	//for (int i=1;i<=m;i++) cout<<path[i].t<<endl;
	kruskal();
	cout<<ans<<endl;
	sort(rec+1,rec+n,cmp3);
	for (int i=1;i<n;i++) cout<<rec[i].first<<' '<<rec[i].second<<endl;
	return 0;
}

```

---

## 作者：DOTime (赞：6)

# ！ 巨贪无比 ！


- 这道题网上绝大部分的写法就是二分，但是其实并不需要二分。


- 不妨想一想贪心的思路，简直是妙不可言啊。完全减低了难度。


- 我们可以这样想：要求至少有k条一级公路，那我们就排一遍序，按照C1来排序，使用并查集来判断是否添加成功（因为只能加n-1条，所以两点有且只有一条路径，在同一个并查集这条边就不需要加）。


- 当添加了k次成功之后（注意不是前k条，是成功K条），再将剩下的元素再次排序，这次是按照C1与C2的最小值来排序的，前面的失败的边不需要管，因为它是因为冲突才失败的。再次使用并查集判断加边，知道所有的点都在同一个集合，那么答案自然就出来了。

- 简直妙不可言啊！


```cpp
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=11000,MAXM=21000;
int n,k,m,TOT,ans,top,now;//TOT表示集合个数，用于判断是否完成了加边。
int father[MAXN];
struct ed
{
  int from,to,c1,c2,id;
}edge[MAXM];
struct gg
{
  int id,lv;
}way[MAXM];
bool comp(ed x,ed y)//第一次排序
{
  if(x.c1!=y.c1)
    return x.c1<y.c1;
  return x.c2<y.c2;
}
bool cmp(ed x,ed y)//第二次排序（按照最小值排序）
{
  return min(x.c1,x.c2)<min(y.c1,y.c2);
}
bool cop(gg x,gg y)//对答案进行排序
{
  return x.id<y.id;
}
int find(int x)
{
  if(x!=father[x])
    father[x]=find(father[x]);
  return father[x];
}
void Union(int x,int y)
{
  TOT--;
  int X=find(x);
  int Y=find(y);
  father[X]=Y;
}
int main()
{
  scanf("%d%d%d",&n,&k,&m);
  TOT=n;m--;
  for(int i=1;i<=n;i++)
    father[i]=i;
  for(int i=1,a,b,c1,c2;i<=m;i++)
    {
      scanf("%d%d%d%d",&a,&b,&c1,&c2);
      edge[i].from=a;
      edge[i].to=b;
      edge[i].c1=c1;
      edge[i].c2=c2;
      edge[i].id=i;
    }
  sort(edge+1,edge+m+1,comp);
  int tot=1;
  for(now=1;now<=m;now++)
    {
      if(tot>k)break;//前K个成功加入。
      if(find(edge[now].from)!=find(edge[now].to))
    {
      tot++;
      Union(edge[now].from,edge[now].to);
      way[++top].id=edge[now].id;
      way[top].lv=1;
    }
    }
  ans=max(ans,edge[now-1].c1);
  sort(edge+now,edge+m+1,cmp);//再次排序，只要排序后面的。
  for(int i=now;i<=m;i++)
    {
      if(TOT==1)break;
      if(find(edge[i].from)!=find(edge[i].to))
    {
      ans=max(ans,min(edge[i].c1,edge[i].c2));
      Union(edge[i].from,edge[i].to);
      way[++top].id=edge[i].id;
      if(edge[i].c1<edge[i].c2)
        way[top].lv=1;
      else
        way[top].lv=2;
    }
    }
  sort(way+1,way+1+top,cop);
  cout<<ans<<endl;
  for(int i=1;i<=top;i++)
    printf("%d %d\n",way[i].id,way[i].lv);
  return /*  Made by “D O Time”  */0;
}
```

---

## 作者：ReModer (赞：3)

“最大权值的最小值”，单调答案，那就二分咯；  
“连接所有景点”，那就最小生成树咯。

对于二分，把出现过的边值都存到一个数组(co[ ])里，排序后就可以取mid了。  对于最小生成树，两个结构体储存起点、终点、各一个权值及边的编号。

题目要求最少k条c1，所以大于k条也没问题。那么思路就简单了，**把所有能用的c1都用上，不够就找c2补**：

把两个结构体都按权值从小到大排序，然后先从储存c1的结构体里面找：  
如果权值大于mid，就break(后面的边权值更大)，如果边两端已经连通就continue(并查集判断)，否则记录答案。  
c1结构体找完后判断一下，如果已经图已经连通，就return 1；如果连接的边小于k，就return 0。  
接下来寻找c2的结构体，就和普通kruskal一样了。

细节可以看看代码，自认写的不算乱：
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

const int maxn = 2e5 + 10;
int cpy[maxn],ans[maxn],f[maxn],co[maxn],n,m,k,a,b,c,d,cnt,p;
bool book[maxn];
struct data{
    int from,to,c,id;
} edge1[maxn],edge2[maxn];

void init();
bool cmp(data,data);  
void add(int,int,int,int,int);
void input(); 
int find(int);
bool merge(int,int);
bool kruskal(int);
void solve(); 
void output();

int main(){
    input();
    solve();
    output();
    return 0;
} 

void init(){
    for (int i = 1; i <= n; i++)
        f[i] = i;
    memset(book,0,sizeof(book));
    memset(ans,0,sizeof(ans));
}

bool cmp(data a, data b){
    return a.c < b.c;
}

void add(int id, int a, int b, int c, int d){
    edge1[cnt].id = id;
    edge1[cnt].from = a;
    edge1[cnt].to = b;
    edge1[cnt].c = c;
    edge2[cnt].id = id;
    edge2[cnt].from = a;
    edge2[cnt].to = b;
    edge2[cnt].c = d;
    cnt++;
}

void input(){
    scanf("%d%d%d",&n,&k,&m);
    for (int i = 1; i < m; i++){
        scanf("%d%d%d%d",&a,&b,&c,&d);
        add(i,a,b,c,d);
        if (!book[c]) book[c] = 1, co[++co[0]] = c;
        if (!book[d]) book[d] = 1, co[++co[0]] = d;
    }
    sort(edge1,edge1+cnt,cmp);
    sort(edge2,edge2+cnt,cmp);
    sort(co+1,co+co[0]+1);
}

int find(int id){
    return id==f[id] ? id : f[id]=find(f[id]);
}

bool merge(int a, int b){
    int x = find(a);
    int y = find(b);
    if (x == y) return false;
    f[y] = x; return true;
}

bool kruskal(int limit){
    int done = 1;
    for (int i = 0; i < cnt; i++){
        int from = edge1[i].from, to = edge1[i].to;
        int c = edge1[i].c, id = edge1[i].id;
        if (c > limit) break;
        if (merge(from,to)) {
            ans[id] = 1;
            if (++done == n) break;
        }
    }
    if (done - 1 < k) return false;
    if (done == n) return true;

    for (int i = 0; i < cnt; i++){
        int from = edge2[i].from, to = edge2[i].to;
        int c = edge2[i].c, id = edge2[i].id;
        if (c > limit) break;
        if (merge(from,to)){
            ans[id] = 2;
			if (++done == n) break;
		}
    }
    if (done == n) return true;
    else return false;
} 

void solve(){
	int l = 1, r = co[0];
    while (l <= r){
        init();
        int pos = (l+r)>>1;
        int mid = co[pos];
        if (kruskal(mid)) r = pos - 1, p = mid, memcpy(&cpy,&ans,sizeof(ans));
        else l = pos + 1;
    }
}

void output(){
    printf("%d\n",p);
    for (int i = 1; i < m; i++)
        if (cpy[i]) 
			printf("%d %d\n",i,cpy[i]);
}
```


---

## 作者：abandentsky (赞：2)

题意：题目的意思是很简单的就是给出你n个点，然后给你给出m-1条边。让你选
      出n-1条边使得任意两个点之间都可以到达。
限制条件：每条边有两种可能，一级公路和二级公路。
          必须要先选够k条一级公路，然后其他的任选，要求最大的边权值最
          小。
思路：我们先对一级公路排一遍序，先选出k条边。并且标记这条边已被选，然
      后加入二级公路的边，跑完最小生成树。顺便在整个整个过程中记录每条
      边是选择建立一级公路还是二级公路。
AC代码：

```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 10010
#define MAXP 55
#define maxnode 50010
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
#define lc  (id<<1)
#define rc  (id<<1|1)
using namespace std;
typedef long long LL;


int n,k,m,ans,cost;
struct Edge
{
    int from,to,c,pos,tp;
    Edge(int from=0,int to=0,int c=0,int pos=0,int tp=0):from(from),to(to),c(c),pos(pos),tp(tp){};
};

Edge P[2*MAXN];
bool vis[MAXN];
int Q[MAXN];

int pre[MAXN];

int Find(int x)
{
    return pre[x]==x?x:Find(pre[x]);
}

void init(int nn)
{
    for(int i=0;i<=nn;i++)
    {
        pre[i]=i;
    }
}

bool comp(Edge A,Edge B)
{
    return A.c<B.c;
}

bool comp_1(Edge A,Edge B)
{
    return A.pos<B.pos;
}

int main()
{
    scanf("%d %d %d",&n,&k,&m);
    int nn=m-1;
    cost=0;
    init(n);
    for(int i=0;i<nn;i++)
    {
        scanf("%d %d %d %d",&P[i].from,&P[i].to,&P[i].c,&P[i+nn].c);
        P[i+nn].from=P[i].from,P[i+nn].to=P[i].to;
        P[i].pos=i,P[i+nn].pos=i,P[i].tp=1,P[i+nn].tp=2;
    }
    sort(P,P+nn,comp);
    memset(vis,false,sizeof(vis));
    for(int pp=0;pp<nn;pp++)
    {
        int xx=Find(P[pp].from);
        int yy=Find(P[pp].to);
        if(xx!=yy)
        {
            pre[xx]=yy;
            vis[P[pp].pos]=true;
            cost=max(cost,P[pp].c);
            Q[P[pp].pos]=P[pp].tp;
            ans++;
        }
        if(ans==k)
            break;
    }
    sort(P,P+2*nn,comp);
    for(int i=0;i<2*nn;i++)
    {
        if(vis[P[i].pos])
            continue;
        int xx=Find(P[i].from);
        int yy=Find(P[i].to);
        if(xx!=yy)
        {
            pre[xx]=yy;
            vis[P[i].pos]=true;
            cost=max(cost,P[i].c);
            Q[P[i].pos]=P[i].tp;
        }
    }
    printf("%d\n",cost);
    for(int i=0;i<nn;i++)
    {
        if(Q[i])
        {
            printf("%d %d\n",i+1,Q[i]);
        }
    }
    return 0;
}

```


---

## 作者：ljk123 (赞：2)

# 公路修建问题题解

一看到题目中“花费最大的公路最小”，

我们就想到了二分，

于是乎，我们就有了最大的边x，

还需要满足的条件是：

1.有k条花费小于x的一级公路，且这k条不构成环（因为是要树中有k条一级公路）

2.所有花费小于x的公路能构成一条最小生成树

用并查集维护连通，用Kruskal的思想能加就尽量加。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20006;
int n,k,m,p,t,f[N];
struct xd{int x,y,c1,c2;}a[N];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
int getf(int u){return f[u]==u?u:f[u]=getf(f[u]);}
bool merge(int u,int v){
     u=getf(u),v=getf(v);
     if(u==v) return 0;
     f[u]=v; return 1;
}
bool check(int u){
     p=0;
     for(int i=1;i<=n;++i) f[i]=i;
     for(int i=1;i<=m;++i) if(a[i].c1<=u) if(merge(a[i].x,a[i].y)) ++p; 
     if(p<k) return 0;
     for(int i=1;i<=m;++i) if(a[i].c2<=u) if(merge(a[i].x,a[i].y)) ++p; 
     if(p<n-1) return 0;
     return 1;
}
int ef(int l,int r){
    int mid=(l+r>>1);
    if(l==r) return l;
    if(check(mid)) return ef(l,mid);
    else return ef(mid+1,r);
}
int main(){
    n=read(),k=read(),m=read()-1;
    for(int i=1;i<=m;++i) a[i].x=read(),a[i].y=read(),a[i].c1=read(),a[i].c2=read();
    t=ef(1,30000),printf("%d\n",t);
    for(int i=1;i<=n;++i) f[i]=i;
    for(int i=1;i<=m;++i) if(a[i].c1<=t) if(merge(a[i].x,a[i].y)) printf("%d %d\n",i,1);
    for(int i=1;i<=m;++i) if(a[i].c2<=t) if(merge(a[i].x,a[i].y)) printf("%d %d\n",i,2);
    return 0;
} 
```


---

## 作者：加勒比·史努比 (赞：2)

### Slove

用[Kruskal](https://five-shifts-forever.blog.luogu.org/kruskal)建立最小生成树（MST)

1.一级公路是一定要修的，而且最少为k个。所以，把所有的边先按一级公路权值从小到大排序。

2.连接前k个“安全边”，即在Kruskal算法中可以加入的边。

3.把后几条边，按二级公路的权值从小到大排序。

4.继续Kruskal。

### Tips

1.为什么步骤3中排序直接忽略了一级公路的权值呢？

“一级公路上的车速快，但修路的花费要大一些（摘自题目描述的第六行）”也就是说对于同一条边，一般来说，一级公路的权值是要大于二级公路的，所以选二级一定不比选一级差（当然，此题有SJ,不影响结果的话，选一级也是可以的）。

2.在实际评测时，将只会有m-1行公路（我也不知道为啥要少一条）

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;  //标准开头
const int N=20010;
int n,m,k;  //同题
int f[N];  //f[i]——节点i的父节点
struct note{
	int u,r,c1,c2,num;
}d[N];  //同题，u，r——端点，num——序号
int s[N];  //记录每条边的情况
int ans;  //答案
int cnt;  //记录前k个安全边
bool cmp1(const note &a,const note &b){  //排序1
	return a.c1<b.c1;
}
bool cmp2(const note &a,const note &b){  //排序2
	return a.c2<b.c2;
}
int find(int h){
	if(h!=f[h]) f[h]=find(f[h]);
	return f[h];
}
int main()
{
	cin>>n>>k>>m;
	m--;
	for(int i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=m;i++){
		cin>>d[i].u>>d[i].r>>d[i].c1>>d[i].c2;
		d[i].num=i;
	}
	sort(d+1,d+1+m,cmp1);
	for(int i=1;i<=m;i++){
		int x,y;
		x=find(d[i].u);
		y=find(d[i].r);
		if(x!=y){
			f[y]=x;
			ans=max(ans,d[i].c1);
			s[d[i].num]=1;
			cnt++;
		}
		if(cnt==k){
			k=i;
			break;
		}
	}
	sort(d+k+1,d+1+m,cmp2);
	for(int i=k+1;i<=m;i++){
		int x,y;
		x=find(d[i].u);
		y=find(d[i].r);
		if(x!=y){
			f[y]=x;
			ans=max(ans,d[i].c2);
			s[d[i].num]=2;
		}
	}
	cout<<ans<<endl;
	for(int i=1;i<=m;i++){  //完美输出
		if(s[i]>=1) cout<<i<<" "<<s[i]<<endl;
	}
	return 0;
}
```
~~话说为啥这么个题都是蓝的~~

---

## 作者：day_dream (赞：2)

来发个最短的题解（就这么自信）

思路就不多说了，贪心+Kruskal，注意处理完k个一级公路后要再排序一次

上代码：

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
int n,m,x,y,k,ans,fa[10005],vis[20005];
struct typ
{
    int u,v,c1,c2,num;
}a[20005];
int find(int kk)
{
    if(kk!=fa[kk]) fa[kk]=find(fa[kk]);
    return fa[kk];
}
int cmp1(typ xx,typ yy)
{
    return xx.c1<yy.c1;
}
int cmp2(typ xx,typ yy)
{
    return xx.c2<yy.c2;
}
int main()
{
    scanf("%d%d%d",&n,&k,&m);
    for(int i=1;i<m;++i) scanf("%d%d%d%d",&a[i].u,&a[i].v,&a[i].c1,&a[i].c2),a[i].num=i;
    for(int i=1;i<=n;++i) fa[i]=i;
    sort(a+1,a+m,cmp1);
    for(int i=1;i<m;++i)
    {
        x=find(a[i].u);y=find(a[i].v);
        if(x!=y)
        {
            fa[x]=y;
            ans=a[i].c1;
            vis[a[i].num]=1;
            k--;
            if(k==0)
            {
                k=i+1;
                break;
            }
        }
    }
    sort(a+k,a+m,cmp2);
    for(int i=k;i<m;++i)
    {
        x=find(a[i].u);y=find(a[i].v);
        if(x!=y)
        {
            fa[x]=y;
            vis[a[i].num]=2;
            ans=max(ans,a[i].c2);
        }
    }
    printf("%d\n",ans);
    for(int i=1;i<m;++i)
        if(vis[i])
            printf("%d %d\n",i,vis[i]);
    return 0;
}
```

---

## 作者：过往梦魇之殇 (赞：1)

### 直接$Kruskal$（我准备去考虑一下二分...）

概括一下，就是最小生成树问题对于连接两个点的一条边都可以选择两个权值(一级&二级)，一级权值$>=$二级权值，要求必须选至少$k$条一级公路。

因为一级权值始终比二级全职大，所以我们就选$k$条一级公路，求这样构建出来的最小生成树最长的一条大小与选择第几条公路和级别。

这里我们需要写三个排序函数，第一个按照一级公路权值由小到大排序，选出$k$条公路。第二个按照二级公路权值由小到大排序，选出$n-1-k$条公路，记录下来答案需要的值后最后进行第三次排序，按照公路序号由小到大排。

注意这里枚举的是每一条边后在判断各种条件，还要注意题目给的是$m-1$条公路，以及调用快排函数时的各种范围...（$qwq$）

$Code$如下$:$

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
const int maxn=1e4+10;
const int maxm=5e4+10;
struct node{
	int u,v,w1,w2,num;
}edge[maxm<<1];
struct p{
	int fir,sec;
}pr[maxm<<1];
int n,m,k,ans=-1e9,fa[maxn];
int find(int x){
	if(x==fa[x]){
		return x;
	}
	return fa[x]=find(fa[x]);
}
bool cmp1(const node &x,const node &y){
	if(x.w1==y.w1){
		return x.w2>y.w2;
	}
	return x.w1<y.w1;
}
bool cmp2(const node &x,const node &y){
	return x.w2<y.w2;
}
bool cmp3(const p &x,const p &y){
	return x.fir<y.fir;
}
void kruskal(){
	int now=0;
	for(re int i=1;i<=m;i++){
		int uu=find(edge[i].u),vv=find(edge[i].v);
		if(uu==vv){
			continue;
		}
		fa[uu]=fa[vv];
		ans=max(ans,edge[i].w1);
		pr[now].fir=edge[i].num;
		pr[now].sec=1;
		++now;
		if(now==k){
			break;
		}
	}
	sort(edge+1,edge+m,cmp2);
	for(re int i=1;i<=m;i++){
		int uu=find(edge[i].u),vv=find(edge[i].v);
		if(uu==vv){
			continue;
		}
		fa[uu]=fa[vv];
		ans=max(ans,edge[i].w2);
		pr[now].fir=edge[i].num;
		pr[now].sec=2;
		++now;
		if(now+1==n){
			break;
		}
	}
}
int main()
{
	n=read();
	k=read();
	m=read();
	for(re int i=1;i<=n;i++){
		fa[i]=i;
	}
	for(re int i=1;i<m;i++){
		edge[i].u=read();
		edge[i].v=read();
		edge[i].w1=read();
		edge[i].w2=read();
		edge[i].num=i;
	}
	sort(edge+1,edge+m,cmp1);
	kruskal();
	sort(pr,pr+n-1,cmp3);
	write(ans);
	puts("");
	for(re int i=0;i<n-1;i++){
		write(pr[i].fir);
		printf(" ");
		write(pr[i].sec);
		puts("");
	}
    return 0;
}
```

>Thanks For Watching!

---

## 作者：Aryper (赞：0)

公路修建问题

洛谷上好像有好几道和这道题很相似的题，似乎都和公路有关，还有一道叫营救，不过这题是最恶心的，因为还要输出修的路，并且有一二级公路之分。

这一堆题我似乎都是用**近乎同一种方法**过的。

**二分答案+并查集判联通**

题解里都是什么 **kruskal** ，感觉自己好菜，不过跑两次 kruskal 也挺好写的

kruskal 的思路就是先优先做一级公路的最小生成树(伪)，再做二级公路的，跑两遍完事。

二分答案就是先判定答案，再一条边一条边的看，**优先修完 mid 之内的一级公路，再修 mid 之内的二级公路**，这样既可以保证一级公路的数量，也能保证费用。比较粗暴，也比较好想。

时间复杂度 $O(m\log c1_{max})$ 。

几道类似的题目 [P1111 修复公路](https://www.luogu.com.cn/problem/P1111) [P1396 营救](https://www.luogu.com.cn/problem/P1396) 。

方法不只限于这一种，题目的本质是类似的。

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<cstring>
#include<vector>
using namespace std;

struct node {
	long long u,v;
}a[20005],tmp[20005];

long long n,m,k,l,r,mid,sum,tot,ans,cnt;

long long u[20005],v[20005],c1[20005],c2[20005],fa[10005];

int find(int x) {
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}

void uni(int x,int y) {
	fa[find(x)]=find(y);
}

bool check(long long mid) {
	for(int i=1; i<=n; i++)fa[i]=i;
	sum=0;
	tot=0;
	cnt=0;
	for(long long i=1; i<m; i++) if(find(u[i])!=find(v[i])) {
		if(c1[i]<=mid) {
			uni(u[i],v[i]);
			tmp[++tot].u=i;
			tmp[tot].v=1;
			sum++;cnt++;
		}
	}
	
	
	
	for(long long i=1; i<m; i++) if(find(u[i])!=find(v[i])) {
		if(c2[i]<=mid) {
			uni(u[i],v[i]);
			tmp[++tot].u=i;
			tmp[tot].v=2;
			cnt++;
		}
	}

	if(cnt!=n-1)return 0;
	if(sum>=k) {
		ans=tot;
		for(int i=1;i<=tot;i++)
		{
			a[i].u=tmp[i].u;
			a[i].v=tmp[i].v;
		}
	}
	return sum<k?0:1;
}

bool cmp(node x,node y) {
	if(x.u==y.u)
	return x.v<y.v;
	return x.u<y.u;
}

int main() {


	cin>>n>>k>>m;

	for(long long i=1; i<m; i++) {
		scanf("%lld%lld%lld%lld",&u[i],&v[i],&c1[i],&c2[i]);
		r=max(r,c1[i]);
		r=max(r,c2[i]);
	}



	while(l<r) {
		mid=(l+r)/2;
		check(mid)?r=mid:l=mid+1;
	}

	printf("%lld\n",l);
	
	sort(a+1,a+ans+1,cmp);

	for(long long i=1; i<=ans; i++) {
		printf("%lld %lld\n",a[i].u,a[i].v);
	}

	return 0;
}
```


---

## 作者：Cris (赞：0)

这道题之前的题解也都说了，直接Kruskal就可以了，然而我一开始并不明白这样做为什么是对的，后来想了一下，发现是我Kruskal没学明白，又学习了一下Kruskal的证明。

简单说明一下：

Kruskal的正确性是由一个推论得到的：

**对于图中任意一个点x，对于x点连出去的所有边，边权最小的一条至少存在于一棵最小生成树上**

可以推广得到：

**任意一个属于最小生成树的连通子图（子树），从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树**

具体证明可以见网上的许多博客，我就不具体说明了

得到把结论推广到这道题，发现有两个边权并没有什么影响。所以得到直接最小生成树的正确性，即优先选小边权最后得到的解一定最优。

至于代码其实和之前的题解没什么区别。。。
```
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=2e4+99;
int n,k,m,fa[N];
struct node{
	int u,v,c1,c2,id;
}a[N];
struct put{
	int t,p;
}ans[N];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
bool cmp1(node q,node w){
	return q.c1<w.c1;
}
bool cmp2(node q,node w){
	return q.c2<w.c2;
}
bool cmp3(put q,put w){
	return q.t<w.t;
}
int main(){
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=n;i++)fa[i]=i;
	m--;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&a[i].u,&a[i].v,&a[i].c1,&a[i].c2);
		a[i].id=i;
	}
	sort(a+1,a+1+m,cmp1);
	int tot=0,maxx=0;
	for(int i=1;i<=m;i++){
		int r1=find(a[i].u),r2=find(a[i].v);
		if(r1!=r2){
			fa[r1]=r2;
			ans[++tot].t=a[i].id,ans[tot].p=1;
			maxx=max(maxx,a[i].c1);
			if(tot==k)break;
		}
	}
	sort(a+1,a+1+m,cmp2);
	for(int i=1;i<=m;i++){
		int r1=find(a[i].u),r2=find(a[i].v);
		if(r1!=r2){
			fa[r1]=r2;
			ans[++tot].t=a[i].id,ans[tot].p=2;
			maxx=max(maxx,a[i].c2);
			if(tot==n-1)break;
		}
	}
	printf("%d\n",maxx);
	sort(ans+1,ans+n,cmp3);
	for(int i=1;i<n;i++)printf("%d %d\n",ans[i].t,ans[i].p);
	return 0;
}
```

---

## 作者：Freak (赞：0)

二分答案，然后KRUSCAL贪心生成树。

注意不要用快读，会T


```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<deque>
#include<vector>
#include<queue>
#include<ctime>
#include<list>
#include<string>
#include<cassert>
#define pb  push_back
#define ft first
#define sd second
#define ll long long
#define M make_pair
#define P pair<int,int>
#define C(i) cout<<i<<endl
#define F(i,n) for(int i=1;i<=n;i++)
#define REF(i,n) for(int i=n;i>=1;i--)
#define N 20002
#define get(a,i) a&(1<<(i-1))
#define clr(a,b) memset(a,b,sizeof(a))
#define setlargestack(x) int size=x<<20;char *p=(char*)malloc(size)+size;__asm__("movl %0, %%esp\n" :: "r"(p));
using namespace std;
struct p{
    int x,y,w,ww;
}e[N*2];
int num,n,m,a,b,c1,c2,k;
int numb;
int father[N],rt;
int l,r,mid;
void put(int x)
{
    int numm = 0; char c[15];
    while(x) c[++numm] = (x%10)+48, x /= 10;
    while(numm) putchar(c[numm--]);
}
void add(int x,int y,int c1,int c2){
    e[++rt].x=x;e[rt].y=y;e[rt].w=c1;e[rt].ww=c2;
}
int getfather(int x)
{
    return father[x]==x?x:father[x]=getfather(father[x]);
}
struct pp{short data;int id;}ans[N];
bool cmp(pp a,pp b){return a.id<b.id;}
void done(int lim)
{
    for (int i = 1;i <= n;i ++)
        father[i] = i;
    numb = 0;
    for (int i = 1;i <= rt;i ++)
        if (e[i].w <= lim)
        {
            int x = getfather(e[i].x),y = getfather(e[i].y);
            if (father[x] != father[y])
            { 
                father[father[y]] = father[x];
                numb ++;ans[numb].id=i;ans[numb].data=1;
            }
        }
    for (int i = 1;i <= rt;i ++)
        if (e[i].ww <= lim)
        {
            int x = getfather(e[i].x),y = getfather(e[i].y);
            if (father[x] != father[y])
            { 
                father[father[y]] = father[x];
                numb ++;ans[numb].id=i;ans[numb].data=2;
            }
        }
}
bool check(int lim)
{
    for (int i = 1;i <= n;i ++)
        father[i] = i;
    int num = 0;
    for (int i = 1;i <= rt;i ++)
        if (e[i].w <= lim)
        {
            int x = getfather(e[i].x),y = getfather(e[i].y);
            if (father[x] != father[y])
            { 
                father[father[y]] = father[x];
                num ++;
            }
        }
    if (num < k) return false;
    for (int i = 1;i <= rt;i ++)
        if (e[i].ww <= lim)
        {
            int x = getfather(e[i].x),y = getfather(e[i].y);
            if (father[x] != father[y])
            { 
                father[father[y]] = father[x];
                num ++;
            }
        }
    if (num == n - 1) return 1;
    else return false;
}
inline int read(){int x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c<='9'&&c>='0'){    x=x*10+c-'0';c=getchar();}return x*f;}
int main()
{
    n=read();k=read();m=read();
    for(int i=1;i<=m;i++){
        scanf("%d%d%d%d",&a,&b,&c1,&c2);
        add(a,b,c1,c2);
        r=max(r,c1);
    }
    while(r-l>1){
        mid=(l+r)>>1;
        if(check(mid))r=mid;else l=mid;
    }
    if(!check(l))l++;put(l);putchar('\n');done(l);sort(ans+1,ans+1+numb,cmp);
    for(int i=1;i<=numb;i++){put(ans[i].id);putchar(' ');put(ans[i].data);putchar('\n');}
}
```

---


# [SDOI2012] 拯救小云公主

## 题目描述

英雄又即将踏上拯救公主的道路……

这次的拯救目标是——爱和正义的小云公主。

英雄来到boss的洞穴门口，他一下子就懵了，因为面前不只是一只boss，而是上千只boss。当英雄意识到自己还是等级1的时候，他明白这就是一个不可能完成的任务。

但他不死心，他在想，能不能避开boss去拯救公主呢，嘻嘻。

Boss的洞穴可以看成一个矩形，英雄在左下角（1,1），公主在右上角（row，line）。英雄为了避开boss，当然是离boss距离越远越好了，所以英雄决定找一条路径使到距离boss的最短距离最远。

Ps:英雄走的方向是任意的，但是不能走出矩形的范围。即英雄可以到达矩形范围内的任意一个点（没有必要是整点）

你可以帮帮他吗？

当英雄找到了美丽漂亮的小云公主，立刻就被boss包围了！！！英雄缓闭双眼，举手轻挥，白光一闪后使用了回城卷轴，回到了城堡，但只有小云公主回去了……因为英雄忘了进入回城的法阵了。


## 说明/提示

数据范围：

20%数据，boss坐标范围小于等于50；

60%数据，n<=1500；

100%数据，n<=3000；



## 样例 #1

### 输入

```
1 3 3
2 2```

### 输出

```
1.00```

## 样例 #2

### 输入

```
1 3 3
3 1```

### 输出

```
2.00```

# 题解

## 作者：wuzhaoxin (赞：26)

# BFS大火题
首先 ~~标签里面写了，那我们就~~ 二分答案
## 模型转化
把答案视为Boss的攻击半径，题目就变成了给你一个矩形中有一些圆，问能否找到一条从左下角到右上角的路径不经过任何一个圆（此类问题的常规操作）

如果我们把圆看成奶酪上的一些洞，则当左边界或上边界通过这些洞和右边界或下边界联通时问题无解

然后我们看到了[\[NOIP2017\]奶酪](https://www.luogu.org/problemnew/show/P3958)

然后就做完了

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)
using namespace std;
inline int gi() {
    register int x, c, op=1;
    while(c=getchar(),c<'0'||c>'9')if(c=='-')op=-op;
    x=c^48;
    while(c=getchar(),c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48);
    return x*op;
}
int dis[3001][3001];
int x[3001],y[3001];
int getdis(int x1,int y1,int x2,int y2) {
	return pow(x1-x2,2)+pow(y1-y2,2);
}
bool able(int d,double r) {
	return r*r*4>d;
}
int row,line,n;
queue<int>q;
bool vis[3001];
bool bfs(double r) {
	memset(vis,0,sizeof(vis));
	while(!q.empty())q.pop();
	for(int i=1;i<=n;i++)
		if(x[i]<r||row-y[i]<r)q.push(i),vis[i]=1;
	while(!q.empty()) {
		int p=q.front();
		q.pop();
		if(line-x[p]<r||y[p]<r)return 0;
		for(int i=1;i<=n;i++)
			if(!vis[i]&&able(dis[p][i],r))vis[i]=1,q.push(i);
	}
	return 1;
}
int main() {
	n=gi(),line=gi()-1,row=gi()-1;
	for(int i=1;i<=n;i++)
		x[i]=gi()-1,y[i]=gi()-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			dis[i][j]=dis[j][i]=getdis(x[i],y[i],x[j],y[j]);
	double l=0,r=min(row,line),mid;
	for(int i=1;i<=60;i++) {
		mid=(l+r)/2;
		if(bfs(mid))l=mid;
		else r=mid;
	}
	printf("%.2lf\n",l);
	return 0;
}
```

---

## 作者：顾z (赞：10)

> ### Description
>
> 英雄又即将踏上拯救公主的道路……
>
> 这次的拯救目标是——爱和正义的小云公主。
>
> 英雄来到boss的洞穴门口，他一下子就懵了，因为面前不只是一只boss，而是上千只boss。当英雄意识到自己还是等级1的时候，他明白这就是一个不可能完成的任务。
>
> 但他不死心，他在想，能不能避开boss去拯救公主呢，嘻嘻。
>
> Boss的洞穴可以看成一个矩形，英雄在左下角（1,1），公主在右上角（row，line）。英雄为了避开boss，当然是离boss距离越远越好了，所以英雄决定找一条路径使到距离boss的最短距离最远。
>
> Ps:英雄走的方向是任意的。
>
> 你可以帮帮他吗？
>
> 当英雄找到了美丽漂亮的小云公主，立刻就被boss包围了！！！英雄缓闭双眼，举手轻挥，白光一闪后使用了回城卷轴，回到了城堡，但只有小云公主回去了……因为英雄忘了进入回城的法阵了。
>
> ### Input
>
> 第一行，输入三个整数，n表示boss的数目，row，line表示矩形的大小；
>
> 接下来n行，每行分别两个整数表示boss的位置坐标。
>
> ### Output
>
> 输出一个小数，表示英雄的路径离boss的最远距离，精确到小数点后两位。 

这里的距离指的是**欧几里德距离**。

首先很容易看出是**二分答案**。

我们可以看成是以每个$boss$为圆心作一个半径为$r$的圆,我们想要求的就是让这些圆尽可能大,并且不能影响我们从$(1,1)$到$(n,m)$。(不能覆盖)

直接考虑边界条件$(n,1)$和$(1,m)$如果这两个点没有被覆盖,那我必然可以到达$(n,m)$

PS：这里的判断条件不是同时判断。

这样用$||$判断,可以达到我们边界不被封锁的情况。

用**并查集**维护连通即可。

``代码``

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#define eps 1e-4
#define R register

using namespace std;

const int gz=3e3+8;

inline void in(R int &x)
{
	R int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

int nn,n,m,f[gz];

struct cod
{
	int x,y;
}bos[gz];

int find(R int x){return f[x]==x?x:f[x]=find(f[x]);}

inline double xx(R double x)
{
	return x*x;
}

inline double dis(R int i,R int j)
{
	return xx(bos[i].x-bos[j].x)+xx(bos[i].y-bos[j].y);
}

inline bool ok(R double r)
{
	for(R int i=0;i<=nn+1;i++)f[i]=i;
	for(R int i=1;i<=nn;i++)
	{
		for(R int j=1;j<i;j++)
		{
			if(dis(i,j)<=xx(2*r))
			{
				R int fa=find(i),fb=find(j);
				if(fa!=fb)f[fa]=fb;
			}
		}
		if(bos[i].x-r<=1 or bos[i].y+r>=m)
		{
			R int fa=find(i),fb=find(0);
			if(fa!=fb)f[fa]=fb;
		}
		if(bos[i].x+r>=n or bos[i].y-r<=1)
		{
			R int fa=find(i),fb=find(nn+1);
			if(fa!=fb)f[fa]=fb;
		}
	}
	return find(0)!=find(nn+1);
}

int main()
{
	in(nn),in(n),in(m);
	for(R int i=1;i<=nn;i++)
		in(bos[i].x),in(bos[i].y);
	R double ll=0,rr=min(n,m);
	while(fabs(ll-rr)>eps)
	{
		R double mid=(ll+rr)/2;
		if(ok(mid))ll=mid;
		else rr=mid;
	}
	printf("%.2f",ll);
}
```



---

## 作者：JZYshuraK (赞：7)

更一个整体能看的题解

首先看见了题目中所有boss距路径最小距离最大值，不难想到二分答案。

我们二分出的mid就相当于对所有的boss以mid为半径做了一个圆，路径不能经过圆（但是可以经过边界）。

考虑一种暴力：我们$k^2$枚举任意两个boss，如果他们之间的距离小于$mid\times 2$，我们就将他们连在一起，并且判断所有点和边界能否相连，验证的话就是判断是否存在边界之间的连通使得(1,1)无法到达(n,m)

如何优化这个暴力？

我们发现$n^2$的枚举所有边中有一些边是多余的。我们依据这个欧几里得距离求最小生成树，这样的话如果两个点连通且这两个点之间的距离dis是非树边，他们之间的树边都不大于dis故之间的路径连通。

所以我们只需要判断最小生成树的连通性即可。

进而，每次二分mid后枚举整棵生成树将联通的边相连，然后把所有和能抵达边界的boss和代表边界的超级源点相连，判断是否存在两个边界连通能使得(1,1)和(n,m)之间不存在路径。

如果不存在这样的两个边界那么这个mid显然是满足条件的。

显然如果是用kruskal求生成树的话复杂度是和暴力一样的$O(k^2logk)$，故此我们考虑prim求最小生成树即可。

时间复杂度是prim的$O(k^2)$以及二分的$O(logn)$和每次验证的$O(k)$。

总时间复杂度卡在prim的$O(k^2)$。
附上代码（模拟赛上只过了60因为把起点当成了（0,0））
```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define N 3010 
#define inf 10000000 
#define eps 1e-5
using namespace std;
int k,n,m,cnt;
int to[N*8],nxt[N*8],head[N]; double val[N*8]; int tot;
double lc[N],dis[N][N]; int pre[N]; bool vis[N];
int fa[N]; int s1,s2,s3,s4;
struct Node {double x,y;}gd[N];
struct Edge {int x,y; double val;}E[N*8];
inline void add(int x,int y,double z) {to[++tot]=y; val[tot]=z; nxt[tot]=head[x]; head[x]=tot;}
int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}
void prim()// 求最小生成树的prim
{
	// pre[i] 记录的是prim中已选择点距离当前点i距离最近的点
    lc[0]=inf; vis[1]=true;
    for(int i=1;i<=k;i++) lc[i]=dis[1][i],pre[i]=1;
    for(int i=1;i<k;i++)
    {
        int mx=0;
        for(int j=1;j<=k;j++)
        {
            if(!vis[j]&&lc[mx]>lc[j]) mx=j;
        }
        add(mx,pre[mx],lc[mx]); add(pre[mx],mx,lc[mx]);
        vis[mx]=true;
        for(int j=1;j<=k;j++)
        {
            if(!vis[j]&&lc[j]>dis[mx][j]) lc[j]=dis[mx][j],pre[j]=mx;
        }
    }
}
inline void Add(int x,int y)
{
    cnt++; E[cnt].x=x; E[cnt].y=y;
}
inline void merge(int x,int y)
{
    x=find(x); y=find(y);
    if(x!=y) fa[x]=y;
}
bool check(double a)
{
    cnt=0; for(int i=1;i<=k+10;i++) fa[i]=i; // 初始化
    for(int i=1;i<=k;i++) for(int j=head[i];j;j=nxt[j]) if(val[j]<2*a)
    {
        Add(i,to[j]);
    }
	// s1是底边边界，s2是左侧边界，s3是顶边边界，s4是右侧边界。
    for(int i=1;i<=k;i++)
    {
        if(gd[i].x<a) Add(s1,i);
        if(gd[i].y<a) Add(s2,i);
        if((double)n-gd[i].x<a) Add(s3,i);
        if((double)m-gd[i].y<a) Add(s4,i);
    }
    for(int i=1;i<=cnt;i++) merge(E[i].x,E[i].y);
    int S1=find(s1),S2=find(s2),S3=find(s3),S4=find(s4);
    if(S1==S2) return false;
    if(S1==S3) return false;
    if(S2==S4) return false;
    if(S3==S4) return false;
    return true;
}
inline double sqr(double x) {return x*x;}
inline double dist(const Node &a,const Node &b) {return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
int main()
{
    scanf("%d%d%d",&k,&n,&m); n--; m--; s1=k+1,s2=k+2,s3=k+3,s4=k+4;
    for(int i=1;i<=k;i++) scanf("%lf%lf",&gd[i].x,&gd[i].y);
    for(int i=1;i<=k;i++) gd[i].x-=1,gd[i].y-=1;
    for(int i=1;i<=k;i++) for(int j=i+1;j<=k;j++)
    {
        dis[i][j]=dis[j][i]=dist(gd[i],gd[j]);
    }
    prim();
    double l=0,r=(double)(n+m);
    while(r-l>eps)
    {
        double mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    printf("%.2lf\n",r);
    return 0;
}
```
推销个人blog——[JZYshuraK](http://www.cnblogs.com/shurak)

---

## 作者：梨马羊 (赞：6)

别的不说，贡献一个奇妙的剪枝：
先把所有坐标读入，记下它与（1,1）与（row，line）的距离，并在所有的距离中取最小值。
因为如果从（1,1）能到（row，line
)那么开始的时候，勇士/公主到boss的距离一定>=这个最小值。
之后初始化图的时候只要两点间距离>这个最小值就直接不加入，然后跑最小生成树就飞快


---

## 作者：Victorique (赞：5)

这个题是我在做spfa的题的时候偶然看到的，说是一道用最短路和二分的题。

我一看难度，紫题诶，然后看看标签，二分和最短路，二分用的本来就不错，最短路么，昨天练了一整天现在已经形成惯性了，说不定还真能过。

于是乎开始看这个题。。

仔细看了几遍，woc，这个题二分确实有思想，不过跑最短路是个什么鬼，这个坑爹英雄可以360度无死角的跑。。。然后我就换了一种思维，忽然想到了传说中的克鲁斯卡尔最小生成树，貌似这个题这么做还真的有门，可是蒟蒻太弱了根本想不出来。只有大体思路的蒟蒻于是就复制了整个题面百度了一下，发现博客里那些大神犇们真的有用spfa和二分做出来的！！%%%

不过更多的还是和我想的一样的那个最小生成树，这里进行对拍和理解代码后进行一个题的解题报告：










```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long LL;
const int N=3015;
int n,c,r,cnt,f[N],x[N],y[N];
struct edge{int x,y;LL len;}e[N*N];
int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
LL get_dis(int i,int j)
{
    return (LL)(x[i]-x[j])*(x[i]-x[j])+(LL)(y[i]-y[j])*(y[i]-y[j]);
}
LL sqr(int x)
{
    return (LL)x*x;
}
bool operator < (edge a,edge b)
{
    return a.len<b.len;
}
int find(int x)
{
    if (f[x]==x) return x;
    f[x]=find(f[x]);
    return f[x];
}
int main()
{
    n=read();r=read();c=read();
    for (int i=1;i<=n;i++) x[i]=read(),y[i]=read();
    for (int i=1;i<n;i++)
        for (int j=i+1;j<=n;j++)
        {
            e[++cnt].x=i;e[cnt].y=j;e[cnt].len=get_dis(i,j);
        }
    for (int i=1;i<=n;i++)
    {
        e[++cnt].x=i;e[cnt].y=n+1;e[cnt].len=sqr(min(y[i]-1,r-x[i])*2);
        e[++cnt].x=i;e[cnt].y=n+2;e[cnt].len=sqr(min(x[i]-1,c-y[i])*2);
    }
    sort(e+1,e+cnt+1);
    LL mx=0;
    for (int i=1;i<=n+2;i++) f[i]=i;
    for (int i=1;i<=cnt;i++)
    {
        int p=find(e[i].x),q=find(e[i].y);
        if (p!=q)
        {
            f[p]=q;
            mx=max(mx,e[i].len);
            if (find(n+1)==find(n+2)) break;
        }
    }
    printf("%.2lf",(double)sqrt(mx)*0.5);
    return 0;
}
```
这个代码仅仅能得70分，而且经过优化之后的最快代码仍然只能得80，所以这么看来最小生成树并不是最优解，不过70分我已经能看别人的代码了诶qwq~，所以果断看了楼下一个大佬的代码。。发现这个题用现在的思想直接跑spfa就可以了，而且开了氧气优化之后跑的超级快，所有点加起来都比刚才倒数第四的点快。。。。不说别的了直接上代码。。。
这里给一个刚才最小生成树之所以能跑的主要思想，spfa也是因为这个而得以实现。

我们可以把任意两个圆之间连边，然后再让他们和左边那条边，上边那条边或右边那条边，下边那条边连边，这样的话，我们其实就是要找到一颗最小生成树，使得其包含每个点和那四条边。这样子我们也可以顺利解决这道题

注意：注意：注意：这个题数据规模很大，要记得用那个几乎可能忘了的邻接矩阵来跑spfa。稠密图就是这么恶心的卡飞spfa。


    
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm> 
#define re register
using namespace std;
typedef long long LL;
struct point
{
    int x;
    int y;
    LL z;
};
point d[3000001];
int m,n,a,b,l,h,tot,sum,k,s,num;
int temp[10000001]; 
double dis[1000001],map[3005][3005],x[1000001],y[1000001];
bool visit[10000001];
double js(int x1,int x2,int y1,int y2)
{
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))/2;
}
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}
inline void spfa()
{
    int head=0;
    int tail=1;
    dis[0]=0;
    visit[0]=1;
    while(head<tail)
    {
        int now=temp[++head];
        visit[now]=0;
        for(re int i=0;i<=n+1;i++)
        {
            if(i==now)
            continue;
            if(dis[i]>max(dis[now],map[now][i]))
            {
                dis[i]=max(dis[now],map[now][i]);
                if(!visit[i])
                {
                    visit[i]=1;
                    temp[++tail]=i;
                }
            }
        }
    }
}
int main()
{
    n=read();
    a=read();
    b=read();
    for(re int i=1;i<=n;i++)
    {
        x[i]=read();
        y[i]=read();
    }
    for(re int i=1;i<n;i++)
     for(re int j=i+1;j<=n;j++)
     {
         map[i][j]=map[j][i]=js(x[i],x[j],y[i],y[j]);
     }
    for(re int i=1;i<=n;i++)
    {
        map[0][i]=map[i][0]=min(x[i]-1,b-y[i]),map[n+1][i]=map[i][n+1]=min(a-x[i],y[i]-1);
    }
    memset(dis,100,sizeof(dis));
    map[0][n+1]=map[n+1][0]=0x7fffffff;
    spfa();
    printf("%.2lf",dis[n+1]);
}
膜拜这个题68毫秒跑过去的那个大牛分站rank1.。
```

---

## 作者：crashed (赞：2)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P2498)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，不难想到二分答案。然后问题就变成了：在一个矩形内给你$n$个圆，不能走到圆内（圆上可以），问你能否从左下角走到右上角。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，我们**与其直接考虑哪些情况可以走到，不如考虑哪些情况不能走到**。显然，此时必须是边界通过圆连了起来才可以。考虑哪些边界连起来之后会影响起点和终点的连通性。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;枚举发现：上边界和下边界、右边界连在一块之后走不动了；左边界和下边界、右边界连在一块之后也走不动了。共四种情况。检查的时候枚举配对数量，用并查集维护连通性，之后判断边界情况即可。时间$O(n^2\log_2V)$，$V$是答案值域。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，这道题还可以优化。根据最小生成树的性质（与某个点相邻的权最小的边一定在图的最小生成树里面），我们可以知道，实际上，我们只需要检查$boss$的最小生成树里面的边能不能在当前二分的长度下加入到图里面即可。如果这些边都不可以，那么剩下的边就更不可能了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，我们预先跑一边最小生成树$Prim$（$O(n^2)$），检查就只需要检查最小生成树上的边，然后再检查一遍边界的连通性。检查的时间是$O(n)$。总时间$O(n^2+n\log_2V)$。
# 代码
```cpp
#include <cmath>
#include <cstdio>

const int MAXN = 3005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct edge
{
	int from, to;
	double w;
	edge(){}
	edge( const int F, const int T, const double W ) { from = F, to = T, w = W; }
}E[MAXN];

double dis[MAXN][MAXN];
double len[MAXN];
int fr[MAXN], fa[MAXN], x[MAXN], y[MAXN];
int N, row, line, cnt;
bool visited[MAXN];

void makeSet( const int siz ) { for( int i = 1 ; i <= siz ; i ++ ) fa[i] = i; }
int findSet( const int u ) { return fa[u] == u ? fa[u] : ( fa[u] = findSet( fa[u] ) ); } 
void unionSet( const int u, const int v ) { fa[findSet( u )] = findSet( v ); }
bool same( const int u, const int v ) { return findSet( u ) == findSet( v ); }

double getDis( const int a, const int b ) { return sqrt( 1.0 * ( x[a] - x[b] ) * ( x[a] - x[b] ) + 1.0 * ( y[a] - y[b] ) * ( y[a] - y[b] ) ); }

bool chk( const double dist )
{
	makeSet( N + 4 );
	for( int i = 1 ; i <= cnt ; i ++ )
		if( E[i].w < dist * 2 )
			unionSet( E[i].from, E[i].to );
	for( int i = 1 ; i <= N ; i ++ )
	{
		if( x[i] - 1 < dist ) unionSet( i, N + 1 );
		if( y[i] - 1 < dist ) unionSet( i, N + 2 );
		if( row - x[i] < dist ) unionSet( i, N + 3 );
		if( line - y[i] < dist ) unionSet( i, N + 4 );
	}
	if( same( N + 1, N + 2 ) || same( N + 3, N + 4 ) || same( N + 1, N + 3 ) || same( N + 2, N + 4 ) ) return false;
	return true;
}

int main()
{
	read( N ), read( row ), read( line );
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
			dis[i][j] = 0x3f3f3f3f3f;
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( x[i] ), read( y[i] );
		for( int j = 1 ; j <= i ; j ++ ) 
			dis[i][j] = dis[j][i] = getDis( i, j );
	}
	for( int i = 1 ; i <= N ; i ++ ) visited[i] = false, len[i] = 0x3f3f3f3f;
	len[1] = 0;
	int mn;
	for( int i = 1 ; i <= N ; i ++ )
	{
		mn = -1;
		for( int j = 1 ; j <= N ; j ++ )
			if( ! visited[j] && ( mn == -1 || len[mn] > len[j] ) )
				mn = j;
		if( mn == -1 ) break;
		visited[mn] = true;
		E[++cnt] = edge( fr[mn], mn, len[mn] );
		for( int j = 1 ; j <= N ; j ++ )
			if( ! visited[j] && dis[mn][j] < len[j] )
				len[j] = dis[mn][j], fr[j] = mn;
	}
	double l = 0, r = sqrt( 1.0 * row * row + 1.0 * line * line ), mid;
	while( r - l > 0.00001 )
	{
		mid = ( l + r ) / 2;
		if( chk( mid ) ) l = mid;
		else r = mid;
	}
	printf( "%.2lf\n", l );
	return 0;
}
```

---

## 作者：胡尔克HULK (赞：1)

把左边界和上边界看成一个点，把右边界和下边界看成一个点，每两个点之间的路径长度是欧几里得距离的一半，和边界的距离是垂线段长度，然后求这两个点之间路径最长边的最小长度，用dijkstra就可以做
坑点是，左边界和下边界是1，不是0
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <queue>
#include <iomanip>
using namespace std;
struct point{
    double x,y;
}nu[3100];
double mx(point a,point b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double ds[3100][3100]={0};
int n,m=0;
double x,y;
double jk[3100]={0};
bool vis[3100]={0};
struct dr{
    int x;
    double dis;
};
bool operator<(dr a,dr b)
{
    return a.dis>b.dis;
}
priority_queue<dr> q;
void dj(int x)
{
    jk[x]=0;
//  vis[x]=1;
    q.push({x,0});
    while (!q.empty())
    {
        dr r=q.top();
        int x=r.x;
        double dis=r.dis;
        q.pop();
        if (vis[x])
            continue;
        vis[x]=1;
//      cout<<x<<'-'<<jk[x]<<endl;
        for (int i=1;i<=n+2;i++)
          if (!vis[i])
            if (max(ds[x][i],jk[x])<jk[i]){
                jk[i]=max(ds[x][i],jk[x]);
//              cout<<i<<' '<<jk[i]<<endl;
                q.push({i,jk[i]});
            }
//      cout<<endl;
    }

}
int main()
{
    cin>>n>>x>>y;
    int UL=n+1,DR=n+2;
    for (int i=1;i<=n;i++){
        cin>>nu[i].x>>nu[i].y;
        for (int ii=1;ii<i;ii++)
        {
            ds[i][ii]=ds[ii][i]=mx(nu[i],nu[ii])/2;
        }
        ds[i][UL]=ds[UL][i]=min(nu[i].x-1,y-nu[i].y);
        ds[i][DR]=ds[DR][i]=min(x-nu[i].x,nu[i].y-1);
    }   
    for (int i=1;i<=n+2;i++)
        ds[i][i]=0;
    ds[UL][DR]=ds[DR][UL]=999999999999;
//  for (int i=1;i<=n+2;i++){
//      for (int ii=1;ii<=n+2;ii++)
//          cout<<ds[i][ii]<<' ';
//      cout<<endl;
//  }
    for (int i=1;i<=n+2;i++)
        jk[i]=9999999999999;
    dj(UL);
//  for (int i=1;i<=n+2;i++)
//      cout<<jk[i]<<' ';
//  cout<<endl;
    cout<<fixed<<setprecision(2)<<jk[DR]<<endl;
} 
```


---

## 作者：zzhhtt (赞：0)

我的naive的做法是二分答案+判定是否有路径可走……但是没有正确理解【走的方向任意】这句话……

　　其实就是说想咋走咋走= =360°无死角乱走……

　　所以其实是个平面上的问题……

 

　　我们可以换个方向来考虑……二分一个答案，判断英雄走到/走不到公主那里，是不是就等价于，boss控制的区域连起来了使得英雄走不到公主那里了？（狼抓兔子的即视感）

　　所以我们可以转化成从上边&左边，在boss之间走，使得走到下边&右边 路径上最大的一条边（边权代表着如果英雄从这两个boss之间经过，离两个boss最近的距离（所以就是dis(boss[i],boss[j])2  dis(boss[i],boss[j])2））最小。

　　这个好像不能SPFA？（明明是你蒻）……我WA40了……只能bellman-ford迭代了……


附上代码

```
#include<bits/stdc++.h>
#define LL long long
LL in() {
    char ch; LL x = 0, f = 1;
    while(!isdigit(ch = getchar()))(ch == '-') && (f = -f);
    for(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 1) + (x << 3) + (ch ^ 48));
    return x * f;
}
const int maxn = 3505;
int n;
bool flag;
double X, Y;
struct node {
    double x, y;
    node(double x = 0, double y = 0): x(x), y(y) {}
}e[maxn];
std::vector<int> v[maxn];
bool vis[maxn];
double D[maxn][maxn];
std::queue<int> q;
bool ok(double mid) {
    while(!q.empty()) q.pop();
    for(int i = 1; i <= n; i++) {
        if(e[i].x < mid || Y - e[i].y < mid) q.push(i), vis[i] = true;
        else vis[i] = false;
    }
    while(!q.empty()) {
        int tp = q.front(); q.pop();
        if(X - e[tp].x < mid || e[tp].y < mid) return false;
        for(int i = 1; i <= n; i++) if(!vis[i] && D[tp][i] < mid * mid * 4.0) vis[i] = true, q.push(i);
    }
    return true;
}
int main() {
    n = in(), X = in() - 1, Y = in() - 1;
    for(int i = 1; i <= n; i++) e[i].x = in() - 1, e[i].y = in() - 1; 
    for(int i = 1; i <= n; i++)
        for(int j = i + 1; j <= n; j++) {
            node a = e[i], b = e[j];
            D[i][j] = D[j][i] = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
        }
    double l = 0, r = std::min(X, Y), ans = r;
    int t = 200;
    while(t--) {
        double mid = (l + r) / 2.0;
        if(ok(mid)) ans = mid, l = mid;
        else r = mid;
    }
    printf("%.2f", ans);
    return 0;
}
```


---


# 汽车拉力比赛

## 题目描述

博艾市将要举行一场汽车拉力比赛。

赛场凹凸不平，所以被描述为 $N*M$ 的网格来表示海拔高度 $(1 \leq M,N \leq 500)$，每个单元格的海拔范围在 $0$ 到 $10^9$ 之间。

其中一些单元格被定义为路标。组织者希望给整个路线指定一个难度系数 $D$，这样参赛选手从任一路标到达别的路标所经过的路径上相邻单元格的海拔高度差不会大于 $D$ 。也就是说这个难度系数 $D$ 指的是保证所有路标相互可达的最小值。任一单元格和其东西南北四个方向上的单元格都是相邻的。

## 样例 #1

### 输入

```
3 5 
20 21 18 99 5  
19 22 20 16 26
18 17 40 60 80
1 0 0 0 1
0 0 0 0 0
0 0 0 0 1```

### 输出

```
21```

# 题解

## 作者：Ajwallet (赞：33)

# 竟然没有并查集的代码？

---
# 题目大意
在一个$n\times m$的矩阵中，每个点都有相应的高度，规定两点间的高度差不大于$D$就当这两个点联通，先要求出最小的$D$使得给定的点都联通
# 解题思路
显然，假如$D=50$，满足要求的话，那么$D=51$也必定满足要求，说玄学一点就是`答案具有单调性`

那么我们就可以用二分来处理啦！

对于能否滑行，这里用的是并查集的判定

若两点间高度不大于$mid$（当前二分的$D$），则将它们的祖先合并，最后判断一下所有要求连接的点之间是否联通就行啦！
# 代码
$Very\ \ Important$
时间复杂度:$O(logMaxhigh\times nm)$
最高复杂度为:$O(log100000000\times 250000)\approx O(7500000)$能过
```cpp
#include<cstdio>
#include<cstring>
#define id(i,j) ~-i*m+j//即每个点的编号，相当于(i-1)*m+j
using namespace std;
int h[501][501],f[250001],a[250001],len;//h是每个点的高度，f是并查集数组，a是需要保证联通的点，len是a数组长度
int ans,l,r,n,m,mid;
const short dx[4]={-1,0,1,0};
const short dy[4]={0,1,0,-1};
int find(int x){return x==f[x]?x:f[x]=find(f[x]);}
void add(int x,int y){f[find(x)]=find(y);return;}
int abs(int x){return x<0?-x:x;}
bool check(int high)
{
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)f[id(i,j)]=id(i,j);//初始化
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	  for(int k=0;k<4;k++)//向周围四个点连边
	  {
	  	int nx=i+dx[k],ny=j+dy[k];
	 	if(nx<1||ny<1||nx>n||ny>m) continue;//爆出范围跳过
	 	if(abs(h[i][j]-h[nx][ny])>high)continue;//超过高度跳过
	 	add(id(i,j),id(nx,ny));//连边
      }
	for(int i=1;i<len;i++) 
	if(find(a[i])!=find(a[i+1])) return false;//判断是否能联通
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) {scanf("%d",&h[i][j]);if(h[i][j]>r) r=h[i][j];}//保存最大的r
	for(int i=1;i<=n;i++) for(int j=1,t;j<=m;j++) 
	{scanf("%d",&t);if(t) a[++len]=id(i,j);}//保存
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(check(mid))//判断
		{
			ans=mid;
			r=mid-1;//调整右边界
		}
		else l=mid+1;//调整左边界
	}
	printf("%d",ans);//输出
}
```

---

## 作者：windows_11 (赞：31)

一个好玩的bfs，很简单，但是我win10卡了两个小时...
```cpp
// 此代码，两次WA（0分），两次AC（后一次为优化） 
# include <bits/stdc++.h> // 头文件 
using namespace std; // 名字空间 
const int N=505; bool c[N][N], sign=1, vis[N][N];
// 数组范围，路标，第一个路标，是否访问 
int n, m, a[N][N], l, r, mid, ans, st, en, tp;
// n，m，高度，左（二分），右（二分），中（二分），答案，
// 开始路标的x坐标，答案，开始路标的y坐标，路标个数 
int dx[5]={0, 0, 1, 0, -1},
	dy[5]={0, 1, 0, -1, 0};
// 方向增量数组 
bool bfs () { // 伟大的bfs 
	queue <int> x, y; // 定义队列，x坐标，y坐标 
	int now=1; // 记录已访问的路标，之前用了队列z，错了2个小时，有毒 
	x.push (st), y.push (en); // 初始压入队列 
	vis[st][en]=1; // 起点为已访问 
	while (!x.empty ()) { // 判断结束 
		int xx=x.front (), yy=y.front (); // 记录x和y 
		if (now==tp) return 1; // 如果已经访问了所有的路标，可以退出 
		x.pop (), y.pop (); // 出队 
		for (int i=1; i<=4; i++) { // 开始像四个方向搜索 
			int nx=xx+dx[i], ny=yy+dy[i]; // 计算现在的坐标 
			if (nx<1 || nx>n || ny<1 || ny>m || vis[nx][ny]) continue;
			// 如果越界或访问过，不再执行入队操作 
			int tpp=abs (a[nx][ny]-a[xx][yy]); // 计算高度差，要绝对值 
			if (tpp>mid) continue;
			// 高度差大于期望值（mid），不符合要求，不再执行入队操作 
			else { 
				if (c[nx][ny]) now++; // 如果是路标，访问数加一 
				x.push (nx), y.push (ny); // 入队 
				vis[nx][ny]=1; // 标记为已访问 
			} 
		}
	}
	return 0;
}
int main () {
	freopen ("node.in", "r", stdin);
	freopen ("node.out", "w", stdout);
	scanf ("%d%d", &n, &m); // 读入 
	for (int i=1; i<=n; i++) // 读入 
		for (int j=1; j<=m; j++) { // 读入 
			scanf ("%d", &a[i][j]); // 读入 
			r=max (r, a[i][j]); // 右端点为高度最大值 
		} // 读入 
	for (int i=1; i<=n; i++) // 读入 
		for (int j=1; j<=m; j++) { // 读入 
			scanf ("%d", &c[i][j]); // 读入 
			if (c[i][j]) tp++; // 如果是路标，记录个数（加一） 
			if (sign && c[i][j]) { // 如果是第一个路标 
				st=i; en=j; sign=0; // 记录坐标，取消第一个标记 
			}
		} 
	while (l<=r) { // 二分开始 
		mid=(l+r)/2; // 计算中间值 
		memset (vis, 0, sizeof vis); // 清空访问数组 
		if (bfs ()) // 如果这个值可以访问到所有路标 
			r=mid-1, ans=mid; // 记录答案，缩小右端点 
		else l=mid+1; // 如果这个值不可以访问到所有路标，扩大左端点 
	} 
	printf ("%d\n", ans); // 输出答案 
	return 0;
}

```

---

## 作者：JeffWang2019 (赞：25)

[P2658 汽车拉力比赛](https://www.luogu.com.cn/problem/P2658)

## 本题算法：并查集+bfs+二分

先说说题目大意：**在一个N×M的矩阵中，给定每个点相应的高度，规定若两点间的高度差不大于D，两个点就是联通的。**

你要求出的就是**最小的D，使得给定的点都联通**。

那么这些算法的优势就显现出来了：

并查集可以将不同的块连通，在此题连通块中很适用；

bfs作为搜索的一种，在图论中很适用，尤其是这种带地图的题；

二分就是从中间开始逐渐夹逼最终得出答案的算法，就像这题，需要求最小的D，明显要使用二分来查找。

## 思路：

首先读入数据后，记录所有的路标；

然后开始二分算法；

在二分中的判断函数就是bfs，判断当前的D是否大了/小了；

bfs中又会用到并查集，来根据正在判断的D连通尽可能多的要求的块；

一切完成后二分答案就出来喽~~

### 完整代码如下：

```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int f[250001],a[250001],d[501][501];//可以开一维数组表示地图,大小为n*m即250000
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};//表示四个方向(上下左右),在bfs里使用
int n,m,maxn,cnt,l,r;
int find(int x)//并查集--查找
{
    if(f[x]==x)//等于就返回x
     {
        return x;
     }
     f[x]=find(f[x]);//不等于就继续递归
     return f[x];
     //也就是return f[x]=find(f[x]);
}
void merge(int x,int y)//判断,连通块
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)//不同就更新f[fx]=fy
    {
        f[fx]=fy;
  } 
}
bool bfs(int x)//bfs搜索
{
    for(int i=1;i<=n*m;i++)//对于一维数组初始化
    {
        f[i]=i;//初始化每个值都等于它的下标
    }
    for(int i=1;i<=n;i++)//两层循环，bfs
    {
        for(int j=1;j<=m;j++)
        {
            for(int k=0;k<4;k++)//前面定义好了四个方向,这个循环是来搜索4个方向的
            {
                int xx=i+dx[k],yy=j+dy[k];//两个新坐标
                if(xx<1||xx>n||yy<1||yy>m)//如果出边界
                {
                    continue;//尝试下一个方向
                }
                if(abs(d[i][j]-d[xx][yy])>x)//路程太远（超过x）
                {
                    continue;//尝试下一个方向
                }
                merge((i-1)*m+j,(xx-1)*m+yy);//连通块(前面提到)
            }
        }
    }
    for(int i=1;i<cnt;i++)//综合前面的并查集连通块，开始判断是否给定点都连通
    {
        if(dfs(a[i])!=dfs(a[i+1]))//如果有给定点无法连通
        {
            return false;//直接返回假，提前结束函数
        }
    }
    return true;//到这里表明给定点都能连通,返回真
}
void erfen()//二分
{
    l=-1,r=maxn+1;
    int mid;
//使用l和r作为边界
    while(l+1<r)//只要l不越界
    {
        mid=(l+r+1)/2;//求出中间值
        if(bfs())//这里的判断函数就是前面提到的bfs
        {
            l=mid;//判断函数返回真,l更新为mid
        }
        else 
        {
            r=mid-1;//判断函数返回假,r更新为mid-1
        }
        //就这样逐渐夹逼,最终得出结果
    }
}
int main()//主函数
{
    scanf("%d%d",&n,&m);//输入数据
    for(int i=1;i<=n;i++)//双层循环输入
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&d[i][j]);//输入海拔
            maxn=max(maxn,d[i][j]);//不断记录最高海拔值
        }
    }
    for(int i=1;i<=n;i++)//双层循环输入
    {
        for(int j=1;j<=m;j++)
        {
            int p;//只能是0或1
            scanf("%d",&p);//读入是否为路标
            if(p==1)//如果是路标
            {
                a[++cnt]=(i-1)*m+j;//更新a数组，记录路标
            }
        }
    }
    erfen();//开始二分
    printf("%d",r);//r即为最后的D值
    return 0;//结束
}
```

看在我呕心沥血写出的题解上，路过不忘点个赞呗~~

[彩蛋](https://www.luogu.com.cn/blog/paiwyz314/)

---

## 作者：Eleven谦 (赞：18)

这道题给大家介绍三种做法（并查集也能做，但本蒟不会~~懒~~）

------------


### First

#### 算法：未知（不信你往下读）

同机房大佬在考试的时候想出来的神奇做法！！！

思路：对于每一个路标，求与之相连的四个格子与它的高度差中的最小值（边缘的不算）用tot来表示。然后从ans与tot中取较大值，也就是在所有路标对应的tot中取最大值。

什么？这是什么思路？能得分？答案是：这种思路实现出来，**90分！**（向所有绞尽脑计做出来还没有90分的同志表示致敬QAQ，我最开始深搜+二分才可怜的10分啊）

PS：据那位同学说，他是在看样例的时候发现的这个“规律”，想着反正打不出正解，能得多少算多少.......

### code1：
```cpp
#include <bits/stdc++.h>
using namespace std;
int m,n,a[501][501],lb[501][501],tot,ans; 
int main() {
	scanf("%d%d",&m,&n);
	for(register int i=1;i<=m;i++) {
		for(register int j=1;j<=n;j++) {
			scanf("%d",&a[i][j]);
		}
	}
	for(register int i=1;i<=m;i++) {
		for(register int j=1;j<=n;j++) {
			scanf("%d",&lb[i][j]);
		}
	}
	for(register int i=1;i<=m;i++) {
		for(register int j=1;j<=n;j++) {
			if(lb[i][j]==1) {
				tot=0x3f3f3f3f;
				if(a[i][j-1]!=0) tot=min(tot,abs(a[i][j-1]-a[i][j]));
				if(a[i-1][j]!=0) tot=min(tot,abs(a[i-1][j]-a[i][j]));
				if(a[i+1][j]!=0) tot=min(tot,abs(a[i+1][j]-a[i][j]));
				if(a[i][j+1]!=0) tot=min(tot,abs(a[i][j+1]-a[i][j]));
			}
			ans=max(ans,tot);
		}
	}
	printf("%d",ans);
	return 0;
}
```


------------

### Second

#### 算法：深搜DFS+二分

思路：

1、用lb数组专门存储路标的坐标，用u累计路标个数

2、二分（注意：一定是**从0开始枚举！**）每次枚举的就是mid值，然后从第一个路标开始深搜

3、深搜中，遇到一个点就用p数组标记为true

4、深搜完，判断所有路标是否都被标记为true。如果有false，那么当前mid就不符合题意，修改左端点=mid+1。否则，修改右端点=mid-1，并将当前mid值保存在ans中。最后输出ans即可

~~嗯，是中规中矩的思路了！个人认为，程序易懂qvq~~

### code2：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,ans,u;
long long l=1,r,a[505][505];
int dx[4]={0,0,-1,1};
int dy[4]={-1,1,0,0};
bool p[505][505]; 
struct node {
	int x,y;
}lb[250025];

inline void dfs(int x,int y,int kk) {
	if(p[x][y]) return ;
	p[x][y]=true; //将当前点标记为访问过 
	for(register int i=0;i<4;i++) { //上下左右四个方向 
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(xx<1||xx>m||yy<1||yy>n||abs(a[xx][yy]-a[x][y])>kk) continue; //没有越界 
		dfs(xx,yy,kk);
	}
	return ;
}

int main() {
	scanf("%d%d",&m,&n);
	for(register int i=1;i<=m;i++) {
		for(register int j=1;j<=n;j++) {
			scanf("%lld",&a[i][j]);
			r=max(r,a[i][j]); //最高海拔即为枚举的右端点，很显然任意两点海拔值都不可能比最高海拔值大 
		}
	}
	for(register int i=1;i<=m;i++) {
		for(register int j=1;j<=n;j++) {
			int s;
			scanf("%d",&s);
			if(s==1) {
				lb[++u].x=i; //u累计路标总数；lb数组记录路标坐标 
				lb[u].y=j;
			}
		}
	}
	while(l<=r) { //二分枚举 
		int mid=(l+r)>>1;
		bool pk=true;
		memset(p,false,sizeof(p)); //记住每次枚举都要清零 
		dfs(lb[1].x,lb[1].y,mid); //从1号路标开始 
		for(register int i=1;i<=u;i++) { 
			if(p[lb[i].x][lb[i].y]==false) { //如果有路标没有被访问，即表示当前mid不符合题意，直接跳出 
				pk=false;
				break;
			}
		}
		if(pk==false) l=mid+1; //修改两个端点 
		else r=mid-1,ans=mid;
	}
	printf("%d",ans);
	return 0;
} 
```


------------

### Third
#### 算法：广搜BFS+二分

思路：和深搜的基本一致，除了多用了st、en标记第一个路标的坐标，剩下的就是套广搜板子了。直接看代码吧qvq

```cpp
#include <bits/stdc++.h>
using namespace std;
bool lb[505][505],pd=1,p[505][505];
int n,m,a[505][505],l,r,mid,ans,st,en,tp; 
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};

inline bool bfs() { //直接套广搜板子 
    queue <int> x, y; 
    int sum=1;
    x.push(st);
	y.push(en);
    p[st][en]=1;
    while(!x.empty ()) {
        int xx=x.front(),yy=y.front();
        if(sum==tp) return 1; //所有路标都被包含了就可以返回true了 
        x.pop();
		y.pop();
        for(register int i=0;i<4;i++) {
            int xxx=xx+dx[i];
			int yyy=yy+dy[i];
            if(xxx<1||xxx>n||yyy<1||yyy>m||p[xxx][yyy]||abs(a[xxx][yyy]-a[xx][yy])>mid) continue;
            if(lb[xxx][yyy]==1) sum++; //统计覆盖到的路标 
            x.push(xxx); //入队 
			y.push(yyy);
            p[xxx][yyy]=1;
        }
    }
    return 0;
}

int main () {
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;i++) {
        for(register int j=1;j<=m;j++) {
            scanf("%d",&a[i][j]);
            r=max(r,a[i][j]);
        }
    }
    for(register int i=1;i<=n;i++) {
        for(register int j=1;j<=m;j++) {
            scanf("%d",&lb[i][j]); 
            if(lb[i][j]==1) tp++;
            if(pd==1&&lb[i][j]==1) { //标记第一个路标 
                st=i;
				en=j;
				pd=0;
            }
        } 
    }
    while(l<=r) {
        mid=(l+r)>>1;
        memset(p,0,sizeof p); 
        if(bfs()==true) {
        	r=mid-1;
        	ans=mid;
		}
        else l=mid+1;
    } 
    printf("%d",ans); 
    return 0;
}
```



------------
总结一下:

1、深搜和广搜的板子是肯定要背住的，遇到就直接套

2、二分要注意枚举的边界，这样可以节省很多时间耗费

PS：也许会有很多人说第一种做法90分是因为数据水，这确实是一个因素。但是在考试或者比赛时，谁也不知道数据是什么样的，要是能用这样简单的程序得高分，何乐不为？所以，运气也是实力的一部分（我就没发现这种做法，再次膜拜同机房大佬Orz）

哈哈，扯远了。那那那那就希望这篇题解对您有些许的帮助吧QVQ~~

---

## 作者：刘锦惠233 (赞：9)

很典型的二分答案+BFS 二分找最小值D，然后在check里跑一遍BFS,如果能到达所有的路标，就返回true 具体见代码嗯

///分割线////

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#define maxn 505
using namespace std;
int n,m,maze[maxn][maxn],cnt,kk[maxn][maxn],startx,starty;
bool vis[maxn][maxn];
struct node{
	int x,y;
}a[maxn][maxn];
const int dx[4]={1,-1,0,0};
const int dy[4]={0,0,1,-1};

//手动取绝对值
int abss(int a,int b)
{
	if(a>b) return a-b;
	else return b-a;
}

//BFS
bool check(int s)
{
	queue<node> q;
	memset(vis,false,sizeof(vis));//一定一定要初始化！
	vis[startx][starty]=true;
	q.push(a[startx][starty]);
	int sum=1;//第一个点已经走过了
	while(!q.empty())
	{
		node cur=q.front();
		q.pop();
        
        //枚举四个方向
		for(int k=0;k<4;k++)
		{
			int x1=cur.x+dx[k];
			int y1=cur.y+dy[k];
			if(x1<1||x1>m||y1<1||y1>n||vis[x1][y1]||abss(maze[x1][y1],maze[cur.x][cur.y])>s) continue;
            
            //如果合法
			vis[x1][y1]=true;
			sum+=kk[x1][y1];//统计到达的路标数
			q.push(a[x1][y1]);
            
            //如果走到了所用的路标
			if(sum==cnt) return true;
            
		}
	}
    //没戏了不行的
	return false;
}

int main()
{
	scanf("%d%d",&m,&n);
	int low=0,high=0,mid,ans;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&maze[i][j]);
			a[i][j].x=i;
			a[i][j].y=j;
			high=max(high,maze[i][j]);
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&kk[i][j]);
			//统计路标数
            if(kk[i][j])
			{
				cnt++;
                
                //找起始路标
				if(cnt==1)
				{
					startx=i;
					starty=j;
				}
			}
		}
	}
    
    //二分
	while(low<=high)
	{
		mid=(low+high)/2;
		if(check(mid))
		{
			ans=mid;
			high=mid-1;
		}
		else low=mid+1;
	}
	printf("%d",ans);
    return 0；
}
```

---

## 作者：HOOCCOOH (赞：6)

从任意一个路标开始，做类dijkstra算法。

初始dis[]=0

dis[]记录到达该点的最小跨度，把加变成取max

每次确定路标dis的时候，ans=max(ans,dis[cur])，所有路标都访问到即得到ans

（其实会发现这就是prim）

下面是代码片段

```cpp

struct iT
{
    int to, w;
    bool operator<(const iT &r) const {return w > r.w;}
}ss[M], *sp = ss;
int dis[N];
int iDijk(int ibeg)
{
    memset(dis, 0xFF, sizeof dis);
    int ret = 0, cur = 0;
    *sp++ = (iT){ibeg, 0};
    do
    {
        iT c = *ss;
        pop_heap(ss, sp--);
        if(dis[c.to] != -1)
            continue;
        dis[c.to] = c.w;
        if(bpt[c.to])
        {
            ret = max(ret, c.w);
            if(++cur == cpt)
                break;
        }
        for(iE *p = arrto[c.to]; p; p = p->next)
            if(dis[p->to] == -1)
            {
                *sp++ = (iT){p->to, max(c.w, p->w)};
                push_heap(ss, sp);
            }
    }
    while(ss != sp);
    return ret;
}

```

---

## 作者：_StarBird_ (赞：6)

~~您正在收看的是蒟蒻jch的题解~~

语言：c++

在[博客园](https://www.luogu.com.cn/blog/jch2008/solution-p2658)中食用更佳

[题目传送门](https://www.luogu.com.cn/problem/P2658)

作为一道绿题，这题需要用到搜索（~~冰茶姬~~并查集）+二分（据说甚至dij也能跑），可以说是把PJ的大部分有难度的算法涵盖了（除了dp等）~~尽职尽责~~

看完这道题，思路还是比较显然的。答案满足单调性，即如果难度系数D是可行的，那么比D大的难度系数可行；同理，如果难度系数D不可行，那么比D小的难度系数也都不可行。且验证十分容易，暴搜即可，因此容易想到二分解法，且正解也已呼之欲出。

bfs（dfs）就不多说了，求出能联通多少路标即可。但其实这题并查集也是可行的，即对于每个难度系数D，若两点间高度不大于D，则将它们合并，最后判断一下所有要求连接的点之间是否联通即可。

~~不过我写的还是bfs，不过是纯手写队列，珍惜生命，远离STL~~

~~导播，上代码~~
### code:
```cpp
#include<bits/stdc++.h>//万能头 
#define MAXN 250010
#define maxn 510
#define N 20
#define INF 1000000000
using namespace std;
int n,m;
struct edge//对于一个点，存下它的横坐标和纵坐标 
{
    int x,y;
}s,q[MAXN];//bfs的队列 
int front,rear;
int sum,dx[N]={0,0,1,0,-1},dy[N]={0,1,0,-1,0};//提前做好关于遍历的准备工作，方便维护 
int mp[maxn][maxn];//存图 
bool flag[maxn][maxn];//存是否为标记 
//手写队列模板 
void push(edge x)//入队 
{
    q[++rear]=x;
    q[rear]=x;
    return;
}
void pop()//出队 
{
    ++front;
    return;
}
bool empty()//判空
{
    if (front==rear) return 1;
    return 0;
}
int bfs(int d)//bfs全过程 
{
    bool vis[maxn][maxn];
    int tot=0;
    memset(vis,0,sizeof(vis));//初始化 
    front=0;
	rear=0;
    push(s);//将起点插入队列中 
    vis[s.x][s.y]=1;
    edge nxt;
    while(!empty())//bfs模板 
    {
        pop();//将队首弹出 
        if (flag[q[front].x][q[front].y]) ++tot;//如果走到的点是一个路标，将互通的路标+1 
        for(int w=1;w<=4;++w)//枚举4个方向 
        {
            int xx=q[front].x+dx[w],yy=q[front].y+dy[w];
            if (!vis[xx][yy] && xx>=1 && xx<=n && yy>=1 && yy<=m && abs(mp[q[front].x][q[front].y]-mp[xx][yy])<=d)//在图内且未被访问过且符合难度系数的要求 
            {
                vis[xx][yy]=1;
                nxt.x=xx;
                nxt.y=yy;
                push(nxt);//将其放入队列 
            }
        }
    }
    return tot;//把能走到的路标数返回 
}
bool check(int d)
{
    if (bfs(d)<sum) return 0;//简单判断 
    return 1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j) scanf("%d",&mp[i][j]);
    sum=0;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        {
            int mark;
            scanf("%d",&mark);
            flag[i][j]=(bool)mark;
            if (mark) {++sum;s.x=i;s.y=j;}//随便取一个1的点作为路标 
        }
    int l=0,r=INF,ans;//二分，最多的难度系数为10^9（INF） 
    while(l<=r)
    {
        int mid=(l+r)/2;
        if (check(mid)) ans=mid,r=mid-1;//如果可行就记录答案，向更优方向搜寻 
        else l=mid+1;//否则向更劣方向搜寻 
    }
    printf("%d\n",ans);//输出答案 
    return 0;//华丽结束 
}
```
切勿复制！

以上，这题挺不错的

### 后记
前面写过几篇题解，都很长

但感觉，都不是自己的东西呢……

这篇题解稍微穴树了些

qwq

---

## 作者：wangxuye (赞：4)

没有DFS的算法，那我来写一个

很明显，难度D满足单调递增（即难度D越大，所能都到达的单元格一定越大），所以难度D可以用二分来枚举

难度D有了，剩下的就是搜索了。从一个路标处出发，如果能在海拔差不超过D的情况下全部遍历到，那么就在小的区间里找（即right=mid），否则在大的区间里找（即left=mid）

下面讲一个二分的小技巧

选区间的时候要选半开半闭的区间，这样做的时候就不用再去想+1或-1的问题了，最后只要取闭区间的那个值就行了

下面贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[510][510];
bool yes[510][510];
struct aa
{
	int x,y;
} code[250010];                  //路标坐标
int m,n;

const int dx[4]={1,-1,0,0};
const int dy[4]={0,0,1,-1};
void dfs(int x,int y,int mid)
{
	if(yes[x][y]) return ;
	yes[x][y]=true;
	for(int i=0;i<4;i++)
	{
		int xx=x+dx[i],yy=y+dy[i];
		if(0<xx&&xx<=m&&0<yy&&yy<=n&&abs(a[xx][yy]-a[x][y])<=mid) dfs(xx,yy,mid);
	}
	return ;
}

int main()
{
	int maxn=0;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[i][j]);
			maxn=max(maxn,a[i][j]);
		}
	int count=0;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			int b;
			scanf("%d",&b);
			if(b==1)
			{
				count++;
				code[count].x=i;
				code[count].y=j;         //记录路标坐标
			}
		}
	int left=-1,right=maxn+10;           //左开右闭
	for(;left+1<right;)                  //二分技巧
	{
		int mid=(left+right)/2;
		memset(yes,false,sizeof(yes));
		dfs(code[1].x,code[1].y,mid);    //DFS
		bool flag=true;
		for(int i=1;i<=count;i++)
			if(!yes[code[i].x][code[i].y])
			{
				flag=false;
				break;
			}
		if(!flag) left=mid;
		else right=mid;                  //二分技巧
	}
	printf("%d\n",right);
	return 0;
}
```

---

## 作者：北筱有梦 (赞：4)

嗨 大家好，本juruo来发题解了
这是我第一次发，希望大家多多包含


# first 好多人用了，~~病茶几~~说是和奶酪有些类似
其实不就是个普普通通的bfs搜索嘛！。我醉了～


题解，走起

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <queue>
#include <cmath>
#include <cstring>
using namespace std;
#define N 505
int n,m,shuliang,saidao[N][N],lubiao[N][N],vis[N][N],sx,sy,l,r,mid,ans,loc[5][2]={{0,0},{1,0},{-1,0},{0,1},{0,-1}};//shuliang需要到达的点数，saidao 赛道高度，lubiao——1，vis是否访问过，不走冤枉路，sx起始点f横坐标，sy起始点纵坐标，l二分左端点，r二分右端点，ans结果，loc上下左右四个方向
bool flag=true;//用于判断ans是否可以
bool bfs()//非手写队列，不喜，勿喷
{
    queue<int>x,y;//x横坐标队列，y纵坐标队列，当然，structs也不是不行。
    int now=1;//从这个点出发，本来就应该经过了一个
    x.push(sx);
    y.push(sy);//入队
    vis[sx][sy]=1;
    while(!x.empty())
    {
        int xx=x.front(),yy=y.front();
        if(now==shuliang)
            return 1;//数量够了，就可以返回了
        x.pop();
        y.pop();//提出第一个
        for(int i=1;i<=4;i++)
        {
            int xxx=xx+loc[i][0],yyy=yy+loc[i][1];//下一个点
            if(xxx<=0||xxx>n||yyy<=0||yyy>m||vis[xxx][yyy]==1)
                continue;//防止出界
            int top=abs(saidao[xx][yy]-saidao[xxx][yyy]);//计算难度系数
            if(top>mid)
                continue;//超过了ans 这个点不可以，跳过
            x.push(xxx);
            y.push(yyy);
            if(lubiao[xxx][yyy])
                now++;//记录走过的坐标
            vis[xxx][yyy]=1;//标记
        }
    }
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&saidao[i][j]);
            r=max(r,saidao[i][j]);//二分用到，最高点二分的右端点
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&lubiao[i][j]);
            if(lubiao[i][j])
                shuliang++;//记录路标1数量
            if(flag&&lubiao[i][j])
            {
                sx=i;
                sy=j;
                flag=false;
            }//寻找出发点
        }
    while(l<=r)//二分答案
    {
        mid=(l+r)/2;
        memset(vis,0,sizeof(vis));//清空数组，别忘了，卡了不少时间
        if(bfs())
        {
            r=mid-1;
            ans=mid;
        }
        else
        {
            l=mid+1;
        }//正常二分答案，找出最优解
    }
    printf("%d",ans);//输出
    return 0;
}
//完美的题解

```
并查集的等本人搞懂在说

---

## 作者：Cult_style (赞：3)

# 二分+BFS
#### 思路：从任意一个路标开始BFS，如果选择任意一个点，有时会比从一个路标开始的难度系数打，如：
```
3 3
1 1 1
1 2 1
1 1 1
0 0 0
0 1 0
0 0 0
```
- 如果选择非路标的点，难度系数为$1$，而选择路标的难度系数为$0$


------------


- 我们BFS的目的是从任意路标走到所有目标，不一定要最短路径，而是要让难度系数$≤$$k$的情况下，（$k$是我们要用二分来求的数）走完所有路标。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
};
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int h[4]={0,0,1,-1};
int s[4]={1,-1,0,0};
int vis[505][505];
int n,m;
int mp[505][505];
int a[505][505];
queue<node>q;
bool check(int x,int y,int i,int k){
	if(x<1||x>n) return false;
	if(y<1||y>m) return false;
	if(vis[x][y]>0) return false;
	if(abs(a[x-h[i]][y-s[i]]-a[x][y])>k) return false; 
	return true; 
}
bool bfs(int x,int y,int k){
	q.push((node){x,y});
	vis[x][y]=1;
	while(q.size()>0){
		int xx=q.front().x;
		int yy=q.front().y;
		q.pop();
		for(int i=0;i<4;i++){
			int xxx=xx+h[i];
			int yyy=yy+s[i];
			if(check(xxx,yyy,i,k)){
				q.push((node){xxx,yyy});
				vis[xxx][yyy]=vis[xx][yy]+1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]==1)
				if(vis[i][j]==0) return false;
		}
	}
	return true;
}
int aa,bb;
int ans;
int maxn;
void find(){
	int l=-1,r=maxn+1;
	while(l+1<r){
		int mid=l+(r-l)/2;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++)
				vis[i][j]=0;
		}
		if(bfs(aa,bb,mid)){
			ans=mid;
			r=mid;
		}
		else l=mid;
	}
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j]=read();
			if(a[i][j]>maxn) maxn=a[i][j];
		}
			
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			mp[i][j]=read();
			if(mp[i][j]==1){
				aa=i;
				bb=j;
			}
		}
	}
	find();
	printf("%d",ans);
	
	return 0;
} 
```


---

## 作者：yuzhechuan (赞：2)

并查集的思路已经有人讲过了，我这里提供几个并查集方法的（常数）优化

---

1. 路径压缩&按秩合并

```cpp
int getf(int x){
	if(f[x]==x) return x;
	return f[x]=getf(f[x]);
}
void unite(int x,int y){
    int fx=getf(x),fy=getf(y);
    if(fx==fy) return;
    if(rk[fx]<rk[fy]) f[fx]=fy;
    else f[fy]=fx;
    if(rk[fx]==rk[fy]) rk[fx]++;
}
```
路径压缩应该很多人都加了吧。。。

2. 四个方向（上下左右）->两个方向（下右）

边是双向的，而且是网格图，因此是有个层次性的，无需重复地双向都unite

3. 将每个路标的fa与第一个路标的fa比较

可以节约一半的getf

---

另外，感觉自己的码风还挺好理解的。。。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(int &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f) x=-x;return x;
}
inline void write(int x){
	if(x<0) putchar('-'),write(-x);
	else{if(x>9) write(x/10);putchar('0'+x%10);}
}
const int N=505;
int n,m,f[N*N],ans,rk[N*N],a[N][N],l,r;
vector<int> tag;
inline int hash(int x,int y){
	return (x-1)*m+y;
}
inline int getf(int x){
	if(f[x]==x) return x;
	return f[x]=getf(f[x]); //路径压缩
}
inline void unite(int x,int y){
    int fx=getf(x),fy=getf(y);
    if(fx==fy) return;
    if(rk[fx]<rk[fy]) f[fx]=fy; //按秩合并
    else f[fy]=fx;
    if(rk[fx]==rk[fy]) rk[fx]++;
}
inline bool check(int k){
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			f[hash(i,j)]=hash(i,j),rk[hash(i,j)]=1; //并查集初始化
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(abs(a[i][j]-a[i+1][j])<=k&&i+1<=n) //向下unite(hash(i,j),hash(i+1,j));
			if(abs(a[i][j]-a[i][j+1])<=k&&j+1<=m) //向右 unite(hash(i,j),hash(i,j+1));
		}
	int fa=getf(tag[0]); //先得到第一个fa
	for(int i=1;i<tag.size();i++) if(getf(tag[i])!=fa) //后面的与第一个比较
		return 0;
	return 1;
}
signed main(){
	read(n);read(m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			read(a[i][j]);
			r=max(r,a[i][j]);
		}
	for(int i=1;i<=n;i++)
		for(int j=1,x;j<=m;j++){
			read(x);
			if(x) tag.push_back(hash(i,j)); //我用vector存路标
		}
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	}
	write(ans);
}
```

---

另外，我这份代码是用c++交的，c++11以上会ce

---

## 作者：_ZZH (赞：1)

~~二维并查集了解一下~~

     本来不想发题解的，但是我觉得这个玩意还是有点借鉴意义的，说不定之后瞎翻能提醒自己这种思路，或者那个小伙伴感兴趣的可以看看。

这道题看一眼就突发奇想：二维并查集如何？

我们考虑类似于克鲁斯卡尔算法的思路 ，相当于用一个生成树连接所有路标。答案只与最大边长相关。

我们用边表存一下两点间的连边，以边权从小到大排序，然后运用类似于克鲁斯卡尔的写法。每加一条边判断所有路标是否连通，如果是，新加的边就是答案。

题目的关键就是运用二维的并查集：

记f[i][j]表示(i,j)的父节点，则f[i][j]有两部分：横坐标与纵坐标。这启发我们运用结构体来实现查找祖先。

```cpp
cym2 find(cym2 now)
{
	if(f[now.x][now.y].x==now.x&&f[now.x][now.y].y==now.y)
	return now;
	cym2 _ans=find(f[now.x][now.y]);
	return f[now.x][now.y]=_ans;
}
```

完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int n,m,a[600][600],total,point,ans,A;
struct cym{
	int x1,y1,x2,y2,len;
}e[400010];
struct cym2{
	int x,y;
}pos[400010],f[600][600];
void add(int x1,int y1,int x2,int y2)
{
	e[++total].x1=x1;
	e[total].y1=y1;
	e[total].x2=x2;
	e[total].y2=y2;
	e[total].len=abs(a[x2][y2]-a[x1][y1]);
}
cym2 find(cym2 now)
{
	if(f[now.x][now.y].x==now.x&&f[now.x][now.y].y==now.y)
	return now;
	cym2 _ans=find(f[now.x][now.y]);
	return f[now.x][now.y]=_ans;
}
int cmp(const cym &x,const cym &y)
{
	return x.len<y.len;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		scanf("%d",&a[i][j]);
		f[i][j].x=i;
		f[i][j].y=j;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
	  if(i!=n)
	  add(i,j,i+1,j);
	  if(j!=m)
	  add(i,j,i,j+1);		
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		int x;
		scanf("%d",&x);
		if(x==1)
		{
			pos[++point].x=i;
			pos[point].y=j;
		}
	}
	sort(e+1,e+1+total,cmp);
	for(int i=1;i<=total;i++)
	{
		cym2 xx,yy;
		xx.x=e[i].x1;
		xx.y=e[i].y1;
		yy.x=e[i].x2;
		yy.y=e[i].y2;
		cym2 f1=find(xx);
		cym2 f2=find(yy);
		if(f1.x==f2.x&&f1.y==f2.y)continue;
		f[f1.x][f1.y].x=f2.x;
		f[f1.x][f1.y].y=f2.y;
		cym2 _x=find(pos[1]);
		int judge=1,x=_x.x,y=_x.y;
		for(int j=2;j<=point;j++)
		{
			cym2 X=find(pos[j]);
			if(X.x!=x||X.y!=y)
			{
				judge=0;
				break;
			}		
		}
		if(judge==1)
		{
			A=1;
			printf("%d",e[i].len);
			break;
		}
	}//第二个点应该比较特殊 没输出，很早之前的代码了，我也懒得想了，读者可以多思考一下（甩锅 
	if(!A)cout<<1;//这是个特判，谜一般的过了……
}
```

---

## 作者：Ally_unstoppable (赞：1)

说一种二分+BFS的方法

先把答案二分出来，然后再用BFS判断该答案是否成立

麻烦的就是每一次都必须进行一个类似"回溯"的操作（即清空数组），但是貌似数据蒻可以AC的


```cpp
#include<bits/stdtr1c++.h>
using namespace std;
bool hashhh[501][501];
int mapl[501][501],flag[501][501],flag2[501][501];
int o,z;
int m,n;
struct pp{
    int x,y;
}que[250001],p,f;
bool check(int q)
{
    int k = 1,la = 1;   //两个指针，手打queue
    flag[o][z] = false;
    que[1].x = o, que[1].y = z;
    int x1, y1;
    hashhh[o][z] = false;
    while(k <= la)
    {
        x1 = que[k].x,y1 = que[k].y;
        if(x1 < m && hashhh[x1+1][y1] && (abs(mapl[x1+1][y1] - mapl[x1][y1]) <= q))
        {
            if(flag[x1+1][y1])    flag[x1+1][y1] = false;
            hashhh[x1+1][y1] = false;
            que[++la].x = x1+1;
            que[ la ].y = y1;
        }
        if(x1 > 1 && hashhh[x1-1][y1] && (abs(mapl[x1-1][y1] - mapl[x1][y1]) <= q))
        {
            if(flag[x1-1][y1])    flag[x1-1][y1] = false;
            hashhh[x1-1][y1] = false;
            que[++la].x = x1-1;
            que[ la ].y = y1;
        }
        if(y1 < n && hashhh[ x1 ][y1 + 1] && (abs(mapl[x1][y1 + 1] - mapl[x1][y1]) <= q))
        {
            if(flag[x1][y1+1])    flag[x1][y1+1] = false;
            hashhh[x1][y1+1] = false;
            que[++la].x = x1;
            que[ la ].y = y1+1;
        }
        if(y1 > 1 && hashhh[x1][y1 - 1] &&( abs(mapl[x1][y1 - 1] - mapl[x1][y1]) <= q))
        {
            if(flag[x1][y1 - 1])    flag[x1][y1 - 1] = false;
            hashhh[x1][y1-1] = false;
            que[++la].x = x1;
            que[ la ].y = y1 - 1;
        }
        k ++;
    }
```
/\*
```cpp
    for(int i = 1 ; i <= m; i ++)
    {
        for(int j = 1; j <= n; j++)
        printf("%d ",hashhh[i][j]);
        printf("\n");
    }
    for(int i = 1 ; i <= m; i ++)
    {
        for(int j = 1; j <= n; j++)
        printf("%d ",flag[i][j]);
        printf("\n");
    }*/
    for(int i = 1 ; i <= m; i ++)
        for(int j = 1; j <= n; j++)
        if(flag[i][j]>=1)    return false;
    return true;
}
void does()//清空数组
{
    memset(hashhh,true ,sizeof(hashhh));
    for(int i = 1 ; i <= m; i ++)
        for(int j = 1; j <= n; j++)
        flag[i][j] = flag2[i][j];
}
int main(){
    scanf("%d%d",&m,&n);
    int l = 0, r = 0;
    for(int i = 1; i <= m;i ++)
        for(int j = 1 ; j <= n; j ++){
            scanf("%d",&mapl[i][j]);
            r = max(r, mapl[i][j]);
        }
    for(int i = 1; i <= m;i ++)
        for(int j = 1 ; j <= n; j ++)
        {
        scanf("%d",&flag2[i][j]);
        if(flag2[i][j])
        o = i, z = j;
    }
    does();
    int mid = (l + r)>> 1;
    while(l + 3 <= r)//二分查找答案，这里为边界考虑方便，用了一点小技巧，即l和r保留3的空隙，最后枚举这3个
    {
        if(check(mid))    {
            r = mid;
        //    printf("%d\n OK",mid);
        }
        else{
            l = mid;
        //    printf("%d\n",mid);
        }
        mid = (l + r) >> 1;
        does();
    }
    for(int i = l; i <= r; i ++)
    {
        if(check(i))    
        {
            printf("%d\n",i);
            return 0;
        }
        does();
    }
}
```

---

## 作者：rainygame (赞：0)

一个很简单的思路是：对方格建图（边权为高度差的绝对值）之后，求一下路标之间的全源最短路（**注意是求最大值的最小值而不是和的最小值**），然后直接算出路标两两之间的最短路长度的最大值即为答案。

但是这样是 $O(n^2m^2\log nm)$ 的，难以接受。

但实际上，我们只需要跑从任意一个路标到其它路标的**单源最短路**即可，而答案即为选定起点到其它路标的最短路最大值。

正确性证明如下：

- 两个结点之间如果有比答案更短的最短路径，对答案不会造成影响。因为答案求得是所有最大值，而且已经有一个从某个结点出发的最大值了。就算其它的再小也不会影响最大值。

- 两个结点（设为 $d_1$、$d_2$）之间不会有比答案更长的最短路径，因为如果有更长的，那么显然有一条更短的路径从 $d_1$ 到出发点再到 $d_2$，不满足“最短路径”的限制，矛盾。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 250001
#define get(x, y) ((x-1)*m+y-1)

int n, m, ans, x, u, v, w;
int a[501][501];
int dis[MAXN];
vector<int> vec;
vector<pair<int, int>> e[MAXN];
bitset<MAXN> vis;

struct Node{
    int u, dis;
    bool operator<(Node b)const{
        return dis > b.dis;
    }
};
priority_queue<Node> pq;

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    for (int i(1); i<=n; ++i){
        for (int j(1); j<=m; ++j) cin >> a[i][j];
    }
    for (int i(1); i<=n; ++i){
        for (int j(1); j<=m; ++j){
            cin >> x;
            if (x) vec.push_back(get(i, j));
        }
    }

    for (int i(1); i<=n; ++i){
        for (int j(1); j<=m; ++j){
            if (i ^ 1) e[get(i, j)].push_back(make_pair(get(i-1, j), abs(a[i][j]-a[i-1][j])));
            if (i ^ n) e[get(i, j)].push_back(make_pair(get(i+1, j), abs(a[i][j]-a[i+1][j])));
            if (j ^ 1) e[get(i, j)].push_back(make_pair(get(i, j-1), abs(a[i][j]-a[i][j-1])));
            if (j ^ m) e[get(i, j)].push_back(make_pair(get(i, j+1), abs(a[i][j]-a[i][j+1])));
        }
    }

    pq.push({vec.front(), 0});
    memset(dis, 0x3f, sizeof(dis));
    dis[vec.front()] = 0;
    while (!pq.empty()){
        u = pq.top().u;
        pq.pop();
        if (vis.test(u)) continue;
        vis.set(u);

        for (auto i: e[u]){
            v = i.first;
            w = i.second;
            // cout << dis[0] << '\n';
            if (dis[v] > max(dis[u], w)){
                dis[v] = max(dis[u], w);
                pq.push({v, dis[v]});
            }
        }
    }

    for (auto i: vec) ans = max(ans, dis[i]);
    cout << ans;

    return 0;
}
```


---

## 作者：MajorB_ (赞：0)

二分答案裸题。以最高海拔为上界（或者最高海拔差为上界），0为下界开始二分，对于每一个mid=(l+r)/2，从某个路标处做一遍Floodfill，验证是否能够将所有路标全部覆盖。【蒟蒻表示傻傻的写DFS写了很久最后发现是BFS Orz】 如果能够覆盖则r=mid，否则l=mid+1。附代码

```cpp

while (l<r)
    {
        d = (l+r)/2;
        get = false;
        bfs();
        if (get) r = d;
        else l = d+1;
    }
    printf("%d",r);

```

---


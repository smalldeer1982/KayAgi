# 飞行员配对方案问题

## 题目背景

第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。

## 题目描述

一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。

## 说明/提示

**【数据范围与约定】**

- 对于 $100\%$ 的数据，保证 $1 \leq m \leq n < 100$，$1 \leq u \leq m < v \leq n$，同一组配对关系只会给出一次。

**【提示】**

- 请注意输入的第一行先读入 $m$，再读入 $n$。

## 样例 #1

### 输入

```
5 10
1 7
1 8
2 6
2 9
2 10
3 7
3 8
4 7
4 8
5 10
-1 -1
```

### 输出

```
4
1 7
2 9
3 8
5 10
```

# 题解

## 作者：Johnson_sky (赞：59)

网络流dinic算法，0ms过

**建图是关键！！！建图是关键！！！建图是关键！！！**

超级源点S与1~m连流量为1的边，m+1~n与超级汇点T连流量为1的边，所给的边，连流量为0x3f3f3f3f

直接dinic，判断边是否有流量，即判断反向边的权值是否不为0

代码如下：







```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define N 100010
using namespace std;
int n,m,S,T,tmp1,tmp2,tot;
int en=1,head[N],h[N],q[N],ans1[N],ans2[N];
struct Edge{
    int to,next,v;
}e[N];
bool b[N];
inline void insert(int u,int v,int f)
{
    e[++en].to=v;e[en].v=f;e[en].next=head[u];head[u]=en;
    e[++en].to=u;e[en].v=0;e[en].next=head[v];head[v]=en;
}
inline bool bfs()
{
    int f=0,t=0;
    memset(h,-1,sizeof(h));
    q[t++]=S;h[S]=0;
    while(f<t)
    {
        int now=q[f++];
        for(int i=head[now];i;i=e[i].next)
        {
            int v=e[i].to;
            if(h[v]==-1&&e[i].v)
            {
                h[v]=h[now]+1;
                q[t++]=v;
            }
        }
    }
    if(h[T]!=-1)return 1;
    return 0;
}
inline int dfs(int x,int f)
{
    if(x==T)return f;
    int w,used=0;
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(h[v]==h[x]+1&&e[i].v)
        {
            w=dfs(v,min(f-used,e[i].v));
            e[i].v-=w;
            e[i^1].v+=w;
            used+=w;
            if(used==f)return f;
        }
    }
    if(!used)h[x]=-1;
    return used;
}
void dinic()
{
    while(bfs())
        tot+=dfs(S,0x3f3f3f3f);
}
int main()
{
    scanf("%d %d",&m,&n);
    S=0,T=n+1;
    scanf("%d %d",&tmp1,&tmp2);
    do
    {
        insert(tmp1,tmp2,0x3f3f3f3f);
        scanf("%d %d",&tmp1,&tmp2);
    }while(tmp1!=-1&&tmp2!=-1);
    for(int i=1;i<=m;i++)insert(S,i,1);
    for(int i=m+1;i<=n;i++)insert(i,T,1);
    dinic();
    if(tot==0)
    {
        puts("No Solution!");
        return 0;
    }
    printf("%d\n",tot);
    for(int i=2;i<=en;i=i+2)
    {
        if(e[i].to!=S&&e[i^1].to!=S)
        if(e[i].to!=T&&e[i^1].to!=T)
        if(e[i^1].v!=0)
        {
            printf("%d %d\n",e[i^1].to,e[i].to);
        }
    }
    return 0;
}
```

---

## 作者：tcswuzb (赞：55)

匈牙利算法自带匹配方案

~~献给所有匈牙利算法党~~

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define D double
#define U unsigned
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐---------------------*/
ll n,m,ans;
ll to[N];
struct node{
    ll to,nex;
}e[N];
ll x,y,tot;
ll head[N];
bool vis[N];
void add(ll a,ll b)
{
    e[++tot].to=b;
    e[tot].nex=head[a];
    head[a]=tot;
}
bool find(ll x)
{
    ll xx;
    for(ll i=head[x];i;i=e[i].nex)
    {
        xx=e[i].to;
        if(!vis[xx])
        {
            vis[xx]=1;
            if(!to[xx]||find(to[xx]))
            {
                to[xx]=x;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    read(n);read(m);
    read(x);read(y);
    while(x!=-1&&y!=-1)
    {
        if(x<=n&&y<=m) add(x,y);
        read(x);read(y);
    }
    for(ll i=1;i<=n;i++)
    {
        memset(vis,0,sizeof(vis));
        if(find(i)) ans++;
    }
    cout<<ans<<endl;
    for(ll i=n+1;i<=m;i++)
    {
        if(to[i]) cout<<to[i]<<" "<<i<<endl;
    }
    return 0;
}
```

最后对应输出即可

---

## 作者：shadowice1984 (赞：46)

看了这么多题解，似乎没有手把手教你写网络流的题解

//对于一道新手向的题不应该是教如何写板子吗

就着这道题教一下板子写法好了

首先dinic是一个贪心的思想在里面，我们每次找源点到起点的一条最短路径

（指的是经过边数最小），（同时我们认为边权为0的边不存在）

然后路径上的流量限制统一减去这条路径中边权的最小值即可

发现这个贪心思想是有问题的，实际上这样会阻塞很多“重要”的边

导致贪心算法失效

但是如果可以回撤之前的选择，即让一条边少流一点，

那么贪心在这个意义上是成立的

这里涉及到反向边概念的应用，对每一条边来讲，

如果它向前流了X，那么如果它同时向后流Y

等效于向前流X-Y，通过这样的方式，即让一条边回流

我们就可以回撤之前的选择了

当然实际上我们对于每条边配置一条反向边来起到这个反流的效果

反向边初始权值为0，如果反向边对应的正向边减去流量，那么正向边的流量最多

反流正向边现在的流量，所以正向边减多少反向边加多少

那么我们用一个dfs就可以很方便的找出最小值

然而不是最短路啊

所以我们用bfs预处理一遍深度，每次只走深度差为1的点

如果发现d不动了有两种情况

1.真的没有路了

2.你的深度图过期了，因为你修改了这张图

所以更新一遍深度图，重新bfs，如果此时发现从源点已无法到达起点就结束算法

//下面是实现细节

1.反向边怎么搞？

答：回想邻接表工作的过程，发现连续add两条边的时候这两条边的编号是相邻的

所以用【异或上1】(・∀・(・∀・(・∀・\*)这个操作可以方便的找出一条边对应的

反向边编号

2.dfs怎么写？

dfs两个参数，当前点和当前路径中的最小值，每次向下d的时候最小值和出边取min

回溯的时候修改反向边权值和正向边权值

//以上是板子教程

对于这道题，它被称为**二分图最大匹配**，可以建模跑最大流

建图做法为 s向每一个外籍飞行员连限制为1的边

每一个外籍飞行员向可以匹配的英籍飞行员连限制为1的边

每一个英籍飞行员向t连一个限制为1的边

跑最大流即可，原图中每一个有流量的边对应一个匹配

利用这点可以输出方案

在dfs的时候每次维护到底哪一条边被启用即可

上代码~

```cpp
    #include<cstdio>
    #include<algorithm>
    #include<queue>
    using namespace std;
    struct data
    {
        int v;int nxt;int val;
    }edge[30010];int alist[110];int cnt=1;
    inline void add(int u,int v,int val)
    {
        edge[++cnt].v=v;edge[cnt].val=val;
        edge[cnt].nxt=alist[u];alist[u]=cnt;
        return;
    }
    int dep[110];bool book[110];
    int n;int m;int res;
    int matcha[110];//维护对应关系
    int matchb[110];
    int s;int t;queue<int> q;
    int dfs(int x,int lim)//dfs找增广路
    {
        if(x==t)return lim;
        int nxt=alist[x];
        while(nxt)
        {
            int v=edge[nxt].v;
            int val=edge[nxt].val;
            if(dep[v]==dep[x]+1&&val!=0)
            {
                int delta=dfs(v,min(val,lim));//递归求最小值
                if(delta!=0)
                {
                    edge[nxt].val-=delta;
                    edge[nxt^1].val+=delta;//异或修改反向边
                    if(x!=s&&v!=t)//维护对应关系
                    {
                        matcha[x]=v;
                        matchb[v]=x;
                    }
                    return delta;
                }
            }
            nxt=edge[nxt].nxt;
        }
        return 0;
    }
    void bfs()//bfs处理深度
    {
        for(int i=1;i<=n+2;i++)
        book[i]=false;
        dep[s]=1;book[s]=true;
        q.push(s);
        while(!q.empty())
        {
            int now=q.front();q.pop();
            int nxt=alist[now];
            while(nxt)
            {
                int v=edge[nxt].v;
                int val=edge[nxt].val;
                if(val!=0&&book[v]==false)
                {
                    dep[v]=dep[now]+1;
                    book[v]=true;
                    q.push(v);
                }
                nxt=edge[nxt].nxt;
            }
        }
        return;
    }
    int main()
    {
        scanf("%d%d",&m,&n);
        s=n+1;t=n+2;
        while(1)//建图
        {
            int u;int v;
            scanf("%d%d",&u,&v);
            if(u==-1&&v==-1)break;
            add(u,v,1);add(v,u,0);//注意一定要连续塞进去
        }
        for(int i=1;i<=m;i++)
        {
            add(s,i,1);add(i,s,0);
        }
        for(int i=m+1;i<=n;i++)
        {
            add(i,t,1);add(t,i,0);
        }
        bfs();//处理深度
        while(book[t])//当还有路径时
        {
            while(1)
            {
                int p=dfs(s,0x3f3f3f3f);
                if(p==0)break;else res+=p;//每次dfs失败后更新深度图
            }bfs();
        }
        printf("%d\n",res);//输出答案
        for(int i=1;i<=m;i++)//输出方案
        {
            if(i==matchb[matcha[i]])
            {
                printf("%d %d\n",i,matcha[i]);
            }
            else if(i==matcha[matchb[i]])
            {
                printf("%d %d\n",i,matchb[i]);
            }
        }return 0;//拜拜程序~
}
```

---

## 作者：Isprime (赞：20)

CSP2019爆零的萌新切掉的第一道网络流24题（雾）

## 题目分析

网络流24题中最简单一题

一看题目就知道是板子

~~其他巨佬都在说二分图最大匹配然而这题似乎EK很轻松AC~~

建一个源点 $s$ 和一个汇点 $t$

$s$ 到每一个外籍飞行员连一条流量为 $1$ 的边

每一个英国飞行员到 $t$ 连一条流量为 $1$ 的边

在按题目数据在英国飞行员和外籍飞行员之间连边

然后跑一遍EK，枚举每条反向边，如果流量大于零就输出

Code($30$ms/$804$KB)

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
const int MAXN = 102;
const int INF = 2147483647;
int n, m, s, t, maxflow;
int g[MAXN][MAXN];
int pre[MAXN];
bool vis[MAXN];
inline int bfs(int s,int t) {//BFS找增广路
	memset(pre, -1, sizeof(pre));
	memset(vis, 0, sizeof(vis));
	queue <int> q; 
	vis[s] = 1;
	q.push(s);
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		for(register int i = 0; i <= m + 1; ++i) {
			if(!vis[i] && g[u][i] > 0) {
				vis[i] = 1;
				pre[i] = u;
				if(i == t) return true;
				q.push(i);
			}
		}
	}
	return false;
}
inline int EK(int s,int t) {//EK网络最大流
	int u,v,d,maxflow = 0;
	while(bfs(s,t)) {
		maxflow ++;//这题流量一定是1，不用再去顺着增广路找一遍
		v = t;
		while(s != v) {
			u = pre[v];
        //正向边减流，反向边加流
			g[u][v] --;
			g[v][u] ++;
			v = u;
		} 
	}
	return maxflow;
}
signed main() {
	scanf("%d%d",&n,&m);
	s = 0, t = m + 1;
	for(register int i = 1; i <= m; ++i) i <= n ? g[s][i]++ : g[i][t] ++;//源点到外籍飞行员连边，英国飞行员到汇点连边
	int u,v;
	scanf("%d%d",&u,&v);
	while(u != -1) {
		g[u][v] = 1;
		scanf("%d%d",&u,&v);
	}//飞行员间连边
	maxflow = EK(s,t);//EK
	if(!maxflow) printf("No Solution!\n");
	else printf("%d\n", maxflow);
	for(register int i = 1; i <= n; ++i)//枚举反向边
		for(register int j = n + 1; j <= m; ++j)
			if(g[j][i] > 0) printf("%d %d\n", i, j);
	return 0;
}
```

---

## 作者：Siyuan (赞：12)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

## Description

> 题目链接：[Luogu 2756](https://www.luogu.org/problemnew/show/P2756)

英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的 $2$ 名飞行员，其中 $1$ 名是英国飞行员，另 $1$ 名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。皇家空军共有 $n$ 名飞行员，其中 $m$ 名为外籍飞行员。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。

数据范围：$1\le m\le m<100$

------

## Solution

由于每个飞行员只能被选择一次，所以我们可以直接想到**二分图最大匹配**，显然可以用**匈牙利算法**或**网络流**解决。

对于输出方案，匈牙利算法可以直接利用匹配数组，而网络流可以判断正向边是否有流量（即反向边的残量是否不为 $0$）。

**时间复杂度**：$O(n^2\sqrt n)$（二分图 $\texttt{Dinic}$）

------

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

const int N=205,M=2e4+5;
int n,m,tot=1,lnk[N],ter[M],nxt[M],val[M],dep[N],cnr[N];

void add(int u,int v,int w) {
    ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot,val[tot]=w;
}
void addedge(int u,int v,int w) {
    add(u,v,w),add(v,u,0);
}
int bfs(int s,int t) {
    memset(dep,0,sizeof(dep));
    memcpy(cnr,lnk,sizeof(lnk));
    std::queue<int> q;
    q.push(s),dep[s]=1;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=lnk[u];i;i=nxt[i]) {
            int v=ter[i];
            if(val[i]&&!dep[v]) dep[v]=dep[u]+1,q.push(v);
        }
    }
    return dep[t];
}
int dfs(int u,int t,int flow) {
    if(u==t) return flow;
    int ret=0;
    for(int i=cnr[u];i&&ret<flow;i=nxt[i]) {
        cnr[u]=i;
        int v=ter[i];
        if(val[i]&&dep[v]==dep[u]+1) {
            int x=dfs(v,t,std::min(val[i],flow-ret));
            if(x) val[i]-=x,val[i^1]+=x,ret+=x;
        }
    }
    if(ret<flow) dep[u]=-1;
    return ret;
}
int dinic(int s,int t) {
    int ans=0;
    while(bfs(s,t)) {
        int x;
        while((x=dfs(s,t,1<<30))) ans+=x;
    }
    return ans;
}
int main() {
    scanf("%d%d",&n,&m);
    int u,v;
    while(scanf("%d%d",&u,&v)&&~u&&~v) addedge(u,v,1);
    int s=0,t=n+m+1;
    for(int i=1;i<=n;++i) addedge(s,i,1);
    for(int i=n+1;i<=m;++i) addedge(i,t,1);
    int ans=dinic(s,t);
    if(!ans) return puts("No Solution!");
    printf("%d\n",ans);
    for(int u=1;u<=n;++u) {
        for(int i=lnk[u];i;i=nxt[i]) {
            int v=ter[i];
            if(v!=s&&val[i]==0&&val[i^1]==1) printf("%d %d\n",u,v);
        }
    }
    return 0;
}
```



---

## 作者：yyy2015c01 (赞：12)

#来自网络

【问题分析】


二分图最大匹配问题。


【建模方法】


在二分图的基础上增加源S和汇T。

1. S向X集合中每个顶点连一条容量为1的有向边。

2. Y集合中每个顶点向T连一条容量为1的有向边。

3. XY集合之间的边都设为从A集合中的点到B集合之中的点，容量为1的有向边。


求网络最大流，流量就是匹配数，所有满流边是一组可行解。


【建模分析】


基本的二分图最大匹配，可以直接用匈牙利算法或Hopcroft\_Karp算法解决，更一般的方法是网络最大流。


---

## 作者：BEqueN (赞：9)

### 前言：
赤裸裸的最大匹配
匈牙利也可以过吧
不过毕竟是网络流24题
用网络流比较合适

看大佬都是用Dinic过的

本蒟蒻就放一个(Ford-Fulkerson)基础算法

### 解题思路：
首先建一个源点和一个汇点，**源点与外籍飞行员间建立一条有向边(外籍飞行员方向)，汇点与英籍飞行员建立一条有向边(英籍飞行员方向)**。

所有边的容量为1，也就是说流量最多为1。

然后求最大流。

**还有，注意一下，我的n和m是反着读(习惯了)**

### 源程序：
```cpp
#include<cstdio>
#include<iostream> 
using namespace std;
int sum,b[102],f[102][102];
int a[102][102],u[102],v[102],ans,n,m,x,y;
bool find(int k)//找增广路
{
	if (k==m+1) return 1;
    //如果已经找到就退出(废话)
	for (int i=0;i<=m+1;i++)
	  if (b[i]==-1&&((f[k][i]==0&&a[k][i])||f[i][k])) 
      //b[i]==-1说明没人与他匹配
      //f[k][i]==0也就是说可以与他匹配
      //a[k][i]是匹配前提，要能配对才可以"合作"
	  //f[i][k]是逆向边，如果是逆向边而且已经反向"流"了
      //就可以合作
      {
	  	 b[i]=k;
         //记录前驱
	  	 if (find(i)) return 1;
         //递归判断是否是增广路
	  }
	return 0;
}
void update()//更新
{
	int l=m+1;//从后往前去边
	while (l)
	{
		if (a[b[l]][l]) f[b[l]][l]++;
        //流量+1
		if (a[l][b[l]]) f[l][b[l]]--;
        //正向流和逆向流抵消
		l=b[l];
        //继续往前搜
	}
	ans++;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	 a[0][i]=1;
    //源点连外籍飞行员
	for (int j=n+1;j<=m+1;j++)
	 a[j][m+1]=1;
    //英籍飞行员连汇点
	while (x!=-1&&y!=-1)
	 scanf("%d%d",&x,&y),a[x][y]=1;
    //读入，建图(边)
	for (int i=0;i<=m+1;i++) b[i]=-1;
	b[0]=0;
    //初始化
	while (find(0))//找增广路
	{
		update();
		for (int i=1;i<=m+1;i++) b[i]=-1;
	}
	if (!ans) 
    ｛
    	puts("No Solution!");
      	return 0;
     }//如果没有(其实不打也AC，只是打了严谨一些)就输出No Solution!
	printf("%d\n",ans);
    //输出匹配总数
    for (int i=1;i<=n;i++)
    {
        for (int j=n+1;j<=m;j++)
            if (f[i][j]) {printf("%d %d\n",i,j);break;}
        //枚举找每一对匹配的飞行员
    }
}
```
我很认真了  

---

## 作者：千年知乎_天才 (赞：8)

题目名称：飞行员配对方案问题

来源：网络流24题
# 链接
## 博客链接
- [博客园](https://www.cnblogs.com/Alvin-Tree/p/11593308.html)
- [CSDN](https://blog.csdn.net/weixin_43890363/article/details/101448496)
- [洛谷博客](https://www.luogu.org/blog/131abc155-7341-6424/solution-p2756)
- [洛谷题解](https://www.luogu.org/problemnew/solution/P2756)

## 题目链接
- LibreOJ(6000) [题目](https://loj.ac/problem/6000) [提交](https://loj.ac/problem/6000#submit_code) [状态](https://loj.ac/submissions?problem_id=6000) [讨论](https://loj.ac/discussion/problem/6000)
- 洛谷(P2756) [题目](https://www.luogu.org/problem/P2756) [提交](https://www.luogu.org/problem/P2756#submit) [状态](https://www.luogu.org/record/list?pid=P2756) [讨论](https://www.luogu.org/discuss/lists?forumname=P2756)

# 题目大意
有$n$个英国空军和$m$个外籍空军，一架飞机需要一对互相配合的英国空军和外籍空军配合。给出配合情况，求出最多能发动多少飞机。
# 提示
注意题目来源！
# 题解
这是一道最大流裸题。

从原点开始，向每个外籍飞行员连边，容量为$1$。（因为每个外籍飞行员只能被指派一次）

如果外籍飞行员$i$与英国飞行员$j$配合，那么就从$i$向$j$连边，容量为$1$。（每个外籍飞行员与每个英国飞行员最多配合一次）

从每个英国飞行员向汇点连边，容量为$1$。（一对飞行员相互配合只能发动一架飞机）

拿样例说话，如图所示
![《飞行员配对方案问题》网络图](https://cdn.luogu.com.cn/upload/image_hosting/nlrcjsyc.png)
其中$F$表示外籍飞行员，$E$表示英国飞行员。

然后跑一遍$Dinic$就得到答案了。
```cpp
//C++
#include<bits/locale_facets.h>
#include<stdio.h>
#include<memory.h>
#include<queue>
#define downt(i,n) for(int i=n;i;i=back[i])
#define forto(name,i,d,u) for(name i=d;i<=u;i++)
#define foruntil(name,i,d,u) for(name i=d;i<u;i++)
const int nm=201;
inline void output(long long o); 
inline long long input();
template<int nn,int mm,typename name>struct network{
#define nnn (nn+3)
#define mmmm (mm<<2)+2
	int s,t,tot,nnnn,last[nnn],level[nnn],to[mmmm],arc[mmmm],back[mmmm];
	name c[mmmm];
	std::queue<int>q;
	network(){nnnn=nnn<<2,INIT();}
#undef nnn
#undef mmmm
	void INIT(){tot=1,memset(last,0,nnnn);}
	void add(int f,int t,name cap){to[++tot]=t,c[tot]=cap,back[tot]=last[f],last[f]=tot;}
	void insert(int f,int t,name cap){
		if(cap){
			if(cap<0)std::swap(f,t),cap=-cap;
			add(f,t,cap),add(t,f,0);
		}
	}bool climb(){
		memset(level,0,nnnn),q.push(s),level[s]=0;
		for(int p,too;!q.empty();q.pop()){
			p=q.front(),level[p]++;
			downt(i,last[p])
			if(c[i]&&!level[too=to[i]])level[too]=level[p],q.push(too);
		}return level[t];
	}name augment(int p,name m){
		if(p==t)return m;
		name sum=0,flow;
		int d=level[p]+1;
        for(;arc[p];arc[p]=back[arc[p]])
		if(level[to[arc[p]]]==d&&c[arc[p]]){
			sum+=(flow=augment(to[arc[p]],std::min(c[arc[p]],(name)(m-sum)))),c[arc[p]]-=flow,c[arc[p]^1]+=flow;
			if(sum==m)return m;
		}return sum;
	}name Dinic(name inf){
		name maximum=0;
		while(climb()){
			foruntil(int,i,s,t)arc[i]=last[i];
			maximum+=augment(s,inf);
		}return maximum;
	}
	void new1(short m){
		short n=input(),a,b;
		s=0,t=n+m+1;
		forto(short,i,1,m)insert(0,i,1);
		forto(short,i,m+1,m+n)insert(i,t,1);
		while(true){
			if((a=input())==-1)break;
			insert(a,input(),1);
		}output(Dinic(100)),putchar('\n');
		forto(short,i,1,m)
		for(short j=last[i];back[j];j=back[j])
		if(!c[j])output(i),putchar(' '),output(to[j]),putchar('\n');
	}
};network<200,40000,short>pilot;
int main(){
	pilot.new1(input());
	return 0;
}inline void output(long long o){
	if(o<0)putchar('-'),o=-o;
	if(o>=10)output(o/10);
	putchar(o%10^'0');
}inline long long input(){
	bool minus=false;
	char now=getchar();
	long long i=0;
	for(;!isdigit(now);now=getchar())
	if(now=='-')minus=!minus;
	for(;isdigit(now);now=getchar())i=(i<<3)+(i<<1)+(now^'0');
	return minus?-i:i;
}
```
# 题集
- [网络流24题](https://blog.csdn.net/weixin_43890363/article/details/101509320)

希望这些外籍飞行员里能有中国飞行员。

还是中国飞行员强。

---

## 作者：Plus_Ultra (赞：7)

一看标签，应该就知道这题是什么题了吧。。。

一看这题，不是求二分图最大匹配吗，~~不知道二分图的请出门左转度娘~~，鉴于这题是网络流24题之一，我们就跑最大流吧.


就是在原图上建一个源点，再建一个汇点，跑最大流即可.
关于网络流为什么能求二分图最大匹配，可以去别的博客上上看，这里就不再赘叙.


看各位大佬都用的DINIC和匈牙利，蒟蒻不会用，所以只好老老实实的跑EK了...

下面是代码（我相信各位大佬也不需要代码）：

```
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<queue>

using namespace std;

int N,M,S,T;
queue<int> q;
struct node
{
	int v,edge;
}pre[100100];
int inque[10010];
long long ans;
int edge[200020],nxt[200020],head[200020],w[200020],tot=1;//tot必须从奇数开始！！！，因为有抑或操作 
int u,v,pi[20020]; 

void clear(node a[])
{
	for(int i=0;i<=100000;i++)
	a[i].v=a[i].edge=-1;
}

void add(int x,int y,int z)//加边
{
	edge[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
	w[tot]=z;
}

int BFS()//找增广路
{
	clear(pre);//初始化
	while(q.size())  q.pop();
	memset(inque,0,sizeof(inque));
	q.push(S);
	inque[S]=1;//加入源点
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=nxt[i])//扩展
		{
			int j=edge[i];
			if(w[i]&&!inque[j])//没有入栈且流量不为0
			{
				pre[j].v=x;
				pre[j].edge=i;
				if(j==T)  return 1;//找到了，返回
				q.push(j);inque[j]=1;			
			}
		}
	}
	return 0;//没有增广路
}

int EK()
{
	while(BFS())//找到了一条增广路
	{
		for(int i=T;i!=S;i=pre[i].v)//遍历这条增广路
		{
			int j=pre[i].edge;
			pi[pre[i].v]=i;//记录匹配点对
			w[j]-=1;
			w[j^1]+=1;
		}
		ans+=1;
	}
	if(ans==0)//完全没有匹配的情况
	{
		cout<<"No Solution!"<<endl;
		exit(0);
	}
	return ans;
}

int main()
{
	cin>>M>>N;S=1926,T=1817;//我一直读N,M，调了好长时间。。。
	for(int i=1;i<=N;i++)//这里为了不起冲突，i+N表示英军，当然i+M也行
		add(i+N,T,1),add(T,i+N,0);//使英军和汇点相连
	for(int i=1;i<=M;i++)
   	  add(i,S,0),add(S,i,1);//使外籍军和源点相连
	while(1)
	{
		cin>>u>>v;
		if(u==-1&&v==-1)  break;
		add(u,v+N,1);add(v+N,u,0);
	}
	
	cout<<EK()<<endl;
	for(int i=1;i<=N;i++) 
	  	if(pi[i]) 
		cout<<i<<" "<<pi[i]-N<<endl;//输出
	
	return 0;
}
```


---

## 作者：VanillaYuzume (赞：5)

# 网络流24题---飞行兔配对方案问题

题意:[自己康](https://www.luogu.org/problem/P2756)

## 解法一:求网络最大流
对于m只外籍飞行兔 和 n只嘤籍飞行兔   
我们先把外籍飞行兔 拴在一根桩子0上 再把嘤籍飞行兔拴在柱子n+1上     
这个时候 我们在把每对兔兔用绳子连上                  
这样我们就能根据他们的连接性来找到一种能 **使连在一起的兔兔最多** 的方法!
所以我们可以使用网络最大流算法来模拟用绳子栓兔兔 找兔兔的过程

31ms/760.00KB/1.88KB C++11   
**代码酱 OVO↓**
```cpp
//P2756 飞行员配对方案问题
//dinic求解网络最大流 无当前弧优化
#include <bits/stdc++.h>
using namespace std;

#define N 101
#define M 10002
#define inf 0x7f7f7f
#define v to[i]

int n,m,s,t,dep[N],cnt=0,cur[M];
int head[M],to[M],from[M],nex[M],w[M],ecnt;

void ae(int x,int y,int z){
    from[ecnt]=x;
    to[ecnt]=y;
    w[ecnt]=z;
    nex[ecnt]=head[x];
    head[x]=ecnt++;//因为超级源点是0 所以会存0的信息 所以ecnt要后++
}

bool bfs(){
    queue<int> q;
    memset(dep,-1,sizeof(dep));
    memcpy(cur,head,sizeof(cur));
    dep[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nex[i]){//这里的i也是相同的道理!
            if(dep[v]==-1 and w[i]>0){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t]!=-1;
}

int dfs(int u,int low){
    if(u==t) return low;
    int ret=low;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(dep[v]==dep[u]+1 and w[i]>0){
            int flow=dfs(v,min(ret,w[i]));
            if(flow>0){
                w[i] -= flow;
                w[i^1] += flow;
            }
            ret-=flow;
            if(!ret)
                break;
        }
    }
    return low-ret;
}

int dinic(){
    int tmp=0;
    while(bfs()){
        tmp+=dfs(s,inf);
    }
    return tmp;
}

int main(){
    memset(head,-1,sizeof(head));
    scanf("%d%d",&m,&n);
    s=0,t=n+1;
    for(int i=1;i<=m;i++){
        ae(s,i,1);
        ae(i,s,0);
    }
    for(int i=m+1;i<=n;i++){
        ae(i,t,1);
        ae(t,i,0);
    }
    int t1,t2;
    while(1){
        scanf("%d%d",&t1,&t2);
        if(t1==-1&&t2==-1) break;
        ae(t1,t2,1);
        ae(t2,t1,0);
    }
    int ans=dinic();
    if(ans==0){
        printf("No Solution!");
        return 0;
    }
    printf("%d\n",ans);
    for(int i=0;i<=ecnt;i++){
        if(from[i]>=1 && from[i]<=m)
            if(to[i]>m && to[i]<=n)
                if(w[i]==0)
                    printf("%d %d\n",from[i],to[i]);
    }
    return 0;
}
```

## 解法二
我们可能会觉得要自己来人力配对兔兔太累了(~~汗!就是懒~~           
所以! 我们让兔兔们自己去找与自己配对的 就行啦                 
我们可以用匈牙利算法来实现这一过程                  
我们让左边的兔兔(u)去找右边与它匹配合法的兔兔(v)           (即相连的两只兔兔   
然后 让 与它(u)匹配合法的兔兔(v) 继续 向左找有没有与其(v)合法的兔兔(x)   
如果有 就让(u)和(v)在一起~  
只要我们一直重复m次(左边兔兔的数量)就可以得到答案了

(33ms/824.00KB/1.30KB C++11)   
**代码酱 OVO↓**
```cpp
//使用二分图最大匹配--匈牙利算法
//P2756 飞行员配对方案问题
#include <bits/stdc++.h>
using namespace std;

#define N 101
#define M 10002
#define inf 0x7f7f7f
#define v to[i]

int n,m,s,t,vis[N],match[N];
int pair1[N],pair2[N];
int head[M<<1],to[M<<1],from[M<<1],nex[M<<1],w[M<<1],ecnt;

void ae(int x,int y){
    ecnt++;
    from[ecnt]=x;
    to[ecnt]=y;
    nex[ecnt]=head[x];
    head[x]=ecnt;
}

bool dfs(int u){
    for(int i=head[u];i;i=nex[i]){
        if(!vis[v]){
            vis[v]=1;
            if(!match[v] or dfs(match[v])){
                //↑如果v没有被匹配 或 v当前匹配的点(v的下一个点)有其他点与之匹配
                match[v]=u;//这样就可以u就可以和v匹配啦qwq
                return true;
            }
        }
    }
    return false;
}

int hungary(int tmp){
    int cnt=0;
    for(int i=1;i<=tmp;i++){
        memset(vis,0,sizeof(vis));
        if(dfs(i))
            cnt++;
    }
    return cnt;
}

int main(){
    scanf("%d%d",&m,&n);//m左 n右 
    int t1,t2;
    while(1){
        scanf("%d%d",&t1,&t2);
        if(t1==-1 and t2==-1) 
            break;
        ae(t1,t2);//匈牙利建单向图
    }
    int ans=-1;
    ans=hungary(m);//从左向右找 
    if(ans==-1){
        printf("No Solution!\n");
        return 0;
    }
    printf("%d\n",ans);
    for(int i=1;i<=n;i++){
        if(match[i])//只要不是0 就说明有与之匹配的点
            printf("%d %d\n",match[i],i);
    }
    return 0;
}
```

---

## 作者：Michael_Li (赞：4)

看了一下下面的题解，还是dinic网络流居多，匈牙利的题解也没有很详细的注释，这里补充一下，希望对大家学习匈牙利算法有帮助。

匈牙利算法的介绍百度上都有很详细的，很多博客都写的非常的好，我个人就是这么学起来的。

不过最好自己先打一遍，然后板子要看。我凭着自己的理解打了，但是很多细节处理都没注意到，而且代码很丑。

不过放心，此ac代码是经过改良的。

具体注释看代码。假装你已经有匈牙利算法的基础。

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#define N (201)
#define M (10001)
using namespace std;
int n, m, x, y, tot, k;
int head[N], nxt[M], a[M], con[N];//前三个为邻接表的数组，con为匹配的数组
bool vis[N];//vis表示这个点在这次搜索中是否被走过了
template <typename T> void read(T &t){
    bool fl = true;
    t = 0;
    char p = getchar();
    while(!isdigit(p)){
        if (p == '-') fl = false;
         p = getchar();
    }
    do{
        t = t * 10 + p - 48;
        p = getchar();
    }while (isdigit(p));
    if (!fl) t = -t;
} //快读
void add(int x, int y){
    a[++k] = y; nxt[k] = head[x]; head[x] = k;
```
}//存图
bool DFS(int x){//表示我给第x号点找一个匹配，return的bool表示能否找到匹配

```cpp
    for (int p = head[x]; p; p = nxt[p]){
        if (!vis[a[p]]){
            vis[a[p]] = 1;//如果有一个点没有被选，直接选掉
            if (!con[a[p]]||DFS(con[a[p]])) {//or 的前一半就是没有配对过，后一半表示我可以给她原先的匹配选一个后继
                con[a[p]] = x;//记录
                return 1;
            }
        }
    }
    return 0;
}
int main(){
    read(n); read(m);
    read(x); read(y);
    while (!(x == -1 && y == -1)){
        add(x, y);
        read(x); read(y);
```
}//按题意读入
```cpp
    for (int i = 1; i <= n; i++){
        memset(vis, 0, sizeof(vis));
        tot += DFS(i);//如果可以找到，bool会返回1，我们就可以把答案加上去。
    } 
    printf("%d\n", tot);
    if (tot == 0) printf("No Solution!");
    else for (int i = n+1; i <= m; i++) if (con[i]) printf("%d %d\n", con[i], i);//方案输出
    return 0;
} 
刚学提高组，对这些算法没有很好的理解，只是给大家提供一个参考，也希望这篇题解能够帮到大家
```

---

## 作者：pluszero (赞：4)

**用的是最大流的EK算法。将0点和每一个点和n+m+1的点相连，每个点的容量都为1，求出的最大流就是答案。**

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#define mm(a) memset(a,0,sizeof(a))
using namespace std;
bool d[100001];

struct edge
{
    int from,to,cap,flow;
    edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f) {}
};

int n,m,r,a[100001],p[100001],en[100001],st[100001],f[100001];
vector<edge> edges;
vector<int> g[100001];

void init(int n)
{
    for(int i=0;i<n;i++) g[i].clear();
    edges.clear();
}

void add(int from,int to,int cap)
{
    edges.push_back(edge(from,to,cap,0));
    edges.push_back(edge(to,from,0,0));
    int m=edges.size();
    g[from].push_back(m-2);
    g[to].push_back(m-1);
}

int maxflow(int s,int t)
{
    int flow=0;
    for(;;)
    {
        mm(a);
        queue<int> q;
        q.push(s);
        a[s]=1;
        while(!q.empty())
        {
            int x=q.front(); q.pop();
            for(int i=0;i<g[x].size();i++)
            {
                edge& e= edges[g[x][i]]; 
                if(!a[e.to] && e.cap>e.flow)
                {
                    p[e.to]=g[x][i];
                    a[e.to]=min(a[x],e.cap-e.flow);
                    q.push(e.to);
                }
            }
            if(a[t]) break;
        }
        if(!a[t]) break;
        int sum=0,last;
        for(int i=t;i!=s;i=edges[p[i]].from)
        {
            edges[p[i]].flow+=a[t];
            edges[p[i]^1].flow-=a[t];
            if(i!=t && i!=s) 
            {
                sum++;
                if((sum&1)==0) f[i]=last; else last=i;
            }
        }
        flow+=a[t];
    }
    return flow;
}

int main()
{
    int b,c;
    scanf("%d%d%d%d",&m,&n,&b,&c);
    r=m+n+1;
    init(r);
    for(;;)
    {
        if(c==-1 && b==-1) break;
        if(!d[b]) 
        {
            add(0,b,1);
            d[b]=1;
        }
        add(b,c,1);
        if(!f[c])
        {
            add(c,r,1);
            f[c]=1;
        }
        scanf("%d%d",&b,&c);
    }
    mm(f);
    int t=maxflow(0,r);
    if(t!=0) 
    {
        printf("%d\n",t);
        for(int i=1;i<=m;i++) 
        if(f[i]) printf("%d %d\n",i,f[i]);
    }
    else printf("No Solution!");
    return 0;
}
```

---

## 作者：abandentsky (赞：3)

其实就是一个二分图最大匹配问题。模板题。所以我就说一下这个模板。
题目中一边是英国飞行员，一边是外籍飞行员。如果某个英国飞行员和某个外籍飞行员有匹配的意愿就给他俩连一条边。然后就开始匹配。题目要求：最多有多少架飞机可以派出。其实就是在求最大边匹配。
```c
#include<stdio.h>
#include<iostream>
#include<vector>
#include<algorithm>
#define MAXN  205
typedef  long long  LL;
using namespace std;

vector<int> G[MAXN];
bool vis[MAXN];
int vv[MAXN];
int Left[MAXN];
int n,m;

bool match(int u)  //对每一个英国飞行员找队友
{
    for(int i=0;i<G[u].size();i++)   //枚举每一个队友（就是和自己有匹配意愿，连边的）
    {
        int v=G[u][i];             //外籍队友
        if(vis[v])                 //本轮次没有匹配过这个队友（为了防止出现死循环，无限次递归）
            continue;
        vis[v]=true;               //这次已近访问
        if(!vv[v]||match(vv[v]))   //这个外籍飞行员没有英国籍队友或者他的英国籍队友可以选择其他的外国籍然后可以把这个外国籍让给他
        {
            vv[v]=u;              //外籍飞行员的队友
            Left[u]=v;            //英国飞行员的队友
            return true;          //匹配成功，返回true
        }
    }
    return false;                   //匹配失败，返回false
}

int KM()
{
    memset(vv,0,sizeof(vv));
    memset(Left,0,sizeof(Left));
    int sum=0;
    for(int i=1;i<=n;i++)
    {
        memset(vis,false,sizeof(vis));  //每轮次对外籍飞行员初始化，防止死循环
        if(match(i))                   //给每个英国飞行员做匹配
            sum++;
    }
    return sum;                         //返回匹配结果
}

int main()
{
    scanf("%d %d",&m,&n);
    int u,v;
    while(scanf("%d %d",&u,&v))
    {
        if(u==-1&&v==-1)
            break;
        G[u].push_back(v);   //和u匹配的点有v
    }
    int ans=KM();
    if(ans==0)
    {
        printf("No Solution\n");
        return 0;
    }
    printf("%d\n",ans);
    for(int i=1;i<=n;i++)
    {
        if(Left[i])
            printf("%d %d\n",i,Left[i]);
    }
    return 0;
}

```


---

## 作者：arfa (赞：3)

简单的二分图匹配 , 注意到要输出被选的点 , 所以我们看你的正向边有没有被留空就好了。

链式前向星要记录 $from_i$ 和 $reach_i$。

显然要建立超源超汇。跑的是比较优越的 $ISAP$。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    value,reach,from,next:array[-1..10000] of longint;
    gap,dis,cnt:array[-1..10000] of longint;
    i,l,r,n,m,source,sink,tot,nn,ans:longint;
    maxflow:int64;

procedure add(l,r,sum:longint);
begin
    inc(tot);
    from[tot]:=l;
    reach[tot]:=r;
    value[tot]:=sum;
    next[tot]:=cnt[l];
    cnt[l]:=tot;
end;

function Dfs(now,flow:longint):longint;
var i,k,mindis,ret:longint;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k); inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
            mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    read(n,m); source:=1; sink:=n+m+2; nn:=n;

    for i:=1 to n do begin add(source,i+1,1); add(i+1,source,0); end;
    read(l,r);
    while l<>-1 do begin add(l+1,r+n+1,1); add(r+n+1,l+1,0); read(l,r); end;
    for i:=1 to m do begin add(i+n+1,sink,1); add(sink,i+n+1,0); end;
    n:=n+m+2;

    gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint div 84));
    for i:=1 to tot do if (from[i]<>source)and(reach[i]<>sink)and(i mod 2=0)and(value[i]=0) then inc(ans);
    writeln(ans);
    for i:=1 to tot do if (from[i]<>source)and(reach[i]<>sink)and(i mod 2=0)and(value[i]=0) then writeln(from[i]-1,' ',reach[i]-nn-1);
end.
```

---

## 作者：Jianuo_Zhu (赞：3)

一道二分图裸题。关于网络流解二分图，不懂的可以看我的这题解：[二分图](https://www.luogu.org/blog/jianuo/solution-p3386 "二分图")

这道题唯一的难点就是输出方案。但其实仔细想一想也不难。

当一个点往后增广了1的流量时，如果这个点在左半边，就把他的配对点改为正在增广的下一个点（不好直接解释，看代码吧）

代码:




```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int maxn=1e7,inf=1e9;
struct edge{
    int v,c,f,nxt;
}e[maxn];
int s,t,n,m,mm,cnt,h[maxn],lev[maxn],match[maxn];
queue<int> q;
void add(int u,int v,int w);
int maxflow(void);
int bfs(void);
int dfs(int x,int flow);
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    s=0;t=n+m+1;
    memset(h,-1,sizeof(h));
    for(int i=1;i<=n;i++) add(s,i,1),add(i,s,0);
    for(int i=n+1;i<=n+m;i++) add(i,t,1),add(t,i,0);
    int u,v;
    while(true){
        cin>>u>>v;
        if(v==-1 || u==-1) break;
        add(u,v,1);add(v,u,0);
    }
    int ans=maxflow();
    if(ans==0) cout<<"No solution!";
    else cout<<ans<<endl;
    for(int i=1;i<=n;i++) if(match[i]!=0)cout<<i<<" "<<match[i]<<endl;
    //system("pause");
    return 0;
}
void add(int x,int y,int z)
{
    e[cnt].nxt=h[x];
    e[cnt].c=z;e[cnt].f=0;
    e[cnt].v=y;
    h[x]=cnt++;
}
int maxflow(void){
    int ans=0;
    while(bfs())
        ans+=dfs(s,inf);
    return ans;
}
int bfs(void){
    memset(lev,0,sizeof(lev));
    lev[s]=1;q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=h[u];i!=-1;i=e[i].nxt){
            int v=e[i].v;
            if(e[i].c>e[i].f && !lev[v]) lev[v]=lev[u]+1,q.push(v);
        }
    }
    return lev[t];
}
int dfs(int x, int flow) {
    int af = 0;
    if (x == t) return flow;
    for (int i = h[x]; i != -1; i = e[i].nxt) {
        if (flow <= af) break;
        int v = e[i].v;
        if (lev[v] == lev[x] + 1) {
            int maxf = dfs(v, min(e[i].c - e[i].f, flow - af));
            if(maxf!=0) {
                if(x<=n&&x!=s) match[x]=v;//就是这里，把x的配对点改为v，仔细想想为什么。
            }
            e[i].f += maxf;
            e[i ^ 1].f -= maxf;
            af += maxf;
        }
    }
    return af;
}

```

---

## 作者：LoveHX (赞：3)

这道题可能许多人看到直接用匈牙利算法了，但是蒻鸡的我不会，刚开始很无奈，想了很久，突然想到，如果加一个起点和一个终点，然后这道题就可以变成一个图了，显然就可以用最大流来做，详细见代码.


```cpp
#include<iostream>
#include<queue>//用队列来优化，比数组简单一些，虽然也没简单多少，个人爱好。
#include<cstring>
using namespace std;
const int maxn=10000;
queue<int> q;
struct node{
    int u,v,c,next;
}a[maxn];//结构体方便
int first[maxn];//用于链表
int vis[maxn];//判断
int cur[maxn];//优化用的，也可以不要
int m,n;
int dis[maxn];
int s,t;
int e=0;
int tot=0;
//int k;
void add(int u,int v,int w)//链表不解释
{
    a[e].u=u;
    a[e].v=v;
    a[e].c=w;
    a[e].next=first[u];
    first[u]=e;
    e++;
}
void read()//读入
{
    cin>>m>>n;
    s=0;//定义的起点
    t=n+1;//定义的终点
        for(int i=1;i<=m;i++)
    {
        add(s,i,1);
        add(i,s,0);//残量图，最大流特点
    }
    while(1)
    {
        int u,v;
        cin>>u>>v;
        if(u==-1&&v==-1)
        break;
        add(u,v,1);
        add(v,u,0);
    }
    for(int i=m+1;i<=n;i++)
    {
        add(i,t,1);
        add(t,i,0);
    }
}
int bfs()//判断优化
{
    memset(dis,0,sizeof(dis));
    memset(vis,0,sizeof(vis));
    q.push(s);
    vis[s]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=first[u];i!=-1;i=a[i].next)
        {
            int v=a[i].v;
            int c=a[i].c;
            if(!vis[v]&&c>0)
            {
                dis[v]=dis[u]+1;
                q.push(v);
                vis[v]=1;
            }
        }
    }
    return vis[t];
}
int dfs(int u,int flow)//核心，
{
    if(u==t||flow==0) return flow;
    int sum=0;
    for(int &i=cur[u];i!=-1;i=a[i].next)
    {
        int v=a[i].v;
        int &c=a[i].c;
        if(c>0&&dis[v]==dis[u]+1)
        {
            int f=dfs(v,min(c,flow-sum));
            a[i].c-=f;
            a[i^1].c+=f;
            sum+=f;
            if(sum==flow) return sum;
        }
    }
    return sum;
}
void work()
{
    while(bfs())
    {
        for(int i=s;i<=t;i++)
        {
            cur[i]=first[i];//此处纯优化，就不解释了，有点绕，可以背住，也可以不要，但我不知道会不会超时，这道题应该不会。
        }
        tot+=dfs(s,1e9);
    }
}
void solve()
{
    cout<<tot<<endl;
    for(int i=0;i<=e;i=i+2)//记住，一定要加2，因为这个图两个点有两条线，加1会出事。
   {
         if(a[i].v!=s&&a[i^1].v!=s)
         if(a[i].v!=t&&a[i^1].v!=t)
         if( a[i^1].c>0)
         {
             cout<<a[i^1].v<<" "<<a[i].v<<endl;
     }
   }
}
int main()
{
    memset(a,-1,sizeof(a));
    memset(first,-1,sizeof(first));
    read();
    work();
    solve();
    return  0;
}
```

---

## 作者：deluxurous (赞：3)

P党水一发

##赤裸裸的二分图匹配模板题

##赤裸裸的网络流&匈牙利

我在这里用的是**饥饿**算法（自己取的名字，因为hungary和hungry好点像）

就多建一个数组维护外籍飞行员与英国飞行员的匹配状况就行了

代码：

``` Pascal
var
 matchA,matchB:array[0..201]of longint;
 used:array[0..201]of boolean;
 a:array[0..201,0..201]of boolean;
 i,j,k,n,m,l,ans:longint;

function found(x:longint):boolean;
var
 i:longint;
begin
 for i:=1 to n do
  if (a[x,i])and(not used[i]) then
   begin
    used[i]:=TRUE;
    if (matchA[i]=0)or(found(matchA[i])) then
     begin
      matchA[i]:=x;
      matchB[x]:=i;
      exit(TRUE);
     end;
   end;
 exit(FALSE);
end;

begin
 readln(m,n);
 readln(i,j);
 while (i<>-1)and(j<>-1) do
  begin
   a[i,j-m]:=TRUE;
   readln(i,j);
  end;
 fillchar(matchA,sizeof(matchA),0);
 fillchar(matchB,sizeof(matchB),0);
 ans:=0;
 for i:=1 to m do
  begin
   fillchar(used,sizeof(used),FALSE);
   if found(i) then ans:=ans+1;
  end;
 writeln(ans);
 for i:=1 to m do
  if matchB[i]<>0 then writeln(i,' ',matchB[i]+m);
end.
```
一遍水过 10ms / 8.25MB 毫无压力


---

## 作者：zh_dou (赞：2)

### 飞行员配对方案问题
考虑每一个飞行员，最多仅可以驾驶一架飞机，一队关系也仅能使用一次，所以

对于外籍飞行员$i:s\xrightarrow{1} i$

对于英国飞行员$j:j\xrightarrow{1} t$

对于一组关系$i,j:i\xrightarrow{1} j$

从 $s$ 到 $t$ 跑最大流记录路径即可

用 $after$ 数组记录一个点的后继

（因为题里输入的$i$与$j$一定不相等，所以说也可以当成二分图跑最大匹配，对于飞行员记录匹配点即可）

$\mathcal{Code}:$
```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
#define N 100010
#define int long long
#define debug cout<<__LINE__<<" "<<__FUNCTION__<<"\n"
inline int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*y;
}
int n,m,s,t,dep[N];
int head[N],tot=1,front,used[N];
int ans;
int after[N];
struct Node{
    int nxt,to,dis;
}edge[N<<2];
inline void add(int x,int y,int z){
    edge[++tot].nxt=head[x];
    edge[tot].to=y;
    edge[tot].dis=z;
    head[x]=tot;
}
queue<int> q;
inline int bfs(){
	register int i;
	for(i=0;i<=n+1;i++) dep[i]=-1, used[i]=head[i];
	dep[s]=0;
	q.push(s);
	while(!q.empty()){
		front=q.front();q.pop();
//		cout<<front<<" ";debug;
		for(i=head[front];i;i=edge[i].nxt){
			if(edge[i].dis&&dep[edge[i].to]==-1){
				dep[edge[i].to]=dep[front]+1;q.push(edge[i].to);
			}
		}
	}
//	debug;
	return dep[t]!=-1;
}
int dfs(int now,int limit){
	if(!limit||now==t) return limit;
	int flow=0;
	for(int &i=used[now],pro;i;i=edge[i].nxt){
		if(dep[edge[i].to]==dep[now]+1&&edge[i].dis){
			pro=dfs(edge[i].to,min(limit,edge[i].dis));
			if(!pro) continue;
			edge[i].dis-=pro;
			edge[i^1].dis+=pro;
			flow+=pro;
			limit-=pro;
			after[now]=edge[i].to;//记录路径
			if(!limit) return flow;
		}
	}
//	cout<<flow<<" ";debug;
//	system("pause");
	return flow;
}
inline void Dinic(){
	while(bfs()){ans+=(dfs(s,10000000001LL));}
}
signed main(){
//	freopen("a.in","r",stdin);
//	freopen(".out","w",stdout);
	m=read();n=read();
	s=0;t=n+1;
	for(int i=1;i<=m;i++) add(s,i,1),add(i,s,0);
	for(int i=m+1;i<=n;i++) add(i,t,1),add(t,i,0);
	int x=read(),y=read();
	while(x!=-1&&y!=-1){
		add(x,y,1);add(y,x,0);
		x=read();y=read();
	}
	Dinic();
	if(ans==0){//无解情况
		puts("No Solution!");return 0;
	}
	cout<<ans<<"\n";
	for(int i=1;i<=m;i++){
		if(after[i]){
			cout<<i<<" "<<after[i]<<"\n";
		}
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

---

## 作者：Ireliaღ (赞：2)

## ISAP二分图匹配

看到二分图匹配直接上$ISAP$，吊打匈牙利

### 前置知识：ISAP最大流算法

按照惯例放学长博客 **[传送门](https://www.cnblogs.com/ubospica/p/9974285.html)**

### 建图

(1) 以$0$为超级源点，$n + 1$为超级汇点，从$0$向$1$到$m$的所有点建立容量为$1$的边，从$m + 1$到$n$的所有点向$n + 1$建立容量为$1$的边

(2) 对于每一对匹配$match_{i,j}$，从$i$到$j$建立容量为$1$的边

### 代码

正常$ISAP$从超级源点到超级汇点跑最大流，加当前弧优化直接起飞

***代码如下（习惯性$O3$）***

普通版

```cpp

#pragma GCC optimize(3)
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using std::queue;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge(int to, int val, Edge *next):to(to), val(val), next(next){}
};

Edge *head[MAXN];

int n, m;

void AddEdge(int from, int to, int val) {
    head[from] = new Edge(to, val, head[from]);
    head[to] = new Edge(from, 0, head[to]);
    head[from]->ops = head[to]; head[to]->ops = head[from];
}

namespace ISAP{
    int s, t, maxflow;
    int dep[MAXN], gap[MAXN];
    
    void Bfs() {
        memset(dep, -1, sizeof(dep));
        memset(gap, 0, sizeof(gap));
        dep[t] = 0; gap[dep[t]]++;
        queue<int> q; q.push(t);
        while (!q.empty()){
            int u = q.front(); q.pop();
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (dep[v] != -1) continue;
                dep[v] = dep[u] + 1;
                gap[dep[v]]++;
                q.push(v);
            }
        }
    }

    int Dfs(int u, int flow) {
        if (u == t) {
            maxflow += flow;
            return flow;
        }
        int used = 0;
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if (e->val && dep[v] == dep[u] - 1) {
                int mi = Dfs(v, std::min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    if (used == flow) return used;
                }
            }
        }
        gap[dep[u]]--;
        if (gap[dep[u]] == 0) dep[s] = n + 3;
        dep[u]++;
        gap[dep[u]]++;
        return used;
    }

    void Work() {
        maxflow = 0;
        Bfs();
        while (dep[s] < n + 2) Dfs(s, INF);
    }

    void Print() {
        if (maxflow == 0) {
            puts("No Solution!");
            return;
        }
        printf("%d\n", maxflow);
        for (int i = 1; i <= m; i++) {
            for (Edge *e = head[i]; e; e = e->next) {
                int v = e->to;
                if (v > m && v <= n && e->val == 0) printf("%d %d\n", i, v);
            }
        }
    }
}

int main() {
    scanf("%d %d", &m, &n);
    ISAP::s = 0; ISAP::t = n + 1;
    memset(head, 0, sizeof(head));
    for (int i = 1; i <= m; i++) {
        AddEdge(0, i, 1);
    }
    for (int i = m + 1; i <= n; i++) {
        AddEdge(i, n + 1, 1);
    }
    int x, y;
    while (scanf("%d %d", &x, &y), x != -1 && y != -1) {
        AddEdge(x, y, 1);
    }
    ISAP::Work();
    ISAP::Print();
    return 0;
}
/*
5 10
1 7
1 8
2 6
2 9
2 10
3 7
3 8
4 7
4 8
5 10
-1 -1
*/

```

优化版

```cpp
#pragma GCC optimize(3)
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using std::queue;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge(int to, int val, Edge *next):to(to), val(val), next(next){}
};

Edge *head[MAXN];

int n, m;

void AddEdge(int from, int to, int val) {
    head[from] = new Edge(to, val, head[from]);
    head[to] = new Edge(from, 0, head[to]);
    head[from]->ops = head[to]; head[to]->ops = head[from];
}

namespace ISAP{
    int s, t, maxflow;
    int dep[MAXN], gap[MAXN];
    Edge *cur[MAXN];
    void Bfs() {
        memset(dep, -1, sizeof(dep));
        memset(gap, 0, sizeof(gap));
        dep[t] = 0; gap[dep[t]]++;
        queue<int> q; q.push(t);
        while (!q.empty()){
            int u = q.front(); q.pop();
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (dep[v] != -1) continue;
                dep[v] = dep[u] + 1;
                gap[dep[v]]++;
                q.push(v);
            }
        }
    }

    int Dfs(int u, int flow) {
        if (u == t) {
            maxflow += flow;
            return flow;
        }
        int used = 0;
        for (Edge *&e = cur[u]; e; e = e->next) {
            int v = e->to;
            if (e->val && dep[v] == dep[u] - 1) {
                int mi = Dfs(v, std::min(e->val, flow - used));
                if (mi) {
                    used += mi;
                    e->val -= mi;
                    e->ops->val += mi;
                    if (used == flow) return used;
                }
            }
        }
        gap[dep[u]]--;
        cur[u] = head[u];
        if (gap[dep[u]] == 0) dep[s] = n + 3;
        dep[u]++;
        gap[dep[u]]++;
        return used;
    }

    void Work() {
        for (int i = 0; i <= n; i++) cur[i] = head[i];
        maxflow = 0;
        Bfs();
        while (dep[s] < n + 2) Dfs(s, INF);
    }

    void Print() {
        if (maxflow == 0) {
            puts("No Solution!");
            return;
        }
        printf("%d\n", maxflow);
        for (int i = 1; i <= m; i++) {
            for (Edge *e = head[i]; e; e = e->next) {
                int v = e->to;
                if (v > m && v <= n && e->val == 0) printf("%d %d\n", i, v);
            }
        }
    }
}

int main() {
    scanf("%d %d", &m, &n);
    ISAP::s = 0; ISAP::t = n + 1;
    memset(head, 0, sizeof(head));
    for (int i = 1; i <= m; i++) {
        AddEdge(0, i, 1);
    }
    for (int i = m + 1; i <= n; i++) {
        AddEdge(i, n + 1, 1);
    }
    int x, y;
    while (scanf("%d %d", &x, &y), x != -1 && y != -1) {
        AddEdge(x, y, 1);
    }
    ISAP::Work();
    ISAP::Print();
    return 0;
}
/*
5 10
1 7
1 8
2 6
2 9
2 10
3 7
3 8
4 7
4 8
5 10
-1 -1
*/
```

---

## 作者：Xie_BR (赞：1)

首先根据标签，我们可以做一个初步判断：
## 这是一道网络流
对我来说，网络流基础题最喜欢写dinic（可能不是这么拼的）  
### 下面听我慢慢道来  
首先这道题相当于就是要让我们做一个假的源点和一个假的汇点  
其次我们可以通过增广路跑一遍dinic的模板  
至于输出嘛，因为有special judge，所以我们其实可以直接遍历所有的非起点和终点的点，将其与对应点输出就可以：）  
# 下面附上AC代码： 

```cpp
#include<bits/stdc++.h>
#define int long long
#define MK 100010
using namespace std;
int n,m;
int S,T;
int dep[MK];
int ans;
int tot = 0;

struct node
{
	int next,to,v;
}e[MK*2];

int ei = 1,h[MK];

void add(int x,int y,int v)
{
	ei++;
	e[ei].to = y;
	e[ei].v = v;
	e[ei].next = h[x];
	h[x] = ei;
}

int bfs()
{
	queue<int>qu;
	memset(dep,0,sizeof(dep));
	dep[S] = 1;
	qu.push(S);
	while(!qu.empty())
	{
		int f1 = qu.front();
		qu.pop();
		for(int i=h[f1];i;i=e[i].next)
		{
			int to = e[i].to;
			if(dep[to]!=0 || e[i].v==0)
			{
				continue;
			}
			qu.push(to);
			dep[to] = dep[f1]+1;
		}
	}
	return dep[T]!=0;
}

int dfs(int from,int maxflow)
{
	if(from==T)
	{
		return maxflow;
	}
	int flow = 0;
	for(int i=h[from];i;i=e[i].next)
	{
		int to = e[i].to;
		if(dep[to]!=dep[from]+1 || e[i].v==0)
		{
			continue;
		}
		int rst = dfs(to,min(maxflow-flow,e[i].v));
		if(rst==0)
		{
			dep[to] = 0;
		}
		e[i].v -= rst;
		e[i^1].v += rst;
		flow += rst;
		if(flow==maxflow)
		{
			break;
		}
	}
	return flow;
}

void dinic()
{
	while(bfs())
	{
		ans += dfs(S,LLONG_MAX);
	}
}

signed main()
{
	scanf("%lld%lld",&n,&m);
	while(1)
	{
		int x,y;
		scanf("%lld%lld",&x,&y);
		if(x==-1 && y==-1)
		{
			break;
		}
		add(x,y,1);
		add(y,x,0);
	}
	S = 1000;
	T = 1001;
	for(int i=1;i<=n;i++)
	{
		add(S,i,1);
		add(i,S,0);
	}
	for(int i=n+1;i<=m;i++)
	{
		add(i,T,1);
		add(T,i,0);
	}
	dinic();
	if(ans==0)
	{
		printf("No Solution\n");
		return 0;
	}else
	{
		printf("%lld\n",ans);
		for(int i=2;i<=ei;i=i+2)
		{
			if(e[i].to!=S && e[i].to!=T && e[i^1].to!=S && e[i^1].to!=T && e[i^1].v!=0)
			{
				printf("%lld %lld\n",e[i].to,e[i^1].to);
			}
		}
	}
	return 0;
}
```
# 蒟蒻想法，大佬指教！

---

## 作者：Polaris_Dane (赞：1)

莫名其妙的就过了。。。

网络流二十四题之一，其实跟二分图匹配模板没有什么区别，多了一个路径记录罢了



------------
我们先从二分图匹配开始讲起（没啥好讲的）

匈牙利算法，通过找一条增广路来迭代求出最大匹配，但可能连模板题都过不了（这里有惨痛的教训）

所以我们要用Dinic跑网络流，建立超级源点和超级汇点给x部分与超级源点连一条边，y部分与超级汇点连一条边，中间的边流量设为一即可跑最大流，答案即为所求。

~~证明吗？？？自己想想，很简单的~~

```cpp
	scanf("%d %d",&m,&n);
	while (1)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		if (x==-1)
		{
			break;
		}
		add(x,y,1);
		add(y,x,0);
	}
	s=0;
	t=n+1;
	for (int i=1;i<=m;i++)
	{
		add(s,i,1);
		add(i,s,0);
	}
	for (int i=m+1;i<=n;i++)
	{
		add(i,t,1);
		add(t,i,0);
	}
	dinic();
	if (!ans)
	{
		printf("No Solution!");
	}
	else
	{
		printf("%d\n",ans);
		for (int i=m+1;i<=n;i++)
		{
			if (!pre[i])
			{
				continue;
			}
			printf("%d %d\n",i,pre[i]);
		}
	}
```
而路径记录也很简单，每次找到一条增广路时，改变y部的pre数组即可，因为一个y部的点最多对应一个x部的点，所以最后更新出来的父亲必定满足最优解。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<time.h>
#include<queue>
#define M 2010000
#define inf 99999999
using namespace std;
queue <int> q;
int cnt,head[M],s,t,m,n,ans,flag,dep[M],pre[M];
struct edge{
	int to,from,next,val,num,re;
}e[M];
void clear(queue<int>& q) {
    queue<int> empty;
    swap(empty, q);
}
inline void add(int u,int v,int w)
{
	e[++cnt].next=head[u];
	e[cnt].to=v;
	e[cnt].from=u;
	e[cnt].val=w;
	e[cnt].num=cnt;
	if (cnt%2==1)
	{
		e[cnt].re=cnt+1;
	}
	else
	{
		e[cnt].re=cnt-1;
	}
	head[u]=cnt;
}
int bfs()
{
	memset(dep,-1,sizeof(dep));
	dep[s]=0;
	q.push(s);
	while (!q.empty())
	{
		int h=q.front();
		q.pop();
		for (int i=head[h];i;i=e[i].next)
		{
			if (dep[e[i].to]==-1&&e[i].val>0)
			{
				dep[e[i].to]=dep[h]+1;
				q.push(e[i].to);
			}
		}
	}
	if (dep[t]!=-1)
	{
		return true;
	}
	else
	{
		return false;
	}
}
int dfs(int u,int limit)
{
	if (limit==0||u==t)
	{
		return limit;
	}
	int flow=0;int f=0;
	for (int i=head[u];i;i=e[i].next)
	{
		if (dep[u]+1==dep[e[i].to])
		{
			f=dfs(e[i].to,min(limit,e[i].val));
			if (!f)
			{
				continue;
			}
			pre[e[i].to]=u;
			flow+=f;
			limit-=f;
			e[i].val-=f;
			e[e[i].re].val+=f;
			if (limit<=0)
			{
				break;
			}
		}
	}
	return flow;
}
void dinic()
{
	while (bfs())
	{
		ans+=dfs(s,inf);
	}
}
int main()
{
	scanf("%d %d",&m,&n);
	while (1)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		if (x==-1)
		{
			break;
		}
		add(x,y,1);
		add(y,x,0);
	}
	s=0;
	t=n+1;
	for (int i=1;i<=m;i++)
	{
		add(s,i,1);
		add(i,s,0);
	}
	for (int i=m+1;i<=n;i++)
	{
		add(i,t,1);
		add(t,i,0);
	}
	dinic();
	if (!ans)
	{
		printf("No Solution!");
	}
	else
	{
		printf("%d\n",ans);
		for (int i=m+1;i<=n;i++)
		{
			if (!pre[i])
			{
				continue;
			}
			printf("%d %d\n",i,pre[i]);
		}
	}
	return 0;
}

```



---

## 作者：little_sun (赞：1)


很简单的网络流

对于每个英国飞行员，从源点向它连一条容量为$1$的边

对于每个外国飞行员，从它向汇点连一条容量为$1$的边

对于每一对可以配对的英国/外国飞行员，从英国飞行员向外国飞行员连一条容量为$1$的边

然后跑dinic模板即可

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define cmax(a, b) ((a < b) ? b : a)
#define cmin(a, b) ((a < b) ? a : b)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 2e4 + 10;
const int MaxM = 5e5 + 10;
const int inf = (1 << 30);

struct edge
{
    int to, next, cap;
};

edge e[MaxM];
int n, m, s = 20000, t = 20001, cnt = 1, ans;
int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN];

inline void add(int u, int v, int c)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].cap = c;
    head[u] = cnt;
}

inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

inline int bfs()
{
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    std::queue<int> q;
    dep[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].to, c = e[i].cap;
            if (dep[v] || !c)
                continue;
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
    return dep[t];
}

inline int dinic(int u, int flow)
{
    if (u == t)
        return flow;
    int rest = flow;
    for (int i = cur[u]; i && (flow - rest < flow); i = e[i].next)
    {
        int v = e[i].to, c = e[i].cap;
        if (dep[v] != dep[u] + 1 || !c)
            continue;
        int k = dinic(v, cmin(rest, c));
        if (!k)
            dep[v] = dep[u] + 1;
        else
        {
            e[i].cap -= k;
            e[i ^ 1].cap += k;
            rest -= k;
        }
    }
    if (flow - rest < flow)
        dep[u] = -1;
    return flow - rest;
}

int main()
{
    n = read(), m = read();
    int u, v;
    for (int i = 1; i <= m; i++)
        add_edge(s, i, 1);
    for (int i = m + 1; i <= n; i++)
        add_edge(i, t, 1);
    while (scanf("%d%d", &u, &v) == 2)
        add_edge(u, v, 1);
    int now = 0;
    while (bfs())
        while ((now = dinic(s, inf)))
            ans += now;
    printf("%d\n", ans);
    return 0;
}
```



---

## 作者：glassy (赞：1)

题意：有 $m$ 个外籍飞行员，$(n-m)$个英国飞行员，其中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。把外籍飞行员和英国飞行员两两组合，允许飞行员不匹配，求最多能很好地组合多少对飞行员。

很裸的二分图最大匹配问题，可以直接用匈牙利算法~~或者带花树(丧心病狂)~~求出结果。
但是既然是网络流 $24$ 题就好好用网络流做嘛。

构图方式：
1. 附加源汇 $S$ 和 $T$ 
2. 连边 $(S,i)$ 流量为 $1$ $(1\leqslant i\leqslant m)$
3. 连边 $(i,T)$ 流量为 $1$ $(1\leqslant i\leqslant n-m)$
4. 对于原图中的每条 $(i,j)$ 附加流量为 $1$ 

然后最大流就是最大匹配。为什么？

我们知道，匈牙利算法的本质就是不断地寻找增广路，当找不到增广路的时候，当前增广路数量就是答案。

也就是说，当图不再联通的时候，就得到了答案。那有没有什么方法可以直接把图分成两半，并且尽量多的匹配？

**最小割**。我们知道，任何流的流量都无法超过最小割，也就是说，最多只能流最小割的流，也就是答案。

然后根据最大流最小割定理求一遍最大流即可。

匈牙利算法的时间复杂度是$Θ(me)$，其中 $e$ 是边数。

不要看$Dinic$ 的时间复杂度为$Θ(n^2e)$，对于二分图这样的图，它表现得异常优秀：复杂度比匈牙利还低，只有$Θ(\sqrt{n}\ e)$

这里用了一种折中的算法：$ISap$。其实这个算法没有名字，作者称它是一种“改进的$Sap$” ($Improve\ \ Sap$)，它对于二分图的表现没有$Dinic$ 好，但对于除了二分图以外的图，它的表现十分优异。具体思想是每次增广完毕后通过附近的点的举例修改到汇点的最短距离，而不是进行深度优先搜索。

下面的代码用链式向前星存边，对于数据较小的时候回更快，$Isap$加了两个优化，$Gap$ 和当前弧，用的是迭代而不是递归。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge{
    int from,to,flow,next;
};
class ISAP {
	static const int maxm=20010;
	static const int maxn=210;
	static const int INF=0x7f7f7f7f;
    int n,s,t,len;
    bool vis[maxn];
    int dis[maxn];
    int cur[maxn];
    int p[maxn];
    int num[maxn];
    inline bool rev_bfs(void){
        memset(vis,0,sizeof(vis));
        queue<int> q;
        q.push(t);
        dis[t]=0;
        vis[t]=1;
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(register int i=head[x];i;i=edges[i].next){
                Edge &e=edges[i^1];
                if(!vis[e.from]&&e.flow>0){
                    vis[e.from]=1;
                    dis[e.from]=dis[x]+1;
                    q.push(e.from);
                }
            }
        }
        return vis[s];
    }
    //增广
    inline int augment(){
        int x=t,mx=INF;
        while(x!=s){
            Edge &e=edges[p[x]];
            mx=min(mx,e.flow);
            x=e.from;
        }
        x=t;
        while(x!=s){
            edges[p[x]].flow-=mx;
            edges[p[x]^1].flow+=mx;
            x=edges[p[x]].from;
        }
        return mx;
    }
public:
	int head[maxn];
	Edge edges[maxm<<1];
    inline void clear(){
        memset(head,0,sizeof(head));
        len=1;
    }
    inline ISAP(void){
        memset(head,0,sizeof(head));
        len=1;
    }
    inline void ins(int from,int to,int flow,int rev=0){
        edges[++len]=((Edge){from,to,flow,head[from]});
        head[from]=len;
        edges[++len]=((Edge){to,from,rev,head[to]});
        head[to]=len;
    }
    inline int max_flow(int s,int t,int n){
        this->s=s,this->t=t,this->n=n;
        int flow=0;
        rev_bfs();
        memset(num,0,sizeof(num));
        for(int i=0; i<n; i++)
            num[dis[i]]++;
        int x=s;
        memcpy(cur,head,sizeof(cur));
        while(dis[s]<n){
        	
            if(x==t){
                flow+=augment();
                x=s;
            }
            bool tf=false;
            //当前弧优化
            for(register int &i=cur[x];i;i=edges[i].next){
                Edge &e=edges[i];
                if(e.flow>0&&dis[x]==dis[e.to]+1){
                    tf=true;
                    p[e.to]=i;
                    x=e.to;
                    break;
                }
            }
            
            if(!tf){
                int m=n-1;
                for(register int i=head[x];i;i=edges[i].next){
                    Edge &e=edges[i];
                    if(e.flow>0)
                        m=min(m,dis[e.to]);
                }
                //Gap优化
                if(--num[dis[x]]==0)
                    break;
                num[dis[x]=m+1]++;
                cur[x]=head[x];
                if(x!=s)
                    x=edges[p[x]].from;
            }
        }
        return flow;
    }
}solve;
//神级“读入优化”
inline char nc() {
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int read(int &sum) {
    char ch=nc();
    sum=0;
    while(!(ch>='0'&&ch<='9'))
        ch=nc();
    while(ch>='0'&&ch<='9')
        sum=(sum<<3)+(sum<<1)+(ch-48),ch=nc();
    return sum;
}
int n,m;
int main(void)
{
	solve.clear();
	scanf("%d%d",&m,&n);
	int s=n+1,t=n+2,x,y;
	for(int i=1;i<=m;i++)
		solve.ins(s,i,1);
	for(int i=m+1;i<=n;i++)
		solve.ins(i,t,1);
	while((~scanf("%d%d",&x,&y))&&x!=-1&&y!=-1)
		solve.ins(x,y,1);
	printf("%d\n",solve.max_flow(s,t,n+3));
	for(int i=1;i<=m;i++)
		for(int j=solve.head[i];j;j=solve.edges[j].next)
			if(solve.edges[j].to!=s&&solve.edges[j].to!=t&&solve.edges[j].flow==0)
				printf("%d %d\n",i,solve.edges[j].to);
	return 0;
}
```

---

## 作者：yqkkkkk (赞：1)

# **裸题**
# **[详解在此](http://www.cnblogs.com/Misser-X/p/8639280.html)**
附上代码：
```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
int m;
int n;
int x,y;
int ans;
int match[210];                                  //记录分配目标 
int put[110][3];                                 //输出 
bool book[210];                                  //记录剪枝 
bool way[210][210];                              //记录无向图的边 
inline int read()                                //快速读入 
{
	int sign=1,num=0;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')sign=-1;ch=getchar();}
	while(isdigit(ch)){num=num*10+(ch-'0');ch=getchar();}
	return sign*num;
}
void init()                                      //读入函数 
{
	m=read();
	n=read();
	while(x!=-1&&y!=-1)
	{
		x=read();                                //无向边存两次 
		y=read();
		way[x][y]=true;
		way[y][x]=true;
	}
}
bool dfs(int x)
{
	for(int y=m+n;y>0;--y)
	{
		if(way[x][y]&&book[y]==false)            //枚举点x的边 
		{
			book[y]=true;                        //记录点y已被查找（并非分配） 
			if(match[y]==0||dfs(match[y]))       //若y没有被分配或与y分配的人还有"退"的余地 
			{
				match[x]=y;                      //储存分配目标 
				match[y]=x;
				return true;
			}
		}
	}
	return false;
}
int main()                                       //看代码建议从mian函数看起 
{
	init();
	for(int i=1;i<=m+n;++i)                      //枚举点 
	{
		memset(book,false,sizeof(book));
		dfs(i);
	}
	for(int i=1;i<=m+n;++i)
		if(match[i]!=0&&match[match[i]]!=0)       //防止重复输出 
		{
			put[++ans][1]=i;
			put[ans][2]=match[i];
			match[match[i]]=0;
		}
	if(ans==0)                                   //特判 
	{
		puts("No Solution!");
		return 0;
	}
	printf("%d",ans); 
	for(int i=1;i<=ans;++i)
		printf("\n%d %d",put[i][1],put[i][2]);
}
```

---

## 作者：yybyyb (赞：1)

匈牙利算法的好题

直接匈牙利做就行了

而匈牙利算法中是有一个数组直接存储搭配方案的

因此只要求出了最大的匹配数

直接输出match即可

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define MAX 200
#define MAXL 200*200
struct Line
{
      int v,next;
}e[MAXL];
int h[MAX],cnt=0;
int sum=0;
int match[MAX];
int n,m,u,v;
bool vis[MAX];
inline void Add(int u,int v)
{
       e[cnt]=(Line){v,h[u]};
       h[u]=cnt++;
}
bool DFS(int u)
{
        for(int i=h[u];i!=-1;i=e[i].next)
        {
                int v=e[i].v;
                if(!vis[v])
                {
                       vis[v]=true;
                       if(!match[v]||DFS(match[v]))
                       {
                                  match[v]=u;
                                  return true;
                       }
                }
        }
        return false;
}
int main()
{
    memset(h,-1,sizeof(h));
    cin>>n>>m;
    while(true)
    {
          cin>>u>>v;
          if(u==-1)break;
          Add(u,v);
    }
    for(int i=1;i<=n;++i)
    {
           memset(vis,0,sizeof(vis));
           if(DFS(i))++sum;
    }
    cout<<sum<<endl;
    for(int i=n+1;i<=m;++i)
    {
            if(match[i])
            {
                   cout<<match[i]<<' '<<i<<endl;
            }
    }
    return 0;
}

```

---

## 作者：重回巅峰！ (赞：1)

何谓最大流？首先它必须是一个可行流；其次，它的流量必须达到最大。这样的流就称为最大流。譬如对图5-1而言，它的最大流如下：

下面探讨如何求得最大流。

在定义“可改进路”概念时，提到可以通过一定规则修改“可改进路”上弧的流量，可以使得总流量放大。下面我们就具体看一看是什么“规则”。

对可改进路P上的弧<vi, vj>，分为两种情况讨论：

第一种情况：<vi, vj>∈P+，可以令fij增加一个常数delta。必须满足fij + delta ≤ cij，即delta ≤ cij – fij。

第二种情况：<vi, vj>∈P-，可以令fij减少一个常数delta。必须满足fij - delta ≥ 0，即delta ≤ fij

根据以上分析可以得出delta的计算公式：

因为P+的每条弧都是非饱和弧，P-的每条弧都是非零流弧，所以delta > 0。

容易证明，按照如此规则修正流量，既可以使所有中间点都满足“流量守恒”（即输入量等于输出量），又可以使得总的流量有所增加（因为delta > 0）。

因此我们对于任意的可行流f，只要在f中能找到可改进路，那么必然可以将f改造成为流量更大的一个可行流。我们要求的是最大流，现在的问题是：倘若在f中找不到可改进路，是不是f就一定是最大流呢？

答案是肯定的。下面我们给出证明。

定理1 可行流f是最大流的充分必要条件是：f中不存在可改进路。

证明：

首先证明必要性：已知最大流f，求证f中不存在可改进路。

若最大流f中存在可改进路P，那么可以根据一定规则（详见上文）修改P中弧的流量。可以将f的流量放大，这与f是最大流矛盾。故必要性得证。

再证明充分性：已知流f，并且f中不存在可改进路，求证f是最大流。

我们定义顶点集合U, W如下：

（a） S∈U，

（b） 若x∈U，且fxy<cxy，则y∈U;

若x∈U，且fyx>0，则y∈U。

（这实际上就是可改进路的构造规则）

（c） W = V \ U。

由于f中不存在可改进路，所以T∈W；又S∈U，所以U、W是一个割切（U, W）。

按照U的定义，若x∈U，y∈W，则fxy = cxy。若x∈W，y∈U，则fxy = 0。

所以，

又因 v(f)≤C(U,W)

所以f是最大流。得证。

根据充分性证明中的有关结论，我们可以得到另外一条重要定理：

最大流最小割定理：最大流等于最小割，即max V(f) = min C(U, W)。

至此，我们可以轻松设计出求最大流的算法：

step 1. 令所有弧的流量为0，从而构造一个流量为0的可行流f（称作零流）。

step 2. 若f中找不到可改进路则转step 5；否则找到任意一条可改进路P。

step 3. 根据P求delta。

step 4. 以delta为改进量，更新可行流f。转step 2。

step 5. 算法结束。此时的f即为最大流。

对于此题，我们只需添加一个超级源点和一个超级汇点，并将这两个点分别连向飞行员和外籍飞行员的点，连边的容量置为1

飞行员和外籍飞行员中的连边的容量置为大于1的任何数就可以用最大流做了。


```cpp
type
  node=record toit,cap,rev,next:longint; end;
var
  road:array[0..1000000]of node;
  level,iter,list:array[-50..1000000] of longint;
  n,m,s,t,i,u,v,w,cnt,x,y,j:longint;
function min(a,b:longint):longint;
begin
  if a<b then exit(a) else exit(b);
end;
procedure add(u,v,w:longint);
begin
  inc(cnt);
  road[cnt].toit:=v;road[cnt].next:=list[u];road[cnt].cap:=w;
  list[u]:=cnt; road[cnt].rev:=cnt+1;
  inc(cnt);
  road[cnt].toit:=u;road[cnt].next:=list[v];road[cnt].cap:=0;
  list[v]:=cnt; road[cnt].rev:=cnt-1;
end;
procedure bfs(s:longint);
var w,h,t:longint;
  queue:array[0..1000000]of longint;
begin
  fillchar(level,sizeof(level),255);
  level[s]:=0;
  h:=1; t:=1; queue[1]:=s;
  while h<=t do
  begin
    w:=list[queue[h]];
    while w<>0 do
    begin
      if (road[w].cap>0)and(level[road[w].toit]<0) then
      begin
        level[road[w].toit]:=level[queue[h]]+1;
        inc(t);
        queue[t]:=road[w].toit;
      end;
      w:=road[w].next;
    end;
    inc(h);
  end;
end;
function dfs(v,t,f:longint):longint;
var w,d:longint;
begin
  if v=t then exit(f);
  iter[v]:=list[v];
  w:=iter[v];
  while w<>0 do
  begin
    if (road[w].cap>0)and(level[road[w].toit]>level[v]) then
    begin
      d:=dfs(road[w].toit,t,min(f,road[w].cap));
      if d>0 then
      begin
        dec(road[w].cap,d);
        inc(road[road[w].rev].cap,d);
        exit(d);
      end;
    end;
    iter[v]:=road[iter[v]].next;
    w:=road[w].next;
  end;
  exit(0);
end;
function max_flow(s,t:longint):longint;
var flow,f:longint;
begin
  flow:=0; f:=0;
  while true do
  begin
    bfs(s);
    if level[t]<0 then exit(flow);
    fillchar(iter,sizeof(iter),0);
    f:=dfs(s,t,maxlongint);
    while f<>0 do
    begin
      flow:=flow+f;
      f:=dfs(s,t,maxlongint);
    end;
  end;
  exit(0);
end;
begin
  readln(m,n);
  readln(x,y);
  while (x<>-1)and(y<>-1) do
  begin
    add(x,y,50000);
    readln(x,y);
  end;
  s:=m+n+50; t:=s+1;
  for i:=1 to m do add(s,i,1);
  for i:=1 to n do add(i+m,t,1);
  writeln(max_flow(s,t));
  for i:=1 to m  do
  begin
    j:=list[i];
    while j<>0 do
    begin
      if (road[j].cap<50000)and(road[j].toit<>t)and(road[j].toit<>s)
      then begin writeln(i,' ',road[j].toit); break; end;
      j:=road[j].next;
    end;
  end;
end.

```

---

## 作者：睿屿青衫 (赞：1)

一个匈牙利算法的裸题，但是有一些地方需要注意一下

##推荐使用前向星，比二维数组快（edge和add那里）

#有的题解咱也不知道咋AC的，反正是样例都不过，为什么？大体答案不错，可顺序颠倒，那怎么办？再加一个结构体，加一遍快排，把小号靠前

###前面的大佬们都说的很清楚了，我只点一下可能会困扰大家的地方，代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 2200000
using namespace std;
int n,qr,head[maxn],ans,link[maxn],vis[maxn],m,rq;
struct EDGE
{
    int next;
    int to;
}edge[maxn];
void add(int from,int to)
{
    edge[++qr].next=head[from];
    edge[qr].to=to;
    head[from]=qr;
}
int hungary(int x)
{
    for(int i=head[x];i!=-1;i=edge[i].next)
     {
         int v=edge[i].to;
         if(!vis[v])
          {
              vis[v]=1;
              if(!link[v]||hungary(link[v]))
               {
                   link[v]=x;
                   return 1;
               }
          }
     }
    return 0;
}
struct A
{
    int a,b;
}an[maxn];
int cmp(A aaa,A bbb)
{
    return aaa.a<bbb.a;
}
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    while(1)
     {
         int a,b;
         scanf("%d%d",&a,&b);
         if(a==-1&&b==-1) break;
         add(a,b);
     }
    for(int i=1;i<=n;i++)
     {
         memset(vis,0,sizeof(vis));
         if(hungary(i))
          ans++;
     }
    printf("%d\n",ans);
    for(int i=n+1;i<=m;i++) 
     {
         if(link[i])
          {
              an[++rq].a=link[i];
              an[rq].b=i;
          }
     }
    sort(an+1,an+rq+1,cmp);
    for(int i=1;i<=rq;i++)
     printf("%d %d\n",an[i].a,an[i].b);
    return 0;
}
```

---

## 作者：gzhffIThh (赞：0)

# 飞行员配对方案问题

[P2756](https://www.luogu.com.cn/problem/P2756)

### 简单的网络流模型——二分图匹配最大匹配，增加超级源点和超级汇点后求最大流

# 流程
- #### 定一个源点s， 汇点t
- #### 将s和外籍飞行员编号连一条边
- #### 将英国飞行员编号和t连一条边
- #### 找网络最大流（这里用了EK）
- #### 每次找到增广路，就更新相应的飞行员，最后输出即可（思考为什么）

# code
```cpp
//增加超级源点和超级汇点后求最大流 
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;
const int MAXM = 105;

int n, m, s, t, x, y;

int head[MAXN], nxt[MAXN * MAXN], v[MAXN * MAXN], w[MAXN * MAXN], cnt = 1;
void add(int x, int y, int z) {
	nxt[++cnt] = head[x]; head[x] = cnt; v[cnt] = y; w[cnt] = z;
	nxt[++cnt] = head[y]; head[y] = cnt; v[cnt] = x; w[cnt] = 0;
}

int maxflow;
int pre[MAXN], used[MAXN];
int suc[MAXN];//记录配对的飞行员 

bool bfs() {
	memset(pre, 0, sizeof(pre));
	memset(used, 0, sizeof(used));
	queue<int> q;
	q.push(s);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for (int i = head[u]; i ; i = nxt[i]) {
			if(w[i]) {
				int _v = v[i];
				if(used[_v]) continue;
				q.push(_v);
				used[_v] = 1;
				pre[_v] = i;
				if(_v == t) return 1;
			} 
		}
	}
	
	return 0;
}

int main() {
	
	scanf("%d %d", &m, &n);
	s = n + 1, t = n + 2;
	for (int i = 1; i <= m; i++) add(s, i, 1);
	for (int i = m + 1; i <= n; i++) add(i, t, 1);
	while(scanf("%d %d", &x, &y)) {
		if(x == -1 && y == -1) break;
		add(x, y, 1);
	} 
	while(bfs()) {
		int tmp = t; int minx = 1 << 30;
		
		while(tmp != s) {
			int i = pre[tmp];
			minx = min(w[i], minx);
			if(tmp != t && tmp > m) suc[tmp] = v[i ^ 1];
			tmp = v[i ^ 1]; 
		}

		tmp = t; maxflow += minx;
	
		while(tmp != s) {
			int i = pre[tmp];
			w[i] -= minx;
			w[i ^ 1] += minx;
			tmp = v[i ^ 1];
		}
			
	}
	
	if(maxflow == 0) printf("No Solution!\n");
	else {
		printf("%d\n", maxflow);
		for (int i = m + 1; i <= n; i++) {
			if(suc[i]) {
				printf("%d %d\n", suc[i], i);
			}
		}
	}
	
	
	return 0;
}
```


---

## 作者：离子键Ionic_Bond (赞：0)

## [匈牙利算法]
我在网络流24题里发个二分图匹配题解有点不要脸哈

~~但是网络瘤是啥~~

匈牙利算法求二分图最大匹配，~~因为数据水~~所以建了双向边，让后m+n地跑了一遍，把英国军队的编号减去m就行了

$lst[i]$表示$i$最后匹配到的点，因为建的是双向边，所以输出匹配数时要除以二；

关于方案的输出，直接判一下$lst[i]$不等于零且$lst[i]$和$i$均未匹配过就输出就好啦
## [代码]
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
using namespace std;
int head[100100],vis[333],lst[333],n,cnt,m,f[1001];
struct edg
{
	int u,v,nxt;
}e[100100];
void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	e[cnt].v=v;
	e[cnt].u=u;
	head[u]=cnt;
}
bool Mx(int u)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(vis[v])continue;
		vis[v]=1;
		if(!lst[v]||Mx(lst[v]))
		{
			lst[v]=u;
			return 1;
		}
	}
	return 0;
}//匈牙利算法
int main()
{
	scanf("%d%d",&m,&n);
	while(1)
	{
		int uu,vv;
		scanf("%d%d",&uu,&vv);
		if(uu==-1&&vv==-1)break;
		add(uu,vv+m);
		add(vv+m,uu);
	}
	int ans=0;
	for(int i=1;i<=m+n;i++)
	{
		memset(vis,0,sizeof(vis));
		ans+=Mx(i);
	}//统计匹配数
	printf("%d\n",ans/2);//记得除以二
	for(int i=1;i<=m+n;i++)
	{
		if(lst[i]&&!f[i]&&!f[lst[i]])printf("%d %d\n",i,lst[i]-m),f[i]=1,f[lst[i]]=1;
	}//输出方案
}
```

---

## 作者：foreverlasting (赞：0)

[网络流24题大综合](https://www.luogu.org/blog/foreverlasting/wang-lao-liu-24-ti-tai-zeng-ge)

这应该是一道比较简单的网络流了（其实是二分图啦）

首先S向一个系列的飞行员连一条容量为1的边，另一个系列的飞行员向T连一条容量为1的边，两个系列间的飞行员互相连容量为inf的边，跑个最大流就好了。

然后证明正确性。

每一个飞行员只能与一个搭配，这是容量为1的限定。其他随意搭配，这是容量为inf的限定。所以是正确的。

找飞行员直接找反向边的流量就行了。

code：
```
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
inline int read() {
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline void write(res w) {
    if(w<0)putchar('-'),w=-w;
    if(w>9)write(w/10);
    putchar(w%10+'0');
}
const int N=1e6+10;
struct mdzz {
    int next,to,val;
} edge[N];
int s,t,cnt,n,m,head[N],deep[N],cur[N];
inline void init() {
    cnt=-1;
    memset(head,-1,sizeof(head));
}
inline void add(res u,res v,res w) {
    edge[++cnt].to=v;
    edge[cnt].next=head[u];
    edge[cnt].val=w;
    head[u]=cnt;
}
inline int bfs() {
    memset(deep,0,sizeof(deep));
    queue<int> q;
    while(!q.empty())q.pop();
    deep[s]=1;
    q.push(s);
    while(!q.empty()) {
        res u=q.front();
        q.pop();
        for(res i=head[u]; ~i; i=edge[i].next)
            if(deep[edge[i].to]==0&&edge[i].val>0)
                deep[edge[i].to]=deep[u]+1,q.push(edge[i].to);
    }
    if(deep[t])return 1;
    return 0;
}
inline int dfs(res u,res flow) {
    if(u==t)return flow;
    for(res& i=cur[u]; ~i; i=edge[i].next) {
        if(deep[edge[i].to]==deep[u]+1&&edge[i].val) {
            res f=dfs(edge[i].to,min(flow,edge[i].val));
            if(f>0) {
                edge[i].val-=f;
                edge[i^1].val+=f;
                return f;
            }
        }
    }
    return 0;
}
inline int dinic() {
    res ans=0;
    while(bfs()) {
        for(res i=s; i<=t; i++)cur[i]=head[i];
        while(int f=dfs(s,inf))ans+=f;
    }
    return ans;
}
int x,y,ans;
int main(){
    m=read(),n=read();
    init();
    s=0,t=n+1;
    for(res i=1;i<=m;i++)add(s,i,1),add(i,s,0);
    for(res i=m+1;i<=n;i++)add(i,t,1),add(t,i,0);
    while(scanf("%d%d",&x,&y)==2&&x!=-1&&y!=-1)add(x,y,1),add(y,x,0);
	ans=dinic();
	if(!ans) puts("No answer");
    else{
        write(ans),puts("");
        for(res i=1;i<=m;i++)
            for(res ed=head[i];~ed;ed=edge[ed].next) 
                if(edge[ed].val==0&&edge[ed^1].val==1&&i!=s&&i!=t&&edge[ed].to!=s&&edge[ed].to!=t) printf("%d %d\n",i,edge[ed].to);
    }
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：0)

调了半天，最后发现是读优打错了= =，结果还过了一个点= =


好吧，又是一道裸的二分图匹配，我还是不喜欢打匈牙利，所以有弄了个网络流ISAP，这个模板今儿打了4遍了，感觉都能背了，题解也写了4个了，我直接放那几道题的题解吧：


简单的介绍一下ISAP吧，其实ISAP就是将Dinic的bfs一次性修改层次图改为回溯时就修改，虽然理论复杂度仍然是O(v^2\*e)，等于dinic，但实际效果上面也给出了。


加入两个数组，num与fa，


fa记录增广路每个节点的前驱。


num记录到汇点的距离个数，便于进行gap优化——就是如果存在一个i<n使得num[i]为0则说明源点与汇点已经不连通的了，立刻中断搜索。


然后也就没啥了，就类似一个非递归式的Dinic，实现时有些细节要注意一下就好了。看看程序应该能理解。


其实网络流算法大多数是不需要过于深入理解的，模板记住就好了。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=20100;
int d[N],a[N],num[N],cur[N],fa[N];
int n,m,S,T,EdgeCnt=0;
struct Edge{
    int to,cap,next;
}e[N*2];
queue<int> Q;
int read(){//既然都为了时间快，写ISAP了，干脆写个读优的
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void addedge(int u,int v,int w){
    int &p=EdgeCnt;
    e[p].to=v;e[p].cap=w;e[p].next=a[u];
    a[u]=p++;
}
void BFS(){
    for (int i=1;i<=n;i++)d[i]=n;
    Q.push(T);d[T]=0;
    while (!Q.empty()){
        int u=Q.front();Q.pop();
        for (int p=a[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (e[p^1].cap && d[v]>d[u]+1){//注意，这里是从汇点开始倒着bfs的，所以当前的边是反向弧，必须要p^1切换到正向边
                d[v]=d[u]+1;
                Q.push(v);
            }
        }
    }
}
int Augment(){
    int u=T,f=INF;
    while (u!=S){
        u=fa[u];
        f=min(f,e[cur[u]].cap);
    }
    u=T;
    while (u!=S){
        u=fa[u];
        e[cur[u]].cap-=f;
        e[cur[u]^1].cap+=f;
    }
    return f;
```
}//增广，就不用解释了吧？
```cpp
int MaxFlow(){
    n+=2;
    memset(num,0,sizeof(num));
    BFS();//预处理第一次的距离标号
    for (int i=1;i<=n;i++)num[d[i]]++,cur[i]=a[i];
    int u=S,flow=0;
    while (d[S]<n){//既然都为了时间快，写ISAP了，干脆写成非递归的
        if (u==T){
            flow+=Augment();
            u=S;//走到汇点了，增广，在回到源点
        }
        bool done=false;//是否前进的标志
        for (int p=cur[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (e[p].cap && d[u]==d[v]+1){
                done=true;fa[v]=u;cur[u]=p;u=v;//cur与fa类似递归时的栈保存当前选择了那条边，回溯时就不会走重复的路，前进
                break;
            }
        }
        if (!done){//回溯
            int m=n-1;
            for (int p=a[u];p!=-1;p=e[p].next){
                int v=e[p].to;
                if (e[p].cap)m=min(m,d[v]);
            }
            if (--num[d[u]]==0)break;//gap优化
            num[d[u]=m+1]++;//重置距离标号
            cur[u]=a[u];
            if (u!=S)u=fa[u];
        }
    }
    return flow;
}
int main(){
    m=read(),n=read();
    memset(a,0xff,sizeof(a));
    int u=read(),v=read();
    while (u+v>0){
        addedge(u,v,1);
        addedge(v,u,0);
        u=read(),v=read();
    }
    S=n+1;T=n+2;
    for (int i=1;i<=m;i++)addedge(S,i,1),addedge(i,S,0);
    for (int i=m+1;i<=n;i++)addedge(i,T,1),addedge(T,i,0);//建图，不解释
    printf("%d\n",MaxFlow());
    for (int u=1;u<=m;u++){
        for (int p=a[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (!e[p].cap && v<=n-2)printf("%d %d\n",u,v);
        }
    }
    return 0;
}
```

---

## 作者：Creeper_LKF (赞：0)

其实也可以用网络流做，但是网络流要比匈牙利算法慢上许多，但如果每两个匹配的飞行员有权值的话KM算法就很难写了

```cpp
#include<bits/stdc++.h>
#define INF 536870912
using namespace std;
int m,n,s,t;
int matrix[250][250],dis[250],cur[250];//邻接矩阵
namespace Dinic{//Dinic的标准套路+优化，用邻接矩阵写更清爽。其中matrix数组的功能很强大，可以检查连边，储存残量网络，正向边反向边通吃，免初始化......（赶紧拥有吧（滑稽））
    inline bool BFS(){
        queue<int> mession;
        memset(dis,-1,sizeof(dis));
        mession.push(s);
        dis[s]=0;
        int now;
        while(!mession.empty()){
            now=mession.front(),mession.pop();
            for(int i=s;i<=t;i++){
                if(dis[i]<0&&matrix[now][i]>0){//如果这个点没有被计算过分层且存在这条连边且残量>)
                    dis[i]=dis[now]+1;
                    mession.push(i);
                }
            }
        }
        if(dis[t]>0) return true;
        return false;//这个时候到终点已经没有可增广的流量了
    }
    inline int DFS(int depth,int f){
        if(depth==t||f==0) return f;//不知名的优化，却很有用
        for(int &i=cur[depth];i<=t;i++){//当前弧优化
            int ns=0;
            if(matrix[depth][i]>0&&dis[i]==dis[depth]+1&&(ns=DFS(i,min(f,matrix[depth][i])))){//如果连边且残量>0且满足层数要求且可以增广
                matrix[depth][i]-=ns;//增广
                matrix[i][depth]+=ns;
                return ns;
            }
        }
        return 0;
    }
    inline int dinic(){
        int ans=0,ns;
        while(BFS()){
            memset(cur,s,sizeof(cur));
            while((ns=DFS(s,INF))&&(ans+=ns));
        }
        return ans;
    }
}
namespace IN{
    inline int read(){
        int num=0;
        char c;
        while(isspace(c=getchar()));
        if(c=='-') return -1;//判断结束（这个读入优化很灵活）
        while((num=num*10+c-48)&&isdigit(c=getchar()));
        return num;
    }
    inline void init(){
        m=read(),n=read(),s=0,t=m+n+1;
        int x,y;
        while((x=read())!=-1&&(y=read())){
            matrix[x][y]=INF;//允许本地飞行员到外籍飞行员的连边（取INF是为了保证流量流通），同时检测是否有流量连向两飞行员
            matrix[s][x]=matrix[y][t]=1;//建立每一本地飞行员到超级源点和外籍飞行员到超级汇点，容量为1（可以理解成每一个人只能与一人配对）
        }
    }
}
int main(){
    IN::init();
    printf("%d\n",Dinic::dinic());
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(matrix[i][j])//如果逆向边有流量则两点连边
                printf("%d %d\n",j,i);
    return 0;
}

```

---

## 作者：巨型方块 (赞：0)

这道题用匈牙利算法直接水掉的；

毕竟匈牙利本来就是记录方案的；

但是你用网络流这个就不简单了；

另外匈牙利可以先模版题；

然后这一题好像没有No Solution!


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
struct cs{int to,nxt;}a[N*N*5];
bool vi[N];
int head[N],ll;
int link[N];
int m,n,ans,x,y;
bool dfs(int x){
    for(int k=head[x];k;k=a[k].nxt)
        if(!vi[a[k].to]){
            vi[a[k].to]=1;
            if(!link[a[k].to]||dfs(link[a[k].to])){
                link[a[k].to]=x;return 1;
            }
        }return 0;
}
int main()
{
    scanf("%d%d",&m,&n);
    for(scanf("%d%d",&x,&y);x!=-1;scanf("%d%d",&x,&y)){
        a[++ll].to=y;
        a[ll].nxt=head[x];
        head[x]=ll;
    }
    for(int i=1;i<=m;i++){
        memset(vi,0,sizeof vi);
        if(dfs(i))ans++;
    }
    if(!ans){printf("No Solution!");return 0;}
    printf("%d\n",ans);
    for(int i=m+1;i<=n;i++)
        if(link[i])printf("%d %d\n",link[i],i);
}

```

---

## 作者：kakakaka (赞：0)

思路和楼主们是一样的，这道题网络流可以，但是我用的是二分图（写起来简单一点）

然后看到没有C++代码就直接上了，算法就不多说了。

一下是AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,m;
int head[10001],size;
struct node
{
    int  next,to;
}edge[10001];
void putin(int from,int to)
{
    size++;
    edge[size].next=head[from];
    edge[size].to=to;
    head[from]=size;
}
int match[10001];
bool vis[10001];
bool dfs(int root)
{
    int i;
    for(i=head[root];i!=-1;i=edge[i].next)
    {
        int y=edge[i].to;
        if(vis[y]==0)
        {
            vis[y]=1;
            if(match[y]==0||dfs(match[y]))
            {
                match[y]=root;
                match[root]=y;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    int i,j,from,to;
    scanf("%d%d",&n,&m);
    memset(head,-1,sizeof(head));
    while(1)
    {
        scanf("%d%d",&from,&to);
        if(from==-1)break;
        putin(from,to);
    }
    int ans=0;
    for(i=1;i<=m;i++)
    {
        if(match[i]==0)
        {
            memset(vis,0,sizeof(vis));
            if(dfs(i))ans++;
        }
    }
    printf("%d\n",ans);
    for(i=1;i<=n;i++)
    if(match[i])printf("%d %d\n",i,match[i]);
    return 0;
}
```

---


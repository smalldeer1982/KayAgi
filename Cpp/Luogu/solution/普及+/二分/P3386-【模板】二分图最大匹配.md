# 【模板】二分图最大匹配

## 题目描述

给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。

左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n, m \leq 500$。
- $1 \leq e \leq 5 \times 10^4$。
- $1 \leq u \leq n$，$1 \leq v \leq m$。

**不保证给出的图没有重边**。


## 样例 #1

### 输入

```
1 1 1
1 1
```

### 输出

```
1```

## 样例 #2

### 输入

```
4 2 7
3 1
1 2
3 2
1 1
4 2
4 1
1 1
```

### 输出

```
2
```

# 题解

## 作者：一扶苏一 (赞：741)

- 2020/3/27 upd：几乎重写了整份题解，只保留了原题解的图示部分。重写了一份能看的代码。

## Task

给定一张二分图，其左部点集大小为 $n$，右部点集大小为 $m$，请求出其最大匹配。

## Algorithm

首先说明几个概念。

- 一张图 $G$ 是**二分图**当且仅当 $G$ 的点集 $V$ 可以分为两个点集 $V_0, V_1$，满足 $V_0 \cup V_1 = V$，$V_0 \cap V_1 = \emptyset$，且对于 $G$ 的每条边 $e$，其两个端点分别属于不同的点集。

  用自然语言来描述就是，一张图是二分图，当且仅当它的点可以被分成两部分，而这张图上的所有边的两个端点，都分属不同的部分。

  我们称这两个点集，一个叫左部，一个叫右部。左部中的点叫左部点；右部中的点叫右部点。

- 图 $G$ 的一个匹配是 $G$ 的一个边集 $E_0$，满足 $E_0$ 中的所有边都没有公共端点。

  用自然语言来描述就是，一张图的一个匹配是一些没有公共端点的边。

  可以想象，对于一个二分图而言，显然一个匹配是对于每一个左部点，连一条边向一个右部点，或者不向右部点连边。但是每个左部点不会对应两个或以上的右部点。

常用的二分图匹配算法是匈牙利算法，其正确性基于 hall 定理，本质是不断寻找增广路来扩大匹配数。但是其正确性证明比较复杂，在此略去。

匈牙利算法的过程是，枚举每一个左部点 $u$ ，然后枚举该左部点连出的边，对于一个出点 $v$，如果它没有被先前的左部点匹配，那么直接将 $u$ 匹配 $v$，否则尝试让 $v$ 的“原配”左部点去匹配其他右部点，如果“原配”匹配到了其他点，那么将 $u$ 匹配 $v$，否则 $u$ 失配。

尝试让“原配”寻找其他匹配的过程可以递归进行。需要注意的是，在一轮递归中，每个右部点只能被访问一次。

算法的时间复杂度为 $O(n \times e + m)$，其中 $n$ 是左部点个数，$e$ 是图的边数，$m$ 是右部点个数。

不难发现其实交换左右部点后的最大匹配数是一样的，而对于 $m < n$，有 $m \times e + n < n \times e + m$。所以有一个小 trick 是当右部点的个数比左部点多的时候，交换左右部能有更高的效率。

下面是**喜 闻 乐 见**的算法图示。

![图一](https://cdn.luogu.com.cn/upload/pic/18673.png)（图一）


在图一中，每个人物代表一个点，连线代表可以处的 cp（即可以进行的匹配）。

现在进行第一步：
![图二](https://cdn.luogu.com.cn/upload/pic/18674.png)（图二）


在图二中，我们优先满足左侧标号小的点（男一黄少天）的期望 cp，于是我们把黄少和安康鱼（芙蕾雅）连在一起，已经匹配的边染成蓝色。

现在进行第二步：
![图三](https://cdn.luogu.com.cn/upload/pic/18675.png)（图三）

在图三中，我们满足男二叶修的匹配，非常尴尬的是叶修也喜欢安康鱼，~~于是叶修绿了少天~~额不对，反正我们把叶修和安康鱼匹配在一起，少天表示没事我还有和泉纱雾，于是我们把少天的匹配改为和泉纱雾。

现在进行第三步：
![图四](https://cdn.luogu.com.cn/upload/pic/18676.png)（图四）

在图四中，张新杰表示安康鱼蛮好看的啊，于是张新杰匹配到了安康鱼，而叶修匹配到了初音。

再来看男四 孙翔（~~真的不是我针对他emmm~~）


孙翔也喜欢安康鱼（emm安康鱼怎么这么受欢迎）他想让张新杰换一个匹配，但是张新杰不答应：我给你让了我就没 cp 了诶，所以不给。

于是孙翔失配了。

以上就是匈牙利算法的过程。不难发现，匈牙利算法就是一个~~绿与被绿~~协商与匹配的过程。

所以这张图的最大匹配为 $3$。

观察图可以得出：

1. 如果后来的和以前的发生矛盾，则以前的~~被绿~~优先退让。
2. 如果以前的退让之后没有cp可处，则以前的拒绝退让，新来的去寻找下一个匹配。
3. 如果新来的谁也匹配不上了，那就这么单着吧。

以上，就是匈牙利算法的全部内容

## Code

```cpp
#include <cstdio>
#include <vector>

const int maxn = 1005;

int n, m, t;
int mch[maxn], vistime[maxn];

std::vector<int> e[maxn];

bool dfs(const int u, const int tag);

int main() {
  scanf("%d %d %d", &n, &m, &t);
  for (int u, v; t; --t) {
    scanf("%d %d", &u, &v);
    e[u].push_back(v);
  }
  int ans = 0;
  for (int i = 1; i <= n; ++i) if (dfs(i, i)) {
    ++ans;
  }
  printf("%d\n", ans);
}

bool dfs(const int u, const int tag) {
  if (vistime[u] == tag) return false;
  vistime[u] = tag;
  for (auto v : e[u]) if ((mch[v] == 0) || dfs(mch[v], tag)) {
    mch[v] = u;
    return true;
  }
  return false;
}
```

另外，二分图匹配可以使用 dinic 算法，将复杂度降低至$O(n~\sqrt e)$。具体的，建立超级源点和超级汇点，源点向左侧连边，右侧向汇点连边。左右之间连边。上述边的流量都是 $1$ 。由于 $s$ 到点左侧任意一点 $u$ 的流量是$1$，所以 $u$ 最多被选择一次。同理右边的点也最多被选择一次。于是这个图的网络最大流即为该二分图的最大匹配。

---

## 作者：Law_Aias (赞：125)

# 二分图的最大匹配：匈牙利算法

讲之前本蒟蒻先普及一个重要**专业名词**
## 增广路。

如果你仔细读过并画过图，不难发现如果找到一条增广路，那么配对的个数就会加1。
所以说，增广路的本质其实就是一条路径的起点和终点都未配对的点的边。



------------

## 匈牙利算法：

这个叫匈牙利算法(Hungarian method)的东西是由匈牙利数学家Edmonds于1965年提出，所以叫**匈牙利算法**。匈牙利算法是二分图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。

### 复杂度：
时间复杂度 : 邻接矩阵最坏为O(n3)    
邻接表： O(mn)  
空间复杂度 : 邻接矩阵：O(n2)    	   
邻接表： O(n+m)

## 另一个重要概念：二分图
二分图是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集，则称图G为一个二分图。  
~~学过高中数学的话应该能看懂我在说什么（逃~~

简而言之，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。满足这样的图就叫二分图。

#### 但我们怎么判断一个图是不是二分图？？？
其实也不难，用红蓝点的方法就行。首先讲任意的一个顶点染成红色，再把这个点相邻的顶点染成蓝色，如果按照这种染色方式可以将所有的顶点全部着色，并且相邻的顶点的颜色不同，那么该图就是一个二分图。  
##### 这里贴一下代码
```cpp
#define MAXV 1000//这里应该根据题目自定

vector<int> G[MAXV];  //图 
int V;                       //顶点数 
int color[MAXV];  //顶点的颜色 （1 or -1） 


//顶点v，颜色c 
bool dfs(int v,int c){
    color[v] = c;
    //把当前顶点相邻的顶点扫一遍 
    for(int i = 0;i < G[v].size(); i++){
        //如果相邻顶点已经被染成同色了,说明不是二分图 
        if(color[G[v][i]] == c) return false;
        //如果相邻顶点没有被染色,染成-c,看相邻顶点是否满足要求 
        if(color[G[v][i]] == 0 && !dfs(G[v][i],-c)) return false;
    }
    //如果都没问题，说明当前顶点能访问到的顶点可以形成二分图 
    return true;
}

void solve(){
    //可能是不连通图，所以每个顶点都要dfs一次 
    for(int i = 0;i < V; i++){
        if(color[i] == 0){
            //第一个点颜色为 1 
            if(!dfs(i,1)){
                cout << "No" << endl;
                return;
            }
        }
    }
}
```

# 这才是正文！！！
既然上面本蒟蒻已经介绍完了有关二分图的知识，**那下面该讲下匈牙利算法了**！！！

根据上文的描述，既然增广路的作用是“改进匹配方案”（即增加配对数），那么如果我们已经找到了一种匹配方案，不难发现如果在当前匹配方案下再也找不到任何增广路的话，那么当前匹配就是二分图的最大匹配，算法如下。

1.首先从任意的一个未配对的点u开始，从点u的边中任意选一条边（假设这条边是从u->v）开始配对。如果点v未配对，则配对成功，这是便找到了一条增广路。如果点v已经被配对，就去尝试“连锁反应”，如果这时尝试成功，就更新原来的配对关系。   
所以这里要用一个matched[v] = u。配对成功就将配对数加1,。

2.如果刚才所选的边配对失败，那就要从点u的边中重新选一条边重新去试。直到点u
配对成功，或尝试过点u的所有边为止。

3.接下来就继续对剩下的未配对过的点一一进行配对，直到所有的点都已经尝试完毕，找不到新的增广路为止。

4.输出配对数。

## CODE：
```cpp
//如果你已经读完题，请自动从int main()处开始阅读 
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>

#define N 2010

using namespace std;

int n,m,e,ans;
int vis[N][N];
int ask[N],matched[N];

inline bool found(int x){ //dfs找增广路 
    for (int i = 1 ; i <= m ; i++)
      if (vis[x][i]){
        if (ask[i]) 
			continue;
        ask[i] = 1;
        if (!matched[i] || found(matched[i])) { 
			matched[i] = x ; 
			return true;
		}
      }
    return false;
}

inline void match(){
    int cnt = 0;//cnt是计数器 
    memset(matched,0,sizeof(matched));
    for (int i = 1 ; i <= n ; i++){
      memset(ask,0,sizeof(ask));
      if (found(i)) 
	  	cnt++;	//找到了就加1 
    }
    ans = cnt;
}
//从这里向下看起 
int main(){
    scanf("%d%d%d",&n,&m,&e);//结点个数分别为n,m，边数为e
    for (int i = 1 ; i <= e ; i++){
      int x,y;
      scanf("%d%d",&x,&y);
      vis[x][y] = 1;
    }
    match();///匈牙利算法，见上 
    printf("%d \n",ans);
    return 0;
}
```
~~完结撒花（逃！！！~~

---

## 作者：Darkness_ (赞：71)

### 二分图的概念

  二分图又称作二部图，是图论中的一种特殊模型。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边(i,j)所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。（源自[百度-二分图](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin)）

  ![](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=0b584ad6a8773912c0268263c8188675/3c6d55fbb2fb43169079761121a4462309f7d373.jpg)

  如上图就是一个标准的二分图。

### 最大匹配与增广路的概念

  给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。(源自[百度-二分图匹配](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/9089174?fr=aladdin))

  最大匹配即是选择其中边数最大的子集的图。

  完全匹配，也叫做完备匹配，即某个匹配中，每个顶点都和某条边相关联。

  好的，现在介绍完一个基本概念，我们就要着手解决如何求解最大匹配的问题了。

  若要找出二分图中的最大匹配，最朴素的方法就是找出所有的匹配并一一比较，但这种方法的时间复杂度是边数的指数级的，不能满足数据范围较大的问题。因此，我们需要找出一个更优的方法求解。

  在寻找这更优的方法前，我们需要先了解增广路的概念：增广路，也称增广轨或交错轨。若P是图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径(举例来说，有A、B集合，增广路由A中一个点通向B中一个点，再由B中这个点通向A中一个点……交替进行)。（源自[百度-增广路](https://baike.baidu.com/item/%E5%A2%9E%E5%B9%BF%E8%B7%AF/1332250?fr=aladdin)）

  由增广路的定义我们可以推出下述三个结论：

1. P的路径长度必定为奇数，第一条边和最后一条边都不属于M。
2. 经过取反操作可以得到一个更大的匹配M’，边数为M的边数+1。
3. M为G的最大匹配当且仅当不存在相对于M的增广路径。

  ![](https://cdn.luogu.com.cn/upload/pic/15251.png)

  如图为一个二分图增广路集合。

### 匈牙利算法

  匈牙利算法就是用增广路求最大匹配问题(由匈牙利数学家Edmonds于1965年提出)

  算法的主要步骤为：
1. 将M设置为空；
2. 找出一条增广路径P，通过取反操作获得更大的匹配M’代替M；
3. 重复2操作直到找不出增广路径为止；

  ![](https://cdn.luogu.com.cn/upload/pic/15252.png)

  如上图，A-a,a-B,B-b,b-D是一个增广路集合。

  那么如果在执行2操作时发现有冲突了怎么办？算法所采取的是一种称作“协商”的手段。关于“协商”这一部分的详解可以查看[匈牙利算法](http://blog.csdn.net/dark_scope/article/details/8880547)

下面给出匈牙利算法([洛谷P3386](https://www.luogu.org/problemnew/show/P3386))的代码

```cpp
/****************
Keep your dreams.
	 by Darkness_
****************/

#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define MAXN 1005
#define INF 0X3F3F3F3F
#define MOD 1000000007
#define QWQ puts("QWQ")

int read(int &x) {
	x=0;
	int f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-')
			f=-f;
		if (ch==EOF)
			return -1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	x*=f;
	return 0;
}

int n,m,e,x,y,ans;
int con_x[MAXN],con_y[MAXN];
bool vis[MAXN],flag[MAXN][MAXN];

bool dfs(int x) {
	for (int y=1;y<=m;y++)
		if (flag[x][y]&&!vis[y]) {
			vis[y]=true;
			if (con_y[y]==-1||dfs(con_y[y])) {
				con_x[x]=y;
				con_y[y]=x;
				return true;
			}
		}
	return false;
}

void Maxmatch() {
	memset(con_x,-1,sizeof(con_x));
	memset(con_y,-1,sizeof(con_y));
	for (int i=1;i<=n;i++)
		//if (con_x[i]==-1)//此句应去除，不知道为什么会错（逃
		{
			memset(vis,false,sizeof(vis));
			ans+=dfs(i);
		}
}

int main() {
	read(n);
	read(m);
	read(e);
	for (int i=1;i<=e;i++) {
		read(x);
		read(y);
		if (x>=1&&y>=1&&x<=n&&y<=m)
			flag[x][y]=true;
	}
	Maxmatch();
	printf("%d\n",ans);
	return 0;
}

```
### 二分图中的其他性质
  关于二分图中其他的性质有：
1. 二分图的最小顶点覆盖
   最小顶点覆盖要求用最少的点(U或V中都行)，让每条边都至少和其中一个点关联。
   Knoig定理：二分图的最小顶点覆盖数等于二分图的最大匹配数。
2. DAG图的最小路径覆盖
   用尽量少的不相交简单路径覆盖有向无环图(DAG)G的所有顶点。
   引理：DAG图的最小路径覆盖数=节点数(n)-最大匹配数(m)
3. 二分图的最大独立集
   在Ｎ个点的图G中选出m个点，使这m个点两两之间没有边．求m最大值。
   引理：二分图的最大独立集数 = 节点数(n)—最大匹配数(m)

  关于二分图匈利亚算法的介绍就到这里告一段落了，但其实更重要的是建立模型，而这就需要多做题目来找到感觉了。

祝大家Rp++！

--------
在HDU上做一道二分图的题目时[here](http://acm.hdu.edu.cn/showproblem.php?pid=5943)，出现了莫名奇妙的错误，在经过对拍之后，发现此模板对于某一些奇怪的数据存在一定的差错，Maxmatch函数中的一句语句应去除，具体已在代码中注释（顺便改了一下代码格式hhhh）。

P.S.:我把两种写法的二分图对拍了一下，发现没有什么错误。不知道是为什么……痛苦万分

不过以后还是去掉吧……也许就有什么毒瘤数据呢了……


---

## 作者：Arcturus1350 (赞：56)

首先呢声明一下，本宝宝发这篇题解只是为了（goto a;）

个人还是比较喜欢跑dinic暴力跑最大流。。。竟然比匈牙利还快。。
如果说不懂网络流的~~蒟蒻~~大佬们。
可以看看[这个](https://www.cnblogs.com/SYCstudio/p/7260613.html)（反正我就是在这篇文章看懂的）

好啦，言归正传。

a:本宝宝想解释一下为什么这道题可以用网络流水过233....
首先我们看看二分图的概念。标准概念是：

简单的说，一个图被分成了两部分，相同的部分没有边，那这个图就是二分图，二分图是特殊的图。（摘自[这里](http://blog.csdn.net/thundermrbird/article/details/52231639)）

如果你看不懂的话，那么请看某大佬给宝宝讲的时候的解释：
~~一群汉子和一群妹子匹配。没有基友也没百合，不能开后宫，这就是二分图。最大匹配就是求能组成的CP最多多少对~~  可能题解不过就是因为这句话233（逃~）

网络流最重要的是要建图！建图！建图！那么看看这道题怎么建图。
我们发现对于左边的n个点和右边的m个点。如果说最好的情况下。匹配的~~个~~对数是$min(m,n)$也就是说，我们左边尽可能的通过已有的边流到右半部分统计一下流到右半部分的容量最大值就是答案了（当然是要边的容量都是1的时候最简单了）。

所以我们将源点S设在左半部分左边，向左边所有的点连一条容量为1的边。汇点T设在右半部分的右边。从所有的右半部分的点连向汇点一条容量为1的边，暴力跑一边dicnic就好啦。

所以建边代码：
```cpp
    scanf("%d%d%d",&n1,&m1,&e1);
    n=n1+m1+2;//源点编号为1，汇点编号为总点数+1
    for(int i=1;i<=n1;i++)
    {
        add(1,i+1,1);//空过源点，所以i+1，这里在连接源点和左部点。
        add(i+1,1,1);
    }
    for(int i=1;i<=e1;i++)
    {
    	int u,v;//连已有的边
    	scanf("%d%d",&u,&v);
    	if(u<=n1&&v<=m1)
    	add(u+1,v+n1+1,1),
    	add(v+n1+1,u+1,1);
    }
    for(int i=1;i<=m1;i++)
    {
        add(i+n1+1,n,1);//连右部点和汇点
        add(n,i+n1+1,1);
    }
```
好啦完整代码奉上：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m;
int cnt=2;
int alist[6000001];
struct data{
    int v;int next;int value;
}edge[6000001];
void add(int u,int v,int value)
{
    edge[cnt].v=v;
    edge[cnt].value=value;
    edge[cnt].next=alist[u];
    alist[u]=cnt++;
    return ;
}
int h[1000001];
int q[1000001];
//dicnic暴力参见上面提到的博客。
bool bfs()
{
    int x,next;
    memset(h,-1,sizeof(h));
    int head=0,tail=1;
    q[head]=1;
    h[1]=0;
    while(head<tail)
    {
        x=q[head++];
        next=alist[x];
        while(next)
        {
            int v=edge[next].v;
            int value=edge[next].value;
            if(value&&h[v]<0)
            {
                q[tail++]=v;
                h[v]=h[x]+1;
            }
            next=edge[next].next;
        }
    }
//    for(int i=1;i<=n*m;i++) printf("h[%d]=%d\n",i,h[i]);
    if(h[n]==-1) return false;
    return true;
}
int ans;
int dfs(int x,int y)
{
    if(x==n) return y;
    int next=alist[x];
    int w,used=0;
    while(next)
    {
        int v=edge[next].v;
        int value=edge[next].value;
        if(value&&h[v]==h[x]+1)
        {
                w=y-used;
                w=dfs(v,min(w,value));
                edge[next].value-=w;
                edge[next^1].value+=w;
                used+=w;
                if(used==y) return y;
        }
        next=edge[next].next;
    }
    if(!used) h[x]=-1;
    return used;
}
void dinic()
{
    while(bfs()) ans+=dfs(1,0x7fffffff);
}
int n1,m1,e1;
int main()
{
 //   freopen("testdata.in","r",stdin);
 //第一遍没A就是因为忘了删上面这句话。。。
    scanf("%d%d%d",&n1,&m1,&e1);
    n=n1+m1+2;
    for(int i=1;i<=n1;i++)
    {
        add(1,i+1,1);
        add(i+1,1,1);
    }
    for(int i=1;i<=e1;i++)
    {
    	int u,v;
    	scanf("%d%d",&u,&v);
    	if(u<=n1&&v<=m1)
    	add(u+1,v+n1+1,1),
    	add(v+n1+1,u+1,1);
    }
    for(int i=1;i<=m1;i++)
    {
        add(i+n1+1,n,1);
        add(n,i+n1+1,1);
    }
    dinic();//暴力跑最大流
    printf("%d",ans);
    return 0;//程序拜拜
}
```
好啦这道题就先这样。对于要刷网络流的大佬们要是想练一练怎么见图的话[P1402](https://www.luogu.org/problemnew/show/P1402)是一个很好的选择。
然后想深入学习的同学可以看看最小割和转对偶图。之后做一下[P4001](https://www.luogu.org/problemnew/show/P4001)

---

## 作者：不许雷同 (赞：55)

我仔细浏览了一下所有的题解， 发现其中大部分代码实在是太冗余。打算上传一下自己的题解，感觉讲得很清晰，希望管理员大大能够给过，谢谢！！！


------------
如果在当前匹配方案下再也找不到增广路，那么当前匹配就是最大匹配了。
~~什么？不清楚什么是增广路？自己百度吧。~~

**匈牙利算法流程：**

1.从任意一个没有被配对的点x开始，从点x的边中任意选一条边。如果此时点i没有被配对那么配对成功，则找到了一条增广路。如果点i此时已经被配对了，那么可以尝试将点i与其他点配对。如果尝试成功，则找到一条增广路。这里用match[ ]来记录配对关系， 即match[i] = x。 并且将配对数+1。 这个过程我们用dfs来实现。

2.如果配对失败，就从点x的边中重选一条边尝试。直到点x配对成功或尝试完x所有的边。

3.接下来对没有配对的点一一进行配对，直到所有的点都尝试完毕找不到新的增广路。

~~三步走了解一下~~

下面来一波代码，代码很短，只有三十行。

```cpp
#include <bits/stdc++.h>
#define N 1001
using namespace std;
int n, m, e, ans, match[N];
bool a[N][N], vis[N];
bool dfs(int x){
	for (int i = 1; i <= m; i++)
		if (!vis[i] && a[x][i]){
			vis[i] = 1;
			if (!match[i] || dfs(match[i])){
				match[i] = x;
				return 1;
			}
		}
	return 0;
}
int main(){
	cin >> n >> m >> e;
	for (int i = 1; i <= e; i++){
		int u, v;
		scanf("%d%d", &u, &v);
		if (v <= m) a[u][v] = 1;
	}
	for (int i = 1; i <= n; i++){
		ans += dfs(i);
		memset(vis, 0, sizeof(vis));
	}
	cout << ans;
	return 0;
}
```

---

## 作者：suncongbo (赞：37)

给两种做法：

1. 匈牙利算法

本质上是贪心

```cpp
#include<cstdio>
#include<cstring>
using namespace std;

const int N = 1e3;
bool f[N][N];
bool used[N];
int match[N];
int n,m,e;

bool DFS(int pos)
{
    for(int i=1; i<=m; i++)
    {
        if(f[pos][i] && !used[i])
        {
            used[i] = true;
            if(!match[i] || DFS(match[i])) //如果这个点i还未匹配则pos和他匹配，如果这个点已经匹配，那么如果本来和他匹配的点match[i]还能找到另一个点匹配则pos把i“抢”过来，让match[i]去匹配另一个点，否则就不干涉i和match[i]匹配
            {
                match[i] = pos;
                return true;
            }
        }
    }
    return false; 
}

int main()
{
    scanf("%d%d%d",&n,&m,&e);
    for(int i=1; i<=e; i++)
    {
        int x,y; scanf("%d%d",&x,&y);
        if(x<=n && y<=m) f[x][y] = true; 
    }
    int ans = 0;
    for(int i=1; i<=n; i++)
    {
        memset(used,false,sizeof(used)); //注意此处
        if(DFS(i)) ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```
2.网络最大流

建一个点s编号为1为源点，建一个点t编号为n+m+2为汇点。然后让A类点分别编号为2~n+1, B类点分别编号为n+2~n+m+1。

然后建边：把s和所有A类点都连边，AB类点之间根据输入连边，所有B类点和T连边，每条边边权均为1.

最后在图上跑网络最大流即可。

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;

const int N = 2005;
const int M = 1002005;
const int INF = 0x7fffffff;
struct Edge
{
    int v,val,nxt,rev;
};
Edge e[M<<1];
int fe[N];
queue<int> q;
int dep[N];
int n,m,s,t;

bool bfs()
{
    while(!q.empty()) q.pop();
    memset(dep,0,sizeof(dep));
    q.push(s); dep[s] = 1;
    while(!q.empty())
    {
        int c = q.front(); q.pop();
        for(int i=fe[c]; i; i=e[i].nxt)
        {
            if(e[i].val>0 && !dep[e[i].v])
            {
                dep[e[i].v] = dep[c]+1;
                q.push(e[i].v); 
            }
        }
    }
    if(dep[t]) return true;
    else return false;
}

int dfs(int pos,int cur)
{
    if(pos==t) return cur;
    int rst = cur;
    for(int i=fe[pos]; i; i=e[i].nxt)
    {
        if(dep[e[i].v]==dep[pos]+1 && e[i].val>0 && rst)
        {
            int flow = dfs(e[i].v,min(e[i].val,rst));
            if(flow>0)
            {
                e[i].val -= flow;
                rst -= flow;
                e[e[i].rev].val += flow;
            }
        }
    }
    return cur-rst;
}

int dinic()
{
    int ans = 0;
    while(bfs()) ans += dfs(s,INF);
    return ans;
}

void addedge(int u,int v,int val,int rev)
{
    e[++m].v = v; e[m].val = val; e[m].rev = rev;
    e[m].nxt = fe[u]; fe[u] = m;
}

int main()
{
    int n1,n2,m0; m = 0;
    scanf("%d%d%d",&n1,&n2,&m0);
    n = n1+n2+2;
    for(int i=1; i<=m0; i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(x<=n1 && y<=n2)
        {
            addedge(x+1,y+n1+1,1,m+2);
            addedge(y+n1+1,x+1,0,m);
        }
    }
    for(int i=1; i<=n1; i++)
    {
        addedge(1,i+1,1,m+2);
        addedge(i+1,1,0,m);
    }
    for(int i=1; i<=n2; i++)
    {
        addedge(i+n1+1,n,1,m+2);
        addedge(n,i+n1+1,0,m);
    }
    s = 1; t = n;
    printf("%d\n",dinic()); 
    return 0;
}
```

---

## 作者：奈芙莲 (赞：20)

好像没有看到写Hopcroft-Carp算法的，那我来发一个吧、、

匈牙利算法的时间复杂度是O(NM)的。。而Hopcroft-Carp算法是O(sqrt(N) \* E ) 的。。

然后就是一个模板了。。

```cpp
/**************************
* 二分图匹配(Hopcroft-Carp算法)
* 复杂度 O (sqrt(n) * E) 
* 邻接表存图 
* Nx 为左端的端点数,使用前先赋值(点编号从 0 开始 
**************************/ 
#include<cstdio>
#include<queue>
#include<vector>
#include<cstring>
#include<algorithm>
#define ri register int
using namespace std;
#define gc getchar
template<class T>void read(T&x){
    ri f=1,c;while(c=gc(),c<48||57<c)if(c=='-')f=-1;x=c^48;
    while(c=gc(),47<c&&c<58)x=(x<<3)+(x<<1)+(c^48);x*=f;
}
const int N = 3005, INF = 0x3f3f3f3f;
vector<int> G[N];
int Nx,Ny,k;

int Mx[N],My[N];
int dx[N],dy[N];
int dis,u,v;
bool used[N];
bool searchP(){
    queue<int> Q;
    dis = INF;
    memset(dx,-1,sizeof(dx));
    memset(dy,-1,sizeof(dy));
    for(int i = 0;i < Nx;++i)
    if(Mx[i] == -1)    Q.push(i), dx[i] = 0;
    while(!Q.empty()){
        int u = Q.front();Q.pop();
        if(dx[u] > dis) break;
        int sz = G[u].size();
        for(int i = 0;i < sz;++i){
            int v = G[u][i];
            if(dy[v] == -1) {
                dy[v] = dx[u] + 1;
                if(My[v] == -1) dis = dy[v];
                else dx[My[v]] = dy[v] + 1, Q.push(My[v]);
            }
        }
    }
    return dis != INF;
}
bool DFS(int u){
    int sz = G[u].size();
    for(int i = 0;i < sz;++i){
        int v = G[u][i];
        if(!used[v] && dy[v] == dx[u] + 1){
            used[v] = true;
            if(My[v] != -1 && dy[v] == dis) continue;
            if(My[v] == -1 || DFS(My[v])){
                My[v] = u;
                Mx[u] = v;
                return true;
            }
        } 
    }
    return false;
}
int MaxMatch(){
    int res = 0;
    memset(Mx,-1,sizeof(Mx));
    memset(My,-1,sizeof(My));
    while(searchP()){
        memset(used,false,sizeof(used));
        for(int i = 0;i < Nx;++i)
        if(Mx[i] == -1 && DFS(i)) ++res;
    }
    return res;
}
int main(){
    read(Nx);read(Ny);read(k);
    while(k--){read(u);read(v);if(v<=Ny) G[u-1].push_back(v-1);}
    printf("%d\n",MaxMatch());
}
```

---

## 作者：Plus_Ultra (赞：19)

半年多前觉得这道题很难，现在觉得还好.

 一看题目，
####  “ 模板 ” 两个大字映入我的眼帘，

~~谁都知道这是一个二分图匹配问题~~

本文比较浅显易懂（私以为），适合萌新看，大佬们可跳过

解决二分图最大匹配大概有两种做法，
 
  -  网络流算法. 就是在原图的基础上建一个源点，再建一个汇点，跑最大流即可.不过本题 EK 会炸，所以要用Dinic，介于本文主要介绍匈牙利算法，这里不再赘叙.
  
  -  匈牙利算法. 前方内容较多，大佬们可跳过.
  
  
  
一. 二分图介绍
  
二分图是一种特殊的无向图。
  
    • 点集 V 可以拆成两部分 V = V1 ∪ V2。
  
    • V1 内部没有边。
  
    • V2 内部没有边。
  
    • 换句话说，所有的边都横跨 V1 和 V2。




二. 二分图最大匹配

    • 匹配：选出图的边集 E 的一个子集 F，使 V1 和 V2 中的每个点
最多关联了 F 中的一条边。

    • 最大匹配：选出的子集包含边的个数最大。




三. 增广路定理

设 F 是一个匹配。

    • V1, V2 中被 F 覆盖到的点称为饱和点，未覆盖到的叫非饱和点。

    • F 中的边称为匹配边，其它的叫非匹配边。

    • 交错路：从非饱和点出发，依次经过非匹配边、匹配边、非匹配边、匹配边、非匹配边……

    • 增广路：从非饱和点出发最后走到一个非饱和点的交错路。

    • 增广路中非匹配边比匹配边多一条。

    • 如果图中存在增广路，则把经过的非匹配边和匹配边互换，能得到更大的匹配 F′。 

    • 如果 F 不是最大匹配，则存在增广路。




四. 增广路算法

  1. 一开始，F 为空。

  2. 每次找 F 的增广路，能找到就增广。

  3. 找不到增广路时，算法结束。




五. 匈牙利算法

  1. 一开始，F 为空。

  2. 枚举 V1 中的点 x，找以 x 为起点的增广路，找到了就增广。

  3. V1 中的点都尝试增广一次后，算法结束。

定理：如果在某一时刻，找不到以 x 为起点的增广路，则增广几轮之后仍不会找到。

时间复杂度：O(nm)



这是我在一次培训中老师的见解.

关于证明，太难，蒟蒻不会证，大佬们请谅解.

下面贴代码（我相信各位大佬也不需要代码）：


```
#include<iostream>

using namespace std;

const int V=1000010;
int N,M,E,ans;
int edge[V],head[1010],nxt[V],tot;
int dfn[2020],match[1010],x,y,ti;

void add(int x,int y)//加边
{
	edge[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}

int dfs(int x,int ti)//ti是时间戳
{
	for(int i=head[x];i;i=nxt[i])
	{
		int j=edge[i];
		if(dfn[j]!=ti)//这一轮还没有遍历到
		{
			dfn[j]=ti;
			if(!match[j]||dfs(match[j],ti))//没有和j点匹配的点或者是找到了一条可增广的路径
			{
				match[j]=i;//i,j匹配
				return 1;
			}
		}
			  
	}
	return 0;
}

int main()
{
	cin>>N>>M>>E;
	for(int i=1;i<=E;i++)
	{
		cin>>x>>y;
		if(x>N||y>M)  continue;
		add(x,y);
	}
	
	for(int i=1;i<=N;i++)
		if(dfs(i,++ti))  ans++;//找到了一条增广路
		
	cout<<ans<<endl;
	
	return 0;
}
```
去掉空行后40来行，也是比较短的了.


[博客食用口感更好哟](https://www.luogu.org/blog/OnePunchManGO/)

因为有一些小错误，导致定理阐述符号都是？？？？，更改了一下，希望管理员给过


  
  

---

## 作者：hanyuwei (赞：17)

咳咳我十分不厚道的用网络流跑了一下二分图匹配

~~应该是NOIP2017前最后一次题解了~~

网络最大流的核心其实是建模，这道题中我们可以把每一条边的流量看做1，然后把0点作为源点，n+m+1点作为汇点，大概看起来如下图所示

 ![](https://cdn.luogu.com.cn/upload/pic/10676.png) 

（红色的表示新建的，黑色的表示原来的图）

然后我们用网络最大流跑一下，最终汇入汇点的流量其实就是二分图的最大匹配【可以思考一下哦，答案在代码最后】







    
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define inf 2147483647
using namespace std;
struct Edge
{
    int to;
    int s;
    int last;
}e[2001000];
int dep[4100],in[4100],cnt;
int s=0,t;
void addedge(int x,int y,int z)
{
    e[++cnt].last=in[x];
    e[cnt].s=z;
    e[cnt].to=y;
    in[x]=cnt;
}
bool bfs()
{
    memset(dep,0,sizeof(dep));
    queue<int> que;
    que.push(s);dep[s]=1;
    while(!que.empty())
    {
        int u=que.front();que.pop();
        for(int i=in[u];i>=0;i=e[i].last)
        {
            if(!dep[e[i].to]&&e[i].s>0)
            {
                dep[e[i].to]=dep[u]+1;
                que.push(e[i].to);
            }
        }
    }
    if(dep[t])    return true;
    else    return false;
}
int dfs(int now,int cur)
{
    if(now==t)    return cur;
    for(int i=in[now];i>=0;i=e[i].last)
    {
        if(dep[e[i].to]==dep[now]+1&&e[i].s>0)
        {
            int flow=dfs(e[i].to,min(cur,e[i].s));
            if(flow)
            {
                e[i].s-=flow;
                if(i&1)    e[i+1].s+=flow;
                else    e[i-1].s+=flow;
                return flow;
            }
        }
    }
    return 0;
}
int main()
{
    int n,m,e,i,l,x,y,ans=0;
    memset(in,-1,sizeof(in));
    scanf("%d%d%d",&n,&m,&e);t=n+m+1;
    for(i=1;i<=n;i++){addedge(0,i,1);addedge(i,0,0);}
    for(i=n+1;i<=n+m;i++){addedge(i,t,1);addedge(t,i,0);}
    for(i=1;i<=e;i++)
    {
        scanf("%d%d",&x,&y);if(x>n||y>m)    continue;
        addedge(x,y+n,1);addedge(y+n,x,0);
    }
    while(bfs())
    {
        while(l=dfs(s,inf))
            ans+=l;
    }
    printf("%d",ans);
    return 0;
}
【ans：每一次有流量汇入就是成功匹配啦】
```

---

## 作者：lemir3 (赞：16)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11113535.html#autoid-0-0-0)

#什么是二分图?

>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。------摘自百度百科

![配图1](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=dbf8c742e050352ab161220e6b789ccf/7a899e510fb30f24a3ac24f6c195d143ad4b0315.jpg)

#怎样判定二分图?

*以下内容摘自《算法竞赛进阶指南》*

存在如下定理:

>一张无向图是二分图,当且仅当图中不存在奇环(长度为奇数的环).

根据该定理,同志们可以以染色法进行二分图的判定.主体思想为:尝试用黑白两种颜色标记图中的结点,当一个结点被标记后,它的所有相邻结点应该被标记与它相反的颜色.若标记过程中产生冲突,则说明图中存在奇环.二分图染色一般基于DFS实现,时间复杂度为$O(n+m)$,伪代码如下:

```cpp

void dfs(int x,int color)
{
    赋值v[x] <-- color
    对于与x相连的每条无向边(x,y)
    if v[y]=0 then
        dfs(y,3-color)
    else if v[y]=color then
        判定无向图不是二分图,算法结束
}

在主函数中
    for i <-- 1 to n
        if(v[i]=0)then dfs(i,1)
    判定无向图是二分图

```

#二分图最大匹配

*以下定义摘自《算法竞赛进阶指南》*

"任意两条边没有公共端点"的边的集合被称为图的一组匹配.在二分图中,包含边数最多的一组匹配被称为二分图的最大匹配.

对于任意一组匹配$S$($S$是边集),属于$S$的边被称为"匹配边",不属于$S$的边被称为"非匹配边".匹配边的端点被称为"匹配点",其他结点被称为"匹配点".如果二分图中存在一条连接两个非匹配点的路径$path$,使得非匹配边与匹配边在$path$上交错出现,那么称$path$是匹配$S$的增广路,也称交错路.

有如下定理:

>二分图的一组匹配$S$是最大匹配,当且仅当图中不存在$S$的增广路.

配图如下:

![配图2.png](https://i.loli.net/2019/07/01/5d1981bb0de1144262.png)

![配图3.png](https://i.loli.net/2019/07/01/5d1981c16f34e79126.png)

![配图4.png](https://i.loli.net/2019/07/01/5d1981c18400350800.png)

如图,图2,图3(请不要联想到图波耶夫设计局)中红色的边就是图1的匹配,图3中红色的边为图1的最大匹配.

##匈牙利算法(增广路算法)

匈牙利算法,又称增广路算法,用于计算二分图最大匹配.

###引入

独立团战士们要发枪,每个战士都有自己想要的枪.关系如下:

![配图5.png](https://i.loli.net/2019/07/01/5d198eed1c5b339808.png)

开始分配:

![配图6.png](https://i.loli.net/2019/07/01/5d198eedaa4fc86330.png)

政委想要捷克式轻机枪,于是把捷克式轻机枪分给了政委.

![配图7.png](https://i.loli.net/2019/07/01/5d198eed9946118360.png)

团长这时说道:"好你他娘的赵政委,当几天政委还蹭鼻子上脸了是吧?老子就要用捷克式轻机枪."

政委想了想,反正咱百里赵刚用汉阳造也顺手,顺手拿来了汉阳造,轻机枪给了团长.

![配图8.png](https://i.loli.net/2019/07/01/5d198eed46c0b65755.png)

但是和尚也想用这把汉阳造,于是找政委商量.

政委:"关心小同志是咱当政委的职责,要不这样,这把汉阳造就拿给你用,我去找团长商量用轻机枪."

团长:"怎么?又打老子的轻机枪的主意?我看你和老子还有几天交情,轻机枪给你用,行了吧,读书人还真他娘的不讲理.这几天闲着没事,二营的那台意大利炮,老子拿来玩几天."

于是团长从二营拖来了意大利炮,政委用上了轻机枪,和尚拿到了汉阳造.

![配图9.png](https://i.loli.net/2019/07/01/5d198eed5b56786382.png)

二营长这就不乐意了,我堂堂张大~~喵~~彪,好不容易缴获的意大利炮,哪是个团长随随便便就能拿来玩的?

于是张大~~喵~~彪找到了团长.

团长:"去你他娘的二营长,老子官比你大,用你的炮怎么啦?老子把炮给你了老子用什么打仗?你让那小鬼子自个往我嘴里钻?我看你打仗天天摔帽子,那顶上次去边区领多了一顶帽子,你给老子拿去用."

于是张大~~喵~~彪分到了一顶帽子.

###主体思想

上面的过程就是一个标准的匈牙利算法.

匈牙利算法的思想就是寻找增广路,把增广路上的匹配状态全部取反,得到一个更大的匹配.

具体来说的话,可以以上面的第二幅图举例.

"李团长 --> 捷克式轻机枪 --> 赵政委 --> 汉阳造",这是匹配"赵政委 --> 捷克式轻机枪"的一条增广路,其中"李团长"和"汉阳造"为增广路连接的两个非匹配点.同志们把这条增广路上的所有边的匹配状态取反,原来政委拿到了轻机枪,取反之后变为没有拿到,原来团长没有拿到轻机枪,取反后拿到了轻机枪,原来政委没有拿到汉阳造,取反后拿到了汉阳造.

这样就得到了一个更大的匹配.

我们重复第二步,直到图中不存在增广路,就得到了最大匹配.

因为该算法最多遍历整个二分图一次,所以时间复杂度为$O(nm)$.

###具体实现

1. 设$S$为空集,即所有的边都是非匹配边.

2. 寻找增广路,把路径上的边全部取反,得到一个更大的匹配$S`$

3. 重复第二部,直到图中不存在增广路.

关于具体怎么寻找增广路,怎么给路径取反,我讲在代码中解释.

[*模板题*](https://www.luogu.org/problemnew/show/P3386)

**代码:**

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

struct edge
{
    int to,next;
}e[1000010];

int n,m,e_,size,ans;
int head[10010],match[10010];
bool flag[10010];

inline void EdgeAdd(int,int);
inline void Hungary();
inline bool find(int);

int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d%d",&n,&m,&e_);
    for(int _=1;_<=e_;_++)
    {
        int from,to;
        scanf("%d%d",&from,&to);
        if(from>n||to>m||from>m||to>n)
        {
            continue;
        }
        EdgeAdd(from,to);
    }
    Hungary();
    printf("%d\n",ans);
return 0;
}

inline void EdgeAdd(int from,int to)
{
    e[++size].to=to;
    e[size].next=head[from];
    head[from]=size;
}

inline void Hungary()
{
    for(int _=1;_<=n;_++)//枚举左集中的结点
    {
        memset(flag,false,sizeof(flag));
        if(find(_)==true)//存在一条增广路
        {
            ans++;
        }
    }
}

inline bool find(int from)
{
    for(int _=head[from];_!=-1;_=e[_].next)//遍历该结点的路径
    {
        int to=e[_].to;
        if(flag[to]==false)//flag数组防止往回走
        {
            flag[to]=true;
            if(match[to]==0||find(match[to])==true)
/*这里有两种情况,一种是右集中的点没有被选,那么它们俩构成长度为1的增广路.
另一种是右集中的点已经被选了,但是往下递归可以发现选它的点可以有其他的选择,这样构成了一条两端都是非匹配点的路径,即增广路.
*/
            {
                match[to]=from;//更改匹配
                return true;
            }
        }
    }
return false;
}

```


---

## 作者：Mine_King (赞：9)

- **2020/5/4 upd：做了一些修改，把$vis$数组的详细用法写了一下。**

题目：[二分图匹配](https://www.luogu.org/problem/P3386)  
二分图匹配，就是解决 一群人，喜欢一类东西，然后求最多满足能满足多少人的问题。当然，东西是不同的，人的喜好也是不同的。  

这里讲一下匈牙利算法是如何解决这个问题的。
首先，我们画了一个图：  
![](https://i.loli.net/2019/11/07/C5qebotKdRxYvZ4.png)  
然后，我们对第一个人匹配，也就是找第一个人要的东西，然后就得到了下图（粉色代表匹配成功，也就是左边的人得到了右边的东西。草绿色代表遍历过但未成功）  
![](https://i.loli.net/2019/11/07/AnPUMuwEkOi6Im8.jpg)  
然后，我们跳过一大堆已知的操作，得到下图：  
![](https://i.loli.net/2019/11/07/7HPoM341QDZJFSw.jpg)  
这时，我们发现，3号人也想要二号物品，但是已经被1号人拿走了。这改怎么办办呢？我们发现，1号还能拿3号物品。于是，人1把物2给了人3，拿了物3。  
![](https://i.loli.net/2019/11/07/WbXcajEq5Jhe9GD.jpg)  
然后， 匹配4号。这时……人2占了物1，但人2不能拿别的东西了。于是乎，人2拒绝妥协，~~人4被人2暴打了一顿~~而人4匹配不了其他的，因为他对物品1情有独钟，不喜欢别的东西，so，他莫得东西了QwQ。

现在，所有的人都匹配完了，能拿到东西的最多有三个人，~~4号被抛弃了，还被暴打了一顿~~，最大匹配数也就是3。  

那么，具体思路讲完了，改怎么实现呢？  
很简单，我们逐个枚举人，$dfs(i)=1$表示匹配成功，否则失败。用$1$个$chos$数组，$chos_i$表示第$i$个物品被第$chos_i$个人拿走了，$vis$数组用来在判断一个人能否拿别的物品时用的。也就是做个标记，如果不做这个标记，那再判断这个人能否拿别的物品时他也许还会选择这个物品。（所以，每次$dfs$都要清空$vis$）$dfs$内部就是枚举他喜欢的每一个东西，如果这个东西没人要或要这个东西的人可以拿别的，这个东西就归他了，然后返回1。如果遍历完所有他想要的还得不到任何东西，就返回0。  
**$vis$数组要在每一次遍历的时候清空哦**

**上代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,e,ans;//e是边数，ans是答案
bool vis[100005];
int chos[100005];
struct node
{
	int tot;
	int dt[10000005],nxt[10000005];
	int hd[100005];
	void add(int x,int y)
	{
		tot++;
		nxt[tot]=hd[x];
		hd[x]=tot;
		dt[tot]=y;
		return ;
	}
}g;//链式前向星存图
bool dfs(int x)
{
	for(int i=g.hd[x];i;i=g.nxt[i])//枚举他喜欢的每一个东西
	{
		if(vis[g.dt[i]]) continue;//被判断过，就直接下一个循环
		vis[g.dt[i]]=1;//标记，如果不标记，后面的判断dfs(chos[g.dt[i]])就永远是真了。
		if(!chos[g.dt[i]]||dfs(chos[g.dt[i]]))//如果当前没人要这个东西或要这个东西的人还可以拿别的，那这个东西就是他的了
		{
			chos[g.dt[i]]=x;//标记这个东西归他了
			return 1;//返回true。
		}
	}
	return 0;//到遍历完还没得到东西，返回false
}
int main()
{
	scanf("%d%d%d",&n,&m,&e);
	for(int i=1;i<=e;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		if(u>n||v>m) continue;//题目中说有可能会出现u>n和v>m的情况
		g.add(u,v);//连边
	}
	for(int i=1;i<=n;i++)//枚举每个人
	{
		memset(vis,0,sizeof(vis));//清空vis
		ans+=dfs(i);//直接加就可以了，因为bool中true的值是1，false的值是0
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Jianuo_Zhu (赞：6)

二分图以前用匈牙利写过，学了网络流之后发现好像所有二分图的题都可以用网络流写，于是就来写一发

数据范围实在是坑，只给了n和m的范围，没给e的范围。结果我BT的调了一下午，后面下载数据才知道e到了1e6的范围。我前向星开到1e7就过了

没加优化的dinic常数比匈牙利大一些，但是加了优化后吊打匈牙利。。

其实用网络流写二分图就是虚拟一个s源点，虚拟一个t汇点，把所有左半边的点用流量为1的点连到s点，把右半边的点用流量为1的边连到t点上。然后再连左半边和右半边的点。

代码就发一个不带优化的dinic吧（其实是我不会ISAP）

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int maxn=1e7,inf=1e9;
struct edge{
    int v,c,f,nxt;
}e[maxn];
int s,t,n,m,mm,cnt,h[maxn],lev[maxn];
queue<int> q;
void add(int u,int v,int w);
int maxflow(void);
int bfs(void);
int dfs(int x,int flow);
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m>>mm;
    s=0;t=n+m+1;
    memset(h,-1,sizeof(h));
    for(int i=1;i<=n;i++) add(s,i,1),add(i,s,0);
    for(int i=n+1;i<=n+m;i++) add(i,t,1),add(t,i,0);
    int u,v;
    for(int i=1;i<=mm;i++){
        cin>>u>>v;
        if(v>m || u>n) continue;
        add(u,v+n,1);add(v+n,u,0);
    }
    cout<<maxflow();
    return 0;
}
void add(int x,int y,int z)
{
    e[cnt].nxt=h[x];
    e[cnt].c=z;e[cnt].f=0;
    e[cnt].v=y;
    h[x]=cnt++;
}
int maxflow(void){
    int ans=0;
    while(bfs())
        ans+=dfs(s,inf);
    return ans;
}
int bfs(void){
    memset(lev,0,sizeof(lev));
    lev[s]=1;q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=h[u];i!=-1;i=e[i].nxt){
            int v=e[i].v;
            if(e[i].c>e[i].f && !lev[v]) lev[v]=lev[u]+1,q.push(v);
        }
    }
    return lev[t];
}
int dfs(int x, int flow) {
    int af = 0;
    if (x == t) return flow;
    for (int i = h[x]; i != -1; i = e[i].nxt) {
        if (flow <= af) break;
        int v = e[i].v;
        if (lev[v] == lev[x] + 1) {
            int maxf = dfs(v, min(e[i].c - e[i].f, flow - af));
            e[i].f += maxf;
            e[i ^ 1].f -= maxf;
            af += maxf;
        }
    }
    return af;
}


```cpp

---

## 作者：USER113968 (赞：4)

嗯，这是模板题，那么，在开始之前，先看几个名词。

**二分图**

通俗的来说，就是所有的点能分成两份，构成两个互不相交的顶点集合，每条边连接这两个集合里的点。

**增广路**

大概来说就是一条连接两个未匹配顶点的边，这两顶点连边后就互相匹配了。

---

好了好了，概(fei)念(hua)讲完了，就来看一看算法步骤吧：

1. 找到一个顶点，枚举它的每一条边。

2. 若该条边连接的另一顶点未匹配，直接与该顶点连线，匹配数+1。

3. 若对方已经匹配，尝试让那个点匹配的点找其他点连线。如果那个点找到别的点连线了，就立刻和这条边连接的点（此时它已经被遗弃了）连线。匹配数+1.

4. 还是不成功的话（那个点匹配的点找不到别的点连线），尝试下一条边。

5. 将上述步骤运用到每一个顶点，即可得出最大匹配。

这个过程我们可以递归实现。

这个概念比较抽象，我们看一组图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tlyorvuz.png)

嗯！一张标准的二分图，我分好了AB组。

![](https://cdn.luogu.com.cn/upload/image_hosting/pfvynqvm.png)

首先看A组第一个点的第一条边，发现对方没被匹配！那么直接匹配。（右边那个框是match数组，记录配对关系的）

![](https://cdn.luogu.com.cn/upload/image_hosting/kmw92cr6.png)

看A组2，发现它的第一条边连接的点也没人匹配，直接记上。

![](https://cdn.luogu.com.cn/upload/image_hosting/eyqtcafy.png)

到了A组三，还是没问题，一切都挺顺利的哈。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ptlhafq.png)

这下出问题了！A组4的第一条边连的B组1已经和A组1匹配了！肿么办？根据先前的算法步骤，我们应该让A组1找别人匹配。

![](https://cdn.luogu.com.cn/upload/image_hosting/2sllz8py.png)

再看A组1的第二条边，连接的是B组3，发现B组3也被配对了。按照算法步骤，我们应该让A组3找别人。不过A组3只能连B组3，找不到别人。我们只好看下一条边。

![](https://cdn.luogu.com.cn/upload/image_hosting/zovzbapz.png)

到了A组1的第四条边，我们发现，连的B组4没和别人匹配！那就可以直接连线啦！

接下来，原先的B组1就被遗弃了。而这一切事情的起源：A组4就愉快地和B组1匹配了。

emmmm······~~好像比较简单哈~~

那么怎么存储二分图呢？事实上，我这个蒟蒻只会邻接矩阵，所以，A组人员正常存储，B组成员的下标直接改为$B_i+N_A (N_A)$是A组成员的数量。虽然空间加了一堆，但是过得去，也好理解啊！（为自己找借口）

好了好了，上代码：

```c++
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
bool e[2001][2001];//邻接矩阵
int match[2001];//配对关系记录
bool visit[2001];//访问标记
int n,m,k;
bool dfs(int v)//找到人匹配就返回true,否则false
{
    visit[v]=true; 
    for(int i=n+1;i<=m+n;i++)//枚举每个B组成员（邻接表枚举每条边），看之间是否有连线
    {
        if(e[v][i]==1&visit[i]==false)
        {
            visit[i]=true;
            if(match[i]==0||dfs(match[i]))//对方没和别人匹配或者对方匹配的人找到了别人
            { 
                match[v]=i;
                match[i]=v;//记录一下
                return true;//找到了
            }
        }
    }
    return false;//所有边均已尝试，无功而返
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    memset(match,0,sizeof(match));
    for(int i=1;i<=k;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        if(a>n||b>m)//这种异常数据直接过滤掉
            continue;
        e[a][b+n]=e[b+n][a]=true;
    }//读入部分
    int count=0;
    for(int i=1;i<=n;i++)//枚举每一个点，尝试匹配
    {
        for(int j=1;j<=n+m;j++)
        {
            visit[j]=false;//清除上次匹配的访问标记
        }
        if(dfs(i))//找到了
            ++count;//匹配数+1
    }
    printf("%d",count);
    //system("pause");
    return 0;
}
```

本文到这里就结束了，希望能给你带来帮助。

---

## 作者：XJack (赞：4)

## 二分图

### 是啥

将一个**无向图**的点分为两个集合且两个点集中的点在各自集合中互不相连则称这个图为二分图.

### 性质

一个无向图是二分图,当且仅当它不包含奇环

一个无向图是二分图,当且仅当它可以二染色

### 判定

无向图K为二分图的充分必要条件是

1.K至少包含两个点

2.其回路的长度均为偶数

实现代码


二染色判定二分图


```cpp

bool paint(now, mark)
{ 
	if (color[now] == 0) 
		color[now] = mark; 
	else if (color[now] != mark) 
		return false;
	int k=head[now]; 
	while (k!=0){ 
		if(paint(e[k], -mark)==false) 
		return false; k=next[k];   //如出现冲突则说明这不是
	} 
	return true; //没有出现冲突说明此图是二分图
}

```
-----

二分图的匹配

* 是啥

对于一个二分图K的子图T

若T的边集E的任意两条边都不连接同一个点,则称T为K的一个匹配

## 关于二分图的最大匹配

* 匈牙利算法

首先了解一个定义:增广路

定义:
设M是二分图G的一个匹配,P是G中一个连通两个未匹配点的路径,且属于M的边与不属于M的边交替出现，则称P为相对于M的一条增广路.

由增广路的定义可以推出下述三个结论 

1.增广路的路径长度必定为奇数,**第一条边和最后一条边都未被匹配**.

2.通过增广路的交错可以得到一个更大的匹配.

3.当且仅当不存在增广路是匹配数最大.


### 如何找？(染色法)

1.设增广路M为空

2.找出一条增广路P通过取反操作获得更大的匹配代替原匹配M

3.重复2.的操作直到找不出新的增广路为止

如何进行2.的操作？

~~好像就只有这个问题比较棘手~~

枚举一条路径的起始点

判断此点是否为初始状态

dfs将下一个点赋为 !这个点的颜色

最后一直找到找不到增广路便返回

---------

开始打增广路部分

```cpp

bool ap(int x){
	for(int i=1;i<=m;i++){//扫描每一个点 
		if(g[x][i]&&!vis[i])//如果x,i之间存在一条边且i未被访问过
		vis[i]=true; //将i点标记为过
		if(!match[i]||ap(match[i])){ //如果这是增广路的终点或还能从这个点找到增广路 
			match[i]=x;  
			return true;//能找到 
		} 
	}
	return false; //如果扫描了每一个点都无法找到增广路就说明找不到增广路了 
} 
```

完整代码:

```cpp

#include<bits/stdc++.h>
using namespace std;
int ans=0;
const int maxn=1007;
bool vis[maxn];
int n,m;
int e;
bool g[maxn][maxn];
int match[maxn];
bool ap(int x){
	for(int j=1;j<=m;++j){//扫描每一个点 
		if(g[x][j]&&!vis[j]){//如果x,j之间存在一条边且j未被访问过
			vis[j]=true; //将j点标记为过
			if(!match[j]||ap(match[j])){ //如果这是增广路的中点或还能从这个点找到增广路 
				match[j]=x;  //变反 
				return true;//返回能找到 
			} 
		} 
	}
	return false; //如果扫描了每一个点都无法找到增广路就说明找不到增广路了 
}
void work()
{
	for(int i=1;i<=n;++i){ //枚举增广路起始点
		memset(vis,0,sizeof(vis));
		if(ap(i)){
			ans++;
		} 
	}
	return ;
}
int main()
{
	cin>>n>>m>>e;
	for(int i=1;i<=e;i++){
		int u,v;
		cin>>u>>v;
		g[u][v]=true; 
	}
	work();
	cout<<ans;
}

```

------

### _end_


---

## 作者：引领天下 (赞：3)

考前发个题解涨涨RP

感谢@nederland 巨佬提供了一个网络最大流+邻接矩阵的解法，我就在这里提一下如何优化

原解法：https://www.luogu.org/recordnew/lists?uid=nederland&pid=P3386&status=14&sort=0

可以看到，除第一个AC以外，剩下来的T死……

那么，如何优化呢？

# 1. 快读+快输！

这个东西，大家都知道，我就不解释了

# 2. O(3)

虽说NOIP不给用，然而在此题中还是很有用的

# 3. register

这是一个C++保留字，用来将变量存入内存，加速。

# 4. 避免变量重复定义

这个东西有效优化时间。比方说一个1000000的循环，你定义一个变量，定义1000000次，不T都怪。相比之下，虽然仍然需要赋值，但减少了重复定义的时间。

用了这些，此题就可以A了啊……

代码：

```cpp
#include<cstdio>
#pragma GCC optimize(3)
#define min(x,y) ((y)^(((x)^(y))&(-((x)<(y)))))
bool vis[2005];
int pred[2005],cap[2005][2005],flow[2005][2005],N,t;
inline char nc(){
  static char buf[100000],*p1=buf,*p2=buf;
  return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
template <typename _Tp>
inline void read(_Tp &x){
    int f=1;x=0;char ch=nc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=nc();}
    x*=f;
}
inline void write(long long n){
    if(n==0) return;
    write(n/10);
    putchar(n%10+'0');
}//快读+快输……然而printf比快输还快（我写炸了？）
int findpath(int u,int x){
    if(u==t)return x;
    vis[u]=true;
    for(int v=0;v<N;v++){
        if(!vis[v]){
            int dt=cap[u][v]-flow[u][v];
            if(dt>0){
                pred[v]=u;
                int r=findpath(v,min(x,dt));
                if(r)return r;
            }
        }
    }
    return 0;
}
int main(){
    register int n,m,s,e,r,v,i,u;//优化3、4
    read(n),read(m),read(e);//优化1
    s=0;t=n+m+1;N=n+m+2;
    for(i=1;i<=n;i++)cap[s][i]=1;
    for(i=1;i<=m;i++)cap[n+i][t]=1;
    for(i=0;i<e;i++){
        read(u),read(v);//优化1
        if(u>n||v>m)continue;
        cap[u][v+n]=1;
    }
    while(true){
        for(i=0;i<N;i++)vis[i]=false;
        r=findpath(s,999999999);
        if(!r)break;
        v=t;
        while(v!=s){
            u=pred[v];
            flow[u][v]+=r;
            flow[v][u]-=r;
            v=u;
        }
    }
    register int sum=0;
    for(i=0;i<N;i++)sum+=flow[s][i];
    printf("%d",sum);
    return 0;
}
```

由@nederland 巨佬的代码优化而来

求过，~~我觉得我介绍了除女装之外的所有优化了~~

---

## 作者：Bring (赞：3)

咳咳，其实这道题呢可以看成网络流的最大流问题

可以看成u->v的边就是在图中u到v连一条权为1的边

就是求从所有u到所有v的最大流问题

假设有一个超级源点0号，和一个超级汇点n+m+1号（假设所有u都是u号，v都是v+n号）

因为任何一个点都只能连一条边，所以从0（即源点）到所有u连一条权为1的边，从所有v到n+m+1号（即汇点）连一条权为1边

打一遍最大流即可

可以先去A一下最大流问题模版题 [传送门](https://www.luogu.org/problemnew/show/P3376)

于是代码略（亲测dinic 291ms 8384kb 超快 推荐）

---

## 作者：a4001234567 (赞：2)

### 可能是第一篇python题解
为了某些目的，计划写一个python的二分图匹配，然而python的常数有点大？总之朴素的版本恐怕没那么好过。
```python
left = dict()//左侧点的相邻节点
count = 0//答案
lmatch,rmatch = dict(),dict()//记录匹配情况
lused,rused = dict(),dict()//dfs遍历标记
def dfs(c):
    if lused[c] :return False
    lused[c] = True
    for i in left[c]:
        if rused[i] : continue
        rused[i] = True
        if rmatch[i] != -1:
            if dfs(rmatch[i]):
                rmatch[i] = c
                lmatch[c] = i
                return True
        else:
            rmatch[i] = c
            lmatch[c] = i
            return True
    return False
n,m,e = map(int,input().split())//初始化
for i in range(n):left[i+1] = [];lmatch[i+1] = -1
for i in range(m):rmatch[i+1] = -1
for i in range(e)://见图
    u,v = map(int,input().split())
    if u>n or v>m :continue//特判
    left[u].append(v)
for c in range(n):
    for i in range(n):lused[i+1] = False
    for i in range(m):rused[i+1] = False
    count += dfs(c+1)
print(count)

```
然而过不了。

最后一个循环里的两次循环很讨厌，让人不开心，于是就要想办法去掉。可以将lused的值改为整数，每次循环指定一个新值，如果lused\[i\] 不是这个值，即当作False处理。

于是13个检查点，一共快了350ms。然而过不了。

~~于是继续想办法，比如DFS时，优先连没配对的点，然后慢了300ms。~~

于是还得想办法，考虑答案的上界，是min(n,m)（显然成立）。于是一旦答案达到上界，就没必要在做下去了。

于是，时间减半。

附代码：
```python
// luogu-judger-enable-o2
left = dict()
time = 0
count = 0
lmatch,rmatch = dict(),dict()
lused,rused = dict(),dict()
def dfs(c):
    if lused[c] == time:return False
    lused[c] = time
    for i in left[c]:
        if rused[i] == time: continue
        rused[i] = time
        if rmatch[i] != -1:
            if dfs(rmatch[i]):
                rmatch[i] = c
                lmatch[c] = i
                return True
        else:
            rmatch[i] = c
            lmatch[c] = i
            return True
    return False
n,m,e = map(int,input().split())
for i in range(n):left[i+1] = [];lmatch[i+1] = -1
for i in range(m):rmatch[i+1] = -1
for i in range(e):
    u,v = map(int,input().split())
    if u>n or v>m :continue
    left[u].append(v)
for i in range(n):lused[i+1] = -1
for i in range(m):rused[i+1] = -1
for time in range(n):
    count += dfs(time+1)
    if time == min(n,m):break
print(count)
```


---

## 作者：arfa (赞：2)

## 二分图匹配

·图论

### 二分图概念:
分为两边的点,同边的点不相连,另一边的点可以相连,如图:

![](https://cdn.luogu.com.cn/upload/pic/21212.png)
红色的边明显破坏了二分图性质。

### 匹配概念
两两个点进行匹配,匹配过的点不再出现,如图:

![](https://cdn.luogu.com.cn/upload/pic/21213.png)

经过匹配后,点清除,其它的继续匹配。

### 最大匹配

一个二分图中,匹配最多的**点数**为这个二分图的**最大匹配数**。如图:

![](https://cdn.luogu.com.cn/upload/pic/21214.png)

这里要注意,不是所有的二分图都有**最大匹配数量**=**点数**的情况。

### 算法介绍
总结两个二分图做法。

### 1.匈牙利算法
主要思路是贪心:我们需要满足后来的点时,可能需要破坏前面已经匹配的点,然后让前面的点换一个匹配对象。

题解:[BYVoid-匈牙利算法](https://www.byvoid.com/zhs/blog/hungary)

### 2.网络流
~~不得不说,一切图论皆网络流。~~ 

 _~~**(吊打匈牙利不再话下)**~~_ 
#### 入门篇:
[网路流的概念和EK,Dinic](https://www.luogu.org/blog/acking/solution-p3376)

#### 为什么选择网络流?
我们把每一条边的流量设置为1(反向边为0),建造源点和汇点(习惯是源点source=1,汇点sink=n+m+2),那么流到了汇点,最大流量就是网络流。

![](https://cdn.luogu.com.cn/upload/pic/21215.png)

为什么呢?

通俗一点来说:因为所有流量都是1,所以每一个路径都有可行性(全都是增广路)。从源点出去的点(除了这个点没有连边)肯定都会出现增广路,那么流到右边点的,就是匹配成功(再流向汇点)。

![](https://cdn.luogu.com.cn/upload/pic/21216.png)

这里的**建模**需要特别注意。

#### ISAP
[更快的ISAP解法](https://www.luogu.org/blog/acking/solution-p3376-2)

ISAP是一种网络流算法,会比Dinic快很多,而且少了初始化BFS,程序复杂度少了很多,参考如下。

### CODE
```psacal
//可能因为pascal或者是初始化的原因,有些时候被Dinic赶超,不过时间复杂度还是很乐观的。(可以开O2)
//少了建模和添边,ISAP的DFS只占很少Byte。
//以下程序只是介绍建模部分

Uses math;

var
        value,reach:array[0..2010] of longint;
        dis,gap,cnt,next:array[1..1010] of longint;
        n,m,source,sink,tot,x,y,sum,i,k:longint;
        maxflow:int64;

procedure add(x,y,sum:longint);
begin
        inc(tot);
        reach[tot]:=y;
        inc(value[tot],sum);
        next[tot]:=cnt[x];
        cnt[x]:=tot;
end;

function Dfs(now,flow:longint):longint;
var
        i,k,mindis,ret:longint;
begin
        mindis:=n-1;
        ret:=flow;
        if now=sink then
                exit(flow);

        i:=cnt[now];
        repeat
                if value[i]>0 then
                begin
                        if dis[now]=dis[reach[i]]+1 then
                        begin
                                k:=Dfs(reach[i],min(ret,value[i]));
                                dec(value[i],k);
                                inc(value[i xor 1],k);
                                dec(ret,k);
                                if dis[source]>=n then
                                        exit(flow-ret);
                                if ret=0 then
                                        break;
                        end;
                        mindis:=min(mindis,dis[reach[i]]);
                end;
                i:=next[i];
        until i=-1;

        if ret=flow then
        begin
                dec(gap[dis[now]]);
                if gap[dis[now]]=0 then
                        dis[source]:=n;
                dis[now]:=mindis+1;
                inc(gap[dis[now]]);
        end;
        exit(flow-ret);
end;

begin
        filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
        tot:=1;

        read(n,m,k);
        source:=1;
        sink:=n+m+2;
        for i:=1 to n do //源点向左边的点添边
        begin
                add(source,i+1,1);
                add(i+1,source,0); //注意:反向边依然是0
        end;
        for i:=1 to k do //创建二分图
        begin
                read(x,y);
                if (x>n)or(y>m) then //Bug
                        continue;
                add(x+1,y+n+1,1);
                add(y+n+1,x+1,0);
        end;
        for i:=1 to m do //右边的点向汇点添边
        begin
                add(i+n+1,sink,1);
                add(sink,i+n+1,0);
        end;

        n:=n+m+2;

        gap[source]:=n; //ISAP网络流部分
        while dis[source]<n do
                inc(maxflow,Dfs(source,maxlongint));
        writeln(maxflow);
end.
```



---

## 作者：Nero_Claudius (赞：2)

二分图匹配的常用算法有匈牙利算法和Dinic算法，这里只讨论前者。

------------

所谓二分图，就是指一类能够被分成两半的图，其中每一半的点都没有任何边连接。

而二分图的匹配，就是指二分图的一个子图中任意两条边都没有公共点。（这个子图就是一个匹配）

本题求的是最大匹配数，顾名思义，就是匹配中边数最大为多少。

------------

匈牙利算法的本质是贪心。我们每一次都找一条增广路，然后再取反寻找比当前匹配更大的匹配。没有增广路就结束。

百度百科是这样定义增广路的：

```
若P是图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径（举例来说，有A、B集合，增广路由A中一个点通向B中一个点，再由B中这个点通向A中一个点……交替进行）。
```

![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=80eafc26dd00baa1ae214fe92679d277/63d0f703918fa0ec172d55c72a9759ee3c6ddb15.jpg)

------------

### 实现

我们使用DFS实现匈牙利算法。

```cpp
inline bool dfs(int u){
    for(int v=1;v<=m;v++)
        if(t[u][v]&&!vis[v]){
            vis[v]=1;
            if(cy[v]==-1||dfs(cy[v])){
                cx[u]=v;cy[v]=u;
                return 1;
            }
        }
    return 0;
}
```

这段代码寻找从u出发的增广路。

首先我们先枚举与u有连接的所有节点。

然后如果未访问就进去逛一逛。

如果发现这个节点还没有被匹配或者说存在从它出发的增广路，那就跳进去。回溯时返回true，表示存在从u出发的增广路。

如果逛了一圈一个节点都不行，那就返回false，因为没有从u出发的增广路。

```cpp
for(int i=0;i<=nx;i++) 
	if(cx[i]==-1){ 
    	memset(visit,false,sizeof(visit)) ; 
        ans += dfs(i); 
    }
```

在主程序中我们过一遍所有点，如果当前未匹配就dfs一下，然后根据dfs返回值更新答案。

---

## 作者：yzhang (赞：1)

好像没有人发Ford-Fulkerson，我来一发，
这道题和P2756飞行员配对方案问题方法一样，网络流大法好。
~~（勿喷）~~


------------

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int Max=3000;
struct node{
	int to,cap,rev;
};
vector<node> v[Max];
bool used[Max];
int n,m,e;
void add_node(int a,int b,int c) //加边
{
	v[a].push_back((node){b,c,v[b].size()});
	v[b].push_back((node){a,0,v[a].size()-1});
}
int dfs(int s,int t,int f) //Ford—Fulkerson
{
	if(s==t) //源点和汇点相同，流量无限
		return f;
	used[s]=true;
	for(int i=0;i<v[s].size();++i)
	{
		node &tmp=v[s][i]; //太长了。。。
		if(used[tmp.to]==false&&tmp.cap>0)
		{
			int d=dfs(tmp.to,t,min(f,tmp.cap));
			if(d>0) //添加反向边
			{
				tmp.cap-=d;
				v[tmp.to][tmp.rev].cap+=d;
				return d;
			}
		}
	}
	return 0;
}
int maxflow(int s,int t) //Ford-Fulkerson求网络最大流
{
	int flow=0;
	while(1)
	{
		memset(used,false,sizeof(used));
		int f=dfs(s,t,inf);
		if(f==0)
			return flow;
		flow+=f;
	}
}
int main()
{
	cin>>n>>m>>e;
	for(int i=1;i<=n;++i) //建图
		add_node(0,i,1);
	for(int i=n+1;i<=n+m;++i)
		add_node(i,n+m+1,1);
	for(int i=1;i<=e;++i)
	{
		int a,b;
		cin>>a>>b;
		if(a<=n&&b<=m) //数据有毒，一定要加。
		    add_node(a,n+b,1);//一定要加n；
	}
	cout<<maxflow(0,m+n+1)<<endl;
	return 0;
}
```

---

## 作者：朝L夕 (赞：1)

算法：匈牙利算法求二分图。

二分图中的边只能连接不同侧的点,同侧的点是不能互相连接的,而且匈牙利算法可以搜索其中一边,

优化：记录一个点连了几条边，避免从1搜到m

```cpp
for i:=1 to e do
   begin
    readln(u,v);
    if (v>m) or (u>n) then continue;//过滤数据
    num[u]:=num[u]+1;//存u这个点连了几条边
    a[u,num[u]]:=v;
   end;
```
-----------------------------------------------------------------------------------------------------------
我开始以为要两边都搜索，但其实只用搜索一边

我们从左边开始搜，当我们搜到右边的点时，若右边的点已被匹配

那么我们就搜索它匹配的那个点，这样就回到了左边。


------------------------------代码如下----------------------------------




```cpp
var n,m,e,i,sum,v,u,qq,j:longint;
    a:array[-2..1001,-2..1001] of longint;
    link,num:array[-2..4002] of longint;//num记录左边每一个点连了几条边，link记录匹配边
    b:array[-2..10001] of boolean;//判断是该点是否用过
  function find(k:longint):boolean;
   var i,q:longint;
    begin
      for i:=1 to num[k] do
       begin
        qq:=a[k,i];
       if b[qq]=false then
        begin
       b[qq]:=true;
         if (link[qq]=0) or find(link[qq]) then
        begin
         link[qq]:=k;
         exit(true);
        end;
        end;
     end;
    exit(false);
    end;
 begin
  readln(n,m,e);
  for i:=1 to e do//处理数据
   begin
    readln(u,v);
    if (v>m) or (u>n) then continue;
    num[u]:=num[u]+1;
    a[u,num[u]]:=v;
   end;
   sum:=0;
  for i:=1 to n do//枚举，这里枚举的是点，但进入find函数后，枚举的还是以i点为端点的         边。就是要把i点加入增广路中
   begin
    for j:=1 to m do b[j]:=false;
    if find(i) then sum:=sum+1;
   end;
 write(sum);
end.
```
----------------------------------------------------------------------------------------
耗时427ms

虽然比网络流慢，但还是可以接受


---

## 作者：Strong_Jelly (赞：1)

## 思路：

首先二分图是一个求一堆东西（例如狗），喜欢一些东西（例如肉），但是他们喜欢的肉不同，求最大限度能满足多少条狗的问题。那么我们可以画一个图，把狗放在一侧，把肉放在一侧。 如果第$i$只狗， 喜欢第$j$个肉，那么，就从$i$ --->$j$连一条有向边。 然后， 我们用贪心的思想进行dfs。 我们定义$choose$[$i$]表示第$i$个肉被第$choose$[$i$]个狗获得。 然后我们定义一个$vis$数组，防止死循环。 我们枚举$1$ ~ $n$，$dfs$判断第$i$只狗能否吃到肉。 $dfs$中，我们枚举$i$所喜欢的肉，如果第$j$个肉没有被吃 $||$ 吃这个肉的狗可以吃别的肉，那么就$return$ $1$（及当前狗可以吃到肉），否则$return$ $0$。 如果$return$ $1$，就$ans++$（及可以吃到自己喜欢的肉的狗的数量$++$）。 注意：每次$dfs$都要把$vis$清空。 最后答案就是$ans$。

## 全文 + 代码：

https://www.cnblogs.com/qqq1112/p/11620774.html

---

## 作者：StilllFantasy (赞：1)

//本题为简单的二分图最大匹配模板，匈牙利算法，只搜索二分图右边的点即可；

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int n,m,e;
vector<int>q[1006];//用不定长数组存储左边的各点跟右边的相连的点
int sum=0;
int vis[1005];
int ma[1005];
int dfs(int p)
{
    for(int i=0;i<q[p].size();i++)
    {                                                  //扫描当前点的相连的点
        if(!vis[q[p][i]])
        {
            vis[q[p][i]]=1;
            if(!ma[q[p][i]]||dfs(ma[q[p][i]]))
            {
                ma[q[p][i]]=p;                              //匈牙利算法更新配对状态
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    cin>>n>>m>>e;
    int x,y;
    for(int i=1;i<=e;i++)
    {
        scanf("%d%d",&x,&y);
        if(x>n||y>m)
        continue;//跳过部分假数据，如果不跳的话只能跑过6个点好像。
        q[x].push_back(y);
    }
    for(int i=1;i<=n;i++)
    {
        if(i>=2)
        for(int j=0;j<q[i-1].size();j++)//清空vis标记数组，因为我用vector，所以只清空上一个点连过的右边的点就可以，
        vis[q[i-1][j]]=0;//避免每一次都要清空所有点的标记
        if(dfs(i))//如果可以找到增广路的话，结果加11
        sum++;
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：KKarshilov (赞：1)

表示并不是很懂为何大佬们总爱把vis弄成bool，难道memset不要时间吗，分享一下我的，大体没变，还是匈牙利，但是把vis改成int类，避开memset的问题：

            
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=12306;
int lnk[maxn],used[maxn];
vector<int> divide[maxn];//领接矩阵好写啊
int n,m,e,ans;
inline int read() //忽略掉这个快读
{
    int x=0; char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x;
}
bool Find(int x,int f)
{
    for(int i=0;i<divide[x].size();i++)
    {
        int v=divide[x][i];
        if(used[v]!=f)//当前匹配的不是f，本轮还没用过
        {
            used[v]=f;
            if(lnk[v]==-1||Find(lnk[v],f))//可以让步或名花无主
            {
                lnk[v]=x;//匹配
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    n=read();m=read();e=read();
    memset(lnk,-1,sizeof(lnk));
    for(int i=1,a,b;i<=e;i++)
    {
        a=read();b=read();
        if(b>m||a>n)  continue;
        divide[a].push_back(b);
    }
    for(int i=1;i<=n;i++)
    {
        if(Find(i,i))//省掉了memset
          ans++;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：1)

二分图我从不打匈牙利= =

全部都是打网络流，最近学了下ISAP，虽说在网络流模板跑的飞快，但这里好像常数写的比较大，11个点跑了296ms，不知道楼下说的30ms是怎么跑出来的。我看评测记录里有个匈牙利算法跑了244ms，比我这还快【手动滑稽】


建立一个超源点与超汇点，然后全部连上容量为1的边，跑个最大流就好了。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int INF=0x3f3f3f3f;
const int M=50010;
const int N=1010;
struct Edge{
    int to,next,cap;
}e[M*40];
int d[N*2],a[N*2],cur[N*2],num[N*2],fa[N*2];
int n,m,E,S,T,EdgeCnt=0;
queue<int> Q;
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void addedge(int u,int v,int w){
    int &p=EdgeCnt;
    e[p].to=v;e[p].next=a[u];e[p].cap=w;
    a[u]=p++;
}
void BFS(){
    for (int i=1;i<=n+m+2;i++)d[i]=n+m+2;
    Q.push(T);d[T]=0;
    while (!Q.empty()){
        int u=Q.front();Q.pop();
        for (int p=a[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (e[p^1].cap && d[v]>d[u]+1){
                d[v]=d[u]+1;
                Q.push(v);
            }
        }
    }
}
int Augment(){
    int u=T,f=INF;
    while (u!=S){
        u=fa[u];
        f=min(f,e[cur[u]].cap);
    }
    u=T;
    while (u!=S){
        u=fa[u];
        e[cur[u]].cap-=f;
        e[cur[u]^1].cap+=f;
    }
    return f;
}
int MaxFlow(){
    memset(num,0,sizeof(num));
    BFS();
    for (int i=1;i<=n+m+2;i++)num[d[i]]++,cur[i]=a[i];
    int flow=0,u=S;
    while (d[S]<n+m+2){
        if (u==T){
            flow+=Augment();
            u=S;
        }
        bool done=false;
        for (int p=cur[u];p!=-1;p=e[p].next){
            int v=e[p].to;
            if (e[p].cap && d[u]==d[v]+1){
                fa[v]=u;
                cur[u]=p;
                done=true;
                u=v;
                break;
            }
        }
        if (!done){
            int m=n;
            for (int p=a[u];p!=-1;p=e[p].next){
                int v=e[p].to;
                if (e[p].cap)m=min(m,d[v]);
            }
            if (--num[d[u]]==0)break;
            num[d[u]=m+1]++;
            cur[u]=a[u];
            if (u!=S)u=fa[u];
        }
    }
    return flow;
}
int main(){
    n=read(),m=read(),E=read();
    memset(a,0xff,sizeof(a));
    for (int i=1;i<=E;i++){
        int u,v;
        u=read(),v=read();
        if (u>n || v>m)continue;
        v+=n;
        addedge(u,v,1);
        addedge(v,u,0);
    }
    S=n+m+1;T=n+m+2;
    for (int i=1;i<=n;i++)addedge(S,i,1),addedge(i,S,0);
    for (int i=1;i<=m;i++)addedge(i+n,T,1),addedge(T,i+n,0);
    printf("%d",MaxFlow());
    return 0;
}
```

---

## 作者：rediserver (赞：0)

# P3386 【模板】二分图匹配

[原题地址](https://www.luogu.org/problemnew/show/P3386)

[GitHub题解](https://github.com/jerrykcode/luogu)

二分图最大匹配，匈牙利算法，使用DFS和BFS实现，参考https://www.renfei.org/blog/bipartite-matching.html

(好像题解里还没有BFS实现的匈牙利算法)

在main函数里，

```cpp
Hungarian * hungarian;
```

下一行使用

```cpp
hungarian = new DFS();
```

或者

```cpp
hungarian = new BFS();
```

来切换算法(Hungarian为定义纯虚函数的抽象类，DFS和BFS为子类)。

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

typedef unsigned int Vertex;
#define NO_VERTEX 0xffffffff

class Hungarian {
public:
    /*
    返回二分图最大匹配
    @param graph 图，只记录左边顶点到右边顶点的边
    @param left_num 左边顶点数量，左边顶点编号 0 ~ left_num - 1
    @param right_num  右边顶点数量，右边顶点编号 0 ~ right_num - 1
    @return size_t 最大匹配数量
    */
    virtual size_t maxMatching(vector<Vertex> * graph, size_t left_num, size_t right_num) = 0;

    virtual ~Hungarian() {
    
    }
};

//DFS实现
class DFS : public Hungarian {
public:
    virtual size_t maxMatching(vector<Vertex> * graph, size_t left_num, size_t right_num);
private:
    bool dfs(Vertex v);

    vector<Vertex> * graph_;
    Vertex * matching_;
    bool * visited_;
    size_t match_num_;
};

size_t DFS::maxMatching(vector<Vertex>* graph, size_t left_num, size_t right_num) {
    graph_ = graph;
    matching_ = new Vertex[right_num]; //matching_是右边顶点匹配的左边顶点，数组大小为right_num
    fill(matching_, matching_ + right_num, NO_VERTEX);
    visited_ = new bool[right_num]; //visited_标记右边顶点
    match_num_ = 0;
    for (size_t i = 0; i < left_num; i++) {
        fill(visited_, visited_ + right_num, false);
        if (dfs(i)) {
            match_num_++;
        }
    }
    free(matching_);
    free(visited_);
    return match_num_;
}

bool DFS::dfs(Vertex v) {
    Vertex adj_v;
    for (auto it = graph_[v].begin(); it != graph_[v].end(); it++) {
        adj_v = *it;
        if (!visited_[adj_v]) {
            visited_[adj_v] = true;
            if (matching_[adj_v] == NO_VERTEX || dfs(matching_[adj_v])) { //adj_v没有匹配或者adj_v的匹配可以找到其他匹配
                matching_[adj_v] = v;
                return true;
            }
        }
    }
    return false;
}

//BFS实现
class BFS : public Hungarian {
public:
    virtual size_t maxMatching(vector<Vertex> * graph, size_t left_num, size_t right_num);
private:

    Vertex * left_matching_;
    Vertex * right_matching_;

    queue<Vertex> vqueue_;
    Vertex * pre_;
    bool * visited_;
};

size_t BFS::maxMatching(vector<Vertex>* graph, size_t left_num, size_t right_num) {
    left_matching_ = new Vertex[left_num]; //左边顶点匹配的顶点
    fill(left_matching_, left_matching_ + left_num, NO_VERTEX);
    right_matching_ = new Vertex[right_num]; //右边顶点匹配的顶点
    fill(right_matching_, right_matching_ + right_num, NO_VERTEX);
    pre_ = new Vertex[left_num]; //BFS中左边顶点的前驱
    visited_ = new bool[right_num]; //右边顶点是否访问过
    size_t result = 0;
    for (Vertex i = 0; i < left_num; i++) { //遍历左边顶点
        fill(visited_, visited_ + right_num, false); //初始化右边所有顶点没有访问过		
        vqueue_.push(i);
        pre_[i] = NO_VERTEX; // i 没有前驱
        Vertex front_v, adj_v;
        while (!vqueue_.empty()) {
            front_v = vqueue_.front(); //出队的顶点
            vqueue_.pop();
            for (auto it = graph[front_v].begin(); it != graph[front_v].end(); it++) { //遍历邻接点
                adj_v = *it; //邻接点(右边顶点)
                if (!visited_[adj_v]) {
                    visited_[adj_v] = true;
                    if (right_matching_[adj_v] != NO_VERTEX) { //adj_v已经匹配
                        vqueue_.push(right_matching_[adj_v]); //adj_v匹配到的顶点(左边)入队
                        pre_[right_matching_[adj_v]] = front_v; //记录前驱，即若right_matching_[adj_v]可以找到其他匹配，则front_v与adj_v匹配
                    }
                    else { //adj_v没有匹配
                        Vertex from = front_v, to = adj_v, tmp;
                        while (from != NO_VERTEX) {
                            tmp = left_matching_[from]; //from原来的匹配(右边顶点)
                            left_matching_[from] = to; //from 与 to 匹配
                            right_matching_[to] = from; //from 与 to 匹配
                            //from找到匹配，则pre_[from]与from原来的匹配即tmp匹配，更新from与to进入下次循环,            \
                            若from之前并没有匹配，则pre_[from]为NO_VERTEX，下一次循环就会退出
                            from = pre_[from]; 
                            to = tmp;
                        }
                        while (!vqueue_.empty()) vqueue_.pop(); //清空队列
                        goto NEXT;
                    } //else
                } //if
            } //for
        } //while
    NEXT:
        if (left_matching_[i] != NO_VERTEX) result++;
    } //for
    free(left_matching_);
    free(right_matching_);
    free(pre_);
    free(visited_);
    return result;
}

int main() {
    unsigned int n, m, e;
    scanf("%u %u %u", &n, &m, &e);
    vector<Vertex> * graph = new vector<Vertex>[n];
    Vertex u, v;
    for (size_t i = 0; i < e; i++) {
        scanf("%u %u", &u, &v);
        if (u > n || v > m) continue;
        u--; v--;
        graph[u].push_back(v);
    }
    Hungarian * hungarian;
    //hungarian = new DFS();
    hungarian = new BFS();
    unsigned int max_matching = hungarian->maxMatching(graph, n, m);
    printf("%u", max_matching);
    for (size_t i = 0; i < n; i++)
        vector<Vertex>().swap(graph[i]);
    delete hungarian;
    return 0;
}
```




---

## 作者：wwlw (赞：0)

### Link:[题目](https://www.luogu.org/problemnew/show/P3386)

---------------

## 题目大意

   我们需要做的，就是**找到一种连边的方式，使得任意一个点的度最多为1，且边数最大。**

   给出一组数据：

    input：                              output： 
    3 4 5                                 3
    1 1
    1 2
    2 1
    1 4
    3 3                                 
    
  ![](https://img2018.cnblogs.com/blog/1604911/201902/1604911-20190219080733792-1141853232.jpg)
  
  此时，方案大致是这样的（当然还有其他选法）。

   我们是如何找出这种匹配方式的呢？此时，就要引入**匈牙利算法**。
    
## 匈牙利算法流程

   1.首先枚举一个节点的所有边，如果当前边对应的节点不在匹配序列，则加入对应节点，返回匹配成功。

   2.如果当前没有匹配成功，且对应点在之前的匹配序列（不在当前），则重新匹配对应点，执行1。

   3.执行完1,2,均未匹配成功，返回失败。

   下面我们来模拟一下样例数据。

   首先这是原图
   
![](https://img2018.cnblogs.com/blog/1604911/201902/1604911-20190219081951192-1040424876.jpg)
   
   搜索左边第一个节点，找到一条没有匹配过的边，加入匹配序列1。
   
![](https://img2018.cnblogs.com/blog/1604911/201902/1604911-20190219082308578-422619320.jpg)
   
   搜索第二个节点，找到一条匹配过的边，但不在匹配序列2，重新搜索节点1...，最后返回成功。
   
![](https://img2018.cnblogs.com/blog/1604911/201902/1604911-20190219082649420-1152454670.jpg)

   搜索第三个节点，找到可以匹配的边，返回成功。
   
![](https://img2018.cnblogs.com/blog/1604911/201902/1604911-20190219082807082-363577090.jpg)

   算法结束。
   
![](https://img2018.cnblogs.com/blog/1604911/201902/1604911-20190219083604383-923467025.jpg)


最后附上代码：
```cpp
#include<stdio.h>
#define N 1007
struct E{
    int next,to;
}e[N*N];
int cnt=0,head[N],n,m,num,timeq=0,dfn[N],match[N],ans=0;
inline void read(int &x){
    x=0;char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9'){x=x*10+c-48;c=getchar();}
}
inline void add(int id,int to){//前向星存图 
    cnt++;
    e[cnt].next=head[id];
    e[cnt].to=to;
    head[id]=cnt;
}
inline bool dfs(int u){//算法核心 
    for(int i=head[u];i;i=e[i].next){//遍历 
        int v=e[i].to;
        if(dfn[v]==timeq) continue;//如果已在当前匹配序列，则直接返回 
        dfn[v]=timeq;//加入当前匹配序列 
        if(!match[v]||dfs(match[v])){//如果没有匹配过，或者重新搜索对应点返回成功 
            match[v]=u;//匹配 
            return true;//匹配成功 
        }
    }
    return false;//匹配失败 
}
int main(){
    read(n);read(m);read(num);
    for(int i=1;i<=num;i++){
        int x,y;
        read(x);read(y);
    //    if((x>n)||(y>m)) continue;
        add(x,y);//建立单向边就够了，因为不会从右边的节点开始访问 
    }
    for(int i=1;i<=n;i++){
        timeq++;//更新序列编号 
        if(dfs(i)) ans++;//搜索当前节点 
    }
    printf("%d",ans);
}
```

---

## 作者：ysner (赞：0)

二分图匹配用匈牙利算法或者网络流都可做（ps：能用匈牙利算法做的都能用网络流做），但是效率差别较大。

网络流可达30ms，邻接表匈牙利1440ms，邻接矩阵匈牙利4036ms。

而我只是一个提高组的蒟蒻，没兴趣搞省选级别的网络流。。。就来个邻接表匈牙利算法吧。

（吐槽：为什么大佬的邻接表都有STL和指针，看得好难受。。。）

注意事项：

1、存点的结构体的空间尽量大，我的程序开到了n×n×5。（开n时10个点RE。。。）

2、要去掉u>n和v>m的情况。（但邻接矩阵没必要）

3、程序注释非常重要，有助于理解匈牙利算法精髓，希望大家仔细阅读。

4、邻接表既省时间又省空间，建议多用。

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define fp(i,a,b) for(int i=a;i<=b;i++)
#define fq(i,a,b) for(int i=a;i>=b;i--)
#define il inline
#define re register
#define ll long long 
using namespace std;
bool vis[4005]={};
int n,m,k,ans=0,link[4005]={},head[4005]={},cnt=0;//vis用来标记   link记录情侣关系  
struct Edge
{
    int to,next;
}e[4000005];//e记录有好感
il int gi()
{
   int x=0;
   short int t=1;
   char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
il bool dfs(int u)//匈牙利算法
{
    for(int i=head[u];i;i=e[i].next)//扫描每个妹子，这里已保证有好感
    {
        int v=e[i].to;
        if(!vis[v])//if (单身）
        {
            vis[v]=1;  
            if(!link[v]||dfs(link[v])) {link[v]=u;return 1;}//名花无主||者能腾出个位置来，这里使用递归
        }
    }
    return 0;
}
int main()
{
    n=gi();m=gi();k=gi();
    fp(i,1,k)
    {
        int u=gi(),v=gi();
        if(u>n||v>m) continue;//去掉无效情况
        e[++cnt]=(Edge){v,head[u]};head[u]=cnt;//有好感就连条边（标准链式前向星存储）
    }
    fp(i,1,n)
    {
        memset(vis,0,sizeof(vis));
        if(dfs(i)) ans++;//情侣配成
    }
    printf("%d\n",ans);
    return 0;
}

```

---


# 斐波那契

## 题目背景

大样例可在页面底部「附件」中下载。

## 题目描述

小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。

小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。

如果我们把这种关系用图画下来，前六个月大概就是这样的：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9806.png) 

其中，一个箭头 $A \to B$ 表示 $A$ 是 $B$ 的祖先，相同的颜色表示同一个月出生的兔子。

为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 $m$ 个问题：她想知道关于每两对兔子 $a_i$ 和 $b_i$，他们的最近公共祖先是谁。你能帮帮小 C 吗？

一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，$5$ 和 $7$ 的最近公共祖 先是 $2,1$ 和 $2$ 的最近公共祖先是 $1,6$ 和 $6$ 的最近公共祖先是 $6$。


## 说明/提示

【数据范围与约定】 子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表：

 ![](https://cdn.luogu.com.cn/upload/pic/9807.png) 

特殊性质 $1$：保证 $a_i$, $b_i$ 均为某一个月出生的兔子中标号最大的一对兔子。例如，对 于前六个月，标号最大的兔子分别是 $1, 2, 3, 5, 8, 13$。

特殊性质 $2$：保证 $|a_i-b_i|\le 1$。


## 样例 #1

### 输入

```
5 
1 1 
2 3 
5 7 
7 13 
4 12```

### 输出

```
1 
1 
2 
2 
4 ```

# 题解

## 作者：浅色调 (赞：64)

###解法：斐波拉契###

**思路：**很多人直接诶想到了lca吧，但对这道题显然是不可以的。我们考虑列出几项斐波拉契数来查找规律：[1] [2] [3] [4 5] [6 7 8] [9 10 11 12 13]…我们观察一下上述的几项，同一个[]中的是同时出生的，我们发现第i个月出生的兔子恰巧就是它上个月之前的兔子所生，而且对于一个数x，它的直接父亲就是x-f[i](f[i]是第一个比x小的斐波拉契数)，所以我们可以对于每次询问(a,b)，将a、b中较大的数先往前跳到它的父亲，然后比较此时a和b的大小是否相同，若想同则输出该数，若不同则重复上述步骤继续往前跳。说的好像不太清楚，但是我们自己列一列应该很容易看出。举个例子：假设我要询问8和11的最近公共祖先是谁，我们先对11往前跳，即11-8得到了3,此时比较3和8的大小，不相等，so用较大的数8继续往前跳，即8-5=3，此时3和3相等了，所以3就是11和8的最近公共祖先。

**注意：**题目中数据较大到了10的12次方，所以要开long long，此外必须得预处理出斐波拉契中的前60项(因为数据只有10的12次方，斐波拉契的第60项刚好超过了数据范围)，然后就是读入优化(数据有300多万次询问而且数还那么大)，最后在比较时最好二分查找节省时间。

**代码量超少，关键是思路稍微得思考**

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
ll m,a,b;
il ll gi()
{
    int a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
    return f?-a:a;
}
ll c[100];
il void find(ll a,ll b)
{
    if(a<b)swap(a,b);
    if(a==b){printf("%lld\n",a);return;}
    int w=lower_bound(c,c+62,a)-c;
    find(b,a-c[w-1]);
}
int main()
{
    m=gi();
    c[0]=1;c[1]=1;
    for(int i=2;i<=61;i++)c[i]=c[i-1]+c[i-2];     //printf("%lld\n",c[i]);
    while(m--)
    {
        a=gi(),b=gi();
        find(a,b);
    }
    return 0;
}
```

---

## 作者：吾乃会虎 (赞：63)

用此篇题解纪念我已经被忘却的关于这个题目的一篇题解

~~甚至也被洛谷遗忘在回收站里了~~	

------------

首先我们要看到大佬的题解

所有大佬（包括管理员大大发的题解）都点出了一个重点：	
—— 父亲和儿子的标号都相差一个斐波那契数	

看起来这是一个不知道原因的规律，实际上这是可以被证明的（不想看证明的可跳过）	

首先显而易见的是，前几轮的兔子中每一轮有$F_{N+1}$只兔子，要生$F_N$只兔子，也符合“父亲和儿子的标号都相差一个斐波那契数”这一条件	

然后如果第$N$轮的兔子符合条件，那么此时会有$F_{N+1}$只兔子，还要生$F_N$只兔子	

由于每一轮的兔子编号是按父亲的编号大小编的，所以$1$号兔子会多一个$F_{N+1}+1$号的儿子，$2$号兔子会多一个$F_{N+1}+2$号的儿子……$F_{N+1}$号兔子会多一个$F_{N+1}+F_N$号兔子，其中父亲与儿子的编号都相差$F_N$	

而此时，原来$F_{N+1}$只兔子都已经“长大成兔”了，就可以再生$F_{N+1}$只兔子，兔子总数也由$F_{N+1}$只兔子变为了$F_{N+1}+F_N=F_{N+2}$只兔子，也符合前提，因此，第$N+1$轮时条件也成立	

通过数学归纳法，我们证明了这个规律	

------------

然后介绍一下“斐波那契编码”（我更喜欢叫做“斐波那契进制”）	

百度百科：[斐波那契编码——百度百科](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%BC%96%E7%A0%81/1863086)

好，结束了 ~~捕捉极其不想打字的蒟蒻一枚~~	

------------

最后来看一下我的~~蒂花之秀的~~解法	

首先我们要记住一个方法：对带编号的数论问题，把编号改成由$0$起始对结果可能有意想不到的惊喜~~和AK比赛的更大的惊喜~~	

我们来试试这个方法：![斐波那契进制+从0编号](https://cdn.luogu.com.cn/upload/pic/46061.png)

是不是发现了什么？好像每一个父亲都是儿子的后缀？	

其实这很好解释	

每一只兔子都和他的父亲相差一个斐波那契数，在出生轮数也会相差至少两轮，这就相当于说每一只兔子的编号都是它的父亲的编号+一个不会产生进位的斐波那契数，在编号上就表现为父亲编号是儿子编号的前缀	

所以说，我们只要知道一个数的编号，就可以知道它的所有祖先的信息，最后只要暴力匹配就可以了，编程难度瞬间减小~~但思维难度比原来更高了~~	

最后附代码：	

~~~cpp
#include<bits/stdc++.h>
using namespace std;
template<typename type>
type get(type &out){
	type sign=1,num=0;
	char input='\0';
	bool over=false,finds=false;
	while((input=getchar())<=32);
	do{
		switch(input){
			case '+':sign=-sign;
			case '-':sign=-sign;
	  					if(!finds)
	  						finds=true;
	  					else
	  						over=true;
	  			break;
	  		case '0':case '1':case '2':case '3':case '4':
	  		case '5':case '6':case '7':case '8':case '9':
	  					num=num*10+(input^48);
	  			break;
	  		default:
				over=true;
				break;
		}
	}while((input=getchar())>32&&!over);
	return out=sign*num;
}//并没有什么卵用的快读
template<typename type>
type put(const type &in){
	type sign=1;
	if(in<0)sign=-sign,putchar('-');
	if(in*sign>=10)put(in*sign/10);
	putchar((in*sign%10)^48);
	return in;
}//比快读更没卵用的快输
const long long MAXN=300000;
long long FBNQ[70]={0,1,2};
long long A[70],B[70];
int main(){
	for(int i=3;i<60;++i)
		FBNQ[i]=FBNQ[i-1]+FBNQ[i-2];
    //将斐波那契数初始化
	int n=0;
	get(n);
	while(n--){
		long long a=0,b=0,ans=1;
		get(a),get(b);
        //输入数据
		--a,--b;
        //将编号改成从0开始
		for(int i=59;i>0;--i)
			A[i]=a/FBNQ[i],a%=FBNQ[i];
		for(int i=59;i>0;--i)
			B[i]=b/FBNQ[i],b%=FBNQ[i];
        //将编号化成斐波那契进制
		for(int i=0;i<60;++i,ans+=FBNQ[i]*A[i])
			if(A[i+1]!=B[i+1])
				break;
        //强行匹配
		put(ans);putchar('\n');
        //输出答案
	}
	return 0;
} 
~~~

时间复杂度$O(Mlog_\Phi N)$	
空间复杂度$O(log_\Phi N)$	

效果近似于LCA的解法，但是代码难度小，常数也小一些

------------

最后的闲言	

实际上我当时一开始想的也是LCA，但是我太蒟了，不会这些解法，于是发现了数论解法	

所以说，蒟蒻也是有春天的~~（滑稽）~~

---

## 作者：Smallbasic (赞：12)

找规律神题。。。

可以发现每个点的父节点就是它的编号减去比这个点编号小的最大的斐波那契数，也就是：

$$fa_i=i-\max_{fib_j<i}fib_j$$

于是对于题目中的两个数，直接一层层跳到lca即可。另外这题只用处理前60个斐波那契数就可以。

输入数据较大，建议加上读优。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

typedef long long ll;

inline ll readll() {
	register ll s = 0;
	register char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s; 
}

ll fib[60], n, m;
int t;

int main() {
	fib[1] = 1; fib[2] = 1;
	for (int i = 3; i < 60; ++i) fib[i] = fib[i - 1] + fib[i - 2];
	t = readll();
	while (t--) {
		n = readll(); m = readll();
		while (n != m) {
//			cout << n << ' ' << m << endl;
			if (n < m) swap(n, m);
			for (int i = 59; i >= 1; --i)
				if (fib[i] < n) { n -= fib[i]; break; }
		} printf("%lld\n", n);
	} return 0;	
}
```


---

## 作者：Scarlet_Hypoc (赞：11)

看完这道题，我深思许久，终于找到了这道题的规律

每一个子节点和父节点的差都是一个斐波那契数，且这个数比他的父亲节点和他父亲节点的父亲节点的差和，他父亲的父亲……就是他父亲到节点1的路径上的所有差值的和都要大（也就是他父亲节点的编号-1的值），因为这个子节点和父亲节点的差的斐波那契数包含了前面的所有差，因为它是由前面的数推来的，所以，只需要找斐波那契中最大的但是比他小的那个数就好了（不能等于！他总不能是0节点的儿子吧！），然后减掉，慢慢往上找就好了。





```cpp
#include <cstdio>
#include <cstring>
int n;
long long a[110];
int main()
{
    scanf("%d",&n);
    a[0]=a[1]=1;
    for(int i=2;i<=59;i++)//差不多到10^12就好了
    a[i]=a[i-1]+a[i-2];
    for(int i=1;i<=n;i++)
    {
        long long x,y;
        scanf("%lld %lld",&x,&y);
        while(x!=y)
        {
            if(y<x)//只对较大的数做处理，也就是比较深的那个，把他放到y中
            {
                long long t=x;
                x=y;y=t;
            }
            int l=1,r=59;
            while(l<=r)//优化，二分查找
            {
                int mid=(l+r)/2;
                if(a[mid]<y)l=mid+1;
                else r=mid-1;
            }
            y-=a[l-1];//减一是因为上面l=mid+1，所以他肯定比我们要的那个大1，那假如根本就没执行过l=mid+1呢？也就是说一直满足a[mid]>y的条件，那么l最后的值一定为1，其实f[1]和f[0]的值一样，所以这里减一并不会影响结果
        }
        printf("%lld\n",x);
    }
}
```

---

## 作者：fstqwq (赞：8)

这里提供的是标程。

题解请参考 [ppt](https://www.luogu.org/discuss/show?postid=26414)，或者其他同学的题解。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

LL f[61] = {0, 1};

LL a, b; int x, y;

void getf() {
    while (f[y] >= b) y--;
    b = b - f[y];
}

int main() {
    for (int i = 2; i <= 60; i++) f[i] = f[i - 1] + f[i - 2];
    int n;
    scanf("%d", &n);
    while (n--) {
        scanf("%lld%lld", &a, &b);
        x = 60, y = 60;
        while (a != b) {
            if (a > b) swap(a, b), swap(x, y);
            getf();
        }
        printf("%lld\n", a);
    }
    return 0;
}
```

---

## 作者：zxf_272 (赞：6)

```cpp
#include<bits/stdc++.h>
using namespace std;
//易证：各子节点编号减去其父节点编号为小于该子节点编号的第一个斐波那契数
long long feb[93];//斐波那契数列的第92位在long long范围内
int main(){
    int i;
    feb[1]=1;feb[2]=1;
    for(i=3;i<=92;i++)feb[i]=feb[i-1]+feb[i-2];//递推求斐波那契数列
    long long m,a,b,p,j;
    cin>>m;
    for(i=1;i<=m;i++){//求lca(根据该树的特殊性质)
        cin>>a>>b;
        while(a!=b){
            if(a<b)swap(a,b);//简化讨论
            p=lower_bound(feb+1,feb+92,a)-feb-1;//查询数列中第一个比a小的斐波那契数
            a-=feb[p];
        }
        cout<<a<<endl;
    }
    return 0;
}
```
/\*
解后反思：

如果能准确发现结点之间的关系并利用之，能大大减少代码量，提高运算效率，节省空间和时间。

做题时若不能一眼看出结点间的关系，可试着再多画几个结点

\*/

---

## 作者：MikukuOvO (赞：5)

首先我们先来观察以下给出的图

![](https://cdn.luogu.com.cn/upload/pic/9806.png)

不难发现每一个点都和它的父结点有着一定的联系

$2-1=1$ 

$5-2=3$

$12-4=8$

题目中也明确告诉了这和斐波那契数列有关，根据~~观察~~可以发现这和该结点出生的月份有关，总结来说就是这个式子：

$fa[x]=x-f[id[x]]$

而对于$id[x]$我们可以二分一下，~~虽然我暴力找也可过~~

这样我们预处理下$f$数组然后一层层往上跳就好了，可以证明树的高度不会超过$60$

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

#define il inline
#define LL long long

const int N=65;

int m;
LL f[N];

il LL calc(LL x,LL y)
{
    while(x!=y)
    {
        if(x<y) swap(x,y);
        int pos=lower_bound(f+1,f+N-4,x)-f;
        x-=f[pos-1];
    }
    return x;
}
int main()
{
    scanf("%d",&m);
    f[1]=1,f[2]=1;
    for(int i=3;i<=N-5;++i) f[i]=f[i-1]+f[i-2];
    for(int i=1;i<=m;++i)
    {
        LL x,y;
        scanf("%lld%lld",&x,&y);
        printf("%lld\n",calc(x,y));
    }
    return 0;
}
```

---

## 作者：兮水XiShui丶 (赞：3)

这道题大家一看那个图大概都YLMB了，，，（反正本蒟蒻是。。。）

不过仔细一想，这T貌似是个搜索啊。。。。。

（为了防止有人抄，就小改了下代码）

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int m;
long long fib[10002]={0};//存每个fib的值
void qfib()//把数组的每个值求出来
{
    fib[1]=1;fib[2]=1;
    for(int i=3;i<=10002;i++)
     fib[i]=fib[i-1]+fib[i-2];
}
int main()
{
    cin>>m;
    long long a,b;//因为是fib数列，所以数据可能很大开longlong 
    for(int i=1;i<=m;i++)
    {
        scanf("%I64d%I64d",&a,&b);
        if(a==b)
        {
            cout<<a<<endl;//如果两个数一样，那么就输出原来的
            continue;
        }
        for(int i=60;i>=0;i--)//个人感念得翻着推
        {
            if(a>fib[i])a-=fib[i];
            if(b>fib[i])b-=fib[i];
            if(a==b){
                printf("%d\n",a);最后的输出
                break;
            }
        }
    }
    return 0;//结束
}
```
这题以前模拟考过，就没提交，翻正当时是懵了

---

## 作者：厨师长_阿才 (赞：2)

11月3号正在我睡午觉的时候，突然灵光一现，起床写出了正确的代码，特别开心，虽然比赛的时候已经知道了规律但没有爆出正解有点遗憾不过就在这天我码出了正确的代码，正确的思路是根据题目可以得到一个关于这个“树”的规律，当然有关于斐波那契

每个月都有f[n-1]个兔子长大 生出f[n-2]只兔子

这样我们打一个f[60]的斐波那契数列存到f中

之后就从60到1枚举，

数组中存的相当于是每一月出来的孩子中最大的那个编号的节点

则就可以写出一个关于这个节点是属于哪一个父亲节点的方程

**fa[x]=x-f[i-1]//x是这个节点（前提是x<=f[i],x>f[i-1])**

之后这是正确的代码，下面有一个比赛的暴力代码，建议大家比赛的时候先打暴力，尽量别打表除了数据很小，打表留到最后不然太浪费时间了（打表是在你完全没有思路的时候采用的毕竟不能作为正解）

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#define MAXN 65
#define ll long long
using namespace std;
int tot=0;
int cnt=0;
ll f[MAXN];
ll a[MAXN];
ll b[MAXN];
int n;
void feibo(){
    f[1]=f[2]=1;
    for(int i=3;i<=60;i++){
        f[i]=f[i-1]+f[i-2];
    }
}
int main(){
    feibo();
    cin>>n;
    while(n){
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        ll x,y;
        cin>>x>>y;
        tot=cnt=0;
        for(int i=60;i>=1;i--){
            if(x<=f[i]&&x>f[i-1]){
                a[++tot]=x;
                x-=f[i-1];
            }
            if(y<=f[i]&&y>f[i-1]){
                b[++cnt]=y;
                y-=f[i-1];
            }
        }
        int ans=0;
        for(int i=1;i<=tot;i++){
            for(int j=1;j<=cnt;j++){
                if(a[i]==b[j]){
                    cout<<a[i]<<endl;
                    ans=1;
                    break;
                }
            }
            if(ans==1)break;
        }
        n--;
    }
}
```
下面是暴力的代码
考试的时候打算用特殊性质骗分，但是因为矩阵快速幂算斐波那契导致翻车就比较尴尬了 幸好把第1,2两个点打表不至于爆零

考试结束之后

又完善了一下自己的代码

虽然没有A但是还是水了90分

用LCA 跟斐波那契数列建树

有题目中我们可以知道

每个月都有f[n-1]个兔子长大 生出f[n-2]只兔子

这样我们就可以构建一棵树

至于具体的构建方法可以看看我的代码

之后这是70分

另外的20分可以用性质过

不过我的代码是先走性质之后走LCA

所以可以参考一下思路

这个难度的题我觉得真的考试的时候能拿70+就差不多了

然后范围如果不超的的话可以尝试开大点说不定有个点能水过（祝大家联赛rp+99999999999999999）

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define ll long long
#define MAXN 65
using namespace std;
ll x,y;
ll m;
ll f[MAXN];
ll tot=1,cnt=1;
ll a[100],b[100];
ll father[1000005][25],deep[1000005];
ll maxh;
ll LCA(ll u,ll v){
    if(u==v) return u;
    if(deep[u]<deep[v]) swap(u,v);
    int d=deep[u]-deep[v];
    if(d!=0) for(ll i=0;i<=maxh;i++)
        if((1<<i)&d) u=father[u][i];
    if(u==v) return u;
    for(ll i=maxh;i>=0;i--)
        if(father[u][i]!=father[v][i]){
            u=father[u][i];
            v=father[v][i];
        }
    return father[u][0];
}
void feibo(){
    f[1]=f[2]=1;
    for(int i=3;i<=62;i++){
        f[i]=f[i-1]+f[i-2];
    }
}
int main(){
    cin>>m;
    feibo();
    if(m==13||m==1005||m==300008){
        for(int i=1;i<=m;i++){
        cin>>x>>y;
        for(int i=1;i<=60;i++){
            if(f[i]==x) tot=i;
            if(f[i]==y) cnt=i;
        }
        if((tot%2==0&&cnt%2==0)||(tot%2!=0&&cnt%2!=0)){
            ll minn=min(x,y);
            cout<<minn<<endl;
        }
        else{
            cout<<"1"<<endl;
        }
    }
}
    if(m==1006||m==300009){
        for(int i=1;i<=m;i++){
        cin>>x>>y;
        if(x==y){
            cout<<x<<endl;
        }
        else
        cout<<"1"<<endl;
    }
    }
    if(m==14||m==1007||m==300010){
    father[1][0]=0;
    father[2][0]=father[3][0]=1;
    deep[1]=1;
    deep[2]=deep[3]=2;
    for(int i=2,a=1,b=2,now=4;now<=1000000;i++){
        for(int j=1;j<=b&&now<=1000000;j++){
            father[now][0]=j;
            deep[now++]=deep[j]+1;
        }
        int c=a+b;
        a=b;
        b=c;
    }
    maxh=22;
    for(int k=1;k<=maxh;k++)
        for(int i=1;i<=1000000;i++)
            father[i][k]=father[father[i][k-1]][k-1];
    while(m--){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",LCA(l,r));
    }
    return 0;
}
    if(m==11||m==12)
        for(int i=1;i<=m;i++){
            cin>>a[i]>>b[i];
            if(a[i]==1&&b[i]==1)
                puts("1");
            if(a[i]==1&&b[i]==2)
                puts("1");
            if(a[i]==1&&b[i]==3)
                puts("1");
            if(a[i]==1&&b[i]==4)
                puts("1");
            if(a[i]==1&&b[i]==5)
                puts("1");
            if(a[i]==1&&b[i]==6)
                puts("1");
            if(a[i]==1&&b[i]==7)
                puts("1");
            if(a[i]==1&&b[i]==8)
                puts("1");
            if(a[i]==1&&b[i]==9)
                puts("1");
            if(a[i]==1&&b[i]==10)
                puts("1");
            if(a[i]==1&&b[i]==11)
                puts("1");
            if(a[i]==1&&b[i]==12)
                puts("1");
            if(a[i]==1&&b[i]==13)
                puts("1");
            if(a[i]==1&&b[i]==14)
                puts("1");
            if(a[i]==1&&b[i]==15)
                puts("1");
            if(a[i]==2&&b[i]==1)
                puts("1");
            if(a[i]==2&&b[i]==2)
                puts("2");
            if(a[i]==2&&b[i]==3)
                puts("1");
            if(a[i]==2&&b[i]==4)
                puts("1");
            if(a[i]==2&&b[i]==5)
                puts("2");
            if(a[i]==2&&b[i]==6)
                puts("1");
            if(a[i]==2&&b[i]==7)
                puts("2");
            if(a[i]==2&&b[i]==8)
                puts("1");
            if(a[i]==2&&b[i]==9)
                puts("1");
            if(a[i]==2&&b[i]==10)
                puts("2");
            if(a[i]==2&&b[i]==11)
                puts("1");
            if(a[i]==2&&b[i]==12)
                puts("1");
            if(a[i]==2&&b[i]==13)
                puts("2");
            if(a[i]==2&&b[i]==14)
                puts("1");
            if(a[i]==2&&b[i]==15)
                puts("2");
            if(a[i]==3&&b[i]==1)
                puts("1");
            if(a[i]==3&&b[i]==2)
                puts("1");
            if(a[i]==3&&b[i]==3)
                puts("3");
            if(a[i]==3&&b[i]==4)
                puts("1");
            if(a[i]==3&&b[i]==5)
                puts("1");
            if(a[i]==3&&b[i]==6)
                puts("1");
            if(a[i]==3&&b[i]==7)
                puts("1");
            if(a[i]==3&&b[i]==8)
                puts("3");
            if(a[i]==3&&b[i]==9)
                puts("1");
            if(a[i]==3&&b[i]==10)
                puts("1");
            if(a[i]==3&&b[i]==11)
                puts("3");
            if(a[i]==3&&b[i]==12)
                puts("1");
            if(a[i]==3&&b[i]==13)
                puts("1");
            if(a[i]==3&&b[i]==14)
                puts("1");
            if(a[i]==3&&b[i]==15)
                puts("1");
            if(a[i]==4&&b[i]==1)
                puts("1");
            if(a[i]==4&&b[i]==2)
                puts("1");
            if(a[i]==4&&b[i]==3)
                puts("1");
            if(a[i]==4&&b[i]==4)
                puts("4");
            if(a[i]==4&&b[i]==5)
                puts("1");
            if(a[i]==4&&b[i]==6)
                puts("1");
            if(a[i]==4&&b[i]==7)
                puts("1");
            if(a[i]==4&&b[i]==8)
                puts("1");
            if(a[i]==4&&b[i]==9)
                puts("1");
            if(a[i]==4&&b[i]==10)
                puts("1");
            if(a[i]==4&&b[i]==11)
                puts("1");
            if(a[i]==4&&b[i]==12)
                puts("4");
            if(a[i]==4&&b[i]==13)
                puts("1");
            if(a[i]==4&&b[i]==14)
                puts("1");
            if(a[i]==4&&b[i]==15)
                puts("1");
            if(a[i]==5&&b[i]==1)
                puts("1");
            if(a[i]==5&&b[i]==2)
                puts("2");
            if(a[i]==5&&b[i]==3)
                puts("1");
            if(a[i]==5&&b[i]==4)
                puts("1");
            if(a[i]==5&&b[i]==5)
                puts("5");
            if(a[i]==5&&b[i]==6)
                puts("1");
            if(a[i]==5&&b[i]==7)
                puts("2");
            if(a[i]==5&&b[i]==8)
                puts("1");
            if(a[i]==5&&b[i]==9)
                puts("1");
            if(a[i]==5&&b[i]==10)
                puts("2");
            if(a[i]==5&&b[i]==11)
                puts("1");
            if(a[i]==5&&b[i]==12)
                puts("1");
            if(a[i]==5&&b[i]==13)
                puts("5");
            if(a[i]==5&&b[i]==14)
                puts("1");
            if(a[i]==5&&b[i]==15)
                puts("2");
            if(a[i]==6&&b[i]==1)
                puts("1");
            if(a[i]==6&&b[i]==2)
                puts("1");
            if(a[i]==6&&b[i]==3)
                puts("1");
            if(a[i]==6&&b[i]==4)
                puts("1");
            if(a[i]==6&&b[i]==5)
                puts("1");
            if(a[i]==6&&b[i]==6)
                puts("6");
            if(a[i]==6&&b[i]==7)
                puts("1");
            if(a[i]==6&&b[i]==8)
                puts("1");
            if(a[i]==6&&b[i]==9)
                puts("1");
            if(a[i]==6&&b[i]==10)
                puts("1");
            if(a[i]==6&&b[i]==11)
                puts("1");
            if(a[i]==6&&b[i]==12)
                puts("1");
            if(a[i]==6&&b[i]==13)
                puts("1");
            if(a[i]==6&&b[i]==14)
                puts("1");
            if(a[i]==6&&b[i]==15)
                puts("1");
            if(a[i]==7&&b[i]==1)
                puts("1");
            if(a[i]==7&&b[i]==2)
                puts("2");
            if(a[i]==7&&b[i]==3)
                puts("1");
            if(a[i]==7&&b[i]==4)
                puts("1");
            if(a[i]==7&&b[i]==5)
                puts("2");
            if(a[i]==7&&b[i]==6)
                puts("1");
            if(a[i]==7&&b[i]==7)
                puts("7");
            if(a[i]==7&&b[i]==8)
                puts("1");
            if(a[i]==7&&b[i]==9)
                puts("1");
            if(a[i]==7&&b[i]==10)
                puts("2");
            if(a[i]==7&&b[i]==11)
                puts("1");
            if(a[i]==7&&b[i]==12)
                puts("1");
            if(a[i]==7&&b[i]==13)
                puts("2");
            if(a[i]==7&&b[i]==14)
                puts("1");
            if(a[i]==7&&b[i]==15)
                puts("2");
            if(a[i]==8&&b[i]==1)
                puts("1");
            if(a[i]==8&&b[i]==2)
                puts("1");
            if(a[i]==8&&b[i]==3)
                puts("3");
            if(a[i]==8&&b[i]==4)
                puts("1");
            if(a[i]==8&&b[i]==5)
                puts("1");
            if(a[i]==8&&b[i]==6)
                puts("1");
            if(a[i]==8&&b[i]==7)
                puts("1");
            if(a[i]==8&&b[i]==8)
                puts("8");
            if(a[i]==8&&b[i]==9)
                puts("1");
            if(a[i]==8&&b[i]==10)
                puts("1");
            if(a[i]==8&&b[i]==11)
                puts("3");
            if(a[i]==8&&b[i]==12)
                puts("1");
            if(a[i]==8&&b[i]==13)
                puts("1");
            if(a[i]==8&&b[i]==14)
                puts("1");
            if(a[i]==8&&b[i]==15)
                puts("1");
            if(a[i]==9&&b[i]==1)
                puts("1");
            if(a[i]==9&&b[i]==2)
                puts("1");
            if(a[i]==9&&b[i]==3)
                puts("1");
            if(a[i]==9&&b[i]==4)
                puts("1");
            if(a[i]==9&&b[i]==5)
                puts("1");
            if(a[i]==9&&b[i]==6)
                puts("1");
            if(a[i]==9&&b[i]==7)
                puts("1");
            if(a[i]==9&&b[i]==8)
                puts("1");
            if(a[i]==9&&b[i]==9)
                puts("9");
            if(a[i]==9&&b[i]==10)
                puts("1");
            if(a[i]==9&&b[i]==11)
                puts("1");
            if(a[i]==9&&b[i]==12)
                puts("1");
            if(a[i]==9&&b[i]==13)
                puts("1");
            if(a[i]==9&&b[i]==14)
                puts("1");
            if(a[i]==9&&b[i]==15)
                puts("1");
            if(a[i]==10&&b[i]==1)
                puts("1");
            if(a[i]==10&&b[i]==2)
                puts("2");
            if(a[i]==10&&b[i]==3)
                puts("1");
            if(a[i]==10&&b[i]==4)
                puts("1");
            if(a[i]==10&&b[i]==5)
                puts("2");
            if(a[i]==10&&b[i]==6)
                puts("1");
            if(a[i]==10&&b[i]==7)
                puts("2");
            if(a[i]==10&&b[i]==8)
                puts("1");
            if(a[i]==10&&b[i]==9)
                puts("1");
            if(a[i]==10&&b[i]==10)
                puts("10");
            if(a[i]==10&&b[i]==11)
                puts("1");
            if(a[i]==10&&b[i]==12)
                puts("1");
            if(a[i]==10&&b[i]==13)
                puts("2");
            if(a[i]==10&&b[i]==14)
                puts("1");
            if(a[i]==10&&b[i]==15)
                puts("2");
            if(a[i]==11&&b[i]==1)
                puts("1");
            if(a[i]==11&&b[i]==2)
                puts("1");
            if(a[i]==11&&b[i]==3)
                puts("3");
            if(a[i]==11&&b[i]==4)
                puts("1");
            if(a[i]==11&&b[i]==5)
                puts("1");
            if(a[i]==11&&b[i]==6)
                puts("1");
            if(a[i]==11&&b[i]==7)
                puts("1");
            if(a[i]==11&&b[i]==8)
                puts("3");
            if(a[i]==11&&b[i]==9)
                puts("1");
            if(a[i]==11&&b[i]==10)
                puts("1");
            if(a[i]==11&&b[i]==11)
                puts("11");
            if(a[i]==11&&b[i]==12)
                puts("1");
            if(a[i]==11&&b[i]==13)
                puts("1");
            if(a[i]==11&&b[i]==14)
                puts("1");
            if(a[i]==11&&b[i]==15)
                puts("1");
            if(a[i]==12&&b[i]==1)
                puts("1");
            if(a[i]==12&&b[i]==2)
                puts("1");
            if(a[i]==12&&b[i]==3)
                puts("1");
            if(a[i]==12&&b[i]==4)
                puts("4");
            if(a[i]==12&&b[i]==5)
                puts("1");
            if(a[i]==12&&b[i]==6)
                puts("1");
            if(a[i]==12&&b[i]==7)
                puts("1");
            if(a[i]==12&&b[i]==8)
                puts("1");
            if(a[i]==12&&b[i]==9)
                puts("1");
            if(a[i]==12&&b[i]==10)
                puts("1");
            if(a[i]==12&&b[i]==11)
                puts("1");
            if(a[i]==12&&b[i]==12)
                puts("12");
            if(a[i]==12&&b[i]==13)
                puts("1");
            if(a[i]==12&&b[i]==14)
                puts("1");
            if(a[i]==12&&b[i]==15)
                puts("1");
            if(a[i]==13&&b[i]==1)
                puts("1");
            if(a[i]==13&&b[i]==2)
                puts("2");
            if(a[i]==13&&b[i]==3)
                puts("1");
            if(a[i]==13&&b[i]==4)
                puts("1");
            if(a[i]==13&&b[i]==5)
                puts("5");
            if(a[i]==13&&b[i]==6)
                puts("1");
            if(a[i]==13&&b[i]==7)
                puts("2");
            if(a[i]==13&&b[i]==8)
                puts("1");
            if(a[i]==13&&b[i]==9)
                puts("1");
            if(a[i]==13&&b[i]==10)
                puts("2");
            if(a[i]==13&&b[i]==11)
                puts("1");
            if(a[i]==13&&b[i]==12)
                puts("1");
            if(a[i]==13&&b[i]==13)
                puts("13");
            if(a[i]==13&&b[i]==14)
                puts("1");
            if(a[i]==13&&b[i]==15)
                puts("2");
            if(a[i]==14&&b[i]==1)
                puts("1");
            if(a[i]==14&&b[i]==2)
                puts("1");
            if(a[i]==14&&b[i]==3)
                puts("1");
            if(a[i]==14&&b[i]==4)
                puts("1");
            if(a[i]==14&&b[i]==5)
                puts("1");
            if(a[i]==14&&b[i]==6)
                puts("1");
            if(a[i]==14&&b[i]==7)
                puts("1");
            if(a[i]==14&&b[i]==8)
                puts("1");
            if(a[i]==14&&b[i]==9)
                puts("1");
            if(a[i]==14&&b[i]==10)
                puts("1");
            if(a[i]==14&&b[i]==11)
                puts("1");
            if(a[i]==14&&b[i]==12)
                puts("1");
            if(a[i]==14&&b[i]==13)
                puts("1");
            if(a[i]==14&&b[i]==14)
                puts("14");
            if(a[i]==14&&b[i]==15)
                puts("1");
            if(a[i]==15&&b[i]==1)
                puts("1");
            if(a[i]==15&&b[i]==2)
                puts("2");
            if(a[i]==15&&b[i]==3)
                puts("1");
            if(a[i]==15&&b[i]==4)
                puts("1");
            if(a[i]==15&&b[i]==5)
                puts("2");
            if(a[i]==15&&b[i]==6)
                puts("1");
            if(a[i]==15&&b[i]==7)
                puts("2");
            if(a[i]==15&&b[i]==8)
                puts("1");
            if(a[i]==15&&b[i]==9)
                puts("1");
            if(a[i]==15&&b[i]==10)
                puts("2");
            if(a[i]==15&&b[i]==11)
                puts("1");
            if(a[i]==15&&b[i]==12)
                puts("1");
            if(a[i]==15&&b[i]==13)
                puts("2");
            if(a[i]==15&&b[i]==14)
                puts("1");
            if(a[i]==15&&b[i]==15)
                puts("15");
        }
        return 0;
}
```

---

## 作者：windows250 (赞：2)

![样例](https://cdn.luogu.com.cn/upload/pic/9806.png)

以上图为例,我们先把新出生的兔子按月份划分:

![列表](https://cdn.luogu.com.cn/upload/pic/10084.png)

不难看出,2,3,4,6,9的父节点是1;5,7,10的父节点是2;8,11的父节点是3;12的父节点是4,13的父节点是5......

结合图表,我们容易发现:**任意一个月份中出生的兔子的父节点 是 该兔子所在月份中的序号**,比如说12号兔子,在5月份出生的兔子中排第4,他的父节点就是4

有了上述结论，我们就可以O(n)建图然后愉快地求LCA拿到70分了(捂脸)

但事实上完全没必要那么做,我们需要的不过是**"某只兔子在出生月份中的序号"**而已,进一步观察可以发现:

**某只兔子在出生月份中的序号=这只兔子的实际编号-到上个月为止出生兔子的总数**

比如 8号兔子的序号=8-5=3,则8号兔子的父节点是3,那么3号兔子的父节点编号=3-2=1,即3号兔子的父亲是1，显然，这是一个递归求解的过程

设到第**N**个月兔子的总数为 **tot[N]**，当前兔子的实际编号为**x**，则有:

**Fa[x]=x-tot[lower\_bound(tot,tot+sum+1,x)-tot-1]**

再结合给出的图例可以发现,子节点的编号一定大于父节点,因此在递归求解时若a>b则向前找a的父节点,a<b找b的父节点,当a=b时当前节点就是答案了。


**虽然分析了这么多但程序实现起来还是很简单的:**

```cpp
#include<cstdio>
#include<algorithm>
#define in(x) x=read() 
#define pre(x) x-tot[lower_bound(tot,tot+sum+1,x)-tot-1]
#define MAXQ 300001
#define MAXN 101

using namespace std;
typedef long long ll;

inline ll read()
{
    ll X=0;char ch=getchar();
    while(ch>'9' || ch<'0') ch=getchar();
    while(ch<='9' && ch>='0') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X;
}

struct data
{
    ll a,b;
}que[MAXQ];
ll m,pmax,sum=2;
ll fb[MAXN]={0,1,1},tot[MAXN]={1,2,3};

inline void query(ll a,ll b)
{
    if(a!=b) a>b?query(pre(a),b):query(a,pre(b));
    else printf("%lld\n",a);
}

int main()
{
    in(m);
    for(int i=1;i<=m;i++)
    {
        in(que[i].a),in(que[i].b);
        pmax=max(pmax,max(que[i].a,que[i].b));
    }
    while(tot[sum]<=pmax)
    {
        fb[++sum]=fb[sum-1]+fb[sum-2];
        tot[sum]=tot[sum-1]+fb[sum];
    }
    for(int i=1;i<=m;i++) query(que[i].a,que[i].b);
    return 0;
}
//By windows250 
```

---

## 作者：Predator_SD (赞：1)

本来这题后三个点我是过不了的


开O2后AC


这题。。。。看眼数据范围就知道是数学题了（掩面


手动列一下各点的爹：


1 2 3 4 5 6 7 8 9 10 11 12 13


1 1 1 1 2 1 2 3 1 2 3 4 5


你会发现，就是个斐波那契。。。。。。


然后，因为fib是指数级增长的，所以打一下fib小于1e12的前缀和的表：


ll biao[59]={0,3,4,6,9,14,22,35,56,90,145,234,378,611,988,1598,2585,4182,6766,10947,17712,28658,46369,75026,121394,196419,317812,514230,832041,1346270,2178310,3524579,5702888,9227466,14930353,24157818,39088170,63245987,102334156,165580142,267914297,433494438,701408734,1134903171,1836311904,2971215074,4807526977,7778742050,12586269026,20365011075,32951280100,53316291174,86267571273,139583862446,225851433718,365435296163,591286729880,956722026042,1548008755921};


然后查找的时候只要二分:biao[mid]<=a<biao[mid+1]就可以了，复杂度log


后面的话用set维护链，爬链查找就可以了


注意要及时退出，并且清空set


附AC代码：



```cpp
#include<cstdio>
#include<iostream>
#include<set>
#define ll long long
using namespace std;
template<typename T>
inline void read(T &x){
  char ch;while((ch=getchar()),(ch>'9'||ch<'0'));
  x=ch-'0';while((ch=getchar()),(ch>='0'&&ch<='9')) x=x*10+ch-'0';
}
int m;
ll biao[59]={0,3,4,6,9,14,22,35,56,90,145,234,378,611,988,1598,2585,4182,6766,10947,17712,28658,46369,75026,121394,196419,317812,514230,832041,1346270,2178310,3524579,5702888,9227466,14930353,24157818,39088170,63245987,102334156,165580142,267914297,433494438,701408734,1134903171,1836311904,2971215074,4807526977,7778742050,12586269026,20365011075,32951280100,53316291174,86267571273,139583862446,225851433718,365435296163,591286729880,956722026042,1548008755921};
inline ll find(ll a){
    if(a==1||a==2||a==3||a==4) return 1;
    int l=0,r=58,mid;
    while(l-r){
        mid=l+((r-l)>>1);
        if(a>=biao[mid]&&a<biao[mid+1]){return a-biao[mid]+1;}
        if(a>biao[mid]) l=mid;
        if(a<biao[mid]) r=mid;
    }
}
set<ll> t;
int main(){
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    read(m);
    register int i;
    register ll a,b;
    for(i=1;i<=m;++i){
        read(a),read(b);
        t.insert(a);
        while(true){a=find(a),t.insert(a);if(a==1)break;}
        if(t.count(b)){printf("%lld\n",b),t.clear();continue;}
        while(true){
            b=find(b);
            if(t.count(b)){printf("%lld\n",b);break;}
        }
        t.clear();
    }
    return 0;
}
```
顺便吐槽几句：

1.这题NOIp D1T1。。。。。。清真！


2.大样例可真是大啊（掩面


3.我的电脑太垃圾了，开O2 1.3s，吓得我还以为我挂了


4.我这么垃圾，看来只会写T1了

![](https://cdn.luogu.com.cn/upload/pic/9424.png)


---

## 作者：faker121 (赞：1)

想不到我这个蒟蒻居然能发一波题解。。

融合了某位大佬的精华思想。。在此鸣谢 @whbwhb

既然题目是斐波那契 那一定是跟斐波那契有点点关系的。。。

首先根据题意模拟建树的话 用O（n）建图貌似能过70分

但是一看数据 10^12 说明建图做法是不可取的

那么。。一定有什么数学关系

首先 写个斐波那契出来 证明到达10^12个点 最多需要f（60）左右

然后根据题意大概画个图

凑活看一下

1  2  3  4  5  6  7  8  9  10  11  12  //找对应父节点

2
3
4  5
6  7  8

9  10 11 12 13

14 15 16 17 18 19 20 21

22 23 24 25 26 27 28 29 30 31 32 33 34

……
不难看出对于每一个确切的点 可以通过预处理的斐波那契得到他的父节点

即每层点是从f（i-1）到f（i）的 差值即为当前层的父节点

然后可以用类似lca的想法一层层跳 因为层数最多60 所以在线处理不会超时

至于代码我就不粘了（不会告诉你我是9:40开始写的然后爆零了）

这个思想蛮好理解的 自己写写递归或者用循环都可以过

处理小技巧：如果想两个点一起跳的话 可以标记一下走过的点 第一个跳到的被标记过的父节点时即为最近公共祖先

这样代码比较简洁 比lca逐层处理好写一点


---

## 作者：HEYUNUO (赞：0)

第一次写题解，有什么不好的地方，请大佬们提出。
刚开始看到这道题时，我以为这是一道树上LCA。
但因为这是这套题的第一道题，所以事情没有那么简单。
按照规律，这就是一道打表找规律题。
是一个很蠢的~~跳一跳~~的模拟。
当然我没有想那么多，直接写了这个模拟。
通过一些读写优化能够不TLE。
接下来就是我的代码思路：
第一步准备
	先将前六十位斐波那契数列算好，因为1e12的数据范围刚好就是第六十位。
    然后我求了个斐波那契的前缀和。主要是为了找到这个点的出生月份。
第二步查找
	分别找到它们的父节点、出生月份，然后一直比较，直到父节点相等。
细节注意
	1、当两个子节点相等时，直接判断父节点输出即可。
   2、谁的父节点大（数值大），就让它跳。
不加读写优化跑的挺慢。
建议学习一下快读快写。
提高程序容错率。
下面发我的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar
#define rg register int
#define re register long long
long long fb[70];
inline long long read()
{
	char c=gc();
	long long x=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c-'0');c=gc();}
	return x*f;
}
inline void rework()
{
	fb[1]=1;fb[2]=2;fb[3]=3;
	re a=1,b=1,t=3;
	for(rg i=1;i;i++)
	{
		t++;
		re c=a+b;
		a=b;
		b=c;
		fb[t]=c+fb[t-1];
		if(fb[t]>1e12)
		{
			return;
		}
	}
}
inline int find(re x)
{
	for(rg i=1;i<=59;i++)
	{
		if(x<=fb[i])
		{
			return i;
		}
	}
}
inline long long work(re a,re b)
{
	if(a==b)
	{
		return a;
	}
	long long ans1=0,ans2=0;
	long long ra=a,rb=b;
	int ma=find(a);
	int mb=find(b);
	long long fta=a-fb[ma-1];
	long long ftb=b-fb[mb-1];
	for(rg i=1;i;i++)
	{
		if(fta==ftb)
		{
			ans1=fta;
			break;
		}
		if(fta==rb)
		{
			ans2=rb;
			break;
		}
		if(ftb==ra)
		{
			ans2=ra;
			break;
		}
		if(fta<ftb)
		{
			b=ftb;
			mb=find(b);
			ftb=b-fb[mb-1];
		}
		else
		{
			a=fta;
			ma=find(a);
			fta=a-fb[ma-1];
		}
	}	
	return max(ans1,ans2);
}
int main()
{
	rg m=read();
	rework();
	for(rg i=1;i<=m;i++)
	{
		re a=read(),b=read();
		printf("%lld\n",work(a,b));
	}
	return 0;
}
```

---

## 作者：八重樱 (赞：0)

其实这道题是一道数学题,跟图论LCA之类的一点关系都没有.

虽然据说有JuLao用各种优化AK了,不过写LCA的大部分都炸了,所以还是安安心心数学推理吧.

求编号为A,B的兔子的LCA,可以先求出各自的各辈祖先.

根据Fibonacci数列,最高辈分不会超过61辈,那么求出来后随便怎么暴力都行.

至于存放各自祖先的容器,个人感觉开两个vector<龙龙>就行了.

那么问题来了:怎么求各辈祖先?

首先预处理出Fibonacci表,前两个元素0,1不要了,或加特判.

在容器中加入A.

不难发现,A兔子的父亲编号为C,C==A-Fibonacci[K],K满足(Fibonacci[K]<A&&A<=Fibonacci[K+1]).

那么首先一个O(log(logA))二分查找,其实用O(logA)暴力查找也是很容易过的,找到他的父亲.

在容器中加入C.

为了尽量做到最优,接下来不用O(log(logA))的二分查找,而是O(1)的暴力查找.

由于Fibonacci数列的性质,必然有(Fibonacci[K-1]<C&&C<=Fibonacci[K]).

那么C兔子的父亲编号为D,D==C-Fibonacci[K-1],就这样直到找到最高祖先(编号为1的兔子).

在容器中加入D.

就这样以此继续暴力查找A兔子的祖先们.B兔子同上.

两次总时间复杂度O((logA-1+log(logA))+(logB-1+log(logB)))即为O(LogA).

然后从各自的最高辈(即容器顶)比较,过程很简单就一句带过.

找到不一样的就输出他们的祖先(一定是同一个).

若其中一个的容器找完了还没找到,即一个是另有规定祖先,那就输出该容器底.

比较的时间复杂度O(log(min(A,B)+1))即为O(LogA).

全题O(mlogA),用了数学方法后拿几个特殊条件可以高傲地无视.

另:重要:

一定要开long long!!!!!

不然会像我一样卡在70分DeBug几个小时还找不出错.


---

## 作者：carlchen666 (赞：0)

//可以证明：对于每个点的父节点便是这个点编号减去刚好比他小的那个斐波那契数


        
        
                
        
    
    
```cpp
//于是便可以找出输入点的所有父节点
//再将父节点比对便行了
#include <cstdio>
#include <iostream>
#include <cstdlib>
using namespace std;
long long a[100000];
long long ans1[100],ans2[100];
int l1,l2,n=3,f1,f2,m,flag;
long long aa,bb;
long long find1(long long x)//找第一个数的父节点
{
    for(int i=1;i<=n&&f1==0;i++)
    {
        if(x<=a[i])
        {
            l1++;
            ans1[l1]=x-a[i-1]; 
            if(ans1[l1]==1) f1=1;    
             else find1(ans1[l1]); 
        }            
    }
}
long long find2(long long x)//找第二个数的父节点
{
    for(int i=1;i<=n&&f2==0;i++)
    {
        if(x<=a[i])
        {
            l2++;
            ans2[l2]=x-a[i-1]; 
            if(ans2[l2]==1) f2=1;    
             else find2(ans2[l2]); 
        }            
    }
}
int main()
{  
    a[1]=1; a[2]=1;  
    while(1)//打表斐波那契数
    {
        a[n]=a[n-1]+a[n-2];
        if(a[n]>=2*(1e12)) break;
        n++;
    }   
    scanf("%lld",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%lld%lld",&aa,&bb);
        l1=1;l2=1;flag=1;f1=0;f2=0;
        ans1[l1]=aa; ans2[l2]=bb;
        find1(aa); find2(bb); 
        int s1=1,s2=1;
        while(flag)//比对两个数的父节点
        {
            if(ans1[s1]>ans2[s2])  s1++;
            else if(ans1[s1]<ans2[s2])  s2++;
            else
            {cout<<ans1[s1]<<endl; flag=0;}
        }
    }
    return 0;
}

```

---

## 作者：xw001 (赞：0)

看到没人贴代码，本蒟篛就过来贴一波我的,写的不好看，大佬表喷的太厉害、、、

#本题关键就是要推出父亲和儿子的关系

因为有了这个关系就可以让两个点一步一步往父亲那里找，直到两个点是相同时说明就是最近公共祖先了

首先每个月兔子出生后，所有兔子的数量用一个数组**f[i]**表示，那么不难发现f[i] = f[i-1] + f[i-2]也就是斐波那契数列（相当于上个月兔子数量加上 上上个月兔子 的数量（只有上上个月的兔子长大了又生育能力。。。））。然后我们就要去找儿子和父亲的编号的关系了。

然后我们发现儿子和父亲的编号我们不能记录下来（a\_i最大有10……12）,所以我们只能在线查询。设某个儿子编号为**x**，那么易的他的父亲的编号为**x-f[i]**,其中f[i]为小于x的最大的那个数。举个栗子，第3月有一堆兔子，1，2，3，4，5；2是第一个月出生的兔子，3是第2个月出生的兔子，4和5是第3个月出生的兔子，那么4这个兔子的父亲其实就等于4-f[i]，f[i]就等于3，说明1是4的父亲。为什么是这样的呢？首先我们发现4和1，5和2是一一对应关系，而他们的距离其实就是上个月兔子的数量，所以说一个兔子的父亲编号其实就是该兔子编号减去上个月兔子的数量，即x-f[i]，其中f[i]是上个月兔子的数量，但是我们也不会记录每个兔子是哪个月出生的，所以我们用二分查找一个最大的f[i]，使得f[i]小于x,就是父亲的编号了。

那么有了父亲的编号，我们就可以往回查找了。

这里我同时记录的该点的辈分，也就相当于深度这个东西，至于这个辈分怎么求，其实就是刚才求到的f[i]的i

如果a的深度大就让a往上调，如果b的深度大就让b往上跳，否则一起往上跳，直到两个点是同一个点就停止并且返回相同时的答案

对了不要混用数据类型，会错掉。。。还有本蒟篛真的感觉这个绿题比别的绿题更难想更难写。。

...cpp
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long LL; // 定义一个数据类型，简化程序 
LL f[61],x ,y;
int i , m ;
int ef(LL x){                        //二分查找上个月兔子的数量，也就是比他小的最大值f[i] 
    int l = 1,r = 60,mid=60;    
    while(l<=r){
        mid = (l+r) / 2;
        if(f[mid] >= x)
            r = mid - 1;
        else
            l = mid + 1;
    }
    while(f[mid] >= x)
        mid -- ;
    return mid;                    //返回的是该点的辈分 也就是f[i]中的i 
}
LL lca(LL x,LL y){            
    if(x == 1 || y == 1)    return 1;        //特判的话可以骗分。。 
    if(x == y+1 || y == x+1) return 1;
    int depx,depy;
    depx = ef(x);        //得到这个点的辈分（深度） 
    depy = ef(y);
    while(1){
        while(depx != depy){        //如果两个点深度不同就让深度大的点往上跳 
            while(depy>depx && y!=1){
                y -=f[depy];    
                while(depy>0 && f[depy] >= y)    //跳完只有要再找f[i]也就是方便下次跳，为什么不是他的上一辈？呵呵，你的祖先一直在生产。。鬼晓得你是哪一辈，所以还是暴力找f[i] 
                    depy--;
            }
            while(depx>depy && x!=1){
                x -= f[depx];
                while(depx>0 && f[depx] >= x)
                    depx--;
            }
            if(x == y)        // 如果这里已经找到了就返回这个值 
                return x;
        }
        while(x != y){            //如果两个是同一辈的，就一起往上跳 
            if(x!=1){        // 1不用跳。。。 
                x = x-f[depx];
                while(depx>0 && f[depx] >= x)    
                    depx--;    
            }    
            if(y!=1){
                y = y-f[depy];
                while(depy>0 && f[depy] >= y)    
                    depy--;
            }
            if(depy != depx)    // 如果发现跳着不是同一辈了就再退出返回上面那个不是同一辈的查找 
                break;
        }
        if(x == y)
            return x;
    }
}
int main(){
    scanf("%d",&m);
    f[0] = 1;
    f[1] = 1;
    f[2] = 1;             //初始化 
    for(i = 3;i <= 60; i++)        //f[60] > 10……12，够用 
        f[i] = f[i- 1] + f[i- 2];
    for(i = 1;i <= m; i++){
        scanf("%lld%lld",&x,&y); 
        printf("%lld\n",lca(x,y));//在线查询 
    }
    return 0;
}
...cpp
```

---

## 作者：坏坏惹人爱 (赞：0)

找规律

对于每个节点，它与它父亲节点编号差一定是斐波那契数列中的一个数

而这个差值为 恰比该节点小的斐波那契数列中的一项

即要找到 i 满足 f[ i ] < max( a,b ) <= f[ i ]+1

做法就是把两个数当中的大数减去f[ i ]直到两数相等，然后输出

而斐波那契数列到f[60]就已经超过1e12了

所以只要开60格数组就够了

以下是本蒟蒻的代码

```cpp
#include<cstdio>
using namespace std;
int m,r;
long long f[61],a,b;
int main(){
    f[1]=1;f[2]=2;
    for(int i=3;i<=60;i++){
        f[i]=f[i-1]+f[i-2];
    }
    scanf("%d",&m);
    while(--m>=0){
        scanf("%lld%lld",&a,&b);
        if(a>b){
            long long t;
            t=a;a=b;b=t;
        }//b用来存较大数，方便操作
        for(int i=1;i<60;i++){
            if(b>f[i] && b<=f[i+1]){
                r=i;break;
```
}//找到恰比b小的f[i]
```cpp
        }
        while(a!=b){
            b-=f[r];
            if(a>b){
                long long t;
                t=a;a=b;b=t;
            }
            while((!(b>f[r] && b<=f[r+1]))&& r>1) 
                r--;//找到恰比b小的f[r]
```
}//若a=b就输出
        printf("%lld\n",a); 

    }
}


---

## 作者：恐怖大魔王 (赞：0)

我也不知道怎么找出的这个规律，总之挺简单的，50行代码过了，不知道为什么当时给我算了90分，赛后一交就ac了。

首先我是标出了所有节点的儿子和它本身的差。

例如 1的儿子和他的差是 1 2 3 5 8.......

2的儿子和他的差是 3 5 8 13.......

3的是 5 8 13......

可以发现差值也是斐波那契，但是每一个都比上一个的差少一些东西。再次观察发现，那些缺少的数字正是上一个的儿子。例如和2差1的和1差2，所以3是1的儿子而不是2的儿子；和3差2的和2差3。假设我们要求5这个数的祖先，我们减斐波那契是优先减去3还是2？经过规律得知要减大的数。所以我们可以知道，一个数减去离他最近（但是不能减到0）的斐波那契数，一定是他的父亲！！。那就太简单了！问题变成了找最大的斐波那契了。

然后再分析，如果是两个数都减的话就错了。应该让较大数减，然后递归处理，因为如果是两个都减，那样永远都碰不上（也能碰上，两个的深度一样），直接到0；

斐波那契数列到1e12就50多个数，不知道二分查找是不是多此一举了。另外倍增我没想过，如果数据再增强的话就不单纯是一道数论题了，难度还要增加。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define maxn 100
long long fei[maxn];//斐波那契数列 
bool check(long long i,long long x){
    if(fei[i]<x)return 1;//判断是否是小于x的最大斐波那契，如果是<=就错了 
    return 0;
}
long long maxx(long long aa,long long bb){
    if(aa>bb)return aa;
    return bb;
```
}//方便调试，所以自己写判断大小
    
        
    

    

```cpp
long long minx(long long aa,long long bb){
    if(aa>bb)return bb;
    return aa;
}
long long erfen(long long c,long long d){//二分查找 
    if(c==d)return c;
    long long l1=0,r1=59;
    long long a=maxx(c,d);
    long long b=minx(c,d);
    long long ans1;
    while(l1<=r1){
    long long mid=(l1+r1)/2;
    if(check(mid,a)){
        ans1=mid;
        l1=mid+1;
    }
    else r1=mid-1;    
    }
    if(a-fei[ans1]==b){
        return a-fei[ans1];
    }
    return erfen(a-fei[ans1],b);    
    }
int main(){
    fei[0]=1;
    fei[1]=1;
    for(int i=2;fei[i-1]<1e12;i++){//根据数据范围预处理 
        fei[i]=fei[i-1]+fei[i-2];
    }
    fei[0]=0;
    long long x=0,y=0;
    int m;
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        scanf("%lld%lld",&x,&y);
        printf("%lld\n",erfen(x,y));
    }
} 

```

---

## 作者：vani_prcups (赞：0)

这题我比赛的时候只有80分，貌似是没开O2？

首先我们要找到一个规律：一个结点的父亲，等于这个结点减去最后一个小于它的斐波那契数。这样，我们就掌握了给结点“找爸爸”的方法。

接下来就可以暴力向上爬，找寻两个点共同的祖先了。

昨天我这里想多了，考虑了层数问题，导致程序麻烦并且常数很大。鉴于思路没什么问题，所以还是放了篇题解。

其实dalao们的惯用做法是：循环操作a、b两节点，谁大谁就向上爬，最后也能得出正确答案。

不过……我的思路可能好想一些吧。

```cpp
#include<iostream>
#include<cstdio>
#define __ long long
using namespace std;
__ n,f[10005];
void pre()
{
    f[0]=1;
    f[1]=1;
    for (int i=2;i<=60;i++)
    f[i]=f[i-1]+f[i-2];
}
__ gf(__ x)//找爸爸
{
    __ l=1,r=60,mid;
    while (l<=r)
    {
        mid=(l+r)/2;
        if (f[mid]<x)l=mid+1;
        else r=mid-1;
    }
    return x-f[r];
}
__ gd(__ x)//找深度
{
    if (x==1)return 1;
    return gd(gf(x))+1;
}
int main()
{
    scanf("%lld",&n);
    __ u,v;
    pre();
    for (int i=1;i<=n;i++)
    {
        scanf("%lld %lld",&u,&v);
        __ dd=gd(u)-gd(v);
        if (dd<0)swap(u,v);
        if (dd<0)dd=-dd;
        for (int j=1;j<=dd;j++)
        u=gf(u);
        while (u!=v)u=gf(u),v=gf(v);
        printf("%lld\n",u);
    }
}
```

---

## 作者：DarkEyeR (赞：0)

首先我们可以提前建一个斐波那契数列出来，f[1] = 1,f[2] = 2,f[i] = f[i-1]+f[i-2](i >=3)

然后观察他的树，自己画个图模拟一下就可以得到以下结论：

对于一个点g，他的父亲fg = g-第一个比g小的斐波那契数

推出这个结论以后我们显然就可以不用暴力建树的方法了。

对于每个数，我们可以使用这种方式推出它的每个祖先，然后使用朴素的lca方法跑一下，因为树的层数最多只有60，所以不会TLE。

对于找数，我们可以使用二分来进行查找，用暴力查找的话会TLE。

代码写的丑，，，，各位dalao不要嘲笑我这个蒟蒻。。。

最后！！！！记得加long long ，记得加long long ，记得加long long 重要的事情说三遍， 完美因为long long RE 3个点。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <cctype>
#include <algorithm>
using namespace std;
long long int f[1000];

int main(){
    int m,n;
    // freopen("data.in","r",stdin);
    f[0] = f[1] = 1;
    for(n = 2;n <= 60;n++){
        f[n] = f[n-1]+f[n-2];
    }
    scanf("%d",&m);
    long long int a,b;
    while(m--){
        scanf("%lld%lld",&a,&b);
        if(a == b){
            printf("%lld\n",a);
            continue;
        }       
        int i = 0, j = 0;
        long long int arr1[4000],arr2[4000],ans = 0;        //代表a的i层祖先
        arr1[++i] = a;
        arr2[++j] = b;
        if(a == 1){
            arr1[++i] = 1;
        }
        while(a != 1){
            int pos = lower_bound(f+1,f+60,a)-f;
            a = a - f[pos-1];
            arr1[++i] = a;
        }
        if(b == 1){
            arr2[++j] = 1;
        }
        while(b != 1){
            int pos = lower_bound(f+1,f+60,b)-f;
            b = b - f[pos-1];
            arr2[++j] = b;
        }
        int step = abs(i-j);
        int now1 = 0,now2 = 0;
        if(i > j){
            now1 = 1,now2 = 1+step;
            while(arr1[now2] != arr2[now1]){
                now1++;
                now2++;
            }
            ans = arr1[now2];
        }else if(j > i){
            now1 = 1,now2 = 1+step;
            while(arr1[now1] != arr2[now2]){
                now1++;
                now2++;
            }
            ans = arr1[now1];
        }else{
            now1 = 1;
            while(arr1[now1] != arr2[now1]){
                now1++;
            }
            ans = arr1[now1];
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

看到没有大佬发题解,本蒟蒻来水一发题解.

一看这道题,直接给人的感觉就是用斐波那契数列建图,然后求最近公共祖先(我旁边的同学真的是这么做的,花了半晚上找了规律建了图,又调了一会lca,最后三个点RE 70分)

但按照惯例,noip第一题不应该是普及-的难度吗,所以蒟蒻的我自然不会往lca上考虑(其实是不会....),如果仅仅只是普及难度的话,应该只用斐波那契数列就能A掉,带着这个想法,我们开始看题干给出的图;

通过观察,我们不难发现,孩子与父亲直接的差值是一个斐波那契数列里面的数,准确一点的规律似乎我没有用到,给你们贴过来    (第i个月出生的第j只图子的编号为fei[i-1]+j,他的father为j,fei表示斐波那契数列;)本蒟蒻只是发现每一个子节点减去一个刚好小于他的编号的斐波那契数列的值,得出的结果就是他的father；

输入进一组数据之后，找到较大的那个，只需要枚举出刚好比他小的那个斐波那契数列的值，减去那个值，让他往上跳，让这个节点往上跳，类似于暴力lca一步一步跳，但这棵树的深度不超过60（可以自己算一下），所以暴力跳并不超时；

##蒟蒻代码贴在这里

```cpp
//by   我是大傻逼 
#include<iostream>
#include<cstdio>
using namespace std;
long long fei[71],answer[301010],m,z;//fei表示斐波那契数列,answer为结果,m为方案数,z为answer的个数; 
int main()
{
    scanf("%lld",&m);
    fei[1]=1;fei[2]=1;
    for(int i=3;i<=70;i++)
        fei[i]=fei[i-1]+fei[i-2];
    //算出斐波那契数列 ,不过好像不需要到70就过了1e12了,但是无所谓了,对复杂度影响不大; 
    for(int i=1;i<=m;i++)
    {
        long long a,b;
        scanf("%lld%lld",&a,&b);
        long long q,w,e=a,r=b;//q,w为枚举用的指针,e,r分别表示两个要找lca的节点目前跳到了那里; 
        //别问我为什么用q w e r作变量; 
        while(e!=r)
        {
            if(e>r)
            {
                for(q=1;q<=70;q++)
                    if(fei[q]>=e)    break; 
                //这一句其实可以用二分优化,不过好像对复杂度影响不大,我懒得写了;    
                e-=fei[q-1]; //找到刚好比他小的数,并一步一步往上跳; 
            }
            if(e<r)
            {
                for(w=1;w<=70;w++)
                if(fei[w]>=r)    break;
                r-=fei[w-1];
            }//同上; 
        }
        answer[++z]=e;//当两者相等时,即找到了最近公共祖先,记录答案; 
    }
    for(int i=1;i<=z;i++)
        printf("%lld\n",answer[i]);
    //输出; 
    return 0;
} 
```




---

## 作者：吾乃会虎 (赞：0)

我有一个奇妙的解法：	
首先要将每个输入-1	
然后转化为斐波那契进制	
求出最长公共后缀后+1	
即可	
~~别跟我说证明，懒得证明~~	
下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename type>
type get(type &out){
	type sign=1,num=0;
	char input='\0';
	bool over=false,finds=false;
	while((input=getchar())<=32);
	do{
		switch(input){
			case '+':sign=-sign;
			case '-':sign=-sign;
	  					if(!finds)
	  						finds=true;
	  					else
	  						over=true;
	  			break;
	  		case '0':case '1':case '2':case '3':case '4':
	  		case '5':case '6':case '7':case '8':case '9':
	  					num=num*10+(input^48);
	  			break;
	  		default:
				over=true;
				break;
		}
	}while((input=getchar())>32&&!over);
	return out=sign*num;
}
template<typename type>
type put(const type &in){
	type sign=1;
	if(in<0)sign=-sign,putchar('-');
	if(in*sign>=10)put(in*sign/10);
	putchar((in*sign%10)^48);
	return in;
}
const long long MAXN=300000;
long long FBNQ[70]={0,1,2};
long long A[70],B[70];
int main(){
	for(int i=3;i<60;++i)
		FBNQ[i]=FBNQ[i-1]+FBNQ[i-2];
	int n=0;
	get(n);
	while(n--){
		long long a=0,b=0,ans=1;
		get(a),get(b);
		--a,--b;
		for(int i=59;i>0;--i)
			A[i]=a/FBNQ[i],a%=FBNQ[i];
		for(int i=59;i>0;--i)
			B[i]=b/FBNQ[i],b%=FBNQ[i];
		for(int i=0;i<60;++i,ans+=FBNQ[i]*A[i])
			if(A[i+1]!=B[i+1])
				break;
		put(ans);putchar('\n');
	}
	return 0;
} 
```

---

## 作者：star_city (赞：0)

事实上，不需要去一直二分。

我们从大到小枚举斐波那契表，两个数一起减，直到相等，就能得出结果。

比如a = 8, b = 11时，

1.通过二分找到max(a, b)能够减掉的斐波那契表中的最大值f，此时是1, 2, 3, 5, (8), 13...

2.从8到1枚举f，如果a大于f就相减，b也一样。注意：等于的时候不能减（减完就成0了）。

f = 8; a = 8 = f; b = 11 > f, b = b - f = 3；

之后重复进行这个操作：

f = 5; a = 8 > f, a = a - f = 3; b = 3 < f；

a = 3 = b。

所以答案就是3。

正确性？找规律啊。其他楼层都说过了。

于是这样避免了一次次的二分查找从而优化了复杂度。
```
#include <iostream>
#include <algorithm>
#include <cstdio>

typedef long long ll; //开long long

using namespace std;

ll f[100]; //斐波那契表

inline ll read() //快读
{
    ll X = 0, w = 1; char ch = 0;
    while (ch < '0' || ch > '9') { ch = getchar(); if (ch == '-') w = -1; }
    while (ch >= '0' && ch <= '9') X = (X << 3) + (X << 1) + ch - '0', ch = getchar();
    return X * w;
}

ll tackle(ll a, ll b) 
{
    int n = lower_bound(f+1, f+60, max(a, b)) - f - 1; //二分查找max(a, b)能够减掉的斐波那契表中的最大值
    for (int i = n; i; i--) {
        if (a > f[i]) a -= f[i];
        if (b > f[i]) b -= f[i]; //大于就相减
        if (a == b) return a; //相等就是答案
    }
}

int main(void)
{
    f[0] = f[1] = 1;
    for (int i = 2; i <= 60; i++) f[i] = f[i-1] + f[i-2]; //初始化斐波那契表，60就够了
    ll m = read();
    ll a, b;
    while (m--) {
        a = read();
        b = read();
        printf("%lld\n", tackle(a, b));
    }
    
    return 0;
}
```

---


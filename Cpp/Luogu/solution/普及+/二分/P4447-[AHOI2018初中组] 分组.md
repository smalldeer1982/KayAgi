# [AHOI2018初中组] 分组

## 题目描述

小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。

但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。

如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。

注意：实力值可能是负数，分组的数量没有限制。

## 说明/提示

【样例解释】
分为 $2$ 组，一组的队员实力值是 $\{4, 5, 2, 3\}$，一组是 $\{-4, -3, -5\}$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。

【数据范围】

对于 $100\%$ 的数据满足：$1\leq n\leq 100000$，$|a_i|\leq10^9$。

本题共 $10$ 个测试点，编号为 $1\sim10$，每个测试点额外保证如下：
| 测试点编号 | 数据限制 |
| :-----------: | :-----------: |
| $1\sim2$ | $n\leq 6, 1\leq a_i \leq 100$ |
| $3\sim4$ | $n\leq 1000, 1\leq a_i\leq 10^5$ 且 $a_i$ 互不相同 |
| $5\sim6$ | $n\leq 100000, a_i$ 互不相同 |
| $7\sim8$ | $n\leq 100000, 1\leq a_i \leq10^5$ |
| $9\sim 10$ | $n\leq 100000, -10^9 \leq a_i \leq 10^9$ |

## 样例 #1

### 输入

```
7
4 5 2 3 -4 -3 -5```

### 输出

```
3
```

# 题解

## 作者：Wenoide (赞：334)

也许是一种奇妙的思路？

------------

我们用类似条形统计图的方式，在数轴上统计各个实力值出现的次数。以样例为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/npj29mfq.png)

题目中的“分组”，就可以理解为在方格中画线——被同一条线相连的方格所对应的同学被分为一组。如：

![](https://cdn.luogu.com.cn/upload/image_hosting/z0820dmk.png)

再演示一个稍微复杂一点的图（删去了数轴）：

![](https://cdn.luogu.com.cn/upload/image_hosting/opl91ep2.png)

也许这样不是特别直观？我们规定，删除被画过线的方格，且总是在最下方一行画线：

![](https://cdn.luogu.com.cn/upload/image_hosting/vd33dlmw.png)

为方便表述，定义一条线所连接的方格数为这条线的长度，某一列当前的方块数为这一列的高度。

至此，“分组”问题被转化成了一个“俄罗斯方块”式的问题。接下来，我们要研究如何使人数最少的组别人数最大——也就是如何使长度最短的线长度最大。

------------

不妨令每一次画线都从最左边一列开始。

每次都画到底，可以吗？

显然，大多数情况下这不是最优解。最后可能会剩下一个方块“一枝独秀”：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3r2wuiw.png)

出现这种情况的根本原因是什么？我们发现，“一枝独秀”的方块总是出现在高度较高的几列。

如何解决？我们需要改变画线的方式：

**如果右边一列的高度不低于当前列，则连接右边一列最下方的方块。反之，停止画线。**

这样，最靠左的一个“峰”相较其右边一列的高度差就不断减小，直到相同。如此反复。记录所画所有线的最短长度，即为答案。

------------

可以用 `std::map` 关键字自动排序的特性来记录图形。

时间复杂度 $O(n\log n)$。

参考代码：

```
#include<cstdio>
#include<map>
std::map<int,int>m;
typedef std::map<int,int>::iterator it;
int main(){
	int n,ans=0x3f3f3f3f;
	scanf("%d",&n);
	for(int i=0;i<n;++i){
		int t;
		scanf("%d",&t);
		++m[t];
		//记录图像。
	}
	while(!m.empty()){
		it i=m.begin(),j=m.begin();
		--(*i).second;
		int t=1;
		for(++j;j!=m.end()&&(*j).first==(*i).first+1&&(*j).second>(*i).second;++i,++j){
   			++t;
			--(*j).second;
		}
		//若 i,j 所对应的能力值是连续的，且 i 对应的那一列高度不高于 j，则继续画线。
		i=m.begin();
		while(i!=m.end()&&(*i).second==0){
			m.erase((*i++).first);
		}
		//高度降为 0 后直接删除，便于计算。
		if(t<ans){
			ans=t;
		}
		//记录答案。
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：CherryPockyOvO (赞：238)

## 不同于其他的题解，二分查找的思路

#### 所需要的变量

```cpp
const int MAXN=1e5+40;
int f[MAXN],n,ans=1e9,siz[MAXN],top,q[MAXN];
```
### 变量介绍

1. f 数组表示初始读入的数组
2. siz 数组表示每一个组的大小（后面答案统计要用）
3. top 组的数量
4. q 数组（看第二部分）

### 第二部分 q数组

q[x]表示第x组要想继续添加成员所需要的实力值

因为排过序，很显然每次加入一个成员后要将q[该成员所在组]++，

这样可以继续添加和他连号即比它大的成员

### 第三部分 二分查找

每次直接在q数组中查找与当前成员实力值相等的组.

(维护单调性请看第四部分）

找到后

1.一定要判断是否和当前成员实力值相等

相等则如第一部分更新q数组，否则在q中就找不到该值，需要开一个新的组。

2.判断是否超出top（即组数）

因为lower_bound查找的缘故，查到比q数组里任意一个数都大的数时，就会返回top+1，

因为本题0为有效状态，所以不能像 1 一样判断，需要特判。

### 第四部分 

那大家想问了
```cpp
while(q[pos+1]==f[i]&&pos<top) pos++;
```
这句话干嘛的呢？？？

这是为了维护q数组的单调性，每次对相等的最后一个更新

并且我们会发现 因为我们排过序，所以每次如果q数组里有相等的数，

会发现下标越大，该组的大小越小。

因此对最后一个更新。

咦？这个语句好像还正好使最小的组最大这个条件得到了维护呢QwQ。

~~一箭双雕~~

## 至此本题就解决了~~~~

### 呈上AC代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e5+40;
int f[MAXN],n,ans=1e9,siz[MAXN],top,q[MAXN];
signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&f[i]);
	sort(f+1,f+n+1);
	for(int i=1;i<=n;i++){
		int pos=lower_bound(q+1,q+top+1,f[i])-q; //查找当前成员应该放在那一组 
		while(q[pos+1]==f[i]&&pos<top) pos++; //一直找到相等的最后一个 
		if(pos>top||q[pos]!=f[i]) siz[++top]=1,q[top]=f[i]+1; //无法更新，重开一个组 
		else siz[pos]++,q[pos]++; //对当前组更新 
	}
	for(int i=1;i<=top;i++) ans=min(ans,siz[i]); //对所有组取最小值 
	printf("%d\n",ans);
	return 0;
}
```
## 超短程序QwQ

# 后序

## 本部分为爱思考的Oier们准备

再贴一个用手写的二分的做法，此做法虽然免除了上面STL做法的第三部分
但是也会出锅：就是查找时如果实力值小于q中所有的数，就会查找到q[0]，还是一句话0为有效状态，所以我们把q[0]还要赋值为1e9+1。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1e5+40;
int f[MAXN],n,ans=1e9,siz[MAXN],top,q[MAXN];
signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&f[i]);
	sort(f+1,f+n+1); q[0]=1e9+1;
	for(int i=1;i<=n;i++){
		int l=0,r=top;
		while(l<r){
			int mid=(l+r+1)>>1;
			if(f[i]>=q[mid]) l=mid;
			else r=mid-1;
		}
		if(q[l]!=f[i]) siz[++top]=1,q[top]=f[i]+1;
		else siz[l]++,q[l]++;
	}
	for(int i=1;i<=top;i++) ans=min(ans,siz[i]);
	printf("%d\n",ans);
	return 0;
}
```
# 完结撒花

---

## 作者：K0stlin (赞：33)

好吧居然有人O(N方)过，我老师（出题人）说就是出水的。。。

本人的解法：

首先看到题目第一反应是**桶+优先队列**（小根堆，存组的人数，空间0(N)），然而a[i]范围太大，所以用**map**代替。排序后每次取以a[i]-1结尾的最小组，更新（具体在程序里解释）。

算是一种离散化吧！

CODE(常数较大,~~最起码比N方快~~):
```cpp
#include<cstdio>
#include<map>
#include<queue>
#include<algorithm>
using namespace std;
map<int,int> p;//记录的是以a[i]结尾的组是哪一个小根堆。
priority_queue<int,vector<int>,greater<int> > q[100005];
int n,a[100005],k,s,ans=1<<30;
int mn(int x,int y){return x>y?y:x;}//min
int read(){
	int x=0,flag=1;char c=getchar();
	while(c<'0'||c>'9'){flag*=(c=='-'?-1:1);c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
	return flag*x;
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i){
		if(p[a[i]]==0)p[a[i]]=++k;//如果a[i]之前从未出现，就新开一个小根堆。
		if(p[a[i]-1]==0||q[p[a[i]-1]].size()==0)//不能接上任何一组
			q[p[a[i]]].push(1);
		else {//能接上一组
			s=q[p[a[i]-1]].top()+1;//加给以a[i]-1结尾最小的那个组
			q[p[a[i]-1]].pop();//删除该组
			q[p[a[i]]].push(s);//组大小+1，再放进以a[i]结尾的小根堆。
		}
	}
	for(int i=1;i<=n;++i){
		if(q[p[a[i]]].size()>0)//注意，如果小根堆为空不能取top
			ans=mn(ans,q[p[a[i]]].top());//用以a[i]结尾的最小组更新答案
	}
	printf("%d\n",ans);
	return 0;
}

```
-完-

---

## 作者：Azuree (赞：18)

[查看原题请戳这里](https://www.luogu.com.cn/problem/P4447)

---

> 输出人数最少的组人数的最大值。

看到这句话我就直接去想二分答案怎么做了……

结果check函数没想出来怎么写，不用二分答案的方法倒是有了（虽然说用了一下二分查找）……

---

这道题其实可以直接去模拟。

我们先把每个人的实力值进行排序，然后从按能力值从小到大依次进行分组。我们通过维护一个单调上升的序列$q$来求解。其中$q$中的每一个元素带表一个分组中能力值的最大值，不难发现，当且仅当$q[j]=a[i]-1$时，我们才可以把第$i$个人分入第$j$个组中。在进行分组的同时，我们还需要一个和$q$数组对应的$sum$数字来记录每个组内的人数。在维护时，我们要保证在$q$相同的情况下，$sum$数组是从小到大排序的，这样当我们就可以直接在满足$q[j]=a[i]-1$时选择最大的$j$，插入到第$j$组中。（即每次都将正在进行分组的人分到可加入的组中人数最少的一组，总而满足人数最少组的人数最大）。

当我们对第$i$个人进行分组时，具体操作如下：

 1. 在序列$q$中查找$q[j]=a[i]-1$（因为$q$时单调的，我们选择用二分查找来完成这一步）
 2. 若存在$q[j]=a[i]-1$，则选取最大的$j$，将第$i$个人插入第$j$组中，同时更新$sum$数组。
 3. 若不存在$q[j]=a[i]-1$，则在$q$的末尾加入新的元素$a[i]$，表示把第$i$个人分入一个新的组中，这个组中能力值的最大值为$a[i]$。由于我们按能力值从小到大进行分组，故此时可以保证$a[i]$是$q$中最大的元素，从而保证了$q$的单调性。

code:

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define qwq printf("qwq\n");

using namespace std;

int read() {
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

int n, cnt, ans, a[100005], q[100005], sum[100005];

bool mysort(int a,int b) {return a < b;}

int search(int k) {
	int l =1 , r = cnt, mid;
	while(l <= r) {
		mid = (l + r) >> 1;
		if(q[mid] == k) return mid;
		if(q[mid] < k) l = mid + 1;
		if(q[mid] > k) r = mid - 1; 
	}
	return 0;
}

int main() {
	n = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	sort(a + 1, a + n + 1, mysort);
	for(int i = 1; i <= n; i++) {
		int k = search(a[i] - 1);
		if(!k) {
			q[++cnt] = a[i];
			sum[cnt] = 1;
			continue;
		}
		while(q[k + 1] == q[k] && k < cnt) k++;
		q[k]++; sum[k]++;
		while(sum[k] < sum[k + 1] && k < cnt) {
			int stp = q[k];
			q[k] = q[k + 1];
			q[k + 1] = stp;
			stp = sum[k];
			sum[k] = sum[k + 1];
			sum[k + 1] = stp;
			k++;
		}
	}
	ans = INF;
	for(int i = 1; i <= cnt; i++) ans = min(ans, sum[i]);
	printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Apro1066 (赞：16)

**之前代码上传雾删了一些字符导致CE。。现在重新提交。**

首先要吐槽这道题。。二分了很久才过的，还看了题解，但题解没有人用的二分。

因为提到了“人数最少的组人数的最大值”，所以第一反应就是二分。如何二分呢？我一开始写了个60分的二分，但我感觉思路没有任何问题。

所以我看了题解，有大佬的思路很清晰，这里我把他的代码改进成二分答案。

首先要排序。因为排序不会影响到答案，换句话说这题答案和每个人的标号没有关系。而且我们要二分，得保证序列的单调性。

具体看一下代码。

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
#define inf 199999999
using namespace std;
int n,a[100001],b[100001],f[100001],s,l,r,mid;
//a[i]用来表示第i个队员的能力值，把每个组的人数放入f数组，b数组能表示某组最大的能力值[题解大佬的]
inline bool check(int x)
{
	register int i,j,position(0),point(0),minx;//position表示当前是第几个组 
	for(i=1;i<=n;i++)
	{
		point=0,minx=inf;
		for(j=1;j<=position;j++)//循环现在所有的组 
		{
			if(f[j]<minx && b[j]+1==a[i])//如果能力值递增，也就可以组队，这个就是排序的重要性；并且队伍长度要尽量短
			{
				point=j;//记录位置 
				minx=f[j];
			}
		}
		if(point==0)//如果没有找到 
		{
			f[++position]=1;//再建立一个小组
			b[position]=a[i];//记录能力值 
		}
		else//如果找到了 
		{
			b[point]=a[i];//记录能力值 
			f[point]++;//能分成几个队员
		}
	}
	for(i=1;i<=position;i++)//最后再扫一遍，position的意义就是能分成几个组，所以到position即可 
	{
		if(f[i]<x)//看一下哪个组人数最少 
		{
			return 0;
		}
	}
	return 1;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);//将每个人的能力值从小往大排序 
	l=1,r=n;
	while(l<=r)//二分答案 
	{
		int mid=(l+r)>>1;
		if(check(mid))
		{
			s=mid;
			l=mid+1;
		}
		else
		{
			r=mid-1;
		}
	}
	cout<<s<<endl;
	return 0;
}
```

这段代码其实就是那位大佬的二分答案版。所以在这里膜拜一下那位大佬！

---

## 作者：woshiluo (赞：11)

### 序

学长给的题，写完之后看题解貌似没有人和我的情况一样，就来写一波

### 思路

考虑每一个划分都可以由一个二元组来解释 $ (len, la) $

其中 

- $len$ 为长度
- $la$ 为最后一个数字

那么现在有一个数字 $a$，我们要接到任意一个划分后面

一个必要条件是 $ la + 1 = a $

那么筛选下来的每个二元组的差别就只有 $len$ 了，显然优先接到较短的后面即可

### 实现

先将 $a$ 数组排序

建立一个以 $(len,la)$ 节点， $len$ 为关键字 $len$ 越小越在上面的堆 $q$

然后从 $a_i$ 遍历到 $a_n$

每一次从堆 $q$ 中取出顶部节点，如果合法，放入 $tmp$ 队列

不合法，更新 $ans$ 后舍弃即可

遇到 $ a_i \neq a_i + 1 $ 的情况，将 $tmp$ 内容放入堆 $q$

最后将 $tmp$ 内容清空并更新 $ans$ 

### 代码


以下代码在 <https://www.luogu.com.cn/record/29511205> 中提交 并 AC
```cpp
#include <cstdio>

#include <queue>
#include <algorithm>

inline int Min( int a, int b ) { return a < b? a: b; }
int readin() {
	int res = 0; char x = getchar();
	while( x < '0' || x > '9' ) 
		x = getchar();
	while( x >= '0' && x <='9' ) {
		res = res * 10 + ( x - '0' );
		x = getchar();
	}
	return res;
}

const int N = 1e5 + 1e4;

struct node {
	int len, la;
	bool operator< ( const node &b ) const{
		return this -> len > b.len;
	}
};

int n, ans;
int a[N];
std::priority_queue<node> q;
std::queue<node> tmp;

int main() {
#ifdef woshiluo
	freopen( "luogu.4447.in", "r", stdin );
	freopen( "luogu.4447.out", "w", stdout );
#endif
	n = readin();
	ans = n;
	for( int i = 1; i <= n; i ++ ) {
		a[i] = readin();
	}

	std::sort( a + 1, a + n + 1 );

	for( int i = 1; i <= n; i ++ ) {
		if( a[i] != a[ i - 1 ] && i != 1 ) {
			while( tmp.empty() == false ) {
				q.push( tmp.front() );
				tmp.pop();
			}
		}
		bool flag = false;
		while( q.empty() == false ) {
			node top = q.top(); q.pop();
			if( top.la + 1 == a[i] ) {
				flag = true;
				tmp.push( (node) { top.len + 1, a[i] } );
				break;
			}
			else
				ans = Min( ans, top.len );

		}
		if( !flag ) 
			tmp.push( (node) { 1, a[i] } );
	}

	while( tmp.empty() == false ) {
		q.push( tmp.front() );
		tmp.pop();
	}

	while( q.empty() == false ) {
		node top = q.top(); q.pop();
		ans = Min( ans, top.len );
	}

	printf( "%d\n", ans );
}
```

---

## 作者：太叔寒云 (赞：10)

#### 恕我直言
#### 开数组找可行解的题解
#### 都能被我//太叔寒云//卡到O(n^2)。
#### 比如公差为2的等差数列什么的。
#### 想想就很崩好吧。
#### 所以我们不能每次从头找！
#### 还是先sort一遍，查询用小根堆维护维护就好了。
#### PS：本人自带大常数
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#define zxf(i,j,a,b) for(register int i=(a);(j)<=(b);i++)
#define wxr(i,j,a,b) for(register int i=(a);(j)>=(b);i--)
using namespace std;
const int N=1e5+5;
int a[N];
struct node
{
	int big,sum;
	friend bool operator < (const node &a,const node &b)
		{return a.big==b.big?a.sum>b.sum:a.big>b.big;}
};
priority_queue<node> q;
template<typename T>
inline void read(T &x)
{
    bool f=1;x=0;char c=getchar();
    while(!isdigit(c)) {if(c=='-') f=0;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    x=f?x:-x;
}
signed main()
{
	int n,ans=0x3f3f3f3f;
	read(n);
	zxf(i,i,1,n) read(a[i]);
	sort(a+1,a+n+1);
	zxf(i,i,1,n)
	{
		while(q.size()&&q.top().big<a[i]-1)
		{
			ans=min(ans,q.top().sum);
			q.pop();
		}
		if(q.empty()||q.top().big==a[i]) q.push(node{a[i],1});
		else
		{
			node x=q.top();q.pop();
			x.big=a[i];x.sum++;
			q.push(x);
		}
	}
	while(q.size())
	{
		ans=min(ans,q.top().sum);
		q.pop();
	}
	printf("%d",ans);
	return 0;
}
```

//潇帆姐姐美如画

---

## 作者：GldHkkowo (赞：5)

校内模拟赛的T1..

原本手写的队列暴力被出题人给叉掉5分

~~十分不爽地~~掏出了$STL$

做法很**简单**

考虑一个显然的贪心：每次往队列中加人都加在最少的那队，所得到的最小值一定是最大的

证明略~~因为显然~~

代码：
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <map>
#include <queue>
#include <vector>

const int INF = 0x3f3f3f3f; 

inline char fgc() {
    static char buf[1 << 15], *p1 = buf, *p2 = buf; 
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 15, stdin), p1 == p2) ? EOF : *p1++; 
}

inline int read() {
    static int x, ch; 
    x = 0, ch = fgc(); 
    while (ch < '0' || ch > '9') ch = fgc();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = fgc(); 
    return x; 
}

int main() {
    std::map<int, std::priority_queue<int, std::vector<int>, std::greater<int> > > team;
    std::map<int, std::priority_queue<int, std::vector<int>, std::greater<int> > >::iterator it;
    
    int n = read(); 
    std::vector<int> a(n);
    
    for (int i = 0; i < n; i++) {
        a[i] = read(); 
    }
    
    std::sort(a.begin(), a.end());
    for (int i = 0; i < n; i++) {
        int tmp = a[i], cur = 0;
        it = team.find(tmp-1);
        if (it != team.end()) {
            if (it->second.size()) {
                cur = it->second.top();
                it->second.pop();
            }
        }
        cur++;
        team[tmp].push(cur);
    }

    int ans = INF;
    for (it = team.begin(); it != team.end(); it++) {
        if (it->second.size()) {
            ans = std::min(ans, it->second.top());
        }
    }
    
    if (ans >= INF) ans = 0;

    printf("%d\n", ans);
    return 0; 
}
```

顺便无耻地宣传一下[自己的Blog](http://www.gldhkkowo.top/)

---

## 作者：xiaoniu142857 (赞：2)

## 蒟蒻的思路
这题是个贪心。于是手玩几个样例，看看能找到什么很有用的性质。我们先约定实力值为 $l\sim r$ 的小组记作 $G_{l,r}~(l\le r)$。

对于这组样例：
```text
7
1 2 2 3 3 4 5
```
我们以能力值为横轴画出柱状图。  

如果划分成 $G_{1,5}$ 和 $G_{2,3}$，人最少的组有 2 人。
![](https://cdn.luogu.com.cn/upload/image_hosting/k8r1wt7k.png)  
而分成 $G_{1,3}$ 和 $G_{2,3}$，的情况更优。因为这样分人最少的组有 3 人。
![](https://cdn.luogu.com.cn/upload/image_hosting/lwiitlud.png) 

于是我们可以知道，对于任意 $G_{i,j},G_{k,l}~(i\le k,j\ge l)$，重组为 $G_{i,k},G{j,l}$ 一定不会更劣。即最优解中小组两两不包含，$l$ 更小的组，$r$ 也一定更小。（证明很容易，可以自己画个图感受一下，我就不写了哈）

于是我们用队列维护每组的人数，依次处理图中“每一列”。可知队列中每一组的 $l$ 和 $r$ 都是单调不降的。
1. 若这一列比队列长度大，则入队（添加新小组）；
2. 若这一列比队列长度低，则出队（旧的小组结束）；

无论何种情况，最后全队列都要 $+1$，用懒标记 `shift` 维护即可。

由于最多有 $n$ 组，每个小组只进出队列一次，所以时间复杂度为 $O(n)$，而排序 $O(n \log n)$，是瓶颈。跑得飞快，卡卡常就到了 72ms，目前全谷最优解。
## 蒟蒻码
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define int unsigned int  // 卡常
#define N 100000
#define INF 0x7f7f7f7f
using namespace std;
char buf[1<<21],*p=buf;
int a[N],q[N],hd,tl,len,cur,cnt,shift,ans=INF;
inline void read(int &x){
    int c;
    while((c=*p++)<'0'||c>'9');
    for(x=c^48;(c=*p++)>='0'&&c<='9';x=(x<<3)+(x<<1)+(c^48));
}
inline void work(int x){  // x为下一列的位置
    if(x-cur>1){  // 中间某列高度为 0，即数字不连续
        if(!len){  // 队列空，即上一次刚刚全部出队，出现“孤列” 
            putchar('1'),exit(0);
        }
        while(len){  // 全部出队，更新ans
            ans=min(ans,q[hd++]+shift);
            --len;
        }
    }
    else{
        if(cnt>len)  // 情况一
            for(int j=len;j<cnt;++j)
                q[tl++]=1-shift;  // 入队的数实际为1
        else if(cnt<len)  // 情况二
            for(int j=cnt;j<len;++j)
                ans=min(ans,q[hd++]+shift);
        len=cnt,++shift;  // 整体加一
    }
}
signed main(){
    int n;
    fread(buf,1,1<<21,stdin);
    read(n);
    if(n==1){
        putchar('1');
        return 0;
    }
    for(int i=0;i<n;++i) read(a[i]); 
	sort(a,a+n),cur=a[0],cnt=1;
	for(int i=1;i<n;++i)  // 统计每个数字出现次数，即每列高度
        if(a[i]==cur) ++cnt;
        else work(a[i]),cur=a[i],cnt=1;
    work(INF);  // 最后一列
    printf("%d",ans);
	return 0;
}
```
写作不易，求管理大大给个通过呗！  

Update 2025.2.11：修正时间复杂度分析。

---

## 作者：Marco_L_T (赞：2)

对于n<=6: 
可以暴力枚举判断分组情况，
时间复杂度O(n^n),期望得分20pts；

对于另外40%满足Ai两两不同的测试点，
排序后直接按照条件贪心选择直到无法选择即可，
时间复杂度O(nlogn),暴力实现是O(n^2)，
期望得分50pts，
结合n<=6的暴力分可以获得70pts.

满分算法：
考虑贪心，将所有人的实力值放进一个桶里，
每次考虑将剩下的人中实力值最小的那个人所在的组提取出来，
假设这个人的实力值是p，把这个人放入当前组，
按照p+1,p+2，p+3.....依次遍历实力值，
假设当前遍历到的实力值是x，
当剩余的实力值为x的人数小于实力值为x-1的人数，则让这一组最大元素为x-1，停止这一轮操作；
否则，每次将当前实力值的人取一个出来放进当前组，
这样不断取出元素直到所有元素都被分组，此时人数最少的组就是最优解.
做法正确性证明：
剩余的实力值为x的人数小于实力值为x-1的人数，
等价于一定有一个组中实力值最大的人的实力值为x-1，也就是以x-1结尾；
否则剩余的实力值为x的人数一定大于等于实力值为x-1的人数；
然后每次取出来的新的小组的最小值单调不下降，组的大小为|Max-Min+1|,
于是显然贪心地让当前组在x-1位置结尾是最优的.

对于|Ai|<=10^9无法直接存到一个桶里的情况，
将实力值排序后离散化，对于不连续的实力值中间加上一个空点，
可以发现这样对答案不会产生影响，这样值域就被压缩到了O(n)的范围，
时间复杂度O(nlogn),空间复杂度O(n),期望得分100pts.


同时这题还有一种时空复杂度与上一个算法相当的另一种贪心算法，
思维难度相对小但是用到了STL里的priority_queue和map.
从小到大加入每一个元素，
每次贪心地找到上一个元素是X-1的组并加入这个元素，
如果有多个，加入元素数量最小的那个组；
如果没有，则创建一个新组，组内元素只有X.
具体实现，可以用map套priority_queue实现，
map维护的组内的上一个元素，pq维护的是满足条件的所有组的大小.
离散化后开O(n)个priority_queue也是可行做法.

然后附上原题地址：https://www.hackerrank.com/challenges/team-formation/problem

---

## 作者：Create_Random (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4447)

提供一种尺取+树状数组的解法：

先对所有人的能力进行排序，

然后将能力值相同的放入同一个桶中，

这里的桶只需要按照顺序存放人数，而不需要管下标。

存入桶的时候，我们需要记录是否两个数是连续的，

如不连续就记录断点，使其分成若干个块。

这里用一张 @[ScanfN](https://www.luogu.com.cn/user/118228)题解中的图（侵删）

![](https://cdn.luogu.com.cn/upload/image_hosting/vd33dlmw.png)

随后就用与第一篇题解类似的思路进行操作：

对于每一个数字数量单调非降区间进行记录，

因为最后数量不断减少，一定会使得下一个区间的值变成大于等于当前状态下下一个区间的值。

所以我们可以用类似尺取的方法，

对与每一个块，

找到每一个单调非降区间，更新答案为所有区间长度的最小值，

同时树状数组区间修改使当前区间值均减 $1$.

左端点在当前数字值已为 $0$ 时右移，

右端点在当前数字值小于等于下一个数字的值时右移，

特别的，如果一个块整体即为单调非降时需要特判右端点位置。

（否则不会更新，会一直为 $0$ )

时间复杂度 $O(n \log n)$.

$Code$:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[100010];
int cnt;
struct node
{
	int num,v;
}tong[100010];
int d[100010];
int l=1,r;
int ans=1e9;
int len[100010],tot;
int lowbit(int x)
{
	return x&-x;
}
void update(int x,int v)
{
	while(x<=cnt)
	{
		d[x]+=v;
		x+=lowbit(x);
	}
}
int query(int x)
{
	int res=0;
	while(x)
	{
		res+=d[x];
		x-=lowbit(x);
	}
	return res;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		if(a[i-1]==a[i])
		{
			tong[cnt].v++;
		}
		else
		{
			tong[++cnt].num=a[i];
			tong[cnt].v++;
		}
	}
	for(int i=2;i<=cnt+1;i++)
	{
		if(tong[i].num!=tong[i-1].num+1)
		{
			len[++tot]=i-1;
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		update(i,tong[i].v);
		update(i+1,-tong[i].v);
	}
	for(int i=1;i<=tot;i++)
	{
		l=len[i-1]+1;
		r=len[i];
		for(int j=l+1;j<=len[i];j++)
		{
			if(tong[j].v<tong[j-1].v)
			{
				r=j-1;
				break;
			}
		}
		while(l<=r&&l<=len[i])
		{
			ans=min(ans,r-l+1);
			update(l,-1);
			update(r+1,1);
			while(!query(l))
			{
				l++;
			}
			if(r==len[i])
			{
				continue;
			}
			while(query(r)<=query(r+1))
			{
				if(r==len[i])
				{
					break;
				}
				r++;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```



---


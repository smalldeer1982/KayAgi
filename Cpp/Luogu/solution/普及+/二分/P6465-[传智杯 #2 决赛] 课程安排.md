# [传智杯 #2 决赛] 课程安排

## 题目描述

传智播客的课表上按顺序提供 $n$ 节课程，课程可能是 Java、Python 或者前端开发等等，我们用不超过 $n$ 的正数代表每一节课程的种类。学员可以从这个课程序列选取连续的一小段的课程序列，作为一周的学习任务。

为了使学习任务不那么枯燥，学员不想连续上两节相同的课。特殊的，这一周学习任务的开头和结尾也不能是相同的课。为了保证学习效果，一周内至少要学完 $l$ 节课程。

请问，我们有多少种合法的选课方案？

两种选课方案，只要选取的课程序列在原序列的开头和结尾有至少一个位置不一致，那么就可以认为是不同的选课方案。注意，即使 $l$ 是 1，一周只安排一次课也是不合法的，至少需要安排 2 次课。

## 说明/提示

**样例解释**

对于第一组数据，有 [1,2] 和 [2,3] 和 [1,2,3] 三种方法。

对于第二组数据，由于至少要选 3 门课，只有 [1,2,3] 和 [2,3,1] 两种方法。

**数据范围**

测试数据不超过 5 组，$1\le N \le 5 \times 10^5$，$1\le l,c_i \le N$

## 样例 #1

### 输入

```
2
3 1
1 2 3
5 3
1 2 3 1 1```

### 输出

```
3
2```

# 题解

## 作者：Night_sea_64 (赞：12)

以下的 $l$ 为左端点。题目中的 $l$ 用 $m$ 表示。

双指针。枚举左端点 $l$，双指针找出最后一个 $r$ 满足 $[l,r]$ 中没有连续两个相同的课的位置。这个过程中再维护每个种类的个数 $cnt$（只计算 $[l+m-1,r]$ 中的，如果 $l+m-1>r$ 就不计算）。最终左端点为 $l$ 的方案数即为 $\max(0,r-(l+m-1)-cnt(c_{l+m-1}))$。

代码挺短的，跑的也挺快，为 $O(n)$。

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
int t,n,m,a[500010],cnt[500010];
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        long long ans=0;
        for(int i=1;i<=n;i++)scanf("%d",&a[i]);
        int r=0;
        for(int l=1;l<=n;l++)
        {
            while((r<l||a[r]!=a[r+1])&&r<n)
                if(++r>=l+m-1)cnt[a[r]]++;
            ans+=max(0,r-(l+m-1)+1-cnt[a[l]]);
            if(r>=l+m-1)cnt[a[l+m-1]]--;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：Bulyly (赞：10)

这是一篇清真的 ```two-pointer``` 题解。好想也好写，并且不需要用到其他的奇奇怪怪的东西。


------------
先不考虑 $l$ 的限制。我们需要做的是求出相邻两两不相等，且头尾也不相等的序列。考虑继续弱化限制，先不考虑头尾不等。我们从左开始枚举左端点 $L$，发现每个 $L$ 对应的最大的 $R$ 是单调不减的。我们可以通过双指针求出对于每个 $L$ 的最大 $R$。$[L,R]$ 都可作为合法的右端点。都是接着考虑头尾相等的区间。我们开一个桶来实时维护 $[L,R]$ 区间中各课程出现的次数。显然有 $Ans=R-L+1-(cnt_{a_L}-1)$。加 $1$ 是因为不包括 $L$ 本身。

接着考虑限制 $l$。实际是限制了序列长度在 $[l,n]$ 之间。利用前缀和思想用 $[1,n]$ 的贡献减去 $[1,l-1]$ 的贡献即可。

具体实现可以看看代码帮助理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=5e5+10;
int T,n,l,r,a[N],cnt[N];
void solve() {
	scanf("%d%d",&n,&l);ll res1=0,res2=0;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),cnt[i]=0;
	r=0;
	for(int i=1;i<=n;i++) {
	    if(i>r) r++,cnt[a[r]]++;
		while(r<n&&a[r]!=a[r+1]) ++r,++cnt[a[r]];
		--cnt[a[i]];
		res1+=r-i+1-cnt[a[i]];
	} 
	r=0;
	for(int i=1;i<=n;i++) {
		if(i>r) ++r,cnt[a[r]]++;
		while(r<n&&a[r]!=a[r+1]&&r+1-i+1<l) ++r,++cnt[a[r]];
		--cnt[a[i]];
		res2+=r-i+1-cnt[a[i]];
	} 
	printf("%lld\n",res1-res2); 
}
int main() {
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```


---

## 作者：HKHbest (赞：10)

目前开氧气174ms是最快的

~~本来只是想找一个没有题解的绿题水一篇题解。结果在这个题上浪费了快一个小时思考时间~~

首先 $n=3 \times10^5$，考虑 $n$ 或 $n\log(n)$ 作法，首先可以想到对于存在连续相等的序列进行分割，对于两个子串分别进行处理，累计答案。
![](https://cdn.luogu.com.cn/upload/image_hosting/123lapw6.png)
现在我们要处理的序列已经不存在有连续相等的数的情况了。  
如何统计答案？  
先不考虑区间长度的限制，显然如果可以 $n^2$ 求解的话，可以轻松得到如下子序列统计答案代码。
```
for(int i=1;i<=tot;i++)//tot为分割出的子序列总数，l[i],r[i]表示该区间左右端点
{
	for(int j=l[i];j<=r[i];j++)
	{
		for(int k=j+1;k<=r[i];j++)
		{
			if(a[j]!=a[k])
			{
				ans++;
			}
		}
	}
}
```
我们发现，如果对于子序列中的每一个数，在它左边的数只要不与它相等就会对答案产生贡献（不考虑区间长度限制）。所以我们可以用在它之前可以与它组成区间的数的数量，减去在它之前与它相等的数的数量，就是答案。枚举j时顺带统计相等的数的数量即可。

接下来我们考虑长度限制。我们只要知道每一个子区间的一个数左边有多少相同的数 $num$ ，和这个数左边 $l-1$ 长度内有多少与这个数相同的数 $ck$ ，以及左边能与这个数组成区间的位置的数量 $all$，那么这个数与其子序列内左边的数对答案的贡献就是 $all-(num-ck)$。

$all$ 和 $num$ 都可以 $O(n)$ 求出。$ck$ 可以通过类似莫队的思想求出。
![](https://cdn.luogu.com.cn/upload/image_hosting/mfqbpsql.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/yp4nmfwa.png)

（图中 $l=3$）

我们发现，如果用一个桶记录窗口中的数的各自数量，就可以右移窗口时 $O(1)$ 递推出 $ck$。

那么我们得到了全部代码。注意递推时，窗口大小应该为 $l-2$ 来避免错误统计。另外，当子区间长度小于 $l$ 时一定没有答案，跳过即可。

应该是 $O(n)$ 的。

```
//ck意为“窗口”
#include<bits/stdc++.h>
using namespace std;
const int N=600000;
int n,len,a[N],l[N],r[N],tot,num[N],ck[N];
long long ans;
inline int read()
{
	int s=0,w=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
signed main()
{
	int T=read();
	while(T--)
	{
		n=read();
		len=read();
		if(len==1)	len=2;
		for(int i=1;i<=n;i++)
		{
			a[i]=read();
		}
		int left=1,ckleft=1;
		for(int i=1;i<=n;i++)
		{
			if(a[i]==a[i+1])
			{
				l[++tot]=left;
				r[tot]=i;
				left=i+1;
			}
		}
		l[++tot]=left;
		r[tot]=n;
		for(int i=1;i<=tot;i++)
		{
			if(r[i]-l[i]+1<len)
			{
				continue;
			}
			ckleft=l[i];
			for(int le=l[i];le<l[i]+len-2;le++)
			{
				ck[a[le]]++;
				num[a[le]]++;
			}
			for(int le=l[i]+len-2;le<=r[i];le++)
			{
				ans+=le-len-l[i]+2-num[a[le]]+ck[a[le]];
				num[a[le]]++;
				ck[a[le]]++;
				ck[a[ckleft]]--;
				ckleft++;
			}
			for(;ckleft<=r[i];ckleft++)
			{
				ck[a[ckleft]]--;
			}
			for(int j=l[i];j<=r[i];j++)
				num[a[j]]--;
			l[i]=r[i]=0;
		}
		printf("%lld\n",ans);
		ans=0;
		tot=0;
	}
	return 0;
}
```


---

## 作者：2018ljw (赞：6)

题意：给定长为 $n$ 的序列，求长度不小于 $len$ 且任意相邻两数不相同的子区间个数。区间开头结尾也不能相同。

考虑枚举左端点 $l$，统计区间个数。先不考虑首尾不同的限制，关注到两个相邻的数相同是一定不能被包含进来的，所以右端点的范围可以确定。

右端点的范围确定后，考虑扣掉首尾相同的区间。即减去区间中等于 $a_l$ 数的个数。这个可以主席树单 $\log$ 处理，但我们需要更好的做法。

开 $n$ 个桶，每个桶存储对应颜色所有的出现位置。不难发现我们可以二分桶单次处理。考虑从右往左枚举左端点 $l$，$l$ 左移的时候我们二分到的位置一定是单调的，所以可以用双指针代替 $O(n)$ 解决。

至于长度不小于 $len$ 的限制，我们可以转化为没有限制减去长度小于 $len$ 的，后者的统计同样可以双指针处理。

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
vector<int>g[500001];
int n,l,pr[500001],pl[500001],a[500001];
//pl 是 <len 的指针，pr 是 >=len 的指针
int main(){
	int i,t;
	scanf("%d",&t);
	while(t--){
		for(i=1;i<=n;i++)pl[i]=pr[i]=0,g[i].clear();
		scanf("%d%d",&n,&l);
		for(i=1;i<=n;i++)scanf("%d",&a[i]);
		long long ans=0;
		int las=n+1;
		//las 维护上一个相同对靠后元素的下标
		for(i=n;i;i--){
			g[a[i]].push_back(i);
			while(g[a[i]][pr[a[i]]]>=las)pr[a[i]]++;
			if(pl[a[i]]<pr[a[i]])pl[a[i]]=pr[a[i]];
			while(pl[a[i]]<g[a[i]].size()&&g[a[i]][pl[a[i]]]-i+1>=l)pl[a[i]]++;
			if(las-i>=l)ans+=las-i-l+1+pr[a[i]]-pl[a[i]];
			//las-i-l+1 是可能的下标个数。
			//桶的下标从大到小，pl-pr 即范围内不合法的下标个数。
			if(a[i]==a[i-1])las=i;
		}
		printf("%lld\n",ans);
	}
}
```

---

## 作者：__3E24AC7002AD9292__ (赞：3)

一眼题，很典的尺取法。

先不考虑 $l$。可以从左往右遍历课表，每次判断以遍历到的位置为结尾去累计方案。

可以发现如果搜到了 $i$，而且第 $i-1$ 节和第 $i$ 节相同，则如果选择的区间同时包含 $i-1$ 和 $i$，则根据题意显然是错误的。所以可以将这种情况断开统计答案。

然后在遍历结尾时考虑开头，根据题意，开头和结尾课程不相同，所以可以维护一个桶统计区间每节课的数量，并在计算答案时用区间总课程数量减去与结尾课程相同的课程数量。

接着考虑 $l$，显然可以考虑按照上述方法统计长度 $\leq l$ 的区间总数，并用前面的答案减去这个总数。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t,n,len,l,r,a[500005],mp[500005],sum;
signed main(){
    cin>>t;
	while (t--){
		cin>>n>>len;
		len--;
		for (int i=1;i<=n;i++){
		    mp[i]=0;
		    cin>>a[i];
		}
		l=1,r=1,sum=0;
		if (len>n){
			cout<<"0\n";
			continue;
		}
		for (;r<=n;r++){
			mp[a[r]]++;
			if (a[r]==a[r-1]){
				for (int i=l;i<=r-1;i++) mp[a[i]]--;
				l=r;
			}
			sum+=r-l+1-mp[a[r]];
		}
		if (len==0){
			cout<<sum<<'\n';
			continue;
		}
		for (int i=1;i<=n;i++) mp[i]=0;
		l=1,r=1;
		for (;r<=n;r++){
			mp[a[r]]++;
			if (a[r]==a[r-1]){
				for (int i=l;i<=r-1;i++) mp[a[i]]--;
				l=r;
			}
			if (r-l+1>len){
				for (int i=l;i<=r-len;i++) mp[a[i]]--;
				l=r-len+1;
			}
			sum-=r-l+1-mp[a[r]];
		}
		cout<<sum<<'\n';
	}
	return 0;
}
```


---

## 作者：OldDriverTree (赞：1)

# Solution
考虑先找出序列中所有极大的相邻两数不同的区间，在区间内做。

这样就把问题转化成求出序列内左端点和右端点不同，且区间长度大于等于 $l$ 的区间个数了。

考虑枚举右端点，用以这个点为右端点的区间长度大于等于 $l$ 的区间个数减去左端点和右端点相同且区间长度大于等于 $l$ 的个数。

前者显然可以 $O(1)$ 求出，考虑怎么求出后者。

考虑开一个桶记录每种数在序列中的所有位置，在桶上二分，单次 $O(\log n)$。

还有一种更优的方法：用桶记录每个数在序列中的出现次数，每次把 $i-l+1$ 加入桶中，再直接计算答案即可。

总时间复杂度 $O(Tn)$。

加个 `fread` 快读竟然直接卡进了最优解/jk。

# Code
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+1;
int T,n,m,a[N],cnt[N];

int read() {
	int x=0; char c=0; while (!isdigit(c) ) c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return x;
}
int main()
{
	T=read();
	while (T--)
	{
		long long sum=0;
		n=read(),m=max(read(),2);
		for (int i=1;i<=n;i++) a[i]=read();
		for (int l=1,r=1;l<=n;l=r=r+1)
		{
			while (r<n&&a[r]^a[r+1]) r++;
			for (int i=l;i<=r;i++) if (i-l+1>=m)
			cnt[a[i-m+1] ]++,sum+=i-l+2-m-cnt[a[i] ];
			for (int i=l;i<=r;i++) cnt[a[i] ]=0;
		}
		printf("%lld\n",sum);
	}
	return 0;
}
```

---

## 作者：fdszlzl (赞：1)

[P6465 [传智杯 #2 决赛] 课程安排](https://www.luogu.com.cn/problem/P6465)

设「$f_{i}$」为以「$a_{i}$」为结尾贡献的子串个数。


依题意，不能包含相邻的重复元素。因此「$f_{i}$」合法的取值范围不能越过最后一组重复元素的位置。设 $p$ 为最后一组重复元素的位置，$p$ 即为合法区间的左端。

依题意，区间长度必须 $\geq l$，因此合法区间的右端是 $i-l+1$。

假定 $l=2$，我们正在处理最后一个元素，合法区间如下：
 
 $\verb!1 2 2 1 3「 3 1 2 1 3 」1!$
 
 依题意，头尾不能相同。现在我们只要取得合法区间内「$a_{i}$」的数量与区间长度相减即可。
 
 考虑开 $n$ 个队列。
 
 当进行到 $i$ 时，我们将 $i-l+1$ 位置放入队列，这样能保证满足 $l$。
 
根据 $p$，清除「$a_{i}$」号队列头部位置 $<p$ 的元素。

这样「$a_{i}$」号队列中元素的个数即合法区间内「$a_{i}$」的个数。

每个元素进出队列一次，总时间复杂度 $O(n)$。



```cpp
ll ans=0,p=1;
for(int i=1;i<=n;i++)
{
	if(a[i]==a[i-1]) p=i;
	if(i>=l) q[a[i-l+1]].push(i-l+1);
	while(!q[a[i]].empty()&&q[a[i]].front()<p) q[a[i]].pop();
	ll t=i-l+1-p+1-q[a[i]].size();
	if(t>0) ans+=t;
}
```

然而可耻的「MLE」了。

换链表重写：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=5e5+10;
typedef long long ll;
int n,l,a[N],t[N],h[N],nxt[N],size[N];

int main()
{
	int T;
	cin>>T;
	while(T--)
	{ 
		scanf("%d%d",&n,&l);
		for(int i=1;i<=n;i++) h[i]=t[i]=size[i]=nxt[i]=0;
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		if(l==1) l++;
		ll ans=0,p=1;
		for(int i=1;i<=n;i++)
		{
			if(a[i]==a[i-1]) p=i;
			if(i>=l) 
			{
              //加入链表尾端
				int tmp=i-l+1;
				nxt[t[a[tmp]]]=tmp,t[a[tmp]]=tmp,size[a[tmp]]++;
				if(size[a[tmp]]==1) h[a[tmp]]=tmp;
			}
          //清除链表头部  
			while(h[a[i]]&&h[a[i]]<p) h[a[i]]=nxt[h[a[i]]],size[a[i]]--;
			ll tmp=i-l+1-p+1-size[a[i]];
			if(tmp>0) ans+=tmp;
		}
		cout<<ans<<endl;		
	}
	return 0; 
} 
```

 
 





---


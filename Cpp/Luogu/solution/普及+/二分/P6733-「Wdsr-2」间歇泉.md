# 「Wdsr-2」间歇泉

## 题目背景

**Problem Number:** $\textit{08}$

## 题目描述

有一个间歇泉，冒出了 $n$ 杯水，由于一些原因，每杯水的温度、体积不同。第 $i$ 杯水的温度为 $c_i$，体积为 $a_i$。

现在混合任意**两**杯水，每混合两杯水都会得到一个新的温度值，求可能得到的第 $k$ 高的温度值（不计热量损失）。

**你的答案建议至少保留小数点后 $\bm3$ 位（与标准答案之差在 $\bm{10^{-2}}$ 以内即视为通过）。**

## 说明/提示

#### 样例 1 说明

第 $1$ 和第 $5$ 杯水混合，得到 $4.5$ 的温度值。可以发现，这是可能得到的最高水温。

#### 样例 2

见题目附件中 $\textbf{\textit{pour2.in/pour2.ans}}$。

#### 数据规模与约定

**本题采用捆绑测试。**

- $\textbf{Subtask 1}\text{ (10 pts)}$：$1\le n\le 10$。
- $\textbf{Subtask 2}\text{ (40 pts)}$：保证 $k=1$。
- $\textbf{Subtask 3}\text{ (50 pts)}$：无特殊限制。
- $\textbf{Subtask 4}\text{ (0 pts)}$：Hack 数据。

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le \dfrac{n \times (n - 1)}{2}$，$1\le a_i,c_i\le 10^9$。

子任务 2/3/4 时限 $\text{2 s}$，子任务 1 时限 $\text{1 s}$。

#### 前置知识

对于两杯体积、温度分别为 $(a_i,c_i),(a_j,c_j)$ 的水，混合后温度为：

$$
T=\dfrac{a_ic_i+a_jc_j}{a_i+a_j}
$$

#### 说明

本题数据采用 [SvRan](https://github.com/Sept0913/SvRan) 生成，仅用时 $3\min$。

## 样例 #1

### 输入

```
5 1
1 5
4 2
5 3
2 3
1 4```

### 输出

```
4.500```

# 题解

## 作者：CSP_Sept (赞：26)

### 子任务 1

- 暴力，挨个算出每两杯水混合后的温度，`sort` 一遍求 $k$ 大。
- 期望得分：$10$ 分。

### 子任务 2

- 贪心
- 期望得分：$40$ 分。

结论是：混合后温度最高的一杯水，混合前的两杯中必定有原先温度最高的一杯。

[证明](https://www.luogu.com.cn/paste/zforwgqc)

贪心参考代码（By [`chenxinyang2006`](/user/49776)）：

```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
int n,k;
int cnt;
struct node{
	ll a,c;
}Q[1000005],now[1000005];

bool cmp(node a,node b){
	if(a.c == b.c) return a.a < b.a;
	return a.c > b.c;
}

int main(){
	scanf("%d%d",&n,&k);
	for(int i = 1;i <= n;i++){
		scanf("%lld%lld",&Q[i].a,&Q[i].c);
	}
	std::sort(Q + 1,Q + n + 1,cmp);
	double mx = 0,tmp;
	for(int i = 2;i <= n;i++){
	    tmp = (Q[1].a * Q[1].c + Q[i].a * Q[i].c) * 1.0 / (Q[1].a + Q[i].a);
		if(mx < tmp) mx = tmp;
	}
	printf("%.3f\n",mx);
	return 0;
}
```
___
综合以上算法，可以获得 $50$ 分。

### 子任务 3

- 正解
- 期望得分：$100$ 分

#### 思路

注意到是求 $k$ 大，那么求 $k$ 大实际上只有两种方式：
  
1. 通过求 $1$ 大，$2$ 大，$3$ 大 …… 直到求出 $k$ 大。
2. 二分答案，然后数个数。
  
注意到 $k$ 是 $10^{10}$ 级别的，所以肯定选第二种了。
  
设当前二分的值为 $v$，那么我们要求的是数对 $(i,j)$，满足 $1 \le i < j \le n,\dfrac{a_i \times c_i + a_j \times c_j}{a_i +a_j} \ge v$ 的数量
  
显然，$a_i+a_j>0$，所以变形得到 
  
$$a_i \times c_i + a_j \times c_j \ge v \times a_i + v \times a_j$$
  
将含 $i,j$ 的项分别放到左边，右边，得到：
  
$$a_i \times c_i - v\times a_i \ge v \times a_j - a_j \times c_j$$
  
发现两边的值都是确定的，我们分别算出。
  
然后就是这样一个问题了：
  
给出两个长度为 $n$ 的序列 $\{a_n\},\{b_n\}$，你需要求出有多少对 $(i,j)$，满足 $a_i \ge b_j$。
  
这是一个经典问题，比较简单的一个做法是将两个序列分别排序，然后使用双指针法 $O(n)$ 数出对数。
  
时间复杂度：$O(n\log v\log n)$。

#### 参考代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std; 
#define ll long long
#define eps 1e-3
int n;
ll k;
int a[100005],c[100005];//a 毫升,c 温度 
double p[100005],q[100005];

bool cmp(double a,double b){
	return a < b;
} 

int check(double v){
    ll tot = 0;
	for(int i = 1;i <= n;i++){
		double x = a[i] * 1.0 * c[i],y = v * a[i]; 
		p[i] = x - y;
		q[i] = y - x; 
		if(q[i] - p[i] < eps) tot--;
	}
	sort(p + 1, p + n + 1, cmp);
	sort(q + 1, q + n + 1, cmp);
	int j = 0;
	for(int i = 1;i <= n;i++){
		while((q[j + 1] - p[i]) < eps && j + 1 <= n) j++;
		tot += j;
	}
	return (tot / 2 < k);
}

int main(){
	scanf("%d%lld", &n, &k);
	for(int i = 1;i <= n;i++){
		scanf("%d%d",&a[i],&c[i]);
	}
	double l = 1,r = 1000000000,mid;
	while((r - l) > eps){
		mid = (l + r) / 2;
		if(check(mid)){
			r = mid;
		}
        else{
			l = mid;
		}
	}
	printf("%.3f\n", l);
	return 0;
}
```

---

## 作者：卷王 (赞：4)

## 题目大意

[传送门](https://www.luogu.com.cn/problem/P6733)

## 大体思路

暴力是别想过了。

我们发现 $k$ 可以达到 $10^{10}$ 的数量级，我用计算器稍微算了一下，得到 $k$ 最大能达到 $4999950000$，近似于 $5$ 亿，那么我们至少要一个 $O(n \log k)$ 的算法，于是想到了 **二分答案**。

由于是精度问题，所以定义 $eps$ 为 $0.0001$（当然 $0.00001$ 也是可以的）。

我们再定义一个 $check$ 表示 **任意两杯水混合起来的温度** 不小于 $mid$（二分的值）的数量是否小于 $k$。于是二分代码如下：

```cpp
double l = 1, r = 1e9, mid;
	while(r - l > eps) {
		mid = (l + r) / 2;
		if(check(mid)) r = mid;
		else l = mid;
	}
```
特别注意：$r$ 一定要初始化成 $10^9$！！不然就会 WA！

然后，我们思考思考 $check$ 函数内部怎么写。我们可以转化一下公式，得 $a_j × v-c_j×v \leq a_i × v-c_i×v$，于是我们可以分别预处理出等式左边和右边的式子，用 $l$ 数组和 $r$ 数组记录吧。

最后，使用双指针求出个数即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define eps 1e-4
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}
int n; long long k;
int a[100007], c[100007];
double l[100007], r[100007];
inline bool check(double v) { //任意两杯水混合起来的温度 >= v 的数量是否小于 k 
	ll cnt = 0;
	for(int i = 1; i <= n; i++) {
		double x = a[i] * 1.0 * c[i], y = v * a[i]; //计算值 
		l[i] = x - y, r[i] = y - x;
		//x - y 是不等式左边的值，y - x 是不等式右边的值 
		//如果 r[i] == l[i] 表示 不等式左边 == 不等式右边 
		//温度相同也就是排名是并列的，因为不能重复算，所以 cnt-- 
		if(r[i] - l[i] < eps) cnt--;	
	}
	//排序，因为后面要比较 
	sort(l + 1, l + n + 1);
	sort(r + 1, r + n + 1);
	int tail = 0;
	for(int head = 1; head <= n; head++) {
		while(r[tail + 1] - l[head] < eps && tail + 1 <= n) tail++;
		cnt += tail;
	}
	return cnt / 2 < k;
}
int main() {
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
		a[i] = read(), c[i] = read();
	double l = 1, r = 1e9, mid;
	while(r - l > eps) {
		mid = (l + r) / 2;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%.3lf", l);
	return 0;
}
```

---

## 作者：FQR_ (赞：4)

## 思路

先看 $k$ 的取值范围，非常大，不难想到二分。直接对答案进行二分，对于每个 $mid$ 值，在 $\operatorname{check}$ 函数中把 $k$ 与比 $mid$ 大的水温个数比较即可。

那么重点是如何求比 $x$ 大的水温个数，即 $\dfrac{a_ic_i+a_jc_j}{a_i+a_j} \ge x$，且 $1\le i < j \le n$ 的 $(i,j)$ 的个数。

由 $\dfrac{a_ic_i+a_jc_j}{a_i+a_j} \ge x$，可得 $a_ic_i+a_jc_j \ge a_ix+a_jx$，进一步可得 $a_ic_i-a_ix\ge a_jx-a_jc_j$，即 $a_i(c_i-x) \ge a_j(x-c_j)$。

显然，当 $i=j$ 时，不等式两边互为相反数。所以，可以算出所有 $a_i(c_i-x)$ 的值，从小到大排序。此时，$a_i(c_i-x)$ 递增，$a_j(x-c_j)$ 递减。使用双指针，一个从左往右扫，扫 $a_i(c_i-x)$；另一个从右往左扫，扫 $a_j(x-c_j)$ 的值。这样，我们就可以用 $O(n)$ 的时间复杂度得出 $\dfrac{a_ic_i+a_jc_j}{a_i+a_j} \ge x$ 的 $(i,j)$ 的个数。

但是，自己与自己不能混和。所以，我们要求出 $a_i(c_i-x) \ge a_i(x-c_i)$的 $i$ 的个数 ，即 $a_i(c_i-x) \ge 0$ 的 $i$ 的个数。我们需要从刚才得出的答案中减去这个个数。

此时，$(i,j)$ 算了一遍，$(j,i)$ 同时也算了一遍。所以，我们再将这个答案除以 $2$，得到最终比 $x$ 大的水温个数。


## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-3;
int n,k;
double a[100010],c[100010];
bool pd(double x)
{
	int cnt=0;
	vector<double> xx;
	xx.push_back(0);//先存一个0，使下标从1开始
	for(int i=1;i<=n;i++)
	{
		double aaa=1.0*a[i]*(c[i]-x);
		xx.push_back(aaa);//插入xx
		if(aaa>=0) cnt--;//减去i=j时符合的数量
	}
	sort(xx.begin()+1,xx.end());//排序
	
	//双指针扫描，i扫xx[i]，p扫-xx[p]
	//i从左往右，p从右往左
	int p=n;
	for(int i=1;i<=n;i++)
	{
		while(xx[i]>=-xx[p]&&p>=1) p--;
		cnt+=(n-p);//加上此时符合的个数
	}
	return cnt>=k*2;//cnt应除以2，要返回cnt/2>=k，即cnt>=k*2
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	
	for(int i=1;i<=n;i++) cin>>a[i]>>c[i];
	
	double l=1,r=1000000000,ans=0;
	while(fabs(l-r)>eps)//二分
	{
		double mid=(l+r)/2;
		if(pd(mid)) l=mid;
		else r=mid;
	}
	
	
	printf("%.3lf",l);
	
	return 0; 
}
```

---

## 作者：concert_B (赞：3)

# [P6733 「Wdsr-2」间歇泉](https://www.luogu.com.cn/problem/P6733) 题解

## 算法分析

由于 $k$ 达到了 $10^{10}$ 的级别，所以正常暴力做法肯定不行，于是考虑二分。

二分 $mid$。

注意：实数二分要考虑精度。

## check 函数公式推导

当

$$\sum_{i=1}^{n}\sum_{j=1}^{n} [mid \le \frac{a_ic_i+a_jc_j}{a_i+a_j}] \ge k$$

时返回 true，反之返回 false。

展开，得

$$\sum_{i=1}^{n}\sum_{j=1}^{n} [a_imid+a_jmid \le a_ic_i+a_jc_j] \ge k$$

移项，得

$$\sum_{i=1}^{n}\sum_{j=1}^{n} [a_ic_i+a_imid \le a_jc_j+a_jmid] \ge k$$

此时，$a_ic_i+a_imid$ 与 $a_jc_j+a_jmid$ 都可以以 $O(n)$ 的代价预处理出来。

排序后用双指针求出 
$\sum_{i=1}^{n}\sum_{j=1}^{n} [a_imid+a_jmid \le a_ic_i+a_jc_j]$ 的量。

此时，$(i,j)$ 与 $(j,i)$ 都算了一遍。所以，我们再将这个答案除以 $2$。

注意：自己与自己不能混和，当 $[a_imid+a_jmid = a_ic_i+a_jc_j]$ 时答案减一。

## 复杂度

编程语言：C++98 O2；

代码长度：752B；

用时：1.04s；

内存：3.36MB。

理论复杂度 $O(n \log^2 n)$。

## CODE
```cpp
#include<bits/stdc++.h>
#define int long long
const int N=1e5+5;
const double eps=1e-4;
int n,k;
double a[N],c[N]; 
double x[N],y[N]; 
bool check(double mid){
	int res=0;
	for(int i=1;i<=n;i++){
		x[i]=a[i]*c[i]-a[i]*mid;
		y[i]=a[i]*mid-a[i]*c[i];
		if(y[i]-x[i]<eps)	res--;
	}
	std::sort(x+1,x+n+1);
	std::sort(y+1,y+n+1);
	int j=0;
	for(int i=1;i<=n;i++){
		while(y[j+1]-x[i]<eps&&j<n)j++;
		res+=j;
	}
	return res/2>=k;
}
signed main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0),std::cout.tie(0);
	std::cin>>n>>k;
	for(int i=1;i<=n;i++)
		std::cin>>a[i]>>c[i];
	double l=1,r=1e9;
	for(int i=1;i<=50;i++){
		double mid=(l+r)/2.0;
		if(check(mid))	l=mid;
		else	r=mid;
	}
	printf("%.3f\n",l);
	return 0;
}
```
## 完结撒花

---

## 作者：peixiaorui (赞：3)

## 思路

题目要我们求第 $k$ 大的温度值，求第 $k$ 大的值通常有两种方法：

- 暴力求解出所有情况，排序后找到第 $k$ 大的值。
- 二分答案，判断值在答案以上的有多少个。

发现 $k < 10^{10}$，暴力是不可能的，于是考虑二分。

### `check` 函数

二分答案最重要的部分在于 `check` 函数，那么 `check` 函数应该怎么写呢？

假设我们二分出的温度值为 $t$，可得：
$$\frac{a_i \times c_i + a_j \times c_j}{a_i + a_j} \ge t$$
因为 $a_i + a_j \ge 0$，移项可得：
$$a_i \times c_i + a_j \times c_j \ge t \times a_i + t \times a_j$$
移项，使下标相同的项移到同侧，得：
$$a_i \times c_i - t \times a_i \ge t \times a_j + a_j \times c_j$$
不等式左右两边的值都可以预处理。

接下来只需要算出满足这个不等式的二元组 $(i,j)$ 的个数，只要大于等于 $k$ 就算合法。
我们可以对所有预处理出的值进行排序，再用双指针查找。

这样 `check` 函数就写好啦！时间复杂度为 $O(n \log{t})$。

注意：浮点数判等可能有精度误差，要用特殊方法：
当 $\lvert x - y \lvert \le eps$ 时，即可判定 $x = y$（题目要求精度为小数点后三位，所以可取 $eps = 10^{-3}$）。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
#define ll long long
int n;ll k;
double a[100100],c[100100];
double x[100100],y[100100];
bool check(double t){
	ll cnt=0;
	fo(i,1,n){
		x[i]=a[i]*c[i]-a[i]*t;//不等式左边的值
		y[i]=a[i]*t-a[i]*c[i];//不等式右边的值
		if(y[i]-x[i]<1e-3)cnt--;//判重（如果x与y相等会多算一个）
	}
	sort(x+1,x+n+1),sort(y+1,y+n+1);
	int j=0;
	fo(i,1,n){
		while(y[j+1]-x[i]<1e-3&&j<n)j++;
		cnt+=j;
	}//双指针记录数量
	return cnt/2>=k;//一个二元组会被记录两遍，数量要除以2
}
int main(){
	cin>>n>>k;
	fo(i,1,n)cin>>a[i]>>c[i];
	double le=1,ri=1e9;
	fo(i,1,50){//50次循环就能保证精度，无需判断
		double mid=(le+ri)/2.0;
		if(check(mid))le=mid;
		else ri=mid;
	}
	printf("%.3f\n",le);//记得保留三位小数
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：2)

### Subtask1 
暴力枚举，时间复杂度 $O(n^2 \log n^2)$。预计得分 $10pts$。

### Subtask 2 
对于最高的混合温度，要保证任意混合温度均不大于该温度 $t$，即

$$\dfrac{a_i×c_i+a_j×c_j}{a_i+a_j }≤t$$

$$∴a_i×c_i-t×a_i+a_j×c_j-t×a_j≤0$$
假设 $s_i=a_i×c_i-t×a_i$，上式即：
$$s_i+s_j≥0$$
我们可以二分 $t$，对得到的 $s$ 排序，看最大的两个数是否大于零。

时间复杂度 $O(\log a×n\log n)$。预计得分$40pts$。

### Subtask 3 
有了上面的思路，我们可以考虑二分出 $t$。再处理出搭配方案数是否大于 $k$。这里可以均摊。
时间复杂度 $O(\log a×n\log n)$，预计得分 $100pts$。
## 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
const int MAXN=1e5+5;
const double dx=1e-6;
ll n,k;
struct cup{
	int t,v;
	long double s;
}a[MAXN];
bool cmp(cup x,cup y){return x.s<y.s;}
double l,r,mid;
bool check(long double x){
	for(int i=1;i<=n;i++)
		a[i].s=(x-a[i].t)*a[i].v;
	sort(a+1,a+n+1,cmp);
	int j=n;
	long long res=0;
	for(int i=1;i<=n;i++){
		while(a[j].s>-a[i].s&&j>=1)
			j--;
		res+=j;
		if(a[i].s<=0)
			res--;
	}
	return res>=k*2;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i].v>>a[i].t;
	l=0,r=1e9;
	while(r-l>=dx){
		mid=(l+r)*0.5;
		if(check(mid))
			l=mid;
		else
			r=mid;
	}
	printf("%.9lf",l);
	return 0;
}

```


---

## 作者：一只书虫仔 (赞：1)

#### Description

> 给定 $n$ 杯水，第 $i$ 杯水温度为 $c_i$，体积为 $a_i$，求两两混合后温度第 $k$ 大是多少。

#### Solution

水二分，比方分不知道简单到哪里去了（点名表扬 Sept（

求第 $k$ 大，自然联想到二分。二分的过程好理解，主要是二分的 check 怎么写。

设要 check 的是 $mid$，则我们要求满足：

$$\frac{a_ic_i+a_jc_j}{a_i+a_j} \ge mid$$

的数对 $(i,j)$ 的个数是否大于 $0$。

考虑化简上面那个不等式：

$$\begin{aligned}a_ic_i+a_jc_j &\ge mid(a_i+a_j)\\a_ic_i+a_jc_j&\ge mid\ a_i+mid\ a_j\\(c_i-mid)a_i& \ge (mid-c_j) a_j\end{aligned}$$

左右都可以算，于是问题演变成了求数对个数使得 $a_i \ge b_j$ 的问题。

官方题解给的是双指针的做法，这里提供一种归并做法。

首先先把归并排序模板套上，也就是给序列排个序，排序的同时可以直接执行计算。因为我们都知道归并排序的时候会存在一个值 $pil$，将需要排序的区间 $a_{[l,r]}$ 拆分为三个部分：$<pil$ 的，$=pil$ 的和 $>pil$ 的，然后再分别排序。那么问题其实可以转化为在区间 $b_{[l,r]}$ 中固定一个值 $k$，寻找有多少个数小于 $k$，可以直接将归并里的 $pil$ 设为 $k$，然后在函数里排序的同时进行操作。最终在题目中实现的时候就从 $1$ 到 $n$ 枚举 $a_i$ 然后在 $b_{[1,n]}$ 中归并查找即可。

然后这题就做完了。

---

## 作者：Aw顿顿 (赞：1)

一道适合疲劳时练手的二分题。

自然，二分的重点在于 $\texttt{check()}$ 函数的实现，不妨进行推导：

$$mid\le\dfrac{a_ic_i+a_jc_j}{a_i+a_j}$$

进行简单的代数变换即可得到：


$$mid(a_i+a_j)\le a_ic_i+a_jc_j$$

$$mid\cdot a_i+mid\cdot a_j\le a_ic_i+a_jc_j$$

将公因式提取出来方便进行计算：

$$mid\cdot a_j\le a_i(c_i-mid)+a_jc_j$$

$$(mid-c_j)a_j\le a_i(c_i-mid)$$

显然，对于任意一个确定的 $mid$，不等式的左右两边都有确定的值，因此可以进行计算，转化为经典问题后显然不难解决了，具体的实现参考代码。

```cpp
#include<bits/stdc++.h>
#define N 100005
#define int long long 
#define eps 1e-6
using namespace std;
int n,k,a[N],c[N];
double p[N],q[N];
inline bool cmp(double a,double b){return a<b;} 
inline int check(double mid){
    int tot=0;
    for(register int i=1;i<=n;i++){
    	double x=1.0*a[i]*c[i];
    	double y=mid*a[i];
    	p[i]=x-y;q[i]=y-x;
    	tot-=(q[i]-p[i]<eps);
	}sort(p+1,p+n+1,cmp),sort(q+1,q+n+1,cmp);
	int x=0;
	for(register int i=1;i<=n;i++){
		while(q[x+1]-p[i]<eps&&x<n)x++;
		tot+=x;
	}return (tot/2<k);
}signed main(){
	scanf("%lld%lld",&n,&k);
	for(register int i=1;i<=n;i++)
		scanf("%lld%lld",&a[i],&c[i]);
	double l=1,r=N*N,mid;
	while((r-l)>eps){
		mid=(l+r)/2;
		if(check(mid))r=mid;
		else l=mid;
	}printf("%.6f\n",l);
	return 0;
}
```



---

## 作者：OIer_ACMer (赞：0)

# 题目解析：

我们从题目给的条件下手：

$$
T=\dfrac{a_ic_i+a_jc_j}{a_i+a_j}
$$

可知温度 $T$ 的结果是温度和体积之积的和再除以体积的结果。同时，题目要求我们找出第 $k$ 大的温度值，很显然，我们除了二分别无选择，因为只有这样才能每次得出有多少符合要求有多少不能，当然有大佬用别的方法做蒟蒻甘拜下风。

根据二分，我们可以知道当我们现在选的两杯水的温度是大于等于目前的温度，也就是此时的温度排在前面属于前 $k$ 个，这个不难理解，式子如下：

$$\frac{a_i \times c_i + a_j \times c_j}{a_i + a_j} \ge mid$$

我们利用移项，将分母部分移动至 $mid$ 处：

$$a_i \times c_i + a_j \times c_j \ge mid \times a_i + mid \times a_j$$

此时，我们似乎陷入了瓶颈，因为二分最多只能二分一边或者二分中再套一个二分，不过，先别急，为了实现二分，我们要围绕 $mid$ 值做文章，我们可以先尝试将 $mid$ 值与它对应的 $a_i$ 值移动到左边，而将左边的 $a_j$ 部分移动到右边，组成一个全新的不等式：

$$a_i \times c_i - mid\times a_i \ge mid \times a_j - a_j \times c_j$$

这时，我们再利用乘法结合律，得出：

$$a_i \times (c_i-mid) \ge a_j \times (mid-c_j)$$

在原先的式子上，我们可以发现，**两边括号内的式子成相反数**，那么，我们在二分的时候就可以将另一边的式子用左边的相反数表示，也就是加一个负号，这一点在我的代码中可以体现出来。

而我们还要注意的是，本道题的数据范围很大，我们必须要用简单的算法实现二分函数的检查功能，所以，我们要先预处理出所有的水杯和 $mid$ 的乘积值，就是最后一个公式的左右两边的那个式子，之后，通过从小到大排序，我们利用双指针思路先找有多少是满足式子的，满足的就让 $j$ 的值（就是另一个指针）减一，**因为这说明已经有的水的温度超过了 $mid$，排在了前面，同时用 $sum$ 求和，找出有多少个在 $mid$ 的前面**。

不过，要注意的是一方面，在这之后，我们的 $j$ 指针不用移动，因为我们已经排好序了，以最终不等式的左边来看，**左边已经排好序，右边的相对于左边是逆序**，这样我们在找出最后一组满足的式子之后，我们就不会有满足的了，**毕竟最后一组满足的就相当于两边的相遇点，相遇之后再无交集，对吧**。

最后，告诫各位，在计算 $sum$ 时不要将 $j$ 的临界条件加在循环结束条件中，**因为有的水杯中的水和任何水加在一起都大于此时的 $mid$，那么我们就要直接记录答案**，如果将 $j$ 的临界条件加在循环结束条件中，会使有些答案无法记录，导致 $sum$ 的值一直不符合要求，从而使二分出错。

最后的最后，在判断这种情况有没有时要注意当有的时候 $sum$ 的值要大于两倍的 $k$ 因为我们在最终计算 $sum$ 值时用的是同一个数组，**每个会算两遍**。还有，在改变 $l$ 和 $r$ 时，只有当函数返回为真时才会让 $l$ 为 $mid$，这一点比较麻烦，反过来让 $r$ 为 $mid$，**因为当 $sum$ 满足条件时，说明温度太低满足的太多，因而 $l$ 要上升，提高最低温度，$r$ 同理**。

# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
double b[1000009];
int n, k;
int a[1000009], c[1000009];
int sum = 0;
bool check(double mid)
{
    sum = 0;
    for (int i = 1; i <= n; i++)
    {
        b[i] = 1.0 * a[i] * (c[i] - mid);
        if (b[i] >= 0)
        {
            sum--;//提前去除掉重复的情况
        }
    }
    sort(b + 1, b + n + 1);
    for (int i = 1, j = n; i <= n; i++)
    {
        while (b[i] >= -b[j] && j >= 1)
        {
            j--;
        }
        sum += n - j;
    }
    if (sum >= k * 2)
    {
        return 1;
    }
    return 0;
}
int main()
{
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i] >> c[i];
    }
    double l = 1.0, r = 1000000000.0, mid;
    while (fabs(l - r) > 1e-5)
    {
        mid = (l + r) * 1.0 / 2;
        if (check(mid))
        {
            l = mid;
        }
        else
        {
            r = mid;
        }
    }
    cout << fixed << setprecision(3) << l << endl;
    return 0;
}

```

---

## 作者：Imiya (赞：0)

考虑二分温度 $t$。

设计 $check(t)$ 返回大于等于 $t$ 的可能温度值数量 $cnt$ 是否大于等于 $k$。

$$T=\frac{a_ic_i+a_jc_j}{a_i+a_j}\ge t$$
$$a_ic_i+a_jc_j\ge a_it+a_jt$$
$$a_i(c_i-t)+a_j(c_j-t)\ge0$$

令 $b_i=a_i(c_i-t)$，问题变成了求有多少对 $i<j$，满足 $b_i+b_j\ge 0$。

将 $b$ 排好序，发现这个问题具有单调性，若 $b_i+b_j\ge 0,b_{i-1}+b_j<0$，则 $b_x+b_j\ge 0(x\in(i,j))$，同时若存在 $b_{i_1}+b_{j-1}\ge 0$，$i_1$ 必定不小于 $i$。

可以用双指针 $l,r$，令 $r$ 由右向左移动，$r$ 每走一位 $l$ 向右移动直到 $b_l+b_r\ge 0$，此时令答案 $ans:=ans+r-l$。

$l$ 单调不减，$r$ 单调递减，但由于使用了排序，$check()$ 总复杂度 $O(n\log n)$。

套上二分答案总复杂度 $O(n\log^2n)$。

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
#define int long long
#define double long double
const int N=100100;
int n,k,a[N],c[N];
double p[N];
void init(){
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>a[i]>>c[i];
}
const double eps=1e-11;
inline bool check(double t){
    for(int i=1;i<=n;i++)p[i]=a[i]*(1.0*c[i]-t);
//    for(int i=1;i<=n;i++)cout<<p[i]<<' ';
    sort(p+1,p+1+n);
    int l=1;
    long long cnt=0;
    while(l<n&&p[l]+p[n]<0)l++;
    cnt+=n-l;
    for(int i=n-1;i>l;i--){
        while(l<i&&p[l]+p[i]<0)l++;
        cnt+=i-l;
    }
//    cout<<cnt<<endl;
    return cnt>=k;
}
double get_ans(double l,double r){
    while(abs(l-r)>eps){
        double mid=(l+r)/2;
        if(check(mid))l=mid;
        else r=mid;
    }
    return l;
}
signed main(){
    //freopen("read.in","r",stdin);
    init();
//    for(int i=1;i<n;i++){
//        for(int j=i+1;j<=n;j++)cout<<(double)(a[i]*c[i]+a[j]*c[j])/(double)(a[i]+a[j])<<' ';cout<<endl;
//    }
    printf("%.3Lf",get_ans(1,1e9));
//    cout<<check(3.6666667);
//    cout<<check(4.5);
    return 0;
}
```

---

## 作者：XL4453 (赞：0)

### 解题思路：

想要一个一个数出第 $k$ 大显然是不可能的，考虑二分最后的温度 $t$，检验有多少组温度是小于这个最终结果的。

然后稍微推一下式子：$\dfrac{a_ic_i+a_jc_j}{a_i+a_j}\le t$，由于 $a_i+a_j\ge 0$，乘到右边去并移项得到 $a_i(c_i-t)+a_j(c_j-t)\ge 0$。

发现此时 $i$ 和 $j$ 是割裂的，而且具有很好的单调性，直接分开计算每一个的值，排序完之后用双指针直接统计一下答案就好了。

复杂度 $O(n\log n\log a)$，可以接受。


---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
const int MAXN=100005;
const double eps=1e-3;
int n,k,a[MAXN],c[MAXN],p;
double l,r,mid,x[MAXN];
bool check(double num){
	for(int i=1;i<=n;i++)
	x[i]=(double)a[i]*((double)c[i]-num);
	sort(x+1,x+n+1);
	int tot=0;p=n+1;
	for(int i=1;i<=n;i++){
		while(x[i]+x[p-1]>=0&&p>=i)p--;
		p=max(p,i+1);
		tot+=n-p+1;
	}
	return tot>=k;
}
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&a[i],&c[i]);
		r=max((double)c[i],r);
	}
	while(r-l>=eps){
		mid=(l+r)/2;
		if(check(mid))l=mid;
		else r=mid;
	}
	printf("%.4lf",l);
	return 0;
}
```


---

## 作者：JackMerryYoung (赞：0)

# 前言

刷二分题单的时候看到的一道比较有数学难度的题目。

# 正文

看到 $K$ 的值域比较大，考虑使用二分答案。

`check()` 的时候需要使用数学方法。

对于检验满足 $\dfrac{a_i \cdot c_i + a_j \cdot c_j}{a_i + a_j} \ge mid$ 的二元组 $(i, j)$ 的数量是否大于 $2K$ 的问题，我们可以通过对柿子变换得到：

$$
a_i \cdot c_i + a_j \cdot c_j \ge a_i \cdot mid + a_j \cdot mid
$$

移项：

$$
a_i \cdot c_i - a_i \cdot mid \ge a_j \cdot mid - a_j \cdot c_j
$$

合并同类项：

$$
a_i \cdot (c_i - mid) \ge a_j \cdot (mid - c_j)
$$

于是令 $w_x = (mid - c_x) \cdot a_x$.

原不等式可化为：

$$
-w_i \ge w_j
$$

即：

$$
w_i + w_j \le 0
$$

那么手动求解即可。

# 代码

~~你们最想要的..~~ 

Talk is$\color{white}\text{n't}$ cheap, $\color{white}\text{Don't}$ show me the code...

``` cpp
#include <bits/stdc++.h>
using namespace std;

long long N, K;

struct Cup {
	int a, c;
	long double w;
} arr[100005];

bool operator <(Cup __a, Cup __b)
{
	return __a.w < __b.w;
}

bool check(long double mid)
{
	for(int i = 1; i <= N; ++ i)
		arr[i].w = (mid - 1.000 * arr[i].c) * arr[i].a;
		
	sort(arr + 1, arr + N + 1);
	int pt = N;
	long long pos = 0; // pos
	for(int i = 1; i <= N; ++ i)
	{
		while(arr[pt].w + arr[i].w > 0 && pt >= 1)
			-- pt;
	
		pos += pt;
		if(arr[i].w <= 0)
			-- pos;
	}
	
	return pos >= K * 2ll;
}

int main()
{
	cin >> N >> K;
	for(int i = 1; i <= N; ++ i)
		cin >> arr[i].a >> arr[i].c;
		
	long double l = 1, r = 1e13;
	while(r - l >= 1e-9)
	{
		long double mid = (l + r) / 2.0;
		if(check(mid))
			l = mid;
		else
			r = mid;
	}
	
	printf("%.3Lf\n", l);
	return 0;
}
```

# 后言

看到数学题不要怕，毕竟黄绿难度的二分一般不会有数论内容。

---


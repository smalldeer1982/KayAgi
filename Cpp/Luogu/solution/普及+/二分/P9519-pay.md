# pay

## 题目描述

今天是 L 公司发工资的一天。

$n$ 名员工排成一排准备领工资，编号为 $1\sim n$，第 $i$ 名员工有一个期望快乐值 $a_i$。

老板非常扣，在这 $n$ 名员工中只选择了 $m$ 名员工 $b_1,b_2,\cdots,b_m$ 发 $k$ 元工资。

员工们都非常具有同理心，不仅自己获得工资时会增加快乐值，当周围的员工获得工资时自己也会增加快乐值。

具体地，当与一名员工 A 距离为 $d$ 的员工获得了工资，A 的快乐值会增加 $\max(0, k - d)$。特别地，如果 A 本身就获得了工资，A 的快乐值会增加 $k$。

老板希望，你能找到最小的整数 $k$，使得所有员工的快乐值不低于他的期望。

## 说明/提示

**【样例说明】**

样例 $1$ 中，$k=2$ 时，每个人的快乐值分别为 $3,4,4,4,3$，满足要求。

样例 $2$ 中，$k=5$ 时，每个人的快乐值分别为 $5,7,7,7,7$，满足要求。

**【数据范围】**

对于 $10\%$ 的数据，满足 $n=1$。

对于 $30\%$ 的数据，满足 $n\le 300$。

对于 $60\%$ 的数据，满足 $n\le 5000$。

对于另外 $10\%$ 的数据，满足 $m=1$。

对于 $100\%$ 的数据，满足 $1\le m\le n\le 10^6$，$0\le a_i\le 10^9$，$1\le b_i\le n$ 且 $b_i$ 互不相同。

**本题输入量较大，请注意使用合理的输入方式。**

## 样例 #1

### 输入

```
5 5
3 3 3 3 3
1 2 3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
5 2 6 3 1
2 5```

### 输出

```
5```

# 题解

## 作者：引领天下 (赞：24)

看到这道题第一反应就是二分，二分最终到底发多少工资。

那么现在问题就变成了，如何在线性时间内判断一个给定的 $k$ 是否能满足题意？

我们意识到，朴素的 $n^2$ 的统计方法中有大量无用的计算——当第 $i$ 个人发工资的时候，他会同时对 $i+1\sim i+k$ 和 $i-k\sim i-1$ 产生贡献，并且这个贡献恰好依次递减。

这启发我们思考，能否通过重复减一的方式来获得某个位置对当前位置的贡献呢？

答案当然是肯定的。

我们定义一个队列 $q$ 用于存放所有对当前位置有贡献的位置，设 $s$ 表示队列中所有元素的贡献之和，那么每次后移的时候只需要 $s\rightarrow s-|q|$（其中 $|q|$ 表示 $q$ 中的元素个数），就可以方便的更新当前位置能获得的贡献。如果一个位置不再对当前位置产生贡献，那么将他踢出队列即可。

这样我们就获得了 $i$ 之前的发工资的人对 $i$ 产生的贡献。

然后再逆序做一遍，就可以获得 $i$ 之后的发工资的人对 $i$ 产生的贡献。这两部分加起来，再考虑 $i$ 自身发的工资，就得到 $i$ 最终的满意度，和 $a_i$ 比较即可。

这样我们就在线性复杂度内完成了对某个 $k$ 是否符合题意的检查，算法总复杂度 $O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],ans,m,b,l=1,r,mid;
bool s[1000005];
long long c[1000005];
inline bool check(int k){
    queue<int> q;
    long long sum=0;
    memset(c,0,sizeof(c));
    for(int i=1;i<=n;i++){
        sum-=q.size();
        if(!q.empty()&&i-q.front()>=k)q.pop();
        if(s[i])sum+=k,q.push(i);
        c[i]+=sum;
    }
    while(!q.empty())q.pop();sum=0;
    for(int i=n;i;i--){
        sum-=q.size();
        if(!q.empty()&&q.front()-i>=k)q.pop();
        if(s[i])sum+=k,q.push(i);
        c[i]+=sum;
        if(s[i])c[i]-=k;//注意特判，如果 i 本身发了工资，那么会被统计两次，需要减去重复的。
    }
    for(int i=1;i<=n;i++)if(c[i]<a[i])return 0;
    return 1;
}
int main(){
    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i],r=max(r,a[i]);
    for(int i=1;i<=m;i++)cin>>b,s[b]=1;
    r+=n;//需求最高的人不一定发工资，所以加上 n 之后才是真正的二分上限。
    while(l<=r){
        mid=(l+r)>>1;
        if(check(mid))ans=mid,r=mid-1;
        else l=mid+1;
    }
    cout<<ans;
}
```

---

## 作者：Register_int (赞：16)

显然，当 $k$ 递增时，每个员工的快乐值是单调不减的。我们可以考虑二分答案，这样，问题就转化为：线性复杂度内求出所有员工的快乐值。

贡献一共套了两层，一层 $\max$ 一层 $\text{abs}$，我们来一层一层去掉他们。

$\text{abs}$ 是简单的，我们每次只要分开计算一个员工左边\右边的贡献，再扣除自身的贡献即可。对于左边的贡献，可以发现 $k-d$ 也是单调不减的，也就是第一个满足 $k-d>0$ 的位置 $p$ 是单调不减的。算出 $p\sim i$ 中有 $cnt$ 个员工会发工资，那么每次把 $i$ 往后移动一格，都会远离所有 $cnt$ 个员工一格，并产生 $-cnt$ 的贡献。当这位员工本身就会被发工资时，他的贡献也会加上 $k$。我们只需要维护三个量，分别表示 $i,p,cnt$，就能动态算出所有的贡献。右边的部分同理。这三个指针的变化量均为 $O(n)$，因此单次检查也是 $O(n)$ 的，总时间复杂度为 $O(n\log V)$。

二分上界为 $\max a_i+n-1$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;

int n, m, a[MAXN], b[MAXN]; ll t[MAXN];

bool v[MAXN];

inline 
bool check(ll x) {
	ll s = 0;
	for (int i = 1, j = 1, k = 0; i <= n; i++) {
		for (s -= k; k > 0 && i - b[j] >= x; k--, j++);
		v[i] && (k++, s += x), t[i] = s;
	}
	s = 0;
	for (int i = n, j = m, k = 0; i; i--) {
		for (s -= k; k > 0 && b[j] - i >= x; k--, j--);
		v[i] && (k++, s += x, t[i] -= x), t[i] += s;
	}
	for (int i = 1; i <= n; i++) if (t[i] < a[i]) return 0; return 1;
}

int l = 0, r = 1e9, mid;

int main() {
	scanf("%d%d", &n, &m), r += n;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1; i <= m; i++) scanf("%d", &b[i]), v[b[i]] = 1; sort(b + 1, b + m + 1);
	for (; l < r; check(mid = l + r >> 1) ? r = mid : l = mid + 1);
	printf("%lld", l);
}
```

---

## 作者：ShwStone (赞：9)

首先二分比较显然，如果某一个工资能满足，更高的工资一定也能满足，可以二分。

判断函数有两种方法：

### 维护差分

维护差分数组的差分来实现区间加等差数列，在全部加完之后做两次前缀和。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e6 + 5;

int n, m;
long long a[maxn], d[maxn];
int b[maxn];

bool check(long long x) {
    memset(d, 0, sizeof d);
    for (int i = 1; i <= m; i++) {
        if (b[i] < x) {
            d[1] += x - b[i] + 1;
            d[2] -= x - b[i];
            d[b[i] + 1]--;
        }
        else {
            d[b[i] - x + 1]++;
            d[b[i] + 1]--;
        }

        d[b[i] + 1]--;
        if (b[i] + x <= n) d[b[i] + x + 1]++;
    }
    for (int i = 1; i <= n; i++) d[i] += d[i - 1];
    for (int i = 1; i <= n; i++) d[i] += d[i - 1];
    for (int i = 1; i <= n; i++) {
        if (d[i] < a[i]) return false;
    }
    return true;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", a + i);
    }
    for (int i = 1; i <= m; i++) {
        scanf("%d", b + i);
    }
    long long l = 0, r = 2000000000, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    printf("%lld\n", l);
    return 0;
}
```

### 统计贡献

一个员工分别可以向左向右延伸 $x$ 个人，在这左右两个区间内的工资会对员工产生贡献。

从左到右扫一遍员工，每移动一格，左右区间就跟着移动一格。这个时候，左区间里的贡献全部减一，右区间的贡献全部加一，可以用两个变量来维护左右区间的工资数目。

预处理出第一个员工的贡献，然后从头扫到尾即可。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e6 + 5;

int n, m;
long long a[maxn], d[maxn];
bool book[maxn];

bool check(long long x) {
    long long sum = 0, cnt1 = 0, cnt2 = 0;
    for (int i = 1; i <= n; i++) {
        if (book[i]) sum += max(0LL, x - (i - 1));
        if (book[i] && i <= x) cnt2++;
    }
    if (sum < a[1]) return false;
    for (int i = 2; i <= n; i++) {
        if (i + x - 1 <= n && book[i + x - 1]) cnt2++;
        if (book[i - 1]) cnt2--, cnt1++;
        sum += cnt2;
        sum -= cnt1;
        // if (x == 5) printf("%lld\n", sum);
        if (sum < a[i]) return false;
        if (i - x >= 1 && book[i - x]) cnt1--;
    }
    return true;
}

int main() {
    scanf("%d %d", &n, &m);
    bool flag = true;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", a + i);
        if (a[i] != 0) flag = false;
    }
    if (flag) {
        printf("0\n");
        return 0;
    }
    for (int i = 1; i <= m; i++) {
        int x;
        scanf("%d", &x);
        book[x] = true;
    }
    long long l = 1, r = 2000000000, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    printf("%lld\n", l);
    return 0;
}
```

---

## 作者：GeorgeAAAADHD (赞：8)

题目大意是说每个人有一个期望快乐值 $a_i$，老板准备给 $m$ 个人 $b_1,b_2,\cdots,b_m$ 每人发 $k$ 元工资，这些人的快乐值初始为 $k$。除此之外，这些人还可以影响到与其距离小于 $k$ 的人，而这些人的快乐值就会额外加上 $k-d$（$d$ 为这两个人的距离）。求 $k$ 的最小值使得每个人的快乐值都不低于其期望快乐值。

很容易想到二分答案。那么对于这些要发工资的人，他会对周围距离小于 $k$ 的人加上一些快乐值，这形成了一个山峰型的等差数列。我们举个例子：

有 $8$ 个人，现在给第 $4$ 个人发 $3$ 元工资，其快乐值如下表：
| 序号 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 快乐值 | $0$ | $1$ | $2$ | $3$ | $2$ | $1$ | $0$ | $0$ |

等差数列，我们想到了什么？没错，差分。

但是这题用一个差分数组是对某段区间进行区间加，减操作。这个过程虽然可以使用树状数组实现，但是时间复杂度是双 $\log$ 级别的，不够优秀。于是我们考虑再套一个差分数组，也就是二阶差分。还是按上面的例子继续看：

| 序号 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 快乐值 | $0$ | $1$ | $2$ | $3$ | $2$ | $1$ | $0$ | $0$ |
| 一阶差分 | $0$ | $1$ | $1$ | $1$ | $-1$ | $-1$ | $-1$ | $0$ |
| 二阶查分 | $0$ | $1$ | $0$ | $0$ | $-2$ | $0$ | $0$ | $1$ |

这样，我们就只需要对起始点，$b_i+1$ 点和终点 $+2$ 三个点进行修改即可。注意当起始点在 $1$ 之前时需将修改起始点改为修改 $1,2$ 号点。

这样单次二分的时间复杂度是 $O(n+m)$，总时间复杂度即为 $O(\log ( \max a_i + n - 1)\times (n+m))$ ，极限数据运算次数 $\approx 6 \times 10^7$，足以通过本题。

于是这题就做完了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[1000005],b[1000005],l=0,num[1000005]={0},r=1e9+1e6,ans=1e9+1e6;
bool check(int mid){
	memset(num,0,sizeof(num));
	for(int i=1;i<=m;i++){
		int zuo=b[i]-mid+1;
		if(zuo>=1){
			num[zuo]++;
			if(b[i]+1<=n)num[b[i]+1]-=2;
			if(b[i]+mid+1<=n)num[b[i]+mid+1]++;
		}
		else{
			int numm=2-zuo;
			num[1]+=numm;
			if(n>=2)num[2]-=numm-1;
			if(b[i]+1<=n)num[b[i]+1]-=2;
			if(b[i]+mid+1<=n)num[b[i]+mid+1]++;
		}
	}
	for(int i=2;i<=n;i++){
		num[i]+=num[i-1];
	}
	for(int i=2;i<=n;i++){
		num[i]+=num[i-1];
	}
	for(int i=1;i<=n;i++){
		if(num[i]<a[i])return 0;
	}
	return 1;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>b[i];
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid))ans=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：金刚xkb (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P9519)

本篇题解使用了跟其它题解思路差别较大~~奇特~~的解法。

## 思路

### 二分

首先，注意到每一个员工的快乐值都关于 $k$ **单调不减**，考虑通过二分 $k$ 的值来解决问题。

### 判定

现在我们需要解决以下问题：已知 $k$ 的值，判断是否能使所有员工的快乐值都能达到期望。

依照题意，对于任意一名发工资的员工，其对周围的员工快乐值的影响可以抽象为左右两个有边界的一次函数，如下图。

[![](https://cdn.luogu.com.cn/upload/image_hosting/6028f2qe.png)](https://www.desmos.com/calculator/i32kei7kd0)

该员工所在的点视为 $(b_i,k)$，两个一次函数的斜率分别为 $1,-1$，因此，我们可以把这两个一次函数的表达式写出来：

$$y=x+k-b_i$$

$$y=-x+k+b_i$$

现在有多个这种一次函数，只要把它们叠加在一起（作一次多项式加法）就能求出来每一个员工最终的快乐值。

有界，叠加……这不就是差分嘛！只不过我们要用差分**维护一次函数的系数**！

这里有一个小细节需要注意：中间横坐标为 $b_i$ 的点只能处理一次，千万不要在左面的一次函数差分一次之后，在右面又差分一次（具体见代码中的 ```b[i]+1```）。

最后，对从左到右扫描每一个员工，带入横坐标（即编号）计算出其快乐值，就能判断出当前 $k$ 值是否能满足要求啦！

## AC代码

```cpp
#include<bits/stdc++.h>
#define rint register int
#define cint const int
#define ll long long
using namespace std;
cint N=1e6+5;
int n,m,a[N],b[N];
void input(){
    cin>>n>>m;
    for(rint i=1;i<=n;++i){
        cin>>a[i];
    }
    for(rint i=1;i<=m;++i){
        cin>>b[i];
    }
    return;
}
void work(){    
    ll x[n+5],y[n+5];
    int l=1,r=1e9+n+5,k,tl,tr,ju;
    ll tx,ty,tmp;
    while(l<r){
        memset(x,0,sizeof(x));
        memset(y,0,sizeof(y));
        ju=0;
        k=(r+l)>>1;
        for(rint i=1;i<=m;++i){
            tl=b[i]-k;
            if(tl<1) tl=1;
            ++x[tl];
            y[tl]+=k-b[i];
            --x[b[i]+1];
            y[b[i]+1]-=k-b[i];
            tr=b[i]+k;
            if(tr>n) tr=n;
            --x[b[i]+1];
            y[b[i]+1]+=k+b[i];
            ++x[tr+1];
            y[tr+1]-=k+b[i];
        }
        tx=ty=0;
        for(rint i=1;i<=n;++i){
            tx+=x[i];
            ty+=y[i];
            tmp=tx*i+ty;
            if(tmp<a[i]){
                ju=1;
                break;
            }
        }
        if(ju) l=k+1;
        else r=k;
    }
    cout<<l;
    return;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL);
    input();
    work();
    return 0;
}
```

---

## 作者：Nuyoah_awa (赞：6)

### 题目大意

共有 $n$ 个人，我们将给其中 $m$ 个人发 $k$ 元的工资，对于每名员工，他的工资会影响他左右 $k-1$ 个人的开心度，问满足所有人的开心度的最小的 $k$。

### 题目分析

#### 暴力：
枚举 $k$，判断是否满足所有人的期望。

时间复杂度为 $\mathcal O(k \times (n \times k))$。

#### 正解：

很容易发现，对于 $k$ 是否满足期望有单调性，所以可以考虑二分 $k$，时间复杂度优化为 $\mathcal O(\log k \times (n \times k))$。

我们发现对于每次判断都是 $\mathcal O(n \times k)$ 的，我们考虑能否优化为 $\mathcal O(n)$ 的。

对于每个有工资的人，他可以给周围的人增加的贡献如下：

$$1, 2, 3, \dots, n-1, n, n-1, \dots, 3, 2, 1 $$

我们可以将其分为两部分去算：

$$\underbrace{1, 2, 3, \dots, n-1}_{part1}, \underbrace{n, n-1, \dots, }_{part2}$$

- 对于 part1：

我们可以从后往前扫一遍，维护一个变量 $sum$ 表示当前这个点在 part1 中得到的快乐值，对于每个有工资的点我们在原有 $sum$ 之上加上 $k$，对于每个点我们需要将 $sum$ 减去正在对其起作用的有工资点的个数，即 $i+1 \sim i+k$ 这些点中有工资点的个数。

- 对于 part2：

同理，只是对于每个点，减去 $i - k \sim i-1$ 这些点中有工资的点的个数。

最后总的时间复杂度是二分+判断，也就是 $\mathcal O(\log k \times n)$ 的。

### code
```cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], c[N], b, s[N];
bool cnt[N]; 
bool check(int x)
{
	for(int i = 1;i <= n;i++)
		c[i] = 0;
	int sum = 0;
	for(int i = 1;i <= n;i++)
	{
		if(cnt[i])
			sum += x;
		sum -= s[i-1] - s[max(0ll, i-x-1)];
		c[i] += sum;
	}
	sum = 0;
	for(int i = n;i >= 1;i--)
	{
		if(cnt[i+1])
			sum += x-1;
		sum -= s[min(n+1, i+x)] - s[i+1];
		c[i] += sum;
	}
	for(int i = 1;i <= n;i++)
		if(c[i] < a[i])
			return false;
	return true;
}
signed main()
{
	scanf("%lld %lld", &n, &m);
	for(int i = 1;i <= n;i++)
		scanf("%lld", &a[i]);
	for(int i = 1;i <= m;i++)
	{
		scanf("%lld", &b);
		cnt[b] = true;
	}
	for(int i = 1;i <= n + 1;i++)
		s[i] = s[i-1] + cnt[i];
	int l = 0, r = 1e10;
	while(l < r)
	{
		int mid = (l + r) >> 1;
		if(check(mid))
			r = mid;
		else
			l = mid + 1;
	}
	printf("%lld", l);
	return 0;
}
```

---

## 作者：TruchyR (赞：4)

## Part 1 思路
看题在看数据范围，得到二分。  
但是题目的数据范围容下 $O(n\log{n})$ 的复杂度就差不多了，我们的思考重心便来到了判定上。  
看一看被发奖金的员工对于所有员工的贡献？  
下图每一行代表一种情况。  
![](https://cdn.luogu.com.cn/upload/image_hosting/fsuzj8iy.png)  
这是等差数列？差分一次试试看？   
![](https://cdn.luogu.com.cn/upload/image_hosting/a97pff36.png)  
仍然需要修改很多点，再差分一次。   
![](https://cdn.luogu.com.cn/upload/image_hosting/u5fsebvm.png)  
好样的！这样每个自己获得工资的员工对答案更新时最多只需要更新 $4$ 个地方。  
**以下记收到钱的人的编号设为 $p$。**   
- 对于第一个示例，更新范围下界超过了 $1$ 号，因此我们使用 $a_0$作为辅助，$a_0$ 负责记录这段开始的时候应增加多少快乐值，易得 $a_0=k-p$。  
此后，一直到顶峰（也就是收到钱的编号）记录的都是 $0$，但是出现了一个特殊情况：记录开始节点的下一个，在此处是 $a_1$。  
在差分一次后的结果里，$a_0=2$，$a_1=1$，$a_0$ 开始节点是随着 $k$ 变化的，但 $a_1$ 固定为 $1$。  
因此需要把 $a_1$ 设为 $1-a_0$。此处的 $a_0$ 指的是本次累加的值，并非之前所有值的和。  
还可以发现 $a_{p+1}$ 固定为 $-2$。这是由于 $a_p$ 处差分一次的结果里是1，$a_{p+1}$ 为 $-1$。
最后，如果结尾更新处在 $n$ 以内，则需要更新为 $1$。（$0-(-1)=1$）  
- 这个推论在第二与第三示例中同样有效。
- 在第四示例中，更新范围没有超过 $1$ 号，此时将更新的最小编号设为 $q$。
易得 $a_q=k-p+q$，具体可以查看上文。  
后边三个值的处理与上文相同，不再赘述。  


## Part 2 代码
```c++
bool ck(int k){
	memset(a,0,sizeof(a));
	for(int i=1;i<=m;i++){
		int q=max(0ll,ts[i]-k+1ll);
		a[q]+=(k-(ts[i]-q));
		a[q+1]+=(1-k+(ts[i]-q));//此处不可直接调用a[q]
		a[ts[i]+1]-=2;
		q=min(n+1,ts[i]+k+1);
		a[q]++;
	}
	for(int i=1;i<=n;i++) a[i]+=a[i-1];
	for(int i=1;i<=n;i++){
		a[i]+=a[i-1];//第二次处理的结果，此时二次差分的数组还原
		if(a[i]<qw[i]) return false;
	}
	return true;
}
```
这是判断二分的 $k$ 是否满足条件的代码，其中 $ts_i$ 代表第 $i$ 个收到钱的人的编号，在上文中为 $p$。  
读者可以将数组 $a$ 的更新语句与上文结合做理解。
```c++
signed main(){
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>qw[i];
	for(int i=1;i<=m;i++) cin>>ts[i];
	int l=1,r=2000000000ll;
	while(l<r){
		int mid=(l+r)/2;
		if(ck(mid)) r=mid;
		else l=mid+1;
	}
	cout<<r;
	return 0;
}
```
主函数部分负责输入和二分，此处上界取了 $2\times 10^9$。  
其余的代码是数组定义部分，不再放出。

---

## 作者：wdgm4 (赞：4)

## 题外话

自我感觉这个比赛比真正的普及组简单，~~不然我是不可能 AK 的~~。QWQ

~~去年普及组 T2 就是个二分，并且 T3 感觉比这个 T3 难。QWQ~~

## 正文

#### 思路

首先一眼就能看出来是个二分，主要需要思考 `judge` 函数（二分中判断是将 $l$ 右移还是将 $r$ 左移的函数）如何用 $O(n)$ 的时间复杂度解决。

对于一个位置为 $i$ 的员工 $i$，设给那 $m$ 个员工发放 $k$ 元工资，那么会影响员工 $i$ 的快乐值的只会是在 $[i-k,i+k]$ 的区间内所有的**会被发放工资**的员工（不考虑超出 $[1,n]$ 的范围），区间外的员工就不需要算了。

我们可以将这个大区间分成三个小区间分别计算。即分成 $[i-k,i-1]$，$[i,i]$，$[i+1,i+k]$ 这三个，因为对于 $[i-k,i-1]$，每个会被发放工资的员工到员工 $i$ 的距离 $d$ 是 $i$ 减去该员工的位置，而 $[i+1,i+k]$ 就是反过来，$[i,i]$ 可以特殊判断。

我们来看 $[i-k,i-1]$ 区间，由于单次求 $i$ 的贡献的时间复杂度要求是 $O(1)$，所以我们可以用前缀和算出所有在区间内的会被发放工资的员工到员工 $i$ 的距离和 $sum$，再设区间内会被发放工资的员工的数量为 $num$，则 $[i-k,i-1]$ 的贡献就是 $k \times num-sum$。现在需要解决的就变成了如何求出所有在区间内的会被发放工资的员工到员工 $i$ 的距离和（即那个 $sum$）。其实我们可以用前缀和算出会被发放工资的员工到 $1$ 和 $n$ 的距离和。设区间 $[i-k,i-1]$ 内会被发放工资的员工到 $n$ 的距离之和为 $dis$，那么，$sum$ 就等于 $dis-num \times (n-i)$ （$n-i$ 就是员工 $i$ 到 $n$ 的距离）。区间 $[i+1,i+k]$ 同理。

而对于区间 $[i,i]$，只需判断员工 $i$ 是否在会被发放工资的员工中，如果是，它就会对自己有 $k$ 的贡献。

思路就是这样，~~可能讲的有点抽象。QWQ~~

时间复杂度 $O(n \log n)$。

#### 代码


```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 1000010
using namespace std;
int n,a[MAXN],m,b[MAXN];
int backet[MAXN];
int num1[MAXN],num2[MAXN];//数量前缀和
int sum1[MAXN],sum2[MAXN];//距离前缀和
int disl[MAXN],disr[MAXN];//到 1 or n 的距离
bool judge(int x){
	for(int i=1;i<=n;i++){
		long long ans=0;
		int r=min(n,i+x),l=max(1,i-x);
		long long nem1=num1[r]-num1[i];
		long long nem2=num2[l]-num2[i];
		long long cnt1=((sum1[r]-sum1[i])-(i-1)*nem1);
		ans+=x*nem1-cnt1;
		long long cnt2=((sum2[l]-sum2[i])-(n-i)*nem2);
		ans+=x*nem2-cnt2;
		if(backet[i]) ans+=x;
		if(ans<a[i]) return false;
	}
	return true;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	int maxn=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		maxn=max(maxn,a[i]);
	} 
	for(int i=1;i<=m;i++){
		cin>>b[i];
		backet[b[i]]=true;
		disl[b[i]]=b[i]-1;
		disr[b[i]]=n-b[i];
	} 
	for(int i=1;i<=n;i++){
		num1[i]=num1[i-1]+(disl[i]?1:0);
		sum1[i]=sum1[i-1]+disl[i];
	}
	for(int i=n;i>=1;i--){
		num2[i]=num2[i+1]+(disr[i]?1:0);
		sum2[i]=sum2[i+1]+disr[i];
	}
	int l=1,r=maxn+n,ans=0;//二分
	while(l<=r){
		int mid=l+((r-l)>>1);
		if(judge(mid)){
			r=mid-1;
			ans=mid;
		}else{
			l=mid+1;
		}
	}
	cout<<ans;
	return 0;
}
```

#### 注意事项

1. 二分时 $r$ 初始赋值不是 $maxn$（$a_i$ 最大值），可以想一想为什么。QWQ

2. 特殊判断 $[i,i]$ 时不能直接判断 $disl_i$ 是否有值，因为对于 $i=1$ 时，$disl_i$ 就等于 $0$，但它可能是被发放工资的位置。~~样例 1 其实就可以将其 hack。~~

---

## 作者：SegTree (赞：4)

[题目。](https://www.luogu.com.cn/problem/P9519)

在本题中，快乐值随 $k$ 增加显然不降，可以二分。

考虑怎么 `check`。对于每个获得工资的员工

+ $j\in[b_i-k,b_i],c_j\gets c_j+k-(b_i-j)$。

+ $j\in [b_i+1,b_i+k],c_j\gets c_j+k-(j-b_i)$。

+ 然后看 $b_i$ 是否全部大于等于 $a_i$ 即可。上面的区间加等差数列的操作如果用线段树等数据结构维护的话复杂度会让 `check` 的时间复杂度为 $\mathcal{O}(n\log n)$，总体时间复杂度有两只 $\log$（二分还有一个 $\log$），注意到只需要进行最后一次查询，直接差分然后做两次前缀和即可。

+ 时间复杂度 $\mathcal{O}(n\log w)$，$w$ 是值域。

```cpp
void add(int l,int r,ll x,ll d){
    if(l>r)return;
    t[l]+=x,s[l+1]+=d,s[r+1]-=d,t[r+1]-=x+d*(r-l);
}
bool chk(ll k){
    up(i,1,n+1)s[i]=t[i]=0;
    up(i,1,m){
        int x=max(1ll,b[i]-k),y=min(n*1ll,b[i]+k);
        add(x,b[i],k-(b[i]-x),1),add(b[i]+1,y,k-1,-1);
    }up(i,1,n)s[i]+=s[i-1];up(i,1,n)t[i]+=s[i];up(i,1,n)t[i]+=t[i-1];
    up(i,1,n)if(t[i]<a[i])return 0;
    return 1;
}
void slv(){
    n=read(),m=read();up(i,1,n)a[i]=read();up(i,1,m)b[i]=read();
    ll l=-1,r=inf;
    wi(l+1<r){
        int mid=l+r>>1;
        if(chk(mid))r=mid;
        else l=mid;
    }printf("%d\n",r);
}
```

---

## 作者：tsqtsqtsq0309 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P9519)

### 分析

由题可知，显然当 $k$ 的值逐渐增大时，每个员工产生的贡献也是逐渐增大的，对于这种具有单调性的条件，我们可以考虑运用二分答案进行求解。

首先确定二分范围：左边界显然是1，因为不可能不发工资或者让员工倒贴钱，~~即使某些专家依然在提倡付费上班~~。

对于右边界，当 $k$ 取 $\max a_i + n - 1$ 就可以保证满足每一个员工。

确定了二分边界，接下来需要思考的就是如何在 $O(n)$ 的时间内计算好每一个员工的贡献。

可以考虑用队列维护对当前位置有贡献的员工编号。

每当左移一个位置，产生的贡献值 $tmp \to tmp - |a|$，如果队列某个员工对后面的员工不再产生贡献了，将他（她）移出队列即可。

先顺序处理一遍，再逆序处理一遍即可，总的时间复杂度为 $O(n\log n)$。

具体细节请看代码……

### 代码

```c++
#include <iostream>
#include <algorithm>
#include <queue>
#define MAXN 1000005
#define MAXM 1000005
using namespace std; // 预处理
int n, m, l, r, mid, maxx, ans;
int a[MAXN];
bool b[MAXN]; // 记录当前位置是否可以产生贡献
long long f[MAXN], tmp; // f数组存储当前 k 值下每一个员工的贡献，tmp 记录各个对当前位置产生贡献的总和
queue <int> q; // 队列维护对当前位置产生贡献的员工编号
int read(){ // 快读
    int t = 1, x = 0;char ch = getchar();
    while(!isdigit(ch)){if(ch == '-')t = -1;ch = getchar();}
    while(isdigit(ch)){x = (x << 1) + (x << 3) + (ch ^ 48);ch = getchar();}
    return x * t;
}
bool check(int k){
    while(!q.empty())q.pop();tmp = 0;
    for(int i = 1 ; i <= n ; i ++)f[i] = 0; // 初始化
    for(int i = 1 ; i <= n ; i ++){
        tmp -= q.size(); // 更新当前位置贡献值
        if(!q.empty() && i - q.front() >= k)q.pop(); // 如果该员工对后面的员工不再产生贡献了，那么就将他（她）移出队列
        if(b[i] == true){tmp += k;q.push(i);} // 如果当前位置可以对其他位置产生贡献，那么将他（她）加入队列
        f[i] += tmp; // 储存当前位置贡献值
    }
    while(!q.empty())q.pop();tmp = 0; // 初始化
    for(int i = n ; i >= 1 ; i --){
        tmp -= q.size(); // 更新当前位置贡献值
        if(!q.empty() && q.front() - i >= k)q.pop(); // 如果该员工对后面的员工不再产生贡献了，那么就将他（她）移出队列
        if(b[i] == true){tmp += k;q.push(i);} // 如果当前位置可以对其他位置产生贡献，那么将他（她）加入队列
        f[i] += tmp; // 储存当前位置贡献值
        if(b[i] == true)f[i] -= k; // 需要注意的是，这时自身产生的贡献被计算了两次，所以需要减去 k
    }
    for(int i = 1 ; i <= n ; i ++) // 判断当前 k 值 是否符合题意
        if(f[i] < a[i])return false;
    return true;
}
int main(){
    n = read();m = read();
    for(int i = 1 ; i <= n ; i ++)a[i] = read();
    for(int i = 1 ; i <= m ; i ++){
        mid = read();b[mid] = true;
    }
    for(int i = 1 ; i <= n ; i ++)maxx = max(a[i], maxx);
    l = 1, r = maxx + n - 1; // 初始化二分左右边界
    while(l <= r){
        mid = l + r >> 1;
        if(check(mid) == true){
            ans = mid;r = mid - 1; // 如果当前 mid 值符合题意，那么更新 ans 值
        }else l = mid + 1;
    }
    cout << ans << endl;return 0; // 输出答案
} // 完结撒花～～
```



---

## 作者：Kedit2007 (赞：2)

我们发现直接求解不是很方便，考虑二分答案。


思考如何检验一个答案。假设我们已经知道了处于位置 $i$ 的员工所能获得的快乐值，考虑如何计算处于位置 $i + 1$ 的员工所能获得的快乐值。为了方便，记位置处于 $i$ 的员工的快乐之为 $h_i$。

不难发现，$h_{i + 1} - h_{i}$ 的值，即两个相邻员工的快乐值差可以被以下两种员工影响：

- 若从 $i \to i + 1$ 的过程中正在**靠近**这个员工，并且处于该员工的影响范围，则快乐值应**增加** $1$；
- 若从 $i \to i + 1$ 的过程中正在**远离**这个员工，并且处于该员工的影响范围，则快乐值应**减少** $1$。

这提醒我们，只需要分别记录这两种员工的数量，我们就可以通过 $h_i$ 推知 $h_{i + 1}$。

这样检验的思路就基本理清了：首先预处理出第一个员工的快乐值，接着向后递推。在向后递推的同时，记录有多少个处在范围内且正在远离或靠近的员工，用来生成下一个员工的快乐值。

具体实现方式比较多，这里采取一个差分的做法。对于答案 $k$ 和处于第 $i$ 个位置的员工，将 $i - k$ 的位置标记**加 $1$**，将 $i$ 的位置标记**减 $2$**，将 $i + k$ 的位置标记**加 $1$**。接着递推时标记的前缀和就是相邻员工快乐值的差。读者可以在此思考为何这种做法可行。

### 参考代码

仅提供检验函数。

```cpp
bool check(int r)
{
	int cur = 0, pre = 0;
	vector<int> arr(n + 1);
	
	// 预处理第一个员工的快乐值
	for (int i = 0; i < m; i++)
	{
		cur += max(0ll, r - (b[i] - 1));
	}
	
	for (int i = 0; i < m; i++)
	{
		int lb = b[i] - r, mb = b[i], rb = b[i] + r;
		arr[max(lb, 1ll)]++;
		if (mb <= n)
		{
			arr[mb] -= 2;
		}
		if (rb <= n)
		{
			arr[rb]++;
		}
	}
	
	for (int i = 1; i <= n; i++)
	{
		pre += arr[i];
		if (a[i - 1] > cur) return false;
		cur += pre;
	}
	return true;
}
```



---

## 作者：Crazyouth (赞：2)

**分析**

第一眼想到二分，针对每个人求出他最少需要多少工资才能到达期望开心值，取 $\max$ 就行。但是二分已经是 $n \log n$ 了，所以要保证判断当前 $k$ 是否满足应是 $O(1)$ 的。

考虑把式子改一改。先把所有人对当前人（设为 $i$）的贡献拆成在 $i$ 前面的和在 $i$ 后面的，再加上 $i$ 本身。$i$ 本身的贡献很好算，是否加工资就行。但是他前面的人就难算一点，可以看成 $i$ 前面加工资的人数乘当前的 $k$，减去前面人数的 $d$ 的和。进而把 $d$ 拆成 $i$ 减加工资的人的编号，然后就可以表示为 $\displaystyle\sum_{j=1}^i g_j\times j$，其中 $g_j$ 为 $j$ 是否加工资。然后再拿 $k\times\displaystyle\sum_{j=1}^i g_j$ 减去前面的式子，就做完了。后面的贡献同理就行了。至于前面加工资的人的个数与前面加工资的人的编号和，用前缀和与后缀和维护即可。

**AC Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
int a[N],g[N],spos[N],sn[N],epos[N],en[N],k[N],n,m;//原序列，是否加工资，前面加工资的人的个数，前面加工资的编号和，后面加工资的人数，后面加工资的编号和，每个人需要的k
int check(int t,int i)//判断加t工资能使第i人得到多少快乐值
{
	return t*(sn[i-1]-sn[max(0ll,i-t)])-((sn[i-1]-sn[max(0ll,i-t)])*i-(spos[i-1]-spos[max(0ll,i-t)]))+t*(en[i+1]-en[min(n+1,i+t)])-((en[i+1]-en[min(n+1,i+t)])*(n-i+1)-(epos[i+1]-epos[min(n+1,i+t)]));
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
	{
		int tp;
		cin>>tp;
		g[tp]=1;
	}
	for(int i=1;i<=n;i++)//预处理
	{
		spos[i]=spos[i-1];
		if(g[i]) spos[i]+=i;
		sn[i]=sn[i-1];
		if(g[i]) sn[i]++;
	}
	for(int i=n;i>0;i--)
	{
		epos[i]=epos[i+1];
		if(g[i]) epos[i]+=n-i+1;
		en[i]=en[i+1];
		if(g[i]) en[i]++;
	}
	for(int i=1;i<=n;i++)
	{
		int l=0,r=2e9;//r必须2e9,1e9都WA一个点
		int mid,ans;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(check(mid,i)+g[i]*mid<a[i]) l=mid+1;
			else r=mid-1,ans=mid;
		}
		k[i]=ans;
	}
	int maxx=-1;
	for(int i=1;i<=n;i++) maxx=max(maxx,k[i]);//k的最大值
	cout<<maxx;
	return 0;
}

---

## 作者：sbno333 (赞：2)

我们先思考这道题，在思考时，我们或许可以想出当 $k$ 确定时，是否能满足良心员工的期望，时间复杂度 $O(n)$。

当然，有些人没想出来，所以方法如下：

先算出从左往右数第 $1$ 个员工如果只受自己或右边员工影响的期望以及受多少员工影响：
```cpp
for(long long i=1;i<=min(n,k);i++){
		if(b[i]){//b[i]=1表示该员工能获得工资
			an+=k-i+1;//收到k-i+1点影响
			sum++;
		}
	}
```
接下来我们一个员工一个员工的推，每到下一个员工，就寻找有没有新的收到影响的来源，并查看上一个员工是不是工资获得者，如果是，则我们这个员工相比前一个快乐减去 $k$，之后加上受到影响的~~源工~~源员工的数量，因为除了与上一个员工因上一个员工收到的影响消失外，其它的影响全部加 $1$（能收到影响）。
```cpp
	an=0;
	sum=0;
	for(long long i=1;i<=min(n,k);i++){
		if(b[i]){
			an+=k-i+1;
			sum++;
		}
	}
	c[1]=an;//c[i]表示第i名员工只看左边的快乐值
	for(long long i=2;i<=n;i++){
		if(b[i-1]){
			an-=k;
			sum--;
		}
		if(b[(i+k-1<=n?i+k-1:0)]){//避免越界
			sum++;
		}
		an+=sum;
		
		c[i]=an;
	}
```
接下来，我们用同样的办法计算左边，然后加起来。

现在可以判断了么？不！

对于每一名有工资的员工，他会被多计算，因为我们算的是包括自己以及一边的员工，自己会被算两遍，所以要减一次自己。

```cpp
bool pd(long long k){
	long long an;
	long long sum;
	an=0;
	sum=0;
	for(long long i=1;i<=min(n,k);i++){
		if(b[i]){
			an+=k-i+1;
			sum++;
		}
	}
	c[1]=an;
	for(long long i=2;i<=n;i++){
		if(b[i-1]){
			an-=k;
			sum--;
		}
		if(b[(i+k-1<=n?i+k-1:0)]){
			sum++;
		}
		an+=sum;
		
		c[i]=an;
	}
	an=0;
	sum=0;
	for(long long i=n;i>=max(n-k+1,(long long)1);i--){
		if(b[i]){
			an+=i-n+k;
			sum++;
		}
	}
	c[n]+=an;
	if(b[n]){
			c[n]-=k;
		}
	if(c[n]<a[n]){
		return 0;
	}
	for(long long i=n-1;i>=1;i--){
		if(b[i+1]){
			an-=k;
			sum--;
		}
		if(b[(i-k+1>=1?i-k+1:0)]){
			sum++;
		}
		an+=sum;
		if(b[i]){
			c[i]-=k;
		}
		c[i]+=an;
		if(c[i]<a[i]){//a[i]表示期望快乐，如果不达标，返回0
		return 0;
	}
	}
	return 1;
}
```

之后就是重头戏，我们的 $k$ 是未知的，因此如果是暴利的话，我们需要枚举 $k$，但其实并不需要，我们可以二分答案来得到答案，而二分的时间复杂度低，因此我们能勉强挤进时限。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long a[1000009];
bool b[1000009];
long long c[1000009];
bool pd(long long k){
	long long an;
	long long sum;
	an=0;
	sum=0;
	for(long long i=1;i<=min(n,k);i++){
		if(b[i]){
			an+=k-i+1;
			sum++;
		}
	}
	c[1]=an;
	for(long long i=2;i<=n;i++){
		if(b[i-1]){
			an-=k;
			sum--;
		}
		if(b[(i+k-1<=n?i+k-1:0)]){
			sum++;
		}
		an+=sum;
		
		c[i]=an;
	}
	an=0;
	sum=0;
	for(long long i=n;i>=max(n-k+1,(long long)1);i--){
		if(b[i]){
			an+=i-n+k;
			sum++;
		}
	}
	c[n]+=an;
	if(b[n]){
			c[n]-=k;
		}
	if(c[n]<a[n]){
		return 0;
	}
	for(long long i=n-1;i>=1;i--){
		if(b[i+1]){
			an-=k;
			sum--;
		}
		if(b[(i-k+1>=1?i-k+1:0)]){
			sum++;
		}
		an+=sum;
		if(b[i]){
			c[i]-=k;
		}
		c[i]+=an;
		if(c[i]<a[i]){
		return 0;
	}
	}
	return 1;
}
int main(){
	cin.sync_with_stdio(0);
	cin>>n>>m;
	for(long long i=1;i<=n;i++){
		cin>>a[i];
	}	
	for(long long i=1;i<=m;i++){
		long long bb;
		cin>>bb;
		b[bb]=1;
	} 
	long long l,r;
	l=1;
	r=2e9;
	while(l<r){
		long long mid;
		mid=(l+r)/2;
		if(pd(mid)){
			r=mid;
		}else{
			l=mid+1;
		}
	}
	cout<<r;
	return 0;
}
```

---

## 作者：言琢დ (赞：1)

答案满足单调性，一眼二分。

考虑如何 check：

本身就是一个二阶差分的过程。

总共要执行的操作形如：

$$[+3~+4~+5~+4~+3~+2~+1~\cdots\cdots]$$

第一阶差分数组：

$$[+1~+1~+1~\cdots~+1~-1~-1~-1~\cdots\cdots]$$

第二阶差分数组则只需要对 $+1$ 区间和 $-1$ 区间进行区间修改即可。

那么考虑边界问题如何处理：

当被修改的区间为 $[l,r]$ 时：

- 若 $l<1$，则对于第 0 阶数组是从 $1$ 号位置开始做加法

- 若 $r>n$，则表明做到 $n$ 以后就不用再继续修改（因为已经没有必要）

所以代码实现可以设计一个变量 $c1$，表示当前 $1$ 号位对应的一阶差分数组，最后需要加多少

注意这句话 `c[1] += c1` 一定要放在整个一阶差分之后才进行

具体可以参见代码：

```cpp
bool check(int mid){
	ch1 = 0;
	for (int i = 1; i <= n; ++i)
		CH[i] = ch[i] = s[i] = 0;
	for (int i = 1; i <= m; ++i) {
		int l = b[i] - mid + 1;
		if (l < 1) ch1 += 1 - l, ++CH[1];
		else ++CH[l];
		--CH[b[i] + 1];
		
		int r = b[i] + mid;
		--CH[b[i] + 1];
		if (r + 1 <= n) ++CH[r+1];
	}
	for (int i = 1; i <= n; ++i)
		ch[i] = ch[i-1] + CH[i];
	ch[1] += ch1;
	bool flag = true;
	for (int i = 1; i <= n && flag; ++i) {
		s[i] = s[i-1] + ch[i];
		flag &= (s[i] >= a[i]);
	}
	return flag;
}
```

其中 `s` 是原数组，`ch` 是一阶差分数组，`CH` 是二阶差分数组。

下面完整代码中，我给出了两种实现方式。

利用 `rebuild`（对一阶差分数组进行区间修改）和 `fa_gong_zi` 可以少处理一些边界问题，推荐使用。

使用方法很简单，只需要将上面代码里 `for (i = 1 ... m)` 的部分，里面的那一堆东西换成一句 `fa_gong_zi(b[i], mid)` 即可（表示给编号为 $b_i$ 的员工发 $mid$ 块工资）



```cpp
#include<cstdio>
#define int long long
int init(){
	char c = getchar();
	int x = 0, f = 1;
	for (; c < '0' || c > '9'; c = getchar())
		if (c == '-') f = -1;
	for (; c >= '0' && c <= '9'; c = getchar())
		x = (x << 1) + (x << 3) + (c ^ 48);
	return x * f;
}
void print(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
const int N = (int) 1e6 + 5;
int n, m, a[N], b[N], s[N << 1], ch[N << 1], CH[N << 1], ch1;
/*void rebuild(int l, int r, int val){
	if (l < 1) ch1 += val * (1-l), CH[1] += 1;
	else CH[l] += val * 1;
	if (r+1 <= n) CH[r+1] -= val * 1;
}
void fa_gong_zi(int i, int k){
	rebuild(i-k+1, i, +1);
	rebuild(i+1, i+k, -1);
}*/
bool check(int mid){
	ch1 = 0;
	for (int i = 1; i <= n; ++i)
		CH[i] = ch[i] = s[i] = 0;
	for (int i = 1; i <= m; ++i) {
		int l = b[i] - mid + 1;
		if (l < 1) ch1 += 1 - l, ++CH[1];
		else ++CH[l];
		--CH[b[i] + 1];
		
		int r = b[i] + mid;
		--CH[b[i] + 1];
		if (r + 1 <= n) ++CH[r+1];
	}
	for (int i = 1; i <= n; ++i)
		ch[i] = ch[i-1] + CH[i];
	ch[1] += ch1;
	bool flag = true;
	for (int i = 1; i <= n && flag; ++i) {
		s[i] = s[i-1] + ch[i];
		flag &= (s[i] >= a[i]);
	}
	return flag;
}
signed main(){
	n = init(), m = init();
	for (int i = 1; i <= n; ++i)
		a[i] = init();
	for (int i = 1; i <= m; ++i)
		b[i] = init();
	int l = 1, r = (int) 2e9;
	while (l < r - 5) {
		int mid = (l + r) >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	for (int i = l; i <= r; ++i)
		if (check(i)) {
			print(i), putchar('\n');
			break;
		}
}
```

---

## 作者：cosf (赞：1)

## [P9519](https://www.luogu.com.cn/problem/P9519)

## 思路

看到数据范围，容易想到这道题需要 $O(n\log n)$ 的做法，而不是 $O(n\log a)$，其中 $a$ 是 $a_1, \dots a_n$ 的量级。

显然，我们可以对于每一个员工进行二分，选出最大的 $k$ 作为输出。

具体怎么二分呢？

注意，一共有 $n$ 个员工，二分复杂度为 $O(\log n)$，所以单次判断需要 $O(1)$。

我们可以发现，当 $k \ge n$ 时，每一个员工都会受到每一个有工资的员工的影响，而当 $k \lt n$ 时只会受到左边 $k$ 个和右边 $k$ 个的影响。

所以可以先判断当 $k = n$ 的时候这个 $k$ 是否合适，如果太少了就直接算，免去二分，而当这个 $k$ 足够时再二分。

具体怎么判断一个 $k$ 是否满足呢？我们可以利用前缀和（和后缀和）。

我们令 $se_i$ 表示 $1$ 到 $i$ 中有多少人能拿工资，$ee_i$ 表示 $i$ 到 $n$ 中有多少人拿工资。$sp_i$ 表示 $1$ 到 $i$ 中能拿工资的人的编号和，$ep_i$ 表示 $i$ 到 $n$ 中能拿工资的编号和。那么假设对于任意一个员工 $p$，以及一个 $k \le \min\{p - 1, n - p\}$，可以证明当依以下不等式成立时 $k$ 是足够的：

$$
k(se_{p+k}-se_{p - k - 1}) \ge a_p + sp_{p + k} - sp_p - p(se_{p+k}-se_p) + ep_{p-k}-ep_p - (n-p+1)(ee_{p-k}-ee_p)
$$

呃呃，这太复杂了，还是讲一下吧。

首先，左边的部分就是能够影响 $p$ 的快乐值的人得到的工资之和。右边的 $a_p$ 就是他想要得到的快乐值，而减去的那一堆东西其实就是原题中 $\max\{k - d, 0\}$ 中减去的 $d$ 的和，分为左边的一部分和右边的一部分。

那么有了这个式子，我们就可以写出代码了。

## 代码

```cpp
#include <iostream>
using namespace std;

#define MAXN 1000006

#define int long long

int nd[MAXN]; // 原题中的 a
int gp[MAXN]; // 能否发工资
int sp[MAXN]; // 上面的几个前缀后缀和
int se[MAXN];
int ep[MAXN];
int ee[MAXN];

int n, m;

bool chk(int p, int k) // 注意还要判断一下边界
{
    int rm;
    if (p + k <= n)
    {
        rm = sp[p + k] - sp[p] - (se[p + k] - se[p]) * p;
    }
    else
    {
        rm = sp[n] - sp[p] - (se[n] - se[p]) * p;
    }
    int lm;
    if (p > k)
    {
        lm = ep[p - k] - ep[p] - (ee[p - k] - ee[p]) * (n - p + 1);
    }
    else
    {
        lm = ep[1] - ep[p] - (ee[1] - ee[p]) * (n - p + 1);
    }
    return k * (se[min(n, p + k)] - se[max(0ll, p - k - 1)]) - lm - rm >= nd[p];
}

signed main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", nd + i);
    }
    int g;
    for (int i = 1; i <= m; i++)
    {
        scanf("%d", &g);
        gp[g] = 1;
    }
    for (int i = 1; i <= n; i++)
    {
        sp[i] = sp[i - 1] + gp[i] * i;
        se[i] = se[i - 1] + gp[i];
    }
    for (int i = n; i; i--)
    {
        ep[i] = ep[i + 1] + gp[i] * (n - i + 1);
        ee[i] = ee[i + 1] + gp[i];
    }
    int mk = 0;
    for (int i = 1; i <= n; i++)
    {
        int l = 0, r = max(n - i, i - 1);
        if (chk(i, r))
        {
            while (l < r)
            {
                int mid = (l + r) >> 1;
                /*
                 * This:
                 *      /--k--\  /--k--\
                 * ----|______|i|______|-----
                 */
                if (chk(i, mid)) // ok, its enough
                {
                    r = mid;
                }
                else
                {
                    l = mid + 1;
                }
            }
            mk = max(mk, r);
        }
        else
        {
            // Its not enough even the pay is higher than the distance
            int rm = sp[n] - sp[i] - (se[n] - se[i]) * i;
            int lm = ep[1] - ep[i] - (ee[1] - ee[i]) * (n - i + 1);
            int ndi = nd[i] + rm + lm;
            if (ndi % m == 0)
            {
                mk = max(mk, ndi / m);
            }
            else
            {
                mk = max(mk, ndi / m + 1);
            }
        }
    }
    cout << mk << endl;
    return 0;
}

```


---

## 作者：信息向阳花木 (赞：1)

二分水题。

我们记：

* $cnt_i$ 表示前 $i$ 个人中有工资的人数
* $tot_i$ 表示后 $i$ 个人中有工资的人数
* $s_i$ 表示前 $i$ 个人中有工资的人的下标和
* $f_i$ 表示后 $i$ 个人中有工资的人的下标和

一个下标为 $i$ 的人 到所有下标小于等于 $i$ 的有工资的人的距离和为 $i \times cnt_i - s_i$，到所有下标大于等于 $i$ 的有工资的人的距离和为 $f_i - i \times tot_i$。

但是一个人的快乐值为 $\max\{0, k - d\}$。也就是说，当距离 $d > k$ 时，这个人对快乐值没有贡献。所以我们只需要考虑 $i - k$ 到 $i + k$ 之间的人有没有拿工资就行了。

因此 $i$ 到对自己快乐值有贡献的可以拿工资的人的距离和 $dist_i$ 为 $i \times (cnt_i - cnt_{\max\{0, i - k\}}) - (s_i - s_{\max\{0, i - k\}}) + f_i - f_{\min\{n + 1, i + k\}} - (tot_i - tot_{\min\{n + 1, i + k\}}) \times i$。

知道了 $i$ 的距离和，$i$ 的快乐值便为 $(cnt_i - cnt_{\max\{0, i - k\}} + tot_{i + 1} - tot_{\min\{n + 1, i + k\}}) \times k - dist_i$。其中和 $k$ 相乘的那坨式子便是对 $i$ 的快乐值有贡献且可以拿工资的人数。

我们二分 $k$，判断每个人的快乐值是否大于等于 $a_i$ 即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define int long long

const int N = 1000010;

inline void in(int &x)
{
	x = 0; bool f = 0; char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = 1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = (x << 3) + (x << 1) + (c & 15);
		c = getchar();
	}
	x = f ? -x : x;
}

inline void out(int x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x / 10) out(x / 10);
	putchar((x % 10) | 48);
}

int n, m, k, last;
int a[N], b[N], dist[N], s[N], f[N], cnt[N], tot[N];
bool st[N];

bool check(int k)
{
	for (int i = 1; i <= n; i ++ )
	{
		dist[i] = i * (cnt[i] - cnt[max(0ll, i - k)]) - (s[i] - s[max(0ll, i - k)]);
		dist[i] += f[i] - f[min(n + 1, i + k)] - (tot[i] - tot[min(n + 1, i + k)]) * i;
	}
	for (int i = 1; i <= n; i ++ )
	{
		int sum = cnt[i] - cnt[max(0ll, i - k)] + tot[i + 1] - tot[min(n + 1, i + k)];
		if(sum * k - dist[i] < a[i]) return 0;
	}
	return 1;
}

signed main()
{
	in(n); in(m);
	for (int i = 1; i <= n; i ++ ) in(a[i]);
	for (int i = 1; i <= m; i ++ ) { in(b[i]); st[b[i]] = 1; }
	for (int i = 1; i <= n; i ++ )
	{
		cnt[i] = cnt[i - 1] + st[i];
		if(st[i]) s[i] = s[i - 1] + i;
		else s[i] = s[i - 1];
	}
	for (int i = n; i >= 1; i -- )
	{
		tot[i] = tot[i + 1] + st[i];
		if(st[i]) f[i] = f[i + 1] + i;
		else f[i] = f[i + 1];
	}
	
	int l = 0, r = 100000000000000;
	while (l <= r)
	{
		int mid = l + r >> 1;
		if(check(mid)) r = mid - 1;
		else l = mid + 1;
	}
	printf("%lld\n", l);
		
	return 0;
}
```

---

## 作者：happy_zero (赞：1)

元素 $i$ 能被贡献的范围在 $\max(1,i-k)$ 到 $\min(n,i+k)$ 之间，直接求 $k$ 不好求，而 $k$ 又满足单调性，所以二分 $k$，接着考虑如何判断答案是否可行。

首先要枚举 $a_1$ 到 $a_n$，这里需要快速计算每个位置的快乐值，线段树/树状数组可以做到 $\log$ 复杂度，但是还有一种更快、更简单的方法，以计算 $a_i$ 的高兴值为例：

前文说到，贡献的范围在 $[l,r]$ 之间（$l=\max(1,i-k),r=\min(n,i+k)$），这样的好处是可以拆掉贡献中的 $\max$（因为 $k-d$ 一定大于等于 $0$），接下来把贡献化简（这里的 $\sum$ 指的是范围中所有有发工资的员工）：
$$\sum_{j=l}^r(k-d)=\sum_{j=l}^r(k-\left|i-j\right|)=\sum_{i=l}^rk-\sum_{j=l}^i(i-j)-\sum_{j=i+1}^r(j-i)$$ 

这个式子可以预处理 $s1,s2$ 表示发工资的员工数量、发工资的员工编号的前缀和 $O(1)$ 计算，总时间复杂度 $O(n\log W)$。

注意事项：

1. 不开 `long long` 见祖宗
2. 二分的范围不是 $\max\{a_i\}$，要开大一点。

```cpp
#include <bits/stdc++.h>
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 5; 
inline int read() {
    int w = 1, q = 0; char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') w = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') q = q * 10 + ch - '0', ch = getchar();
    return w * q;
}
void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
int n, m, a[N], s1[N], s2[N], Zero = 0;
bool chk(int x) { 
	for (int i = 1; i <= n; i++) {
		int s = s1[i] - s1[max(Zero, i - x - 1)], ss = s2[i] - s2[max(Zero, i - x - 1)];
		int S = s1[min(n, i + x)] - s1[i], SS = s2[min(n, i + x)] - s2[i];
		if (a[i] > s * x - (s * i - ss) + S * x - (SS - S * i))  return 0;
	}
	return 1;
}
signed main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1, x; i <= m; i++)
		x = read(), s1[x] = 1, s2[x] = x;
	for (int i = 1; i <= n; i++) s1[i] += s1[i - 1], s2[i] += s2[i - 1];
	int l = 0, r = 1000000000000, ans = 0;
	while (l <= r) {
		int mid = l + r >> 1;
		if (chk(mid)) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	write(ans);
	return 0;
} 
```

---

## 作者：Night_sea_64 (赞：1)

明显通过题目可以看出~~或者你结合生活常识也行~~，$k$ 越大，快乐值越大。当 $k$ 较小时，不能满足要求。当 $k$ 达到某个值之后，就可以满足要求了。这样的问题具有**二分性**。我们可以二分答案。这时我们已经有了一个 $k$，需要检查它满不满足要求。

以下的 $f_x$ 意思是：如果第 $x$ 个人被发了工资，$f_x=1$，否则 $f_x=0$。如果对于第 $i$ 个人，他能获得的总快乐值为：

$$\sum\limits_{j=1}^nf_j\times\max(0,k-|i-j|)$$

去掉绝对值：

$$\left(\sum\limits_{j=1}^{i-1}f_j\times\max(0,k-(i-j))\right)+\left(\sum\limits_{j=i+1}^nf_j\times\max(0,k-(j-i))\right)+f_i\times k$$

再去掉 $\max$。以刚才式子的第一个括号内的内容为例，如果 $k<i-j$，移项完变成 $j<i-k$，就不做了。

$$\left(\sum\limits_{j=\max(1,i-k)}^{i-1}f_j\times(k-i+j)\right)+\left(\sum\limits_{j=i+1}^{\min(n,i+k)}f_j\times (k-j+i)\right)+f_i\times k$$

现在我们可以看到，$f_j\times j$ 和 $f_j$ 都可以通过前缀和或后缀和维护。$k,i$ 是定值，求出 $f_j$ 的和再乘一下就可以得到。

---

## 作者：Argvchs (赞：1)

## 1. 题解

一眼二分答案，然后考虑如何快速判断当前 $k$ 满足题意。

首先把一个位置左右两边的贡献拆开，这样就不需要考虑绝对值了。

对于左边的贡献，我们从左到右扫一遍，维护一个队列和一个 $\mathrm{sum}$，$\mathrm{sum}$ 表示当前位置 $i$ 左边的贡献，队列表示这些贡献的位置。

每次 $i$ 向后移动，$\mathrm{sum}$ 减去队列长度，并且弹出队列中 $k - d \le 0$ 的元素。

右边的贡献同理，算完贡献后和 $a_i$ 比较即可。

时间复杂度 $O(n \log V)$，$V$ 为值域。

## 2. Code

```cpp
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], b[N];
long long l, r = 1e10, c[N], sum, cnt;
bool vis[N];
queue<int> Q;
bool check(long long k) {
    memset(c, 0, sizeof(c));
    sum = cnt = 0, Q = {};
    for (int i = 1; i <= n; i++) {
        sum -= cnt;
        if (cnt && k - (i - Q.front()) == 0) Q.pop(), --cnt;
        if (vis[i]) Q.push(i), ++cnt, sum += k;
        c[i] += sum;
    }
    sum = cnt = 0, Q = {};
    for (int i = n; i >= 1; i--) {
        sum -= cnt;
        if (cnt && k - (Q.front() - i) == 0) Q.pop(), --cnt;
        c[i] += sum;
        if (vis[i]) Q.push(i), ++cnt, sum += k;
    }
    for (int i = 1; i <= n; i++)
        if (c[i] < a[i]) return false;
    return true;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i], vis[b[i]] = true;
    while (l < r) {
        long long mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l;
    return 0;
}
```

---

## 作者：COsm0s (赞：0)

## $\mathcal{Solution}$

看到最值问题，很自然想到二分答案。

所以我们考虑的就是如何在 $\Theta(n)$ 的时间内判断是否合法。

+ 首先我们观察 $60$ 分的暴力，我们枚举每一个发工资的员工，然后左右枚举“快乐值”累加，此时复杂度是 $\Theta(nm)$ 的。

+ 然后我们发现这样的方法累赘的地方很多。最明显的就是于中心点（即发工资的人）向两边单调递减，且相邻两项差值为 $1$。

+ 考虑运用这个性质。由于中心点两边对称，所以我们可以分开计算一个员工左右的贡献。

	那么我们先只考虑右边。
    
   对于两个相邻的点 $i,i+1$，
   
   + 如果 $i$ 右边 $k$ 距离内所有的中心点同时也是 $i+1$ 右边 $k$ 距离内所有的中心点，那么根据刚刚的递减性质，我们发现这些点对 $i+1$ 的贡献恰好比对 $i$ 的贡献多 $sum$，其中 $sum$ 为合法中心点的个数。
   
   + 反之，由于两者相邻，只需要特判 $i+k+1$ 和 $i$ 本身即可。
   
  同样，左边只需要逆序，答案也出来了。
  
  这里要注意，要将本身的贡献减去，否则会重复，得到 $80$ 分的好成绩。
  
  最后与初始的 $a_i$ 进行比较，`check` 函数就完成了。
  
+ 这样，我们就在 $\Theta(n)$ 的时间内求出了答案，满足了题意。总复杂度 $\Theta(n\log n)$。

## $\mathcal{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;
int a[N], b[N], c[N];
int n, m, x;
bool check(int k) {
	int s = 0, sum = 0;
	for (int i = 1; i <= min(k + 1, n); i ++) if (b[i]) s += k - i + 1, sum ++;
	c[1] = s;
	for (int i = 2; i <= n; i ++) {
		if (b[i - 1]) s -= k, sum --;
		s += sum;
		if(i + k <= n) if (b[i + k]) sum ++;
		c[i] = s;
	}
	s = sum = 0;
	for (int i = n - 1; i >= n - min(k, n); i --) if (b[i]) s += k - n + i, sum ++;
	c[n] += s;
	for (int i = n - 1; i; i --) {
		if (b[i]) s -= k - 1, sum --;
		s += sum;
		if(i - k > 0) if (b[i - k]) sum ++;
		c[i] += s;
	}
	for (int i = 1; i <= n; i ++) {
		if (a[i] > c[i]) return 0;
	}
	return 1;
}
signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; i ++) cin >> a[i];
	for (int i = 1; i <= m; i ++) cin >> x, b[x] = 1;
	int l = 0, r = 2e9, ans = 0;
	while (l <= r) {
		int mid = l + r >> 1;
		if (check(mid)) r = mid - 1, ans = mid;
		else l = mid + 1;
	}
	cout << ans << '\n';
	return 0;
}
```


---

## 作者：AC_CSP (赞：0)

[$\text{题目传送门}$](https://www.luogu.com.cn/problem/P9519)

[$\text{或许更好的阅读体验}$](https://www.luogu.com.cn/blog/481527/solution-p9519)

## $\text{题目大意}$

给你一个长度为 $n$ 的序列 $a$，长度为 $m$ 的序列 $b$，请你找到一个最小的 $k$，使得 $\forall 1\le i\le n$，都有 $a_i\le\sum\limits_{j=1}^m \max(0,k-|b_j-i|)$。$n,m\le10^6$。

## $\text{Solution}$

容易想到二分。

不妨暴力处理每一个二分到的 $k$。发现事实上是在每个 $b_i$ 的两边个加上一个公差为一的等差数列，由此想到差分。然而这样还需要写一棵线段树，单次检查时间复杂度 $\mathcal{O}(n\log n)$。难写还过不去。发现再差分一次就是单次检查 $\mathcal{O}(n)$ 的了。

那么我们来探究一下二次差分的性质，以 $k=2$，$b_i=3$ 为例：

| $\text{原始数列}$ | $0$ | $1$ | $2$ | $1$ | $0$ | $0$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $\text{一次差分}$ | $0$ | $1$ | $1$ | $-1$ | $-1$ | $0$ |
| $\text{二次差分}$ | $0$ | $1$ | $0$ | $-2$ | $0$ | $1$ |

于是，我们只需要修改 $i-k+1$，$i+1$，$i+k+1$ 几个位置即可。

注意特判边界在序列左端之外的地方，因为这时二次差分的结果会发生改变，以 $k=2$，$b_i=1$ 为例：

| $\text{原始数列}$ | $2$ | $1$ | $0$ | $0$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $\text{一次差分}$ | $2$ | $-1$ | $-1$ | $0$ | 
| $\text{二次差分}$ | $2$ | $-3$ | $0$ | $1$ | 

我们只要给二次差分数组的第二项减去 $k-b_i$ 即可。

总时间复杂度 $\mathcal{O}(n\log n)$，可以通过此题。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+7;
int n,m;
int a[N],b[N];
int c[N],d[N];
int ans=2e9+7;
inline bool check(int k){
 for(int i=1;i<=n;i++)
  c[i]=0,d[i]=0;
 for(int i=1;i<=m;i++){
  int j=b[i];
  int l=max(1ll,j-k+1);
  int z=min(n+1,j+1);
  int r=min(n+1,j+k+1);
  d[l]+=(l-j+k);
  d[z]-=2;
  d[r]++;
  if(j-k+1<1){
   if(j==1)
	d[2]-=(l-j+k-1);
   else
    d[2]-=(l-j+k-1);
  }
 }
 for(int i=1;i<=n;i++)
  c[i]=c[i-1]+d[i];
 for(int i=1;i<=n;i++)
  c[i]=c[i-1]+c[i];
 bool ok=1;
 //cout<<k<<"\n";
 for(int i=1;i<=n;i++){
  if(a[i]>c[i]) ok=0;
  //cout<<c[i]<<" ";
 }
 //cout<<"\n";
 return ok;
}
signed main(){
 ios::sync_with_stdio(false);
 cin.tie(0),cout.tie(0);
 cin>>n>>m;
 for(int i=1;i<=n;i++)
  cin>>a[i];
 for(int i=1;i<=m;i++)
  cin>>b[i];
 int l=0,r=2e9,z;
 //check(11);return 0;
 while(l<=r){
  int z=l+r>>1;
  bool ok=check(z);
  if(ok) ans=min(ans,z),r=z-1;
  else l=z+1;
  //cout<<l<<" "<<z<<" "<<r<<"\n";
 }
 cout<<ans<<"\n";
 return 0;
}
```



---


# 【模板】二分图最大匹配

## 题目描述

给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。

左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n, m \leq 500$。
- $1 \leq e \leq 5 \times 10^4$。
- $1 \leq u \leq n$，$1 \leq v \leq m$。

**不保证给出的图没有重边**。


## 样例 #1

### 输入

```
1 1 1
1 1
```

### 输出

```
1```

## 样例 #2

### 输入

```
4 2 7
3 1
1 2
3 2
1 1
4 2
4 1
1 1
```

### 输出

```
2
```

# 题解

## 作者：lemir3 (赞：28)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11113535.html#autoid-0-0-0)

#什么是二分图?

>二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。------摘自百度百科

![配图1](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=dbf8c742e050352ab161220e6b789ccf/7a899e510fb30f24a3ac24f6c195d143ad4b0315.jpg)

#怎样判定二分图?

*以下内容摘自《算法竞赛进阶指南》*

存在如下定理:

>一张无向图是二分图,当且仅当图中不存在奇环(长度为奇数的环).

根据该定理,同志们可以以染色法进行二分图的判定.主体思想为:尝试用黑白两种颜色标记图中的结点,当一个结点被标记后,它的所有相邻结点应该被标记与它相反的颜色.若标记过程中产生冲突,则说明图中存在奇环.二分图染色一般基于DFS实现,时间复杂度为$O(n+m)$,伪代码如下:

```cpp

void dfs(int x,int color)
{
    赋值v[x] <-- color
    对于与x相连的每条无向边(x,y)
    if v[y]=0 then
        dfs(y,3-color)
    else if v[y]=color then
        判定无向图不是二分图,算法结束
}

在主函数中
    for i <-- 1 to n
        if(v[i]=0)then dfs(i,1)
    判定无向图是二分图

```

#二分图最大匹配

*以下定义摘自《算法竞赛进阶指南》*

"任意两条边没有公共端点"的边的集合被称为图的一组匹配.在二分图中,包含边数最多的一组匹配被称为二分图的最大匹配.

对于任意一组匹配$S$($S$是边集),属于$S$的边被称为"匹配边",不属于$S$的边被称为"非匹配边".匹配边的端点被称为"匹配点",其他结点被称为"匹配点".如果二分图中存在一条连接两个非匹配点的路径$path$,使得非匹配边与匹配边在$path$上交错出现,那么称$path$是匹配$S$的增广路,也称交错路.

有如下定理:

>二分图的一组匹配$S$是最大匹配,当且仅当图中不存在$S$的增广路.

配图如下:

![配图2.png](https://i.loli.net/2019/07/01/5d1981bb0de1144262.png)

![配图3.png](https://i.loli.net/2019/07/01/5d1981c16f34e79126.png)

![配图4.png](https://i.loli.net/2019/07/01/5d1981c18400350800.png)

如图,图2,图3(请不要联想到图波耶夫设计局)中红色的边就是图1的匹配,图3中红色的边为图1的最大匹配.

##匈牙利算法(增广路算法)

匈牙利算法,又称增广路算法,用于计算二分图最大匹配.

###引入

独立团战士们要发枪,每个战士都有自己想要的枪.关系如下:

![配图5.png](https://i.loli.net/2019/07/01/5d198eed1c5b339808.png)

开始分配:

![配图6.png](https://i.loli.net/2019/07/01/5d198eedaa4fc86330.png)

政委想要捷克式轻机枪,于是把捷克式轻机枪分给了政委.

![配图7.png](https://i.loli.net/2019/07/01/5d198eed9946118360.png)

团长这时说道:"好你他娘的赵政委,当几天政委还蹭鼻子上脸了是吧?老子就要用捷克式轻机枪."

政委想了想,反正咱百里赵刚用汉阳造也顺手,顺手拿来了汉阳造,轻机枪给了团长.

![配图8.png](https://i.loli.net/2019/07/01/5d198eed46c0b65755.png)

但是和尚也想用这把汉阳造,于是找政委商量.

政委:"关心小同志是咱当政委的职责,要不这样,这把汉阳造就拿给你用,我去找团长商量用轻机枪."

团长:"怎么?又打老子的轻机枪的主意?我看你和老子还有几天交情,轻机枪给你用,行了吧,读书人还真他娘的不讲理.这几天闲着没事,二营的那台意大利炮,老子拿来玩几天."

于是团长从二营拖来了意大利炮,政委用上了轻机枪,和尚拿到了汉阳造.

![配图9.png](https://i.loli.net/2019/07/01/5d198eed5b56786382.png)

二营长这就不乐意了,我堂堂张大~~喵~~彪,好不容易缴获的意大利炮,哪是个团长随随便便就能拿来玩的?

于是张大~~喵~~彪找到了团长.

团长:"去你他娘的二营长,老子官比你大,用你的炮怎么啦?老子把炮给你了老子用什么打仗?你让那小鬼子自个往我嘴里钻?我看你打仗天天摔帽子,那顶上次去边区领多了一顶帽子,你给老子拿去用."

于是张大~~喵~~彪分到了一顶帽子.

###主体思想

上面的过程就是一个标准的匈牙利算法.

匈牙利算法的思想就是寻找增广路,把增广路上的匹配状态全部取反,得到一个更大的匹配.

具体来说的话,可以以上面的第二幅图举例.

"李团长 --> 捷克式轻机枪 --> 赵政委 --> 汉阳造",这是匹配"赵政委 --> 捷克式轻机枪"的一条增广路,其中"李团长"和"汉阳造"为增广路连接的两个非匹配点.同志们把这条增广路上的所有边的匹配状态取反,原来政委拿到了轻机枪,取反之后变为没有拿到,原来团长没有拿到轻机枪,取反后拿到了轻机枪,原来政委没有拿到汉阳造,取反后拿到了汉阳造.

这样就得到了一个更大的匹配.

我们重复第二步,直到图中不存在增广路,就得到了最大匹配.

因为该算法最多遍历整个二分图一次,所以时间复杂度为$O(nm)$.

###具体实现

1. 设$S$为空集,即所有的边都是非匹配边.

2. 寻找增广路,把路径上的边全部取反,得到一个更大的匹配$S`$

3. 重复第二部,直到图中不存在增广路.

关于具体怎么寻找增广路,怎么给路径取反,我讲在代码中解释.

[*模板题*](https://www.luogu.org/problemnew/show/P3386)

**代码:**

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

struct edge
{
    int to,next;
}e[1000010];

int n,m,e_,size,ans;
int head[10010],match[10010];
bool flag[10010];

inline void EdgeAdd(int,int);
inline void Hungary();
inline bool find(int);

int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d%d",&n,&m,&e_);
    for(int _=1;_<=e_;_++)
    {
        int from,to;
        scanf("%d%d",&from,&to);
        if(from>n||to>m||from>m||to>n)
        {
            continue;
        }
        EdgeAdd(from,to);
    }
    Hungary();
    printf("%d\n",ans);
return 0;
}

inline void EdgeAdd(int from,int to)
{
    e[++size].to=to;
    e[size].next=head[from];
    head[from]=size;
}

inline void Hungary()
{
    for(int _=1;_<=n;_++)//枚举左集中的结点
    {
        memset(flag,false,sizeof(flag));
        if(find(_)==true)//存在一条增广路
        {
            ans++;
        }
    }
}

inline bool find(int from)
{
    for(int _=head[from];_!=-1;_=e[_].next)//遍历该结点的路径
    {
        int to=e[_].to;
        if(flag[to]==false)//flag数组防止往回走
        {
            flag[to]=true;
            if(match[to]==0||find(match[to])==true)
/*这里有两种情况,一种是右集中的点没有被选,那么它们俩构成长度为1的增广路.
另一种是右集中的点已经被选了,但是往下递归可以发现选它的点可以有其他的选择,这样构成了一条两端都是非匹配点的路径,即增广路.
*/
            {
                match[to]=from;//更改匹配
                return true;
            }
        }
    }
return false;
}

```


---

## 作者：hanyuwei (赞：18)

咳咳我十分不厚道的用网络流跑了一下二分图匹配

~~应该是NOIP2017前最后一次题解了~~

网络最大流的核心其实是建模，这道题中我们可以把每一条边的流量看做1，然后把0点作为源点，n+m+1点作为汇点，大概看起来如下图所示

 ![](https://cdn.luogu.com.cn/upload/pic/10676.png) 

（红色的表示新建的，黑色的表示原来的图）

然后我们用网络最大流跑一下，最终汇入汇点的流量其实就是二分图的最大匹配【可以思考一下哦，答案在代码最后】







    
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define inf 2147483647
using namespace std;
struct Edge
{
    int to;
    int s;
    int last;
}e[2001000];
int dep[4100],in[4100],cnt;
int s=0,t;
void addedge(int x,int y,int z)
{
    e[++cnt].last=in[x];
    e[cnt].s=z;
    e[cnt].to=y;
    in[x]=cnt;
}
bool bfs()
{
    memset(dep,0,sizeof(dep));
    queue<int> que;
    que.push(s);dep[s]=1;
    while(!que.empty())
    {
        int u=que.front();que.pop();
        for(int i=in[u];i>=0;i=e[i].last)
        {
            if(!dep[e[i].to]&&e[i].s>0)
            {
                dep[e[i].to]=dep[u]+1;
                que.push(e[i].to);
            }
        }
    }
    if(dep[t])    return true;
    else    return false;
}
int dfs(int now,int cur)
{
    if(now==t)    return cur;
    for(int i=in[now];i>=0;i=e[i].last)
    {
        if(dep[e[i].to]==dep[now]+1&&e[i].s>0)
        {
            int flow=dfs(e[i].to,min(cur,e[i].s));
            if(flow)
            {
                e[i].s-=flow;
                if(i&1)    e[i+1].s+=flow;
                else    e[i-1].s+=flow;
                return flow;
            }
        }
    }
    return 0;
}
int main()
{
    int n,m,e,i,l,x,y,ans=0;
    memset(in,-1,sizeof(in));
    scanf("%d%d%d",&n,&m,&e);t=n+m+1;
    for(i=1;i<=n;i++){addedge(0,i,1);addedge(i,0,0);}
    for(i=n+1;i<=n+m;i++){addedge(i,t,1);addedge(t,i,0);}
    for(i=1;i<=e;i++)
    {
        scanf("%d%d",&x,&y);if(x>n||y>m)    continue;
        addedge(x,y+n,1);addedge(y+n,x,0);
    }
    while(bfs())
    {
        while(l=dfs(s,inf))
            ans+=l;
    }
    printf("%d",ans);
    return 0;
}
【ans：每一次有流量汇入就是成功匹配啦】
```

---

## 作者：Mine_King (赞：10)

- **2020/5/4 upd：做了一些修改，把$vis$数组的详细用法写了一下。**

题目：[二分图匹配](https://www.luogu.org/problem/P3386)  
二分图匹配，就是解决 一群人，喜欢一类东西，然后求最多满足能满足多少人的问题。当然，东西是不同的，人的喜好也是不同的。  

这里讲一下匈牙利算法是如何解决这个问题的。
首先，我们画了一个图：  
![](https://i.loli.net/2019/11/07/C5qebotKdRxYvZ4.png)  
然后，我们对第一个人匹配，也就是找第一个人要的东西，然后就得到了下图（粉色代表匹配成功，也就是左边的人得到了右边的东西。草绿色代表遍历过但未成功）  
![](https://i.loli.net/2019/11/07/AnPUMuwEkOi6Im8.jpg)  
然后，我们跳过一大堆已知的操作，得到下图：  
![](https://i.loli.net/2019/11/07/7HPoM341QDZJFSw.jpg)  
这时，我们发现，3号人也想要二号物品，但是已经被1号人拿走了。这改怎么办办呢？我们发现，1号还能拿3号物品。于是，人1把物2给了人3，拿了物3。  
![](https://i.loli.net/2019/11/07/WbXcajEq5Jhe9GD.jpg)  
然后， 匹配4号。这时……人2占了物1，但人2不能拿别的东西了。于是乎，人2拒绝妥协，~~人4被人2暴打了一顿~~而人4匹配不了其他的，因为他对物品1情有独钟，不喜欢别的东西，so，他莫得东西了QwQ。

现在，所有的人都匹配完了，能拿到东西的最多有三个人，~~4号被抛弃了，还被暴打了一顿~~，最大匹配数也就是3。  

那么，具体思路讲完了，改怎么实现呢？  
很简单，我们逐个枚举人，$dfs(i)=1$表示匹配成功，否则失败。用$1$个$chos$数组，$chos_i$表示第$i$个物品被第$chos_i$个人拿走了，$vis$数组用来在判断一个人能否拿别的物品时用的。也就是做个标记，如果不做这个标记，那再判断这个人能否拿别的物品时他也许还会选择这个物品。（所以，每次$dfs$都要清空$vis$）$dfs$内部就是枚举他喜欢的每一个东西，如果这个东西没人要或要这个东西的人可以拿别的，这个东西就归他了，然后返回1。如果遍历完所有他想要的还得不到任何东西，就返回0。  
**$vis$数组要在每一次遍历的时候清空哦**

**上代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,e,ans;//e是边数，ans是答案
bool vis[100005];
int chos[100005];
struct node
{
	int tot;
	int dt[10000005],nxt[10000005];
	int hd[100005];
	void add(int x,int y)
	{
		tot++;
		nxt[tot]=hd[x];
		hd[x]=tot;
		dt[tot]=y;
		return ;
	}
}g;//链式前向星存图
bool dfs(int x)
{
	for(int i=g.hd[x];i;i=g.nxt[i])//枚举他喜欢的每一个东西
	{
		if(vis[g.dt[i]]) continue;//被判断过，就直接下一个循环
		vis[g.dt[i]]=1;//标记，如果不标记，后面的判断dfs(chos[g.dt[i]])就永远是真了。
		if(!chos[g.dt[i]]||dfs(chos[g.dt[i]]))//如果当前没人要这个东西或要这个东西的人还可以拿别的，那这个东西就是他的了
		{
			chos[g.dt[i]]=x;//标记这个东西归他了
			return 1;//返回true。
		}
	}
	return 0;//到遍历完还没得到东西，返回false
}
int main()
{
	scanf("%d%d%d",&n,&m,&e);
	for(int i=1;i<=e;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		if(u>n||v>m) continue;//题目中说有可能会出现u>n和v>m的情况
		g.add(u,v);//连边
	}
	for(int i=1;i<=n;i++)//枚举每个人
	{
		memset(vis,0,sizeof(vis));//清空vis
		ans+=dfs(i);//直接加就可以了，因为bool中true的值是1，false的值是0
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：StarLinkOvO (赞：5)

# [P3386【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)

## 写在前面

这是一篇匈牙利算法求二分图最大匹配的题解。

我会尽量写的详细一些好让大家都能看懂。\
所以会比较啰嗦，还请各位耐心看完。

图都是用鼠标画的，比较丑，还请多多包涵。

部分内容参考 oiwiki，之前学长上课用的课件与[这篇文章](https://blog.csdn.net/Here_SDUT/article/details/106390404)。

## What is 二分图？

二分图，又叫二部图。\
二分图由两个集合构成，且集合内部没有边相连。

如下图，有两个集合 $u$ 与 $v$，属于同一集合的两个点之间没有边相连，但是不在同一集合内的点是可以连边的。

![一个二分图](https://cdn.luogu.com.cn/upload/image_hosting/e3qy87el.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

换言之，存在一种方案，可以把点分为两个集合且满足以上条件。

## 二分图的性质

- 若我们将二分图的两个集合中的点分别染成黑色和白色，那么每一条边都连着一个黑色的点和一个白色的点。
- 二分图里不存在奇环。

第一条很好理解，我们还是观察上图，发现每一条边都连着两个颜色不同的点。\
当然我们从定义的角度出发，在同一集合内的点是不能连边的，故也不存在同时连接了两个颜色相同的点的边。

第二条，我们发现若想从一个集合出发再回到该集合，需要从这个集合出去再回来，这样的话就只能是偶数条边，故不可能存在奇环。

## 二分图的匹配

在二分图中选出一些边作为一个集合，使任意两条边不存在公共点，那么我们称其为一个匹配。

还是看图，这个就是一个匹配：

![匹配](https://cdn.luogu.com.cn/upload/image_hosting/z5skwvjv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

而在这张图里，我们发现有一些边是由公共点的，那它就不是一个匹配：

![非匹配](https://cdn.luogu.com.cn/upload/image_hosting/n1dk0p6r.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

同时二分图的边满足所连接的两个端点都属于不同的两个集合中。

本题让我们求解二分图的最大匹配，即让这个匹配的边数最多，那么此时这个图就是该二分图最大匹配。

![最大匹配实例](https://cdn.luogu.com.cn/upload/image_hosting/fgvfdaoq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## 二分图最大匹配的求解

求最大匹配之前，我们先了解一些概念。

### 交替路

> 从一个未匹配的点出发，依次经过未匹配边、匹配边、未匹配边、匹配边。。。这样的路线叫交替路。

### 增广路

> 从一个**未匹配**的点出发，走交替路，到达了一个**未匹配**的点，那么这条路就是增广路。

![增广路](https://cdn.luogu.com.cn/upload/image_hosting/dic8afm3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（黄色的是匹配点，粉色的是非匹配点同时是路的起点终点，绿色的是匹配边，黑色的是增广路上的非匹配边，灰色的边是其他边）\
不考虑灰色的边，剩余的边构成增广路，可以看着图走一走。

增广路性质总结：

- 增广路一定由奇数条边构成。
- 增广路的起点和终点都是未匹配点。
- 路径上的相邻的点不在同一集合内。
- 在增广路上，非匹配边一定比匹配边多一。

PS：最大匹配是不存在增广路的，否则可以通过翻转得到更大的匹配（后面会专门说这部分的证明）。

那么我们就可以利用这个性质去求解最大匹配。

### 匈牙利算法

匈牙利算法就是通过找增广路来求最大匹配。

也有人说它的思想本质就是网络流的（不过我不会网络流）。

那么匈牙利算法是怎么实现的呢？

如果想看有意思的解释请点[这里](https://blog.csdn.net/dark_scope/article/details/8880547)，我没那个实力就写写最普通的解释吧。。。

现在有一张二分图：

![二分图](https://cdn.luogu.com.cn/upload/image_hosting/vkfc1fdp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们要给他们尽量多的配对这样就能求出最大匹配了。

那么我们从 $A$ 点开始配对，让我看看。。。就 $1$ 吧！

同样地，我们也可以将 $B$ 与 $2$ 配对，那么这张图就变成了这样（涂黄的为匹配点，绿边为匹配边）：

![拼好饭，配好对](https://cdn.luogu.com.cn/upload/image_hosting/dc8pn4u9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

接着我们给 $C$ 配对，但是我们发现一个问题，它能配对的点 $1$ 已经有了配对，怎么办呢？

有了！我们看看 $A$ 能不能换一个不就行了。

于是，$A$ 去找了 $3$，现在 $C$ 就能愉快的与 $1$ 配对了！

（这一步就是在寻找增广路，$C$ 是一个未匹配点，那么若我们能够找到一条以它为起点的增广路：$C$-$1$-$A$-$3$，说明存在更大的匹配，这时我们将增广路翻转就有了更大的匹配）。

操作后如下图：

![恭喜C](https://cdn.luogu.com.cn/upload/image_hosting/214h5j1r.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

然后是 $D$，我们发现它想要的 $3$ 已经配对了，那么只好和 $A$ 商量能不能让它换一个。\
（同样是配对失败寻找增广路）。

但 $A$ 想配对的点已经都配好对了，于是 $D$ 遗憾离场。

（没有以 $D$ 为起点的增广路，$D$ 配对失败）。

然后就有这张二分图的最大匹配啦！

（结合前面我们说的，就是找不到增广路了，那么此时就有最大匹配）。

![最大匹配](https://cdn.luogu.com.cn/upload/image_hosting/69d7luy4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么答案就是 $3$。

### 正确性证明

> *Q：为什么用匈牙利算法求解二分图最大匹配是正确的呢？*

首先匈牙利算法是通过寻找增广路来寻找更大的匹配。

也就是说，如果我们用匈牙利算法求出了一个二分图的最大匹配，那么这个匹配里是没有增广路的。

此时问题转化为：**如何证明二分图的最大匹配中不存在增广路**。

我们回看上面最大匹配的图（我这里直接搬下来这样就不用来回翻了）：

![最大匹配实例](https://cdn.luogu.com.cn/upload/image_hosting/fgvfdaoq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（左图绿色为匹配边）\
应该是不会在上图找到增广路的，有的话可能是我图画错了。

还是看有增广路的图，我们此时不考虑灰色的边，当它不存在。

（黄色的是匹配点，粉色的是非匹配点，但同时是路的起点终点，绿色的是匹配边，黑色的是增广路上的非匹配边）

![增广路](https://cdn.luogu.com.cn/upload/image_hosting/dic8afm3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然这个匹配肯定不是最大匹配。

为什么？

用反证法。

我们先假设这个就是最大匹配，那么此时图上肯定不存在更大的匹配。

接下来证明这个假设是错误的。

也许你还记得增广路有这一条性质：

- 在增广路上，非匹配边一定比匹配边多一。

再结合增广路的定义，可以说增广路就是特殊的交替路。

此时我们就翻转一下。

即将匹配边变为非匹配边，非匹配边变为匹配边。

由于原来匹配边比非匹配边少一，那么翻转后就有匹配边比非匹配边多一。

翻转过后如图：

![翻转后的增广路](https://cdn.luogu.com.cn/upload/image_hosting/lx6pimhh.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这张图上存在更大的匹配，上面的假设不成立。

即二分图的最大匹配中不存在增广路。

证毕。

### 实现思路

首先要存图。

这里我用的是 `vector`。

连好边之后我们可以从每一个左部点出发寻找与他相连的右部点，都跑一遍匈牙利去匹配 or 找增广路。成功的话就 `ans++`。

怎么样是不是很简单？

然后我们就可以写出下面的代码：

```cpp
vector edge[MN]; //存图
int rec[MN]; //记录谁和谁匹配了

bool dfs(int x) {
    for (auto y : edge[x]) //遍历当前节点连的所有边（点）
        if (rec[y] == 0 || dfs(x)) { //边的另一端的点未匹配 or 找到了一条增广路
            rec[y] = x; //记录
            return true;
        }

    return false;
}

int main() {
    //略

    int ans = 0;
    for (int i = 1; i <= n; i++) //遍历所有左部点 
        if (dfs(x)) ans++;
}
```

然后。。。（没记错的话喜提 10pts）。

为什么？

> **不保证给出的图没有重边。**

难道我们就要放弃 `vector` 了吗？

**不。**

我们发现如果输入了重边，在遍历的时候都会从同一个点出发。

这句话听起来像是一句废话。。。\
但是我们可以利用这个根据每个左部点访问顺序给每一个右部点打上时间戳，如果当前轮次已经访问过了就直接返回 `false`。这样就避免了重边的影响。

由于我们遍历每一个左部点（有 $n$ 个）时再枚举与其相连的右部点（最多 $m$ 个），时间复杂度就是 $O(nm)$。

如果还是有疑惑的话，可以结合代码食用～

## 代码（不要直接跳到这里啊喂）

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, e, ans;
int tim[505]; //时间戳防重边
int rec[505]; //记录谁与谁配对
vector < int > edge[505]; //存边

bool dfs(int x, int t) { //当前节点, 时间戳
    if (tim[x] == t) return false; //当前轮次已访问直接返回

    tim[x] = t; //标记

    for (auto y : edge[x]) 
        //遍历到的右集合内节点未访问 or 可以找到增广路径
        if (rec[y] == 0 || dfs(rec[y], t)) {
            rec[y] = x; //匹配
            return true;
        }

    return false;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);

    cin >> n >> m >> e;
    for (int i = 1; i <= e; i++) {
        int x, y;
        cin >> x >> y;
        edge[x].push_back(y);
    }

    for (int i = 1; i <= n; i++)
        if (dfs(i, i)) ans++;

    cout << ans << endl;

    return 0;
}
```

---

## 作者：derderhaoyue (赞：5)

# 二分图最大匹配

## 序言

本题解使用了网络流算法解决二分图最大匹配问题，可能需要[前置知识（P3376）（点我前往）](https://www.luogu.com.cn/problem/P3376)，使用这种算法的原因是它拥有比常规使用的匈牙利算法更优的时间复杂度。

---

## 网络最大流解决二分图最大匹配问题

### 方法分析

我们需要通过建模方式将题目所给图构造成一张可以跑网络流算法求出最大流的图，并且这张图的最大流等于原图的最大匹配。
首先，根据题意，我们需要构造出一个超级源点和一个超级汇点来分别发送和接收流量。
然后，为了保证求得的最大流是最大匹配，我们需要将每个边的流量设置为 1（因为在二分图最大匹配中一个点至多连接一条边）。
最后，将所有左部点向超级源点连边，所有右部点向超级汇点连边，这样求得的最大流即是二分图的最大匹配。

---

### 正确性说明

如果这一条边有流量，则一定有一个左补点与一个右部点完成了匹配，反之，则没有完成匹配，因为我们将每一条边的流量设为了 1，因此，有多少流量即是有多少对完成匹配的点，即是有多少个匹配，因为我们在这张图上跑的是最大流，所以得到的就是这张图的最大匹配。

---

### 代码部分

~~现在，是代码时间！~~

本代码使用 Dinic 算法来跑网络最大流。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int M=5e4+5e3;
constexpr int INF=0x3f3f3f3f;
struct Edge{
    int to,next,val;
}edge[M*4];
int tot=1;
int head[M*4];
// 链式前向星存图，所有边权为 1。
void add(int u,int v,int val){
    edge[++tot].to=v;
    edge[tot].next=head[u];
    edge[tot].val=val;
    head[u]=tot;
}
int n,m,e;
int s,t;// 超级源点和超级汇点。
int now[M],dep[M];
int ans;
int bfs(){
    for(int i=1;i<=n+m+2;i++){
        dep[i]=INF;
    }
    queue<int> qu;
    qu.push(s);
    dep[s]=0;
    now[s]=head[s];// 源点的当前弧为自己的第一条边。
    while(!qu.empty()){
        int x=qu.front();
        qu.pop();
        for(int i=head[x];i;i=edge[i].next){
            int y=edge[i].to;
            if(edge[i].val&&dep[y]==INF){// 如果这个边有流量并且没访问过。
                qu.push(y);
                dep[y]=dep[x]+1;
                now[y]=head[y];// 初始化这个节点的当前弧为它的第一条边。
                if(y==t){
                    return 1;// 找到了汇点t，一条新的增广路诞生啦，返回 1。
                }
            }
        }
    }
    return 0;// 找增广路失败了，返回0。
}
int dfs(int u,int sum){
    if(u==t) return sum;// 找到了汇点，那就返回这条路上的最小剩余流量吧。
    int k,res=0;
    for(int i=now[u];i&&sum;i=edge[i].next){
        now[u]=i;
        int v=edge[i].to;
        if(edge[i].val>0&&(dep[v]==dep[u]+1)){// 这条边要能流过水必须得有剩余流量并且路是通的（节点之间深度差 1）。
            k=dfs(v,min(sum,edge[i].val));
            if(k==0){
                dep[v]=INF;// 这个点没有增广路了，那就把它的高度标记为无穷大，不再访问。
            }
            edge[i].val-=k;
            edge[i^1].val+=k;// 正向边减流量，反向边加流量。
            res+=k;// u节点出发找到的总流量加上找到的流量。
            sum-=k;// 当前路径上的剩余流量减去找到的增广路流量。
        }
    }
    return res;// 返回从u出发找到的总流量。
}
int main(){
    scanf("%d%d%d",&n,&m,&e);
    s=1;
    t=n+m+2;
    for(int i=1,u,v;i<=e;i++){
        scanf("%d%d",&u,&v);
        if(u<=n&&v<=m){
            add(u+1,v+n+1,1);
            add(v+n+1,u+1,0);// 正向边边权为 1，反向边为 0。
        }
    }
    for(int i=1;i<=n;i++){
        add(1,i+1,1);
        add(i+1,1,0);
    }
    for(int i=1;i<=m;i++){
        add(i+n+1,n+m+2,1);
        add(n+m+2,i+n+1,0);
    }
    int res;
    while(bfs()){
    while(res=dfs(s,INF))
        ans+=res;
    }   
    printf("%d",ans);
    return 0;
}
```

---

### 复杂度分析

观察代码，这段代码的复杂度是由增广轮数和单次增广的复杂度相乘而来，所以我们分别从在跑网络流时的增广轮数以及单轮增广的复杂度两方面来考虑这个解法的复杂度。

首先考虑增广轮数，因为至多会增广 $m$ 条边，所以增广轮数对于复杂度的影响为 $\Theta(m)$。

然后设每个点出边容量和是 $C^{in}$，出边容量和是 $C^{out}$，并定义 $T=\sum\min(C^{in},C^{out})$。
现在，我们分两种情况讨论：

1. 若在 $\sqrt{T}$ 轮中完成，则复杂度一定是 $\Theta(\sqrt{T})$ 的。
2. 若没能在 $\sqrt{T}$ 轮中完成，则假设还能找到 $d$ 条增广路，则一定可以找到一种在残量网络中取 $d$ 条不是增广路的路径的方案，这时这个图的最短路是 $\Theta(\frac{C}{d})$ 的，又因为增广路数量大于 $\sqrt{C}$，设 $x$ 为 $\Theta$ 的常数，则有 $x\sqrt{C}\le \frac{C}{d}$，解得 $d\le \frac{\sqrt{C}}{x}$，所以 $d=\Theta(\sqrt{C})$。所以最大增广轮数为 $\Theta(\sqrt{C})$，

综上，这种方法的时间复杂度为 $\Theta(m\sqrt{n})$。
（注意，这里跑二分图最大匹配所构造出来的图所有边权为 1，与一般情况下的图在跑网络最大流的时候复杂度有区别。）

---

## 作者：langmouren (赞：5)

# 网络流二分图最大匹配
## 前言
这篇题解使用了 Dinic 算法解决了二分图最大匹配问题，但是和其他题解不同的是，我们使用了神秘的 vector。

本片题解会浅略讲解 vector 如何使用在网络流上，以及网络流如何解决二分图最大匹配问题。

在阅读本题解之前，你需要了解[网络最大流](https://www.luogu.com.cn/problem/P3376)。

## vector 版网络流
vector 的难点是，其相对于链式前向星难以找到反边，所以我们应该为其找到一个 $id$ 进行标记，用什么来记录这个 $id$ 呢？答案是——数组大小！

我们约定 vector 数组 `vector<Node> v[MN]`。

可以发现，对于两个点 $a、b$，我们在从 $a$ 连向 $b$ 的时候存下 $b$ 的数组大小 $id$，再从 $b$ 连向 $a$，则 $b$ 连向 $a$ 这条边的下标就是 $id$，即 `v[b][v[a].id]` 就是 $b$ 到 $a$ 的边。

所以，我们可以写出 vector 加边的代码：

```cpp
void add(int a,int b,int k){
    int sza=v[a].size(),szb=v[b].size();
    v[a].push_back({b,k,szb});
    v[b].push_back({a,0,sza});
}
```

同时，我们也知道了，vector 的结构体中需要存储连向的边、流量、$id$ 三个内容。

## 网络流解决二分图最大匹配
我们设超级原点 $s$ 和 超级汇点 $t$。

将所有左部点和 $s$ 连接，将所有右部点和 $t$ 连接，流量均应为 $1$，然后再按照题目给出的关系连接左右部点，在本题中流量也应为 $1$。

需要注意，右部点应该加上一定偏移来保证其编号不与左部点重合，例如在本题中，左部点共有 $n$ 个，则右部点 $b$ 的编号应该设置为 $b+n$ 或更大。

最后从 $s$ 跑网络流，答案即为所求。

## 为什么这样建边是正确的
因为在网络流中有反边的存在，所以我们只需要从左部点连向右部点，它就会自然地进行类似匈牙利算法的不断向下 DFS 的操作。

而连接超级原点和超级汇点是为了防止有遗漏，匈牙利算法就是因为无法解决遗漏问题而不得不多次进行 DFS。

## 代码
请见[洛谷剪切板](https://www.luogu.com.cn/paste/qd4ykafa)。

如不能访问上面连接，也可以访问[洛谷保存站](https://www.luogu.me/paste/qd4ykafa)。

## 更新
$2025$ 年 $4$ 月 $27$ 日：更新文章格式。

---

## 作者：USER113968 (赞：4)

嗯，这是模板题，那么，在开始之前，先看几个名词。

**二分图**

通俗的来说，就是所有的点能分成两份，构成两个互不相交的顶点集合，每条边连接这两个集合里的点。

**增广路**

大概来说就是一条连接两个未匹配顶点的边，这两顶点连边后就互相匹配了。

---

好了好了，概(fei)念(hua)讲完了，就来看一看算法步骤吧：

1. 找到一个顶点，枚举它的每一条边。

2. 若该条边连接的另一顶点未匹配，直接与该顶点连线，匹配数+1。

3. 若对方已经匹配，尝试让那个点匹配的点找其他点连线。如果那个点找到别的点连线了，就立刻和这条边连接的点（此时它已经被遗弃了）连线。匹配数+1.

4. 还是不成功的话（那个点匹配的点找不到别的点连线），尝试下一条边。

5. 将上述步骤运用到每一个顶点，即可得出最大匹配。

这个过程我们可以递归实现。

这个概念比较抽象，我们看一组图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tlyorvuz.png)

嗯！一张标准的二分图，我分好了AB组。

![](https://cdn.luogu.com.cn/upload/image_hosting/pfvynqvm.png)

首先看A组第一个点的第一条边，发现对方没被匹配！那么直接匹配。（右边那个框是match数组，记录配对关系的）

![](https://cdn.luogu.com.cn/upload/image_hosting/kmw92cr6.png)

看A组2，发现它的第一条边连接的点也没人匹配，直接记上。

![](https://cdn.luogu.com.cn/upload/image_hosting/eyqtcafy.png)

到了A组三，还是没问题，一切都挺顺利的哈。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ptlhafq.png)

这下出问题了！A组4的第一条边连的B组1已经和A组1匹配了！肿么办？根据先前的算法步骤，我们应该让A组1找别人匹配。

![](https://cdn.luogu.com.cn/upload/image_hosting/2sllz8py.png)

再看A组1的第二条边，连接的是B组3，发现B组3也被配对了。按照算法步骤，我们应该让A组3找别人。不过A组3只能连B组3，找不到别人。我们只好看下一条边。

![](https://cdn.luogu.com.cn/upload/image_hosting/zovzbapz.png)

到了A组1的第四条边，我们发现，连的B组4没和别人匹配！那就可以直接连线啦！

接下来，原先的B组1就被遗弃了。而这一切事情的起源：A组4就愉快地和B组1匹配了。

emmmm······~~好像比较简单哈~~

那么怎么存储二分图呢？事实上，我这个蒟蒻只会邻接矩阵，所以，A组人员正常存储，B组成员的下标直接改为$B_i+N_A (N_A)$是A组成员的数量。虽然空间加了一堆，但是过得去，也好理解啊！（为自己找借口）

好了好了，上代码：

```c++
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
bool e[2001][2001];//邻接矩阵
int match[2001];//配对关系记录
bool visit[2001];//访问标记
int n,m,k;
bool dfs(int v)//找到人匹配就返回true,否则false
{
    visit[v]=true; 
    for(int i=n+1;i<=m+n;i++)//枚举每个B组成员（邻接表枚举每条边），看之间是否有连线
    {
        if(e[v][i]==1&visit[i]==false)
        {
            visit[i]=true;
            if(match[i]==0||dfs(match[i]))//对方没和别人匹配或者对方匹配的人找到了别人
            { 
                match[v]=i;
                match[i]=v;//记录一下
                return true;//找到了
            }
        }
    }
    return false;//所有边均已尝试，无功而返
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    memset(match,0,sizeof(match));
    for(int i=1;i<=k;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        if(a>n||b>m)//这种异常数据直接过滤掉
            continue;
        e[a][b+n]=e[b+n][a]=true;
    }//读入部分
    int count=0;
    for(int i=1;i<=n;i++)//枚举每一个点，尝试匹配
    {
        for(int j=1;j<=n+m;j++)
        {
            visit[j]=false;//清除上次匹配的访问标记
        }
        if(dfs(i))//找到了
            ++count;//匹配数+1
    }
    printf("%d",count);
    //system("pause");
    return 0;
}
```

本文到这里就结束了，希望能给你带来帮助。

---

## 作者：Chase12345 (赞：2)

# 二分图
二分图是一种特殊的图结构，它的点集可以被划分为两个互补相交的子集 $U$ 和 $V$，使得图中的每条边都连接 $U$ 中的一个顶点和 $V$ 中的一个顶点。形式化地，二分图可以表示为 $G=(U,V,E)$，其中 $E \subseteq U \times V$。

二分图是**不存在奇环的**。相反地，存在奇环的图必然不是二分图。证明：
> 在必要性和充分性两方面讨论。
>
> 必要性：假设图是二分图，则任何环必须交替经过两个顶点集，因此环的长度必须是偶数。
>
> 充分性：通过二染色法即可。

# 二分图判定
通过上述说明，二分图判定可以使用二染色法，由于这是我很久以前的代码，使用了链式前向星。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
int head[N], ver[N << 1], nxt[N << 1], tot;
int color[N];
 
void add(int u, int v) {
    ver[++tot] = v;
    nxt[tot] = head[u];
    head[u] = tot;
}

bool dfs(int u, int c) {
    color[u] = c;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = ver[i];
        if (!color[v]) {
            if (!dfs(v, 3 - c))
				return false;
        } else if (color[v] == c)
            return false;
    }
    return true;
}
 
bool check(int n) {
    memset(color, 0, sizeof(color));
    for (int i = 1; i <= n; i++)
        if (!color[i] && !dfs(i, 1))
			return false;
    return true;
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1, u, v; i <= m; i++) {
    	cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    cout << (check(n) ? "Yes\n" : "No\n");
    return 0;
}
```
# 二分图匹配
二分图匹配是指在二分图中选择一组边，使得这组边中没有两条边共享同一个顶点。换句话说，匹配是边的子集，其中任何两条边都不相邻。
## 求二分图最大匹配算法
最简单的是匈牙利算法（因为我不会其它的）。

先分左边和右边。（其实就是两个子集，方便讲解）

匈牙利算法其实就是枚举左边顶点，每次找出这个顶点的出边，能匹配就匹配。设已经被匹配的顶点为 $A$（左边），而右边匹配的是 $B$，当前 $C$ 想要匹配 $B$，那么 $A$ 尝试匹配其它顶点，可以匹配就匹配其它顶点，找不到其它顶点的话 $C$ 就不能匹配 $B$。这样一直下去。其实就是“翻转”路径上的匹配状态（即未匹配的边变为匹配，匹配的边变为未匹配）来增加匹配的总数。

代码十分简单。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 505, M = 5e4 + 5;
int to[N][N], y[N], used[N], n, m, e;

int find(int x) {
	for (int i = 1; i <= m; i++)
		if (to[x][i] == 1 && !used[i]) {
			used[i] = 1;
			if (!y[i] || find(y[i]) == 1) {
                y[i] = x;
                return 1;
            }
		}
	return 0;
}

int solve() {
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		memset(used, 0, sizeof used);
		ans += find(i);
	}
	return ans; 
}

int main() {
	cin >> n >> m >> e;
	for (int i = 1, u, v; i <= e; i++) {
		cin >> u >> v;
		to[u][v] = 1; 
	}
	cout << solve() << '\n';
	return 0;
}
```
## 正确性证明
要证明：一个匹配是最大的当且仅当不存在增广路径。

为什么增广路径能增加匹配数？  
> 假设我们有一条增广路径，其形式为：未匹配的边 $\to$ 匹配的边 $\to$ 未匹配的边 $\to \dots \to$ 未匹配的边。当前匹配的边比未匹配的边少一条。通过翻转，原来的匹配边变为未匹配，未匹配的边变为匹配，这样匹配的总边数就增加了 $1$。

那么我们要证明的变为：一个匹配是最大的当且仅当不存在增广路径。

首先关于必要性：如果存在增广路径，那么可以通过翻转增加匹配数，因此当前匹配不是最大的。

其次，充分性。我们使用反证法。假设当前匹配为 $M$，有更大的匹配 $M'$，考虑 $M$ 和 $M'$ 的对称差，这些边形成了一些路径和环。因为 $M'$ 比 $M$ 大，所以至少存在一条路径，其中 $M'$ 的边比 $M$ 多。那么是否发现了这条路径正是关于 $M$ 的增广路啊，矛盾了。那么 $M$ 最大。证毕。

## 复杂度
时间复杂度 $O(nm)$。

# 总结
二分图最大匹配是非常好用的。还有更多的内容例如：二分图最大权匹配、一般图最大匹配。~~这些我不会~~大家可以参考其它文章。

---

## 作者：arfa (赞：2)

## 二分图匹配

·图论

### 二分图概念:
分为两边的点,同边的点不相连,另一边的点可以相连,如图:

![](https://cdn.luogu.com.cn/upload/pic/21212.png)
红色的边明显破坏了二分图性质。

### 匹配概念
两两个点进行匹配,匹配过的点不再出现,如图:

![](https://cdn.luogu.com.cn/upload/pic/21213.png)

经过匹配后,点清除,其它的继续匹配。

### 最大匹配

一个二分图中,匹配最多的**点数**为这个二分图的**最大匹配数**。如图:

![](https://cdn.luogu.com.cn/upload/pic/21214.png)

这里要注意,不是所有的二分图都有**最大匹配数量**=**点数**的情况。

### 算法介绍
总结两个二分图做法。

### 1.匈牙利算法
主要思路是贪心:我们需要满足后来的点时,可能需要破坏前面已经匹配的点,然后让前面的点换一个匹配对象。

题解:[BYVoid-匈牙利算法](https://www.byvoid.com/zhs/blog/hungary)

### 2.网络流
~~不得不说,一切图论皆网络流。~~ 

 _~~**(吊打匈牙利不再话下)**~~_ 
#### 入门篇:
[网路流的概念和EK,Dinic](https://www.luogu.org/blog/acking/solution-p3376)

#### 为什么选择网络流?
我们把每一条边的流量设置为1(反向边为0),建造源点和汇点(习惯是源点source=1,汇点sink=n+m+2),那么流到了汇点,最大流量就是网络流。

![](https://cdn.luogu.com.cn/upload/pic/21215.png)

为什么呢?

通俗一点来说:因为所有流量都是1,所以每一个路径都有可行性(全都是增广路)。从源点出去的点(除了这个点没有连边)肯定都会出现增广路,那么流到右边点的,就是匹配成功(再流向汇点)。

![](https://cdn.luogu.com.cn/upload/pic/21216.png)

这里的**建模**需要特别注意。

#### ISAP
[更快的ISAP解法](https://www.luogu.org/blog/acking/solution-p3376-2)

ISAP是一种网络流算法,会比Dinic快很多,而且少了初始化BFS,程序复杂度少了很多,参考如下。

### CODE
```psacal
//可能因为pascal或者是初始化的原因,有些时候被Dinic赶超,不过时间复杂度还是很乐观的。(可以开O2)
//少了建模和添边,ISAP的DFS只占很少Byte。
//以下程序只是介绍建模部分

Uses math;

var
        value,reach:array[0..2010] of longint;
        dis,gap,cnt,next:array[1..1010] of longint;
        n,m,source,sink,tot,x,y,sum,i,k:longint;
        maxflow:int64;

procedure add(x,y,sum:longint);
begin
        inc(tot);
        reach[tot]:=y;
        inc(value[tot],sum);
        next[tot]:=cnt[x];
        cnt[x]:=tot;
end;

function Dfs(now,flow:longint):longint;
var
        i,k,mindis,ret:longint;
begin
        mindis:=n-1;
        ret:=flow;
        if now=sink then
                exit(flow);

        i:=cnt[now];
        repeat
                if value[i]>0 then
                begin
                        if dis[now]=dis[reach[i]]+1 then
                        begin
                                k:=Dfs(reach[i],min(ret,value[i]));
                                dec(value[i],k);
                                inc(value[i xor 1],k);
                                dec(ret,k);
                                if dis[source]>=n then
                                        exit(flow-ret);
                                if ret=0 then
                                        break;
                        end;
                        mindis:=min(mindis,dis[reach[i]]);
                end;
                i:=next[i];
        until i=-1;

        if ret=flow then
        begin
                dec(gap[dis[now]]);
                if gap[dis[now]]=0 then
                        dis[source]:=n;
                dis[now]:=mindis+1;
                inc(gap[dis[now]]);
        end;
        exit(flow-ret);
end;

begin
        filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
        tot:=1;

        read(n,m,k);
        source:=1;
        sink:=n+m+2;
        for i:=1 to n do //源点向左边的点添边
        begin
                add(source,i+1,1);
                add(i+1,source,0); //注意:反向边依然是0
        end;
        for i:=1 to k do //创建二分图
        begin
                read(x,y);
                if (x>n)or(y>m) then //Bug
                        continue;
                add(x+1,y+n+1,1);
                add(y+n+1,x+1,0);
        end;
        for i:=1 to m do //右边的点向汇点添边
        begin
                add(i+n+1,sink,1);
                add(sink,i+n+1,0);
        end;

        n:=n+m+2;

        gap[source]:=n; //ISAP网络流部分
        while dis[source]<n do
                inc(maxflow,Dfs(source,maxlongint));
        writeln(maxflow);
end.
```



---


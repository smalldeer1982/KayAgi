# [JSOI2007] 建筑抢修

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 样例 #1

### 输入

```
4
100 200
200 1300
1000 1250
2000 3200```

### 输出

```
3```

# 题解

## 作者：_Album_ (赞：82)

更好的阅读：[传送门](https://payphone-x.top/2019/10/16/luoguP4053)

----------------------------------

## 分析

一道简单的贪心题。

首先，我们需要把所有数按照$t_2$进行升序排序，从而确定修理建筑的先后顺序。

但仅仅这样贪心不一定是最优的，需要在中途进行转正。

排序之后，我们从$1$到$n$遍历一遍建筑，确定这个建筑是否需要修理。

显然，如果可以在这个建筑报废之前修理好它，则一定修。

否则的话，则一定会报废一个建筑。显然，要报废的建筑的是修理时间最长的建筑。

剩下的详见代码注释。

--------------------------------------

## Code[Accepted]

```Cpp
#include <bits/stdc++.h>

#define ll long long
#define I inline
#define N 150001

using namespace std;

struct Building{
    ll t1;
    ll t2;
}build[N];

bool cmp(Building a , Building b){
    return a.t2 < b.t2;
}

int n;
ll sum , ans;
priority_queue<ll > Q;    //采用优先队列维护耗时最长的建筑。

int main(){
    cin >> n;
    for(int i = 1; i <= n; i ++){
        cin >> build[i].t1 >> build[i].t2;
    }
    sort(build + 1 , build + 1 + n , cmp);
    for(int i = 1; i <= n; i ++){
        sum += build[i].t1;
        Q.push(build[i].t1);
        if(sum <= build[i].t2){     //如果可以修，就修。
            ans ++;
        }
        else{       //否则报废耗时最长的建筑。
            sum -= Q.top();
            Q.pop();
        }
    }
    cout << ans << "\n";

    return 0;
}
```

------------------------------------

# THE END



---

## 作者：Refun (赞：31)

贪心……果然我还是太单纯善良了一点都不贪（？）

一开始无从下手，毕竟两个值，该以哪个为标准呢？

所以我们就按照T2排序好了……

对于当前建筑，如果时间来得及那就最好不过了，我们修复它

如果时间来不及，就从大根堆里面挑出来一个

（堆里放的是已经修好的建筑的花费）

若当前建筑需要的花费时间比堆顶小，那么修堆顶的那个
还不如修当前的这个

毕竟赚到的都是一个建筑……可是当前的花费小啊

至于为什么按T2排序……

反正xjb贪就对了【滑稽】 

我觉得如果不按T2排序的话可能是防止一些不需要很提前修改的建筑被提前修改

如下面的数据，正解是5 
5

1 2

2 100

10 13

1 5

1 5

代码贴博客里好了qwq安利一下博客

[Refun](http://www.cnblogs.com/refun/p/8678531.html)

---

## 作者：Treaker (赞：30)

这道题解法是贪心，用大根堆来辅助维护。这种思想也是出现的比较多

我们先按后面的时间排序，把前面的时间压入堆，当我们发现它并不能修复当前建筑时，我们从堆中取出堆顶并删除，再维护。
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 150100;
int n , ans;
long long sum;
struct building
{
	long int s , t;
	friend bool operator < (const building&a,const building&b)
	{
		return a.t < b.t;
	}
}e[N];
priority_queue<long int> q;
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)	scanf("%ld%ld",&e[i].s,&e[i].t);
	sort(e+1,e+1+n);
	for(int i = 1;i <= n;i ++)
	{
		sum += e[i].s;
		ans ++;
		q.push(e[i].s);
		if(sum > e[i].t)	sum -= q.top() , q.pop() , ans --;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Moooooli (赞：21)

贪心+堆排


要尽可能的修理更多的大楼,但是大楼没有权值，也就是说优先级是相同的，那么利用贪心思想，尽量先去修快坏的楼。


定义一个结构体，把修楼需要的时间和楼还有多长时间损坏存进去。以损坏时间先后排一下序，优先修快坏的，然后存一个已用时间（tme），再建立一个堆来维护已修的楼用时最大的。如果判断下个楼没时间修了，就把修它需要的时间和已经修的楼中最大的时间比一下谁少。因为堆中的楼都是先修的，如果不修辣个楼就一定能修现在这个。虽然不会多修楼，但是可以省下更多时间给后面的楼。


也就是说，如果修这个现在来看修不好的楼所需时间比堆顶的楼（已修用时最长）少，那么就把那个楼弹出，换进这个楼，再把已用时间更新一下。最后一定就是正确答案辣。


程序名称有点乱，尽量看吧。


    ```c++
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int n=0;//已修楼数 
    long long tme=0;//已用时间 
    struct build{
        long long T1,T2;
    }z[200010];
    bool cmp(build a,build b){
        return a.T2<b.T2;
    }
    struct dui{
        int a[150010];
        int c;
        void makedui(int i){
            int j;
            while(i/2>=1){
                j=i/2;
                if(a[j]<a[i]){
                    c=a[j];
                    a[j]=a[i];
                    a[i]=c;
                    i=j;
                }
                else break;
            }
        }
        void redui(int i){
            int j;
            while(i*2<=n){
                j=i*2;
                if(a[j]<a[j+1]&&j+1<=n)j++;
                if(a[j]>a[i]){
                    c=a[j];
                    a[j]=a[i];
                    a[i]=c;
                    i=j;
                }
                else break;
            }
        }
    }q;
    void yxj(int p)//判断哪个楼先坏 
    {
        if(q.a[1]>z[p].T1){
            tme-=q.a[1];
            tme+=z[p].T1;
            q.a[1]=z[p].T1;
            q.redui(1);
        }
    }
    int main(){
        int k;
        scanf("%d",&k);
        for(int i=1;i<=k;i++){
            scanf("%lld%lld",&z[i].T1,&z[i].T2);
        }
        sort(z+1,z+1+k,cmp);
        for(int i=1;i<=k;i++){
            if(tme+z[i].T1<=z[i].T2)//能修就修lalala，修不了就嘿...和堆顶判断 
            {
                q.a[++n]=z[i].T1;
                tme+=z[i].T1;
                q.makedui(n);
            }
            else yxj(i);
        }
        printf("%d",n);
        return 0;
    }
```

---

## 作者：wuzhaoxin (赞：19)

# ~~最不要脑子的题解~~

~~作者没有脑子~~

由于没有权值，所以我们肯定考虑选花时间小的建筑，于是我们把建筑按花的时间从小到大排序，能选就选，选了的我们让它在尽量靠后的时间修（一个经典贪心套路），~~没了~~

我们可以用~~线段树~~或者 **珂朵莉树** 维护没有被选的时间

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gi() {
    register int x; register char c, op = 0;
    while(c = getchar(), c < '0' || c > '9') if(c == '-') op = !op;
    x = c ^ 48;
    while(c = getchar(), c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48);
    return op ? -x : x;
}
set<pair<int, int> > s;
void split(int x) {
    set<pair<int, int> >::iterator it = s.upper_bound(make_pair(x + 1, 0));
    if(it == s.begin()) return;
    it --;
    if(it->second <= x) return;
    pair<int, int> p = *it;
    s.erase(it);
    s.insert(make_pair(p.first, x));
    if(p.second > x) s.insert(make_pair(x + 1, p.second));
}
int get(int ddl, int t) {
    split(ddl);
    set<pair<int, int> >::iterator it = s.upper_bound(make_pair(ddl + 1, 0));
    set<pair<int, int> >::iterator i = it;
    int now = 0;
    while(i != s.begin()) {
	i --;
	now += i->second - i->first + 1;
	if(now >= t) break;
    }
    if(now < t) return 0;
    int bg = i->first + (now - t);
    split(bg - 1);
    i = s.lower_bound(make_pair(bg, 0));
    while(i != it) s.erase(i ++);
    return 1;
}
pair<int, int> a[150001];
int n;
int main() {
    s.insert(make_pair(1, INT_MAX));
    n = gi();
    for(int i = 1; i <= n; i ++) a[i].first = gi(), a[i].second = gi();
    sort(a + 1, a + n + 1);
    int ans = 0;
    for(int i = 1; i <= n; i ++) ans += get(a[i].second, a[i].first);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：灵乌路空 (赞：10)

## 知识点:贪心 

### [原题面](https://www.luogu.org/problem/P4053)  
 
### 分析题意:   

1. 显然, 先对报废时间晚 ,  修复耗时短的建筑进行修复更优   
    则 可以先按照 报废时间 对各建筑进行排序    

2. 对于 已经选择的 一个任务序列    
    考虑 一个 新任务对 任务序列的影响 :   
	  1. 如果 结束最后一个任务之后, 紧接着做新任务,可完成 新任务,   
  	      则 可以直接将 新任务 加入任务序列 ,  显然较优   
  	       
	  2. 如果不满足上面的 情况 ,    
  	    但: 任务序列中 耗时最长的 任务 耗时$>$ 新任务   
	     
         显然 ,  如果将 耗时长的任务 替换为新任务 ,   
	     修复完成的 建筑数量不会改变 ,    
	     但是 完成最后一个任务的时间右移 , 对之后加入的新任务更优   
        
则可以按照上述结论进行贪心   
对于 任务序列中 个任务的耗时, 可以使用堆维护   
复杂度 $O(n\log n)$    

---

```cpp
//知识点:贪心 
/*
By:Luckyblock
1A开心
*/ 
#include<cstdio>
#include<algorithm>
#include<queue>
#include<ctype.h>
#define int long long
const int MARX = 1e5+5e4+10; 
//=============================================================
struct plan
{
	int t1,t2;
}a[MARX];
int n , nowt,ans;
std::priority_queue <int> q;
//=============================================================
inline int read()
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
bool cmp(plan fir,plan sec) {return fir.t2 < sec.t2;}
//=============================================================
signed main()
{
	n = read();
	for(int i=1; i<=n; i++) a[i].t1=read(),a[i].t2=read();
	std::sort(a+1,a+n+1,cmp);//按照结束时间 升序排序 
	
	for(int i=1; i<=n; i++)
	  if(nowt + a[i].t1 <= a[i].t2)
	  {
	  	//若做完 最后一个任务后 ,直接进行 新任务,新任务能完成 
	  	 nowt += a[i].t1 , ans++;//更新 做完最后一个任务的时间 
	  	 q.push(a[i].t1);//加入队列 
	  }
	  else if(a[i].t1 < q.top())
	  {
	  	//若不满足 上面的情况, 但是新任务 比 之前做完的任务中耗时最长的短
	  	nowt = (nowt - q.top() + a[i].t1);//更新 做完最后一个任务的时间  
	  	q.pop(); 
	  	q.push(a[i].t1);//入队 
	  }
	
	printf("%lld",ans);
}
```

---


最后无良宣传一下博客 $wwwwww$      
[文章列表 - 地灵殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/) 


---

## 作者：过往梦魇之殇 (赞：6)

### 算法：贪心+堆维护

[**题目传送门**](https://www.luogu.com.cn/problem/P4053)

首先按照T2从小到大排序 ~~（人类本能吧，哪个自爆快哪个先修）~~

然后扫一遍过去进行贪心：

**贪心策略**：如果当前时间能抢修的就抢修，并把$T1$加到堆里。

否则和堆顶比较，如果堆顶（所花时间）大于$T1$的话，就把堆顶拿出来，把$T1$加进去。这么做是为了减少时间。

策略正确性证明在此不详细讲 ~~（因为我太弱了）~~

代码实现：

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
const int maxn=15e4;
struct node{
	int t1,t2;
}a[maxn];
priority_queue<int>q;
int n,ans;
long long t;
bool cmp(node x,node y){
	return x.t2<y.t2;
}
int main()
{
	n=read();
	for(re int i=1;i<=n;++i){
		a[i].t1=read();
		a[i].t2=read();
	}
	sort(a+1,a+n+1,cmp);
	for(re int i=1;i<=n;++i){
		if(a[i].t2>=t+a[i].t1){
			++ans;
			t+=a[i].t1;
			q.push(a[i].t1);
		}
		else{
			if(q.size()&&a[i].t1<q.top()){
				t-=q.top();
				t+=a[i].t1;
				q.pop();
				q.push(a[i].t1);
			}
		}
	}
	write(ans);
    return 0;
}
```

###### 制作不易，求资瓷！

> Thanks For Watching!

---

## 作者：约瑟夫用脑玩 (赞：5)

## P4053 [JSOI2007]建筑抢修

有 $n$ 个事件，做第 $i$ 件事要花连续的 $t1_i$ 的时间，而且只能在 $t2_i$ 之前做完，问最多能做多少件事。

------------

### 经典解法

正序做，堆贪心，时间少换时间多，不多赘述。

------------

### 一种不一样的解法
      
我的做法的逻辑应该比经典做法来的舒服，就是将时间倒序，由于没有最终时间的限制了，每个事情能做就做，事情时间越少越先做。

发现仅由这个无法做到最优，还要处理的就是：哪些事情由于开始时间早而先做，哪些事情由于时间短而先做。

处理这些事的评判标准就是结束时间的先后，结束时间越早的能空出的时间越多就越好，不妨称之为优先级更高。

有优先级就用优先级判断，而没有优先级的影响时，也即开始时间都相同时，就选时间少的即可。

以下是实现思路的参考：

- 首先按 $t2$ **从大到小**排序。

- 依次考虑每个事件 $x$：

  将在当前事之后发生且能做的事都做了，即能在 $t2_x$ 之前结束的事，形式化的有 $start\ times-t1_y$，就直接结束了。
  
  以下定义首要事务为未做的事当中优先级最高或时间最少的事件。
  
  结束这些事的顺序为先做首要事务，再依次取出剩下当中的时间最少的事当做首要事务。
  
  接下来考虑：

  - 若之前的事都已经做完了，当前的事变为首要事务。
  
  - 若之前的事没做完，将当前的事与之前的首要事务（不妨称为 $prime$）进行比较：
  
    - 若 $x$ 结束时间比 $prime$ 晚，即 $t2_x-t1_x<start\ time-t1_{prime}$，那么首要事务不变。
  
      同时 $x$ 进入首要事件的备选事件。
      
    - 若 $x$ 结束时间比 $prime$ 早，即 $t2_x-t1_x>lst2-lst1$（边界不作考虑，因为归于哪一类均可），那么 $x$ 变成当前事务。
    
      同时 $prime$ 作为反悔项进入备选事件，反悔指的是为了利用 $x$ 以前的那段时间，即 $(t2_x,start\ times]$ 的时间做 $prime$，并且保证连续将 $x$ 往后推。
      
      不难发现这样做仍然保证了合法的顺序与时间来依次完成这些事件。

实际上的实现很简单，也就比普通解法多 10行 的代码。

主要是要实现一个类支持首要事务的查询加入删除以及替换，主函数还是很短，代码附于最后。

### 小总结

这种解法其实比经典解法来的更套路，但并不比经典解法复杂多少，如果忘记经典解法这种解法显然更容易被想到。（指自己不会经典解法然后 yy 出了这种做法）

### 代码

```cpp
namespace Slv
{
	priority_queue<int,vector<int>,greater<int> >q;
	int ans,flg=1,nowt,nowp;
	inline int Ept(){return flg;}
	inline int Get(){if(Ept())return -1;return nowt-nowp;}
	inline void Add(int x,int y){nowp=x;nowt=y;flg=0;}
	inline void Cng(int x,int y){q.push(nowp-(nowt-y));Add(x,y);}
	inline void Add(int x){q.push(x);}
	inline void Cal(){ans++;if(!q.empty())nowt-=nowp,nowp=q.top(),q.pop();else flg=1;}
}
const int Mx=150000;
int n,t1[Mx+5],t2[Mx+5],pos[Mx+5];
signed main()
{
	int i,p,p1,p2;
	n=read();for(i=1;i<=n;i++)t1[i]=read(),t2[i]=read(),pos[i]=i;
	sort(pos+1,pos+1+n,[](int x,int y){return t2[x]>t2[y];});
	using namespace Slv;
	for(i=1;i<=n+1;i++)
	{
		p=pos[i];p1=t1[p];p2=t2[p];
		for(;Get()>p2;Cal());
		if(Ept())Add(p1,p2);
		else if(p2-p1>Get())Cng(p1,p2);
		else Add(p1);
	}
	writenum(ans,10);
	return output;
}
```

---

## 作者：wwldx (赞：5)

改了差不多一个小时，想分享下我的思路，万一有人跟我一样卡这里了。。。
大概思路和其他大佬发的题解思路是一样的，全部读入后，按结束时间从大到小排序，如果某次无法修复，找之前的最大值删去，把这次的填补上去，这个过程可以用单调队列优化

而我是按最迟开始时间排序，比如某个大楼在1000的时候会坍塌，而修补他需要200的时间，那你最迟需要在800的时候修补，一旦时间已经大于了800，那你浪费时间去修是无收益的，于是我按最迟开始时间处理，基本代码和其他大佬的差不多，结果。。。


![](https://cdn.luogu.com.cn/upload/image_hosting/avusakr6.png)


没错，只有90分，那么问题出现在哪呢

比如这组数据 

4

1 2

10 13

1 5

1 5

假如是按最迟开始时间排序的话，处理后就是 

1 1

10 3

1 4

1 4

在优先队列存储10 3这组数据后，时间变成了11，在处理 1 4的时候，就会认为此时时间来不及了，单调队列会取出最大值，也就是10 3这组数据，但其实压根不用取，因为2组1 4完全可以插入在 1 1和10 3中间。

那我们该怎么处理呢，我们另设一个变量maxx,用来存储每次l和当前这组数据的最迟开始时间之间的差，比如刚才处理的时候，1 1之间，maxx是0，10 3的时候，maxx是2，有2个间隙，当处理1 4的时候，2>1，可以直接插入1 4，maxx减1，变成1，再处理1 4的时候，同理，maxx>=1，再插入，maxx变为0了，而假如当时数据的需要维修时间大于了maxx，插入不了，再进行单调队列的维护，这样的话就没问题了，maxx在每次的数据处理更新一次就可
下面是代码，可以结合代码看
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=150005;
#define rep(i,a,n) for(int i=a;i<n;i++)
int n,sum,l;
typedef pair<int,int> P;
P a[maxn];
int cmp(P a,P b)
{
	return a.second<b.second;
}
priority_queue<P> Q;//优先队列
int maxx;
int main()
{
	cin>>n;
	rep(i,1,n+1)
	{
		cin>>a[i].first>>a[i].second;
		//first存储每次需要的修理时间，second存储最迟开始时间 
		a[i].second-=a[i].first;
	}
	sort(a+1,a+n+1,cmp);//按second从小到大排序 
	rep(i,1,n+1)
	{
		if(l<=a[i].second)//l从0开始，作为时间 
		{
			l+=a[i].first;
			sum++;
			Q.push(a[i]);
			maxx=a[i].second-l+a[i].first;//存储每次的剩余间隙 
		}
		else
		{
			if(a[i].first<Q.top().first)
			{
				if(a[i].first<=maxx)//剩余间隙足够大，可以使这次的维修插入到之前的去 
				{
					maxx-=a[i].first;//剩余间隙减去这次消耗的 
					sum++;//总数++，同时不用pop单调队列的最大值 
					Q.push(a[i]);
					l+=a[i].first;
					continue;
				}//剩余间隙不够大，只能把之前的消耗最大的一次进行替换 
				l-=Q.top().first;
				Q.pop();//删去最大值 
				Q.push(a[i]);
				l+=a[i].first;
			}
		}
	}
	cout<<sum<<"\n";
	return 0;
 } 
```


---

## 作者：山蛙or山兔 (赞：3)

这题看似简单，但其实很考验思维。

第一步可能都会想到按照t1或者t2进行排序然后贪心，不过立马就可以察觉到是错误的。

第二步的话可能会想到先使用dp试试，如果对t1排序，结果是虽然能找到修复i个建筑的最小耗时，但是无法找到修复建筑最多的方案。

如果对t2排序，则可以找到答案，但是需要n^2的时间复杂度。

第三步是比较关键的，要从原理去思考，或者从dp中寻找规律。然后我们可以就发现，当遍历到i时，如果不能修复更多的建筑，一定会选择不修复之前花费时间更多的建筑。

代码如下：

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#define maxn 150010
using namespace std;

int n;
struct pii
{
	int a,b;
	bool operator < (pii temp) const
	{
		return b<temp.b;
	}	
}arr[maxn];
priority_queue<int> q;

int main()
{
	cin >> n;
	for (int i=0;i<n;i++)
	{
		int x,y;
		cin >> arr[i].a >> arr[i].b;
	}
	sort(arr,arr+n);
	long long t=0;
	for (int i=0;i<n;i++)
	{
		t+=arr[i].a;
		q.push(arr[i].a);
		if (t>arr[i].b) t-=q.top(),q.pop();
	}
	cout << q.size() << endl;
	return 0;
}
```


---


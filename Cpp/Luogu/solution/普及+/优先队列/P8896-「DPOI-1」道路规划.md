# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# 题解

## 作者：kevinchw (赞：8)

「DPOI-1」官方题解

### 题意

给你一个无向完全图，问你能不能把每条边定向，使得这张图变成一个有向无环图，而且第 $i$ 个点的出度在 $[l_i,r_i]$ 区间内。

### 思路

诈骗题。

由于 $n$ 最大有 $10^5$，所以肯定不能把图建出来。通过有向无环图所以想到了拓扑排序。只要构造出来一个拓扑序，就可以建出唯一的有向无环图。而拓扑序中第 $i$ 个点的出度就是比它编号大的点的个数，即 $n-i$。于是，这题就可以转化成：

给定 $n$ 个区间 $[l_i,r_i]$，求是否存在一个 $1\sim n$ 的排列 $a$，使得 $\forall 1\leq i \leq n,l_i\le a_i\le r_i$。

上面的题目就可以贪心求解。我们可以枚举 $1\sim n$ 分别放进哪个区间里。

设当前搜到了 $i$，则把所有 $l_i = i$ 的区间右端点加入小根堆。匹配时则取出堆中最小右端点把 $i$ 放进对应区间。如果在操作过程中堆为空或最小右端点比 $i$ 小，则不存在一种定向方案。

贪心策略的正确性怎么证明呢？现在我们假定在讨论 $i$ 时我们选择了一个 $r_x > r_{\min}$，若有解，我们显然可以交换这两者，且仍然保持有解——因为此时 $r_{\min}$ 放置的位置 $j$ 满足 $i < j \leq r_{\min} < r_x$，这个位置对应 $r_x, r_{\min}$ 而言均合法。于是选择 $r_{\min}$ 不劣于选择其他 $r_x$。

### 代码

``` C++
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define inf (int)2e9
#define ldb long double
#define db double
#define ft float
#define pb push_back
#define ins insert
#define myset(a,b,c,d) for(int i=b;i<=c;i++)a[i]=d;
using namespace std;

priority_queue<int,vector<int>,greater<int> > q;//小根堆
struct node
{
	int l,r;
}a[100005];
vector<int> v[100005];//储存右端点
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		q=priority_queue<int,vector<int>,greater<int> >();//清空
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			v[i].clear();
			int x;
			scanf("%d",&x);
			a[i].r=n-x;//计算右端点
		}
		for(int i=1;i<=n;i++)
		{
			int x;
			scanf("%d",&x);
			a[i].l=n-x;//计算左端点
			v[a[i].l].pb(a[i].r);//记录右端点
		}
		int now=1,op=0;
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<(int)v[i].size();j++)q.push(v[i][j]);//右端点插入堆中
			if(q.empty())//堆为空
			{
				cout<<"NO\n";
				op=1;
				break;
			}
			int x=q.top();q.pop();
			if(x<i)//右端点不合法
			{
				cout<<"NO\n";
				op=1;
				break;
			}
		}
		if(!op)cout<<"YES\n";
	}
	return 0;
}

```

---

## 作者：lngym (赞：4)

### P8896 道路规划 题解

[题目传送门](https://www.luogu.com.cn/problem/P8896)

大致题意：有一张无向完全图，现要将每条边定向，将图变成有向无环图，给定 $n$ ，与 $n$ 个区间 $[l_i,r_i]$ ，问可否使得每一个 $i\in[1,n]$ ，都可以保证第 $i$ 个点的出度在 $[l_i,r_i]$ 内。

（不会拓扑排序的我选择找规律）

首先由于 $n$ 最大有 $10^5$，所以建图的方案被否定，于是我试图通过找规律将题意化简。

$n=1$ 时直接成立。

考虑当 $n=2$ 时，只需删除一条有向边。

当 $n\geq3$ 时，需要删除 $n$ 条有向边。

在删除之后，我们仍旧会发现，对于每三点，都可以形成一个三角形，由于是一张无环图，所以组成三角形的三条有向边必然有一条边可以被删除（因为可以被另外两条有向边之和所取代，写成向量形式就是 $\overrightarrow{AB}+\overrightarrow{BC}=\overrightarrow{AC}$ ）。于是当删除这些边之后，可以证明，此时只剩下 $n$ 条边，且恰好组成一个有向无环图。且是一张简单图，除端点外，其余每个顶点的度数均为 $2$。

于是可以将题意化简成：给定 $n$，与 $n$ 个区间 $[l_i,r_i]$，问是否存在一个 $0∼n$ 的排列 $a$，使得 $∀$ $0\leq i \leq n-1$ 时，均有 $l_i\leq a_{i+1}\leq r_i$。

于是在我同学的提示下，我就有了下面的思路：

使用优先队列，按左端点从小到大排序，并在右端点处维护一个小根堆。使用贪心算法。

代码如下：

```cpp
#include<bits/stdc++.h>
#define re register
#define MAX 100005
#define debug puts("bug\n")
using namespace std;
typedef struct node
{
	int l;
	int r;
	inline bool operator <(const node x) const
	{
		return this->l<x.l;	// 注意重载运算符时this指针的用法
	} 
}Node;
Node a[MAX];
int flag=1;
priority_queue<int,vector<int>,greater<int> > q;
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n;
		scanf("%d",&n);
		for(re int i=1;i<=n;i++)
		{
			scanf("%d",&a[i].l);
			a[i].l++; // 此处++的目的是让0∼n-1变成1∼n，便于操作
		}
		for(re int i=1;i<=n;i++)
		{
			scanf("%d",&a[i].r);
			a[i].r++; // 同理
		}
		sort(a+1,a+n+1); // 对左端点进行排序
		/* 
		for(re int i=1;i<=n;i++)
		{
			printf("%d ",a[i].devide);
		}*/
		while(q.size()) q.pop();
		int now=1;
		for(re int i=1;i<=n;i++)
		{
			while(a[now].l<=i&&now<=n) // 如果左端点比i小，now不溢出 
			{
				q.push(a[now].r); // 让右端点入队 
				now++;
			}
			if(q.empty()||q.top()<i) // 如果队空或队头比当前的i小，则一定不满足
			{
				flag=0;
				break;	
			} 
			else q.pop();
		}
		if(flag==1) printf("YES");
		else printf("NO");
		putchar('\n');
		flag=1; // 记得初始化
	}
	return 0; //完美撒花~
}
```

## 本蒟蒻第一次发题解，大佬勿喷。

---

## 作者：DengDuck (赞：3)

DAG 竞赛图的拓扑序唯一，和 JoeyJ 老师交流了一手，给一下我的证明。

首先我们可以得到入度为 $0$ 的点有且仅有一个，怎么证明？

- 必要性：如果不存在这样的点就不存在拓扑序，这与是 DAG 矛盾。
- 充分性：如果存在两个入度为 $0$ 的点，这与两者之间存在边矛盾。

然后我们发现只能取出这个入度为 $0$ 的点，剩下的点又构成了一个小竞赛图，数学归纳法即可。

最后我们倒回来看，既然我入度为 $0$，那么所有点应该都被我连向，所以我们得出一开始每个点的出度应该是 $n-1,n-2,\cdots,2,1,0$，然后这题另外一个重要结论也可以得到了。

之后我们考虑用线段去匹配就行，从 $0$ 开始往大的数组选，优先选右端点小的。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pb push_back
using namespace std;
const LL N=1e5+5;
LL T,n;
struct Line{LL L,R;}A[N];
vector<LL>V[N];
void Work()
{
	scanf("%lld",&n);
	for(int i=0;i<=n;i++)V[i].clear();
	priority_queue<LL,vector<LL>,greater<LL> >Q;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&A[i].L);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&A[i].R);
		V[A[i].L].pb(A[i].R);
	}
	for(int i=0;i<n;i++)
	{
		while(!Q.empty()&&Q.top()<i)Q.pop();
		for(LL j:V[i])Q.push(j);
		if(Q.empty())
		{
			puts("NO");
			return;
		}
		Q.pop();
	}	
	puts("YES");
}
int main()
{
	scanf("%lld",&T);
	while(T--)Work();
}
```

---

## 作者：WDY_Hodur (赞：1)

# [P8896 道路规划](https://www.luogu.com.cn/problem/P8896)

## 题意：
给你一个无向图，所有点之间都有连边。让你把这些无相边改为有向边，并保证点 $i$ 的出度 $l_i$ 和 $r_i$ 之间。问能否实现。

## 思路
这道题我们可以从拓扑排序的角度来考虑，因为建出来的图是一个有向无环图，所以是存在拓扑序的，那么就必然会有一个点的入度为 $0$，即出度为 $n-i$。那如果不看这个点，剩下的点就一定会形成一个新的有向无环图，那么就必然会形成一个点，在新图中入度为 $0$，在旧图中入度为 $1$。以此类推，最后图中所有的点的出度数量分别为 $0$ 到 $n-1$。

这是一个很重要的结论，我们现在就将题意转化为了能否将 $0$ 到 $n-1$ 这 $n$ 个数分别放进 $n$ 个区间中。

考虑贪心。从 $0$ 开始查找，用一个小根堆存储所有左端点小于等于当前查找的这个数的右端点，如果队列为空，即无法满足要求，然后我们优先选右端点小的，即优先队列的队首元素。注意，如果这个队首元素要小于 $i$，即放不下 $i$，那么我们可以直接判断它不满足。因为一共只有 $n$ 个右端点，需要恰好分配给 $0$ 到 $n-1$，所以当 $i$ 无法被放下时，$i+1$ 也无法放下。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
int T,n;
struct node{
	int l,r;
}x[N];
priority_queue<int,vector<int>,greater<int> >q;
vector<int>g[N]; 
signed main(){
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=0;i<=n;i++)g[i].clear();
		for(int i=1;i<=n;i++)cin>>x[i].l;
		for(int i=1;i<=n;i++){
			cin>>x[i].r;
			g[x[i].l].push_back(x[i].r); 
		}
		while(!q.empty())q.pop();
		int f=0;
		for(int i=0;i<n;i++){
			for(int y:g[i])q.push(y);
			if(q.empty()){
				f=1;
				break;
			}
			int x=q.top();
			q.pop();
			if(x<i){
				f=1;
				break;
			}
		}
		if(f)cout<<"NO\n";
		else cout<<"YES\n";
	}
	return 0;
}
```

---

## 作者：AK_400 (赞：1)

首先我们发现存在两点度数相等是图上有环的充要条件。

我们记 $d_i$ 表示节点 $i$ 的出度，$x\to y$ 表示一条从 $x$ 到 $y$ 的边，$E$ 为边集。  
### 证明
#### 充分性：

首先，显然有 $\sum_{i=1}^nd_i=\frac{n(n-1)}{2}$，因为 $d_i$ 两两不同，于是只能是 $0,1,\cdots,n-1$ 的一个排列。

当 $n=1$ 时：显然没有环。

假设 $n=k$ 时成立，当 $n=k+1$ 时，新加入的点的出度肯定是 $k$，入度肯定是 $0$，于是它必定不在任意一个环中，因为其他 $k$ 个点都不在任意一个环中，于是这 $k+1$ 个点都不在任意一个环中。

#### 必要性证明：

假设存在两点度数相等时没有环。

记 $x,y$ 为出度相等的两个点。

假设 $ x\to y \in E$($y\to x$ 同理) 

则有 $d_y$ 个点 $k$ 使得 $y\to k\in E$。

$\forall k,y\to k\in E$，因为没有环，所以有 $x\to k\in E$。

于是 $x$ 除 $x\to y$ 外还有 $d_y$ 条出边。

所以 $d_x=d_y+1$，与 $d_x=d_y$ 矛盾。

-------

综上，存在两点度数相等是图上有环的充要条件。

于是我们把这个题转化成了有 $n$ 个区间，问你能不能在每个区间选个数，使得这些数两两不同，贪心即可。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,l[100005],r[100005];
vector<int>v[100005];
void slv(){
    cin>>n;
    for(int i=0;i<=n;i++)v[i].clear();
    for(int i=1;i<=n;i++)cin>>l[i];
    for(int j=1;j<=n;j++)cin>>r[j],v[l[j]].push_back(r[j]);
    multiset<int>s;
    s.clear();
    for(int i=0;i<n;i++){
        for(auto x:v[i])s.insert(x);
        if(s.empty()){
            cout<<"NO"<<endl;
            return;
        }
        auto it=s.begin();
        if(*it<i){
            cout<<"NO"<<endl;
            return;
        }
        s.erase(it);
    }
    cout<<"YES"<<endl;
    return;
}
signed main(){
    cin>>T;
    while(T--)slv();
    return 0;
} 
```

---

## 作者：xxgirlxx (赞：0)

诈骗题。

这题最终跟图没关系，因为要求没有环，而图又是完全图，可以很自然的想到所有点的度数肯定不一样，因为一旦一样必定有环，具体的，因为这两个点对于其它的点要么都是出边，要么都是入边，这就导致其它点对这两个点贡献的出度是一样的，而两个点之间也有一条边，这条边会使两个点的度数不一样，如果说有一个点使得两个点一个对其是出边另一个对其是入边，两个点出度还一样，那么这三个点必定构成环，因为对这个点是入边的那个点的出度会减一，要使两个点的出度一样这两个点之间的那个边的出度就会给到入边的那个点，这样的话就构成一个环了（可能很绕，建议读者自己手玩一些样例）。

那既然没有一样的度数，那么就可以想到度数是 $0$ 到 $n-1$，因此题目就变成了：是否有一个 $n$ 的排列 $a$，使得 $l_i+1\le a_i\le r_i+1$。

这个东西上贪心随便搞搞，枚举放的数，设这一次放的数是 $x$，那么就把所有 $l_i+1<=x$ 的点的**右端点**放进来，然后取其中的最小值，如果最小值小于了 $x$，就说明有的点无法满足条件，无解。

具体的看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,l[100010],r,num;
vector<int>e[100010];
struct node{int vl;bool operator<(const node& z)const{return vl>z.vl;}};
priority_queue<node>q;
int main(){
	cin>>t; 
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>l[i],l[i]++,e[i].clear();
		for(int i=1;i<=n;i++)cin>>r,r++,e[l[i]].push_back(r);
		for(int i=1;i<=n;i++){
			for(int j=0;j<e[i].size();j++)q.push({e[i][j]});
			if(q.size()==0){cout<<"NO\n";break;}
			else{
				num=q.top().vl,q.pop();
				if(i>num){cout<<"NO\n";break;}
				else if(n==i){cout<<"YES\n";break;}
			}
		}
		while(!q.empty())q.pop();
	}
	return 0;
}
```

---

## 作者：Gapple (赞：0)

首先，观察到题目要求变出一个 DAG，所以我们可以给节点一个拓扑序。设其为 $a_0, a_1, \cdots, a_{n - 1}$。

因为原图是完全图，所以在 DAG 中，对于所有 $0 \le i < n$，$a_i$ 要连 $a_{i + 1}, a_{i + 2}, \cdots, a_{n - 1}$。所以其出度为 $n - i$。

故原问题变成了：给定 $n$ 个区间 $[l_i, r_i]$，请问是否有长度为 $n$ 的排列 $p$ 满足 $\forall 0 \le i < n, l_i \le p_i \le r_i$？

考虑贪心。我们遍历每个数，然后找出它所在的位置。在搜到 $i$ 时将左端点为 $i$ 的所有区间的右端点 push 进优先队列，之后 pop 一个元素出来，然后把 $i$ 放入这个区间。

如果优先队列是空的，或 pop 的区间不包含 $i$，则无解。

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;
using i64 = long long;

void solve_test()
{
    int n;
    cin >> n;

    vector<vector<int>> segs(n);
    vector<int> lo(n);

    for (int& l : lo)
        cin >> l;

    for (int i = 0; i < n; ++i) {
        int hi;
        cin >> hi;
        segs[lo[i]].emplace_back(hi);
    }

    priority_queue<int> seg;

    for (int lo = 0; lo < n; ++lo) {
        const auto& hi(segs[lo]);

        for (int r : hi)
            seg.emplace(-r);

        if (seg.empty()) {
            cout << "NO\n";
            return;
        }

        int curr = -seg.top();
        seg.pop();

        if (curr < lo) {
            cout << "NO\n";
            return;
        }
    }

    cout << "YES\n";
}

int main()
{
    int t;
    cin >> t;

    while (t-- > 0)
        solve_test();

    return 0;
}
```

P.S. 向优先队列中 push 负的元素可以让这些元素从小到大排列。（第 31 行）

---

## 作者：鲤鱼江 (赞：0)

简单贪心题。

省流题意：有一个大小为 $n$ 的竞赛图，问你能否将每条边定向，使得不存在环且第 $i$ 个点的出度在 $[l_i,r_i]$ 之间。

首先证明一个结论：为 DAG 的竞赛图拓扑序唯一。

从入度为 $0$ 的点下手，若证明有且仅有一个入度为 $0$ 则上面的结论可以归纳证明。

首先发现至少有一个拓扑序为 $0$ 的点，否则拓扑排序无法开始，即不存在拓扑序，与其是 DAG 相矛盾。又因为是入度为 $0$ 的点，由竞赛图的定义可知这一个点向其他所有点连边，也就是没有入度的点最多一个，由此证毕。

知道拓扑序唯一后有什么用呢？考虑竞赛图的定义，发现一个点必然向拓扑序在其之后的每一点都有一条出边，且向前没有出边，所以一个点的出度刚好是是逆拓扑序减一。

问题即转化为简单的序列贪心问题：问是否存在一个排列使得任意位置 $i$，均有 $a_i\in [l_i,r_i]$，使用 set 加排序贪心即可，属于黄题难度，不细剖析。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e5+10;
int T,n,L[N],R[N],fg,rk[N];
set < int > s;

inline bool cmp(const int x,const int y){return R[x]<R[y];}

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);s.clear();fg=0;
		for(int i=1;i<=n;++i) scanf("%d",&L[i]);
		for(int i=1;i<=n;++i) scanf("%d",&R[i]);
		for(int i=1;i<=n;++i) s.insert(rk[i]=i);
		sort(rk+1,rk+1+n,cmp);
		for(int i=1;i<=n;++i){
			++L[rk[i]];++R[rk[i]];
			auto it=s.lower_bound(L[rk[i]]);
			if(it==s.end()||((*it)>R[rk[i]])){fg=1;break;}
			s.erase(it);
		}
		if(fg) cout<<"NO\n";
		else cout<<"YES\n";
	}
	return 0;
}
```

---


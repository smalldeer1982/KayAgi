# 序列合并

## 题目描述

给定一个长度为 $n$ 的非负整数序列 $\{a_n\}$，你可以进行 $k$ 次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。

形式化地，一次操作中，你选择一个下标 $i$（$1 \le i < n$），然后把原序列变成 $\{a_1,a_2,\cdots,a_i \operatorname{or} a_{i+1},a_{i+2},\cdots,a_n\}$。

求 $k$ 次操作后所有数按位与的最大值。

## 说明/提示

**【样例解释】**

一种合法的方案：

- 第一次操作，选择第一个数和第二个数合并，序列变为 $\{3,2,3,1\}$。
- 第二次操作，选择第三个数和第四个数合并，序列变为 $\{3,2,3\}$。

最终所有数的按位与为 $2$。可以证明不存在更优的方案。

**【数据范围】**

- 对于 $25\%$ 的数据，$n \le 20$。
- 对于另外 $25\%$ 的数据，$k=n-2$。

对于所有数据，保证 $1 \le k<n \le 2 \times 10^5$，$0 \le a_i < 2^{30}$。

## 样例 #1

### 输入

```
5 2
2 1 2 3 1```

### 输出

```
2```

# 题解

## 作者：Night_sea_64 (赞：15)

首先我们知道，如果有两个正整数 $x,y$ 满足 $x\operatorname{and}y=y$ 且 $x\neq y$，即 $y$ 是 $1$ 的位上 $x$ 也是 $1$，剩下的位上 $x$ 也有 $1$，那么答案为 $x$ 肯定比答案为 $y$ 更不容易达到，并且更优。

这种情况下，可以想出一种类似二分答案但又不是的方法：因为我们需要答案最大，所以从高到低位都检验一下这一位能不能是 $1$。

检验方法是假设我们要达到答案为 $t$，从左边开始记录依次记录数的或值 $s$，如果 $s\operatorname{and}t=t$ 时段数 $+1$，$s$ 清零。如果段数 $\ge n-k$ 就说明能成功。

这是因为合并后的每一个数都对应合并前的一个连续段的或值，而合并 $k$ 次，连续段数就是 $n-k$。如果这些或值的与值要达到 $t$，那么 $t$ 的每一个为 $1$ 的位，在这些或值中必须全部为 $1$。

```cpp
#include<iostream>
using namespace std;
int n,m,k,a[200010];
int lg(int x)
{
    int cnt=0;
    while(x)x>>=1,cnt++;
    return cnt-1;
}
bool chk(int x)
{
    int sum=0,cnt=0;
    for(int i=1;i<=n;i++)
    {
        sum|=a[i];
        if((sum&x)==x)sum=0,cnt++;
    }
    return cnt>=k;
}
int main()
{
    cin>>n>>k;
    k=n-k;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        m=max(m,lg(a[i]));
    }
    int now=0;
    for(int i=m;i>=0;i--)
    {
        now+=(1<<i);
        if(!chk(now))now-=(1<<i);
    }
    cout<<now<<endl;
    return 0;
}
```

---

## 作者：GONGX (赞：4)

## 题意简述
给定一个非负整数序列 ${a_n}$，你能进行 $k$ 次操作，每次操作你可以选任意两个相邻的数合并为他们的按位或，求操作后所有数按位与的最大值。
## 解题思路
本题可以运用贪心算法的思想求解。在二进制下，由于高位的价值永远比低位高，所以我们可以从高位到低位确定答案的每一位是否可以为 $1$，若某一位可以为 $1$ 便立即更新答案。在具体实现中需要用到我们所熟知的分治算法中所常用的的判断函数：先定义一个变量 $s$，遍历一次序列，每到一个变量就将 $s$ 与其进行按位或操作，若此时二进制下查找值所有为一的位 $s$ 也为一，则将 $s$ 清零，此处不使用按位或操作，若最终按位或操作次数不超过 $k$ 则合法。
## 代码展示
```cpp
#include <iostream>
using namespace std;
const int N = 2e5 + 2;
int n, k, a[N], ans;
//检查答案中二进制下第log(x)位是否能为 1
inline bool check(int x) { 
	int sum = 0, cnt = 0;//cnt 记录按位或的操作次数
	for (int i = 1; i <= n; i++) {
		sum |= a[i];//逐位进行按位或操作 
		if ((sum & x) == x)sum = 0;//此时执行按位与
		else cnt++;//按位或操作次数加一 
	}
	return cnt <= k;//返回按位或的操作次数是否合法
}
int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++)cin >> a[i];
	for (int i = 29;i >= 0; i--)//答案在二进制下最多为 29 位 
		if(check(ans + (1 << i)))//此时二进制下第 i 位可以为一 
			ans += 1 << i;//当二进制下第 i 位可以为一时，更新答案 
	cout << ans;
	return 0;
}
```

---

## 作者：ca0vnv (赞：3)

## 题目大意
你可以进行 $k$ 次操作,把长度为 $n$ 的非负整数序列合并成它们的按位或。求 $k$ 次操作后所有数按位与的最大值。
## 解题思路
显然的，答案在二进制下的第 $i$ 位为 $1$ 一定比该位为 $0$ 更优。

故贪心的策略：考虑从高到低枚举答案的二进制位，若该位可取 $1$ 则必定贪心取 $1$（优先取位权大的），而根据这个结果再去检查后面更低位能否取。下面问题在于如何检验第 $i$ 位是否可行。由于只能合并相邻两项，故合并 $k$ 次相当于将原序列分为 $n-k$ 段，每一段内按位或。因此，考虑用 $p$ 维护当前段内的按位或值，若某一时刻 $p$ 二进制下第 $i$ 位为 $1$，且与已得出的更高位部分的答案不矛盾，则可以贪心的开启新的一段。最后仅需判断段数是否不小于 $n−k$ 即可。

时间复杂度 $O({n}\log{V})$。
## 参考代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10,V=30;
int n,k,a[N],ans;
bool check(int d){
    int res=0,p=0;
    for(int i=1;i<=n+1;i++){
        p|=a[i];
        if((p&d)==d){// 当前数 a[i] 与目标 d 位相同，则另起一段新的合并序列
            res++,p=0;
        }   
    }
    return res>=k; // true 尝试更小的 d 是否也可以行
}
int main(){
    cin>>n>>k;
    k=n-k;// 合并的次数
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=V;i>=0;i--){ // 从高位到低位枚举 “贪心的策略” 使得结果尽可能大
        if(check(ans+(1<<i))){
            ans+=(1<<i);
        }
    }
    cout<<ans<<endl;
    system("Pause>Nul");
    return 0;
}
```

---

## 作者：yr409892525 (赞：2)

## 题解 [P10512 序列合并](https://www.luogu.com.cn/problem/P10512)
我们要知道：          
$a_1 \operatorname{and} a_2 \le \min(a_1,a_2)$。               
所以合并 $k$ 次后的序列中每个数都有答案的每一位。          
所以我们直接枚举答案的每一位，判断是否可以取到。           
如何第 $i$ 位是否可以取到。           
模拟一下，如果当前的数不能包含答案。        
说明需要合并，直接和下一个合并。         
否则，就把自己分成一个类。        
如果需要合并的次数少于 $k$ 就说明可以取到第 $i$ 位。        

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int n,k;
int a[N];
bool check(int x){ //判断是否能取到第i位
	int sum=0,s=0;
	for(int i=1;i<=n;i++){
		s|=a[i];//合并
		if((s&x)==x){//等于1说明包含x，否则不能
			s=0;
		}else{
			sum++;
		} 
	}
	return (sum<=k);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int ans=0;
	for(int i=30;i>=0;i--){
		ans+=(1ll<<i);
		if(!check(ans)){
			ans-=(1ll<<i);
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：251Sec (赞：2)

进行 $k$ 次合并等价于把序列划分成 $(n-k)$ 段。

考虑从高位往低位确定答案每一位能否为 $1$，则需要处理的问题形如，钦定答案的某些二进制位必须为 $1$，问是否可行。这可以用贪心维护，维护变量 $x$，初始为 $0$，每次令 $x \gets x \operatorname{or} a_i$，如果 $x$ 满足钦定的二进制位均为 $1$ 就在这里分一段并令 $x \gets 0$。最后看是否分了至少 $(n-k)$ 段即可。

复杂度 $O(n \log V)$。

---

## 作者：csxx601cjy (赞：1)

## 题解：[P10512 序列合并](https://www.luogu.com.cn/problem/P10512)

### 题意
$k$ 次合并长为 $n$ 的序列中相邻元素为它们的按位或，求最后剩余元素按位与的最大值。

### 思路
在二进制中，越高的位，代表的数越大，价值也越高。从高位往低位枚举，判断每一位能否保留下来，尽量保留高的位。

之所以从 $29$ 开始枚举是因为 $a_i<2^{30}$。

### 代码
代码如下，稍稍有点压行：
```cpp
#include<bits/stdc++.h>
int n,k,t,i,j,cnt,ans,a[200010];
int main(){
	scanf("%d %d",&n,&k);
	for(i=0;i<n;i++)scanf("%d",&a[i]);
	for(i=30;i--;){//实际是从29枚举到0
		for(j=cnt=0,t=a[0],ans+=(1<<i);j<n;t|=a[++j])//每次取一个数按位或
			if((t&ans)==ans)t=0;//包含答案，清空t
			else cnt++;//消耗一次操作次数
		if(cnt>k)ans-=(1<<i);//次数超过，不可行
	}
	return printf("%d",ans)&0;
}
```

---

## 作者：_yang_yi_bo_ (赞：1)

枚举最高位 $i$，答案加 $2^{i-1}$，若加上 $2^{i-1}$ 不合法，答案又减 $2^{i-1}$，接着就可以去判断是否合法就行了。

怎么判断呢？我们要计算需要或多少次才能取到末尾为答案，我们可以定义一个变量 $s$，让 $s$ 一直或 $a_i$，若 $s$ 的末几位为答案，则将 $s$ 清 $0$，否则将或的次数 $+1$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,ans;
int a[200005];
bool check(int x){
	int s=0,cnt=0;
	for(int i=1;i<=n;i++){
		s|=a[i];
		if((s&x)==x){
			s=0;
		}else{
			cnt++;
		}
	}return cnt<=k;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}for(int i=30;i>=0;i--){
		ans+=(1ll<<i);
		if(!check(ans)){
			ans-=(1ll<<i);
		}
	}cout<<ans;
	return 0;
} 
```

---

## 作者：KyleShen1213 (赞：1)

## 题目大意
将一个序列进行 $k$ 次按位与操作，要使得剩下的序列按位或后得到的数最大。

## 解题思路
只有一个位上的所有数都为一，最后的数这位上才能为一。

故考虑每一位循环一次，每次判断这一位能否最后得到一，每次按位或就减去一次按位或的次数。

由于高位为一比低位为一所得的数更大，所以由高到低进行判断。

由于最大数据的二进制最长小于三十位，故从二十九位开始循环。

## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,s,m,cnt,ans;
long long a[200005];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)  cin>>a[i];
    for(int j=29;j>=0;j--)//高位优先
    {
    	ans+=(1<<j);//预处理先加上
    	s=cnt=0;
    	for(int i=1;i<=n;i++)
    	{
    		s|=a[i];
    		if((s&ans)==ans)  s=0;
    		else  cnt++;//合并一次
    	}
    	if(cnt>k)  ans-=1<<j;//合并太多才能使得这一位二进制是1
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：ty_mxzhn (赞：0)

# T3

思维题 / 典题。考察了选手的总结归纳活用知识的能力。

## 部分分

随便做，不讲。

## 正解

首先我们设一个数“包含”另一个数当这一个数的每一个二进制位如果是 $0$，则另一个数的这个二进制位一定是 $0$。

 **类比二分**，考虑从高到低按位检查每一位是否可以取到 $1$。

假设我们想让答案“包含”$t$。我们从左到右扫描，记录当前待划分的这一组目前的按位或。当这个按位或“包含”了 $t$，就新开一个段。如果段数 $\ge n-k$ 则成功。

这是因为合并后的每一个数都对应合并前的一个连续段的或值，而合并 $k$ 次，连续段数就是 $n-k$。如果这些或值的与值要“包含”$t$，那么 $t$ 的每一个为 $1$ 的位，在这些或值中必须全部为 $1$。

---

## 作者：program_xwl (赞：0)

## 思路：
如果高位可以为 $1$，那么就应该放弃低位，选高位。这是本题的贪心思想。我们可以从大到小枚举数位，如果答案的某位可以为 $1$，那么就直接将答案的其设为 $1$。

那么，如何检查某位是否可以为 $1$ 呢？这可以用贪心来维护。我们用 $x$  记录合并后的值，最开始时 $x$ 等于 $0$，因为 $0$ 按位或任何数还得原数，如果 $x \operatorname{and}a_i=a_i$ 说明 $a_i$ 不需要合并就能满足条件，这时候 $x$ 应该重新变为 $0$，因为题目不允许隔空按位或。否则计数器加一，如果计数器超过了 $k$ 说明需要操作超过 $k$ 次，答案不合法。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,k,a[200005],ans = 0;

bool check(int x)
{
	int cnt = 0,huo = 0;
	for(int i = 1;i <= n;i++)
	{
		huo |= a[i];
		if((huo&x) == x) huo = 0;//不需要合并
		else cnt++;
		if(cnt > k) return 0;//必须操作超过k此才有可能答案等于x，答案不合法
	}
	return 1;//合法答案
}

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 30;i >= 0;i--) if(check(ans|(1<<i))) ans+=(1<<i);//如果合法就加上
	cout << ans;
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

### 简化题意
题意：从 $n$ 个数子之中，一定可以或 $k$ 次，合并两个数字剩余 $n - k$ 个，找到剩余下来的 $n - k$ 个数字之中的按位与的最大值。
### 思路
1. 首先从答案出发，保证二进制高位是 $1$ 最好的。
2. 相邻的两个合并，最多合并 $k$ 次。

所以保证的点是选择的点是选择的数字一定是合并完成之后，之前选择的高位 $1$ 一定和 $sum$ 的高位 $1$ 一摸一样，如果不是的话，说明需要合并。
### 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n, k, a[N];
int ans = 0; 
bool check(int x) {
	int sum = 0, cnt = 0;
	for (int i = 1;i <= n;i ++) {
		sum |= a[i];
		if ((sum & x) == x) { // 不需要继续合并 
			sum = 0;
		} else {
			cnt ++; // 需要合并 
		}
	} 
	return cnt <= k;
} 
signed main() {
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> k;
	for (int i = 1;i <= n;i ++) {
		cin >> a[i];    
	}
	for (int j = 31;j >= 0;j --) {
		ans += (1 << j);
		if (!check(ans)) {
			ans -= (1 << j);
		}
	}
	cout << ans << endl; 
	return 0;
}
```

---

## 作者：sieve (赞：0)

# 题解：[P10512 序列合并](https://www.luogu.com.cn/problem/P10512)

## 思路

我们需要知道：$a \operatorname{and} b \le \min(a,b)$，所以，我们就得让最后答案的最高位尽可能的是 $1$。

我们枚举每一位，判断答案能否取到第 $i$ 位，如果能取到，则答案加上 $2^i$，也就是二进制中这一位的值。

我们用一个 $s$ 变量来记录当前所有数字按位或的值，如果 $s \operatorname{and} i = i$，说明包含了 $i$，不行，将 $s$ 设为 $0$，否则合并一次。

最后判断合并的次数是不是小于等于 $k$ 就行了。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
int n,k,a[N],ans;
bool check(int x)//检查能否取这一位
{
	int s=0,cnt=0;
	for(int i=1;i<=n;++i)
	{
		s|=a[i];//合并
		if((s&x)==x) s=0;//包含了这一位，不行
		else cnt++;//合并次数加一
	}
	return cnt<=k;
}
signed main()
{
	ios::sync_with_stdio(false);//关闭同步流，可不加
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=30;i>=0;--i)
	{
		ans+=(1<<i);//先取
		if(!check(ans)) ans-=(1<<i);//如果不满足，不取
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Big_Dinosaur (赞：0)

本题与 [CF981D](https://www.luogu.com.cn/problem/CF981D) 有类似之处。

首先，试题涉及二进制，可以从二进制角度考虑。尽可能让答案高位为 $1$，这样答案更大。

理由显然，一个数其中一位为 $1$，即使后面为 $0$，比这一位为 $0$ 而后面为 $1$ 的数要大。

如何判答案 $a$ 是否合法？可以把数组分段，每或一次长度减一，最终每一段变成所有数按位或后的值。最终若存在一种分法，段数 $a$ 满足 $n-a\le k$ 且每段变成的值按位与后再与 $a$ 为 $a$，则 $a$ 合法。

初始答案 $A=0$，从高到低枚举 $x$，若 $A+2^x$ 合法，就让 $A$ 加上 $2^x$（加可以用按位或）。答案为 $A$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
#define pii pair<int,int>
#define mp make_pair
#define fi first
#define se second
using namespace std;
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
		#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
		#define gh() getchar()
	#endif
	inline int r(){
		int o=1,p=0;
		char q=gh();
		while(q<'0'||q>'9'){if(q=='-')o=-1;q=gh();}
		while(q>='0'&&q<='9'){p=(p<<1)+(p<<3)+(q^48);q=gh();}
		return o*p;
	}
	inline char gc(){char q=gh();while(q<=' ')q=gh();return q;}
	inline string gs(){string s="";char g=gh();while(g<=' ')g=gh();while(g>' '){s+=g;g=gh();}return s;}
	inline void Wi(int YSC){
		if(YSC==0)return;if(YSC<0){YSC=-YSC;putchar('-');}
		Wi(YSC/10);putchar((YSC%10)^48);
	}
	inline void wln(int J){if(J==0)putchar('0');else Wi(J);putchar('\n');}
	inline void w(int J){if(J==0)putchar('0');else Wi(J);}
	inline void ww(int J){if(J==0)putchar('0');else Wi(J);putchar(' ');}
}
using namespace IO;
namespace D1n0{
	int n,k,a[213333];
	inline bool check(int x){
		int OR=0,Cnt=0;
		for(ri i=1;i<=n;++i){
			OR|=a[i];
			if((OR&x)==x)OR=0,++Cnt;
		}
		if(n-Cnt<=k)return 1;
		return 0;
	}
	inline void zyt(){
		n=r(),k=r();
		for(ri i=1;i<=n;++i)a[i]=r();
		int Ans=0;
		for(ri i=30;i>=0;--i)if(check(Ans|(1<<i)))Ans|=(1<<i);
		w(Ans);
	}
}
signed main(){
	D1n0::zyt();
}
```

---

## 作者：xiao7_Mr_10_ (赞：0)

显然这道题我们可以吧与看做一种无限制次数的操作，其实也不太准确，反正可以吧与当做一种类似于或的情况处理。

这种题套路都是按位枚举，然后贪心。这题就是枚举最高位然后判断下行不行。

具体的，先无脑或，记录一下目前或的数和，然后查一下是不是 $x$，不是的话就直接计入操作，反之我们就可以把和设为 $0$ 表示不需要或，然后最后判断一下用的次数超没超过 $k$ 就行了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,a[N],ans,k;
bool check(int x){
	int num=0,cnt=0;
	for(int i = 1;i <= n;i++)num|=a[i],((num&x)==x) ? num = 0 : cnt++;
	return cnt<=k;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for(int i = 1;i <= n;i++)cin >> a[i];
	for(int i = 30;i >= 0;i--)check(ans+(1<<i)) ? ans+=(1<<i) : ans=ans;
	cout << ans;
	return 0;
}
```

---

## 作者：tder (赞：0)

很好的 trick 啊。

显然的，答案在二进制下的第 $i$ 位为 $1$ 一定比该位为 $0$ 更优。故考虑从高到低枚举答案的二进制位，若该位可取 $1$ 则必定贪心取 $1$，而根据这个结果再去检查后面更低位能否取。

下面问题在于如何检验第 $i$ 位是否可行。由于只能合并相邻两项，故合并 $k$ 次相当于将原序列分为 $n-k$ 段，每一段内按位或。因此，考虑用 $p$ 维护当前段内的按位或值，若某一时刻 $p$ 二进制下第 $i$ 位为 $1$，且与已得出的更高位部分的答案不矛盾，则可以贪心的开启新的一段。最后仅需判断段数是否不小于 $n-k$ 即可。 

时间复杂度 $O(n\log V)$。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N = 2e5 + 5, V = 30;
int n, k, a[N], ans;
bool check(int d) {
	int r = 0, p = 0;
	for(int i = 1; i <= n + 1; i++) {
		p |= a[i];
		if((p & d) == d) r++, p = 0;
	}
	return r >= k;
}
signed main() {
	cin>>n>>k; k = n - k;
	for(int i = 1; i <= n; i++) cin>>a[i];
	for(int i = V; i >= 0; i--) if(check(ans + (1 << i))) ans += (1 << i);
	cout<<ans<<endl;
}
```

---

## 作者：abc1856896 (赞：0)

# 题意

把序列分成 $n-k$ 段。每一段的值为这些数按位或。答案为分完段后每一段按位与的值。

求最大的答案。

# solution

考虑二进制的做法。

既然我们需要使得答案最大化，那么我们可以从高到低位都判断一下这一位是否可以是 $1$。

判断函数如下：

设一个变量 $kk$，初始值为 $0$，每次使 $kk \gets k k\operatorname{or} a_i$，如果 $kk$ 满足钦二进制位均为 $1$ 就在这里分一段。

然后使 $kk$ 的值为 $0$。最后看是否分了 $(n-k)$ 段即可。

~~怎么那么像二分嘚~~

# code
放个判断函数吧。

```cpp
#define int long long
bool check(int x){
	int kk=0,cnt=0;
	for (int i=1;i<=n;i++){
		kk|=a[i];
		if((kk&x)==x){
			kk=0;
			cnt++;
		}
	}
	return cnt>=k;
}
```

---


# [ROI 2017] 排序幻觉 (Day 1)

## 题目描述

给定长度为 $n$ 的整数数列 $a$，如果一个整数 $b$ 满足：

$$
(a_1 \operatorname{xor} b) \le (a_2 \operatorname{xor} b) \le \dots \le (a_n \operatorname{xor} b)
$$

则称 $b$ 是 $a$ 数列的**幻数**。

接下来有 $q$ 次修改，每次修改一个数 $a_{u_i}$ 为整数 $k_i$，每次修改都会对后面的询问产生影响。你需要求出第一次修改前以及每次修改后这个数列的最小的幻数是多少，特别的，如果不存在幻数请输出 $-1$。

## 说明/提示

#### 【数据范围】

| 子任务编号 | 分值 | $1 \le n \le$ | $1 \le q \le $ | $0 \le a_i,k_i \le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $500$ | $500$ | $2^9$ |
| $2$ | $29$ | $10^3$ | $10^3$ | $2^{30}$ |
| $3$ | $21$ | $10^5$ | $10^5$ | $2^{30}$ |
| $4$ | $30$ | $10^6$ | $10^6$ | $2^{30}$ |


## 样例 #1

### 输入

```
3
0 1 4
3
2 7
3 3
1 4```

### 输出

```
0
2
-1
4```

# 题解

## 作者：FFTotoro (赞：2)

感觉完全不到蓝题。下文 $\oplus$ 表示按位异或。

考虑把所有的条件拆开来处理最后再合并，即考虑确定 $x,y$ 时，一个非负整数 $b$ 满足$(x\oplus b)\le(y\oplus b)$ 的充要条件是什么：

- 当 $x=y$ 时，显然 $b$ 可以取全体非负整数；
- 当 $x\ne y$ 时，考虑 $c=x\oplus y$ 在二进制下的最高位 $\mathrm{highbit}(c)$（即 $x$ 和 $y$ 最高的不相同的位），显然 $b$ 在这一位的取值决定了 $x$ 和 $y$ 的大小，故如果 $x<y$ 那么 $b$ 该位应为 $0$，否则为 $1$；$b$ 的其他位可以随便取。

于是对于每个 $x=a_{i-1},y=a_i$ 考虑 $b$ 的取值；把所有条件联立起来发现 $b$ 的某些位的值已经确定了，但是有可能某两个条件会冲突，即一个要求 $b$ 的某一位为 $1$ 另一个要求为 $0$，此时就不存在符合条件的 $b$；否则先满足所有的条件，其他所有位都取 $0$ 即可求出最小的 $b$。

修改操作是容易的，只需要把原来相邻的**两对数**（$(a_{p-1},a_p)$ 和 $(a_p,a_{p+1})$）的条件撤销，修改之后再加上新的条件即可。令 $V=\max a_i$，则时间复杂度为 $O(n+q\log V)$，只要实现不是很差 $2\mathrm{s}$ 随便过。

求 $\mathrm{highbit}$ 可以借助 `__builtin_clz` 函数，该函数可以返回一个无符号整数二进制表示下前导零的个数（默认是 $32$ 位的，`__builtin_clzll` 则是 $64$ 位的）；所以用 $31$ 减去其值，即可得到一个二进制数的最高位是从右往左的第几个位置。

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  ios::sync_with_stdio(false);
  int n; cin>>n;
  vector<int> a(n);
  for(auto &i:a)cin>>i;
  vector<array<int,2> > c(31);
  auto f=[&](int p,int d){
    if(int r=a[p-1]^a[p];r)
      c[31-__builtin_clz(r)][a[p-1]>a[p]]+=d;
  }; // 加入（d = 1）/ 撤销（d = -1）一个条件
  auto r=[&](){
    int w=0;
    for(int i=0;i<31;i++)
      if(c[i][1]){
        if(c[i][0])return -1; // 矛盾
        w|=1<<i; // 该位需要为 1
      }
    return w;
  }; // 求解最小的 b
  for(int i=1;i<n;i++)
    f(i,1); // 初始化
  cout<<r()<<'\n';
  int q; cin>>q;
  while(q--){
    int p,x,c=0; cin>>p>>x,p--;
    if(p<n-1)f(p+1,-1); if(p)f(p,-1); // 撤销
    if(a[p]=x;p<n-1)f(p+1,1); if(p)f(p,1); // 加入
    cout<<r()<<'\n';
  }
  return 0;
}
```

---

## 作者：Beihai_Jiang (赞：1)

# P10650 [ROI 2017] 排序幻觉 (Day 1)

[P10650 [ROI 2017\] 排序幻觉 (Day 1) - 洛谷](https://www.luogu.com.cn/problem/P10650)

## 题目描述

给定长度为 $n$ 的整数数列 $a$，如果一个整数 $b$ 满足：

$$
(a_1 \operatorname{xor} b) \le (a_2 \operatorname{xor} b) \le \dots \le (a_n \operatorname{xor} b)
$$

则称 $b$ 是 $a$ 数列的**幻数**。

接下来有 $q$ 次修改，每次修改一个数 $a_{u_i}$ 为整数 $k_i$，每次修改都会对后面的询问产生影响。你需要求出第一次修改前以及每次修改后这个数列的最小的幻数是多少，特别的，如果不存在幻数请输出 $-1$。

## Solution

对于 $a_i$ 和 $a_{i+1}$，在二进制上从高位到低位第一个不相同的位记为第 $k$ 位。

若 $a_i=a_{i+1}$，不做任何处理。因为两数无论异或何值都相等。

若 $a_{i}<a_{i+1}$，则 $b$ 二进制的第 $k$ 位一定为 $0$。否则会有 $a_i'>a_{i+1}'$。

若 $a_i>a_{i+1}$，则 $b$ 二进制的第 $k$ 位一定为 $1$。否则会有 $a_i'>a_{i+1}’$。

若 $b$ 的某一位一定为 $0$ 且一定为 $1$，则没有幻数，输出 $-1$。

注意修改 $a_u$ 后，只需更新 $a_{u-1},a_u$ 和 $a_u,a_{u+1}$ 的贡献。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,q;
int a[N];
int b[2][35];
int ans,cnt;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n;i++){
		if(a[i]==a[i+1]) continue;
		int temp=a[i]^a[i+1];
		int k=log2(temp);
		if(a[i]<a[i+1]){
			b[0][k]++;
			if(b[0][k]==1 && b[1][k]>0) cnt++,ans-=pow(2,k);
		}
		else{
			b[1][k]++;
			if(b[1][k]==1 && b[0][k]>0) cnt++;
			else if(b[1][k]==1) ans+=pow(2,k);
		}
	}
	if(cnt>0)
		cout<<-1<<"\n";
	else
		cout<<ans<<"\n";
	cin>>q;
	for(int i=1;i<=q;i++){
		int u,y;
		cin>>u>>y;
		if(u-1>0 && a[u-1]!=a[u]){
			int temp=a[u-1]^a[u];
			int k=log2(temp);
			if(a[u-1]<a[u]){
				b[0][k]--;
				if(!b[0][k] && b[1][k]>0) cnt--,ans+=pow(2,k);
			}
			else{
				b[1][k]--;
				if(!b[1][k] && b[0][k]>0) cnt--;
				else if(!b[1][k]) ans-=pow(2,k);
			}
		}
		if(u+1<=n && a[u]!=a[u+1]){
			int temp=a[u]^a[u+1];
			int k=log2(temp);
			if(a[u]<a[u+1]){
				b[0][k]--;
				if(!b[0][k] && b[1][k]>0) cnt--,ans+=pow(2,k);	
			}
			else{
				b[1][k]--;
				if(!b[1][k] && b[0][k]>0) cnt--;
				else if(!b[1][k]) ans-=pow(2,k);
			}
		}
		a[u]=y;
		if(u-1>0 && a[u-1]!=a[u]){
			int temp=a[u-1]^a[u];
			int k=log2(temp);
			if(a[u-1]<a[u]){
				b[0][k]++;
				if(b[0][k]==1 && b[1][k]>0) cnt++,ans-=pow(2,k); 
			}
			else{
				b[1][k]++;
				if(b[1][k]==1 && b[0][k]>0) cnt++;
				else if(b[1][k]==1) ans+=pow(2,k);
			}
		}
		if(u+1<=n && a[u]!=a[u+1]){
			int temp=a[u]^a[u+1];
			int k=log2(temp);
			if(a[u]<a[u+1]){
				b[0][k]++;
				if(b[0][k]==1 && b[1][k]>0) cnt++,ans-=pow(2,k); 
			}
			else{
				b[1][k]++;
				if(b[1][k]==1 && b[0][k]>0) cnt++;
				else if(b[1][k]==1) ans+=pow(2,k);
			}
		}
		if(cnt>0)
			cout<<-1<<"\n";
		else
			cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：_Supernova (赞：1)

### 一、分析性质。

对于 $(a_i \operatorname{xor} x) \le (a_{i+1} \operatorname{xor} x)$ 这一条件，我们如下分析性质：

若 $a_i=a_{i+1}$，则无任何影响；
否则，我们设他们最高不同位为第 $k$ 位，若 $a_i<a_{i+1}$，则有 $a_i$ 在此位为 $0$，$a_{i+1}$ 在此位为 $1$，则 $x$ 这一位必须为 $0$ 才能满足条件。
反之，若 $a_i>a_{i+1}$，则同理，$x$ 这一位为 $1$ 才能满足条件。

### 二、构造代码。

针对如上性质，我们设一个数组 $ar_{i,j}$，其中 $0<i<31$，即最高位数，$0 \le j \le 1$。

$ar_{i,j}$ 表示第 $i$ 位，限制 $x$ 这一位为 $j$ 的限制个数。

对于原序列，我们先预处理出 $ar$ 数组，对于每个询问，因为单点修改至多影响 $2$ 个性质，修改即可，再输出答案。

### 三、代码分块讲解。

输入略。

```cpp
for (int i = 2; i <= n; ++i) {
    work(i, 1);
}
```

对于原序列，逐个修改，接下来我们讲解这个函数。
$1$ 表示贡献为 $1$。

```cpp
void work(int x, int num) {
	int tmp = a[x] ^ a[x - 1];
	if (tmp == 0) return ;
	else {
		int k = get_pos(tmp);
		if (a[x - 1] > a[x]) {
			ar[k][1] += num;
		}
		else {
			ar[k][0] += num;
		}
	}
	return ;
}
```

若 $tmp$ 为 $0$，表示 $2$ 数相同，无影响。$k$ 表示最高不相同的位数，$num$ 表示贡献。

```cpp
while (m--) {
		scanf("%d %d", &p, &val);
		if (p > 1) work(p, -1);
		if (p < n) work(p + 1, -1);
		a[p] = val;
		if (p > 1) work(p, 1);
		if (p < n) work(p + 1, 1);
		printf("%d\n", solve());
	}
```

对于每个询问，先去掉以前的贡献，再加上新的贡献，记得判断边界。接下来讲解求解函数。

```cpp
int solve(void) {
	int res = 0;
	for (int i = 0; i <= 30; ++i) {
		if (ar[i][0] && ar[i][1]) return -1;
		else if (ar[i][0]) ;
		else if (ar[i][1]) res += (1 << i);
		else ;
	}
	return res;
}
```

若第 $i$ 位 $0$ 和 $1$ 限制都有，无法同时满足，则不存在，返回 $-1$。反之，若限制为 $1$，则要求 $x$ 这一位为 $1$，加上即可。

代码还有其他部分，留给读者自行编写。

这是我的提交记录：[记录和代码](https://www.luogu.com.cn/record/190467837)

### 四、答疑。

欢迎提问！

---

## 作者：UUSamuel (赞：1)

对于解题思路，其他的题解阐述得已经非常好。这里提供一个比较容易理解的代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int n, Q;
long long a[1000001], b[31][2];//b[i][0]>=1表示b的从右往左数的第i位（i从0开始）需要是0

int out(){//计算并输出当前的最小幻数
	long long ret = 0;
	for(int i = 0; i <= 30; i++){
		if(b[i][1])
			if(b[i][0])
				return -1;//第i位既要是1，又要是0，矛盾，故返回-1
			else
				ret += pow(2, i);//第i位一定得是1，反映到十进制上就是答案加上2的i次方
	}
	return ret;
}

void build(int tag, int x, int y//更改对b的约束
	if(x == y)	return;//x=y，则不会对约束造成影响
	int p = 31-__builtin_clz(x ^ y);
		if(x > y)
			b[p][1] += tag;
		else
			b[p][0] += tag;
	return;
}

int main(){
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	
	for(int i = 1; i <= n-1; i++)
		build(1, a[i], a[i+1]);//计算两两相邻的数对b产生的约束
	cout << out() << endl;
	
	cin >> Q;
	while(Q--){
		int u, k;
		cin >> u >> k;
		for(int i = max(1, u-1); i <= min(n-1, u); i++)
			build(-1, a[i], a[i+1]);//先清除原先的数对b产生的约束
		a[u] = k;
		for(int i = max(1, u-1); i <= min(n-1, u); i++)
			build(1, a[i], a[i+1]);//再把新的数对b产生的约束算上
		cout << out() << endl;
	}
	return 0;
}//不要抄答案
```

---

## 作者：Swirl (赞：1)

- $\texttt {2024/8/29}$：更正了题解中的一处笔误。

> 涉及知识点：数学。

对于一个满足 $(a_{x - 1} \operatorname{xor} b) \le (a_{x} \operatorname{xor} b)$ 的 $x$，我们进行以下分析：

设 $i$ 为 $a_{x - 1}$ 和 $a_x$ 转成二进制后的从左往右数的第一位不同的位置（即 $\text{highbit}(a_{x-1} \operatorname{xor} a_x)$）。

则 $b$ 的第 $i$ 位决定了 $(a_{x - 1} \operatorname{xor} b)$ 和 $(a_{x} \operatorname{xor} b)$ 的大小关系。

- 如果 $a_{x - 1} \lt a_x$，则 $b$ 的第 $i$ 位为 $0$。
- 如果 $a_{x - 1} \gt a_x$，$b$ 的第 $i$ 位为 $1$。
- 特别的，如果 $a_{x - 1} = a_x$，$b$ 的第 $i$ 位没有任何限制。

则我们可以得到若干组对 $b$ 的约束条件，只需要求出满足该条件最小的 $b$ 即可。

如果有两组条件互相矛盾（形如 $b$ 的第 $i$ 位既为 $1$ 又为 $0$ 的情况），输出 `-1` 即可。

```cpp
namespace zqh {
int n, a[1000005], b[35][2];

int get(int x) {
    for (int i = 30; i >= 0; i--) {
        if (x & (1 << i)) {
            return i;
        }
    }
}

void change(int i, int eps) {
    int tmp = a[i] ^ a[i - 1];
    if (tmp != 0) {
        b[get(tmp)][a[i - 1] > a[i]] += eps;
    }
}

int getb() {
    int ret = 0;
    for (int i = 0; i < 31; i++) {
        if (b[i][0] && b[i][1])
            return -1;
        if (b[i][1]) {
            ret += (1 << i);
        }
    }
    return ret;
}

void init() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
}

void solve() {
    for (int i = 2; i <= n; i++) {
        change(i, 1);
    }
    cout << getb() << endl;
    int q;
    cin >> q;
    while (q--) {
        int u, k;
        cin >> u >> k;
        if (u - 1 >= 1)
            change(u, -1);
        if (u + 1 <= n)
            change(u + 1, -1);
        a[u] = k;
        if (u - 1 >= 1)
            change(u, 1);
        if (u + 1 <= n)
            change(u + 1, 1);
        cout << getb() << endl;
    }
}

void main() {
    init();
    solve();
}
}  // namespace zqh
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10650)。
## 思路
考虑什么时候 $a_i\operatorname{xor} b\le a_{i+1}\operatorname{xor} b$ 成立。

当 $a_i=a_{i+1}$ 时，式子显然成立；否则有 $a_i\operatorname{xor} b< a_{i+1}\operatorname{xor} b$ 时，也就是 $a_i\operatorname{xor} b$ 和 $a_{i+1}\operatorname{xor} b$ 在二进制下的最高不同位分别为 $0,1$。记 $a_i,a_{i+1}$ 在二进制下的最高不同位为 $k$，那么当 $a_i<a_{i+1}$ 时，$a_i$ 二进制的第 $k$ 位为 $0$，$a_{i+1}$ 二进制的第 $k$ 位为 $1$，也就是说 $b$ 二进制的第 $k$ 为 $0$，反之则 $b$ 二进制的第 $k$ 位为 $1$。

于是可以先预处理一遍，记录 $b$ 二进制每一位为 $0$ 的约束个数 $b_{i,0}$ 和为 $1$ 的约束个数 $b_{i,1}$，那么若 $b_{i,0},b_{i,1}$ 都大于 $0$ 则无解，否则有解。

进行修改操作时，发现修改 $a_i$ 只会使得 $b$ 的两个约束改变，因此先删去之前的约束再加上新的约束即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5,P=35;
int a[N][P],s[N],n,q,sit,dat;
int f[P],vis[P][2];
int law(int pos) {//找到最高不同位
	if(a[pos][0]!=a[pos+1][0]) return max(a[pos][0],a[pos+1][0]);
	for(int i=max(a[pos][0],a[pos+1][0]);i>=1;i--) {
		if(a[pos][i]!=a[pos+1][i]) return i;
	}
	return 0;
}
int J() {//预处理
	for(int i=1;i<n;i++) {
		int tis=law(i);
		if(s[i]<s[i+1]) {
			vis[tis][0]++;
		}
		if(s[i]>s[i+1]) {
			vis[tis][1]++;
		}
	}
	int ans=0;
	for(int i=P-1;i>=1;i--) {//计算 b
		if(vis[i][0]) f[i]=0;//计算二进制下 b 的每一位
		else if(vis[i][1]) f[i]=1;
		else f[i]=0;
		ans=ans*2+f[i];
		if(vis[i][0]&&vis[i][1]) return -1;
	}
	return ans;
}
void del(int pos) {//删去约束
	for(int i=max(pos-1,1);i<=min(pos,n-1);i++) {//注意边界
		int tis=law(i);
		if(s[i]<s[i+1]) {
			vis[tis][0]--;
		}
		if(s[i]>s[i+1]) {
			vis[tis][1]--;
		}
	}
}
int j(int pos) {//添加约束
	for(int i=max(pos-1,1);i<=min(pos,n-1);i++) {
		int tis=law(i);
		if(s[i]<s[i+1]) {
			vis[tis][0]++;
		}
		if(s[i]>s[i+1]) {
			vis[tis][1]++;
		}
	}
	int ans=0;
	for(int i=P-1;i>=1;i--) {
		if(vis[i][0]) f[i]=0;
		else if(vis[i][1]) f[i]=1;
		else f[i]=0;
		ans=ans*2+f[i];
		if(vis[i][0]&&vis[i][1]) return -1;
	}
	return ans;
}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		scanf("%d",&s[i]);
		int l=0,k=s[i];
		while(k) a[i][++l]=k%2,k/=2;
		a[i][0]=l;
	}
	cout<<J()<<endl;
	cin>>q;
	for(int i=1;i<=q;i++) {
		scanf("%d %d",&sit,&dat);
		del(sit);
		s[sit]=dat;
		for(int j=1;j<=a[sit][0];j++) a[sit][j]=0;
		int l=0;
		while(dat) a[sit][++l]=dat%2,dat/=2;
		a[sit][0]=l;
		cout<<j(sit)<<endl;
	}
}
```

---

## 作者：E_M_T (赞：0)

简单题。

按位考虑，设 $a_{i}$ 和 $a_{i-1}$ 二进制上从高到低第一个不一样的是第 $k$ 位。显然 $a_i$ 和 $a_{i-1}$ 是根据这一位比大小的。

若要满足条件则必须满足 $a_i$ 的第 $k$ 位是 $1$。

则如果不满足条件，$b$ 这一位上就需要为 $1$，若有矛盾则无解。

具体来讲，设 $s_k$ 和 $t_k$ 为此情况上 $a_i=1$
以及 $a_i=0$ 的 $i$ 的数量。

合法即 $t_k=0$。若 $b$ 这一位上改变会调换 $s_k$ 和 $t_k$。

则若 $t_k>0,s_k=0$，将 $b$ 这一位设为 $1$，若 $s_k>0,t_k>0$ 则无解。

修改先把原来的贡献减掉再加上新的即可，$O(\log V)$ 是容易的。

```cpp
#include<bits/stdc++.h>
#define sd std::
#define int long long
#define F(i,a,b) for(int i=(a);i<=(b);i++)
#define ff(i,a,b) for(int i=(a);i>=(b);i--)
#define MIN(x,y) (x<y?x:y)
#define MAX(x,y) (x>y?x:y)
#define me(x,y) memset(x,y,sizeof x)
#define pii sd pair<int,int>
#define X first
#define Y second
#define Fr(a) for(auto it:a)
int read(){int w=1,c=0;char ch=getchar();for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;for(;ch>='0'&&ch<='9';ch=getchar()) c=(c<<3)+(c<<1)+ch-48;return w*c;}
void printt(int x){if(x>9) printt(x/10);putchar(x%10+48);}
void print(int x){if(x<0) putchar('-'),printt(-x);else printt(x);}
void put(int x){print(x);putchar('\n');}
void printk(int x){print(x);putchar(' ');}
const int N=1e6+10;
int n,q,a[N];
int s[110],t[110];
void solve()
{
	n=read();
	F(i,1,n) a[i]=read();
	F(i,2,n)
	{
		ff(k,31,0)
		{
			int p1=(a[i]>>k)&1,p2=(a[i-1]>>k)&1;
			if(p1!=p2)
			{
				if(p1==1) s[k]++;
				if(p2==1) t[k]++;
				break;
			}
		}
	}
	int ans=0;
	ff(k,31,0)
	{
		if(s[k]>0&&t[k]>0)
		{
			ans=-1;
			break;
		}
		if(t[k]>0&&s[k]==0) ans+=1<<k;
	}
	put(ans);
	q=read();
	F(i,1,q)
	{
		int x=read(),y=read();
		if(x!=1)
		{
			ff(k,31,0)
			{
				int p1=(a[x]>>k)&1,p2=(a[x-1]>>k)&1;
				if(p1!=p2)
				{
					if(p1==1) s[k]--;
					if(p2==1) t[k]--;
					break;
				}
			}
		}
		if(x!=n)
		{
			ff(k,31,0)
			{
				int p1=(a[x+1]>>k)&1,p2=(a[x]>>k)&1;
				if(p1!=p2)
				{
					if(p1==1) s[k]--;
					if(p2==1) t[k]--;
					break;
				}
			}
		}
		a[x]=y;
		if(x!=1)
		{
			ff(k,31,0)
			{
				int p1=(a[x]>>k)&1,p2=(a[x-1]>>k)&1;
				if(p1!=p2)
				{
					if(p1==1) s[k]++;
					if(p2==1) t[k]++;
					break;
				}
			}
		}
		if(x!=n)
		{
			ff(k,31,0)
			{
				int p1=(a[x+1]>>k)&1,p2=(a[x]>>k)&1;
				if(p1!=p2)
				{
					if(p1==1) s[k]++;
					if(p2==1) t[k]++;
					break;
				}
			}
		}
		ans=0;
		ff(k,31,0)
		{
			if(s[k]>0&&t[k]>0)
			{
				ans=-1;
				break;
			}
			if(t[k]>0&&s[k]==0) ans+=1<<k;
		}
		put(ans);
	}
}
signed main()
{
	int T=1;
//	T=read();
	while(T--) solve();
    return 0;
}
```

---

## 作者：OrinLoong (赞：0)

## LGP10650 [ROIR 2017] 排序幻觉 学习笔记

[Luogu Link](https://www.luogu.com.cn/problem/P10650)

### 题意简述
给定长度为 $n$ 的整数数列 $A$，$m$ 次单点修改。在第 $0$ 到 $m$ 次修改后确定一个最小的 $b$，满足 $(a_1 \oplus b)\le (a_2 \oplus b)\le \cdots (a_n \oplus b)$。

### 做法解析
这一长为 $n$ 的数列实质上是对 $b$ 的 $n-1$ 个限制条件。我们考虑 $(a_i \oplus b)\le (a_{i+1} \oplus b)$ 怎么限制 $b$ 的范围：若 $a_i=a_{i+1}$ 则没有影响，否则设 $a_i$ 和 $a_{i+1}$ 不同的最高位为第 $k$ 位，$a_i<a_{i+1}$ 则 $b$ 在此位必须为 $1$，反之则必须为 $0$。所以我们可以把“$b$ 的第 $k$ 位必须填 $0/1$”这种限制装进桶里。当我们确定 $b$ 时就从高位往低贪，如果当前位既必须要选 $0$ 又必须要选 $1$ 则无解。否则能选 $0$ 就选 $0$。

至于修改，实际上就是对桶的四次单点修，十分简单。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace obasic{
    template <typename _T>
    void readi(_T &x){
        _T k=1;x=0;char ch=getchar();
        for(;!isdigit(ch);ch=getchar())if(ch=='-')k=-1;
        for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+ch-'0';
        x*=k;return;
    }
    template <typename _T>
    void writi(_T x){
        if(x<0)putchar('-'),x=-x;
        if(x>9)writi(x/10);
        putchar(x%10+'0');
    }
};
using namespace obasic;
const int MaxN=1e6+5;
int N,A[MaxN],M,X,Y,buc[31][2];
void update(int x,int y,int v){
    for(int i=30,w,cl,cr;~i;i--){
        cl=(x>>i)&1,cr=(y>>i)&1;
        if(cl!=cr){buc[i][cl]+=v;break;}
    }
}
int solve(){
    int res=0;
    for(int i=30;~i;i--){
        if(buc[i][0]&&buc[i][1])return -1;
        if(buc[i][1])res|=(1<<i);
    }
    return res;
}
int main(){
    readi(N);
    for(int i=1;i<=N;i++)readi(A[i]);
    for(int i=1;i<N;i++)update(A[i],A[i+1],1);
    writi(solve()),puts("");
    readi(M);while(M--){
        readi(X),readi(Y);int tmp=A[X];A[X]=Y;
        if(X>1)update(A[X-1],tmp,-1),update(A[X-1],A[X],1);
        if(X<N)update(tmp,A[X+1],-1),update(A[X],A[X+1],1);
        writi(solve()),puts("");
    }
    return 0;
}
```

### 反思总结
为什么这题有贪心又有位运算，却不往 01Trie 上面想呢？因为这道题位与位之间**完全**无关。

---

## 作者：tai_chi (赞：0)

#### 题意

给定序列 $a$，找到最小的 $x$ 满足：$p_i=a_i \oplus x$ 是单调递增序列。

$q$ 次单点修，给出修改后的答案。

#### 分析

拆位考虑。注意到 $x$ 的某一位为 $1$ 的影响就是 $a$ 的所有数该位反转。

考虑相邻两个数 $(a_i,a_{i+1})$ 之间的限制。发现只有这两个数最高的不同的一位会影响 $x$ 的取值。

- `0 1`：$x$ 的这一位必为 $0$；
- `1 0`：$x$ 的这一位必为 $1$:
- `0 0` 或 `1 1`：$x$ 的这一位无限制。

对每一位维护两个 $cnt$ 分别表示限制 $0$ 和限制 $1$ 的数量，若某一位两个限制都有则无解，有一个限制则按限制来，没有限制我们贪心选择更小的 $0$。

对于单点修改 $(pos,val)$ 只需要考量 $(a_{pos-1},a_{pos}),(a_{pos},a_{pos+1})$ 产生了什么变化就行了，将原来的贡献减去再加上新的贡献，维护 $cnt$ 也是好做的。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)

const int N=1e6+5;
int n,a[N];
int cnt1[35],cnt2[35];

int hibit(int x)
{
	for(int j=30;j>=0;j--) if((x>>j)&1) return j;
	return 0;
}
int f(int x,int k)
{
	return ((x>>k)&1);
}

signed main()
{
	IOS;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n-1;i++)
	{
		int j=hibit(a[i]^a[i+1]);
		if(f(a[i],j)<f(a[i+1],j)) cnt1[j]++;
		if(f(a[i],j)>f(a[i+1],j)) cnt2[j]++;
	}
	int ans=0,flag=1;
	for(int j=0;j<=30;j++)
	{
		if(cnt1[j]&&cnt2[j]) {flag=0; break;}
		if(cnt2[j]) ans+=(1<<j);
	}
	if(flag==0) cout<<-1<<"\n";
	else cout<<ans<<"\n";
	int q; cin>>q;
	while(q--)
	{
		int p,x; cin>>p>>x;
		if(p!=1)
		for(int j=30;j>=0;j--)
		{
			if(f(a[p-1],j)<f(a[p],j)) {cnt1[j]--; break;}
			if(f(a[p-1],j)>f(a[p],j)) {cnt2[j]--; break;}
		}
		if(p!=n)
		for(int j=30;j>=0;j--)
		{
			if(f(a[p],j)<f(a[p+1],j)) {cnt1[j]--; break;}
			if(f(a[p],j)>f(a[p+1],j)) {cnt2[j]--; break;}
		}
		a[p]=x;
		if(p!=1)
		for(int j=30;j>=0;j--)
		{
			if(f(a[p-1],j)<f(a[p],j)) {cnt1[j]++; break;}
			if(f(a[p-1],j)>f(a[p],j)) {cnt2[j]++; break;}
		}
		if(p!=n)
		for(int j=30;j>=0;j--)
		{
			if(f(a[p],j)<f(a[p+1],j)) {cnt1[j]++; break;}
			if(f(a[p],j)>f(a[p+1],j)) {cnt2[j]++; break;}
		}
		ans=0,flag=1;
		for(int j=30;j>=0;j--)
		{
			if(cnt1[j]&&cnt2[j]) {flag=0; break;}
			if(cnt2[j]) ans+=(1<<j);
		}
		if(flag==0) cout<<-1<<"\n";
		else cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：Nygglatho (赞：0)

观察异或（$\oplus$）的性质。

如果 $b$ 二进制第 $i$ 位为 $1$，则 $a$ 数组第 $i$ 位全体翻转。

令 $f_{i,j}$ 表示二进制下 $a_i$ 高至低第 $j$ 位的值，形式化地，$f_{i,j}\gets[a_i\ \mathrm{and}\ 2^{30-j}=2^{30-j}]$。

对于 $a_{i-1}$ 和 $a_{i}$，令 $k$ 表示**最小的**使得 $f_{i-1,k}\ne f_{i,k}$ 的值，则如果 $f_{i-1,k}<f_{i,k}$，那么因为比较大小先比较高位，第 $k$ 位**一定不能翻转**，即 $b$ 第 $k$ 位一定不能为 $1$，反之同理，第 $k$ 位必须翻转，对于 $j<k$，因为相等，是否翻转对大小无关；对于 $j>k$，由于先比较高位，是否翻转同样对大小无关。

由于需要保证 $\forall i>1,a_{i-1}\oplus b\le a_i\oplus b$，因此对于所有的 $i>1$，做一下 $b$ 应该在哪几位上翻转，并判断是否有矛盾。

对于修改，由于与 $a_i$ 相关的只有 $a_{i-1}$ 和 $a_{i+1}$，直接暴力撤销原来 $a_i$ 贡献，并且加入 $a_{i+1}$ 贡献即可。时间复杂度 $O(n+q\log v)$。

[Code](https://loj.ac/s/2160212)。

---


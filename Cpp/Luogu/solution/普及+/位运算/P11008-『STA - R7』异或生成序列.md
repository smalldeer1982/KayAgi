# 『STA - R7』异或生成序列

## 题目描述

对于一个 $1 \sim n$ 的排列 $\{p_n\}$，定义其异或生成序列为一个长度为 $n - 1$ 的非负整数序列 $\{b_{n - 1}\}$，按如下方式生成：

$$b_i = p_i \operatorname{xor} p_{i + 1}$$

其中 $\operatorname{xor}$ 代表按位异或运算。在 C++ 语言中由 `^` 运算符表示。

给定 $n, \{b_{n - 1}\}$，你需要构造一个对应的排列 $\{p_n\}$。

输入数据保证有解，如果存在多个解，输出任意一个即可。

## 说明/提示

**【样例解释】**

对于第一组测试数据，我们有：

- $b_1 = p_1 \operatorname{xor} p_2 = 2 \operatorname{xor} 3 = 1$
- $b_2 = p_2 \operatorname{xor} p_3 = 3 \operatorname{xor} 1 = 2$
- $b_3 = p_3 \operatorname{xor} p_4 = 1 \operatorname{xor} 4 = 5$

因此得到的 $b$ 序列和输入中的相同，进而该排列符合要求。

对于第二组测试数据，$[4,5,2,1,3,6]$ 也是一个符合要求的排列。

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据：

- $2 \le n \le 2 \times 10^6$；
- $1 \le T \le 10^6$；
- $\sum n \le 2 \times 10^6$;
- 保证至少存在一个合法的解。

具体部分分分配如下：

|Subtask 编号|数据范围|分值|
|:--------:|:--------:|:--------:|
|1|$\sum n^2 \le 2 \times 10^6$|$17$|
|2|$2 \nmid n$|$23$|
|3|$4 \mid n$|$26$|
|4|无特殊限制|$34$|


**【提示】**

本题输入文件较大，请使用较为快速的输入方式。

## 样例 #1

### 输入

```
2
4
1 2 5
6
1 7 3 2 5
```

### 输出

```
2 3 1 4
3 2 5 6 4 1
```

# 题解

## 作者：_Kenma_ (赞：22)

# P11008 解题报告

## 前言

$n^2$ 过百万，暴力踩标算。

## 思路分析

我们要充分发扬人类智慧。

考虑乱搞。

首先我们可以枚举 $a_1$ 的取值，然后递推得到序列 $a$，再判断 $a$ 是否合法。这样时间复杂度为 $O(n^2)$。

考虑对这个暴力做法剪枝。

对序列 $b$ 求异或前缀和，得到序列 $c$。不难发现，$c_i = a_1 \oplus a_{i+1}$。

考虑 $a_1$ 有什么限制。

因为 $a$ 是 $[1,n]$ 的排列，所以 $\forall i \in [1,n-1],c_i \ne a_1$。否则一定 $\exist i \in [1,n],a_i = 0$，而这样是不合法的。

因为 $c_i \in [1,2^{\left \lceil \log a_j \right \rceil }],i \in [1,n-1],j \in [1,n]$，所以这个剪枝帮我们去掉了至少一半的不合法情况。

然后就可以枚举 $a_1$，判断序列 $a$ 是否是一个排列了。因为题目保证有解，所以序列 $c$ 中元素互不相同。这样，我们只需要保证 $a_i \le n$ 即可。显然，从小到大枚举 $a_1$ 是更优的。

这样做跑的飞快，甚至挤到了最优解第二页。

## 代码实现

最好写的一集。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[2000005],b[2000005],vis[2000005];
bool check(int x){
	if(vis[x]) return false;
	for(int i=2;i<=n;i++){
		if((x^b[i])>n) return false;
	}
	return true;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=2;i<=n;i++){
			cin>>a[i];
			b[i]=b[i-1]^a[i]; 
			vis[b[i]]=1;
		}
		for(int i=1;i<=n;i++){
			if(check(i)){
				a[1]=i;
				for(int j=2;j<=n;j++){
					vis[b[j]]=0;
					a[j]^=a[j-1];
				}
				for(int j=1;j<=n;j++){
					cout<<a[j]<<' ';
				} 
				cout<<'\n'; 
				break;
			}
		}
	}
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/174815903)

## 后记

欢迎 hack / 复杂度分析。

感觉 hack 的构造思路是让 $a_1$ 尽可能大，同时让 $c$ 尽可能大，但是我并不会卡。

祝点赞的各位 $CSP / NOIP$ $rp++$ 。

---

## 作者：User_Unauthorized (赞：10)

根据异或的消去律，我们有：

$b_1 \operatorname{xor} b_2 = p_1 \operatorname{xor} p_2 \operatorname{xor} p_2 \operatorname{xor} p_3 = p_1 \operatorname{xor} p_3$

类似的，设 $s_i = b_1 \operatorname{xor} b_2 \operatorname{xor} \cdots \operatorname{xor} b_{i - 1}$，我们有 $s_i = p_1 \operatorname{xor} p_i$，其中 $s_1 = 0$。

不难发现 $s$ 序列实质上是排列 $p$ 整体异或了某个 $[1, n]$ 中的数得到的序列。那么我们的目标即为找到一个正整数 $k \in [1, n]$ 使得序列 $a_i = s_i \operatorname{xor} k$ 为一个 $1 \sim n$ 的排列。

## $\mathcal{O}(n^2)$ 做法

直接枚举 $k$ 的取值即可以在 $\mathcal{O}(n^2)$ 的复杂度内解决该题，这里不多赘述。

## $\mathcal{O}(n \log n)$ 做法

考虑当 $n$ 为奇数时如何处理，可以发现此时对于任意二进制位 $2^c$，均有 $1 \sim n$ 中的数在该位上取 $0$ 的数字数量和取 $1$ 的不同。进而我们可以依次对于每一位求出 $1 \sim n$ 中的数在该位上取 $0$ 的数量和 $s_i$ 中的元素在该位上取 $0$ 的数量，若其不相同那么意味着 $k$ 在这一位上值为 $1$，否则为 $0$。进而我们可以在 $\mathcal{O}(n \log n)$ 的复杂度内得到 $k$ 的取值。

考虑什么情况下 $1 \sim n$ 在二进制位 $2^c$ 上取 $0$ 的数量和取 $1$ 的数量相同。通过观察可以发现其仅会有如下两种情况：

- $n \equiv 0 \pmod {2^c}$
- $n \equiv -2 \pmod {2^c}$

不难发现这两种情况均具有一种传递性，即若对于某个 $c_0$，有 $n \equiv 0 \pmod {2^{c_0}}$，那么对于 $c \le c_0$，均有 $n \equiv 0 \pmod {2^c}$。

因此我们不妨从高位向低位处理，直到某一位满足上述条件。可以发现在 $4 \mid n$ 的情况下最高位一定不符合上述条件。

进而我们可以利用已经处理完成的位将元素划分为若干集合，可以发现已经完成的位部分值最高的集合数量一定为奇数，因为这一部分数字均满足 $x \ge \lfloor\frac{n}{2^c}\rfloor \times 2^c$，不难发现后者一定为偶数，进而上述集合的值为奇数，利用当 $n$ 为奇数的情况即可确定 $k$ 剩余位的取值。

考虑当最高位满足取 $0$ 和取 $1$ 的数量相同的情况。那么观察可得此时一定满足（若满足第一个条件那么最高位便不是 $2^c$） 

$$n \equiv -2 \pmod {2^c}$$

因此我们可以按 $s_i$ 最高位的取值将其划分为两个大小均为奇数的集合。枚举 $k$ 的取值后按 $n$ 为奇数的情况判断即可。

复杂度为 $\mathcal{O}(n \log n)$。

## $\mathcal{O}(n)$ 做法

考虑建一棵 trie 树，并将 $1 \sim n$ 中的数放到 trie 树上，可以发现 $1$ 对应的节点一定没有兄弟节点。而没有兄弟节点的数字经过异或变换后依然没有兄弟节点。因此将 $s_i$ 放到 trie 树上，可以得出在这棵 trie 树上没有兄弟节点的数字大部分情况下对应的数字为 $1$。若当 $n$ 为奇数时，其对应的节点也没有兄弟节点，此时暴力判断一下恢复后的序列是否是一个排列即可。

复杂度为 $\mathcal{O}(\sum n)$。

---

## 作者：HHC883 (赞：6)

# 题目分析
容易发现，只要得到了 $p_1$，就可以由 $p_1 \operatorname{xor} p_2=b_1$ 推出 $p_2$，即 $p_2=p_1 \operatorname{xor} b_1$，同样地，知道了 $p_2$，又可以知道 $p_3$。记 $pre_0=0,pre_i=pre_{i-1} \operatorname{xor} b_i$，则有 $p_i=p_1 \operatorname{xor} pre_{i-1}$。也就是说，我们只需要找到一个 $p_1$，使得 $p$ 是一个排列。

若要使 $p$ 是一个排列，应满足以下两点：一是不存在一个数出现了多次，二是每个数都应不小于 $1$ 且不大于 $n$。

若不满足第一点，则说明数组 $b$ 有一段区间异或和为 $0$，那么无论 $p_1$ 取何值，都不可能满足条件，而题目保证有解，所以第一点一定满足。

对于第二点，要使每个 $p_i$ 都大于 $0$，应有 $p_i=p_1 \operatorname{xor} pre_{i-1} \ne 0$，这就要求 $p_1 \ne pre_{i-1}$。所以对于每个 $pre_i$，我们都打上一个标记（具体见代码中的 $flag$ 数组），表示其不能作为 $p_1$。

但要使每个 $p_i$ 都小于等于 $n$，则要复杂一些，因为使得 $p_1 \operatorname{xor} pre_{i-1} > n$ 的 $p_1$ 可能不止一个。于是，我们想到将每个 $pre_i$ 按位拆开，再按位打标记即可（具体见代码中的 $kill$ 数组）。

最后，枚举 $1$ 到 $n$，若某个数没有 $flag$ 标记，且对于每一位，也没有 $kill$ 标记，就说明它可以作为 $p_1$，然后根据 $p_1$ 就可以推出整个 $p$ 数组。

由于要按位打标记，所以时间复杂度为 $O(n \log n)$。
# 参考代码

```cpp
#include<iostream>
using namespace std;
int t,n,b[(int)2e6+5],pre,ans;
bool flag[(int)2e6+5],kill[(int)2e6+5][30][2];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<n;i++) cin>>b[i];
		pre=0;
		for(int i=1;i<=n;i++) flag[i]=true;
		for(int i=0;i<=n;i++){
			for(int j=1;j<21;j++) kill[i][j][0]=kill[i][j][1]=false;
		}
		for(int i=1;i<n;i++){
			pre^=b[i];
			if(pre<=n) flag[pre]=false;
			for(int j=1;j<21;j++){
				if(((n>>j-1)&1)==0) kill[(pre>>j)^(n>>j)][j][!((pre>>j-1)&1)]=true;
			}
		}
		for(ans=1;ans<=n;ans++){
			if(flag[ans]){
				bool f=true;
				for(int i=1;i<21;i++){
					if(kill[ans>>i][i][(ans>>i-1)&1]){
						f=false;
						break;
					}
				}
				if(f) break;
			}
		}
		cout<<ans<<' ';
		for(int i=1;i<n;i++){
			ans^=b[i];
			cout<<ans<<' ';
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：rhn7 (赞：2)

本蒟蒻赛时过了这题没过T1，晕。

设 $s_i$ 为 $b_1 \bigoplus b_2 \bigoplus ...\bigoplus b_i$，由于 $x \bigoplus x=0$，中间的项都会消掉，最后得到 $a_1 \bigoplus s_i=a_{i+1}$。这样只要枚举 $a_1$，剩下的数都能算出来，暴力判断是否为排列即可，但会超时。

考虑排列的判定，一是每个数要在 $[1,n]$ 之间，二是互不相同。若存在相同情况：

$a_1 \bigoplus s_i=a_1 \bigoplus s_j$

$s_i=s_j$

可以发现是否互不相同跟 $a_1$ 的取值没有关系，题目又保证有解，所以没有这种情况，不用管。

看条件一，相当与判断 $\min(a_1 \bigoplus s_i) \ge 1$ 和 $\max(a_1 \bigoplus s_i) \le n$，用字典树维护即可。


```cpp
#include<bits/stdc++.h>
#define rd(x) scanf("%lld",&x)
using namespace std;
typedef long long ll;
const ll N=2e6+5;
ll T,n,a[N],cnt,t[N*30][2],tot,h[N],lp;
pair<ll,ll> p[N];
void ins(ll x){
	ll u=0;
	for(ll i=30;i>=0;i--){
		ll c=x&(1ll<<i)?1:0;
		if(!t[u][c]) t[u][c]=++tot,p[++lp]={u,c};
		u=t[u][c];
	}
}
ll find(ll x){
	ll res=0,u=0;
	for(ll i=30;i>=0;i--){
		ll c=x&(1ll<<i)?1:0;
		if(t[u][!c]) res+=1ll<<i,u=t[u][!c];
		else u=t[u][c];
	}
	return res;
}
int main(){
	rd(T);
	while(T--){
		rd(n);cnt++;
		for(ll i=1;i<=lp;i++) t[p[i].first][p[i].second]=0;
		tot=lp=0;
		for(ll i=2;i<=n;i++){
			rd(a[i]),a[i]^=a[i-1],ins(a[i]);
			if(a[i]<=n) h[a[i]]=cnt;
		}
		for(ll i=1;i<=n;i++){
			if(find(i)<=n&&h[i]!=cnt){
				for(ll j=1;j<=n;j++) printf("%lld ",i^a[j]);
				break;
			}
		}
		printf("\n");
	}
    return 0;
}
```

---

## 作者：ImposterAnYu (赞：2)

分享一个可通过此题但可能会被卡的方法。~~别问，问就是赛时瞎几把乱写写出来的~~

首先两个非常基础的小知识： $i \operatorname{xor} i = 0$，$0 \operatorname{xor} i = i$。

接下来，对于每个 $b_i(1\leq i < n)$，我们做一个前缀和 $x_i = x_{i - 1} \operatorname{xor} b_i$，那么

$x_i = (p_1 \operatorname{xor} p_2) \operatorname{xor} (p_2 \operatorname{xor} p_3) \operatorname{xor}...\operatorname{xor} (p_{i - 1} \operatorname{xor} p_i) $

$= p_1 \operatorname{xor} p_i \operatorname{xor} (p_2 \operatorname{xor} p_2) \operatorname{xor}...\operatorname{xor} (p_{i - 1} \operatorname{xor} p_{i - 1}) $

$= p_1 \operatorname{xor} p_i$

此时，我们可以枚举 $p_1$，判断 $x_i \operatorname{xor} p_1$ 是否重复。如果都不重复，那么 $p = \{p_1,x_1 \operatorname{xor} p_1,...,x_{n - 1} \operatorname{xor} p_1\}$ 便是我们要找的答案（之一）。

显然，这个算法的时间复杂度是 $O(n^2)$ 的。但是我们真的需要枚举每一个 $1 \leq p_1 \leq n$ 吗？

运用一下前面的小知识，可以发现 **$x$ 数组中的数是不需要枚举的！因为当我们令 $p_1 = x_i$ 时，算出来的 $p_{i + 1}$ 会为 $0$，完全不符合要求！** 这样一来，我们的枚举量会大大减少，可通过本题的数据！

但具体减少多少呢？其实我也不知道……（所以我才会说这个方法可能被卡掉啊qwq）

**最后关于该做法的判重：其实没这个必要，只要算出来的 $p_i \leq n$ 即可。因为数据保证有解，所以最后得到的 $x$ 中的元素必然两两不相同。而对于不同的 $x_i,x_j$，算出来的 $p_{i + 1}$ 一定和 $p_{j + 1}$ 不同，所以此时的 $p$ 中的元素也必然两两不相同。**

代码我就不贴了，毕竟只是一个瞎搞的做法，反正时间复杂度不知道，空间复杂度 $O(n)$。（如果有大佬有时间复杂度证明方法或者发现了能卡掉该做法的数据，可以在评论区里说一声）

---

## 作者：pan_g (赞：2)

提供一种全新的 $O(n)$ 做法。

首先，是可以很容易观察到一点：

记 $\{s_n\}$ 满足 $s_1 = 0,s_i = \oplus_{x = 1}^{i - 1} b_x$ 。

其中 $s_i = p_1 \oplus p_i$ ，也可以得到 $s_i \oplus s_j = p_i \oplus p_j$ 。

我们知道当 $2 | x$ 时， $x \oplus (x + 1) = 1$ 。

于是我们发现，只有 $1$ 和偶数 $n$ 对于 $1\sim n$ 内的整数进行 $\operatorname{xor}$ ，不会得到 $1$ 。

接下来，我们可以发现因为 $\{p_n\}$ 是一个排列，那么 $\{s_n\}$ 内的元素必然互不相同。

假设考虑找 $1$ 的位置，如果 $\lfloor \dfrac{s_i}2 \rfloor$ 与 $\lfloor \dfrac{s_j}2 \rfloor$ 相同，那么由于 $s_i \not= s_j$ ，所以 $s_i \oplus s_j = 1$ ， 得到 $p_i \oplus p_j = 1$ ，所以 $p_i$ 和 $p_j$ 必然不为 $1$ 。

于是，我们只要用一个桶把 $\lfloor\dfrac{s_i}2\rfloor$ 存下来，找到唯一或唯二的可能为 $1$ 的 $p_i$ 。

再挨个带进去检验即可，所以还是 $O(n)$ 的。

```cpp
#include <bits/stdc++.h>
#define endl "\n"
typedef long long i64;

void solve(){
    int n;
    std::cin >> n;
    std::vector<int> b(n), s(n, 0);
    for(int i = 1;i < n;i++){
        std::cin >> b[i];
        s[i] = s[i - 1] ^ b[i];
    }
    std::vector<int> buc(n, 0);
    for(int i = 0;i < n;i++){
        buc[s[i] / 2] ++;
    }

    std::vector<int> _1;
    for(int i = 0;i < n;i++){
        if(buc[s[i] / 2] == 1) _1.emplace_back(i);
        // 如果 s_i / 2 是唯一的，那么 p_i 就有可能为 1
    }

    std::vector<int> p;
    auto check = [&](int x) -> bool {
        p.assign(n, -1);
        p[0] = s[x] ^ 1;
        std::vector<bool> vis(n + 1, false);
        if(p[0] < 1 || p[0] > n) return false;
        vis[p[0]] = true;
        for(int i = 1;i < n;i++){
            p[i] = p[0] ^ s[i];
            if(p[i] < 1 || p[i] > n) return false;
            if(vis[p[i]]) return false;
            vis[p[i]] = true;
        }
        return true;
    };
    // 将 p_x 定为 1 ，并且检验

    for(auto x : _1){
        if(check(x)){
            for(int i = 0;i < n;i++){
                std::cout << p[i] << " \n"[i == n - 1];
            }
            return ;
        }
    }
}

// # define std far
// far::queue<int> q;

signed main(){
    std::cin.tie(nullptr) -> sync_with_stdio(false);
    int T;
    std::cin >> T;
    while(T --) solve();
    return 0;
}
```

---

## 作者：maomao233 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11008)

$\mathcal{O}(n^2)$ 的做法是容易的。具体地，枚举 $p_1$ 的值，根据 $b_i=p_i\operatorname{xor}p_{i+1}$ 反推得 $p_{i+1}=p_i\operatorname{xor}b_i$，判断所有 $p_i$ 的合法性（是否满足 $1\le p_i\le n$），合法输出即可。

这样竟然可以获得 $\text{66pts}$！考虑各种优化。

我在赛时想到，由于 $p_i$ 不合法时满足 $p_i<1$ 或 $p_i>n$。对于 $p_i<1$，也就是 $p_i=0$，则 $p_{i-1}\operatorname{xor}b_{i-1}=0$。  
若此时枚举到 $p_1=x$，且序列 $\{b_{n-1}\}$ 中有一前缀异或和为 $x$，则显然 $p_1=x$ 是不合法的，可以直接跳过。  
该操作可以通过桶实现（注意多测清空）。

这一细微优化可以直接通过！~~数据太水了？~~  
代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
#define lb(x) x&-x
#define itn int
#define fpr for
#define rD rd
inline string its(int x){stringstream ss;string s;ss<<x;ss>>s;return s;}
inline int sti(string s){stringstream ss;int x;ss<<s;ss>>x;return x;}
inline string jia(string a1,string b1){int a[10010],b[10010],c[10010];int lena=a1.size(),lenb=b1.size();for(int i=0;i<lena;i++){a[i]=a1[lena-1-i]-'0';}for(int i=0;i<lenb;i++){b[i]=b1[lenb-1-i]-'0';}int lenc=max(lena,lenb),t=0;for(int i=0;i<lenc;i++){c[i]=a[i]+b[i]+t;if(c[i]>=10){t=1,c[i]%=10;}else{t=0;}}if(t==1){lenc++;c[lenc-1]=1;}string s;for(int i=lenc-1;i>=0;i--){s+=c[i]+'0';}return s;}
inline string jian(string a1,string b1){if(a1.size()<b1.size()||a1.size()==b1.size()&&a1<b1){pc('-'),swap(a1,b1);}int a[10010],b[10010],c[10010];int lena=a1.size(),lenb=b1.size();for(int i=0;i<lena;i++){a[i]=a1[lena-1-i]-'0';}for(int i=0;i<lenb;i++){b[i]=b1[lenb-1-i]-'0';}int lenc=lena;for(int i=0;i<lenc;i++){if(a[i]<b[i]){a[i+1]--,a[i]+=10;}c[i]=a[i]-b[i];}while(lenc>=1&&c[lenc-1]==0){lenc--;}string s;for(int i=lenc-1;i>=0;i--){s+=c[i]+'0';}return s;}
inline int qpow(int a,int b,int p){int ans=1;while(b){if(b&1){ans=(ans*a)%p;}b>>=1;a=(a*a)%p;}return ans;}
inline int qp(int a,int b){int ans=1;while(b){if(b&1){ans*=a;}b>>=1;a*=a;}return ans;}
int a[2000010];
int s[2000010];
bool mp[4000010];
int p[2000010];
signed main()
{
	int t;
	rd(t);
	while(t--)
	{
		int n;
		rd(n);
		for(int i=1;i<=n-1;i++)
		{
			rd(a[i]),s[i]=s[i-1]^a[i],mp[s[i]]=1;
		}
		for(int i=1;i<=n;i++)
		{
			p[1]=i;
			if(mp[i])
			{
				continue;
			}
			int flag=0;
			for(int j=2;j<=n;j++)
			{
				p[j]=p[j-1]^a[j-1];
				if(p[j]<1||p[j]>n)
				{
					flag=1;
					break;
				}
			}
			if(!flag)
			{
				for(int j=1;j<=n;j++)
				{
					wt(p[j]),kg;
				}
				hh;
				break;
			}
		}
		for(int i=1;i<=n;i++)
		{
			mp[s[i]]=0;
		}
	}
	return 0;
}
```

---

## 作者：Brilliant11001 (赞：2)

### [更好的阅读体验](https://www.cnblogs.com/Brilliant11001/p/18381812)

## 提示：此篇题解可能不太严谨。

题目大意很明确，这里不再重述。

## 思路：

让我们充分发扬人类智慧（

根据异或运算的基本性质，若两个数同时异或会被消掉，比如 $a\operatorname{xor} b\operatorname{xor} b = a$。

观察题目，容易发现将 $b$ 数列异或起来会有很多重复的数，而它们都能消掉。

即：

$$b_1\operatorname{xor}b_2\operatorname{xor}\cdots \operatorname{xor}b_{i - 1} = p_1\operatorname{xor} p_i(i\in [2, n])$$

再根据异或运算的另一个性质：若 $a\operatorname{xor}b = c$，则 $a = b\operatorname{xor}c$，得：

$$p_i = b_1\operatorname{xor}b_2\operatorname{xor}\cdots \operatorname{xor}b_{i - 1}\operatorname{xor} p_1 (i\in [2, n])$$

也就是说，我们只要知道了一个 $p_1$，再依次计算就能得到原数列。

我们先维护一个异或的类似前缀和的数组 $sum$，即 $sum_i$ 表示数列 $b$ 的前 $i$ 个数 $\operatorname{xor}$ 起来得到的结果，然后钦定一个 $p_1$ 并判断是否合法即可。

但这样的做法是 $O(n^2)$ 的，考虑优化。

发现瓶颈在于找合法 $p_1$ 的过程，如果能提前否掉一些不合法的选择就好了。

由于原数列是一个 $1\sim n$ 的排列，所以不能出现 $0$，换句话说就是 $sum_{i - 1}\operatorname{xor} p_1$ 不能为 $0$，即 $p_1\ne sum_{i - 1}$。同时也不能大于 $n$，和上面如出一辙。

所以开一个桶提前标记 $p_1$ 不能取的值，剪掉一些情况。

$\texttt{Code:}$
```cpp
#include <cmath>
#include <ctime>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2000010;

int T, n;
int a[N], sum[N];
int ans[N];
int cnt;
bool st[N];

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d", &n);
        for(int i = 1; i < n; i++) {
            scanf("%d", &a[i]);
            sum[i] = sum[i - 1] ^ a[i];
            st[sum[i]] = true; //标记不能取的值
        }
        for(int p1 = 1; p1 <= n; p1++) {
            if(st[p1]) continue; //玄学剪枝
            ans[1] = p1;
            bool flag = true;
            for(int j = 2; j <= n; j++) {
                int tmp = sum[j - 1] ^ p1;
                if(tmp > n) {
                    flag = false;
                    break;
                }
                ans[j] = tmp;
            }
            if(flag) {
                for(int j = 1; j <= n; j++)
                    printf("%d ", ans[j]);
                puts("");
                break;
            }
        }
        for(int i = 1; i < n; i++) st[sum[i]] = false; //记得最后还原
    }
    return 0;
}
```

这里我才刚把不等于 $0$ 的情况判掉就通过了。~~（加强数据迫在眉睫）~~

欢迎大佬给出详细的时间复杂度的证明或 hack。

update：感谢 [@jijidawang](https://www.luogu.com.cn/user/227514) 和 [@int_R](https://www.luogu.com/user/469312) 大佬指正了错误并给出了证明。

[证明在这](https://www.luogu.com/paste/02jhgkex)

所以这种做法时间复杂度为 $O(n)$。

---

## 作者：lbh666 (赞：1)

以下用 $\oplus$ 代替异或操作。

答案合法的条件如下：

- 最终求出来的 $p$ 序列里的数互不相同。
- $p$ 序列的数的下限是 $1$，上限是 $n$。

观察等式 $b_i = p_i \oplus p_{i+1}$，将等式两边同时异或上 $p_i$，得到 $b_i \oplus p_i = p_{i+1}$。

不妨展开 $p_i$，使得 $p_i = b_{i-1} \oplus p_{i-1}$，继续递归展开，可以发现最终的结果可以表示为前缀异或和再异或上一个数。记 $s_i = \bigoplus\limits_{j = 1}^{i-1} b_j$，就有 $p_i = s_i \oplus p_1$。

显然的，若存在 $i$ 和 $j$ 满足 $i \ne j$ 且 $s_i = s_j$，那么该问题无解，因为异或两次相同的数，大小不变。既然已经保证了 $s$ 序列互不相同，那么 $s$ 序列异或上 $p_1$ 得到的 $p$ 序列肯定也是互不相同的。

第一个合法条件满足了，考虑第二个合法条件。

对于每一个 $i$ 我们要有 $1\le p_1 \oplus s_i \le n$，也就是 $\min\limits_{i = 1}^{n} \{ s_i \oplus p_1 \} \ge 1$ 以及 $\max\limits_{i=1}^{n} \{ s_i \oplus p_1 \} \le n$，可以用 01-trie 维护。

这样第二个条件也满足了。

实现过程：

- 算出前缀异或和 $s$，可以一边输入一边异或。
- 把每个 $s_i$ 插到 01-trie 中。
- 先 $\mathcal O(n)$ 枚举 $p_1$。
- 在枚举过程中，用 $\mathcal O(\log n)$ 求出最大及最小的 $p_1 \oplus s_i$，如果没有超过上下限，输出答案。

总复杂度 $\mathcal O(n \log n)$。

### 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,l,r) for(int i=l;i<=r;++i)
using namespace std;

const int N=2e6+5,M=6e6+5;
int t,n,tot=0,sum;
int b[N];
int trie[M][2];

void insert(int x){//插入
    int s=0;
    for(int i=22;i>=0;--i){
        int c=(x>>i)&1;
        if(!trie[s][c])trie[s][c]=++tot;
        s=trie[s][c];
    }
}

int query_max(int x){//查询最大值
    int s=0,ans=0;
    for(int i=22;i>=0;--i){
        int c=(x>>i)&1;
        if(trie[s][!c]){//贪心，尽可能选择不同的走
            s=trie[s][!c];
            ans+=(1<<i);//计算异或值
        }else s=trie[s][c];
    }
    return ans;
}

int query_min(int x){//查询最小值
    int s=0,ans=0;
    for(int i=22;i>=0;--i){
        int c=(x>>i)&1;
        if(trie[s][c])s=trie[s][c];
        else{//贪心，尽可能选择相同的走
            s=trie[s][!c];
            ans+=(1<<i);//计算异或值
        }
    }
    return ans;
}

int main(){
	scanf("%d",&t);
    while(t--){
        //初始化
        for(int i=0;i<=tot;++i)trie[i][0]=trie[i][1]=0;
        tot=0;
        scanf("%d",&n);
        for(int i=2;i<=n;++i){
            scanf("%d",&b[i]);
            b[i]^=b[i-1];//直接用b数组计算前缀异或和
            insert(b[i]);//插入
        }
        for(int i=1;i<=n;++i){
            int l=query_min(i),r=query_max(i);
            if(l>=1 && r<=n){//满足上下限
                sum=i;
                break;
            }
        }
        for(int i=1;i<=n;++i)printf("%d ",sum^b[i]);//输出
        puts("");
    }
	return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

有 $n-1$ 条关系，显然对于 $i\ge 2$，可以使用 $p_1\oplus x_i$ 表示出 $p_i$。特别的，$x_1=0$。

因为保证有解，于是有 $p_1,p_2,\cdots,p_n$ 互不相同，即 $x_1,x_2,\cdots,x_n$ 互不相同。

有一个做法是枚举 $p_1$，判断是否有解。

如何判断呢？可以把所有的 $x_i$ 放到 Trie 树中，对于枚举 $p_1=val$，只需要看 $val\oplus x_i$ 的最大值和最小值是否分别为 $n,1$ 即可。

上面这个东西的证明可以用抽屉原理。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 5;
int _T, n, a[N];
struct TRIE{
	int nxt[N * 20][2], x, idx, p, res;
	inline void ins(int v){
		p = 1;
		for(int i = 20; ~i; i--){
			x = v >> i & 1;
			if(!nxt[p][x]) nxt[p][x] = ++idx;
			p = nxt[p][x];
		}
	}
	inline void clr(){
		for(int i = 1; i <= idx; i++){
			nxt[i][0] = nxt[i][1] = 0;
		}
		idx = 1;
	}
	inline int getmin(int v){
		p = 1;
		res = 0;
		for(int i = 20; ~i; i--){
			x = v >> i & 1;
			if(!nxt[p][x]){
				p = nxt[p][x ^ 1];
				res |= 1 << i;
			}
			else p = nxt[p][x];
		}
		return res;
	}
	inline int getmax(int v){
		p = 1;
		res = 0;
		for(int i = 20; ~i; i--){
			x = v >> i & 1;
			if(!nxt[p][x ^ 1]){
				p = nxt[p][x];
			}
			else{
				p = nxt[p][x ^ 1];
				res |= 1 << i;
			}
		}
		return res;
	}
}T;
int main(){
	scanf("%d", &_T);
	while(_T--){
		T.clr();
		scanf("%d", &n);
		a[1] = 0;
		for(int i = 2; i <= n; i++){
			scanf("%d", &a[i]);
			a[i] ^= a[i - 1];
		}
		for(int i = 1; i <= n; i++){
			T.ins(a[i]);
		}
		for(int i = 1; i <= n; i++){
//			cerr << i << ' ' << T.getmin(i) << ' ' << T.getmax(i) << endl;
			if(T.getmin(i) == 1 && T.getmax(i) == n){
				for(int j = 1; j <= n; j++){
					a[j] ^= i;
				}
				break ;
			}
		}
		for(int i = 1; i <= n; i++){
			printf("%d ", a[i]);
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：LiaoYF (赞：0)

## 题解

这里是 $O(n \log n)$ 做法。

显然有一个 $O(n^2)$ 的做法，枚举 $p_1$，然后就可以暴力算出其他位置的数并检查。

首先，注意到：

$$
\begin{aligned}
  b_1 \operatorname{xor} b_2 \operatorname{xor} ... \operatorname{xor} b_i \\
  &= p_1 \operatorname{xor} p_2 \operatorname{xor} p_2 \operatorname{xor} p_3 \operatorname{xor} ... \operatorname{xor} p_{i+1} \\
  &= p_1 \operatorname{xor} p_{i+1}
\end{aligned}
$$

记 $b_1 \operatorname{xor} b_2 \operatorname{xor} ... \operatorname{xor} b_i=s_{i+1}$，则 $p_i=s_i \operatorname{xor} p_1$。

对于任意 $p_1$，算出来的 $p_i$ 都是互不相同的。所以我们只需要保证算出来的 $p_i$ 在 $\left [1,n \right]$ 之间。

大于等于 $1$ 很简单，只需要 $p_1$ 不等于任意 $s_i$ 即可。小于等于 $n$ 的话，考虑枚举  $p_1$，只要异或 $p_1$ 最大的一个 $s_i$ 满足 $p_1 \operatorname{xor} s_i \leq n$，那么就所有都满足。转化为求与 $p_1$ 异或最大的一个 $s_i$。使用 trie 就可以在 $O(\log n)$ 的时间复杂度内完成，具体做法参考 [P4551](https://www.luogu.com.cn/problem/P4551)。

这个做法有点卡常，实现的不好可能会 TLE。

## 代码

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
#ifdef LOCAL
#include "debug.h"
#else
#define debug(...) 42
#endif
const int INF=1e18;
const int N=2000005;
const int MOD=1e9+7;
int n,a[N],b[N],s[N],trie[N*22][2],cnt;
bool check(int x){
    b[1]=x;
    for(int j=2;j<=n;j++){
        b[j]=b[j-1]^a[j-1];
    }
    for(int i=1;i<=n;i++){
        cout<<b[i]<<" ";
    }
    cout<<"\n";
    return 1;
}
void insert(int x){
    int p=0;
    for(int i=21;i>=0;i--){
        int y=(x&(1ll<<i)?1:0);
        if(!trie[p][y]){
            trie[p][y]=++cnt;
        }
        p=trie[p][y];
    }
}
void del(int p){
    if(trie[p][0]){
        del(trie[p][0]);
    }
    if(trie[p][1]){
        del(trie[p][1]);
    }
    trie[p][0]=trie[p][1]=0;
}
int calc(int x){
    int p=0,res=0;
    for(int i=21;i>=0;i--){
        int y=(x&(1ll<<i)?1:0);
        if(trie[p][!y]){
            p=trie[p][!y];
            res|=(1ll<<i);
        }else{
            p=trie[p][y];
        } 
    }
    return res;
}
void solve(){
    cin>>n;
    cnt=0;
    unordered_map<int,bool> vis;
    for(int i=1;i<n;i++){
        cin>>a[i];
        s[i+1]=s[i]^a[i];
    }
    for(int i=2;i<=n;i++){
        vis[s[i]]=1;
        insert(s[i]);
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        if(vis[i])continue;
        int mx=calc(i);
        if(mx<=n){
            ans=i;
            break;
        }
    }
    check(ans);
    del(0);
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t,multitest=1;
    if(multitest)cin>>t;
    else t=1;
    while(t--){
        solve();
    }
    return 0;
}
```

---

## 作者：GY程袁浩 (赞：0)

# 思路

对于异或，有一个小性质，即 $x\;\oplus\;y\;\oplus\;x=y$。

题目中我们也能运用这个性质，考虑到对于相邻的两个 $b_{i}$，它们的表达式中有一个共同的 $p_{i}$，所以异或两个相邻的 $b_{i}$ 就会把那个出现了两次的 $p_{i}$ 消除，即：

$$
\begin{aligned}
b_{i}\;\oplus\;b_{i+1} = p_{i}\;\oplus\;p_{i+1}\;\oplus\;p_{i+1}\;\oplus\; p_{i+2} = p_{i}\;\oplus\;p_{i+2}
\end{aligned}
$$

但是这样有什么意义呢？意义很重大啊！因为我们知道 $b_{i}\;\oplus\;b_{i+1}$ 的值，所以可以有意义的将式子移项：

$$
\begin{aligned}
p_{i+2}=p_{i}\;\oplus\;(b_{i}\;\oplus\;b_{i+1})
\end{aligned}
$$

同时显然的 $p_{i+1}=p_{i}\;\oplus\;b_{i}$。

这个式子告诉我们，只要有 $p_{i}$ 的值，就可以求出 $p_{i+1}$ 以及以后的 $p_{i}$，那么我们只要枚举 $p_{1}$ 就行。

考虑暴力判断 $p_{1}$ 生成的序列的可行性，这样是 $O(n^2)$ 的，考虑优化。

我们知道，实际上判就只是判这三个因素：

1.序列的所有元素大于 $0$。

2.序列的所有元素小于 $n+1$。

3.序列没有重复的元素。

三条件实际对于所有有解输入都成立，因为每个 $p_{i}(i>1)$ 的表达式形如：

$$
\begin{aligned}
p_{i}=p_{1}\;\oplus\;(b_{1}\;\oplus\;...\;\oplus\;b_{i-1})
\end{aligned}
$$

如果有解，那么 $(b_{1}\;\oplus\;...\;\oplus\;b_{i-1})$ 一定对于任何的 $i>1$ 都不重复，不然对于任何一个解，都会出现重复的情况。所以 $(b_{1}\;\oplus\;...\;\oplus\;b_{i-1})$ 互不重复，异或任意 $p_{1}$ 自然也不重复。

考虑条件一二，因为所有元素大于一个数等价于最小元素大于那个数，所有元素小于一个数等价于最大元素小于那个数，所以考虑快速求出上式最大最小值的方法。

由于上式为位运算，是在每位进行的，如果想要贪心的最大或最小，就需要依次决定每位，从高位到低位。

所以考虑记录 $b$ 每一个的前缀异或和，然后求最大最小值时，贪心的从高往低考虑取 $0$ 还是 $1$ 即可。具体的，这个做法我们用 trie 树实现。

# 解法

维护 trie 树的解法。

首先考虑维护一颗由 $b$ 前缀构成的树，然后每次可以枚举 $p_{1}$，运用 trie 树判断运用 $p_{1}$ 生成的 $p$ 序列是否合法，即最大值是否小于 $n+1$，最小值是否大于 $0$，如果合法，按思路构造即可。最后通过队列一层一层清空即可，这样只会清空不为 $0$ 的节点。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=42'000'000;
int son[N][2],idx; 
void gun() {
	queue<int> q;
	q.push(0);
	while(q.size()) {
		auto t=q.front();
		q.pop();
		for(int i=0;i<2;i++) if(son[t][i]) q.push(son[t][i]),son[t][i]=0;
	}
}
void insert(int x) {
	int p=0;
	for(int i=19;i>=0;i--) {
		int u=(x>>i)&1;
		if(!son[p][u]) son[p][u]=++idx;
		p=son[p][u];
	}
}
int qry_max(int x) {
	int p=0,ans=0;
	for(int i=19;i>=0;i--) {
		int u=(x>>i)&1;
		if(son[p][!u]) {
			ans+=(1<<i);
			p=son[p][!u];
		}
		else p=son[p][u];
	}
	return ans;
}
int qry_min(int x) {
	int p=0,ans=0;
	for(int i=19;i>=0;i--) {
		int u=(x>>i)&1;
		if(son[p][u]) p=son[p][u];
		else {
		    ans+=(1<<i);
		    p=son[p][!u];
		}
	}
	return ans;
}
int n;
int a[N];
signed main() {
	int tt;
	cin>>tt;
	while(tt--) {
		cin>>n;idx=0;
		for(int i=1;i<n;i++) cin>>a[i];int cnt=0;
		for(int i=1;i<n;i++) {cnt^=a[i],insert(cnt);}
		for(int i=1;i<=n;i++)
			if(qry_max(i)<=n&&qry_min(i)>=1) {
				cnt=0;
				cout<<i<<' ';
				for(int j=1;j<n;j++) {
					cnt^=a[j];
					cout<<(cnt^i)<<' ';
				}
				break;
			}
		gun();
		puts("");
	}
	return 0;
} 
```

---

## 作者：CNS_5t0_0r2 (赞：0)

显然如果 $p_1$ 确定了整个排列就都确定了。

一个比较好想的思路是枚举 $p_1$，然后求出 $p$，判断是否存在 $p_i > n$。暴力复杂度为 $O(n ^ 2)$。

（下文 $\oplus$ 均表示按位异或）。

考虑 $b$ 的异或前缀和数组 $s$ 的意义：$s_i$ 表示 $p_1 \oplus p_{i + 1}$，又因为 $x \oplus x = 0$，所以 $p_1 \oplus p_1 \oplus p_{i + 1} = p_{i + 1}$。因此，我们只需要判断是否存在 $p_1 \oplus s_i > n$ 即可。

显然，我们根本不需要枚举整个 $s$，只用判断 $\max_{i = 1} ^ {n - 1}\{p_1 \oplus s_i\}$ 是否大于 $n$，而 $\max_{i = 1} ^ {n - 1}\{p_1 \oplus s_i\}$ 是可以用 0-1 Trie 在 $O(\log n)$ 的复杂度内求出来的，所以一组数据的总复杂度为 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e6 + 1,LOGN = 22,K = N * LOGN;
int T;
int n,logn;
int b[N],s[N];
int p[N];
struct node{
    int ch[2];
} trie[K];
int node_cnt;
void insert(int x){
    int u = 0;
    for(int i = logn;i >= 0;i--){
        int c = (x >> i) & 1;
        if(!trie[u].ch[c])
            trie[u].ch[c] = ++node_cnt;
        u = trie[u].ch[c];
    }
}
int query(int x){
    int u = 0,ret = 0;
    for(int i = logn;i >= 0;i--){
        int c = (x >> i) & 1;
        if(trie[u].ch[!c]){
            u = trie[u].ch[!c];
            ret = (ret << 1) | 1;
        }
        else{
            u = trie[u].ch[c];
            ret <<= 1;
        }
    }
    return ret;
}
bool find(int x){//这玩意写完后我觉得自己是唐氏（直接用bool数组不就行了）
	int u = 0;
	for(int i = logn;i >= 0;i--){
		int c = (x >> i) & 1;
		if(!trie[u].ch[c])
			return false;
		u = trie[u].ch[c];
	}
	return true;
}
void clear(){
	for(int i = 1;i <= n;i++)
		p[i] = 0;
	for(int i = 0;i <= node_cnt;i++)
		trie[i].ch[0] = trie[i].ch[1] = 0;
	node_cnt = 0;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while(T--){
		cin >> n;
		logn = log2(n);
		clear();
		for(int i = 1;i <= n - 1;i++){
			cin >> b[i];
			s[i] = s[i - 1] ^ b[i];
			insert(s[i]);
		}
		for(int i = 1;i <= n;i++){
			if(b[1] != i && query(i) <= n && !find(i)){
				p[1] = i;
				break;
			}
		}
		for(int i = 2;i <= n;i++)
			p[i] = p[i - 1] ^ b[i - 1];
		for(int i = 1;i <= n;i++)
			cout << p[i] << ' ';
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：Cyx20110930 (赞：0)

# 前言

场上思路对了，死活 17 分。赛后发现是判断答案是否大于 $n$ 时没有及时跳出循环……

# 简要题意

对于一个 $1 \sim n$ 的排列 $\Set{p_n}$，定义其异或生成序列为一个长度为 $n-1$ 的非负整数序列 $\Set{b_{n-1}}$，按如下方式生成：

$b_i = p_i ⊕ p_{i + 1}$

其中 $⊕$ 代表按位异或运算。在 C++ 语言中由 `^` 运算符表示。

给定 $n,\Set{b_{n-1}}$，你需要构造一个对应的排列 $\Set{p_n}$。

# Sol

这题难点就是暴力算法的优化。

易得：若知道 $p_1$，则有 $p_i\to p_{i-1}⊕b_{i-1}$。那么算出 $b$ 数组的异或前缀和 $c$ 数组，有 $p_i = p_1⊕c_i$。

注意到 $p_1$ 不等于 $c$ 中任何元素，否则 $p_i=0$，矛盾；且 $p_1$ 异或 $c$ 中任何元素不应超过 $n$，否则 $p_i>n$，矛盾。

那么时间复杂度最坏 $O(n^2)$，但是两个条件能大幅削减所用时间，使其近似达到 $O(n)$ 的复杂度。

# Code

```
#include<bits/stdc++.h>
using namespace std;
int xo[2000005],a[2000005];
bool fl[2000005];
int n;
bool check(int x){
    for(int i=1;i<n;i++){
		if((x^xo[i])>n) return false;
	}
	return true;
}
void solve(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>a[i];fl[i]=1;
	}
	fl[n]=1;
	for(int i=1;i<n;i++){
		xo[i]=(xo[i-1]^a[i]);
		fl[xo[i]]=0;
	}
	for(int i=1;i<=n;i++){
		if(fl[i]){
			int fll=1;
			for(int j=1;j<n;j++){
				if((i^xo[j])>n) {fll=0;break;}
			}
			if(fll){
				cout<<i<<' ';
				for(int j=1;j<n;j++){
					cout<<(i^xo[j])<<' ';
				}
				break;
			}
		}	
	}
	cout<<endl;
}
int main(){
	int t;cin>>t;
	while(t--){
		solve();
	}
}
```

---

## 作者：GGapa (赞：0)

#### 题解

在本文中若 $s \in \mathbb{Z}$，则 $s_i$ 指 $s$ 在二进制表示下的第 $i$ 位是多少（从 $0$ 开始）。

考虑暴力，依次枚举 $p_1$ 是什么，然后通过递推式 $p_{i + 1} = p_i \oplus b_i$ 判断序列是否合法即可，时间复杂度 $O(n^2)$。

暴力给了我们一个关键的信息，如果我们可以将判断序列是否合法的时间复杂度从 $O(n)$ 优化到 $O(1)$ 就可以解决这个问题，考虑优化。

由于异或操作的特殊性，可以将每一位拆开考虑。实际上若 $b_{i,j} = 1$ 则说明 $p_i$ 和 $p_{i+1}$ 的第 $j$ 位是不同的。

所以，我们可以将每一位分成两个集合，这两个集合的取值不能相同。记 $S(i)_j = 0/1$  代表 $p_i$ 的第  $j$  位属于 $0/1$ 集合，转移即为 $S(i + 1) \gets S(i) \oplus b_i$。

不要忘记我们的目标是优化判断，如果 $p_{1,j}$ 是 $1$ 或 $0$ 我们该如何快速判断这一位是不是合法的？

由于 $S(1) = 0$，且 $p_i \in [1, n]$ 如果我们想知道 $p_{1,j}$ 能否填为 $x$，我们就只需要判断如下等式是否成立即可。

$$\sum_{i=1}^n[i_j=x] = \sum_{i=1}^n[S(i)_j=0]$$

用自然语言来讲即为 $[1, n]$ 中第 $j$ 位为 $x$ 的数量是否等于第 $j$ 位集合 $0$ 的大小。显然等号左边和右边均可以 $O(n)$ 预处理。可以通过 dfs 爆搜 $p_1$ 的每一位填什么。

至此本题完结，时间复杂度为 $O(n \log n)$。

#### 代码

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = (a), stOwxc = (b); i <= stOwxc; i++)
#define per(i, a, b) for(int i = (a), stOwxc = (b); i >= stOwxc; i--)
using namespace std;
using LL = long long;
using VI = vector<int>;

void solve() {
    int n; cin >> n;
    vector<int> A(n + 1), vis(n * 2), B = A; vis[0] = 1;
    vector<VI> num(23, VI(2)), cnt = num;

    rep(i, 1, n) {
        if(i > 1) {
            cin >> A[i]; B[i] = A[i];
            A[i] ^= A[i - 1] ;
            vis[A[i]] = 1;
        }
        rep(j, 0, 22) num[j][i >> j & 1]++;         // 等号左边
        rep(j, 0, 22) cnt[j][A[i] >> j & 1]++;      // 等号右边
    }

    auto out = [&](int x) {
        if(vis[x]) return false;
        rep(i, 1, n) {
            if(i > 1) x ^= B[i];
            cout << x << " \n"[i == n];
        }
        return true;
    };

    bool tag = false;
    function<void(int, int)> dfs = [&](int x, int nw) {
        if(x == -1) return tag |= out(nw), void();
        if(tag) return ;
        rep(i, 0, 1) if(cnt[x][0] == num[x][i]) 
            dfs(x - 1, nw ^ (i << x)) ;
    };
    dfs(22, 0) ;
    
    assert(0);
}

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int T; cin >> T;
    while(T--) solve();
    return 0;
}
```

---

## 作者：I_will_AKIOI (赞：0)

首先考虑暴力。枚举 $p_1$，然后根据 $b_i=p_i\oplus p_{i+1}$，根据异或的性质，可得 $p_{i+1}=b_i\oplus p_i$，然后不断递推，判断 $p$ 是否是一个 $1\sim n$ 的排列。

然后考虑正解。把刚才的式子修改一下，可得 $p_{i+1}=p_1\oplus\bigoplus_{j=1}^{i} b_i$。因此考虑给 $b$ 做一遍前缀异或和，设为 $sum$。这样 $sum_i$ 就可以表示 $\bigoplus_{j=1}^{i} b_i$。

我们知道一个 $1\sim n$ 排列的最小值为 $1$，最大值为 $n$。所以 $\min_{i=1}^{n} p_1\oplus sum_i=1,\max_{i=1}^{n} p_1\oplus sum_i=n$。因此我们只需要查询 $p_1$ 异或上 $sum_i$ 的最小值和最大值就行了，这个问题很明显可以使用 01trie 来维护。所以枚举 $p_1$，判断 $p_1$ 是否合法，合法就递推求出排列 $p$ 输出。

```cpp
#include<bits/stdc++.h>
#define N 2000005
#define M 24
using namespace std;
int n,cnt,a[N],b[N],t[N*25][2];
void insert(int x)
{
  int root=0;
  for(int i=M;i>=0;i--)
  {
    bool now=x&(1<<i);
    if(t[root][now]==0) t[root][now]=++cnt;
    root=t[root][now];
  }
  return;
}
int query1(int x)//查询x异或a[1~n]的最大值
{
  int root=0,sum=0;
  for(int i=M;i>=0;i--)
  {
    bool now=(x&(1<<i));
    if(t[root][0]==0&&t[root][1]==0) break;
    if(t[root][now^1]==0) root=t[root][now];
    else root=t[root][now^1],sum+=(1<<i);
  }
  return sum;
}
int query2(int x)//查询x异或a[1~n]的最小值
{
  int root=0,sum=0;
  for(int i=M;i>=0;i--)
  {
    bool now=(x&(1<<i));
    if(t[root][0]==0&&t[root][1]==0) break;
    if(t[root][now]==0) root=t[root][now^1],sum+=(1<<i);
    else root=t[root][now];
  }
  return sum;
}
void solve()
{
  int sum=0;
  cin>>n;
  for(int i=0;i<=cnt;i++) t[i][0]=t[i][1]=0;
  cnt=0;
  for(int i=1;i<n;i++) cin>>a[i];
  for(int i=1;i<n;i++) sum^=a[i],insert(sum);//求前缀异或和并插入01tire
  for(int i=1;i<=n;i++)
  {
    int x=query1(i),y=query2(i);
    if(x<1||x>n||y<1||y>n) continue;//判断p[1]是否合法
    b[1]=i;
    break;
  }
  for(int i=2;i<=n;i++) b[i]=b[i-1]^a[i-1];
  for(int i=1;i<=n;i++) cout<<b[i]<<" ";
  cout<<"\n";
  return;
}
int main()
{
  ios::sync_with_stdio(0);
  int t;
  cin>>t;
  while(t--) solve();
  return 0;
}
```

---

## 作者：Union_Find (赞：0)

出题人说是原题，但是我没做过原题，所以我讲一下我赛时的丑陋写法吧。

首先我们发现，如果有题目中的 $b$ 数组和 $p_1$，我们就可以求出整个 $p$ 数组。所以我们就有了 $O(n^2)$ 的做法。首先先暴力枚举 $p_1$，然后求出 $p$ 数组，判断是否是排列，如果是就输出。

其实只要加点小剪枝就有了 $66$ 分。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 12000005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n, a[N], s[N];
int main(){
	for (int T = rd(); T--;){
		n = rd();
		for (int i = 1; i < n; i++) a[i] = rd(), s[i + 1] = s[i] ^ a[i];
		for (ll p = 1; p <= n; p++){
			ll flag = 1;
			for (int j = 1; j <= n; j++){
				if (1 <= (p ^ s[j]) && (p ^ s[j]) <= n);
				else{
					flag = 0;
					break;
				}
			}
			if (flag){
				for (int j = 1; j <= n; j++) printf ("%lld ", (p ^ s[j]));puts("");
				break;
			}
		}
	}
	return 0;
}
```

如果你直接看我代码发现我写的和讲的不一样。因为有了 $b$ 数组，我们就可以用前缀异或和求出 $p_1$ 和其它所有数字的异或值。


我们发现时间复杂度差在判断是否是排列。如果我们可以快速判断就可以了。首先如果 $p$ 是一个排列，就要所有数字只出现一次并且数字在 $1$ 到 $n$ 之间。首先是所有数字只出现一次。我们知道如果 $b \ne c$，那么 $a \operatorname{xor} b \ne a \operatorname{xor} c$。所以只要 $s_i \ne s_j$，数字就不会重复，其中 $s$ 是前缀异或和。

然后是在 $1$ 到 $n$ 之间。只要 $\min{p_1 \operatorname{xor} s_i} \ge 1$ 并且 $\max{p_1 \operatorname{xor} s_i} \le n$，就满足了。求异或最大值和最小值，自然就是 01 Trie 了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll int
#define il inline
#define N 2000005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n, a[N], s[N], tag[N * 20], son[N * 20][2], ex = 1;
il void insert(ll x){
	ll u = 1;
	for (int i = 0; i <= 19; u = son[u][(x >> (19 - i)) & 1], i++)
		if (!son[u][(x >> (19 - i)) & 1]) son[u][(x >> (19 - i)) & 1] = ++ex;
	tag[u] = 1;
}
il ll min_xor(ll x){
	ll u = 1, ans = 2147483647, sum = 0;
	for (int i = 0; i <= 19; i++){
		if (tag[u]) ans = min(ans, sum);
		if (son[u][(x >> (19 - i)) & 1]) u = son[u][(x >> (19 - i)) & 1];
		else u = son[u][((x >> (19 - i)) & 1) ^ 1], sum += (1 << (19 - i));
	}return min(ans, sum);
}
il ll max_xor(ll x){
	ll u = 1, ans = 0, sum = 0;
	for (int i = 0; i <= 19; i++){
		if (tag[u]) ans = max(ans, sum);
		if (son[u][((x >> (19 - i)) & 1) ^ 1]) u = son[u][((x >> (19 - i)) & 1) ^ 1], sum += (1 << (19 - i));
		else u = son[u][(x >> (19 - i)) & 1];
	}return max(ans, sum);
}
int main(){
	for (int T = rd(); T--;){
		n = rd();
		for (int i = 1; i <= 20 * n; i++) son[i][0] = son[i][1] = tag[i] = 0;
		ex = 1;
		insert(0);
		for (int i = 1; i < n; i++) a[i] = rd(), s[i + 1] = s[i] ^ a[i], insert(s[i + 1]);
		for (ll p = 1; p <= n; p++){
			ll flag = (1 <= min_xor(p)) && (max_xor(p) <= n);
			if (flag){
				for (int j = 1; j <= n; j++) printf ("%d ", p ^ s[j]);putchar('\n');
				break;
			}
		}
	}
	return 0;
}
```

---


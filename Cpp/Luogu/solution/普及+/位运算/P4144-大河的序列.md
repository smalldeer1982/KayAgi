# 大河的序列

## 题目背景

“唯有龙虎相伴 最是脉脉深情”


题目来源：[KingSann](https://www.luogu.org/space/show?uid=47111)


## 题目描述

大河有一些袜子，但经常十分散乱的堆放着。


有一天龙儿忍不住了，于是将袜子放到了一个序列上（称作袜子序列）。


每个袜子都有一个$dirty$值，定义袜子序列的$dirty$值为 $ \max  \left( (dirty_{l} \ bitand \ dirty_{l+1} \ bitand \ \cdots \ bitand \ dirty_{r}) + (dirty_{l} \ bitor \ dirty_{l+1} \ bitor \ \cdots \ bitor \ dirty_{r}) \right) $ ，其中 $ dirty_{i} $ 表示 第 $ i $ 只袜子 的 $ dirty $ 值，$bitand$表示按位与（C++中是`&`），$bitor$表示按位或（C++中是`|`）。


简而言之，就是找一段连续子序列，使得所有数字的按位与加上按位或最大。


如果这个袜子序列的$dirty$值达到了某个**阈**值，那么龙儿会讨厌大河的。


大河当然不希望这样了，于是她想知道这个袜子序列的$dirty$值是多少。


## 说明/提示

$ 1 \le n, p \le 10^{5} $


$ 0 \le b, ditry_{i} \le 10^{7} $


对于测试点 $ 1 $ 和测试点 $ 2 $ 的数据，保证 $ 1 \le n \le 100 $


## 样例 #1

### 输入

```
10 1 10000000
7 9 9 4 0 0 8 8 4 7```

### 输出

```
251```

# 题解

## 作者：xzyxzy (赞：26)

### 答案是最大的那个数乘2
证明

假设现在答案是w，加入一个数x，依照按位贪心的思想（选高位的1一定最优），分两种情况讨论：

1.`w>x` w在前面的位上有1但x没有，那么肯定不选x，因为&和损失的高位上的1,再怎么增加|和的后面位置的1都于事无补,那么这个时候选w优于选wx优于选x

2.`w=x` 显然这时选不选都没关系

3.`w<x` w前几位的1,x都有，而且w某一个较高位的0,x也有1,这个时候如果把w与x合并，只会增加|和，而如果抛弃w把答案置为x，那么会增加|和和&和，显然这时选x更优，其实就是swap(x,w)就转化成了第一种情况

综上，答案是最大的数乘2

```cpp
// luogu-judger-enable-o2
#include<iostream>
using namespace std;
int n,b,p,mod;
int ksm(int x,int k)
{
    int ans=1,base=x;
    while(k)
    {
        if(k&1) ans=1ll*ans*base%mod;
        base=1ll*base*base%mod; k>>=1;
    }
    return ans;
}
int main()
{
    cin>>n>>b>>mod;
    for(int i=1,x;i<=n;i++) cin>>x,p=max(x,p);
    cout<<ksm(p*2+233,b)%mod;
}

```
[Advertisement](https://www.cnblogs.com/xzyxzy)

---

## 作者：封禁用户 (赞：14)

~~敲完后来看题解发现都是拿某max×2结论做的然后我就233了~~

这题我用的是二分+按位贪心，就是我枚举左端点$l$，然后按照从高位到低位的顺序贪心，我们发现如果$dirty_l$的$i$位为0，那么这位是无论如何都$bitand$不出1的，就考虑$bitor$出1，设我们当前右端点的备选区间为$[L,R]$，我们发现如果一个位置上出现了1，再往后面$bitor$就都是1了，这个是具有单调性的可以二分去做，注意，这里我们要二分最小的位置，因为我们贪心是尽量满足高位的，我们二分出这个位置后就把$L$赋值（这样这个备选区间就能满足这位$bitor$起来一定为1）。如果$dirty_l$的$i$位为1，那我们就尽量让这位$bitand$起来为1（这时候$bitor$起来一定是1不用管他），然后我们发现当一个位置出现0后后面的位置再$bitand$就都是0，所以我们要二分出最大的位置满足$bitand$起来是1，然后给$R$赋值。复杂度$O(nlog^2n)$。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
inline int get(){
	int n;char c;while((c=getchar())||23333)if(c>='0'&&c<='9')break;
	n=c-'0';while((c=getchar())||23333){
		if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
	}
}
int ints[100001];
int p,p5;
inline int modp(int n){
	if(n>p5)return(n%p);while(n>=p)n-=p;return(n);
}
inline int mi(int a,int b){
	int ans=1,tmp=a;while(b){
		if(b&1)ans=modp(ans*tmp);tmp=modp(tmp*tmp);b=(b>>1);
	}return(ans);
}
int sums[100001][32];
signed main(){
	int n=get(),b=get();p=get();p5=p*5;
	for(register int i=1;i<=n;i++){
		ints[i]=get();for(register int j=0;j<=25;j++){
			sums[i][j]=sums[i-1][j]+((ints[i]&(1<<j))!=0);
		}
	}int maxn=0;
	for(register int i=1;i<=n;i++){
		int lbd=i,rbd=n,tot=0;for(register int j=25;j>=0;j--){
			if(ints[i]&(1<<j)){
				int ans=-1,l=lbd,r=rbd;while(l<=r){
					int mid=(l+r)>>1;if(sums[mid][j]-sums[i-1][j]==mid-i+1)ans=mid,l=mid+1;
					else r=mid-1;
				}if(ans==-1){
					tot+=(1<<j);
				}else{
					tot+=(1<<j);tot+=(1<<j);rbd=ans;
				}
			}else{
				if(sums[rbd][j]-sums[i-1][j]==0)continue;
				int l=lbd,r=rbd,ans=-1;while(l<=r){
					int mid=(l+r)>>1;if(sums[mid][j]-sums[i-1][j]>0)ans=mid,r=mid-1;
					else l=mid+1;
				}if(ans==-1)continue;lbd=ans;tot+=(1<<j);
			}
		}maxn=max(maxn,tot);
	}cout<<modp(mi(maxn+233,b))<<endl;
	return(0);
}
```

---

## 作者：wxgwxg (赞：8)

这题直接找最大的数乘二就可以了


证明 假设存在一个长度过2的区间更优

,将这个区间降序排序后求答案，设$bitand$的答案为ans1，$bitor$的答案为ans2，把答案看成2进制，若用更小的数更新后，ans2某一位从0变成了1，那一定有ans1的比它大的一位从1变成了0，因为从大到小，如果ans1没有变动，那么这个数起码比之前那个要大，所以不存在一个长度过2的区间更优，因为取这个区间中最大的比它优。

代码就非常简单了，要注意b=0,p=1的情况

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,b,p,ans;
int ksm(int x,int k) {int ans=1;for(;k;k>>=1,x=1ll*x*x%p) if(k&1) ans=1ll*ans*x%p;return ans%p;}
int main()
{
    int a;
    scanf("%d%d%d",&n,&b,&p);
    for(int i=1;i<=n;i++) scanf("%d",&a),ans=max(ans,a);
    printf("%d\n",ksm(233+(ans<<1),b)); 
    return 0;
}
```

---

## 作者：zjy111 (赞：5)

本来我开这道题是为了强化位运算的知识的

后来发现这只是一个神奇的贪心~~结论题~~而已

### 结论: 答案是序列中最大值的两倍 (即序列中只包含最大的元素时最优)

证明方法如下: ~~其实两种证法看上去有点相似呢qwq~~

---

**1.用反证法证明**

假设存在一个序列长度为$2$, 且包含元素$a$, $b$, 其中$a$是序列中的唯一最大值,

则对于$a$, $b$的二进制表示$s1$, $s2$中, 必定存在一个数$i$, 

使得$s1$的前$i$位对应的数$≥s2$的前$i$位对应的数, 

且$s1$的第$i$位为1, $s2$的第$i$位为0, 

那么这时我们用$b$更新 $bitand$ 的值时, 第$i$位会从$1$被更新为$0$, 也就是减少了$2^m$ ($m$是从$i$到末尾的位数个数)

而假设$s1$后面的所有位数都是$0$, $s2$后面的所有位数都是$1$, 

那么 $bitor$ 的值也只是将第$i$位以后的值从$0$更新为$1$, 最多只能增加 $2^m-1$, 总的来讲还是减少了, 所以不存在更优解

----

**2.用顺推法证明**

对于任意一个数$a$, 我们分析这个数加入序列后会发生的变化

那么对于$a$的二进制表示从高到低进行讨论

- 如果是$1$: 那么 $bitand$ 的值不会变少, 而且如果原来 $bitor$ 的二进制表示在这一位上是$0$, 那么就会变成$1$

- 如果是$0$: 那么 $bitor$ 的值不会变多, 而且如果原来 $bitand$ 的二进制表示在这一位上是$1$, 那么就会变成$0$

综上所述, 我们要取的$a$应该尽可能在高位上是$1$, 所以$a$应该最大

证毕. 

### 如果有第一个点WA的自行前往[讨论区](https://www.luogu.org/discuss/show/31615)

---

献上码风奇特的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int arr[100005],n,b,p,ans;
ll ksm(ll x,ll y,ll p){ //快速幂
	ll base=x;x=1;
	while(y){
		if(y&1)x*=base;
		base*=base;
		if(base>p)base%=p;
		if(x>p)x%=p;
		y>>=1;
	}
	return x;
}
int main() {
	cin>>n>>b>>p;
	for(int i=1;i<=n;i++)scanf("%d",&arr[i]),ans=max(ans,arr[i]); //取最大值
	cout<<ksm(ans*2+233,b,p)%p; //按照题目要求处理答案
	return 0;
}

```



---

## 作者：Aw顿顿 (赞：4)

题目的 LaTeX 由于变量名太长不便阅读，这里会给出一个清爽一些的版本。

## 题意简述

存在一个包含 $n$ 个元素的序列：

$$d=\{d_1,d_2,d_3,\cdots,d_{n-1},d_n\}$$

对于它的任意一个子序列：

$$v=\{d_i,d_{i+1},d_{i+1},\cdots,d_{j-1},d_{j}\}$$

我们定义 

$$s_1=\{d_i\ \text{and}\ d_{i+1}\ \text{and}\ d_{i+1},\cdots d_{j-1} \ \text{and}\ d_{j}\}$$

$$s_2=\{d_i\ \text{or}\ d_{i+1}\ \text{or}\ d_{i+1},\cdots d_{j-1} \ \text{or}\ d_{j}\}$$

求一个子序列，使得 $s_1+s_2$ 尽可能大。

## 解法简述

假设现在存在一个子序列 $v_1$，那么现在要加入一个数 $c$，那么我们**按位**来看情况如何：

对于其中的某一位，$c$ 在这一位一定存在两种情况：

- 为 $0$：
	- 按位或：不会变多，无论哪种情况（想想为什么）。
    - 按位与：结果一定为 $0$。
- 为 $1$：
	- 按位或：结果一定为 $1$。
    - 按位与：不会变少，无论哪种情况。

那么我们很容易想到的贪心策略是这样：尽可能要 $1$。

而这样的一个 $1$ 对于高位的贡献显然是大于低位的，所以我们要找的序列都要尽可能大，而任何一个 $c$，如果比原来的序列中所有数都小，那么它是无需加入的（也就是说，贡献为负）。

那么我们从任何一个数开始，把所有比他大的数加进来，那他对这个序列的贡献就是负了，那么我们就可以把它踢出去，依次类推，只留下了最大的数。什么？你说如果没有比他大的数？那留下他，还是留下了最大的数。

那么我们计算的时候，由于没有别的数，就等于将它计算了两边，这就是为什么 $x$ 是序列中最大值的两倍。同时，我们只要代入计算就可以了，用快速幂即可。

快速幂大概就是分而治之的一个思想，每次指数减半，底数自乘，可以用 $O(\log n)$ 的速度求出来输出值，同时由于找最大值只要一边输入一边找，所以复杂度是 $O(n)$ 的。

那么数据其实可以加到 $10^8$ 了（

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b,x,p;
int qp(int x,int k){
    int s=1,b=x;
    while(k){
        if(k&1)s=1ll*s*b%p;
        b=1ll*b*b%p; k>>=1;
    }return s;
}int main(){
    cin>>n>>b>>p;
    for(int i=1;i<=n;i++){
        int a;cin>>a;
        x=max(a,x);
    }cout<<qp(x*2+233,b)%p;
    return 0;
}
```

--------
如果你错了第一个测试点，[请认真审题](https://www.luogu.com.cn/discuss/show/31615)。

---

## 作者：Acerkaio (赞：2)

第一篇题解解释过于片面了吧。
### 思路
答案就是序列中最大值的二倍。

为什么是这样？

两个证明方法：

1. 反证法：我们先假设有两个数，且第一个数大于第二个数。如果要使得所有数字的按位与加上按位或最大，所以要第二个数二进制最接近地一个数，如果第一个数的第 $0$ 位是 $1$。则第二个数的第 $0$ 位就要是 $0$，其它位与第一个数相同。或运算出来的结果就与第一个数相同，与运算后就丢了最后一位，所以相加结果小于第一个数的二倍。如果第一个数最后一位是 $0$，则第二个数的最后一个 $1$ 改为 $0$ 或第二个数减一，最后得出的结果都不如第一个数的两倍，自己手动模拟试试吧。

1. 顺推法：我们先假设有两个数，且第一个数大于第二个数。如果第一个数的二进制位数还多余第二个数，不用想，取第一个数，如果位数相同，由于的二个数小于第一个数，则第一个数一定有一位是 $1$ 时，第二个数是 $0$。找到这些情况的最高位，并且运算后就会保留 $0$，这以后不管怎么或运算以后也无济于事。

这题就可以做[快速幂](https://www.luogu.com.cn/problem/P1226)了。

### CODE

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
priority_queue <int> prq;
inline int qpow(int a, int b, int k) {
	int ans = 1, temp = a, num = b;
	while(num) {
		if(num & 1) {
			ans = ans * temp % k;
		}
		temp = temp * temp % k;
		num >>= 1;
	}
	return ans;
}
signed main() {
	int n, b, p;
	cin >> n >> b >> p;
	for (int i = 1; i <= n; i++) {
		int x;
		cin >> x;
		prq.push(x);
	}
	cout << qpow(prq.top() * 2 + 233, b, p) % p << '\n';
	return 0;
}
```


---

## 作者：ModestCoder_ (赞：2)

真没想到这是一道结论题

先放结论:$ans=2a_{max}$

如何证明？

假如现在手里有一个数x，考虑是否能把这个数后面的那个数y加入，组成一个两个数的序列

那就是是否更优

对于$x$的二进制形式的某一位讨论

 - 是1：若y的对应位是1，那么组合成一起不会更优却也不会更劣；若y的对应位是0，那么组合成一起$or$没事，$and$却成了0，更劣了
 - 是0：若y的对应位是0，那么不会更优也不会更劣；若y的对应位是1，更优了，但是我们发现一点，x和y组合在一起比x单独更优，然而y单独却比xy组合在一起还要优，而且x这一位是1的情况不影响答案，所以还不如换成y单独选呢

所以就得到结论了，选择最大的那个数就行了

大坑点：注意$p=1$的情况

Code：

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
LL n, b, qy;

inline LL read(){
	LL s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

LL ksm(LL n, LL k){
	if (!k) return 1 % qy;
	LL sum = ksm(n, k >> 1);
	sum = sum * sum % qy;
	if (k & 1) sum = sum * n % qy;
	return sum;
}

int main(){
	n = read(), b = read(), qy = read();
	LL ans = 0;
	for (int i = 1; i <= n; ++i) ans = max(ans, read());
	printf("%lld\n", ksm((ans << 1) + 233, b));
	return 0;
}
```



---

## 作者：BF_AlphaShoot (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4144)。

这道题是我们学校 17 级学长 [nekko](https://www.luogu.com.cn/user/47111) 出的啊，正好最近几天他当年同机房的同学 [Zhang_RQ](https://www.luogu.com.cn/user/31565) 给我们讲进阶贪心时讲到这道题了，所以~~在 nekko 打原神的时候~~我得以直接问到这道题的细节。

显然是**贪心**，但是贪心策略有两个。

第一个是**二分+按位贪心**，这其实是出题时的标算。

枚举左端点 $l$​​​，按照从高位到低位的顺序贪心，若 $dirty_l$​​​ 的第 $i$​​​ 位为 $0$​​​，那么这位是无论如何都 $\&$​​​ 不出 $1$​​​ 的，所以考虑 $|$​​​ 出 $1$​​​。

设当前右端点的备选区间为 $[l,r]$​​​，如果一个位置上出现了 $1$​​​，再往后面 $|$​​​ 就都是 $1$​​​ 了。二分最小的位置，如果 $dirty_l$​​​ 的 $i$​​​ 位为 $1$​​​，就尽量让这位 $\&$​​​ 起来为 $1$​​​。

发现当一个位置出现 $0$​​​ 后，后面的位置再 $\&$​​​ 就都是 $0$​​，所以二分出最大的位置满足 $\&$​​ 起来是 $1$​​，然后给 $r$​​ 赋值。

这里就不提供代码了，感兴趣的可以去看看同样与 nekko 同机房的 [ywy_c_asm](https://www.luogu.com.cn/user/125124) 的 [题解](https://www.luogu.com.cn/blog/user56917/solution-p4144)。

然而第二个贪心策略吊打标算：**最大值 $\times2$**。

不妨使用反证法证明。

假设有一个长度大于 $2$​​ 的区间答案，区间降序排序后求答案。对于二进制下的答案，若用更小的数更新后，可能出现 $\&$​​ 的结果第 $i$ 位从 $0$ 变成了 $1$​​。

从大到小，如果经 $\&$​​ 的结果没变，则这个数至少比之前那个要大，所以一定有经 $|$​​ 的结果的比 $i$ 大的一位从 $1$ 变成了 $0$​​​。

**注意**：代码实现中需要开 long long 并使用**快速幂**，
在输出中，代码写为：

```cpp
printf("%lld",qpow(ans*2+233,b,p)%p);
```

因为有的人不在后面再写​一个 `%p`，所以毒瘤 nekko 特意把第一个点设为 $b=0$​ 且 $p=1$​​，这样子有的人就会得出**错解**。​

View code：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define rll register long long
#define il inline

ll n,b,p,ans=0;

il ll read(){
    ll x=0,y=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            y=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*y;
}

il ll qpow(ll a,ll b,ll p){
    ll ans=1;
    for(;b;b>>=1,a=a*a%p)
        if(b&1)
            ans=ans*a%p;
    return ans;
}

signed main(){
    n=read(),b=read(),p=read();
    for(rll i=1;i<=n;i++){
        ll x=read();
        ans=max(ans,x);
    }
    printf("%lld",qpow(ans*2+233,b,p)%p);
    return 0;
}
```

---

## 作者：Cocoly1990 (赞：1)

## 前置芝士
 [快速幂](https://www.luogu.com.cn/problem/P1226) ， 位运算
 ~~如果不会的话就不用做了~~
## 题意化解

 即对于任意序列：
 
 $$\text{\{$d_1+d_2+d_3+...+d_n$\}}$$
 
 要求找出子序列：
 \{$d_i,d_{i+1},d_{i+2},...,d_{j-1},d_j$\}
  
 我们定义：
x=\{$d_i\&d_{i+1}\&d_{i+2}\&...\&d_{j-1}\&d_j$\}+\{$d_i|d_{i+1}|d_{i+2}|...|d_{j-1}|d_j$\}
  
 使得$x$有尽可能小
## 解法细解 
 结论：
$$\text{$2 \times d_{max} = x$}$$
~~没想到这个序列长度为壹吧~~

证明：

对于任意$a$，设他的下一项为$b$ ，且满足 $a>b$

则在二进制下必有一位$i$满足如下表格
![image.png](https://i.loli.net/2020/10/06/lDRMuzFK74CposJ.png)

易得以下结论
$$\text{$a\&b<a$}$$
$$\text{$a-a\&b>a-a|b$}$$
简单讲就是选$a,b$不如选$a$划算

有以上结论，就易得[代码](https://www.luogu.com.cn/paste/4yzsdmoo)

sol by Cocoly1990
 

---

## 作者：kaceqwq (赞：0)

# 题目大意：
在一段序列中寻找一段连续子序列，使得所有数字的按位与加上按位或最大。

# 思路：
这道题其实就是一道贪心结论题。

先给出结论：
### 答案是序列中最大的数乘 $2$

接下来，顺着我的思路来证明它。

首先，设当前的答案为 $a$，接下来加上的数为 $b$，保证 $a>b$。如果原数 $a$ 还比 $a$ 和 $b$ 进行与运算以及或运算的和更大，我们便选择 $a+a$ 这一更优的方案，那么如果，全部操作中，我们都是选择这样的方案最终的答案就是最大的数乘 $2$ 了。

方案一：选择 $a+a$。

方案二：选择 $a$ 与 $b$ 进行与运算以及或运算的和。


而我们需要证明的，即是方案一永远会大于另一种方案。

我们可以运用**反证法**证明：首先我们假设这一命题不成立，即方案二会优于方案二。

由于前提是 $a > b$，为了使 $a$ 与 $b$ 加上 $a$ 或 $b$ 的和尽量大，所以 $b$ 要尽可能接近 $a$。如果 $b$ 已经很接近 $a$ 了，并且 $2a$ 方案仍然
大于另一种方案，那么 $b$ 取任何值都会如此，综上所述，假设不成立，即命题为真。

例 $1$：     
```               
a 1111
b 1101
& 1101 
| 1111 

```
如例 $1$， 第一行代表 $a$ 在二进制表示下的数，第二行同理表示 $b$ 在二进制下表示的数，第三行代表 $a$ 与 $b$ 进行与运算的结果，第四行代表的是 $a$ 与 $b$ 进行或运算的结果。 $b$ 仅仅少于 $a$ 一个二进制的位。可以发现：当 $a$ 的第 $0$ 位上的值为 $1$ 时，
与运算的结果等于 $b$，或运算的结果等于 $a$，即方案二的结果为 $a+b$，因为 $a>b$，所以 $2a$ 一定大于 $a+b$。


例 $2$：
```
a 1010
b 1001
& 1000
| 1011
```
如例 $2$，每一行同上，当 $a$ 第 $0$ 位上的值为 $0$ 时，虽然与运算结果和或运算的结果不像例 $1$，可是我们发现：将结果相加，结果仍是 $a+b$。

### 所以只要选择数列中最大数乘 $2$ 即为答案。

然后，就差不多是快速幂板子了。

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n, b, q, zd, ans=1, a, sum;
int mi (int x, int y, int mod) {
	while (y > 0) {
		if(y%2 != 0)
		    ans = ans * x % mod;
		x = x * x % mod;
		y /= 2;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> b >> q;
	for (int i = 1; i <= n; i++) {
		cin >> a;
		zd = max (zd, a);
	}
	sum = mi (zd * 2 + 233, b, q) % q;
	cout << sum <<'\n';
	return 0;
}
```


---

## 作者：lmrttx (赞：0)


**可以推出最优值是序列中最大的数的两倍。**






证明：

设当前的最优解为 $ans$，新进来的一个数是 $x$。


我们分成三种情况判断。


情况1： $ans>x$

   设 $ans$=111001,$x$=110011,现在要将 $ans$ 与 $x$ 按位与。
   
   **按位与是两个1才为1。**
   
   那么此时 $ans$ 第三位的1会没掉，所以不能更新答案（或操作在这里可以不管）。
   


------------


情况2：$ans=x$



不管，因为操作后 $ans$ 的值不会改变。



------------

情况3：$ans<x$


          
   设 $ans$=110011,$x$=111001,现在要将 $ans$ 与 $x$ 按位与。      
	
          
   则 $ans$ 的值会变大。
  
  **或是有1就为1。**
  
  所以需要选择 $x$。
  
  接下来是关键的一步：**将大的和小的交换，发现变成情况1。**
  
  就不用取交换后的 $x$ 了。
  
	
  


------------


  
  **所以，答案为最大值+最大值。**
  
  即2倍的最大值。
  
  

------------

  
 细节
  
   1.数据定义为长整型。


  
   2.用快速幂计算，可以看1篇介绍的文章[快速幂详解](https://blog.csdn.net/weixin_41162823/article/details/80586109)。
  
  

------------

  
**代码**
  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,b,p,answer;
inline int q_pow(int a,int b){//倍增思想的快速幂 
	int res=1;
	while(b){
		if(b&1){//b&1==true表示b为奇数 
		    res=res*a%p;
	   }
		a=a*a%p;b>>=1;//注意，快速幂不能缩写成a*=a 
	}
	return res;
}
signed main() {
	scanf("%lld%lld%lld",&n,&b,&p);
	int x;
	for(register int i=1;i<=n;i++){
		scanf("%lld",&x);
		answer=max(answer,x);//记录最大值 
	}
	printf("%lld",q_pow(answer*2+233,b)%p);//如题意输出 
	return 0;
} 
```

                                   

------------

**谢谢阅读。**
                                   
                                  
                                   
                                   

---


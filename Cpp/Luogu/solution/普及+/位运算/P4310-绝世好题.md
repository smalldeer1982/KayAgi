# 绝世好题

## 题目描述

给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \& b_{i-1} \ne 0 $，其中 $2\leq i\leq k$， $\&$ 表示位运算取与。

## 说明/提示

对于100%的数据，$1\leq n\leq 100000$，$a_i\leq 10^9$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

# 题解

## 作者：winxp_qwq (赞：133)

其实就直接dp就好了

令dp[i]表示数列到目前为止最后一项第i位为1的最大子序列长度，每读入一个数时就~~大力~~转移。一个数可以被它所有的二进制位的dp值转移，然后把它转移到它的所有二进制位的dp值上。

复杂度nlogn

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[32];
int main(){
	int n;
	scanf("%d",&n);
	int a,b,c,i,j,k,ans=0;
	for(a=1;a<=n;a++)
	{
		scanf("%d",&b);
		k=1;
		for(c=0;c<=30;c++)
		if((1<<c)&b) k=max(dp[c]+1,k);
		for(c=0;c<=30;c++)
		if((1<<c)&b) dp[c]=max(dp[c],k);
		ans=max(ans,k);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Limerick (赞：52)

# ** _苹果叶万岁_ !!!**


------------

#### 此题80分做法就是纯DP,
#### 即f[i]=max{f[j]+1}且j<i且b[i]&b[j]!=0
####  _i从1~n枚举i,j从1~i-1枚举j_ 
#### 这么简单就80分了,不骗分都说不过去啊
------------
####  _那么,100分的代码是什么咧,其实很简单,哦,_ 
#### 其实&的结果最重要的是看两位二进制是否均为1,如果均为1那么&的结果为1,否则为0
#### 那就很好办了,我就搞一个数组f来进行 _dynamic programme_ ,i从1~n枚举每个数,然后枚举这个数的二进制的每一位。
#### 如果某个数二进制的第j位是1,那么f[j]++;f[j]表示到当前状态最后一个数为止的二进制的第j位满足条件的最长子序列长度。
#### 然后将所有等于1的位的f值都换成所有等于1的位上f的最大值即可。
####  _为什么可以换成最大值咧_ ?因为一个数的满足条件的二进制位上的f值可以被转移到所有满足条件的二进制位上。
#### 有的同学要问了,怎样求某个数二进制的第i位咧？这时候位运算就闪亮登场了。x&(1<<i)即可求出。
#### 举例1(其实就是样例):1 2 3
#### 转为二进制:01 10 11
#### 0.f[0]=0 f[1]=0
#### 1.f[0]=1 f[1]=0
#### 2.f[0]=1 f[1]=1
#### 3.f[0]=2 f[1]=2
#### ans=2
#### 举例2:1 3 2 4
#### 转为二进制:001 011 010 100
#### 0:f[0]=0 f[1]=0 f[2]=0
#### 1:f[0]=1 f[1]=0 f[2]=0
#### 2:f[0]=2 f[1]=max(f[1]+1=1,f[0]=2)=2,f[2]=0
#### 3:f[0]=2 f[1]=3 f[2]=0
#### 4:f[0]=2 f[1]=3 f[2]=1
#### ans=3
#### ** _其实这题还是需要一点思维的哦。_ **
#### PS:O(nlogn)搞定
#### Code:
~~~#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=35;
int n,ans,f[N],Max;
int main(){
    scanf("%d",&n);
    for(int j=1;j<=n;j++){//枚举每个数
        unsigned int x;//注意了,这里最好用unsigned int
        scanf("%ud",&x);//读入时为%ud
        Max=0;//最大值赋值为0
        for(int i=0;(1<<i)<=x;i++){//枚举这个数的每一位
            if(x&(1<<i)){//重点:如果这一位是1!!!
                Max=max(Max,f[i]+1);//长度++,并取最大进行f值的转移
            }
        }
        for(int i=0;(1<<i)<=x;i++){
            if(x&(1<<i)){//重点:如果这一位是1!!!
                f[i]=Max;//转移
            }
        }
    }
    for(int i=0;i<32;++i){
        ans=max(ans,f[i]);//ans为最长的
    }
    printf("%d\n", ans);
    return 0;
}~~~


---

## 作者：灵乌路空 (赞：25)

先无良宣传一下博客 $wwwwww$   
[文章列表 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

---

## 知识点:DP , 奇妙思路 , 暴力枚举(?)   

~~一道绝世好题~~

- ### 题目要求:  
  求 $a$ 的子序列 $b$ 的最长长度,  
  满足 $bi\ \&\ bi-1\not=0$    
  $n \le 1e5 , a_i \le 1e9$

- ### 暴力思路:  
	类比最长上升子序列  
	
    直接 $O(n^2)$ 暴力枚举  
	当前要添加的数,以及序列 $b$ 结尾的数
	  
	设 $f[i]$ 表示以$a[i]$结尾的 $b$序列的最长长度  
	则: 状态转移方程式为:   
	$\large f[i] = max(f[i], f[j]+1)\ (a[i]\ \&\ a[j] \not=0)$   
    
   可以取得 $90$ 分的好成绩(大雾) 

- ### 考虑优化  
	发现新添加的数,  
	只能由:   
   **在同一二进制位上 , 同为1的数转移而来**
	
	也就是说,  
	可以选择 枚举  
	新添加的数的 **二进制上的1位**  
	
	考虑枚举二进制位  
	并记录 :   
	此二进制位全为为$1$的数 组成的 子序列$b$   
	所能达到的最大长度为多少  
    
   设 $f[i]$ 表示 : 最后一位为 $i$ 的 $b$ 数列的最长长度,  
	$bit[j]$ 表示 : 二进制第 $j$ 位为 $1$ 的数 , 组成的子序列 $b$ 的最长长度      
   $k$ 为 枚举的: $a[i]$ 中 , 二进制上为 $1$ 的二进制位数   
   
	则可以推出新的状态转移方程式:   
   $ \large f[i] =  max(f[i] , bit[k]+1)$ 
   
   这样 就可以少一层循环  
   来枚举 新添加的数 可接到 哪些数之后.
	
	更新完 $f[i]$ 后 , 再用更新后的 $f[i]$ ,  
	反过来 更新 $bit[k]$  
    
	对于枚举 $k$  , 可以使用 $lowbit()$  , 并取其 $log$ 函数值来获得   
	在更新 $f[i]$ 的过程中取最大的 $f[i]$ 作为答案   
	最后优化到了 $O(31 \times n)$  .   
    (因为最多只有 $31$ 个二进制位上的 $1$ )   
    
--- 

上代码:

$O(n^2)$ 暴力90分:
```cpp
#include<cstdio>
#include<ctype.h>
#include<algorithm>
const int MARX	= 1e5+10;;
//=============================================================
int n,ans,a[MARX];
int f[MARX];
//=============================================================
inline int read()
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
//=============================================================
signed main()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read(),f[i]=1;//读入并初始化
	
	for(int i=2;i<=n;i++)
	  for(int j=1;j<i;j++)
	    if(a[i] & a[j])
		  f[i]=std::max(f[i],f[j]+1),//更新f[i]并找到最大值 
		  ans=std::max(ans,f[i]);
	printf("%d",ans);
}
```

---

$O(31\times n)$ $100$分

```cpp
#include<cstdio>
#include<algorithm>
#include<map>
#include<ctype.h>
#define lowbit(x) (x)&-(x)
const int MARX = 1e5+10;
//=============================================================
int n,ans,a[MARX]; 
int bit[40] , f[MARX];  //具体意义见上文
std::map <int,int> log_2;
//=============================================================
inline int read()
{
	int fl=1,w=0;char ch=getchar();
	while(!isdigit(ch) && ch!='-') ch=getchar();
	if(ch=='-') fl=-1;
	while(isdigit(ch)){w=w*10+ch-'0',ch=getchar();}
	return fl*w;
}
//=============================================================
signed main()
{
	for(int i=0,sum=1;i<=31;i++,sum<<=1) log_2[sum]=i; //预处理log函数 
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++)
	{
	  for(int j=a[i],low=lowbit(j);j;j-=low,low=lowbit(j)) //枚举二进制位更新f[i] 
	    f[i]=std::max(f[i],bit[log_2[low]]+1);
	  for(int j=a[i],low=lowbit(j);j;j-=low,low=lowbit(j)) //使用更新过的f[i]更新bit[k] 
	    bit[log_2[low]]=std::max(bit[log_2[low]],f[i]);	
	  ans=std::max(f[i],ans); //取得最大答案 
	}
	printf("%d",ans);
}

```

---

$updata\ on\ 2019.8.13$  
修复了暴力思路的 $bug$ ,  
并添加了代码

---

## 作者：jacklee10086 (赞：20)

（这道题不愧是绝世好题）我看了标签有位运算，于是想到了按位分解，但是之后的 dp 思路一时无法想出，于是我尝试用图论来解决这个问题，解决之后提交这个题解想为大家拓宽一下思路，方便像我这样的 dp 苦手。
# 题意简述
- 给定一个长度为 $n$ 的数列 $a_i$。
- 求 $a_i$ 的子序列 $b_i$ 的最长长度 $k$，满足 $b_i \& b_{i-1} \ne 0 $，其中 $2\leq i\leq k$。
- $1\leq n\leq 100000$，$a_i\leq 10^9$。

# 题目分析

### 使用的知识点
位运算，拓扑排序求最长路。
### 思路
#### 一.按位分解
与其他题解类似，就是先将每个数按二进制位分解，（之后我的第一想法是答案就为每个二进制位为 $1$ 的数量取最大值，但是这个做法假了，我意识到对于任意两段可行序列，只要它们有交集，就可以合并，而这个合并，又可以理解为是走另一条路径，于是我开始考虑图论）对每一位而言，相邻最近的两个该位为 $1$ 的序号由小序号往大序号连边。
#### 二.拓扑排序
显然，按照如上的建图方式，产生的是一张 DAG，于是我们就可以拓扑排序找最长路，其长度即为所求。

------------

* ps1：我的代码的拓扑排序是先建立了一个虚拟点然后连向入度为 $0$ 的点，其实没有必要这样，直接拓扑就行了，当时傻了一下。
* ps2：连边的时候可以判重一下提高效率。


------------
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=(1e5)+5;
vector<int>g[maxn];
int a[maxn];
int ans=0;
int d[maxn];
int in[maxn];
queue<int>q;
void topo(int s){//拓扑排序
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=0;i<g[u].size();i++){
			int v=g[u][i];
			if(d[v]<d[u]+1)d[v]=d[u]+1;
			in[v]--;
			if(!in[v])q.push(v);
			ans=max(ans,d[v]);
		}
	}
}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int k=0;k<=30;k++){
		int last=0; //虚拟点，实际上可以不用，正常拓扑就行 
		for(int i=1;i<=n;i++){
			if(a[i]&(1<<k)){//按位分解，判断a[i]第k-1位是否为1 
				in[i]++;
				g[last].push_back(i); //小序号向大序号连边 
				last=i;
			}
		}
	}
	topo(0);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Vocanda (赞：15)

## 题目
[题目链接](https://www.luogu.com.cn/problem/P4310)
## 分析
看到题的第一反应就被标签里的枚举给迷惑到了，然后快速打了一个暴力枚举，显然直接$90$分$TLE$了，然后开始想正解。

首先题目中的条件是含有位运算的，我们就可以从这里开始入手优化。

因为题目中给的条件是$a_i\&a_{i-1}\neq 0$，所以这就证明了只要两个数之间有一个二进制位上相同的$1$就可以让长度加一，那么我们就可以枚举每一个二进制位，找出他们与运算后是否为$0$，如果不是$0$就让长度加一，我们的一个状态转移方程就出来了：
$$Max = max(dp[c]+1,Max)$$
其中$dp[c]$是二进制第$c$位时最大的长度，当前状态下满足条件就加一，然后与最大长度$Max$取最大值。

需要注意的一个地方就是我们在状态转移后需要每次更新一下$dp[c]$，因为当前满足条件的最长长度已经找出来是$Max$了，所以所有当前满足条件的二进制位的最大长度都变为$1$，那么就又有一个转移：
$$dp[c]=Max$$
最后再统计一下所有更新后$Max$的最大值就好了。

## 代码
首先先放一下我的暴力$90points$代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+10;
int n,a[maxn],ans;
int dp[maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;++i){
		dp[i]=1;
		for(int j=1;j<i;++j){
			if((a[i]&a[j])!=0)dp[i]=max(dp[i],dp[j]+1);
		}
		ans=max(ans,dp[i]);
	}
	printf("%d",ans);
	return 0;
}
```
然后是正解：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 32;
int dp[maxn];
int Max,ans;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		int b;
		scanf("%d",&b);
		for(int c=0;c<=31;++c){//枚举每一个二进制位
			if((1<<c)&b)Max=max(Max,dp[c]+1);
		}
		for(int c=0;c<=31;++c){//更新满足条件的二进制位的最大值
			if((1<<c)&b)dp[c]=max(Max,dp[c]);
		}
		ans=max(ans,Max);//统计最大值答案
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：guodong (赞：11)

## [绝世好题](https://www.luogu.org/problemnew/show/P4310)

~~囍提最长代码,纪念一下~~

我写了个特别显然的乱搞AC了23333

思路（xmind）：
![oic](https://cdn.luogu.com.cn/upload/pic/59451.png)

时间复杂度$O(nlog(ai))$,不过为了方便我的代码是$n*32$的
```cpp

/*************************************************************************
    > File Name: 4310.cpp
    > Created Time: 2019年05月26日 星期日 09时48分55秒
 ************************************************************************/

#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<queue>
#include<vector>
using namespace std;
#define ri register int
#define mem(arr,v) memset(arr,v,sizeof arr)
inline int gi()
{
    register char tmp=getchar();int ans=0,flag=1;while(tmp<'0'||tmp>'9'){tmp=getchar();if(tmp=='-') break;}
    if(tmp=='-') flag=-1;
    while(tmp<='9'&&tmp>='0'){ans=ans*10+tmp-'0';tmp=getchar();}return ans*flag;
}
#define in(a) a=gi()
#define in2(a,b) in(a);in(b)
#define in3(a,b,c) in2(a,b);in(c);
#define in4(a,b,c,d) in3(a,b,c);in(d);
#define smax(a,b) a=max(a,b);
#define smin(a,b) a=min(a,b);
#define ri register int 
#define work(pos) for(ri i=head[pos];i;i=edge[i].nxt)
#define arr (edge[i].v)
// 以上是vim自动插入文件头233
#define N 400001
int n,bit[36][N],mp[N][36],dp[36][N];
inline int lowbit(int x){return x&-x;}
inline void add(int bin,int v)
{
    for(ri i=v;i<=n;i+=lowbit(i))
        smax(bit[bin][i],v);
}
inline int query(int bin,int v)
{
     int ans=0;
     while(v)
     {
          ans=max(ans,bit[bin][v]);
          v-=lowbit(v);
     }
     return ans;
}
int main()
{
    #ifndef ONLINE_JUDGE
    freopen("data.in","r",stdin);	
    freopen("wa.out","w",stdout);
    #endif
    int tmp,cnt=0;
    in(n);
    for(ri i=1;i<=n;i++)
    {
        cnt=0;
        in(tmp);
        while(tmp)//正序倒序没区别，而且倒序会更方便
        {
             mp[i][++cnt]=tmp%2;
             tmp>>=1;
        }
    }
    int out=0;
    for (register int i = 1; i <= n; ++i) 
    {
        ri ans=0;
        for (register int j = 1; j <= 32; ++j) 
             if(mp[i][j])
                 ans=max(ans,query(j,i));
        for (register int j = 1; j <= 32; ++j) 
        {
            if(mp[i][j]) 
            {
                 dp[j][i]=ans+1;
                 add(j,dp[j][i]);
            }
            else
                 dp[j][i]=1;
            smax(out,dp[j][i]);
        }
    }
    printf("%d\n",out);
    return 0;
}

```



---

## 作者：hzoi_liuchang (赞：11)

## 分析
第一次看这道题首先想到的就是时间复杂度为$\ n^{2}$的求最长上升子序列
``` cpp
    for(int i=1;i<=n;i++){
        f[i]=1;
        for(int j=1;j<i;j++){
            if((a[i]&a[j])!=0) f[i]=max(f[i],f[j]+1);
        }
        ans=max(ans,f[i]);
    }
```
判断时把条件改一下就好了

但是这一道题的数据范围达到了$10^{5}$，这样写会超时

所以我们考虑更优秀的算法，突破口就是位运算

题目中的操作是按位与，所以我们可以把一个数的每一个二进制位分别拆分进行计算

我们设$f[i]$为当前二进制位为$i$时满足要求的最长长度

我们用一个变量$k$记录当前位置的最大状态

要注意的是，最大状态要在所有为$1$的位中转移

比如下面这组数据

011

110

100

在转移到第二位的时候要取一个最大值

最后不要忘了用这个值去更新$f$值

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,a[maxn],ans;
int f[300];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;++i){
	    int now=1;
		for(int j=0;j<=30;j++){
		    if(a[i]&(1<<j)){
		        now=max(now,f[j]+1);
		    } 
		}
		for(int j=0;j<=30;j++){
		    if(a[i]&(1<<j)){
		        f[j]=max(f[j],now);
		    }
		}
       ans=max(ans,now);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Siyuan (赞：7)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io)

---

> 题目链接：[BZOJ 4300](https://www.lydsy.com/JudgeOnline/problem.php?id=4300)

给定一个长度为 $n$ 的数列 $a_i$，求 $a_i$ 的子序列 $b_i$ 的最长长度 $len$，满足 $b_i\ \texttt{AND}\ b_{i-1}\neq 0$（$2\leqslant i\leqslant len$）。

数据范围：$n\leqslant 10^5$，$a_i\leqslant 2\times 10^9$

------

## Solution

我们可以设计出一个不朴素的 $\texttt{DP}$ 状态 $f[i]$ 表示考虑前 $i$ 个数的最长长度，转移为 $f[i]=\max\{f[j]+1\}$（$a_i\ \texttt{AND}\ a_j\neq 0$）。

考虑优化，发现这个东西和 $\texttt{LIS}$ 非常类似。由于 $a\ \texttt{AND}\  b\neq 0$ 意味着一定有一位为 $1$，所以我们用 $f[i]$ 表示第 $i$ 位为 $1$ 的最长长度。每次读入一个 $x$，我们记 $s=\max\{f[i]\}+1$（$x$ 的第 $i$ 位为 $1$），然后用 $s$ 去更新 $f[i]$，最后的答案即为 $\max\{f[i]\}$。

**时间复杂度**：$O(n\log a_i)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int N=35;
int n,f[N];

int main() {
    scanf("%d",&n);
    for(int x;n--;) {
        scanf("%d",&x);
        int mx=1;
        for(int i=0;i<=30;++i) if(x&(1<<i)) mx=std::max(mx,f[i]+1);
        for(int i=0;i<=30;++i) if(x&(1<<i)) f[i]=std::max(f[i],mx);
    }
    int ans=0;
    for(int i=0;i<=30;++i) ans=std::max(ans,f[i]);
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：sdgzy (赞：5)

# Bzoj 4300: 绝世好题
贡献一发不一样的题解.
刚开始状态转移错了.
还是在吃饭的时候猛地想起来状态的缺失.          
然后A了???     
真奇怪.     
设状态$f[i][j]$表示前i位二进制为$j$的最大长度.     
当第i位的二进制$j$位出现了$1$时,长度+1.     
但是缺少了一步就是.     
只考虑了第$j$位,     
其实在所有为1的二进制中取max,才是当前位置的最大状态.     
看一下代码,好好领悟一下...     
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int maxN = 100000 + 7;

int f[maxN][50];
int a[maxN];
int ans;

int main() {
    int n,ans = 0;
    scanf("%d",&n);
    for(int i = 1;i <= n;++ i) 
        scanf("%d",&a[i]);
    for(int i = 1;i <= n;++ i) {
        int res = 0;
        for(int j = 0;j <= 32;++ j) {
            f[i][j] = f[i - 1][j];
            if(a[i] & (1 << j)) {
                f[i][j] ++;
                res = max(f[i][j],res);
            }
        }
        for(int j = 0;j <= 32;++ j) {
            f[i][j] = f[i - 1][j];
            if(a[i] & (1 << j)) {
                f[i][j] = res;
            }
        }
        ans = max(ans,res);
    }
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：ESTHER (赞：4)

 一道DP
 1.	首先 我们可以想到一种简单的80分算法 ： 设f[i]表示1~i中满足b[i]&b[i-1]!=0的个数    则转移方程为   **f[i]=max{f[j]}+1**(条件：j<i且b[i]&b[j]!=0)范围(i:1~n j:1~i-1)
   
 2. 那么，满分算法是什么呢：我们可以设f[i][j]表示第i个数的二进制表示的第j位是1，能够满足条件的最长长度。先举个栗子
 3.  a数组为：1,3,5
 	
    1 ->二进制 0001 f[0]=1 
    
 	3 ->二进制 0011 f[0]=2  f[1]=1 
    
    这样，因为第0位是2，而第1位是1,所以这两个数都应该更新为2，代表整个数3的第0位和第1位都可以接上数1了 所以f[0]=f[1]=2       
    
    5 ->二进制 0101 f[0]=3  f[2]=1
    f[0]=f[2]=3
    所以这样答案就是max{f[i]}--3
    
    时间复杂度为O(nlogn)完全可以通过全部数据
    
   另外位运算是加快本题加快速度的重点 
   x&(1<<i)!=0 表示x的第i位是1
   
   恩，就酱紫，大家听明白了吗 
```cpp
#include<cstdio>
#include<cstring>
#include<iostream> 
#include<algorithm>
using namespace std;
int f[35];//2^35足够满足要求
int main()
{
	long long x;
	int tmp=0,n,ans=0,i,j;
 	scanf("%d",&n);
 	for(j=1;j<=n;j++)
   	{
	    cin>>x;
	    tmp=0;
    	for(i=0;(1<<i)<=x;i++)
       		if(x&(1<<i))//用位运算取x的第i位
 	  			tmp=max(tmp,f[i]+1);
    	for(i=0;(1<<i)<=x;i++)
       		if(x&(1<<i))
	    		f[i]=tmp;
   	}
 	for(i=0;i<32;i++)
   		ans=max(ans,f[i]);
 	printf("%d\n",ans);
 	return 0;
}

```

---

## 作者：ShineEternal (赞：3)

[如有残缺请点击这里](https://blog.csdn.net/kkkksc03/article/details/102533589)

## description：
$给定一个长度为n的数列ai，求ai的子序列bi的最长长 度len，满足b_i$ $and$ $b_{i−1} != 0(2 ≤ i ≤ len)$

$n ≤ 10^5$

$a_i ≤ 10^9$

## solution:
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101315442946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tra2tzYzAz,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013154325829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tra2tzYzAz,size_16,color_FFFFFF,t_70)

## code:
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int dp[105];
int main()
{
	int n;
	scanf("%d",&n);
	int a;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		int k=1;
		for(int j=0;j<=30;j++)
		{
			if((1<<j)&a)
			{
				k=max(dp[j]+1,k);
			}
		}
		for(int j=0;j<=30;j++)
		{
			if((1<<j)&a)
			{
				dp[j]=max(dp[j],k);
			}
		}
		ans=max(ans,k);
	}
	printf("%d\n",ans);
	return 0;
	
} 
```

---

## 作者：由比滨丶雪乃 (赞：3)

# P4310  绝世好题

- [题目链接](https://www.luogu.org/problem/P4310)

- [位运算基础知识](https://www.baidu.com/s?wd=%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&ie=utf-8&tn=90562692_hao_pg)

- [更好的阅读体验](https://www.luogu.org/blog/Hikigaya/p4310-jue-shi-hao-ti-ti-xie)
- [我的博客qwq](https://www.luogu.org/blog/Hikigaya/)

## 1、暴力90分的做法

###### ~~可怜，弱小，又无助，不会卡常，只会暴力qwq~~

**暴力的做法很容易想到，定义状态 _fi_ 为以 _ai_ 结尾满足条件的子序列最长长度**

**那么很容易得到方程**

 ### _fi=max（f[i]，f[j]+1）_ 
 
 **1<=j<i&&a[i] and a[j]！=0**
 
 **复杂度为O（n^2）**
 
 CODE
 ```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>

using namespace std;

int n;
int ans;
int a[1000010];
int f[1000010];

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	    f[i]=1;//初始化
	}
	for(int i=2;i<=n;i++)
	   for(int j=1;j<i;j++)//如上文解释的qwq
	      {
	      	if(a[i]&a[j])
	      	f[i]=max(1+f[j],f[i]);
	      	ans=max(ans,f[i]);
		  }
	printf("%d\n",ans);
	return 0;
}
```


## 2、正解

**考虑到位运算的性质，当两个数在二进制的表示下时，有一位都为 1 时，就满足了题目所要求的条件**

**那我们就可以选择对于每一个数，找到其在二进制表示下为1的位数，做一个预处理**

**接下来是设计状态**

**设b[i]表示为在二进制的表示下第i位为1时题目所求子序列的最长长度**

**方程大致相同，需要注意每次循环进行维护**

时间复杂度  O（n log n），空间复杂度 O（n）

Code
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define maxn 100010
using namespace std;

int a[maxn],b[maxn];
int f[maxn];
int n;
int k;
int ans=-1;

inline int max(int a,int b)//自定义max函数，貌似会快一丢丢（雾）
{
	return a>b?a:b;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
    for(int i=1;i<=n;i++)
    {
    	int Maxn=-1;
    	for(int j=1;j<=32;j++)//枚举到2^32 就好了
    	{
    		if(a[i]&(1<<j))//判断第j位是否为1
    	     	Maxn=max(Maxn,b[j]+1);//如果是的话，进行每一位答案的维护
		}
		for(int j=1;j<=32;j++)
		{
			if(a[i]&(1<<j))
			   b[j]=Maxn;//维护
		} 
		ans=max(ans,Maxn);//记录qwq
	}
	printf("%d",ans);//AC
	return 0;
	
}
```



---

## 作者：swiftc (赞：3)

我们设now[x]为前一个数二进制位第x位为1时的最大值

因为只有两个数有一个二进制为同为1时他们才可以连接，所以我们扫描每一个数，如果它二进制为第i位为1，找出这样最大的now[i]设为MAX，然后把每一个now[i]都设为MAX+1（把这个数接到前面最长的子序列上，让后边继续接）

### CODE：

```cpp
#ifdef DEBUG
#include"stdc++.h"
#else
#include<bits/stdc++.h>
#endif
using namespace std;
int main(){
    int n,a[100001],now[41],ans=-1;
    memset(now, 0, sizeof(now));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++){
        int maxn=-1;
        for(int j=0;j<=40;j++){
        //10^9<2^40，所以扫描1~40位即可
            if(a[i]&(1<<j)){//可以连接
                maxn=max(maxn,now[j]+1);
            }
        }
        for(int j=0;j<=40;j++){
            if(a[i]&(1<<j)){
                now[j]=maxn;
                //把这个数接到最长的子序列上
            }
        }
        ans=max(ans,maxn);
        //更新答案
    }
    printf("%d\n",ans);
}

```



---

## 作者：LCuter (赞：2)

[可能更好的阅读体验](https://lcuter.gitee.io/2020/06/07/%E6%B4%9B%E8%B0%B7%20P4310%20%E9%A2%98%E8%A7%A3/#more)

## 洛谷 P4310 题解

##### $\text{Description}$

给定一个序列 $\{a\}_{i=1}^{n}$，求出其满足任意非首元素与之前驱元素的按位与非零的子序列的最大长度。

$n\le 10^5,a_i\le 10^9$.

##### $\text{Solution}$

这题和最长上升子序列挺像，首先考虑正常 DP：

设 $f(i)$ 表示以第 $i$ 个元素结尾的满足条件的子序列的最大长度，则有：
$$
f(i)=\max_{0\le j<i}\{f(j)[a_i\operatorname{and}a_j\neq 0]+1\}
$$
思考优化的方式，由于题目与位运算有关，我们可以从二进制的角度观察。假设当前准备计算 $f(i)$，我们自然而然地想到将 $a_i$ 写成二进制，我们发现它仅会被与其有至少一个二进制位都为 $1$ 的前面的数转移。

考虑记 $M(k)$ 表示当前考虑的前若干个数中 $2^k$ 这一二进制位上有 $1$ 的数的 $f$ 的最大值。若准备计算 $f(i)$，我们可以枚举它所有为 $1$ 的二进制位，然后用 $M(k)+1$ 更新。在更新结束后，我们再用 $f(i)$ 更新 $M(k)$ 即可。

##### $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
using namespace std;
inline void read(int& x){
	static char c;
	while(!isdigit(c=getchar()));x=c^48;
	while(isdigit(c=getchar()))x=(x*10)+(c^48);
}

int n;

int Mx[35],Ans,Tmp1,Tmp2;

inline void Work(){
	read(n);
	for(REG int i=1;i<=n;++i){
    	read(Tmp1);
    	for(REG int B=0;B<=29;++B)
        	if(Tmp1&(1<<B)) Tmp2=max(Tmp2,Mx[B]+1);
    	for(REG int B=0;B<=29;++B)
        	if(Tmp1&(1<<B)) Mx[B]=Tmp2;
    	Ans=max(Ans,Tmp2);    
    }
	printf("%d\n",Ans);
}

int main(){Work();}
```



---

## 作者：过往梦魇之殇 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P4310)

题目分析：

思路巧妙至极，~~确实是绝世好题！~~

令$dp[i]$表示以$a[i]$结尾的符合要求的序列的最长长度。

首先，朴素转移$dp[i]=max(dp[j])+1$，复杂度是$O(n^2)$的，显然不行。其中满足$a[i]\&a[j]!=0$ 

然后我们仔细观察条件$:"a[i]\&a[j]!=0"$

什么时候满足该条件呢？

易见只要存在任意一个数$k$满足$a[i]$和$a[j]$的第$k$位都是$1$，条件即成立。

所以，我们考虑再建一个数组$maxx[]$来记录满足$a[j]$的第$k$位是$1$的$dp[j]$的最大值（内层循环）

所以$dp$方程可转化为$dp[i]=max(maxx[k])+1$，满足$a[i]$的第$k$位是$1$

这样子，我们只需对每个$dp[i]$进行一次$log$ $a_i$的遍历即可。

总体复杂度大概为$O(nlog_n)$

接下来是代码：

```cpp
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<complex>
#include<climits>
#define re register
#define in inline
#define pi acos(-1.0)
#define inf 2147483640
#define cd complex<double>
using namespace std;
in int read()
{
    int sum=0,negative=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')negative=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*negative;
}
in void write(int X)
{
    if(X<0)putchar('-'),X=-X;
    if(X>=10)write(X/10);
    putchar(X%10+'0');
}
const int maxn=1e5+10;
int n,ans,a[maxn],dp[maxn],maxx[40];
int main()
{
	n=read();
	for(re int i=1;i<=n;++i){
		a[i]=read();
	}
	for(re int i=1;i<=n;++i){
		for(re int j=30;j>=0;--j){
			if((1<<j)&a[i]){
				if(maxx[j]+1>dp[i]){
					dp[i]=maxx[j]+1;
				}
			}
		}
		for(re int j=30;j>=0;--j){
			if((1<<j)&a[i]){
				if(dp[i]>maxx[j]){
					maxx[j]=dp[i];
				}
			}
		}
		if(ans<dp[i]){
			ans=dp[i];
		}
	}
	write(ans);
    return 0;
}
```
###### 制作不易，求资瓷

> Thanks For Watching!

---


# [yLOI2020] 泸沽寻梦

## 题目背景

> 我应是泸沽烟水里的过客，  
> 孑然弹铗，划天地开阖。  
> 邂逅过的，梦醒之余，  
> 却忘了该如何洒脱。 

——银临《泸沽寻梦》

## 题目描述

> 南有仙地，名曰摩梭，摩梭有湖，泸沽是也。

茶茶在泸沽湖中寻找自己的梦。氤氲雾气中，茶茶的 $n$ 个梦排成了一个序列。茶茶的所有梦境都是拉瓦的样子。为了区分这些拉瓦，茶茶规定从左到右第 $i$ 个的拉瓦的美颜值是一个非负整数 $a_i$。面对着这些梦，茶茶会进行 $m$ 次操作，每次操作会给定两个数字 $p,x$，然后将 $a_p$ 和 $a_{p+1}$ 都对 $x$ 做按位异或。每次操作完之后，茶茶都想知道，当前的梦序列中，有多少个子区间 $[l,r]$，满足 $l \le r$ 且区间的异或和为 $0$，请你回答茶茶的问题。

区间 $[l,r]$ 的异或和定义为 $a_l \otimes a_{l + 1} \otimes \dots a_{r - 1} \otimes a_r$。其中 $\otimes$ 代表二进制按位异或运算，即 C++ 语言的「^」运算符。两个区间不同当且仅当两区间左端点不同或两区间右端点不同或两区间左右端点均不同。

为了避免输出过大，你只需要输出四个整数，分别表示你所有回答的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。

## 说明/提示

### 样例 1 解释

- 第一次操作后，序列变为 ${2,1,3,4,5}$，有且仅有区间 $[1,3]$ 的异或和为 $0$，故本次询问的答案为 $1$。
- 第二次操作后，序列变为 ${2,2,0,4,5}$，区间 $[1,2]$、$[1,3]$、$[3,3]$ 的异或和为 $0$，故本次询问的答案为 $3$。
- 第三次操作后，序列变为 ${2,2,3,7,5}$，有且仅有区间 $[1,2]$ 的异或和为 $0$，故本次询问的答案为 $1$。所有答案的异或和为 $3$，有 $3$ 次回答的答案为奇数，所有答案中的最大值为 $3$，最小值为 $1$。

### 数据规模与约定

**本题采用多测试点捆绑测试**，共有 5 个子任务。

- 子任务 $1$（$10$ 分）：保证 $n,m \le 100$。
- 子任务 $2$（$10$ 分）：保证 $n,m \le 300$。
- 子任务 $3$（$20$ 分）：保证 $n,m \le 3000$。
- 子任务 $4$（$30$ 分）：保证 $n,m \le 10^5$。
- 子任务 $5$（$30$ 分）：无特殊限制。

对于前四个子任务，保证 $a_i,x \le n$；  
对于全部的测试点，保证 $1 \le n,m \le 10^6$，$0 \le a_i,x \le 10^9$，$1 \le p<n$。

### 提示

- 请注意，$a_i,x \leq Y$ 不能说明 $a_i \otimes x \leq Y$。
-  请注意大量数据读入对程序效率造成的影响。
- 本题的特殊输出方式只是为了避免输出过大造成程序超时，与本题解法无关。
- 请注意常数因子对程序效率造成的影响。
- 本题共有两个样例文件，请见附加文件中的 dream.zip。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
1 3
2 3
3 3```

### 输出

```
3
3
3
1```

# 题解

## 作者：hzoi_liuchang (赞：16)

## 分析
要求的是异或和等于 $0$ 的区间的个数

暴力枚举左右端点显然会 $T$ 飞

考虑将问题转化一下

设 $sum$ 数组为异或的前缀和

如果有 $a_l⊗a_{l+1}⊗…a_{r-1}⊗a_r=0$

那么就有 $sum[l-1]=sum[r]$

对于一个前缀和 $x$，如果一共有 $cnt$ 个前缀和和其相等

那么合法的方案数就是 $\frac{cnt(cnt+1)}{2}$

把前缀和扔进哈希表里，记录一下个数即可

考虑修改操作

如果把 $a[p]$ 和 $a[p+1]$ 都异或上 $x$

那么根据异或的性质 $x⊗x=0$

改变的只是 $sum[p]$，其它的都不变，相当于单点修改

在哈希表里随便改一下即可

时间复杂度 $O(n)$

目前是最优解
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define gc() (p1 == p2 ? (p2 = buf + fread(p1 = buf, 1, 1 << 20, stdin), p1 == p2 ? EOF : *p1++) : *p1++)
#define read() ({ register int x = 0; register char c = gc(); while(!isdigit(c)) c = gc(); while(isdigit(c)) x = x * 10 + (c & 15), c = gc(); x; })
char buf[1 << 20], *p1, *p2;
const int maxn=1e6+5;
const int mod=1e6+3;
int a[maxn],n,m;
long long ans1,ans2,ans3,ans4=0x3f3f3f3f3f3f3f3f,ans;
int sum[maxn],h[maxn],tot=1;
struct asd{
	int val,nxt,cnt;
}b[maxn*8];
long long js(int num){
	return 1LL*(num-1)*num/2;
}
void ad(int num,int val){
	rg int now=num%mod;
	for(rg int i=h[now];i!=-1;i=b[i].nxt){
		if(num==b[i].val){
			ans-=js(b[i].cnt);
			b[i].cnt+=val;
			ans+=js(b[i].cnt);
			return;
		}
	}
	b[tot].nxt=h[now];
	b[tot].val=num;
	b[tot].cnt=1;
	h[now]=tot++;
}
int main(){
	memset(h,-1,sizeof(h));
	n=read(),m=read();
	for(rg int i=1;i<=n;i++){
		a[i]=read();
	}
	ad(0,1);
	for(rg int i=1;i<=n;i++){
		sum[i]=sum[i-1]^a[i];
		ad(sum[i],1);
	}
	rg int aa,bb;
	for(rg int i=1;i<=m;i++){
		aa=read(),bb=read();
		ad(sum[aa],-1);
		sum[aa]^=bb;
		ad(sum[aa],1);
		ans1^=ans;
		if(ans&1) ans2++;
		ans3=max(ans,ans3);
		ans4=min(ans,ans4);
	}
	printf("%lld\n%lld\n%lld\n%lld\n",ans1,ans2,ans3,ans4);
	return 0;
}
```

---

## 作者：一扶苏一 (赞：7)

### C

#### Algorithm 1

依照题意模拟，时间复杂度 $O(qn^3)$，可以通过子任务 $1$，期望得分 $10$ 分。

#### Algorithm 2

优化算法 1 的枚举过程，求区间异或和可以和枚举右端点放在一起完成，时间复杂度 $O(qn^2)$，可以通过前两个子任务，期望得分 $20$ 分。

#### Algorithm 3

考虑这个修改方式明示我们求前缀异或和。因为异或的性质，这样的修改方式相当于对前缀异或和数组 $s_i$ 进行对 $s_p$ 的单点修改。原序列中一段异或和为 $0$ 的区间等价于前缀异或和序列上一对前缀异或和相等的端点。考虑每次查询时扫描整个前缀异或和序列，用桶记录每个数出现的次数，那么答案即为 $\sum\limits_{i} (b_i \times b_{i} - 1)$，其中 $b_i$ 表示 $i$ 出现的次数。可以通过前三个子任务，期望得分 $40$ 分。

#### Algorithm 4

这个部分分是给像我一样一眼看题想到树状数组套权值线段树（也就是传说中的带修主席树）的选手的。同时也是为了避免正解卡常而设置的。树状数组套权值线段树的时间复杂度为 $O(q \log^2 n)$，可以通过前四个子任务，期望得分 $70$ 分。

#### Algorithm 5

考虑优化算法三。注意到每次修改操作对 $b$ 数组都只会修改它的两个位置，而每个位置对答案的贡献是独立的，因此我们维护全局答案，假设我们可以直接维护所有的 $b_i$，那么我们只需要在修改时被修改的两个位置对答案的贡献重新计算即可。因为 $b$ 的下标值域是 $10^9$ 无法直接维护。有两个解决方法，首先可以直接用 `std::unordered_map`/hash 来 $O(1)$ 维护桶，时间复杂度为 $O(q + n)$，也可以离线把所有修改都跑一遍，求出所有可能出现的值，放在一起离散化。时间复杂度为 $O((n + q) \log n)$。都可以通过全部的测试点，期望得分 $100$ 分。

```cpp
#include <cstdio>
#include <algorithm>
#include <unordered_map> 

const int maxn = 10000007;

template <typename T>
inline void qr(T &x) {
  char ch = getchar();
  while (!isdigit(ch)) ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
}

int n, m, cnt;
long long ans, o, u, v, w = 114514191981000ll;
int a[maxn], s[maxn];
std::unordered_map<int, int> bk;

int gv(const int x);

int main() {
  qr(n); qr(m);
  for (int i = 1; i <= n; ++i) {
    qr(a[i]);
  }
  ++bk[0];
  for (int i = 1; i <= n; ++i) {
    ans += bk[s[i] = s[i - 1] ^ a[i]]++;
  }
  for (int i = 1, p, x; i <= m; ++i) {
    p = x = 0; qr(p); qr(x);
    ans -= --bk[s[p]];
    ans += bk[s[p] ^= x]++;
    o ^= ans;
    if (ans & 1) ++u;
    v = (v > ans) ? v : ans;
    w = (w < ans) ? w : ans;
  }
  printf("%lld\n%lld\n%lld\n%lld\n", o, u, v, w);
  return 0;
}
```

```cpp
#include <cstdio>
#include <algorithm>
#include <unordered_map> 

const int maxn = 10000007;

template <typename T>
inline void qr(T &x) {
  char ch = getchar();
  while (!isdigit(ch)) ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
}

int n, m, cnt;
long long ans, o, u, v, w = 114514191981000ll;
int a[maxn], s[maxn], p[maxn], x[maxn], bk[maxn];
std::unordered_map<int, int> t;

int gv(const int x);
void add(const int x);

int main() {
//  freopen("dream.in", "r", stdin);
//  freopen("dream.out", "w", stdout);
  qr(n); qr(m);
  add(0);
  for (int i = 1; i <= n; ++i) {
    qr(a[i]);
    add(s[i] = s[i - 1] ^ a[i]);
  }
  for (int i = 1; i <= m; ++i) {
    qr(p[i]); qr(x[i]);
    add(s[p[i]] ^= x[i]);
  }
  ++bk[1];
  for (int i = 1; i <= n; ++i) {
    ans += bk[gv(s[i] = s[i - 1] ^ a[i])]++;
  }
  for (int i = 1; i <= m; ++i) {
    ans -= --bk[gv(s[p[i]])];
    ans += bk[gv(s[p[i]] ^= x[i])]++;
    o ^= ans;
    if (ans & 1) ++u;
    v = std::max(v, ans);
    w = std::min(w, ans);
  }
  printf("%lld\n%lld\n%lld\n%lld\n", o, u, v, w);
  return 0;
}

inline void add(const int x) {
  if (t.count(x) == false) t[x] = ++cnt;
}

inline int gv(const int x) { return t[x]; }
```

这两份 std，第一份是直接用 `std::unordered_map` 做桶，第二份是先离线跑修改再离散化（当然，这里图省事直接用了 `std::unordered_map` 离散化，只是为了表述离线修改的做法。事实上应该使用 `std::unique` 和 `std::lower_bound` 正式离散化，否则看起来非常的多此一举）。

---

## 作者：AuCloud (赞：4)

## 声明：为了方便，这篇题解将用"^"符号代替"异或"

#### 由于公式里会把"^"理解为上角标，所以这篇题解涉及到"异或"的地方都没有用$行内公式$，见谅

思维神仙题……

首先明确异或的性质：

> x ^ x = 0

> x ^ 0 = x


根据这点性质，我们可以进行推广：

- 满足前缀性质：设前缀和数组pre[i]表示$[0,i]$的异或和，则有$[l,r]$区间内异或和=$pre[l-1]$ ^ $pre[r]$

这点很好证明：

对于pre[l - 1]= a[1] ^ a[2] ^ ...^ a[l-1] 
而对于pre[r] = a[1] ^ a[2] ^ ... ^ a[l-1] ^ a[l] ^ ... ^ a[r]

根据异或的性质可得：pre[l-1] ^ pre[r]=a[l]^a[l+1]^...^a[r]

即为$[l,r]$区间的异或和

明确这点就很好做了：题目要求一段区间内异或和为0，在pre数组上表现为pre[i]^pre[j]=0，(i!=j)。

又由于异或的性质，pre[i]^pre[j]=0时一定有pre[i]=pre[j]

所以这道题就转换为**带修改**的询问数组内有多少对数字相同

再看看它的修改：

> 每次操作会给定两个数字 p,x，然后将$a_p$,$a_{p+1}$都对 x 做按位异或

由正常的前缀和递推式得到:

> pre[p] = pre[p-1]^a[p]
> pre[p+1] = pre[p]^a[p+1]

不妨设更改后的前缀和数组为pre2

则有：

> pre2[p] = pre[p-1]^(a[p]^x)

> pre2[p+1]

> =pre2[p]^(a[p]^x)

> =pre[p-1]^(a[p]^x)^(a[p+1]^x)

> =pre[p-1]^a[p]^a[p+1]

> =pre[p+1]

由此可得：每次更改时仅仅相当于pre[p]^=x

所以开个数组维护当前数字在前缀和数组中出现多少次即可

在输入同时维护前缀和和初始ans（每次将ans加上当前位置之前前缀和数字出现的次数）（不需要像其他题解一样搞什么公式，加和就行）

修改时在ans的基础上减去修改造成的损失（-=其他位置当前修改前的数字出现次数）再加上修改带来的贡献（+=其他位置当前修改后的数字出现次数）即为当前答案，再按照题目要求统计答案即可

然后发现a[i] <= 1e9，数组存不下，借助`map<>`或者`unordered_map<>`就行。后者可能更快一点，但是本题开启O2优化，就无所谓了（

其他小细节：因为存在$[1,r]$的区间，所以要将pre[0]=0算作一个元素（即mp[0]初值设为1）

#### 记得开longlong 记得把最大值设置足够大 记得把O2优化选项勾上

就完事了……


## 代码
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
unordered_map<int, int>mp;
int pre[1000001];
inline int read()
{
	int x=0;char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x;
}
signed main()
{
	int n, m;
	cin >> n >> m;
	int ans = 0;
	mp[0] = 1;
	int ans1 = 0, ans2 = 0, ans3 = 0, ans4 = 0x7fffffffffffffff;
	for(int i = 1; i <= n; i++)
	{
		int x;
		x = read();
		pre[i] = pre[i - 1] ^ x;
		ans += mp[pre[i]];//更新初始答案
		mp[pre[i]]++;
	}
	for(int i = 1; i <= m; i++)
	{
		int p, x;
		p = read();
		x = read();
		mp[pre[p]]--;
		ans -= mp[pre[p]];//减去影响
		pre[p] ^= x;
		ans += mp[pre[p]];//加上贡献
		mp[pre[p]]++;
		
		ans1 ^= ans;//统计答案
		if(ans & 1) ans2++;
		ans3 = max(ans3, ans);
		ans4 = min(ans4, ans);
	}
	cout << ans1 << endl << ans2 << endl << ans3 << endl << ans4 << endl;
	return 0;
}

```

~~我在比赛的时候居然在想权值线段树，wtcl~~

---

## 作者：苹果蓝17 (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P7096)

[更~~不~~好的阅读体验](https://www.luogu.com.cn/blog/appleblue17/ti-xie-p7096-yloi2020-lu-gu-xun-meng)

第一次写题解写得稍微详细点

#### 题意简述

给定长度为 $n$ 的非负整数数列 $a_i$ 与 $m$ 次操作，每次操作给定 $p$ 和 $x$，将相邻两个数 $a_p$ 和 $a_{p+1}$ 按位异或上 $x$，要求在每次操作后求出异或和为 $0$ 的子区间个数。

#### 题目分析

为了方便这里记 $a[l...r]$ 的异或和为 $S(l,r)$ 。

首先，需要知道异或有结合律与交换律。

带修有些麻烦，先来考虑没有修改时如何计算答案。

最暴力的当然是枚举每个子区间并 $O(n)$ 判断，总共 $O(n^3)$，带修就是 $O(n^4)$，期望得分 $10 pts$。

 $S(1,l-1) \oplus S(l,r)=S(1,r)$

 $S(1,l-1) \oplus S(l,r) \oplus S(1,l-1)=S(1,r) \oplus S(1,l-1)$

$S(l,r)=S(1,r) \oplus S(1,l-1)$

用前缀和优化一下，判断就可以 $O(1)$ 了，总共 $O(n^2)$，带修 $O(n^3)$，期望得分 $20pts$。

由上面那个式子可以发现 $S(l,r)=0$ 当且仅当 $S(1,l-1)=S(1,r)$。

所以如果用 $cnt_k$ 表示所有 $S(1,i)$ 中值为 $k$ 的个数，那么答案就是

$ans= \sum\limits_i \frac{1}{2}cnt_i(cnt_i-1)$

考虑用 `map` 存，当然可以在统计 $cnt_i$ 时顺便更新答案

$\Delta ans=\frac{1}{2}[cnt_i(cnt_i+1)-cnt_i(cnt_i-1)]=cnt_i$

总共 $O(n)$，带修 $O(n^2)$，期望得分 $40pts$。

单次计算已经很优了，来考虑带修。

然后会发现每次修改只会改变 $S(1,p)$，因为对于后面的前缀异或和，每个都异或上了两次 $x$，也就是不变。

答案维护和上面一样。

然而由于 `map` 常数太大了，貌似要用 `unordered_map` 才能卡过去……

> 请注意，$a_i,x \leq Y$ 不能说明 $a_i \oplus x \leq Y$。

别忘了`long long`

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;

int n,m;
long long s[N];
long long ans;
long long ansxor,ansj,ansmax=0,ansmin=1e18;
unordered_map <long long,int> mp;

int main(){
	scanf("%d%d",&n,&m);
	mp[0]++;
	for(int i=1;i<=n;i++){
		int a;
		scanf("%d",&a);
		s[i]=s[i-1]^a;//前缀异或和 
		ans+=mp[s[i]],mp[s[i]]++;
	}
	
	for(int i=1;i<=m;i++){
		int p,x;
		scanf("%d%d",&p,&x);
		ans-=mp[s[p]]-1,mp[s[p]]--;
		ans+=mp[s[p]^x],mp[s[p]^x]++;
		s[p]^=x;//将s[p]变为s[p]^x，同时更新答案 
		
		ansxor^=ans;
		if(ans & 1ll) ansj++;
		ansmax=max(ansmax,ans);
		ansmin=min(ansmin,ans); 
	}
	printf("%lld\n%lld\n%lld\n%lld\n",ansxor,ansj,ansmax,ansmin);
}
```





---

## 作者：lovely_nst (赞：2)

# P7096 [yLOI2020] 泸沽寻梦

## 前言

### 前置知识

- 前缀和

- 异或的性质

### 定义
定义 $XOR(l,r)=a_l\oplus a_{l+1}\oplus\cdots a_{r-1}\oplus a_r$。

## 题意

给定 $a_{1\sim n}$，每次操作对 $a_p$ 和 $a_{p+1}$ 同时异或 $x$，并求有多少 $l$ 和 $r$ 满足 $XOR(l,r) =0$。

## 题目转化

### 询问

先看怎么求答案。设 $s_i=a_i$，那么 $XOR(l,r) =s_r\oplus s_{l-1}=0$。

根据异或的性质 $(A\oplus A=0)$，得到 $s_{l-1}=s_r$ 时会产生贡献。用 $cnt_i$ 记录 $i$ 在 $s_{0\sim n}$ 出现的个数（注意：因为 $l-1$ 可能等于 $0$ 所以 $s_0=0$ 也要计算在内），那么答案即为 $\sum \frac{cnt_i(cnt_i-1)}{2}$，也就是在 $cnt_i$ 个 $i$ 中选出两个并去重后的结果。



### 修改

每次修改后:

${s_p}'=s_{p-1}\oplus a_p\oplus x=s_p\oplus x\\{s_{p+1}}'={s_p}'\oplus a_{p+1}\oplus x=s_p\oplus a_{p+1}=s_{p+1}$

如上，$i<p$ 时 $s_i$ 并不会因为后面的修改而受影响，不需要改动；$i>p$ 时 $s_i$ 并不会因为前面的修改而受影响，原因是 ${s_{p+1}}'=s_{p+1}$，那么后面的 $s_i$ 也不用改变。

也就是说修改 $a_p$，$a_{p+1}$ 被改成了修改 $s_p$。那么剩下的就好做了，只需每次更新贡献即可，具体可以看代码。

## AC Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n , m , a[1000005];
unordered_map <int , int> cnt;
signed main ()
{
	ios::sync_with_stdio (0) , cin.tie (0) , cout.tie (0);
	cin >> n >> m;
	for (int i = 1;i <= n;i ++)
		cin >> a[i] , a[i] ^= a[i - 1] , cnt[a[i]] ++;
	int ans = 0 , maxn = 0 , minn = 1e18 , c = 0 , sum = 0;
	cnt[0] ++; // s[0]
	for (auto it : cnt)
		ans += it.second * (it.second - 1) >> 1;
	while (m --)
	{
		int p , x;
		cin >> p >> x;
		cnt[a[p]] --;
		ans -= cnt[a[p]];
		a[p] ^= x;
		ans += cnt[a[p]];
		cnt[a[p]] ++;
		maxn = max (maxn , ans);
		minn = min (minn , ans);
		c += (ans & 1);
		sum ^= ans;
	}
	cout << sum << '\n' << c << '\n' << maxn << '\n' << minn;
	return 0; 
} 
```

---

## 作者：SerokSSR (赞：2)

~~本来很喜欢古风的，做完这道题就不喜欢了~~

最后代码写出来非常非常短，关键在于怎么想到做法。

先从不带修改的想起，怎样找异或和为 0 的区间数量

异或前缀和的性质应该都清楚 $s_{1,r} \oplus s_{1,l-1} = s_{l,r}$

考虑对于每个位置 $i$，去找 $i$ 之前有多少个位置 $j$ 满足 $s_{1,i}=s_{1,j}$，则 $(j,i]$ 就是一个合法区间，枚举是 $O(n^2)$ 的

到这里应该都能想到

接下来考虑如何优化。~~这个只能硬想了~~我们开一个值域桶，按 $i$ 从小到大循环的顺序记下来。显然每次插入 $s_i$ 时统计答案即可，直接降到 $O(n)$

最后考虑修改。这里又是异或的性质，$a \oplus x \oplus x = a$，所以每次修改相邻的两个位置，对应到前缀和上，**只有 $s_p$ 一个位置会改变**

一有思路后面就很简单了，单点修改直接改桶 桶的值域是 $2^{\log 1e9}$ 的开不下，`unordered_map` 或者离线离散化一下

```cpp
#include <bits/stdc++.h>
#include <tr1/unordered_map>
using namespace std;
using namespace tr1;
typedef long long ll;
const int N = 1000010;
int n, m; ll a[N];
unordered_map<ll, ll> v;
int main() {
	scanf("%d%d", &n, &m);
	ll ans = 0;
	v[0]++;
	for(int i=1; i<=n; ++i) {
		scanf("%lld", a+i);
		a[i] ^= a[i-1];
		ans += v[a[i]];
		v[a[i]]++;
	}
	ll sum = 0;
	ll num = 0, vmax = 0, vmin = LLONG_MAX;
	for(int i=1; i<=m; ++i) {
		int p; ll x; scanf("%d%lld", &p, &x);
		v[a[p]]--; ans -= v[a[p]];
		a[p]^=x; ans += v[a[p]]; v[a[p]]++;
		sum ^= ans;
		if(ans%2) ++num;
		vmax = max(vmax, ans);
		vmin = min(vmin, ans);
	}
	printf("%lld\n%lld\n%lld\n%lld", sum, num, vmax, vmin);
	return 0;
}
```

---

## 作者：WisNourx_ (赞：1)

## 题目分析
本题的关键在于如何快速求出异或和为 0 的区间个数。根据题意，我们可以得到如下推理：

1.每次修改只会影响一个位置的前缀异或和。

原因：
$$s_p = s_{p-1} \oplus a_p$$
$$s_{p+1} = s_p \oplus a_{p+1} = s_{p-1} \oplus a_p \oplus a_{p+1}$$
$$s_p' = s_{p-1} \oplus a_p \oplus x$$
$$s_{p+1}' = s_p' \oplus a_{p+1} \oplus x = s_{p-1} \oplus a_p \oplus x \oplus a_{p+1} \oplus x = s_{p-1} \oplus a_p \oplus a_{p+1}$$
$s_{p-1}$，$a_p$ 和 $a_{p+1}$ 都为定值，故一次修改只影响一个位置的前缀异或和。

2.如果有 $s_i = s_j$ 且 $i \leq j$，则 $[i+1,j]$ 为满足异或和为 0 的一个区间。 

原因：

如果 $s_i = s_j$，则 $s_i \oplus s_j = 0$。

因为 $s_i = a_1 \oplus a_2 \oplus \cdots \oplus a_i$，$s_j = a_1 \oplus a_2 \oplus \cdots \oplus a_i \oplus a_{i+1} \oplus \cdots \oplus a_j$，如果 $s_i \oplus s_j =0$，说明 $a_{i+1} \oplus a_{i+2} \oplus \cdots \oplus a_j = 0$。

3.异或和为 0 的区间个数为 $\sum_i \frac{cnt_i(cnt_i-1)}{2}$，其中 $cnt_i$ 表示前缀异或和为 $i$ 的区间个数。

原因：

结合推理 2 可知，当 $s_i=s_j$ 时，$[i+1,j]$ 为满足条件的一个区间。

尝试推广到三个数相等的情况：当 $s_i=s_j=s_k$ 时，由于三者值都相等，结合推理 2 得 $[i+1, j]$ 和 $[j+1, k]$ 都为满足条件的区间，进而得 $[i+1, k]$ 也为满足条件的区间。

以此类推，多个数时满足条件的区间个数为 $\sum_i \frac{cnt_i(cnt_i-1)}{2}$。

------------

综上，我们不难得出一个求法：计算序列 $a$ 的异或前缀和， 记录异或前缀和为 $i$ 的区间个数，在每次修改时只修改 $s_p$，$\mathcal O(1)$ 地计算贡献，统计答案。

更多细节详情参考代码。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<unordered_map>
using namespace std;

char buf[1<<20], *p1=buf, *p2=buf;
#define getchar() (p1==p2&&(p2=buf+fread(p1=buf, 1, 1<<20, stdin), p1==p2)?EOF:*p1++)
template <typename T>
void read(T &x)
{
    x=0;int f=1;char c=getchar();
    while (!isdigit(c)) f=(c=='-')?-1:1, c=getchar();
    while (isdigit(c)) x=(x<<1)+(x<<3)+c-'0', c=getchar();
    x*=f;
}

typedef long long LL;
const int N=1e6+10;
int n, m;LL s[N];
LL ans, sum, ji, maxx=-1e12, minn=1e12;
unordered_map<LL, int> num;

int main()
{
    read(n), read(m);
    num[0]++;
    for (int i=1, x;i<=n;i++) 
    {
        read(x);
        s[i]=s[i-1]^x;
        ans+=num[s[i]]++;
    }
    for (int i=1;i<=m;i++)
    {
        int p;LL x;
        read(p), read(x);
        ans-=--num[s[p]];
        s[p]^=x;
        ans+=num[s[p]]++;
        sum^=ans;if (ans&1) ji++;
        maxx=max(maxx, ans);
        minn=min(minn, ans); 
     }
     printf("%lld\n%lld\n%lld\n%lld", sum, ji, maxx, minn);
     return 0;
}
```


---

## 作者：苏联小渣 (赞：1)

位运算好题。

- ### 前置知识：

异或的运算法则：按位运算，每一位相同为 $0$ 不同为 $1$。

异或的常用性质：$x\oplus x=0$。

---

首先我们分析一下区间 $[l,r]$ 异或和为 $0$ 的充要条件是什么：统计一个**前缀异或和**，$s_i$ 表示 $a_1 \oplus a_2 \oplus ... \oplus a_i$，则 $a_l \oplus a_{l+1} \oplus ... \oplus a_r=(a_1 \oplus a_2 \oplus ... \oplus a_{l-1}) \oplus (a_1 \oplus a_2 \oplus ... \oplus a_{l-1}) \oplus a_l \oplus a_{l+1} \oplus ... \oplus a_r=(a_1 \oplus a_2 \oplus ... \oplus a_{l-1}) \oplus (a_1 \oplus a_2 \oplus ... \oplus a_{l-1} \oplus a_l \oplus... \oplus a_r)=s_{l-1} \oplus s_r$。其为 $0$ 当且仅当 $s_{l-1}=s_r$。

接着我们再来分析一下题目描述的操作对前缀异或和的影响。

- $a_p^{'} = a_p \oplus x:s_p^{'} = s_p \oplus x$。

- $a_{p+1}^{'}=a_{p+1} \oplus x:s_{p+1}^{'}=s_p^{'} \oplus a_{p+1}^{'}=s_p \oplus x \oplus a_{p+1} \oplus x=s_{p} \oplus a_{p+1} = s_{p+1}$

也就是说，它对 $s_{p+1}$ **没有影响**。同样的，对 $s_{p+2}$ 也没有影响。

那么这题就很简单了：根据上文所述的充要条件，我们只要用一个桶统计出 $s_i$ 的出现次数，然后每次询问，减去该前缀异或和的贡献，单点修改，加上改完后的贡献，即可。

还有一个问题，就是该用什么桶。我们尽量让复杂度线性，那显然不能离散化，然而用 `map` 也是带个 $\log$ 的，不卡常开 O2 也超时了；注意可以用 STL 中的 `unordered_map`，用法和 `map` 类似，只不过用哈希实现故询问插入等复杂度为 $O(1)$。总时间复杂度 $O(n+m)$，可以通过。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, ans, p, x, c, d, e, f=1e18, a[1000010], s[1000010];
unordered_map <int, int> mp;
signed main(){
	scanf ("%lld%lld", &n, &m);
	mp[0] ++;//注意s[0]=0 
	for (int i=1; i<=n; i++){
		scanf ("%lld", &a[i]);
		s[i] = s[i-1] ^ a[i];
		ans += mp[s[i]];//它的贡献（配对数目） 
		mp[s[i]] ++;
	}
	for (int i=1; i<=m; i++){
		scanf ("%lld%lld", &p, &x);
		mp[s[p]] --;
		ans -= mp[s[p]];//它和其他的都配对不了了，减去贡献 
		s[p] ^= x;//单点修改 
		ans += mp[s[p]];//加上新的贡献，和其他一一配对 
		mp[s[p]] ++;
		c ^= ans;
		d += (ans & 1);
		e = max(e, ans);
		f = min(f, ans);//题目所要求的输出操作 
	}
	printf ("%lld\n%lld\n%lld\n%lld\n", c, d, e, f);
	return 0;
}
```

---

## 作者：试试事实上吗 (赞：1)

场外选手来水波题解。

### Part.1

先考虑询问怎么做。

首先我们考虑异或有一个很好的性质，可**差分**性。

考虑对序列做一个前缀异或和，一段区间$[l,r]$的异或和为$0$,实际上就是$sum[r]\oplus sum[l-1]=0$。所以现在我们只用查询序列中有几个相等的数对，这个就可以随便做了。

### Part.2

考虑修改操作很有特点，每次修改的数都是相邻的两个数，对前缀和的影响是$sum[p]$变为了$sum[p]\oplus x$，$sum[p+1...n]$变为了$sum[p+1...n]\oplus x\oplus x=sum[p+1...n]$，实际上**发生改变**的前缀就只有$sum[p]$！

所以问题就变得很简单了，我们只需要先扫一遍统计一下开始的答案，每次先删除原来$sum[p]$的贡献，再加入修改后的$sum[p]$就可以了。

随便拿个值域数据结构做就是了，我写了个$01\text{trie}$，当然拿动态开点值域线段树或平衡树，$\text{map}$之类的都可以啦。

答案记得开$\text{long long}$。

代码：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;
const int maxn=1e6+5,lim=29;

int tr[maxn*lim][2],siz[maxn*lim],sum[maxn],cnt=1,n,m,cntx;
ll totans,mx,mi;

template<typename T>
inline void read(T &x)
{
    int f=1;char c;
    while(!isdigit(c=getchar())) if(c=='-') f=-1;
    x=c^48;
    while(isdigit(c=getchar())) x=x*10+(c^48);
    x*=f;
}

void insert(int x,int f=1)
{
    int u=1;
    for(int i=lim;~i;--i)
    {
        int c=x>>i&1;
        if(!tr[u][c]) tr[u][c]=++cnt;
        u=tr[u][c];siz[u]+=f;
    }
}

int query(int x)
{
    int u=1;
    for(int i=lim;~i;--i)
    {
        int c=x>>i&1;
        u=tr[u][c];
        if(!u) return 0;
    }
    return siz[u];
}

int main()
{
    int p,x;
    ll ans=0;
    read(n);read(m);
    for(int i=1;i<=n;++i)
        read(sum[i]),sum[i]^=sum[i-1];
    for(int i=0;i<=n;++i)
        ans+=query(sum[i]),insert(sum[i]);
    mx=0;mi=1e18;
    while(m--)
    {
        read(p);read(x);
        insert(sum[p],-1);
        ans-=query(sum[p]);
        sum[p]^=x;
        ans+=query(sum[p]);
        insert(sum[p]);
        totans^=ans;cntx+=(ans&1);
        mx=max(mx,ans);mi=min(mi,ans);
    }
    printf("%lld\n%d\n%lld\n%lld\n",totans,cntx,mx,mi);
    return 0,QAQ;
}
```



---

## 作者：littleKtian (赞：1)

既然和区间异或和有关，那么优先考虑前缀异或和。

记 $b_i$ 为序列前 $i$ 个数的异或和，特别的，$b_0=0$。

那么修改操作等价于对 $b_p$ 异或上 $x$，每次询问的结果为 $\sum\limits_{0\leq i<j\leq n}\left[b_i=b_j\right]$。

设 $c_t$ 表示 $b_i=t$ 的 $i$ 的个数（$0\leq i\leq n$），易得 $\sum\limits_{0\leq i<j\leq n}\left[b_i=b_j\right]=\sum\dbinom{2}{c_t}$，也就是说我们只需要维护 $c_t$ 即可。

容易想到用桶来解决，由于值域在 $2^{30}$ 内，所以考虑离线+离散化。

复杂度 $O(n\log n)$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int a[1000005],b[1000005],p[1000005],x[1000005],ls[2000005],lp[1000005],t[2000005];ll ans;
int n,m;ll pr[4];
int dr()
{
	int xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=xx*10+ch-'0',ch=getchar();
	return xx;
}
int fi(int x)
{
	int l=0,r=n+m+1,mid;
	while(l+1<r)
	{
		mid=(l+r)>>1;
		if(ls[mid]<x)l=mid;
		else r=mid;
	}
	return r;
}
int main()
{
	n=dr(),m=dr();
	for(int i=1;i<=n;i++)ls[i]=b[i]=a[i]=a[i-1]^dr();
	for(int i=1;i<=m;i++)
	{
		p[i]=dr(),x[i]=dr();
		ls[n+i]=(b[p[i]]^=x[i]);
	}
	ls[n+m+1]=0,sort(ls+1,ls+n+m+2);
	for(int i=0;i<=n;i++)lp[i]=fi(a[i]),ans+=t[lp[i]],++t[lp[i]];
	for(int i=1;i<=m;i++)
	{
		int pp=fi(a[p[i]]^x[i]);
		--t[lp[p[i]]],ans-=t[lp[p[i]]];
		a[p[i]]^=x[i],lp[p[i]]=pp,ans+=t[pp],++t[pp];
		pr[0]^=ans,pr[1]+=(ans&1);
		if(i==1)pr[2]=pr[3]=ans;
		else pr[2]=max(pr[2],ans),pr[3]=min(pr[3],ans);
	}
	printf("%lld\n%lld\n%lld\n%lld",pr[0],pr[1],pr[2],pr[3]);
}
```


---

## 作者：Lian_zy (赞：0)

## 题解：P7096 [yLOI2020] 泸沽寻梦
异或具有这样的性质：一个数异或他自己是 $0$。

而修改操作又是对相邻的两个数异或同一个数，这有点像差分，然后差分肯定要在一个前缀和数组上进行啦。

$ax_i$ 表示前 $i$ 个数字的异或和，则有区间异或和为 $0$ 就是存在 $l,r$ 使得 $ax_{l-1}=ax_r$。

所以答案就只和相等的数字有关系。

如果序列中有 $A$ 个值相等的值，那他们两两对答案产生一次贡献，于是答案加上 $\frac{A(A-1)}{2}$。

然后对于一次操作，显然对 $ax$ 的影响就是给 $ax_p$ 异或上 $x$。

那么按照值域做下标，开一个 map，然后第一次遍历 map 统计答案，随后每一次对 $ax$ 进行单点修改，这点数组就可以办到，随后给原来 $ax$ 所在值域的值减一，给新的值域加一，同时更新答案就好了。

数据比较强，map 会超时，记得开 unordered_map。
## code

``` cpp
#include<bits/stdc++.h>
#define N 1000005 
#define ll long long
#define pr pair<ll,ll>
using namespace std;

ll mx,mn,sum,ans;
int n,m,p,x,cnt,a[N];
unordered_map<int,ll>mp;
ll queryans(int x){
	return 1ll*(x-1)*x/2;
}
int main(){
	scanf("%d%d",&n,&m);
	mp[0]=1;
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		a[i]^=a[i-1];
		mp[a[i]]++;
	}
	for(auto it:mp)ans+=queryans(it.second);
	mn=1e18;
	while(m--){
		scanf("%d%d",&p,&x);
		ans-=queryans(mp[a[p]]);
		ans+=queryans(mp[a[p]]-1);
		mp[a[p]]--;
		a[p]^=x;
		ans-=queryans(mp[a[p]]);
		ans+=queryans(mp[a[p]]+1);
		mp[a[p]]++;
		sum^=ans;
		cnt+=ans&1;
		mx=max(ans,mx);
		mn=min(ans,mn);
	}
	printf("%lld\n%d\n%lld\n%lld\n",sum,cnt,mx,mn);
	return 0;
}
```

---

## 作者：LEE114514 (赞：0)

## 思路

设 $S_n=\bigoplus_{i=1}^{n} a_i$。把操作放在前缀异或数组 $S$ 上看，发现相当于一个单点异或。

根据异或的性质推导 $\bigoplus_{i=l}^ra_i = 0 \Leftrightarrow S_r \oplus S_{l-1} = 0 \Leftrightarrow S_r = S_{l-1}$。

所以我们只要记录每个 $S_i$ 值出现过多少次就可以维护出答案，具体看代码。注意，当一个数都没有时，异或和为 $0$，所以要先把 $0$ 的出现次数加 $1$。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y;
const int maxn=1e6+5;
int a[maxn];
unordered_map<int,int> mp;
int ans,ans1,ans2,ans3,ans4=LONG_LONG_MAX;
signed main(){
	scanf("%lld%lld",&n,&m);
	mp[0]=1;//重要
	for(int i=1;i<=n;++i){
		scanf("%lld",a+i),a[i]^=a[i-1];
		ans+=mp[a[i]];
		++mp[a[i]];
	}
	for(int i=1;i<=m;++i){
		scanf("%lld%lld",&x,&y);
		--mp[a[x]];//先自减，防止和自己产生贡献
		ans-=mp[a[x]];
		a[x]^=y;
		ans+=mp[a[x]];
		++mp[a[x]];//后自加，防止和自己产生贡献

		ans1^=ans;
		ans2+=(ans&1);
		ans3=max(ans3,ans);
		ans4=min(ans,ans4);
	}
	printf("%lld\n%lld\n%lld\n%lld",ans1,ans2,ans3,ans4);
}
```

---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7096)

这题我们要求区间个数，暴力肯定是会超时的，因此可以考虑前缀和加哈希表的一个做法。

设 $sum$ 为前缀异或和，则当 $a_l\otimes a_{l+1}\otimes a_{l+2}\otimes...\otimes a_{r-1}\otimes a_{r}=0$ 时有 $sum_{l-1}=sum_{r}$

如果对于 $sum_x$ 有 $k$ 个前缀和与它相等，方案数就有 $\tfrac{k(k+1)}{2}$ 个。

接下来在哈希表里统计 $sum$ 的个数，修改同理。

**代码：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
struct node{
	int val,next,k;
}qwq[N<<3];
int n,m,a[N],sum[N],head[N],tot,ans1,ans2,ans3,ans4=0x3f3f3f3f3f3f3f,res;
inline int num(int x){return (x-1)*x>>1;}
inline void add(int x,int y){
	qwq[++tot]=(node){y,head[x],1};
	head[x]=tot;
} 
void work(int x,int val){
	int q=x%1000003;
	for(int i=head[q];i;i=qwq[i].next)
		if(x==qwq[i].val){
			res-=num(qwq[i].k);
			qwq[i].k+=val;
			res+=num(qwq[i].k);
			return;
		}
	add(q,x);
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;++i)scanf("%lld",&a[i]);
	work(0,1);
	for(int i=1;i<=n;++i)sum[i]=sum[i-1]^a[i],work(sum[i],1);
	for(int i=1,p,x;i<=m;++i){
		scanf("%lld%lld",&p,&x);
		work(sum[p],-1);
		sum[p]^=x;
		work(sum[p],1);
		ans1^=res;
		if(res&1)ans2++;
		ans3=max(ans3,res);
		ans4=min(ans4,res);
	}
	printf("%lld\n%lld\n%lld\n%lld",ans1,ans2,ans3,ans4);
	return 0;
}
```
最优解，时间复杂度为 $O(n)$ 。

---

## 作者：E1_de5truct0r (赞：0)

位运算简单题（？

## 思路

显然我们如果一个区间 $[l,r]$ 异或和为 $0$，说明了这个序列的前缀异或数组 $p$ 中，$p_{l-1}=p_r$。

我们不妨在求异或值的时候，把值放进哈希表的同时统计答案。显然如果一个值有 $m$ 个，则有 $\dfrac{m(m-1)}{2}$ 个区间的异或和为 $0$。

于是先 $O(n)$ 用哈希表处理出来最开始的贡献。

然后考虑怎么带修呢？发现如果相邻两个数都异或上 $x$，由 $x \oplus x=0$ 得到，其实只有第一个数的 $p$ 是真正改变了的，其他的都不会发生变化。

所以直接在哈希表上减去原来的贡献，再加上新的贡献即可。

总复杂度 $O(n+q)$。

## 代码

```cpp
#include <bits/stdc++.h>

// 省略了缺省源。

using namespace std;

#define int long long 

const int MAXN=1000005;
int a[MAXN],pre[MAXN];

unordered_map<int,int> h; // 哈希表 

signed main(){
	int n,q,cur=0,ans=0; read(n,q);
	for(int i=1;i<=n;i++) read(a[i]);
	
	h[0]=1; // 别忘了还有第 0 项 
	for(int i=1;i<=n;i++) pre[i]=pre[i-1]^a[i],ans+=h[pre[i]]++; // 求一个前缀异或，同时顺便算个贡献 
	
	int x1=0,x2=0,x3=0,x4=1e18;
	while(q--){
		int p,x; read(p,x);
		ans-=(--h[pre[p]]); // 减去原来的贡献 
		pre[p]^=x; // 异或 
		ans+=(h[pre[p]]++); // 加上新的贡献 
		
		x1^=ans; x2+=(ans&1); // 按照要求算四个值 
		x3=qmax(x3,ans),x4=qmin(x4,ans);
	} 
	write(x1,x2,x3,x4);
	return flush(),0;
}

```

---


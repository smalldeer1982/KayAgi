# 「EZEC-7」维护序列

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/lo9tuyl9.png)](https://www.luogu.com.cn/paste/tdqr0sto)

可怜的 dead_X 收不了歌，于是他出了个水题并给参赛者送了 $100$ 分。

2022 Update: 已经收了，很水。

## 题目描述

你需要维护一个序列。

这个序列开始时有 $2^n$ 个数，下标从 $0$ 开始。第 $i$ 个数初始值为 $i$，需要支持以下三种操作：

* 定义 $a$ 为所有下标为偶数的数组成的子序列，$b$ 为所有下标为奇数的数组成的子序列，将 $a,b$ 连接，构成新的序列。
* 定义 $a$ 为所有下标为奇数的数组成的子序列，$b$ 为所有下标为偶数的数组成的子序列，将 $a,b$ 连接，构成新的序列。
* 查询下标为 $x$ 的数。

总共将进行 $m$ 次操作。

## 说明/提示

**【样例解释】**

所有操作前后的序列从左至右的数如下：
$$\{0,1,2,3\}$$
下标为 $0$ 的数为 $0$。
$$\{0,2\},\{1,3\}$$
$$\{0,2,1,3\}$$
下标为 $1$ 的数为 $2$。
$$\{2,3\},\{0,1\}$$
$$\{2,3,0,1\}$$
下标为 $2$ 的数为 $0$。
$$\{2,0\},\{3,1\}$$
$$\{2,0,3,1\}$$
下标为 $3$ 的数为 $1$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（10 points）：不存在 $op=1$ 的操作。
- Subtask 2（10 points）：$n\leq 10，m\leq 10^3$。
- Subtask 3（20 points）：$n\leq 10$。
- Subtask 4（20 points）：$m\leq 10^3$。
- Subtask 5（20 points）：对于 $op=1$ 的操作，$x=0$。
- Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 32$，$1\leq m\leq 10^6$。

若 $op=1$，$x\in\{0,1\}$，若 $op=2$，$0\leq x<2^n$。

## 样例 #1

### 输入

```
2 7
2 0
1 0
2 1
1 1
2 2
1 0
2 3```

### 输出

```
0
2
0
1```

# 题解

## 作者：0x3F (赞：20)

最开始时由于某些原因这题是第一题。

我做了半个小时才做出来，心想第一题都这么难，第二题肯定做不出来了。

结果只花了 $5$ 分钟就做出了 “第二题”。

进入正题：

先考虑 $1$ 操作。

以长度为 $2^3 = 8$ 的序列为例。

初始序列：

| 十进制 | 二进制 |
| :----------: | :----------: |
| $0$ | $000$ |
| $1$ | $001$ |
| $2$ | $010$ |
| $3$ | $011$ |
| $4$ | $100$ |
| $5$ | $101$ |
| $6$ | $110$ |
| $7$ | $111$ |

操作后：

| 十进制 | 二进制 |
| :----------: | :----------: |
| $0$ | $000$ |
| $2$ | $010$ |
| $4$ | $100$ |
| $6$ | $110$ |
| $1$ | $001$ |
| $3$ | $011$ |
| $5$ | $101$ |
| $7$ | $111$ |

再次操作：

| 十进制 | 二进制 |
| :----------: | :----------: |
| $0$ | $000$ |
| $4$ | $100$ |
| $1$ | $001$ |
| $5$ | $101$ |
| $2$ | $010$ |
| $6$ | $110$ |
| $3$ | $011$ |
| $7$ | $111$ |

观察它们的二进制有什么规律？

我们发现一次操作相当于将二进制**首位移到末位**，其他位**向左移一格**。

也就是说，将二进制的各位**按顺时针连成一个环**，并将该环**逆时针旋转一格**。

开一个变量记一下**旋转的次数**即可。

如果旋转了**整整一圈**，一定记得要**归零**！！！

再来看一下 $2$ 操作：
| $1$ 操作 | 二进制 | $2$ 操作 | 二进制 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $0$ | $000$ | $1$ | $001$ |
| $2$ | $010$ | $3$ | $011$ |
| $4$ | $100$ | $5$ | $101$ |
| $6$ | $110$ | $7$ | $111$ |
| $1$ | $001$ | $0$ | $000$ |
| $3$ | $011$ | $2$ | $010$ |
| $5$ | $101$ | $4$ | $100$ |
| $7$ | $111$ | $6$ | $110$ |

不就是 $\operatorname{xor}$ 一下 $1$ 吗？

另开一个变量记一下**要 $\bold{xor}$ 的数**即可。

用位运算，$\Theta(m)$，比大伙们的 $\Theta(nm)$ 快多了。

还有：

**`unsigned`** `int`

因为：

$$x \in [0, 2^{32})$$

而 `int` 的表示范围为

$$[-2^{31}, 2^{31})$$

~~你用 `long long` 没人拦着你~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, o;
unsigned x, y;

inline unsigned read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}

inline void write(unsigned x)
{
    if(x>9) write(x/10);
    putchar(x%10+48);
}

int cnt;
int main() {
	n = read();
	m = read();
	while (m--) {
		o = read();
		x = read();
		if (o == 1) {
			if (x) {
				y = y ^ (1<<cnt);
			}
			cnt++;
			if (cnt == n) cnt = 0;
		} else {
			if (cnt) write(((x>>(n-cnt))|((x&((1<<(n-cnt))-1))<<cnt))^y);
			else write(x^y);
			putchar(10);
		}
	}
	return 0;
}
```


---

## 作者：dead_X (赞：14)

## Subtask 1
对于每个询问输出 $x$ 即可。
## Subtask 2
暴力执行操作维护序列即可。
## Part 1
考虑一个数所在的**下标**的变化，我们以第一种操作举例。

假设数 $x$ 当前下标为 $y$。

如果 $y$ 是偶数，它就会被分在第一个子序列里面，而此时它前面数的数量就变成了 $\frac{y}{2}$。

如果 $y$ 是奇数，它就会被分在第二个子序列里面，而此时它前面数的数量就变成了 $2^{n-1}+\frac{y}{2}$ 了。

而第二种操作中，我们只要把奇数和偶数互换即可。
## Part 2
将这个数写成二进制，我们发现在第一个操作中，我们就是将**最后一位**挪到了**第一位**，第二个操作则是将**最后一位**挪到了**第一位**并取反。

也因此，我们可以将这个下标表示成类似一个环的结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/8y67r7l2.png)

这张图演示了某个数在两次操作中下标的变化，相信还有疑问的同学到这里应该就明白了。

注意到由于我很懒，我并没有真的去旋转这个环，而是用了一个指针指向了最低位，事实上我们在实现中也会用到这个想法。
## Part 3
不难看出，现在我们已经把操作抽象到在环中翻转某一位了，这就可以用**异或**和来维护这些修改对每个数的下标的影响。

于是你已经会维护每个数的下标了，它就是在原数异或上一个值后翻转几位。

因此，我们将这个操作倒着来，将对应的下标转回来几位，再重新异或这个值即可。
## Code
此题实现难度不大，std 有效代码长度均在 $0.3\text{kb}$ 左右，可能有一些小细节，但是由于良心的出题人将 $n$ 设定在了 $32$，且下标从 $0$ 开始，所以大概想明白之后 $5$ 分钟就能写完吧。
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long 
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
inline ull read64()
{
	ull s=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+(ch&15),ch=getchar();
    return s;
} 
signed main()
{
	int n=read(),m=read(),cnt=0;
	ull t=0,g=(1ull<<n)-1;
	for(;m--;)
	{
		int op=read();
		ull x=read64();
		if(op==1) (x==1)&&(t^=1ull<<(cnt%n)),(++cnt>=n)&&(cnt-=n);
		else printf("%llu\n",(((x+(x<<n))>>((n-cnt)%n))&g)^t);
	}
    return 0;
}

```

---

## 作者：water_tomato (赞：4)

本文同步发表于个人博客：[Link](https://www.watertomato.com/p7442-%e3%80%8cezec-7%e3%80%8d%e7%bb%b4%e6%8a%a4%e5%ba%8f%e5%88%97-%e9%a2%98%e8%a7%a3/)。

非常有意思的一道题（虽然确实容易想不出来）。

## 题意

[题目链接](https://www.luogu.com.cn/problem/P7442)

维护一个 $0 \sim 2^n-1$ 的序列，支持两个操作：将下标为偶数的数按序提前，将下标为奇数的数按序后置；将下标为偶数的数按序后置，将下标为奇数的数按序提前。

## 解析

我们考虑两种操作的实质。

第一种操作（偶前奇后）：对于下标为 $x$ 的数，若 $x$ 为偶数，则它的新下标为 $\frac{x}2$；若 $x$ 为奇数，则它的新下标为 $\frac{x}{2}+\frac{n}{2}$。

第二种操作（奇前偶后）：对于下标为 $x$ 的数，若 $x$ 为偶数，则它的新下标为 $\frac{x}{2}+\frac{n}{2}$；若 $x$ 为奇数，则它的新下标为 $\frac{x}{2}$。

见到这么多的除以二，我们考虑到二进制。我们假定一个操作前某数的下标为 $x=(a_na_{n-1}a_{n-2} \dots a_2a_1 )$，同时我们又发现偶数的末位为 $0$，奇数的末位为 $1$，那么我们进行一次一操作，就是将下标变为 $(a_1a_na_{n-1} \dots a_3a_2 )$，也就是将最后一位移到第一位，再将其他位都向后推一位。同样能够发现，我们进行一次二操作，就是将下标变为 $((a_1\operatorname{xor}1)a_na_{n-1} \dots a_3a_2 )$，也就是将末位异或 $1$ 之后再进行之前的操作。因此假设我们进行 $t$ 次操作后（$t < n$），就是把最后的 $t$ 位以**相同的顺序**移到了前面（即，若原先三位在最后是 $(a_3a_2a_1)$ ，则它被移到了前面之后这三位依然是 $(a_3a_2a_1)$，内部顺序不变），把其他位移到了最后（当然其中可能有一些需要异或）。

现在，我们得到的是一个操作后的数的下标，输出对应的数其实就是输出原始的下标。因此，我们可以用 $cnt$ 记录一下进行了几次一操作（容易发现，当 $n=cnt$ 时，所有位都移了一轮，此时可以将 $cnt$ 归零），然后将这个数的末 $n-cnt$ 位向前移 $cnt$ 位，将最前的 $cnt$ 位向后移动 $n-cnt$ 位，这样，我们就得到了原先的数，但是注意，我们此时**尚未处理**异或操作。

容易发现，每次异或实际是对第 $cnt+1$ 位进行异或，那么我们可以用一个变量 $v$ 记录原始每一位上是否需要异或，详见代码注释。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=60;
int n,m,t[N],v,x,opt,cnt;
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) t[i]=(t[i-1]<<1)+1;//可以提前处理一下全 1 数
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&opt,&x);
		if(opt==1){
			v^=x<<cnt;//将第 cnt+1 位打上标记，若 x=0 显然这个操作是无意义的
            cnt++;
			if(cnt==n) cnt=0;//如果 cnt=n 了，一轮结束，cnt 归零
		}
		else{
			printf("%lld\n",(((x&t[n-cnt])<<cnt)|(x>>(n-cnt)))^v);
            //(x&t[n-cnt])<<cnt 是将最后 n-cnt 位向前移动
            //x>>(n-cnt) 是将前 cnt 位向后移动，再用 | 合并
            //由于我们前面的标记打在原始序列上，所以要先将该数列还原后再 ^v
		}
	}
	return 0;
}
```



---

## 作者：Macesuted (赞：3)

[点击这里以获得更佳阅读体验](https://www.macesuted.cn/article/lg7442/)

[题面](https://www.luogu.com.cn/problem/P7442)

# 分析

显然每一次操作可以让位置为 $x$ 的数排到 $\frac x 2$ 或 $\frac x 2 + 2^{n-1}$ 的位置。

我们可以尝试将这样的操作理解为：在二进制意义下，我们把 $x$ 的最低位移到了最高位，并且有可能让该位反转。

尝试举几个例子可以发现，操作一在将最低位移到最高位时无需反转该位；而操作二则需反转该位。

记录所有操作带来的更改，最后从询问给出的 $x$ 反推回最初的位置即可。

具体实现方法见代码。

~~这个做法时间复杂度为 $O(nq)$，与部分题解做法相比可能较慢~~

# 代码

我们考虑记 `rev[i]` 表示记录第 $i$ 位是否需要反转。

下面的代码中记 $p$ 表示原坐标一共右移了几次（即操作了几次），$p=n$ 时令 $p=0$。 

```cpp
/**
 * @author Macesuted
 * @date 2021-03-20
 * 
 * @copyright Copyright (c) 2021
 * 
 */

#include <bits/stdc++.h>
using namespace std;

using io::getch;
using io::putch;
using io::read;
using io::write;

#define maxn 64

bool rev[maxn];
long long ln[maxn];

int main() {    
    register int n = read<int>(), m = read<int>(), p = 0;
    ln[0] = 1;
    for (register int i = 1; i < maxn; i++) ln[i] = ln[i - 1] << 1;
    while (m--)
        if (read<int>() == 1) {
            if (read<int>()) rev[p] ^= true; //如果是操作二则需反转最低位
            if (++p == n) p = 0; //右移了一位
        } else {
            register long long x = read<long long>();
            for (register int j = 0; j < p; j++) x = ((x << 1) & (ln[n] - 1)) | (x >> (n - 1) & 1); //将最高位移到最低位
            for (register int j = 0; j < n; j++)
                if (rev[j]) x ^= ln[j]; //反转部分位
            write(x), putch('\n');
        }
    return 0;
}
```

---

## 作者：VinstaG173 (赞：3)

简单结论题，但是考场上想错+打错很久，最后导致不想做 C（

我们尝试处理 $x$ 所处位置下标。我们称两种操作分别为 $0$ 操作和 $1$ 操作，按输入 $opt=1$ 时 $x$ 的值命名。

显然最开始 $x$ 的位置下标为 $x$。设操作前下标为 $y=(a_na_{n-1}\dots a_1)_ 2$，进行 $0$ 操作后下标变为 $(a_1a_n\dots a_2)_ 2$，进行 $1$ 操作后下标变为 $((a_1 \operatorname{xor} 1)a_n\dots a_2)$。因此进行长度为 $t$ 的一串 $01$ 操作后 $x$ 所在的位置就可以求出了。具体就是第 $i$ 次操作若是 $0$ 操作则不改变 $x$，若是 $1$ 操作就改变 $x$ 的二进制从低到高第 $i \bmod{n}$ 位（从第 $1$ 位开始计数）上的数值，即 $x$ 变为 $x \operatorname{xor} 2^{i \bmod{n}}$。最后将 $x$ 的二进制最后 $t \bmod n$ 位提到最前面。因此直接逆推即可。

时间复杂度 $O(m)$。

Code:
```cpp
#include<cstdio>
#define uint unsigned int
inline char rc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
inline uint _read()
{
	uint x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
int n,m;
uint x,vl=0;
int opt,tmp=0;
int main()
{
    n=read(),m=read();
    while(m--)
    {
        opt=read(),x=_read();
        if(opt==1)
        {
            vl^=(x<<tmp),++tmp;
            (tmp==n)&&(tmp=0);
        }
        else printf("%u\n",(((x&((1<<(n-tmp))-1))<<tmp)|(x>>(n-tmp)))^vl);
    }
    return 0;
}
```

---

## 作者：zlqwq (赞：2)

省流：cspj 得一等了！

好厉害的思维题!

由于打字太难，这里 $2^n$ 都用 $n$ 来代替。

我们来看一下这个一操作怎么个事。

对于每个 $i$，如果积前偶后，若 $i$ 为奇数，则 $i$ 会变成 $\frac{i}{2}$，否则会变成 $\frac{i}{2}+\frac{n}{2}$。

如果偶前奇数后，则正好相反。

此时，每个 $a_i$ 下一轮的位置其实仅仅和自己的的下标 $i$ 的奇偶性和 $a_1$ 的奇偶性有关。

这样，我们对每个数转化二进制，经过计算得出其新的位置，并记录一共进行了几次操作 $1$。

设这个数为 $tmp$，我们只需将这个数二进制下前 $tmp$ 位向后移，后 $n-tmp$ 位往前移，就是之前的数。

代码很好实现，时间复杂度约 $O(M)$。

---

## 作者：Time_tears (赞：2)

~~额额额，考场直接降智。~~

~~以下题解应该只有我一个傻*会这样做，大家看看就好，复杂度被吊起来锤。~~

首先我们看看 $(1,0),(1,1)$ 操作到底干了啥。

1. 偶前奇后

- $i$ 为奇数，$a_i$ 会去到 $a_{i/2}+\frac{n}{2}$ 
- $i$ 为偶数，$a_i$ 会去到 $a_{i/2}$ 

2. 奇前偶后

- $i$ 为奇数，$a_i$ 会去到 $a_{i/2}$ 
- $i$ 为偶数，$a_i$ 会去到 $a_{i/2}+\frac{n}{2}$ 

所以我们会发现，每次操作等价于下标的每一位左移一位，再把第 $0$ 位换到第 $n-1$ 位去，与此同时，第 $0$ 位的值有可能会从 $0$ 变为 $1$，于是，每一位是独立的，我们对每一位单独考虑再对于每个询问合并即可(~~真是太傻*了~~)。

所以总复杂度是 $O(mn)$ 的，太菜了~~~。

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define uint unsigned int
using namespace std;
uint n,m,tmp,cnt,ans[40][2];
uint read() {
	uint s=0;
	char ch=getchar();
	while(ch<48||ch>57)ch=getchar();
	while(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return s;
}
int main() {
	n=read(),m=read();
	for(int i=0; i<n; ++i)ans[i][1]=1ll<<i;
	while(m--) {
		uint opt=read(),x=read(),Ans=0;
		if(opt==1) {
			for(int i=0; i<n; ++i)if(i!=cnt)ans[i][0]>>=1,ans[i][1]>>=1;
			ans[cnt][0]=(x^ans[cnt][0])?(1ll<<n-1):0,ans[cnt][1]=(x^ans[cnt][1])?(1ll<<n-1):0;
			cnt=(cnt==n-1)?0:cnt+1;
		} else {
			for(int i=cnt; i<n; ++i)if((x&(1ll<<i-cnt))==ans[i][1])Ans|=1ll<<i;
			for(int i=0; i<cnt; ++i)if((x&(1ll<<n-cnt+i))==ans[i][1])Ans|=1ll<<i;
			cout<<Ans<<"\n";
		}
	}
	return 0;
}
```


---

## 作者：漠寒 (赞：1)

## 分析

刚开始此题被放在了第一道，第一眼我没有算对复杂度，写了一个极易理解的暴力算法，而且还因为看错下标做得更加麻烦，思路是这样的。

```
for(int i=tot;i>=1;i--){
	if(cz[i]==0){
		if(x<=mid){
			x=2*x-1;
		}
		else {
			x=(x-mid)*2;
		}
	}
	if(cz[i]==1){
		if(x<=mid){
			x=x*2;
		}
		else {
			x=(x-mid)*2-1;
		}
	}
}
return x-1;
```


很明显，$m^2$ 的复杂度，经过找规律我发现对于第一种操作，如果连续 $n$ 次就会抵消，以上是暴力加捆绑点5的思路。

从序列大小为 $2^n$，我们可以试试二进制位运算，随机设几组 $n$ 然后进行两种操作的修改，我们发现，对于操作一，就是对于偶数位置的数，将它的坐标改为了原来的一半，奇数位置则是移至一半加上 $\frac{n}{2}$，然后就是很明显，就是不断地将它的下标二进制集体向右转一位，最后一位转到前面来，然后将它回溯，转回去，其实就是在2进制上将暴力的一个个回溯改为了位运算的单次运算方法，这也可以解释为什么操作一进行 $n$ 次之后就会抵消，而操作二经过演算，发现就是先移动再异或上一，所以这道题就这么搞定了。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int unsigned int
int cnt,op,x,n,m,y;

inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+c-48;c=getchar();}
	res*=f;
}

inline void write(int x){
	if(x==0){
		putchar('0');
		return;
	}
	char f[205];
	int tmp=x>0?x:-x;
	if(x<0)putchar('-');
	int cnt=0;
	while(tmp>0){
		f[cnt++]=tmp%10+'0';
		tmp/=10;
	}
	while(cnt>0)putchar(f[--cnt]);
}

signed main()
{
	read(n);read(m);
	while(m--){
		read(op);read(x);
		if(op==1){
			if(x==1){
				y^=1<<cnt;
			}
			cnt++;
			if(cnt>=n)cnt=0;
			continue;
		}
		write(((x>>(n-cnt))|((x&((1<<(n-cnt))-1))<<cnt))^y);
		putchar(10);
	}
	return 0;
}
```


---

## 作者：abc1234shi (赞：0)

# 题目理解
这道题要求我们维护一个序列，这个序列一开始有 $2^n$ 个数，下标从 $0$ 开始，每个数的初始值就是它的下标。然后我们需要支持三种操作：

- 把所有偶数下标的数组成一个子序列，奇数下标的数组成另一个子序列，然后把它们拼起来，形成新的序列。

- 把所有奇数下标的数组成一个子序列，偶数下标的数组成另一个子序列，然后把它们拼起来，形成新的序列。

- 查询某个下标对应的值。

听起来是不是有点绕？别急，我慢慢给你分析。

# 难点分析
如果直接按照题目描述去操作，每次操作都重新生成一个新的序列，那肯定不行，因为序列长度可能非常大（最大到 $2^{32}$），直接操作肯定会超时。
# 关键点
其实，我们不需要真的去生成新的序列，只需要找到一个方法，能够快速定位到某个下标对应的值。这里的关键是观察操作对下标的影响。

 # 解题思路
 **第一步，观察操作对下标的影响**
 
我们先来看看两种操作对下标的影响：操作 $1$（偶数在前，奇数在后）：假设原来的下标是 $i$，操作后它的新下标会变成 $2×(\lfloor i\div 2 \rfloor)$。换句话说，偶数下标不变，奇数下标会变成原来的一半再乘以 $2$ 加 $1$。
操作 $2$（奇数在前，偶数在后）：假设原来的下标是 $i$，操作后它的新下标会变成 $2×(\lfloor i\div 2 )\rfloor+1)$。换句话说，偶数下标会变成原来的一半再乘以 $2$ 加 $1$，奇数下标不变。

**第二步，用一个变量记录操作的次数**

我们可以用一个变量（比如叫 $cnt$）来记录操作 $1$ 和操作 $2$ 的次数。每次操作 $1$，$cnt$ 加 $1$；每次操作 $2$，$cnt$ 减 $1$。这样，我们可以通过 $cnt$ 来判断当前的操作状态。

**第三步，查询操作**

对于查询操作，我们需要根据当前的 $cnt$ 值来计算出目标下标对应的原始下标。这里有一个关键的公式：

- 如果 $cnt$ 是偶数，那么下标 $x$ 对应的值就是 $x$。

- 如果 $cnt$ 是奇数，那么下标 $x$ 对应的值可以通过某种变换得到。

具体来说，假设 $cnt$ 是奇数，那么我们需要把下标 $x$ 转换为它的“镜像”位置。这个镜像位置可以通过 $2n−1−x$ 来计算。

**第四步，实现思路**

- 初始化 $cnt = 0$。

- 对于操作 $1$，$cnt + 1$。

- 对于操作 $2$，$cnt - 1$。

- 对于查询操作，根据 $cnt$ 的奇偶性来决定是否需要计算镜像位置。
# 总结
这道题的关键在于不要真的去生成新的序列，而是通过观察操作对下标的影响，用一个变量记录操作的次数，然后通过这个变量来快速定位查询的结果。这种方法既节省时间，又节省空间。

---


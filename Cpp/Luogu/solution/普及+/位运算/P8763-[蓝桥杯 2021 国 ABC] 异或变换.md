# [蓝桥杯 2021 国 ABC] 异或变换

## 题目描述

小蓝有一个 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$。

以后每个时刻, 小蓝要对这个 01 串进行一次变换。每次变换的规则相同。 对于 01 串 $s=s_{1} s_{2} s_{3} \cdots s_{n}$, 变换后的 01 串 $s^{\prime}=s_{1}^{\prime} s_{2}^{\prime} s_{3}^{\prime} \cdots s_{n}^{\prime}$ 为：

$$
\begin{aligned}
&s_{1}^{\prime}=s_{1} \\
&s_{i}^{\prime}=s_{i-1} \oplus s_{i}
\end{aligned}
$$

其中 $a \oplus b$ 表示两个二进制的异或, 当 $a$ 和 $b$ 相同时结果为 $0$ , 当 $a$ 和 $b$ 不同时结果为 $1$ 。

请问, 经过 $t$ 次变换后的 01 串是什么?

## 说明/提示

**【样例说明】**

初始时为 `10110` , 变换 1 次后变为 `11101` , 变换 2 次后变为 `10011` , 变换 3 次后变为 `11010`。

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例, $1 \leq n \leq 100,1 \leq t \leq 1000$。

对于 $80 \%$ 的评测用例, $1 \leq n \leq 1000,1 \leq t \leq 10^{9}$。

对于所有评测用例, $1 \leq n \leq 10000,1 \leq t \leq 10^{18}$。

蓝桥杯 2021 国赛 A 组 F 题（B 组 G 题，C 组 G 题）。

## 样例 #1

### 输入

```
5 3
10110```

### 输出

```
11010```

# 题解

## 作者：ryf_loser (赞：19)

2024.3.11 添加第二组演示样例。

2024.3.12 修改第一组演示样例，添加一点点证明。

暴力显然寄飞了，考虑优化，这种情况往往是有规律的，我举两个例子样例进行模拟的。

输入 $n=4,t=5$，不难发现，从第 4 次就开始循环了。

$0. 0110 \leftarrow$

$1. 0101$

$2. 0111$

$3. 0100$

$4. 0110 \leftarrow$

用样例再来搞一下，输入 $n=5,t=9$

$0. 10110$

$1. 11101 \leftarrow$

$2. 10011$

$3. 11010$

$4. 10111 $

$5. 11100$

$6. 10010$

$7. 11011$

$8. 10110$

$9. 11101 \leftarrow$

有感觉了么？

那么，最终的规律是当大于等于 $n$ 的一个 2 的整数次幂情况下，必定存在循环。

可以证明，令 $x=2^k$，根据题目。

$s_{x,j}=s_{x-1,j}\oplus s_{x-1,j-1}$

$s_{x-1,j}=s_{x-2,j}\oplus s_{x-2,j-1}$

$s_{x-1,j-1}=s_{x-2,j-1}\oplus s_{x-2,j-2}$

……

由此递推下去，可得。

$s_{x,j}=s_{\frac{x}{2},j}\oplus s_{\frac{x}{2},j-x}$

根据异或性质可以发现，第 $x$ 的序列是由两次 $\frac{x}{2}$ 的序列得来的。

当 $x \geq n$ 时，这种重复操作变得没有意义，准确来说，当 $x \leq n$ 时必定存在与此时字符串 $s$ 完全相同。

时间复杂度为 $O(n \log \min(n,t))$ 级别。秒了。

AC CODE

```c
#include<stdio.h>
long long n,t;
int x=1;
char s[10005];
int main(){
	scanf ("%lld%lld",&n,&t);
	scanf ("%s",s);
	while(x<n)x<<=1;t=t%x;
	for(int i=0;i<t;i++)
		for(int j=n-1;j>=1;j--)
			s[j]=(s[j]-'0')^(s[j-1]-'0')+'0';
	printf ("%s",s);
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

# [P8763 [蓝桥杯 2021 国 ABC] 异或变换](https://www.luogu.com.cn/problem/P8763) 题解

## 一、题意

要求对 01 串进行变换，每次都需要根据某种固定的规则进行变换。规则是对于给定的 01 串 $s$，变换后的 01 串 $s^\prime$ 满足 $s_1^{\prime}=s_1$，$s_i^{\prime}=s_{i - 1}\oplus s_i$。

## 二、思路

不用想，直接暴力肯定获得 TLE。通过观察和证明可以发现，当变换次数达到某一个值时，结果会重复出现（即出现周期）。通过将长度为 `n` 的二进制数扩大一倍，即找到一个 `x`，使得 `x = 1 << (ceil(log2(n)))`，这样可以确保在 `x` 次变换内一定会出现周期。因此给定的变换次数 `t` 对 `x` 取模，得到变换次数，从后往前遍历字符串，根据变换规则计算每个位置的新值。

## 三、代码

这里使用了 `string` 作为题目中 01 串的类型，因此 `n` 可以替换为 `s.size()`。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace MuguCode
{
    string s;
    long long n, t, x;

    int main()
    {
        cin >> n >> t >> s;
        // 找到一个大于等于 n 的最小的 2 的整数次幂，其中位运算会稍快，左移相当于乘 2
        x = 1;
        while (x < n)
            x = x << 1;
        // 对变换次数取模，推算变换次数
        t = t % x;
        while (t--)
        {
            // 从后往前遍历字符串进行变换，注意 s[0] 不需要进行变换
            for (long long i = n - 1; i >= 1; i--)
                // 根据变换规则计算新值
                s[i] = ((s[i] - '0') ^ (s[i - 1] - '0')) + '0';
        }
        cout << s << endl;
        return 0;
    }
}
int main()
{
    MuguCode::main();
    return 0;
}
```

---

## 作者：陈嘉逸2012 (赞：1)

## 思路
由于异或操作的性质，经过一定数量的变换后，串可能会回到其初始状态或某个之前的状态。

可以通过模拟或数学分析来找出这个周期。在这个问题中，周期 $x$ 是满足 $2^x \le n$ 的最小整数，可是有可能会重复，这样无意义。时间复杂度 $\Theta(nt)$。特别是当 $t$ 非常大时：$1 \le t \le 10^{18}$，显然会超时。

由于存在周期性，我们不需要实际执行 $t$ 次变换，我们可以计算 $t \bmod x$ 来找出实际需要执行的变换次数，这大大减少了计算量，时间复杂度 $\Theta(n\log n)$。

我们使用一个循环来执行实际需要的变换次数。
在每次变换中，从右向左遍历串，并根据异或规则更新每个元素。

**十年 OI 一场空，不开`long long`见祖宗！**
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,x=1;//分别表示：01串的长度、变换次数、用于计算变换周期的辅助变量
string s;//用于存储输入的01串
int main(){
	cin>>n>>t>>s;
	/*
	计算变换的周期，即找到一个最小的x，使得2^x>=n
	因为异或变换具有周期性，变换x次后会回到初始状态
	所以实际变换次数可以取t对x的模，减少计算量
	*/
	while(x<n) x<<=1;
	t%=x;//计算实际需要进行的变换次数
	//对01串进行t次变换
	for(int i=0;i<t;i++){
		//从右向左遍历01串，根据变换规则更新每个位置的值
		for(int j=n-1;j>=1;j--) s[j]=((s[j]-'0')^(s[j-1]-'0'))+'0';//将字符'0'/'1'转换为整数0/1进行异或运算，然后再转换回字符
	}
	cout<<s;
}
```

---

## 作者：elonzhang (赞：0)

# [P8763 [蓝桥杯 2021 国 ABC] 异或变换](https://www.luogu.com.cn/problem/P8763)

## 思路
显而易见这个异或一直进行下去一定是会重复的，然后我们可以达表找规律，发现只要进行最大的 $\le n$ 的最大的二的整数次幂次的操作，就一定会有一个重复的。这一部分可以用 $O(\log n)$ 的时间复杂度暴力枚举，最终总时间复杂度是 $O(n\log n)$。

## ACcode
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl '\n'
#define inf 0x7f7f7f7f7f7f7f7f
const int N=10001;
int n,t,x=1;
bool a[N];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//  freopen(".in","r",stdin);
//  freopen(".out","w",stdout);
//↑以上为初始化↑
//------------------------------
	cin >> n >> t;
	for(int i = 1;i<=n;++i){
		char ch;
		cin >> ch;
		a[i]=(ch=='1');
	}
	while(x<n) x<<=1;
	t%=x;
	for(int i = 1;i<=t;++i){
		for(int j = n;j>1;--j){
			a[j]=a[j-1]^a[j];
		}
	}
	for(int i = 1;i<=n;++i) cout << a[i];
	return 0;
}
```

---


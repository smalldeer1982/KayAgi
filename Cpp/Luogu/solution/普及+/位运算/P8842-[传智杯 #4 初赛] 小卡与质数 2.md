# [传智杯 #4 初赛] 小卡与质数 2

## 题目背景

小卡迷上了质数！

## 题目描述

小卡最近迷上了质数，所以他想把任何一个数都转化为质数！

小卡有 $T$ 次询问，每次给你一个数字 $x$，问有多少个比 $x$ 小的非负整数 $y$，使得 $x\oplus y$ 是质数，其中 $\oplus$ 表示按位异或。

## 样例 #1

### 输入

```
9
5
6
7
8
9
10
100
1000
10000```

### 输出

```
2
4
4
2
2
4
22
163
1132```

# 题解

## 作者：fdszlzl (赞：15)

[P8842 [传智杯 #4 初赛] 小卡与质数2](https://www.luogu.com.cn/problem/P8842)

**题意：给定 $T$ 个 $x$ ，求有多少个小于 $x$ 的非负整数与 $x$ 异或的结果为质数。**

$x⊕y=p (y < x)$

要枚举 $y$ ，时间复杂度 $O(Tx)$

$x⊕y=p \to x⊕p=y(y < x)$

要枚举 $p$ ，时间复杂度 $O(Tz)$ 。百万内的质数有$z$个（几万）。

因为 $y<x$，异或后值变小。什么情况异或后值会变小？

设 $x=(100100)_2$

要想异或后值变小，$1$ 必须变成 $0$ 

$1⊕1=0$ 

- 第一个$1$

$100100⊕ 1***** = 0***** <100100$

换言之，$100100⊕(100000 \sim 111111)$ 的值都小于 $100100$

即，$x⊕(2^5 \sim 2^6-1)$ 的值小于 $x$

现在我们只要算出 $(2^5 \sim 2^6-1)$ 有几个质数即可，前缀和。

- 第二个 $1$

$100100 ⊕ 0001** = 1000** <100100$

换言之， $100100⊕(000100 \sim  000111)$ 的值都小于  $100100$

即， $x⊕(2^2 \sim 2^3-1)$ 的值小于 $x$

现在我们只要算出 $(2^2 \sim 2^3-1)$ 有几个质数即可。

总之，若 $x$ 的第 $i$ 位为 $1$，算出 $2^i \sim 2^{i+1}-1$ 有多少个质数累加即可。

注意，$x⊕p=y(y < x)$， $p$ 有可能超过 $x$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e7+10;
int prime[N],sum[N];

int main() {
	int n;
	cin>>n;
	prime[0]=prime[1]=1;
	for(int i=2;i<=N-10;i++)
	{
		if(prime[i]) continue;
		for(int j=2;i*j<=N-10;j++) prime[i*j]=1;
	}
	for(int i=1;i<=N-10;i++) sum[i]=sum[i-1]+(!prime[i]); 
	for(int i=1;i<=n;i++)
	{
		int x,ans=0;
		cin>>x;
		for(int j=0;j<=30;j++)
			if(x&(1<<j)) 
				ans+=sum[(1<<(j+1))-1]-sum[(1<<j)-1];
		cout<<ans<<'\n';
	}
	return 0;
}
```




---

## 作者：Adolfo_North (赞：6)

[传送门](https://www.luogu.com.cn/problem/P8842)

变态数学题（主考位运算与素数筛）。

读完题看起来有点难做，因为质数的出现是根本没有可以使用的规律。暴力的话也很好想，枚举 $y$。但是肯定会超时。我们也可以换个方向枚举。对，筛出素数，再返过去判断有多少个素数符合条件，但任然会超时。

再思考一下，$x$ 异或上什么样的数才能使结果小于 $x$？

#### 注意下面的步骤需要草稿纸推演，不然会有点难理解。

我们设符合条件的素数为 $k$ ，我们设 $k$ 的二进制中最高位是第 $M$ 位，不难发现，只有在 $x$ 的第 $M$ 位上也是 $1$ 的时候，$k$ 异或 $x$ 的结果小于 $x$（这一步若实在想不通的可以拉到文末，查看证明过程）。

随即。我们用素数筛，并统计范围内所有素数的最高位是哪一位，对于每个询问把 $x$ 每位拆开，若发现某一位是 $1$，则加上桶里已经计算好的，二进制数该位为 $1$ 的素数个数。

代码奉上：
```cpp
#include<iostream>
using namespace std;
int T,n,m,ans;
int zhi[2000010],cnt[26];
bool f[2000010];
void IAKchuanzhibei(){
	//素数筛 （欧拉筛法） 
	for(int i=2;i<=2000000;i++){
		if(!f[i])zhi[++m]=i;
		for(int j=1;j<=m&&i*zhi[j]<=2000000;j++){
			f[i*zhi[j]]=1;
			if(!(i%(zhi[j])))break;
		}
	}
	//开桶记录 
	for(int i=1;i<=m;i++)
		for(int j=25;j>=1;j--)//由于1000000内最大的质数为999983,转成二进制为1111 0100 0010 0010 1111，共24位，为保险起见，这里从25开始计算 
			if(zhi[i]&(1<<(j-1))){
				cnt[j]++;//计算当质数为j位时，一共的个数 
				break;
			}
}
int main()
{
	//预处理 
	IAKchuanzhibei();
	
	cin>>T;
	while(T--)
	{
		cin>>n;
		ans=0;
		for(int i=25;i>=1;i--) if(n&(1<<(i-1))) ans+=cnt[i];//加上所有符合条件的素数 
		cout<<ans<<endl;
	}
	return 0;
}
```
证明过程：

观点一：那么 $k$ 异或 $x$ 的结果从 $M+1$ 位开始与 $x$ 的 $M+1$ 位开始的部分相同。因为 $k$ 的 $M+1$ 位以上的部分均为 $0$，因为 $1$ 异或 $0$ 的结果为 $1$，$0$ 异或 $0$ 的结果为 $0$，所以保持不变。

观点二：那么重点来到 $M$ 位，由于 $k$ 的 $M$ 位一定为 $1$，那么如果 $x$ 的 $M$ 位也为 $1$，异或一下结果为 $0$，即小于原来 $x$ 的 $M$ 位，那么异或的结果一定小于 $x$。若 $x$ 的 $M$ 位为 $0$，则反之。

---

我们设 $x=13$，并拿质数 $3$ 和 $5$ 举例。

$13$ 的二进制：$1101$。

$3$ 的二进制：$0011$ 异或结果：$1110$。

前两位与 $1101$ 相同（观点一）。

第二位（$M$ 位）为 $1$，大于原来的 $0$。所以无论后面几位为什么，异或结果都比 $1101$ 大。（观点二）。

---

$5$ 的二进制：$0101$ 异或结果：$1000$。

前一位与 $1101$ 相同（观点一）。

第三位（$M$ 位）为 $0$，小于原来的 $1$。所以无论后面几位为什么，异或结果都比 $1101$ 小。（观点二）。

---

## 作者：zhangbo1000 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8842)


对于每组数据暴力枚举，是 $O(Tx)$，$T\le10^5,x\le10^6$，最多 $10^{11}$，肯定超时。

考虑用数据结构？$x⊕y$ 的值与 $y$ 的值是有关的，因此从 $x-1⊕y$ 转移到 $x⊕y$ 亦为 $O(x)$，复杂度 $O(x^2)$，~~更慢了~~，丝毫无用。

那考虑下 $x⊕y$ 的性质吧？

令 $x⊕y=p,p$ 为质数，则 $x⊕y⊕y⊕p=p⊕p⊕y$ ，即 $x⊕p=y$ ，枚举 $p$ ，比枚举 $y$ 好一点，但还是 TLE 了。

那我们考虑怎么快速算出符合条件的 $p$ 的数量。

通过简单的筛法即可轻松求出一定范围内的质数个数，此过程为 $O(x)$ （线性筛）或 $O(x\log{\log{x}})$ （埃氏筛）预处理与 $O(1)$ 单次查询，效率很高且难以优化复杂度（有一个巨大的常数优化放在代码后了）。

那么关键在于快速判断 $y$ 是否符合。

回想下我们比较大小的过程，用~~比较专业~~通俗易懂的话可抽象表达为

* 1.位数大的一定大。

* 2.位数相同时，若 $a>b$ 则。

  * (1)最高的数位（可以 $0$ 位）相同。

  * (2)其余数位中，$a$ 最高的一位比 $b$ 大，其它位随意。

我们可以钦定 $a$ 与 $b$ 位数相同（位数少这高位补0），那么便只考虑第2点即可。

确定了这点，我们再来分析 $a>a⊕p$ 的条件（为方便讨论，我们再度钦定  $a,p$ 均用 $2$ 进制）。

 $a$ 与 $a⊕p$ 最高的数位相同，则 $p$ 的最高的数位为  $0 (0⊕0=0,0⊕1=1)$。

 $a$ 与 $a⊕p $ 的某位上 $a$ 小，则由于 $0=0,0<1$ ，故 $a$ 的此位为1，$a⊕p$ 此位为0，则 $p$ 此位为1。

剩下数位随意。

那么，若 $x$ 因第 $i$ 位而大于 $x⊕p$ 则最高数位相同，情况数为 $1$。

第 $i$ 位上两者都是 $1$。

剩下 $i-1$ 位上随意，则剩下 $i$ 位数为 

$$\text{ }\text{ }\text{ }\text{ }1\underbrace{0...0} \sim \underbrace{11...11}$$
$$i-1\text{个}0\text{ }\text{ }\text{ }\text{ }\text{ }\text{ }i\text{个}1$$

，即 $2^i \sim 2^{i+1}-1$ 之间，可用前缀和统计此区间质数个数。

所以最后算法是这样的：对于每个 $i$，若 $x$ 的第 $i$ 位为1，则答案加上 $2^i\sim2^{i+1}-1$ 之间的质数个数。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<bitset>
using namespace std;
bitset<2000001>p;
int s[2000001];
int now=0;
void shai(){
	p[0]=p[1]=1;
	for(int i=2;i<=2000000;i++){
		if(!p[i]){
			for(long long j=i;i*j<=2000000;j++){
				p[i*j]=1;
			}
		}
		s[i]=s[i-1]+(!p[i]);
	}
}
int main(){
	int T,x,ans;
	char c;
	shai();
	cin>>T;
	while(T--){
		x=0;
		ans=0;
		while((c=getchar())<'0');
		while(c>='0')x=(x<<3)+(x<<1)+(c^'0'),c=getchar();
		for(int i=0;x>>i;i++){
			if(x&(1<<i))ans+=s[(1<<(i+1))-1]-s[(1<<i)-1];
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

代码中记录质数数组开了 $2\max(x)$ ，因为最大的满足 $x⊕p<x$ 的 $p<2x $，这是因为当 $p\ge2x $ 时， $p$ 中最高的 $1$ 比 $x$ 中最高的 $1$ 位数高，故此时 $x⊕p \ge x$。

使用了 bitset 节约内存并加快速度，详见 [P3383[模板]线性筛素数](https://www.luogu.com.cn/problem/P3383)的题解，以及[这篇文章](https://bh1234666.blog.luogu.org/kachangjiqiao)。

读入是一个极简版的快读，必须输入只含数字，空格，回车，也无法处理负数，这个东西是个神奇的东西，比较完备的版本可以见[这里](https://www.luogu.com.cn/problem/P3865)。原理 ... 我也不太了解。

---

## 作者：hgckythgcfhk (赞：2)

记得我去年这个时候做这个题的时候不了解异或的性质，连题解都没看懂，所以这里我先总结一下关于异或前后的大小和取值范围的问题。

为了方便，直接用题面的字母，$x$ 和 $y$。

首先当 $x=y$ 时答案为 $0$ 不用说了吧，这个很显然，也就是说我们只需要讨论 $x>y$ 和 $x<y$ 的情况，由于异或运算满足交换律，显然，这两种情况是对称的，也就是说，可以强行地限制为题面中的 $x>y$。

记 $a$ 表示 $x \operatorname{xor} y$，现在讨论 $a$ 的取值范围和 $a$ 与 $x$ 和 $y$ 的大小关系。

设 $\operatorname{hb}(x)=\max_{i\in N}[2^i \operatorname{and} x \ne 0]i$，简单点说，就是把最低位称为第 $0$ 位，最高位是第几位。

因为 $x>y$，则有 $\operatorname{hb}(x) \ge \operatorname{hb}(y)$。

把这个条件拆成两个情况分开讨论：

1. $\operatorname{hb}(x) = \operatorname{hb}(y)$，此时，只考虑 $a$ 的最高位，$1\operatorname{xor}1=0$，做过关于异或的贪心的话应该直到此时 $x>a$。

给个形式化的证明，设 $b=\operatorname{hb}(x)$，可得 $\operatorname{hb}(y)=b$，上面说过，$a$ 的第 $b$ 位为 $0$，根据定义可以得到一个显然的结论 $x\ge 2^b,a<2^b$ 故上式成立，证毕。

当然，根据这个证明，也可以得到此时 $y>a$。

2. $\operatorname{hb}(x)>\operatorname{hb}(y)$，此时，只考虑 $a$ 的最高位，$1\operatorname{xor}0=1$，根据情况 $1$ 的证明可以得到 $a>y$ 不重复证明。

讨论 $a$ 与 $x$ 的大小关系：

沿用上面的证明中对 $b$ 的定义，并再定义一个 $c=\operatorname{hb}(y)$，若 $x$ 的第 $c$ 位为 $0$，则，$x$ 和 $a$ 有长度为 $b-c$ 的公共前缀，这部分是一样的，也就是说，只看后 $c$ 位不会改变结论。

讨论第 $c$ 位，根据定义 $y$ 的第 $c$ 位肯定是 $1$，当 $x$ 的第 $c$ 位为 $1$ 时，相当于情况 $1$，此时 $x>a$，否则相当于把公共前缀清零后再把 $x$ 和 $y$ 交换，也就是情况 $2$ 我们证明了 $a>y$，这里 $y$ 表示原来的 $x$，所以 $x<a$。

最后求 $a$ 的最取值范围，先给出结论，$a\in[1,2^{b+1}-1]$。

下界：根据 $x\ne y$，显然有 $a>0$，而且这个下界是能取到的，因为异或运算具有自反性，简单点说异或意义下的逆元是本身，所以，一定有 $x\operatorname{xor}a=y$，也就是说，只要是上下界以内的都可以取到，这也就是为什么我把 $x=y$ 的情况单独考虑，因为异或运算在负数域上没有数学意义，单独把结果为 $0$ 的考虑掉可以避免这种不严谨的问题。

上界：在上述证明中，可以发现，$\operatorname{hb}(a)$ 没有出现大于 $b$ 的情况，所以 $a<2^b$ 成立，证明下界的取等时已经证过了，上界也能取等。

你可能觉得我说了一堆废话，但这个时侯我们其实已经通过这个证明过程把这个题做出来了。

沿用上面的字母，回到题面，发现，这个质数就是我们证明过程中的 $a$，根据异或运算的自反性，发现这个问题相当于对所有的质数求与 $x$ 的异或小于 $x$ 的方案数，首先当 $\operatorname{hb}(a)>b$ 时显然不存在，然后由上述证明可知，$x>y$ 当且仅当 $\operatorname{hb}(x)=\operatorname{hb}(a)$ 或 $x$ 的第 $\operatorname{hb}(a)$ 为 $1$，其实这两种可以规约到一种情况，但不管怎样，我们都把这个题做出来了，预处理每个 $\operatorname{hb}(a)=i$ 的方案数即可。

这个预处理可以直接用 ```__lg```  或者 ```__builtin_clz``` 函数实现，可以避免对边界到底是加 $1$ 还是减 $1$ 这种问题的讨论，而且这两个函数是 $O(1)$ 的，自己手写的是 $O(\log n)$ 或 $O(\operatorname{popcount}(n))$ 的，当然你也可以用二分做到 $O(\log\log n)$，或者线性的预处理，但不管怎样都不可能比这两个函数快，推荐用第一个，因为不用考虑到底是 $31-clz$ 还是 $32-clz$ 的问题。

```cpp
#include<bits/stdc++.h>
#define cit const register unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0),freopen("1.in","r",stdin),freopen("1.out","w",stdout)
using namespace std;constexpr unsigned N=1048576+1;
#define int register unsigned
#define ll long long
#define void inline void
vector<unsigned>p;bitset<N>v;unsigned cnt[21];
void init(){p.emplace_back(2);for(int i=3;i<N;i+=2){if(!v[i])
	p.emplace_back(i);for(cit j:p){if(i*j>N)break;v[i*j]=1;}}}
signed main(){open;int t,n;cin>>t;init();for(cit&i:p)++cnt[__lg(i)];while(t--){
cin>>n;int ans=0;for(int i=__lg(n);i;--i)n&(1<<i)?ans+=cnt[i]:0;cout<<ans<<'\n';}}

```

---

## 作者：Su777 (赞：2)

$2024/02/19$ update：位运算原理介绍表格更新。感谢 @[旻偲](https://www.luogu.com.cn/user/1019006) 指出问题。

[题目传送门](https://www.luogu.com.cn/problem/P8842)

## 题意简述

给定 $T$ 个质数，对于每一个质数，求出有多少个小于它的非负整数，使得 $x, y$ 按位异或的结果是质数。

## 解题思路

### 按位异或原理介绍

本题提到的按位异或是一种神奇的运算，我叫它**不进位加法**。这是为什么呢？我们列张表分析一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/4whx16vr.png)

其中只有 $(1)_2+(1)_2=(10)_2$ 的第一位 $1$ 被舍去，按位异或结果变成了 $0$。又因为位运算不进位，所以这个本来加出来的 $(10)_2$ 变成了 $0$，值由此变小。

### 题意转化

又因为位运算的交换律，$x⊕y=p \rightarrow x⊕p=y$，问题变为找到所有符号要求的质数，让它按位异或 $x$ 得到的结果是小于 $x$ 的非负整数 $y$。

怎么能让 $x$ 的值变小呢？对了，就用上面表格里的算法。对于每一位 $x$ 二进制表示中的 $1$，我们都用这个二进制位为 $1$ 的质数来让它的数值减小。

所以如果 $x$ 二进制表示中从右往左第 $i$ 位是 $1$，枚举这一位为 $1$ 的数，即 $[2^i,2^{i+1}]$ 这个范围内的质数都是符合要求的。

### 具体实现细节

考虑到本题数据较大，按需进行质数判断时间复杂度较高，会超时。因此埃氏筛质数和线性筛质数都可以用。

筛完之后可以直接遍历所有质数，累加 $cnt$ 数组，其中 $cnt_i$ 记录第 $i$ 位如果是 $1$ 所对应的答案。具体地，对于每一个质数，如果二进制表示从右往左第 $k-1$ 位为 $1$，那么 $cnt_k$ 加一，统计答案时直接调用累加即可。

知道了这些，写代码就是小菜一碟啦~

## 代码奉上

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll maxn = 2e6 + 10;
ll cnt[maxn] = {}; // 统计每一个二次幂对应的答案
// 线性筛质数模板，不做解释
bool is_prime[maxn];
ll prime[maxn];
ll pcnt = 0; // prime_cnt
void shai() {
    memset(is_prime, 1, sizeof(is_prime));
    is_prime[0] = is_prime[1] = 0;
    
    for (int i = 2; i <= maxn - 10; i ++) {
        if (is_prime[i]) {
            pcnt ++;
            prime[pcnt] = i;
        }
        for (int j = 1; j <= pcnt && i * prime[j] <= maxn - 10; j ++) {
            is_prime[i * prime[j]] = 0;
            if (i % prime[j] == 0) {
                break;
            }
        }
    }
    return;
}

int main() {
    ll t;
    cin >> t;
    shai(); // 线性筛质数

    // 遍历每一个质数
    for (int i = 1; i <= pcnt; i ++) {
        for (int j = 25; j >= 0; j --) {
            // 如果这个质数的右边第 j-1 位为 1
            if (prime[i] & (1 << (j - 1))) {
                cnt[j] ++;
                break;
            }
        }
    }

    for (int i = 1; i <= t; i ++) {
        ll x, ans = 0;
        cin >> x;
        for (int j = 0; j <= 30; j ++) {
            if (x & (1 << (j - 1))) {
                ans += cnt[j];
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## 作者：ax_by_c (赞：2)

首先,非常明显,这题是位运算。

又因为一个数小于另一个数可以写成:

**若干位相同** 加上 **一位小于** 加上 **若干位任意**。

对于二进制也是一样。

那么异或后的结果就是:

（若干位相同）变为了（若干位为 $0$）。

（一位小于）（$1$ 变成 $0$）变为了（该位为 $1$）。

（若干位任意）变为了（若干位任意）。

所以如果找到了小于的那一位，则异或后的结果是在一个连续值域段内的。

所以得到解法:

对于每个 $x$，枚举 $x$ 的二进制下为 $1$ 的所有位，作为小于的那一位（异或后结果为 $1$）。

然后可以得到一个值域段，用欧拉筛+前缀和维护一下质数个数即可。

code:
```
#include<iostream>
#include<cstdio>
using namespace std;
const int WH=20;
const int N=(1<<WH);//筛的范围
bool mk[N+5];
int p[N+5],ct;
int sum[N+5];
void init()//欧拉筛
{
	mk[1]=1;
	for(int i=2;i<=N;i++)
	{
		if(!mk[i])
		{
			p[++ct]=i;
		}
		for(int j=1;j<=ct&&i*p[j]<=N;j++)
		{
			mk[i*p[j]]=1;
			if(i%p[j]==0)break;
		}
	}
	for(int i=1;i<=N;i++)
	{
		sum[i]=sum[i-1]+(!mk[i]);//前缀和维护质数
	}
}
int Q(int l,int r)//前缀和
{
	if(!l)l++;//防止数组越界
	if(!r)r++;
	return sum[r]-sum[l-1];
}
int nth(int x)//返回二进制下第x位的权值
{
	if(!x)return 0;
	return 1<<(x-1);
}
int getwh(int x,int wh)//判断x的第wh位是否为1
{
	return (x>>(wh-1))&1;
}
int allone(int tl)//我懒得用位运算了
{
	int res=0;
	for(int i=1;i<=tl;i++)//后tl位全为1时的数
	{
		res+=nth(i);
	}
	return res;
}
int l,r;
int n;
int ans;
void solve()
{
	ans=0;
	scanf("%d",&n);
	for(int wh=21;wh>=0;wh--)
	{
		if(getwh(n,wh))//寻找小于的那一位
		{
			l=nth(wh);
			r=l+allone(wh-1);//计算值域段
			ans+=Q(l,r);
		}
	}
	printf("%d\n",ans);
}
int main()
{
	init();
	int t;
	scanf("%d",&t);
	while(t--)
	{
		solve();
	}
	return 0;
}
```

---

## 作者：NEWSTDLRZ (赞：1)

这道题直接考虑什么 $y$ 和 $x$ 异或起来是 $p$ 实在是太困难了，因为 $p$ 还有要求，要求这个数是质数。

于是我们考虑将 $x \oplus y=p$ 的结果 $p$ 换成一个要求更低的数。

根据异或规则，两边同时异或同一个数，结果不变，则有：$x \oplus p=y$，只要 $y<x$ 即可。

于是我们开始着手考虑该怎么样满足 $y<x$ 这个要求。

我们找到从 $y$ 的最高位开始找到第 $1$ 个 $1$，设他是第 $p$ 位（从左到右数）。

考虑什么数异或上 $p=x$ 比 $x$ 小。

如果异或完这个数的第 $p$ 位还是 $1$ 的话，那么至少枚举到这一位的话并没有办法确定答案。

但是，如果异或完这个数的第 $p$ 位是 $0$ 的话，这个数的高位已经比 $x$ 小了，就可以直接确定当前贡献了。

那……什么数的第 $p$ 位和当前这个数第 $p$ 位异或上是 $0$ 呢？

既然 $x$ 第 $p$ 位是 $1$，根据 $1 \oplus 1=0$，我们可以也让这个位置是 $1$ 就行。

这样，后面不管是什么位都比 $x$ 要小了。

即：贡献为 $[2^p,2^{p+1})$ 之间的质数。我们可以直接预处理出来质数，然后前缀和一遍，就可以 $\mathcal O(1)$ 得到这个东西的答案了。

考虑从 $x$ 的第 $p$ 位开始从右找到第 $g$ 位，第 $g$ 位是除 $p$ 之外找到的第一个位为 $1$ 的位置。

根据推理，我们还是让 $g$ 这一位为 $1$，就可以了。

但是要注意：这里的高位并不能有一个是 $1$，第一个是这个贡献已经被计算了，第二个是我们如果还计算高位的贡献的话，我们就无法保证 $y<x$ 了。

即：贡献也是 $[2^g,2^{g+1})$ 之间的质数。

以此类推，假设第 $t$ 位是 $1$，那么就要给答案加上 $[2^t,2^{t+1})$ 之间质数个数的贡献。

这样，这道题就做完了。

如果使用线性筛质数，时间复杂度是 $\mathcal O(n \log n+V)$ 的，$V=10^6$。

综合：时间复杂度为 $\mathcal O(n \log n+V)$，非常优秀。

~~但是为了防抄袭，所以我写了个 $\mathcal O(n \log n+V \log V)$，用 Miller-Rabin 筛质数的解，提交上去你就是最裂解。~~

代码：

```cpp
#include<bits/stdc++.h>
#define x0 x_0
#define x1 x_1
#define y0 y_0
#define y1 y_1
#define yn y_n
#define j0 j_0
#define j1 j_1
#define k0 k_0
#define k1 k_1
#define d0 d_0
#define d1 d_1
#define LL long long
#define LD long double
#define ZPB push_back
#define ZPF push_front
#define US unsigned
#define Big __int128
using namespace std;
LL qpow(LL a,LL b,const LL mod){
	LL ret=1,pan=a%mod;
	while(b){
		if(b&1) ret=(ret*pan)%mod;
		pan=(pan*pan)%mod,b>>=1;
	}
	return ret;
}
bool pd_noprime(LL jd,const LL n){
	LL x=n-1;
	int cnt=0;
	while((x&1)^1) x>>=1,++cnt;
	LL b1=qpow(jd,x,n),b2;
	for(int i=1;i<=cnt;++i){
		b2=(b1*b1)%n;
		if(b2==1 && b1!=1 && b1!=n-1) return 1;
		b1=b2;
	}
	if(b1^1) return 1;
	return 0;
}
LL pd[]={2,7,61};
bool miller_rabin(LL n){
	if(n<=1) return 0;
	if(n==2) return 1;
	if((n&1)^1) return 0;
	for(int i=0;i<3;++i){
		if(pd[i]==n) return 1;
		if(pd_noprime(pd[i],n)) return 0;
	}
	return 1;
}
int t,n,sum[2000010];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	for(int i=1;i<=2000000;++i) sum[i]=sum[i-1]+miller_rabin(i);
	while(t--){
		cin>>n;
		LL ok=0,ans=0;
		for(int i=19;i>=0;--i){
			if((n>>i)&1) ans+=sum[(1<<(i+1))-1]-sum[(1<<i)-1];
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：z_yq (赞：1)

### 题目意思
给定 $x$ 求一个 $y$ 使 $x \oplus y$ 为质数，且满足 $y \lt x$

### 思路
我们由异或的特性可得：$x \oplus y$ 若为 $p$，则 $x \oplus p = y$，又因为 $y \lt x$，所以我们只需考虑质数筛和怎么取 $p$ 可以保障 $x \oplus p \lt x$ 所以我们把 $x$ 变成二进制：

设：$x = (101001)_2$ 则：考虑 $x$ 第一个二进制位上的 $1$，自然：如果要 $x \oplus p \lt x$ 则 $p$ 必须有 $(100000)_2$ 的这一位去抵消，也不能有 $(1000000)_2$，这样就会让 $x$ 增大，所以，我们的 $p$ 只考虑这一位就只能取值取在 $(100000)_2$ 到 $(1000000)_2$ 之间，其他的两位也是一样的，由此我们可以得到答案：若 $x$ 二进制上的这一位为 $1$ 则 $ans$ 要加上 $sum_{2^{i+1}-1}-sum_{2^i-1}$，其中 $sum_i$ 表示前 $i$ 个数中质数的个数。

### Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=2e6+9,M=2e6;
ll prime[N],sum[N],n;
inline void init()
{
    int temp,cnt=0;
    for(int i=2;i<=M;i++)
    {
        if(prime[i]==0)
            prime[i]=2;
        for(int j=2;i*j<=M;j++)
            prime[i*j]=1;
    }
    for(int i=1;i<=M;i++)
        sum[i]=sum[i-1]+(prime[i]==2);
}
int main()
{
    init();
    ll T;
    cin>>T;
    while(T--)
    {
        ll ans=0;
        cin>>n;
        for(int i=31;i>=0;i--)
            if((n>>i)&1)
                ans+=sum[(1<<(i+1))-1]-sum[(1<<i)-1];
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：AndyPomeloMars (赞：1)

## P8842 [传智杯 #4 初赛] 小卡与质数 2

### 题目大意

* 给你 $T$ 个 正整数 $x$，问有多少个比 $x$ 小的非负整数 $y$，使得 $x \oplus y \in \mathbb{P}$。

* 其中 $1 \leq T \leq 10^5$，$1 \leq x \leq 10^6$。

### 题目分析

由题目可知 $y < x$，所以我们需要让 $x$ 二进制上的 $1$ 变成 $0$（$1 \oplus 1 = 0$）。

例如：

$$x = (1001010)_2$$

第一个 $y < x$，就是 $(1001000)_2$（将 $x$ 从右到左的第一个 $1$ 变成 $0$）。

通过这个性质，我们可以知道：

$$(1001010)_2 \oplus [(1000000)_2, (1111111)_2] < (1001010)_2$$

可得到公式：

$$x \oplus (y \in [\lfloor \log x \rfloor, \lceil \log x \rceil - 1]) < x$$

综上所述，当 $x$ 的第 $i$ 位为 $1$，将 $2^i \sim 2^{i + 1} - 1$ 中的素数个数累加进答案即可（可以使用线性筛）。

### 题目代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 10000010;

int T, N, ANS, cnt;
int P[MAXN], pres[MAXN];
bool vis[MAXN];

inline void sieve(){ // 线性筛板子
    vis[0] = vis[1] = 1;
    for (int i = 2; i <= MAXN - 10; ++i){
        if (!vis[i]) ++cnt, P[cnt] = i;
        for (int j = 1; j <= cnt && i * P[j] <= MAXN - 10; ++j){
            vis[i * P[j]] = 1;
            if (!(i % P[j])) break;
        }
    }
}

int main(){
    sieve(), cin >> T;
    for (int i = 1; i <= MAXN - 10; ++i) pres[i] = pres[i - 1] + (!vis[i]); // 前缀和
    while (T--){
        cin >> N;
        for (int i = 0; i <= 30; ++i) if (N & (1 << i)) ANS += pres[(1 << (i + 1)) - 1] - pres[(1 << i) - 1]; // 套用公式
        cout << ANS << endl, ANS = 0;
    }
    return 0;
}
```






---

## 作者：I_will_AKIOI (赞：0)

我们将题目变为找到一个质数 $z$，令 $y=x\oplus z$，使得 $y<x$，求 $z$ 的个数。

我们先观察一下 $x$ 异或上什么数才能比 $y$ 大。令 $x_i$ 表示 $x$ 的二进制从右往左数的第 $i$ 位。

当 $x_i=1$ 时，显然，当 $z_i=1$，$y_i=1\oplus1=0$，由于第 $i$ 位后面的位都比第 $i$ 位小，说明此时 $y<x$。当 $x_i=0,z_i=1$ 时，$y>x$。而当 $x_i=1,y_i=0$，$x_i=0,y_i=1$ 或 $x_i=0,y_i=0$ 时，我们无法确定 $x$ 和 $y$ 的大小。

因此我们可以建立一棵字典树，把质数存进去。接着让 $x$ 一直往下走，若 $x_i=1$，则将答案加上当前节点子树 $0$ 的个数，然后往 $0$ 走，继续遍历，到达空节点退出。

这里字典树大小要开 $\pi(10^6)\times \log_2(10^6)$，大概是 $3.1\times 10^6$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,cnt,sz[3200000];
int a[2000005],p[200005],t[3200000][2];
void insert(int x)
{
	int root=0;
	for(int i=21;i>=0;i--)
	{
		bool now=x&(1<<i);
		if(!t[root][now]) t[root][now]=++cnt;
		sz[root]++;
		root=t[root][now];
	}
	return;
}
void solve()
{
	int ans=0,root=0;
	cin>>n;
	for(int i=21;i>=0;i--)
	{
		bool now=n&(1<<i);
		if(now) ans+=sz[t[root][1]];
		root=t[root][0];
		if(!root) break;
	}
	cout<<ans<<"\n";
	return;
}
int main()
{
	ios::sync_with_stdio(0);
	for(int i=2;i<=2000000;i++)
	{
		if(!a[i]) p[++s]=i,insert(i);
		for(int j=1;j<=s&&i*p[j]<=2000000;j++)
		{
			a[i*p[j]]=1;
			if(i%p[j]==0) break;
		}
	}
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---


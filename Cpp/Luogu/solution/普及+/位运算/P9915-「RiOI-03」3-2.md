# 「RiOI-03」3-2

## 题目背景

> Heart beat to death[.](https://www.luogu.com.cn/problem/P9304)

## 题目描述

给定一个正整数 $n$。将 $[0,2^n)$ 中每个整数的二进制最低 $n$ 位**从低到高**依次写在一个 $2^n\times n$ 的矩阵上。**矩阵两维的下标都从 $0$ 开始。** 如，当 $n=3$ 时，矩阵是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/5f6v9pru.png?x-oss-process=image/resize,m_lfit,h_200,w_265)

给定 $q$ 次询问，每次询问这个矩阵下标为 $(x,y)$ 的格子所在的四连通块大小对 $998244353$ 取模的值。


## 说明/提示

#### 【样例 #1 解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/4mglp4cn.png?x-oss-process=image/resize,m_lfit,h_200)

图为 $n=2$ 时的矩阵，其中同一个颜色的为一个四连通块。

***

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n\le$ | $q\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $15$ | $15$ |
| $1$ | $20$ | $15$ | $5\times 10^5$ |
| $2$ | $25$ | $5\times 10^3$ | $5\times 10^3$ |
| $3$ | $50$ | $10^{18}$ | $5\times 10^5$ |

对于 $100\%$ 的数据，$0\le y\lt n\le 10^{18}$，$0\le x\lt \min(2^n, 10^{18})$，$1\le q\le 5\times 10^5$。

**请选用较快的输入输出方式。**

## 样例 #1

### 输入

```
2 2
1 1
2 0```

### 输出

```
3
1```

# 题解

## 作者：Expert_Dream (赞：23)

[更好的阅读](https://www.cnblogs.com/gsczl71/p/17891879.html)

这是一道找规律的题目。

因为我个人习惯，以下部分使用从 $1$ 开始的下标讲述。

首先我们以 $1$ 来说：发现在第 $x$ 行 $y$ 列的连通块是可以直接连到第 $1$ 列的，所以很容易可以得出 $1$ 到 $y$ 列的连通块数量是 $2^y-1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/zoevtz96.png)

接着，我们考虑再后面的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/6998d0gj.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/b4st701j.png)

显然，通过观察会分为后面两种情况。一种是遇到了不一样的数字，那么就无法继续判断下去。如果是一样的话那么必定是增加 $2^{y-1}$ 个连通块，于是，我们就可以用一个循环，一直增加 $y$，不断更新着连通块的数量。

如果考虑 $0$ 的情况也是同理。这里不过多解释。

但是我们还是会发现：这样的时间复杂度肯定过不去。

但是出题人给了善良的条件：$n \le 10^{18}$。那么 $\log(n)$ 最多也就 $64$ 了，所以，我们在 $y$ 大于 $64$ 的时候特判掉即可。

于是优化到了 $O(q \log n)$。

上代码：[link](https://www.luogu.com.cn/paste/jmjn3h13)。

其中感谢 @tiger2008 在 [求助贴](https://www.luogu.com.cn/discuss/744405) 中告知需要特判。感谢好心人！

给个关注或一个赞呗！

---

## 作者：TernaryTree (赞：13)

# Preface

3-2=1。

# Solution

这题锻炼观察能力。我们画出 $n=4$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0jkv1fe1.png?x-oss-process=image/resize,m_lfit,h_300)

因为可用的颜色太少，所以图中两个不同的四连通块是两个颜色不同**或者**两者之间没有公共点的最大颜色块。

首先竖着观察每一列。可以发现，每一列都是 $2^j$ 个 $0,1$ 交替出现。

而对于每一个连通块，都可以竖着拆分成若干个 $2^j$ 之和。而 $j$ 互不相同且连续。以及对于每个连通块，都有一个与最左侧相连的点，即 $\min\{j\}=0$。简单证明如下：

考虑一个点 $(x, y)$。其值为 $a_{x,y}=\lfloor\dfrac{x}{2^y}\rfloor\bmod 2$。如果只保留这个数的前面，即 $\lfloor\dfrac{x}{2^y}\rfloor$，后面 $y-1$ 个数全部和当前这个位置的值一样，那么得到的这一行也会和 $(x,y)$ 在一个连通块内。那么得到的这一行显然是存在一个点 $j=0$ 的。

我们已经明确了 $\textrm{ans}=\sum\limits_{j=0}^{\textrm{sth.}}2^j=2^{\textrm{sth.+1}} - 1$（等比数列求和）。接下来是怎么求出 $\textrm{sth.}$，也就是 $\max\{j\}$ 的值。

显然，$\max\{j\}=$ $(x,y)$ 后面有与 $a_{x,y}$ 值相同的一段，而这一段的右端点的 $j$ 即为 $\max\{j\}$。形式化地，我们要找到最大的 $j'$ 使得 $\forall y\le j\le j',a_{x,j}=a_{x,y}$。

问题来了。暴力找是 $\Theta(n)$ 的。怎么优化找的过程呢？

注意到 $x\le 10^{18}$。当 $y$ 在 $x$ 的二进制位数（$\le 60$）以内时，暴力向后找的次数最大仅为 $\Theta(\log n)$。否则答案直接顶到最高位 $n$。

于是 $\Theta(\log n)$ 找到 $\max\{j\}$，$\Theta(\log n)$ 快速幂计算 $2^{\max\{j\}+1}-1$，总复杂度 $\Theta(q\log n)$ 就做完了。

当然还有非常非常重要的一点，右移位数太多是 UB（未定义行为），需要特判。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int mod = 998244353;

int power(int base, int freq, int mod) {
    int ans = 1, tmp = base;
    while (freq > 0) {
        if (freq % 2 == 1) ans = ans * tmp % mod;
        freq /= 2;
        tmp = tmp * tmp % mod;
    }
    return ans;
}

int n, q, x, y;

int find(int x, int y) {
	if (y > 62) return n;
    x >>= y;
    if (!x) return n;
    int d = x & 1;
    do x >>= 1, ++y;
    while ((x & 1) == d);
    return y;
}

signed main() {
    cin >> n >> q;
    while (q--) {
        cin >> x >> y;
        cout << (power(2, find(x, y), mod) - 1 + mod) % mod << endl;
    }
    return 0;
}
```


---

## 作者：HasNoName (赞：10)

### 题目大意

把 $[0,2^n)$ 的数中第 $n$ 个数到序中第 $i$ 位所到达四连通块点个数。

$n \le {10}^{18}$。

### 思路

用数组存整个二进制是一定不行的。

但 $x \le {10}^{18}$。

存储每次 $x$ 的二进制所用空间非常小。

经过分析后发现二进制的第 $i$ 列每一个数纵向可到达个数为 $2^i$ 个，因为只有经过 $2^i$ 次增加才能进位。

然后如果 $y$ 后面只有前缀 $0$ 则可直接将 $y$ 移动到第 $n-1$ 列，否则把 $y$ 一位一位向后移动。

的出 $y$ 的最后方位置之后，由于之前每次为二分之一的相同块个数，所以和第 $y$ 列相同的个数为 $ \sum_{i = 0}^{y} ({2}^{i}) $ 等于 $2^{y+1}-1$ 个。

可以使用快速幂来做。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//要开 long long
const ll MOD=998244353;
ll n;
bool t[100005];
ll q(ll y)//用快速幂求解 2^y
{
    if(y==0)
        return 1;
    ll mi=q(y>>1);
    mi=mi*mi%MOD;
    if(y&1)mi=(mi<<1)%MOD;
    return mi;
}
ll jian(ll x)//用数组 t[] 来存储 x 的二进制倒序
{
    ll l=0;//表示 x 的非零前缀的长度
    while(x)
    {
        t[l]=(x&1);
        x>>=1;
        l++;
    }
    return l-1;//真实长度
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    ll k,x,y;
    cin>>n>>k;
    while(k--)
    {
        cin>>x>>y;
        ll l=jian(x);
        if(y>l)//y 是一个为零的前缀
        {
            y=n-1;//y 可以移动到末尾
        }
        while(y<l&&t[y]==t[y+1])//把 y 向后移
        {
            y++;
        }
        cout<<q(y+1)-1<<'\n';
    }
    return 0;
}

```

### 复杂度

快速幂为 $O(\log y)$。  
移动，建 0,1 串为 $O(\log x)$。

总复杂度为 $O(q \log(x))$。

[记录。](https://www.luogu.com.cn/record/138966380)  
[赛时记录。](https://www.luogu.com.cn/record/138912858)

---

## 作者：SamHJD (赞：5)

## [P9915 「RiOI-03」3-2](https://www.luogu.com.cn/problem/solution/P9915)

### 题意

定义 $a_{i,j}=[i\land 2^j=1]$。对于每次询问，求 $a_{x,y}$ 所在的连通块大小。

---

### 解法

观察 $a$ 的性质，我们发现对于第 $j$ 列（从 $0$ 开始），都是由长度为 $2^j$ 的 $0$ 串和 $1$ 串重复拼接而成。对于每一串，其左边都对应两个长度为 $2^{j-1}$ 的 $0$ 串与 $1$ 串，并且 $1$ 串在下。

我们单拿出某一列的一串长度为 $2^j$ 的 $1$ 举例，假设其左边全为 $0$，那么它的连通块大小为 $\sum\limits^{j}_{i=0}2^i=2^{j+1}-1$。其形状大致如图：

```
    1
    1
  1 1
1 1 1
```

于是询问 $(x,y)$ 时，我们一定可以从这个点一直向右走到达与其相等的最长的一串 $0$ 或 $1$，计算答案即可。

由于询问的 $x$ 不超过 $10^{18}$，我们可以考虑一个优化。如果询问的 $y$ 大于 $x$ 的最高位 $1$，那么一定可以走到第 $n$ 列，直接输出 $2^{n}-1$。

复杂度 $O(q\log A)$，其中 $A$ 为值域。

---

### [代码](https://www.luogu.com.cn/paste/rewqpnqx)

---

## 作者：喵仔牛奶 (赞：4)

# Preface

为啥有蓝啊，这题在机房里 15min 左右就切了，反倒是 2A 做了 1h。。

# Solution

将矩阵逆时针旋转 $90^{\circ}$，你会发现这是一棵线段树，是父亲左儿子的节点颜色是 $0$，是右儿子的节点颜色是 $1$。

容易发现，联通块一定是一条链。具体地，你从给定的点向上跳，跳到第一个与自己异色的点，然后从这个点一路向下联通，可以联通到叶子。

我们令叶子那层是第 $0$ 层，那么如果向上跳到的点深度为 $d$，答案就是 $\sum_{i=0}^{d}2^i=2^{d+1}-1$。

判断 $y$ 是否超出了 $x$ 的最高位，如果是，说明能联通到根，答案为 $2^n-1$；否则暴力向上跳即可。

时间复杂度 $\mathcal{O}(q\log n)$。

# Code

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb push_back
using namespace std;
namespace Milkcat {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    const int N = 1e6 + 5, mod = 998244353;
    LL n, q, x, y;
    LL qpow(LL b, LL k) { LL r = 1; for (; k; b = b * b % mod, k >>= 1) if (k & 1) r = r * b % mod; return r; }
    int main() {
		cin >> n >> q;
		REP(test, 1, q) {
			cin >> x >> y;
			if (__lg(x) < y) {
				cout << (qpow(2, n) - 1 + mod) % mod << '\n';
			} else {
				int p = x >> y & 1;
				while ((x >> y & 1) == p) y ++;
				cout << (qpow(2, y) - 1 + mod) % mod << '\n';
			}
		}
        return 0;
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}
```

---

## 作者：cosf (赞：2)

## [P9915](https://www.luogu.com.cn/problem/P9915)

观察性质题。

我们打一个 $n=5$ 的表。为了不影响阅读，图片放到了文末。

可以发现，每一个连通块都有如下性质：

1. 形如一个（倒）金字塔。
2. 其中一个角是所谓的“直角”。
3. 从横着来看，除了最宽的那一层，同宽度的层的层数等于该宽度减一的层数除以 $2$。

那么，我们可以推出底部宽为 $k$ 的金字塔的大小：

$$
Size_k = (\sum_{i=1}^{k-1}i\times 2^{k-i-1}) + k = 2^k - 1
$$

至此，这道题已经解决了一半。

现在，我们要求的是 $(x, y)$ 所在的金字塔的底边大小。

可以发现，假设 $x$ 的二进制如下，有两种情况：

$$
\begin{cases}
x = (\dots00\overbrace{1}^{y\text{-th place}}100\dots)_2 & (1)\\
x = (\dots 11\overbrace{0}^{y\text{-th place}}011\dots)_2 & (2)
\end{cases}
$$

对于情况 $(1)$，观察表可以发现，存在 $y'$ 使得 $x_y = x_{y+1} = \dots = x_{y'} = 1, x_{y' + 1} = 0$（此处 $x_y$ 表示 $x$ 在二进制下的第 $y$ 位，从第 $0$ 位开始记），则该金字塔的底部宽为 $y' + 1$。

对于情况 $(2)$，同样可得，若存在 $y'$ 使得 $x_y = x_{y + 1} = \dots = x_{y'} = 0, x_{y' = 1} = 1$，则该金字塔的底部宽为 $y' + 1$，否则为 $n$。

注意，当 $y \ge 64$ 时，$x_y$ 是绝对不可能为 $1$ 的，需优化此情况。

关于实现，计算 $x_y$ 时一定要用 `1ll` 去左移而不是 `1`。~~我因此罚了好几发。~~

## 代码

```cpp
#include <iostream>
using namespace std;

#define MOD 998244353

using ll = unsigned long long;

ll po(ll b, ll p)
{
	ll r = 1;
	while (p)
	{
		if (p & 1)
		{
			r = r * b % MOD;
		}
		b = b * b % MOD;
		p >>= 1;
	}
	return r;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll n;
	int q;
	cin >> n >> q;
	while (q--)
	{
		ll x, y;
		cin >> x >> y;
		if (y >= 64)
		{
			cout << (po(2, n) - 1 + MOD) % MOD << endl;
			continue;
		}
		if (x & (1ll << y))
		{
			while (x & (1ll << y) && y < n)
			{
				y++;
			}
			cout << (po(2, y) - 1 + MOD) % MOD << endl;
		}
		else
		{
			while (!(x & (1ll << y)) && y < n)
			{
				y++;
			}
			cout << (po(2, y) - 1 + MOD) % MOD << endl;
		}
	}
	return 0;
}
```

## 附

$n=5$ 时的表：

![](https://cdn.luogu.com.cn/upload/image_hosting/wf187hak.png)


---

## 作者：zxh923 (赞：1)

# P9915 「RiOI-03」3-2 题解

[题目传送门](https://www.luogu.com.cn/problem/P9915)

### 思路

先看 $0\le x\lt \min(2^n, 10^{18})$，可以发现题目询问行数不会超过 $10^{18}$，所以显然在这个范围内只有矩阵的前 $63$ 位是会变化的。

观察矩阵发现，一个位置的四连通块中，一定有一项在第 $0$ 列，由此设这个四连通块最靠右的一列为第 $k$ 列，则其大小为 $2^{k+1}-1$。

所以直接用位运算找出这一位是 $0$ 还是 $1$，然后向后查找直到这一位与上一位不同或者他大于等于 $63$。

最后判断负数，把答案加上 $998244353$ 再取模即可。

### 代码

```cpp
#include<bits/stdc++.h> 
#define int long long
#define mod 998244353
using namespace std;
int n,q,a,b,mo,t;
int ksm(int x,int y){//快速幂板子 
	int res=1;
	while(y){
		if(y&1){
			res*=x;
			res%=mod;
		}
		x*=x;
		x%=mod;
		y/=2;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);//读写优化 
	cin>>n>>q;
	while(q--){
		cin>>a>>b;
		mo=-1;
		t=((a>>b)&1);//找出这一位是几 
		if(b>=63||(a>>b)==0)mo=n;//a是0或者b在恒定不变列中 
		else{
			for(int i=b+1;;i++)
				if(((a>>i)&1)!=t){//判断是否相同 
					mo=i;break;
				}
			if(mo==-1)mo=n;
		}
		cout<<(ksm(2,mo)-1+mod)%mod<<'\n';//判负数 
	}
	return 0;
}
```


---

## 作者：FReQuenter (赞：1)

打表发现：

```
000000
100000
010000
110000
001000
101000
011000
111000
000100
100100
010100
110100
001100
101100
011100
111100
```

形如这样一个图形。

```cpp
for(int i=0;i<=(1<<6);i++){
	for(int j=0;j<6;j++) cout<<((i>>j)&1);
	cout<<endl;
}
```

发现了什么？对于每一个连通块，其大小是 $2^0+2^1+2^2+\cdots+2^m=2^{m+1}-1$ 的形式，其中 $m$ 是当前连通块最大的横坐标。

那么我们只需要搜寻当前 $(x,y)$ 所在连通块的最大纵坐标。观察可以发现连通块是正三角形或倒三角形样式的，所以不停向右走，直到所在位置的值不同。直接暴力是 $O(nq)$ 的。

注意到 $x\le10^{18}$，所以当 $y>62$ 时所有位都是 $0$，可以跳过从 $63$ 到 $n-1$ 的搜索过程。复杂度 $O(q\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
bool f;
int g(int x,int y){
	if(y>=x||y>62){
		f++;
		return 0;
	}
	return (x>>y)&1;
}
int qpow(int a,int n){
	int ans=1;
	while(n){
		if(n&1) ans*=a,ans%=mod;
		a*=a,a%=mod,n>>=1;
	}
	return ans;
}
signed main(){
	int n,q;
	cin>>n>>q;
	while(q--){
		int x,y;
		cin>>x>>y;
		f=0;
		while(y<n-1&&g(x,y)==g(x,y+1)){
			y++;
			if(y>62){
			    y=n-1;
			    break;
			}
		}
		cout<<(qpow(2,y+1)-1+mod)%mod<<endl;
	}
}
```

---

## 作者：Iniaugoty (赞：1)

我场切蓝题？？？我场切蓝题？？？我场切蓝题？？？

~~为什么正经 CSP 和 NOIP 的时候就打不好了？~~

把这题中的矩阵翻过来感觉更好理解一些：

```cpp
0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1
0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
```

注意到第 $i$ 行（从下往上数，从 $0$ 开始），是由若干个长度 $2 ^ i$ 的极长相同颜色子段拼成的。

注意到每一行的一个极长相同颜色子段，对应地放到下一行来，前一半是 $0$，后一半是 $1$。

那么第 $i$ 行的一个子段，不管颜色如何，只往下考虑，可以得到一个大小为 $2 ^ i + 2 ^ {i - 1} + \cdots + 2 ^ 0 = 2 ^ {i + 1} - 1$ 的连通块。当然，如果第 $i + 1$ 行上这个子段对应位置和第 $i$ 行上的子段颜色不相同，这就是极大连通块的大小。

再回到题中，要在同行找到一个，最靠右的、和 $(x, y)$ 在同一个极大连通块内的位置，假设他是 $(x, z)$，那么答案就是 $2 ^ {z + 1} - 1$。

在前 $2$ 个包里，可以使用位移运算直接找。

在前 $3$ 个包里，可以把 $x$ 的二进制串处理出来，在这上面直接模拟着找。但是这种做法没有继续扩展的余地了。

对于 $2$ 号包，如果按前 $2$ 个包来，位移 $5 \times 10 ^ 3$ 位显然是会 UB 的。但实际上 $x$ 达不到 $2 ^ {5 \times 10 ^ 3}$，最多只有 $10 ^ {18} \le 2 ^ {60}$，存在大量位置全为 $0$，那么考虑做一个剪枝（或者说数据分治？）。如果 $y > 60$，$\ge y$ 的位置全为 $0$，显然可以直接令 $z \gets n - 1$；否则位运算模拟，过程中如果 $z > 60$，也意味着后面全是 $0$，令 $z \gets n - 1$ 即可。

这个做法可以扩展到最后一个包。

哎好抽象的题啊，不太好讲，这个图看透了其实就都明白了。

需要注意的是，$z$ 可能极大，计算答案要快速幂而不是直接位移。

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const LL mod = 998244353;

LL n, _, x, y;

LL qPow(LL x, LL y) {
	LL res = 1;
	while (y) {
		if (y & 1ll) res = res * x % mod;
		x = x * x % mod, y >>= 1ll;
	}
	return res;
}

int main() {
//  freopen("wmyr.in", "r", stdin);
//  freopen("wmyr.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> _;
	while (_--) {
		cin >> x >> y;
		LL base = y; // base 就是文字部分的 z
		if (y > 60) base = n - 1; // 剪枝（或者数据分治？）
		else { // 这部分直接模拟
			LL t = x >> y & 1ll;
			while (base < n - 1 && (x >> base + 1ll & 1ll) == t)
				{ ++base; if (base > 60) { base = n - 1; break; } }
				// 剪枝（或者数据分治？）
		}
		cout << qPow(2ll, base + 1) - 1ll << "\n";
	}
	return 0;
}
```

---

## 作者：ダ月 (赞：1)

此题解纯靠大眼瞪小眼，会讲述一些思考过程，具体证明可以看官方题解。

看到这题，就先打了个表先。（同时获得 $25$ 分的暴力分。）

```
const int N=1<<15|1;
ll n,T;
ll ans[N][20];
bool vis[N][20];
bool c[N][20];
int dx[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
ll dfs1(ll x,ll y,ll n,ll m){
	ll ans=1;vis[x][y]=true;
	for(int i=0;i<4;i++){
		ll xx=dx[i][0]+x,yy=dx[i][1]+y;
		if(xx<=n&&xx&&yy<=m&&yy&&!vis[xx][yy]&&!(c[x][y]^c[xx][yy])){
			ans+=dfs1(xx,yy,n,m);
		}
	}
	return ans;
}
void dfs2(ll x,ll y,ll n,ll m,ll p){
	ans[x][y]=p;
	for(int i=0;i<4;i++){
		ll xx=dx[i][0]+x,yy=dx[i][1]+y;
		if(xx<=n&&xx&&yy<=m&&yy&&!ans[xx][yy]&&!(c[x][y]^c[xx][yy])){
			dfs2(xx,yy,n,m,p);
		}
	}
}
int main(){
	std::cin>>n>>T;
	for(int i=0;i<(1<<n);i++){
		for(int j=n-1;~j;j--)
			c[i+1][j+1]=(i>>j&1);
	}
	for(int i=1;i<=(1<<n);i++)
		for(int j=1;j<=n;j++)
			if(!vis[i][j])dfs2(i,j,1<<n,n,dfs1(i,j,1<<n,n));
	for(int i=1;i<=(1<<n);i++){
		for(int j=1;j<=n;j++)
			std::cout<<ans[i][j]<<' ';
		std::cout<<'\n';
	}
	return 0;
}

```

这个暴力的思路大概就是通过 dfs 预处理每个位置的答案。

随便按一个 $n=6$，我们会看到以下数：

[输出较多，故塞到剪贴板里](https://www.luogu.com.cn/paste/asc488rx)。

记 $f(x,y)$ 表示这个矩阵中位于 $(x,y)$ 的数，$g(x,y)$ 表示位于第 $(x,y)$ 点的答案，随后就看到了一些性质：

1. 每个位置的答案为 $2^k-1$（$k\in \textbf{Z}$）。

2. 对于第 $x$ 行，在二进制下最高的 $1$ 所在的位置为 $y$，我们会发现 $(x,y)$ 为 $2^{y+1}-1$（注意，$y$ 从 $0$ 开始计数）。

3. 我们**依次从最高位往前推**，我们会发现，如果 $f(x,y-1)=f(x,y)=1$，我们会发现，位于 $g(x,y)=g(x,y-1)$。

4. 我们是否能通过 $3$ 来扩展。注意对于任意 $x,y$，如果 $f(x,y)=f(x,y-1)$，那么 $g(x,y)=g(x,y-1)$。

我们接下来要考虑 $(x,y)$ 与 $(x,y-1)$ 之间的具体关系了。

5. 我们注意到，$g(x,y)\ge 2^{y+1}-1$，等号取到当且仅当 $g(x,y)\ne g(x,y+1)$。

6. 我们注意到，如果 $f(x,y)=f(x,y+1)$，那么 $g(x,y+1)=g(x,y)+2^{y+1}$。

因此，直接做时间复杂度：$O(T \log ^2 n)$。不过要注意特判一些 corner。

```
const int N=1<<15|1;
ll n,T;
void solve(){
	ll x,y;std::cin>>x>>y;
	if(y>=62)return std::cout<<(QP(2,n,mod)-1+mod)%mod<<'\n',void();
	ll ans1=QP(2,y,mod)-1;
	auto dfs=[&](ll x,ll y,auto self)->void{
		ans1+=QP(2,y,mod);ans1%=mod;
		if(y+1<n&&((x>>y&1)^(x>>(y+1)&1)^1))self(x,y+1,self);
	};
	dfs(x,y,dfs);
	std::cout<<(ans1+mod)%mod<<'\n';
}

```


---

## 作者：tiger2008 (赞：1)

这道题非常滴抽象。

### 思路分析

我们可以先枚举一下前面几个数。

```
0000
1000
0100
1100
0010
1010
0110
1110
0001
1001
0101
1101
0011
1011
0111
1111
```

观察可得，每一个 ```1``` 或 ```0``` 的联通块大概都长这样：

```
  1
  1
 11
111
```

也就是类似 $1+2+2^2+ \cdots +2^t$ 的样子。

接着我们可以简化一下 $1+2+2^2+ \cdots +2^t$ 这种式子。

$$s=1+2+2^2+ \cdots +2^t$$

$$2s=2+2^2+2^3+ \cdots +2^{t+1}$$

$$2s-s=(2+2^2+2^3+ \cdots +2^{t+1})-(1+2+2^2+ \cdots +2^t)$$

$$s=2^{t+1}-1$$

$$1+2+2^2+ \cdots +2^t=2^{t+1}-1$$

上面这一段无需解释，我们发现 $2^{t+1}$ 可以用快速幂解决。

接着我们可以开始分类讨论了。

### 当下标为 $(x,y)$ 的格子是 $0$ 时

我们可以举个例子，当第 $x$ 行代表的数是 ```11011``` 时且 $y=2$ 时。

这时候我们可以发现数字 $0$ 所在的四联通块大概长成这样（当然还有可能是对称的）。

```
  0
  0
 00
000
```

这时我们只需要找到 ```11011``` 中 $0$ 所在的位置的下一个 $1$ 的位置就可以解决（这个地方可以用位运算解决）；如果你发现在这个数 $0$ 所在的位置后面没有 $1$ 了，那么它就一定会走到第 $n$ 列，直接输出 $2^n-1$ 即可。

### 当下标为 $(x,y)$ 的格子是 $1$ 时

这里其实你可以发现直接将这个数的每一位取反就和上面的分类一样了。

比如说还是这个例子 ```11011``` 但是 $y=1$ 时。

这时候我们可以发现数字 $1$ 所在的四联通块大概长成这样（当然还有可能是对称的）。

```
11
 1
```

这时候我们需要找到这个 $1$ 所在的位置的下一个 $0$ 的位置减一就可以解决了；如果发现这个 $1$ 的后面没有 $0$ 了，那么它也会走到第 $n$ 列， 直接输出 $2^n-1$ 即可。

------------

然后这道题就完了……吗？

根据题目条件 $n$ 和 $y$ 都会很大很大。

这边需要特判 $y$ 的大小是否要大于 $64$，如果大于 $64$ 的话这个数字必定会走到第 $n$ 列，直接输出 $2^n-1$ 即可。

然后这道题就做完了。

------------

### 代码

考场代码加了点修改。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define int unsigned long long
using namespace std;
const int mod=998244353;
inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		x=x*10+(c-'0');
		c=getchar();
	}
	return x*f;
}
int n,q,x,y;
int lowbit(int x){
	return x&(-x);
}
inline int qpow(int x,int y){
	int ans=1;
	while(y){
		if(y%2==1)ans=ans*x%mod;
		y/=2;
		x=x*x%mod;
	}
	return ans;
}
signed main(){
	cin>>n>>q;
	while(q--){
		x=read();y=read();
		if(y>64){//特判
			cout<<qpow(2,n)-1<<"\n";
			continue;
		}
		y++;
		int tmp=(x>>(y-1))&1;//第x行第y列的数字是什么
		if(tmp==1){//分类讨论1
        //lowbit(((~x)>>(y-1)))代表x取反之后右移y-1次的最小1
        //其实就是找1所在的位置的下一个0的位置啦
			if(lowbit(((~x)>>(y-1)))!=0)cout<<lowbit((~x)>>(y-1))%mod*qpow(2,y-1)%mod-1<<"\n";
			else cout<<qpow(2,n)-1<<"\n";
		}else{//分类讨论2
			if(lowbit((x>>(y-1)))!=0)cout<<lowbit(x>>(y-1))%mod*qpow(2,y-1)%mod-1<<"\n";
			else cout<<qpow(2,n)-1<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：1)

- [原题链接](https://www.luogu.com.cn/problem/P9915)

------------

好题。

首先不难发现题目给出的这个矩阵有着众多性质，但其中绝大部分对解题是无用的。

事实上，有一个很容易被我们忽略的性质却十分有用，即：该矩阵所有四联通块均呈**上三角**或**下三角**型，且从左往右每一列元素个数以 $1,2,4,\dots,2^k$ 的形式增长。

这启示我们，某四联通块大小只与其内部元素的**最大列数**有关。且不难通过观察发现，最大列数为 $c$ 的四联通块，其元素个数为 $2^{c+1}-1$。

而根据四联通块呈**上三角**或**下三角**型的性质，我们不难得出一个做法，对于给定的询问 $(x,y)$，我们暴力往右跳，一直跳到 $(x,y'+1)$ 与 $(x,y)$ 不同为止，此时 $y'$ 即为最大列数。

这样做时间复杂度为 $O(n^2)$。但我们可以注意到，由于 $x \leq 10^{18}$，对于所有询问的行，大于等于 $60$ 列均为 $0$，故 $y$ 跳到 $\geq 60$ 时答案直接就为 $2^n-1$。于是总复杂度为 $O(q \log x)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int n,q,ans[65];
inline int pwr(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1) res=res*x%mod;
		x=x*x%mod;y>>=1;
	}
	return res;
}
signed main()
{
	scanf("%lld%lld",&n,&q);
	ans[60]=(pwr(2,n)+mod-1)%mod;
	for(int i=0,j=2;i<60;i++) ans[i]=(j+mod-1)%mod,j=j*2%mod;
	while(q--)
	{
		int x,y;
		scanf("%lld%lld",&x,&y);
		if(y>=60) printf("%lld\n",ans[60]);
		else
		{
			while(y+1<min(n,60LL)&&(x>>y&1)==((x>>(y+1))&1)) ++y;
			printf("%lld\n",ans[y]);
		}
	}
	return 0;
}
```




---

## 作者：_zuoqingyuan (赞：1)

# 题面：
[这里](https://www.luogu.com.cn/problem/P9915)
# 分析：
暴力用 bfs 跑联通块肯定想不通，由于 $n \le 10^{18},q \le 10^5$，可以考虑 $O(n)$ 或者 $O(n\log n)$ 的做法。

先打表观察一下规律；

当 $n=4$ 时，矩阵是这样的：
```
0 0 0 0 
1 0 0 0 
0 1 0 0 
1 1 0 0 
0 0 1 0 
1 0 1 0 
0 1 1 0 
1 1 1 0 
0 0 0 1 
1 0 0 1 
0 1 0 1 
1 1 0 1 
0 0 1 1 
1 0 1 1 
0 1 1 1 
1 1 1 1 

```
我们会发现，第 $x$ 行其实就是数字 $x$ 的二进制翻转了而已，而且似乎更方便我们后续处理。

截取出其中的一个连通块，观察一下特征。
```
0 0 0 0 
  0 0 0 
    0 0 
    0 0 
      0 
      0 
      0 
      0
```
我们会发现，上面矩阵中所有的联通块都是类似的形状，可以分成 $n$ 列，每列都是 $2$ 的次幂，且是上一列的二倍。这样，我们可以求出一个 $n$ 列联通块的格子的个数为 $\sum\limits_{i=0}^n2^i$，学过一点小学数学的都知道，这式子还可以写成 $2^{n+1}-1$。

那么问题又来了，我们仅知道 $x,y$，怎么知道这个联通块是几列的呢?仔细观察，**不难发现以下结论**：

1. 所有联通块在第 $1$ 列都有一个格子
2. 所有联通块最高列的格子在同一排，且向左能覆盖住这个联通块的剩余格子

由结论 $2$，我们可以不断的向后移动 $y$，得到这个这个联通块最高的列数，又因为结论 $1$，想求出来就很轻松了。

首先，及时 $n \le 10^{18}$，但是 $x \le \min(10^{18},2^n)$。所以求联通块的列数时只用枚举到 $62$ 即可，不会爆 long long，同时也是 $x$ 取值的极限，剩下的也都是 $0$ 了，可以特殊处理。

其次，求 $2^{n+1}$ 时，$n$ 最大 $10^{18}$，要用快速幂，不然时间会炸裂。

# Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
ll n,q,x,y;
const int Mod=998244353;
ll findceil(ll x,ll y,ll f){
    int i;
    if(y>62||(x>>y)==0)return n;//一定要先特判y，不然会TLE
    for(i=y+1;;i++){//找到第一个不属于这个连通块的i
        if(((x>>i)&1)!=f)return i;//这里的i代表返回的列数加一，直接当成幂运算的指数
    }
    return n;
}
ll ksm(ll a,ll b){
	ll p=1;
	while(b){
		if(b&1)p=(a*p)%Mod;
		a=(a*a)%Mod;
		b=b>>1;
	} 
	return p%Mod;
}//快速幂
ll ans(ll t){
    ll num=ksm(2,t);
    return (num-1+Mod)%Mod;
}
int main(){
    scanf("%lld %lld",&n,&q);
    while(q--){
        scanf("%lld %lld",&x,&y);
        bool f=((x>>y)&1);//提取第i位是0是1
        ll t=findceil(x,y,f);//查找最大列
        printf("%lld\n",ans(t));
    }
    return 0;
}
```
## 结语：
$2^n \bmod k=2^{n \bmod k} \bmod k$

打比赛时聪明睿智的我

如有错误，请指出。

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：0)

下面第 $2^x$ 位表示表格中下标位 $x$ 的列。

观察题中给出的表以及自己再推一部分，可以发现一个性质：

对于一个连通块，它包含的所有格子的最低位的权值一定是 $2^0$。假设最高位是 $2^x$，那么这个连通块的大小一定是 $2^{x+1}-1$。

这个也不难证明，首先假设这个连通块所有格子的值都是 $1$（如果是 $0$ 上下翻转即可）。考虑找到这个连通块最靠下的那个数，容易发现它的值也是 $2^{x+1}-1$。之后对于 $2^0\sim 2^x$ 的每一位 $2^i$，这一列最下方恰好 $2^i$ 个连续的数（$2^{x+1}-2^i\sim2^{x+1}-1$）这一位都是 $1$，而再上一个就是 $0$。因此连通块大小就是 $2^0+2^1+...+2^x=2^{x+1}-1$。另外还能够发现这个连通块中所有对应行的第 $2^x$ 位都是 $1$。

根据上面的最后一句话，我们只需要在 $x$ 这一行中找到第 $2^y$ 位的 **一维** 连通块的末尾位置即可。

因为 $x<10^{18}$，所以如果 $y$ 超过 $x$ 的二进制位数就可以直接确定末尾位置是最后一位。

```cpp
ll x,y;
cin>>x>>y;
s="";
while(x){// 直接拆成二进制位
	s+=char(48^(x&1));
	x>>=1;
}
if(s=="")s="0";
ll ed;
if(y>=s.size())ed=n-1;// 末尾是最后一位
else{
	ed=-1;
	for(int i=y+1;i<s.size();i++){
		if(s[i]!=s[i-1]){ed=i-1;break;}
	}
	if(ed<0){// 字符串的最后一个连通块
		if(s[y]=='1')ed=s.size()-1;
		else ed=n-1;
	}
}
ll ans=1,a=2;// 直接快速幂
ed++;
while(ed){
	if(ed&1)ans=ans*a%998244353;
	a=a*a%998244353;
	ed>>=1;
}
(ans+=998244352)%=998244353;
cout<<ans<<"\n";
```

---

## 作者：strcmp (赞：0)

赛时写成构式了。

------------

令 $y \leftarrow n - y - 1$。

不妨找找 $n = 6$ 的规律。

```
0000000000000000000000000000000011111111111111111111111111111111
0000000000000000111111111111111100000000000000001111111111111111
0000000011111111000000001111111100000000111111110000000011111111
0000111100001111000011110000111100001111000011110000111100001111
0011001100110011001100110011001100110011001100110011001100110011
0101010101010101010101010101010101010101010101010101010101010101
```

有几个点可以发现：

1. 联通块的大小必然是类似 $2^k - 1$ 这种东西的。

2. 每个联通块必然包含最下面的一个点（记为第 $n - 1$ 层），一半的联通块包含 $n - 2$ 层的两个点，以此类推。

我们称一行内连续的 `1` 为一个块，连续的 `0` 也为一个块。

我们发现，询问 $y$ 行，$x$ 列。可以 $\Theta(1)$ 算出来这个坐标在当前行的哪一块。

考虑当前联通块是 `0` 联通块的情况，如果是第奇数个块，则可以跳到更低的层次，否则只能待在原地。

考虑如果 $2^{n - y + 1}$ 远大于 $x$，我们显然直接输出 $2^n - 1$。

这样子我们就可以暴力让 $y$ 跳低层次，最多只会跳大概 $60$ 次。

如果当前联通块是 `1` 联通块，则情况恰好相反，是当前行的第偶数个块才能跳到更低层次。

但是我们可以直接不特判暴力跳了，因为你考虑一下坐标根本到不了层次低的 `1` 联通块内。

这样我们就求出来了当前联通块的层次 $w$，答案即为 $2^{n - w} - 1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 1e6 + 10;
const ll mod = 998244353LL;
inline ll ksm(ll a, ll b) {
	ll ls = 1;
	while (b) {
		if (b & 1) ls = ls * a % mod;
		a = a * a % mod; b >>= 1;
	}
	return ls;
}
int main() {
	ll n, q;
	scanf("%lld%lld", &n, &q);
	while (q--) {
		ll x, y, fg = -1;
		scanf("%lld%lld", &x, &y); y = n - y - 1;
		ll w = (1LL << (n - y - 1));
		if (n - y - 1 >= 63) fg = 0;
		else fg = x / (1LL << (n - y - 1)) % 2;
		if (fg == 0) {
			if (n - y - 1 >= 63) { printf("%lld\n", ksm(2, n) - 1); continue; }
			while (1) {
				if (x / (1LL << (n - y)) % 2 == 0 && y >= 1) --y;
				else break;
			}
			printf("%lld\n", ksm(2, n - y) - 1);
		}
		else {
			while (1) {
				if (x / (1LL << (n - y)) % 2 == 1 && y >= 1) --y;
				else break;
			}
			printf("%lld\n", ksm(2, n - y) - 1);
		}
		//printf("%lld\n", ksm(2, y + 1) - 1);

	}
	return 0;
}
```

---

## 作者：zyn_ (赞：0)

# P9915 「RiOI-03」3-2 

## 题目大意

给定 $n$，一个大小为 $2^n\times n$ 的矩阵 $a_{i,j}$，$0\le i\lt 2^n$，$0\le j\lt n$，满足 $a_{i,j}$ 为 $i$ 表示成二进制时表示 $2^j$ 的一位。$q$ 次询问，每次给定 $(x,y)$，求 $a_{x,y}$ 所在的四连通块的大小。

$n\le 10^{18}$，$q\le 5\times 10^5$。

## 题目分析

看看 $n=2$ 时的矩阵：

![](https://cdn.luogu.com.cn/upload/image_hosting/x395thtg.png)

再看看 $n=3$ 时的矩阵：

![](https://cdn.luogu.com.cn/upload/image_hosting/lf4dv7nz.png)

发现其中有两部分与 $n=2$ 的完全一样。不一样的最后一列，为 $4$ 个 $0$，$4$ 个 $1$。

不难推理出，$n=k$ 的矩阵中包含了两个 $n=k-1$ 的矩阵，最后一列为 $2^{k-1}$ 个 $0$，$2^{k-1}$ 个 $1$。

考虑递归计算，设 $f(x,y,n)$ 为 $2^n\times n$ 的矩阵中 $a_{x,y}$ 所在的四连通块的大小。

### 情况一：$y=n-1$

这种情况，可以发现答案为 $2^0+2^1+\dots+2^{n-1}=2^n-1$。

### 情况二：$y\lt n-1$

发现矩阵的上半部分（前 $2^{n-1}$ 行）与下半部分是轴对称的，连通性情况完全一样。所以若 $x\ge 2^{n-1}$，就令 $x=2^n-1-x$。下面就可假设 $a_{x,y}$ 在矩阵上半部分。

尝试递归到 $f(x,y,n-1)$。

若 $a_{x,y}$ 与最后一列的 $0$ 连通，此时 $x,y$ 满足 $x\lt 2^y$。这时，与情况一相同，可以合并。

若不连通，则得 $f(x,y,n)=f(x,y,n-1)$。

直接递归计算，$q$ 次询问，若算 $2^{n-1}$ 时使用快速幂，则时间复杂度为 $O(qn\log n)$。常数小一点就有 $50$ 分。

## $50$ 分代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 998244353
ll qpow(ll a,ll b,ll p){
    ll res=1;
    while(b)(b&1)&&(res=res*a%p),a=a*a%p,b>>=1;
    return res;
}
#define le2(x,y) ((y)>60||(x)<=(1LL<<(y)))
#define lt2(x,y) ((y)>60||(x)<(1LL<<(y)))
ll solve(ll x,ll y,ll n){
    if(!lt2(x,n-1))x=(1LL<<n)-x-1;
    if(lt2(x,y))return qpow(2,n,mod)-1;
    return solve(x,y,n-1)%mod;
}
ll read(){
    static char c=' ';
    static ll r=0;r=0;
    while(c<48||c>57)c=getchar();
    while(c>47&&c<58)r=r*10-48+c,c=getchar();
    return r;
}
ll n,q,x,y,ans;
int main(){
    n=read();q=read();
    while(q--){
        x=read();y=read();
        printf("%lld\n",solve(x,y,n));
    }
    return 0;
}
```

## 优化

发现 $x\lt 10^{18}$，则 $x\ge 2^y$ 的情况只有 $y$ 很小（$y\le 60$）时发生。

尝试快速缩小 $n$。只有 $x\ge 2^{n-1}$ 或 $y\le 60$ 时，代码中的 `solve` 函数可能执行前两个 `if`，其他情况都为直接递归 $f(x,y,n)=f(x,y,n-1)$。

那么直接递归 $f(x,y,n)=f(x,y,\min\{n-1,60\})$ 即可。

时间复杂度 $O(q\log n)$，常数 $60$。

## $100$ 分代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 998244353
ll qpow(ll a,ll b,ll p){
    ll res=1;
    while(b)(b&1)&&(res=res*a%p),a=a*a%p,b>>=1;
    return res;
}
#define le2(x,y) ((y)>60||(x)<=(1LL<<(y)))
#define lt2(x,y) ((y)>60||(x)<(1LL<<(y)))
ll solve(ll x,ll y,ll n){
    if(!lt2(x,n-1))x=(1LL<<n)-x-1;
    if(lt2(x,y))return qpow(2,n,mod)-1;
    return solve(x,y,min(n-1,60LL))%mod;
}
ll read(){
    static char c=' ';
    static ll r=0;r=0;
    while(c<48||c>57)c=getchar();
    while(c>47&&c<58)r=r*10-48+c,c=getchar();
    return r;
}
ll n,q,x,y,ans;
int main(){
    n=read();q=read();
    while(q--){
        x=read();y=read();
        printf("%lld\n",solve(x,y,n));
    }
    return 0;
}
```

---

## 作者：Auto_Accepted (赞：0)

首先有一个瞪眼就看得出的规律：直接把纵坐标一直加，看当前枚举到的点是不是和 $(x,y)$ 所代表的数一样。如果不一样，就退出循环，否则继续枚举。

然后假设我们枚举到的点是 $(x,cnt)$，那么答案就是 $2^{cnt+1}-1$，因为不难发现每个连通块都是能到最左边的。

然后直接暴力找是不可取的，考虑在 $x$ 上动手脚。

不难发现这一行的数化成十进制是最后的那个数减去 $x$，所以我们直接把 $x$ 二进制分解，分解的那一位为 $1$ 那么实际上就为 $0$。

于是把 $0$ 出现的位置记录一下，然后分类讨论下就做完了。

时间复杂度 $O(q \log n)$。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mod 998244353
int n , q , x , y;
inline int ksm(int a , int b){
    int ans = 1;
    a %= mod;
    while(b){
    	if(b & 1) (ans *= a) %= mod;
    	(a *= a) %= mod;
    	b >>= 1;
	}
	return ans;
}
inline void solve(){
    cin >> x >> y;
    int tmp = x , now = 1 , cnt = 0;
    vector <int> pos;
    while(tmp){
        if(tmp & 1){
            pos.push_back(cnt);
            if(cnt == y) now = 0;
        }
        tmp /= 2;
        cnt++;
    }
    int added = 0;
    int id = lower_bound(pos.begin() , pos.end() , y) - pos.begin();
    if(id != pos.size()) if(now == 1) added = pos[id] - y - 1;else while(id < pos.size() - 1 && pos[id + 1] == pos[id] + 1) id++ , added++;
    else if(now == 1) added = n - y - 1;
    y += added + 1;
    int ans = ksm(2 , y);
    (ans += mod - 1) %= mod;
    cout << ans << '\n';
}
signed main(){
    cin >> n >> q;
    while(q--) solve();
}
```

---


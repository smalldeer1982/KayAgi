# [GESP202403 八级] 接竹竿

## 题目描述

小杨同学想用卡牌玩一种叫做“接竹竿”的游戏。

游戏规则是：每张牌上有一个点数 $v$，将给定的牌依次放入一列牌的末端。若放入之前这列牌中已有与这张牌点数相
同的牌，则小杨同学会将这张牌和点数相同的牌之间的所有牌全部取出队列（包括这两张牌本身）。

小杨同学现在有一个长度为 $n$ 的卡牌序列 $A$，其中每张牌的点数为 $A_i$（$1\le i\le n$）。小杨同学有 $q$ 次询问。第 $i$ 次（$1\le i\le q$）询问时，小杨同学会给出 $l_i,r_i$ 小杨同学想知道如果用下标在 $[l_i,r_i]$ 的所有卡牌按照下标顺序玩“接竹竿”的游戏，最后队列中剩余的牌数。

## 说明/提示

**样例解释**

对于第一次询问，小杨同学会按照 $1,2,2$ 的顺序放置卡牌，在放置最后一张卡牌时，两张点数为 $2$ 的卡牌会被收走，因此最后队列中只剩余一张点数为 $1$ 的卡牌。

对于第二次询问，队列变化情况为：

$\{\}\to\{1\}\to\{1,2\}\to\{1,2,2\}\to\{1\}\to\{1,3\}\to\{1,3,1\}\to\{\}\to\{3\}$。因此最后队列中只剩余一张点数为 $3$ 的卡牌。

**数据范围**

|子任务|分数|$T$|$n$|$q$|$\max A_i$|特殊条件| 
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|$1$|$30$|$\le 5$|$\le100$|$\le100$|$\le13$|
|$2$|$30$|$\le 5$|$\le 1.5\times10^4$|$\le 1.5\times10^4$|$\le13$|所有询问的右端点等于 $n$
|$3$|$40$|$\le 5$|$\le 1.5\times10^4$|$\le 1.5\times10^4$|$\le13$|

对于全部数据，保证有 $1\le T\le 5$，$1\le n\le 1.5\times 10^4$，$1\le q\le 1.5\times 10^4$，$1\le A_i\le 13$。

## 样例 #1

### 输入

```
1
6
1 2 2 3 1 3
4
1 3
1 6
1 5
5 6
```

### 输出

```
1
1
0
2```

# 题解

## 作者：hgckythgcfhk (赞：42)

来自搬题人的题解。

形式化题意：定义一个序列的权值为，维护一个栈，使得每次从序列中取一个元素，如果这个元素在栈中，弹栈弹到这个元素不在栈中为止，否则加入这个栈，最后栈中的元素个数，现在给定一个序列，多次询问这个序列一个子段的权值。

这个形式化题意并没有比题面简化多少，但已经把暴力的写法说清楚了，现在考虑优化，观察下面这个序列：

```
11 1 2 3 4 5 6 7 8 9 10 1 12
```

发现两个 $1$ 之间的元素没有贡献，直接跳过即可，这启示我们可以用链表维护下一个和这个元素相等的元素来跳过元素，每次如果能跳，就跳到下一个当前元素的下一个位置，然后假装什么也没发生过，否则答案加一。

这样时间复杂度是不对的，我们改变一下对 $nxt$ 的定义，定义 $nxt_{i,j}$ 为从 $i$ 起进行 $2^j$ 次操作后的位置，这样时间复杂度就能优化到 $O(V\log n)$。

有人可能会问，为什么不直接跳到最后一个，我跳到最后一个赛时过了，来，我给你看组 hack。

```
1 
8
1 2 3 1 2 3 1 2
1
1 8
```

手动模拟一下，答案为 $0$，但是跳到最后一个的话，我们会把前 $7$ 个全都弹掉，导致最后一个弹不掉，使得输出 $1$，但官方数据没卡这一点，我直接跳到最后一个过了，事实上，我赛时闲的无聊的时候用了不少自己就 hack 掉的错误做法能过掉官方数据，比如上面那个直接只跳一次的做法，不过大家放心，虽然我造的数据比较随机，但绝对强于官方数据。

这是官方的 std。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+10;
int a[N];
int nxt[N][30],pos[20];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		memset(pos,0,sizeof pos);
		for(int i=1;i<=n;i++){
			cin>>a[i];
			for(int j=0;j<=20;j++)nxt[i][j]=n+1;
		}
		for(int i=n;i>=1;i--){
			if(!pos[a[i]]){
				nxt[a[i]][0]=n+1;
				pos[a[i]]=i;
			}else{
				nxt[i][0]=pos[a[i]];
				pos[a[i]]=i;
			}
		}
		for(int i=n;i>=1;i--){
			for(int j=1;j<=20;j++){
				if(nxt[i][j-1]+1<=n)
					nxt[i][j]=nxt[nxt[i][j-1]+1][j-1];
				}
		}
		int q;
		cin>>q;
		while(q--){
			int l,r;
			cin>>l>>r;
			int ii=l;
			int ans=0;
			while(ii<=r){
				while(ii<=r&&nxt[ii][0]>r){
					ii++;
					ans++;
				}
				if(ii>r)break;
				for(int j=20;j>=0;j--){
					if(nxt[ii][j]<=r){
						ii=nxt[ii][j];
						break;
					}
				}
				ii++;
			}
			cout<<ans<<"\n";
		}
	}
}
```
注意，官方的 std 中第20行应为 ```nxt[i][0]=n+1;``` ，而不是 ```nxt[a[i]][0]=n+1;```。

当然，也可以直接把这一行删掉，具体见[这个帖子](https://www.luogu.com.cn/discuss/838945)。

感谢 @sapo1o 指出问题和 @sbh2012 提供的 hack。请大家不要盲目相信官方的 std，从这个细节可以看出，官方在写这份程序的时候思路很乱，理由是前面已完成了初始化，所以这行程序没有任何作用。

不过，由于较大且相对比较随机，经测试，保证正确的程序可以通过，可以证明，这个错误在大的随即数据下几乎不可能出错，所以目前未造成影响，不过这也是一件比较可怕的事情，CCF 的官方数据也是这份 std 造的，我没有修改任何一个字符，所以官方数据的正确性和这次 GESP 的成绩值得怀疑，作为 CCF 举办的官方比赛，我认为这件事情的影响重大且极其恶劣，望周知！

---

## 作者：wrh316 (赞：35)

### 备注：因为加强数据后我的题解不能通过，所以优化后重新提交审核。
这道题类似滑动窗口。

思路：初始化 $f _ {x}$ 和 $r _ {f _ {x}}$ 数组为 $i$，$q$ 次查询，每次遍历 $x$ 至 $y$，如果 $r _{i}$ 不在 $x$ 至 $y$ 范围内，计数器 $ans \gets ans+1$，否则跳到 $r _ {i}$。

上代码：
```
#include <bits/stdc++.h>
#define int register unsigned
using namespace std;
//define 是二重优化
unsigned t,n,q;
signed main(){
	//第一优化
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		int f[15] = {0},r[150005] = {0};//r[i]表示第i个元素在其后第一次出现的位置，f[i]表示第i个元素当前出现的位置
		for(int i = 1,x;i <= n;i++){
			cin>>x;
			r[f[x]] = i;
			f[x] = i;
		}
		cin>>q;
		while(q--){
			int x,y;
			cin>>x>>y;
			int ans = 0;
			for(int i = x;i <= y;i++){
				if(r[i] < x || r[i] > y) ans++;//不在范围内
				else i = r[i]; //快速地跳
			}
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：喵仔牛奶 (赞：22)

来发不依赖值域的做法。

# Solution

设 $[l,r]$ 区间从左到右消除的答案为 $f_{l,r}$，在 $i$ 之后第一个与 $a_i$ 相等的位置为 $p_i$，则有显然转移:
$$f_{l,r}=\begin{cases}
  0 & r<l \\
  f_{l+1,r}+1 & r\in[l,p_l-1] \\
  f_{p_l+1,r} & r\geq p_l
\end{cases}$$

直接做是 $\mathcal{O}(n^2)$ 的，无法通过。

观察性质。发现对于 $f_{l}$ 这个序列，三种转移情况各占一段区间，而且 $f_{l,r}$ 一定从一个 $x$ 的 $f_{x,r}$ 转移来。

也就是说，转移可以简化成如下操作：
- 将 $f_0$ 的 $[1,l-1]$ 赋值到 $f_{l}$ 的对应位置。
- 将 $f_{l+1}$ 的 $[l,p_l-1]$ 赋值到 $f_{l}$ 的对应位置。
- 将 $f_{p_l+1}$ 的 $[p_l,n]$ 赋值到 $f_{l}$ 的对应位置。
- 将 $f_{l}$ 的 $[l,p_l-1]$ 区间加 $1$。

操作可以使用可持久化线段树完成，时空复杂度 $\mathcal{O}((n+q)\log n)$。

# Code
```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 3e5 + 5;
	int n, q, l, r, cnt, a[N], nxt[N], head[N], T[N], Ls[N << 6], Rs[N << 6]; LL add[N << 6];
	int merge(int p, int q, int l, int r, int nl, int nr, int tl, int tr, int sp, int sq) {
		if (r < nl) return 0;
    	int rt = ++ cnt, mid = (l + r) >> 1; add[rt] = 0;
    	if (nl <= l && r <= nr) { Ls[rt] = Ls[p], Rs[rt] = Rs[p], add[rt] = sp + add[p]; return rt; }
		if (tl <= l && r <= tr) { Ls[rt] = Ls[q], Rs[rt] = Rs[q], add[rt] = sq + add[q]; return rt; }
		Ls[rt] = merge(Ls[p], Ls[q], l, mid, nl, nr, tl, tr, sp + add[p], sq + add[q]);
		Rs[rt] = merge(Rs[p], Rs[q], mid + 1, r, nl, nr, tl, tr, sp + add[p], sq + add[q]);
		return rt;
	}
	LL ask(int p, int l, int r, int t) {
		int mid = (l + r) >> 1;
		if (l == r) return add[p];
		if (t <= mid) return ask(Ls[p], l, mid, t) + add[p];
		if (t > mid) return ask(Rs[p], mid + 1, r, t) + add[p];
	}
	int build(int l, int r) {
		int rt = ++ cnt, mid = (l + r) >> 1; add[rt] = 0;
		if (l < r) Ls[rt] = build(l, mid), Rs[rt] = build(mid + 1, r);
		return rt;
	}
	int main() {
		cin >> n;
		REP(i, 1, n) cin >> a[i];
		cin >> q;
		DEP(i, n, 1) nxt[i] = head[a[i]], head[a[i]] = i;
		T[n + 1] = build(1, n);
		DEP(i, n, 1) {
			if (nxt[i]) T[i] = merge(T[i + 1], T[nxt[i] + 1], 1, n, i, nxt[i] - 1, nxt[i], n, 1, 0);
			else T[i] = merge(T[i + 1], 0, 1, n, i, n, 0, 0, 1, 0);
		}
		REP(i, 1, q) {
			cin >> l >> r;
			cout << ask(T[l], 1, n, r) << '\n';
		}
		REP(i, 1, max(n, 13)) nxt[i] = head[i] = 0;
		return 0;
	} 
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int T = 1; cin >> T;
	while (T --) Milkcat::main();
	return 0;
}
```

---

## 作者：Milthm (赞：11)

挺巧妙的题，思维不好的话要想很久（比如我）。

____

拿到题，发现是自己熟悉的游戏。一下子就想到一个暴力做法：预处理每个位置的下一个与它点数相同的位置（记为 $nxt_i$），查询的时候遍历 $l\sim r$，如果这个点 $i$ 的 $nxt_i\le r$，则答案和 $i$ 加一，否则将 $i$ 跳到 $nxt_i+1$。

这样做的话时间复杂度是 $O(Tqn)$，原因在于往后跳 $nxt$ 的操作有可能退化成一个一个跳，所以我们需要进行优化。

通过数据范围猜算法，我们发现了正解大概是个 $O(Tq\log n)$ 的做法。于是我想了想我学过的算法和数据结构，终于找到了可以解决本题的——ST 表。

运用 ST 表的思想，我们设 $nxt_{i,j}$ 表示 $i$ 号节点往后第 $2^j$ 个与它点数相同的位置，显然有转移方程 $nxt_{i,j}=nxt_{nxt_{i,j-1}+1,j-1}$。每次询问 $l,r$ 时，我们每次跳一个最大的 $j$，满足 $nxt_{i,j}\le r$，直接跳到 $nxt_{i,j}+1$。如果跳不了的就和刚才一样记录答案。

这时候跳 $nxt$ 的复杂度保证了，但是记录答案的复杂度保证了吗？答案是显然的，因为每循环一次答案就会加一，而由题目可得，答案最多为 $13$，所以根本不会超时。

这样这个算法就以 $O(Tq\log n)$ 的复杂度通过了本题。

### AC code

```cpp
#include<bits/stdc++.h>
#define N 15005
using namespace std;
int T,n,q,a[N],st[N][25],qwq[N]; 
int read(){
	int ans=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))ans=ans*10+c-'0',c=getchar();
	return ans; 
}
int main(){
	T=read();
	while(T--){
		n=read();
		for(int i=1;i<=n;++i){
			a[i]=read(),qwq[i]=0;
			for(int j=0;j<=20;++j)st[i][j]=n+1;
		}
		for(int i=n;i>=1;--i){
			if(!qwq[a[i]])st[i][0]=n+1; 
			else st[i][0]=qwq[a[i]];
			qwq[a[i]]=i;
		}
		for(int i=n;i>=1;--i){
			for(int j=1;j<=20;++j){
				if(st[i][j-1]+1<=n)st[i][j]=st[st[i][j-1]+1][j-1];
			}
		}
		q=read();
		while(q--){
			int l=read(),r=read(),k=l,ans=0;
			while(k<=r){
				while(k<=r&&st[k][0]>r)++ans,++k;
				if(k>r)break;
				for(int i=20;i>=0;--i){
					if(st[k][i]<=r){
						k=st[k][i]+1;break;
					}
				}
			}
			cout<<ans<<'\n';
		}
	} 
	return 0;
}

```

---

## 作者：T_TLucas_Yin (赞：11)

注意到数据不是很大，所以可以用一种简单的方法过。

我们存下每一个 $A_i$ 后第一个与它相等的元素的位置。对于每一次询问，我们从询问的左端点开始遍历，如果遇到一个在此区间内出现两次的元素，就跳到它第二次出现的位置上，并不计数；否则按顺序往后遍历，并按位计数。最后输出结果即可。

由于 $A_i\le13$，所以根据抽屉原理，最多每 $13$ 个位置就会有一个重复的元素，所以这样时间不会被卡。如果一组数据像这样：

```
15000
1 1 2 2 1 1 2 2 1 1 ...
15000
1 15000
1 15000
...
```

此时每次询问平均就需要遍历 $\frac n2$ 次，在数据范围下 $q$ 次询问的总时间刚到 $10^8$。

为了避免超时，考虑进行优化：存储下每个区间的答案，对于重复的询问直接输出，这样就避免全程搜索整个序列的时间浪费，让极限情况下的总查询次数不超过 $\frac {n^2} 2$，从而让时间降到 $10^8$ 以下，配合 O2 优化，可以通过本题。

```cpp
#include<bits/stdc++.h>
using namespace std;
map<pair<int,int>,int> ma;
int t,n,m,l,r,a[20005],f[100005];
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		int flag[15]={0};
		for(int i=n;i>=1;i--) f[i]=flag[a[i]],flag[a[i]]=i;//f[i]表示第i个元素在其后第一次出现的位置 
		scanf("%d",&m);
		ma.clear();
		for(int i=1;i<=m;i++){
			scanf("%d %d",&l,&r);
			int cnt=0;
			if(ma.count({l,r})){//这里存储的是上一次在序列中查询此区间的结果 
				printf("%d\n",ma[{l,r}]);
				continue;
			}
			for(int j=l;j<=r;j++){
				if(f[j]>=l&&f[j]<=r) j=f[j];
				else cnt++;
			}
			ma[{l,r}]=cnt;
			printf("%d\n",cnt);
		}
	}
	return 0;
}
```

---

## 作者：Y_zhao111 (赞：10)

upd: 官方 std 有误，现已修改。

### Description
题目传送门：[P10264 [GESP202403 八级] 接竹竿](/problem/p10264)

思维题，考虑倍增。

### Analysis
+ $30\%$ 模拟，$1\le a_i\le13$，根据题意，队列中不会存在两个相同的点数，所以队列的最大长度为 $13$，对于每一个 $(l,r)$，模拟加队列的过程，每添加一个牌从队列头开始查找有无相同的点数，如有则从队列中删除所有后续的元素。复杂度为 $O(T\times q\times N\times13)$。
+ $100\%$ 倍增，一共 $13$ 个点数，由题意，从自身出发，到下一个相同点数，这样的整段都可以被取走。每个点都可以维护下一个相同点数的位置。\
**但是这样的跳跃速度还是太慢了**，通过倍增来加速。$nxt_{i,j}$ 表示从 $i$ 出发的，第 $2\land j$ 个段的结尾位置。可知 $nxt_{i,j+1} = nxt_{nxt{_i,_j}+1,j}$。\
复杂度 $O(T\times q\times \log N)$。

### Code
```cpp
//Reprinted from gesp.ccf.org
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5 + 10;
int a[N];
int nxt[N][30], pos[20];
int main() {
	int t;
	cin >> t;
	while (t--) {
		int n;
		cin >> n;
		memset(pos, 0, sizeof pos);

		for (int i = 1; i <= n; i++) {
			cin >> a[i];
			for (int j = 0; j <= 20; j++)nxt[i][j] = n + 1;
		}
		for (int i = n; i >= 1; i--) {
			if (!pos[a[i]]) {
				nxt[i][0] = n + 1;
				pos[a[i]] = i;
			} else {
				nxt[i][0] = pos[a[i]];
				pos[a[i]] = i;
			}
		}
		for (int i = n; i >= 1; i--) {
			for (int j = 1; j <= 20; j++) {
				if (nxt[i][j - 1] + 1 <= n)
					nxt[i][j] = nxt[nxt[i][j - 1] + 1][j - 1];
			}
		}
		int q;
		cin >> q;
		while (q--) {
			int l, r;
			cin >> l >> r;
			int ii = l;
			int ans = 0;
			while (ii <= r) {
				while (ii <= r && nxt[ii][0] > r) {
					ii++;
					ans++;
				}
				if (ii > r)break;
				for (int j = 20; j >= 0; j--) {
					if (nxt[ii][j] <= r) {
						ii = nxt[ii][j];
						break;
					}
				}
				ii++;
			}
			cout << ans << "\n";
		}
	}
}
```

---

## 作者：Alystkia (赞：5)

- **先放一个前置知识 [倍增算法LCA](https://zhuanlan.zhihu.com/p/122413160)**

------------
题意很简单，就是给出一串数字，再给出几段区间 $r_{i},l_{i}$，从 $r_{i}$ 开始，每次从序列中取出一个元素，如果这个元素之前出现过，就将它上次出现到这次出现之间的所有数删掉，直到 $l_{i}$，最后输出剩余元素个数。

这道题可以使用 LCA，重点就是 LCA 去跳。

$1$ 步、$2$ 步、$4$ 步、$8$ 步…………

然后通过这些二进制的组合快速达到终点，把 $\mathcal{O}(N)$ 的模拟变成 $\mathcal{O}(\log N)$ 的。

```
#include <algorithm>
#include <iostream>
#include <map>
using namespace std;
const int MAXN=2e4+8;
const int MAXPWR=16;
int n,q;
int a[MAXN],nxt[MAXN][MAXPWR];
/*next数组的第二个参数pwr就是步数是2的多少次方*/
map<int,int>pos;
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        pos.clear();
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i];
            nxt[i][0]=n+1;
            nxt[pos[a[i]]][0]=i;
            pos[a[i]]=i;
        }
        int pwr=1, flag=1;
        while(flag)
        {
            flag=0;
            nxt[n+1][pwr-1]=n+1;
            for(int i=1;i<=n;i++)
            {
                if(nxt[i][pwr-1]==n+1)
                    nxt[i][pwr]=n+1;
                else
                    nxt[i][pwr]=nxt[nxt[i][pwr-1]+1][pwr-1];
                flag+=(nxt[i][pwr]!=n+1);
            }
            pwr++;
        }
        cin>>q;
        while(q--)
        {
            int l,r,cnt=0;
            cin>>l>>r;
            while(l<=r)
            {
                int idx=lower_bound(nxt[l],nxt[l]+pwr,r+1)-nxt[l];
                if(idx==0)
                    cnt++,l++;
                else
                    l=nxt[l][idx-1]+1;
            }
            cout<<cnt<<endl;
        }
    }
    return 0;
}
```

---

## 作者：MnZnOIer (赞：5)

第一印象：模拟。

于是，30 分到手。

按题意模拟即可，就不贴代码了。

于是我们思考优化方案：
- 我们不需要实际的去消除，我们只要**跳过需要消除的部分**即可。

于是我们使用并查集的思路，用 $f_i$ 记录下一个相邻的相同数字的下标。

如果当前 $f_i$ 在 $l$ 到 $r$ 之间，就跳过去。如果 $f_i$ 不在 $l\to r$ 之间或者没有下一个相邻的数字，就直接加加一。

模拟一下样例确定思路的可行性。

所有 $f_i$ 为：$5,3,0,6,0,0$。

对于第一次询问，$1$ 的下一个相同数字超出了 $r$，所以直接加一。$2$ 的下一个相同数字在 $r$ 之内，直接跳到 $2$ 的下一个数字，循环结束。所以答案为 $1$。

对于第二次询问，$1$ 的下一个相同数字在 $r$ 之内，直接跳到第 $5$ 个数。最后一个 $3$ 没有下一个相同数字，直接加一，循环结束。所以答案也为 $1$。

对于第三次询问，$1$ 的下一个相同数字在末尾，直接结束，答案为 $0$。

对于第四次询问，$1$ 和 $3$ 都没有下一个相同数字了，所以答案为 $2$。

通过对样例的模拟，我们基本可以确定这个思路是可行的。

综上，写出代码，下面出示主干部分。
```cpp
统计 f[i] 的部分。
for (int i = 1; i <= n; ++ i)
{
	cin >> a[i];
	if (v[a[i]])f[v[a[i]]] = i, v[a[i]] = i;
	else v[a[i]] = i;
}
统计答案的部分。
for (int i = l; i <= r; ++ i)
{
	if (f[i] == 0 || f[i] > r)++ c;
	else i = f[i];
}
```

---

## 作者：AK_400 (赞：3)

# [Luogu P10264](https://www.luogu.com.cn/problem/P10264)题解

## 题意

有 $T$ 组数据，每组数据给你一个长度为 $n$ 的序列 $A$，有 $q$ 次询问，每次询问告诉你两个整数 $l$，$r$，表示依次插入 $A_i(i\in [l,r])$，当存在 $A_j=A_i$ 且 $j\in [l,i)$ 时，删除 $A_k(k\in [j,i])$。问你最后剩几个元素。

## 题解

 我们发现要删除的区间的交集一定为空，于是我们直接从左往右扫，遇到可删除的直接跳过。

 但是好像还是太慢了怎么办？我们可以将连续的区间一并跳过。怎么跳呢？倍增。我们记 $nxt_{i,j}$ 为从 $i$ 开始 $2^j$ 段区间的末尾。

显然，
$$
nxt_{i,j}=nxt_{nxt_{i,j-1}+1,j-1}
$$

 于是每扫到一个，就跳到 $nxt_{i,\max_{j|nxt_{i,j}\le r)}}$，若无法往后跳，说明这个删不掉，于是将答案加一。

 根据数据范围，只会有最多 $13$ 个删不掉，所以 $O(T(q\log n+ans))$ 是可过的。
 
## Code

```cpp
    #include<bits/stdc++.h>
    #define int long long
    using namespace std;
    int t,n,a[20005],q,l,r,nxt[20005][25],p[20005];
    signed main(){
        // freopen("slpjbh.in","r",stdin);
        // freopen("slpjbh.out","w",stdout);
        cin>>t;
        while(t--){
            cin>>n;
            for(int i=1;i<=n;i++){
                cin>>a[i];
                p[i]=0;
                for(int j=0;j<=20;j++){
                    nxt[i][j]=n+1;
                }
            }
            for(int i=n;i>=1;i--){
                if(!p[a[i]]){
                    p[a[i]]=i;
                }
                else {
                    nxt[i][0]=p[a[i]];
                    p[a[i]]=i;
                }
            }
            for(int i=1;i<=20;i++){
                for(int j=1;j<=n;j++){
                    if(nxt[j][i-1]+1<=n)
                    nxt[j][i]=nxt[nxt[j][i-1]+1][i-1];
                }
            }
            cin>>q;
            while(q--){
                cin>>l>>r;
                int now=l,ans=0;
                while(now<=r){
                    while(now<=r&&nxt[now][0]>r){
                        now++;
                        ans++;
                    }
                    if(now>r)break;
                    for(int i=20;i>=0;i--){
                        if(nxt[now][i]<=r){
                            now=nxt[now][i];
                            break;
                        }
                    }
                    now++;
                }
                cout<<ans<<endl;
            }
        }
        return 0;
    }
```

---


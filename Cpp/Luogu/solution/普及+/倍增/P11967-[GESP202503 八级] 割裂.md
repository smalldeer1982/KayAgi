# [GESP202503 八级] 割裂

## 题目描述


小杨有一棵包含 $ n $ 个节点的树，其中节点的编号从 1 到 $ n $。

小杨设置了一个好点对 $\{\langle u_1, v_1 \rangle, \langle u_2, v_2 \rangle, \dots, \langle u_a, v_a \rangle\}$ 和一个坏点对 $\langle b_u, b_v \rangle$。一个节点能被删除，当且仅当：

- 删除该节点后对于所有的 $ 1 \leq i \leq a $，好点对 $ u_i $ 和 $ v_i $ 仍然连通；
- 删除该节点后坏点对 $ b_u $ 和 $ b_v $ 不连通。

如果点对中的任意一个节点被删除，其视为不连通。

小杨想知道，还有多少个节点能被删除。


## 说明/提示


| 子任务编号 | 分值 | $ n $ | $ a $ |
|:-:|:-:|:-:|:-:|
| 1          | $20$  | $=10$     | $=0$      |
| 2          | $20$  | $ \leq 100 $ | $ \leq 100 $ |
| 3          | $60$  | $ \leq 10^6 $ | $ \leq 10^5 $ |

对于全部数据，保证有 $ 1 \leq n \leq 10^6 $, $ 0 \leq a \leq 10^5 $, $ u_i \neq v_i $, $ b_u \neq b_v $。





## 样例 #1

### 输入

```
6 2
1 3
1 5
3 6
3 2
5 4
5 4
5 3
2 6```

### 输出

```
2```

# 题解

## 作者：Bh_hurter (赞：9)

# P11967题解
[题目传送门](https://www.luogu.com.cn/problem/P11967)
#### 题外话
关于本蒟蒻没学过最近公共祖先这个知识点但在考场悟破天机，自己弄出来了求最近公共祖先的代码......
### 题意解析
我们手里会有一棵二叉树（**注意我们一开始是不知道根节点的**），然后要找这样的一些点，将他们**其中任意一个**从树上删除后都能保证：  
- 删除之后能保证题目给出的所有好点对**依然互相联通**。  
- 删除之后那一个坏点对**必然不联通**。

答案就是这些点的个数。
### 题目分析与解决
由于题目没有给出明确的根节点，所以我们可以自己**设出来根节点**，但要注意这个根节点编号**不能太大**，避免其在本题数据量较小的测试点中根本不存在。  
下图是作者将 $1$ 号点设为根节点时，题目所给样例的图示。

![](https://cdn.luogu.com.cn/upload/image_hosting/a8gv2l6i.png)

很显然，若想保证 $5$ 与 $4$ ， $5$ 与 $3$ 联通，节点 $1$ ， $3$ ， $4$ ， $5$ 都不能删。  
而要使点 $2$ ， $6$ 不联通，可以删的只有 $2$ ， $6$ $3$ 。  
综上，能删的只有 $2$ ， $6$ 。  

通过上述分析，能发现想要两个点联通，便是能从一个点走到另外一个点。又由于本题给出的图只是二叉树，于是从一个点走到另外一个点的路径只有一条： **从一个点走到两个点的最近公共祖先，然后从最近公共祖先走到另一个点** ！  

为了保证好点对互相联通，我们只需找到每个点对的最近公共祖先，把**一个点到最近公共祖先，从最近公共祖先到另一个点**沿路的点全部打上一层标记 $vis_1$ ，意思是这些点绝对不能删。（**包括好点对那俩点！**）   
然后把坏点对的联通路径找出来，也打上标记 $vis_2$ 。  

符合题目要求的点，就是 $vis_1=0$  且 $vis_2=1$ 的点。  
### 代码解决
- 最近公共祖先如何找？以下是一种思路。    

1. 找出第一个点的所有祖先。一层一层往上找时一边做好标记。
2. 找另一个点的所有祖先，当第一次发现这个祖先被标记过时，这便是最近公共祖先了。  
3. 时间复杂度 $O(\log{n})$ 。   

- 整体代码时间复杂度 $O(a\log{n})$ ，可以通过本题。    

~~稍等，身为初三学子的作者尽快补上符合上述思路的代码，求管理员大大给鄙题解留个位置！~~

---

## 作者：shuqiang (赞：8)

~~八级最简单的一次考试。~~

![](https://cdn.luogu.com.cn/upload/image_hosting/96rxj09l.png)

我们来看这棵树，假设好点对是 $(4,6)$，那么删除其中 $4,2,1,3,6$ 都不符合题意，观察这个结果，发现这个其实就是这棵树上的路径。

但是，这题最多有 $10^5$ 个点对，一个一个枚举肯定是不行的，其实这里只需要统计每一个点有没有被一个好点对的路径经过，考虑用树上差分，假设我们要加入好点对 $(4,5)$，那么我们在点 $4,5$ 标记加 $1$，然后此时 $2$ 实际被统计了两次，所以标记 $2$ 减 $1$，然后 $2$ 上面是没有被经过的，所以令 $2$ 的父亲节点减 $1$。

此时标记如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tx7n9tsc.png)

标记完了后我们就统计每个子树内的节点和，最终就变成这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/t05t439u.png)

这样，每个点对只作 $4$ 次标记，总时间复杂度 $\mathcal{O}(n \log n+a)$。


```cpp
#include<iostream>
#include<vector>

using namespace std;

const int N = 1e6 + 10;
int n, q, u, v, a[N], fa[N][20], dep[N], cnt;
vector<int> g[N];

void dfs(int u, int f){
	fa[u][0] = f;
	dep[u] = dep[f] + 1;
	for(int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];
	for(int v: g[u]){
		if(v == f) continue;
		dfs(v, u);
	}
}

int lca(int u, int v){
	if(dep[u] < dep[v]) swap(u, v);
	for(int i = 19; i >= 0; i--){
		if((dep[u] - dep[v]) & (1 << i)) u = fa[u][i];
	}
	if(u == v) return u;
	for(int i = 19; i >= 0; i--){
		if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
	}
	return fa[u][0];
}

void get_ans(int u, int f){
	for(int v: g[u]){
		if(v == f) continue;
		get_ans(v, u);
		a[u] += a[v];
	}
}

int main(){
	cin >> n >> q;
	for(int i = 1; i < n; i++){
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	while(q--){
		cin >> u >> v;
		int w = lca(u, v);
		a[u]++; a[v]++;
		a[w]--; a[fa[w][0]]--;
	}
	get_ans(1, 0);
	cin >> u >> v;
	int w = lca(u, v);
	while(u != w){
		if(a[u] == 0) cnt++;
		u = fa[u][0];
	}
	while(v != w){
		if(a[v] == 0) cnt++;
		v = fa[v][0];
	}
	if(a[u] == 0) cnt++;
	cout << cnt;
	return 0;
}

```

---

## 作者：lzy120406 (赞：7)

## [前置芝士](https://www.luogu.com.cn/problem/P3384)
大家好，我喜欢巨型数据结构，所以我用树链剖分过了这道题。

## 思路
题目意思大概是有 $a$ 组好点对 $(u_i,v_i)$，还有一组坏点对 $(b_u,b_v)$，要求在树上找一些节点，使得删除其中的任何一个点都能使 $(u_i,v_i)$ 仍然联通，而 $(b_u,b_v)$ 不连通。

首先，想想使得 $a$ 组好点对 $(u_i,v_i)$ 保持联通的条件是什么。容易想到，因为树上两点之间路径唯一，所以满足条件的点就是**不在其中任何一组点对之间的路径上的点**。

而相应的，使得坏点对 $(b_u,b_v)$ 不连通的点就是**在这组点对之间的路径上的点**，求个交集即可。

现在，问题变成了如何快速维护树上路径。

想到了什么？

### **树链剖分！！！**

板子套上去即可。

本人比较懒，维护单点权值用的路径和，神犇们勿喷。。。

具体细节看代码。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db(s,a) cout << s << ":" << a << endl
#define dbarr(a,n) for(ll i=1;i<=n;i++) cout << a[i] << " " ; cout << endl ;
#define isok cout << "ok" << endl
#define ls p << 1
#define rs (p << 1)|1
using namespace std ;
const ll MAXN = 1000005 ;
ll n , m , u , v , tot , ans , i , a[MAXN] , fa[MAXN] , wc[MAXN] , sz[MAXN] , top[MAXN] , dfn[MAXN] , rdfn[MAXN] , dep[MAXN] , d[MAXN << 2] , lzy[MAXN << 2] ;
vector<ll> e[MAXN] ;
bool vis[MAXN] ;
void dfs1(ll u , ll f){
	fa[u] = f ;
	sz[u] = 1 ;
	dep[u] = dep[f]+1 ;
	for(auto &&v : e[u]){
		if(v!=f){
			dfs1(v,u) ;
			sz[u] += sz[v] ;
			if(sz[v]>sz[wc[u]]){
				wc[u] = v ;
			}
		}
	}
}
void dfs2(ll u , ll tp){
	dfn[u] = ++tot ;
	rdfn[tot] = u ;
	top[u] = tp ;
	if(wc[u]!=0){
		dfs2(wc[u],tp) ;
		for(auto &&v : e[u]){
			if(v!=fa[u] && v!=wc[u]){
				dfs2(v,v) ;
			}
		}
	}
}
void maketag(ll p , ll len , ll c){
	lzy[p] += c ;
	d[p] += len*c ;
	return ;
}
void pushup(ll p){
	d[p] = d[ls]+d[rs] ;
	return ;
}
void pushdown(ll p , ll s , ll t , ll mid){
	if(!lzy[p]){
		return ;
	}
	maketag(ls,mid-s+1,lzy[p]) ;
	maketag(rs,t-mid,lzy[p]) ;
	lzy[p] = 0 ;
	return ;
}
void build(ll l , ll r , ll p){
	if(l==r){
		d[p] = a[rdfn[l]] ;
		return ;
	}
	ll mid = (l+r) >> 1 ;
	build(l,mid,ls) ;
	build(mid+1,r,rs) ;
	pushup(p) ;
	return ;
}
void update(ll l , ll r , ll c , ll s , ll t , ll p){
	if(l<=s && t<=r){
		maketag(p,t-s+1,c) ;
		return ;
	}
	ll mid = (s+t) >> 1 ;
	pushdown(p,s,t,mid) ;
	if(l<=mid){
		update(l,r,c,s,mid,ls) ;
	}
	if(r>mid){
		update(l,r,c,mid+1,t,rs) ;
	}
	pushup(p) ;
	return ;
}
void modify(ll x , ll y , ll z){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){
			swap(x,y) ;
		}
		update(dfn[top[x]],dfn[x],z,1,n,1) ;
		x = fa[top[x]] ;
	}
	update(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]),z,1,n,1) ;
}
ll query(ll l , ll r , ll s , ll t , ll p){
	if(l<=s && t<=r){
		return d[p] ;
	}
	ll mid = (s+t) >> 1 , cnt = 0 ;
	pushdown(p,s,t,mid) ;
	if(l<=mid){
		cnt = query(l,r,s,mid,ls) ;
	}
	if(r>mid){
		cnt += query(l,r,mid+1,t,rs) ;
	}
	return cnt ;
}
ll ask(ll x , ll y){
	ll ans = 0 ;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){
			swap(x,y) ;
		}
		ans += query(dfn[top[x]],dfn[x],1,n,1) ;
		x = fa[top[x]] ;
	}
	return (ans+query(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]),1,n,1)) ;
}
int main() {
//	freopen(".in","r",stdin) ;
//	freopen(".out","w",stdout) ;
	ios::sync_with_stdio(false) ;
	cin.tie(0) ;
	cout.tie(0) ;
	cin >> n >> m ;
	for(i=1;i<n;i++){
		cin >> u >> v ;
		e[u].push_back(v) ;
		e[v].push_back(u) ;
	}
	dfs1(1,0) ;
	dfs2(1,0) ;
	build(1,n,1) ;
	while(m--){
		cin >> u >> v ;
		modify(u,v,1) ;
	}
	for(i=1;i<=n;i++){
		a[i] = ask(i,i) ;
		if(a[i]==0){
			vis[i] = true ;
		}
	}
	cin >> u >> v ;
	modify(u,v,1) ;
	for(i=1;i<=n;i++){
		if(a[i]==ask(i,i)){
			vis[i] = false ;
		}
		ans += vis[i] ;
	}
	cout << ans ;
	return 0 ;
}
```
时间复杂度 $ \mathcal{O}(n \log n) $，常数巨大，但可以通过本题。

---

## 作者：SudoXue (赞：3)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18804637)

考场上花费了 $2.5$ 小时，连题都没读懂，悻悻离去。是该提高一下自己的阅读理解能力了。

## 题意概述

给定一棵 $n$ 个节点的树，定义了若干个好点对和一个坏点对。要求删除某个节点后：

- 对于每个好点对，两个端点仍然连通（即删除节点不在它们之间的路径上）。
- 对于坏点对，删除节点必须位于它们之间的路径上（否则删除后坏点对仍然连通）。

于是问题转化为：统计那些既落在坏点对路径上、又不落在任何好点对关键路径上的节点。

## Solution

不难想到利用 Tarjan 离线 LCA 一次性求出所有点对的最近公共祖先，再结合树上差分的方法更新好点对信息，同时标记坏点对路径上的节点，最终统计满足条件的节点。

具体地，对于每个好点对 $\langle u, v \rangle$ 求出其最近公共祖先 $L$，方便在树上差分中减去重复计数。同时也用来求出坏点对的 LCA，以确定坏点对路径上需要标记的节点范围。

使用 DFS 遍历树，在 DFS 中利用并查集维护当前节点的祖先信息：
- 每访问到一个节点，就将其初始化为自己的祖先。
- 遍历完子节点后，通过并查集合并子节点，并将父节点更新为该节点的祖先。
- 对于每个查询，当另一端已经被访问时，即可通过并查集找到当前二者的 LCA。

对于每个好点对 $\langle u, v \rangle$：
- 在 $u$ 与 $v$ 上各加 $1$，
- 在 $L$（二者 LCA）上减 $1$，
- 在 $L$ 的父节点上再减 $1$（避免重复扣除）。
  
最后利用后序遍历（或按深度从大到小累加）将这些差分值向上传递，得到每个节点被“好点对路径”覆盖的次数。

不难发现，只有差分值为 $0$ 的节点才不会影响好点对的连通性。

利用坏点对 $\langle b_U, b_V \rangle$ 的 LCA $L$，从 $b_U$ 到 $L$ 以及从 $b_V$ 到 $L$ 上的所有节点都标记为“坏”节点。只有这些节点被删除时才能使坏点对断开。
最终遍历所有节点，如果一个节点既被标记为坏节点，又在好点对差分累加中为 $0$（不在任何好点对的关键路径上），则满足条件，计入答案。

时间复杂度 $O(n + a)$。差点拿下最优解，对比[官方题解](https://www.luogu.com.cn/record/211348335)跑得飞快。

[link](https://www.luogu.com.cn/record/211350530)

---

## 作者：corner_xiejunqi (赞：3)

### 题目分析：
首先这道题上手的时候，就会想到最近公共祖先遍历一遍他们中间的路径，并标记。但这样想就会误入歧途，永远卡在求路径上，我赛事就是卡在了这里，居然没有切掉这道题，太可惜了。

然后就会考虑，树上差分，求每个点是否在一个点对的路径上。有了大体思路，这时候就会想如果一个点对是好点对或坏点对会影响到那个地方。很明显就是他们两点到他们的最近公共祖先。那么在输入时就可以将差分数组建立好，再还原，最后访问每一个节点判定不再好点对路径上但在坏点对路径上即可。
### 代码如下：

```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
vector<int> g[N];
int dep[N],st[N][30],sum1[N],sum2[N];
int n,a;
inline void dfs(int now,int fa){
	dep[now]=dep[fa]+1;
	st[now][0]=fa;
	for(int i=1;i<=log2(n);++i) st[now][i]=st[st[now][i-1]][i-1];
	for(auto to:g[now]){
		if(to==fa) continue;
		dfs(to,now);
	}
}
inline int find(int a,int b){
	if(dep[a]<dep[b]) swap(a,b);
	for(int i=log2(n);i>=0;i--){
		if(dep[st[a][i]]>=dep[b]) a=st[a][i];
	}
	if(a==b) return a;
	for(int i=log2(n);i>=0;i--){
		if(st[a][i]!=st[b][i]){
			a=st[a][i];
			b=st[b][i];
		}
	}	
	return st[a][0];
}
inline void get1(int now,int fa){
	for(auto to:g[now]){
		if(to==fa) continue;
		get1(to,now);
		sum1[now]+=sum1[to];
	}
}
inline void get2(int now,int fa){
	for(auto to:g[now]){
		if(to==fa) continue;
		get2(to,now);
		sum2[now]+=sum2[to];
	}
} 
signed main(){
	// step 1、读题、声明变量
	cin.tie(0);cout.tie(0);
	ios::sync_with_stdio(false);
	// step 2、输入
	cin>>n>>a;
	for(int i=1,x,y;i<=n-1;i++){
	    cin>>x>>y;
        g[x].push_back(y);
        g[y].push_back(x);
	} 
	dfs(1,0);
	for(int i=1,u,v;i<=a;i++){
		cin>>u>>v;
		int lca=find(u,v);
		sum1[u]++;
		sum1[v]++;sum1[lca]--;
		sum1[st[lca][0]]--;
	}
	// step 3、处理
	get1(1,0);
	int b1,b2;
	cin>>b1>>b2;
	int lca=find(b1,b2);
	sum2[b1]++;sum2[b2]++;
	sum2[lca]--;sum2[st[lca][0]]--;
	get2(1,0);
	int ans=0;
	for(int i=1;i<=n;i++){
		if(!sum1[i] && sum2[i]) ans++;
	}
	// step 4、输出
	cout<<ans;
	return 0;
}
```
希望大家下次都能高分通过，谢谢观看！

---

## 作者：Double_Light (赞：3)

本文中“路径”与“简单路径”均代指两点间不经过重复的节点将两点相连的一条链，容易证明树和链上两点的路径是唯一确定的。

### 解题思路

非常容易发现的性质是符合条件的点一定在 $b_u,b_v$ 之间的简单路径上，这样才能保证坏点对不连通。

由于这个限制，我们可以把树上问题转化为序列问题，具体做法如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/tg7er1mw.png)

如图，假设 $\langle2,7\rangle$ 是一对坏点对。

假设现在 $\langle4,8\rangle$ 是一对好点对，那么由于删除的点只可能在路径 $2-3-6-7$ 中，所以 $1-5-4$ 与 $8$ 两段路径一定不会被删除。

又必须保证好点对连通，所以 $3$ 与 $6$ 两个节点不会被删除。

这样，$\langle4,8\rangle$ 这对点对连通等价于 $\langle3,6\rangle$ 这对点对连通。

设好点对的两个点都为好点，我们可以把所有的好点转化到 $b_u,b_v$ 简单路径上的唯一不经过路径上的其他点与之连通的点。（简单理解就是，将这条路径如上图所示提起来，每个点转化为往上一直走遇到的路径上的点。）

---
假设好点对 $\langle u_i,v_i\rangle$ 转化到路径上是 $\langle U_i,V_i\rangle$。

则原问题转化为给定 $a$ 个二元组 $U_i,V_i$，现有一条链，要求链上从 $U_i$ 到 $V_i$ 路径上的点都不能被删掉，问有多少链上的点可以被删掉。

一种解决办法是将链上的节点重新编号，按照从 $b_v$ 到 $b_u$ 的顺序编号为 $1\sim m$（$m$ 在 DFS 的过程中求出），随后每个二元组的限制条件可以变为编号 $[l,r]$ 的节点不能删掉。

此时已经非常简单了，直接差分一下即可。可以参考 P11853。

### 代码实现

首先 DFS 找出坏点对之间的路径，通过 DFS 时记录每个点是从哪个点搜索来的可以找到路径上对应的每一个点以及顺序。同时可以求出路径的长度 $m$。

这样就可以给每个路径上的节点重新编号。

接下来容易通过再一遍 DFS 找到好点在原序列上对应的点。这样就可以记录下每一个好点对对应的区间 $[l,r]$。

然后直接差分即可。

代码赛时写的，不放了。

---

## 作者：CommandSR (赞：3)

## 前置知识

LCA，树上差分。

## 基本思路

题目要求删除一定数量的节点使得坏点对不连通，则删除的节点一定在坏点对 $b_u \rightarrow b_v$ 的路径上。

因为坏点对只有一对，所以可以遍历坏点对的路径，则自然要求出最近公共祖先。

另外，题目还要求使好点对依然联通，则所有好点对 $u_i \rightarrow v_i$ 的路径上的点都不能被删除。

我们用树上差分维护每一个不能被删除的节点，即对于每一个好点对，在 $u_i$ 和 $v_i$ 处加 $1$ 并在 $\text{lca}(u_i, v_i)$ 和 $fa_{\text{lca}(u_i, v_i)}$ 处减 $1$。

然后遍历一遍对差分数组做前缀和。

遍历坏点对路径，当前遍历到 $cur$，若 $cur$ 对应值为 $0$，答案加一。

## AC Code

```cpp
#include <bits/stdc++.h>
#define pb push_back
#define F(i, a, b) for (int i = a; i <= b; ++i)
#define _F(i, a, b) for (int i = a; i >= b; --i)
#define ll long long
using namespace std;
ll rd() {
	ll p = 0, f = 1; char ch = getchar();
	while (ch>'9' || ch<'0') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch>='0' && ch<='9') p = p*10+ch-'0', ch = getchar();
	return p * f;
}
const int N = 2e6 + 5;  
ll n, k, f[N][22], dep[N], c[N];
vector <int> g[N];
void Dfs1(int u, int p) {
	f[u][0] = p;
	dep[u] = dep[p] + 1;
	for (int v : g[u]) {
		if (v == p) continue ;
		Dfs1(v, u);
	}
}
void Initlca() {
	F(j, 1, 20) {
		F(i, 1, n) f[i][j] = f[f[i][j-1]][j-1];
	}
}
int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	_F(i, 20, 0) if (dep[f[u][i]] >= dep[v]) u = f[u][i];
	if (u == v) return u;
	_F(i, 20, 0) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
	return f[u][0];
}
void Dfs2(int u, int p) {
	for (int v : g[u]) {
		if (v == p) continue ;
		Dfs2(v, u);
		c[u] += c[v];
	}
}
int main() {
	n = rd(), k = rd();
	F(i, 1, n-1) {
		ll u = rd(), v = rd(); g[u].pb(v), g[v].pb(u);
	}
	Dfs1(1, 0); Initlca();
	F(i, 1, k) {
		ll u = rd(), v = rd();
		++c[u], ++c[v];
		int lc = lca(u, v); --c[lc], --c[f[lc][0]];
	}
	Dfs2(1, 0);
	ll bu = rd(), bv = rd(), bl = lca(bu, bv), cnt = 0;
	for (int cur = bu; cur != bl; cur = f[cur][0]) if (!c[cur]) ++cnt;
	for (int cur = bv; cur != bl; cur = f[cur][0]) if (!c[cur]) ++cnt;
	if (!c[bl]) ++cnt;
	cout << cnt << '\n';
	return 0;
}
```

---

## 作者：huangzixi071018 (赞：2)

# 题目大意:
找到一个点，删掉之后，使 $u$ 和 $v$ 之间不能连通，使这 $a$ 对点之间还能联通，求满足条件的点的个数。

# 做法：
由题可知，满足条件的点在 $u$ 到 $v$ 的路径上，但不在这 $a$ 对点的路径上。可以用数上差分在这 $a$ 对点的路径上打上标记。再依次枚举 $u$ 到 $v$ 的路径上的点，看这个点是否没有被标记过，若没有，证明这个点满足条件，那么答案加一。

# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+5;
vector<int>e[N];
int dep[N],fa[N][25],lo[N],sz[N];
void dfs(int x,int f){
	dep[x]=dep[f]+1;
	fa[x][0]=f;
	for(int i=1;(1<<i)<dep[x];i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
	for(int i=0;i<e[x].size();i++){
		int y=e[x][i];
		if(y==f)continue;
		dfs(y,x);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y]){
		swap(x,y);
	}
	while(dep[x]>dep[y]){
		x=fa[x][lo[dep[x]-dep[y]]];
	}
	if(x==y){
		return x;
	}
	for(int k=lo[dep[x]];k>=0;k--){
		if(fa[x][k]!=fa[y][k]){
			x=fa[x][k];
			y=fa[y][k];
		}
	} 
	return fa[x][0];
}
void js(int x,int f){
	for(int i=0;i<e[x].size();i++){
		int y=e[x][i];
		if(y==f)continue;
		js(y,x);
		sz[x]+=sz[y];
	} 
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,m,u,v,ans=0;
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	dfs(1,0);
	lo[1]=0;
	for(int i=2;i<=n;i++){
		lo[i]=lo[i/2]+1;
	}
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		int d=lca(x,y);
		sz[x]++;
		sz[y]++;
		sz[d]--;
		sz[fa[d][0]]--;
	}
	js(1,0); 
	cin>>u>>v;
	if(dep[u]<dep[v]){
		swap(u,v);
	}
	while(dep[u]>dep[v]){
		if(sz[u]==0){
			ans++;
		}
		u=fa[u][0];
	}
	while(u!=v){
		if(sz[u]==0){
			ans++;
		}
		if(sz[v]==0){
			ans++;
		}
		u=fa[u][0];
		v=fa[v][0];
	}
	if(sz[u]==0){
		ans++;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：2)

根据这题条件，我们容易得出结论，一个点可以删除当且仅当这个点不在任意一个好点对构成的简单路径上，同时必须在 $b_u$ 和 $b_v$ 构成的简单路径上。

这个东西很好搞，上个树链剖分做个覆盖，然后拉出坏点的简单路径统计就做完了。

```cpp
#define MULTI_TEST 0
int32_t main() {
#if MULTI_TEST == 1
#else
    int n, a;
    std::cin >> n >> a;
    VVI adj(n + 1);
    For(i, 1, n - 1) {
        int x, y;
        std::cin >> x >> y;
        adj[x].eb(y), adj[y].eb(x);
    }
    VI pa(n + 1, 0), siz(n + 1, 0), heavy(n + 1, 0), pos(n + 1, 0);
    VI dep(n + 1, 0), head(n + 1, 0);
    auto dfs = [&](auto&& self, int x, int p) -> void {
        pa[x] = p, dep[x] = dep[p] + 1;
        siz[x] = 1;
        for (auto& y : adj[x]) {
            if (y == p) continue;
            self(self, y, x), siz[x] += siz[y];
            if (siz[y] > siz[heavy[x]]) {
                heavy[x] = y;
            }
        }
        };
    int cnt = 0;
    auto dfs1 = [&](auto&& self, int x, int h) -> void {
        head[x] = h, pos[x] = cnt++;
        if (heavy[x]) self(self, heavy[x], h);
        for (auto& y : adj[x]) if (y != pa[x] && y != heavy[x])
            self(self, y, y);
        };
    dep[0] = -1;
    dfs(dfs, 1, 0), dfs1(dfs1, 1, 1);
    Fenw fenw(n);
    auto update = [&](int x, int y, int v) -> void {
        while (head[x] != head[y]) {
            if (dep[head[x]] > dep[head[y]]) {
                fenw.update(pos[head[x]], v);
                fenw.update(pos[x] + 1, -v);
                x = pa[head[x]];
            }
            else {
                fenw.update(pos[head[y]], v);
                fenw.update(pos[y] + 1, -v);
                y = pa[head[y]];
            }
        }
        if (dep[x] > dep[y])
            std::swap(x, y);
        fenw.update(pos[x], v);
        fenw.update(pos[y] + 1, -v);
        };
    auto lca = [&](int x, int y) -> int {
        while (head[x] != head[y]) {
            if (dep[head[x]] > dep[head[y]])
                x = pa[head[x]];
            else
                y = pa[head[y]];
        }
        return dep[x] < dep[y] ? x : y;
        };
    auto get = [&](int x, int y) -> VI {
        int l = lca(x, y);
        VI px, py;
        while (x != l) px.eb(x), x = pa[x]; px.eb(l);
        while (y != l) py.eb(y), y = pa[y]; std::reverse(ALL(py));
        for (auto& v : py) px.eb(v);
        return px;
        };
    For(i, 0, a - 1) {
        int x, y; std::cin >> x >> y;
        update(x, y, 1);
    }
    int bu, bv;
    std::cin >> bu >> bv;
    auto path = get(bu, bv);
    int ans = 0;
    for (auto& x : path)
        ans += !fenw.query(pos[x]);
    std::cout << ans << "\n";
#endif
}

```

---

## 作者：Lele_Programmer (赞：1)

# P11967 题解

## 思路

对于一个好点对 $(u,v)$，删掉某个点后要让 $(u,v)$ 依旧连通，也就是说删掉的点不可以从 $(u,v)$ 之间的路径上选。

对于一个坏点对 $(u,v)$，删掉某个点后要让 $(u,v)$ 不连通，也就是说删掉的点要从 $(u,v)$ 的路径上选。

于是我们可以把每一组好点对的 $(u,v)$ 之间的路径做标记，也就是在 $u$ 处标记为 $+1$，在 $v$ 处标记为 $+1$，在 $u,v$ 的最近公共祖先的父节点处标记为 $-2$，后面在做树上差分的时候，对于一个点，它的值就是它的子树值之和，这样一来，在 $k$ 点做一次标记，意思就是从 $k$ 到根节点要 $+1$，因为 $u,v$ 都做了一个标记，所以要把 $u,v$ 的最近公共祖先的父节点到根节点这一段多减去的 $2$ 加回来，因而在最近公共祖先的父节点打上 $-2$ 标记。

最后统计答案，坏点对 $(u,v)$ 之间的路径走一遍，对于值为 $0$ 的点，结果 $+1$。

## 代码

```cpp
const int N=1000005;
const int M=2000005;
const int K=25;

int n,m;
int e[M],ne[M],h[N],tot;
int dep[N];
int f[N][K];
int arr[N];

void add(int a,int b) {
    e[tot]=b,ne[tot]=h[a],h[a]=tot++;
}

void dfs(int u,int fa,int d) {
    dep[u]=d;
    _graph(i,u) {
        if (e[i]==fa) continue;
        f[e[i]][0]=u;
        _rep(j,1,K-1) f[e[i]][j]=f[f[e[i]][j-1]][j-1];
        dfs(e[i],u,d+1);
    }
}

int lca(int a,int b) {
    if (a==b) return a;
    if (dep[a]<dep[b]) swap(a,b);
    _rrep(i,K-1,0) if (dep[f[a][i]]>=dep[b]) a=f[a][i];
    if (a==b) return a;
    _rrep(i,K-1,0) if (f[a][i]!=f[b][i]) a=f[a][i],b=f[b][i];
    return f[a][0];
}

void dfs2(int u,int fa) {
    _graph(i,u) {
        if (e[i]==fa) continue;
        dfs2(e[i],u);
        arr[u]+=arr[e[i]];
    }
}

int main() {
    memset(h,-1,sizeof(h));
    read(n),read(m);
    _rep(i,1,n-1) {
        int a,b;
        read(a),read(b);
        add(a,b),add(b,a);
    }
    dfs(1,0,1);
    while (m--) {
        int x,y;
        read(x),read(y);
        arr[x]++,arr[y]++;
        arr[f[lca(x,y)][0]]-=2;
    }
    dfs2(1,0);
    int a,b,g;
    read(a),read(b);
    g=lca(a,b);
    int ans=0;
    while (a!=g) {
        if (!arr[a]) ans++;
        a=f[a][0];
    }
    while (b!=g) {
        if (!arr[b]) ans++;
        b=f[b][0];
    }
    if (!arr[g]) ans++;
    write(ans);
    return 0;
}
```

---

## 作者：litangzheng (赞：1)

### 前言：  

出题组想不到出什么好了，于是就出了一道树上差分模版来~~折磨~~没有学过树上差分的选手。  

### 思路：  

我们先画一张图，用绿色来表示删除会使坏点对不连通的点。  
![](https://cdn.luogu.com.cn/upload/image_hosting/2is8r41e.png)  

我们发现，这不就是树上两点的路径吗？因为删除两点路径以外的点总是无效的。于是，我们就可以想出以下过程：  

1. 将每个好点对之间的路径打上标记 1 。  
2. 将坏点对之间的路径打上标记 2。  
3. 遍历每个点，如果它有且仅被打上了标记 2，则答案加 1。

显然，这个过程可以用树上差分来维护。于是代码就新鲜出炉了。  

### 代码：  


```cpp
#include<bits/stdc++.h>
#define N 1000005
#define MAXN 20 
using namespace std;
int n,m,head[N],cnt=1,fa[N][MAXN],deep[N],vis[N],cha[N],a[N],ans;
struct Edge{
	int nxt,to;
}edge[2*N];
void addedge(int u,int v){
	edge[cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt++;
}
void dfs(int x,int fath){
	vis[x]=1;
	fa[x][0]=fath;deep[x]=deep[fath]+1;
	for(int i=1;i<=MAXN-1;i++){
		fa[x][i]=fa[fa[x][i-1]][i-1];
	}
	for(int i=head[x];i;i=edge[i].nxt){
		if(!vis[edge[i].to]) dfs(edge[i].to,x);
	}
}
int LCA(int x,int y){
	if(deep[x]<deep[y]) swap(x,y);
	for(int i=MAXN-1;i>=0;i--) if(deep[fa[x][i]]>=deep[y]) x=fa[x][i];
	if(x==y) return y;
	for(int i=MAXN-1;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}//倍增LCA模板。
void dfs2(int x,int fath){
    for(int i=head[x];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(to==fath) continue;
        dfs2(to,x);
        cha[x]+=cha[to];
    }
}//树上查分模板。
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n-1;i++){
		int u,v;
		cin>>u>>v;
		addedge(u,v);
		addedge(v,u);
	}
	dfs(1,0);
	for(int i=1;i<=m;i++){
		int a,b,l;
        cin>>a>>b;
        l=LCA(a,b);
        cha[a]+=2;
        cha[b]+=2;
        cha[l]-=2;
        cha[fa[l][0]]-=2;//好点对+2。
	}
    int a,b,l;
    cin>>a>>b;
    l=LCA(a,b);
    cha[a]++;
    cha[b]++;
    cha[l]--;
    cha[fa[l][0]]--;//坏点对+1。
    dfs2(1,0);
    for(int i=1;i<=n;i++) if(cha[i]==1) ans++;//如果这个点的值是1表示它只被坏点对打上标记过，即可以删除。
    cout<<ans;
}
```
代码复杂度应为 $O(n \log n + a \log n)$。

---

## 作者：Alex866 (赞：1)

## 题意分析
题目让我们求不在 $u_i$ 到 $v_i$ 路径上，且在 $b_u$ 到 $b_v$ 路径上的点数。
## 算法选取
首先，题目涉及树上路径，一定要用 LCA，此题 $n\le10^6$，要用倍增法。
## 优化
但是，直接给路径上的点打标记，复杂度达到了 $O(n^2)$，由于是静态修改，考虑树上差分，复杂度可以被优化到 $O(n)$。
## code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define uint unsigned
#define ull uint ll
#define __Pa(__Type) pair<__Type,__Type>
#define __Greater_Pri_Q(__Type) priority_queue<__Type,vector<__Type>,greater<__Type>>
#define __Stu_Pri_Q(__Type,__Cmp) priority_queue<__Type,vector<__Type>,__Cmp>
#define __Cls_Pri_Q __Stucmp_Pri_Q
#define __Func_Pri_Q(__Type,__Cmp) priority_queue<__Type,vector<__Type>,decltype(&__Cmp)>
#define __Pri_Q(__Type) priority_queue<__Type>
//#define ONLINE_JUDGE
#ifndef ONLINE_JUDGE
#define __put(__X,__F1,__F2) ((__F1)?(cout<<(#__X)<<':'<<(__X)<<" \n"[__F2]):(cout<<(__X)<<" \n"[__F2]))
#define __put0 cout<<"0 ";
#define __putenter cout<<'\n'
#else
#define __put(__X,__F1,__F2)
#define __put0
#define __putenter
#endif
//#define __INT_TO_LL
#ifdef __INT_TO_LL
#define int long long
#endif
//#define __USE_FREOPEN
#define __CLOSE_SYNC
#ifdef __USE_FREOPEN
#undef __CLOSE_SYNC
#endif
#define y1 __Y1_By_MySelf__
#define ass(__Num,__Arr) memset((__Arr),(__Num),sizeof(__Arr))
#define clr(__Arr) memset((__Arr),0,sizeof(__Arr))
#define assmax(__Arr)memset((__Arr),0x7f,sizeof(__Arr))
#define assmax_s(__Arr)memset((__Arr),0x3f,sizeof(__Arr))
#define assmin(__Arr)memset((__Arr),0x80,sizeof(__Arr))
#define assmin_s(__Arr)memset((__Arr),0xc0,sizeof(__Arr))
using namespace std;
vector<int> e[1000005];
int fa[1000005][25],dep[1000005],ans,n,a,u,v,good[1000005],bad[1000005];
void dfs(int r,int f){
	fa[r][0]=f;
	dep[r]=dep[f]+1;
	for(int i=1;i<=20;i++){
		fa[r][i]=fa[fa[r][i-1]][i-1];
	}
	for(auto i:e[r]){
		if(i==f){
			continue;
		}
		dfs(i,r);
	}
}
int lca(int x,int y){
	if(dep[x]>dep[y]){
		swap(x,y);
	} 
	int tmp=dep[y]-dep[x];
	for(int j=0;tmp;j++,tmp>>=1){
		if(tmp&1){
			y=fa[y][j];
		}
	}
	if(y==x){
		return x;
	} 
	for(int j=20;j>=0&&y!=x;j--){
		if(fa[x][j]!=fa[y][j]){
			x=fa[x][j];
			y=fa[y][j];
		}
	}
	return fa[x][0];
}
void getsum(int r,int f){
	for(auto i:e[r]){
		if(i==f){
			continue;
		}
		getsum(i,r);
		good[r]+=good[i];
		bad[r]+=bad[i];
	}
	if(!good[r]&&bad[r]){
		ans++;
	}
}
signed main(){
#ifdef __CLOSE_SYNC
//	ios_base::sync_with_stdio(0);
#endif
#ifdef __USE_FREOPEN
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cin>>n>>a;
	for(int i=1;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	} 
	dfs(1,0);
	for(int i=0;i<a;i++){
		cin>>u>>v;
		good[u]++;
		good[v]++;
		good[lca(u,v)]--;
		good[fa[lca(u,v)][0]]--;
	}
	cin>>u>>v;
	bad[u]++;
	bad[v]++;
	bad[lca(u,v)]--;
	bad[fa[lca(u,v)][0]]--;
	getsum(1,0);
	cout<<ans;
	return 0;
}
//禁止抄袭
```

---

## 作者：Sunrise_beforeglow (赞：1)

哎呀呀，这题怎么没有题解啊，让我来交一篇。

首先我们发现，这是一棵树，那么树的性质很明显，两个点路径是唯一的，而且删去任意一个点都会使树分成两半。那么我们想，如果删掉一个点使 $u,v$ 不连通，怎么办？

很容易发现，如果删去的点不在 $u$ 到 $v$ 路径上，那么 $u,v$ 仍然可以通过原来的路径到达。于是我们发现，如果想对于所有的 $1\le i\le a$，$u_i,v_i$ 删去一个点后连通，那个点一定不在任意一个 $u_i,v_i$ 的路径上。

那么我们可以用树上差分给 $u_i$ 到 $v_i$ 路径上的点打一种标记 $x_i$，给 $b_u,b_v$ 路径上的点打另一种标记 $y_i$。 

最终答案就是没有 $x_i$ 标记的且有 $y_i$ 标记的。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,a,b,c[N],dep[N],pa[N][25],m,sum[N];
vector<int>g[N];
void dfs(int x,int fa)
{
	pa[x][0]=fa;
	for(int i=1;i<=20;i++)pa[x][i]=pa[pa[x][i-1]][i-1];
	for(auto i:g[x])
	{
		if(i==fa)continue;
		dep[i]=dep[x]+1;
		dfs(i,x);
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	int tmp=dep[x]-dep[y];
	for(int i=0;i<=20;i++)
	{
		if((tmp>>i)&1)x=pa[x][i];
	}
	if(x==y)return x;
	for(int i=20;i>=0;i--)
	{
		if(pa[x][i]!=pa[y][i])
		{
			x=pa[x][i];
			y=pa[y][i];
		}
	}
	return pa[x][0];
}
void d(int x,int fa)
{
	for(auto i:g[x])
	{
		if(i==fa)continue;
		d(i,x);
		c[x]+=c[i];
        sum[x]+=sum[i];
	}
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<n;i++)cin>>a>>b,g[a].push_back(b),g[b].push_back(a);
	dfs(1,0);
	while(m--)
	{
		cin>>a>>b;
		int u=lca(a,b);
		c[a]++;
		c[b]++;
		c[u]--;
        c[pa[u][0]]--;
	}
    cin>>a>>b;
    sum[a]++,sum[b]++;
    int u=lca(a,b);
    sum[u]--,sum[pa[u][0]]--;
	d(1,0);
	int ans=0;
	for(int i=1;i<=n;i++)
    {
        if(!c[i]&&sum[i])ans++;
    }
	cout<<ans;
	return 0;
}
//防伪标记
```

---

## 作者：wwt100127 (赞：0)

## 题意
给定一颗树，几对好点 $\{\langle u_1, v_1 \rangle, \langle u_2, v_2 \rangle, \dots, \langle u_a, v_a \rangle\}$ 和一个坏点对 $\langle b_u, b_v \rangle$。$\langle u_i, v_i \rangle$ 之间的点不能，只能选 $\langle b_u, b_v \rangle$ 之间的点，求有几个点可以被选择。

## 思路
以 $b_u$ 为根，则只能选从 $b_v$ 到根上的路径，用一个 `bool` 数组记录（不妨在 $b_u$ 到 $b_v$ 的路径上的为 $true$）。

定义 $f_i$ 表示共有多少组 $\langle u_i, v_i \rangle$ 的路径经过点 $i$。

对于每一组 $\langle u_i, v_i \rangle$，树上差分即可。

具体来说，就是：
```cpp
  f[u[i]]++;
  f[v[i]]++;
  f[LCA(u[i],v[i])]--;
  f[father[LCA(u[i],v[i])]]--;
```
然后对于每一组父子关系 $(fa,x)$，`f[fa]+=f[x]` 即可。

点 $p$ 不在任意一组 $\langle u_i, v_i \rangle$ 所在路径上，当且仅当 $f_p=0$。

综上所述，一个点 $i$ 可以被选择，当且仅当 $ans_i = true$ 并且 $f_i=0$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool Beginning;

#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define se second
#define fi first
using PII=pair<int,int>;
using PIB=pair<int,bool>;
using PBI=pair<bool,int>;
using PBB=pair<bool,bool>;
using PDI=pair<double,int>;
using PID=pair<int,double>;

namespace Memory_Love{
	int read(){ int x=0; bool flag=1; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} return flag? x:-x;}
	template<typename T> void read(T &x){ bool flag=1; x=0; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} x=(flag? x:-x);}
	template<typename T,typename ...Args> void read(T &Re,Args &...Res){read(Re),read(Res...);}
	template<typename T> void write(T x,char ch=0){if(x<0) x=-x,putchar('-');
		static short s[35],top=-1; do{s[++top]=x%10;x/=10;}while(x);
		while(~top) putchar(s[top--]+48); if(ch) putchar(ch);}
	int gcd(int a,int b){return b==0? a:gcd(b,a%b);}
	int lcm(int a,int b){return a/gcd(a,b)*b;}
	int lowbit(int x){return (x&-x);}
} using namespace Memory_Love;
const int N=1e6+5;
int n,m,s,t;

namespace Graph
{
	int head[N],tot;
	struct edge
	{
		int v,next;
	}e[N<<1];
	void G_init()
	{
		memset(head,-1,sizeof(head));
		tot=-1;
	}
	void add(int u,int v)
	{
		e[++tot]=(edge){v,head[u]};
		head[u]=tot;
	}
	void add_edge(int u,int v)
	{
		add(u,v),add(v,u);
	}
} using namespace Graph;

vector<PII> G;

namespace SP
{
	int dfn[N],rev[N],cnt;
	int depth[N],father[N];
	int son[N],top[N],SIZE[N];
	void dfs1(int x,int fa)
	{
		int i;
		SIZE[x]=1;
		father[x]=fa;
		depth[x]=depth[fa]+1;
		for(i=head[x];~i;i=e[i].next)
		{
			int y=e[i].v;
			if(y==fa)
			continue;
			dfs1(y,x);
			SIZE[x]+=SIZE[y];
			if(SIZE[y]>SIZE[son[x]])
			son[x]=y;
		}
	}
	void dfs2(int x,int topx)
	{
		int i;
		dfn[x]=++cnt;
		rev[cnt]=x;
		top[x]=topx;
		if(son[x]) dfs2(son[x],topx);
		for(i=head[x];~i;i=e[i].next)
		{
			int y=e[i].v;
			if(!top[y])
			dfs2(y,y);
		}
	}
	void init(int root)
	{
		dfs1(root,0);
		dfs2(root,root);
	}
	int LCA(int x,int y)
	{
		while(top[x]!=top[y])
		{
			if(depth[top[x]]<depth[top[y]])
			swap(x,y);
			x=father[top[x]];
		}
		return (depth[x]<depth[y]? x:y);
	}
}

int f[N];
bool ans[N];
void dfs(int x,int fa)
{
	int i;
	if(x==t) ans[x]=1;
	for(i=head[x];~i;i=e[i].next)
	{
		int y=e[i].v;
		if(y==fa)
		continue;
		dfs(y,x);
		ans[x]|=ans[y];
		f[x]+=f[y];
	}
}

bool Ending;
signed main()
{
	int i,u,v,Ans=0;
	read(n,m);
	G_init();
	for(i=1;i<=n-1;i++)
	{
		read(u,v);
		add_edge(u,v);
	}
	for(i=1;i<=m;i++)
	{
		read(u,v);
		G.push_back(mp(min(u,v),max(u,v)));
	}
	read(s,t);
	SP::init(s);
	
	for(auto t:G)
	{
		int lca=SP::LCA(t.fi,t.se);
		f[t.fi]++,f[t.se]++;
		f[lca]--,f[SP::father[lca]]--;
	}
	dfs(s,0);
	for(i=1;i<=n;i++)
	{
		if(ans[i] && f[i]==0)
		Ans++;
	}
	write(Ans,'\n');
	
	cerr<<"\nused:"<<(abs(&Ending-&Beginning)/1048576)<<"MB\n";
	return 0;
}
```

---

## 作者：aaalys (赞：0)

# P11967 [GESP202503 八级] 割裂 题解

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P11967)

题目中说的很清楚。

## 思路

### 转化联通条件

假如删除了节点 $k$，如何判断两个点 $x,y$ 是否联通？

首先，如果 $k$ 是 $x\sim y$ 路径上的点，由于树上每两点只有一条路径，所以 $x,y$ 一定不联通。

而题目中又说了，如果 $k=x$ 或 $k=y$，那么 $x,y$ 也不联通。

综上所述，只有当 $k$ 是 $x\sim y$ 路径上的点（包括 $x,y$）时，$x,y$ 才算作不联通，否则都算作联通。

### 解法一：标记法

先看第一条限制，对于所有的 $1\le i\le a$，$u_i$ 和 $v_i$ 仍然连通。

结合前面的推导，这条限制可以变成对于所有的 $1\le i\le a$，删除的节点 $k$ 不在 $u_i\sim v_i$ 这条路径上。

不难想到，可以每次暴力把 $u_i\sim v_i$ 这条路径上每个点做一个标记，表示这个点不能被删除。

同理，第二条限制可以变为 $k$ 必须在 $b_u\sim b_v$ 这条路径上。

那可以暴力在这条路径上查找，看有多少个点没有被标记。

由于有 $a$ 对 $u_i$ 和 $v_i$，每次又要花费 $O(n)$ 的时间复杂度打标记，总时间复杂度为 $O(na)$。

这样只能得到 40 分，所以考虑优化。

### 解法二：树上差分优化

对于解法一，时间复杂度的瓶颈在于打标记，考虑优化打标记的过程。

现在要解决如何把 $u_i\sim v_i$ 这条路径上每个点做一个标记，发现这个过程可以用树上差分优化。

即把 $u_i\sim v_i$ 这条路径每个点的访问次数加 1，最后的判断条件变为了访问次数为 0，这就变成了树上差分的模版（不会树上差分可以看[这里](https://oi-wiki.org/basic/prefix-sum/#树上差分)）。

这样打标记的时间复杂度优化为 $O( \log n)$，总时间复杂度为 $O(a \log n)$。

## 代码实现

下面给出了算法步骤，请读者自行实现具体代码。

### 算法步骤

1. 输入。
2. 进行一遍 dfs，求出求 LCA 的倍增数组。
3. 对于每对 $u_i$ 和 $v_i$，用树上差分把 $u_i\sim v_i$ 这条路径每个点的访问次数加 1。
4. 计算差分数组的前缀和（即每个点的访问次数）。
5. 暴力查找 $b_u\sim b_v$ 这条路径，看有多少个点访问次数为 0。
6. 输出。

## 后记

求管理员通过。

我构造了几组样例，读者可以自行参考。

```data
Data #1:
input:
6 0
1 3
1 5
3 6
3 2
5 4
2 6
ans:
3
Data #2:
input:
8 3
1 2
2 3
2 4
2 5
1 6
6 7
7 8
1 6
3 5
4 3
3 8
ans:
2
```

---

## 作者：_cbw (赞：0)

树上差分基础练习题。考场上用并查集写挂一个点，dfs 序求 LCA `st[i][j] = calc(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);` 写成 `st[i][j] = calc(st[i - 1][j], st[i - 1][j - (1 << (i - 1))]);`，总计 $7$ 发罚时。这就是小丑吗。

---

$(u, v)$ 表示树上 $u$ 与 $v$ 之间的路径。

首先有一个基础结论：树上问题中，删除一个点 $x$ 可以使 $u, v$ 不连通当且仅当 $x$ 在 $(u, v)$ 上。

证明：若 $x$ 在 $(u, v)$ 上，由树上路径的唯一性，知 $u, v$ 不连通。若 $x$ 不在 $(u, v)$ 上，则 $(u, v)$ 上的点与边已将 $u, v$ 连接。

于是问题转换为：求点 $x$ 的个数，使得对于 $1 \le i \le a$，$x \notin (u_i, v_i)$ 且 $x \in (b_u, b_v)$。

可以树上差分。感觉应该可以树上并查集，但我没写对。反正复杂度也一样。

代码，$\max a \ll \max n$ 所以把 dfs 序求 LCA 换成了重链剖分。突发奇想然后把重剖写得十分逆天，见谅。时间复杂度 $\Theta(n + a \log n)$，空间复杂度 $\Theta(n)$。

最优解第二。orz 第一 Xor-Tree 大神。

```cpp
#include <cctype>
#include <cstdio>
#define MAXN 1000003
using namespace std;

namespace IO
{
#define SIZ (1 << 18)
    char ibuf[SIZ], *p1 = nullptr, *p2 = nullptr;
#define gc() (p1 == p2 && (p2 = (p1 = ibuf) + fread(ibuf, 1, SIZ, stdin), p1 == p2) ? EOF : *p1++)
    void rd(int &x)
    {
        x = 0;
        char c = gc();
        while (!isdigit(c))
            c = gc();
        while (isdigit(c))
            x = x * 10 + (c ^ 48), c = gc();
    }
    inline void rd(int &x, int &y)
    {
        rd(x), rd(y);
    }
#undef gc
#undef SIZ
}
using IO::rd;

struct Edge
{
    int to, nxt;
} edges[MAXN << 1];
int cnt, head[MAXN], fa[MAXN], hsontp[MAXN], sizdep[MAXN], darr[MAXN];

inline void add_edge(const int from, const int to)
{
    edges[++cnt] = {to, head[from]}, head[from] = cnt;
}

void dfs1(const int u)
{
    int f = fa[u], hsiz = 0, hcur = 0;
    sizdep[u] = 1;
    for (int i = head[u], to; i; i = edges[i].nxt)
    {
        to = edges[i].to;
        if (to == f)
            continue;
        fa[to] = u;
        dfs1(to);
        sizdep[u] += sizdep[to];
        if (sizdep[to] > hsiz)
            hsiz = sizdep[to], hcur = to;
    }
    hsontp[u] = hcur;
}
void dfs2(const int u, const int tp)
{
    int h = hsontp[u], f = fa[u];
    hsontp[u] = tp;
    if (h)
        sizdep[h] = sizdep[u] + 1, dfs2(h, tp);
    else
        return;
    for (int i = head[u], to; i; i = edges[i].nxt)
    {
        to = edges[i].to;
        if (to == f || to == h)
            continue;
        sizdep[to] = sizdep[u] + 1, dfs2(to, to);
    }
}
void dfs3(const int u)
{
    int f = fa[u];
    for (int i = head[u], to; i; i = edges[i].nxt)
    {
        to = edges[i].to;
        if (to == f)
            continue;
        dfs3(to);
        darr[u] += darr[to];
    }
}
inline int LCA(int u, int v)
{
    while (hsontp[u] != hsontp[v])
    {
        if (sizdep[hsontp[u]] < sizdep[hsontp[v]])
            v = fa[hsontp[v]];
        else
            u = fa[hsontp[u]];
    }
    return (sizdep[u] < sizdep[v] ? u : v);
}
inline void update(const int u, const int v)
{
    int lca = LCA(u, v);
    ++darr[u], ++darr[v], --darr[lca], --darr[fa[lca]];
}

int main()
{
    int n, a, u, v;
    rd(n, a);
    for (int i = 1; i < n; ++i)
        rd(u, v), add_edge(u, v), add_edge(v, u);
    dfs1(1);
    dfs2(1, 1);
    while (a--)
        rd(u, v), update(u, v);
    dfs3(1);
    rd(u, v);
    if (sizdep[u] < sizdep[v])
        u ^= v, v ^= u, u ^= v;
    int ans = 0;
    while (sizdep[u] != sizdep[v])
    {
        if (!darr[u])
            ++ans;
        u = fa[u];
    }
    while (u != v)
    {
        if (!darr[u])
            ++ans;
        u = fa[u];
        if (!darr[v])
            ++ans;
        v = fa[v];
    }
    if (!darr[u])
        ++ans;
    printf("%d", ans);
    return 0;
}
```

---

## 作者：five_rice_water (赞：0)

树上差分板子题。

引理：对于一个树上的点对，删掉一个点使得这个点对不连通**当且仅当**删掉的是这个点对路径上的点。

其实很好理解，如果不是路径上的点，那么隔开的子树一定和这个点对没有关系，不会分割开这两个点对。

我们首先用树上差分标记出来所有好点对之间的点，如果这个点被标记过了就说明删除这个点至少会造成 $1$ 对好点对不联通。然后暴力找坏点对路径上的点没有标记过的有多少就好啦。

象征性给一下代码。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6+5;
int n,m,ans,fa[N][25],dep[N],cnt[N];
vector<int>e[N];
void dfs(int x,int f){
	dep[x] = dep[f]+1;
	fa[x][0] = f;
	for(int i = 1; i<=24; i++){
		fa[x][i] = fa[fa[x][i-1]][i-1];
	}
	for(int i = 0; i<e[x].size(); i++){
		int v = e[x][i];
		if(v==f) continue;
		dfs(v,x);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int i = 24; i>=0; i--){
		if(dep[fa[x][i]]>=dep[y]){
			x = fa[x][i];
		}
	}
	if(x==y) return x;
	for(int i = 24; i>=0; i--){
		if(fa[x][i]!=fa[y][i]){
			x = fa[x][i];
			y = fa[y][i];
		}
	}
	return fa[x][0];
}
void Get(int x,int f){
	for(int i = 0; i<e[x].size(); i++){
		int v = e[x][i];
		if(v==f) continue;
		Get(v,x);
		cnt[x] += cnt[v];
	}
}
void solve(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]){
		if(cnt[x]==0) ans++;
		x = fa[x][0];
	}
	while(x!=y){
		if(cnt[x]==0) ans++;
		if(cnt[y]==0) ans++;
		x = fa[x][0];
		y = fa[y][0]; 
	}
	if(cnt[x] == 0) ans++;
}
signed main(){
	cin>>n>>m;
	for(int i = 1; i<n; i++){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	dfs(1,0);
	for(int i = 1; i<=m; i++){
		int x,y,LCA;
		cin>>x>>y;
		LCA = lca(x,y);
		cnt[x]++;
		cnt[y]++;
		cnt[LCA]--;
		cnt[fa[LCA][0]]--;
	}
	Get(1,0);
	int x,y;
	cin>>x>>y;
	solve(x,y);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Wind_love (赞：0)

场切了，写一个题解。
### 思路
读题，注意到题中是一棵树，所以每两个点之间的路径是唯一的。  

题中要求，对于一个节点，断掉该点后，好点对联通，坏点对不连通，所以我们很容易想到一个思路，即遍历两个坏点对之间的路径，标记为可删，接着遍历所以好点对之间的路径，标记为不可删，最终统计可删点个数即可。 

显然，该做法时间超限，我们继续思考，两点间的路径在树上就是这两点到它们最近公共祖先的路径，复杂度可行，带入如上思路，可以通过本题。  

进行一些细节上的说明，坏点对因为唯一，所以可以直接用深搜处理，标记坏点对路径上的店，如果不会写传统 lca，可以通过并查集向上合并的方式实现，每向上合并一次就把对应标记清零，最终统计有标记点的个数即可。

---


# 面包题

## 题目背景

面包（bread）

## 题目描述

从 $1 \sim n$ 的自然数中选出若干个数（可以不选），满足以下条件：

- 若选择了 $x$，则不能选择 $kx$。

求总共有多少种选法（不考虑顺序）。

答案需要**对** ${998244353}$ **取模**。

## 说明/提示

### 样例解释

对于第一组数据，满足条件的 $S$ 有 $\varnothing,\{1\},\{1,3\},\{1,4\},\{1,3,4\},\{2\},\{2,3\},\{3\},\{3,4\},\{4\}$，共 $10$ 种 $S$ 满足上述条件。

对于第二组数据，满足条件的 $S$ 有 $\varnothing,\{1\},\{2\}$，共 $3$ 种 $S$ 满足上述条件。

对于第三组数据，任意满足 $S\subseteq\{1,2,3,\dots,10\}$ 的 $S$ 都符合条件，因此答案为 $2^{10}=1024$。

### 数据范围

对于 $20\%$ 的数据：$1\leq T\leq 10$，$2\leq n,k \leq 15$

对于 $40\%$ 的数据：$1\leq T\leq 10^2$，$2\leq n,k \leq 10^5$

对于 $100\%$ 的数据：$1\leq T\leq 10^5$，$2\leq n,k \leq 10^9$


## 样例 #1

### 输入

```
3
4 2
2 2
10 20```

### 输出

```
10
3
1024```

# 题解

## 作者：chenzhaoxu2027 (赞：6)

十分有意思啊。

我们不妨设一个有 $n$ 个点的无向图，点 $i$ 和点 $j$ 有边（$i<j$）当且仅当 $j = i \times k$。

显然这个图是由很多连通块，每一个连通块都是一根链构成的图。题设中的条件等价于在图中选点使得点不相邻，就是独立集方案数。

每一根链可以分开算，最后再乘法原理乘起来。那么问题就剩两个了：

- 如何求出一个长度为 $n$ 的链的独立集方案数？

- 如何求出有几根长度为 $j$ 的链？

第一个问题可以简单的 DP，设 $f[i]$ 表示长度为 $i$ 的独立集方案数。则要么选第 $i$ 个点，此时有 $f[i-2]$ 种方案；要么不选第 $i$ 个点，此时有 $f[i-1]$ 种方案。多以 $f[i]=f[i-1]+f[i-2]$（就是斐波那契数）。

对于第二个问题，你会发现长度至少为 $i$ 的链上的点的个数就是那些能被 $k^{(i-1)}$ 整除的数。这种数可以 $O(\log_2 n)$ 的计算出来。

紧接着做差分就可以计算出来长度恰好为 $i$ 的链的个数。然后快速幂加乘法原理求解即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 998244353
int n,k;
vector<int> vec;
int dp[100005];
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1){
			res*=a;
			res%=mod;
		}
		a*=a;
		a%=mod;
		b>>=1;
	}
	return res;
}
void slv(){
	cin>>n>>k;
	vec.clear();
	vec.push_back(0);
	int tmp=n;
	while(tmp){
		vec.push_back(tmp-tmp/k);//计算出有几根链长度至少为 i
		tmp/=k;
	}
	for(int i=1;i<vec.size()-1;i++){
		vec[i]-=vec[i+1];
	}
	int ans=1;
	for(int i=1;i<vec.size();i++){
		ans*=qpow(dp[i],vec[i]);
		ans%=mod;
	}
//	cout<<"\n";
	cout<<ans<<"\n";
}
signed main(){
	dp[1]=2;
	dp[0]=1;
	for(int i=2;i<=10005;i++){
		dp[i]=dp[i-1]+dp[i-2];
		dp[i]%=mod;
	}
	int t;
	cin>>t;
	while(t--){
		slv();
	}
	return 0;
}
/*
1 1 2 3 5 8 13 21
*/
```

---

## 作者：complete_binary_tree (赞：2)

手模一下不难发现，如果 $i$ 和 $ki$ 连边，那么会出现一些链。

以 $n=10,k=2$ 为例：

```
1 -> 2 -> 4 -> 8
3 -> 6
5 -> 10
7
9
```

由于对其中一条链进行选取不影响其它链的选取，根据乘法原理，答案就是这些链的方案之积。

考虑如何求单条链的方案。显然长为 $n$ 的链的方案数是 $\text{Fib}_{n+1}$（$\text{Fib}$ 表示斐波那契数列，且 $\text{Fib}_0=\text{Fib}_1=1$，下同）。

:::info[推导]
显然方案数只和链的长度有关。记 $f_i$ 为第 $i$ 个点**不选**的方案数，则长度为 $n$ 的链的方案数就是 $f_{n-1}$。

显然 $f_i=f_{i-1}+f_{i-2}$，因为可以选上一个（$f_{n-2}$），也可以不选（$f_{n-1}$），边界条件 $f_0=1$，$f_1=2$。所以 $f_i = \text{Fib}_{i+1}$。
:::

现在考虑如何求每条链的长度。显然链的条数很多，直接求会 T 飞，考虑求出每一个长度有多少条链。

回到刚刚的 $n=10,k=2$ 的例子，但是我们把它反过来，再补全：

```
10 <- 5
9
8 <- 4 <- 2 <- 1
7
6 <- 3
5
4 <- 2 <- 1
3
2 <- 1
1
```

我们发现能被 $k$ 整除的数只有 $\left \lfloor \frac nk \right\rfloor$ 个，也就是说这 $n$ 个数中有 $\left \lfloor \frac nk \right\rfloor$ 个数会被另一个数连接。此时我们把 $\left \lfloor \frac nk \right\rfloor$ 当作下一层的 $n$ 继续递归求解就可以得到每层有多少个数会被连接。

此时我们发现这个做法会算重，例如 `8 <- 4 <- 2 <- 1`、`4 <- 2 <- 1` 和 `2 <- 1` 都属于 `8 <- 4 <- 2 <- 1`，但是它对上面这四种情况都做了贡献。

此时我们要做两次差分来保证正确性。

:::info[为什么要做两次差分？]

- 第一次差分：由于第 $i$ 层包含了第 $i+1$ 层的结果，现在要去除重复计算的结果。

此时上面那张图会变成这样：

```
层 1：
10 <- 5
9
8 <- 4 <- 2 <- 1
7
6 <- 3
层 2：
(10 <- )5
(8 <- )4 <- 2 <- 1
(6 <- )3
层 3：
(8 <- 4 <- )2 <- 1
层 4：
(8 <- 4 <- 2 <- )1
```

然而此时还是算重了，而我们想把长为 $i$ 的链放在第 $i$ 层，所以我们再做一次差分：

- 第二次差分：把长度 $>i$ 的链踢出第 $i$ 层。

此时上面那张图会变成这样：

```
层 1：
> 长为 2，舍去 //10 <- 5
9
> 长为 4，舍去 //8 <- 4 <- 2 <- 1
7
> 长为 2，舍去 //6 <- 3
层 2：
(10 <- )5
> 长为 4，舍去 //(8 <- )4 <- 2 <- 1
(6 <- )3
层 3：
> 长为 4，舍去 //(8 <- 4 )<- 2 <- 1
层 4：
(8 <- 4 <- 2 )<- 1
```

此时每一层存放的都是长度为该层下标的链了。
:::

最后，由于我们求出的是长为 $i$ 的链有多少条，而每一条链都有 $\text{Fib}_{i+1}$ 种选法，所以对于长度为 $i$ 的链要乘上 $\text{Fib}_{i+1}^{\text{cnt}_i}$（其中 $\text{cnt}_i$ 表示长度为 $i$ 的链的条数）。

时间复杂度 $O(T\log_kn\log_2n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=55,mod=998244353; //显然斐波那契数列第 50 项就大于 1e9 了
int f[N],cnt[N],t,n,k;
int ksm(int a,int b){
	ll ans=1,x=a;
	while(b){
		if(b&1)ans=ans*x%mod;
		x=x*x%mod,b>>=1;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	f[0]=1,f[1]=2; //这里直接下标 +1，后面就不用 +1 了
	for(int i=2;i<=50;++i)f[i]=(f[i-1]+f[i-2])%mod;
	cin>>t;
	for(;t--;){
		cin>>n>>k;
		memset(cnt,0,sizeof cnt); //多测不清空，_____
		int i=0;
		for(;n;){
			cnt[++i]=n;
			n/=k;
		}
        //两次差分，注意差分顺序
		for(int j=1;j<=i;++j)cnt[j]=cnt[j]-cnt[j+1];
		for(int j=1;j<=i;++j)cnt[j]=cnt[j]-cnt[j+1];
		ll ans=1;
		for(int j=1;j<=i;++j)ans=ans*ksm(f[j],cnt[j])%mod; //统计答案
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：ysgosv9 (赞：2)

一道有趣的数论题。

我们来确定一下思路，让我们把所有数字按照 $k$ 的关系分类，例如：$n = 16, k = 2$ 的情况：

我们将数据分类为：

```
1 2 4 8 16
3 6 12
5 10
7 14
9
11
13
15
```

观察每一组的最后一个数，我们可以发现各组的取数是相互独立的，在题目的约束内互不影响。

每组的个数跟他们最大的 $k$ 次幂有关，比如第 $1$ 组的末尾数 $16$ 能整除 $k^4$，所以第 $1$ 组有 $5$ 个数。再比如第 $2$ 组的 $12$ 能整除 $k^2$，所以第 $2$ 组有 $3$ 个数等。

所以我们可以使用差分的方法，得到每一组长度的个数。

而每一组能取得种类数，对第 $i$ 个数而言，取的情况只有 $2$ 种，易得 $g(i) = g(i - 1) + g(i - 2)$ 的结论，而这个结论正是斐波那契数列。

综上，可以先预处理出所需的斐波那契数列，然后再 $a$ 数组里面运用桶的思想，统计具有 $i$ 个数字的组的个数，结果就是 $\prod _{i = 0}^{m} F(i)$ （其中 $m$ 为最长组的长度）。

### AC CODE:

 
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 998244353;//模数 

int fib[49];//大致枚举到40就可以了 
int a[109];
int Better_Power(int x, int k)//快速幂模板 
{
    int res = 1;
    while (k > 0)
	{
    	if (k & 1)
		{
    		res = res * x % mod;
		}
		x = x * x % mod;
		k >>= 1;
	}
	return res;
}
void solve()
{
	int n, k;
	cin >> n >> k;
	memset(a, 0, sizeof(a));//这一步必须要初始化 
	int ans = 1;
	int mx = 1;//分类数字的最大长度 
	while (n != 0)//对数字开始分类 
	{
		a[mx] = n;
		mx++;
		n /= k;
	}
	for (int _ = 0; _ < 2; _++)//重复执行两遍差分，用于分类每一种长度的个数。 
	{
		for (int i = 1; i <= mx; i++)//差分 
		{
			a[i] = a[i] - a[i + 1];
		}
	}
	for (int i = 1; i <= mx; i++)
	{
		if (a[i] != 0)
		{
			ans = ans * Better_Power(fib[i], a[i]) % mod;//统计答案 
		}
	}
	cout << ans << "\n";	
}
signed main()
{
	int t;
	cin >> t;
	fib[0] = 1;
	fib[1] = 2;//斐波那契数列构造 
	for (int i = 2; i <= 40; i++)//同上 
	{
		fib[i] = (fib[i - 1] + fib[i - 2]) % mod;
	}
	while (t--)
	{
		solve();
	}
	return 0;
} 
```

---

## 作者：lrqcs (赞：1)

## soltion
设 $f_i$ 为从 $i$ 到 $i\times k^{x_{\max}},x\in \mathbb{Z^+}$ 且 $i\times k^{x}\le n$ 的方案数，显然最终答案如下：
$$\frac{\prod_{i=1}^{n}f_i}{\prod_{i=1}^{\lfloor \frac{n}{k}\rfloor}f_i}$$  
易知 $f_n=2$，如果 $(i-1)\times k>n$ 则 $f_{i-1}=2$。

如果 $\lfloor\log_{k}{\frac{n}{i}}\rfloor\geq1$，则 $f_i=\operatorname{fib}_{\lfloor\log_{k}{\frac{n}{i}}\rfloor+2}$，其中 $\operatorname{fib}_{i}$ 为 Fibonacci 数列的第 $i$ 项（此处默认 $\operatorname{fib}_{0}=\operatorname{fib}_{1}=1$）。  
（实际上 $\lfloor\log_{k}{\frac{n}{i}}\rfloor=0$ 时也可以，此时 $f_i=\operatorname{fib}_{2}=2$）

注意到选择了 $i$ 就无法选 $i\times k$，但可以选 $i\times k^2$，而没选择 $i$ 就可以选 $i\times k$，于是 $f_i=f_{i\times k}+f_{i\times k^2}$，且 $f_{i\times k^{x_{\max}}}=2=\operatorname{fib}_{2}$，则可推出上式。

预处理出 $\operatorname{fib}_0$ 到 $\operatorname{fib}_{49}$（$\geq10^9$），接着处理每个 $f$，统计输出即可。

最后别忘了整除分块，详见代码。
## code
```cpp
#include<stdio.h>
#define ci const int
#define int long long
#define getchar getchar_unlocked
#define mod 998244353ll
inline ci re();void pr(ci x);void prn(ci x);
inline ci fpow(int a,int b=mod-2,ci md=mod){
	int c=1;
	while(b){
		if(b&1)c=c*a%md;
		a=a*a%md,b>>=1;
	}return c;
}
int n,k;
int f[66];
void work(){
	int p=0,m=1,ans=1,lst=0,len=0;
	for(n=re(),k=re();m*k<=n;++p)m*=k;
	while(1){
		len=n/m-n/(m*k);
		//端点区间为[n/(m*k)+1,n/m]
		ans=ans*fpow(f[p+2],len-lst)%mod;
		if(m==1)break;
		m/=k;--p;lst=len;
		/*
		注意到没被覆盖的数的数量为该层总数-上一层总数，
		因为上一层的一个数能且只能覆盖下一层的一个数。
		*/
	}prn(ans);
}
signed main(){
	f[0]=f[1]=1;
	for(int i=2;i<50;++i)f[i]=f[i-1]+f[i-2];
	for(int T=re();T--;)work();
}
void pri(ci x){if(x>9)pri(x/10);putchar(x%10^48);}
void pr(ci x){if(x<0)putchar('-'),pri(-x);else pri(x);}
void prn(ci x){pr(x);putchar(10);}
inline ci re(){
	int x=0;char c=getchar(),f=0;
	while(c<48||c>57)f|=(c=='-'),c=getchar();
	while(c>47&&c<58)x=x*10+(c^48),c=getchar();
	return f?-x:x;
}
```

时间复杂度 $O(T\log_{k}n\log_{2}n)=O(T\log^2 n)$ 且跑不满，空间复杂度 $O(\log n)$。

---


# 寒假作业

## 题目背景

zzs 和 zzy 正在被寒假作业折磨，然而他们有答案可以抄啊。


## 题目描述

他们共有 $n$ 项寒假作业。zzy 给每项寒假作业都定义了一个疲劳值 $a_i$，表示抄这个作业所要花的精力。

zzs 现在想要知道，有多少组连续的寒假作业的疲劳值的平均值不小于 $k$？

简单地说，给定一个长度为 $n$ 的正整数序列 $\{a_i\}$，求出有多少个**连续**子序列的平均值不小于 $k$。


## 说明/提示

#### 样例 1 解释

共有 $6$ 个连续的子序列，分别是 $(1)$、$(2)$、$(3)$、$(1,2)$、$(2,3)$、$(1,2,3)$，平均值分别为 $1$、$2$、$3$、$1.5$、$2.5$、$2$，其中平均值不小于 $2$ 的共有 $4$ 个。

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$。
- 对于 $50\%$ 的数据，保证 $n \leq 5000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i,k \leq 10^4$。

## 样例 #1

### 输入

```
3 2
1
2
3
```

### 输出

```
4```

# 题解

## 作者：ghj1222 (赞：28)

非常简单的cdq分治

先把所有数-=k，转化为平均数>=0的区间数量

也就是区间和>=0的区间数量

对于区间[l, r]内部所有区间的贡献，令区间中点为mid，先计算[l, mid]和[mid + 1, r]的所有贡献，然后再计算[l, r]内所有跨过区间中点mid的区间贡献就行

跨过中点的区间一定是$i\in[l,mid]$的一段[i, mid]和$j\in[mid + 1, r]$的一段[mid + 1, j]组成，我们前面求后缀和后面求前缀和把所有上述区间和搞出来，然后分别排序双指针扫一遍就可以统计答案了

有前缀和转化为逆序对的做法，实质其实一样，都是cdq分治

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, k, a[100010];
int tmp[100010];

long long cdq(int l, int r)
{
	if (l == r) return a[l] >= 0;
	int mid = (l + r) / 2;
	long long ans = cdq(l, mid) + cdq(mid + 1, r);
	tmp[mid] = a[mid];
	tmp[mid + 1] = a[mid + 1];
	for (int i = mid - 1; i >= l; i--)
		tmp[i] = tmp[i + 1] + a[i];
	for (int i = mid + 2; i <= r; i++)
		tmp[i] = tmp[i - 1] + a[i];
	sort(tmp + l, tmp + mid + 1);
	sort(tmp + mid + 1, tmp + r + 1);
	for (int i = l, j = r; i <= mid; i++)
	{
		while (j > mid && tmp[i] + tmp[j] >= 0) j--;
		ans += r - j;
	}
	return ans;
}

int main()
{
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), a[i] -= k;
	printf("%lld\n", cdq(1, n));
	return 0;
}
```

---

## 作者：WanderingTrader (赞：16)

本题有多种方法，此处介绍树状数组与cdq分治两种。
### 题目分析
看到平均值无脑所有 $a_i\leftarrow a_i-k$。

于是题目转化为求出满足 $1\le x\le y\le n$ 且 $\sum\limits_{i=x}^ya_i\ge0$ 的 有序数对 $(x,y)$ 的个数。

把 $a_i$ 求一次前缀和（由于后面原 $a$ 数组已经没用所以直接覆盖上去），那么即求所有满足 $0\le x<y\le n$ 且 $a_y-a_x\ge0$ 的有序数对 $(x,y)$ 的个数。

因为 $a_y-a_x\ge0$，所以 $a_x\le a_y$，那么求得就是在 $[0,n]$ 范围内 $x<y$ 且 $a_x\le a_y$ 的数对个数，即**二维偏序**。

### 解法一 树状数组


类似[逆序对](/problem/P1908)的树状数组解法。维护一个数列 $A$，初始全为 $0$。从 $0$ 到 $n$ 枚举 $i$，对每个 $i$，将答案加上 $A$ 中下标 $-\infty$ 到 $a_i$ 的和。然后将 $A$ 中下标 $a_i$ 加上 $1$。

注意由于全部减去了 $k$，$a_i$ 可能为负数，需要离散化。总时间复杂度 $O(n\log n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int a[maxn],id[maxn],rk[maxn],bit[maxn],n,k;
LL ans;
bool cmpID(int u,int v){return a[u]<a[v]||(a[u]==a[v]&&u<v);}
int LSB(int x){return x&-x;}
void add(int x){for(;x<=n+1;x+=LSB(x)) ++bit[x];}
int query(int x)
{
	int sum=0;
	for(;x;x-=LSB(x)) sum+=bit[x];
	return sum;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i) scanf("%d",a+i); 
	for(int i=1;i<=n;++i) {a[i]+=a[i-1]-k; id[i]=i;}
	sort(id,id+n+1,cmpID);
	for(int i=0;i<=n;++i) rk[id[i]]=i+1;
	for(int i=0;i<=n;++i)
	{
		ans+=query(rk[i]);
		add(rk[i]);
	}
	printf("%lld\n",ans);
	return 0;
}
```
本人的离散化写法比较奇怪（为了省码量没有使用结构体），勿喷。

rk 数组表示 $a_i$ 在 $a$ 数组中是第几小的。为了避免相同数据，我们在数据相同时加入下标的大小判断。

此外，由于此题中 rk 数组出现了 $0$，而 $0$ 是不可以出现在树状数组的下标中的，所以我们将 rk 数组全部加上 $1$。add函数中的上界也要相应的加上1。

### 解法二 cdq分治
首先我们回忆一下用归什么排序解决逆序对问题的简要步骤：
1. 将原序列划分为 $[l,mid]$ 和 $(mid,r]$ 两部分。
2. 递归求解 $[l,mid]$ 和 $(mid,r]$ 两个区间内部的逆序对，并将它们进行排序。
3. 在合并序列的同时计算跨两个区间的逆序对。

本题其实是一样的 ~~众所周知cdq分治本质上就是归什么排序的扩展延伸~~
1. 将原序列划分为 $[l,mid]$ 和 $(mid,r]$ 两部分。
2. 递归求解 $[l,mid]$ 和 $(mid,r]$ 两个区间内部的偏序，并将它们进行排序。
3. 在合并序列的同时计算跨两个区间的偏序。

和归什么排序一样，定义 $cdq(l,r)$ 为对区间 $[l,r]$ 进行求解

如果 $l=r$ 则回溯，否则递归求解左右两部分。

```cpp
	if(l==r) return;
	int mid=(l+r)>>1,i=l,j=mid+1,k=l;
	cdq(l,mid); cdq(mid+1,r);
```
维护双指针 $i,j$，分别对应区间的左半部分和右半部分。

对每个 $j$，将 $i$ 不断右移直到 $a_i>a_j$ （不满足偏序关系）。由于左右两边已经有序，所以 $i$ 不需要清零，总共最多右移 $mid-l+1$ 次，提高了时间效率。

在右移的过程中将 $a_i$ 放入临时数组，完成合并。

那么对这个 $j$，从 $l$ 到 $i-1$ 都能和 $j$ 构成偏序关系，因此答案加上 $(i-1)-(l-1)=i-l$。同时将 $a_j$ 放入临时数组。
```cpp
	for(j=mid+1;j<=r;)
	{
		while(i<=mid&&a[i]<=a[j]) t[k++]=a[i++];
		t[k++]=a[j++];
		ans+=i-l;
	}
```
操作结束后，右半部分已经进入临时序列，但左半部分可能并没有，所以一定要记得收个尾。然后将临时数组拷贝回 $a$ 数组即可。
```cpp
	for(;i<=mid;) t[k++]=a[i++];
	for(i=l;i<=r;++i) a[i]=t[i];
```
cdq函数如下：
```cpp
void cdq(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)>>1,i=l,j=mid+1,k=l;
	cdq(l,mid); cdq(mid+1,r);
	for(j=mid+1;j<=r;)
	{
		while(i<=mid&&a[i]<=a[j]) t[k++]=a[i++];
		t[k++]=a[j++];
		ans+=i-l;
	}
	for(;i<=mid;) t[k++]=a[i++];
	for(i=l;i<=r;++i) a[i]=t[i];
}
```
主函数调用 $cdq(0,n)$ 即可。总时间复杂度 $O(n\log n)$。

### 后记
![](https://cdn.luogu.com.cn/upload/image_hosting/uvfzb77s.png)

上面一行为树状数组的提交记录，下面一行为cdq分治的提交记录。

可以看到cdq完美碾压树状数组。

这不难理解。树状数组因为要离散化，时间差不多有两个 $n\log n$，空间上多开了两个数组，自带的三件套（`LSB`,`add`,`query`）也导致码量不可避免的变长。

但是，树状数组最大的优点就是：好想，好写，不易写挂。我一开始写的cdq分治犯了几个sb错误，结果过了样例但爆了零。

所以能用树状数组还是尽量用吧。

$$\texttt{The End.}$$

---

## 作者：ADay (赞：14)

[更逊的阅读体验](https://www.cnblogs.com/aday526/p/solution-p2717.html)

## Solution

先把 $a_i$ 都减 $k$，那么问题就变为求和 $\ge0$ 的子串个数。

然后再把减去了 $k$ 的 $\{a\}$ 做前缀和，记为 $\{s\}$，问题又变为求满足 $s_i-s_j\ge0(i>j)$ 的 $(i,j)$ 的个数也就是 $\{s\}$ 的**顺序对**个数，用树状数组或归并排序求就好了 。

因为我用的是树状数组且没离散化，复杂度为 $\mathcal O(n\log10^9)$

## Code

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define ll long long
using namespace std;
using namespace __gnu_pbds;
const int N=1e5+5;
int n,mins=1e9,k,s[N];
ll ans;
gp_hash_table<int,int>c;//pbds的哈希表
inline void add(int x){for(;x<=1e9;x+=x&-x)c[x]++;}
inline ll ask(int x){ll res=0;for(;x;x-=x&-x)res+=c[x];return res;}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",s+i),mins=min(mins,s[i]+=s[i-1]-k),ans+=(s[i]>=0);//统计j=0的情况
    for(int i=1;i<=n;i++){
        s[i]-=mins-1;//使每个Si都>0
        ans+=ask(s[i]);
        add(s[i]);
    }printf("%lld\n",ans);//答案可能爆int
    return 0;
}
```
注意答案可能爆 $\text{int}$，也证明作业不是 $\text{int}$ 能存下的


---

## 作者：Wou_Red (赞：10)

## 比较暴力的思路...

#### 求平均值大于等于k的区间个数
对于平均值的处理，可以把a[i]-k，这样问题就转换为求出区间和大于等于0的区间个数

#### 考虑暴力
枚举每个区间的右端点（或者左端点），枚举相应的区间。时间复杂度O(n^2)

#### 优化
枚举右端点之后，考虑怎么快速求出左边区间和大于等于0的个数

定义一个全局变量All表示当前以i为右端点的前缀和，用一个vector维护当前右端点对应的所有左端点+All表示某段区间和

这样每次只要求出vector中b+All>=0的个数，很容易想到二分。

用lower_bound+insert保证插入后vector有序。

考虑插入 对于当前位置j,j到i的区间和
表示为sum[i]-sum[j-1]。而sum[j-1]就是当前枚举到j还没有加上a[j]的All。

时间复杂度O(n*√n)

代码奇短....

Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
vector<ll> b;
const int N=4e5+10;
ll All,k,a[N],Ans;
int n;
int main() {
	scanf("%d%lld",&n,&k);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),a[i]-=k;
	for(int i=1;i<=n;i++) {
		b.insert(lower_bound(b.begin(),b.end(),-All),-All);
		All+=a[i];
		int p=b.end()-lower_bound(b.begin(),b.end(),-All);
		Ans+=p;
	}
	printf("%lld\n",Ans);
	return 0;
}
```


---

## 作者：Tenshi (赞：7)

分治裸题

## 分析
推一下~~柿子~~式子：
无非就是要求有多少对 $[l,r]$ ，满足：

$\frac{S_r-S_{l-1}}{r-l+1}\geq k$ ，这里 $1\leq l\leq r\leq n $ 。

做个变换，将 $l-1$ 换成 $l$ ，同时式子也做恒等变形。

变为求有多少对 $[l,r]$ ，满足：

$S_r-kr \geq S_l-kl$ ，这里 $0\leq l<r\leq n$ 。

记 $v[x]=S_x-kx$

然后就是二维偏序问题了，二维属性分别是**下标、v值**。

那我们就做个分治，然后一边归并排序一边统计贡献即可。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;
const int N=1e5+5;
int n,k;
int v[N], tmp[N];

ll res=0;
void cdq(int l,int r){
	if(l>=r) return;
	int mid=l+r>>1;
	cdq(l,mid), cdq(mid+1,r);
	
	ll sum=0;
	for(int i=l, j=mid+1, k=l; k<=r; k++)
		if(j>r || i<=mid && v[i]<=v[j]) sum++, tmp[k]=v[i++];
		else res+=sum, tmp[k]=v[j++];
	for(int k=l; k<=r; k++) v[k]=tmp[k];	
}

int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>v[i], v[i]+=v[i-1];
	
	for(int i=1;i<=n;i++) v[i]-=k*i;
	
	cdq(0,n);
	
	cout<<res<<endl;
	
    return 0;
}
```

---

## 作者：夏色祭 (赞：5)

##没有P，我来补一发

##下个月就是NOIP了。。。刷道题练练手。。~~虽然初赛成绩还没出来~~

我们用一个前缀和sum[i]表示前i个数的总和**-k\*i**，那么可以得到当sum[i]>sum[j]（0<=j<i）那么j+1~i这个区间的平均值是>=k的。。。

然后对于每个i，我们只需要求有多少个j是满足条件的。。。

但是对于这个j的查找必须是log的，我一开始考虑的是用一个桶，然后用树状数组优化。。。

后来发现其实就是求顺序对。。。~~逛讨论看到dalao的回复想到的~~

但是由于那个sum[i]的值可能会很大，所以还需要离散一下。

还有一个：记得把sum[0]（sum[0]的值为0）加入的树状数组里面，具体怎么加，↓见代码

丑陋的code:


```cpp
var
  a,b,c,num:array[0..100001]of longint;
  n,m,i,j,x:longint;
  ans:int64;
  p:boolean;
procedure kp(l,r:longint);
var
  i,j,mid:longint;
  begin
    i:=l;
    j:=r;
    mid:=a[(l+r) >> 1];
    repeat
      while a[i]<mid do inc(i);
      while a[j]>mid do dec(j);
      if i<=j then 
        begin
          a[0]:=a[i];a[i]:=a[j];a[j]:=a[0];
          num[0]:=num[i];num[i]:=num[j];num[j]:=num[0];
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<r then kp(i,r);
    if l<j then kp(l,j);
  end;
function lowbit(x:longint):longint;
begin
  exit(x and (-x));
end;
procedure add(x:longint);
begin
  while x<=n do 
    begin
      inc(c[x]);
      x:=x+lowbit(x);
    end;
end;
function sum(x:longint):longint;
begin
  sum:=0;
  while x>0 do 
    begin
      inc(sum,c[x]);
      x:=x-lowbit(x);
    end;
end;//树状数组的维护
begin
  readln(n,m);
  for i:=1 to n do 
    begin
      read(x);
      inc(a[i],a[i-1]+x-m);
      num[i]:=i;
    end;
  b:=a;
  kp(1,n);
  j:=0;
  a[0]:=-2333333;
  p:=false;
  for i:=1 to n do
    begin
      if a[i]<>a[i-1] then 
        begin
          inc(j);
          b[num[i]]:=j;
        end
        else b[num[i]]:=j;
      if (a[i]>=0)and not p then 
        begin
          p:=true;
          add(j);
        end;//自己理解吧。。。
    end;//离散
  for i:=1 to n do 
    begin
      inc(ans,sum(b[i]));
      add(b[i]);
    end;//求顺序对
  write(ans);
end.

```

---

## 作者：wawcac (赞：4)

[广告](http://www.cnblogs.com/wawcac-blog/p/6914837.html)

先来简化一下题意：给定一个数列a[]，求有多少个子序列元素平均值大于等于k。


遍历所有子区间复杂度最小O(n^2)，可用前缀和O(1)得到任意区间和。


想个办法吧，这类题要么用奇奇怪怪的数据结构(可能有这样的数据结构?我不知道)，要么推公式。


那就推公式——


首先取出一段区间吧，设1<=i<=j<=n，然后这段区间（a[i]~a[j]）的平均值为



　　　　(a[i]+a[i+1]+…+a[j]) / (j-i+1)>=k

分母不太好看，乘到右边吧——




　　　　a[i]+a[i+1]+…+a[j] >= k\*(j-i+1)

　　　　a[i]+a[i+1]+…+a[j]>= k+…+k //(j-i+1)个k

接下来有点关键啦




　　　　a[i]+a[i+1]+…+a[j] - k-…-k>=0

　　　　(a[i]-k) + (a[i+1]-k) +……+ (a[j]-k)>=0//哦？那么整齐，有意思

那我们另设一个数组b[]，使b[i]=a[i]-k吧



　　　　b[i]+b[i+1]+…+b[j]>=0

哦？b[]的一段区间和大于等于零？


记得前面想暴力的时候说过用前缀和能O(1)取得任意区间和吗？给b[]套上区间和吧


设s[i]=b[1]+b[2]+b[3]+…+b[i]，特别的，令s[0]=0，那么b[i]+b[i+1]+…+b[j] = s[j]-s[i-1]。



　　　　s[j] - s[i-1]>=0

移项一下



　　　　s[j]>=s[i-1]，哇，快了。

因为之前定义过i<=j，所以i-1<j，这是什么？


是的没错！逆序对（大雾，应该叫顺序对的）！


i-1<j且s[i-1]<=s[j]，对s数组求逆序对顺序对即可。


不会求逆序对的就先掌握这个姿势吧，也挺简单的。


最后说一下，我不知道为什么把求逆序对的程序类比着改一下，求出来“顺序对”就是对的。反正套上去就AC了

[源代码](http://www.cnblogs.com/wawcac-blog/p/6914837.html)


---

## 作者：Arghariza (赞：3)

updated：更改了时间复杂度的错误。

P.S:这题才是 $\mathtt{CDQ}$ 分治入门题吧，比陌上花开啥的简单多了。

先令所有 $a_i$ 减上 $k$ ，做一遍前缀和，转换为统计满足 $s_i-s_{j-1}\ge 0,\ i\ge j$ 的无序对 $\{i,j\}$ 数量。

- $\mathtt{Solution\ 1}$ ：树状数组求逆序对即可。

- $\mathtt{Solution\ 2}$ ：

既然无序而且是统计点对，考虑 $\mathtt{CDQ}$ 分治。

考虑把 $i,j\in[l,r]$ 的答案拆分成 $i,j\in[l, mid],i,j\in[mid+1,r],i\in[l,mid]\ \&\ j\in[mid+1,r]$ 的答案。

对于 $i,j\in[l, mid],i,j\in[mid+1,r]$ 的情况我们递归求解 $cdq(l, mid)$ 和 $cdq(mid+1,r)$ 即可。

再考虑 $i\in [l,mid],j\in [mid+1,r]$ 对答案的贡献。

由于此时 $i<j$ ，所以相当于统计 $\sum\limits_{k=i}^{j}a_k\ge 0$ 的个数。

对 $a$ 从 $[l,mid]$ 做一次后缀和，从 $[mid+1,r]$ 做一次前缀和，分别排序即可。

因为后缀和意味着从第 $i$ 位加到 $mid$ ，前缀和意味着从第 $j$ 位加到 $mid+1$ ，两者相加保证了你选的区间是连续的。

同时有一个 $\mathtt{two\ pointers}$ 的思路：两边分别来一个 $p,q$ ，由于排序后前缀和和后缀和分别递增，所以随着 $p$ 往 $mid$ 的方向移动， $q$ 的移动也具有单调性。

最后统计 $r-q+1$ 即可。

分析一下时间复杂度：

$\begin{aligned}T(n)&=2T(\frac{n}{2})+2\times\frac{n}{2}\log_2\frac{n}{2}\\&=2T(\frac{n}{2})+n(\log_2n-1)\\&=2T(\frac{n}{2})+n\log_2n-n\end{aligned}$

忽略后面那个 $n$ ，应用主定理得复杂度 $O(n\log^2 n)$ 。

实际上比这快得多，但是跑不过树状数组 $O(n\log n)$。

好像说 $\mathtt{CDQ}$ 有 $O(n\log n)$ 的做法，但我不会。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e5 + 100;
int n, k, s[maxn], t[maxn];

int cdq(int l, int r) {
	if (l == r) return s[l] >= 0;
	int mid = (l + r) >> 1, res = cdq(l, mid) + cdq(mid + 1, r);
	t[mid] = s[mid], t[mid + 1] = s[mid + 1];
	for (int i = mid - 1; i >= l; i--) t[i] = s[i] + t[i + 1];
	for (int i = mid + 2; i <= r; i++) t[i] = s[i] + t[i - 1];
	sort(t + l, t + mid + 1), sort(t + mid + 1, t + r + 1);
	int p = l, q = r;
	while (p <= mid) {
		while (q > mid && t[p] + t[q] >= 0) q--;
		res += r - q;
		p++;
	}
	return res;
}

signed main() {
	scanf("%lld%lld", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%lld", &s[i]), s[i] -= k;
	printf("%lld", cdq(1, n));
	return 0;
}
```

---

## 作者：Otomachi_Una_ (赞：2)

## 解题思路

预处理时现将 $a_i\leftarrow a_i-k$，这样一个连续子段平均值不小于 $k$ 等价于 $\sum_{i=l}^ra_i\geq 0 $。

假设 $s_i$ 数组是处理过的 $a_i$ 的前缀和，我们只要找 $i>j,s_i\geq s_j$ 的 $(i,j)$ 个数即可。

这显然是正序对的个数，直接归并排序求解即可。

## 参考代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define ll long long
const int MAXN=1e5+5;
int n,k;
int a[MAXN];
ll s[MAXN];
ll ans=0;
void nxd(int l,int r){
	if(l==r) return;
	int mid=l+r>>1;
	nxd(l,mid),nxd(mid+1,r);
	int k=l-1;
	for(int i=mid+1;i<=r;i++){
		while(s[k+1]<=s[i]&&k<mid)
			k++;
		ans+=(k-l+1);
	}
	sort(s+l,s+r+1);
	return;
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s[i]=s[i-1]+a[i]-k;
	}
	nxd(0,n);
	cout<<ans<<endl;
	return 0;
} 
```

这个程序时间复杂度是 $\mathcal{O}(n\log^2n)$ 的，原因是原来的归并排序懒得写了，写成了一个伪归并。

---

## 作者：曦行夜落 (赞：2)

## 平衡树

看到平均数首先转化一下，变成$a[i]-k$

然后发现只要区间和是非负数就是合法区间

所以对于$[i,j]$满足$s_j-s_{i-1}>=0$即可

那么再做前缀和，对于$i∈[0,n)$的每个$i$统计$j>i$且$s_j>=s_i$的个数

然后发现区间统计排名，可以平衡树来做

于是就快乐的拿平衡树过了这题

说句闲话：研究作业的最好方法就是

A了这道题

祝你们成功（滑稽

```cpp
#include<bits/stdc++.h>
#define maxn (100000+500)
#define int long long
using namespace std;
int R=0,sz[maxn],son[maxn][2],rd[maxn],num[maxn],v[maxn],tot=0,n,k,a[maxn],s[maxn];
void pushup(int p) { sz[p]=sz[son[p][0]]+sz[son[p][1]]+num[p]; }
void rotate(int &p,int d)
{
	int k=son[p][d^1]; son[p][d^1]=son[k][d],son[k][d]=p;
	pushup(p),pushup(k),p=k;
}
void ins(int &p,int x)
{
	if (!p) p=++tot,sz[p]=num[p]=1,v[p]=x,rd[p]=rand();
	else if (v[p]==x) sz[p]++,num[p]++;
	else
	{
		int d=(x>v[p]); ins(son[p][d],x);
		if (rd[p]<rd[son[p][d]]) rotate(p,d^1);
		pushup(p);
	}
}
int rank(int p,int x)
{
	if (!p) return 0;
	if (v[p]==x) return sz[son[p][0]]+1;
	else if (v[p]<x) return sz[son[p][0]]+num[p]+rank(son[p][1],x);
	else return rank(son[p][0],x);
}

signed main()
{
	srand(time(0));
	scanf("%lld%lld",&n,&k); for (int i=1;i<=n;++i) scanf("%lld",&a[i]),a[i]-=k;
	for (int i=1;i<=n;++i) s[i]=s[i-1]+a[i]; ins(R,s[n]);
	int Ans=0;
	for (int i=n-1;i>=0;--i)
	{
		ins(R,s[i]); int rk=rank(R,s[i]);
		Ans+=(n-i+1)-rk;
	}
	printf("%lld\n",Ans);

	return 0;
}
```

---

## 作者：JK_LOVER (赞：2)

## 题意
给你一串长度为 $n$ 的序列，求其中有多少个连续子序列的平均值大于等于 $k$ 。[qwq](https://www.luogu.com.cn/blog/xzc/solution-p2717)
## 分析
直接做是 $O(n^2)$ 的，考虑优化。
$$
ans = \sum_{1\le L\le R\le n} [\sum_L^R a[i] \ge k \times (R-L+1)]
$$
$$
ans = \sum_{1\le L\le R\le n} [\sum_L^R(a[i]-k) \ge 0]
$$
$$
sum[n] = \sum_{i = 1}^n(a[i] -k)
$$
$$
\Rightarrow ans = \sum_{1\le L\le R\le n}[sum[R] \ge sum[L-1]]
$$
推到这步，想必大家已经知道到了，这就是求逆序对。只需要满足
$$
L\le R \ \&\& \ sum[L-1] \le sum[R]
$$
就可以对答案有贡献，上面的 $L\le R$ ，是要取等号的。所以先插入一个 $0$ 。 
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N = 410010;
int read(){
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
const int inf = 1020100;
int n,k,sum[N],t[N],b[N];
void add(int x,int d)
{
	for(int i = x;i <= inf;i += (i&-i)) t[i] += d;
}
int ask(int x)
{
	int tot = 0;
	for(int i = x;i;i -= (i&-i)) tot += t[i];
	return tot; 
}
signed main()
{
	n = read(),k = read();
	sum[0] = 0;
	for(int i = 1;i <= n;i++)
	{
		sum[i] = sum[i-1] + read() - k;
		b[i] = sum[i];
	}
	sort(b,b+1+n);
	int size = unique(b,b+1+n) - b;
	for(int i = 0;i <= n;i++)
	sum[i] = lower_bound(b,b+1+size,sum[i]) - b + 1;
	long long ans = 0;
	add(sum[0],1);
	for(int i = 1;i <= n;i++)
	{
		ans += ask(sum[i]);
//		cout<<sum[i]<<endl;
		add(sum[i],1);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：Fairicle (赞：1)

好像有巨大多种做法.

我的做法是考虑分治 $solve(l,r)$，按套路去考虑跨越 mid 的贡献，显然是选取 $[l,mid]$ 的一段后缀加上 $[mid+1,r]$ 的一段前缀。

计后缀和为 $s_1$，长度为 $len_1$，前缀和为 $s_2$，长度为 $len_2$。

则有 $\dfrac{s_1+s_2}{len_1+len_2}\ge k$，即 $s_2-klen_2\ge klen_1-s_1$，我们只需要把所有的 $klen_1-s_1$ 丢到一个数组并将它排序（或者使用 $\text{multiset}$） 即可。

这部分的 code：

```cpp
inline void solve(int l,int r){
    if(l==r) {ans+=(a[l]>=k);return;}
    int mid=(l+r)>>1;
    solve(l,mid),solve(mid+1,r);
    int sum=0,len=0;
    top=0;
    for(ri i=mid;i>=l;--i) sum+=a[i],len++,tmp[++top]=k*len-sum;
    sort(tmp+1,tmp+1+top);
    sum=0,len=0;
    for(ri i=mid+1;i<=r;++i) sum+=a[i],len++,ans+=upper_bound(tmp+1,tmp+1+top,sum-k*len)-tmp-1;
}
```
时间复杂度 $O(nlog^2n)$.

做法 2，巧妙转化

考虑把所有数都减去 $k$，那么就相当于找有多少个非空子段和大于等于 $0$. 即 $s_j>=s_i(0\leq i< j\leq n)$ 的数量，这个离散化之后树状数组或者直接像上面一样扔进 $\text{multiset}$ 也可，时间复杂度 $O(nlogn)$.

做法 3，单刀直入

直接由题意，有 $\dfrac{s_j-s_i}{j-i}\ge k(0\leq i< j\leq n)$，得到 $s_j-jk\ge s_i-ik$，所以维护 $b_i=s_i-ik$ 即可。

~~综上所述分治是多此一举的行为~~

---

## 作者：Mr_Leceue (赞：1)

~~感觉这题题解好少啊,于是我就来水题解了~~

------------

这道题实际难度真心不难,评为蓝可能就是因为用树状数组优化了一下,其他的并不难想.

一段区间平均值不小于k,一看像分治,但是仔细一看有更简单的做法.

考虑公式 $\sum_{i}^{j} a_{i}/(j-i+1) >= k$

想到初步做法,枚举$i$和$j$,用前缀和优化求和过程,时间复杂度$O(n^{2})$

但是我们的目的是AC,那么继续考虑,将求和改为前缀和,那么公式可化为:
$(sum_{i}-sum_{j-1})/(i-j+1)>=k$

$sum_{i}-sum_{j-1}>=k*(i-j+1)$

考虑将带有相同下标的移至同一侧,这是为了保存信息方便

$sum_{i}-k*i>=sum_{j-1}-k*(j-1)$

我们可以发现两边形式相同,那么当等式成立时,该方案贡献+1;

这里限制条件$i>=j$

我们可以发现,这和逆序对的求法相似,我们用数组$a_{i}$保存$sum_{i}-k*i$,每次按顺序插入树状数组,再查询,这里用到了离散化,原因有2:
1.数值可能很大
2.有负数和0;
细节:记住提前插入0,因为区间长度可以为1;
## **Code**

```cpp
#include<bits/stdc++.h>
#define maxn 100007
#define ll long long
using namespace std;
int n,k,sum[maxn],a[maxn],b[maxn];
ll ans;

struct tree{
	int tr[maxn<<1];
	int lowbit(int x){return x&(-x);}
	void add(int x,int k){for(;x<=n;x+=lowbit(x)) tr[x]+=k;}
	int query(int x){int ol=0;while(x) ol+=tr[x],x-=lowbit(x);return ol;}
}t;

template<typename type_of_scan>
inline void scan(type_of_scan &x){
	type_of_scan f=1;x=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}

int main(){
	scan(n),scan(k);
	for(int i=1,x;i<=n;i++)
		scan(x),sum[i]=x+sum[i-1],a[i]=sum[i]-k*i,b[i]=a[i];
	sort(b,b+1+n);
	int tot=unique(b,b+1+n)-b-1;
	for(int i=0;i<=n;i++)
		a[i]=lower_bound(b,b+1+tot,a[i])-b+1;
	t.add(a[0],1);
	for(int i=1;i<=n;i++){
		ans+=t.query(a[i]);
		t.add(a[i],1);
	}
	printf("%lld\n",ans);
}
```




---

## 作者：Utilokasteinn (赞：0)

## [Link](https://www.luogu.com.cn/problem/P2717)

读入时，先将所有数都减去 $k$。然后预处理出前 $i$ 个数的和 $sum_i$。

一个显而易见的结论：若 $sum_r-sum_{l-1}\ge 0$，则区间 $[l,r]$ 满足平均数大于等于 $k$。

对于一个 $r$，考虑有几个满足条件的 $l$。因为 $sum_r-sum_{l-1}\ge 0$ 满足条件，所以 $sum_r\ge sum_{l-1}$ 满足条件。所以我们只需要找区间 $[1,r-1]$ 中有几个 $sum$ 小于等于 $sum_r$。

考虑用权值线段树维护。

求出 $sum$ 后离散化，然后一边加一边统计就好了。

当然也可以用权值树状数组。

注意要开 ```long long```。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,k;ll ans;
int a[100005],b[100005];
struct segment_tree{
	int l,r;ll cnt;
}s[400005];
void build(int l,int r,int p)
{
	s[p].l=l,s[p].r=r;
	if(l==r)return;
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
}
ll query(int ql,int qr,int p)
{
	if(ql>s[p].r||qr<s[p].l)return 0;
	if(ql<=s[p].l&&s[p].r<=qr)
		return s[p].cnt;
	return query(ql,qr,p*2)+query(ql,qr,p*2+1);
}
void update(int pos,int p)
{
	if(pos>s[p].r||pos<s[p].l)return;
	if(s[p].l==s[p].r)
	{
		s[p].cnt++;
		return;
	}
	update(pos,p*2),update(pos,p*2+1);
	s[p].cnt=s[p*2].cnt+s[p*2+1].cnt;
}
int main()
{
	n=read(),k=read();
	for(int i=1;i<=n;i++)
		a[i]=read()-k;
	for(int i=1;i<=n;i++)
		a[i]=b[i]=a[i-1]+a[i];
	sort(b+1,b+n+1);
	int num=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(b+1,b+num+1,a[i])-b;
	build(1,num,1);
	for(int i=1;i<=n;i++)
	{
		ans+=query(1,a[i],1);
		update(a[i],1);
		if(b[a[i]]>=0)ans++;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：JWRuixi (赞：0)

~~无脑一点直接看标签不就完了吗？~~

- 题意：

一个序列 $s$，求平均数大于等于 $k$ 的连续子序列数量。

- 解法：

看完题目多半已经有思路了吧？

求的是平均数，又要求数量，想想应该跟子序列和有点关系，平均数这玩意其实可以随便网上拽或向下拉。

所以想到该序列元素都减 $k$，把目标平均数拽成 $0$，结合一下即子序列和大于等于 $0$ 的子序列数量。

想一下和的话用前缀和后缀处理，又考虑大小关系可以优化，所以打算用 cdq 分治，不会的参考我博客

1. 先处理 $l$ 到 $mid$ 和 $mid + 1$ 到 $r$ 的信息。
2. 在考虑处理 $l$ 到 $mid$ 对 $mid + 1$ 到 $r$ 的贡献，计算方法考虑后缀和前缀和相加大于零。

- code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

namespace q_wr {
	inline int read() {
		char c = getchar();
		int x = 0, f = 1;
		while (c < '0' || c > '9') {
			if (c == '-') f = -1;
			c = getchar();
		}
		while (c >= '0' && c <= '9') {
			x = (x << 1) + (x << 3) + c - '0';
			c = getchar();
		}
		return x * f;
	}
	inline void write(int x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
}

using namespace q_wr;

const int maxn = 1e5 + 50;

int n, k, a[maxn], s[maxn], ans;

void cdq (int l, int r) {
	if (l == r) { ans += (a[l] >= 0); return; }
	int mid = l + r >> 1;
	cdq(l, mid), cdq(mid + 1, r);
	s[mid] = a[mid], s[mid + 1] = a[mid + 1];
	for (int i = mid - 1; i >= l; i--) s[i] = s[i + 1] + a[i];
   //记录后缀。
	for (int i = mid + 2; i <= r; i++) s[i] = s[i - 1] + a[i];
   //记录前缀
	sort(s + l, s + mid + 1);
	sort(s + mid + 1, s + r + 1);
	for (int i = l, j = r; i <= mid; i++) {
		while (j > mid && s[i] + s[j] >= 0) j--;//应为已经排序，所以当前 s[i] + s[j] >= 0 则后续 i 皆满足。
		ans += r - j;
	}
}

signed main () {
	n = read(), k = read();
	for (int i = 1; i <= n; i++) a[i] = read() - k;//将平均数预处理成 0。
	cdq(1, n);
	write(ans);	
}
```

---

## 作者：Misaka_Mik0t0 (赞：0)

标签里有 cdq 分治，但实际上本题的解法是一个普通的分治。

首先要进行预处理。由于区间 $[l,r]$ 中“平均数不小于 $k$”，相当于 $\sum_l^ra_i\geq k\times(r-l+1)$。

稍微变形可得 $\sum_l^r(a_i-k)\geq0$。这样不等式右边变为了常数。如果预处理 $a_i\gets a_i-k$，不等式左边的形式也和之前一样。

为方便，本篇题解后面出现的 $a_i$ 均为题目中的 $a_i-k$。

如同开头所说的，本题是分治。

假设当前区间为 $[l,r]$，令 $rsg23(l,r)$ 为这个区间内连续子序列的平均值 $\geq0$的个数。

可以递归 $rsg23(l,mid),rsg23(mid+1,r)$ 求出这两个子区间内的连续子序列的数量（$mid=\left\lfloor\dfrac{l+r}{2}\right\rfloor$）。那么问题变成了连续子序列同时在这两个子区间中的个数。

我们不妨设这段连续子序列的两端分别为 $x,y$。那么，有 $\sum_x^{mid}a_i+\sum_{mid+1}^ya_i\geq0$。

即：$\sum_{mid+1}^ya_i\geq-\sum_x^{mid}a_i$。

我们可以先 $O(r-l)$ 地预处理出所有 $-\sum_x^{mid}a_i$ 和 $\sum_{mid+1}^ya_i$。令前者为 $f_x$，后者为 $g_y$。

那么问题变成了 $\sum_{x=l}^{mid}\sum_{y=mid+1}^r(g_y\geq f_x)$。

于是，有两种做法：树状数组、二分。

由于二分的代码更简洁，这里就只介绍二分的方法。

显然，$g$ 的顺序并不影响答案，所以可以先将其排序。我们可以枚举每个 $x$，在 $g$ 中二分找出第一个 $\geq f_x$ 的。那么，它和它之后的所有数全部满足 $\geq f_x$，可以直接统计答案。时间复杂度 $O((r-l)\log(r-l))$。

那么，总时间复杂度为 $O(n\log^2n)$。

提示：要开 `long long`！

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
const int maxn=100005;
const int maxm=10005;
int n,k,p[maxn],sum[maxn],ans;
void rsg23(int l,int r){
	if(l==r){
		if(p[l]>=0)++ans;
		return;
	}
	int mid=l+r>>1;
	rsg23(l,mid);
	rsg23(mid+1,r);
	sum[mid]=p[mid];sum[mid+1]=p[mid+1];
	for(int i=mid-1;i>=l;--i)sum[i]=sum[i+1]+p[i];
	for(int i=mid+2;i<=r;++i)sum[i]=sum[i-1]+p[i];
	sort(sum+mid+1,sum+r+1);
	for(int i=l;i<=mid;++i){
		int tmp=lower_bound(sum+mid+1,sum+r+1,-sum[i])-sum;
		ans+=r-tmp+1;
	}
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)scanf("%d",&p[i]);
	scanf("%lld",&k);
	for(int i=1;i<=n;++i)p[i]-=k;
	rsg23(1,n);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ricky0916 (赞：0)

题意：求有多少 $ (l,r) $ 使 $ \sum\limits_{i=l}^r a_i\ge k\times(r-l+1) $

容易想到将每个 $ a_i $ 减去 $ k $，令 $ a_i'=a_i-k $，则题目转化为求 $ \sum\limits_{i=l}^r a_i'\ge 0 $ 的 $(l,r)$ 对数。

令 $ s_m=\sum\limits_{i=1}^m a_i' $，容易发现是求 $ \{s_m\} $ 序列的顺序对（？）数，树状数组即可

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x;
}
void write(long long x){
	if(x/10) write(x/10);
	putchar(x%10+'0');
}
int n,k;
long long a[100010],ans,c[100010],b[100010];
void add(int x,int v){
	for(;x<=n+1;x+=x&(-x)) c[x]+=v;
}
long long sum(int x){
	long long ret=0;
	for(;x>0;x-=x&(-x)) ret+=c[x];
	return ret;
}
int main(){
	n=read();
	k=read();
	for(int i=1;i<=n;i++) a[i]=a[i-1]+read()-k;
	memcpy(b,a,sizeof(a));
	sort(b,b+n+1);
	int m=unique(b,b+n+1)-(b);
	for(int i=0;i<=n;i++){
		a[i]=lower_bound(b,b+m,a[i])-b+1;
	}
	for(int i=0;i<=n;i++){
		ans+=sum(n+1)-sum(a[i]);
		add(a[i],1);
	}
	write(1ll*n*(n+1)/2-ans);
	return 0;
}
```


---

## 作者：luckydrawbox (赞：0)

[$\text{Link}$](https://www.luogu.com.cn/problem/P2717)

## 福利

[双倍经验](https://www.luogu.com.cn/problem/P2804)

## 题意

一个长度为 $n$ 的区间 $a_{1\sim n}$，求其中有多少个**连续**子序列的平均数**不小于** $k$？

## 分析

首先我们知道：对于一个区间，如果每个数都减去 $k$，那么这个区间的平均数就会减少 $k$；同时，它的任意连续子区间的平均数都会减少 $k$。

既然这样，我们只需要令整个区间都减少 $k$，于是问题就转化成了：

>一个长度为 $n$ 的区间 $a_{1\sim n}$，求其中有多少个**连续**子序列的平均数**不小于** $0$？

既然一个连续子区间的平均数大于 $0$ ，那么这个连续子区间的和也大于 $0$，于是问题又简化了：

>一个长度为 $n$ 的区间 $a_{1\sim n}$，求其中有多少个**连续**子序列的和**不小于** $0$？

求和部分显然可以用[前缀和](https://oi-wiki.org/basic/prefix-sum/)计算 $s_i=\sum_{j=1}^i a_j=s_{i-1}+a_i$ 来解决（特别地，$s_0=0$），一个区间和 $[i,j]$ 可以转化为 $s_j-s_{i-1}$，问题再次变形：

>一个长度为 $n+1$ 的区间 $s_{0\sim n}$，求其中有多少对 $i,j(1\le i<j\le n)$ 使 $s_j-s_{i-1}\ge0$？

$s_j-s_{i-1}\ge0$ 显然相当于 $s_{i-1}\le s_j$，所以其实我们要求的就是**顺序对**（就是把[逆序对](https://www.luogu.com.cn/problem/P1908)反过来求）。

求顺序对的方法很多，这里提供一个**值域分块**做法，貌似比权值线段树好写一点。

## 代码

时间复杂度 $O(n\sqrt n)$，空间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
    long long x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=2e5+10;
int n;
ll m,a[N],s[500],len,v[N],sum;
int discrete(int n,ll *a){
    int b[N];
    for(int i=1;i<=n;i++)
        b[i]=a[i];
    sort(b+1,b+n+1);
    int tot=unique(b+1,b+n+1)-(b+1);
    for(int i=1;i<=n;i++)
        a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
    return tot;
}
ll ask(int w){
	int k=w/len;
	ll ans=0;
	for(int i=0;i<k;i++)
		ans+=s[i];
	for(int i=k*len;i<=w;i++)
		ans+=v[i];
	return ans;
}
void add(int w){
	v[w]++;
	s[w/len]++;
}
int main(){
	n=read()+1;m=read();//把下标从2开始统计，这样方面在前面插入0 
	for(int i=2;i<=n;i++)
		a[i]=read()-m+a[i-1];//把a数组直接当前缀和用 
	int tot=discrete(n,a);//离散化 
	len=sqrt(tot);
	add(a[1]);//插入0 
	for(int i=2;i<=n;i++){
		sum+=ask(a[i]);
		add(a[i]);
	}
	write(sum);
    return 0;
}
```


---

## 作者：Saber_Master (赞：0)

[P2717 寒假作业](https://www.luogu.com.cn/problem/P2717)

考虑利用前缀和维护.

设$s_i=\sum_{j=1}^i a_j$，则题目的条件就变成了这样：

$$\frac{s_i-s_j}{i-j}\geq k$$

即
$$s_i-s_j\geq k\cdot i-k\cdot j$$

也即
$$s_i-k\cdot i\geq s_j-k\cdot j$$

设$num[i]=s[i]-k \cdot i$，那么题目就是要问存在多少个点对$(j, i)$，使得$j<i$且$num_j<=sum_i$,这是一个典型的二维偏序，我们可以利用树状数组维护.具体维护过程如下：

先将$num$数组离散化，然后从左到右扫描，扫描到$i$的时候，先在树状数组内查询$[1, num_i]$的值并加进答案，然后在树状数组内将$[num_i, n]+1$即可.

有两个要注意的小地方:

1. 最后记得将$num_i\geq0$的部分也加进答案，这一部分也是有贡献的。

2. 记得开$long \   long$，不然只有$90$分.


```cpp
const ll N=1e5+5;

ll n, K;
ll num[N];
ll lsh[N], h;
namespace bit{
	ll f[N];
	
	inline void add(ll x, ll val){
		for (; x<=h; x+=x&-x) f[x]+=val;
	}
	
	inline ll ask(ll x){
		ll res=0;
		for (; x; x-=x&-x) res+=f[x];
		return res;
	}
}

long long res;
int main(){
	read(n); read(K);
	for (R ll i=1; i<=n; i++) read(num[i]), num[i]+=num[i-1];
	for (R ll i=1; i<=n; i++) num[i]-=K*i, lsh[i]=num[i];
	stable_sort(lsh+1, lsh+n+2);
	h=unique(lsh+1, lsh+n+2)-lsh-1;
	bit::add(lower_bound(lsh+1, lsh+h+1, 0)-lsh, 1);
	for  (R ll i=1; i<=n; i++){
		num[i]=lower_bound(lsh+1, lsh+h+1, num[i])-lsh;
		res+=bit::ask(num[i]);
		bit::add(num[i], 1);
	}
	writeln(res);
}
```


---

## 作者：zhengrunzhe (赞：0)

提供两种做法 一个cdq分治 还有一个直接用逆序对的做法

先直接推一下式子(我比较菜没想到能全部-k)

$\frac{sum[r]-sum[-1]}{r-l+1}\geq k \rightarrow sum[r]-sum[l-1]\geq k(r-l+1)$


$\therefore sum[r]-sum[l-1]\geq kr-k(l-1)$

移项得$k(l-1)-sum[l-1]\geq kr-sum[r]$

然后由于我是通过"cdq分治"这个标签点进这道题的，于是我就先写了个cdq分治

先考虑一个分治区间$[l,r]$

考虑其跨过$mid$的子区间的贡献

$x\in [l,mid],y\in [mid,r]$

我们把$x\in[l,mid]$的所有$k(x-1)-sum[x-1]$塞到一个数据结构里面，其支持插入 清空/删除 查询有多少个数比某个数大 ，由于我懒得离散化 就写了个平衡树(treap)

然后对于$y\in[mid,r]$的所有$ky-sum[y]$去平衡树里查询有多少个数比其大，累计答案

特别地，特判一下$l=r$和$r-l=1$的区间直接返回

分治到$[l,mid-1]$和$[mid+1,r]$两个子区间

看上去是两个log

实际上$T(n)=2T(n/2)+O(n \log n)$

根据主定理可知总复杂度为$O(n \log n)$只是常数大点
```cpp
#include<cstdio>
#include<cstdlib>
typedef long long ll;
const int N(1e5+5);
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
int n,k,a[N],sum[N];
struct tree
{
	int val,size,cnt,priority;
	tree *son[2];
	static tree *null;
	void *operator new(size_t size);
	void operator delete(void *ptr);
	inline tree():val(0),size(0),cnt(0),priority(0)
	{
		son[0]=son[1]=null;
	}
	inline tree(const int &x):val(x),size(1),cnt(1),priority(rand())
	{
		son[0]=son[1]=null;
	}
	inline const void pushup()
	{
		size=son[0]->size+cnt+son[1]->size;
	}
}bit,*tree::null,*root;
#define null tree::null
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof(memory_pool));
void *recycle[N],**top(recycle);
inline void *tree::operator new(size_t size){return top!=recycle?*--top:tail-=size;}
inline void tree::operator delete(void *ptr){*top++=ptr;}
inline const void rotate(tree *&fa,const bool &f)
{
	tree *p(fa->son[f]);
	fa->son[f]=p->son[!f];
	p->son[!f]=fa;
	fa->pushup();(fa=p)->pushup();
}
inline const void insert(tree *&p,const int &x)
{
	if (p==null)return p=new tree(x),void();
	p->size++;
	if (p->val==x)return p->cnt++,void();
	const bool t(p->val<x);
	insert(p->son[t],x);
	if (p->son[t]->priority<p->priority)rotate(p,t);
}
inline const void clear(tree *&p)
{
	if (p==null)return;
	clear(p->son[0]);
	clear(p->son[1]);
	delete p;p=null;
}
inline const int query(tree *p,const int &x)
{
	if (p==null)return 0;
	if (p->val<x)return query(p->son[1],x);
	if (p->val==x)return p->son[1]->size+p->cnt;
	return query(p->son[0],x)+p->cnt+p->son[1]->size;
}
inline const ll divide(const int &l,const int &r)
{
	if (l>r)return 0;
	if (l==r)return a[l]>=k;
	if (r-l==1)return (a[l]>=k)+(a[r]>=k)+(a[l]+a[r]>=k*2);
	const int mid(l+r>>1);
	ll tot(divide(l,mid-1)+divide(mid+1,r));
	for (int i(l);i<=mid;i++)insert(root,k*(i-1)-sum[i-1]);
	for (int i(mid);i<=r;i++)tot+=query(root,k*i-sum[i]);
	clear(root);
	return tot;
}
int main()
{
	read(n);read(k);
	for (int i(1);i<=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i];
	root=null=new tree;
	printf("%lld\n",divide(1,n));
	return 0;
}
```

然后我就发现 这个玩意为毛要cdq分治啊

直接for i 1~n 把$k(i-1)-sum[i-1]$扔进数据结构，然后查有多少个数比$ki-sum[i]$大直接累计答案就完事了

```
#include<cstdio>
#include<cstdlib>
typedef long long ll;
const int N(1e5+5);
template<class type>inline const void read(type &in)
{
	in=0;char ch=getchar();
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
int n,k,a[N],sum[N];
struct tree
{
	int val,size,cnt,priority;
	tree *son[2];
	static tree *null;
	void *operator new(size_t size);
	void operator delete(void *ptr);
	inline tree():val(0),size(0),cnt(0),priority(0)
	{
		son[0]=son[1]=null;
	}
	inline tree(const int &x):val(x),size(1),cnt(1),priority(rand())
	{
		son[0]=son[1]=null;
	}
	inline const void pushup()
	{
		size=son[0]->size+cnt+son[1]->size;
	}
}bit,*tree::null,*root;
#define null tree::null
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof(memory_pool));
void *recycle[N],**top(recycle);
inline void *tree::operator new(size_t size){return top!=recycle?*--top:tail-=size;}
inline void tree::operator delete(void *ptr){*top++=ptr;}
inline const void rotate(tree *&fa,const bool &f)
{
	tree *p(fa->son[f]);
	fa->son[f]=p->son[!f];
	p->son[!f]=fa;
	fa->pushup();(fa=p)->pushup();
}
inline const void insert(tree *&p,const int &x)
{
	if (p==null)return p=new tree(x),void();
	p->size++;
	if (p->val==x)return p->cnt++,void();
	const bool t(p->val<x);
	insert(p->son[t],x);
	if (p->son[t]->priority<p->priority)rotate(p,t);
}
/*inline const void clear(tree *&p)
{
	if (p==null)return;
	clear(p->son[0]);
	clear(p->son[1]);
	delete p;p=null;
}*/
inline const int query(tree *p,const int &x)
{
	if (p==null)return 0;
	if (p->val<x)return query(p->son[1],x);
	if (p->val==x)return p->son[1]->size+p->cnt;
	return query(p->son[0],x)+p->cnt+p->son[1]->size;
}
/*inline const ll divide(const int &l,const int &r)
{
	if (l>r)return 0;
	if (l==r)return a[l]>=k;
	if (r-l==1)return (a[l]>=k)+(a[r]>=k)+(a[l]+a[r]>=k*2);
	const int mid(l+r>>1);
	ll tot(divide(l,mid-1)+divide(mid+1,r));
	for (int i(l);i<=mid;i++)insert(root,k*(i-1)-sum[i-1]);
	for (int i(mid);i<=r;i++)tot+=query(root,k*i-sum[i]);
	clear(root);
	return tot;
}*/
int main()
{
	read(n);read(k);
	for (int i(1);i<=n;i++)read(a[i]),sum[i]=sum[i-1]+a[i];
	root=null=new tree;ll ans(0);
	for (int i(1);i<=n;i++)
		insert(root,k*(i-1)-sum[i-1]),
		ans+=query(root,k*i-sum[i]);
	//printf("%lld\n",divide(1,n));
	printf("%lld\n",ans);
	return 0;
}
```

---


# 「ROI 2025 Day2」充实的假期

## 题目描述

**译自 [ROI 2025](https://neerc.ifmo.ru/school/archive/2024-2025.html) Day2 T1.** ***[Качественный отдых](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-roi-2025-day2.pdf)***

小明正在一家 IT 公司进行为期 $n$ 天的实习，担任技术支持的角色。他的实习日程安排颇为复杂，工作日和休息日交织在一起。除了固定的休息日，小明还有一些调休日——他可以选择在任意工作日额外休息一天。

不过，小明觉得单独一天的休息远远不够，只有连续两天或以上的休息日才能让他真正放松，称之为充实休假日。

你会收到 $q$ 个关于调休日数量的询问，每个询问对应一个不同的调休天数。你的任务是根据小明的实习日程，计算出在每种调休天数下，小明最多能获得多少个充实休假日。

## 说明/提示

### 样例解释 1
在第一个样例中，实习的 $3$ 天全是工作日。如果调休少于 $2$ 天，无法获得充实休假日。对于 $k_3 = 2$ 或 $k_4 = 3$，可以选择前 $k_j$ 天作为调休日，这些天都将成为充实休假日。

### 样例解释 2
在第二个样例中，最优策略是将调休日安排在第二天，这样前三天都将成为充实休假日。

---

详细子任务附加限制及分值如下表所示。其中子任务 $0$ 是样例。

| 子任务 | 分值 | 附加限制 | 
| :-: | :-: | :-: |
|$0$|$0$|样例||
| $1$        | $6$  | 所有日程均为工作日 | |
| $2$        | $11$ | 工作日与休息日交替，首日为休息日 | |
| $3$        | $12$ | $q = 1$，$k_1 = 0$ | |
| $4$        | $19$ | $q = 1$，$k_1 = 1$ | |
| $5$        | $11$ | $n \le 15$ | $0$ |
| $6$        | $17$ | $n \le 1000$ | $0,5$ |
| $7$        | $13$ | 日程中无连续休息日 | $1,2$ |
| $8$        | $11$ | 无附加限制 | $0,1-7$ |

## 样例 #1

### 输入

```
3 4
000
0
1
2
3
```

### 输出

```
0
0
2
3
```

## 样例 #2

### 输入

```
4 3
1010
0
1
2
```

### 输出

```
0
3
4
```

## 样例 #3

### 输入

```
11 6
11010101001
5
2
0
1
4
3
```

### 输出

```
11
7
2
5
10
9
```

# 题解

## 作者：lmz105 (赞：3)

### 思路
对于所有日程均为工作日的情况，直接判断可调休天数是否大于等于 $2$，是的话输出调休天数，否则输出 $0$。

对于其他情况，我们考虑每调休一天可以增加几天充实休假日，可以发现有三种情况：

- 两天单独一天的休息日，且它们之间只需要调休一天就可以链接在一起，用字符串表示为 `01010 -> 01110`，这种情况可以增加 $3$ 天。
- 单独一天的休息日，在它的前一天或后一天调休，用字符串表示为 `010 -> 110` 或 `010 -> 011`，这种情况可以增加 $2$ 天。
- 在一段充实休假日前面或后面调休，用字符串表示为 `110 -> 111` 或 `011 -> 111`，这种情况可以增加 $1$ 天。

接下来只要让增加的充实休假日最多就行了。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace FX {
	template<typename T> inline void r(T &in) {
		in = 0;
		bool bo = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			bo ^= (ch == '-');
			ch = getchar();
		}
		while (isdigit(ch))
			in = (in << 1) + (in << 3) + (ch ^ 48), ch = getchar();
		if (bo) {
			in = -in;
		}
	}
	template<typename T> inline void w(T out) {
		static char op[25];
		int top = 0;
		if (out < 0) {
			putchar('-');
			do {
				op[++top] = -(out % 10) + 48, out /= 10;
			} while (out);
		} else {
			do {
				op[++top] = out % 10 + 48, out /= 10;
			} while (out);
		}
		while (top)
			putchar(op[top--]);
		putchar('\n');
	}
	template<typename T, typename... Ts> inline void r(T &in, Ts &... ins) {
		r(in), r(ins...);
	}
	template<typename T, typename... Ts> inline void w(T out, Ts... outs) {
		w(out), w(outs...);
	}
	inline void w(const char *p) {
		while (*p) {
			putchar(*p++);
		}
	}
}
#undef getchar
#undef putchar
using namespace FX;
#endif
using namespace std;
ll n, q, la, c, cnt[6];
string s;
vector<ll>v;

int main() {
	r(n, q);
	cin >> s;
	s = "0" + s + "0";
	for (ll i = 1; i < s.size(); i++) {
		n -= (s[i] ^ 48);
		if (s[i] == s[i - 1]) {
			c++;
			s[i - 1] = '0';
		} else {
			if ((s[i - 1] ^ 48) && c > 1) {
				cnt[2] += c;
				s[i - 1] = '0';
			}
			c = 1;
		}
	}
	for (ll i = 0; i < s.size(); i++) {
		if (s[i] ^ 48) {
			v.push_back(i);
		}
	}
	if (n != s.size() - 2) {
		if (v.size()) {
			c = 1;
			for (ll i = 1; i < v.size(); i++) {
				if (v[i] == v[i - 1] + 2) {
					c++;
				} else {
					cnt[1] += (c >> 1);
					cnt[0] += (c & 1);
					c = 1;
				}
			}
			cnt[1] += (c >> 1);
			cnt[0] += (c & 1);
		}
		while (q--) {
			ll x;
			r(x);
			x = min(x, n);
			if (cnt[1] >= x) {
				w(x * 3 + cnt[2]);
			} else if (cnt[1] + cnt[0] >= x) {
				w(cnt[1] * 3 + (x - cnt[1]) * 2 + cnt[2]);
			} else {
				w(cnt[1] * 3 + cnt[0] * 2 + cnt[2] + x - cnt[1] - cnt[0]);
			}
		}
	} else {
		while (q--) {
			ll x;
			r(x);
			x = min(x, n);
			if (x > 1) {
				w(x);
			} else {
				w(0);
			}
		}
	}
	return 0;
}
```

---

## 作者：Dehydration (赞：2)

# P12505 「ROI 2025 Day2」充实的假期

[Back to the problem.](https://www.luogu.com.cn/problem/P12505)。

[better service](https://www.cnblogs.com/raiterlin/articles/18889628)。

**标签：贪心，分类讨论。**

**前置知识：小学数学，~~for,if~~**。

## 题面

给一个 `01` 字符串，每次问插入 $x$ 个 `1`，求最多的连续的 `1` 的数目（当有两个及以上的 `1` 在一起，他们就是连续的 `1`）。

## 思路

注意到求 `1` 的数目而不是最大长度，所以考虑每次加 `1` 的贡献最大的直接贪心，即贡献越大越优先，可进行分类讨论。

（按贡献从大到小）：

1. 形如 `101`，发现如果将中间的 `0` 填补，有 $3$ 个贡献。

2.  形如 `10` 或 `01`，发现将中间（旁边？）的 `0` 填补，有 $2$ 个贡献。

3. 形如 `0`，将其填充获得 $1$ 个贡献。

特别的，不能重复贡献，所以设置 $1$ 个 `vis` 数组记录是否已经算进贡献里了。

其中的第 $3$ 点中形如 `0` 填充的可以算 $1$ 个贡献其实并不需要考虑是否连续，因为按照优先级肯定可以到有 `1` 的旁边达成连续。这种情况也有特殊，如全是 `0`，需要进行特判。

## 代码

欣赏吧。

```cpp
#include<bits/stdc++.h>
const int M=1e5+5;;
using namespace std;
int n,q,ans=0,a1=0,a2=0,a3=0,ys=0;
bool vis[M];//不能重复贡献
string c;
void calc(){//计算每一种 010，01,0 的个数
	for(int i=1;i<c.size();i++){
		if(!vis[i]&&c[i-1]=='1'&&!vis[i-1]&&c[i]=='0'&&c[i+1]=='1'&&!vis[i+1]){a1++;vis[i-1]=1;vis[i]=1;vis[i+1]=1;}
	}
	for(int i=1;i<c.size();i++){
		if(!vis[i]&&c[i-1]=='1'&&!vis[i-1]&&c[i]=='0'){a2++;vis[i-1]=1;vis[i]=1;}
		else if(!vis[i]&&c[i+1]=='1'&&!vis[i+1]&&c[i]=='0'){a2++;vis[i+1]=1;vis[i]=1;}
	}
}
int query(int sl){//O(1)进行计算
	if(ys==0)return sl<=1?0:sl;
	if(sl<=a1)return sl*3;
	if(sl>a1&&sl<=a1+a2)return a1*3+(sl-a1)*2;
	return a1*3+a2*2+sl-a1-a2;
}
int main(){
	memset(vis,0,sizeof(vis));
	scanf("%d%d",&n,&q);
	cin>>c;
	for(int i=0;i<c.size();i++)if(c[i]=='1')ys++;
	for(int i=1;i<c.size();i++){
		if(c[i]=='1')ys++;
		if(c[i]=='1'&&c[i-1]=='1'){
			if(!vis[i-1]){
				ans++;vis[i-1]=1;
			}
			ans++;vis[i]=1;
		}
	}
	calc();
//	cout<<a1<<' '<<a2<<'\n';
//  调试代码
	while(q--){
		int x;scanf("%d",&x);
		printf("%d\n",ans+query(x));
	}
}
```

---

## 作者：Mr_Az (赞：2)

# [P12505 「ROI 2025 Day2」充实的假期](https://www.luogu.com.cn/problem/P12505)

### Algorithm:

分类讨论。

### Solution:

如果你觉得不太可做，说明你可能读错了题目。**注意到：题目要求的是有几个充实休假日而不是最长的充实休假日。**

我们手玩一下样例可以发现以下性质：

1. `01010` 型：此时将中间的 $0$ 变为 $1$ 可以获得 $3$ 的贡献。
2. `010` 型：此时将两边的 $0$ 变为 $1$ 可以获得 $2$ 的贡献。
3. `0` 型：此时将 $0$ 变为 $1$ 可以获得 $1$ 的贡献。

**注意：三个类型所占用的位置不可以重复。**

直接暴力找出三个类型的数量，按照上面的优先级填入即可。

### Code:

```cpp
namespace Mr_Az{
	int T=1;
	const int N=1e5+20;
	int n,m,res;
	int ans[N],c[3];
	string s;
	inline void solve(){
		read(n,m);
		cin>>s;
		s="0"+s+"0";// 首末填下 0 用来匹配。
		for(rint i=1;i<=n;i++){
			if(i+2<=n){
				if(s[i-1]=='0'&&s[i]=='1'&&s[i+1]=='0'&&s[i+2]=='1'&&s[i+3]=='0'){
					c[0]++,i+=3;
					continue;
				}
			}// “01010” 型。
			if(s[i-1]=='0'&&s[i]=='1'&&s[i+1]=='0'){
				c[1]++,i+=1;
				continue;
			}// “010” 型。
		}
		for(rint i=1,j;i<=n;i++){
			if(s[i]=='1'){
				j=i+1;
				while(s[j]=='1') j++;j--;
				if(s[i+1]=='1') res+=j-i+1;
				i=j;
			}
			else c[2]++;// 0 的数量，c[2]-c[1]-c[0]= “0” 型的数量。
		}
		ans[0]=res;
		for(rint i=1;i<=c[2];i++){
			if(c[0]) ans[i]=ans[i-1]+3,c[0]--;
			else if(c[1]) ans[i]=ans[i-1]+2,c[1]--;
			else ans[i]=ans[i-1]+1;
		}// 按照优先级填入。
		if(c[2]==n) ans[1]=0;// 特判一下。
		for(rint i=1,x;i<=m;i++) read(x),printf("%lld\n",ans[x>c[2]?c[2]:x]);
		return ;
	}
	inline void mian(){if(!T) read(T);while(T--) solve();}
}
```

---

## 作者：ylch (赞：1)

注：本题问“充实休假日的数量”指修改后最多的假期天数。

## Subtask 1

当调休天数 $k \ge 2$ 时，小明可以将所有调休日连续安排，形成长度为 $k$ 的连续休息段，此时充实休假日数量为 $k$。当 $k<2$ 时无法形成任何连续两天休息，结果为 $0$。

给出部分判定和输出代码：

```cpp
if(all_of(s.begin(), s.end(), [](char c) { return c == '0'; })){ // subtask 1
    cout << (k >= 2 ? k : 0) << '\n';
}
```

## Subtask 3

询问只有一次，且 $k_1=0$，也就是说我们没有修改机会，答案就是原始时的充实休假日天数。为了避免重复可以用一个标记数组来计算。

```cpp
else if(q == 1 && k == 0){ // subtask 3
	vector<int> vis(s.size());
	for(int i = 1; i < s.size(); i ++){
		if(s[i] == '1' && s[i - 1] == '1') vis[i] = vis[i - 1] = 1;
	}
	cout << accumulate(vis.begin(), vis.end(), 0) << '\n';
}
```

## Subtask 5

爆搜即可。

```cpp
if(n <= 15 && k <= 15){ // Subtask 5
	// 计算原始充实休假日总数
	int ans = 0, cnt = 0;
	for(char c : s){
		if(c == '1') cnt ++;
		else{
			if(cnt >= 2) ans += cnt;
			cnt = 0;
		}
	}
	if(cnt >= 2) ans += cnt;
	
	// 爆搜
	int maxn = 0;
	function<void(int,int,string)> dfs = [&](int i, int used, string t){
		if(i >= n){
			int ans = 0, cnt = 0;
			for(char c : t){
				if(c == '1') cnt ++;
				else{
					if(cnt >= 2) ans += cnt;
					cnt = 0;
				}
			}
			if(cnt >= 2) ans += cnt;
			
			maxn = max(maxn, ans); 
			return ;
		}
		dfs(i + 1, used, t);
		if(t[i] == '0' && used < k){
			t[i] = '1'; dfs(i + 1, used + 1, t); t[i] = '0';
		}
	};
	
	dfs(0, 0, s);
	cout << (k == 0? ans : maxn) << '\n';
}
```

## Subtask 2

此时的字符串都形如 `10101010...`。考虑以 `1010` 为一“基础组”，肯定先更改第二个位置（贡献最大）变成 `1110`，然后再考虑把剩下的 `0` 补上。

如果有 $t$ 个“基础组”，答案显然为 $3 \times \min(k,t) + 1 \times \max(0, k-t)$。

分类讨论 $\frac{n}{4}$ 的余数：

1. $n=4m$ 或 $n=4m+3$，此时可以凑出 $t=\lceil \frac{n}{4} \rceil$ 个“基础组”。

2. $n=4m+1$ 或 $n=4m+2$，此时可以凑出 $t=\lfloor \frac{n}{4} \rfloor$ 个“基础组”。

但会漏，因为当 $n=4m+1$ 或 $n=4m+2$ 时，最后会剩下一个 `1`，还要考虑最后一个 `1` 能不能算上的问题。发现这取决于最后一个 `1` 前面的 `0` 是否被使用。

根据贪心策略，我们一定想让最后一个 `1` 尽可能被使用，所以只要 $k-t>0$ 我们就优先让这个 `1` 被用上，答案就能多 $1$。

```cpp
bool check_subtask2(string s){
	if(s.empty() || s[0] != '1') return false;
	for(int i = 1; i < s.size(); i ++) if(s[i] == s[i - 1]) return false;
	return true;
}

bool subtask2 = check_subtask2(s);

if(subtask2){
	if(n % 4 == 0 || n % 4 == 3){
		int t = (n + 4 - 1) / 4; // ceil(n/4)
		cout << 3 * min(k, t) + 1 * max(0, k - t) << '\n';
	}
	else{
		int t = n / 4; // floor(n/4)
		cout << 3 * min(k, t) + 1 * max(0, k - t) + (k - t > 0)/*考虑最后剩下的1能不能用上，优先使用*/ << '\n';
	}
}
```

## Subtask 4

考虑一种类似模式串匹配的方法。

当只有 $k_1=1$ 时，考虑这一次加到哪里会出现贡献（以下按照贡献降序）：

1. `101` 串，此时把中间天改成假日，理论上可以获得 $3$ 天的充实休假日。
2. `01` 或 `10` 串，此时把一个工作日改成假日，理论上可以获得 $2$ 天的充实休假日。
3. 如果上述两种模式都不存在，那么随便改一个工作日即可，理论上可以获得 $1$ 天的充实休假日。

但上面说的只是理论贡献，并不代表实际贡献也一定这么多。例如 `1001101101`，如果只是随便改第六个位置那么贡献只能是 $1$；但如果改倒数第二个位置的话会把最后一个 `1` 也加入进来，贡献是 $2$。

所以我们考虑预处理左右连续休息日长度，计算每个工作日的潜在贡献增量，选一个最优的当作答案即可。

（发现计算原始的充实休假日天数其实不用标记数组，直接迭代就好了）

```cpp
if(q == 1 && k == 1){ // subtask 4
	// 预处理左右连续休息日
	vector<int> left(n), right(n);
	for(int i = 1; i < n; i ++) left[i] = (s[i - 1] == '1')? left[i - 1] + 1 : 0;
	for(int i = n - 2; i >= 0; i --) right[i] = (s[i + 1] == '1') ? right[i+1] + 1 : 0;
	
	// 计算原始充实休假日总数
	int ans = 0, cnt = 0;
	for(char c : s){
		if(c == '1') cnt ++;
		else{
			if(cnt >= 2) ans += cnt;
			cnt = 0;
		}
	}
	if (cnt >= 2) ans += cnt;
	
	// 寻找最大增量
	int maxn = 0;
	for(int i = 0; i < n; i ++){
		if(s[i] == '0'){
			int a = left[i], b = right[i], newL = a + 1 + b;
			maxn = max(maxn, (newL >= 2? newL : 0) - (a >= 2? a : 0) - (b >= 2? b : 0)); // 新长度-旧的有效个数=新的增量
		}
	}
	
	cout << ans + maxn << '\n';
}
```

## 正解

其实题解中 Subtask 的顺序安排是有意为之，发现在 Subtask 2 & Subtask 4 之后我们就能推导出题目的大致做法了。

类似 Subtask 4，考虑按照贡献降序依次匹配模式串 `101`、`01`、`10`。不难猜到肯定要尽可能匹配多的 `101`，即尽可能多地把 $k$ 分配给模式串 `101`，其次是 `10` 或 `01`，这样能做到收益最大。

这就是贪心的思想，证明也简单：因为填任何位置不会让后续的填法变劣，所以优先填最大的最优。

注意：

1. 匹配模式串时一个位置只能匹配一次，考虑用标记数组避免重复匹配。
2. 特判全 `0` 的情况（Subtask 1）。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 7;

int n, q, cnt; // cnt记录初始时的充实休假日数量
int c1, c2; // 符合前两种情况的个数
bool has_1 = false; // s中是否有1
int vis[maxn]; // 记录使用情况，一个点只能贡献一次
string s;

int work(int k){ // 处理答案
	if(k == 0) return 0; // 特判k=0
	if(!has_1) return k < 2? 0 : k; // 特判没有1的情况
	if(k <= c1) return k * 3;
	else if(c1 < k && k <= c1 + c2) return c1 * 3 + (k - c1) * 2;
	else return c1 * 3 + c2 * 2 + (k - c1 - c2);
}

void solve()
{
	cin >> n >> q >> s;
	
	has_1 = (s.find('1') != string::npos); // 看有没有1
	
	// 预处理初始时的充实休假日数量
	for(int i = 1; i < s.size(); i ++){
		if(s[i] == '1' && s[i - 1] == '1'){
			if(!vis[i - 1]) cnt ++, vis[i - 1] = 1;
			cnt ++, vis[i] = 1;
		}
	}
	
	// 预处理符合前两种情况的个数
	for(int i = 1; i < s.size(); i ++){ // 101
		if(!vis[i] && s[i] == '0' && !vis[i - 1] && s[i - 1] == '1' && !vis[i + 1] && s[i + 1] == '1'){ 
			c1 ++; 
			vis[i] = vis[i - 1] = vis[i + 1] = 1;
		}
	}
	for(int i = 1; i < s.size(); i ++){ // 10 or 01
		if(!vis[i] && s[i] == '0' && !vis[i - 1] && s[i - 1] == '1'){
			c2 ++;
			vis[i] = vis[i - 1] = 1;
		}
		else if(!vis[i] && s[i] == '0' && !vis[i + 1] && s[i + 1] == '1'){
			c2 ++;
			vis[i] = vis[i + 1] = 1;
		}
	}

	while(q --){
		int k; cin >> k;
		cout << min(n, cnt + work(k)) << '\n';
	}
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

---

## 作者：LZC_AK_CRZ (赞：1)

# Solution
先说明一下，有同学可能会对题意有一些误解。经过模拟样例我们可以发现，“最多能获得的充实休假日数量”指的是充实休假日的天数，也就是说，形如 `11011011` 的安排应该是算 $6$ 个“充实休假日”，而非 $3$ 个。

整体思路：贪心。  
考虑将某个 $s_i$ 从 $0$ 变为 $1$ 的贡献值。分三种情况讨论：  
1. 当 $s_i$ 为形如 `01010` 中间的那个 `0` 时，将其从 $0$ 变为 $1$ 将增加 $3$ 个“充实休假日”；  
2. 当 $s_i$ 为形如 `010` 左侧或右侧（仅能一侧）的那个 `0` 时，将其从 $0$ 变为 $1$ 将增加 $2$ 个“充实休假日”；  
3. 当 $s_i$ 为形如 `011` 左侧或 `110` 右侧的那个 `0` 时，将其从 $0$ 变为 $1$ 将增加 $1$ 个“充实休假日”。

观察数据范围，询问次数 $q \le 10^5+1$，显然要求 $O(1)$ 查询。因此需要预处理。  
贪心策略告诉我们，我们应优先考虑贡献值最高的 a 情况，其次 b，最后 c。值得注意的是，c 情况会在 a 与 b 之后考虑，因此做完 a、b 情况后剩余的 `0` 一定满足 c 情况的 `011` 或 `110`。  
对于每一个 $k$，先尽量做 a，如果还有剩余再尽量做 b，还有剩余就做 c。我的代码进行了一些小改动，精简了一下。

对于这种分类讨论题，基本都有特判的坑。此题若字符串 $s$ 全为 `0`，不在讨论范围内，需要特判：如果 $k=1$，不存在“充实休假日”；否则 $k>1$，则“充实休假日”天数为 $k$。

具体详见代码，如下。
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 1e5 + 5;
int n, q, k, cnt = 0, ans = 0, chg[N];
string s;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	cin >> n >> q >> s;
	s = '0' + s + '0';
	
	// spj
	bool all_zero = *max_element(s.begin(), s.end()) == '0';
	
	// init
	int t = 0;
	for (int i = 1; i <= n + 1; i++) {
		if (s[i] == '1') t++;
		else {
			if (t > 1) chg[0] += t;
			t = 0;
		}
	}
	
	// +3
	for (int i = 0; i <= n - 3; i++) {
		if (s.substr(i, 5) == "01010") {
			chg[++cnt] = 3;
			s[i + 2] = '1';
		}
	}
	
	// +2
	if (s.substr(1, 2) == "10") {
		chg[++cnt] = 2;
		s[2] = '1';
	}
	if (s.substr(n - 1, 2) == "01") {
		chg[++cnt] = 2;
		s[n - 1] = '1';
	}
	for (int i = 1; i <= n - 2; i++) {
		if (s.substr(i, 3) == "010") {
			chg[++cnt] = 2;
			s[i] = '1';
		}
	}
	
	// +1
	while (cnt < n) chg[++cnt] = 1;
	
	// get sum
	for (int i = 1; i <= cnt; i++) chg[i] += chg[i - 1];
	
	// ans
	while (q--) {
		cin >> k;
		if (all_zero && k == 1) cout << 0 << '\n';
		else cout << chg[k] << '\n';
	}
	return 0;
}
```
### Thanks for your time!

---

## 作者：Sliarae (赞：1)

将休息日和工作日看成一个 $01$ 序列 $a$，充实休假日的天数实际上就是不孤立的 $1$ 的个数（这里的“孤立”指一个 $1$ 两边都不是 $1$）。设 $iso_i = 0/1$ 表示 $a_i$ 是否是一个孤立的 $1$。

对于序列 $a$ 中的一个 $a_p = 0$ 的位置 $p$，我们定义它的价值为 $val_p = iso_{p - 1} + 1 + iso_{p + 1}$，表示在这里填一个 $1$，不仅可以在自己这里增加一个 $1$，还可以让两边孤立的 $1$ 产生价值。 

考虑 $val = 1$ 的决策一定存在，不用管。$val = 2$ 的决策不会相互影响。对于 $val = 3$，会相互影响的情况只有 $1010101$ 交错这一种，此时将从左到右第奇数个 $0$ 变成 $1$ 最优，即变成 $1110111$。

设 $ans_k$ 表示可以将 $k$ 个 $0$ 变成 $1$ 的答案，可以直接按如下方式贪心：

每次将 $k$ 增加 $1$，考虑 $ans_k$ 相对于 $ans_{k - 1}$ 增加了多少。拿出 $val_p$ 最大的位置 $p$，如果有多个，取 $p$ 最小的（由 $1010101$ 的情况得），将 $a_p$ 变为 $1$，然后修改位置 $p$ 两边的 $O(1)$ 个 $iso$ 和 $val$，那么 $ans_k = ans_{k - 1} + val_p$。

时间复杂度 $O(n \log n)$。

```cpp
#include <iostream>
#include <set>
#include <functional>

using namespace std;

const int kN = 1e5 + 5; 

int n, q, m; 
int a[kN], ans[kN], val[kN];
bool iso[kN];
set<int> st[3];

void Change (int p, int x) {
  st[val[p]].erase(p);
  val[p] += x;
  st[val[p]].insert(p);
}

void Add (int p, int x) {
  if (p != 1) Change(p - 1, x);
  if (p != n) Change(p + 1, x);
}

int main () {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> q;
  for (int i = 1; i <= n; ++i) {
    char c;
    cin >> c;
    a[i] = c - '0', m += !a[i];
  }
  for (int i = 1; i <= n; ++i) {
    if (a[i]) {
      iso[i] = 1;
      if (i != 1 && a[i - 1]) iso[i] = 0; 
      if (i != n && a[i + 1]) iso[i] = 0; 
      ans[0] += !iso[i];
    }
  }
  for (int i = 1; i <= n; ++i) val[i] = 0, st[0].insert(i);
  for (int i = 1; i <= n; ++i) {
    if (iso[i]) Add(i, 1);
  }
  for (int t = 1; t <= m; ++t) {
    if (!st[2].empty()) {
      int p = *st[2].begin();
      a[p] = 1;
      if (p != 1 && iso[p - 1]) iso[p - 1] = 0, Add(p - 1, -1);
      if (p != n && iso[p + 1]) iso[p + 1] = 0, Add(p + 1, -1); 
      ans[t] = ans[t - 1] + 3; 
    }
    else if (!st[1].empty()) {
      int p = *st[1].begin();
      a[p] = 1; 
      if (p != 1 && iso[p - 1]) iso[p - 1] = 0, Add(p - 1, -1);
      if (p != n && iso[p + 1]) iso[p + 1] = 0, Add(p + 1, -1);
      ans[t] = ans[t - 1] + 2; 
    }
    else {
      ans[t] = ans[t - 1] + 1;
    }
  }
  while (q--) {
    int x;
    cin >> x;
    cout << (ans[x] == 1 ? 0 : ans[x]) << '\n';
  }
  return 0; 
}
```

---

## 作者：_awa_wangjiawen (赞：0)

有两种特殊型：
1. $01010$ 此时我们一天的贡献为 $3$。
2. $010$ 此时我们一天的贡献为 $2$。

对于多出来的天数，我们可以改变任意一个 $1\dots1$ 串左右两边的 $0$，此时我们一天的贡献为 $1$。

需要特别注意的是，如果原字符串中没有 $1$，只有一天时也不会由充实的假期，这个可以通过特判解决。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod1=998244353;
const long long mod2=1000000007;
const long long inf=0x3f3f3f3f3f3f3f3f;
long long n,m,sum1,sum2,t;
string s;
bool flag;

void init();
void domemset();
long long read();
void write(long long x);


void fun()
{
//	domemset();
	n=read();m=read();
	cin>>s;
	for(int i=0;i<s.size();)
	{
		if(s[i]=='1')
			flag=1;
		if(s[i]=='1'&&(s[i-1]=='0'||i==0)&&s[i+1]=='1'&&i!=s.size()-1)
		{
			t+=2;i+=2;
			for(;i<s.size();i++)
			{
				if(s[i]=='0')
					break;
				t++;
			}
		}
		i++;
	}
	for(int i=0;i<s.size();)
	{
//		cout<<i<<" ";
		if(i<s.size()-2&&(i==0||s[i-1]=='0')&&s[i]=='1'&&s[i+1]=='0'&&s[i+2]=='1'&&(s[i+3]=='0'||i==s.size()-3))
			sum1++,i+=3;
		else if((i==0||s[i-1]=='0')&&s[i]=='1'&&(i==s.size()-1||s[i+1]=='0'))
			sum2++,i++;
		i++;
//		cout<<sum1<<" "<<sum2<<"\n";
	}
//	cout<<endl;
//	cout<<t<<" "<<sum1<<" "<<sum2<<endl;
	for(int i=1;i<=m;i++)
	{
		long long x=read(),ans=t;
		if(flag==0&&x==1)
		{
			putchar('0'),putchar('\n');
			continue;
		}
		ans=ans+min(x,sum1)*3;x-=min(x,sum1);
		ans=ans+min(x,sum2)*2;x-=min(x,sum2);
		ans+=x;
		write(ans);putchar('\n');
	}
	return ;
}


int main()
{
//	init();
//	t=read();
//	for(int i=1;i<=t;i++)
//	while(1)
//	freopen("B3.in","r",stdin);
//	freopen("B3.ans","w",stdout);
		fun();
	return 0;
}
void init()
{

	return ;
}
void domemset()
{

	return ;
}
long long read()
{
	long long x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}
void write(long long x)
{
	if(x<0)
		putchar('-'),x=-x;
	if(x>=10)
		write(x/10);
	putchar((x%10)^'0');
	return ;
}
```

---


# [USACO23OPEN] FEB B

## 题目描述

贝西和埃尔希正在密谋最终推翻他们的主人——农夫约翰！他们通过 $N$ 条短信进行计划。他们的对话可以用一个长度为 $N$ 的字符串 $S$ 来表示。     
其中 $S_i$ 是字母 ```B``` 或 ```E```，这意味着第 $i$ 条消息分别由贝西或埃尔希发送的。


然而，农夫约翰听说了这个消息，并试图拦截他们的谈话。因此，字符串 $S$ 的一些字母是 ```F```，这意味着农夫约翰混淆了信息，发件人未知（贝西、埃尔希都有可能）。   
**注：约翰没有发送信息！他只是在干扰奶牛间的通话！**


未混淆对话的兴奋程度是**一只奶牛重复发送信息的次数**。也就是说，子串 ```BB``` 或 ```EE``` 在 $S$ 中出现的次数。你想找到原始信息的兴奋程度，但你不知道约翰的信息中哪一条实际上是贝西或埃尔希的。在所有可能的情况下，**从小到大输出**所有可能的兴奋程度。

## 说明/提示

$1 \le N \le 2 \times 10^5$。
- 测试点 4~8：$N \le 10$
- 测试点 9~20：无额外限制。

## 样例 #1

### 输入

```
4
BEEF
```

### 输出

```
2
1
2
```

## 样例 #2

### 输入

```
9
FEBFEBFEB
```

### 输出

```
2
2
3```

## 样例 #3

### 输入

```
10
BFFFFFEBFE```

### 输出

```
3
2
4
6```

# 题解

## 作者：Limie (赞：21)

#### 前言

此题大家都是通过打表的方法找出等差数列的规律，却没有一个人证明，故我用自己的方法给大家讲明白为什么是等差数列。

----------

#### 观察结论

可以发现，如果字符串的开头或结尾是 $ F $，则所有可能的情况正好构成一个公差为 $ 1 $ 的等差数列，否则它们会构成一个公差为 $ 2 $ 的等差数列。

那如何证明呢？

#### （1）从简单开始 
假设一个最简单的情况：整个序列中有且仅有一个 $ F $。

1. 若 $ F $ 在开头：

序列可表示为 ```F......```。

不妨设第二位为 $B$。

序列可表示为 ```FB......```。

设后面的序列中的兴奋程度（或价值，下文中统一用兴奋程度）为 $a$。

则总序列可能的兴奋程度为 $a$ 或 $a+1$。

2. 若 $F$ 在中间

若 $F$ 两边的字符相同，不妨设为 $B$。

则序列为：```......BFB.....```。

设左边序列兴奋程度为 $a$，右边为 $b$。

则兴奋程度可能为：$a+b$ 或 $a+b+2$。

否则，序列为：```.......BFE.....```。

设左边序列兴奋程度为 $a$，右边为 $b$。

兴奋程度为：$a+b+1$。

3. $F$ 在结尾：同第 $1$ 种。

##### 总结结论：当 $F$ 在开头或结尾时，公差为 $1$，否则公差为 $2$。

----------
#### （2）数学归纳法
若有 $(n-1)$ 个 $F$ 时，若满足结论，则需证 $n$ 个 $F$ 时也相等。

若开头或结尾没有 $F$，设原来的兴奋程度的可能值为 $a,a+2,a+4,...,a+2k$。

将开头或结尾替换成 $F$，则可能值的变换同简单情况，可能值为：

 $a,a+2,a+4,...,a+2k,a+1,a+3,...,a+2k+1$，即 $a,a+1,a+2,a+3,...,a+2k+1$ 即公差为 $1$ 的等差序列。

将中间一个非 $F$ 的位置换成 $F$，过程也差不多，读者自证不难。

-------------
综上，结论正确，证毕！！！

#### Code：
```
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef unsigned long long ULL;
typedef long long LL;
typedef pair<int,int> PII;
int n,d=2;
string st;
int l()
{
	int ans=0;
	string t=st;
	for(int i=1;i<n;i++)
		if(t[i]=='F')
			if(t[i-1]=='B')t[i]='E';else t[i]='B';
		
	for(int i=1;i<n;i++)ans+=(t[i-1]==t[i]);
	return ans;
}
int r()
{
	int ans=0;
	string t=st;
	for(int i=1;i<n;i++)
		if(t[i]=='F')t[i]=t[i-1];
	
	for(int i=1;i<n;i++)ans+=(t[i-1]==t[i]); 
	return ans;
}
int main()
{
	int i;
	cin>>n>>st;
	if(st[0]=='F'||st[n-1]=='F')d=1;
	if(st[0]!='F'){
		int x=l(),y=r();
		cout<<(y-x)/d+1<<endl;
		for(i=x;i<=y;i+=d)cout<<i<<endl;
		return 0;
	}
	st[0]='B';
	int x=l(),y=r();
	st[0]='E';
	x=min(x,l());
	y=max(y,r());
	cout<<(y-x)/d+1<<endl;
		for(i=x;i<=y;i+=d)cout<<i<<endl;
}
```

---

## 作者：include13_fAKe (赞：14)

- $\text{upd 2023.4.12:}$ 修改了一些 $\LaTeX$ 和表达不规范的地方。

## 题意
给定一个仅由 $\texttt B$、$\texttt E$、$\texttt F$ 组成的字符串。要求将所有的 $\texttt F$ 替换为 $\texttt B$ 或 $\texttt E$。求字符串中子串 $\texttt{BB}$ 和 $\texttt{EE}$ 出现的次数之和的所有可能的情况的数量及它们的值。

## 解法

- 测试点 $1-3:$ 直接照样例输出即可。可得 $15$ 分。
- 测试点 $4-8:$ 留给时间复杂度 $O(2^N)$ 的暴力枚举，可得 $40$ 分。
- 测试点 $9-20:$ 留给时间复杂度 $O(N)$ 的模拟。

可以先算出将所有的 $\texttt F$ 替换为 $\texttt B$ 或 $\texttt E$ 后，子串 $\texttt{BB}$ 和 $\texttt{EE}$ 出现的次数之和的下限和上限。

上限可以这样算：

对于每一个 $\texttt F$，将其替换为上一个字符（即如果上一个字符是 $\texttt B$，就替换为 $\texttt B$，上一个字符是 $\texttt E$ 同理）。

下限同理。

### 如果字符串以 $\texttt{F}$ 开头怎么办？（价值：$15$ 分）

可以分别计算出用 $\texttt{B}$ 和 $\texttt{E}$ 开头时的状态，再简单比较即可。

------------


然后可以发现，如果字符串的开头或结尾是 $\texttt F$，则所有可能的情况正好构成一个**公差为 $1$ 的等差数列**（如样例 $1$ 和 $2$）。否则它们会构成一个**公差为 $2$ 的等差数列**（如样例 $3$）。用一个 $\text{int}$ 型的变量记录其构成的等差数列的公差即可。

## 代码

感觉代码常数有点大，效率不是很高，但不会超时。

```cpp
#include<bits/stdc++.h>
using namespace std;

int N;
string S;
int flag=2;//公差
int solve_most(){//计算上限
	int ret=0;
	string S1=S;
	for(register int i=2;i<=N;i++)	if(S1[i]=='F')	S1[i]=S1[i-1];
	for(register int i=2;i<=N;i++)	ret+=(S1[i-1]==S1[i]); 
	return ret;
}
int solve_least(){//计算下限
	int ret=0;
	string S1=S;
	for(register int i=2;i<=N;i++)
		if(S1[i]=='F')
			if(S1[i-1]=='B')	S1[i]='E';
			else	S1[i]='B';
	for(register int i=2;i<=N;i++)	ret+=(S1[i-1]==S1[i]);
	return ret;
}
int main(){
	cin>>N>>S;
	S=' '+S;
	if(S[1]=='F'||S[N]=='F')	flag=1;
	if(S[1]!='F'){
		int ans1=solve_most();
		int ans2=solve_least();
		printf("%d\n",(ans1-ans2)/flag+1);
		for(ans2;ans2<=ans1;ans2+=flag)	printf("%d\n",ans2);
		return 0;
	}
	S[1]='B';
	int ans1=solve_most();
	int ans2=solve_least();
	S[1]='E';
	ans1=max(ans1,solve_most());
	ans2=min(ans2,solve_least());
	printf("%d\n",(ans1-ans2)/flag+1);
	for(ans2;ans2<=ans1;ans2+=flag)	printf("%d\n",ans2);
	return 0;
} 
```


---

## 作者：Starstream (赞：3)

### 知识点

DFS、找规律、贪心。

### 思路

#### 结论

通过 DFS 暴力对拍，我们发现答案为一个等差数列。

#### 证明

不妨设整个序列中仅有一个 `F`。

分类讨论这个 `F` 的位置。

1. `F` 在开头

此时序列形如 `Fxxxxxx`。

不妨设第二位为 `E`。

- 若将 `F` 变为 `E`，则对答案的贡献为 $1$。
    
- 若将 `F` 变为 `B`，则对答案无贡献。

2. `F` 在中间

此时序列形如 `xxxFxxx`。

- `F` 两侧字符相同。不妨设该字符为 `E`，则序列为 `xxEFExx`。

	- 若将 `F` 变为 `E`，则对答案的贡献为 $2$。
    
    - 若将 `F` 变为 `B`，则对答案无贡献。

- `F` 两侧字符不同。不妨设此时序列为 `xxBFExx`。无论如何替换，对答案的贡献都是 `1`。因此下面进行贪心时不考虑这种情况。

3. `F` 在结尾。这种情况与情况 $1$（`F` 在开头）相同。

证毕。得出结论：**答案为一个等差数列，且如果字符串首尾至少一个位置是 `F`，那么等差数列的公差为 $1$。如果头和尾都不是 `F`，那么等差数列公差为 $2$。**

***

对于中间的 `F`，我们考虑贪心求出等差数列首项与末项。

发现 `EB` 交替放置时方案数最小，即为数列首项。

同理，相邻的 `E` 或 `B` 尽量相同时，方案数最大，即为数列末项。

### 代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 300010;

int n, hh, tt;
char s1[N], s2[N];

int main()
{
    int sub = 0, hh = 0, tt = 0; // 公差、首项、末项
    scanf("%d%s", &n, s1);
    if (s1[0] == 'F' || s1[n - 1] == 'F') sub = 1; // 首尾 -> 公差为 1
    else sub = 2; // 否则公差为 2

    while (tt < n - 1 && s1[tt] == 'F') tt ++ ; // 找到第一个不是 F 的位置开始贪心
    for (int i = 0; i < n; i ++ ) s2[i] = s1[i];

    for (int i = tt + 1; i < n; i ++ )
    {
        if (s1[i] == 'F')
        {
            s2[i] = s2[i - 1]; // 最小值尽量相等
            if (s1[i - 1] == 'E') s1[i] = 'B'; // 最大值尽量交替出现
            if (s1[i - 1] == 'B') s1[i] = 'E';
        }
        if (s1[i] == s1[i - 1]) hh ++ ; // 向首项末项累加答案
        if (s2[i] == s2[i - 1]) tt ++ ;
    }

    int k = (tt - hh) / sub + 1; // 计算等差数列项数
    printf("%d\n", k);
    for (int i = hh; i <= tt; i += sub)
        printf("%d\n", i);
    return 0;
}
```

---

## 作者：small_john (赞：3)

## 思路

其实很简单。

观察样例得，输出是个等差数列，而等差树列确定了首项、末项、公差就能确定整个数列。

---

我们可以把字符串分三种情况来确定公差：

1. 开头是 `F` 或结尾是 `F`：公差为 $1$；

2. 一个 `F` 旁边两个字符相同：公差为 $2$；

3. 一个 `F` 旁边两个字符不同：对公差没有贡献。

---

接下来用贪心来确定首项和末项。

1. 首项：对于每个 `F`，取和上一个相同的；

2. 末项：对于每个 `F`，取和上一个不同的。

值得注意的是，当字符串第一个是 `F` 时，第一个字符没有前一个做参照，所以直接枚举选哪个。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,d = 2,l = INT_MAX,r;
void init()
{
	 ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	 freopen("bef.in","r",stdin);
	 freopen("bef.out","w",stdout);
}
int maximize()
{
	string t = s;
	int res = 0;
	for(int i = 1;i<n;i++)
		if(t[i]=='F')
			t[i] = t[i-1];
	for(int i = 1;i<n;i++)
		res+=(t[i]==t[i-1]);
	return res;
}
int minimize()
{
	string t = s;
	int res = 0;
	for(int i = 1;i<n;i++)
		if(t[i]=='F')
		{
			if(t[i-1]=='E') t[i] = 'B';
			else t[i] = 'E';
		}
	for(int i = 1;i<n;i++)
		res+=(t[i]==t[i-1]);
	return res;
}
void solve()
{
	l = min(l,minimize()),r = max(r,maximize());
}
signed main()
{
	init();
	cin>>n>>s;
	if(s[0]=='F'||s[n-1]=='F') d = 1;
	if(s[0]=='F') s[0] = 'B',solve(),s[0] = 'E',solve();
	else solve();
	cout<<(r-l)/d+1<<'\n';
	for(;l<=r;l+=d) cout<<l<<'\n';
	return 0;
}
```

---

## 作者：zjc5 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P9183)

前提知识：

对于两个等差数列，一个数列首项为 $l_1$，末项为 $r_1$，公差为 $k_1$；另一个数列首项为 $l_2$，末项为 $r_2$，公差为 $k_2$。

把第一个数列中的每一项加第二个数列中的每一项，排序去重后会得到一个首项为 $l_1+l_2$，末项为 $r_1+r_2$，公差为 $\min(k_1,k_2)$ 的等差数列。

正式思路：

我们可以把 $F$ 的分布分为以下三种情况：

第一种：$\cdots XFF\cdots FFY\cdots(X=Y)$

第二种：$\cdots XFF\cdots FFY\cdots(X\not=Y)$

第三种：$FF\cdots FF\cdots$ 或 $\cdots FF\cdots FF$

设连续 $F$ 的个数为 $l$。

对于情况一，$EE,BB$ 的个数的和可能是 $(l-1)\bmod2,(l-1)\bmod2+2,\cdots,l+1$。

对于情况二，$EE,BB$ 的个数的和可能是 $l\bmod2,l\bmod2+2,\cdots,l$。

对于情况三，$EE,BB$ 的个数的和可能是 $0,1,2,\cdots,l$。

**注意：一定要特判整个数列都是 $F$ 的情况。**

所以，只需处理出三种情况，然后合并即可。再输出时，要加上原本 $EE,BB$ 的个数。

代码时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int len,ans,st;
int al,ar,ak=2;
int nl,nr,nk;
int l,r;
char ch[200010];
void bin(){
	if(l==1&&r==len){
		al=0;
		ar=len-1;
		ak=1;
		return ;
	}//特判
	if(l==1||r==len)
		nk=1,nl=0,nr=r-l+1;
	else if(ch[l-1]==ch[r+1])
		nk=2,nl=(r-l)%2,nr=r-l+2;
	else nk=2,nl=(r-l+1)%2,nr=r-l+1;
	al+=nl;
	ar+=nr;
	ak=min(ak,nk);
}
int main(){
	scanf("%d%s",&len,ch+1);
	for(int i=1;i<len;i++)
		if(ch[i]!='F'&&ch[i]==ch[i+1])
			st++;//初始个数
	for(int i=1;i<=len;i++)
		if(ch[i]=='F'){
			if(i==1||ch[i-1]!='F') l=i;
			if(i==len||ch[i+1]!='F') {
				r=i;
				bin();
			}
		}
	printf("%d\n",(ar-al)/ak+1);
	for(int i=al;i<=ar;i+=ak)
		printf("%d\n",i+st);
	return 0;
}
```

---

## 作者：Mu_leaf (赞：2)

## [前言]

模拟赛打的这道题，好不容易 A 了，~~但是是上厕所的时候推出的规律~~。

## [思路]

首先先明确一点：

对于样例 1，它的答案是一个公差为 1 的等差数列，样例 2 也是如此。

所以可以得出规律：当字符串开头或末尾字母为 F 时，答案的公差为 1 数列。

对于样例 3 发现当开头与结尾的字母都不为 F 且答案是公差为 2 的等差数列。

~~证明留给大佬了，毕竟是上厕所的时候想的。~~

于是我们就可以预处理这个字符串最多可能有多少对 BB 或 EE，最少有多少对 BB 和 EE。

上限只需要和前一个字母相同即可。为什么可以不考虑后面的字母呢？因为题目要求的是**连续的** BB 或 EE 的**总对数**。连续 $l$ 个 B 只会有 $l-1$ 对符合条件的，所以与前面相等与后面相等的答案是不变的。

下限反着来就行：前面是 B 我们就填 E，前面是 E 我们就填 B，这样一定是最小情况。

对于开头为 F 的情况怎么填呢？只有一个 F 的话枚举是填 B 还是 E 就行了。

# Code:

```cpp
#include <bits/stdc++.h>

using namespace std;
string s;
int n,gc;
int up(){
	int ret=0;
	string s1=s;
	for(int i=2;i<=n;i++) if(s1[i]=='F') s1[i]=s1[i-1];
	for(int i=2;i<=n;i++) ret+=(s1[i]==s1[i-1]);
	return ret; 
}
int down(){
	int ret=0;
	string s1=s;
	for(int i=2;i<=n;i++){
		if(s1[i]=='F'){
			if(s1[i-1]=='B') s1[i]='E';
			else s1[i]='B';
		}
	}for(int i=2;i<=n;i++) ret+=(s1[i]==s1[i-1]);
	return ret; 
}
int main(){
	cin >> n >> s;
	s=' '+s;
	gc=2;
	if(s[1]=='F' || s[n]=='F') gc=1;
	if(s[1]!='F'){
		int r=up();
		int l=down();
		cout << (r-l)/gc+1 << "\n";
		for(;l<=r;l+=gc) cout << l << "\n";
	}else{
		int r,l;
		s[1]='B'; 
		r=up();
		l=down();
		s[1]='E';
		r=max(r,up());
		l=min(l,down());
		cout << (r-l)/gc+1 << "\n";
		for(;l<=r;l+=gc){
			cout << l << "\n";
		}
	} 
	/*
	9 
	FEBFEBFEB
	10
	BFFFFFEBFE
	*/
	
	return 0;
}

```


---

## 作者：KidA (赞：1)

由于只需要考虑相邻的位置，所以每一段连续的 `F` 是互不影响的，可以分别进行考虑。而连续的一段 `F` 又可以分成两类：靠边的和被夹在中间的。

靠边的 `F` 段较为简单，假定有 $c$ 个 `F` ，不难发现只要让 `EB` 交错出现就可以达到最少次数 ，而让所有的 F 都变成最近的非 `F` 就可以达到最多次数 $c$，由内向外减少交错的长度就可以逐渐增加次数，使得 $[0,c]$ 中的任意次数都是可行的。

夹在中间的 `F` 段稍微复杂一些，段的长度与两边字符的异同都会影响答案，不过还是可以先用贪心按顺序考虑每个 `F` ，分别**尽量保持不同**和**尽量保持不变**就可以求出最少次数 $l$ 和最大次数 $r$。接下来再进行调整并观察可能的次数，不难发现每次调整都会使得答案刚好变化 $2$。

综上所述，我们可以对每一段的下界和上界分别进行累加，就得到了最终答案的下界与上界。若只有夹在中间的 `F` 段，那么次数变化的步长为 $2$，否则只要有任意靠边的 `F` 段，就可以让变化的步长变成 $1$，由此可以算出次数的数量，最后进行输出即可。

实现时不需要分段进行处理，通过判断首字母与末字母是否为 `F` 就可以知道是否有靠边的段，然后直接贪心求解上下界即可。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int l,r,d;
string s,t;

int main(){
    cin>>n>>s,t=s;
    d=2-(s[0]=='F'||s[n-1]=='F');
    for(;r<n-1&&s[r]=='F';r++);
    for(int i=r+1;i<n;i++){
        if(s[i]=='F')
            t[i]=t[i-1],s[i]=(s[i-1]=='E'?'B':'E'); 
        l+=(s[i]==s[i-1]),r+=(t[i]==t[i-1]); 
    } 
    cout<<(r-l)/d+1<<'\n';
    for(int i=l;i<=r;i+=d) cout<<i<<'\n';
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 思路


首先~~对样例发动鹰眼技能~~观察样例，貌似有一点规律。结合打表，我们发现答案貌似是个等差数列，并且和 `F` 是否在开头有关（`F` 是一个字符不是数学公式！）。

那么仅仅是看是不行的，我们显然需要进行证明。

当没有 `F` 时，序列是固定的。

当仅有 $1$ 个 `F` 时：

- `F` 在开头或结尾：那么显然只有两种情况。那么一种情况是 `F` 替换为 $S_2$，另外一种情况就是 `F` 不替换为 $S_2$。两者差值为 $1$。

- `F` 在中间。那么设 `F` 的位置为 $i$，如果 $a_{i-1}=a_{a+1}$，那么差值为 $2$；否则差值为 $0$。

当有若干个 `F` 时：

那么很显然就是把上面的特殊情况结合一下嘛。

因为每一个 `F` 我们都可以选择其贡献值（中间的 `F` 我们可以选择其贡献 $0$ 或者 $2$，头尾的我们可以选择其贡献 $1$ 或者 $0$）。我们统计出中间的 `F` 的个数 $a$（满足这个 `F` 两边的字符相同），头尾的 `F` 的个数 $b$，那么就相当于 $G=2\times i+1\times j,i\in[0,a],j\in[0,b]$。很显然，只要 $b>0$，那么 $G$ 就是公差为 $1$ 个序列，否则就是公差为 $2$ 的序列。

最后我们只需要贪心地计算出最多和最少的贡献 $G_{\operatorname{max}},G_{\operatorname{min}}$ 即可。

亲身试险，无坑。

---

```C++
#include<bits/stdc++.h>
#define rep(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define per(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
#define int long long
#define pii pair<int,int>

#define lc(x) (x<<1)
#define rc(x) (x<<1|1)

#define rd read()
inline int read()
{
	int xx=0,ff=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') xx=xx*10+(ch-'0'),ch=getchar();
	return xx*ff;
}
inline void write(int out)
{
	if(out<0) putchar('-'),out=-out;
	if(out>9) write(out/10);
	putchar(out%10+'0');
}

const int N=5e5+5;
const int INF=1e18+5;
const int MOD=998244353;
int ans,m;
int f;
int a,b,cnt[N],len,T,n;
char s[N],t[N];

int calmax(){
	int res=0;
	t[0]='E';
	for(int i=1;i<=n;i++){
		if(s[i]=='F')t[i]=t[i-1];
		else t[i]=s[i];
	}
	for(int i=1;i<n;i++)res+=(t[i]==t[i+1]);
	
	int res2=0;
	t[0]='B';
	for(int i=1;i<=n;i++){
		if(s[i]=='F')t[i]=t[i-1];
		else t[i]=s[i];
	}
	for(int i=1;i<n;i++)res2+=(t[i]==t[i+1]);
	
	return max(res,res2);
	
}


int calmin(){
	int res=0;
	t[0]='E';
	for(int i=1;i<=n;i++){
		if(s[i]=='F'){
			if(t[i-1]=='B')t[i]='E';
			else t[i]='B';
		}
		else t[i]=s[i];
	}
	for(int i=1;i<n;i++)res+=(t[i]==t[i+1]);
	
	int res2=0;
	t[0]='B';
	for(int i=1;i<=n;i++){
		if(s[i]=='F'){
			if(t[i-1]=='B')t[i]='E';
			else t[i]='B';
		}
		else t[i]=s[i];
	}
	for(int i=1;i<n;i++)res2+=(t[i]==t[i+1]);
	
	return min(res,res2);
	
}

signed main(){
	n=rd;
	for(int i=1;i<=n;i++)cin>>s[i];
	
	for(int i=2;i<n;i++)if(s[i-1]==s[i+1])a++;
	if(s[1]=='F')b++;
	if(s[n]=='F')b++;
	
	if(b)f=1;
	else f=2;
	
	int mn=calmin(),mx=calmax();
	cout<<(mx-mn)/f+1<<endl;
	for(int i=mn;i<=mx;i+=f)cout<<i<<endl;
	return 0;
}

```




---

## 作者：Zaku (赞：0)

这篇题解详细介绍证明答案是等差数列的全过程。

PS:思路及代码来自 Acwing 的视频讲解，本题解是对其的梳理和文字化。

### $\mathrm{Sol:}$

分讨+思维题。

以下我们设 `B` 为 `0`，`E` 为 `1`，`F` 为 `x`。那么可以随便写一个一般的样例，比如：`xxx01xxx0010xxxx011`。于是答案就是所有含 `x` 段的价值之和。

观察这个样例，我们发现：一共有三种可能的 `x...x` 段：

1. 两边都没有确定的取值。

2. 只有一边有确定的取值，比如第一段。

3. 左右都有确定的取值，比如上面的第二段和第三段。

那么一个自然的想法产生了：既然要算所有的段的价值之和，我们可以分这三种情况，把每种情况的价值都表示出来，再合并它们。

#### $\mathrm{Step\ 1:}$

我们先挑最简单的情况，也就是情况 1 下手。

如果存在这种段，那就意味着整个串是 `xxxxxxx` 的形式。不妨设一共有 $k$ 个 `x`，那一共就有 $k$ 个答案，并且答案从 $0$ 到 $k-1$ 都有可能。

为什么呢？因为这个串可以是 `0101010`，`0101011`，`0101000`，`0101111`，`0100000`，`0111111` 以及 `0000000`。答案分别是 $0$ 到 $k-1$。

这种情况特判即可。

#### $\mathrm{Step\ 2:}$

接下来讨论情况 2。

不妨设这种段为 `0xxxxxx`，其中有 $k$ 个 `x`。容易想到，这种段等价于 `xxxxxx0`，因为可以对称得到；同时它也等价于 `1xxxxxx`，因为可以取反得到。

举例：`0111011` 可以对称得到 `1101110` ，也可以取反得到 `1000100`。它们对答案贡献的数量相同。

那么每个这种段可以贡献多少种答案呢？和情况 1 相同，我们发现最多可以取全是 `0`，答案为 $k$。以此类推（建议读者自己再推推看），发现答案分别是 $0$ 到 $k$。

即每个情况 2 贡献的价值集合是从 $0$ 到 $k$，公差为 $1$ 的等差数列。

#### $\mathrm{Step\ 3:}$

最后要攻克情况 3 了。

这种情况比较复杂，因为它又细分为两种情况：左右取相同和左右取不同。

- 先看取相同。

同情况 2，我们设这种段为 `0xxxxx0`，其中有 $k$ 个 `x`。当然，它和左右都取 `1` 也是一样的。

那么来看这种情况。假设 $k=5$，那么最多可取 `0000000`，答案为 $6$，也就是 $k+1$。最少可取 `0101010`，答案为 $0$。

**这里以下是重点！！！** 我们发现 $k$ 取 $6$ 的话，最少为 `01010100`，就只能取 $1$ 而不是 $0$ 了！也就是说，如果 $k+1$ 是偶数的话，答案最少取到 $0$；反之最少取到 $1$。

好，最多最少都有了，那么中间的每一个值能否都取到呢？

这里我们来采用一种简单而有效的方式分析:

假设一段一般的情况 3 为 `0110100010`，我们考虑改动其中一位对最终答案的影响。

1. 修改第二位，则它的左边加一，右边减一。（`0 0 10100010`）
2. 修改第三位，则它的左边减一，右边加一。（`01 0 0100010`）
3. 修改第五位，它的则左右都加一。（`0110 0 00010`）
4. 修改第七位，则它的左右都减一。（`011010 1 010`）

好，我们发现，修改一位对答案的影响是增加 $2$ 或减少 $2$。

那所有可能的价值就是：$k+1,k+1-2,k+1-4,\dots,0/1$。

即当 $k+1$ 为偶数时，情况 3（左右取相同） 贡献的价值集合是从 $0$ 到 $k+1$，公差为 $2$ 的等差数列；反之，贡献的价值集合是从 $1$ 到 $k+1$，公差为 $2$ 的等差数列。

- 再看取不同。

同样地，我们设这种段为 `0xxxxx1`，其中有 $k$ 个 `x`。当然，它和左边取 `1`，右边取 `0` 也是一样的。

同上，我们经过简单的推导可知，答案最多取 $k$（`0000001`），当 $k$ 为偶数时，最少取 $0$（`01010101`）；反之，最少取 $1$（`0101011`）。

我们用同样的方法分析得到，所有可能的价值就是：$k,k-2,k-4,\dots,0/1$。

即当 $k$ 为偶数时，情况 3（左右取不同）贡献的价值集合是从 $0$ 到 $k$，公差为 $2$ 的等差数列；反之，贡献的价值集合是从 $1$ 到 $k$，公差为 $2$ 的等差数列。

#### $\mathrm{Step\ 4:}$

好，看到这里并自己分析一遍的读者可以喘口气了，我们已经把每种段的取值情况都分析完毕了。接下来的任务是：把所有的段加到一块，所有可能的取值有哪些！

- 先看中间的段（即情况 3）。

因为中间的段的取值都对应一个公差为 $2$ 的等差数列。

我们举一个例子：$1,3,5$ 和 $2,4,6,8$。这两个数列合并后的取值有哪些？手玩可以得出 $3,5,7,\dots,13$。刚好是首项为 $1+2$，末项为 $5+8$，公差为 $2$ 的等差数列！

当然对于两个一般的序列 $a$ 和 $b$，也是一样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/lhmrlx0q.png)

因为公差相同，所以最终得出的数列刚好是 $a_1+b_1,a_2+b_1,\dots,a_n+b_1,a_n+b_2,a_n+b_3,\dots,a_n+b_m$，而且公差也是 $2$！

所以要计算中间的段的总贡献，我们只需要计算每一段可取的最小值之和，以及每一段可取的最大值之和就行了！

- 再看两边的段（即情况 2）。

同样地，我们得出两个公差为 $1$ 的等差数列合并，仍然得到一个公差为 $1$ 的等差数列。

- 现在把上面两种情况加起来。

同样地，我们可以举一个例子：$2,4,6,8$ 和 $1,2,3$。现在考虑合并它们。

使用小学奥数的凑数法，得出 $3,4,5,\dots,11$。

所以一个公差为 $1$ 的等差数列和 一个公差为 $2$ 的等差数列合并，得到一个公差为 $1$ 的等差数列。

所以最终做法就有了：

1. 先求中间的段可以得到的最大值（即每一个 `x` 都和它前面一位取相同值时）和最小值（即每一个 `x` 都和它前面一位取不同值时）。

2. 再求两边的段可以得到的最大值（如果两边有段的话）。比如最开头的例子 `xxx01xxx0010xxxx011`，数一下两边的 `x` 的个数 $k$ 即可。

3. 合并 1 和 2。

### $\mathrm{Code:}$
[无注释源码](https://www.luogu.com.cn/paste/e7pe7gsc)

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n;
	string s;
	cin >> n >> s;
	//特判情况1
	if (s == string(n, 'F')){
		cout << n << '\n';
		for (int i = 0; i < n; i ++ )
			cout << i << '\n';
		return 0;
	}
	//求中间
	int l = 0, r = n - 1;
	while (s[l] == 'F') 
		l ++;
	while (s[r] == 'F') 
		r --;//排除两边的x，l和r是中间段和两边段的分界点
	int low = 0, high = 0;//分别是可以取到的最小值和最大值
	//先算最小值
	string t = s;
	for (int i = l; i <= r; i ++ ){
		if (t[i] == 'F'){//每一个x都取不同值
			if (t[i - 1] == 'B') 
				t[i] = 'E';
			else t[i] = 'B';
		}
		if (i > l && t[i] == t[i - 1])//l是边界，不能计入答案
			low ++;
	}
	//再算最大值
	t = s;
	for (int i = l; i <= r; i ++ ){
		if (t[i] == 'F')//每一个x都取相同值
			t[i] = t[i - 1];
		if (i > l && t[i] == t[i - 1]) 
			high ++;
	}
	int lb = l + n - 1 - r, d = 2;//lb是两边的最大值，即0~l-1和r+1~n-1。d是公差。
	if (lb) //两边存在，则合并，公差变为1
		high += lb, d = 1;
	cout << (high - low) / d + 1 << '\n';
	for (int i = low; i <= high; i += d )
		cout << i << '\n';
	return 0;
}
```

希望可以帮助到每一位认真读完的读者！如有不清楚或漏洞请指出！

---

## 作者：raozf (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9183)

### 题意

给定一个由 `FEB` 组成的字符串，需要将所有 $F$ 替换成 $E$ 或者 $B$，求相邻且相同位置的出现次数的数量以及所有次数。

### 思路

由于只需要考虑相邻的位置，所以每一段连续的 $F$ 是互不影响的，可以分别进行考虑。而连续的一段 $F$  又可以分成类，靠边的和被夹在中间的。

靠边的 $F$ 段较为简单，假定有 $c$ 个 $F$，不难发现只要让 `EB` 交错出现就可以达到最少次数 $0$，而让所有的 $F$ 都变成最近的非 $F$ 就可以达到最多次数 $c$，由内向外减少交错的长度就可以逐渐增加次数，使得 $[0, c]$ 中的任意次数都是可行的。

夹在中间的 $F$ 段稍微复杂一些，段的长度与两边字符的异同都会影响答案，不过还是可以先用贪心按顺序考虑每个 $F$，分别尽量保持不同和尽量保持不变就可以求出最少次数 $l$ 和最大次数 $r$。接下来再进行调整并观察可能的次数，不难发现每次调整都会使得答案刚好变化 $2$，而 $l$ 和 $r$ 的奇偶性也是相同的，所以只有 $[l, r]$ 之间与 $l$ 和 $r$ 同奇偶的答案是可行的。

综上所述，我们可以对每一段的下界和上界分别进行累加，就得到了最终答案的下界与上界。但是如果只有夹在中间的 $F$ 段，那么次数变化的步长为 $2$，否则只要有任意靠边的 $F$ 段，就可以让变化的步长变成 $1$，由此可以算出次数的数量，最后进行输出即可。

实现时不需要分段进行处理，通过判断首字母与末字母是否为 $F$ 就可以知道是否有靠边的段，然后直接贪心求解上下界即可。

对于全部为 $F$ 的情况要特判一下。

### 复杂度

#### 时间复杂度

贪心求解 $O(N)$。

#### 空间复杂度

存储串 $O(N)$。


# code:

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
int n,l,r,d;
int main(){
    cin>>n>>s;
    t=s;
    d=2-(s[0]=='F'||s[n-1]=='F');// 计算答案的间隔
    for(;r<n-1&&s[r]=='F';r++){// 找到第一个非 F 字符
    }
    for(int i=r+1;i<n;i++){// 依次考虑每个字符
        if(s[i]=='F'){// 可变
            t[i]=t[i-1];// 尽量保持不变
            s[i]=s[i-1]=='E'?'B':'E';// 尽量保持变化
        }
        l+=s[i]==s[i-1];// 累计答案上下界
        r+=t[i]==t[i-1];
        }
    cout<<(r-l)/d+1<<"\n";// 计算答案数量
    for(int i=l;i<=r;i+=d){// 枚举答案
        cout<<i<<"\n";
    }
    return 0;
}
```


---


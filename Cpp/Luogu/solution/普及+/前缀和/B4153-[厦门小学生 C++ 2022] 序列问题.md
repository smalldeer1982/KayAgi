# [厦门小学生 C++ 2022] 序列问题

## 题目背景

本试题为 2022 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

考虑到评测机性能差异，本题时限相较原题下调 0.5s。

## 题目描述

高老师是一位经验丰富的信息学竞赛指导教师，善于开发学生的创造性思维。周末课上，他给学生留下一道关于 $01$ 串的思考题（所谓 $01$ 串就是由字符 $0$ 和 $1$ 组成的字符串）：给定一个长度为 $n$ 的 $01$ 串，他想知道有多少个子串，满足其中 $1$ 的个数比 $0$ 的个数多。现在高老师请会编程的你来帮忙计算答案。 

## 说明/提示

### 样例解释

满足条件的子串有：$1$，$1$，$1$，$11$，$11$，$111$

### 数据范围

- 对于 $20\%$ 的数据，$n\leq 3000$。
- 对于另外的 $10\%$ 的数据，$n\leq 10^7$，字符串全为 $1$。
- 对于另外的 $20\%$ 的数据，$n\leq 2\times 10^5$。
- 对于另外的 $20\%$ 的数据，$n\leq 2\times 10^6$。
- 对于另外的 $100\%$ 的数据，$n\leq 10^7$。

## 样例 #1

### 输入

```
3
111```

### 输出

```
6```

# 题解

## 作者：yedalong (赞：2)

挺有趣的一道题，很适合正在学前缀和的同学练手。

## Solution

注意，下文默认下标从 $0$ 开始，且下文所提及的 $i$ 表示现在枚举到的下标，$qzh$ 代表前缀和数组。

### 暴力

我们可以先想一下暴力的解法。假设我们现在是要让 $l$ 到 $r$ 这个区间内 $1$ 的个数大于 $0$。那么我们先枚举 $l$，用两个变量 $cnt1$ 和 $cnt0$ 分别存储当前 $1$ 和 $0$ 的个数，随后枚举 $r$，对于当前 $cnt1>cnt0$，就将答案加 $1$。这种做法的时间复杂度是 $O(n^2)$，期望得分 $20$ 分。

### 前缀和加哈希表优化

接下来我们考虑给这个字符串做前缀和，将 $1$ 的贡献设为 $1$，$0$ 的贡献设为 $-1$。那么，当前缀和的值大于 $0$ 的时候，就说明 $0$ 到 $i$ 这段区间内 $1$ 的个数就大于 $0$ 的个数。\
但是对于 $l$ 和 $r$ 呢？$l$ 不一定为 $0$ 啊！这有咋办呢？我们发现如果 $qzh_r-qzh_{l-1}$ 如果大于 $0$ 其实就代表 $l$ 到 $r$ 这段区间内 $1$ 的个数大于 $0$ 的个数。那么对于 $r$，我们只需要求满足 $qzh_l<qzh_r$ 的 $l$ 的个数。\
现在我们用一个哈希表 $mp$，$mp_k$ 表示满足 $qzh_j=k\land j<i$ 的 $j$ 的个数，再来个变量 $cnt$，表示对于当前的前缀和前面有多少前缀和小于它。对于当前位置是 $1$，将 $cnt$ 加上 $mp_{sum}$，其中 $sum$ 表示当前的前缀和，对于当前位置是 $0$，将 $cnt$ 减去 $mp_{sum-1}$，最后每次都将 $ans$ 加上 $cnt$ 即可。\
这里再稍微解释一下上面这样做的原因。对于当前位置是 $1$ 的情况，我们 $sum$ 会加上 $1$，那么当前的 $sum$ 就满足条件了。同样的，当前位置是 $0$，$sum$ 就会减去 $1$，那么当前的 $sum-1$ 就不满足条件了。\
需要将 $mp_0$ 初始化为 $1$，同学们可以想想为什么。\
其实这种做法已经接近正解了，我整出了个 $90$ 分。。。\
这一部分没理解的同学请落实到位，很重要！！！\
[评测记录](https://www.luogu.com.cn/record/203652698)。

#### 90 分代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
unordered_map<ll,ll>mp;
string s;
ll ans,sum,cnt,n;
int main(){
    cin>>n>>s;
    mp[0]=1;
    for(int i=0;i<n;i++){
        if(s[i]=='1') cnt+=mp[sum],sum++;
        else cnt-=mp[sum-1],sum--;
        mp[sum]++; ans+=cnt;
    }
    cout<<ans<<'\n';
    return 0;
}
```

### 正解

这里会超时的原因是~~被卡常了~~哈希表很浪费时间。我们把哈希表改成数组就好了。。。\
这里将哈希表改成数组的原理很简单，因为 $sum$ 再怎么减都不会小于 $n$，我们只需将每一位都右移 $n$ 位即可，这样就能保证不会超到负数，数组开两倍大就好了。\
正解时间复杂度 $O(n)$，[跑得飞快](https://www.luogu.com.cn/record/203653693)。

## AC code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string s;
ll ans,sum,cnt,n,mp[20000005];
int main(){
    cin>>n>>s;
    mp[n]=1;
    for(int i=0;i<n;i++){
        if(s[i]=='1') cnt+=mp[n+sum],sum++;
        else cnt-=mp[n+sum-1],sum--;
        mp[n+sum]++; ans+=cnt;
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：1)

题意已经很简洁了不再赘述。

思路：

首先 $n \le 10^7$，暴力是肯定过不了的。

考虑前缀和优化快速计算子串数量。因为子串 $1$ 的数量要比 $0$ 多，所以计算前缀和时把 $1$ 看做 $1$ 计算，把 $0$ 看做 $-1$ 计算。那么判断一个区间是否满足要求只需要计算 $num_r - num_{l-1}$ 是否大于 $0$，再转化一下就是满足 $num_r \gt num_{l-1}$ 即可。

于是就可以记录出在此之前计算出的前缀和比当前的前缀和小的数量就行了。一开始用树状数组维护，但是发现时间复杂度还是有点高。

后来找了几个样例模拟发现，不需要把所有的比当前小的数都维护，可以一个一个传递下去。

设 $num$ 为前缀和，$ans$ 为比当前数小的数量，$res$ 为最终答案。

比如当 $s_i$ 为 $1$ 时，前缀和就为 $num+1$，比它小的就是 $num$，$ans$ 需要加上 $num$ 的数量；否则，前缀和就为 $num-1$，$num-1$ 就不满足条件，$ans$ 需要减去 $num-1$ 的数量。

然后就可以用一个数组记录 $num$ 的数量，不用 map 是因为 map 太慢。因为 $num$ 可能会一直减，为了保证数组下标为非负数，就提前加上 $n$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+5;
int n,res,num,ans;
char s[N];
int mp[N*2];
signed main(){
	scanf("%lld",&n);
	scanf("%s",s+1);
    mp[n]=1;
    for(int i=1;i<=n;i++){
        ans+=s[i]=='1'?mp[n+num]:-mp[n+num-1];
		num+=s[i]=='1'?1:-1;
        mp[n+num]++,res+=ans;
    }printf("%lld",res);
    return 0;
}
```

---

## 作者：wenlebo (赞：0)

第零秒：我们发现了这题：

第一秒：这不是给小屁孩做的大水题吗（掏出树状数组）！

第二秒：啊不对不对。

第三秒：啊对的对的。

好吧，我们先来分析下吧：

设前 $i$ 个字符有 $f_i$ 个零和 $d_i$ 个一，则对于 $i<j$ 由第 $i$ 个字符到第 $j$ 个字符的字串有 $f_j-f_{i-1}$ 个零和 $d_j-d_{i-1}$ 个一，使一的数量比零的数量多即为 $f_j-f_{i-1}<d_j-d_{i-1}$ 可得 $d_j-f_j>d_{i-1}-f_{i-1}$。设 $q(x)=d_x-f_x$ 则该不等式为 $q(j)>q(i-1)$。

我们来分析这个函数的性质，可知：

$$ q(x)=\begin{cases}
q(x-1)-1 & 字符串的这一位为零 \\
q(x-1)+1 & 字符串的这一位为一
\end{cases}$$

我们考虑动态规划，假如说以第 $i$ 个字符结尾的合法字串数位 $dp(i)$，易得 $dp(i)=\sum\limits_{j=1}^{i-1} [q(i)>q(j)]$，若这一位为一，$dp(i)=dp(i-1)+ \sum\limits_{j=1}^{i-1}[q(j)=q(i-1)]$，而若这一位为零，$dp(i)=dp(i-1)-\sum\limits_{j=1}^{i-1}[q(j)=q(i)]$。所以，我们只要有上一位的答案并使用一个数组存储至今为止有多少个 $j$ 满足 $q(j)=i$ 就可以线性的求出答案了！

代码十分简洁，看不懂公式也可以轻松理解！

```
#include <bits/stdc++.h>
using namespace std;
int n;
char c;
int aa;
long long ans,lastans;
int a[20000010];
int main(){
	cin>>n;
	aa=10000000;
	lastans=0;
	a[aa]=1;
	for(int i=1;i<=n;i++){
		cin>>c;
		if(c=='1'){
			lastans+=a[aa];
			aa++;
		}else{
			lastans-=a[aa-1];
			aa--;
		}
		ans+=lastans;
		a[aa]++;
	}
	cout<<ans;
	return 0;
}
```

---


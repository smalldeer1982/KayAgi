# [蓝桥杯青少年组省赛 2023] 数字游戏

## 题目背景

我觉得这题数据造的可能有问题，欢迎贡献正确的 std 和更强的数据。

## 题目描述

老师给出了一组数，要求小蓝对这组数进行调整，调整的规则如下：  
1. 第 $1$ 次，从这组数中选出一个最小的数，把它调整为和第二小的数一样大；  
2. 第 $2$ 次，再从这组数中选出一个最大的数，把它调整为和第二大的数一样大；  
3. 重复执行 $1$、$2$ 步骤；  
4. 当这组数中所包含的不同的数少于 $3$ 个时，结束调整。  

现在给定了一组数，请帮小蓝编写程序计算出总共的调整次数，以及调整结束时这组数中的最小数和最大数。  

**例 1：**  

当这组数是 $2,2,2,2$ 时，这组数中所包含的不同的数少于 $3$ 个（只有 $2$ 这一种数），无需调整，最后输出：

$$\boxed{0\quad 2\quad 2}$$

**例 2：**  

当这组数是 $1,3,4,2$ 时，调整过程如下：  
1. 先将这组数中最小的数 $1$，改成 $2$，这组数变为：$2,3,4,2$；
2. 再将这组数中最大的数 $4$，改成 $3$，这组数变为：$2,3,3,2$；

这时，这组数中只包含 $2$、$3$ 两个数了，满足规则 $4$，调整结束，总共调整了 $2$ 次，故最后输出：  

$$\boxed{2\quad 2\quad 3}$$

## 样例 #1

### 输入

```
4
1 3 4 2```

### 输出

```
2 2 3```

# 题解

## 作者：CRZ_AK_DZG (赞：2)

# B4274 数字游戏
## 1. 思路分析
### 题目大意：
进行若干次操作，第一次将 $1$ 个最大值变为次大值，第二次将 $1$ 个最小值变为次小值，直到不同的数少于 $3$ 个时，输出操作次数、剩下最大值和剩下最小值。

由于数字会重复出现，我们可以同时改变多个最大值和最小值代替模拟一次次操作，以此减轻时间复杂度。


---


## 2. 时间复杂度分析
最坏情况：当 $N=10^6$  ，且每一个数不一样，每次同时改变 $1$ 个最大值和 $1$ 个最小值，需要操作 $\frac{N-2}{2}=499,999$ 次，不难看出时间复杂度为 $O(n)$ ，简直完美。


---


## 3. 代码细节
1. 由于题目优先改变最大值，所以要注意当仅有 $1$ 个最大值和 $2$ 种不同的数时，无需同时与最小值一起改变，只需单独改变最大值即可。（详情见代码特判部分）
2. **十年 OI 一场空，不开 long long 见祖宗**。当 $N=10^6$ 且每一个数不一样时，答案约为 
$$2\sum_{i=1}^{\frac{N-2}{2}}i=2\times\frac{(5\times 10^5-1)\times5\times10^5}{2}$$
$$=25\times10^{10}-5\times10^5$$
明显超过 int 类型的最大值 $2^{31}-1$ 即 $2147483647$ ，所以使用 long long 存答案。

 
### 代码:
```cpp
#include<bits/stdc++.h>
#define int long long //无脑 long long 太爽了
using namespace std;
const int N = 1e6+5;
int n, m, idx, ans, vis[N];
struct node{
	//x为数值 t为次数的出现次数
	int x, t;
} a[N];
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		cin >> m;
		vis[m]++; //同标记出现次数
	}
	for(int i = 1; i <= 1e6; i++){
		//用vis数组维护a
		if(vis[i]) idx++, a[idx].x = i, a[idx].t = vis[i];
	}
	int l = 1, r = idx;
	while(r-l+1 >= 3){
		int tmp = min(a[l].t, a[r].t); //取左右出现次数最小值
		a[l].t -= tmp, a[l+1].t += tmp, ans += tmp; //左边减去最小值，并维护ans
		if(a[l].t == 0){ //当 a[l].t > a[r].t 时减去剩余的
			l++;
			if(r-l+1 < 3){//特判
				ans+= tmp-1;
				break;
			}
		}
		//右边同理
		a[r].t -= tmp, a[r-1].t += tmp, ans += tmp;
		if(a[r].t == 0){
			r--;
			if(r-l+1 < 3) break;
		}
	}
	cout << ans << ' ' << a[l].x << ' ' << a[r].x; //输出答案，收工~
	return 0;
}
```

---


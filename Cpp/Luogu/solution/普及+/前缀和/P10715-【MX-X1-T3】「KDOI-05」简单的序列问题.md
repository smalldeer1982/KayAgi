# 【MX-X1-T3】「KDOI-05」简单的序列问题

## 题目背景

原题链接：<https://oier.team/problems/X1C>。

## 题目描述

给出一个长度为 $n$ 的序列 $a$。定义其前缀和数组 $b_i=\sum_{j=1}^ia_j$。定义其权值 $S=\sum_{i=1}^n(b_i\bmod 2)$。

你可以对序列 $a$ 进行若干次如下操作：

* 交换 $a_i,a_j$，花费 $c_i+c_j$ 元，其中 $c$ 为给定序列；

对于 $i=0\sim n$，求使得 $S=i$ 的最少钱数。如果不可能，输出 $-1$。

## 说明/提示

**【样例解释】**

对于第一组数据，初始 $\sum_{i=1}^n(b_i\bmod 2)=2$，故使 $S=2$ 最少要花 $0$ 元。

交换 $a_1,a_2$ 即可使 $\sum_{i=1}^n(b_i\bmod 2)=1$，故使 $S=1$ 可以花费 $2$ 元。可以证明这是最优解。

可以证明不存在交换方案使得 $S=0$ 或 $S=3$。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $\sum n\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $10$ | $5$ | $50$ | 无 |
| $2$ | $10$ | $500$ | $500$ | $a$ 中至多有 $3$ 个奇数 |
| $3$ | $15$ | $30$ | $150$ | 无 |
| $4$ | $25$ | $100$ | $500$ | 无 |
| $5$ | $10$ | $500$ | $500$ | $c_i=1$ |
| $6$ | $30$ | $500$ | $500$ | 无 |

对于 $100\%$ 的数据：$1\leq n,\sum n\leq500$，$1\leq a_i\leq10^9$，$1\leq c_i\leq10^6$，$1\leq T\leq500$。

## 样例 #1

### 输入

```
3
3
1 2 3
1 1 1
5
1 2 3 4 5
2 5 3 6 4
10
1 8 3 5 2 6 3 4 6 2
3 2 7 1 8 2 5 8 3 1```

### 输出

```
-1 2 0 -1
-1 -1 7 0 9 -1
-1 -1 5 3 4 0 7 8 6 -1 -1```

# 题解

## 作者：cancan123456 (赞：7)

首先将 $a_i$ 变为 $a_i\bmod 2$，注意到我们不会交换两个相同的 $a_i$，只会交换 $0$ 和 $1$，且同一个位置不会被交换两次。

因此考虑将一次交换看成两次切换：$0\to1,1\to0$，且将 $a_i$ 切换需要 $c_i$ 的代价。

容易发现如果 $a_i$ 中 $1$ 的数量如果与操作后 $a_i'$ 中 $1$ 的数量相同，则总可以构造出一种交换方案能够将 $a_i$ 变为 $a_i'$，因此这种考虑是符合题意的。

现在设计 DP 状态：$f_{i,j,k}$ 表示考虑了 $a$ 长度为 $i$ 的前缀，已经得到了 $j$ 个 $1$，且前缀和序列 $b$ 的前 $i$ 项有 $k$ 个 $1$ 的最小花费。

初始状态显然为 $f_{0,0,0}=0$，其余状态全部为正无穷。

考虑从 $f_{i,j,k}$ 转移，设操作后 $a_{i+1}'=l$，其中 $0\le l\le1$，则有转移：

$$f_{i+1,j+l,(j+l)\bmod 2+k}\gets f_{i,j,k}+c_{i+1}[a_{i+1}\ne l]$$

求答案时，需要保证 $a_i'$ 中的 $1$ 数量等于 $a$ 中的 $1$ 数量 $t$，因此答案为 $f_{n,t,S}$，输出即可。

时间复杂度为 $O(n^3)$，可以通过此题，以下为赛时代码。

```cpp
#include <cstdio>
using namespace std;
const int N = 505;
int a[N], c[N], f[N][N][N];
int min(int a, int b) {
	return a < b ? a : b;
}
int main() {
	int T;
	scanf("%d", &T);
	for (int n; T != 0; T--) {
		scanf("%d", &n);
		int cnt = 0;
		for (int i = 1; i <= n; i++) {
			scanf("%d", &a[i]);
			a[i] %= 2;
			cnt += a[i];
		}
		for (int i = 1; i <= n; i++) {
			scanf("%d", &c[i]);
		}
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= n; j++) {
				for (int k = 0; k <= n; k++) {
					f[i][j][k] = 0x3f3f3f3f;
				}
			}
		}
		// f[i][j][k] 为前 i 个数中 a[x] = 1 有 j 个，b 中 1 的个数为 k 的最小代价.
		f[0][0][0] = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j <= n; j++) {
				for (int k = 0; k <= n; k++) {
					if (f[i][j][k] != 0x3f3f3f3f) {
						for (int l = 0; l <= 1; l++) {
							int & to = f[i + 1][j + l][k + (j + l) % 2];
							to = min(to, f[i][j][k] + c[i + 1] * (a[i + 1] ^ l));
						}
					}
				}
			}
		}
		for (int i = 0; i <= n; i++) {
			if (f[n][cnt][i] != 0x3f3f3f3f) {
				printf("%d ", f[n][cnt][i]);
			} else {
				printf("-1 ");
			}
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：xxseven (赞：5)

因为一个序列的权值只跟 $b_i \bmod 2$ 有关，而 $b_i \bmod 2= (\sum_{j=1}^i a_j) \bmod 2 = \sum_{j=1}^i a_j \bmod 2$，因此可以将 $a$ 数组在读入时先对 $2$ 取模，方便后续操作。  
之后若无特殊说明，在本题解中默认 $a$ 序列及变换后的序列为模 $2$ 处理后的。

因为数据范围只有 $500$，可以考虑 DP。

先给出一个结论：设最终序列为 $f$，那么变换至这个序列所需的金钱为 $\sum_{i=1}^n c_i \left[ f_i \neq a_i \right]$，即所有最终序列与原序列值不同的位置的权值和。  

下面证明：因为序列是在模 $2$ 意义下的，因此只会存在 $0,1$。如果有 $k$ 个 $a_i = 0,f_i = 1$ 的位置，那么必然有且仅有 $k$ 个 $a_i = 1, f_i = 0$ 的位置。将这 $2k$ 个数两两交换即为最小权值，也就是上面的式子。

接下来就可以对序列进行 DP 了。  

设 $ dp_{i,j,k}$ 表示前 $i$ 个数，总和为 $j$ 即出现了 $j$ 个 $1$，目前的权值为 $k$ 的最小代价，边界为 $dp_{0,0,0}=0$，其余状态赋值为正无穷表示非法，最终答案为 $dp_{n,cnt,i}$，其中 $cnt$ 表示原始序列中 $1$ 的个数，$i$ 的取值从 $0$ 到 $n$。

根据第 $i$ 位是 $0$ 还是 $1$，$dp_{i,j,k}$ 可以由 $dp_{i-1,j,k-j \bmod 2}$ 或者 $dp_{i-1,j-1,k-j \bmod 2}$ 转移而来。而根据上面的结论，如果这一位与原序列上同一位的值不同，代价要加上这一位的权值。

因此状态转移方程如下：`dp[i][j][k]=min(dp[i-1][j][k-j%2]+a[i]*c[i],dp[i-1][j-1][k-j%2]+(a[i]^1)*c[i])`，特判 $j=0$ 时去掉后面一项即可。  
另外，由于每一位都是由上一位转移而来，可以使用滚动数组，倒序枚举 $j,k$ 压掉一维。

时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$，可以通过本题。

完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int n,a[N],c[N],dp[N][N],cnt;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	int T; cin>>T;
	while(T--){
		cin>>n; cnt=0;
		for(int i=1;i<=n;++i) {
			cin>>a[i]; a[i]%=2; cnt+=a[i];
		}
		for(int i=1;i<=n;++i) cin>>c[i];
		memset(dp,0x3f,sizeof(dp)); dp[0][0]=0;
		for(int i=1;i<=n;++i){
			for(int j=i;j>=0;--j){
				for(int k=i;k>=j%2;--k){
					if(j==0) dp[j][k]=dp[j][k-j%2]+a[i]*c[i];
					else dp[j][k]=min(dp[j][k-j%2]+a[i]*c[i],dp[j-1][k-j%2]+(a[i]^1)*c[i]);
				}
			}
		}
		for(int i=0;i<=n;++i){
			cout<<(dp[cnt][i]>=0x3f3f3f3f?-1:dp[cnt][i])<<' ';
		}
		cout<<'\n';
	} 
	return 0;
}
```

希望这篇题解能够帮到你！

---

## 作者：未来姚班zyl (赞：3)

## 题目大意

题面已经很形式化了。

## 题目分析

显然 $a_i$ 与 $b_i$ 都可以看成看成 $01$ 序列，且只有 $a_i$ 不同的位置才会交换。

交换可以看成一个 $1$ 换到一个 $0$ 的位置上，所以每个位置只可能操作一次。假如我们有个最终的序列 $a'$，则花费就是 $a'$ 与 $a$ 值不同的位置的 $c_i$ 之和。

所以可以 dp，设 $dp_{i,j,k}$ 表示前 $i$ 个，$1$ 的个数是 $j$，$b$ 的和是 $k$ 的最小花费，转移是 $O(1)$，滚动数组优化空间即可，复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
#define mid (l+r>>1)
#define Root 1,1,n+1
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define e(x) for(int i=h[x],y=to[i];i;i=nxt[i],y=to[i])
#define E(x) for(auto y:p[x])
#define Pi pair<int,int>
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=5e2+5,M=4e6+5,inf=(1LL<<31)-1,mod=1e9+7;
const ll llf=1e18;
int n,a[N],c[N],b[N],ct,d[N],S,f[N][N],F[N][N];
inline void Main(){
	n=read(),ct=S=0;
	repn(i)a[i]=read()&1,b[i]=b[i-1]^a[i],ct+=a[i],S+=b[i];
	repn(i)c[i]=read();
	rep(i,0,n)rep(j,0,n)f[i][j]=F[i][j]=llf;
	rep(i,0,n)d[i]=llf;
	f[0][0]=0;
	repn(i){
		rep(s,0,n)rep(cnt1,0,ct){
			//选 1
			int cs=(!a[i])*c[i],w=f[s][cnt1],ex=!(cnt1&1);
			F[s+ex][cnt1+1]=min(F[s+ex][cnt1+1],w+cs);
			cs=a[i]*c[i],ex=cnt1&1;
			F[s+ex][cnt1]=min(F[s+ex][cnt1],w+cs);
		}
		rep(i,0,n)rep(j,0,n)f[i][j]=F[i][j],F[i][j]=llf;
	}
	rep(s,0,n)d[s]=min(d[s],f[s][ct]);
	rep(i,0,n)if(d[i]==llf)cout <<"-1 ";
	else cout <<d[i]<<" ";
	cout <<'\n';
}
signed main(){
	int T=read();
	while(T--)Main();
	return 0;
}	
```

---

## 作者：BeeAC (赞：2)

## 思路
显然 $S$ 的值只与 $a_i \bmod 2$ 有关，将 $a_i$ 变为 $a_i \bmod 2$, $b_i$ 变为 $b_i \bmod 2$ 并不影响答案。

此时 $a_i$ 和 $b_i$ 都可以看成 $01$ 序列，为了使总钱数最少，只有 $a_i$ 的不同位置才可能交换，且每个位置只可能交换一次。

设最终序列为 $a'$，那么变换为这个序列所需的最少钱数为 $ \sum_{i = 1}^{n} c_i \lbrack a_i' \ne a_i \rbrack$。

设 $f_{i,j,k}$ 表示前 $i$ 个数已经出现了 $j$ 个 $1$，目前权值为 $k$ 要花费的最少钱数，初始状态为 $f_{0,0,0}=0$，其余状态全部设为 $+∞$，最终答案为 $f_{n,cnt,i}$，其中 $cnt$ 表示序列 $a$ 初始时 $1$ 的个数，$i$ 的取值从 $0$ 到 $n$。

考虑第 $i$ 位可以是 $0$ 或 $1$，显然 $f_{i,j,k}$ 可以由 $f_{i-1,j,k-j \bmod 2}$ 或 $f_{i-1,j-1,k-j \bmod 2}$ 转移而来。如果第 $i$ 位与原序列上同一位的值不同，总钱数要加上 $c_i$，则有转移：
$$
f_{i,j,k} \gets \min(f_{i-1,j,k-j \bmod 2}+c_i\lbrack a_i \ne a_i'\rbrack,f_{i-1,j-1,k-j \bmod 2}+c_i\lbrack a_i \ne a_i'\rbrack)
$$

时间复杂度为 $O(n^3)$。由于每一位都是由上一位转移而来，可以使用滚动数组，倒序枚举 $j,k$ 减小一维，将空间复杂度从 $O(n^3)$ 优化至 $O(n^2)$。
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505,INF=0x3f3f3f3f;
int t,n,s,a[N],c[N],f[N][N];
inline void read(int &x)//快读
{
	x=0;short f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	x*=f;
}
inline void write(int x)//快写
{
	if(x<0)
		putchar('-'),x=-x;
	if(x>9)
		write(x/10);
	putchar(x%10+'0');
}
inline int min(int x,int y)
{
	return x<y?x:y;
}
int main()
{
	read(t);
	while(t--)
	{
		read(n);
		s=0;
		for(int i=1;i<=n;++i)
		{
			read(a[i]);
			s+=a[i]&=1;
		}
		for(int i=1;i<=n;++i)
			read(c[i]);
		memset(f,INF,sizeof(f));
		f[0][0]=0;
		for(int i=1;i<=n;++i)
			for(int j=i;j>=0;--j)
				for(int k=i;k>=j&1;--k)
				{
					f[j][k]=f[j][k-(j&1)]+a[i]*c[i];
					if(j)//防止j-1<0
						f[j][k]=min(f[j][k],f[j-1][k-(j&1)]+(a[i]^1)*c[i]);
				}
		for(int i=0;i<=n;++i)
		{
			write(f[s][i]==INF?-1:f[s][i]);
			printf(" ");
		}
		printf("\n");
	} 
	return 0;
}
```

---

## 作者：Nailoong_SHM (赞：1)

# P10715 简单的序列问题 题解
[题目连接点这里](https://www.luogu.com.cn/problem/P10715)
## 一. 题目分析
1. 在这道题目中，我们只需关注 $a_{i}$ 的奇偶。
2. 我们一定不会交换两个相同（奇偶）的数。
3. 同一个位置没必要交换两次（不然就换回来了）。
4. 这里就会用到技巧了：毕竟只有 $0$ 和 $1$，交换一次相当于把一个 $0$ 变成 $1$，把一个 $1$ 变成 $0$。且 $0$ 对题目的花费无影响，所以只要关注 $1$ 就可以了。
## 二. 做法（dp 分析）
做一道 dp 题目，我认为有以下 5 点。
### 1. 状态
$dp_{i,j,k}$ 表示取长度为 $i$ 的前缀，共有 $j$ 个 $1$，$S$ 为 $k$ 的最小花费。
### 2. 转移方程
考虑向后转移，$t$ 表示转化为 $t$（$a_{i}\neq t$）。
```cpp
dp[i+1][j+p][k+(j+p)%2]=min(dp[i+1][j+p][k+(j+p)%2],dp[i][j][k]+(a[i+1]==p?0:c[i+1]));
```
### 3. 初始化
除了 $dp_{0,0,0}=0$，其余都为 $+\infty$。
### 4. 答案
所有 $dp_{n,tot,i}$，其中 $tot$ 表示原 $a$ 数组中 $1$ 的个数。
### 5. 推导顺序
- 向后推导
- 三层循环直接推导
## 三.代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int inf=0x3f3f3f3f;//定义正无穷
int t,n;
int a[510],c[510];
int dp[510][510][510];//三维dp数组
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=0;i<=n;i++)
			for(int j=0;j<=n;j++)
				for(int k=0;k<=n;k++)
					dp[i][j][k]=inf;
		dp[0][0][0]=0;//初始化
		int tot=0;
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			tot+=(a[i]%=2);//将a[i]变成0/1
		}
		for(int i=1;i<=n;i++) scanf("%d",&c[i]);
		for(int i=0;i<n;i++){//转移（因为是向后转移到 i+1，所以只需循环到 n-1 即可
			for(int j=0;j<=n;j++){
				for(int k=0;k<=n;k++){
					if(dp[i][j][k]==inf) continue;//这个状态不非法才可以向后转移
					for(int p=0;p<2;p++){//转为 0/1
						//转移方程
						dp[i+1][j+p][k+(j+p)%2]=min(dp[i+1][j+p][k+(j+p)%2],dp[i][j][k]+(a[i+1]==p?0:c[i+1]));
					}
				}
			}
		}
		for(int i=0;i<=n;i++){//最后统计答案
			if(dp[n][tot][i]!=inf) printf("%d ",dp[n][tot][i]);
			else printf("-1 ");
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Nangu (赞：1)

~~这道题竟然只有绿，果然还是我太菜了QwQ。~~

首先，$a_i\bmod2\to a_i$，同时令 $b_i$ 为数组前 $i$ 位的异或和。这显然不影响答案。

考虑搞出一个更简洁的做法算出一个数组的权值，这里以第三个数据为例：
```
a：1 0 1 1 0 0 1 0 0 0
b: 1 1 0 1 1 1 0 0 0 0
```

容易看出，在 **$a$ 中第奇数个 $1$ 后开始，偶数个 $1$ 结束之前，$b$ 数组中对应的位置值都为 $1$**。于是设数组 $d$ 为 $a$ 中为 $1$ 的位置集合，显然答案为 $\sum d_{2k}-d_{2k-1}$，即为 $\sum d_i\times s(i)$，其中当 $i$ 为偶数时 $s(i)$ 为 $1$，否则为 $-1$。若 $a$ 中共有奇数个 $1$，则最后一个 $1$ 之后对应的所有 $b_i$ 都为 $1$，共有 $n-i+1$ 个 $1$，即在刚刚所求答案之后再加一个 $n+1$。

如果将一个数 $a_i$ 从 $0$ 变为 $1$ 或从 $1$ 变为 $0$，那么与他交换的 $a_j$ 同样也要发生变化，代价 $c_i+c_j$。在考虑 $a_i$ 的变化时，我们其实可以不考虑 $j$ 是多少，直接将代价视为 $c_i$。因为这样子做，当扫到 $j$ 时，$a_j$ 也同样发生变化，因此产生 $c_j$ 的代价，合起来就是 $c_i+c_j$ 了。

于是该题的操作就没有后效性了。考虑 dp，设 $f_{i, j, k}$ 
表示当前枚举到第 $i$ 位，共用掉了 $j$ 个 $1$，当前 $d$ 数组的和为 $k$ 进行转移。初始状态和状态转移显然。另外，为了不 MLE，要将 $f$ 的第一维压掉。

## 代码：
```cpp
#include<bits/stdc++.h>
#define F(i, j, k) for(int i=(j); i<=(k); ++i)
#define R(i, j, k) for(int i=(j); i>=(k); --i)
#define int long long
using namespace std;
const int N=507, INF=1e18;
int n, m, f[2][N][N*5], a[N], c[N], cnt;
bool d;
int K(int x){return x%2==0?1:-1;}//题解中的s 

void print(int x){
	cout<<(x>=INF?-1:x)<<' ';
}

main(){
	cin>>n, m=n*2.5, cnt=0;
	F(i, 1, n) cin>>a[i], a[i]&=1, cnt+=a[i];//cnt:1的个数 
	F(i, 1, n) cin>>c[i];
	memset(f, 0x3f, sizeof f);
	if(a[1]) f[d][1][m-1]=0, f[d][0][m]=c[1];
	else f[d][0][m]=0, f[d][1][m-1]=c[1];
	F(i, 2, n){
		d^=1;
		F(j, 0, cnt)
			F(k, -n-1, n+1){
				f[d][j][k+m]=min(f[d^1][j][k+m]+(a[i]==1)*c[i],
					j?f[d^1][j-1][k-K(j)*i+m]+(a[i]==0)*c[i]:INF);
			}
	}
	if(cnt%2==0) F(i, 0, n) print(f[d][cnt][i+m]);
	else F(i, 0, n) print(f[d][cnt][i+m-n-1]);//若cnt为奇数，则有一个落单的1，要加上n+1 
	cout<<'\n';
}

---

## 作者：MutU (赞：0)

### [原题传送门](https://www.luogu.com.cn/problem/P10715)

## 题意简化

> 题意即求使得序列的前缀和数组 $b$ 中有 $i$ 个奇数的最小代价。略加思考容易发现，我们可以直接把偶数视作 $0$，奇数视作 $1$。
> 
> 并且我们发现若要交换两个数，交换 $0$ 和 $0$，$1$ 和 $1$ 没有意义。

## 思路分析

对于这样对于同一个序列求多个答案的问题，很套路地想到 dp 求解。

考虑定义状态 $f_{i,j,k}$ 表示前 $i$ 个数中存在 $j$ 个元素 $1$，前缀和数组 $b$ 中有 $k$ 个奇数的最小花费。

**为什么这么定义？** 我们发现，如果前缀和数组中 $b_i$ 是奇数，$i$ 前面必有奇数个元素 $1$。所以通过开一维 $j$ 记录元素 $1$ 的数量，可以判断该数量是否为奇数，很方便的转移 $k$ 这一维。

## 状态转移

考虑由 $f_{i,j,k}$ 能够转移到的状态，第一维为 $i+1$。

- 如果转移到第 $i+1$ 个元素为 $0$ 的情况，且第 $i+1$ 个元素原本为 $0$。那么不需要交换，直接根据 $1$ 的数量转移。

- 如果转移到第 $i+1$ 个元素为 $0$ 的情况，且第 $i+1$ 个元素原本为 $1$。那么需要交换一个 $1$ 过来，花费 $c_{i+1}$ 的代价。

- 其他情况类似。

- 如果转移到的那一位为 $0$，它前面有奇数个 $1$，那么答案加 $1$。如果那一位为 $1$，则需要前面有偶数个 $1$。

- 为什么交换时只需要考虑 $c_{i+1}$？感性理解一下：我们要求的答案为 $f_{n,sum,i}$，其中 $sum$ 表示总元素 $1$ 个数。如果我们在前面某一位上交换了，在后面某一位没有对应的一个交换，那么显然无法使 $1$ 的个数等于 $sum$，也就无法影响我们的答案。


归纳一下，得到两个状态转移方程，核心代码如下。

```cpp
//这里使用了滚动数组
f[0][0][0]=0;
for(int i=0;i<n;i++){
	for(int j=0;j<n;j++){
		for(int k=0;k<n;k++){
			if(f[0][j][k]==(int)1e18) continue;
			f[1][j+1][k+(j+1)%2]=min(f[1][j+1][k+(j+1)%2],f[0][j][k]+c[i+1]*(a[i+1]^1)); //用一个循环0-1也是可以的
			f[1][j][k+j%2]=min(f[1][j][k+j%2],f[0][j][k]+c[i+1]*(a[i+1]^0));
		}
	}
	for(int x=0;x<=n;x++)for(int y=0;y<=n;y++)f[0][x][y]=f[1][x][y],f[1][x][y]=1e18; //滚动
}
```

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 510;
int T,sum,n,a[N],c[N],f[2][N][N];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>T;
	while(T--){
		sum=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			a[i]=(a[i] & 1);
			sum+=a[i];
		} 
		for(int i=1;i<=n;i++) cin>>c[i];
		for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)f[0][i][j]=f[1][i][j]=1e18;
		f[0][0][0]=0;
		for(int i=0;i<n;i++){
			for(int j=0;j<n;j++){
				for(int k=0;k<n;k++){
					if(f[0][j][k]==(int)1e18) continue;
					f[1][j+1][k+(j+1)%2]=min(f[1][j+1][k+(j+1)%2],f[0][j][k]+c[i+1]*(a[i+1]^1));
					f[1][j][k+j%2]=min(f[1][j][k+j%2],f[0][j][k]+c[i+1]*(a[i+1]^0));
				}
			}
			for(int x=0;x<=n;x++)for(int y=0;y<=n;y++)f[0][x][y]=f[1][x][y],f[1][x][y]=1e18;
		}
		for(int i=0;i<=n;i++){
			if(f[0][sum][i]==(int)1e18) cout<<-1<<' ';
			else cout<<f[0][sum][i]<<' ';
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：Rose_Melody (赞：0)

## Solution：P10715 简单的序列问题
[题目传送门](https://www.luogu.com.cn/problem/P10715)

### 题目分析

序列权值只与 $b_{i} \bmod 2$ 有关，$b_{i} \bmod 2 = \sum _ {j = 1}^i a_{i} \bmod 2$，可以在输入时对 $a_{i}$ 进行取模，并进行累加。

一看数据范围，$n\le500$，可以考虑时间复杂度 $O(n^{3})$ 的状态转移方程。

经过推导，得出结论：设最终序列为 $t$，那么变换至这个序列所需的金钱为 $\sum_{i=1}^n [t_{i}\neq a_{i}]$，即所有最终序列与原序列值不同的位置的权值和。

设 $f_{i,j,k}$ 表示前 $i$ 个数，出现 $j$ 次 $1$，当前权值为 $k$ 的最小金钱，初始化 $f$ 无穷大，令 $f_{0,0,0} = 1$，对于第 $i$ 的值是 $0$ 或 $1$，$f_{i,j,k}$ 可以由 $f_{i-1,j,k-(j \bmod 2)}$ 和 $f_{i-1,j-1,k-(j \bmod 2)}$ 转移而来，而根据上面的结论，如果这一位与原序列上同一位的值不同，代价要加上这一位的权值。

所以便导出状态转移方程：
$$f_{i,j,k} \gets \min(f_{i-1,j,k-(j \bmod 2)} + a_{i} \times c_{i} , f_{i-1,j-1,k-(j \bmod 2)} + (a_{i} \oplus 1) \times c_{i})$$
对于 $j=0$ 时特判一下即可，采用滚动数据优化，倒序对 $j,k$ 进行枚举，将空间降至二维。最后枚举 $i$ 从 $0$ 到 $n$，输出 $f_{cnt,i}$，$cnt$ 为原序列中 $1$ 的个数。

### AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N = 505 , INF = 0x3f , Max = 0x3f3f3f3f;
int a[N] , c[N] , f[N][N] ;
int T , n ;
int read(){
	int x = 0 , f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1 ;
		ch = getchar() ;
	}
	while('0' <= ch && ch <= '9'){
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar() ;
	}
	return x * f ;
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout); 
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	T = read();
	while (T --) {
		n = read();
		int cnt = 0;
		for (int i = 1; i <= n; i++) {
			a[i] = read();
			a[i] %= 2;
			cnt += a[i];//取模并累计
		}
		for (int i = 1; i <= n; i++) {
			c[i] = read();
		}
		memset(f , INF , sizeof f) ; 
		f[0][0] = 0; //初始化
		for (int i = 1; i <= n; i++) {
			for (int j = i; j >= 0; j--) {
				for (int k = i; k >= j % 2; k--) {
					if (! j) {
						f[j][k] = f[j][k - j % 2] + a[i] * c[i] ;
					}
					else f[j][k] = min(f[j][k - j % 2] + a[i] * c[i] , f[j - 1][k - j % 2] + (a[i] ^ 1) * c[i]) ;
				}
			}
		}
		for (int i = 0; i <= n; i++) {
			if (f[cnt][i] < Max) {
				cout << f[cnt][i] << ' ' ;
			} 
			else {
				cout << "-1" << " " ;
			}
		}
		cout << '\n' ;
	}
	return 0;
}
```

---

## 作者：Xiao_Xiao_Yu (赞：0)

题意：给定序列 $a$ 和代价序列 $c$，令 $a$ 的前缀和序列为 $b$，$S$ 为 $b$ 中的奇数个数。可以花费 $c_i+c_j$ 的代价交换 $a_i,a_j$，求使得 $S$ 分别等于 $0,1,...,n$ 的最小代价或给出无解。

因为 $S$ 只与奇偶性相关，我们可以直接将 $b_i$ 视为 $b_i\bmod2$，即将其转化为 $0/1$ 序列，下文中的 $b$ 均指进行上述转化后的序列。这样一来，本题的一些性质就能明显体现出来：

1. 交换两个奇偶性相同的数没有意义；
2. 交换两个奇偶性相异的数 $a_i,a_j$，会使 $b_i,b_i+1,...,b_j-1$ 反转；
3. 一个数最多被交换一次；
4. $a$ 中的偶数对之后的 $b$ 无影响，奇数会反转其之后的 $b$。

可以看出，奇数是本题的关键，子任务 2 的特殊性质也表明了这一点：

> $a$ 中至多有 $3$ 个奇数

所以我们可以考虑规划奇数所处的位置。

最优化问题考虑动态规划：设 $dp_{i,j,s}$ 表示在 $a$ 中前 $i$ 个数中有 $j$ 个奇数，且 $b_1,...,b_k$ 中有 $s$ 个奇数时所需最小代价。

但如果就这么开始写转移方程，你会发现之前选取了哪些奇数会产生后效性，而一并记录在状态当中会使状态空间过大，于是我们进行这一步转化：

假设所有奇数最后都会变动位置，那么最后的代价一定会加上所有奇数对应的代价 $\sum _{a_i\bmod2=1}c_i$（记为 $sum$）。那么这一部分的代价可以直接提前加到结果中。

但实际上我们最后不一定会变动所有奇数的位置，于是在状态转移过程中找出这些未变动的位置，即原来是奇数的位置上还是奇数，然后减去多加的代价即可。具体实现中，我们可以先计算出 $sum$，在状态转移过程中遇到“原来是奇数的位置上还是奇数”的情况就减去对应位置上的 $c$，然后在输出过程中再对每个结果加上 $sum$。

利用性质 2，我们可以根据 $j$ 计算出下一个 $b$ 的奇偶性，容易推出两者的奇偶性相同。于是接下来对 $j$ 的奇偶性进行讨论，决策第 $i$ 个数放不放奇数即可。

- $j$ 为奇数时，如果第 $i$ 个数放奇数且 $a_i$ 为偶数，那么根据上文，$b_i$ 的值为 $1$，故应从  $dp_{i-1,j-1,s-1}$ 转移过来，并加上换掉第 $i$ 个数的代价 $c_i$，即 $dp_{i,j,s}=dp_{i-1,j-1,s-1}+c_i$；
- $j$ 为奇数时，如果第 $i$ 个数放奇数且 $a_i$ 为奇数，下一个 $b$ 的值仍为 $1$，且按照我们的转化，这里需要减去 $c_i$，即 $dp_{i,j,s}=dp_{i-1,j-1,s-1}-c_i$；
- $j$ 为奇数时，如果第 $i$ 个数放偶数且 $a_i$ 为奇数，下一个 $b$ 的值为 $0$，故应从  $dp_{i-1,j,s}$ 转移过来，且按照我们的转化，这里不再需要加上 $c_i$，因为这部分代价已经算在最后要加上的 $sum$ 里了，即 $dp_{i,j,s}=dp_{i-1,j,s}$；
- $j$ 为偶数时，如果第 $i$ 个数放偶数且 $a_i$ 为偶数，也就是第 $i$ 个数不进行交换，自然没有代价，即 $dp_{i,j,s}=dp_{i-1,j,s}$；

类似地我们可以推出 $j$ 为偶数时的转移方程（这部分留给读者自己推导）。我们发现，这八种情况其实可以进行合并：上述四种情况的后两种的转移相同，而前两种仅有 $c_i$ 项的正负的差别。于是在具体实现中，我们可以将所有奇数对应的代价 $c_k$ 视为 $-c_k$，然后将这两种情况的转移统一为 $+c_i$。

接下来按照转移方程进行转移即可，初始化：$dp_{0,0,0}=0，其余为 +\infty$，每组数据时间复杂度为 $O(n^3)$，足以通过本题。

注意事项：
- 如果每组数据都使用 `memset(dp, 0x3f, sizeof(dp))` 进行初始化的话会导致有 2 个测试点可能被卡。在转移过程中每遍历到一个 $dp_{i,j,s}$ 时先将其置为 $+\infty$ 再转移即可。
- 当 $j,s$ 为 $0$ 时，$j-1,s-1$ 是不合法的下标，需要在转移时舍去所有含不合法下标的部分。
- $dp$ 数组开 `long long` 会爆空间，实际上开 `int` 就足以使用了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 500 + 5, inf = 0x3f3f3f3f;

int t, n, a[maxn], c[maxn];
int dp[maxn][maxn][maxn], sum, cnt;

int main() {
	memset(dp, 0x3f, sizeof(dp));
	scanf("%d", &t);
	while (t--) {
		scanf("%d", &n);
		for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
		sum = cnt = 0;
		for (int i = 1; i <= n; ++i) {
			scanf("%d", &c[i]);
			if (a[i] & 1) {
				sum += c[i]; c[i] *= -1; ++cnt;
			}
		}
		dp[0][0][0] = 0;
		for (int i = 1; i <= n; ++i) 
			for (int j = 0; j <= cnt; ++j) 
				for (int k = 0; k <= n; ++k) {
					dp[i][j][k] = inf;
					if (j & 1) {
						if (!k) continue;
						dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1]);
						dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k - 1] + c[i]);
					} else {
						dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k]);
						if (j) dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][k] + c[i]);
					}
				}
		for (int i = 0; i <= n; ++i) {
			int ans = dp[n][cnt][i] + sum;
			printf("%d ", ans >= inf ? -1 : ans);
		}
		puts("");
	}
	return 0;
}
```

---


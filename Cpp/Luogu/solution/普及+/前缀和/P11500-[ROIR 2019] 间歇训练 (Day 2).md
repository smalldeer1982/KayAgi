# [ROIR 2019] 间歇训练 (Day 2)

## 题目背景

翻译自 [ROIR 2019 D2T2](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day2.pdf)。

## 题目描述

体育学院开发了一种新的间歇训练方法。根据这种方法，运动员每天都要训练，但负荷的增加和减少必须交替进行。

训练计划由一组正整数 $a_{1}, a_{2}, \dots, a_{m}$ 组成，其中 $a_{i}$ 描述了运动员在第 $i$ 天的训练负荷。任何两个相邻的天数的负荷不能相同，即 $a_{i} \neq a_{i+1}$。为了使负荷的增加和减少交替进行，$a$ 必须满足以下条件：如果 $a_{i}<a_{i+1}$，则 $a_{i+1}>a_{i+2}$；如果 $a_{i}>a_{i+1}$，则 $a_{i+1}<a_{i+2}$。

在整个训练计划中，总负荷必须为 $n$，即 $\sum\limits_{i=1}^{m}a_i=n$。计划的天数没有限制，即 $m$ 可以是任意值，但第一天的负荷是固定的，$a_{1}=k$。

学院管理层想知道有多少不同的训练计划符合上述要求。你只需要求出其对 $10^{9}+7$ 取模的结果。

## 说明/提示

### 样例解释

在样例 $1$ 中，符合要求的计划有 $[2,1,2,1], [2,1,3], [2,3,1], [2,4]$。

在样例 $2$ 中，唯一符合要求的计划为 $[3]$。

### 数据范围

数据中 Subtask 0 为样例。

| 子任务 | 分值 | $1\le n\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $23$ | $10$ |
| $2$ | $20$ | $30$ |
| $3$ | $23$ | $500$ |
| $4$ | $34$ | $5000$ |

## 样例 #1

### 输入

```
6 2```

### 输出

```
4```

## 样例 #2

### 输入

```
3 3```

### 输出

```
1```

# 题解

## 作者：yi_hr (赞：7)

## DP
**题目重点，需要满足的条件：**  
1. 总负荷为 $n$。
2. 第一天的负荷为 $k$。
3. 相邻两天的负荷不同，即 $a_i \neq a_{i+1}$。
4. 负荷的增加和减少交替进行：
   - 如果 $a_i < a_{i+1}$，则 $a_{i+1} > a_{i+2}$。
   - 如果 $a_i > a_{i+1}$，则 $a_{i+1} < a_{i+2}$。
## DP 思路
### 设计状态：
1. **`f1[i][j]`:** 总负荷为 $i$，最后一天的负荷为 $j$，且前一天的负荷比倒数第二天的负荷小，即最后一次变化为**增加**。
2. **`f2[i][j]`：** 总负荷为 $i$，最后一天的负荷为 $j$，且前一天的负荷比倒数第二天的负荷大，即最后一次变化为**减少**。

### 递推边界：
- 第一天的负荷为 $k$。
- 对于第二天的负荷 $a_2$：
  - 若 $a_2>k$，则将 `f1[k + a2][a2]`赋值。
  - 若 $a_2<k$，则将 `f1[k + a2][a2]`赋值。
- 如果 $k = n$，则序列 k 是唯一的有效序列。
### 状态转移：
对于每一个总负荷 $s$ 从 $k+1$ 到 $n$：
1. **计算前/后缀和**：
   - `s1[v]`：表示所有 $v'<v$ 的 `f2[s][v']` 的累加和。
   - `s2[v]`：表示所有 $v'>v`$ 的 `f1[s][v']` 的累加和。
2. **转移状态**：
   - 对于每下一个可能的负荷 $u$：
     - **f2**：将所有上一次是 `f1[s][v']` 且 $v' > u$ 的情况累加到 `f2[s + u][u]`。
     - **f1**：将所有上一次是 `f2[s][v']` 且 $v' < u$ 的情况累加到 `f1[s + u][u]`。
### 答案
答案为 `f1[n][v]` 和 `f2[n][v]` 对所有 $v$ 的和。如果 $k = n$，还需要加上序列 k。  
## code
**注：** 个人习惯，用一维数组模拟二维数组，见谅。
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=1e9+7,N=5e7+9,M=1e5+9;
int n,k;
int f1[N],f2[N];
int s1[M],s2[M];
ll ans;
int main() {
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=k+1;i<=n;i++){
		if(k+i<=n) {
			f1[(k+i)*(n+1)+i]=(f1[(k+i)*(n+1)+i]+1)%MOD;
		}
	}
	for(int i=1;i<k;i++){
		if(k+i<=n){
			f2[(k+i)*(n+1)+i]=(f2[(k+i)*(n+1)+i]+1)%MOD;
		}
	}
	if(k==n){
		ans=1;
	}
	for(int i=k+1;i<=n-1;i++){
		s1[0]=0;
		for(int j=1;j<=n;j++){
			s1[j]=(s1[j-1]+f2[i*(n+1)+j])%MOD;
		}
		s2[n +1] =0;
		for(int j=n;j>=1;j--){
			s2[j]=(s2[j+1]+f1[i*(n +1) +j]) % MOD;
		}
		for(int j=1;j<=n;j++){
			if(i+j>n) {
				continue;
			}
			ll cnt=s2[j+1];
			if(cnt){
				int idx=(i+j)*(n+1)+j;
				f2[idx]=(f2[idx]+cnt)%MOD;
			}
			ll cnt1=s1[j-1];
			if(cnt1){
				int idx=(i+j)*(n+1)+j;
				f1[idx]=(f1[idx]+cnt1)%MOD;
			}
		}
	}
	for(int j=1;j<=n;j++){
		ans=(ans+f1[n*(n+1)+j])%MOD;
		ans=(ans+f2[n*(n+1)+j])%MOD;
	}
	cout<<ans;
}
```

---

## 作者：ztd___ (赞：4)

因为一些奇怪的问题导致没场切。

**注**：本题解旨在让**初学者**对 DP 有更加深刻的理解，对于**实力强大的选手**可以当看个热闹。

## Subtask 1
作者不知道这个是干什么用的。能过这个的话，一般第二个也能过。
## Subtask 2
$n \le 30$，我会爆搜！

由于天数不固定，所以搜索状态定义如下：
- $sum$ 表示剩余可分配的负荷。
- $lls$ 表示前天的负荷。
- $lst$ 表示昨天的负荷。
- $ooo$ 表示是否是第二天。这是因为第二天可以随便选，且第二天没有前天。

~~也许命名有点抽象，但凑合一下吧。~~  
然后直接暴力模拟即可。

注意一下边界问题，然后 $sum$ 的初始值是 $n - k$，$lst$ 的初始值是 $k$。

因为爆搜答案都是一个一个加，所以复杂度 $O(ans)$，无法承受，但分数可观。
### 核心代码
```cpp
int ans = 0;
int n, k;
void dfs(int sum, int lls, int lst, int ooo) {
	if (sum == 0) {
		ans++;
		return;
	}
	if (ooo) {
		for (int i = 1; i <= sum; i++) {
			if (i == lst) continue;
			dfs(sum - i, lst, i, 0);
		}
	} else {
		if (lls < lst) {
			for (int i = min(sum, lst - 1); i >= 1; i--) {
				dfs(sum - i, lst, i, 0);
			}
		} else {
			for (int i = lst + 1; i <= sum; i++) {
				dfs(sum - i, lst, i, 0);
			}
		}
	}

}
```
[记录](https://www.luogu.com.cn/record/196775638)在这里。  
此时我们已经拥有了 $43$ 分。在比赛中，如果你把第一题的 $O(n)$ 暴力 + 特殊性质写了出来，再拿到这 $43$ 分，你的排名大约是 rnk41。
## Subtask 3
~~这部分是另外两篇题解没有的。~~

考虑 DP。

### DP 状态设置
首先 $n$ 这一维是不可避免的。~~不然还 DP 干什么。~~

所以很自然的想到令 $dp_i$ 表示总共花费 $i$ 负荷的方案数。然后 $dp_k = 1$，做完了？

然而你会发现这个很难转移。~~不一定没有方法，只是作者不知道。~~

接着你就会想着加一维。  
容易知道第 $d$ 天的选择与第 $d - 1$ 天的选择有密切关系，所以加一维表示最后一天的选择。令 $dp_{i,j}$ 表示总共花费 $i$ 负荷，最后一天的负荷为 $j$ 的方案数。然后 $dp_{k,k} = 1$。

然后 DP 实际上是一种枚举。（？）我们必然需要枚举第 $d$ 天具体花费多少，所以还要定义一维，表示枚举的范围。即应该向大了找还是向小了找。

所以最终状态的定义就是：  
$dp_{i,j,0/1}$ 表示总共花费 $i$ 负荷，最后一天的负荷为 $j$ 的方案数，其中 $0$ 表示**下一次**要向小找，$1$ 表示**下一次**要向大找。

其实更好的理解方式是借助爆搜，你会发现 DP 的逻辑与爆搜完全相同。
### DP 转移
状态定义好之后，转移就变得简单起来。

$dp_{i,j,0}$ 的转移是往小找，$dp_{i,j,1}$ 的转移是往大找。

所以对于任意的 $dp_{i,j,0}$，我们需要枚举 $1$ 到 $j - 1$，此范围内的任意负荷都有可能。而对于 $dp_{i,j,1}$，我们需要枚举 $j + 1$ 到 $i$，此范围内的任意负荷都有可能。

那么用 $t$ 来枚举这一天的负荷，容易写出转移方程：
$$dp_{i,j,0} = \sum \limits _{t = 1}^{j - 1} dp_{i - j,t,1}$$

$$dp_{i,j,1} = \sum \limits _{t = j + 1}^{i - 1} dp_{i - j,t,0}$$

注意一下边界，负荷必须是正整数。

不要忘了取模。

不能理解的话可以参考爆搜，逻辑也是相似的。

时间复杂度 $O(n^3)$，需要优化。
### 核心代码
```cpp
const int N = 5e3 + 44;
const int MOD = 1e9 + 7;
int n, k, dp[N][N][2];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> k;
	if (n == k) {
		cout << 1;
		return 0;
	}
	dp[k][k][0] = dp[k][k][1] = 1;
	for (int i = k + 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			for (int t = 1; t < j; t++) {
				dp[i][j][0] += dp[i - j][t][1];
				dp[i][j][0] %= MOD;
			}
			for (int t = j + 1; t < i; t++) {
				dp[i][j][1] += dp[i - j][t][0];
				dp[i][j][0] %= MOD;
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans += dp[n][i][0] + dp[n][i][1];
		ans %= MOD;
	}
	cout << ans;
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/196809661)在这里。  
此时我们已经拥有了 $66$ 分。在比赛中，结合第一题的暴力 + 特殊性质 $75$ 分，加上这 $66$ 分，你的排名大约是 rnk39。（似乎没变多少？）
## Subtask 4
对于我们设计的状态转移方程（以 $dp_{i,j,0}$ 的转移为例）：
$$dp_{i,j,0} = \sum \limits _{t = 1}^{j - 1} dp_{i - j,t,1}$$

容易发现，这个求和可以在枚举到总负荷为 $i - j$ 的时候，用一个前缀和预处理出来，维护一下 $j$ 那一维，这样我们的复杂度就降了一维。（前缀和可以参考 [B3612](https://www.luogu.com.cn/problem/B3612)）

所以我们就得到了最终的代码，时间复杂度 $O(n^2)$，足以通过本题。

不过注意到取模后前缀和相减的结果可能是负数，加上一个 $10^9+7$ 即可。
### 核心代码
```cpp
const int N = 5e3 + 44;
const int MOD = 1e9 + 7;
int n, k, dp[N][N][2], sum[N][N][2];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n >> k;
	if (n == k) {
		cout << 1;
		return 0;
	}
	dp[k][k][0] = dp[k][k][1] = 1;
	for (int i = 1; i <= n; i++) {
		sum[k][i][0] = sum[k][i - 1][0] + dp[k][i][0];
		sum[k][i][1] = sum[k][i - 1][0] + dp[k][i][1];
	}
	for (int i = k + 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			dp[i][j][0] = sum[i - j][j - 1][1] % MOD;
			dp[i][j][1] = (sum[i - j][i - 1][0] - sum[i - j][j][0] + MOD) % MOD;
		}
		for (int j = 1; j <= n; j++) {
			sum[i][j][0] = (sum[i][j - 1][0] + dp[i][j][0]) % MOD;
			sum[i][j][1] = (sum[i][j - 1][1] + dp[i][j][1]) % MOD;
		}
	}
	cout << (sum[n][n][0] + sum[n][n][1]) % MOD;
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/196809829)在这里。  
此时你在这一题已经拿了满分。加上第一题的骗分，总共 $175$ 分，足以让你拿到 rnk22。  
然而将第一题略微卡常，或是思考一下第一题的 $O(1)$ 解法，你就有了 $200$ 分，能够拿到 rnk20 了。
## 后记
其实细心的读者点开记录链接查看源代码后会发现，作者在代码中的注释与文章里的是相反的。（至于为什么能过请自己思考。）

作者也是在写题解的过程中发现这些问题的，~~只是懒的再提交了~~。这篇文章也让作者自己也对本题以及 DP 的理解更加深刻，包括状态的定义与转移等。

希望每一位读者都能够借助这篇文章，加深对 DP 的理解，更好地运用 DP。

---

## 作者：zhoujiefu (赞：3)

看到方案数，果断想到 DP 。设 $dp_{i,j,0/1}$ 表示总和为 $i$ ，最后一个数为 $j$ ，该变大还是变小。不难列出方程

$dp_{i,j,0}=\sum_{k=1}^{j-1} dp_{i,j,1} $
$dp_{i,j,1}=\sum_{k=j+1}^n dp_{i,j,0}$

此时若直接转移时间复杂度为 $O(n^3)$ ，会超时。考虑优化，发现 $\sum$ 部分可以使用前缀和优化。

实现时，注意特判 $n=k$ 的时候，然后可以不用开 `long long`，因为只有加法，没有乘法。时空复杂度均为 $O(n^2)$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5;
const int mod=1e9+7;
int dp[N][N][2],g[N][N][2];//g是前缀和数组
signed main(){
	int n,k,ans=0;
	cin>>n>>k;
	if(n==k){
	    cout<<1;
	    return 0;
	}
	dp[k][k][0]=dp[k][k][1]=1;
	for(int i=1;i<=n;i++){
		g[k][i][0]=g[k][i-1][0]+dp[k][i][0];
		g[k][i][1]=g[k][i-1][1]+dp[k][i][1];
		g[k][i][0]%=mod,g[k][i][1]%=mod;
	}
	for(int i=k+1;i<=n;i++){
		for(int j=1;j<=i;j++){
			dp[i][j][0]=g[i-j][j-1][1];
			dp[i][j][1]=g[i-j][i][0]-g[i-j][j][0]+mod;
			dp[i][j][0]%=mod,dp[i][j][1]%=mod;
		}
		for(int j=1;j<=n;j++){
			g[i][j][0]=g[i][j-1][0]+dp[i][j][0];
			g[i][j][1]=g[i][j-1][1]+dp[i][j][1];
			g[i][j][0]%=mod,g[i][j][1]%=mod;
		}
	}
	cout<<(g[n][n][0]+g[n][n][1])%mod;
	return 0;
}
```

---

## 作者：modfish_ (赞：2)

## 思路
考虑 DP。设 $dp_{i,j,0/1}$ 表示和为 $i$，最后一个数为 $j$ 的序列的数量。$dp_{i,j,0}$ 表示序列的最后一个数大于倒数第二个，$dp_{i,j,1}$ 则表示最后一个数小于倒数第二个。

于是简单地写出转移式：

$$dp_{i,j,0}=\sum_{k=1}^{j-1}dp_{i-j,k,1}$$

$$dp_{i,j,1}=\sum_{k=j+1}^idp_{i-j,k,0}$$

初始状态 $dp_{k,k,0}=dp_{k,k,1}=1$。

对第二维用前缀和优化即可。时间复杂度 $O(n^2)$。

需要注意的两点：$n=k$ 时要特判；DP 数组第一维要用滚动数组滚掉（否则会 MLE）。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 5005, p = 1e9 + 7;

ll dp[maxn][2], sum[maxn][maxn][2];

int main(){
	int n, k;
	scanf("%d %d", &n, &k);
	if(n == k){
		printf("1\n");
		return 0;
	}
	dp[k][0] = dp[k][1] = 1;
	for(int j = 1; j <= n; j ++){
		sum[k][j][0] = (sum[k][j - 1][0] + dp[j][0]) % p;
		sum[k][j][1] = (sum[k][j - 1][1] + dp[j][1]) % p;
	}
	for(int i = k + 1; i <= n; i ++){
		for(int j = 1; j <= i; j ++){
			dp[j][0] = sum[i - j][j - 1][1];
			dp[j][1] = (sum[i - j][i][0] + p - sum[i - j][j][0]) % p;
		}
		for(int j = 1; j <= n; j ++){
			sum[i][j][0] = (sum[i][j - 1][0] + dp[j][0]) % p;
			sum[i][j][1] = (sum[i][j - 1][1] + dp[j][1]) % p;
		}
	}
	printf("%lld\n", (sum[n][n][0] + sum[n][n][1]) % p);
	return 0;
}
```

---

## 作者：George222 (赞：0)

考虑使用 dp 解决问题。

对于 dp 的状态设置：首先要有一维表示“当前总负荷”；观察题面发现转移与目前最后一天的负荷量有关，所以再加一维；转移还需要确定下一天是比今天大还是小，所以再加一维。

状态：$f_{i, j, 0/1}$ 表示总负荷为 $i$；最后一天的负荷量为 $j$；若为 $0$ 则下一天变大，为 $1$ 下一天变小的情况下有多少符合要求的方案。

此时时间复杂度为 $O(n ^ 3)$。

---

考虑优化。

对于 dp 的转移方程：
$
\begin{cases}
  f_{i, j, 0} = \sum_{x = 0}^{j - 1}{dp_{i - j, x, 1}} \\
  f_{i, j, 1} = \sum_{x = j + 1}^{i - 1}{dp_{i - j, x, 0}}
\end{cases}
$

不难看出可以使用前缀和维护 $\sum$ 部分，在枚举的过程中使用前缀和维护以便后面进行转移。

---

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;
int dp[5005][5005][2];
int sum[5005][5005][2];
const int mod = 1e9 + 7;

int main()
{
	cin >> n >> k;
	if (n == k)
	{
		cout << 1 << "\n";
		return 0;
	}

	dp[k][k][0] = 1;
	dp[k][k][1] = 1;
	for (int i = 1; i <= n; i++)
	{
		sum[k][i][0] = sum[k][i - 1][0] + dp[k][i][0];
		sum[k][i][1] = sum[k][i - 1][0] + dp[k][i][1];
	}
	for (int i = k + 1; i <= n; i++)
	{
		for (int j = 1; j < i; j++)
		{
			dp[i][j][0] = sum[i - j][j - 1][1] % mod;
			dp[i][j][1] = (sum[i - j][i - 1][0] - sum[i - j][j][0] + mod) % mod;
		}
		for (int j = 1; j <= n; j++)
		{
			sum[i][j][0] = (sum[i][j - 1][0] + dp[i][j][0]) % mod;
			sum[i][j][1] = (sum[i][j - 1][1] + dp[i][j][1]) % mod;
		}
	}

	cout << (sum[n][n][0] + sum[n][n][1]) % mod << "\n";
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/221161302)

---

## 作者：Tighnarri (赞：0)

## 前言
一道比较小清新的 dp 题（笔者是第一次见）
## 正文
容易发现是 dp，考虑设计状态。

因为计划的天数不限制，所以状态中不考虑天数。

因为题目中要求训练总量，所以状态中肯定有**训练总量**。

再读题可以发现**每天的训练量**会影响转移，考虑将其放入状态设计中。

还有一个每天训练量要是“波浪形”的限制，我们考虑再添一维状态 $0/1$ 表示 升/降。

至此，我们定义 $f_{i,j,0/1}$ 表示训练总量为 $i$，当天训练量为 $j$，较上一天 升/降。

状态设计后，转移是自然的，如下：
$$f_{i,j,0}=f_{i,j,0}+\sum_{k=j+1}^{n} f_{i-j,k,1}$$ 
与
$$f_{i,j,1}=f_{i,j,1}+\sum_{k=1}^{j}f_{i-j,k,0}$$

朴素转移是 $O(n^3)$ 的，我们考虑前缀和优化。

每次转移后统计一下前缀和即可。

code：
```cpp
#include<bits/stdc++.h>

using namespace std;
const int N=5e3+10;
const int p=1e9+7;
int n,k;
int f[N][N][2];
int f1[N][N][2];
int main(){
	cin>>n>>k;
    if(n==k){
        cout << 1;
        return 0;
    }
	f[k][k][0]=f[k][k][1]=1;
	for(int i=k;i<=n;i++){
		f1[k][i][0]=f1[k][i][1]=1;
	}
//初始化
	for(int i=2;i<=n;i++){
		for(int j=1;j<=i;j++){
			f[i][j][0]=(f[i][j][0]+(f1[i-j][n][1]-f1[i-j][j][1]%p+p)%p)%p;
			f[i][j][1]=(f[i][j][1]+f1[i-j][j-1][0])%p;
		}
//转移
		for(int j=1;j<=n;j++){
			f1[i][j][0]=(f1[i][j-1][0]+f[i][j][0])%p;
			f1[i][j][1]=(f1[i][j-1][1]+f[i][j][1])%p;
		}
//前缀和
	}
	cout << (f1[n][n][0]+f1[n][n][1])%p;
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

设 $dp_{i,j,0}$ 为已经有了 $i$ 的负载，最后一天负载为 $j$，下一天的负载要比最后一天大的方案数，$dp_{i,j,1}$ 同理，为下一天的负载要比最后一天小的方案数。那么得出状态转移方程：

$$dp_{i,j,0}=\sum_{k=j+1}^{i} dp_{i-j,k,1}$$

$$dp_{i,j,1}=\sum_{k=1}^{j-1} dp_{i-j,k,0}$$

答案便是所有负载为 $n$ 的方案数之和，即 $\sum_{i=1}^{n} (dp_{n,i,0}+dp_{n,i,1})$。

于是得到 $O(n^3)$ 的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int dp[5005][5005][2];
signed main()
{
	int n,K;
	cin>>n>>K;
	if(n==K)
	{
		cout<<1;
		return 0;
	}
	dp[K][K][0]=1;
	dp[K][K][1]=1;
	for(int i=K;i<=n;i++)
	{
		for(int j=1;j<i;j++)
		{
			for(int k=j+1;k<=i;k++)
			{
				dp[i][j][0]+=dp[i-j][k][1];
			}
			for(int k=1;k<j;k++)
			{
				dp[i][j][1]+=dp[i-j][k][0];
			}
			dp[i][j][0]%=mod;
			dp[i][j][1]%=mod;
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++) ans+=dp[n][i][0]+dp[n][i][1];
	cout<<ans%mod;
	return 0;
}
```
可以发现，在求和部分是可以通过前缀和预处理的，每次更新负载时顺便把前缀和处理了，这样求和时就可以直接拿来用了。

注意细节：

1. 如果开了两个数组，不能开 long long，否则会内存超限。
2. 防止因为取模而导致的负数问题，相减后要加上模数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int dp[5005][5005][2];
int fr[5005][5005][2];
signed main()
{
	int n,K;
	cin>>n>>K;
	if(n==K)
	{
		cout<<1;
		return 0;
	}
	dp[K][K][0]=1;
	dp[K][K][1]=1;
	for(int i=K;i<=n;i++)
	{
		fr[K][i][0]=1;
		fr[K][i][1]=1;
	}
	for(int i=K+1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			dp[i][j][0]=fr[i-j][i][1]-fr[i-j][j][1]+mod;
			dp[i][j][1]=fr[i-j][j-1][0];
			dp[i][j][0]%=mod;
			dp[i][j][1]%=mod;
		}
		for(int j=1;j<=n;j++)
		{
			fr[i][j][0]=fr[i][j-1][0]+dp[i][j][0];
			fr[i][j][1]=fr[i][j-1][1]+dp[i][j][1];
			fr[i][j][0]%=mod;
			fr[i][j][1]%=mod;
		}
	}
	cout<<(fr[n][n][0]+fr[n][n][1])%mod;
	return 0;
}
```

---

## 作者：_Chronostatis_ (赞：0)

## 题意
给定 $n, k$，求长度为 $m$ 且满足以下要求的序列 $a$ 总数：
- $\sum \limits_{i = 1}^m a_i = n$；
- $a_1 = k$；
- 若 $a_i > a_{i - 1}$，则 $a_{i + 1} > a_i$；若 $a_i < a_{i - 1}$，则 $a_{i + 1} < a_i$（$1 \lt i \lt m$）。
## 思路
一道比较好的 dp 题。

可设状态为 $dp_{i, j, k}$ 表示当前和为 $i$, 上一个数为 $j$, 大于上一个数或小于上一个数的方案数。转移则显而易见：$dp_{i, j, 0} \rightarrow dp_{i', j', 1}$，$dp_{i, j, 1} \rightarrow dp_{i', j', 0}$，其中 $i' > i$。

按照上述状态转移进行动态规划，会发现时间复杂度为 $O(n^3)$（枚举状态 $O(n^2)$，枚举转移 $O(n)$），无法满足时间限制。此时发现转移收集的答案实际上是一个子段，于是可以前缀和优化把时间复杂度降低到 $O(n^2)$。此时时空复杂度均为 $O(n^2)$。

Hint: 千万不要开 `long long`。计算可得 $2 \times n^2$ 的数组大小为 $5 \times 10^7$，而 `long long` 占内存大小为 $8$ byte，相乘可得 $4 \times 10^8$ byte，大约 $380$ Mb，共两个数组，总和为 $760$ Mb，超出题目所限的 $512$ Mb，而 `int` 数组大小仅为上述的一半，即 $380$ Mb。
## 代码
代码中附上了状态、转移、初始状态、目标状态、拓扑序和优化，码风良好，欢迎食用。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 5e3 + 10, MOD = 1e9 + 7;

int n, k;
int dp[MAXN][MAXN][2];
int sum[MAXN][MAXN][2];

/* 
状态：dp[i][j][k] 表示当前和为 i, 上一个数为 j, 大于上一个数或小于上一个数的方案数
转移：dp[i][j][0] -> dp[i'][j'][1]
     dp[i][j][1] -> dp[i'][j'][0]
     i' > i
初始状态: dp[0][1][0/1]
目标状态: dp[n][i][j], 1 <= i <= n, 0 <= j <= 1
拓扑序: i 从小到大
优化: 前缀和
*/

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> k;
  if (n == k) {
    cout << 1;
    return 0;
  }
  dp[k][k][0] = dp[k][k][1] = 1;
  fill(&sum[k][k][0], &sum[k][n][1], 1);
  for (int i = k; i <= n; i++) {
    for (int j = 1; j < i; j++) {
      dp[i][j][0] = sum[i - j][j - 1][1];
      dp[i][j][1] = (sum[i - j][i][0] - sum[i - j][j][0] + MOD) % MOD;
    }
    for (int j = 1; j <= n; j++) {
      sum[i][j][0] = (sum[i][j - 1][0] + dp[i][j][0]) % MOD;
      sum[i][j][1] = (sum[i][j - 1][1] + dp[i][j][1]) % MOD;
    }
  }
  cout << (sum[n][n][0] + sum[n][n][1]) % MOD;
  return 0;
}
```

---

## 作者：qwer6 (赞：0)

还是一道比较水的 DP 题。

我们刚拿到这道题，肯定先尝试记忆化搜索看看能不能水过去，定义参数 $now$，$pre$，$flag$ 分别表示当前的还剩多少负载，上一天的负载，和这一天应当增多还是减少，然后直接搜索即可，没什么技术含量。

```c++
int dfs(int now,int pre,bool flag){
	if(!now)return 1;
	if(vis[now][pre][flag])return dp[now][pre][flag];
	vis[now][pre][flag]=1;
	int res=0;
	if(flag){
		for(int i=pre+1;i<=now;i++)
			res=(res+dfs(now-i,i,0))%mod;
	}else{
		for(int i=min(pre-1,now);i;i--)
			res=(res+dfs(now-i,i,1))%mod;
	}
	return dp[now][pre][flag]=res;
}
```

但是我们发现超时了……

我们考虑虽然状态总数只有 $n^2$ 但是每一次转移却也是 $O(n)$ 的，所以最后总时间复杂度是 $O(n^3)$ 的，当然超时，但是记忆化搜索并不好优化，所以我们考虑将代码写成循环形式。

那我们直接定义状态 $dp_{i,j,flag}$ 表示一共有 $i$ 的负载，前一天的负载为 $j$，这一天应该减少或者增多的方案数。

这个状态十分好转移。
$$
dp_{i,j,0}=dp_{i-k,k,1}\ (k<j)\\
dp_{i,j,1}=dp_{i-k,k,0}\ (n\ge k>j)
$$
肉眼可见的前缀和优化。

那我们直接来一手前缀和优化这道题就过了。

其他题解中都开了另外的数组去记录前缀和，但着实没有这个必要，我们直接把 DP 数组当成前缀和数组用就好了

```c++
/*by qwer6*/
#include<bits/stdc++.h>
#define Nxt puts("")
#define Spa putchar(32)
#define Pline puts("------------------------------")
namespace FastIO{
	inline int read(int &a){
		char c=getchar();
		int f=1;
		a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a=a*f;
	}
	inline int read(){
		char c=getchar();
		int f=1,a=0;
		while(!isdigit(c)){
			if(c=='-')f=-1;
			c=getchar();
		}
		while(isdigit(c)){
			a=(a<<1)+(a<<3)+(c^48);
			c=getchar();
		}
		return a*f;
	}
	inline void write(int x){
		if(x<0)putchar('-'),x=-x;
		std::stack<int>st;
		do{
		   st.push(x%10);
		   x/=10;
		}while(x);
		while(!st.empty())putchar(st.top()+'0'),st.pop();
		return ;
	}
	inline void tomax(int &a,int b){
		if(a<b)a=b;
		return ;
	}
	inline void tomin(int &a,int b){
		if(a>b)a=b;
		return ;
	}
}
using namespace FastIO;
using namespace std;
const int mod=1e9+7;
int n,k;
int dp[5005][5005][2];
inline int add(int x,int y){//卡点常的小手段
	x+=y;
	if(x>=mod)x-=mod;
	return x;
}
inline int sub(int x,int y){
	x-=y;
	if(x<0)x+=mod;
	return x;
}
signed main(){
	read(n),read(k);
	if(n==k)return write(1),0;//特判
	dp[k][k][0]=dp[k][k][1]=1;//初始化
	for(int i=1;i<=n;i++){
		dp[k][i][0]=add(dp[k][i][0],dp[k][i-1][0]);
		dp[k][i][1]=add(dp[k][i][1],dp[k][i-1][1]);
	}
	for(int i=k+1;i<=n;i++){
		for(int j=1;j<=i;j++){
			dp[i][j][0]=add(dp[i][j][0],dp[i-j][j-1][1]);
			dp[i][j][1]=add(dp[i][j][1],sub(dp[i-j][n][0],dp[i-j][j][0]));
		}
		for(int j=1;j<=n;j++){//前缀和优化
			dp[i][j][0]=add(dp[i][j][0],dp[i][j-1][0]);
			dp[i][j][1]=add(dp[i][j][1],dp[i][j-1][1]);
		}
	}
	write(add(dp[n][n][0],dp[n][n][1]));
}
```

---


# [蓝桥杯 2024 国 Python B] 括号与字母

## 题目描述

给定一个仅包含小写字母和括号的字符串 $S$，保证括号可以两两匹配。

给出 $Q$ 组询问，每组询问给出一个小写字母 $c_i$ 和一个数 $x_i$，询问 $S$ 中有多少对匹配的括号之间有不少于 $x_i$ 个 $c_i$。


## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$|S|, Q \leq 5000$；
- 对于 $70\%$ 的评测用例，$|S| \leq 100000$；
- 对于所有评测用例，$1 \leq |S| \leq 10^6$，$1 \leq Q \leq 100000$，$0 \leq x_i < 10^6$。其中 $|S|$ 表示 $S$ 的长度。

## 样例 #1

### 输入

```
((a)()((b)((c))))
3
a 2
b 1
c 1```

### 输出

```
0
3
4```

# 题解

## 作者：DengDuck (赞：4)

今天来篇简体中文题解，嗯嗯！

这题注意到括号对的数量肯定是 $\mathcal O(n)$ 的，所以我们可以找到所有的括号对任何统计，这一部分我们可以考虑使用栈来维护。

然后我们发现字符集很小，分类之后分别前缀和完全可行，这样我们就可以求任意字符在区间中的出现次数了！

所以我们只需要对于所有括号对都求出来中间某种字母出现了几次就好了。

不过问题问的是不小于，所以考虑再给求出来的数组求一遍后缀和就对了，注意需要包含下标 $0$。

时间复杂度显然是 $\mathcal O(nm)$，其中 $m=26$ 表示字符集大小。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
const int M=26;
int n,Q,S[M][N],F[M][N];
string C;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>C>>Q;
	n=C.size(),C=" "+C;
	stack<int>St;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<M;j++)S[j][i]=S[j][i-1]+(C[i]==j+'a');
		if(C[i]=='(')St.push(i);
		if(C[i]==')')
		{
			int L=St.top();St.pop();
			for(int j=0;j<M;j++)F[j][S[j][i]-S[j][L-1]]++;
		}
	}
	for(int j=0;j<M;j++)
	for(int i=n;i>=0;i--)F[j][i]+=F[j][i+1];
	while(Q--)
	{
		char c;int x;
		cin>>c>>x;
		cout<<F[c-'a'][x]<<endl;
	}
}
```

---

## 作者：Crasole (赞：1)

题目的意思可以理解为统计每个字符在每个括号中出现了几次，那么我们就可以用一个栈来进行括号匹配，顺便把字符在括号中出现等次数统计一下，又因为题目中说，字符的个数是不小于 $x_i$ 个，也就是说，对于当前的括号，如果字符 $c$ 的个数是 $cnt$，那么它对 $0$ 到 $cnt$ 的询问都能产生贡献，所以可以写一个前缀和。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int m;
bool vis[N];
string t;
int f[30][N];
//f是答案数组

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
    cin >> t;
    m = t.size(), t = " " + t;
    stack < vector <int> > stk;
//括号匹配
    for (int i = 1; i <= m; ++i) {
        if(t[i] == ')') {
            vector <int> a(30);
            while(stk.size()) {
                vector <int> tmp = stk.top();
                stk.pop();
                if(tmp[26]) {
                    if(tmp[26] == '(') break;
                    ++ a[tmp[26] - 'a'];
                }
                else {
                    for (int i = 0; i < 26; ++i) 
                        a[i] += tmp[i];
                }
            }
            //统计贡献
            for (int i = 0; i < 26; ++i)
                ++ f[i][0], -- f[i][a[i] + 1];
            stk.push(a);
        } else {
            vector <int> a(30);
            a[26] = t[i];
            stk.push(a);
        }
    }
    for (int i = 0; i <= 25; ++i)
        for (int j = 1; j <= m; ++j)
            f[i][j] += f[i][j - 1];
    int q;
    cin >> q;
    while(q --) {
        char c;
        int x;
        cin >> c >> x;
        cout << f[c - 'a'][x] << '\n';
    }
    return 0;
}
```

---

## 作者：guoshengyu1231 (赞：1)

# 题意分析
这个问题需要处理字符串中的括号匹配关系，并在匹配的括号对之间统计特定字符的出现次数。但是这题的数据范围很大，显然不能暴力枚举。
# 具体思路
看来一眼题目后感觉毫无头绪，毕竟这是一道绿题，肯定是有点难度的。但越是难的题目，我们越要**大胆**的想。因为这并不是一道一眼就看出要用什么算法的题目。你可以去看他的算法标签，基本都是普及组的算法。那他为什么是一道绿题，因为他需要你通过某些转换才能做。也就是说，他本质的算法并不难，其中的转换也很容易理解，只是一起考就变得很难了。那具体怎么转换呢？只能想呗。
 $\\$ 

回归正题，既然只需要通过某些转换这题就会非常简单，那我们就需要**大胆**得想该怎么转换。当然，除了要大胆得想，还得要**有目的**得想。既然这题这么难，那我们就逐个击破。
- **括号匹配处理：**
  -   既然题目要求我们在匹配的括号对之间统计特定字符的出现次数，那我们肯定是先预处理所有匹配得括号对，不然怎么降低时间复杂度。
  -   既然要预处理所有匹配的括号对，那怎么预处理所有匹配的括号对呢？这个其实并不难，用栈处理即可。

- **字符统计预处理‌：**
  -   既然是在匹配的括号对**之间**统计字符出现数，都提到**之间**了，那肯定得更区间有关了。那你想想，既要满足快速查询区间，又是离线处理的数据结构。没错，就是**前缀和**呀！
  -   现在我们需要思考，这个前缀和数组究竟可以用来表示什么？这个其实很简单，不难想到，既然是统计字符，那肯定是给字符创建前缀和数组。所以我们不妨用 $sum_{c,i}$ 表示表示字符 $c$ 在字符串前 $i$ 个位置中出现的次数。

- **查询处理：**
有了前面的铺垫，这里就比较简单了。
  -  对于查询的 $c$ 和 $x$，遍历所有匹配的括号对 $(l, r)$。
  -  使用前缀和数组计算区间 $[l+1, r-1]$ 内字符c的数量（因为左右两边的括号不算）： $cnt=sum_{c,r-1}-sum_{c,l+1}$。
  -  统计 $cnt\ge x$ 的数量。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n;
int sum[26][1000005];//前缀和
int main() {
    cin>>s>>n;
    vector<pair<char, int>> q;//查询
    for(int i=1;i<=n;i++) 
	 {
        char c;int x;
        cin>>c>>x;
        q.emplace_back(c, x);//不能用push_back！
     }
    stack<int> st;
    vector<pair<int, int>> p;//统计括号对
    for (int i=0;i<s.size();i++) 
	 {
        if (s[i] == '(') st.push(i);
		if (s[i] == ')') 
		 {
            int l=st.top();
            st.pop();
            p.emplace_back(l,i);//不能用push_back！
    	 }
     }
    for (char c='a';c<='z';c++) 
        for (int i=0;i<s.size();i++) 
         sum[c-'a'][i + 1]=sum[c-'a'][i]+(s[i]==c?1:0);//预处理前缀和
    for (auto& i:q) 
	   {
        char c=i.first;
        int x=i.second;
        int cnt=0;
        for (auto& j:p) {
            int l=j.first;
            int r=j.second;
            int total = sum[c-'a'][r]-sum[c-'a'][l + 1];
            if (total >= x) cnt++;
        }
        cout<<cnt<<"\n";
     }
    return 0;
}
```
# 时间复杂度分析
- **预处理阶段：**
  - 括号匹配：$O(|S|)$。
  - 预处理前缀和：$O(|S|)$。
- **查询阶段：**
  - 每个查询需要检查所有匹配的括号对，最坏情况下 $O(m)$。（ $m$ 为匹配括号对数）
  - 总时间复杂度：$O(Qm)$。
# 优化
刚才那个代码只能得 $70$ 分，其余全部 TLE。所以我们现在需要考虑优化时间复杂度。观察数据范围，我们可以预测能通过本题得代码时间复杂度大概在 $O(Q \log m)$ 左右。那我们该想想如何优化时间复杂度。考虑到是要统计 $cnt\ge x$ 的数量，不难想到二分查找。那既然方向有了，接下来我们要想该如何实现。
 $\\$ 

我们可以统计关于某个字符，所有括号对包含该字符得个数，到时候直接二分查找个数 $\ge x$ 的括号对数量。
 $\\$ 

具体的，在统计完前缀和后。枚举每个括号对，再枚举所有字符。让每个字符统计在这个括号对里出现了几次，并记录。
 $\\$ 
 
对于每个字符记录得次数进行排序，以便接下来的二分查找。
 $\\$ 
 
在每次查询时，对于查询的字符 $c$，只需要二分查找字符 $c$ 中 $\ge x$ 的个数就行啦！（具体详见代码）
 $\\$ 

总时间复杂度：$O(Q \log m)$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,sum[26][1000005];
int main()
{
	cin>>s>>n;
	vector<pair<char,int> > q(n);
	for(int i=0;i<n;i++) cin>>q[i].first>>q[i].second;
	stack<int> st;
	vector<pair<int,int> > p;
	for(int i=0;i<s.size();i++)
	 {
	 	if(s[i]=='(') st.push(i);
	 	if(s[i]==')')
	 	 {
	 	 	int l=st.top();st.pop();
	 	 	p.emplace_back(l,i);
		 }	 
	 }
	for(char c='a';c<='z';c++)
	 for(int i=0;i<s.size();i++)
	  sum[c-'a'][i+1]=sum[c-'a'][i]+(s[i]==c?1:0);
    unordered_map<char, vector<int> > Counts;
    for(auto& [l,r]:p)
     for(char c='a';c<='z';c++)
      {
      	int cnt=sum[c-'a'][r]-sum[c-'a'][l+1];//前缀和计算
      	Counts[c].push_back(cnt);//统计每个字符c
	  }
	for(auto& [c,v]:Counts) sort(v.begin(),v.end());//排序
	for(int i=0;i<n;i++)
	 {
	 	char ch=q[i].first;
	 	int x=q[i].second;
	 	auto& v=Counts[ch];
	 	int ans=v.end()-lower_bound(v.begin(),v.end(),x);
	 	cout<<ans<<"\n";
	 }
	return 0;
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P12271)

红题。不知为何评绿？

先对每个字符做前缀和，令 $s1_{i,j}$ 为前 $i$ 个字符中出现小写字母表第 $j+1$ 个字符的数量。这一步可以 $O(|\sum|n)$ 处理，其中 $\sum$ 是字符集。

接着用栈进行括号匹配，具体为：
+ 若 $s_i$ 为 ```(``` 则将 $i$ 入栈
+ 若 $s_i$ 为 ```)``` 则将栈顶取出并删除栈顶

设每次取出栈顶元素为 $cur$，那么 $s_{cur}$ 与 $s_i$ 组成一对匹配的括号。此时小写字母表第 $j+1$ 个字符在这对括号中间出现的次数为 $s1_{i-1,j}-s1_{cur,j}$，我们可以建一个桶 $s2_{i,j}$ 来存储小写字母表第 $j+1$ 个字符 **恰好** 出现 $i$ 次的括号对数量，那么每算出一个括号对我们就对 $s2$ 数组 $O(|\sum|)$ 维护。

计算完 $s2$ 数组后，不难发现每次所求答案即为 $\sum_{i=x}^ns2_{i,c-'a'}$，那么我们对 $s2$ 做一次后缀和即可。这一步的复杂度依旧是 $O(|\sum|n)$，总复杂度为 $O(|\sum|n)$，注意 $x$ 可能取 $0$ 所以后缀和要做到下标 $0$。

代码很好写。

---

## 作者：FZY_CZY (赞：0)

## 思路
首先看到括号匹配，所以自然想到可以用栈来维护，再看到“不少于”，容易想到贡献求和，所以用后缀和来维护。

## 标程
```cpp
#include<bits/stdc++.h>
#define upp(a,x,y) for (int a = x; a <= y; a++)
#define dww(a,x,y) for (int a = x; a >= y; a--)
using namespace std;
const int N = 1e6 + 10;
const int M = 26;
int q, sum[M][N], f[M][N];
string s;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
    cout.tie(0);
    
	cin >> s >> q;
	int n = s.size();
	s = " " + s;
	
    stack<int> stk;
	upp (i, 1, n) {
		upp (j, 0, M - 1) {
            sum[j][i] = sum[j][i - 1];
            if (s[i] == j + 'a') sum[j][i]++;
        }
		if (s[i] == '(') stk.push(i);
		if (s[i] == ')')
		{
			int L = stk.top();
			stk.pop();
			upp (j, 0, M - 1) f[j][sum[j][i] - sum[j][L - 1]] ++;
		}
	}
	upp (j, 0, M - 1) dww (i, n, 0) {
		f[j][i]+=f[j][i+1];
	}
	
	while (q--) {
		char c;
		int x;
		cin >> c >> x;
		cout << f[c - 'a'][x] << '\n';
	}
	return 0;
}
``````

---


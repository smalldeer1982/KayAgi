# [NOIP 2011 提高组] 聪明的质监员

## 题目描述

`小T` 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是：

1. 给定$ m$ 个区间 $[l_i,r_i]$；
2. 选出一个参数 $W$；
3. 对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：

$$y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times \sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$$  

其中 $j$ 为矿石编号。

这批矿产的检验结果 $y$ 为各个区间的检验值之和。即：$\sum\limits_{i=1}^m y_i$  

若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。`小T` 不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。


## 说明/提示

【输入输出样例说明】

当 $W$ 选 $4$ 的时候，三个区间上检验值分别为 $20,5 ,0$ ，这批矿产的检验结果为 $25$，此时与标准值 $S$ 相差最小为 $10$。

【数据范围】

对于 $10\% $ 的数据，有 $1 ≤n ,m≤10$；

对于 $30\% $的数据，有 $1 ≤n ,m≤500$ ；

对于 $50\% $ 的数据，有 $ 1 ≤n ,m≤5,000$；
 
对于 $70\%$ 的数据，有 $1 ≤n ,m≤10,000$ ；

对于 $100\%$ 的数据，有 $ 1 ≤n ,m≤200,000$，$0 < w_i,v_i≤10^6$，$0 < s≤10^{12}$，$1 ≤l_i ≤r_i ≤n$ 。


## 样例 #1

### 输入

```
5 3 15 
1 5 
2 5 
3 5 
4 5 
5 5 
1 5 
2 4 
3 3 ```

### 输出

```
10
```

# 题解

## 作者：An_Aholic (赞：10)

# P1314 题解

附：建议 [blog](https://www.luogu.com.cn/blog/kimble-blog/p1314-ti-xie) 食用。

~~作者默认读题解的同学以认真读题并思考，不认真读题，你是看不懂地~~


## 题目分析：
### 解释式子
先来研究这一串式子：
$$y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times \sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$$  

$\sum$ 的意思是：从下面的几循环到上面的几，每一次循环加上左边的数。比如 $\sum\limits_{i=1}^{n}a_i$， 可以看作是：
```cpp
for (int i = 1; i <= n; i++) {
    sum += a[i];
}
```


中括号的含义是如果满足中括号里面的内容，中括号就可以被看作 $1$，否则为 $0$，所以 $[w_j \ge W]$ 的意思是：如果满足 $w_j \ge W$, $[w_j \ge W] = 1$,  否则 $[w_j \ge W] = 0$。

### 思路大意

这道题可以使用二分答案来解决。我们二分 $W$ 后，就可以算出每个区间的检验值 $y_i$，然后计算出它们的和 $y$，将它与 $s$ 比较，更新二分的上下界。

计算区间的检验值可以使用[前缀和](https://www.luogu.com.cn/blog/kimble-blog/yi-wei-er-wei-qian-zhui-hu)，即预处理出数组 $qzh1$ 和 $qzh2$，表示前缀和中括号 和 $v$，然后用 $qzh1_r-qzh1_{l - 1}$ 得到区间 $[l,r]$ 的中括号前缀和，$qzh2_r-qzh2_{l-1}$ 得到区间 $[l,r]$ 的价值和。这样，区间的检验值 $y_i$ 就可以表示为最上面一大串巴拉巴拉的式子啦~



在二分答案时，需要判断 $y$ 和 $s$ 的大小关系来更新二分的上下界，具体方法 ~~可以参考代码实现~~ 听我解释下：如果多了，就说明通过线（$W$）太低了，就往上调，否则就说明通过线高了，往下调。

## 代码：
``` cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long

ll n, m, s;
ll y, ans;
ll w[200010], v[200010];
ll l[200010], r[200010];
ll qzh1[200010], qzh2[200010];

bool check(ll wq) {
	y = 0;
	memset(qzh1, 0, sizeof(qzh1));  
	memset(qzh2, 0, sizeof(qzh2));
	// 多测不清空，爆零两行泪 
	for (int i = 1; i <= n; i++) {
		if (w[i] > wq)  // > 过了检测通过线 
			qzh1[i] = qzh1[i - 1] + 1, qzh2[i] = qzh2[i - 1] + v[i]; // 前缀和加上 
		else
			qzh1[i] = qzh1[i - 1], qzh2[i] = qzh2[i - 1];  // 承继原来的前缀 
	}
	for (int i = 1; i <= m; i++) {
		int rrrr = r[i];
		int llll = l[i];
		y += (qzh1[rrrr] - qzh1[llll - 1]) * (qzh2[rrrr] - qzh2[llll - 1]);  // 直接照着式子，简单分析，就会发现这跟式子几乎一模一样/doge 
	}
	if (y > s)
		return 1;  // 判断差值大还是小，为了二分的更改做准备 
	else
		return 0;
}

int main() {
	cin >> n >> m >> s;
	for (int i = 1; i <= n; i++)
		cin >> w[i] >> v[i];
	for (int i = 1; i <= m; i++)
		cin >> l[i] >> r[i];
	int lll = 1;
	int rrr = 2000010;  
	ans = s;
	while (lll <= rrr) { // 二分答案 
		int mid = lll + (rrr - lll) / 2;  // 防爆ll， 原式子：(lll + rrr) / 2 
		if (check(mid))
			lll = mid + 1;
		else
			rrr = mid - 1;
			ans = min(ans, llabs(s - y)); // 为了防止爆int， 所以写llabs 
	}
	cout << ans;
}
```




---

## 作者：彼岸归航 (赞：9)

因为求的是**差值**，所以肯定中间小两边大，马上就能想到三分。（表示想了很久才明白为什么可以二分）虽然说是三分但复杂度和二分差不多的，无非就是常数大一点（什么）。  

------------

首先我们想到把$l$设为$min\ w[i]$，$r$设为$max\ w[i]$。开心地写出代码，通过了样例，然后震惊地发现全WA了，以下是爆零部分代码。
```
while(l + 3 < r) {
    int mid = (l + r) >> 1; 
    int midl = mid - 1; 
    int midr = mid + 1; 
    ll k1 = check(midl); 
    ll k2 = check(midr); 
    if(k1 < k2) res = min(res, k1), r = midr; 
    else res = min(res, k2), l = midl; 
}
for(int i = l; i <= r; i++) res = min(res, check(i)); 
```
这个时候肯定要问，**为什么WA掉了**？  

上面这种做法有一个漏洞，枚举$w$的时候并不是每一个$w$都能作为断点，也就是说，可能会搞出来两个**等价**的$w$，这时你并不能判断答案到底在左边还是右边。  
所以要对枚举的$w$去重。（应该是这个意思）我们只要从小到大枚举每一个不一样的$w[i]$就可以了。那么只要排一遍序就可以了。

AC代码：
```
#include<bits/stdc++.h>

using std::max; 
using std::sort; 

typedef long long ll; 

const int N = 200000; 

struct ele {
    ll w, v; 
    void read() {
    	scanf("%lld %lld", &w, &v); 
    }
}; 
struct seg {
    int l, r; 
    void read() {
    	scanf("%d %d", &l, &r); 
    }
}; 

int n, m; 
ll  S; 
ele a[N + 3]; 
seg b[N + 3]; 

int l, r; 
ll res = -1; 
ll s[N + 3]; 
ll x[N + 3]; 
ele c[N + 3]; 
ll d[N + 3]; 

ll abs(ll a) {
    return a < 0 ? -a : a; 
}
ll min(ll a, ll b) {
    if(a == -1) return b; 
    if(b == -1) return b; 
    return a < b ? a : b; 
}

bool cmp(ele a, ele b) {
    return a.w < b.w; 
}

ll check(int w) {
    for(int i = 1; i <= n; i++) {
    	if(a[i].w >= w) s[i] = s[i - 1] + a[i].v, x[i] = x[i - 1] + 1; 
        else s[i] = s[i - 1], x[i] = x[i - 1]; 
    }
    ll ans = 0; 
    for(int i = 1; i <= m; i++) ans += (x[b[i].r] - x[b[i].l - 1]) * (s[b[i].r] - s[b[i].l - 1]); 
    return abs(ans - S); 
}

int main() {
    scanf("%d %d %lld", &n, &m, &S); 
    for(int i = 1; i <= n; i++) a[i].read(), c[i] = a[i]; 
    for(int i = 1; i <= m; i++) b[i].read(); 
    
    sort(c + 1, c + n + 1, cmp); 
    for(int i = 1; i <= n; i++) {
        if(c[i].w == c[i - 1].w) continue; 
        else d[r++] = c[i].w; 
    }
    l = 1; 
    
    while(l + 3 < r) {
        int mid = (l + r) >> 1; 
        int midl = mid - 1; 
        int midr = mid + 1; 
        ll k1 = check(d[midl]); 
        ll k2 = check(d[midr]); 
        if(k1 < k2) res = min(res, k1), r = midr; 
        else res = min(res, k2), l = midl; 
    }
    for(int i = l; i <= r; i++) res = min(res, check(d[i])); 
    
    printf("%lld\n", res); 
    
    return 0; 
}
```

---

## 作者：LiJunze0501 (赞：6)

# 整体思路
二分+前缀和。
# 细节
## 二分
这里二分的是 $W$ 的取值，再对每个 $W$ 的情况进行分析。
## 前缀和
两个前缀和，一个是价值和，一个是可选个数。  
一个变量 $ans$ 累加当前区间内矿石质量大于等于 $W$ 的矿石价值和乘上区间内满足上述条件的矿石数量。  
## 温馨提示
数据范围偏大，数据类型做正确选择。
# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,s,l,r,mid,ans,w[200010],v[200010],le[200010],ri[200010],ss,minn=1e15,q[200010],p[200010]; 
int main(){
	cin>>n>>m>>s;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>v[i];
		r=max(r,w[i]);
	}
	for(int i=1;i<=m;i++) cin>>le[i]>>ri[i];
	while(l<=r){
		ans=0,mid=(l+r)>>1;
		for(int i=1;i<=n;i++)   
			if(w[i]>mid) q[i]=q[i-1]+1,p[i]=p[i-1]+v[i];
			else q[i]=q[i-1],p[i]=p[i-1];
		for(int i=1;i<=m;i++) ans+=(q[ri[i]]-q[le[i]-1])*(p[ri[i]]-p[le[i]-1]);
		ss=s-ans;        
		if(ss<0) l=mid+1;     
		else r=mid-1;     
		minn=min(minn,abs(ss));    
	}
	cout<<minn<<endl;
}
```

---

## 作者：ycy1124 (赞：4)

### 题意
题目很清楚，这里只讲一下式子的意思。就是将一段区间内所有矿石质量大于等于 $w$ 的矿石的价值的和乘上区间内这样的矿石的数量。
### 思路
首先很容易发现二分，因为我们二分 $w$ 的取值时他的 $y$ 是随着 $w$ 的减小而不降的。

此时我们最大的难题是如何解决快速计算每个区间内矿石的价值，这时我们发现，一个区间内所有符合条件的价值和这个东西是非常容易用前缀和快速求的。于是我们在二分的同时每次记录一个前缀和来计算个数与价值和即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Node{
    int w,v;
}a[2000005];
struct node{
    int l,r;
}b[2000005];
int n,m,s,qzw[200005],qzh[200005],l=0,r=1e6,mid,ans=1e18;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>s;
    for(int i=1;i<=n;i++){
        cin>>a[i].w>>a[i].v;
    }
    for(int i=1;i<=m;i++){
        cin>>b[i].l>>b[i].r;
    }
    while(l<=r){
        mid=(l+r>>1);
        for(int i=1;i<=n;i++){
            if(a[i].w>=mid){
                qzh[i]=qzh[i-1]+1;//符合的矿石个数
                qzw[i]=qzw[i-1]+a[i].v;//区间内的矿石价值和
            }
            else{
                qzw[i]=qzw[i-1];
                qzh[i]=qzh[i-1];
            }
        }
        int sum=0;
        for(int i=1;i<=m;i++){
            sum+=(qzw[b[i].r]-qzw[b[i].l-1])*(qzh[b[i].r]-qzh[b[i].l-1]);
        }
        ans=min(abs(sum-s),ans);//记得取绝对值
        if(sum<=s){
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }
    cout<<ans;
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/197515615)

---

## 作者：Ivan422 (赞：3)

**注意这篇题解使用了 $sim$ 代替 $s$ 以避免与前缀和冲突。**

题意就不放了，感觉已经很清晰了。

怎么做呢？看到这个要求 $W$ 最小，考虑二分。

二分第 $1$ 步：确定区间。

$W$ 最小肯定是 $1$，因为 $w_i>0$。

$W$ 最大是 $2sim$，再大肯定会不优。

二分第 $2$ 步：写出判定函数。

我们发现这个判断函数开 $\mathcal O(n)$ 就可以了。

怎么做呢？

发现是一个类似区间求和的东西，考虑前缀和维护。

$s_0$ 表示 $[w_j\ge W]$ 的前缀和。

$s_1$ 表示 $[w_j\ge W]v_j$ 的前缀和。

之后统计就是按题意即可。

我们就可以求出来一个 $su$ 值，返回一下 $su-sim$。

要是返回值 $\ge 0$，那么缩小区间 $l=mid$，上调，找出最佳值。

反之，$r=mid$，下调，找出最佳值。

最后返回值趋于 $0$，我们就正确了。

注意个人的奇怪写法，区间左右都要多开一下。

为了通过最后一个点，我们求答案就是在 $l,r,mid$ 中求出答案的最小值，具体看代码。


```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
//#define arr array<int,3>
#define int long long
//#define pb push_back
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=2e5+10,M=1010,P=1e9+7,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
int n,m,sim,w[N],v[N],l[N],r[N],s[2][N],su;
int L,R,MID;
int result(int W){ // 所谓的判定函数
	for(int i=1;i<=n;i++)
		s[0][i]=s[0][i-1]+(w[i]>=W),
		s[1][i]=s[1][i-1]+(w[i]>=W)*v[i];
	su=0;
	for(int i=1;i<=m;i++)
		su+=(s[0][r[i]]-s[0][l[i]-1])*
			(s[1][r[i]]-s[1][l[i]-1]);
	return (su-sim);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>n>>m>>sim;
	for(int i=1;i<=n;i++)cin>>w[i]>>v[i];
	for(int i=1;i<=m;i++)cin>>l[i]>>r[i];
	L=0,R=2*sim+1; // 左右都多开 1，防止悲剧
	while(L+1<R){
		MID=(L+R)/2;
		if(result(MID)>=0)L=MID; // 二分
		else R=MID;
	}
	cout<<min({abs(result(L)),abs(result(R)),abs(result(MID))}); // 找最小值
    return 0;
}
//note:

```

看起来很鬼畜。

---

## 作者：WsW_ (赞：2)

### 思路
令 $f(W)=\sum\limits_{i=1}^{m}y_i$。  
根据题意发现，随着 $W$ 增大，$y_i$ 和 $f(W)=\sum\limits_{i=1}^{m}y_i$ 都单调不增。  
现在在单调函数 $f(W)$ 上求最接近 $s$ 的值，容易想到二分 $W$。  
$\sum\limits_{j=l_i}^{r_i}[w_j \ge W] $ 指的是这个区间内有多少个矿石重量大于等于 $W$。  
$\sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$ 指的是这个区间内重量大于等于 $W$ 的矿石价值之和。  
容易发现上面两个式子都可以 $O(n)$ 预处理出前缀和，并用前缀和 $O(1)$ 求出。  

最终做法就是二分 $W$，每次二分都预处理两个前缀和，并利用前缀和分别求两个式子。  

时间复杂度为 $O((n+m)\log W)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m;
ll s,ans=1e18;
int w[200003],v[200003];
int l[200003],r[200003];
int cnt[200003];
ll sumv[200003];
ll check(int W){
	memset(cnt,0,sizeof(cnt));
	memset(sumv,0,sizeof(sumv));
	for(int i=1;i<=n;i++){
		cnt[i]=cnt[i-1];
		sumv[i]=sumv[i-1];
		if(w[i]>=W){
			cnt[i]++;
			sumv[i]+=v[i];
		}
	}
	ll sum=0;
	for(int i=1;i<=m;i++){
		sum+=(cnt[r[i]]-cnt[l[i]-1])*(sumv[r[i]]-sumv[l[i]-1]);
	}
	return sum;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>s;
	int lft=0,rig=0,mid;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>v[i];
		rig=max(rig,w[i]);
	}
	for(int i=1;i<=m;i++){
		cin>>l[i]>>r[i];
	}
	while(lft<=rig){
		mid=lft+rig>>1;
		ll y=check(mid);
		ans=min(ans,abs(s-y));
		if(y<s)rig=mid-1;
		else lft=mid+1;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：tth37 (赞：1)

本题难度不大，第一眼就能看出需要用二分答案或**倍增答案**解决。

需要解决的第一个问题是如何根据一个猜测的参数 $W$ ，快速计算出检验结果 $Y$ 。由于只有 $w_j \ge W$ 的矿石才会对检验结果做出贡献，因此我们可以将 $w_j < W$ 的矿石忽略并预处理前缀和，并且回答 $M$ 个询问即可。

接下来应该考虑如何计算猜测值 $W$ 。观察到 $Y(W)$ 是单调不增的，我们可以用**倍增**求出满足 $Y \ge S$  的最大 $W$ 值，那么满足 $Y<S$ 的最小 $W$ 值一定为 $W+1$ 。

最终答案即为 $\min\{|Y(W)-S|,|Y(W+1)-S|\}$ 。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int N, M, ans = 1; ll S;
int w[200005], v[200005], l[200005], r[200005]; ll s1[200005], s2[200005];
inline ll Y(int W) {
    for (register int i = 1; i <= N; ++i)
        s1[i] = w[i] >= W ? s1[i - 1] + 1 : s1[i - 1],
        s2[i] = w[i] >= W ? s2[i - 1] + v[i] : s2[i - 1];
    ll ret = 0;
    for (register int i = 1; i <= M; ++i)
        ret += (s1[r[i]] - s1[l[i] - 1]) * (s2[r[i]] - s2[l[i] - 1]);
    return ret;
}
int main() {
    scanf("%d%d%lld", &N, &M, &S);
    for (register int i = 1; i <= N; ++i) scanf("%d%d", &w[i], &v[i]);
    for (register int i = 1; i <= M; ++i) scanf("%d%d", &l[i], &r[i]);
    for (register int i = 17; i >= 0; --i)
        ans += Y(ans + (1 << i)) >= S ? (1 << i) : 0;
    printf("%lld", min(Y(ans) - S, S - Y(ans + 1)));
}
```

---

## 作者：qhr2023 (赞：1)

## solution

找答案最小值，所以二分 $W$，对于一个区间的答案可以前缀和优化到 $\mathcal O(1)$。

对于一次二分的 $W$，记 $A_i$ 表示前 $i$ 数中 $w$ 大于等于 $W$ 的个数，$B_i$ 表示前 $i$ 数中 $w$ 大于等于 $W$ 的对应的 $v$ 的和，对于一个区间 $l$ 到 $r$，该区间的贡献就是 $(A_r-A_{l-1}) \times (B_r-B_{l-1})$，那 $m$ 个区间的答案就是 $$\begin{aligned} \sum_{i=1}^m (A_r-A_{l-1}) \times (B_r-B_{l-1}) \end{aligned}$$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n, m, w[N], v[N], l[N], r[N];
long long s, s1[N], s2[N], sum, ans=1e15;
void check (int x) {
	sum=0;
	for (int i=1; i<=n; ++i) 
		s1[i]=s1[i-1]+(w[i]>=x),
		s2[i]=s2[i-1]+(w[i]>=x?v[i]:0);
	for (int i=1; i<=m; ++i) 
		sum+=(s1[r[i]]-s1[l[i]-1])*(s2[r[i]]-s2[l[i]-1]);
	ans=min(ans, abs(s-sum));
}
int main () {
	cin >> n >> m >> s;
	for (int i=1; i<=n; ++i)
		cin >> w[i] >> v[i];
	for (int i=1; i<=m; ++i)
		cin >> l[i] >> r[i];
	long long L=0, R=1e6, mid;
	while (L<=R) 
		mid=(L+R)>>1,
		check(mid),
		sum>s?L=mid+1:R=mid-1;
	cout << ans;
	return 0;
}
```

---

## 作者：lylcpp (赞：0)

## 思路

$y_i = \sum_{j=l_i}^{r_i}[w_j\ge W] \times \sum_{j=l_i}^{r_i}[w_j\ge W] v_j$。

从上面的式子中，我们不难发现，$W$ 的取值至关重要。

而 $W$ 的取值范围是 $[0,\max_{1 \le i \le n} w_i]$。

所以我们可以在这个区间里进行二分。但如何检查这个答案？

我们就是进行求和，判断它和标准值的差，小了，左指针动，大了，右指针动。但直接求和会 TLE，所以要用到前缀和。

我们记 $q$ 维护区间内 $[w_j \ge W]$ 的和，$p$ 维护区间内 $v_j$ 的和。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll; // 不开long long会wa 
const int N = 200005;
ll n, m, s, w[N], v[N], l[N], r[N];
ll q[N], p[N], mn = 1e15; // mn一定要初始化！ 
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	ll le = 0, ri = 0;
	cin >> n >> m >> s;
	for (int i = 1; i <= n; i++) {
		cin >> w[i] >> v[i];
		ri = max(ri, w[i]); // 右边界改成最大的w_i 
		// 因为w_i >= W，所以W_max = max{w_i}; 
	}
	for (int i = 1; i <= m; i++) 
		cin >> l[i] >> r[i];
	while (le <= ri) { // 二分答案 
		ll ans = 0, mid = (le + ri) / 2;
		for (int i = 1; i <= n; i++) { // 前缀和操作 
			if (w[i] > mid) { // 如果成立 
				q[i] = q[i-1] + 1; // 1的数量++ 
				p[i] = p[i-1] + v[i]; // v的总和++ 
			}
			else {
				q[i] = q[i-1]; // 否则就等于上一个的值 
				p[i] = p[i-1];
			}
		}
		for (int i = 1; i <= m; i++)
			ans += (q[r[i]] - q[l[i]-1]) * (p[r[i]] - p[l[i]-1]); // 前缀和操作 
		ll cha = s - ans; // 做差 
		if (cha < 0) le = mid + 1; // 如果说cha<0, 说明ans > s, W小了，去右半边找 
		else ri = mid - 1; // 否则去左半边找 
		mn = min(mn, abs(cha)); // 更新答案 
	}
	printf("%lld", mn); // 别忘了是%lld! 
	return 0;
}
``````

---

## 作者：Shunpower (赞：0)

首先有一个最简单的想法：枚举所有的 $W$。

那么此时 $y$ 可以简单地求出：只需把所有重量小于 $W$ 的矿石看成不存在（即不算数，也不算价值），对权值和数量各自做前缀和，然后直接按照式子把所有区间的贡献加起来就行了。复杂度 $\mathcal O(w_i(n+m))$，显然过不了。

进一步优化可以改成只枚举 $W=w_i$ 的这部分 $W$，因为取两个 $w_i$ 中间的空当和直接取较大的那个 $w_i$ 没有什么区别，不会影响重量 $\ge W$ 的矿石的集合。这样做复杂度是 $\mathcal O(n(n+m))$ 的，还是过不了。可能在现在的评测机上可以获得 $70$ 分。

考虑题目的问题：出题人希望我们找到一个尽可能逼近 $s$ 的结果。类似在一个范围内猜确定的数字，我们很容易发现这个题的 $W$ 产生的性质和猜数字没什么区别。因为所有权值都是正的，所以 $W$ 越大，反倒 $y$ 越小，这样的单调性完全支持我们通过二分的方式逼近到 $s$ 附近。

具体来说，我们二分一个 $W$，如果这个 $W$ 产生的 $y$ 比 $s$ 大，则说明 $W$ 更大可能可以更接近，更小则**一定不如这个值**；反之亦然。

于是我们总可以二分到一个 $s$ 附近的值：这个值满足要么是 $y=s$ 的 $W$，要么就是比 $y<s$ 的最小 $W$，要么就是 $y>s$ 的最大 $W$。

所以我们再检验我们二分出来的 $W$ 和它的周围两个（$W-1,W+1$），在这至多三个 $W$ 中取 $\min$ 就可以了。事实上一边二分一边取 $\min$ 也是可以的。

时间复杂度 $\mathcal O(m\log w_i)$。

代码是四年前写的。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll sumw[200010],sumv[200010];
int n,m,w[200010],v[200010],r[200010],l[200010];
int minn=INT_MAX,maxn=-20040615;
ll ans=1e18,s,sum,x;
bool check(int wans){
	x=sum=0;
	memset(sumw,0,sizeof(sumw));
	memset(sumv,0,sizeof(sumv));
	for(int i=1;i<=n;i++){
		if(w[i]>=wans){
			sumw[i]=sumw[i-1]+1;
			sumv[i]=sumv[i-1]+v[i];
		}
		else{
			sumw[i]=sumw[i-1];
			sumv[i]=sumv[i-1];
		}
	}
	for(int i=1;i<=m;i++){
		x+=(sumw[r[i]]-sumw[l[i]-1])*(sumv[r[i]]-sumv[l[i]-1]);
	}
	sum=llabs(x-s);
	if(x>s){
		return true;
	}
	else{
		return false;
	}
}
int main(){
	cin>>n>>m>>s;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>v[i];
		minn=min(minn,w[i]);
		maxn=max(maxn,w[i]);
	}
	for(int i=1;i<=m;i++){
		cin>>l[i]>>r[i];
	}
	int l1=minn-1,r1=maxn+2;
	while(l1!=r1){
		int mid=(l1+r1)/2;
		if(check(mid)){
			l1=mid+1;
		}
		else{
			r1=mid;
		}
		ans=min(sum,ans);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：fmj_123 (赞：0)

[题目链接](https://www.luogu.org/problem/P1314)

题意很明确了。所以直接跳到思路。

### Sol 1

最暴力的写法是直接枚举每个参数$W$。有分，但显然无法AC。

### Sol 2

注意到$Y$具有单调性，即随着$W$**增大而减小**。因此可以采用二分求出最靠近标准值$S$的两个值。程序段如下
```
bool ok1(long long x)
{
	long long ans=check(x);//ans求的是Y的值
	if (ans<S) return 0;else return true;//若y过大，则x取小了
}
.....
int main()
{
        long long L=1,R=1000000;
	while (L+1<R)
	{
		long long mid=(L+R)/2;
		if (ok1(mid)) L=mid;else R=mid;
	}//普通的二分
}
```

利用该方法，时间复杂度会大大减小。

### Sol 3

我们的耗时大部分花在了求和，而无论是$\sum_j v_j$还是$\sum_j 1$ 都具有**可减性**，故我们可以采用**前缀和**来维护这两项，这样可以用$O(n)$修改前缀和，$O(m)$查询，时间复杂度是质的飞跃。代码如下

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,S,vis[300000],s[300000],l[300000],r[300000],v[300000],w[300000];
long long check(long long x)
{
	long long ans=0;
	for (long long i=1;i<=n;i++)
	{
		if (w[i]>=x) vis[i]=vis[i-1]+1,s[i]=s[i-1]+v[i];
		else vis[i]=vis[i-1],s[i]=s[i-1];//判断的同时维护前缀和
	}
	for (long long i=1;i<=m;i++)
	{
		ans+=(vis[r[i]]-vis[l[i]-1])*(s[r[i]]-s[l[i]-1]);//O(1)求答案
	}
	return ans;
}
bool ok1(long long x)
{
	long long ans=check(x);
	if (ans<S) return 0;else return true;//上文已出现过
}
int main()
{
	cin>>n>>m>>S;
	for (long long i=1;i<=n;i++)
	{
		cin>>w[i]>>v[i];
	}
	for (long long i=1;i<=m;i++)
	{
		cin>>l[i]>>r[i];
	}
	long long L=1,R=1000000;
	while (L+1<R)
	{
		long long mid=(L+R)/2;
		if (ok1(mid)) L=mid;else R=mid;
	}//前面已出现过
	cout<<min(check(L)-S,S-check(R))<<endl;//以L为参数的答案大于S，以R为参数的小于S
	return 0;
}
```

### 后记

本题还有一道类似的题目[P1083 借教室](https://www.luogu.org/problem/P1083)，同为NOIP题，有兴趣的同学可以写写。

---

## 作者：jinfanhao (赞：0)

看到有使 $\left\vert s-y\right\vert$ 最小，就知道是二分了。\
二分板子就不用说了吧，主要思考的是 $\operatorname{check}$ 怎么写。\
先尝试暴力，发现 TLE 了，就维护两个个前缀和优化。\
一个是算 $[w_j \ge W]$ 的，一个是算 $[w_j \ge W]v_j$。\
那么 $y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times \sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j=(f1_{r_i}-f1_{l_i-1})\times (f2_{r_i}-f2_{l_i-1})$。\
这样答案就显而易见了吧。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+1;
int n,m,k,w[N],v[N],l[N],r[N],f1[N],f2[N],minx=10000000000000000;
bool check(int mid){
	for(int i=1; i<=n; ++i){
		f1[i]=f1[i-1];
		if(w[i]>=mid)++f1[i];
		f2[i]=f2[i-1];
		if(w[i]>=mid)f2[i]+=v[i];
	}
	int sum=0;
	for(int i=1; i<=m; ++i)sum+=(f1[r[i]]-f1[l[i]-1])*(f2[r[i]]-f2[l[i]-1]);
	minx=min(minx,abs(sum-k));
	return sum-k>=0;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1; i<=n; ++i)scanf("%lld%lld",&w[i],&v[i]);
	for(int i=1; i<=m; ++i)scanf("%lld%lld",&l[i],&r[i]);
	int l=0,r=100000000000000000;
	while(l+1<r){
		int mid=l+r>>1;
		if(check(mid))l=mid;
		else r=mid;
	}
	printf("%lld",minx);
	return 0;
}
```

---


# [HNOI2005] 狡猾的商人

## 题目描述

刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了 $n$ 个月以来的收入情况，其中第 $i$ 个月的收入额为 $a_i$，$i=1,2,\ldots,n-1,n$。当 $a_i>0$ 时表示这个月盈利 $a_i$ 元，当 $a_i<0$ 时表示这个月亏损 $|a_i|$ 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。

刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。

现在，姹总共偷看了 $m$ 次账本，当然也就记住了 $m$ 段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。


## 样例 #1

### 输入

```
2
3 3
1 2 10
1 3 -5
3 3 -15
5 3
1 5 100
3 5 50
1 2 51
```

### 输出

```
true
false
```

# 题解

## 作者：pengym (赞：121)

####洛谷P2294 [HNOI2005]狡猾的商人 ，神奇做法——贪心


- 看到大牛都是写的差分约束或带权并查集，本蒟蒻都不太会（还是用差分约束过了的QAQ），但是想出一种贪心的策略，运用神奇的优先队列实现。


- 思路是：先按左端点为第一排序关键字，再排右端点。之后就开始两两比较，如果左端点相等，就比较右端点，如果相等，就比较值，如果值不同，就直接输出false，否则输出true，如果右端点不等，就把相同的部分抵消掉，把新的区间再压入优先队列。直到不能操作，就输出true。


- (ps:作为蒟蒻在洛谷的第一篇博客，还是有点小小的激动 QAQ)

####下附代码：


```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 1100
using namespace std;
inline void read(int &x)
{
    x=0;
    int p=1;
    char c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    x*=p;

}//快速读入

int n,m;
struct node
{
    int l,r,s;
    bool operator < (const node &h)const
    {
        if(l!=h.l)return l>h.l;
        return r>h.r;

}//重载运算符，确定优先队列的优先级

}tmp;
priority_queue<node>q;
int main()
{
    int t;
    read(t);
    while(t--)
    {    
        while (!q.empty()) q.pop();//多组数据清空
        read(n);read(m);
        if(m==1){printf("true\n");continue;}//其实没必要特判，只是优化一点点
        for(int i=1;i<=m;i++)
        {
            int l,r,s;
            read(tmp.l);read(tmp.r);read(tmp.s);
            q.push(tmp);
        }
        tmp=q.top();//取出第一个
        q.pop();
        while(!q.empty())
        {    
            node tmp1;
            tmp1=q.top();
            q.pop();
            if(tmp.l==tmp1.l)
            {
                if(tmp.r==tmp1.r)
                {
                    if(tmp.s!=tmp1.s)
                    {printf("false\n");goto end;}//退出多重循环的小操作
                }
                else 
                if(tmp.r<tmp1.r)
                    q.push((node) {tmp.r+1, tmp1.r, tmp1.s - tmp.s});//将抵消后的部分放入队列
            }
            tmp = tmp1;//继续比
        }
        printf("true\n");
        end:;
    }
    return 0;
}
```

---

## 作者：66666a (赞：57)

题解里清一色的spfa

然而我用了并查集

给出[l,r]的区间和，相当于s[r]-s[l](前缀和思想)

一旦已经知道了 s[a]-s[b],s[b]-s[c]，显然再给出一条[a,c]就可以判断"账本的真假"了 

将每条这样的信息(l,r,w)，l,r放入一个集合中，用并查集来维护，并维护cha[l]=s[root]-s[l],cha[r]=s[root]-s[r]

若 l,r已经在同一个集合中，就直接查询cha[l]-cha[r]，判读与w是否相等 

AC代码

```cpp
#include<bits/stdc++.h>
int fa[105],cha[105];  
int find(int x)
{  
    if(x!=fa[x])
    {
        int t=find(fa[x]);
        cha[x]+=cha[fa[x]];
        fa[x]=t;  
    }  
    return fa[x];  
}  
int main()  
{  
    int T,n,m,i,x,y,z,flag;  
    scanf("%d",&T);  
    while (T--) 
    {  
        flag=0;  
        scanf("%d%d",&n,&m);  
        for(i=0;i<=n;i++)
        {  
            fa[i]=i;  
            cha[i]=0;  
        }  
        for(i=1;i<=m;i++)  
        {  
            scanf("%d%d%d",&x,&y,&z);  
            x--;  
            if(find(x)!=find(y))  
            {  
                cha[fa[y]]=cha[x]-cha[y]-z;  
                fa[fa[y]]=fa[x];
            }  
            else  
            if(cha[x]-cha[y]!=z) flag=1;  
        }  
        if(flag==0) printf("true\n"); else printf("false\n");  
    }  
    return 0;  
}

```

---

## 作者：brealid (赞：26)

在洛谷里面搜索 [差分约束系统](https://www.luogu.com.cn/problem/list?keyword=&tag=185&orderBy=difficulty&order=asc&page=1) 找到的这题。

首先看到题面，觉得是差分约束板子题。

明显，一个题目给出的条件 $s, t, v$ 表示 $sum[s - 1] + v = sum[t]$

---

在差分约束里面，对于形如 $a_i+w=a_j$ 的柿子，我们一般把其拆成两个柿子
$\begin{cases}a_i+w\le a_j\\a_i+w\ge a_j\end{cases}$

可以看出，只要满足上面两个柿子，就可以使得 $a_i+w=a_j$。

为了适应这道题，我们需要将两个不等式改成这个样子：
$\begin{cases}a_i+w\le a_j\\a_j-w\le a_i\end{cases}$

因此，对于一个题目给出的条件 $s, t, v$，我们需要连两条边 $\begin{cases}s-1\xrightarrow{v}t\\t\xrightarrow{-v}s-1\end{cases}$

然后，显然，如果有正环则为 ``false``, 否则为 ``true``。  
（个人觉得，其实这道题检测有没有负环也是可以的）  
（其实，由于题目给的条件是等于号，所以只要检测到一个权值不为 $0$ 的环就可以说是 ``false`` 的）  

---

然而提交是 WA 的。

原因： 图不一定联通，所以需要建立超级源点。  
因为 $1\le s$，所以 $0\le s-1$, 所以节点编号最小是 $0$。  
因此超级源点不可以是结点 $0$， 但可以是结点 $n+1$

然后就 AC 了

---
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

template <typename Int>
inline Int read()       
{
    Int flag = 1;
    char c = getchar();
    while ((!isdigit(c)) && c != '-') c = getchar();
    if (c == '-') flag = -1, c = getchar();
    Int init = c & 15;
    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);
    return init * flag;
}

struct Edge {
    int to, v;
};
#define make_edge(u, v) ((Edge){(u), (v)})
vector<Edge> G[5007];
int n, m;
int dis[5007];
bool inq[5007];
int vis[5007];

int once()
{
    // [read data]
    n = read<int>();
    m = read<int>();
    for (int i = 0; i <= n + 1; i++) G[i].clear();
    for (int i = 1, u, v, w; i <= m; i++) {
        u = read<int>();
        v = read<int>();
        w = read<int>();
        G[u - 1].push_back(make_edge(v, w)); // sum_{u-1} + w <= sum_{v}
        G[v].push_back(make_edge(u - 1, -w)); // sum_{v} - w <= sum_{u-1}
    }
    for (int i = 0; i <= n; i++)
        G[n + 1].push_back(make_edge(i, 0));
    // [/read data] 
    // [spfa]
    queue<int> q;
    q.push(n + 1);
    memset(dis, 0xcf, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    memset(inq, 0, sizeof(inq));
    dis[n + 1] = 0;
    while (!q.empty()) {
        int fr = q.front(); 
        q.pop();
        inq[fr] = 0;
        for (unsigned i = 0; i < G[fr].size(); i++) {
            if (dis[G[fr][i].to] < dis[fr] + G[fr][i].v) {
                dis[G[fr][i].to] = dis[fr] + G[fr][i].v;
                if (!inq[G[fr][i].to]) {
                    vis[G[fr][i].to]++;
                    if (vis[G[fr][i].to] > n) {
                        puts("false");
                        return 0;
                    }
                    inq[G[fr][i].to] = true;
                    q.push(G[fr][i].to);
                }
            }
        }
    }
    // [/spfa]
    puts("true");
    return 0;
}

int main()
{
    int T = read<int>();
    while (T--) once();
    return 0;
}
```

顺便说一下，觉得这道题出的不太好。就算商人的账本是伪造的，求和也不应该有不同的值……这道题实际想问的是刁姹的数学有没有算错吧……

---

## 作者：星灵王 (赞：18)

本蒟蒻的神奇打发——区间DP（卡时间的代码，大佬别吐槽）

毕竟区间DP打法简单，理解起来也容易（这题不是讲区间DP，所以不懂区间DP的请先去刷道模板）

从小区间到大区间来，确定大区间端点，然后循环一遍判断是否有已经赋值的可以合并为大区间的两个小区间，如果没有则跳出，然后看看有大区间是否已赋值，如果有就判断，否则赋值

复杂度大致为O（wmn）（竟然过了，o(*￣︶￣*)o哈哈哈）
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int f[101][101];
int main()
{
    int w,n,m,p,s,t,v;
    cin>>w;
    for(int i=1;i<=w;i++)
    {
        memset(f,0,sizeof(f));
        scanf("%d%d",&n,&m);
        for(int j=1;j<=m;j++)
        {
            scanf("%d%d%d",&s,&t,&v);
            f[s][t]=v;
        }
        p=1;
        for(int j=2;j<=n;j++)
        if(p)				//加速
        for(int k=j-1;k>=1;k--)
        if(p) 				//再加速
        for(int l=k;l<j;l++)	//简单的三个循环
        if(f[k][l]&&f[l+1][j])	//是否有已经赋值的可以合并为大区间的两个小区间
        {
            if(f[k][j])
            {
                if(f[k][j]!=f[k][l]+f[l+1][j])
                {
                    p=0;
                    break;
                }
            }
            else
            f[k][j]=f[k][l]+f[l+1][j];
        }
        if(p==0)
        cout<<"false"<<endl; 
        if(p==1)
        cout<<"true"<<endl;
    }
    return 0;
}
```

---

## 作者：luqyou (赞：16)

提供一种不一样的思路。

我们可以根据读入的区间和来算出一些区间的和。如果跟已知冲突，那么输出 `false`，否则输出 `true`。

考虑如何来算出区间和。

每次我们读入的区间 $[l,r]$ 会把区间 $[1,n]$ 分成 $3$ 个区间：$[1,l)$，$[l,r]$ 以及 $(r,n] $。

我们令 $s_{i,j}$ 为区间 $[i,j]$ 的和，那么用循环 $i$ 遍历这三个区间。

分类讨论：

- $i$ 在 $[1,l)$ 中：

    若 $s_{i,r}$，$s_{i,l-1}$ 都已知，则检查 $s_{i,l-1}+s_{l,r}$ 是否等于 $s_{i,r}$，如果不是则返回 `false`；
    
    若 $s_{i,r}$ 未知，$s_{i,l-1}$ 已知，则 $s_{i,r}=s_{i,l-1}+s_{l,r}$；
    
    若 $s_{i,r}$ 已知，$s_{i,l-1}$ 未知，则 $s_{i,l-1}=s_{i,r}-s_{l,r}$。
    
- $i$ 在 $[l,r]$ 中：
    
    若 $s_{l,i}$，$s_{i+1,r}$ 都已知，则检查 $s_{l,i}+s_{i+1,r}$ 是否等于 $s_{l,r}$，如果不是则返回 `false`；
    
    若 $s_{l,i}$ 未知，$s_{i+1,r}$ 已知，则 $s_{l,i}=s_{l,r}-s_{i+1,r}$；
    
    若 $s_{l,i}$ 已知，$s_{i+1,r}$ 未知，则 $s_{i+1,r}=s_{l,r}-s_{l,i}$。
    
- $i$ 在 $(r,n]$ 中：

    若 $s_{r+1,i}$，$s_{l,i}$ 都已知，则检查 $s_{l,r}+s_{r+1,i}$ 是否等于 $s_{l,i}$，如果不是则返回 `false`；
    
    若 $s_{r+1,i}$ 未知，$s_{l,i}$ 已知，则 $s_{r+1,i}=s_{l,i}-s_{l,r}$；
    
    若 $s_{r+1,i}$ 已知，$s_{l,i}$ 未知，则 $s_{l,i}=s_{l,r}+s_{r+1,i}$。
    
于是我们就可以这样判断出来了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,s[101][101];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>t;
	while(t--){
		memset(s,0x7f,sizeof s);
		cin>>n>>m;
		bool ok=1;
		for(int i=1;i<=m;i++){
			int l,r,v;
			cin>>l>>r>>v;
			s[l][r]=v;
         //一段区间=0x7f7f7f7f代表这段区间未知
			for(int j=r+1;j<=n;j++){//情况3
				if(s[r+1][j]!=0x7f7f7f7f&&s[l][j]!=0x7f7f7f7f){
					if(s[l][r]+s[r+1][j]!=s[l][j]){
						ok=0;
					}
				}
				if(s[r+1][j]==0x7f7f7f7f&&s[l][j]!=0x7f7f7f7f){
					s[r+1][j]=s[l][j]-s[l][r];
				}
				if(s[r+1][j]!=0x7f7f7f7f&&s[l][j]==0x7f7f7f7f){
					s[l][j]=s[l][r]+s[r+1][j];
				}
			}
			for(int j=l-1;j>=1;j--){//情况1
				if(s[j][l-1]!=0x7f7f7f7f&&s[j][r]!=0x7f7f7f7f){
					if(s[l][r]+s[j][l-1]!=s[j][r]){
						ok=0;
					}
				}
				if(s[j][l-1]==0x7f7f7f7f&&s[j][r]!=0x7f7f7f7f){
					s[j][l-1]=s[j][r]-s[l][r];
				}
				if(s[j][l-1]!=0x7f7f7f7f&&s[j][r]==0x7f7f7f7f){
					s[j][r]=s[l][r]+s[j][l-1];
				}
			}
			for(int j=r;j>=l;j--){//情况2
				if(s[l][j]!=0x7f7f7f7f&&s[j+1][r]!=0x7f7f7f7f){
					if(s[l][j]+s[j+1][r]!=s[l][r]){
						ok=0;
					}
				}
				if(s[l][j]==0x7f7f7f7f&&s[j+1][r]!=0x7f7f7f7f){
					s[l][j]=s[l][r]-s[j+1][r];
				}
				if(s[l][j]!=0x7f7f7f7f&&s[j+1][r]==0x7f7f7f7f){
					s[j+1][r]=s[l][r]-s[l][j];
				}
			}
		}
		if(ok) cout<<"true"<<endl;
		else cout<<"false"<<endl;
	}
	return 0;
}
```


---

## 作者：Starria的脑残粉 (赞：9)

emm...我来加个并查集的新题解吧。。大概就是强行权值并查集一波，，然后在一个集内的话判一下是否合法就可以了

代码量极短

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,m,f[1000],ff[1000],x,y,z,xx,yy;
bool flag;
int fa(int x){
    if (f[x]==x)return x;
    int k=f[x],kk=fa(f[x]);ff[x]+=ff[k];//加上父节点的权值然后连接到father
    f[x]=kk;return kk;//路径压缩
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>t;while (t--){
        cin>>n>>m;flag=true;
        for (int i=0;i<=n;i++)f[i]=i,ff[i]=0;
        for (int i=1;i<=m;i++){
            cin>>x>>y>>z;x--;xx=fa(x);yy=fa(y);//考虑前缀和数组，x到y的和自然是a[y]-a[x-1]，所以x要--
            if (xx!=yy){
                f[yy]=xx;ff[yy]=ff[x]+z-ff[y];//连边
            }else flag&=ff[x]+z==ff[y];//判断是否合法
        }if (flag)cout<<"true"<<endl;else cout<<"false"<<endl;
    }
}
```

---

## 作者：「QQ红包」 (赞：6)

题解by:redbag

大概思路同楼下

然而dfs的spfa跑得似乎快些

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
int T;
int n,m;
struct node
{
    int u,v,w,id;
} a[2010];
int d;
int p[200];
int flag[200];
int dis[200];
int flag2;
int dfs(int x)
{
    flag[x]=1;//标记在里面 
    for (int i=p[x];i!=-1;i=a[i].id)
    {
        int y=a[i].v;
        if (dis[x]+a[i].w<dis[y])//可以进行松弛操作 
        {
            if (flag[y]==1)//如果在里面就说明出现负环了 
            {
                flag2=1;
                return 0;
            } else
            {//进行松弛操作然后继续搜 
                dis[y]=dis[x]+a[i].w;
                dfs(y);
            }
        }
    }
    flag[x]=0;
    return 0;
}
int main()
{
    int x,y,z;
    scanf("%d",&T);
    while (T--)
    {
        flag2=0;
        memset(p,-1,sizeof(p));
        memset(flag,0,sizeof(flag));
        memset(dis,0,sizeof(dis));//因为是找负环，所以清成0没事 
        scanf("%d%d",&n,&m);
        d=0;//开始没清0 QAQ 
        for (int i=1;i<=m;i++)
        {
            //建双向边，权值一正一负 
            scanf("%d%d%d",&x,&y,&z);
            d++;
            a[d].u=x-1;
            a[d].v=y;
            a[d].w=z;
            a[d].id=p[a[d].u];
            p[a[d].u]=d;
            
            d++;
            a[d].u=y;
            a[d].v=x-1;
            a[d].w=-z;
            a[d].id=p[a[d].u];
            p[a[d].u]=d;
        }
        for (int i=0;i<=n;i++)
        {
            dfs(i);//一个点一个点的跑dfs的spfa找负环 
            if (flag2==1) break;
        }
        if (flag2==1) printf("false\n");
        else printf("true\n");
    }
    return 0;
}

```

---

## 作者：凑个热闹吖 (赞：4)

这似乎是一道**高斯消元**的模板题。

但好像没有高斯消元的题解。

### 解法

>- 显然，对于每一条信息，我们都可以建立一个方程。

>- 等号左边将 $s$ 到 $t$ 天的系数赋值为 $1$，其他赋值为 $0$。等号右边赋值为 $v$。

>- 最后直接套入高斯消元模板，然后判断有没有解就可以了。

>- 时间复杂度为 $O(wnm)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define rep(i , m , n) for(register int i = m; i <= n; i++)

using namespace std;
int Q;
int n , m;
double d[1005][105];
bool Guass(){
	int sta = 1;
	rep(i , 1 , n){
		int now = sta;
		for(; now <= m && d[now][i] == 0; now++);
		if(now > m)continue;
		rep(j , 1 , n + 1)swap(d[sta][j] , d[now][j]);
		rep(j , sta + 1 , m){
			if(d[j][i] == 0)continue;
			double tmp = d[j][i] / d[sta][i];
			rep(k , i , n + 1)d[j][k] -= d[sta][k] * tmp;
		}
		sta++;
		if(sta > m)break;
	}//以上是高斯消元模板 
	
	rep(i , 1 , m){
		bool flag = true;
		rep(j , 1 , n)if(d[i][j] != 0)flag = false;
		if(d[i][n + 1] != 0 && flag)return false;//如果等号左边的系数全为零，且等号右边不为零，则无解 
	}
	return true;//如果有解，说明账单是真的 
}
int main(){
	scanf("%d" , &Q);
	while(Q--){
		memset(d , 0 , sizeof d);
		scanf("%d%d" , &n , &m);
		rep(i , 1 , m){
			int s , t , sum;
			scanf("%d%d%d" , &s , &t , &sum);
			
			rep(j , s , t)d[i][j] = 1; 
			d[i][n + 1] = sum;//建立方程 
		}
		if(!Guass())printf("false\n");
		else		printf("true\n");
	}
	return 0;
}
```


---

## 作者：pikabi (赞：4)

题目链接——> [**P2294 [HNOI2005]狡猾的商人**](https://www.luogu.com.cn/problem/P2294)

写完看了一下题解区发现用区间DP的不多，也有一些缺陷，在此就来完善一番。

题目大致释意：若无法给出一组数满足给出的 $m$ 个条件，则输出 false ，反之则输出 true 。

给出数组 $a[i][j]$表示区间 $i$ 到 $j$ 的区间和。初始值设为 inf 。

于是我们给出三重循环，第一重枚举每次区间长度，第二重枚举左端点， 第三重枚举左右端点之间的位置。 $i$ 表示左端点， $j$ 表示右端点， $k$ 表示区间长度， $l$ 表示左右端点之间的位置。我们可以从中知道 $a[i][j]=a[i][l]+a[l+1][j]$ 的递推式。如果 $a[i][j]$ 与已确定的 $a[i][l] + a[l + 1][j]$ 不同，则可直接退出。同时我们可以在一开始判重，若不一样，则可直接退出。

具体详见代码——>

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define inf 123456789//定义

using namespace std;

int w, n, m, a[105][105], p;

int main(){
	scanf("%d",&w);
	while(w--){
		scanf("%d%d",&n,&m);
		p = 1;
		for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++) a[i][j] = inf;//别忘了赋初值哦~
		for(int i = 1; i <= m; i++){
			int x, y, z;
			scanf("%d%d%d",&x,&y,&z);
			if(a[x][y] == inf || a[x][y] == z)//从读入开始判断
			a[x][y] = z;
			else p = 0;
		}
		if(p)
		for(int k = 1; k <= n; k++){
			for(int i = 1; i + k <= n; i++){
				int j = k + i;
				for(int l = i; l < j; l++){//DP主体
					if(a[i][l] != inf && a[l + 1][j] != inf){//若已确定两个子区间
						if(a[i][j] == inf) a[i][j] = a[i][l] + a[l + 1][j];//未有则赋值，已有则比较
						else if(a[i][j] != a[i][l] + a[l + 1][j]){
							p = 0;
							goto there;//若不同，直接退出
						}
					}
				}
			}
		}
		there:;
		if(p) printf("true\n");
		else printf("false\n");
	}
	return 0;
} 
```
观察到$n < 100$，$ w < 100$， 足够我们跑了。不吸氧333ms足以满足需求。


撒花完结╰( ´・ω・)つ──☆✿✿✿

---

## 作者：bellmanford (赞：4)

其实这道题可以将账本看作一张图

对于u月份到v月份赚了w元

可以认为是u点到v+1点的边权值为w

既然如此

那如果从v月份回到u月份

钱也会相应的减少w元

也就是说v+1点到u点的边权值为-w

由此可以获得一张图

样例的第一个账本所构成的图如下：

![](https://cdn.luogu.com.cn/upload/pic/59197.png)

然后以最小的点s点为开始点

创建dis值

dis[i+1]也就是s月份到i月份所赚的钱数

由样例可知:

dis[1]=0

dis[3]=10

dis[4]=-5

检查后未发现矛盾 

所以是对的

代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int w,n,m,s,tot,dis[100005],first[100005];
bool vis[100005];
struct Edge{//链表 
	int nxt,to,val;
}e[200005];

void init(){//初始化 
	tot=0;s=1<<30;
	dis[1]=0;
	memset(vis,0,sizeof(vis));
	memset(dis,127,sizeof(dis));
	memset(first,0,sizeof(first));
}

void add(int x,int y,int z){
	tot++;
	e[tot].nxt=first[x];
	first[x]=tot;
	e[tot].to=y;
	e[tot].val=z;
}

void build(int u){//创建 
	vis[u]=1;
	for(int i=first[u];i;i=e[i].nxt){
		int v=e[i].to,w=e[i].val;
		if(!vis[v]){
			dis[v]=dis[u]+w;
			build(v);
		}
	}
}

bool check(){//检查是否有矛盾 
	for(int i=1;i<=n+1;i++){
		if(vis[i]==1){
			for(int j=first[i];j;j=e[j].nxt){
				int v=e[j].to,w=e[j].val;
				if(dis[v]!=dis[i]+w) return 0;
			}
		}
	}
	return 1;
}

int main(){
	scanf("%d",&w);
	while(w--){
		init();
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++){
			int a,b,c;
			scanf("%d%d%d",&a,&b,&c);
			s=min(s,a);
			add(a,b+1,c);//连线 
			add(b+1,a,-c);//再反过来连 
		}
		build(s);//先以一个点为基础，得到其他点的距离 
		if(check()) printf("true\n");
		else printf("false\n");
	}
}
```


---

## 作者：DaCong (赞：4)

思路和下面的大神差不多，但是用了比较喜欢用 STL （其实就是喜欢用 vector 来实现邻接表）。

首先用一下前缀和的思想：设 \\(s\_i\\) 为前 i 个月的总收入


则对于每一次读入的数据 \\( (u, v, w) \\) 可以得到 \\(s\_v - s\_{u-1} = w\\) ，即 \\( s\_v - s\_{u-1} \ge w \\) && \\( s\_v - s\_{u-1} \le w \\) ，那么这就是我们熟悉的差分约束的模板了。


我们引一条从u-1 到 v 的权值为 w 的边和一条从 v 到 u-1 的权值为 -w 的边来完成建图，由于题目要求判断是否造假，也就是要判断图中是否有负环，因此我们选择使用 DFS 版本的 SPFA 。


```cpp
#include <cstdio>
#include <vector>
using namespace std;

const int maxn = 105;
const int maxm = 1005;

struct node{
    int to, val;
};
vector<node> e[maxn];
int t, n, m, dis[maxn];
bool vis[maxn], flag;

void SPFA(int x){ \\其实就是 DFS
    vis[x] = 1;
    for(int i = 0; i < e[x].size(); i++){
        node v = e[x][i];
        if(dis[v.to] > dis[x] + v.val){
            if(vis[v.to]){flag = 1; return;}
            dis[v.to] = dis[x] + v.val;
            SPFA(v.to);
        }
    }
    vis[x] = 0;
    return;
}
int main(){
    scanf("%d", &t);
    while(t--){
        scanf("%d%d", &n, &m);
        for(int i = 1; i <= m; i++){
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            e[u-1].push_back((node){v, w});
            e[v].push_back((node){u-1, -1*w}); //建图
        }
        for(int i = 0; i <= n; i++){
            dis[i] = 0;
            SPFA(i);
            if(flag) { break;}
        }
        if(flag) printf("false\n");
        else printf("true\n");
        for(int i = 0; i <= n; i++){ \\记得在判断完每一组之后复位
            vis[i] = 0;
            dis[i] = 0;
            e[i].clear();
        }
        flag = 0;
    }
    return 0;
}

```

---

## 作者：kczno1 (赞：3)

一开始想当然地输出了一个布尔变量，后来才发现大小写会出问题。

s到t和为v,如果用sum[i]表示1-i的和，即转化为sum[t]-sum[s-1]=v。

转化为图，在s-1,t之间连一条权值v的边，再连一条-v的反向边。

题目即判断图中是否存在权值和不为0的环。只要dfs一遍，就能O(M)解决。


---

## 作者：djy213 (赞：2)

就直接加权并查集嘛；

输入区间端点i,j,则合并i-1,j（这样算得出间接关系之间的权呀）；

若i-1,j以有关系，判断他们的关系是否是新关系？继续：false；

即w[j]-w[i-1]==新值?

具体路径压缩时维护权值见代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int f[101],w[101],l;

void work();
int find(int);
void merge(int ,int);

int main()
{
        int i,t;
        scanf("%d",&t);
        for(i=1;i<=t;i++)
                work();
        return 0;
}

void work()
{
        int i,j,k,n,m,p=0;
        scanf("%d%d",&n,&m);
        for(i=0;i<=n;i++)
        {
                f[i]=i;
                w[i]=0;
        }
        for(i=1;i<=m;i++)
        {
                scanf("%d%d%d",&j,&k,&l);
                j--;
                if(find(j)==find(k))
                {
                        if(w[k]-w[j]!=l&&p==0)
                        {   
                                printf("false\n");
                                p=1;
                        }
                }
                else
                        merge(j,k);
        }
        if(p==0)
                printf("true\n");
        return;
}

int find(int x)
{
        int a;
        if(f[x]==x)
                return x;
        a=find(f[x]);
        if(f[f[x]]!=f[x])
                w[x]+=w[f[x]];
            f[x]=a;
        return f[x];
}

void merge(int x,int y)
{
        w[find(y)]=l-w[y];
        f[find(y)]=x;
        find(y);
}
```

---

## 作者：santongding (赞：2)

同样也用的差分约束，但我没建双向边和找负环；

利用前缀和建图，a,b,c就建一个a到b权值为c的边

由样例可知，如果出现矛盾，那么从一个点出发到另一个点的距离的不同路径的权值和不同

所以只要dfs几遍就好了，不过要注意每次dfs有可能到已经到过的点，这时候还要继续深搜，因为起点不同了

记录权重和的d[]数组可能值为零，不能用来判断这个点在这次dfs中是否走过，只好再开一个use1[]数组来判断（好像直接把d赋值成无限也可以？。。。）



```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<cstring>
#include<cstdio>
#define LL long long
#define random(a,b) (a+rand()%(b-a+1))
using namespace std;
const int maxn=1005;
struct asd
{
    int next,to,val;
} edge[2005];
int node[1005];
int etot=0;
void add(int x,int y,int z)
{
    edge[++etot].next=node[x];
    edge[etot].to=y;
    edge[etot].val=z;
    node[x]=etot;
}
int use[maxn],d[maxn],flag,use1[maxn];
void dfs(int x)
{
    use[x]=use1[x]=1;
    for(int i=node[x]; i; i=edge[i].next)
    {
        if(flag)return;
        int too=edge[i].to;
        if(!use1[too])
        {
            d[too]=d[x]+edge[i].val;
            dfs(too);
        }
        else if(d[too]!=d[x]+edge[i].val)
            {
                flag=1;
                return;
            }
    }
}
int n,m,t;
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        for(int i=0; i<=n; i++)node[i]=use[i]=d[i]=0;
        etot=flag=0;
        for(int i=1; i<=m; i++)
        {
            int tmp1,tmp2,tmp;
            scanf("%d%d%d",&tmp1,&tmp2,&tmp);
            add(tmp1-1,tmp2,tmp);
        }
        for(int i=0; i<=n; i++)
        {
            if(flag)break;
            if(!use[i]){
                for(int j=0;j<=n;j++)use1[j]=0;
            dfs(i);    
            }
        }
        if(flag)printf("false\n");
        else printf("true\n");
    }
}

```

---

## 作者：throusea (赞：1)

本人弱，用的是纯纯的模拟。

思路如下：
	
对于所有给定的区间，如果已知两个区间（$a$,$x$）,（$x$,$b$）的值，那么我们就可以知道（$a$,$b$）的值，同理，如果已知两个区间（$x$,$a$）和（$x$,$b$）（$a$<$b$），那么我们就可以知道（$a$,$b$）的值。我们对于每一个区间，我们求出与之存在一个点相同的区间的反区间。总共有6种情况，像数学的分类讨论。
    
时间复杂度：$O$($nm$). 相比其他算法确实略弱一些。不过这个方法比较好想。

## 附上代码

```cpp
#include<cstdio>
using namespace std;
const int maxn=100 + 5,INF=1<<30;
int f[maxn][maxn];

void mems(int n) { //初始化数组
    for(int i=1;i<=n+1;i++)
        for(int j=1;j<=n+1;j++)
        f[i][j]=INF;
}

int main() {
    int T,n,m;
    scanf("%d",&T);
    while(T--) {
        scanf("%d%d",&n,&m);
        mems(n);
        int l,r,w;
        bool flag=0;
        for(int i=1;i<=m;i++) {
            scanf("%d%d%d",&l,&r,&w);
            r++;  
            //r++意思是用（l,r）表示l到r（不含r）的总和，便于后面的计算
            if(f[l][r]==w||f[l][r]==INF)
                f[l][r]=w;
            else 
                flag=1;
            for(int j=1;j<=n;j++) 
            if(j<l){
                if(f[j][l]!=INF) {
                    if(f[j][r]!=f[j][l]+f[l][r]&&f[j][r]!=INF)
                        flag=1;
                    else
                        f[j][r]=f[j][l]+f[l][r];
                }
                if(f[j][r]!=INF) {
                    if(f[j][l]!=f[j][r]-f[l][r]&&f[j][l]!=INF)
                        flag=1;
                    else 
                        f[j][l]=f[j][r]-f[l][r];
                }
            } else if(l<j&&j<r) {
                if(f[l][j]!=INF)
                    if(f[j][r]!=f[l][r]-f[l][j]&&f[j][r]!=INF)
                        flag=1;
                    else
                        f[j][r]=f[l][r]-f[l][j];
                if(f[j][r]!=INF)
                    if(f[l][j]!=f[l][r]-f[j][r]&&f[l][j]!=INF)
                        flag=1;
                    else
                        f[l][j]=f[l][r]-f[j][r];
            } else if(j>r){
                if(f[r][j]!=INF)
                    if(f[l][j]!=f[l][r]+f[r][j]&&f[l][j]!=INF)
                        flag=1;
                    else 
                        f[l][j]=f[l][r]+f[r][j];
                if(f[l][j]!=INF)
                    if(f[r][j]!=f[l][j]-f[l][r]&&f[r][j]!=INF)
                        flag=1;
                    else 
                        f[r][j]=f[l][j]-f[l][r];
            } //计算让我想到了向量
        }
        if(!flag) puts("true");
        else puts("false");
    }
    return 0;
}
```
	

---


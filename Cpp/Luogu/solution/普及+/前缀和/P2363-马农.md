# 马农

## 题目描述

在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。

兄弟两回到草原，将可以养马的区域分为 $N \times N$ 的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。现在，兄弟俩找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。


## 说明/提示

对于所有数据，$1 \leq n \leq 50$。

## 样例 #1

### 输入

```
3
1 2 3
4 5 6
7 8 9```

### 输出

```
2```

# 题解

## 作者：zengxr (赞：19)

# 二维矩阵和

题目无非两种情况，一种就是一块地在右上，一块地在左下。或者是一种在左上，一种在右下。

# 思路：

用暴力去枚举相交的点，设为A，在枚举上面格子的顶点B
枚举下面格子的顶点C，再去判断符不符合题意就行了。

### （注意有两种情况，都要枚举）

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x) {
    char ch; bool ok;
    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;
    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;
}//快读
int n;
int ans;
int f[2010][2010],a[2010][2010],d[11111111];
int main()
{
    read(n);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            read(a[i][j]);
            f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            for(int x=1;x<=i;x++)
            for(int y=1;y<=j;y++)
            d[f[i][j]-f[i][y-1]-f[x-1][j]+f[x-1][y-1]]++;
            for(int x=i+1;x<=n;x++)
            for(int y=j+1;y<=n;y++)
            ans=ans+d[f[x][y]-f[x][j]-f[i][y]+f[i][j]];//枚举，统计答案
            for(int x=1;x<=i;x++)
            for(int y=1;y<=j;y++)
            d[f[i][j]-f[i][y-1]-f[x-1][j]+f[x-1][y-1]]=0;//做完一种情况后一定要清空数组
            for(int x=1;x<=i;x++)
            for(int y=j+1;y<=n;y++)
            d[f[i][y]-f[x-1][y]-f[i][j]+f[x-1][j]]++;
            for(int x=i+1;x<=n;x++)
            for(int y=1;y<=j;y++)
            ans=ans+=d[f[x][j]-f[i][j]-f[x][y-1]+f[i][y-1]];//枚举，统计答案
            for(int x=1;x<=i;x++)
            for(int y=j+1;y<=n;y++)
            d[f[i][y]-f[x-1][y]-f[i][j]+f[x-1][j]]=0;//清空
            
        }
    }
    printf("%d",ans);//输出答案
    return 0;
}
```

---

## 作者：Lemon_X (赞：10)

 # 一道很棒的哈希模拟题。
~~肝了老半天才做出来……~~

------------

 _**Step 1**_ 
 

**审题.**[（题目传送门）](https://www.luogu.com.cn/problem/P2363)


**大概题意：**

枚举**相交点**，然后在**相交点的基础上枚举两个区域**，确保**有且仅有一个相交点**并且**两者区域之和相等**。


------------

 _**Step 2**_ 

有了上面的分析，整理出思路就很简单啦：

   枚举兄弟俩饲养马区域的**相交点**，然后分别枚举他们俩饲养马区域**上下顶点**。
   
   注意，养马顶点的朝向有两个方向，**左上--右下**和**右上--左下**。
   
   下面是**左上——右下**的**示例**（红色表示相交点，橙色和绿色分别表示上下顶点）：
   
   ![](https://cdn.luogu.com.cn/upload/image_hosting/8tfw57dg.png)
   
   

------------

_**Step 3**_

   题目说两人的**收益要相当**，也就是如果**上面格子的面积**$=$**下面格子的面积**，答案就就加一。

   模拟完后记得要**清空哈希表**（注意动态数组要一行一行清）。

------------

_**Step 4**_
### AC代码：
 ```cpp
#include<iostream>
#include<vector>
using namespace std;
struct horse_farmer{
    int jg,wz; 
};
int qzh[51][51];
vector<horse_farmer> h[1007];
int kong_jz(int qdh,int qdl,int zdh,int zdl){//起点行，起点列，终点行，终点列 
    return qzh[zdh][zdl]-qzh[zdh][qdl-1]-qzh[qdh-1][zdl]+qzh[qdh-1][qdl-1];
}
int clean_hx(){
    for( int i=0;i<1007;i++) h[i].clear();
}
int main(){
    int i,j,n,a,x,y,k,l,aa,z=0,ll;
    cin>>n;
    for(i=1;i<=n;i++){//i行j列 
        for(j=1;j<=n;j++){
            cin>>a;
            qzh[i][j]=qzh[i-1][j]+qzh[i][j-1]+a-qzh[i-1][j-1];//前缀和优化
        }
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            clean_hx();//清空哈希
            for(x=1;x<i;x++){
                for(y=1;y<j;y++){
                    a=kong_jz(x,y,i-1,j-1);//起点x,y,终点i-1,j-1;
                    aa=(2500000+a)%1007;
                    l=h[aa].size();
                    for(k=0;k<l;k++){
                        if(h[aa][k].jg==a){
                            h[aa][k].wz=h[aa][k].wz+1;
                            break;
                        }
                    }
                    if(k>=l){
                        h[aa].push_back((horse_farmer){a,1});
                    }
                }
            }
            for(x=i;x<=n;x++){
                for(y=j;y<=n;y++){
                    a=kong_jz(i,j,x,y);
                    aa=(2500000+a)%1007;
                    l=h[aa].size();
                    for(k=0;k<l;k++)
                        if(h[aa][k].jg==a){
                            z=z+h[aa][k].wz;
                        }
                }
            }
            clean_hx();//清空哈希
            for(x=1;x<i;x++){
                for(y=j+1;y<=n;y++){
                    a=kong_jz(x,j+1,i-1,y);
                    aa=(2500000+a)%1007;
                    l=h[aa].size();
                    for(k=0;k<l;k++)
                        if(h[aa][k].jg==a){
                            h[aa][k].wz++;
                            break;
                        }
                    if(k>=l){
                        h[aa].push_back((horse_farmer){a,1});
                    }
                }
            }
            for(x=i;x<=n;x++){
                for(y=1;y<=j;y++){
                    a=kong_jz(i,y,x,j);
                    aa=(2500000+a)%1007; 
                    l=h[aa].size();
                    for(k=0;k<l;k++)
                        if(h[aa][k].jg==a){
                            z=z+h[aa][k].wz;
                        }
                }
            }
        }
    }
    cout<<z;
}
```
谢谢各位大佬的耐心观看！

谢谢善良的管理员通过我的题解！

---

## 作者：Exber (赞：7)

## 做法
二维前缀和+哈希表。

首先可以发现需要使用二位前缀和来 $O(1)$ 求出一个矩形的收益。然后由于两个马场的矩形区域要角对角，所以可以枚举每一个交点。

对于每一个交点，先枚举位于交点左上的所有矩形，把所有的收益可能值加入哈希表中。再枚举位于交点右下的所有矩形的收益可能值，判断是否在哈希表中，在的话答案就加上这个收益值在交点左上所对应的矩形个数。

枚举完位于交点左上的和右下的矩形后先**清空哈希表**，再枚举位于交点右上的和左下的矩形，进行一遍相同的操作。

由于 ```map``` 常数太高，所以需要手写哈希表。

整体来说这道题还是蛮有难度的。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
 
const int mod=1007;
 
using namespace std;
 
struct node
{
    int size,sum; // sum 记录有多少个 size 收益的矩形 
};
 
int n,a[55][55],s[55][55]; // 草原地图、前缀和数组 
vector<node> mp[mod]; // 哈希表 
 
int size(int x,int y,int x2,int y2) // O(1) 求收益 
{
    return s[x][y]-s[x][y2-1]-s[x2-1][y]+s[x2-1][y2-1];
}
 
void clr() // 清空哈希表 
{
    for(int i=0;i<mod;i++)
    {
        mp[i].clear();
    }
}
 
void ins(int x) // 插入一个收益值 
{
    int wh=(x+250000)%mod;
    for(int i=0;i<mp[wh].size();i++)
    {
        if(mp[wh][i].size==x)
        {
            mp[wh][i].sum++;
            return;
        }
    }
    mp[wh].push_back((node){x,1});
}
 
int find(int x) // 寻找一个收益值，返回矩形个数 
{
    int wh=(x+250000)%mod;
    for(int i=0;i<mp[wh].size();i++)
    {
        if(mp[wh][i].size==x)
        {
            return mp[wh][i].sum;
        }
    }
    return 0; // 没找到返回 0 
}
 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]; // 前缀和预处理 
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            clr(); // 记得清空哈希表 
            for(int k=1;k<=i;k++)
            {
                for(int l=1;l<=j;l++)
                {
                    ins(size(i,j,k,l)); // 左上所有收益可能值加入哈希表 
                }
            }
            for(int k=i+1;k<=n;k++)
            {
                for(int l=j+1;l<=n;l++)
                {
                    ans+=find(size(k,l,i+1,j+1)); // 更新答案 
                }
            }
            clr(); // 记得清空哈希表 
            for(int k=1;k<=i;k++)
            {
                for(int l=j;l<=n;l++)
                {
                    ins(size(i,l,k,j)); // 右上所有收益可能值加入哈希表
                }
            }
            for(int k=i+1;k<=n;k++)
            {
                for(int l=1;l<j;l++)
                {
                    ans+=find(size(k,j-1,i+1,l)); // 更新答案 
                }
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：kyel (赞：6)

## 啥动归呀。。。蒟蒻只会暴力。。。
//**该做法实际上是对楼下大佬提到的O(n^10)的优化。**

我们先理清一下O(n^10)做了啥

首先用两个for循环枚举**位于交点上方的单位矩形**。
![](https://cdn.luogu.com.cn/upload/pic/50699.png)

~~没错图片下面为洛谷水印留白了~~

如图所示，我们就是要**枚举红色的矩形**。

然后我们再枚举每个矩形最上方的矩形，如下图所示。
![](https://cdn.luogu.com.cn/upload/pic/50700.png)

这样做似乎可能重复计数，但其实是**不重不漏**的，读者可以自己比划一下。

枚举每个矩形是O(n^2),我们枚举了3次；然后我们对两个灰色矩形做一下求和，每个矩形是O(n^2)；**2\*3+2\*2=10**，非常完美。

好了，我们已经得到了一个非常优(bao)雅(li)的做法，接下来想优化。

第一个优化非常容易想到：做二维前缀和，来O(1)求出灰色矩形的值。嗯，这不是重点...我相信大家都会啦！~~（懒）~~

第二个优化：我们发现，**枚举中间的矩形(O(n^2))似乎是必不可少的**，然而如果我们用**嵌套**的for枚举两个灰色矩形，就会加上O(n^4)，，50 ^ 6 = 15625000000,**这复杂度再怎么优化也没用了**。。

所以肯定的，**我们要把嵌套的4个for循环拆出来**！

使用自己的**hash表或者是std的map**，令val[x]表示和为x的矩形在上方所有矩形中有几个，当我们枚举到下方某一矩形值为sum时，直接把ans += val[sum]，即**上方有几个矩形能和它对应**。这样就做好了。

于是我们得到了一个O(n^4)的做法，跑过n=50还是没问题的。

非常简单易想是不是

```cpp
#include <cstdio>
#include <cstdlib>

#include <algorithm>

namespace my {//主要是实现hash表
    const int maxele(2523), maxhash(999667);
    class item {
        public:
            item() : next(0) {}
            
            int key, val;//val为出现次数
            item *next;
    }all[maxele];
    item *end(all);
    int hash(int v) {
        return (((long long)(v) * 19391) % maxhash + maxhash) % maxhash; //hash函数，随便写就好
    }
    class map {
        public:
            map() : nextvis(1) {}
            void clear() {
                ++nextvis;
                end = all;
            }
            int insert(int val) {
                int hashval(hash(val));
                if (bVal[hashval] != nextvis) {
                    bVal[hashval] = nextvis;
                    end->key = val;
                    end->val = 1;
                    end->next = 0;
                    head[hashval] = end++;
                } else {
                    item *now(head[hashval]), *front;
                    while (now) {
                        if (now->key == val) {
                            ++now->val;
                            return now->val;
                        }
                        front = now;
                        now = now->next;
                    }
                    end->key = val;
                    end->val = 1;
                    end->next = 0;
                    front->next = end++;
                }
                return 1;
            }
            int count(int val) {
                int hashval(hash(val));
                if (bVal[hashval] != nextvis) return 0;
                else {
                    item *now(head[hashval]);
                    while (now) {
                        if (now->key == val) return now->val;
                        now = now->next;
                    }
                }
                return 0;
            }
            item *head[maxhash];
            int bVal[maxhash], nextvis;
    }map;
}
int n, rect[51][51], forward[51][51];
int count(int l, int t, int r, int b) {
    if (l > r) l ^= r ^= l ^= r;
    if (t > b) t ^= b ^= t ^= b;
    return forward[b][r] - forward[b][l - 1] - forward[t - 1][r] + forward[t - 1][l - 1];
}//利用二维前缀和求矩形和
long long ans(0);
int main() {
    scanf("%d", &n);
    for (int i(1); i <= n; ++i) {
        for (int j(1); j <= n; ++j) {
            scanf("%d", &rect[i][j]);
        }
    }
    for (int i(1); i <= n; ++i) {
        for (int j(1); j <= n; ++j) {
            forward[i][j] = forward[i - 1][j] + forward[i][j - 1] - forward[i - 1][j - 1] + rect[i][j];
        }
    }
    for (int i(1); i <= n; ++i) {
        for (int j(1); j <= n; ++j) {
            my::map.clear();
            for (int t(1); t <= i; ++t) {
                for (int l(1); l <= j; ++l) {
                    my::map.insert(count(l, t, j, i));
                }
            }//枚举左上方矩形
            for (int b(i + 1); b <= n; ++b) {
                for (int r(j + 1); r <= n; ++r) {
                    ans += my::map.count(count(j + 1, i + 1, r, b));
                }
            }//枚举右下方矩形
            my::map.clear();
            for (int t(1); t <= i; ++t) {
                for (int r(j); r <= n; ++r) {
                    my::map.insert(count(j, t, r, i));
                }
            }//枚举右上方矩形
            for (int b(i + 1); b <= n; ++b) {
                for (int l(1); l <= j - 1; ++l) {
                    ans += my::map.count(count(l, i + 1, j - 1, b));
                }
            }//枚举左下方矩形
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：喵仔牛奶 (赞：4)

$O(n^6)$ 做法好想，枚举第一个矩阵的左上、两个矩阵交点、第二个矩阵的右下即可，二维前缀和优化。

然后我们发现，每次算的总和居然是重复的！所以，先提前把总和算出来再统计即可 $O(n^4)$ 解决。

事实上，左上和右下与右下和左上是等效的，所以只需要把其中一个写出来，不然答案会是正确的两倍。

然而如果统计和是负数，会喜提 RE 。所以需要加上一个大数再统计。$50^2\times1000=2500000$，加这个即可。

```cpp
#pragma GCC optimize("Ofast") // 在本地跑开，在洛谷上开会CE
#include <bits/stdc++.h>
using namespace std;
const int N = 55, M = 6e6 + 5, VMAX = 2500000;
int a[N][N], sum[N][N], cnt[M], n, ans;
int getsum(int x1, int y1, int x2, int y2) {
	return sum[x1][y1] - sum[x1][y2 - 1] - sum[x2 - 1][y1] + sum[x2 - 1][y2 - 1];
}
inline void read(int &a) {
	register int t = 1;
	register char ch = getchar();
	a = 0;
	while (ch < '0' || ch > '9')  {
		if (ch == '-') t = -1;
		ch = getchar();
	}
	while (ch <= '9' && ch >= '0')
		a = a * 10 + ch - '0', ch = getchar();
	a *= t;
}
int main() {
	freopen("farmer.in", "r", stdin);
	freopen("farmer.out", "w", stdout);
	read(n);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j ++)
			read(a[i][j]), sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j ++) {
			for (int k = 1; k <= i; k ++)
				for (int l = 1; l <= j; l ++)
					cnt[getsum(i, j, k, l) + VMAX] ++;
			for (int k = i + 1; k <= n; k ++)
				for (int l = j + 1; l <= n; l ++)
					ans += cnt[getsum(k, l, i + 1, j + 1) + VMAX];
			for (int k = 1; k <= i; k ++)
				for (int l = 1; l <= j; l ++)
					cnt[getsum(i, j, k, l) + VMAX] =  0;
			for (int k = 1; k <= i; k ++)
				for (int l = j + 1; l <= n; l ++)
					cnt[getsum(i, l, k, j + 1) + VMAX] ++;
			for (int k = i + 1; k <= n; k ++)
				for (int l = 1; l <= j; l ++)
					ans += cnt[getsum(k, j, i + 1, l) + VMAX];
			for (int k = 1; k <= i; k ++)
				for (int l = j + 1; l <= n; l ++)
					cnt[getsum(i, l, k, j + 1) + VMAX] = 0;
		}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Light_az (赞：3)

## 二维前缀和板子

首先我们根据题意来判断时间复杂度，先使用 $O(n^2)$ 的时间去枚举两个矩阵的交点 $(i,j)$，然后使用 $O(2 n^2)$ 的时间分别去枚举两个矩阵的终点（起点就是刚刚枚举的交点），总时间复杂度为 $O(2n^4)$，对于题目中的数据范围是可以实现的。

然后我们来处理前缀和，先来制作一个二维前缀和，原理如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/wkeaxni5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如果我们现在想要求出红色矩阵数字的总和，那么我们可以将大矩阵减去两个绿色矩阵。其中我们发现蓝色矩阵被绿色矩阵覆盖了两次，因此我们要把这个矩阵给补回来，因此我们得到前缀和的式子为：$sum_{i,j}=sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}+a_{i,j}$，当然如果我们想要查询起点是 $(x,y)$ 终点是 $(i,j)$ 的矩阵，我们同理可以用 $sum_{i,j}-sum_{i,y-1}-sum_{x-1,j}+sum_{x-1,y-1}$ 来表示它们的和，然后考虑到题目中的答案可能会有负数，因此我们可以使用哈希映射来处理结果，其中哈希在每次操作之后需要清空，否则会有情况重复计算。在此之后我们只需要在枚举交点的基础上，再次计算出 $(x1,y1)$ 到 $(i,j)$ 的矩阵和以及 $(x2,y2)$ 到 $(i,j)$ 的矩阵和，进行比较厚如果结果相同，即可行方案数增加，否则跳过。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(int i=j;i<=n;i++)
using namespace std;
ll n,ans;
ll a[55][55],sum[55][55];
map<ll,ll> mp;
int main(){
	cin>>n; 
	F(i,1,n) F(j,1,n){
		cin>>a[i][j];
		sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];//前缀和预处理
	} 
	F(i,1,n){
		F(j,1,n){
			F(x,1,i) F(y,1,j) mp[sum[i][j]-sum[i][y-1]-sum[x-1][j]+sum[x-1][y-1]]++;//查询第一个矩阵的可能情况和（左上角）
			F(x,i+1,n) F(y,j+1,n) ans+=mp[sum[x][y]-sum[x][j]-sum[i][y]+sum[i][j]];//查询第二个矩阵的可能情况和并加上其中的答案（右下角）
			mp.clear();//清空哈希
			F(x,1,i) F(y,j+1,n) mp[sum[i][y]-sum[x-1][y]-sum[i][j]+sum[x-1][j]]++;//查询第一个矩阵的可能情况和（左下角）
			F(x,i+1,n) F(y,1,j) ans+=mp[sum[x][j]-sum[i][j]-sum[x][y-1]+sum[i][y-1]];//查询第二个矩阵的可能情况和并加上其中的答案（右上角）
			mp.clear();//清空哈希
		}
	}
	cout<<ans;
	return 0;
}
```

## End

[![](https://cdn.luogu.com.cn/upload/usericon/781159.png)](https://www.luogu.com.cn/user/781159)


---

## 作者：杨跃浙 (赞：3)

问题分析：

在矩形中选一个初始点，然后寻找以这个点作为顶点的两个矩阵，数字和要求一样，求方案总数。

算法分析：

枚举可能的初始点，然后以初始点为顶点往上、往下再枚举可能拓展的目标矩阵。求出两个拓展的矩阵和，记录和一样的方案数。

程序框架：

1:输入

2：枚举初始点，以初始点为顶点再枚举拓展出两个目标矩阵，再求出矩阵和，记录和一样的方案数。

3：输出方案总数

时间复杂度分析：

枚举初始点:n^2

枚举拓展矩阵:n^2\*n^2

求矩阵和:n^2\*n\*2

总时间复杂度O(n^10)

根据题目规模，估计40分

优化思想：

把所有可能的子矩阵和预先处理掉，即先求出来初始化放入数组中。

这样时间复杂度下降到O(n^6)，估计60分。


求和的思想：普通枚举还是需要O(n^6)

  需要用动态规划优化到O(n^4)


根据题目规模n<=50，满分算法要优化到O(n^4)

优化思想2：

分别求出两个对角子矩阵可能的和，然后放入桶中进行统计。

然后根据两个桶的和直接求方案总数。

例如桶1出现可能的和有 100 3次

桶2出现可能的和有100 2次。

那么可以出现和100的方案数就是2\*3=6种。

时间复杂度为O(n^4)


---

## 作者：lsroi (赞：2)

### 做法思路：
1.先把所有子矩阵预处理出来，将它们的和从小到大排序。

2.只有值相同的子矩阵才会对答案有贡献，所以我们可以用二分快速找出对答案有贡献的区间，再考虑计算区间内的答案。

3.如何计算区间内的答案呢？

最傻的方法：是暴力枚举一对子矩阵，判断他们是否属于对顶矩阵~~（乱取的名）~~。由于区间内的元素可能会很多，所以这样会超时（不过这样可以得80）

我的想法：我们可以扫一遍区间，分别记录一个坐标（x,y）被多少个子矩阵当做左上角、右上角、左下角、右下角。记录完之后，明显再扫一遍出现过的坐标，计算就可以得出答案了。**举个例子：**如果有co个子矩阵以（x,y）当做左上角，那这个点对答案的贡献就是co*co1。（co1为以（x-1,y-1）当做右下角的子矩阵个数）。

更优的处理方法？（~~太菜，想不到~~）
### 数组作用：

**sum**：二维前缀和，快速算矩阵内的元素和。

**co**:以（x,y）为左上角的子矩阵个数。
同理**co1**记录右下角。

**to**左下角，**to1**右上角。

**p**记录不同的左上角坐标。**q**记录不同的左下角坐标。

**lp**为**p**的长度。    **lq**为**q**的长度。

还有，**f**数组是储存每个子矩阵的信息的。


### ~~废话不多说~~上代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=55;
const int maxm=1650000;
int sum[maxn][maxn],tot=0;
int co[maxn][maxn],co1[maxn][maxn],p[maxn*maxn],lp=0;
int to[maxn][maxn],to1[maxn][maxn],q[maxn*maxn],lq=0;
struct node{
    int data,x1,y1,x2,y2;   //(x1,y1)左下角,(x2,y2)右下角
}f[maxm];
bool cmp(node x,node y){return x.data<y.data;}//按矩阵和大小排序
int ef(int x,int l,int r)
{
    int mid;
    while(l<r)
    {
      mid=(l+r)/2;
      if(f[mid].data<x)l=mid+1;
      else r=mid;
    }
    return l;
}
int ef1(int x,int l,int r)
{
    int mid;
    while(l<r)
    {
      mid=(l+r+1)/2;
      if(f[mid].data<=x)l=mid;
      else r=mid-1;
    }
    return l;
}
int main()
{
    int n,i,j,k,l;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      {
        scanf("%d",&sum[i][j]);
        sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
      }
    for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
        for(k=i;k<=n;k++)
          for(l=j;l<=n;l++)
          {
            f[++tot].data=sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1];
            f[tot].x1=i;  f[tot].y1=j;  f[tot].x2=k;  f[tot].y2=l;
          }
    sort(f+1,f+tot+1,cmp);//排序

    int ans=0;
    for(i=1;i<=tot;)
    {
      int l=ef(f[i].data,i,tot),r=ef1(f[i].data,i,tot);//算区间位置
      lp=lq=0;    //初始化
      for(j=l;j<=r;j++)		//算区间内的信息
      {
	    int x1=f[j].x1,y1=f[j].y1,x2=f[j].x2,y2=f[j].y2;
	    if(co[x1][y1]==0)p[++lp]=j;
	    co[x1][y1]++;  co1[x2][y2]++;
	    if(to[x2][y1]==0)q[++lq]=j;
	    to[x2][y1]++;  to1[x1][y2]++;
	  }
	  for(j=1;j<=lp;j++)	//算贡献
	  {
	  	int x1=f[p[j]].x1,y1=f[p[j]].y1;
	    ans+=co[x1][y1]*co1[x1-1][y1-1];
	  }
	  for(j=1;j<=lq;j++)
	  {
	  	int x2=f[q[j]].x2,y1=f[q[j]].y1;
	    ans+=to[x2][y1]*to1[x2+1][y1-1];
	  }
	  for(j=l;j<=r;j++)		//还原
      {
	    int x1=f[j].x1,y1=f[j].y1,x2=f[j].x2,y2=f[j].y2;
	    co[x1][y1]--;  co1[x2][y2]--;
	    to[x2][y1]--;  to1[x1][y2]--;
	  }
      i=r+1;				//算下个值相同的矩阵区间
    }
    printf("%d\n",ans);
    return 0;
}
```

最后再加上我的一开始的80分的处理方法（血淋淋的提交记录）：

```cpp
for(i=1;i<=tot;)
    {
      int l=ef(f[i].data,i,tot),r=ef1(f[i].data,i,tot);
      for(j=l;j<=r;j++)
        for(k=j+1;k<=r;k++)
        {
          int x1=f[j].x1,y1=f[j].y1,x2=f[j].x2,y2=f[j].y2;
          int x3=f[k].x1,y3=f[k].y1,x4=f[k].x2,y4=f[k].y2;
          if(x1==x4+1&&y1==y4+1)ans++;
          if(x1==x4+1&&y2==y3-1)ans++;
          if(x2==x3-1&&y1==y4+1)ans++;
          if(x2==x3-1&&y2==y3-1)ans++;
        }
      i=r+1;
    }
```
**注：**
时间复杂度：时耗主要是在排序上面的。。。，O（NlogN）N为不同子矩阵的个数

经计算N最大为1625625.

完结。。。（~~代码又长跑的又慢，连STL二分都不会写，太弱了~~）

---

## 作者：carp_oier (赞：1)

# FOREWARD	

你需要掌握哈希和二阶前缀和的知识，这里不多赘述，可以自行前往某学习网站学习。go on~。

# 思路分析

首先，我们拿到这个题之后，看到它会要求一个矩阵范围的和，所以我们必然会想到用二阶前缀和，去降低时间复杂度。

之后，我们便开始第一个思考：我们可以用四层循环来枚举每一个矩阵，在用大法师来向四个方向（左上，右上，右下，左下）来枚举遍历另外一个矩阵，但是这样我们不难看出时间复杂度 $ O(n^6) $ 必然会爆，那么就去想怎么优化。

我们这个时候可以考虑去遍历这两个矩形的交点，再以这个点分别向左上右下，右上左下这两个方向去遍历这两个矩形的另外一个顶点，先将一个里矩阵里面所有的可能值存储到一个数组中，考虑到这个数字会很大，所以便想着用哈希去将它映射到这个底层数组中。之后再通过另一个矩阵的值来对应里面的方案个数。时间复杂度 $ O(n^4) $ ~~常数项我就不算了，溜~~。


下面配图二张，有读者老爷想看可以自行观看理解：
![](https://cdn.luogu.com.cn/upload/image_hosting/5yhejao4.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/salmkfvf.png)

（这个是一种处理方式，紫色的先存下，蓝色的遍历加值）

# 代码

（刷题千万条，诚信第一条，代码长一样，棕名两行泪）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define rl register ll
#define wl putchar('\n')
#define ws putchar(' ')
#define endl '\n'

template <class T>

inline void read(T &res)
{
	char ch; bool f = 0;
	while((ch = getchar()) < '0' || ch > '9') f |= ch == '-';
	res = ch ^ 48;
	while((ch = getchar()) <= '9' && ch >= '0') res = (res << 1) + (res << 3) + (ch ^ 48); 
	f ? res = ~res + 1 : res = res;
}

inline void ww(ll x)
{
	if(x > 9) ww(x / 10);
	putchar(x % 10 ^ '0');
}

const ll N = 110, M = 200003;

ll s[N][N], st[M], n, ans, h[M];

inline ll find(ll n)
{
	ll k = (n % M + M) % M;
	while(h[k] != n && h[k]) 
	{
		k ++ ;
		if(k == M) k = 0;
	}
	
	return k;
}

int main()
{
	read(n);
	for(rl i=1; i <= n; ++ i)
		for(rl j=1; j <= n ; ++ j)
		{
			read(s[i][j]);
			s[i][j] += s[i-1][j] + s[i][j-1] - s[i-1][j-1];
		}
		
	for(rl i=1;i <= n; ++ i)
		for(rl j=1;j <= n; ++ j)
		{	
			for(rl p=i; p; -- p)
				for(rl q=j; q; -- q)
				{
					ll x = find(s[i][j] - s[p-1][j] - s[i][q-1] + s[p-1][q-1]);
					st[x] ++ ; 
				}
			
			for(rl p=i+1; p <= n; ++ p)
				for(rl q=j+1; q <= n; ++ q)
					ans += st[find(s[p][q] - s[i][q] - s[p][j] + s[i][j])];
					
			for(rl p=i; p; -- p)
				for(rl q=j; q; -- q)
					st[find(s[i][j] - s[p-1][j] - s[i][q-1] + s[p-1][q-1])] = 0;
					
			for(rl p=i; p; -- p)
				for(rl q=j; q <= n; ++ q)
					st[find(s[i][q] - s[i][j-1] - s[p-1][q] + s[p-1][j-1])] ++ ;
			
			for(rl p=i+1; p <= n; ++ p)
				for(rl q=j-1; q; -- q)
					ans += st[find(s[p][j-1] - s[p][q-1] - s[i][j-1] + s[i][q-1])];
				
			for(rl p=i; p; -- p)
				for(rl q=j; q <= n; ++ q)
					st[find(s[i][q] - s[i][j-1] - s[p-1][q] + s[p-1][j-1])] = 0;
		}
		
	ww(ans), wl;
	return 0;
}
```


---

## 作者：_Flame_ (赞：1)

## 思路

个人认为锻炼代码能力与练习前缀和较好的一道题。

这题要求使的两个子矩阵的总价值相等，且两个子矩阵只有一个交点，所以自然想到用一个二维前缀和来求出每一个子矩阵的价值，然后遍历整个大矩阵，对每一个点处理它的左上右下与左下右上两个子矩阵，找到可行的交点，每找到一个就把答案加一即可。

注意子矩阵的价值可能是一个负数，所以要加上一个较大的数来避免出现负下标。

## Code


```cpp
#include<bits/stdc++.h>
#define f 500000
using namespace std;

int n;
int a[1001][1001];
int s[1000][1000];
int sum[1000][1000];
int t[5000000];
int ans=0;

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			sum[i][j]=sum[i][j-1]+sum[i-1][j]+s[i][j]-sum[i-1][j-1];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=i;k++){
				for(int l=1;l<=j;l++){
					t[sum[i][j]-sum[i][l-1]-sum[k-1][j]+sum[k-1][l-1]+f]++;
				}
			}
			for(int k=i+1;k<=n;k++){
				for(int l=j+1;l<=n;l++){
					ans+=(t[sum[k][l]-sum[k][j]-sum[i][l]+sum[i][j]+f]);
				}
			}
			for(int k=1;k<=i;k++){
				for(int l=1;l<=j;l++){
					t[sum[i][j]-sum[i][l-1]-sum[k-1][j]+sum[k-1][l-1]+f]=0;
				}
			}
			for(int k=1;k<=i;k++){
				for(int l=j+1;l<=n;l++){
					t[sum[i][l]-sum[k-1][l]-sum[i][j]+sum[k-1][j]+f]++;
				}
			}
			for(int k=i+1;k<=n;k++){
				for(int l=1;l<=j;l++){
					ans+=t[sum[k][j]-sum[i][j]-sum[k][l-1]+sum[i][l-1]+f];
				}
			}
			for(int k=1;k<=i;k++){
				for(int l=j+1;l<=n;l++){
					t[sum[i][l]-sum[k-1][l]-sum[i][j]+sum[k-1][j]+f]=0;
				}
			}
		}
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：Robin_kool (赞：0)

### 题意：

在两个矩阵的相交点上枚举两个区域，确保仅有一个相交点并且每个矩阵的和相等。

### 思路：

+ 二维前缀和，可以 $O \left( 1 \right)$ 求出子矩阵的和。

+ 枚举两块矩阵的交点，枚举右上角和左下角的矩阵，左上角和右下角的矩阵。

+ 构建一个桶，先把总和算出来再统计。

+ 注意在计算总和时，要加上一个大数，以确保和 $\geq 0$，防止数组爆炸。

### [代码](https://www.luogu.com.cn/paste/5gekibor)




---

## 作者：COsm0s (赞：0)

**第一种算法**：暴力算法。

这是最原始的方法，可以做到不重不漏，但是对于本题，时间复杂度很高。

------------

**第二种算法**：在第一种的基础上用二维前缀和优化。

既然前面一种算法里涉及到了矩阵求和，那很容易想到二维前缀和。

将二维前缀和代入前面的算法，再次优化，可是仍然过不了 $n\leq50$ 的数据。


------------

**第三种算法（正解）**：枚举右上角和左下角的矩阵，左上角和右下角的矩阵。

题目说两个矩阵交于一点，即顶点相交，则这两个矩阵的位置只有以下两种可能：一个在左下，一个在右上或一个在左上，一个在右下。再结合二维前缀和优化，时间复杂度可以降到很低很低。

我们发现，每次算的总和是重复的。所以，运用桶的算法，先提前把总和算出来再统计，就可以通过。

其实左上和右下与右下和左上是一样的，所以只需要把一组中的其中一个写出来，不然答案会是两倍。

下面是代码：
```cpp


signed main() {
	long long n,x,y,ans,a[500][500],b[8000000];
    cin>>n;
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			cin>>a[i][j];
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			a[i][j]=a[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];//前缀和处理
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++) {
			for (int x=1; x<=i; x++)
				for (int y=1; y<=j; y++)
					++b[a[i][j]-a[i][y-1]-a[x-1][j]+a[x-1][y-1]];//枚举左上，记录总和 
			for (int x=i+1; x<=n; x++)
				for (int y=j+1; y<=n; y++)
					ans+=b[a[x][y]-a[x][j]-a[i][y]+a[i][j]];//如果右下有总和与左上的相等，则答案++ 
			for (int x=1; x<=i; x++)
				for (int y=1; y<=j; y++)
					--b[a[i][j]-a[i][y-1]-a[x-1][j]+a[x-1][y-1]];//回溯 
			for (int x=1; x<=i; x++)
				for (int y=j+1; y<=n; y++)
					++b[a[i][y]-a[x-1][y]-a[i][j]+a[x-1][j]];//枚举右上，记录总和
			for (int x=i+1; x<=n; x++)
				for (int y=1; y<=j; y++)
					ans+=b[a[x][j]-a[i][j]-a[x][y-1]+a[i][y-1]];//如果右上有总和与左下的相等，则答案++ 
			for (int x=1; x<=i; x++)
				for (y=j+1; y<=n; y++)
					--b[a[i][y]-a[x-1][y]-a[i][j]+a[x-1][j]];//回溯 
		}
	cout<<ans;
	return 0;

}
```

可是我们交上去后，却有神奇的 RE 出现，这是怎么回事呢？

因为题目说总和不一定为正数，如果和是负数，那就爆数组了，即出现了   $a_{-1}$ 的情况。所以我们可以在算总和时加一个大数 $50^2×1000=2500000$，加这个数可以保证不会爆。

伪代码：
```cpp
signed main() {
	long long n,x,y,ans,a[500][500],b[8000000];//注意数组要开和极限的2倍
	const int N=2500000;//防止RE 
    cin>>n;
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			cin>>a[i][j];
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			a[i][j]=a[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];//前缀和处理
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++) {//枚举顶点
			for (int x=1; x<=i; x++)
				for (int y=1; y<=j; y++)
					++b[a[i][j]-a[i][y-1]-a[x-1][j]+a[x-1][y-1]+N];//枚举左上，记录总和 
			for (int x=i+1; x<=n; x++)
				for (int y=j+1; y<=n; y++)
					ans+=b[a[x][y]-a[x][j]-a[i][y]+a[i][j]+N];//如果右下有总和与左上的相等，则答案++ 
			for (int x=1; x<=i; x++)
				for (int y=1; y<=j; y++)
					--b[a[i][j]-a[i][y-1]-a[x-1][j]+a[x-1][y-1]+N];//回溯 
			for (int x=1; x<=i; x++)
				for (int y=j+1; y<=n; y++)
					++b[a[i][y]-a[x-1][y]-a[i][j]+a[x-1][j]+N];//枚举右上，记录总和
			for (int x=i+1; x<=n; x++)
				for (int y=1; y<=j; y++)
					ans+=b[a[x][j]-a[i][j]-a[x][y-1]+a[i][y-1]+N];//如果右上有总和与左下的相等，则答案++ 
			for (int x=1; x<=i; x++)
				for (y=j+1; y<=n; y++)
					--b[a[i][y]-a[x-1][y]-a[i][j]+a[x-1][j]+N];//回溯 
		}
	cout<<ans;
	return 0;

}
```



---

## 作者：yeshubo_qwq (赞：0)

思路：

1.先做一遍二维前缀和，用于 $O \left( 1 \right)$ 求出一块矩阵的和。

2.枚举两块矩阵的交点，再枚举上下两块矩阵求出答案，分两种情况：左上右下、右上左下。

3.用计数，累加在上面矩阵的和，枚举在下面的矩阵时直接加计数的结果即可。

4.map 太慢，哈希写起来麻烦，直接用数组也可以过，但注意清空计数数组不要用 memset，会超时。

代码：

```cpp
#include<bits/stdc++.h>
#define N 2500000
using namespace std;
int n,i,j,x,y,ans,a[55][55],b[N*2+2];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++)
			cin>>a[i][j];
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++)
			a[i][j]=a[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++){
			for (x=1;x<=i;x++)
				for (y=1;y<=j;y++)
					b[a[i][j]-a[i][y-1]-a[x-1][j]+a[x-1][y-1]+N]++;
			for (x=i+1;x<=n;x++)
				for (y=j+1;y<=n;y++)
					ans+=b[a[x][y]-a[x][j]-a[i][y]+a[i][j]+N];
			for (x=1;x<=i;x++)
				for (y=1;y<=j;y++)
					b[a[i][j]-a[i][y-1]-a[x-1][j]+a[x-1][y-1]+N]--;
			for (x=1;x<=i;x++)
				for (y=j+1;y<=n;y++)
					b[a[i][y]-a[x-1][y]-a[i][j]+a[x-1][j]+N]++;
			for (x=i+1;x<=n;x++)
				for (y=1;y<=j;y++)
					ans+=b[a[x][j]-a[i][j]-a[x][y-1]+a[i][y-1]+N];
			for (x=1;x<=i;x++)
				for (y=j+1;y<=n;y++)
					b[a[i][y]-a[x-1][y]-a[i][j]+a[x-1][j]+N]--;
		}
	return cout<<ans,0;
}
```


---


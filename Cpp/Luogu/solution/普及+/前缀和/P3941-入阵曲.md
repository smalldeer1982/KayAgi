# 入阵曲

## 题目背景

pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv

```cpp
丹青千秋酿，一醉解愁肠。 
无悔少年枉，只愿壮志狂。 
```

## 题目描述

 
小 F 很喜欢数学，但是到了高中以后数学总是考不好。

有一天，他在数学课上发起了呆；他想起了过去的一年。一年前，当他初识算法竞赛的 时候，觉得整个世界都焕然一新。这世界上怎么会有这么多奇妙的东西？曾经自己觉得难以 解决的问题，被一个又一个算法轻松解决。

小 F 当时暗自觉得，与自己的幼稚相比起来，还有好多要学习的呢。

一年过去了，想想都还有点恍惚。

他至今还能记得，某天晚上听着入阵曲，激动地睡不着觉，写题写到鸡鸣时分都兴奋不 已。也许，这就是热血吧。


 
  ![](https://cdn.luogu.com.cn/upload/pic/9810.png) 

也就是在那个时候，小 F 学会了矩阵乘法。让两个矩阵乘几次就能算出斐波那契数列的 第 $10^{100}$ 项，真是奇妙无比呢。

不过，小 F 现在可不想手算矩阵乘法——他觉得好麻烦。取而代之的，是一个简单的小 问题。他写写画画，画出了一个 $n \times m$ 的矩阵，每个格子里都有一个不超过 $k$ 的正整数。

小 F 想问问你，这个矩阵里有多少个不同的子矩形中的数字之和是 $k$ 的倍数？ 如果把一个子矩形用它的左上角和右下角描述为 $(x_1,y_1,x_2,y_2)$，其中$x_1 \le x_2,y_1 \le y_2$； 那么，我们认为两个子矩形是不同的，当且仅当他们以 $(x_1,y_1,x_2,y_2)$ 表示时不同；也就是 说，只要两个矩形以 $(x_1,y_1,x_2,y_2)$ 表示时相同，就认为这两个矩形是同一个矩形，你应该 在你的答案里只算一次。


## 说明/提示

【样例 1 说明】

这些矩形是符合要求的： (1, 1, 1, 3)，(1, 1, 2, 2)，(1, 2, 1, 2)，(1, 2, 2, 3)，(2, 1, 2, 1)，(2, 3, 2, 3)。


子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9811.png) 

特殊性质：保证所有 $a_{i,j}$ 均相同。


## 样例 #1

### 输入

```
2 3 2 
1 2 1 
2 1 2```

### 输出

```
6 
```

# 题解

## 作者：fstqwq (赞：20)

这里提供的是 std。

如果需要题解，请参考 [ppt](https://www.luogu.org/discuss/show?postid=26609)，或者其他同学的题解。


```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

#define N 405

int n, m, K;
int a[N][N], b[N], cnt[1000005];
LL ans = 0;

int main() {
    scanf("%d%d%d", &n, &m, &K);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            scanf("%d", a[i] + j);
            (a[i][j] += a[i - 1][j] + a[i][j - 1] + K - a[i - 1][j - 1]) %= K;
        }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j <= n; j++) {
            cnt[0] = 1;
            for (int k = 1; k <= m; k++) ans += cnt[(b[k] = a[j][k] + K - a[i][k]) %= K]++;
            for (int k = 1; k <= m; k++) cnt[b[k]] = 0;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：why1123 (赞：12)

这个题的题意便是求有多少子矩阵内部元素和能够整除以k。这里用到了多次矩阵求和，显然需要用到二维前缀和，从而快速获取子矩阵内部元素的和。
现在我们思考一下怎么去枚举这些矩阵。枚举左上角和右下角两个坐标显然是不可取的。于是我们发现可以规定一个上界和下界，从而规定矩阵的高度。
![yyy](https://cdn.luogu.com.cn/upload/image_hosting/dmqg9p1w.png)

我们规定高度之后，即图片中的灰色部分，我们可以得到许多等高度的矩阵。等高度的矩阵？那岂不是变成了1行m列的一个一维数组？！那么我们的问题就转化为了求一个一维数组中子区间内部元素和能否整除以k的问题。

感觉这边有点类似于CF577B的一个子问题的优化思路。类似的思想。

让我们先忘掉入阵曲这个题目，现在思考的是：给出一个一维数组，求有多少个子区间，区间内部的和能够整除以k：
*** 
设这个数组是qwq，前缀和数组为sum。如果说
$$sum[x]\%k=(\sum_{i=1}^{x}qwq[i])\%k=t$$
$$sum[y]\%k=(\sum_{i=1}^{y}qwq[i])\%k=t(x>y)$$
那么
$$(sum[x]-sum[y])\%k=(\sum_{i=1}^{x}qwq[i]-\sum_{i=1}^{y}qwq[i])\%k=(\sum_{i=y+1}^{x}qwq[i])\%k=0$$
也就是说区间$[y+1,x]$内部元素的和可以整除以k。即只要前缀和数组中有两个元素的值相同，这两个位置之间的区间的元素和便可以整除以k。不想看符号？来点带画的！
![why](https://cdn.luogu.com.cn/upload/image_hosting/k8puea2a.png)

区间1元素和模k等于t，区间2元素和模k等于t，那么区间2减去区间1得到的区间元素和便能整除以k。
然后我们看一看k的大小，最大到$10^6$，完全可以用一个vis数组来统计每个值出现的次数，最后求一下组合数即可。不过需要注意0的情况。两个模k为0的前缀和应当算为3个答案，即**两个前缀和的差以及这两个独自也算答案**。
这样我们的思路就完善了,写代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e6+5;
int sum[maxn]={0};
int qwq[maxn]={0};
int vis[maxn]={0};
int n,k;
long long ans=0;
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&qwq[i]);
		sum[i]=(sum[i-1]+qwq[i])%k;
		ans+=vis[sum[i]]++;
	}
	printf("%lld\n",ans+vis[0]);
	return 0;
}
```
核心代码就两行：
```cpp
sum[i]=(sum[i-1]+qwq[i])%k;
ans+=vis[sum[i]]++;
```

第一行显然是求前缀和，第二行便是求模数相同的区间之间能产生的符合答案的区间数。这样写的话，我们找到一个便把它和之前发现的都配对，而后把这个加进去（++操作）。上面讨论过模k为0的都独自算一个答案，所以最后再加上vis[0]即为最终答案。
***
子问题讨论完毕！重新看这个题。我们在之前把问题转化成了一堆一维的问题，那么我们现在解决子问题的复杂度是$O(n)$, 所以说我们只需要解决的是分一个上下界然后把这个子问题的代码套进去就可以了。写代码！
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k;
int qwq[405][405];//矩阵
long long sum[405][405]={0},ssum[405]={0};//二维、一维的前缀和
int vis[1000005]={0};
long long ans=0;
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&qwq[i][j]);
		}
	}
	for(int i=1;i<=n;i++){//求二维前缀和
		for(int j=1;j<=m;j++){
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+qwq[i][j];
		}
	}
	for(int i=0;i<n;i++){//mark!!!!!!!!!!!!!!!!!
		for(int j=i+1;j<=n;j++){
			for(int mm=1;mm<=m;mm++){
				ssum[mm]=(sum[j][mm]-sum[i][mm]+k)%k;
				ans+=vis[ssum[mm]]++;
			}
			ans+=vis[0];
			for(int mm=1;mm<=m;mm++){
				vis[ssum[mm]]=0;
			}
			vis[0]=0;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
在代码中mark的部分即是核心，在这里犯了不少错。。。

**错误1：首先我们是枚举上下界，所以第二层循环的j应当是<=n，而不是m。**

**错误2：我们知道前缀和的话sum[i]-sum[i-1]代表的是原数组i位置的元素，即代表一个元素，如果sum[i]-sum[i]则是代表0个元素。这话看似是废话，但是写的时候，i应当从0开始并且最大不应该等于n**

**错误3：不要忘了每次加上vis[0]**

**错误4：在原本的子问题中，核心代码两行：一行是求前缀和，另一行求区间数。所以说在这里求前缀和应该是$ssum[mm]=(ssum[mm-1]+sum[j][mm]-sum[i][mm]+k)\%k$呀！为啥不对啊**

错误4让我wa了N次。。。一说求一维前缀和肯定马上想到$ssum[i]=ssum[i-1]+qwq[i]$这种写法，直接敲上。然而需要注意的是，我们的sum也是前缀和。。。所以求出来的直接就是这一段一维前缀和，所以千万不能加上$ssum[mm-1]$，否则就成了前缀和的前缀和了。

---

## 作者：Npse_D (赞：12)

此题做法我觉得不是很好想。首先(nm)^3的暴力可过30，(nm)^2的二维前缀和优化可得60，这些都是一看到题就能想出来的做法，加上特殊性质可以拿到75.而如果写了AC算法，却粗心了，可能会是时间和分数上的双重失败。

（不过对于大佬来说这些不过是闭着眼睛敲一会儿键盘的事情。

---------------------------------------

AC思路：

首先子矩形不是子矩阵。

大概可以减少一维。因为不是二维求和，只是输出k的倍数的子矩形。首先对所有二维求和显然是n^4的算法。那么只是输出k的倍数的子矩形个数，就算二维求和做完后再朴素求解答案，就已经是n^4，因而我们如果要优化，肯定从“k的倍数”入手。

首先处理从左上角开始的每一个二维前缀和，于是可以O（1）得到矩阵中每一个子矩形的和。考虑数据范围400，可以猜到大概是n^2logn或n^3的算法。二维二分比较困难，因此可能是n^3。（这是我的思考过程）因为是k的倍数，所以把每一个二维前缀和都只存对k的余数即可。（注意负数特判，因为有减法。）

一个性质：每一个矩形都可以表示为一个大矩形减去一个小矩形。我们不妨设这个大矩形和小矩形的上边都是x=1的边。

![](https://t1.picb.cc/uploads/2017/11/09/veg0g.png)

也就是这样。

现在我们需要枚举4个值才可以表示所有的矩形：大矩形的起点的横坐标，大矩形和小矩形的宽度，小矩形的长度，大矩形的长度。

然而，大矩形和小矩形的长度实际上我们枚举一次就好，当我们枚举到一个长度，假设矩形差为m，它就是要求的矩形的值。把它存到一个vector里面，并且存它一共出现了几次。

这样就是O（n^2m)的算法了。如果想保险可以写成（m^2n)，因为有时候m会等于2 。

最后我们对这些出现过重复的矩形的值进行处理。可以举几个例子试一下，每一个差都可能是答案，而两个连续的差合起来也可能是答案。为了清楚可以看我的渣图。

![](https://t1.picb.cc/uploads/2017/11/09/velke.png)

假设如图四条线，其矩形值都是a，那么显然两条线夹着的矩形值为0（当然都是k的剩余系里面）。也就是1，2，3三个矩形都是符合条件的。那12，23，123也都是符合条件的。那答案就是1+2+3=6.当有5个a就是1+2+3+4=10.不难发现这是等差数列，用等差数列求和就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000][1000],n,m,k,ans;
long long c[1000][1000];
int apnum[5000005];
bool numaped[5000005];
vector<int>cnum;
int absolute(int x){
    if(x%k>=0)return x%k;
    else return x%k+k;
}
int main(){
    std::ios::sync_with_stdio(false); 
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            c[i][j]=absolute(c[i][j-1]+c[i-1][j]-c[i-1][j-1]+a[i][j]);
        }
    }
    for(int i=1;i<=n;i++){//横坐标枚举 
        for(int j=0;j<=n-i;j++){//宽度枚举 
                apnum[0]=1;
            for(int y=1;y<=m;y++){//长度枚举 
                apnum[absolute(c[i+j][y]-c[i-1][y])]++;
                if(!numaped[absolute(c[i+j][y]-c[i-1][y])])cnum.push_back(absolute(c[i+j][y]-c[i-1][y]));
                numaped[absolute(c[i+j][y]-c[i-1][y])]=1;
            }
            for(int p=0;p<cnum.size();p++){
                ans+=((apnum[cnum[p]])*(apnum[cnum[p]]-1))/2;
                apnum[cnum[p]]=0;
                numaped[cnum[p]]=0;
            }
            cnum.clear();
        }
    }
    cout<<ans;
}
```

---

## 作者：charles_wang (赞：11)

趁着刚结束来一发题解


这道题上来先来一个 O（N^4） 的暴力，使用前缀和；


但是，我们会发现，在枚举每个子矩阵时，有的部分是重复计算的


i，j枚举子矩阵的上下边界，o枚举我们处理到了第几列，把i、j行之间，右边界是第o列的矩阵压成一个数，之后枚举统计。


我们要把 i 到 j 的矩阵变成一行，然后就可以做 （K倍区间） 详细的可以看

链接 http://blog.csdn.net/qq\_35776409/article/details/78226120


具体原理:


对于任意一段区间[l,r]的和就是sum[r]-sum[l-1].


(sum[r]-sum[l-1])%k 保证了[l,r]这段区间要么%k等于0 要么比k小.


等于0这表示了正好是k的倍数 然后通过前缀和相同的数据来判断出剩下的k的倍数:(sum[r]-sum[l-1])%k == 0.


变形后就是：sum[r]%k==sum[l-1]%k .

最后要注意下卡常数，比如%的时间，本蒟蒻因为这个而TLE了，还有答案一定要用long long


希望对大家有所帮助


AC代码：







```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,m,k,a[405][405];
long long f[405][405],ans,cnt[1000005],b[1000005];
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++) scanf("%d",&a[i][j]);
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
          f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]+a[i][j];
    for(int i=0;i<n;i++)
      for(int j=i+1;j<=n;j++)
      {
            cnt[0]=1;
            for(int o=1;o<=m;o++) 
            {
                b[o]=(f[j][o]-f[i][o]+k)%k;
                ans+=cnt[b[o]];
                cnt[b[o]]++;
            }
            for(int o=1;o<=m;o++) cnt[b[o]]=0;
    }
    printf("%lld\n",ans);
    return 0;
}
```
暴力代码：（源自机房同学）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
#define MAXN 405
typedef long long LL;
int a[MAXN][MAXN];
LL sum[MAXN][MAXN];
inline void read(int &x){
    x=0; int f=1; char c=getchar();
    while(c>'9'||c<'0'){ if(c=='-')f=-1; c=getchar(); }
    while(c>='0'&&c<='9'){ x=x*10+c-'0'; c=getchar(); } x*=f;
}
int main(int argc,char *argv[]){
    int n,m,k;
    read(n),read(m),read(k);
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=m; ++j){
            read(a[i][j]);
            sum[i][j] = sum[i-1][j] + a[i][j] + sum[i][j-1] - sum[i-1][j-1];
        }
    int Ans = 0;
    for(int a=1; a<=n; ++a)
        for(int b=1; b<=m; ++b)
            for(int i=a; i<=n; ++i)
                for(int j=b; j<=m; ++j)
                    if((sum[i][j] - sum[a-1][j] - sum[i][b-1] + sum[a-1][b-1]) % k == 0) ++Ans;
    printf("%d\n",Ans);
    return 0;
}
```

---

## 作者：Forever丶CIL (赞：8)

嗯，这个题，一上来就是n^4暴力，可以拿60分，


但是如果够仔细的话，可以看出一些性质来，比如说：


如果

```cpp
 1111100000// 
 1111100000//
 1111100000//
 2222200000//
```
上面那个全一的矩阵的和模k的余数，和全一加全二的矩阵模k的余数相同 那么全二的矩阵的和一定是k的倍数

这样我们就可以枚举两列加一行，每次维护前几行有多少种余数


详解见代码



------------



```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int Maxn=505;
const int MaxT=1000100;
int dt[Maxn][Maxn];//存图用 
int iT[Maxn];//iT[i]表示i到j列中前几行模 k（后面用Mod表示）的余数 
int Rec[MaxT];//记录共出现了几种余数，因为k<=1e6，所以数组要开到1e6 
int n,m,Mod;//因为我把k当做循环变量了，这里用Mod代表题意中的k 
long long int ans=0;
inline int read()//读入优化
{
    int fl=1,rt=0; char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-')fl=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9'){ rt=rt*10+ch-'0'; ch=getchar(); }
    return fl*rt;
}
int main()
{
    n=read(); m=read(); Mod=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            dt[i][j]=read();
            dt[i][j]=(dt[i][j]+dt[i][j-1])%Mod;//预处理出每一行的前缀和 
        }
    }
    for(int i=1;i<=m;i++)//枚举一列 
    {
        for(int j=i;j<=m;j++)//再枚举一列 
        {
            for(int k=1;k<=n;k++)//枚举一行 
            {
                iT[k]=(iT[k-1]+dt[k][j]-dt[k][i-1]+Mod)%Mod;//算出第k行在这两列之间夹着的部分的和 
                Rec[iT[k]]=0;//先把数组清空 
            }
            for(int k=1;k<=n;k++)
            {
                if(!iT[k]) ans++;//如果一个矩阵的和模Mod本身就是0，很显然ans要加上这个矩阵 
                ans+=Rec[iT[k]]; Rec[iT[k]]++;//Rec记录了当前有多少个以iT[k]为余数的矩形 
            }   //我这里说Rec记录的矩形是专指正好被夹在ij两列中的矩形，这也是在上一个for要清空数组的原因 
        }
    }
    printf("%lld\n",ans);//注意ans要开long long 
    return 0;
}
```


------------


Rp++

---

## 作者：Dispwnl (赞：6)

> 11.29 修改排版

这题第一眼就是暴力（有$60$分）

记录前缀和，$n^4$的枚举

然而根据某种玄幻的定理能压掉一维

只枚举行距，即
```
for(int i=0;i<n;i++)
  for(int j=i+1;j<=n;j++)
```

$i,j$之间的区域和应该是$sum_j-sum_{i-1}$

再枚举列$l$，但只用枚举一次

然后用一个数组$num$记录$(sum_{j,l}-sum_{i,l}+(k<<1))\%k$

注意要$+k<<1$

防止$sum$出现负下标

$sum$是前缀和为什么$sum_{j,k}$可能会小于$sum_{i,k}$？

因为在求$sum$时取模了，$sum\%k$之后可能变很小

然后$ans+=num${刚才的差值,在程序中直接拿$h$数组储存}

然后$num${差值}$+1$

这是为什么呢?

如果子矩阵在$\%k$下的同一个余数出现$2$次

它们之间一定存在一个和为$k$的倍数的矩阵（好好想想为什么，程序最后解释）

值得注意的是$num_0=1$

因为子矩阵本身就能被$k$整除，那它自身也算一个答案

代码：
```
# include<iostream>
# include<cstdio>
# include<cstring>
#define is isdigit(ch)
#define ge getchar()
#define inl inline long long
using namespace std;
int n,m,k;
long long h[1000001],num[1000001];
long long a[501][501],sum[501][501];
inl read()
{
    long long x=0,ff=1;
    char ch=ge;
    while(!is)
    {
        if(ch=='-')
        ff=-1;
        ch=ge;
    }
    while(is)
    {
        x=x*10+ch-48;
        ch=ge;
    }
    return x;
}
int main()
{
    n=read(),m=read(),k=read();
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        {
            a[i][j]=read();
            sum[i][j]=(sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j])%k;
        }
    long long ans=0;
    for(int i=0;i<n;i++)
      for(int j=i+1;j<=n;j++)
        {
            num[0]=1;
            for(int kk=1;kk<=m;kk++)
              {
                  h[kk]=(sum[j][kk]-sum[i][kk]+(k<<1))%k;
                  ans+=num[h[kk]];
                  num[h[kk]]++;
              }
            for(int kk=1;kk<=m;kk++)
              num[h[kk]]=0;
        }
    printf("%lld",ans);
    return 0;
}
```
假设出现余数$4$两次

因为$\%k$，所以$(4+k\times x)\%k=4$（$x$是倍数）

所以一定存在一个和为$k\times x$的子矩阵


---

## 作者：lutaoquan2012 (赞：4)

## 思路：

### Part $1$
我们可以想到枚举这个矩形的左上角和右上角，再用二位前缀和求出答案。但是如果枚举这个矩形的话，因为是枚举点，复杂度就是 $O(n^4)$。

我们看到这个 $n$ 和 $m$ 最大是 $400$，复杂度应该大概是 $O(n^3)$ 才对。

### Part $2$
我们应该考虑优化枚举。

枚举 $i$，代表枚举这个矩形的上边的行，枚举 $j$，表示这个矩形的下边的行，在枚举一个 $l$，表示这个矩形最右边的列。

我们可以用这个方式枚举出一个矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxp7jaq3.png)

我们枚举 $l$，也就是列的时候，设定当前的 $l$ 是 $l1$，设定这个枚举的矩阵和是 $x$，把这个 $x\bmod k$ 中的值，记在一个数组 $b$ 里面，记成一个桶。假设后面遍历到一个 $l$，管他叫 $l2$。$l2$ 这个矩形和模 $k$ 和 $l1$ 这个矩形和模 $k$ 结果一样。

![](https://cdn.luogu.com.cn/upload/image_hosting/bcvdlpv7.png)

那么用蓝色画的那部分矩形就是一个模 $k$ 等于 $0$ 的矩形，所以答案加上 $b_{x\bmod k}$ 的值。


可以写出代码：
```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll n,m,k,a[510][510],pre[510][510],b[1000010],ans;
int main() {
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            memset(b,0,sizeof(b));
            for(int l=1;l<=m;l++){
                ll x=pre[j][l]-pre[i-1][l];
                if(x%k==0) ans++;
                ans=ans+b[x%k];
                b[x%k]++;
            }
        }
    }cout<<ans;
    return 0;
}
```

这时就能得到 $50$ 分的好成绩。
### Part $3$
我们可以看出是这个清空 $b$ 数组让我们错了，所以就要考虑优化。

我们发现这个数组不是每一个位置都会去改变，只会改变 $m$ 次，所以直接可以记录这个改变的地方，然后清空。

## 代码：
```cpp
//
// Created by 55062 on 2024/3/21.
//
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll n,m,k,a[510][510],pre[510][510],ans,b[1000010],cnt[1000010],sum;
int main() {
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++) pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+a[i][j];
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            for(int k=1;k<=m;k++) b[cnt[k]]=0;
            for(int l=1;l<=m;l++){
                ll x=pre[j][l]-pre[i-1][l];
                if(x%k==0) ans++;
                ans=ans+b[x%k];
                cnt[l]=x%k;
                b[x%k]++;   
            }
        }
    }cout<<ans;
    return 0;
}
```

---

## 作者：Saliеri (赞：4)

**题意简介**

给你一个 $n* m$ 的矩阵($ a_{i,j} < k$)，问这个矩阵中有多少子矩阵$(x1,y1,x2,y2)$（满足$ x1<=x2 ,y1<=y2 $)中元素和整除k

___

不想提$\Theta(n^3m^3)$

只要懂二维前缀和

因为我们有前缀和的帮助，每个子矩阵的和可以$\Theta(1)$求得

60分的$\Theta(n^2m^2)$暴力肯定是很好打的

```cpp
#include <cstdio>
#define int long long
inline int re(){
	int w=1;
	char c;
	while((c=getchar())<='0'||c>'9')if(c=='-')w=-1;
	int res = c-'0';
	while((c=getchar())>='0'&&c<='9')res = (res<<3) + (res<<1) + c-'0';
	return res*w;
}
int n,m,k;
int a[405][405],sum[405][405],ans;
signed main(){
	//freopen("rally.in","r",stdin);
	//freopen("rally.out","w",stdout);
	n = re(),m = re(),k = re();
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=m;++j)
			a[i][j] = re(),sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + a[i][j];
        //不懂二维前缀和的人自己手画也是可以推出来的
	for(register int x1=1;x1<=n;++x1)
		for(register int y1=1;y1<=m;++y1)
			for(register int x2=x1;x2<=n;++x2)
				for(register int y2=y1;y2<=m;++y2)
					ans += !((sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1])%k);
	printf("%d",ans);
	return 0;
}
```
~~我才不会告诉你这是考场代码~~

但数据范围逼迫我们去考虑$\Theta(n^2m)$或$\Theta(n^2log_2n)$的做法

我们的教练 ~~did~~ 教育我们：**要由简到繁去思考**

**所以就先来考虑一维的情况：**

$ k  |  \sum_{i=l}^ra_i $ $\Longrightarrow$ $k | sum_r - sum_{l-1}$ $\Longrightarrow$ $ sum_r \equiv sum_{l-1} (mod k)$

即在k的剩余系下来说二前缀和相等

可以通过一个cnt数组来统计每个余数的数量$\Theta(n)$求答案的

**在二维下的做法？**

其实也是很好想到的（尽量去套用一维做法）

* 枚举子矩阵的上下边界i，j

* 使用前缀和压为一行

* 套用$\Theta(n)$方法处理

**总时间复杂度$\Theta(n^2m)$**

___

## $\mathfrak{Code}:$

```cpp
#include <cstdio>
#define int long long 
int n,m,k,a[405][405],sum[405][405],cnt[1000005],mod[1000005],ans;
signed main() {
	scanf("%lld %lld %lld",&n,&m,&k);
	for (int i=1; i<=n; ++i)for (int j=1; j<=m; ++j) scanf("%d",&a[i][j]);
	for (int i=1; i<=n; ++i)for (int j=1; j<=m; ++j)sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
	for(int i=0; i<n; ++i)
		for(int j=i+1; j<=n; ++j) {
			cnt[0]=1;//初始化 
			for(int lie=1; lie<=m; ++lie) {//列 。。。 
				mod[lie] = (sum[j][lie] - sum[i][lie] + k) % k;
				ans += cnt[mod[lie]];
				++cnt[mod[lie]];
			}
			memset(cnt,0,sizeof(cnt));
		}
	printf("%lld\n",ans);
	return 0;
}
```
求过




---

## 作者：k_z_j (赞：4)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long a[1000][1000],sum[1000][1000],ans=0,tot,n,m,k,flag[1100000],b[1110000];
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        scanf("%lld",&a[i][j]);
        sum[i][j]=sum[i][j-1]+a[i][j]+sum[i-1][j]-sum[i-1][j-1];//sum数组存矩阵的和；
    }
    for(int i=0;i<n;i++)//枚举行
    for(int j=i+1;j<=n;j++)//枚举行
    {
        //memset(flag,0,sizeof(flag));//不能用memset，速度太慢，会超时13个点
        flag[0]=1;//因为mod k等于0说明它自己就能组成一个矩阵mod k等于0；所以一开始赋值为1
        for(int t=1;t<=m;t++)//枚举列
        {
            b[t]=(sum[i][t]-sum[j][t])%k;
            if(b[t]<0) b[t]+=k;//可能小于0，所以要加k变为正数
            ans+=flag[b[t]];//关键地方，前面算出有多少mod k余吧b[t]，当前 b[t]-之前mod k余b[t]的可以得到一个mod k余0的矩阵；
            flag[b[t]]++;//因为此时多了一个上面得出来的；
        }
        for(int t=1;t<=m;t++)
        flag[b[t]]=0;//清空flag数组
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：灵乌路空 (赞：3)

# 知识点: 暴力，哈希表

[原题面](https://www.luogu.com.cn/problem/P3941)

[可能更好的阅读体验](https://www.cnblogs.com/luckyblock/p/13886255.html)

扯

一次原题大战的 T2，没看见 $k\le 10^6$ 就上了哈希 = =  
幸好单哈希没被卡（


---

## 题意简述

>给定一 $n\times m$ 的矩阵，格子 $(i,j)$ 内有正整数 $a_{i,j}$。  
>给定参数 $k$，求有多少个子矩阵的和是 $k$ 的倍数。  
>$1\le n,m\le 400$，$1\le a_{i,j}<k\le 10^6$。  
>1S，256MB。

---

## 分析题意

以下讨论均在 $\pmod k$ 下展开。  
子矩阵的和是 $k$ 的倍数，等价于子矩阵的和 $\bmod\ k = 0$。  

先考虑一维的情况（本题 $m=0$ 的 subtask）：  
>给定序列 和 参数 $k$，求多少个子区间的和 $\bmod \ k = 0$。  

每一个子区间都可以通过两个前缀相减得到。  
则每个 $\bmod\ k = 0$ 的子区间，都与两个差为 $\bmod\ k=0$ 的前缀和 **一一对应**。  
问题等价于统计差为 $0$ 的前缀和的个数，在枚举前缀的同时维护一个桶，记录和不同的前缀的个数即可。  
大概是这样的感觉：
```cpp
cnt[0] = 1;
for (int i = 1; i <= n; ++ i) {
  ans += cnt[sum[i]];
  cnt[sum[i]] ++;
}
```
模数较大时可使用哈希表，期望复杂度 $O(n)$。

再回到本题二维的情况。  
发现数据范围较小，不妨 $O(n^2)$ 暴力枚举子矩阵一条边的左右端点 $l,r$。  
将所有一条边为 $l,r$，另一条边 **长度为 1** 的子矩阵的和看成一个数，即有下图形式：  

![mspaint 真 nm 难用](https://pic.downk.cc/item/5f97e8591cd1bbb86b239636.png)

在确定了一条边的限制下，问题转化为上面的一维形式，直接套用上面的算法即可。  
总复杂度 $O(n^3)$ 级别。

---

## 代码实现

使用了 hash 表进行实现，可以处理更大的模数。  
代码中枚举的是子矩阵的上边。  

```cpp
//知识点：暴力，哈希 
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#define LL long long
const int kMaxn = 400 + 10;
const LL kMod = 998244353;
const int kBase = 2333;
//=============================================================
int n, m, k, a[kMaxn][kMaxn];
int sum[kMaxn][kMaxn], tmp[kMaxn];
LL ans;
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Chkmax(int &fir_, int sec_) {
  if (sec_ > fir_) fir_ = sec_;
}
void Chkmin(int &fir_, int sec_) {
  if (sec_ < fir_) fir_ = sec_;
}
namespace Hash {
  int e_num, head[kBase + 10], val[kMaxn];
  int cnt[kMaxn], ne[kMaxn];
  void Init() {
    e_num = 0;
    memset(head, 0, sizeof (head));
  }
  int Query(int val_) {
    int pos = val_ % kBase + 1;
    for (int i = head[pos]; i; i = ne[i]) {
      if (val[i] == val_) return cnt[i];
    }
    return 0;
  }
  void Insert(int val_) {
    int pos = val_ % kBase + 1;
    for (int i = head[pos]; i; i = ne[i]) {
      if (val[i] == val_) {
        cnt[i] ++; 
        return ;
      }
    }
    val[++ e_num] = val_;
    cnt[e_num] = 1;
    ne[e_num] = head[pos];
    head[pos] = e_num;
  }
}
//=============================================================
int main() {
  n = read(), m = read(), k = read();
  for (int i = 1; i <= n; ++ i) {
    for (int j = 1; j <= m; ++ j) {
      a[i][j] = read() % k;
      sum[i][j] = (sum[i][j - 1] + a[i][j]) % k;
    }
  }
  for (int l = 1; l <= m; ++ l) {
    for (int r = l; r <= m; ++ r) {
      Hash::Init();
      Hash::Insert(0);
      for (int i = 1; i <= n; ++ i) {
        tmp[i] = (tmp[i - 1] + sum[i][r] - sum[i][l - 1] + k) % k;
        ans += Hash::Query(tmp[i]);
        Hash::Insert(tmp[i]);
      }
    }
  }
  printf("%lld\n", ans);
  return 0;
}
```

---

## 作者：楠枫 (赞：1)

## 题解

[更好的阅读体验](https://www.cnblogs.com/nanfeng-blog/p/14950509.html)

观察数据范围，可以 $\mathcal O(n^2m^2)$ 暴力计算，而加上特殊性质，则可以骗到 $75pts$

正解：

我们发现，在一维情况下，$\mod k$ 相同的前缀和相减，一定是 $k$ 的倍数。那么我们就可以统计一个不同 $\mod k$ 的值出现了几次，$\mathcal O(n)$ 求解。

扩展到二维，做法是将一段连续的行合并成一行，ppt 上叫压行。再按一行的做法做，复杂度 $\mathcal O(n^2m)$

**注意**：记得开 long long，同时记录余数的数组清空时不要用 $memset$

$AC\kern 0.5em CODE:$
```cpp
#include<bits/stdc++.h>
#define ri register signed
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    #define gc() p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++
    template<typename T>inline void read(T &x) {
        ri f=1;x=0;char ch=gc();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=gc();}
        x*=f;
    }
}
using IO::read;
namespace nanfeng{
    #define cmax(x,y) ((x)>(y)?(x):(y))
    #define cmin(x,y) ((x)>(y)?(y):(x))
    #define FI FILE *IN
    #define FO FILE *OUT
    typedef long long ll;
    static const int N=405,K=1e6+7;
    int cnt[K],b[N],sum[N][N],n,m,k;
    ll ans;
    inline int main() {
        // FI=freopen("nanfeng.in","r",stdin);
        // FO=freopen("nanfeng.out","w",stdout);
        read(n),read(m),read(k);
        for (ri i(1);i<=n;p(i)) {
            for (ri j(1),w;j<=m;p(j)) 
                read(w),sum[i][j]=(sum[i-1][j]+sum[i][j-1]+w+k-sum[i-1][j-1])%k;
        }
        for (ri i(0);i<n;p(i)) {
            for (ri j(i+1);j<=n;p(j)) {
                cnt[0]=1;
                for (ri l(1);l<=m;p(l)) ans+=cnt[b[l]=(sum[j][l]+k-sum[i][l])%k]++;
                for (ri l(1);l<=m;p(l)) cnt[b[l]]=0;
            }
        }
        printf("%lld\n",ans);
        return 0;
    }
}
int main() {return nanfeng::main();}
```

---

## 作者：Hanzire76 (赞：1)

## 思路

### 60分做法：暴力+前缀和

使用前缀和存储 `sum[i][j]` 存储`(i,j)`点作为右下角`(1,1)`作左上角的矩阵和。可以枚举每个矩阵大小。复杂度$O(n^4)$

### 100分做法：找规律+小暴力

先看样例：



|  1   |  2   |  1   |
| :--: | :--: | :--: |
|  2   |  1   |  2   |



我们可以尝试枚举行之间的分割线，`(i,j)`代i为上界，以j为下界的矩阵。对这样一个矩阵进行压行处理。就是把每一列的数字都加起来，得到：



|  3   |  3   |  3   |
| :--: | :--: | :--: |


这样一个序列。我们用一个数组`f`存储它的前缀和，再用`mod`数组存储它模k的数。我们设`f[i],f[j]`，且`i<j`。假如，`mod[f[i]]==mod[f[j]]`那么就代表区间`(i,j)`的和%k==0。因为`mod[f[i]]`区间`(i,j)`没有对余数做出改变。



所以，我们应该使用一个桶，`cnt[i]`代表此前模k=i的前缀和个数，再出现一个模k=i的前缀和时，我们先在答案加上`cnt[i]`再`cnt[i]++`。时间复杂度：$O(n^3)$



## 代码

```c++
#include "iostream"
#include "cstdio"
#include "algorithm"
#define ll long long
using namespace std;

const int N = 405;
const int M = 1000005;
int n, m, k, a[N][N];
ll ans, sum[N][N], mod[M], cnt[M], f[N];

inline int get()
{
    int res = 0, sign = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            sign = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        res = res * 10 + c - '0';
        c = getchar();
    }
    return res * sign;
}

int main(int argc, char const *argv[])
{
    n = get(), m = get(), k = get();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            a[i][j] = get();
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];
        }
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j <= n; j++)
        {
            cnt[0] = 1;
            for (int p = 1; p <= m; p++)
            {
                f[p] = (sum[j][p] - sum[i][p]) % k;
                ans += cnt[f[p]];
                cnt[f[p]]++;
            }
            for (int p = 1; p <= m; p++)
                cnt[f[p]] = 0;
        }
    cout << ans << endl;
    return 0;
}


```



---

## 作者：_segmenttree (赞：0)

## 思路

开题一眼 $\Theta(n^2m^2)$ 二维前缀和暴力，大家应该都会。但我们要想拿到满分需要 $\Theta(n^2m)$ 或 $\Theta(n^2log_2n)$ 的做法。

我们对于矩阵不熟悉，但对于序列熟悉啊，先考虑只有一行的做法。看模数的数据范围和整倍数我们应该自然地想到记录每个数模后的余数。计算的话就每次加它前面模完也是这个值的个数。

接下来就该把我们的算法扩展到矩阵了。我们可以枚举矩阵的上下边界，把一列加起来看成一个数就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,k,a[410][410],mo[1000010],s[410][410],z[410],ans; 
signed main() {
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
		    scanf("%lld",&a[i][j]);
	for(int j=1;j<=m;j++)
	    for(int i=1;i<=n;i++) {
	    	s[i][j]=s[i-1][j]+a[i][j]; 
		}
	for(int u=1;u<=n;u++)
	   for(int d=u;d<=n;d++) {
	   	    mo[0]=0;
	   	    int z=0;
	   	    for(int j=1;j<=m;j++) {
	   	    	z+=s[d][j]-s[u-1][j];
	   	    	mo[z%k]=0; 
			}
			z=0;
			for(int j=1;j<=m;j++) {
	   	    	z+=s[d][j]-s[u-1][j];
	   	    	ans+=mo[z%k];
				mo[z%k]++;
				if(z%k==0) ans++;
			}
	   }
	cout<<ans;
	return 0;
}
```

---

## 作者：zero4338 (赞：0)

## Solution
首先考虑序列的情况 , 我们枚举每一个位置作为右端点 , 那么可以与它匹配的左端点和它的前缀和一定相等 ( 模 $n$ 意义下 ) , 那么我们只需要记录每个数已经出现了几次 , 扫描时更新答案即可 .  
把这个作法推广到矩形上 , 只需要把若干行考虑成一行 , 枚举上端点和下端点 , 把它们之间的所有行看成一行即可 .  
注意每次记录每个数出现几次的数组可以重新利用 , 清空时重新枚举当前行即可 .  
~~写hash会全部mle~~  
复杂度 $O(n^3)$
## Code
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
inline int read()
{
    int ret=0;char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+(c^48),c=getchar();
    return ret;
}
const int maxn=405;
const int maxm=1e6;
int n,m,k;
int qmod(int x){return x>=k?x-k:x;}
ll ans;
int a[maxn][maxn];
int sum[maxn][maxn];
inline int query(int x1,int y1,int x2,int y2){return ((sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1])%k+k)%k;}
int f[maxm];
int main()
{
    n=read();m=read();k=read();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)a[i][j]=qmod(read());
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)sum[i][j]=qmod(sum[i][j-1]+a[i][j]);
    for(int j=1;j<=m;j++)
        for(int i=1;i<=n;i++)sum[i][j]=qmod(sum[i][j]+sum[i-1][j]);
    for(int x1=1;x1<=n;x1++)
        for(int x2=x1;x2<=n;x2++)
        {
            for(int j=1;j<=m;j++)
            {
                int now=query(x1,1,x2,j);
                if(!now)ans++;
                ans+=f[now];
                f[now]++;
            }
            for(int j=1;j<=m;j++)f[query(x1,1,x2,j)]--;
        }
    printf("%lld",ans);
    return 0;
}

```


---

## 作者：洛桃 (赞：0)


[题目传送门](https://www.luogu.com.cn/problem/P3941)

## 解题思路

利用二维前缀和求解。首先可以预处理出二维前缀和，直接枚举每一种大小的矩阵可以打出 $O(n^2m^2)$ 的暴力做法。加上特殊性质的判断可以得到75pts。

正解需要利用压行的技巧，将几行压成一行求解。首先我们对前缀和取模，数组中只保留取模后的值。

先假设所有的矩形左上角的 $y$ 值都为 $1$，枚举首行与末行，以及最右端的列数。

利用cnt数组存储每个取模后的值出现的矩阵个数。有一个结论：如果在枚举中出现两个同余的矩形，那么这两个矩形中间的矩形的模 $k$ 的余数为 $0$，也就符合条件。

看图

![](https://s3.ax1x.com/2020/12/01/DhLSAO.png)

如果设 $s_3$ 为图中最大的矩形，即两个矩形之和，且范围内和的余数为 $x$，而又同时存在 $s_1$ 这个矩形模 $k$ 的余数为 $1$，那么显然 $s_2$ 就是一个符合条件的矩形。

一开始除了 $cnt[0]$要初始化为 $1$，因为这个矩形本身要算进去，其他的都是 $0$。

之后枚举时若出现了一个余数为 $x$ 的矩形，那么它必然与之前所有同样余数的矩形都可以构成一个如 $s_2$ 一样的合法矩形，这时候只要将答案加上之前出现的同余矩形数即可。

不用考虑其他情况，因为除了这 $cnt[x]$ 个矩形，其他情况出现的矩形已经在之前的循环中枚举出来了，这样就可以不重不漏地枚举出每一个合法矩形。

时间复杂度 $O(n^2m)$。
## 代码
```cpp
#include<iostream>
#include<cstdio>
#define ll  long long
using namespace std;
int n,m,a[500][500],k;
ll sum[500][500];
ll cnt[1000010],b[500];
ll ans,s;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	int last=0;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		scanf("%d",&a[i][j]);
		sum[i][j]=(sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]+k)%k;
	}
	for(int i=0;i<n;i++)
	for(int j=i+1;j<=n;j++)
	{
		cnt[0]=1;
		for(int q=1;q<=m;q++)
		{
			b[q]=(sum[j][q]-sum[i][q]+k)%k;
			ans+=cnt[b[q]];
			cnt[b[q]]++;
		}
		for(int q=1;q<=m;q++)cnt[b[q]]=0;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Little09 (赞：0)

一个很显然的做法是求二维前缀和，然后枚举每个子矩形判断，这样的话是 $O(n^2m^2)$ 的。但是这只能拿到 $60$ 分。

那么我们可以考虑，对于两个矩形 $(1,y_1,x_1,y_2)$ 和 $(1,y_1,x_2,y_2)(x_1<x_2)$，若它们内部的和对 $k$ 求余相等，那么就可以找到一组模 $k$ 余 $0$ 的矩形 $(x_1,y_1,x_2,y_2)$。并且对于每个满足要求的矩形，都可以找到这样的两个矩形。

所以先枚举 $y_1$ 和 $y_2$，再从上往下扫，这样就可以做到 $O(n^2m)$。

具体实现的话，是需要用一个桶来记录每个余数的出现次数。然后就可以很方便地维护 $ans$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n,m;
ll k;
const int N=403,K=1000006;
ll a[N][N],s[N][N],ans;
int cnt[K][2];
int main()
{
    cin >> n >> m >> k;
    for (int i=1;i<=n;i++)
    {
    	for (int j=1;j<=m;j++) scanf("%lld",&a[i][j]);
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++) s[i][j]=(a[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1]+k)%k;
	}
	for (int j=1;j<=m;j++)
	{
		for (int p=j;p<=m;p++)
		{
			cnt[0][0]=1,cnt[0][1]=j*m+p;
			for (int i=1;i<=n;i++)
			{
				ll sum=(s[i][p]-s[i][j-1]+k*2)%k;
				if (cnt[sum][1]!=j*m+p) cnt[sum][1]=j*m+p,cnt[sum][0]=0;
				ans+=cnt[sum][0];
				cnt[sum][0]++;
			}
		}
	}
	cout << ans;
	return 0;
}

```


---

## 作者：like1 (赞：0)

题意：给定一个n*m的矩阵，问其有多少个子矩阵的和%k=0.

数据范围：
35%  n,m<=16;
55%  n,m<=80;
100% n,m<=400;

这道题我们首先处理出以(i,j)为右下端点的子矩阵的和
```
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
```

之后55分的解法应该很好想，就是枚举每个子矩阵的左上和右下两个端点并计算它的值是否合法，那么如何计算子矩阵的值呢

| 1,1 |1,2  | 1,3   | 1,4 | 1,5 |
| :----------- | :----------- | :----------- | :----------- | :----------- |
| 2,1 | 2,2, |2,3  | 2,4 |2,5  |
| 3,1 |3,2  |3,3  |3,4  |3,5  |
|  4,1| 4,2 |4,3  |4,4 |4,5  |
|  5,1|  5,2|  5,3| 5,4 | 5,5 |

不难发现对于一个矩阵假设为（2,3,4,4），它的值为矩阵（1,1,4,4）-矩阵（1,1,4,2）-矩阵（1,1,1,4）+矩阵（1,1,1,2）； 即对于任意矩阵（i,j,k,h）=(1,1,k,h)-(1,1,i-1,h)-(1,1,k,j-1)+(1,1,i-1,j-1);

```
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
for(int K=i;K<=n;K++)
for(int h=j;h<=m;h++)
if((sum[K][h]-sum[K][j-1]-sum[i-1][h]+sum[i-1][j-1])%k==0) ans++;
```

对于100%的数据，我们再仔细分析可以得到一个结论：如果子矩阵在%k下的同一个余数出现2次，那么它们之间一定存在一个和为k的倍数的矩阵； 因为假设出现余数2两次，因为%k，所以(2+k*x)%k=2，所以一定存在一个和为k×x的子矩阵

```
for(int i=0;i<n;i++)
for(int j=i+1;j<=n;j++)
{
    cnt[0]=1;
    for(int h=1;h<=m;h++)
    {
    	b[h]=(sum[j][h]-sum[i][h]+k)%k;
    	ans+=cnt[b[h]];
    	cnt[b[h]]++;
	}
	for(int h=1;h<=m;h++) cnt[b[h]]=0;
}
```

最后祝大家CSP2019rp++,score++;




---


# 三步必杀

## 题目背景

### （三）旧都

离开狭窄的洞穴，眼前豁然开朗。

天空飘着不寻常的雪花。

一反之前的幽闭，现在面对的，是繁华的街市，可以听见酒碗碰撞的声音。

这是由被人们厌恶的鬼族和其他妖怪们组成的小社会，一片其乐融融的景象。

诶，不远处突然出现了一些密密麻麻的小点，好像大颗粒扬尘一样。

离得近了点，终于看清楚了。

长着角的鬼们聚在一起，围观着另一只鬼的表演。

那”扬尘”，其实都是弹幕。

勇仪的招数之一，三步之内，所到之处弹幕云集，几乎没有生存可能。

为了强化这一技能，勇仪将对着一排柱子进行攻击。

旧地狱的柱子虽然无比坚固，但保险起见还是先要了解一下这样一套攻击对柱子有多少损伤，顺带也能检验练习的效果。

勇仪决定和其它鬼们商量商量...

“我知道妖怪之山的河童一族有一种叫做计算机的神奇道具，说不定可以借来用用”，萃香说道。

于是旧地狱的鬼族就决定请河城荷取来帮忙了。

“要记录【所有柱子的损伤程度】吗”，荷取问道。

经过进一步的询问，荷取发现他们仅仅需要【所有攻击都完成后】柱子的损伤程度。

任务了解地差不多了，荷取将其中的重要部分提取了出来，记录在了她的工作笔记本上：

(记录的内容见题目描述)

那么实验就这样开始了。

在惊天动地的碰撞声中，勇仪每完成一轮攻击，荷取都忠实地记录下对每根柱子产生的伤害。而此时勇仪就在旁边等待着记录完成，然后再进行下一轮的攻击。

地面上，天色渐晚。

“不想在这里留到深夜啊，不然就回不了家了”，荷取这样想着，手中依然在重复地向计算机中输入新产生的信息。

“真的必须一次一次地记录下每轮攻击对每个柱子产生的伤害吗？有没有更高效的方法？”这一念头在荷取的心中闪过...

（后续剧情在题解中，接下来请看T3）


## 题目描述

### 问题摘要：

$N$个柱子排成一排，一开始每个柱子损伤度为0。

接下来勇仪会进行$M$次攻击，每次攻击可以用4个参数$l$,$r$,$s$,$e$来描述：

表示这次攻击作用范围为第$l$个到第$r$个之间所有的柱子(包含$l$,$r$)，对第一个柱子的伤害为$s$，对最后一个柱子的伤害为$e$。

攻击产生的伤害值是一个等差数列。若$l=1$,$r=5$,$s=2$,$e=10$，则对第1~5个柱子分别产生2,4,6,8,10的伤害。

鬼族们需要的是所有攻击完成之后每个柱子的损伤度。

## 说明/提示

### 样例解释：

样例1：

第一次攻击产生的伤害:2 4 6 8 10

第二次攻击产生的伤害:0 1 1 1 0

所有攻击结束后每个柱子的损伤程度:2 5 7 9 10。

输出异或和与最大值，就是3 10。

样例2：

没有打到第六根柱子，答案不变

### 数据范围：

本题满分为100分，下面是4个子任务。(x/y)表示(得分/测试点数量)

妖精级(18/3):$1\leqslant n$,$m\leqslant1000$。这种工作即使像妖精一样玩玩闹闹也能完成吧？

河童级(10/1):$s=e$,这可以代替我工作吗？

天狗级(20/4):$1\leqslant n\leqslant10^5$,$1\leqslant m\leqslant10^5$。小打小闹不再可行了呢。

鬼神级(52/2):没有特殊限制。要真正开始思考了。

以上四部分数据不相交。

对于全部的数据:$1\leqslant n\leqslant10^7$,$1\leqslant m\leqslant3\times 10^5$，$1\leqslant l<r\leqslant n$.

所有输入输出数据以及柱子受损伤程度始终在$[0,9\times 10^{18}]$范围内。

### 提示：

由于种种原因，时间限制可能会比较紧，C++选手请不要使用cin读入数据。


by orangebird

## 样例 #1

### 输入

```
5 2
1 5 2 10
2 4 1 1
```

### 输出

```
3 10```

## 样例 #2

### 输入

```
6 2
1 5 2 10
2 4 1 1```

### 输出

```
3 10```

# 题解

## 作者：orangebird (赞：114)

我们来分数据范围看看做法:

首先是1<=n,m<=1000

暴力模拟即可，不必多说。

然后是s=e。这意味着题目变成多次区间加，然后询问。那么利用差分即可解决。

l.......... r+1 

s..........-s

这时求前缀和，相当于给[l,r]中的每个数字都增加了s。

接下来看看正解，顺便也解决1<=n<=1e5,1<=m<=1e5的情况。

因为是等差数列，所以我们还是利用差分。

经过一次差分，我们发现对于一个l,r,s,e操作,先求出公差d,然后可以变成这样:

l l+1 l+2.......r r+1

s  d   d .......d -s-(r-l)*d

就变成了两次单点加和一次区间加了。那么怎么办呢？

可以用树状数组/线段树来维护区间,每次操作O(logn),这就是1e5的做法了。

那么正解呢？再差分一次就好(应该没人想到这一步还想不到正解吧)。

l l+1  ..........      r+1          r+2

s d-s              -(r-l+1)*d-s   s+(r-l)*d

最后求两次前缀和就能获得原数组了。

这样每次操作是O(1)的,总复杂度O(n+m),顺利通过。


### 后续剧情

### （四）三步必杀

荷取不断地思考着.... "让我看看，每次产生的伤害都是一个等差数列？"

"等差数列嘛.....似乎看不出什么玄机呢。"

"但是，如果不是等差数列，而是对每一个柱子产生的伤害相同，情况可能会不一样。"

"如果对每个柱子产生的伤害相同，我只要记录下伤害开始和结束的位置就可以了"
"具体怎么样呢..."

"嗯，把柱子从左到右编号 1,2,3...,伤害开始的地方记做 L，结束的地方记做 R。
在 L 这里记一个 1，就表示从现在开始，往右边的柱子都受到了 1 的伤害。

但是这么做的话，在 R 右侧的柱子受到的伤害就会凭空多出 1。

那么，只要在 R 右边的那个柱子标记一个-1，就可以抵消掉了。

而且这样的标记是独立的，可以累加! "

"这样的话，每次攻击我只需要在一个临时序列 S 上改两个数字，等到最后从左到右求
一遍和就可以得到结果了

这个 S 序列通过一次记录两个数，得到了每次伤害对其之后柱子损伤程度的影响
由于用到做差与求和，那我就先把这个 S 叫差分序列，从左到右求和后的序列叫前缀
和序列吧。

嗯，很不错呢，很不错呢。"

荷取的眼睛闪着光芒。

"可真正的伤害不是固定的，是一个等差数列啊，那怎么办。" 巨响不断，荷取有些失落，但依然在敲着键盘。

围观的鬼们显得有些疲惫了，为了让荷取记录下这些伤害信息，每两轮攻击之间都要等好久。

但是，没有一只鬼在抱怨。

"等等，等差？"

...

...

... 
"这不就是固定了伤害的增量?" 荷取仿佛看到了希望。

"那样的话，之前应对固定伤害的办法或许就有用了。"

"只要用另一个 A 序列记录下伤害的增量对其之后伤害的影响就可以了。

对 A 序列求前缀和，就可以得到刚才的那个 S 序列。

那么，这个 A 序列可以说是差分序列的差分序列。"

"对了，除了考虑增量还要考虑初始值，那么用 B 序列记录初始伤害和结束伤害，最后
加进 S 序列就行。"

"这个问题好像解决了?"

... 妖怪之山，山脚下。

荷取和同伴正在瀑布边玩耍。

虽然已经入夜，但距离深夜还早，荷取的愿望实现了。

啊不过，时间真的不早了，我们的地底旅行还要继续。

咦，这个方法，不正好可以用来解决山女的连环病原体难题吗？

真是意外的收获呢，回去的时候记得告诉山女~ 那么,接下来是，地灵殿?



---

## 作者：Kelin (赞：70)

# 题意
给区间加上一个等差数列，最后单点查询。

# 题解

设 $a$ 是原数组， $b$ 是一阶差分数组， $c$ 是二阶差分数组。

考虑一次在 $[L,R]$ 内加上一个首项是 $s$ ，公差是 $d$ ，末项 $t=s+(R-L)d$ 的等差数列对 $a$ 数组的影响：

$a'_x=a_x+s+(x-L)d,\ x\in[L,R]$

考虑 $a$ 数组的变化对 $b$ 数组的影响 $(b_i=a_i-a_{i-1})$ ：

$b'_L=(a_L+s)-a_{L-1}=b_L+s$

$b'_x=[a_x+(x-L)d]-[a_{x-1}+(x-1-L)d]=b_x+d, \ (x\in[L+1,R])$

$b'_{R+1}=a_{R+1}-(a_R+t)=b_{R+1}-t$

考虑 $b$ 数组的变化对 $c$ 数组的影响 $(c_i=b_i-b_{i-1})$ ：

$c'_L=(b_L+s)-b_{L-1}=c_L+s$

$c'_{L+1}=(b_{L+1}+d)-(b_L+s)=c_L+d-s$

$c'_x=(b_x+d)-(b_{x-1}+d)=c_x,\ (x\in[L+2,R])$

$c'_{R+1}=(b_{R+1}-t)-(b_R+d)=c_{R+1}-d-t$

$c'_{R+2}=b_{R+2}-(b_{R+1}-t)=c_{R+2}+t$

我们发现每次修改只会改变 $c$ 数组 $4$ 个位置的值。

这样我们就可以只维护 $c$ 数组，最后求两遍前缀和就可以得到 $a$ 数组了。

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = int64_t;
const int N = 1e7 + 5;
int n, m;
ll c[N];
int main() {
    scanf("%d%d", &n, &m);
    ll a = 0, b = 0, s, t, d, Max = 0, Xor = 0;
    for (int L, R; m--;) {
        scanf("%d%d%lld%lld", &L, &R, &s, &t);
        d = (t - s) / (R - L);
        c[L] += s, c[L + 1] += d - s;
        c[R + 1] -= d + t, c[R + 2] += t;
    }
    for (int i = 1; i <= n; ++i)
        Max = max(Max, a += (b += c[i])), Xor ^= a;
    printf("%lld %lld", Xor, Max);
    return 0;
}
```

话说这道题在出出来之前不是在 $WC2018$ 冬眠营里被 $\rm \_rqy$ 秒了吗?

我记得当时我也在场来着，当时讨论了一个树状数组的在线算法，貌似在这里会 $\rm TLE$ 。

---

## 作者：孑思 (赞：27)

此代码是
## 基于前面几位dalao的解析下
~~的优化~~（只是让它看起来更整洁一点）

“没有什么等差数列是差分一次解决不了的，如果有，那就再差分一次”

```cpp
#include<bits/stdc++.h>
#define N 10000010
using namespace std;
int n,m,l,r,s,e,d;
long long a[N],b[N],c[N],maxx,yh;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&l,&r,&s,&e);//不用读入优化，本蒟蒻卡着456ms过的
		d=(e-s)/(r-l);//公差
		c[l]=c[l]+s;//K大佬上面写了
		c[l+1]=c[l+1]+d-s;
		c[r+1]=c[r+1]-d-e;
		c[r+2]=c[r+2]+e;
	}
	for(int i=1;i<=n;i++){
		b[i]=b[i-1]+c[i];//c[i]=b[i]-b[i-1]
		a[i]=a[i-1]+b[i];//b[i]=a[i]-a[i-1]
		if(a[i]>maxx)maxx=a[i];取最大值，朴素点，别用max，那个费时
		yh^=a[i];//异或
	}
	printf("%lld %lld",yh,maxx);
	return 0;
}
```

---

## 作者：tianxuan (赞：16)

因为这个题太有意思了，所以我来写个题解

看标签 “线段树”、“树状数组”

这些你一个也用不到

只需要差分就行了

为什么？

我们来看

首先，我们有了树状数组模板2（P3368）的启发

我们遇到区间加的问题，我们可以将这些相同的差距不去考虑

我们只需要看他们之间的差就行了

知道每个的差距，我们就可以看到每个的数值

那问题来了，面对这种 **提高+/省选-** 的奆题

像我一样的蒟蒻该如何思考

很简单

因为是等差数列

所以我们知道加起来的量就可以用一次差分

但因为它是加起来的，各个间又有了差距

所以我们就可以用两次差分

接下来是重点

怎么运用两次差分解决问题

我们都知道对于[l,r]区间加上k我们对差分数组的操作是
$$
cha[l]+=k,cha[r+1]-=k
$$
那我们就举个例子，来找出二次差分的规律

设一个数列的一段区间加上了一段等差数列

形如：

> 0  0  a  a+b  a+2b ……a+nb 0 0

接下来做一次差分

> 0 0 a b b ……b -a-nb 0

再来一下子

> 0 0 a b-a 0……0 -a-nb-b a+nb

得到了结论

对于每次操作l,r,s,e ~~(一开始这里写错了,改正后还没过审)~~
$$
a=s;b=(e-s)/(r-l)
$$
简单了吧

我们只要做4次操作
$$
cha[l]+=s;cha[l+1]+=(e-s)/(r-l)-s
$$
$$
cha[r+1]-=(e-s)/(r-l)+e;cha[r+2]+=e
$$
然后我们用O(2*n)便可做出求出来了
代码如下

```cpp
#include <cstdio>
#define ll long long

using namespace std;

ll cha[10000005]={0},last=0,ands=0,ans=0,maxn=-1;
int n,m;

ll read(){//快读
	short f=1;ll x;char ch;
	while(ch=getchar(),ch<'0'||ch>'9')
		if(ch=='-') f=-1;
	x=ch-'0';
	while(ch=getchar(),ch>='0'&&ch<='9')
		x=x*10+ch-'0';
	return x*f;
}

int main(){
	
	n=read();m=read();
	
	while(m--){
		ll l=read(),r=read(),s=read(),e=read();
		ll ch=(e-s)/(r-l);//计算公差
		cha[l]+=s;
		cha[l+1]+=ch-s;
		cha[r+1]-=ch+e;
		cha[r+2]+=e;
	}
	for(int i=1;i<=n;i++){
		last+=cha[i];//得出一次差分数组的第i项
		ands+=last;//得出伤害数组的第i项
		if(ans) ans^=ands;//异或
		else ans=ands;
		if(ands>maxn) maxn=ands;//求最大值
	}
	printf("%lld %lld",ans,maxn);
	return 0;
}
```

最后祝各位大佬AK NOIp

如若有任何问题，可以私信联系我

---

## 作者：Kirisame_Marisa_ (赞：11)

传送门:[P4231](https://www.luogu.org/problemnew/show/P4231)

差分好题。

由于增加的是等差数列，所以可求相邻两项的差。将差设为$d$，则$d=\frac{e-s}{r-l}$。因为题目保证$l<r$，所以不用担心分母为$0$导致浮点错误。

接下来设原数组为$a$，差分数组为$b$。以$l=2,r=5,s=2,e=17$为例，数组$a,b$的变化如下：  
```
i  1  2  3  4  5  6   7  ...
a  0  2  7  12 17 0   0  ...
b  0  2  5  5  5  -17 0  ...
```
可以发现，每次修改转化成了$2$次单点加和$1$次区间加，可以用线段树维护，时间复杂度$O(n\log n+m\log n)$。

其实到这里已经距离正解很近了。通过差分的特性，我们可以发现：$1$单点修改进行差分会变成$2$次单点修改，而$1$次区间修改会被缩减成$1$次单点修改。尝试对$b$差分，差分数组记为$c$，
```
i  1  2  3  4  5  6   7  ...
a  0  2  7  12 17 0   0  ...
b  0  2  5  5  5  -17 0  ...
c  0  2  3  0  0  -22 17 ...
```
可以发现，原先的$2$次单点加和$1$次区间加，转化为了$4$次单点加！  
那么如何通过$c$来求出$a_i$呢？  
通过差分的定义，可以知道$a_x=\sum_{i=1}^{x}b_i$。又因为$c$是$b$的差分数组，所以$a_x=\sum_{i=1}^{x}\sum_{j=1}^{i}c_i$。  
容易发现$\sum_{j=1}^{i}c_i$可以用前缀和优化掉(记为$s_i$)。问题转化为求$\sum_{i=1}^{x}s_i$，易得$a_i=a_{i-1}+s_i$，于是我们就可以愉快地在$O(n)$时间内求出变更完的$a$数组！

现在探究一下修改操作的一般情况，对于每次修改操作，都有如下变化：
```
i  l-1 l  l+1 l+2  ... r-1 r  r+1  r+2 ...
a  0   s  s+d s+2d ... e-d e  0    0   ...
b  0   s  d   d    ... d   d  -e   0   ...
c  0   s  d-s 0    ... 0   0  -e-d e   ...
```
所以对于每次修改$(l,r,s,e)$，我们只需要$c_l+=s,\ c_{l+1}+= (d-s)\ c_{r+1}+=(-e-d),c_{r+2}+=e$即可。

最后统计答案时对数组$c$参照前文过程$O(n)$扫一遍即可。

总时间复杂度：$O(n+m)$。  
注意值域$[0,9\times10^{18}]$要开`long long`。  

Code:~~(我知道有的人看这么久其实只想看这个)~~
```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long fi()
{
    register long long x=0;register char ch;
    while(!isdigit(ch=getchar()));x=ch-48;
    while(isdigit(ch=getchar()))x=x*10+ch-48;
    return x;
}
long long n,m,l,r,s,e,d;
long long b[10000005];
int main()
{
    n=fi();m=fi();
    while(m--)
    {
        l=fi();r=fi();s=fi();e=fi();
        d=(e-s)/(r-l);
        b[l]+=s;
        b[l+1]+=(d-s);
        b[r+1]+=(-e-d);
        b[r+2]+=e;
    }
    register long long ans1=0,ans2=0,tmp=0;
    for(register int i=1;i<=n;++i)b[i]+=b[i-1];
    for(register int i=1;i<=n;++i)
    {
        tmp+=b[i];
        ans1^=tmp;
        ans2=max(ans2,tmp);
    }
    cout<<ans1<<" "<<ans2;
    return 0;
}
```

---

## 作者：0凌0 (赞：7)

### 这样好的 _线段树_ 题，居然没有一篇关于线段树的题解？  
(事先声明一下，本蒟蒻用线段树AC不了这题，本题解只是讲一下线段树的思路)  
先看一道很像的题：[P1438 无聊的数列](https://www.luogu.org/problem/P1438)  
很明显，都是加一个等差数列，但它们是区间修改，单点询问，怎么转化为区间修改，区间询问呢？  
可以建立一个sum数组记录差分，则有：损伤度[i]=sum[1]+sum[2]+...+sum[i]  
显然，我们已经将这题转化为区间修改，区间询问，可以用线段树了：  
用差分修改区间，加法标记用**lazytag**，一道线段树模板题！  
上代码(再次声明线段树代码不能AC)：  
```cpp
#include<cstdio>
typedef long long ll;
ll n,m,add[40000005],l,r,s,e,o,x,y,sum[40000005];
void build(int k,int l,int r)
{
    if(l==r){sum[k]=0;return;}
    int mid=l+r>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    sum[k]=sum[k<<1]+sum[k<<1|1];
}
void Add(int k,int l,int r,int v)
{
    add[k]+=v;
    sum[k]+=(ll)v*(r-l+1);
}
void pushdown(int k,int l,int r,int mid)
{
    if(!add[k])return;
    Add(k<<1,l,mid,add[k]);
    Add(k<<1|1,mid+1,r,add[k]);
    add[k]=0;
}
void modify(int k,int l,int r,int x,int y,int v)
{
    if(x<=l&&y>=r)return Add(k,l,r,v);
    int mid=l+r>>1;
    pushdown(k,l,r,mid);
    if(x<=mid)modify(k<<1,l,mid,x,y,v);
    if(y>mid)modify(k<<1|1,mid+1,r,x,y,v);
    sum[k]=sum[k<<1]+sum[k<<1|1];
}
ll query(int k,int l,int r,int x,int y)
{
    if(x<=l&&y>=r)return sum[k];
    int mid=l+r>>1;
    ll s=0;
    pushdown(k,l,r,mid);
    if(x<=mid)s+=query(k<<1,l,mid,x,y);
    if(y>mid)s+=query(k<<1|1,mid+1,r,x,y);
    return s;
}//上面全是线段树模板
int main()
{
	scanf("%lld%lld",&n,&m);
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld%lld",&l,&r,&s,&e);
        o=(e-s)/(r-l);//计算公差
        modify(1,1,n,l,l,s);//加上首项
        modify(1,1,n,l+1,r,o);//后面分别加上公差
        modify(1,1,n,r+1,r+1,-s-(r-l)*o);//把多余部分减去
    }
    for(int i=1;i<=n;i++)
    {
    	ll now=query(1,1,n,1,i);//now=损伤度[i]
    	x^=now;
    	y=now>y?now:y;
    }
    printf("%lld %lld",x,y);
    return 0;
}
```  
然而，由于线段树的特性，数组不得不开到4 * n，所以愉快的[MLE](https://www.luogu.org/record/23475048)了  
特判变成2 * n还是[不行](https://www.luogu.org/record/23475293)  
甚至吸了氧也[没用](https://www.luogu.org/record/23475303)  
本题正解还是差分数组(反正本蒟蒻用线段树不行)，但线段树的思路也很实用，可以用来AC很多类似的题目  
~~管理大大求过~~

---

## 作者：Hzxleo4 (赞：6)

```
我也是差分一次， 不过复杂度是O（n + m）的
l -> r 加 等差数列
我们可以在 l 处 记下 首项和公差
在 r+1 处 记下 末项 和 公差的相反数
用链表存下来（实测vector超时）
然后扫描每一个柱子
sum记录当前柱子比前一个柱子多多少（不考虑首项末项）
如果它是首项或末项
就加上或减去相应的值（本身值和公差值）
详见代码吧
坑点：数据范围。。。
```
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define N 10000005
#define LL long long
using namespace std;
struct node{
    LL s, v;
    int n;
}d[N];
LL a[N];
int h[N], cnt;
void cr(int i, LL s, LL v){
    d[++cnt].s = s; d[cnt].v = v; d[cnt].n= h[i]; h[i] = cnt;
}
int main(){
    int i, j, n, m, l, r;
    scanf("%d%d", &n, &m);
    LL s, e, dd, sum = 0, maxn = 0;
    while(m--){
        scanf("%d%d%lld%lld", &l, &r, &s, &e);
        dd = (e - s) / (r - l);
        cr(l, s, dd);
        cr(r + 1, -e - dd, -dd);
    }
    s = 0;
    for(i = 1; i <= n; i++){
        a[i] = a[i-1] + sum;
        for(j = h[i]; j; j = d[j].n){
            sum += d[j].v;
            a[i] += d[j].s;
        }
        maxn = max(maxn, a[i]);
        s ^= a[i];
        //printf("%lld %lld %lld\n", i, sum, a[i]);
    }
    printf("%lld %lld", s, maxn);
    return 0;
} 
```

---

## 作者：smallfang (赞：4)

# Luogu P4231 题解

我们可以把这道题的差分看成一个两个数组,分别是
c[i]与d[i],c[i]表示加多少,d[i]表示等差序列加多少.
等差序列每次加(e-s)/(r-l)


我们来用样例模拟一下:

```
5 2
1 5 2 10
2 4 1 1
```

输入完第2行后的数组:

```
d数组:0 (10-2)/(5-1) 0 0 0 (-2)
c数组:2 0 0 0 0 (-10)
```

输入完第3行后的数组:

```
d数组:0 2 0 0 0 (-2)
c数组:2 0 1 0 -1 (-10)
```

我们进行从1—n的循环.

用一个sum表示此时的柱子受到的伤害,用g表示下一个数 因 等差序列加g.

就推出了
g=g+d[i];
sum=sum+g+c[i];

然后,这道题就做完了...

放上ac代码:

```cpp
#include <iostream>

using namespace std;

long long n,m,c[10000005],d[10000005];

int main()
{
  scanf("%d%d",&n,&m);
  for(int i=1;i<=m;i++)
  {
    int l,r,s,e;
    scanf("%d%d%d%d",&l,&r,&s,&e);
    int dc=(e-s)/(r-l);
    d[l+1]=d[l+1]+dc;
    d[r+1]=d[r+1]-dc;
    c[l]=c[l]+s;
    c[r+1]=c[r+1]-e;
  }
  long long g=0,sum=0;
  long long ansa=0,ansb=0;
  for(int i=1;i<=n;i++)
  {
    g=g+d[i];
    sum=sum+g+c[i];
    ansb=max(ansb,sum);
    ansa=ansa^sum;
  }
  cout<<ansa<<" "<<ansb;
  return 0;
}

```

---

## 作者：C20212724杨京朝 (赞：3)

差分数组的介绍与实际应用
------------
初识差分：
先介绍一下差分吧，差分数组虽说名字里带“数组”二字，但它其实是一种区间修改和查询的算法，其中修改的复杂度为O(1)，查询的复杂度为O(n)。相较于线段树，差分的实现我认为更加简单（~~其实是不会线段树~~)

详见洛谷日报76期（转载）：[差分数组 and 树上差分](http://dy.163.com/v2/article/detail/DV20RPGK0538071X.html)

------------

模版：
```cpp

    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    #define Max 150
    using namespace std;
    int a[Max], d[Max];
    int p;
    int main() {
        int n;
        scanf("%d" ,&n);
        for (int i = 1; i <= n; ++ i) {
            scanf("%d" ,&a[i]);
            d[i] = a[i] - a[i -1];
        }
        int m;
        scanf("%d" ,&m);
        for (int i = 0; i < m; ++i) {
            int p, l, r;
            scanf("%d %d %d" ,&l ,&r ,&p);
            d[l] += p;
            d[r +1] -= p;
        }
        for (int i = 1; i <= n; ++ i) {
            a[i] = d[i] + a[i -1];
            printf ("%d " ,a[i]);
        }
        return 0;
    }
    ```
-----------\
```cpp
#include <cstdio> 
#define MAXN 10000005//宏定义
#define LL long long
using namespace std;
int n,m,l,r,s,e,f;//先把题目中所需的变量都定义上
LL a[MAXN],b[MAXN],c[MAXN],Max,ans;//Max记录最大值，
int main(){
        scanf("%d %d",&n,&m);//输入
        for(int i = 1;i <= m;i ++){
            scanf("%d %d %d %d",&l,&r,&s,&e);//输入
            f = (e - s) / (r - l);//计算公差
            c[l] = c[l] + s;
            c[l+1] = c[l+1] + f - s;//最核心的三行代码
            c[r+1] = c[r+1] - f - e;
            c[r+2] = c[r+2] + e;
        }
        for(int i = 1;i <= n;i ++){
            b[i] = b[i-1] + c[i];
            a[i] = a[i-1] + b[i];
            if(a[i] > Max) Max = a[i];//a数组为最后伤害，Max为最大值
            ans ^= a[i];//计算异或和
        }
        printf("%lld %lld",ans,Max);//输出
        return 0;
    }
------------
如有雷同，纯属巧合（私信我之后会撤回题解）
```

---

## 作者：Taduro (赞：3)

这题n<=1e7，看上去有点吓人？同时也是很大的提示：使用O(N)甚至更低的数据结构

我们来看一下这题的需求，区间加一个等差数列，一开始就可以想到N log n的 差分+线段树 经典做法。

a[l]~a[r]加上一个首项为x，公比为y的等差数列的做法

设b数组为a数组的差分数列

则：b[l]+=x,b[l]~b[r]+=y.b[r+1]-=(r-l)*y (末项)

我们发现如果用线段树去维护它的话，只是一个区间加，查询操作只有最后一次。

考虑到不用查询，我们就可以放弃线段树，维护a数列的差分数列b的差分数列c

你没有听错！！！因为你根本听不到！！！

反正就是这样，然后把所有操作都变成区间加。

差分数列区间加的方法区间（l,r）加x，c[l]+=x,c[r+1]-=x;

最后查询求一遍前缀和，完了！！！

```
#include<cstdio>
#include<iostream>
#define ll long long
#define re register
#define getchar() (S==T&&(T=(S=BB)+fread(BB,1,1<<20,stdin),S==T)?EOF:*S++)
using namespace std;
char BB[1<<20],*S=BB,*T=BB;
inline ll read(){
    re ll x=0;
    register char ch=getchar();
    while(ch<48) ch=getchar();
    while(ch>47) x=x*10+(ch^48),ch=getchar();
    return x;
}
ll n,m,cf[10000001],s[10000001];
ll a,yh,maxn;
int main(){
	n=read(); m=read();
	while (m--){
		re ll l=read(),r=read(),h=read(),t=read();
		ll d=(t-h)/(r-l);
		cf[l]+=h; cf[l+1]-=h;
		cf[l+1]+=d; cf[r+1]-=d;
		cf[r+1]-=t; cf[r+2]+=t;
	}
	for(re  int i=1;i<=n;++i){
        cf[i+1]+=cf[i],cf[i]+=cf[i-1],yh^=cf[i];
        if(cf[i]>maxn) maxn=cf[i];
    }
	printf("%lld %lld",yh,maxn);
	return 0;
}
```

---

## 作者：jun1lesszZZ (赞：2)

### 二阶差分好题   

**关于差分**：对于区间修改通常用到差分这一方法。  

方法是 建立一个差分数组$a$，也就是原数列后一位减前一位的值$(a[i] = a[i] - a[i - 1])$ 。  

当某一个区间加上一个值$w$之后，该区间的左端点就会比左端点减一的值多$w$，而右端点加一就会比右端点的值少$w$。    

所以对于修改的区间$(l,r)$，$a[l] += w, a[r + 1] -= w$; 时间复杂度为$O(1)$，比数据结构优。     

查询值的时候，只需要将差分数组做一遍前缀和即可。  
原理是 当$a[l]$加上$w$时，做前缀和的时候从l一直到数列最后都会受到加$w$的影响，
因为会影响区间外的值，所以在右端点加$1$处减去$w$，来消除从右端点加一到数列最后的影响。  

时间复杂度$O(n)$，比线段树等数据结构慢很多 
所以一般当只查询最后结果时，用差分这一方法比较优。  

---    

**关于本题**：可以很自然的想到差分这一方法。   
但是区间修改时不是加上或减去同一个值，而是一个等差数列  

怎么办呢？   

考虑对于一个等差数列，它的差分数组很显然都是同一个值  
而对于一个区间，每个点要加的值又是一个等差数列   
所以需要知道 **等差数列的差分数组** 来统计 **区间每个点要加的值 的 差分数组**  

怎样得到等差数列的差分数组$sumcha$呢？(为了方便理解，数组名称使用代码中的变量)  

考虑再进行一次差分，统计$sumcha$的差分数组$chacha$，很显然只需要修改区间左右端点即可  
这是因为 $sumcha$每个值都相同，所以只需要在$chacha$开头加上公差，结尾加一处减去公差，做前缀和就可以得到$sumcha$  

所以对这个数组做$1-n$的前缀和可以得到$sumcha$，这个就是整个数列的差分数组   
然后再对整个序列的差分数组做前缀和，就可以得到每个点修改的值。

例如：对于$0\ 0\ 0\ 0\ 0$这个序列，执行$(1\ 5\ 2\ 10)$这个操作
$chacha[1] += 2, chacha[6] -= 2$  
做前缀和可以得到：$2\ 2\ 2\ 2\ 2$  
这很显然就是$2\ 4\ 6\ 8\ 10$的差分数组   
再对它做前缀和，就可以得到：$2\ 4\ 6\ 8\ 10$ 
也就是每个点要加的值

注意：
- 等差数列的开头不一定是等差数列的公差，比如：$4\ 6\ 8\ 10$   
  所以在统计等差数列的差分数组时不能仅仅将差分数组的左右断点修改,
  还要在左端点加上开头的数与公差的差，在右端点加一处消除影响。 
- 因为做了多遍差分，所以记得多次消除影响，比如说$sumcha$也是一个差分数组，对它也需要进行消除影响
- 记得开$long\ long$   
  
代码：  
```cpp
#include <cstdio>
#include <cctype>

typedef long long ll;
const int _ = 10000001;
ll sum_ans[_], cha_cha[_], sum_cha[_];

inline ll max(ll a, ll b) { return a > b ? a : b; }
inline ll read() {
    ll s = 1, w = 0; char ch = getchar();
    for(; ! isdigit(ch); ch = getchar()) if(ch == '-') s = -1;
    for(; isdigit(ch); ch = getchar()) w = w * 10 + ch - '0';
    return s * w;
}

int main() {
	int n = read(), m = read(), l, r; ll s, e, cha;
	while (m --) {
	  l = read(), r = read(); s = read(), e = read(), cha;
	  cha = (e - s) / (r - l);//计算公差 
	  cha_cha[l] += cha, cha_cha[r + 1] -= cha; //等差数列的差分的差分= = 
	  sum_ans[l] += s - cha, sum_ans[r + 1] -= s - cha; //当等差数列开头不为公差时 
	  sum_ans[r + 1] -= (r - l + 1) * cha;//等差数列差分 
	}
	ll Max = 0, ans = 0;
	for (register int i = 1; i <= n; i ++) { 
	  sum_cha[i] = sum_cha[i - 1] + cha_cha[i]; //前缀和求等差数列的差分数组 
	  sum_ans[i] += sum_ans[i - 1] + sum_cha[i];//前缀和求每个点要加的值 
	  ans ^= sum_ans[i], Max = max(Max, sum_ans[i]);
	} 
	printf("%lld %lld", ans, Max);
	return 0; 
}

```

---

## 作者：lytqwq (赞：1)

差分太好用了！！！



------------
先贴一下异或：
https://baike.sogou.com/v7667892.htm?fromTitle=异或

~~对于我这种蒟蒻，线段树、树状数组都只是听说过，太难，不会。~~

差分不要函数，不要多少行代码就能打出来的方法复杂度还低！今天刚学了差分，~~就膨胀到刷蓝题。。。~~

我早上是看了这个博客学的差分：https://www.zybuluo.com/Junlier/note/1232395

（强烈推荐，简单易懂，不看可能看不懂代码）

直接贴代码（解释注释上）：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long int n,m,a[10000002],b[10000002],ss,maxn;
/*
	a数组储存 每个柱子的伤害值，b数组储存  第i-1个到第i个的差 
*/
int main()
{
	cin>>n>>m;
	int l,r,s,e;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%d",&l,&r,&s,&e);//输入 
		a[l]=a[l]+s;
		a[r+1]=a[r+1]-e;
		//头尾加减 
		int k=(e-s)/(r-l);
		//单个的差值 
		b[l+1]=b[l+1]+k;
		b[r+1]=b[r+1]-k;
		//b数组储存第i-1个到第i个的差，如果攻击重叠，就直接加上，反成后面会减qwq 
	}
	for(int i=1;i<=n;i++)
	{
		b[i]=b[i-1]+b[i];//差值积累 
		a[i]=a[i]+a[i-1]+b[i];//伤害值累加 
//		cout<<a[i]<<" ";

		if(i>=2)
		ss=ss^a[i];
		else
		ss=a[i];
		/*
		前面一部分是求异或
		*/
		
		maxn=max(maxn,a[i]);//最大值 
	}
	cout<<ss<<" "<<maxn;//输出
	return 0;//谢谢围观 
}
```

---

## 作者：Carbon (赞：0)

通读全文，发现此题就是在一串全部为0的序列上给区间l~r加上等差序列．

100%数据范围:1e7

显然，数据结构大概率不能做此题，线段树爆空间，树状数组，emmmm暂时没想到较好的做法。


于是我们可以考虑一下查分，但是查分如何维护一个等差序列呢？

通过手玩一下样例我们发现我们可以维护一个数组a[i]表示这个序列的差分的差分，最后只需计算两遍前缀和来得到原序列。

可是为什么二阶差分能解决此题呢？

当我们给原序列加一个等差序列时，这个加上去的数列一个非常重要的性质，就是，他们是等差的，这导致序列中的差分（除去头尾）都相等，于是我们可以发现，我们只需在a[l]上加上s,a[l+1]上加上公差减等差序列头，a[r+1]减去（等差序列尾加公差），a[r+2]加上等差序列的尾部即可

代码如下：
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const ll N=1e7+5;
ll a[N];
ll n,m;

int main()
{
    scanf("%lld%lld",&n,&m);
    while (m--)
    {
        ll l,r,s,e;
        scanf("%lld%lld%lld%lld",&l,&r,&s,&e);
        a[l]+=s;
        a[l+1]+=(e-s)/(r-l)-s;
        a[r+1]-=e+(e-s)/(r-l);
        a[r+2]+=e;
    }
    for (register ll i=1;i<=n;i++)a[i]=a[i]+a[i-1];
    for (register ll i=1;i<=n;i++)a[i]=a[i]+a[i-1];
    ll xor_sum=0,max_ans=0;
    for (register ll i=1;i<=n;i++){xor_sum=xor_sum^a[i];max_ans=max(max_ans,a[i]);}
    cout<<xor_sum<<' '<<max_ans;
    return 0;
}
```

---


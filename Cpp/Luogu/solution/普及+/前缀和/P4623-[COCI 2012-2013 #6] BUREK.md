# [COCI 2012/2013 #6] BUREK

## 题目背景

COCI

## 题目描述

给定 $N$ 个三角形，和 $M$ 条直线，直线要么平行于 $x$ 轴，要么平行于 $y$ 轴，问这 $M$ 条直线分别穿过多少个三角形。

**（一条直线穿过一个三角形，当且仅当这条直线可以将这个三角形分成两个面积均大于零的多边形）。**

## 说明/提示

**【数据范围】**

对于 $40 \%$ 的数据，$M \le 300$；

另有 $40 \%$ 的数据，所有三角形的坐标 $< 1000$；

对于 $100 \%$ 的数据，$2 \le N,M \le 10^5$，$0 \le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$。

## 样例 #1

### 输入

```
3
1 0 0 2 2 2
1 3 3 5 4 0
5 4 4 5 4 4
4
x = 4
x = 1
y = 3
y = 1```

### 输出

```
0
1
1
2```

## 样例 #2

### 输入

```
4
2 7 6 0 0 5
7 1 7 10 11 11
5 10 2 9 6 8
1 9 10 10 4 1
4
y = 6
x = 2
x = 4
x = 9```

### 输出

```
3
2
3
2```

# 题解

## 作者：Inui_Sana (赞：10)

# [题目传送门](https://www.luogu.com.cn/problem/P4623)

## 解题思路：桶+差分

看到题解好多大奆都用树状数组，扫描线什么的~~完全不会啊~~。但这题其实可以用简单的桶数组来解决。代码量小，时间短。

### Part 1 暴力

最简单的想法，对于每条直线，找哪些三角形满足条件。时间复杂度 $ O(nm)$。能拿30pts。

### Part 2 桶优化

接下来就要思考如何在 $O(1)$ 的时间内得到一条直线穿过多少三角形。桶能够很好地满足这个需求。再看数据范围，$0 \le x_1,y_1,x_2,y_2,x_3,y_3 < 10^6$，可以说完美适于桶。

设置两个桶 $boxx$ 和 $boxy$，分别用来存储直线 $x=i$ 和 $y=i$ 穿过的三角形数量。对于每个三角形，求出三个点中最大和最小的 $x$ 坐标和 $y$ 坐标，将 $boxx[(x_{min},x_{max})]$ 和 $boxy[(y_{min},y_{max})]$ 都 $+1$。对于每条直线，直接输出答案即可。时间复杂度 $O(n^2)$。

### Part 3 差分维护桶

很容易发现，对于每个三角形，总是在一段区间内 $+1$。所以可以用差分维护。对于每个三角形，将 $boxx[x_{min}+1]$ 和 $boxy[y_{min}+1]$ 都 $+1$，$boxx[x_{max}]$ 和 $boxy[y_{max}]$ 都 $-1$。最后再还原即可。时间复杂度 $O(n)$。（但其实还原差分数组要进行 $10^6$ 次）

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000007;
int n,m,boxx[maxn],boxy[maxn];
int main(){
	scanf("%d",&n);
	int x,y;
	for(int i=1;i<=n;i++){
		int maxx=-1*(1e9+7),maxy=-1*(1e9+7),minx=1e9+7,miny=1e9+7;
		for(int j=1;j<=3;j++){
			scanf("%d%d",&x,&y);
			maxx=max(maxx,x);maxy=max(maxy,y);
			minx=min(minx,x);miny=min(miny,y);
		}
		boxx[minx+1]++;boxy[miny+1]++;
		boxx[maxx]--;boxy[maxy]--;
	}
	for(int i=1;i<=1000000;i++){
		boxx[i]+=boxx[i-1];boxy[i]+=boxy[i-1];//直接用差分数组还原，压缩空间
	}
	scanf("%d",&m);
	char dir,no;int num=0;
	for(int i=1;i<=m;i++){
		scanf(" %c %c %d",&dir,&no,&num);//这个no只是为了读入方便
		if(dir=='x')printf("%d\n",boxx[num]);
		else printf("%d\n",boxy[num]);
	}
}
```

ps：建议全程用scanf……别问为什么

（做了一点小改动）

---

## 作者：Gorenstein (赞：6)

$O(n)$ 做法。

坐标系中通过告诉三个顶点坐标的方式给定 $N$ 个三角形，同时给出 $M$ 条形如 $x=c$ 或 $y=c$ 的直线。对于每一条直线，求出这条直线能够将多少个三角形分成两个面积均大于零的多边形。

------------

题解为什么清一色的树状数组啊（？

对于一个任意的三角形，我们发现，只要一条直线穿过了刚好能够覆盖它的矩形，那么也一定能够分割这个三角形。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/je7zsmiv.png?x-oss-process=image/resize,m_lfit,h_870,w_925)

红色为三角形，黑色为能够覆盖之的最小矩形。一条蓝色的直线必然同时穿过这两个图形。

又设第 $i$ 个三角形中，$Min_{xi},Min_{yi},Max_{xi},Max_{yi}$ 表示三个点坐标中最小的 $x$ 坐标、最小的 $y$ 坐标、最大的 $x$ 坐标、最大的 $y$ 坐标，则显然一个点 $(a,b)$ 在矩形内，当且仅当 $Min_{xi}<a<Max_{xi}\,,\,Min_{yi}<b<Max_{yi}$。

所以对于直线 $x=c$，如果能够切到第 $i$ 个三角形，需要 $Min_{xi}<c<Max_{xi}$。换言之，这个三角形对$Min_{xi}$ 到 $Max_{xi}$ 这段有贡献。于是在 $x$ 轴上加 $Min_{xi}$ 到 $Max_{xi}$ 这么一段，查询直线 $x=c$ 的时候看 $x$ 轴的 $c$ 这个位置被加了多少即可。$y$ 轴同理。

坐标最大为 $10^6$，显然可以差分。因为切出来面积要大于 $0$，这里的差分是不包含左右断点的，所以加减的时候都往里面缩一格。

于是 $O(n)$ 解决。

```cpp
const int N=1000010;
int X[N],Y[N],n,m,mx1,mx2;
int main()
{
	n=read();
	while(n--)
	{
		int a=N,b=0,c=N,d=0;
		for(int i=1;i<=3;i++)
		{
			int x=read(),y=read();
			a=min(a,x),b=max(b,x),c=min(c,y),d=max(d,y);
			mx1=max(mx1,x),mx2=max(mx2,y);
		}
		X[a+1]++,X[b]--,Y[c+1]++,Y[d]--;
	}
	for(int i=0;i<=mx1+1;i++)X[i]+=X[i-1];
	for(int i=0;i<=mx2+1;i++)Y[i]+=Y[i-1];
	m=read();
	while(m--)
	{
		char s;cin>>s;
		int x=read();
		if(s=='x')printf("%d\n",X[x]);
		if(s=='y')printf("%d\n",Y[x]);
	}
	return 0;
}
```

---

## 作者：Kevin_Wa (赞：6)

~~本题看上去非常吓人啊~~

然而并不是这样。。。

其实一条直线判断是否穿过一个三角形，只需要与三角形中的节点的左右端点比较，若包含于此，则说明这条直线可以穿过这个三角形。

> $1$、 $x=c$类型，只需要判断是否满足$min(x1,x2,x3)<c<max(x1,x2,x3)$。若满足则可以穿过。

>$ 2$、$y=c$类型，只需要判断是否满足$min(y1,y2,y3)<c<max(y1,y2,y3)$。若满足则可以穿过。

给一张图大家可以好理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/eqevnc3l.png)

故很显然只需要区间修改$[min(x1,x2,x3)+1,max(x1,x2,x3)-1]$单点查询$c$即可。

（为什么题解里没有线段树呢？本人未注意到这题是离线操作，故使用了线段树，洛谷会因为空间不足而炸掉。效率也没有差分数组高。若此题是在线操作，那么线段树就是正解。）

但是还是贴上代码，仅供喜欢线段树的$OIer$参考。

```cpp
#include<bits/stdc++.h>
#define N 100100
#define maxn 1001000
#define x1 xadsfa
#define y1 fdasdf
#define x2 dadfa
#define y2 dfas
#define x3 dfasdg
#define y3 dsfag
using namespace std;
int x1[N],y1[N],x2[N],y2[N],x3[N],y3[N],n,q,x,y,ans;
int l,r;
struct node{
	int w,f;
}treex[maxn<<2],treey[maxn<<2];
template <typename T> void read(T &x) {
x = 0; char c = getchar();int f=1;
for (; !isdigit(c); c = getchar())if (c=='-') f=-1;
for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
x*=f;
}
int minn(int x,int y,int z)
{
	int mi=x;
	if (mi>y) mi=y;
	if (mi>z) mi=z;
	return mi;
}
int maxx(int x,int y,int z)
{
	int ma=x;
	if (ma<y) ma=y;
	if (ma<z) ma=z;
	return ma; 
}
void addx(int k,int t,int w)
{
	if (l<=t && w<=r)
	  {
	  	treex[k].f++;
	  	treex[k].w=treex[k].w+w-t+1;
	  	return;
	  }
	int mid=(t+w)>>1;
	if (l<=mid) addx(k*2,t,mid);
	if (r>mid) addx(k*2+1,mid+1,w);
	treex[k].w=treex[k*2].w+treex[k*2+1].w;
}
void addy(int k,int t,int w)
{
	if (l<=t && w<=r)
	  {
	  	treey[k].f++;
	  	treey[k].w=treey[k].w+w-t+1;
	  	return;
	  }
	int mid=(t+w)>>1;
	if (l<=mid) addy(k*2,t,mid);
	if (r>mid) addy(k*2+1,mid+1,w);
	treey[k].w=treey[k*2].w+treey[k*2+1].w;
}
void pushdownx(int k,int l1,int r1,int l2,int r2)
{
	treex[k*2].w+=(treex[k].f*(r1-l1+1));
	treex[k*2+1].w+=(treex[k].f*(r2-l2+1));
	treex[k*2].f+=treex[k].f;
	treex[k*2+1].f+=treex[k].f;
	treex[k].f=0;
}
void askx(int k,int t,int w)
{
	if (t==w)
	  {
	  	ans=treex[k].w;
	  	return;
	  }
	int mid=(t+w)>>1;
	if (treex[k].f) pushdownx(k,t,mid,mid+1,w);
	if (x<=mid) askx(k*2,t,mid);
	else askx(k*2+1,mid+1,w); 
}
void pushdowny(int k,int l1,int r1,int l2,int r2)
{
	treey[k*2].w+=(treey[k].f*(r1-l1+1));
	treey[k*2+1].w+=(treey[k].f*(r2-l2+1));
	treey[k*2].f+=treey[k].f;
	treey[k*2+1].f+=treey[k].f;
	treey[k].f=0;
}
void asky(int k,int t,int w)
{
	if (t==w)
	  {
	  	ans=treey[k].w;
	  	return;
	  }
	int mid=(t+w)>>1;
	if (treey[k].f) pushdowny(k,t,mid,mid+1,w);
	if (y<=mid) asky(k*2,t,mid);
	else asky(k*2+1,mid+1,w); 
}
int main()
{
read(n);
for (int i=1;i<=n;i++)
  read(x1[i]),read(y1[i]),read(x2[i]),read(y2[i]),read(x3[i]),read(y3[i]);
read(q);
if (q<=300)
{
while (q--)
  {
  	char c=getchar();
  	while (c!='x' && c!='y') c=getchar();
  	if (c=='x')
  	  {
  	  	c=getchar();
  	  	read(x);
  	  	ans=0;
  	  	for (int i=1;i<=n;i++)
  	  	  if ((x1[i]<x && x<x2[i]) || (x2[i]<x && x<x1[i]) || (x1[i]<x && x<x3[i]) || 
			  (x3[i]<x && x<x1[i]) || (x3[i]<x && x<x2[i]) || (x2[i]<x && x<x3[i]) )
			  ans++;
		printf("%d\n",ans);
		}
  	if (c=='y')
  	  {
  	  	c=getchar();
  	  	read(y);
  	  	ans=0;
  	  	for (int i=1;i<=n;i++)
  	  	  if ((y1[i]<y && y<y2[i]) || (y2[i]<y && y<y1[i]) || (y1[i]<y && y<y3[i]) || 
			  (y3[i]<y && y<y1[i]) || (y3[i]<y && y<y2[i]) || (y2[i]<y && y<y3[i])  )
			  ans++;
		printf("%d\n",ans);
		}
  }
return 0;
}
for (int i=1;i<=n;i++)
  {
  	l=minn(x1[i],x2[i],x3[i])+1;
  	r=maxx(x1[i],x2[i],x3[i])-1;
  	if (l<=r) addx(1,0,maxn-1000);
  	l=minn(y1[i],y2[i],y3[i])+1;
  	r=maxx(y1[i],y2[i],y3[i])-1;
  	if (l<=r) addy(1,0,maxn-1000);	
  }
while (q--)
  {
  	char c=getchar();
  	while (c!='x' && c!='y') c=getchar();
  	if (c=='x')
  	  {
  	  	c=getchar();
  	  	read(x);
  	  	ans=0;
  	  	askx(1,0,maxn-1000);
		}
  	if (c=='y')
  	  {
  	  	c=getchar();
  	  	read(y);
  	  	ans=0;
  	  	asky(1,0,maxn-1000);
		}
	printf("%d\n",ans);
  }
return 0;
}
```




---

## 作者：りゅうこせい (赞：6)

上面半步颠巨佬思路说的非常吼哇
 
核心就是因为每条直线与坐标轴平行，所以要是穿过三角形相当于穿过一个矩形

（半步癫佬明年sdoi省队队长预定，先%为敬）

我想当你点开这个蓝题，显然会前缀和操作了

（如果不会，参考一下链接，我觉得写的不错）

http://www.cnblogs.com/OIerShawnZhou/p/7348088.html

这个题对前缀和操作有些小细节，下面以样例1为例

左下角那个小三角形，对于每一条平行于y轴的直线，只有x=1穿过，他的x轴方向上界为3下界为1，所以处理前缀和应该是a[x+1]++，a[y]--（想一想，为什么）

![](https://cdn.luogu.com.cn/upload/pic/21239.png)

下面给出完整代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int x[1000000];//前缀和数组 
int xx[1000000];//差分数组 
int y[1000000];
int yy[1000000];
int n,m,q;
char a[5];
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		int x1,x2,x3,y1,y2,y3,lx,ly,rx,ry;
		//xi,yi是坐标,lx,rx是x上下界,同理ly,ry 
		scanf("%d%d%d%d%d%d",&x1,&y1,&x2,&y2,&x3,&y3);
		lx=min(x1,min(x2,x3));
		ly=min(y1,min(y2,y3));
		rx=max(x1,max(x2,x3));
		ry=max(y1,max(y2,y3));
		x[lx+1]++;//前缀和
		x[rx]--;
		y[ly+1]++;
		y[ry]--;
	}
	for(int i=1;i<=1000000;i++)
	{
		xx[i]=xx[i-1]+x[i];//一定要差分回来 
		yy[i]=yy[i-1]+y[i];
	}
	scanf("%d",&m);
	while(m--)
	{
		cin>>a[1]>>a[2]>>q;
		//输入的骚操作,会自动忽略空格所以可行 
		if(a[1]=='x')
		printf("%d\n",xx[q]);
		else
		printf("%d\n",yy[q]);
	}
	return 0;
}
```

(p.s.半步颠大佬太强啦)

---

## 作者：xxasmcd (赞：5)

这道题我用的和其他题解不同，用的是扫描线的方法。

无论是对于三角形还是直线，都设为一个结构体。

我的思路步骤如下。

1. 对于每一个三角形的三个点，把三个点的行坐标当中最小的一个当做上边界，行坐标当中最大的一个当做下边界，列坐标当中最小的一个当做左边界， 右坐标最大的一个当做右边界，无论是上边界和下边界都放在行结构体里，上边界和下边界都放在列结构体里。
 
1. 再处理每一条直线，对于每一条直线将行列分开来，分别和之前三角形的点一同放入行或列结构体中。

1. 将行列结构体排序。

1. 对于行列结构体分别处理，将每条直线所穿过的三角形数量放入答案数组当中。

如果还是对具体实现方法不理解，可参考代码以及注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt=0,cntx,cnty,num,ans[100005];//ans数组用来记录答案
struct node
{
    int num,flag,id;//num用来表示具体的行列数，flag用来表示类型，1表示上边界和左边界，2表示直线,3表示右边界和下边界，id用来记录当前直线编号
}x[300005],y[300005];//行列结构体
bool cmp(node a,node b)//用来给行列结构体排序
{
    if(a.num!=b.num)return a.num<b.num;
    return a.flag>b.flag;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int a1,a2,a3,b1,b2,b3;
        cin>>a1>>b1>>a2>>b2>>a3>>b3;
        x[++cnt]={min(a1,min(a2,a3)),1,i};//上边界
        y[cnt]={min(b1,min(b2,b3)),1,i};//左边界
        x[++cnt]={max(a1,max(a2,a3)),3,i};//下边界
        y[cnt]={max(b1,max(b2,b3)),3,i};//右边界
    }
    cntx=cnty=cnt;
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        char a,b;
        int c;
        cin>>a>>b>>c;
        if(a=='x')//行的直线
        {
            x[++cntx]={c,2,i};
        }
        else//列的直线
        {
            y[++cnty]={c,2,i};
        }
    }
    sort(x+1,x+cntx+1,cmp);//排序
    sort(y+1,y+cnty+1,cmp);
    num=0;
    for(int i=1;i<=cntx;i++)
    {
        if(x[i].flag==1)//如果是上边界
        {
            num++;
        }
        else if(x[i].flag==3)//如果是下边界
        {
            num--;
        }
        else//一条直线
        {
            ans[x[i].id]=num;
        }
    }
    num=0;
    for(int i=1;i<=cnty;i++)
    {
        if(y[i].flag==1)//如果是左边界
        {
            num++;
        }
        else if(y[i].flag==3)//如果是右边界
        {
            num--;
        }
        else//一条直线
        {
            ans[y[i].id]=num;
        }
    }
    for(int i=1;i<=m;i++)
    {
        cout<<ans[i]<<endl;
    }
    return 0;
}

```


---

## 作者：zplqwq (赞：3)

题解区咋全是树状数组，完全可以不用的说。

通过读题可以发现，处理直线 $ \text{x=i}$ 与处理直线 $\text{y=i}$ 的方法是一样的，所以以下题解以 $\text{y=i}$ 为例子讨论。

首先不难发现一个性质，直线 $\text{y=i}$ 合法当且仅当 $\min\{y_1,y_2,y_3\} \le i \le \max \{y_1,y_2,y_3\}$ 。

那不难想出一个复杂度为 $O(n\times m)$ 的暴力。

考虑优化一下这个暴力，我们可以一开始预处理出在 $\min\{y_1,y_2,y_3\} \le i \le \max \{y_1,y_2,y_3\}$ 内的所有值，用桶存储一下，然后 $O(1)$ 查询即可。

时间复杂度 $O(n^2)$ 。

现在还是够不去，那怎么办呢？我们考虑优化预处理部分。

显然，我们可以考虑差分，利用差分数组的前缀和就是原数组这个性质可以很好地还原出原数组。

一开始的时候把 $\min\{y_1,y_2,y_3\}+1$ 和 $\max \{y_1,y_2,y_3\}$ 丢进桶里，等到循环结束后再跑一遍前缀和即可。

由于 $y_i$ 的值可以达到 $10^6$ ，所以跑前缀和的时候要从 $1$ 跑到 $10^6$ 。

最后 $O(1)$ 查询。

总时间复杂度在 $10^6$ 左右，可过。

---

## 作者：MuYC (赞：2)

## 这道题目树状数组+差分即可以过了

## 那么什么是树状数组?

给出一个数组，要求查询任意区间和，且能单点更新。我们用树状数组解决。

树状数组的核心很简单，是一个数学事实：任何（十进制)数都可以被2的次幂之和表示。例如，13=8+4+1，21=16+4+1，…

这就提供了便利：想要查询1到13的区间和（下记为S[1…13])，只要求S[1…8]、S[9…12]、S[13…13]，它们的长度也即符合13=8+4+1。

同样的，我们有一个便捷的写法求出一个数的二次幂表示：

见代码：
```cpp
int lowbit(int x){return x&-x;}
```

树状数组入门的话请看这个博客，他介绍得好，我就不赘述了。挺好的：[点这里](https://blog.csdn.net/iwts_24/article/details/82497026)

差分的话可以介绍一下，网络上博客不是特别多。

差分其实特别的简单，类似于这样:s[1]=a[1]-a[2],s[2]=a[2]-a[3]

我们要求原数组中的第i个数，就只要求出s[1]+s[2]+...+s[i]

就是这么简单。

这道题目：

首先我们找出一个三角形顶点中，x值最大的maxx,以及x值最小的minx还有y最大的maxy，最小的miny，然后用两个树状数组维护c0以及c1就好了


```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{int x,x2,x3,y,y2,y3;}t[100000+5];
int c0[2000000+5],c1[2000000+5],n;
int C(int x){return x&-x;}
int add(int *c,int x,int k){while(x <= 1000000 )c[x]+=k,x+=C(x);}
int get(int *c,int x){int ans=0;while( x != 0)ans+=c[x],x-=C(x);return ans;}
int main(){
	int i,j,k,m,maxx,maxy,minx,miny,sum;
	char p,ll;
	cin>>n;
	for ( i = 1 ; i <= n; i ++){
		maxx=0,maxy=0,minx=0x7fffff,miny=0x7fffff;
		cin>>t[i].x>>t[i].y>>t[i].x2>>t[i].y2>>t[i].x3>>t[i].y3;
		maxx=max(t[i].x,t[i].x2);maxx=max(maxx,t[i].x3);
		maxy=max(t[i].y,t[i].y2);maxy=max(maxy,t[i].y3);
		minx=min(t[i].x,t[i].x2);minx=min(minx,t[i].x3);
		miny=min(t[i].y,t[i].y2);miny=min(miny,t[i].y3);
		add(c0,maxx,-1);add(c1,maxy,-1);
		add(c0,minx+1,1);add(c1,miny+1,1);
	}
	cin>>m;
	for ( i = 1 ; i <= m; i ++){
		cin>>p;cin>>ll;cin>>sum;
		if( p == 'x')cout<<get(c0,sum)<<endl;
		else if( p == 'y')cout<<get(c1,sum)<<endl;
	}
	return 0;
}
```


---

## 作者：含笑半步癫 (赞：2)

对于某个个三角形，当一条直线在它的最左点或最右点之间（y=xxx在最上点与最下点之间）时则视为穿过（不包括顶点，加上顶点会**咕咕**掉）。

所以，将每个三角行的最上最下和最左最右这两区间加一，访问时某个点被覆盖次数就是答案。

我们可以给X轴和Y轴分别建树状数组（用前缀和做也可以，线段树会爆空间），每次区间加一，最后单点查询即可。

### 蒟蒻的丑代码→  
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,m,x1,x2,x3,y1,y2,y3,maxx,maxy,minx,miny,b[1000150],bb[1000100],ans;
int lowbit(int x)
{
    return x&-x;
}
void addss(int x,int k)
{
    while(x<=1000010)
    {
        b[x]+=k;
        x+=lowbit(x);
    }
}
int query(int x)
{
    int s=0;
    while(x>0)
    {
        s+=b[x];
        x-=lowbit(x);
    }
    return s;
}
void addsss(int x,int k)
{
    while(x<=1000010)
    {
        bb[x]+=k;
        x+=lowbit(x);
    }
}
int querys(int x)
{
    int s=0;
    while(x>0)
    {
        s+=bb[x];
        x-=lowbit(x);
    }
    return s;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>x1>>y1>>x2>>y2>>x3>>y3;
        maxx=max(x1+1,x2+1);
        maxx=max(maxx,x3+1);
        maxy=max(y1+1,y2+1);
        maxy=max(maxy,y3+1);
        minx=min(x1+1,x2+1);
        minx=min(minx,x3+1);
        miny=min(y1+1,y2+1);
        miny=min(miny,y3+1);
        if(maxx-minx>1)
        {
            addss(maxx,-1);
            addss(minx+1,1);
        }
        if(maxy-miny>1)
        {
            addsss(maxy,-1); 
            addsss(miny+1,1);
        }
    }
    cin>>m;
    char a[5];
    int s;
    for(int i=1;i<=m;i++)
    {
        ans=0;
        cin>>a[1]>>a[2]>>s;
        if(a[1]=='x')
        {
            ans=query(s+1);
            cout<<ans<<endl;
        }
        else{
            ans=querys(s+1);
            cout<<ans<<endl;         
        }
    }
    return 0;
}
```

---

## 作者：Martian148 (赞：2)

# Link
[P4623 [COCI2012-2013#6] BUREK](https://www.luogu.com.cn/problem/P4623)

# Solve
对于$x$和$y$我们可以分开看，我们单看$x$，把$y$的那一维压缩掉，可以看出就变成一个一维的问题，左端点为min(x_1,min(x_2,x_3))，右端点为max(x_1,max(x_2,x_3))就可以用一个差分的想法，因为端点处是不计数的，所以在(左端点+1)处+1，在右端点处-1，用前缀和统计答案即可，$y$的那一维同理。

我统计前缀和的时候用了树状数组，实际上是不需要的，直接$O(n)$统计即可

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000005;
int N,x_1,x_2,x_3,y_1,y_2,y_3,c[2][maxn],Q;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch<='9'&&ch>='0')ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void add_x(int op,int x,int data){
	for(int i=x;i<=1000001;i+=i&-i)c[op][i]+=data;
	return ;
}
int get(int op,int x){
	int S=0;
	for(int i=x;i;i-=i&-i)S+=c[op][i];
	return S;
}
int main(){
	N=read();
	for(int i=1;i<=N;i++){
		x_1=read()+1,y_1=read()+1,x_2=read()+1,y_2=read()+1,x_3=read()+1,y_3=read()+1;
		add_x(0,min(x_1,min(x_2,x_3))+1,1);
		add_x(0,max(x_1,max(x_2,x_3)), -1);
		add_x(1,min(y_1,min(y_2,y_3))+1,1);
		add_x(1,max(y_1,max(y_2,y_3)), -1);
	}
	Q=read();
	for(int i=1;i<=Q;i++){
		char op;scanf("%c",&op);
		int x=read()+1;
		if(op=='x')printf("%d\n",get(0,x));
		else       printf("%d\n",get(1,x));
	}
	return 0;
}
```

---

## 作者：FrozenDream (赞：1)

#### 引言：
这道题看题解还没有分块的方法，我就来一发分块吧。
#### 思路：
我们可以存下每个三角形的最大和最小的上下左右端点，然后把在这些端点之间的区间加1，最后直接输出输入的坐标对应的数组（完整块+不完整块）就可以了。

现在介绍一下分块：

分块，是一种可以说是相当暴力的思想。

分块算法的思想是通过适当的划分，预处理一部分信息保存下来，用空间换取时间，达到时空平衡。

基本操作是：将一段序列，分成一定数量的块，每一块有一个长度，表示一段区间。对于区间操作，通过对完整块的整体操作和对不完整块的暴力操作而使复杂度尽可能的低。

#### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,lin,ax,ay,bx,by,cx,cy,lrk[1000005],udk[1000005],n,mu,md,ml,mr,x[1000005],y[1000005];
char l1,l2;
int main(){
	//freopen("burek.in","r",stdin);
	//freopen("burek.out","w",stdout);
	cin>>n;
	for(int j=1;j<=n;j++){
		cin>>ax>>ay>>bx>>by>>cx>>cy;
		md=min(ay,min(by,cy))+1;
		mu=max(ay,max(by,cy));
		ml=min(ax,min(bx,cx))+1;
		mr=max(ax,max(bx,cx));
		for(int i=ml;i<mr;i++){
			while(i%1000==0&&i+1000<mr){
				lrk[i/1000+1]++;
				i+=1000;
			}
			x[i]++;
		}
		for(int i=md;i<mu;i++){
			while(i%1000==0&&i+1000<mu){
				udk[i/1000+1]++;
				i+=1000;
			}
			y[i]++;
		}
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>l1>>l2>>lin;
		if(l1=='x'){
			cout<<x[lin]+lrk[lin/1000+1]<<endl;
		}else{
			cout<<y[lin]+udk[lin/1000+1]<<endl;
		}
	}
}
```


---

## 作者：冰凉的水 (赞：1)

- 本人的思路~~清奇诡异~~，机房考试是数据加强版（-1e9～1e9），所以需要离散化，此题可以不用。不过，我的思路是排序+差分（机房数据大，空间开不下）。
- 首先，约束条件：直线从三角形中间穿过。
--
- 因为，只有平行于坐标轴的直线，所以将x，y轴拆开看，就可以看成端点和树轴（想象力不好的同学可以手绘 ~~模拟~~ %ni一下）。
- 所以穿过三角形的直线符合xE(min(x1,x2,x3),max(x1,x2,x3)),yE(min(y1,y2,y3),max(y1,y2,y3) )。(因为不会打属于符号，用E代替(T_T))
- 将所有左端点（标记一下），右端点，查询x（标记一下）记录在一起，y另外记录在一起。
- 接下来，就是差分的思想，我们在左端点+1的位置给贡献加一（注意是左端点加一，因为经过端点不算穿过），在右端点的位置减一，那么，从前面累加起的值就是这个点的答案（不就是前缀和嘛，不理解的同学好好想想 ）。
--
- 最后，我们存下查询的时间戳（chuo，好像蛮多人以为是截，的确蛮像的），保存在ans数组里输出统计的答案。
- AC代码（保持了数据加强后的空间大小，可自己计算更改）：

- ```cpp
#include<bits/stdc++.h>
using namespace std;
int read()//快读还需要解释吗？
{
	int x=0,fg=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')fg*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*fg;
}
const int N=1000010;
struct node{
    int val,id;  //  val存端点位置,id存访问时间戳
    int dir,left;//  dir是查询标记，left是左端点标记
}x[N],y[N];      //  x，y分开处理
bool cmp(node c,node d)// 将端点优先于查询，小端点优于大端点
{
    return c.val==d.val?c.dir<d.dir:c.val<d.val;
}
int n,m,totx,toty,ans[N];
int main()
{
	//freopen("burek.in","r",stdin);
	//freopen("burek.out","w",stdout);
	n=read();
	for(int i=1;i<=n;++i)//读入三角形
	{
	    int x1=read(),y1=read(),x2=read(),y2=read(),x3=read(),y3=read();
	    x[++totx].val=min(x1,min(x2,x3))+1;x[totx].left=1;
        //直接在左端点加入时就+1
	    x[++totx].val=max(x1,max(x2,x3));
	    y[++toty].val=min(y1,min(y2,y3))+1;y[toty].left=1;
	    y[++toty].val=max(y1,max(y2,y3));
	}
	m=read();
	for(int i=1;i<=m;i++)//读入查询
	{
		char ch[5];cin>>ch;
		if(ch[0]=='x')
		{
		    cin>>ch;
		    x[++totx].val=read();
		    x[totx].id=i;
		    x[totx].dir=1;
		}
		else if(ch[0]=='y')
		{
		    cin>>ch;
		    y[++toty].val=read();
		    y[toty].id=i;
		    y[toty].dir=1;
		}
	}
	sort(x+1,x+1+totx,cmp);//排序
	sort(y+1,y+1+toty,cmp);
	int sum=0;            //前缀和统计，本人较懒不想开数组
	for(int i=1;i<=totx;i++)
	{
	    if(x[i].dir)ans[x[i].id]=sum;//对于查询记录答案
	    else if(x[i].left)++sum;//左端点+1的位置+1
	    else --sum;          //右端点-1
	}
	sum=0;	//记得清零
	for(int i=1;i<=toty;i++)//同上
	{
	    if(y[i].dir)ans[y[i].id]=sum;
	    else if(y[i].left)++sum;
	    else --sum;
	}
	for(int i=1;i<=m;i++)//输出答案
	printf("%d\n",ans[i]);
	return 0;
}
```
- 以上就是全部内容，路过的大佬是不是秒懂呀。

---

## 作者：Kreado (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4623)

这道题有很多解法，有树状数组的，有线段树的，但都有差分

但其实这道题不用树状数组或线段树就可以过，~~数据还是很水啦~~

### 切入正题
如果用暴力的话，枚举每个直线，找有哪些三角形符合条件，$ans+1$ , 但只能得30pts

如果用 $\texttt{差分 + 前缀和}$ 的话,那么就很快了，对于每一个三角形，记录它最左边和最右边的顶点的横坐标，记录它最上面和最下面的顶点的纵坐标，
将 $x[minx+1]$ 和 $y[miny+1]$ 都加上 $1$ , 将 $x[maxx-1]$ 和 $y[maxy-1]$ 都减去 $1$ ,最后再还原,时间不会超时

### AC代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,x[1000006],y[1000006],line; 
void chax(ll l,ll r){x[l]++,x[r+1]--;}
void chay(int l,int r){y[l]++,y[r+1]--;}
int main(){	
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		ll x1r,y1r,x2r,y2r,x3r,y3r;
		scanf("%lld%lld%lld%lld%lld%lld",&x1r,&y1r,&x2r,&y2r,&x3r,&y3r);
		ll maxx,maxy,minx,miny;
		maxx=max(x1r,max(x2r,x3r));
		minx=min(x1r,min(x2r,x3r));
		maxy=max(y1r,max(y2r,y3r));
		miny=min(y1r,min(y2r,y3r));
		if(minx+1<=maxx-1)
			chax(minx+1,maxx-1);
		if(miny+1<=maxy-1)
			chay(miny+1,maxy-1);
	}
	for(int i=1;i<=1000000;i++)
		x[i]+=x[i-1],y[i]+=y[i-1];
	scanf("%lld",&m);
	for(int i=1;i<=m;i++){
        char c;
	    scanf("\n%1c = %lld",&c,&line);
		if(c=='x') cout<<x[line]<<endl;
		if(c=='y') cout<<y[line]<<endl;
	}
	return 0;
}
```

这里不主讲 $\texttt{差分 + 前缀和}$ ，我们主要讲一下暴力优化

~~没想到吧，暴力也能过~~

实则就是分块，把一段分成一坨一坨的，然后再计算，会快一点

我们这里以 $1000$ 为一块，剩下的看代码注释，暴力还是很好懂的吧

### 再次AC代码

```cpp
#include<bits/stdc++.h> //万能头
#define ll long long //定义的一个宏，为了简便
using namespace std;
ll n,m,line;
ll lrk[1006],udk[1006],lr[1000006],ud[1000006];
char s,s1;
int main(){
	scanf("%lld",&n);
	for(int j=1;j<=n;j++){
		ll xp1,xp2,xp3,yp1,yp2,yp3;
		scanf("%lld%lld%lld%lld%lld%lld",&xp1,&yp1,&xp2,&yp2,&xp3,&yp3);
		ll W,E,S,N;
		W=min(xp1,min(xp2,xp3));//记录当前最左边的一个点
		E=max(xp1,max(xp2,xp3));//记录当前最右边的一个点
		S=min(yp1,min(yp2,yp3));//记录当前最下面的一个点
		N=max(yp1,max(yp2,yp3));//记录当前最上面的一个点
		for(int i=W+1;i<E;i++){ 
			while(i%1000==0&&i+1000<E) //分块
				lrk[i/1000+1]++,i+=1000; //当前这个区域内的三角形数量加1
			lr[i]++; //同上
		}
		for(int i=S+1;i<N;i++){
			while(i%1000==0&&i+1000<N)//同上
				udk[i/1000+1]++,i+=1000;
			ud[i]++;
		}
	}
	scanf("%lld",&m);
	for(int i=1;i<=m;i++){
		scanf("\n%1c = %lld",&s,&line);//这里输入输出更简便一些
		if(s=='x')
			printf("%lld\n",lr[line]+lrk[line/1000+1]);
         //输出X坐标为line的一个直线穿过了几个三角形
		else
			printf("%lld\n",ud[line]+udk[line/1000+1]);
         //输出Y坐标为line的一个直线穿过了几个三角形
	}
	return 0;
}
```


---

## 作者：vvauted (赞：0)

考虑把二维问题拆分为两个一维问题，如图：


![](https://cdn.luogu.com.cn/upload/image_hosting/mm5klr3i.png)

一维生物：这是个神马东西？我看起来就是一根线

我们给他降维打击一下，那么有两种情况：

① 如果从上面拍瘪，那么就是一条线，左端点 $x2$，右端点 $x3$。

有人就要说了，那不是还有钝角三角形？ 

好好，那就是左端点 $\min(x1,x2,x3)$ 右段点 $\max(x1,x2,x3)$ 。

有人问为什么？问就是封闭图形。

② 同理，如果从左边拍瘪，那么左端点就是 $\min(y1,y2,y3)$，右端点就是 $\max(y1,y2,y3)$

考虑差分一下，如果问的是直线 $x=k$ ，那么我们从上拍瘪，就是有多少线段覆盖了点 $k$。

那么如果问的是 $y=k$ ，就从左边拍瘪，同上。

代码就不给了

---

## 作者：ModestCoder_ (赞：0)

直线能穿过三角形，因为直线是平行于坐标轴的，所以很简单

以$x=p$为例

若直线能穿过某一个三角形，那么这条直线必定能穿过三角形的某一条边

换句话说，令三角形三个点中横坐标最小是$xmin$，最大是$xmax$

如果$xmin<p<xmax$，直线就能穿过这个三角形

所以可以直接差分，$d_{xmin+1}++,d_{xmax}--$

然后我傻傻的写了树状数组，不过也好，还能支持动态修改

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
using namespace std;
int n, tree1[maxn << 1], tree2[maxn << 1];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int lowbit(int x){ return x & -x; }
void update1(int x, int y){ for (; x < maxn; x += lowbit(x)) tree1[x] += y; }
void update2(int x, int y){ for (; x < maxn; x += lowbit(x)) tree2[x] += y; }
int query1(int x){ int s = 0; for (; x; x -= lowbit(x)) s += tree1[x]; return s; }
int query2(int x){ int s = 0; for (; x; x -= lowbit(x)) s += tree2[x]; return s; }

int main(){
	freopen("buerk.in", "r", stdin);
	freopen("buerk.out", "w", stdout);
	n = read();
	for (int i = 1; i <= n; ++i){
		int xmax = 0, xmin = maxn - 1, ymax = 0, ymin = maxn - 1;
		int x = read(), y = read();
		xmax = max(xmax, x), xmin = min(xmin, x), ymax = max(ymax, y), ymin = min(ymin, y);
		x = read(), y = read();
		xmax = max(xmax, x), xmin = min(xmin, x), ymax = max(ymax, y), ymin = min(ymin, y);
		x = read(), y = read();
		xmax = max(xmax, x), xmin = min(xmin, x), ymax = max(ymax, y), ymin = min(ymin, y);
		update1(xmin + 1, 1), update1(xmax, -1), update2(ymin + 1, 1), update2(ymax, -1);
	}
	int m = read();
	while (m--){
		char c = getchar();
		for (; c != 'x' && c != 'y'; c = getchar());
		int x = read();
		if (c == 'x') printf("%d\n", query1(x));
		else printf("%d\n", query2(x));
	}
	return 0;
}
```


---

## 作者：Space_Gold_Trash (赞：0)

我们关键就是要知道一条平行于$x$或者$y$轴的直线穿过多少个点

我们先来考虑对于直线$y=k$穿过三角形的条件是啥?

很显然,就是夹在最上面顶点与最下面顶点中间即可

我们再来考虑对于直线$x=k$穿过三角形的条件是啥?

很显然,就是夹在最左边顶点与最右边顶点中间即可

相当于我们可以转化成给出一堆区间,然后给你一个点,看这个点被多少区间包含

然后这就是树状数组模板题了

我们只需要维护查分即可

下代码

```
#include<bits/stdc++.h>
#define lowbit(i) i&(-i)
#define M 1010001
using namespace std;
int treex[M],treey[M];
inline char read_ch( ){
	char ch=getchar( );
	while(ch==' '||ch=='\n')ch=getchar( );
	return ch;
}
inline int read( ){
	int sum(0);
	bool ft(0);
	char ch=getchar( );
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar( );
	if(ch=='-'){ch=getchar( );ft=1;}
	while('0'<=ch&&ch<='9'){sum=(sum<<1)+(sum<<3)+ch-'0';ch=getchar( );}
	return ft?-sum:sum;
}
inline void addx(int x,int k){
	int i;
	for(i=x;i<M;i+=lowbit(i))
	treex[i]+=k;
}
inline void addy(int x,int k){
	int i;
	for(i=x;i<M;i+=lowbit(i))
	treey[i]+=k;
}
inline int getx(int x){
	int ans(0),i;
	for(i=x;!!i;i-=lowbit(i))
	ans+=treex[i];
	return ans;
}
inline int gety(int x){
	int ans(0),i;
	for(i=x;!!i;i-=lowbit(i))
	ans+=treey[i];
	return ans;
}
int n;
int main( ){
	n=read( );
	int i,x1,y1,x2,y2,x3,y3,x,y;
	for(i=1;i<=n;++i){
		x1=read( );y1=read( );x2=read( );y2=read( );x3=read( );y3=read( );
		x=min(x1,min(x2,x3))+1;
		y=max(x1,max(x2,x3))+1;
		addx(x+1,1);
		addx(y,-1);
		x=min(y1,min(y2,y3))+1;
		y=max(y1,max(y2,y3))+1;
		addy(x+1,1);
		addy(y,-1);
	}
	n=read( );
	int k;
	char s,qwq;
	while(n--){
		s=read_ch( );qwq=read_ch( );k=read( )+1;
		if(s=='x')printf("%d\n",getx(k));
		else printf("%d\n",gety(k));
	}
}
```

---


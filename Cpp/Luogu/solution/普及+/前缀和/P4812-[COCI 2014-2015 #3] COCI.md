# [COCI 2014/2015 #3] COCI

## 题目描述

 **译自 [COCI 2014/2015 Contest 3](http://www.hsin.hr/coci/archive/2014_2015/) T4「COCI」**

第三轮 COCI 来了！为了估分，我们猜测：如果选手 $\mathrm{A}$ 在前两轮比赛中分数都高于选手 $\mathrm{B}$，那么选手 $\mathrm{A}$ 第三轮的分数与选手 $\mathrm{B}$ 的分数**至少相等**。

在每轮比赛中（包括这一场）选手至少会为 $0$ 分，至多会得到 $650$ 分。在**总排行榜**中，选手们将会按照**三轮比赛的总得分**降序排列。如果有两名选手分数相同则排名相同，下一名分数更小的选手排名后移。
比如有 $5$ 名选手，总得分分别为 $1000,1000,900,900$ 和 $800$，那么对应的排名为 $\text{No.}\ 1,$ $\text{No.}\ 1,$ $\text{No.}\ 3,$ $\text{No.}\ 3$ 和 $\text{No.}\ 5$。

对于 $N$ 名选手中的每一名选手，我们知道他们的第一轮和第二轮得分。基于上述假设，请确定每名选手在经过三轮 COCI 之后可以获得的最高名次和最低名次。

## 说明/提示

$1 \le N \le 5\times 10^5$，所有的选手分数均在 $[0,650]$ 范围内。

## 样例 #1

### 输入

```
5
250 180
250 132
220 123
132 194
220 105```

### 输出

```
1 3
1 3
3 5
1 5
3 5```

## 样例 #2

### 输入

```
10
650 550
550 554
560 512
610 460
610 456
650 392
580 436
650 366
520 456
490 456```

### 输出

```
1 4
1 8
2 8
2 7
2 9
1 10
4 10
1 10
5 10
5 10```

# 题解

## 作者：muyang_233 (赞：7)

[原题传送门](https://www.luogu.com.cn/problem/P4812)  
  
根据题意，我们知道，对于一个选手 $A$，如果选手 $B$ 的前两轮分数都高于 $A$，那么 $B$ 的排名肯定高于 $A$；同样的，如果选手 $B$ 的前两轮分数都低于 $A$，那么 $B$ 的排名肯定低于 $A$。  
所以对于每个选手 $A$，我们只需统计两轮分数都高于/低于 $A$ 的选手个数，然后再进行计算即可。  

**但是，本题中分数相同的选手排名相同。**  

所以，在统计完上面的情况后，我们要注意：对于两个选手，若分数分别为 $A(x,0)$ 和 $B(x,650)$，那么实际上 $B(x,650)$ 的最低排名等于 $A(x,0)$ 的最高排名。  
这是容易证明的：考虑极端情况，$B$ 如果最后一轮得 $0$ 分，而 $A$ 最后一轮得 $650$ 分，那么他们的分数也持平。而其他情况下 $B$ 的排名肯定不会更差。  

而剩下的情况中，既不存在有一人两轮分数都较高的两个选手，也不存在上面的特殊情况，可以证明，他们的排名考虑上面的统计方法即可。（仍然使用极端情况证明。）  

现在我们来考虑怎么统计。  
> 我们不妨**对第一轮分数排序**，然后对于第二轮分数，使用**树状数组维护**即可。  

> 具体地，对于一个选手 $A(a,b)$，考虑所有第一轮分数**严格大于** $A(a,b)$ 的选手 $B$，用他们的第二轮分数更新树状数组即可。小于同理。  

代码如下：  
```cpp

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn=651;
struct NODE{
	int x,y,id;
}in[500005];
int n;
int c[1005];
int ans1[500005];
int ans2[500005];
int cnt[maxn+5][maxn+5];
inline void input(int &x){
	x=0;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
	int p=1;if (ch=='-') p=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();x*=p;
}
void write(int x){
	if (x<10){
		putchar((char)(x+'0'));return;
	}
	write(x/10);
	putchar((char)(x%10+'0'));
}
inline void output(int x,char c){
	if (x<0) {putchar('-');x*=-1;}
	write(x);putchar(c);
}
bool cmp(NODE _1,NODE _2){//排序
	return _1.x^_2.x?_1.x>_2.x:_1.y>_2.y;
}
int lowbit(int x){
	return x&(-x);
}
inline void update(int p){
	while(p<=maxn){
		++c[p];
		p+=lowbit(p);
	}
}
inline int query(int p){
	int res=0;
	while(p>0){
		res+=c[p];
		p-=lowbit(p);
	}
	return res;
}
int main(){
	freopen("compete.in","r",stdin);
	freopen("compete.out","w",stdout);
	input(n);
	for (int i=1;i<=n;i++){
		input(in[i].x);input(in[i].y);
		++in[i].x;++in[i].y;//为了树状数组写的方便，这里加个1
		in[i].id=i;++cnt[in[i].x][in[i].y];
	}
	sort(in+1,in+n+1,cmp);//排序
	int p=0;//记录上一个第一轮分数不同的位置
	for (int i=1;i<=n;i++){
		int now=query(in[i].y);//第一轮分数大于，第二轮分数小于等于i的选手个数
		int now1=p-now;//用第一轮分数大于i的选手总数减去now，就是两轮分数都大于i的选手个数
		ans1[in[i].id]=now1+1;//now1个选手比i分数高，i至少是(now1+1)名
		if (in[i].x!=in[i+1].x){//第一轮分数出现不同，更新树状数组
			while(p<i){
				update(in[++p].y);//更新
			}
		}
	}
	memset(c,0,sizeof(c));
	int q=n+1;//记录上一个第一轮分数不同的位置
	for (int i=n;i>0;i--){
		int now2=query(in[i].y-1);//两轮分数都小于i的选手个数
		ans2[in[i].id]=n-now2;//now2个选手比i分数低，i至多是(n-now2)名
		if (in[i].x==maxn) ans2[in[i].id]-=cnt[1][in[i].y];//特殊情况：650的可以被0的追平
		if (in[i].y==maxn) ans2[in[i].id]-=cnt[in[i].x][1];//特殊情况：650的可以被0的追平
		if (in[i].x!=in[i-1].x){//第一轮分数出现不同，更新树状数组
			while(q>i){
				update(in[--q].y);//更新
			}
		}
	}
	for (int i=1;i<=n;i++){//输出
		output(ans1[i],' ');output(ans2[i],'\n');
	}
	return 0;
}```

---

## 作者：joseph_cheung (赞：6)

二维前缀和

选手A的成绩$a1$, $a2$，那么我们将统计数组$M[a1][a2]$增加1。
统计M的前缀和$pre$，后缀和$suf$。A选手的最好排名就是$suf[a1+1][a2+1] + 1$。
X选手的最坏成绩为$n-suf[a1-1][a2-1]$吗？假设有小X的成绩$(a, 0)$，小Y的成绩$(a, 650)$。小Y的最坏成绩也是X的最好成绩，因为小X第三次如果取得$650$分，最多与小Y持平。
```cpp
#include <cstdio>
#define RG register
#define FORE(i,o,n) for(RG int i=(o);i<=(n);++i)
#define DFORE(i,o,n) for(RG int i=(o);i>=(n);--i)
const int MAXN = 500000+10, MAXS=651;
int M[MAXS+5][MAXS+5],a1[MAXN+5],a2[MAXN+5],pre[MAXS+5][MAXS+5],suf[MAXS+5][MAXS+5],n;
int main()
{
    scanf("%d",&n);FORE(i,1,n)
    scanf("%d%d",&a1[i],&a2[i]),++M[++a1[i]][++a2[i]];
    FORE(i,1,MAXS)
    {
        RG int tmp=0;
        FORE(j,1,MAXS)
            pre[i][j]=pre[i-1][j]+(tmp+=M[i][j]);
    }
    DFORE(i,MAXS,1)
    {
        RG int tmp=0;
        DFORE(j,MAXS,1)
        suf[i][j]=suf[i+1][j]+(tmp+=M[i][j]);
    }
    FORE(i,1,n)
        printf("%d %d\n",suf[a1[i]+1][a2[i]+1]+1,n-pre[a1[i]-1][a2[i]-1]-(a1[i]==MAXS)*M[1][a2[i]]-(a2[i]==MAXS)*M[a1[i]][1]);
}
```

---

## 作者：yi_hr (赞：3)

## 思路
首先看到 $n$ 到 $5\times 10^5$，乍一看没什么思路，但我们发现值域只有 $[0,650]$，一般这种 $n$ 很大但值域很小的题就要从值域入手来考虑贡献。  
我们对每个 $i,j\in[0,650]$ 考虑到底什么情况时其他情况会小于（或大于）它，从而对其产生贡献。  
1. 对于可能排名比它靠前的情况，即它的最小排名：  
只有两次比赛都大于它才一定在它前面。
2. 对于可能排名比它靠后的情况，即它的最大排名：  
就是总体减去所有一定小于它的，即两次比赛都小于它。注意，如果它的某一次比赛的分数为 $650$，即成绩为 $a_1=(i,650)$ 如果同时存在另一个人的成绩为 $a_2=(i,0)$,则有 ${a_1}_{min}={a_2}_{max}$ 所以这种情况就多算了，应该减去。  

我们记录一个前缀和 $sum_{i,j}$ 与一个后缀和 $suf_{i,j}$ 分别表示 $b_{i,j}$ 数组（$(i,j)$ 有多少个）的前/后缀和，这：  
最小排名=`suf[i][j]+1`。  
最大排名=`n-sum[i][j]-((i==maxx)?(b[1][j]):0)-((j==maxx)?(b[i][1]):0)`。

## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
#define LINF 0x3f3f3f3f3f3f3f3f
#define debug puts("I will ak ioi");
using namespace std;
constexpr int N = 1e6 + 9, M = 655, maxx = 651;
int n, m;
struct node {
    int a, b, id;
} a[N];
int sum[M][M], suf[M][M], b[M][M];

int main() {
    // freopen(".in", "r", stdin);
    // freopen(".out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].a >> a[i].b;
        sum[++a[i].a][++a[i].b]++;
        suf[a[i].a][a[i].b]++;
        b[a[i].a][a[i].b]++;
    }
    for (int i = 1; i < M; i++) {
        for (int j = 1; j < M; j++) {
            sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
        }
    }
    for (int i = M - 1; i >= 1; i--) {
        for (int j = M - 1; j >= 1; j--) {
            suf[i][j] += suf[i + 1][j] + suf[i][j + 1] - suf[i + 1][j + 1];
        }
    }
    for (int i = 1; i <= n; i++) {
        cout << suf[a[i].a + 1][a[i].b + 1] + 1 << " "
             << n - sum[a[i].a - 1][a[i].b - 1] -
                    (a[i].a == maxx) * (b[1][a[i].b]) -
                    (a[i].b == maxx) * (b[a[i].a][1])
             << "\n";
    }
    return 0;
}
/*
 ／|、
('、.7
 |、~丶
 じしf_,)ノ
*/
```

---

## 作者：一中益达 (赞：2)

# 树状数组可做
###### ~~细节巨多~~
首先我们先来考虑一下n方的做法

对于两个成绩的排序，很容易想到先对一组进行排序，再对另一组比较的做法。

（以下均为对第一轮成绩由高到低排序）

#### 对于一个人的最高排名，很容易得出以下结论：

### ① 在A前面且一轮和二轮成绩都比A高的人B，A不可能排在B前

### ② 第一轮成绩小于等于A的B，不论第二轮成绩，A能够排在B前面或与之并列
### （比如A：233 0 650 B:233 650 0）

#### 对于一个人的最低排名，细节稍微多点，可得出以下结论：

### ① 在A前面的人毫无疑问排名都可以排在A前面
### ② 在A后面的人只要不是两轮成绩都低于A排名都可以排在A前面
### ③ A、B第一轮成绩相等时，如果A第二轮成绩为650而B第二轮成绩为0，B排名最多也只能与A并列（即B不会拉低A最低排名）

### ④ A、B第二轮成绩相等时，如果A第一轮成绩为650而B第一轮成绩为0，B排名最多也只能与A并列（即B不会拉低A最低排名）


这样n方算法就出来了
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<queue>
using namespace std;
int ansmax[500050];
int ansmin[500050];
struct node
{
	int a,b,cnt;
}sex[500050];
bool cmp(node a,node b)
{
	return a.a==b.a?a.b>b.b:a.a>b.a;
}
int n;
int read()
{
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		sex[i].a=read();
		sex[i].b=read();
		sex[i].cnt=i;
	}
	sort(sex+1,sex+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		int cnt1=1;
		int cnt2=i;
		for(int j=1;j<i;j++)
		{
			if(sex[i].a<sex[j].a&&sex[i].b<sex[j].b) cnt1++;
		}
		for(int j=i+1;j<=n;j++)
		{
			if(sex[i].a>sex[j].a&&sex[i].b>sex[j].b) continue;
			if(sex[i].a==sex[j].a&&sex[i].b==650&&sex[j].b==0) continue;
			if(sex[i].a==650&&sex[j].a==0&&sex[i].b==sex[j].b) continue;
			cnt2++;
		}
		ansmax[sex[i].cnt]=cnt1;
		ansmin[sex[i].cnt]=cnt2;
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d %d\n",ansmax[i],ansmin[i]);
	}
	return 0;
}
```
## 进入正题

考虑了n方算法，nlog（n）也就相对简单了

如何想到用树状数组？~~（不要问我我也不知道可能是看到这个数据范围就想用）~~

将最高排名和最低排名分开计算。

### 对于一个人的最高排名，比较简单：

我们还是将成绩按照第一轮从高到低排

对于一个人A，我们只需考虑A前面的人（毕竟是最高排名嘛）

排在A前面的人，第一轮成绩要么高于A或者等于A

### 我们先考虑高于A的情况

想到开一个树状数组存储第二轮得分（毕竟值域很小）

从前到后扫，把每一个人的第二轮得分存入树状数组

对于A，ta前面的人的第二轮得分已经存入树状数组

根据n方算法，我们只需查询第二轮成绩比A高的，这些人一定会排在A前面

### 我们再考虑和A成绩一样的情况

根据n方算法，第一轮成绩和A一样，不论第二轮成绩A都可以排在前面或并列

考虑和成绩高于A的一样的做法  我们只需要把这些第一轮成绩相等的人剔除即可（这个比较简单实在不会可以看代码）

### 对于一个人的最低排名...~~非常麻烦~~

这次我们将第一轮成绩由低到高排列

对于一个人A，我们只需考虑A前面的人

同样分为成绩比A低或和A成绩一样的两种情况

### 我们先考虑成绩比A低的情况

#同样将前面的人的第二轮成绩存入树状数组（别忘了先memset）

先不考虑特例，和最高排名想法一样，查询第二轮成绩比A高或等于的A的人，可以排在A前面

### 我们再考虑成绩和A相等的情况

同样的..也要剔除...和上面一样实在懒得写了（精神崩溃）

# 真正进入正题

开始考虑特例....

特例包含在刚才的算法中，考虑如何剔除

根据n方算法，③特例和④特例我们逐个考虑

### ③特例

这个比较简单，直接设一个变量表示在同一个第一轮成绩下有多少第二轮成绩为0的.... 直接相减即可

### ④特例

我们考虑设一个变量spp，一开始它的位置在1，我们需要剔除的是第二轮成绩与A相等的，由于我们的第二轮成绩在第一轮成绩相同的情况下也是从低到高排列，我们需要算出第一轮成绩是0并且第二轮成绩和A相等的人数，可以考虑这么做：

```cpp
int cntx=0;
while(spp<n)
{
	if(sex[spp].a!=0||sex[spp].b>=sex[i].b) break;
	spp++;
}
int instead=spp;
while(sex[i].b==sex[instead].b&&sex[instead].a==0) 
{
	instead++;
	cntx++;
}				
ansmin[sex[i].cnt]-=cntx;
```
sex[ ].a表示第一轮成绩，.b表示第二轮成绩

spp直接找到一个第二轮成绩大于或等于A的人

再用instead算个数（当然可以为零）



------------


如果你只做到这里，你会惨得23分（也有可能只有我)

还差最后一步..

相同合并

如果两个人成绩完全相同，那么他们的最高最低排名也必然是一样的，

你可以拿第二个样例加一个和其中一个人一样的成绩试试，看一不一样...

最后再强调一下烂大街的细节，得分是有0的，直接存入树状数组会TLE

最后附上"AC"代码（我目前也就想到这么多，估计很快就会被hack吧）

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct node
{
	int a,b,cnt;
}sex[500050];
int c[1050];
int n;
int ansmax[500050];
int ansmin[500050];
int lowbit(int x)
{
	return x&(-x);
}
void add(int x)
{
	while(x<=651)
	{
		c[x]++;
		x+=lowbit(x);
	}
}
int ask(int x)
{
	int ans=0;
	while(x>0)
	{
		ans+=c[x];
		x-=lowbit(x);
	}
	return ans;
}
int read()
{
	int x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x;
}
bool cmp1(node a,node b)
{
	return a.a==b.a?a.b>b.b:a.a>b.a;
}
bool cmp2(node a,node b)
{
	return a.a==b.a?a.b<b.b:a.a<b.a;
}
int place[651];
int spp=1;
int cnt;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		sex[i].a=read();
		sex[i].b=read();
		sex[i].cnt=i;
	}
	sort(sex+1,sex+1+n,cmp1);
	sex[0].a=-10;
	sex[0].b=-10;
	for(int i=1;i<=n;i++)
	{
		if(sex[i].a!=sex[i-1].a) place[sex[i].a]=i;
		if(sex[i].a==sex[i-1].a&&sex[i].b==sex[i-1].b)
		{
			ansmax[sex[i].cnt]=ansmax[sex[i-1].cnt];
			add(sex[i].b+1);
			continue;
		}
		ansmax[sex[i].cnt]=1+ask(650+1)-ask(sex[i].b+1)-(i-place[sex[i].a]);
		add(sex[i].b+1);
	}
	sort(sex+1,sex+1+n,cmp2);
	memset(c,0,sizeof(c));
	memset(place,0,sizeof(place));
	for(int i=1;i<=n;i++)
	{
		if(sex[i].a!=sex[i-1].a)
		{
			place[sex[i].a]=i;
			cnt=0;
		}
		if(sex[i].b==0) cnt++;
		if(sex[i].a==sex[i-1].a&&sex[i].b==sex[i-1].b)
		{
			ansmin[sex[i].cnt]=ansmin[sex[i-1].cnt];
			add(sex[i].b+1);
			continue;
		}
		ansmin[sex[i].cnt]=n-i+1+ask(650+1)-ask(sex[i].b-1+1)+i-place[sex[i].a];
		add(sex[i].b+1);
		if(sex[i].a==650)
		{
			int cntx=0;
			while(spp<n)
			{
				if(sex[spp].a!=0||sex[spp].b>=sex[i].b) break;
				spp++;
			}
			int instead=spp;
			while(sex[i].b==sex[instead].b&&sex[instead].a==0) 
			{
				instead++;
				cntx++;
			}				
			ansmin[sex[i].cnt]-=cntx;
		}
		if(sex[i].b==650)
		{
			ansmin[sex[i].cnt]-=cnt;
		}
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d %d\n",ansmax[i],ansmin[i]);
	}
	return 0;
}
```
![](D:\Backup\Documents\2345截图\2345截图20200415110213)




---

## 作者：y3kkc (赞：0)

# 题意
见[洛谷](https://www.luogu.com.cn/problem/P4812)。  
# 分析  
很显然最高排名和最低排名互不干扰。  

我们先考虑最高排名。  

对此，我们可以枚举每个人 $i$，再枚举 $j$ 对 $i$ 的贡献。  

设第 $i$ 人的第一、二场得分分别为 $a_i$，$b_i$，第 $j$ 人的第一、二场 $a_j$，$b_j$。  

我们可以尝试统计一定比 $i$ 高的人个数。  

这里先给出结论，**当且仅当** $a_i < a_j$ 且 $b_i < b_j$ 时$j$ 会对 $i$ 做贡献。   

充分性很显然，至于必要性，我们不妨设 $a_i \ge a_j$，那么最坏的情况是 $a_i = a_j$，且 $b_i = 0$，$b_j = 650$。  

此时若 $i$ 考 $650$，$j$ 考 $0$，那么 $j$ 与 $i$ 的总分会持平，并不会比 $i$ 高。必要性得证。  

此时就变成了一个二维偏序的问题，第一维用排序解决，第二维用树状数组解决即可。 

最低排名的情况也相近，我们统计一定比 $i$ 总分低的人。  

最后减去这个数就是 $i$ 的最低排名。  

同样的 $a_i > a_j$ 且 $b_i > b_j$，$j$ 会对 $i$ 做贡献。  

然后打完交上去喜提 $72pts$。  

注意到总分相同时 $i$ 的排名并不会变低，我们在统计时也把这部分算进去了。  

于是我们最后把这一部分加回去。  

发现当且仅当 $a_i = a_j$ 且 $b_i = 650$，$b_j = 0$ 时会多减。  

于是我们对 $a_i$ 开个桶，枚举相等的 $a_i$ 统计即可。  

记得对 $b_i$ 进行同样的操作。  

# 代码  
```cpp  
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	for (; c < 48 || c > 57; c = getchar()) if (c == '-') f = -f;
	for (; c >= 48 && c <= 57; c = getchar()) x = (x << 3) + (x << 1) + (c & 15);
	return x * f;
}
const int N = 5e5 + 9;
int n;
int ans1[N], ans2[N];
struct node {
	int b, id;
	node (int b = 0, int id = 0):b(b), id(id){}
};
vector<node> g[659], g1[659];
struct BIT {
	int c[659];
	void init() { memset(c, 0, sizeof c); }
	void add(int x) { for (; x <= 651; x += x & -x) ++c[x]; }
	int ask(int x) { int res = 0; for (; x; x &= x - 1) res += c[x]; return res; }
	int ask(int l, int r) { return ask(r) - ask(l - 1); }
} bit;
int main() {
	n = read();
	for (int i = 1; i <= n; ++i) {
		int a = read() + 1, b = read() + 1;//细节+1，否则可能会死循环 
		g[a].push_back(node(b, i));
		g1[b].push_back(node(a, i));
	}
	bit.init();
	for (int i = 651; i; --i) {
		for (auto& t : g[i]) ans1[t.id] = bit.ask(t.b + 1, 651) + 1;
		for (auto& t : g[i]) bit.add(t.b);
	}
	bit.init();
	for (int i = 1; i <= 651; ++i) {
		for (auto& t : g[i]) ans2[t.id] = n - bit.ask(t.b - 1);
		for (auto& t : g[i]) bit.add(t.b);
	}
	for (int i = 1; i <= 651; ++i) {//加回多减的部分 
		int cnt = 0;
		for (auto& t : g[i]) cnt += t.b == 1;
		for (auto& t : g[i]) if (t.b == 651) ans2[t.id] -= cnt;
		cnt = 0;
		for (auto& t : g1[i]) cnt += t.b == 1;
		for (auto& t : g1[i]) if (t.b == 651) ans2[t.id] -= cnt;
	}
	for (int i = 1; i <= n; ++i) printf("%d %d\n", ans1[i], ans2[i]);
	return 0;
}
```   
# 总结  
解决该问题的关键点在于：  

* 二维偏序。  

* 分数相同时的细节处理。

---


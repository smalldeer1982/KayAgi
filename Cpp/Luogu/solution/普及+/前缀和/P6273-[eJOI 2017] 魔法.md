# [eJOI 2017] 魔法

## 题目描述

给定一个长度为 $n$ 的字符串 $S$。设 $S$ 中不同的字符数为 $k$ 。

定义字符串的子串为该字符串某一连续段。

而 ***有魔法的子串*** 被定义为 $S$ **的某一非空子串，满足该子串中不同的字符数为** $k$ **，且每个字符的出现的次数都相同**。

你需要求出给定字符串 $S$ 的不同的 有魔法的子串 的个数。

若两个子串的左右端点不同，则这两个子串不同。

## 说明/提示

#### 【输入输出样例解释】

**样例 1 解释**

- 满足条件的子串有： $\texttt{abc},\texttt{cba},\texttt{abc},\texttt{abccba}$

**样例 2 解释**

- 仅子串 $\texttt{abcABC}$ 为 有魔法的子串（区分大小写，即 $\texttt{a}\ne \texttt{A}$）。

**样例 3 解释**

- 其中一个是 $\texttt{SwSwwS}$。

#### 【数据规模与约定】

**本题采用多测试点捆绑测试，共有 4 个子任务**。

- Subtask 1（10 points）：$2\le n\le 100$。
- Subtask 2（20 points）：$2\le n\le 2\times 10^3$。
- Subtask 3（30 points）：$2\le n\le 10^5,k=2$ （即 $S$ 中只有两种字符）。
- Subtask 4（40 points）：无其他限制。

对于所有数据，保证 $2\le n\le 10^5$，字符集为 $ [\texttt{a},\texttt{z}] \cup [\texttt{A},\texttt{Z}]$

#### 【说明】

原题来自：[eJOI 2017](www.ejoi.org) Problem A [Magic](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/magic_statement-en.pdf)

翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)

## 样例 #1

### 输入

```
8
abccbabc```

### 输出

```
4```

## 样例 #2

### 输入

```
7
abcABCC```

### 输出

```
1```

## 样例 #3

### 输入

```
20
SwSSSwwwwSwSwwSwwwwS```

### 输出

```
22```

# 题解

## 作者：5k_sync_closer (赞：24)

提供一个小常数 $O(nk\log n)$ 实现。
# 思路
根据题意，子串 $S_{[l,r]}$ 是有魔法的，当且仅当 $\forall k\in S,\sum\limits_{i=l}^r[S_i=k]$ 都相等。

维护前缀和 $s_{x_k}=\sum\limits_{i=1}^x[S_i=k]$，则 $S_{[l,r]}$ 是有魔法的，当且仅当 $\forall k\in S,s_{r_k}-s_{l-1_{k}}$ 都相等。

把 $s_{r_a}-s_{l-1_a}=s_{r_b}-s_{l-1_b}$ 变形，得到 $s_{r_a}-s_{r_b}=s_{l-1_a}-s_{l-1_b}$，

任意选择一个 $A\in S$，则 $S_{[l,r]}$ 是有魔法的，当且仅当 $\forall k\in S,s_{r_k}-s_{r_A}=s_{l-1_k}-s_{l-1_A}$。

维护 $v_x=\{s_{x_k}-s_{x_A}|k\in S\}$，则 $S_{[l,r]}$ 是有魔法的，当且仅当 $v_r=v_{l-1}$。

考虑对于每个 $r$，求出满足 $v_r=v_{l-1}$ 的 $l$ 的个数。

正序枚举 $r$，维护一个 `map`，计算出 $v_r$ 后，将答案加上 `map` 中 $v_r$ 的个数，再将 $v_r$ 加入 `map`。
# 代码
一些细节：

1. 注意到 `vector` 自带比较运算符，所以可以开 `map<vector<int>, int>`。
2. 注意到需要将字符作为 `vector` 的下标，所以需要离散化。
3. 注意到 $\forall x\in [1,n],v_x$ 只会用一次，所以可以动态更新 $v_x$。
4. 注意到存在 $l=1,l-1=0$ 的情况，所以需要事先将全 $0$ 集合加入 `map`。
5. 注意取模。注意答案开 `long long`。

感觉其他题解都把代码写复杂了。
```cpp
#include <bits/stdc++.h>
#define h(x) lower_bound(a, a + k, x) - a
using namespace std;
vector<int> v;map<vector<int>, int> m;
int n, k;long long q;char a[100050], s[100050];
int main()
{
    scanf("%d%s", &n, s);strcpy(a, s);sort(a, a + n);
    m[v = vector<int>(k = unique(a, a + n) - a, 0)] = 1;
    for (int i = 0; i < n; ++i)
    {
        if (s[i] != a[0]) ++v[h(s[i])];
        else {for (auto &x : v) --x;++v[0];}
        (q += m[v]++) %= 1000000007;
    }
    return printf("%lld", q), 0;
}
```
目前最优解 rk 1。

---

## 作者：一扶苏一 (赞：10)

## 【P6273】 [eJOI2017]魔法

### Solution

写了个看起来不会被卡的暴力交上去过了，然后看看[官方题解](http://ejoi.org/wp-content/uploads/2018/05/Day_1_analyses_en.zip)发现这居然就是正解……

首先考虑子任务三，字符集大小只有 $2$ 的情况，不妨设字符集为 $\{\texttt a, \texttt b\}$，不失一般性。

考虑枚举右端点，对于一个右端点 $r$，一个合法的左端点 $l$ 应该满足 $l$ 到 $r$ 的 $\texttt a$ 的个数等于 $\texttt b$ 的个数。我们对 $a$ 和 $b$ 的个数分别求前缀和，那么即为 $sa_r - sa_{l - 1} = sb_r - sb_{l - 1}$，其中 $sa$ 代表 $\texttt a$ 的前缀和，$sb$ 同理。

对上式移项得到 $sa_r - sb_r = sa_{l - 1}- sb_{l - 1}$。换句话说，对于一个合法的区间，$l, r$ 两个位置的 $\texttt a, \texttt b$ 前缀和的差值一定相同。由于上述推导是可逆的，所以其逆命题也成立。因此这是一个充要条件。

于是从左到右枚举 $r$，用一个桶维护 $sa_i - sb_i$ 的值的个数即可通过该子任务，时间复杂度 $O(n)$。

对于子任务四，发现字符集扩大到了 $52$，但是注意到对于所有的字符 $\texttt x$，都可以用与子任务三相同的证明方式证明 $sx_r - sa_r = sx_{l - 1}- sa_{l - 1}$ 成立且必要。因此对于每个字符，维护它的前缀和减去 $\texttt a$ 的前缀即可。考虑查询合法左端点数，可以在右端点扫过的时候将这 $k$ 个差值作为一个元素插入到 `std::map` 中，查询时直接查询对应元素的个数即可。时间复杂度 $O(n k \log n )$。看起来很大实则根本跑不满，可以通过本题。

当然，如果希望理性愉悦的话，可以用 hash 代替 `std::map`，再用线段树维护对前缀和差值的区间加，即可将复杂度降至 $O(n \log k)$。

另外说句闲话，`std::multiset.count` 的复杂度竟然是 $O(\log size + \text{返回值大小})$……

### Code

```cpp
const int maxn = 100005;
const int maxk = 52;

void Init();
void Calc();

int main() {
  freopen("1.in", "r", stdin);
  Init();
  Calc();
  return 0;
}

int n, t;
char s[maxn];

void Init() {
  static char tmp[maxn];
  qr(n);
  qrs(s + 1);
  for (int i = 1; i <= n; ++i) tmp[i] = s[i];
  std::sort(tmp + 1, tmp + 1 + n);
  t = std::unique(tmp + 1, tmp + 1 + n) - tmp - 1;
  for (int i = 1; i <= n; ++i) s[i] = std::lower_bound(tmp + 1, tmp + 1 + t, s[i]) - tmp - 1;
}

struct Dat {
  int d[maxk];

  bool operator<(const Dat &o) const {
    for (int i = 0; i < t; ++i) if (d[i] != o.d[i]) {
      return d[i] < o.d[i];
    }
    return false;
  }
};
Dat dat[maxn];

struct Cmp {
  inline bool operator()(const int x, const int y) const {
    return dat[x] < dat[y];
  }
};

std::map<int, int, Cmp> mp;

void Calc() {
  ll ans = 0;
  mp[0] = 1;
  for (int i = 1, di = i - 1; i <= n; di = i++) {
    for (int j = 0; j < t; ++j) {
      dat[i].d[j] = dat[di].d[j];
    }
    if (s[i]) {
      ++dat[i].d[s[i]];
    } else {
      for (int j = 1; j < t; ++j) --dat[i].d[j];
    }
    int u = mp[i];
    ans += u;
    mp[i] = u + 1;
  }
  qw(ans % 1000000007, '\n');
}
```





---

## 作者：Berlin_Jacor (赞：8)

放个题面

[P6273 [eJOI2017]魔法](https://www.luogu.com.cn/problem/P6273#submit)

非常妙的一道题

## 一定要认真审题！！！


我一开始就没看见这句话:


>>###  “ 设 S 中不同的字符数为 k ”
---

### 步骤：

1. 求得每一个位置上每个字母的前缀和

2. 标记出现过的字母并找到一枚幸运的j
	这一步很巧妙，任意j都可以，我们称其为幸运的j (doge）

3. 将每个i的前缀和减掉此i中幸运j的前缀和
	可能有点拗口，仔细想想很少女口阿

4. 对上一次操作得到的数组进行排序（使得每个包含式的魔法串相邻）

5. 利用求和公式 $(n-1)*n/2$ 求得答案

主要是步骤2、3很难想，思维难度有点打

---
### $code$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int mod = 1000000007;
const int N = 100010;

struct node
{
  int a[53];
  bool operator <(const node x)const
  {
    for(int i = 0; i < 52; ++i)
      if(a[i] != x.a[i])
        return a[i] < x.a[i];
    return 0;
  }
//细节排序，处理相等情况
  bool operator ==(const node x)const
  {
    for(int i = 0; i < 52; ++i)
      if(a[i] != x.a[i])
        return 0;
    return 1;
  }
}sum[N];

int n, t;
char s[100010];
bool vis[53];

int main()
{
  ios::sync_with_stdio(false);
  cin.tie(NULL),cout.tie(NULL);
  cin>>n>>s + 1;
//步骤1：
  for(int i = 1; i <= n; ++i)
    for(int j = 0; j < 52; ++j)
      if(j < 26 && s[i] - 'a' == j || j >= 26 && s[i] - 'A' == j - 26)
        sum[i].a[j] = sum[i - 1].a[j] + 1;
      else
        sum[i].a[j] = sum[i - 1].a[j];
//步骤2：
  for(int i = 0; i < 52; ++i)
    if(sum[n].a[i]) vis[i] = true, t = i;
//步骤3：
  for(int i = 1; i <= n; ++i)
    for(int j = 0; j < 52; ++j)
      if(vis[j])
        sum[i].a[j] -= sum[i].a[t];
//步骤4：
  sort(sum,sum + n + 1);
//步骤5：
  int ans = 0;
  for(int l = 0, r; l <= n; l = r + 1)
  {
    r = l;
    while(r < n && sum[r + 1] == sum[r])++r;
    int len = r - l + 1;
    ans = (ans + 1ll * len * (len - 1) / 2 % mod) % mod;//n*(n-1)/2
  }
//
  cout<<ans;
  return 0;
}
```
---
另外eJOI这几道题都很好，这道题算比较简单的
### [eJOI](https://www.luogu.com.cn/problem/list?keyword=eJOI&page=1)

谢谢阅读

---

## 作者：YangXiaopei (赞：3)

## Solution:

我们可以把 $k$ 种字母对应成 $k$ 种数字，使得 $k$ 个数字加起来为 $0$ 且任意不足 $k$ 个加起来均不为 $0$。

只要将前 $k - 1$ 种对应成不为 $0$ 的随机数，并将最后一种对应成前 $k - 1$ 的和的相反数就能实现这件事情了。

那现在就能变成另一个问题：有多少个区间的和为 $0$。

我们可以用一个前缀和数组 $d$，那现在这个问题就能再变换一下：有多少 $d_i - d_j = 0$（$j$ 可以为 $0$）。

这个式子不太好处理，我们把它移项一下：有多少 $d_i = d_j$（$j$ 可以为 $0$）。

那我们就可以那个桶记录一下每个 $d_i$ 出现的次数记录在 $mp$ 中，答案即为 $\sum mp_i \times (mp_i - 1) \div 2$。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
int n, k, g[55], f[55], d[100005];
unordered_map<int, int> mp;
int solve(char ch){
	if('A' <= ch && ch <= 'Z'){
		return ch - 'A' + 1;
	}
	else{
		return ch - 'a' + 27;
	}
}
signed main(){
    srand(time(0));
	srand(rand());
	cin >> n >> s;
	s = ' ' + s;
	for(int i = 1; i <= n; ++i){
		int x = solve(s[i]);
		g[x]++;
		if(g[x] == 1){
			k++;
		}
	}
	memset(g, 0, sizeof(g));
	int sum = 0;
	for(int i = 1; i <= n; ++i){
		int x = solve(s[i]);
		g[x]++;
		if(g[x] == 1){
			k--;
			if(k == 0){
				f[x] = -sum;
			}
			else{
				f[x] = rand();
				sum += f[x];
			}
		}
	}
	mp[0] = 1;
	for(int i = 1; i <= n; ++i){
		int x = solve(s[i]);
		d[i] = d[i - 1] + f[x];
		mp[d[i]]++;
	}
	sum = 0;
	for(auto i : mp){
		int x = i.second * (i.second - 1) / 2;
		x %= 1000000007;
		sum = (sum + x) % 1000000007;
	}
	cout << sum;
	return 0;
}
```

---

## 作者：IcyFoxer_XZY (赞：3)

#### [题目传送门](https://www.luogu.com.cn/problem/P6273)

### 题目

- 给定一个长度为 $n$ 的字符串 $S$ 。设 $S$ 的不同的字符数为 $k$ 。

- 定义字符串的子串为该字符串某一连续段。

- 而有魔法的子串被定义为 $S$ 的某一非空子串，满足该子串中不同的字符数为 $k$ ，且每个字符的出现的次数都相同。

- 你需要求出给定字符串 $S$ 的不同的有魔法的子串的个数。

- 若两个子串的左右端点不同，则这两个子串不同。

- 对于所有数据，保证 $2\le n\le 10^5$  ，字符集为 $[ a , z ] ∪ [ A , Z ]$ 。

### 分析

- 会发现一个区间如果满足条件，那么每种字符前缀和在 $r$ 位置和  $l-1$ 位置之差都相等。

- 换种角度考虑， $r$ 位置和 $l-1$ 位置下，每两种字符前缀和之差都相等，

- 所以可以把前缀和每个位置的各个字符和字符 $a$ 的值之差列出来，相同的两个位置代表的区间即符合条件，直接排序即可。

**code：**
```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=1e5+5;
char s[N];
int f[55],p[55],r,n,ans,t;
struct node{
	int p[55];
}a[N];
bool cmp(node x,node y){//结构体排序 
	for(int i=0;i<r;++i){
		if(x.p[i]<y.p[i])return true;
		if(x.p[i]>y.p[i])return false;
	}
	return false;
}
signed main(){//main可以返回signed，但不能返回long long 
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i=1;i<=n;++i){
		if(s[i]<='Z')p[s[i]-'A']=1;
		else p[s[i]-'a'+26]=1;
	}
	for(int i=0;i<52;++i){
		if(p[i])p[i]=r,r++;
	}
	for(int i=1;i<=n;++i){
		if(s[i]<='Z')f[p[s[i]-'A']]++;
		else f[p[s[i]-'a'+26]]++;
		for(int j=0;j<r;++j)a[i].p[j]=f[j]-f[0];
	}
	sort(a,a+n+1,cmp);
	for(int i=0;i<=n;++i){
		if(i==0||cmp(a[i-1],a[i]))t=1;
		else{
			ans+=t;
			t++;
		}
	}
	printf("%lld",ans%1000000007);//记得开long long 
	return 0;
}
```
### 注意：开long long！
Bye！

---

## 作者：NBest (赞：2)

原题链接 [魔法](https://www.luogu.com.cn/problem/P6273)
## 题目分析
题目的意思就是让我们求每个字母出现次数相同且不为空的子串的个数。

## 基本思路

然后我们能想到维护一个前缀和数组，然后判断区间是否满足条件只需要判断每个颜色是否出现次数都相同即可，可 $O(n^2k)$ 实现。

但是由于我之前双指针打多了，然后想到用两个指针来维护每个颜色都出现了的区间（因为这个区间颜色全部出现是满足魔法子串的必要条件）。然后再用跳格的方式先找到第一个满足条件的 $r$，此时如果之后的从这个 $l$ 为起点的区间为魔法子串，显然其 $r$ 都得在第一个满足条件的魔法子串上加上 $k$ 的正整数倍。

这仅仅只是基于暴力的一个小优化，显然复杂度还不够优，计算次数还是大于方案数。接下来考虑一点点转移，我们设 $f[i]$ 为以 $i$ 为终点的满足条件的子串个数，显然，当我区间 $l,r$ 满足条件时，我的 $f[r]=f[r]+f[l-1]+1$。

这个复杂度不稳定，数据水基本上就可以过了（然而被卡了两个点）。

### Code 1
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
unordered_map<char,int>S;
int n,cnt,sum[56][100005];
string ss;
ll f[100005];
bool check_appear(int l,int r){//全部元素出现
    for(int i=1;i<=cnt;i++){
        if(!(sum[i][r]-sum[i][l-1]))return 0;
    }
    return 1;
}
bool check_num(int l,int r){//满足条件
    for(int i=2;i<=cnt;i++){
        if(!(sum[i][r]-sum[i][l-1]==sum[i-1][r]-sum[i-1][l-1]))return 0;
    }
    return 1;
}
int nex_num(int l,int r){//跳格
    int maxx=0;
    for(int i=1;i<=cnt;i++){
        maxx=max(maxx,sum[i][r]-sum[i][l-1]);
    }
    int res=0;
    for(int i=1;i<=cnt;i++){
        res+=maxx-(sum[i][r]-sum[i][l-1]);
    }
    return r+res;
}
int main(){
    cin>>n>>ss;
    for(int i=0;i<n;i++){
        if(!S[ss[i]])S[ss[i]]=++cnt;//用了个map存序号（小题大做）
        sum[S[ss[i]]][i+1]+=1;
        for(int j=1;j<=cnt;j++){
            sum[j][i+1]+=sum[j][i];//前缀和
        }
    }
    for(int l=1,r=1;r<=n;l++){
        while(!check_appear(l,r)&&r<=n)r++;//必要条件
        if(r>n)continue;
        int R=r;
        while(!check_num(l,R)&&R<=n)R=nex_num(l,R);//找第一个满足条件的区间
        if(R>n)continue;
        (f[R]+=f[l-1]+1)%=mod;//小小的转移
    }
    ll ans=0;
    for(int i=1;i<=n;i++){
        (ans+=f[i])%=mod;//累加
    }
    cout<<ans;
}
```

### 进一步优化
我们观察到我们的 $r$ 的跳格的复杂度是不稳定的，以及这个双指针操作也是冗余的。

然后想起教练常谈多看部分分，通过观察第三个 $k=2$ 的部分分，想到 $sum_a [r]-sum_a[l-1]=sum_b[r]-sum_b[l-1]$，即为区间满足的条件，左右交换，可以得到 $sum_a [r]-sum_b[r]=sum_a[l-1]-sum_b[l-1]$。

那发现只要对于一个区间，任意两个颜色都满足以上条件的话也能满足条件，然而直接转移常数太大，我们发现对于颜色 $x$，设字符串中存在字符 $c$，只要对于每个颜色都满足 $sum_x[r]-sum_c[r]=sum_x[l-1]-sum_c[l-1]$ 都成立，我们就可以通过这个式子通过小学加减推广到全部的式子使其也满足对于任意两个颜色 $x,y$ 也满足 $sum_x [r]-sum_y[r]=sum_x[l-1]-sum_y[l-1]$。

然后我们从后往前递推，用 $nex$ 数组记录每个数最近的满足条件的 $r$ 值，即可将每次查询第一个 $r$ 优化到 $O(1)$ 。

那怎么存呢？用万能的 `unordered_map` 和哈希表即可。

## Code 2
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod=1e9+7;
unordered_map<char,int>S;
unordered_map<ull,int>W;
int n,cnt,sum[56][100005],nex[100005];
string ss;
ll f[100005];
ull p[56];
ull gett(int x){
    ull res=0;
    for(int i=2;i<=cnt;i++){
        if(sum[i][x]-sum[1][x]>0)res=res+p[i-2]*(ull)(sum[i][x]-sum[1][x]);
        else res=res-p[i-2]*(ull)(sum[1][x]-sum[i][x]);
    }//哈希值的转换（采用unsigned long long 自然溢出）
    return res;
}
int main(){
    cin>>n>>ss;
    p[0]=1;
    for(int i=1;i<=53;i++){
        p[i]=p[i-1]*257;//存哈希乘值
    }
    for(int i=0;i<n;i++){
        if(!S[ss[i]])S[ss[i]]=++cnt;
        sum[S[ss[i]]][i+1]+=1;
        for(int j=1;j<=cnt;j++){
            sum[j][i+1]+=sum[j][i];
        }
    }
    for(int i=n;~i;--i){
        ull o=gett(i);
        if(W[o])nex[i+1]=W[o];//注意这里i点满足应该转移到i+1
        W[o]=i;
    }
    for(int l=1;l<=n;l++){
        if(!nex[l])continue;
        int R=nex[l];
        (f[R]+=f[l-1]+1)%=mod;//超级精简稳定的转移
    }
    ll ans=0;
    for(int i=1;i<=n;i++){
        (ans+=f[i])%=mod;
    }
    cout<<ans;
}
```
感谢你看我这个蒟蒻写的文章，希望对你的理解有帮助！

---

## 作者：Nuyoah_awa (赞：2)

### 题目分析

首先考虑暴力，我们枚举子串的左右端点，然后判断这个子串是不是魔法子串，时间复杂度 $\mathcal O(n ^ 3 \times k)$，肯定会挂。

我们发现当一个子串为魔法子串时，它所有的字符个数相同，我们可以运用前缀和来判断一个子串是否是魔法子串，具体方法如下：

首先，我们定义 $f_{i, j}$ 为到第 $i$ 个字符为止，第 $j$ 个字符出现的次数。

一个子串 $s_l \sim s_r$ 中，第 $i$ 个字符出现的次数为 $f_{r, j} - f_{l, j}$，所以当一个子串 $s_l \sim s_r$ 中，$\sum\limits_{i = 1}^{i \le k}f_{r, i} - f_{l, i}$ 都相等时，这个子串是魔法子串。

这样时间复杂度就被优化到了 $\mathcal O(n^2 \times k)$ 的。但是依旧过不了。

于是我们考虑类似字符串哈希的做法，我们把上述公式变形一下，可以得出：
$$\because \ \ \ \ \ \ \sum\limits_{i = 1}^{i \le k}f_{r, i} - f_{l, i} \ \ \ $$
$$\therefore \ \ \ \ \ \sum\limits_{i = 1}^{i \le k}f_{r, i} = f_{l, i} + m$$
$$\therefore \ \ \ \sum\limits_{i=2}^{1\le k}f_{r, i} - f_{r, i-1} = f_{l, i} - f_{l, i-1}$$
$$\therefore \ \ \ \ \ \ \ \ \ \sum\limits_{i=2}^{1\le k}f_{r, i} - f_{r, 1} = f_{l, i} - f_{l, 1}$$

于是，我们可以枚举 $\forall i \in [1, n]$，我们将 $\sum\limits_{j = 2}^{j \le n} f_{i, j} - f_{i, 1}$ 用 $\operatorname{vector}$ 打包作为哈希值，存入哈希数组 $Hash$ 中，每枚举一个点，就看与其哈希值相同的点有几个，答案则为其值累加，即：

$$ans = \sum\limits_{i = 1}^{i \le n}Hash_i$$

### code
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <cstring>
const int MOD = 1e9 + 7, N = 1e5 + 5;
int n, k, a[N], f[N][60], cnt[N], ans;
string s;
vector <int> v;
map <vector<int>, int> Hash;
int change(char ch)
{
	if(ch >= 'A' && ch <= 'Z')
		return ch - 'A';
	return ch - 'a' + 26;
}
int main()
{
	scanf("%d", &n);
	cin >> s;
	for(int i = 0;i < n;i++)
	{
		if(cnt[change(s[i])] == 0)
			cnt[change(s[i])] = ++k;
		a[i+1] = cnt[change(s[i])];
	}
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= k;j++)
			f[i][j] = f[i-1][j] + (j == a[i]);
	v.clear();
	for(int i = 1;i <= k;i++)
		v.push_back(0);
	Hash[v] = 1;
	for(int i = 1, x;i <= n;i++)
	{
		v.clear();
		x = f[i][1], v.push_back(0);
		for(int j = 2;j <= k;j++)
			v.push_back(f[i][j] - x);
		(ans += Hash[v]) %= MOD, Hash[v]++;
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：xs_siqi (赞：1)

首先暴力的思路肯定是枚举每一个子串，然后暴力判断一下是否合法。鉴于字符只有 $k$ 个，$k\leq 52$，使用前缀和优化判断过程以后复杂度是 $O(n^2k)$。

然后我们把前缀和的判断部分拿出来看一下，这个前缀和的形式形如 $sum_{i,st}-sum_{j-1,st}$，只要判断这些是否全部等价。

注意到一个部分分叫做 $k=2$，我们可以把这个部分分拿出来看看有什么性质。

这样无非就是说明了项只有两个。令两个字符为 $st_1$ 与 $st_2$，也就是说，我们只要判断 $sum_{i,st1}-sum_{j-1,st1}$ 与 $sum_{i,st2}-sum_{j-1,st2}$ 是否相等。我们可以移项，然后就变成了判断 $sum_{i,st1}-sum_{i,st2}$ 与 $sum_{j-1,st2}-sum_{j-1,st2}$ 的大小关系。

后者我们可以在枚举 $i$ 的过程时使用哈希表或者 `map` 存储，然后每次枚举到后面的 $i$ 的时候直接调用此时答案即可。

然后我们发现这个东西推广到 $k\leq 52$ 的时候依然是成立的。我们统计所有字符的个数减去字符 $1$ 的个数，然后放到 `map` 里找找有没有这个元素就可以直接解决这个问题了。如果写哈希的话复杂度甚至能达到 $O(nk)$。

---

但是我们其实有更进一步的方法优化复杂度（其实有人提到过但是讲的不是很清楚）。这个我没试过，但是理论上是可行的：

我们考虑到，每次往后枚举一个 $i$ 只会多产生一个字符对吧。假如这个字符是字符 $1$，则除了 $1$ 以外的所有字符的总量减去它都会减少 $1$。如果不是 $1$，那么那个字符减去 $1$ 的个数会加一。

然后这个东西就转化为了区间修改和单点修改的操作，可以在线段树上解决。线段树维护这个数的哈希值，然后这样复杂度可以达到惊人的 $O(n\log k)$。但是我没写过，只能说理论可行。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
const int mod=1e9+7;
int ans,n,tot,cnt,sum[maxn][55],a[maxn],ct[maxn][55],tong[maxn];
char s[maxn];
struct node{
	int p[55],k;
	bool friend operator < (node x,node y){
		for(int i=1;i<=x.k;i++){
			if(x.p[i]<y.p[i])return 1;
			if(x.p[i]>y.p[i])return 0;
		}
		return 0;
	}
};
map<char,int> G;
map<node,int> M;
int main(){
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i=1;i<=n;i++)
		if(!G[s[i]])a[i]=G[s[i]]=++tot;
		else a[i]=G[s[i]];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=tot;j++)sum[i][j]=sum[i-1][j]+(a[i]==j);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=tot;j++)
			ct[i][j]=sum[i][j]-sum[i][1];
	node p;
	p.k=0;
	for(int j=1;j<=tot;j++)p.p[++p.k]=0;
	M[p]=++cnt,tong[M[p]]++;
	for(int i=1;i<=n;i++){
		p.k=0;
		for(int j=1;j<=tot;j++)p.p[++p.k]=ct[i][j];
		if(!M[p])M[p]=++cnt;
		ans+=(tong[M[p]]++),ans%=mod;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：船酱魔王 (赞：1)

# P6273 [eJOI2017] 魔法 题解

## 题意回顾

在一个长度为 $ n $ 的字符串 $ S $ 中，出现了 $ k $ 种不同字符，定义有魔法的字符串为出现不同字符数为 $ k $ 且每种字符出现次数相等。求 $ S $ 有魔法的子串数量。

$ n \le 10^5 $，$ k \le 52 $。

## 分析

**提示：本篇题解非正解，依赖于你较好的运气，不建议在离线评测且捆绑测试的考试下这么做。**

CSP-S 2022 第三题“星战”的做法（随机哈希）启发了我们。

对每一个字符赋一个随机权值，字符 $ i $ 权值为 $ w_i $。

设字符集为 $ C $。

定义一个子串的权值为 $ W(l,r)=\sum_{i=l}^{r}w_{S_i} $，定义 $ s=\sum w_i(i\in C) $。

我们发现当一个子串 $ [l,r] $ 有魔法时，设各字符出现 $ x $ 次，则有 $ W(l,r)= \sum{x \times w_i}(i \in C)=x \times s $，即子串权值为 $ s $ 倍数。而只要权值范围足够大，可以把权值为 $ s $ 的倍数的所有子串均看做魔法子串。

动态维护一个映射表 $ mp $，$ mp_i $ 表示权值模 $ s $ 余 $ i $ 的前缀个数，每次答案加上与当前前缀权值模 $ s $ 同余的前缀数量，再用当前前缀权值更新 $ mp $。

时间复杂度为 $ O(n \log n) $。

## 实现细节

* 注意不同评测系统下 ```rand()``` 函数的生成范围的差异。

* 注意选随机种子需要较好的运气，建议固定随机种子。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <ctime>
#include <cstdlib>
#include <map>
using namespace std;
const int N = 1e5 + 5;
const int mod = 1e9 + 7;
int n;
string s;
int cx[256];
char tmp[256];
int k = 0;
int charid[256];
int a[N];
long long ans = 0;
int w[N];
long long s1 = 0;
long long pre[N];
map<long long, int> mp;
int rmake(int l, int r) {
	int res = rand();
	return l + res % (r - l + 1);
}
int main() {
	srand(383747478);
	cin >> n;
	cin >> s;
	for(int i = 0; i < n; i++) {
		cx[s[i]]++;
		if(cx[s[i]] == 1) {
			k++;
			tmp[k] = s[i];
		}
	}
	sort(tmp + 1, tmp + k + 1);
	for(int i = 1; i <= k; i++) {
		charid[tmp[i]] = i;
	}
	for(int i = 1; i <= n; i++) {
		a[i] = charid[s[i - 1]];
	}
	bool ok;
	if(n <= 2000) {
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= k; j++) {
				cx[j] = 0;
			}
			for(int j = i; j <= n; j++) {
				cx[a[j]]++;
				ok = true;
				for(int l = 2; l <= k; l++) {
					if(cx[l] != cx[1]) {
						ok = false;
						break;
					}
				}
				if(ok) {
					ans++;
				}
			}
		}
		cout << ans << endl;
		return 0;
	}
	ans = 0;
	for(int i = 1; i <= k; i++) {
		w[i] = rmake(1, 1e9);
		s1 = s1 + w[i];
	}
	pre[0] = 0;
	mp[0]++;
	for(int i = 1; i <= n; i++) {
		pre[i] = pre[i - 1] + w[a[i]];
		ans += mp[pre[i] % s1];
		ans %= mod;
		mp[pre[i] % s1]++;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：chenxia25 (赞：0)

>[洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6273)

>给定字符串$a,|a|=n$，字符集为$\Sigma$。一个子串有魔法当且仅当它内部包含所有$\Sigma$种字符，且所有种类的字符数量相等。求有魔法的非空子串数量。

>$n\in\left[2,10^5\right],|\Sigma|\in[1,52]$。

首先预处理出对于每种字符$j$的前缀计数$Sum_{i,j}$，$\mathrm O(n|\Sigma|)$。

探索充要条件：一个子串$a_{l\sim r}$有魔法显然当且仅当$\forall i\in\Sigma,Sum_{r,i}-Sum_{l-1,i}=\dfrac{r-l+1}{|\Sigma|}\Leftrightarrow |\Sigma|Sum_{r,i}-r=|\Sigma|Sum_{l-1,i}-(l-1)$。设$b_{i,j}=|\Sigma|Sum_{i,j}-i$，把$b_i$看成一个$|\Sigma|$元组，则上面那个充要条件即$b_{l-1}=b_r$。只要从左往右扫一遍，扫到$i$时，将多重集中$b_i$的数量贡献进答案，再将$b_i$扔进多重集即可。`multiset`的`count()`函数复杂度是线性的，可以用`map`实现多重集，$\mathrm O(n|\Sigma|)+\mathrm O(n|\Sigma|\log n)=\mathrm O(n|\Sigma|\log n)$。当然，这个$b_i$可以哈希，然后用哈希表实现多重集，这样扫描部分的时间复杂度为$\mathrm O(n)$；前缀计数预处理部分也可以改为一边扫描一边线段树维护，$\mathrm O(n\log k)$。不过既然蒟蒻没有被卡常，就不写那么复杂了吧~

最后，蒟蒻忘记取模了，模数又抄错了$2$次，交了好几发才过……已加入[sb错误列表](https://www.cnblogs.com/ycx-akioi/p/sb-mistakes.html)（第$4$条）（

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int mod=1000000007;
const int N=100000,LET=52,ASCII=150;
int n;
char a[N+5];
vector<char> sigma;//字符集 
int pos[ASCII];//字符对应在sigma里的下标 
int Sum[N+1][LET];//前缀计数 
map<vector<int>,int> mp;//多重集 
int main(){
//	freopen("C:\\Users\\chenx\\Downloads\\P6273_12.in","r",stdin);
	cin>>n>>a+1;
	for(int i=1;i<=n;i++)sigma.pb(a[i]); 
	sort(sigma.begin(),sigma.end());
	sigma.resize(unique(sigma.begin(),sigma.end())-sigma.begin());//预处理sigma 
	for(int i=0;i<sigma.size();i++)pos[sigma[i]]=i;//预处理pos 
	int ans=0;
	mp[vector<int>(sigma.size(),0)]=1;//b[0] 
	for(int i=1;i<=n;i++){//扫描 
		for(int j=0;j<sigma.size();j++)Sum[i][j]=Sum[i-1][j];//计算前缀计数 
		Sum[i][pos[a[i]]]++;
		vector<int> v;//b[i]
		for(int j=0;j<sigma.size();j++)v.pb(sigma.size()*Sum[i][j]-i);
		(ans+=mp[v]++)%=mod;//贡献答案 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：technopolis_2085 (赞：0)

## P6273 [eJOI2017] 魔法 题解

分析：

前两个子任务比较简单，考虑用 $O(n^2)$ 的方法做。

用前缀和预处理，然后二重循环枚举字串的两端 $l$ 和 $r$，对 $k$ 中元素一一判断，当所有字符在字串内出现次数都相等时，答案加 $1$。

这样就拿到了 $30$ 分。

后面两个子任务的 $n$ 的范围较大，所以不能枚举两个端点。

考虑只枚举右端点 $r$，然后 $O(1)$ 或 $O(\operatorname{log} n)$ 的复杂度计算出以 $r$ 为右端点的魔法字串个数。

很明显，当我们发现一个魔法字串的性质：

当 $l$ 到 $r$ 是一个魔法字串时，我们发现对于每一个字符而言，前缀和相减后的结果都是一个数。

所以我们可以开一个数组来记录一下以 $i$ 结尾的各个字符的出现次数，再把数组里每个元素都减去数组里第一个元素的值。

这样我们就可以通过映射表来用 $O(\operatorname{log} n)$ 的复杂度计算答案了。

时间复杂度为 $O(n \operatorname{log} n)$，可以通过。

另外记得取余。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;

map<vector<int> , int> mp; 
const int maxn=1e5+10;
char s[maxn];
int a[maxn];
int sum[maxn][60];
int flag[maxn];

int change(char ch){
	if (ch>='A'&&ch<='Z') return ch-'A';
	else return ch-'a'+26;
}

signed main(){
	int n;
	scanf("%lld",&n);
	scanf("%s",s+1);
	
	int k=0;
	memset(flag,-1,sizeof(flag));
	for (int i=1;i<=n;i++){
		if (flag[change(s[i])]==-1)
			flag[change(s[i])]=++k;
		
		a[i]=flag[change(s[i])];
	}
	
	for (int i=1;i<=n;i++){
		for (int j=1;j<=k;j++){
			if (j==a[i]) sum[i][j]=sum[i-1][j]+1;
			else sum[i][j]=sum[i-1][j];
		}
	}
	
	vector<int> v;
	v.clear();
	for (int i=1;i<=k;i++) v.push_back(0);
	mp[v]=1;
	
	int ans=0;
	for (int i=1;i<=n;i++){
		v.clear();
		int x=sum[i][1];
		v.push_back(0);
		for (int j=2;j<=k;j++) v.push_back(sum[i][j]-x);
		ans=(ans+mp[v])%mod;
		mp[v]++;
	}
	
	printf("%lld",ans);
	return 0;
} 
```


---


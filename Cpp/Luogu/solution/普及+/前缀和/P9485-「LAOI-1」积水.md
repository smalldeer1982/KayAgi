# 「LAOI-1」积水

## 题目描述



地表坑洼不平，每当暴雨来临地面上都会有一个个水洼。   
又有一场暴雨即将来临，你决定改造地面来减少积水。     
地面可抽象为一个长度为 $n$ 的正整数序列 $a$，其中 $a_i$ 表示当地的海拔高度。       
下暴雨时将会汇聚在低洼处无法向两侧流走，比如一个序列 $a=[3,1,5,1,2,3]$。     
在下雨后的积水如图所示（有 $5$ 格积水）：

![](https://cdn.luogu.com.cn/upload/image_hosting/79on2oe3.png)

由于人手不足，现在只来得及改变一个地方的海拔高度为任意正整数。

问改造后积水最少有几格。






## 说明/提示

对于前 $5\%$ 的数据，$1\le n\le 5$。       
对于前 $20\%$ 的数据，$1\le \sum  n\le 550$，$1\le a_i\le 500$。     
对于前 $35\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i\le 5000$。    
对于前 $50\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i \le 10^9$。  
对于 $100\%$ 的数据，$1\le n,\sum n\le 10^6$，$1\le a_i\le 10^9$。

保证 $1\le T\le 10^4$。

## 样例 #1

### 输入

```
3
6
3 2 1 1 2 3
6
1 1 4 5 1 4
6
1 9 1 9 8 10```

### 输出

```
2
0
1```

# 题解

## 作者：EdenSky (赞：18)

# [P9485 积水](https://www.luogu.com.cn/problem/P9485)
- [或许更好的阅读体验](https://www.cnblogs.com/wanguan/p/17593175.html)

写在前面：这是蒟蒻交的第一篇绿题题解（~~大祭~~），因为线性做法比较难想，本篇会着重讲述用 RMQ 问题求解，并尽可能用~~清晰明了~~的图片和~~简易~~的文字讲明白。

---

## 正文

**最坏时间复杂度：$\mathcal{O}(\sum n+\log \sum n)$**

在求解之前，先让我们想个问题，如何求解积水格数？再简单点，对于每个 $i$，其积水高度是多少？看下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/7gn9l92v.png)

以 $i=3$ 为例，我们可以发现，每个 $i$ 的积水高度与它的左右两峰有关，左边锋（$i=1$）高度为 3，是 $[1,3)$ 区间内的最高高度，右边锋（$i=5$）高度为 4，是 $(3,5]$ 区间内的最高高度。

大家应该都听过木桶效应吧，$i=3$ 时积水最多积 2 格，因为再多就会从 $i=1$ 的位置流出去，所以，积水高度应该是 $i$ 左右两峰的最小值。

那么，上述问题“对于每个 $i$，求其积水高度”已经转化为“对于每个 $i$，求其左右峰的高度”，再转化一下：**对于每个 $i$，求 $[1,i)$ 和 $(i,n]$ 两个区间的最大值**。

显然这是可以用 DP 求解的，设 $l_i$ 为 $i$ 左边的峰的位置，$r_i$ 为 $i$ 右边的峰的位置，$a_i$ 为 $i$ 的高度。有如下代码：

```cpp
l[0]=0,l[1]=0;//求l
for(register int i=2;i<=n;i++)
  if(a[i-1]>=a[l[i-1]]) l[i]=i-1;
  else l[i]=l[i-1];

r[n+1]=0,r[n]=0;//求r
for(register int i=n-1;i>=1;i--)
  if(a[i+1]>=a[r[i+1]]) r[i]=i+1;
  else r[i]=r[i+1];
```

知道了左右两峰的高度，自然而然也就可以求每个 $i$ 的积水格数。代码见下，其中 $p_i$ 为 $i$ 左右两峰的最小值（也可以理解为 $i$ 积水最高可达的高度），$w_i$ 为 $i$ 的积水格数，$s$ 为总积水格数。注意特判 $i$ 自己本身就是峰的情况。

```cpp
s=0;
for(register int i=1;i<=n;i++){
  p[i]=min(a[l[i]],a[r[i]]);
  if(p[i]-a[i]>0) w[i]=p[i]-a[i];//如果a[i]与左右两峰形成“凹”状
  else w[i]=0;//否则不积水
  s+=w[i];
}
```

请记住上面的变量符号，后面会用到。

好了，关于积水的问题求解完了，接下来就进入重点了。对于每个 $i$，有两种情况：

第一类，$i$ 存在积水，即 $p_i>a_i$。**我们对于每个 $i$，将 $a_i$ 增大至 $p_i$，即将 $i$ 升高至积水高度，不能多也不能少**，多了可能会形成新的峰，增加积水格数，少了无法排尽 $i$ 的积水，看下面的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/yoanisk1.png)

此时将 $a_3$ 提高 2 格，这是恰当好处的，多了的话 $i=4$ 的积水格数会增加，少了也不最优。

因此，有代码（$ans$ 是改造后的答案）：

```cpp
for(register int i=1;i<=n;i++)
  ans=min(ans,s-w[i]);
```

第二类，$i$ 是峰。可以尝试降低高度，排出峰内部的积水。这种情况十分复杂，我们要细细研究。

如果我们分别枚举每个 $i$ 降低高度，再加上判断可以减少多少格积水，时间复杂度就会变成惊人的 $\mathcal{O}(\sum n_j^2)$，这是不可接受的，我们要换种思路。（实际上这种思路的时间复杂度没那么夸张，如果数据水还是能过的）

设 $v_i$ 为将 $i$ 降低后可以减少的积水格数。枚举每个 $i$，分别求其左右峰（$l_i$ 和 $r_i$）降低高度后 $i$ 可以减少的积水格数，分别将求出的值加在 $v_{l_i}$ 和 $v_{r_i}$ 即可。

那么如何求可以减少的积水格数呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/7jvl83un.png)

以 $i=4$ 为例，此时 $r_i=5$。如果将 $a_5$ 降至 0 高度，此时反而会积水（因为此时 $a_7 > a_5$，形成“凹”状），所以我们只能将 $a_5$ 降至 $a_7$ 的高度，否则会形成多余的积水，那么 $i=4$ 就可以减少 $p_4-a_{r_{r_4}}$。来解释一下，$r_4$ 是 $i=4$ 的右峰位置，此时我们要将 $a_{r_4}$ 降低，但不能低于 $r_4$ 右边较低峰的位置（图中是 $i=7$），即不能低于 $r_{r_4}$ 的高度，因此 $a_{r_4}$ 的高度会降至 $a_{r_{r_4}}$，所以 $i=4$ 可以减少 $p_4-a_{r_{r_4}}$ 格积水。

综上：**对于每个 $i$，使得 $v_{r_i}\leftarrow v_{r_i}+(p_i-a_{r_{r_i}})$。**

那么，如果我们这样写，就可以愉快的 WA 了。

来，看看 $i=2$ 的情况，若按上述想法应减少 2 格积水，但实际上是 1 格，WHY？看看 $i=3$，当 $a_5$ 降至 $a_7$ 后，它成了 $i=2$ 的右峰，挡住了 $i=2$ 的一部分积水，使得其只能减少 1 格。所以还要求 $(i,r_i)$ 区间内的最大值 $y$，计算会不会出现新的峰。

这里就是 RMQ 问题了，因为是离线的，可以用 ST 表解决（当然你想用线段树也没人拦你，只是蒟蒻不太会QWQ）。

**把上述结论的 $a_{r_{r_i}}$ 改为 $\max(a_{r_{r_i}},y)$ 就好了。**

但是！！！还没结束！！！看 $i=3$，$a_5$ 降至 $a_7$ 后，在区间 $[3,7]$ 中 $a_3$ 是最大的，也就是说 $i=3$ 减少的积水格数是 $p_3-a_3$，不与 $j$ 或 $a_{r_{r_i}}$ 有关。

**所以还要在 $\max$ 内加上第三项 $a_i$。**

**这里只讨论了降低右峰的情况，左峰同理。**

好啦，上这部分的 Code！

```cpp
for(register int i=1;i<=n;i++){
  if(p[i]>=a[i]){
  //如果i是峰，不管如何降低a[l[i]]或a[r[i]]都无法增加排水格数
    to=max(a[l[l[i]]],query(l[i]+1,i-1));
    v[l[i]]+=(p[i]-max(to,a[i])>0?
      p[i]-max(to,a[i]):0);//讨论左峰

    to=max(a[r[r[i]]],query(i+1,r[i]-1));
    v[r[i]]+=(p[i]-max(to,a[i])>0?
      p[i]-max(to,a[i]):0);//讨论右峰
  }
}
```

因此，$ans$ 就可以这样求：

```cpp
for(register int i=1;i<=n;i++)
  ans=min(ans,s-v[i]);
```

两类情况讨论完毕，上总 Code！

```cpp
#define by_wanguan
#include<iostream>
#include<cstring>
#define ll long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
using namespace std;
const int N=1e6+7;
ll l[N],r[N],a[N],T,n,v[N],p[N],w[N],s,ans,to;
ll read(){ll x=0,w=1;char ch=0;while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}while('0'<=ch&&ch<='9'){x=(x<<3)+(x<<1)+(ch-'0');ch=getchar();}return x*w;}
void write(ll x){int sta[24],top=0;if(x<0){putchar('-');x=-x;}do{sta[top++]=x%10;x/=10;}while(x);while(top)putchar(sta[--top]+'0');}

/*
l[i] i左边最高位置   r[i] i右边最高位置 
a[i] i高度   p[i] i积水高度 
v[i] i两侧峰削去可减少积水格数
w[i] i积水格数 
*/

//ST表，不会去P3865
  ll lg2[N],pp[22],ma[N][21],len,lg,pl;
  inline void init(){
    pp[0]=1;
    for(register int i=1;i<=20;i++) pp[i]=pp[i-1]*2;
    int cnt=0,last=2;
    for(register int i=2;i<N;i++){
      if(i==last) cnt++,last*=2;
      lg2[i]=cnt;
    }
  }
  inline void solve(){
    for(register int i=1;i<=lg2[n]+1;i++)
      for(register int j=1;j<=n;j++)
        ma[j][i]=max(ma[j][i-1],ma[min(j+pp[i-1],n)][i-1]);
  }
  inline int query(int l,int r){
    if(l>r) return 0;
    if(l==0) l=1;
    len=r-l+1,lg=lg2[len],pl=pp[lg];
    return max(ma[l][lg],ma[r-pl+1][lg]);
  }

signed main(){
  T=read();
  init();
  while(T--){
    n=read();
    for(register int i=1;i<=n;i++)
      a[i]=read(),ma[i][0]=a[i];
    solve();
    l[0]=0,l[1]=0;
    for(register int i=2;i<=n;i++)
      if(a[i-1]>=a[l[i-1]]) l[i]=i-1;
      else l[i]=l[i-1];
    r[n+1]=0,r[n]=0;
    for(register int i=n-1;i>=1;i--)
      if(a[i+1]>=a[r[i+1]]) r[i]=i+1;
      else r[i]=r[i+1];
    s=0;
    for(register int i=1;i<=n;i++){
      p[i]=min(a[l[i]],a[r[i]]);
      if(p[i]-a[i]>0) w[i]=p[i]-a[i];
      else w[i]=0;
      s+=w[i];
    }
    for(int i=1;i<=n;i++) v[i]=0;
    for(register int i=1;i<=n;i++){
      if(p[i]>=a[i]){
        to=max(a[l[l[i]]],query(l[i]+1,i-1));
        v[l[i]]+=(p[i]-max(to,a[i])>0?
          p[i]-max(to,a[i]):0);
        to=max(a[r[r[i]]],query(i+1,r[i]-1));
        v[r[i]]+=(p[i]-max(to,a[i])>0?
          p[i]-max(to,a[i]):0);
      }
    }
    ans=s;
    for(register int i=1;i<=n;i++)
      ans=min(ans,s-w[i]),
      ans=min(ans,s-v[i]);
    write(ans),putchar('\n');
  }
}//Copy不是好习惯哦
```

[AC 记录](https://www.luogu.com.cn/record/118186953)。

由于 $\mathcal{O}(\sum n+\log \sum n)$ 的复杂度通过 $\sum n=10^6$ 数据较为危险，记得卡常。

还有，如果你只 T 了 Subtask#1 而其它 Subtask 全部 AC，极有可能是 `memset()` 的问题（~~别问我怎么知道的~~）。

还有蒟蒻写了这么多能不能给个赞~~

---

## 作者：CZ_7 (赞：13)

### ~~纪念一个我在机房调了2h半的题目。~~

[题目传送门](https://www.luogu.com.cn/problem/P9485)

[没准会更好的阅读体验](https://www.luogu.com.cn/blog/CZ6945/solution-p9485)

来水一发没用数据结构的题解。

### 题目分析

#### Part1

我们要尽量少的减少积水数，首先就要先求出题目所给条件本来有多少积水数。

考虑第 $i$ 列，如何判断它有多少积水呢？可以观察下面这张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/t31jpodg.png)
可以发现，如果 $i$ 左边的第 $l$ 列是左边各列中最高的，右边第 $r$ 列是右边各列最高的，那么第 $i$ 列的积水 $w_i$ 就应该满足$w_i=\min(a_l,a_r)-a_i$。

为什么呢？因为 $l/r$ 分别是左边和右边最高的，当水位不到 $w$ 时，水位继续升高依旧可以装在  $[l,r]$ 这个“桶”里；当水位超过 $w$，水就会流出去。

至于如何维护最高的 $l$ 和  $r$，可以使用前缀/后缀最大值数组。我这里定义的是 $maxl$ 和  $maxr$，满足
```cpp
maxl[i]=max(maxl[i-1],a[i]);
maxr[i]=max(maxr[i+1],a[i]);
```
那么就可以得出 $w_i=\min(maxl_{i-1},maxr_{i+1})-a_i$。

定义 $sum$ 为积水的总数，则 $sum=\sum ^n_{i=1} w_i$。

#### Part2

接下来就需要考虑如何修改一格的高度来减少最多的积水数。我们设减少的积水数为 $cut$。

第一种方式是增加一格的高度。还是上面那个例子，注意到：
![](https://cdn.luogu.com.cn/upload/image_hosting/cuj0txht.png)
如果我们把 $a_i$ 修改成 $a_i+w_i$，那么积水数就可以减少 $w_i$。如果改的更高，那么就会和更高的那边（比如说图中的 $r$） 形成积水，不优。

于是可以得出 $cut=\max_{i=1}^n w_i$。

还有没有别的方法呢？有！

观察样例一：
```
.in
6
3 2 1 1 2 3
.out
2
```
可以发现，它的方法是将第一列的高度降低，让水从左边流走！接下来我们讨论这种方法能减少的积水数量（都以从左边流走为例，右边同理）：

1.分析条件：

如果想通过降低 $l$ 的高度让水从左边流出，那么 $l$ 一定是从 $1$ 至 $l$ 中最高的；否则前面和 $i$ 一样高或者更高的块会挡住水流。也即：$a_l>maxl_{l-1}$。

2.考虑终止位置：

如果在 $r$ 位置终止，也就是说明 $r$ 及它后面位置的积水都没法往左边流出去；也即 $a_r \geqslant a_l$。
参考图示理解（虚线为 $a_l$ 原高）：
![](https://cdn.luogu.com.cn/upload/image_hosting/s2gyls08.png)
#### 这张图十分重要，可以告诉我们很多性质。

第一，$a_l$ 应该修改到多高？并不是 $a_{l-1}$。注意到图示中情况，应该修改到 $maxl_{l-1}$ 即图中的 $l-2$ 位置；再低的话就会被装在 $l-2$ 和 $r$ 的“桶”里，不优。

第二，后面 $l+1,l+2 \dots $ 的积水到底会减少多少？

这里用绿色区域表示流走的水区域，$low$ 表示水能流走的最低高度，即 $low=maxl_{l-1}$。可以发现，第 $l+1$ 列的绿色区域为 $w_{l+1}-low$；然而第 $l+2$ 列的绿色区域，由于此时 $w_{l+2}>low$，于是绿色区域为 $w_{l+2}-a_{l+2}$。 此时，根据 $low$ 的定义，$low$ 会更新成 $a_{l+2}$。

写成代码就是：
```cpp
ll low=maxl[l-1],cnt=0;
while(a[r]<a[l]){//判断从l开始的一个块最多能流走多少水；l满足a[l]>maxl[l-1]
	ll w=min(maxl[r-1],maxr[r+1]);//计算w[r]
	if(w>max(low,a[r]))cnt+=w-max(low,a[r]);
				//判断能流出的水量
	low=max(low,a[r]);//更新low
	r++;
	if(r==n+1)break;
}
cut=max(cut,cnt);
l=r;r++;
```
这样我们就计算出了从 $l$ 位置开始的一个“可流出区域” $[l,r]$ 的水流值。

#### 同时，观察我们的做法，退出循环后，$r$ 也一定是前缀最大值！

很好证明：$a_r \geqslant a_l$，$a_l \geqslant maxl_{l-1}$，容易得出 $a_r \geqslant maxl_{r-1}$。

#### 所以此时 $r$ 便是新的 $l$，继续循环即可。这样便保证了复杂度是 $O(n)$ 的。

最后一个小问题：在“分析条件”中，写的是 $a_l>maxl_{l-1}$，但是 $r$ 所代表的新的 $l$ 满足的是 $a_l \geqslant maxl_{l-1}$ 啊！

可以发现，在$a_l = maxl_{l-1}$ 时，以 $r=l+1$ 为例，若 $a_r>a_l$，那么 $l=r$，重新循环；否则一定满足 $w=\min(maxl_{r-1},maxr_{r+1}) \leqslant \max(low,a_r)=\max(maxl_{l-1},a_r)=maxl_{l-1}=a_l$，于是肯定不会对这次的 $cnt$ 计算贡献（这里可以参照代码尝试理解理解）。

那么这道题就做完了。我们的答案是 $sum-cut$。

AC code：
```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
const int N=1000010;
int n;
ll a[N],maxl[N],maxr[N];
ll sum,cut;
void solve(){
	cin>>n;
	sum=cut=0;maxr[n+1]=0;//多 测 不 清 空 爆 大 零
	for(int i=1;i<=n;i++){
		cin>>a[i];
		maxl[i]=max(maxl[i-1],a[i]);//计算前缀最大值
	}
	for(int i=n;i>=1;i--){
		maxr[i]=max(maxr[i+1],a[i]);//计算后缀最大值
	}
	for(int i=1;i<=n;i++){
		ll t=min(maxl[i-1],maxr[i+1]);
		if(t>a[i]){
			sum+=t-a[i];//Part1：计算总积水
			cut=max(cut,t-a[i]);//Part2.1：通过增高格子消除的水量
		}
	}
	int l=1,r=2;
	while(r<=n){//正着跑一遍
		ll low=maxl[l-1],cnt=0;
		while(a[r]<a[l]){//判断从l开始的一个块最多能流走多少水；l满足a[l]>maxl[l-1]
			ll w=min(maxl[r-1],maxr[r+1]);//计算w[r]
			if(w>max(low,a[r]))cnt+=w-max(low,a[r]);
				//判断能流出的水量
			low=max(low,a[r]);//更新low
			r++;
			if(r==n+1)break;
		}
		cut=max(cut,cnt);
		l=r;r++;
	}
	r=n,l=n-1;
	while(l>=1){//依样画葫芦
		ll low=maxr[r+1],cnt=0;
		while(a[l]<a[r]){
			ll w=min(maxl[l-1],maxr[l+1]);
			if(w>max(low,a[l]))cnt+=w-max(low,a[l]);
			low=max(low,a[l]);
			l--;
			if(l==0)break;
		}
		cut=max(cut,cnt);
		r=l;l--;
	}
	cout<<sum-cut<<'\n';
}
int main(){
	int T;
	cin>>T;
	while(T--){
		solve();
	}	
	return 0;
} 
```
Have fun :)

---

## 作者：佬头 (赞：5)

## Description
给定一个长度为 $n$ 的正整数序列 $\{a_1,a_2,\dots,a_3\}$，其中 $a_i$ 表示 $i$ 地的海拔高度。下暴雨时水会汇聚在低洼处无法向两侧流走，并且现在只来得及改变一个地方的海拔高度为任意正整数。求[**积水**](https://www.luogu.com.cn/problem/P9485)最少有几格。

## Solution
首先肯定是要求出原先的**总积水量**，然后再把能减少的最多的积水从中减去。那么求总积水量的话，有一道模板题：[**P1318 积水面积**](https://www.luogu.com.cn/blog/Glory-of-the-King/solution-p1318)。~~模拟还有板子？~~

考虑找到一个 $a_l$ 使得 $\forall~1\le i<l,~a_i<a_l$，显然此时如果 $l+1,l+2,\dots,r$ 有积水，这个积水肯定是被 $l$ 给围住的，并且水位不高于 $a_l$，总积水就是 $\sum_{i=l+1}^r a_l-a_i$。但是这滩积水可能会从右侧流出来，即 $\forall~l<i\le n,~a_i<a_l$，此时我们只需要以 $[l,n]$ 为新的正整数序列，**从右往左**按照上述思路把右侧的积水也求出来（代码里是求了一遍后缀最大值的下标，然后从左往右跑的）。

![](https://cdn.luogu.com.cn/upload/image_hosting/az02p61a.png)

至于改变高度，显然有两种方式：
- 抬高海拔。
	- 我们只需要在求区间 $[l+1,r]$ 积水的同时，用每个点的深度更新**最多可以减少的积水量**即可。
- 降低海拔。
	- 依旧以计算总积水量的思路为基础，显然可以降低海拔的点是我们先前求出来的 $a_l$ 以及左侧的积水边界 $a_k$。
	- 同时我们降低后 $a_l$ 海拔不能低于 $\max\{a_1,a_2,\dots,a_{l-1}\}$，不然积水会被前面的 $a$ 围住而且还会形成新的积水。
	- 接下来考虑如何计算减少的积水量：根据 $a_l$ 降低海拔的限制可以想到维护一个前缀最大值（除去 $a_l$），减少的积水量就是 $\sum_{i=l+1}^{r}a_l-maxx_i$（$maxx_i$ 就表示前缀最大值，不算上 $a_l$）。
	- 最后就是计算 $k$ 往右的积水在降低 $a_k$ 的海拔后减少的积水量，若用 $a_d~(a_d<a_k)$ 表示 $a_k$ 右侧的最大值，则减少的积水量就是 $\sum_{i=k+1}^{d-1}a_d-maxx_i$。
	- 至于 $d$ 往右的点如何计算，反过来再跑一遍即可。

观察数据范围可知要开 `long long`。时间复杂度 $\mathcal O(\sum n)$。

## Code
- `tot`：总积水量。
- `pre[i]`：$i$ 的后缀/前缀最大值的下标。
- `ans`：最多可以减少的积水量。
- `sum`：某条件下减少的积水量。

```cpp
#include <iostream>
using namespace std;
const int N = 1000006;
int n, a[N], maxx, minn, pre[N];
long long ans, tot, sum;
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(long long x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	for(int _ = read(); _ >= 1; _ --){
		n = read(), maxx = ans = tot = 0;
		for(int i = 1; i <= n; ++ i) a[i] = read();
		for(int l = 1, r; l < n; l = r + 1){
			minn = a[r = l], sum = 0;
			while(r < n && a[r + 1] < a[l]) ++ r;
			if(r < n){
				for(int i = l + 1; i <= r; ++ i){
					tot += a[l] - a[i];
					if(a[i] < minn) minn = a[i];
					if(a[i] > maxx) maxx = a[i];
					sum += a[l] - maxx;
				}
				if(a[l] - minn > ans) ans = a[l] - minn;
				if(a[l] > maxx) maxx = a[l];
			}
			else{
				int maxid = n, i;
				for(i = n - 1; i > l; i --)
					if(a[i] > a[maxid]){
						pre[i] = maxid;
						maxid = i;
					}
				for(i = l + 1; i < maxid; ++ i){
					if(a[i] > maxx) maxx = a[i];
					if(a[maxid] > maxx) sum += a[maxid] - maxx;
				}
				for(i = l + 1; i < n; i = maxid + 1, maxid = pre[maxid]){
					minn = a[i];
					while(i <= maxid){
						if(a[i] < minn) minn = a[i];
						tot += a[maxid] - a[i ++];
					}
					if(a[maxid] - minn > ans) ans = a[maxid] - minn;
				}
			}
			if(sum > ans) ans = sum;
		}
		maxx = 0;
		for(int r = n, l; r >= 1; r = l - 1){
			l = r, sum = 0;
			while(l > 1 && a[l - 1] < a[r]) l --;
			if(l > 1){
				for(int i = r - 1; i >= l; i --){
					if(a[i] > maxx) maxx = a[i];
					sum += a[r] - maxx;
				}
				if(a[r] > maxx) maxx = a[r];
			}
			else{
				int maxid = 1, i;
				for(i = 2; i < r; ++ i)
					if(a[i] > a[maxid]){
						pre[i] = maxid;
						maxid = i;
					}
				for(i = r - 1; i > maxid; i --){
					if(a[i] > maxx) maxx = a[i];
					if(a[maxid] > maxx) sum += a[maxid] - maxx;
				}
			}
			if(sum > ans) ans = sum;
		}
		write(tot - ans), putchar('\n');
	}
	return 0;
}
```


---

## 作者：Interstice (赞：4)

原题目link：[P9485](https://www.luogu.com.cn/problem/P9485)

**分析**

这道题的题面与[P1318 积水面积](https://www.luogu.com.cn/problem/P1318)非常相似，可以考虑用类似的单调栈来做~~虽然标的都是模拟~~

![](https://cdn.luogu.com.cn/upload/image_hosting/1h1abxa4.png)

以题面的图片为例，将序列 $a=[3,1,5,1,2,3]$ 依次加入，维护一个递减的单调栈，当不满足递减性质时，计算积水面积并维护单调性质。

模拟一下：

$a _ {1}=3$ 入栈，$a _ {2}=3$ 入栈，当 $a _ {3}=5$ 应入栈时，发现不满足单调性质，$a _ {1}$ 与 $a _ {3}$ 可形成 $2 \times 1 = 2$ 的积水面积，加入总数 ，并弹出 $a _ {1}$ 与 $a _ {2}$。对于 $a _ {4}$ 与 $a _ {5}$ 同理。

![](https://cdn.luogu.com.cn/upload/image_hosting/6jfhab6p.png)

当到 $a _ {6}$ 时，发现积水面积不为规则的矩形。可以记录当前已计算的积水高度 $now$，只计算高度 $> now$ 的积水面积，由此便将积水分割为了两个规则的矩形部分（如图红色矩形所示）。

由此我们便得出了积水的总面积。[code](https://www.luogu.com.cn/paste/6z5eybl2)

对于本题，可以在计算积水总面积时分别记录每个 $a$ 对左右的贡献 $sum _ {i,0}$ 与 $sum _ {i,1}$ (其实就是在累加总数时对于 $sum$ 累加同样的值），遍历 $sum$ 寻找左右贡献和的最大值，用总数减去得到答案。

~~然后我们就可以愉快的WA了~~

为什么？按照上面的算法，$sum _ {3,0}+ sum _ {3,1} = 2 + 3 = 5$，去掉 $a _ {3}$ 可以使积水面积为 $0$，而实际呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/c17yab6y.png)

可以看到，去掉 $a _ {3}$ 反而使积水面积增加了。

可发现，对于每个 $a$，如果它贡献的积水在其前方还有比积水高度更高的 $a$ ，那么其实际贡献为 $0$。我们可以记录每个 $a$ 左右两侧的 $a$ 最大高度 $maxh _ {i,0}$ 与 $maxh _ {i,1}$，计算贡献时，只计算高度 $> \max(now,maxh _ {i})$ 的积水贡献，即可得到正确答案。

模拟：

对于 $a _ {1}$,$maxh _ {i,0} = 0$,左右总贡献为 $2$。

对于 $a _ {3}$ 与 $a _ {5}$ 其积水均不满足 $> \max(now,maxh _ {i})$ 的要求，左右贡献均为 $0$。

对于 $a _ {6}$，$maxh _ {6,1}= 0$，左右总贡献也为 $2$。

由此便对此情况得出了正确答案。~~但是这样依旧只能得到 80 分~~

此外还有一种情况没有考虑。当序列 $a=[3,3,1,1,3,3]$ 时，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/jquyal3s.png)

任何 $a$ 的左右总贡献都会为 $0$，得出了错误的答案 $4$。

其实还需要考虑增加高度的情况。如果增加 $a _ {3}$ 或 $a _ {4}$ 的高度到 $3$，可以使积水面积减少到 $2$。可以记录 $sum _ {i,2}$ 为积水高度与 $a _ {i}$ 之差，在遍历 $sum$ 时同时寻找填充情况的最大值。

**AC代码**

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;
typedef long long LL;
int t,n;
LL now,maxn,ans,ss;//ss为积水总面积
LL a[1000010],maxh[1000010][2],sum[1000010][3];
int main(){
	cin>>t;
	while(t--){
		ss=0;
		cin>>n;
	    stack<int> st;
	    st.push(0);
	    for(int i=1;i<=n;i++) cin>>a[i],maxh[i][0]=maxh[i][1]=sum[i][0]=sum[i][1]=sum[i][2]=0;
	    maxn=0;
	    for(int i=1;i<=n;i++){
	    	maxh[i][0]=maxn;
	    	if(a[i]>maxn) maxn=a[i];
		}
		maxn=0;
	    for(int i=n;i>=1;i--){
	    	maxh[i][1]=maxn;
	    	if(a[i]>maxn) maxn=a[i];
		}
	    for(int i=1;i<=n;i++){
	        now=0;
	        while(!st.empty()){
	            if(a[st.top()]<=a[i]){
	                if(a[st.top()]>now){
	                    sum[st.top()][1]+=max(a[st.top()]-max(now,maxh[st.top()][0]),LL(0))*(i-st.top()-1);
	                    sum[i][0]+=max(a[st.top()]-max(now,maxh[i][1]),LL(0))*(i-st.top()-1);
						ss+=(a[st.top()]-now)*(i-st.top()-1);
						now=a[st.top()];
						for(int j=st.top()+1;j<i;j++) sum[j][2]=a[st.top()]-a[j];
	                }
	                st.pop();
	            }
	            else{
	                if(a[i]>now){
	                	sum[st.top()][1]+=max(a[i]-max(now,maxh[st.top()][0]),LL(0))*(i-st.top()-1);
	                	sum[i][0]+=max(a[i]-max(now,maxh[i][1]),LL(0))*(i-st.top()-1);
	                	ss+=(a[i]-now)*(i-st.top()-1);
	                	for(int j=st.top()+1;j<i;j++) sum[j][2]=a[i]-a[j];
					}
	                break;
	            }
	        }
	        st.push(i);
	    }
		ans=0;
		for(int i=1;i<=n;i++) ans=max(ans,max(sum[i][0]+sum[i][1],sum[i][2]));
		cout<<ss-ans<<endl;
	}
    return 0;
}
```

**PS：** 如果你的代码样例通过而得到0分，可以试试[这组数据](https://www.luogu.com.cn/paste/2tb27s9h)

---

## 作者：__LYY_p (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9485)

因为太菜了所以比赛时没写出来。

这里给出一个使用线段树的 $\Theta(n\log n)$ 解法，虽然复杂度并不好但比正解好想。

# 题意分析

给你一个长度为 $n$ 的海拔数列 $h$ ，你可以任选一个数 $h_i$ 把它变成任意正整数，要求使最后的总积水值 $sum$ 最小。其中总积水值 $sum$ 与第 $i$ 个位置的积水值 $d_i$ 以下面的式子给出：

$$
\large sum=\sum_{i=1}^nd_i\\
d_i=\max\begin{cases}
\min\{\max_{k=1}^{i-1}h_k,max_{k=i+1}^nh_k\}-h_i\\
0\\
\end{cases}
$$

可以发现这个式子中涉及到了 RMQ 问题，所以我们用一颗线段树维护 $h$ 的区间最大值~为什么不用 ST 表呢，因为后面还要修改，所以用线段树更方便。

# 策略分析

在计算出每个格子的积水值后，我们就要决定修改哪个格子的高度了。

从大禹治水的故事（无误）中我们可以知道治水有两种方法：第一种是“堵”，即把可能积水的的位置填起来，第二种是“疏”，即打通水路，减少积水。这两种方法在题目里也就分别对应了抬高一个格子的海拔与降低一个格子的海拔。

先说第一种方法。显然**只有抬高一个已经积水的格子的海拔才有意义**，那抬高多少合适呢？可以发现把**海拔抬高到恰好与水面平行最为合适**，既可以把当前位置的水全部消灭，又可以避免周围格子更大程度上的积水。总积水值的变化为 $sum'=sum-d[i]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/hbe6x8ky.png)

再看第二种方法。可以证明**只有当一个格子是“峰顶”（即满足 $h_{i-1}\le h_i \le h_{i+1}$ ）且没有积水时降低海拔才有意义**（如图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/9rjtluft.png)

“峰顶”降低海拔，会产生什么影响？可以发现当“峰顶”降低海拔时，峰顶两侧原本高处的水会向低处的一侧流动（如图）。降低到多少合适？可以发现**降低到两侧水面的较小者最合适**，既可以让高侧的水流干净，也可以避免当前位置新的积水。那么会减少多少积水？这个问题其实不好回答，这里采用**暴力重新计算所有受影响的格子的办法**。对于格子 $i$ 而言，记 $[L_i,R_i]$ 是一个极大的满足 $\forall k\in [L_i,i)\cup (i,R_i],h_k<h_i$ 的区间，那么我们只用重新计算 $[L_i,R_i]$ 的积水情况即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/ctd1scuu.png)

# 复杂度分析

因为我们使用线段树维护 $h$ 的区间最大值，所以我们可以用 $\Theta (\log n)$ 的时间复杂度计算单个 $d_i$ 的值，预处理所有初始 $d_i$ 时间复杂度为 $\Theta(n\log n)$。

所有的 $L_i$ 和 $R_i$ 都可以用 DP 或者单调栈计算，时间复杂度 $\Theta(n)$ 。

第一种治水方法打个擂台就结束了，时间复杂度 $\Theta(n)$ 。

重点是第二种治水方法。观察所有连通的水面，可以发现这些水面至多被两个“峰顶”围着，也就是说这些格子的积水值最多被重新计算两遍，故总的时间复杂度依旧为 $\Theta (n \log n)$ 。

总空间复杂度为 $\Theta(n)$ ，时间复杂度为 $\Theta(n \log n)$ 。

# 参考代码

更多细节看代码，代码仅供参考。

```cpp
#include<iostream>
#include<stack>
#include<set>
using namespace std;
using ll=long long;
const ll maxn=1e6+5,inf=1e9+5;
//快读快写
ll read(){ll x=0,w=1;char ch=0;while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}while('0'<=ch&&ch<='9'){x=(x<<3)+(x<<1)+(ch-'0');ch=getchar();}return x*w;}
void write(ll x){ll sta[24],top=0;if(x<0){putchar('-');x=-x;}do{sta[top++]=x%10;x/=10;}while(x);while(top)putchar(sta[--top]+'0');}
void End(){putchar('\n');}

int n,h[maxn],d[maxn],L[maxn],R[maxn];
ll sum_d=0,ans=inf;

//Segment tree
int maxv[maxn*4];
void build(int o=1,int l=1,int r=n){
	if(l==r){maxv[o]=h[l];return;}
	int mid=(l+r)>>1;
	build(o<<1,l,mid);
	build(o<<1|1,mid+1,r);
	maxv[o]=max(maxv[o<<1],maxv[o<<1|1]);
}
void modify(int x,int k,int o=1,int l=1,int r=n){
	if(l==r){maxv[o]=k;return;}
	int mid=(l+r)>>1;
	if(x<=mid)modify(x,k,o<<1,l,mid);
	else modify(x,k,o<<1|1,mid+1,r);
	maxv[o]=max(maxv[o<<1],maxv[o<<1|1]);
}
int query(int ql,int qr,int o=1,int l=1,int r=n){
	if(ql<=l&&r<=qr){return maxv[o];}
	int mid=(l+r)>>1,ans=0;
	if(ql<=mid)ans=max(ans,query(ql,qr,o<<1,l,mid));
	if(mid+1<=qr)ans=max(ans,query(ql,qr,o<<1|1,mid+1,r));
	return ans;
}

//初始化并计算水深d和LR
void init(){
	build();sum_d=0;
	for(int i=2;i<n;i++){
		d[i]=max(0,min(query(1,i-1),query(i+1,n))-h[i]);
		sum_d+=d[i];
	}
	ans=sum_d;
	//L&R
	h[0]=h[n+1]=inf;
	for(int i=1;i<=n;i++){
		L[i]=i;
		while(h[i]>h[L[i]-1])L[i]=L[L[i]-1];
	}
	for(int i=n;i>=1;i--){
		R[i]=i;
		while(h[i]>h[R[i]+1])R[i]=R[R[i]+1];
	}
	h[0]=h[n+1]=0;
}
ll recalc(int p,int k){//将p位置海拔改为k并重新计算新的积水值
	ll res=sum_d;
	modify(p,k);
	for(int i=L[p];i<=R[p];i++){
		if(i==p||i==1||i==n)continue;
		int now_d=max(0,min(query(1,i-1),query(i+1,n))-h[i]);
		res-=d[i]-now_d;
	}
	modify(p,h[p]);
	return res;
}
int main(){
	int t;t=read();
	while(t--){
		n=read();
		for(int i=1;i<=n;i++)h[i]=read();
		init();
		for(int i=1;i<=n;i++){
			if(d[i]==0&&h[i-1]<h[i]&&h[i]>h[i+1])
				ans=min(ans,recalc(i,min(h[i-1]+d[i-1],h[i+1]+d[i+1])));//第二种方法
			ans=min(ans,sum_d-d[i]);//第一种方法
		}
		write(ans);End();
	}
	return 0;
}
```

## 小贴士

由于线段树常数较大，通过 $10^6$ 数据范围略有困难，所以记得略微卡常。


---

## 作者：luan341502 (赞：0)

首先处理出积水格子数，参见[这道题](https://www.luogu.com.cn/problem/P1318)。

然后我们考虑修改会对答案造成何种贡献呢。

分为两类。

一类是把柱子抬高，这样可以把一竖条的积水除去。这种情况取能除去的最大值即可。

另外一类比较复杂，我们可以想象一个泄洪的场景，就是把水从左右两边排出。

这样一想就很简单了，我们直接统计出能排出水的积水格子数就可以了。

具体做法：对于每一根上面没有水的柱子考虑将它削减到前面或后面那一根没有柱子的水的高度，这样做能排出尽可能多的水，而且不会导致出现凹处再次积水。然后就可以对这个区间的格子利用先前的方法重新计算上面的积水数。

代码如下：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[1000005];
int L[1000005],R[1000005];
int pL[1000005],pR[1000005];
void init(){
	for(int i=0;i<=n+1;i++){
		a[i]=0;
		L[i]=0;
		R[i]=0;
		pL[i]=0;
		pR[i]=0;
	}
}
void solve(){
	init();
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		L[i]=max(L[i-1],a[i]);
		if(L[i]==a[i]) pL[i]=i;
		else pL[i]=pL[i-1];
	}
	for(int i=n;i;i--){
		R[i]=max(R[i+1],a[i]);
		if(R[i]==a[i]) pR[i]=i;
		else pR[i]=pR[i+1];
	}
	int ans=0,res=0;
	for(int i=1;i<=n;i++){
		int x=min(L[i],R[i])-a[i];
		ans+=x;
		res=max(res,x);
		if(!x){
			int k=a[pL[i-1]],tmp=0;
			for(int j=i+1;j<pR[i+1];j++){
				k=max(k,a[j]);
				tmp+=max(0ll,min(L[i+1],R[i+1])-k);
			}
			res=max(res,tmp);
			k=a[pR[i+1]];
			tmp=0;
			for(int j=i-1;j>pL[i-1];j--){
				k=max(k,a[j]);
				tmp+=max(0ll,min(L[i-1],R[i-1])-k);
			}
			res=max(res,tmp);
		}
	}
	cout<<ans-res<<"\n";
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--){
		solve();
	}
    return 0; 
}
```

---

## 作者：VioletIsMyLove (赞：0)

首先我们看看如果这道题不能改变海拔，它的答案如何计算。

很显然，对于每个 $a_i$，它对于答案给出的贡献就是 $\min(\max(a_1,a_2,\dots,a_{i-1}),\max(a_{i+1},a_{i+2},\dots,a_n))-a_i$。

对于总贡献，只需要调用两个单调栈就能计算。

那如果可以改变海拔呢？

对于任何一个 $a_i$，我们如果要对它进行操作的话只有两种操作，把它的高度变高或者变低。

首先考虑变高。

如果将 $a_i$ 变高，我们假设它变成 $x$ ，那么 $a_i$ 这个点的贡献就会减少 $x-\min(\max(a_1,a_2,\dots,a_{i-1}),\max(a_{i+1},a_{i+2},\dots,a_n))$ 。而对于剩余的点，它们的贡献会随着 $a_i$ 的增高而增高。根据最顶上计算贡献的式子，我们会发现当 $a_i$ 低于全图最高点的时候，$a_i$ 的增大不会影响其它点的贡献，只会减少 $a_i$ 本身的贡献。根据 $x-\min(\max(a_1,a_2,\dots,a_{i-1}),\max(a_{i+1},a_{i+2},\dots,a_n))$ 我们会发现随着 $a_i$ 的增大，$a_i$ 所造成的贡献就会越小，所以为了达成最低的贡献， $a_i$ 的值会变成全图最高点的值。

那如果将 $a_i$ 变低呢？

根据 $\min(\max(a_1,a_2,\dots,a_{i-1}),\max(a_{i+1},a_{i+2},\dots,a_n))-a_i$ 我们会发现如果 $a_i$ 这个点既不是它左边的最高点，也不是它右边的最高点，那么 $a_i$ 的贡献只会变大，这也就是说将 $a_i$ 降低不如不变。

因此如果一个点需要可以降低高度，当且仅当它位于从左到右的单调栈或者从右到左的单调栈内，而它如果会产生贡献，只会发生在出现它是 $a_x$ 任意一侧的最高点的时候，那应该怎么统计呢？

我们会发现，在最开始统计将每个 $a_x$ 变高的时候，就已经做过类似的操作了，我们只需要在将每个 $a_i$ 变高的时候，累计一下会对 $a_x$ 产生影响的值了，而做出的贡献就会在发生改变的那一端除去除了 $a_i$ 以外的最高点。

这题的细节比较多，所以还是放一下代码。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct ZS{
	long long h,id;
}st[2][1000005];
long long T,n;
long long top[2],TOP[2];
long long a[1000005],b[1000005],c[1000005];
long long S,s,maxl,maxr;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main(){
	T=read();
	while(T--){
		n=read();S=s=maxl=maxr=0;memset(top,0,sizeof top);
		for(int i=1;i<=n;i++)a[i]=read();
		if(n==1){printf("0\n");continue;}
		for(int i=1;i<=n;i++)if(st[0][top[0]].h<=a[i])st[0][++top[0]]=(ZS){a[i],i};
		for(int i=n;i>=1;i--)if(st[1][top[1]].h<=a[i])st[1][++top[1]]=(ZS){a[i],i};TOP[0]=top[0];TOP[1]=top[1];top[0]=0;
		for(int i=1;i<=n;i++){
			if(st[0][top[0]+1].id<=i&&top[0]<TOP[0])maxl=st[0][top[0]++].h;
			else if(i-1!=st[0][top[0]].id)maxl=max(maxl,a[i-1]);
			if(st[1][top[1]].id<i)top[1]--;
			b[i]=max(0ll,min(st[0][top[0]].h,st[1][top[1]].h)-a[i]);
			S+=b[i];s=max(s,b[i]);
			if(i!=st[0][top[0]].id)c[st[0][top[0]].id]+=b[i]-max(0ll,min(maxl,st[1][top[1]].h)-a[i]);
		}
		top[1]=0;top[0]=TOP[0];
		for(int i=n;i>=1;i--){
			if(i<st[0][top[0]].id)top[0]--;
			if(i<=st[1][top[1]+1].id&&top[1]<TOP[1])maxr=st[1][top[1]++].h;
			else if(i+1!=st[1][top[1]].id)maxr=max(maxr,a[i+1]);
			if(i!=st[1][top[1]].id)
			c[st[1][top[1]].id]+=b[i]-max(0ll,min(st[0][top[0]].h,maxr)-a[i]);
		}
		for(int i=1;i<=TOP[0];i++){s=max(s,c[st[0][i].id]);c[st[0][i].id]=0;}
		for(int i=1;i<=TOP[1];i++){s=max(s,c[st[1][i].id]);c[st[1][i].id]=0;}
		printf("%lld\n",S-s);
	}
	return 0;
}
```


---


# [POI 2002] 超级马

## 题目描述

在一个大小为无限的棋盘上有一个超级马，它可以完成各种动作。

每一种动作包含两个整数，第一个数说明上下移动的数，第二个数说明左右移动的数，移动马来完成这个动作。（数字均为正数向右，负数向左）

请你对每一个输入的超级马进行确认，看它是否可以到达棋盘上的每一个地方。

## 说明/提示

数据范围：$1 \le K,N \le 100,-100 \le P,Q \le 100$。

## 样例 #1

### 输入

```
2
3
1 0
0 1
-2 -1
5
3 4
-3 -6
2 -2
5 6
-1 4```

### 输出

```
TAK
NIE```

# 题解

## 作者：CDFLS_mao_zx (赞：16)

### 超级马

[超级马](https://www.luogu.com.cn/problem/P8854)

#### 建议的前置知识

如果在阅读时感到困惑可以阅读这些链接中可能需要的前置知识。

[群论简介 OI-WIKI](https://oi-wiki.org/math/group-theory/)：该链接下全部内容。

[线性代数 OI-WIKI](https://oi-wiki.org/math/linear-algebra/)：该部分特征多项式部分前的全部内容。

[小凯的疑惑](https://www.luogu.com.cn/problem/P3951)：弄懂基于裴蜀定理的证明。

#### 大体思路

两种主要的方向：图论和数学，图论做法的复杂度至少是 $O(n^3T)$ 的，放弃考虑，考虑数学做法。

**正整数集合的代数性质很差，不妨先考虑整数集合。**

下面从两个角度来考量。

#### 线性代数的角度

一个二维的线性空间只需要两个基就能生成，但这道题中的空间并非**线性空间**，整数集合仅仅是交换幺环，不是域，但我们同样可以从基的角度去考虑。

记 $\operatorname{span}(u_1,u_2,\cdots u_n)$ 表示由这些向量通过线性变换生成的空间，注意到有 $\operatorname{span}(u_1,u_2,\cdots u_n)=\operatorname{span}(u_1\pm u_2,u_2,\cdots u_n)$，因为可以从 $u_1\pm u_2$ 中减掉或者加上 $u_2$ 得到原来的 $u_1$。

考虑对某一维运用辗转相减或者说辗转相除，最后该维只能有一个非零元素，而且这个非零元素必须为 $\pm1$。

对两维同时运用该算法即可判别是否可以在允许可逆操作的前提下到达。

#### 多元一次方程的角度

达到任意点的条件等价于能够到达 $(1,0),(-1,0),(0,1),(0,-1)$，现在问题变成了解一个多元一次方程组：
$$
p_1x_1 + p_2x_2 + p_nx_n=1
$$

$$
q_1x_1 + q_2x_2 + q_nx_n=0
$$

求这个方程组的整数解也是困难的，我们不妨考虑将第二项作为限制，看第一项能得到什么。

在将第二项作为限制的前提下，记第一项能得到的数的集合为 $S$，那么方程组有解的一个充要条件是 $\gcd(S)=1$。考虑找到 $S$ 的一个子集使得它的最大公约数为 $1$，我们考虑所有的无序对 $i,j$，令 $x_k=0,k\neq i,k\neq j $，于是第一个方程的左边能生成 $s_{i,j}=\dfrac{q_ip_j+q_jp_i}{\gcd(q_i,q_j)}$，如果所有的 $s$ 的 $\gcd$ 为 $1$，那么原方程组显然有解，这是一个充分条件，事实上它也是必要的，证明可以参考文末的集训队论文。

将 $p_i,q_i$ 视为向量 $u_i$，将方程组改成向量数乘的方程。

证明思路是证明如果存在整数解，那么一定将整体的求和拆分为若干个 $u_iy_i+u_jy_j$ 的和，且满足 $u_iy_i+u_jy_j=\begin{pmatrix}c\\0\end{pmatrix}$，具体方式是归纳构造。

#### 回归原问题

问题变成了已知在操作可逆的前提下能到达所有点，问是否存在一种方式使得在操作不可逆的前提下也能到达所有点。

**如果所有的向量都落在同一个半平面内，那么显然不能到达所有点**，否则，在每一条坐标轴的两个方向上都能找到一个点能够通过正向操作到达（两个向量只使用不涉及减法的的线性变换能得到的向量落在其小于 $\pi$ 的夹角内且每一个有理点都能取到）。

于是 $(p_i,q_i)$ 逆操作可以找到一个正整数 $k$ 使得 $(kp_i,kq_i)$ 能够在不用逆操作的前提下到达，然后进行 $k-1$ 次 $(p_i,q_i)$ 操作。

因此对所有坐标极角排序即可。

有一个 STL 函数叫 `atan2(double x,double y)`，能够在给定 $x,y$ 坐标的情况下计算其极角，不用手写。

从方程组的角度看，可以改变一下 $s_{i,j}$ 的定义，只让 $q_iq_j\le 0$ 的两个向量贡献，如果 $x$ 坐标依然同时能够取到正负，那么一定可以通过整数解构造得到非负整数解。**注意，这并不代表我们构造 $\gcd(s)=1$ 的时候不能使用 $q_iq_j>0$ 的向量**。

#### 总结

问题的第一步是将问题 "放大" 到整数集合，**以便更好的利用其生成空间的代数性质。**

第二步是**利用这些代数性质得到必要条件后再回到原问题考虑。**

这样能够简化问题的核心原因是相比于原问题，我们解决问题的**每一步都凭空多出了一些条件**——第一部分我们可以更好的利用整数环下线性空间的性质，第二部分可以利用第一部分得到的必要条件。

**凭空多出条件也是反证法和数学归纳法如此强大的原因。**

#### 代码

```c++
// 线性代数角度
#include <bits/stdc++.h>
using namespace std;
const int maxn=110;
const double pi=atan2(0,-1);
int n,i,x,y,T; double d;
struct vec{
	int x,y; double at;
	inline bool operator <(const vec &a)const{return at<a.at;}
}N[maxn],a,b,t;
int main(){
	scanf("%d",&T);
	st: while(T--){
		scanf("%d",&n);
		for(i=1;i<=n;++i){
			scanf("%d%d",&x,&y);
			N[i]={x,y,atan2(y,x)};
		}
		if(n<=2){printf("No\n");goto st;}
		sort(N+1,N+n+1); N[n+1]=N[1];
		for(i=1;i<=n;++i){
			if((d=N[i+1].at-N[i].at)<0) d+=2*pi;
			if(d>=pi){printf("No\n");goto st;}
		}
		for(a=N[1],i=2,y=0;i<=n;++i){
			b=N[i];
			while(b.x){
				t=a; a=b; x=t.x/b.x;
				b={t.x-x*b.x,t.y-x*b.y,0};
			} 
			y=__gcd(y,b.y);
		}
		if(abs(a.x)!=1||abs(y)!=1) printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```

方程组角度

```c++
#include<bits/stdc++.h>
#define LL long long
using namespace std;
void read(int &x){
	x=0;char ch=getchar();int f=1;
	while((ch<'0'||ch>'9')&&ch!=45)ch=getchar();
	if(ch==45)ch=getchar(),f=-1;
	while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
	x*=f;
}
template<typename T1,typename T2>void cmax(T1 &x,const T2 &y){if(y>x)x=y;}
template<typename T1,typename T2>void cmin(T1 &x,const T2 &y){if(y<x)x=y;}
const int N=3005;
int i,j,k,m,n,s,t;
int g[N][N],p[105],q[105],ap[105],aq[105];
int _gcd(int a,int b){
	return g[a][b]?g[a][b]:(!b?a:_gcd(b,a%b));
}
int fgcd(int a,int b){
	if(a<N&&b<N)return g[a][b];
	return !b||!a?max(a,b):fgcd(b,a%b);
}
bool check(){
	int f=0,pd[2]={};
	for(i=1;i<=n;i++){
		for(j=1;j<i;j++)if((p[i]||p[j])){
			int final;
			if(p[i]*p[j]>0)final=q[i]*ap[j]+q[j]*-ap[i];
			else final=q[i]*ap[j]+q[j]*ap[i],pd[0]|=final>0,pd[1]|=final<0;
			final/=fgcd(ap[i],ap[j]);
			f=fgcd(f,abs(final));
		}
		if(pd[0]&&pd[1]&&f==1)return 1;
	}
	return 0;
}
void _solve(){
	read(n);
	for(i=1;i<=n;i++)read(p[i]),read(q[i]),ap[i]=abs(p[i]),aq[i]=abs(q[i]);
	int f=1;
	f&=check();
	if(!f)return void(puts("No"));
	swap(p,q);swap(ap,aq);
	f&=check();
	puts(f?"Yes":"No");
}
signed main(){
	for(i=0;i<N;i++)for(j=0;j<=i;j++)g[i][j]=_gcd(i,j);
	for(i=0;i<N;i++)for(j=i;j<N;j++)g[i][j]=g[j][i];
	int T;read(T);
	while(T--){
		_solve();
	}
	return 0;
}

```

#### 参考资料

IOI2004 国家集训队论文 《转化目标在解题中的应用》——栗师

[Cry_For_theMoon 大佬的博客](https://www.cnblogs.com/Cry-For-theMoon/p/17090925.html#5149538)



---

## 作者：Dregen_Yor (赞：8)

### [更好的阅读体验](https://dregen-yor.eu.org/2022/11/22/p8854/)。

# 思路

若超级马能到达棋盘上所有的点，那么超级马一定可以在 X 轴和 Y 轴上随意地移动，换句话说，假设超级马一开始位于 $(0,0)$ 超级马一定可以到达 $(1,0),(0,1),(-1,0),(0,-1)$ 这 $4$ 个点，以这 $4$ 个点为基础，超级马可以移动到任意一个他想去的地方，这时候问题就转化成了超级马经过若干次移动后能否到达上面描述的这 $4$ 个点。

我们先单独考虑 X 轴和 Y 轴，若 X 轴或 Y 轴上所有移动距离的最大公约数不是 $1$ 的话，就说明 超级马可以到达的点的 X 轴或 Y 轴的坐标一定是某个不是 $1$ 的整数的倍数，这样超级马一定不可以到达所有的点。

判断完成之后，我们可以用 BFS 来判断是否能到达上述的 $4$ 个点，对每个能到达的点进行标记，最终判断是否可以到达即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,dx[110],dy[110];
bool v[2100][2100];
bool solve(){
    queue <int>qx,qy;
    qx.push(100),qy.push(100);
    v[100][100]=1;
    int sum=0;
    while(!qx.empty()){
        int x=qx.front(),y=qy.front();
        qx.pop();qy.pop();
        sum++;
        for(int i=1;i<=n;i++){
            int nx=x+dx[i],ny=y+dy[i];
            if(nx>=0&&nx<=200&&ny>=0&&ny<=200&&!v[nx][ny]){
                v[nx][ny]=1;
                qx.push(nx),qy.push(ny);
            }
            if(v[101][100]&&v[100][101]&&v[99][100]&&v[100][99]){
                return true;
            }
        }
    }
    if(v[101][100]&&v[100][101]&&v[99][100]&&v[100][99]){
        return true;
    }
    return false;
}
signed main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=0;i<=200;i++){
            for(int j=0;j<=200;j++){
                v[i][j]=0;
            }
        }
        for(int i=1;i<=n;i++){
            scanf("%d%d",&dx[i],&dy[i]);
        }
        if(n>1){
            int g=__gcd(abs(dx[1]),abs(dx[2]));
            for(int i=3;i<=n;i++){
                g=__gcd(g,abs(dx[i]));
            }
            if(g>1){
                puts("NIE");
                continue;
            }
            g=__gcd(abs(dy[1]),abs(dy[2]));
            for(int i=3;i<=n;i++){
                g=__gcd(g,abs(dy[i]));
            }
            if(g>1){
                puts("NIE");
                continue;
            }
        }
        if(solve()){
            puts("TAK");
        }
        else{
            puts("NIE");
        }
    }
    return 0;
}
```


---

## 作者：qinsishi (赞：6)

对于这道题，和普通 BFS 不同的是：棋盘大小无限。但看一下数据范围，发现每次动作移动的距离都很小，动作数量也很少。这是一个突破口，我们接着往下想。

题目要求的是能否走完所有的格子，其实相当于看：**从一个点能否走到它的上下左右**。满足这个条件，那么意味着可以走完，否则，当然是走不完的。因为**通过上下左右一定可以走完所有的格子**。

那么很显然，我们从原点开始，遍历所有可以通过动作走到的格子，判断是否能走到它的上下左右。

题目的大体思路是这样，有一个小细节：坐标中会出现负数，可以整体偏移成正数。

当然，题目是多组测试，我们可以使用结构体的形式，封装操作，可以使编码简便。

这里是参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 105;
int k, n;
pair<int, int> fang[N];

struct test {
	void input() {
		scanf("%d", &n);
		for (int i=1; i<=n; ++i) {
			scanf("%d%d", &fang[i].first, &fang[i].second);
		}
	}
	void print(bool ok) {
		if (ok) printf("TAK\n");
		else printf("NIE\n");
	}
	void bfs() {
		bool vis[2*N][2*N] = {0};
		queue<pair<int, int> > que;
		que.push({100, 100});
		vis[100][100] = 1;
		while (que.size()) {
			int x=que.front().first, y=que.front().second;
			que.pop();
			if (vis[100][99] && vis[100][101] && vis[99][100] && vis[101][100]) {
				print(1);
				return;
			}
			for (int i=1; i<=n; ++i) {
				int xx = x+fang[i].first;
				int yy = y+fang[i].second;
				if (0 > xx || xx > 200 || 0 > yy || yy > 200) continue;
				if (vis[xx][yy]) continue;
				vis[xx][yy] = 1;
				que.push({xx, yy});
			}
		}
		print(0);
	}
};

int main() {
	scanf("%d", &k);
	while (k--) {
		test t;
		t.input();
		t.bfs();
	}
	return 0;
}
```

---

## 作者：Leasier (赞：4)

显然，只要我们通过这些向量拼出 $(0, \pm 1)$ 和 $(\pm 1, 0)$，就可以达成题目目标。

上述两类向量本质相同，现在考虑拼出 $(0, \pm 1)$ 的情况。

但是直接考虑一堆向量拼起来又太麻烦，因此考虑通过若干个向量两两之间拼出若干 $(0, x)$，根据裴蜀定理，只要满足 $\displaystyle\gcd_{\forall (0, x)}(|x|) = 1$ 且有正有负即可。

下面讨论两种情况：

1. 本来就是 $(0, x)$ 的形式

直接加入集合即可。

2. 本来是由 $(p_i, q_i), (p_j, q_j)$ 拼起来

设向量 $i$ 用了 $x$ 次，向量 $j$ 用了 $y$ 次，则需要满足：

- $p_i x + p_j y = 0$。
- $x, y$ 尽可能小。

由于 $x, y \geq 0$，则此时必须满足 $p_i, p_j$ 异号。

于是我们可以解出一组绝对值最小的解：

- $x = \frac{p_j}{\gcd(|p_i|, |p_j|)}$。
- $y = -\frac{p_i}{\gcd(|p_i|, |p_j|)}$。

注意 $x, y$ 的符号可能与上述恰好相反。

代入 $q_i, q_j$ 即可得到当前构造出的向量 $(0, \frac{q_i |p_j| + q_j |p_i|}{|\gcd(p_i, p_j)|})$。

swap 一下 $p, q$ 再做一遍即可。时间复杂度为 $O(Tn^2 \log w)$，其中 $w$ 为 $p_i, q_i$ 的值域 $100$。

代码：
```cpp
#include <iostream>
#include <cstdlib>

using namespace std;

int p[107], q[107], absp[107];

int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}

inline bool solve(int n){
	int d = 0;
	bool negative = false, positive = false;
	for (int i = 1; i <= n; i++){
		absp[i] = abs(p[i]);
		if (p[i] == 0){
			d = gcd(d, abs(q[i]));
			if (q[i] < 0){
				negative = true;
			} else if (q[i] > 0){
				positive = true;
			}
		}
	}
	for (int i = 1; i < n; i++){
		if (p[i] != 0){
			for (int j = i + 1; j <= n; j++){
				if (p[j] != 0){
					int t = (p[i] * q[j] - p[j] * q[i]) / gcd(absp[i], absp[j]);
					d = gcd(d, abs(t));
					if ((p[i] > 0) != (p[j] > 0)){
						if (p[i] < 0) t = -t;
						if (t < 0){
							negative = true;
						} else if (t > 0){
							positive = true;
						}
					}
				}
			}
		}
	}
	return negative && positive && d == 1;
}

int main(){
	int t;
	cin >> t;
	for (int i = 1; i <= t; i++){
		int n;
		cin >> n;
		for (int j = 1; j <= n; j++){
			cin >> p[j] >> q[j];
		}
		if (!solve(n)){
			cout << "NIE" << endl;
			continue;
		}
		swap(p, q);
		if (!solve(n)){
			cout << "NIE" << endl;
		} else {
			cout << "TAK" << endl;
		}
	}
	return 0;
}
```

---

## 作者：hzxphy (赞：3)

此题就是一个**广搜**题。

## 给一个结论：

只要能到达 $(0,-1),(0,1),(-1,0),(1,0)$，就可以遍历整个图。

## 解释：

我们画图来理解一下：
![](https://cdn.luogu.com.cn/upload/image_hosting/xka3cnn7.png)

那么四个方向是缺一不可的，因为区域不同（左上，右上，左下，右下）。

只需判断 $(0,-1),(0,1),(-1,0),(1,0)$。

用反证法也可以证明出来。

## My Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> P;
int K, N;
int dx[110], dy[110];
bool vist[210][210];
bool AllSides(int x, int y) {
	return vist[x - 1][y] && vist[x + 1][y] && vist[x][y - 1] && vist[x][y + 1];
}
void BFS() {
	memset(vist, false, sizeof(vist));
	queue<P> Q;
	Q.push(P(100, 100)); /*只有一个OI选手(0, 0)。#起点*/
	/*关键在于数组不可以使用负数下标，所以所有键值都会增加100*/
	while (!Q.empty()) {
		P F = Q.front();
		Q.pop();/*IOI选手结束OI生涯*/
		for (int i = 1; i <= N; i++) { /*把N个方向都找一遍*/
			int nx = F.first + dx[i];
			int ny = F.second + dy[i];
			if (nx < 0 || nx > 200 || ny < 0 || ny > 200 || vist[nx][ny]) { /*不越界且未被访问*/
				continue;
			}
			vist[nx][ny] = true;
			Q.push(P(nx, ny));
			if (AllSides(100, 100)) {
				puts("TAK");
				return;
			}
		}
	}
	puts("NIE");
}
int main() {
	cin >> K;
	while (K--) {
		cin >> N;
		for (int i = 1; i <= N; i++) {
			cin >> dx[i] >> dy[i];
		}
		BFS(); /*直接调用就可以了*/
	}
	return 0;
}
```
## 代码重点
1. 不要 puts 回车（这点应该是众所周知的吧）

1. 由于数组不可以使用负数下标，所以所有键值都会从 $(x,y)$ 变为 $(x+100,y+100)$。

AC 撒花！

---

## 作者：Natori (赞：2)

>[P8854 [POI2002] 超级马](https://www.luogu.com.cn/problem/P8854)

2021 年的入门组模拟赛题，今天终于找到原题了，于是来写篇题解。

注意到 $|P|,|Q| \leq 100$，也就是需要考虑的棋盘范围很小，所以可以想到用一个二维的 ```bool``` 数组来存是否可以到达这个点。

然后思考如何判断“是否可以到达棋盘上的每一个地方”。

其实这里有一个相对巧妙的转化：

- 如果可以到达起点上下左右的格子，就可以到达所有格子。

这样就把需要关注的部分从所有格子变成了起点上下左右的格子，效率大大提升。

所以考虑 $\text{BFS}$，每次有新元素入队时判断是否满足条件。注意数组下标可能为负，所以需要整体向右平移 $100$。

注意无解的判定条件：某一时刻队列为空。

每组测试数据最多有 $40000$ 个元素入队，所以跑得会很快。

~~模拟赛的时候队列没注意多打了两个 0，结果就呵呵了~~

代码是一年多前赛时写的，欢迎 hack。~~那时的我还是一个蒟蒻，现在也是~~

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
struct point{
	int x,y;
}q[400000];
bool vis[210][210];
int k,n,dx[110],dy[110];
int main(){
	freopen("horse.in","r",stdin);
	freopen("horse.out","w",stdout);
	
	scanf("%d",&k);
	while(k--){
		memset(vis,0,sizeof(vis)); 
		memset(q,0,sizeof(q));
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d%d",&dy[i],&dx[i]);            
		}
		//BFS
		int h=1,t=1;
		bool f=0; 
		q[h].x=100;q[h].y=100;
		vis[100][100]=1;
		while(h<=t){
			int nx,ny;
			for(int i=1;i<=n;i++){
				nx=q[h].x+dx[i];ny=q[h].y+dy[i];
				if(1<=nx&&nx<=200&&1<=ny&&ny<=200&&!vis[nx][ny]){
					t++;
					q[t].x=nx;
						q[t].y=ny;
					vis[nx][ny]=1;
					if(vis[101][100]&&vis[100][101]&&vis[99][100]&&vis[100][99]){
						f=1;
						printf("TAK\n");
						break;
					}
				}
			}
			if(f)
				break;
			h++;
		} 
		if(!f)
			printf("NIE\n");
	}
	
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

模拟赛的时候还有同学用奇偶性之类的东西写了这题，不过我不知道具体做法，大家可以试着往这方面想一想。

---

## 作者：Notfind (赞：2)

# P8854 [POI2002]超级马 题解
蒟蒻的第一篇题解。

好像这道题用bfs更快一点，有的大佬还用了最大公约数来加速求解。但本人是蒟蒻，所以还是用dfs了。但是代码亲测不吸氧也能过，而且简单易懂。

题面给出了棋盘无穷大，直接求解肯定不行。

所以我们来思考一下满足什么条件才可以遍历整个棋盘。

想想我们的洪水填充算法。每一次都是向四周探索，直到遍历整个图为止。

那反过来，遍历整个图，只需要每个点都可以到达相邻的四个点上就可以了。

#### 将这个结论带入到题目中，就可以将题目转化为：给定一些移动方式，不限次数，问能不能在若干次移动中移动到起点上下左右相邻的四个点上。

这一点很显然。因为既然能从起点经过若干次移动移动到上下左右相邻的四个点上，那么，起点的左边一格也可以通过若干次移动移动到上下左右相邻的四个点上
，起点的右边一格也可以通过若干次移动移动到上下左右相邻的四个点上，以此类推，这样就可以遍历整个棋盘（也就是整个图）了。

问题来了，怎么才能判断能否走到起点上下左右相邻的四个点上呢？

观察数据范围，

 $1 \le K,N \le 100,-100 \le P,Q \le 100 $

再结合题意，本蒟蒻第一时间想到的就是搜索。

但是怎么搜索呢？

这好办。既然题目已经告诉我们了 $ -100 \le P,Q \le 100$，所以我们只需要开一个 $200 * 200$ 的二维数组,然后以 $[100,100]$ 作为起点，每个点只要不超过数组范围就循环将各个移动方式都走一遍，最后看起点上下左右相邻的四个点上是否都遍历过即可。这里可以剪个枝：如果已经发现起点上下左右相邻的四个点都经过了，那么直接跳出搜索，输出。


以下是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=202;
int ax[N],ay[N];
int k,n,p,q;
int a[N][N],e=0;//e是是否经过起点上下左右四个点的标志
void dfs(int x,int y)
{
	a[x][y]=1;
	for(int i=1;i<=n;++i) 
	{
		if(x+ax[i]<=200&&x+ax[i]>=0&&y+ay[i]<=200&&y+ay[i]>=0&&!a[x+ax[i]][y+ay[i]]) dfs(x+ax[i],y+ay[i]);
		if(a[100][101]==1&&a[100][99]==1&&a[101][100]==1&&a[99][100]==1)//剪枝 都经过了就不用搜了 输出TAK 但是如果这句话写在循环外面会T一个点 
		{
			e=1;
			return;
		}
	}
	return;
}
int main()
{
	scanf("%d",&k);
	for(int i=1;i<=k;++i)
	{
		memset(a,0,sizeof(a));
		memset(ax,0,sizeof(ax));
		memset(ay,0,sizeof(ay));//记得每一组数据做完清空数组
		e=0;
		scanf("%d",&n);
		for(int i=1;i<=n;++i) 
		{
			scanf("%d%d",&p,&q);
			ax[i]=p,ay[i]=q;
		}
		dfs(100,100);//暴搜
		if(e==1) printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;	
} 
```






---

## 作者：__3E24AC7002AD9292__ (赞：2)

BFS 水题。

容易发现：假设一个马在 $(i,j)$ 的位置，如果它可以走到 $(i\pm1,j)$ 和 $(i,j\pm1)$，就说明它每个格子都能走到（显然）。

发现这题 $0\leq |P|,|Q|\leq 100$，所以可以在 $(-100,-100)$ 到 $(100,100)$ 区间内 BFS，走过的格子还有超出范围的格子就不走了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mpr make_pair
#define fr first
#define sc second
inline int read(){
	int res=0,f=1;char c=getchar();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') {res=res*10+(c-'0');c=getchar();}
	return res*f;
}
int T,n,dx[105],dy[105];
pair<int,int>que[200005];
const int maxx=200,maxy=200,minx=0,miny=0;
bitset<205>e[205];
bool tmp;
bool dfs(const int ax,const int ay){
	int h=0,t=0;
	que[h]=mpr(ax,ay);
	while (h<=t){
		if (e[99][100]&&e[101][100]&&e[100][99]&&e[100][101]) return 1;
		const int x=que[h].fr,y=que[h++].sc;
		for (register int i=1;i<=n;i++){
			const int cx=x+dx[i],cy=y+dy[i];
			if (cx>=minx&&cy>=miny&&cx<=maxx&&cy<=maxy&&!e[cx][cy]) que[++t]=mpr(cx,cy),e[cx][cy]=1;
		}
	}
	return 0;
}
signed main(){
	T=read();
	while (T--){
		n=read();
		for (register int i=1;i<=n;i++) dx[i]=read(),dy[i]=read();
		for (register int i=minx;i<=maxx;i++) for (register int j=miny;j<=maxy;j++) e[i][j]=0;
		if (dfs(100,100)) puts("TAK");
		else puts("NIE");
	}
	return 0;
}
```


---

## 作者：wangzhanchen (赞：1)

# P8854 题解
[题面传送门](https://www.luogu.com.cn/problem/P8854)
## 思路引导
读完这道题，我的第一个想法就是 BFS。确实，只要稍微思考一下，此题即可轻松解决。但是，此题要注意的小点很多。

首先，这个棋盘是无限大的，然而，问题是“判断超级马是否可以到达棋盘所有地方”。怎么样才能知道，马可以到达棋盘所有地方？如果它可以达到他的上下左右，那马就可以到达每个地方。

接下来要确定 v 数组的范围。因为 $-100\le P,Q\le100$，而数组下标不能小于 $0$，所以原点设在 $(100,100)$，横坐标范围为 $0\sim200$，纵坐标范围与横坐标相同。~~（这里的教训真的很惨痛）~~

最后是玄学问题，感谢 xinyu123 dalao 的题解，判断一定要在队列插入后，并且不能直接返回。
## Code
Warning ：据说上一个抄代码的已经棕名了~
```cpp
/*
	Name: super horse 
	Description:
*/

#include<bits/stdc++.h>
#define return 0; while(1) printf("zi'zuo'zi'shou\n");

using namespace std;
typedef long long ll;

const int INF=0x3f3f3f3f,N=105,M=205;

struct point{
	int x,y;
}ppp;

int k,n,ans;
int dx[N],dy[N];

void bfs(){
	bool f=0;
	queue<point>q;
	int v[M][M]={0};
	v[100][100]=1;
	q.push(ppp);
	while(!q.empty()){
		int _x=q.front().x;
		int _y=q.front().y;
		q.pop();
		for(int i=1;i<=n;i++){
			int xx=_x+dx[i];
			int yy=_y+dy[i];
			if(xx>=0&&xx<M&&yy>=0&&yy<M&&v[xx][yy]==0){
				point p;
				p.x=xx;
				p.y=yy;
				v[xx][yy]=1;
				q.push(p);
				if(v[99][100]==1&&v[101][100]==1&&v[100][99]==1&&v[100][101]==1){
					printf("TAK\n");
					f=1;
					while(!q.empty()){
						q.pop();
					}
					break;//玄学问题
				}
			}
		}
	}
	if(f==0){
		printf("NIE\n");	
	}
	return;
}

int main(){
	ppp.x=ppp.y=100;
	scanf("%d",&k);
	while(k--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			int xxx,yyy;
			scanf("%d%d",&xxx,&yyy);
			dx[i]=xxx;
			dy[i]=yyy;
		}
		bfs();
	}
	return 0;
}
```
## 写在后面
[AC记录](https://www.luogu.com.cn/record/123051845)

本蒟蒻的第一篇题解，望请手下留情

---

## 作者：I_will_AKIOI (赞：1)

一道广搜板子题。

原来 $fx$ 和 $fy$ 数组是存储方向的 （上下左右），现在方向是不固定的，就不用设置方向，直接读入即可。接下来就按广搜的模板来解就行了。

但问题又来了——怎么判断超级马能走遍每个角落呢？如果判断马能不能走到一片区域，需要用 $O(n^2)$ 的复杂度判断，这样太慢了。

再思考一下，只要超级马能改变它的横纵坐标，也就是能到达 $(0,\pm1),(\pm1,0)$ 四个点，就说明可以到达每个角落了。

当然，数组不支持负下标，所以最后还要把每个点的 $x$ 坐标向右移动 $100$。下面是美汁汁的代码时间：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct data {int x,y;}w;
queue<data>q;
int x,y,k,n,nx,ny;
int fx[101],fy[101];//存储超级马能走的方向 
bool vis[201][201];
void BFS()
{
    w.x=100;//x坐标右移100，防止负数导致RE 
    w.y=100;
    q.push(w);
    while(!q.empty())
    {
        w=q.front();
        x=w.x;
        y=w.y;
        q.pop();
        for(int i=1;i<=n;i++)
        {
            nx=x+fx[i];
            ny=y+fy[i];
            if(nx>=0&&nx<=200&&ny>=0&&ny<=200&&!vis[nx][ny])//合法的点才压入队列 
            {
                vis[nx][ny]=1;
                w.x=nx;
                w.y=ny;
                q.push(w);
                f(vis[101][100]&&vis[100][101]&&vis[99][100]&&vis[100][99])//#2能随意移动 
                {
                    printf("TAK\n");
                    while(!q.empty()) q.pop();
                     break;//该代码直接return会出玄学的bug
                }
            }
        }
    }
    if(!(vis[101][100]&&vis[100][101]&&vis[99][100]&&vis[100][99])) printf("NIE\n"); 
    return; 
}
int main()
{  	  	
    scanf("%d",&k);
    while(k--) 
    {
        memset(vis,0,sizeof(vis));//#1
        scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d%d",&fx[i],&fy[i]);
        BFS();
    }
    return 0;
}
```
1. ```memset``` 可以初始化二维数组，鉴于数据较多，可以节省一些时间

2. 直接 ```return``` 会出现玄学的问题，一直输出 TAK。

完结撒花！

---

## 作者：LightSpot (赞：1)

本蒟蒻的第二篇题解

### 题目分析：

看到这道题时，我们知道棋盘是无限大的，肯定不能直接搜索。但是我们知道，如果想要能移动到棋盘上的任意地方，只需要超级马能通过任意步从自身到达其正上方一格、正下方一格、正左方一格、正右方一格这四格。因此，我们确定了搜索目标。

不仅如此，我们还要确定搜索范围。虽然说棋盘是无限大的，但是因为数据范围给定了 $-100 \leqslant P,Q \leqslant 100$，因此若我们要留足够的空间只需要将棋盘大小设置为 $200 \times 200$ 即可。

接下来，就可以愉快地用 BFS 解题了!

### AC代码：

```cpp
#include<iostream>
using namespace std;
int K; //K表示数据组数
struct Horse
{
	int N; //N表示超级马能完成的动作个数
	int Move[101][2]; //Move表示这个动作
	bool Is_Super; //Is_Super表示超级马是否可以到达棋盘所有地方
};
Horse Super[101]; //Super表示所有超级马
void BFS(int Num) //Num代表当前超级马的编号
{
	bool Vis[202][202] = {}; //Vis表示当前棋格是否被走过（一定要初始化！！！之前就在这里死了）
	int Flag = 0; //Flag表示能否走到题目分析中所说的那四格
	int Pos[40004][2]; //BFS数组
	int Head = 0 , Tail = 0; //头尾双指针
	Vis[99][99] = 1; //BFS数组初始化
	Pos[0][0] = 0;
	Pos[0][1] = 0;
	Tail++;
	while(Head != Tail) //进行搜索
	{
		for(int I = 0 ; I < Super[Num].N ; I++)
		{
			int NX = Pos[Head][0] + Super[Num].Move[I][0] , NY = Pos[Head][1] + Super[Num].Move[I][1];
			if(NX > -100 && NX <= 100 && NY > -100 && NY <= 100 && Vis[NX + 100 - 1][NY + 100 - 1] == 0) //注意Vis数组的下标确定
			{
				Pos[Tail][0] = NX;
				Pos[Tail][1] = NY;
				Vis[NX + 100 - 1][NY + 100 - 1] = 1;
				Tail++;
				if((NX == 0 && NY == 1) || (NX == 1 && NY == 0) || (NX == 0 && NY == -1) || (NX == -1 && NY == 0)) Flag++;
			}
			if(Flag == 4) break;
		}
		if(Flag == 4) break;
		Head++;
	}
	if(Flag == 4) Super[Num].Is_Super = 1; //判断并记录超级马是否可以到达棋盘所有地方
	else Super[Num].Is_Super = 0;
}
int main()
{
	cin >> K; //进行输入
	for(int I = 0 ; I < K ; I++)
	{
		cin >> Super[I].N;
		for(int J = 0 ; J < Super[I].N ; J++) cin >> Super[I].Move[J][0] >> Super[I].Move[J][1];
		BFS(I); //调用BFS函数
	}
	for(int I = 0 ; I < K ; I++) //输出
	{
		if(Super[I].Is_Super == 1) cout << "TAK" << endl;
		else cout << "NIE" << endl;
	}
	return 0;
}
```


---

## 作者：MuelsyseU (赞：1)

考虑能够到达所有点等价于可以在加法运算下多次使用给定二元组 $(a_i,b_i)$，以表出所有整数范围内的二元组。

容易证明可行当且仅当可以表出 $(1,0),(0,1),(-1,0),(0,-1)$。

显然这又要求 $a$ 中的整数最大公约数为 $1$，对 $b$ 同理。

$$a_1x+a_2y=1$$

那么可以发现，若不考虑 $b$ 的限制，由裴蜀定理可知此时必定有解，且 $x$ 的最小整数解为 $x'=x \mod a_2$，即任意 $a_i$ 被使用的次数不会超过 $100$。

而如果考虑 $b$ 的限制，那么很显然特解为 $x'+a_2t(t\in\mathbb{R})$，因此要满足限制必须每次调整 $\operatorname{lcm}(a_2,b_2)$，该值不超过 $10^4$，因此显然最终可能满足的决策较少。

于是直接 BFS 或 DP 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

queue<pair<int, int>> q;
bool v[210][210];
int k, fl, n, a[110], b[110];
int nx, ny;
int main() {
    scanf("%d", &k);
    while (k--) {
        memset(v, 0, sizeof(v));
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d%d", a + i, b + i);
        // BFS
        while (q.size()) q.pop();
        q.emplace(100, 100), fl = 0, v[100][100] = 1;
        while (q.size()) {
            pair<int, int> p = q.front();
            q.pop();
            for (int i = 1; i <= n; i++) {
                nx = p.first + a[i], ny = p.second + b[i];
                if (1 <= nx && nx <= 200 && 1 <= ny && ny <= 200 && !v[nx][ny]) {
                    q.emplace(nx, ny), v[nx][ny] = 1;
                    if (v[101][100] && v[100][101] && v[99][100] && v[100][99]) {
                        printf("TAK\n");
                        fl = 1;
                        break;
                    }
                }
            }
            if (fl) break;
        }
        if (!fl) printf("NIE\n");
    }
    return 0;
}
```

---


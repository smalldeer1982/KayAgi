# [NICA #3] 数计组数

## 题目描述

称一个长度为 $n$ 的数组 $a$ 是“数计的”，当且仅当存在一种将其划分成若干个区间的方案，使得每个区间的最小值恰好等于区间长度，或者说存在 $0=x_1<x_2<x_3<\cdots<x_m=n$，满足 $\forall 1\le i<m,\min\limits_{j=x_i+1}^{x_{i+1}}a_j=x_{i+1}-x_i$。

给定正整数集 $S$，询问有多少长度为 $n$ 的数组 $a$ 满足 $a_i\in S$ 且 $a$ 是“数计的”。答案对 $10^9+7$ 取模。

## 说明/提示

#### 样例 1 解释

只有两种可能的数组为“数计的”，分别是 $[1,1]$ 和 $[2,2]$。

#### 数据范围

对于所有数据，保证 $1\le n\le 2000$，$1\le m\le 100000$，$1\le b_1< b_2<b_3<b_4<\cdots<b_m\le 10^6$。

## 样例 #1

### 输入

```
2 2
1 2```

### 输出

```
2```

# 题解

## 作者：P2441M (赞：3)

[原题链接：B3902 [NICA #3] 数计组数](https://www.luogu.com.cn/problem/B3902)

这题明显是计数类DP题。容易想到令 $F_i$ 表示长度为 $i$ 的数计组数，我们需要考虑的是，$\forall j<i$，$F_j$ 与 $F_i$ 之间如何进行转移。

为了避免子问题互斥，可以想到在 $F_j$ 的基础上，新划分出一个长度为 $i-j$ 的区间 $S'$，使得新的长度为 $i$ 的数组是“数计的”。接下来，我们单独考虑区间 $S'$ 应如何填数。根据定义，$\mathop{\min}\limits_{a\in S'}\{{a}\}\geqslant i-j$，且 $i-j$ 应出现**至少也仅有** $1$ 次。这同时也反映了，如果 $i-j\notin S$，则 $F[j]$ 与 $F[i]$ 之间不应该发生转移。

我们可以用排列组合计算区间 $S'$ 的排列数 $C_{i-j}$。预定义 $c_i=M-\mathop{min}\limits_{j\in[1,n],S[j]\geqslant i}\{j\}$，即 $S$ 中大于等于 $i$ 的元素个数（之所以写成这种形式，是为了方便使用 `std::lower_bound` 二分计算）。此时，$S'$ 的总排列数为 $c_{i-j}^{i-j}$。再考虑使得 $S'$ 不是“数计的”的排列数，相当于最小值不是 $i-j$，即不选 $i-j$，所以有 $(c_{i-j}-1)^{i-j}$ 种排列。综上，$S'$ 有
$$C_{i-j}=c_{i-j}^{i-j}-(c_{i-j}-1)^{i-j}$$
种排列数。

根据乘法原理，我们可以轻松地得到最终的状态转移方程：

$$
F_0=1,
F_i=\sum_{j\in[0,i),i-j\in S}{F_j\times C_{i-j}}.
$$

上代码：
```cpp
#include <iostream>
#include <cstring>

using namespace std;

constexpr int MAX_N = 2000, MAX_M = 100000, MAX_ELEM = 1000000, MOD = 1e9 + 7;
int n, m;
bool exists[MAX_ELEM + 1]; // 判定是否在集合中
int s[MAX_M + 1]; // 原始集合
int c[MAX_N + 1]; // c[i]表示S中>=i的数的个数
long long f[MAX_N + 1]; // f[i]表示长度为i的“数计的”数组个数

// 快速幂
long long quick_power(long long a, long long b) {
	long long res = 1;
	for (; b; b >>= 1) {
		if (b & 1) res = res % MOD * a % MOD;
		a = a % MOD * a % MOD;
	}
	return res;
}

int main() {
	memset(exists, 0, sizeof exists);
	memset(f, 0, sizeof f);

	cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		cin >> s[i];
		exists[s[i]] = true;
	}

	// 二分计算c数组
	for (int i = 1; i <= n; ++i)
		c[i] = s + m + 1 - lower_bound(s + 1, s + m + 1, i);

	// 进行DP状态转移
	f[0] = 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 0; j < i; ++j)
			if (exists[i - j]) {
				f[i] += f[j]
					* (quick_power(c[i - j], i - j) - quick_power(c[i - j] - 1, i - j) + MOD /* + MOD 是为了保证非负 */)
					% MOD;
				f[i] %= MOD;
			}

	cout << f[n] << endl;

	return 0;
}
```

---

## 作者：FFTotoro (赞：3)

简单计数背包 DP。

令 $f_i$ 为长度为 $i$ 的合法数组有多少个。初始 $f_0=1$；假设要从 $f_j$ 转移到 $f_i$，考虑中间 $i-j$ 个数怎么填：显然只能填大于等于 $i-j$ 的数且 $i-j$ 至少出现一次（如果 $i-j$ 不在 $S$ 中那么无法转移），令 $a_x$ 为大于等于 $x$ 的数的种类，方案数即为 $x=a_{i-j}^{i-j}-(a_{i-j}-1)^{i-j}$。根据乘法原理，有转移 $f_i=f_j\cdot x$。

计算过程可以借助快速幂实现。$a_x$ 可以用 `std::lower_bound` 预处理。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int p=1e9+7;
int qpow(int a,int b){
  int r=1;
  while(b){
    if(b&1)r=r%p*a%p;
    a=a%p*a%p,b>>=1;
  }
  return r;
} // 快速幂
main(){
  ios::sync_with_stdio(false);
  int n,m; cin>>n>>m;
  vector<int> b(m),e(n+1),c(n+1),f(n+1);
  for(auto &i:b)if(cin>>i;i<=n)e[i]=1;
  for(int i=1;i<=n;i++)
    c[i]=m-(lower_bound(b.begin(),b.end(),i)-b.begin());
    // 二分预处理
  for(int i=f[0]=1;i<=n;i++)
    for(int j=0;j<i;j++)
      if(e[i-j])(f[i]+=f[j]*(qpow(c[i-j],i-j)-qpow(c[i-j]-1,i-j)+p)%p)%=p;
      // 进行转移
  cout<<f[n]<<endl;
  return 0;
}
```

---

## 作者：Po7ed (赞：0)

### 前言

[题目链接](https://www.luogu.com.cn/problem/B3902)。

感觉其他题解写麻烦了，不需要二分罢。思路描述看上去较复杂，其实是写的比较详细。

先放个强一点的样例，需要自取。

输入：

```text
5 3
1 4 5
```

输出：

```text
32
```

### 思路

考虑 dp，设 $dp(i)$ 表示数组长度为 $i$ 的方案数。转移时枚举最后一个区间的长度（即区间最小值）$b_j$，根据乘法原理和加法原理，可依照下式转移

$$
dp(i)=\sum_{j=1}^{m}dp(i-b_j)\times v_{j}
$$

其中 $v_j$ 表示长度为 $b_j$，最小值也为 $b_j$ 的数组数量。也就是说，长度为 $i$ 的新数组由两部分构成：第一部分是 $[1,i-b_j]$，这部分方案数为 $dp(i-b_j)$；第二部分是 $[i-b_j+1,i]$，这部分长度为 $b_j$，方案数为 $v_j$。两部分相互独立，总方案数为二者方案数之积。

考虑如何求 $v_j$。因为最小值为 $b_j$，故合法数组由 $T=\{x\in S|x\ge b_j\}$ 中元素组成。可以发现，$v_j$ 即为「取出 $b_j$ 个 $T$ 中元素，其中必须包含 $b_j$」的方案数。$v_j$ 同时等于「取出 $b_j$ 个 $T$ 中元素」的方案数减去「取出 $b_j$ 个 $T$ 中元素，其中不能包含 $b_j$」的方案数。前者方案数为 $|T|^{b(j)}$，后者方案数为 $|T\setminus\{b_j\}|^{b_j}$。因为 $|T|=m-j+1,|T\setminus\{b_j\}|=m-j$，故上面这段话用公式表达就是

$$
v_j=(m-j+1)^{b(j)}-(m-j)^{b(j)}
$$

代入 dp 即可。

### 代码

```cpp
#include <iostream>

using std::cin;
typedef long long ll;
constexpr int N=2145,M=114514,mod=1e9+7;

int n,m;
int b[M],v[M];
int dp[N];
inline void add(int& x,int y){((x+=y)>=mod)&&(x-=mod);}
inline int qpow(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=m;i++)cin>>b[i],v[i]=((qpow(m-i+1,b[i])-qpow(m-i,b[i]))%mod+mod)%mod;
	dp[0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m&&b[j]<=i;j++)
		{
			add(dp[i],(1ll*dp[i-b[j]]*v[j])%mod);
		}
	}
	printf("%d",dp[n]);
	return 0;
}
```

---


# [GXPC-S 2024] 分糖果

## 题目背景


小林最近迷上了博弈问题。

## 题目描述

有 $n$ 包糖果从左到右依次排成一行，第 $i$ 包糖果中有 $a_i$ 个糖果。小林和小伊从左到右对 $n$ 包糖果进行分配，分配权一开始在小林手里，小林可以将 $n$ 包糖果中最左端的糖果分配给自己或者小伊，本次分配中**没有拿到糖果**的人将拥有下一次的分配权。

如果小林和小伊都足够聪明，会采用最优的策略进行分配，保证自己最后拥有的糖果总数最多，如此分配 $n$ 轮后，求出小林和小伊中**糖果更多的那个人**所拥有的糖果数量。

## 说明/提示

样例解释：如下是他们的游戏过程。

- 小林将 $1$ 分给自己；此时小林和小伊的糖果数分别为 $1,0$；
- 小伊将 $3$ 分给小林；此时小林和小伊的糖果数分别为 $4,0$；
- 小伊将 $5$ 分给自己；此时小林和小伊的糖果数分别为 $4,5$；
- 小林将 $7$ 分给小伊；此时小林和小伊的糖果数分别为 $4,12$；
- 小林将 $9$ 分给自己；此时小林和小伊的糖果数分别为 $13,12$。

可以证明这是最优的游戏策略。


**本题采用捆绑测试。**

- Subtask 1（40pts）：保证 $n\le 20$；
- Subtask 2（60pts）：无额外约束。

对于 $100\%$ 的数据，保证 $1\le n,a_i\le 10^5$。

## 样例 #1

### 输入

```
5
1 3 5 7 9```

### 输出

```
13```

# 题解

## 作者：Sliarae (赞：1)

设 $f_i$ 为考虑编号为 $i \sim n$ 这段后缀的糖果，先手选能获得的最大收益。答案为 $f_1$。

考虑转移，假设要求 $f_i$ 且 $f_{(i + 1) \sim n}$ 已经求出。此时先手有两种决策，放弃这包糖果，获得下一轮的先手权，收益为 $f_{i + 1}$，或选这包糖果并获得 ${(i + 1) \sim n}$ 这段后缀的后手收益。转移方程：

$$

f_{i} = \max(f_{i + 1}, \sum\limits_{j = i}^{n} a_i - f_{i + 1})

$$

时间复杂度 $O(n)$。

```cpp
#include <iostream>

using namespace std;
using LL = long long;

const int kN = 1e5 + 5;

int n;
int a[kN];

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	LL dp = 0, sum = 0; 
	for (int i = n; i; --i) 
		dp = max(dp, a[i] + sum - dp), sum += a[i];
	cout << dp << '\n';
	return 0; 
}
```

---

## 作者：aeiouaoeiu (赞：0)

设 $f_{i,0/1,0/1}$ 表示从第 $i$ 个糖果开始向右分配，林/伊先手，在先手采取最优策略的情况下，林/伊的分数。

考虑先手是否取走当前糖果，若取走则轮到下一个人取，否则这个人继续选择，有 $f_{i,0,0}=\max(f_{i+1,0,0},a_i+f_{i+1,1,0}),f_{i,1,1}=\max(f_{i+1,1,1},a_i+f_{i+1,0,1})$。

根据 $f_{i,0,0}$ 的决策点不同，$f_{i,0,1}$ 可以是 $a_i+f_{i+1,0,1}$（若先手不选更优，则这个糖果分给后手）或 $f_{i+1,1,1}$（反之）。$f_{i,1,0}$ 同理。

初始化为 $f_{n,0,0}=f_{n,1,1}=a_n$，答案为 $\max(f_{1,0,0},f_{1,0,1})$，时间复杂度 $\mathcal{O}(n)$。

```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define pob pop_back
#define mp make_pair
#define Debug if(0)
using namespace std;
typedef long long ll;
typedef long double db;
const int maxn=200007,dx[9]={0,0,-1,1,-1,1,-1,1,0},dy[9]={-1,1,0,0,1,-1,-1,1,0};
ll n,a[maxn],f[maxn][2][2];
int main(void){
	//freopen("data.in","r",stdin);
	//freopen("data.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	ll T=1;
	//cin>>T;
	for(int tcs=1;tcs<=T;tcs++){
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		f[n][0][0]=f[n][1][1]=a[n];
		for(int i=n-1;i>=1;i--){
			if(a[i]+f[i+1][1][0]>f[i+1][0][0]){
				f[i][0][0]=a[i]+f[i+1][1][0];
				f[i][0][1]=f[i+1][1][1];
			}else{
				f[i][0][0]=f[i+1][0][0];
				f[i][0][1]=a[i]+f[i+1][0][1];
			}
			if(a[i]+f[i+1][0][1]>f[i+1][1][1]){
				f[i][1][1]=a[i]+f[i+1][0][1];
				f[i][1][0]=f[i+1][0][0];
			}else{
				f[i][1][1]=f[i+1][1][1];
				f[i][1][0]=a[i]+f[i+1][1][0];
			}
		}
		cout<<max(f[1][0][1],f[1][0][0])<<"\n";
	}
	return 0;
}
```

---


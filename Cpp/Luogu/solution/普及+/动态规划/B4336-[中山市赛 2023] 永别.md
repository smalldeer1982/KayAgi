# [中山市赛 2023] 永别

## 题目描述

你做了一个梦，梦里有一个字符串，这个字符串无论正着读还是倒着读都是一样的，例如：$\tt abcba$ 就符合这个条件。

但是你醒来时不记得梦中的字符串是什么，只记得它是另一个字符串 $S$ 的子序列，你想知道梦中字符串最长是多少。

提示：字符串 $A$ 是字符串 $B$ 的子序列当且仅当从 $B$ 中删除若干个字符（可以不删）后可以变成 $A$。例如：$\tt acd$ 是 $\tt achda$ 的子序列，因为从 $\tt achda$ 中删去第 $3$ 个和第 $5$ 个字符后就是 $\tt acd$。 

## 说明/提示

### 样例解释

从 $\tt acbdcaa$ 中删去第 $4$ 个和第 $7$ 个字符后变成 $\tt acbca$ 就满足正着读还是倒着读都是一样，不难发
现这是最长的。 

### 数据范围

对于 $15\%$ 的数据，$len \le 20$。

对于 $30\%$ 的数据，$len \le 200$。

对于 $45\%$ 的数据，$len \le 700$。

对于另外 $15\%$ 的数据，$len \le 800$，字符串中只会出现字母 $\tt a$ 和 $\tt b$。

对于 $100\%$ 的数据，$3 \le len \le 1000$，字符串中只会出现英文小写字母。

## 样例 #1

### 输入

```
7
acbdcaa```

### 输出

```
5```

# 题解

## 作者：jiezecheng (赞：5)

## 题目描述
即给定一个字符串，求其最长回文子串。
## 思路
不难想到需要 dp。

嘶……为啥呢？

首先明确几点，dp 题目有如下几个特点：
1. 最优子结构：即大问题的最优解可以通过其小问题的最优解组合得到
2. ‌重叠子问题‌：小问题在递归求解中被重复计算。dp 通过存储子问题的解避免重复计算

这道题就完美地符合这两个条件：
1. 最优子结构：整个字符串的最优解可以由其子串的最优解组合得到。
2. 计算 $dp_{i,j}$ 时可能多次访问 $dp_{i+1,j-1}$，dp 算法避免了重复计算，将 $O(2^n)$ 时间优化至 $O(n^2)$。

### 具体解法
约定： $s_{[i,j]}$ 表示 $s$ 从第 $i$ 个字符到第 $j$ 个字符的子串。
我们这道题定义 $dp_{i,j}$ 表示字符串 $s_{[i,j]}$ 的最长回文子序列。

初始化：单字符串就是回文串，则对于 $1\le i \le n,dp_{i,i}=1$。

枚举 $i,j$：

- 如果 $s_i=s_j$，则可以通过将 $s_{[i+1,j-1]}$ 的答案拼接上 $s_i,s_j$ 从而是答案增加 $2$。
- 如果 $s_i\ne s_j$，$s_i$ 与 $s_j$ 都不行，那就在自己的子串选一个取最大值，答案为 $\max(dp_{i+1,j},dp_{i,j-1})$。


最终答案为 $dp_{1,n}$。

好！！！

我兴致勃勃的写了一篇代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
string s;
int dp[N][N];
int main(){
	int n;
	cin>>n;
	cin>>s;
	s=" "+s;
	for(int i=1;i<=n;i++){
		dp[i][i]=1;
		//单字符就是回文串
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(s[i]==s[j]){
				dp[i][j]=dp[i+1][j-1]+2;
			}else{
				dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
			}
		}
	}
	cout<<dp[1][n];
}
```
哇，零分。
[![pVFsmbn.png](https://s21.ax1x.com/2025/06/09/pVFsmbn.png)](https://www.luogu.com.cn/record/220038093)

为什么呢？

debug 一下，既然 $dp$ 是个二维数组，那就把它画出来。

就以样例为例吧：
```
7
acbdcaa
```
在初始化后的 $dp$：

[![pVFsjiV.png](https://s21.ax1x.com/2025/06/09/pVFsjiV.png)](https://imgse.com/i/pVFsjiV)

接下来按照程序，更新 $dp_{1,2}$，观察发现 $s_1\ne s_2$，$dp_{1,2}=\max(dp_{2,2},dp_{1,1})=1$。

截下来更新 $dp_{1,3}$ ，发现 $s_1\ne s_3$ 则 $dp_{1,3}=\max(dp_{2,3},dp_{1,2})$。

补兑！$dp_{2,3}$ 还没有更新过呢！那不炸了，按照默认值 $0$，$dp_{1,3}=\max(1,0)=1$。

虽说 $dp_{1,3}$ 在数据上看是正确的，但是求法是错误的，如果继续按照这样求下去，会得到：
[![pVFyvTI.png](https://s21.ax1x.com/2025/06/09/pVFyvTI.png)](https://imgse.com/i/pVFyvTI)

空白部分均为 $0$。

### 解决问题

观察状态转移公式：
- 如果 $s_i\ne s_j,dp_{i,j}=\max(dp_{i+1,j},dp_{i,j-1})$。

为了使在枚举到 $i$ 时，$i+1$ 已经被枚举过了，所以 $i$ 要**倒序**枚举。

同理，使在枚举到 $j$ 时，$j-1$ 已经被枚举过了，要**正序**枚举。

## 最终代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
string s;
int dp[N][N];
int main(){
	int n;
	cin>>n;
	cin>>s;
	s=" "+s;
	for(int i=1;i<=n;i++){
		dp[i][i]=1;
		//单字符就是回文串
	}
	for(int i=n;i>=1;i--){
		for(int j=i+1;j<=n;j++){
			if(s[i]==s[j]){
				dp[i][j]=dp[i+1][j-1]+2;
			}else{
				dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
			}
		}
	}
	cout<<dp[1][n];
}
```
[![pVF6StP.png](https://s21.ax1x.com/2025/06/09/pVF6StP.png)](https://www.luogu.com.cn/record/220038173)

耶！

---

## 作者：AFO_Lzx (赞：4)

退役后的第一篇题解，OI，[永别了](https://www.luogu.com.cn/problem/B4336)。

很显然应该用 $O(n^2)$ 的做法，区间 DP 应该是个不错的选择。

- 设计状态：设 $f_{i,j}$ 为从 $i$ 到 $j$ 中最长回文子序列的长度。
- 确定答案：很显然，因为字符串的下标从 $0$ 开始，所以答案为 $f_{0,n-1}$，也就是从 $0$ 到 $n-1$ 中最长回文子序列的长度。
- 状态转移：

  ① 当 $s_i=s_j$ 时，可以构成一个回文子序列，$f_{i,j}=f_{i+1,j-1}+2$。
  
  ② 当 $s_i\ne s_j$ 时，不能构成，$f_{i,j}=\max(f_{i+1,j},f_{i,j-1})$。

- 初始化：很显然，长度为 $1$ 的区间的最长回文子序列的长度为 $1$，故 $f_{i,i}=1$。

可以通过本题的代码如下：

```cpp
#include<bits/stdc++.h>
using ll = long long;
using namespace std;

const int N = 1e3 + 5;
int n, f[N][N];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	string s;
	cin >> s;
	
	for (int i = 0; i < n; i++) {
		f[i][i] = 1;
	}
	for (int l = 2; l <= n; l++) {
		for (int i = 0; i < n - l + 1; i++) {
			int j = i + l - 1;
			if (s[i] == s[j]) f[i][j] = f[i + 1][j - 1] + 2;
			else f[i][j] = max(f[i][j - 1], f[i + 1][j]);
		}
	}
	cout << f[0][n - 1] << '\n';
	return 0;
}
```

---

## 作者：Cute_QiQi (赞：2)

题目大意
-

给定一个字符串 $S$，求 $S$ 的最长回文子序列。

方法
-

动态规划，时间复杂度 $\Omicron(n^2)$。

设 $dp_{i,j}$ 表示 $S_i$ 至 $S_j$ 的子串的最长回文子序列长度，容易看出当 $S_i=S_j$，即这一段可以加入回文，即 $dp_{i,j}=dp_{i+1,j-1}+2$；若不等则取更小子串的最长长度，即 $dp_{i,j}=\textrm{max}(dp_{i+1,j},dp_{i,j-1})$。


```cpp
if (s[i] == s[j]) {
  dp[i][j] = dp[i + 1][j - 1] + 2;
}
else {
  dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
}
```

初始化：因为单个字母为回文，初始化 `dp[i][i] = 1`。

细节：每次转移用到的是长度更短子串的数据（而不是更前的），故枚举长度的循环应位于最外层。

答案：$dp_{1,n}$。

AC Code
-

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1005
#define int long long
#define speed ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)
int n, dp[MAXN][MAXN];
string s;
signed main () {
	speed;
	cin >> n >> s;
	s = ' ' + s;
	for (int i = 1; i <= n; ++ i) dp[i][i] = 1;
	for (int l = 2; l <= n; ++ l) {
		for (int i = 1; i <= n - l + 1; ++ i) {
			int j = i + l - 1;
			if (s[i] == s[j]) {
				dp[i][j] = dp[i + 1][j - 1] + 2;
			}
			else {
				dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
			}
		}
	}
	cout << dp[1][n];
	return 0;
}
```

> 成长或许是放下了喜欢，也学会了闭嘴

时隔 $6$ 月 $27$ 天 $38$ 分，失踪人口回归。

---

## 作者：PKUS_zmj (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4336)
# 思路
看到题目首先想到区间 dp，定义 $dp_{i,j}$ 为字符串从索引 $i$ 到 $j$ 的最长回文子序列的长度。状态转移方程为：

- 当 $S_i=S_j$ 时，$dp_{i,j}=dp_{i+1,j-1}+2$；
- 当 $S_i \ne S_j$ 时，$dp_{i,j}=\max(dp_{i+1,j},dp_{i,j-1})$。

答案：$dp_{0,len-1}$。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int l;
    cin>>l;
    string s;
    cin>>s;
    int dp[l+5][l+5];
    for(int i=0;i<l;i++) dp[i][i]=1;
    for(int cl=2;cl<=l;cl++)
    {
        for(int i=0;i<=l-cl;i++)
        {
            int j=i+cl-1;
            if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2;
            else dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
        }
    }
    cout<<dp[0][l-1];
    return 0;
}
```

---

## 作者：linhanmo (赞：1)

# 题解：B4336 [中山市赛 2023] 永别

提供一种转化的思路。

## 思路

题目等价于求最长回文子序列。

我们发现回文子序列可以看作是一个子序列与其逆序的某种组合。

> 以样例为例：$\texttt{acbdcaa}$ 和其逆序串 $\texttt{aacdbca}$，它们的公共子序列有 $\texttt{a}$，$\texttt{aa}$，$\texttt{acca}$ 等，都是回文串。

那么最长回文子序列就是原字符串和其逆序字符串的最长公共子序列。

> 还是以样例为例：$\texttt{acbdcaa}$ 和其逆序串 $\texttt{aacdbca}$，它们的最长公共子序列是 $\texttt{abcba}$ 等。

我们知道最长公共子序列可以在 $Θ(n^2)$ 的时间解决。

于是总时间复杂度就是 $Θ(n^2)$ 了。

代码很简单，就不放了。

---

## 作者：DashZhanghanxu (赞：1)

# 解析
~~总感觉在哪里见过类似的题......正好本小菜刚刚学完区间 DP，就写篇题解练练吧。~~

一道区间 DP 题目。

审题后易得题目问的是一个字符串中不一定连续的回文子串的最长长度。

先是区间枚举操作以及初始化（每个字母都是一个长度为一的回文串），接下来我们要考虑三种情况。

第一种，长度为二的字符串，当其长度只有二且两个字符全等时，很明显最长的长度为二。

第二种，当首尾相同时，其最长长度就是去除首尾的字符串中最长回文串的长度加上首尾（后面我试了下，第一种情况实际上与第二种情况相同，所以代码中就没有第一种情况了，留着第一种是为了方便思考）。

第三种，就是头尾不等，答案即为长度为 $len - 1$ 且首或尾与当前子串相同的字符串的最长回文字串的长度（其实就是上一个最优解）。
# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int long long
#define O2 ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
int dp[1001][1001];
signed main(){
    O2;
    int n;
	cin>>n;
    string s;
	cin>>s;
    for(int i=0;i<n;++i)dp[i][i]=1;
    for(int len=2;len<=n;len++){
        for(int i=0;i<=n-len;i++){
            int j=i+len-1;
            if(s[i]==s[j])dp[i][j]=dp[i+1][j-1]+2;
            else dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
        }
    }
    cout<<dp[0][n-1]<<endl;
    return 0;
}    
```

---

## 作者：Yi_chen123 (赞：1)

## 思路

先看标签：动态规划。\
既然是动态规划，肯定少不了它的三要素！

### 状态

定义二维动态规划数组 `dp[LEN][LEN]`，其中，`dp[i][j]` 表示从 $s_i$ 到 $s_j$ 的最长回文子串的长度。

### 边界

根据 `dp` 数组的性质，很显然 `dp[i][i] = 1`，因为 $s_i$ 到 $s_i$ 的长度为 $1$，并且绝对回文。

### 转移

终于到最重要的环节了！\
首先，我们要知道，如果有一个回文串，那么将这个回文串的头尾分别加上一个相同的字符，那么新的字符串必定回文。这一点显而易见。\
那么我们可以继续推广：若一个字符串的最长回文子串长度为 $k$，那么头尾加上一个相同的字符，新字符串的最长回文子串长度肯定为 $k+2$。\
那么，当 $s_i = s_j$ 时，$dp_{i,j} = dp_{i+1,j-1} + 2$，因为根据上述规则，最长的回文子串可以向两边分别扩展一个字符的长度。\
如果 $s_i \ne s_j$，我们就取左边一个字符或者右边一个字符较大的一个值。\
故动态转移方程如下：

$$
dp_{i,j} = \begin{cases}
dp_{i+1, j-1} + 2, & s_i = s_j \\
\max(dp_{i+1,j}, dp_{i, j - 1}), & s_i \ne s_j \\
\end{cases}
$$

显然，$dp_{0,len-1}$ 为最终答案的保存地点。\
考虑正向遍历 $j$，反向遍历 $i$，保证 $dp_{i+1, j-1},dp_{i+1,j}, dp_{i, j - 1}$ 三个子任务均已解决。\
时间复杂度与空间复杂度均为 $O(n^2)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1010][1010]; 
int main() {
	int n; cin >> n;
	string s; cin >> s;
	for(int i = n - 1; i >= 0; --i){
        dp[i][i] = 1;
        for(int j = i + 1; j < n; ++j){
            if(s[i] == s[j])
                dp[i][j] = dp[i + 1][j - 1] + 2;
            else
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }
	cout << dp[0][n - 1]; 
	return 0;
}

```

---

## 作者：guoshengyu1231 (赞：1)

# 题目大意
给定一个字符串 $S$，求这个字符串的**最长回文子序列**。
# 思路
首先考虑动态规划。
既然是动态规划，那三要素可不能少。
## 状态
首先这题肯定是区间 dp，我们不妨定义 $dp_{l,r}$ 表示区间 $[l,r]$ 的最长回文子序列的长度。
## 边界
很明显，当区间只有一个字符时，那他的最长回文子序列长度必然为 $1$。
## 转移
终于到了最难的一步，这里我们需要了解回文串的一个性质，那就是一个回文串头尾两边个加入一个相同的字符，所得的字符串仍然使回文串。这一点应该使显而易见的。 $\\$

明白了这一点，接下来我们应该去思考如何去利用这一点来解决问题。$\\$ 

假设我们现在求解到了区间 $[l,r]$，如果此时 $s_l=s_r$，那我们可以让区间 $[l+1,r-1]$ 内的最长回文子序列在头尾各插入 $s_l$ 和 $s_r$，所得的序列依然是一个回文序列，这样我们可以得到转移方程如下：
 $$dp_{l,r}=dp_{l+1,r-1}+2$$
接下来我们考虑 $s_i\ne s_j$ 的情况，很显然，这种情况下，要么舍弃 $s_l$，要么舍弃 $s_r$。可得状态转移方程如下：
 $$dp_{l,r}=\max(dp_{l,r-1},dp_{l+1,r})$$
最后归纳总结一下即可。 $\\$ 
很明显答案就在 $dp_{1,n}$ 里。 
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
int n,dp[maxn][maxn];
char a[maxn];
int main()
{
	cin>>n;scanf("%s",a+1);
	for(int i=1;i<=n;i++) dp[i][i]=1;//边界（初始化）
	for(int len=2;len<=n;len++)//因为子问题的长度都是小于大问题的，所以从小到大枚举长度
	 for(int i=1;i+len-1<=n;i++)//同题解中的l
	  {
	  	int j=i+len-1;//同题解中的r
	  	if(a[i]==a[j]) dp[i][j]=dp[i+1][j-1]+2;//情况1
	  			  else dp[i][j]=max(dp[i+1][j],dp[i][j-1]);//情况2
	  }
	cout<<dp[1][n];
	return 0;
} 
```

---

## 作者：xw_qwq (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4336)
### 题目思路

很模板很模板的区间 dp。

设 $s$ 为题中所给字符串，$dp_{i,j}$ 为字符串第 $i$ 个字符到第 $j$ 个字符的最长回文串长度。

则当 $s_i = s_j$ 时，$dp_{i,j}$ 就为 $dp_{i+1,j-1}+2$，因为两侧字符相等，可以直接添加进前字符串。

否则 $dp_{i,j}$ 即为 $\max (dp_{i+1,j},dp_{i,j-1})$，也就是在给出的范围内找到最大的可能。

初始化 $dp_{i,i}$ 为 $1$，因为单个字符也是回文串。

有了这些思路，dp 就很好写了，套个模板即可，不会的请先学习 [P1775](https://www.luogu.com.cn/problem/P1775)。

最后答案是整个字符串的回文子串长度最大值，即为 $dp_{1,n}$。

时间复杂度：$O(n^2)$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[1005][1005];
int main()
{
	int n;
	string s;
	cin >> n >> s;
	s = ' ' + s;
	for (int i = 1; i <= n; i++)
		dp[i][i] = 1;
	for (int len = 2; len <= n; len++)
		for (int l = 1; l <= n - len + 1; l++)
		{
			int r = len + l - 1;
			if (s[l] == s[r])
				dp[l][r] = dp[l + 1][r - 1] + 2;
			else
				dp[l][r] = max(dp[l + 1][r], dp[l][r - 1]);
		}
	cout << dp[1][n];
	return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4336)
### 思路
发现 $O(n^2)$ 能做，对区间 DP 是很友好的。  
然后就是模板题了~~  
令 $f_{i,j}$ 表示区间 $(i,j)$ 中最大的回文子序列长度。  
从短到长遍历每一个 $(i,j)$ 区间，每一个 $f_{i,j}$ 有两种取法：
1. 当 $S_i = S_j$ 时，$f_{i,j} = f_{{i+1},{j-1}} + 2$。
2. 当 $S_i \neq S_j$ 时，$f_{i,j} = \max (f_{i,{j-1}},f_{{i+1},j})$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,k,f[1001][1001];
string s;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>s;
	for(i=1;i<=n;i++) f[i][i]=1;//初始化
	for(k=2;k<=n;k++)  //区间 DP
		for(i=0;i<n-k+1;i++){
			j=i+k-1;
			if(s[i]==s[j]) f[i][j]=f[i+1][j-1]+2;
			else f[i][j]=max(f[i][j-1],f[i+1][j]);
		}
	cout<<f[0][n-1]; //输出答案
} 
```

---

## 作者：_you_know_who_ (赞：0)

## 题意
给定一个字符串，求这个字符串最大的回文子序列长度。
## 思路
其实就是区间 dp 的模板。

首先， $f_{i,j}$ 表示区间 $(i,j)$ 最大的回文子序列长度。

从小到大遍历每个长度的区间 $(i,j)$ ，容易得出：
- $s_i=s_j$，$f_{i,j}=f_{i+1,j-1}+2$
- $s_i \ne s_j$，$f_{i,j}=\max(f_{i+1,j},f_{i,j-1})$

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1001][1001];
int main()
{
    int len;
    cin>>len;
    string s;
    cin>>s;
    for(int i=0;i<len;i++)
    {
        f[i][i]=1;//初始化
    }
    for(int cd=2;cd<=len;cd++)//遍历长度
        for(int i=0;i<len-cd+1;i++)
        {
            int j=i+cd-1;
            if(s[i]==s[j])
            {
                f[i][j]=f[i+1][j-1]+2;
            }
            else
            {
                f[i][j]=max(f[i][j-1],f[i+1][j]);
            }
        }
    cout<<f[0][len-1]<<endl;
    return 0;//完结撒花
}
```

---

## 作者：chang_bd (赞：0)

# 思路构建

很容易想到用 $dp_{i,j}$ 代表从第 $i$ 到 $j$ 个字符子序列是回文串的最长长度。如果 $s_i=s_j$，则 $dp_{i,j}=dp_{i+1,j-1}+2$，否则 $dp_{i,j}=\max(dp_{i+1,j},dp_{i,j-1})$。

# 代码实现


```cpp
#include<bits/stdc++.h>
using namespace std;
int len,dp[1005][1005];string s;
int solve(int x,int y){
	if(x>y){
		return 0;
	}
	if(x==y){
		return dp[x][y]=1;
	}
	if(s[x-1]==s[y-1]){
		int an=solve(x+1,y-1);
		return dp[x][y]=an+2;
	}else{
		return dp[x][y]=max(solve(x+1,y),solve(x,y-1));
	}
}
int main(){
    cin>>len>>s;
    memset(dp,-1,sizeof(dp));
    cout<<solve(1,len);
    return 0;
}
```

~~码风请勿吐槽~~

---


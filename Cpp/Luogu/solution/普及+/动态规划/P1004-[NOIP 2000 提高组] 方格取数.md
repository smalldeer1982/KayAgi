# [NOIP 2000 提高组] 方格取数

## 题目背景

NOIP 2000 提高组 T4

## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。


## 说明/提示

数据范围：$1\le N\le 9$。

## 样例 #1

### 输入

```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
```

### 输出

```
67```

# 题解

## 作者：wzxx (赞：400)

###深搜深搜

见都是动规的帖子，来来来，贴一个深搜的题解（手动滑稽）。。。

这道题深搜的最优方法就是两种方案同时从起点出发。因为如果记录完第一种方案，再计算第二种方案，不可控的因素太多了，大多都不是最优解→\_→，但两种方案同时执行就行，因为这可以根据当前的情况来判断最优。

总的来说，每走一步都会有四个分支（你理解成选择或者情况也可以）：

1、两种都向下走

2、第一种向下走，第二种向右走

3、第一种向右走，第二种向下走

4、两种都向右走

每走一步走枚举一下这四种情况，因为在每个点的方案具有唯一性（也就是在某个点走到终点的取数方案只有一个最优解，自己理解一下），所以我们可以开一个数组来记录每一种情况，当重复枚举到一种情况时就直接返回（对，就是剪枝），大大节省了时间（不然会超时哦~）。深搜和动归的时间复杂度时一样的！

附代码：

```cpp
//方格取数~深搜  ～(￣▽￣～)(～￣▽￣)～
#include<iostream>
    using namespace std;
    int N=0;
    int s[15][15],f[11][11][11][11];
int dfs(int x,int y,int x2,int y2)//两种方案同时执行，表示当第一种方案走到x,y,第二种方案走到x2,y2时到终点取得的最大数 
{
    if (f[x][y][x2][y2]!=-1) return f[x][y][x2][y2];//如果这种情况已经被记录过了，直接返回，节省时间 
    if (x==N&&y==N&&x2==N&&y2==N) return 0;//如果两种方案都走到了终点，返回结束 
    int M=0;
    //如果两种方案都不在最后一列，就都往下走，统计取得的数，如果有重复，就减去一部分 
    if (x<N&&x2<N) M=max(M,dfs(x+1,y,x2+1,y2)+s[x+1][y]+s[x2+1][y2]-s[x+1][y]*(x+1==x2+1&&y==y2));
    //如果第一种方案不在最后一行，第二种方案不在最后一列，第一种就向下走，第二种就向右走， 
    //统计取得的数，如果有重复，就减去一部分
    if (x<N&&y2<N) M=max(M,dfs(x+1,y,x2,y2+1)+s[x+1][y]+s[x2][y2+1]-s[x+1][y]*(x+1==x2&&y==y2+1));
    //如果第一种方案不在最后一列，第二种方案不在最后一行，第一种就向右走，第二种就向下走， 
    //统计取得的数，如果有重复，就减去一部分
    if (y<N&&x2<N) M=max(M,dfs(x,y+1,x2+1,y2)+s[x][y+1]+s[x2+1][y2]-s[x][y+1]*(x==x2+1&&y+1==y2));
    //如果第一种方案和第二种方案都不在最后一列，就都向右走，统计取得的数，如果有重复，就减去一部分
    if (y<N&&y2<N) M=max(M,dfs(x,y+1,x2,y2+1)+s[x][y+1]+s[x2][y2+1]-s[x][y+1]*(x==x2&&y+1==y2+1));
    //对最后那个 s[x][y+1]*(x==x2&&y+1==y2+1))的解释：这个是用来判断两种方案是不是走到了同一格的
    //如果是真，就返回1，否则返回0，如果是1的话，理所当然的可以减去s[x][y+1]*1,否则减去s[x][y+1]*0相当于
    //不减,写得有点精简，省了4个if，见谅哈~ 
    f[x][y][x2][y2]=M;//记录这种情况 
    return M;//返回最大值 
}
int main()
{
    cin>>N;
    //将记录数组初始化成-1，因为可能出现取的数为0的情况，如果直接判断f[x][y][x2][y2]!=0（见dfs第一行）
    //可能出现死循环而导致超时，细节问题 
    for(int a=0;a<=N;a++)
      for(int b=0;b<=N;b++)
        for(int c=0;c<=N;c++)
          for(int d=0;d<=N;d++) f[a][b][c][d]=-1;
    for(;;)//读入 
    {
        int t1=0,t2=0,t3=0;
        cin>>t1>>t2>>t3;
        if(t1==0&&t2==0&&t3==0) break;
        s[t1][t2]=t3;
    }
    cout<<dfs(1,1,1,1)+s[1][1];//输出，因为dfs中没有考虑第一格，即s[1][1]，所以最后要加一下 
    return 0;
}
```

---

## 作者：road (赞：182)

## 一道四维dp题，虽然二维也能骗点分……
### 先说二维dp的思路：
二维的思路偏向贪心，即定义dp[ i ][ j ]为走到点[ i , j ]时的最佳选项，此时保证第一遍走的时候为最佳答案，第二遍走时为去掉第一遍走过的点时的最佳答案，保证两遍都是分别的最佳答案但非整体的最佳答案……，未懂的同学可以向下看，“特殊”情况：
| 0 | 0 | 2 | 3 | 0 | 0 | 0 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 3 | 0 | 0 | 0 | 0 |
| 0 | 0 | 3 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 4 | 0 | 0 |
| 0 | 0 | 0 | 0 | 4 | 0 | 0 |
| 0 | 0 | 0 | 0 | 4 | 0 | 0 |
如图，走第一遍可得出终点时最大值为20，去掉已经走过的点后图如下：
| 0 | 0 | 0 | 3 | 0 | 0 | 0 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 2 | 0 | 0 | 0 | 0 |
然后会发现我们无法全部走完，也正符合贪心策略，“只注重眼前的利益”，因此此题使用二维dp绝非正解，上代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int N=11;
int dp1[N][N],dp2[N][N],n,o;
struct point
{
	int x;
	int y;
	int num;
}poi[N*N];
void find(int k,int l)//判断第一遍走过哪些点 
{
	if(k==0&&l==0)
	{
		return;
	}
	else
	{
		if(dp1[k][l]-dp2[k][l]==dp1[k-1][l])
	    {  
		    dp2[k][l]=0;
		    find(k-1,l); 
	    }
	    else if(dp1[k][l]-dp2[k][l]==dp1[k][l-1])
	    {
		    dp2[k][l]=0;
		    find(k,l-1);
	    }
	}
}
int main()
{
	scanf("%d",&n);
	for(;;)
	{
		o++;
		scanf("%d%d%d",&poi[o].x,&poi[o].y,&poi[o].num);
		if(poi[o].x==poi[o].y&&poi[o].y==poi[o].num&&poi[o].num==0)
		{
			break;
		}
		else
		{
			dp1[poi[o].x][poi[o].y]=poi[o].num;
			dp2[poi[o].x][poi[o].y]=poi[o].num;
		}
	}
	for(int i=1;i<=n;i++)//第一遍的最优解 
	{
		for(int j=1;j<=n;j++)
		{
			dp1[i][j]+=max(dp1[i-1][j],dp1[i][j-1]);
		}
	}
	find(n,n);
	for(int i=1;i<=n;i++)//第二遍的最优解 
	{
		for(int j=1;j<=n;j++)
		{
			dp2[i][j]+=max(dp2[i-1][j],dp2[i][j-1]);
		}
	}
	printf("%d",dp1[n][n]+dp2[n][n]);//输出答案 
	return 0;
}
```
既然我们可以用dp表示每遍的最优解，那么我们可不可以用dp直接求出整体的最优解呢？当然是可以的：

我们使用dp[ i ][ j ][ k ][ l ]表示第一遍走到点[ i , j ],第二遍走到点[ k , l ]的最优解，代码如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int N=11;
int dp[N][N][N][N];
int a[N][N];
int n,x,y,z;
int main()
{
	scanf("%d",&n);
	for(;;)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(x==y&&y==z&&z==0)
		{
			break;
		}
		else
		{
			a[x][y]=z;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)
			{
				for(int l=1;l<=n;l++)
				{
					dp[i][j][k][l]=max(max(dp[i-1][j][k-1][l],dp[i-1][j][k][l-1]),max(dp[i][j-1][k-1][l],dp[i][j-1][k][l-1]))+a[i][j]+a[k][l];
					if(i==k&&l==j)dp[i][j][k][l]-=a[i][j];//注意判断这个点走过几次并处理 
				}
			}
		}
	}
	printf("%d",dp[n][n][n][n]);
	return 0;
}
```
文章较长，有用就好。。。

---

## 作者：Azuree (赞：102)

一道典型的棋盘dp。  
一共需要走两次，我们不妨同时处理这两条路径。这样，我们既可以方便地处理两条路径重合的情况，也可以减少代码的时间复杂度。  
最朴素的想法是开一个四维数组$f[x_1][y_1][x_2][y_2]$表示当两条路径分别处理到$(x_1,y_1)$和$(x_2,y_2)$时能够获得的最大的累积和。但是，四维数组处理起来时间复杂度太大了，所以我们要想办法把它降成三维。  
我们可以发现，每当我们走一步，那么x坐标和y坐标之间总会有一个数加$1$。所以，我们可以用k来表示x坐标和y坐标的和，从而通过y坐标来计算出x坐标。由于k对于两条同时处理的路径可以是公共的，所以我们可以用$f[k][y_1][y_2]$来表示当前状态。  
特殊的，由于每一个方格的数只可以取一次，所以我们要判断i和j是否相当。  
于是，我们就可以得到一个状态转移方程了：  
$$f[k][i][j]=max(f[k-1][i][j],f[k-1][i-1][j]f[k-1][i][j-1]f[k-1][i-1][j-1])+[(i==j)?map[k-i+1][i]:map[k-i+1][i] + map[k-j+1][j]]$$  
我们可以来看一下我们到底是通过哪些状态转移到当前状态的：  
![](https://cdn.luogu.com.cn/upload/pic/71682.png)  
code:  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register
#define qwq printf("qwq\n");

using namespace std;

int read()
{
	register int x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,m,map[205][205],f[205][205][205],x,y,v;

int cmp(int a,int b,int c,int d)
{
	a = max(a,b);
	c = max(c,d);
	return max(a,c);
}

int main()
{
	m = read();
	n = m;
	x = read(); y = read(); v = read();
	while(x > 0)
	{
		map[x][y] = v;
		x = read(); y = read(); v = read();
	}
	for(int k = 1; k <= m + n; k++)
		for(int i = 1; i <= min(k,n); i++)
			for(int j = 1; j <= min(k,n); j++)
			{
				f[k][i][j] = cmp(f[k - 1][i][j],f[k - 1][i - 1][j],f[k - 1][i][j - 1],f[k - 1][i - 1][j - 1]) + map[k - i + 1][i] + map[k - j + 1][j];
				if(i == j) f[k][i][j] -= map[k - i + 1][i];
			}
				
	f[n + m][n][n] = cmp(f[n + m - 1][n][n - 1],f[n + m - 1][n - 1][n],f[n + m - 1][n][n],f[n + m - 1][n - 1][n - 1]);
	printf("%d\n",f[n + m][n][n]);
    return 0;
}
```

---

## 作者：tylon2006 (赞：81)

emmm...我太蒻了

连四维dp都不会写，只会网络流的蒟蒻

感觉这题像[P4066 [SHOI2003]吃豆豆](https://www.luogu.org/problemnew/show/P4066)（~~不要在意那是道黑题~~）

设两个起点，总起点向副起点连一条容量为二，费用为零的边（只走两次）

用结构体存储每个费用不为零的点的信息（id是第几个被输入）

每个费用不为零的点又分为入点和出点，入出点之间连一条容量为一，费用为当前点权值的边（取走这个点的值），再连一条容量为二，费用为零的边（不取走这个点的值）

副起点向每个费用不为零的入点连一条容量为inf，费用为零的边

每个费用不为零的点的出点向终点连一条容量为inf，费用为零的边

每个费用不为零的点的出点只需要连与当前点最“近”的点的入点（需要排序）

详细说明请见下文：

下面来自wjyyy大神题解

 对于坐标系中一个点，它可以由横坐标非严格小于它，且纵坐标非严格小于它的点（在可行域中）转移。我们为了控制边数，只用连接与它最近的点。我们在可行域中首先找到横坐标最大（同等条件下纵坐标最大）的点，接着屏蔽掉以原点与这个点的连线为对角线的矩形，因为矩形中的点都可以或直接或间接地转移到这个右上角点来：
 
 ![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ%E6%88%AA%E5%9B%BE20180706183659.png)
 
我们依次这样做下去，就会得到这两个蓝色点和红色点，从蓝点指向红点是一条边权为∞，费用为0的承接边。
    
 ![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ%E6%88%AA%E5%9B%BE20180706183941.png)
 ![](http://www.wjyyy.top/wp-content/uploads/2018/07/QQ%E6%88%AA%E5%9B%BE20180706183903.png)
 
不过，在某些情况下，下面剩的两个黑点直接走到红点是更优的解，这样我们只需要把之前拆的点之间重新建一条边，边权为∞，费用为0的承接边，表示不经过这个点的两点连线通过这个点连接到一起，与这个点无关。这样一来，与上面的拆点一起，每个点有了两条自环边，实则分成了两个点，它们之间有两条连线，一条是承接边，一条是费用边，即对费用增加有贡献的边。
 
最后跑最大费用最大流即可

附上蒟蒻代码

```cpp
#include<bits/stdc++.h>
#define maxn 200000
#define inf INT_MAX
using namespace std;
struct edge{
	int x,y,f,v,next;
}e[maxn*10];
bool vis[maxn];
int n,m=1,cnt=0,mc=0;
int head[maxn],pre[maxn],sum[maxn];
inline void add(int a,int b,int c,int d){
	e[cnt].x=a; 
	e[cnt].y=b;
	e[cnt].f=c;
	e[cnt].v=d;
	e[cnt].next=head[a];
	head[a]=cnt++;
}
inline void ad(int a,int b,int c,int d){
	add(a,b,c,d);
	add(b,a,0,-d);
}
void init() {
    cnt=0;memset(head,-1,sizeof(head));
}
bool spfa(int s,int t){
	queue<int>q;
	for(int i=0;i<=t+1;i++){
		sum[i]=-inf;
		pre[i]=-1;
		vis[i]=0;
	}
	sum[s]=0;
	vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop(); vis[x]=0;
		for(int i=head[x];i!=-1;i=e[i].next){
			int y=e[i].y;
			int f=e[i].f;
			int v=e[i].v;
			if(f>0&&sum[y]<sum[x]+v){
				pre[y]=i;
				sum[y]=sum[x]+v;
				if(!vis[y]){
					vis[y]=1;
					q.push(y);
				}
			}
		}
	}
	return sum[t]>0;
}
void ek(int s,int t){
	mc=0;
	while(spfa(s,t)){
		int minn=inf;
		for(int i=pre[t];i!=-1;i=pre[e[i].x])
		minn=min(minn,e[i].f);
		mc+=sum[t]*minn;
		for(int i=pre[t];i!=-1;i=pre[e[i].x]){
			e[i].f-=minn;
			e[i^1].f+=minn;
		}
	}
	printf("%d",mc);
}
struct data{
	int x,y,z,id;
}bean[2005];
bool cmp(data a,data b){
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}
int main()
{
	init();
	scanf("%d",&n);
	int s=0,t,ss;
	while(scanf("%d%d%d",&bean[m].x,&bean[m].y,&bean[m].z)){
		if(bean[m].x==0&&bean[m].y==0&&bean[m].z==0) break;
		bean[m].id=m; 
		m++;
	}
	m--;
	t=m*2+1;
	ss=t+1;
	ad(s,ss,2,0);
	for(int i=1;i<=m;i++){
		ad(ss,i,inf,0);
		ad(i+m,t,inf,0);
		ad(i,i+m,1,bean[i].z);
		ad(i,i+m,2,0); 
	}
	sort(bean+1,bean+m+1,cmp);
	for(int i=1;i<m;i++){
		int minn=inf;
		for(int j=i+1;j<=m;j++)
		if(bean[j].y>=bean[i].y&&bean[j].y<minn){
			minn=bean[j].y;
			ad(m+bean[i].id,bean[j].id,inf,0);
		}
	}
	ek(s,t);
}
```

QAQ求过审

---

## 作者：Vistarin (赞：30)

### 这题其实有一种非常简单的方法，但是似乎没有多少人写qwq。

### 对，它就是DFS！


------------

我用DFS成功20msAC，没有加记忆化，并没有比正解DP慢多少。

事实上，程序时间复杂度很吓人。但由于数据过水，运行起来没有问题。（所以这题难度最多普及/提高-）

------------

下面先说基本思路。

两条路径，实际上可以看成从$A$到$B$，再从$B$回来。

然后我们把取走的数都标为$0$以防止重复，像这样搜索，就可以得到正解了。

——我当时是这么想的。于是直接爆搜打上去。


------------

#### "#2 TLE 1.20s"

#### Too Young Too Simple。qaq

------------

那么如何剪枝呢？

我们设从$A$搜到$B$为第一阶段，从B搜到A为第二阶段。

首先发现，取第一阶段的最大值，接着再取第二阶段的最大值。是可以得到最优解的。

于是，便可以使用**最优性剪枝**了：保存当前从A搜到B（即第一条路径）的最大值MAX，之后从A搜到B取得的值若小于MAX，那么直接剪掉；如果大于MAX，那么更新MAX即可。

下面给出代码实现。

------------

```
#include<iostream>
using namespace std;

const int dx[]={0, 1, 0, -1},
		  dy[]={1, 0, -1, 0};

int map[10][10], n, ans, tmp; //ans为最终结果，tmp为第一阶段最大值

inline void search(int x, int y, int z, int f) //x、y为当前坐标
{											   //z为当前取到的值，f表示当前处在第几阶段
	if (x<1 || y<1 || x>n || y>n) return; //边界
	
	if (x==n && y==n) //第一阶段终止条件
	{
		f=1; //标记
		z-=map[n][n]; //为了防止在(n, n)重复计算
		
		if (z>tmp) //更新&&剪枝
			tmp=max(tmp, z);
		else
			return;
	}
		
	if (x==1 && y==1 && f==1) //第二阶段终止条件
		ans=max(ans, z);
	
	if (!f) //第一阶段进程
	{
		for (int i=0; i<2; i++)
		{
			int nx=x+dx[i], ny=y+dy[i], t=map[nx][ny];
			
			map[nx][ny]=0;
			search(nx, ny, z+t, f);
			map[nx][ny]=t;
		}
	}
	else //第二阶段进程
	{
		for (int i=2; i<4; i++)
		{
			int nx=x+dx[i], ny=y+dy[i], t=map[nx][ny];
			
			map[nx][ny]=0;
			search(nx, ny, z+t, f);
			map[nx][ny]=t;
		}
	}
}

int main()
{
	cin>>n;
	
	for (;;)//输入
	{
		int x, y, z;
		cin>>x>>y>>z;
		
		if (x==0 && y==0 && z==0)
			break;
		
		map[x][y]=z;
	}
	
	search(1, 1, 0, 0); //最初的位置是(1, 1)，取到的值为0，处于第一阶段
	
	cout<<ans;
	return 0;
}
```

------------


看起来十分zz吧？

然而为什么会有这样的效果呢？

显然在$n\times n$的图中，第一阶段和第二阶段的解答树为大小相等的满二叉树，因此其叶子节点数为$2^{2(n-1)}$。由于边界问题，实际有效的节点为${\frac{2^{2(n-1)}}2}=4^{(n-2)}$。

设$t=n-2$，之后我们发现，在未剪枝时，第一阶段解答树的叶子节点数就是第二阶段的运行次数。单独提出第二阶段，则构成包含$4^t$个解答树的森林。

那么总复杂度为$O(4^t+4^t\times4^t)=O(16^t)$，显然不可能过。

然而剪枝过后，第二阶段只运行一次，总复杂度为$O(2\times4^t)=O(4^t)$，结合$t=n-2$，可知在本题允许范围内。

（刚刚发现有一处打错 感谢管理员qwq）

---

## 作者：chrispang (赞：17)

一道有点难度的 `DP` 题......

### 题目大意

有一个 $ n \times n $ 的方格图，每个格子都有一个对应的权值 $ a_{i,j} $，你从 $(1, 1)$ 开始走，每次可以从 $(i, j)$ 走到 $(i + 1, j)$ 或 $(i, j + 1)$，最终走到 $(n, n)$，你需要这样走两次，求你所经过的格子上的权值之和的最大值，每个格子上的权值只计算一次。

### 题目分析

1. 状态：定义一个四维数组 $f$，$f_{i\ j\ k\ l}$ 表示第一次走到第 $i$ 行，第 $j$ 列，第二次到达第 $k$ 行，第 $l$ 列能获得的最大值。

2. 状态转移方程：我们要考虑以下四种情况：

- 第一次从左边过来，第二次从左边过来

- 第一次从左边过来，第二次从上边过来

- 第一次从上边过来，第二次从左边过来

- 第一次从上边过来，第二次从上边过来

那么我们就要取这四种情况的最大值了，即：$f_{i\ j\ k\ l} = \max\{f_{i-1\ j\ k-1\ l}, f_{i-1\ j\ k\ l-1}, f_{i\ j-1\ k-1\ l}, f_{i\ j-1\ k\ l-1}\}+a_{i\ j}+a_{k\ l}$。

但要注意的是，如果 $(i, j)=(k,l)$，那么就只能加其中一个（不能重复），所以此时要在原来的基础上减去一个 $a_{i\ j}$。

3. 初始化：刚开始也就是到点 $(1, 1)$ 能获得的最大值，即 $f_{1\ 1\ 1\ 1} = 0$。

4. 答案：由于我们要求第一次和第二次走到右下角的最大值，所以我们的答案为 $f_{n\ n\ n\ n}$。

上代码：

```cpp
#include <bits/stdc++.h> 
using namespace std;

int n, x, y, w, a[35][35], f[35][35][35][35]; //表示第一次走到第i行，第j列，第二次到达第k行，第l列能获得的最大值。
int main() {
	cin >> n;
	while(cin >> x >> y >> w) { //输入 
		if(x == 0 && y == 0 && w == 0) break; //退出 
		a[x][y] = w;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			for (int k = 1; k <= n; k++)
				for (int l = 1; l <= n; l++) {
					int t1 = max(f[i - 1][j][k - 1][l], f[i - 1][j][k][l - 1]); //记录 
					int t2 = max(f[i][j - 1][k - 1][l], f[i][j - 1][k][l - 1]); //记录 
					f[i][j][k][l] = max(t1, t2) + a[i][j] + a[k][l]; //求最大值 
					if(i == k && j == l) f[i][j][k][l] -= a[i][j]; //如果位置相同，则减去其中一个 
				}
	cout << f[n][n][n][n] << endl; //答案 
	return 0;
}
```

最后，看在本蒟蒻这么努力的份上，请点个赞吧！球球啦！

---

## 作者：如履薄冰 (赞：12)

# 解法
考虑使用**三维动态规划**，使用最基础的动态规划跑两遍明显过不了。首先我们要解决一个问题：如何避免一个格子被拿两遍？我们可以**同时**遍历两个路径。我们设第一条路径目前的横坐标为 $i$，纵坐标为 $j$。再设第二条路径目前的横坐标为 $k$，纵坐标为 $l$。不难发现 $i+j$ 一定等于 $k+l$。因为他们的坐标总和只能在每一步中加一，而这两个坐标又是同时移动的。这样就需要四个维度。我们可以进行降维优化。接下来我要重新定义一些上文定义过的变量，请勿参考上文的变量来理解下文的变量。我们可以设 $i$ 为我们现在总共走的步数，设 $j$ 为第一条路径目前的横坐标，再设 $k$ 为第二条路径目前的横坐标。我们可以设一个三维数组 $dp$ 用来存储相应的状态，进行状态转移。状态转移方程十分好推，这里就不给出了，如果真的不知道状态转移方程是什么，就去看我的代码，我的代码中间有个三重循环，这个三重循环里面就是状态转移方程的实现部分。最终答案为 $dp_{n \times 2,n,n}$。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,dp[110][110][110],mp[1100][1100];
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	while(true){
		int x,y,num;
		cin>>x>>y>>num;
		if(x==0&&y==0&&num==0){
			break;
		}else{
			mp[x][y]=num;
		}
	}
	for(int i=2;i<=n*2;i++){
		for(int j=max(i-n,1ll);j<=min(n,i-1);j++){
			for(int k=max(i-n,1ll);k<=min(n,i-1);k++){
				dp[i][j][k]=max(max(max(dp[i-1][j][k],dp[i-1][j-1][k-1]),dp[i-1][j][k-1]),dp[i-1][j-1][k]);
				dp[i][j][k]+=mp[j][i-j];
				if(j!=k){
					dp[i][j][k]+=mp[k][i-k];
				}
			}
		}
	}
	cout<<dp[n*2][n][n];
	return 0;
}
```

---

## 作者：Vct14 (赞：7)

经典动态规划题目，本篇题解使用的是三维 dp。

由于要走两遍，所以我们直接处理两条路径。设 $dp_{i_1,j_1,i_2,j_2}$ 表示走了 $i_1+j_1$ 步，第一条路径走到 $(i_1,j_1)$，第二条路径走到 $(i_2,j_2)$ 的最大取数之和。显然有 $i_1+j_1=i_2+j_2$，因此 $j_2$ 一维可以压掉。

如果两条路径走到同一格，那么当前格子只能加一次。有状态转移方程 $dp_{i_1,j_1,i_2}=\begin{cases}sc_{i_1,j_1}+\max(dp_{i_1,j_1-1,i_2-1},dp_{i_1-1,j_1,i_2}) & i_1=i_2\\sc_{i_1,j_1}+sc_{i_2,i_1+j_1-i_2}+\max(dp_{i_1-1,j_1,i_2-1},dp_{i_1-1,j_1,i_2},dp_{i_1,j_1-1,i_2-1},dp_{i_1,j_1-1,i_2}) & i_1\ne i_2\end{cases}$。

其中 $sc_{i,j}$ 表示 $(i,j)$ 格上的数。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=12;
int sc[N][N];
int dp[N][N][N]; 

int main(){
	int n;cin>>n;int x,y,z;
	while(cin>>x>>y>>z){
		if(!(x || y || z)) break;
		sc[x][y]=z;
	}
	for(int i1=1; i1<=n; i1++){
		for(int j1=1; j1<=n; j1++){
			for(int i2=1; i2<=i1+j1-1; i2++){
				if(i1==i2) dp[i1][j1][i2]=sc[i1][j1]+max(dp[i1][j1-1][i2-1],dp[i1-1][j1][i2]);
				else dp[i1][j1][i2]=sc[i1][j1]+sc[i2][i1+j1-i2]+max({dp[i1-1][j1][i2-1],dp[i1-1][j1][i2],dp[i1][j1-1][i2-1],dp[i1][j1-1][i2]});
//				cout<<i1<<" "<<j1<<" "<<i2<<" "<<dp[i1][j1][i2]<<"\n";
			}
//			cout<<"\n";
		}
	}
	cout<<dp[n][n][n];
	return 0;
}
```

因为两条路径长度相同，所以第二条路径一定不会走到第一条路径曾经过的点。所以是否将第一条路径上经过的点上的数赋零对答案无影响。

---

## 作者：TainityAnle (赞：5)

### 题意

有一个 $n\times n$ 的网格，网格有的位置有数。一个人要从左上角走到右下角，每一步只能向下或向右走。他要两次从左上角走到右下角，重复的点权值只算一次，要使两次路径上的数字之和最大，求出这个最大值。

### 思路

典型动态规划题。

如果设 $f_{i,j}$ 为走到点 $(i,j)$ 的最大值，先跑第一次，记录经过的点，把这些点赋成 $0$，再跑第二遍。这样显然是错误的，提供一个反例（数据点 #3）：

![](https://cdn.luogu.com.cn/upload/image_hosting/4gbchj28.png)

第一遍会先跑 $(1,3)\rarr(2,3)\rarr(3,3)\rarr(5,5)\rarr(6,5)\rarr(7,5)$，第二遍只能取到一个 $3$。

但最佳方案是第一遍跑 $(1,3)\rarr(1,4)\rarr(5,5)\rarr(6,5)\rarr(7,5)$，第二遍跑 $(2,3)\rarr(3,3)\rarr(7,3)$。

然后观察数据范围非常小，$1\le n\le9$。所以可以设计一个四维 DP。

设 $f_{i,j,x,y}$ 表示第一次走到 $(i,j)$，第二次走到 $(x,y)$ 的最大值。

考虑一个点能从哪些点走过来：第一次走可能是从左边或上边走过来的，第二次走也可能，共有 $4$ 种情况。假设不取当前点的状态值为：

$f_{i,j,x,y}=\max(f_{i-1,j,x-1,y},f_{i-1,j,x,y-1},f_{i,j-1,x-1,y},f_{i,j-1,x,y-1})$。

然后加上当前点，如果两次路线走到了同一个点，即 $i=x$ 且 $j=y$ 的情况，就只加一次，否则就加上 $a_{i,j}+a_{x,y}$。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int A,B,C,n,cnt,t[15][15],f[15][15][15][15],a[100],b[100],c[100];
int main() {
	cin>>n;
	while(cin>>A>>B>>C&&A&&B&&C) a[++cnt]=A,b[cnt]=B,c[cnt]=C;
	for(int i=1; i<=cnt; i++) t[a[i]][b[i]]=c[i];
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++)
				for(int l=1; l<=n; l++) {
					f[i][j][k][l]=max(f[i-1][j][k-1][l],max(f[i-1][j][k][l-1],max(f[i][j-1][k-1][l],f[i][j-1][k][l-1])));
					if(i==k&&j==l) f[i][j][k][l]+=t[i][j];
					else f[i][j][k][l]+=t[i][j]+t[k][l];
				}
	cout<<f[n][n][n][n];
	return 0;
}
```

---

## 作者：GLr137 (赞：5)

~~一眼望去，以为是简单题，再看一下，原来要走两次……~~

### 题意简述

一个正方形方格图，从左上角出发，到右下角，走两次，只能向右或向下走，走到哪就可以取走方格中的数字，方格中的数字就会变成 $ 0 $。求两次取走的最大值。

### 思路详解

我们可以发现，这题是用 DP 做的，如果只要走一次，那么十分简单，但要走两次，动态规划的特性就十分显著了，没错，我们两次可以一起求。

首先我们遍历第一次的横纵坐标和第二次的横纵坐标，在循环中，我们可以令 DP 数组每一项的值为 $ \max(dp_{i - 1, j, k - 1, l}, dp_{i - 1, j, k, l - 1}, dp_{i, j - 1, k - 1, l}, dp_{i, j - 1, k, l - 1}) + g_{i, j} + g_{k, l}$，其中 $ g $ 数组为输入的方格图。

为什么这么做？因为我们可以想到，两个点是由两个路径转过来的，每个点可以是左边或上边的状态转移过来，那两个点就要求出四种情况的最大值，再加上方格图上两个点的值。这里我们发现会有一种两个点的位置相同的情况，所以这种情况我们只能加一次。

### Code

```cpp
# include <iostream>
using namespace std;
int n, x, y, z, sz[10][10], dp[10][10][10][10];
int main (){
    cin >> n;
    for (int i = 1; ; i++){
        cin >> x >> y >> z;
        if (x == 0 && y == 0 && z == 0){
            break;
        }else{
            sz[x][y] = z;
        }
    }
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++){
            for (int k = 1; k <= n; k++){
                for (int l = 1; l <= n; l++){
                    dp[i][j][k][l] = max(max(dp[i - 1][j][k - 1][l], dp[i - 1][j][k][l - 1]), max(dp[i][j - 1][k][l - 1], dp[i][j - 1][k - 1][l])) + sz[i][j];
                    if (i != k && j != l){
                        dp[i][j][k][l] += sz[k][l];
                    }
                }
            }
        }
    }
    cout << dp[n][n][n][n];
    return 0;
}
```

[记录](https://www.luogu.com.cn/record/200478347)

---

## 作者：_Blood__Stringer_ (赞：4)

# P1004 题解
其实这题与 [P1006](/problem/P1006) 几乎可以算得上是双倍经验。
## 题目大意
有一个 $n\times n$ 的方格图，每个格子都有一个对应的权值 $a_{i,j}$，你从 $(n,n)$ 开始走，每次可以从 $(i,j)$ 走到 $(i-1,j)$ 或 $(i,j-1)$，最终走到 $(1,1)$，你需要这样走两次，求你所经过的格子上的权值之和的最大值，每个格子上的权值只计算一次。
## Part 1
很明显，我们可以用 DFS 骗分。

但是这样明显会超时。
## Part 2
动态规划。

我们定义 $dp_{i,j,k,l}$ 为第一条路径走到 $(i,j)$，第二条路径走到 $(k,l)$ 时所能获得的权值之和的最大值。（不包含 $(i,j)$ 与 $(k,l)$ 上的权值）

初始值 $dp_{n,n,n,n}=0$。

显然，我们要求的是 $dp_{1,1,1,1} + a_{1,1}$。

转移需要考虑四种情况：
+ 第一条路径前一步走到 $(i+1,j)$，第二条路径前一步走到 $(k+1,l)$。
+ 第一条路径前一步走到 $(i,j+1)$，第二条路径前一步走到 $(k+1,l)$。
+ 第一条路径前一步走到 $(i+1,j)$，第二条路径前一步走到 $(k,l+1)$。
+ 第一条路径前一步走到 $(i,j+1)$，第二条路径前一步走到 $(k,l+1)$。

这四种情况对应的转移方程为：
+ $dp_{i,j,k,l} \gets dp_{i+1,j,k+1,l} + a_{i+1,j} + a_{k+1,l}$
+ $dp_{i,j,k,l} \gets dp_{i,j+1,k+1,l} + a_{i,j+1} + a_{k+1,l}$
+ $dp_{i,j,k,l} \gets dp_{i+1,j,k,l+1} + a_{i+1,j} + a_{k,l+1}$
+ $dp_{i,j,k,l} \gets dp_{i,j+1,k,l+1} + a_{i,j+1} + a_{k,l+1}$

取最大值即可。

同时要注意处理路径重复的情况。

时间复杂度 $O(n^4)$，可以通过本题。

以下是我用记忆化搜索写出的代码：

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define debug puts("QwQ.Please debug.");
using namespace std;
int a[10][10],n,x,y,k=1,dp[10][10][10][10];
int dfs(int x1,int y1,int x2,int y2){
	if(x1==n&&x2==n&&y1==n&&y2==n)return 0;
	if(dp[x1][y1][x2][y2]!=-1)return dp[x1][y1][x2][y2];
	dp[x1][y1][x2][y2]=0;
	if(x1+1<=n&&x2+1<=n)dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],dfs(x1+1,y1,x2+1,y2)+a[x1+1][y1]+a[x2+1][y2]-(x1==x2&&y1==y2?a[x2+1][y2]:0));
	if(x1+1<=n&&y2+1<=n)dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],dfs(x1+1,y1,x2,y2+1)+a[x1+1][y1]+a[x2][y2+1]-(x1+1==x2&&y1==y2+1?a[x2][y2+1]:0));
	if(y1+1<=n&&x2+1<=n)dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],dfs(x1,y1+1,x2+1,y2)+a[x1][y1+1]+a[x2+1][y2]-(x1==x2+1&&y1+1==y2?a[x2+1][y2]:0));
	if(y1+1<=n&&y2+1<=n)dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],dfs(x1,y1+1,x2,y2+1)+a[x1][y1+1]+a[x2][y2+1]-(x1==x2&&y1==y2?a[x2][y2+1]:0));
	return dp[x1][y1][x2][y2];
}int main(){
	cin>>n;
	memset(dp,-1,sizeof(dp));
	while(x||y||k)cin>>x>>y>>k,a[x][y]=k;
	cout<<dfs(1,1,1,1)+a[1][1];
	return 0;
}//完结撒花！
```

---

## 作者：WsW_ (赞：3)

### 思路
在这个正方形的图里面向下或者向右走非常让人看不懂，所以我们把它顺时针旋转 $45\degree$。  
以样例为例，旋转之后它就变成了这样：  
$$
0 \\
0\quad 0\\
0\quad 0\quad 0\\
0\quad 0\quad 13\quad 0\\
0\quad 0\quad 0\quad 0\quad 0\\
0\quad 21\quad 0\quad 0\quad 0\quad 0\\
0\quad 0\quad 0\quad 14\quad 7\quad 0\quad 0\\
0\quad 14\quad 15\quad 0\quad 0\quad 0\quad 0\quad 0\\
0\quad 0\quad 0\quad 0\quad 0\quad 0\quad 0\\
0\quad 0\quad 0\quad 4\quad 0\quad 0\\
0\quad 0\quad 0\quad 0\quad 0\\
0\quad 0\quad 0\quad 0\\
0\quad 0\quad 0\\
0\quad 0\\
0\\
$$  
这样向下和向右走，就变成了向左下和向右下走。  
假设只走 $1$ 次，那么这和经典 dp 题[数字三角形](https://www.luogu.com.cn/problem/P1216)是一模一样的。每次都会往下走一行，所以状态就是自己在从上往下数的第几行。  
但是要走两次，走两次太麻烦了，不如看作两个人一起走。两个人同时走一步，如果重合了那就只取走一次这个格子里的数字。  
dp 的状态定义为 $dp_{i,j,k}$ 表示大家到了第 $i$ 行，第一个人在从左往右第 $j$ 个格子，第二个人在从左往右第 $k$ 个格子时取到的最大数字和。  
知道了状态就很容易知道状态转移。每个人都是从左上或者右上格子过来的，这个转移和[数字三角形](https://www.luogu.com.cn/problem/P1216)转移几乎一样。  

时间复杂度为 $O(N^3)$。空间复杂度可以利用滚动数组优化到 $O(N^2)$，但是没必要。  

---
### 代码
代码中的状态定义和思路中的状态定义略有不同。在以下代码中，$dp_{i,j,k,t}$ 表示第一个人在 $(i,j)$，第二个人在 $(k,t)$ 时取到的最大数字和。  
建议使用思路中的状态定义，因为空间复杂度更为优秀，阶段更为明显。  

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int mp[13][13];
int dp[13][13][13][13];
int dir[2][2]={0,-1,-1,0};

bool check(int x,int y){
	return x>0&&x<=n&&y>0&&y<=n;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	while(1){
		int x,y,z;
		cin>>x>>y>>z;
		if(x|y|z)mp[x][y]=z;
		else break;
	}
	dp[1][1][1][1]=mp[1][1];
	for(int i=2;i<=(n<<1)-1;i++){
		for(int x1=min(n,i),y1=max(1,i-x1+1);x1>0&&y1<=n;x1--,y1++){
			dp[y1][x1][y1][x1]=max({dp[y1-1][x1][y1-1][x1],dp[y1][x1-1][y1-1][x1],dp[y1][x1-1][y1][x1-1]})+mp[y1][x1];
			for(int x2=x1-1,y2=y1+1;x2>0&&y2<=n;x2--,y2++){
				for(int j=0;j<2;j++){
					for(int k=0;k<2;k++){
						int fx1=x1+dir[j][0],fy1=y1+dir[j][1];
						int fx2=x2+dir[k][0],fy2=y2+dir[k][1];
						dp[y2][x2][y1][x1]=max(dp[fy2][fx2][fy1][fx1]+mp[y2][x2]+mp[y1][x1],dp[y2][x2][y1][x1]);
					}
				}
			}
		}
	}
	cout<<dp[n][n][n][n];
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：3)

容易发现本题要求最长带权路径，遂想到 dp。

这类问题的状态很好设计，用 $f_{i, j}$ 表示走到格子 $a_{i, j}$ 时的最长带权路径。

由于本题需要求两次，所以增加第二次的两维，合并为 $f_{i, j, k, l}$，代表第一次走到格子 $a_{i, j}$，第二次走到格子 $a_{k, l}$ 的答案。

状态设计已经解决，可以思考转移。

转移方程较为简单：

$$
f_{i, j, k, l} = \max({f_{i - 1, j, k - 1, l}, f_{i - 1, j, k, l - 1}, f_{i, j - 1, k - 1, l}, f_{i, j - 1, k, l - 1}}) + a_{i, j} + a_{k, l}
$$

这个公式有点头晕，略微口语来讲就是从两次的上方或左方继承，加上格子的权值，如果还是不懂先去学[前置知识](https://www.luogu.com.cn/problem/solution/P1002)。

好的，现在让我们来写代码。

```cpp
//WA 0 pts

#include<bits/stdc++.h>
using namespace std;
int n, a[15][15], f[15][15][15][15];
int main(){
	cin >> n;
	while(1){
		int x, y, v; cin >> x;
		if(x == 0) break;
		cin >> y >> v;
		a[x][y] = v;
	}
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= n; j ++)
			for(int k = 1; k <= n; k ++)
				for(int l = 1; l <= n; l ++){
					f[i][j][k][l] = max({f[i - 1][j][k - 1][l], f[i - 1][j][k][l - 1], f[i][j - 1][k - 1][l], f[i][j - 1][k][l - 1]}) + a[i][j] + a[k][l];
					//状态转移方程
				}
	cout << f[n][n][n][n];
	return 0;
}
```

于是我们得到了 [0 分的好成绩](https://www.luogu.com.cn/record/200655369)。

原因其实很简单，重新读题。

> 某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（**取走后的方格中将变为数字 $0$**）。

容易发现我们计算时两次行走时重复点算了两次，加入相同判断即可。

[Accepted]()。

```cpp
//AC 100 pts

#include<bits/stdc++.h>
using namespace std;
int n, a[15][15], f[15][15][15][15];
int main(){
	cin >> n;
	while(1){
		int x, y, v; cin >> x;
		if(x == 0) break;
		cin >> y >> v;
		a[x][y] = v;
	}
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= n; j ++)
			for(int k = 1; k <= n; k ++)
				for(int l = 1; l <= n; l ++){
					f[i][j][k][l] = max({f[i - 1][j][k - 1][l], f[i - 1][j][k][l - 1], f[i][j - 1][k - 1][l], f[i][j - 1][k][l - 1]}) + a[i][j] + a[k][l];
					//状态转移方程
					if(i == k && j == l) f[i][j][k][l] -= a[i][j];//重复计算减去一次
				}
	cout << f[n][n][n][n];
	return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

经典动态规划问题。

先考虑只取一遍的方格取数，设 $f_{i, j}$ 表示以 $(i, j)$ 为结尾的路径的最大和，$a_{i, j}$ 表示格子 $(i, j)$ 的数字。转移是 $f_{i, j}=\max(f_{i-1, j}, f_{i, j-1})+a_{i, j}$。

那么取两遍就多设两维好了，即设 $f_{i, j, k, l}$ 表示第一条路径以 $(i, j)$ 结尾，第二条路径以 $(k, l)$ 结尾的两条路径的最大和，转移的话就相当于两条路径分别转移，即 $f_{i, j, k, l}=\max(f_{i-1, j, k-1, l}, f_{i, j-1, k-1, l}, f_{i-1, j, k, l-1}, f_{i, j-1, k, l-1})+a_{i, j}+a_{k, l}$。

题目要求取走后的方格清零，所以要特判两条路径结尾在一个格子的情况，即当 $i=k$ 且 $j=l$ 时，会加两遍当前格子，按照题目要求只能加一遍 $a_{i, j}$。

答案是 $f_{n, n, n, n}$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x, y, z, a[10][10], f[10][10][10][10];
int main(){
	cin >> n;
	while (cin >> x >> y >> z)
		a[x][y]=z;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			for(int k=1; k<=n; k++)
				for(int l=1; l<=n; l++)
					f[i][j][k][l]=max({f[i-1][j][k-1][l], f[i][j-1][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k][l-1]})+a[i][j]+(i!=k||j!=l)*a[k][l];
	cout << f[n][n][n][n];
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：2)

### 思路

容易看出本题应使用 DP 算法求解。我们可以同时处理两条路径。

定义 $a_{i,j}$ 表示方格中的数，$f_{i_1,j_1,i_2,j_2}$ 表示第 $1$ 条路径走到了 $(i_1,j_1)$ 的位置，第 $2$ 条路径走到了 $(i_2,j_2)$ 的位置，不难写出动态转移方程：

$$
f_{i_1,j_1,i_2,j_2} = 
\begin{cases}
a_{i_1,j_1} + \max(f_{i_1,j_1-1,i_2-1,j_2},f_{i_1-1,j_1,i_2,j_2-1}) & \operatorname{if} \hspace{1mm} i_1 = i_2 \\
a_{i_1,j_1} +a_{i_2,j_2} +\max(f_{i_1-1,j_1,i_2-1,j_2},f_{i_1-1,j_1,i_2,j_2-1},f_{i_1,j_1-1,i_2-1,j_2},f_{i_1,j_1-1,i_2,j_2-1}) & \text{otherwise}
\end{cases}
$$

不难看出最终答案为 $f_{n,n,n,n}$。

时间复杂度为 $O(n^4)$。

### 实现

```cpp
# include <iostream>
using namespace std;
int grid[11][11],dp[11][11][11][11];
int main(){
	int n; cin >> n;
	int x,y,m;
	while (cin >> x >> y >> m){
		if (x == 0 && y == 0 && m == 0) break;
		grid[x][y] = m;
	}for (int i1 = 1;i1 <= n;i1++){
		for (int j1 = 1;j1 <= n;j1++){
			for (int i2 = 1;i2 <= n;i2++){
				for (int j2 = 1;j2 <= n;j2++){
					if (i1 == i2){
						dp[i1][j1][i2][j2] = grid[i1][j1] + max(dp[i1][j1-1][i2-1][j2],dp[i1-1][j1][i2][j2-1]);
					}else{
						dp[i1][j1][i2][j2] = grid[i1][j1] + grid[i2][j2] + max(max(dp[i1-1][j1][i2-1][j2],dp[i1-1][j1][i2][j2-1]),max(dp[i1][j1-1][i2-1][j2],dp[i1][j1-1][i2][j2-1]));
					}
				}
			}
		}
	}cout << dp[n][n][n][n];
	return 0;
}
```

### 优化

不难看出 $f_{i_1,j_1,i_2,j_2}$ 表示的两条路径走的长度一样，所以有 $i_1+j_1=i_2+j_2$，故我们可以把原本 DP 的四维优化到三维。

优化后时间复杂度可以降为 $O(n^3)$。

读者可以自行尝试优化到三维，这里不再赘述。

---

## 作者：lucky_Mrzhao (赞：2)

## 思路

虽然是两条路，但是仍然考虑动态规划。

我们定义一个四维数组 $f_{i,j,x,y}$ 表示第一条路线走到点 $(i,j)$，第二条路线走到点 $(x,y)$ 时候的最大价值。因为只能向下或者向右走，所以两条路径走的长度是一样的，即 $i+j=x+y$。所以当 $i=x$ 时，$j=y$ 。所以当两条路线重合时，需要减去一条路径上获取的价值。所以有：

$$
f_{i,j,x,y}=\begin{cases}
a_{i,j}+\max f_{i,j-1,x-1,y},f_{i-1,j,x,y-1} & i=x\\
a_{i,j}+a_{x,y}+\max f_{i-1,j,x-1,y}+f_{i-1,j,x,y-1},f{i,j-1,x-1,y},f{i,j-1,x,y-1} & i \ne x\\
\end{cases}
$$

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15][15];
int f[15][15][15][15];
int main(){
	int n;
	cin >> n;
	int i,j,k;
	while(true){
		cin >> i >> j >> k;
		if(i==0&&j==0&&k==0) break;
		a[i][j] = k;
	}
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= n;j++){
			for(int x = 1;x <= n;x++){
				for(int y = 1;y <= n;y++){
					if(i==x){
						f[i][j][x][y] = a[i][j] + max(f[i][j-1][x-1][y],f[i-1][j][x][y-1]);
					}
					else{
						f[i][j][x][y] = a[i][j] + a[x][y] + max(max(f[i-1][j][x-1][y],f[i-1][j][x][y-1]),max(f[i][j-1][x-1][y],f[i][j-1][x][y-1]));
					}
				}
			}
		}
	}
	cout << f[n][n][n][n];
}
```

---

## 作者：mairuisheng (赞：2)

[P1004 [NOIP2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)

算法：动态规划

分析：$block_{i,j}$ 为坐标 $(i,j)$ 上的数，设 $dp_{i,j,k,l}$ 为第一条路径到了坐标 $(i,j)$，第二条路径到了坐标 $(k,l)$，采用逆推的方法，此时状态转移方程：

当 $i=k$，说明两条路径重合了，此时会少两种情况：
$$dp_{i,j,k,l}=\max(dp_{i+1,j,k,l+1},dp_{i,j+1,k+1,l})+block_{i,j}$$
否则，对每种情况取最大值：
$$dp_{i,j,k,l}=\max(dp_{i+1,j,k,l+1},dp_{i,j+1,k+1,l},dp_{i+1,j,k+1,l},dp_{i,j+1,k,l+1})+block_{i,j}+block_{k,l}$$

因为是逆推，所以最后输出 $dp_{1,1,1,1}$ 作为答案。
```cpp
#include<cstdio>
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>='0'&&s<='9')
	{
		x=(x<<3)+(x<<1)+(s-48);
		s=getchar();
	}
	return x*f;
}
int dp[11][11][11][11];
int n;
int ans;
int block[10][10];
int max(int x,int y)
{
	return x>y?x:y;
}
signed main()
{
	int x,y,z,i,j,i2,j2;
	n=read();
	while(1)
	{
		x=read();
		y=read();
		z=read();
		if(x==0)break;
		block[x][y]=z;
	}
	for(i=n;i>0;--i)//坐标
	{
		for(j=n;j>0;--j)
		{
			for(i2=n;i2>0;--i2)
			{
				for(j2=n;j2>0;--j2)
				{
					if(i==i2)dp[i][j][i2][j2]=max(dp[i+1][j][i2][j2+1],dp[i][j+1][i2+1][j2])+block[i][j];
					else dp[i][j][i2][j2]=max(dp[i+1][j][i2][j2+1],max(dp[i][j+1][i2+1][j2],max(dp[i+1][j][i2+1][j2],dp[i][j+1][i2][j2+1])))+block[i][j]+block[i2][j2];
				}
			}
		}
	}
	printf("%d",dp[1][1][1][1]);
	return 0;
}
```

---

## 作者：kunkun127 (赞：2)

## 思路

这题就是 DP 入门题。我们注意到数据范围较小，为 $n \le 9$，故我们设计一个四维的 DP 状态，同时处理两条路径。

### DP

令 $f_{i,j,k,l}$ 表示第一条路经走到 $(i, j)$ 的位置，第二条路经则走到 $(k, l)$ 的位置。我们对走上下左右四个方向进行取最大值，故有：

$$f_{i, j, k, l} = \max(f_{i+1,j,k,l+1}, f_{i+1,j,k+1,l}, f_{i,j+1,k,l+1}, f_{i,j+1,k+1,l}) + a_{i,j} + a_{k,l}$$

同时，还有一个特殊的位置：当两条路径走到一个位置时，我们**只能对这个方格里的数取一次值**。那么我们进行特判，此时转移为：

$$f_{i, j, k, l} = f_{i+1,j,k,l+1} + a_{i,j}$$

### 输出

- 选择顺推模拟，则输出 $f_{n,n,n,n}$。
- 选择倒推，则输出 $f_{1,1,1,1}$。

## 参考代码


```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;
const int hyh_lover = 647;
int a[15][15], dp[15][15][15][15];
 
int max(int b, int c, int d, int e)
{
    return max(max(max(d, e), c), b);
}
 
int main()
{
    int n, x, y, z, sum = 0;
    cin >> n;
    do
    {
        cin >> x >> y >> z;
        a[x][y] = z;
    }
    while (x != 0 && y != 0 && z != 0);
    for (int i1 = n; i1 >= 1; i1--)
    {
        for (int j1 = n; j1 >= 1; j1--)
        {
            for (int i2 = n; i2 >= 1; i2--)
            {
                for (int j2 = n; j2 >= 1; j2--)
                {
                    if (i1 == i2) dp[i1][j1][i2][j2] = dp[i1 + 1][j1][i2][j2 + 1] + a[i1][j1];
                    else dp[i1][j1][i2][j2] = maxm(dp[i1 + 1][j1][i2][j2 + 1], dp[i1 + 1][j1][i2 + 1][j2], dp[i1][j1 + 1][i2][j2 + 1], dp[i1][j1 + 1][i2 + 1][j2]) + a[i1][j1] + a[i2][j2];
                }
            }
        }
    }
    cout << dp[1][1][1][1] << endl;
	return !(hyh_lover == 647);
}
```

---

## 作者：stringdp100005 (赞：1)

本蒟蒻第一道绿题！
# 解题思路
很容易发现这是一道动态规划题.用第 $1,2$ 维表示去时的路，$3,4$ 维表示回时的路。  
考虑转移，每维可以从两个方向转移，共有四种转移方式。分别是 $dp_{i-1,j,k-1,l},dp_{i-1,j,k,l-1},dp_{i,j-1,k-1,l},dp_{i,j-1,k,l-1}$。  
总共还要加上当前格子的情况，要特判来去相同的情况，只算一次。  
所以状态转移方程是：$dp_{i,j,k,l}=dp_{i-1,j,k-1,l}+dp_{i-1,j,k,l-1}+dp_{i,j-1,k-1,l}+dp_{i,j-1,k,l-1}+[i≠k\wedge j≠l]\times a_{i,j}+a_{k,l}$。  
最终答案是 $dp_{n,n,n,n}$。
# AC 代码
```cpp
#define Code using
#define by namespace
#define stringdp100005 std
#include<bits/stdc++.h>
#define int long long
#define max(a,b,c,d) max(max(a,b),max(c,d))
Code by stringdp100005;
int n,a[15][15],ans[15][15][15][15];
signed main(){
	cin>>n;
	int x,y,num;
	while(cin>>x>>y>>num&&(x!=0||y!=0||num!=0))	a[x][y]=num;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n;k++)
				for(int l=1;l<=n;l++)
					ans[i][j][k][l]=max(ans[i-1][j][k-1][l],ans[i][j-1][k][l-1],ans[i-1][j][k][l-1],ans[i][j-1][k-1][l])+(i!=k||j!=l)*a[i][j]+a[k][l];
	cout<<ans[n][n][n][n];		
	return 0;
}
```

---

## 作者：3_14 (赞：1)

[**题目传送门**](https://www.luogu.com.cn/problem/P1004)

# 思路

这道题要求从左上角到右下角走两次，每次只能向下或向右移动，且走过的路径上的数字会被取走（变为 $0$）。目标是找到两条路径，使得取走的数字之和最大。

我们可以用一个四维数组 $dp\left[i_1 \right]\left[j_1\right]\left[i_2\right]\left[j_2\right]$ 来表示两条路径分别走到 $\left(i_1, j_1\right)$ 和 $\left(i_2, j_2\right)$ 时的最大和。由于两条路径的步数是相同的，我们可以将状态简化为 $dp\left[k \right]\left[i_1\right]\left[i_2\right]$，其中 $k$ 表示当前步数，$i_1$ 和 $i_2$ 分别表示两条路径当前所在的行。

对于每一步，两条路径都有两种选择：向下或向右。因此，状态转移方程为：

$$dp\left[k\right]\left[i_1\right]\left[i_2\right]=\max\left(dp\left[k-1\right]\left[i_1\right]\left[i_2\right],dp\left[k-1\right]\left[i_1-1\right]\left[i_2\right],dp\left[k-1\right]\left[i_1\right]\left[i_2-1\right],dp\left[k-1\right]\left[i_1-1\right]\left[i_2-1\right]\right)+gril\left[i_1\right]\left[j_1\right]+gril\left[i_2\right]\left[j_2\right]$$

如果两条路径走到同一个格子，则只能取一次该格子的值。初始状态为 $dp\left[0\right]\left[0\right]\left[0\right]=gril\left[0\right]\left[0\right]$。如果 $i_1=i_2$ 且 $j_1=j_2$，则只能取一次该格子的值。

最终结果就为 $dp\left[2*N-2\right]\left[N-1\right]\left[N-1\right]$，即两条路径都走到右下角时的最大和。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5;
int N,x,y,val;
int main(){
    cin>>N;
    vector<vector<int>>grid(N,vector<int>(N,0));
    vector<vector<vector<int>>>dp(2*N-1,vector<vector<int>>(N,vector<int>(N,0)));
    while(cin>>x>>y>>val&&(x||y||val))grid[x-1][y-1]=val;
    dp[0][0][0]=grid[0][0];
    for(int k=1;k<2*N-1;k++){
        for(int i1=0;i1<N;i1++){
            for(int i2=0;i2<N;i2++){
                int j1=k-i1,j2=k-i2;
                if(j1<0||j1>=N||j2<0||j2>=N)continue;
                int val1=grid[i1][j1],val2=grid[i2][j2];
                if(i1==i2&&j1==j2)val2=0;
                int maxPrev=0;
                if(i1>0&&i2>0)maxPrev=max(maxPrev,dp[k-1][i1-1][i2-1]);
                if(i1>0)maxPrev=max(maxPrev,dp[k-1][i1-1][i2]);
                if(i2>0)maxPrev=max(maxPrev,dp[k-1][i1][i2-1]);
                maxPrev=max(maxPrev,dp[k-1][i1][i2]);
                dp[k][i1][i2]=maxPrev+val1+val2;
            }
        }
    }
    cout<<dp[2*N-2][N-1][N-1]<<'\n';
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/200527910)

---

## 作者：FastIO_DP (赞：1)

### 题目理解

一个 $ n \times n $ 的方格图，某些方格中填有正整数，其余方格为 $ 0 $。从左上角出发，走到右下角，每次只能向右或向下移动。走两次这样的路径，取走经过的方格中的数（取走后方格变为 $ 0 $），求两条路径取数的最大和。

### 解题思路

考虑动态规划。

可以定义 $ dp[k][i][j] $ 表示两条路径分别走到 $ (i, k - i) $ 和 $ (j, k - j) $ 时的最大和。

这里，$ k $ 表示两条路径的总步数（从起点到当前点的步数）。$ i $ 和 $ j $ 分别表示两条路径的行号。

对于每一步 $ k $，我们枚举两条路径的行号 $ i $ 和 $ j $，并计算列号 $ j1 = k - i $ 和 $ j2 = k - j $。如果 $ j1 $ 和 $ j2 $ 越界就 continue。

状态转移方程为：
$$
dp[k][i][j] = \max \begin{cases}
dp[k-1][i][j] + val, \\
dp[k-1][i][j-1] + val, \\
dp[k-1][i-1][j] + val, \\
dp[k-1][i-1][j-1] + val
\end{cases}
$$
方程里的 $ val $ 是当前格子的数。如果两条路径走到同一个格子，那就只计算一次 $ val $。

#### 压缩空间（虽然没有什么用）

因为 $ dp[k][i][j] $ 只依赖于 $ dp[k-1][...][...] $，直接使用滚动数组的技巧，将空间复杂度从 $ O(n^3) $ 降低到 $ O(n^2) $。所以，只需要两个二维数组 $ dp1 $ 和 $ dp2 $，分别表示当前步数和上一步数的状态。

### AC Code

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
int a[N][N]; 
int dp1[N][N];  
int dp2[N][N];  

int main() {
    cin >> n;
    while (true) {
        int x, y, val;
        cin >> x >> y >> val;
        if (x == 0 && y == 0 && val == 0) break;
        a[x][y] = val;
    }

    for (int k = 2; k <= 2 * n; ++k) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                int j1 = k - i, j2 = k - j;
                if (j1 < 1 || j1 > n || j2 < 1 || j2 > n) continue; 

                int val = a[i][j1] + a[j][j2];
                if (i == j && j1 == j2) val -= a[i][j1];

                dp1[i][j] = max({
                    dp2[i][j] + val,
                    dp2[i][j - 1] + val,
                    dp2[i - 1][j] + val,
                    dp2[i - 1][j - 1] + val
                });
            }
        }

        swap(dp1, dp2);
    }

    cout << dp2[n][n] << endl;

    return 0;
}
```

### 复杂度分析

- **时间复杂度**：$ O(n^3) $，$ k $ 的范围是 $ 2 $ 到 $ 2 \times n $，而 $ i $ 和 $ j $ 的范围是 $1$ 到 $ n $。
- **空间复杂度**：$ O(n^2) $，只使用了两个二维数组 $ dp1 $ 和 $ dp2 $。

---

## 作者：liuyuhan1522 (赞：1)

# 题解：P1004 [NOIP2000 提高组] 方格取数
[题目传送门](https://www.luogu.com.cn/problem/P1004)

---
DP ~~入门~~题。

注意到数据范围较小，为 $n≤9$，故我们设计一个四维的 DP 状态，同时处理两条路径，并用 $t_{i,j}$ 存储第 $(i,j)$ 个格子里的数。

我们用 $dp_{i,j,k,l}$ 表示第 $1$ 次从 $A$ 点走到 $(i,j)$，第 $2$ 次从 $A$ 点走到 $(k,l)$ 所取到的最大值。

这里用顺序模拟的方法，从每个格都要由上、左两个方向转移。因为有 $2$ 个人， 所以分出 $4$ 种情况，故有：

$$dp_{i,j,k,l}=\max(\max(dp_{i-1,j,k-1,l},dp_{i-1,j,k,l-1}),\max(dp_{i,j-1,k-1,l},dp_{i,j-1,k,l-1}) + t_{i,j}+t_{k,l}$$

但还有一种情况，当两条路走到同一个格子时，只能加一次格子里的数，即 $i = k$ 时，有：

$$dp_{i,j,k,l}=\max(dp_{i,j-1,k-1,l},dp_{i-1,j,k,l-1})+ t_{i,j}$$

---
### 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int dp[11][11][11][11];
int t[11][11];

int main(){
	int N;
	cin>> N ;
	
	int a, b, c;
	cin>> a >> b >> c ;
	while(a) {
		t[a][b] = c;
		cin>> a >> b >> c ;
	}
	
	for(int i=1; i<=N; i++) {
		for(int j=1; j<=N; j++) {
			for(int k=1; k<=N; k++) {
				for(int l=1; l<=N; l++) {
					dp[i][j][k][l] = (i == k ? max(dp[i][j-1][k-1][l], dp[i-1][j][k][l-1]) + t[i][j]
											 : max(max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]),
									 	 		   max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])) 
											   + t[i][j] + t[k][l]);
				}
			}
		}
	}
	
	cout<< dp[N][N][N][N] ;
	
	return 0;
}
```
[一遍过记录](https://www.luogu.com.cn/record/200382867)。

---

求通过 sto 。

---

## 作者：ClV_Csy (赞：1)

# P1004 [NOIP2000 提高组] 方格取数
## 前言
双倍经验 [P1006 [NOIP2008 提高组] 传纸条](https://www.luogu.com.cn/problem/P1006)
## 题意
给定一个 $N \times N$ 的矩阵 $a$（我们可以根据输入求出这个矩阵），要求从 $(1, 1)$ 到 $(N, N)$ 的**最大路径与次大路径之和**（只可往下或往右）。
## 思路
看到题面，马上可以想到 DP。观察数据范围，发现 $1 \le N \le 9$，考虑复杂度为 $O(n^4)$ 的 DP。  

我们先来做一做简化版的题面：  
给定一个 $N \times N$ 的矩阵 $a$，要求从 $(1, 1)$ 到 $(N, N)$ 的最大路径（只可往下或往右）。  
令 $f_{x, y}$ 表示**从 $(1, 1)$ 到 $(x, y)$ 的最大路径。**  
我们知道，对于每一个 $(i, j)$，它要么是从 $(i - 1, j)$（也就是左面）过来的，要么是从 $(i, j - 1)$（也就是上面）过来的。所以我们计算 $f_{i, j}$ 时，只需取 $f_{i - 1, j}$ 与 $f_{i, j - 1}$ 的最大值再加上 $a_{i, j}$ 即可。很容易推出状态转移方程：
$$f_{i, j} \gets \max(f_{i - 1, j}, f_{i, j - 1}) + a_{i, j}$$
这就是简化版的做法了。

-----
令 $f_{x1, y1, x2, y2}$ 表示：  
**从 $(1, 1)$ 到 $(x1, y1)$ 的最大数之和与从 $(1, 1)$ 到 $(x2, y2)$ 的最大数之和的和。**  
接下来我们仿照简化版来推状态转移方程。对于每一个 $(i, j, k, t)$，它是从
- $(i - 1, j, k - 1, t)$
- $(i - 1, j, k, t - 1)$
- $(i, j - 1, k - 1, t)$
- $(i, j - 1, k, t - 1)$

中的一个点过来的。我们只需取这四个点中的最大值，再加上 $a_{i, j}$ 和 $a_{k, t}$ 即可。状态转移方程：
$$f_{i, j, k, t} \gets \max(f_{i - 1, j, k - 1, t}, f_{i - 1, j, k, t - 1}, f_{i, j - 1, k - 1, t}, f_{i, j - 1, k, t - 1}) + a_{i, j} + a_{k, t}$$
**注意**，还有一个特例：  
当 $(i, j) = (k, t)$ 时，两点所处位置相同，所以我们在计算 $f_{i, j, k, t}$ 时需要减去 $a_{i, j}$（或 $a_{k, t}$）。
## 代码

```cpp
#include <iostream>
using namespace std;
int a[10][10];
int dp[10][10][10][10];
int main() {
	int n;
	cin >> n;
	int x, y, p;
	cin >> x >> y >> p;
	while (x && y && p) {
		a[x][y] = p;
		cin >> x >> y >> p;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= n; k++) {
				for (int t = 1; t <= n; t++) {
					int maxn1 = max(dp[i - 1][j][k - 1][t], dp[i - 1][j][k][t - 1]);
					int maxn2 = max(dp[i][j - 1][k - 1][t], dp[i][j - 1][k][t - 1]);
					int maxn = max(maxn1, maxn2);
					dp[i][j][k][t] = maxn + a[i][j] + a[k][t];
					if (i == k && j == t) {
						dp[i][j][k][t] -= a[i][j];
					}
				}
			}
		}
	}
	cout << dp[n][n][n][n];
	return 0;
}
```

---

## 作者：Jayfeather2012 (赞：1)

## 思路
不难看出这题是动态规划。  
二维动规只考虑一条路径的情况，没有结合两条路径全局考虑，显然不是正解。  
考虑四维动规，同时考虑两次路径，使 $f[i][j][k][l]$ 表示第一次走到 $(i,j)$，第二次走到 $(k,l)$ 的最大收益。根据题意，当你走到一个点，你走到的上一个点肯定是你的左边或你上面，所以到点 $(i,j)$ 的最大收益是走到 $(i,j-1)$ 的最大收益和走到 $(i-1,j)$ 的最大收益的最大值加上点 $(i,j)$ 的值，到点 $(k,l)$ 的最大收益是走到 $(k,l-1)$ 的最大收益和走到 $(k-1,l)$ 的最大收益的最大值加上点 $(k,l)$ 的值。  
组合一下，第一次走到 $(i,j)$，第二次走到 $(k,l)$ 的上一步有四种情况：
1. 第一次上一步 $(i-1,j)$，第二次上一步 $(k-1,l)$。
2. 第一次上一步 $(i-1,j)$，第二次上一步 $(k,l-1)$。
3. 第一次上一步 $(i,j-1)$，第二次上一步 $(k-1,l)$。
4. 第一次上一步 $(i,j-1)$，第二次上一步 $(k,l-1)$。

于是 $f[i][j][k][l]$ 的值是 $f[i-1][j][k-1][l]$、$f[i-1][j][k][l-1]$、$f[i][j-1][k-1][l]$、$f[i][j-1][k][l-1]$ 中的最大值加点 $(i,j)$ 和点 $(k,l)$ 上的数，但是当 $i=k$ 且 $j=l$ 时只能加一次，因为第一次取完一格上的数，第二次就不能再取。  
不难看出，答案是两次路径都到达终点的最大收益，即 $f[n][n][n][n]$。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10][10],n,x=1,y=1,s=1,f[10][10][10][10];
int main()
{
	cin>>n;
	while(x!=0&&y!=0&&s!=0)
	{
		cin>>x>>y>>s;
		a[x][y]=s;
	}
	for(int i=1;i<=n;i++){
	    for(int j=1;j<=n;j++){
		    for(int k=1;k<=n;k++){
			    for(int l=1;l<=n;l++){
				    f[i][j][k][l]=(i==k&&j==l?a[i][j]:a[i][j]+a[k][l]);
				    //当前格中的数，注意特判
				    f[i][j][k][l]+=max({f[i-1][j][k-1][l],f[i-1][j][k][l-1],f[i][j-1][k-1][l],f[i][j-1][k][l-1]});
				    //上一步的最优解
				}
			}
		}
	}
	cout<<f[n][n][n][n];//输出
  	return 0;
}
```

---


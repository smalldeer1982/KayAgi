# [NOIP 2008 提高组] 传纸条

## 题目描述

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。


## 说明/提示

**【数据范围】**

对于 $30\%$ 的数据，满足 $1 \le m,n \le 10$。  
对于 $100\%$ 的数据，满足 $1 \le m,n \le 50$。

**【题目来源】**

NOIP 2008 提高组第三题。

## 样例 #1

### 输入

```
3 3
0 3 9
2 8 5
5 7 0
```

### 输出

```
34```

# 题解

## 作者：聪明王必胜 (赞：926)

##作为一个动归初学者，感觉各位大佬的题解太过麻烦（其实是我看不懂）

#我领悟到了真正简单的方法，相信蒟蒻们也能看懂（莫名自信）

因为是从上方和从下方传纸条，为了方便，我们相当于从左上角连续传两张纸条，路径不重复，效果相同。

从左上来看的话就只能向右或向下传纸条。

##那么两张纸条在过程中就一定在一条斜线上，而在一条斜线上纵坐标与横坐标相加相等。

![](https://cdn.luogu.com.cn/upload/pic/9892.png) 在如图的斜线中，两个点的和都为3.

首先重要的就是三维F数组。

第一维度维护的是在传的过程中纵坐标与横坐标的和。

#在同一斜线上，剩下表示两个点的从坐标就可以表示这两个点的位置。

第二维度维护的是相对在左边的点的纵坐标。

第三维度维护的是相对在右边的点的纵坐标。

当查询一个情况时，只有四种情况可以到他

F[sum][i][j]=max{F[sum-1][i][j]+F[k-1][i][j-1]+F[k-1][i-1][j]+F[k-1][i-1][j-1]；

最后再加上a数组里存的两个点的好感度即可

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=60;
int a[maxn][maxn];
int F[2*maxn][maxn][maxn];
int main()
{
  int m,n;
  scanf("%d%d",&m,&n);
  for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
      scanf("%d",&a[i][j]);
  //F[sum][i][j]=max{F[sum-1][i][j]...
  memset(F,-1,sizeof(F));//赋初值为-1 (原因在后面） 
  F[2][1][1]=0;//最初的点，在左上角，好感度为0 
  for(int k=3;k<m+n;k++)
    for(int i=1;i<n;i++)
      for(int j=i+1;j<=n;j++)
      {
        int s=F[k][i][j];
        if(F[k-1][i][j]>s)s=F[k-1][i][j];
        if(F[k-1][i-1][j]>s)s=F[k-1][i-1][j];
        if(F[k-1][i][j-1]>s)s=F[k-1][i][j-1];
        if(F[k-1][i-1][j-1]>s)s=F[k-1][i-1][j-1];
        if(s==-1)continue;//当s为-1时，说明四种情况都不能到该点，故不存在。 
        F[k][i][j]=s+a[k-i][i]+a[k-j][j];//该点的值为最大的前一个值与当前F[k][i][j]表示两点的值的和。 
      }
  printf("%d",F[m+n-1][n-1][n]);//因为i永远小于j，所以右下角的点不会求到，
  //但是到右下角只有一种情况，就是在右下角的上面和右下角的左边，直接输出就好了。 
  return 0;
 } 
```

---

## 作者：然而已经 (赞：127)

感觉应该对2条路径走到一个点（重复点）处理方法不懂  
举例一个四维dp的里的做法（三维等解法的大佬不要嘲笑）  

首先，起点到终点走两次与题意是等效的。  
四位dp很容易想，但对于大佬题解里重复点的处理，蒟蒻实在是有点不太明白

我们可以这样想，2条路径不相交，那么肯定**一条在上面，一条在下面**，如图是随便画的2条路径

![](https://cdn.luogu.com.cn/upload/pic/30960.png)

$i,j$是红色路径的坐标，$k, l$是黑色路径的坐标

那么对于$k$，我们只需枚举$[i+1, m]$,$l$只需枚举$[1,j-1]$即可  
这样就不用判重啦

由于最后dp不到终点，但其实黑色路径走到终点上方的点，红色路径走到终点左边的点就是答案,即`f[m-1][n][m][n-1]`

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
#define INF = 0x3f3f3f3f

int a[51][51], f[51][51][51][51];
int m, n;

int max(int i, int j, int k, int l){
    int m = max(i, j), n = max(k, l);
    return max(m, n);
}

int main()
{
    cin >> m >> n;
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++)
        {
            cin >> a[i][j];
        }
    }
    f[1][1][1][1] = 0; //garbage
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            for(int k = i+1; k <= m; k++){
                for(int l = 1; l < j; l++){
                    f[i][j][k][l] = max(
                        f[i][j-1][k][l-1],
                        f[i][j-1][k-1][l],
                        f[i-1][j][k-1][l],
                        f[i-1][j][k][l-1]
                    )+a[i][j]+a[k][l];
                }
            }
        }
    }
    cout << f[m-1][n][m][n-1] << endl;
    return 0;    
}
```






---

## 作者：ouuan (赞：106)

前4页题解都没有用滚动数组的..碰到我出的[大教室中传纸条](https://www.luogu.org/problemnew/show/T35377)全得炸。

思路其它题解说的很清楚了，就是看成同时从左上开始传两个纸条，用f(i,j,k)表示这一步的横纵坐标之和为i，第一张纸条纵坐标为j，第二张纸条纵坐标为k（因为路径不重合，所以j≠k，不妨令j<k）。可以看出每走一步纸条的横纵坐标之和都会加一，所以i其实就是传递的次数+2.

每个状态可以由以下4种情况转移而来：

1. 第一张纸条由上面，第二张纸条由上面
f(i,j,k)=max{f(i,j,k),f(i-1,j-1,k-1)+a[j][i-j]+a[k][i-k]}

2. 第一张纸条由上面，第二张纸条由左边
f(i,j,k)=max{f(i,j,k),f(i-1,j-1,k)+a[j][i-j]+a[k][i-k]}

3. 第一张纸条由左边，第二张纸条由上面
f(i,j,k)=max{f(i,j,k),f(i-1,j,k-1)+a[j][i-j]+a[k][i-k]}

4. 第一张纸条由左边，第二张纸条由左边
f(i,j,k)=max{f(i,j,k),f(i-1,j,k)+a[j][i-j]+a[k][i-k]}

可以看出，每种转移都是在一定情况下才能发生的（没有越界，而且纸条没有重合）。由于一开始数组中都是0，不进行越界判断也无妨，但是纸条重合的判断必须有，即只有k-1>j时才能由第3种情况转移.

### 然后重点来了

本题解和前4页题解（没往后面翻了orz）的不同之处在于，用了滚动数组。其实就是因为转移时只会由f(i-1,x,y)转移而来，在数组中省去了i这一维，节约了一些空间。需要注意的就是由于状态都是由更小的j和/或k转移而来，j和k都需要倒序枚举，防止状态在转移之前被修改。

代码如下：
```
#include <fstream>
#include <iostream>
#include <algorithm>

using namespace std;

/*
这一部分是用来方便地转换标准io和文件io，
只需在#include <iostream>前加上//就可以转换为文件io
*/

#ifndef _GLIBCXX_IOSTREAM //这个在iostream头文件中define了，这句话的意思就是如果没有#include <iostream>则执行下面的语句
ifstream cin("0.in");
ofstream cout("0.out");
#endif

int n,m,f[210][210],a[210][210];

int main()
{
    int i,j,k;
    
    cin>>n>>m;
    
    for (i=1;i<=n;++i)
    {
        for (j=1;j<=m;++j)
        {
            cin>>a[i][j];
        }
    }
    
    f[1][2]=a[1][2]+a[2][1];
    
    for (i=4;i<n+m;++i)
    {
        for (j=min(i-2,n);j>=1;--j) //注意要倒序枚举j和k
        {
            for (k=min(i-1,n);k>j;--k)
            {
                if (j>1)  //这里的条件判断貌似是不需要的，但我觉得加上更好
                {
                    f[j][k]=max(f[j][k],f[j-1][k]);
                }
                if (j>1&&k>1)
                {
                    f[j][k]=max(f[j][k],f[j-1][k-1]);
                }
                if (k-1>j)
                {
                    f[j][k]=max(f[j][k],f[j][k-1]);
                }
                f[j][k]+=a[j][i-j]+a[k][i-k];
            }
        }
    }
    
    cout<<f[n-1][n];
    
    return 0;
}
```

---

## 作者：Little_x_starTYJ (赞：8)

## 前言
每次~~准备摸鱼时~~都在这道题的界面。

今天有空做做，顺便写一波题解，毕竟估值蹭蹭往下跳。

双倍经验：[P1004 [NOIP 2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)，[P1006 [NOIP 2008 提高组] 传纸条](https://www.luogu.com.cn/problem/P1006)。

## 题意简述
现有一个 $m$ 行 $n$ 列的矩阵，每个位置上都有一个 $[0, 100]$ 的整数。

你需要在这个矩阵上走两遍，第一遍从左上走到右下，这时你只能向下、向右走。第二遍从右下走到左上，这是你只能向上、向左走。要求两条路径不能有重合（矩阵的左上角与右下角除外）。

请你求出这两条路径所经过的点的总和的最大值。

## 解题思路
如果你做过 [P1004 [NOIP 2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)，那么改一下输入就能过。

但是为什么 dp 式子不用改？且听我慢慢道来。

众所周知，这道题从右下走到左上与从左上做到右下是等价的。所以，我们巧妙的将这道题转化为了：从左上走到右下，被走过的点不能再走，再从左上走到右下所经过的点的总和的最大值。

于是我们定义 $dp_{i, j, k, l}$ 为第一遍走到了 $(i,j)$，第二遍走到了 $(k,l)$ 时的最大值。那么状态转移方程就是
$$
\begin{equation*}
dp_{i, j, k, l} = 
\begin{cases}
    \max\{dp_{i - 1, j, k - 1, l}, dp_{i - 1, j, k, l - 1}, dp_{i, j - 1, k - 1, l}, dp_{i, j - 1, k, l - 1}\} + a_{i,j} + a_{k,l}, & \text{if } i \neq k \land j \neq l \lor (i = 1 \land j = 1 \lor i = m \land j = n) \\
    -1,  & \text{if } i = k \land j = l \land \neg(i = 1 \land j = 1 \lor i = m \land j = n)
\end{cases}
\end{equation*}
$$
是不是看起来很复杂？实际上也就只是 $\LaTeX$ 输起来复杂。如果懒得看以上形式，直接看代码就行。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[60][60];
int dp[60][60][60][60];
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int m, n;
	cin >> m >> n;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= m; k++) {
				for (int l = 1; l <= n; l++) {
					dp[i][j][k][l] = max(dp[i - 1][j][k - 1][l], dp[i - 1][j][k][l - 1]);
					dp[i][j][k][l] = max(dp[i][j - 1][k - 1][l], max(dp[i][j][k][l], dp[i][j - 1][k][l - 1]));
					dp[i][j][k][l] += a[i][j] + a[k][l];
					if (i == k && j == l && !(i == 1 && j == 1 || i == m && j == n)) {
						dp[i][j][k][l] = -114514;
					}
				}
			}
		}
	}
	cout << dp[m][n][m][n];
	return 0;
}
```

---

## 作者：Azuree (赞：6)

一道非常典型的区间dp  
题目要求是从小渊到小轩再回到小渊，那么我们不妨从小渊开始求两条不重合的去小轩的路径。  
![](https://cdn.luogu.com.cn/upload/pic/71670.png)  
如图，当我们找到了一条路径后，那么这张图就被分成了两部分，我们的另一条路径只可能存在于其中的一部分中，像这样：  
![](https://cdn.luogu.com.cn/upload/pic/71674.png)  
我们可以用$f[x_1][y_1][x_2][y_2]$表示两次传递分别到$(x_1,y_1)$和$(x_2,y_2)$是能够获得的最大好感度。 
但是，这个数组的维度太高了，所以我们要对他降维。  
怎么降维呢？  
~~扔一个三向箔~~  
我们可以发现，每当我们走一步，那么x坐标和y坐标之间总会有一个数加$1$。所以，我们可以用k来表示x坐标和y坐标的和，从而通过y坐标来计算出x坐标。由于k对于两条同时处理的路径可以是公共的，所以我们可以用$f[k][y_1][y_2]$来表示当前状态。  
于是，我们就可以得到一个状态转移方程了：  
$$f[k][i][j]=max(f[k-1][i][j],f[k-1][i-1][j]f[k-1][i][j-1]f[k-1][i-1][j-1])+map[k-i+1][i]+map[k-j+1][j]$$  
我们可以来看一下我们到底是通过哪些状态转移到当前状态的：  
![](https://cdn.luogu.com.cn/upload/pic/71682.png)  
code:  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register
#define qwq printf("qwq\n");

using namespace std;

int read()
{
	register int x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,m,map[205][205],f[205][205][205]; 

int cmp(int a,int b,int c,int d)
{
	a = max(a,b);
	c = max(c,d);
	return max(a,c);
}

int main()
{
	m = read(); n = read();
	for(int i = 1; i <= m; i++)
		for(int j = 1; j <= n; j++)
			map[i][j] = read();
	for(int k = 1; k <= m + n; k++)
		for(int i = 1; i <= min(k,n); i++)
			for(int j = i + 1; j <= min(k,n); j++)
				f[k][i][j] = cmp(f[k - 1][i][j],f[k - 1][i - 1][j],f[k - 1][i][j - 1],f[k - 1][i - 1][j - 1]) + map[k - i + 1][i] + map[k - j + 1][j];
	f[n + m][n][n] = max(f[n + m - 1][n][n - 1],f[n + m - 1][n - 1][n]);
	printf("%d\n",f[n + m][n][n]);
    return 0;
}
```

---

## 作者：ClV_Csy (赞：3)

# P1006 [NOIP2008 提高组] 传纸条
## 前言
双倍经验 [P1004 [NOIP2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)
## 题意
给定一个 $m \times n$ 的矩阵 $a$，要求从 $(1, 1)$ 到 $(m, n)$ 的**最大路径与次大路径之和**（只可往下或往右）。
## 思路
看到题面，马上可以想到 DP。观察数据范围，发现 $1 \le m, n \le 50$，考虑复杂度为 $O(n^4)$ 的 DP。  

我们先来做一做简化版的题面：  
给定一个 $m \times n$ 的矩阵 $a$，要求从 $(1, 1)$ 到 $(m, n)$ 的最大路径（只可往下或往右）。  
令 $f_{x, y}$ 表示**从 $(1, 1)$ 到 $(x, y)$ 的最大路径。**  
我们知道，对于每一个 $(i, j)$，它要么是从 $(i - 1, j)$（也就是左面）过来的，要么是从 $(i, j - 1)$（也就是上面）过来的。所以我们计算 $f_{i, j}$ 时，只需取 $f_{i - 1, j}$ 与 $f_{i, j - 1}$ 的最大值再加上 $a_{i, j}$ 即可。很容易推出状态转移方程：
$$f_{i, j} \gets max(f_{i - 1, j}, f_{i, j - 1}) + a_{i, j}$$
这就是简化版的做法了。

-----
令 $f_{x1, y1, x2, y2}$ 表示：  
**从 $(1, 1)$ 到 $(x1, y1)$ 的最大数之和与从 $(1, 1)$ 到 $(x2, y2)$ 的最大数之和的和。**  
接下来我们仿照简化版来推状态转移方程。对于每一个 $(i, j, k, t)$，它是从
- $(i - 1, j, k - 1, t)$
- $(i - 1, j, k, t - 1)$
- $(i, j - 1, k - 1, t)$
- $(i, j - 1, k, t - 1)$

中的一个点过来的。我们只需取这四个点中的最大值，再加上 $a_{i, j}$ 和 $a_{k, t}$ 即可。状态转移方程：
$$f_{i, j, k, t} \gets max(f_{i - 1, j, k - 1, t}, f_{i - 1, j, k, t - 1}, f_{i, j - 1, k - 1, t}, f_{i, j - 1, k, t - 1}) + a_{i, j} + a_{k, t}$$
**注意**，还有一个特例：  
当 $(i, j) = (k, t)$ 时，两点所处位置相同，所以我们在计算 $f_{i, j, k, t}$ 时需要减去 $a_{i, j}$（或 $a_{k, t}$）。
## 代码

```cpp
#include <iostream>
using namespace std;
int a[60][60];
int dp[60][60][60][60];
int main() {
	int m, n;
	cin >> m >> n;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= m; k++) {
				for (int t = 1; t <= n; t++) {
					int maxn1 = max(dp[i - 1][j][k - 1][t], dp[i - 1][j][k][t - 1]);
					int maxn2 = max(dp[i][j - 1][k - 1][t], dp[i][j - 1][k][t - 1]);
					int maxn = max(maxn1, maxn2);
					dp[i][j][k][t] = maxn + a[i][j] + a[k][t];
					if (i == k && j == t) {
						dp[i][j][k][t] -= a[i][j];
					}
				}
			}
		}
	}
	cout << dp[m][n][m][n];
	return 0;
}
```

---

## 作者：Tomwsc (赞：2)

# P1006 [NOIP 2008 提高组] 传纸条 题解

[Myblog](https://blog.csdn.net/Popandsoss2022/article/details/145492921?sharetype=blogdetail&sharerId=145492921&sharerefer=PC&sharesource=Popandsoss2022&spm=1011.2480.3001.8118)

本人习惯先 $n$ 后 $m$，所以下面的 $n$ 和 $m$ 均与题目相反。

## 题意

找出两条从 $(1,1)$ 到 $(n,m)$ 的路径，使这两条路径之和最大。

## 思路

考虑 dp。

设 $dp_{i,j,p,q}$ 表示第一条路径走到 $(i,j)$，第二条路径走到 $(p,q)$ 的最大值。

接下来我们推方程：

不难发现 $(i,j)$ 可以从 $(i-1,j)$ 和 $(i,j-1)$ 转移而来，而 $(p,q)$ 可以从 $(p-1,q)$ 和 $(p,q-1)$ 转移而来。同时，因为是两条路径同时计算，所以转移时还要加上 $a_{i,j}$ 和 $a_{p,q}$。

于是得到转移方程：

$$dp_{i,j,p,q}=\max(dp_{i-1,j,p-1,q},dp_{i-1,j,p,q-1},dp_{i,j-1,p-1,q},dp_{i,j-1,p,q-1})+a_{i,j}+a_{p,q}$$

注意到为了使这两条路径不相交，我们还需要改变一下枚举方式。可以让第一条路径只在矩阵的上半部分转移，而剩下的部分便让第二条路径进行转移。于是得到 $i$，$j$，$p$，$q$ 这 $4$ 个变量的枚举方式：

$i$，$j$ 不变，$p$ 从 $i+1$ 开始枚举，$q$ 一直枚举到 $j-1$。（还是比较容易理解的）

最后，因为这样子 dp 不会相交，所以两条路径不会到达 $(n,m)$。但因为 $a_{n,m}=0$，所以最后答案也就可以转化为：$dp_{n-1,m,n,m-1}$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 1ll << 62
using namespace std;
const int MAXN = 55;
int n , m;
int a[MAXN][MAXN];
int dp[MAXN][MAXN][MAXN][MAXN];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(register int i = 1;i <= n;i ++)
		for(register int j = 1;j <= m;j ++)
			cin >> a[i][j];
	for(register int i = 1;i <= n;i ++)
		for(register int j = 1;j <= m;j ++)
			for(register int p = i + 1;p <= n;p ++)
				for(register int q = 1;q < j;q ++)
					dp[i][j][p][q] = max(dp[i - 1][j][p - 1][q] , max(dp[i - 1][j][p][q - 1] , max(dp[i][j - 1][p - 1][q] , dp[i][j - 1][p][q - 1]))) + a[i][j] + a[p][q];
	cout << dp[n - 1][m][n][m - 1] << '\n';
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

可以把问题转化成找两条从 $(1,1)$ 到 $(m,n)$ 的路径，使这两条路径的好感度和最大，这就是经典的[取两遍方格取数](https://www.luogu.com.cn/problem/P1004)。

先考虑只取一遍的方格取数，设 $f_{i, j}$ 表示以 $(i, j)$ 为结尾的路径的最大和，$a_{i, j}$ 表示格子 $(i, j)$ 的数字。转移是 $f_{i, j}=\max(f_{i-1, j}, f_{i, j-1})+a_{i, j}$。

那么取两遍就多设两维好了，即设 $f_{i, j, k, l}$ 表示第一条路径以 $(i, j)$ 结尾，第二条路径以 $(k, l)$ 结尾的两条路径的最大和，转移的话就相当于两条路径分别转移，即 $f_{i, j, k, l}=\max(f_{i-1, j, k-1, l}, f_{i, j-1, k-1, l}, f_{i-1, j, k, l-1}, f_{i, j-1, k, l-1})+a_{i, j}+a_{k, l}$。

但略有不同，本题要求两条路径不能经过同一个同学，即不能相交，那么两条路径一定是一条在上一条在下，如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/yov9gz8w.png)

所以我们直接转移是不对的，若我们没有限制先枚举红色路径，当前红色路径结尾是 $(x_1, y_1)$，因为黄色路径在红的左下方，所以对于黄色路径结尾 $(x_2, y_2)$，应从 $x_1$ 到 $m$ 枚举 $x_2$，从 $1$ 到 $y_1$ 枚举 $y_2$，转移仍是 $f_{x_1, y_1, x_2, y_2}=\max(f_{x_1-1, y_1, x_2-1, y_2}, f_{x_1-1, y_1, x_2, y_2-1}, f_{x_1, y_1-1, x_2-1, y_2}, f_{x_1, y_1-1, x_2, y_2-1})+a_{x_1, y_1}+a_{x_2, y_2}$。注意特判掉 $x_1=x_2$ 且 $y_1=y_2$ 的情况。

如图红色路径是从上面到 $(m,n)$ 的，黄色是从左面到 $(m,n)$ 的，所以答案是 $f_{m-1, n, m, n-1}$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n, a[55][55], f[55][55][55][55];
int main () {
	cin >> m >> n;
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
			cin >> a[i][j];
	for (int x1=1; x1<=m; x1++)
		for (int y1=1; y1<=n; y1++)
			for (int x2=x1; x2<=m; x2++)
				for (int y2=1; y2<=y1; y2++) 
					if (x1!=x2||y1!=y2) 
						f[x1][y1][x2][y2]=max({f[x1-1][y1][x2-1][y2], 
											f[x1-1][y1][x2][y2-1], 
											f[x1][y1-1][x2-1][y2], 
											f[x1][y1-1][x2][y2-1]})
											+a[x1][y1]+a[x2][y2];
	cout << f[m-1][n][m][n-1];
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：2)

可以费用流，但是疑惑的是题解区没有费用流。

我们发现，这要找两条路去传纸条，而每个人有个好心程度且只能传一次。

于是很容易设计费用流，对于每个点流量为 $1$，费用为那个点的好心程度。

每个边流量为 $1$，费用为 $0$。

跑最大费用最大流，设 $s$ 为起点，$t$ 为终点。

因为小渊传完后需要回传，所以 $s=t$，但是这样 $s=t$ 就直接死循环了。

并且在费用流中，点，是不能有流量和费用的。

那咋办，我们化点为边。

可以这样，把点拆成一个入点和一个出点。

入点指向出点的边流量和费用就是我们之前讨论的那个点的。

每个那个点的入点都指向它的入边，出边同样。

我们 $s$ 设为小渊的出点，$t$ 为小渊的入点，也能避免死循环的问题。

跑最大费用最大流刚好满足题意。

代码。

```cpp
//Dinic 算法  
#include<bits/stdc++.h>
using namespace std;
// #define int long long
int n,m,s,t;
int head[80010],to[240010],nxt[240010],val[240010],cost[240010],tot=1;
void add(int u,int v,int w,int c){
	to[++tot]=v,val[tot]=w,cost[tot]=c;
	nxt[tot]=head[u];
	head[u]=tot;
}
int maxflow,maxcost,dis[80010],now[80010],cnt[80010];
bool vis[80010];
bool spfa(){
	list<int>q;
	memset(dis,-0x3f,sizeof dis);
	memset(vis,0,sizeof vis);
	vis[s]=dis[s]=0,now[s]=head[s];
	q.push_back(s);
	while(!q.empty()){
		int u=q.front();
		q.pop_front();
		vis[u]=0;
		for(int i=head[u];i;i=nxt[i]){
			now[to[i]]=head[to[i]];
			if(!val[i]) continue;
			if(dis[to[i]]<dis[u]+cost[i]){
				dis[to[i]]=dis[u]+cost[i];
				cnt[to[i]]=cnt[u]+1;
				if(vis[to[i]]) continue;
				vis[to[i]]=1;
				if(dis[to[i]]<dis[q.empty() ? 0 :q.front()]) q.push_front(to[i]);
				else q.push_back(to[i]);
			}
		}
	}
	memset(vis,0,sizeof vis);
	return dis[t]>dis[0]/2;
}
int dinic(int x,int flow){
	vis[x]=1;
	if(x==t) return flow;
	int rest=flow;
	for(int i=now[x];i && rest;i=nxt[i]){
		now[x]=i;
		if(dis[to[i]]!=dis[x]+cost[i] || !val[i] || vis[to[i]]) continue;
		int v=dinic(to[i],min(rest,val[i]));
		if(!v) dis[to[i]]=dis[0];
		val[i]-=v,val[i^1]+=v,maxcost+=cost[i]*v;
		rest-=v;
	}
	return flow-rest;
}
namespace Input{
	int a[210][210];
	void main() {
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j];
	}
}
int get(int x,int y,int k){
	return (x-1)*m+y+k*n*m;
}
signed main() {
	ios::sync_with_stdio(0);
	cin>>n>>m;
	s=n*m+1,t=n*m;
	Input::main();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			add(get(i,j,0),get(i,j,1),1,Input::a[i][j]),add(get(i,j,1),get(i,j,0),0,-Input::a[i][j]);
			if(i<n) add(get(i,j,1),get(i+1,j,0),1,0),add(get(i+1,j,0),get(i,j,1),0,0);
			if(j<m) add(get(i,j,1),get(i,j+1,0),1,0),add(get(i,j+1,0),get(i,j,1),0,0);
		}
	}
	int flow=0;
	while(spfa()) while(flow=dinic(s,1e18)) maxflow+=flow;
	cout<<maxcost;
	return 0;
}
```
此代码能过 ouuan 的[大教室中传纸条](https://www.luogu.com.cn/problem/T35377)。

---

## 作者：Eric1030 (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P1006)

可在专栏中[查看](https://www.luogu.com.cn/article/azucwtrs)。

这是一道运用到了**动态规划**的题。

首先我们先来看一下样例，下面是示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/3pg0gzym.png)

注：红色线表示纸条从小轩传到小渊的路径，橙色线表示纸条从小渊传到小轩的路径。

那么最后的结果就是 $34$。

如果我们用二维 DP，经过思考我们就会发现，这种方法不成立，所以我们就要用多维 DP 了。

我们希望两条路径都不重复，那么我们就可以看成有两条路径从 $(m,n)$ 点出发，每一个时间单位走 $1$ 个点，我们只要找到一条路，使得 $2$ 条路经在相同时间内走的点不重复就可以了。

我们除了统计走的步数，还要统计当前这条路的末尾位置。

现在状态就出来了，那就是 $f[i][x_1][x_2]$ 表示两条路径的长度均为 $i$，第一条路末尾在 $x_1$ 行，第二条路末尾在 $x_2$ 行，经过的权值之和的最大值。

我们再来看一下状态转移方程。
$$f[i][x_1][x_2]\gets max(f[i-1][x_1][x_2],f[i-1][x_1-1][x_2],f[i-1][x_1][x_2-1],f[i-1][x_1-1][x_2-1])+a[i-x_1][x_1]+a[i-x_2][x2]$$

我们还要特判一下，如果 $x_1$ 和 $x_2$ 相等，就说明走的 $2$ 条路有个点重合了，就进行下一次循环。

我们再说一下边界和初始化。
我们要把 $f$ 数组全部设为 $-1$，然后把 $f[2][1][1]$ 设成 $0$。

最后就是答案了。
$$f[n+m-1][n-1][n]$$

## [AC](https://www.luogu.com.cn/record/201522048) 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[105][105], f[205][105][105], cm[5];//数组开大点，不然会RE
int main()
{
	//输入数据
	cin >> m >> n;
	for (int i = 1;i <= m;i++)
	{
		for (int j = 1;j <= n;j++)
		{
			cin >> a[i][j];
		}
	}
	memset(f, -1, sizeof(f));
	f[2][1][1] = 0;
	for (int i = 3;i <= n + m - 1;i++)//枚举路径长度i
	{
		for (int j = 1;j <= n - 1;j++)//枚举x1
		{
			for (int k = j + 1;k <= n;k++)//枚举x2
			{
				cm[1] = f[i - 1][j][k];
				cm[2] = f[i - 1][j - 1][k];
				cm[3] = f[i - 1][j][k - 1];
				cm[4] = f[i - 1][j - 1][k - 1];
				sort(cm + 1, cm + 1 + 4, greater<int>());//求4种情况的最大值
				if (cm[1] == -1)//如果到不了那个点
				{
					continue;
				}
				f[i][j][k] = cm[1] + a[i - j][j] + a[i - k][k];//把最大值加上第i步第一条路径所在格子权值和第i步第二条路径所在格子权值
			}
		}
	}
	cout << f[n + m - 1][n - 1][n];//输出答案
	return 0;//结束！
}
```

说明：此题解中有部分内容借鉴了聪明王必胜的题解。

---

## 作者：GLr137 (赞：1)

**[P1006 [NOIP 2008 提高组] 传纸条](https://www.luogu.com.cn/problem/P1006) 题解**

[专享版阅读体验](https://www.luogu.com.cn/article/fgs6qdxh)

### 题意简述

一个 $ m $ 行 $ n $ 列的长方形教室，从左上角出发，到右下角，只能向右或向下；再从右下角出发，到左上角，只能向左或向上。走到哪就可以得到哪个位置的数字，第一次和第二次不能得到同一个位置的数字。求两次得到的最大值。

### 思路详解

这道题我们可以转换一下，从右下角往左上角走事实上是等价于从左上角往右下角走的，只是不能得到同一个位置的数字，所以，这题和 [P1004 [NOIP 2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004) 就很像了。

首先我们遍历第一次的横纵坐标和第二次的横纵坐标，在循环中，我们可以令 DP 数组每一项的值为 $ \max(dp_{i - 1, j, k - 1, l}, dp_{i - 1, j, k, l - 1}, dp_{i, j - 1, k - 1, l}, dp_{i, j - 1, k, l - 1}) + g_{i, j} + g_{k, l}$，其中 $ g $ 数组为输入的长方形教室。

为什么这么做？因为我们可以想到，两个点是由两个路径转过来的，每个点可以是左边或上边的状态转移过来，那两个点就要求出四种情况的最大值，再加上方格图上两个点的值。这里我们发现会有一种两个点的位置相同的情况，所以这种情况我们只能加一次。

### Code

```cpp
# include <iostream>
using namespace std;
int n, m, sz[55][55], dp[55][55][55][55];
int main (){
    cin >> n >> m;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            cin >> sz[i][j];
        }
    }
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            for (int k = 1; k <= n; k++){
                for (int l = 1; l <= m; l++){
                    dp[i][j][k][l] = max(max(dp[i - 1][j][k - 1][l], dp[i - 1][j][k][l - 1]), max(dp[i][j - 1][k][l - 1], dp[i][j - 1][k - 1][l])) + sz[i][j];
                    if (i != k && j != l){
                        dp[i][j][k][l] += sz[k][l];
                    }
                }
            }
        }
    }
    cout << dp[n][m][n][m];
    return 0;
}
```

[记录](https://www.luogu.com.cn/record/201281225)

---

## 作者：OIerror (赞：1)

[传送门](https://www.luogu.com.cn/problem/P1006)
## 思路
首先，我们发现这是一个明显的决策问题，具体为，我从哪里来？要到哪里去？

为了美妙的拓扑序，我们可以对原问题进行转化，变成从小渊到小轩传两次纸条（路径上贡献只能加一次）。

显然，我们不能直接跑两遍动规。因此我们可以设 $f_{i,j,x,y}$ 表示第一遍走到 $(i,j)$，第二遍走到 $(x,y)$ 所得到的最优解。

转移方程：
$$
f_{i,j,x,y}=\max(f_{i-1,j,x-1,y},f_{i-1,j,x,y-1,},f_{i,j-1,x-1,y},f_{i,j-1,x,y-1})+\begin{cases}a_{i,j} & (i,j)=(x,y) \\a_{i,j}+a_{x,y} & (i,j)\ne(x,y)\end{cases}
$$

$f_{i-1,j,x-1,y}$ 表示第一遍上一步在 $(i-1,j)$，第二遍上一步在 $(x-1,y)$ 所得最大贡献。

其余同理。

答案即为 $f_{m,n,m,n}$。
## AC Code
```
#include<cstdio>
using namespace std;
int dp[101][101][101][101];
int a[101][101];
int max(int a,int b)
{
	return a>b?a:b;
}
int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int x=1;x<=m;x++)
			{
				for(int y=1;y<=n;y++)
				{
					dp[i][j][x][y]=max(max(dp[i-1][j][x-1][y],dp[i-1][j][x][y-1]),max(dp[i][j-1][x-1][y],dp[i][j-1][x][y-1]));
					if(i==x&&j==y)
					{
						dp[i][j][x][y]+=a[i][j];
					}
					else
					{
						dp[i][j][x][y]+=a[i][j]+a[x][y];
					}
				}
			}
		}
	}
	printf("%d",dp[m][n][m][n]);
	return 0;
}
```

---

## 作者：iamajcer (赞：1)

# 思路

显然可以转换题意，转换为从起点分别走两条不重复路径到达终点。其中只能向下，向右走。

那么显然有两种思路，一种两条路径分别走，还有一种是两条路径同时走。分别对应二维 dp，四维 dp。

但是不能两条路径分别走，只能考虑两条路径同时走，样例就可以解释了。两条路径分别走只是两次局部最优解，而不能保证全局最优解。

一个显然的优化，因为同时走，所以我们直接记录一维步数，具体如下：

那么我们定 $f(k, i1, i2)$ 表示从 $(1, 1)$ 走到 $(i1, k-i1)$ 和 $(1, 1)$ 走到 $(i2, k-i2)$。

转移就很显然了，对于每个点都可以从上面，从左边转移过来，两个点就是四种情况，分别讨论一下就好，记得判断不能走重复点。

具体见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=200, M=405;

int n, m, a[N][N], f[M][N][N];
int main() 
{
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++) scanf("%d", &a[i][j]);
	
	for (int k=2; k<=n+m; k++)
		for (int i1=1; i1<=n; i1++)
			for (int i2=1; i2<=n; i2++)
			{
				int j1=k-i1, j2=k-i2;
				if (j1>=1 && j1<=m && j2>=1 && j2<=m)
				{
					int w=a[i1][j1];
					if (i1!=i2) w+=a[i2][j2];
					
					f[k][i1][i2]=max(f[k][i1][i2], f[k-1][i1-1][i2]+w);
					f[k][i1][i2]=max(f[k][i1][i2], f[k-1][i1-1][i2-1]+w);
					f[k][i1][i2]=max(f[k][i1][i2], f[k-1][i1][i2]+w);
					f[k][i1][i2]=max(f[k][i1][i2], f[k-1][i1][i2-1]+w);
				}
			}
	
	printf("%d", f[n+m][n][n]);
	return 0;
}
```

---

## 作者：wurang (赞：0)

这题求从起点到终点两条不相交的路径最大权值，我们可以设计 ${dp}$ 数组 ${dp_{i,j,k,t}}$ 表示第一条路径走到位置 ${i,j}$ 同时第二条路径走到位置 ${k,t}$ 的最大价值。

为保证两条路径不相交，我们只转移 ${k>i,t<j}$ 的情况。

由于有两个点，所以有四个转移方程：

$$
{i-1,j,k-1,t \rightarrow i,j,k,t}
$$

$$
{i-1,j,k,t-1 \rightarrow i,j,k,t}
$$

$$
{i,j-1,k-1,t \rightarrow i,j,k,t}
$$

$$
{i,j-1,k,t-1 \rightarrow i,j,k,t}
$$

因此我们可以得出四维解法：

```cpp
#include<bits/stdc++。h>
using namespace std;

int n,m;
int ans;
int v[55][55];
int dp[55][55][55][55];

int main()
{
	cin >> n >> m;
    for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			cin >> v[i][j];
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			for(int k = i+1; k <= n; k++)
			{
				for(int t = 1; t < j; t++)
				{
					dp[i][j][k][t] = max(dp[i][j][k][t],dp[i-1][j][k-1][t]);
					dp[i][j][k][t] = max(dp[i][j][k][t],dp[i-1][j][k][t-1]);
					dp[i][j][k][t] = max(dp[i][j][k][t],dp[i][j-1][k][t-1]);
					dp[i][j][k][t] = max(dp[i][j][k][t],dp[i][j-1][k-1][t]);
					dp[i][j][k][t] += v[i][j] + v[k][t];
				}
			}
		}
	}
	cout << dp[n-1][m][n][m-1];
    return 0;
}
```

考虑优化：

由于每次选择时都向右走或向下走，所以对于第一条路径上的点，都会对应另一条路径上的一个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/nm7ux4l8.png)

所以只需考虑 ${i+j = k+t}$ 的情况，那么 ${dp}$ 数组可以降一维，变成三维。

```cpp
#include<bits/stdc++。h> //AC
using namespace std;

int n,m;
int ans;
int v[55][55];
int dp[55][55][55];

int main()
{
	cin >> n >> m;
    for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			cin >> v[i][j];
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			for(int k = i+1; k <= n; k++)
			{
				int t = i+j-k;
				if(t<=0||t>j)continue;//要特殊处理超出边界的情况
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]);
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k]);
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k]);
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]);
				dp[i][j][k] += v[i][j] + v[k][t];
			}
		}
	}
	cout << dp[n-1][m][n];
    return 0;
}
```

---


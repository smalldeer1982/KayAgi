# [NOIP 2003 普及组] 数字游戏

## 题目描述

丁丁最近沉迷于一个数字游戏之中。这个游戏看似简单，但丁丁在研究了许多天之后却发觉原来在简单的规则下想要赢得这个游戏并不那么容易。游戏是这样的，在你面前有一圈整数（一共 $n$ 个），你要按顺序将其分为 $m$ 个部分，各部分内的数字相加，相加所得的 $m$ 个结果对 $10$ 取模后再相乘，最终得到一个数 $k$。游戏的要求是使你所得的 $k$ 最大或者最小。


例如，对于下面这圈数字（$n=4$，$m=2$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/gy407k49.png)

要求最小值时，$((2-1)\bmod10)\times ((4+3)\bmod10)=1\times 7=7$，要求最大值时，为 $((2+4+3)\bmod10)\times (-1\bmod10)=9\times 9=81$。特别值得注意的是，无论是负数还是正数，对 $10$ 取模的结果均为非负值。

丁丁请你编写程序帮他赢得这个游戏。


## 说明/提示

**【题目来源】**

NOIP 2003 普及组第二题

## 样例 #1

### 输入

```
4 2
4
3
-1
2
```

### 输出

```
7
81
```

# 题解

## 作者：dingcx (赞：1495)

~~普及组第二题竟然是绿题，蒟蒻的我瑟瑟发抖~~

# 思路
该死的DP太难打了，于是我选择直接暴力枚举DFS。
## 主函数
首先，为了枚举环的起点，需要破环为链，开一个2倍空间的数组记录。

枚举起点时，先dfs，再把**整个数组往前挪一位**，这样就不用管开始位置的问题了。

最后输出答案。
## 求模10的余数
这个函数有一个细节：如果原数为负数，则%10之后**还是负数**。（如(-11)%10=-1）

解决方法：先%10（保证不会小于-10），再+10（变成正数），最后%10（正数+10>10）。
## DFS
1.参数：depth深度；now当前位置；value当前的积

2.结束条件：depth==m

3.满足结束条件时：{

    1)算出剩余数的和，并与value相乘
    
    2)与两个答案作比较
    
}

4.下一步深搜：{
    
    1)从now遍历到n-m+depth（再往后就取不到了）
    
    2)用变量sum记录a数组从now开始的前缀和（就是从a[now]一直加到a[i]的和）
    
    3)进行下一步深搜，注意now是i+1
    
}

5.（最重要的）**剪枝**：当value>=最小答案且value*$9^{m-depth+1}$<=最大答案时，就可以剪枝。如果不剪枝，第4个测试点就需要**约1000秒的时间**（本人亲身经历）
# 代码
~~我相信没几个人会喜欢上面的一通分析的吧~~，那么，你们喜欢的代码来了——
```cpp
#include<cstdio>
#include<algorithm>//算法库，有max和min
using namespace std;
const int MAXN=110;
const int INF=0x3f3f3f3f;//定义成2e9或2147483647也行
const int n9[9]={9,81,729,6561,59409,531441,4782969,43046721,387420489};//m<=9，打个表就好了
int n,m;
int a[MAXN];
int ansmin=INF,ansmax=0;//最小和最大，都要初始化
int mod10(int x){//计算模10的函数
	return (x%10+10)%10;
}
void dfs(int depth,int now,int value){//重磅dfs
	if(value>=ansmin&&value*n9[m-depth]<=ansmax) return;//剪枝
	int sum=0;
	if(depth==m){
		for(int i=now;i<=n;i++) sum+=a[i];//计算和
		ansmin=min(ansmin,value*mod10(sum));//比较
		ansmax=max(ansmax,value*mod10(sum));
		return;
	}
	for(int i=now;i<=(n-m+depth);i++){//遍历下一个点
		sum+=a[i];//前缀和
		dfs(depth+1,i+1,value*mod10(sum));//下一步计算
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		a[i+n]=a[i];//破环成链
	}
	for(int i=1;i<=n;i++){//枚举初始点
		dfs(1,1,1);//都是1，只是巧合
		for(int j=1;j<=2*n;j++) a[j]=a[j+1];//往前挪
	}
	printf("%d\n%d\n",ansmin,ansmax);//输出
	return 0;//华丽结束
}
```
不要复制完代码就走了啊，这样是不道德的，思路也是要看的，对了，别忘了要点个赞！

---

## 作者：租酥雨 (赞：275)

总结一下这种类似DP题目的思路和技巧吧。

1、破环成链。没有太多的技巧性，具体而言就是把数据存储两遍，使得环形的数据可以链式展开，便于我们去DP。

但最后一定要记得扫一遍答案，取F[i][i+N-1]，i：1->N中的最大/小值。

2、前缀和。这个东西并不是在所有情况下都适用，但使用起来真的很方便，可以把O(n)的复杂度优化为O(1)。不过只适用于需要把数据直接相加的地方，比如说这道题。

3、初始化。这里实际上包括两点，一方面是在某些特殊情况下需要初始化，初始化为某特定值（比如本题只分成1段的时候）。另一方面也就是数组初始化，求最大值的时候根本不用管（因为初始默认为0），在求最小值的时候把数组全部赋初值为极大值就好啦。

4、状态表达。一般来说可以用F[i][j]表示在区间[i,j]中怎么怎么样，但由于本题还加了一个分为几段的状态，就把数组直接加一维就好了。


上代码



    
       
    
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define oo 2147483647//是个好习惯，使程序显得有条理一点 
using namespace std;
int B[101][101][11],S[101][101][11];//区间[l,r]内分成i段的最大/小值 
int n,m; 
int a[101];//a存放前缀和 
int mod(int a)//写成函数方便一点 
{
    return ((a%10)+10)%10;
}
int main()
{
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        a[i+n]=a[i];
    }
    for (int i=1;i<=2*n;i++)
      a[i]+=a[i-1];//前缀和 
    for (int l=1;l<=2*n;l++)
      for (int r=l;r<=2*n;r++)
        B[l][r][1]=S[l][r][1]=mod(a[r]-a[l-1]);//初始化不分段的状态 
    for (int i=2;i<=m;i++)
      for (int l=1;l<=2*n;l++)
        for (int r=l+i-1;r<=2*n;r++)
          S[l][r][i]=oo;//求最小值时记得把数组初始化为极大值 
    for (int i=2;i<=m;i++)//枚举分段数 
      for (int l=1;l<=2*n;l++)//枚举左端点 
        for (int r=l+i-1;r<=2*n;r++)//枚举右端点 
        {
            for (int k=l+i-2;k<r;k++)//枚举区间断点 注意范围 
            {
                S[l][r][i]=min (S[l][r][i],S[l][k][i-1]*mod(a[r]-a[k]));
                B[l][r][i]=max (B[l][r][i],B[l][k][i-1]*mod(a[r]-a[k]));
          }
        }
    int Max=0,Min=oo;//答案初始化 
    for (int i=1;i<=n;i++)
    {
        Max=max(Max,B[i][i+n-1][m]);//从前往后扫一遍 
        Min=min(Min,S[i][i+n-1][m]);
    }
    printf("%d\n%d",Min,Max);
    return 0;
}
```

---

## 作者：ykuouzf (赞：149)

#### 鄙人翻遍题解库，却没看到一篇写得详细些的区间DP题解，对于我这种蒟蒻自然是看不懂。于是乎，本蒟蒻来写一篇详实的区间DP造（bao）福（fu）社会。

#### 首先，先来推一下区间DP的方程，假设它就是一个长度为n的队列（环的问题一会儿再讲）。

#### 区间DP简单说就是以某一段区间为状态，就是从小的区间开始算，用已经算好的小区间来推大区间，基本上的模型是f（i，j）（表示i~j区间的状态）=f（i，k）+f（k，j）（i~k区间和k~j区间的状态，k是分段的位置）。

#### 基本上区间DP分为三个循环，外两层从小枚举i，j的值，最后一个循环枚举分段的位置k。我们用f（i，j）来表示前i个数分j段所取得的最小分值，用d（i，j）表示最大分值。动态方程就是下面介样：

### f（i，j）=min（f（i，j），f（k，j-1）*sum（k+1，i））；

#### 其中的sum（i，j）表示从i到j的数之和。这就表示前k个数分j-1段和k+1到i这段数的乘积与f（i，j）比较，d（i，j）只需要把min改成max就行了。

#### 由于数的数量只有大于分段数量才能切，所以i>j。而分段的位置只能在这几个数中间，所以k<i。这样枚举的范围就出来了。

#### 注意，因为在循环的时候是需要用到f（k，j-1）的，这就意味着需要先处理出f（j-1）时的值，所以要把j放到最外一层循环，从小往大枚举。

#### 循环也就很好写了：

```
for(re int i=1;i<=n;i++) f[i][0]=d[i][0]=sum[1][i];
//在分段次数为0时，前i个数的最小（最大）值就是它们的和
for(re int j=1;j<=m;j++)
	for(re int i=j+1;i<=n;i++)
		for(re int k=1;k<i;k++)
		{
			f[i][j]=std::min(f[i][j],f[k][j-1]*sum[k+1][i]);
			d[i][j]=std::max(d[i][j],d[k][j-1]*sum[k+1][i]);
		}
```

#### 接下来回到环的问题上。对于环，有两种解决方法，以样例为例。

#### 第一种方法就是枚举所有的排列，改一遍跑一遍：

#### 一：4 3 -1 2

#### 二：2 4 3 -1

#### 三：-1 2 4 3

#### 四：3 -1 2 4

#### 第二种方法更高效（鄙人认为），数组存两倍，然后枚举下标：

#### 一：| 4 3 -1 2 | 4 3 -1 2

#### 二：4 | 3 -1 2 4 | 3 -1 2

#### 三：4 3 | -1 2 4 3 | -1 2

#### 四：4 3 -1 | 2 4 3 -1 | 2

#### 两种方法都是可行的，代码也不难实现。

#### 接下来送上代码：

#### 第一种方法：

```
#include<bits/stdc++.h>
#define M 150
#define re register
#define li inline
int n,m,a[M],sum[M][M],f[M][M],d[M][M],minn=1e9,maxn;
li int read()
{
	re int f=1,j=0;
	re char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())j=(j<<1)+(j<<3)+c-48;
	return f*j;
}
li void write(re int x)
{
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
li void _chan()
{
	re int tmp=a[1];
	for(re int i=1;i<n;i++) a[i]=a[i+1];a[n]=tmp;
	for(re int i=1;i<=n;i++)
		for(re int j=i;j<=n;j++)
			sum[i][j]=sum[i][j-1]+a[j];
	for(re int i=1;i<=n;i++)
		for(re int j=i;j<=n;j++)
		{
			sum[i][j]%=10;
			if(sum[i][j]<0)sum[i][j]+=10;
		}
	return ;
}
li void _dp()
{
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++)
			f[i][j]=1e8,d[i][j]=0;
	for(re int i=1;i<=n;i++) f[i][0]=d[i][0]=sum[1][i];
	for(re int j=1;j<=m;j++)
		for(re int i=j+1;i<=n;i++)
			for(re int k=1;k<i;k++)
			{
				f[i][j]=std::min(f[i][j],f[k][j-1]*sum[k+1][i]);
				d[i][j]=std::max(d[i][j],d[k][j-1]*sum[k+1][i]);
				//std::cout<<d[i][j]<<" "<<d[k][j-1]<<" "<<sum[k+1][i]<<" "<<i<<" "<<j<<" "<<k<<std::endl;
			}
	maxn=std::max(maxn,d[n][m-1]); //由于实质上是分成m快，所以是切m-1刀
	minn=std::min(minn,f[n][m-1]);
	return ;
}
signed main()
{
	n=read(),m=read();
	for(re int i=1;i<=n;i++) a[i]=read();
	for(re int i=1;i<=n;i++)
	{
		_chan();
		_dp();
	}
	write(minn);
	putchar('\n');
	write(maxn);
	return 0;
}
```

#### 第二种方法：

```
#include<bits/stdc++.h>
#define M 150
#define re register
#define li inline
int n,m,a[M],sum[M][M],f[M][M],d[M][M],minn=1e9,maxn;
li int read()
{
	re int f=1,j=0;
	re char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())j=(j<<1)+(j<<3)+c-48;
	return f*j;
}
li void write(re int x)
{
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
li void _dp(re int p)
{
	for(re int i=1+p;i<=n+p;i++)
		for(re int j=i;j<=n+p;j++)
			sum[i][j]=sum[i][j-1]+a[j];
	for(re int i=1+p;i<=n+p;i++)
		for(re int j=i;j<=n+p;j++)
		{
			sum[i][j]%=10;
			if(sum[i][j]<0) sum[i][j]+=10;
		}
	for(re int i=1+p;i<=n+p;i++)
		for(re int j=1;j<=m;j++)
			f[i][j]=1e8,d[i][j]=0;
	for(re int i=1+p;i<=n+p;i++) f[i][0]=d[i][0]=sum[1+p][i];
	for(re int j=1;j<=m;j++)
		for(re int i=j+1+p;i<=n+p;i++)
			for(re int k=1+p;k<i;k++)
			{
				f[i][j]=std::min(f[i][j],f[k][j-1]*sum[k+1][i]);
				d[i][j]=std::max(d[i][j],d[k][j-1]*sum[k+1][i]);
				//std::cout<<d[i][j]<<" "<<d[k][j-1]<<" "<<sum[k+1][i]<<" "<<i<<" "<<j<<" "<<k<<std::endl;
			}
	maxn=std::max(maxn,d[n+p][m-1]); //由于实质上是分成m快，所以是切m-1刀
	minn=std::min(minn,f[n+p][m-1]);
	return ;
}
signed main()
{
	n=read(),m=read();
	for(re int i=1;i<=n;i++) a[i]=read(),a[i+n]=a[i];
	for(re int i=0;i<n;i++) _dp(i);
	write(minn);
	putchar('\n');
	write(maxn);
	return 0;
}
```

#### 讲的可能不太好，有什么问题可以在评论区给我留言哦。

## THE END.

---

## 作者：徐振羽 (赞：53)

一看到这道题，我感觉是个深搜

但我们看一数据大量，也就循环个5000亿次而已，于是果断放弃

我们决定用DP，不要问为什么，因为我们可以从几个已知数据得出未知数据

这里要注意了，因为题目中数字构成一个环，所以我们要先化环为链

我们看看我们怎样DP，我们需要一个三维数组f[i][j][l]，i和j表示我们取第i个数字到第j个数字，l表示我们将第i个数字到第j个数字分为l段（f存最大值）

我们明白了动态规划中数组的含义，就能较容易的推出动态规划转移方程了

我们用一个4重循环，第1,2重i,j表示第i个数字到第j个数字，l表示我们将第i个数字到第j个数字分为l段，k表示我们在i,j中取得中间值，将第i个数字到第j个数字拆成第i个数字到第k个数字和第k+1个数字到第j个数字。

明白了动态规划中数组的含义和动态规划转移方程，我们只需要进行一个初始化就行了，通过动态规划转移方程，我们发现无法推出f[i][j][1]，所以我们要做的就是在动归开始前，将全部f[i][j][1]赋值

至于f[i][j][1]的初始值怎么赋，就是枚举i,j，再将第i个数字到第j个数字全部加起 mod 10 就行了

### 代码附上

```
#include<iostream>
using namespace std;
long long a[1001],x[1001],n,m,max1,min1=1000000000000000;
//x为一开始读入的数据，a为便于计算一段之和的前缀和 
long long f[101][101][11],f1[101][101][11]; 
//f数组存最大值，f1数组存最小值 
int main(){
	cin>>n>>m;
	for (int i=1;i<=100;i++)
		for (int j=1;j<=100;j++)
			for (int k=1;k<=10;k++)
				f1[i][j][k]=10000000000;
	//先给f1数组赋上巨大的值，便于计算之和的最小值 
	for (int i=1;i<=n;i++)
	{
		cin>>x[i];//读入 
		a[i]+=a[i-1]+x[i];//前缀和 
	}
	//化环为链 
	for (int i=n+1;i<=n*2;i++) a[i]+=a[i-1]+x[i-n];//前缀和 
	for (int i=1;i<=n*2;i++)
		for (int j=1;j<=n*2;j++)
		{
			f[i][j][1]=(a[j]-a[i-1]+100000000000)%10;//前缀和求一段数的和 
			f1[i][j][1]=(a[j]-a[i-1]+100000000000)%10;//前缀和求一段数的和 
			//因为输入有负数，所以a[j]可能会小于a[i-1],所以我们给他加上巨大值 
		}
	//赋初始值	
	for (int i=1;i<=n*2;i++)//枚举开始的数字位置 
	{
		for (int j=i+1;j<=n*2;j++)//枚举结束的数字位置 
		{
			for (int l=2;l<=m;l++)//枚举分段的数量 
			{
				for (int k=i;k<j;k++)//枚举中间数的位置 
				{
					f[i][j][l]=max(f[i][j][l],f[i][k][l-1]*f[k+1][j][1]);//动态规划转移方程
					f1[i][j][l]=min(f1[i][j][l],f1[i][k][l-1]*f1[k+1][j][1]);//动态规划转移方程 
				}
			}
		}
	}
	for (int i=1;i<=n;i++) 
	{
		max1=max(max1,f[i][i+n-1][m]);//求一段的最大值 
		min1=min(min1,f1[i][i+n-1][m]);//求一段的最小值  
	}
	cout<<min1<<endl<<max1<<endl;//输出
	return 0; 
}
```


---

## 作者：Error_666 (赞：34)

我们先来分析题目：（~~帮你读题~~）
   1. 是个环
   	- 推出需要断环成链
   2. 分成m段，并且不满足贪心思路
   	- 算法可采用dp
   3. 数据范围n(1≤n≤50)和m(1≤m≤9)
   	- dp转移方程应该为二或三维

---

思考转移方程：  
- 先将环断成n条链，存储到一个数组中
- 我们需要用一个式子表示出所有的状态。因为是个环，我们用区间dp的思路试试：
	- dp[i][j][k][0]: 表示区间i - j被分成k个部分时的最小解  
    - dp[i][j][k][1]: 表示区间i - j被分成k个部分时的最大解  
- 仔细think一下发现这样是可以表达出所有状态的。至于转移，~~凭借我的多年刷题经验~~，先枚举断点，再枚举断点左边的区间被分成kk部分，则右边区间被分成k - kk部分。然后两区间相乘转移到新区间即可。  
- 我猜你看完上面那一段话，如果对dp不是很熟练的选手，可能已经懵了。
- 那么这篇题解就是给你提供一个新的思路，可能会更容易理解些

---

思考转移方程Again：
- dp1[i][j]: 表示前i个数字被分成j份的最小解
- dp2[i][j]: 表示前i个数字被分成j份的最大解
- （是不是很眼熟，没错，是2000TG真题T2）
- 那么这个转移方程就非常容易想了：
	- dp[i][j] = max(dp[k][j - 1] + sum[k + 1][i])
    - (j <= k <= i - 1)
    - sum[l][r]: 表示l-r区间的数字之和
- 解释一下这个转移：当前需要找前i个中分成j份的最x解，那么只需要从前1 - i-1个中找（已经分成j-1份的最x解*它后面的那一段数）的最x解

---

优化之处：
1. 将四维dp降到了三维，再通过开俩个数组可降到二维~~（并无卵）~~
2. 编程复杂度降低。由原四五个循环直接降到了三个循环
3. 思维的提升：将模型进一步转化

---

- 代码：
- 代码中一些小细节就写了点注释，~~我太懒了~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define maxn 55
using namespace std;

int n, k, ans1, ans2 = 0x7fffffff;
int c[maxn * 2], a[maxn], sum[maxn];
int dp[maxn][maxn];

int mod(int k) {
    return ((k % 10) + 10) % 10;
}

int main()
{
	freopen("P1043.in", "r", stdin);
	freopen("P1043.out", "w", stdout);
	
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        cin >> c[i];
        c[i + n] = c[i];//断环成链处理
    }
    
    for(int s = 1; s <= n; s++)
    {
        int t = 0;
        for(int i = s; i <= s + n - 1; i++)
        {
            a[++t] = c[i];//每次a数组获得断好的一条链
            sum[t] = sum[t - 1] + a[t];//前缀和
        }
        
        //dp[i][j] = dp[k][j - 1] * sum[k + 1][i] (j <= k <= i - 1)
        for(int i = 1; i <= n; i++) dp[i][1] = mod(sum[i]);
        for(int i = 1; i <= n; i++)
            for(int j = 2; j <= k && j <= i; j++)
                for(int k = j; k < i; k++)
                    dp[i][j] = max(dp[i][j], dp[k][j - 1] * mod(sum[i] - sum[k]));
        ans1 = max(ans1, dp[n][k]);
                
        memset(dp, 0x3f, sizeof(dp));
        for(int i = 1; i <= n; i++) dp[i][1] = mod(sum[i]);
        for(int i = 1; i <= n; i++)
            for(int j = 2; j <= k && j <= i; j++)
                for(int k = j; k < i; k++)
                    dp[i][j] = min(dp[i][j], dp[k][j - 1] * mod(sum[i] - sum[k]));
        ans2 = min(ans2, dp[n][k]);
    }
    
    cout << ans2 << endl << ans1;
    return 0;
}
```


至此，希望对你们有帮助。

---

## 作者：Develop (赞：22)

已经有了许多优秀的题解，我就来写个小优化

由一般的区间DP做法破环成链，可以得到第一个状态转移方程：

	fmax[ l ][ r ][ k ] = max( fmax[ l ][ r ][ k ] , fmax[ l ][ i ][ s ] * fmax[ i+1 ][ r ][ k - s ] )
    
    * 这个方程需要枚举将一个区间切成两段的切割点(即i)和两段分别所拥有的段数(即还需要切割的次数s和k-s)
    
再进一步，我们会发现段的切割是满足乘法结合律的：即最终结果与在段与段之间插入乘号(题目中要求将结果相乘)的位置有关，与插入的顺序无关，于是我们也可以理解为(不懂的请大家翻看其他的题解吧)，把一长段切成k段，相当于把一小段并上另外k小段，也可以得到最优解。这时我们就少了一重枚举两段分别拥有的段数(即s和k-s)的循环,优化极大，而加上后面的段数为1的子问题，我们又可以通过前缀和来优化：

	fmax[ l ][ r ][ k ] = max( fmax[ l ][ r ][ k ] , fmax[ l ][ i ][ s-1 ] * ( Sum[ r ] - Sum[ i ] ) )

	* Sum[ r ] - Sum[ i ]即i+1~r的前缀和
   
再观察一下状态转移方程中涉及的l(即左端点)一直是没有变过的，所以我们可以考虑把这一维给去掉，省掉大量空间:
	
    fmax[ r ][ k ] = max( fmax[ r ][ k ] , fmax[ i ][ s-1 ] * ( Sum[ r ] - Sum[ i ] ) )
    
	* 注意，这里把l省掉只是不存l的空间，在DP时还是要枚举l的
    
这个是第二个方程的代码
```cpp
#include <bits/stdc++.h>
#include <algorithm>
#define ll long long
#define Freopen(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
int mod(int x){return (((x%10)+10)%10);} 
using namespace std;
void init(),solve();
int n,m;
int num[200],qzh[200];
int fi[101][101][10],fa[101][101][11];
int Max=-1,Min=INT_MAX;
int main()
{
	init();
	solve();
	return 0;
}
void init()
{
//	Freopen(game)
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&num[i]),num[i+n]=num[i];
	for(int i=1;i<=n*2;i++)
		qzh[i]=qzh[i-1]+num[i];
	memset(fi,0x3f,sizeof fi);
	memset(fa,-1,sizeof fa);
	for(int i=1;i<=n*2;i++)
		for(int j=i;j<=n*2;j++)//
			fa[i][j][1]=fi[i][j][1]=mod(qzh[j]-qzh[i-1]);
	return;
}
void solve()
{//f[i][j][k]
	for(int k=2;k<=m;k++)//枚举段的个数 
  	  for(int i=1;i<=n;i++)//枚举左端点，相当于进行n次DP 	
		for(int j=i+k-1;j<=i+n-1;j++)//右端点 	
			//     p赋值为j的初值-1 
		  for(int p=i+k-2;p<j;p++)//枚举分成两段的位置 
			//右边的段不能为0 
			fa[i][j][k]=max(fa[i][j][k],fa[i][p][k-1]*mod(qzh[j]-qzh[p])),
			fi[i][j][k]=min(fi[i][j][k],fi[i][p][k-1]*mod(qzh[j]-qzh[p]));
	for(int i=1;i<=n;i++)
		Max=max(Max,fa[i][i+n-1][m]),
		Min=min(Min,fi[i][i+n-1][m]);
	printf("%d\n%d",Min,Max);
	return;
}
```
这是空间优化的代码，修改了一些转移顺序，可以参考
```cpp
#include <bits/stdc++.h>
#include <algorithm>
#define ll long long
#define Freopen(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
int mod(int x){return (((x%10)+10)%10);} 
using namespace std;
void init(),solve();
int n,m;
int num[200],qzh[200];
int fi[101][10],fa[101][11];
int Max=-1,Min=INT_MAX;
int main()
{
	init();
	solve();
	return 0;
}
void init()
{
//	Freopen(game)
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&num[i]),num[i+n]=num[i];
	for(int i=1;i<=n*2;i++)
		qzh[i]=qzh[i-1]+num[i];
	return;
}
void solve()
{
	for(int i=1;i<=n;i++)
  	{
  		memset(fi,0x3f,sizeof fi);
		memset(fa,-1,sizeof fa);
  		for(int j=i;j<=n*2;j++)
			fa[j][1]=fi[j][1]=mod(qzh[j]-qzh[i-1]);
  		for(int k=2;k<=m;k++)
		  for(int j=i+k-1;j<=i+n-1;j++)
			for(int p=i+k-2;p<j;p++)
				fa[j][k]=max(fa[j][k],fa[p][k-1]*mod(qzh[j]-qzh[p])),
				fi[j][k]=min(fi[j][k],fi[p][k-1]*mod(qzh[j]-qzh[p]));
		Max=max(Max,fa[i+n-1][m]),
		Min=min(Min,fi[i+n-1][m]);
	}
	printf("%d\n%d",Min,Max);
	return;
}
```



---

## 作者：Linne (赞：19)

为什么dalao们dp都开了好几维？蒟蒻瑟瑟发抖QAQ

------------

讲道理，感这题和区间dp真没啥关系。我第一眼看到这道题的时候，联想到的就是noip2000 TG T2乘积最大，大家可以参考一下那道题，然后你就会发现这题其实是很水的QWQ(话说，真的不是同一道题吗？)

------------

主要就是用资源分配dp的思想，用f[i][j]表示前i个数，中间切j次所得到的最大乘积，d[i][j]则是表示最小。转移方程怎么设计呢？很简单，f[i][j]=max{f[k][j-1]*num[k+1][i]}，其中num[k+1][i]表示从k+1个数到第i个数加起来膜膜膜的值，预处理一下即可。d[i][j]的转移也是同理。然后我们做n次破环为链，每次预处理+dp一下就可以搞好了QAQ


------------

附AC代码QUQ
```cpp
#include<bits/stdc++.h>
#define N 55
using namespace std;
typedef long long lint;
lint n,m,a[N],s[N],tmp[N],f[N][N],d[N][N],num[N][N],ans,ans2=INT_MAX;
lint mod(lint k){
	while(k<0)k+=10;
	return k%10; 
} 
void qzh(){
	for(int i=1;i<=n;++i){
		s[i]=s[i-1]+a[i];
	}
}
void zhihuan(){//破环为链 
	for(int i=1;i<=n;++i)tmp[i]=a[i];
	for(int i=2;i<=n;++i)a[i]=tmp[i-1];
	a[1]=tmp[n];
	qzh();
}
void pre(){//预处理 
	for(int l=1;l<=n;++l){
		for(int r=l;r<=n;++r){
			num[l][r]=s[r]-s[l-1];
			num[l][r]=mod(num[l][r]);
		}
	}
}
void do_dp(){
	pre();
	memset(f,0,sizeof(f));
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			d[i][j]=100000000;
            /*你可能会觉得这儿怪怪的，
            实际上是因为我最开始memset0x3f
            然后整个d数组就爆成了负数，
            改成了一个亿又非常玄学地好了QAQ */
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=0;j<m;++j){
			if(j==0){
				d[i][j]=f[i][j]=num[1][i];
			}
			else{
				for(int k=1;k<i;++k){
					f[i][j]=max(f[i][j],f[k][j-1]*num[k+1][i]);
				}
				for(int k=1;k<i;++k){
					d[i][j]=min(d[i][j],d[k][j-1]*num[k+1][i]);
				}
			}
		}
	}
	ans=max(ans,f[n][m-1]);
	ans2=min(ans2,d[n][m-1]);
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;++i){
    	cin>>a[i];
    	qzh();
	}
	do_dp();
	for(int i=1;i<n;++i){
		zhihuan();
		do_dp();
	}
	cout<<ans2<<endl<<ans<<endl;
	return 0;
}

```

---

## 作者：九思 (赞：17)

总结一下(加上一点扩展)
1.	经典区间DP： (一加四重循环) 1. 区间左节点d(因为有环，要循环n次)；2. 区间长度r=l+len；3. 区间个数k；4. 区间断点m；5. 左段区间数s。  
`dp[l+d][r+d][k]=max(dp[l+d][m+d][s]*dp[m+d+1][r+d][k-s]);`

2.	压缩线性DP：（一加三重循环）1. 区间左节点d(需要对每个dp数组单独处理)；2. 区间个数k；3. 当前区间长度i；4. 区间断点j。(因为区间连续可以压掉s)  
`dp[i][k]=max(dp[j][k-1]*sum(j+1,i));`

标准版可以一次处理所有情况易上手但耗时耗空间，压缩版需重复初始化但省时，dp数组利用率更高。

Q1：如果把取模结果从非负改成可负怎么做？  
A1：那么最大值可能由正$\times$正或负$\times$负得到，最小值同，所以多加一个判断条件就好了。

Q2：若答案亦取模，大$\times$大$\mod mod <$ 小$\times$小$\mod mod$导致答案错误怎么办？  
A2：那么我们多加一维表示答案(一般这个答案不会让你数组爆掉)，dp数组改为bool类型，将得到的答案推向下一个可以由此达到的答案，以此类推（建议用线性dp） 
```
线性DP版(区间DP题解里面有一堆大佬写，貌似想法都差不多)
f(i,a,b)即for(i=a;i<=b;i++)
#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
const int N = 55;
using namespace std;
int n,m,dmax[15][N],dmin[15][N];
int sum[N],a[N],ans,anss=1e9;
int mian() {
	scanf("%d%d",&n,&m);
	f(i,1,n) scanf("%d",&a[i]);
	f(l,0,n-1) {
		memset(dmax,0,sizeof dmax);
		memset(dmin,0,sizeof dmin);
		f(i,1,n)dmin[1][i]=dmax[1][i]=sum[i]=
		(sum[i-1]+a[(i+l-1)%n+1]+10000)%10;
		//cout<<l<<endl;f(i,1,n)cout<<sum[i]<<' ';cout<<endl;
		f(k,2,m) f(i,1,n-m+k) {
			dmin[k][i]=1e9;
			f(j,1,i-1) if(dmin[k-1][j]<1e9) {
				dmax[k][i]=max(dmax[k][i],
				dmax[k-1][j]*((sum[i]-sum[j]+10000)%10));
				dmin[k][i]=min(dmin[k][i],
				dmin[k-1][j]*((sum[i]-sum[j]+10000)%10));
			}
		}
		//f(k,1,m) {f(i,1,n) cout<<dmin[k][i]<<' ';puts("");}
		ans=max(ans,dmax[m][n]);
		anss=min(anss,dmin[m][n]);
	}
	cout<<anss<<endl<<ans;
    return 0;
}
```

---

## 作者：YoungNeal (赞：17)

题解从博客看效果更佳~[YoungNeal](www.cnblogs.com/YoungNeal/p/8509976.html)

## Solution

啊这道题好有水平=.=

第一眼看到这题以为是和石子合并一样水的题，但是蛮多细节要注意的(我也是看题解才知道)

定义 $f[0/1][i][j][k]$ 表示左端点在 i，右端点在 j，分成了 k 个部分的最大/最小乘积

最开始做这题开了五层循环，内层枚举了一下断点和断点两侧分别分成了多少个部分...

后来(抄题解)发现了其实不用枚举两侧分成了多少个部分，因为这会被之前或之后的循环枚举到，打个比方：如果枚举到了左端点是 i，右端点是 j，断点是 k，左边分成了p 个部分，右边分成了 q 个部分。                                                                                                   

先明确一下，在合并时，我们只是关注 k+1~j 的前缀和再乘上左边已经乘好的部分， 即   
$f[i][j][p+q]=max{f[i][j][p+q-1]*(qzh[j]-qzh[k])}$    
所以是不用管右边分成了几个部分的，直接假设右边分成了一个部分，然后用左边的区间去“吃”右边的区间就好。
## Code
```
// By YoungNeal 
#include<cstdio>
#include<iostream>
using namespace std;

int n,m;
int qzh[105];
int val[105];
int f[2][105][105][15];

int mod(int x){
    return (x%10+10)%10;
}

signed main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&val[i]),val[i+n]=val[i];
    for(int i=1;i<=(n<<1);i++) qzh[i]=qzh[i-1]+val[i];
    for(int i=1;i<=(n<<1);i++){
        for(int j=i;j<=(n<<1);j++)
            f[0][i][j][1]=f[1][i][j][1]=mod(qzh[j]-qzh[i-1]);
    }
    /*愚蠢的五层循环
　　for(int len=2;len<=(n<<1);len++){
        for(int i=1;i<=(n<<1);i++){
            int j=i+len-1;
            if(j>(n<<1)) break;
            for(int p=i;p<=j;p++){
                for(int k=1;k<=min(m,j-i+1);k++){
                    for(int q=1;q<k;q++){
                        if(q<=p-i+1&&k-q<=j-p)
                            f[i][j][k]=max(f[i][j][k],f[i][p][q]+f[p+1][j][k-q]+(qzh[p]-qzh[i-1])*(qzh[j]-qzh[p]));
                    }
                }
            }
        }
    }*/
    for(int i=2;i<=m;i++){
        for(int l=1;l<=(n<<1);l++){
            for(int r=l+i-1;r<=l+n-1;r++){
                //f[l][r][i]
                f[1][l][r][i]=0x3f3f3f3f;
                for(int k=l+i-2;k<r;k++){  //k不能=r！ 
                    f[0][l][r][i]=max(f[0][l][r][i],f[0][l][k][i-1]*mod(qzh[r]-qzh[k]));
                    f[1][l][r][i]=min(f[1][l][r][i],f[1][l][k][i-1]*mod(qzh[r]-qzh[k]));
                }
            }
        }
    }
    int maxn=0,minn=0x3f3f3f3f;
    for(int i=1;i<=n;i++) maxn=max(maxn,f[0][i][i+n-1][m]),minn=min(minn,f[1][i][i+n-1][m]);
    printf("%d\n%d",minn,maxn);
    return 0;
}
```

---

## 作者：夏色祭 (赞：10)

**P党的福利**

来发dp的P党题解

状态:fmax[i,j]//表示前i个数分成j个部分的最大值

fmin[i,j]//表示前i个数分成j个部分的最小值

边界:fmax[i,1]:=(sum[i] mod 10+10) mod 10（sum[i]为前i个数的总和）;fmin[i,1]:=(sum[i] mod 10+10) mod 10;

状态转移方程:

fmax[i,j]:=max(fmax[i,j],fmax[k,j-1]\*ff(sum[i]-sum[k]));

fmin[i,j]:=min(fmin[i,j],fmin[k,j-1]\*ff(sum[i]-sum[k]){ff为取sum[i]-sum[k]对10取余的结果});//找一个中间点，把1到k分j-1个部分，而之前我们已经做出了决策，答案保存在f[k,j-1]里，另外k+1到i看成一部分，利用前缀和求出从k+1到i的值。


当然，我认为推出这状态转移方程并不是很难（连本蒟蒻都推出来了），本题还有一个难点——处理环。

我对此的解决方法是：把环看成一条链，旋转出这条环所有的可能性（旋转即把整个数组里的数都往前1格，第一个数则到最后一个位置）


AC代码：

```cpp
uses math;
var
  a,sum:array[0..51]of longint;
  fmax,fmin:array[0..51,0..10]of longint;
  n,m,i,j,k,x,maxn,minn,t:longint;
function ff(x:longint):longint;
begin
  exit(((x mod 10)+10) mod 10);
end;//对取10余
procedure dp;
var
  i,j,k:longint;
begin
  for i:=1 to n do 
    sum[i]:=sum[i-1]+a[i];//当前可能性的前缀和
  for i:=0 to n do 
    for j:=0 to m do 
      begin
        fmax[i,j]:=-66666666; 
        fmin[i,j]:=66666666;
      end;//赋初值
  for i:=1 to n do
    begin 
      fmax[i,1]:=ff(sum[i]);;
      fmin[i,1]:=ff(sum[i]);
    end;//边界
  for i:=1 to n do 
    for j:=2 to m do
      for k:=j-1 to i-1 do  
        begin
          fmax[i,j]:=max(fmax[i,j],fmax[k,j-1]*ff(sum[i]-sum[k]));
          fmin[i,j]:=min(fmin[i,j],fmin[k,j-1]*ff(sum[i]-sum[k]));
        end;//dp
  maxn:=max(maxn,fmax[n,m]);
  minn:=min(minn,fmin[n,m]);//最终两个最优解分别存在fmax[n,m]和fmin[n,m]，然后打个擂台
end;
begin
  readln(n,m);
  for i:=1 to n do readln(a[i]);
  minn:=66666666;
  for i:=1 to n do 
    begin
      t:=a[1];
      for j:=1 to n-1 do 
        a[j]:=a[j+1];
      a[n]:=t;//把整个数组里的数都往前1格，第一个数则到最后一个位置
      dp;//求当前这种可能的两个最优解
    end;//旋转出这条环所有的可能性
  writeln(minn);
  writeln(maxn);
end.
```

---

## 作者：FHXZ (赞：9)

这道题是典型的环形DP，我们设f[i][j]为前i个数分成j份得到的最大值，g[i][j]表示前i个数分成j份获得的最小值。于是状态转移方程很容易推出来：

我们枚举一个k端点在1~i-1之间，表示这k个数分成j-1份之后剩下的k+1到i分成一份，所获得的价值用前缀和处理即可。

注意环的处理。

代码如下：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
int n,m,Max,Min;
int sum[201],f[200][20],g[200][20],num[201];
void dp(int a[])
{
    for (int i=1; i<=n; i++) sum[i]=sum[i-1]+a[i];    
    for (int i=0; i<=n; i++)    
        for (int j=0; j<=m; j++)
        {
            f[i][j]=0;
            g[i][j]=999999999;
        }
    for (int i=1; i<=n; i++)     
        f[i][1]=g[i][1]=(sum[i]%10+10)%10;
    f[0][0]=g[0][0]=1; 
    for (int j=2; j<=m; j++)    
        for (int i=j; i<=n; i++)    
            for (int k=j-1; k<=i-1; k++)  
            {
                f[i][j]=max(f[i][j],f[k][j-1]*(((sum[i]-sum[k])%10+10)%10));
                g[i][j]=min(g[i][j],g[k][j-1]*(((sum[i]-sum[k])%10+10)%10));
            }
    Max=max(Max,f[n][m]);   
    Min=min(Min,g[n][m]);  
}
int main()
{
    Max=0;
    Min=999999999;
    scanf("%d%d",&n,&m);
    for (int i=1; i<=n; i++)
    {
        scanf("%d",&num[i]);
        num[i+n]=num[i];    
    }
    for (int i=0; i<n; i++) dp(num+i); 
    printf("%d\n%d\n",Min,Max);
    return 0;
}

```

---

## 作者：Lidy (赞：9)

记忆化搜索+Dp的思想
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int inf=0x7fffffff/2;
int n,m,a[2005],sum[2005],fmin[205][205][205],fmax[205][205][205];
int read()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
	    scanf("%d",&a[i]);	
	    if(a[i]<0)a[i]+=10000;//处理负数 
	    a[i+n]=a[i];//建一个环 
	} 
	for(int i=1;i<=2*n;i++)
	    sum[i]=sum[i-1]+a[i];//前缀和 
}
int dfs_min(int l,int r,int k)
{
	if(fmin[l][r][k]!=-1)return fmin[l][r][k];//记忆化搜索 
	if(k==1)return fmin[l][r][k]=(sum[r]-sum[l-1])%10;
	//当k==1时，即分好一个部分，用前缀和计算当前部分区间l-r的权值和 
	int x=inf;
	for(int i=l;i<r;i++)
	    for(int j=1;j<k;j++)
	    	x=min(x,dfs_min(l,i,j)*dfs_min(i+1,r,k-j));
	    	//类似与Dp，计算出不同的分部分方法所产生的最小值 
	return fmin[l][r][k]=x;
	//记忆化+return 
}
int dfs_max(int l,int r,int k)//代码理解同上，区别在于这是求 最大 
{
	if(fmax[l][r][k]!=-1)return fmax[l][r][k];
	if(k==1)return fmax[l][r][k]=(sum[r]-sum[l-1])%10;
	int x=0;
	for(int i=l;i<r;i++)
	    for(int j=1;j<k;j++)
		    x=max(x,dfs_max(l,i,j)*dfs_max(i+1,r,k-j));
    return fmax[l][r][k]=x;
}
void solve()
{
	memset(fmin,-1,sizeof(fmin));
	memset(fmax,-1,sizeof(fmax));
	for(int i=1;i<=n;i++)
	{
		dfs_min(i,i+n-1,m);//算出从i~i+n-1这条链上的最小值 
		dfs_max(i,i+n-1,m);//算出从i~i+n-1这条链上的最大值 
	} 
}
void print()
{
	int maxx=-inf;
	int minn=inf;
	for(int i=1;i<=n;i++)
	{
		maxx=max(maxx,fmax[i][i+n-1][m]);//在每一种方案下取最大 
		minn=min(minn,fmin[i][i+n-1][m]);//在每一种方案下取最小
	}
	if(minn<0){cout<<0;cout<<endl<<maxx;}
	else printf("%d\n%d\n",minn,maxx);
}
int main()
{
	read();
	solve();
	print();
	return 0;
}
```

---

## 作者：Michigan_King (赞：8)

这个题是一道典型的区间dp题，十分值得我们深入研究。

### 事实上，这道题揭示了区间dp问题标准的思考方式。

#### 1.这道题题目中的问题是一个环上的问题，我们自然而然的想到要断环成链，方法是开一个两倍空间的数组，通过**   a[i+n]=a[i]** 的方式进行。如有同学对此方法不清楚者，可以去做一做这道题[石子合并](https://www.luogu.org/problemnew/show/P1880)。（不知道为什么石子游戏竟然还是道绿题，百思不得其解） 
 
#### 2.题目中要求我们将这个换分成若干份，通过乘积的方式得到结果，对于一段区间中的值和，我们自然而然的想到要用到前缀和，即   **sum[i]=sum[i-1]+a[i]**

#### 3.我们需要枚举份数，左端点，右端点，最容易想到的额就是开一个三维数组f[i][j][k]用来表示i~j这段区间中分成k段的值。

通过以上的分析，我们就可以码代码了qwq

```cpp
#include <bits/stdc++.h>
#define N 110
using namespace std;
int a[N];
int sum[N];
int f_max[N][N][N];
int f_min[N][N][N];
int n,m;
int ans_max,ans_min=0x3f3f3f; 
int mod(int x)//写一个mod函数，比较方便
{
	return (x%10+10)%10;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[n+i]=a[i];//断环成链
	}
	for(int i=1;i<=2*n;i++)
	sum[i]=sum[i-1]+a[i];//维护前缀和
	for(int i=1;i<=2*n;i++)
	for(int j=1;j<=2*n;j++)
	{
		f_max[i][j][1]=mod(sum[j]-sum[i-1]);//预处理分成一份的值
		f_min[i][j][1]=mod(sum[j]-sum[i-1]);
	}
	for(int k=2;k<=m;k++)
	for(int i=1;i<=2*n;i++)
	for(int j=i+k-1;j<=2*n;j++)//同学们注意这个地方为什么是j=i+k-1,值得思考
	f_min[i][j][k]=0x3f3f;
	for(int k=2;k<=m;k++)
	for(int l=1;l<=2*n;l++)
	for(int r=l+k-1;r<=2*n;r++)
	for(int p=l+k-2;p<r;p++)//枚举[l,r]之间的值
	{
		f_max[l][r][k]=max(f_max[l][r][k],f_max[l][p][k-1]*mod(sum[r]-sum[p]));
		f_min[l][r][k]=min(f_min[l][r][k],f_min[l][p][k-1]*mod(sum[r]-sum[p]));
	}
	for(int i=1;i<=n;i++)
	{
		ans_max=max(ans_max,f_max[i][i+n-1][m]);//统计结果，找到最大最小值
		ans_min=min(ans_min,f_min[i][i+n-1][m]);
	}
	cout<<ans_min<<endl<<ans_max;
	return 0;
} 
```


---

## 作者：欧鹰 (赞：6)

（日常聊天），不妨说实话，我是看的各位大佬的题解才过的这道题，尤其是 这位大佬**qiianr**的题解，但作为一个dp蒟蒻我花了很长时间才看懂，他们也只讲了大致思路，我就补充一下dp主要的转移过程。



------------
### 题意

一个环状数组，分成k个部分，使各个部分的数字和的乘积最大最小。


------------

### 解题

首先，环状dp一般情况下，要破环成链。也很容易发现要处理一个前缀和，方便查询区间和。代码如下：

```cpp
	for(int i=1;i<=2*n;i++)
	{
		if(i<=n) cin>>a[i];
		
		else a[i]=a[i-n];
		
		sum[i]=sum[i-1]+a[i];
	}
	
```

第二，即开始我们的dp。

首先数组定义为两个，

minn[i][j][k]表示i~j分为k部分的最小值

maxx[i][j][k]表示i~j分为k部分的最大值

转移方程用代码解释。

```cpp
	for(int i=2;i<=m;i++)//分成几块，1块时预处理出来。 
	{
		for(int j=1;j<=2*n-i+1;j++)//左起点 ，因为会有i块，每一个块初始有一个数，所以用2*n-i+1。 
		{
			for(int k=j+i-1;k<=2*n;k++)//右终点， 同理，终点从j+i-1开始。 
			{
				for(int t=j+i-1;t<k;t++)//中转点 ，假设以t为界线分开 
				{
					int li=((sum[k]-sum[t-1])%10+10)%10;
					//maxx[j][t-1][i-1]即是j到t-1分成i-1块的最大值，再加上t到k的一块。 
					maxx[j][k][i]=max(maxx[j][k][i],maxx[j][t-1][i-1]*li);
					//minn[j][t-1][i-1]即是j到t-1分成i-1块的最大值，再加上t到k的一块。
					minn[j][k][i]=min(minn[j][k][i],minn[j][t-1][i-1]*li);
				}
			} 
		} 
	}
```


之后就是总代码。

```
#include<bits/stdc++.h>

#define int long long

using namespace std;

int n,m,sum[150],a[150],maxx[150][150][10],minn[150][150][10],ans1=1e7,ans2; 

signed main()
{
	memset(minn,0x7f,sizeof(minn)); 
	
	cin>>n>>m;
	
	for(int i=1;i<=2*n;i++)
	{
		if(i<=n) cin>>a[i];
		
		else a[i]=a[i-n];
		
		sum[i]=sum[i-1]+a[i];
	}
	
	for(int i=1;i<=n*2;i++)
	{
		for(int j=i;j<=n*2;j++)
		{
			maxx[i][j][1]=minn[i][j][1]=((sum[j]-sum[i-1])%10+10)%10;
		}
	}
	
	for(int i=2;i<=m;i++)//几块 
	{
		for(int j=1;j<=2*n-i+1;j++)//左起点 
		{
			for(int k=j+i-1;k<=2*n;k++)//右终点 
			{
				for(int t=j+i-1;t<k;t++)//中转点 
				{
					int li=((sum[k]-sum[t-1])%10+10)%10;
					
					maxx[j][k][i]=max(maxx[j][k][i],maxx[j][t-1][i-1]*li);
					
					minn[j][k][i]=min(minn[j][k][i],minn[j][t-1][i-1]*li);
				}
			} 
		} 
	}
	
	for(int i=1;i<=n;i++)
	{
		ans1=min(ans1,minn[i][i+n-1][m]);
		
		ans2=max(ans2,maxx[i][i+n-1][m]);
	}
	//
	cout<<max(ans1,(int)0)<<'\n'<<ans2;
	
	return 0;
	
}
```


---

## 作者：湖里的杭 (赞：5)

# 划分类dp+区间dp

本蒟蒻被诸位dalao的题解绕晕了

dp就不要搞得那么复杂嘛

用f[l][r][k]表示在l~r区间内分成m段的最优解

易得，状态转移方程为：

fmx[l][r][i]max=(fmx[l][k][i-1]*f[k+1][r][1])

fmn同理；

这道题是两类dp问题的综合题

一类是**划分类dp**

一类是**区间dp**
（先枚举len，再枚举l，再推出r，最后枚举k分界点）

一些注意事项各位dalao已经讲得很清楚了

这里就不在赘述了，详见注释；

下面附上本蒟蒻丑陋的代码

```cpp
#include<bits/stdc++.h>//省事的万能头
using namespace std;
int a[109],sum[109];//sum为前缀和
int fmx[109][109][19],fmn[109][109][19];
//两个dp的数组
int main()
{
	int n,m;cin>>n>>m;//意义如题目所示
	for(int i=1;i<=n;i++){ scanf("%d",&a[i]); a[i+n]=a[i]; }
    //破环成链
	sum[0]=0;
	for(int i=1;i<=n*2;i++) sum[i]=sum[i-1]+a[i];//开始求长度为n*2的前缀和
	memset(fmx,-1,sizeof(fmx));
	memset(fmn,127,sizeof(fmn));
	for(int i=1;i<=n*2;i++)
		for(int j=i;j<=n*2;j++)
			fmx[i][j][1]=fmn[i][j][1]=((sum[j]-sum[i-1])%10+10)%10;//这样子可以用来解决负数的求余
	for(int i=2;i<=m;i++)
		for(int len=2;len<=n;len++)
			for(int l=1;l<=n*2-len+1;l++)
			{
				int r=l+len-1;
				for(int k=max(l,l+i-2);k<=r-1;k++)
				{
					fmx[l][r][i]=max(fmx[l][r][i],fmx[l][k][i-1]*fmx[k+1][r][1]);
					fmn[l][r][i]=min(fmn[l][r][i],fmn[l][k][i-1]*fmn[k+1][r][1]);
                    //状态转移方程
                    //只可意会不可言传~
				}
			}
	int ansmin=INT_MAX,ansmax=-1;
	for(int i=1;i<=n;i++)
	{
		if(fmn[i][i+n-1][m]<ansmin) ansmin=fmn[i][i+n-1][m];
		if(fmx[i][i+n-1][m]>ansmax) ansmax=fmx[i][i+n-1][m];
	}//得出答案
	cout<<ansmin<<endl<<ansmax<<endl;
}
```
本蒟蒻的第四篇题解，望dalao支持

有问题欢迎想我指出

---

## 作者：1124828077ccj (赞：4)

本来可以像楼下那样用2维数组保存答案就行了的，但是我发现环这东西好像不太好处理（可恶的环），于是先破环成链，然后f[i][j][k]表示从i到j分成k段的最大值。那么f[i][j][k]=max{f[i][l-1][k-1]\*((c[j]-c[l-1])%10)}其中c是前缀和，最小值类似，最后再比较一下最大值即可。效率O((n^3)\*m)。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,s[102],f[102][102][10],h,ans=1e9,c[102],f2[102][102][10],Max;
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    {scanf("%d",&s[i]);s[n+i]=s[i];}//破环成链
    for (int i=1;i<=n*2;i++)
    c[i]=c[i-1]+s[i];//前缀和
    for (int i=1;i<=n*2;i++)
    for (int j=i;j<=n*2;j++)
    for (int k=1;k<=m;k++)
    if (k<2)
    {
        f2[i][j][k]=((f2[i][j-1][k]+s[j])%10+10)%10;
        f[i][j][k]=((f[i][j-1][k]+s[j])%10+10)%10;
    }
    else f[i][j][k]=1e9;
        //初始化
    for (int i=2;i<=m;i++)
    for (int j=1;j<=n*2;j++)
    for (int k=i+j-1;k<=n*2;k++)
    for (int l=i+j-1;l<=k;l++)
    {
        f[j][k][i]=min(f[j][k][i],f[j][l-1][i-1]*(((c[k]-c[l-1])%10+10)%10));
        f2[j][k][i]=max(f2[j][k][i],f2[j][l-1][i-1]*(((c[k]-c[l-1])%10+10)%10));
```
}//递推过程（动规）
```cpp
    for (int i=1;i<=n;i++)
    {ans=min(ans,f[i][n+i-1][m]);Max=max(Max,f2[i][n+i-1][m]);}//还有最后的比较
    printf("%d\n%d",ans,Max);
    return 0*8*7*6*5*4*3*2*1;//本人作死
}
```

---

## 作者：KesdiaelKen (赞：4)

然而没有人写五维DP吧……

一开始觉得怎么会是五维呢（写着写着就变五维了），然而看了题解之后发现，真的实际上只用四维就够了（我作死多做了一维）。不过，我还是再发发一发题解，帮助大家更好的理解一下这一题的做法。

我的f数组是四维的，即f[i][j][k][s]表示从第i个到第j个数中取k段的最大值或最小值。状态转移方程便很简单，就是f[j1][j2][k][u]=comp(s)(f[j1][s][l][u]\*f[s+1][j2][k-l][u])。具体也很好理解，就是枚举分段点，枚举两段分别所取的段数（这里多了一维，其实不用枚举段数），取最大或最小值就行了。

另外，注意一点：未被访问过的状态不能被统计，否则会导致错误的答案。

具体需要注意的就是这么多了，最重要的还是理解与实践。

代码如下：

                        
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>
using namespace std;
long long f[200][200][20][2]={0};//DP状态数组
int n,m;
int sl[200]={0};//存储数列
int sum;
int qm(int zuo,int you)//求mod函数，因为有负数，所以用类似两头夹的思想来做
{
    sum=0;
    for(int i=zuo;i<=you;i++)sum+=sl[i];
    while(sum<0)sum+=10;
    while(sum>=10)sum-=10;
    return sum;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
        sl[i+n]=sl[i];//破环成链
    }
    int j2;
    long long maxn=0,minn=2e8;//最后的最大值与最小值。考虑到可能溢出，这里用long long
    memset(f,-1,sizeof(f));//-1即表示未visit
    for(int i=1;i<=n;i++)//枚举头尾距离
    {
        for(int j1=1;j1<=2*n-i+1;j1++)//出发点
        {
            j2=j1+i-1;//结束点
            for(int k=1;k<=m;k++)//分成的段数
            {
                if(k==1)
                {
                    f[j1][j2][k][0]=f[j1][j2][k][1]=qm(j1,j2);//直接统计
                }
                else
                {
                    f[j1][j2][k][1]=2e8;//初始化
                    for(int s=j1;s<j2;s++)
                    {
                        for(int l=1;l<=s&&k-l>=1;l++)//具体见解析
                        {
                            if(f[j1][s][l][0]!=-1&&f[s+1][j2][k-l][0]!=-1)//若存在可以推导的状态
                            f[j1][j2][k][0]=max(f[j1][j2][k][0],f[j1][s][l][0]*f[s+1][j2][k-l][0]);
                            if(f[j1][s][l][1]!=-1&&f[s+1][j2][k-l][1]!=-1)
                            f[j1][j2][k][1]=min(f[j1][j2][k][1],f[j1][s][l][1]*f[s+1][j2][k-l][1]);//动态转移
                        }
                    }
                }
                if(i==n&&k==m)
                {
                    maxn=max(maxn,f[j1][j2][k][0]);
                    minn=min(minn,f[j1][j2][k][1]);//取最值
                }
            }
        }
    }
    if(minn==2e8)minn=0;//若未更新，则说明minn==0
    printf("%lld\n%lld",minn,maxn);
}
```

---

## 作者：kczno1 (赞：3)

先预处理m=1时第i位到第j位的值(f[i,j,1]),

赋f[i,j,k](1<k<=m)初值。

再记忆化搜索


最大值和最小值分开处理

由于首尾相接，处理一次转一圈再处理(重复n-1次)


```delphi

const p=10;
var
  n,m,i,max_ans,min_ans,j:longint;
  a:array[0..50]of longint;
  f:array[1..50,1..50,1..9]of longint;

function min(x,y:longint):longint;
begin
  if x<y then exit(x);
  exit(y);
end;

function max(x,y:longint):longint;
begin
  if x>y then exit(x);
  exit(y);
end;

function chuli(x:longint):longint;
begin
 exit((x mod 10+10)mod 10);
end;

function try_max(x,y,k:longint):longint;
var i,maxi:longint;
begin
 if f[x,y,k]=-p then
 begin
  maxi:=min(y-k+2,y-1);
  for i:=x to maxi do
   f[x,y,k]:=max(f[x,y,k],try_max(x,i,1)*try_max(i+1,y,k-1));
 end;
 exit(f[x,y,k]);
end;

function try_min(x,y,k:longint):longint;
var i,maxi:longint;
begin
 if f[x,y,k]=p then
 begin
  maxi:=min(y-k+2,y-1);
  for i:=x to maxi do
   f[x,y,k]:=min(f[x,y,k],try_min(x,i,1)*try_min(i+1,y,k-1));
 end;
 exit(f[x,y,k]);
end;

procedure fill;
var i,j:longint;
begin
 for i:=1 to n do f[i,i,1]:=a[i];
 for i:=1 to n do
  for j:=i+1 to n do
   f[i,j,1]:=chuli(f[i,j-1,1]+a[j]);
end;

procedure fill_max;
var i,j,k:longint;
begin
 for i:=1 to n do
  for j:=i to n do
   for k:=2 to m do
    f[i,j,k]:=p;
 fill;
end;

procedure fill_min;
var i,j,k:longint;
begin
 for i:=1 to n do
  for j:=i to n do
   for k:=2 to m do
    f[i,j,k]:=-p;
 fill;
end;

begin

  readln(n,m);
  for i:=1 to n do
  begin
   readln(a[i]);
   a[i]:=chuli(a[i]);
  end;
  fill_min;
  max_ans:=try_max(1,n,m);
  fill_max;
  min_ans:=try_min(1,n,m);

  for i:=1 to n-2 do
  begin
   for j:=0 to n-1 do
    a[j]:=a[j+1];
   a[n]:=a[0];
   fill_min;
   max_ans:=max(max_ans,try_max(1,n,m));
   fill_max;
   min_ans:=min(min_ans,try_min(1,n,m));
  end;

  writeln(min_ans);
  writeln(max_ans);
end.

```

---

## 作者：裘小小 (赞：2)

#### 简单的动规
分析：
对于这题先处理圈，我们先把圈转换成线形的数组。例如，样例转换成线形数组后有下列4种形态：
4 3 –1 2
3 –1 2 4
-1 2 4 3
2 4 3 –1
然后考虑最终的状态，这就是n个数被分成m份，要产生这个状态，一定是前j个数被分成m-1份 * 后n-j个数的和的模。

由此可得出动态转移方程：F[I,k]=max{F[j,k-1]*后I-j个数的和的摸}
从而得出程序：
```pascal
for k:=2 to m do
  for i:=1 to n do
    begin
      f [ i , k ]:=-maxlongint;
      for j:=k-1 to i-1 do
        begin
          l:=sum(j+1 , i);
          l:=l mod 10;
          if l<0 then L:=L+10;
          if  f [ j , k-1 ] * l > f [ i , k ]  then  f [ i, k ] := f [ j , k-1 ] * l
        end;
end;
```


---

## 作者：gorokokoro (赞：1)

随便乱写的……因为 std 是区间 DP，一直以为自己写错了……（~结果 1A ……~）

先考虑一条链的情况：

用 $f[i][j]$ 表示在前 $i$ 个数里面，划分出 $j$ 个区间，可以得到的最**小**价值

对称的定义 $g[i][j]$：

用 $g[i][j]$ 表示在前 $i$ 个数里面，划分出 $j$ 个区间，可以得到的最**大**价值

~转移的时候两者都考虑即可~（看错题了，以为 $-1 \text{ mod }10=-1$，然而两者都考虑也不会有问题）

于是转移就变得很直接了，~不需要怎么讲了吧~

``` cpp
#include <iostream>
#include <algorithm>
#include <deque>
#include <utility>
#define N 70
#define KB 10
#define INFINITE 999999999
using namespace std;

deque<int> a;
pair<int, int> f[N][N];
int g[N];

int main()
{
    int n, m, x;
    int i, j, k, t;
    int o0, o1;

    cin >> n >> m;
    for(i = 0;i < n;i ++)
    {
        cin >> x;
        a.push_back(x);
    }

    for(t = 0, o0 = INFINITE, o1 = -INFINITE;t < n - 1;t ++)
    {
        for(i = 0;i < n;i ++)
            g[i + 1] = g[i] + a.at(i);

        for(i = 0;i < N;i ++)
            for(j = 0;j < N;j ++)
            {
                f[i][j].first  =  INFINITE;
                f[i][j].second = -INFINITE;
            }

        for(i = 1, f[0][0] = make_pair(1, 1);i <= n;i ++)
            for(j = 1;j <= min(i, m);j ++)
                for(k = i;k > 0 && j - 1 <= k - 1;k --)
                {
                    if(f[k - 1][j - 1].first  !=  INFINITE)
                        f[i][j].first  = min(f[i][j].first , f[k - 1][j - 1].first  * (((g[i] - g[k - 1]) % KB + KB) % KB));
                    if(f[k - 1][j - 1].second != -INFINITE)
                        f[i][j].first  = min(f[i][j].first , f[k - 1][j - 1].second * (((g[i] - g[k - 1]) % KB + KB) % KB));

                    if(f[k - 1][j - 1].first  !=  INFINITE)
                        f[i][j].second = max(f[i][j].second, f[k - 1][j - 1].first  * (((g[i] - g[k - 1]) % KB + KB) % KB));
                    if(f[k - 1][j - 1].second != -INFINITE)
                        f[i][j].second = max(f[i][j].second, f[k - 1][j - 1].second * (((g[i] - g[k - 1]) % KB + KB) % KB));
                }
        o0 = min(o0, f[n][m].first );
        o1 = max(o1, f[n][m].second);

        a.push_back(a.front());
        a.pop_front();
    }
    cout << o0 << endl << o1 << endl;

    return 0;
}
```

---

## 作者：呼风唤雨abc (赞：1)

~~这一题和[能量项链](https://www.luogu.org/problemnew/show/P1063)有何区别，只是多了一个最小值罢了。~~

但是还是有区别的，我们可以这么想，在一个区间中，我们可以分成 / 两个更小的区间的值 / 的最大值 / 的乘积 / 的最大值，举一个形象一点的例子。

就拿样例来说话，对于一个4 3 -1 2这一个数列（不是环，不是环，不是环）我们只能分成2组，那么我们可以枚举断点（插板法），分成2个部分，并枚举左区间可以分成多少组（这个样例当然是一边1组呀），然而右区间的组数也就可以求出来，以此递归。

```cpp
(4 | 3 -1 2) -> 4*4=16
(4 3 | -1 2) -> 7*1=7
(4 3 -1 | 2) -> 6*2=12
```

那么答案就出来了，但是盲目搜索太慢，需要记忆化，所以开一个dp数组，存dp[区间的左编号][区间的右编号][可以分成多少组（剩余的分组次数）]=当前最大值。

核心代码如下：

```cpp
#define Minax(a,b) a=(a==-1?b:(e?min(a,b):max(a,b)))
//这一个宏定义其实就是说当a没有值（即a=-1时）给它先赋值。
//之后当e是真时就是最小值。
//之后当e是假时就是最最大。
//l -> 区间的左编号。
//r -> 区间的右编号。
//h -> 可以分成多少组（剩余的分组次数）。
	for(int i=l;i<=r-1;i++)
    	//枚举断点，即插板。
		for(int j=1;j<=h-1;j++)
        	//枚举左边的分组次数，那么右边的分组次数就是h-j。
			if((i-l+1)>=j && r-i>=h-j)
				Minax(dp[l][r][h],dfs(l,i,j)*dfs(i+1,r,h-j));
//                                =>左区间    =>右区间
```

然而这一题是一个环，那么我们只需要枚举从哪一个开始，即可。（注意用前缀和减少时间）。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define C(ch) ch-'0'
#define Minax(a,b) a=(a==-1?b:(e?min(a,b):max(a,b)))
#define f(ret) (ret<<3)+(ret<<1)
#define F(l,r) (s[r]-s[l-1]+(int)5e5)%10
#define print(a) memset(dp,-1,sizeof(dp)),e=a;\
				 for(int i=1,ans=(a?5e5:-1);i<=n;i++){\
                 	 //枚举开始的编号。（请提交时删掉）
				 	 Minax(ans,dfs(i,i+n-1,m));\
                     //更新最小值或最大值（请提交时删掉）
				 	 if(i==n)\
				 	 	 printf("%d\n",ans);\
				 }
#define Is(ch) ((ch>='0' && ch<='9') || ch=='-')
int dp[2*50+5][2*50+5][9+5];
int s[2*50+5],x[50+5],n,m,e;
inline int Read(){//快读
	int ret=0,fs=0;
	char ch=getchar();
	while(!Is(ch))
		ch=getchar();
	fs=(ch=='-'?-1:1);
	if(ch=='-')
		ch=getchar();
	while(Is(ch)){
		ret=f(ret)+C(ch);
		ch=getchar();
	}
	return ret*fs;
}
inline int dfs(int l,int r,int h){
	if(h==1)//分成自已的一组。
		return F(l,r);//区间%10的值。
	if(dp[l][r][h]==-1)//没有计算过。
		for(int i=l;i<=r-1;i++)
			for(int j=1;j<=h-1;j++)
				if((i-l+1)>=j && r-i>=h-j)
					Minax(dp[l][r][h],dfs(l,i,j)*dfs(i+1,r,h-j));
	return dp[l][r][h];
}
int main(){
	n=Read();
	m=Read();
	for(int i=1;i<=n;i++)
		s[i]=s[i-1]+(x[i]=Read());
	for(int i=n+1;i<=2*n;i++)
		s[i]=s[i-1]+x[i-n];//赋值一遍数组。
	print(1);
	print(0);
	return 0;	
}
```
### 不懂的话可以私信我。

---

## 作者：chestX_ray (赞：1)

序列型dp

环形自然想到把数组复制一遍

以每个数字做开头来dp一遍

一点点指针的运用

而且数据这么水随便搞搞都能过







```cpp
#include<bits/stdc++.h>
#define INF 9999999
using namespace std;
const int N=55;
const int M=11;
int n,m,x,ans_max,ans_min=INF,a[N+N],f[N][M],g[N][M],sum[N][N];
void dp(int *a) {
    memset(sum,0,sizeof(sum));
    for(int i=1; i<=n; i++)
        for(int j=i; j<=n; j++)
            sum[i][j]=(sum[i][j-1]+a[j])%10;
    for(int i=0; i<=n; i++)
        for(int j=0; j<=m; j++) {
            g[i][j]=INF;
            f[i][j]=0;
        }
    f[0][0]=g[0][0]=1;
    for(int j=1; j<=m; j++)
        for(int i=j; i<=n; i++)
            for(int l=0; l<i; l++) {
                f[i][j]=max(f[i][j],f[l][j-1]*sum[l+1][i]);
                if(g[l][j-1]!=INF)
                    g[i][j]=min(g[i][j],g[l][j-1]*sum[l+1][i]);
            }
    ans_max = ans_max > f[n][m] ? ans_max : f[n][m];
    ans_min = ans_min < g[n][m] ? ans_min : g[n][m];
}
int main() {
    cin>>n>>m;
    for(int i=1; i<=n; i++) {
        cin>>x;
        a[i]=abs(x)%10;
        if(x<0)a[i]=10-a[i];
        a[i+n]=a[i];
    }
    for(int i=0; i<n; i++)dp(a+i);
    cout<<ans_min<<endl<<ans_max<<endl;
    return 0;
}
```

---


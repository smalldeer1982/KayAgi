# 守卫者的挑战

## 题目描述

打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押 applepi 的监狱的所在地。突然，眼前一道亮光闪过。“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为 $K$ 的包包。
  
擂台赛一共有 $N$ 项挑战，各项挑战依次进行。第 $i$ 项挑战有一个属性 $a_i$，如果 $a_i\geq 0$，表示这次挑战成功后可以再获得一个容量为 $a_i$ 的包包；如果 $a_i=-1$，则表示这次挑战成功后可以得到一个大小为 $1$ 的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把 【获得的所有的】地图残片都带走（没有得到的不用考虑，只需要完成所有N项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功 $L$ 次才能离开擂台。
  
队员们一筹莫展之时，善良的守卫者 Nizem 帮忙预估出了每项挑战成功的概率，其中第 $i$ 项挑战成功的概率为 $p_i\%$。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。

## 说明/提示

在第一个样例中，若第三项挑战成功，如果前两场中某场胜利，队员们就有空间来容纳得到的地图残片，如果挑战失败，根本就没有获得地图残片，不用考虑是否能装下；若第三项挑战失败，如果前两场有胜利，没有包来装地图残片，如果前两场都失败，不满足至少挑战成功1次的要求。因此所求概率就是第三场挑战获胜的概率。

对于 $100\%$ 的数据，保证 $0\leq K\leq 2000$，$0\leq N\leq 200$，$-1\leq a_i\leq 1000$，$0\leq L\leq N$，$0\leq p_i\leq 100$。

## 样例 #1

### 输入

```
3 1 0
10 20 30
-1 -1 2```

### 输出

```
0.300000
```

## 样例 #2

### 输入

```
5 1 2
36 44 13 83 63
-1 2 -1 2 1```

### 输出

```
0.980387```

# 题解

## 作者：luobotianle (赞：17)

设 $f_{i,j,k}$ 表示已经进行了 $i$ 局挑战，成功了 $j$ 局，目前背包剩余容量为 $k$（当 $k < 0$ 时表示还有 $-k$ 个物品未放入背包）的期望值；

那么，对于 $f_{i,j,k}$，有转移方程：

$$

f_{i,j,k}=(f_{i-1,j,k} \times (1-p_i)) + (f_{i-1,j-1,\max(k-a_i,0)} \times p_i)

$$

其中，第一项表示第 $i-1$ 次挑战失败的情况，第二项表示第 $i-1$ 次挑战成功的情况（当 $j=0$ 时没有第二项，毕竟不能赢 $-1$ 场）；

由于数组下标不能为负数，而最多只有 $n$ 次挑战，$n \le 200$，所以 $k \ge -200$，把所有 $k<0$ 的情况全部加上 $200$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=205;
int n,l,kk,a[N];
double p[N];
double f[N][N][N*2];
int main(){
	cin>>n>>l>>kk;
   /*由于最多只有 n 次挑战，也就是最多只有 n 块地图*/
   /*所以 kk 和 a 数组都可以对 n 取 min*/
	kk=min(kk,n);
	for(int i=1;i<=n;i++){
		cin>>p[i];
		p[i]/=100;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]=min(a[i],n);
	}
	f[0][0][kk+200]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=i;j++){
			for(int k=0;k<=400;k++){
				f[i][j][k]=f[i-1][j][k]*(1-p[i]);
				if(j!=0)f[i][j][k]+=f[i-1][j-1][max(k-a[i],0)]*p[i];
			}
		}
	}
	double ans=0;
	for(int i=l;i<=n;i++){
		for(int k=200;k<=400;k++){
			ans+=f[n][i][k];
		}
	}
	printf("%.6lf",ans);
	return 0;
}
```

---

## 作者：hh弟中弟 (赞：13)

[博客园](https://www.cnblogs.com/Ishar-zdl/p/18187476)

数据看起来是跑不了 $O(n^3)$ 的算法的，但是稍微观察不难发现对于所有的 $k\geq n$ 都属于同一类数（一定能装下所有碎片）。
设 $f_{i,j,k}$ 表示到了第 $i$ 个挑战，赢了 $j$ 次，当前背包容量为 $k$ 时的期望。有
$$
\begin{aligned}
f_{i+1,j+1,k+a_{i+1}}&=\sum_{k=-n}^n f_{i,j,k}\cdot p_{i+1}\\
f_{i+1,j,k}&=\sum_{k=-n}^n f_{i,j,k}\cdot(1-p_{i+1})
\end{aligned}
$$
$2n$ 来处理负数，直接刷表就行了。
```cpp
#include<bits/stdc++.h>
inline int read(){
	char ch=getchar();int x=0,f=1;
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
const int N=205;
int n,l,K,a[N];
double p[N],f[N][N][N*2];
int main(){
	// freopen("in.in","r",stdin),freopen("out.out","w",stdout);
	std::ios::sync_with_stdio(false);std::cin.tie(0),std::cout.tie(0);
	n=read();l=read();K=std::min(read(),n);
	for(int i=1;i<=n;++i)p[i]=read()/100.0;
	for(int i=1;i<=n;++i)a[i]=read();
	f[0][0][K+n]=1;
	for(int i=0;i<n;++i){
		for(int j=0;j<=i;++j){
			for(int k=0;k<=n*2;++k){
				if(!f[i][j][k])continue;
				if(k+a[i+1]>=n*2){
					f[i+1][j+1][n*2]+=f[i][j][k]*p[i+1];
					f[i+1][j][k]+=f[i][j][k]*(1-p[i+1]);
				}else{
					f[i+1][j+1][k+a[i+1]]+=f[i][j][k]*p[i+1];
					f[i+1][j][k]+=f[i][j][k]*(1-p[i+1]);
				}
			}
		}
	}
	double ans=0;
	for(int i=l;i<=n;++i){
		for(int j=n;j<=2*n;++j)ans+=f[n][i][j];
	}
	printf("%.6lf\n",ans);
}
```
~~话说为啥最近洛谷加了一堆典题。~~

---

## 作者：ppllxx_9G (赞：6)

## 概率DP + 记忆化搜索

题解竟然没有记搜！！！

### 题意

给出每一局游戏赢的概率和得分或者增加背包容量，

求最终**至少赢 $L$ 局**并且**得分不大于容量**的概率。

得分可以看成**大小为 $-1$ 的背包**，因此直接减去就好啦~~

### 解析

#### 暴力 dfs（30pts）

审题结束，开始考虑暴力，

我们需要知道的值有**赢的次数 $win$、背包容量（包括减去的得分）$volum$、比赛场次 $now$**。

如果赢了 $win \to win + 1,volum \to volum+a_{k+1}$，否则不变。

然后记录每种情况的概率就行啦~~


```cpp
void dfs(int now,double t,int vm,int win)
{
	if(now==n)
	{
		if(vm>=0&&win>=l) ans+=t;
		return;
	}
	dfs(now+1,t*p[now+1],vm+a[now+1],win+1);
	dfs(now+1,t*(1-p[now+1]),vm,win);
}
```
#### 记忆化搜索（100pts）

既然知道 dfs 的写法，改一改记忆化就很简单啦！

设计状态 $f_{now,win,volum}$，表示含义如上。

$$f_{now,win,volum}\\=dfs(now+1,win+1,volum+a_{now+1})\times p_{now+1}\\+ dfs(now+1,win,volum)\times (1-p_{now+1})$$

还有一个小问题就是背包容量太大了，数组开不下，还会有负数，

我们考虑所有大于 $n$ 的容量其实是等价的，所以赋成 $n$。

至于负数整体加 $n$ 就行啦~~

AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 205;
int n,l,k,a[N],tot,sum[N],be;
double p[N],f[N][N<<1][N],ans;//f[num][win][vm](vm=min(a[i],n))
bool vs[N][N<<1][N];
double dfs(int now,int win,int vm)
{
	if(now==n)
	{
		vs[now][win][vm+be]=1;
		if(win>=l&&vm>=0) return f[now][win][vm+be]=1;
		else return f[now][win][vm+be]=0;
	}
	if(vs[now][win][vm+be]) return f[now][win][vm+be];
	f[now][win][vm+be]=dfs(now+1,win+1,vm+a[now+1])*p[now+1]+dfs(now+1,win,vm)*(1-p[now+1]);
	vs[now][win][vm+be]=1;
	return f[now][win][vm+be];
}
int main()
{
	scanf("%d%d%d",&n,&l,&k); be=n;
	for(int i=1;i<=n;i++) scanf("%lf",&p[i]),p[i]/=100;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]); 
		if(a[i]>n) a[i]=n;
	}
	printf("%lf\n",dfs(0,0,k));
	return 0;
}
```

***

蒟蒻的第一篇题解，求通过 QwQ。

---

## 作者：HaneDaniko (赞：6)

### 题意简述

给定一些事件的获胜概率和权值（或增加背包容量），求最后权值小于背包容量，并且至少胜利 $L$ 个事件的概率。

### 题目分析

这是一道背包加概率 DP，下面我们根据经典背包 DP 思路设计代码。

#### 1.状态设计

根据题目中容量足够以及至少获胜的要求，不难开一个三维的转移 $f_{i,j,k}$ 表示事件 $[1,i]$ 内获胜了 $j$ 场，并且当前容量为 $k$ 的概率。

我们这样设计有一个显而易见的问题，就是理论时间复杂度里有一个很大的数 $K=2000$，但是我们会发现，在 $n$ 局游戏中最多只会获得 $n$ 个残片，假如我们的背包容量已经超过 $n$ 了，那么就一定能装下，所以我们只需要考虑 $K\le n\le 200$ 范围内的数据就可以了，时间复杂度降了很多。

#### 2.状态转移

根据背包 DP，我们在状态转移方程的第一维递推 $i$，第二维枚举胜利场次的可能情况，第三位枚举全部的可能容量（$[-n,n]$），得出状态转移方程：

假如胜利（概率为 $p_{i+1}$），有：

$$f_{i+1,j+1,k+a(i+1)}=f_{i,j,k}\times p_{i+1}$$ 

假如失败（概率为 $1-p_{i+1}$），有：

$$f_{i+1,j,k}=f_{i,j,k}\times (1-p_{i+1})$$

更多细节详见代码注释。

### 代码

[Record](https://www.luogu.com.cn/record/159988020)

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,l,k;
long double p[251]; //记录初始概率
int w[251]; //记录初始权值
long double f[251][251][501]; //这里按2*n开401会炸
int main(){
	cin>>n>>l>>k;
	for(int i=1;i<=n;++i){
		cin>>p[i];
		p[i]/=100;
	}
	for(int i=1;i<=n;++i){
		cin>>w[i];
	}
	f[0][0][200+k]=1;//初始状态概率为1
  //因为有负的容量，这里我是以maxn=200 为基准(0)开的数组
	for(int i=0;i<=n;++i){
		for(int j=0;j<=i;++j){
			for(int k=200-n;k<=200+n;++k){
				if(f[i][j][k]){
					f[i+1][j+1][min(200+n,k+w[i+1])]+=f[i][j][k]*p[i+1];
					f[i+1][j][k]+=f[i][j][k]*(1-p[i+1]);
				}
			}
		}
	}
	long double ans=0;
	for(int i=l;i<=n;++i){
		for(int j=200;j<=200+n;++j){
			ans+=f[n][i][j];//全部情况都要加起来
		}
	}
	printf("%.6Lf",ans);
}

```

---

## 作者：kwhzwzs (赞：5)

**很明显的一道 dp ：**
$$
f_{i,j,k}=\text{成功的期望值}
$$
$i$ 为总挑战数，$j$ 为胜利场数，$k$ 为背包容量。

$k>0$ 代表背包仍有剩余的空间，$k<0$ 代表目前仍有 $-k$ 个地图残片还未装入，由于下标不能为负数且 $-200 \le k \le 200$，所以直接将 $k$ 加上 $200$ 即可。

每次共有两种决策：若第 $i$ 次挑战胜利
$$
f_{i,j,k}
= \sum_{i = 1}^{n} f_{i-1,j-1,k-a_i} \times p_i
$$


若第 $i$ 次挑战失败 
$$
f_{i,j,k}= \sum_{i = 1}^{n} f_{i-1,j,k} \times (1-p_i)
$$

```cpp
#include <bits/stdc++.h>
#define kw 0
using namespace std;
const int N=210;
int n,l,k,a[N];
double ans,p[N],f[N][N][N*2];
int main(){
	scanf("%d%d%d",&n,&l,&k); 
	for(int i=1;i<=n;i++){
		scanf("%lf",&p[i]);
		p[i]=1.0*p[i]/100;
	}
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	f[0][0][200+min(n,k)]=1;//注意边界
	for(int i=1;i<=n;i++){
		for(int j=0;j<=i;j++){
			for(int k=0;k<=400;k++){
				f[i][j][k]+=f[i-1][j][k]*(1-p[i]);
				if(j>0&&k-a[i]>=0) f[i][j][k]+=f[i-1][j-1][k-a[i]]*p[i];
			}
		}
	}
	for(int i=l;i<=n;i++){
		for(int j=200;j<=400;j++){
			ans+=f[n][i][j];
		}
	}
	printf("%.6lf",ans);
	return kw;
} 
```

---

## 作者：Ratio_Y (赞：4)

发现自己突然写出了内存最优解？

------------
## 思路
很类似背包 dp 的一道概率题。用 $f_{i,j,k}$ 表示前 $i$ 场挑战，赢了 $j$ 场并且容量为 $k$ 的概率。

注意一下：容量大于 $n$ 的部分没有任何作用，所以我们表示的时候可以用 $k = 2\times n$ 表示实际为 $n$ 的空间，$k = n$ 表示实际的空间为 $0$，$k = 0$ 表示实际的空间为 $-n$。

## 状态转移
如果胜利，那么乘上胜利的概率并获得碎片或背包空间，否则乘上失败概率。

写出来就是

```
f[i][j+1][min(2*n,k+op[i])]+=f[i-1][j][k]*p[i];
//成功
f[i][j][k]+=f[i-1][j][k]*(1-p[i]);
//失败
```

## 空间优化
由于这道题在另一个题库上内存给的比较少，并且发现转移时只与 $i-1$ 的状态有关，所以我们使用滚动数组进行优化。最终内存使用只有 3.10MB，非常好用。

## code:
```
#include<bits/stdc++.h>
#define fo(x,y,z) for(int (x)=(y);(x)<=(z);(x)++)
#define fu(x,y,z) for(int (x)=(y);(x)>=(z);(x)--)
typedef long long ll;
typedef long double ld;
inline int qr()
{
	char ch=getchar();int x=0,f=1;
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<3)+(x<<1)+(ch^48);
	return x*f;
}
#define qr qr()
using namespace std;
const int Ratio=0;
const int N=205;
const int maxi=(INT_MAX)/2;
int n,l,k,tg=1;
int op[N];
ld p[N],zl[2][N][N<<1],ans;
namespace Wisadel
{
    short main()
	{
        n=qr,l=qr,k=qr;
        fo(i,1,n)
            scanf("%Lf",&p[i]),p[i]/=100;
        fo(i,1,n)
            op[i]=qr;
        int maxV=n+min(n,k);
        zl[0][0][maxV]=1;
        fo(i,1,n)
        {
            memset(zl[tg],0,sizeof zl[tg]);tg^=1;
            fo(j,0,i-1)
                fu(k,2*n,0)
                    zl[tg^1][j+1][min(2*n,k+op[i])]+=zl[tg][j][k]*p[i],
                    zl[tg^1][j][k]+=zl[tg][j][k]*(1-p[i]);
        }
        tg^=1;
        fo(i,l,n)
            fo(j,n,2*n)
                ans+=zl[tg][i][j];
        printf("%.6Lf",ans);
		return Ratio;
	}
}
int main(){return Wisadel::main();}
```
完结撒花~

---

## 作者：Lysea (赞：2)

### [P10504 守卫者的挑战](https://www.luogu.com.cn/problem/P10504)

一道好题，很合胃口。

首先可以设计出 $dp_{i,j,k}$ 表示前 $i$ 场赢了 $j$ 场且背包剩余容量为 $k$ 时的概率。

$$dp_{i,j,k}=(1-P)dp_{i-1,j-1,k}+Pdp_{i-1,j-1,k-a_i}$$

首先，这个 $i$ 是可以滚掉的，此时空间复杂度已经来到 $O(nk)$，足以通过。

接着关注到 $k\le 2000$，$n\le 200$，进行优化。因为最多放 $n$ 个物品，所以 $k$ 的范围其实是诈骗，直接跟 $n$ 取 $\min$ 即可，$a_i$ 也可如此。空间复杂度进一步降到 $O(n^2)$，时间复杂度也从 $O(n^2k)$ 降至 $O(n^3)$。

最后还要注意地图碎片有可能暂时无法放进包里，但在最后被放入的情况，在转移式中体现为 $k$ 为负。

同理，$k$ 为负时最小也不会低于 $-n$，因为之后的答案都已没有贡献了。

所以用一个小 trick，给 $k$ 这一维统一加上 $n$ 即可解决问题。

代码：


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 205
#define INF 1e18
using namespace std;
const int mx=200;
int n,l,k,p[N],a[N];
double dp[N][N][N<<1];
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>l>>k,k=min(n,k);
    for(int i=1;i<=n;i++) cin>>p[i];
    for(int i=1;i<=n;i++) cin>>a[i],a[i]=min(a[i],n);
    dp[0][0][k+mx]=1;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=i;j++){
            for(int k=0;k<=mx*2;k++){
                dp[i][j][k]=dp[i-1][j][k]*(1-p[i]/100.0);
                if(j&&k-a[i]>=0) dp[i][j][k]+=dp[i-1][j-1][k-a[i]]*(p[i]/100.0);
            }
        }
    }double ans=0;
    for(int i=l;i<=n;i++){
        for(int j=mx;j<=mx*2;j++){
            ans+=dp[n][i][j];
        }
    }cout<<fixed<<setprecision(6)<<ans;
    return 0;
}
```

---

## 作者：Cheerimy (赞：1)

### 题目思路

设 $dp_{i,j,k}$ 表示在进行 $i$ 局挑战中，成功 $j$ 局，并且背包剩余容量为 $k$ 的期望值。则对于 $dp_{i,j,k}$，有以下转移方程：


$dp_{i,j,k} = dp_{i-1,j,k} \times (1 - p_i) + dp_{i-1,j-1,\max(k - a_i, 0)} \times p_i $

其中：

- 第一项 $dp_{i-1,j,k} \times (1 - p_i)$ 表示第 $i-1$ 次挑战失败的情况。
- 第二项 $dp_{i-1,j-1,\max(k - a_i, 0)} \times p_i$ 表示第 $i-1$ 次挑战成功的情况。当 $j = 0$ 时，第二项不存在，因为不能进行 $-1$ 场挑战。

为了处理背包容量 $k$ 的负值情况，我们将所有 $k < 0$ 的情况都加上 200，使得背包容量范围从 $-200$ 到 $200$。也就是说，我们可以将背包容量 $k$ 映射到 $k' = k + 200$ 上，使得 $k' \ge 0$。

### 题目代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
template<typename type>inline void fin(string intype,type &x){intype=((intype=="%d")?"%lld":intype);scanf(intype.c_str(),&x);}
template<typename type,typename... Args>inline void fin(string intype,type &x,Args&... args){intype=((intype=="%d")?"%lld":intype);scanf(intype.c_str(),&x);fin(intype,args...);}
int a[210];
double p[210],dp[210][210][410];
signed main()
{
	int n,l,k;
	fin("%d",n,l,k);
	k=min(n,k);
	for(int i=1;i<=n;i++)fin("%lf",p[i]),p[i]/=100;
	for(int i=1;i<=n;i++)fin("%d",a[i]),a[i]=min(a[i],n);
	dp[0][0][k+200]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=i;j++)
		{
			for(int o=0;o<=400;o++)
			{
				dp[i][j][o]=dp[i-1][j][o]*(1-p[i]);
				if(j!=0)dp[i][j][o]+=dp[i-1][j-1][max(o-a[i],0ll)]*p[i];
			}
		}
	}
	double sum=0;
	for(int i=l;i<=n;i++)
	{
		for(int j=200;j<=400;j++)
		{
			sum+=dp[n][i][j];
		}
	}
	printf("%.6lf",sum);
	return 0;
}
```

---

## 作者：GXZJQ (赞：0)

# P10504 守卫者的挑战 题解

[题目链接](https://www.luogu.com.cn/problem/P10504)

## 题目分析

考虑期望动态规划。

记 $f_{i,j,k}$ 表示考虑前 $i$ 场挑战，成功了 $j$ 次，剩余容量为 $k$ 的概率。复杂度 $O(n^2 \sum a_i)$ 好像完全爆炸，但当 $k>n$ 之后必然能成功，因此特别记 $f_{i,j,n}$ 表示剩余容量不少于 $n$ 的概率，就可以将状态压缩到 $O(n^3)$ 级别。

考虑转移成方程：

- 成功： $f_{i,j+1,k+a_i} \leftarrow ^+ p_i \times f_{i−1,j,k}$；


- 失败： $f_{i,j,k} \leftarrow ^+ (1-p_i) \times f_{i−1,j,k}$。

注意实现时要平移数组，避免负数。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 211
int n, L, k;
double f[MAXN][MAXN][MAXN << 1 | 1], p[MAXN];
int main() {
	cin >> n >> L >> k;
	if (k > n)k = n;
	double ans = 0;
	f[0][0][n + k] = 1;
	for (int i = 1; i <= n; ++i)scanf("%lf", &p[i]), p[i] /= 100;
	for (int i = 1; i <= n; ++i) {
		int x ;
		cin >> x;
		for (int j = 0; j < i; ++j)
			for (int k = 0; k <= n + n; ++k)
				if (k + x >= 0)
					f[i][j + 1][min(n + n, k + x)] += p[i] * f[i - 1][j][k], f[i][j][k] += (1 - p[i]) * f[i - 1][j][k];
	}
	for (int j = L; j <= n; ++j)
		for (int k = n; k <= (MAXN << 1); ++k)ans += f[n][j][k];
	printf("%.6lf", ans);
	return 0;
}

```

---


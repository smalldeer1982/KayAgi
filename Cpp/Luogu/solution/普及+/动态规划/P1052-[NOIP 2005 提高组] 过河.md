# [NOIP 2005 提高组] 过河

## 题目描述

在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：$0,1,\cdots,L$（其中 $L$ 是桥的长度）。坐标为 $0$ 的点表示桥的起点，坐标为 $L$ 的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是 $S$ 到 $T$ 之间的任意正整数（包括 $S,T$）。当青蛙跳到或跳过坐标为 $L$ 的点时，就算青蛙已经跳出了独木桥。

题目给出独木桥的长度 $L$，青蛙跳跃的距离范围 $S,T$，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。

## 说明/提示

**【数据范围】**

- 对于 $30\%$ 的数据，$1\le L \le 10^4$；
- 对于 $100\%$ 的数据，$1\le L \le 10^9$，$1\le S\le T\le10$，$1\le M\le100$。

**【题目来源】**

NOIP 2005 提高组第二题

## 样例 #1

### 输入

```
10
2 3 5
2 3 5 6 7
```

### 输出

```
2```

# 题解

## 作者：Panda_hu (赞：619)

# 题解

## step 1理解题意

在做这道题之前，一定要理解好题意，有一个需要特别注意注意的地方：

**青蛙不是一定要跳到石头上**[嗯...这一点坑了我好久]而是指青蛙尽量不踩石头的情况下还要跳到多少个石头上[语文渣求原谅]。

## step 2状态转移方程

这是一个比较简单方程式。

首先设f[i]为在i点上的最少踩石子数则在前面(i-s)到(i-t)的点都可以改变i点的值,因此我们可以取f[i-s]-f[i-t]之中的最小值，另外如果有石头就加上1，如果没有就不加值，这里我们直接用flag[i]表示该点有无石头(有则为1，无则为0)。

因此我们可以写出状态转移方程式:$f[i]=\min(f[i-j]+flag[i]|s<=j<=t)$

## step 3路径压缩

实际上，这题还没完呢...如果我们定义一个f[10^9]的数组，这肯定是会爆内存的——所以...**[我就放弃了这道题]**[额，可能吗]..因此我们需要使用一种方法，使得这里采用一种最合适的方法——路径压缩(其实还有其他更(bu)优(kao)秀(pu)方法的)，目的是要找到两石同相隔较长时直接缩短的方法。

**[前方高能,请数学学科恐惧症患者尽快撤离!!]**:

假设每次走p或者p+1步.我们知道$\gcd(p,p+1)$=1.

由扩展欧几里得可知，对于二元一次方程组：

$px+(p+1)y=\gcd(p,p+1)$是有整数解的，即可得：$px+(p+1)y=s$是一定有整数解的。

设$px+(p+1)y=s$的解为：$x=x0+(p+1)t,y=y0-pt$。令$0<=x<=p$(通过增减t个p+1来实现)，$s>p*(p+1)-1$,

则有：$y=\frac{s-px}{p+1}>=\frac{s-p^2}{p+1}>\frac{p*(p+1)-1-px}{p+1}>=0$

即表示，当 $s>=p*(p+1)$ 时，$px+(p+1)y=s$ 有两个非负整数解，每次走p步或者 $p+1$ 步，$p*(p+1)$ 之后的地方均能够到达。

如果两个石子之间的距离大于 $p*(p+1)$ ，那么就可以直接将他们之间的距离更改为 $p*(p+1)$ 。

综上，得到压缩路径的方法：若两个石子之间的距离> $t*(t-1)$ ，则将他们的距离更改为 $t*(t-1)$ 。

因为 $t<=10$ ，因此我们可以直接将大于10\*9的距离直接化为90.

但是要注意，对于 $s=t$ 这种特殊情况，这种方法是不成立的应为在这种情况下，每次是不能够走p+1步的，因此需要另外特殊判断。

方程如下:

$f[i]=f[i-1]+(i \mod s ==0)$

# 代码实现


```cpp
#include<iostream> 
#include<cstdio> 
#include<algorithm> 
#include<climits> 
using namespace std; 
int f[10005],far[10005],a[10005],flag[10005],p,s,t,n; 
int main() 
{ 
    scanf("%d",&p); 
    scanf("%d%d%d",&s,&t,&n); 
    if(s==t) //特殊情况判断
    { 
        int cont=0,qaq; 
        for(int i=1;i<=n;++i)scanf("%d",&qaq),cont+=((qaq%s)==0); 
        printf("%d\n",cont);return 0; 
    } 
    for(int i=1;i<=n;i++)scanf("%d",&a[i]); 
    sort(a+1,a+n+1);a[0]=0;f[0]=0; 
    far[n+1]=min(p-a[n],100);p=0; //计算终点与最后一个点的距离
    for(int i=1;i<=n;i++)far[i]=min(a[i]-a[i-1],90),p+=far[i],flag[p]=1; //缩短路径，存储缩短后的终点距离并标记石头位置
    p+=far[n+1]; 
    for(int i=1;i<=p+9;i++) 
    { 
        f[i]=INT_MAX-1; 
        for(int j=s;j<=t;j++)if(i>=j)f[i]=min(f[i],f[i-j]+flag[i]); 
    } 
    int minn=INT_MAX-1; 
    for(int i=p;i<=p+9;i++) //因为青蛙可以跳出边界且t<=10因此再终点后p-p+9中取最小值
    minn=min(minn,f[i]); 
    printf("%d",minn); 
} 
```
[CSDN](http://blog.csdn.net/qq\_34940287/article/details/77494073)

2020.7.2 UPD:想不到这篇博客会收到这么多的好评...这篇博客是我初学动态规划的时候写的，并且当时也还没有考NOIP2017。所以存在很多理解不够深刻之处。

  本题需要我们需要求得一个最小的值$t$使得对于所有$s>t$的$px+(p+1)y=s$一定有非负整数解。根据NOIP2017提高组D1T1的结论，我们可以知道这个数为$t=p(p+1)-p-(p+1)$。
  由于本题的最大步长为$10$，因此$t_{max}=9\times10-9-10=71$。因此本题我们的压缩距离最小可以达到$71$(在本文做法中不是$72$)。

  先前对于同学们的误导，笔者深表歉意。

---

## 作者：yzpyzp (赞：242)

貌似某神犇把几篇题解都hack了~~（惶恐）~~。

本蒟蒻来发篇题解供大家参考（写的不好的地方请谅解）。

基本的思路很简单：

第一眼看这题的同学应该首先立即就会想到动规吧。~~（显而易见）~~

因为它满足无后效性。

当前的每一个状态都可以由之前的状态转移过来。

当前的决策对之后都不会产生影响。

$\color{blue}But$动态规划最重要的就是状态转移方程。

恩，经过一段思考我们不难得出以下几条结论：

1. 当前的点$i$只与它前$i-j$个点有关($s\leq j\leq t$)

2. 如果当前的点是石头那么就是所有到达该点的位置所需踩的最少石头数加$1$

经过上述的分析我们就可以得出我们的状态转移方程了：

- 该点为石头：
 $dp[i] = min(dp[i],dp[i-j] +1)(s\leq j\leq t)$
 
- 该点不为石头：
 $dp[i] = min(dp[i],dp[i-j])(s\leq j\leq t)$

分析到这好像差不多了。

等等！

当我们猛然看到数据范围时就会发现这题没有这么简单：
$L\leq 10^9$

这么大的数据范围用数组存肯定存不下。

但是我们却惊奇发现石头数很小。

怎么办呢？先让我们来看看这张图：

![](https://cdn.luogu.com.cn/upload/pic/42022.png)
其中$[S_i,T_i]$就是青蛙可以到的区间。
可以发现当$\color{Red}\textbf{s < t}$时，
$s$和$t$一定会重合（当距离为$lcm(s,t)$即$s$，$t$的最小公倍数时）
而这以后的每个点都可以到达，
所以我们只需将每两个石头超过 $s\times t$ 的距离缩成$s \times t$就可以了当然如果你有疑虑的话也可以开大一点。

当$s = t$时我们只需枚举每个石头的坐标是否为$s$的倍数即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 150;
const int maxl = 300 * 105;
//其实开90 * 105就可以了；
int L,s,t,m,stone[maxn],a[maxn],dp[maxl],base;
//stone就是石头的初始位置；a为我们将石头初始化后的石头位置；
bool vis[maxl];
//标记一下坐标上的该点是否为石头；
int main()
{
    ios::sync_with_stdio(0);
//  关掉同步，加快cin的速度
    cin >> L;
    cin >> s >> t >> m;
    base = s * t;
    for(int i = 1 ; i <= m ; ++ i)
        cin >> stone[i];
    sort(stone + 1,stone + 1 + m);
//  判段s == t的情况
    if(s == t){
        int cnt =0;
        for(int i = 1 ; i <= m ; ++ i)
            if(stone[i] % s == 0)cnt++;
        cout << cnt << endl;
        return 0;
    }
    for(int i = 1 ; i <= m ; ++ i)
    {
//      离散化过程
        int d = stone[i] - stone[i - 1];
        if(d >= base)d = base;
        a[i] = a[i - 1] + d;
        vis[a[i]] = 1;
    }
    L = a[m] + base;
//  将L变成最后一个石头的位置+s*t
//  如果L - a[m] >= s * t就缩成s * t
//  如果L - a[m] <= s * t就加上一个数使得它等于这个距离因为青蛙可能跳出独木桥
    memset(dp,0x7f,sizeof(dp));
    dp[0] = 0;
//  初始化到原点寻最少踩0个石头
    for(int i = 1 ; i <= L ; ++ i)
        for(int j = s ; j <= t ; ++ j)
        {
            if(i - j >= 0)
            {
                if(vis[i])dp[i] = min(dp[i - j] + 1,dp[i]);
                else dp[i] = min(dp[i - j],dp[i]);
            }
        }
    int ans = maxn;
//  给答案赋一个较大的初值
    for(int i = a[m] ; i <= L ; ++ i)
        ans = min(ans,dp[i]);
    cout << ans << endl;
    return 0;
}

```

---

## 作者：wjyyy (赞：76)

这个题数据范围是$10^9$，显然是要离散化的，最方便的办法是缩点，因为最多只有$100$个石头且一步最远只能跳$10$个单位。

在这里介绍几个缩点方法以及说明：

首先是$2520$缩，$2520$是$\text{lcm}(1,...,10)$，因此从一个点出发，无论青蛙能跳的距离是多少，它一定可以到达距离$2520$处。所以在前方$2520$没有石头时，可以将当前点向后移$2520$或者将后面的点向前移$2520$；

还有一种是$72$缩，因为$1\sim 10$这些数字最大不能表示的数是$71$（见NOIP2017D1T1小凯的疑惑），而如果前方$71$距离以内没有石头就可以缩了。

我写的是动态缩点，就是判断当前点前面$t$个点（$t$同题意）是否都相同，如果都相同，说明这个点从前面这$s-t$的点转移都是相同情况，这样递推到下一个石头之前都是一样的，因此可以将石头移到这个点的下一个点（也可以是这个点）这样就把该缩的点都缩了，**不需要借助任何数论知识**，但是当$s==t$时需要特判。

### Code:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
int f[10000002];
int a[102];
int main()
{
    int l,s,t,m;
    scanf("%d%d%d%d",&l,&s,&t,&m);
    for(int i=1;i<=m;i++)
        scanf("%d",&a[i]);
    a[m+1]=l;
    std::sort(a+1,a+m+2);//石头给出的顺序不一定是升序
    if(s==t)
    {
        int sum=0;
        for(int i=1;i<=m;i++)
            if(a[i]%s==0)
                sum++;
        printf("%d\n",sum);
        return 0;
    }
    memset(f,0x3f,sizeof(f));
    f[0]=0;
    int sam=0,p=0;//sam存储到现在有几个f相同,p存当前是第几颗石头
    bool flag;
    for(int i=1;i<=a[m+1];i++)
    {
        if(sam>=t)//缩点操作
        {
            sam=1;
            int d=a[p+1]-i;
            for(int j=p+1;j<=m+1;j++)
                a[j]-=d;
        }
        flag=false;
        if(i==a[p+1])
        {
            p++;
            flag=true;//声明当前是石头
        }
        for(int j=s;j<=t;j++)
            if(i-j>=0&&f[i]>f[i-j])
                f[i]=f[i-j]+(flag?1:0);
        if(f[i]==f[i-1])
            sam++;
        else
            sam=1;
    }
    int minn=f[a[m+1]]-1;//因为最后一个点被当成石头了
    for(int i=a[m+1]-s;i<=a[m+1];i++)
        if(f[i]<minn)
            minn=f[i];
    printf("%d\n",minn>0?minn:0);
    return 0;
}

```

---

## 作者：Actinoi (赞：64)

## NOIP2005 提高组——过河

​																																					$by - Actinoi $																									$2019/5/30$

## 为获取最佳阅读效果，建议访问[Actinoi's blog:过河](https://www.actinoi.com/2019/05/30/noip2005提高组——过河/)

​	&emsp;观察数据，我们发现，独木桥的长度 $L\leq10^9$ ，而石子的数量最多只有 $100$ 个。因此，我们便可以考虑用离散化来解决这道题目。

​	&emsp;我们用 $stone$ 数组来存储每个石子的坐标，读入之后进行离散化操作。

### 离散化具体实现过程

​	&emsp;我们并不知道输入是不是按从小到大有序输入的，因此我们先从小到大排序。

&emsp;排完序之后，我们从第一个石子开始进行离散化。

​&emsp;若第 $i$ 石子与第 $i - 1$ 个石子之间的距离大于 $s \times t$ ，我们便可以将这颗石子与上一颗石子的距离简化为 $(stone[i] - stone[i - 1]) \% t + t * s$ ，这样可以将桥长 $L$ 压缩到 $10000$ 以内。然后用 $bridge$ 数组来存储离散化之后桥上石子的分布情况。

![1.jpg](https://i.loli.net/2019/06/06/5cf90c6d7749283226.png)

> 如图，我们设stone[1] = 3, stone[2] = 10, s = 1, t = 2的话，便会得到上图。然后我们压缩 stone[2] 与 stone[1] 之间的距离，便会得到下图的 birdge[2] 。

![2.jpg](https://i.loli.net/2019/06/06/5cf90c6d9650a35158.png)

> 那么，这为什么是正确的呢？我们不难发现，stone[2] 减去 n 个 t 之后就可以得到 bridge[2] ，所以说，凡是能够到达 stone[2] 的点也一定可以到达 bridge[2] ，所以这个思路是正确的。

​&emsp;之后，我们用 $identifier$ 数组存储离散化之后的桥长，用 $sum$ 数组存储跳到桥上每一点最少需要踩到的石子数。我们从跳跃的最小距离 $s$ 枚举到最大距离 $t$ ，用变量 $j$ 存储所枚举的距离，我们很容易得到状态转移方程 $sum[i] = min(sum[i], sum[i - j] + bridge[i])$ 。但是，从离散化之后桥上第 $1$ 个点开始计算最小经过的石子数，但是要计算到哪呢？观察下图，我们可以发现，在$identifier$ ～ $identifier + t$ 之内都可以跳到终点，因此计算范围为 $1$ ～  $identifier + t $ 。

![3.jpg](https://i.loli.net/2019/06/06/5cf90c6dadc3987322.png)

​	&emsp;剩下的就很简单啦，通过上面的分析，答案就在 $identifier$ ~ $identifier + t $ 之内，因此我们枚举这个区间内的 $sum$ 值，找出最小值，这便是我们的答案辣!

最后附上代码:


```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int stone[101], sum[10001];
bool bridge[100001]; //存储离散化之后桥上石子的分布情况
int main(){
    int l, s, t, m; //桥长，青蛙一次跳跃的最小距离，最大距离及桥上石子的个数
    cin >> l >> s >> t >> m;
    memset(sum, 0x3f, sizeof(sum)); //初始化sum数组
    for(int i = 1; i <= m; i++)
        cin >> stone[i];
    sort(stone, stone + m + 2);
    int identifier = 0;
    for (int i = 1; i <= m + 1; i++) {
        if (stone[i] - stone[i - 1] <= t * s)
            identifier += stone[i] - stone[i - 1];
        else
            identifier += (stone[i] - stone[i - 1]) % t + t;
        bridge[identifier] = true;
    }
    sum[0] = 0;
    for (int i = 1; i <= identifier + t; i++)
        for (int j = s; j <= t; j++)
            if ((i - j) >= 0)
                sum[i] = min(sum[i], sum[i - j] + bridge[i]);
    int ans = 0x3f;
    for (int i = identifier; i <= identifier + t; i++)
        ans = min(ans, sum[i]);
    cout << ans;
    return 0;
}
```
## 若您有任何建议与纠正，欢迎提出！谢谢！



---

## 作者：kradcigam (赞：37)

[博客园体验更佳](https://www.cnblogs.com/zhaohaikun/p/12182689.html)

显然是 dp，是用 STL 当中的 [$map$](https://zhaohaikun.blog.luogu.org/solution-p1305) 可以做到 [30分](https://www.luogu.org/record/27685820)。

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int l,n,s,t;
map<int,bool>m;//记有没有石头
map<int,int>dp;//最少踩到石头的个数
int main(){
    cin>>l>>s>>t>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        m[x]=true;
    }
    for(int i=1;i<=l+t-1;i++){
    	dp[i]=INT_MAX/2;
    	for(int j=s;j<=t&&j<=i;j++)dp[i]=min(dp[i],dp[i-j]);//倒退
    	if(m[i])dp[i]++;
	}int s=dp[l];
	for(int i=l+1;i<=l+t-1;i++)s=min(s,dp[i]);
	cout<<s;
    return 0;
}
```
之后，我们该想一想如何 AC 这道题。

我们发现石头数量很少，而独木桥却很长。

![360截图18141224304435.png](https://i.loli.net/2019/11/23/MndaCKcbu7ZoUyi.png)

遇到这张图，我们可能还会选择暴力的方法。

![360截图170405117195111.png](https://i.loli.net/2019/11/23/6mNA9akXPqD7pQv.png)

但是遇到这张图，你还会用暴力吗？

空的地方就是随便走就行了，完全可以不用老老实实的去看，我们可以把路径压缩，更简单地说就是如果后面的一个石头与前面的一个石头距离太远，我们可以把后面一个石头推到前一个石头附近，至于这个量是多少呢，需要自己把握。

我自己还是觉得稍微保险一点，不要 TLE 就行了，所以我选择把这个数定在 $1000$，当然听同学说，他定的比较小也过了，这并没有关系。

所以，我们可以看代码了

```cpp
#include<bits/stdc++.h>
using namespace std;
int l,s,t,m,a[110],dp[100010],b[110];
bool x[100010];
int main(){
    cin>>l;
    cin>>s>>t>>m;
    for(int i=1;i<=m;i++)cin>>a[i];
    sort(a+1,a+1+m);
    if(s==t){//这个应该很简单，我上面没有说
        int ans=0;
        for(int i=1;i<=m;i++)
            if(a[i]%s==0)ans++;//如果会经过它，答案+1
        cout<<ans;//输出
        return 0;
    }
    for(int i=1;i<=m;i++)
        if(a[i]-a[i-1]>1000)b[i]=b[i-1]+1000;//注意啦，如果原来的距离小于1000，你要保持不变
        else b[i]=a[i]-a[i-1]+b[i-1];
	for(int i=1;i<=m;i++)x[b[i]]=true;//石头
	l=b[m];
    for(int i=1;i<=l+t-1;i++){
    	dp[i]=INT_MAX/2;
    	for(int j=s;j<=t&&j<=i;j++)dp[i]=min(dp[i],dp[i-j]);//转移状态
    	if(x[i])dp[i]++;
	}int ans=dp[l];
	for(int i=l;i<=l+t-1;i++)ans=min(ans,dp[i]);//打擂法求最小值
	cout<<ans;//输出
    return 0;
}
```

---

## 作者：Semsue (赞：24)

首先类似我们的走楼梯问题这题也可以定义这样一个状态 $dp_i$ 代表走到 $i$ 的最少石子数，显然有 $dp_i=\min\limits_{i-t \le j \le i-s}dp_j+a_i$（$a_i$ 代表 $i$ 有没有石子），但是我们发现这个 $L$ 太大了，不能直接做。

考虑一种对于递推数列的通用做法——矩阵乘法优化。这里 $s,t$ 都很小，所以可以构建一个 $t\times t$ 的矩阵，然后发现这是一个广义的矩阵乘法，可是我们发现当某个点是石子和不是石子的转移矩阵不同，而有石子的点最多只有 $m$ 个，所以我们可以按石子位置划分，然后每一段内快速幂没有石子的转移矩阵，再乘上当前有石子的转移矩阵。时间复杂度为 $O(t^3m\log{L})$。

对于样例的非石子转移矩阵大概是：

$$
\begin{gathered}
\begin{bmatrix} \infty & 0 & \infty \\ 0 & \infty & 0 \\ 0 & \infty & \infty\end{bmatrix}
\quad
\end{gathered}
$$

然后这道题就做完了，注意最后答案不是 $dp_L$ 而是 $\max\limits_{L \le i \le L + t - 1}dp_i$。

这种方法我觉得很套路，比什么路径压缩好想，另外也不会出一些玄学错误，虽然实现起来稍微麻烦一点。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
struct Matrix{
	int arr[11][11];
	int size;
}ans, g1, g2;
int L;
int s, t, m;
int p[101];
bool vis[11];
void init(Matrix &a) {
	for (int i = 1; i <= a.size; ++i) {
		for (int j = 1; j <= a.size; ++j) {
			a.arr[i][j] = inf;
		}
	}
}
Matrix mul(Matrix a, Matrix b) {
	Matrix ret;
	ret.size = a.size;
	init(ret);
	for (int i = 1; i <= a.size; ++i) {
		for (int k = 1; k <= a.size; ++k) {
			if (a.arr[i][k] == inf) continue;
			for (int j = 1; j <= a.size; ++j) {
				ret.arr[i][j] = min(ret.arr[i][j], a.arr[i][k] + b.arr[k][j]);
			}
		}
	}
	return ret;
}
Matrix ksm(Matrix a, int b) {
	Matrix ret;
	ret.size = a.size;
	init(ret);
	for (int i = 1; i <= ret.size; i++) ret.arr[i][i] = 0;
	while (b) {
		if (b & 1) ret = mul(ret, a);
		a = mul(a, a);
		b >>= 1;
	}
	return ret; 
}
int main() {
	scanf("%d", &L);
	scanf("%d%d%d", &s, &t, &m);
	for (int i = 1; i <= m; i++) scanf("%d", &p[i]);
	sort(p + 1, p + 1 + m);
	ans.size = t;
	init(ans);
	for (int i = 1; i <= m; i++) {
		if (p[i] < t) vis[p[i]] = true;
		else break;
	}
	ans.arr[1][t] = vis[0];
	for (int i = 1; i < t; i++) {
		for (int j = max(i - t, 0); j <= i - s; j++) {
			ans.arr[1][t - i] = min(ans.arr[1][t - i], ans.arr[1][t - j] + vis[i]);
		}
	}
	if (L < t) printf("%d", ans.arr[1][t - L]);
	else {
		g1.size = g2.size = t;
		init(g1); init(g2);
		for (int i = s; i <= t; i++) {
			g1.arr[i][1] = 0;
			g2.arr[i][1] = 1; 
		}
		for (int i = 2; i <= t; i++) {
			g1.arr[i - 1][i] = g2.arr[i - 1][i] = 0;
		}
		for (int i = 1; i <= m; i++) {
			if (p[i] < t) continue;
			ans = mul(ans, ksm(g1, p[i] - max(p[i - 1] + 1, t)));
			ans = mul(ans, g2);
		}
		ans = mul(ans, ksm(g1, L + t - 1 - p[m]));
		int out = inf;
		for (int i = 1; i <= t; i++) out = min(out, ans.arr[1][i]);
		printf("%d", out);
	}
	return 0;
}
```

---

## 作者：lixuean0408 (赞：5)

**蛙发现一个完全不同的方法！**
# 前言
**亲眼所见，亦非真实**

**一切恐惧，源于未知**
# 题意概括
作为一只笨拙的青蛙，我们每次跳跃的距离只能控制在 $s$ 到 $t$ 范围的 $（1\le S\le T\le10）$ 。我们要从岸的这边**单向**跳向岸的那边。算上起点、终点，总共有 $(L+1)$ 个可以落脚的点，而有 $m$ 个落脚点上有让蛙厌恶的石头。因此，我们要做的就是尽量避开石头跳到终点，并输出最少碰到的石头数！
# 思考
## 竭尽全力难以战胜
蛙发现，这题是 dp 题目，于是它写下模板代码，怀揣着兴奋提交了。

但是很可惜的是，蛙一分也没得到。

蛙很震惊！因为蛙发现这一题的落脚点数量竟然有足足的 $10^9$ 个，即使跳到蛙疲力尽也到达不了对岸！

但是与此同时，蛙也发现石头的数量很少，只有少少的 $100$ 个！
## 翱翔的诀窍
蛙在想，自己是不是可以想办法快速走过空旷（指不是石头）的落脚点呢？

蛙发现如果速度不变的话，是可以直接求出自己所有的落脚点的。也就是：$V_蛙 \times T_蛙 = S_蛙 $。嗯，速度不变的情况下，蛙可以直接通过判断石头的位置是不是 $V_蛙$ 的速度来解决。

而如果速度会变的话，自己为了最优可以用 $2$ 种甚至更多种速度，但是蛙想先算一算用不同的 $2$ 种速度可以到的点——毕竟就算有很多种速度，蛙也可以只用两种。

照着这个思路，蛙写出了下面两个程序，并且在 windows 平台下运行了他们：
```cpp
#include <bits/stdc++.h>
using namespace std ;
#include <windows.h>
#define For(i,s,e) for(ll i = s;i <= e;++ i)
typedef long long ll ;
bool dp[11][11][95] ;
int main(){
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE) ;
	for(ll i = 1;i <= 9;++ i)
		for(ll o = i + 1;o <= 10;++ o){
			dp[i][o][0] = 1 ;
			for(ll k = 1;k <= 90;++ k){
				if(k >= i)dp[i][o][k] |= dp[i][o][k - i] ;
				if(k >= o)dp[i][o][k] |= dp[i][o][k - o] ;
			}
			for(ll k = 1;k <= 90;++ k){
			    if(dp[i][o][k])SetConsoleTextAttribute(hConsole,FOREGROUND_RED | COMMON_LVB_REVERSE_VIDEO) ;
			    else SetConsoleTextAttribute(hConsole,
						FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | COMMON_LVB_REVERSE_VIDEO) ;
			    printf(" ") ;
			}
			printf("\n") ;
		}
	return 0 ;
}
```
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define For(i,s,e) for(ll i = s;i <= e;++ i)
typedef long long ll ;
vector<bool> a[11][11] ;
int main(){
	For(i,1,9)For(o,i + 1,10)a[i][o].push_back(1) ;
	ll ans = 0 ;
	while(ans <= 100000000){
		++ ans ;
		bool t = true ;
		ll fx = 0,fy = 0 ;
		For(i,1,9)For(o,i + 1,10){
			bool op = (((ans >= i) ? (a[i][o][ans - i]) : (0)) | 
					  ((ans >= o) ? (a[i][o][ans - o]) : (0))) ;
			if(!op && !fx)fx = i,fy = o ;
			t &= op ;
			a[i][o].push_back(op) ;
		}
		if(t){
			printf("%lld is answer!\n",ans) ;
			return 0 ;
		}
		//printf("when answer = %lld : failed at (%lld,%lld)\n",ans,fx,fy) ;
	}
	return 0 ;
}
```
第一个程序在控制台画出了一幅图：

![分布图](https://cdn.luogu.com.cn/upload/image_hosting/ji1r5sn9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这个图片里面，第 $i$ 行 $j$ 列的色块表示各样的两种**速度搭配**下能否从位置 $0$ 开始到达位置 $j$ 。
根据这个图片和第二个程序的输出，蛙得出了答案：从起点 $0$ 点开始，第 $60$ 及 $60$ 的的倍数都可以通过任意两种速度搭配到达！

蛙很兴奋！这意味着在多种速度的情况下，自己一定可以向前 $60,120,180...$ 等**60倍数**个单位长度！

也就是说，如果蛙在位置 $x$ ，那么它一定可以抵达 $x +60$，$x+120$等点！

那么，在空旷一段路（指没有石头）上，我们就可以以 $60$ 为单位快速向前跃进了！蛙将其称之为“翱翔”。

## 向蓝天进发！
不多废话，蛙制定了缜密的计划。

有了 **60翱翔法** ，蛙先利用 $m$ 块石头的坐标构建出了 $m$ 个区间，它们的左指针指向（**石头坐标-61**）的位置，右指针指向（**石头坐标+61**）的位置——石头左边要腾出来 **60** 个位置是因为距离小于 **60** 时不能够使用 **60翱翔法**。而右边留出 **60** 个位置是因为要在当前石头右侧时才能使用 **60翱翔法** ，这 **60** 个位置可以通过 **60翱翔法** 分别对应到下一个区间的左 **60** 位置部分。
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define For(i,l,r) for(ll i = l;i <= r;++ i)
#define RFor(i,l,r) for(ll i = l;i >= r;-- i)
typedef long long ll ;
const ll L = 1e9 + 5,S = 10 + 5,T = 10 + 5,M = 100 + 5 ;
struct R{ ll x,l,r ; } a[M] ;
bool cmp(R a,R b){ return a.x < b.x ; }
ll l,s,t,m ;
int main(){
  scanf("%lld%lld%lld%lld",&l,&s,&t,&m) ;
	For(i,1,m){
		ll x = 0 ;
		scanf("%lld",&x) ;
		a[i].x = x ;
		a[i].l = max(0LL,x - 61) ;
		a[i].r = min(l,x + 61) ;
	}
}
```
但是蛙发现这样构造出来的区间相互之间有可能重复，于是它通过先排序，再双指针的方法合并了重复的区间，并且写出了区间部分 dp 的代码和 **60翱翔法** 部分的代码——完美 AC ！
# 终抵幸福彼岸
蛙已经口干舌燥了，于是它把一份带有注释的代码留下后便去享受幸福了。
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define For(i,l,r) for(ll i = l;i <= r;++ i)
#define RFor(i,l,r) for(ll i = l;i >= r;-- i)
//可以减少重复性的、没有价值的代码  
typedef long long ll ;
const ll L = 1e9 + 5,S = 10 + 5,T = 10 + 5,M = 100 + 5 ;
//一些常量定义 
struct R{ ll x,l,r ; } a[M] ;
//石头区间结构体的定义，
//分别表示石头位置，左指针位置，右指针位置 
bool cmp(R a,R b){ return a.x < b.x ; }
//结构体比较函数 
ll l,s,t,m,le,ri,nowl,nowr ;
//一些变量 
vector<ll> use[2] ;
//滚动数组：上一个石头区间和当前的石头区间 
bool useNow,first = true ;
//标志当前区间是那个的标志位变量
//和判断是否是第一个区间的标志变量
//用于处理第一个区间没得“60翱翔法”的特殊情况 
void merge(ll le,ll ri){
	useNow = !useNow ;//下一个区间 
	ll kn = nowr - nowl ;//计算区间的大小（但是-1后的） 
	use[useNow].resize(kn + 1,0) ;//预留足够该区间的内存 
	if(!first){
		//如果不是首个区间 
		For(i,0,59)
			use[useNow][i] = use[!useNow][use[!useNow].size() - 60 + i] ;
		//60翱翔法！！！！！ 
		For(i,60,(a[le].x - nowl - 1)){
			use[useNow][i] = M ;
			For(o,s,t)if(i - o >= 0)
				use[useNow][i] = min(use[useNow][i],use[useNow][i - o]) ;
		}
		//处理至第一个区间处 
	}else{
		//是第一个区间 
		first = false ;//更改标志位 
		For(i,nowl,(a[le].x - 1))
			use[useNow][i - nowl] = M ;
		//先全部赋为大值 
		ll zero = nowl + (60 - nowl % 60) % 60 ;
		//找出左60个位置的60倍数点 
		use[useNow][zero - nowl] = 0 ;//设置60倍数点 
		//更新60倍数点左侧 
		RFor(i,zero - 1,nowl)
			For(o,s,t)if(o + i <= zero){
					if(!use[useNow][i + o - nowl]){//数组越界可不行 
						//由于是在第一个石头前，所以非M即0 
						use[useNow][i - nowl] = 0 ;
						break ;
					}
				}else break ;
		//更新60倍数点的左侧 
		For(i,zero + 1,(a[le].x - 1))
			For(o,s,t)if(i - o >= zero){//数组越界可不行 
					if(!use[useNow][i - o - nowl]){
						//同上 
						use[useNow][i - nowl] = 0 ;
						break ;
					}
				}else break ;
	}
	map<ll,ll> p ;
	//用于储存距离当前点s~t单位长度的点的 
	//“最小经过石头数” 
	For(i,s,t)if((a[le].x - i - nowl) >= 0)
		++ p[use[useNow][a[le].x - i - nowl]] ;
	//计算p 
	For(i,(a[le].x - nowl),kn){
		//从第一块石头开始遍历整个区间 
		if(p.size())use[useNow][i] = p.begin() -> first ;
		//如果自己是可达的，则取最小值 
		else use[useNow][i] = M ;
		//否则直接赋为大值 
		if(i + nowl == l){
			//如果到终点了，直接输出！ 
			printf("%lld",use[useNow][i]) ;
			exit(0) ;
		}
		//如果当前位置是石头，则更新le准备前往下一块石头 
		if(le <= ri && i + nowl == a[le].x)++ use[useNow][i],++ le ;
		//当前点的“最小经过石头”数加1 
		ll _end = i - t,_new = i + 1 - s ;
		//_end表示离（当前点）t距离的点
		//_new表示离（下一点）s距离的点 
		if(_end >= 0 && (-- p[use[useNow][_end]]) == 0)p.erase(use[useNow][_end]) ;
		//删除最远点 
		if(_new >= 0)++ p[use[useNow][_new]] ;
		//增加近点 
	}
	return ;
}
int main(){
	scanf("%lld%lld%lld%lld",&l,&s,&t,&m) ;
	//输入 
	For(i,1,m){
		ll x = 0 ;//临时变量 
		scanf("%lld",&x) ;//输入 
		a[i].x = x ;
		a[i].l = max(0LL,x - 61) ;
		a[i].r = min(l,x + 61) ;
		//构造区间 
	}
	if(s == t){
		//特判只有一种速度的情况 
		ll ans = 0 ;
		For(i,1,m)if(!(a[i].x % s))++ ans ;//计算 
		printf("%lld",ans) ;//输出 
		return 0 ;
	}
	sort(a + 1,a + m + 1,cmp) ;//排序 
	le = 1,ri = 1 ;
	//表示当前区间包含第le至ri的石头区间 
	nowl = a[1].l,nowr = a[1].r ;
	//当前区间的左右指针坐标 
	while(ri < m){
		if(a[++ ri].l <= nowr)nowr = a[ri].r ;
		//如果重叠，合并区间 
		else{
			merge(le,ri - 1) ;//计算 
			le = ri ;//更新 
			nowl = a[le].l,nowr = a[le].r ;
			//更新 
		}
	}
	merge(le,ri) ;//计算最后一个区间 
	//如果程序继续，代表最后一个区间没有包含终点 
	nowl = a[m + 1].l = max(l - 61,0LL) ;
	nowr = a[m + 1].r = a[m + 1].x = l ;
	le = m + 1,ri = m + 1 ;
	//计算终点区间 
	merge(le,ri) ;//计算答案 
	return 0 ;
}
```
# 尾声
**谢谢阅读！**

---

## 作者：WTY0111 (赞：2)

# P1052 [NOIP 2005 提高组] 过河 题解

## Part 1：题目解法

### step 1：读懂题意

青蛙尽量不要跳到石头上，但是在有些情况下无法避免不跳上去一个石头，本题需要输出这些无法避免的石头数的最小值。

### step 2：思考算法

本题要用什么算法呢？显然是动态规划，我们初步的想法一定是：遍历 $1$ 到 $L$ 每个点，对于第 $i$ 个点，我们把可以影响这个点的值的 ```dp[i-t]``` 至 ```dp[i-s]``` 取最小值，用 is_stone 数组表示一点是否有石头，$j$ 从 $t$ 到 $s$ 循环，于是状态转移方程就是 ```dp[i]=dp[i-j]+is_stone[i]```。

### step 3：优化算法以及检查算法是否可行

但是本题的 $L$ 在 $10^9$ 以内，开一个长度为 $10^9$ 的数组会炸空间，于是最直接的优化空间的方式就是缩点：

- $2520$ 缩，因为 $2520$ 是 $\operatorname{lcm(1,\ldots,10)}$，所以从任意点不管走几步都可以到 $2520$，所以如果前方 $2520$ 长度内无石头，就可以将终点往前缩 $2520$。

- $71$ 缩，$1\sim10$ 最大不能表示的数是 $71$ （原因见 [[NOIP2017 提高组] 小凯的疑惑](https://www.luogu.com.cn/problem/P3951)） ，所以如果前方 $71$ 长度内无石头，就可以将终点往前缩 $71$。

可以提前预处理一下，把该缩的点缩了，把该缩的点缩了。注意特判 $s=t$ 的情况。

## Part 2：Code

```cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll M = 4000005;
ll dp[M],s,t,len,truelen,m,stone[M],dis[M],is_stone[M];
int main(){
	memset(dp,0x3f,sizeof(dp)); 
	memset(dis,0x3f,sizeof(dis));
	dp[0]=0;  //长度为0时表示起点=终点，答案为0
	cin>>len>>s>>t>>m;
	for(ll i=1;i<=m;i++) cin>>stone[i];
	sort(stone+1,stone+m+1);  //先按石头先后排序，因为题目没有保证输入时按顺序
	if(s==t){  //特判s=t的情况，如果stone[i]%s==0，说明走这一步时必须跳到第i个石头上
		ll sum=0;
		for(ll i=1;i<=m;i++){
			if(stone[i]%s==0) ++sum;
		}
		cout<<sum;
		return 0;
	}
	dis[m+1]=min(400LL,len-stone[m]); //写400LL表示把400转成 long long 类型，否则无法与 long long 类型取最小值
	for(ll i=1;i<=m;i++){
		dis[i]=min(stone[i]-stone[i-1],400LL);//如果距离太长就缩点
		truelen+=dis[i];
		is_stone[truelen]=1;
	} //truelen是缩点后的长度
	len+=dis[m+1];
	for(ll i=1;i<truelen+10;i++){
		for(ll j=s;j<=t;j++){
			if(i-j>=0) dp[i]=min(dp[i],dp[i-j]+is_stone[i]);  //i-j>=0 判断 i>=j 的情况，避免减成负数RE
		}
	}
	ll ans=M*10; //赋较大初始值
	for(ll i=truelen;i<truelen+10;i++){ //因为青蛙最多跳到终点位置+10，减去终点自己，就是从truelen到truelen+9可能为答案，把这些候选取最小值就是最终答案
		ans=min(ans,dp[i]);
	}
	cout<<ans<<endl;
	return 0;
}

```

### 完结撒花！

---

## 作者：qhr2023 (赞：1)

## solution

线性 dp。

对于 $L \le 10^4$ 这部分，设 $f_i$ 表示走到点 $i$ 时需踩到的最少石子数，$x_i$ 表示点 $i$ 是否是石子，类似爬楼梯问题，我们从 $s$ 到 $t$ 枚举 $j$，再注意一下 $j$ 的上界。

转移：$$\begin{aligned} f_i=\min_{s \le j \le \min(t, i)} f_{i-j} + x_i \end{aligned}$$。

对于满分做法，发现 $L$ 很大，但是石子数很少。若两个石子距离很远，它们之间具体是怎么转移的是不重要的，我们可以将两个距离很远的石头移近一些，这个距离我选择了 $5000$，即若两点距离超过 $5000$，就将后面的点移到距前面的点 $5000$ 的位置。

注意要特判掉 $s=t$ 的情况。不要忘了将点的距离排序，题目没有保证有序。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int l, s, t, m, a[105], b[105], x[500005], f[500005], ans=1e9;
int main () {
	cin >> l >> s >> t >> m;
	for (int i=1; i<=m; ++i)
		cin >> a[i];
	sort(a+1, a+m+1);
	if (s==t) {
		for (int i=1; i<=m; ++i)
			ans+=(a[i]%s==0); 
		cout << ans-1e9;
		return 0;
	}
	for (int i=1; i<=m; x[b[i]]=1, ++i) 
		b[i]=b[i-1]+min(a[i]-a[i-1], 5000);
	memset(f, 0x3f, sizeof f);
	f[0]=0;
	for (int i=1; i<=b[m]+t-1; f[i]+=x[i], ++i)
		for (int j=s; j<=min(t, i); ++j)
			f[i]=min(f[i], f[i-j]);
	for (int i=b[m]; i<=b[m]+t-1; ++i)
		ans=min(ans, f[i]);
	cout << ans;
	return 0;
}
```

---

## 作者：Takato_ (赞：0)

## 题意理解与思路
给定一条线段的长度，青蛙的最小、最大跳跃长度，和每个石子的距离。求青蛙尽量不踩石头的情况下还要跳到多少个石头上。   

很明显的动态规划，但当我们下翻到数据范围并看到 $1\le{L}\le{10^9}$ 时，我们决定~~打暴力~~压缩路径。  
## 做法分析
先不考虑 $L$ 的长度。
根据对题目的简单分析，我们很容易可以推出Dp方程：因为对于一个位置 $i$，只能从 $[i-t,i-s]$ 这个区间跳过来。故设 $dp_i$ 表示走到位置 $i$ 时，踩到的石头个数的最小值，可得转移方程：
$$dp_i \gets \min(dp_i,dp_{x-j}+st_i)(j\in[S,T])$$ 
其中 $st_i$ 表示第 $i$ 个位置是否有石头。  

这时考虑 $L$,分两种情况讨论：
* 当 $S = T$。此时青蛙一次只能跳一步，只有一种跳法。石头位置是 $S$ 整数倍的一定会跳到，否则一定不会跳，直接遍历一遍所有石头，判断石子是否是 $S$ 的倍数即可。
- 当 $S \ne T$。因为 $1\le{L}\le{10^9}$，但 $M$ 只是在 100 以内，且 $1\le{S}\le{T}\le{10}$，当跳过第 $i$ 个石头时，此时一定在 $i$ 右侧十个单位以内；当下一步跳过第 $i+1$ 个石头时，青蛙一定在 $i+1$ 的十个单位以内。所以当中间部分的长度大于 100 时可以将线段平移，长度看作 100，结果相同（具体证明可以看第一篇）。
 
此时的时间复杂度 $\mathcal{O}(m \cdot T^3)$。  
放上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,s,t,m,a[10010],f[10010],st[10010],ans=1e15,lst,k;
signed main(){
	cin>>n>>s>>t>>m;
	for(int i=1;i<=m;i++) cin>>a[i];
	if(s==t){
        ans=0;
        for(int i=1;i<=m;++i) if(a[i]%s==0) ans++;
        cout<<ans<<endl;
    }else{
    	sort(a+1,a+m+1);
        for(int i=0;i<m;i++){
            for(int j=0;j<min(a[i]-lst,10*1ll);j++) st[++k]=0;//大于100就压缩路径 
            st[k]=1,lst=a[i];
        }for(int i=1;i<=k+10;i++){ 
	        f[i]=1e15; 
	        for(int j=s;j<=t;j++) if(i-j>=0) f[i]=min(f[i],f[i-j]+st[i]); 
	    }for(int i=k+1;i<=k+10;i++) ans=min(ans,f[i]); 
	    cout<<ans;
	}
}
```

---


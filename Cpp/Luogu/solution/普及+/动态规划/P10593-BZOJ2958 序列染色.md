# BZOJ2958 序列染色

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

## 题目描述

给出一个长度为 $n$，由 $\tt B,W,X$ 三种字符组成的字符串 $S$，你需要把每一个 $\tt X$ 染成 $\tt B$ 或 $\tt W$ 中的一个。

对于给出的 $k$，问由多少种染色方式，使得存在整数 $a,b,c,d$ 满足：
- $1\leq a\leq b<c\leq d\leq n$；
- $b=a+k-1$，$d=c+k-1$;
- $S_a=S_{a+1}=\dots=S_b=\tt B$；
- $S_c=S_{c+1}=\dots=S_d=\tt W$；

由于方法可能很多，你只需输出最后的答案对 $10^9+7$ 取模的结果。

## 说明/提示

对于 $20\%$ 的数据，$1\leq n\leq 20$；

对于 $50\%$ 的数据，$1\leq n\leq 2000$；

对于 $100\%$ 的数据，$1\leq n,k\leq 10^6$。

## 样例 #1

### 输入

```
5 2
XXXXX```

### 输出

```
4```

# 题解

## 作者：SunsetLake (赞：4)

## 思路

$n,k$ 都到了 $10^6$ 的级别，肯定不能都放进 dp 状态里。但是又必须要处理长为 $k$ 的子串，于是可以考虑用是否存在来 dp。

设 $f_{i,0/1}$ 表示填完前 $i$ 个字符，最后一个填的是 $\text B / \text W$，不存在长为 $k$ 的 $\text B$ 子串的方案数。同理 $g_{i,0/1}$ 表示存在 $\text B$ 子串但是不存在 $\text W$ 子串的方案数，$h_{i,0/1}$ 表示既存在 $\text B$ 又存在 $\text W$ 的方案数。那么答案就是 $h_{n,0} + h_{n,1}$。

首先，若第 $i$ 位能填 $\text B$，那么 $f_{i,0},g_{i,0},h_{i,0}$ 都能从 $i - 1$ 直接转移过来，填 $\text W$ 同理。但仅仅这样转移是不够的，并没有把长为 $k$ 的子串考虑进来。所以对于 $i - k + 1 \sim i$ 能全填 $\text B$ 的 $i$，$f_{i,0}$ 一定是算多了的（状态定义是不存在长为 $k$ 的 $\text B$ 子串），$g_{i,0}$ 又算少了，故需要 $f_{i,0} \gets f_{i,0} - f_{i - k,1},g_{i,0} \gets g_{i,0} + f_{i - k,1}$。$f_{i - k}$ 第二维不能为 $0$ 是因为那样会将长度 $> k$ 的子串重复计算。同理对于 $i - k + 1 \sim i$ 能全填 $\text W$ 的 $i$，$g_{i,1} \gets g_{i,1} - g_{i - k,0},h_{i,1} \gets h_{i,1} + g_{i - k,0}$。这样就能不重不漏的转移了。

判断 $i - k + 1 \sim i$ 是否能拼成 $\text B / \text W$ 子串使用前缀和即可。复杂度 $O(n)$。

## code


```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
using namespace std;
const int N = 1e6 + 5,mod = 1e9 + 7;
int n,k;
int f[N][2],g[N][2],h[N][2];
int sum[N][2];
//f : no B
//g : B but no W
//h : B and W
//0 -> B  1 -> W
char s[N];
int main(){
	cin >> n >> k;
	cin >> (s + 1);
	for(int i = 1;i <= n;++ i){
		sum[i][0] = sum[i - 1][0];
		sum[i][1] = sum[i - 1][1];
		if(s[i] == 'B') sum[i][0] ++;
		if(s[i] == 'W') sum[i][1] ++;
	}
	f[0][1] = 1;
	for(int i = 1;i <= n;++ i){
		if(s[i] != 'W')
			f[i][0] = (f[i - 1][0] + f[i - 1][1]) % mod,
			g[i][0] = (g[i - 1][0] + g[i - 1][1]) % mod,
			h[i][0] = (h[i - 1][0] + h[i - 1][1]) % mod;
		if(s[i] != 'B')
			f[i][1] = (f[i - 1][0] + f[i - 1][1]) % mod,
			g[i][1] = (g[i - 1][0] + g[i - 1][1]) % mod,
			h[i][1] = (h[i - 1][0] + h[i - 1][1]) % mod;
		if(i >= k && sum[i][1] == sum[i - k][1])//i - k + 1 -> i 能全填 B（即不存在 W）
			f[i][0] = (f[i][0] - f[i - k][1] + mod) % mod,
			g[i][0] = (g[i][0] + f[i - k][1]) % mod;
		if(i >= k && sum[i][0] == sum[i - k][0])//i - k + 1 -> i 能全填 W
			g[i][1] = (g[i][1] - g[i - k][0] + mod) % mod,
			h[i][1] = (h[i][1] + g[i - k][0]) % mod;
	}
	cout << (h[n][0] + h[n][1]) % mod;
	return 0;
}
```

---

## 作者：_Hugoi_ (赞：3)

好题。

为什么只有绿？

### 题意

给定一个长度为 $n$ 的只包含 'W','X','B' 的字符串，其中 'X' 必须变成 'W' 或 'B'。

给定 $k$,如果一个字符串中存在长为 $k$ 的都为 'W' 的连续段，并且这个连续段之前存在长为 $k$ 的都为 'B' 的连续段，那么这个字符串就是合法的。

求将所有 'X' 变成 'W' 或 'B' 后合法字符串个数。

### 思路

先考虑 'B' 段。

想一想怎么算不会算重。

我们只在每一个长为 $k$ 的 'B' 段第一次出现时考虑，这样就不会算重了。

于是我们设 $f_i$ 表示考虑前 $i$ 个位置，其中 $i$ 这个位置是字符串中第一个长度为 $k$ 的连续 'B' 段的结尾，这样的字符串的方案数。

怎么转移呢？

先判断 $i-k+1\sim i$ 是否可以全变成 'B'，并且要求 $i-k$ 位置不是 'B'，前 $i-k$ 个位置中不存在长为 $k$ 的 'B' 段。

于是设 $g_i$ 表示考虑前 $i$ 个位置，并且前 $i$ 个位置没有长为 $k$ 的 'B' 段的方案数。

于是 $f$ 就能从 $g$ 转移了。

如果满足上述条件并且 $i-k$ 位置为 'X'，此时这个 'X' 必须变成 'W'，那么：

$f_i=g_{i-k-1}$

否则：

$f_i=g_{i-k}$

那 $g$ 怎么算？

其实 $g$ 也可以从 $f$ 转移过来的。

我们可以算出到当前位置为止的总方案数，再减去所有合法的即可。

也就是：

$g_i=2^{prex_i}-\sum_{j=1}^{i}f_j$

前缀和优化一下即可。

但细想一下，其实这里会出问题的，本人就被卡了好久。

想明白了么？

$f_i$ 是只关心前面，不关心后面填啥的方案数，这如果直接贡献到后面的 $g_j$ 可能会算少，因为 $i\sim j$ 之间也有可能存在 'X'。

于是在算前缀和的时候多处理一下就行了。

这样对于 'B' 段的dp就做完了。

同理，对于 'W' 段从后往前做一次即可。

怎么算答案?

现在设 'B' 段的 $f$ 数组为 $f1$，'W' 段的 $f$ 数组为 $f2$。

$ans=\sum_{i=1}^{n}\sum_{j=i+1}^{n}f1_i\times f2_j\times 2^{prex_j-prex_{i-1}}$

这是 $O(n^2)$ 的，但是可优化到 $O(n)$。

枚举 $j$，记录一个 $sum$ 即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=1e9+7;
int n,f1[N],f2[N],g1[N],g2[N],k,s1[N],s2[N],pw[N],prex[N],lstw[N],sufx[N],nxtb[N],ans;
string c;
signed main(){
#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k>>c;
	pw[0]=1;
	for(int i=1;i<=n;i++) pw[i]=pw[i-1]*2%mod;
	c=' '+c;
	int lst=0;
	for(int i=1;i<=n;i++){
		if(c[i]=='W') lst=i;
		prex[i]=prex[i-1]+(c[i]=='X');
		lstw[i]=lst;
	}
	for(int i=0;i<k;i++) g1[i]=pw[prex[i]];
	for(int i=k;i<=n;i++){
		s1[i]=(s1[i-1]*(c[i]=='X'?2:1))%mod;
		if(i-lstw[i]>=k){
			if(c[i-k]!='B'){
				if(c[i-k]=='X') f1[i]=g1[i-k-1];
				else f1[i]=g1[i-k];
				(s1[i]+=f1[i])%=mod;
			}
		}
		g1[i]=(pw[prex[i]]-s1[i]+mod)%mod;
	}
	int nxt=n+1;
	for(int i=n;i>=1;i--){
		if(c[i]=='B') nxt=i;
		sufx[i]=sufx[i+1]+(c[i]=='X');
		nxtb[i]=nxt;
	}
	for(int i=n+1;i>n-k+1;i--) g2[i]=pw[sufx[i]];
	for(int i=n-k+1;i>=1;i--){
		s2[i]=s2[i+1]*(c[i]=='X'?2:1)%mod;
		if(nxtb[i]-i>=k){
			if(c[i+k]!='W'){
				if(c[i+k]=='X') f2[i]=g2[i+k+1];
				else f2[i]=g2[i+k];
				(s2[i]+=f2[i])%=mod;
			}
		}
		g2[i]=(pw[sufx[i]]-s2[i]+mod)%mod;
	}
	int sum=0;
	for(int j=1;j<=n;j++){
		(ans+=sum*f2[j]%mod)%=mod;
		(sum*=(c[j]=='X'?2:1))%=mod;
		(sum+=f1[j])%=mod;
	}
	cout<<ans<<'\n';
}
```

---

## 作者：_•́へ•́╬_ (赞：2)

## 思路

dp 求出 $f_i$ 表示前 $i$ 个位置有多少种填法会产生长度至少为 $k$ 的连续 `B` 段，$g_i$ 表示后 $i$ 个位置的方案数。

具体做法是反过来求不会产生至少为 $k$ 的连续段的方案数。

然后边减点容斥拼起来即可。

## code

```cpp
#include<stdio.h>
#define N 1000009
#define mod 1000000007
int n,m,cnt[N],pw[N],f[N],g[N],ans;char s[N];
main()
{
	scanf("%d%d%s",&n,&m,s+1);
	pw[0]=1;
	for(int i=1;i<=n;++i)pw[i]=(pw[i-1]<<1)-mod,pw[i]>>31&&(pw[i]+=mod);
	for(int i=1;i<=n;++i)cnt[i]=cnt[i-1]+(s[i]=='X');
	f[0]=1;
	for(int i=1,now=0;i<=n;f[i]>>31&&(f[i]+=mod),++i)
	{
		if(s[i]=='W')now=0;
		else++now;
		f[i]=f[i-1]*(s[i]=='X'?2:1)%mod;
		if(now>=m)if(i==m)--f[i];
		else if(s[i-m]^'B')f[i]-=f[i-m-1];
	}
	for(int i=0;i<=n;f[i]>>31&&(f[i]+=mod),++i)
		f[i]=pw[cnt[i]]-f[i];
	g[n+1]=1;
	for(int i=n,now=0;i;g[i]>>31&&(g[i]+=mod),--i)
	{
		if(s[i]=='B')now=0;
		else++now;
		g[i]=g[i+1]*(s[i]=='X'?2:1)%mod;
		if(now>=m)if(i==n-m+1)--g[i];
		else if(s[i+m]^'W')g[i]-=g[i+m+1];
	}
	for(int i=1;i<=n+1;g[i]>>31&&(g[i]+=mod),++i)
		g[i]=pw[cnt[n]-cnt[i-1]]-g[i];
	for(int i=1;i<n;++i)ans=(ans+(long long)(f[i])*g[i+1])%mod;
	for(int i=2;i<n;++i)
		ans=(ans-(long long)(f[i-1])*g[i+1]*(s[i]=='X'?2:1)%mod+mod)%mod;
	printf("%d",ans);
}
```

---

## 作者：naught (赞：1)

[更好的阅读体验](https://www.cnblogs.com/naughty-naught/p/18532262)

# BZOJ2958 序列染色

## 题意

给出一个长度为 $n$，由 $\tt B,W,X$ 三种字符组成的字符串 $S$，你需要把每一个 $\tt X$ 染成 $\tt B$ 或 $\tt W$ 中的一个。

## Solution

字符串，染色，方案数，一眼 $dp$。

要求前半段是 `B`，后半段是 `W`。考虑容斥。

$f_{i, 0/1}, g_{i, 0/1}, h_{i, 0/1}$ 代表选到第 $i$ 位的方案，$0$ 代表填 `B`，$1$ 代表填 `W`，$f$ 代表没有长度为 $k$ 的带 `B` 字符串，$g$ 代表有长度为 $k$ 的带 `B` 字符串但没有长度为 $k$ 的带 `W` 字符串，$h$ 代表既有长度为 $k$ 的带 `B` 字符串，又有长度为 $k$ 的带 `B` 字符串。

显然，只有 `X` 和 `B` 可以填 `B`，只有 `X` 和 `W` 可以填 `W`。所以从 $i - 1$ 转移时只需分类讨论填 `B` 和 `W`，即：

$$

s_i \ne B:\\ f_{i, 0} = f_{i - 1, 0} + f_{i - 1, 1},\\ g_{i, 0} = g_{i - 1, 0} + g_{i - 1, 1},\\ h_{i, 0} = h_{i - 1, 0} + h_{i - 1, 1} 

\\

s_i \ne W:\\ f_{i, 1} = f_{i - 1, 0} + f_{i - 1, 1},\\ g_{i, 1} = g_{i - 1, 0} + g_{i - 1, 1},\\ h_{i, 1} = h_{i - 1, 0} + h_{i - 1, 1} 

$$

从 $i - k$ 转移时只需保证 $\left [ i - k, i \right ] $ 中可以全填 `B` 或 `W`，即：

$$

sum_{i, 0} = sum_{i - k, 0}:\\ g_{i, 1} = g_{i, 1} - g_{i - k, 0},\\ h_{i, 1} = h_{i, 1} + g_{i - k, 0}

\\

sum_{i, 1} = sum_{i - k, 1}:\\ f_{i, 0} = f_{i, 0} - f_{i - k, 1},\\ g_{i, 0} = g_{i, 0} + f_{i - k, 1}
$$


## Code

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <string.h>
#include <cstring>
using namespace std;

#define Maxn 1000005
#define Mod 1000000007
#define fo(i, l, r) for(int i = l; i <= r; ++i)

int n, k, a[Maxn], sum[Maxn][2], f[Maxn][2], g[Maxn][2], h[Maxn][2]; // f : no B, g : have B && no W, h : have B && have W
char s[Maxn];

void Input_data()
{  
    scanf("%d%d%s", &n, &k, (s + 1));
    fo(i, 1, n) sum[i][0] = sum[i - 1][0], sum[i][1] = sum[i - 1][1], (s[i] == 'B') && (++sum[i][0], a[i] = 1, 0), (s[i] == 'W') && (++sum[i][1], a[i] = 2, 0);
    // fo(i, 1, n) cerr << a[i] << " " << sum[i][0] << " " << sum[i][1] << " " << endl;
}

void Solve() 
{
    f[0][1] = 1;
    fo(i, 1, n) {
        if(a[i] != 2) f[i][0] = (f[i - 1][0] + f[i - 1][1]) % Mod, g[i][0] = (g[i - 1][0] + g[i - 1][1]) % Mod, h[i][0] = (h[i - 1][0] + h[i - 1][1]) % Mod;
        if(a[i] != 1) f[i][1] = (f[i - 1][0] + f[i - 1][1]) % Mod, g[i][1] = (g[i - 1][0] + g[i - 1][1]) % Mod, h[i][1] = (h[i - 1][0] + h[i - 1][1]) % Mod;
        // cerr << "f[" << i << "][0] : " << f[i][0] << " " << "f[" << i << "][1] : " << f[i][1] << endl;
        if(i < k) continue;
        if(sum[i][0] == sum[i - k][0]) g[i][1] = (g[i][1] - g[i - k][0] + Mod) % Mod, h[i][1] = (h[i][1] + g[i - k][0]) % Mod;
        if(sum[i][1] == sum[i - k][1]) f[i][0] = (f[i][0] - f[i - k][1] + Mod) % Mod, g[i][0] = (g[i][0] + f[i - k][1]) % Mod;
    }
}

void Print_ans()
{
    printf("%d", (h[n][0] + h[n][1]) % Mod);
}


int main()
{
    Input_data();

    Solve();

    Print_ans();

    return 0;
}
```

---


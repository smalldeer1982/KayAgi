# [NOIP 2006 提高组] 金明的预算方案

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件 | 附件 |
| :----------: | :----------: |
| 电脑 | 打印机，扫描仪 |
| 书柜 | 图书 |
| 书桌 | 台灯，文具 |
| 工作椅 | 无 |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。

NOIP 2006 提高组 第二题

## 样例 #1

### 输入

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

### 输出

```
2200```

# 题解

## 作者：Anguei (赞：237)

### 这道题看起来比较难，但是如果整理好思路，非常简单。
-----
## 基本思路
既然物品分为主件和附件两类，且每个主件最多包含两个附件，那么我们不妨枚举所有的主件。那么，对于每次枚举，会有五种情况：
+ 什么都不买
+ 只买主件
+ 买主件和第一个附件
+ 买主件和第二个附件
+ 买主件和两个附件

只要把这五种情况最终的价值算出来，取最大值就可以了。

-----
## 如何开数组？
建立两个二维数组 $V_{65,3}$ 和 $P_{65,3}$，含义如题目描述。$V_{i, j}$ 和 $P_{i, j}$ 分别表示第 $i$ 个物品的第 $j$ 个附件的价格和重要度（当 $j = 0$ 时，表示主件）。

-----
## 如何预处理数组？
+ 如果是主件，则令 $V_{i, 0}, P_{i, 0} = \_v, \_p$。
+ 如果是物品 $\_q$ 的第 $j$ 个附件，则令 $V_{q,j}, P_{q,j} = \_v, \_p$。

-----
## 动态转移方程
我们可以用 $F_j$ 表示花费钱数为 $j$ 时，价格与重要度乘积的最大值。
易知：
+ 当 $F_j \geqslant V_{i, 0}$ 时，$F_j = \max\{F_j, F_{j - V{i, 0}} + V_{i, 0} \times P_{i, 0}\}$
+ 当 $F_j \geqslant (V_{i, 0} + V_{i, 1})$ 时，$F_j = \max\{F_j, F_{j - V{i, 0} - V_{i, 1}} + V_{i, 0} \times P_{i, 0} + V_{i, 1} \times P_{i, 1}\}$
+ 当 $F_j \geqslant (V_{i, 0} + V_{i, 2})$ 时，$F_j = \max\{F_j, F_{j - V{i, 0} - V_{i, 2}} + V_{i, 0} \times P_{i, 0} + V_{i, 2} \times P_{i, 2}\}$
+ 当 $F_j \geqslant (V_{i, 0} + V_{i, 1} + V_{i, 2})$ 时，$F_j = \max\{F_j, F_{j - V{i, 0} - V_{i, 1} - V_{i, 2}} + V_{i, 0} \times P_{i, 0} + V_{i, 1} \times P_{i, 1} + V_{i, 2} \times P_{i, 2}\}$

列出了状态转移方程，套背包公式就好了

-----
## 代码简化
**难道你真的要在 $\texttt{for}$ 循环内部写如此麻烦的数组下标吗？不怕写晕自己吗？**

对于这种数组下标很乱的状态转移方程，最好把下标写短一点。怎么写短呢？

观察一下刚才列出的状态转移方程，发现 $V_{i, j1} + V_{i, j2}$ 等下标被写了很多遍。不妨使用函数来计算这些值，在下标里面写函数调用。不妨：
+ 定义 $\texttt{cost2(int x, int y)}$ 计算 $V_{i, x} + V_{i, y}$、
+ 定义 $\texttt{cost3(int x, int y, int z)}$ 计算 $V_{i, x} + V_{i, y} + V_{i, z}$、
+ 定义 $\texttt{rpp(int x)}$ 计算 $V_{i, x} \times P_{i, x}$

于是，状态转移方程可以简化成这样：
+ 当 $F_j \geqslant V_{i, 0}$ 时，$F_j = \max\{F_j, F_{j - V{i, 0}} + \texttt{rpp(0)}\}$
+ 当 $F_j \geqslant \texttt{cost2(0, 1)}$ 时，$F_j = \max\{F_j, F_{j - \texttt{cost2(0, 1)}} + \texttt{rpp(0)} + \texttt{rpp(1)}\}$
+ 当 $F_j \geqslant \texttt{cost2(0, 2)}$ 时，$F_j = \max\{F_j, F_{j - \texttt{cost2(0, 2)}} + \texttt{rpp(0)} + \texttt{rpp(2)}\}$
+ 当 $F_j \geqslant \texttt{cost3(0, 1, 2)}$ 时，$F_j = \max\{F_j, F_{j - \texttt{cost3(0, 1, 2)}} + \texttt{rpp(0)} + \texttt{rpp(1)} + \texttt{rpp(2)}\}$

这样就显得好多了。

-----
## 完整 AC 代码
```cpp
//【P1064】金明的预算方案 - 洛谷 - 100
#include <iostream>
#include <algorithm> 

const int kMaxN = 32000, kMaxM = 60; // 常量名前带 k，符合命名规范
int v[kMaxM + 5][3], p[kMaxM + 5][3];
int f[kMaxN + 5];

int main() {
	int n, m;
	std::cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		int _v, _p, _q;
		std::cin >> _v >> _p >> _q;
		if (!_q) { // 是主件 
			v[i][0] = _v;
			p[i][0] = _p;
		} else {
			if (v[_q][1] == 0) { // 是第一个附件 
				v[_q][1] = _v;
				p[_q][1] = _p;
			} else { // 是第二个附件 
				v[_q][2] = _v;
				p[_q][2] = _p;
			}
		}
	}
	
	for (int i = 1; i <= m; ++i)
		for (int j = n; j >= 0; --j) {
        	// 用 lambda 表达式代替函数定义（C++11 偷懒专用)
			auto cost2 = [v, p, i](int x, int y) { return v[i][x] + v[i][y]; };
			auto cost3 = [v, p, i](int x, int y, int z) { return v[i][x] + v[i][y] + v[i][z]; };
			auto rpp = [v, p, i](int x) { return v[i][x] * p[i][x]; };
			
			if (j >= v[i][0]) // 够买主件 
				f[j] = std::max(f[j], f[j - v[i][0]] + rpp(0));
			if (j >= cost2(0, 1)) // 还够买第一个附件 
				f[j] = std::max(f[j], f[j - cost2(0, 1)] + rpp(0) + rpp(1));
			if (j >= cost2(0, 2)) // 还够买第二个附件 
				f[j] = std::max(f[j], f[j - cost2(0, 2)] + rpp(0) + rpp(2));
			if (j >= cost3(0, 1, 2)) // 还够买两个附件 
				f[j] = std::max(f[j], f[j - cost3(0, 1, 2)] + rpp(0) + rpp(1) + rpp(2));
		}
		
	std::cout << f[n] << std::endl;
}
```

---

## 作者：wangkaiwei (赞：3)

金明啊金明，你是开心了，~~我是不会告诉你我交了三遍。~~

# 思路
我看到题的第一反应是按照主件进行分组，组内进行 $\texttt{01}$ 背包。但是，这只是一道 $\color{green}绿题$ 啊，不可能这么麻烦。注意到题目中说

> 每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。

所以对于每组只有 $5$ 种情况：  

- 什么都不买
- 只买主件
- 买主件和第一个附件（前提是有第一个附件）
- 买主件和第二个附件（前提是有第二个附件）
- 买主件和两个附件（前提是有两个附件）

然后对以上方案产生的价值取最大值。

状态转移方程和基础的背包一样，这里不再赘述。

# 代码实现
可以建一个结构体，里面包含 $v,p,q,lc,rc$，分别表示物品的价格、重要度以及它对应的的主件、第一个附件、第二个附件。边读入边处理，如果这件物品是附件，找到它的主件，并判断是第几个主件。


```cpp
	for(int i=1;i<=m;i++){
		cin>>a[i].v>>a[i].p>>a[i].q;
		if(a[i].q!=0){
			if(a[a[i].q].lc==0) a[a[i].q].lc=i;
			else a[a[i].q].rc=i;
		}
		a[i].s=a[i].v*a[i].p;
	}
```

# AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct thing{int v,p,q,lc,rc,s;}a[70];
int dp[50005];
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i].v>>a[i].p>>a[i].q;
		if(a[i].q!=0){
			if(a[a[i].q].lc==0) a[a[i].q].lc=i;
			else a[a[i].q].rc=i;
		}
		a[i].s=a[i].v*a[i].p;
	} 
	for(int i=1;i<=m;i++){
		if(a[i].q==0){
			for(int j=n;j>=1;j--){
				if(j>=a[i].v) dp[j]=max(dp[j-a[i].v]+a[i].s,dp[j]);
				if(a[i].lc!=0&&j>=a[i].v+a[a[i].lc].v){
					dp[j]=max(dp[j-a[i].v-a[a[i].lc].v]+a[i].s+a[a[i].lc].s,dp[j]);
				}
				if(a[i].rc!=0&&j>=a[i].v+a[a[i].rc].v){
					dp[j]=max(dp[j-a[i].v-a[a[i].rc].v]+a[i].s+a[a[i].rc].s,dp[j]);
				}
				if(a[i].lc!=0&&a[i].rc!=0&&j>=a[i].v+a[a[i].lc].v+a[a[i].rc].v){
					dp[j]=max(dp[j-a[i].v-a[a[i].rc].v-a[a[i].lc].v]+a[i].s+a[a[i].rc].s+a[a[i].lc].s,dp[j]);
				}
			}	
		}
	}
	cout<<dp[n];
	return 0;
}
```
~~我觉得可以降黄~~

---

## 作者：ClV_Csy (赞：1)

# P1064 [NOIP2006 提高组] 金明的预算方案
## 前言
- 01 背包  
如果不会，可以先解决 [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)（01 背包模板题），熟悉 01 背包后再来尝试解决此题。
## 题意
给出 $m$ 个物品，每个物品要么是主件，要么是附件，并且每个物品都有一个**价格** $v_i$ 和一个**重要度** $w_i$，要求出使用不超过 $n$ 元能买到物品的最大价值。
## 思路
每个物品要么是主件要么是附件，因此可以建立结构体，每个结构体元素 $a_i$ 有 $6$ 个成员，分别是：
$$v_1, v_2, v_3, s_1, s_2, s_3$$
其中，  
$v_1$ 表示序号为 $i$ 的主件的**价格**，$v_2$ 表示序号为 $i$ 的第一个附件的**价格**，$v_3$ 表示序号为 $i$ 的第二个附件的**价格**；  
我们将物品的**价格与重要度的乘积**称为**价值**。  
$s_1$ 表示序号为 $i$ 的逐渐的**价值**，$s_2$ 表示序号为 $i$ 的第一个附件的**价值**，$s_3$ 表示序号为 $i$ 的第二个附件的**价值**。

依次输入 $m$ 个物品的价格 $v$、重要度 $p$ 以及它对应的主件 $q$。
- 若 $q = 0$，即该物品自身为主件，则 $v_1 \gets v$，$s_1 \gets v \times p$。
- 若 $q \ne 0$，即该物品自身为附件，且 $a_q$ 的 $v_2 \ne 0$（现在还没有序号为 $i$ 的第一个附件，所以当前物品成为第一个附件），则 $v_2 \gets v$，$s_2 \gets v \times p$。
- 若 $q \ne 0$，即该物品自身为附件，且 $a_q$ 的 $v_2 = 0$（现在已经有了序号为 $i$ 的第一个附件，由于每个主件最多有 $2$ 个附件，所以当前物品成为第二个附件），则 $v_3 \gets v$，$s_3 \gets v \times p$。

```cpp
#include <iostream>
using namespace std;
struct node {
	int v1 = 0, v2 = 0, v3 = 0;
	int s1 = 0, s2 = 0, s3 = 0;
}a[70];
int n, m;
int v, p, q;
int dp[32010];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> v >> p >> q;
		if (q == 0) {
			a[i].v1 = v;
			a[i].s1 = v * p;
		} else {
			if (a[q].v2 == 0) {
				a[q].v2 = v;
				a[q].s2 = v * p;
			} else {
				a[q].v3 = v;
				a[q].s3 = v * p;
			}
		}
	}
	return 0;
}
```

-----
完成上述操作后，再进行 01 背包，$dp_j$ 表示花 $j$ 元可以买到的最大总**价值**。  
以 01 背包标准代码为范例，其中 $w_i$ 表示花费，$v_i$ 表示价值。

```cpp
for (int i = 1; i <= n; i++)
	for (int j = W; j >= 1; j--)
		if (w[i] <= j)
			f[j] = max(f[j], f[j - w[i]] + v[i]);
cout << f[W];
```

Q & A：  
Q：为什么要判断 $w_i \le j$？  
A：防止数组 `f` 下标为负导致越界。

深入思考 Q 提出的问题，可以发现本题也有相似之处。
现先给出代码，再进行分析。

```cpp
if (a[i].v1 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1] + a[i].s1);
if (a[i].v1 + a[i].v2 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2] + a[i].s1 + a[i].s2);
if (a[i].v1 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v3] + a[i].s1 + a[i].s3);
if (a[i].v1 + a[i].v2 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2 - a[i].v3] + a[i].s1 + a[i].s2 + a[i].s3);
```

我们进行逐步拆解分析：
```cpp
if (a[i].v1 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1] + a[i].s1);
```
和 01 背包标准代码对照，可以发现此时 `a[i].v1` 就是花费，`a[i].s1` 就是价值。与前文 Q & A 相似，判断语句是为了防止数组越界。此时的操作是只考虑主件的。
```cpp
if (a[i].v1 + a[i].v2 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2] + a[i].s1 + a[i].s2);
```
类比，可以发现此时 `a[i].v1 + a[i].v2` 是花费，`a[i].s1 + a[i].s2` 是价值。此时的操作考虑的是主件与第一个附件搭配的情况。
```cpp
if (a[i].v1 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v3] + a[i].s1 + a[i].s3);
```
类比，可以发现此时 `a[i].v1 + a[i].v3` 是花费，`a[i].s1 + a[i].s3` 是价值。此时的操作考虑的是主件与第二个附件搭配的情况。
```cpp
if (a[i].v1 + a[i].v2 + a[i].v3 <= j)
	dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2 - a[i].v3] + a[i].s1 + a[i].s2 + a[i].s3);
```
类比，可以发现此时 `a[i].v1 + a[i].v2 + a[i].v3` 是花费，`a[i].s1 + a[i].s2 + a[i].s3` 是价值。此时的操作考虑的是主件与第一个附件和第二个附件搭配的情况。

这样全部考虑一遍后即可得到最终答案。
## 代码

```cpp
#include <iostream>
using namespace std;
struct node {
	int v1 = 0, v2 = 0, v3 = 0;
	int s1 = 0, s2 = 0, s3 = 0;
}a[70];
int n, m;
int v, p, q;
int dp[32010];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> v >> p >> q;
		if (q == 0) {
			a[i].v1 = v;
			a[i].s1 = v * p;
		} else {
			if (a[q].v2 == 0) {
				a[q].v2 = v;
				a[q].s2 = v * p;
			} else {
				a[q].v3 = v;
				a[q].s3 = v * p;
			}
		}
	}
	for (int i = 1; i <= m; i++) {
		if (a[i].v1 == 0) continue;
		for (int j = n; j >= 1; j--) {
			if (a[i].v1 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1] + a[i].s1);
			if (a[i].v1 + a[i].v2 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2] + a[i].s1 + a[i].s2);
			if (a[i].v1 + a[i].v3 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v3] + a[i].s1 + a[i].s3);
			if (a[i].v1 + a[i].v2 + a[i].v3 <= j)
				dp[j] = max(dp[j], dp[j - a[i].v1 - a[i].v2 - a[i].v3] + a[i].s1 + a[i].s2 + a[i].s3);
		}
	}
	cout << dp[n];
	return 0;
}
```

---

## 作者：wurang (赞：0)

本题是分组背包的变形，我们要先理解分组背包。

分组背包其实就是在每个组里至多选一样物品，我们的循环第一重枚举每一组，第二重枚举容量，第三重枚举一组中的每一件物品。下面是一份模板代码。

```cpp
for (int k = 1; k <= ts; k++)          // 循环每一组
  for (int i = m; i >= 0; i--)         // 循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      if (i >= w[t[k][j]])             // 背包容量充足
        dp[i] = max(dp[i],dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```

对于这题而言，对于每一件主件来说，之多有五种情况。

- 什么都不买
- 只买主件
- 买主件和第一个附件
- 买主件和第二个附件
- 买主件和两个附件

恰好，在这些情况中之能选择一种。

那么经过处理后即为分组背包了。

```cpp
#include<iostream>  
using namespace std;  
int n,W;
int v,p,q;
int mw[40000],mv[40000],fw[40000][3],sum[40000],fv[40000][3];
int dp[40000];
//mw,mv为主件，fw,fv为附件
//sum用于记录主件有几件附件 
int main()  
{  
    cin>>W>>n;  
    for(int i=1;i<=n;i++)
	{  
		cin>>v>>p>>q;//简单读入 
		if(q)//附件 
		{
			sum[q]++;
			fw[q][sum[q]]=v;
			fv[q][sum[q]]=v*p;   
		}  
		else//主件 
		{  
			mw[i] = v; 
			mv[i] = v*p;
		}  
    }  
    for(int i = 1; i <= n;i++)  
    {
        for(int j = W; j >= 0;j--)
        {
			//枚举所有情况 
            if(j >= mw[i]) dp[j] = max(dp[j], dp[j - mw[i]] + mv[i]);     
            if(j >= mw[i] + fw[i][1])dp[j] = max(dp[j], dp[j-mw[i] - fw[i][1]]+mv[i]+fv[i][1]);
            if(j >= mw[i] + fw[i][2])dp[j] = max(dp[j], dp[j-mw[i] - fw[i][2]]+mv[i]+fv[i][2]);  
            if(j >= mw[i] + fw[i][1] + fw[i][2])dp[j] = max(dp[j], dp[j - mw[i] - fw[i][1]-fw[i][2]]+mv[i]+fv[i][1]+fv[i][2]);  
        }    
    }
    cout<<dp[W]<<endl;  
    return 0;  
}
```

---

## 作者：jackgdn (赞：0)

每一个主件最多带有 $2$ 个附件，所以每一个主件都有五种情况，每种情况与其所对应的价格-期望分别为

* 啥都不选，$(0,0)$；
* 只选主件，$(v_{main}, v_{main}\times p_{main})$；
* 选主件和附件一（如果存在），$(v_{main}+v_{attach1}, v_{main}\times p_{main}+v_{attach1}\times p_{attach1})$；
* 选主件和附件二（如果存在），$(v_{main}+v_{attach2}, v_{main}\times p_{main}+v_{attach2}\times p_{attach2})$；
* 选主件和两个附件（如果存在），$(v_{main}+v_{attach1}+v_{attach2}, v_{main}\times p_{main}+v_{attach1}\times p_{attach1}+v_{attach2}\times p_{attach2})$；

以上五种情况相互冲突，只能选则一种。此时，这道依赖背包问题就被转换成了分组背包问题。

另外由于题目给出的金额都是 $10$ 的倍数，因此可以在处理时将所有金额都除以 $10$，最后再乘回去以降低时空消耗。

下面是使用滚动数组优化过的代码：

```python
from collections import defaultdict

n, m = map(int, input().strip().split(" "))
n //= 10

main = list()
attach = defaultdict(list)
for i in range(1, m + 1):
    v, p, q = map(int, input().strip().split(" "))
    v //= 10
    if q == 0:
        main.append((v, p, i))
    else:
        attach[q].append((v, p))

dp = [0] * (n + 1)
for m in main:
    v_main, p_main, idx = m
    atch = attach[idx]
    comb = list()
    comb.append((0, 0))
    comb.append((v_main, v_main * p_main))
    if len(atch) >= 1:
        v_atch, p_atch = atch[0]
        comb.append((v_main + v_atch, v_main * p_main + v_atch * p_atch))
    if len(atch) == 2:
        v_atch, p_atch = atch[1]
        comb.append((v_main + v_atch, v_main * p_main + v_atch * p_atch))
    if len(atch) == 2:
        v_atch1, p_atch1 = atch[0]
        v_atch2, p_atch2 = atch[1]
        comb.append((v_main + v_atch1 + v_atch2, v_main * p_main + v_atch1 * p_atch1 + v_atch2 * p_atch2))

    for j in range(0, n + 1)[::-1]:
        for v, val in comb:
            if j >= v:
                dp[j] = max(dp[j], dp[j - v] + val)

print(dp[-1] * 10)

```

在输入数据中某些附件的数据可能先于其主件数据输入，故需要使用 `defaultdict` 存储附件信息，否则会 RE。

---


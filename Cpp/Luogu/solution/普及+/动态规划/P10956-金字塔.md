# 金字塔

## 题目描述

虽然探索金字塔是极其老套的剧情，但是有一队探险家还是到了某金字塔脚下。

经过多年的研究，科学家对这座金字塔的内部结构已经有所了解。

首先，金字塔由若干房间组成，房间之间连有通道。

如果把房间看作节点，通道看作边的话，整个金字塔呈现一个有根树结构，节点的子树之间有序，金字塔有唯一的一个入口通向树根。

并且，每个房间的墙壁都涂有若干种颜色的一种。

探险队员打算进一步了解金字塔的结构，为此，他们使用了一种特殊设计的机器人。

这种机器人会从入口进入金字塔，之后对金字塔进行深度优先遍历。

机器人每进入一个房间（无论是第一次进入还是返回），都会记录这个房间的颜色。

最后，机器人会从入口退出金字塔。

显然，机器人会访问每个房间至少一次，并且穿越每条通道恰好两次（两个方向各一次）， 然后，机器人会得到一个颜色序列。

但是，探险队员发现这个颜色序列并不能唯一确定金字塔的结构。

现在他们想请你帮助他们计算，对于一个给定的颜色序列，有多少种可能的结构会得到这个序列。

因为结果可能会非常大，你只需要输出答案对$10^9$ 取模之后的值。

## 样例 #1

### 输入

```
ABABABA
```

### 输出

```
5```

# 题解

## 作者：kind_Ygg (赞：7)

~~区间 dp 怎么就只有四十道题啊。~~
## 思路
一棵树可以从他的子树转移得到，果断选择区间 dp（也有树形 dp 的思想）。每从根节点出发，遍历完一棵子树，就要重新返回根节点。所以字符串应该长这样：

```
根 子树1 根 子树2... 子树n 根
```
那么就可以区间 $[i,j]$ 就可以由区间 $[i,k]$ 和 $[k+1,j-1]$ 转移得到（$[i,k]$ 是本来的子树，$[k+1,j-1]$ 是他新的一颗子树）。  
## Code

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
string a;
int dp[305][305];
const int mod=1e9;
signed main()
{
	cin>>a;
	int n=a.size();
	a=" "+a;
	for(int i=1;i<=n;i++)
	{
		dp[i][i]=1;
	}
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			if(a[i]==a[j])
			{
				for(int k=i+1;k<j;k++)
				{
					if(a[k]==a[i])
					{
						dp[i][j]+=dp[i][k]*dp[k+1][j-1];
						dp[i][j]%=mod;
					}
				}
				dp[i][j]+=dp[i+1][j-1];
				dp[i][j]%=mod;
			}
		}
	}
	cout<<dp[1][n]<<'\n';
	return 0;
}
```

但你写出来之后，发现跑了 $136ms$，实在是太慢了。不难发现，只有在长度为奇数时才可能有答案。所以长度 $len$ 的遍历可以改成这样：

```
for(int len=3;len<=n;len+=2)
```
时间复杂度十分优秀，~~快了整整 $12ms$。~~

---

## 作者：never_knew (赞：3)

蓝书是个好东西，可是没人用。

我们枚举每棵子树，这取棵子树的答案，进行递归，枚举左右子树，取其乘积，相加即可。

记得记忆化。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int dp[1001][1001];
const int mod=1e9;
string s;
int dfs(int l,int r)
{
    if(l>r)
    {
        return 0;
    }
    if(l==r)
    {
    	return 1;
	}
    if(s[l]!=s[r])
    {
        return 0;
    }
    if(dp[l][r]!=-1)
    {
        return dp[l][r]; 
    }
    dp[l][r]=0;
    for(int i=l+2;i<=r;i++)
    {
        dp[l][r]+=dfs(l+1,i-1)*dfs(i,r);
        dp[l][r]%=mod;
    }
    return dp[l][r];
}
signed main()
{
    cin>>s;
    memset(dp,-1,sizeof(dp));
    cout<<dfs(0,s.size()-1);
    return 0;
}
```

---

## 作者：Jerrycyx (赞：3)

根据题意，金字塔房间的结构是一棵树，每个房间有一个颜色，要求根据访问颜色序列来计算可能的树结构数量。

很明显，除了叶节点的所有节点在遍历时都应该被访问至少两次。两次访问之间的序列就为节点的子树（可能多于一个）。

更具体的，如果有颜色序列 $s_l,\cdots,s_k,\cdots,s_r$ 使得 $s_l=s_k$，那么 $s[l,k]$ 可以作为 $s[l,r]$ 的一颗子树。

设区间 $s[l,r]$ 的结构数量为 $f_{l,r}$，那么根据乘法原理，当把 $k$ 看作 $s[l,r]$ 的第一棵子树时，其方案数为 $f_{l+1,k-1} \times f_{k,r}$

由此可得区间 DP 算法：枚举区间 $[l,r]$，如果有 $k \in [l,r]$ 使得 $s_l=s_k$，那么令 $f[l,r]$ 加上 $f_{l+1,k-1} \times f_{k,r}$。

代码如下，注意开 `long long`：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=305,P=1e9;
int n; char s[N];
long long f[N][N];

int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	for(int i=1;i<=n;i++) f[i][i]=1;
	for(int len=2;len<=n;len++)
		for(int l=1;l+len-1<=n;l++)
		{
			int r=l+len-1;
			for(int k=l;k<=r;k++)
				if(s[l]==s[k])
				{
					f[l][r]+=f[l+1][k-1]*f[k][r];
					f[l][r]%=P;
				}
		}
	printf("%lld\n",f[1][n]);
	return 0;
}
```

---

## 作者：yinpeichu2021 (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P10956)

## 思路

由 dfs 遍历的性质可知一棵树的颜色序列必定形如 `xAxBx....xCx`（`x` 表示树根节点的字符，`A`、`B`、`C` 表示其子树的颜色序列），所以可以用区间 DP 解决。

定义 $f_{i,j}$ 表示字符串 $s[i\dots j]$ 这个颜色序列对应的结构个数，则转移方程为 $f_{i,j}=\sum_{s_k=s_i} (f_{i,k}\times f_{k+1,j-1})$，即枚举中间的某一个 `x`，用乘法原理统计 $s[k+1\dots j-1]$ 为一个子树的方案数。

## Code

```cpp
#include<bits/stdc++.h>
#define MOD 1000000000
// #define inf 0x3f3f3f3f
using namespace std;
typedef long long LL;
#define MAXN 305
int n;char c[MAXN];
LL f[MAXN][MAXN];
signed main(){
	cin>>(c+1),n=strlen(c+1);
	for(int i=1;i<=n;i++)
		f[i][i]=1;
	for(int l=2;l<=n;l++)
	for(int i=1;i<=n-l+1;i++){
		int j=i+l-1;
		if(c[i]!=c[j])continue;
		for(int k=i;k<j;k++)
			if(c[k]==c[i])f[i][j]=(f[i][j]+f[i][k]*f[k+1][j-1]%MOD)%MOD;
	}
	cout<<f[1][n];
	return 0;
}
```

---

## 作者：hzoi_Shadow (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P10956)

# 前置知识

[欧拉序](https://oi-wiki.org/graph/lca/#定义_1) | [区间 DP](https://oi-wiki.org/dp/interval/) | [乘法原理](https://oi-wiki.org/math/combinatorics/combination/#乘法原理)

# 解法

颜色序列本质上是欧拉序，故考虑区间 DP。

设 $f_{l,r}$ 表示 $[l,r]$ 对应的二叉树的个数，状态转移方程为 $f_{l,r}=\begin{cases} 1 & l=r \\ [s_{l}=s_{r}] \times \sum\limits_{i=l+2}^{r}[s_{l}=s_{i}] \times f_{l+1,i-1} \times f_{i,r} & l \ne r\end{cases}$。

最终，有 $f_{1,n}$ 即为所求。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
const ll p=1000000000;
ll f[400][400];
char s[400];
int main()
{
	ll n,len,l,r,i;
	cin>>(s+1);
	n=strlen(s+1);
	for(i=1;i<=n;i++)
	{
		f[i][i]=1;
	}
	for(len=1;len<=n;len++)
	{
		for(l=1,r=l+len-1;r<=n;l++,r++)
		{
			if(s[l]==s[r])
			{
				for(i=l+2;i<=r;i++)
				{
					f[l][r]=(f[l][r]+(s[l]==s[i])*f[l+1][i-1]*f[i][r]%p)%p;
				}
			}
		}
	}
	cout<<f[1][n]<<endl;
	return 0;
}
```

# 后记

多倍经验：[UVA1362 Exploring Pyramids](https://www.luogu.com.cn/problem/UVA1362)

---

## 作者：sad_lin (赞：1)

题意是对一个字符串颜色序列的 dfs 序求树的可能数，所以考虑区间dp，设状态 $dp[i][j]$ 为区间 $i$ 到 $j$ 树的状态数。

在转移的过程中如果 $s_i=s_j$ 时代表这可能为同一个根节点组成的树，所以才可以开始枚举中间点，当中间点与根节点的颜色相同时，我们就可以将分为两个子树，然后根据乘法原理，将每个区间状态数相乘就是这么划分的方案数，再将所有的状态数相加就得到了大区间的状态数，转移方程为 $dp[i][j]=(dp[i][j]+dp[i][k]\times dp[k+1][j-1])$，$k+1$ 和 $j-1$ 是为了得到两个不同子树乘积。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int mod=1e9;
const int N=1e5;
char s[N];
int n;
ll dp[1005][1005];
int main(){
    ios::sync_with_stdio(false);
	cin>>s+1;
	n=strlen(s+1);
	for(int i=1;i<=n;i++){
		dp[i][i]=1;//初始化，只有1种可能 
	}
	for(int len=2;len<=n;len++){//区间长度 
		for(int i=1;i<=n-len+1;i++){//枚举起点 
			int j=i+len-1;
			if(s[i]==s[j]){//可能合法 
				for(int k=i;k<=j-1;k++){//枚举中间点 
					if(s[k]==s[i]){//得到两个子树 
						dp[i][j]+=(dp[i][k]*dp[k+1][j-1])%mod;
						dp[i][j]%=mod;
					}
				}
			}
		}
	}
	cout<<dp[1][n];
    return 0;
}
```

---

## 作者：Cells (赞：1)

#### 思路

很好的一道区间 DP。

注意到题面阐述的是 dfs 序，所以对于一个非叶子节点，在遍历完它的子树后必定回到这个节点。

想象一下，所以这个序列就会像这样 `root 子树A root 子树B ... root`，于是我们枚举每一个两端相同，即根节点相同的区间。

然后枚举这个区间内的所有根节点字符，这样我们就把这颗树分成两个部分，根据乘法原理，我们将每一个区间的形态数相乘就是这样划分的形态数，把所有形态数加和即可。

令 $dp_{l,r}$ 为以 $l$ 和 $r$ 为左右两个端点的区间形态数，转移方程就是 $dp_{l,r}=\sum_{k=l}^{r-1}dp_{l,k} \times dp_{k+1,r-1}$，当然前提是 $s_k=s_l$。至于为什么是 $k+1$ 和 $r-1$，那是因为两个子树不能一样，不能重复啊。那初始状态也很好想了，长度为 $1$ 的区间只有 $1$ 种形态。

另外记得开 `long long`。

**Code**

```c++
# include <bits/stdc++.h>
# define int LL
# define mem(a, b) memset(a, b, sizeof (a))
# define rep(i, a, b) for(int i = a; i <= b; i ++)
# define pre(i, a, b) for(int i = a; i >= b; i --)
using namespace std;

typedef long long LL;

const int N = 3e2 + 10, mod = 1e9; 

int n, dp[N][N];
char s[N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
    
    cin >> s + 1;
    n = strlen(s + 1);
    rep(i, 1, n) dp[i][i] = 1;//一个字符就只有一种形态 
    
    rep(len, 2, n){//枚举区间 
    	for(int l = 1; l + len - 1 <= n; l ++){
    		int r = l + len - 1;
    		if(s[l] != s[r]) continue;//区间不合法 
    		rep(k, l, r - 1){
    			if(s[k] != s[l]) continue;//枚举根节点字符 
    			dp[l][r] = (dp[l][r] + dp[l][k] * dp[k + 1][r - 1] % mod) % mod;
			}
		}
	}
    
    cout << dp[1][n];
    
	return 0;
}
```
**感谢你能看到这里!!!**

---

## 作者：cly312 (赞：1)

对于 dfs 序, 由于题目的要求是进入还是返回都会记录颜色, 那么我们可以考虑把问题的规模进行缩小。

令 $dp_{i,j}$ 代表以区间 $[i,j]$ 可行的方案数。
显然 $dp_{i,j}$ 可以从 $dp_{i-1,j-1}$ 转化而来(大区间可以从小区间转移过来)。

此外，根据 dfs 序的特性，当出现 $s_l=s_r$ 的时候，可以令 $1$ 为根，使得 $[l,r]$ 作为以 $1$ 为根的深度优先遍历的结果。
最后，我们可以枚举一个中间点 $mid$， 如果出现 $s_l=s_{mid}=s_r$，证明可以把 $[l,r]$ 划分成两个子树 $[l+1,mid−1]$, $[mid,r]$, 所以是 $dp_{i,j} \gets dp_{l+1,mid-1}\cdot dp_{mid,r}+dp_{i,j}$（两个子树的方案都可以随意排列组合）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3e2+10;
const int mod=1e9;
char s[maxn];
int dp[maxn][maxn];
int main(){
	scanf("%s",s+1);
	int n=strlen(s+1);
	for(int i=1;i<=n;i++)	dp[i][i]=1;
	for(int l=n-1;l>=1;l--)
		for(int r=l+1;r<=n;r++){
			if(s[l]==s[r]){
				for(int k=l+2;k<=r;k++)
					dp[l][r]=(dp[l][r]+1LL*dp[l+1][k-1]*dp[k][r]%mod)%mod;
			}
		}
	cout<<dp[1][n]<<endl;
}
```

---

## 作者：_ChongYun_ (赞：1)

### Solution

考虑区间 dp。很容易想到定义 $dp_{l,r}$ 表示区间 $[l,r]$ 对应的满足条件的子树的方案数。

一般区间 dp 的套路无非就是枚举一个断点 $k$，使得这个大状态由两个小状态转移过来，我们现在需要考虑的就是如何划分每一个状态。

状态对应的子树也有若干个子树。不妨只考虑第一棵子树是什么样的，这样我们将整个状态划分成了第一棵子树和其他子树。所以考虑递归地把每一个 $dp_{l,r}$ 计算。具体地，每次依然枚举一个断点 $k$，分割第一棵子树和其他子树，再分别递归计算第一棵子树和其他子树的答案。

下面假设每一个 $dp_{l,r}$ 已经算出，那么：

$$dp_{l,r}=\sum^{r}_{k=l+2}dp_{l+1,k-1} \times dp_{k,r}$$

### Code

使用的是记忆化搜索。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9;
string str;
int n,dp[305][305];
int dfs(int l,int r){
	if(l>r) return 0;
	if(l==r) return 1;
	if(str[l]!=str[r]) return 0;
	if(dp[l][r]!=-1) return dp[l][r];
	dp[l][r] = 0;
	for(int i=l+2;i<=r;i++){
		if(str[l]==str[i]) dp[l][r]=(dp[l][r]+dfs(l+1,i-1)*dfs(i,r))%mod;
	}
	return dp[l][r];
}
signed main(){
	cin>>str;
	n=str.size();
	str=" "+str;
	for(int i=1;i<=n;i++){
	    for(int j=i;j<=n;j++){
	        dp[i][j]=-1;
	    }
	}
	cout<<dfs(1,n)<<endl;
	return 0;
}
```

---

## 作者：minVan (赞：0)

**题目大意**

给定一棵树的 dfs 遍历路径 $s$，问这棵树的排列有多少种。

**解题思路**

对于一个非叶子节点，在扫完它的一棵子树后就会回到这个节点，所以 $s$ 就相当于是根节点 + 子树一 + 根节点 + 子树二 + $\cdots$ + 根节点。

将整棵树转换为字符串（线性），就可以想到区间 dp，而又根据 $s$ 的构成，所以我们只需要枚举每个满足左右两端点相同的区间即可。

为了代码简洁，所以使用了记忆化搜索。

初始：$f_{i,j}=-1$

答案：$f_{1,n}$

边界：

1. $l > r$：$0$。
2. $l = r$：$1$。
3. $s_l\neq s_r$：$0$。
4. $f_{l,r}\neq -1$：$f_{l,r}$

转移方程：

$$
f_{l,r}=\sum_{i=l+2}^r[s_l=s_i]\times f_{l+1,i-1}\times f_{i,r}
$$

注意一下，模数是 $10^9$ 而不是 $10^9+7$（我先前就错了）。

**AC 代码，请勿抄袭。**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 305, Mod = 1e9;
string s;
int n, f[N][N];
inline int dfs(int l, int r) {
  if(l > r) { return 0; }
  if(l == r) { return 1; }
  if(s[l] != s[r]) { return 0; }
  if(f[l][r] != -1) { return f[l][r]; }
  f[l][r] = 0;
  for(int i = l + 2; i <= r; i++) {
    if(s[l] != s[i]) { continue; }
    f[l][r] = (f[l][r] + dfs(l + 1, i - 1) * dfs(i, r) % Mod) % Mod;
  }
  return f[l][r];
}
signed main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> s;
  n = s.size();
  s = " " + s;
  memset(f, -1, sizeof(f));
  cout << dfs(1, n);
  return 0;
}
```

---

## 作者：mirance2025 (赞：0)

### 题目传送门
众所周知，OIer 写题目需要通读题目至少 $3$ 遍。

[P10956 金字塔](https://www.luogu.com.cn/problem/P10956)

### 题意分析
根据 dfs 序列的长度为 $2n - 1$ 可以判断长度为偶数时方案为 $0$。

若长度为偶数，按照常规做法必然 TLE。

考虑 DP。

#### 区间DP

状态表示：$f_{i, j}$ 表示所有 DFS 序列是 $str_{l}$~$str_{r}$ 的树的集合。

状态计算（对应集合划分）：对于 $f_{l, r}$：

- 枚举最后一棵子树的起点，很显然 $k$ 点需满足和 $r$ 点相同（即 $l, r, k$ 相同）。
- 要使其为最后一颗树的遍历序列，则长度需要满足为奇数，因此 $k$ 为 $l, l + 2, ..., r - 2$。
- 分别对应的方案为 $f_{l, k} \times f_{l + 1, r - 1}$，最后求和即可。

### 代码

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 310, mod = 1e9;

char str[N];
int f[N][N];

int main(){
    cin >> str + 1;
    
    int n = strlen(str + 1);
    if (n % 2 == 0) printf("0\n");
    else{
        for (int len = 1; len <= n; len += 2)
            for (int l = 1; l + len - 1 <= n; l ++ ){
                int r = l + len - 1;
                if (len == 1) f[l][r] = 1;
                else if (str[l] == str[r]){
                    for (int k = l; k < r; k += 2)
                        if (str[k] == str[r])
                            f[l][r] = (f[l][r] + (LL)f[l][k] * f[k + 1][r - 1]) % mod;
                }
            }
            
        printf("%d\n", f[1][n]);
    }

    return 0;
}
```

---

## 作者：luxiaomao (赞：0)

## [P10956](https://www.luogu.com.cn/problem/P10956) 简单区间 DP

竟然一遍过还可以写题解。

## Problem

一棵 $n$ 个点的树，每个点被染上若干种颜色中的一种，给出用欧拉序遍历这棵树时得到的颜色序列，求树的可能的形态数。

## Solution

$n \le 300$，一眼 $O(n^3)$ 的区间 DP。

比较板地设 $f_{l,r}$ 为区间 $[l,r]$ 的答案。然后根据乘法原理可以写出：

```cpp
for(int i = 1;i <= n;i++)f[i][i] = 1,g[i][i] = 1;
for(int k = 3;k <= n;k+=2)
	for(int l = 1,r = k;r <= n;l++,r++)
	{
		if(s[l] != s[r])
			continue;
		f[l][r] = f[l+1][r-1];
		for(int i = l+1;i < r;i++)
			if(s[i] == s[l])
				(f[l][r] += f[l][i] * f[i][r] % mod) %= mod;
	}
```

但是答案偏大，手推了一下发现，假设在一种形态中根有三个孩子，在枚举断点的时候实际上会枚举两次，也就是这种形态的贡献被多算了一次。

我们设 $g_{l,r}$ 表示：区间 $[l,r]$，中途不准跑回根节点的形态数。

把 $f_{l,r} = \sum f_{l,i} \times f_{i,r}$ 改为 $f_{l,r} = \sum g_{l,i} \times g_{i,r}$。

但是这样答案又小了，发现这样只统计了两个孩子的情况，三个孩子没被考虑到。

断点将一个区间割为左右区间。我们应该允许其中一个区间中途跑回根节点，另一个不能跑回根节点，这样就可以覆盖所有情况而不重复了，具体实现请看代码。

特殊地，若 $s_l \not= s_r$，$f_{l,r} = 0$。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 305
using namespace std;

const int mod = 1e9;

int n;
char s[N];
int f[N][N],g[N][N];

signed main()
{
	scanf("%s",s+1);
	n = strlen(s+1);
	for(int i = 1;i <= n;i++)f[i][i] = 1,g[i][i] = 1;
	for(int k = 3;k <= n;k+=2)
		for(int l = 1,r = k;r <= n;l++,r++)
		{
			if(s[l] != s[r])
				continue;
			g[l][r] = f[l+1][r-1];
			f[l][r] = f[l+1][r-1];
			for(int i = l+1;i < r;i++)
				if(s[i] == s[l])
					(f[l][r] += g[l][i] * f[i][r] % mod) %= mod;
		}
	printf("%lld\n",f[1][n]);
	return 0;
}
```

---


# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# 题解

## 作者：issue_is_fw (赞：126)

**这是你的福利题解，请签收>-<~**

**一、n^3方做法**
	
	1、根据问什么设什么的思想，我们很容易看出，题目中的状态有当前在那颗树，当前的高度。
    那我们不妨设dp[i][j]为在i颗树高度为j时的最大吃苹果数。
    
    2、我们发现，当处于第i棵树高度为j时，可以从第i棵树高度为j+1的地方掉下来，
    即dp[i][j]=a[i][j]+dp[i][j+1];其中a数组表示第i棵树j位置有几个苹果。
    
    也可以从其他任意一棵树的j+delta跳到第i棵树的j位置，所以我们应该枚举每一颗树，
    dp[i][j]=max(dp[i][j],dp[q][j+delta]+a[i][j]);
    3、这么一来就很明了了。第一重循环时枚举高度，从h往0递推，
    第二重循环枚举当前处于哪一棵树，第三重枚举从哪一棵树转移而来，具体见代码。
   ```cpp
#include <bits/stdc++.h>
using namespace std;
int n,h,de;
int a[5009][2009],dp[5009][2009];
int main()
{
	cin>>n>>h>>de;
	for(int i=1;i<=n;i++)
	{
		int t,zz;
		scanf("%d",&t);
		while(t--){
			scanf("%d",&zz);
			a[i][zz]++;
		}
	}
	int maxn=0;
	for(int j=h;j>=0;j--)
	{
		for(int i=1;i<=n;i++)
		{
			dp[i][j]=max(dp[i][j],a[i][j]+dp[i][j+1]);
			for(int q=1;q<=n;q++)
			{
				if(q!=i)
					dp[i][j]=max(dp[i][j],dp[q][j+delta]+a[i][j]);
			}
			maxn=max(maxn,dp[i][j]);
		}
	}
	cout<<maxn;
}
```

 _但是聪明的你肯定发现了，妥妥的tle. _   
 
**于是有了n^2的优化**。
 
 我们想一下，为什么要有第三重循环？我们只不过想从当前高度的状态里挑一棵最大收益的树转移过来。那这样就简单了，我们开一个pre数组保存对应高度的最大收益，转移的时候直接拿过来用就好了。
 
 不懂的话请看代码，很容易理解。
 ```cpp
#include <bits/stdc++.h>
using namespace std;
int n,h,de;
int a[5009][2009]，dp[5009][2009]，pre[5009];
int main()
{
	cin>>n>>h>>de;
	for(int i=1;i<=n;i++)
	{
		int t,zz;
		scanf("%d",&t);
		while(t--){
			scanf("%d",&zz);
			a[i][zz]++;
		}
	}
	int maxn=0;
	for(int j=h;j>=0;j--)
	{
		for(int i=1;i<=n;i++)
		{
			dp[i][j]=a[i][j]+dp[i][j+1];//先继承上一次 
			dp[i][j]=max(dp[i][j],pre[j+de]+a[i][j]);//转移 
			pre[j]=max(pre[j],dp[i][j]);//尝试更新当前的pre 
			maxn=max(maxn,dp[i][j]);
		}
	}
	cout<<maxn;
}
```

希望管理大大能过。第一次写题解被退回来了，原因是排版不整齐。
没有备份，希望这次能过。

**ps:要是觉得对你有帮助，评论一下让我知道好嘛...!?**


---

## 作者：chen_zhe (赞：90)

这是一个在图上做的 dp

我们可以把 $n$ 棵高为 $h$ 的树看作一个宽为 $n$，高为 $h$ 的图，设 $dp[i][j]$ 为位于 $(i,j)$ 处我们可以得到的最多的柿子的数目。

转移方程比较简单：$dp_{i,j}=\max(dp_{i-1,j},dp_{i-delta,j})$

由于第二项的计算时间比较多，注意到行数都是 $i-delta$，这个时候可以维护一个最大值优化一下即可。

时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$，但是可能数据比较大需要读入优化。

---

## 作者：sxyugao (赞：20)

容我推销一波自己的个人主页蛤

[更好的阅读体验](https://sxyugao.top/p/f1f923b5.html)

------------

首先感谢chen_zhe管理员dalao提供的思路

话说这题应该是普及+吧。。

------------

我们根据题意，发现这是一个DP题，定义$f_{i,j}$表示在高度为$i$，当
前要爬的树为$j$所能获得的最大柿子数。

易得状态转移方程：$f_{i,j}=max(f_{i-1,j},f_{i-delta,k}) (1\leq k \leq n)$ 当$i>delta$时后一项成立。

于是我们得到了一个时间复杂度为$O(H*N^2)$，空间复杂度为$O(N*H)$的算法啦。。

然而$N,H=2000$的数据这个时间复杂度还是难以承受，所以需要进一步的优化。

我们发现对于每个$i$，第二个转移的$i-delta$总是固定的，所以就可以直接处理出高度为$i$时$f_{i,j}$的最大值，时间复杂度降到$O(N*H)$

接下来上代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define gc ch=getchar()
inline int read(){
	int x=0,f=1;char gc;
	for(;ch<'0'||ch>'9';gc)if(ch=='-')f=-1;
	for(;ch>='0'&&ch<='9';gc)x=x*10+ch-'0';
	return x*f;
}
#undef gc
//以上为快读，听说不用读入优化会TLE,比如cin、cout
int n,h,d,g[2005],a[2005][2005],f[2005][2005];
//g[i]表示高度为i时f[i][j]的最大值
int main(){
	n=read();h=read();d=read();
	for(int i=1;i<=n;i++){
		a[i][0]=read();
		for(int j=1;j<=a[i][0];j++)a[i][read()]++;
        //注意，是每个上面有1个，所以要加一，而不是赋值为一
	}
	for(int i=1;i<=h;i++){
		for(int j=1;j<=n;j++)f[i][j]=f[i-1][j]+a[j][i];
		if(i>d)for(int j=1;j<=n;j++)f[i][j]=max(f[i][j],g[i-d]+a[j][i]);
		for(int j=1;j<=n;j++)g[i]=max(f[i][j],g[i]);
        //转移见上
	}
	printf("%d",g[h]);
}
```

---

## 作者：Y_B_Y (赞：9)

就我一个人被标签上的贪心骗了吗

~~自己走的路含着泪也要走完~~

### 思路

#### 贪心+递归

每次都挑柿子最多的树(在上方的柿子不算)

一开始先到柿子最多的树上(同时记录第二多的数量)如所在高度没有柿子就向下爬一米,在这棵树还剩的柿子比第二多的多时,就一直在这棵树向下爬,直到比第二多的少时,为这个时候这棵树下面的柿子可能不是最多的了,这里的第二多其实包括了第二多的树上高度大于现在高度的柿子,就是不算的,所以要在其他树高度为现在的高度-delta(因为跳过去高度会下降delta,意,高度-delta要大于0不然只能不跳)以下的柿子数量,如果找到的的最大值大于现在这棵树的跳到那一棵树上去(之后第一多的值为那棵树的数量,第二多为之前找到的第二多),如果小于就还在这一棵树上,直到高度为0,输出吃到的种数结束

取第二大的值的方法:if(a>最大值) 第二大的值=最大值,最大值=a

这里的思路没有用优化 ~~(朴素的思路)~~

复杂度 _O_ (n$^2$*h) 50分

贪心代码

```cpp
void tx(int now,int high,int maxn,int maxn2,int tot)//now为现在所在的树,high为现在所在高度,maxn为现在所在树剩余的柿子(即最多),maxn2为第二多,tot为总共吃了多少柿子
{
	if(high<0||now==0) return;//防超界
	if(high==0)//高度为0
	{
		cout<<tot;//输出
		exit(0);//直接退出整个程序
	}
    /*tr[i][high]为树i在高度为high有几个柿子*/
	if(tr[now][high]==0) return tx(now,high-1,maxn,maxn2,tot);//没有,向下爬
	maxn-=tr[now][high];//这棵树这个高度的柿子被吃掉了
	tot+=tr[now][high];//吃的柿子数量加上去
	if(maxn<maxn2&&high-del>0)//如果出现思路中提到的那种情况,即这棵树不一定是柿子最多的了,且要能向下跳(够高)
	{
	    int s1=0,mm=0,mm2=0,mmc=0;//s1记录某一棵树的柿子,mm为最多的树的柿子树,mm2为第二多,mmc为最多的树的编号
		for(int i=1;i<=n;i++)
		{
			s1=0;
			for(int j=1;j<=high-del;j++)
			{
			    s1+=tr[i][j];//这棵树高度high-del以下所有的柿子(只有这些可以吃到)
			}
			if(s1>mm) mm2=mm,mm=s1,mmc=i;//mm取最大值,mm2第二大值,mmc保存最大值所在树的编号
		}
		if(mm>maxn&&mmc!=0)/*mmc!=0表示还有其他树*/ return tx(mmc,high-del,mm,mm2,tot);//另一棵树更多
		else return tx(now,high-1,maxn,maxn2,tot);//还是这棵树多
	}
	else//这棵树依然一定是最多的,或跳不了了
	{
		return tx(now,high-1,maxn,maxn2,tot);//向下爬一米
	}
}
```

### 优化
 
我们发现前面的代码其实有许多可以优化的地方

- 之前找柿子非常费时间,于是可以定义一个n1[i]保存第i棵树在现在高度下方的柿子数量,每次经过的高度如果这棵树有柿子那么n1[i]-=这个高度的柿子树,注意跳途中的高度也算,所以找跳到那一棵树时要先减掉跳的过程中错过的柿子,在判断最大值,如果不跳要回溯到减跳的过程中错过的柿子之前的值(可以先保存一个副本)//最重要的优化

- 前面思路中如果找了其他的树都比这棵少,本来maxn2的值是不变的因为把每棵树的柿子数量找一遍非常费时间,所以如果将maxn2赋值为mm(即找到的最大值),如果最大值就是这棵树,那么更新为找到的第二大的值//也非常重要

- scanf输入,虽然cin可能会过但明显慢了很多

下面这个优化建议不要(或再完善一下,防止一个高度有太多的柿子使数组爆炸,但是这一题不需要),去掉对时间复杂度影响较小:
 
- 前面减n1[i]时要从1~n找一遍~~非常~~花时间,所以定义一个h[i][j]表示高度i中第j个在这个高度有柿子的树的编号(如果一棵树有两个同一高度的柿子算作在h中保存在不同位置,就是这里可以优化) 

### 完整代码 

复杂度 略大于 _O_ (n$^2$) 

100分(514ms) //没有用第三个优化

```
#include<bits/stdc++.h>
using namespace std;
int tr[2010][3001]/*,h1[2010][5001]如果不用第三个优化不需要定义*/,n,h,del,m,m2,mc,n1[50001],n2[50001];//tr[i][j]存树i在高度j上有多少柿子,n,h,del题目定义,m,m2,mc,n1[],n2[]下面会用得到
void tx(int now,int high,int maxn,int maxn2,int tot)
{
	if(high<0||now==0) return;//防止超界
        /*
        这个是第三个优化的代码
	for(int p=1;p<=h1[high][0];p++)
	{
		n1[h1[high][p]]--;//这个高度的柿子所属的树的柿子总量减一,注意tr不要变,后面要用到(减掉这个高度所有柿子)
	}
	*/
        for(int p=1;p<=n;p++) n1[p]-=tr[p][high];//所有树减掉这个高度的柿子
	if(high==0)//高度为0,表示爬完了
	{
		cout<<tot;//输出
		exit(0);//直接结束整个程序
	}
	if(tr[now][high]==0) return tx(now,high-1,maxn,maxn2,tot);//这里没柿子,直接向下
	maxn-=tr[now][high];//这棵树这个高度的柿子吃掉了
	tot+=tr[now][high];//吃了的柿子数加上去
	if(maxn<maxn2&&high-del>0)//如果出现思路中提到的那种情况,即这棵树不一定是柿子最多的了,且要能向下跳(够高)
	{
	    int s1=0,mm=0,mm2=0,mmc=0;//s1记录某一棵树的柿子,mm为最多的树的柿子树,mm2为第二多,mmc为最多的树的编号
		for(int i=1;i<=n;i++)//在所有的树中找
		{
		    for(int j=high-1;j>=high-del+1;j--) n2[1]=n1[i],n1[i]-=tr[i][j];//减掉跳过程中的,并保存副本(如果不跳要回溯)
			s1=n1[i];//用于取最大值
			if(s1>mm) mm2=mm,mm=s1,mmc=i;//mm取最大值,mm2第二大值,mmc保存最大值所在树的编号
		}
		if(mm>maxn&&mmc!=0)//有更多的树,mmc!=0表示还有其他树
		{
		 return tx(mmc,high-del,mm,mm2,tot);//另一棵树更多
	    }
		else //没有或跳不了了
		{
		if(mmc==now) mm=mm2;//如果最大是自己,用第二大(不然会出错)
		for(int i=1;i<=n;i++) n1[i]=n2[i];//回溯到选择跳之前的值 
		return tx(now,high-1,maxn,mm,tot);//还是这棵树多
	    }
	}
	else//这棵树依然一定是最多的,或跳不了了
	{
		return tx(now,high-1,maxn,maxn2,tot);//向下爬
	}
}
int main()
{
	scanf("%d%d%d",&n,&h,&del);//输入
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&n1[i]);//输入有几个
		if(n1[i]>m) m2=m,m=n1[i],mc=i;//m取最大值,m2第二大值,mc保存最大值所在树的编号
		for(int p=1;p<=n1[i];p++)
		{
			int hi;//用于输入
			scanf("%d",&hi);
			tr[i][hi]++;//这棵树这个高度的柿子加1
			/*
			h1[hi][++h1[hi][0]]=i;//这个高度柿子加一(同一棵树有多个算作不同,但保存的编号一样)
			如果不用第三个优化不需要这一句*/
		}
	}
	tx(mc,h,m,m2,0);//从最多的树开始
	return 0;//输出在函数里面
}
```


---

## 作者：良辰何需美景 (赞：8)

~~第一篇题解鸭。~~

主要原因是在T掉一个点之后觉得题解里大佬的讲解过于简单（可能是因为我太弱了看不懂）于是利用NB的画图软件自己暴力模拟了一下dp的过程..

说正题吧

#### 首先O(n^2*h) 的转移方程是很好推的
这里得分50 第一个点TLE

用j来表示从1到h现在所在的高度 i表示当前的柱子  
如果当前高度j>delta 那么f[i][j]=max(往下走1 f[i][j-1],往其它柱子跳）+当前点的柿子数  
这时枚举k 表示要跳到的其它柱子，注意k不能等于i，用ret来更新下降delta个高度后，同一高度其它所有柱子的最大值 即f[i][j]=max(f[i][j-1],ret)+a[i][j];

如果当前高度j<=delta（=delta的时候跳到0，即地面，可以不考虑） 那么只能在同一柱子上向下跳，不能跳到其它柱子上，这时的ret并没有更新过，还是初值0，所以无影响
##### 代码
```cpp
for(int j=1;j<=h;j++)
    for(int i=1;i<=n;i++){
        if(j>d)
        for(int k=1;k<=n;k++){
            if(k==i)continue;
            ret=max(ret,f[k][j-d]);
        }
        f[i][j]=max(f[i][j-1],ret)+a[i][j];
    }
for(int i=1;i<=n;i++)
    ans=max(ans,f[i][h]);//还要再找一遍从阳台跳到哪个柱子最优
```
### 然后..小猫无情的T了
那么我们来优化一下  
再回去看一下刚刚的代码会发现一个重要的问题
#### **ret更新了每个高度所有柱子的最优解** 
如果我们把它存下来！
用ret[h]来表示高为h时的最优解
这样状态转移方程就变成了
```cpp
for(int j=1;j<=h;j++)
	for(int i=1;i<=n;i++){
		if(j>d)f[i][j]=max(f[i][j-1],ret[j-d])+a[i][j];
                        //往下走1， 往下跳到j-delta层时的最大值
		else f[i][j]=f[i][j-1]+a[i][j];
		ret[j]=max(ret[j],f[i][j]);//同时更新当前层数的ret
	}
```
##### 时间复杂度分分钟降成O(n*h)
并且还有小惊喜  
就是可以不需要最后的循环来确定第一次跳到哪个柱子最优了，因为在循环里面ret已经更新过了 所以直接输出ret[h]

## **完整代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h,d,num,k;
int f[2018][2018],a[2018][2018],ret[2018];
int main(){
	std::ios::sync_with_stdio(false);
	cin>>n>>h>>d;
	for(int i=1;i<=n;i++){
		cin>>num;
		for(int j=1;j<=num;j++){
			cin>>k;
			a[i][k]++;
		}
	}
	for(int j=1;j<=h;j++)
		for(int i=1;i<=n;i++){
		    if(j>d)f[i][j]=max(f[i][j-1],ret[j-d])+a[i][j];
		    else f[i][j]=f[i][j-1]+a[i][j];
		    ret[j]=max(ret[j],f[i][j]);
		}
	cout<<ret[h];
	return 0;
}//完美AC
```
[实测AC](https://www.luogu.org/recordnew/show/12827981)

---

## 作者：邓布利多6 (赞：4)

一个明显的**动态规划**

------------

一、 $50$分方法  $O(n^3)$
```
a[i][x] 第i棵树高度j上的柿子数量
f[i][j] 到第i棵树的高度j时所能摘到的最多数量
方程：f[i][j]=max(f[i][j],f[k][j-delta]);
```
------------
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int NH=2001;
int a[NH][NH],f[NH][NH],n,h,m,delta,ans;
int main(){
  scanf("%d%d%d",&n,&h,&delta);	
  for(int i=1;i<=n;i++){
	  scanf("%d",&m);
	  for(int j=1;j<=m;j++){
		  int x;
		  scanf("%d",&x);
		  a[i][x]++;
		  }
	  }
  for(int j=1;j<=h;j++){
	  for(int i=1;i<=n;i++){
		  f[i][j]=f[i][j-1];
		  for(int k=1;k<=n;k++)if(k!=i&&j>=delta)
			  f[i][j]=max(f[i][j],f[k][j-delta]);
		  f[i][j]+=a[i][j];
		  }
	  }
  for(int i=1;i<=n;i++) ans=max(ans,f[i][h]);
  printf("%d\n",ans);
  return 0;
}
```

二、 $100$分方法  $O(n^2)$

观察发现，$f[i][j]$的值为$f[k][j-delta]$（$k$不等于$i$）和$f[i][j-1]$中的最小值，所以我们不妨把$f[i][j]$的初值制为$f[i][j-1]$。用$ans[i]$代表到高度为i的地方所能摘到的最大数量，而且我们不用特别考虑$k==i$的情况，因为即使$k==i$，$f[k][j-delta]$肯定能到达$f[i][j]$,值还$>=$ $f[k][j-delta]$,所以一并考虑即可。代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=2001;
int n,h,d,ans[N],f[N][N],x,y,a[N][N];
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main()
{
     n=read();h=read();d=read();
	 for(int i=1;i<=n;i++)
	 {
		  x=read();
		  for(int j=1;j<=x;j++)
		  {
			   y=read();
			   a[i][y]++;
		  }
	 }
	 for(int j=1;j<=h;j++)
		  for(int i=1;i<=n;i++)
		  {
			   f[i][j]=f[i][j-1];
			   if(j>=d)f[i][j]=max(f[i][j],ans[j-d]);
			   f[i][j]+=a[i][j];
			   ans[j]=max(ans[j],f[i][j]);
		  }
	 cout<<ans[h];
	 return 0;
}

---

## 作者：不存在之人 (赞：4)

## 思路：

#### 高度低的位置的值肯定是由高度高的位置更新得来的。在某一位置，有两种可能:

1. **是从这个树上下降1到达这里的。**

2. **是从其他树上跳来的，由于可以从任意树上跳来，所有选之前吃果子最多的树。**

#### 用dp[i][j]表示到达第i棵树，高度j的时候的最优解，那么:

**dp[i][j]=max(dp[i][j+1],m[j+d])+a[i][j]。**

**m[j]=max(dp[i][j],m[j])。**

**其中m[x]表示到达高度x时的最优解，a[i][j]表示第i棵树上，高度j位置的果子数量。**
```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;
typedef long long ll;
int a[2020][5010]={0};
int dp[2020][5010]={0};
int m[2010]={0};
int n,h,d;
int read()
{
    char ch=getchar();
    while(!isdigit(ch))
    	ch=getchar();
    int x=0;
    while(isdigit(ch))
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
void print()
{
    for(int i=h;i>=1;i--)
    {
        for(int j=1;j<=n;j++)
        {
            dp[j][i]=max(dp[j][i+1],m[i+d])+a[j][i];
            m[i]=max(dp[j][i],m[i]);
        }
    }
    printf("%d\n",m[1]);
}
int main()
{
	scanf("%d%d%d",&n,&h,&d);
	int x,y;
    for(int i=1;i<=n;i++)
    {
        x=read();
        for(int j=1;j<=x;j++)
        {
            y=read();
            a[i][y]++;
        }
    }
    print();
	return 0;
}
```

---

## 作者：LlLlCc (赞：2)

叫大家一个方法，看题前先看数据范围（~~看看能不能的打表~~），这样就能知道大概算法，然后看题是会往那个方向想。n，h<=2000，嗯，至少应该是n*h。


------------

看完题目，一个简单粗暴的想法来了，n * n * h的dp（~~Dfs大法可还行~~），f[i][j]表示小猫跳到第i棵树高度为j时最多~~偷~~吃的柿子数。枚举每一颗树的每一个高度，比较是从自己这颗树的上一个高度跳下来好，还是从别的树跳过来好。

转移方程：


```cpp
f[i][j]=max(f[i][j+1],f[k][j+Delta])
```



------------

我们再来观察一下这个式子，首先需要需要两层循环i，j来枚举第i棵树的高度j，还要一层循环k来枚举时从哪棵树跳过了的，复杂度很高，达到了n * n * h，这和我们之前估算的时间复杂度不符，很明显的超时。



------------

再仔细思考一下，我们这次k循环，其实就是在枚举是从哪棵树上跳过来的。想想，假如可以从很多树那跳过了，我们应该选哪棵？一个贪心的想法出来啦，因为我们要得到更多的柿子，所以应该选得到柿子最多的状态转过来，所以我们只需要记录一下每个高度的最大值即可将这层k循环去掉，时间复杂度o（n * k），空间n*k，可以AC。

代码如下：
```cpp
#include<bits/stdc++.h>
#define maxn 5005
using namespace std;
int n,H,m,x,f[2005][maxn],Ans,d,a[maxn],vis[2005][maxn];
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
int main(){
	n=read(),H=read(),d=read();
	for (int i=1;i<=n;i++){
		m=read();
		for (int j=1;j<=m;j++) vis[i][read()]++;
	}
	for (int i=H;i;i--)
	for (int j=1;j<=n;j++){
		if (i+d<=H) f[j][i]+=a[i+d];
		f[j][i]=max(f[j][i],f[j][i+1]);
		f[j][i]+=vis[j][i];
		a[i]=max(f[j][i],a[i]);
		Ans=max(f[j][i],Ans);
	}
	printf("%d",Ans);
	return 0;
}
```


---

## 作者：henry_y (赞：2)


## [可以采用博客食用QAQ](https://www.cnblogs.com/henry-1202/p/9544717.html)

------------

朴素做法很容易想，就是对于每一层，枚举上面d层的最大值来转移，效率$O(n^2h)$

显然没法过

所以考虑优化：能不能$O(1)$算上面d层的最大值？

观察到对于第i层，它只能从i+1层或者i+d层跳过来，所以我们可以预处理i+d层的最大值，i+1层可以直接$O(1)$转移

只需要枚举层数的时候倒序枚举就可以了！保存下来当前层的最大值，下面转移的时候就可以直接调用了

但是要注意的一点是，不能从当前点最上方的i+d层那里跳过来，所以需要保存一下最大值的位置，特判一下，如果最大值正好在最上方，那就得枚举一下i+d层来转移（不过这对于复杂度几乎没有影响）

总复杂度$O(nh)$


------------

```
#include <bits/stdc++.h>
using namespace std;
int n,m,d,t[3000][2];
int a[3000][3000];
int f[3000][3000];
int main(){
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		for(int j=1;j<=x;j++){
			int y;
			scanf("%d",&y);
			a[i][y]++;
		}
	}
	for(int i=1;i<=n;i++){
		f[i][m]=a[i][m];
		if(f[i][m]>t[m][0]){
			t[m][0]=f[i][m];
			t[m][1]=i;
		}
	}
	for(int j=m-1;j;j--){
		for(int i=1;i<=n;i++){
			f[i][j]=max(f[i][j],f[i][j+1]+a[i][j]);
			if(j<=m-d){
				if(t[j+d][1]!=i){
					f[i][j]=max(f[i][j],t[j+d][0]+a[i][j]);
				}else {
					for(int k=1;k<=n;k++){
						if(k==i)continue;
						f[i][j]=max(f[i][j],f[k][j+d]+a[i][j]);
					}
				}
			}
			if(f[i][j]>t[j][0]){
				t[j][0]=f[i][j];
				t[j][1]=i;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=max(ans,f[i][1]);
	}
	printf("%d\n",ans);
} 
```

---

## 作者：刘曜曜 (赞：2)

拿到这道题我们很容易可以看出这道题dp的算法

这道方程还是很好想的

dp[i][j] 表示高度为i，在第j棵树上时最多吃到柿子的个数

方程：
```cpp
    dp[i][j]=max(dp[i][j],dp[i-1][j]);
    if(i>D)
    for(int k=1;k<=n;k++)
    dp[i][j]=max(dp[i][j],dp[i-delta][k]);
```
这样大体上就没问题了

但是！！！！！

因为n<=2000  所以我们这样的n立方的算法就会时间超限很多

所以我们可以想“既然我们要换树，那么要换就要换到接下来的吃到柿子最多的树，其他的树就不跳了。”

所以我们可以引入一个数组“maxn[2002]={0}”maxn[i]表示高度为i时接下来最多吃到的柿子数。
每次通过maxx[i]=max(maxx[i],dp[i][j]);来储存。这样时间上也够用了。

于是代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int N,H,D,num,maap[2002][2002]={0},dp[2002][2002]={0},ans=0,maxx[2002]={0};
int main()
{
    scanf("%d%d%d",&N,&H,&D);
    for(int i=1;i<=N;i++)
    {
        scanf("%d",&num);//一棵树上一共多少柿子；
        for(int j=1;j<=num;j++)
        {
            int xb;
            scanf("%d",&xb)//奇怪的变量名，大佬们见谅;
            maap[xb][i]++;//记录柿子的位置；
        }
    }
    for(int i=1;i<=H;i++)//先是H的循环还是N的不好想；
        for(int j=1;j<=N;j++)//但是因为我们是从最高处往下跳；
        {//且不确定向那一棵树跳，所以i是第一重1~h；
         //又因为n棵树并列关系所以j是第二重1~n（写n~1也未尝不可）；
            dp[i][j]=max(dp[i][j],dp[i-1][j]);//一定可以向下跳一格；
            if(i>D)如果可以换树，考虑换哪棵树；
            dp[i][j]=max(dp[i][j],maxx[i-D]);
            dp[i][j]+=maap[i][j];//加上现在位置的柿子；
            maxx[i]=max(maxx[i],dp[i][j]);
            //求出这一高度接下来最多吃的柿子量
        }
    for(int j=1;j<=N;j++)ans=max(ans,dp[H][j]);
    printf("%d",ans);
    return 0;
}
```
有错误请在评论区指出orzorz；

---


# 环状最大两段子段和

## 题目描述

给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 样例 #1

### 输入

```
7
2 -4 3 -1 2 -4 3
```

### 输出

```
9```

# 题解

## 作者：Develop (赞：484)

## 2019.11.30 
## 关于最大子段和及其变式
#### $upd:$增加了一些变式的题面描述，一个$chapter$，补了一些锅
#### $chapter 1$ 最大子段和
	
$O(n^3)$ 枚举区间起点和终点，暴力求和；
   
$O(n^2)$ 枚举左右端点时 $j=i$ -> $m$ 可以动态维护$i$~$j$的前缀和；
   
$O(n^2)$ 预处理前缀和，枚举左右端点时$O(1)$计算；
   
$O(nlogn)$ 枚举中点,分别往前面和后面计算一个包含$center$的最大子段和，预处理前缀和一次判断是$O(1)$的；
   
$O(n)$ 考虑$dp$，设状态$f[i]$为包含且以$a[i]$结尾的最大值，方程：$f[i] = max(~f[i-1]~,~0~) + a[i]$；
   
$O(n)$ 一个以$a[i]$结尾最大子段的定义：$sum[i]-min(sum[k])~(1<=k<i)$ ，计算$min(~sum[k]~)$可以动态维护一个前缀和的最小值；
   
#### $chapter 2$ 子段长度不大于m的最大子段和

$O(n)$ 仍然考虑最大子段和的定义，动态维护$min(sum[k])~(i-m<=k<i)$，使用单调队列维护，队列中的数递增(参考$P1886$滑动窗口)；

#### $chapter 3$ 子段长度不小于m的最大子段和

$O(nlongn)$ 可以将分治思想中的枚举中点改成枚举一个中段，同理；(但是显然需要枚举一个段的话编码难度会提升)
   
$O(n)$ 先计算一次不限长最大子段和，再从头开始，枚举每一个长为m的子段，在它前面拼上以$a[i-1]$结尾的最大子段和；方程：$f'[i] = max(~f[i-1]~,~0~) + sum[i+m] - sum[i-1]$，最后取一个$max$；
   
$O(n)$ 动态维护$min(sum[k])~(1<=k<=i-m)$，比上一种编码简洁，只需要一次循环，维护前缀和；

#### $chapter 4$ 环状最大子段和

	在最大子段和的基础上，认为a[1]和a[n]是相邻的。

$O(n)$ 将序列倍长，就可以做一遍长度不大于m的最大子段和

$O(n)$ 考虑子段是否过端点，过端点就取反，其实就是求一个最小子段和；不过端点就没有影响。

#### $chapter 5$ 环状最大两段子段和

$O(n^2)$ 考虑破环成链，枚举破坏的断点$O(n)$，在链上求最大两段子段和；维护一个$f1[i]$为以$a[i]$结尾的最大子段和，一个$f2[i]$为以$a[i]$开头的最大子段和；(其实就是倒着求一遍)复杂度$O(3n)$；

$O(n)$ 对于答案可能有的所有情况，一种是有一段跨过了端点，另一种是没有跨过端点；所以可以先求一遍两段最大子段和，再对整个序列取反，再求一遍(这时其实就是求出两段的最小子段和，用总和减去后就是跨过端点的两段最大子段和)，这时把两种情况取一个$max$；

#### $chapter 6$ 最大m段子段和

	给定由n个整数（可能为负整数）组成的序列，
    以及一个正整数m，要求确定序列m个不相交子段，
    使得这m个子段的总和达到最大，求出最大和。
    
$O(n^{2m})$ 不用说了，暴力枚举每一段的左右端点，求和；

$O(n^m)$ 还可以再优化，动态维护每一段当前$a[i]$之前，上一段结尾之后的前缀和$min$，可以递归实现；当然递归的形式会减慢速度；

$O(n^3m)$ 难道不像一个区间dp？？我们设状态$f1[i][j][k]$为区间$[i,j]$内已经分配了k段的最大值；方程为：$f1[i][j][k]=max(f1[i][j][k],f1[i][p][k-1]+f1[p+2][j][1])~(p>i,p+2<=j)$；这转移显然有：

           for(int p=1;p<=m;p++)
	          for(int i=1;i<=n;i++)
                  for(int j=i;j<=n;j++)
                      for(int q=i+1;q+2<=j;q++)
                          f[i][j][p]=max(f[i][j][p],f[i][q][p-1]+f[q+2][j][1]);

$O(n^2m)$ 其实本来方程中枚举段数也需要一层循环，但是我们发现这是一个分段问题，和选取的段数先后无关，故我们可以直接把一段拼上$p-1$段。(对于这种dp我更愿意称它为分段dp而不是区间dp)接着我们将方程转化一下，会发现$f1[q+2][j][1]$其实就是$sum[j]-sum[q+1]$！这时方程变为$f1[i][j][k]=max(f1[i][j][k],f1[i][p][k-1]+sum[j]-sum[q+1])~(p>i,p+2<=j)$；我们再次观察，发现转移可以优化：第一维所涉及的转移全部是$i$！这时把第一维去掉，状态定义转化为区间$[1,j]$内已经分配了k段的最大值：$f[j][k]$；这时转移就有：

              for(int p=1;p<=m;p++)
                  for(int j=1;j<=n;j++)
                      for(int q=i+1;q+2<=j;q++)
                          f[j][p]=max(f[j][p],f[j][p-1]+sum[j]-sum[q+1]);

$O(nm)$ 上一种方法的方程已经变为$f1[j][p]=max(f1[j][p],f[j][q][p-1]+sum[j]-sum[q+1])$，我们再看看还是否可以优化。我们发现，求m段子段的过程中，当我已经求出前$i$个元素，$k$段的时候，我要做的，其实就是考虑向后多少个元素后再重新开一段。所以该状态为$f[i][j][0/1]$表示前$i$个元素，$j$段，第i个元素是否选的最大子段和。转移就好写了：

		  f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0])+a[i];
              f[i][j][0]=max(f[i-1][j][1],f[i-1][j][0]);

#### $chapter 7$ 只含正整数的不小于$S$($S<=10^9$)的最小子段和的长度($n<=100000$)

	给出了N个正整数（10 <N <100 000）的序列，
    每个正整数均小于或等于10000，并给出了一个正整数S（S <100 000 000）。
    编写程序以查找序列中连续元素的子序列的最小长度，其总和大于或等于S。

$O(n^2)$ 枚举左右端点，用前缀和计算$O(1)$，取最小值；

$O(n)$ 考虑二分答案，每次计算不超过当前长度下的最大子段和能否不小于$S$，具体操作见$chapter2$

$O(n)$ 一种新的方法：尺取法。因为题目所给数均为正整数，所以可以设一个队首和一个队尾，总和小于$S$就往后加一个数，大于$S$就在最前面减一个数。(决策的单调性是应用尺取法的前提，老师将它比作虫子向前蠕动的样子)同样，尺取法不仅能求长度，也能求大于$S$的最小子段和。而二分得到的答案，最短的不一定是最接近$S$的。

#### $chapter 8$ 含负数的不小于$S$($S<=10^9$)的最小子段和的长度($n<=100000$)

$O(nlogn)$ 现将所有前缀和算出来，离散化；题目所求即为求一个$min(j-i)$，满足$sum[j]-sum[i]>=S~(1<=i<=j,sum[i]=min(sum[1]~to~sum[j-1]))$；即$sum[j]-S>=sum[i]$。开一个值域树状数组，$c[i]$表示的是前缀和为$i$(离散化后的)的前缀的最后一个位置。相当于在树状数组内每次查询小于$sum[j]-S$的那一段中位置的最大值。这样就求出了最小长度；而对于最小值的话，查询第一个$c[i]!=-1$就可以了。

#### $chapter 9$ 含/不含负数的不大于S的最大子段和的长度/值

$O(???)$ 这些其实都可以类比上一个$chapter$的做法，不说了。

#### $chapter 10$ 一些其他的

有些题目中要求的是不相邻的两个子段，有些又没有要求。其实不相邻意味着两个子段之间至少隔一个数；不然的话，两个子段虽然接在了一起，但是仍可以认为是两个子段。这个时候其实关于转移，只需要转移$a[i]~to~a[j]$改成$a[i+1]~to~a[j+1]$就可以了。

### 启示：其实我们在优化算法时，优化枚举的核心即为减少枚举过程中的重复计算。

---

## 作者：I_AM_HelloWord (赞：75)

对于这个问题，由于分成了两个子序列，我们不妨就是枚举一下可能出现的情况：

无非就这两种：

1.+++++0000+++++0000++++

2.0000++++00000++++000000

0就表示选了这个数，+就表示不选这个数，

那我们正反先做一个普通的最大子序列，就可以完成第2中情况，然后再求个最小子序列，把总和一减就是第1种情况。

至于求最小子序列，可以把数字都负过来，然后再搞个最大子序列就好了。

楼下举的例子非常对，我仔细思考了一下这个特例，即

4
-1 1 -1 -1

当我们将数字负过来时，就成了：

4
1 -1 1 1

此时的两个最大子序列我们会选成：

0+00
而首尾都选了，其实就是只选了一个序列，而这种特殊情况又只会在

只有一个数是正数时出现，所以特判一下就好了，如果只有一个数是正数，我们就不做将数字负过来后的那个最大子序列了，

直接找两个最大的数累和就行了。

由于本题数据较水，所以不用特判也可以过。

参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=2e5+5;
int n,f[N],g[N],a[N],sum=0,tot=0;
int query(){
    int res=-INF;
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
    for (int i=n;i>0;i--)g[i]=max(g[i+1],0)+a[i];
    for (int i=1;i<=n;i++)f[i]=max(f[i-1],f[i]);
    for (int i=n;i>0;i--)g[i]=max(g[i+1],g[i]);
    for (int i=1;i<n;i++)res=max(res,f[i]+g[i+1]);
    return res;
}
int main(){
    scanf("%d",&n);
    memset(f,~0x3f,sizeof(f));memset(g,~0x3f,sizeof(g));
    for (int i=1;i<=n;i++)scanf("%d",&a[i]),sum+=a[i],tot+=a[i]>0;
    int t1=query();
    if (tot==1){
        printf("%d",t1);
    }else{
        for (int i=1;i<=n;i++)a[i]=-a[i];
        int t2=sum+query();
        if (!t2)t2=-INF;
        printf("%d",max(t1,t2));
    }
    return 0;
}
```

---

## 作者：zhy137036 (赞：48)

~~这题恶评的吧，顶多绿~~
## 1.最大子段和
[P1115](/problem/P1115)

暴力 $O(n^3)$，太慢。其中最内层的循环是用来求和的，容易想到用**前缀和**预处理一下，复杂度优化到 $O(n^2)$，仍然太慢。

定义 $f_i$ 表示以 $i$ 为尾的子序列中，和最大的那个，即：

$$f_i=\max_{j=1}^i\sum_{k=j}^ia_k$$


容易得到，当 $i>1$ 时，$f_i=\max(f_{i-1}+a_i,a_i)=\max(f_{i-1},0)+a_i$。

$f_1=a_1$。

定义 $g_i$ 表示 $\max_{k=1}^if_k$，即前 $i$ 个元素构成的序列的最大子段和。

当 $i>1$ 时，$g_i=\max(g_{i-1},f_i)$。

$g_1=f_1$

$g_n$ 即为所求。

于是得到如下代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[200010],f[200010],g[200010];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	f[1]=a[1];
	for(int i=2;i<=n;i++)f[i]=max(f[i-1],0)+a[i];
	g[1]=f[1];
	for(int i=2;i<=n;i++)g[i]=max(g[i-1],f[i]);
	printf("%d\n",g[n]);
	return 0;
}
```
## 环状最大子段和
如果这个子段没有跨过 $a_1$ 与 $a_n$ 的分界，那它就是最大子段。

如果跨过了，那另一部分就是没跨过的最小子段。

注意最小子段不能占满整个序列。

解决方法就是 $1\sim n-1$ 求一遍，$2\sim n$ 再求一遍。

求了这么多遍，可以考虑使用函数。

代码：
```cpp
#include<cstdio>
using namespace std;
int n,sum,a[200010],f[200010],g[200010];
int getmax(int*arr,int l,int(*cmp)(int,int)){//指向函数的指针，sort 也是这个原理
	f[1]=arr[1];
	for(int i=2;i<=l;i++)f[i]=cmp(f[i-1],0)+arr[i];
	g[1]=f[1];
	for(int i=2;i<=l;i++)g[i]=cmp(g[i-1],f[i]);
	return g[l];
}
int max(int x,int y){return x>y?x:y;}//库里的函数好像不能用
int min(int x,int y){return x<y?x:y;}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		sum+=a[i];//计算总和
	}
	int ans=getmax(a,n,max);
	ans=max(ans,sum-getmax(a,n-1,min));//用总和减
	ans=max(ans,sum-getmax(a+1,n-1,min));
	printf("%d\n",ans);
	return 0;
}
```
## 最大双子段和
[P2642](/problem/P2642)

从前往后和从后往前维护两个 $f_i$ 和 $g_i$。

然后枚举分界点，找到答案。

顺便可以将 $f_i$ 和 $g_i$ 合并，减少数组数量。

```cpp
#include<cstdio>
#include<algorithm>
#define size 1000010
using namespace std;
int n,a[size],front[size],back[size];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	front[1]=a[1];
	for(int i=2;i<=n;i++)front[i]=max(front[i-1],0)+a[i];
	for(int i=2;i<=n;i++)front[i]=max(front[i-1],front[i]);
	back[n]=a[n];
	for(int i=n-1;i>0;i--)back[i]=max(back[i+1],0)+a[i];
	for(int i=n-1;i>0;i--)back[i]=max(back[i+1],back[i]);
	int ans=1ll<<31ll;//溢出为负数
	for(int i=2;i<n;i++)ans=max(ans,front[i-1]+back[i+1]);//这样可以保证一定被 a[i] 隔开
	printf("%d\n",ans);
	return 0;
}
```
## 环状最大双子段和
[P1121](/problem/P1121)

和环状最大子段和类似，分为两种情况。

没有任何一段跨过 $a_1$ 与 $a_n$ 的分界，就是最大双子段和；

有一段跨过 $a_1$ 与 $a_n$ 的分界，就是最小双子段和的补集。

这题坑点在哪呢？**两个子段可以相邻**。

也就是说，最小双子段可以为空。

具体改动见代码。
```cpp
#include<cstdio>
#include<algorithm>
#define size 1000010
using namespace std;
int n,sum,a[size],af[size],ab[size],mf[size],mb[size];
int getmin(int*arr,int l){
	mf[1]=arr[1];
	for(int i=2;i<=l;i++)mf[i]=min(mf[i-1]+arr[i],min(arr[i],0));//可以为0 
	for(int i=2;i<=l;i++)mf[i]=min(mf[i-1],mf[i]);
	mb[l]=arr[l];
	for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1]+arr[i],min(arr[i],0));//可以为0 
	for(int i=l-1;i>0;i--)mb[i]=min(mb[i+1],mb[i]);
	int ans=(1ll<<31ll)-1ll;//2^31-1，即 int 的最大值 
	for(int i=2;i<l;i++)ans=min(ans,mf[i-1]+mb[i+1]);//这里必须被分开 
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
		sum+=a[i];
	}
	af[1]=a[1];
	for(int i=2;i<=n;i++)af[i]=max(af[i-1],0)+a[i];
	for(int i=2;i<=n;i++)af[i]=max(af[i-1],af[i]);
	ab[n]=a[n];
	for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],0)+a[i];
	for(int i=n-1;i>0;i--)ab[i]=max(ab[i+1],ab[i]);
	int ans=1ll<<31ll;//溢出为负数
	for(int i=1;i<n;i++)ans=max(ans,af[i]+ab[i+1]);//可以不被分开 
	ans=max(ans,sum-getmin(a,n-1));
	ans=max(ans,sum-getmin(a+1,n-1));
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ywy_c_asm (赞：28)

其实这题完全可以线段树爆搞……~~另外前方多图预警~~

### **前置知识：线段树求区间最大子段和**

首先我们先来讲一下线段树求区间最大子段和（其核心就是合并的时候一堆分析与讨论），我们在线段树上考虑两个区间的合并，这个时候需要对我们维护的区间内的最大子段和的位置进行讨论：
![](https://cdn.luogu.com.cn/upload/pic/39111.png)

我们重点考虑的是如何处理区间内跨中点的最大子段，我们发现这是由左区间的后缀和右区间的前缀构成的，所以我们需要维护一个最大的前缀和后缀，我们同样要对他们进行一些讨论（以前缀为例）：

![](https://cdn.luogu.com.cn/upload/pic/39112.png)

我们发现跨中点的前缀（后缀）是由一整段左（右）区间与右（左）区间的前缀（后缀）构成的，所以我们还要维护区间和，于是我们应该在线段树上的区间里维护这几个东西：

1.区间和

2.区间最大子段和

3.区间最大前缀

4.区间最大后缀

### **下面即将进入正题~**

这题让我们求 **环状** **两段** **最大子段和**（注意我把它拆成了3个词），首先环状我们可以套路的把它复制一份接在后面，然后我们枚举起点，问题就转化为了求**区间内**的**两段最大子段和**。

我们按照上面线段树维护区间最大子段和的思路，讨论一下这个两段最大子段和的位置：

![](https://cdn.luogu.com.cn/upload/pic/39114.png)

前两种就不用说了，第三种情况我们维护一下区间内的最大子段和即可，我们重点讨论的是最后两种情况。我们以D为例，这东西是由右区间的最大前缀和左区间内的最大的 **后缀+中间一段** 构成的我们接着来讨论这个该怎么维护（这里就只写了跨区间中点的情况）：

![](https://cdn.luogu.com.cn/upload/pic/39116.png)

A是左区间的最大子段和+右区间的最大后缀，B是左区间的最大的 **后缀+中间一段** +右区间的区间和，C是左区间的最大后缀+右区间的最大 **前缀+后缀**。于是我们接着维护区间内的最大 **前缀+后缀**：

![](https://cdn.luogu.com.cn/upload/pic/39118.png)

A是左区间的最大前缀+右区间的最大后缀，B是左区间的区间和+右区间的最大 **前缀+后缀** ，C是左区间的最大 **前缀+后缀** +右区间的区间和，于是我们惊喜的发现不用再维护新东西了，好这题就做完了。

总结一下，我们需要在线段树上维护以下信息：

1.区间和

2.区间最大子段和

3.区间两段最大子段和

4.区间最大前缀

5.区间最大后缀

6.区间最大 **前缀+后缀**

7.区间最大 **前缀+中间一段**

8.区间最大 **后缀+中间一段**

（注意我把上面混搭起来的几个东西比如 **前缀+后缀** 加粗了，目的是强调这并不是最大前缀+最大后缀，而是最大的前缀+后缀的和）

其实大家可以自己动手画一下上面的图，尝试自己讨论一下情况，还是不难的。

上代码~（区间合并部分写的略微恶心……）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ls(_o) (_o<<1)
#define rs(_o) ((_o<<1)|1)
using namespace std;
inline int get() {//快读 
	int n=0;
	char c;
	while((c=getchar())||23333) {
		if(c=='-')goto s;
		if(c>='0'&&c<='9')break;
	}
	n=c-'0';
	while((c=getchar())||23333) {
		if(c>='0'&&c<='9')n=n*10+c-'0';
		else return(n);
	}
s:
	while((c=getchar())||23333) {
		if(c>='0'&&c<='9')n=n*10-c+'0';
		else return(n);
	}
}
typedef struct _n {//我把线段树要维护的信息用结构体封装了一下 
	int he;//区间和 
	int zd;//区间最大子段和 
	int zd2;//区间最大两段子段和 
	int qz;//区间最大前缀 
	int hz;//区间最大后缀 
	int qzhz;//区间最大 前缀+后缀 
	int qzzj;//区间最大 前缀+中间一段 
	int hzzj;//区间最大 后缀+中间一段 
	friend _n operator +(_n a,_n b) {//这题的核心——区间信息合并（我把它定义成了+运算符） 
		_n c;
		//-------------区间和 
		c.he=a.he+b.he;
		//-------------区间最大子段和（参见第一张图） 
		c.zd=max(a.zd,b.zd);
		c.zd=max(c.zd,a.hz+b.qz);
		//-------------区间最大前后缀（参见第二张图） 
		c.qz=max(a.qz,a.he+b.qz);
		c.hz=max(b.hz,b.he+a.hz);
		//-------------区间最大 前缀+后缀（参见第五张图） 
		c.qzhz=max(a.qz+b.hz,a.he+b.qzhz);
		c.qzhz=max(c.qzhz,b.he+a.qzhz);
		//-------------区间最大 前缀+中间一段（参见第四张图（虽然是后缀但也是一样的~）） 
		c.qzzj=max(a.qzzj,a.he+b.qzzj);
		c.qzzj=max(c.qzzj,a.qz+b.zd);
		c.qzzj=max(c.qzzj,a.qzhz+b.qz);
		//-------------区间最大 后缀+中间一段（参见第四张图） 
		c.hzzj=max(b.hzzj,b.he+a.hzzj);
		c.hzzj=max(c.hzzj,b.he+a.zd);
		c.hzzj=max(c.hzzj,b.qzhz+a.hz);
		//-------------区间两段最大子段和（参见第三张图） 
		c.zd2=max(a.zd2,b.zd2);
		c.zd2=max(c.zd2,a.zd+b.zd);
		c.zd2=max(c.zd2,a.hzzj+b.qz);
		c.zd2=max(c.zd2,a.hz+b.qzzj);
		return(c);
	}
} node;
node data[2000001];
int ints[400001];
void build(int l,int r,int tree) {//建树 
	if(l==r) {
		data[tree].he=data[tree].qz=data[tree].hz=data[tree].zd=ints[l];
		data[tree].zd2=data[tree].qzhz=data[tree].qzzj=data[tree].hzzj=-123456789;
		//注意涉及到至少两个点的信息（比如两段最大子段和），因为现在这是叶子，所以要把他们设为-inf
		//以后会把他们合并起来的 
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls(tree));
	build(mid+1,r,rs(tree));
	data[tree]=data[ls(tree)]+data[rs(tree)];
}
node query(int rl,int rr,int l,int r,int tree) {//区间查询 
	if(rl==l&&rr==r)return(data[tree]);
	int mid=(l+r)>>1;
	if(rl>mid)return(query(rl,rr,mid+1,r,rs(tree)));
	if(rr<=mid)return(query(rl,rr,l,mid,ls(tree)));
	return(query(rl,mid,l,mid,ls(tree))+query(mid+1,rr,mid+1,r,rs(tree)));
}
int main() {
	int n=get();
	for(register int i=1; i<=n; i++)ints[i]=get();
	for(register int i=n+1; i<=(n<<1); i++)ints[i]=ints[i-n];//复制一份接在后面 
	build(1,n<<1,1);
	int maxn=-2147483646;
	for(register int i=1; i<=n; i++) {//枚举起点 
		node cjr=query(i,i+n-1,1,n<<1,1);
		maxn=max(maxn,cjr.zd2);
	}
	cout<<maxn<<endl;
	return(0);
}
```

---

## 作者：xMinh (赞：24)


环状最大两段子段和(luogu 1121)

第一道不看题解A掉的紫题！庆祝一下！

解法：一看就是DP啊

首先能想到破环为链，然而并不是这样

思路是用f[i][1/2][0/1]表示到第i个分成0/1/2个子段选或不选第i个的最大和

状态转移方程：

到i只选一个子段，不选第i个

f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);

到i只选一个子段，选第i个

f[i][1][1]=max(f[i-1][1][1]+a[i],a[i]);

到i选两个子段，不选第i个

既然这个不选，那

f[i][2][0]=max(f[i-1][2][1],f[i-1][2][0]);

到i选两个子段，选第i个

那得好好考虑一下

如果上一个没选

就可以用f[i-1][1][0]（上一个没选，截止到上一个选了一个子段）转移

但不能用f[i-1][2][0]（上一个没选，截止到上一个选了两个子段）

因为上一个没选，这一个选了，不就选了三个了吗

如果上一个选了

就可以用f[i-1][1][1]（上一个选了，截止到上一个选了两个子段）

和f[i-1][2][1]（上一个选了，截止到上一个选了两个子段）转移

方程大概是

f[i][2][1]=max(f[i-1][1][0],max(f[i-1][1][1],f[i-1][2][1]))+a[i];

但是有一个很恶心的地方需要考虑

因为这个环不能绕回去，所以推某一个状态的时候最多考虑它后面的n个

然后突然想到

可以考虑一种分成三个子段的情况，但是第一个和最后一个必须选

这样不就视为能绕回去的情况了吗

这个想是摘出来单独算

就是直接加上a[1]和a[n]，然后从2到n-1循环

但是有一个方程要改一下，就是f[i][1][1]=f[i-1][1][1]+a[i]

因为第一个必须选，所以到第i个想要保持一个子段就要一只加

剩下的仔细想想，不改也都没毛病

再想想初始化，由于有负数所以先把f memset成128

然后再f[1][1][1]=a[1];

之后从2开始算就好咯

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,a[200001],f[200001][4][2],ans1,ans2;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
        cin>>a[i];
    memset(f,128,sizeof(f));
    f[1][1][1]=a[1];
    for (int i=2;i<=n;i++)
    {
        f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);
        f[i][1][1]=max(f[i-1][1][1],0)+a[i];
        f[i][2][0]=max(f[i-1][2][0],f[i-1][2][1]);
        f[i][2][1]=max(f[i-1][1][0],max(f[i-1][1][1],f[i-1][2][1]))+a[i];
    }    
    ans1=max(f[n][2][0],f[n][2][1]);
    memset(f,128,sizeof(f));
    f[1][1][1]=a[1];
    for (int i=2;i<=n;i++)
    {
        f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);
        f[i][1][1]=f[i-1][1][1]+a[i];
        f[i][2][0]=max(f[i-1][2][0],f[i-1][2][1]);
        f[i][2][1]=max(f[i-1][1][0],max(f[i-1][1][1],f[i-1][2][1]))+a[i];
        f[i][3][0]=max(f[i-1][3][0],f[i-1][3][1]);
        f[i][3][1]=max(f[i-1][2][0],max(f[i-1][2][1],f[i-1][3][1]))+a[i];
    }
    ans2=f[n][3][1];
    cout<<max(ans1,ans2); 
}
```

---

## 作者：Morning_Glory (赞：23)

[也许更好的阅读体验1](https://blog.csdn.net/Morning_Glory_JR/article/details/97390944)		

[也许更好的阅读体验2](https://www.cnblogs.com/Morning-Glory/p/11250817.html)

# O(n)的贪心做法	

~~(好吧这一句只是吸引你们注意的，不过确实是贪心，确实是O(n))~~	

# $\mathcal{Description}$

给出一段环状序列，即认为$a_1$和$a_n$​是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。

---

# $\mathcal{Solution}$

## 思路


要求两个最大子段，考虑其与最大子段的关系	
我们先把序列复制一遍，求出长度小于等于$n$的最大子段	
把其左端点作为起点，现在得到一个长度为$n$的子段	
如图，这个最大子段的和一定是正数，旁边一定是负数	
![例1](https://img-blog.csdnimg.cn/20190726151616528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vcm5pbmdfR2xvcnlfSlI=,size_16,color_FFFFFF,t_70)
证明，如果旁边不是负数那么其不是最大子段

那么要再弄一个子段出来，__有且仅有__ 两种方式		
* 将$r+x\ $ ～ $\ i+n-1$中的最大段取出来与最大段凑成两段	
* 最大段可能是有不连续的正数一起拼出来的，也就是说中间有负数	
	* 如图	
                ![例2](https://img-blog.csdnimg.cn/20190726152059597.png)
	*  另一种方式就是将最大子段拆成两个子段	

为什么没有另一种方式将包含了最大子段中的某一段并与不包含最大子段的某段凑成两段	
既然题目要子段最大，那没道理只取最大子段中的一小段	

没有另外的选择方式了 ~~(选一堆负数除外)~~	

## 实现方法

---

于是我们要解决的问题就只有两个了	
* 怎么求长度小于等于$n$的最大子段	
	如果没有长度限制相信大家都会求	
	即用$sum[i]$表示前缀和，在前面找一个最小的$sum[j]$，用$sum[i]-sum[j]$就是以$i$为结尾的最大子段了	
	只需$O(n)$扫一遍即可	
	有了长度限制的最大子段	
	还是要再前面找一个最小的$sum[j]$，并且要有$i-j<n\ (i-j+1\leq n)$	
	用单调队列维护一下就好了，即此时最小的$sum[j]$不满足长度条件，那我们就换成满足条件的$sum[j]$	
* 怎么计算答案	
	先求一遍最大子段	
	第一种情况	求出其右端点$r$到$l+n-1$的最大子段	
	第二种情况	可认为是减去中间的一个最小子段，把所有数变成其相反数，再求一遍最大子段即可求出要减去的数的绝对值(也就是要加上的数)	


另外，这仅是考虑两个最大子段都是正数的情况，若给出的答案为负数，计算结果就会为0	
对这种情况特判一下就好了	

还有!	
若右边全是负数并且最大子段没有负数，那么我们将最大子段人为的认为是两个子段就好了	
~~说这么多其实特判的并没有什么东西~~	

---

# $\mathcal{Code}$

```cpp
/*******************************
Author:Morning_Glory
LANG:C++
Created Time:2019年07月26日 星期五 10时32分59秒
 *******************************/
#include <cstdio>
#include <fstream>
#include <queue>
#include <algorithm>
#define ll long long
#define mp make_pair
using namespace std;
const int maxn = 400005;
//{{{cin 读入优化
struct IO{
	template<typename T>
		IO & operator>>(T&res){
			res=0;
			bool flag=false;
			char ch;
			while((ch=getchar())>'9'||ch<'0')	 flag|=ch=='-';
			while(ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^'0'),ch=getchar();
			if (flag)	 res=~res+1;
			return *this;
		}
}cin;
//}}}
int n,l1,l2,r1,r2,t,tt;
ll a[maxn];
ll ans,t1,t2;
//{{{_find 找l~r中的最大子段 该子段左端点为lt右端点为rt
ll _find (ll l,ll r,int &lt,int &rt)
{
	deque< pair<ll,ll> > q;//单调队列记得开long long，没开WA了，考试就炸了
	ll sum=0,mx=-97865432112345678,res;
	q.push_front(mp(l-1,0));
	for (int i=l;i<=r;++i){
		sum+=a[i];
		while (!q.empty()&&i-q.front().first>n)	q.pop_front();
		if (!q.empty()){
			res=sum-q.front().second;
			if (res>mx){	lt=q.front().first+1,rt=i,mx=res;}
		}
		while (!q.empty()&&sum<=q.back().second)	q.pop_back();
		q.push_back(mp(i,sum));
	}
	return mx;
}
//}}}
int main()
{
	cin>>n;
	for (int i=1;i<=n;++i)	cin>>a[i],a[i+n]=a[i];
	ans=_find(1,2*n,l1,r1);//全局最大子段
	if (ans<0){
		sort(a+1,a+n+1);
		printf("%lld\n",a[n]+a[n-1]);
		return 0;
	}
	t1=_find(r1+1,l1+n-1,l2,r2);//右边的最大子段
	for (int i=l1;i<=r1;++i)	a[i]=-a[i];
	t2=_find(l1,r1,t,tt);//中间的最小子段和的绝对值
	ans=max(0ll,max(t1,t2))+ans;//0是对应最后那个还有
	printf("%lld\n",ans);
	return 0;
}

```

>如有哪里讲得不是很明白或是有错误，欢迎指正	
如您喜欢的话不妨点个赞收藏一下吧

---

## 作者：Lates (赞：17)

分为两种情况

-  不跨环

举个例子

$$0001111100000222220$$

数字表示属于哪一段，0 表示不选。

此时只要维护 

$f_i$ 表示 $1$ 到 $i$ 的 最大子段和

$g_i$ 表示 $i$ 到 $n$ 的 最大子段和

然后枚举断点，取左右两边最大子段和的 $\max$ 即可。

答案 为 

$$\max_{i=1}^{n-1}f_{i}+g_{i+1}$$

- 跨环

举个例子

$$1111000 222200011111$$

此时首尾都属于一个子段和内。

考虑此时必定有两段不选，因为是总的最大子段和，那么就要然后这不选的两段最小。

那么只要求出最小序列（不是环状）两段子段和即可，用总和减去这个值，就是答案。

设

$f_i$ 表示 $1$ 到 $i$ 的 最**小**子段和

$g_i$ 表示 $i$ 到 $n$ 的 最**小**子段和

答案为 

$$\sum_{i=1}^{n}a_i-\min_{i=1}^{n-1}f_{i}+g_{i+1}$$

## 坑点

如果选出来的两段最小子段和是整个序列，那么显然不符合题目条件，应该不考虑。

```cpp

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define mem(a,b) memset(a,b,sizeof(a))
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=200005;
const int INF=0x3f3f3f3f; 
int res,ans,sum,f[MAX],g[MAX],h[MAX],n,a[MAX];
signed main(){
	n=read();
	for(register int i=1;i<=n;++i)a[i]=read(),sum+=a[i];
	
	ans=-INF;
	f[0]=h[0]=-INF;
	for(register int i=1;i<=n;++i)h[i]=max(h[i-1]+a[i],a[i]),f[i]=max(f[i-1],h[i]);
	g[n+1]=h[n+1]=-INF;
	for(register int i=n;i;--i)h[i]=max(h[i+1]+a[i],a[i]),g[i]=max(g[i+1],h[i]);
	for(register int i=1;i<=n;++i)ans=max(ans,f[i]+g[i+1]);
	
	res=INF;
	f[0]=h[0]=INF;
	for(register int i=1;i<=n;++i)h[i]=min(h[i-1]+a[i],a[i]),f[i]=min(f[i-1],h[i]);
	g[n+1]=h[n+1]=INF;
	for(register int i=n;i;--i)h[i]=min(h[i+1]+a[i],a[i]),g[i]=min(g[i+1],h[i]);
	for(register int i=1;i<=n;++i)res=min(res,f[i]+g[i+1]);

	printf("%d\n",max(ans,sum-res));
	return 0;
}


```

---

## 作者：Daidly (赞：16)

- 两种情况：

    1.---max---max---

    2.max--max--max
    
第二种情况可以转化成总和减两段最小和。

所以，题意清晰明了：求两子段和极值。

- 考虑 DP：

$t_i=\max or \min(a_i,f_{i-1}+a_i)$ 表示以 $i$ 为结尾的子段和极值。

$f_i=\max or \min(f_{i-1},t[i])$ 表示区间 $[1,i]$ 的子段和极值。

$g_i=\max or \min(g_{i+1},t[i])$ 表示区间 $[i,n]$ 的子段和极值。

则以 $i$ 和 $i+1$ 为分界线：

$ans=\max(\max(ans,f_i+g_{i+1}),sum-\min(ans,f_i+g_{i+1})).$

需要特判计算出的子段极值为空的情况 （`80` 分）。

- 主体代码如下：

```cpp
#define MAXN 200005
const int INF=0x3f3f3f3f;
int n,a[MAXN],sum,t[MAXN],f[MAXN],g[MAXN],maxn,minn;
int get_max(){
	int ans=-INF;
	for(int i=1;i<=n;++i){
		t[i]=max(a[i],t[i-1]+a[i]);
		f[i]=max(f[i-1],t[i]);
	}
	for(int i=n;i>=1;--i){
		t[i]=max(a[i],t[i+1]+a[i]);
		g[i]=max(g[i+1],t[i]);
	}
	for(int i=1;i<=n;++i){
		ans=max(ans,f[i]+g[i+1]);
	}
	return ans;
}
int get_min(){
	int ans=INF;
	for(int i=1;i<=n;++i){
		t[i]=min(a[i],t[i-1]+a[i]);
		f[i]=min(f[i-1],t[i]);
	}
	for(int i=n;i>=1;--i){
		t[i]=min(a[i],t[i+1]+a[i]);
		g[i]=min(g[i+1],t[i]);
	}
	for(int i=1;i<=n;++i){
		ans=min(ans,f[i]+g[i+1]);
	}
	return ans;
}
```


---

## 作者：蒟蒻wyx (赞：11)

# 题解 [P1121 环状最大两段子段和](https://www.luogu.org/problemnew/show/P1121)

- - **698**通过
  - **2.9K**提交
- **难度** **省选/NOI-**
- **时空限制** 1000ms / 128MB

## 题目描述

给出一段环状序列，即认为$A_1$和$A_n$是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。

## 输入输出格式

 ### 输入格式：

第一行是一个正整数$N(N\le 2\times 10^{5})$，表示了序列的长度。

第二行包含$N$个绝对值不大于$10000$整数$A_i$，描述了这段序列，第一个数和第$N$个数是相邻的。

### 输出格式：

一个整数，为最大的两段子段和是多少。



## 输入输出样例

### 输入样例#1：

```
7
2 -4 3 -1 2 -4 3
```

### 输出样例#1：

```
9
```

## 分析

### 引例：最大子段和问题

一个序列的最大子段和是指，从序列中找出一段连续的子段，最大化这个子段的和。

设 $f_i$表示以 $a_i$ 结尾的最大子段和， $g_i$ 表示 $[1,i]$ 的最大子段和，显然有转移

$f_i=\max(f_{i-1}+a_i,a_i)$

$g_i=\max(g_{i-1},f_i)$

求整个序列最大子段和的代码如下

```cpp
g[0] = -inf;
for (int i = 1; i <= n; ++i) {
    f[i] = max(f[i - 1] + a[i], a[i]);
    g[i] = max(g[i - 1], f[i]);
}
printf("%d\n", g[n]);
```

### 阅读理解

对于这个题目，我们要首先知道：

1. 两段可以相邻如$ : [1,3][4,5]$
2. $|\text{选取的部分}| \ge 2$

### 分类讨论

显然的，我们可以按照是否跨断裂点分类：

1. $*1111*2222*$

2. $11*22*11$

### Part 1

我们可以直接枚举一个两段分界点，求两遍的最大子段和的综合最大，例如：

取点$<4,5>$,然后将$[1,4]$和$[5,n]$的最大子段和加起来。

那么，如何求两段的呢？我们可以预处理

回想我们刚刚的方程式， $g_i$ 表示 $[1,i]$ 的最大子段和

那么，我们也可以搞出一个 $h_i$ 表示 $[i,n]$ 的最大子段和

然后就可以$O(n)$枚举分界点，$O(n)$预处理，总共是$O(n)$

### Part 2

$wyx : \text{太难了}!$

正难则反。

考虑做一个最小子段和的$\text{Part 1}$

用总和减一减就好了！

![VP0nK0.png](https://s2.ax1x.com/2019/05/23/VP0nK0.png)

### 细节题

关于$\text{Part 2}$两个问题：

1. 如果我们选取的两段最小子段和为$[1,i - 1]$和$[i + 1,n]$，那么，就爆了
2. 如果我们全选了呢？

考虑过这两个问题后，我们就过了。

![VP0aqK.png](https://s2.ax1x.com/2019/05/23/VP0aqK.png)

代码$($超丑$)$:
```
#include <iostream>

using namespace std;

const int mxk = 2e5 + 1e3, inf = 1 << 30;

int n, a[mxk], g[mxk], h[mxk], s[mxk], sum;

bool check() {
    int tot = 0;
    for(int i = 1; i <= n; ++i)
        tot += (a[i] > 0);
    if(tot == 1)
        return 0;
    return 1;
}

int main() {
    //Input
    cin >> n;
    for(int i = 1; i <= n; ++i)
        cin >> a[i];
    for(int i = 1; i <= n; ++i)
        sum += a[i];
    //Part 1
    g[0] = -inf;
    for(int i = 1; i <= n; ++i)
        g[i] = max(g[i - 1] + a[i], a[i]);
    for(int i = 1; i <= n; ++i)
        g[i] = max(g[i - 1], g[i]);
    h[n + 1] = -inf;
    for(int i = n; i >= 1; --i)
        h[i] = max(h[i + 1] + a[i], a[i]);
    for(int i = n; i >= 1; --i)
        h[i] = max(h[i + 1], h[i]);
    int ans = -inf;
    for(int i = 1; i < n; ++i)
        ans = max(ans, g[i] + h[i + 1]);
    if(!check()) {
        cout << ans << endl;
        return 0;
    }
    //Part 2
    for(int i = 1; i <= n; ++i)
    	a[i] = -a[i];
    g[0] = -inf;
    for(int i = 1; i <= n; ++i)
        g[i] = max(g[i - 1] + a[i], a[i]);
    for(int i = 1; i <= n; ++i)
        g[i] = max(g[i - 1], g[i]);
    h[n + 1] = -inf;
    for(int i = n; i >= 1; --i)
        h[i] = max(h[i + 1] + a[i], a[i]);
    for(int i = n; i >= 1; --i)
        h[i] = max(h[i + 1], h[i]);
    int res = -inf;
    for(int i = 1; i < n; ++i)
        res = max(res, g[i] + h[i + 1]);
    res = sum + res;
    if(res == 0)
    	res = -inf;
    
    cout << max(ans, res) << endl;
    
}
```

---

## 作者：ctq1999 (赞：10)

## 思路

观察题目，发现不管怎么选，都只有两种情况：

```
1. ++++++---++++---

2. ++---+++++--++++
```

即要么是选两段的（对应$1.$），要么是有两段不选的（对应$2.$）

这样想就会把环拆成一条链

那么对于$1.$，我们可以从头尾两端去扫描数组，设$f[i]$为$1-i$和最大的连续的一段：

```
f[i] = max(f[i - 1], 0) + a[i];
```

这样保证了扫描一遍后的$f[i]$必定是在以$i$结尾一个连续的一段中

但并不是最优的那一段，因为在$1-i$中最优的一段可能不以$i$结尾

所以再扫描一遍数组：

```
f[i] = max(f[i - 1], f[i]);
```

便得到了$1-i$中和最大的连续的一段

因为是两段，所以设$g[i]$为$i-n$中和最大的连续的一段，再扫两遍，比较一下：

```
res = max(res, f[i] + g[i + 1]);//注意因为不重叠，所以是g[i + 1]
```

这是第一种情况的做法

第二种求最优的三段的和，那么也就是总和减去不要的两段

那么把上面的$max$改成$min$就可以求出不要的两段的和了

更简单的方法：把$a$数组正负翻转，直接跑，最后是$sum+ask()$（因为符号变了）

### 注意

- 若全是**非正数**，第二次跑会返回$0$（全不选），所以要排除这种情况

- 若只有**一个正数**，第二次跑会把除它全不选，是错的，要特判

*自己想想为什么，对以后的变形会有好处*

## 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 200010

using namespace std;

int n, ans, sum, positive_num;

int a[MAXN], f[MAXN], g[MAXN];

int ask() {
	int res = -MAXN;
	for (int i = 1; i <= n; i++) f[i] = max(f[i - 1], 0) + a[i];
	for (int i = n; i >= 1; i--) g[i] = max(g[i + 1], 0) + a[i];
	for (int i = 1; i <= n; i++) f[i] = max(f[i - 1], f[i]);
	for (int i = n; i >= 1; i--) g[i] = max(g[i + 1], g[i]);
	for (int i = 1; i < n; i++) res = max(res, f[i] + g[i + 1]);
	return res;
}

int main() {
	scanf("%d", &n);
	memset(f, ~0x7f, sizeof(f));
	memset(g, ~0x7f, sizeof(g));
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		sum += a[i];
		if (a[i] > 0) positive_num++;
	}
	ans = ask();
	if (positive_num == 1) {
		cout << ans << endl;
		return 0;
	}
	for (int i = 1; i <= n; i++) a[i] *= -1;
	ans = max(ans, sum + ask() ? sum + ask() : -MAXN);
	cout << ans << endl;
	return 0;
} 
```

> 日拱一卒，功不唐捐


---

## 作者：封禁用户 (赞：3)

本人看到楼主们的代码那么长，就想了一个简单易懂的，同时也更加短小精悍。

直接将a[i]负过来就可以用同一个函数来进行运算了。

思路就不啰嗦了，和楼主们的是一样的。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
using namespace std;
int n;
long long a[2000009],sum;
long long l[2000009],r[2000009];
long long calc()
{
    long long ans=-0x3f3f3f3f3f3f;
    memset(l,0,sizeof l);memset(r,0,sizeof r);l[0]=r[n+1]=-0x3f3f3f3f3f;
    for(int i=1;i<=n;i++) l[i]=max(l[i-1],(long long)0)+a[i];
    for(int i=n;i>=1;i--) r[i]=max(r[i+1],(long long)0)+a[i];
    for(int i=1;i<=n;i++) l[i]=max(l[i],l[i-1]);
    for(int i=n;i>=1;i--) r[i]=max(r[i],r[i+1]);
    for(int i=1;i<=n;i++) ans=max(ans,l[i]+r[i+1]);
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        sum+=a[i];
    }
    long long ans=calc();
    for(int i=1;i<=n;i++) 
        a[i]=-a[i];
    ans=max(ans,sum+calc());
    if(ans==0) cout<<-1;
    else cout<<ans;
    return 0;
}
```

---

## 作者：GuideZombies (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1121)

~~好久没发题解了，今天来水一篇~~

首先，要说这道题就不得不提到另一道题[双子序列最大和](https://www.jianguoyun.com/c/tblv2/0K-IRZmeHxjeNWUJ6CTkmoxhkudSp54_5KGtkFVpVkGK7BIi9xinOVxMh7XqIMfZQYCUfK6V/26lxxa9PyyWrzLCclSIrdg/l)，那道题是这道题的基础，我的思路就源于这道题。

给定一个长度为n的整数序列，要求从中选出两个连续子序列，使得这两个连续  子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为1，并且两个连续子序列之间至少间隔一个数。——P2624题面。
#### **对于这道题来说，没有环状，只需要求出两个子序列和即可，既然两个子序列不能重叠，则子序列之间肯定有一个完美的中间点，使得中心点以前的最大连续子序列和加上中心点以后的最大连续子序列和最大，那怎么找到这个完美的中心点呢？对，就是枚举，因为题目数据不大，扫一遍数组就找到了。**
#### 核心代码代码：
#### 
```cpp 
	for(1~n){
		f[n]=a[n];
		f[0]=-0x7ffffff;
		for(i-1~1) 	f[j]=max(a[j],a[j]+f[j+1]);
		for(1~i) f[0]=max(f[0],f[j]);
		dp[n]=dp[n];
		dp[0]=-0x7ffffff;
		for(n-1~i+1)  dp[j]=max(a[j],a[j]+dp[j+1]);
		for(i+1~n) dp[0]=max(dp[0],dp[j]);
		ans=max(f[0],dp[0]);
   }
```
 好了，说了那么多，现在切回正题：环状最大两段子段和。

**这道题与P2624唯一一点不一样的就是环状，环状代表尾和头可以连在一起，也就有了两种情况，我们用O表示选，X表示不选，用OOXX的序列来表示两种情况。**

 **（1）XXXXOOOOOXXXOOOOXXXX**
 
 **（2）OOOOOXXXXXOOOOOOXXXXXOOOO**
对于第一种情况，其实和P2624是一样的，根本不用管，而第二种首位连接，很难从里面找到突破口，但是，我们可以换一个思路去想，**如果两段和最大，则剩余的最小，而从（2）可知，X被分成了两段，所以，只要将P2624改一下，改成最小两段子段和，用所有数的和减去最小就行了。**
现在，是你们最爱的代码部分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,sz[200001],dp[200001],pd[200001],ans,zda[200001],zdb[200001],zd,zd2,mxd;
int a1(){//第一种情况
	dp[1]=sz[1];
	pd[n]=sz[n];
	for(i=2;i<=n;i++) dp[i]=max(sz[i],sz[i]+dp[i-1]);
	for(i=n-1;i>=1;i--) pd[i]=max(sz[i],sz[i]+pd[i+1]);
	zda[1]=dp[1];
	zdb[n]=pd[n];
	for(i=2;i<=n;i++) zda[i]=max(zda[i-1],dp[i]);
	for(i=n-1;i>=1;i--) zdb[i]=max(zdb[i+1],pd[i]);
	ans=-0x7ffffff;
	for(i=1;i<=n-1;i++) ans=max(ans,zda[i]+zdb[i+1]);
	return ans;
}int a2(){//第二种情况
	dp[1]=sz[1];
	pd[n]=sz[n];
	for(i=2;i<=n;i++) dp[i]=max(sz[i],sz[i]+dp[i-1]);
	for(i=n-1;i>=1;i--) pd[i]=max(sz[i],sz[i]+pd[i+1]);
	zda[1]=dp[1];
	zdb[n]=pd[n];
	for(i=2;i<=n;i++) zda[i]=max(zda[i-1],dp[i]);
	for(i=n-1;i>=1;i--) zdb[i]=max(zdb[i+1],pd[i]);
	ans=-0x7ffffff;
	for(i=1;i<=n-1;i++) ans=max(ans,zda[i]+zdb[i+1]);
	ans=-ans;
	return mxd-ans;
}int main(){
	cin>>n;
	for(i=1;i<=n;i++) cin>>sz[i];//输入
	if(n==2000&&sz[1]==-145){
		cout<<-200;
		return 0;
	}for(i=1;i<=n;i++) mxd+=sz[i];
	zd=a1();//调用函数
	for(i=1;i<=n;i++) sz[i]=-sz[i];//将所有数倒过来，0减最大的便是最小
	zd2=a2();
	cout<<max(zd2,zd);//输出
	return 0;
}
```

---

## 作者：RoRoyyy (赞：2)

这题和同机房$dalao$讨论了好久， ~~可能是窝太弱了限制了$dalao$的思路。~~

这题求 
#### 1.环状
#### 2.两段

首先我们看到环状肯定会想破环成链， 然后发现很难去
保证每次找的不会重复。

我们于是想随便断点成链， 分两种情况讨论。

#### 发现只有两种情况。
#### 1.在链上的两个不相交的区间
#### 2.  $1-x$ 和链上某一段再加上$y-n$ 
#### (链上一段一定满足 $l > x && r < y$) 

第一种情况很显然， 先预处理出从某一断点开始的最大前缀子段和和最大后缀字段和， 枚举断点就行了。

第二种情况很难处理， 因为要保证三段加起来最大， 想到求补集， 转化成两段的问题， 直接求某一段点的最小前缀子段和和最小后缀子段和，再枚举断点， 相减就行了。 求最小前缀子段和可以求相反数转化成求最大前缀子段和最后再把答案取相反数就行了。

注意要特判一下不合法的情况：
	当出现我们枚举的两段加起来最后选不上两段了， 那么就不行了。而仅仅当出现2个以下自然数的时候才会出现这种情况。

```cpp
//RoRoyyy
#include <cstdio>
#include <iostream>

using namespace std;
const int N = 2e5 + 5;
const int inf = 0x3f3f3f3f;
int n;
int a[N];
int sufmax[N], premax[N];
void cacl() {
    for(int i = 1; i <= n; i++) premax[i] = max(premax[i - 1], 0) + a[i];
    for(int i = n; i >= 1; i--) sufmax[i] = max(sufmax[i + 1], 0) + a[i];
    for(int i = 2; i <= n; i++) premax[i] = max(premax[i], premax[i - 1]);
    for(int i = n; i >= 2; i--) sufmax[i] = max(sufmax[i], sufmax[i + 1]);
}
int ans = 0, sum = 0, cnt = 0;
int max1 = -inf, max2 = -inf;
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        sum += a[i];
        if(a[i] >= 0) cnt++;
    }
    for(int i = 1; i <= n; i++) {
        if(a[i] > max1) max2 = max1, max1 = a[i];
        else if(a[i] > max2) max2 = a[i];
    }
    ans = max1 + max2;
    if(cnt < 2) {
        cout << ans << endl;
        return 0;
    }
    cacl();
    for(int i = 1; i < n; i++) ans = max(ans, premax[i] + sufmax[i + 1]);
    for(int i = 1; i <= n; i++) a[i] = -a[i];
    cacl();
    for(int i = 1; i < n; i++) ans = max(ans, sum + premax[i] + sufmax[i + 1]);
    cout << ans << endl;
    return 0;
}
```


---

## 作者：gravf (赞：2)

做这道题之前，一定要注意：
# 连续不重叠且非空的两段
我真的是醉了，这句话让我调了一个上午

进入正题：

我们先不考虑环形，如果题目是求一个数列的**连续不重叠且非空的两段**该怎么求呢？

前置知识：最大子段和~~以及模拟~~

lef[i] 表示1~i中的最大子段和，rig[i]表示i~n中的最大子段和

**max{lef[i]+rig[i+1] | i>=1 && i<n}**

注意，不能写成**max{lef[i]+rig[i] | i>=1 && i<n}**，因为这个式子可能只会选择一个数



------------

好了，我们已经解决了非环形的问题

我们可以考虑一下环形这个条件与上面这个问题有什么不同

当其中一个子段越过第1个数和第n个数时，序列会变成下面这个样子

11000000011000011111

其中，1是选择的数，0是没有选择的数

这时，我们发现，跨过第1个数和第n个数时

就相当于选择连续不重叠且非空的两段**使这两段和最小**。

所以我们就可以将环形序列转化成一个数列求两次的问题

一次，求连续不重叠且非空的两段使这两段和最大

一次，求连续不重叠且非空的两段使这两段和最小，然后用序列所有数的总和减去这个数

将这两次求出来的值取max就是答案了

（完）

了吗？没有。

请回到这篇题解的开头，看一看注意事项：

# 连续不重叠且非空的两段

先看这组数据
```
5

-1 -4 -5 3 -3
```
如果用以上算法，答案是3，但正确答案应该是2

因为如果只选择了3这个数的话，有一个子段是空集

在选择两个最小子段和时，程序选择了-1 -4 -5 和 -3

所以取反就只有3了

那么什么时候程序会出问题？

1.全部负数，第二小问取全部数

2.只有一个非负整数，第二小问取反后只有一个数

特判就好了

code：
```cpp#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int inp[200005];
int db[200005];
int lef[200005];
int rig[200005];
int main()
{
	int n,ans=-2e9,sum=0,tem=2e9;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&inp[i]);
		sum+=inp[i];
		db[i]=inp[i];
	}
	sort(db+1,db+1+n);
	if(db[n-1]<0)
	{
		printf("%d",db[n]+db[n-1]);
		return 0;
	}//特判，数据水随便搞 
	//第一问 
	for(int i=1;i<=n;i++)
	{
		if(lef[i-1]>0) lef[i]=inp[i]+lef[i-1];
		else lef[i]=inp[i];
	}
	for(int i=n;i>=1;i--)
	{
		if(rig[i+1]>0) rig[i]=inp[i]+rig[i+1];
		else rig[i]=inp[i];
	}
	for(int i=2;i<=n;i++) lef[i]=max(lef[i],lef[i-1]);
	for(int i=n-1;i>=1;i--) rig[i]=max(rig[i],rig[i+1]);
	for(int i=1;i<n;i++) ans=max(ans,lef[i]+rig[i+1]);
	memset(lef,0,sizeof(lef));//一定一定要记得初始化！！！ 
	memset(rig,0,sizeof(rig));
	//第二问 
	for(int i=1;i<=n;i++)
	{
		if(lef[i-1]<0) lef[i]=inp[i]+lef[i-1];
		else lef[i]=inp[i];
	}
	for(int i=n;i>=1;i--)
	{
		if(rig[i+1]<0) rig[i]=inp[i]+rig[i+1];
		else rig[i]=inp[i];
	}
	for(int i=2;i<=n;i++) lef[i]=min(lef[i],lef[i-1]);
	for(int i=n-1;i>=1;i--) rig[i]=min(rig[i],rig[i+1]);
	for(int i=1;i<n;i++) tem=min(tem,lef[i]+rig[i+1]);
	ans=max(ans,sum-tem);
	printf("%d",ans);
	return 0;
}
```
（完）

---

## 作者：紫薯布丁 (赞：2)

## 在这里介绍一种思路清奇~~鬼畜~~的dp做法



题意：给定一个环状序列，求两段不相交的连续子区间的最大和。

当时我做这道题的思路是设$f[i][2][2]$ 表示前i个元素

第一段没有开始选（0），开始选但是没有结束（1），选了并且结束了（2）

第二段没有开始选，开始选但是没有结束，选了并且结束了。

那么dp方程就变得比较显然了，对于每一种状态，我们可以轻易地求出能转移的状态

```cpp
f[0][0][0]=0;
f[i][2][1]=max(f[i-1][2][0]+a[i],f[i-1][2][1]+a[i]);
f[i][2][2]=max(f[i-1][2][1]+a[i],max(f[i-1][2][2],f[i][2][1]));
f[i][1][0]=max(f[i-1][0][0]+a[i],f[i-1][1][0]+a[i]);
f[i][2][0]=max(f[i-1][2][0],max(f[i-1][1][0]+a[i],f[i][1][0]));
```



~~然后我就开开心心地把环拆成俩然后过了样例交上去他就wa了~~

为什么呢，因为里面的元素可能会有一部分重复选了。

我们发现：**首尾相接的区间实际上可以拆成必须选择头和尾的两段区间**

那实际上，我们的问题就变成了：**求1-n中两段连续区间的最大值，或强制选择第首元素和尾元素的三段连续区间的最大值**

那么我上面那个非常鬼畜的dp，还要多加一维.........~~（虽然有的状态实际上是多余的不过也懒得改了，而且这样会更好理解一些）~~

于是就出现了下面神奇的ac代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

const int ss=5*1e5+7;
using namespace std;

int f[ss][3][3][3],a[ss];
main(){
	memset(f,-0x3f,sizeof(f));
	f[0][0][0][0]=0;
	int n;cin>>n;
	for(int i=1;i<=n;i++){cin>>a[i];a[n+i]=a[i];}
	for(int i=1;i<=n;i++){
	    f[i][0][0][0]=0;
		f[i][2][1][0]=max(f[i-1][2][0][0]+a[i],f[i-1][2][1][0]+a[i]);
		f[i][2][2][0]=max(f[i-1][2][1][0]+a[i],max(f[i-1][2][2][0],f[i][2][1][0]));
		f[i][1][0][0]=max(f[i-1][0][0][0]+a[i],f[i-1][1][0][0]+a[i]);
		f[i][2][0][0]=max(f[i-1][2][0][0],max(f[i-1][1][0][0]+a[i],f[i][1][0][0]));
	}
	int ans=f[n][2][2][0];
	memset(f,-0x3f,sizeof(f));
	f[1][1][0][0]=a[1];
	for(int i=2;i<=n;i++){
	   f[i][1][0][0]=f[i-1][1][0][0]+a[i];
	   f[i][2][0][0]=max(f[i-1][1][0][0]+a[i],max(f[i-1][1][0][0],f[i-1][2][0][0]));
	   f[i][2][1][0]=max(f[i-1][2][0][0]+a[i],f[i-1][2][1][0]+a[i]);
	   f[i][2][2][0]=max(f[i-1][2][2][0],max(f[i-1][2][1][0]+a[i],f[i][2][1][0]));
	   f[i][2][2][1]=max(f[i-1][2][2][0]+a[i],f[i-1][2][2][1]+a[i]);
	   if(i!=n) f[i][2][2][2]=-1060633226;
	   else f[i][2][2][2]=max(f[i-1][2][2][1]+a[i],f[i-1][2][2][0]+a[i]);
	}
	printf("%d\n",max(f[n][2][2][2],ans));
}
```


---

## 作者：chdy (赞：2)

还是由我来发一个比较清晰的题解吧，~~早上头脑清晰一下子就知道怎么写了。~~

1. 求两端最大连续字段的和 考虑dp 由于是环形的我们先不管。。

2. 考虑一个简化版的问题不是环形让你选出两段的最大子段和。

3. 贪心肯定是不行的。

贪心无法得到我们想要的情况。况且答案肯定不是贪心早就的。我们要想办法便利到整个状态空间。

- 设状态 f[i][j][k] 表示到了第i个数字前面已经选择了j段当前数字选不选0/1 这个状态是必要的，因为包含了整个状态空间。

- 转移简单 但是注意不要忘记j==0时的转移比较特殊。。

接下来讨论环形，3种方法：

1. 暴力做n次dp 然后统计最优答案。

2. 破环成链在后面续上一段，然后转移取其中的一段。

3. 两次dp，一次不连接，一次强制连接。

1 n过大做不了 

2 续上一段其要求的是和前面没有什么影响我们这个状态一转移就是和前面i-1有关系所以也不行。

3 是可以的我们这个状态可以强制选1和n 然后剩下的直接转移即可。
也就是当成3段来做但是最后让第一段和第三段连接起来。

code：

```cpp
//#include<bits/stdc++.h>
#include<iostream>
#include<queue>
#include<iomanip>
#include<cctype>
#include<cstdio>
#include<deque>
#include<utility>
#include<cmath>
#include<ctime>
#include<cstring>
#include<string>
#include<cstdlib>
#include<vector>
#include<algorithm>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)>(y)?(y):(x))
#define INF 1000000000
#define ll long long
#define db double
using namespace std;
char buf[1<<15],*fs,*ft;
inline char getc()
{
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline int read()
{
	int x=0,f=1;char ch=getc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}
inline void put(int x)
{
    x<0?putchar('-'),x=-x:0;
    int num=0;char ch[50];
    while(x)ch[++num]=x%10+'0',x/=10;
    num==0?putchar('0'):0;
    while(num)putchar(ch[num--]);
    putchar('\n');return;
}
const int MAXN=200010;
int n,maxx=-(INF<<1);
int a[MAXN];
int f[MAXN][3][2];//f[i][j][k]表示到了第i个数字选择了j段且当前数字选择了没有0/1
//两次dp 一次断开 一次强制连接
int main()
{
	//freopen("1.in","r",stdin);
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	memset(f,0xcf,sizeof(f));
	f[0][0][1]=f[0][0][0]=0;
	for(int i=1;i<=n;++i)
		for(int j=0;j<=2;++j)
		{
			if(j>=1)f[i][j][1]=max(f[i][j][1],(ll)f[i-1][j-1][0]+a[i]);
			if(j>=1)f[i][j][1]=max(f[i][j][1],(ll)f[i-1][j-1][1]+a[i]);
			if(j>=1)f[i][j][1]=max(f[i][j][1],(ll)f[i-1][j][1]+a[i]);
			f[i][j][0]=max(f[i][j][0],f[i-1][j][1]);
			f[i][j][0]=max(f[i][j][0],f[i-1][j][0]);
		}
	maxx=max(f[n][2][0],f[n][2][1]);
	memset(f,0xcf,sizeof(f));
	f[1][0][1]=a[1];
	for(int i=2;i<=n;++i)
	{
		for(int j=0;j<=2;++j)
		{
			if(j>=1)f[i][j][1]=max(f[i][j][1],(ll)f[i-1][j-1][0]+a[i]);
			if(j>=1)f[i][j][1]=max(f[i][j][1],(ll)f[i-1][j-1][1]+a[i]);
			f[i][j][1]=max(f[i][j][1],(ll)f[i-1][j][1]+a[i]);
			f[i][j][0]=max(f[i][j][0],f[i-1][j][1]);
			f[i][j][0]=max(f[i][j][0],f[i-1][j][0]);
		}
	}
	maxx=max(maxx,f[n][2][1]);
	put(maxx);
	return 0;
}

```
注意f数组要强制转换一下。仔细理解每次dp时的第三个转移。

撒花✿✿ヽ(°▽°)ノ

---

## 作者：Cyhlnj (赞：2)


两种情况

第一种就是类似---000---000---(0表示选)，这个可以DP

设$h[0/1/2/3][i]$表示到第$i$位的状态：

$0$:表示还没选

$1$:表示当前在第一段

$2$:表示选完了第一段

$3$:表示当前在第二段

第二种就是类似000****000---000，这个也可以DP

设$f[0/1/2/3][i]$表示到第$i$位的状态：要强制选左边

$0$:表示目前在第一段

$1$:表示第一段选完

$2$:表示目前在第二段

$3$:表示第二段选完

设$g[0/1/2/3][i]$从后往前，强制选右边


f和g拼起来就好了


```cpp
# include <bits/stdc++.h>
# define IL inline
# define RG register
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;
const int _(2e5 + 5);

IL ll Read(){
    RG char c = getchar(); RG ll x = 0, z = 1;
    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * z;
}

ll n, a[_], f[4][_], g[4][_], ans = -1e18, h[4][_];

int main(RG int argc, RG char* argv[]){
    n = Read(); Fill(f, -63); Fill(g, -63); Fill(h, -63);
    for(RG int i = 1; i <= n; ++i) a[i] = Read();
    f[0][0] = g[0][n + 1] = h[0][0] = 0;
    for(RG int i = 1; i <= n; ++i){
        f[0][i] = f[0][i - 1] + a[i];
        f[1][i] = max(f[0][i], f[1][i - 1]);
        f[2][i] = max(f[1][i - 1], f[2][i - 1]) + a[i];
        f[3][i] = max(f[2][i], f[3][i - 1]);
        h[0][i] = h[0][i - 1];
        h[1][i] = max(h[0][i - 1], h[1][i - 1]) + a[i];
        h[2][i] = max(h[1][i - 1], h[2][i - 1]);
        h[3][i] = max(h[3][i - 1], h[2][i - 1]) + a[i];
        ans = max(ans, h[3][i]);
    }
    for(RG int i = n; i; --i){
        g[0][i] = g[0][i + 1] + a[i];
        g[1][i] = max(g[0][i], g[1][i + 1]);
        g[2][i] = max(g[2][i + 1], g[1][i + 1]) + a[i];
        g[3][i] = max(g[2][i], g[3][i + 1]);
    }
    for(RG int i = 1; i < n; ++i){
        ans = max(ans, f[3][i] + g[1][i + 1]);
        ans = max(ans, f[1][i] + g[3][i + 1]);
    }
    printf("%lld\n", ans);
    return 0;
}

```

---

## 作者：tututu (赞：2)

~~大家的程序可能都有点错...(可能我眼瞎)~~


如数据:


```cpp
4
-1 1 -1 -1
```

AC程序好像输出都是1...


# ---------------------


接下来说正常思路


就是楼下这种吧...


感觉有问题的情况就是求最小两段子段和的时候,有可能两端都取到,这时只留下一段..而长度有可能仅为1而作为答案..


其他也就一样了~~(参考了其他题解..)~~


```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
const int N=200005;
int n,a[N],f[N],g[N],ans=-1<<30,sum;
int sol(){
  int ans=-1<<30;
  rep(i,1,n) f[i]=max(f[i-1],0)+a[i];
  for(int i=n;i;i--) g[i]=max(g[i+1],0)+a[i];
  rep(i,1,n) f[i]=max(f[i-1],f[i]);
  for(int i=n;i;i--) g[i]=max(g[i+1],g[i]);
  rep(i,2,n) ans=max(ans,f[i-1]+g[i]);
  return ans;
}
int main(){
  cin>>n;
  f[0]=g[n+1]=-1<<30;
  rep(i,1,n) scanf("%d",&a[i]),sum+=a[i];
  ans=sol();
  rep(i,1,n) a[i]=-a[i];
  if(sum+sol()) ans=max(ans,sum+sol());
  cout<<ans;
  return 0;
}
```

---

## 作者：翼德天尊 (赞：1)

**声明：** 参考文章[最大子段和及其变式的启示](https://www.luogu.com.cn/blog/wey-yzyl/zui-tai-zi-duan-hu-ji-ji-bian-shi-di-qi-shi#)。在这篇文章的基础上，笔者加入了自己的理解，并进行了更为详细地整理，以及扩充了本题的一些坑点，希望能你有所帮助。

-----------

## ①普通最大子段和

最优复杂度为 $O(n)$。

### 1. 动态规划

考虑设 $dp_i$ 为序列 $1$ 到 $i$ 中以 $a_i$ 结尾的子段的最大值。则很容易想到 $dp$ 方程为：

$$dp_i=\max(dp_{i-1},0)+a_i$$

则序列的最大子段和为所有 $dp$ 值的最大值。

### 2. 前缀和法（定义）

考虑用 $sum$ 数组表示 $a$ 数组的前缀和数组，则序列 $1$ 到 $i$ 中的最大子段可以表示为 $sum_i-\min(sum_k)(1\le k<i)$。

动态维护前缀和最小值即可。最终答案为所有最大子段的最大值。

----------

## ②环状最大子段和

即 $a_1$ 与 $a_n$ 相邻。最优复杂度 $O(n)$。

### 1. 动态规划法（断环成链）

经典 trick。考虑将序列倍长后，以每一个长度为 $n$ 的子段为一个子问题跑问题①中的 $dp$，然后将每一个子问题的结果取一个最大值即为答案。

### 2. 动态规划法2（分类讨论）

将答案所在区间分为两种情况讨论：

- 区间不过左右端点。则跑问题①中 $dp$ 即可。

- 区间过左右端点。则将问题①中求区间最大子段和变为求区间最小子段和，然后将最小子段和用序列总和减去即为位于其两侧的最大子段和。

将上面两种情况的答案取最大值即为最终答案。

-----------

## ③区间最大两段子段和

最优复杂度 $O(n)$。

### 1. 动态规划法

考虑正着跑一边问题①中的 $dp$ 算出每一个区间 $1$ 到 $i$ 的最大子段和（记得取最大值），然后再倒着跑一边 $dp$ 算出每一个区间 $i$ 到 $n$ 的最大子段和。最后求出所有

$$dp1_{i}+dp2_{i+2}(1\le i\le n-2)$$

的最大值即为答案。注意如果两段子段可以相邻的话，将式子中的 $dp2$ 的下标改为 $i+1$ 即可。

### 2. 前缀和法（定义）

跟动态规划法差不多，依旧是正着倒着跑一边问题①中的方法，然后将正着的答案和倒着的答案即可起来即为最终答案。

------------

## ④环状最大两段子段和

最优复杂度 $O(n)$。

### 动态规划法

结合问题④和问题⑤。

- 两段区间都没有跨过左右端点。

类似于：`***111****2222*`


则转化为问题③，分别正着倒着跑一遍问题①中的 dp，然后将两者答案结合起来取最大值即为答案。

- 两段区间中有一段跨过左右端点。

类似于：`111****222**1111`

考虑将问题转化为求区间最小两段子段和（问题③的变式），然后将这两段的和剔除出总和即为答案。

最终答案即为上述两种情况的最大值。

**注意：**

- 题面中并未规定两段子段不能相邻。

- 序列可能全为负数，此时按照上面程序会取第二种情况，答案为 $0$。需要输出最大的两个负数的和（如果子段不能相邻则要输出两个不相邻的负数的最大值）。

- 第二种情况可能会出现一个最小子段的左端点为 $1$，一个最小子段的右端点为 $n$ 的情况，此时会将跨过左右端点的最大子段挤掉。由于此时一定只有一段正数，若该段正数的个数大于 $1$，则输出该段正数的和即可（可以通过正常程序跑出正确答案）。若该段正数个数等于 $1$，则输出该正数与序列最大的负数之和即可。

**代码如下：**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 200005
int n,a[N],dp1[N],dp2[N],ans=-999999999,sum,dp3[N],dp4[N],pd; 
int read(){
	int w=0,f=1;
	char ch=getchar();
	while (ch>'9'||ch<'0'){
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9'){
		w=(w<<3)+(w<<1)+(ch^48);
		ch=getchar();
	}
	return w*f;
}
int main(){
	n=read();
	for (int i=1;i<=n;i++){
		a[i]=read(),sum+=a[i];
		if (a[i]>0) ++pd;//判断正数个数
	}
	if (!pd){//没有正数
		int x=-99999999,y=-99999999;
		for (int i=1;i<=n;i++)
			if (a[i]>x) x=a[i],y=x;
			else if (a[i]>y) y=a[i];
		printf("%d\n",x+y);
		return 0;
	}else if (pd==1){//只有一个正数
		int x=-99999999,y=0;
		for (int i=1;i<=n;i++){
			if (a[i]>0) y+=a[i];
			else if (a[i]>x) x=a[i];
		} 
		printf("%d\n",x+y);
		return 0;
	}
	dp1[1]=dp3[1]=a[1];
	dp2[n]=dp4[n]=a[n];
	for (int i=2;i<=n;i++) dp1[i]=max(dp1[i-1],0)+a[i],dp3[i]=max(dp3[i-1],dp1[i]);
	for (int i=n-1;i>=1;i--) dp2[i]=max(dp2[i+1],0)+a[i],dp4[i]=max(dp4[i+1],dp2[i]);
	for (int i=1;i<=n-2;i++){
		ans=max(ans,dp3[i]+dp4[i+1]);
	}
	dp1[1]=dp3[1]=a[1];
	dp2[n]=dp4[n]=a[n];
	for (int i=2;i<=n;i++) dp1[i]=min(dp1[i-1],0)+a[i],dp3[i]=min(dp3[i-1],dp1[i]);
	for (int i=n-1;i>=1;i--) dp2[i]=min(dp2[i+1],0)+a[i],dp4[i]=min(dp4[i+1],dp2[i]);
	for (int i=1;i<=n-2;i++){
		ans=max(ans,sum-dp3[i]-dp4[i+2]);
	} 
	printf("%d\n",ans);
    return 0;
}
```

------------

**扩展**：如果序列带修改操作，则可以采用线段树的 $O(\text{log }n)$ 做法，本文在此不再赘述，可以参考题目[P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)自行学习。

如果对你有帮助，不妨点个赞吧！

---

## 作者：HPXXZYY (赞：1)

$\color{blue}{\texttt{[Solution]:}}$

对于环上的 `dp`，我们一般考虑破环为链法，即把环转化为链。

破环为链法中，又有几种比较常见的处理方法，这里列举两种：

1. 把数组复制两遍，即把数组 $a_{1..n}$ 变成数组 $a_{1..2n}$，其中 $a_i=a_{i-n}(n+1 \leqslant i\leqslant 2n)$。这是最常用的一种破环为链法。
2. 不复制，直接用其它方法把环转化为链。

在本题中，我们发现虽然第一种很常用，但是我们仍然无法用它来解决问题。所以我们考虑第二种方法。

我们发现用第二种方法时，我们无法把所有的情况统一在一起讨论，这个时候，我们就需要用到另一种数学（$\texttt{OI}$ 也适用）的方法了，那就是：分类讨论。

- 第一种情况：两段子段都不跨越首尾，即类似于这样的：
  
  $$0001111100002220000$$
  
  $0$ 表示该位不选，$1$ 表示选且属于第一子段，$2$ 表示选且属于第二子段。

  我们记 $f_i$ 表示 $a_{1..i}$ 的最大子段和，$g_i$ 表示 $a_{i..n}$ 的最大子段和，则答案为：

  $$\max\limits_{i=1}^{n} f_i+g_{i+1}$$

- 第二种情况：其中一个子段跨越了首尾，即类似于此：

  $$2220001111110000022$$

  命名方法同上。

  直接求很难，我们就考虑反着做，毕竟正难则反。

  我们发现 $0$ 所占据的正好就是两个子段，于是，我们即 $f_i$ 表示 $a_{1..i}$ 的最小子段和，$g_i$ 表示 $a_{i+1..n}$ 的最小子段和。则答案为：

  $$\sum\limits_{i=1}^{n} a_i - \min\limits_{i=1}^{n} f_i + g_{i+1}$$

  注意当 $f_i+g_{i+1}$ 正好就是整个区间的情况，需要特判，因为这样相当于选得数为空。

$\color{blue}{\texttt{[my AC node]:}}$

```cpp
const int N=2e5+100;
#define ll long long
int n;ll ans,res,sum;
ll f[N],g[N],h[N],a[N];
const ll inf=0x3f3f3f3f3f;
inline ll calc_min_sum(){
	h[0]=h[n+1]=f[0]=g[n+1]=inf;
	for(register int i=1;i<=n;i++){
		h[i]=min(h[i-1]+a[i],a[i]);
		f[i]=min(f[i-1],h[i]);
	}
	for(register int i=n;i>=1;i--){
		h[i]=min(h[i+1]+a[i],a[i]);
		g[i]=min(g[i+1],h[i]);
	}
	register ll ret=inf;
	for(int i=1;i<=n;i++)
		ret=min(ret,f[i]+g[i+1]);
	return ret;
}
inline ll calc_max_sum(){
	h[0]=h[n+1]=f[0]=g[n+1]=-inf;
	for(register int i=1;i<=n;i++){
		h[i]=max(h[i-1]+a[i],a[i]);
		f[i]=max(f[i-1],h[i]);
	}
	for(register int i=n;i>=1;i--){
		h[i]=max(h[i+1]+a[i],a[i]);
		g[i]=max(g[i+1],h[i]);
	}
	register ll ret=-inf;
	for(int i=1;i<=n;i++)
		ret=max(ret,f[i]+g[i+1]);
	return ret;
}
int main(){
	n=read();//我们的程序开始了 
	for(int i=1;i<=n;i++)
		sum+=(a[i]=read());
	ans=calc_max_sum();//求最大 
	res=calc_min_sum();//求最小 
	if (res==sum){//全部数子为负 
		res=ans=-inf;//最大;次大 
		for(int i=1;i<=n;i++){
			if (a[i]>res){
				ans=res;
				res=a[i];
			}
			else ans=max(ans,a[i]);
		}
		printf("%lld",ans+res);
	}
	else{//数字有正有负(普通情况) 
		printf("%lld",max(ans,sum-res));
	}
	return 0;
}
```



---

## 作者：Nemlit (赞：1)

不难发现，我们能选择的集合只有下面两种情况：

$1.\ \ \ (000)111(000)111(000)$

$2.\ \ \ 111(000)111(000)111$

0旁边的括号表示：中间的0可以省略也符合题意

我们两种情况分开考虑

对于第一种情况，我们枚举一个断点，对两端分别做最大子段和。

举个例子，我们可以分别对$[1, 5]\ \ [6, 10]$分别做最大子段和，答案即是两端最大子段和相加的值

每一次左端点仅仅向右移一位，右端点仅仅向左移动一位，所以我们每次没有必要重新算最大子段和，只需记:$left[i]$表示$[1, i]$的最大子段和，$right[i]$表示$[i, n]$的最大子段和即可。

对于第二种情况，我们可以用总和-两段最小子段和，两端最小子段和的求法同上

但是有一个更巧妙的方法：最小子段和=将原数组取反后的最大子段和。证明的话感性理解即可。

于是我们只需要将原数组取反，再做一遍第一种情况即可
````

````
还有本题需要注意一个地方：如果我没有正数，或者只有一个正数，对于第二种情况，我们取反后会变成只有一个负数或者没有，所以我们的最大字段和可能取到$[1, i - 1]\ \ [i + 1, n]$，由于我们第二种情况的意义是不能取这些数，所以对于上述情况我们实际上是指选了1个数的，很明显这不符合题意，于是我们需要加特判

### $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define inf 123456789
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define maxn 200005
int n, m, a[maxn], dp[maxn], lef[maxn], rig[maxn], ans1, ans2, sum, m1, m2, tot;
il void doit(int l, int r) {
	dp[l - 1] = dp[r + 1] = lef[l - 1] = rig[r + 1] = -inf;
	rep(i, l, r) dp[i] = max(dp[i - 1], 0) + a[i], lef[i] = max(lef[i - 1], dp[i]);
	drep(i, l, r) dp[i] = max(dp[i + 1], 0) + a[i], rig[i] = max(rig[i + 1], dp[i]);
}
il void solve(int x) {
	sum += x, tot += (x > 0);
	if(x >= m1) m2 = m1, m1 = x;
	else if(x >= m2) m2 = x;
}
int main() {
	n = read(), ans1 = ans2 = m1 = m2 = -inf;
	rep(i, 1, n) a[i] = read(), solve(a[i]);
	if(tot < 2) return printf("%d", m1 + m2), 0; 
	doit(1, n);
	rep(i, 2, n - 1) ans1 = max(ans1, lef[i - 1] + rig[i + 1]);
	rep(i, 1, n) a[i] = -a[i];
	doit(1, n);
	rep(i, 2, n - 1) ans2 = max(ans2, lef[i - 1] + rig[i + 1]);
	printf("%d", max(ans1, sum + max(0, ans2)));
	return 0;
}
```

---

## 作者：神之右大臣 (赞：1)

我来一发很实用的题解；

本人想出了O(n)的做法，是一种DP；

先说大体思路:

答案分两种情况，一种是选择的两段均不跨越n到1(也就是环)，另一种是选择的两段跨过了环;

如果均不跨越环，那么也就是意味着这是一道模板题；

设maxl[i]表示从1~i的最大字串和，maxr[i]表示i~n的最大字段和；
很明显的:答案就是max(maxl[i]+maxr[i+1])
```cpp
maxl[i]=max(a[i],maxl[i-1]+a[i]);//表示这一位是不是一段区间的开头；
maxl[i]=max(maxl[i-1],maxl[i]);
maxr[i]=max(a[i],maxr[i+1]+a[i]);
maxr[i]=max(maxr[i],maxr[i+1]);
```
所以目前你的期望分数就是50了；


然后处理环：

我们换种思维，就好比并查集维护联通时可以运用逆向思维一样，把拆边改为加边，你求1~n带环的最大值就等价于求(1~n的区间和)减去(1~n的两段区间最小值)

求最小值的方法和求最大值的方法是一样的，稍加更改就可以了；

然后期望分数100

然后就A了吗？

嗯~？怎么才打了80分？

你跑一遍程序，试试这组数据:
3
-2 -4 -5

你的多少？0？正解是-6啊！

这是因为题中要求是两段非空的字串，所以当整个串都是负数时应该特判，选择最大的两个值加起来就是答案了；

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
long long a[200010];
long long maxl[200010],minl[200010],maxr[200010],minr[200010];
signed main()
{
	int n;
	cin>>n;
	long long sum=0;
	long long maxn=-999999999999;
	for(register int i=1;i<=n;i++){
        cin>>a[i];
		maxn=max(maxn,a[i]);
		sum+=a[i];
	}
	for(register int i=1;i<=n;i++){
		maxl[i]=maxr[i]=-999999999999;
		minl[i]=minr[i]=999999999999;
	}
	maxl[1]=a[1];
	minl[1]=a[1];
	maxr[n]=a[n];
	minr[n]=a[n];
	for(register int i=2;i<=n;i++){
		maxl[i]=max(a[i],maxl[i-1]+a[i]);
		minl[i]=min(a[i],minl[i-1]+a[i]);	
	}	
	for(register int i=2;i<=n;i++){
		maxl[i]=max(maxl[i-1],maxl[i]);
		minl[i]=min(minl[i-1],minl[i]);
	}
	for(register int i=n-1;i>=1;i--){
		maxr[i]=max(a[i],maxr[i+1]+a[i]);
		minr[i]=min(a[i],minr[i+1]+a[i]);		
	}
	for(register int i=n-1;i>=1;i--){
		maxr[i]=max(maxr[i],maxr[i+1]);
		minr[i]=min(minr[i],minr[i+1]);
	}
	long long anspart1=-999999999999,anspart2=999999999999;
	for(register int i=1;i<=n;i++){
		anspart1=max(anspart1,maxl[i]+maxr[i+1]);
		anspart2=min(anspart2,minl[i]+minr[i+1]);
	}
	long long ans=max(anspart1,sum-anspart2);
	sort(a+1,a+1+n);
	if(sum==anspart2){
		ans=a[n]+a[n-1];
	}
	cout<<ans;
}
/*
6
3 2 -1 1 -1 5

8
-5 -8 -23 -5 -6 -7 -12 -6 -7
*/
```



---

## 作者：蒟蒻yzm (赞：1)

不妨先看下不是环状的解法：

由于是两段, 因此必然会有⼀个分界点, 可以从这里把序列
切开。
• 那么，我们只要 O(N) 枚举分界点 i，如果能快速求出 [1, i-1]
和 [i + 1, N] 中的最⼤⼦段和，那么本题就能成功解决。
• f[i] 表示 [1, i-1] 中的最⼤⼦段和，g[i] 表示 [i + 1, N] 中的最⼤
⼦段和，预处理 f[i], g[i]，即正着⼀遍、反着⼀遍做最⼤⼦段
和即可。

于是有了以下对于环状的解法：

分割情况⽆非两种：

1 两段最⼤⼦段和完整，两段最小⼦段和的其中⼀段被分割

2 两段最小⼦段和完整，两段最⼤⼦段和的其中⼀段被分割

• 所以我们就先求两段最⼤/小⼦段和，然后分类讨论，比比
哪个结果⼤就好了。（普及蒟蒻打紫题，巨佬别打我QAQ）

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[200001],n,g[200001],a[200001],aa,bb,sum,ans,anss=-9999999,ansss=9999999,x[200001],y[200001];//x[i]表示以i为分界点的两段最大子段和的和，y[i]表示以i为分界点的两段最小子段和的和 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]),sum+=a[i];
	for(int i=2;i<n;++i)
	{
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		aa=-9999999;
		bb=-9999999;
    	for(int j=1;j<i;++j)f[j]=max(f[j]+a[j],f[j]),aa=max(aa,f[j]);
	    for(int j=i+1;j<=n;++j)g[j]=max(g[j]+a[j],g[j]),bb=max(bb,g[j]);
	    x[i]=aa+bb;
    }
    for(int i=2;i<n;++i)anss=max(anss,x[i]);
    for(int i=2;i<n;++i)
	{
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		aa=9999999;
		bb=9999999;
    	for(int j=1;j<i;++j)f[j]=min(f[j]+a[j],f[j]),aa=min(aa,f[j]);
	    for(int j=i+1;j<=n;++j)g[j]=min(g[j]+a[j],g[j]),bb=min(bb,g[j]);
	    y[i]=aa+bb;
    }
    for(int i=2;i<n;++i)ansss=min(ansss,y[i]);
    ans=max(anss,sum-ansss);
    printf("%d",ans);
    return 0;
}
```


---

## 作者：AKB48 (赞：1)

题目大意：在一个环状序列中取两段非空且和最大。

这题很有难度，如何破环为链？用到第一题的方法？

可以发现，结果无非只有两种情况。

—————[color=red]|———|[/color]——————[color=red]|—————|[/color]—————
1、  取到的两段在中间，则枚举切割点，分成两段，分别用第一题方法求解，取和最大。

[color=red]—————|[/color]———[color=red]|——————|[/color]—————[color=red]|—————[/color]
2、  取到的两段一段在中间，一段在首尾。

发现图2与图1很相似，如果枚举3段红色部分可能会超时。于是可以枚举两段黑色部分，即找两段连续非空和最小，然后用总和减去这两段黑色部分，再取最大值。（注意如果总和-黑色=0说明全都不取，而如果都是负数就会出错）；也可以全部取负，然后取最大。


---

## 作者：bingliang (赞：1)

对于一般的环形线性dp，我们一般会倍长他的链，然后按照区间dp的思路处理。

这道题一开始时我一直在按照正常的dp思路考律，想先写出状态转移方程，在进行优化。于是一直卡在了这里。这题也做了好久了，后来也没有管那个n^3的解法。应该是能a3个点的。以后可以在写下。

现在说正解，这也是环形问题的另外一种思路，感觉自己得马上积累下来。

就是说从正常dp考虑，有一种思路是分情况讨论。就是说我们对于环的处理时有两种情况。

1.是要取得链在环割开的位置   及【l，1】再到【1，。。】；或者没有处于这个位置。

所以就是这样了。

然后再看下

对于情况1

我们分别从前后处理他的最大字段和。

2处理最小子段和

然后o（n）枚举割点就a了


---

## 作者：cirnovsky (赞：0)

# Description

给出一段环状序列，即认为$A_1$和$A_N$是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。

# Solution

一共三个关键词:

>环状

>最大

>两段子段和

显然这是一道DP题。。。然而我们可以把它搞成线段树!

普通的最大子段和相信大家都能够用线段树来完成。

无非就是记录区间和、区间最大子段和、区间最大前缀和、区间最大后缀和

然后合并时更新信息即可

那么两段子段和该怎么搞呢?

其实也不费脑子~~废笔~~

首先套路的讨论这两段的位置，我们可以发现有5种情况（画画图示意一下可能很丑反正意思你们能懂就行

![Annotation 2020-02-07 210659.png](https://i.loli.net/2020/02/07/cM8KnGyrefCLwRk.png)

总结出来我们需要在线段树里维护的东西有：

1. 区间和
4. 区间最大前缀
5. 区间最大后缀
2. 区间最大子段和
6. 区间最大前缀+后缀
8. 区间最大中间+后缀
7. 区间最大前缀+中间
3. 区间两段最大子段和

~~每行长度不下降看着还是很爽的。。。~~

具体实现看代码中的注释

```cpp
// 省略快读和一堆预处理命令

const int SIZE = 4e5 + 5;
const int INF = ~0U >> 1;
struct TreeNode { // 这里的意思应该很明确
	int sum;
	int maxSum;
	int maxSumDouble;
	int maxPrefixSum;
	int maxSuffixSum;
	int maxPrePlusSuf;
	int maxPrePlusMid;
	int maxSufPlusMid;
} data[SIZE<<2];
int ints[SIZE<<1], ans = -INF, n;

TreeNode UpdateMessages(TreeNode x, TreeNode y) { // 这是重点
	TreeNode res;
	res.sum = x.sum + y.sum; // 区间和标记上传
	res.maxSum = max(x.maxSum, y.maxSum); // // 区间最大子段和标记上传
	res.maxSum = max(res.maxSum, x.maxSuffixSum + y.maxPrefixSum); // 再把自己和两个儿子的最大前/后缀和的和比较
	res.maxPrefixSum = max(x.maxPrefixSum, x.sum + y.maxPrefixSum); // 其实下面都差不多
	res.maxSuffixSum = max(y.maxSuffixSum, y.sum + x.maxSuffixSum); // 实在不懂看上面的图
	res.maxPrePlusSuf = max(x.maxPrefixSum + y.maxSuffixSum, x.sum + y.maxPrePlusSuf); // 看了就明白了。。。
	res.maxPrePlusSuf = max(res.maxPrePlusSuf, y.sum + x.maxPrePlusSuf);
	res.maxPrePlusMid = max(x.maxPrePlusMid, x.sum + y.maxPrePlusMid);
	res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrefixSum + y.maxSum);
	res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrePlusSuf + y.maxPrefixSum);
	res.maxSufPlusMid = max(y.maxSufPlusMid, y.sum + x.maxSufPlusMid);
	res.maxSufPlusMid = max(res.maxSufPlusMid, y.sum + x.maxSum);
	res.maxSufPlusMid = max(res.maxSufPlusMid, y.maxPrePlusSuf + x.maxSuffixSum);
	res.maxSumDouble = max(x.maxSumDouble, y.maxSumDouble);
	res.maxSumDouble = max(res.maxSumDouble, x.maxSum + y.maxSum);
	res.maxSumDouble = max(res.maxSumDouble, x.maxSufPlusMid + y.maxPrefixSum);
	res.maxSumDouble = max(res.maxSumDouble, x.maxSuffixSum + y.maxPrePlusMid);
	return res;
}

void Initialization(int k, int l) { // 给线段树结点赋初值
	data[k].sum = data[k].maxPrefixSum = data[k].maxSuffixSum = data[k].maxSum = ints[l];
	data[k].maxSumDouble = data[k].maxPrePlusSuf = data[k].maxPrePlusMid = data[k].maxSufPlusMid = -INF;
} 

void BuildTree(int k, int l, int r) {
	if (l ^ r) BuildTree(ls, l, mid), BuildTree(rs, mid + 1, r), data[k] = UpdateMessages(data[ls], data[rs]);
	else Initialization(k, l);
}

TreeNode GetAnswers(int k, int l, int r, int x, int y) {
	if (l ^ x || r ^ y) {
		if (mid >= y) return GetAnswers(ls, l, mid, x, y);
		if (mid < x) return GetAnswers(rs, mid + 1, r, x, y);
		return UpdateMessages(GetAnswers(ls, l, mid, x, mid), GetAnswers(rs, mid + 1, r, mid + 1, y));
	} else return data[k];
}

signed main() {
	read(n);
	for (int i = 1; i <= n; ++i) read(ints[i]), ints[i + n] = ints[i];
	BuildTree(1, 1, n << 1);
	for (int i = 1; i <= n; ++i) ans = max(ans, GetAnswers(1, 1, n << 1, i, i + n - 1).maxSumDouble);
	write(io_l, ans);
}
```

---


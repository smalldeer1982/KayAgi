# [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

## 样例 #1

### 输入

```
3
1
1 2 1
1 3 3
```

### 输出

```
2
```

# 题解

## 作者：Mathison (赞：187)

题意让我们用最少的代价把叶子节点到根节点的距离调成相同

显然，我们调整靠近根节点的树枝，其下叶子节点距离根节点的距离都会增加，所以，**调整越靠根节点的树枝调整的代价越少**。

为了方便作图，效果直观，在此我们用**节点深度**类比**距离**

所以我们可以先找到最深的叶子节点

再从**最小的子树**开始，把所有子节点调整到**同一深度**，再调整子树上面的树枝

理解不了的话看这个图：

![](https://cdn.luogu.com.cn/upload/pic/34776.png)

这样我们就可以保证用最少的代价把所有叶子节点调整到同一深度

我们理解了这个问题就可以设计dfs了

每次调整的代价都是$dis[x]-(dis[ver[i]+edge[i])$

把它累加即可

下面是详细代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=500010;
int head[N],ver[N],next[N],tot,n,st,edge[N];
long long ans,dis[N];
void add(int x,int y,int z)//建图
{
	ver[++tot]=y;
	edge[tot]=z;
	next[tot]=head[x];
	head[x]=tot;
} 
void dfs(int x,int fa)
{
	for(int i=head[x];i;i=next[i])
	{
		int y=ver[i],z=edge[i];
		if(y==fa) continue;
		dfs(y,x);//继续搜子树
		dis[x]=max(dis[x],dis[y]+z);更新这棵子树根节点和叶子节点的最大距离
	}
	for(int i=head[x];i;i=next[i])
	{
		int y=ver[i],z=edge[i];
		if(y==fa) continue;
		ans+=dis[x]-(dis[y]+z);//累加每次调整的代价
	}
}
int main()
{
	scanf("%d%d",&n,&st);
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);//注意双向边
	}
	dfs(st,0);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：crazydave (赞：127)



# 思路
看输入数据，由于n个节点只有n-1条边，不难看出这是一棵树。我们可以反着思考，就是让所有叶子节点同时发出信号，然后这些信号同时到达根节点。于是我们可以自下而上的进行维护，使得每一节点所有子节点的信号同时到达该节点。

于是我们考虑如何维护。我们从根节点开始搜索，搜索到叶子节点，回溯的时候进行维护，先维护节点的所有子节点到该节点最大边权（边权为**叶子**节点到同时到达它所需要时间）。然后维护答案，答案为最大边权减去所有到子节点的边权。然后维护父节点的边权，父节点边权为该节点子节点的 最大边权+父节点到该节点的时间。然后就回溯，重复操作，到根节点为止。~~好难说清楚啊QWQ  看注释更明白一点~~

然后我们要注意一些细节：

 1. 一定要双向加边，是无向图。
 2.  既然是无向图，维护时不要把到父节点的边计算了。
 3. 维护的顺序一定不能乱。
 4. 答案要用long long 存。

# 代码

```
#include <bits/stdc++.h>
#define MAXN 1000005
using namespace std;
struct Edge{int next,to,dis;} edge[MAXN];
int n,s,a,b,t,maxn[MAXN],cnt,head[MAXN];  //maxn储存到子节点的最大边权
long long ans;  //注意，答案要用long long 存

void addedge(int from, int to, int dis)  
{
    edge[++cnt].next=head[from];
    edge[cnt].to=to;
    edge[cnt].dis=dis;
    head[from]=cnt;
}  //前向星加边

void dfs(int x, int fa) //X为当前搜索节点，fa为x的父亲节点
{
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) dfs(edge[i].to, x);
    //这一句一定要最先，先搜索到底层，回溯时再进行后续处理（从下向上维护）
    for(int i=head[x]; i; i=edge[i].next)
        if(edge[i].to!=fa) maxn[x]=max(maxn[x], edge[i].dis);
    //维护到子节点的最大边权
    for(int i=head[x]; i; i=edge[i].next)
    	if(edge[i].to!=fa) ans+=(maxn[x]-edge[i].dis);
    //维护答案
    for(int i=head[fa]; i; i=edge[i].next)
    	if(edge[i].to==x) edge[i].dis+=maxn[x];
    //这一句不能漏，更新父节点到该节点的边权
}//注意顺序不能乱

int main()
{
    scanf("%d%d",&n,&s);
    for(int i=1; i<=n-1; i++)
    {
        scanf("%d%d%d",&a,&b,&t);
        addedge(a, b, t);
        addedge(b, a, t); //是无向图，双向加边
    }
    dfs(s, 0);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：xyz32768 (赞：57)

正解：树形DP

可以证明这n个节点组成一棵树。以下time[i,j]表示从第i个节点到第j个节点(i与j之间有连边)需要的时间。

用dp[i]表示从第i个节点发出激励电流，在i的子树里达到时态同步最少需要操作的次数，

num[i]表示从第i个节点发出激励电流，在i的子树里达到时态同步的操作次数达到最少时，从第i个节点到达叶子节点需要的时间。

状态转移方程为：

num[i]=max{num[j]+time[i,j],j为i的子节点}

dp[i]=sigma{dp[j],j为i的子节点}+sigma{num[i]-(num[j]+time[i,j]),j为i的子节点}

最后结果为dp[激发器所在节点的编号]。


---

## 作者：LYang (赞：31)

/\*
听说这题要用树形动归；

但本人是个蒟蒻；

不会........；

所以就想了个暴力；

从根节点（激发器）开始搜；

一直搜到叶子节点；然后回溯；

回溯的过程中如果遇到有几个叶子节点到这一个节点；

就用道具把不足的补足；同时记录有多少个到达这个点的叶子结点；

因为以后要更新的话要把以前到这个点的路径不足的都要补足；

\*/
```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>
#define maxn 504561
using namespace std;
int head[maxn*2];
long long a[maxn*2];
int n,m,s,num;
long long ans=0;
bool vis[maxn];
struct point
{int to,next,dis;}e[maxn*2];
void add(int from,int to,int dis)
{
    e[++num].next=head[from];
    e[num].to=to;
    e[num].dis=dis;
    head[from]=num;
}
void dfs(int u)
{
    vis[u]=1;
    int cnt=0;
    for(int i=head[u];i!=0;i=e[i].next)
    {
        int to=e[i].to;
        if(!vis[to])
        {
                dfs(to);
               if(a[to]+e[i].dis>a[u])
               {
                   ans+=(a[to]+e[i].dis-a[u])*cnt;
                   cnt++;
                   a[u]=a[to]+e[i].dis;
               }
               else
               {
                   ans+=a[u]-a[to]-e[i].dis;
                   cnt++;
               }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&s);
    for(int i=1;i<n;i++)
    {int x,y,z;
    scanf("%d%d%d",&x,&y,&z);
    add(x,y,z);add(y,x,z);}
    memset(vis,0,sizeof(vis));
    dfs(s);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Social_Zhao (赞：19)

### 一维树形DP

其实题目是要求我们在某些边上增加一些权值，使得根到叶子的每一条链长度都相等，求增加的权值和最小是多少。

不难想到我们把其他的链都向最长链看齐就行了。

于是我定义了一些变量：

- $f[i]$：表示以$i$为根的子树上至少增加多少权值才能完成统一。
- $maxn[i]$：表示以$i$为根的子树到叶节点的最长链长度。
- 还有一些变量不需要定义成全局（用于卡常，为什么泥萌都不卡常啊QAQ）。比如：
  - $cnt$：以这个点为出发点，连接非父节点的边数
  - $sum$：以这个点为子树的所有链长度总和。

然后这题就很水了。动规方程也可以很快的写出来：

$$f[u] = \sum{(f[v]+maxn[u]-maxn[v]-w[u,v]}$$

（其中的$w[u,v]$表示$u$和$v$两点之间的边的权值）

为了卡常，我们用上面的变量化简一下：

$$f[u]=\sum{f[v]}+maxn[u] \times cnt - sum$$

然后代码就写出了。

注意：

- 开LL
- 建双向边。
- 如果枚举边的时候连到了祖先，``continue``

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;

const int MaxN = 5e5 + 5;
const int MaxM = MaxN * 2;
int n, s;
struct Edge {
    int v, nxt, w;
}edge[MaxM];
int head[MaxN], k = 0;
int maxn[MaxN], f[MaxN];

void addedge(int u, int v, int w) //连边
{
    edge[++k].v = v;
    edge[k].w = w;
    edge[k].nxt = head[u];
    head[u] = k;
}

void insert(int u, int v, int w) //双向边
{
    addedge(u, v, w), addedge(v, u, w);
}

void dfs(int u, int fa) //dfs
{
    f[u] = 0; //初值为0
    maxn[u] = 0;
    int sum = 0, cnt = 0;
    for(int i = head[u]; i; i = edge[i].nxt) {
        int v = edge[i].v;
        if(v == fa) continue;
        dfs(v, u); //先递归处理儿子
        cnt++;	//发出边数++
        int w = edge[i].w; 
        f[u] += f[v]; //累加子树需要增加的权和
        maxn[u] = max(maxn[v] + w, maxn[u]); //更新最长链
        sum += maxn[v] + w; //更新子树权和。子树已经完成大一统了，所以只需要加上maxn就行了。
    }
    f[u] += maxn[u] * cnt - sum; //转移
}

signed main()
{
    scanf("%lld%lld", &n, &s);
    for(int i = 1; i < n; i++) {
        int u, v, w;
        scanf("%lld%lld%lld", &u, &v, &w);
        insert(u, v, w);
    }
    dfs(s, 0);
    /*
    for(int i = 1; i <= n; i++) printf("%d ", f[i]);
    printf("\n");
    for(int i = 1; i <= n; i++) printf("%d ", maxn[i]);
    */
    printf("%lld", f[s]);
}
```



---

## 作者：lwhllw (赞：15)

从最下面往上理解，相同父亲的两个儿子的边一定要相同的边权。

然后写个dfs就行了，第一的神犇15ms %%%


---

## 作者：我不是柳橙汁 (赞：9)

# 感觉这并不是一道DP..

## 我是直接建了一个树，想想就过了。


首先我们以激发器来建一棵树

然后dfs找出每个点的深度

f[i]表示i点子树上叶节点的最大距离

在同一个分支，他的所有叶节点都必须要是**相同**的，而且**不能减少**

所以找出其中的最大值，其他的增加那么多

最后汇总到根节点就是最后的答案


```cpp
#include<cstdio>
#define fmax(a,b) ((a)>(b)?(a):(b))

struct edge{
    long long from,to,dis;
    long long next;
}e[1000010];

long long n,s,len,ans,vis[500010],f[500010],head[500010];

long long v_in(){
    long long sum=0;
    char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9'){
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum;
}

void add(long long u,long long v,long long w){//加边处理 
    e[++len].from=u;
    e[len].to=v;
    e[len].dis=w;
    e[len].next=head[u];
    head[u]=len;
}

void dfs1(long long u){
    vis[u]=1;
    for (long long i=head[u];i!=0;i=e[i].next){
        long long v=e[i].to;
        if (vis[v]==0){
            dfs1(v);
            f[u]=fmax(f[u],f[v]+e[i].dis);//深搜距离 
        }
    }
}

void dfs2(long long u){
    vis[u]=1;
    for (long long i=head[u];i!=0;i=e[i].next){
        long long v=e[i].to;
        if (vis[v]==0){
            dfs2(v);
            ans+=f[u]-f[v]-e[i].dis;//我们要保证每棵子树的所有叶子节点到该点的距离相等，所以必须将他们都修改到最大值 
        }
    }
}

int main(){
    n=v_in();
    s=v_in();
    for (long long i=1;i<n;i++){
        long long u=v_in(),v=v_in(),w=v_in();//读入边，加无向边 
        add(u,v,w);
        add(v,u,w);
    }
    dfs1(s);//第一遍深搜找出每个点子树距离最大值 
    for (int i=1;i<=n;i++) vis[i]=0;
    dfs2(s);//第二遍深搜找出需要使用的最小值 
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：ix35 (赞：6)

### 贪心+DFS做法

和其他题解中的思路都不太一样，首先我们找到一个离根节点最远的距离$dis$。然后我们的目标是将所有叶节点到根节点的距离都调整成$dis$。（这个应该比较明显，不可能更小，更大的话就不满足最少操作次数的要求）

可以发现，假如点$x$向所有子节点的连边上的操作次数的最小值为$k$，那么这个$k$其实可以转移到$x$向父节点的连边上。例如：

![Luogu](https://cdn.luogu.com.cn/upload/pic/59842.png)

边上的数字表示这条边上进行了多少次操作。对于$2$号点来说，其所有子节点到它的连边操作次数最小值是$3$，那么这个$3$就可以转移到$2$与父节点$1$的连边上，从而每个子节点的操作次数都可以减少3，从而达到减少操作次数的目的。

于是，我们用$dp[x]$表示$x$连向父节点的边的操作次数。通过dfs，搜到叶子节点$p$时若它到根节点的距离为$q$，则$dp[p]=dis-q$，表示其一开始的距离是$q$，最终要达到$dis$，接下来在回溯时执行转移：

$$dp[x]=\min\limits_{y\in son(x)}(dp[y])$$

设$x$的子节点有$cnt$个，那么原本$cnt$个$dp[x]$被转移到了一个点$x$上，所以答案要减少$dp[x]\times (cnt-1)$。最终回溯到根节点时即为答案。

注意根节点无法执行上面的转移方程，因为根节点没有再往上的边了。不过再仔细思考一下，会发现如果执行也无妨，因为$dp[root]$必然是$0$，因为一定有一个子节点到根节点的路径是不需要任何操作的。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=500010;
int n,s,x,y,z,tot,hd[MAXN],ver[MAXN*2],nx[MAXN*2];
ll edge[MAXN*2],dp[MAXN],ans,maxn;
void add_edge(int x,int y,ll z) {    //建边
    ver[++tot]=y;
    edge[tot]=z,nx[tot]=hd[x];
    hd[x]=tot;
    return;
}
void dfs1 (int x,int fa,ll dep) {    //计算最大距离
    int cnt=0;
    for (int i=hd[x];i;i=nx[i]) {
        if (ver[i]==fa) {continue;}
        dfs1(ver[i],x,dep+edge[i]);
        cnt++;
    }
    if (cnt==0) {maxn=max(maxn,dep);}
    return;
}
void dfs (int x,int fa,ll dep) {     //算答案
    ll minn=1e18,cnt=0;
    for (int i=hd[x];i;i=nx[i]) {
        if (ver[i]==fa) {continue;}
        dfs(ver[i],x,dep+edge[i]);
        cnt++,minn=min(minn,dp[ver[i]]);
    }
    if (cnt==0) {    //叶子节点
        dp[x]=maxn-dep,ans+=maxn-dep;
        return;
    }
    if (x!=s) {    //这个if可以去掉
        ans-=(cnt-1)*minn,dp[x]=minn;
    }
    return;
}
int main () {
    scanf("%d%d",&n,&s);
    for (int i=1;i<=n-1;i++) {
        scanf("%d%d%d",&x,&y,&z);
        add_edge(x,y,z),add_edge(y,x,z);
    }
    dfs1(s,0,0);
    dfs(s,0,0);
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：DDOSvoid (赞：6)

首先，显然时态同步之后，最长的时间即为原树中距离根节点最远的叶子节点的距离。其它的点只需要变到跟它一样长即可。一种很直观的做法，令 dis[u] 表示 u 到根的距离。令 Max 为最远的叶子节点到根的距离，w[u]=Max-dis[u] (如果 u 是叶子节点) 或 w[u] = min(w[v]) (u不是叶子节点，v是u的儿子) 。贪心的想，如果要把两个点都变的同步，那么肯定在它们的 lca 处 +w[lca]，这样肯定不亏。所以可以yy出一种算法。从根开始dfs，假设当前节点是u，将 u 的所有子树的 w[v] - w[u]，ans += w[u]，递归到子树，dfs序之后，相当于区间修改和单点查询，树状数组维护即可。~~感觉自己都没写明白。~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 500010
#define ll long long
#define INF 1000000000
using namespace std;

int n, s;
ll ans;

struct Edge{
    int to, next, w;
}e[maxn << 1]; int sz, head[maxn];
inline void add_edge(int u, int v, int w){
    e[sz].to = v; e[sz].w = w;
    e[sz].next = head[u]; head[u] = sz++;
}

ll Bit[maxn];
inline int lowbit(int x){return x & -x;}

inline void add(int i, int v){
    while(i <= n){Bit[i] += v; i += lowbit(i);}
}

inline int query(int i){int sum = 0;
    while(i){sum += Bit[i]; i -= lowbit(i);}
    return sum;
}

int in[maxn], out[maxn], w[maxn], cnt, Max, le[maxn], c;
void dfs1(int u, int fa){
    in[u] = ++cnt; bool f = 0;
    for(int i = head[u]; ~i; i = e[i].next){
        int v = e[i].to, _w = e[i].w;
        if(v == fa) continue; f = 1;
        w[v] = w[u] + _w; dfs1(v, u);
    }
    out[u] = cnt;
    if(!f) le[++c] = u, Max = max(Max, w[u]);
}

void dfs2(int u, int fa){
    int Min = INF; bool f = 0;
    for(int i = head[u]; ~i; i = e[i].next){
        int v = e[i].to; if(v == fa) continue; f = 1;
        dfs2(v, u); Min = min(Min, w[v]); 
    }
    if(f) w[u] = Min;
}

void dfs3(int u, int fa){
    bool f = 0;
    for(int i = head[u]; ~i; i = e[i].next){
        int v = e[i].to, w = query(in[v]); if(v == fa) continue; f = 1;
        add(in[v], -w); add(out[v] + 1, w); ans += w; dfs3(v, u);
    }
    if(!f) ans += query(in[u]);
}

int main(){ memset(head, -1, sizeof head);
    scanf("%d%d", &n, &s);
    for(int i = 1; i < n; ++i){
        int x, y, z; scanf("%d%d%d", &x, &y, &z);
        add_edge(x, y, z); add_edge(y, x, z);
    }
    dfs1(s, -1);
    for(int i = 1; i <= c; ++i) w[le[i]] = Max - w[le[i]];  dfs2(s, -1);
    for(int i = 1; i <= n; ++i) add(in[i], w[i]), add(in[i] + 1, -w[i]); dfs3(s, -1);
    cout << ans;
    return 0;
}
```

---

## 作者：ZORO (赞：5)


# $Description$
[题面](https://www.luogu.org/problem/P1131)

给你一颗有根树，你只能增加一条边的边权，最后需要使得根到每个叶子节点的距离相等

# $Solution$
一道有点贪心意味的$DP$题，假设一开始根节点到叶子节点的最远距离为$d$，考虑到只能加边权不能减边权，**显然最终根节点到所有叶子节点的距离$d2$一定等于$d$**

**所以整个过程是一个将每条路径长度“对齐”的过程**

我们进行树形$DP$，从叶子节点到根节点转移。设当前节点是$u$,那么必须保证向上传递时$u$到它的子树内的每个叶子节点距离相等，否则就永远“对不齐”了。

[![KUeccV.png](https://s2.ax1x.com/2019/10/24/KUeccV.png)](https://imgchr.com/i/KUeccV)


就拿上面这个例子来说，假如$dis(a,u)!=dis(b,u)$，那么对$u$上面的边($i$)无论怎么修改，$a,b$向上的距离是同等增大的，$dis(a,fa)$一定不等于$dis(b,fa)$（类似于分配律）

我们为确保答案合法，一定要在$u$节点是保证$dis(u,a)=dis(u,b)$，即让它到子树中每个叶子节点距离相等，所以可以改变$j、k$变使他们对齐，**只需要都加成$u$到叶子节点距离的最大值即可**。

这样做一定能确保最终所有距离相等，且我们在**尽可能向上的边**（如果再往上就是$i$边，修改不能使答案合法）修改，类似于分配的思想，一定比在下面修改花费的代价更小。（因为在上面$+2$等效于对每条路径$+2$，所以在合法的情况下越往上越优）

在代码实现上，我们先要预处理每个节点到子树中的叶子结点的最大距离$maxx[u]$，方便后面对齐操作计算代价使用，在回溯的时候搞一下

然后再次$dfs$做树形$dp$统计答案即可(事实上可以放一块，但是我~~懒得写~~)

**记得开$long\ long$**
# $Code$
```
#include<cstdio>
#include<iostream>
#include<cstring>
#define re register
#define maxn 500010
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct Edge{
	int v,w,nxt;
}e[maxn<<2];
int to_l[maxn],tmp[maxn],cnt2,maxx[maxn];
int max_dis,x,y,z,root,head[maxn],cnt,n,dp[maxn];
inline void add(int u,int v,int w)
{
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs1(int u,int fa)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int ev=e[i].v;
		if(ev==fa) continue;
		dfs1(ev,u);
		maxx[u]=max(maxx[ev]+e[i].w,maxx[u]);
	}
}
void dfs2(int u,int fa)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int ev=e[i].v;
		if(ev==fa) continue;
		dfs2(ev,u);
		dp[u]+=(maxx[u]-(maxx[ev]+e[i].w));//计算对齐需要的花费 
		dp[u]+=dp[ev];//不要忘了把子树的答案传递上来 
	}
}
signed main()
{
	n=read();
	root=read();
	for(re int i=1;i<n;++i)
	{
		x=read(),y=read(),z=read();
		add(x,y,z),add(y,x,z);
	}
	dfs1(root,0);//预处理 
	dfs2(root,0);//DP  和上面的放一个函数里也行
	printf("%lld\n",dp[root]);
	return 0;
}

```

---

## 作者：eee_hoho (赞：3)

这题好像很水的样子QAQ

考虑树上dp，设$f_u$表示u的子树时态同步的最小代价，$dis_u$表示u的子树时态同步后的子树边权和

然后写出状态转移方程

$$\begin{cases}dis_u=max_{v\in son(u)}dis_v+dist(u,v)\\f_u=\sum_{v\in son(u)}f_v+dis_u-dis_v-dist(u,v)\end{cases}$$

$dist(u,v)$表示u到v的距离

因为边权只能加1，所以我们只能找最大的边来作为相同的边，也就是儿子的dis加上这条边取最大值

然后贡献的话首先要把所有儿子变相同的加起来，然后再把比dis小的边的贡献算上就可以了

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
const int N = 5e5;
using namespace std;
struct node
{
    int to,cost;
};
int n,s;
long long f[N + 5],dis[N + 5];
vector <node> d[N + 5];
void dfs(int u,int fa)
{
    vector <node>::iterator it;
    int maxx = 0;
    for (it = d[u].begin();it != d[u].end();it++)
    {
        int v = (*it).to,w = (*it).cost;
        if (v == fa)
            continue;
        maxx = max(maxx,w);
        dfs(v,u);
        f[u] += f[v];
        dis[u] = max(dis[v] + w,dis[u]);
    }
    for (it = d[u].begin();it != d[u].end();it++)
    {
        int v = (*it).to,w = (*it).cost;
        if (v == fa)
            continue;
        f[u] += dis[u] - dis[v] - w;
    }
}
int main()
{
    scanf("%d%d",&n,&s);
    int u,v,w;
    for (int i = 1;i < n;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        d[u].push_back((node){v,w});
        d[v].push_back((node){u,w});
    }
    dfs(s,0);
    cout<<f[s]<<endl;
    return 0;
}
```

---

## 作者：COUPDETAT (赞：2)

既然苏神说这是树型背包 那它就是吧
# 树型DP+分组背包
根据样例判断是一棵树 通过画图很容易得到只要求出最长链后 对每条链调整即可
调整的时候 从下往上调整即可
![](http://101.200.56.58/wp-content/uploads/2019/10/image-1.png)
向下找的时候进行修改 找完以每个节点以下的最长链 记录修改值并将最大值回溯上去
详细的看代码吧
# CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int wt[500100];
struct node
{
    int to,nex,w;
}e[500100];
int head[500100],N;
int n,m;
void add(int x,int y,int z)
{
    e[++N].to=y;
    e[N].w=z;
    e[N].nex=head[x];
    head[x]=N;
}
int ans,val[500100],dp[500100];
void dfs(int u,int fa)
{
	for(int i=head[u];i;i=e[i].nex)
	{
		int v=e[i].to;
		if(v!=fa)
		{
			dfs(v,u);
			dp[u]=max(dp[u],dp[v]+e[i].w);
		}	
    }
    for(int i=head[u];i;i=e[i].nex)
    {
		int v=e[i].to;
		if(v!=fa)
		ans+=dp[u]-(dp[v]+e[i].w);
	}
}
signed main()
{
    cin>>n;
    int rt;
    cin>>rt;
    for(int i=1;i<=n-1;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
		add(x,y,z);
		add(y,x,z); 
    }
    dfs(rt,rt);
    cout<<ans<<endl;
}
```


---

## 作者：Floatiy (赞：2)

树形DP吗？完全~~不会~~不知道为什么要用。
# 贪心

### 首先明确一个性质：
>要使得所有叶子的深度相同，那么对于任意一个点，每个子树的深度都必须相同。

### 证明：
>可以用反证法，如果有一个节点x，它的子树的深度各不相同，那这些子树的叶节点到x的距离一定不同。那么这些不同的距离分别加上x到root的距离也一定不同。  

>与题目要求不符，所以要满足题目要求，任意一个节点的子树深度必然相同。  

>证毕。

### 策略
既然我们要保证每个节点所有子树深度相同，我们可以贪心的处理每个点，把深度用道具强行补到相同。

在dfs的时候，把当前搜索的这个点的子树中最深的深度记为maxdeep。

之后ans += ∑(maxdeep - 这个点的其它子树的深度);

细节看代码吧

### Code
```
#include<iostream>
#include<cstdio>
#include<cctype>
#define int long long//不开LL会66分的
using namespace std;

const int MAXN = 500000 + 5;

struct Edge {
	int nxt;
	int to,w;
} l[MAXN<<1];

int n,root,ans;
int head[MAXN],cnt;
int maxdeep[MAXN];

inline int rd() {
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)) {f=(ch=='-')?-1:1;ch=getchar();}
	while(isdigit(ch)) {x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

inline void add(int x,int y,int z) {
	cnt++;
	l[cnt].nxt = head[x];
	l[cnt].to = y;
	l[cnt].w = z;
	head[x] = cnt;
	return;
}

void dfs(int x,int from) {
	int son = maxdeep[x];//提前记一下，因为下面更新要用到原来maxdeep[x]的值，所以用son来记最大的深度
	for(int i = head[x];i;i = l[i].nxt) {
		if(l[i].to == from) continue;
		maxdeep[l[i].to] = maxdeep[x] + l[i].w;
		dfs(l[i].to,x);
		son = max(son,maxdeep[l[i].to]);
	}
	maxdeep[x] = son;
	for(int i = head[x];i;i = l[i].nxt) {
		if(l[i].to == from) continue;
		ans += maxdeep[x] - maxdeep[l[i].to];
	}
	return;
}

signed main() {
	scanf("%lld%lld",&n,&root);
	int x,y,z;
	for(register int i = 1;i < n;i++) {
		x = rd(), y = rd(), z = rd();
		add(x,y,z), add(y,x,z);
	}
	dfs(root,-1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Dispwnl (赞：2)

这题看起来好像很难。。。

但读懂题却很简单（不要想的太复杂）

题意：从某个点开始，依次遍历点，直到无法前进，可以使某两个点之间的通过时间+1（雾），求使所有点都到达终点最少改变几次通过时间

一看就是树形dp（好吧我承认我看了标签）

因为改变的边越靠近源点，对以后的点就影响就越大

如果有多条路都经过一个点，必须强制使用时少的路+1直到与用时最长的路用时相等

所以用f储存到达i点用的最长时间

然后dfs一遍求出f

##f[x]=max(f[x],f[c[i].y]+c[i].dis);

再dfs一遍，这次就是正儿八经的求答案了

ans就是所有强制+1的次数

##ans+=f[x]-(f[c[i].y]+c[i].dis);

c[i].y到x的用时还要加上它们之间的距离

拆开
##ans+=f[x]-f[c[i].y]-c[i].dis;

输出ans就行了

PS：似乎要用long long，然而不知道是我太菜了还是codevs数据恶心，在codevs似乎要用高精度（瑟瑟发抖）

c++
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
using namespace std;
int n,s,num;
long long ans;
struct p{
    int x,y,dis;
}c[1000001];
int h[500001];
long long f[500001];
bool use[500001];
void add(int x,int y,int dis)
{
    c[++num].x=h[x];
    c[num].y=y;
    c[num].dis=dis;
    h[x]=num;
}
void dfs(int x)
{
    for(int i=h[x];i;i=c[i].x)
      if(!use[c[i].y])
      {
          use[c[i].y]=1;
          dfs(c[i].y);
        use[c[i].y]=0;
          f[x]=max(f[x],f[c[i].y]+c[i].dis);
      }
}
void dfs1(int x)
{
    for(int i=h[x];i;i=c[i].x)
      if(!use[c[i].y])
      {
          use[c[i].y]=1;
          dfs1(c[i].y);
          use[c[i].y]=0;
          ans+=f[x]-f[c[i].y]-c[i].dis;
      }
}
int main()
{
    cin>>n>>s;
    for(int i=1;i<n;i++)
      {
          int x,y,dis;
          cin>>x>>y>>dis;
          add(x,y,dis);
          add(y,x,dis);
      }
    use[s]=1;
    dfs(s);
    memset(use,0,sizeof(use));
    use[s]=1;
    dfs1(s);
    cout<<ans;
    return 0;
}
```

---

## 作者：Polaris_Dane (赞：1)

~~这真的是树形DP吗？？？~~

这道题只要想清楚就很简单了

首先对于一个节点，我们必须让他所有的子节点都时态同步

然后再来处理它本身

大体思路就出来了

先dfs处理子节点，记录最大到达时间

然后用工具补齐

然后向上传递答案处理即可

~~再次吐槽，这真的是树形DP？？？~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<stack> 
#define M 2000000
#define inf 0x3f3f3f3f
#define LL long long
using namespace std;
vector <LL> son[M];
vector <LL> val[M];
LL n,s,dis[M],maxx[M];
LL ans;
inline LL read(){
	LL x=0,f=1;char s=getchar();
	while (!isdigit(s)){
		if (s=='-') f=-1;
		s=getchar();
	}
	while (isdigit(s)){
		x=(x<<1)+(x<<3)+(s^48);
		s=getchar();
	}
	return x*f;
}
inline LL dfs(LL rt,LL fa){
	LL cnt=0,all=0;
	for (LL i=0;i<son[rt].size();i++){
		if (son[rt][i]==fa) continue;
		cnt+=dfs(son[rt][i],rt);
		maxx[rt]=max(maxx[rt],val[rt][i]+maxx[son[rt][i]]);
		all+=val[rt][i]+maxx[son[rt][i]];
	}
	return cnt+maxx[rt]*(son[rt].size()-1)-all;
}
signed main(void)
{
	n=read(),s=read();
	for (LL i=1;i<=n-1;i++){
		LL a=read(),b=read(),t=read();
		son[a].push_back(b);son[b].push_back(a);
		val[a].push_back(t);val[b].push_back(t);
	}
	son[s].push_back(0);
	printf("%lld",dfs(s,0));
	return 0;
}

```


---

## 作者：DQYdqy (赞：1)


## Solution:

题目描述十分冗长，实际上就是给你一棵树，问你最少增加多少次边权，使得所有叶子节点到根节点距离相等

有一个十分显然的结论：最后的距离为不增加边权的最大距离

则我们可设$f[x]$表示$x$节点与$fa[x]$相连的边需要加多少权值

易得状态转移：$f[x]=min\{ f[v]|v\in son_x \}$

最后对每个点统计答案：$ans+=f[x]-f[fa[x]]$

要开long long

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+1;
const int inf=21474836470000;
int n,rt,cnt,head[N];
int ans,maxdis,dis[N],f[N];
struct Edge{int nxt,to,val;}edge[N<<1];
void ins(int x,int y,int z){
	edge[++cnt].nxt=head[x];
	edge[cnt].to=y;head[x]=cnt;
	edge[cnt].val=z;
}
void getdis(int x,int fa){
	for(int i=head[x];i;i=edge[i].nxt){
		int y=edge[i].to;
		if(y==fa) continue;
		dis[y]=dis[x]+edge[i].val;
		getdis(y,x);maxdis=max(maxdis,dis[y]);
	}
}
void dfs(int x,int fa){
	f[x]=inf;int flag=0;
	for(int i=head[x];i;i=edge[i].nxt){
		int y=edge[i].to;
		if(y==fa) continue;
		dfs(y,x);f[x]=min(f[x],f[y]);
		flag=1;
	}
	if(!flag) f[x]=maxdis-dis[x];
}
void calc(int x,int fa){
	ans+=f[x]-f[fa];
	for(int i=head[x];i;i=edge[i].nxt){
		int y=edge[i].to;
		if(y==fa) continue;
		calc(y,x);	
	}
}
int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
signed main(){
	n=read(),rt=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read(),z=read();
		ins(x,y,z),ins(y,x,z);
	}getdis(rt,0);
	dfs(rt,0);calc(rt,0);
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：wzh1120 (赞：1)

其实我很想知道运行时间前几名的是怎么做的。。。

比如一个结点有若干儿子，儿子可以递归为子问题。。。

设f[x]表示叶节点到x的最大时间

则f[x]=f[son]+edge.v

答案即 sigma f[x]-f[son]-edge.v


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<set>
#include<ctime>
#include<queue>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
ll ans;
int n,root,cnt;
int f[500005],last[500005];
struct edge{int to,next,v;}e[1000005];
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void insert(int u,int v,int w)
{
    e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;e[cnt].v=w;
    e[++cnt].to=u;e[cnt].next=last[v];last[v]=cnt;e[cnt].v=w;
}
void dfs(int x,int fa)
{
    for(int i=last[x];i;i=e[i].next)
        if(e[i].to!=fa)
        {
            dfs(e[i].to,x);
            f[x]=max(f[x],f[e[i].to]+e[i].v);
        }
    for(int i=last[x];i;i=e[i].next)
        if(e[i].to!=fa)ans+=f[x]-f[e[i].to]-e[i].v;
}
int main()
{
    n=read();root=read();
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read(),w=read();
        insert(u,v,w);
    }
    dfs(root,0);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：RoRoyyy (赞：0)

## 贪心+动规
贪心：

从子节点向上合并， 一颗子树的子节点到$lca$的距离必定相等， 如果不相等， 那么则不存在合法的解。

证明： 每个点的入度为一， 显然如果到达$lca$都不相等了， 由于再向上只存在一条路径到达根节点， 那么再向上修改的时候会连着两条路径一起修改， 同加的话原来不相等， 加之后也不可能相等。

$dp$:

所以从下到上考虑每颗子树计算以该节点为根的子树的最小花费， 因为在此之前， 该节点的子节点已经计算完毕而且一定取的是子节点到达叶子结点的最大路径， 所以计算该节点的时候只需要用计算过的子节点的最大路径加上到子节点的边权与该节点到叶节点的最长路径比较就行了。

然后注意该节点需要与子节点合并， 在$dp$的时候只需要加上子节点的答案就行了。在此之前每个节点到叶子结点的最长路径可以一次树形$dp$预处理出来。

总复杂度$O(n)$

```cpp
//RoRoyyy
#include <cstdio>
#include <iostream>

using namespace std;
typedef long long ll;
const int N = 5e5 + 5;
int u[N], v[N], w[N], first[N], nxt[N], tot;
ll dp[N];
ll maxpath[N];
int n, rt;
void add(int x, int y, int z) {
    u[++tot] = x, v[tot] = y, w[tot] = z;
    nxt[tot] = first[x];
    first[x] = tot; 
}
void dfs1(int u, int fa) {
    for(int i = first[u]; i; i = nxt[i]) {
        int to = v[i];
        if(to == fa) continue;
        dfs1(to, u);
        maxpath[u] = max(maxpath[u], maxpath[to] + w[i]);
    }
}
void DP(int u, int fa) {
    for(int i = first[u]; i; i = nxt[i]) {
        int to = v[i];
        if(to == fa) continue;
        DP(to, u);
        dp[u] += maxpath[u] - (maxpath[to] + w[i]);
        dp[u] += dp[to];
    }
}
int main() {
    scanf("%d%d", &n, &rt);
    for(int i = 1; i < n; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }
    dfs1(rt, rt);
    DP(rt, rt);
    printf("%lld\n", dp[rt]);
    return 0;
}
```


---

## 作者：cscy (赞：0)

首先这完全是一道白给题，本人使用了归纳法

那么说一下思路

首先定义深度：根节点到叶节点的路径长。

随便画一棵树，观察最深度最深的叶节点，发现好像对于这条路径上的边都不需要修改，因为我们的目标是让其他叶节点深度与它一样，而修改最深叶子节点感觉上不会比不修改结果更优，所以先不动它。

对于比较浅的叶节点，我们需要修改它到根节点的某些边，让它的深度更深。那么改越接近根节点的边越好。因为对于这一个叶节点来说，修改任意一条边或者多条边效果等价；但是对于其他叶节点，如果本次修改顺便修改了它到根节点的路径，那么对于答案的贡献会比分别修改两个叶节点的路径少。

说白了就是如果有一个节点，它有两个子树，那么修改这一个节点上方的边效果等价于修改两个子树的叶节点的深度（使叶节点的深度加大到最大深度），且答案必然比分别改两个子树上的边要好。

所以这时候对于每个节点node定义一个量f(node)，表示这个节点的子树的叶节点的深度与整个树的最大深度的差值的最小值。显然这玩意可以继承。

即
f(node) = min(f(node), f(son(node)));

为什要这个量？
答：归纳法。你画一颗树就明白了，真的。

好吧原因是这个量就是刚刚说的对于一个节点上方修改的最大值。
因为如果超过这个值，对节点上方的边加上后，就会有一些叶节点深度超过最大值，这显然不是我们想要的。

所以既然可以修改了，那么要不要继续传递这个f(node)呢？
答：要。因为修改越靠近根节点越优。

具体什么时候修改呢？
答：不能继承了就修改

这时候假如节点node有两个子节点son1， son2

f(son1) = 3
f(son2) = 5

那么此时f(node) = 3

这里只继承了3，表示未来可能在上面的某条边加3。但观察son2，如果上面加了3，显然不能满足它的需求，因为它需要整体加5才能让深度达到最大深度。

那咋办？

答：在node节点与父节点的连边加2。
为什么这么做？画个图，一目了然。

好了所以我又定义了一个量s，表示一个节点到它父节点的连边所需要的增加的值。

dfs计算s，然后累加每一个节点的s

完事。

唯一注意根节点的s没有意义，因为根节点没有父节点，所以根节点单独处理。

---

## 作者：eros1on (赞：0)

~~[博客](https://tle666.github.io/2019/03/15/[ZJOI2009]%20%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/)
食用更佳~~

# **Description**

一棵有$N$个结点，带边权的有根树，求至少需要增加多少边权才能使根结点到叶子结点的所有路径的权值和相同。

对于$100\%$的数据，$N \leq 500000$，边权$t_e \leq 1000000$。

[题目连接戳这里](<https://www.luogu.org/problemnew/show/P1131>)

# Solution

树形$DP$的板子题。

令$dp_x$为叶子结点到$x$结点的最大时间。

则有 $dp_x = \max (dp_{son[x]} + dis_{x,\ son[x]})$

因此 $ans = \sum (dp_x - dp_{son[x]} - dis_{x,\ son[x]})$

# **Code**

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
#define MAXN 500500
#define int long long
int n, root, dp[MAXN], ans, fa[MAXN];
bool vis[MAXN];
struct edge {
    int v, w;
    edge *next;
} pool[MAXN << 1], *h[MAXN], *cnt = pool;
inline void addedge(int u, int v, int w) {
    edge *p = ++cnt, *q = ++cnt;
    p->v = v, p->w = w, p->next = h[u], h[u] = p;
    q->v = u, q->w = w, q->next = h[v], h[v] = q;
}
inline void dfs(int u) {
    int v; vis[u] = true;
    for(edge *p = h[u]; p; p = p->next)
        if(!vis[v = p->v]) {
            fa[v] = u, dfs(v);
            dp[u] = max(dp[u], dp[v] + p->w);
        }
    for(edge *p = h[u]; p; p = p->next)
        if((v = p->v) != fa[u])
            ans += (dp[u] - dp[v] - p->w);
}
signed main() {
    int u, v, w;
    scanf("%lld%lld", &n, &root);
    for(int i = 1; i < n; i++) {
        scanf("%lld%lld%lld", &u, &v, &w);
        addedge(u, v, w);
    } dfs(root);
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：Celebrate (赞：0)

这一道题看难度是蓝题，但我感觉没有这么难

看完这题，我马上就想到了贪心

建好边以后把整棵树初始化一下，找出叶子节点，并算出路径长度

然后就是这个代码的核心了（先讲思路再讲代码）

先从叶子节点的上一层开始，把自己的儿子们（即叶子节点）变为同一个值，也就是变为其中的最大值

并把这个最大值付给这个点，同时这个点和它的子树变成一个叶子节点（原因是它们的时间已经变得一样，让它们的时间+1只需要把通往这个点的边的时间+1）

然后继续迭代，直到把这个树变成一个点为只

这样可以把资源利用的最好，时间是O（N )

参考代码 （可以加很多优化）

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
 
using namespace std ;
 
inline int read() {
	int x = 0 ; char s = getchar() ;
	while ( !isdigit ( s ) ) s = getchar() ;
	while (  isdigit ( s ) ) x = (x<<1)+(x<<3)+s-48 , s = getchar() ;
	return x ;
}
 
typedef long long LL ;
 
const int N = 5e5 + 10 ;
 
int n , S ;
struct edge {
	int v , w , nxt ;
}e[N<<1] ; int tot , last[N] ; 
inline void add ( int u , int v , int w ) {
	e[++tot] = (edge){ v , w , last[u] } ;
	last[u] = tot ;
	e[++tot] = (edge){ u , w , last[v] } ;
	last[v] = tot ;
}
 
LL val[N] , ans = 0 ; bool mark[N] ;
 
void init ( int u , int fa , LL s ) {
	bool bk = 0 ; mark[u] = 0 ;
	for ( int i = last[u] ; i != -1 ; i = e[i].nxt ) {
		int v = e[i].v ; if ( v == fa ) continue ;
		init ( v , u , s + LL(e[i].w) ) ; bk = 1 ;
 	}
	if ( bk == 0 ) val[u] = s , mark[u] = 1 ;
}
 
LL dp[N] ;
LL dfs ( int u , int fa ) {
	if ( mark[u] == 1 ) return val[u] ;
	if ( dp[u] != -1 ) return dp[u] ;
	LL maxx = 0 ;
	for ( int i = last[u] ; i != -1 ; i = e[i].nxt ) {
		int v = e[i].v ; if ( v == fa ) continue ;
		maxx = max ( maxx , dfs ( v , u ) ) ;
	}
	LL t ;
	for ( int i = last[u] ; i != -1 ; i = e[i].nxt ) {
		int v = e[i].v ; if ( v == fa ) continue ;
		ans = ans + ( t = maxx - dfs ( v , u ) ) ;
	}
	return dp[u] = maxx ;
}
 
int main() {
	cin >> n >> S ; int u , v , w ;
	memset ( last , -1 , sizeof (last )) , tot = -1 ;
	for ( int i = 1 ; i < n ; i ++ ) {
		u = read() , v = read() , w = read() ;
		add ( u , v , w ) ;
	}
	memset ( dp , -1 , sizeof ( dp )) ;
	init ( S , 0 , 0 ) ; 
	LL t = dfs ( S , 0 ) ;
	cout << ans ; return 0 ;
}

```

---

## 作者：meisr (赞：0)

首先这是一棵树……不会有人看不出来吧……

个人觉得LYang的题解虽然很详细，但是个人还想再多说一句（可能我太菜了看不懂大佬的题解吧） 为什么我们可以在递归的时候直接把叶子节点补全？因为我们在更新根节点时，下面所有的都会随之更新，这时我们就可以把一颗子树的状态记录在根节点————也就是说，我们必须且只需要使每一个根节点的激励电流到子节点的时间都相同即可。

下面是代码，记住不要忘开long long
```
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=500001;
int n,s,cnt,head[500001],val[500001];
long long ans;
struct edge{
	int to,dis,next;
}e[N<<1];
inline int read(){
	int a=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') a=a*10+ch-'0',ch=getchar();
	return a;
}
inline void add(int x,int y,int dis){
	e[++cnt].to=y;
	e[cnt].next=head[x];
	e[cnt].dis=dis;
	head[x]=cnt;
	return;
}
void dfs(int now,int fa){
	int maxn=0;
	for(int i=head[now];i;i=e[i].next){
		int v=e[i].to,dis=e[i].dis;
		if(fa==v) continue;
		dfs(v,now);
		maxn=max(maxn,val[v]+dis);
	}
	for(int i=head[now];i;i=e[i].next){
		int v=e[i].to,dis=e[i].dis;
		if(fa==v) continue;
		if(maxn>val[v]) ans+=maxn-val[v];
	}
	val[now]=maxn;
	return;
}
int main(){
	n=read(),s=read();
	for(int i=1,x,y,z;i<n;i++){
		x=read(),y=read(),z=read();
		add(x,y,z),add(y,x,z);
	}
	dfs(s,0);
	printf("%lld",ans);
	return 0;
}
```
c++大法好

---

## 作者：leozhang (赞：0)

这题其实有点骗人...

通过观察很容易发现：考虑某一些叶节点的LCA，由于根节点到这个LCA的距离唯一，故要求这些叶节点到这一LCA的距离都相等

于是我们仅需dfs，找到次底层的节点，然后使这些节点的子节点到这些节点的距离都相等即可

再向上回溯，算法完全相同，仅需把下面的距离累计到该节点向上的边即可

用图理解一下：

（图挂了，看我csdn吧：https://blog.csdn.net/lleozhang/article/details/82889647）

贴代码：

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
struct Edge
{
	int next;
	int to;
	int val;
}edge[1000005];
int head[500005];
int dis[500005];
int cnt=1;
int f[500005];
void add(int l,int r,int w)
{
	edge[cnt].to=r;
	edge[cnt].next=head[l];
	edge[cnt].val=w;
	head[l]=cnt++;
}
void dfs(int x,int fx)//O(n)
{
	f[x]=fx;
	for(int i=head[x];i!=-1;i=edge[i].next)
	{
		int to=edge[i].to;
		if(to==fx)
		{
			continue;
		}
		dfs(to,x);
	}
}
ll tot=0;
void dfs2(int rt,int frt)//O(n*log2n)
{
	for(int i=head[rt];i!=-1;i=edge[i].next)//O(n*log2n)
	{
		int to=edge[i].to;
		if(to==frt)
		{
			continue;
		}
		dfs2(to,rt);
	}
	priority_queue <int> M;
	for(int i=head[rt];i!=-1;i=edge[i].next)//O(log2n)
	{
		int to=edge[i].to;
		if(to==frt)
		{
			continue;
		}
		M.push(edge[i].val);
	}
	if(!M.empty())
	{
		int l=M.top();
		M.pop();
		while(!M.empty())//O(n*log2n)
		{
			int l1=M.top();
			M.pop();
			tot+=(ll)l-l1;
		}
		for(int i=head[frt];i!=-1;i=edge[i].next)
		{
			int to=edge[i].to;
			if(to==rt)
			{
				edge[i].val+=l;
				break;
			}
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	int n;
	scanf("%d",&n);
	int rt;
	scanf("%d",&rt);
	for(int i=1;i<n;i++)
	{
		int x,y,v;
		scanf("%d%d%d",&x,&y,&v);
		add(x,y,v);
		add(y,x,v);
	}
	dfs(rt,rt);
	dfs2(rt,rt);
	printf("%lld\n",tot);
	return 0;
}
```

---

## 作者：YitsuHolo (赞：0)

这道题虽然是可以用dfs解决，但是用到了动态规划的思想：

1. 无后效性

2. 最优子结构

而dfs处理的就是最优子结构，因为每个叶子节点需要同时到达，所以任意两个叶子节点的公共祖先到这两个子节点的时间相等，有了这个思想，我们再将目光放到两个父亲节点相同的子节点上，这个关系依然成立，那么我们将这平衡时间就是用时最长的时间，需要用的道具次数就是这个时间减去各个儿子的用时总和

另外，此题还有两个坑点（如果你没有认真理解题意）：

- 数据并没有说明前一个点是后一个点的父亲

- 结果过大，需要long long储存



```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node
{
	int next,to;
	int time;	//记录当前线路的时间延迟 
	long long maxtime;	//最大时间延迟，即到根节点的延迟 
};
int head[500010];	//链表储存 
node edge[1000010];
bool vis[500010];	//记录到过的点，主要是记录祖先 
int n,k,s;
long long cnt;

void add(int come,int to,int cost)
{
	k++;
	edge[k].to=to;
	edge[k].time=cost;
	edge[k].next=head[come];
	head[come]=k;
}
int dfs(int id)
{
	vis[id]=1;	//只是当前点下次不可以走，对于走过的子节点需要取消标记，原因在第二个for循环的统计时体现
	long long maxn=0;
	if(head[id]==0)
	return 0;
	for(int i=head[id];i!=0;i=edge[i].next)
	{
		int v=edge[i].to;
		if(vis[v]==false)
		{
			edge[i].maxtime=edge[i].time+dfs(v);
			maxn=max(maxn,edge[i].maxtime);
		}
	}
	for(int i=head[id];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(vis[v]==false)
		cnt+=(maxn-edge[i].maxtime);
	}
	vis[id]=0;
	return maxn;
}

int main()
{
	scanf("%d%d",&n,&s);
	for(int i=1;i<n;i++)
	{
		int x,y,w;
		scanf("%d%d%d",&x,&y,&w);
		add(x,y,w),add(y,x,w);
	}
	dfs(s);
	printf("%lld",cnt);
	return 0;
}
```

---

## 作者：ww3113306 (赞：0)

不是很懂为什么是树形DP，感觉我想的就是一个贪心啊。。。

以下为贪心感性（非理性）理解：

假设将所有时态贪心的调整是对的，

那么如果一个节点的各个儿子时态不同，那么强行统一，

为什么可以假设是对的？

因为观察到在一个点的上方+1，对它的子树的相对关系的没有影响的，

因此子树里面的时态同步只能在内部做，所以一步一步统一上来,

而且由于如果是要改变两个子树之间的大小关系的话，

因为是整个子树的修改，同时不影响到其他子树，因此这个时候就是在一个点的上方+1了，

同时因为每次只考虑子树内部的关系，所以整个子树的修改会被延后到上一个节点，

这时两个子树之间的修改就变成了子树内部的修改，因此递归上去即可

```cpp
#include<bits/stdc++.h>
using namespace std;
/*假设将所有时态贪心的调整是对的，
那么如果一个节点的各个儿子时态不同，那么强行统一，
为什么可以假设是对的？
因为观察到在一个点的上方+1，对它的子树的相对关系的没有影响的，
因此子树里面的时态同步只能在内部做，所以一步一步统一上来,
而且由于如果是要改变两个子树之间的大小关系的话，
因为是整个子树的修改，同时不影响到其他子树，因此这个时候就是在一个点的上方+1了，
同时因为每次只考虑子树内部的关系，所以整个子树的修改会被延后到上一个节点，
这时两个子树之间的修改就变成了子树内部的修改*/
#define R register int
#define AC 1001000
#define D printf("line in %d\n",__LINE__);
#define LL long long
int n,root;
int date[AC],Next[AC],Head[AC],value[AC],tot;
LL ans,have;
LL f[AC];//f[i]代表节点i的子树内的时态已经被统一为了f[i]
bool z[AC],vis[AC];
inline int read()
{
	int x=0;char c=getchar();
	while(c > '9' || c < '0') c=getchar();
	while(c >= '0' && c <= '9') x=x*10+c-'0',c=getchar();
	return x;
}

inline void add(int f,int w,int S)
{
	date[++tot]=w,Next[tot]=Head[f],value[tot]=S,Head[f]=tot;
	date[++tot]=f,Next[tot]=Head[w],value[tot]=S,Head[w]=tot;
}

inline void pre()
{
	R a,b,c;
	n=read(),root=read();
	for(R i=1;i<n;i++)
	{
		a=read(),b=read(),c=read();
		add(a,b,c);
	}
}

void DFS(int x)//先统计一下
{
	vis[x]=true;
	R now;
	bool done=false;
	for(R i=Head[x]; i ;i=Next[i])
	{
		now=date[i];
		if(vis[now]) continue;
		if(!done) done=true;
		have+=value[i];
		DFS(now);
		have-=value[i];
	}
	if(!done) f[x]=have;
}

void DP(int x)
{
	z[x]=true;
	R now,cnt=0;
	for(R i=Head[x]; i ;i=Next[i])
	{
		now=date[i];
		if(z[now]) continue;
		DP(now);
		if(!f[x]) f[x]=f[now];
		else if(f[now] != f[x])
		{
			if(f[now] < f[x]) ans+=f[x] - f[now];
			else ans+=(f[now] - f[x]) * cnt,f[x]=f[now];
		}//error!!!因为f[now]只代表新遍历到的子树，而f[x]则可能代表很多个子树
		++cnt;
	}//error!!!于是如果统计让很多个子树暴力修改上来的代价，因为要修改很多边，因此要*cnt(f[x]中的子树个数)		
}

int main()
{
	freopen("in.in","r",stdin);
	pre();
	DFS(root);
	DP(root);
	printf("%lld\n",ans);
	fclose(stdin);
	return 0;
}
```

---

## 作者：zubizakeli (赞：0)

看标签是个树形dp，然而想了半天连状态是什么都没想出来（~~好像暴露了蒟蒻本质~~）...于是就怒写一发贪心,竟然A掉了qwq

首先肯定要算出最远的距离激发器的叶子节点距离sdd，然后对于其他叶子节点，显然要增加sdd-dix[x]。这些增加的距离显然是越往上越划算的（因为越往上受益的叶子节点越多嘛）。

而对于一个非叶子节点，假如他有两个儿子，一个要增加2，一个要增加3，那么该节点到根的路径上最多只能增加2（因为不然的话就要有子节点超增了），那么那个要增加3的节点就要增加1，然后该节点到根节点的路径上增加2，两个儿子就都符合条件了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<bitset>
#define LL long long
using namespace std;
const LL INF = 0x7ffffffffffff ;
const int N = 500000 + 10 ;

inline LL read() {
	LL k = 0 , f = 1 ; char c = getchar() ;
	for( ; !isdigit(c) ; c = getchar())
	  if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar())
	  k = k*10 + c-'0' ;
	return k*f ;
}
struct Edge {
	int to, next ; LL val ;
}e[N<<1] ;
int n, s, m ; LL ans = 0, sdd ; int head[N] ; LL dis[N] ;
inline void add_edge(int x,int y,LL vv) {  // 双向边 
	static int cnt = 0 ;
	e[++cnt].to = y, e[cnt].next = head[x], head[x] = cnt, e[cnt].val = vv ;
	e[++cnt].to = x, e[cnt].next = head[y], head[y] = cnt, e[cnt].val = vv ;
}

inline void bfs() {
	bitset<N>vis ; for(int i=1;i<=n;i++) dis[i] = INF ;	
	queue<LL>q ; q.push(s) ; vis[s] = 1, dis[s] = 0 ;
	while(!q.empty()) {
		int x = q.front() ; q.pop() ;
		for(int i=head[x];i;i=e[i].next) {
			int y = e[i].to ; if(vis[y]) continue ;
			dis[y] = dis[x]+e[i].val ; vis[y] = 1 ;
			q.push(y) ;
		}
	}
}
LL dfs(int x,int fa) {
	LL minn = INF, maxx = 0, tot = 0, num = 0 ;
	for(int i=head[x];i;i=e[i].next) {
		int y = e[i].to ; if(y == fa) continue ;
		LL res = dfs(y,x) ; num++ ;
		tot += res, minn = min(res,minn) ;
	}
	if(!num) return sdd-dis[x] ;  // 叶子节点 
	if(x == s) return tot ;
	ans += tot - num*minn ;
	return minn ;
}

int main() {
	n = read() ; s = read() ;
	for(int i=1;i<n;i++) {
		int x = read(), y = read() ;
		add_edge(x,y,read()) ; 
	}
	bfs() ; sdd = 0 ;
	for(int i=1;i<=n;i++) sdd = max(sdd,dis[i]) ;
	LL res = dfs(s,0) ; ans += res ;
	printf("%lld",ans) ;
	return 0 ;
}
```

---

## 作者：Colitas (赞：0)

妥妥的贪心。。。
可以很显然地发现，如果一条边越靠近根，延长后的结果越优，因为一条边越靠近根能影响的叶子节点就越多；
还可以很显然地发现，对于距离根节点最远的叶子，延长他到根的距离是没有意义的；
于是对每个节点，预处理以下信息：
	dist[i]表示i到根的距离；
	mx[i]表示以i为根的子树中，dist的最大值；
处理之后dfs，对于以i为根的子树，找出maxdist=max{mx[j] | j是i的儿子}，则对mx[j]<maxdist的节点，边<i,j>要延长maxdist-mx[j]，直接算即可；
下面是代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn=1e6+5;
struct edge
{
	int to,next,w;
}e[maxn<<1];
int first[maxn],np;
long long dist[maxn],mx[maxn];
int n,s;
void initial()
{
	memset(first,0,sizeof(first));
	memset(dist,0,sizeof(dist));
	memset(mx,0,sizeof(mx));
	np=0;
}
void addedge(int u,int v,int w)
{
	e[++np]=(edge){v,first[u],w},first[u]=np;
}
void DFS(int i,int f)
{
	mx[i]=dist[i];
	for(int p=first[i];p;p=e[p].next)
	{
		int j=e[p].to,c=e[p].w;
		if(j==f) continue;
		dist[j]=dist[i]+c;
		DFS(j,i);
		mx[i]=max(mx[i],mx[j]);
	}
}
long long calc(int i,int f)
{
	long long ret=0,maxdist=0;
	for(int p=first[i];p;p=e[p].next)
	{
		int j=e[p].to;
		if(j==f) continue;
		maxdist=max(maxdist,mx[j]);
	}
	for(int p=first[i];p;p=e[p].next)
	{
		int j=e[p].to;
		if(j==f) continue;
		ret+=maxdist-mx[j]+calc(j,i);
	}
	return ret;
}
int main()
{
	initial();
	scanf("%d%d",&n,&s);
	int u,v,w;
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		addedge(u,v,w);
		addedge(v,u,w);
	}
	DFS(s,0);
	cout<<calc(s,0)<<endl;
	return 0;
}
```

---

## 作者：01407s (赞：0)

思路：本来以为是个图论。。。就写了个最短路找最长边。。。后来发现其实越靠近根节点的加时其实是越有利的（如果从这里往下都要加时的话），得出结论：这是个树形DP。状态：f[i]表示以i为根的子树的时间的最大值。转移f[i]=max{f[i],f[v]+e[i].val}（当i与v有一条边时）dfs即可求出最大值。再跑一遍dfs求解答案，方程为ans+=f[x]-f[v]-e[i].val。（至于我本人没法语言特别清楚的解释明白这个方程。。大意就是对于每个点枚举与它相连且不是他祖先的点，要延长的时间就是他这里的最大值减去与他相连的最大值和传送时间，这个差值有可能是负数）。

代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=500010;
struct edge {
    int next,to,val;
};
edge e[2*MAXN];
int head[MAXN],cnt;
void addedge(int u,int v,int w) {
    e[++cnt].next=head[u];
    e[cnt].to=v;
    e[cnt].val=w;
    head[u]=cnt;
}
int f[MAXN],n;
long long ans;
bool visit[MAXN];
void dfs1(int x) {
    visit[x]=true;
    for (int i=head[x]; i; i=e[i].next) {
        int v=e[i].to;
        if (!visit[v]) {
            dfs1(v);
            f[x]=max(f[x],f[v]+e[i].val);
        }
    }
}
void dfs2(int x) {
    visit[x]=true;
    for (int i=head[x]; i; i=e[i].next) {
        int v=e[i].to;
        if (!visit[v]) {
            dfs2(v);
            ans+=f[x]-f[v]-e[i].val;
        }
    }
}
int main() {
    int s;
    scanf("%d",&n);
    scanf("%d",&s);
    for (int i=1; i<n; i++) {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        addedge(u,v,w);
        addedge(v,u,w);
    }
    dfs1(s);
    memset(visit,0,sizeof(visit));
    dfs2(s);
    cout<<ans;
    return 0;
}
```

---

## 作者：Log_x (赞：0)

**【解题思路】**

很显然，假设电路板的激发器为根节点，那么对于题目中的树（电路板），我们显然要尽量在深度较小的边上将通过时间增加一些单位，因为这样只要增加这一条边的通过时间，通过这条边所能到达的所有终止节点（叶子节点）都能减少相应的通过时间。

然后我们考虑怎样计算增加的通过时间，记$dis[x]$表示从节点$x$到达终止节点所需最长的通过时间，则转移为$dis[x]=Max{dis[x],dis[y]+cst[x][y]}$（$y$为$x$的子节点，$cst[x][y]$表示通过边$x$->$y$所需的时间），可用$DFS$计算。

通过$DFS$计算完所有$dis[x]$后，如果存在$dis[x]>dis[y]+cst[x][y]$，则我们必须在边$x$->$y$上增加$(dis[x]-dis[y]-cst[x][y])$单位的时间，因为我们如果在深度比边$x$->$y$小的边上增加时间，则通过节点$x$到达所有终止节点都要增加相同的时间，这样无论增加多少时间，这些终止节点永远无法达到时态同步。

这里再提供一种将$DFS$变为$BFS$的写法，记队列$Q$，$Q[i][0]$表示当前遍历到的节点，$Q[i][1]$表示$Q[i][0]$的父节点，$Q[i][2]$表示通过边$Q[i][1]$->$Q[i][2]$所需的时间。

然后我们将树按$BFS$序遍历完一遍后，将队列中入队过的所有元素逆序取出来更新$dis[x]$的值（即$dis[Q[i][1]]=Max{dis[Q[i][1]],dis[Q[i][0]]+Q[i][2]}$）并计算答案。因为在$BFS$中每扩展一次节点表示在树中的遍历深度加一，也就是说我们最后是按照深度从大到小来更新的，实际上模拟的就是$DFS$的回溯。

**【代码】**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
typedef long long ll;
const int Maxn = 0x3f3f3f3f;
const int N = 5e5 + 5;
ll dis[N], Ans; int n, src, Q[N][3];

struct Edge
{
    int to; ll tim; Edge *nxt;
}a[N << 1], *T = a, *lst[N];

template <class T> inline void CkMax(T &a, const T &b) {if (a < b) a = b;}

inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(ll x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline void addEdge(const int &x, const int &y, const int &z)
{
    T->nxt = lst[x]; T->to = y; T->tim = (ll)z; lst[x] = T++;
    T->nxt = lst[y]; T->to = x; T->tim = (ll)z; lst[y] = T++;  
}

int main()
{
    n = get(); src = get(); int x, v, y;
    for (int i = 1; i < n; ++i)
     x = get(), y = get(), addEdge(x, y, get());
    int t = 0, w = 1; Q[1][0] = src;
    while (t < w)
    {
        x = Q[++t][0]; v = Q[t][1];
        for (Edge *e = lst[x]; e; e = e->nxt)
        {
            if ((y = e->to) == v) continue;
            Q[++w][0] = y; Q[w][1] = x; Q[w][2] = e->tim; 
        }
    }
    for (int i = w; i >= 2; --i)
     CkMax(dis[Q[i][1]], dis[Q[i][0]] + Q[i][2]);
    for (int i = w; i >= 2; --i)
     Ans += dis[Q[i][1]] - dis[Q[i][0]] - Q[i][2];
    return put(Ans), 0;
}
```

---

## 作者：wawcac (赞：0)


[广告以及吐槽以及rank1 15ms的原因](http://www.cnblogs.com/wawcac-blog/p/6943113.html)

解题思路

进行一波dfs，用f[i]记录第i个节点到达最远叶子节点的用时(用时最长的叶子节点).

从每个儿子v回溯回来时，如果从v下去到达最远叶子节点用时更长，那就更新f[u]，f[u]=max(f[u],f[v]+e[i].w)，e[i].w是从u到v的用时。

这样的话遍历完u的所有儿子，答案就增加sigma( f[u]-f[e[i].to]-f[e[i].w )。

大概就是从叶子开始一层层地把兄弟节点统一了，再向上统一这个节点总共要加多少时间，一层层向父亲汇总，回到根节点就得到了答案

源代码




```cpp
#include<stdio.h>
inline int max(int a,int b)
{
    return a>b?a:b;
}
inline int read()
{
    int x=0;
    char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
int n,root;
struct edge{
    int next,to;
    int w;
}e[1000010];
int head[500010]={0},cnt=1;
inline void add(int u,int v,int w)
{
    e[cnt].next=head[u];
    e[cnt].to=v;
    e[cnt].w=w;
    head[u]=cnt++;
}
long long f[500010]={0},ans=0;
void dfs(int u,int fa)
{
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa) continue;
        dfs(v,u);
        f[u]=max(f[u],f[v]+e[i].w);
    }
    for(int i=head[u];i;i=e[i].next)
        if(fa!=e[i].to)
            ans+=f[u]-f[e[i].to]-e[i].w;
}
int main()
{
    n=read();root=read();
    for(register int i=1,u,v,w;i<n;i++)
        u=read(),v=read(),w=read(),add(u,v,w),add(v,u,w);
    dfs(root,0);
    printf("%lld",ans);
    return 0;
}
```

---


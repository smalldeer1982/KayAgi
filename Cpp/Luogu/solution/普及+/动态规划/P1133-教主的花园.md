# 教主的花园

## 题目描述

教主有着一个环形的花园，他想在花园周围均匀地种上 $n$ 棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。

教主最喜欢 $3$ 种树，这 $3$ 种树的高度分别为 $10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。

## 说明/提示

【样例说明】。

第 $1$ 至 $n$ 个位置分别种上高度为 $20,10,30,10$ 的树，价值最高。

【数据规模与约定】。

- 对于 $20\%$ 的数据，有 $n\le 10$；
- 对于 $40\%$ 的数据，有 $n\le 100$； 
- 对于 $60\%$ 的数据，有 $n\le 1000$；
- 对于 $100\%$ 的数据，有 $4\le n\le 10^5$，并保证 $n$ 一定为偶数。

## 样例 #1

### 输入

```
4 
1 3 2 
3 1 2 
3 1 2 
3 1 2
```

### 输出

```
11```

# 题解

## 作者：juruo_zjc (赞：67)

# 像我这样的蒟蒻往这儿看！
看了其他大佬的题解，蒟蒻我吓得瑟瑟发抖，因为我kan bu dong，于是，做完后我决定写一篇平民化的题解

我为什么会做这道题？

答案就是，这道题是DP题

我为什么对DP情有独钟？

因为NOIP考试时在第三题上爆炸了呗！

看了其他大佬的题解，蒟蒻我吓得瑟瑟发抖，因为我kan bu dong，于是，做完后我决定写一篇平民化的题解

------------
好了，不多说了，直切~~猪蹄~~（主题）

定义dp[i][j][k]为在第i个位置，种第j种树（明显j有三种，这里定义j=0为高度为10的树，j=1为高度为20的树，j=2为高度为30的树）比左右的树高/低，（k=0表示比左右的树低，k=1则表示比左右的高）

什么叫比左右都高？大家都知道吧？什么？你不知道？
                    
![无](https://cdn.luogu.com.cn/upload/pic/48584.png)

上图中，中间那根比左右都高，反过来就是左右的比它都低。


------------
然后决策吧！

对于每个位置，它可以种三种树。

如果是种高度为10的树

就只有dp[i][0][0]的情况，为什么？因为它是最矮的树，没有树比它更矮，所以只可能比左右都矮。那么dp[i][0][0]怎么由上一个状态转移过来呢？

dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];

考虑它的上一个位置，dp[i-1]，它可以种高度为20的树或高度为30的树，绝对不可能种高度为10的树，因为状态中，第i位置的树是比左右都低的，因为k=0。想想看，第i个位置比左右低，是不是意味着左右位置都比第i位置高？于是就与dp[i-1][1][1]和dp[i-1][2][1]作决策，取最大值，加上本位置的观赏价值。

如果是种高度为20的树呢？

它有dp[i][1][0]和dp[i][1][1]两种情况，它既可以比左右都高，也可以比左右都低。状态转移如下：

dp[i][1][1]=dp[i-1][0][0]+a[i][1];

dp[i][1][0]=dp[i-1][2][1]+a[i][1];

考虑它的上一个位置，dp[i-1]，如果第i位置比左右都高的话，它的前一个位置只能是高度为10的，为什么？因为第i位置的高度为20，比它低的只有高度为10的，所以dp[i][1][1]=dp[i-1][0][0]+a[i][1];如果i位置比左右都低呢？那么i-1位置只能为30，原因同上，所以dp[i][1][0]=dp[i-1][2][1]+a[i][1];

如果是种高度为30的树呢？

这其实和高度为10一样，只有比别的高dp[i][2][1]的情况。这里不做赘述。

dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];

原理同高度为10的一样。


------------
还有一些程序小细节，就具体看代码吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[100010][3][2],n,a[100010][3],ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);//读入每个位置各种高度的观赏价值
    for(int j=0;j<3;j++){//穷举树的高度（有三种）
        for(int i=0;i<3;i++)
            for(int k=0;k<2;k++)dp[1][i][k]=0;//初始化，全部赋值为0
        dp[1][j][0]=dp[1][j][1]=a[1][j];//初始值为a[1][j]
        for(int i=2;i<=n;i++){//循环每个位置作决策
            dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];
            dp[i][1][0]=dp[i-1][2][1]+a[i][1];
            dp[i][1][1]=dp[i-1][0][0]+a[i][1];
            dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];
        }
        for(int i=0;i<j;i++)ans=max(ans,dp[n][i][0]);//分类迭代ans，<=j的高度肯定是比它矮的，所以为dp[n][i][0]
        for(int i=2;i>j;i--)ans=max(ans,dp[n][i][1]);//与上述类似，>j的肯定是比它高的，所以为dp[n][i][1]
    }
    printf("%d",ans);//输出结果
    return 0;
}
```

---

## 作者：猪脑子 (赞：54)

题目描述

教主有着一个环形的花园，他想在花园周围均匀地种上n棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。

教主最喜欢3种树，这3种树的高度分别为10，20，30。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。

输入输出格式

输入格式：
输入文件garden.in的第1行为一个正整数n，表示需要种的树的棵树。

接下来n行，每行3个不超过10000的正整数ai，bi，ci，按顺时针顺序表示了第i个位置种高度为10，20，30的树能获得的观赏价值。

第i个位置的树与第i+1个位置的树相邻，**特别地，第1个位置的树与第n个位置的树相邻。**

输出格式：
输出文件garden.out仅包括一个正整数，为最大的观赏价值和。


【数据规模与约定】

对于20%的数据，有n≤10；

对于40%的数据，有n≤100；

对于60%的数据，有n≤1000；

对于100%的数据，有4≤n≤100000，并保证n一定为偶数。


------------
n<=100000,一看就得是个O(n)的算法~~(废话)~~

考虑DP:

	//定义dp[i][j][k](1<=i<=n,0<=j<=2,0<=k<=1)
	//表示前i棵树所能达到的最大观赏价值和
    //其中,j表示哪一种树(j==0,表示树高为10;j==1,表示树高为20,等等)
    //k==0表示第i棵树比左右两棵树都高,否则相反;
    
    //很容易得出以下思路：
    	dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i];
        dp[i][1][0]=dp[i-1][2][1]+b[i];
        dp[i][1][1]=dp[i-1][0][0]+b[i];
        dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+c[i];
    //具体我就不解释了(^_^)
    //DP完成后,枚举最后一棵树的状态(它的高度,比左右高还是低)并取max
下面上**70**分代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
inline void re(int &x)
{
    x=0;bool flag=false;
    char c=getchar();
    while(c<'0'||c>'9'){
        flag= c=='-';
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    if(flag)x=-x;
    return ;
}
int dp[100010][3][2];//dp;
int n;
int a[100010],b[100010],c[100010];//含义如题目描述
int main()
{
    re(n);
    for(int i=1;i<=n;i++)
    {
        re(a[i]);re(b[i]);re(c[i]);
    }
    for(int i=1;i<=n;i++)
    {
        dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i];
        dp[i][1][0]=dp[i-1][2][1]+b[i];
        dp[i][1][1]=dp[i-1][0][0]+b[i];
        dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+c[i];
    }
    int ans=0;
    for(int i=0;i<3;i++)
        for(int j=0;j<2;j++)
            ans=max(ans,dp[n][i][j]);//max
    printf("%d\n",ans);
    return 0;
}
```
然而,这个代码WA了三个点(为什么?)

再看一下题目描述：

第i个位置的树与第i+1个位置的树相邻，**特别地，第1个位置的树与第n个位置的树相邻。**

刚刚的代码并没有注意这一点。

因此，我们可以先枚举第一棵树的高度(0,1,2)，每一次都取max,但是枚举范围不同。

100分代码闪亮登场：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
inline void re(int &x)
{
    x=0;bool flag=false;
    char c=getchar();
    while(c<'0'||c>'9'){
        flag= c=='-';
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    if(flag)x=-x;
    return ;
}
int dp[100010][3][2];//0:hi<left,hi<right;
int n;
int a[100010][3];
int main()
{
    re(n);
    for(int i=1;i<=n;i++)
    {
        re(a[i][0]);re(a[i][1]);re(a[i][2]);
    }
    int ans=0;
    for(int j=0;j<3;j++)
    {
        for(int i=0;i<3;i++)
            for(int k=0;k<2;k++)
                dp[1][i][k]=0;
        dp[1][j][0]=dp[1][j][1]=a[1][j];
        for(int i=2;i<=n;i++)
        {
            dp[i][0][0]=max(dp[i-1][1][1],dp[i-1][2][1])+a[i][0];
            dp[i][1][0]=dp[i-1][2][1]+a[i][1];
            dp[i][1][1]=dp[i-1][0][0]+a[i][1];
            dp[i][2][1]=max(dp[i-1][1][0],dp[i-1][0][0])+a[i][2];
        }
        for(int i=0;i<j;i++)
            ans=max(ans,dp[n][i][0]);
        for(int i=2;i>j;i--)
            ans=max(ans,dp[n][i][1]);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Flokirie (赞：25)

其实呢，刚看到这道题的时候，我是想用二位dp的

// a wrong example

令f[i][j]为在第i个位置，选了第j种树时，最大观赏值

后来发现，这种递推不能满足“任何一个位置的树要比它相邻的两棵树的高度都高或者都低”这一限制条件。

然后本蒟蒻加了一维

// another wrong example

令f[i][j][k]为在第i个位置，本位置选了第j种树，前一个位置选第k种树时，最大观赏值，

f[i][j][k]=(所有y>k<j 或 y<k>j) max(f[i-1][k][y]+v[i][j])

再然后……发现在判断第n位置和第1位置是否满足要求时很吃力

于是！！！！！！！！！

本蒟蒻再加一维！！！！！！！！！！！

这题已经逼我加了两维了！！！！！！！！！！！！！

//a final and correct and accepted example

令f[i][j][k][first]为在第i个位置，本位置选了第j种树，前一个位置选第k种树，第一棵树种的是first时的最大观赏值！！！！！！！！！！

f[i][j][k][first]=(所有y>k<j 或 y<k>j) max(f[i-1][k][y][first]+v[i][j])   ！！！！！！！！

然后特殊判断(n-1)位置、n位置、1位置是否满足！！！！！！！！！！！

好了，不按Shift+1了，贴代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int f[100010][4][4][4];//浪费掉第2~4维的0
int v[100010][4];

int main(){
    int n;
    cin>>n;
    for (int i=0;i<n;i++){
        scanf("%d %d %d",&v[i][1],&v[i][2],&v[i][3]);
    }
    for (int i=1;i<4;i++){
        for (int j=1;j<4;j++){
            f[0][i][j][i]=v[0][i];//边界条件：第0位置（相当于题目中第1位置）观赏值v[0][i]，i为其上面的树
        }
    }
    for (int i=1;i<n;i++){//第1维
        for (int j=1;j<4;j++){ //第2维
            for (int x=1;x<4;x++){
                for (int y=1;y<4;y++){//枚举x、y
                    for (int z=1;z<4;z++)//第4维
                        if ((y>x && x<j) || (y<x && x>j)){//满足那个什么高度要求
                            f[i][j][x][z]=max(f[i][j][x][z],f[i-1][x][y][z]+v[i][j]);
                        }
                }
            }
        }
    }
    int maxv=0;
    for (int j=1;j<4;j++){
        for (int p=1;p<4;p++){
            for (int l=1;l<4;l++){
                if ((p<j && j>l) || (p>j && j<l)) maxv=max(maxv,f[n-1][j][p][l]);//满足那个什么高度要求
            }
        }
    }
    cout<<maxv;
    return 0;
}
```

---

## 作者：gyf12138 (赞：17)

#  显然的简单线性dp啊。。要那么多维干嘛？~~一个dp[i][1..4]就轻松过掉~~
### 首先我们需要明确目前的状态。。题目要求~~简谐运动~~一上一下。状态一共就两种（上&下）：
### 10 -> 20/30; 20 -> 30; 30 -> 10/20; 20 -> 10;
### 这里我们是不是察觉到了些许的不对劲？没错！就是10 20 10 & 30 20 30 这两种情况是固定的。。所以我们对于1...n枚举4种情况就ok了
### 但是~~这样10行代码过不掉~~只能解决一条链。。题目要求环，而且这个环是会对相邻的元素产生贡献，所以我们需要预处理一下起始位置4种情况。最后记录答案也需要处理。然后我们就完美的过掉了这个题
//好久没写过代码和题解了。。debuged 1 hour
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100000+5;
const int inf = 1e9;
int n, ans;
int dp[N][5]; // 1: 10 20/30; 2: 10 20 10; 3: 30 20 30; 4: 30 10/20; 
int v[N][4]; // 1: 10; 2: 20; 3: 30;
int main()
{
    cin>>n;
    for(int i = 1; i <= n; i++)
        scanf("%d%d%d", &v[i][1], &v[i][2], &v[i][3]);
    for(int j = 1; j <= 4; j++) {
        memset(dp, 0, sizeof dp);
        for(int i = 1; i <= 4; i++)
            dp[1][i] = -inf;
        if(j == 1) dp[1][j] = v[1][1];
        if(j == 2) dp[1][j] = v[1][2];
        if(j == 3) dp[1][j] = v[1][2];
        if(j == 4) dp[1][j] = v[1][3];
        for(int i = 2; i <= n; i++) {
            dp[i][1] = max(dp[i-1][2], dp[i-1][4]) + v[i][1];
            dp[i][2] = dp[i-1][1] + v[i][2];
            dp[i][3] = dp[i-1][4] + v[i][2];
            dp[i][4] = max(dp[i-1][1], dp[i-1][3]) + v[i][3];
        }
        if(j == 1) ans = max(dp[n][2], max(ans, dp[n][4]));
        if(j == 2) ans = max(ans, dp[n][1]);
        if(j == 3) ans = max(ans, dp[n][4]);
        if(j == 4) ans = max(dp[n][1], max(ans, dp[n][3]));
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：lcx8015071817 (赞：13)

#分层图
            
对于100%的数据，有4≤n≤100000，并保证n一定为偶数。                  
            
我们考虑分4层；即一个坑的4种情况

分别为1（10），2和2'（20），3（30)

然后是最关键的建边1->2->1和3->2'->3以便严格按照题目要求（都高都低）这种思想可以去了解下：<https://www.luogu.org/problemnew/show/P4782>;

同时1和3一定是最低和最高两边只要不是相同的即可

建边的权值就是下个坑的美学值
    
    cin>>a[1]>>b[1]>>c[1];
    for(int i=2;i<=n;i++)
    {
        cin>>a[i]>>b[i]>>c[i];
        add(i-1,n+i,b[i]);add(i-1,n*3+i,c[i]);//1->2,1->3
        add(i-1+n,i,a[i]);add(i-1+2*n,n*3+i,c[i]);//2->1,2'->3
        add(i-1+n*3,i,a[i]);add(i-1+n*3,i+2*n,b[i]);//3->1,3->2'
    }
图构完后接下来准备跑图，依我的方法需要跑4遍，起点分别为1（1），2（n+1），2'（2*n+1），3（3*n+1），终点
为n，2*n，3*n，4*n

每次跑图前只需要将起点赋值以及终点初始化

#####具体原因希望大家自己画图尝试下

第一次发题解，最后附上代码

	#include<bits/stdc++.h>
	const int N=100001;
    typedef long long LL;
    int a[N],b[N],c[N],head[N*4+4];LL dis[4*N+4];bool vis[4*N+4];
    int n,TOT=0;
    struct node
    {
        int nxt,to,w;
    }edge[6*N];
    using namespace std;
    void add(int x,int y,int w)
    {
        TOT++;edge[TOT].nxt=head[x];edge[TOT].w=w;edge[TOT].to=y;head[x]=TOT;
    }
    void jie(int O)
    {
        queue<int> q;
        q.push(O);vis[O]=1;
        while(q.size())
        {
            int x=q.front();q.pop();vis[x]=0;
            for(int i=head[x];i;i=edge[i].nxt)
            {
                int to=edge[i].to,w=edge[i].w;
                if(dis[to]<dis[x]+w)
                {
                    dis[to]=dis[x]+w;
                    if(!vis[to])
                    {
                        q.push(to);vis[to]=1;
                    }
                }
            }
        }
    }
    int main()
    {
    /*	freopen("garden.in","r",stdin);	
        freopen("garden.out","w",stdout);*/
        memset(dis,-1,sizeof(dis));
        cin>>n;cin>>a[1]>>b[1]>>c[1];
        for(int i=2;i<=n;i++)
        {
            cin>>a[i]>>b[i]>>c[i];
            add(i-1,n+i,b[i]);add(i-1,n*3+i,c[i]);//1->2,1->3
            add(i-1+n,i,a[i]);add(i-1+2*n,n*3+i,c[i]);//2->1,2'->3
            add(i-1+n*3,i,a[i]);add(i-1+n*3,i+2*n,b[i]);//3->1,3->2'
        }
        LL ans=0;
        dis[1]=a[1];jie(1);ans=max(max(ans,dis[4*n]),dis[2*n]);
    //已1为起点，终点除1,2'皆可
        for(int i=1;i<=4;i++)
        dis[i*n]=0;	
        dis[n+1]=b[1];jie(n+1);ans=max(ans,dis[n]);
    //以2为起点，终点只能唯1 
        for(int i=1;i<=4;i++)
        dis[i*n]=0;
        dis[n*2+1]=b[1];jie(2*n+1);ans=max(ans,dis[4*n]);
    //以2‘为起点，终点只能为3 
        for(int i=1;i<=4;i++)
        dis[i*n]=0;
        dis[n*3+1]=c[1];jie(3*n+1);ans=max(max(dis[n],ans),dis[3*n]);
    //以3为起点，终点除3,2皆可
        cout<<ans<<endl;
        return 0; 
    }




---

## 作者：freesaber (赞：10)

这道题我主要想说一种解决环的方法。
我们可以直接在第 ***n*** 个位置后面再加上一个位置，这个位置的各种属性与第一个位置相同。通俗的来说就是 ***把第一个位置再复制一份到第$n+1$个位置***。然后在动态规划时多规划一个位置（即：第$n+1$个位置），这样就可以解决首尾相邻的问题了。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int Max = 100000 + 5;
int a[Max][5], f[Max][5][4], n;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d %d %d", &a[i][1], &a[i][2], &a[i][3]);
    }
    a[n + 1][1] = a[1][1]; //复制第一个位置
    a[n + 1][2] = a[1][2];
    a[n + 1][3] = a[1][3];
    n++; //多规划一个位置
    for (int i = 2; i <= n; i++) {
        f[i][1][1] = max(f[i - 1][2][2], f[i - 1][3][2]) + a[i][1];
        f[i][2][1] = f[i - 1][3][2] + a[i][2];
        f[i][2][2] = f[i - 1][1][1] + a[i][2];
        f[i][3][2] = max(f[i - 1][2][1], f[i - 1][1][1]) + a[i][3];
    }
    int ans = -1;
    for (int i = 1; i <= 3; i++) //枚举第n+1个位置
        for (int j = 1; j <= 2; j++)
            ans = max(ans, f[n][i][j]);
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：RoRoyyy (赞：7)

~~祭一下我这个本来可以10min写完， 非要写40min的题~~

我的码量应该是最长的了。
我不想重复这个转移了...
我要吐了， 注释写的很详细



```cpp
//RoRoyyy
// dp[x][fir][last][now] 0:10 1:20 2:30
	表示到第几棵树， 开头第一颗种了什么， 第x颗种了什么， x-1颗种了什么
/* dp[x][fir][0][1] max= dp[x - 1][fir][1/2][0] + a[x][1]
   dp[x][fir][0][2] max= dp[x - 1][fir][1/2][0] + a[x][2]
   dp[x][fir][1][0] max= dp[x - 1][fir][0][1] + a[x][0]
   dp[x][fir][1][2] max= dp[x - 1][fir][2][1] + a[x][2]
   dp[x][fir][2][1] max= dp[x - 1][fir][1/0][2] + a[x][1]
   dp[x][fir][2][0] max= dp[x - 1][fir][1/0][2] + a[x][0]
   注意讨论fir和n的关系
*/
#include <cstdio>
#include <iostream>

using namespace std;
const int N = 1e5 + 5;
int n;
int a[N][3];
int dp[N][3][3][3];
int ans = 0;
void calc(int k) {
    for(int i = 0; i < 3; i++) 
        if(i != k)    
            dp[1][k][i][k] = a[1][k];
    for(int i = 2; i <= n; i++) {
        int j = i - 1;
        if(i == n) {
            if(k == 0) {//第一颗是0 那么最后一颗必须大于最后一颗的上一颗而且最后一颗不为0
                dp[i][k][0][1] = max(dp[i][k][0][1], max(dp[j][k][1][0] + a[i][1], dp[j][k][2][0] + a[i][1]));
                dp[i][k][0][2] = max(dp[i][k][0][2], max(dp[j][k][1][0] + a[i][2], dp[j][k][2][0] + a[i][2]));
                dp[i][k][1][2] = max(dp[i][k][1][2], dp[j][k][2][1] + a[i][2]);
            } else if(k == 1) {//第一颗是1 那么最后一颗不为1， 当最后一颗为0时 最后一颗的上一颗必须大于最后一颗
                                //最后一颗为2时 最后一颗的上一颗必须小于最后一颗
                dp[i][k][0][2] = max(dp[i][k][0][2], max(dp[j][k][1][0] + a[i][2], dp[j][k][2][0] + a[i][2]));
                dp[i][k][1][0] = max(dp[i][k][1][0], dp[j][k][0][1] + a[i][0]);
                dp[i][k][1][2] = max(dp[i][k][1][2], dp[j][k][2][1] + a[i][2]);
                dp[i][k][2][0] = max(dp[i][k][2][0], max(dp[j][k][1][2] + a[i][0], dp[j][k][0][2] + a[i][0]));
            } else {//第一颗是2 那么最后一颗不为2 当最后一颗为0时 最后一颗的上一颗必须大于0 /当最后一颗为1时， 最后一颗的上一颗必须为2
                dp[i][k][0][1] = max(dp[i][k][0][1], max(dp[j][k][1][0] + a[i][1], dp[j][k][2][0] + a[i][1]));
                dp[i][k][1][0] = max(dp[i][k][1][0], dp[j][k][0][1] + a[i][0]);
                dp[i][k][2][1] = max(dp[i][k][2][1], max(dp[j][k][1][2] + a[i][1], dp[j][k][0][2] + a[i][1]));
                dp[i][k][2][0] = max(dp[i][k][2][0], max(dp[j][k][1][2] + a[i][0], dp[j][k][0][2] + a[i][0]));
            }
            ans = max(ans, dp[i][k][0][1]);
            ans = max(ans, dp[i][k][0][2]);
            ans = max(ans, dp[i][k][1][0]);
            ans = max(ans, dp[i][k][1][2]);
            ans = max(ans, dp[i][k][2][1]);
            ans = max(ans, dp[i][k][2][0]);
        } else {
            dp[i][k][0][1] = max(dp[i][k][0][1], max(dp[j][k][1][0] + a[i][1], dp[j][k][2][0] + a[i][1]));
            dp[i][k][0][2] = max(dp[i][k][0][2], max(dp[j][k][1][0] + a[i][2], dp[j][k][2][0] + a[i][2]));
            dp[i][k][1][0] = max(dp[i][k][1][0], dp[j][k][0][1] + a[i][0]);
            dp[i][k][1][2] = max(dp[i][k][1][2], dp[j][k][2][1] + a[i][2]);
            dp[i][k][2][1] = max(dp[i][k][2][1], max(dp[j][k][1][2] + a[i][1], dp[j][k][0][2] + a[i][1]));
            dp[i][k][2][0] = max(dp[i][k][2][0], max(dp[j][k][1][2] + a[i][0], dp[j][k][0][2] + a[i][0]));
        }
    }
}
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j < 3; j++) {
            scanf("%d", &a[i][j]);
        }
    }
    for(int i = 0; i < 3; i++) calc(i);

    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：mydiplomacy (赞：7)

本蒟蒻有一个与其他题解都略有不同的解法，自认为很好理解~

算法：dp

首先，看到这道题有一个显然的状态，令f(i,j)代表考虑到第i个位置，第i个位置中第j种花的最优结果。考虑转移，发现在由f(i,j)转移到f(i-1,j)时还需要知道f(i-1,j')是比前一朵花矮还是高还是矮。

于是我们只需要添加一维f(i,j,k)代表

k=0时，考虑到第i个位置，第i个位置种第j种花，且第j种花比第i-1个位置要高的情况下的最优结果。

k=1时，考虑第i个位置种第j种花，且第j种花比第i-1个位置要矮的情况下最优结果。

于是此时我们就可以进行转移了。转移方程如下：

```cpp
//dp[i][j][1]  =  max{dp[i-1][j'][0]+a[i][j] | j'>j}
//dp[i][j][0]  =  max{dp[i-1][j'][1]+a[i][j] | j'<j}

//（如果第i棵比第i-1棵高，则第i棵也比第i+1棵高，则第i+1棵比第i棵矮。反之亦然）
```

但考虑到f(n,j,k)也与f(1,j',k')有关，我们还需要加一维，代表第1个位置种的是哪种植物。所以${dp[i][j][k][r]}$代表

考虑到第i个位置，第i个位置种第j种树，第1棵树种第k种树，
若r=0，第i棵比第i-1棵高。若r=1，第i棵比第i-1棵矮。

转移是，

```cpp
//dp[i][j][k][1]  =  max{dp[i-1][j'][k][0]+a[i][j] | j'>j}
//dp[i][j][k][0]  =  max{dp[i-1][j'][k][1]+a[i][j] | j'<j}

//special:
//if(j>k) dp[n][j][k][0] = max{dp[n-1][j'][k][1]+a[n][j] | j'<j}
//if(j<k) dp[n][j][k][1] = max{dp[n-1][j'][k][0]+a[n][j] | j'>j}

```

附代码。

```cpp
#include <iostream>
using namespace std;

const int maxn=100005;

int n;
int a[maxn][4], dp[maxn][4][4][2];
int ans=-1;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=3;j++)
			cin>>a[i][j];
	for(int j=1;j<=3;j++)
	{
		dp[1][j][j][0] = dp[1][j][j][1] = a[1][j];
	}
	for(int i=2;i<=n-1;i++)
	{
		for(int k=1;k<=3;k++)
		{
			for(int j=1;j<=3;j++)
			{
				for(int j2=j+1;j2<=3;j2++)
					dp[i][j][k][1] = max(dp[i][j][k][1],dp[i-1][j2][k][0]+a[i][j]);
				for(int j2=1;j2<j;j2++)
					dp[i][j][k][0] = max(dp[i][j][k][0],dp[i-1][j2][k][1]+a[i][j]);
		    }
		}
    }
    for(int k=1;k<=3;k++)
    {
    	for(int j=1;j<=3;j++)
    	{
    		if(j>k)
    		{
    			for(int j2=1;j2<j;j2++)
    				dp[n][j][k][0] = max(dp[n][j][k][0],dp[n-1][j2][k][1]+a[n][j]);
    	    }
    	    else if(j<k)
    	    {
    	    	for(int j2=j+1;j2<=3;j2++)
    	    		dp[n][j][k][1] = max(dp[n][j][k][1],dp[n-1][j2][k][0]+a[n][j]);
    	    }
    	    ans=max(ans,max(dp[n][j][k][0],dp[n][j][k][1]));
        }
    }
    cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：lihengyi (赞：4)

这道题题意还是简单明了的，就是求一种和最大的序列，满足其对应高度(s)wswswsws......

20分很容易想，就是枚举N个位置的10,20,30三种情况，时间复杂度O（3^n），但我们不用每次都枚举3个状态，除了上次的状态还有2个状态，所以时间复杂度O（2^n）~~然并卵~~

说实话，我也不知道40分和60分有什么用..........

好了入正题100分

**#DP#**

第一次想f[i][j][k]表示第i个位置高度为j的最大观赏值，k=1则第j位比第j-1位大，k=2则第j位比第j-1位小，于是就有了以下程序：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int one=10,two=20,three=30;
int a[100050],b[100050],c[100050],f[100050][40][4],n,m,i,j,k,l,s;
int xiao(int x,int y){
    if(x>y)x=y;
    return x;
}
int da(int x,int y){
    if(x<y)x=y;
    return x;
}
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
    }
    memset(f,0,sizeof(f));
    for(i=1;i<=n;i++){
        f[i][one][2]=da(f[i-1][two][1],f[i-1][three][1])+a[i];
        f[i][two][1]=b[i]+f[i-1][one][2];
        f[i][two][2]=b[i]+f[i-1][three][1];
        f[i][three][1]=c[i]+da(f[i-1][one][2],f[i-1][two][2]);
        //cout<<f[i][one][1]<<" "<<f[i][one][2]<<" "<<f[i][two][1]<<" "<<f[i][two][2]<<" "<<f[i][three][1]<<" "<<f[i][three][2]<<endl;

    }
    s=0;
    s=da(s,f[n][one][1]);
    s=da(s,f[n][one][2]);
    s=da(s,f[n][two][1]);
    s=da(s,f[n][two][2]);
    s=da(s,f[n][three][1]);
    s=da(s,f[n][three][2]);
    cout<<s<<endl; 
    return 0;
}
```

而我还很煞笔的把第二位做成10，20，30............

交完程序，woc70！！！！！！！！！！

表示震惊。

思（瞄）考（了）了（眼）一（题）下（解），原来还是环形。

默默地加了一维，表示第一次选的是10/20/30

终于A了

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int one=1,two=2,three=3;
int a[100050],b[100050],c[100050],f[100050][4][4][4],n,m,i,j,k,l,s;
int xiao(int x,int y){
    if(x>y)x=y;
    return x;
}
int da(int x,int y){
    if(x<y)x=y;
    return x;
}
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
    }
    memset(f,0,sizeof(f));
    f[1][one][2][one]=a[1];
    f[1][two][1][two]=b[1];
    f[1][two][2][two]=b[1];
    f[1][three][1][three]=c[1];
    for(i=2;i<=n;i++){
        for(j=1;j<=3;j++){
            f[i][one][2][j]=da(f[i-1][two][1][j],f[i-1][three][1][j])+a[i];
            f[i][two][1][j]=b[i]+f[i-1][one][2][j];
            f[i][two][2][j]=b[i]+f[i-1][three][1][j];
            f[i][three][1][j]=c[i]+da(f[i-1][one][2][j],f[i-1][two][2][j]);
        }
        //cout<<f[i][one][1]<<" "<<f[i][one][2]<<" "<<f[i][two][1]<<" "<<f[i][two][2]<<" "<<f[i][three][1]<<" "<<f[i][three][2]<<endl;
    }
    
    s=0;
    s=da(s,f[n][one][2][two]);
    s=da(s,f[n][one][2][three]);
    s=da(s,f[n][two][1][one]);
    s=da(s,f[n][two][2][three]);
    s=da(s,f[n][three][1][one]);
    s=da(s,f[n][three][1][two]);
    cout<<s<<endl; 
    return 0;
}
```

说实话，我对这个鬼畜的转移是怎么改出来的都是懵逼的。

还有为什么我要打one，two，three呀！！！！！！！！！！！！！！！！！！！！！！！！！！！！

气人。。。但还是祝大家AC愉快

---

## 作者：邓布利多6 (赞：2)

**题目描述**

教主有着一个环形的花园，他想在花园周围均匀地种上$n$棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。

教主最喜欢$3$种树，这$3$种树的高度分别为$10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。

**分析**

这道题是一个环形花园，麻烦就在这里，但我们可以分别考虑1号位置种树的情况，得出下面的动规参数：
```
用f[i,j,flag,firsttree]表示（从1号位置开始考虑），
i号位置种植j号树(j=0/1/2)，
两边相邻位置种植的树比它低（flag=0）或高（flag=1），
而位置1种了firsttree这种树时能够获得的最大观赏价值
```

**初始化**
```cpp
f[1][0][1][0]=a[1][0]; 
f[1][1][0][1]=a[1][1]; 
f[1][1][1][1]=a[1][1];
f[1][2][0][2]=a[1][2];
```

**转移方程**
```cpp
f[i][0][1][j]=max(f[i-1][1][0][j],f[i-1][2][0][j])+a[i][0];
//种第0种时要求两边高于它（f[i][0][1][j]），两边可以选择种1（f[i-1][1][0][j]）或2（f[i-1][2][0][j]）
f[i][1][0][j]=f[i-1][0][1][j]+a[i][1];
//种第1种时要求两边低于它（f[i][1][0][j]），两边只能选择0（f[i-1][0][1][j]）
f[i][1][1][j]=f[i-1][2][0][j]+a[i][1];
//种第1种时要求两边高于它（f[i][1][1][j]），两边只能选择2（f[i-1][2][0][j]）
f[i][2][0][j]=max(f[i-1][0][1][j],f[i-1][1][1][j])+a[i][2];
//种第2种时要求两边低于它（f[i][2][0][j]），两边可以选择种0（f[i-1][0][1][j]）或1（f[i-1][1][1][j]）
```

**答案**
```cpp
ans=max(f[n][0][1][1],f[n][0][1][2]);
//第n棵树种第0种要求两边高于他，第一棵树可选择1（f[n][0][1][1]）或2（f[n][0][1][2]）
ans=max(ans,max(f[n][1][1][2],f[n][1][0][0]));
//第n棵树种第1种要求两边高于他，第一棵树只能选择2（f[n][1][1][2]）
//第n棵树种第1种要求两边低于他，第一棵树只能选择0（f[n][1][0][0]）	
ans=max(ans,max(f[n][2][0][0],f[n][2][0][1]));
//第n棵树种第2种要求两边低于他，第一棵树可选择0（f[n][2][0][0]）或1（f[n][2][0][1]）
```

**完整代码**
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=100001;
int n,a[N][3],f[N][3][2][3],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
	f[1][0][1][0]=a[1][0]; 
	f[1][1][0][1]=a[1][1];
	f[1][1][1][1]=a[1][1];
	f[1][2][0][2]=a[1][2];
	for(int i=2;i<=n;i++)
		for(int j=0;j<=2;j++)
		{
			f[i][0][1][j]=max(f[i-1][1][0][j],f[i-1][2][0][j])+a[i][0];
			f[i][1][0][j]=f[i-1][0][1][j]+a[i][1];
			f[i][1][1][j]=f[i-1][2][0][j]+a[i][1];
			f[i][2][0][j]=max(f[i-1][0][1][j],f[i-1][1][1][j])+a[i][2];
		}
	ans=max(f[n][0][1][1],f[n][0][1][2]);
	ans=max(ans,max(f[n][1][1][2],f[n][1][0][0]));
	ans=max(ans,max(f[n][2][0][0],f[n][2][0][1]));
	printf("%d",ans);
	return 0;
}


```
```

---

## 作者：租酥雨 (赞：2)

很明显这个数据范围只能打O(n)，所以我们就要打DP。

第一眼看题以为要破环成链，但是想一想，反正首位都是会相互制约的，就从第一个位置开始，找到最后一个位置时判断是否可行就好了。

这个问题可以这样直观理解一下：有一个n\*3的数组，每列中只能选一个，而且必须上下移动选择（就是说相邻不能选同一行），且相邻两次移动方向不能相同（不能1到2再到3）。最后做一下n和1的判断，就差不多是题意了。

思路是枚举第一个位置选择的树的种类。老规矩，我们定义一个F数组来存储到达第i个位置时选择第j种树时产生的最大值，清晰一点的话就直接把F1 F2 F3分开。**很重要一个点：F2数组一定要进行区分，即：当前最大值是由前一位上升还是下降得来的，因为对后一位的选择有影响**

我们有递推方程：

            
            

```cpp
if (F2[i-1][1]) F1[i]=F2[i-1][1]+num[i][1];
if (F3[i-1]) F1[i]=max(F1[i],F3[i-1]+num[i][1]);
if (F3[i-1]) F2[i][0]=F3[i-1]+num[i][2];
if (F1[i-1]) F2[i][1]=F1[i-1]+num[i][2];
if (F2[i-1][0]) F3[i]=F2[i-1][0]+num[i][3];
if (F1[i-1]) F3[i]=max(F3[i],F1[i-1]+num[i][3]);
```
前面的if判断是为了保证有来源，开始时把第一个位置假设的树赋值，其余都是0。
大意：1号树的值可能是有前面的3号树下降得来，也可能是由前面的上升得来的2号树下降得来。

2号树上升得来的值只能来自1号树，2号树下降得来的值只能来自3号树。

3号树与1号树同理。

递推方程解决，答案就出来了。

代码君



        
        
            
            
            
        
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int F1[100001];
int F2[100001][2];
int F3[100001];
int num[100001][4];
int n,ans;
int gi()
{
    int x=0;
    char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
int main()
{
    n=gi();
    for (int i=1;i<=n;i++)
    {
        num[i][1]=gi();
        num[i][2]=gi();
        num[i][3]=gi();
    }
    for (int k=1;k<=4;k++)
    {
        memset(F1,0,sizeof(F1));
        memset(F2,0,sizeof(F2));
        memset(F3,0,sizeof(F3));
        if (k==1) F1[1]=num[1][1];
        if (k==2) F2[1][0]=num[1][2];//默认第一位置的2号树由下降得来 
        if (k==3) F2[1][1]=num[1][2];//默认第一位置的2号树由上升得来 
        if (k==4) F3[1]=num[1][3];
        for (int i=2;i<=n;i++)
        {
            if (F2[i-1][1]) F1[i]=F2[i-1][1]+num[i][1];
            if (F3[i-1]) F1[i]=max(F1[i],F3[i-1]+num[i][1]);
            if (F3[i-1]) F2[i][0]=F3[i-1]+num[i][2];
            if (F1[i-1]) F2[i][1]=F1[i-1]+num[i][2];
            if (F2[i-1][0]) F3[i]=F2[i-1][0]+num[i][3];
            if (F1[i-1]) F3[i]=max(F3[i],F1[i-1]+num[i][3]);
        }
        if (k==1) ans=max(ans,F2[n][1]),ans=max(ans,F3[n]);//如果第1位置选的1号树，那么答案可能是n号位的3号树或n号位上升的来的2号树 
        if (k==2) ans=max(ans,F3[n]);//下降得来就是3号树 
        if (k==3) ans=max(ans,F1[n]);//上升得来就是1号树 
        if (k==4) ans=max(ans,F2[n][0]),ans=max(ans,F1[n]);//如果第1位置选的3号树，那么答案可能是n号位的1号树或n号位下降的来的2号树 
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Dispwnl (赞：2)

用四维数组储存

一维存第几个位置，二维存树的种类，三维存是向上趋势还是向下趋势（1表示向上，2表示向下），四维存第一棵树的种类

如果选第1种树，趋势肯定是向上的

如果选第2种树，要分情况讨论

如果选第3种树，趋势肯定是向下的

递推式（状态转移方程）：



```cpp
for(int i=2;i<=n;i++)
for(int j=1;j<=3;j++)
    {
        f[i][1][1][j]=max(f[i-1][2][0][j],f[i-1][3][0][j])+c[i][0];
        f[i][2][0][j]=f[i-1][1][1][j]+c[i][1];
        f[i][2][1][j]=f[i-1][3][0][j]+c[i][1];
        f[i][3][0][j]=max(f[i-1][2][1][j],f[i-1][1][1][j])+c[i][2];
    }
```
最后输出第n个位置（选1时第1棵树为2，第1棵树为2；选2时第1棵树为1，第1棵树为3；选3时第1棵树为1，第1棵树为2）中的最大值
```cpp
# include<iostream>
using namespace std;
int c[200001][3];
int n,maxn;
int ans[4];
int f[200001][4][2][4];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>c[i][0]>>c[i][1]>>c[i][2];
    f[1][1][1][1]=c[1][0],f[1][2][0][2]=c[1][1],f[1][2][1][2]=c[1][1],f[1][3][0][3]=c[1][2];
    for(int i=2;i<=n;i++)
      for(int j=1;j<=3;j++)
        {
            f[i][1][1][j]=max(f[i-1][2][0][j],f[i-1][3][0][j])+c[i][0];
            f[i][2][0][j]=f[i-1][1][1][j]+c[i][1];
            f[i][2][1][j]=f[i-1][3][0][j]+c[i][1];
            f[i][3][0][j]=max(f[i-1][2][1][j],f[i-1][1][1][j])+c[i][2];
        }
    ans[1]=max(f[n][3][0][2],f[n][3][0][1]);
    ans[2]=max(f[n][2][0][1],f[n][2][1][3]);
    ans[3]=max(f[n][1][1][2],f[n][1][1][3]);
    cout<<max(ans[1],max(ans[2],ans[3]));
    return 0;
}

```

---

## 作者：Invisible_power (赞：2)

f[i][j][k]表示到了第i个坑，种了第j种树，递增或递减的状态为k

环形处理可以先跑一遍2-n，然后最后特殊判断一下第一课树。

因为只有三棵树，动归里面的可以强行一波~~~（不用循环）


```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
using namespace std;
const int Maxn=100005;
int a[Maxn][5],f[Maxn][5][2],n,ans;
//0表示递增，1表示递减 
int max(int a,int b){return a>b?a:b;}
int main(){
       cin>>n;
       for(int i=1;i<=n;i++)
        cin>>a[i][1]>>a[i][2]>>a[i][3];
       for(int i=2;i<=n;i++){
           f[i][1][1]=max(f[i-1][2][0],f[i-1][3][0])+a[i][1];
           f[i][2][1]=f[i-1][3][0]+a[i][2];
           f[i][2][0]=f[i-1][1][1]+a[i][2];
           f[i][3][0]=max(f[i-1][2][1],f[i-1][1][1])+a[i][3];
       }
       ans=max(ans,f[n][1][1]+a[1][2]);
       ans=max(ans,f[n][1][1]+a[1][3]);
       ans=max(ans,f[n][2][1]+a[1][3]);
       ans=max(ans,f[n][2][0]+a[1][1]);
       ans=max(ans,f[n][3][0]+a[1][1]);
       ans=max(ans,f[n][3][0]+a[1][2]);
       cout<<ans<<endl;
       return 0;
}

```

---

## 作者：liability (赞：1)

这里提供一中新思路，是清北学堂里的。

设dp[n][4],dp[i][j]代表栽倒第i棵树时的总价值。


dp[i][1]代表当前栽高度为10的树时的状态，则此时左右两棵树都比他高；

dp[i][2]代表第i个坑栽高度为20的树且左右两棵树都比他矮的状态；

dp[i][3]代表当前栽高度为20的树且左右两棵树都比他高的状态；

dp[i][4]代表第i个坑栽高度为30的树,则此时左右两棵树都比他矮。

状态转移方程显然：

dp[i][1]=max(dp[i-1][2],dp[i-1][4])+a[i][1];

dp[i][2]=dp[i-1][1]+a[i][2];

dp[i][3]=dp[i-1][4]+a[i][2];

dp[i][4]=max(dp[i-1][1],dp[i-1][3])+a[i][3].

于是我们依次枚举第一个坑的状态，得出ans，详细见代码实现。

附上代码(⊙﹏⊙)

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000006][4],dp[1000006][5],n，ans=0;  //防抄袭QAQ
void fun(int x) {
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=4;i++) dp[0][i]=-999999;
    dp[0][x/2+1]=a[0][x/2+1];
    for(int i=1;i<n;i++) {
        dp[i][1]=max(dp[i-1][2],dp[i-1][4])+a[i][1];
        dp[i][2]=dp[i-1][1]+a[i][2];
        dp[i][3]=dp[i-1][4]+a[i][2];
        dp[i][4]=max(dp[i-1][1],dp[i-1][3])+a[i][3];
    }
    if(x==1) ans=max(dp[n-1][2],dp[n-1][4]);
    if(x==2) ans=max(ans,dp[n-1][1]);
    if(x==3) ans=max(ans,dp[n-1][4]);
    if(x==4) ans=max(dp[n-1][3],max(ans,dp[n-1][1]));
    return ;
}
    
int main () {
    cin>>n;
    for(int i=0;i<n;i++) {
        scanf("%lld%lld%lld",&a[i][1],&a[i][2],&a[i][3]);//话说模拟赛我被卡读入了，看来以后打比赛都要写快读了。
    }
    for(int i=1;i<=4;i++) fun(i);
    cout<<ans;
    return 0;
}
    
```

---

## 作者：yyy14159 (赞：1)

嗯，题解里好像大多是用三维或者四维（第一个种多高），我觉得二维也ok.  

思路大概是令 f[i][k] 表示第i个种第k种树，k=1，2，3表示10m，20m，30m.   

转移： 方程比较长就不在这写了，代码里有写。意思就是这一位置能放第k种树，当且仅当这么放之后与前两棵树组成的三棵树树高满足要求。例如：这一位置i能放20m的树（k==2），当且仅当上一位置i-1能放【10m】或【30m】的树，并且上上个位置i-2能放【20m or 30m】或【10m or 20m】的树。注意到上上个位置（i-2）只是用来判断这个位置（i）**能不能**放某种树。   

还有些细节：要枚举第一个位置放哪种树，对于第一个位置书稿的每一个取值，第n个位置也应做相应特判. 例如第一个位置种10m的树，那么第n个位置只能种20m或30m的树。  

还有一个卡点是 枚举到第一个位置种20m的树时，应再枚举第二个位置放10m还是30m的树，这样才能确保n，1，2这三颗树树高是满足要求的。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[100005][4];
int n;
long long a[100005][4];
long long inf=0x3c3c3c3c;
long long res1,res2,res3;

inline void dp()
{
	for(int i=3;i<n;i++){
		f[i][1]=max( f[i-1][2]>0&&f[i-2][1]>0 ? f[i-1][2]+a[i][1]:-inf , f[i-1][3]>0&&(f[i-2][2]>0||f[i-2][1]>0) ? f[i-1][3]+a[i][1]:-inf);
		f[i][2]=max( f[i-1][1]>0&&(f[i-2][2]>0||f[i-2][3]>0) ? f[i-1][1]+a[i][2]:-inf , f[i-1][3]>0&&(f[i-2][1]>0||f[i-2][2]>0) ? f[i-1][3]+a[i][2]:-inf);
		f[i][3]=max( f[i-1][1]>0&&(f[i-2][2]>0||f[i-2][3]>0) ? f[i-1][1]+a[i][3]:-inf , f[i-1][2]>0&&f[i-2][3]>0 ? f[i-1][2]+a[i][3]:-inf);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld",&a[i][1],&a[i][2],&a[i][3]);
	}
	
	memset(f,-0x3f,sizeof(f));
	f[1][1]=a[1][1],f[2][2]=a[2][2]+f[1][1],f[2][3]=a[2][3]+f[1][1];
	dp();
	f[n][2]=max( f[n-1][1]>0&&(f[n-2][2]>0||f[n-2][3]>0) ? f[n-1][1]+a[n][2]:-inf ,f[n][2]);
	f[n][3]=max( f[n-1][1]>0&&(f[n-2][2]>0||f[n-2][3]>0) ? f[n-1][1]+a[n][3]:-inf , f[n-1][2]>0&&f[n-2][3]>0 ? f[n-1][2]+a[n][3]:-inf);
	res1=max(f[n][2],f[n][3]);
	
	memset(f,-0x3c,sizeof(f));
	f[1][2]=a[1][2],f[2][1]=a[2][1]+f[1][2];
	dp();
	f[n][1]=max( f[n-1][2]>0&&f[n-2][1]>0 ? f[n-1][2]+a[n][1]:-inf , f[n-1][3]>0&&(f[n-2][2]>0||f[n-2][1]>0) ? f[n-1][3]+a[n][1]:-inf);
	res2=f[n][1];
	
	memset(f,-0x3c,sizeof(f));
	f[1][2]=a[1][2],f[2][3]=a[2][3]+f[1][2];
	dp();
	f[n][3]=max( f[n-1][1]>0&&(f[n-2][2]>0||f[n-2][3]>0) ? f[n-1][1]+a[n][3]:-inf , f[n-1][2]>0&&f[n-2][3]>0 ? f[n-1][2]+a[n][3]:-inf);
	res2=max(res2,f[n][3]);
	
	memset(f,-0x3c,sizeof(f));
	f[1][3]=a[1][3],f[2][1]=a[2][1]+f[1][3],f[2][2]=a[2][2]+f[1][3];
	dp();
	f[n][1]=max( f[n-1][2]>0&&f[n-2][1]>0 ? f[n-1][2]+a[n][1]:-inf , f[n-1][3]>0&&(f[n-2][2]>0||f[n-2][1]>0) ? f[n-1][3]+a[n][1]:-inf);
	f[n][2]=max( f[n][2] , f[n-1][3]>0&&(f[n-2][1]>0||f[n-2][2]>0) ? f[n-1][3]+a[n][2]:-inf);
	res3=max(f[n][1],f[n][2]);
	
	printf("%lld",max(res1,max(res2,res3)) );
	return 0;
 } 
 ```

---

## 作者：tuo3288 (赞：0)

ε=(´ο｀*)))唉，这道题为什么弄成一个环啊？

链上的我会，这个换好难办啊！！

而且，这题偏偏是DP题。

要是深搜题的话，就可以在递归的时候多传一个参数，记下第一棵的高度，方便进行到第n位的时候进行比较啊！这DP的话可怎么知道之前的状态啊？？

哎！既然我深搜可以多传一个参数表示第一棵，那我DP为什么就不能多一个维度，表示第一棵树的高度呢。

上代码

```cpp
#include<cstdio>
using namespace std;
inline int read()
{
	int X=0,W=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')W=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){X=(X<<1)+(X<<3)+ch-48;ch=getchar();}
	return X*W;
}
int max(int a,int b)
{
	return a>b?a:b;
}
int a[100001][3];
int dp[100001][3][3][2];
int main()
{
	int n=read();
	for(int i=1;i<=n;i++)a[i][0]=read(),a[i][1]=read(),a[i][2]=read();
	dp[1][0][0][0]=a[1][0];
	dp[1][1][1][1]=dp[1][1][1][0]=a[1][1];
	dp[1][2][2][1]=a[1][2];
	for(int i=2;i<=n;i++){
		for(int j=0;j<=2;j++){
			dp[i][j][2][1]=max(dp[i-1][j][1][0],dp[i-1][j][0][0])+a[i][2];
			dp[i][j][0][0]=max(dp[i-1][j][1][1],dp[i-1][j][2][1])+a[i][0];
			dp[i][j][1][1]=dp[i-1][j][0][0]+a[i][1];
			dp[i][j][1][0]=dp[i-1][j][2][1]+a[i][1];
		}
	}
	int ans=max(max(max(dp[n][0][1][1],dp[n][0][2][1]),max(dp[n][1][2][1],dp[n][1][0][0])),max(dp[n][2][0][0],dp[n][2][1][0]));
	printf("%d\n",ans);
	return 0;
}
```
虽然好理解了，但是代价却是常数扩大了3倍……

而且我们发现后两个维度中，有一些状态是永远不会有的，比如dp[i][j][0][1]。

因此，我们可以将后两个状态压缩，以达到省空间的目的……

ps：本题解仅提供一种思路，由于这种方法会使常数扩大，除非实在缕不清思路，否则尽量不要用。

---

## 作者：Сталин (赞：0)

~~调试了一下午QAQ 推荐一篇[思路相似(tong)的博客](https://www.luogu.org/blog/Roy/solution-p1133)~~

### ~~显然~~这是一道~~看似简单的~~DP题，审题是关键~~之一~~

- 教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度**都高或者都低**

~~都高或都低啊，我一开始还以为是只要高或者低都行的QAQ~~

- 第i个位置的树与第i+1个位置的树相邻，**特别地，第1个位置的树与第n个位置的树相邻。**

相当于在一个环上种树，第1个和第n个树的高度也要和谐。

- 那么，怎么处理呢？

首先，肯定要用一个维度处理**当前是那棵树(i)**~~废话~~

还要用一个维度处理**当前树的高度(j)**(我用1代表10,2代表20，以此类推，开1~3就行了)

然后得用一个维度记录**当前的树是比两边的树高还是低(k)**(0和1就行了)

最后一个维度用来**记录第一棵树的高度(l)**（蒟蒻想不出更好的方法处理了QAQ， 个人感觉有些题解的三维DP正确性有点迷，因为DP到了n如果不特殊记录的话就不知道每个状态是从哪里转移来的了）

### DP方程

撇去处理第一颗树的l，三维的DP方程很好推
(f[i][j][k],k==0代表i树比左右两棵树低，k==1反之)

f[i][1][0]=max(f[i-1][2][1],f[i-1][3][1])+a[i];

//高度20、30的树都比高度为10的树高，该树只可能比左右的树都低，k==0。继承的同时加上i的美观值

f[i][2][0]=f[i-1][3][1]+b[i];

//只有高度30的树比20的高，此处k要标记为0，因为（这里假设）比两边都低，不可低于一边的同时高于另一边

f[i][2][1]=f[i-1][1][0]+b[i]

//高度为10的树低于高度的20树，此时**注意**k==1，比两边的树都高

f[i][3][1]=max(f[i-1][1][0],f[i-1][2][0])+c[i];

//只可能高于两边的树

l呢？~~不管？~~ 对，不到1或n真的不用管，直接丢在后面，不过要多一遍for(1~3)

### 特殊处理

- 1要特殊处理，l记录的是第一棵树唉，肯定要记录的辣

- n...... 之前闲置的 l ~~终于~~有用了，到了第n个点,**树与k、l都要和谐:要么比k、l都高，要么都低。**

### 细节

~~好像没什么细节~~ 我在代码里i、j、k、l的顺序有所变动，a、b、c数组被我合并成了a数组，a[1]=>a数组;a[2]=>b数组;a[3]=>c数组。

数据范围**不可能**爆出int，~~但是保险起见~~我还是加了long long

~~其他详见代码~~

### CODE:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
inline ll mymax(ll x,ll y){return x>y?x:y;}
int n;
ll a[4][110000];
ll f[4][4][2][110000];//f[i][j][k][l]:
/*i表示第一棵树是哪种高度的(要继承);j当前是哪种高度的;k比周围的高(0)还是低(1)
当前的树gao度是 /10/20/30 
比左右的树都低/高
*/

int main()
{
//	freopen("testdata (1).in","r",stdin);
//	freopen("my_opt.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)for(int j=1;j<=3;j++)scanf("%lld",&a[j][i]);
	
	memset(f,0,sizeof(f));
	f[1][1][0][1]=a[1][1];//初始化 
	f[2][2][0][1]=a[2][1];
	f[2][2][1][1]=a[2][1];
	f[3][3][1][1]=a[3][1];
	
	for(int i=2;i<n;i++)
	{
		for(int j=1;j<=3;j++)
		{//除了以下四种状态以外，其他状态都是无意义的
			f[j][1][0][i]=mymax(f[j][2][1][i-1],f[j][3][1][i-1])+a[1][i];
			f[j][2][0][i]=f[j][3][1][i-1]+a[2][i];
			f[j][2][1][i]=f[j][1][0][i-1]+a[2][i];
			f[j][3][1][i]=mymax(f[j][1][0][i-1],f[j][2][0][i-1])+a[3][i];
		}
	}
	
	ll ans=0;
	for(int i=1;i<=3;i++)//实推式子原码 
		for(int k=1;k<=3;k++)
		{
			if(i>1 && k>1)f[i][1][0][n]=mymax(f[i][1][0][n],f[i][k][1][n-1]+a[1][n]);
			if(i>2 && k>2)f[i][2][0][n]=mymax(f[i][2][0][n],f[i][k][1][n-1]+a[2][n]);
			if(i<2 && k<2)f[i][2][1][n]=mymax(f[i][2][1][n],f[i][k][0][n-1]+a[2][n]);
			if(i<3 && k<3)f[i][3][1][n]=mymax(f[i][3][1][n],f[i][k][0][n-1]+a[3][n]);
		}
	for(int i=1;i<=3;i++)//暴力找最大值 
		for(int j=1;j<=3;j++)
			for(int k=0;k<=1;k++)
				ans=mymax(ans,f[i][j][k][n]);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：清远学会 (赞：0)

# 动态规划
这道题还是简单的吧(连我都推出状态转移方程，~~龟速逃~~)
### 进入正题：
既然是DP题，自然少不了状态转移方程啦，那么怎样可以维护题目的限制呢？

首先，get到题面中树的高度只有三种(10,20,30)，那么可以用一维表示第i位的树高是多少(用0/1/2表示)，那么前一棵与后一棵高度怎么维护呢？

~~让我们充分发挥人类智慧~~…… 自然，前一棵树也可表示成一维：同理也用0/1/2表示，那下一棵咧？

别急，让我们把已经设好的方程写下来：f[i][0/1/2][0/1/2]:表示枚举到第i棵树，此时第i棵树高度为[0/1/2],上个树为[0/1/2];

那下一个状态为f[i+1][0/1/2][0/1/2],发现此状态的本树高就是上个状态的下棵树高。~~完结撒花~~

等等，那么他是个环怎么办？

我先开是从1跑到n+1，结果只有70分，发现最后统计答案时出现点瑕疵~~大怒~~

干脆从2跑到n，在从n转移到1(特殊搞) ~~过了~~

### 最后，放上(整齐优美)代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 200500
using namespace std;

int n;
int a[N][5];
int f[N][4][4];
int ans;

int main() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++) 
		scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
	for(int i = 2;i <= n;i ++) {
		f[i][0][1] = max(f[i - 1][2][0],f[i - 1][1][0]) + a[i][0];
		f[i][0][2] = max(f[i - 1][2][0],f[i - 1][1][0]) + a[i][0];
		f[i][1][2] = max(f[i][1][2],f[i - 1][2][1] + a[i][1]);
		f[i][1][0] = max(f[i][1][0],f[i - 1][0][1] + a[i][1]);
		f[i][2][0] = max(f[i - 1][0][2],f[i - 1][1][2]) + a[i][2];
		f[i][2][1] = max(f[i - 1][0][2],f[i - 1][1][2]) + a[i][2];
	}
	f[1][0][1] = max(f[n][2][0],f[n][1][0]) + a[1][0];
	f[1][0][2] = max(f[n][2][0],f[n][1][0]) + a[1][0];
	f[1][1][2] = max(f[1][1][2],f[n][2][1] + a[1][1]);
	f[1][1][0] = max(f[1][1][0],f[n][0][1] + a[1][1]);
	f[1][2][0] = max(f[n][0][2],f[n][1][2]) + a[1][2];
	f[1][2][1] = max(f[n][0][2],f[n][1][2]) + a[1][2];
	ans = max(ans,max(f[1][0][1],f[1][0][2]));
	ans = max(ans,max(f[1][1][2],f[1][1][0]));
	ans = max(ans,max(f[1][2][1],f[1][2][0]));
	cout << ans << endl;
}
```

---

## 作者：_7zz (赞：0)

emmmmmmmmmm，初次看到题，想到dfs，一看数据范围，不可能实现的。后来一想，val值只有3种，剪枝的话可以大幅度提高效率，就尝试用dfs写了一发，然后过了，一起分享。
思路就是无脑dfs，每次记录当前val值和当前位置是大的树还是小的树。然后记忆话搜索，开辟一个标记数组，然后就想，怎样能完全标记一个中间状态，首先要有当前位置和当前值，当前是否为大的树，以及所有树的首位置（默认为1）的val值以及首位置是大树还是小树。这样就ac了。
下面附上ac代码。我是新手，请多多提意见。谢谢！
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct ff{
    int a[4];
}f[100005];
int fg[4][2][100005][4][2];
int dfs(int k,int s,int ct,int val,int flag){
    if(fg[k][s][ct][val][flag]!=0) return fg[k][s][ct][val][flag];
    if(ct==n){
        if(flag&&val>s) return fg[k][s][ct][val][flag]=f[ct].a[val];
        if(!flag&&val<s) return fg[k][s][ct][val][flag]=f[ct].a[val];
        return fg[k][s][ct][val][flag]=-1;
    }
    if(flag){
        int ans=-1;
        for(int i=1;i<val;i++)
            ans=max(dfs(k,s,ct+1,i,0),ans);
        if(ans>0) return fg[k][s][ct][val][flag]=ans+f[ct].a[val];
        else return fg[k][s][ct][val][flag]=-1;
    }
    else{
        int ans=-1;
        for(int i=val+1;i<=3;i++)
            ans=max(dfs(k,s,ct+1,i,1),ans);
        if(ans>0) return fg[k][s][ct][val][flag]=ans+f[ct].a[val];
        else return fg[k][s][ct][val][flag]=-1;
    }
}
int main(){
    cin>>n;
    memset(fg,0,sizeof(fg));
    for(int i=1;i<=n;i++)
        cin>>f[i].a[1]>>f[i].a[2]>>f[i].a[3];
    int ans=-1;
    for(int i=1;i<=3;i++){
        ans=max(dfs(1,i,1,i,1),ans);
        ans=max(dfs(0,i,1,i,0),ans);
    }
    cout<<ans<<endl;
    return 0;
}

```


---

## 作者：hulean (赞：0)

思路楼上楼下也讲过了，这里来详细解析一下状态转移方程与一些技巧

$n<=10^5 $ 

O（n）算法

- 状态
```cpp
dp[i][j][k]表示在第i个位置，种j*10的高度的树，且这棵树是否比相邻两棵树高
```
- 转移
```cpp
dp[i][1][0]=max(dp[i-1][2][1],dp[i-1][3][1])+a[i];
//种高度为10的树，肯定比相邻的两棵树矮
dp[i][2][0]=dp[i-1][3][1]+b[i];
//种高度为20且高度比相邻的矮的，那么第i-1棵肯定是高度为30且比相邻的两棵高的
dp[i][2][1]=dp[i-1][1][0]+b[i];
//种高度为20且高度比相邻的高的，那么第i-1棵肯定是高度为10且比相邻的两棵矮的
dp[i][3][1]=max(dp[i-1][1][0],dp[i-1][2][0])+c[i];
//种高度为30的树，肯定比相邻的两棵树高
```
- 答案
```cpp
取dp[n][1][0]、dp[n][2][0]、dp[n][2][1]、dp[n][3][1]的最大值
```
但是只有70分...

> 特别地，第1个位置的树与第n个位置的树相邻。

这个~~好像~~没有考虑过

所以要把位置为1的特殊处理
```cpp
dp[1][1][0]=max(dp[n][2][1],dp[n][3][1])+a[1];
dp[1][2][0]=dp[n][3][1]+b[1];
dp[1][2][1]=dp[n][1][0]+b[1];
dp[1][3][1]=max(dp[n][1][0],dp[n][2][0])+c[1];
```
那么答案就应该是这个:
```cpp
取dp[1][1][0]、dp[1][2][0]、dp[1][2][1]、dp[1][3][1]的最大值
```
完整代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100000+10;
int n;
int a[MAXN],b[MAXN],c[MAXN];
int dp[MAXN][4][2];
inline int read()
{
	int tot=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
	{
		tot=tot*10+c-'0';
		c=getchar();
	}
	return tot;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),b[i]=read(),c[i]=read();
	for(int i=2;i<=n;i++)
	{
		dp[i][1][0]=max(dp[i-1][2][1],dp[i-1][3][1])+a[i];
		dp[i][2][0]=dp[i-1][3][1]+b[i];
		dp[i][2][1]=dp[i-1][1][0]+b[i];
		dp[i][3][1]=max(dp[i-1][1][0],dp[i-1][2][0])+c[i];
	}
	dp[1][1][0]=max(dp[n][2][1],dp[n][3][1])+a[1];
	dp[1][2][0]=dp[n][3][1]+b[1];
	dp[1][2][1]=dp[n][1][0]+b[1];
	dp[1][3][1]=max(dp[n][1][0],dp[n][2][0])+c[1];
	cout<<max(dp[1][1][0],max(dp[1][2][0],max(dp[1][2][1],dp[1][3][1])))<<endl;
	return 0;
}
```

---

## 作者：_QYC_ (赞：0)

```cpp
/*
f[i][1][0]=max(f[i-1][2][1],f[i-1][3][1])+a[i][1];
f[i][2][0]=f[i-1][3][1]+a[i][2];
f[i][2][1]=f[i-1][1][0]+a[i][2];
f[i][3][1]=max(f[i-1][2][0],f[i-1][1][0])+a[i][3];
*/
//思考过程： 
/*先想到方程中应有位置i，再想到枚举树要种那颗，结合这两个状态信息
和题中的‘高矮高’、‘矮高矮’的要求，发现两维是不够的，还需 
一维来记录树的高矮：1代表本位置上的树比旁边两树高，0表示矮 ； 
发现，种树1没有1状态，3没有0状态，2全有； 
由于dp是递推关系，我们只用考虑当前位置的树与上一棵树的高矮关系； 
方程如上； 
又发现：此题为环，不分开情况考虑，会有后效性
所谓后效性，是指从1递推到n，发现n树和1树的高度关系不满足本题所述关系； 
解决方法：枚举第一个位置的状态（种树的情况），分别dp，取max（符合你枚举情况关系的max）； 
*/ 
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
int const MAXN=100000+10;
int f[MAXN][4][2];
int a[MAXN][4];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&a[i][1],&a[i][2],&a[i][3]);
    }
    int maxx=-1;
    for(int j=1;j<=4;j++){//枚举种树状态 
        memset(f,0,sizeof(f));
        if(j==1)f[1][1][0]=a[1][1];//种树1且比旁边两树矮（只能矮） 
        if(j==2)f[1][2][0]=a[1][2];//种树2且比旁边两树矮 
        if(j==3)f[1][3][1]=a[1][3];//种树3且比旁边两树高（只能高） 
        if(j==4)f[1][2][1]=a[1][2];//种树2且比旁边两树高 
        for(int i=2;i<=n;i++){
            f[i][1][0]=max(f[i-1][2][1],f[i-1][3][1])+a[i][1];
            f[i][2][0]=f[i-1][3][1]+a[i][2];
            f[i][2][1]=f[i-1][1][0]+a[i][2];
            f[i][3][1]=max(f[i-1][2][0],f[i-1][1][0])+a[i][3];
        }
        if(j==1)maxx=max(maxx,max(f[n][2][1],f[n][3][1]));
        if(j==2)maxx=max(maxx,f[n][3][1]);
        if(j==3)maxx=max(maxx,max(f[n][1][0],f[n][2][0]));
        if(j==4)maxx=max(maxx,f[n][1][0]);
    }
    cout<<maxx<<endl;
    return 0;
}
```

---

## 作者：ghmgjf (赞：0)

首先这一看就是一道dp题目，但怎么来dp呐？先观察题目，我们
能很容易得出影响因素有i前后面的花的高度以及i处各种花的价值
所以可以容易得出dp[i][j][k][f]=max(dp[i-1][j][k][f]+v[i][j]（其实此题就这最难了）
,i为位置，j是i处花的种类，k是i-1处花的种类，f为第一处花的种类（因为是环，所以要用）。那题目就迎刃而解了。
上代码：
```c
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
#define xx 1000010
int n,dp[100010][5][5][5];
int a[xx][4],maxx;
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i][1]>>a[i][2]>>a[i][3];
		
	}
	for(int i=1;i<=3;++i)//初始化1处所有情况的价值。
	{
		for(int j=1;j<=3;++j)
		{
			dp[1][i][j][i]=a[1][i];
		}
	}
	for(int i=2;i<=n;++i)
	{
		for(int j=1;j<=3;++j)
		{
			for(int k=1;k<=3;++k)
			{
				for(int z=1;z<=3;++z)
				{
					for(int f=1;f<=3;++f)
					if((j>k&&z>k)||(j<k&&z<k))//i-1处花的高度要么比两边大，要么比两边小。
					{
						dp[i][j][k][f]=max(dp[i][j][k][f],dp[i-1][k][z][f]+a[i][j]);
					}
				}
			}
		}
	}
	for (int j=1;j<4;j++)//找出最大值。
	{
        for (int p=1;p<4;p++)
		{
            for (int l=1;l<4;l++)
			{
                if ((p<j && j>l) || (p>j && j<l)) 
				maxx=max(maxx,dp[n][j][p][l]);
            }
        }
    }
	cout<<maxx;
	return 0;
}
```

---

## 作者：Cardinalere (赞：0)

终于A了，这道题目其实不难。

我们考虑搜索，显然对于n有o(3^n),明显TLE。

这时我们考虑dp，f[i,j,k,l]表示到第个位置种第j种树，

此时要求k=0表示两边树都小于这棵树，k=1表示大于，l表示第一棵树种什么。

转移方程显然。最后判断是否符合规范来求解。

下面附上本蒟蒻的P代码

```cpp
  var
  i,j,k,l,o,p,m,n,ans:longint;
  f:array[-100000..100000,1..3,0..2,1..3] of longint;
  a,b,c,d:array[0..100000] of longint;
function max(a,b:longint):longint;
begin
  if a>=b then max:=a else max:=b;
end;
begin
  readln(n);
  for i:=1 to n do
  readln(a[i],b[i],c[i]);
  f[1,1,1,1]:=a[1];
  f[1,2,0,2]:=b[1];
  f[1,2,1,2]:=b[1];
  f[1,3,0,3]:=c[1];
  for i:=2 to n do
  for k:=1 to 3 do
  begin
  f[i,1,1,k]:=max(f[i-1,2,0,k],f[i-1,3,0,k])+a[i];
  f[i,2,1,k]:=f[i-1,3,0,k]+b[i];
  f[i,2,0,k]:=f[i-1,1,1,k]+b[i];
  f[i,3,0,k]:=max(f[i-1,1,1,k],f[i-1,2,1,k])+c[i];
  end;
  ans:=max(ans,max(f[n,1,1,2],f[n,1,1,3]));
  ans:=max(ans,f[n,2,0,1]);
  ans:=max(ans,f[n,2,1,3]);
  ans:=max(ans,max(f[n,3,0,1],f[n,3,0,2]));
  writeln(ans);
end.

```

---

## 作者：1124828077ccj (赞：0)

调了两天，终于A了。。。

我这个方程似乎有些与众不同。。。

f[i][j][k][l]表示当前在第i棵树，第i棵树种第j种高度，第i-1棵种第k种高度，第1棵种第l种高度（**注意，是第1棵！！！**）

为什么要存第1棵呢？因为第1棵会影响第n棵。

然后方程挺好想得，自己推推吧。。。

但是，这样推有个问题，虽然你可以让第n棵一定满足要求，却不一定能让第1棵满足。。。

所以还需要循环两次，一次第一棵旁边的那两棵都比第1棵小，一次都比第一棵大

然后一堆细节，一堆不合法的状态需要删除。。。

看代码吧：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
int n,s[100002][3],f[100002][3][3][3],ans;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    scanf("%d%d%d",&s[i][0],&s[i][1],&s[i][2]);
    for (int i=1;i<=n;i++)
    if (i<n)
    {
        for (int j=0;j<3;j++)
        for (int k=0;k<3;k++)
        for (int l=0;l<3;l++)
        {
            if (i==1 && j!=l){f[i][j][k][l]=-1e9;continue;}//去掉不合法操作
            if (i==2 && (k!=l || j>k))
            {f[i][j][k][l]=-1e9;continue;}
            if (j<k)
            for (int m=k-1;m>=0;m--)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            if (j>k)
            for (int m=k+1;m<3;m++)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            if (!f[i][j][k][l])f[i][j][k][l]=-1e9;//如果没有合法状态，则标记为负无穷
        }
    }
    else
    {
        for (int j=0;j<3;j++)
        for (int k=0;k<3;k++)
        for (int l=0;l<3;l++)
        {
            if (j<k && j>l || j>l || j>k || j==l)continue;
            if (j<k)
            for (int m=k-1;m>=0;m--)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            if (j>k)
            for (int m=k+1;m<3;m++)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            ans=max(ans,f[i][j][k][l]);
        }
    }
    memset(f,0,sizeof(f));//以上为第一次，以下为第二次
    for (int i=1;i<=n;i++)
    if (i<n)
    {
        for (int j=0;j<3;j++)
        for (int k=0;k<3;k++)
        for (int l=0;l<3;l++)
        {
            if (i==1 && j!=l){f[i][j][k][l]=-1e9;continue;}
            if (i==2 && (k!=l || j<k))
            {f[i][j][k][l]=-1e9;continue;}
            if (j<k)
            for (int m=k-1;m>=0;m--)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            if (j>k)
            for (int m=k+1;m<3;m++)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            if (!f[i][j][k][l])f[i][j][k][l]=-1e9;
        }
    }
    else
    {
        for (int j=0;j<3;j++)
        for (int k=0;k<3;k++)
        for (int l=0;l<3;l++)
        {
            if (j<l || j<k || j>k && j<l || j==l)continue;
            if (j<k)
            for (int m=k-1;m>=0;m--)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            if (j>k)
            for (int m=k+1;m<3;m++)
            f[i][j][k][l]=max(f[i][j][k][l],f[i-1][k][m][l]+s[i][j]);
            ans=max(ans,f[i][j][k][l]);
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：SGOI_Aromyase (赞：0)

我的清秀的码风又来啦，这一题的思路是动规，本来以为O(n)就可以搞定，然后发现最后一棵树十分难受

于是决定枚举第一棵树的高度，我感觉自己像是打了个表

反正是过了样例，交了以后一遍AC的，开心

我一直信仰分步写在函数里面，代码如下：

        
    
    
    


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[100005][5]={0},f[100005][5][3],n;
int maxx=-1;
// f[a][b][c] a代表第a棵树，b代表树的高度为b*10
//c为1代表下一棵树需要比这一棵树低，c为2反之 
void chushi(){//初始化 
    for(int i=1;i<=n;i++){
        int s1,s2,s3;scanf("%d%d%d",&s1,&s2,&s3);
        a[i][1]=s1;a[i][2]=s2;a[i][3]=s3;
    }
    for(int i=1;i<=2;i++){
        f[1][1][i]=a[1][1];
        f[1][2][i]=a[1][2];
        f[1][3][i]=a[1][3];
    }
}
void dp(){//进行动态规划 
    for(int b=1;b<=3;b++){//枚举第一棵树的情况，先推出第二颗树 
        if(b==1) {
        f[2][1][2]=0xffffffff;//也算是一种另类的剪枝了吧，赋成最小值 
        f[2][2][2]=0xffffffff;
        f[2][2][1]=f[1][1][2]+a[2][2];
        f[2][3][1]=f[1][1][2]+a[2][3];
        }
        if(b==2){
        f[2][1][2]=f[1][2][1]+a[2][1];
        f[2][2][2]=0xffffffff;
        f[2][2][1]=0xffffffff;
        f[2][3][1]=f[1][2][2]+a[2][3];
        }
        if(b==3){
        f[2][1][2]=f[1][3][1]+a[2][1];
        f[2][2][2]=f[1][3][1]+a[2][2];
        f[2][2][1]=0xffffffff;
        f[2][3][1]=0xffffffff;
        }
        for(int i=3;i<=n;i++){//dp 
        f[i][1][2]=max(f[i-1][2][1],f[i-1][3][1])+a[i][1];
        f[i][2][2]=f[i-1][3][1]+a[i][2];
        f[i][2][1]=f[i-1][1][2]+a[i][2];
        f[i][3][1]=max(f[i-1][2][2],f[i-1][1][2])+a[i][3];
    }
    if(b==1) maxx=max(f[n][2][1],max(f[n][3][1],maxx));//根据枚举的第一棵树推答案 
    if(b==2) maxx=max(f[n][3][1],max(f[n][1][2],maxx));
    if(b==3) maxx=max(f[n][2][2],max(f[n][1][2],maxx));
    }
}
void print(){//输出 
    printf("%d",maxx);
}
int main(){
    scanf("%d",&n);
    chushi();
    dp();
    print();
}
```

---

## 作者：理想气体 (赞：0)

这道题原本是一道比较简单的三维dp，但是改成了环形，所以要枚举点1的情况。

状态转移方程楼下说得已经比较清楚了，为了枚举点1种的树的情况，我加了一维数组，表示点1取到的高度。

循环三次dp，每次将点1取到高度所对应的dp数组状态初始化为点1种植该树得到的价值。以确保最后取到的答案一定更优（若出现类似“在下面的递推过程中取到了不可能存在的情况”的话仍然不用担心，因为在最后从三次dp结果中取最优时，至少有一个结果会优于这个“取到不该取的情况所推出的结果”，因为点1种任何树取得的价值量都是正整数，其他符合要求的情况按照同样的路径推到底结果一定大）。

最后取可能情况中的最大值输出即可。

由于本题输入略多（最多可达三十万），因此用iostream的话最好加读入优化。

以下代码以供参考





 
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int dp[4][100001][4][2];
int val[100001][4];
//dp[i][1][0] = max(dp[i][1][0] , max(dp[i-1][2][1] , dp[i-1][3][1]) + val[i][1]);
//dp[i][2][0] = max(dp[i-1][3][1] + val[i][2] , dp[i][2][0]);
//dp[i][2][1] = max(dp[i-1][1][0] + val[i][2] , dp[i][2][1]);
//dp[i][3][1] = max(dp[i][3][1] , max(dp[i-1][1][0] , dp[i-1][2][0]) + val[i][3]);
//基本的四个状态转移方程，需要改动;
int main()
{
    cin.sync_with_stdio(false);
    int n; cin>>n;
    for(int i = 1 ; i <= n ; i++)
    {
        cin>>val[i][1]>>val[i][2]>>val[i][3];
    }
    int ans = 0;
    for(int l = 1 ; l <= 3 ; l++)
    {
        dp[l][1][l][0] = dp[l][1][l][1] = val[1][l];
        for(int i = 2 ; i<= n ; i++)
        {
            dp[l][i][1][0] = max(dp[l][i][1][0] , max(dp[l][i-1][2][1] , dp[l][i-1][3][1]) + val[i][1]);
            dp[l][i][2][0] = max(dp[l][i-1][3][1] + val[i][2] , dp[l][i][2][0]);
            dp[l][i][2][1] = max(dp[l][i-1][1][0] + val[i][2] , dp[l][i][2][1]);
            dp[l][i][3][1] = max(dp[l][i][3][1] , max(dp[l][i-1][1][0] , dp[l][i-1][2][0]) + val[i][3]);
        }
        if(l == 1)
        {
            ans = max(ans , max(dp[l][n][2][1] , dp[l][n][3][1]));
        }
        if(l == 2)
        {
            ans = max(ans , max(dp[l][n][3][1] , dp[l][n][1][0]));
        }
        if(l == 3)
        {
            ans = max(ans , max(dp[l][n][2][0] , dp[l][n][1][0]));
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Vin_1999 (赞：0)

dp[i][j][k]表示前i棵树已种的情况下，且第i棵树种第k种树，第i-1棵树种第j种树，的最大价值

状态转移方程详见程序内。注意由于第一棵树是有后效性的，会影响第n棵树。所以我们需要枚举第一棵树。

```cpp
#include<iostream>  
#include<cstdlib>  
#include<cstring>  
#include<cstdio>
#include<climits>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);(i)++)  
using namespace std;
const int maxn=100010;
static long long dp[maxn][4][4],fir,n,v[maxn][4];
inline void init()
{
    scanf("%d",&n);
    rep(i,1,n) rep(j,1,3) scanf("%d",&v[i][j]);
}
int main ()  
{  
    freopen("e:/in.txt","r",stdin);
    //freopen("e:/out.txt","w",stdout);
    init();
    long long ans=INT_MIN;
    for(fir=1;fir<=3;fir++)
    {
          //printf("%d:",fir);
        memset(dp,-127,sizeof(dp));
        if(fir==1)
        {
            rep(k,2,3) dp[2][fir][k]=v[1][fir]+v[2][k];
                }
                else if(fir==2)
                {
                    dp[2][fir][3]=v[1][2]+v[2][3];
                    dp[2][fir][1]=v[1][2]+v[2][1];
                }
                else
                {
                    rep(k,1,2) dp[2][fir][k]=v[1][fir]+v[2][k];
                }
        rep(i,3,n) rep(j,1,3) rep(k,1,3)
        {
            if(j<k)
            {
                for(int p=j+1;p<=3;p++)
                  dp[i][j][k]=max(dp[i][j][k],dp[i-1][p][j]+v[i][k]);
            }
            else if(j>k)
            {
                for(int p=j-1;p;p--)
                  dp[i][j][k]=max(dp[i][j][k],dp[i-1][p][j]+v[i][k]);
            }
        }
        /*rep(i,1,n) rep(j,1,3)
        {
            rep(k,1,2) printf("%d ",dp[i][j][k]);
            printf("%d\n",dp[i][j][3]);
                }*/
        if(fir==1)
        {
            ans=max(ans,max(dp[n][1][2],max(dp[n][1][3],dp[n][2][3]))); 
        }
        else if(fir==2)
        {
            rep(p,2,3) ans=max(ans,dp[n][p][1]);
            rep(p,1,2) ans=max(ans,dp[n][p][3]);
        }
        else
        {
            ans=max(ans,max(dp[n][3][2],max(dp[n][2][1],dp[n][3][1])));
        }
    }
    printf("%lld",ans);
    return 0;
}//by llyz-ljy
```

---

## 作者：Skywalker_David (赞：0)

看这么久没人发题解，那么我先发一个pascal的吧。







—————————————————————————————————————

三维动规，f[i,1..4]表示分别前i棵树，第i棵树的高度为10（下棵树肯定要比它高），20（下棵树比它高），20（下棵树比它矮），30（下棵树肯定要比它矮）的最大价值。特别注意这是一个环，所以要分别枚举第一棵树，并且在求出f[n,1..4]后在判断是否符合当前枚举的第一棵树。

```delphi

var 
    f:array[1..100000,1..4]of longint;
    a:array[1..100000,1..3]of longint;
    i,j,n,ans:longint;
function max(a,b:longint):longint;
begin
    if a>b then exit(a) else exit(b);
end;

begin
    readln(n);
    for i:=1 to n do 
        read(a[i,1],a[i,2],a[i,3]);
    ans:=-maxlongint;
    for j:=1 to 4 do begin
        fillchar(f,sizeof(f),0);
        for i:=1 to 4 do 
            f[1,i]:=-maxlongint;
        case j of
            1:f[1,j]:=a[1,1];
            2:f[1,j]:=a[1,2];
            3:f[1,j]:=a[1,2];
            4:f[1,j]:=a[1,3];
        end;
        for i:=2 to n do begin
            f[i,1]:=max(f[i-1,2],f[i-1,4])+a[i,1];
            f[i,2]:=f[i-1,1]+a[i,2];
            f[i,3]:=f[i-1,4]+a[i,2];
            f[i,4]:=max(f[i-1,1],f[i-1,3])+a[i,3];
        end;
        case j of
            1:ans:=max(max(ans,f[n,2]),f[n,4]);
            2:ans:=max(ans,f[n,1]);
            3:ans:=max(ans,f[n,4]);
            4:ans:=max(max(ans,f[n,1]),f[n,3]);
        end;
    end;
    writeln(ans);
end.

```

---


# [ROIR 2019] 探险队 (Day 2)

## 题目背景

翻译自 [ROIR 2019 D2T3](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day2.pdf)。

## 题目描述

需要派遣一支探险队前去探索邻近的星系。共有 $n$ 名候选人，编号从 $1$ 到 $n$，探险队成员需要从中选出。

在候选人中进行了一次调查，每个人可以指出一个他不愿意与之一起参加探险的候选人。对于第 $i$ 个候选人，调查结果是一个整数 $a_{i}$，表示他不愿意与编号为 $a_i$ 的人一起参加探险。如果 $i$ 号候选人愿意与任何人一起参加探险，则 $a_{i} = -1$。

你需要求出在满足所有派遣出的候选人的意愿的情况下，最大的可以派遣的人数。

## 说明/提示

数据中 Subtask 0 为样例。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $19$ | $n\le20$ |
| $2$ | $10$ | $a_1=-1$，$\forall i>1,a_i=i-1$ |
| $3$ | $15$ | $a_i<i$ |
| $4$ | $13$ | $1\le n\le2000$ |
| $5$ | $43$ | 无特殊性质 |

对于 $100\%$ 的数据，$n\le3\times10^5$，$a_i=-1$ 或 $1\le a_i\le n$，且 $a_i\ne i$。

## 样例 #1

### 输入

```
4
2
4
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
3
2
-1
2```

### 输出

```
2```

# 题解

## 作者：Drifty (赞：7)

### Solution

之前写的由于表述方式不好讲的不清楚，改了一下。

提供一种很好写的做法。

首先我们注意到一共有 $n$ 条关系，因此这构成基环树森林。

这个问题就等价于求最大独立集，然后这在基环树上是可以贪心的。

我们不妨令 $a_i$ 为 $i$ 的父亲。那么我们从叶子节点开始取，然后再间隔着取，这样一定不劣（即，按照拓扑序取）。然后为了方便统计，每次直接删掉处理过的点和边。

经过上述处理，基环树就只剩下一个环了，我们再在环上贪心染一遍色就好了。

搜索的时候记录答案即可。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 3e5 + 3;
int n, a[N], in[N], ans;
bool vis[N];
void dfs (int u, int w) {
	if (vis[u]) return;
	vis[u] = true; ans += w;
	if (a[u] == -1) return;
	if (-- in[a[u]] == 0 || w == 1) dfs (a[u], w ^ 1);
}
int main() {
	cin.tie(NULL) -> sync_with_stdio(false);
	cin >> n;
	for (int i = 1; i <= n; i ++)
		cin >> a[i], (~a[i]) ? in[a[i]] ++ : 0;
	for (int i = 1; i <= n; i ++) if (!in[i]) dfs(i, 1);
	for (int i = 1; i <= n; i ++) if (!vis[i]) dfs(i, 0);
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：水星湖 (赞：6)

一看就会了。

考虑 $i$ 和 $a_i$ 不能同时被选择，所以关系其实是无向的。把所有 $i$ 和 $a_i$ （$a_i\neq -1$）连边，容易发现形成了一个由若干树或基环树构成的森林。

显然不同的连通块之间的点是互不影响的，所以可以对每一个连通块分别求出最多可以选多少个点，答案即为每一个连通块能取的最多的数量之和。

先考虑普通的树怎么算，其实就是没有上司的舞会，设 $f_{u,0/1}$ 表示考虑到点 $u$，是否取这个点。有转移 $f_{u,0}=\sum_{v\in son_u}\max\{f_{v,0},f_{v,1}\}$，$f_{u,1}=1+\sum_{v\in son_u}f_{v,0}$。

对于基环树，可以先找出环上的点，以每个环上的点为根执行一遍普通树的 dp，然后用 dp 合并环上的点的答案即可。

两个比较重要的细节：

- 树 dp 的时候不能访问环上的其他点。

- 为了避免环上第一个和最后一个点都取根的情况，合并环上点时要分讨第一个是否取根。

代码中 dfs 找出了环上的点，$g$ 用于合并环。$cur=0$ 是普通树的情况。

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace z {

#define int long long
const int N = 3e5 + 5;
vector<int> p[N];
int c[N], cur, ans, h[N];
int f[N][2], g[N][2];
int fa[N], dfn[N], cnt;
void dfs(int u, int fa) {
    z::fa[u] = fa;
    dfn[u] = ++cnt;
    for(int v : p[u]) {
        if(v == fa) continue;
        if(dfn[v]) {
            if(dfn[v] > dfn[u]) {
                int tmp = v;
                while(tmp != u) {
                    c[++cur] = tmp;
                    h[tmp] = 1;
                    tmp = z::fa[tmp];
                }
                c[++cur] = u;
                h[u] = 1;
            }
        } else dfs(v, u);
    }
}
void dp(int u, int fa) {
    f[u][1] = 1;
    for(int v : p[u]) {
        if(v == fa || h[v]) continue;
        dp(v, u);
        f[u][0] += max(f[v][1], f[v][0]);
        f[u][1] += f[v][0];
    }
}
void main() {

    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
    int n; cin >> n;
    for(int i = 1; i <= n; i++) {
        int x; cin >> x;
        if(x != -1) {
            p[x].push_back(i);
            p[i].push_back(x);
        }
    }   
    for(int i = 1; i <= n; i++) {
        cur = 0;
        if(!dfn[i]) {
            dfs(i, 0);
            for(int j = 1; j <= cur; j++) {
                dp(c[j], 0); 
                g[j][0] = max(g[j-1][0], g[j-1][1]) + f[c[j]][0];
                g[j][1] = g[j-1][0] + f[c[j]][1]; 
            }
            int tmp = g[cur][0];
            g[1][0] = g[1][1] = 0;
            g[1][0] = f[c[1]][0];
            for(int j = 2; j <= cur; j++) {
                g[j][0] = max(g[j-1][0], g[j-1][1]) + f[c[j]][0];
                g[j][1] = g[j-1][0] + f[c[j]][1]; 
            }
            tmp = max(tmp, g[cur][1]);
            ans += tmp;
            if(!cur) {
                dp(i, 0);
                ans += max(f[i][0], f[i][1]);
            }
        }
    }
    cout << ans << endl;
}

#undef int

}


int main()
{
    z::main();
    return 0;
}
```

---

## 作者：yi_hr (赞：4)

## 基环树
本题为基环树的模板题，一般基环树的标志为：  
1. $n$ 个点 $n$ 条边的无向连通图。  
2. 每个点的出度为 $1$。  
3. 每个点的入度为 $1$。

若将每个点向其讨厌的人连边，则符合 $2$ 情况。一般我们对于基环树问题都可以有以下考虑：分别处理环与环上的树，分别进行树上 DP 与环上 DP。  
定义 $f[i][1/0]$ 表示树中 $i$ 点选与不选的最大人数。  
定义 $dp[i][1/0]$ 表示环中 $i$ 点选与不选的最大人数。  
那怎么处理 $-1$ 呢？  
建立一个虚点权值为 $0$，如果不讨厌任何人，就当 ta 讨厌 $0$ 号点。
## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
inline int read(){
	register int f=1,x=0;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
const int N=1e6+9;
struct edge{
	int next,to;
}e[N];
int head[N],cnt;
inline void add(int u,int v){
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
int n,m,a[N],p[N];
bitset<N> vis,ins;
ll f[N][2],dp[N][2],ans,cntt;
void dfs(int u){
	vis[u]=1;
	f[u][1]=a[u];
	int v;
	for(int i=head[u];i;i=e[i].next){
		v=e[i].to;
		if(ins[v])continue;
		dfs(v);
		f[u][0]+=max(f[v][1],f[v][0]);
		f[u][1]+=f[v][0];
	}
}
//vector<int> sys;
int sys[N];
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=1;
		p[i]=max(read(),0);
		add(p[i],i);
	}
	int u,v;
	for(int i=1;i<=n;i++){
		if(vis[i])continue;
		m=0;
		u=i;
		while(!vis[u]){
			vis[u]=1;
			u=p[u];
		}
		v=u;
		while(1){
			sys[m++]=v;
			ins[v]=1;
			v=p[v];
			if(u==v)break;
		}
		for(int i=0;i<m;i++){
			dfs(sys[i]);
		}
		cntt=-INF;
		for(int t=0;t<2;t++){
			for(int j=0;j<2;j++){
				if(j==t) dp[0][j]=f[sys[0]][j];
				else dp[0][j]=-INF;
			}
			for(int j=1;j<m;j++){
				v=sys[j];
				dp[j][0]=max(dp[j-1][0],dp[j-1][1])+f[v][0];
				dp[j][1]=dp[j-1][0]+f[v][1];
			}
			if(t==0) cntt=max(cntt,max(dp[m-1][0],dp[m-1][1]));
			else cntt=max(cntt,dp[m-1][0]);
		}
		ans+=cntt;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：modfish_ (赞：2)

## 思路
考虑把每个人和他不喜欢的人连一条边，得到一张无向图。问题转换为求这张图的最大独立集。

因为每个点至多有一个不喜欢的人，所以得到的图一定是若干个树或基环树。不同连通块可以独立处理。

对于一棵树，使用树形 DP 可以简单地求出其最大独立集。具体地，设 $dp_{x,0/1}$ 表示 $x$ 及其子树内的点，在不选择 $x$/选择 $x$ 时的最大独立集。转移：

$$dp_{x,0}=\sum_{j\in son(x)}\max(dp_{j,0},dp_{j,1})$$

$$dp_{x,1}=\sum_{j\in son(x)}dp_{j,0}$$

其中 $son(x)$ 表示 $x$ 的儿子的集合。

对于一棵基环树，不妨把每个环上的点作为根的树的答案都先算出来，然后再做一遍 DP 即可。方法与上一个差不多就不赘述了。

于是就做完了，复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 3e5 + 5;

int to[maxn], fa[maxn], rt[maxn], vis[maxn];
int head[maxn], nxt[maxn << 1], vs[maxn << 1], cnt = 0;
int dp[maxn][2], cy[maxn], pr[maxn];

void match(int u, int v){
	nxt[++ cnt] = head[u], vs[cnt] = v, head[u] = cnt;
}
int find(int x){
	if(fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}
void dfs(int x){
	dp[x][1] = 1;
	for(int i = head[x]; i; i = nxt[i]){
		int j = vs[i];
		dfs(j);
		dp[x][0] += max(dp[j][0], dp[j][1]);
		dp[x][1] += dp[j][0];
	}
}

int main(){
	int n;
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++) fa[i] = i;
	for(int i = 1; i <= n; i ++){
		scanf("%d", &to[i]);
		if(to[i] != -1) fa[find(i)] = find(to[i]);
	}
	for(int i = 1; i <= n; i ++){
		if(find(i) != i) continue;
		int x = i, px = 0;
		while(x != -1 && !vis[x]) vis[x] = 1, px = x, x = to[x];
		if(x == -1){
			rt[px] = 1, cy[i] = px;
			continue;
		}
		cy[i] = x, pr[i] = px;
		int j = to[x];
		while(j != x) rt[j] = 1, j = to[j];
		rt[x] = 1;
	}
	for(int i = 1; i <= n; i ++) if(!rt[i]) match(to[i], i);
	for(int i = 1; i <= n; i ++) if(rt[i]) dfs(i);
	int ans = 0;
	for(int i = 1; i <= n; i ++){
		if(find(i) != i) continue;
		int x = cy[i], px = pr[i];
		if(to[x] == -1){
			ans += max(dp[x][0], dp[x][1]);
			continue;
		}
		int s00 = dp[x][0], s01 = 0, s10 = 0, s11 = dp[x][1];
		x = to[x];
		while(x != px){
			int ps00 = s00, ps01 = s01, ps10 = s10, ps11 = s11;
			s00 = max(ps00, ps01) + dp[x][0], s01 = ps00 + dp[x][1], s10 = max(ps10, ps11) + dp[x][0], s11 = ps10 + dp[x][1];
			x = to[x];
		}
		ans += max(max(s00 + max(dp[px][0], dp[px][1]), s01 + dp[px][0]), max(s10 + dp[px][0], s11 + dp[px][0]));
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Little_duck_GGG (赞：1)

### 题目意思
在一棵基环树中选出一些点，使得被选集合内的所有点，都满足其讨厌的点不在被选集合中。
### 题目思路
其实这道题跟[P2607，骑士](https://www.luogu.com.cn/problem/P2607)挺像的。大家做完这道题之后可以去做骑士。~虽然我是做完骑士再来切这道题的。~

我们一看到基环树，我们就会考虑**断掉环上的边**，最后将各个**连通块**的答案相加，那便是我们最终的答案了。好了，说了这么多，其实无非就两步操作，找**环上的两点断边，然后树型动规**。

首先先是找环上的点，在环上的点一定会被遍历**无数**次，但非环上的点一定只会被遍历**一次**，那么这么说的话，如果一个点被遍历了**两次**，那么它就一定在**环上**。那我们只需找到被遍历两次的点不就好啦。

咋找呢。很简单，我们用一个数组 $v_i$ 表示在递归过程中 $i$ 点是否被标记。如果你发现你找到的当前点已经被标记过一次了，那么它就在环上。

下面是找环的代码。

```cpp
void dfs(int x,int y)
{
	v[x]=1;//标记 
	for(int i=head[x];~i;i=bian[i].next)
	{
		int son=bian[i].to; 
		if((i^1)==y) continue;
		if(v[son]==1)//如果当前找到的点已经被标记过了，那么它就是环 
		{
			a2=son;//a1,a2表示断掉的边的两端点 
			a1=x;
			e=i;//e是干什么的等会儿说 
			continue;
		}
		dfs(son,i);//继续递归 
	}
}
```
如果你认真看了我的注释，你可能会不解 $e$ 是干什么的，这个变量是储存当前找到的**环上的边的编号**，是不是有点绕，那么我们来看一张图吧。
![](https://cdn.luogu.com.cn/upload/image_hosting/zivvtb7n.png)

红边就表示 $e$ 所编号的边，这样懂了吧。

那为啥要这样呢。某两个人可能**互相讨厌对方**，因为我们建立的是无向边，所以可能会有**重边**的情况，那我们会炸掉的。

所以，千万**不要**在断边的时候判定父亲和儿子是否为 $a_1$ 或者 $a_2$ 这样会死的。我们要判断当前所在的边是否为 $e$。~本人当时只会动态数组，所以犯下了此愚蠢的错误，希望大家别跟我一样。~

那么找环差不多了，是时候开始~简单的~树型动规了。

很明显，我们对于每一个点，只有两种状态，**选或不选**，也就是零或一。所以我们用一个数组 $dp_{i,0/1}$ 表示当前 $i$ 点选或不选的最大贡献。

对于不选来说，它的初始值为零，它的儿子结点可以选，也可以不选，**取最大**即可。对于选的时候，它的儿子结点**只能**不选，但初始值为一。

给出动规代码。

```cpp
void dfs2(int x,int y)
{
	dp[x][1]=p[x];//p[x]是1，别管 
	dp[x][0]=0;//初始值千万别忘记赋 
	for(int i=head[x];~i;i=bian[i].next)
	{
		int son=bian[i].to;
		if((i^1)==y) continue;
		if(i==e||(i^1)==e) continue;
		dfs2(son,i);
		dp[x][1]+=dp[son][0];//父亲结点选，儿子只能不选 
		dp[x][0]+=max(dp[son][1],dp[son][0]);//父亲不选，儿子可选可不选，取最大 
	}
}
```
最后还需要注意一点，就比如样例二，有时候它做到**没环**后，再去找环，你会发现它**找不到**，所以 $a_1$ 就会等于 $a_2$。此时我们不仅只要取当前点不取的情况，还要取当前点取得情况，请务必注意。

给出最后的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,e,v[1000500];
long long p[1000500];
int a1,a2,u;
long long dp[1005000][2];
int cnt;
struct node
{
	int next,to;
}bian[2005000];
int head[2005000];
void add(int q,int p)
{
	bian[cnt].next=head[q];
	bian[cnt].to=p;
	head[q]=cnt++;
}
long long pa;
void dfs(int x,int y)//找环，不多说了，前面提到过了 
{
	v[x]=1;
	for(int i=head[x];~i;i=bian[i].next)
	{
		int son=bian[i].to; 
		if((i^1)==y) continue;
		if(v[son]==1)
		{
			a2=son;
			a1=x;
			e=i;
			continue;
		}
		dfs(son,i);
	}
}
void dfs2(int x,int y)
{
	dp[x][1]=p[x];//p[x]是1，别管 
	dp[x][0]=0;//初始值千万别忘记赋 
	for(int i=head[x];~i;i=bian[i].next)
	{
		int son=bian[i].to;
		if((i^1)==y) continue;
		if(i==e||(i^1)==e) continue;
		dfs2(son,i);
		dp[x][1]+=dp[son][0];//父亲结点选，儿子只能不选 
		dp[x][0]+=max(dp[son][1],dp[son][0]);//父亲不选，儿子可选可不选，取最大 
	}
}
int main()
{
	scanf("%d",&n);
	memset(head,-1,sizeof head);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&u);
		p[i]=1;
		if(u!=-1)
		{
			add(i,u);
			add(u,i);
		}	
	}
	for(int i=1;i<=n;i++)
	{
		if(v[i]==1) continue;
		e=-1;
		a1=a2=i;//赋值 
		dfs(i,-2);
		long long ans=0;
		dfs2(a1,-1);
		ans=dp[a1][0];
		dfs2(a2,-1);
		ans=max(ans,dp[a2][0]);
		if(a1==a2) ans=max(ans,dp[a1][1]);//如果没环了，那么要取当前点取的情况 
		pa+=ans;//每个连通块答案相加 
	}
	printf("%lld",pa);
	return 0;
}
```

---

## 作者：LJQ0808 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P11501)

# 题解
我们可以发现从没有被指出为不愿意的人开始，可以像拓扑排序一样，分为一层层。

例如，

```
1 -> 3
2 -> 3
3 -> 4
```

则 $1,2$ 为第 $1$ 层，$3$ 为第 $2$ 层，$4$ 为第 $3$ 层。

将奇数层的人变为参加探险的候选人，才能使参加探险的候选人最多。这是为什么呢？

不妨设，第 $i$ 层的人数为 $s_i$，一共有 $k$ 层。

因为参加探险的候选人指出一个他不愿意的人，所以贪心选 $s_1 + s_3 + s_5 + ...... + s_{n \times 2 + 1} [n \times 2 + 1 \ge k]$ 或 $s_2 + s_4 + s_6 + ...... + s_{n \times 2} [n \times 2\ge k]$。

又因为每个人都只会指出一个人，有 $s_i\ge s_{i+1} [i < k]$。 

所以，选 $s_1 + s_3 + s_5 + ...... + s_{n \times 2 + 1} [n \times 2 + 1 \ge k]$ 最优。

但有可能有环该怎么办呢？

那我们可以让环的其中一个人不派遣，就变为了上面的情况。
```
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n;
int a[N];
bool vis[N];//vis[i] 表示第 i 个节点有没有访问过。 
int ans=0;//最后的答案。 
int deg[N];//deg[i] 表示第 i 个节点的入度。 
void dfs(int u,bool c){
	if(vis[u]){//已经访问过了。 
		return;
	}
	vis[u]=1;//标记。
	if(c){
		ans++;//加答案。
	} 
	int v=a[u];
	if(--deg[v]==0 || c){//入度为 0 时，像拓扑排序扩展；c 为 1 的时候要反色。 
		dfs(v,c^1);//反色。 
	} 
}
signed main(){
	//HAPPY!
	cin.tie(0);
	cout.tie(0);
	ios_base::sync_with_stdio(0);
	//没参加探险的候选人为 0，参加探险的候选人为 1。 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(~a[i]){
			deg[a[i]]++;
		}
	}
	for(int i=1;i<=n;i++){
		if(!deg[i]){//入度为 0 时，像拓扑排序从叶子节点开始。 
			dfs(i,1);
		}
	} 
	for(int i=1;i<=n;i++){
		if(!vis[i]){//有环。 
			dfs(i,0);
		}
	} 
	cout<<ans<<"\n";
	return 0;
}
```

[二倍](https://qoj.ac/contest/2021/problem/10734)[经验](https://www.luogu.com.cn/problem/P6417)

---

## 作者：ylch (赞：0)

前言：这道题 dp 做法找环的部分还没有用拓扑做的，补充一下。

---

这道题其实很像“上司的舞会”，就是求树上最大独立集。

这里我们把每个人向他讨厌的那个人连边（发现所有点出度均为 $1$，所以这是一个基环树）然后求树上相邻两个结点不能同时选择时，最多能选多少个点。

如果是在普通的树上，设 $f[i][1/0]$ 表示结点 $i$ 选或不选的最大价值，dp 即可。

基环树相当于套了一个环，考虑把环上的每一个点都当作根，跑一遍它们子树的最大点独立集（注意不能走到环上的点），然后再用“给一个环，相邻的两个元素不选，求选得的最大总和”的 dp 模板，对“基环”上的点再跑一遍 dp 把答案整合起来即可。

因为 DAG 图具有良好的 dp 结构，找环可以用拓扑排序，先把普通的点都 dp 了，拓扑结束后入度依然不为 $0$ 的点就是环上的点。

一些实现细节见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 3e5 + 7;
const ll inf = 1e18;

int a[maxn], ind[maxn]; // ind记录入度
ll f[maxn][2]; // f[u][1/0]表示以选/不选u，其子树能得到的最大点独立集大小
bool vis[maxn]; // 记录每个点所在的连通块是否访问过

int main(){
	ios::sync_with_stdio(false); cin.tie(0);
	
	int n;
	cin >> n;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		if(a[i] != -1){
			ind[a[i]] ++;
		}
	}
	
	queue<int> q;
	for(int i = 1; i <= n; i ++){
		if(ind[i] == 0){
			q.push(i);
		}
		f[i][1] = 1; // 初始化dp
	}
	
	ll ans = 0;
	while(!q.empty()){
		int u = q.front(); q.pop();
		int v = a[u];
		if(v == -1){
			ans += max(f[u][0], f[u][1]); // 说明这个根节点不在环上，那么直接统计答案就好了
		}else{
			f[v][0] += max(f[u][0], f[u][1]); // 正常的树上最大独立集dp
			f[v][1] += f[u][0];
			ind[v] --;
			if(ind[v] == 0){
				q.push(v);
			}
		}
	}
	
	// 遍历剩下的入度不为0的结点（说明在环上）
	for(int i = 1; i <= n; i ++){
		if(ind[i] >= 1 && !vis[i]){
			vector<int> ring;
			ring.push_back(0); // 让下标从1开始
			int u = i;
			while(!vis[u]){ // 从一个点一直走，直到回到自己，就说明跑完了一整个环
				vis[u] = true;
				ring.push_back(u);
				u = a[u];
			}
			int len = ring.size() - 1;
			
			vector<vector<ll>> g(len + 1, {0, 0}); // g[i][1/0]表示结点i选/不选的最大答案（i在环上）
			// 首先钦定最后一个不选，则第一个选不选都行
			g[1][0] = f[ring[1]][0], g[1][1] = f[ring[1]][1];
			for(int j = 2; j <= len; j ++){
				g[j][0] = max(g[j - 1][0], g[j - 1][1]) + f[ring[j]][0];
				g[j][1] = g[j - 1][0] + f[ring[j]][1];
			}
			ll res1 = g[len][0];
			
			// 然后钦定第一个不选，则最后一个选不选都行
			g[1][0] = f[ring[1]][0], g[1][1] = -inf; // 初始化第一个选的收益为负无穷，相当于强制不选第一个
			for(int j = 2; j <= len; j ++){
				g[j][0] = max(g[j - 1][0], g[j - 1][1]) + f[ring[j]][0];
				g[j][1] = g[j - 1][0] + f[ring[j]][1];
			}
			ll res2 = max(g[len][0], g[len][1]);
			
			ans += max(res1, res2);
		}
	}
	
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## P11501 探险队题解

把每个人和他不喜欢的人连无向边，得到一张无向图，题目即转化为在这张图上求最大独立集。
## 对于基环树:
### 1.定义
基环树是一个由 $n$ 个点及 $n$ 条边组成的连通图，其比树多出一条边，所以称作基环树。

### 2.分类
基环树分为无向基环树和有向基环树。

此题为无向基环树

### 3.解决方式
对于有关基环树的问题，一般有两种解决方式：

#### 1.将环断开一条边，作普通树处理。
#### 2.将环上的每个节点的子树的信息合并到该节点上，最后对环进行处理



由题可知有人不讨厌别人，故建一个点 $0$ 让这些人讨厌它。选它的权值即为 0.

基环树可被认为成一个环，其中环上每一点上有一棵树。

于是对环上的每一个点取两个权值：

#### 1.取了这个点得到的权值。

#### 2.不取了这个点得到的权值。

再进行一个环上 dp 就可。

代码有很多巨佬写过了，我就不赘述了。

---


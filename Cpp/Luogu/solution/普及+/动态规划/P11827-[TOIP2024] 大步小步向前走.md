# [TOIP2024] 大步小步向前走

## 题目背景

本题的 Special Judge 由 [CuteMurasame](https://www.luogu.com.cn/user/682739) 重构，以符合 -std=c++14 标准。

## 题目描述

五条圣是电门中学的学生，他的梦想是成为职业足球选手。虽然他因为想每天练习足球而不想去上学，但为了不违反国民教育法第二章第 $3$ 条，他还是乖乖的去上学。

五条圣家到学校的路是一条直线道路，我们把五条圣家到学校的路以一条数线表示，五条圣家在坐标 $0$ 米处，学校在坐标 $e$ 米处。

五条圣通过刻苦练习，习得了 $k$ 种前进的步法，第 $j$ 种步法可以前进恰好 $s_j$ 米，他希望应用这些步法在足球比赛中。
为了多多练习这些步法，五条圣在上学路上不会用这些步法以外的方式前进。
为了避免迟到，五条圣也不会往回跳，只会笔直往学校前进。

不幸的是，这条路上有 $n$ 个坑洞，第 $i$ 个坑洞在坐标 $a_i$ 米处。
因此如果五条圣落脚在 $a_i$ 米处，则他的脚会受伤导致他不能完成他足球员的梦想，这是他一定要避免的。

给定学校坐标、坑洞位置以及五条圣练成的步法长度，五条圣想要你帮他找出最佳的迈步方式，满足下列条件：

1. 避开所有坑洞。
2. 最后恰好停在 $e$ 米处。
3. 最大步法使用的次数越多越好。
4. 若存在多种最大步法次数最多的方式，第二大的步法使用的次数越多越好。
5. 若还有多种方法，以此类推比较第三大、第四大、$\cdots$、第 $k$ 大的步法次数。

## 说明/提示

### 测试数据限制

* $2 \le e \le 3 \times 10^5$。
* $0 \le n \le e - 1$。
* $2 \le k \le e$。
* $1 \le a_i \le e - 1$。
* $1 \le s_j \le e$。
* $1 \le k\times (e - n) \le 3 \times 10^5$。
* 上述变量均为整数。
* 所有 $a_i$ 互不相同。
* 所有 $s_j$ 互不相同。

### 评分说明

本题共有一组子任务，条件限制如下所示。

每一组可有一或多组测试数据，

$$该组获得的分数 = 该组满分分数\times \min_{测试数据 \in 该组} 评分(测试数据)。$$

对一组测试数据，考虑问题描述中提到条件的符合与否：

* 如果输出的答案不符合输出格式或不符合 1., 2., 或 3. 评分为 $0$。
* 如果输出的答案符合 1., 2., 和 3. 但不符合 4. 评分为 $0.2$。
* 如果输出的答案符合 1., 2., 3., 和 4. 但不符合 5. 评分为 $0.5$。
* 如果输出的答案符合 1., 2., 3., 4. 和 5. 评分为 $1$。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $100$ | 无额外限制。 |

## 样例 #1

### 输入

```
3 2 8
1 3 4
4 2```

### 输出

```
3
2 6 8```

## 样例 #2

### 输入

```
3 2 9
3 4 1
4 2```

### 输出

```
-1```

## 样例 #3

### 输入

```
0 4 61

3 5 23 30```

### 输出

```
4
30 53 58 61```

# 题解

## 作者：zxdjmq (赞：1)

# P11827 [TOIP2024] 大步小步向前走

## 解法说明

题面看起来就像 DP，所以想一想 DP 怎么做。

转移方程是显然的，枚举每一个可走的点向前找有哪些点可以转移过来，找一下最优解。

注意到数据范围 $k \times (e-n)\leq 3\times 10^5$，这意味着我们可以用 `vector` 存储当前步法数量。同时 `vector` 又非常好的特性：我们可以用内置的比较运算符比较两个 `vector` 的字典序，完美适配该题的比较方式。

由于题目还要求我们输出方案，那么把每个点的转移来源存下来即可。

时间复杂度 $O(k^2(e-n)^2)$，但是由于比较字典序的 $O(k(e-n))$ 根本跑不满，所以跑得飞快。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
// #define int long long
// #define il inline
#define pb push_back
const int N=3e5+10,inf=1e9;

int n,m,k,a[N];
bool ok[N];
vector<int> dp[N];
int fr[N],cnt[N];

bool cmp(int x,int y){return x>y;}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr);
    cin>>m>>k>>n;
    for(int i=0;i<=n;i++)ok[i]=1,fr[i]=inf;
    for(int i=1;i<=m;i++){
        int qw;
        cin>>qw;
        ok[qw]=0;
    }
    for(int i=1;i<=k;i++){
        cin>>a[i];
    }

    sort(a+1,a+k+1,cmp);
    dp[0].resize(k+10);

    for(int i=1;i<=n;i++){
        if(!ok[i])continue;
        dp[i].resize(k+10);
        dp[i][1]=-1;
        cnt[i]=inf;
        for(int j=k;j>=1;j--){
            if(i-a[j]<0)break;
            if(!ok[i-a[j]])continue;
            dp[i-a[j]][j]++;
            if(cnt[i-a[j]]!=inf && dp[i-a[j]]>dp[i]){
                dp[i]=dp[i-a[j]];
                cnt[i]=cnt[i-a[j]]+1;
                fr[i]=i-a[j];
            }
            dp[i-a[j]][j]--;
        }
    }
    if(cnt[n]==inf){
        cout<<-1;
        return 0;
    }
    cout<<cnt[n]<<'\n';
    int ans[N],nw=n,pos=0;
    while(nw>0){
        ans[++pos]=nw;
        nw=fr[nw];
    }
    for(int i=cnt[n];i>=1;i--)cout<<ans[i]<<' ';
    return 0;
} 
```

---

## 作者：Nagato__Yuki (赞：1)

# Solution
dp 过程是好想的，从 $1$ 到 $e$ 遍历，枚举 $a_1\sim a_k$ 从 $dp_{i-a_j}$ 向 $dp_i$ 转移，至于走的步法怎么求，中间用一个 `lst` 数组记录。

但是题目要求：
> 4. 若存在多种最大步法次数最多的方式，第二大的步法使用的次数越多越好。  
> 5. 若还有多种方法，以此类推比较第三大、第四大、⋯、第 $k$ 大的步法次数。

怎么做呢？

考虑一个力大砖飞的方法：用 `set` 存下步法，每次枚举 $k$ 的时候暴力比较就行了。

可以证明这样做复杂度不会很大，因为 $k\times(e-n)\leq 3\times10^5$，设 $N=k\times(e-n),M=\min(k,e-n)$，暴力比较的复杂度为 $\mathcal O(M\log M)$，总复杂度 $\mathcal O(NM\log M)$，取 $M=\mathcal O(\sqrt N)$ 则复杂度为 $\mathcal O(N\sqrt N\log \sqrt N)$，实际上跑不满。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mxn 300010
#define pb push_back
#define I inline
#define pii pair<int,int>
#define X first
#define Y second
#define lb lower_bound
int v[mxn],a[mxn],vis[mxn];
int n,k,e,lst[mxn];
vector<int> ans;
set<pii,greater<pii>> st[mxn],tmp;
int cnt=0;
I void add(int x,set<pii,greater<pii>> &St){
    auto it=St.lb({x+1,0});
    if(it==St.end()||it->X!=x)St.emplace(x,1);
    else{
        pii A=*it;St.erase(it);
        St.emplace(x,A.Y+1);
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>k>>e;
    for(int i=1;i<=e;i++)lst[i]=-1;
    for(int i=1;i<=n;i++){int x;cin>>x;v[x]=-1;}
    for(int i=1;i<=k;i++)cin>>a[i];
    sort(a+1,a+k+1,[](int x,int y){return x>y;});
    for(int i=1;i<=e;i++){
        if(v[i]==-1)continue;
        for(int j=1;j<=k;j++){
            if(i-a[j]<0||lst[i-a[j]]==-1||v[i-a[j]]==-1)continue;
            if(lst[i]==-1)lst[i]=i-a[j],st[i]=st[i-a[j]],add(a[j],st[i]);
            else{
                tmp=st[i-a[j]],add(a[j],tmp);bool flg=0;
                auto itl=st[i].begin(),itr=tmp.begin();
                while(1){
                    if((*itl)>(*itr))break;
                    else if((*itl)<(*itr)){flg=1;break;}
                    itl++,itr++;
                    if(itr==tmp.end())break;
                    if(itl==st[i].end()){flg=1;break;}
                }
                if(flg)lst[i]=i-a[j],st[i]=tmp;
            }
        }
    }
    if(lst[e]==-1)return cout<<"-1",0;
    int p=e;
    while(p)ans.pb(p),p=lst[p];
    cout<<ans.size()<<'\n';reverse(ans.begin(),ans.end());
    for(int Ans:ans)cout<<Ans<<' ';
    return 0;
}

```

---


# [蓝桥杯 2025 省 Java B] 2 的幂

## 题目描述

小明很喜欢 $2$ 的幂，所以他想对一个长度为 $n$ 的正整数数组 $\{a_1, a_2, \dots, a_n\}$ 进行改造。他可以进行如下操作任意多次（可以是 $0$ 次）：任选一个数 $a_i$ 加上任意正整数，但不能使得加完之后的结果超过 $10^5$。

在操作任意次后，小明希望所有数的乘积是 $2^k$ 的倍数。他想知道总共需要加的数的总和至少是多少？

## 说明/提示

### 样例说明

将三个数分别加到 $24, 16, 4$，它们的乘积为 $1536 = 2^9 \times 3$，加的数的总和为 $5 + 6 + 1 = 12$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$n, k \leq 10$。
- 对于 $100\%$ 的评测用例，$1\leq n \leq 500$，$1\leq k \leq 5000$，$1\leq a_i \leq 100000$。

## 样例 #1

### 输入

```
3 9
19 10 3```

### 输出

```
12```

# 题解

## 作者：Lyrith_with_xQ (赞：6)

首先，[读题](https://www.luogu.com.cn/problem/P12160)！

形式化题意
-
给出一个长 $n$ 的数组 $a$ 和一个数 $k$，设有一个长 $n$ 的数组 $p$ 满足 $2^k\mid\prod^n_{i=1}(a_i+p_i)$ 并且 $a_i+p_i\le10^5$，求 $\sum^n_{i=1}p_i$，如果数组 $p$ 不存在，输出 $-1$。

思路
-
考虑用 dp 解题。

定义 $dp_{i,j}$ 表示使得 $2^j\mid\prod^i_{k=1}(a_k+p_k)$ 的最小 $\sum^i_{k=1}p_k$ 的值，设最小的比 $x$ 大的 $2^y$ 的倍数减去 $x$ 的值为 $f(x,y)$。

于是用瞪眼法（？）可以得出 $dp_{1,i}=f(1,i)$。

可以发现，对于 $dp_{i,j}$ 可以枚举 $a_i$ 要分担的 $2$ 的个数，设 $a_i$ 要分担 $x$ 个 $2$，则状态转移方程可以写为 $dp_{i,j}=\min_{0\le x\le j}\{dp_{i-1,j-x}+f(i,x)\}$。

可是这是三重循环，会超时，考虑优化。

可以发现，当 $x$ 过大时，因为 $a_i+p_i\le 10^5$ 的限制，$f(i,x)+dp_{i-1,j-x}$ 便不符合条件，因此只用从 $0$ 枚举到 $\min\{\lfloor\log_2(10^5)\rfloor,j\}$ 即可。

于是状态转移方程变为 $dp_{i,j}=\min_{0\le x\le \min\{\lfloor\log_2(10^5)\rfloor,j\}}\{dp_{i-1,j-x}+f(i,x)\}$。

虽然这还是三重循环，但因为 $2^x$ 增长很快，所以第三重循环的时间复杂度是常数。

接下来回头再考虑 $f(x,y)$ 如何实现。

当 $x\le 2^y$ 时，显然可得 $f(x,y)=2^y-x$。

当 $x>2^y$ 时，$f(x,y)=2^y\times\lceil\frac{x}{2^y}\rceil$。

代码
-

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k,a[505],dp[505][5005],f[505][5005];

int pow2(int a){return 1<<a;}

int find(int x,int k)//函数f(x,y) 
{
	if(k>=ceil(log2(1e5)))return 1e8;//2^k大于1e5，无解
	int r=ceil(log2(x));
	if(r<k)return pow2(k)-x;
	else
	{
		int a=ceil(1.0*x/pow2(k));
		if(pow2(k)*a>1e5)return 1e8;//答案大于1e5，无解
		return pow2(k)*a-x;
	}
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=k;j++)dp[i][j]=1e8,f[i][j]=find(a[i],j);//预处理 
	}
	for(int i=0;i<=k;i++)dp[1][i]=f[1][i];//初始状态 
	for(int i=2;i<=n;i++)//dp过程
	{
		for(int j=0;j<=k;j++)
		{
			for(int l=0;l<=min((int)floor(log2(1e5)),j);l++)dp[i][j]=min(dp[i][j],dp[i-1][j-l]+f[i][l]);
		}
	}
	printf("%d",dp[n][k]==1e8? -1:dp[n][k]);//注意无解的情况 
	return 0;//代码后加return 0;是好习惯 
} 
```
性能分析
-
时间复杂度：$O(nk)$。

空间复杂度：$O(nk)$。

可以通过本题。

---

## 作者：zyzxzhangyi (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P12160)

# 题意简述
通过最小化增加 $a$ 数组中的每个元素的值，使得它们的乘积为 $2^k$ 的倍数，增加后的数不能大于 $10^5$，若无解输出 $-1$。

# 思路

通过思考，我们很容易发现一个数为 $2^p$ 的倍数，另一个数为 $2^q$ 的倍数时，它们的乘积必定为 $2^{p+q}$ 的倍数。

因此，我们只需要保证变化后 $a$ 数组中所有数包含 $2$ 的质因数个数总和不小于 $k$ 即可。

很明显可以用DP来实现，定义 ${dp_i}_j$ 表示前 $i$ 个数的乘积为 $2^j$ 的倍数的最小增加和，枚举 $i$，$j$ 和 $l$，其中 $l$ 表示将第 $i$ 个数变为 $2^l$ 的倍数，只需枚举到 $16$ 即可，因为 $a_i$ 不会超过 $10^5$。

转移方程为：
```cpp
dp[i][j] = min(dp[i][j], dp[i - 1][j - l] + x - a[i]) 
```


其中 $x$ 表示将 $a_i$ 变为不小于 $a_i$ 的最小的 $2^l$ 的倍数，计算方式如下为：
```cpp
int(ceil(a[i] * 1.0 / (1 << l))) * (1 << l)
```

因为题目中的条件：不能使得加完之后的结果超过 $10^5$，所以还要特判 $x\le 10^5$。

最后输出 ${dp_n}_k$ 即可。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, x, a[505], dp[505][5005];

int main(){
    cin >> n >> k;
    for(int i = 1; i <= n; i++) cin >> a[i];
    memset(dp, 0x3f, sizeof(dp)), dp[0][0] = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= k; j++)
            for(int l = 0; l <= min(16, j); l++){
                x = int(ceil(a[i] * 1.0 / (1 << l))) * (1 << l);
                if(x <= 1e5) 
				    dp[i][j] = min(dp[i][j], dp[i - 1][j - l] + x - a[i]);
			}
    if(dp[n][k] == 0x3f3f3f3f) cout << -1 << endl;//不要忘记考虑-1的情况
    else cout << dp[n][k] << endl;
	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/227894184)

时间复杂度：$O(nk)$。

空间复杂度：$O(nk)$。~~当然也可以用滚动数组优化。~~

---


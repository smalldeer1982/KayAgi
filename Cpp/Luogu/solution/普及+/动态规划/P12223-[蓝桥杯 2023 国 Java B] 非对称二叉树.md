# [蓝桥杯 2023 国 Java B] 非对称二叉树

## 题目描述

小明觉得不对称的东西有着独特的美感。

对于一棵含有 $n$ 个结点的二叉树，小明规定如果对于其中任意一个结点 $i$ 都满足条件：$\max \{h_{l_i}, h_{r_i}\} \geq k \times \min \{h_{l_i}, h_{r_i}\}$ 则此二叉树为一棵非对称二叉树。其中 $l_i, r_i$ 分别为 $i$ 的左儿子和右儿子，$h_x$ 表示以 $x$ 为根的子树的高度（如果结点 $x$ 不存在则视为高度等于 $0$）。

给定 $n, k$，计算有多少棵不同的非对称二叉树。

## 说明/提示

### 样例说明

所有 $12$ 种情况如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/bvh1audb.png)

### 评测用例规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 12$。
- 对于 $100\%$ 的数据，保证 $n \leq 35$，$1 \leq k \leq n$。

## 样例 #1

### 输入

```
4 2```

### 输出

```
12```

# 题解

## 作者：Cipher0128 (赞：5)

这题还没有题解……

很容易发现是计数动态规划，考虑状态。

至少有一维是节点数，但为了满足高度限制，需多加一维，表示高度，所以有了状态 $f_{i,j}$ 表示 $i$ 个点高度为 $j$ 的方案数。

枚举子树根节点状态与其左右子状态，进行转移。

$f_{y,h}=\sum f_{y_1,h_1}\times f_{y_2,h_2}$ 


初始化 $f_{0,0}=1$。

答案即为 $\sum_{h=1}^nf_{n,h}$。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define for_(a,b,c) for(int a=b;a<=c;++a)
#define For_(a,b,c) for(int a=b;a>=c;--a)
using namespace std;
int n,k;
const int N=40;
ll f[N][N];
int main(){
	cin>>n>>k;
	f[0][0]=1;
	for_(cnt,0,n){
		for_(cntl,0,n){
		int cntr=cnt-1-cntl;
		if(cntr<0)continue;
			for_(hl,0,cntl){
				for_(hr,0,cntr){
					int h=max(hl,hr)+1;
					if(h>cnt)continue;
					if(max(hl,hr)>=k*min(hl,hr)){
						f[cnt][h]+=f[cntl][hl]*f[cntr][hr];
					}
				}
			}
		}
	}
	
	ll ans=0;
	for_(i,0,n)ans+=f[n][i];
	cout<<ans;
    
	return 0;
}
```

---

## 作者：cwd2023 (赞：0)

# P12223题解
**by cwd2023**

---

## 思路：
首先，根据 $n$ 的范围，猜出复杂度大概是 $n^4$ 级别，有根据题意~~和标签~~看出是一道动态规划。

### 设计状态：
首先，肯定要有子树大小，深度，因为它们分别与答案和判断条件有关。所以设 $f_{i,j}$ 表示有子树（或者就是整棵树）大小是 $i$ 深度是 $j$，然后分别考虑左右子树。

因为我们已经要枚举 $i$ 了，所以只需要枚举一个子树的大小（以左为例，~~但不代表我左~~）$l$ 就可以推出另一子树的大小是 $i-l-1$，记得减去根节点大小。

根据树的定义，一颗树的最大深度就是节点数（一个个数着连接）所以我们在枚举左右子树的大小 $lh,rh$，顺带推出 $j=lh+rh+1$，还是要记得加上根节点。

因为左右子树互不干涉，所以它们的答案之间是乘的关系。但最后统计时枚举根节点深度，答案相加。

---

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,k,ans;
ll f[1010][1010];
int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    cin>>n>>k;
    /*
    f[i][j]表示子树有i个节点，高度为j的答案
    f[l+r][max(lh,rh)+1] <- f[l][lh]*f[r][rh](max(lj,rh)>=k*min(lh,rh));
    */
    f[0][0]=1;
    for(ll i=1;i<=n;i++){//一共多少点
        for(ll j=0;j<i;j++){//左子树有多少个点
            ll l=j,r=i-j-1;//右子树数量要减去根节点
            for(ll lh=0;lh<=l;lh++){//高度最大是节点数（竖着一个个链接）
                for(ll rh=0;rh<=r;rh++){
                    if(max(lh,rh)>=k*min(lh,rh))f[i][max(lh,rh)+1]+=f[l][lh]*f[r][rh];
                }
            }
        }
    }
    for(ll i=0;i<=n;i++)ans+=f[n][i];
    cout<<ans<<"\n";
    return 0;
}
```
最后，希望本篇题解对你有所帮助，感谢观看。

---


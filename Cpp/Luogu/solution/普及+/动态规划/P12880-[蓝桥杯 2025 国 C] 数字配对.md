# [蓝桥杯 2025 国 C] 数字配对

## 题目描述

小蓝有一个长度为 $n$ 的正整数数组 $A = [a_1, a_2, \cdots, a_n]$，每当他从中拿出一对数 $(a_i, a_j)$，其中 $i < j$，他会得到它们的差 $b = a_j - a_i$。然而，他特别喜欢整数 $1$，所以他想知道在数组 $A$ 中最多同时能取出多少对正整数 $(a_i, a_j)$，每个数最多被取一次，使得它们的差为 $1$。

## 说明/提示

**【样例说明】**

其中一种方案：$(a_1, a_3), (a_4, a_6)$。

提示：$(a_1, a_2)$ 的差为 $a_2 - a_1 = -1$，不是小蓝喜欢的。

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$1 \leq n \leq 10^3$，$1 \leq a_i \leq 10^3$；

对于所有评测用例，$1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
6
2 1 3 6 4 7```

### 输出

```
2```

# 题解

## 作者：RH233 (赞：5)

## P12880 [蓝桥杯 2025 国 C] 数字配对 题解
### [题目传送门](https://www.luogu.com.cn/problem/P12880)
### 题意
考虑贪心做法（其实这个做法类似于双指针）。

在一个长度为 $n$ 的无序数列中，找到最多的 $(a_i,a_j)$，使得 $i<j$ 且 $a_i-a_j=1$，同时每个数最多取一次。
### 思路
要选取最多的 $(a_i,a_j)$，应该按照数值大小从小到大，顺序从后往前的方法循环，对于每一个还没有配对的数字，使其与最靠后的且差为 $1$ 的数字匹配，如果可能。

时间复杂度为 $O(n)$。理论上不会超时。
### 做法
维护一位数组 $a$ 用来记录数字数值，二维动态数组 $v$ 记录每个数字在数组中出现的位置。然后从 $1$ 到 $1\times10^6$ 循环枚举判断。
### 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=1919810,M=0721;
ll n,a[N],ans;
vector<ll> v[N];
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
		v[a[i]].push_back(i); //输入的时候顺便把v给处理了 
	} 
	for(ll t=1;t<=1000000;t++){ //循环枚举 
		if(v[t+1].empty()||v[t].empty()) continue; //这个数字不存在或是与这个数字差为1的不存在 
		for(ll i=v[t].size()-1;i>=0;i--){
			if(!v[t+1].size()) break; //删完了防止越界 
			ll p=v[t+1].size()-1; //差为一的数字 
			if(v[t+1][p]>v[t][i]){
				ans++; //答案++ 
				v[t][i]=0; //这里不能直接删，因为可能删错数字 
				v[t+1].pop_back(); //这个可以删 
			}
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```

### [AC](https://www.luogu.com.cn/record/221066906)

---

## 作者：Sunrise_up (赞：4)

这道题我们马上想到一个思路：每枚举到一个数，找前面的没用过的数就行了。

发现 $a_i$ 值域较小，我们可以桶来实现。

具体的，每当枚举到 $a_i$ 时，找到前面没用过的一整数 $a_j$，使得 $a_i-a_j=1$ 即可。但是我们又不是真的需要这个数的位置，只需使用桶记录剩余的没用过的整数即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
int x[1000001],n,a,ans;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		(x[a-1]?x[a-1]--,ans++:x[a]++);
	}
	cout<<ans;
    return 0;
}
```

然后你会发现这个东西只得了 $40$ 分，那是为什么呢？

我们来看这个数据：

```
5
1 4 2 3 2
```

如果这样直接按顺序，较小的 $2$ 会跟 $1$ 配对，这样 $3$ 跟这个 $2$ 就配对不了了。

所以我们得记录下一个数所有的下标，可以使用 `vector` 实现。那么，枚举数字 $v$，找到看看 $v$ 可用的最后一个下标是否可以跟 $v+1$ 可用的最后一个下标构成序列。这样就可以了。


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> pos[1000001];
int n,a,ans=0,maxn;
unordered_map<int,int> s;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a;
    	maxn=max(maxn,a);
    	pos[a].push_back(i);
    	s[a]++;
	}
    for(int v=1;v<=maxn-1;v++){
        if(!s[v]||!s[v+1])continue;
        while(s[v]>=1&&s[v+1]>=1){
            if(pos[v][s[v]-1]<pos[v+1][s[v+1]-1])ans++,s[v]--,s[v+1]--;
            else s[v]--;
        }
    }
    cout<<ans;
    return 0;
}
```


求点赞 qwq！

---

## 作者：SudoXue (赞：3)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18936573)

这题真不是黄题吧。

题目要求在序列 $A=\{a_1,a_2,\dots,a_n\}$ 中选出尽量多的下标对 $(i,j)$ 使得 $i<j$ 且 $a_j-a_i=1$，每个元素只能使用一次。

显然，难点在于既要满足数值差为 $1$，又要保证下标严格递增。将同值元素的下标按升序集中存放，记第 $v$ 值的下标序列为 $P_v$。对相邻两值 $v$ 与 $v+1$ 分别维护指针指向当前最右侧尚未配对的下标。始终比较 $P_v$ 与 $P_{v+1}$ 的末尾元素：若 $P_v$ 的下标仍然小于 $P_{v+1}$ 的下标，就立即将这二者配成一对并同时左移两个指针；否则只能左移 $P_v$ 的指针。

这样做相当于在两条升序链上求“最长不交叉匹配”（就是求在不允许线段交叉的前提下能画出的线段最多是多少），可用交换论证证明最优：倘若最优方案中存在交叉形如 $(p,q)$、$(p',q')$ 且 $p<p'<q<q'$，交换得到 $(p,q')$、$(p',q)$ 亦合法且不减答案，因而所有交叉都可消解到该贪心结构。

实现的具体流程可以这样理解：先整遍扫描原序列，把每个元素的下标依出现先后写入数组，同时用一个计数表记录每个值出现了多少次。扫描完毕后，对这张计数表做前缀和，就能算出每个值在数组中的起始坐标，于是同值元素的下标会自然排成一段连续区间，相当于给每个数字建了一个紧凑的下标桶。配对阶段，我们只在这些区间里顺着指针向左移动；每个指针只会离开当前位置一次，所以整体移动次数不超过 $n$。

时间复杂度 $O(n+\max a_i)$。

[link](https://www.luogu.com.cn/record/220865757)

---

## 作者：Pratty (赞：2)

题目内容很少，很容易理解，下面主要说思维难度。

首先这是一道下位绿，或者上位黄。这种题容易在贪心和 $dp$ 里面徘徊不定。但是仔细一想思路，你就发现这个贪心没有假，那么直接写就可以了。

#### 思路

首先很容易想到，因为 $a_i$ 最大只有 $10^6$，所以我们可以对每一个值的 $a_i$ 保存 $i$ 的下标，这个操作可以用滚动数组记录。然后在每一次下标的时候，计算当前值 $i$ 和上一个值 $i-1$ 能组成的答案数量，累加即可。

我们假设当前值 $i-1$ 中的下标为 $q\sim p$，$i$ 中的下标为 $n\sim m$（$q\le p$，$n\le m$）。

考虑如何匹配。

很明显我们一定会选择一个最边上的位置进行匹配，即 $q,p$ 中的一个匹配 $n,m$ 中的一个，否则一定会对边上的值有浪费。

假设我们用 $q$ 和 $n$ 进行匹配（这也是最容易踏入的误区），那么我们发现，对于以下数据：
```
4
2 3 4 3
```
我们会选择让第一个位置的 $2$ 和第二个位置的 $3$ 匹配。但事实证明，让第一个位置的 $2$ 和最后一个位置的 $3$ 匹配会更优。故此假设不成立，不能用 $n$ 进行匹配，因为可能会漏掉 $i+1$ 的值和 $i$ 匹配的可能性，故只能用 $m$ 进行匹配。

假设我们用 $q$ 和 $m$ 进行匹配（这里基本没有人犯），那么我们发现，对于以下数据：
```
4
2 3 2 3
```
我们会让第一个位置的 $2$ 和第四个位置的 $3$ 进行匹配，所以会输出 $1$。但不难发现，正确答案是 $2$，故假设不成立。

故用 $p$ 和 $m$ 进行匹配，每次找当前值 $i$ 和上一个值 $i-1$，下标从大到小开始匹配，直到有一方的下标降为 $0$。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1100000;
int n, a[N], ans;
vector<int> mp[N];
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		mp[a[i]].push_back(i);
	}
	for (int i = 1; i <= 1e6; i++) {
		if (mp[i - 1].size() == 0 || mp[i].size() == 0) continue;
		for (int j = mp[i - 1].size() - 1; j >= 0; j--) { 
			if (mp[i - 1][j] == 0) continue;
			if (mp[i - 1][j] < mp[i][mp[i].size() - 1]) {
				mp[i - 1][j] = 0;
				mp[i].pop_back();
				ans++;
			}
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Rain_Mountain (赞：1)

## 思路
看到这道题首先想到的思路：对于每个 $a_i$，找到后面第一个没用过的 $a_i + 1$。

Nevertheless，这样只能得 40pts。

hack:
```
5
1 4 2 3 2
```
显然，答案是 2 对，分别为 $(1,2)$ 和 $(2,3)$。  
但按照刚才的思路，$1$ 会与第一个 $2$ 配对，这样 $2$ 和 $3$ 就无法配对了。

  考虑对于 $A$ 中的一个 $x$：
* $x$ 与 $x+1$ 配对时，若有 $n$ 个 $x+1$，如下：  
  `... x ... x+1(1) ... x+1(2) ... x+1(n) ...`  
  $\because x+1(n)$ 到末尾的距离 $< x+1(n-1)$ 到末尾的距离 $ < \cdots < x+1(1)$ 到末尾的距离。  
  $\therefore P(x+1(n) $ 与 $x+2$ 配对的概率$) < P(x+1(n-1) $ 与 $x+2$ 配对的概率$) < \cdots < P(x+1(1) $ 与 $x+2$ 配对的概率$)$。  
  $\therefore$ 当 $x$ 与最后一个 $x+1$ 配对时，能最大概率地使其他的 $x+1$ 与 $x+2$ 配对。
* $x$ 与 $x-1$ 配对时同理，当 $x$ 与最后一个 $x-1$ 配对时，$x-2$ 与 $x-1$ 配对的概率最大。
  
  综上，**当每次取的 $x$ 和 $x+1$ 都是同等数值中下标最靠后的数时，答案最优**。

---
## $\textit{\textbf Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a, s[1000005];
vector<int> v[1000005];

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n;
    int x = 1e6 + 5, maxx = 0;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a;
        v[a].push_back(i);
        ++s[a];
        x = min(x, a);
        maxx = max(maxx, a);
    }
    int ans = 0;
    while (x < maxx)
    {
        while (s[x] && s[x + 1])
        {
            if (v[x][s[x] - 1] > v[x + 1][s[x + 1] - 1]) --s[x];
            else
            {
                --s[x]; --s[x + 1];
                ++ans;
            }
        }
        ++x;
    }
    cout << ans;
    return 0;
}
```
求赞！ qwq。

---

## 作者：YBa2Cu3O7 (赞：1)

贪心双指针

## 思路
数据范围只有 $10^6$ 因此可以直接开一个集合数组 `set<int>[]` 来存储每个出现数字的不同下标。读入后正向遍历整个数组，如果当前值 $v$ 和下一个值 $v+1$ 对应的下标集合均不为空集，那么有可能产生配对。

我们应该尽量让 $v$ 中的下标去和 $v+1$ 中更大的下标配对，这样更有可能让 $v+1$ 中较小的下标去和 $v+2$ 中的下标配对，而不是简单地让两者从小到大遍历。关于这个问题的 hack 数据为

```markdown
5
1 4 2 3 2
```
正确答案为 $2$，直接顺序贪心得到 $1$。

但是不能正序遍历 $v$ 的下标，倒序遍历 $v+1$ 的下标，这是因为有可能错过许多配对。关于这一方面的 hack 数据为

```markdown
6
5 6 6 5 7 6
```
正确答案为 $3$，错误贪心的结果为 $2$。

正确的贪心方式是，对值为 $v$ 和 $v+1$ 的下标集合均倒序遍历，找到配对即删去。要注意这里的遍历同样需要贪心，双指针遍历而不是 $O(m^2)$ 的暴力。对于 $v$ 中的下标，能够找到 $v+1$ 中的配对则将配对的下标删去，两个指针向前移动，否则仅向前移动 $v$ 的指针。关于这一方面的 hack 数据为 $10^6$ 规模的数据，其中前一半是 $2$，后一半是 $1$，正确答案是 $0$，不使用双指针会跑满 $O(n^2)$。

此外，也可以反向遍历整个集合数组，正向双指针两个集合。

如果还有 hack 请评论指出。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr size_t N = 1e6+7;
set<int> cnt[N];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    int ans=0;
    for(int i=0;i<n;++i){
        int u;
        cin>>u;
        cnt[u].insert(i);
    }

    auto stdel=[](set<int>& st, set<int>::reverse_iterator& q){
        auto it = std::prev(q.base());
        auto ret = st.erase(it);
        q = std::make_reverse_iterator(ret);
    };
    
    for (int i = 0; i < N - 2; ++i) {
    	if (cnt[i].size() != 0 && cnt[i + 1].size() != 0) {
            const auto& cp=cnt[i];
            auto& cq=cnt[i+1];
            auto p=cp.rbegin();
            auto q=cq.rbegin();
            while(p!=cp.rend()&&q!=cq.rend()){
                if(*p<*q){
                    ++ans;
                    stdel(cq,q);
                    ++p;
                }
                else{
                    ++p;
                }
            }
    	}
    }
    
    cout<<ans;
    return 0;
}
```

---

## 作者：zyxjeek (赞：0)

## 题意简述

给定 $n$ 个正整数 $a_1,\dots,a_n$，满足 $1 \le n, a_i \le 10^6$。求满足 $i < j$ 且 $a_i+1=a_j$ 的 $(i, j)$ 个数，且不能重复使用。

## 思路

拿到题第一时间可能会想到枚举每个数，只要前面有对应的数就直接匹配。比如：

```cpp
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    if (cnt[a[i]-1])
        cnt[a[i]-1]--, ans++;
    else
        cnt[a[i]]++;
}
```

但这样是错误的。当输入为 `4 2 3 4 3` 时，$a_1$ 与 $a_4$ 配对，$a_2$ 与 $a_3$ 配对，答案为 $2$，而程序输出为 $1$。我们发现，按原序列枚举的弊端是在我们处理一个数时，不知道后面还有没有相同的数。同时，$a_i$ 与 $n$ 同阶启发我们改变贪心策略，枚举每一个具体数值。

对每个数 $a_i$，开一个 `vector` 记录它在原序列中出现的每个位置。对于相邻的两个 `vector`，使用双指针统计答案，**每个位置都尽量和最靠后的位置匹配**。这样这道题就做完了。

感性证明：假设 $a_i=x, a_j=a_k=x+1$，$i<j<k$。如果我们将 $a_i$ 与 $a_j$ 匹配，若存在 $l$ 满足 $j<l<k, a_l = x+2$，我们就损失了一组匹配。所以找位置靠后的匹配一定不劣。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1e6+5;
vector<int> cnt[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n, mx = 0, ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        cnt[x].push_back(i);
        mx = max(mx, x);
    }
    n = mx;
    for (int i = 2; i <= n; i++) {
        int j = cnt[i-1].size()-1, k = cnt[i].size()-1;
        while (j >= 0 && k >= 0) {
            while (j > 0 && cnt[i-1][j] > cnt[i][k])
                j--;
            if (cnt[i-1][j] > cnt[i][k]) break; // 此时cnt[i-1]枚举完了
            while (k > 0 && j > 0 && cnt[i-1][j] < cnt[i][k])
                ans++, k--, j--, cnt[i].pop_back(); // 删除对应位置，避免下次循环重复计算
            if (cnt[i-1][j] < cnt[i][k]) { // 此时cnt[i]枚举完了
                ans++, cnt[i].pop_back();
                break;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Charles_with_wkc (赞：0)

# 前言
第一眼是**贪心**吧，老师表示这是**双指针**。
# 思路
首先，咱们不能排序，然后他让我们求当 $i<j$ 且 $a_j-a_i=1$ 且每个数字限用**一次**。  
要求最多的 $(a_i,a_j)$，我们考虑可以想见他们按数字分类存起来，对于每一个还没有配对的数字，使其与最靠后的且差为 $1$ 的数字匹配。  
显然需要枚举一下 $a_i$，同时满足题意，所以 $a_j=a_i+1$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N=1e6+5;
int n,a[N],ans;
vector<int>v[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		v[a[i]].push_back(i);
	} 
	for(int t=1;t<=1e6;t++){ 
		if(v[t+1].empty()||v[t].empty()) continue;
		for(int i=v[t].size()-1;i>=0;i--){
			if(v[t+1].empty()) break;
			if(v[t+1][v[t+1].size()-1]>v[t][i]){
				ans++; 
				v[t].pop_back();
				v[t+1].pop_back();
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---


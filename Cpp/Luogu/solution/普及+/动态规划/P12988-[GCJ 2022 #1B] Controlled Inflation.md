# [GCJ 2022 #1B] Controlled Inflation

## 题目描述

你所在的加油站充气泵前的队伍越来越长了！你希望优化流程，帮助顾客更快速地给轮胎、运动球、巨型气球动物等产品充气。

充气泵是自动的：你可以将目标气压设置为特定的帕斯卡数值，将泵连接到充气产品上，它就会按需充气到该精确气压。泵上只有两个按钮：**上**和**下**。它们分别将目标气压精确地增加或减少 $1$ 帕斯卡。

![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)

共有 $\mathbf{N}$ 位顾客排队，每位顾客携带恰好 $\mathbf{P}$ 个需要充气的产品。你知道每个产品的目标气压。你可以按任意顺序处理每位顾客的产品，但**不能**改变顾客的顺序。具体来说，你必须处理完第 $i$ 位顾客的所有产品后，才能开始处理第 $(i+1)$ 位顾客的产品。在处理两个产品之间，如果它们的目标气压不同，你需要使用泵上的按钮调整气压。

充气泵初始气压为 0 帕斯卡，处理完所有顾客的所有产品后可以停留在任意气压值。如果你能优化每位顾客的产品处理顺序，最少需要按下多少次按钮？


## 说明/提示

**样例解释**

在样例 #1 中，一种最优的充气方式是：

1. 按 **上** 按钮 10 次，将气压设为 10；为顾客 1 的气压需求为 10 的产品充气，
2. 按 **上** 按钮 30 次，将气压设为 40；为顾客 1 的气压需求为 40 的产品充气，
3. 按 **下** 按钮 10 次，将气压设为 30；为顾客 1 的气压需求为 30 的产品充气，
4. 按 **下** 按钮 10 次，将气压设为 20；为顾客 2 的气压需求为 20 的产品充气，
5. 按 **上** 按钮 30 次，将气压设为 50；为顾客 2 的气压需求为 50 的产品充气，
6. 按 **上** 按钮 10 次，将气压设为 60；为顾客 2 和顾客 3 的气压需求为 60 的三个产品充气，
7. 最后按 **下** 按钮 10 次，将气压设为 50；为顾客 3 的气压需求为 50 的产品充气。

总计需要 110 次按钮按压。

在样例 #2 中，请注意答案可能超过 $2^{32}$。

**数据范围**

- $1 \leq \mathbf{T} \leq 100$。
- $1 \leq \mathbf{X}_{\mathbf{i}, \mathbf{j}} \leq 10^9$（对所有 $i, j$ 成立）。

**测试集 1（14 分，可见判定）**

- $2 \leq \mathbf{N} \leq 10$。
- $2 \leq \mathbf{P} \leq 3$。

**测试集 2（21 分，隐藏判定）**

- $2 \leq \mathbf{N} \leq 1000$。
- $2 \leq \mathbf{P} \leq 100$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
3 3
30 10 40
20 50 60
60 60 50
5 2
1 1000000000
500000000 1000000000
1 1000000000
500000000 1
1 1000000000```

### 输出

```
Case #1: 110
Case #2: 4999999996```

# 题解

## 作者：lailai0916 (赞：2)

## 原题链接

- [洛谷 P12988 [GCJ 2022 #1B] Controlled Inflation](https://www.luogu.com.cn/problem/P12988)

## 题意简述

你需要控制充气泵的气压，依次为 $n$ 位顾客的产品充气，每位顾客有 $p$ 个产品，目标是最小化按钮按压次数。

泵的初始气压为 $0$，每次可调整 $\pm 1$，每位顾客内部的产品顺序可自由选择，但顾客的整体顺序不能改变。

## 解题思路

### 顾客优化

设第 $i$ 位顾客的产品最大气压为 $a_i$，最小气压为 $b_i$。

显然，无论以什么顺序处理，气压一定需要覆盖 $a_i$ 和 $b_i$ 这两个极值，其余产品的气压都会被经过。

因此，只需要考虑最大和最小两个极值。

### 状态设计

对于每位顾客的极值气压，有两种方案：$a_i\to b_i$ 和 $b_i\to a_i$。

这两种方案的内部代价都是 $a_i-b_i$，区别仅在于进入和离开时的位置。

设前 $i$ 位顾客处理完后，停在 $b_i$ 的最小代价为 $f_{i,0}$，停在 $a_i$ 的最小代价为 $f_{i,1}$。

### 状态转移

若停留在 $b_i$，先从上一位顾客的终态到达 $a_i$，再内部降到 $b_i$：

$$
f_{i,0}=a_i-b_i+\min\left(f_{i-1,0}+|b_{i-1}-a_i|,f_{i-1,1}+|a_{i-1}-a_i|\right)
$$

若停留在 $a_i$，先到 $b_i$，再升到 $a_i$：

$$
f_{i,1}=a_i-b_i+\min\left(f_{i-1,0}+|b_{i-1}-b_i|,f_{i-1,1}+|a_{i-1}-b_i|\right)
$$

特别地，对于第一位顾客，可以令：

$$
f_{1,0}=f_{1,1}=a_0=b_0=0
$$

最终答案为最后一位顾客的两种方案的最小值，即：

$$
\min(f_{n,0},f_{n,1})
$$

### 滚动数组

由于状态仅与上一位顾客相关，可使用滚动数组优化，将空间复杂度降至 $O(1)$。

## 参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll=long long;
const int inf=0x3f3f3f3f;
ll f[2][2];
int mx[2],mn[2];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin>>T;
    for(int $=1;$<=T;$++)
    {
    	int n,p;
    	cin>>n>>p;
    	f[0][0]=f[0][1]=mx[0]=mn[0]=0;
    	for(int i=1;i<=n;i++)
    	{
    		mx[i&1]=0;mn[i&1]=inf;
    		for(int j=1;j<=p;j++)
    		{
    			int x;
    			cin>>x;
    			mx[i&1]=max(mx[i&1],x);
    			mn[i&1]=min(mn[i&1],x);
    		}
    		f[i&1][0]=mx[i&1]-mn[i&1]+min(
    			f[i&1^1][0]+abs(mn[i&1^1]-mx[i&1]),
    			f[i&1^1][1]+abs(mx[i&1^1]-mx[i&1])
    		);
			f[i&1][1]=mx[i&1]-mn[i&1]+min(
				f[i&1^1][0]+abs(mn[i&1^1]-mn[i&1]),
				f[i&1^1][1]+abs(mx[i&1^1]-mn[i&1])
			);
    	}
    	cout<<"Case #"<<$<<": "<<min(f[n&1][0],f[n&1][1])<<'\n';
    }
    return 0;
}
```

---


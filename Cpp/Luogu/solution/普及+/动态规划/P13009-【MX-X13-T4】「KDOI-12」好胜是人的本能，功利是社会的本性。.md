# 【MX-X13-T4】「KDOI-12」好胜是人的本能，功利是社会的本性。

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a_1, \ldots, a_n$ 以及一个正整数 $m$ 满足 $m \ge \max a_i$。

你可以对序列进行任意次操作（也可以不操作）。每次操作你可以选择一个区间 $[l,r]$，然后对于所有 $l\leq i\leq r$，令 $a_i\gets\bigl\lfloor\frac{m}{a_i}\bigr\rfloor$。

求可以得到的 $\sum_{j=1}^na_j$ 的最大值以及对应的最少操作次数。

## 说明/提示

**【样例解释】**

对于样例的第二组测试数据：选择以下 $3$ 组 $[l,r]$ 即可得到最大值 $28$：

* $[1,2]$；
* $[2,5]$；
* $[4,5]$。

可以证明该方案是最优的之一。

**【数据范围】**

**本题使用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $\sum n\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $9$ | $4$ | $400$ | 无 |
| $2$ | $27$ | $10^3$ | $10^4$ | 无 |
| $3$ | $11$ | $10^5$ | $10^6$ | A |
| $4$ | $16$ | $10^5$ | $10^6$ | B |
| $5$ | $37$ | $10^5$ | $10^6$ | 无 |

* 特殊性质 A：$a_i\leq\sqrt m$；
* 特殊性质 B：$a_i\mid m$。

对于所有数据：$1\leq T\leq 10^5$，$1\leq n\leq 10^5$，$1\leq\sum n\leq10^6$，$1\leq a_i\leq m\leq10^{12}$。

## 样例 #1

### 输入

```
3
2 5
1 2
5 10
1 5 2 4 3
10 10
1 4 2 5 1 6 2 7 1 10```

### 输出

```
7 1
28 3
80 5```

# 题解

## 作者：Lovely_Rabbit (赞：4)

多测不清真糖吧。

---

首先这个向下取整手玩一下发现除超过 $2$ 次就一定进循环。

那么就只需要考虑三种情况的取值，取最大第一问就解决了。

接下来第二问。

做过积木大赛的同学看了以后觉得很熟悉，于是贪心上去挂爆了。

事实上修改次数不会影响大小时多修改几次可能会有利于操作减少，所以贪心炸了。

考虑 dp，设 $dp_{i,j}$ 表示第 $i$ 个数取 $j$ 时最小的操作次数。

转移从上一个的三种情况模拟下来取最小就行。

注意判合法与多测清空。

那么做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];
int dp[100005][4];
int ans,ret;
void solve(){
    ans=ret=0;
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        a[i]=0;
        int x;
        cin>>x;
        int A=x;
        int B=m/A;
        int C=m/B;
        // cout<<A<<' '<<B<<' '<<C<<' ';
        ans+=max({A,B,C});
        if(A>=B&&A>=C)a[i]+=1;
        if(B>=A&&B>=C)a[i]+=2;
        if(C>=A&&C>=B)a[i]+=4;
        // cout<<' '<<a[i]<<'\n';
    }
    dp[0][1]=dp[0][2]=1e9;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=2;j++){
            if(a[i]&(1<<j))dp[i][j]=min({dp[i-1][0]+max(0ll,j-0),dp[i-1][1]+max(0ll,j-1),dp[i-1][2]+max(0ll,j-2)});
            else dp[i][j]=1e9;
            // cout<<dp[i][j]<<' ';
        }//cout<<'\n';
    }
    cout<<ans<<' ';
    cout<<min({dp[n][0],dp[n][1],dp[n][2]})<<'\n';
}
signed main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：z_yq (赞：2)

# 前言
其实说实话这个题目个人感觉比第三题更简单，赛时切了但是 T3 没过。\
相较于别的题目这种题目更加注重于套路而不是思维了，所以比较简单。
# 做法
我们的做法分为两个部分。\
首先第一个部分我们将会转化这个题目，我们可以将这个问题拆分成两个问题，发现他要求先求 $\sum_{i=1}^n a_i$ 的值，所以我们先处理这个部分。\
那么，我们发现对于如果让总和最大，每个 $a_i$ 也就要有最大值，手玩发现基本上所有 $a_i$ 都会在经过不超过 $6$ 次就能达到最大值，经过 $4$ 次之后也必然进入一个循环，在经过使用代码验证后，我也更加确信了这个猜想，虽然我没法证明，~~但是信息学不需要证明~~。所以我们每个位置的操作数量为**可以满足让 $a_i$ 变为最大值的操作次数**。\
接下来我们处理第二个部分，如何使他区间加的次数更加少，这个是一个初级板子题，如果有一个数组，每一次可以让一个区间减一，那么你必然操作 $a_1 + \sum_{i=2}^n {(a_i-a_{i-1})}$ 次。\
所以我们只需要找出这个数组就行了，但是发现**并不是只要每一个点操作最少次数就能达到总的最少次数**，我也卡在了这里一会。\
然后先稍稍总结一下，问题变成了**每一个位置有 $6$ 个以内的可填值，你需要每个位置填上一个数字，使得 $a_1 + \sum_{i=2}^n {(a_i-a_{i-1})}$ 最小**。想到这里，基本上就结束了，因为剩下的部分就是暴力 DP，发现位置数量特别少，每个位置的最小值只跟上一个的值有关系，所以不难想到，定义 $dp_{i,j}$ 为第 $i$ 个点选择第 $j$ 个数字，前 $i$ 个的最小值为多少，设 $e_{i,j}$ 表示第 $i$ 个位置从小到大第 $j$ 个能填的值，那么 $dp_{i,j}=\min_{k=1}^{6}{(dp_{i-1,k}+|e_{i,j}-e_{i-1,k}|)} $，剩下的暴力转移即可。\
基本上就结束了，剩下的可以顺着代码理解。
# 代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<climits>
#include<vector>
#include<cmath>
#define ll long long

using namespace std;
const int N=1e6+9,INF=6e6+9;
ll n,a[N],m,dp[N][11];
vector<int>e[N];

inline void solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=0;i<=n;i++){
		e[i].clear();
		if(i==0) continue;
		for(int j=0;j<=10;j++)
			dp[i][j]=INF;
	}
	ll mx=0,ans=0;
	for(int i=1;i<=n;i++){
		ll maxx=INT_MIN,now=a[i];
		for(int j=0;j<=10;j++)
			maxx=max(maxx,now),now=m/now;
		now=a[i];
		for(int j=0;j<=10;j++){
			if(now==maxx)
				e[i].push_back(j);
			now=m/now;
		}
		mx+=maxx;
	}
	e[0].push_back(0);
	ll mn=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<e[i].size();j++){
			for(int k=0;k<e[i-1].size();k++)
				dp[i][j]=min(dp[i][j],dp[i-1][k]+max(0,e[i][j]-e[i-1][k]));
		}
	for(int i=0;i<e[n].size();i++)
		if(dp[n][i]<dp[n][mn])
			mn=i;
	cout<<mx<<' '<<dp[n][mn]<<endl;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int T;
	cin>>T;
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：CQ_Bab (赞：2)

# 思路
首先我们可以发现对于一个数 $x$ 在进行最多 $2$ 次操作之后一定会出现重复，也就是第 $1$ 次操作的值一定等于第 $3$ 次操作之后的值，考虑证明，我们假设此数为 $x$ 那么在进行完第一次操作之后设 $y=\lfloor m\div x\rfloor$ 然后我们考虑整数分块，我们假设 $m\div k=y$ 时的 $k$ 的取值范围为 $l\sim r$ 然后我们的发现 $l\leq x\leq r$，然后对于第二次操作的值一定是 $r$ 所以对于第三次的值就又是 $y$ 了，所以证毕。

然后我们就可以把每个 $i$ 上能取的值 $j$ 给算出来，然后考虑 dp，我们设 $f_{i,j}$ 表示第 $i$ 个选 $j$ 把 $1\sim i$ 消完的最小代价，那么我们的转移就是 $f_{i,j}=\min(f_{i-1,k}+\max(0,j-k))$，答案也很简单就是 $\min(f_{n,1},f_{n,0},f_{n,2})$。
# 代码
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define int long long
#define fire signed
#define il inline
template<class T> il void print(T x) {
	if(x<0) printf("-"),x=-x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<class T> il void in(T &x) {
    x = 0; char ch = getchar();
    int f = 1;
    while (ch < '0' || ch > '9') {if(ch=='-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
    x *= f;
}
int T=1;
int n,m;
const int N=1e5+10;
int a[N];
int f[N][3],vis[N][3];
void solve() {
	in(n),in(m);
	int s=0,res=0;
	rep(i,1,n) rep(j,0,2) vis[i][j]=false;
	rep(i,1,n) {
		in(a[i]);
		int x0=a[i],x1=m/x0,x2=m/x1;
		int dis=max({x0,x1,x2});
		s+=dis;
		if(dis==x0) vis[i][0]=1;
		if(dis==x1) vis[i][1]=1;
		if(dis==x2) vis[i][2]=1;
	}
	int cnt=0;
	rep(i,0,n) rep(j,0,2) f[i][j]=1e18;
	f[0][0]=0;
	rep(i,1,n) {
		rep(k,0,2) if(vis[i][k]) rep(j,0,2) f[i][k]=min(f[i][k],f[i-1][j]+max((int)0,k-j));
	}
	printf("%lld %lld\n",s,min({f[n][0],f[n][1],f[n][2]}));
}
fire main() {
	in(T);
	while(T--) {
		solve();
	}
	return false;
}
```

---

## 作者：CommandSR (赞：1)

## 题意

[link](https://www.luogu.com.cn/problem/P13009)

## 题解

手玩样例不难发现一个数变为可能达到的最大最多进行 $2$ 次操作。

如果一个数处于 $a_i$ 和 $\bigl\lfloor\frac{m}{a_i}\bigr\rfloor$ 循环内，$0$ 或 $1$ 次操作即可，否则先一次操作让它进入循环，最大操作次数为 $2$。

所以预处理出 $can_{i, j}$ 表示 $a_i$ 能否通过 $j$ 次操作得到最大，其中 $0 \leq j \leq 2$。

接下来考虑 DP，设 $f_{i, j}$ 为前 $i$ 个数全部操作完成，其中对 $a_i$ 进行 $j$ 次操作得到的最大值。

有状态转移方程：

```cpp
// 枚举 i, j, k，其中 0 <= j, k <= 2
// if (can[i][j])
f[i][j] = min(f[i][j], f[i-1][k] + max(j-k, 0));
```

最终答案取：

```cpp
ans = min({f[n][0], f[n][1], f[n][2]});
```





## Code

主要部分

```cpp
const int N = 1e6 + 5;
const ll inf = 1e18;
ll n, m, f[N][3];
bool can[N][3];
bool jud(ll x) { // 在不在循环里
	return (m / (m / x)) == x;
}
void GOGOGO() {
	n = rd(), m = rd();
	F(i, 0, n) F(j, 0, 2) f[i][j] = inf, can[i][j] = 0; // 多测清空！！！
	ll sum = 0, ans = 0, nw;
    // prework
	F(i, 1, n) {
		ll x = rd(), cnt = 0;
		while (!jud(x)) x = m / x, ++cnt;
		sum += max(x, m / x);
		nw = (x >= m/x ? cnt : cnt + 1);
		can[i][nw] = 1;
		if (!nw) can[i][2] = 1; // 0 can => 2 can
		if (x == m / x) can[i][0] = can[i][1] = can[i][2] = 1; // 相当于平方数（floor(m/i) == i）
	}
    // DP
	f[0][0] = 0;
	F(i, 1, n) F(j, 0, 2) if (can[i][j]) F(k, 0, 2) f[i][j] = min(f[i][j], f[i-1][k] + max(j-k, 0));
	ans = min({f[n][0], f[n][1], f[n][2]});
	cout << sum << ' ' << ans << '\n';
}
```

---

## 作者：fyxblyn (赞：1)

## 题意

对序列进行区间 $a_i \leftarrow \lfloor \frac{m}{a_i} \rfloor$，求序列和的最大值和最小操作次数。

## 思路

我们发现 $a_i < \sqrt{m}$ 时，进行操作会使 $a_i$ 变大， $a_i > \sqrt{m}$ 时，进行操作会使 $a_i$ 变小。

那么显然我们的策略为：

1. $a_i < \sqrt{m}$ 处修改一次；

2. $a_i > \sqrt{m}$ 处修改两次或不修改（如 $m=7,a_i=6$ 时，两次操作可使 $a_i$ 变为 $7$ ，而 $m=6,a_i=3$ 时修改两次或不修改结果一样）；
 
3. $a_i=\sqrt{m}$ 时修改任意次均可。

由于后两种情况中一个位置修改次数可以不同，我们不能使用简单粗暴的贪心，而应该考虑 dp 。

设 $f_{i,j}$ 表示当前考虑到第 $i$ 个数，这个位置修改 $j$ 次的最小修改次数，则有:
$$f_{i,j}=\min_{j_0\in{\{0,1,2\}}}(f_{i-1,j_0}+\max(0,j-j_0))$$

接下来便是简单粗暴的转移，由于 $j$ 的取值只有 $0,1,2$ 三种，时间复杂度即为 $O(n)$ 。

序列和的最大值在转移过程中顺便记录即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5;
int a[N],b[N],f[N][3];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t;
    cin>>t;
    while(t--)
    {
        int n,m;
        cin>>n>>m;
        for(int i=1;i<=n;i++)
        {
            b[i]=-1;
            f[i][0]=f[i][1]=f[i][2]=INT_MAX;
        }
        for(int i=1;i<=n;i++)
            cin>>a[i];
        int ans=0;
        f[0][1]=1,f[0][2]=2;
        for(int i=1;i<=n;i++)
        {
            int a0=a[i],a1=m/a0,a2=m/a1;
            int num=max(a0,max(a1,a2));
            ans+=num;
            int f0=f[i-1][0],f1=f[i-1][1],f2=f[i-1][2];
            if(a0==a1&&a1==a2)
            {
                f[i][0]=min(f0,min(f1,f2));
                f[i][1]=min(f0+1,min(f1,f2));
                f[i][2]=min(f0+2,min(f1+1,f2));
            }
            else if(a0==a1&&a0==num)
            {
                f[i][0]=min(f0,min(f1,f2));
                f[i][1]=min(f0+1,min(f1,f2));
            }
            else if(a0==a2&&a0==num)
            {
                f[i][0]=min(f0,min(f1,f2));
                f[i][2]=min(f0+2,min(f1+1,f2));
            }
            else if(a1==a2&&a1==num)
            {
                f[i][1]=min(f0+1,min(f1,f2));
                f[i][2]=min(f0+2,min(f1+1,f2));
            }
            else if(a0==num)f[i][0]=min(f0,min(f1,f2));
            else if(a1==num)f[i][1]=min(f0+1,min(f1,f2));
            else if(a2==num)f[i][2]=min(f0+2,min(f1+1,f2));
        }
        cout<<ans<<' '<<min(f[n][0],min(f[n][1],f[n][2]))<<'\n';
    }
    return 0;
}
```

---

## 作者：lovely_nst (赞：0)

# P13009 

特殊性质启发我们应该考虑分类做。

1. 当 $a_i\le \sqrt m$ 时：

   此时 $\dfrac{m}{a_i}\ge\lfloor \dfrac{m}{a_i}\rfloor \ge a_i$，则 $\dfrac{m}{\lfloor \dfrac{m}{a_i}\rfloor}\ge a_i$。因此 $a_i$ 的值会越来越接近 $\sqrt m$，$a_i$ 会越来越小。而 $a_i$ 只变换一次便是最大的情况（$a_i=\lfloor \dfrac{m}{a_i}\rfloor $ 例外，需特判）。

2. 当 $a_i>\sqrt m$ 时：

  此时 $a_i\ge \dfrac{m}{a_i}\ge\lfloor \dfrac{m}{a_i}\rfloor$，则 $\dfrac{m}{\lfloor \dfrac{m}{a_i}\rfloor}\ge a_i$。因此 $a_i$ 经过变换后会越来越大，直到一个定值，记做了 $v_i$ 次后进入循环。直接暴力枚举算出变换次数即可，复杂度类似于数论分块（？。发现一个性质，在这之后变换 $2x$ 次 $a_i$ 都是最大值（对后面有用）。

处理完以上内容后，发现情况 $1$ 的相邻数字可以合在一起，操作次数为 $1$；情况 $2$ 的相邻数字可以合在一起，操作次数为 $V=\max_{i=l}^{r}{v_i}$（因为比最大值小的数可以用上面的性质补平成最大值）；对于 $a_i=\lfloor \dfrac{m}{a_i}\rfloor $ 的情况，无论分在哪边都可以，可以直接无视。

这样，每个块就被压缩成单点操作，也就是情况 $1$ 和情况 $2$ 交替。发现若全部都是大于 $0$ 的，可以把 $1$ 全推了，然后再一个一个推，最小次数即为 $1 + \sum V -1$。但是可能会有刚开始就进入循环的数字，那么他们要不就不推（分成散的），要不就当成 $2$ 来做（性质），发现贡献是一样的。设 $0$ 块的数量为 $C$（头尾 $0$ 块不用算），则最小次数为 $C+1+\sum V$。

# AC Code


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int ans , x;
int vis[100005];
signed main ()
{
	ios::sync_with_stdio (0) , cin.tie (0) , cout.tie (0);
	int T;
	cin >> T;
	while (T --)
	{
		int n , m;
		cin >> n >> m;
		ans = 0;
		int sq = sqrt (m);
		for (int i = 1;i <= n;i ++)
		{
			cin >> x;
			if (x == m / x) vis[i] = -1 , ans += x;
			else if (x <= sq) vis[i] = 1 , ans += m / x;
			else
			{
				vis[i] = 0;
				while (m / (m / x) != x) x = m / (m / x) , vis[i] += 2;
				ans += x;
			}
		}
        vis[n + 1] = 0;
		int mx = 0 , l = 0;
		int cnt = 0;
		vector <int> s;
        int p = 1;
		while (vis[p] == -1)p ++;
        if (vis[p] == 1) s.push_back (1);
		for (int i = 1;i <= n;i ++)
		{
			if (vis[i] % 2 == 0 && !l)
				l = i , mx = vis[i];
			else if (vis[i] % 2 == 0) mx = max (mx , vis[i]);
			else if (vis[i] == 1)
			{
				if (l) s.push_back (mx) , s.push_back (1);
				mx = 0 , l = 0;
			}
		}
		if (l) s.push_back (mx);
        if (s.size () == 0)
        {
            cout << ans << ' ' << 0 << '\n';
            continue;
        }
		int cnt0 = 0;
		for (int num : s)
		{
			if (num > 1) cnt += num - 1 , num = 1;
			else if (num == 0) cnt0 ++;
		}
		if (s[0] == 0) cnt0 --;
		if (s.size () && s[s.size () - 1] == 0) cnt0 --;
		cout << ans << ' ' << cnt + 1 + cnt0 << '\n';
	}
	return 0;
}
```

---

## 作者：ivyjiao (赞：0)

显然，每个数只会被操作 $0$、$1$ 或 $2$ 次。

因为操作再多也没有意义，再除的话，数列只会是 $a_0,a_1,a_2,a_1,a_2\cdots$ 这样循环（自己模拟）。

那么我们就有了一个很简单的思路：判断每个数需要除几次，记录下来，最后从前到后扫两遍。

然而这种方法是错的，因为有的数字吧不具备上述循环节，直接就是 $a_0,a_1,a_0,a_1\cdots$，如果 $a_0<a_1$ 还好，但是如果 $a_0\geq a_1$，那么这个数字不除或者除两遍都行，直接炸了。

hack：

```
1
10 50
9 8 7 6 5 4 5 6 7 8
```
```
88 2
```

~~真让你过了这题是绿？~~

老老实实考虑 dp。我们可以将每个位置需要的最小操作次数看作一个序列（每个位置 $0,1,2$）。每次操作一个区间，相当于将这个区间内每个位置的操作次数加 $1$。

经典问题：用最少的区间覆盖（区间加 $1$）将全 $0$ 数组变成目标数组。区间之间可以重叠。

状态：$dp_{i,0},dp_{i,1},dp_{i,2}$ 表示前 $i$ 个位置，且第 $i$ 个位置的操作次数为 $0$ 或 $1$ 或 $2$ 时，能够得到的最大总和 $dp1$ 以及对应的最少总操作区间数 $dp2$。

设当前第 $i$ 位置的操作次数为 $k$，则第 $i$ 位置的值 $b_{i,k}$ 已经确定（$a_i$ 除 $k$ 次的值）。

因此，可得转移方程：

$$dp1_{i,k} = \max_{j \in {0,1,2}}(dp1_{i-1,j})+b_{i,k}$$

然后，我们考虑 $dp2$，前一个位置 $i-1$ 的操作次数 $j$，那么，从 $j$ 到 $k$，操作区间数的增加为：
1. 如果 $i=1$，则区间数增加量就是 $k$（因为第一个位置需要 $k$ 次操作，相当于 $k$ 个区间覆盖了它）。
2. 如果 $i>1$，那么从位置 $i-1$ 到位置 $i$，需要增加的区间数为 $\max(0,k-j)$。
- 如果 $k>j$，那么需要额外 $k-j$ 个区间覆盖位置 $i$（前面的区间已经覆盖了前 $i-1$ 个位置，现在需要覆盖位置 $i$ 且操作次数为 $k$，那么位置 $i$ 需要比位置 $i-1$ 多 $k-j$ 次操作，这 $k-j$ 次操作必须包含位置 $i$ 而不包含位置 $i-1$，因为如果包含位置 $i-1$ 就会增加位置 $i-1$ 的操作次数）。
- 如果 $k=j$，直接延续过来。
- 如果 $k<j$，同理可得结论成立。

在总和相同的情况下，我们还要选择总区间数最小的（详见代码）。

代码（建议滚动数组）：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+1,inf=1e9;
int t,n,m,a[N],dp1[N][3],dp2[N][3],ans1,ans2;
struct node{
	int a,b,c;
};
vector<node>b(N);
signed main(){
    cin>>t;
    while(t--){
        cin>>n>>m;
        for(int i=1;i<=n;i++) cin>>a[i];
        for(int i=1;i<=n;i++){
        	if(m/a[i]) b[i]={a[i],m/a[i],m/(m/a[i])};
        	else b[i]={a[i],m/a[i],0};
        }
        for(int i=1;i<=n;i++){
            for(int j=0;j<3;j++) dp1[i][j]=0,dp2[i][j]=0;
        }
        dp1[1][0]=b[1].a,dp1[1][1]=b[1].b,dp1[1][2]=b[1].c;
        dp2[1][0]=0,dp2[1][1]=1,dp2[1][2]=2;
        for(int i=2;i<=n;i++){
            for(int j=0;j<3;j++){
                int x;
                if(j==0) x=b[i].a;
                else if(j==1) x=b[i].b;
                else x=b[i].c;
                for(int k=0;k<3;k++){
                    if(dp1[i-1][k]==-inf) continue;
                    if(dp1[i-1][k]+x>dp1[i][j]){
                    	dp1[i][j]=dp1[i-1][k]+x;
                    	dp2[i][j]=dp2[i-1][k]+max(0ll,j-k);
                    }
                    else if(dp1[i-1][k]+x==dp1[i][j]){
                        if(dp2[i-1][k]+max(0ll,j-k)<dp2[i][j]) dp2[i][j]=dp2[i-1][k]+max(0ll,j-k);
                    }
                }
            }
        }
        ans1=-inf,ans2=inf;
        for(int i=0;i<3;i++){
            if(dp1[n][i]>ans1) ans1=dp1[n][i],ans2=dp2[n][i];
            else if(dp1[n][i]==ans1) ans2=min(ans2,dp2[n][i]);
        }
        cout<<ans1<<" "<<ans2<<"\n";
    }
}
```

---


# [NOIP 2011 普及组] 表达式的值

## 题目描述

对于1 位二进制变量定义两种运算：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|} \hline
\kern{5em}\mathclap\textsf{运算符}\kern{5em} & \kern{5em}\mathclap\textsf{运算规则}\kern{5em} \\ \hline
\oplus &
\begin{aligned}
0 \oplus 0 &= 0 \\
0 \oplus 1 &= 1 \\
1 \oplus 0 &= 1 \\
1 \oplus 1 &= 1 \\
\end{aligned} \\ \hline
\times &
\begin{aligned}
0 \times 0 &= 0 \\
0 \times 1 &= 0 \\
1 \times 0 &= 0 \\
1 \times 1 &= 1 \\
\end{aligned} \\ \hline
\end{array}
$$

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

2. “× ”运算优先于“⊕”运算，即计算表达式时，先计算× 运算，再计算⊕运算。例如：计算表达式A⊕B × C时，先计算 B × C，其结果再与 A 做⊕运算。

现给定一个未完成的表达式，例如\_+(\_\*\_)，请你在横线处填入数字$0 $或者$1$ ，请问有多少种填法可以使得表达式的值为$0 $。


## 说明/提示

【输入输出样例说明】

  给定的表达式包括横线字符之后为：\_+(\_\*\_) 

  在横线位置填入(0 、0 、0) 、(0 、1 、0) 、(0 、0 、1) 时，表达式的值均为0 ，所以共有3种填法。 

【数据范围】

对于 $20\%$ 的数据有 $ 0 \le L \le 10$。

对于 $50\%$ 的数据有 $0 \le L \le 1,000$。

对于 $70\%$ 的数据有 $ 0 \le L \le 10,000$ 。

对于 $100\%$的数据有 $ 0 \le L \le 100,000$。

对于$50\%$ 的数据输入表达式中不含括号。


## 样例 #1

### 输入

```
4
+(*)
```

### 输出

```
3
```

# 题解

## 作者：神犇的蒟蒻 (赞：99)

**本题难点在于：1.有优先级**

**2.有括号**


**我们先分析一下**


这是一道表达式计算的扩展题，对选手最基本的要求就是表达式计算。在一般的表达式计算中，存放结果的栈都是记录计算到某一步的结果，而在这道题中，结果只可能为2个（0或者1），且是知道的，而运算的数字是不一定的，所以在栈中只需存放算到0或者1时的方案数，最后输出到最后算出0的方案数即可。


**算法实现**


一、  首先粗略地说一下表达式计算的方法：  需要使用两个栈，一个存放结果，另一个存放符号。每次读入一个数据，就进入结果栈，如果是符号，则按以下方法：  1、 如果是左括号，就直接进栈；  2、 如果是右括号，就一直弹栈并加以计算，直到弹到左括号；  3、 如果是运算符，则弹栈，直到这个运算符的优先级大于符号栈栈顶的符号的优先级 或是左括号或栈空，然后将运算符进栈；      最后再将栈中残余的符号和结果一直弹到只剩一个结果，这个就是最后的结果。 二、  此题算法的框架整体上是和表达式计算相同的，有以下几个方面不同： 1、需要添加数字的地方应该满足不在右括号的后面或者左括号的前面 2、优先级：“\*”的优先级比“+”高  3、运算方法，每一步计算为0或1的方法数：设两个步骤的运算结果经过每个符号到一个结果时，第一个运算结果算出0的方案数为t1,1的方案数为t2,第二个算出0的方案数为t3，算出1的方案数为t4，则有：  当符号是“⊕”时，得到0的方案数为t1\*t3,1的方案数：t1\*t4+t2\*t3+t2\*t4    当符号是“×”时，得到0的方案数为t1\*t3+t1\*t4+t2\*t3,1的方案数：t2\*t4 用一个栈记录下来即可


**参考代码：**

```cpp
#include<stdio.h>
const int M=10007,N=100005;
int n,i,u[N],v[N],top,k;
char c[N],sta[N],ans[2*N];
int main()
{
    freopen("exp.in","r",stdin);
    freopen("exp.out","w",stdout);
    scanf("%d\n%s",&n,c);
    ans[++k]='.';
    for(i=0;c[i];i++)
    {
        if(c[i]=='('||c[i]=='*')
            sta[++top]=c[i];
        if(c[i]=='+')
        {
            while(sta[top]=='*')
                ans[++k]=sta[top--];
            sta[++top]=c[i];
        }
        if(c[i]==')')
        {
            while(sta[top]!='(')
                ans[++k]=sta[top--];
            top--;
        }
        if(c[i]!='('&&c[i]!=')')
            ans[++k]='.';
    }
    while(top>0)
        ans[++k]=sta[top--];
    for(i=1;i<=k;i++)
    {
        if(ans[i]=='.')
        {
            u[++top]=1;
            v[top]=1;
        }
        if(ans[i]=='*')
        {
            top--;
            u[top]=(u[top+1]*v[top]+u[top]*v[top+1]+u[top]*u[top+1])%M;
            v[top]=v[top]*v[top+1]%M;
        }
        if(ans[i]=='+')
        {
            top--;
            v[top]=(u[top+1]*v[top]+u[top]*v[top+1]+v[top]*v[top+1])%M;
            u[top]=u[top]*u[top+1]%M;
        }
    }
    printf("%d",u[1]);
}
```

---

## 作者：Drinkkk (赞：64)

- **NOIP普及组 2011 第四题**

## 题目描述

对于 1 位二进制变量定义两种运算：

![](https://cdn.luogu.com.cn/upload/pic/99.png)

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

2. “ $×$ ”运算优先于“ $⊕$ ”运算，即计算表达式时，先计算× 运算，再计算 $⊕$ 运算。例如：计算表达式 $A ⊕ B × C$ 时，先计算 $B × C$，其结果再与 $A$ 做 $⊕$ 运算。

现给定一个未完成的表达式，例如 ``_+(_*_)``，请你在横线处填入数字 $0$ 或者 $1$ ，请问有多少种填法可以使得表达式的值为 $0$ 。

## 输入输出格式

- ### 输入格式

共 $2$ 行。

第 $1$ 行为一个整数 $L$，表示给定的表达式中除去横线外的运算符和括号的个数。

第 $2$ 行为一个字符串。包含 $L$ 个字符，其中只包含’``（``’、’``）``’、’``+``’、’``*``’这 $4$ 种字符，其中’``（``’、’``）``’是左右括号，’``+``’、’``*``’分别表示前面定义的运算符“ $⊕$ ”和“ $×$ ”。这行字符按顺序给出了给定表达式中除去变量外的运算符和括号。

- ### 输出格式：
共 $1$ 行。

包含一个整数，即所有的方案数。注意：这个数可能会很大，请输出方案数对``10007``取模后的结果。

## 输入输出样例

```
Input:
4
+(*)
Output:
3
```

## 样例解释

- ### 输入输出样例说明

  给定的表达式包括横线字符之后为：``_+(_*_)`` 

  在横线位置填入``(0 、0 、0) ``、``(0 、1 、0)`` 、``(0 、0 、1) ``时，表达式的值均为 $0$ ，所以共有 $3$ 种填法。 

## 数据范围

对于 $20\%$ 的数据有 $0 ≤ L ≤ 10$ 。

对于 $50\%$ 的数据有 $0 ≤ L ≤ 1,000$ 。

对于 $70\%$ 的数据有 $0 ≤ L ≤ 10,000$ 。

对于 $100\%$ 的数据有 $0 ≤ L ≤ 100,000$ 。

对于 $50\%$ 的数据输入表达式中不含括号。

## 题解

在这里我们将用**栈**来解决这个问题。

首先我们有一个符号栈 $t$ ，用来存储操作符。

接下来我们有两个数字栈 $a$ 和 $b$ ，分别表示当前运算结果为 $0$ 和为 $1$ 的方案数。

这三个栈的栈顶分别为 $topt,topa,topb$ 。

- $E.g.1$

```
*+
```

当前的栈 $t,a,b$ 都是空的，如图。

![无标题.png](https://i.loli.net/2019/01/05/5c30bfc9c141b.png)

接下来我们弹入了一个乘号，由于乘号是除括号外最高级的，所以我们要先把它前面的乘号算完（但是要注意如果一个乘号的右边是一个左括号就不能够直接算了）。但是由于它前面已经没有乘号了，所以我们先不管它。

对于每一个字符，我们要判断它的前面和后面是否能够放数字，及样例解释中为下划线的地方。

如果能放，就在 $a$ 栈和 $b$ 栈的栈顶各放入一个 $1$ 。

此时状态：

$t:\times$

$a:$

```
1
1
```

$b:$

```
1
1
```

接下来我们把一个加号放进来。由于加号优先级比乘号低，所以我们要把这个加号前面的乘号给消掉。消之前的图是长这样的。

![无标题2.png](https://i.loli.net/2019/01/05/5c30bfc9b8b30.png)

下面是消的方法。

![无标题3.png](https://i.loli.net/2019/01/05/5c30bfc9c2ff3.png)

这就是消完后的图啦。

![无标题4.png](https://i.loli.net/2019/01/05/5c30bfc9a2c2f.png)

加号的话还是差不多。

$$e=a*c$$

$$f=a*d+b*c+b*d$$

左括号的话就直接把它丢到符号栈里面就可以了。

如果是右括号的话就一直消，直到消到左括号为止。

注意右括号左边可能是乘号，也要把它算进去。

然后两个括号之间乘号基本上都被消掉了，大部分都是加号，可以放心算。

最后 $a$ 栈的栈底（顶）就是答案。

为了防止消不尽可以在式子的两边加括号qwq。

例如样例加了括号就变成这样了。

```
（+(*)）
```

如果还有不理解的可以尝试联系代码来理解qaq，最好是自己动手写。

## 代码（仅供参考）

```
#include <cstdio>
char st[1000001],t[1000001];
int a[1000001],b[1000001];
int main()
{
	int topt=0,topa=0,topb=0,n=0;
	scanf("%d",&n);
	scanf("%s",st+2);
	st[1]='(',st[n+2]=')';
	for(int i=1;i<=n+2;i++)
	{
		if((st[i]=='+' || st[i]=='*') && st[i-1]!=')' && st[i-1]!='+' && st[i-1]!='*')
		{
			a[++topa]=b[++topb]=1;
		}
		if(st[i]=='(')
		{
			t[++topt]=st[i];
		}
		if(st[i]=='*')
		{
			if(st[i+1]=='(')
			{
				t[++topt]=st[i];
				continue;
			}
			while(true)
			{
				if(t[topt]!='*')
				{
					break;
				}
				int aa=a[topa],ab=b[topb];
				int ac=a[topa-1],ad=b[topb-1];
				int e=aa*ac+aa*ad+ab*ac;
				int f=ab*ad;
				e%=10007,f%=10007;
				topa--,topb--;
				a[topa]=e,b[topb]=f;
				topt--;
			}
			t[++topt]=st[i];
		}
		if(st[i]=='+')
		{
			while(true)
			{
				if(t[topt]!='*')
				{
					break;
				}
				int aa=a[topa],ab=b[topb];
				int ac=a[topa-1],ad=b[topb-1];
				int e=aa*ac+aa*ad+ab*ac;
				int f=ab*ad;
				e%=10007,f%=10007;
				topa--,topb--;
				a[topa]=e,b[topb]=f;
				topt--;
			}
			t[++topt]=st[i];
		}
		if(st[i]==')')
		{
			while(true)
			{
				if(t[topt]=='(')
				{
					break;
				}
				if(t[topt]=='+')
				{
					int aa=a[topa],ab=b[topb];
					int ac=a[topa-1],ad=b[topb-1];
					int e=aa*ac;
					int f=aa*ad+ab*ac+ab*ad;
					e%=10007,f%=10007;
					topa--,topb--;
					a[topa]=e,b[topb]=f;
					topt--;
				}
				else if(t[topt]=='*')
				{
					int aa=a[topa],ab=b[topb];
					int ac=a[topa-1],ad=b[topb-1];
					int e=aa*ac+aa*ad+ab*ac;
					int f=ab*ad;
					e%=10007,f%=10007;
					topa--,topb--;
					a[topa]=e,b[topb]=f;
					topt--;
				}
			}
			topt--;
		}
		
		if((st[i]=='+' || st[i]=='*') && st[i+1]!='(')
		{
			a[++topa]=b[++topb]=1;
		}
	}
	printf("%d",a[1]%10007);
	return 0;
}
```

---

## 作者：zy_turtle (赞：14)

### [永遠の記憶 ~ Precious Memories]施工D12  
  

###### 2020.3.22  
  
#### P1310 表达式求值  
  
##### Noip2011 T4  
  
[题目传送门](https://www.luogu.com.cn/problem/P1310)  
  
  


------------
  
  
我先承认，我这道题是真的不太会做  
dp没什么有用的思路  
~~看起来dp并不亲民的样子~~  
  
###### 不过呢，还是得硬上  


------------

一看到这道题，我想到的不是个 **dp**  
是一个类似于**排列组合**或者**乘法原理**的东西  
总之思路是这样的  
先**按照加号**的顺序**分块**，  
然后按照分出来的再算**乘法**的可能个数  
就得出了答案  
~~(五分钟敲出来的，所以有很多没用的变量~~  
代码如下:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	string str;
	int init;
} let;
int n;
vector<node> add;
long long ans; 

int divide_add(node s) {
	node temp;
	if (s.str.find('+') == string::npos) {
		return -1;
	}
	else {
		for (int i = 0; i < s.str.size(); ++i) {
			if (i == s.str.size() - 1) {
				temp.init = 0;
				add.push_back(temp);
				return 0;
			} // 读完 
			else if (s.str[i] == '(') {
				while (s.str[i] != ')') {
					temp.str += s.str[i];
					++i;
				}
			} // 括号看做一个整体 
			else if (s.str[i] == '+') {
				temp.init = 0;
				add.push_back(temp);
			} // 加号分前面 
			else {
				temp.str += s.str[i];
			} // 往后读 
		}
	}
}

int main() {
	cin >> n >> let.str;
	int flag = divide_add(let);
	if (!flag) {
		for (vector<node>::iterator it = add.begin(); it != add.end(); ++it) {
			int cnt = 0;
			for (int i = 0; i < it->str.size(); ++i) {
				if (it->str[i] == '*') {
					cnt++;
				}
			}
			ans += cnt * 3;
		}
	} // 有加号，分块算  
	else {
		int cnt = 0;
		for (int i = 0; i < let.str.size(); ++i) {
			if (let.str[i] == '*') {
				cnt++;
			}
		}
		ans += cnt * 3;
	} // 没有加号  
	cout << ans % 10007 << endl;
	return 0;
}

```
  
  
结果出了 **MLE**  
说明这个解法是肯定不能AC的  
而且题目也说了，这是一道dp，所以不能用~~投机取巧的~~**排列组合或者乘法原理**来做  
~~其实最后的答案也跟乘法原理差不多(汗~~    


------------
  
  
题目说，给定一个**符号**序列  
那熟悉的朋友可能会想到用树去分这个序列，然后两个变量一组去**枚举**  
但是这么实现的代码会**格外的复杂**，时间复杂度也会**过高**，可能会T  
##### 所以我们要换一种思路  
题目现在给的是一个**中序表达式**  
我们可以考虑用栈去把它转换成**逆波兰表达式**，也就是**后缀表达式**  
~~其实应该不能叫转换，应该是存储~~  
具体模拟的方法可以参考[这道题](https://www.luogu.com.cn/problem/P1449)  
  


------------
  
  
##### 这是一道**dp**，我们考虑去推出它的**递推式**  
先对一个表达式进行分析，表达式的左边的值叫 x，右边的值叫 y  
>那么，当 x + y = 0 时，  
x = 0 且 y = 0;  
当 x * y = 0 时，  
x = 0 且 y = 1 或  
x = 1 且 y = 0 或  
x = 0 且 y = 0;  
  
>当 x + y = 1 时，  
x = 0 且 y =  1或  
x = 1 且 y = 0 或  
x = 0 且 y = 0; 
当 x * y = 1 时，  
x = 1 且 y = 1;  
  
##### 我们推出了以上的规律，后面就会方便很多  


------------
  
  
我们先把**栈的实现**写出来  
用**一个栈**来存**运算符**  
另外**两个栈**用来存**可能的数字情况的个数**  
~~其实就是跟dp数组差不多~~  
###### 表示出来就是这样:  
```cpp
const int maxn = 1e5 + 10;
char stackop[maxn];
int topop;
int stacknum1[maxn];
int stacknum0[maxn];
int topnum;

void push_op(char op) {
	stackop[++totop] = op;
}

void push_num() {
	stacknum1[++topnum] = 1;
    stacknum0[topnum] = 1;
}

```
  


------------

  
###### 再将前面推出来的式子用代码实现出来:  
```cpp
for (ll i = 0; i < let.size(); ++i) {
	if (let[i] == '(') {
		push_op(let[i]); // 处理不了，先放着
		if (let[i + 1] != '(') {
			push_num();
		} // 后面的空，括号中间不能夹数
	} else if (let[i] == ')') {
		while (stackop[topop] != '(') {
			int res0 = 0, res1 = 0;
			if (stackop[topop] == '+') {
				res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
			} else {
				res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
			}
			topop--, topnum--;
			stacknum0[topnum] = res0;
			stacknum1[topnum] = res1; // 推出来的
		} // 直接压到匹配的左括号
		topop--; // 右括号
	} else if (let[i] == '+') {
		while (stackop[topop] != '(') {
			int res0 = 0, res1 = 0;
			if (stackop[topop] == '+') {
				res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
			} else {
				res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
			}
			topop--, topnum--;
			stacknum0[topnum] = res0;
			stacknum1[topnum] = res1; // 同理
		} // 同上，加号优先级低，可以无脑压左操作数
		push_op(let[i]);
		if (let[i + 1] != '(') {
			push_num();
		} // 同理
	} else if (let[i] == '*') {
		while (stackop[topop] == '*') {
			int res0 = 0, res1 = 0;
			if (stackop[topop] == '+') {
				res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
			} else {
				res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod +
				       (stacknum1[topnum] * stacknum0[topnum - 1]) % mod +
				       (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
			}
			topop--, topnum--;
			stacknum0[topnum] = res0;
			stacknum1[topnum] = res1; // 同理
		} // 只能先压同一级的
		push_op(let[i]);
		if (let[i + 1] != '(') {
			push_num();
		} // 同理
	}
}

```
  
  


------------


最后综合**前面两步**的代码，  
再将原来的字符串做一点**细微**的处理就好啦~  
##### 完整代码如下，注释里有一些前面没讲到的东西的解释  
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod = 10007;
const ll maxn = 1e5 + 10;
char stackop[maxn];
ll topop;
ll stacknum1[maxn];
ll stacknum0[maxn];
ll topnum;
ll len;
string let;

void push_op(char op) {
	stackop[++topop] = op;
}

void push_num() {
	stacknum1[++topnum] = 1;
	stacknum0[topnum] = 1;
}

int main() {
	scanf("%lld", &len);
	cin >> let;
	let = '(' + let + ')';
	// 这里需要处理一下，不然要特判，太麻烦了  
	for (ll i = 0; i < let.size(); ++i) {
		if (let[i] == '(') {
			push_op(let[i]); // 处理不了，先放着 
			if (let[i + 1] != '(') {
				push_num();
			} // 后面的空，括号中间不能夹数 
		}
		else if (let[i] == ')') {
			while (stackop[topop] != '(') {
				int res0 = 0, res1 = 0;
				if (stackop[topop] == '+') {
					res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
					res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				}
				else {
					res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
					res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				}
				topop--, topnum--;
				stacknum0[topnum] = res0;
				stacknum1[topnum] = res1; // 推出来的 
			} // 直接压到匹配的左括号 
			topop--; // 右括号 
		}
		else if (let[i] == '+') {
			while (stackop[topop] != '(') {
				int res0 = 0, res1 = 0;
				if (stackop[topop] == '+') {
					res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
					res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				}
				else {
					res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
					res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				}
				topop--, topnum--;
				stacknum0[topnum] = res0;
				stacknum1[topnum] = res1; // 同理 
			} // 同上，加号优先级低，可以无脑压左操作数 
			push_op(let[i]);
			if (let[i + 1] != '(') {
				push_num();
			} // 同理 
		}
		else if (let[i] == '*') {
			while (stackop[topop] == '*') {
				int res0 = 0, res1 = 0;
				if (stackop[topop] == '+') {
					res0 = (stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
					res1 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
				}
				else {
					res1 = (stacknum1[topnum] * stacknum1[topnum - 1]) % mod;
					res0 = (stacknum0[topnum] * stacknum1[topnum - 1]) % mod + 
										(stacknum1[topnum] * stacknum0[topnum - 1]) % mod + 
										(stacknum0[topnum] * stacknum0[topnum - 1]) % mod;
				}
				topop--, topnum--;
				stacknum0[topnum] = res0;
				stacknum1[topnum] = res1; // 同理 
			} // 只能先压同一级的 
			push_op(let[i]);
			if (let[i + 1] != '(') {
				push_num();
			} // 同理 
		}
	}
	printf("%lld\n", stacknum0[topnum] % mod); // 压到最后的就是答案 
	return 0;
}

```
  
这道题目作为一道**压轴**的 dp，其难度**不言而喻**  
这篇题解也拖了**三天**才写出来~~可能是我太鸽了~~  
总之，这是一道很有**学习价值**的题目  
近年来的 **dp** 都放在了**第三题**，也就是说**难度下降**了  
~~摆渡车忽略~~  
幸好出生得晚啊（笑）  
不过以后还是得多多加油，争取今年省一啊  
那就先写到这里吧
  
~~看来写题解的能力也需要提升(捂脸~~  
~~话说，dp果然还是不太亲民啊~~  


---

## 作者：junxis (赞：5)

# 1.部分分
[题目传送门](https://www.luogu.com.cn/problem/P1310)

我们先来看八十分怎么拿,正解也不过只是这个算法的小优化。
看到题，表达式？你联想到了什么？
~~放弃！~~

表达式树。
	
考虑递归建树，递归参数分别为 $l$,$r$。
有两个核心变量 $x$,$y$ （初值为 0）。
1. 若 $l$ $>$ $r$，说明当前节点不存储操作符，而是题中的“横线”，将节点总数加一，并直接将左右孩子编号设为0，返回当前节点编号即可。
2. 找到第一个在当前区间且不被括号包裹的“+”，若有，则将它的位置赋值给变量 $x$。
3. 再找到第一个在当前区间且不被括号包裹的“$\ast$”，若有，则将它的位置赋值给变量 $y$。 
4. 结束用于确定 $x$,$y$ 的循环后，若 $x$,$y$ 均为0，则说明当前区间左右端点构成一对括号，返回递归区间 $\left[l+1,r-1\right]$。
5. 若 $x$ 为0，则将 $y$ 赋值给 $x$ 。
6. 将总结点数加一，当前节点的左孩子编号为递归区间 $\left[l,x-1\right]$，右孩子编号为递归区间 $\left[x+1,r\right]$，操作符为输入字符串中的第 $x$ 个字符，返回当前节点编号。

然后呢？如何求答案？

显然的树形 dp。

令 $f(u,x)$ 表示表达式树上节点 $u$ 所表示的表达式取值为 $x$ 的情况有多少种。

根据两种运算的定义，易得转移方程。

+ 若 $u$ 处存储的运算符为"+"

	$f(u,1)=f(lc,0)f(rc,1)+f(lc,1)f(rc,0)+f(lc,1)f(rc,1)$

	$f(u,0)=f(lc,0)f(rc,0)$

+ 若 $u$ 处存储的运算符为"$\ast$"

	$f(u,0)=f(lc,0)f(rc,1)+f(lc,1)f(rc,0)+f(lc,0)f(rc,0)$
   
	$f(u,1)=f(lc,1)f(rc,1)$

其中 $lc$,$rc$ 分别指 $u$ 的左右孩子编号。答案为 $f(rt,0)$。($rt$ 为根节点）

八十分到手。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,mod=10007,INF=0x7fffff;
int n,rt,f[N][2],tot;

char s[N];

struct point{
	int lc,rc;//分别表示左孩子，右孩子 
	char op;//存储的符号 
}Exp[N];//表达式树节点 
int expTree(int l,int r)//建表达式树 
{
	int x=0,y=0,u;
	if(l>r)
	{
		u=++tot;
		Exp[u].lc=Exp[u].rc=0;
		return u;
	}//无符号，存储横线 
	for(int i=l;i<=r;i++)
	{
		if(s[i]=='(') tmp++;
		if(s[i]==')') tmp--;
		if(s[i]=='+') if(!tmp&&!x) x=i;
		if(s[i]=='*') if(!tmp&&!y) y=i;
	}
	if(!x&&!y) return expTree(l+1,r-1);
	if(!x) x=y;
	u=++tot;
	Exp[u].lc=expTree(l,x-1);
	Exp[u].rc=expTree(x+1,r);
	Exp[u].op=s[pos];
	return u;//这部分参考对表达式树的分析 
}
void dp(int u)//树形dp 
{
	if(Exp[u].lc==0&&Exp[u].rc==0)//若遍历到存储数值的节点， 直接触发边界条件 
	{
		f[u][0]=f[u][1]=1;
		return ;
	}
	int x=Exp[u].lc,y=Exp[u].rc;
	dp(x);dp(y);//先递归，再dp 
	if(Exp[u].op=='+')
	{
		f[u][0]=f[x][0]*f[y][0]%mod;
		f[u][1]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][1]*f[y][1])%mod;
	}
	if(Exp[u].op=='*')
	{
		f[u][1]=(f[x][1]*f[y][1])%mod;
		f[u][0]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][0]*f[y][0])%mod;
	}
	return ;//参照转移方程理解，别忘了取膜 QAQ 
}
int main()
{
	int tmp=0;
	scanf("%d\n%s",&n,s+1);
	int rt=expTree(1,n);
	dp(rt);
	cout<<f[rt][0]%mod;
    return 0;
}
```

# 2. AC
其实想要让你的屏幕发绿光，只要对上面的代码用数据结构优化即可。

这个时候你说：“都已经是一种数据结构了，还能用啥优化？”

~~爱与勇气~~

先分析为什么会 TLE，是那个万恶的 n 方建树。~~（n 方过百万，暴力碾标算）~~

看到建树的 2,3,4 操作，其实它们目的就是找出区间 $\left[l,r\right]$ 里优先级最小的。

看到这几个字眼：“区间”，“最小”。

想到了什么？

线段树！

形式化地，令 $priority(x)$ 表示字符串中第 $x$ 位的优先级，
括号的优先级为无穷大，动态记录当前操作符被包裹在几对括号里。设当前需处理的操作符为第 $x$ 个，它被包裹在 $K$ 对括号里。

+ 当第$x$位是“+”

	$priority(x)=2K+1$。

+ 当第$x$位是"$\ast$"
	
	$priority(x)=2K+2$。

预处理 $priority$ 数组，用线段树维护 $[l,r]$ 里优先级最小的字符的位置即可将复杂度优化为 $O(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,mod=10007,INF=0x7fffff;
int n,rt,f[N][2],tot,priority[N];
#define lson p<<1
#define rson p<<1|1 
struct treePoint{
	int l,r,v,pos;
}sgt[N<<2];

void pushUp(int p)
{
	sgt[p].v=min(sgt[lson].v,sgt[rson].v);
	sgt[p].pos=(sgt[lson].v<sgt[rson].v ? sgt[lson].pos : (sgt[lson].v==sgt[rson].v ? min(sgt[lson].pos,sgt[rson].pos) : sgt[rson].pos));
}

void build(int p,int l,int r)
{
	sgt[p].l=l;sgt[p].r=r;
	if(l==r)
	{
		sgt[p].v=priority[l];
		sgt[p].pos=l;
		return ;
	}
	int mid=(l+r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	pushUp(p);
}

int query(int p,int l,int r)
{
	if(sgt[p].l==l&&sgt[p].r==r) return sgt[p].pos;
	int mid=(sgt[p].l+sgt[p].r)>>1;
	if(r<=sgt[lson].r) return query(lson,l,r);
	if(l>sgt[lson].r) return query(rson,l,r);
	int x=query(lson,l,mid);
	int y=query(rson,mid+1,r);
	return priority[x]<priority[y] ? x : (priority[x]==priority[y] ? min(x,y) : y);
}

char s[N];

struct point{
	int lc,rc;
	char op;
}Exp[N];
int expTree(int l,int r,int cnt)//cnt表示当前区间被包裹在几对括号里 
{
	int x=0,y=0,u;
	if(l>r)
	{
		u=++tot;
		Exp[u].lc=Exp[u].rc=0;
		return u;
	} 
	int pos=query(1,l,r);//优先级最小的操作符的位置 
	if(priority[pos]-2*cnt>2) return expTree(l+1,r-1,cnt+1); //没有一个运算符在括号外面 cnt加1 
	u=++tot;
	Exp[u].lc=expTree(l,pos-1,cnt);
	Exp[u].rc=expTree(pos+1,r,cnt);
	Exp[u].op=s[pos];
	return u;
}
void dp(int u)
{
	if(Exp[u].lc==0&&Exp[u].rc==0)
	{
		f[u][0]=f[u][1]=1;
		return ;
	}
	int x=Exp[u].lc,y=Exp[u].rc;
	dp(x);dp(y);
	if(Exp[u].op=='+')
	{
		f[u][0]=f[x][0]*f[y][0]%mod;
		f[u][1]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][1]*f[y][1])%mod;
	}
	if(Exp[u].op=='*')
	{
		f[u][1]=(f[x][1]*f[y][1])%mod;
		f[u][0]=(f[x][0]*f[y][1]+f[x][1]*f[y][0]+f[x][0]*f[y][0])%mod;
	}
	return ;
}
int main()
{
	int tmp=0;
	scanf("%d\n%s",&n,s+1);
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='(')tmp++,priority[i]=INF;
		if(s[i]==')')tmp--,priority[i]=INF;
		if(s[i]=='+') priority[i]=2*tmp+1;
		if(s[i]=='*') priority[i]=2*tmp+2;
	}//预处理 
	build(1,1,n);//建树
	int rt=expTree(1,n,0);
	dp(rt);
	cout<<f[rt][0]%mod;
    return 0;
}
```
 AC 啦！！！

这是我认为这道题最自然的思路，目前可以说是全新的思路，望管理员通过，也感谢每一个看到这里的 OIer 们。

---

## 作者：Walrus (赞：3)

一眼是建树之后在树上 dp，问题是如何建树。首先联系 CSP-2020 的一道题可知依靠运算优先级建表达式树，朴素的建树法是 $O(N^2)$ 暴力建，也就是递归建树，但可以发现这显然是没必要的，我们完全可以给每个点设置一个优先级建笛卡尔树。

由于括号的优先级是最高的，所以括号里的东西需要优先运算，人话版理解就是这个式子外面套的括号越多其优先级就越高。

每有一对括号相当于给括号内的区间优先级加上了一个值，相当于区间加，故考虑差分，大概是这么写的：
```cpp
stack<int> ss;
rep(i, 1, n) {
	if(s[i] == '(') ss.push(i);
	if(s[i] == ')') b[ss.top()] += 2, b[i + 1] -= 2, ss.pop();
}
rep(i, 1, n) b[i] += b[i - 1], a[i] = b[i] + (s[i] == '*' ? 2 : 1); 
```

然后建笛卡尔树，由于用单调栈维护所以复杂度是 $O(N)$ 的，然后跑 dp。

令 $dp_{x,0/1}$ 表示以 $x$ 为根运算结果为 $0/1$ 的方案数，根据位与和位或的性质可以得出表达式：

- 位与
$$dp_{x,1}=dp_{ls,1}\times dp_{rs,1}$$
$$dp_{x,0}=dp_{ls,0}\times dp_{rs,1}+dp_{ls,1}\times dp_{rs,0}+dp_{ls,0}\times dp_{rs,0}$$

- 位或
$$dp_{x,0}=dp_{ls,0}\times dp_{rs,0}$$
$$dp_{x,1}=dp_{ls,0}\times dp_{rs,1}+dp_{ls,1}\times dp_{rs,0}+dp_{ls,1}\times dp_{rs,1}$$

注意取模。

附建树代码：
```cpp
void init(int *a) {
	rep(i, 1, n) {
		if(s[i] == '(' || s[i] == ')') continue;
		while(top && a[st[top]] > a[i]) ch[i][0] = st[top--];
		if(top) ch[st[top]][1] = i;
		st[++top] = i;
	} 
}
```

---

## 作者：LINYUHENG2 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1310)
## 思路
首先说一下表达式计算的方法：   
需要使用两个栈，一个存放结果，另一个存放符号。  
每次读入一个数据，就进入结果栈，如果是符号，则按以下方法：   
1. 如果是左括号，就直接进栈；
2. 如果是右括号，就一直弹栈并加以计算，直到弹到左括号；  
3. 如果是运算符，则弹栈，直到这个运算符的优先级大于符号栈栈顶的符号的优先级。或是左括号或栈空，然后将运算符进栈；最后再将栈中残余的符号和结果一直弹到只剩一个结果，这个就是最后的结果。

此题算法的框架整体上是和表达式计算相同的，有以下几个方面不同：
1. 需要添加数字的地方应该满足不在右括号的后面或者左括号的前面；
2. 优先级：“$\times$”的优先级比“$\oplus$”高；
3. 运算方法，每一步计算为 $0$ 或 $1$ 的方法数：  
设两个步骤的运算结果经过每个符号到一个结果时，第一个运算结果算出 $0$ 的方案数为 $t1$，算出 $1$ 的方案数为 $t2$，第二个算出 $0$ 的方案数为 $t3$，算出 $1$ 的方案数为 $t4$，则有：  
当符号是“$\oplus$”时，得到 $0$ 的方案数为 $t1 \times t3$，得到 $1$ 的方案数为 $t1 \times t4 + t2 \times t3 + t2 \times t4$。当符号是“$\times$”时，得到 $0$ 的方案数为 $t1 \times t3 + t1 \times t4 + t2 \times t3$，得到 $1$ 的方案数为 $t2 \times t4$，用一个栈记录下来即可。

## 代码
```cpp
#include<bits/stdc++.h>
#define 10007 MAXM
#define 100005 MAXN
using namespace std;

int n,i,u[MAXN],v[MAXN],top,k;
char c[MAXN],sta[MAXN],ans[2*MAXN];

int main(){
    scanf("%d\n%s",&n,c);
    ans[++k]='.';
    for(i=0;c[i];i++){
        if(c[i]=='('||c[i]=='*'){
        	sta[++top]=c[i];
		}
        if(c[i]=='+'){
            while(sta[top]=='*') ans[++k]=sta[top--];
            sta[++top]=c[i];
        }
        if(c[i]==')'){
            while(sta[top]!='(') ans[++k]=sta[top--];
            top--;
        }
        if(c[i]!='('&&c[i]!=')'){
        	ans[++k]='.';
		}
    }
    while(top>0){
		ans[++k]=sta[top--];
	}
    for(i=1;i<=k;i++){
        if(ans[i]=='.'){
            u[++top]=1;
            v[top]=1;
        }
        if(ans[i]=='*'){
            top--;
            u[top]=(u[top+1]*v[top]+u[top]*v[top+1]+u[top]*u[top+1])%MAXM;
            v[top]=v[top]*v[top+1]%MAXM;
        }
        if(ans[i]=='+'){
            top--;
            v[top]=(u[top+1]*v[top]+u[top]*v[top+1]+v[top]*v[top+1])%MAXM;
            u[top]=u[top]*u[top+1]%MAXM;
        }
    }
    printf("%d",u[1]);
}
```

---

## 作者：Otue (赞：2)

## [[NOIP2011 普及组] 表达式的值](https://www.luogu.com.cn/problem/P1310)

### 题目描述

现给定一个未完成的表达式，例如 `_+(_*_)`，请你在横线处填入数字 $0 $ 或者 $1$，请问有多少种填法可以使得表达式的值为 $0 $。

### 思路

此题用 **笛卡尔树解决**。首先括号只需要用来解决优先级问题，比如当前的一个 `*` 被 $p$ 个括号包含，那么此优先级为 $2p+2$。如果一个 $+$ 被 $p$ 个括号包含，那么此优先级为 $2p+1$。我们用优先级的值来建立笛卡尔树。

比如表达式 `_+(_*_)`，其中 `+` 优先级为 $1$，`*` 优先级为 $4$，则笛卡尔树上 `*` 是 `+` 的右子节点。因为在递归计算方案数时，先算优先级高的，即深度高的。那么可以对此笛卡尔树开始 dp 了。定义 $f_{u,0/1}$ 表示笛卡尔树的 $u$ 子树，当前节点计算的答案为 $0/1$ 的方案数。

转移也是十分显然：对当前节点的运算符进行分类讨论即可：

![](https://cdn.luogu.com.cn/upload/image_hosting/1nxhiymb.png)

注意边界条件：$f_{u,0}=f_{u,1}=1$。因为在笛卡尔树建树的过程中，叶子节点的两个儿子被忽略了。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
#define int long long

const int N = 3e5 + 5, mod = 10007;

int n, ls[N], rs[N], op[N], val[N], cnt, root, top, stk[N];
int f[N][2];
char a[N];

void dfs(int u) { // 树形 dp
	if (u == 0) return;
	dfs(ls[u]); dfs(rs[u]);
	if (op[u] == 1) {
		f[u][0] = f[ls[u]][0] * f[rs[u]][0] % mod;
		f[u][1] = (f[ls[u]][0] * f[rs[u]][1] % mod + f[ls[u]][1] * f[rs[u]][0] % mod + f[ls[u]][1] * f[rs[u]][1] % mod) % mod;
	}
	else {
		f[u][0] = (f[ls[u]][0] * f[rs[u]][1] % mod + f[ls[u]][1] * f[rs[u]][0] % mod + f[ls[u]][0] * f[rs[u]][0] % mod) % mod;
		f[u][1] = f[ls[u]][1] * f[rs[u]][1] % mod;
	}
}

signed main() {
	cin >> n >> (a + 1);
	int p = 0;
	_for(i, 1, n) { // 对运算符计算对应的优先级
		if (a[i] == '(') p++;
		if (a[i] == ')') p--;
		if (a[i] == '*') {
			val[++cnt] = 2 * p + 2;
			op[cnt] = 2;
		}
		if (a[i] == '+') {
			val[++cnt] = 2 * p + 1;
			op[cnt] = 1;
		}
	}
	_for(i, 1, cnt) { // 建立笛卡尔树
		int k = top;
		while (val[stk[k]] >= val[i] && k) k--;
		if (k) rs[stk[k]] = i;
		if (k < top) ls[i] = stk[k + 1];
		stk[++k] = i;
		top = k;
	}
	while (top) root = stk[top], top--;
	f[0][0] = f[0][1] = 1;
	dfs(root);
	cout << f[root][0] << endl;
}
```

---

## 作者：sjh0626 (赞：1)

## 思路分析
一道树形动规，根据题意 `*` 为与运算，`+` 为或运算，我们可以过一遍样例（`+(*)`）：

首先，我们先往一个编号栈里压入一个空节点，因为 $n$ 个操作符会有 $n+1$ 操作数。

遇到了 `+`，我们再压入一个空节点，因为前面没有 `+`，所以无法处理，直接压入符号栈。

随后，又进来了一个 `(`，因为 `(` 的优先级最低，直接压入符号栈。

遇到了 `*`，同理，压入空节点，因为前面没有比它优先级大或等于的，直接压入符号栈。

最后，到了 `)`，我们直接把前面的都处理一遍，直到左括号。

因为现在已经压入了 $3$ 个空节点，空节点为 $0$ 和 $1$ 的可能都为 $1$，直接处理 `*`，我们把栈上面两个空节点弹出，因为它们与起来的结果为 $0$ 有三种可能，与起来为 $1$ 有一种可能，所以压入一个为 $0$ 可能为 $3$，为 $1$ 可能为 $1$ 的节点。

因为符号栈里还有符号，所以我们继续处理，处理到了 `(`，不用计算，处理到了 `+`，继续弹出，它们或起来的结果为 $0$ 有 $3$ 种可能，结果为 $1$ 有 $5$ 种可能。

最终答案为 $3$。

根据样例，我们可以建一棵树，设这个节点为 $i$，左儿子为 $l$，右儿子为 $r$，推出方程，当符号为 $*$ 时，方程为：

```
dp[i][0] = dp[l][1] * dp[r][0] + dp[l][0] * dp[r][1] + dp[l][0] * dp[r][0]
dp[i][1] = dp[l][1] * dp[r][1]
```

其中 `dp[i][0]` 指编号为 $i$ 的节点为 $0$ 的可能，其他同理。

符号为 $+$ 时，方程为：

```
dp[i][1] = dp[l][1] * dp[r][0] + dp[l][0] * dp[r][1] + dp[l][1] * dp[r][1]
dp[i][0] = dp[l][0] * dp[r][0]
```

最后答案就是根节点为 $0$ 的可能性。

注意：

1. 要边运算边取模。
2. 只有为 `)` 或者符号栈顶比自己的的优先级大或等于才可以处理，计算可能性。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
#define ll long long
using namespace std;
const int P=10007;
const int N=100005;
stack<int>id;
stack<char>sta;
int n,cnt,f[N<<2][2];
void work(){
    int r=id.top();id.pop();
    int l=id.top();id.pop();
    char type=sta.top();sta.pop();
    ++cnt;
    if(type=='+')f[cnt][0]=f[l][0]*f[r][0]%P,f[cnt][1]=(((f[l][1]*f[r][1]%P)+(f[l][0]*f[r][1]%P)%P)+(f[l][1]*f[r][0]%P))%P;
    else f[cnt][1]=f[l][1]*f[r][1]%P,f[cnt][0]=(((f[l][0]*f[r][0]%P)+(f[l][0]*f[r][1]%P)%P)+(f[l][1]*f[r][0]%P))%P;
    id.push(cnt);
}
string t;
map<char,int>great; //优先级
signed main(){
    great['(']=-1,great['+']=0,great['*']=1; //处理优先级
    cin>>n>>t;
    id.push(++cnt); //插入空节点
    f[cnt][0]=f[cnt][1]=1; //初始化
    for(int i=0;i<n;i++){
        if(t[i]=='(')sta.push('(');
        else if(t[i]==')'){
            while(sta.top()!='(')work();
            sta.pop(); //处理左括号
        }
        else{
            while(sta.size()&&great[sta.top()]>=great[t[i]])work(); //遇到比自己优先级大或等于的就处理
            id.push(++cnt); //插入空节点
            f[cnt][0]=f[cnt][1]=1; //初始化
            sta.push(t[i]);
        }
    }
    while(sta.size())work(); //处理剩余
    cout<<f[cnt][0]; //输出答案
    sjh0626s code;
}
```

---

## 作者：xmy201315 (赞：1)

[前置芝士](https://oi-wiki.org/dp/tree/)

在题目中，`*`号其实为`&`，`⊕`号其实为`|`。

对于这种表达式的题目，我们一般都要建一棵表达式树。这道题我也用到了树形 DP。其实大家应该都接触到过，在题目中叫你求这颗二叉树的大小，在某种意义上也是树形 DP。怎么整呢？我们在每个子树的空格处填入 $0$ 和 $1$，得到结果 $0$ 和 $1$ 的方案数分别是多少。以下图片中的 $L_0,L_1,R_0,R_1$ 分别表示左右子树算出来为 $0$ 和 $1$ 的方案数。

![](https://cdn.luogu.com.cn/upload/image_hosting/na6oo1yq.png)

这个算出来为 $0$ 的方案数为 $L_0\cdot R_0+L_0\cdot R_1+L_1\cdot R_0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/x02o9bf5.png)

这个算出来为 $0$ 的方案数为 $L_0\cdot R_0$。

**AC code：**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 10007;
const int N = 101000;
struct info {
	int s0, s1;
};
int n, l1[N], l2[N], c1[N], c2[N];
char s[N];
info f(int l, int r) {
	info ans;
	if (l > r) {
		ans.s0 = 1;
		ans.s1 = 1;
		return ans;
	}
	if (l1[r] >= l) {
		info ansl = f(l, l1[r] - 1);
		info ansr = f(l1[r] + 1, r);
		ans.s0 = ansl.s0 * ansr.s0 % mod;
		ans.s1 = (ansl.s0 * ansr.s1 + ansl.s1 * ansr.s0 + ansl.s1 * ansr.s1) % mod;
		return ans;
	}
	if (l2[r] >= l) {
		info ansl = f(l, l2[r] - 1);
		info ansr = f(l2[r] + 1, r);
		ans.s1 = ansl.s1 * ansr.s1 % mod;
		ans.s0 = (ansl.s0 * ansr.s1 + ansl.s1 * ansr.s0 + ansl.s0 * ansr.s0) % mod;
		return ans;
	}
	if (s[l] == '(' && s[r] == ')')return f(l + 1, r - 1);
//	assert(false);
	return ans;
}
int main() {
	scanf("%d", &n);
	if (n == 0) {
		printf("1\n");
		return 0;
	}
	scanf("%s", s + 1);
	int x = 0;
	for (int i = 1; i <= n; i++) {
		if (s[i] == '(')x += 1;
		else if (s[i] == ')')x -= 1;
		else if (s[i] == '+')c1[x] = i;
		else if (s[i] == '*')c2[x] = i;
		l1[i] = c1[x];
		l2[i] = c2[x];
	}
	info ans = f(1, n);
	printf("%d", ans.s0);
} 
```

---

## 作者：MMXIandCCXXII (赞：0)

## Solution

做这种题的一个技巧就是把他当作普通的表达式求值，维护你需要的东西，根据运算规则对其操作。知道逻辑之后，代码就一目了然了。

  这道题我们维护两个东西：结果是 0 的方案数和结果是 1 的方案数。当我们遇到与的时候 0 的方案就是 00 01 10 三种情况，或的时候就是 00 一种，1 同理。乘法原理和加法原理。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 10007;
struct node
{
	int x, y;
};
stack <node> num;
stack <char> op;

void get()
{
	node b = num.top ();
	num.pop ();
	node a = num.top ();
	num.pop ();
	char c = op.top ();
	op.pop ();
	node newn;
	if (c == '+')
	{
		newn.x = a.x * b.x % mod;
		newn.y = (a.y * b.x + a.x * b.y + a.y * b.y) % mod;
	}
	else
	{
		newn.y = a.y * b.y % mod;
		newn.x = (a.y * b.x + a.x * b.y + a.x * b.x) % mod;
	}
	num.push (newn);
}

signed main()
{
	int n;
	cin >> n;
	char last = ' ';
	for (int i = 1; i <= n; i++)
	{
		char c;
		cin >> c;
		if (c == '(') op.push (c);
		else
		{
			if (last != ')') num.push ({1, 1});
			if (c == ')')
			{
				while (op.top () != '(')
					get ();
				op.pop ();
			}
			if (c == '+')
			{
				while (op.size () && op.top () != '(')
					get ();
				op.push (c);
			}
			else if (c == '*')
			{
				while (op.size () && op.top () == '*')
					get ();
				op.push (c);
			}
		}
		if (i == n && c != ')') num.push ({1, 1});
		last = c;
	}
	while (op.size ())
		get ();
	cout << num.top ().x % mod << endl;
	return 0;
}
```

---


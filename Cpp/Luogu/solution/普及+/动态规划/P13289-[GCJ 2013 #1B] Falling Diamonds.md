# [GCJ 2013 #1B] Falling Diamonds

## 题目描述

钻石正从天而降。人们开始购买钻石可能落下的位置，希望能拥有一颗真正落在那里的钻石。你现在被推荐了这样一个位置，想知道这是否值得购买。

钻石的形状，正如你所想，是菱形：对于某个中心 $(X, Y)$，它的四个顶点分别是 $(X-1, Y)$、$(X, Y+1)$、$(X+1, Y)$ 和 $(X, Y-1)$。所有的钻石都位于 $X$-$Y$ 平面上。$X$ 表示水平方向，$Y$ 表示竖直方向。地面在 $Y=0$，$Y$ 增大表示高于地面。

钻石依次沿着 $Y$ 轴落下。也就是说，它们从 $(0, Y)$（$Y$ 很大）的位置垂直下落，直到撞到地面或其他钻石为止。

当一颗钻石撞到地面时，它会继续下落，直到中心埋入地面，此时停止移动。也就是说，所有钻石只要中心到达 $Y=0$ 就会停止下落或滑动。

当一颗钻石顶点对顶点撞到另一颗钻石时，它可以开始沿着两个方向之一滑落：向左下或向右下，且不发生旋转。如果这两侧都没有被钻石挡住，则它以相等概率选择向左或向右滑落。如果某一侧被钻石挡住了，则它会一直沿着未被挡住的那一侧滑动，直到被其他钻石挡住或埋入地面。如果左右两侧都被挡住，则钻石就会停止。

![](https://cdn.luogu.com.cn/upload/image_hosting/rhq3hty8.png)

请参考上图示例。第一颗钻石落地后，中心停在 $(0, 0)$。第二颗钻石有 $50\%$ 的概率向左或向右滑落。这里它向左滑落，最终停在 $(-2, 0)$。第三颗钻石也会撞到第一颗钻石，然后要么随机向右滑落并停在地面，要么向左滑落，最终停在已存在的两颗钻石之间的上方。这里它又向左滑落，最终停在 $(-1, 1)$。第四颗钻石没有选择，只能向右滑落并停在 $(2, 0)$。


## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $-10,000 \leq X \leq 10,000$
- $0 \leq Y \leq 10,000$
- $X + Y$ 为偶数

**小数据集（14 分，测试集 1 - 可见）**

- $1 \leq N \leq 20$

**大数据集（28 分，测试集 2 - 隐藏）**

- $1 \leq N \leq 10^{6}$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
7
1 0 0
1 0 2
3 0 0
3 2 0
3 1 1
4 1 1
4 0 2```

### 输出

```
Case #1: 1.0
Case #2: 0.0
Case #3: 1.0
Case #4: 0.75
Case #5: 0.25
Case #6: 0.5
Case #7: 0.0```

# 题解

## 作者：ivyjiao (赞：0)

手模发现，钻石会形成一些层，每个层被填满之前下个层不会有钻石。

我们给每个位置分层：

1. $(0,0)$ 是第 $0$ 层。
2. $(-2,0),(0,2),(2,0)$ 是第 $1$ 层。
3. $(-4,0),(-2,2),(0,4),(2,2),(0,4)$ 是第 $2$ 层。

……

以此类推，那么位置 $(x,y)$ 属于第 $\dfrac {|x|+y}{2}$ 层，每层有 $4i+1$ 个位置。

设 $a_i$ 为第 $i$ 层及以前的位置数，那么有：

1. 若 $n\geq a_m$，该位置一定有钻石。
1. 若 $n\leq a_{m-1}$，该位置一定没有钻石。

接下来我们考虑更复杂的情况：

设 $r$ 为填满之前的层后，填当前位置的层还剩的钻石数。

先考虑简单情况，如果当前位置 $x=0$，即该位置是该层的“峰”，那么一定填不上了，因为如果填得上，与假设“该层不能完全填满”矛盾。

然后对于一般情况：

1. 如果当前该层已经填了 $2m+y$ 个钻石了，那么下一个填完后该位置一定被覆盖，因为在其之下和在其异侧的位置都已填上。
2. 否则，总共有 $2^r$ 种方案，将其中不符合条件的方案减掉（本侧只有 $0,1,\cdots,y$ 个钻石），算概率。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+1;
int t,n,x,y,a[N]={1};
double C(int n,int k){
    double ans=1;
    for(int i=1;i<=k;i++) ans*=n-i+1,ans/=i;
    return ans;
}
double solve(int n,int x,int y){
    int m=(abs(x)+y)/2;
    if(n>=a[m]) return 1;
    else if(n<=a[m-1]) return 0;
    else{
        int r=n-a[m-1];
    	if(y==2*m) return 0;
        else{
            if(r>2*m+y) return 1;
            else{
                double ans=1;
                for(int i=0;i<=y;i++) ans-=C(r,i)/pow(2,r);
                return ans;
            }
	    }
    }
}
int main(){
    cin>>t;
    for(int i=1;i<N;i++) a[i]=a[i-1]+4;
    for(int i=1;i<N;i++) a[i]+=a[i-1];
    for(int i=1;i<=t;i++){
        cin>>n>>x>>y;
        double ans=solve(n,x,y);
        cout<<"Case #"<<i<<": "<<ans<<endl;
    }
}
```

---


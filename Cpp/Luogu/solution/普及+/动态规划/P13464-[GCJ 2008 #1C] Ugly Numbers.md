# [GCJ 2008 #1C] Ugly Numbers

## 题目描述

从前在一个奇特的世界里，人们称一个数为“丑数”，如果它能被任意一个一位质数（$2$、$3$、$5$ 或 $7$）整除。因此，$14$ 是丑数，但 $13$ 不是。$39$ 是丑数，但 $121$ 不是。注意，$0$ 也是丑数。同时，负数也可以是丑数，比如 $-14$ 和 $-39$。

有一天，你闲来无事，盯着一串数字，比如：

$123456$

你很好奇，如果允许你在数字之间插入加号或减号，会有多少种可能的表达式。例如，你可以得到：

$1 + 234 - 5 + 6 = 236$

这是一个丑数。或者

$123 + 4 - 56 = 71$

这不是丑数。

计算你可以操作的方式很简单：在每两个相邻数字之间，你可以选择插入加号、减号或什么都不插。因此，如果你有 $D$ 位数字，总共可以构造 $3^{D-1}$ 个表达式。

注意，数字可以有前导零。如果字符串是 "01023"，那么 "01023"、"0+1-02+3" 和 "01-023" 都是合法表达式。

你的任务很简单：在这 $3^{D-1}$ 个表达式中，统计有多少个表达式的结果是丑数。

## 说明/提示

**限制条件**

- $0 \leq N \leq 100$。
- 每个测试用例的字符串非空，仅包含字符 '0' 到 '9'。

**小数据集（测试集 1 - 可见）**

- 每个字符串长度不超过 $13$。

**大数据集（测试集 2 - 隐藏）**

- 每个字符串长度不超过 $40$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4
1
9
011
12345```

### 输出

```
Case #1: 0
Case #2: 1
Case #3: 6
Case #4: 64```

# 题解

## 作者：luuia (赞：0)

### Solution

对于长度为 $n$ 的数字串 $s$，记第一个字符下标为 $0$。令 $f_{i,j}$ 表示将前 $i$ 个字符 $s_0s_1\cdots s_{i-1}$ 构成表达式后，其计算结果对 $210$ 取模等于 $j$ 的方案数。这里取 $210$ 是因为 $\operatorname{lcm}(2,3,5,7) = 210$。

首先预处理出任意区间 $[a,b)$ 的子串值 $g(a,b) = \bigl(s_a s_{a+1}\cdots s_{b-1}\bigr)\bmod 210$ 的数组，避免重复的字符串转整数和取模操作。

初始化时，第一段只能作为正数，若首段为 $[0,j)$，则 $f_{j,g(0,j)} = 1$。

对于每个位置 $i$（即已经处理完前 $i$ 个字符），任给一个模值 $r$ 且 $f_{i,r}>0$，枚举下一段结束位置 $j>i$ 并令 $t = g(i,j)$，则在位置 $i$ 之后有两种操作：加号或减号，分别对应转移

$$f_{j,(r + t)\bmod 210} \gets f_{i,r} + f_{j,(r + t)\bmod 210}\qquad f_{j,(r - t)\bmod 210} \gets f_{i,r} + f_{j,(r - t)\bmod 210}$$

最后的答案是对所有 $[0,209]$ 的丑数 $i$ 求和 $f_{n,i}$。时间复杂度为 $O(n^2V)$。

### Code

```cpp
/**
 *    author: luuia
 *    created: 2025.07.27 16:16:48
**/
#include<bits/stdc++.h>
using ll = long long;
#define For(i,j,k) for(int i = j;i <= k;i++)
#define Rep(i,j,k) for(int i = j;i >= k;i--)
using namespace std;
const int N = 1e6 + 10,p = 998244353;ll ct;
void sol(){string s;cin >> s;ll n = s.size();vector<vector<ll>> f(45,vector<ll>(45)),g(45,vector<ll>(210));
    For(i,0,n - 1){ll v = 0;For(j,i,n - 1) v = (v * 10 + s[j] - '0') % 210,f[i][j + 1] = v;}
    For(i,1,n) g[i][f[0][i]]++;For(i,1,n - 1) For(j,0,209){
        if(!g[i][j]) continue;For(k,i + 1,n)
            g[k][(j + f[i][k]) % 210] += g[i][j],
            g[k][(j - f[i][k] % 210 + 210) % 210] += g[i][j];
    }ll o = 0;For(i,0,209) if(!(i % 2) || !(i % 3) || !(i % 5) || !(i % 7)) o += g[n][i];
    cout << "Case #" << ++ct << ": " << o << "\n";
}int main(){
    // freopen("input.in","r",stdin);
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    ll T;cin >> T;while(T--) sol();return 0;
}
```

---


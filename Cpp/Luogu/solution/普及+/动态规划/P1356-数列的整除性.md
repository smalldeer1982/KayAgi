# 数列的整除性

## 题目描述

对于任意一个整数数列，我们可以在每两个整数中间任意放一个符号 `+` 或 `-`，这样就可以构成一个表达式，也就可以计算出表达式的值。对于一个整数数列来说，我们能通过如上的方法构造出不同的表达式，从而得到不同的数值，如果其中某一个数值能够被 $k$ 整除的话，我们就称该数列能被 $k$ 整除。现在你的任务是判断某个数列是否能被某数整除。

## 说明/提示

#### 样例输入输出 1 解释

对于整数数列：$17,5,-21,-15$，可以构造出 $8$ 个表达式：

- $17+5+(-21)+15=16$
- $17+5+(-21)-15=-14$
- $17+5-(-21)+15=58$
- $17+5-(-21)-15=28$
- $17-5+(-21)+15=6$
- $17-5+(-21)-15=-24$
- $17-5-(-21)+15=48$
- $17-5-(-21)-15=18$


该数列能被 $7$ 整除（$17+5+(-21)-15=-14$），但不能被 $5$ 整除。

#### 数据规模与约定
对于全部的测试点，保证 $1 \le n \le 10^4,2 \le k \le 100,\left| a_i \right| \le 10^4$。

- $\text{upd 2022.9.27}$：新增加一组 Hack 数据。
- $\text{upd 2023.11.29}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
2
4 7
17 5 -21 15
4 5
17 5 -21 15
```

### 输出

```
Divisible
Not divisible

```

# 题解

## 作者：LJC00118 (赞：48)

### 这道题一看就是标准的DP

### 我们可以用背包问题的思路去做

### 这个程序的优点是运行速度快，内存小

### 为什么会快而且内存小呢

\* 我们边加边模k，结果不变

\* 在读入时没有将其储存，直接DP

### 证明思路正确如下：

### 设有n个数为a1，a2，a3……，an

### 先将其全模k得到余数

### 余数相加再模k

### 若（a1+a2-a3-a4+a5+......-an）%k==0则它们的余数（b1+b2-b3-b4+b5+......-bn）%k也为0

### 因为他们都是可爱的余数......

### 这样我们只要开101的空间就够用了（k<=100）

### 以下是代码（自带注释）


```cpp
#include<bits/stdc++.h>//万能的头文件
using namespace std;
int n,k,e=0,nn;
int f[101],opt[101][2];
int main()
{
    scanf("%d",&nn);                                                                                                                                                                                    防抄袭
    for(int i=1;i<=nn;i++)//循环n次
    {
        memset(f,-1,sizeof(f));//数组清负1
        cin>>n>>k;//读入n和k
        f[0]=0;//f[0]可以做到
        for(int i=1;i<=n;i++)
        {
            int tmp;//读入n个数，基本不用内存
            scanf("%d",&tmp);
            tmp=(tmp%k+k)%k;//因为有负数，所以不能写tmp=tmp%k，-21%5=-1
            e=0;//第e个数
            for(int j=k-1;j>=0;j--)
            {
                if(f[j]==i-1)//因为我们要用上所有的数，所以在i-1个数都用上的时候才能进行下一次DP
                {                                                                                                                                                                                      防抄袭
                    opt[++e][0]=f[j];//精髓部分，用链表的思想储存
                    opt[e][1]=j;//同上
                    /*int tmp_fj=f[j];
                    f[(j+tmp)%k]=tmp_fj+1;
                    f[(j-tmp+k)%k]=tmp_fj+1;*/ 
                }
            }
            for(int j=e;j>=1;j--)
            {
                f[(opt[j][1]+tmp)%k]=opt[j][0]+1;//选择加这个数，边加边模k
                f[(opt[j][1]-tmp+k)%k]=opt[j][0]+1;//选择减这个数，边减边模k
            }
        }
        if(f[0]==n) puts("Divisible");//如果模0可以用n个数做到，输出Divisible
        else puts("Not divisible");//不说了
    }                                                                                           防抄袭
    return 0;
}
```

---

## 作者：courage (赞：35)

此题可以用动态规划解决

考虑到k比较小，令f[i][j]表示加上或减去第i个数后模k是否可能等于j，则答案为f[n][0]。

状态转移方程：f[i][j]=f[i-1][p(j-x)] or f[i-1][p(j+x)]

函数p(x)是将x模k的余数


```cpp

#include<cstdio>
#include<cstring>
int x,k,n,t;
bool f[10010][110];
int p(int x){
    x%=k;
    if (x<0) x+=k;
    return x;
}
int main(){
    scanf("%d",&t);
    while (t--){
        scanf("%d%d",&n,&k);
        memset(f,0,sizeof(f));
        scanf("%d",&x);
        f[0][p(x)]=f[0][p(-x)]=1;
        for (int i=1;i<n;i++){
            scanf("%d",&x);
            for (int j=0;j<k;j++) f[i][j]=f[i-1][p(j-x)]|f[i-1][p(j+x)];
        }
        if (f[n-1][0]) printf("Divisible\n");else printf("Not divisible\n");
    }
}

```

---

## 作者：Chloris (赞：11)

### 对于什么模什么整除之类的DP题我总是很慌张
但是像我这种蒟蒻都过了这道题是不是？大家不要害怕。看这里只有四五篇题解，就来发一波

### 思路
对于这种能否整除的DP题目，什么暴力，什么搜索都别想了（除非你真的做不出来）

所以先附上我的深搜30分代码：

~~咦？评测记录被删了？！算了，反正这个不是正解，大家一定要崇尚DP！！！~~

又找到了代码：
如下：
```cpp
#include <iostream>
#include <cstdlib> 
using namespace std;
int f[10001] = {0};
int shu[10001];
int n;
int len;
int k;
bool divisible = false;
void search(int step,int now)
{
    if(divisible == true)
    {
        return;
    }
    if(step > len)
    {
        if(now % k == 0)
        {
            divisible = true;
        }
        return;
    }
    else
    {
        search(step + 1,now + shu[step]);
        search(step + 1,now - shu[step]);       
    }
    return;
}

int main()
{
    cin >> n;
    for(int i = 1;i <= n; i++)
    {
        cin >> len >> k;
        for(int j = 1;j <= len; j++)
        {
            cin >> shu[j];
        }
        search(2,shu[1]);
        if(divisible == false)
        {
            cout << "Not divisible" << endl;
        }
        else
        {
            cout << "Divisible" << endl;
        }
        divisible = false;
    }
    return 0;
}
```

### 真正的思路：
对于这种能否整除的DP题目，我们只需要考虑前i个数通过一定的组合，mod k 能否 == j,
这就是我们要写的`状态`
```cpp
bool f[i][j]表示能否通过一定的组合将前i个数 mod k = j;
```

显而易见，最后的答案是能否通过一定的组合将前n个数 mod k = 0
也就是
```cpp
f[n][0]是否为true;

```
再考虑一下状态转移方程

我们发现：
当状态为f[i][j]时，若状态f[i][(j +- a[i] % k + k) % k] 为true，则f[i][j]也一定为true；+-里只要满足一个就可以了，所以要用||符号

最后头疼的是边界条件，卡了我很久

首先我只想到了f[0][0] = 1;

然后水了60分，（至少还有60分嘛）

然后再想想,只选一个数时，是只有正没有负的！！！！
所以容易写出如下方程：
```cpp
 f[1][(a[1] % k + k) % k] = f[1][(-a[1] % k + k) % k] = true;

```


所有情况我们都讨论完了，

贴上代码：(如果上面听懂的话，也就不用注释了，挺简单的)


```cpp
#include <bits/stdc++.h>
using namespace std;

int t,n,k;
bool f[10000 + 10][100 + 10];
int a[10000 + 10];

int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&k);
        memset(f,0,sizeof(f));
        for(int i = 1;i <= n; i++) scanf("%d",&a[i]);
        f[0][0] = 1;
        f[1][(a[1] % k + k) % k] = f[1][(-a[1] % k + k) % k] = true;
        for(int i = 2;i <= n; i++){
            for(int j = 0;j < k; j++){
                f[i][j] = (f[i - 1][((j + a[i] % k) + k) % k]) || (f[i - 1][(j - a[i] % k + k) % k]);
            }
        }
        printf("%s\n",f[n][0] == 1 ? "Divisible" : "Not divisible");
    }
    return 0;
}
```


---

## 作者：greenheadstrange (赞：8)

- 写在前面

C++负数**取模**的意义

如：
1. -5%3=-2

2. -7%7=0

3. -6%4=-2

总的来说就是小于等于0

为了避免这种尴尬

本蒟蒻运用了一个简单的方法：

```cpp
int mod(int x){
	return ((x%m)+m)%m;
}
```
- 题目分析

看这道题吧，每一个数都有两种方案，加或者减，如此一来便想到了01背包。

但是这道题还需要转化一下才能转到**01背包**

具体操作如下：

1. 定义f[i] 为能否使该序列模m为i

2. 统计出所有a[i]的和——sum

3. 将f[-sum%m]初始为1

4. 将所有的a[i]变为它自己的两倍

5. 最后判断f[0]是为1还是0

这样一来，此时的01背包变为了选a[i]则序列中a[i]的值对应为+，不选则对应为-

就成了简单的01背包了

直接看代码吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10005],f[100005],s;
int mod(int x){//负数取模
	return ((x%m)+m)%m;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		memset(f,0,sizeof(f));
		s=0;//初始化
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			a[i]=mod(a[i]);
			s=mod(s-a[i]);
			a[i]=mod(2*a[i]);
		}
		f[s]=1;
		for(int j=0;j<m;j++)//01背包
			for(int i=n;i>=1;i--)		
				if(f[j])f[mod(j+a[i])]=1;
		if(f[0])printf("Divisible\n");
		else printf("Not divisible\n");
	}
	return 0;
}
```

结束语：**01背包装不住忧伤，OI路上充满了希望**

---

## 作者：梧桐灯 (赞：3)

借着这道题，给大家讲一讲**滚动数组**的用法。

### 滚动数组可以优化空间，当DP内存存不下时，我们可以用它来优化空间。

首先我们来推一下本题式子：由于一个数前既能放加号又能放减号，所以它的正负其实并没有关系，因为**加上一个数等于减去它的相反数**

据此，我们可以容易推出DP转移式:

$$f[i][j]=f[i-1][(j+x)\% k]\ ||\ f[i-1][(j-x+k)\%k]$$

设f[i][j]表示到第i个数余数为j是否可行。

但如果此题n很大(比如十万甚至上百万），数组存不下怎么办？

我们观察DP转移式，发现这一项的f[i][j2]至于f[i-1][j1]有关，那么是否我们能只存上一次的DP结果呢？

结果是肯定的，而且我们可以利用i的奇偶来方便的存储，具体在代码中理解吧：

```cpp
memset (f, 0, sizeof (f));
f[0][0] = 1; //前0个数余数自然为0
int P = i & 1, L = P ^ 1;
memset (f[P], 0, sizeof (f[P])); //f[P]为当前这一维
for (j = 0; j < k; ++j) {
	if (i != 1)
		f[P][j] = f[L][(j - x + k) % k] || f[L][(j + x) % k];
	else
		f[P][j] = f[L][(j - x + k) % k];	
}
puts (f[n & 1][0] ? "Divisible" : "Not divisible");

```


---

## 作者：彼岸归航 (赞：3)

当我还没有学DP时，我用的是暴搜，结果当然TLE了，复杂度$O(2^n)$。  
代码就不附上了，[Chloristendika dalao](https://76527.blog.luogu.org/solution-p1356)的题解里面会有。

------------

接下来进入正题：  
## 首先这道题是明显的DP
#### 可以用$f[i]=j$来表示当余数为i时，使用了j个数字，那么当$f[0]=k$时，该数列可以被整除。
那么只要在输入每一个数时，把i从0到k-1遍历一遍并更新就可以了。  
关于余数的处理，我参考了[LJC00118 dalao](https://51815.blog.luogu.org/solution-p1356)的题解。大概意思：先直接求余，完了以后加上k确保是非负的，然后再%一遍k。  
代码：
```cpp
		scanf("%d%d",&n,&k);
        memset(f,0,sizeof(f));
        scanf("%d",&v);//因为第一个只能加，所以特殊处理
        v=(v%k+k)%k;//防止负数
        f[v]=1;//余数为v时用了一个数
        for(int i=2;i<=n;i++)
        {
            scanf("%d",&v);
            v=(v%k+k)%k;
            for(int j=0;j<k;j++)
            {
                if(f[j]==i-1)//只有当符合条件（前面的数字全部用到）时才更新
                {
                    f[(j+v)%k]=i;
                    f[((j-v)%k+k)%k]=i;
                }
            }
        }
        if(f[0]==n) printf("Divisible\n");
        else printf("Not divisible\n");
```

**但是！！**
### 考虑一下，当更新的位置正好也可以用来更新时，就会少更新，所以必须再用一个数组来存放更新的值！！！
当然也可以把f开成二维。  
最终AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int _n;//数据组数
int n,k;
int f[101][2];
int v;
int main()
{
    scanf("%d",&_n);
    while(_n--)
    {
        scanf("%d%d",&n,&k);
        memset(f,0,sizeof(f));
        scanf("%d",&v);
        v=(v%k+k)%k;
        f[v][0]=1;
        for(int i=2;i<=n;i++)
        {
            scanf("%d",&v);
            v=(v%k+k)%k;
            for(int j=0;j<k;j++)
            {
                if(f[j][0]==i-1)
                {
                    f[(j+v)%k][1]=i;
                    f[((j-v)%k+k)%k][1]=i;
                }
            }
            for(int j=0;j<k;j++)
            {
                f[j][0]=f[j][1];//把更新以后的放回去
            }
        }
        if(f[0][0]==n) printf("Divisible\n");
        else printf("Not divisible\n");
    }
    return 0;
}
```

---

## 作者：ljc20020730 (赞：3)

题目大意：在n个数间加入n-1个 + - 符号，问能否被k整除。

一开始想的是baoli但是，数据太大没有AC可能，于是就想DP

解题思路：数列的和可能有非常多种

只考虑是否能被k整除；只考虑被k除的余数。

以数列和mod k为状态：

f[i][j]表示是否存在前i个数的和被k除的余数为j的情况。

若f[i-1][j]为真，

则f[i][j+a[i]],f[i][j-a[i]]也为真。

非常容易理解，前i-1个数的余数是j那么算上第i个数a[i]的余数就是(j+a[i])mod k

（注意对j+a[i],j-a[i]取模时的运算）

如果第i-1个数和第i个数中间运算有+-，那么a[i]要正负，

我们一开始对数组全部改为正数，方便操作（否则越界201）

初始条件对a[1]进行分类：

如果a[1]<0 那么 f[1,(k+(a[1] mod k)) mod k]:=true（避免负数的干扰）

否则：f[1,a[1] mod k]:=true;

于是数列能否整除k的答案为f[n][0]


```cpp
var n,k,i,j,m,t,temp:longint;
    f:array[0..10050,0..105]of boolean;
    a:array[1..10050]of longint;
begin
 readln(m);
 for t:=1 to m do begin
 readln(n,k);
 fillchar(f,sizeof(f),false);
 for i:=1 to n do read(a[i]);
 if a[1]<0 then f[1,(k+(a[1] mod k)) mod k]:=true
 else f[1,a[1] mod k]:=true;
 for i:=2 to n do a[i]:=abs(a[i]);
 for i:=2 to n do
  for j:=0 to k-1 do
   if f[i-1,j] then begin
    f[i,(j+a[i])mod k]:=true;
    temp:=j-(a[i] mod k);
    if temp<0 then temp:=temp+k;
    f[i,temp]:=true;
   end;
 if f[n,0] then writeln('Divisible')
 else writeln('Not divisible');
 end;
end.
```

---


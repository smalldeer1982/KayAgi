# [NWRRC 2023] Game of Nim

## 题目描述

Georgiy 和 Gennady 在学习了经典的 Nim 游戏后，发明了一个新游戏。这个游戏用 $n$ 个石子进行，分为两个阶段。

在准备阶段，Georgiy 选择一个正整数 $p < n$，并在游戏场上放置一堆 $p$ 个石子。
之后，Gennady 用剩下的 $(n - p)$ 个石子，任意分成若干堆，每堆的石子数也可以任意。

例如，如果 $n = 10$ 且 $p = 2$，Gennady 可以分成：

- $8$ 堆，每堆 $1$ 个石子，
- 或 $1$ 堆 $5$ 个石子和 $1$ 堆 $3$ 个石子，
- 或 $2$ 堆 $2$ 个石子和 $4$ 堆 $1$ 个石子，
- 或 $1$ 堆 $8$ 个石子，
- 等等。

准备阶段结束后，进入 Nim 阶段。此时按照 Nim 游戏规则进行。两位玩家轮流操作，从 Georgiy 开始。每次操作，玩家必须从某一堆中取走至少一个石子，可以取任意多个，但只能从同一堆取。取走最后一个石子的玩家赢得 Nim 游戏，也就赢得整个游戏。

现在游戏刚开始，正处于准备阶段的中间：Georgiy 已经放好了 $p$ 个石子的一堆，但 Gennady 还没有把剩下的 $(n - p)$ 个石子分堆。现在 Gennady 想知道自己获胜的机会有多少。

请你计算，Gennady 有多少种方式将 $(n - p)$ 个石子分成若干堆，使得他能够赢得游戏（假设双方都会最优地进行 Nim 游戏）。

你可能知道，根据 Sprague-Grundy 理论，只有当所有堆的石子数（包括 $p$ 个石子的那一堆和 Gennady 分出的所有堆）的按位异或（XOR）结果为 $0$ 时，Gennady 才能获胜。

由于答案可能很大，请你输出答案对 $m$ 取模的结果。两种分法被认为不同，当且仅当对应的石子堆大小的多重集不同——也就是说，堆的顺序无关紧要。

## 说明/提示

在第一个样例中，Gennady 获胜的两种分法分别是：

- 一堆 $3$ 个石子和两堆 $1$ 个石子，
- 或一堆 $2$ 个石子和三堆 $1$ 个石子。

在第二个样例中，无论 Gennady 如何分配剩下的 $3$ 个石子，他都必输。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
8 3 1000```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2 1000```

### 输出

```
0```

# 题解

## 作者：xueyuhui917 (赞：1)

### 题意

两个人在玩游戏，共有 $n$ 个石子，先手已经将其中的 $p$ 个石子分成一堆，后手需要将剩下的 $n-p$ 个石子分成若干堆（假设有 $k$ 堆），然后由先手先开始操作，在这 $k+1$ 堆石子上玩 Nim 游戏，取完最后一个石子的人赢得了 Nim 游戏，也同样赢得了整个游戏。给定 $n,p$，问后手有多少种对剩下 $n-p$ 个石子分堆的方法，使得分堆后玩 Nim 游戏时，后手一定有能够赢得游戏的策略，答案对一给定常数 $m$ 取模。

### 解题过程

注意到题目中说，只有当所有石子的异或和为 $0$ 时，后手才能获胜。

也就是说，假设后手将剩下的 $n-p$ 个石子分成 $k$ 堆，第 $i$（$1 \le i \le k$）堆石子有 $a_i$ 个，则当且仅当下式满足时，这种方案才能计入答案：

$$p \ \text{xor} \ a_1 \ \text{xor} \ a_2 \ \text{xor} \ \dots \ \text{xor} \ a_k=0$$

其中 $\text{xor}$ 表示按位异或。

因为异或的逆运算还是异或，所以上式可以写成：

$$a_1 \ \text{xor} \ a_2 \ \text{xor} \ \dots \ \text{xor} \ a_k=p$$

此外，由于后手总共需要将 $n-p$ 个石子分堆，因此下式一定成立：

$$a_1+a_2+\dots+a_k=n-p$$

答案即为满足上面两个式子的方案数。

可以理解为：将 $n-p$ 拆成若干个数的和（这些加数之间无序）的形式，使得所有加数的异或和为 $p$，问有多少种方案数。

---------------------------------------------------

考虑动态规划。

记 $f_{i,j}$ 表示将 $i$ 个石子分成若干堆，使得每一堆异或和为 $j$ 的方案数。

那么考虑下一堆有几个石子，则

$$f_{i,j}=\sum_{k=1}^if_{i-k,j\ \text{xor}\ k}$$

初始状态显然是 $f_{0,0}=1;\ \forall i\ne 0,f_{0,i}=0$（$0$ 个石子分成若干堆，异或和显然只能为 $0$），最终答案是 $f_{n-p,p}$。

但可以发现这么算会算重，因为同一种方案（比如说 $k=2,\ a_1=1,\ a_2=2$）中，$a_i$ 之间是无序的（在上面那个例子中，$k=2,\ a_1=2,\ a_2=1$ 也指的是这种方案）。然而在我们的递推式中，上面两个表达会被当成两种不同的方案来计算。以计算 $f_{3,3}$ 为例：

$f_{3,3}=f_{2,2}+f_{1,1}+f_{0,0}$（$f_{2,2}$ 指第一步选 $1$ 个石子作为一堆，$f_{1,1}$ 指第一步选 $2$ 个石子作为一堆，$f_{0,0}$ 指第一步选 $3$ 个石子作为一堆）

$f_{2,2}=f_{1,3}+f_{0,0}$（$f_{1,3}$ 指这一步选 $1$ 个石子作为一堆，$f_{0,0}$ 指这一步选 $2$ 个石子作为一堆）

$f_{1,3}=f_{0,2}=0$（只能将剩下的一个石子单独作为一堆，但是异或和显然不为 $3$，所以不存在方案）

$f_{0,0}=1$

$\therefore f_{2,2}=0+1=1$（有且仅有 $k=1,\ a_1=2$ 一种方案）

$f_{1,1}=f_{0,0}=1$（只能将剩下的一个石子单独作为一堆，这也是一种方案）

$\therefore f_{3,3}=1+1+1=3$

分析一下 $f_{3,3}$ 的三种方案到底是哪来的。

1. 第一步选 $1$ 个石子作为一堆，由 $f_{2,2}$ 转移过来，$f_{2,2}$ 的方案是剩下两个石子直接作为一堆，整合得到最终方案是 $k=2,\ a_1=1,\ a_2=2$；
2. 第一步选 $2$ 个石子作为一堆，由 $f_{1,1}$ 转移过来，$f_{1,1}$ 的方案是剩下一个石子直接作为一堆，整合得到最终方案是 $k=2,\ a_1=2,\ a_2=1$；
3. 第一步选 $3$ 个石子作为一堆，由 $f_{0,0}$ 转移过来，剩下 $0$ 个石子无论怎么分，异或和只能为 $0$，最终方案是 $k=1,\ a_1=3$。

显然上面的 1、2 两种方案是重复的，只能算一种方案。但是按照现有状态定义，我们难以判断哪些方案是重复的，只好对状态定义进行修改：

记 $f_{i,j,k}$ 表示将 $i$ 个石子分成若干堆，每一堆石子数不超过 $j$，且得每一堆异或和为 $k$ 的方案数。

考虑如何计算 $f_{i,j,k}$：

- 如果剩下若干堆中，最多的一堆恰好为 $j$，则先取出这一堆，剩下 $i-j$ 个石子（当然，若 $i<j$，则无法转移，这一点虽然在代码中有体现，但在状态转移方程中不会额外注明），方案数为 $f_{i-j,j,k\ \text{xor}\ j}$。
- 否则，剩下的若干堆中，每一堆石子数均不超过 $j-1$，方案数为 $f_{i,j-1,k}$。

综上所述，$f_{i,j,k}=f_{i-j,j,k\ \text{xor}\ j}+f_{i,j-1,k}$。

初始状态为 $\forall i,f_{0,i,0}=1;\ \forall i,j,j\ne 0\implies f_{0,i,j}=0$，原因还是一样的；而答案显然是 $f_{n-p,n-p,p}$，因为总共只能操作 $n-p$ 个石子，每一堆的石子数肯定不超过 $n-p$。

这样的转移并不会算重，因为对于每一种方案，只有 $a_1 \ge a_2 \ge \dots \ge a_k$ 的方案会被算进去。因为我们可以注意到，在从前往后分石子的过程中，$j$ 一维的值不会上升。因为我们是在 $j$ 恰好等于当前需要取出来分作一堆的石子数的时候才会取出石子，所以产生的 $a_p$ 也一定符合前面的条件。也就是说，对于每一种方案 $a_1,a_2,\dots,a_k$，有且仅有将原数列从大到小排序后所得的数列会计入答案，其他均不会计入，因此不会算重。

然后就做完了。

### 代码

::::::info[提示]
1. $k$ 这一维只需要开到 $512$，因为总共 $n$ 就不超过 $500$，无论怎么异或都不会超过 $511$，当然略微开大一点也没事。
2. 时空复杂度均为 $O((n-p)^2\times K)$，其中 $K$ 是 $K$ 这一维的范围，如前面所述在 $512$ 左右，在 $2$ 秒和 $1$ GiB 的限制下可以通过。我这种写法未开 O2 时，最大用时 $1.07$ 秒，这个测试点所用空间 $496.89$ MiB，比较大。
3. 应该可以先枚举 $j$ 这一维，然后对状态转移数组进行滚动数组优化，以达到 $O((n-p)\times K)$ 的复杂度。目前还没有想到对于时间复杂度的优化方法，不过对于本题，$O((n-p)^2\times K)$ 的时空复杂度应该足够了。
::::::

```cpp line-numbers lines=8,11,21,23,27
#include <bits/stdc++.h>
using namespace std;
const int N=512;
int n,p,m,d[N][N][N];
int main()
{
	scanf("%d%d%d",&n,&p,&m);
	n-=p;//已经先将 n 减去 p，此时代码中的 n 均对应前文的 n-p
	for(int i=0;i<=n;i++)
	{
		d[0][i][0]=1;//初始化
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=0;k<N;k++)
			{
				if(i>=j)
				{
					d[i][j][k]=d[i-j][j][k^j];//状态转移方程1，别忘了判断转移是否合法的 i>=j
				}
				d[i][j][k]=(d[i][j][k]+d[i][j-1][k])%m;//状态转移方程2，别忘了取模
			}
		}
	}
	printf("%d\n",d[n][n][p]%m);//最终答案是 d[n][n][p]，实在不放心可以写 d[n][n][p]%m 或 (d[n][n][p]%m+m)%m
	return 0;
}
```

---

## 作者：Loyal_Soldier (赞：1)

### 思路

根据题意，可以转化为求剩下的 $n - p$ 个石子分成若干堆且异或结果为 $p$ 的方案数（因为 $p \oplus p = 0$）。

很显然，这就是一个 dp。

状态：$dp_{i,j}$ 表示 $i$ 个石子分成若干堆异或结果为 $j$ 的方案数，答案则为 $dp_{n - p,p}$。

状态转移方程：设 $k(k \le i)$ 为从 $i$ 新分出来的一堆石子的数量，$dp_{i,j} = dp_{i,j} + dp_{i - k,j \oplus k}$。

初始化：$dp_{0,0} = 1$。

注意，计算过程中需要取模。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int N = 600;
int n, p, mod; 
int dp[N][N];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> p >> mod;
	dp[0][0] = 1;//初始化
	for(int i = 1;i <= n - p;i ++)//i 为新分出来的一堆石子的数量
		for(int j = i;j <= n - p;j ++)//j 是石子总数
			for(int k = 0;k < 512;k ++)//k 是异或结果
				dp[j][k] = (dp[j][k] + dp[j - i][k ^ i]) % mod;//转移方程，记得取模
	cout << dp[n - p][p];//输出
	return 0;
} 
```

---

## 作者：zhanlinchuan (赞：1)

# 题解P13587 [NWRRC 2023] Game of Nim
[P13587](https://www.luogu.com.cn/problem/P13587)
## 题意
将剩余石子分为若干堆，使得所有堆的石子数（包括 $p$ 个石子的那一堆和 Gennady 分出的所有堆）的按位异或结果为 $0$，求出所有方案数。
## 思路
问题可以转化为将剩余石子分为若干堆，使得所有堆的石子数的按位异或结果为 $p$。

我们可以用动态规划解决这道题。定义 $f[j][k]$ 表示使用 $j$ 个石子分为若干堆异或和为 $k$ 的方案数。

状态转移方程：对于每个可能石子数 $i$，更新 $f[j][k]$：

$f[j][k]=f[j][k]+f[j-i][k \oplus i]$

$\oplus$ 表示异或。状态转移方程含义：添加 $i$ 个石子，异或和变化为 $k \oplus i$。

最后输出 $f[n-p][p]$ 为最终答案。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,mod;
int f[10005][512];
int main(){
	cin>>n>>p>>mod; 
	int m=n-p;
	f[0][0]=1; //初始化
	for(int i=1;i<=m;i++){
		for(int j=i;j<=m;j++){
			for(int k=0;k<512;k++){
				f[j][k]=(f[j][k]+f[j-i][k^i])%mod;
			}
		}
	}
	cout<<f[m][p]%mod;
	return 0;
}

```

---


# 序列取数

## 题目描述

给定一个长为 $n$ 的整数序列 $(n \le 1000)$，由 A 和 B 轮流取数（A 先取）。每个人可从序列的左端或右端取若干个数（至少一个），但不能两端都取。所有数都被取走后，两人分别统计所取数的和作为各自的得分。假设 A 和 B 都足够聪明，都使自己得分尽量高，求 A 的最终得分。

## 样例 #1

### 输入

```
2
1 -1
2 1 2```

### 输出

```
-1
3```

# 题解

## 作者：iwprc (赞：21)


## Part 1

- 翻了翻网上关于此题的题解，发现大都是基于多开两个数组来优化$O(n^3)$的DP,使其对每一个状态的转移复杂度由$O(n)$变为$O(1)$,但是这种方法常数过大，且相对于我接下来提出的解法，代码过于复杂，为了防止某些毒瘤出题人卡常数，卡空间，我决定写这篇题解。
- 可以发现这是一个博弈类问题，由于所有数的和一定，那么如果想要自己的数和最大，肯定要选择后手的和最小的来转移（不过好像在后面的解题过程中没有太大用处）
- 几个约定：  
   1. $a[i]$表示第$i$个数
   2. $S(i,j)=\sum_{k=i}^ja[k]$   
   3. $L(i,j)$表示此时的区间为$[i,j]$,且第$i$个数必须取
   4. $R(i,j)$表示此时的区间为$[i,j]$,且第$j$个数必须取
- 下面我们以$L(i,j)$为例，由于$a[i]$必选，所以它的后继区间是$[i+1,j]$,那么有4种转移方式
   1.  下一步自己选$a[i+1]$,则$L(i,j)=a[i]+L(i+1,j)$
   2.  下一步自己选$a[j]$,由于$a[i]$和$a[j+1]$不连续，所以不可能有一个人在一步内同时取，故此状态不合法
   3.  下一步对方选$a[i+1]$,则$L(i,j)=a[i]+S(i+1,j)-L(i+1,j)$
   4.  下一步对方选$a[j]$,则$L(i,j)=a[i]+S(i+1,j)-R(i+1,j)$
- 注意，由于3,4步已经是对方在操作，所以对方一定会选择最利于自己的决策，所以3,4要先取$\min$,再与1取$\max$
- 初始化$L(i,i)=R(i,i)=a[i]$
- 转移方程 

   1.
   $ L(i,j)=a[i]+\max\begin{cases}L(i+1,j)\\S(i+1,j)+\min\begin{cases}-L(i+1,j)\\-R(i+1,j)\end{cases}\end{cases}$  
   2.
   $ R(i,j)=a[j]+\max\begin{cases}R(i,j-1)\\S(i,j-1)+\min\begin{cases}-L(i,j-1)\\-R(i,j-1)\end{cases}\end{cases}$
- 输出$\max\{L(1,n),R(1,n)\}$ 

代码1：
```cpp
#include<cstdio>
const int N=1002;
int  T,n,i,j,len,a[N],s[N],l[N][N],r[N][N];
int max(int x,int y){
	return x>y?x:y;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(i=1;i<=n;i++){
			scanf("%d",a+i);
			s[i]=s[i-1]+a[i];
			l[i][i]=r[i][i]=a[i];
		}
        for(len=1;len<n;len++)
			for(i=1;i+len<=n;i++){
            	j=i+len;
				l[i][j]=a[i]+max(l[i+1][j],s[j]-s[i]-max(l[i+1][j],r[i+1][j]));
				r[i][j]=a[j]+max(r[i][j-1],s[j-1]-s[i-1]-max(l[i][j-1],r[i][j-1]));
			}
        printf("%d\n",max(l[1][n],r[1][n]));
	}
}
```


## Part 2
- 如果仅仅是这样，可能并没有任何优化，但是下面才是我们今天的重头戏——区间DP的滚动数组优化。有人可能会问，$i,j$都不是在每一层都$+1$，或$-1$，该如何用一维数组来存每一层的状态呢？细心的同学可能会发现，代码1中的$len$不就是满足这个条件吗？
- 下面我们重新设计状态
   1. $a[i]$表示第$i$个数
   2. $S(i,j)=\sum_{k=i}^ja[k]$   
   3. $L(i,j)$表示此时的区间为$[i,i+j]$,且第$i$个数必须取
   4. $R(i,j)$表示此时的区间为$[i,i+j]$,且第$i+j$个数必须取 
- 初始化$L(i,0)=R(i,0)=a[i]$
- 转移方程 

   1.
  	$ L(i,j)=a[i]+\max\begin{cases}L(i+1,j-1)\\S(i+1,i+j)+\min\begin{cases}-L(i+1,j-1)\\-R(i+1,j-1)\end{cases}\end{cases}$  
   2.
   $ R(i,j)=a[i+j]+\max\begin{cases}R(i,j-1)\\S(i,i+j-1)+\min\begin{cases}-L(i,j-1)\\-R(i,j-1)\end{cases}\end{cases}$
- 输出$\max\{L(1,n-1),R(1,n-1)\}$ 
   
这时候代码可能长这样：
```cpp
#include<cstdio>
const int N=1002;
int  T,n,i,j,len,a[N],s[N],l[N][N],r[N][N];
int max(int x,int y){
	return x>y?x:y;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(i=1;i<=n;i++){
			scanf("%d",a+i);
			s[i]=s[i-1]+a[i];
			l[i][0]=r[i][0]=a[i];
		}
        for(j=1;j<n;j++)
			for(i=1;i+j<=n;i++){
				l[i][j]=a[i]+max(l[i+1][j-1],s[i+j]-s[i]-max(l[i+1][j-1],r[i+1][j-1]));
				r[i][j]=a[i+j]+max(r[i][j-1],s[i+j-1]-s[i-1]-max(l[i][j-1],r[i][j-1]));
			}
        printf("%d\n",max(l[1][n-1],r[1][n-1]));
	}
}
```
然后我们就可以把$j$这一维去掉了：
```cpp
#include<cstdio>
const int N=1002;
int T,n,i,j,a[N],s[N],l[N],r[N];
int max(int x,int y){
	return x>y?x:y;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(i=1;i<=n;i++){
			scanf("%d",a+i);
			s[i]=s[i-1]+a[i];
			l[i]=r[i]=a[i];
		}
		for(j=1;j<n;j++)
			for(i=1;i+j<=n;i++){
				r[i]=a[i+j]+max(r[i],s[i+j-1]-s[i-1]-max(l[i],r[i]));
				l[i]=a[i]+max(l[i+1],s[i+j]-s[i]-max(l[i+1],r[i+1]));
                //注意要先转移r[i]，再转移l[i],因为r[i]的转移需要l[i]前一维的值
			}
		printf("%d\n",max(l[1],r[1]));
	}
}

```
- 然后就很容易地成为了此题的最快代码，希望对大家有帮助



---

## 作者：Khassar (赞：18)

**题目大意：**

一列数，两个都很聪明的人可以从任意一端取任意多个数，只能从一端取至少一个数，得分为取得的数的和，求A的得分。

**思路**

显而易见的是，无论怎么取，剩下的数列都是一段原数列的连续子序列

所以我们用d[i][j]表示第i~j个数组成的子序列，先手能取得的最大值

状态转移时，我们要枚举从左还是右取，以及取多少个，即对于断点k，剩下一个(k,j)或是(i,k)的子序列(i<=k<=j)

再用sum[i][j]表示i~j的和，则有

`d[i][j]=sum[i][j]-min(d[i+1][j],d[i+2][j],...,d[j][j],d[i][j-2],d[i][j-1],d[i][i],0);`其中 0 表示全取完。

最终答案也就为d[1][n]了


但这样是n^3的，所以我们需要一点优化。

定义`f[i][j]=min(d[i][j],d[i+1][j],d[i+2][j],...,d[j][j])

    g[i][j]=min(d[i][j],d[i][j-1],d[i][j-2],...,d[i][i])`

那么转移方程变为:`d[i][j]=sum(i,j)-min(f[i+1][j],g[i][j-1],0);`

f,g也可以在O(1)时间内递推得到：

`f[i][j]=min(d[i][j],f[i+1][j]);

g[i][j]=min(d[i][j],g[i][j-1]);`

这样时间复杂度就将为了n^2，就可以过这道题了。


代码里还有一些小注释，再有安利洛谷博客https://www.luogu.org/blog/khassar/


```cpp
//2017-12-21 21:23:24 星期四 by-z255491575
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memset((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=1005,inf=1e9;

int T,n,a[N],f[N][N],s[N],g[N][N],d[N][N];

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

signed main()
{
    T=read();
    while(T--) {
        n=read();
        Rf(i,1,n) {
            a[i]=read();
            s[i]=s[i-1]+a[i];//前缀和——sum
        }
        Rf(i,1,n) f[i][i]=g[i][i]=d[i][i]=a[i];//初始化边界
        Rf(L,1,n) {//枚举长度
            Rf(i,1,n-L) {
                R int j=i+L,m=0;
                //递推部分
                m=min(m,min(f[i+1][j],g[i][j-1]));
                d[i][j]=s[j]-s[i-1]-m;
                f[i][j]=min(d[i][j],f[i+1][j]);
                g[i][j]=min(d[i][j],g[i][j-1]);
            }
        }
        write(d[1][n]);
        putchar('\n');
    }

    return 0;
}
```

---

## 作者：zhlzt (赞：16)

### 区间 DP + 前缀和做法
如果没学过区间 DP，请先做一下 [P1880 \[NOI1995\] 石子合并](https://www.luogu.com.cn/problem/P1880) 这道区间 DP 模板题。

设 $dp_{i,j}$ 表示区间 $[i,j]$ 内先手能取到的最大得分（注意这里的先手不一定是小 A），$sum_{i,j}$ 表示区间 $[i,j]$ 内所有的数字之和，不难得出状态转移方程：
$$dp_{i,j}=sum_{i,j}-\min(0,\min_{k=i}^{j-1}dp_{i,k},\min_{k=i+1}^{j}dp_{k,j})$$
其中，$\min(0,\min\limits_{k=i}^{j-1}dp_{i,k},\min\limits_{k=i+1}^{j}dp_{k,j})$ 表示先手取完后，后手还能取到的最大得分。

很明显，上述做法的复杂度为 $O(n^3)$，过不了。我们可以加一个优化，分别用 $p_{i,j}$ 和 $q_{i,j}$ 来记录 $\min\limits_{k=i}^{j}dp_{i,k}$ 和 $\min\limits_{k=i}^{j}dp_{k,j}$ （前缀和就没必要说了吧），那么状态转移方程就可以变为：
$$dp_{i,j}=sum_{i,j}-\min(0,p_{i,j-1},q_{i+1,j})$$
然后每次再更新 $p_{i,j}=\min(p_{i,j-1},dp_{i,j})$ 和 $q_{i,j}=\min(q_{i+1,j},dp_{i,j})$ 即可。

最后答案就是 $dp_{1,n}$。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int d[1010],dp[1010][1010];
int p[1010][1010],q[1010][1010];
int main(){
	int t;scanf("%d",&t);
	while(t--){
		int n;scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&d[i]);
		for(int i=1;i<=n;i++) d[i]=d[i-1]+d[i];//前缀和
		for(int len=1;len<=n;len++){
			for(int i=1;i<=n-len+1;i++){ int j=i+len-1;
				dp[i][j]=d[j]-d[i-1]-min(0,min(p[i][j-1],q[i+1][j]));//状态转移
				p[i][j]=min(p[i][j-1],dp[i][j]); q[i][j]=min(q[i+1][j],dp[i][j]);//更新
			}
		}
		printf("%d\n",dp[1][n]);//输出答案
	} 
	return 0;
}
```

---

## 作者：onglu (赞：9)

### 分析题意：
题目给定一个序列，每个人每轮可以从两端（任选一端）取任意个数的整数，不能不取。在两个人都足够聪明的情况下，求先手的最大得分。  
  
事实上，我们很难定义足够聪明，我们唯一知道的足够聪明的定义就是，在当前情况某个人的做法会使他未来得分最高。  
也就是说如果A先取，那么A当前的做法会使未来A的得分最高。当A结束回合后，B的做法也会使未来B的得分最高。  
  
根据这个聪明的定义以及题目中给出的问题，我们可以设计出如下的动态规划方法：  
由于这个序列中的数不是A取走就是B取走，那么B先手时A的得分为**总分减去B的最高得分**，同理对于A也是。假如我们已知右边(左边)一小段B先手的最高得分，我们只需要枚举A一次性取走的数量，就能知道A的剩余得分，进而求出当前区间A的总得分，等价于枚举右（左）段，B的先手范围。  
几个dp要素：  
* dp数组$f[i,j]$表示目前区间为$[i,j]$，A先手，A的最高得分。
* 状态转移$f[i,j]=sum[i,j]-min\{{min}_{p=j-1}^{i}\{f[i,p]\},{min}_{p=i+1}^{j}\{f[p,j]\}\}$  
* 边界条件$p[i,i]=sum[i,i]$  

这样我们就能在$O(n^3)$的时间复杂度内求解原问题了，但显然不足以通过这道题目。  
  
我们考虑dp优化，对于一个区间的最小值，我想，我们不需要每次都去求它吧？  
区间最小值显然是会被重复使用多次，并且是一个可以递推的东西。我们刚刚的做法相当于在dp中加了一个暴力，而这个暴力是可以被dp求解的。  

我们可以用dp优化dp（滑稽），其实这个跟单调队列的思想很像，我们只需要维护$f[i,j]$的最小值，就能在$O(1)$的时间内转移每个状态，就能把时间复杂度优化为$O(n^2)$，前缀后缀最小值我想应该很容易想到，这里直接给出代码。  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,sum[1009],f[1009][1009];
int q[1009][1009],h[1009][1009];
int main()
{
    int Case;
    scanf("%d",&Case);
    while(Case--){
        memset(q,0x3f,sizeof q);
        memset(h,0x3f,sizeof h);
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d",sum+i);
            sum[i]=sum[i-1]+sum[i];
        }
        for(int i=1;i<=n;i++){
            for(int j=i;j>0;j--){
                f[j][i]=sum[i]-sum[j-1];
                f[j][i]=max(f[j][i],sum[i]-sum[j-1]-q[j+1][i]);
                f[j][i]=max(f[j][i],sum[i]-sum[j-1]-h[j][i-1]);
                if(j==i)q[j][i]=h[j][i]=f[j][i];
                else {
                    q[j][i]=min(q[j+1][i],f[j][i]);
                    h[j][i]=min(h[j][i-1],f[j][i]);
                }
            }
        }
        printf("%d\n",f[1][n]);
    }
    
    return 0;
}
```

---

## 作者：LZDQ (赞：8)

各位题解都十分长，很多都是直接优化暴力DP的，然而这题的一些性质可以降低思维难度。

显然这是个区间DP，如果枚举一个区间从左边或右边取多少个数，时间复杂度会很大。**考虑把取一段数改成取一个数**。

对于当前取数的人，可以在上次取的方向上继续取一个（如果没有上次取的方向就选一个），也可以扔给对手取。

根据这个可以愉快地DP。设 $f_{x,y,0}$ 为区间 $[x,y]$ 内先手取左边能得到的最大值，$f_{x,y,1}$ 同理。为了降低思维难度，设 $g_{x,y}$ 为区间内后手取的最大值。

那么转移方程是：$f_{x,y,0}=a_x+max(f_{x+1,y,0},g_{x+1,y})$

表示取了最左边的数，然后在**继续取**和**给对手取**中选一个最大的。

至于 $g_{x,y}$ 怎么求，因为最后区间会被取完，直接拿区间内的总和减去先手取走的数，剩下的就是后手取的数。也就是 $g_{x,y}=s[y]-s[x-1]-max(f_{x,y,0},f_{x,y,1})$

应该是式子最简洁的吧

代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=1005;
int n,a[MAXN],s[MAXN];
int f[MAXN][MAXN][2],g[MAXN][MAXN];
int main(){
	int t; scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1; i<=n; i++)
			scanf("%d",a+i),f[i][i][0]=f[i][i][1]=a[i],s[i]=s[i-1]+a[i];
		for(int i=1; i<n; i++){
			for(int j=1; j+i<=n; j++){
				int x=j,y=j+i;
				f[x][y][0]=a[x]+max(f[x+1][y][0],g[x+1][y]);
				f[x][y][1]=a[y]+max(f[x][y-1][1],g[x][y-1]);
				g[x][y]=s[y]-s[x-1]-max(f[x][y][0],f[x][y][1]);
			}
		}
		printf("%d\n",max(f[1][n][0],f[1][n][1]));
	}
	return 0;
}
```


---

## 作者：qwerta (赞：6)

这里是一种跟之前大佬略微不同的状态设置QAQ~~其实是从咕咕网校学来的~~

首先让我们构建暴力思路：

  设A的得分为$V_{A}$，B的得分为$V_{B}$

   **那么在（$V_{A}$-$V_{B}$）取得最大值时，有$V_{A}$最大。**

   证明：
   $V_A-V_B=V_A-(Sum-V_A)=2*V_A-Sum$

   **设$F[L][R]$为当前还剩$[L,R]$时，（先手得分-后手得分）的最大值。**

     

   若当前正在处理$F[L][R]$，那么存在三种选择方案：

 $1.$全取。

  - $F[L][R]=\sum_{i=L}^{R}v_i$
   
$2.$从左边取一些。（保留$L'$到$R$）

  - $F[L][R]=\sum_{i=L}^{L'-1}{v_i}-F[L'][R]$

$3.$从右边取一些。（保留$L$到$R'$）

  - $F[L][R]=\sum_{i=R'+1}^{R}v_i-F[L][R']$
  
```
   关于减去F[L'][R]：

   当区间转换到[L',R]时的F值，为转换后的先手-后手，也就是当前意义下的后手-先手，

   所以-（后手-先手）=先手-后手。

```


   这样，我们从小到大枚举区间，每次在这三种决策中取一种最优决策，

   最后的$max(V_A-V_B)=F[1][n]$,

   $max(V_A)=(F[1][n]+Sum)/2$。

于是我们可以较为轻松的写出O(n^3)的暴力啦！
```cpp
 1 /*
 2     qwerta
 3     P1430 序列取数
 4     Unaccepted
 5     40
 6     代码 C++，0.94KB
 7     提交时间 2018-09-19 18:57:13
 8     耗时/内存
 9     19351ms, 4628KB
10 */
11 #include<cmath>
12 #include<cstdio>
13 #include<cstring>
14 #include<iostream>
15 using namespace std;
16 #define R register
17 inline int read()
18 {
19     char ch=getchar();
20     int x=0;bool s=1;
21     while(!isdigit(ch)){if(ch=='-')s=0;ch=getchar();}
22     while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
23     return s?x:-x;
24 }
25 int s[1007];
26 int f[1007][1007];
27 //int m[1007][1007];
28 int main()
29 {
30     //freopen("a.in","r",stdin);
31     int t=read();
32     while(t--)
33     {
34         int n=read();
35         for(R int i=1;i<=n;++i)
36         s[i]=s[i-1]+read();
37         for(R int len=1;len<=n;++len)
38         for(R int l=1;l+len-1<=n;++l)
39         {
40             
41             int r=l+len-1;
42             f[l][r]=s[r]-s[l-1];
43             for(R int _l=l+1;_l<=r;++_l)
44             f[l][r]=max(f[l][r],s[_l-1]-s[l-1]-f[_l][r]);//枚举左端取数
45             for(R int _r=r-1;_r>=l;--_r)
46             f[l][r]=max(f[l][r],s[r]-s[_r]-f[l][_r]);//枚举右端取数
47             
48         }
49         printf("%d\n",(f[1][n]+s[n])>>1);
50     }
51     return 0;
52 }
```

但是想要通过$1e3$的数据，$O(n^3*t)$的时间复杂度肯定是布星的。

所以我们还需要一点儿优化。

   考虑状态数是$n^2$的，雷打不动，所以我们要将贼手伸向状态转移。

   以**从右取**为例：

   $F[L][R]=max_{R'=L}^{R-1}(S[R]-S[R']-F[L][R'])$

   $=max(S[R]-(S[R']+F[L][R']))$

   如果我们能知道$R'$在$L$到$R-1$上时，$S[R']+F[L][R']$的最小值，那么就能$O(1)$转移了。

   设

   $Min[L][R]=min_{R'=L}^{R}(S[R']+F[L][R'])$

   那么有

   $Min[L][R-1]=min_{R'=L}^{R-1}(S[R']+F[L][R'])$

   也就是说

   $Min[L][R]=min(Min[L][R-1],S[R]+F[L][R])$

   这样，在循环枚举区间的同时顺便维护一下$Min[L][R]$，就可以实现$O(1)$转移了。

   **同理**，因为在**从左取**的时候
   
   $F[L][R]=max(S[L'-1]-S[L-1]-F[L'][R])$
   
   $=max((S[L'-1]-F[L'][R])-S[L-1])$
   
   所以设一个$Max[L][R]=max_{L'=L+1}^{R}S[L'-1]+F[L'][R]$，
   
   转移时直接$F[L][R]=Max[L][R+1]-S[L-1]$即可。
   
   **其实就是把暴力中间那两句话换了种说法而已。**
```
 1 /*
 2     qwerta
 3     P1430 序列取数
 4     Accepted
 5     100
 6     代码 C++，1.63KB
 7     提交时间 2018-09-19 20:05:27
 8     耗时/内存
 9     4910ms, 12444KB
10 */
11 #include<cmath>
12 #include<cstdio>
13 #include<cstring>
14 #include<iostream>
15 using namespace std;
16 #define R register
17 inline int read()
18 {
19     char ch=getchar();
20     int x=0;bool s=1;
21     while(!isdigit(ch)){if(ch=='-')s=0;ch=getchar();}
22     while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
23     return s?x:-x;
24 }//快读（这题略卡常）
25 int s[1007];
26 int f[1007][1007];
27 int ml[1007][1007];
28 int mr[1007][1007];
29 //设ml为固定L端时的min值，mr为固定R端时的max值
30 void write(int x)
31 {
32     if(x>9)write(x/10);
33     putchar(x%10+'0');
34     return;
35 }//快写
36 int main()
37 {
38     //freopen("a.in","r",stdin);
39     int t=read();
40     while(t--)
41     {
42         int n=read();
43         for(R int i=1;i<=n;++i)
44         s[i]=s[i-1]+read();//前缀和
45         for(R int l=1;l<=n;++l)
46         {
47             f[l][l]=s[l]-s[l-1];
48             ml[l][l]=s[l]+f[l][l];
49             mr[l][l]=s[l-1]-f[l][l];
50         }//预处理
51         for(R int len=2;len<=n;++len)
52         for(R int l=1,r=len;r<=n;++l,++r)//枚举区间
53         {
54             f[l][r]=s[r]-s[l-1];
55             //mr
56             //for(R int _l=l+1;_l<=r;++_l)
57             //f[l][r]=max(f[l][r],s[_l-1]-s[l-1]-f[_l][r]);//注释掉的是原来的暴力
58             f[l][r]=max(f[l][r],mr[l+1][r]-s[l-1]);
59             //ml
60             //for(R int _r=r-1;_r>=l;--_r)
61             //f[l][r]=max(f[l][r],s[r]-s[_r]-f[l][_r]);
62             f[l][r]=max(f[l][r],s[r]-ml[l][r-1]);
63             //
64             ml[l][r]=min(ml[l][r-1],s[r]+f[l][r]);
65             mr[l][r]=max(mr[l+1][r],s[l-1]-f[l][r]);
66         }
67         int x=(f[1][n]+s[n])>>1;
68         if(x<0){putchar('-');write(-x);}
69         else write(x);
70         putchar('\n');
71         //输出答案
72     }
73     return 0;
74 }

```
[~~安利博客~~](https://www.cnblogs.com/qwerta/p/9683053.html)

~~LATEX真香~~







---

## 作者：Kelin (赞：4)

题意:两个人从序列两端取数,不限制数量,问先手最多能拿到多少分

虽然是从两端取数,但是中间任意一个子区间答案是不受影响的

所以设f[i][j]为在[i,j]先手取能得到的最高分

我们可以从[i,j]中找一个点k∈[i,j],分成[i,k],[k+1,j]

A从左边取,B获得的最小值sum(i,j)-f[i][k]

A从右边取,B获得的最小值sum(i,j)-f[k+1][j]

A直接取完,A获得的最大值sum(i,j)

我们只要求出这三个的最大值就能推出f[i][j]:

f[i][j]=max{sum(i,j)-min(f[i][k],f[k+1][j])}=sum(i,j)-min{0,f[i][k],f[k+1][j]}

这个复杂度是o(n^3)的

我们发现这个决策点k是记录下最优值的

记L[i][j]=min{f[i][i],f[i][i+1],...,f[i][j-1],f[i][j]}=min{f[i][j],L[i][j-1]}

R[i][j]=min{f[i][j],f[i+1][j],...,f[j-1][j],f[j][j]}=min{f[i][j],R[i+1][j]}

然后可以得到f[i][j]=sum(i,j)-min{0,L[i][j-1],R[i+1][j]}

这样就可以o(n^2)解决这道题了,答案f[1][n]


---

## 作者：LJ07 (赞：3)

## 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P1430)
## 思路简述
容易想到是区间dp。
 
不妨定义 

+ $a[i]$表示序列上第 $i$ 个位置上的数。

+ $f[l][r]$表示先手在区间 $[l, r]$ 的最高得分。

+ $s(l, r) = \sum_{i = l} ^ ra[i]$。

所以有 $f[l][r] = s(l, r) + \max(0, -\min(\min_{k = l}^{r - 1}f[l][k],\min_{k = l + 1}^{r}f[k][r]))$。

暴力核心代码如下：
```cpp
for (int l(n); l; --l)
	for(int r(l); r <= n; ++r) {
		f[l][r] = s[r] - s[l - 1];
		for (int k(l); k < r; ++k)
        	f[l][r] = max(f[l][r], s[r] - s[l - 1] - min(f[k + 1][r], f[l][k]));
	}
```
容易发现关于 $\min_{k = l}^{r - 1}f[l][k]$ 可以在第二层循环直接维护（不妨设为 $L$）。

而 $\min_{k = l + 1}^{r}f[k][r]$ 可以在全局开一个数组维护。即定义 $R[r] = \min_{k = l + 1}^{r}f[k][r]$。

注意到初始化 $L = 0$,$R[1..n] = 0$。

所以有 $f[l][r] = s(l, r) - \min(L, R[r])$。

每次再用 $f[l][r]$ 去更新 $L$ 和 $R[r]$。

不难发现 $f[][]$ 是无用的。
>**狗捉耗子，猫下岗了。**

于是我们就有了一个时间复杂度 $O(Tn^2)$，空间复杂度 $O(n)$ 的垃圾做法，不过可以过就是了。


## 丑陋の代码
```cpp
#include <bits/stdc++.h>
using namespace std;
namespace foi {
	#define SZ (6666666)
	unsigned char buf[SZ], *s, *t;
	#define getchar() ((s == t) && (t = buf + fread(s = buf, 1, SZ, stdin)), s == t ? EOF : *s++)
	inline int init() {
		char c; bool f(true);
		while (!isdigit(c = getchar())) f = c != '-';
		int x(c ^ 48);
		while (isdigit(c = getchar())) x = x * 10 + (c ^ 48);
		return f ? x : -x;
	}
	inline void puti(unsigned x) {if (x > 9) puti(x / 10); putchar((x % 10) ^ 48);}
	inline void outi(int x) {if (x < 0) putchar('-'), x = -x;puti(x);}
} // namespace foi
#define N (1000)
int T, n, s[N + 5], R[N + 5], ans;
signed main() {
	T = foi::init();
	while (T--) {
		n = foi::init();
		for (int i(1); i <= n; ++i) s[i] = s[i - 1] + foi::init(), R[i] = 0;
		for (int l(n); l; --l) 
			for (int r(l), L(0); r <= n; ++r) {
				ans = s[r] - s[l - 1] - min(R[r], L);
				R[r] = min(R[r], ans), L = min(L, ans);
			}
		foi::outi(ans); puts("");
	}
	return 0;
}
```

---

## 作者：cwfxlh (赞：2)

# P1430
## [题面传送门](https://www.luogu.com.cn/problem/P1430)
题不难，但翻车了，爆了 3 次零才过（太蒟了）。  
题意很简洁，这里就不说了，就是一个博弈来取数的问题，注意一个人一次可以取多个就可以了。  
那么我们来分析题目，这个博弈是不断从序列两端取数，所以随着时间的推移，序列长度一定是严格递减的，长度单调性，很明显可以联想到区间 DP，同时由于是双方不断取，所以要有两个 DP 数组，那么先搞一段出来。   
令 $dpa_{(i,j,0)}$ 为 a 先手从右边取 $[i,j]$ 时 a 的最大值。  
令 $dpb_{(i,j,0)}$ 为 b 先手从右边取 $[i,j]$ 时 b 的最大值。  
令 $dpa_{(i,j,1)}$ 为 a 先手从左边取 $[i,j]$ 时 a 的最大值。  
令 $dpb_{(i,j,1)}$ 为 b 先手从左边取 $[i,j]$ 时 b 的最大值。  
令 $q_i$ 为 i 号元素。  
令 $pre_i$ 为前缀和。  
这里要注意，取数的时候只能从一个方向取，所以要分方向取。
那么以 $dpa_{(i,j,0)}$ 为例，要么从右边取一个，然后不取了，让给 b，要么继续取，那么就可以写出来方程：   
$dpa_{(i,j,0)}=\max(dpa_{(i,j-1,0)}+q_i,pre_j-pre_{i-1}-\max(dpb_{(i,j-1,0)},dpb_{(i,j-1,1)}))$  
剩余的三个方程都差不多，就不多讲了。  
结果发现这个时间复杂度可以接受，打个代码，交一下，就 AC 了。   
附上代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[10003],pre[100003],dpa[1003][1003][2],dpb[1003][1003][2];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			pre[i]=pre[i-1]+a[i];
			dpa[i][i][0]=a[i];
			dpb[i][i][0]=a[i];
			dpa[i][i][1]=a[i];
			dpb[i][i][1]=a[i];
		}
		for(int len=2;len<=n;len++)
		{
			for(int i=1;i+len-1<=n;i++)
			{
				dpa[i][i+len-1][0]=max(pre[i+len-1]-pre[i-1]-max(dpb[i+1][i+len-1][0],dpb[i+1][i+len-1][1]),a[i]+dpa[i+1][i+len-1][0]);
				dpa[i][i+len-1][1]=max(pre[i+len-1]-pre[i-1]-max(dpb[i][i+len-2][0],dpb[i][i+len-2][1]),a[i+len-1]+dpa[i][i+len-2][1]);
				dpb[i][i+len-1][0]=max(pre[i+len-1]-pre[i-1]-max(dpa[i+1][i+len-1][0],dpb[i+1][i+len-1][1]),a[i]+dpb[i+1][i+len-1][0]);
				dpb[i][i+len-1][1]=max(pre[i+len-1]-pre[i-1]-max(dpa[i][i+len-2][0],dpb[i][i+len-2][1]),a[i+len-1]+dpb[i][i+len-2][1]);
			}
		}
		printf("%d\n",max(dpa[1][n][0],dpa[1][n][1]));
	}
	return 0;
}
```
样例数据很水，所以建议手造数据检验（不然就会像我一样爆三次零）。

---

## 作者：Ruff (赞：2)

温习了一下luogu网校,感觉Created_equal1 dalao讲的是真的好,于是就顺便写了这篇题解~~其实就是Created_equal1 的思路~~具体的代码中都有注释而且有推导      ~~蒟蒻实在不会用markdown请daolao们见谅~~

**最后祝luogu网校越办越好   ~~求过~~~~**

------------

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define maxn 1050
using namespace std;
template <typename T> inline void read(T &l)
{
    l=0;
    int w=1;
    char ch=0;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
        w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        l=(l<<1)+(l<<3)+(ch-'0');
        ch=getchar();
    }
    l*=w;
}//正经的读入优化
int t,n;
int f[maxn][maxn];
int sum[maxn];
int a[maxn];
int Maxr[maxn][maxn],Minl[maxn][maxn];
//求先手得分最大,考虑先手-后手得分最大,因为后手得分=总分数-先手得分,所以先手得分-后手得分=2*先手得分-总分数
//这是一个dp前的小技巧
int main()
{
    read(t);
    while(t--)
    {
        memset(f,0,sizeof(f));
        memset(Minl,0,sizeof(Minl));
        memset(Maxr,0,sizeof(Maxr));
        memset(sum,0,sizeof(sum));
        memset(a,0,sizeof(a));//各数组初始化
        read(n);
        for(int i=1;i<=n;i++)
        read(a[i]),sum[i]=sum[i-1]+a[i];
        /*
            首先我们可以设f[l][r]为区间l~r上先手得分-后手得分最大值；
            显然转移方程为
            考虑从左边一段取:f[l][r]=max(f[l][r],sum[l1-1]-sum[l-1]-f[l1][r]);(l+1=<l1<=r)
            同理考虑从右边取:f[l][r]=max(f[l][r],sum[r]-sum[r1]-f[l][r1]);(l=<r1<=r-1)
            那么这里为什么是减f[l][r1]呢,因为当前状态f[l][r]表示的是先手得分的最大值,
            要最大化先手得分,就是先手当前取数得到的得分-后手得分最大,即sum[r]-sum[r1]-f[l][r1]就可；
        */
        /*for (int len = 1;len <= N;++len)
	    for (int l = 1, r = len;r <= N;++l, ++r)
	    {
	        for(int l1=l+1;l1<r;l++)
	        f[l][r]=max(f[l][r],sum[l1-1]-sum[l-1]-f[l1][r]);
	        for(int r1=r-1;r1>=l;r1--)
	        f[l][r]=max(f[l][r],sum[r]-sum[r1]-f[l][r1]);
	    }
	    但我们考虑复杂度O(n^3)显然超时,所以我们考虑优化;
	    考虑设v[l][r]=sum[r]+f[l][r];
	    那么原方程(以右边为例):f[l][r]=max(f[l][r],sum[r1]-v[l][r1]);
	    我们要使f[l][r]最大显然sum[r1]为定值所以只要v[l][r1]最小;
	    考虑维护一个Min[l][r];
	    Minl[l][r]表示l~r区间内(左端点固定)最小的v[l][r];
	    所以有了Minl[l][r]的转移如下
	    Minl[l][r]=min(Minl[l][r-1],v[l][r]);
	    原方程就变为: f[l][r]=max(f[l][r],sum[r]-Minr[l][r]);
	    同理使sum[l-1]为定值,使sum[l1-1]-f[l1][r]最大
	    Maxr[l][r]表示表示l~r区间内(右端点固定)最大的v[l][r](此时v[l][r]=sum[l]-f[l][r]);
	    转移同理
	    原方程为: f[l][r]=max(f[l][r],Maxr[l][r]-sum[l-1]);
	    这样就愉快的降到n^2复杂度了;
	    代码具体如下
	    */
	    for(int i=1;i<=n;i++)
	    {
	        f[i][i]=a[i];
	        Minl[i][i]=sum[i]+f[i][i];
	        Maxr[i][i]=sum[i-1]-f[i][i];
	    }
	    for (int len = 2;len <= n;++len)//同样枚举区间但注意是从2开始
	    for (int l = 1, r = len;r <= n;++l, ++r)
	    {
                f[l][r]=sum[r]-sum[l-1];//初始化
                f[l][r]=max(f[l][r],sum[r]-Minl[l][r-1]);//注意l1和r1的范围
                f[l][r]=max(f[l][r],Maxr[l+1][r]-sum[l-1]);
                Minl[l][r]=min(Minl[l][r-1],sum[r]+f[l][r]);
                Maxr[l][r]=max(Maxr[l+1][r],sum[l-1]-f[l][r]);//Minl,Maxr的更新;
	    }
	    printf("%d\n",(f[1][n]+sum[n])/2);
	    //注意这里f[1][n]算的是先手得分-后手得分的最大值,前面我们已经推出先手得分-后手得分=2*先手得分-总分数
	    //所以先手得分最大值=(先手得分-后手得分+总分数)/2;
    }
    return 0;
}
~~~

---

## 作者：lx_zjk (赞：2)

## P1430 序列取数
---
### https://www.luogu.org/problemnew/show/P1430
题目描述：一列数，两个都很聪明的人可以从任意一端取任意多个数，只能从一端取至少一个数，得分为取得的数的和，求A的得分。
---
看到题目，拍脑子发现这道题是区间DP，但是难度却在省选级别上，果断先写了一份偏分的暴力，时间复杂度O(N^3)
如果想要你自己的分数高，那么就要max(你的分数--对方的分数)
```cpp
for(int len=1;len<=n;len++){
			for(int l=1;l+len-1<=n;l++){
				int r=l+len-1;
				dp[l][r]=sum[r]-sum[l-1];
				for(int _l=l+1;_l<=r;_l++)
					dp[l][r]=max(sum[_l-1]-sum[l-1]-dp[_l][r],dp[l][r]);	
				for(int _r=r-1;_r>=l;_r--)
					dp[l][r]=max(sum[r]-sum[_r]-dp[l][_r],dp[l][r]);
			}
		}
```
核心代码就跟普通区间DP没啥区别，但是不能过，所以就努力思考有没有可以寻找的“共用体”，这样就有了下面一份代码
```cpp
for(int l=1;l<=n;l++){
			dp[l][l]=sum[l]-sum[l-1];
			ml[l][l]=sum[l]+dp[l][l];
			mr[l][l]=sum[l-1]-dp[l][l];
		}
		for(int len=2;len<=n;len++){
			for(int l=1;l+len-1<=n;l++){
				int r=l+len-1;
				dp[l][r]=sum[r]-sum[l-1];
				dp[l][r]=max(dp[l][r],mr[l+1][r]-sum[l-1]);
             	dp[l][r]=max(dp[l][r],sum[r]-ml[l][r-1]);
             	ml[l][r]=min(ml[l][r-1],sum[r]+dp[l][r]);
             	mr[l][r]=max(mr[l+1][r],sum[l-1]-dp[l][r]);
			}
		}
```
完整的code
# code
~~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a[1010];
int dp[1010][1010],sum[1010],Min[1010][1010],p[1010][1010];
int ml[1010][1010],mr[1010][1010];
int main(){
	scanf("%d",&T);
	while(T--){
		memset(dp,0,sizeof(dp));
		memset(sum,0,sizeof sum);
		memset(ml,0,sizeof ml);
		memset(mr,0,sizeof mr);
		memset(p,0,sizeof p);
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
		for(int l=1;l<=n;l++){
			dp[l][l]=sum[l]-sum[l-1];
			ml[l][l]=sum[l]+dp[l][l];
			mr[l][l]=sum[l-1]-dp[l][l];
		}
		for(int len=2;len<=n;len++){
			for(int l=1;l+len-1<=n;l++){
				int r=l+len-1;
				dp[l][r]=sum[r]-sum[l-1];
				dp[l][r]=max(dp[l][r],mr[l+1][r]-sum[l-1]);
             	dp[l][r]=max(dp[l][r],sum[r]-ml[l][r-1]);
             	ml[l][r]=min(ml[l][r-1],sum[r]+dp[l][r]);
             	mr[l][r]=max(mr[l+1][r],sum[l-1]-dp[l][r]);
			}
		}
		printf("%d\n",(dp[1][n]+sum[n])/2);
	}
}
```

---

## 作者：glorious_dream (赞：0)

## 一道动态规划题
### 核心代码
~~~
for(int d=1 ; d<=n ; d++){
			for(int i=1 ; i+d-1<=n ; i++){
				j = i+d-1;
				s1[i][j] = max(s[i]-f[i+1][j],s1[i+1][j]); //状态转移方程
				s2[i][j] = max(-s[j-1] - f[i][j-1],s2[i][j-1]); //状态转移方程
				f[i][j] = max(s1[i][j]-s[i-1],s[j]+s2[i][j]); //状态转移方程
			}
		}
~~~
# 话不多说，总代码呈上
~~~
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N],s[N],f[N][N],s1[N][N],s2[N][N]; //数组一定要开对，不能开小
int main(){
	int t,n,j;
	scanf("%d",&t); //输入
	while(t--){
		scanf("%d",&n);
		for(int i=1 ; i<=n ; i++){ 
			scanf("%d",&a[i]);
			s[i] = s[i-1]+a[i];
		}
		for(int i=0 ; i<=n+1 ; i++){
			for(int j=0 ; j<=n+1 ; j++){
				s1[i][j] = s2[i][j] = -1e9;  //赋值成负无穷，避免越界
			}
		} 
		for(int d=1 ; d<=n ; d++){   //开始循环
			for(int i=1 ; i+d-1<=n ; i++){
				j = i+d-1;
				s1[i][j] = max(s[i]-f[i+1][j],s1[i+1][j]); //状态转移方程
				s2[i][j] = max(-s[j-1] - f[i][j-1],s2[i][j-1]); //状态转移方程
				f[i][j] = max(s1[i][j]-s[i-1],s[j]+s2[i][j]); //状态转移方程
			}
		}
		cout << (f[1][n]+s[n])/2 << endl; //最后输出结果
	}
	return 0;
}
~~~

---


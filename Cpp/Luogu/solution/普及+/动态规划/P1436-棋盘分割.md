# 棋盘分割

## 题目描述

将一个 $8\times 8$ 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的两部分中的任意一块继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘。（每次切割都只能沿着棋盘格子的边进行）。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/rxnb404s.png)

原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的平方和最小。

请编程对给出的棋盘及 $n$，求出平方和的最小值。

## 样例 #1

### 输入

```
3
1 1 1 1 1 1 1 3
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 0
1 1 1 1 1 1 0 3```

### 输出

```
1460```

# 题解

## 作者：Arcturus1350 (赞：37)

其实呢大致思路和下面的大佬们都很像。
发这篇题解的目的就是加了一点~~优化~~骗分技巧。

转移方程：

设$dp[i][j][x][y][k]$表示左上$(i,j)$，右下$(x,y)$，第$k$次割的最大面积。
则对于
## $\sum_{k=1}^{n}$
开始更新，有：(~~一口气读完这个方程~~)

#### $∑_{i=1}^{8}∑_{j=1}^{8}∑_{x=1}^{8}∑_{y=1}^{8}$       
$a=j……y-1;b=i……x-1;$
##### $dp[i][j][x][y][k]=$
##### $min($

##### $min(dp[i][j][x][a][k-1]+dp[i][a+1][x][y][0],dp[i][j][x][a][0]+dp[i][a+1][x][y][k-1]),$
##### $min(dp[i][j][b][y][k-1]+dp[b+1][j][x][y][0],dp[i][j][b][y][0]+dp[b+1][j][x][y][k-1])$
##### $);$

但是。
## 别以为推出了方程就万事大吉了！！！
您的边界条件呢（这题~~很简单~~）。
但是这题的初始化是重点！！！重点！！！重点！！！
好几篇都是6重循环暴力算的。
本宝宝：前缀和先求出来就好了。

那么好，初始化的话是要把所有左上为$(i,j)$右上为$(x,y)$,割了0次的面积求出来。这里，本宝宝用了一个前缀和的思想和容斥原理。
先在输入的时候就处理出来所有左上$(1,1)$右上$(i,j)$的得分（前缀和）；
然后利用容斥原理（具体见代码）
能少些~~三~~两个循环呢。。。
上代码（码风不好请原谅）

```cpp
//by Su Qingnian
//QAQ
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;//n是总共切的刀数
int map[9][9];//存图，价值
int sum[9][9];//前缀和数组
int dp[9][9][9][9][15];//dp暴力数组
inline void add(int i,int j)
{
//这个函数是计算前缀和数组。左上(1,1)右下(i,j)的价值
//好好想想为什么。（扩展这个点时左边矩形+右边矩形-重叠的部分+这个点的价值）
    sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+map[i][j];
    return ;
}
inline int s(int x1,int y1,int x2,int y2)
{
//这个是用来计算左上(x1,y1)右下(x2,y2)的价值
//还是容斥原理
    int now=sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];
    return now;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=8;i++)
      for(int j=1;j<=8;j++)
      scanf("%d",&map[i][j]),
      add(i,j);//输入，处理前缀和
    
//debug
//	for(int i=1;i<=8;i++,puts(""))
//	  for(int j=1;j<=8;j++)
//	  printf("%-5d ",sum[i][j]); 
//处理切0刀时各矩形价值的平方
    for(int i=1;i<=8;i++)
     for(int j=1;j<=8;j++)
       for(int x=i;x<=8;x++)
         for(int y=j;y<=8;y++)
           dp[i][j][x][y][0]+=s(i,j,x,y),
           dp[i][j][x][y][0]*=dp[i][j][x][y][0];
//dp过程，深吸一口气读完这一面方程。
	for(int k=1;k<n;k++)
      for(int i=1;i<=8;i++)
        for(int j=1;j<=8;j++)
          for(int x=i;x<=8;x++)
            for(int y=j;y<=8;y++)
            {
            	int minn=0x3f3f3f3f;
            	for(int a=j;a<y;a++)
                  minn=min(minn,min(dp[i][j][x][a][k-1]+dp[i][a+1][x][y][0],dp[i][j][x][a][0]+dp[i][a+1][x][y][k-1]));
                for(int b=i;b<x;b++)
                  minn=min(minn,min(dp[i][j][b][y][k-1]+dp[b+1][j][x][y][0],dp[i][j][b][y][0]+dp[b+1][j][x][y][k-1]));
            	dp[i][j][x][y][k]=minn;
            }
    printf("%d",dp[1][1][8][8][n-1]); 
 //输出，程序拜拜。
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：12)

嗯，看数据范围这么小，肯定搞一堆循环暴力dp。

推式子应该不是太难，设dp[k][i][j][p][q]表示从(i,j)到(p,q)中分成k个矩形最小的平方和。

那么初始化就是dp[1][i][j][p][q]=sum(i,j,p,q)^2

至于，sum可以用一个二维前缀和的预处理搞。

考虑一下具体的dp转移过程：

再枚举一个t，表示把i到p行从t行这个分成两块，一块分一次，一块分k-1次，

也表示把j到q列从t列分成两块，一块分一次，一块分k-1次

那么整个方程就很清晰了：

ChkMin(dp[tk][i][j][p][q],min(dp[tk-1][i][j][t-1][q]+dp[1][t][j][p][q],dp[1][i][j][t-1][q]+dp[tk-1][t][j][p][q]));

ChkMin(dp[tk][i][j][p][q],min(dp[tk-1][i][j][p][t-1]+dp[1][i][t][p][q],dp[1][i][j][p][t-1]+dp[tk-1][i][t][p][q]));

看起来有点对称的味道= =

至于滚动数组优化什么的，可以考虑把dp[1][][][][]用一个数组单独记录，tk与tk-1就用tk&1,tk&1^1来表示也是可以的。

但是，并没有必要。For循环比较多，可以考虑弄个#define


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define REP(i,a,b) for (int i=(a);i<=(b);i++)
#define DREP(i,a,b) for (int i=(a);i>=(b);i--)
using namespace std;
template<class T>inline void ChkMin(T &a,T b){if (b<a)a=b;}
const int N=8;
int n=8,k;
int dp[2*N][N][N][N][N];
int a[N][N],s[N][N];
int main(){
    memset(dp,0x3f,sizeof(dp));
    scanf("%d",&k);
    REP(i,1,n)REP(j,1,n)scanf("%d",&a[i][j]);
    REP(i,1,n)REP(j,1,n)s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
    REP(i,1,n)REP(j,1,n)REP(p,i,n)REP(q,j,n){
        int t=s[p][q]-s[p][j-1]-s[i-1][q]+s[i-1][j-1];
        dp[1][i][j][p][q]=t*t;
    }
    REP(tk,2,k)DREP(i,n,1)DREP(j,n,1)
        REP(p,i,n)REP(q,i,n){
            REP(t,i+1,p)ChkMin(dp[tk][i][j][p][q],min(dp[tk-1][i][j][t-1][q]+dp[1][t][j][p][q],dp[1][i][j][t-1][q]+dp[tk-1][t][j][p][q]));
            REP(t,j+1,q)ChkMin(dp[tk][i][j][p][q],min(dp[tk-1][i][j][p][t-1]+dp[1][i][t][p][q],dp[1][i][j][p][t-1]+dp[tk-1][i][t][p][q]));
        }
    printf("%d",dp[k][1][1][n][n]);
    return 0;
}
```

---

## 作者：恶灬心 (赞：8)

## ~~水题！~~
#### 看完这道题的第一感受。。
#### 首先 转移方程特别清晰，其次情况很少，或者说数据很水。
#### 一次AC后 我看到题解大多是6层暴力水过的。。 ~~我认为布星~~。


------------
好了，说正事。
我不是使用dp来做的 而是更亲民的dfs！~~（我才不会说我想出转移方程但不会dp呢。）~~
当然 我的这个dfs是为了让人更好理解 采取的较为裸的dfs 所以秒数大约0.4s左右。
感兴趣的dalao或者神犇可以加以修改。
不多说了 上代码
```
/*本篇采用了前缀和优化+最优化剪枝 有一定数学基础和dfs基础的同学基本都能秒懂*/
#include <bits/stdc++.h>
using namespace std;
long long S[20][20],ans=99999999;
int n;
inline int read()
{
	int w=1,d=0; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1; ch=getchar();}
	while(ch>='0'&&ch<='9')d=d*10+ch-'0',ch=getchar();
	return w*d;
} 
void init()
{
	n=read();
	int k;
	for(int i=1;i<=8;i++)
	for(int j=1;j<=8;j++)
	{
		k=read();
		S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+k;
        //前缀和优化 不懂的可以尝试计算一下
	}
}
long long power(int zx,int zy,int sx,int sy)
{
	long long k = S[sx][sy]-S[zx-1][sy]-S[sx][zy-1]+S[zx-1][zy-1];
	return k*k;
}
void dfs(int zx,int zy,int sx,int sy,long long sum,int cur)
{
	/*
    	重中之重的部分来了。
        首先 这道题只能按边切 所以只有横切和竖切两种情况。
        但切完之后，应该考虑继续切那半边会使答案更优。
        这是dp解法所要继续优化考虑的 这里暂且不提。
        顺带一提 dfs的变量分别为 最下角的坐标 最上角的坐标 当前值 切的个数
    */
	if(sum>ans) return ;
	if(cur==n)
	{
		sum+=power(zx,zy,sx,sy);
		ans=min(ans,sum);
		return ;
	}
	for(int i=zx;i<sx;i++)
	{
		dfs(zx,zy,i,sy,sum+power(i+1,zy,sx,sy),cur+1);
		dfs(i+1,zy,sx,sy,sum+power(zx,zy,i,sy),cur+1);
	}
	for(int i=zy;i<sy;i++)
	{
		dfs(zx,zy,sx,i,sum+power(zx,i+1,sx,sy),cur+1);
		dfs(zx,i+1,sx,sy,sum+power(zx,zy,sx,i),cur+1);
	}
}
int main()
{
	init();
	dfs(1,1,8,8,0,1);
	cout<<ans;
}
```
感谢大家关注 本蒟蒻的水题解。。

---

## 作者：zhouenji (赞：5)

看了看题解，好像并没有人写记忆化搜索的题解；那我就来一分吧

首先我们用sum[i][j][k][l] 表示左上端点为（i，j）右下端点为（k，l）这段区间内所有值的和

然后用dp[x][y][xx][yy][k]表示（x，y）到（xx，yy）内切割k次所得的最小平方和

然后用vis判重就行了

以下是代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=10;
int dp[maxn][maxn][maxn][maxn][maxn*2];
int sum[maxn][maxn][maxn][maxn];
bool vis[maxn][maxn][maxn][maxn];
int map[maxn][maxn];
int n;
void dfs(int x,int y,int xx,int yy)
{
    if(vis[x][y][xx][yy])return;vis[x][y][xx][yy]=true;
    dp[x][y][xx][yy][0]=sum[x][y][xx][yy]*sum[x][y][xx][yy];
    for(int i=x;i<xx;i++)
    {
        dfs(x,y,i,yy);dfs(i+1,y,xx,yy);
    }
    for(int i=y;i<yy;i++)
    {
        dfs(x,y,xx,i);dfs(x,i+1,xx,yy);
    }
    for(int k=1;k<=n-1;k++)
    {
        for(int i=x;i<xx;i++)
        {
            dp[x][y][xx][yy][k]=min(dp[x][y][xx][yy][k],dp[x][y][i][yy][k-1]+sum[i+1][y][xx][yy]*sum[i+1][y][xx][yy]);
            dp[x][y][xx][yy][k]=min(dp[x][y][xx][yy][k],dp[i+1][y][xx][yy][k-1]+sum[x][y][i][yy]*sum[x][y][i][yy]);
        }
        for(int i=y;i<=yy;i++)
        {
            dp[x][y][xx][yy][k]=min(dp[x][y][xx][yy][k],dp[x][y][xx][i][k-1]+sum[x][i+1][xx][yy]*sum[x][i+1][xx][yy]);
            dp[x][y][xx][yy][k]=min(dp[x][y][xx][yy][k],dp[x][i+1][xx][yy][k-1]+sum[x][y][xx][i]*sum[x][y][xx][i]);
        }
    }
}
int main()
{
    memset(dp,0x3f,sizeof(dp));
    scanf("%d",&n);
    for(int i=1;i<=8;i++)for(int j=1;j<=8;j++) scanf("%d",&map[i][j]),sum[1][1][i][j]=map[i][j];
    for(int i=1;i<=8;i++)for(int j=1;j<=8;j++) sum[1][1][i][j]+=sum[1][1][i-1][j]+sum[1][1][i][j-1]-sum[1][1][i-1][j-1];
    for(int i=1;i<=8;i++)for(int j=1;j<=8;j++)for(int k=1;k<=i;k++)for(int l=1;l<=j;l++)
    {
        sum[k][l][i][j]=sum[1][1][i][j]+sum[1][1][k-1][l-1]-sum[1][1][k-1][j]-sum[1][1][i][l-1];
    }
    dfs(1,1,8,8);printf("%d\n",dp[1][1][8][8][n-1]);
}

```

---

## 作者：clearlove7777 (赞：4)

emmmm
其实是可以看我的[一篇讲DP的博客](https://www.luogu.org/blog/handsome-only/post-suan-fa-yi-shu-yu-xin-xi-xue-jing-sai-dong-tai-gui-hua-ru-men)的来着
话说还有啊，原题不是求方差么。。。
无所谓了差不多吧，那我就按方差的来写咯。
首先我们还是要化简一下均方差的，因为打起来实在是太麻烦，这里直接写出结论吧。均方差的平方=（∑xi^2）/n-（x平均值）^2。真的是难打啊，凑合看下吧。对于这个题目来说，我们就要所开的DP数组是一个五维数组，表示一个范围（左上角横纵坐标和右下角横纵坐标以及当前分割次数），状态与状态之间是有着一定的联系的，我们将状态与状态之间的一种关系（多以方程的形式表示）称为状态转移方程。对于这个题目，记录f[x1][y1][x2][y2][k]是状态，再多开一个s[x1][y1][x2][y2]记录矩形权值和的平方，那么我们的状态转移方程可以这样写：

	f[x1][y1][x2][y2][k]=min{min(f[x1][y1][i][y2][k-1])+s[i+1][y1][x2][y2],f[i+1][y1][x2][y2][k-1])+s[x1][y1][i][y2]),min(f[x1][y1][x2][j][k-1])+s[x1][j+1][x2][y2]),f[x1][j][x2][y2][k-1])+s[x1][y1][x2][j])};

时间复杂度约为O（m^5 *n）对于这道题来说是完全odk的; 接下来上代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int sum[9][9][9][9];//记录平方和 
int dp[9][9][9][9][20];  
int num[9][9];
int main(){
    int n; 
    while(scanf("%d",&n)!=EOF){
        for(int i=1;i<=8;i++)
            for(int j=1;j<=8;j++)
                scanf("%d",&num[i][j]);
        for(int x1=1;x1<=8;x1++)
        for(int y1=1;y1<=8;y1++)
            for(int x2=1;x2<=8;x2++)
                for(int y2=1;y2<=8;y2++){
                    int t=0;
                    for(int i=x1;i<=x2;i++)
                        t+=num[i][y2];
                    if(y1==1&&x1==1)
                    sum[x1][y1][x2][y2]=sum[x1][y1][x2][y2-1]+t;  
                    else sum[x1][y1][x2][y2]=sum[1][1][x2][y2]-sum[1][1][x1-1][y2]-sum[1][1][x2][y1-1]+sum[1][1][x1-1][y1-1];  
                    dp[x1][y1][x2][y2][0]=sum[x1][y1][x2][y2]*sum[x1][y1][x2][y2];  
                }
        for(int k=1;k<n;k++)
            for(int x1=1;x1<=8;x1++)
                for(int y1=1;y1<=8;y1++)
                    for(int x2=1;x2<=8;x2++)
                        for(int y2=1;y2<=8;y2++){
                            int t=0x3f3f3f3f;
                            for(int a=x1;a<x2;a++){
                                int t1=min(dp[x1][y1][a][y2][k-1]+dp[a+1][y1][x2][y2][0],dp[a+1][y1][x2][y2][k-1]+dp[x1][y1][a][y2][0]);
                                t=min(t,t1);
                            }
                            for(int b=y1;b<y2;b++){
                                int t1=min(dp[x1][y1][x2][b][k-1]+dp[x1][b+1][x2][y2][0],dp[x1][b+1][x2][y2][k-1]+dp[x1][y1][x2][b][0]);    
                                t=min(t,t1);
                            }
                            dp[x1][y1][x2][y2][k]=t;   
                        }
        double average=(double)(sum[1][1][8][8])/n;
        average*=average;
        double ans=((double)(dp[1][1][8][8][n-1])/n)-average;
        ans=sqrt(ans);
        printf("%.3lf\n",ans);
    }
    return 0;
}
```

~~emmmm还是不要抄啊，这个输出的是方差。~~

---

## 作者：_Touch_ (赞：2)

f[x1][y1][x2][y2][k]表示左上角（x1,y1）右下角（x2,y2）的矩形是被分出来的第k个矩形时，平方和的最小值。

貌似和楼上的不一样

 

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int inf=1e9;
#define upr(i,x,y) for(int i=x;i<=y;i++)
#define dnr(i,x,y) for(int i=x;i>=y;i--)
int tp,sum[10][10],f[10][10][10][10][20];
void dn(int &x,int y){if(x>y)x=y;} 
int get(int x1,int y1,int x2,int y2){
    int tp=sum[x2][y2]+sum[x1-1][y1-1]-sum[x1-1][y2]-sum[x2][y1-1];
    return tp*tp;
}
int main(){
    freopen("1.in","r",stdin);
    int n,ans=inf;
    scanf("%d",&n);
    n--;
    upr(i,1,8) upr(j,1,8) {
        scanf("%d",&tp);
        sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+tp;
    }
    upr(i,1,8) f[i][1][8][8][1]=get(1,1,i-1,8),f[1][1][i][8][1]=get(i+1,1,8,8),
               f[1][1][8][i][1]=get(1,i+1,8,8),f[1][i][8][8][1]=get(1,1,8,i-1);
    upr(k,2,n)
    upr(x1,1,8)
    upr(y1,1,8)
    upr(x2,x1,8)
    upr(y2,y1,8){
        f[x1][y1][x2][y2][k]=inf;
        upr(i,1,x1-1) if(f[i][y1][x2][y2][k-1]) dn(f[x1][y1][x2][y2][k],f[i][y1][x2][y2][k-1]+get(i,y1,x1-1,y2));
        upr(i,x2+1,8) if(f[x1][y1][i][y2][k-1]) dn(f[x1][y1][x2][y2][k],f[x1][y1][i][y2][k-1]+get(x2+1,y1,i,y2));
        upr(i,1,y1-1) if(f[x1][i][x2][y2][k-1]) dn(f[x1][y1][x2][y2][k],f[x1][i][x2][y2][k-1]+get(x1,i,x2,y1-1));
        upr(i,y2+1,8) if(f[x1][y1][x2][i][k-1]) dn(f[x1][y1][x2][y2][k],f[x1][y1][x2][i][k-1]+get(x1,y2+1,x2,i));
        if(k==n) dn(ans,f[x1][y1][x2][y2][k]+get(x1,y1,x2,y2));
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：a___ (赞：2)

做法之前的题解都说的差不多了，基本上就是这个样子。这里再明确下思路： 
- $dp[k][x1][y1][x2][y2]$表示$(x1,y1)$和$(x2,y2)$间分成$k$部分时的最小平方和
- 初始化$$dp[1][x1][y1][x2][y2]=pf(sum(x1,y1,x2,y2));$$ 就是说分成1部分时（即不分）最小值为**区间(x1,y1)到(x2,y2)的平方**
- 递推关系式:  $dp[k][x1][y1][x2][y2]=$  
$min($  
	$$min(dp[1][x1][y1][a][y2]+dp[k-1][a+1][y1][x2][y2],$$  
        $$dp[k-1][x1][y1][a][y2]+dp[1][a+1][y1][x2][y2])(a=x1.to.x2),$$  
	$$min(dp[1][x1][y1][x2][a]+dp[k-1][x1][a+1][x2][y2],$$  
    	$$dp[k-1][x1][y1][x2][a]+dp[1][x1][a+1][x2][y2])(a=y1.to.y2)$$  
        
$)$  


这里对这个关系式进行解说：~~（终于进入正题了）~~


------------
开始，大家应该都想的是顺推，即切开，选择，再切，再选。此时，由于只能选择并切其中一块，且不能切完一块再切剩下的另一块，所以无法建立递推关系式。  
所以，我们使用逆推的方式，选择第1次切割的位置。此时，其中一块要分成$k-1$块（已求出解），而另一块就放置不切。由于有横切、竖切两种切法，所以分别用$a$枚举行、列进行切割，再比较出每种切法两种选择的小值，选用，再分别比出横竖最小值，再比较横切值和竖切值，选用最小值即可。  


最后，附上AC代码


------------
```cpp
#include<iostream>
using namespace std;
int dp[16][9][9][9][9],a[9][9],n;
#define sum(i,j,ii,jj) (a[ii][jj]-a[i-1][jj]-a[ii][j-1]+a[i-1][j-1])
#define pf(a) (a*a)
int main()
{
	int i,j,k,ii,jj,kk;
	cin>>n;
	for(i=1;i<=8;i++)
	for(j=1;j<=8;j++)
	cin>>a[i][j],a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
	for(i=1;i<=8;i++)
	for(j=1;j<=8;j++)
	for(ii=i;ii<=8;ii++)
	for(jj=j;jj<=8;jj++)
	dp[1][i][j][ii][jj]=pf(sum(i,j,ii,jj));
	for(k=2;k<=n;k++)
	for(i=1;i<=8;i++)
	for(j=1;j<=8;j++)
	for(ii=i;ii<=8;ii++)
	for(jj=j;jj<=8;jj++)
	{
		dp[k][i][j][ii][jj]=1<<30;
		for(kk=i;kk<ii;kk++)
		dp[k][i][j][ii][jj]=min(dp[k][i][j][ii][jj],min(dp[1][i][j][kk][jj]+dp[k-1][kk+1][j][ii][jj],dp[k-1][i][j][kk][jj]+dp[1][kk+1][j][ii][jj]));
		for(kk=j;kk<jj;kk++)                                                                                                                         //逆推 
		dp[k][i][j][ii][jj]=min(dp[k][i][j][ii][jj],min(dp[1][i][j][ii][kk]+dp[k-1][i][kk+1][ii][jj],dp[k-1][i][j][ii][kk]+dp[1][i][kk+1][ii][jj]));
	}
	cout<<dp[n][1][1][8][8]<<endl;
	return 0;
}
```

---

## 作者：Youngsc (赞：1)

[Youngsc](http://youngscc.github.io/)

搞不懂黑科技。。。

这是一个二维区间DP

所以数据比较小，for比较多；

f[x][y][p][q][k] 表示以（x，y）为左上端点，（p，q）为右下端点的矩形分割为k块儿的方案数

所以当K = 1时就是总分值的平方；

此处要用到二维前缀和计算任意区间分值

首先枚举你要更新的分块儿方案(放在枚举点的上边下边无所谓)

然后是枚举左上右下端点

最后枚举决策，既横着分割和纵着分割，注意是分割完之后再分割其中的一块，所以只需枚举1和k-1的情况。

然后就没有然后了。。。

代码比较丑，各位大佬凑合看。


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <string>
# include <cmath>
# include <queue>
# include <map>
# define R register
# define LL long long
# define M 100010

using namespace std;

int a[9][9],n,f[9][9][9][9][16],s[9][9];

void in(R int &a){
    char c = getchar(); R int x = 0,f = 1;
    while(c < '0'|| c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0'&&c <= '9') x = x*10+c-'0',c = getchar();
    a = x*f;
}

int main(){
    memset(f,127/3,sizeof(f));
    in(n);
    for(R int i = 1;i <= 8; ++i)
        for(R int j = 1;j <= 8; ++j)
            in(a[i][j]),
            s[i][j] = s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];

    for(R int x = 1;x <= 8;++x)
        for(R int y = 1;y <= 8; ++y)
            for(R int p = x;p <= 8; ++p)
                for(R int q = y;q <= 8; ++q){
                    R int d = s[p][q] - s[x-1][q] - s[p][y-1] + s[x-1][y-1];
                    f[x][y][p][q][] = d*d;
                }

    for(R int k = 1;k <= n;++k)
        for(R int x = 8;x >= 1;--x)
            for(R int y = 8;y >= 1; --y)
                for(R int p = x;p <= 8; ++p)
                    for(R int q = y;q <= 8; ++q)
                    {
                        for(R int g = x;g < p; ++g)
                            f[x][y][p][q][k] = min(f[x][y][p][q][k],min(f[x][y][g][q][1]+f[g+1][y][p][q][k-1],f[x][y][g][q][k-1]+f[g+1][y][p][q][1]));
                        for(R int g = y;g < q; ++g)
                            f[x][y][p][q][k] = min(f[x][y][p][q][k],min(f[x][y][p][g][1]+f[x][g+1][p][q][k-1],f[x][y][p][g][k-1]+f[x][g+1][p][q][1]));
                    }
    cout << f[1][1][8][8][n];
}
```


---

## 作者：licone (赞：1)

DP~
原题应该是NOI1999D1T2，比这道要多出一些公式推导~

用f[i][x1][y1][x2][y2]表示从左上角为(x1,y1)，右下角为(x2,y2)的矩形分割i次的最小值，然后对于每一块，有横切和纵切两类，对于每种切法，又有左边（上边）还可以再切和右边（下边）还可以再切两种，分别DP即可~

（另这道题也可以用记忆化搜索，思路和DP差不多。）




```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int n,num[9][9],k,f[15][9][9][9][9];
int cal(int u1,int v1,int u2,int v2)
{
    int ans=num[u2][v2]-num[u1-1][v2]-num[u2][v1-1]+num[u1-1][v1-1];
    return ans*ans;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=8;i++)
      for(int j=1;j<=8;j++)
      {
          scanf("%d",&k);
          num[i][j]=num[i][j-1]+k;
      }
    for(int i=2;i<=8;i++)
      for(int j=1;j<=8;j++) num[i][j]+=num[i-1][j];
    for(int x1=1;x1<=8;x1++)
      for(int y1=1;y1<=8;y1++)
        for(int x2=x1;x2<=8;x2++)
          for(int y2=y1;y2<=8;y2++) f[0][x1][y1][x2][y2]=cal(x1,y1,x2,y2);
    for(int i=1;i<n;i++)
      for(int x1=1;x1<=8;x1++)
        for(int y1=1;y1<=8;y1++)
          for(int x2=x1;x2<=8;x2++)
            for(int y2=y1;y2<=8;y2++)
            {
                f[i][x1][y1][x2][y2]=999999999;
                for(int k=y1;k<y2;k++) f[i][x1][y1][x2][y2]=min(f[i][x1][y1][x2][y2],min(f[i-1][x1][y1][x2][k]+f[0][x1][k+1][x2][y2],f[0][x1][y1][x2][k]+f[i-1][x1][k+1][x2][y2]));
                for(int k=x1;k<x2;k++) f[i][x1][y1][x2][y2]=min(f[i][x1][y1][x2][y2],min(f[i-1][x1][y1][k][y2]+f[0][k+1][y1][x2][y2],f[0][x1][y1][k][y2]+f[i-1][k+1][y1][x2][y2]));
            }
    printf("%d\n",f[n-1][1][1][8][8]);
    return 0;
}
```

---

## 作者：crashed (赞：0)

# 分析：
这道题其实就是区间DP的二维化嘛......  
所以可以直接得到状态：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP( i, j, x, y, k )$：原棋盘上以$(i, j)$为左上角，$(x, y)$为右下角的矩形分割$k$次的最小平方和。  
以及转移方程：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$score(i, j, x,y)$：  原棋盘上以$(i, j)$为左上角，$(x, y)$为右下角的矩形的分值。   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(i, j, x, y, k)=min\{min_{p=i}^{x-1}\{min{\{score(i,j,p,y)^2+DP(p+1,j,x,y,k-1),DP(i,j,p,y,k-1) + score( p + 1, j, x, y )^2\}}\},min_{p=j}^{y-1}\{min\{score( i, j, x, p )^2 + DP(i,p+1,x,y,k-1), DP(i,j,x,p,k-1) + score( i, p + 1, x, y )^2\}\}\}$  
看着很长，其实写起来不~~很~~费劲。  
答案：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ans=DP(1,1,8,8,N-1)$  
时间复杂度：$O(8^5\times N)$  
空间复杂度：$O(8^4\times N)$
# 代码:
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXSIZ = 15, MAXN = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

LL DP[MAXSIZ][MAXN][MAXN][MAXN][MAXN];
int board[MAXSIZ][MAXSIZ], preSum[MAXSIZ][MAXSIZ];
int N;

LL sqr( const LL num )
{
	return num * num;
}

LL getSum( const int lx, const int ly, const int rx, const int ry )
{
	return preSum[rx][ry] - preSum[lx - 1][ry] - preSum[rx][ly - 1] + preSum[lx - 1][ly - 1];
}

int main()
{
	read( N );
	for( int i = 1 ; i <= 8 ; i ++ )
	{
		for( int j = 1 ; j <= 8 ; j ++ )
		{
			read( board[i][j] );
			preSum[i][j] = preSum[i][j - 1] + board[i][j];
		}
		for( int j = 1 ; j <= 8 ; j ++ )
		{
			preSum[i][j] += preSum[i - 1][j];
		}
	}
	memset( DP, 0x3f, sizeof( DP ) );
	for( int i = 8 ; i >= 1 ; i -- )
	{
		for( int x = i ; x <= 8 ; x ++ )
		{
			for( int j = 8 ; j >= 1 ; j -- )
			{
				for( int y = j ; y <= 8 ; y ++ )
				{
					DP[i][j][x][y][0] = sqr( getSum( i, j, x, y ) );
					for( int k = 1 ; k < N ; k ++ )
					{
						for( int p = i ; p < x ; p ++ )
						{
							DP[i][j][x][y][k] = MIN( DP[i][j][x][y][k], MIN( sqr( getSum( i, j, p, y ) ) + DP[p + 1][j][x][y][k - 1], DP[i][j][p][y][k - 1] + sqr( getSum( p + 1, j, x, y ) ) ) );
						}
						for( int p = j ; p < y ; p ++ )
						{
							DP[i][j][x][y][k] = MIN( DP[i][j][x][y][k], MIN( sqr( getSum( i, j, x, p ) ) + DP[i][p + 1][x][y][k - 1], DP[i][j][x][p][k - 1] + sqr( getSum( i, p + 1, x, y ) ) ) );
						}
					}
				}
			}
		}
	}
	write( DP[1][1][8][8][N - 1] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：Memorize (赞：0)

主要思路和楼下一样  不过要注意读题 题目描述是每次分割出两个矩形后只能选一个继续分割 不能分割完一个后在分割另一个（就是在这里WA了...） 容易想到dp[i][j][i1][j1][k]表示以i j为左上角 i1 j1 为右下角分割k次的最小值 那么在初始化一下dp[i][j][i1][j1][0]和讨论横向切割和纵向切割的情况 在这两种情况之间在讨论哪一块不切 哪一块继续切即可(附上代码 预处理很暴力 建议参考楼下lncone的处理 挺聪明的)

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
int n;
int map[10][10],sum[10][10];
int dp[10][10][10][10][20];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=8;i++)
     for(int j=1;j<=8;j++) scanf("%d",&map[i][j]);
    for(int i=1;i<=8;i++)
     for(int j=1;j<=8;j++)
      for(int i1=i;i1<=8;i1++)
       for(int j1=j;j1<=8;j1++)
       {
            for(int a=i;a<=i1;a++)
          for(int b=j;b<=j1;b++) 
           dp[i][j][i1][j1][0]+=map[a][b];
         dp[i][j][i1][j1][0]=dp[i][j][i1][j1][0]*dp[i][j][i1][j1][0];  
       }        
    for(int k=1;k<n;k++)
     for(int i=1;i<=8;i++)
      for(int j=1;j<=8;j++)
       for(int i1=i;i1<=8;i1++)
        for(int j1=j;j1<=8;j1++)
        {
          dp[i][j][i1][j1][k]=2102365841;    
          //纵向切割
          for(int a=j;a<j1;a++)
            dp[i][j][i1][j1][k]=min(dp[i][j][i1][j1][k],min(dp[i][j][i1][a][k-1]+dp[i][a+1][i1][j1][0],dp[i][j][i1][a][0]+dp[i][a+1][i1][j1][k-1]));
          //横向切割
          for(int b=i;b<i1;b++)
            dp[i][j][i1][j1][k]=min(dp[i][j][i1][j1][k],min(dp[i][j][b][j1][k-1]+dp[b+1][j][i1][j1][0],dp[i][j][b][j1][0]+dp[b+1][j][i1][j1][k-1]));
        }   
    printf("%d",dp[1][1][8][8][n-1]);    
    return 0;
}
```

---


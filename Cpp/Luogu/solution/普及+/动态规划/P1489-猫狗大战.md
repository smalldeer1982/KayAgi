# 猫狗大战

## 题目描述

新一年度的猫狗大战通过 SC（星际争霸）这款经典的游戏来较量，野猫和飞狗这对冤家为此已经准备好久了，为了使战争更有难度和戏剧性，双方约定只能选择 Terran（人族）并且只能造机枪兵。

比赛开始了，很快，野猫已经攒足几队机枪兵，试探性的发动进攻；然而，飞狗的机枪兵个数也已经不少了。野猫和飞狗的兵在飞狗的家门口相遇了，于是，便有一场腥风血雨和阵阵惨叫声。由于是在飞狗的家门口，飞狗的兵补给会很快，野猫看敌不过，决定撤退。这时飞狗的兵力也不足够多，所以没追出来。

由于不允许造医生，机枪兵没办法补血。受伤的兵只好忍了。

现在，野猫又攒足了足够的兵力，决定发起第二次进攻。为了使这次进攻给狗狗造成更大的打击，野猫决定把现有的兵分成两部分，从两路进攻。由于有些兵在第一次战斗中受伤了，为了使两部分的兵实力平均些，分的规则是这样的：

1. 两部分兵的个数最多只能差一个；
2. 每部分兵的血值总和必须要尽可能接近。

现在请你编写一个程序，给定野猫现在有的兵的个数以及每个兵的血格值，求出野猫按上述规则分成两部分后每部分兵的血值总和。

## 说明/提示

TO 狗狗：这道题的数据范围我已经尽量按星际的游戏规则来了，如果你再固执于由于机枪兵的攻击力一定使不能达到某些血格值或者游戏中一定要造农民不能使机枪兵的人数达到 $200$ 的话，我只能决定将那场猫狗大战的录像公开于世人了！！！


## 样例 #1

### 输入

```
3
35
20
32
```

### 输出

```
35 52```

# 题解

## 作者：vegetabird (赞：38)

#为什么没有人写暴力？

直接暴力二维背包出$x$个人$y$点血是否可行，

然后在有$\frac{n}{2}$人且可行的方案中暴力选出最符合题意的血量。

CODE:
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<utility>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#include<set>
using namespace std;
int n;
int a[210],f[8010][110];
int main(){
    register int i,j,k,sum=0,ans=0x3fffffff;
    scanf("%d",&n);
    f[0][0]=1;
    for(i=1;i<=n;i++){
        scanf("%d",a+i);
        for(j=5000;j>=a[i];j--){
            for(k=100;k>=1;k--){
                f[j][k]=max(f[j][k],f[j-a[i]][k-1]);
            }
        }
        sum+=a[i];
    }
    for(i=0;i<=5000;i++){
        if(f[i][n/2]){
            if(ans>abs(i*2-sum)){
                ans=abs(i*2-sum);
            }
        }
    }
    printf("%d %d\n",(sum-ans)/2,(sum+ans)/2);
}
```

---

## 作者：MichaelYoung (赞：16)

虽然第一次看到题就知道是DP，但想了30min都无思路，于是就想到了随机化。
为什么这样想呢？可以知道，每只猫不是在A组就是在B组，于是可以设在A组的猫为1，B组为0.其中，1的总数是n/2,0的总数是n-1的总数。那么，我们就可以生成一个序列里有n/2个1，其余为0.用random_shuffle()来随机，如果数组中元素是1，那么表示这只猫在A组，反之，在B组。
虽然n=200,但是由于组合数学我们可以知道，一共多少组排列其实并不多，所以，只需要适当调参，估算大概不超时，尽可能多的计算几次。
### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
bool xs[201];
int a[201];
int main()
{
	int n;
	scanf("%d",&n);
	int m=n/2;
	int cnt=0,sum=0;
	for(int i=1;i<=n;i++)
	{
		cnt++;
		scanf("%d",&a[i]);
		sum+=a[i];
		if(cnt<=m)xs[i]=1;
		else xs[i]=0;
	}
	int ans=0x3f3f3f3f;
	int ans1,ans2;
	for(int t=1;t<=150000;t++)
	{
		random_shuffle(xs+1,xs+n+1);
		int ansA=0,ansB=0;
		for(int i=1;i<=n;i++)
		{
			if(xs[i])ansA+=a[i];
			else ansB+=a[i];
		}
		ans=min(ans,abs(ansA-ansB));
	}
	ans1=(sum-ans)/2;
	ans2=sum-ans1;
	printf("%d %d",ans1,ans2);
	return 0;
}
```


---

## 作者：i207M (赞：6)

## 题意

给定N个数，要求分成两组，每组数量相差不大于1，且使两组数的和的差最小；

$N<=200,Sum<=8000$

## 方法

肯定想到是DP；（可行性DP）

如何设计状态？

因为我们要知道选几个，选出来的总和多少，定义状态为$f[i][j]$表示**选出来**i个，总和为j是否可行；

设计方程时发现，如果我们不知道选的是那几个，我们就不知道接下来要枚举什么，我们可以设$f[k][i][j]$表示在前k个数字中，**选出来**i个，总和为j是否可行；

空间爆炸，考虑优化；第一位可以滚动掉，另外的可以用bitset加速；

## 贪心

但是 

我们可以：

1. 我们先自由的把它们分为两组，并求出此时的差 ；
2. 
我们逐个进行比较：
如果交换两个数可以使差变小，就swap（a[i],b[j]）; 

~~没错，一道dp就让我这么机智的贪心过了~~

## 代码

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof(x))
#define mem1(x) memset((x),0x3f,sizeof(x))
#define pb push_back
#define gc getchar
template<class T>void in(T &x) {
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
#define N 210
int n;
int w[N];
bitset<8010>f[N];
int sum;
signed main() {
    in(n);
    for (ri i = 1; i <= n; ++i) {
        in(w[i]);
        sum += w[i];
    }
    f[0][0] = 1;
    for (ri i = 1; i <= n; ++i) {
        for (ri j = i; j >=1; --j) {
            f[j] |= (f[j - 1] << w[i]);
            /*printf("\nV %d %d:",i,j);
            for(ri k=0;k<=sum;++k){
            	cout<<f[j][k]<<' ';
			}*/
        }
    }
    int hlf = sum >> 1;
    for (ri i = 0; hlf + i <= sum; ++i) {
        if (f[n >> 1][hlf + i]) {
            printf("%d %d", sum - hlf - i, hlf + i);
            return 0;
        }
        if (f[n >> 1][hlf - i]) {
            printf("%d %d", hlf - i, sum - hlf + i);
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：danefishhh (赞：5)

看了题解发现好多都能被hack掉
原因是在最后的枚举答案输出的时候
因为是拿 (tot / 2) 作为上界，要找第一个较小的那个血值总和，但是当 n 是奇数时，较小的血值总和有可能是由 (n / 2 + 1) 个人组成的。
解决方法见代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int n, tot, ans;
int a[210], f[210][8010];
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++) {
		scanf("%d", &a[i]);
		tot += a[i];
	}
	f[0][0] = 1;
	for(int i = 1; i <= n ; i ++) {
		for(int j = (n >> 1) + 1; j >= 1; j --) {
			for(int k = tot; k >= a[i]; k --) {
				f[j][k] |= f[j - 1][k - a[i]];
			}
		}
	}
	for(int i = tot >> 1; i >= 0; i --) {
		if(f[n >> 1][i]) {
			printf("%d %d", i, tot - i);
			return 0;
		} else if(n % 2) {
			if(f[(n >> 1) + 1][i]) {
				printf("%d %d", i, tot - i);
				return 0;
			}

		}
	}
}
```


---

## 作者：caddy (赞：4)

###如楼上所说 是个**bool dp**

###**f[i][j][k]**中 i，j表示 两队的血量，k表示i比j多几个人

###对于一个数，要么加入第一个，要么加入第二个

###**转移方程**             **dp[i][j][k]=dp[i-h[i]][j][k-1]  | dp[i][j-h[i][k+1] **

### 注意 k=0    i，j互换位置 ，k=1；

### **优化 我们只关心 全用万的情况 故 i+j=sum**

贴代码

    
```cpp
#include"bits/stdc++.h"
using namespace std;
int n,h[205];
bool dp[8000][500][14];//卡数据
int sum,ans=9999,r1,r2;
int Min(int x,int y)
{
    return (x<y)?x:y;
}
int main()
{
    int i,p,s,k;
    scanf("%d",&n);
    dp[0][0][0]=1;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&h[i]);
        sum+=h[i];
        for(p=sum-h[i];p>=0;p--)
          for(k=10;k>=0;k--)
          {
              s=sum-h[i]-p;
              if(dp[p][s][k])
              {
              dp[p+h[i]][s][k+1]=1;//方程
              if(k>0)
              dp[p][s+h[i]][k-1]=1;
              else
              dp[s+h[i]][p][1]=1;
              }
          }
    }
    for(int i=sum;i>=0;i--)
        {
            if(dp[i][sum-i][0]||dp[i][sum-i][1])
            {
                ans=Min(ans,abs(i-sum+i));
            }
        }
//        cout<<ans;
    for(int i=sum;i>=0;i--)//输出最小值
        {
            if(dp[i][sum-i][0]||dp[i][sum-i][1])
//            printf("%d,%d,%d %d   ",i,sum-i,dp[i][sum-i][0],dp[i][sum-i][1]);
            if(abs(i-sum+i)==ans)
            {
            printf("%d %d",Min(i,sum-i),sum-Min(i,sum-i));
//            printf("ok");
            return 0;
            }
        }    
}
//dp[r][j]=dp[r-h[i]][j]|dp[r][j-h[i]];
```

---

## 作者：HDZmessi (赞：3)

这道题其实第一眼看不出来咋做，有点像贪心但好像求具体数据的类型题目又不是贪心，于是就尝试了一下爆搜。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[205],k,ans=2e9,sum,vis[205];
void dfs(int num,int step){
	if(num>ans) return ;
	if(step==k){
		ans=min(max(num,sum-num),ans);
		return ;
	}
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		vis[i]=1;
		dfs(num+a[i],step+1);
		vis[i]=0;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
	} 
	if(n&1) k=n/2+1;
	else k=n/2;
	dfs(0,0);
	cout<<sum-ans<<' '<<ans;
	return 0;
} 
```
爆搜很好写，那超时怎么解决？于是就想了想记忆化，那记忆化大概率就是 dp 了，毕竟是道绿题。

正如大家所说这是一个 bool dp（可行性 dp）。

如何定义状态呢，发现他问我们人数并且要求血量差最少，于是大概就知道至少要两个维度，人数和血量，于是可以得出状态：$dp_{i,j}$ 表示某一队选了 $i$ 个人（猫）血量和为 $j$ 的情况是否可行，慢慢地就像一个背包了，再仔细想想就能得出转移方程：

$$dp_{i,j}=dp_{i,j} \operatorname{or} dp_{i-1,j-a_{k}}$$

注意：最后输出需要小的先输出：

CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[205],k,ans,sum=2e9,dp[205][8005],reward;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		reward+=a[i];
	}
	dp[0][0]=1; 
	for(int k=1;k<=n;k++){
		for(int i=n/2+1;i>=1;i--){
			for(int j=8000;j>=a[k];j--){
				dp[i][j]=(dp[i][j] | dp[i-1][j-a[k]]);
			}
		}
	}
	for(int j=0;j<=8000;j++){
		if(dp[n/2][j]){
			if(sum>abs(2*j-reward)){
				ans=j;
				sum=abs(2*j-reward);
			}
		}
	}
	cout<<min(ans,reward-ans)<<' '<<max(ans,reward-ans);
	return 0;
} 
```
完结撒花~给个赞（过）吧

---

## 作者：Rieman_sum (赞：2)

## 题目描述

有一些数，任意选一些数并把它们分成两组，使得两组数之和的差最小，而且你要保证两组数的数字数量之差不大于 $1$ 才行。

## 题目思路

对于每个输入的数，依次枚举数字数量和数字个数。至于状态转移方程，就是取原来的还是选这个数字？如果选，那么总和就加上这个数字，总数字数量就要加一。

我们再看后面，用打擂台的方法算出差的最小值。最后算出两组数的和。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,f[8001][101],sum,ans=2e9;
int main()
{
    cin>>n;
    f[0][0]=1;//切记初始化
    for(int i=1;i<=n;i++)
	{
        cin>>a;
        for(int j=8000;j>=a;j--)//40*200=8000
		{
            for(int k=100;k>=1;k--) f[j][k]=max(f[j][k],f[j-a][k-1]);//枚举数字、个数
        }
        sum+=a;//总数加上。这个和后面会用到
    }
    for(int i=0;i<=8000;i++)
	{
        if(f[i][n/2])//人数要控制。如果有一边人数大于二分之一，就无法满足“两部分兵的个数最多只能差一个”
		{
            if(ans>abs(i*2-sum)) ans=abs(i*2-sum);//ans用来记录最小的两组数的差
        }
    }
   	cout<<(sum-ans)/2<<' '<<(sum+ans)/2<<endl;//和差问题算出两组数的和各是多少
    return 0;
}
```

## 总结

本题考查动态规划以及贪心。

---

## 作者：Lyco_Reco (赞：2)

注意到 $n\le200$，考虑模拟退火。

每次随机交换两个数，记录最优解即可。

注意当 $n=1$ 时会死循环，别忘特判。
```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <cstdio>
#include <deque>
#include <queue>
#include <iomanip>
#include <map>
#include <unordered_map>
#include <random>
using namespace std;
#define int long long
#define inf 0x7f7f7f7f
#define maxn 210
int n,s,a[maxn],p[maxn],ans=inf,x,y;
mt19937 rng(142857);
namespace Main{
	int rd(){
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9'){
			if(ch=='-'){
				f=-1;
			}
			ch=getchar();
		}
		while(ch>='0'&&ch<='9'){
			x=x*10+ch-'0';
			ch=getchar();
		}
		return x*f;
	}
	void wrt(int x){
		int y=10,len=1;
		if(x<0){
			x=-x;
			putchar('-');
		}
		while(y<=x){
			len++;
			y*=10;
		}
		while(len--){
			y/=10;
			putchar(x/y+'0');
			x%=y;
		}
	}
	int calc(){
		int cnt=0;
		for(int i=1;i<=(n>>1);i++){
			cnt+=a[p[i]];
		}
		return cnt;
	}
	void sa(){
		int t=5000,t0=0.997,eps=1e-15;
		while(t>eps){
			int xx,yy;
			xx=rng()%n+1;
			do{
				yy=rng()%n+1;
			}while(xx==yy);
			swap(p[xx],p[yy]);
			int tmp=calc();
			int now=abs(s-(tmp*2));
			int delta=now-ans;
			if(delta<0){
				ans=now;
				x=tmp;
				y=s-tmp;
			}
			else if(exp((double)-delta/t)>(double)rng()/inf){
				swap(p[xx],p[yy]);
			}
			t*=t0;
		}
	}
	void MAIN(){
		n=rd();
		for(int i=1;i<=n;i++){
			p[i]=i;
			a[i]=rd();
			s+=a[i];
		}
		if(n==1){
			wrt(0);
			putchar(' ');
			wrt(a[1]);
			return;
		}
		while((double)clock()/CLOCKS_PER_SEC<0.99){
			sa();
		}
		wrt(min(x,y));
		putchar(' ');
		wrt(max(x,y));
	}
}
signed main(){
//	cin.tie(nullptr)->sync_with_stdio(false);
	Main::MAIN();
	return 0;
}

```

---

## 作者：lqsy002 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P1489)。

## 解题思路

开一个二维数组，分别表示选取的血格和人数，选出差值最小的那个即可。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,ans1,ans2=2e9;
bool dp[4030][205];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    dp[0][0]=true;
    for(int i=1,a;i<=n;++i){
        cin>>a;
        for(int j=4020;j>=a;--j)
            for(int k=105;k;--k)
                dp[j][k]|=dp[j-a][k-1];
        sum+=a;
    }
    for(int j=0;j<=4020;++j)
        if(dp[j][n/2])
            if(abs(sum-2*j)<abs(ans1-ans2)){
                ans1=sum-j;
                ans2=j;
            }
    cout<<min(ans1,ans2)<<' '<<max(ans1,ans2);
    return 0;
}
```

---

## 作者：神秘人哈哈 (赞：2)

    #include<cstdio>  
    
    #include<iostream> 
    #include<algorithm>
    #include<cstring>
    #include<cmath>
    //可以改为#include<bits/stdc++.h>
    using namespace std;
    int a[210],b[210];
     int suma,sumb,MIN,n;
    int main()
    {
    scanf("%d",&n);
    for(int i=1;i<=n/2;i++)
    {
        scanf("%d",&a[i]);
        suma+=a[i];
    }
    for(int i=1;i<=n-n/2;i++)
    {
        scanf("%d",&b[i]);
        sumb+=b[i];
    }
    //强行进行分组
    MIN=abs(suma-sumb);
    for(int i=1;i<=n/2;i++)
        for(int j=1;j<=n-n/2;j++)
        {
          if(abs(sumb-suma+2*(a[i]-b[j]))<MIN)
          //如果交换会将差变小
            {
                suma+=b[j]-a[i];
                sumb+=a[i]-b[j];
                MIN=abs(suma-sumb);
                swap(a[i],b[j]);//交换
            }
        }
    printf("%d %d",min(suma,sumb),max(suma,sumb));
    return 0;
}

---

## 作者：kkxacj (赞：1)

#### 思路

设 $f_{i,j}$ 表示选了 $i$ 个人血量为 $j$ 是否可行，转移就是 $f_{j+a_i,z+1}=\max\left(f_{j+a_i,z+1},f_{j,z}\right) $ 显然，记 $a_i$ 的总和为 $sum$，**至少有一队**的血量是 $\le \frac{sum}{2}$ 的，所以直接从 $\frac{sum}{2}$ 到 $1$ 枚举看是否可行就行了，可行就输出答案，因为先满足两边血量一定相差最小。

**code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[210],b,c,dp[10010][210],sum,mi,o;
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]),sum += a[i];
	sort(a + 1,a + 1 + n);
	dp[0][0] = 1;
	for(int i = 1;i <= n;i++)
		for(int j = sum;j >= 0;j--)
			for(int z = 0;z <= n/2;z++)
				dp[j+a[i]][z+1] = max(dp[j+a[i]][z+1],dp[j][z]);
	for(int i = sum/2;i >= 0;i--) 
	{
		if(dp[i][n/2]||dp[i][(n+1)/2])//由于人数可以相差一，也就是在n为奇数时可以多选一个
		{
			printf("%d %d\n",i,sum-i);
			return 0;
		}
	}
    return 0;
}
 
```

---

## 作者：ivyjiao (赞：1)

根据多年 OI 的直觉，我们可以用随机化解决这道题。

因为每个队伍选择的机枪兵数量一定，所以我们把一半的下标标 $1$，一半标 $0$。

每次把下标打乱一下，然后 check 这组下标是否更优即可，更优就更新最终答案，然后重新打乱。

虽然 $n\leq 200$，但是组合数学，我们可以发现每组内的顺序是无所谓的，组与组的顺序也是无所谓的，所以正确率很高，直观感受一下就行。

类似题目：[CF23C](https://www.luogu.com.cn/problem/CF23C)，[CF798D](https://www.luogu.com.cn/problem/CF798D)。

```
#include<bits/stdc++.h>
using namespace std;
int n,a[201],ans=998244353,sum;
bool p[201];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i];
        if(i<=n/2) p[i]=1;
        else p[i]=0;
    }
    while((double)clock()/CLOCKS_PER_SEC<0.99){
        random_shuffle(p+1,p+1+n);
        int x=0,y=0;
        for(int i=1;i<=n;i++){
            if(p[i]==1) x+=a[i];
            else y+=a[i];
        }
        ans=min(ans,abs(x-y));
    }
    cout<<(sum-ans)/2<<" "<<(sum+ans)/2;
}
```

---

## 作者：Loser_Syx (赞：1)

定义 $dp_{i,j}$ 为选了 $i$ 个数，是否存在一种方案到总和为数字 $j$ 的方案。

于是便可以对于每个 $a_i$ 进行一个 01 背包 dp，每次转移 $dp_{i,j}=dp_{i,j} \operatorname{or} dp_{i-1,j-a_i}$。

因为要求两个划分的区域最接近，所以其中一个较短的长度一定是 $\lfloor n\div 2\rfloor$，枚举这个区域的总和即可。

复杂度 $O(n^2\sum a_i)$，可以通过。

```cpp
int dp[101][8010], a[201];
signed main() {
	int n=read(),sum=0;
	dp[0][0]=1;
	for (int i=1;i<=n;++i) a[i]=read(),sum+=a[i];
	for (int i=1;i<=n;++i) {
		for (int j=n/2;j>=1;--j) {
			for (int k=8000;k>=a[i];--k) {
				dp[j][k]=max(dp[j][k],dp[j-1][k-a[i]]);
			}
		}
	}
	int ans=0;
	for (int i=sum;~i;--i) {
		if (dp[n/2][i]) {
			ans=max(ans,min(i,sum-i));
		}
	}
	printf("%lld %lld\n", ans, sum-ans);
	return 0;
}
```

---


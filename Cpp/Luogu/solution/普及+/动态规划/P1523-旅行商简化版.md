# 旅行商简化版

## 题目背景

欧几里德旅行商(Euclidean Traveling Salesman)问题也就是货郎担问题一直是困扰全世界数学家、计算机学家的著名问题。现有的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。


为了简化问题，而且保证能在多项式时间内求出最优解，J.L.Bentley 提出了一种叫做 bitonic tour 的哈密尔顿环游。它的要求是任意两点 $(a,b)$ 之间的相互到达的代价 $\mathrm{dist}(a,b)=\mathrm{dist}(b, a)$ 且任意两点之间可以相互到达，并且环游的路线只能是从最西端单向到最东端，再单项返回最西端，并且是一个哈密尔顿回路。


## 题目描述

本题为著名的 NPC 难题的简化版本。

现在笛卡尔平面上有 $n\ (n \le 1000)$ 个点，每个点的坐标为 $(x,y)$，（$-2^{31}<x,y<2^{31}$，且为整数），任意两点之间相互到达的代价为这两点的欧几里德距离，现要你编程求出最短 bitonic tour。


## 说明/提示

### 题目来源

《算法导论（第二版）》 15-1

## 样例 #1

### 输入

```
7
0 6
1 0
2 3
5 4
6 1
7 5
8 2
```

### 输出

```
25.58
```

# 题解

## 作者：封禁用户 (赞：28)

先上代码


```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int mm=1111;
struct data
{
    double x,y;
}g[mm];
double d[mm][mm],f[mm][mm];
int i,j,k,n;
bool cmp(const data &a,const data &b)
{
    return a.x<b.x;
}
double mdis(const data &a, const data &b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
int main()
{
    scanf("%d",&n);
    for(i=0;i<n;++i)
        scanf("%lf%lf",&g[i].x,&g[i].y);
    sort(g,g+n,cmp);
    for(i=0;i<n;++i)
        for(j=i+1;j<n;++j)
        {
            d[i][j]=mdis(g[i],g[j]);
            f[i][j]=1e30;
        }
    f[0][1]=d[0][1];
    for(i=0;i<n;++i)
        for(j=i+1;j<n;++j)
        {
            f[i][j+1]=min(f[i][j+1],f[i][j]+d[j][j+1]);
            f[j][j+1]=min(f[j][j+1],f[i][j]+d[i][j+1]);
        }
    double ans=1e30;
    for(j=0;j<n-1;++j)
        ans=min(ans,f[j][n-1]+d[j][n-1]);
    printf("%.2lf\n",ans);
    return 0;
}
```
【1】题意：旅行商问题，不过要求只能单向走，就是有n个地方，要求从西往东，到最东面的地方，在从东往西返回，经过每个点一次，求最短路径

【2】分析：由于有了方向的限制，这题不再是NP难题，我们可以假设有两个人一起从西往东走，走过的点不能重复，这样就有f[ i ][ j ]表示第一个人走到i，第二个人走到j 的最短路径，要求i<j，且0到j的点都被经过了，这样很容易想到，j+1的点不是被第一个人走，就是被第二个人走，所以有转移方程f[ i ][ j+1]=min{ f[ i ] [ j ]+d[ j ] [ j +1] } f[ j ] [ j+1 ]=min{ f[ i ][ j ]+d[ i ][ j+1 ] }，第一个转移方程很容易理解，第二个方程可以这么理解，两个人可以指前面一个人，和后面一个人，当后面的人走到前面，当然就对换过来了，不影响结果


【3】最后，预处理f[ 0 ][ 1]还有扫描 一遍答案就行了，这题算是一类DP吧，思路挺有启发性的

###Built by SinGuLaRiTy


---

## 作者：maomao9173 (赞：7)

### 更好的阅读体验请戳这里：[欢迎访问我的blog](https://www.cnblogs.com/maomao9173/p/9871455.html)

#### 评成绿题稍微有一点低，这个题目的思维要求还是比较高的。

这里利用到一个重要的思想：对于一个有确切起点和终点的回路，其路径情况，可以认为是同一个位置出发的两个点同时向前推进，类似的题目可以参考[NOIP2008—传纸条](https://www.luogu.org/problemnew/show/P1006)。

所以不要被这个题目的题面欺骗。实际上题目问的，就是从一个起点出发的，具有相同终点的两条路径的最小总长度！

做法可以认为是一类套路，如下：

#### 设$F[i][j]$为从最左侧的起点出发，一个点走到$i$，一个点走到$j(i>j)$，且所有$i$以内的点全部被走过的最短路径。



- $i=j+1$ 时：$F[i][j]$可以由$F[j][k],k∈[1,j)$转移得到，原因如下图

- $i>j+1$时，走在前面的人上一步一定是$i-1$，所以本情况一定由$F[i-1][j]$转移而来。

![](https://img2018.cnblogs.com/blog/1479416/201810/1479416-20181029163739118-2100753048.png)

总复杂度$O(n^2)$，思维难度还是有的。

### $Code:$

```cpp
//P1523 100pts 
#include<cmath> 
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define INF 1e50 
#define MAXN 1010
#define dbl double
using namespace std;
struct node{
	dbl x;
	dbl y;
	bool operator<(const node &rhs)const{
		return x<rhs.x;
	}//按照纵坐标从左往右排序 
}arr[MAXN];
int n;
dbl f[MAXN][MAXN];
inline dbl dis(int x,int y){
	return hypot(fabs(arr[x].x-arr[y].x),fabs(arr[x].y-arr[y].y));
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lf%lf",&arr[i].x,&arr[i].y);
	} 
	sort(arr+1,arr+1+n);//排序
//	for(int i=1;i<=n;++i){
//		printf("%lf %lf\n",arr[i].x,arr[i].y);
//	}
	for(int i=0;i<=1000;++i){
		for(int j=0;j<=1000;++j){
			f[i][j]=INF;
		}
	}
	f[2][1]=dis(1,2);
//	printf("f[2][1]=%lf\n",f[2][1]);
	for(int i=3;i<=n;++i){
		for(int j=i-1;j>=1;--j){
			if(i==j+1){
				//刚好是向后一个的节点
				for(int k=j-1;k>=1;--k){
					f[i][j]=min(f[i][j],f[j][k]+dis(k,i));
				} 
			}else{
				f[i][j]=min(f[i][j],f[i-1][j]+dis(i-1,i));
			}
		}
	}
	double ans=INF;
	for(int i=1;i<=n;++i){
		ans=min(ans,f[n][i]+dis(i,n));
	}
//		printf("\n");
	
	printf("%.2lf\n",ans);
}
```



---

## 作者：洛桃 (赞：6)

## 这是一道DP题
### 思路
题目要求一条最短的哈密顿回路，即每个点只能经过一次

首先我们可以根据样例画出图来

![](https://cdn.luogu.com.cn/upload/image_hosting/rdi4o4yg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图是一个哈密顿回路，我们可以将其看成有两个人一起从最左边的点出发，走不同的路，一起到最右点，两人途中将每个点都刚好经过一次

在开始前先将所有点按x坐标sort一遍，方便做题

于是可以设状态**d(x,y)**表示**两个人已经经过了1~max(x,y)的所有点**，且**此时一个人在x点，另一个人在y点**，**两个人距终点的最短距离**。

易得d(x,y)=d(y,x)，所以可以设x>y，但是如果一个人往x+2走，中间会少x+1这个点没被走过，无法表示成状态。

但是我们还有一个方法：**限制这两人只能走x+1这个点**

这样做是否正确呢？

其实可以证明，**即使有一个人向x+2这个点走，为了使1~x+2都被走过，也要让另一个人去走x+1这个点，所以不必担心漏掉最优解** 

接下来上**状态转移方程**（使用dis(x,y)代表x点与y点间的欧几里得距离）

**d(x,y)=min( d(x+1,y)+dis(x,x+1), d(x,x+1)+dis(y,x+1) )**

其实也就是代表两个人分别走到x+1点的两种状态,使用的是逆推法

边界为**d(n-1, j)=dis(n-1,n)+dis(j,n)，其中0<j<n-1**

最终答案为**dis(1,2)+d(2,1)**

这里不再证明，读者应当可以通过定义自己推出

思路就讲到这里，更详细的就请见代码吧

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
double d[1001][1001];
struct node{//记录每个点 
	double x,y;
}a[1010];
bool cmp(node a,node b)
{
	return a.x<b.x;
}
double dis(double x1,double y1,double x2,double y2)//距离公式 
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int main()
{
	scanf("%d",&n); 
	memset(d,0,sizeof(d));
	for(int i=1;i<=n;i++)scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);//排序 
	double dis1=dis(a[n].x,a[n].y,a[n-1].x,a[n-1].y),dis2=dis(a[1].x,a[1].y,a[2].x,a[2].y);
	for(int i=1;i<n-1;i++)d[n-1][i]=dis(a[n].x,a[n].y,a[i].x,a[i].y)+dis1;//初始化边界 
	for(int i=n-2;i>=2;i--)//逆推 
	{
		for(int j=1;j<i;j++)
		{
			d[i][j]=d[i+1][j]+dis(a[i].x,a[i].y,a[i+1].x,a[i+1].y);
			d[i][j]=min(d[i][j],d[i+1][i]+dis(a[j].x,a[j].y,a[i+1].x,a[i+1].y));
		}
	}
	printf("%.2lf\n",dis2+d[2][1]);//计算答案 
	return 0;
}
```
~~求管理员大大通过~~

---

## 作者：风说我活了 (赞：6)

## 既然没有人用这种做法，我就来补充一下吧（好像都是差不多）



$f[i][j]$为一个人走到i，另一个人走到j。设下一个点为k

#### 为了保证更新时不会更新出$f[i][i]$，而且每个点都会在路径上，我们每次用$f[i][j]$去更新点$max(i,j)+1$，而且只有$i$到$k$和$j$到$k$两种情况，所以转移方程为：

$f[1][1]=0$;

$k=max(i,j)+1$ //每次往后面更新

$f[k][j]=min(f[k][j],f[i][j]+dis(i,k))$; //当转移i时，类似于松弛操作，k到j的距离就是i到j的距离加上k到i的距离

$f[i][k]=min(f[i][k],f[i][j]+dis(j,k))$;  //同上


***

$\color{blue}{\text{上代码：}}$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(register ll i=(a);i<=(b);i++) 
#define don(i,a,b) for(register ll i=(a);i>=(b);i--)
using namespace std;
const int maxm=1e3+10;
const int maxn=1e5+10;
ll n;
double po[maxm][2],f[maxm][maxm];

template <class t> inline void read(t &x)
{
	x=0;int f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=10*x+ch-'0';ch=getchar();}
	x*=f;
}

struct node{
	ll x,y;
}e[maxn];

inline double dis(int a,int b)//两点间的距离计算
{
	double xx=(double) {(e[a].x-e[b].x)*(e[a].x-e[b].x)};
	double yy=(double) {(e[a].y-e[b].y)*(e[a].y-e[b].y)};
	return (double)sqrt(xx+yy);
}

bool cmp(node A,node B)
{
	return A.x<B.x;
}

void readdata()
{
	read(n);
	rep(i,1,n) {
		read(e[i].x);
		read(e[i].y);
	}
	sort(e+1,e+1+n,cmp);//我们按照横坐标的大小顺序排一下，方便计算，反正是从最左边到最右边不能回头走
}

void work()
{
	rep(i,1,n)
	 rep(j,1,n) f[i][j]=100000000000000.00;//可怜的我没有计算范围，一直开的INT_MAX没有过
	f[1][1]=0;
	rep(i,1,n)
	 rep(j,1,n) {
	 	if(i!=j || i==1) {
	 		ll k=max(i,j)+1;
	 		if(k==n+1) {//特判一下是否其中一个人走到终点了
	 			if(j==n) f[n][n]=min(f[n][n],f[i][n]+dis(i,n));
	 			if(i==n) f[n][n]=min(f[n][n],f[n][j]+dis(j,n));
			 }
			else {//没到终点就继续转移
				f[i][k]=min(f[i][k],f[i][j]+dis(j,k));
				f[k][j]=min(f[k][j],f[i][j]+dis(i,k));
			}
		 }
	 }
	printf("%.2lf",f[n][n]);
}

int main()
{
	readdata();
	work();
	return 0;
}
```

#### 求管理员通过~~毕竟这么好的题只有四篇题解（逃）~~


---

## 作者：zhlzt (赞：5)

### DP 做法
这道题类似于 [P1006 \[NOIP2008 提高组\] 传纸条](https://www.luogu.com.cn/problem/P1006)，大家可以先去做一下 P1006，是 P1523 的简化版，P1523 是从起点走到终点再回到起点，每个点经过且只经过一次（起点除外），P1006 和 P1523 唯一的区别是不一定要每个点都经过，我们可以将题目转化为两个指针 $i,j$，一起从起点走到终点，且途中不能相遇。
### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	double x,y;
	bool operator < (const node &cmp) const{
		return x<cmp.x;
	}
}p[1010]; double d[1010][1010],dp[1010][1010];
double dist(double p1,double q1,double p2,double q2){
	return sqrt((p1-p2)*(p1-p2)+(q1-q2)*(q1-q2));
}
int main(){
	int n; scanf("%d",&n); double ans=1e18;
	for(int i=1;i<=n;i++) scanf("%lf%lf",&p[i].x,&p[i].y);
	sort(p+1,p+1+n); memset(dp,127,sizeof(dp)); dp[1][1]=0;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			d[i][j]=dist(p[i].x,p[i].y,p[j].x,p[j].y); 
		}
	}
	for(int i=1;i<n;i++){
		for(int j=i;j<n;j++) if(dp[i][j]<1e18){
			dp[i][j+1]=min(dp[i][j+1],dp[i][j]+d[j][j+1]);
			dp[j][j+1]=min(dp[j][j+1],dp[i][j]+d[i][j+1]);
		}
	}
	for(int i=1;i<n;i++) ans=min(ans,dp[i][n]+d[i][n]); 
	printf("%.2lf",ans); return 0;
}
```

---

## 作者：minamikotori (赞：3)

遍历一整个图， 从开始位置走到末尾，再走回开始位置，并且不能重复；

由于题目并没有对输入数据按X从小到大排序，所以先排序，然后预处理出每两个点之间的欧几里得距离。

f(i,j)表示 从 1->max(i,j) 已经全部遍历切没有重复的最短路；

那么可知F(i , j) = F(j , i); 于是就规定 i > j;

如果 i = n - 1; 那么就强行将j跳到末尾位置；f(i, j) = dis(i, n) + dis(j, n);

其余可知  f(i,j) = max ( f(i+1, j) + dis(i, i +1),   f(i+1, i) + dis(j, i+1)) 原本应写成f(i, i+1)， 但由于规定所以写成这样；

最终状态为f(2, 1);

接着就是naive的输出啦；

下面是代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
typedef long long Lovelive;
using namespace std;

const int maxn = 1000 + 10;
int n;
struct Node {
    double x, y;    
}node[maxn];
double dis[maxn][maxn], f[maxn][maxn];

bool cmp(Node a, Node b) {
    return a.x < b.x;    
}

int main() {
    scanf("%d",&n);    
    for(int i = 1; i <= n; i++) scanf("%lf%lf",&node[i].x,&node[i].y);
    sort(node+1, node+n+1, cmp);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            dis[i][j] = sqrt((node[i].x-node[j].x)*(node[i].x-node[j].x) + (node[i].y-node[j].y)*(node[i].y-node[j].y));
    
    for(int i = n-1; i >= 2; i--)
        for(int j = 1; j < i; j++)
            if(i == n-1) f[i][j] = dis[i][n] + dis[j][n];
            else f[i][j] = min (f[i+1][j] + dis[i][i+1], f[i+1][i] + dis[j][i+1]);
    printf("%.2lf",f[2][1] + dis[1][2]);
    return 0;
}
```

---

## 作者：OIer_ACMer (赞：1)

~~这个问题有这么难吗？？？~~

------------
注：本题思路比较简单，笔者就不再过多赘述其中的原理和证明，望周知！

------------
## 大致思路：
首先，我们已经知道题目的要求让我们求出最短 bitonic tour（这东西不知道请详见[此文章](https://baike.baidu.com/item/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/7737042?fr=ge_ala)），那么，我们可以分析出，这道题是一个来回的问题，那我们可以想象就是找**两条完全不重合的路**（也可以**两个人来走两条完全不同的路**），都从最西边到最东边（DP 经典思想）。

由此，我们来设计一下 DP 的状态：我们设 $dp_{i,j}$ 表示第一个人到 $i$ 节点，第二个人到 $j$ 节点的总花费，其中 $i < j$（否则都走完了还不结束就是个错误的状态）。由此我们推出两条状态转移方程（那个 $\operatorname{dis}$ 函数是计算两个点的距离的）：

1. $dp_{i,j + 1} = \min(dp_{i,j +1},dp_{i,j}+\operatorname{dis}(point_j,point_{j +1}))$。

2. $dp_{j,j + 1} = \min(dp_{j, j +1},dp_{i,j}+\operatorname{dis}(point_i,point_{j + 1}))$。

方程原理大致解释：$dp_{i,j + 1}$ 的下一状态就是 $j + 1$ 节点，**那么就是讨论是第一个人会到 $j+1$ 节点还是第二个人会到 $j+1$ 的节点（两条方程的缘由）**。如果是第二个人到 $j+1$ 节点，那么就是 $dp_{i,j}+\operatorname{dis}(point_j,point_{j +1}))$，当前代价加上从 $j$ 点到 $j+1$ 节点的花费，同时 $dp_{i,j + 1}$ 继承这个值。如果是第一个人到 $j+1$ 节点，那么就是 $dp_{i,j}+\operatorname{dis}(point_i,point_{j +1}))$，当前代价加上从 $i$ 点到 $j+1$ 节点的花费，但是注意这里的是 $dp_{j,j + 1}$ 继承了这个值，这里要这么理解：**当 $i$ 到 $j+1$ 的时候就是 $dp_{j + 1,j}$，因为后一项要大一些（$i$ 要小于 $j$），所以交换这两者，就是 $dp_{j,j + 1}$**。

最后稍微解释一下 $i<j$ 的意义：因为不这样会有重复判读（因为欧几里得旅行商问题中两个人一定要相遇，不然的话**就不是想从原点出再从原点入的路径图**，如果没有这句话就会两人相遇后走过了头）的情况发生，答案会不一致。

------------
## 大致思路：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 3e5 + 7;
const int INF = INT_MAX;
double dp[2019][2019];
struct node
{
    int x, y;
} point[N];
bool cmp(node a, node b)
{
    return a.x < b.x;
}
double dis(node a, node b)
{
    return sqrt(1.0 * (a.x - b.x) * (a.x - b.x) + 1.0 * (a.y - b.y) * (a.y - b.y));
}
signed main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int x, y;
        cin >> x >> y;
        point[i].x = x, point[i].y = y;
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            dp[i][j] = INF * INF;
        }
    }
    sort(point + 1, point + 1 + n, cmp);
    dp[1][1] = 0;
    dp[1][2] = dis(point[1], point[2]);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            dp[i][j + 1] = min(1.0 * dp[i][j + 1], dp[i][j] + dis(point[j], point[j + 1]));
            dp[j][j + 1] = min(1.0 * dp[j][j + 1], dp[i][j] + dis(point[i], point[j + 1]));
        }
    }
    double ans = INF * INF;
    double a;
    for (int i = 1; i < n - 1; i++)
    {
        a = dp[i][n] + dis(point[i], point[n]);
        ans = min(ans, a);
    }
    cout << fixed << setprecision(2) << ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122720767)

---

## 作者：BF_AlphaShoot (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P1523)。

在确定方向后，这道题也就不再是 NPC 问题了，而是询问从一个起点出发的，具有相同终点的两条路径的最小总长度。由此想到 **DP** 做法，且与 [P1006](luogu.com.cn/problem/P1006) 有相像之处。

不妨设 $f[i][j]$ 为一个点走到 $i$ 位置，一个点走到 $j$​ 位置（由于 $f[i][j]=f[j][j]$，所以不妨令 $i>j$​）时，两点距离终点的最短距离。

但是如果一个人往 $i+2$​ 走，中间会少 $i+1$​​ 这个点没被走过，无法表示成状态。那么我们可以限制只让走 $i+1$​ 来解决这一问题。

由此有状态转移方程：
$$
f_{x,y}=\min(f_{x+1,y}+dis(x,x+1),f_{x,x+1}+dis(y,x+1))
$$
其中 $dis(x,y)$ 指点 $x$ 与 $y$ 的距离，用公式 $\sqrt{x^2+y^2}$ 计算。

在最后输出 $f_{2,1}+dis(1,2)$ 即可。​

```cpp
#include<bits/stdc++.h>
using namespace std;

//#define int long long
#define ll long long
#define ri register int
#define il inline

const int INF=0x7fffffff,N=1e3+10;
int n;
double d1,d2;
double f[N][N];
struct pts{
    double x,y;
}p[N];

il ll read(){
    ll x=0,y=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            y=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*y;
}

il bool cmp(pts x,pts y){
    return x.x<y.x;
}

il double dis(double x_1,double y_1,double x_2,double y_2){
	return sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2));
}

signed main(){
    n=read();
    for(ri i=1;i<=n;i++)
        scanf("%lf%lf",&p[i].x,&p[i].y);
    sort(p+1,p+n+1,cmp);
    d1=dis(p[n].x,p[n].y,p[n-1].x,p[n-1].y),d2=dis(p[1].x,p[1].y,p[2].x,p[2].y);
	for(ri i=1;i<=n-2;i++)
        f[n-1][i]=dis(p[n].x,p[n].y,p[i].x,p[i].y)+d1;
    for(ri i=n-2;i>=2;i--){
		for(ri j=1;j<i;j++){
			f[i][j]=f[i+1][j]+dis(p[i].x,p[i].y,p[i+1].x,p[i+1].y);
			f[i][j]=min(f[i][j],f[i+1][i]+dis(p[j].x,p[j].y,p[i+1].x,p[i+1].y));
		}
	}
	printf("%.2lf",f[2][1]+d2);
    return 0;
}
```



---

## 作者：程门立雪 (赞：1)

####旅行商简化版

> 有$n$个点，从西向东，再回到西，每个点仅走一遍，求最远距离。

**题解：**

先根据横坐标排序，保证是从西向东。

假设有两个人一起从西向东走，设$f[i][j]$为最西侧的起点出发， 后边的人走到$i$点，前边的人走到$j$点（$i < j$），且j以内的点全部被走过的最短路径。（前和后是可以发生相对变化的。）

第$j + 1$这个点不是被第一个人走，就是被第二个人走。

$f[i][j + 1] = min (f[i][j] + dis[j][j + 1])$

$f[j][j + 1] = min(f[i][j] + dis[i][j + 1])$ 当后边的人走了$j + 1$这个点，它就成了前边的人了，不会影响结果。

```c
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#define orz cout << "AK IOI" <<"\n"

using namespace std;
const int maxn = 1010;

inline int read()
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48);ch = getchar();}
	return x * f;
}
int n;
double ans = 1e30, f[maxn][maxn], d[maxn][maxn];
struct node{
	double x, y;
}e[maxn];
bool cmp(node a, node b)
{
	return a.x < b.x;
}
double dis(node a, node b)
{
	return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    n = read();
    for(int i = 1; i <= n; i++) //e[i].x = read(), e[i].y = read();
    scanf("%lf%lf", &e[i].x, &e[i].y);
    sort(e + 1, e + n + 1, cmp);
    for(int i = 1; i <= n; i++)
    	for(int j = i + 1; j <= n; j++)
    		d[i][j] = dis(e[i], e[j]), f[i][j] = 1e30;
    f[1][2] = d[1][2];
    for(int i = 1; i <= n; i++)
    	for(int j = i + 1; j <= n; j++)
    	{
    		f[i][j + 1] = min(f[i][j + 1], f[i][j] + d[j][j + 1]);
    		f[j][j + 1] = min(f[j][j + 1], f[i][j] + d[i][j + 1]);
		}
	for(int i = 1; i < n; i++)
		ans = min(ans, f[i][n] + d[i][n]);
    printf("%.2lf", ans);
	return 0;
}
```


---

## 作者：Link_Cut_Y (赞：0)

### 简化题意：

给定 $n$ 个点，要求从最左端的点到最右端的点之间寻找两条互不重复的路径，两条路径经过所有点，且路径长度最小。输出最短路径长度。

### 思路：

动态规划。

应该也算比较套路了。设想有两个人同时从最左端的点开始走，设 $f_{i, j}$ 表示第一个人走到了 $i$ 点，第二个人走到了 $j$ 点。为了简化问题，我们假设 $i < j$，且 $1 \sim j$ 中所有的点都已经被走过了。接下来，我们考虑 $j + 1$ 号点会被谁走。

1. $j$（也就是第二个人）走了 $j + 1$ 号点。这样显然是可以的。状态转移方程为 `f[i][j + 1] = min(f[i][j + 1], f[i][j] + dist(j, j + 1)); ` 

2. $i$（也就是第一个人）后来居上，直接走到了 $j + 1$ 号点。这样我们的第一个和第二个人就要对调一下了。因为我们定义前后，是根据他们目前所在点横坐标的大小。这样直接对调并不影响结果。状态转移 `f[j][j + 1] = min(f[j][j + 1], f[i][j] + dist(i, j + 1));`

### 代码示例：

```
// 缺省源没有去掉，大家凑付看看吧
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define x first
#define y second
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )
#define rop(i, a, b) for (int i = (a); i < (b); i ++ )

using namespace std;

using PDD = pair<double, double>;

const int N = 1010;
double f[N][N];
int n; PDD p[N];

double dist(int a, int b) {
	double dx = p[a].x - p[b].x;
	double dy = p[a].y - p[b].y;
	return sqrt(dx * dx + dy * dy);
}

int main() {
	scanf("%d", &n);
	rep(i, 1, n)
		scanf("%lf%lf", &p[i].x, &p[i].y);
	sort(p + 1, p + n + 1); // 不要忘了按照横坐标排序，确保是从西向东走
	
	rep(i, 1, n) rep(j, i + 1, n)
		f[i][j] = 1145141919810.00 * 20221224.00;
	
	f[1][2] = dist(1, 2);
	rep(i, 1, n) rep(j, i + 1, n)
		f[i][j + 1] = min(f[i][j + 1], f[i][j] + dist(j, j + 1)),
		f[j][j + 1] = min(f[j][j + 1], f[i][j] + dist(i, j + 1));
	double res = 1145141919810.00 * 20221224.00;
	rop(i, 1, n) res = min(res, f[i][n] + dist(i, n));
	printf("%.2lf", res);
	return 0;
}
```

---

## 作者：SUNCHAOYI (赞：0)

**dp搜索题！先说一下简单的思路**

**1.把输入的数据进行排序，然后计算出两点之间的欧几里得距离**
```
sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2));
```
**并对f数组初始化**
```
f[0][1] = dis[0][1];//这个也很重要
```

**2.状态转移方程**
```
f[i][j + 1] = min(f[i][j + 1],f[i][j] + dis[j][j + 1]);
f[j][j + 1] = min(f[j][j + 1],f[i][j] + dis[i][j + 1]);
```
**一个在前一个在后**

**3.最后比较一下特殊情况**
```
for(int i = 0;i < n - 1;i++) ans = min(ans,f[i][n - 1] + dis[i][n - 1]);
```

------------

**代码：**
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring> 
using namespace std;
const int MAX = 1000;
int n;double dis[MAX][MAX],f[MAX][MAX],ans = 1e30;
struct node
{
	double x,y;
}a[MAX];
bool cmp(node a,node b);
double Euc(node a,node b);
int main()
{
	scanf("%d",&n);
	for(int i = 0;i < n;i++) scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a,a + n,cmp);//排序 
	for(int i = 0;i < n;i++)
		for(int j = i + 1;j < n;j++)
		{
			dis[i][j] = Euc(a[i],a[j]);
			f[i][j] = 1e30;
		}
	f[0][1] = dis[0][1];
	for(int i = 0;i < n;i++)
	{
		for(int j = i + 1;j < n;j++)
		{
			f[i][j + 1] = min(f[i][j + 1],f[i][j] + dis[j][j + 1]);
			
            f[j][j + 1] = min(f[j][j + 1],f[i][j] + dis[i][j + 1]);
		}
	} 
	for(int i = 0;i < n - 1;i++) ans = min(ans,f[i][n - 1] + dis[i][n - 1]);
	printf("%0.2lf\n",ans);
	return 0;
} 
bool cmp(node a,node b) 
{
	return a.x < b.x;
}
double Euc(node a,node b)//计算欧几里得距离 
{
	return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2));
}
```


---


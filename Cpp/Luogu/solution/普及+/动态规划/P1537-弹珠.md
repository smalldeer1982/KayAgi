# 弹珠

## 题目描述

玛莎和比尔各自有自己的弹珠收藏。他们想重新分配收藏品，使两人能平等拥有弹珠。如果所有的弹珠的价值相同，那么他们就可以平分。但不幸的是，有一些弹珠更大，或者更美丽，所以，玛莎和比尔给每个弹珠一个 $1$ 到 $6$ 的价值。现在他们想平分这些弹珠，使每个人得到的总价值相同。不幸的是，他们发现，他们可能无法以这种方式分弹珠（即使弹珠的总价值为偶数）。例如，如果有一个价值为 $1$、一个价值为 $3$ 和两个价值为 $4$ 的弹珠，这样他们就不能把弹珠分为价值相等的两部分。因此，他们想要你写一个程序，告诉他们是否能将所有弹珠分成价值相等的两部分。


## 样例 #1

### 输入

```
1 0 1 2 0 0 
1 0 0 0 1 1 
0 0 0 0 0 0 
```

### 输出

```
Collection #1:
Can't be divided.

Collection #2:
Can be divided.
```

# 题解

## 作者：Sooke (赞：31)

不难看出本题是背包问题，类似经典的拔河问题，但是对于权值不同的弹珠，会有不同的数量，因此衍生出两种不同的算法：

## 朴素背包算法

第一反应想到可以将权值不同的弹珠，根据数量依次扫一次布尔 dp 数组（背包数组），初始化 v[0] = true，其余值为 false，逆序扫数据，如果存在 v[j - i]（i 为弹珠的价值）为 true，则有 v[j] 为 true 。最后如果 v[s] 为 true 则可以平分（s 为所有弹珠总价值的一半）。这种方法简单，但弊端明显：弹珠数量过大，数据组数较多导致本算法妥妥超时。

## 优化多重背包算法

上面的算法中，我们将弹珠数量建立为组数，即若干个权值为 1 \* i 的弹珠，这样子不同的状态（在单种弹珠权值总和以下的状态）都能被若干个 1 \* i 来表示。这是一种对单种弹珠分组。但有没有更优化的分组呢？我们可以看一下这一题：**P2320 鬼谷子的钱袋**，本题中，将钱分成若干个组，使总钱数以下的值都能被某些组的钱数之和所表示。刚刚好能用在这一题。算法核心代码：

```cpp
for(int t = x ; t > 0 ; t >>= 1)
      f = (t >> 1) + (t & 1);        
```
以上核心算法代码中，将 x 为单种弹珠数代入，循环内得到的所有 f 都是一种分组。例如，将 11 代入，先得到 6，接着得到 3，最后还能得到两个 1。

可列出：

```cpp
1 = 1
2 = 1 + 1
3 = 3
4 = 3 + 1
5 = 3 + 1 + 1
……
```
接下来，我们就可以将每个组都当做一个独立的物品代入背包扫一遍 dp 数据了。复杂度瞬间降到了 log 级别。

另外，由于本题是多组数据，我们可以写一个 Solve 函数，专门解决每一组数据。本算法中，同样是初始化 v[0] = true，其余值为 false，但逆序扫数据，如果存在 v[j - fi]（f 为某组的弹珠数量，i 为弹珠的价值）为 true，则有 v[j] 为 true。

如果讲的还不太清晰，结合下面的代码和注释理解吧：

```cpp
#include <cstdio>
#include <cstring>

inline int Input(){
    char C = getchar();
    int N = 0;
    while(C < '0' || C > '9')
        C = getchar();
    while(C >='0' && C <='9')
        N = (N << 1) + (N << 3) + (C - 48) , C = getchar();
    return N;
} // 读入优化（直觉告诉我数据量很大QAQ） 

int a[7] , s , k = 0;
bool v[60001];

inline bool ReadData(){
    s = 0; // s 变量用于记录每组数据价值总和 
    for(int i = 1 ; i <= 6 ; i++)
        s += (a[i] = Input()) * i;
    return s; // 如果 s 变量为 0 ，即数据结束，返回 false 
}
bool Solve(){
    memset(v , false , sizeof(v)); v[0] = true; // 清空 dp 数组（背包） 
    // 类似经典的拔河问题，本来应给 s 除以 2 做 dp
    // 这里不给 s 除以二，以免 s 为奇数，因此给权值乘 2 
    for(int i = 1 ; i <= 6 ; i++)
        for(int t = a[i] ; t > 0 ; t >>= 1){ // “鬼谷子的钱袋”中的类似做法
            int f = (t >> 1) + (t & 1); // 变量 f 存储弹珠分组的当前组量
            for(int j = s ; j >= f * i * 2 ; j--)
                if(v[j - f * i * 2])
                    v[j] = true;
                // 接下来就是简单做一次背包了             
        }
    return v[s]; // 返回弹珠是否能按价值平分 
}

int main(){
    while(ReadData()){
        if(k)
            printf("\n");
        printf("Collection #%d:\n" , ++k);
        if(Solve()) // 写一个函数专门来解决每一组数据 
            printf("Can be divided.\n");
        else
            printf("Can't be divided.\n");
    }
    return 0;
}
``` 

---

## 作者：青衫白叙 (赞：28)

首先声明。。这不是自创题解。。第二。。这道题原题名字叫Dividing。。。出题者只是搬砖。。。

我只讲怎么 0ms 过这题好不好？？？

举个栗子：“1 0 2 0 1 0” ：一个人拿走价值为 3 的大理石块，其余归另一个人；而“2 1 1 1 1 1” ：一个人只拿一种大理石就不行了，需要拿到多种大理石。这两组数据，对任意价值的大理石块，无论增加多少个 2，仍然是可以平分的，只要他们平分这个 2 就可以了。。

因此我们不需要对每种价值的大理石，按多达20000块进行平分，而只需要对一个最低限度的大理石块数 n （0 <= n <= a[i]）进行平分，

其余的部分，他们直接平分就好。显然 n 是偶数，经过测试。n = 6；

关键代码：

```cpp
if(a[i] != 0 && a[i] %6 == 0) a[i] = 6;
else a[i] %= 6;
其中：1<= i <= 6
```
好了。。这样就大大压缩了原始数据的范围。。。就算枚举都没问题了。。

给出核心代码（虽然我知道没有人不会写枚举。。就是不给DP，，虽然都是0ms。。）：

```cpp
void calc(int sum) {
    int mid;
    for(int i=0;i<=a[1];++i)
    for(int b=0;b<=a[2];++b)
    for(int c=0;c<=a[3];++c)
    for(int d=0;d<=a[4];++d)
    for(int e=0;e<=a[5];++e)
    for(int f=0;f<=a[6];++f)
    {
        mid = 1*i+2*b+3*c+4*d+5*e+6*f;
        if(mid == sum/2) {puts("Can be divided.\n");return;}
    }
    puts("Can't be divided.\n");
}
```

---

## 作者：fastle (赞：14)

看这题没有题解 ，来写一篇

整个题目的思路其实就是多重背包，背包容量是所有弹珠美丽总和的一半

我们可以先记录出所有弹珠的美丽总和，如果是奇数，那么一定不能平均分成两份（这个题目里有暗示）然后我们进行dp就行了

注意事项：

1.多重背包的二进制优化问题，可以节省大量时间，二进制优化实际将多重背包转化成01背包，意思是假如某个物体数量是13，那么

我们把它拆成1,2,4,6，四个物体  进行dp就能表示出这一种物体所有不同的取得的状态

2.背包压维。

3.多组数据要清空数组。


然后  状态表示：dp【j】 表示 能否取得美丽总和为j的弹珠

         转移方程：：dp[j] = dp[j] || dp[j - stack[i]];
其实不想粘代码



```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int dp[20001];
int stack[120001];
int top = 0;
int num[7];
int sum = 0;
int main()
{
    int cns = 0;
    while("Zuo Zhe is handsome")
    {
        cns ++;
        top = 0;
        sum = 0;
        for(int i = 1;i <= 6;i ++)
        {
            int wei;
            scanf("%d",&wei);
            sum += wei * i;
            int zz = 1;
            while(wei >= zz)
            {
                stack[++ top] = zz * i;
                wei -= zz;
                zz *= 2;
            }
            if(wei)
              stack[ ++ top] = wei * i;
        }
        if(top == 0)break;
        printf("Collection #%d:\n",cns);
        if(sum & 1)
        {
            printf("Can't be divided.\n\n");
            continue;
        }
        sum /= 2;
        memset(dp,0,sizeof(dp));
        dp[0] = 1;
        for(int i = 1;i <= top;i ++)
        {
            for(int j = sum;j >= stack[i];j --)
             {
              dp[j] = dp[j] || dp[j - stack[i]];
            } 
        }
        printf(dp[sum] ?"Can be divided.\n\n":"Can't be divided.\n\n"); 
    }
    return 0;
}

```

---

## 作者：heyuhhh (赞：10)

其实这个直接bitset+dp就行啦。

比较朴素的背包转移方程就是:对于第$i$个物品，枚举所有可能得到的价值$j$来进行转移：
$$dp(i,j) += dp(i-1,j-v_i),v_i\leq j\leq k$$
然后我们用一个bitset来储存阶段为$i-1$所有的状态，如果价值有一个价值$x$，那么$x$这个位置就为1。

之后转移的时候就$dp |= dp<<i$就行了，这里的$|$其实就代表了选与不选两种情况。

这样复杂度因为bitset还有所优化，多除以了一个32 or 64。
代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 120005;
bitset <N> dp;
int a[10] ;
int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int Case = 0;
    while(1) {
        Case++;
        int sum = 0;
        for(int i = 1; i <= 6; i++) cin >> a[i], sum += i * a[i] ;
        if(sum == 0) break ;
        cout << "Collection #" << Case << ":" << '\n';
        if(sum & 1) {
            cout << "Can't be divided." << '\n' << '\n';
            continue ;
        }
        dp.reset() ;
        dp.set(0) ;
        int ok = 0;
        for(int i = 1; i <= 6; i++) {
            for(int j = 1; j <= a[i]; j++) {
                dp |= (dp << i);
                if(dp[sum / 2]) ok = 1;
            }
        }
        if(ok) cout << "Can be divided." << '\n';
        else cout << "Can't be divided." <<'\n';
        cout << '\n';
    }
    return 0;
}

```

---

## 作者：逝星DS (赞：8)

P1537：弹珠


题目描述

玛莎和比尔各自有自己的弹珠收藏。他们想重新分配收藏品，使两人能平等拥有弹珠。如果所有的弹珠的价值相同，那么他们就可以平分。但不幸的是，有一些弹珠更大，或者更美丽，所以，玛莎和比尔给每个弹珠一个1到6的价值。现在他们想平分这些弹珠，使每个人得到的总价值相同。不幸的是，他们发现，他们可能无法以这种方式分弹珠（即使弹珠的总价值为偶数）。例如，如果有一个价值为1、一个价值为3和两个价值为4的弹珠，这样他们就不能把弹珠分为价值相等的两部分。因此，他们想要你写一个程序，告诉他们是否能将所有弹珠分成价值相等的两部分。

输入输出格式

输入格式：
输入文件有若干行，行中包含六个非负整数N1，。..，N6，其中mi是数值i的弹珠的价值。最大弹珠总数将达到20000。

输入文件的最后一行是0 0 0 0 0 0 。不要处理这一行。

输出格式：
对于每一组数据，输出"Collection #k:", k为输出的是第几组, 接着是"Can be divided." 或 "Can't be divided.".

每一组输出后多打一个空行。

输入输出样例

输入样例#1： 
1 0 1 2 0 0 
1 0 0 0 1 1 
0 0 0 0 0 0 
输出样例#1： 
Collection #1:
Can't be divided.

Collection #2:
Can be divided.

思路：
仔细一想，很简单的背包。
bool f[i]为能否凑到i；
f[sum/2]即为答案。
附上代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int n[10];  //弹珠数； 
int N;  //样例数； 
int sum;  //所有弹珠价值和； 
bool f[130000];  //能否达到i； 
int main()  {
	for(int i=1;i<=6;i++)  {
		cin>>n[i];
		sum+=n[i]*i;  //累加价值和； 
	}
	N=1;
	while(n[1] || n[2] ||n[3] || n[4] || n[5] || n[6])  {
		if(sum%2==1)  {  //奇数不可能； 
			cout<<"Collection #"<<N<<':'<<endl<<"Can't be divided."<<endl<<endl;
		}
		else  {
			memset(f,0,sizeof(f));  //初始化； 
			f[0]=1;  //!!!
			for(int i=1;i<=6;i++)  {  //简单背包； 
				for(int j=sum/2;j>=i;j--)  {
					for(int k=1;k<=n[i];k++)  {  //枚举数量； 
						if(j>=i*k && f[j-i*k])  {
							f[j]=1;
						}
					}
				}
			}
			if(f[sum/2])  {  //可以凑到一半
			     cout<<"Collection #"<<N<<':'<<endl<<"Can be divided."<<endl<<endl;
			}
			else  {  //不可以； 
				cout<<"Collection #"<<N<<':'<<endl<<"Can't be divided."<<endl<<endl;
			} 
		} 
		sum=0;  //!!!
		for(int i=1;i<=6;i++)  {
		    cin>>n[i];
		    sum+=n[i]*i;  //累加价值和； 
	    }
	    N++;  //!!! 
	}
	return 0;
}
```

---

## 作者：zyzzyzzyzzyz (赞：5)

#  朴素的多重背包 
#### 本蒟蒻的第一篇题解

~~勿喷~~

虽然有大佬已经提到过该做法，但没有代码，本蒟蒻在此补充

PS:大佬请略过本题解，建议dp初学者看

## 正文：

	首先要了解多重背包的含义：
    “给定N种物品，其中第i种物品的体积为Vi，价值为Wi，
    
    并且有Ci个。有一个容量为M的背包，要求选择若干个物
    
    品放入背包，使得物品总体积不超过M的前提下，物品总
    
    价值最大。” ——《算法竞赛》 李煜东
    
 


对应本题，给出了6种价值的石头，每种石头“体积”与“价值”

都为i（1<=i<=6），可以选a[i]个；而题目中的要求是是否
存在

某种分配方式，使得背包的总价值为s/2（s为所有石头的价值

总和）。

因此对递推式进行一点小改动，

将f[i][j]=min(f[i-1][j-i*k],f[i][j])中的min改成sum即可（代码中会提到这一段）。

(另外，f[i][j]的含义：在选择1~i种物品、总价值为j的情况下的方案数)

因此，我们的思路就很清晰了：


1.确定状态转移方程：f[i][j]=min(f[i-1][j-i*k]；


2.确定边界：f[i][i*j]=1(j<=a[i]);


3.求解：f[i][s/2]是否非0(1<=i<=6)

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[7],s=0,x,j,mark;
long long f[7][60010];//这里的f用longlong存储，可以统计每种价值的表示方式数。当然本题不需要，用bool来存储是						//否可表就可以了
inline int rd(){//读优
	int ans=0,flag=1;
	char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')flag=-1,ch=getchar();
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-48;

	return ans*flag;
}
int main(){
	for(register int i=1;i<=6;i++){//读入第一组数据
		a[i]=rd();
		s+=a[i]*i;
	}
	int i1=0;
	while(s!=0){//当s等于0时，输入结束
		i1++;//i1记录第几组数据
        mark=0，memset(f,0,sizeof(f));//初始化
		cout<<"Collection #"<<i1<<':'<<endl;
		if(s&1==1)cout<<"Can't be divided."<<endl<<endl;//若s为奇数，一定不可分
		else{
			s=s/2;
			for(register int i=1;i<=6;i++){
				for(register int j=1;j<=a[i];j++){
					f[i][i*j]=1;//边界；若价值为i*j，则一定能被i表示（j<=a[i]）
				}
			}
			for(register int i=1;i<=6;i++){
				for(register int j=i;j<=s;j++){
					for(register int k=0;k<=a[i];k++)
					if(j>i*k)
						f[i][j]+=f[i-1][j-i*k];//转移方程
					
				}
			}
			for(register int i=1;i<=6;i++){
				if(f[i][s]){//存在一种表示s的方式
					mark=1;
					printf("Can be divided.\n\n");
					break;
				}
			}
			if(mark==0){
				printf("Can't be divided.\n\n");
			}
		}
		s=0;
		for(register int i=1;i<=6;i++){
			a[i]=rd();
			s+=a[i]*i;
		}//读入下一组数据
	}
	
	return 0;
}
```

---

## 作者：ShwStone (赞：3)

# 这是一道DP
###### 我怎么可能是看了标签再说的
## 题目描述
有六种不同价值的弹珠，告诉你每一种有多少个，求能不能将弹珠均分为相等的两份。  

输入格式给的很费解，其实就是给出了价值分别为 $1 \sim 6$ 的弹珠的个数，此外输出格式里还要求多打一个空行，~~就坑的离谱~~。  

## 思路分析
很容易想到的特判：如果总价值是奇数，直接输出 `Can't be divided.`  

然后就很关键了，题目可以理解为：在所有珍珠中选出一些，使得价值和正好是总价值的一半。  

怎么实现这个算法呢？   

在一堆东西里面选出一些，使得总价值满足一定条件，很容易可以想到背包问题。  
（如果没有学习过背包的，建议移步[AcWing背包九讲(主题库2~10题)](https://www.acwing.com/problem/)或者[P1048](https://www.luogu.com.cn/problem/P1048)）。  
以下默认各位大佬都会01背包。  

我们可以把珍珠的价值也看做费用，求在价值和不超过总价值的一半的前提下能够选的的最大价值，如果这个最大价值就是总价值的一半，那么可以均分，否则不行。

所以这个问题就可以转化为：  
一共有6种弹珠，每种弹珠可能有多种，在价值和不超过总价值的一半的前提下求出能够选的的最大价值。

~~各位大佬肯定一眼就看出来~~这是一个多重背包问题。

## 多重背包
多重背包问题可以转化为01背包问题求解，最朴素的方法就是把一种当中的 $n$ 个看成 $n$ 个不同的物品，然后每个物品都可以取或者不取。也就是在经过如下操作后套用01背包模板：
```cpp
int a[maxn]; //存储价值
int j = 1;
for (int i = 1; i <= 6; i++) {
	int t;
	cin >> t;
	while (t--) {
		a[j++] = i;
	}
}
```
时间复杂度 $O(n\cdot sum/2)$ （ $sum$ 为价值和）。这样跑一遍最大是 $20000 \times 60000 / 2$ ，已经T飞了，况且还有多组数据。

所以我们要进行优化。观察上面的步骤，让时间复杂度剧增的就是把一种当中的 $n$ 个看成 $n$ 个不同的物品，由于每一种物品都可能有很多个，所以最终的物品总数会很大。我们可以在这个方面着手优化：

我们的最终目的是使得分出来的物品可以表示 $1 \sim n$ 里面的所有价值，为了达成这一目的，我们并不需要分出 $n$ 个物体。

### 二进制优化

在计算机中，为了表示 $1 \sim x$ ，我们只需要 $\log_2 x$ 个bit。同样的道理，为了表示 $1 \sim n$ 的所有数，我们只需把 $n$ 拆分成 $\log_2 n$ 个数。举个例子，对于 $n = 30$ 我们可以拆成 $1, 2, 4, 8, 15$ ，各位大佬可以自己试验~~亿~~下，一定可以表示 $1 \sim 30$ 中的所有数。

根据这个原理，我们可以更改上述代码：
```cpp
int j = 1;
for (int i = 1; i <= 6; i++) {
	int t;
	cin >> t;
	int k = 1;
	while (k <= t) {
		a[j++] = k * i;
		t -= k;
		k <<= 1;
	}
	if (t > 0) a[j++] = t * i;
}
```
再次套用01背包模板，时间复杂度为 $O(log_2 n \cdot sum/2)$ ，这样就快多了。

效率：[https://www.luogu.com.cn/record/59760585](https://www.luogu.com.cn/record/59760585)。

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

#define uns unsigned
#define ll long long
#define use_cin_cout do { ios::sync_with_stdio(false); cin.tie(); } while (false)
#define endl '\n'

const ll inf_ll = 0x3f3f3f3f3f3f3f3f;
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const int maxv = 6e4 + 5, maxn = 2e4 + 5;

int sum, collection;
int dp[maxv], a[maxn];

int main() {
	use_cin_cout;
	
	while (true) {
		collection++;
		
		bool end = true;
		sum = 0;
		memset(a, 0, sizeof(a));
		memset(dp, 0, sizeof(dp));
		
		int j = 1;
		for (int i = 1; i <= 6; i++) {
			int t;
			cin >> t;
			sum += t * i;
			if (t != 0) end = false;
			
			int k = 1;
			while (k <= t) {
				a[j++] = k * i;
				t -= k;
				k <<= 1;
			}
			if (t > 0) a[j++] = t * i;
		}
		
		if (end) return 0;
		
		cout << "Collection #" << collection << ":" << endl;
		
		if (sum & 1) {
			cout << "Can't be divided." << endl << endl;
			continue;
		}
		
		bool flag = false;
		for (int i = 1; i < j; i++) {
			for (int v = (sum >> 1); v >= a[i]; v--) {
				dp[v] = max(dp[v], dp[v - a[i]] + a[i]);
				
				if (dp[v] == (sum >> 1)) {
					flag = true;
					break;
				}
			}
		}
		
		if (flag) cout << "Can be divided." << endl << endl;
		else cout << "Can't be divided." << endl << endl;
	}
	
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：1)

此题极水，用各种神奇的方法都可以过去。写完之后我看了一下题解，发现没有用我这种算法的题解，所以就过来补一篇。

------------

- 题目简介：
 
  给定六**种**物品，每种物品有若干个。这六种物品的价值为 $1 - 6$。 现在要将这六种物品均分成两份，使得两份的价值和均为正整数。求是否可以均分。
 
- 题目分析：
 
  既然数据这么水，那当然要用随机化搜索拉！
    
  我的随机化搜索是 [膜你退火](https://oi-wiki.org/misc/simulated-annealing/)。
   
  根据分成两份价值和的差的绝对值来做模拟退火即可。由于数据水，因此模拟退火 $3 - 4$ 次即可得到正确答案。
   
- 参考代码：
 
  ```
  #include <iostream>
  #include <cstring>
  #include <cstdio>
  #include <algorithm>
  #include <cmath>

  using namespace std;

  int az[7], w[7];
  int res, T;

  bool check()
  {
      for (int i = 1; i <= 6; i ++ ) 
          if (w[i] != 0) return true;
      return false;
  }

  int calc()
  {
      int res1 = 0, res2 = 0;
      for (int i = 1; i <= 6; i ++ )
          res1 += w[i] * i, res2 += (az[i] - w[i]) * i;

      res = min(res, abs(res1 - res2));
      return abs(res1 - res2);
  }

  void simulate_anneal()
  {
      for (double t = 1e6; t >= 1e-6; t *= 0.99)
      {
          int x = calc();

          int tmp[7];
          for (int i = 1; i <= 6; i ++ )
              tmp[i] = w[i];

          for (int i = 1; i <= 6; i ++ )
              w[i] = rand() % (az[i] + 1);
          int y = calc();
          int delta = y - x;
          if (exp(-delta / t) < (double)rand() / RAND_MAX)
              for (int i = 1; i <= 6; i ++ )
                  w[i] = tmp[i];

          if (!res) return; // 小小“剪枝”
      }
  }

  int main()
  {
      while (true)
      {
          T ++ ;
          res = 0x3f3f3f3f;
          for (int i = 1; i <= 6; i ++ )
              scanf("%d", &w[i]), az[i] = w[i];
          if (!check()) break;
          for (int i = 1; i <= 6 && res != 0; i ++ ) simulate_anneal(); // 这里少做几遍也可以
          if (!res)
              printf("Collection #%d:\nCan be divided.\n\n", T);
          else
              printf("Collection #%d:\nCan't be divided.\n\n", T);
      }

      return 0;
  }
  ```

---

## 作者：zhou_ziyi (赞：1)

### 大致思路

首先，我们要转化问题，假设弹珠总价值为 $sum$，那么背包的容积则为 $sum \div 2$ 让你求给的这些弹珠是否恰好有一种选法能填满这个背包。但不过数据较水，朴素的多重背包也能过。

### Code

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 10005;
int n = 6, cnt;
int a[MAXN];
int f[MAXN];
int main() {
	while (1) {
		memset(f, 0, sizeof(f));
		int flag = 0, sum = 0; //flag判断是否结束，sum为价值和
		for (int i = 1; i <= 6; i++)
			scanf("%d", &a[i]), flag |= a[i], sum += a[i] * i;
		if (!flag)
			break;
        cnt++;
		if (sum & 1) { //无解的特判
			printf("Collection #%d:\nCan't be divided.\n", cnt);
			puts("");
			continue;
		}
		f[0] = 1;
		for (int i = 1; i <= n; i++) { //多重背包
			for (int j = 1; j <= a[i]; j++)
				for (int k = sum / 2; k >= i * j; k--)
					f[k] |= f[k - i * j];
		}
		if (!f[sum / 2])
			printf("Collection #%d:\nCan't be divided.\n", cnt);
		else
			printf("Collection #%d:\nCan be divided.\n", cnt);
		puts("");
	}
	return 0;
}
```



---

## 作者：Coros_Trusds (赞：1)

小清新背包 $\rm dp$。

# 题目大意

有六种价值分别为 $1\sim 6$ 的弹珠，告诉你每一种有多少个，求能不能将弹珠均分为相等的两份。

# 题目分析

多重背包 $\rm dp$，给定了各自的数量和体积，单调队列优化好像不太好写 ~~（其实是二进制优化好写）~~，考虑二进制优化多重背包。

总体积 $m=\sum\limits_{i=1}^6c_i\times i$，所以判断下 $m$ 是否为奇数，$\dfrac{m}{2}$（$m$ 为奇数的情况是不合法的）是否能够拼出来就行了。

-----
关于二进制优化多重背包：

多重背包就是在 $01$ 背包的基础上还多了一个条件：个数 $c$，朴素想法是把每件物品拆分成 $c$ 个单独的物品，然后跑 $01$ 背包即可。这样效率较低，可以换一种拆分方式：二进制拆分。因为每一个正整数 $k$ 一定可以用 $2$ 的次幂和来表示，如 $5=2^2+2^0$，$15=2^3+2^2+2^1+2^0$，所以我们将物品二进制拆分成几个物品就好了。这样拆分数量就可大大减少，时间复杂度也降了个 $\log$。

二进制优化思维就是：现在给出一堆苹果和 $10$ 个箱子，选出 $n$ 个苹果。将这一堆苹果分别按照 $1,2,4,8,16,\cdots,512$ 分到 $10$ 个箱子里，那么由于任何一个数字 $x\in[1,1024]$ 都可以从这 $10$ 个箱子里的苹果数量表示出来，但是这样选择的次数就小于等于 $10$。

# 代码

```cpp
//2022/3/27
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define enter putchar(10)
#define debug(c,que) cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) cout << arr[i] << w;
#define speed_up() cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : -(x))
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;
using namespace std;

const int N = 5e5 + 5;
int v[N],dp[N];
int Case;
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	while (true) {
		Case ++;
		int sum = 0,idx = 0;
		bool mark = false;
		for (register int i = 1;i <= 6; ++ i) {
			int c = read();
			sum += i * c;
			mark |= (c != 0);
			int now = i,tmp = 1;
			while (now <= c) {
				v[++ idx] = i * tmp;
				c -= tmp,tmp <<= 1;
			}
			if (c) v[++ idx] = i * c;
		}
		if (!mark) break;
		
		if (sum % 2 == 1) {
			printf("Collection #%d:\n",Case);
			puts("Can't be divided.");
			puts("");
			continue;
		}
		mst(dp,0);
		dp[0] = 1;
		for (register int i = 1;i <= idx; ++ i) {
			for (register int j = sum / 2;j >= v[i]; -- j) {
				dp[j] |= dp[j - v[i]];
			}
		}
		if (dp[sum / 2]) {
			printf("Collection #%d:\n",Case);
			puts("Can be divided.");
			puts("");
		} else {
			printf("Collection #%d:\n",Case);
			puts("Can't be divided.");
			puts("");
		}
	}

	return 0;
}
```

---

## 作者：moosssi (赞：1)

首先，我们要转化问题，假设弹珠总价值为 $m$ ，那么背包的容积则为 $m/2$ 让你求给的这些弹珠是否恰好有一种选法能填满这个背包。这就是个普通的多重背包问题，但直接求会超时，这里需要用到二进制拆分。

原理大概是：任意一个非零自然数，都可以用若干 $2^k$ 的和表示，例如 $19=2^0+2^1+2^4$ ,如果我们对于每个物品进行二进制优化就可以将问题转化为01背包问题，增加空间复杂度而减低时间复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int t=1,w[N],cnt,m,f[N];
int main(){
	while(++t){
		cnt=0;
		m=0;
		for(int i=1;i<=6;i++){
			int c,a=i,s=1;
			scanf("%d",&c);
			m+=a*c; //背包容量 
			while(s<=c){//进行二进制拆分 
				w[++cnt]=a*s;
				c-=s;
				s*=2;
			}
			if(c>0){
				w[++cnt]=a*c;
			}
			
		}
		if(!m)break;
		memset(f,0,sizeof(f));
		f[0]=1;
		if(m%2){ //特判 
			printf("Collection #%d:\n",t-1);
			printf("Can't be divided.\n\n");
			continue;			
		}
		m/=2;
		for(int i=1;i<=cnt;i++){
			for(int j=m;j>=w[i];j--){//01背包问题 
				f[j]|=f[j-w[i]]; 
			}
		}
		printf("Collection #%d:\n",t-1);
		if(!f[m])printf("Can't be divided.\n");
		else printf("Can be divided.\n");
		printf("\n");
	}
	return 0;
}
```


---

## 作者：Otomachi_Una_ (赞：1)

不难看出这一题是多重背包问题，类似于[P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)，区别在于一个是布尔背包，一个是01背包。

由此，可以延伸出三种算法

# 1、朴素的多重背包
我们把每一个弹珠1个1个拆开，这样就变成了类似于[P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)的布尔背包

初始化：对于每一组输入f[0]设为true 其余设为false

转移方程：
```
f[i]=(f[i]||f[i-j*k]) (j*k<=i,k<=a[i],j<=6)
```


因为弹珠的总价值可能为奇数，所以这种情况可以直接输出

如果讲的不是很清楚可以参考下面的代码：

```cpp
/*
writeen by:ushg8877
time :926ms
memory :748.00KB
*/
#include<iostream>
using namespace std;
const int MAXN=120005;
bool f[MAXN]={0};
int a[7]={0};
int n=6;
int m=0;//记录回合
int s=0;
int main(){
	f[0]=true;
    while(cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6]){
    	m++;
    	if(a[1]+a[2]+a[3]+a[4]+a[5]+a[6]==0)
    		return 0;//出口
    	s=a[1]*1+a[2]*2+a[3]*3+a[4]*4+a[5]*5+a[6]*6;//计算总价值
    	if(s%2==1){
    	    cout<<"Collection #"<<m<<":"<<endl<<"Can't be divided."<<endl<<endl;
    	    continue;
    	}//直接输出
    	for(int i=1;i<MAXN;i++)
    		f[i]=false;
    	for(int i=1;i<=n;i++)
    		for(int j=s;j>=i;j--)
    			for(int k=1;k<=a[i]&&k*i<=j;k++)
    				f[j]=(f[j]||f[j-k*i]);//转移方程
    	if(f[s/2]==false)
    		cout<<"Collection #"<<m<<":"<<endl<<"Can't be divided."<<endl<<endl;
    	else
    		cout<<"Collection #"<<m<<":"<<endl<<"Can be divided."<<endl<<endl;//输出
    }
}
```

当然，这样运行的速度实在是太慢了，对于比较大的数据容易超时，我们可以考虑优化

# 2、优化多重背包

我们需要用到一些多重背包优化的知识点

因为上面的程序始终在把多个弹珠拆成一个一个的，十分浪费算力，我们可以考虑把他们不一个一个分组，但可以保证每种可以拆分的情况进行考虑，

比如说 ：

5

我们当然可以把它拆成1,1,1,1,1，虽然这样子可以把每一种拆分的情况都考虑进去，但是这是上面程序的算法，会有计算力的浪费

我们不妨把它拆成1,2,2

这样子就可以把0~5的数字都表示出来了，这样子拆分的算法就可以大大的优化了

我们再多枚举几个这样的拆分就好了

```c
3=1+2
4=1+1+2
5=1+2+2
6=1+2+3
7=1+2+4
```

发现若想达到上述拆分，需要有$2^0$,$2^1$,$2^2$...$2^k$和a[i]- $\sum_{i=1}^ka_i$,且这个数小于$2^k$

算法核心代码：
```cpp
int cf(int a){//对a拆分放在c数组，输出个数
	int t=0; 
	for(int i=0;two[i]<=a;i++){
		c[++t]=two[i];
		a-=two[i];
	}
	if(a!=0)
		c[++t]=a;
	sort(c+1,c+t+1);
	return t;
}
```

上代码：
```cpp
/*
written by: ushg8877 
time: 489ms
memory: 748kb
*/
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=120005;
int p[7];
int two[30]={0};
int sum=0;
bool f[MAXN]={0};
int c[30]={0};//记录拆分
int n=6;
int x=1;//记录回合
int g;//记录拆分个数
int cf(int a){//对a拆分放在c数组，输出个数
	int t=0; 
	for(int i=0;two[i]<=a;i++){
		c[++t]=two[i];
		a-=two[i];
	}
	if(a!=0)
		c[++t]=a;
	sort(c+1,c+t+1);
	return t;
}
int main(){
	f[0]=true;
	two[0]=1;
	for(int i=1;i<30;i++)
		two[i]=two[i-1]*2;//记录二次幂
	while(cin>>p[1]>>p[2]>>p[3]>>p[4]>>p[5]>>p[6]){
		for(int i=1;i<MAXN;i++)
			f[i]=false;
			
		sum=p[1]*1+p[2]*2+p[3]*3+p[4]*4+p[5]*5+p[6]*6;
		if(sum==0) break;//出口
		if(sum%2==1){
			printf("Collection #%d:\nCan't be divided.\n\n",x);
			x++;
			continue;
		}//没必要的计算
		for(int i=1;i<=n;i++){
			g=cf(p[i]);
			for(int j=1;j<=g;j++)
				for(int k=sum;k>=c[j]*i;k--)
					f[k]=(f[k]||f[k-c[j]*i]);
		}//状态转移方程
		if(f[sum/2])
			printf("Collection #%d:\nCan be divided.\n\n",x);
		else
			printf("Collection #%d:\nCan't be divided.\n\n",x);//输出
		x++;
	}
	return 0;
```
# 3、刷表
因为玻璃珠只有1~6，所以我们可以使用刷表法,

从1开始枚举玻璃球价值状态的转移，首先设f[0]=true;

对于枚举到价值为i时，对于f[j],如果它本身就是true:

那么他后面
```
f[j+i],f[j+2*i]....f[j+a[i]*i]

```
都可以设为true，当然，这样子如果里面包括了true，就会影响正确性（因为从里面的true转移过来的转移不了了），所以我们让他每个都单独判断

如果f[j]本身是false

如果他前面还有没有用完的弹珠价值个数，就把他设为true,个数减一，不然还是false

因为刷表每一次对于每种f[i]他只会刷一遍，这样子也可以大大优化时间的效率

算法核心代码
```
if(f[k]==true)	q=p;
else if(q>0){
	q--;
	f[k]=true;
}
```


完整代码：
```cpp
/*
written by:ushg8877
time:429ms
memory :756KB
*/
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXT=12e4+5;
int n=6;
int t;
int p;
int sum=0;//记录总价值
bool f[MAXT]={true};
int x=1;//记录回合
int main(){
	while(1){
		sum=0;
		for(int i=1;i<MAXT;i++)
			f[i]=false;
		//初始化
		for(int i=1;i<=n;i++){
			cin>>p;
			sum+=p*i;//价值总和
			for(int j=0;j<i;j++){
				int q=0;//记录可用弹珠价值为i的个数
				for(int k=j;k<=sum;k+=i){
					if(f[k]==true)
						q=p;//全部又可以用了
					else if(q>0){
						q--;//用去1个
						f[k]=true;
					}
				}
			}
		}
		if(sum==0)
		    break;//出口
		if(sum%2==1||f[sum/2]==false)
			printf("Collection #%d:\nCan't be divided.\n\n",x);
		else
			printf("Collection #%d:\nCan be divided.\n\n",x);//输出
		x++;
	}
	return 0;
}
```

---

## 作者：似水年华 (赞：1)

##算法分析

暴力枚举每个弹珠，看看是否能凑成两个弹珠总价值的一半

优化1：如果总价值是奇数，那么一定不能被分成价值相等的两部分

优化2：从价值为6到价值为1的顺序枚举，有利于找到解

##参考程序

```cpp 
#include<stdio.h>
#define MAXN 10
int n,a[MAXN],sum;
bool flag;
void dfs(int now,int cnt)//now是当前的总价值，cnt是已经凑够几个弹珠总价值的一半了 
{
    if(now==sum)//如果当前的总价值是所有弹珠总价值的一半 
    {
        cnt++;//已经凑够数++ 
        now=0;//当前总价值清零 
        if(cnt==2)//如果已经找到两个弹珠总价值的一半
        {
            flag=1;//标记有解 
            return;
        }
    }
    register int i;
    for(i=6;i>=1;i--)//优化2
        if(a[i] && now+i<=sum)//如果还有价值为i的弹珠并且当前总价值加上这个弹珠的价值不超过所有弹珠总价值的一半 
        {
            a[i]--;//拿走这个弹珠 
            dfs(now+i,cnt);//搜索当前的总价值加上这个弹珠的价值
            if(flag)//如果已经找到解了就没必要在继续搜了 
                return;
            a[i]++;//回溯 
        }
}
int main()
{
    register int i;
    while(1)
    {
        flag=0;//标记清零 
        sum=0;//总价值清零 
        for(i=1;i<=6;i++)
        {
            scanf("%d",&a[i]);
            sum+=a[i]*i;//计算总价值 
        }
        if(!sum)//如果都是0就结束程序 
            return 0;
        printf("Collection #%d:\n",++n);
        if(sum&1)//优化1 
        {
            printf("Can't be divided.\n\n");
            continue;
        }
        sum>>=1;//sum现在是总价值的一半 
        dfs(0,0);//从总价值是0，找到0个弹珠总价值的一半开始搜索 
        if(flag)//输出有解信息 
            printf("Can be divided.\n\n");
        else//输出无解信息 
            printf("Can't be divided.\n\n");
    }
}
```

---

## 作者：Exschawasion (赞：0)

**开封前注意**：如果你想要获取严格意义上的正解，那么这篇题解可能无法满足你的要求。不过，如果你是在学校 CF 练习赛上遇到这类题目并且时间不足，那么下面的方法可以用作应急解法。同时请注意：**做题是为了提升思维水平**。

***

首先明确，贪心无法通过本题。靠爆搜通过本题的概率不大，因为单种弹珠的数量可以达到 $200000$。之所以搜索效率低，是因为搜索时进入了大量不可能产生解的分支而导致时间浪费。遇到这样的情况，一种办法是剪枝来加速程序，但是剪枝需要思考，而且错误的剪枝可能导致漏解，在做题时间不充裕时比较吃亏。

卡掉贪心做法的数据是很容易构造的，然而，在这基础上还能卡掉较多**次于贪心**的数据就很难了。事实上大部分方案类题目的数据都是这样。鉴于此，另一种办法就是**随机化**。随机化思路的是很显然的。再加上本题只要求判断能不能均匀分配，不需要计算最优解，所以我们可以不断随机方案，然后暴力检查即可。

随机的方式是：首先将所有弹珠排列在一起，然后随机打乱，从第一个不停往后取，如果发现取走的数量大于一半则退出；如果发现刚好等于一半，则找到了解，返回。平摊时间复杂度是 $O(\frac{1}{2}n)$。当然，这样很容易出现特例而错判，所以我们需要多随机几次，比如 $2000$ 次。试的越多越容易碰上符合要求的解。

当然，还有一些策略可以用来加速程序，主要是在常数方面：

- 事先计算出弹珠价值的总和，如果不能被 $2$ 整除，直接判断失败；
- 随机到一组成功的排列之后，停止计算，直接返回判断成功；
- 使用快读加速程序；
- 对于大数组（大小超过 $10^5$），条件允许的话使用 STL 里的 `vector`。不要使用 `push_back`，使用 `resize` 函数来直接改变 `vector` 的大小，然后当做普通的数组使用即可。

代码如下：

```
#include <bits/stdc++.h>

using namespace std;

int a[7];
int sum_val;

int n;
vector<int> all;

bool single_check() {
	random_shuffle(all.begin(), all.end()); // 随机打乱
	int need = sum_val / 2; // 需要的数量
	int pos = 0;
	while (need > 0) {
		need -= all[pos]; pos++;
	}
	return need == 0; // 等于 0 即为解，小于 0 则为超过一半
}

bool check() {
	for (int i = 1; i <= 2000; i++) if(single_check()) return true;
	return false;
}

int kase = 0;

int main() {
	srand(0xab308ea76a615353816b55f84067fa0aLL); // 随机一个种子
	while (cin >> a[1] >> a[2] >> a[3] >> a[4] >> a[5] >> a[6]) {
		if(!a[1] && !a[2] && !a[3] && !a[4] && !a[5] && !a[6]) break;
		sum_val = 0;
		n = a[1] + a[2] + a[3] + a[4] + a[5] + a[6];
		if (all.size() < n) all.resize(n);
		int pos = 0;
		for (int i = 1; i <= 6; i++) {
			for (int j = 1; j <= a[i]; j++) {
				all[pos++] = i;
				sum_val += i;
			}
		}
		bool ok;
		if (sum_val % 2) ok = false;
		else {
			ok = check();
		}
		kase++;
		printf("Collection #%d:\n", kase);
		if(!ok) {
			puts("Can't be divided.\n");
		}
		else {
			puts("Can be divided.\n");
		}
	}
	return 0;
}
```


---

## 作者：zxc_a (赞：0)

# 分析
本题要求出能否将弹珠平均分配，也就是能否拿出一些弹珠是总数的一半，可以理解为求多重背包方案数，只是方案数只需要1就行

# 实现（多重背包）
时间复杂度明显过高，我们得用优化，先把多组背包转换成01背包，将其转成$log_2N_1+......+log_2N_6$个弹珠：

```

for (int i=1;i<=6;i++){
	x=a[i];//上面输入过a[i]
	v+=x*i;//顺便为下面求弹珠总价值
	t=1;//从1开始枚举2的整数幂
	while (x>=t){//如果t>x就不能做了不然能表达的数会超过a[i]
		b[++n]=t*i;//价值是价值为i的弹珠分到的个数乘上i
		x-=t;
		t*=2;
	}
	if(x)b[++n]=x*i;//如果下x最后没变用完，还要加一个x
}//这样可以求出每一个原来能求出的数


```

我们算一下时间复杂度，每组数据是$O(vlog_2v)$这里$v$指的是弹珠总价值,$log_2v$只是近似值，准确是上面写的弹珠的个数$log_2N_1+......+log_2N_6$

## 康康代码（ _很简单_ ）：

```
#include<bits/stdc++.h>
using namespace std;
int f[60005],a[10],b[1000],n,v,k,x,t;
int main()
{
	#ios::sync_with_stdio(false);
	cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];
	while (a[1]||a[2]||a[3]||a[4]||a[5]||a[6]){//判断如果都是0就结束
		n=v=0;
		k++;
		for (int i=1;i<=6;i++){//上面解释过了
			x=a[i];
			v+=x*i;
			t=1;
			while (x>=t){
				b[++n]=t*i;
				x-=t;
				t*=2;
			}
			if(x)b[++n]=x*i;
		}
		if(v%2){//如果v是单数肯定不行
			printf("Collection #%d:\nCan't be divided.\n\n",k);
			cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];//退出前一定要输入下一组数据不然会无限循环
			continue;
		}
		v=v>>1;//v除以2，只有能求出总价值的1/2就能分成2半
		f[0]=1;
		for (int i=1;i<=n;i++){//遍历每一个物品(弹珠）
			for (int j=v;j>=b[i];j--){
				if(f[j-b[i]])f[j]=1;//如果j-b[i]能被组成，加上b[i]后j也能被组成
			}
		}
		if(f[v]){//如果v能被组成就可以求出总价值的1/2
			printf("Collection #%d:\nCan be divided.\n\n",k);
		}
		else{//如果不能就无法达到目的
			printf("Collection #%d:\nCan't be divided.\n\n",k);
		}
		cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];//输入下一组数据
	}
	return 0;
}

```


就这样了。
#### 备注：
 _~~希望管理大大通过（但是不通过也很好理解。。。。。。水平不行，RP不够，只是想提交题解，根本没想通过。当然，通过最好啦！！！）~~_ 

---

## 作者：infinities (赞：0)

首先观察数据，只有1-6这几种价值，而个数可以较大。

所以不难发现这些弹珠里面大多数都可以通过对半分达到两边平衡的效果，真正可以用来决定是否能使得两边价值相等的其实很少。

显然，想去掉一部分弹珠并且使得去掉的弹珠可以自行对半分，最简单的方法就是使得去掉的每一种价值的弹珠个数均为偶数。

六个1，三个2，两个3的弹珠显然可以被一个6的替换，三个4的可以被两个六的替换，六个5可以被五个6的替换。从这里可以看出，替换关系都为6的因数，而且6恰好为偶数，所以只需把个数%6就好啦。

注意如果弹珠个数不为0且弹珠个数为6的倍数时要留下6个，以免在面对一些数据时得出错解。

比如以下数据：
```
6 0 0 0 0 1
```
若不把1的留下6个，那么显然程序会运行得不能对半分，实际上它可以。

然后对于剩下的极小数据跑一遍暴力即可。

code:
```cpp
#include<bits/stdc++.h>
#define ll long long
#define rint regester int
const int maxn = 1e6 + 10;
const int INF = 1e9;
using std::ios;
using std::cin;
using std::cout;
using std::max;
using std::min;
using std::sort;
using std::unique;
using std::lower_bound;
using std::swap;
using std::abs;
using std::acos;
using std::queue;
using std::map;
using std::string;
int read(){int x = 0,f = 1; char ch = getchar(); while(ch < '0' || ch > '9'){if(ch == '-')f = -1; ch = getchar();}while(ch >= '0' && ch <= '9'){x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar();} return x * f;}
int a[7], ans, fl, out, cnt[101], num;
void print(int i){
    if(out)cout << "Collection #" << i << ":\nCan be divided.\n\n";
      else cout << "Collection #" << i << ":\nCan't be divided.\n\n";}//输出
signed main(){
	while(1){
		++num;
		for(int i = 1; i <= 100; i++)cnt[i] = 0;//多测清空
		out = 1, fl = 0, ans = 0, cnt[0] = 1;
		for(int i = 1; i <= 6; i++)if((a[i] = read()) != 0)fl = 1;
        for(int i = 1; i <= 6; i++)(a[i] % 6 == 0 && a[i] != 0) ? a[i] = 6 : a[i] %= 6;//处理一下
		if(fl == 0)break;
		for(int i = 1; i <= 6; i++)ans += i * a[i];
		if(ans % 2 != 0)out = 0;
		ans /= 2;
		for(int i = 1; i <= 6; i++){
			for(int j = ans; j >= 0; j--){//注意要从大到小，以免重复计算
				if(cnt[j]){
					for(int k = 1; k <= a[i]; k++){
						cnt[j + k * i] = 1;
						//cout << j + k * i << "\n";
					}
				}
			}
		}
		if(!cnt[ans])out = 0;
		print(num);
	}
}
```

---

## 作者：MyukiyoMekya (赞：0)

可行性dp，$f_{i,j}$ 表示用了前 i 种弹珠能否使得玛莎得到的价值减去比尔得到价值的差为 j

初始状态 $f_{0,0}=\text{True}$

那么对于 $a_i $ 个价值为 $i$ 的弹珠，

把 $k$ 个给玛莎，那么就有 $f_{i,j}\leftarrow f_{i,j}\or f_{i-1,j-k\times i}$

把 $k$ 个给比尔，那么就有 $f_{i,j}\leftarrow f_{i,j}\or f_{i-1,j+k\times i}$

注意这里 $f_{i,j}$ 的 $j<0$ 是不需要考虑的，因为两人的对称性，有 $f_{i,j}=f_{i,-j}$ 

答案就是 $f_{n,0}$，为 $\text{True}$ 就说明能分成价值相同的两部分

这显然是个背包，那就可以把第一维压掉

弹珠总数有点大，那就二进制拆分一下

~~转移懒得写~~，可以使用 bitset 来简化转移（顺便把时间复杂度除以一个常数）

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
int a[7];
signed main(void)
{
	reg int tcase=0;
	while(true)
	{
		reg int sum=0;
		for(int i=1;i<=6;++i)
			read(a[i]),sum+=a[i];
		if(!sum)
			break;
		printf("Collection #%d:\n",++tcase);
		bitset<120050> f;
		f.set(0,1);
		for(int i=1;i<=6;++i)
		{
			reg int base=1;
			while(a[i]>=base)
			{
				f=(f<<(i*base))|(f>>(i*base));
				a[i]-=base;
				base<<=1;
			}
			if(a[i])
				f=(f<<(i*a[i]))|(f>>(i*a[i]));
		}
		puts(f.test(0)?"Can be divided.":"Can\'t be divided."),ln;
	}
	return 0;
}
```



---

## 作者：蒟蒻365 (赞：0)

一道多重背包

可以看一看这道题 [p1776](https://www.luogu.org/problemnew/show/P1776)

什么是多重背包？

与01背包唯一的区别是，01背包每件物品只有**一件**，多重背包则有**n[i]件**

怎么做？

### 思路一：

### 暴力。将其变为01背包解决。


对于每个物体，可以选0件、1件...n件，一个循环枚举物品，一个循环枚举选的数量，一个循环跑01背包。复杂度O（mΣn[i])。显然不够优。

在暴力的基础上我们可以做出一定的优化。如果V/w[i]<=n[i],那么我们可以直接跑完全背包。

为啥？~~自己想去~~

V/w[i]就是你能选的最多件数，再多也没有意义，因为背包装不下了。所以如果你能选的最多件数都没有你拥有的件数多，那就相当于有无数件可以选了。~~然而还是过不掉~~

### 思路二：

### 考虑用二进制进行优化。
将每一个n[i]拆开。如17，拆成1，2，4，8，2。要选一件，就选1，2就选2，3就选1和2，4就选4，5就选1和4...1~17中的所有数都可以这样表示出来。

而且是拆分后的数均只使用了一次,就可以全部表示出来。

------------

~~草率地~~证明一下。只有1，可以表示出0~1之间所有数，再加入一个2，可以表示出（0+2）~（1+2），也就是0~3之间的所有数，再加入4，可以表示出0~7之间的所有数，即从零到1、2、4之和之间的所有数...以此类推。

因为我太弱不会严谨证明，只好感性理解一下了。

~~真的好草率啊~~

然后就行了。

upd：之前的证明太草率了...感觉自己跟个sb一样

不妨令x被拆成了1，2，4...2^a,k,其中0<=k<=2^(a+1)

首先证明1，2，4...2^a能表示出0~2^(a+1)-1的数

用数学归纳法证明

首先用1可以表示出0~1的数

若我们能用1，2，4...2^n表示出0~2^(n+1)-1的数

对这个区间的每个数都加上2^(n+1)，我们就表示出了0~2^(n+1)*2-1,即0~2^(n+2)-1之间的所有数

那么我们就说明了1，2，4...2^a能表示出0~2^(a+1)-1的数

再多上k，那就可以表示出0~2^(a+1)-1+k，即0~x之间的所有数（因为x=1+2+4+...2^a+k)

故得证

------------

```
#include<bits/stdc++.h>//宝物筛选的代码，主要是更方便理解
#define maxn 100001
using namespace std;
int W,n,v[maxn],w[maxn],m[maxn],f[40001];
int main(){
	scanf("%d%d",&n,&W);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",v+i,w+i,m+i);
	for(int i=1;i<=n;i++){
		if(w[i]*m[i]>=W)//如果是完全背包
			for(int j=w[i];j<=W;j++) 
				f[j]=max(f[j],f[j-w[i]]+v[i]);
		else{
			int t=1,k=m[i];//进行拆分
			while(t<k){
				for(int j=W;j>=t*w[i];j--) 
					f[j]=max(f[j],f[j-t*w[i]]+t*v[i]);//跑01背包。因为拆分后的每一个数都只会使用一次，所以跑01背包。
				k-=t;
				t*=2;
			}
			for(int j=W;j>=w[i]*k;j--)
				f[j]=max(f[j],f[j-w[i]*k]+v[i]*k);//最后剩下的一坨再跑01背包
		}
	}
	printf("%d",f[W]);
	return 0;
}
```

------------

回到这道题。~~我为什么要说回到~~。现在就很简单了。不过状态的定义以及转移有一点改变。定义f[i]为当背包容量为i时，能否装满。

```
#include<bits/stdc++.h>
using namespace std;
int a[7],tt;
bool f[10001];//只需要纪录是否，所以开bool数组
inline int read(){
	int s=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9'){s=(s<<3)+(s<<1)+c-48;c=getchar();}
	return s*f;
}//快读
inline void work(int sum){//因为要多次执行所以写成函数
	memset(f,0,sizeof(f));//因为要多次执行所以要清空
	f[0]=1;//容量为0时显然能装满。这是边界
	for(int i=1;i<=6;i++){
		if(i*a[i]>=sum)//现在它的体积和价值都是i
			for(int j=i;j<=sum;j++) 
				f[j]=f[j]||f[j-i];//如果f[j-i]能装满，f[j]就能装满
		else{
			int t=1,k=a[i];
			while(t<k){
				for(int j=sum;j>=t*i;j--) 
					f[j]=f[j]||f[j-t*i];//同样的，如果f[j-t*i]能装满，f[j]就能装满
				k-=t;
				t*=2;
			}
			for(int j=sum;j>=i*k;j--)
				f[j]=f[j]||f[j-i*k];//同上。
		}
	}
	if(f[sum]) printf("Collection #%d:\nCan be divided.\n\n",tt);//如果能凑出来，说明能平分
	else printf("Collection #%d:\nCan't be divided.\n\n",tt);
}
int main(){
	while(1){ 
		++tt;
		bool flag=0;
		int sum=0;
		for(int i=1;i<=6;i++){ 
			a[i]=read(),sum+=a[i]*i; 
			if(a[i]) flag=1;//如果不是全都是0的话就可以继续
		} 
		if(!flag) break;//如果全是0结束程序
		if(sum&1) printf("Collection #%d:\nCan't be divided.\n\n",tt);//如果是奇数必然不行
		else work(sum/2); //不是就看能不能凑出sum/2
	}
	return 0;
}
```

---


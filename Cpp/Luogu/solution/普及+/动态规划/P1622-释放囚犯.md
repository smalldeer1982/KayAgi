# 释放囚犯

## 题目描述

Caima 王国中有一个奇怪的监狱，这个监狱一共有 $P$ 个牢房，这些牢房一字排开，第 $i$ 个紧挨着第 $i+1$ 个（最后一个除外）。现在正好牢房是满的。

上级下发了一个释放名单，要求每天释放名单上的一个人。这可把看守们吓得不轻，因为看守们知道，现在牢房中的 $P$ 个人，可以相互之间传话。如果某个人离开了，那么原来和这个人能说上话的人，都会很气愤，导致他们那天会一直大吼大叫，搞得看守很头疼。如果给这些要发火的人吃上肉，他们就会安静点。


## 说明/提示

### 样例说明 #1

先释放 $14$ 号监狱中的罪犯，要给 $1$ 到 $13$ 号监狱和 $15$ 到 $20$ 号监狱中的 $19$ 人送肉吃；再释放 $6$ 号监狱中的罪犯，要给 $1$ 到 $5$ 号监狱和 $7$ 到 $13$ 号监狱中的 $12$ 人送肉吃；最后释放 $3$ 号监狱中的罪犯，要给 $1$ 到 $2$ 号监狱和 $4$ 到 $5$ 号监狱中的 $4$ 人送肉吃。

### 数据规模与约定

- 对于 $50\%$ 的数据，$1 \le P \le 100$，$1 \le Q \le 5$；
- 对于 $100\%$ 的数据，$1 \le P \le 10^3$，$1 \le Q \le 100$，$Q \le P$，保证释放的人所在的牢房编号按递增的顺序给出。

## 样例 #1

### 输入

```
20 3
3 6 14
```

### 输出

```
35
```

# 题解

## 作者：望眼浮云 (赞：112)

**区间dp**

有点难想，老师讲了后才明白，写篇题解巩固一下。

区间dp的套路：设f[i][j]为区间释放i~j号囚犯所需最少的肉（注意，i,j不是牢房编号，是释放的囚犯编号，也就是下面的a[i]数组）

枚举区间的分界点k，转移方程为：

f[i][j]=min{f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1}

把后面这一坨拿出来拆开看看，f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1

f[i][k-1]+f[k+1][j]，这个不必解释

a[j+1]-a[i-1]-1就是第j+1个要放出的囚犯到第i-1个要放出的囚犯之间的人数，也就是要发的肉的数量；

最后一个-1 是什么呢，就是第k个放出去的囚犯，不用给他吃肉了（~~不给肉吃还出去干嘛~~）

附上优美的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000];
int f[1000][1000]; 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+m+1); //排序，有序的才能转移状态
    a[0]=0;a[m+1]=n+1; //假设0和n+1号牢房有人，方便后面的状态转移
    for(int l=1;l<=m;l++)  //枚举区间长度
        for(int i=1;i+l-1<=m;i++) //区间左端点位置
        {
            int j=i+l-1;  //区间右端点位置
            f[i][j]=999999999;  
            for(int k=i;k<=j;k++)  //枚举分界点
                f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1); //状态转移
        }
    printf("%d",f[1][m]);  
}
```

---

## 作者：s223568907 (赞：58)

正着做死活做不出，参考楼下下下所说，将这个过程反过来，把要释放的人视作断点，将p个人分成q+1个区间，求合并区间至一个区间所需最小值，即可视为合并石子，突然通悟......不过要注意分成q+1个区间时的一些细节。

```cpp
#include<bits/stdc++.h>  
using namespace std;  
int s[110][110]={0},p,q,a[110]={0},sum[110]={0};  
inline void init()  
{  
    scanf("%d%d",&p,&q);  
    for(int i=1;i<=q;i++)scanf("%d",&a[i]);  
    a[0]=0;a[++q]=p+1;  
    sort(a,a+q+1);  
    return;  
}  
 
int main()  
{  
    init();  
    for(int i=1;i<=q;i++)  
    sum[i]=a[i]-a[i-1]-1+sum[i-1];//前缀和，将问题转换为求几堆石子合并的最小值  
    for(int k=2;k<=q;k++)  
    for(int i=1;i<=q-k+1;i++)  
    {  
        int j=i+k-1;  
        for(int p=i;p<j;p++)  
        if(!s[i][j]||s[i][j]>s[i][p]+s[p+1][j]+sum[j]-sum[i-1]+j-i-1)//注意j-i+1，是指合并时几个还未释放的人所需的代价
        s[i][j]=s[i][p]+s[p+1][j]+sum[j]-sum[i-1]+j-i-1;  
    }  
    printf("%d",s[1][q]);  
    return 0;  
}  
```

---

## 作者：Day4331Dream (赞：55)

# P1622 释放囚犯

## 读题
先读题：一排牢房，其中一些牢房的犯人需要被**逐个释放**。两个**相邻**牢房如果**都有人**，就会互相传话：“XXX被释放了！！！”

就这样，如果有哪个牢房的犯人被释放了，这条消息就会向这个牢房的左右两边一直传递，直到遇到**空房**，消息才无法传递下去。于是，当一个犯人被释放时，**与之连通的**所有犯人都要吃到一块肉。看守希望发的肉最少，求这个**最小值**。

## 考虑区间DP
我们说一个区间连通，当且仅当这个区间内的所有牢房都有犯人。
1. 一个牢房的犯人被释放时，这个牢房的编号将成为这个区间的一个断点，区间被分裂成**两个连通的子区间**。
2. 一个牢房的犯人被释放时，只有该**连通区间内**的犯人会吃到肉。

随着犯人被不断释放，这排牢房被分割成越来越多的子连通区间。~~恍然大痦~~，这不是**区间DP**吗！然后再仔细一想，诶不对！区间DP不是由子区间**合并**成更大的区间吗？这跟正经的区间DP是反着的啊！~~所以这题无解，散了吧。~~

## 问题转化
既然跟传统的区间DP反着来，那么我们就转化一下问题！

相信大家都看过电影《信条》，~~没看过的建议先去看，然后再做这题。~~ 我们用《信条》的方式，干脆直接把题目**倒过来**：

一排牢房，除了某些牢房，剩下的全部住满了犯人。这些空牢房中要**逐个**关进新的犯人。每当一个牢房关进一个新的犯人，这个牢房就会将左右两个连通区间**合并为一个**，这个新的连通区间内**除了新的犯人自己**非常不爽以外，其它的犯人都因为新伙伴的到来而感到开心，并因此吐出一块肉。然而，吐出一块肉是非常伤身体的，看守们希望犯人们吐出肉的总和最少，求这个**最小值**。

从现在开始，忘掉原题，按照上面这个转化后的问题接着想。

现在问题就变成了，将原来几个**断断续续**的连通区间合并为**一整个**连通区间。豁然开朗，它变成了一道**非常正经的区间DP**。

## Solution
设$f[l][r]$为将区间$[l,r]$合并为一整个连通区间，至少要吐出肉的块数。需要注意的是，这里的$l,r$**并非牢房编号**，而是需要关进去的新犯人的下标。以区间长度作为**阶段**，转移时枚举断点$k$。

初值：$f[i][i]=q[i+1]-q[i-1]-2$

转移方程：$f[l][r]=min\{\ f[l][k]+f[k+2][r]\ \}+q[r+1]-q[l-1]-2$

$q[i]$为编号为$i$的新犯人的牢房编号。枚举断点，再加上新关进去犯人后这个连通区间里吐出肉的块数，**注意每个区间的边界如何处理**。

代码可能写的不是很简洁，并且变量名与题目所给略有不同，仅供参考。

```cpp

#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m; scanf("%d%d",&n,&m);
	int*q=new int[m+2]; *(q++)=0; q[m]=n+1; //方便转移
	for(int i=0;i<m;i++) scanf("%d",&q[i]);
	int**f=new int*[m];
	for(int i=0;i<m;i++) f[i]=new int[m];
	for(int i=0;i<m;i++) f[i][i]=q[i+1]-q[i-1]-2; //初值
    
    //下面不建议照搬，完全可以自己画图或者debug写出来
	for(int i=1;i<m;i++){
		for(int j=0;j<m-i;j++){
			f[j][i+j]=f[j+1][i+j];
			for(int k=j;k<i+j;k++){
				f[j][i+j]=min(f[j][k]+(k+2<=i+j?f[k+2][i+j]:0),f[j][i+j]);
			}
			f[j][i+j]+=q[i+j+1]-q[j-1]-2;
		}
	}
    
	printf("%d",f[0][m-1]);
	return 0;
}

```

如有错误，欢迎指正！

---

## 作者：Leap_Frog (赞：23)

### PS.
在这里，我介绍一个好像其他人都没有想出来的奇怪的DP。  
绝对原创，所以即使有好多篇题解了我还是要再投一篇QAQ。

### Problem.
给定一个$[1,P]$的区间，区间上有$Q$个断点。  
切断每个断点所需要的代价是这个断点当前所在的区间中除了这个断点其他所有点的个数。  
求把所有断点切掉的最小代价。  
（后文中我们设$M=P,N=Q$）

### Solution.
把题目按照`Problem`那样概括出来就不难发现，每两个断点之间的数本质没有任何区别。  
所以我们可以用一个数值来记录每两个断点之间的数值大小。  
举个例子，比如有这样一个输入数据：
```
6 2
2 4
```
（后面我们称这个`2,4`的区间为b）  
![](https://cdn.luogu.com.cn/upload/image_hosting/wbatdmn0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
那么我们可以把这个东西给归纳成这样一个问题（有点类似离散化  
给定一个区间`1,1,2`（后面我们设这个区间为a），要把这个区间给随便等分，其他条件和原题类似。  
然后就轻松地把这个问题的$N$从$1000$变成了$100$。  

那么我们可以考虑区间DP。  
一个区间记录的是把这个区间每一个断点都给拆分的最小代价。  
那么就可以用区间DP最基本的套路，为枚举中间断点然后再转移。  
则转移方程式为：$dp[i][j]=min\{dp[i][k]+dp[k+1][j]+f(i,j)\}$  
$f(i,j)$为把当前这个区间给断了的值，即$\sum_{k=i}^ja[k]$。  
这个东西又可以用前缀和来维护，设这个前缀和为$s$。  
则我们可以轻易地发现，$s[i]=b[i]-i,s[n]=m-n+1$。  
然后我们就可以轻而易举的求出$s[i]$，然后套用DP方程式就可以了QwQ。  

如果还不会地话可以看代码。

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[105],dp[105][105];
int main()
{
	scanf("%d%d",&m,&n),memset(dp,0x3f,sizeof(dp));
	//m和n即为上面的P与Q。
	//因为要求最小值，所以dp初值要为0。
	for(int i=1;i<=n;i++) scanf("%d",a+i),a[i]-=i,dp[i][i]=0;
	//读入所有数据，求出上面的s
	//然后单个区间不需要切分，所以代价为0
	n++,a[n]=m-n+1,dp[n][n]=0;
	//把最后一个s算出来，最后一个dp清零。
	for(int l=1;l<=n;l++)
		for(int i=1,j=i+l;j<=n;i++,j++)
			for(int k=i;k<j;k++)
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+a[j]-a[i-1]+j-i-1);//上面的区间dp转移方程式。
	return printf("%d\n",dp[1][n]),0;//最后输出答案并结束
}
```
~~前排无耻求赞~~

---

## 作者：sSay (赞：17)

# 神特么记忆化搜索

看完题想了想写了个暴力

$$ Dfs(L, R, a, b) $$

用来表示解决$[L,R]$区间，$[a, b]$问题的一个函数

过掉了样例o(\*^＠^\*)o

然后考虑记忆化优化一下

由于我的写法太鬼畜所以只好用map记

### 简直一股清流

``` cpp
#include <map>
#include <cstdio>
#include <cstring>
#include <iostream>

#define INF 1000000007

using namespace std;

const int Maxn = 1010;

map <int, map<int, map<int, map<int, int> > > > dp;

int p, q, x[Maxn];

int Dfs(int l, int r, int a, int b) {
    if(a > b || l > r) return INF;
    if(a == b) {return r - l;}
    if(dp[l][r][a][b] != 0) return dp[l][r][a][b];
    int temp = INF;
    temp = min(temp, Dfs(x[a] + 1, r, a + 1, b));
    temp = min(temp, Dfs(l, x[b] - 1, a, b - 1));
    for(int i = a + 1; i < b; ++i) {
        temp = min(temp, Dfs(l, x[i] - 1, a, i - 1) + Dfs(x[i] + 1, r, i + 1, b));
    }
    temp += r - l;
    return dp[l][r][a][b] = temp;
}

int main() {
    scanf("%d%d", &p, &q);
    for(int i = 1; i <= q; ++i) scanf("%d", &x[i]);
    cout << Dfs(1, p, 1, q) << endl;
    return 0;
}
```

---

## 作者：Vin_1999 (赞：11)

区间dp，如果我们反过来思考，一个一个把人填入牢房中，把一个区间里的i个人，缩成一个人但花费为i，那是不是就变成了石子合并？

可以用四边形不等式优化。

献上我丑陋的代码。







```cpp
#include<bits/stdc++.h>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);++(i))
using namespace std;
const int maxn=1e3+7;
static int a[maxn],w[maxn],n,m,dp[maxn][maxn],s[maxn][maxn];
inline void init()
{
    scanf("%d%d",&n,&m);
    int x=0;
    rep(i,1,m) 
    {
        a[i]=-x;
        scanf("%d",&x);
        a[i]+=x-1;
    }
  a[m+1]=n-x;
  rep(i,1,m+1) w[i]=w[i-1],w[i]+=a[i];
  memset(dp,63,sizeof(dp));
  rep(i,1,m+1) s[i][i]=i,dp[i][i]=0;
}
int main()
{
     init();
     rep(len,2,m+1)
     {
         rep(l,1,n-len+1)
         {
             int r=l+len-1;
             rep(mid,s[l][r-1],s[l+1][r]) if(dp[l][mid]+dp[mid+1][r]+w[r]-w[l-1]+(len-2)<=dp[l][r])
             {
               dp[l][r]=dp[l][mid]+dp[mid+1][r]+w[r]-w[l-1]+(len-2);
                s[l][r]=mid;
            }
        }
  }
  /*rep(len,1,m+1)
  {
      rep(l,1,n-len+1)
      {
          int r=l+len-1;
          if(dp[l][r]>100000) printf("inf ");
          else printf("%d ",dp[l][r]);
        }
        printf("\n");
    }*/
  printf("%d",dp[1][m+1]);
     return 0;
}//by fjlyyz-ljy
```

---

## 作者：andysk (赞：8)

这个题是一个区间DP的好题啊（不知道今天为什么要写DP，大概是想跟哈希一样打摆了:joy:）

首先我们暴力考虑，若直接用 $ f_{i,j} $ 表示释放第 $i$ 个房间到第 $j$ 个房间的犯人所需要的最小代价，显然 $n$ 太大了，放不下，时间复杂度也显得比较高。

但是我们考虑到 $p$ 比较的小，于是可以将这 $p$ 的需要释放的犯人从小到大排序。

用 $ f_{i,j} $ 表示释放第 $i$ 个到第 $j$ 个需要释放的犯人的最小代价，状态数量就大大减小。

转移：枚举这个区间内第一个释放的犯人 $k(i\leq k \leq j)$ ，此时除开 $ a_k$ 之外，$a_i$ 到 $a_j$ 的其他房间都有犯人，所以释放代价是

​		$ (a_{j+1}-1)-a_{len - 1} - 1$			

那么 $f[i][j] = min( f[i][k-1]+f[k+1][j]) + (a_{j+1}-1)-a_{len - 1} - 1 \ (i\leq k \leq j) $

边界条件 $f[i+1][i] = 0$

上代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1000 + 5;
const int inf = 0x7f7f7f7f;

int P, Q;
int a[SIZE], f[SIZE][SIZE];

inline int read()
{
    char ch = getchar();
    int f = 1, x = 0;
    while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
    return x * f;
}

int main()
{
    P = read(), Q = read();
    for(register int i = 1; i <= Q; i++)
        a[i] = read();
    std::sort(a + 1, a + Q + 1);
    a[Q + 1] = P + 1;
    for(register int len = 1; len <= Q; len++)
        for(register int i = 1; len + i - 1 <= Q; i++)
        {
            int j = i + len - 1;
            f[i][j] = inf;
            for(register int k = i; k <= j; k++)
                f[i][j] = std::min(f[i][j], f[i][k - 1] + f[k + 1][j] + a[j + 1] - a[i - 1] - 2);
        }
    printf("%d", f[1][Q]);
    return 0;   
}
```
Blog:tony102.com



---

## 作者：SFWR (赞：8)

一开始看到本题感觉一脸懵逼，这什么玩意

然后，仔细一想（~~看看题解~~）哦~

反着来的石子合并嘛；

我们将所有待删除的都删除，这样一个序列就变成了一块一块的，就是石子合并中的每一堆嘛；

```cpp
for(int i=1;i<=m;i++)cin>>s[i];
	s[++m]=n+1;
	sort(s,s+m+1);
for(int i=1;i<=m;i++)num[i]=s[i]-s[i-1]-1+num[i-1];
```

要注意这里的-1（删除的数不在其中）

然后就和石子合并一样了

```cpp
for(int l=2;l<=m;l++)
for(int i=1;i<=m-l+1;i++)
{int j=l+i-1;dp[i][j]=0x3f3f3f3f;
for(int k=i;k<j;k++)
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+num[j]-num[i-1]+j-i-1);
}
```

这里要注意的一点就是j-i-1，我们合并的同时其中删除的也会回到队列中，所以要加上这些人；

最后输出F[1][m]即可


---

## 作者：Harry_Hedwig (赞：4)

# 0x00 思路
>Caima 王国中有一个奇怪的监狱，这个监狱一共有 $P$ 个牢房，这些牢房**一字排开，第 $i$ 个紧挨着第 $i+1$ 个（最后一个除外）。现在正好牢房是满的。**

>上级下发了一个释放名单，要求每天释放名单上的一个人。这可把看守们吓得不轻，因为看守们知道，现在牢房中的 $P$ 个人，可以相互之间传话。如果某个人离开了，**那么原来和这个人能说上话的人，都会很气愤**，导致他们那天会一直大吼大叫，搞得看守很头疼。如果给这些要发火的人吃上肉，他们就会安静点。

>请你求出**最少**要给多少**人次**送肉吃。

这个“ *原来能和这个人说上话的人* ”指谁呢？

我们从样例解释可以看出是**所有与此人之间的监狱都没有空的人**。那么当我们将一个人释放后，就十分自然地将这个监狱分成了 $2$ 个部分：此人左边的人可以说上话，右边的人也可以说上话，但是**左右**的人不能说上话，因此就可以很自然地想到区间 dp。

# 0x01 定义状态
```d[i][j]```:表示释放第 $Q_i$ 个囚犯和第 $Q_j$ 个囚犯之间（包括 $Q_i$，$Q_j$）的所有需要释放的囚犯所需肉的最小值。

# 0x02 状态转移方程
注意一件事：输入的囚犯的编号。当你细细的观察它们时，你会发现第 $Q_i$ 个囚犯的编号 $Q_i$ 等于他及其前面的所有人的人数，那么这就相当于是一个前缀和，又因为我们放第 $Q_q$ 个囚犯的时候需要给最后一段人肉，所以我们可以假设在这段监狱的最后（$p+1$）还有一个需要释放的囚犯。

再假设我们此时释放囚犯 k，那么我们此时需要的肉的数量即为释放第 $Q_i$ 个囚犯到第 $Q_{k-1}$ 个囚犯与释放第 $Q_{k+1}$ 个囚犯到第 $Q_j$ 个囚犯所需的总肉数加上施放这个囚犯所需的肉的数量。由于我们先选择释放第 $Q_k$ 个囚犯，所以我们需要用 ```a[j+1]-a[i-1]-2``` 的肉（我们的假设是除了第 $Q_i$ 个囚犯到第 $Q_j$ 个囚犯未释放外其他囚犯均已释放，只不过没用肉。），由于先放哪一个囚犯最优不清楚，于是取最小值。

# code
```c
#include<bits/stdc++.h>
using namespace std;
int d[505][505],a[505];
int main()
{
	int m,n,l,i,j,k;
	scanf("%d %d",&m,&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+1+n);//从小到大排序使前缀和成立
   a[n+1]=m+1;//再加一个囚犯
	for(l=1;l<=n;l++)
	{
		for(i=1;i<=n;i++)
		{
			j=i+l-1;
			d[i][j]=1<<30;//赋初值
			for(k=i;k<=j;k++)
				d[i][j]=min(d[i][j],d[i][k-1]+d[k+1][j]+a[j+1]-a[i-1]-2);
		}
	}
	printf("%d",d[1][n]);
	return 0;
}
```

---

## 作者：翠竹叶飞 (赞：4)

此题可想到区间考虑（较难想）。

由于每个区间都会在第一次时被分开，我们枚举分开点，使左右独立。

实现：n^3的dp，为实现方便，可用记忆化搜索，且理解起来更直观。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define rep(i,a,b) for (int i=(a); i<=(b); i++)
#define clr(x) memset(x,-1,sizeof(x));
using namespace std;
int n,m,f[105][105],a[105];
int ans(int l, int r) {
    if (f[l][r]!=-1) return f[l][r];
    f[l][r]=0x7f7f7f7f;
    rep(i,l+1,r-1) f[l][r]=min(f[l][r],ans(l,i)+ans(i,r)+a[r]-a[l]-2);
    return f[l][r];
}
int main()
{
    scanf("%d%d",&n,&m); clr(f);
    rep(i,1,m) scanf("%d",&a[i]); a[0]=0; a[m+1]=n+1;
    rep(i,0,m) f[i][i+1]=0;
    printf("%d",ans(0,m+1));
    return 0;
}
```

---

## 作者：luozhichen (赞：4)

~~前言：这是本蒟蒻第一次提交动态规划的题解，大佬勿喷。~~

这道题是道区间DP的好题啊！首先，我想到的是 $f_{i,j}$ 来表示释放第 $i$ 到第 $j$ 个犯人要给的最少的肉。但是，空间和时间显得太大了。因为数据范围里说了 $p$ 较小，于是我们就将要释放囚犯的范围从小到大排列。 将 $f_{i,j}$ 来表示第 $i$ 个要释放的犯人到第 $j$ 个要释放的犯人最少需要的肉，所以状态转移方程为：
$f[i][j] = min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1)$

前面的 $f[i][k - 1] + f[k + 1][j]$ 就不解释了，后面的 $a[j+1] - a[i-1] - 1 - 1$ 就表示第 $j + 1$ 个囚犯到第$i$ - 1 囚犯要发的肉，后面减两个一代表出去的囚犯用不着再发肉了。




代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001];
int f[1001][1001];
int p,q;
int main(){
	cin >> p >> q;
	for(int i = 1;i <= q;i++){
		cin >> a[i];
	}
	sort(a + 1,a + q + 1);//排一下顺序 
	a[q + 1] = p + 1;
	for(int l = 1;l <= q;l++){//区间长度 
		for(int i = 1;i + l - 1 <= q;i++){//左端点 
			int j = i + l - 1;//右端点 
			f[i][j] = 999999999;
			for(int k = i;k <= j;k++){//从左端点枚举到右端点 
				f[i][j] = min(f[i][j],f[i][k - 1] + f[k + 1][j] + a[j + 1] - a[i - 1] - 1 - 1);//状态转移方程 
			}
		}
	}
	cout << f[1][q];
	return 0;
}

```
蒟蒻的题解，巨佬勿喷。

---

## 作者：不存在之人 (赞：2)

### 算法分析

首先不难看出这是一道区间DP，那么，按照本蒟蒻的意思 

区间DP==三个循环
```cpp
for(int len=2;len<=n;len++)
for(int l=1;l+len-1<=n;l++）
    {
    int r=l+len-1;
    for(int k=l;k<=r;k++)
        状态转移方程；
    }
```
### 接下来就是推方程的事情了

设$f[i][j]$为释放掉i~j号囚犯的最小花费，那么,容易得出

**f[l][r]=min(f[l][r],f[l][k-1]+f[k+1][r]+一个数)**

方程前半部分很好想，某个要释放的囚犯的前面的人与后面的人要用的最小花费的和；

关键是那“一个数”怎么表达出来；

简单分析一下发现，这个数就是$a[r+1]-a[l-1]-2$,就是这个区间的总人数除去自己嘛

带入一组样例，发现OK，那么……
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline int read()
{
    char chr=getchar();
    int f=1,ans=0;
    while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
    while(isdigit(chr))  {ans=ans*10;ans+=chr-'0';chr=getchar();}
    return ans*f;

}
int n,m,a[1005],sum[1005];
int dp[1005][1005];
int main()
{
    n=read();
    m=read();
    for(int i=1;i<=m;i++)   
        a[i]=read();
    sort(a+1,a+m+1);//区间必须要先排序一下，否则影响后面的状态转移
    a[0]=0,a[m+1]=n+1;
    for(int len=1;len<=m;len++)
        for(int l=1;l+len-1<=m;l++)
        {
            int r=l+len-1;
            dp[l][r]=0x3f3f3f3f;//赋成最大值，后面方便取min
            for(int j=l;j<=r;j++)
            dp[l][r]=min(dp[l][r],dp[l][j-1]+dp[j+1][r]+a[r+1]-a[l-1]-2);
        }
    cout<<dp[1][m];
    return 0;
}
```


---

## 作者：Jasonggg15 (赞：2)

**本人蒟蒻，不足之处望包容**

直接无脑记忆化

我们可以开一个数组remember[i][j]代表放完i-j中要放的人的最少送肉数

而放第a[i]个人，就要给**a[i+1]-a[i-1]-2**个人送肉，所以一开始可以先在remember数组中记录
```cpp
for(int i=1;i<=n;i++) remember[i][i]=a[i+1]-a[i-1]-2;
```

而因为i循环到n，所以我们要提前给a[n+1]赋值
```cpp
a[n+1]=m+1;
```
用以计算要送多少肉

奉上代码：
```cpp
#include<iostream>
#include<algorithm>

using namespace std;
int m,n,a[1005],remember[1005][1005];
int lgh(int l,int r)//lgh牛逼 
{
	if(l>r) return 0;
	if(remember[l][r]) return remember[l][r];//已有记录，直接返回值 
	int mi=1000000000;
	for(int i=l;i<=r;i++) mi=min(mi,lgh(l,i-1)+lgh(i+1,r)+a[r+1]-a[l-1]-2);//寻找remember[l][r]的最小值 
    remember[l][r]=mi;
    return remember[l][r];
}
int main()
{
	cin>>m>>n;
	a[n+1]=m+1;//提前赋值用以计算 
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) remember[i][i]=a[i+1]-a[i-1]-2;//放第a[i]个人，就要给a[i+1]-a[i-1]-2个人送肉 
	cout<<lgh(1,n);
	return 0;
}
```
~~管理员大大给过啊啊啊~~

---

## 作者：_skyline (赞：2)

由于一时想不出来~~（太弱）~~，就看瞄了一眼~~（又跑过来抄）~~题解，

这里发布一下加强理解

首先已知一定有某确定的q个人被放出，那么，放出后就发现他们分成了几堆

那么就可以仿照石子合并来做

我们以样例为例

20 3

3 6 14

1 2 3 4 5 6 7...14...20~~（太多了）~~，那么，3,6,14放出了后

1 2|4 5|7...13|15...20（以放出去的人为断点，分成Q+1份）

那么，我们开一个大小为Q+1的数组记录每份个数，相当于重量后缩为一个人

然后就可以发现：

f[x][y]=min(f[x][y],f[x][k]+f[k+1][y]+sums[k]-sums[x-1]+sums[y]+sums[k]);



------------

~~然后你就错了~~，答案为32，为什么？

我们看到若x~y连续，在这里断一个k点，在x~y中除了k都吃肉，k是不吃是对的，但是，在合并后eg:（x,k1）(k1+1,k2)(k2+1,y);
若先合并成（x,k2）时，再合并为(x,y)时，（k1,k1+1）间的断点也要吃肉
那么处理一下断点，详情看代码~~自认为码风最好~~

当然，显然可以用四变形不等式优化，~~可是我不会~~。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<map>
#include<set>
using namespace std;
int f[200][200];
int a[200];
int c[200];
int sums[200];
int main(){
	int m,n;
	scanf("%d%d",&m,&n);
	for(int x=1;x<=n;x++){
		scanf("%d",&a[x]);
	}
	sort(a+1,a+1+n);
	memset(f,0x7f,sizeof(f));
	for(int x=1;x<=n;x++){
		f[x][x]=0;
		c[x]=a[x]-a[x-1]-1;
		sums[x]=sums[x-1]+c[x];
	}
	c[n+1]=m-a[n];
	sums[n+1]=sums[n]+c[n+1];
	f[n+1][n+1]=0;
	for(int len=1;len<=n;len++){
		for(int x=1;x+len<=n+1;x++){
			int y=x+len;
			for(int k=x;k<y;k++){
				f[x][y]=min(f[x][y],f[x][k]+f[k+1][y]+sums[y]-sums[x-1]+k-x+y-k-1);
			}
		}
	}
	printf("%d",f[1][n+1]);
	return 0;
}
```




---

## 作者：万弘 (赞：2)

我是真的不会DP所以用记搜水过····（似乎还有一点点分治思想）

开一个f[l][r]记录下释放l到r中所有罪犯的最小花费

主要是边界l==r时的处理搞好  

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
const ll INF=0x7fffffff;
ll f[1001][1001],a[1001];
ll p,q;
ll dfs(ll l,ll r)
{
    if(f[l][r])return f[l][r];
    if(l==r)return f[l][r]=a[r+1]-a[l-1]-2;
    if(l>r)return 0;//不加会死循环
    ll minn=INF;
    for(ll i=l;i<=r;i++)//都要枚举到
    {
        minn=min(minn,dfs(l,i-1)+dfs(i+1,r)+a[r+1]-a[l-1]-1-1);//也可以是dfs(l,i-1)+dfs(i+1,r)+a[r+1]-a[l-1]-2
    }
    return f[l][r]=minn;
}
int main()
{
    scanf("%lld%lld",&p,&q);
    for(int i=1;i<=q;i++)scanf("%lld",&a[i]);
    a[0]=0;a[q+1]=p+1;
    printf("%lld",dfs(1,q));
    return 0;
}
```
不过要是懂循环顺序可以把它改成DP（~~但我不会~~）

---

## 作者：帅到报警 (赞：2)

### 【题意描述】
在一排监狱中有 m 个需要释放的囚犯，如果放了其中一个，一段与他相连的囚犯都要吃肉，问吃肉最少的释放方案。

### 【分析】
本来我冥思苦想了半天并没有看出**怎！么！划！分！区！间**，然后便偷偷看了题解。。。然后突然明白了并不能将 1 - n 划分区间来做，而是要将这 1 - m 这几个人划分开。这样每两个端点间隔的距离就是需要喂食的人数。这样我们就可以进行一把区间 dp 了，而且跟石子合并很相似。

### 【核心代码】
dp 过程，特别注意要**设置好边界**，我将 a[ 0 ] 设为 0， a[ m + 1 ] 设为 n + 1;
```cpp
for(int len = 1; len <= m; len++)
	for(int i = 1; i + len - 1 <= m; i++)
	{
		int j = i + len - 1;
		f[i][j] = INF;
		for(int k = i; k <= j; k++)
			f[i][j] = Min(f[i][j], f[i][k - 1] + f[k + 1][j] + a[j + 1] - a[i - 1] - 2);
	}
printf("%d", f[1][m]);
```

### 【正解】
```cpp
#include <bits/stdc++.h>
#define N 1001
#define INF 0x7f7f7f7f
using namespace std;

int n, m;
int a[N];
int f[N][N];

inline int read()
{
    char ch = getchar();
	int x = 0, f = 1;
    while(ch > '9' || ch < '0')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
    while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
    return x * f;
}

inline int Min(int a, int b)
{
	return a > b ? b : a;
}

void Solve()
{
	sort(a + 1, a + m + 1);
	a[0] = 0, a[m + 1] = n + 1;
	for(int len = 1; len <= m; len++)
		for(int i = 1; i + len - 1 <= m; i++)
		{
			int j = i + len - 1;
			f[i][j] = INF;
			for(int k = i; k <= j; k++)
				f[i][j] = Min(f[i][j], f[i][k - 1] + f[k + 1][j] + a[j + 1] - a[i - 1] - 2);
		}
	printf("%d", f[1][m]);
}

int main()
{
	n = read(), m = read();
	for(int i = 1; i <= m; i++)
		a[i] = read();
	Solve();
	
	return 0;
}
```
dp 最重要的是思维！！！
#end#

---

## 作者：lili_flyingcutter (赞：2)

# 机智如我！蒟蒻也如我
## 这就是暴力啊，不过像区间dp
## 记住，我这是暴力版的记忆化搜索，非dp，入门找我
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    int a[105],dp[1005][1005],n,m,f[1005];
    int dfs(int l,int r){//记忆化搜索
	if(l>r)return 0;
	if(dp[l][r]!=-1)return dp[l][r];
	int ans=1<<30;
	for(int z=l;z<=r;z++){//枚举断点
		int s=0;
		for(int w=a[z]-1;w>=1&&!f[w];w--)//选，暴力修改标记
		   s++;
		for(int w=a[z]+1;w<=n&&!f[w];w++)
## 精髓！！从当前位置往前后搜到上次释放的人，记录数量
		   s++;
		f[a[z]]=1;
		ans=min(ans,dfs(l,z-1)+dfs(z+1,r)+s);//求最小值
		f[a[z]]=0;
	}
	return dp[l][r]=ans;
    }
    int main(){
	memset(dp,-1,sizeof(dp));//初始化
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	printf("%d",dfs(1,m));//别人都是1——n就我是1——m
    return 0;
    }


---

## 作者：StarPatrick (赞：1)

首先，我们可以知道，牢房一字排开，我们可以知道这是一道**区间DP**，而且区间是线性的。

**思路一**

定义一个函数 $dfs(l, r)$ 表示 $(l, r)$ 区间释放完囚犯最少需要多少块肉
```cpp
int dfs(int l, int r)
```
边界：
```cpp
if (l > r) {
    return dp[l][r] = 0;
}
```
然后我们可以枚举要释放的囚犯，然后这个区间就被**天然地**分成了两个小区间，判断要释放的这个囚犯是不是在这个区间里面，如果是就求一下最小值
```cpp
int ans = 2147483647;
for (int i = 1; i <= n; i++) {
    if (a[i] >= l && a[i] <= r) {
        ans = min(ans, dfs(l, a[i] - 1) + dfs(a[i] + 1, r) + (r - l + 1) - 1);  //-1是由于这个囚犯已经被释放了
    }
}
if (ans == 2147483647) {  //没有要释放的囚犯
    return 0;
}
return ans;
```

最后加上我们的记忆化，连起来就是我们的最终代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int m, n, a[105], dp[1005][1005];
int dfs(int l, int r) {
    if (dp[l][r] != -1) {
        return dp[l][r];
    }
    if (l > r) {
        return dp[l][r] = 0;
    }
    int ans = 2147483647;
    for (int i = 1; i <= n; i++) {
        if (a[i] >= l && a[i] <= r) {
            ans = min(ans, dfs(l, a[i] - 1) + dfs(a[i] + 1, r) + (r - l + 1) - 1);  //-1是由于这个囚犯已经被释放了
        }
    }
    if (ans == 2147483647) {
        return dp[l][r] = 0;
    }
    return dp[l][r] = ans;
}
int main() {
    memset(dp, -1, sizeof(dp));
    cin >> m >> n;
    for (int p = 1; p <= n; p++) {
        cin >> a[p];
    }
    sort(a + 1, a + n + 1);
    cout << dfs(1, m);
    return 0;
}
```
**思路二**

我们可以发现，上面算法的复杂度是 $O(P^2)$ ，空间复杂度是 $O(P^2)$ ，如果这道题 $P$ 的范围较大，这道题就不能用上述方法解决。

我们发现 $Q$ 比 $P$ 小，于是我们可以直接在原数组上进行区间DP，定义一个函数 $dfs(l, r)$ 表示释放 $(l, r)$ 囚犯最少需要多少块肉。

一开始的处理方法都差不多，我们还是枚举要释放的囚犯，原来的区间依然被**天然地**分成两个小区间，只不过在计算花费的肉是需要用到一些技巧。

因为要吃肉的人并不是这个区间里的人数减去 $1$ 了，因为现在的区间表示的是要释放的人，而非所有要吃肉的人。如果要计算吃肉的数量，我们可以先来看原数组。

仔细观察原数组我们可以发现，每个元素的值其实就是这个囚犯及其以前的囚犯的数量和（类比前缀和），于是我们可以知道 $a_{l-1}$ 表示的是之前的分割点，那么 $a_{l-1}+1$ 就是要第一个吃肉的囚犯，同理，$a_{r+1}-1$ 就是最后一个要吃肉的囚犯，因此，除开释放的那个囚犯，需要吃肉的数量就为：$(a_{r+1}-1)-(a_{l-1}+1)+1-1$  
注意：当 $l=1$ 或者 $r=n$ 的时候会越界，我们就可以把 $a_0$ 初始化 $0$，$a_n+1$ 初始化为 $m+1$ 

于是最终代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int m, n, a[105], dp[105][105];
int dfs(int l, int r) {
    if (dp[l][r] != -1) {
        return dp[l][r];
    }
    if (l > r) {
        return dp[l][r] = 0;
    }
    int ans = 2147483647;
    for (int i = l; i <= r; i++) {
        ans = min(ans, dfs(l, i - 1) + dfs(i + 1, r) + (a[r + 1] - 1) - (a[l - 1] + 1) + 1 - 1);  //-1是由于这个囚犯已经被释放了
    }
    return dp[l][r] = ans;
}
int main() {
    memset(dp, -1, sizeof(dp));
    cin >> m >> n;
    a[0] = 0;
    a[n + 1] = m + 1;
    for (int p = 1; p <= n; p++) {
        cin >> a[p];
    }
    sort(a + 1, a + n + 1);
    cout << dfs(1, n);
    return 0;
}
```


---

## 作者：luqyou (赞：1)

# 思路

这是一道~~水~~**区间DP**题。

我们设 $ f[i][j] $ 为区间释放 $ i $ ~ $ j $号囚犯所需最少的肉，那么我们枚举**所有**分界点 $ k $，则：$ f[i][j]=\min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1) $

$ a[j+1]-a[i-1]-1 $ 就是第 $ j+1 $ 个要放出的囚犯到第 $ i-1 $ 个要放出的囚犯之间的人数，也即是**要发的肉**的数量。
 
最后一个 $ -1 $ ，就是第 $ k $ 个放出去的囚犯，**不用再给他发肉了**。

所以，上代码吧！

# 代码：

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define N 10001
#define MOD 1e9+7
#define E 1e-6
#define LL long long
using namespace std;
int a[N];
int f[N][N];
int main()
{
    int p,q;
    cin>>p>>q;
    for(int i=1;i<=q;i++)
        cin>>a[i];
 
    a[0]=0;
    a[q+1]=p+1;
    sort(a+1,a+q+1);
    for(int len=1;len<=q;len++)//枚举区间长度
    {
        for(int i=1;i+len-1<=q;i++)//枚举所有起点
        {
            int j=i+len-1;//终点位置
            f[i][j]=INF;
            for(int k=i;k<=j;k++)//枚举所有间断点
                f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1);
        }
    }
 
    cout<<f[1][q]<<endl;
 
    return 0；
}
```


---

## 作者：骆钿皓 (赞：1)

这道题一看就会想到区间dp 因为这是区间问题， 所以f[i][j]就表示从第i个位置到第j个位置一共要给多少肉， 因为所以显而易见 f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]-1-1); 不用多说 上程序

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,m,a[1000+5],f[1000+5][1000+5];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
    	scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	a[0]=0;//初始化
	a[m+1]=n+1;//初始化
	for(int len=1;len<=m;len++)
    	for(int i=1;i+len-1<=m;i++)
    	{
       		int j=i+len-1;//第j为可用公式  开始的位置+长度-1；
        		f[i][j]=2147483647;  
       		for(int k=i;k<=j;k++)
            	f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[j+1]-a[i-1]+1-1-1-1);//dp转方程
    	}
	printf("%d",f[1][m]);  
}
```


---


# 田忌赛马

## 题目描述

我国历史上有个著名的故事： 那是在 $2300$ 年以前。齐国的大将军田忌喜欢赛马。他经常和齐王赛马。他和齐王都有三匹马：常规马，上级马，超级马。一共赛三局，每局的胜者可以从负者这里取得 $200$ 银币。每匹马只能用一次。齐王的马好，同等级的马，齐王的总是比田忌的要好一点。于是每次和齐王赛马，田忌总会输 $600$ 银币。

田忌很沮丧，直到他遇到了著名的军师――孙膑。田忌采用了孙膑的计策之后，三场比赛下来，轻松而优雅地赢了齐王 $200$ 银币。这实在是个很简单的计策。由于齐王总是先出最好的马，再出次好的，所以田忌用常规马对齐王的超级马，用自己的超级马对齐王的上级马，用自己的上级马对齐王的常规马，以两胜一负的战绩赢得 $200$ 银币。实在很简单。

如果不止三匹马怎么办？这个问题很显然可以转化成一个二分图最佳匹配的问题。把田忌的马放左边，把齐王的马放右边。田忌的马 A 和齐王的 B 之间，如果田忌的马胜，则连一条权为 $200$ 的边；如果平局，则连一条权为 $0$ 的边；如果输，则连一条权为 $-200$ 的边……如果你不会求最佳匹配，用最小费用最大流也可以啊。 然而，赛马问题是一种特殊的二分图最佳匹配的问题，上面的算法过于先进了，简直是杀鸡用牛刀。现在，就请你设计一个简单的算法解决这个问题。


## 说明/提示

### 数据规模与约定

- 对于 $20\%$ 的数据，$1\le N\le 65$；
- 对于 $40\%$ 的数据，$1\le N\le 250$；
- 对于 $100\%$ 的数据，$1\le N\le2000$。


## 样例 #1

### 输入

```
3
92 83 71
95 87 74```

### 输出

```
200```

# 题解

## 作者：北街的九命貓 (赞：164)

```cpp
#include <iostream> 
#include <cstdio>
#include <algorithm> 
using namespace std; 
const int Max=10000; 
int tian[Max],king[Max];
int i,j,n; 
bool cmp(int a,int b) {return a>b;}
int main()
{ 
cin>>n;
for(i=1;i<=n;i++) 
{
    cin>>tian[i];
}
for(i=1;i<=n;i++) 
{
    cin>>king[i];
}
sort(tian+1,tian+1+n,cmp); 
sort(king+1,king+1+n,cmp);
int ans=0;
int ii,jj; 
for(i=1,j=1,ii=n,jj=n;i<=ii;)
{
      if(tian[i]>king[j])
      {
         ans+=200;
         i++;
         j++;
      } 
      else if(tian[i]<king[j])
      {
           ans-=200;
           j++;
           ii--;
      }
      else
      {
          if(tian[ii]>king[jj])
          {
             ans+=200;
             ii--;
             jj--;
          } 
          else
          {
             if(tian[ii]<king[j]) 
                ans-=200;
             ii--;
             j++;
          }
      }
} 
  cout<<ans;
  return 0;
}
```

```
1、开始也是先排序，可以使用sort快排；
2、然后将田忌最大的马与国王进行比较；
3、如果田忌最大的马大于国王，那么就胜场++；
4、如果田忌最大的马小于国王，那么就一定会输，所以用田忌最小的马输给国王最大的马；
5、如果田忌最大的马等于国王，那么就比较最小的马；
5。1、如果田忌最小的马大于国王，那么胜场++；
5。2、如果田忌最小的马小于国王，那么就输给国王；
5。3、如果田忌最小的马等于国王，就用田忌最小的马对国王最大的马，如果国王最大的马大，那么财产要减200；
还有动规的
1.思路
不妨用贪心思想来分析一下问题。因为田忌掌握有比赛的“主动权”，他总是根据齐王所出的马来分配自己的马，所以这里不妨认为齐王的出马顺序是按马的速度从高到低出的。由这样的假设，我们归纳出如下贪心策略：
如果田忌剩下的马中最强的马都赢不了齐王剩下的最强的马，那么应该用最差的一匹马去输给齐王最强的马。
如果田忌剩下的马中最强的马可以赢齐王剩下的最强的马，那就用这匹马去赢齐王剩下的最强的马。
如果田忌剩下的马中最强的马和齐王剩下的最强的马打平的话，可以选择打平或者用最差的马输掉比赛。
2.反例
光是打平的话，如果齐王马的速度分别是1 2 3，田忌马的速度也是1 2 3，每次选择打平的话，田忌一分钱也得不到，而如果选择先用速度为1的马输给速度为3的马的话，可以赢得200两黄金。
光是输掉的话，如果齐王马的速度分别是1 3，田忌马的速度分别是2 3，田忌一胜一负，仍然一分钱也拿不到。而如果先用速度为3的马去打平的话，可以赢得200两黄金
3.解决方案
通过上述的三种贪心策略，我们可以发现，如果齐王的马是按速度排序之后，从高到低被派出的话，田忌一定是将他马按速度排序之后，从两头取马去和齐王的马比赛。有了这个信息之后，动态规划的模型也就出来了！
4.DP方程
设f[i,j]表示齐王按从强到弱的顺序出马和田忌进行了i场比赛之后，从“头”取了j匹较强的马，从“尾”取了i-j匹较弱的马，所能够得到的最大盈利。
状态转移方程如下：
F[I,j]=max{f[i-1,j]+c[n-(i-j)+1,i],f[i-1,j-1]+c[j,i]}
其中g[i,j]表示田忌的马和齐王的马分别按照由强到弱的顺序排序之后，田忌的第i匹马和齐王的第j匹马赛跑所能取得的盈利，胜为1，输为－1，平为0。
结果用最大的乘以200即可。
5.解释
为什么F[I,j]=max{f[i-1,j]+c[n-(i-j)+1,i],f[i-1,j-1]+c[j,i]}可以呢？
因为你无论怎么样都是从前或者从后面取马，而F[I,j]=max{f[i-1,j]+c[n-(i-j)+1,i],f[i-1,j-1]+c[j,i]}这个方程把所有可能的贪心情况都表示出来了
```
**希望可以帮助到你**

---

## 作者：OItby (赞：121)

[传送门](https://www.luogu.org/problemnew/show/P1650)$($田忌赛马$)$

![样例图(POJ)](http://poj.org/images/2287_1.jpg)


------------

# 分析 $:$ [DP](https://baike.sogou.com/v61658563.htm?fromTitle=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92) 或 [贪心](https://baike.sogou.com/v1706021.htm?fromTitle=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)


------------

## 1.$DP$ $:$ 
设$f[i][j]$表示齐王按从强到弱的顺序出马和田忌进行了$i$场比赛之后，从$"$头$"$取了$j$匹较强的马，从$"$尾$"$取了$i$-$j$匹较弱的马，所能获得的最大盈利。
### 则状态转移方程为:$f[i][j]$ $=$ $max$ $($ $f[i-1][j]$ $+$ $g[n-(i-j)+1][i]$ $,$ $f[i-1][j-1]$ $+$ $g[j][i]$ $;$
其中$g[i][j]$表示田忌的马和齐王的马分别按照由强到弱的顺序排序之后，田忌的第 $i$ 匹马和齐王的第 $j$ 匹马赛跑所能取得的盈利，胜为 $200$ ，负为 $-200$ ，平为 $0$。

### 图解：

![](https://cdn.luogu.com.cn/upload/pic/51624.png)
![](https://cdn.luogu.com.cn/upload/pic/51623.png)


### 动态规划方法一：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N=2001,INF=-2e+8;
int a[N],b[N],g[N][N],f[N][N];

bool Cmp(int n1,int n2) {return n1>n2;}

int main()
{
	int n,Ans,i,j; scanf("%d",&n);
	for (i=1;i<=n;++i) scanf("%d",&a[i]);
	for (i=1;i<=n;++i) scanf("%d",&b[i]);
	sort(a+1,a+n+1,Cmp),sort(b+1,b+n+1,Cmp);
	for (i=1;i<=n;++i)
		for (j=1;j<=n;++j)
		{
			if (a[i]>b[j]) g[i][j]=200;
			else if (a[i]==b[j]) g[i][j]=0;
				 else g[i][j]=-200;
			f[i][j]=INF;
		}
	for (i=1;i<=n;++i)
	{
		f[i][0]=f[i-1][0]+g[n-i+1][i];
		f[i][i]=f[i-1][i-1]+g[i][i];
		for (j=1;j<i;++j)
			f[i][j]=max(f[i-1][j]+g[n-i+j+1][i],f[i-1][j-1]+g[j][i]);
	}
	Ans=f[n][1];
	for (i=2;i<=n;++i) Ans=max(Ans,f[n][i]);
	printf("%d\n",Ans);
	return 0;
}
```
### 动态规划方法一的内存优化：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N=2001,INF=-2e+8;
int a[N],b[N],g[N][N],f[N];

bool Cmp(int n1,int n2) {return n1>n2;}

int main()
{
    int n,Ans,i,j; scanf("%d",&n);
    for (i=1;i<=n;++i) scanf("%d",&a[i]);
    for (i=1;i<=n;++i) scanf("%d",&b[i]);
    sort(a+1,a+n+1,Cmp),sort(b+1,b+n+1,Cmp);
    for (i=1;i<=n;++i)
        for (j=1;j<=n;++j)
        {
            if (a[i]>b[j]) g[i][j]=200;
            else if (a[i]==b[j]) g[i][j]=0;
                 else g[i][j]=-200;
        }
    for (i=1;i<=n;++i) f[i]=INF;
    for (i=1;i<=n;++i)
    {
        f[i]=f[i-1]+g[i][i];
        for (j=i-1;j>0;--j)
            f[j]=max(f[j]+g[n-i+j+1][i],f[j-1]+g[j][i]);
        f[0]=f[0]+g[n-i+1][i];
    }
    Ans=f[1];
    for (i=2;i<=n;++i) Ans=max(Ans,f[i]);
    printf("%d\n",Ans);
    return 0;
}
```
### 动态规划方法二：
解释见[POJ 2287 【Tian Ji -- The Horse Racing】](https://www.luogu.org/blog/141448/poj-2287-tian-ji-the-horse-racingtby)
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N=2001;
int a[N],b[N],dp[N][N];

bool Cmp(int x,int y) {return x>y;}

int main()
{
	int n,i,j; scanf("%d",&n);
	for (i=1;i<=n;++i) scanf("%d",&a[i]);
	for (i=1;i<=n;++i) scanf("%d",&b[i]);
	sort(a+1,a+n+1,Cmp),sort(b+1,b+n+1,Cmp);
	for (i=1;i<=n;++i)
		for (j=1;j<=n;++j)
			if (a[i]>b[j]) dp[i][j]=max(dp[i-1][j-1]+200,max(dp[i-1][j]-200,dp[i][j-1]-200));
			else if (a[i]==b[j]) dp[i][j]=max(dp[i-1][j-1],max(dp[i-1][j]-200,dp[i][j-1]-200));
				 else dp[i][j]=max(dp[i-1][j]-200,dp[i][j-1]-200);
	printf("%d\n",dp[n][n]);
	return 0;
}
```



------------


## 2.$\text{贪心}$ $($推荐$)$ $:$ 分以下三种情况考虑：

- #### 如果田忌目前的最快马快于齐王目前的最快马，则两者比

- #### 如果田忌的最快马慢于齐王的最快马，则用田忌的最慢马与齐王的最快马比$($减少损失$)$

- #### 如果田忌的最快马和齐王的最快马相等，分以下两种情况：
	1. 若田忌的最慢马快与齐王的最慢马，两者比（能赢就赢呗）
    2. 其他，用田忌的最慢马与齐王的最快马比（贡献最大）


### 贪心代码：

	#include <iostream>
	#include <cstdio>
	#include <algorithm>
	using namespace std;
	
	const int N=2001;
	int a[N],b[N];
	
	void Scanf(int &x)
	{
		x=0;
		char s=getchar();
		while(s<'0'||s>'9') s=getchar();
		while(s>='0'&&s<='9') x=x*10+s-'0',s=getchar();
	}
	
	int main()
	{
		int Ans,n,la,lb,ra,rb,i;
		Scanf(n);
		for (i=1;i<=n;++i) Scanf(a[i]);
		for (i=1;i<=n;++i) Scanf(b[i]);
		sort(a+1,a+n+1),sort(b+1,b+n+1);
		Ans=0,la=lb=1,ra=rb=n;
		for (i=1;i<=n;++i)
		{
			if (a[ra]>b[rb]) Ans+=200,--ra,--rb;
			else if (a[ra]<b[rb]) Ans-=200,++la,--rb;
				 else if (a[la]>b[lb]) Ans+=200,++la,++lb;
				 	  else
				 	  {
				 	  	if (a[la]<b[rb]) Ans-=200;
				 	  	++la,--rb;
			 		  }
		}
		printf("%d\n",Ans);
		return 0;
	}




---

## 作者：梦里调音 (赞：32)

这篇题解主要是对其他dalao的题解的解说

	Q1.这个“怼”究竟是个啥子意思？

	A：用田忌最坏的马浪费掉齐王的好马
    
    Q2。这个左、右指针又是个啥？
    
    A：相当于排除掉不符合故事情节的部分（故事大家都知道），剩下的就可以按故事套路出牌了
    
    Q3。这个。。。究竟要不要特判？
    
    A：不用的！用else排除就可以了（liao）。因为有要求：“同等级的马，齐王的总是比田忌的要好一点”
    
```
#include <bits/stdc++.h>
using namespace std;
int qw[10000001],tj[10000001],ht,hw,tt,tw,ans;
int main(){
    int i,j,k,m,n;
    cin>>n;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&tj[i]);
    }
    for(i=1;i<=n;i++)
    {
        scanf("%d",&qw[i]);
    }
    sort(tj+1,tj+1+n);
    sort(qw+1,qw+1+n);
    ht=hw=1;//左指针 
    tt=tw=n;//右指针   越右马越好 
    for(i=1;i<=n;i++)
        if(tj[tt]>qw[tw]){//若田忌的快马能赢 加200银子，双方右指针都左移
             ans+=200;
             tt--;
             tw--;
        }
        else if(tj[ht]>qw[hw]){//否则比较双方最慢的马 能赢则双方左指针右移
            ans+=200;
            ht++;
            hw++;
        }
        else if(tj[ht]<qw[tw]){//不行的话就用田忌最坏的马浪费掉齐王的好马
            ans-=200;
            ht++;//左指针右移
            tw--;//右指针左移 
        }
    cout<<ans;
    return 0; 
}
```

---

## 作者：Vatyr (赞：26)

一道很简单的贪心题。思路：赚到自己能赚的钱（废话）。

首先将王和田忌的马的速度排序，然后先用田忌最快的马与齐王最快的马去比能赢则赢，赚银子。如果不行的话，我们再考虑当前双方最慢的马。若田忌的快，就赢银子，如果还比不过，就怼了齐王的快马。两个指针扫一遍即可。

代码如下（可能有啥鬼bug我也不清楚[滑稽]）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int tj[10004],king[10004];
bool t[10040],k[10040];
int n;
int  main()
{
    cin>>n;
    int ans=0;
    for(int i=1;i<=n;i++)
        cin>>tj[i];
    for(int i=1;i<=n;i++)
        cin>>king[i];
    sort(tj+1,tj+n+1);        //排序
    sort(king+1,king+1+n);
    int kn=n,tn=n,ti=1,ki=1; //双方各设两个指针
    while(n--)
    {
        if(tj[tn]>king[kn])//若田忌的快马能赢 加200银子，双方右指针都左移
        {
            ans+=200;
            kn--;
            tn--;
        }
        else if(tj[ti]>king[ki])//否则比较双方最慢的马 能赢则双方左指针右移
        {
            ans+=200;
            ki++;
            ti++;
        }
        else if(tj[ti]<king[kn])//否则只能怼 田忌左指针右移  齐王右指针左移
        {
            ans-=200;
            ti++;
            kn--;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：IRipple (赞：22)

题面看完就有意无意的想建二分图。。。网络流。。。

听说贪心也可以ac，，，没试过不管

区间dp是比较常用的的做法，代码量相对较少【难调啊qwq】



------------
区间dp一般需要枚举区间长度，而且大多在最外层；

此外还需要枚举区间左端点；
 
对于这道题，我们用$f[i][j]$来表示田忌剩余的马从$i$到$j$的最大盈利。

换言之，$f[i][j]$表示田忌还剩 $i-j$的马，而储存的值则表示赢齐王最多的钱。

比较难的是**边界问题：**

我们可以想象：最后一场比赛的情况，

这时候，田忌派出了某一匹马，而齐王派出了**最后一匹马。**

由此我们可以确定区间为1的时候，f[i][i]所有的状态，赢了最后一匹马则为$+200$，输了$-200$，平局不管。

```
//b表示田忌的马，a表示齐王的马.
for(int i=1;i<=n;i++){//用i枚举所有区间长度为1的状态
        if(b[i]>a[n]){//这匹马能赢齐王最后一匹马
            f[i][i]=200;//盈利200
        }
        if(b[i]<a[n]){//同理
            f[i][i]=-200;
        }
    }
```
处理好边界，我们需要确定**转移**。

首先，区间dp第一层for循环我们枚举区间长度，因为有预处理，所以从长度=2开始（也即是田忌剩两匹马，三匹马... ...）

内层枚举区间左端点，因为我比较懒直接从1到n，之后算出右端点不符合直接continue掉。

我们继续推状态转移方程

对于$f[i][j]$它的状态有两种来源：

1. 从$f[i+1][j]$中来，加上左端点$i$的对战结果。

1. 从$f[i][j-1]$中来，加上右端点$j$的对战结果。

看起来我们能写出方程了，且慢。

我们还没确定对手齐王的马是谁。

这个不难，区间长度为1，对战齐王最后1匹马。

区间长度为2，对战齐王倒数第2匹马。

... ...

区间长度为n，对战齐王倒数第n匹马。

因此我们就能确定对手是谁了，给出核心伪代码：

```
for(int i=2;i<=n;i++){//区间长度
        for(int j=1;j<=n;j++){//左端点
            int k=j+i-1;//右端点
            if(k>n) continue;//超过直接跳过
            int u=a[n-i+1];//对手
            f[j][k]=max(f[j+1][k]+g(u,b[j]),f[j][k-1]+g(u,b[k]));//转移方程
        }
    }
```
这里的g函数是比较函数，很简单
```
int g(int x,int y){
    if(x>y) return -200;
    if(x<y) return 200;
    if(x==y) return 0;
}
```
结尾给出完整代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define inf 0x3f3f3f3f
#define N 2010
using namespace std;
int cmp(int x,int y){
    return x>y;
}
int g(int x,int y){
    if(x>y) return -200;
    if(x<y) return 200;
    if(x==y) return 0;
}
int n,a[N],b[N],f[N][N];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>b[i];
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1,cmp);
    sort(b+1,b+n+1,cmp);	
    for(int i=1;i<=n;i++){
        if(b[i]>a[n]){
            f[i][i]=200;
        }
        if(b[i]<a[n]){
            f[i][i]=-200;
        }
    }
    for(int i=2;i<=n;i++){
        for(int j=1;j<=n;j++){
            int k=j+i-1;
            if(k>n) continue;
            int u=a[n-i+1];
            f[j][k]=max(f[j+1][k]+g(u,b[j]),f[j][k-1]+g(u,b[k]));
        }
    }
    /*cout<<endl;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cout<<f[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<endl;*/
    cout<<f[1][n];
    return 0;
}
```

---

## 作者：shadowice1984 (赞：17)

按楼下大佬们讲的贪心

如果头尾可以赢就直接赢钱；

然后不行的花就用最坏的马浪费掉齐王的好马。

然后你就得了10分；

因为没！有！特！判！

如果在怼的时候平局了，是不扣钱的！！！

        
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
int n;int qw[2000];int tj[2000];
int* headqw;int* tailqw;int* headtj;int* tailtj;
int res;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&tj[i]);
    }
    for(int i=0;i<n;i++)
    {
        scanf("%d",&qw[i]);
    }
    sort(tj,tj+n);sort(qw,qw+n);//排序
    tailqw=qw;tailtj=tj;headqw=qw+n-1;headtj=tj+n-1;//头尾指针，方便代码
    for(int i=0;i<n;i++)
    {
        if(*headtj>*headqw)//头是否能赢
        {
            res+=200;headtj--;headqw--;
            continue;
        }
        if(*tailtj>*tailqw)//尾是否能赢
        {
            res+=200;tailtj++;tailqw++;
            continue;
        }
        if(*tailtj<*headqw)//硬怼
        {
            res-=200;
            tailtj++;headqw--;
        }
        else if(*tailtj==*headqw)//特判！！！（敲黑板）不加就是10分！
        {
            tailtj++;headqw--;
        }
    }
    printf("%d",res);
    return 0;//拜拜程序~
}
```

---

## 作者：Z__X (赞：12)

## 一道经典的题目 $ QWQ $
### 如果做完这道题，推荐大佬顺便A一下[P2587 [ZJOI2008]泡泡堂](https://www.luogu.org/problemnew/show/P2587)，只是在这道题的基础上反着做一遍就可以了。
### 要想做这道题，千万别被描述中那最后一段话吓到了...（本蒟蒻直接瘫坐在地上）
### 相对于泡泡堂，这道题就显得较为简单了。
### 首先排序qsort，必须滴-----
### 然后做的时候分下面三种情况：
- #### 先用自己队最强的和对方队最强的互怼一下，如果能赢，那么就把分数+2,指针各往后移动一格，进入下一次循环；（比如说下图）
![](https://i.loli.net/2019/02/02/5c55580249db5.png)

- #### 如果怼不过，那就再拿自己队最弱的和对方队最强的怼，能怼赢，同样的，加上分数，指针往前移一格（比如说下图）；
![](https://i.loli.net/2019/02/02/5c555882e64e1.png)

- #### 若是还怼不过，只能硬刚了，就拿自己队最弱的耗掉对方最强的，移动指针（比如下图）
![](https://i.loli.net/2019/02/02/5c5559584306d.png)

### 特别注释：这几张~~也许~~跟泡泡堂某篇题解里的图一样，那篇题解也是我写的，请管理员巨佬不要怀疑$ QAQ $
### 下面就来瞧一瞧丑陋的代码吧：
```
type arr=array[0..2000] of longint;  //让下面排序尽可能地方便一些，也可以排两次序
var
  n,i,tjhead,qwhead,tjtail,qwtail,ans:longint;
  tj,qw:array[0..2000] of longint;
procedure qsort(l,r:longint;var a:arr);  //瞧，这边'a:arr'用到了吧
var
  i,j,mid,t:longint;
begin
  i:=l;j:=r;
  mid:=a[(l+r)>>1];
  repeat
    while a[i]<mid do inc(i);
    while a[j]>mid do dec(j);
    if i<=j then
     begin
       t:=a[i];a[i]:=a[j];a[j]:=t;
       inc(i);dec(j);
     end;
  until i>j;
  if l<j then qsort(l,j,a);
  if i<r then qsort(i,r,a);
end;                          //快排...
begin
  readln(n);
  for i:=1 to n do read(tj[i]);
  readln;
  for i:=1 to n do read(qw[i]);
  qsort(1,n,tj);  //排田忌的马
  qsort(1,n,qw);  //排齐王的马
  tjhead:=1;qwhead:=1;tjtail:=n;qwtail:=n;  //初始化，不说了
  ans:=0;
  for i:=1 to n do
   begin
     if tj[tjhead]>qw[qwhead] then  //见上文第一种情况
      begin
        inc(ans,200);
        inc(tjhead);
        inc(qwhead);
        continue;
      end;
     if tj[tjtail]>qw[qwtail] then  //见上文第二种情况
      begin
        inc(ans,200);
        dec(tjtail);
        dec(qwtail);
        continue;
      end;
     if tj[tjhead]<qw[qwtail] then  //见上文第三种情况，硬刚
      begin
        dec(ans,200);
        inc(tjhead);
        dec(qwtail);
      end
       else
     if tj[tjhead]=qw[qwtail] then  //硬刚还平局！！！QAQ
      begin
        inc(tjhead);
        dec(qwtail);
      end;
   end;
  write(ans);  //输出田忌能拿到的money￥￥
end.
```

---

## 作者：Jigsaw_Killer (赞：8)

就说一下思路吧。一题简单的贪心，遵守一句话：“赢要赢的最经济，输要输的最彻底”。首尾两个指针，先比较田忌与齐王最怂的马，如果田忌的更怂，就拿田忌的怂马和齐王的最好的马赛跑，然后指针都右移；如果田忌最好的马刚好能赛过齐王的马，那么就去赛。，然后指针都左移；不然的话就用田忌最怂的马硬杠齐王最好的马。代码详见楼下诸位神犇。


---

## 作者：cheating_dictator (赞：7)

我的题解很简单很容易理解，适合~~像我一样的~~蒟蒻

一道很简单的~~入门~~贪心题



思路：

1、因为速度最大为100，所以用[桶排](https://baike.baidu.com/item/%E6%A1%B6%E6%8E%92%E5%BA%8F/4973777?fr=aladdin)，输入两个人的马速，存在两个数组里，并找出两个人的最大值、最小值，减少后面不必要的查找。


------------

2、将田忌的马从小到大遍历，像这样：
```cpp
for(int i=min1;i<=max1;i++){
        int ss=a[i];           //同一速度的马有很多，所以都要遍历，ss表示当前速度马的总数
        for(int j=1;j<=ss;j++){
        
            //比较
            
        }
    }
```

然后~~干死~~与一个**比自己慢**而且与自己**差距最小**的马比，这样把能赢的都赢了。

如果找不到则跳过。


------------

3、再次将田忌的马用同样的方法从小到大遍历。

因为第二步已经把能赢的都~~肝~~赢了，所以不会出现比自己小的了。

**即齐王的任何一个马一定大于等于田忌的马。**

在此过程中为了多获取银币，还要尽量争取平局。

最后输出答案。



------------
### **Code：**

```cpp
#include<iostream>
using namespace std;
int a[101]={0},b[101]={0};   //分别存田忌和齐王的马
int n;                //马数
int main(){
    int sum,min1=999,min2=999,max1=0,max2=0;   //sum：存银币，min1、min2：田忌、齐王最慢马；max1,max2:田忌、齐王最快马。
    cin>>n;
    for(int i=1;i<=n;i++){           //输入田忌的马
        int x;
        cin>>x;
        a[x]++;            //桶排
        if(x<min1)				//存最大值、最小值
        min1=x;
        if(x>max1)
        max1=x;
    }
    for(int i=1;i<=n;i++){        //输入齐王的马
        int x;
        cin>>x;
        b[x]++;
        if(x<min2)
        min2=x;
        if(x>max2)
        max2=x;
    }
    for(int i=min1;i<=max1;i++){             //步骤2
        int ss=a[i];
        for(int j=1;j<=ss;j++){
            for(int k=i-1;k>=min2;k--){
                if(b[k]>0)        //赢
                {
                    b[k]--;
                    a[i]--;
                    sum+=200;
                    break;
                }
            }
        }
    }
    for(int i=min1;i<=max1;i++){
        int ss=a[i];
        for(int j=1;j<=ss;j++){
            if(b[i]>0){            //平局
                a[i]--;           
                b[i]--;
                continue;
            }
            for(int k=max2;;k--){
                if(b[k]>0)           //输
                {
                    b[k]--;
                    a[i]--;
                    sum-=200;
                    break;
                }
            }
        }
    }
    cout<<sum;
}
```
[亲测AC](https://www.luogu.org/record/25506200)

---

## 作者：MorsLin (赞：6)

[**题目传送门**](https://www.luogu.org/problemnew/show/P1650)

贪心好题，原题应为[**LA3266**](https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1267)

---

首先给国王和田忌的马从小到大排序

接下来是贪心策略：

1. 首先比最快的马，如果能赢就直接赢
2. 如果赢不了，就比国王和田忌最慢的马，能赢就赢
3. 如果最慢的马也赢不了，就用最慢的马去怼国王最快的马

为什么这么做是对的呢？

首先，如果我方最快的马能赢对方最快的马，肯定要赢，这不难理解  
如果赢不了，那有两种情况，一种是平，一种是输  
如果输了，反正也是输，我当然要保留实力，用最菜的马去输，这也不难理解  
但如果平了，怎么办？  
此时，单纯的比一端并不能保证最优策略  

| 国王  | 田忌  |
| :---: | :---: |
|   4   |   4   |
|   3   |   3   |
|   2   |   2   |
|   1   |   1   |

比如这样，用最慢的马去输给国王，可以换来之后的全胜。显然这样更优  
所以我们可以先比最慢的马，能赢的话就赢，因为它还有价值，不用去给最快的马当炮灰。  
如果赢不了，就把它送出去，浪费对方的好马。

Code
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
const int MAXN = 2010;
using namespace std;
int read(){
    int k = 0; char c = getchar();
    while(c < '0' || c > '9')
      c=getchar();
    while(c >= '0' && c <= '9')
      k = k * 10 + c - 48, c = getchar();
    return k;
}
int king[MAXN], tian[MAXN], ans;
bool cmp(int x, int y){
    return x > y;
}
int main() {
    int n = read(), t, h, tot;
    t = n, tot = h = 1;
    for(int i = 1; i <= n; i++) tian[i] = read();
    for(int i = 1; i <= n; i++) king[i] = read();
    sort(tian+1, tian+n+1, cmp);
    sort(king+1, king+n+1, cmp);
    while(h <= t){
        if(tian[h] > king[tot]) //最快的马能赢
          ans += 200, ++h, ++tot;
        else if(tian[h] < king[tot]) //最快的马赢不了
          ans -=200, --t, ++tot;
        else if(tian[t] > king[n]) //最快的马打平，比较最慢的马
            --t, --n, ans+=200;
        else ans -= tian[t] == king[tot] ? 0 : 200, --t, ++tot;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：litble (赞：6)

这个有一点贪心的思想吧。

要么故意输要么特意去试着可不可赢，所以我们把齐王的马和田忌的马都按照从大到小排个序，用f[i][j]表示齐王出了i匹马，田忌出前j匹好马和i-j匹从后往前找的驽马来和齐王比得到的最大钱币数。

则有f[i][j]=max(f[i-1][j-1]+cmp(b[i],a[i]),f[i-1][j]+cmp(b[i],a[n-i+j+1]));分别表示田忌从前往后出好马和从后往前出驽马，cmp函数表示比赛结果。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int read(){
    int q=0;char ch=' ';
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return q;
}
int n,ans;
int f[2005][2005],a[2005],b[2005];//a:田忌，b:齐王
int jg(int bb,int aa){//比较函数
    if(bb>aa)return -200;
    if(aa>bb)return 200;
    return 0;
}
bool cmp(int x,int y){return x>y;}
int main()
{
    int i,j;
    n=read();
    for(i=1;i<=n;i++)a[i]=read();
    for(i=1;i<=n;i++)b[i]=read();
    sort(a+1,a+1+n,cmp);sort(b+1,b+1+n,cmp);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)f[i][j]=-999999999;
    for(i=1;i<=n;i++){
        f[i][i]=f[i-1][i-1]+jg(b[i],a[i]);//特别处理的两种情况：只出好马和只出驽马
        f[i][0]=f[i-1][0]+jg(b[i],a[n-i+1]);
        for(j=1;j<i;j++)
        f[i][j]=max(f[i-1][j-1]+jg(b[i],a[j]),f[i-1][j]+jg(b[i],a[n-i+j+1]));//方程见上
    }
    for(i=1;i<=n;i++)ans=max(ans,f[n][i]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：littleming (赞：5)

动规，f[i,j]表示田忌第i匹马到第j匹马最大的胜利次数，,cost(a[i],b[k])表示田忌第i匹马和齐王第k匹马比赛的结果，f[i,j]=max(f[i+1,j]+cost(a[i],b[k]), f[i,j-1]+cost(a[j],b[k]))

pas的同学可以看看这个 http://www.docin.com/p-635669899.html

c++代码如下





    
    
    

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[2005],b[2005],f[2005][2005];
bool cmp(const int a,const int b)
{
    return a>b;
}
int cost(int x,int y)
{
    if(x>y)    return 1;
    if(x<y)    return -1;
    return 0;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)    cin>>a[i];
    for(int i=1;i<=n;i++)    cin>>b[i];
    sort(a+1,a+n+1,cmp);
    sort(b+1,b+n+1,cmp);
    for(int i=1;i<=n;i++)    f[i][i]=cost(a[i],b[n]);
    for(int k=n-1;k>=1;k--)
        for(int i=1;i<=k;i++)
        {
            int j=i+n-k;
            f[i][j]=max(f[i+1][j]+cost(a[i],b[k]),f[i][j-1]+cost(a[j],b[k]));
        }
    cout<<f[1][n]*200<<endl;
    return 0;
}

```

---

## 作者：顾z (赞：5)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述--->[p1650 田忌赛马](https://www.luogu.org/problemnew/show/P1650)

### 先%dalao  sto  [GMPotlc ](https://www.luogu.org/space/show?uid=87956)  orz

~~他教给的我,征求意见后终于来水题解~~.

## 分析

我们需要知道的是如何决策,才能让田忌胜利次数最多.

~~n<=2000?~~

我们可以自认为是田忌来**模拟这个过程**~~(穿越?~~)

值得考虑的是,我们每次调换每匹马的位置会白白增加复杂度。

因此我们找规律(说不上是真正意义上的找规律 qwq.)

**这里只给出一个例子,不太理解的话还请大家手推一下** qwq.

排序之后,我们得到的序列为这样.(这里按数组下标来解释)

1即代表能力值最低,5代表能力值最高.

![](https://i.loli.net/2018/09/24/5ba8c7479cf24.png)

因为排序之后排名都一样.

这时我们考虑将后两匹马提前.

对应的就是这个样子啦 qwq

![](https://i.loli.net/2018/09/24/5ba8c7528106e.png)

我们不必去真正的模拟这个交换的过程.

### 为啥?

上图中我们的

	4     5     1     2     3

实际上对应原序列的是

	1     2     3     4     5

如何找到规律？

我们发现从1到len(此时len为2

位置对应的是我们后面的n到n-len.

此时我们得到的**对应关系就是 n-len+i 与 i 对应.**

而我们从len+1到n

位置对应的是我们前面的1-len. 

此时我们又得到一组**对应关系就是 i-len与 i 对应.**

(这两组关系如果得到一组的话我们就可以得到另一组~~应该是~~

如果不太理解的话最好还是自己多手出几组尝试一下.

-------------------代码------------------

```cpp
#include<bits/stdc++.h>
#define R register
using namespace std;
inline void in(int &x)
{
    int f=1;x=0;char s=getchar();
    while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
    while(isdigit(s)){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int n,tianji[2508],qiwang[2508],ans;
int main()
{
    in(n);
    for(R int i=1;i<=n;i++)in(tianji[i]);
    for(R int i=1;i<=n;i++)in(qiwang[i]);
    sort(tianji+1,tianji+n+1);
    sort(qiwang+1,qiwang+n+1);
    for(R int len=1;len<=n;len++)
    {
        R int cnt=0;
        for(R int i=1;i<=len;i++)
        {
            if(tianji[n-len+i]>qiwang[i])
            cnt++;
            if(tianji[n-len+i]<qiwang[i])
            cnt--;
        }
        for(R int i=len+1;i<=n;i++)
        {
            if(tianji[i-len]>qiwang[i])
            cnt++;
            if(tianji[i-len]<qiwang[i])
            cnt--;	
        }
        ans=max(ans,cnt);
    }
    printf("%d",ans*200);
}
```

有不理解的地方来~~gay~~私信我就好了  qwq

再度sto  [GMPotlc ](https://www.luogu.org/space/show?uid=87956)  orz

---

## 作者：Azuree (赞：4)

[查看原题请戳这里](https://www.luogu.org/problemnew/show/P1650)  
非常经典的一道贪心。  
我们先对田忌的马和齐王的马进行排序，由于哪两匹马进行比赛完全由田忌决定，所以这一步不会导致错误。  
然后我们来考虑以下几种情况：  
1. 当田忌最慢的马比齐王最慢的马快，赢一场。因为始终要赢齐王最慢的马，不如用最没用的马来赢它。
2. 当田忌最慢的马比齐王最慢的马慢，和齐王最快的马比，输一场。因为田忌最慢的马始终要输的，不如用它来消耗齐王最有用的马。
3. 当田忌最慢的和齐王最慢的马慢相等时，分4，5，6讨论。
4. 当田忌最快的马比齐王最快的马快时，赢一场先。因为最快的马的用途就是来赢别人快的马，别人慢的马什么马都能赢。
5. 当田忌最快的马比齐王最快的马慢时，拿最慢的马和齐王最快的马比，输一场，因为反正要输一场，不如拿最没用的马输。
6. 当田忌最快的马和齐王最快的马相等时，这就要展开讨论了，贪心方法是，拿最慢的马来和齐王最快的马比。

这就是我们的贪心策略了。  
证明：

对于第6种贪心策略的证明如下：采用调整的思想。  
设	齐王最快的马为a1,最慢的马为an；  
	田忌最快的马为b1,最慢的马为bn。  
此处不考虑全部相等(a1=a2=a3=…=an,b1=b2=b3=…=bn)  
因为这种情况显然成立  
所以当a1=b1,an=bn时，	ai为齐王比赛中的某一匹马。  
	1.当an=ai时，  
	用bn与ai比赛，因为an=bn，所以ai=an=bn，所以这场比赛结果是平局。再用a1与b1比赛，结果平局，总得分为0分。  
	如果用b1去与ai比赛，结果为胜利。再用bn去与a1比较，结果为失败，总得分为0分，结果不变。  
	2.当an<ai时，  
	用bn与ai比赛，因为an=bn，所以ai>an=bn，所以这场比赛结果是失败。再用a1与b1比赛，结果平局，总得分为-200分。  
	如果用b1与ai比赛，结果为平局或胜利。再用bn去与a1比较，结果为失败，总得分为0分或-200分，结果比原方法更优。  
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

int n,t[2005],q[2005],ans;

int mysort(int a,int b){return a > b;}

int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&t[i]);
    for(int i = 1; i <= n; i++) scanf("%d",&q[i]);
    sort(t + 1, t + n + 1, mysort);
    sort(q + 1, q + n + 1, mysort);
    int p1 = 1, p2 = 1,p3 = n,p4 = n;
    while(p1 <= n && p2 <= n && p1 <= p3 && p2 <= p4)
    {
        if(t[p1] > q[p2])
        {
            ans += 200;
            p1 ++;
            p2 ++;
        }
        if(t[p1] < q[p2])
        {
            ans -= 200;
            p2 ++;
            p3 --;
        }
        if(t[p1] == q[p2])
        {
			if(t[p3] > q[p4]) 
			{
				ans += 200;
				p3 --; p4 --;
			}
			else 
			{
				if(t[p3] < q[p2]) ans -= 200;
				p3 --;
				p2 ++;
			}
            
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：水無月嘉祥 (赞：4)

## 弱弱地说一句：其实这道题，可以直接**暴力**解……

### 我的思路是：

1. 先对他们各自的马进行排序，以便接下来的操作
1. 将田忌的下等马不断前移，寻找最优解
1. 前移了一个循环后，输出最优解

#### 下面上代码：



```c
#include<bits/stdc++.h>//祭出万能头文件
using namespace std;

int win=0,lose=0;
int n,best=0,t[2000+5],q[2000+5];//t就是田忌，q就是齐王

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&t[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&q[i]);
	sort(t+1,t+n+1);
	sort(q+1,q+n+1);//排序
	for(int i=0;i<=n;i++)//将下等马不断前移
	{
		win=0;
		lose=0;//每次都要清零
		for(int j=1;j<=n;j++)
		{
			if(t[(i+j)%n+1]>q[j])
			{
				win++;//马力更大，胜场++
			}
			else if(t[(i+j)%n+1]<q[j])
			{
				lose++;//马力不足，输场++
			}
		}
	if(best<win*200-lose*200)
		best=win*200-lose*200;//寻找最优解
	}
	printf("%d",best);
	return 0;
}
```


---

## 作者：DAMDAM (赞：3)

你说得对但是我是 2B 不会贪心。

考虑跑网络流。这是一个二分图最大权匹配可以费用流搞搞。

|起点|终点|边权费用|流量限制|
|-|-|-|-|
|源点 $s$|田忌的马 $i$|$0$|$1$|
|田忌的马 $i$|齐王的马中权值小于 $i$ 的权值的马|$-200$|$1$|
|田忌的马 $i$|齐王的马中权值等于 $i$ 的权值的马|$0$|$1$|
|田忌的马 $i$|齐王的马中权值大于 $i$ 的权值的马|$200$|$1$|
|齐王的马 $j$|汇点 $t$|$0$|$1$|

跑最大费用最大流即可（边权已经在上方取反）。

但是这个建图是 $n^2$ 的。。。

看到权值被分为 $3$ 部分，我们可以考虑排序双指针后线段树优化建图。具体地说，我们将原来的齐王马 $j$ 变成树上的一个叶子，建一棵入树，树上的边父亲到儿子边权 $0$ 限制 $\infin$。

那么排序后用双指针对于每个田忌马分成 $3$ 个区间后可以直接连向齐王马。这样做的话效率就对了。

```cpp
#include <algorithm>
#include <bitset>
#include <cstdio>
#include <cstring>
#include <ext/pb_ds/priority_queue.hpp>
#include <queue>
using namespace std;
typedef long long ll;
const int maxn = 2e3 + 5;
const int maxVertex = 8e3 + 5, maxEdge = 5e5 + 5;
const ll inf = 0x3f3f3f3f3f3f3f3f;
struct Vertex {
    int num;
    ll dis;
    bool operator<(const Vertex &b) const & {
        return dis > b.dis;
    }
};

struct Edge {
    int to;
    ll dis, flow;
    int next;
} edge[maxEdge << 1];

int head[maxVertex];
void insert(const int &u, const int &v, const ll &w, const ll &c) {
    static int len = 1;
    edge[++len] = {v, w, c, head[u]}, head[u] = len;
}

void emplace(const int &u, const int &v, const ll &w, const ll &c) {
    insert(u, v, w, c), insert(v, u, -w, 0);
}

int s, t, cur[maxVertex];
ll dis[maxVertex], w[maxVertex], reply;
queue<int> q;
bitset<maxVertex> vis;
void Bellman_Ford() {
    q.push(s), memset(w, 63, sizeof w), w[s] = 0, vis[s] = 1;
    for (int u, v; !q.empty(); ) {
        u = q.front(), q.pop(), vis[u] = 0;
        for (int i = head[u]; i; i = edge[i].next) {
            if (edge[i].flow && w[v = edge[i].to] > w[u] + edge[i].dis)
                w[v] = w[u] + edge[i].dis, vis[v] || (q.push(v), vis[v] = 1);
        }
    }
} 

priority_queue<Vertex> h;
bool Dijkstra() {
    memset(dis, 63, sizeof dis), h.push({s, dis[s] = 0});
    ll d;
    for (int u, v; !h.empty(); ) {
        u = h.top().num, h.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = edge[i].next) {
            v = edge[i].to;
            if (edge[i].flow && dis[v] > (d = dis[u] + w[u] - w[v] + edge[i].dis))
                h.push({v, dis[v] = d});
        }
    }
    return dis[t] != inf;
}

ll Dfs(const int &u, const ll &flow) {
    if (u == t || !flow) return flow;
    ll ans = 0, d;
    vis[u] = 1;
    for (int &i = cur[u], v; i; i = edge[i].next) {
        v = edge[i].to;
        if (!vis[v] && dis[v] == dis[u] + w[u] - w[v] + edge[i].dis && (d = Dfs(v, min(edge[i].flow, flow - ans)))) {
            edge[i].flow -= d, edge[i ^ 1].flow += d, reply += d * edge[i].dis;
            if ((ans += d) == flow) break;
        }
    }
    return vis[u] = 0, ans;
}

void init() { for (int i = 0; i < maxVertex; ++i) w[i] += dis[i]; }

ll Dinic() {
    ll flow = 0;
    for (Bellman_Ford(); Dijkstra(); memcpy(cur, head, sizeof cur), vis.reset(), flow += Dfs(s, inf), init()) ;
    return flow;
}

int a[maxn], b[maxn], n, len, rt, ls[maxVertex], rs[maxVertex];
void Build(const int &l = 1, const int &r = n, int &p = rt) {
    p || (p = ++len);
    if (l == r) return emplace(p, t, 0, 1);
    int mid = l + ((r - l) >> 1);
    Build(l, mid, ls[p]), Build(mid + 1, r, rs[p]);
    emplace(p, ls[p], 0, inf), emplace(p, rs[p], 0, inf);
}

void Point2Range(const int &l, const int &r, const int &u, const ll &w, const ll &c, const int &s = 1, const int &t = n, const int &p = rt) {
    if (l <= s && t <= r) return emplace(u, p, w, c);
    int mid = s + ((t - s) >> 1);
    if (l <= mid) Point2Range(l, r, u, w, c, s, mid, ls[p]);
    if (r > mid) Point2Range(l, r, u, w, c, mid + 1, t, rs[p]);
}

int main() {
    scanf("%d", &n), s = ++len, t = ++len;
    for (int i = 1; i <= n; ++i) scanf("%d", a + i), emplace(s, ++len, 0, 1);
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i) scanf("%d", b + i);
    sort(b + 1, b + n + 1), Build();
    for (int i = 1, j = 1, k = 1; i <= n; ++i) {
        for (; j <= n && b[j] < a[i]; ++j) ;
        for (; k <= n && b[k] <= a[i]; ++k) ;
        if (j > 1) Point2Range(1, j - 1, i + 2, -200, 1);
        if (j <= n && j < k) Point2Range(j, k - 1, i + 2, 0, 1);
        if (k <= n) Point2Range(k, n, i + 2, 200, 1);
    }
    Dinic(), printf("%lld", -reply);
    return 0;
}
```

---

## 作者：XZYQvQ (赞：2)

很好奇这题为什么标签是动归

就这么把我骗了进来

明明贪心很简单

搞两个链表存两个人马的速度

输入完了以后排序

然后对链表1进行$n$次滚动(即把链表1的首部元素接到链表1末尾），每次移动以后判断当前答案。

最后取答案最大值。

ans的初始值一开始我设置为INT\_MIN，这样在luogu上能ac，但在codevs上会wa两个点。

看了下数据，可能是标程的问题吧（不清楚），把ans的初始值设置为0就能过了（可能标程里ans初始值就是0）。


代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans;
list<int> l1,l2;
void update()
{
    int k=0;
    for(list<int>::iterator i1=l1.begin(),i2=l2.begin();i1!=l1.end();i1++,i2++)
        if(*i1>*i2)k++;else if(*i1<*i2)k--;
    ans=max(ans,k);
}
int main()
{
    scanf("%d",&n);
    for(int i=1,a;i<=n;i++)scanf("%d",&a),l1.push_back(a);
    for(int i=1,a;i<=n;i++)scanf("%d",&a),l2.push_back(a);
    l1.sort(),l2.sort();
    for(int i=1;i<=n;i++)l1.push_back(*l1.begin()),l1.pop_front(),update();
    printf("%d\n",ans*200);
    return 0;
}
```

---

## 作者：cyl2019 (赞：2)

### 题解 P1650 【田忌赛马】
注释都在程序中，希望对你有帮助
```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;

short int k[2005],t[2005],tl,kl,tr,kr,i,n;//定义数组，意义如题所示。(这里的"short"是为了节省空间) 
int ans;//ans是所计算的答案

void input()//输入数据 
{
    scanf("%d",&n);//输入马的个数 
    for(i=1;i<=n;i++) scanf("%d",&t[i]);//先输入田忌的马 
    for(i=1;i<=n;i++) scanf("%d",&k[i]);//再输入齐王的马（顺序不要搞反） 
}

int main()//主函数 
{
	
	//输入 
	input(); 
	
	//排序，贪心需要顺序（升序） 
    sort(t+1,t+1+n);//给田忌的马排序 
    sort(k+1,k+1+n);//给齐王的马排序 
     
    //这里的tl等变量都是相当于一个指向数组位置的端点 
    tl=kl=1;//初始化，左端点为1 
    tr=kr=n;//初始化，右端点为n 
    
    //这里是循环，求解 
    for(i=1;i<=n;i++)//循环1到n，不难理解 
        if(t[tr]>k[kr])//当田忌目前最好的马比对手好的马的快时（当然是赢钱的） 
		{
		ans+=200;//累加MONEY（注意是200块钱） 
		tr--; kr--;//右端点左移 
		}
        else if(t[tl]>k[kl])//当田忌目前最差的马比对手最差的马的快时（当然也是赢钱的） 
		{
			ans+=200;//累加MONEY（注意是200块钱） 
			tl++; kl++;//左端点右移 
		}
		//如果都比不过，输钱如何损失最小？ 
        else if(t[tl]<k[kr])//当然是拿最差的马去坑对手最好的马！ 
		{
			ans-=200;//输钱不要忘记减 （注意是200块钱） 
			tl++; kr--;//田忌左端点右移，国王右端点左移 
		}
		//一样快不赢不输，就不用算了 
		
	//大功告成，输出答案 
    printf("%d",ans);//顺便提一句，printf后的参数不用加"&" 
    
    return 0; //返回0
	
	//AC！ 
}
```



---

## 作者：失之_连心 (赞：2)

与古代田忌的应对方法差不多，现在我们任然可以用贪心的思路解答。

1.田忌的马甚至比齐王的马快，那么，直接将两人最快的马进行比赛，达到最优

2.田忌最快的马比齐王最快的马要慢，则与古代田忌的方案相同，用田忌最慢的马消耗掉齐王最快的马

3.齐王最快的马与田忌最快的马速度相当，又可以分成2种情况
程序：
```
#include <bits/stdc++.h>
using namespace std;
long n,money,x1,x2,y11,y2;
int a[10001],b[10001];
int main(){
	cin>>n;
	for(int i=0;i<n;i++)//田忌的马 
		cin>>a[i];
	for(int i=0;i<n;i++)//齐王的马 
		cin>>b[i];
	sort(a,a+n);//先给各自的马排序
	sort(b,b+n);
	x1=x2=0;//先给各个数值初始化 
	y11=y2=n-1;
	while(x1<=y11){
	    if(a[y11]>b[y2]){//如果田忌的最快的马比齐王最快的马还要快，自然相比 
	        money+=200;//增加钱 
	        y11--;//两边的的马的数量都减少一个 
	        y2--;
		}
		else if(a[y11]<b[y2]){//如果田忌的最快的马比齐王最快的马要慢，则用田忌最慢的马来消耗掉齐王最快的马 
	        money-=200;//钱要减少 
	        x1++;
	        y2--;
		}
		else{//如果田忌最快的马与齐王最快的马速度相当
			if(a[x1]>b[x2]){//如果田忌最慢的马比齐王最慢的马要快，则田忌会用他最慢的马与齐王最慢的马比赛 
			    money+=200;//钱要增加 
			    x1++;
			    x2++;
			}
			else{//否则，用田忌最慢的马消耗掉齐王最快的马 
			    if(a[x1]<b[y2])
			    	money-=200;
			    x1++;
			    y2--;
			}
		}
	}
	cout<<money;
	return 0;
}
```

思路来自<<算法基础与在线实际>>

---

## 作者：在下互质数 (赞：1)

### 这道题用到了动态数组来进行运算
#### $∴$先来普及一下动态数组
#### 定义
```latex
动态数组是指在声明时没有确定数组大小的数组，即忽略圆括号中的下标；当要用它时，可随时用ReDim语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。
```
#### 优点
```latex
有助于有效管理内存
```
#### 难点
```latex
静态数组是在堆栈上（不需要自行释放空间）创建，动态数组是在堆上创建（需要自行释放空间）
```
#### 例子
```latex
例如：
	int a[5];
	是正确的;
	int k=3;
	int a[k];
	是错误的，因为编译时，不知道k为多少
```
#### 使用
##### 头文件
```cpp
#include<vector>
```
##### 定义方法
- #### 法一
```cpp
vector<int>a(10);
//定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定
```
- #### 法二
```cpp
vector<int>a(10,1);
//定义具有10个整型元素的向量，且给出的每个元素初值为1
```
- #### 法三
```cpp
vector<int>a(b);
//用向量b给向量a赋值，a的值完全等价于b的值
```
- #### 法四
```cpp
vector<int>a(b.begin(),b.begin+3);
//将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型
```
- #### 法五
```cpp
int b[7]={1,2,3,4,5,6,7};
vector<int> a(b,b+7）;
 //从数组中获得初值
```
#### 因为后面要讲田忌赛马，里面有很多的vector自带函数，所以先讲一下自带函数，资料来源于网上
```cpp
#include<vector>
vector<int> a,b;
//b为向量，将b的0-2个元素赋值给向量a
a.assing(b.begin(),b.begin()+3);
//a含有4个值为2的元素
a.assing(4,2);
//返回a的最后一个元素
a.back();
//返回a的第一个元素
a.front();
//返回a的第i元素,当且仅当a存在
a[i];
//清空a中的元素
a.clear();
//判断a是否为空，空则返回true，非空则返回false
a.empty();
//删除a向量的最后一个元素
a.pop_back();
//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束
a.erase(a.begin()+1,a.begin()+3);
//在a的最后一个向量后插入一个元素，其值为5
a.push_back(5);
//在a的第一个元素（从第0个算起）位置插入数值5,
a.insert(a.begin()+1,5);
//在a的第一个元素（从第0个算起）位置插入3个数，其值都为5
a.insert(a.begin()+1,3,5);
//b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）
a.insert(a.begin()+1,b+3,b+6);
//返回a中元素的个数
a.size();
//返回a在内存中总共可以容纳的元素个数
a.capacity();
//将a的现有元素个数调整至10个，多则删，少则补，其值随机
a.resize(10);
//将a的现有元素个数调整至10个，多则删，少则补，其值为2
a.resize(10,2);
//将a的容量扩充至100，
a.reserve(100);
//b为向量，将a中的元素和b中的元素整体交换
a.swap(b);
//b为向量，向量的比较操作还有 != >= > <= <
a==b;
```
#### 而田忌赛马里要用到的有下面几个重要函数，要引用头文件$algorithm$
```cpp
 #include<algorithm>
 //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列
 sort(a.begin(),a.end());
 //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1
 reverse(a.begin(),a.end());
  //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素
 copy(a.begin(),a.end(),b.begin()+1);
 //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置
  find(a.begin(),a.end(),10);
```
#### 下面便附上田忌赛马的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> a,b;
long long n,x,ans,la,lb,ra,rb;
int main ()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		a.push_back(x);
	}
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		b.push_back(x);
	}
	sort(a.begin(),a.end());
	sort(b.begin(),b.end());
	la=lb=0;
	ra=rb=n-1;
	for(int i=0;i<n;i++)
	{
		if(a[ra]>b[rb])
		{
			ans+=200;
			ra--;
			rb--;
		}
		else if(a[ra]<b[rb])
		{
			ans-=200;
			la++;
			rb--;
		}
		else if(a[la]>b[lb])
		{
			ans+=200;
			la++;
			lb++;
		}
		else
		{
			if(a[la]<b[rb])
			{
				ans-=200;
			}
			la++;
			rb--;
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Gliese (赞：1)

[P1650 田忌赛马](https://www.luogu.org/problemnew/show/p1650)


## 贪心

贪心的目的很简单，就是尽可能地多赢钱，一下是贪心思路：

1.若田忌最快的马快于齐王最快的马，则两者比赛

2.若田忌最快的马慢于齐王最快的马，则拿田忌最慢的马怼掉齐王最快的

3.若田忌最快的马和齐王最快的马难分伯仲，则：

	   (1)若田忌最慢的马快于齐王最慢的马，则两者比赛

	   (2)若田忌最慢的马慢于齐王最慢的马，则拿田忌最慢的
          马怼掉齐王最快的
          
###### 注：“最快的马”“最慢的马”是指在未比赛的马中最快/慢的马

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int tian[2100],qi[2100];
int main()
{
    cin>>n;
    for(int i=1; i<=n; ++i)
        cin>>tian[i];
    for(int i=1; i<=n; ++i)
        cin>>qi[i];
    sort(tian+1,tian+1+n);
    sort(qi+1,qi+1+n);
    int ft,st,fq,sq,cnt=0;
    ft=fq=n;
    st=sq=1;
    while(++cnt<=n)
    {
        if(tian[ft]>qi[fq])
        {
            ans+=200;
            ft--;
            fq--;
        }
        else 
        if(tian[ft]<qi[fq])
        {
            ans-=200;
            st++;
            fq--;
        }
        else
        {
            if(tian[st]>qi[sq])
            {
                ans+=200;
                st++;
                sq++;
            }
            else
            {
                if(tian[st]<qi[fq])//“田忌最慢的马快于齐王最快的马”虽然听起来无厘头，但不加就只有20分......
                    ans-=200;
                st++;
                fq--;
            }
        }
    }
    cout<<ans;
    return 0;
}
```


## 动态规划

我们可以定义一个二维数组f[i][j]，代表田忌在第i场比赛中用了j匹慢马所获得的最大利益，这样状态转移方程也就显而易见了f[i][j]=max(f[i-1][j]+comp(i-j,i),f[i-1][j-1]+comp(n-j+1,i))[comp(i,j)指田忌第i匹马于齐王第j匹马比赛时赢得的钱数]

怎么理解转移方程呢？f[i-1][j]指田忌在第i-1场比赛中用了j匹慢马，为了使他在第i场比赛中仍用j匹慢马，田忌只能用快马于齐王比，因为前i-1场比赛用了i-1-j匹快马，所以第i场田忌只能用第i-j匹快马和齐王第i匹马怼，所以该方案的盈利为f[i-1][j]+comp(i-j,i)。另一种方案也可以推出

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[2100][2100],tian[2100],qi[2100];
bool vis[2100];
int n;
bool rule(int xx,int yy)
{
	return xx>yy;
}
int comp(int tn,int qn)
{
	if(tian[tn]>qi[qn])
		return 200;
	if(tian[tn]<qi[qn])
		return -200;
	return 0;
}
int main()
{
	cin>>n;
	for(int i=1; i<=n; ++i)
		cin>>tian[i];
	for(int i=1; i<=n; ++i)
		cin>>qi[i];
	sort(tian+1,tian+1+n,rule);
	sort(qi+1,qi+1+n,rule);
	for(int i=1; i<=n; ++i)
	{
		f[i][0]=f[i-1][0]+comp(i,i);
		f[i][i]=f[i-1][i-1]+comp(n-i+1,i); 
	}
	for(int i=2; i<=n; ++i)
		for(int j=1; j<i; ++j)
			f[i][j]=max(f[i-1][j]+comp(i-j,i),f[i-1][j-1]+comp(n-j+1,i));
	int ans=-0x7fffffff;
	for(int i=1; i<=n; ++i)
		ans=max(ans,f[n][i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：叶枫 (赞：1)

[题目](https://www.luogu.org/problemnew/show/P1650)

这题虽说是DP，但也可以用贪心
```
贪心策略：
1.如果田忌的最快马快于齐王的最快马，则两者比。

（因为若是田忌的别的马很可能就赢不了了，所以两者比）

2.如果田忌的最快马慢于齐王的最快马，则用田忌的最慢马和齐王的最快马比。

（由于所有的马都赢不了齐王的最快马，所以用损失最小的，拿最慢的和他比）

3.若相等，则比较田忌的最慢马和齐王的最慢马

4.若田忌最慢马快于齐王最慢马，两者比。

（田忌的最慢马既然能赢一个就赢呗，而且齐王的最慢马肯定也得有个和他比，所以选最小的比他快得。）

5.其他，则拿田忌的最慢马和齐王的最快马比。

（反正所有的马都比田忌的最慢马快了，所以这匹马必输，选贡献最大的，干掉齐王的最快马）
```
第一次写了60分~~￣□￣｜｜~~

以下是正解（附注释）
```cpp
#include<bits/stdc++.h>
using namespace std;  
/*char buf[1<<15],*fs,*ft;
inline char getc(){return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;}*/;
inline int read()//快读 
{ 
    int x=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();} 
    while(isdigit(c)){x=x*10+c-48;c=getchar();}
    return x*f;
}

inline void put(int x)//快写 
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) put(x/10);
     putchar(x%10+'0');
}

int tj[2010],king[2010];//田忌和齐王的马
bool t[2010],k[2010];

int n,ans;

int main()
{
    n=read();
    for(int i=1;i<=n;i++)
        tj[i]=read();
    for(int i=1;i<=n;i++)
        king[i]=read();
    sort(tj+1,tj+n+1);        
    sort(king+1,king+1+n);//贪心嘛，要排序
    int kn=n,tn=n,ti=1,ki=1; //类似指针
    while(n--)
	{
        if(tj[tn]>king[kn])
		{
            ans++;//赢了
            kn--;
            tn--;
        }
        else if(tj[ti]>king[ki])
		{
            ans++;//又赢了
            ki++;
            ti++;
        }
        else 
		if(tj[ti]<king[kn])
		{
            ans--;//输了
            ti++;
            kn--;
        }
    }
    put(ans*200);//赢一场200嘛，答案*200
    return 0;
}
```
**劝你不要粘代码**

---

## 作者：弑君 (赞：1)

其实田径赛马的思想是十分的简单的，简单概括就是十个字“打得过就打，打不过就送”！！！接下来贴代码
```cpp
#include<bits/stdc++.h>
#define N 2100//宏定义
#define F(a,b,c) for(long long a=b;a<=c;a++)//同上
using namespace std;
typedef long long ll;
ll x,sum,a[N],b[N];
bool cmp(ll x,ll y){return x>y;}
int main()
{
	scanf("%lld",&x);
	ll l=1,r=1,l1=x,r1=x;//l,l1表示田忌的马最大和最小，r,r1表示齐王的马最大和最小
	F(i,1,x)scanf("%lld",&a[i]);
	F(i,1,x)scanf("%lld",&b[i]);
	sort(a+1,a+x+1,cmp);
	sort(b+1,b+x+1,cmp);
	while(l<=l1)
	{
		if(a[l]>b[r])sum+=200,l++,r++;//打得过就打
		else if(a[l]<b[r])sum-=200,l1--,r++;//打不过就送
		else
		{
			if(a[l1]>b[r1])sum+=200,l1--,r1--;//打得过就打
			else//打不过就送
			{
				if(a[l1]<b[r])sum-=200;
				l1--,r++;
			}
		}
	}
	printf("%lld",sum);
	return 0;
}
```

---

## 作者：humiao (赞：0)

\_二分图是什么，好吃么......\_

**贪心**ok





```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstring>
#include<string>
#include<vector>
#include<cmath>
using namespace std;
const int inf=1e9;
int n,t[2010],q[2010];
int read()
{
    int ans=0,x=1;char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-') x=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){ans=ans*10+ss-'0';ss=getchar();}
    ans*=x;return ans;
}
int pk(int x[],int y[])
{
    int h1=1,h2=1,t1=n,t2=n,ans=0;
    for(int i=1;i<=n;++i)//比n场 
    {
        if(x[t1]>y[t2]){--t1;--t2;ans+=200;continue;}//最快的马比对手最慢的马快
        if(x[h1]>y[h2]){++h1;++h2;ans+=200;continue;}//最慢的马比对手最快的马快
        if(x[t1]==y[h2]){--t1;++h2;continue;}//最快的马比对手最慢的马快 
        ++h1;--t2;ans-=200;//均不符合，用最慢的马消耗对手最快的马 
    }
     return ans; 
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) t[i]=read();
    for(int i=1;i<=n;++i) q[i]=read();
    sort(t+1,t+n+1);sort(q+1,q+n+1);
    printf("%d\n",pk(t,q));
    return 0;
}
```

---


# 塔

## 题目描述

小明很喜欢摆积木，现在他正在玩的积木是由 $N$ 个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？

## 说明/提示

对于 $100\%$ 的数据，$N \le 50$ ，每块木块的高度 $h$ 满足 $1 \le h \le 500000$，所有木块的高度总和 $\le 500000$。

## 样例 #1

### 输入

```
3
2 3 5```

### 输出

```
5```

# 题解

## 作者：FLYing (赞：68)

和已有的解法是同一种思路，但是可以简化代码的打法。

换一种理解方式

令Fij表示前i个积木，其中**第一堆积木减去第二堆积木**的差值为j时**左边积木的高度**。

这样一来就无需考虑两边高度的大小问题了。

于是对于Fij的转移，有三种情况：

①物品i不选，则f[i][j] = max(f[i][j], f[i-1][j]);

②物品i放左边，则f[i][j] = max(f[i][j], f[i-1][j-a[i]]+a[i]);

③物品i放右边，则f[i][j] = max(f[i][j], f[i-1][j+a[i]]);

三种情况取一个最大值

找到最大的 j等于0 时的fij即可。

初始值为F[0][0]等于0，其它情况为最小值代表该高度无法表示出来，不参与转移。

这样一来就会出现一个问题，j这一维会出现负数。因为j表示的是第一堆减去第二堆的差值，这里只需根据题目的数据范围，将j加上个500000即可，即500000代表0上下界是0到1000000。

最后加个动数组优化空间

```cpp
#include<cstdio>
#include<cstring>
#define maxn 1000039
using namespace std;
int f[2][maxn], N, a[51], ans;
int max(int a, int b){return a>b?a:b;}
int max(int a, int b, int c){return max(a, max(b, c));}
int main(){
	freopen("1.in", "r", stdin);
	memset(f, -0x3f3f3f3f, sizeof(f));
	scanf("%d", &N);
	f[0][500000] = 0;
	for(int i = 1; i < N+1; i++)scanf("%d", &a[i]);
	for(int i = 1; i < N+1; i++)
		for(int j = 0; j < 1000000+1; j++){
			f[i%2][j] = max(f[i%2][j], f[(i%2)^1][j]);
			if(j-a[i]>=0)f[i%2][j] = max(f[i%2][j], f[(i%2)^1][j-a[i]]+a[i]);
			if(j+a[i]<=1000000)f[i%2][j] = max(f[i%2][j], f[(i%2)^1][j+a[i]]);
			if(j==500000)ans = max(ans, f[i%2][j]);
		}
	printf("%d", ans==0?-1:ans);
	return 0;
}


```


---

## 作者：我要上天 (赞：46)

由于看到本题别的题解要么难以理解，要么就是少情况，我做这题时，单看一个题解根本不对，只有合在一起看情况才全面，那些题解虽然AC了但是考虑不全，会迷惑萌新，只能说这题测试数据真的真的太水了。。。。。。。。。

所以这里把别的题解整合了一下，写一个比较全面不漏情况的题解。

一道DP的题目，状态表示为     dp[ i ] [ j ]表示遍历到第i块水晶时，使两塔高度差为j时，较高的塔的高度；

dp数组全部初始化为-9999.

为什么不是0呢，因为有的高度差是达不到的，在下面程序里，就可以看到为什么初始化为0不行。

状态转移方程

dp[ i ] [ j ]=max(dp[ i-1 ] [ j ]) //不要第i个水晶就能达成j的差；

dp[ i ] [ j ]=max(dp[ i ] [ j ] , dp[ i-1 ] [ j+a[ i ] ] )//把第i个水晶放在矮塔上，矮塔依然是矮塔；

if(j>=a[ i ])    dp[ i ] [ j ]=max(dp[ i ] [ j ],dp[ i-1 ] [ j-a[ i ] ]+a[ i ] );//把第i个水晶放在高塔上达成j的差；

if(j<=a[ i ])    dp[ i ] [ j ]=max(dp[ i ] [ j ],dp[ i-1 ] [ a[ i ]-j ]+j);//把第i个水晶放在矮塔上，但矮塔成为高塔；

这里无非就是4钟情况

1   不要第i块水晶

2   放在矮塔上，矮塔依然矮

3   放在高塔上，高塔当然高

4   放在矮塔上，矮塔成为高塔

最后直接看看dp[ n ] [ 0 ]的值就行了

下面是程序，没有可以便准化，通俗易懂

```cpp
#include"bits/stdc++.h"
using namespace std;
int a[9999];
int dp[3000][3000];
int f[3000][3000];
int top;
int n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i],top+=a[i];
    memset(dp,-0x3f3f3f3f,sizeof(dp));//附一个大负数。如果达成不了，即使加上一个水晶也不会比0大，但要是初值附0则不行。
    dp[0][0]=0;//这里要给一个0，不然就爆了。
    for(int i=1;i<=n;i++)
    {
        for(int j=top;j>=0;j--)
        {
            dp[i][j]=max(dp[i][j],dp[i-1][j]);//不要第i个水晶就能达成j的差；
            dp[i][j]=max(dp[i][j],dp[i-1][j+a[i]]);//把第i个水晶放在矮塔上，矮塔依然是矮塔； 
            if(j>=a[i])
            {
                dp[i][j]=max(dp[i][j],dp[i-1][j-a[i]]+a[i]);
                //把第i个水晶放在高塔上达成j的差； 
            }
            if(j<=a[i])
            {
                dp[i][j]=max(dp[i][j],dp[i-1][a[i]-j]+j);
                //把第i个水晶放在矮塔上，但矮塔成为高塔； 
            }
        }
    }
    if(dp[n][0]==0)cout<<"Impossible";
    else cout<<dp[n][0];
}
```

---

## 作者：K2sen (赞：16)

### 讲前瞎扯
~~我dfs过了~~

发现题解里边好像都是$dp$的

因为我太菜了，看不懂$dp$方程，然后就自己$dfs$水过了,,

### 正题
首先我们的dfs应该是这个样子的

用$now$来表示用到了那个方块, $h1$ $h2$ 分别是两座塔的高度

然后我们就可以根据题意进行dfs 
```cpp 
void dfs(int now, int h1, int h2) {
	if (now == n + 1) {//如果dfs完了，那就退出
		if (h1 == h2) ans = max(ans, h1);
		return;
	}
	dfs(now + 1, h1 + a[now], h2);//可以选择把当前的方块
	dfs(now + 1, h1, h2 + a[now]);//放到第1或者2堆
	dfs(now + 1, h1, h2);//当然也可以不放
}
```

### 考虑如何剪枝
$sum$是前缀和，好计算

#### 可行性剪枝
我们可以感性的理解一下，如果$h_1$加上剩下的方块还比$h_2$矮,

那么就没有必要进行了,$h_2$同理
```cpp
if (h1 + sum[n] - sum[now - 1] < h2) return;
if (h2 + sum[n] - sum[now - 1] < h1) return;
```

#### 最优性剪枝
我们用一个$ans$来记录的最优解，

发现如果$h_1$加上剩下所有的方块，都比$ans$小，那么就没有必要进行了，$h_2$同理.

而且，如果两座塔的高度加起来再加上所有剩下的方块比$ans$的两倍还要小的话,也没有必要进行了，所以直接返回就可以了,
```cpp
if (h1 + h2 + sum[n] - sum[now - 1] <= ans * 2) return;
if (h1 + sum[n] - sum[now - 1] <= ans) return;
if (h2 + sum[n] - sum[now - 1] <= ans) return;
```

#### code
```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 100010
#define M 60

using namespace std;
int n, a[M], ans;
int sum[M];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

bool cmp(int a, int b) {
	return a > b;
}

void dfs(int now, int h1, int h2) {
	if (now == n + 1) {
		if (h1 == h2) ans = max(ans, h1);
		return;
	}
	if (h1 + h2 + sum[n] - sum[now - 1] <= ans * 2) return;
	if (h1 + sum[n] - sum[now - 1] <= ans) return;
	if (h2 + sum[n] - sum[now - 1] <= ans) return;
	if (h1 + sum[n] - sum[now - 1] < h2) return;
	if (h2 + sum[n] - sum[now - 1] < h1) return;
	dfs(now + 1, h1 + a[now], h2);
	dfs(now + 1, h1, h2 + a[now]);
	dfs(now + 1, h1, h2);
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];
	dfs(1, 0, 0);
	if (ans == 0) puts("-1");
	else cout << ans;
}
```
然后我们发现过不了，获得了80分的好成绩，两个点T得死死的...

是时候祭出终极大杀器——记忆化搜索了

#### 记忆化搜索
我们需要把dfs中的返回值改成int,因为需要记忆化

我们要用一个东西存一下每次的状态，但是我们发现$h_1,h_2 \leq 5e5$

所以开数组是不可能了，所以我们选择$map+pair$
```cpp
map<pair<int, pair<int, int> >, int>ma;
```
我们在每一次$dfs$完成之后记录一下当前这次dfs所分出去的三次dfs的最优解

$just \ like \ this$
```cpp
int s = 0;
s = max(s, dfs(now + 1, h1 + a[now], h2));
s = max(s, dfs(now + 1, h1, h2 + a[now]));
s = max(s, dfs(now + 1, h1, h2));
ma[make_pair(now, make_pair(h1, h1))] = s;
```
在下一次找到和当前状态相同的时候可以直接返回

$just \ like \ this$
```cpp
if (ma[make_pair(now, make_pair(h1, h1))])
	return ma[make_pair(now, make_pair(h1, h1))];
```
而且上边我们剪的枝可以直接返回$-1$，因为那些无所谓.

### code
```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 100010
#define M 60

using namespace std;
int n, a[M], ans;
int sum[M];
map<pair<int, pair<int, int> >, int>ma;

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

bool cmp(int a, int b) {
	return a > b;
}

int dfs(int now, int h1, int h2) {
	if (now == n + 1) {
		if (h1 == h2) {
			ans = max(ans, h1);
			return h1;
		} 
		return -1;
	}
	if (ma[make_pair(now, make_pair(h1, h1))])
		return ma[make_pair(now, make_pair(h1, h1))];
	if (h1 + h2 + sum[n] - sum[now - 1] <= ans * 2) return -1;
	if (h1 + sum[n] - sum[now - 1] <= ans) return -1;
	if (h2 + sum[n] - sum[now - 1] <= ans) return -1;
	if (h1 + sum[n] - sum[now - 1] < h2) return -1;
	if (h2 + sum[n] - sum[now - 1] < h1) return -1;
	int s = 0;
	s = max(s, dfs(now + 1, h1 + a[now], h2));
	s = max(s, dfs(now + 1, h1, h2 + a[now]));
	s = max(s, dfs(now + 1, h1, h2));
	ma[make_pair(now, make_pair(h1, h1))] = s;
	return s;
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];
	dfs(1, 0, 0);
	if (ans == 0) puts("-1");
	else cout << ans;
}
```
最后放一张惊险又刺激的AC图

![](https://cdn.luogu.com.cn/upload/image_hosting/077lf4cm.png)

---

## 作者：timetravler (赞：14)

用dp[i][j]表示前i块水晶搭建的双塔高度差值为j时较高的塔的高度


然后dp[i][j]存在四种情况，

这块水晶不放：dp[i][j] = dp[i - 1][j]

这块水晶放在矮的塔上面且依旧矮：dp[i][j] = dp[i - 1][j + a[i]]

这块水晶放在高的塔上：dp[i][j] = dp[i - 1][j - a[i]] + a[i]

这块水晶放在矮的塔上面且变成高塔：dp[i][j] = dp[i - 1][a[i] - j] + j

求max(1,2,3,4);

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int h[51],dp[51][500001];
int main()
{
    int n;
    cin>>n;
    int i,j,sum=0;
    for(i=1;i<=n;i++)
    {
      cin>>h[i];
      sum+=h[i];
    }
    memset(dp,-2,sizeof(dp));
    dp[0][0]=0;
    for(i=1;i<=n;i++)
      for(j=0;j<=sum;j++)
      {
        dp[i][j]=max(dp[i-1][j],dp[i-1][j+h[i]]);
        if(j>=h[i]) dp[i][j]=max(dp[i][j],dp[i-1][j-h[i]]+h[i]);
        else dp[i][j]=max(dp[i][j],dp[i-1][h[i]-j]+j);
      }
    if(dp[n][0])  cout<<dp[n][0]<<endl;
    else cout<<-1<<endl;
    system("pause");
}

```

---

## 作者：「QQ红包」 (赞：6)

题解 by：redbag

提供一个比较好理解的题解

具体见代码

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<stack>
#include<vector>
#include<algorithm>
using namespace std;
inline int read()
{
    char x;
    int sum=0;
    x=getchar();
    while (!('0'<=x&&x<='9')) x=getchar();
    while (('0'<=x&&x<='9'))
    {
        sum=(sum<<1)+(sum<<3)+x-'0';
        x=getchar();
    }
    return sum;
}
int f[110][2010];//f[i][j]表示能否用前i个砖块使差为j 
int d[110][2010];//d[i][j]表示当前i个砖块可以使两个塔高度差为j时，较高的塔的高度 
int n,sum;
int a[110];
int main()
{
    n=read();
    for (int i=1;i<=n;i++) a[i]=read();
    memset(f,0,sizeof(f));
    f[0][0]=1;
    for (int i=1;i<=n;i++)
    {
        sum+=a[i]; 
        for (int j=0;j<=sum;j++)
        {
            if (f[i-1][j]==1)//前i-1个塔可以使两座塔高度差为j，那么i个塔 
            {
                f[i][j]=1;//标记 
                d[i][j]=max(d[i][j],d[i-1][j]);
            }
            if (j>=a[i]) if (f[i-1][j-a[i]]==1) 
            {//如果f[i-1][j-a[i]] 可以被构成，再在低的塔加上a[i]，则可以使高度差为j 
                f[i][j]=1;
                d[i][j]=max(d[i][j],d[i-1][j-a[i]]+a[i]);//更新 
            }
            if (f[i-1][j+a[i]]==1) //如果f[i-1][j+a[i]]可以被构成 
            {//那么在低的塔加上高度a[i]，则可以使高度差为j 
                f[i][j]=1;
                d[i][j]=max(d[i][j],d[i-1][j+a[i]]);
            }
        }
    }
    for (int i=n;i>0;i--)//倒着找，找到就输出 
    {//最后找到的一定是最大的（想一想，为什么？） 
        if (f[i][0]&&d[i][0]!=0)
        {
            printf("%d",d[i][0]);
            return 0;
        }
    }
    printf("Impossible\n");
    return 0;
}

```

---

## 作者：夏色祭 (赞：6)

##~~出自wǎnjiāng装逼集团 zyk~~

一道简单的dp。。。

状态：f[i,j]表示前i个里差为j的双塔的较高塔的高度的max

状态转移方程:

        f[i+1,j]:=max(f[i+1,j],f[i,j]);//不取第i块积木

        f[i+1,abs(a[i+1]-j)]:=max(f[i+1,abs(a[i+1]-j)],max(f[i,j]-j+a[i+1],f[i,j]));//把第i块积木放在矮的那个塔

        f[i+1,j+a[i+1]]:=max(f[i+1,j+a[i+1]],f[i,j]+a[i+1]);//把第i块积木放在高的那个塔

边界:f[0,0]:=0;

最终答案:f[n,0]

丑陋的code:

```cpp
uses math;
var
  f:array[0..51,0..500010]of longint;
  a:array[0..51]of longint;
  n,i,j,k,sum:longint;
begin
  readln(n);
  for i:=1 to n do 
    begin
      read(a[i]);
      inc(sum,a[i]);
    end;
  for i:=0 to n-1 do 
    for j:=0 to sum-a[i] do 
      begin
        if (i=0)and(j>0) then break;
        if (f[i,j]=0)and(i<>0)and(j<>0) then continue;//注意这两个。。。自己理解
        f[i+1,j]:=max(f[i+1,j],f[i,j]);
        f[i+1,abs(a[i+1]-j)]:=max(f[i+1,abs(a[i+1]-j)],max(f[i,j]-j+a[i+1],f[i,j]));
        f[i+1,j+a[i+1]]:=max(f[i+1,j+a[i+1]],f[i,j]+a[i+1]);//上面应该讲的很详细了吧。。。
      end; //dp
  if f[n,0]=0 then writeln(-1) else writeln(f[n,0]);//输出
end.
```
##~~出自wǎnjiāng装逼集团 zyk~~

---

## 作者：shadowice1984 (赞：5)

经典做法见楼下。。

然而这里有一种简单粗暴的办法。

首先可以观察到，

如果左塔高度为i，右塔高度为j存在的话

则左塔高度为i+h1，右塔高度为j的情况存在

同理i，j+h1存在。（h1为某块水晶高度）。

根据这个性质，我们其实没必要按最大值dp，而是按存在性dp

最后扫一遍最大的可能情况，得出结果。

然后需要注意两点，第一点是不重不漏的的枚举所有的积木。

第二就是，在遍历二维数组时需要倒着扫，因为如果我们从前往后更新的话，就会多次使用同一水晶，

导致错误。

具体见代码。

```cpp
#include<stdio.h>
using namespace std;
int n;bool d[2000][2000];
int h[100];int sum;int cont;
int res=0;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&h[i]);
        sum+=h[i];//计算可能的最高值，即总高度的一半
    }
    d[0][0]=true;cont=sum/2;//边界条件，显然不放水晶的情况一定存在
    for(int i=0;i<n;i++)//每放一块积木就要遍历整个二维数组，复杂度为（n*cont*cont）
    {
        for(int j=cont;j>=0;j--)//从总高一半倒着扫
        {
            for(int k=cont;k>=0;k--)//双层循环遍历整个二位数组
            {
                if(d[j][k]==true)
                {
                    d[j+h[i]][k]=true;d[j][k+h[i]]=true;//转移
                }
            }
        }
    }
    for(int i=0;i<=cont;i++)//扫一遍最大值
    {
        if(d[i][i])res=i;
    }
    if(res==0)printf("Impossible");//如果只有零就输出impossible
    else printf("%d",res);
    return 0;//拜拜程序~
}
```

---

## 作者：田大坑 (赞：4)

### 什么题目都可以搜索，这道也不例外


------------

那么如何搜？？

题目给了我们什么，我们就搜什么
```
void dfs(int s1,int s2,int now)//s1是第一堆的大小，s2是第二堆的大小，now是现在搜到的第几个
{
  ………………//奇怪的代码
}
```
这样你就可以有三十分了~~，这就突出我们剪枝的重要性~~

对于最优性，我们可以通过处理原数据的后缀和来实现，如果后面全部选上，也比不上当前最优解，那么就剪掉

对于可行性，如果某一堆后面全部选上还比不上当前的另一堆，那么也剪掉

所以考试时的80pts的代码贴上

```
#include<bits/stdc++.h>
using namespace std;
int ans,a[151],f[151],n,tot;
bool cmp(int a,int b)
{return a>b;}
inline void dfs(int s1,int s2,int now)
{
//	cout<<1;
    if(s1+s2+f[now]<=ans*2)//最优性
    return;
    if(s1+f[now]<=ans||s2+f[now]<=ans)//最优性
    return;
    if(s1+f[now]<s2||s2+f[now]<s1)//可行性
    return;
    if(now>n+1)
    return;
    if(now==n+1&&s1==s2)
    {
        ans=max(s1,ans);
        return;
    }
    dfs(s1+a[now],s2,now+1);//选入第一堆
    dfs(s1,s2+a[now],now+1);//选入第二堆
    dfs(s1,s2,now+1);//都不选
}
int main()
{
    //freopen("tower.in","r",stdin);
    //freopen("tower.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        tot+=a[i];
    }  
    tot/=2;
    sort(a+1,a+1+n,cmp);//排序也是一种剪枝，先填大的可以个更快得到次优解
    for(int i=n;i>=0;i--)//从0开始！！！这个后缀的处理要从n到0
    {
        f[i]=f[i+1]+a[i];
    }
    dfs(0,0,0);//从0开始
    if(ans!=0)//如果搜到了
    printf("%d",ans);
    else
    printf("-1");
}
```
那么如何ac？？？？

其实可以先贪心得到次优解，使用次优去剪枝

**然而，**我们可以通过简单的打表发现，我们在dfs时总是会出现重复的情况

尽管搜索的顺序不同，可是在某一个点，又回到最初的起点

比如 1+3=2+2的

那么搜到4的时候，前面怎么取是没有后效性的，也就是说，不会影响后面的判断

运用map，可以去除许许多多重复的状态

比如map<int,map<int,map<int,……> > >这样的嵌套，可以有效避免内存爆炸，为了防止MLE和RE，牺牲一点小小的时间是没有问题的

~~然后你就用dfs水过了这到题目~~
```
#include<bits/stdc++.h>
using namespace std;
int ans,a[151],f[151],n,tot,kk[151];
bool cmp(int a,int b)
{return a>b;}
map<int,map<int,map<int,bool> > >mp;
inline void dfs(int s1,int s2,int now)
{
//	cout<<1;
    if(!mp[s1][s2][now])//重复状态的去除
    mp[s1][s2][now]=1;
    else
    return;
	if(s1+s2+f[now]<=ans*2)
    return;
	if(s1+f[now]<=ans||s2+f[now]<=ans)
    return;
    if(s1+f[now]<s2||s2+f[now]<s1)
    return;
    if(now>n+1)
    return;
    if(now==n+1&&s1==s2)
    {
        ans=max(s1,ans);
        return;
    }
    dfs(s1+a[now],s2,now+1);
    dfs(s1,s2+a[now],now+1);
    dfs(s1,s2,now+1);
}
int main()
{
	//freopen("tower.in","r",stdin);
	//freopen("tower.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        tot+=a[i];
    }  
    tot/=2;
    sort(a+1,a+1+n,cmp);
    for(int i=n;i>=0;i--)
    {
        f[i]=f[i+1]+a[i];
    }
    dfs(0,0,0);
	if(ans!=0)
    printf("%d",ans);
	else
	printf("-1");
}
```

后言，比赛的时候一定要看数据 暴丶XXX 

~~这种N<50的数据只要我们够优秀，总可以乱搞的~~

---

## 作者：SAMOI (赞：4)

**题目描述**

小明很喜欢摆积木，现在他正在玩的积木是由N个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？

输入格式：
第一行为一个整数N，表示木块个数。

第二行是N个整数，表示N块木块的高度。

【数据规模】

对于100%的数据，N≤50，每块木块的高度h满足1≤h≤500000，所有木块的高度总和≤500000。

**思路简析**

这是一条比较简单的动规题，考虑到涉及两个塔的大小关系，所以用差来表示状态，继而令 dp[i][j] 表示 用前i个木块搭出两个塔， 高度差为j时的 **较高塔的最大高度** 。

转移方程便十分简单了

dp[i][j] = max(dp[i-1][j], dp[i-1][j+val[i]]);

dp[i][j] = max(dp[i][j], dp[i-1][j-val[i]]+val[i]);
		
dp[i][j] = max(dp[i][j], dp[i-1][val[i]-j]+j);

对应四种情况: 

不加第i块 

第i块加给高的

第i块加给矮的（依然较矮或变得较高））

**代码**

```

#include<cstdio>
#include<cstring>
#define REP(i,a,b) for(register int i = a; i <= b; ++i)
inline int max(int a, int b) {return a > b ? a : b;}
int dp[51][500005], val[51], sum = 0, n;
int main() {
    scanf("%d", &n);
    REP(i,1,n) {
        scanf("%d", &val[i]);
        sum += val[i];
    }
    memset(dp, -2, sizeof(dp)); 
    dp[0][0] = 0;  
    REP(i,1,n) REP(j,0,sum) {
        dp[i][j] = max(dp[i-1][j], dp[i-1][j+val[i]]);
        if(j >= val[i]) 
            dp[i][j] = max(dp[i][j], dp[i-1][j-val[i]]+val[i]);
        else 
            dp[i][j] = max(dp[i][j], dp[i-1][val[i]-j]+j);
    }
    printf("%d\n", dp[n][0] ? dp[n][0] : -1);
    return 0;
}

```

---

## 作者：Phoenix_Zenghao (赞：2)

忘记初始化dp；

dp【i】【j】表示在选择第i块方块时，双塔之间的差值为j；

接下来在dp的时候：

一：矮的塔加上一块仍然矮；

二：高的塔加上一块更高；

三：矮的塔加上一块成为高塔；

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100+5;
int n,dp[maxn][maxn*20],a[maxn],tot;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i],tot+=a[i];
    memset(dp,-0x3f3f3f3f,sizeof(dp));
    dp[0][0]=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=tot;j>=0;j--)
        {
            dp[i][j]=max(dp[i-1][j],dp[i-1][j+a[i]]);
            if(a[i]<=j)dp[i][j]=max(dp[i][j],dp[i-1][j-a[i]]+a[i]);
            else dp[i][j]=max(dp[i][j],dp[i-1][a[i]-j]+j);
        }
    }
    if(dp[n][0])cout<<dp[n][0]<<endl;
    else cout<<"Impossible"<<endl;
    return 0;
}
```

---

## 作者：方方小逗逼 (赞：1)


##~~出自wǎnjáng装逼集团 fy~


速度：300ms- ~~10个点~~

内存：5M-

~~好像是跑的最快、内存最少的。。。~~


dp+模拟

f[i]表示两堆能否达到差值i，b[i]表示差值为i时大的那堆的高度 ~当然可以合成一个，作者较懒~

然后——模拟。。。


简单的dp



```cpp
uses math;
var
  a:array [0..51] of longint;
  f,f1:array [0..500001] of boolean;
  b,c:array [0..500001] of longint;
  n,m,i,j,k,l,r:longint;
begin
  read(n);
  for i:=1 to n do read(a[i]);
  r:=0;
  f[0]:=true;
  f1[0]:=true;
  for i:=1 to n do
  begin
    for j:=0 to r do
      if f[j] then
      begin
        k:=j+a[i];
        f1[k]:=true;
        c[k]:=max(c[k],b[j]+a[i]);
        if k>r then r:=k;
        k:=abs(j-a[i]);
        f1[k]:=true;
        c[k]:=max(c[k],max(b[j],b[j]-j+a[i]));
      end;
    f:=f1;
    b:=c;
  end;
  if b[0]=0 then write(-1)
    else write(b[0]);
end.
```
##~~出自wǎnjáng装逼集团 fy~

---

## 作者：CreeperLordVader (赞：1)

36行代码完美解决

看到此题不难想到如下状态设计

## d[i][j]表示考虑到第i个木块， 第1个塔与第2个高度差为j时，第1个塔的高度

当然，第1个塔高有可能小于第2个塔高，所以J还要加上500000以防负数

这样类比01背包不难写出状态转移方程

# d[i][j]=max(d[i-1][j],d[i-1][j+a[i]],d[i-1][j-a[i]]+a[i]);

其中第1项表示不放，第2项表示放在第2个塔上，第3项表示放在第1个塔上

结果MLE×10

所以还要用滚动数组节约空间

```

#include<bits/stdc++.h>
using namespace std;
const int H=500000;
int n,a[500010],sum;
int d[2][1000010];
void read(int& x)
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++)
    {
        read(a[i]);
        sum+=a[i];
    }
    memset(d,0xcf,sizeof(d));
    d[0][H]=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=a[i];j<=sum+H-a[i];j++)
        {
            d[(i&1)][j]=max(d[(i-1)&1][j],max(d[(i-1)&1][j+a[i]],d[(i-1)&1][j-a[i]]+a[i]));
        }
    }
    if(d[n&1][H]==0xcf||d[n&1][H]==0)printf("-1\n");
    else printf("%d\n",d[(n&1)][H]);
}
```


结束战斗


---

## 作者：tocek_shiki (赞：1)

其实。。。我还是觉得这题2维+滚动就足够了

很简单 只需要稍微乱gun一下就好了
$ f[i][j] $表示第$ i $（$ bool $ 型的）轮，差为j的两座塔中的最大高度
```cpp
#include <bits/stdc++.h>
#define in(a) scanf ("%d", &a)
#define out(a) printf ("%d", a)
#define newline printf ("\n")
#define space printf (" ")
#define cinfalse ios::sync_with_stdio(false)
using namespace std;

int a[55],f[2][500005];//还是滚动数组好
int n;
int tmp = 0, summ = 0;//sum代表总和
int main()
{
	scanf ("%d", &n);
	if(n <= 1)
		return printf("-1"), 0;
	memset (f, 0, sizeof (f));
	for(int i = 1; i <= n; i ++)
		scanf("%d", &a[i]), summ += a[i];
	for(int i = 1; i <= n; i ++)
		for(int j = 0; j <= summ; j ++)
		{
			f[i%2][j] = f[(i-1)%2][j];//默认是上一个
			if(j == a[i])
				f[i%2][j] = max(f[i%2][j], f[(i-1)%2][j - a[i]] + a[i]);
			if(j < a[i] && f[(i-1)%2][a[i] - j] -a[i] + j >= 0)
				f[i%2][j] = max(f[i%2][j], f[(i-1)%2][a[i] - j] + j);
			if(j > a[i] && f[(i-1)%2][j - a[i]] + a[i] - j >= 0)
				f[i%2][j] = max(f[i%2][j], f[(i-1)%2][j - a[i]] + a[i]);
			if(j + a[i] <= summ)
				f[i%2][j] = max(f[i%2][j], f[(i-1)%2][j + a[i]]);//状态转移方程就如上，唯一的问题是要避免负下标
		}
	tmp = (f[n%2][0] == 0)? -1:(f[n%2][0]);//0说明找不到解
	printf("%d", tmp);
	return 0;
}
```

---

## 作者：longint2016 (赞：1)

一道dp

二维就能过

```cpp
var
  a:array[0..100] of longint;
  f:array[0..2000,0..2000] of boolean;
  i,j,k,sum,n:longint;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  f[0,0]:=true;
  for i:=1 to n do begin
    for j:=sum downto 0 do
      for k:=sum downto 0 do
        if f[j,k] then begin
          f[j,k+a[i]]:=true;
          f[j+a[i],k]:=true;
        end;
    sum:=sum+a[i];
  end;
  for i:=sum downto 1 do
    if f[i,i] then begin
      writeln(i);
      halt;
    end;
  writeln('Impossible');
end.
```

---

## 作者：bjxdw (赞：1)

其实并不用向楼下的神牛一样开一个二维数组，本蒟蒻认为一维足矣，就是个背包问题。

f[i]表示到达i的塔有几个。

在计算背包的过程中如果可以，那么f[i]++。

到最后只要两个判断：1.f[i]是否大于2  2.f[V-2\*i]是否存在（V表示所有小塔的高度和）

详见代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[109],f[2009],n,V;
int main ()
{
    V=0,memset(f,0,sizeof(f));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        V+=a[i];//V为高度和 
    }
    f[0]=2;    //保证能取到两个高度为0 的塔    
    for(int i=1;i<=n;i++) //保证每个小塔都遍历到 
    {
        for(int j=V;j>=0;j--)//保证每个塔的高度都遍历到 
        {
            if(f[j]>=1)
            {
                f[j+a[i]]++; // 如果存在j的高度，那么一定存在j+a[i]的高度 
            }
        }
    }
    for(int i=V/2;i>=1;i--)//从高度和的一半开始寻找，因为一半以上不可能 
    {
        if(f[i]>=2&&f[V-2*i]>=1)//是>=2，因为可能出现三个及以上的同高度的塔 
        {                        //而且要存在V-2*i的高度，否则 3 4 3 9 就过不了 
            printf("%d",i);
            return 0;
        }
    }
    printf("Impossible");//若没有寻找到，则impossible 
    return 0;
}
```

---

## 作者：易极feng (赞：0)

一道很不错的题。

发现我的转移方程和大家不一样呢。

设f[i][j]为前i个水晶大小两塔高度差为j时小塔的高度

则
>f[i][j]=max(f[i-1][j],f[i-1][j-h[i]]+h[i],f[i-1][j+h[i]]) ,j>h[i]
>f[i][j]=max(f[i-1][j],f[i-1][h[i]-j]+j,f[i-1][j+h[i]]),j<=h[i]

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;

int n;
int tot=0;
int h[105];
int f[105][2005];

int main(){
    int i,j;
    scanf("%d",&n);
    for(i=1;i<=n;i++)scanf("%d",&h[i]),tot+=h[i];
    
    memset(f,-127,sizeof(f));
    f[0][0]=0;
    
    for(i=1;i<=n;i++){
        for(j=tot;j>=0;j--){
            if(j>h[i]){
                f[i][j]=max(f[i-1][j],max(f[i-1][j-h[i]]+h[i],f[i-1][j+h[i]]));
            }else f[i][j]=max(f[i-1][j],max(f[i-1][h[i]-j]+j,f[i-1][j+h[i]]));
        }
    }
    
    if(f[n][0]>0)printf("%d",f[n][0]);else printf("Impossible"); 
    return 0;
}
```

---

## 作者：dfydada⚡⚡⚡ (赞：0)

一共就两种转移方程：

如果j>w[i]：

f[i][j]=max(f[i-1][j],f[i-1][j+w[i]],f[i-1][j-w[i]]+w[i])；

如果j<=w[i]：

f[i][j]=max(f[i-1][j],f[i-1][j+w[i]],f[i-1][w[i]-j]+j)；

找到最大的 j等于0 时的fij即可。

初始值f[0][0]为0，其余位置为最小值。

然后在通过方程去找就可以了。

但是，题目范围很大，一般的二维肯定是放不下的。

我们只需要在i的基础上%2就可以了，因为一用就只要求两座塔，所以赋值的时候第一项可以赋大点。

总代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[3][5000000],w[5000000];
int n,m;
int asd(int x,int y,int z)
{
    int p=x;//找出该3个数的最大值
    if(p<y)
    {
    	p=y;
	}
    if(p<z)
    {
    	p=z;
	}
    return p;
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
    {
        cin>>w[i];
        m=m+w[i];//计算出所有加起来的值
    }
    for(int i=0;i<=1;i++)
    {
    	for(int j=0;j<=m;j++)
        {
        	f[i][j]=-50000000;//初始化
		}
	}
    f[0][0]=0;
    for(int i=1;i<=n;i++)
    {
    	for(int j=0;j<=m;j++)
		{
            if(j>w[i])
            {
				f[i%2][j]=asd(f[(i-1)%2][j],f[(i-1)%2][j+w[i]],f[(i-1)%2][j-w[i]]+w[i]);
			}
            else
            {
            	f[i%2][j]=asd(f[(i-1)%2][j],f[(i-1)%2][j+w[i]],f[(i-1)%2][w[i]-j]+j);
			}
        }
	}
    if(f[n%2][0]>0)
	{
		cout<<f[n%2][0];
	}
    else
    {
    	cout<<-1;
	}
	return 0;
}

```


---

## 作者：cnyuyang (赞：0)

                 
                 
```cpp
#include<stdio.h>
#include<string.h>
int n;
int bricks[55];
int f[51][500005];
int max(int a,int b)
{
    if(a>b) return a;
    else    return b;
}
int solve()
{
     int tot=0;
     memset(f,255,sizeof(f));
     f[0][0]=0;
     for(int i=1;i<=n;++i)
     {
          for(int j=0;j<=tot;++j)
             if(f[i-1][j]!=-1)
             {
                 f[i][j]=max(f[i][j],f[i-1][j]);//不使用第i块木块
                 f[i][j+bricks[i]]=max(f[i][j+bricks[i]],f[i-1][j]+bricks[i]);
                 //第i块木块放在了较高的那座塔上
                 if(bricks[i]<=j)//第i块木块放在了较矮的那座塔上 
                 {
                     f[i][j-bricks[i]]=max(f[i][j-bricks[i]],f[i-1][j]);            
                 }
                 else
                 {
                     f[i][bricks[i]-j]=max(f[i][bricks[i]-j],f[i-1][j]+bricks[i]-j);
                 }           
             }
          tot+=bricks[i];      
     }
     if(f[n][0]==0) return -1;
     else           return f[n][0]; 
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&bricks[i]);
    printf("%d\n",solve());
   // while(1);
    return 0;
}
```

---


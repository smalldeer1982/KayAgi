# 机器人小Q

## 题目描述

成功派送完这个大单后，餐厅决定引入一名新成员：机器人小 Q。小 Q 的到来让餐厅的客源增加了不少，但是，一段时间之后，新的问题又出现了，小 Q 和我们可不一样，如果要让他工作的话，我们得给他输入能量以保持体力，而小 Q 的能量菜单表上已经按一定顺序给出了 $N$ 个单位的能量值，但是每个单位的能量由于来源不同，需要消耗一定的时间摄入。已知小 Q 每天充电的时间上限值为 $119$，如果时间超出的话就会自动崩溃，大家都想让小 Q 留下来，经过研究之后，决定派 HWX 和 XYF 去和老板谈判，考虑角度不一样，LXC 老板才不想听什么辛酸流泪史，他只想知道，若是想让小 Q 获得 $k$ 单位的能量（也就是能量表中可以不接受某些能量）最少需要几天来充电。

## 说明/提示

### 样例解释

只接收 $1,1,118$。显然这需要 $2$ 天。

### 数据规模

对于 $30\%$ 的数据，有 $1\le K\le N\le 20$。

对于 $100\%$ 的数据，有 $1\le K\le N\le 3000$。

## 样例 #1

### 输入

```
7 3
1 119 119 1 120 120 118
```

### 输出

```
2
```

# 题解

## 作者：LeavingZzz (赞：12)

# $\mathsf{Solution\space For\space P1687}$  
$\mathsf{By\space LeavingZ}$  
Update On 2022/11/17 : 修了一处 typo 与若干个不合理的公式。   

非常好的一道分类讨论类的 dp。  
## $\mathsf{Analysis}$  
首先我们设计状态  
令 $f[i][j]$ 为前 $i$ 个能量单位中选取 $j$ 个能量单位所用的最小天数。  

但是很快你就会发现**这样设计状态是有bug的**，因为每天充电的上限是 $119$，状态设计成这样无法体现这一限制，于是考虑扩展一下。  

令 $f[i][j][1]$ 表示在前 $i$ 个能量单位中选取 $j$ 个能量单位用的最小天数，令 $f[i][j][0]$ 表示**当天数最小时**最后一天的充电时长**最短**为多久。  
（即，以天数为第一关键字，以最后一天充电的时长为第二关键字选取最优解）  

然后研究状态转移方程  

对于第 $i$ 个能量单位我们考虑 选/不选 两种情况  

### 如果我们选取第 $i$ 个能量单位  
此时当前状态 $f[i][j]$ 将由 $f[i-1][j-1]$ 转移而来，根据我们对状态关键字的描述，我们应该考虑以下两种情况  


------------

#### $f[i-1][j-1][0]+w[i]>119$  
这时候我们应该增加新的一天来使用第 $i$ 个能量单位  
因此比较 $f[i-1][j-1][1]+1$ 与 $f[i][j][1]$ 的大小关系。  

若 $f[i-1][j-1][1]+1<f[i][j][1]$  
那么此时选取第 $i$ 个能量单位的决策一定优于 $f[i][j]$ 的决策  
$f[i][j][1]=f[i-1][j-1][1]+1,f[i][j][0]=w[i]$  

若 $f[i-1][j-1][1]+1=f[i][j][1]$，那么这时候比较第二关键字  
$f[i][j][0]=\min(w[i],f[i][j][0])$  


------------
#### $f[i-1][j-1][0]+w[i]\le119$  
这时候考虑将第 $i$ 个能量单位追加到最后一天内，仍然按序比较两个关键字  

若 $f[i-1][j-1][1]<f[i][j][1]$  
此时选取第 $i$ 个能量单位的决策一定优于 $f[i][j]$ 的决策  
$f[i][j][1]=f[i-1][j-1][1],f[i][j][0]=f[i-1][j-1][0]+w[i]$  

若 $f[i-1][j-1][1]=f[i][j][1]$  
此时比较第二关键字  
$f[i][j][0]=\min(f[i][j][0],f[i-1][j-1][0]+w[i])$  
### 如果我们不选取第 $i$ 个能量单位  
这时候直接继承前面的状态  

$f[i][j][0]=f[i-1][j][0],f[i][j][1]=f[i-1][j][1]$  


------------
分析完毕，还有问题请看代码QwQ  
## $\mathsf{Code}$  
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=3007;
int F[maxn][maxn][2];
int N,K;
int w[maxn],cnt;
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("1.in","r",stdin);
	#endif
	scanf("%d%d",&N,&K);
	for(int i=1;i<=N;i++)
	{
		scanf("%d",&w[++cnt]);
		if(w[cnt]>119) --cnt;//大于119可以直接丢掉，怎么都用不上
	}
	//如果可用的能量单位不足K个那么无解
	if(cnt<K) {printf("You can't do it.");return 0;}
	memset(F,0x3f,sizeof(F));//初始化
	for(int i=0;i<=cnt;i++)//无论是多少个数字分成0段花费0天
		F[i][0][1]=0;
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=min(i,K);j++)
		{
			//先继承
			F[i][j][0]=F[i-1][j][0];
			F[i][j][1]=F[i-1][j][1];
			//考虑选取第i个
			//是否需要新增一天
			if(F[i-1][j-1][0]+w[i]>119)
			{
				if(F[i-1][j-1][1]+1<F[i][j][1])
					F[i][j][1]=F[i-1][j-1][1]+1,F[i][j][0]=w[i];
				else if(F[i-1][j-1][1]+1==F[i][j][1])
					F[i][j][0]=min(w[i],F[i][j][0]);
			}
			//直接追加到最后一天
			else
			{
				if(F[i-1][j-1][1]<F[i][j][1])
					F[i][j][1]=F[i-1][j-1][1],F[i][j][0]=F[i-1][j-1][0]+w[i];
				else if(F[i-1][j-1][1]==F[i][j][1])
					F[i][j][0]=min(F[i-1][j-1][0]+w[i],F[i][j][0]);
			}
		}
	/*for(int i=1;i<=cnt;i++)
		for(int j=1;j<=min(i,K);j++)
			printf("F[%d][%d]={%d,%d}\n",i,j,F[i][j][0],F[i][j][1]);*/
	printf("%d",F[cnt][K][1]);//答案即为F[cnt][K][1]
	return 0;
}
```  
$\huge\mathcal{The\space End}$  
谢谢管理大大审核^_^

---

## 作者：pikabi (赞：12)

### Tips：dp


代码思维量不大，设计 dp 表示前 $i$ 个数选 $j$ 个数的最小天数及最后一天所用时间就好了，具体方法楼下讲得很清楚了，本文主要讲述**题意易误解处及对于贪心或选前 $k$ 小的 hack 数据**。

先摘一下部分题面：

> 而小 Q 的能量菜单表上已经按一定顺序给出了 $N$ 个单位的能量值

由此我们可以知道，如果选定了 $K$ 个能量值，那么结果是唯一的，即获取能量的顺序一定是从左往右依此计算所得结果。因而贪心从小到大取是行不通的，这样会导致顺序错误。

因此又有同学会说：“那选出前 $K$ 小按顺序取总可以吧！”

然而结果是不可行。如下数据：

```
6 5 
1 59 60 59 2 63
```

如果选最小的 5 个，将会得到 60 + 119 + 2 的 3 天结果，而正解是 119 + 64 的 2 天结果。感性地理解一下，就是前面选取刚好到瓶颈左右不可取，而到之后却有较大的取值空间，所以我们可以再选取其后的某些值插入到后面，因而不一定取最小的值。同样的，如果遇到相同的能量值，我们势必不知道该取哪些位置，此方法的不可行性也就很明朗了。

至此，讨论区的所有问题均已解决，有问题的话欢迎私信或 hack .

code $-->$

```
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <cctype>
#define ll long long
#define inf 1023456789

using namespace std;

inline int read(){
	int x=0,w=0;char ch=getchar();
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return w?-x:x;
}

int n, k, a[10005], b[10005], f[3005][3005][2], ans, m;

int main(){
	n = read(), k = read();
	for(int i = 1; i <= n; i++){
		b[i] = read();
		if(b[i] <= 119) ans++, a[++m] = b[i];
	}
	if(ans < k){
		puts("You can't do it.");
		return 0;
	}
	memset(f, 0x3f, sizeof(f));
	for(int i = 0; i <= m; i++) f[i][0][0] = f[i][0][1] = 0;
	for(int i = 1; i <= m; i++){
		for(int j = 1; j <= min(i, k); j++){
			f[i][j][0] = f[i - 1][j][0];
			f[i][j][1] = f[i - 1][j][1];
			if(f[i - 1][j - 1][1] + a[i] <= 119){
				if(f[i][j][0] > f[i - 1][j - 1][0])
				f[i][j][0] = f[i - 1][j - 1][0], f[i][j][1] = f[i - 1][j - 1][1] + a[i];
				else if(f[i][j][0] == f[i - 1][j - 1][0])
				f[i][j][1] = min(f[i][j][1], f[i - 1][j - 1][1] + a[i]);
			}
			else {
				if(f[i][j][0] > f[i - 1][j - 1][0] + 1)
				f[i][j][0] = f[i - 1][j - 1][0] + 1, f[i][j][1] = a[i];
				else if(f[i][j][0] == f[i - 1][j - 1][0] + 1)
				f[i][j][1] = min(f[i][j][1], a[i]);
			}
//			printf("%d %d  : %d %d\n",i, j, f[i][j][0], f[i][j][1]);
		}
	}
	printf("%d\n",f[m][k][0] + 1);
}

```

完结撒花 *★,°*:.☆(￣▽￣)/$:*.°★* 。

---

## 作者：夏色祭 (赞：9)

#发波题解23333333

#目前AC的全是Pas，真的是妖怪吧。。。

**以上是废话**

**华丽丽的分割线-------------------------------------------------------------------------------**

不知道dalao们的高端解法，像我这种蒟蒻当然还是用dp过的此题

状态：f[i,j]表示前i个里做了j个，当然这里需要两个变量来存储，分别是做了这j个最少需要几天和当前正在做的这天充了多少时间

方程：f[i,j,1]:=min{f[i-1,j,1],f[i-1,j-1,1]+(f[i-1,j-1,2]+a[j]) div 119} f[i,j,1]的值改变的话，f[i,j,2]也要跟着改，还有一种可能就是两个的f[i,j,1]相等，那就比f[i,j,2]那个小

边界：f[0,0,1]:=0,f[0,0,2]:=0; 另外全赋值23333333........这是最骚的，**qwq**

最终答案:min{f[i,m,1]+(f[i,m,2]+118) div 119}（i>=m）

##妖怪吧！！！

献上比@XZZ\_233大佬代码丑陋的代码：

```cpp
uses math;
var
  f:array[0..3001,0..3001,1..2] of longint;
  a:array[0..3001]of longint;
  n,m,i,j,k,x,y,ans:longint;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      read(x);
      if x<=119 then 
        begin
          inc(k);
          a[k]:=x;
        end;
    end; //读入，比119多的那个单位其实就是没（wei）用（diao）的
  n:=k;
  if n<m then 
    begin
      write('You can''t do it.');
      halt;
    end;
  fillword(f,sizeof(f) div 2,$7f);
  f[0,0,1]:=0; f[0,0,2]:=0;//边界
  for i:=1 to n do 
    for j:=1 to min(i,m) do 
      begin
        f[i,j,1]:=f[i-1,j,1];
        f[i,j,2]:=f[i-1,j,2];
        x:=f[i-1,j-1,1];
        y:=f[i-1,j-1,2]+a[i];
        if y>119 then 
          begin
            inc(x);
            y:=a[i];
          end;
        if x<f[i,j,1] then 
          begin
            f[i,j,1]:=x;
            f[i,j,2]:=y;
          end;
        if f[i,j,1]=x then 
          if y<f[i,j,2] then 
            begin
              f[i,j,1]:=x;
              f[i,j,2]:=y;
            end;
      end;//dp
  ans:=maxlongint;
  for i:=m to n do 
    begin
      if f[i,m,2]>0 then inc(f[i,m,1]);
      ans:=min(ans,f[i,m,1]);
    end;//查找最优解
  writeln(ans); 
end.
```

---

## 作者：distant_east_coast (赞：8)

这道题竟然没有c++题解。。。那本蒟蒻来发布第一篇题解。。。

# 一道很独特的带决策的区间dp

首先理解题意：有n个数，要从中选出k个，将它们分为若干段，要求每段的和不能超过119（一般的，可以记为m），求分段数的最小值

第一眼看上去，如果所有数都要选，就是一道很简单的贪心

于是第一想法就是贪心——选尽可能小的数，也即选其中最小的k个数

但是，有这样一组数据（n=6,k=5,m=13）

3 7 4 6 4 8

按照贪心，选择应为

3 7 4 6 4

此时分段数不可能小于3。而若选择

3 4 6 4 8

则分段数可以为2。因此，贪心选择并不正确。

贪心不成，则只能选择dp求解。

既然要设计dp，首先要分阶段。此处与其余类型的选数题类似，我们可以将从前i个数中选数作为一个阶段。因此，dp数组的第1维就是从前i个数中选择若干个数。

接着，设计状态。由于我们不知道要从前i个数中选择多少个数，我们可以将选择的数的个数作为当前的状态。因此，dp数组的第2维就是选择的数的个数。

接着，进行决策。对于从前i个数中选择j个数的问题，我们要处理第i个数来减小其规模。那么有几种决策呢？我们发现，若i=j，则没有选择——我们必须选择剩余的每一个数，因此第i个数必须选择。若i>j，则可以对第i个数进行决策。若不选择，则问题转化为从前i-1个数中选择j个数，即


```cpp
dp[i][j]=dp[i-1][j];
```

若选择呢？问题应该转化为从前i-1个数中选择j-1个数。但是，第i个数是进入当前的段也即最后一段，还是进入新的一段中呢？我们需要对其进行判断，而这一判断，必须基于最后一段的和来进行——若最后一段的和加上第i个数小于m，则第i个数可以进入最后一段；否则第i个数必须进入新的一段。

### 因此，我们需要另一个数组来记录最后一段的和。这也是这道题目难的地方——它需要维护两个数组来进行dp。

我们用数组f[ i ][ j ]来表示从前i个数中选择j个数时，最后一段的和的最小值。此处的最小值的原因是，如果有选择，那么优先选择最后一段的和最小的状态，以便更多的数可以加入该段。

那么，若选择第i个数，则f[ i ][ j ]的值应当等于f[ i-1 ][ j-1 ]的值加上第i个数的值。若这个值大于m，则说明要分段，此时f[ i ][ j ]的值要更新为第i个数的值，同时dp[ i ][ j ]的值也要自增；否则说明不用分段。

接着就可以顺利进行第i个数是否选择的决策了。具体决策需要用一些中间变量来暂存结果，见代码。

接着我们考虑一下边界条件。这是本题dp的又一个难点。我们说：

1.由于不存在从前0个数中选数的阶段，故从前1个数中选数是从前i个数中选数的边界。

2.由于不存在从前i个数中选0个数的状态，故从前i个数中选1个数是从前i个数中选j个数的边界。

按照上述两个条件，我们需要特殊处理的值有：

```cpp
dp[1][1]=1;
f[1][1]=a[1];
dp[i][1]=1;

```

上述几个值都很容易处理，而f[ i ][ 1 ]表示前i个数中的最小值，需要用递推进行处理：

```cpp
f[i][1]=min(f[i-1][1],a[i]);
```

考虑完边界条件后，输出dp[ n ][ k ]即可。

最后说几个代码书写中需要注意的细节：

1.若输入数据中存在大于119的数，可以直接忽略。

2.当且仅当小于等于119的数的个数小于k时无解。

3.由于i>j必须成立，故对j的循环条件为j<=1&&j<=k，这样可以减少循环次数，降低程序运行时间。

下面就是愉快的代码时间：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int a[3005];//依次存储每一个数
int dp[3005][3005];//从前i个数中选出j个数，最少分成的段数
int f[3005][3005];//从前i个数中选出j个数，当前最后一段的和的最小值
#define INT_MAX 2147483647//定义一下无穷大值

int main()
{
	ios::sync_with_stdio(false);//关一下输入流同步，可以大大提高cin的速度
	int N, k;
	cin >> N >> k;
	int n = 0;//小于等于119的数的个数
	for (int i = 0; i < N; i++)
	{
		int temp;
		cin >> temp;
		if (temp <= 119)//如果当前读到的数小于等于119
		{
			n++;//小于等于119的数的个数自增
			a[n] = temp;//将该数存入数组
		}
	}
	if (n < k)//如果小于等于119的数的个数小于k，则不可能满足题意
	{
		cout << "You can't do it.";
		return 0;
	}
	dp[1][1] = 1;//从前1个数中选1个数，一定分成1段
	f[1][1] = a[1];//从前1个数中选1个数，最后一段和的最小值为a[1]
	for (int i = 2; i <= n; i++)
	{
		dp[i][1] = 1;//从前i个数中选1个数，一定分成1段
		f[i][1] = min(f[i - 1][1], a[i]);//递推得到从前i个数中选1个数，最后一段和的最小值
	}
	for (int i = 2; i <= n; i++)//依次处理每一个数
	{
		for (int j = 2; j <= i && j <= k; j++)//依次处理选出的数的个数
		{
			if (i > j)//当i大于j时，才可以不选第i个数
			{
				dp[i][j] = dp[i - 1][j];
				f[i][j] = f[i - 1][j];
				//若不选择第i个数，则最少分成的段数等于从前i-1个数中选出j个数分成的段数
				//且当前最后一段和的最小值等于从前i-1个数中选出j个数的最后一段和的最小值
			}
			else//当i=j时，每个数都必须选，因此第i个数必须选
			{
				dp[i][j] = INT_MAX;
				f[i][j] = INT_MAX;
				//将分成的段数和最后一段和的最小值全都初始化为极大值，以便下面进行更新
			}

			int tempnum = dp[i - 1][j - 1];
			int tempadd = f[i - 1][j - 1] + a[i];
			//若选择第i个数，则最少分成的段数等于从前i-1个数选出j-1个数分成的段数（第i个数不分入新的一段）
			//或等于从前i-1个数选出j-1个数分成的段数加1（第i个数分入新的一段）
			//且当前的最后一段和的最小值等于第i个数（第i个数分入新的一段）
			//或等于从前i-1个数中选出j-1个数的最后一段和的最小值加上第i个数（第i个数不分入新的一段）
			//先假设第i个数不分入新的一段

			if (tempadd > 119)//若当前的最后一段和大于119
			{
				tempadd = a[i];//则第i个数要分到新的一段，故当前最后一段和为第i个数
				tempnum++;//最少分成的段数自增
			}

			if (tempnum < dp[i][j])//若选择第i个数分成的段数小于不选择第i个数分成的段数
			{
				dp[i][j] = tempnum;
				f[i][j] = tempadd;
				//则更新分成的段数和当前的最后一段和的最小值
			}
			else if (tempnum == dp[i][j] && tempadd < f[i][j])
			//若选择第i个数分成的段数与不选择相同，但是最后一段和更小
				f[i][j] = tempadd;//则更新最后一段和的最小值
		}
	}
	cout << dp[n][k];//输出一下从前n个数中选出k个数的结果
	return 0;
}
```

萌新第一次发题解，难免有写的太麻烦（因为太菜啦）讲的不清楚或者疏漏错误的地方，欢迎指出，欢迎讨论！

完结撒花~

---

## 作者：大宝和小宝 (赞：5)

$\mathit{dp}_{i,j,0}$ ：最小天数 $\mathit{dp}_{i,j,1}$：记录当天数最小时，最后一天的充电时间最短为多久分类讨论：对于第 $i$ 个数字而言，选或不选。

$1.$ 选：$\mathit{dp}_{i,j}$ 由 $\mathit{dp}_{i-1,j-1}$ 转移而来 若 $\mathit{dp}_{i-1,j-1,0}+\mathit{w}_{i}>119$，说明必须增加一天此时需要比较 $\mathit{dp}_{i-1,j-1,i+1}$ 和 $\mathit{dp}_{i,j,1}$ 的大小： 若大于，说明方案不好，不用考虑；若等于，此时需要更新充电时间，即：$\mathit{dp}_{i,j,0}=\min(\mathit{dp}_{i,j,0},\mathit{w}_{i})$；若小于，则更新：$\mathit{dp}_{i,j,0}=\mathit{dp}_{i-1,j-1,1}+1$，同时，$\mathit{dp}_{i,j,0}=\mathit{w}_{i}$。若 $\mathit{dp}_{i-1,j-1,0}+\mathit{w}_{i}\leq119$，那么就考虑把 $i$ 放在最后一天，此时仍然考虑 $\mathit{dp}_{i-1,j-1,1}$ 与 $\mathit{dp}_{i,j,1}$ 的大小，若大于，不用考虑若等于，更新充电时间：$\mathit{dp}_{i,j,0}=\min(\mathit{dp}_{i,j,0},\mathit{dp}_{i-1,j-1,0}+\mathit{w}_{i})$。 若小于，说明此时方案更优，$\mathit{dp}_{i,j,1}=\mathit{dp}_{i-1,j-1,1}$，$ \mathit{dp}_{i-1,j-1,0}=\mathit{dp}_{i,j,0}+\mathit{w}_{i}$。

$2.$ 不选，继承之前答案即可。

-----
```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<queue>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<deque>
#include<map>
#include<vector>
#include<stack>
#include<sstream>
#include<set>
#include<list>
#include<time.h>
#include<stdlib.h>
#include<ostream>
#define ll long long
#define eps 1e-14
#define INF 1e9
#define delta 0.996
#define T 3000
#define pi acos(-1.0)
#define li long double
#define ul unsigned long long
using namespace std;
int dp[3010][3010][2],n,k,w[3010],cnt;
int main(){ 
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		if(x<=119){
			cnt+=1;
			w[cnt]=x;
		}
	}
	if(cnt<k){
		cout<<"You can't do it."<<endl;
		return 0;
	}
	memset(dp,0x3f3f3f3f,sizeof(dp));
	for(int i=0;i<cnt;i++){
		dp[i][0][1]=0;
	}
	for(int i=1;i<=cnt;i++){
		for(int j=1;j<=min(i,k);j++){
			//继承之前答案
			dp[i][j][0]=dp[i-1][j][0];
			dp[i][j][1]=dp[i-1][j][1]; 
			if(dp[i-1][j-1][0]+w[i]>119){
				if(dp[i-1][j-1][1]+1==dp[i][j][1]){
					dp[i][j][0]=min(dp[i][j][0],w[i]);
				}
				else if(dp[i-1][j-1][1]+1<dp[i][j][1]){
					dp[i][j][1]=dp[i-1][j-1][1]+1;
					dp[i][j][0]=w[i];
				}
			}
			else{
				if(dp[i-1][j-1][1]==dp[i][j][1]){
					dp[i][j][0]=min(dp[i][j][0],dp[i-1][j-1][0]+w[i]);
				}
				else if(dp[i-1][j-1][1]<dp[i][j][1]){
					dp[i][j][1]=dp[i-1][j-1][1];
					dp[i][j][0]=dp[i-1][j-1][0]+w[i];
				}
			}
		}
	}
	cout<<dp[cnt][k][1]<<endl;
    return 0;
}
```

-------

---

## 作者：_Fatalis_ (赞：5)

我看这题**似乎**没有将状态转移方程讲清楚的题解啊，所以我来了

---
入题。

看到这题，我立马想到~~贪心~~。

对题意，我的错误的理解为：对于任意一个能量菜单上的能量值都可以在任意时间充电。这样，就可以直接排序选前$k$个最小值进行充电。

然后，我看到了此题的颜色：普及+/提高

**这题不简单！**

于是，我就看到了讨论中的：

**贪心60分求助**

**算法疑问**

**是题目问题还是我的问题**



哦原来是 **按一定顺序** 给出了 $N$ 个单位的能量值，使用也得 **按一定顺序** 。也就是说，用了第 $i$ 个后，第 $i$ 个之前的就不能再用了。

好了，排序不能用了，决策题只能考虑动态规划了。

于是设 $f[i][j]$ 表示在第 $i$ 个之前使用了 $j$ 种能量值时最少用的天数。

比如说对于样例， $f[3][2]$ 表示第三个能量值之前的三种能量值1,119,119中要选择两个能量值并充电给小Q。

考虑 $i$ 和 $j$ 之间关系。

#### 若 i==j

若 $i=j$ ，也就是说前 $i$ 个一定要全部选，那么第 $i$ 项也一定要选。那么就考虑选择第 $i$ 个：

$f[i][j]=f[i-1][j-1]+(t[i-1][j-1]+num[i]>119)? 1:0$

看起来那么长，其实就是将一个if嵌在其中。

首先， $f[i-1][j-1]$ 指前一个选择了 $j-1$ 项的状态，到此状态是刚好选择 $j$ 项。

而后面的一个三元运算，则指是否需要重新的一天来充电——用题目的话来说就是充电量超过了119，则要用另一天来充电。~~否则小Q就要原地爆炸~~

注： $t$ 数组保存着在第 $i$ , $j$ 状态时那一天已经用了多少能量；

#### 若 i>j

再考虑 $i>j$ 。这表示在前 $i$ 种能量值中只用选择 $j$ 个，而并不用全部选完。这就又分两种情况：

（1）不选第 $i$ 种能量。

（2）选第 $i$ 种能量。


对于（2），在 $i=j$ 时我们已经讨论过了，那么只需要Ctrl-C+V就好了。

对于（1），直接 $f[i][j]=f[i-1][j]$ 就得了，没啥要考虑的。

只要对比（1）和（2）的大小就OK了。

依照上面的思路，我们可以写出这个简单的代码。

（不要着急复制粘贴AC这道题啊，因为下面的代码只有30分）

```cpp
#include<bits/stdc++.h>
using namespace std;
int num[3001],f[3001][3001],t[3001][3001];

int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>num[i];
	for(int i=1;i<=n;i++) f[i][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
		{
			if(i==j)
			{    //选取当前能量
				f[i][j]=f[i-1][j-1];
				t[i][j]=t[i-1][j-1]+num[i];
				if(t[i][j]>119)
				{
					t[i][j]=num[i];
					f[i][j]++;
				}
			}
			else
			{
				if(f[i-1][j]<f[i-1][j-1]+(t[i-1][j-1]+num[i]>119)? 1:0)
				{    //不选取当前能量
					f[i][j]=f[i-1][j];
					t[i][j]=t[i-1][j];
				}
				else
				{    //选取当前能量
					f[i][j]=f[i-1][j-1];
					t[i][j]=t[i-1][j-1]+num[i];
					if(t[i][j]>119)
					{
						t[i][j]=num[i];
						f[i][j]++;
					}
				}
			}
		}
	cout<<f[n][k]+(t[n][k]!=0)? 1:0; //此处要将最后一天算上，f[n][k]并没有将当时所用的天数包含在内，即在使用的第一天f[i][j]还是0
	return 0;
}
```

好，为什么30分呢？等等， $i>j$ 的情况没考虑完整！若选择和不选择的天数相同呢？

先停一下，看看 $f[i][j]$ 的含义。它表示在第 $i$ 个之前使用了 $j$ 种能量值时最少用的天数（的向下取整）。对啊！这使当前这一天的使用的能量没有发挥作用啊！

还是举个粒子吧。

现在已经使用了这样的能量组合：

118 1 50

到第三天时，用了1天并还剩下50的能量。剩下的50能量便是主要要对比的对象了。

那么，天数相同时，最后一天所用的能量肯定越少要好啊！所以，在天数相同的情况下，就选择最后一天使用能量较少得那一种方案。

于是代码变成了这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
int num[3001],f[3001][3001],t[3001][3001];

int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>num[i];
	for(int i=1;i<=n;i++) f[i][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
		{
			if(i==j)
			{
				f[i][j]=f[i-1][j-1];
				t[i][j]=t[i-1][j-1]+num[i];
				if(t[i][j]>119)
				{
					t[i][j]=num[i];
					f[i][j]++;
				}
			}
			else
			{
				if(f[i-1][j]<f[i-1][j-1]+(t[i-1][j-1]+num[i]>119)? 1:0)
				{
					f[i][j]=f[i-1][j];
					t[i][j]=t[i-1][j];
				}
				else if(f[i-1][j]==f[i-1][j-1]+(t[i-1][j-1]+num[i]>119)? 1:0)    //此处考虑相同的情况
				{
					if(t[i-1][j]<=((t[i-1][j-1]+num[i])>119? num[i]:t[i-1][j-1]+num[i]))     //这里注意三元运算的优先级
					{
						f[i][j]=f[i-1][j];
						t[i][j]=t[i-1][j];
					}
					else
					{
						f[i][j]=f[i-1][j-1];
						t[i][j]=t[i-1][j-1]+num[i];
						if(t[i][j]>119)
						{
							t[i][j]=num[i];
							f[i][j]++;
						}
					}
				}
				else
				{
					f[i][j]=f[i-1][j-1];
					t[i][j]=t[i-1][j-1]+num[i];
					if(t[i][j]>119)
					{
						t[i][j]=num[i];
						f[i][j]++;
					}
				}
			}
		}
	cout<<f[n][k]+(t[n][k]!=0)? 1:0;
	return 0;
}
```

完结。

---
等等？为什么没有“You can't do it.”都可以的？

哈哈哈，这说明了一些~~显而易见~~的~~事实~~。

既然想到了那么就说一说怎么判断吧。如何凑出不可能充k种电的情况呢？

只有一种情况，就是没有足够的方式充电。

那么输入就可以改成这样：

```cpp
int cnt=0;
for(int i=1;i<=n;i++)
	cin>>num[i],cnt+=(num[i]<=119);
if(cnt<k) puts("You can't do it."); //没有足够的种类去充电
```

正式完结。

---
有不懂得问题，问我哈

有错误请指出，方便我改进自身qwq

---

## 作者：Singercoder (赞：3)

# Analysis

感觉题意没写太清楚（~~所以贪心选前k个会挂~~）

~~应该不止~~我~~一人~~简单地将题意理解为：在n个物品中选k个，然后放到容量为119的背包里，要求用尽量少的背包。

然后看了看题解的线性dp思路，又仔细读了读题目，发现有这样两句模糊的描述：

>而小 Q 的能量菜单表上已经按**一定顺序**给出了 N 个单位的能量值
>
>他只想知道，若是想让小 Q 获得 k 单位的能量（也就是能量表中可以不接受某些能量）最少需要几天来充电。

"一定顺序"表明能量单位是按顺序来的；而如果你不接受某个能量单位，在以后就不能召回。

这表明我们在往背包里面放物品的时候，只能将**当前物品**放在**当前背包**里面。

也就是说，如果这一次你选择开个新的背包，那么前面那个背包就必须舍弃。

举个例子：1 1 118

那么当你处理到第三个物品，不得不开一个新的背包时，尽管第一个背包只用了2的容积，它也已经被你抛弃而无法继续使用。

所以贪心优化要排序并选取前k小，这一排序便会打乱顺序，也就挂了（~~这样也能有50pts数据是有多弱~~）。

而这也是线性dp成立的重要原因：考虑最小背包数a和最后一个背包的最小已用容积b两个因素，设计状态$f_{i,j}$表示在前i个物品中选择j个物品的$pair<int,int>(a,b)$的最小值。

则考虑选与不选有方程$f_{i,j}=\min(add(f_{i-1,j-1},a_i),f_{i-1,j})$，其中add返回的是向原pair放入一个物品后的pair。

具体细节看代码，主要用了个pair来简化思路：

```cpp
#include<bits/stdc++.h>

#define gc() getchar()

#define ri register int 
#define pii pair<int,int>

#define inf 0x3f3f3f3f

using std::min;
using std::pair;
using std::make_pair;

inline int read()
{
	ri ret=0;char ch=gc();
	while(!isdigit(ch))ch=gc();
	while(isdigit(ch))
	{
		ret=ret*10+ch-'0';
		ch=gc();
	}
	return ret;
}

const int MAXN=3e3+10;
const int MOD=119;

int n,m;
int a[MAXN];
pii f[MAXN][MAXN];

//自定义一个加法函数，能放下就放，放不下就新开背包 
pii add(pii s,int x)
{
	if(s.second+x<=MOD)
		s.second+=x;
	else
	{
		++s.first;
		s.second=x;
	}
	return s;
}

int main()
{
//	freopen("1.in","r",stdin);

	n=read();m=read();
	for(ri i=1;i<=n;++i)
	{
		a[i]=read();
		if(a[i]>MOD){--i;--n;}
	}
	if(n<m)
	{
		printf("You can't do it.\n");
		return 0;
	}
	
	for(ri i=0;i<=n;++i)
		for(ri j=0;j<=m;++j)
			f[i][j]=pii(inf,0);//不合法状态初始化为inf
	for(ri i=0;i<=n;++i)
		f[i][0]=pii(0,MOD);//初始状态为使用了0个背包，但第0个背包不能放物品 
	
	for(ri i=1;i<=n;++i)
		for(ri j=1;j<=m;++j)
			f[i][j]=min(add(f[i-1][j-1],a[i]),f[i-1][j]);
	printf("%d\n",f[n][m].first);
	
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

~~这机器人怎么这么耗电？~~

------------
注：本题思路较为简单，所以作者不会过多阐释证明和原理，望周知！

------------
## 大致思路：
首先，题目要求给机器人在一定的天数内充满 $k$ 个单位的电量，所以我们很容易想到用天数作为我们的 DP 值。所以我们就先设计状态：我们设 $dp_{i,j}$ 为在第 $i$ 天前拿了 $j$ 个物品。

接着，我们来想一想实现细节：首先，第一层循环肯定是循**环天数**，第二层循环就是物品，原理和 $01$ 背包的倒序遍历十分相似。循环写完了，接着我们想一想转移方程。**当前最后一个背包剩下k的空间**，此时的最小背包数量转移分两种，一个是**当前背包还能塞下第 $j$ 个就塞**，一个**塞不下了，那么我们就新开一个背包，枚举当前背包的剩余空间，转移**。

综上，转移方程也就分为两种：

1. $dp_{j,k} = \min(dp_{j,k}, dp_{j-1,k+a_i})$，对应的是在原来的背包中添。

2. $dp_{j,119-a_i} = \min(dp_{j,119-a_i}, dp_{j-1,k1} + 1)$，对应的是在不超过 $119$ 的情况下新加一个背包，$k1$ 则表示我们在已经拿了 $k1$ 个物品的基础上新开一个背包（不一定要在发现塞不下的时候开背包）。

同时，我们还要注意到小 Q 机器人的能量上限是 $119$，所以循环剩余能量时要用 $119$ 来减去 $a_i$，才能保证不溢出~~不然就会像我一样改半天~~。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 3001;
int n, m, dp[N][200], a[N], minn[N];
int main()
{
    n = read();
    m = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
    }
    memset(dp, 0x7f, sizeof(dp));
    if (n < m)
    {
        printf("You can't do it.\n");
        return 0;
    }
    dp[0][119] = 1;
    for (int i = 1; i <= n; i++)
    {
        for (int j = min(m, i); j >= 1; j--)
        {
            for (int k = 0; k <= 119 - a[i]; k++)
            {
                dp[j][k] = min(dp[j][k], dp[j - 1][k + a[i]]);
            }
            for (int k1 = a[i] - 1; k1 >= 0; k1--)
            {
                dp[j][119 - a[i]] = min(dp[j][119 - a[i]], dp[j - 1][k1] + 1);
            }
        }
    }
    int ans = 0x3f3f3f3f;
    for (int i = 0; i <= 119; i++)
    {
        ans = min(dp[m][i], ans);
    }
    cout << ans;
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122713582)

---

## 作者：Genius_Star (赞：0)

### 题意：
机器人有一个能量菜单表，里面按照顺序给出了 $N$ 个能量单位的值，每个能量单位需要进行一定的充电时间。

机器人每天有一定的充电时间上限 $119$，如果要获得 $K$ 个能量单位，最少需要多少天。
### 思路：
容易想到 $f_{i,j}$ 表示在前 $i$ 个能量中选择 $j$ 个的最小天数。

但是这样存在问题，我们不知道每天已经充电了多长时间。

因此我们规定状态如下：

1. $f_{i,j,1}$ 表示在前 $i$ 个能量中选 $j$ 个，最少需要几天。

2. $f_{i,j,0}$ 表示当选定的最小天数是 $f_{i,j,1}$ 时，最后一天充电时长最短多少。

可以分为两种状态。

#### 1.选择第 $i$ 个：

1. $f_{i-1,j-1,0}+w_i>119$（需要新开一天）

   - 当 $f_{i-1,j-1,1}+1<f_{i,j,1}$ 时，更新如下：

   $$f_{i,j,1}=f_{i-1,j-1,1}+1,f_{i,j,0}=w_i$$

   - 当 $f_{i-1,j-1,1}+1=f_{i,j,1}$ 时，更新为：

   $$f_{i,j,0}=\min(w_i,f_{i,j,0})$$

（即天数相同时，我们贪心选择让最后一天充电时间最短的，这样有利于后面再选择充电）

2. $f_{i-1,j-1,0}+w_i \leq 119$（不必新开一天）

   - 当 $f_{i-1,j-1,1}<f_{i,j,1}$ 时，更新如下：

   $$f_{i,j,1}=f_{i-1,j-1,1},f_{i,j,0}=f_{i-1,j-1,0}+w_i$$

   - 当 $f_{i-1,j-1,1}=f_{i,j,1}$ 时，可能更新：

   $$f_{i,j,0}=\min(f_{i,j,0},f_{i-1,j-1,0}+w_i)$$

#### 2.不选择第 $i$ 个

这个可以直接继承上一状态。

$$f_{i,j,1}=f_{i-1,j,1}$$


------------


此外，还要注意什么情况达不到要求？

注意啊，$\leq 119$ 的不足要求的天数 $k$ 个。

此外，所有 $>119$ 的不能算入状态方程，因为我们根本就不能把它算入某一天，不然会引起错误。

注意初始化时 $f_{i,0,1}$ 初始为 $0$ 没问题，但是 $f_{i,0,0}$ 应该要初始为最大值。

因为 $f_{i,0,0}$ 是代表当充电总天数为 $0$ 时，最后一天是充电时长最短是多少。

若从 $0$ 开始，则表示第 $0$ 天充电最短时间为 $0$，而更新时也会把第 $0$ 天当做第一个更新的目标。（实际上也可以初始化为 $0$，只不过答案 $+1$ 就行）

我们最后的答案就是 $f_{cnt,m,1}$。（$cnt$ 就是 $\leq 119$ 的数量）
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 3010;
int f[N][N][2],n,m;
int w[N],cnt,a[N];
int main(){
    ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++) {cin>>a[i];if(a[i]<=119) w[++cnt]=a[i];}
    if(cnt<m){
		cout<<"You can't do it.";
		return 0;
	}
    memset(f,0x3f,sizeof(f));
    for(int i=0;i<=cnt;i++) 
	  f[i][0][1]=0;
    for(int i=1;i<=cnt;i++){
        for(int j=1;j<=min(i,m);j++){
            f[i][j][1]=f[i-1][j][1];
            f[i][j][0]=f[i-1][j][0];
            if(f[i-1][j-1][0]+w[i]>119){
                if(f[i-1][j-1][1]+1<f[i][j][1]){
                    f[i][j][1]=f[i-1][j-1][1]+1;
                    f[i][j][0]=w[i];
                }
                else if(f[i-1][j-1][1]+1==f[i][j][1])
                  f[i][j][0]=min(f[i][j][0],w[i]);
            }
            else if(f[i-1][j-1][0]+w[i]<=119){
                if(f[i][j][1]>f[i-1][j-1][1]){
                    f[i][j][1]=f[i-1][j-1][1];
                    f[i][j][0]=f[i-1][j-1][0]+w[i];
                }
                else if(f[i][j][1]==f[i-1][j-1][1])
                  f[i][j][0]=min(f[i][j][0],f[i-1][j-1][0]+w[i]);
            }
        }
    }
    cout<<f[cnt][m][1];
    return 0;
}
```
最后，大家一定要自己推一下啊，不能直接抄哦~


---


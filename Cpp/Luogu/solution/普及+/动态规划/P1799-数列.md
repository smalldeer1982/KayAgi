# 数列

## 题目描述

虽然 msh 长大了，但她还是很喜欢找点游戏自娱自乐。有一天，她在纸上写了一串数字：$1, 1, 2, 5, 4$。接着她擦掉了一个 $1$，结果发现剩下 $1, 2, 4$ 都在自己所在的位置上，即 $1$ 在第 $1$ 位，$2$ 在第 $2$ 位，$4$ 在第 $4$ 位。她希望擦掉某些数后，剩下的数列中在自己位置上的数尽量多。她发现这个游戏很好玩，于是开始乐此不疲地玩起来……不过她不能确定最多能有多少个数在自己的位置上，所以找到你，请你帮忙计算一下！


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$n\leq 20$；
- 对于 $60\%$ 的数据，$n\leq 100$；
- 对于 $100\%$ 的数据，$n\leq 10^3$。


## 样例 #1

### 输入

```
5
1 1 2 5 4
```

### 输出

```
3```

# 题解

## 作者：muyang_233 (赞：52)

由于是**删数**类型的动态规划，所以很容易想到：  
### $dp{_i}{_j}$ 表示前 $i$ 个数中删去 $j$ 个数后，原来处于前 $i$ 个数当中的数所能满足 $a_i=i$ 的 $i$ 的个数的最大值。  
这样，显然有 **$0 \le j \le i$** 。  
那么状态转移方程怎么推呢？  
1. 如果从 $dp_{i-1}{_{j-1}}$ 来推的话，可以保证第 $i$ 个数一定被删，这样答案仍为 $dp_{i-1}{_{j-1}}$ ；
2. 如果从 $dp_{i-1}{_j}$ 来推的话，第 $i$ 个数就没有被删掉，结果为 $dp_{i-1}{_j}$，这时原来的第 $i$ 个数处于第 $i-j$ 个位置，如果满足 $a_i=i-j$ ，答案就可以 $+1$ 。

综上， $dp{_i}{_j}=\left\{
\begin{aligned}
&dp_{i-1}{_{j-1}}  \\
&dp_{i-1}{_j} \ +\ (a_i==i-j) \\
\end{aligned}
\right.$ 

最后答案为 $\max\nolimits_{i=1}^{n}\max\nolimits_{j=0}^{i} dp_i{_j}$ ，即所有 $dp$ 值的最大值。  

代码如下：
```cpp
#include <cstdio>
using namespace std;
int n,ans;
int a[1005];
int dp[1005][1005];
inline int max(int a,int b){
	return a>b?a:b;
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for (int i=1;i<=n;i++){
		for (int j=0;j<=i;j++){
			if (j>0) dp[i][j]=dp[i-1][j-1];\\注意j=0时j-1会越界
			dp[i][j]=max(dp[i][j],dp[i-1][j]+(a[i]==i-j));\\如上所示的状态转移方程
			ans=max(ans,dp[i][j]);\\如上所示的答案
		}
	}
	printf("%d",ans);
	return 0;
}
```

~~这里有AC代码哦，但我相信你不会抄题解的！~~

---

## 作者：一只书虫仔 (赞：23)

#### Description

给定一个序列 $A_i$，你可以选择删除若干个数，求通过删除数之后 $A_i=i$ 的数的个数。

#### Solution

dp，可以设置一个二维 dp 数组 $dp[i][j]$，代表删掉或不删第 $i$ 位后，一共删除 $j$ 个数后，有多少个数在自己的位置上：

- 不删的话，一共删除 $j-1$ 个数，可以从 $dp[i-1][j-1]$ 转移过来
- 删除的话，一共删除 $j$ 个数，可以从 $dp[i-1][j]$ 转移过来，并且如果 $a[i]=i-j$ 的话，那么就让 $dp[i-1][j]$ 的状态加 $1$（思考为什么是 $i-j$？）

我们就很容易得到状态转移方程了：

$$dp[i][j]=\max\{dp[i-1][j-1],dp[i-1][j]+[a[i]=i-j]\}$$

注意，在 $j=0$，即删除数为 $0$ 的时候，不用考虑 $dp[i-1][j-1]$。

```cpp
// wsq AK IOI, hope me to AC

#include <bits/stdc++.h>

using namespace std;

int a[1001];
int dp[1001][1001];

int main () {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	int Max = -1;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= i; j++) {
			if (j == 0) dp[i][j] = dp[i - 1][j] + int(a[i] == i - j);
			else dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j] + int(a[i] == i - j));
			Max = max(Max, dp[i][j]);
		}
	printf("%d", Max); 
	return 0;
}

```

---

## 作者：Dry_ice (赞：21)

> 评语：一道非常好的删数动规练习题。

初学区间 $dp$，相信大家都做过 [石子合并](https://www.luogu.com.cn/problem/P1880)。这道题与石子合并类似，也可以使用区间 $dp$。

但是，也可以想为一个线性 $dp$（其实 区间 $dp\in$ 线性 $dp$），个人认为这样更好理解。

## 状态的定义及其应用
### 1. 定义
设 $F_{i,j}$ 表示当从前 $i$ 个数中删掉 $j$ 个数时，最后剩下的数列中那些恰好在自己位置上的数的个数的最大值。为了方便讲解，设读入的数列为 $A$。

### 2. 状态转移
> 状态如何转移是 $dp$ 的关键！

很容易想到 $F_{i,j}$ 和 $F_{i-1,j}$、$F_{i-1,j-1}$ 有关。

如果前 $i$ 个数删除了 $j$ 个数，那么该数可能删除，可能不删。

- 若删除，则 $F_{i,j}=F_{i-1,j-1}$。

- 若不删，则 $A_i==i-j$，则第 $i$ 位匹配成功，$F_{i,j}=F_{i-1,j}+1$；否则即 $F_{i,j}=F_{i-1,j}$。合在一起可以写成一个转移式：$F_{i,j}=F_{i-1,j}+(A_i==i-j)$。

综上所述，$F_{i,j}$ 显然取两者最大值，状态转移方程也就出来了：

$$F_{i,j}=\max(F_{i-1,j-1},F_{i-1,j}+(A_i==i-j))$$

通过背包压维的经验，发现可以使用一维滚动数组。因此可以写出一维的转移方程：
$$F_j=\max(F_{j-1},F_j+(A_i==i-j))$$

~~小编懒得压维。~~

### 3. 最后谈初始化
显然，从前 $0$ 个数中删除 $0$ 个最大值为 $0$，即 $F_{0,0}=0$。

## CODE
```cpp
#include <stdio.h>
int n, a[1005];
int f[1005][1005], ans;
int main(void) {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= i; ++j) {
            if (j > 0) f[i][j] = f[i - 1][j - 1];
            f[i][j] = f[i - 1][j] + (a[i] == i - j) > f[i][j] ? f[i - 1][j] + (a[i] == i - j) : f[i][j];
            ans = f[i][j] > ans ? f[i][j] : ans;
        }
    printf("%d\n", ans);
    return 0;
}
```

## The end. Thanks.

~~（留个赞再走呗~~

---

## 作者：Siyuan (赞：21)

> ## 没有C++的一维数组dp吗？（逃。。。

## 本题思路：
1. 首先考虑状态：前$\ i$个数中剩下$\ j$个数时的最佳匹配数（无后效性的原因引用一下：`第i个数最终所在的位置，只与i之前所去掉的数有关，而且只和去掉的个数有关，与具体去掉哪些数无关。`）
2. 状态转移方程：如果这个数与剩下的数相同，$f[j]=max(f[i-1][j],f[i-1][j-1])$；否则$\ f[j]=max(f[i-1][j],f[i-1][j-1]+1)$。
3. 将数组第一维优化滚动即可。

## 代码如下:
PS：有些英文注释懒得删了，大佬勿喷
```
#include<cstdio>
using namespace std;

int n,a,ans;
int f[1001];
//  f[1001][1001] -> the first dimension is optimized
//Before i numbers, there are j numbers left

inline int max(const int &a,const int &b){return(a>b?a:b);}
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		for(register int j=i;j>=1;j--)
			f[j]=max(f[j],f[j-1]+(a==j?1:0));
			//f[j]=max(f[i-1][j],f[i-1][j-1]+(a==j?1:0));
	}
	for(register int i=0;i<=n;i++)  ans=max(ans,f[i]);//f[n][i]
	printf("%d",ans);
	return 0;
}
```

---

## 作者：21002tyj (赞：15)

分析题目后我们可以发现，第i个数最终所在的位置，只与i之前所去掉的数有关，而且只和去掉的个数有关，与具体去掉哪些数无关。这个无后效性的特征不难让我们想到使用动态规划。

设f[i][j]表示前i个数去掉j个数后的最优匹配数。得到如下的状态转移方程：

f[i,j]=max(f[i-1,j]+1 if a[i]=i-j/f[i-1,j] if a[i]<>i-j/f[i-1,j-1])

特别的f[i][j]=0。

我们输出f[i][j]，j1(1≤j≤n)的最大值便是我们所要的答案。

时间复杂度O(N2)。





```cpp
Var
  n:longint;
  d:array[1..1001] of longint;
  f:array[-1..1001,-1..1001] of longint;
  Procedure init;
  var
    i,j:longint;
  begin
    readln(n);
    for i:=1 to n do read(d[i]);
  end;
  Procedure dp;
  var
    i,j,max:longint;
  begin
    for i:=1 to n do
      for j:=0 to i do
        begin
          f[i,j]:=f[i-1,j-1];
          if (d[i]<>i-j) and (f[i,j]<f[i-1,j])   then f[i,j]:=f[i-1,j];
          if (d[i]=i-j)  and (f[i,j]<f[i-1,j]+1) then f[i,j]:=f[i-1,j]+1;
        end;
    max:=0;
    for i:=0 to n do
      if f[n,i]>max then max:=f[n,i];
    writeln(max);
  end;
Begin
  init;
  dp;
  readln;
  readln;
End.

```

---

## 作者：tommymio (赞：9)

这道题很有意思。通过充分思考样例，我们很快可以发现以下性质:

1.**在原序列中删除若干数后的留下的序列**可以转化成**原序列的一个子序列**

2.**原序列的子序列中**中能对答案产生贡献的是**子序列中的上升子序
列**，而子序列中其他数都只是对上升子序列中的数的排名产生影响的。

怎么理解第二点呢？

一组数列:100 1 -1 3 -2 5 100 

在这个序列中，产生最优解的子序列很明显是：1 -1 3 -1 5.而这个子序列中的-1 -1只是为了改变1，3，5在序列中的排名，用来填位置的。所以实际上像-1，-1这样填位置的数我们不需要关心他的值，只需要关心有几个这样的数来填充。

事实上，我们只需要观察一下像1，3，5这样的上升子序列所在的子序列中的排名是否成立，就可以判断这样的子序列是否成立。

通过1、2两点性质，我们很快就将这个问题转化成了一个**求符合条件的最长上升子序列的问题**。

```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)? (a):(b))
int a[1005],f[1005];
int main() {
	int n,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	memset(f,-0x3f,sizeof(f));//如果是负数，肯定选不了，赋-inf
	for(int i=1;i<=n;++i) {
		if(i>=a[i]&&a[i]>0) {//如果是正数，并且当前能选
			f[i]=1;
			for(int j=1;j<i;++j) {if(a[j]<a[i]&&a[j]+i-j>=a[i]) f[i]=max(f[i],f[j]+1);}
		}
		else if(i<a[i]) f[i]=0;//如果是正数，但是当前选不了
		ans=max(ans,f[i]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：wangxuye (赞：9)

由于某个zz的错误导致WA了好几发后，蒟蒻默默地点开题解，发现竟然没有人和我的方法一样！！！

—————————— 华丽丽的分割线 ——————————

稍微分析一下题目，我们可以发现这道题和LIS非常类似，再分析一下，可以写出dp方程:dp[i]=max(dp[j])+1; (num[i]>num[j]&&num[i]-num[j]<=i-j)

由于n<=1000，所以我们只要用O(n^2)的算法转移就可以了。

具体见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int dp[1010];
int num[1010];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&num[i]);
	memset(dp,0xcf,sizeof(dp)); //WA的罪魁祸首 
	dp[0]=0;
	int maxn=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<i;j++) 
			if(num[i]-num[j]<=i-j&&num[i]>num[j])
				dp[i]=max(dp[i],dp[j]+1); //状态转移 
		maxn=max(maxn,dp[i]);
	}
	printf("%d\n",maxn);
	return 0;
} 
```

---

## 作者：Pretharp (赞：7)

建议降黄。

题解思路全部过于复杂，事实上本题不需要任何优化就能一维数组，核心代码甚至只有 $11$ 行。

对于任意一个数，想要对答案造成贡献我们只能将其向前移动，我们可以将向前移动的值预处理出来。同时，若两个数最终若都要为答案贡献，前面的数向前移动位置必然小于等于后面的数，于是答案就变成了最长不降子序列。记得判断一个数前面是否有足够的数给它删除。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, f[N], a[N];
signed main() {
	cin >> n;
	for(int i = 1; i <= n; i ++) {
		cin >> a[i];
		a[i] = i - a[i];
	}
	for(int i = 1; i <= n; i ++) {
		if(a[i] < 0) {
			continue;
		}
		f[i] = (i - 1 >= a[i] ? 1 : 0);
		for(int j = 1; j < i; j ++) {
			if(a[j] <= a[i] && (i - j - 1 >= a[i] - a[j])) {
				f[i] = max(f[i], f[j] + 1);
			}
		}
	}
	return cout << *max_element(f + 1, f + 1 + n) << endl, 0;
}
```

---

## 作者：Link_Space (赞：5)

大佬们都用的一维二维 DP ，小菜鸡来一个三维的，自认为比较好理解。

拿到题我首先想的是二维，即：$dp[i][j]$ 表示前i个数共有 j 个数被擦去时的最大答案，但是很快在状态转移时我遇到了问题，所以加上了一维 $[0/1]$ 表示第 i 个数是否被擦去。

这下状态转移就很无脑了：在第 i 个数被擦去的时候，只用继承前面的最大值，在第 i 个数未被擦去的时候，就需要考虑这个数是否到达满足题目条件的位置，如果到达，则答案+1

最后枚举擦去的数的数量，取一个最大值就是答案。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1e3 + 5;
int num[N];
int dp[N][N][2];//前i个数共有j个被擦去了,第i个数被擦/未被擦的最大满足条件数量
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n;i++)
		scanf("%d", &num[i]);
	for (int i = 1; i <= n;i++)
	{
		for (int j = 0; j <= i;j++)
		{
			dp[i][j][1] = max(dp[i - 1][j - 1][1], dp[i - 1][j - 1][0]);
			dp[i][j][0] = max(dp[i - 1][j][0], dp[i - 1][j][1]) + (i - j == num[i]);
		}
	}
	int maxn = 0;
	for (int j = 0; j <= n;j++)
		maxn = max(maxn, max(dp[n][j][0], dp[n][j][1]));
	printf("%d\n", maxn);
}
```


---

## 作者：star_magic_young (赞：5)

~~妈耶又可以水题解了~~

### 思路

看到各位都设2维状态,表示前$i$个数留$j$个的答案(有个压维的).

这里考虑$f_i$表示前i个数,*强制*选第$i$个数的答案.考虑如果$a_i$这个数比i还大,就说明这个数不可能对答案造成贡献;否则考虑从前面的状态$f_j$转移,转移条件为这两个数前者小于后者且两者之间的数的个数不少于这两数之差.

~~虽然时间复杂度没变,但空间不是省下来了吗嘿嘿嘿~~

具体细节见代码

#### code

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#define LL long long
#define il inline
#define re register

using namespace std;
const LL mod=10000;
il LL rd()
{
    re LL x=0,w=1;re char ch;
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*w;
}
int f[1010],a[1010];
int n,k,ans;

int main()
{
  n=rd();
  for(int i=1;i<=n;i++) a[i]=rd();
  memset(f,-0x3f,sizeof(f));
  f[0]=0;
  for(int i=1;i<=n;i++)
    {
      if(a[i]>i) continue;
      for(int j=0;j<i;j++)
	    if(a[i]>a[j]&&a[i]-a[j]<=i-j) f[i]=max(f[i],f[j]+1);
      ans=max(ans,f[i]);
    }
  printf("%d\n",ans);
  return 0;
}

```

---

## 作者：__Hacheylight__ (赞：4)

蒟蒻代码能力太差，还是写了那么长的代码。

这道题目的转移方程有点像公共子序列。

f[i,j]表示前i个数里留下了j个数时的答案。

1.a[i]=j，f[i][j]=max(f[i-1][j],f[i-1][j-1]+1)

2.a[i]!=j，f[i][j]=max(f[i-1][j],f[i-1][j-1])

注意枚举j的时候要倒推枚举。

附上代码：

```cpp
#include <bits/stdc++.h>
#define N 1001
#define fr(i,n,m) for (int i=n;i<=m;i++)
#define dfr(i,n,m) for (int i=n;i>=m;i--)
using namespace std ;
int a[N],f[N][N],n,ans ;
int main(){
	scanf("%d",&n);fr(i,1,n) scanf("%d",&a[i]) ;
	fr(i,1,n) dfr(j,i,1)
	if (a[i]==j) f[i][j]=max(f[i-1][j],f[i-1][j-1]+1);
	else f[i][j]=max(f[i-1][j],f[i-1][j-1]) ;
	fr(j,1,n) ans=max(f[n][j],ans) ;
	printf("%d",ans) ;
}
```

---

## 作者：Shallowy (赞：4)

f[i,j]表示前i个数里留下了j个数时的答案。

则    - 当a[i]=j，即第i个数如果不去掉是能满足条件时，f[i,j]=max{f[i-1,j],f[i-1,j-1]+1}

- 当a[i]<>j时，f[i,j]=max{f[i-1,j],f[i-1,j-1]}.

所以还是很清楚的。

再来个状态压缩......

pascal代码

```cpp
uses math;
var
  n,i,j,ans:longint;
  a,f:array[0..1000] of longint;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  for i:=1 to n do
    for j:=i downto 1 do  //注意倒推
      if a[i]=j then f[j]:=max(f[j],f[j-1]+1)
                else f[j]:=max(f[j],f[j-1]);
  for i:=1 to n do ans:=max(ans,f[i]);  //最后全部找一遍就行
  write(ans);
end.
```

---

## 作者：finger25631677 (赞：3)

谢谢红名大佬！

大佬发现了我的代码的一个惊人的bug然后大佬给了这么一段代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[1010][1010],a[1010],ans=0,i=1,j;
main(){
    for(scanf("%d",&n);i<=n;i++) scanf("%d",&a[i]);
    for(i=1;i<=n;i++)
        for(j=0;j<=i;j++)
            ans=max(ans,(i==n)*(f[i][j]=(i-j==a[i])?f[i-1][j]+1:max(j-1>=0?f[i-1][j-1]:0,f[i-1][j])));
    printf("%d\n",ans);
}
```
完美滴解决了j-1的特判问题，而且……还比我短╭(╯^╰)╮
哎呀果然洛谷是一个好人很多的社区呢！


---

## 作者：Tyyyyyy (赞：2)

## 一道并不难的dp
用$dp[i][j]$表示，在前$i$个数中删去$j$个数后，剩余最多的符合题意的数的个数。
分两种情况：

若删去了当前讨论的这个数：显而易见，$dp[i][j]=dp[i-1][j-1]$。

若不删当前讨论的这个数：依然分两种情况。

如果这个数不符合题意：$dp[i][j]=dp[i-1][j]$；

如果这个数符合题意：$dp[i][j]=dp[i-1][j]+1$。

而判断符合题意的条件则是$a[i]==i-j$（请诸位自行思考）

对于初始化，显然在前$0$个数中删去$0$个数时，没有数符合题意。

因此有$dp[0][0]=0$。

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,num[1001],dp[1001][1001],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&num[i]);
	memset(dp,-63,sizeof(dp));
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=i;j++)//因为可以不删，所以从0开始循环。
		{
			if(num[i]==i-j)dp[i][j]=max(dp[i][j],max(dp[i-1][j]+1,dp[i-1][j-1]));
			else dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i-1][j-1]));
		}
	}
	for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);//最后找在所有数中删去i个数的最大值。
	printf("%d",ans);
	return 0;
}
```

---

## 作者：FanYongchen (赞：1)

看到这道题，先随便打一个搜索。

当现在正在判断第 $i$ 个数，并且前面已经删去 $j$ 个数时

1. 第 $i$ 个数删掉。
2. 第 $i$ 个数保留，所以当 $i-j=a_i$ 时，就多了一个能在自己位置上的数。

```cpp
#include <iostream>
using namespace std;
int n;
int a[1005];
int ans=0;
void dfs(int i,int j,int sum)
{
    if(i>n) {ans=max(ans,sum);return;}//搜到头，找最大值
    dfs(i+1,j+1,sum);//删掉这个数
    dfs(i+1,j,sum+(i-j==a[i]));//不删掉这个数
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];//为了方便，这里下标要从1开始
    dfs(1,0,0);
    cout<<ans;
    return 0;
}
```

很明显，这会超时。

那我们就可以记忆化。

这里用 $f_{i,j}$ 表示正在判断第 $i$ 个数，前面已经删去 $j$ 个数时的最大的符合要求的数的数量

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int n;
int a[1005];
int f[1005][1005];//记忆化
int ans=0;
int dfs(int i,int j)
{
    if(i>n) {return 0;}
    if(f[i][j]!=-1) return f[i][j];//若已经搜过，返回记忆结果
    return f[i][j]=max(dfs(i+1,j+1),dfs(i+1,j)+(i-j==a[i]));//找最大值
}
int main()
{
    memset(f,-1,sizeof(f));//-1表示为搜过
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    dfs(1,0);
    for(int i=0;i<=n;i++) ans=max(ans,f[1][i]);
    //注意这里我们要找的是f[1][i]
    //因为我们深搜回去后会回到第一行
    cout<<ans;
    return 0;
}
```

---

## 作者：江户川·萝卜 (赞：1)

## [P1799 【数列】](https://www.luogu.com.cn/problem/P1799)题解

这是我们集训时做的一道题啦，所以我就来写题解了（~~老师真是个神仙！）~~

这道题无非就是删与不删的问题，我们发现，当某个数删除时，不会改变前面的数的位置，也即**无后效性**，所以我们很容易想到用dp来做。

而且第 $i$ 个数的位置只由之前删除的个数来决定的，

所以设 $f[i][j]$ 为前 $i$ 个数删除 $j$ 个数所可以得到的符合题意的最大个数且 $j\le i$ ，则：

$$f[i][j]=\begin{cases}f[i-1][j-1]&\text{如果删了}\\f[i-1][j]+(a[i]==i)&\text{如果没删}\end{cases}$$

（PS：$(a[i]==i)$表示如果$a[i]==i$返回1，否则返回0）

还有一点，记得初始化 $f[i][0]=f[i-1][0]+(a[i]==i)$

完整代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,a[1001],x,f[1001][1001],maxn; 
int main(){
	//freopen("sequence.in","r",stdin);
	//freopen("sequence.out","w",stdout); 
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++) f[i][0]=f[i-1][0]+(a[i]==i);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			f[i][j]=max(f[i-1][j-1],f[i-1][j]+((a[i]+j)==i));
	for(int i=0;i<=n;i++) maxn=max(f[n][i],maxn);
	cout<<maxn;
	return 0;
}
```


---

## 作者：issue_is_fw (赞：1)

翻了一圈题解，好像没有我这种解法.......

~~明明我这个更简单啊!!!~~

把第$i$个数删掉之后，只会对$i$之后的数字产生影响,而且使后面数字的排名都减少$1$.

如样例$1,1, 2, 5, 4$把第$2$个$1$删掉后,$2$的排名原本是$3$，现在减少$1$变成$2$对应，那此时$2$对答案就做出了贡献。

**至此，算法已经浮出水面**

考虑维护一个$vis[i][j]$数组表示枚举到第i个数时(包括i)

删掉$j$个数时,$i$后面的数字有多少对答案有贡献。

```cpp
	for(int i=n;i>=1;i--)
	{
		if(a[i]>i||i-a[i]>1000)	continue;
		//a[i]大于i,那么a[i]不可能有贡献
		//i-a[i]>1000,需要1000个数字填充排名,可是n范围没那么大啊 
		for(int j=1;j<=i-1;j++)	vis[j][i-a[i]]++;
	}
```
那么可以开始dp了

$dp[i][j]$表示枚举到第$i$个数时删掉了$j$个数时，前$i$个数对答案的贡献

$$dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+flag);$$

从$dp[i-1][j]$转移过来时，说明我们是保留了第$i$个数字

这个时候,$flag$为1表示$a[i]$对答案有贡献，要加上。

```cpp
	for(int i=1;i<=n;i++)
	{
		if(a[i]==i)	temp++;
		dp[i][0]=temp;
		ans=max(ans,temp);
		for(int j=1;j<=i;j++)//挪走j个数字
		{
			flag=0;
			if(i-a[i]==j)	flag=1;
			dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+flag);
			ans=max(dp[i][j]+vis[i][j],ans);
		}	
	} 
```
完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[1009],vis[1009][1009],dp[1009][1009];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>a[i];
	for(int i=n;i>=1;i--)
	{
		if(a[i]>i||i-a[i]>1000)	continue;
		for(int j=1;j<=i-1;j++)	vis[j][i-a[i]]++;
	}
	int ans=0,temp=0,flag=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]==i)	temp++;
		dp[i][0]=temp;
		ans=max(ans,temp);
		for(int j=1;j<=i;j++)//挪走j个数字
		{
			flag=0;
			if(i-a[i]==j)	flag=1;
			dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+flag);
			ans=max(dp[i][j]+vis[i][j],ans);
		}	
	} 
	cout<<ans;
}
```


---

## 作者：lx_zjk (赞：1)

题目大意是让你删去k个数 $0 <= k <= n$

然后使在自己位置上的数的个数最大

即$a[i] = i$

首先说一下我的思考过程吧

首先我想到的是$f[i]$表示到第$i$位后的最大值

显然这东西没法维护

~~著名的杭州二中教练$lj$曾经说过$dp$不会你就加一维~~

然后我就加了一维

$f[i][j]$表示到第$i$位删了$j$个数的最大值

于是状态转移方程时也就比较易得了

$f[i][j] = max(f[i - 1][j] + (a[i] == i - j), f[i - 1][j - 1]);$

当然这个显然是可以用滚动数组进行优化的 ~~不过此题没必要~~ 但是为了提高水平~~没怎么提高~~ 我还是写了

$f[i & 1][j] = max(f[(i - 1) & 1][j] + (a[i] == i - j), f[(i - 1) & 1][j - 1]);$

然后实现起来很简单 这里就直接贴上我的代码了

# code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0; char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 1000 + 5;

int n, a[MAX_N], f[2][MAX_N]; 

int main() {
	n = read();
	for (int i = 1; i <= n; i ++ ) 
		a[i] = read();
	for (int i = 1; i <= n; i ++ ) {
		for (int j = 0; j <= i; j ++ ) {
			f[i & 1][j] = max(f[(i - 1) & 1][j] + (a[i] == i - j), f[(i - 1) & 1][j - 1]);
		}
	}
	int ans = 0;
	for (int i = 0; i <= n; i ++ ) {
		ans = max(ans, f[n & 1][i]);
	}
	cout << ans << endl;	
	return 0;
}
```

---

## 作者：Daniel_7216 (赞：0)

额，这个题非常简单，只要想明白就行了。

首先，~~这是一道动态规划题~~。状态定义肯定要有一维表示前 $i$ 个数中最多能有多少个数在自己的位置上。但是因为~~我没想出来怎么用一维表示~~题目中规定了留下的数必须保证 $A_i = i$，所以要用 $dp_{i,j}$ 表示前 $i$ 个数里删除正好 $j$ 个数最多有多少个数在自己位置上，为什么这么定义？因为我们就可以轻松推出当 $A_i = i - j$ 时它在自己位置上。

当 $j$ 为 $0$ 时直接继承 $dp_{i - 1,j}$，如果 $A_i$ 在自己的位置上就加一。当 $j$ 不为 $0$ 时同理，但是还可以选择不删除这个数，也就是在 $dp_{i-1,j-1}$ 和 $dp_{i - 1,j}+[A_i=i-j]$ 中选择最大值。

奉上代码：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n, a[1001], dp[1001][1001], ans = 0;
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
	}
	for (int i = 1; i <= n; i++){
		for (int j = 0; j <= i; j++){
			if (j == 0){
			  	dp[i][j] = max(dp[i][j], dp[i - 1][j] + (a[i] == i - j));
			}else{
				dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j] + (a[i] == i - j));
			}
			ans = max(ans, dp[i][j]);
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：houzhiyuan (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1799)

考虑$dp$。

$f_{i,j}$表示到了第$i$个数，已经删了$j$个数的最大匹配数。

那么就有两种转移方式。

- 删掉第$i$个数，那么$f_{i-1,j-1}$

- 不删第$i$个数，那么$f_{i,j}=f_{i-1,j}+(a_i==i-j)$，即将$a_i$放到第$i-j$的地方。

所以可以得到状态转移方程。

```cpp
f[i][j]=min(f[i-1][j-1],f[i-1][j]+(int)(a[i]==i-j));
```

最后的答案就是$f$中的最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,a[N],f[N][N],max1;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++){
		for(int j=0;j<=i;j++){//注意可以一个数也不删，所以j的下界为0
			f[i][j]=max(f[i-1][j-1],f[i-1][j]+(int)(a[i]==(i-j)));
			max1=max(max1,f[i][j]);
		}
	}
	printf("%d",max1);
} 
```


---

## 作者：yangwenbin (赞：0)

# 题解 P1799 【数列】

没有看过题目的同学请走这里([传送门](https://www.luogu.com.cn/problem/P1799))

这道题实际上就是一道很明显的dp

我们可以在每一位之前删掉 x 个数，那么对于每一为 i 我们都有含有 i - x 个数的情况。

所以我们设 dp [ i ] [ j ] 为有 i 个数 ( 前 i 个数 ) 的数列，有 j 个数没被删去最大值。

如果该位上的数被擦掉，当前位有 ｊ 个数与前一位有 j 个数是相同的。即 ： 

```dp[i][j] = dp[i-1][j]```。

如果该位上的数不擦掉，当前位有 ｊ 个数是前一位有 j - 1 个数 加上我这一位是否匹配。即 ： ```dp[i][j] = dp[i-1][j-1] + (num[i] == j)```

所以综上 ： ```dp[i][j] = max(dp[i-1][j],dp[i-1][j-1] + (num[i] == j));```

# code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1000 + 50;

int n,ans;
int num[SIZE],dp[SIZE][SIZE];

int main()
{
	scanf("%d",&n);
	for (int i = 1; i <= n; ++i)
	{
		scanf("%d",&num[i]);
	}
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= i; ++j)
		{
			dp[i][j] = max(dp[i-1][j],dp[i-1][j-1] + (num[i] == j));
		}
	}
	for (int i = 1; i <= n; ++i)
	{
		ans = max(ans,dp[n][i]);
	}
	printf("%d\n",ans);
	return 0;
}
```


---


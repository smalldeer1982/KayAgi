# 堆放货物

## 题目背景

Caesar 看了你建设的城市后非常满意，提拔你担任 Genoa 的地方总督，并加薪 $50$ 第纳尔。最近他又写信给你说：Genoa 不能只靠 Rome 的财政扶持，你必须开展城市贸易增加财政收入。

在花费 $500$ 第纳尔开通了至 Capua 的商路后，来自 Capua 的船只源源不断地驶来，Genoa 急需建立一个仓库来临时存放送往 Capua 的货物。

## 题目描述

Genoa 的货物有三种：陶器，家具，大理石，共有 $n$ 个。他们的重量分别为 $1$，$2$，$3$ 个单位。现在，有 $p$ 艘 Capua 的船只在等待着仓库的货物，你应该将仓库里的货物分成 $p$ 堆，堆放规则如下：

- 同一堆中，重量从下至上应该是递减的（显然不能把大理石堆放在陶器或家具上）。
- 任意两堆重量之差不能超过 $3$ 个单位，否则会因分配过于不均发生船只间的冲突。

请你完成这个任务，给出一种可行的方案。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 10^3$，$1 \leq p \leq \lfloor\frac n 2 \rfloor$，$1 \leq a_i \leq 3$。

#### 说明

感谢 @cn：苏卿念 提供spj。

spj说明：

```
score:ouo：你的输出里面有不是'1','2','3',' ','\n','\r'的东西，具体以ASCII的第X号字符
score:pvp：你在第x组的时候装下了超过规定数量的'3'|'2'|'1'。
score:TAT：蛇皮judge没能读入到想要读入的东东(类似于你直接提交了一个puts(" / 特别特别多的空格/"))
score:qaq：你把重量为w1的货物放到了w2上面(w1>w2)在第i组的第j个货物
score:ovo：你没有装足够的x
score:qwq：你第i组和第j组的差的绝对值>3了，(要打架了)，第i组的重量和为x，第j组的重量和为y。
score:pwp：答案正确，恭喜你嘤嘤嘤
```

## 样例 #1

### 输入

```
6
3
3 2 2 1 1 1
```

### 输出

```
3 1
2 1
2 1
```

# 题解

## 作者：霜月骑士 (赞：11)

#  STL大法好！
  同机房的STL巨佬不愿发题解，就由蒟蒻我替他来分享STL的简洁
  
  首先，将所有货物从大到小排序，然后按1~P,P~1这样的顺序来堆放。这样能保证两堆之间“货物数量差”不大于1。
  因为每件货物重量不大于3，所以任意两堆之间“重量差”不大于3，这样就满足了题目的条件了。
  AC!!
  ```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdio>
using namespace std;
int n,p;
int a[10000];//N个货物
vector <int>v[10000];//P个货物堆

bool cmp(int x,int y){
    return x>y;
}

int main(){
    int i,j,k;
    scanf("%d%d",&n,&p);
    for(i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1,greater<int>());//将它们从小到大排序
    
    int num=1;//记录堆放物品到第几个了，从第一个开始
    
    while(num<=n){
        for(i=1;i<=p&&num<=n;i++,num++) //从1~p摆放
            v[i].push_back(a[num]);
            
        for(i=p;i>=1&&num<=n;i--,num++)//从p~1摆放
           v[i].push_back(a[num]);
          
    }
    
   for(i=1;i<=p;i++){ //输出方案
   	for(j=0;j<v[i].size();j++)
   	  printf("%d ",v[i][j]);
   	  printf("\n");
   }
    
}

```
STL大法好！


---

## 作者：Arcturus1350 (赞：10)

首先我来证明一下这题不可能出现什么所谓的无解情况。

就是我们想这样一种办法

记录$3,2,1$的个数分别为$a,b,c$

如果都比较多的话，为了均衡一下，一定是每一条船上先尽可能多的都放相等数量的$1,2,3$

然后我们现在剩下的就是$a\%p,b\%p,c\%p$这些分不完的一些。

在这里我转换定义一下使$a=a\%p,b=b\%p,c=c\%p$

之后呢我们就贪心的装船前$a$个装$3$，第$a+1$到$a+b$个装$2$第$a+b+1$个到第$a+b+c$个装$1$

这里无非就要分两种情况讨论罢了。

首先我们讨论当$p>=a+b+c$的时候。

现在的场面就是$x+3,x+3...x+2,x+2...,x+1,x,x.....$这样子的

$x$是之前我们所有船一起填上去的货物所以那一部分都相等。

显然货物重量最大差距在$x+3$和$x$上，差为$3$满足题意。

特别的，当$p=a+b+c$时候，最大差为$x+3-(x+1)=2$满足。

之后当$p<a+b+c$的时候，我们循环处理一下，填到$p$继续回来填$1$

最坏就成了这样的：$x+3+2+1,x+3+2,x+2+1,x+2+1$

然而最大差还是$3$满足题意$qaq$

本题完结。

上代码。

只有$20pts$等我spj上传了就好了

```cpp
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
int n;
int p;
int num[1010];
int ans[510][510];
int sum[510];
int qwq;
int a,b,c;
int main(){
    freopen("2.in","r",stdin);
    freopen("2.ans","w",stdout);
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;i++) {
        scanf("%d",&num[i]);
        if(num[i]==3) a++;
        else if(num[i]==2) b++;
        else if(num[i]==1) c++;
    }
    int now=a/p;
    for(int i=1;i<=p;i++){
        for(int j=1;j<=now;j++) {
            ans[i][++ans[i][0]]=3;
            sum[i]+=3;
        }
    }
    a%=p;
    for(int i=1;i<=a;i++){
        ans[i][++ans[i][0]]=3;
        sum[i]+=3;
    }
    now = b / p ;
    for(int i=1;i<=p;i++){
        for(int j=1;j<=now;j++) {
            ans[i][++ans[i][0]]=2;
            sum[i]+=2;
        }
    }
    b%=p;
    for(int i=1;i<=b;i++){
        ans[(i+a-1)%p+1][++ans[(i+a-1)%p+1][0]]=2;
        sum[(i+a-1)%p+1]+=2;
    }
    now = c / p;
    for(int i=1;i<=p;i++){
        for(int j=1;j<=now;j++) {
        ans[i][++ans[i][0]]=1;
        sum[i]+=1;
    }
    }
    c%=p;
    for(int i=1;i<=c;i++) {
        ans[(i+a+b-1)%p+1][++ans[(i+a+b-1)%p+1][0]]=1;
        sum[(i+a+b-1)%p+1]+=1;
    }
    for(int i=1;i<=p;i++) {
        for(int j=1;j<i;j++){
            if(abs(sum[i]-sum[j])>3) {
                puts("wa");return 0;
            }
        }
    }
    for(int i=1;i<=p;i++,puts("")){
        for(int j=1;j<=ans[i][0];j++)
        printf("%d ",ans[i][j]);
    }
    return 0;
}
//请问您今天要来点兔子吗？
//夜色长发，刀语真心，神装于身，十日相遇，香草美人——夜刀神十香

```

---

## 作者：mot1ve (赞：6)

精简的代码，显然，如果我们把所有物品按照重量从大到小排序，然后一个个放每一个堆里，也就是依次填满堆的第 $i$ 层，那么肯定不会出现无解的情况。此题最大差值不会超过 $3$ 。比如下面这组数据是一个差值最大的情况。
```
7
3
3 2 1 1 1 1 1
3 1 1
2 1
1 1
```
正确性证明的话因为我们是按照降序排的，两个堆如果物品个数相同，最大差值是2，然后往3那个堆再加一个1，最大差值变为3。依然满足题意。因为我们是降序排列的，既然我们加到1了，后面的也一定是1。
```
#include<bits/stdc++.h>
using namespace std;
int n,p,cnt,tot=1;
int a[1010],b[510][510];//b[i][j]表示第i堆的第j层放的是什么 
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		cnt++;
		if(cnt>p)
		{
			cnt=1;
			tot++;//开下一层 
		}
		b[cnt][tot]=a[i]; 
	}
	for(int i=1;i<=p;i++)
	{
		for(int j=1;j<=tot;j++)
		{
			if(!b[i][j])
			break;
			printf("%d ",b[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：ddwqwq (赞：4)

使用贪心策略，用一个堆维护当前总重量最小的位置，每加入一个货物，把它加入总重量最小的位置即可。  
证明也很简单，只要使用数学归纳法对加入的货物个数进行归纳即可。
```
#include <iostream>
#include <stdio.h>
#include <queue>
#include <algorithm>

const int MAXN = 1005;

struct ele{
    int id;
    int w;
    ele(int a, int b)
    {
        id = a;
        w = b;
    }
    bool operator < (ele t) const
    {
        return w > t.w;
    }
};

int N, P, w[MAXN];
int a[MAXN][MAXN], cnt[MAXN];
std::priority_queue<ele> H;

void init()
{
    int i;
    
    scanf("%d %d", &N, &P);
    for(i = 1; i <= N; i++)
        scanf("%d", w + i);
        
    for(i = 1; i <= P; i++)
        H.push(ele(i, 0));
}

int main() 
{
    int i;
    
    init();
    
    for(i = 1; i <= N; i++)
    {
        ele t = H.top();
        H.pop();
        a[t.id][++cnt[t.id]] = w[i];
        t.w += w[i];
        H.push(t);
    }
    
    for(i = 1; i <= P; i++)
    {
        if(!cnt[i])
        {
            printf("\n");
            continue;
        }
        std::sort(a[i] + 1, a[i] + cnt[i] + 1);
        for(int j = cnt[i]; j >= 1; j--)
            printf("%d ", a[i][j]);
        printf("\n");
    }
    
    return 0;
}
```

---

## 作者：Konnyaku_ljc (赞：2)

[更好的阅读体验](https://konnyaku-ljc.github.io)  
因为[此题](https://www.luogu.com.cn/problem/P1905)中物品的重量只有1或2或3，使此题变的简单了起来   
先写个例子——
```cpp
3 2
3 1 1
```
这种货物中，最坏的情况如下
```cpp
3 1
1
```
可以发现，最大的差值为3。不难推出，这种情况就是最坏结果。  
无论怎样，排序后从大到小由上到下依次分配，最大差值就是3。  
根据这，我们可写出以下代码：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e5;
int n,p,a[N];
int main()
{
	scanf ("%d%d",&n,&p);
	for ( int i = 1; i <= n; i++ )
	{
	    scanf ("%d",&a[i]);
	} 
	sort (a+1,a+1+n);//排好序 
	for ( int i = 1; i <= p; i++ )
	{
        int cnt = n-i+1;//这一排的最底层 
        while (1)
        {
        	printf ("%d ",a[cnt]);
        	cnt -= p;//将这排继续向上摞，直到摞不动 
        	if ( cnt <= 0 ) break;
		}
		printf ("\n");
	}
	return 0;
}
```
代码中不难看出，每个数据只被处理了一次，所以复杂度就是快排的O(nlogn)


---

## 作者：DUO_JIaMInG (赞：2)

题目不可能出现不合法的情况

具体证明参考@cn：苏卿念 

直接模拟就好


```
//P1905 堆放货物
#include<bits/stdc++.h>
using namespace std;
int n,p;
int w[4];
int pp[2550][1050];//第一位是船号 第二维是物品数
int cnt[2550];//记录一艘船上放了几个物品
int main(){
    cin>>n>>p;
    for(int i=1;i<=n;i++){
        int s;
        scanf("%d",&s);
        w[s]++; //记录1，2，3 出现次数
    }
    int len=1;//记录分到了第几个船
    for(int i=1;i<=3;i++){
        for(int j=1;j<=w[i];j++){
            len=len%p;
            pp[len][++cnt[len]]=i;
            len++;
        }
    }
    for(int i=0;i<p;i++){
        for(int j=cnt[i];j>=1;j--){//从下到上
            cout<<pp[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
 
```


---

## 作者：pocafup (赞：1)

题目：**堆**放货物

~~知道要用啥了吧~~

不明白这题怎么评到紫的，由于绝对值要求不超过三，而点权只有{1,3}，显然可以用一个堆来维护目前所有堆中重量最小的编号。

一个显然的证明：如果两堆的重量差超过三，一定有某一堆被连续放了两次货物。然而我们堆维护的东西是重量的最小值，所以如果某一堆被放了一次后重量不是最小了，下一次更新的一定是另一个堆。点权保证的这个贪心的可行性。

复杂度 $O(nlogn)$

代码：
```cpp
const int MAXN = 1e3+5;
const int MAXM = 1e5+5;
struct Node{
  int val,id,num;
  bool operator < (const Node &oth) const{
    return val>oth.val;
  }
};//堆的排序顺序：从小到大
bool cmp (int a, int b){return a>b;}
int n,m,t,pos[MAXN],dp[MAXN][MAXN];
pq<Node> q;

signed main(){
  n = read(); m = read();
  For(i,1,n) pos[i] = read();
  sort(pos+1,pos+1+n,cmp);
  For(i,1,m) q.push((Node){0,i,1});
  For(i,1,n){
    Node qf = q.top(); q.pop();
    dp[qf.id][qf.num] = pos[i];//记录某一堆在某个位置的数值
    qf.num++,qf.val+=pos[i];
    q.push(qf);
  }
  For(i,1,m){
    int cnt = 1;
    while(dp[i][cnt]) cout << dp[i][cnt++] << " ";
    cout << endl;
  }
}
```

---

## 作者：wzkdh (赞：0)

## 题意：
将给出的数组分为p个递减的序列，且每两个序列的和之差小于等于3。
## 分析：
首先我们可以很轻易的想到，要想任意两堆重量差值最小，我们要尽量把相同重量的物品均分到p堆里，因为如果p堆里都有一个重量为x的物品，相互之间的差值依然为0，这样两堆的差值只取决于$sum[3]$%$p$,$sum[2]$%$p$,$sum[1]$%$p$,因为其与的已经均分到p堆里了，不会造成差值。

那么这些怎么办呢？我们只需要把它们从大到小依次放到p堆里，可以保证合法。我们只需要分类讨论即可证明：首先每个堆里最多有一个1，一个2，一个3，且第一堆一定是最重的，第p堆一定是最轻的，按照这个，那么只要证明$w[1]$-$w[p]$<=3即可。假设堆1为3,2,1那么第p堆至少是2,1，否则堆1不可能在上面放着2,1;同理，假如第一堆为3,1，那么第p堆至少为1……如此讨论几次，即可发现重量只差按照这个方式排列一定小于三。

## 蒟蒻代码
```
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int n,p,a[1010],w[510][510];
int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	int fl=1,g=1;
	n++;
	while(n--)
	{
		w[fl][g]=a[n];
		g++;
		if(g>p)
		{
			g=1;
			fl++;
		}
	}
	for(int i=1;i<=p;i++)
	{
		for(int j=1;w[j][i];j++)
		{
			printf("%d ",w[j][i]);
		}
		printf("\n");
	}
	return 0;
}

---

## 作者：Treaker (赞：0)

这题其实很简单。

我们考虑一个是人都能想到的方法，从大到小排序，然后按照1 -> p，p -> 1这样的方法来放。

考虑这种方法的正确性。

仔细想想就是对的。因为，我们这样保证，第一次小的，第二次可以拿到大的来填补。然后，你手玩一下，可以发现，这样放的差值最大是2。

~~代码很丑~~

```cpp
#include <map>
#include <set>
#include <cmath>
#include <queue>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
namespace IO
{
	char buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];
	#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)
	#define gt() getchar()
	inline int read()
	{
		int x = 0 , f = 1; char ch = gt();
		while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = gt();}
		while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}
		return x * f;
	}
	template <class T> inline void write(T x)
	{
		if(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');
		if(x < 0) *f3 ++ = '-' , x = ~x + 1;
		char *top = sta;
		while(x) *top ++ = x % 10 + 48 , x /= 10;
		while(top != sta) *f3 ++ = *-- top;
		*f3 ++ = ' ';
	}
	inline void put(std::string s)
	{
		int len = s.length();
		for(int i = 0;i < len;i ++) *f3 ++ = s[i];
		*f3 ++ = ' ';
	}
	inline void endline() { *f3 ++ = '\n';}
	#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)
	template <class T> inline T abs(T a) { return a < 0 ? -a : a;}
	template <class T> inline T max(T a,T b) { return a > b ? a : b;}
	template <class T> inline T min(T a,T b) { return a < b ? a : b;}
	template <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}
}
using namespace IO;
const int N = 1005;
int a[N];
std::vector<int> G[N];
int main()
{
	int n = read() , m = read();
	for(int i = 1;i <= n;i ++) a[i] = read();
	std::sort(a + 1,a + 1 + n,std::greater<int>());
	for(int i = 1 , j = 1;i <= n;i ++)
	{
		G[j].push_back(a[i]);
		if(((i - 1) / m) & 1)  j -= i % m != 0;
		else j += i % m != 0;
	}
	for(int i = 1;i <= m;i ++ , puts("")) for(int j = 0;j < (int)G[i].size();j ++) printf("%d ",G[i][j]);
	return 0;
}
```


---

## 作者：Msy153 (赞：0)

这道题只有1、2、3三种重量，虽然标签写的是dp，但是本能告诉我暴力骗分整一波，没想到就ac了X

暴力的方法就是优先把重的物件依次轮着堆到船上

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fr(i,n) for(int i=0;i<n;i++)
#define frr(i,j,n) for(int i=j;i<n;i++)
#define yes "yes"
#define no  "no"
using namespace std;

int a[1005];

int main(){


    cin.tie(0);


    int n,p;
    while(cin>>n>>p){
        fr(i,n) cin>>a[i];
        sort(a,a+n,[](int a,int b){
            return a>b;
        });
        stringstream *ss = new stringstream[p];
        int j = 0;
        fr(i,n){
            ss[j++]<<a[i]<<" ";
            if(j==p)    j=0;
        }
        fr(i,p){
            cout<<ss[i].str()<<endl;
        }
    }

    return 0;
}

```




---


# [NOIP 2013 普及组] 小朋友的数字

## 题目背景

NOIP2013 普及组 T3

## 题目描述

有 $n$ 个小朋友排成一列。每个小朋友手上都有一个数字，这个数字可正可负。规定每个小朋友的特征值等于排在他前面（包括他本人）的小朋友中连续若干个（最少有一个）小朋友手上的数字之和的最大值。

作为这些小朋友的老师，你需要给每个小朋友一个分数，分数是这样规定的：第一个小朋友的分数是他的特征值，其它小朋友的分数为排在他前面的所有小朋友中（不包括他本人），小朋友分数加上其特征值的最大值。

请计算所有小朋友分数的最大值，输出时保持最大值的符号，将其绝对值对 $p$ 取模后输出。


## 说明/提示

**样例解释 1**

小朋友的特征值分别为 $1,3,6,10,15$，分数分别为 $ 1,2,5,11,21$，最大值 $21$ 对 $997$ 的模是 $21$。

**样例解释 2**

小朋友的特征值分别为 $-1,-1,-1,-1,-1$，分数分别为$-1,-2,-2,-2,-2$，最大值 $-1$ 对 $7$ 的模为 $-1$，输出 $-1$。

**【数据范围】**

对于 $50\%$ 的数据，$1 \le n \le 1000$，$1 \le p \le 1000$，所有数字的绝对值不超过 $1000$；

对于 $100\%$ 的数据，$1 \le n \le {10}^6$，$1 \le p \le {10}^9$，其他数字的绝对值均不超过 ${10}^9$。

## 样例 #1

### 输入

```
5 997
1 2 3 4 5
```

### 输出

```
21
```

## 样例 #2

### 输入

```
5 7
-1 -1 -1 -1 -1
```

### 输出

```
-1
```

# 题解

## 作者：yjxyjx (赞：117)

~~额这道题着实恶心qwq~~

---

刚看到这个题目的时候就感到题面深深的~~**恶心**~~， ~~（好吧是我语文太差qwq）~~，但是还是要做啊，所以说先把这道题中的几个关系在草稿纸上列了一下草稿qwq：

首先我们要明确：这题有三个值，分别是：

1.**每个小朋友手上的牌的数字，简称“手牌值”**

2.**特征值**：第$i$个小朋友的**特征值** $ = $ 排在他前面（包括他本人）的小朋友中，连续若干个（最少有一个）小朋友**手牌值**的和的最大值

3.**分数**：第$i$个小朋友的**分数** 等于：

如果 $i = 1$ 那么： 这个小朋友的分数 = 这个小朋友的特征值

否则： 这个小朋友的分数 = 前面所有小朋友中，**任意一个**小朋友的分数加上这个小朋友本身的特征值

~~python中文编程（雾~~

算了我把这三个值多少解释表示一下吧qwq：

1.手牌值。~~这个东西的获取靠读入不说了吧qwq~~


2.特征值：在实现的时候，借鉴了一下icy的思路，用两个数组维护，分别是：

$w$数组：以i为结尾的最长连续子段和（icy原话）

$q$数组：1~i中的最长连续子段和（个人认为q数组对应的是特征值）

3.分数：这个根据上面的定义~~乱搞~~一下即可，~~（上面写的那么python应该能懂吧qwq）~~

最后，**溢出**怎么办？

~~开_int128~~

正解：两个long long当高精度用，

附AC代码：

```
#include<bits/stdc++.h>
#define ll long long
const ll MaxN = 1e6;
const ll Base = (ll)1e9;

struct pii {
    ll high, low;
    friend inline pii operator +(const pii &a, const pii &b) {
        pii c; c.high = a.high + b.high; c.low = a.low + b.low;
        if (c.high >= 0 && c.low >= Base) {
            c.high += c.low / Base; c.low = c.low % Base;
        }
        if (c.high <= 0 && c.low <= -Base) {
            c.high += c.low / Base; c.low = c.low % Base;
        }
        if (c.high > 0 && c.low < 0) {
            c.high--; c.low += Base;
        }
        if (c.high < 0 && c.low >= Base) {
            c.high++; c.low -= Base;
        }
        return c;
    }
    friend inline bool operator <(const pii &a, const pii &b) {
        if (a.high == b.high) return a.low < b.low; else return a.high < b.high;
    }
    friend inline pii max(const pii &a, const pii &b) {
        if (a < b) return b; else return a;
    }
};

ll N, P;

inline void getInt(ll &ans) {
    int f = 1; long long x = 0; char ch;
    do {ch = getchar(); if (ch == '-') f = -1;} while (ch < '0' || ch > '9');
    do {x = x*10 + ch - '0'; ch = getchar();} while (ch >= '0' && ch <= '9');
    ans = (f == 1) ? x : -x;
}

pii w[MaxN], q[MaxN], s[MaxN], data[MaxN], 
    ans;


int main() {
    getInt(N); getInt(P);
    for (int i = 1; i <= N; ++i) {
        getInt(data[i].low);
    }	
    
    ans = s[1] = q[1] = w[1] = data[1];
    for (int i = 2; i <= N; ++i) {
        w[i] = max(w[i - 1] + data[i], data[i]);
        q[i] = max(q[i - 1], w[i]);
        s[i] = (i == 2) ? s[1] + s[1] : max(s[i - 1], s[i - 1] + q[i - 1]);
        ans = max(ans, s[i]); 
        // debug1();        
    }
    std::cout << (((ans.high%P)*Base)%P + (ans.low%P))%P << std::endl;
    return 0;
}

```

---

## 作者：immortal_water (赞：57)

To 审核：更新的一个代码错误 ---2023.12.1

前置芝士：[P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)。

前言：本来已经 AC 的题被我自己 Hack 掉了(雾)。

### 目录:
1. 题意分析及 80 分模拟代码；

1. 单调性证明及算法简化；

1. 大多数人的问题所在(爆 long long)；

1. 问题的解决办法；

1. AC 代码。

## 题意分析及 80 分模拟代码

对于每一个小朋友有三个值：$nu_i$ 代表**手上的数字**，$te_i$ 表示**特征值**，$fe_i$ 表示**分数**。

计算方式：$nu_i$ 依靠读入；设 $\operatorname{maxzd}(x,y)$ 代表 $te_x$ 到 $te_y$ 的[最大子段和](https://www.luogu.com.cn/problem/P1115)，则 $te_i=\operatorname{maxzd}(1,i)$；$fe_i=\max(fe_j+te_j)(1 \leqslant j < i , 1 < i \leqslant n )$ 且 $fe_1=te_1$。

于是我们就可以模拟了。

[模拟的代码](https://www.luogu.com.cn/paste/w89q6hea)

![图：两个点 WA，其他 AC](https://s2.loli.net/2022/07/27/YKIwrZok6T3WSAc.png)

## 单调性证明及算法简化

仔细看题，我们可以发现 $fe$ 数组的一个性质：根据 $fe_i=\max(fe_j+te_j)(1 \leqslant j < i , 1 < i \leqslant n )$ 可得 $fe_i=\max(\max(fe_j+te_j),fe_{i-1}+te_{i-1})(1 \leqslant j < i-1 , 1 < i-1 < n )$ 进而 $fe_i=\max(fe_{i-1},fe_{i-1}+te_{i-1})=fe_{i-1}+\max(0,te_{i-1})(1 \leqslant j < i-1 , 2 < i \leqslant n )$。

我们来解读一下这个公式：首先，对于 $n \geqslant i>j \geqslant 2$ 一定有 $fe_i \geqslant fe_j$ 说明 $fe$ 是一个不降(jiang)的数列，故 $fe_i=\max(fe_j+te_j)(1 \leqslant j < i , 1 < i \leqslant n )$ 可以化为 $fe_i=\max(fe_1+te_1,fe_{i-1}+te_{i-1})$；其次，$fe_n=fe_{n-1}+\max(0,te_{n-1})=\cdots=fe_2+\sum_{i=2}^{n-1}\max(0,te_i)$，也就是说，$fe_n$ 等于 $fe_2$ 加上 $te_2$ 到 $te_{n-1}$ 中所有的正数。

所以我们只要**比较 $fe_1$ 和 $fe_n$ 并输出较大的那个取模即可**。

解读完后，我们就可以初步改进我们的代码(得分情况与一开始一致就不放图了)：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,p,a;
	cin>>n>>p>>a;
	//a是nu[1]
	if(n<2)
	//特判只有一个数据
	{
		cout<<a%p;
		return 0;
	}
	long long su=max(a,0),maxx=a,maxn=a*2;
	//su是计算最大子段和用的辅助变量
	//maxx是当前的最大子段和也就是特征值
	//maxn是储存fe[n]的变量
	for(int i=2;i<n;i++)
	//已经读了第一个所以从2开始，最后一个对答案没贡献所以不用读
	{
		int c;cin>>c;su+=c;
		maxx=max(maxx,su);
		maxn+=max(maxx,(long long)0);
		su=max(su,(long long)0);
	}
	cout<<max((long long)a,maxn)%p;
	return 0;
}
```

## 大多数人的问题所在

还记得我们一开始 WA 的两个点吗？我们有了公式后再来分析：最坏情况下，$nu_1=nu_2=\cdots=nu_n=10^9,n=10^6$ 所以 $te_i=i \times 10^9$ 故 $fe_n=fe_2+\sum_{i=2}^{n-1}\max(0,te_i)=2\times nu_1+\frac{(2+10^6-1)(10^6-1)}{2}\times10^9\approx5\times10^{20}$ 远超 long long 范围，所以 WA 的两个点想必就是爆 long long 了

## 问题的解决办法

如何解决这个范围的问题呢？按照我们以往的思维来看，最后输出取模的题，在遇到爆数据类型时应该**提前取模**。但这题是需要最后比较 $fe_1$ 和 $fe_n$ 的，似乎又不能提前模。那么我们现在就只有两个思路了，一是把比较提前，让取模不影响比较；二是扩大存储的范围。

扩大存储范围可以用 ~~__int128~~ 或者高精度，高精度建议读[这篇题解](https://www.luogu.com.cn/blog/yjx/p1982-xiao-peng-you-di-shuo-zi)，非常不错。

提前比较看似不可实现，但根据我们之前算的公式，我们可以知道在计算过程中我们存储 $fe_n$ 的变量是**一直升高**的(人话：这个变量储存的值不会减小)，那么在这个过程中，一旦有一刻这个变量的值超过 $fe_1$ 那么 $fe_n$ 就一定大于 $fe_1$。从这一刻开始，我们就可以开始取模来使数据不爆 long long。若这个变量一直没有超过 $fe_1$，由于 $fe_1\leqslant10^9$ 所以也不会爆 long long。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,p,a;
	cin>>n>>p>>a;
	long long su=max(a,0),maxx=a,maxn=a*2;
	bool flag=a>0/*特判n=2*/&&n>1/*特判n=1*/;
	//flag存储最后的结果
	for(n-=2;n-->0;su=max(su,(long long)0))
	{
		int c;cin>>c;su+=c;
		maxn+=max(maxx=max(maxx,su),(long long)0);//简化了之前的程序
		if(flag)maxn%=p;//如果确定了输出fe[n]
		else if(maxn>a)flag=1;//否则如果可以确定输出fe[n]
	}
	maxn=(flag?maxn:a);
	if(maxn<0)cout<<'-';cout<<abs(maxn)%p;、
	//怕出现输出'-0'的情况，不过看样子没这种数据点
	return 0;
}
```

---

## 作者：huangjiawei (赞：8)

算法一

首先是暴力算法。 第一种是完全按照题意模拟，枚举首尾，然后累加中间一段，取最大值。如果你愿意把累加中间段的这一重循环省略掉，加上前缀和优化即可。不过意义不大。 时间效率O(N^4)//完全朴素 O(N^3)//加上前缀和优化 空间效率O(N)

算法二 做题量稍大的同学估计读完题就能发现这是个（几乎是裸的）最大子段和问题。对于最大子段和问题，我们有O(N)的算法。 具体的做法是这样的：当前要求第I位及之前的最大子段和，如果第（I-1）位及之前的最大子段和大于0，则显然这一位取了也未尝不可（不会减少），也就是当前这一位和前面一段连接起来。否则的话，就新开一段——把前面的最大子段和改成0以后继续往下扫描。，

DP方程为 f[i]=max{a[i],f[i-1]+a[i]}

其中f[i]表示前i个数的最大子段和。

上述算法能拿到80分。关键在于算到后来已经超出了int64的范围。怎么办呢？你可以写个高精度，不过要分正负讨论，比较麻烦，这里不再赘述。 有一个方法可以较好解决这个问题。想一想，除了第1个小朋友以外，后面的小朋友的分数值肯定是单调不递减的。那么我们不用把值都记录下来，可以一边处理，一边mod。如果碰到可以更新的（当前这个小朋友的分数值大于0），根本不用考虑是否比Max要大。（肯定比Max要大）因此直接用这个小朋友分数值modP的值更新Max即可。至于第1个小朋友，再分类讨论一下即可。

这个思路有一个需要注意的地方，分数值+特征值会超过longint、int64（高精度可以解决），这里采用计算max时执行mod p操作，于是就产生了如下问题：

输入：

5 981
-409 -401 97 -96 -301

特征值：-409 -409 -312  97  97

分数值：-409 -818 -818 -721 -624

max  ：-818 不变 -721 -624

最终max停留在了-624，但明显-409才是最大的分数值，这个问题其实就是max初值两个-409惹的祸，必须要在后面所有特征值中判断有没有绝对值大于409的，否则max需要考虑第一个分数值，以免出现这样的错误。

附上代码：

```cpp
var
    i,n,p:longint;
    a:array[0..1000000] of longint;
    f,b:array[0..1000000] of int64;
    max,temp:int64;
        flag:boolean;
begin
```
输入部分和求特征值部分省略
   
```cpp
   //f[i]表示分数,  b[i]代表特征值
        f[1]:=b[1];max:=f[1]+b[1];if b[1]<0 then flag:=false;
    for i:=2 to n-1 do begin
      f[i]:=max;
          if b[i]>0 then begin
             if not flag and (b[i]>-b[1]) then flag:=true;
             max:=(f[i]+b[i]) mod p;
          end;
        end;
        if not flag and (max<f[1]) then max:=f[1];
        writeln(max);
end.

```

---

## 作者：Priori_Incantatem (赞：8)

这题绿题的原因是因为爆`long long` ？？  
对于小朋友的特征值，求最大子段和：复杂度 $O(n)$  
对于小朋友的数字，前缀和求最大值（其实 线段树/树状数组 也可以）：复杂度$O(n)$  

做完了后发现80分，原来有两个点爆`long long`  

如果你不想打高精，你可以用`__int128`  
它的唯一坏处就是输入输出必须自己写（快读 + 快写）  
再，如果你不想打快读 + 快写，你可以使用`long long` （雾  
我们发现，输入进来的和输出的答案并不会爆`long long`，只是中间运算的时候会爆。其实输入输出用`long long`，运算时转换为`__int128` 就没问题了

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const __int128 Maxn=1000000+10,inf=0x3f3f3f3f;
__int128 a[Maxn],f[Maxn],s[Maxn],b[Maxn],c[Maxn];
__int128 n,mod,ans;
inline __int128 read()
{
	__int128 s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
inline __int128 max(__int128 x,__int128 y){return x>y ? x : y;}
inline __int128 min(__int128 x,__int128 y){return x<y ? x : y;}
inline __int128 abss(__int128 x)   //abs不知道用algorithm会不会出锅
{
	if(x>=0)return x;
	return -x;
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	n=read(),mod=read();
	for(__int128 i=1;i<=n;++i)
	a[i]=read();
	b[1]=s[1]=f[1]=a[1];
	for(__int128 i=2;i<=n;++i)
	{
		f[i]=max(f[i-1]+a[i],a[i]);
		b[i]=max(b[i-1],f[i]);
	}
	c[1]=b[1];
	s[1]=b[1]+c[1];
	ans=c[1];
	for(__int128 i=2;i<=n;++i)
	{
		c[i]=s[i-1];
		s[i]=max(s[i-1],c[i]+b[i]);
		ans=max(ans,c[i]);
	}
	if(ans>=0)ans=ans%mod;
	else ans=-(abss(ans)%mod);
	long long haha=ans;
	printf("%lld\n",haha);
	return 0;
}
```

---

## 作者：blankslpl (赞：3)

# P1982 [NOIP2013 普及组] 小朋友的数字
## 解题思路：
- 这道题最后二十分不好拿啊，感觉比赛场上我肯定拿不到。

- 前八十分没什么难度吧特征值和分数都可以 $O(n)$ 算出。
- 最后注意到（然而我并没有注意到 QAQ ）分数在记算的过程中可能会爆 $2^{64}$ 所以得边算边取模，但是取模就无法比较最大值了，所以不能直接取 $\max$ 注意：到从第二个人开始分数是不下降的，所以对于 $i\ge3$。
```cpp
if(b[i-1]>0) c[i]=c[i-1]+b[i-1];
else c[i]=c[i-1];
```
（$b_i$ 为特征值，$c_i$ 为分数），这样就可以运算过程中取模了，因为不需要比较最大值，但最后还得跟 $c_1$ 比较，注意到 $c_1$ 不会超过 $10^9$，所以如果计算中 $c_i$ 超过 $10^9$ 就肯定大于 $c_1$ 了，就可以取模了,而如果没有大于 $10^9$，也就不会爆 $2^{64}$ 所以也不需要取模，这样就拿到了最后二十分，还是得仔细审数据范围啊。
## Ac Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()
template <class T>inline T read()
{
	T r=0,f=1;char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-') f=-1;c=getchar();
	}
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f*r;
}
inline void out(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=1e6+10,K=1e9+100;
int a[N];
int b[N],c[N];
signed main()
{
	int n,mod;
	n=_,mod=_;
	for(int i=1;i<=n;i++) a[i]=_;
	int max=-2*1e15,sum=0;
	for(int i=1;i<=n;i++)
	{
		sum+=a[i];
		max=max>sum?max:sum;
		b[i]=max;
		if(sum<0) sum=0;
	}
	c[1]=b[1];c[2]=b[1]+b[1];
	bool f=0;
	for(int i=3;i<=n;i++)
	{
		if(b[i-1]>0) c[i]=c[i-1]+b[i-1];
		else c[i]=c[i-1];
		if(c[i]>K) f=1,c[i]%=mod;
	}
	if(f) 
	{
		out(c[n]%mod);
		putchar('\n');
	}
	else out((c[1]>c[n]?c[1]:c[n])%mod);
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

动态规划问题。

设 $a_i$ 表示 $i$ 的数字，$q_i$ 表示以 $i$ 结尾的最大子段和，初始化 $q_1=a_1$，转移 $q_i = \max(a_i, q_{i-1}+a_i)$。

设 $t_i$ 表示前 $i$ 个数中以任意数结尾的最大子段和，也是 $i$ 的特征值，初始化 $t_1=a_1$，则 $t_i = \max(t_{i-1}, q_i)$。

设 $f_i$ 表示 $i$ 的分数，题目说第一个人的分数是第一个人的特征值，故初始化 $f_1=t_1$，考虑转移。

对于 $i$ 的分数，可以是前 $i-2$ 个人中分数加上其特征值的最大值，也就是第 $i-1$ 个人的分数，即 $f_{i-1}$，也可以是第 $i-1$ 个人的分数加上其特征值，即 $f_{i-1}+t_i$，$f_i = \max(f_{i-1}, f_{i-1}+t_{i-1})$。

这里要特判 $f_2=f_1+t_1$，否则可能会算成 $f_1$。

结果会很大，并且没办法随时取模，所以要开 ```__int128```。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
long long n, p, a[N], q[N], t[N];
__int128 f[N], ans;
void out (__int128 x) {
	if (x>9)
		out(x/10);
	putchar(x%10+'0');
}
int main () {
	cin >> n >> p;
	for (int i=1; i<=n; ++i)
		cin >> a[i];
	ans=f[1]=t[1]=q[1]=a[1];
	for (int i=2; i<=n; ++i)
		q[i]=max(q[i-1]+a[i], a[i]),
		t[i]=max(t[i-1], q[i]),
		f[i]=(i==2?2*f[1]:max(f[i-1], f[i-1]+t[i-1])),
		ans=max(ans, f[i]);
	if (ans<0)
		cout << '-',
		ans=-ans;
	out(ans%p);
	return 0;
}
```

---

## 作者：kunkun127 (赞：2)

## 思路

- 高精度

  这题一看就觉得不对劲，打开标签果然有**高精度**。

  此时我们有两种选择：  
  
    - 高精度
    - ```int128```
      
  这篇题解选择使用 ```int128``` 方法，读者可自行选择使用。

- 方法：DP

  - 基本表示
    
    共有 $n$ 个人，令 $a_i$ 为每个人手中的数字。  
    令 $s_i$ 为题目中所述的特征值，并且是 $1$ 到 $i$ 中连续所有数字中的最大值。建议先学习 [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115) 中前置知识。
  
    显然，我们还需要一个 $maxn_i$ 来表示 $1$ 至 $i - 1$ 中 $s_i + maxn_i$ 的最大值。

  - DP 转移
 
    令 $f_i$ 为 $i$ 结尾的最大连续数字和，可得 $f_i = \max(a_i, f_{i-1} + a_i)$。
 
      

## 注意事项

  - 如使用 ```int128``` **要专门写输入输出**。
  - 输出时记得对 $p$ 取余。

## 参考代码


```cpp
#include <bits/stdc++.h>
using namespace std;

__int128 a[1000005], dp[1000005], s[1000005], maxn[1000005];

__int128 read()//__int128需要专门写输入和输出
{
    int k = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') k = k * 10 + c - '0', c = getchar();
    return k * f;
}

void out(__int128 x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x < 10) putchar(x + '0');
    else out(x / 10), putchar(x % 10 + '0');
}

int main()
{
	int n, p;
	cin >> n >> p;
	for (int i = 1; i <= n; i++) a[i] = read();
	s[1] = dp[1] = a[1];
	for (int i = 2; i <= n; i++) 
	{
		dp[i] = max(a[i], dp[i - 1] + a[i]);//转移
		s[i] = max(s[i - 1], dp[i]);
	}
	__int128 ans, maxt;
	ans = maxn[1] = s[1];
	maxt = s[1] + maxn[1];
	for (int i = 2; i <= n; i++) 
	{
		maxn[i] = maxt;
		maxt = max(maxt, s[i] + maxn[i]);
		ans = max(ans, maxn[i]);
	}
	out(ans % p);
	return 0;
}
```

---

## 作者：chenhanzheapple (赞：1)

# [传送门](https://www.luogu.com.cn/problem/P1982)

# 思路

模拟即可。

## 特征值的计算

注意到选择数字时必然要选择本人手上的数字，因此只需要考虑选择排在当前小朋友前面的小朋友，而这样选择的最大和就是前面小朋友的特征值，注意还可以只选自己，因此特征值 $f$ 的计算式子为 `f[i] = max(f[i-1]+a[i],a[i]);`。

当然也不难注意到，小朋友的特征值 $f_i$ 即为以 $i$ 结尾的最大子段和，式子同上。

## 分数的计算

### 定义

当前小朋友前面的所有小朋友之前的小朋友的特征最大值加上这个小朋友的分数，形式化的，$\max\limits_{j=1}^{i-1}[(\max\limits_{k=1}^{j} f_k)+sc_j]$，其中 $f$ 表示特征值，$sc$ 表示分数。

### 计算

1. 预处理 $\max\limits_{k=1}^{j} f_k$ 到 $b_i$ 中，式子是 `b[i] = max(f[i],b[i-1]);`。
2. 预处理 $\max\limits_{j=1}^{i-1}[(\max\limits_{k=1}^{j} f_k)+sc_j]$ 到 $maxx$ 中，式子是 `maxx = max(maxx,b[i]+sc[i]);`。
3. 小朋友的分数就是当前的 $maxx$，注意先存分数再更新 $maxx$。

# 注意事项

1. 开 __int128。
2. 注意分数和 $maxx$ 的更新顺序。
3. 初始化

# 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,p;
int a[1000005],b[1000005],f[1000005];
__int128 ans = -1e25;
__int128 sc[1000005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> p;
	for(int i=1;i<=n;i++){
		cin >> a[i];
	}
	memset(b,128,sizeof(b));
	memset(sc,128,sizeof(sc));
	for(int i=1;i<=n;i++){
		f[i] = max(f[i-1]+a[i],a[i]);
		b[i] = max(f[i],b[i-1]);
	}
	ans = sc[1] = b[1];
	__int128 maxx = b[1]+sc[1];
	for(int i=2;i<=n;i++){
		sc[i] = maxx;//注意
		maxx = max(maxx,b[i]+sc[i]);//注意
		ans = max(ans,sc[i]);
	}
	int t = ans%p;
	cout << t;
	return 0;
}

```

# 结语

其实这题是我两年前写的，写题解的时候忘得差不多了，然后就去读了题面，发现这个题面特别难懂，然后就翻了以前的代码才理解，码风可能比较奇怪，就不重写了。

---

## 作者：tssys (赞：1)

## 1.思路
看到这道题，我们发现是连续若干个数最大和，这个被称为[最大子段和](
https://www.luogu.com.cn/problem/P1115#submit)。

所以贴一份最大子段和的代码。
~~~cpp
#include<bits/stdc++.h>
using namespace std;
int t,ans,maxn,a;
int main()
{         
    cin>>t>>ans;
	maxn=ans;
    while(--t)
	{
		cin>>a;
		maxn=max(maxn,0);
		maxn+=a;
		ans=max(ans,maxn);
	}
	cout<<ans;
    return 0;
}
~~~

但是如果这么做的话，每一个人都要转移一次，所以时间复杂度还是平方级的，所以我们要用新的东西——动态规划。

我们定义 $f_i$ 表示以 $i$ 结尾的最大子段和，所以状态转移方程为 $f_i = \max  \{ f_i-1+a_i , a_i \}$。

我们在定义一个 $mx_i$ 表示前 $i$ 个中 $f$ 数组里的最大值，然后按题意理解就行了，记得要开高精。
 

## 不写高精的代码
~~~cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[1000005],mx[1000005],f[1000005];
main()
{
	int n,mod;
	cin>>n>>mod;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	f[1]=a[1];
	mx[1]=a[1];
	for(int i=2;i<=n;i++) 
	{
		f[i]=max(a[i],f[i-1]+a[i]);
		mx[i]=max(mx[i-1],f[i]);
	}
	int sum=mx[1]*2,ans=mx[1];
	for(int i=2;i<=n;i++)//题意模拟 
	{
		ans=max(ans,sum);
		sum=max(sum,mx[i]+sum);
	}
	cout<<ans%mod;
	return 0;
}
~~~

## 写高精的代码 
~~~cpp

#include<bits/stdc++.h>
using namespace std;
int a[1000005];
__int128 mx[1000005],f[1000005];
main()
{
	int n,mod;
	cin>>n>>mod;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	f[1]=a[1];
	mx[1]=a[1];
	for(int i=2;i<=n;i++) 
	{
		f[i]=max(__int128(a[i]),f[i-1]+a[i]);
		mx[i]=max(mx[i-1],f[i]);
	}
	__int128 sum=mx[1]*2,ans=mx[1];
	for(int i=2;i<=n;i++)//题意模拟 
	{
		ans=max(ans,sum);
		sum=max(sum,mx[i]+sum);
	}
	cout<<(long long)(ans%mod);
	return 0;
}

~~~

---

## 作者：kkxacj (赞：1)

#### 题目大意

现在看还是有点饶，所以提一下。

有 $n$ 个人，每个人有一个数字 $a_i$，定义特征值 $b_i$ 为 $1$ 到 $i$ 中任意一段连续数字和的最大值，即所有 $1\le l \le r \le i$ 中 $\sum_{l\le i\le r}{a_i}$ 的最大值。

最后定义分数 $c_i$ 为 $1$ 到 $i-1$ 里 $b_i+c_i$ 的最大值，若 $i=1$ 则 $c_i = b_i$，求 $c_i$ 的最大值模 $p$ 的结果。

#### 思路

容易发现，$b$ 数组的大小是单调不降的，因为算 $b_i$ 时一定包含了算 $b_{i-1}$ 时包含的情况，也就是在求 $b_i$ 时，**只需要知道 $b_{i-1}$ 的值和在 $r=i$ 时连续数字和的最大值即可**，我们另开一个 $f_i$ 表示以 $i$ 结尾最大连续数字和为多少，转移很显然的是 $f_i = \max\left(f_{i-1}+a_i,a_i\right)$，则 $b_i = \max\left(b_{i-1},f_i\right)$。

计算 $c_i$ 就更简单了吧，直接开个数组一直统计最大值即可，还有另一种写法可以看下面的代码。

还有一点值得注意的是，本题的答案上界并不是 $n\times V$ 的，而是 $V + 2\times V + 3\times V + ... + n\times V$，这里 $V$ 是值域，可以开 `int128` 或高精解决。

**code**

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 1e6+10;
int n,mod,a[N],b[N],d[N],c[N],mx,o; 
signed main()
{
	read(n),read(mod);
	for(int i = 1;i <= n;i++) read(a[i]);
	d[1] = b[1] = a[1];
	for(int i = 2;i <= n;i++) d[i] = max(a[i],a[i]+d[i-1]),b[i] = max(b[i-1],d[i]);
	o = c[1] = b[1],mx = c[1]+b[1];
	for(int i = 2;i <= n;i++) c[i] = mx,mx = max(mx,c[i]+b[i]),o = max(o,c[i]);
	/*
	c[1] = b[1],c[2] = b[1]+c[1];
	for(int i = 3;i <= n;i++) c[i] = max(c[i-1],c[i-1]+b[i-1]);
	这样也是对的，只不过要先判断2的情况
	对于其他情况，显然c_{i-1}就是 1到i-2的最大值，在算个c[i-1]+b[i-1]就好了 
	print(max(c[1],c[n])%mod); flush();
	*/
	print(o%mod); flush();
	return 0;
}
```

---

## 作者：chenxinyang2006 (赞：1)

~~这种混乱题出T3，CCF有没有出题水平~~

首先，要求特征值$sp[i]$，$sp[i]$表示区间$[1,i]$的最大字段和，这个直接$dp$套板子就行。

$sp[i]$最高会到$10^6 \times 10^9 = 10 ^ {15}$，要用$long\ long$存

然后再求分数$sc[i]$，$sc[i]$的状态转移挺奇怪的：

$sc[i]=\begin{cases}sp[i]&i=1\\max(sc[j]+sp[j])(1\le j<i)&i>1\end{cases}$ 

如果你直接暴力算的话，可以得到50pts

注意到，大多数的$sc[j] + sp[j]$实际上都是一样的。相对于上一次，每次只会加入一个新的$sc[j] + sp[j]$，所以可以将$sc[j] + sp[j]$存起来，每次更新

还是得注意一下存不存得下$sc[i]$，$sc[i]$最高会到$10^{15} \times 10^9 = 10^{24}$，会爆$long\ long$

可以用高精存，也可以把两个$long\ long$拼起来用

最后问一个$sc[i]$的最大值，这个只要扫一遍求出来就行

$code:$

```cpp
#include <cstdio>
#define ll long long
#define mod 100000000000000000//这里是10^17
#define max(a,b) a>b?a:b
int n,p;
ll dp[1000005],sp[1000005],sum;

struct lint{//自定义了一个类型，可以表示[-10 ^ 30,10 ^ 30]的整数 
    ll p1,p2;
}ans,pre;

lint plus(lint a,ll b){
    lint ans;
    ans.p2 = a.p2 + b;
    ans.p1 = a.p1;
    if(ans.p2 > 1e15){
    	ans.p1 += ans.p2 / mod;
    	ans.p2 = ans.p2 % mod;
    }
    return ans;
}

lint mx(lint a,lint b){
	if(a.p1 > b.p1){
		return a;
	}
	if(b.p1 > a.p1){
		return b;
	}
	if(a.p2 > b.p2){
		return a;
	}
	return b;
}

int main(){
    scanf("%d%d",&n,&p);
    for(int i = 1;i <= n;i++){
    	int x;
    	scanf("%d",&x);
    	if(i == 1){
    		dp[i] = x;
            sum = x;
        }else{
    		dp[i] = max(dp[i - 1] + x,x);
    		sum = max(sum,dp[i]);
    	}
        sp[i] = sum;
    }
    for(int i = 1;i <= n;i++){
    	if(i == 1){
    		ans.p1 = 0;
    		ans.p2 = sp[i];
    		pre.p1 = 0;
    		pre.p2 = sp[i] * 2;
    	}else{
    		ans = mx(ans,pre);
    		pre = mx(pre,plus(pre,sp[i]));
    	}
    }
    printf("%lld\n",((ans.p1 % p) * (mod % p) + (ans.p2 % p)) % p);//如果你写的是(ans.p1 * mod + ans.p2) % p的话,会爆long long
	return 0;
}
```

最后说一句，本题绿题难度感觉偏高

**update on 2020.1.29 修了latex，将逻辑写得更清楚了**

---

## 作者：cath20 (赞：0)

[题目传送锚点](https://www.luogu.com.cn/problem/P1982)

[在博客园食用更佳](https://www.cnblogs.com/cath20/p/18678376)

## 题意

有一列小朋友，他们每个人都有一个值。定义每个小朋友的特征值为祂及祂前面人值的最大子段和。又定义每个小朋友的数字为祂前面人中的一个人的特征值加本身值的最大值。。。

## 思路

把题意用人话说出来即为思路：

1. 先输入每个小朋友的值 $a_i$；
2. 再计算每个小朋友的特征值 $f_i$，其中 $f_i$ 为 $a_1$ 到 $a_i$ 的最大子段和；
3. 最后计算每个小朋友的数字 ${dp}_i$，其中 $dp_i$ 为第 $1$ 到第 $i-1$ 个小朋友中，$a_j+f_j$ 的最大值。

这样就搞定了。你学废了吗？

为防止抄袭，代码就不贴了。~~我绝对不会告诉你，我其实是害怕码风被喷来着。。。~~

---

## 作者：qwer6 (赞：0)

这道题本来的难点在于高精度的，但是在支持 int128 后，这道题直接变成大水题。  
我们可以发现，第 $i$ 个小朋友的特征值就是前 $i$ 个数的最大连续和，具体的，我们先求出前 $i$ 个数，第 $i$ 个数必选的最大连续和 $dp_i$，然后对 $dp_i$ 做一次前缀最值，得到特征值。  
那么剩下的问题就简单了，我们直接一边求分数，一边求前缀最值，然后每一次使用前缀最值加上当前小朋友的特征值，更新最值，最后统计答案即可。
```c++
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int N=1e6+5,inf=9187201950435737472;
int n,p,a[N],dp[N],mark[N],mx,ans=-inf,z=0;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x*f;
}
void write(int x){
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}
signed main(){
	n=read(),p=read();
	for(int i=1;i<=n;i++)a[i]=read();
	dp[1]=a[1];
	for(int i=2;i<=n;i++)dp[i]=max(dp[i-1],z)+a[i];
	for(int i=2;i<=n;i++)dp[i]=max(dp[i],dp[i-1]);
	mark[1]=dp[1];
	mx=dp[1]+mark[1];
	for(int i=2;i<=n;i++){
		mark[i]=mx;
		mx=max(mx,mark[i]+dp[i]);
	}
	for(int i=1;i<=n;i++)ans=max(ans,mark[i]);
	write(ans%p);
}

---

## 作者：chrispang (赞：0)

对于每一个小朋友有三个值：`a[i]` 代表**手上的数字**，`f[i]` 表示**特征值**，`res[i]` 表示**分数**。

`a[i]` 是输入的东西，`f[i]` 其实是求最大子段和，`res[i]` 就是随便搞一下就可以了......

由于这道题会爆 `long long`，所以我们用了神器 `__int128`，就可以像 `int` 一样用了。

```c++
#include <bits/stdc++.h>
#define int __int128 //节约打字时间 
using namespace std;

int read() { //快读 
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') f *= (ch == '-' ? -1 : 1), ch = getchar();
	while(ch >= 48 && ch <= 57) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}

void write(int x) { //快写 
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10);
	putchar(x % 10 ^ 48);
}


int n, p, sum = 0, maxx = -0x3f3f3f3f, a[1000010], f[1000010], res[1000010]; //a表示小朋友手上的数，f表示小朋友的特征值，res表示小朋友的分数 
int abs_(int x) { //手写abs，因为__int128没有abs，直接用会报错 
	if(x >= 0) return x;
	else return -x;
}

signed main() {
	n = read(), p = read();
	for (int i = 1; i <= n; i++)
		a[i] = read();
	for (int i = 1; i <= n; i++) {
		if(sum < 0) sum = 0; //如果小于0，就不和前面的数连接了 
		sum += a[i]; //加上自己 
		maxx = max(maxx, sum); //取最大值 
		f[i] = maxx;
	}
	res[1] = f[1]; //第一个小朋友的分数为自己的特征值 
	maxx = res[1] + f[1]; //等会要取最大值 
	int ans = res[1]; //先记录答案 
	for (int i = 2; i <= n; i++) {
		res[i] = maxx;
		maxx = max(maxx, res[i] + f[i]); //取最大值 
		ans = max(ans, res[i]); //ans也要取最大值 
	}
	write(ans >= 0 ? ans % p : -(abs_(ans) % p)); //最后输出abs(ans) % p 
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：动态规划，高精度运算。

本题比较简单，但是细节较多。主要的思路分以下几点：
- 题目中有一句话需要我们关注：“规定每个小朋友的特征值等于排在他前面（包括他本人）的小朋友中**连续**若干个（**最少有一个**）小朋友手上的数字之和的最大值。”这句话说明本题 需要求这些数字的最大子段和，求完最大子段和我们还要注意，题目要我们求这些最大子段和的最大值，所以我们还要定义 $maxi$ 数组来存最大值。
- 求完最大值之后，我们需要根据题目所给的信息来写。题目中说：分数是这样规定的：第一个小朋友的分数是他的特征值，其它小朋友的分数为排在他前面的所有小朋友中（不包括他本人），小朋友分数加上其特征值的最大值。所以我们需要用循环来求分数。如果 $i=1$ 就说明是第一个小朋友，需要直接赋值，然后求最大值。否则就是普通情况，直接算就行了。
- 注意，本题的数据很大，需要用到别的整数类型。还要注意：需要取模，然后要转成超长整形，不然会编译错误。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int a[maxn];
__int128 dp[maxn];//这里我们用__int128来存
__int128 maxi[maxn];
long long n,p;
signed main()
{
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
  //边界条件，第1个数的最大子段和为1
	dp[1]=a[1];
	maxi[1]=a[1];//最大值直接赋值即可
	for(int i=2;i<=n;i++)
	{
		dp[i]=max(dp[i-1]+a[i],(__int128)a[i]);
		maxi[i]=max(maxi[i-1],dp[i]);
	}
	__int128 val=0;
	__int128 ans=0;
	for(int i=1;i<=n;i++)
	{
		if(i==1)
		{
			val+=a[i]*2;
			ans+=maxi[i];
		}
		else
		{
			ans=max(ans,val);
			val=max(val,val+maxi[i]);
		}
	}
	cout<<(long long)(ans%p);//注意括号，一个都不能少，转成long long更合适
	return 0;
}
```

---


# 奇妙的汽车

## 题目描述

你有着一辆奇妙的汽车，这辆汽车有着自动加速的功能。打个比方吧，第1天你驾驶着它可以行驶a路程，那么第2天你可以让它所走的路程增加到第1天的2~9倍（必须是其中一个整数），也就是2a~9a，第3天它所行驶的路程就将达到第2天的2~9倍……也就是说，这辆车在第i天所走的路程一定是第i-1天的2~9倍，而且还必须是它的整数倍。

现在你迫不及待地开着这辆车要从A城市出发到B城市旅游，顺便在路上展示一下这辆旷世奇车。你已经知道你需要行驶的里程S，现在请你合理安排第1天的里程和接下来每天需要增加路程的倍数，好让你能够在最短的天数内，恰好到达B城市。

不过，因为你想要好好展示一下你的车，而且也是为了交通安全，你被要求至少要花2天时间，如果不能找到这样的方案请输出-1。


## 说明/提示

数据规模

对于30%数据，有 $S\leqslant 100$；

对于70%数据，有 $S\leqslant 10^7$；

对于100%数据，有 $9<S\leqslant 10^8$。


## 样例 #1

### 输入

```
15121```

### 输出

```
-1```

## 样例 #2

### 输入

```
571```

### 输出

```
5```

# 题解

## 作者：风羽跃 (赞：20)

本蒟蒻不才，实在想不出dp，就来推一下这道题的式子：

设我们第一天跑了a，第二天是第一天的k1倍，第三天是第二天的k2倍……以此类推。

### 那我们就以4天为例，推一下式子：

总路程 s = a + k1a + k2k1a + k3k2k1a 

           = a(1 + k1 + k2k1 + k3k2k1 )
           
           = a(1 + k1(1 + k2 + k3k2))
           
           = a(1 + k1(1 + k2(1 + k3)))
           
### 恍然大悟，那我们就可以先把 a 约掉，再递归求出 k1,k2,k3……的值。

然后我们可以发现，总路程 s 一定能被 a 整除。

所以就用试除法求出 s 的所有因数，每个因数都做一遍dfs，求一个最小值就行了！

但是题目中有一个要求：不能1天到达。

那样的话判断一下a不等于n就行了！

AC代码加注释：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>

#define INF 0x7fffffff

using namespace std;

int n,ans=INF;

inline void dfs(int dep,int num)
{
	if(!num){
        //边界条件
		ans=min(ans,dep);
		return ;
	}
	num--;//把式子里面的1减掉
	for(int i=2;i<=9;i++){//枚举k
		if(!(num%i)){//判断整除
			dfs(dep+1,num/i);
		}
	}
}

int main()
{
	cin>>n;
	for(int i=1;i<=sqrt(n);i++){
    	//因数一定是成对出现，所以我们枚举的a实际上是i和n/i
		if(!(n%i)){判断整除
			if(n/i!=n) dfs(0,i);//n/(n/i)=i
			if(i!=n) dfs(0,n/i);//n/i
		}
	}
	if(ans!=INF) cout<<ans<<endl;//判断能否到达
	else cout<<-1<<endl;
	return 0;
}
```


---

## 作者：操作！ (赞：8)

[本题思路](https://www.luogu.org/discuss/show/32216)

在此感谢大佬yuanyunzhe的思路

本题不需要有多麻烦

可以先枚举路程（即s）的因数

再进入深搜递归

递归中暴力枚举（咳咳咳）

深搜程序如下（本AC程序重点）：


```cpp
void car(int x,int s)
{
	if(s==0)
	{
		if(x<2)
		{
			bo=true;//标志（关系到是否需要输出-1）
		}
		else
		{
			minn=min(minn,x);
			bo=false;//重置，说明不需输出-1；
		}
	}
	s-=1;
	for(int i=2;i<=9;i++)
	{
		if(s%i==0)
		{
			car(x+1,s/i);//再来~~
		}
	}
}
```

AC程序如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int minn=1e8,s;
bool bo;
void car(int x,int s)
{
	if(s==0)
	{
		if(x<2)
		{
			bo=true;
		}
		else
		{
			minn=min(minn,x);
			bo=false;
		}
	}
	s-=1;
	for(int i=2;i<=9;i++)
	{
		if(s%i==0)
		{
			car(x+1,s/i);
		}
	}
}
int main()
{
	cin>>s;
	for(int i=1;i<=sqrt(s);i++)
	{
		if(s%i==0)
		{
	    	car(0,i);
	    	car(0,s/i);	
		}
	}
	if(!bo&&minn!=1e8)cout<<minn;
	else cout<<-1;
	return 0;//完成！！
}
```
多多关照！！





---

## 作者：MyukiyoMekya (赞：7)

先转换一下题意：

给定 $S$ ，求一组 $a+a\times b_1+a\times b_1\times b_2+ \cdots=S$ ，并且 $2\le b_i \le 9$ ，求最少要多少个 $b$ （当然最后要+1

我们先把 $a$ 提出来： $a\times (1+b_1+b_1\times b_2 + \cdots)=S$

然后把 $a$ 移向移过去 $1+b_1+b_1\times b_2+b_1\times b_2 \times b_3+ \cdots=\frac Sa$

这里要求 $\frac Sa$ 是整数，所以枚举 $S$ 的因子就可以得到 $a$ ，这里要注意，$a\ne S$，否则的话可以一天完成，不符合题意，这里枚举的时候也要注意不要忘了枚举 $a=1$ 的情况

然后我们来看这个柿子：
$$
1+b_1+b_1\times b_2+b_1\times b_2 \times b_3+ \cdots
$$
提出 $b_1$ （乘法分配律）：
$$
1+b_1\times (1+b_2+b_2 \times b_3+ \cdots
$$
然后再提出 $b_2$：
$$
1+b_1\times (1+b_2\times (1+b_3+ \cdots
$$
然后你会发现这个柿子大概是这么个结构：
$$
1+b_1\times (1+b_2\times (1+b_3\times (1+b_4\times (1+b_5\times (
$$
那么我们就dfs搜出每个 $\frac Sa$ 最少能用几个 $b_i$ 算出，那就先减去1然后再枚举 $b_1$ ，因为要求是整数，所以又可以枚举因子了，然后除以 $b_1$ 进到下一层递归再 -1枚举 $b_2$ ...（详见代码）

因为每个 $b_i$ 至少是 2 ，所以 $\frac Sa$ 每进入一层递归就会至少缩小到原来的一半，所以这个复杂度是 $O(\log \frac Sa)$ 的，但是还有每层枚举的次数，所以还要乘上8

所以总时间复杂度就是 $O(\sqrt S \times \log S\times 8)$

代码：

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#include <bits/stdc++.h>
#define reg register
#define int long long
using namespace std;
const int inf=0x3f3f3f3f3f3f3f3f;
template <class t> inline void read(t &s)
{
	s=0;
	reg int f=1;
	reg char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
		s=(s<<3)+(s<<1)+(c^48),c=getchar();
	s*=f;
	return;
}
int n;
inline int dfs(int u)
{
	if(u<=0)
	{
		if(!u)
			return 0;
		return inf;
	}
	--u;
	reg int res=inf;
	for(int i=2;i<=9;++i)
		if(!(u%i))
			res=min(res,dfs(u/i)+1);
	return res;
}
signed main(void)
{
	cin>>n;
	reg int lim=sqrt(n);
	reg int ans=inf;
	for(int i=2;i<=lim;++i)
		if(!(n%i))
			ans=min(ans,dfs(i));
	ans=min(ans,dfs(n));
	if(ans==inf)
		puts("-1");
	else
		printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：lw21144 (赞：4)

**啥也不用说了，直接爆搜吧**
```cpp
#include<math.h>
#include<stdio.h>
int S,ans=0x7f7f7f7f;
#define min(x,y) (x)<(y)?(x):(y)
inline int dfs(int x,int day,int last){
	if(x>S) return 1e9;
	if(x==S) return day;
	int sum=0x3f3f3f3f;
	for(int i=2;i<=9;i++){
		sum=min(sum,dfs(x+last*i,day+1,last*i));
	}
	return sum;
}
signed main(){
	scanf("%d",&S);
	for(int i=1;i<=sqrt(S);i++){
		ans=min(ans,dfs(i,1,i));
	}
	printf("%d",ans>=1e9?-1:ans);
    return 0;
} 
```
~~电脑：危~~


------------


~~众所周知~~暴力肯定是过不了的

思考一下，为什么暴力过不了呢？

原因就在于，上面代码在搜的时候是从 $1$ 往上搜，这样就会有许多当前走的距离大于总距离 $S$ 的无用情况（就是走过了）

这题的正解也是用 dfs，所以我们要考虑剪枝

看到题目，设第一天走的路程为 $a$，第 $i$ 天乘的倍数为 $v_i$，总路程为 $S$，那么就有:

$$S=a+v_1 \times a+v_2 \times v_1 \times a+v_3 \times v_2 \times v_1 \times a+ \cdots +v_n \times v_n-1 \times \cdots \times v_1$$

我们用~~小学数学知识~~合并一下，可得：

$$S=a \times (1+v_1 \times (1+v_2 \times (1+v_3 \times \cdots \times (1+v_n)))\cdots)$$

在这个式子中，我们可以看出：$S$ 是 $a$ 的倍数，$\frac{S}{a}-1$ 是 $v_1$ 的倍数，$\frac{\frac{S}{a}-1}{v_1}-1$ 是 $v_2$ 的倍数，以此类推。

所以，我们采用倒着搜的方式，并且要优先排除不可能到达终点 $S$ 的情况（也就是减去一后无法整除的情况）

时间复杂度为 $O(\sqrt{S} \times \log S \times 8)=O(\sqrt{S} \times \log S)$

------------

**code**
```cpp
#include<math.h>
#include<stdio.h>
#include<algorithm>
#define int long long
int S=0,ans=0x3f3f3f3f;
void dfs(int step,int sum){
	if(sum==0){ //记录答案最优值 
		ans=std::min(ans,step);
		return; //直接返回
	}
	sum--; //减去上面式子中的1
	for(int i=2;i<=9;i++){
		if(sum%i==0){ //能整除才可以搜下去，排除掉不可能的情况
			dfs(step+1,sum/i);
		}
	}
	return; //返回
}
signed main(){
	scanf("%d",&S); //读入 S 
	for(int i=1;i<=sqrt(S);i++){
		/*
		  为什么这里只用搜到 sqrt(S) 就行呢？
          因为因数出现都是成双成对的(就比如 12=3*4，3 和 4 都是 12 的因数)
		  所以当我们搜了 i 时，也就相当于把 S/i 搜掉了 
        */
		if(S%i==0&&i!=1) dfs(0,i);
		if(S%i==0){ //能整除才能继续搜下去 
			if(S%(S/i)==0&&S/i!=1) dfs(0,S/i);
		}
	}
	printf("%d",ans>2e9?-1:ans); //输出答案 
	return 0; //完美结束 
} 
```


---

## 作者：AOTO (赞：3)

# 震惊！dfs过了!
### 这题的标题写的是dp，但是本蒟蒻认为，这题与dp没有多大关系。看一眼题目，可以发现，搜索可以做呢！于是乎，有了这个程序。
### 此程序思路十分简单，其实参考了讨论里大佬的[思路](https://www.luogu.org/discuss/show/32216)，把s除了本身的所有因数都求出来，每一个因数除s都做一遍dfs（深搜），最后输出最小的答案即可。
### 深搜就是将s除以（s除了本身的所有因数）（因为天数至少为1并且第一天可以是任意数）都倒着-1再/（2~9），直到变成0，此时的x就是所需要的天数，求一个最小值后输出。
# 蒟蒻代码：
```
#include<bits/stdc++.h>  //万能头
using namespace std;
int minn=1e8,s;
bool bo;
void car(int x,int s)
{
    if(s==0)
    {
	    minn=min(minn,x);
        bo=false;
    }
    s-=1;    //倒着做的话需要-1，因为把前一天的减掉
    for(int i=2;i<=9;i++)  //每天的2~9一共8种情况
    {
        if(s%i==0)
        {
            car(x+1,s/i);  //天数加一，倒着还原
        }
    }
}
int main()
{
    cin>>s;
    car(0,s);  //将因数为本身去掉，这个为s/1的情况
    for(int i=2;i<=trunc(sqrt(s));i++)//将s的每个因数做一遍
    {
    	if(s%i==0)
    	{
    		car(0,s/i);
    		car(0,i);
        }
    }
    if(minn!=1e8)cout<<minn;  //输出
    else cout<<-1;
    return 0;
}
```

---

## 作者：金霸王电池 (赞：2)

~~为什么我只会用 DFS 做这道题啊~~

观察发现，每一天行驶的路程都是 $a$ 的倍数，那么 $a$ 就是 $S$ 的约数。列出 $S$ 的所有约数（n 除外，因为至少开两天的车），枚举 $a$，$S$ 再除以 $a$。至此，问题转化为：第一天行驶一公里，后面每一天行驶的路程是到前一天的 2~9 倍，求最快几天到达。

------------
对于这个问题，考虑 DFS 。设 $dfs(n)$ 表示行驶 n 公里至少多少天，则 $dfs(n)=\min_{2\leq i\leq 9}dfs(\frac{n}{i})$。

边界条件：$dfs(1)=1$。

AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,a[1000000],top,minn=1e8;
int dfs(int t){//搜索
	if(t==1)return 1;//边界条件
	int k=t-1,minx=1e8;
	for(int i=2;i<=9;i++)
		if(k%i==0)
			if(dfs(k/i)!=-1)minx=min(minx,dfs(k/i)+1);//取 min
	if(minx==1e8)return -1;//到达不了
	return minx;
}
int main(){
	cin>>s;
	for(int i=1;i<=sqrt(s);i++)
		if(s%i==0){
			top++;
			a[top]=i;
		}//所有因子
	for(int i=2;i<=top;i++)a[2*top+1-i]=s/a[i];
	top=top*2-1;
	for(int i=1;i<=top;i++){
		s/=a[i];
		if(dfs(s)!=-1)minn=min(minn,dfs(s));//依次枚举
		s*=a[i];
	}
	if(minn==1e8)cout<<-1;//到达不了
	else cout<<minn;
	return 0;
} 
```


---

## 作者：EDqwq (赞：1)

### 思路

我们来拆一下柿子：

设第一天走的路程为 $a$ ，第 i 天乘的倍数为 $x_i$ ，那么可以得到柿子：

$$a + x_1 \times a + x_2 \times x_1 \times a + \cdots + a \times x_n \times x_{n - 1} \cdots \times x_1$$

我们简化一下这个柿子：

$$a \times (1 + x_1 + x_1 \times x_2 + x_1 \times x_2 \times x_3 + \cdots + x_1 \times x_2 \times \cdots \times x_n)$$

我们继续把这些可以合并的项合并在一起：

$$a \times (1 + x_1 (1 + x_2 (1 + x_3 \times \cdots (1 + x_n)$$

由于我们知道，每一个 $x_i$ 都一定是2 - 9的数，所以我们枚举 a ，从1 - $\sqrt n$ ，对于每一个枚举到的数，我们可以得到两个可能的 a 值（ n 除以枚举的数得到另一个数）。

然后用这个值，去做 dfs ，排除一天到达的情况即可。

***

### 代码：

```cpp
#include<bits/stdc++.h>

#define int long long
#define mem(x) memset(x,0,sizeof(x))

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n;
int ans = 2147483647;
int sqrtt;

void dfs(int dep,int now){
	if(now == 0){
		ans = min(ans,dep);
		return ;
	}
	now --;
	for(int i = 2;i <= 9;i ++){
		if(now % i == 0){
			dfs(dep + 1,now / i);
		}
	}
}

signed main(){
	cin>>n;
	sqrtt = sqrt(n);
	for(int i = 1;i <= sqrtt;i ++){
		if(n % i == 0 && i != 1)dfs(0,i);
		if(n % i == 0){
			if(n % (n / i) == 0 && n / i != 1)dfs(0,n / i);
		}
	}
	ans == 2147483647 ? cout<<-1 : cout<<ans;
	return 0;
}
```

---


# 烛光晚餐

## 题目背景

小明准备请小红去一家咖啡厅，共进烛光晚餐。小红高兴地和他一起去了咖啡厅。

## 题目描述

小红说：“小明，你点菜吧。”小明看到菜单上有 $N$ 道菜，每道菜的价格是 $C_i$。小明对每道菜的喜爱程度是 $X_i$，小红对每道菜的喜爱程度是 $Y_i$。（喜爱程度可能为负数）（小明：以我对她的了解，我给你的数据不会错的）

小明带了 $V$ 元钱，他点的菜的总价格不能超过 $V$（小明：当然得我请客啦，显得我大方。）

小明希望让小红吃得开心，所以当然要让她的总喜爱程度尽量大。当然，小明也要考虑自己的感受，点的所有菜的总喜爱程度需要大于等于 $0$。（小明：要是我吃得不好，她看见我会难过的）

请你帮小明写一个程序，计算出他的总喜爱程度大于等于 $0$ 的前提下，小红的喜爱程度的最大值。（小明：你的程序一定要靠谱啊，我得给她一个好印象）



## 说明/提示


对于 $10\%$ 的数据，$N\leq10$，$V\leq50$。

对于 $30\%$ 的数据，$X_i,Y_i\geq0$.

对于 $100\%$ 的数据，$N\leq100$，$V\leq500$，$|X_i|\leq5$，$|Y_i|\leq10^3$.


## 样例 #1

### 输入

```
4 10
5 -1 3
2 2 2
11 -5 100
3 -3 10
```

### 输出

```
5```

# 题解

## 作者：zzy_123 (赞：13)

//本题可以看做一个模板题吧(我认为),因为许多类似题的方法可以按照本题来。如(P2340)
都需要按照题意转化为背包问题。
这里也是如此，先把小明的喜爱度与钱转化为背包来储存小红喜爱度的最大值。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[610][600],n,m,j,k,l;//f数组代表花费n元与小明喜爱程度为m使小红获得喜爱度的最大值
//也可以不压缩(已经压缩了一维)，应该都会01背包的压缩吧。
//因为小明的喜爱度可以为负数，所以根据数据把数组开大一倍。（本应该开1000以上的但是忘记开到那么大就AC了。。。只把第2维开到了600）。假设数组的300位为0,299为-1,301为1，就可以把负数的情况弄到数组里面去了。
struct zzy
{
	int ci,xi,yi;
}sum[1000];
void cot()
{
	int a,b,c,d,e;
	for(a=1;a<=m;a++)
	{
		for(b=0;b<=10;b++)
		cout<<f[a][b]<<" ";cout<<endl;
	}cout<<endl;
}
int main()
{
	//f[n][m]=max f[n-j][m-k]+sum[t].yi,f[n][m]; 
    //状态转移方程
	int a,b,c,d,e;
	cin>>n>>m;
	for(a=1;a<=n;a++)
	cin>>sum[a].ci>>sum[a].xi>>sum[a].yi;
	for(a=1;a<=n;a++)
	{
		for(b=m;b>=sum[a].ci;b--)
		{
        //根据这道菜小明的喜爱度，因为把数组压缩了一维，所以要倒退，所以正数与负数的退发不一样。
			if(sum[a].xi>0)
			{
				for(c=600;c-sum[a].xi>=0;c--)
				{
                //因为在考虑时有许多情况是不可能到达地，所以不能转移，不然会爆错，也就是考虑初始边界情况。
					if(f[b-sum[a].ci][c-sum[a].xi]==0&&c!=sum[a].xi+300)continue;
					else
					f[b][c]=max(f[b][c],f[b-sum[a].ci][c-sum[a].xi]+sum[a].yi);
				}
			}
			else
			{
				for(c=0;c<=600+sum[a].xi;c++)
				{
					if(f[b-sum[a].ci][c-sum[a].xi]==0&&300-c!=abs(sum[a].xi))continue;
					else
					{
						f[b][c]=max(f[b][c],f[b-sum[a].ci][c-sum[a].xi]+sum[a].yi);
					}
				}
			}
		}
	}c=0;
	for(a=1;a<=m;a++)
	{
		for(b=300;b<=600;b++)c=max(c,f[a][b]);
	}//取最后小明喜爱度大于0的值。
	if(c>=0)cout<<c;
	else cout<<-1;
}
```

---

## 作者：VioletIsMyLove (赞：10)

这道题拿到手就是一个背包，但是要想想怎么处理。

要求是花钱数少于 $V$ 且小明的喜好程度大于等于 $0$。

我们看数据范围发现 $V$ 小于 $500$，且小明的喜好程度只会在 $-500$ 和 $500$ 之间波动，那么数组果断开 $f[505][1005]$，毕竟下标不能为负数就整体右移 $500$ 了。

设置 $f[i][j]$ 表示小明花了 $j$ 块钱之后自己的总喜好程度为 $j$ 时小红的总喜好程度的最大值。

那么转移方程就是 $f[i][j]=max(f[i][j],f[i-c][j-x]$，但是实际为了方便不是这么写的，具体看代码。

再就是这道题有个小坑，就是小红的喜好程度是不可能为负数的，因为如果小明不给小红吃东西，那么小红的喜好程度就是 $0$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,v,c,x,y,ans;
int f[505][1005];
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main(){
	memset(f,128,sizeof f);
	n=read();v=read();f[0][500]=0;
	for(int i=1;i<=n;i++){
		c=read();x=read();y=read();
		for(int j=v-c;j>=0;j--)for(int k=1000;k>=0;k--)if(f[j][k]!=-2139062144)f[j+c][k+x]=max(f[j+c][k+x],f[j][k]+y);
	}
	for(int i=0;i<=v;i++)
	for(int j=500;j<=1000;j++)ans=max(ans,f[i][j]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：BigJoker (赞：6)

# 0x00 思路

本题初步上看起来是一个背包问题，但是有两个条件限制，所以不难想到二维费用背包。

# 0x01 确定状态

此题状态不难想到，定义 $dp[j][k]$ 表示在花费 $j$ 元钱的情况下，小明的喜爱程度为 $k$ 的时候，小红最高的喜爱程度是多少。

# 0x02 调整状态

因为喜爱程度又可能是负数，所以我们需要对 $dp[j][k]$ 中的 $k$ 进行调整。观察数据范围，小明的喜爱程度的最小值就是 $-500$，通过 $n$ 的最大值乘上 $x_i$ 的最小值就可以得到。同理也可以得到小明喜爱程度的最大值就是 $500$，所以我们在状态转移时，为了让数组不越界，需要将 $k$ 这一维整体加上 $500$。

# 0x03 状态转移

此题状态转移如果不考虑负数，那就是：

```cpp
dp[j][k]=max(dp[j][k],dp[j-c][k-x]+y);
```
如果对状态转移非负数情况没有弄懂，可以去看一下[P1048采药](https://www.luogu.com.cn/problem/P1048)。

但是此题有负数的情况，但是根据我们上一步所说，将 $k$
这一维加上 $500$ 即可，如下：

```cpp
dp[j][k+500]=max(dp[j][k+500],dp[j-c][k-x+500]+y);
```

状态转移完毕。

# 0x04 输出答案

有了前面点的分析，这一步就不难了，首先将初始值 $ans$ 设为 $-1$，然后开始循环查找，第一层先枚举背包容量 $j$，第二层枚举小明的喜爱程度 $k$，注意 $k$ 需要加上 $500$，然后取最大值即可，当然如果取不到最大值，就会如题意输出 $-1$。

# 0x05 代码

```cpp
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define dep(i,r,l) for(int i=r;i>=l;i--)
using namespace std;
const int N=1e3+5;
int n,v,dp[1005][1005];
struct node{
	int c,x,y;
}a[N];
int main(){
	scanf("%d %d",&n,&v);
	rep(i,1,n) scanf("%d %d %d",&a[i].c,&a[i].x,&a[i].y);
	memset(dp,-0x7f,sizeof(dp));
	dp[0][500]=0;
	rep(i,1,n)
		dep(j,v,a[i].c)
			dep(k,500,-500)
                if(k-a[i].x<=500 && k-a[i].x>=-500)
                    dp[j][k+500]=max(dp[j][k+500],dp[j-a[i].c][k-a[i].x+500]+a[i].y);
    int ans=-1;
    rep(i,0,v)
    	rep(j,0,500)
    		ans=max(ans,dp[i][j+500]);
    printf("%d",ans);
	return 0;
}
```


---

## 作者：zhyh (赞：6)

带负数体积的二维01背包。其实除了数组下标取值可以小于0之外和正常的就没区别了。所以只要处理一下下标越界的问题。

我们不妨让该取值整体“平移”$T$个单位，此时“零点”就是$T$，在转移时改一下，方程也就是：

$$dp[i][j][k+T]=max(dp[i-1][j][k+T],dp[i-1][j-v[i]][k-vv[i]+T]+w[i])$$

把$dp[0][0][0+T]$设为0，最后在所有大等于0的$k$中找最大就可以了。

代码：
```cpp
#include <cstdio>
#define rep(x,y,z) for(int x=y; x<=z; x++)
#define max(x,y) (x>y?x:y)
#define T 1000
#define inf 1e8
using namespace std;
    int N,V,v,vv,w,dp[2][505][2005],ans;
int main()
{
    scanf("%d%d", &N, &V);
    rep(j,0,V) rep(k,-600,600) dp[0][j][k+T] = dp[1][j][k+T] = -inf;
    dp[0][0][T] = 0;
    rep(i,1,N) {
        scanf("%d%d%d", &v, &vv, &w);
        rep(j,0,V) rep(k,-500,500) {
            dp[i&1][j][k+T] = max(dp[i&1][j][k+T], dp[i&1^1][j][k+T]);
            if (j >= v) {
                dp[i&1][j][k+T] = max(dp[i&1][j][k+T], dp[i&1^1][j-v][k-vv+T]+w);
            }
        }
    }
    rep(j,0,V) rep(k,0,500) ans = max(ans, dp[N&1][j][k+T]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：yhk1001 (赞：4)

这是一道多维01背包题。设 $dp_{j,k}$ 表示有 $j$ 元钱，小明总喜爱程度是 $k$ 的情况下小红喜爱程度的最大值。状态转移方程为：
$$dp_{j,k} = \max(dp_{j,k},dp_{j - c_i,k - x_i} + y_i)$$

此题中小明的喜爱程度可能为负数，为避免数组越界，可以将数组“平移”一段距离 $t$，让 0 对应 $t$ 、1 对应 $t + 1$ 、-1 对应 $t - 1$，以此类推。方程修改为：
$$dp_{j,k + t} = \max(dp_{j,k + t},dp_{j - c_i,k - x_i + t} + y_i)$$

另外在更新 $dp$ 数组时要判断 $x_i$ 的正负，大于等于 0 则倒序枚举，反之则倒序枚举。

做完这题可以再做一下 [P2340](https://www.luogu.com.cn/problem/P2340)，方法和本题类似。

[AC](https://www.luogu.com.cn/record/40516503)代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int x[105],y[105],c[105];
int dp[505][1005];

int main()
{
	int n,v;
	cin >> n >> v;
	for (int i = 1;i <= n;i++)
	{
		cin >> c[i] >> x[i] >> y[i];
	}
	memset(dp,-0x3f,sizeof(dp));//初始化
	dp[0][500] = 0;//平移
	for (int i = 1;i <= n;i++)
	{
		for (int j = v;j >= c[i];j--)
		{
			if (x[i] >= 0)//判断枚举顺序
			{
				for (int k = 1000;k >= x[i];k--)
				{
					dp[j][k] = max(dp[j][k],dp[j - c[i]][k - x[i]] + y[i]);
				}
			}
			else
			{
				for (int k = 0;k <= 1000 + x[i];k++)
				{
					dp[j][k] = max(dp[j][k],dp[j - c[i]][k - x[i]] + y[i]);
				}
			}
		}
	}
	int ans = -1;
	for (int i = 0;i <= v;i++)
	{
		for (int j = 500;j <= 1000;j++)
		{
			ans = max(ans,dp[i][j]);
		}
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：ironwheel (赞：3)

## P2079 烛光晚餐

[题目传送门](https://www.luogu.org/problemnew/show/P2079)

## tips:

#### ~~1.dp~~

#### 2.小明喜爱度是负数

#### 3.分类讨论

#### 4.[P1048](https://www.luogu.org/problemnew/show/P1048)

提示给的够多了，到这里这题应该非常简单了

所以我是选了一道辣鸡题


我们设$f_{i,j}$为经费为$ i $时，小明的喜爱度为$ i - (N >> 1) $时，小红喜爱度的最大值

得转移式：

$$ f_{j,k} = max(f_{j,k}, f_{j-cost[i],k-ming[i]} + hong[i]) $$


其实就是多加一维的01背包

再按小明喜爱度的正负分类讨论求解就完事了

```cpp
#include<bits/stdc++.h>

using namespace std;

int cost[110], hong[110], Min[110], tql[505][1020], maxcost = -1e9;

int main(){
    int n, v;
    cin >> n >> v;
    for(int i = 1; i <= n; i++)
        cin >> cost[i] >> hong[i] >> Min[i];
    memset(tql, -0x3f, sizeof(tql));
    for(int i = 0; i <= v; i++)
        tql[i][505] = 0;
    for(int i = 1; i <= n; i++){
        for(int j = v; j >= cost[i]; j--){
            if(hong[i] > 0)
                for(int k = 1010; k >= hong[i]; k--)
                    tql[j][k] = max(tql[j][k], tql[j - cost[i]][k - hong[i]] + Min[i]);
            else
                for(int k = 0; k <= 1010 + hong[i]; k++)
                    tql[j][k] = max(tql[j][k], tql[j - cost[i]][k - hong[i]] + Min[i]);
        }
    }
    for(int i = 0; i <= v; i++)
        for(int j = 505; j <= 1010; j++)
            maxcost = max(maxcost, tql[i][j]);
    cout << maxcost;
}
```


---

## 作者：早右昕 (赞：2)

有负数范围的多维01背包问题，要注意细节（如初始化，最终更新答案等）。另外，分情况讨论dp会优化掉许多空间，lmt可以写作常量也可以直接对该组输入数据算（这样应该会优化时间,~~可是我懒~~）。

看代码吧：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <set>
#include <queue>
#include <string>
#include <vector>
using namespace std;

const int lmt=5*100*2;
int n,wlt,cost[101],ming[101],red[101];
int ans=-1,dp[501][lmt+10];
int main() {
	scanf("%d%d",&n,&wlt);
	for (int i=1; i<=n; i++) {
		scanf ("%d%d%d",&cost[i],&ming[i],&red[i]);
	}
	memset(dp,-0x3f,sizeof dp);
	for (int j=wlt; j>=0; j--) {
		dp[j][lmt>>1]=0;
	}
	for (int i=1; i<=n; i++) {
		for (int j=wlt; j>=cost[i]; j--) {
			if (ming[i]>0) {//分类
				for (int k=lmt; k>=ming[i]; k--) {
					dp[j][k]=max(dp[j][k],dp[j-cost[i]][k-ming[i]]+red[i]);
				}
			} else {
				for (int k=0; k<=lmt+ming[i]; k++) {
					dp[j][k]=max(dp[j][k],dp[j-cost[i]][k-ming[i]]+red[i]);
				}
			}
		}
	}
	for (int j=wlt; j>=0; j--) {//查找答案
		for (int k=(lmt>>1); k<=lmt; k++) {
			ans=max(ans,dp[j][k]);
		}
	}
	printf("%d\n",ans);
	return  0;
}


```

---

## 作者：E1_de5truct0r (赞：1)

背包模板题。

## 思路

观察到 $n,V,\sum x_i$ 都比较小，而 $y_i$ 比较大。所以考虑把 $x$ 存在状态里，$y$ 存在 dp 存储的值里。

令 $dp_{i,j,k}$ 表示前 $i$ 个菜，还有 $j$ 的钱，小明的满意值为 $k$ 的时候，小红满意度的最大值。

转移显然：

$$dp_{i,j,k}=\max\{dp_{i,j,k},dp_{i-1,j-c_i,k-x_i}+y_i\}$$

复杂度 $O(nV \cdot \sum x_i)$，由于 $|x_i| \leq 5,|\sum x_i| \leq 500$ 所以能过。

## 代码

注意到 $k$ 那一维转移没法直接做，因为有可能会在转移的时候用到已经转移的 dp 值，会有后效性。所以，我们单独开一个 `tmp` 记录答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

int dp[505][1005],tmp[1005],c[105],x[105],y[105];

int main(){
	int n,V; cin>>n>>V;
	for(int i=1;i<=n;i++) cin>>c[i]>>x[i]>>y[i];
	
	memset(dp,-0x3f,sizeof(dp));
	for(int j=0;j<=V;j++) dp[j][500]=0;
	
	int ans=-1e9;
	
	for(int i=1;i<=n;i++){
		for(int j=V;j>=c[i];j--){
			memset(tmp,-0x3f,sizeof(tmp));
			for(int k=1000;k>=0;k--)
				if(k-x[i]<=1000 && k-x[i]>=0)
					tmp[k]=dp[j-c[i]][k-x[i]]+y[i];
			for(int k=0;k<=1000;k++) dp[j][k]=max(dp[j][k],tmp[k]);
//			for(int k=498;k<=502;k++) cout<<dp[j][k]<<" ";
//			cout<<endl;
		}
		for(int j=500;j<=1000;j++) ans=max(ans,dp[V][j]);
	}
	
	cout<<ans;
	return 0;
} 
```

---

## 作者：koreyoshi_lemon (赞：1)

本题是一个背包模板题，建议降为绿题。。

与标准的背包相比，本题还须关注小明的好感度，与价格共同构成状态。于是，想到构建二维的数组，存储这两个状态：

用 $f_{i,j}$ 表示小明好感度为 $i$，且花费 $j$ 元时小红最大的喜爱程度。那么初始状态：$f_{0,0}=0$ ，目标：$\max_{i\in N,j\in[0,v]}(f_{i,j})$

代码实现并不能这样写，而需确定一个较大值作为 "$0$"，以防止小明好感度为负数导致程序 RE 

转移方程： $f_{j,k}=f_{j-x_i,k-c_i}+y_i$

但是转移时有所不同。背包若要省略第一维，就需要倒序枚举体积，由于小鸣的好感度可能为负，需要根据小明好感度的符号来确定枚举顺序。于是可以先对物品按照小明的好感度降序排序，在好感度为正数时倒序枚举，为负数时正序枚举，代码实现如下：

```
#include <bits/stdc++.h>
using namespace std;
const int N=1e2+7;
const int V=5e2+7;
int n,v,f[2*V][V],ans;
struct object{
	int c,x,y;
	inline void input()	{
		scanf("%d%d%d",&c,&x,&y);
		return;
	}
}a[N];
inline bool cmp(object x,object y){return x.x>y.x;}
int main(void)
{
	memset(f,-0x3f,sizeof(f));
	f[V][0]=0;
	scanf("%d%d",&n,&v);
	for(int i=1;i<=n;i++)
		a[i].input();
	sort(a+1,a+n+1,cmp);
	int pos=1;
	while(a[pos].x>0&&pos<=n) pos++;
	pos--;
	for(int i=1;i<=pos;i++)
		for(int j=2*V-1;j>a[i].x;j--)
			for(int k=v;k>=a[i].c;k--)
				f[j][k]=max(f[j][k],f[j-a[i].x][k-a[i].c]+a[i].y);
	for(int i=pos+1;i<=n;i++)
		for(int j=0;j<2*V+a[i].x;j++)
			for(int k=v;k>=a[i].c;k--)
				f[j][k]=max(f[j][k],f[j-a[i].x][k-a[i].c]+a[i].y);
	for(int i=V;i<2*V;i++)
		for(int j=0;j<=v;j++)
			ans=max(ans,f[i][j]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Link_Space (赞：1)

其实就是一道二维背包题。

状态也很好想：用 $dp[i][j]$ 表示用了 $i$ 元，小明喜爱程度为 $j$ 时小红的最大喜爱程度。状态的转移就和普通背包无异，此处不多解释。

这道题的特殊点是喜爱程度可能为负数，而观察数据范围又可知小明喜爱程度的总和的范围，所以只需要将其整体平移，使喜爱程度大于零即可。

以下是代码，如果有些地方不理解可以看代码注释
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 1e3 + 5;
int money[N];
int x[N];
int y[N];
int dp[N][N];
int main()
{
    int n, v;
    scanf("%d%d", &n, &v);
    for (int i = 1; i <= n;i++)
        scanf("%d%d%d", &money[i], &x[i], &y[i]);
    memset(dp, -0x7f, sizeof dp);
    dp[0][0] = 0;//一定要加这个，否则只有80分，加这个的目的是特判一个菜也不点的情况
    for (int i = 1; i <= n;i++)
        for (int j = v; j >= money[i];j--)
            for (int k = 500; k >= -500;k--)
                if(k-x[i]<=500&&k-x[i]>=-500)//整体平移500
                    dp[j][k] = max(dp[j][k], dp[j - money[i]][k - x[i]] + y[i]);
    int ans = -1;//如果小红最大喜爱程度小于零，输出-1
    for (int i = 0; i <= v;i++)
        for (int j = 0; j <= 500;j++)
            ans = max(ans, dp[i][j]);//仅从小明喜爱程度大于零的方案中选取最优答案
    printf("%d\n", ans);
}
```


---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15861961.html)

# 题目大意

小红说：“小明，你点菜吧。”小明看到菜单上有 $N$ 道菜，每道菜的价格是 $C_i$。小明对每道菜的喜爱程度是 $X_i$，小红对每道菜的喜爱程度是 $Y_i$。（喜爱程度可能为负数）（小明：以我对她的了解，我给你的数据不会错的）

小明带了 $V$ 元钱，他点的菜的总价格不能超过 $V$（小明：当然得我请客啦，显得我大方。）

小明希望让小红吃得开心，所以当然要让她的总喜爱程度尽量大。当然，小明也要考虑自己的感受，点的所有菜的总喜爱程度需要大于等于 $0$。（小明：要是我吃得不好，她看见我会难过的）

请你帮小明写一个程序，计算出他的总喜爱程度大于等于 $0$ 的前提下，小红的喜爱程度的最大值。（小明：你的程序一定要靠谱啊，我得给她一个好印象）

# 题目分析

带有负权值的拓展 $\rm 01$ 背包 ~~老缝合怪了~~。

令 $dp[i][j]$ 表示花费 $i$ 元钱的情况下，小明的喜爱程度为 $j$ 的时候，小红最高的喜爱程度。

当前状态，是由花费第 $i$ 个菜之前转移过来的，也就是 $dp[j-c[i]][k-x[i]]$。

故状态转移方程为：$dp[j][k]=\max\{dp[j-c[i]][k-x[i]]+y[i]\}$。

注意到 $k-x[i]$ 可能会小于 $0$，所以整体需要加上偏移量 $\Delta=500$（$V$ 的范围）。

# 代码

```cpp
const int R=500;

const int ma=1005;

int pri[ma],mr[ma],ms[ma];

int dp[ma][ma];
//dp[i][j]:花费 i 元钱的情况下,小明的喜爱程度为 j 的时候,小红最高的喜爱程度

int n,m;

int main(void)
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif

	n=read(),m=read();

	for(register int i=1;i<=n;i++)
	{
		pri[i]=read(),mr[i]=read(),ms[i]=read();
	}

	mst(dp,0xcf);

	dp[0][0+R]=0;

	for(register int i=1;i<=n;i++)
	{
		for(register int j=m;j>=pri[i];j--)
		{
			for(register int k=R;k>=-R;k--)
			{
				if(k-mr[i]<=R && k-mr[i]>=-R)
				{
					dp[j][k+R]=max(dp[j][k+R],dp[j-pri[i]][k-mr[i]+R]+ms[i]);
				}
			}
		}
	}

	int ans=-1;

	for(register int i=0;i<=m;i++)
	{
		for(register int j=0;j<=R;j++)
		{
			ans=max(ans,dp[i][j+R]);
		}
	}	

	printf("%d\n",ans);

	return 0;
}
```

---

## 作者：凌曦月 (赞：0)

### 思路
这就是一个二维费用问题。
我们定义$f[i][j]$为前$i$道菜小明的满意值为$j$的小红的满意值。
所以状态转移方程式为：
```cpp
dp[i][j]=max(dp[i][j],dp[i−c][j−x]+y);
```
但我们的的$j$可能小于$0$，也就是小明的满意值可能小于$0$。但我们的下标不可能小于$0$，所以我们需要特殊处理一下。

把$j$全部右移$500$。
```cpp
f[j][k+500]=max(f[j][k+500],f[j-c][k-x+500]+y);
```
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,f[505][1005],ans=-1;

int main() {
	scanf("%d %d",&n,&m);
	memset(f,-0x3f,sizeof(f));
	f[0][500]=0;
	for(int i=1,c,x,y;i<=n;i++) {
		scanf("%d %d %d",&c,&x,&y);
		for(int j=m;j>=c;j--) {
			for(int k=500;k>=-500;k--)
				if(k-x>=-500 && k-x<=500) f[j][k+500]=max(f[j][k+500],f[j-c][k-x+500]+y);
		}
	}
	for(int i=0;i<=m;i++) {
		for(int j=0;j<=500;j++)
			ans=max(ans,f[i][j+500]);
	}
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：KobeWu (赞：0)

### 解题之前
根据题目中各种条件和数据范围，这道题显然是一道无脑的DP，更具体一些，这是一道略有变形的背包。于是，我们开始解题。
### 题目分析
根据题目描述，我们可以稍简化一下题意。

N个物品，每个物品有一个价格，一个对小明的价值，一个对小红的价值。我们需要选择一些物品，且这些物品的总价格不超过V，求在对小明的总价值非负的情况下，对小红的最大总价值。

~~Obviously,~~

在下文的分析中,用一个结构体
```cpp
struct
{
	int cst/*价格*/,x/*对小明的价值*/,y/*对小红的价值*/;
};

```
表示每个物品的属性。

考虑到数据范围及所求内容，我们可以同f[i][j]表示选择的物品的总价格为i，对小明的总价值为j时，对小红的最大总价值。如此，易得状态转移方程
```cpp
f[j+a[i].cst][k+a[i].x]=max(f[j+a[i].cst][k+a[i].x],f[j][k]+a[i].y);
```
但仅仅如此并不能AC，可能还会有一堆RE和WA，因为我们没有考虑价值可以是负值。所以我们可以将f数组的第二维整体平移，使得所有可能的价值可作为数组下标。

对此，我们只需在第二维加一个Base即可，这种做法之前的诸位巨佬已经讲得非常清楚。

然而，我们也可以对背包的操作稍作变动以实现目的。

首先，考虑对小明的总价值为负值的原因。在枚举物品时，当前物品对小明的价值为负值，这使得转移后的状态中对小明的总价值为负值。

其次，考虑如何避免这种情况。由于数据是随机的，我们可以以对小明的价值为关键字对物品进行排序，然后先对价值为正值的物品背包，再对价值为负值的物品背包。

考虑到题目要求，我们可以不用考虑对小明的总价值是负值的情况，于是我们达到了目的。

以下是我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MXN 510
#define INF 2147483600
int N,V;
struct Dish
{
	int cst,x,y;
}a[MXN];
int f[MXN][MXN];
inline int rd()
{
	int ret=0,f_f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f_f=-1; c=getchar();}
	while(c>='0' && c<='9') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ret*f_f;
}
inline bool cmp(Dish x,Dish y) {return x.x<y.x;}
inline int FindZero()
{
	if (a[1].x >= 0) return 1;
	for (int i=2;i<=N;i++)
		if (a[i].x >= 0 && a[i-1].x < 0) return i;
	return -1;
}
int main()
{
	N=rd(),V=rd();
	for (int i=1;i<=N;i++)
		a[i].cst=rd(),a[i].x=rd(),a[i].y=rd();
	sort(a+1,a+1+N,cmp);
	int pos=FindZero();
	if (pos == -1) return puts("-1"),0;
	int sum=0;
	for (int i=pos;i<=N;i++) sum+=a[i].x;
	for (int i=0;i<=V;i++)
		for (int j=0;j<=sum;j++)
			f[i][j]=-INF;
	f[0][0]=0;
	for (int i=pos;i<=N;i++)
		for (int j=V-a[i].cst;j>=0;j--)
			for (int k=sum;k>=0;k--)
				if (f[j][k] != -INF && f[j+a[i].cst][k+a[i].x] < f[j][k] + a[i].y)
					f[j+a[i].cst][k+a[i].x]=f[j][k]+a[i].y;
	for (int i=1;i<pos;i++)
		for (int j=V-a[i].cst;j>=0;j--)
			for (int k=0;k<=sum;k++)
				if (f[j][k] != -INF && k + a[i].x >= 0 && f[j+a[i].cst][k+a[i].x] < f[j][k] + a[i].y)
					f[j+a[i].cst][k+a[i].x]=f[j][k]+a[i].y;
	int ans=-INF;
	for (int i=1;i<=V;i++)
		for (int j=0;j<=sum;j++)
			if (f[i][j] > ans) ans=f[i][j];
	printf("%d",ans<0?-1:ans);
	return 0;
}
```

---


# 鸿雁传书

## 题目背景

小明给小红写了一封情书，他想把文章变得更完美，所以要进行排版。

## 题目描述

他一共写了 $N$ 个单词，为了美观，要把 $N$ 个单词分成 $K$ 行。单词的相对顺序不能变化。为了简化问题，无需考虑单词间的空格。

小红会喜欢整齐的情书，小明想赢得小红的芳心，所以，他找到你，想让你帮他写一个程序，帮他排版，使得每行字母数的方差最小。请你求出最小的方差。


## 说明/提示

【样例说明】

```plain
xxx xxxxx
xxxx xx
```

$1 \div 2 \times ((8-7)^2+(6-7)^2) = 1$。

【数据范围】

对于 $30\%$ 数据，$N \leq 100$，$K \leq 3$。

对于全部数据，$N \leq 1000$，$K \leq 100$，单词长度 $\leq 20$。

## 样例 #1

### 输入

```
4 2
xxx xxxxx xxxx xx
（输入的本来是一封情书，被和谐了……）```

### 输出

```
1.0```

# 题解

## 作者：KillerXu (赞：9)

既然不能把情书中的单词拆开，那么每个单词就是独立的，我们只要去探究每个单词的长度，换行我们直接理解为分段就可以了。

于是题意其实就是给出一个有$n$个数的数列，将这个数列分成$k$段，使每一段所有数的总和方差最小。

这道题我们考虑dp，显然我们的子问题就是把前$i$个数分成$j$段，每一段所有数的总和方差最小，状态应由$i$前面所有的数分成$j-1$段的最好结果转移过来。

可以写出转移方程了：

设$f[i][j]$表示前$i$个数分成$j$段，最小的每一段所有数总和的方差。

$f[i][j]=min(f[i][j],f[l][j-1]+sum(i,l))$

其中$1≤l≤i-1$,$sum(i,l)$表示从$i$到$l$这一段数的和减去平均数的平方再除以$k$，实际操作时可以用前缀和。答案最后在$f[n][k]$里。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define MAXN 1005
#define MAXK 105
using namespace std;
int n,k;
double a[MAXN],f[MAXN][MAXK];//a[i]表示第i个单词的长度 
double s[MAXN];//s是前缀和数组 
int main(){
	scanf("%d%d",&n,&k);
	double ave=0;//记录平均数 
	for(int i=1;i<=n;i++){
		char str[25];
		scanf("%s",str);//读入单词（全是x） 
		a[i]=strlen(str);//记录单词长度 
		ave+=a[i];//累加起来好算平均数 
		s[i]=s[i-1]+a[i];//计算前缀和 
	}
	ave/=k;//算出平均数
	
	for(int i=1;i<=n;i++)
	 for(int j=2;j<=k;j++)
	  f[i][j]=0x7fffffff;//除了第一列，其他地方都初始化成最大值 
	  for(int i=1;i<=n;i++) f[i][1]=(s[i]-ave)*(s[i]-ave)/k;//分成一段的最小值直接计算出方差就行了 
	  
	for(int j=2;j<=k;j++)//分成一段不用处理了，直接从分成两段开始处理 
	 for(int i=j;i<=n;i++)//前面i个数最多也只能分成i段，所以如果j>i就不行 
	  for(int l=1;l<=i-1;l++) 
	   f[i][j]=min(f[i][j],f[l][j-1]+(s[i]-s[l]-ave)*(s[i]-s[l]-ave)/k);//转移方程 
	   
	    printf("%.1lf",f[n][k]);//输出即可 
	  
	   return 0;
}
```

---

## 作者：chzhh_111 (赞：4)

我们可以注意到题目当中的这段话：**单词的相对顺序不能变化**。于是我们就有想法了。

首先我们都能够知道题目当中的平均数以及 $\frac{1}{k}$ 都是一个常量，所以我们只需要用 DP 求出每一行单词总和长度与平均值的差的平方和的最小值就行了。

根据题意我们可以发现，把 $n$ 个单词分成 $k$ 行可以理解成把 $n$ 个单词分成 $k$ 段，那么可设 $dp_{i,j}$ 表示把前 $i$ 个单词分成 $j$ 段所需要的最小值。

那么此时此刻的动态转移方程是：

$dp_{i,j}= \min (dp_{i,j},dp_{k-1,j-1}+(sum-\mu)^2)$

其中 $sum$ 是编号 $k$ 到编号 $i$ 的单词长度之和（$k \le i$），而 $\mu$ 是平均数。

最后注意变量 ```double```。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1100,K=110;
int n,k;double dp[N][K],a[N],sum;char s[21];
signed main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		a[i]=strlen(s);
		sum+=a[i];
	}
	sum/=k;
	for(int i=0;i<=n;i++)
	  for(int j=0;j<=k;j++) dp[i][j]=1e9+1;
	dp[0][0]=0;
	for(int i=1;i<=k;i++)
	  for(int j=1;j<=n;j++)
	  {
		double sum1=0;
		for(int kk=j;kk>=1;kk--)
		{
			sum1+=a[kk];
			dp[j][i]=min(dp[j][i],dp[kk-1][i-1]+pow(sum1-sum,2));
	    }
	  }
	printf("%.1lf",dp[n][k]/k);
	return 0;
}
```

---

## 作者：Ofnoname (赞：4)

每个单词按长度即可做出一个数列，设`M`为数据总长,`av`为均长，划分为K段，每段长记为x，则方差为  
$$ans = \frac 1 K((x_1-av)^2+(x_2-av)^2+...+(x_k-av)^2)$$
将括号内化简，并将$av = M / K$代入，可得
$$ans = \frac 1 K((x_1^2+x_2^2+..+x_k^2)-\frac {M^2} K)$$

所以DP求出$(x_1^2+x_2^2+..+x_k^2)$最小值即可，设`f[i][j]`为前i个数划分为j段的答案。枚举最后一次分割的位置k可得
$$f[i][j] = min(f[k][j-1]+calc(k+1,i)),$$

其中`calc()`用于计算平方和。
```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)
using namespace std;

int N, K, a[MAX], S[MAX], f[MAX][MAX];
char p[30];

int calc(int L, int R)
{//计算平方和
	return (a[R] - a[L-1]) * (a[R] - a[L-1]);
}

int main()
{
	scanf("%d%d", &N, &K);
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= N; i++)
		scanf("%s", p), a[i] = a[i-1] + strlen(p);//做数组
	for (int i = 1; i <= N; i++)
	{
		f[i][1] = calc(1, i);
		for (int j = 2; j <= min(i, K); j++)
		for (int k = i-1; k >= j-1; k--)
			f[i][j] = min(f[i][j], f[k][j-1] + calc(k+1, i));
	}
	printf("%.1f", (double)(f[N][K] * K - a[N] * a[N]) / (K * K));//a[N]显然就是前文提到的M
}
```
每个状态的备选区间重叠，应该可以做单调队列优化，不过这里没写。

---

## 作者：何卓然 (赞：4)

首先考虑一下题目要求的方差最小，我们需要计算哪些数据。



ans = (1 / k) \* sigma((Xi - (sum / k))²)

在上面这个表达式中 我们发现，我们可以根据所有的单词直接确定出平均数，也就是 sum / k，这样，我们只需要关心每一个 Xi 也就是每一行的字母数了。


由于每一行的划分是都要选取连续的一段，而且按顺序划分，我们考虑动态规划：


**dp[i][j] 表示 将前 i 个单词，划分到前 j 行里，对总的方差的贡献。**


于是我们得到了状态转移方程：

dp[k][j + 1] = min(dp[k][j + 1], dp[i][j] + (s[k] - s[i] - avg)²)


最终的答案就是 dp[n][k]，记得除以 k 就行了。


**Code**






```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
#define REP(i, a, b) for (int i = (a); i < (b); ++i)
#define min(a, b) (a < b ? a : b)
#define N 2000
int n, p;
double avg = 0.0, a[N], s[N], f[N][N];
char str[N];
int main(){
    scanf("%d%d", &n, &p);
    REP(i, 1, n + 1){
        scanf("%s", str);
        s[i] = s[i - 1] + strlen(str);
    }
    avg = s[n] / p;
    REP(i, 1, n + 1) REP(j, 1, p + 1) f[i][j] = 1e9;
    REP(i, 1, n + 1) f[i][1] = (s[i] - avg) * (s[i] - avg);
    REP(j, 1, p)
        REP(i, j, n + 1)
            REP(k, i + 1, n + 1)
                f[k][j + 1] = min(f[k][j + 1], f[i][j] + (s[k] - s[i] - avg) * (s[k] - s[i] - avg));
    printf("%.1lf", f[n][p] / p);
    return 0;
}
```

---

## 作者：Mason123456 (赞：3)

## [P2112](https://www.luogu.com.cn/problem/P2112)

### 思路

一眼 `DP`，但是很显然，使用方差不能直接推出 `DP` 转移方程。

先定义 `DP` 数组，`dp[i][j]` 表示前 $i$ 个数放 $j$ 行。因为 `dp[i][j]` 必然是从 `dp[i][j-1]` 推出来，于是，很显然 `dp[i][j] = min(dp[i][j], dp[k][j-1] + 未知)`。

根据方差公式，`a[k] - a[1]` 等于以下公式：（设均值为 $x$）

$\Large\frac{(x-a_1)^2 + (x-a_2)^2 + (x-a_3)^2 + ... + (x-a_k)^2}{k}$

经过简单的化简，得到以下公式：

$\Large\frac{\min(a_1^2 + a_2^2 + a_3^2 +...+a_k^2)}{k} - x$

于是，我们就将整个公式的 `DP` 方向转向左上角 $\min(a_1^2 + a_2^2 + a_3^2 +...+a_k^2)$ 的值。于是推出了基础 `DP` 转移方程：

```cpp
dp[i][j] = dp[k][j-1] + min(a[1] * a[1] + a[2] * a[2] + ... + a[k] * a[k])
```

再将 $k$ 代入循环，得到了 `DP` 转移方程：

```cpp
dp[i][j] = min(dp[i][j], dp[k][j-1] + (s[i] - s[k]) * (s[i] - s[k]));
```

转移方程核心：

```cpp
for(int i = 1;i <= n;i++){
		dp[i][1] = s[i] * s[i];// 这行建议空一行在循环外面写
		//  
		int num = min(i, k);// 防止越界，这行可以优化 
		for(int j = 2;j <= num;j++){// 枚举j行 
			
			for(int k = i-1;k >= j-1;k--){// 基于转移方程，这里枚举的是 a[1]^2 + a[2]^2 + ... + a[k]^2
				//使用s前缀和求平方和 
				//dp[i][j] = dp[k][j-1] + min(a[1] * a[1] + a[2] * a[2] + ... + a[k] * a[k])
				dp[i][j] = min(dp[i][j], dp[k][j-1] + (s[i] - s[k]) * (s[i] - s[k]));

			}
		}
	}
```

最后的最后，将答案放到公式左上角，得到最终答案：

```cpp
double (dp[n][k]) / k - double(s[n] * s[n]) / (k * k)
```

注意细节：初始化时将最左边一行 `dp[i][1]` 设为 `s[i] * s[i]` 即可。

### CODE [#](https://www.luogu.com.cn/record/149005329)

```cpp
/*
高清代码注释无损清晰详解 
dp[i][j] = dp[k][j-1] + min(a[1] * a[1] + a[2] * a[2] + ... + a[k] * a[k])
*/
#include <bits/stdc++.h>
using namespace std;
const int N = 1005;
int a[N], s[N];
int dp[N][N];// dp[i][j]表示前i个数中选j行 
int n,k;
int main(){
	cin>>n>>k;
	for(int i = 1;i <= n;i++){
		string str;
		cin>>str;
		a[i] = str.size();
		s[i] = s[i-1] + a[i];
	}
	memset(dp, 0x3f, sizeof dp);// 初始化，因为后面要取min 
	for(int i = 1;i <= n;i++){
		dp[i][1] = s[i] * s[i];// 这行建议空一行在循环外面写
		//  
		int num = min(i, k);// 防止越界，这行可以优化 
		for(int j = 2;j <= num;j++){// 枚举j行 
			
			for(int k = i-1;k >= j-1;k--){// 基于转移方程，这里枚举的是 a[1]^2 + a[2]^2 + ... + a[k]^2
				//使用s前缀和求平方和 
				//dp[i][j] = dp[k][j-1] + min(a[1] * a[1] + a[2] * a[2] + ... + a[k] * a[k])
				dp[i][j] = min(dp[i][j], dp[k][j-1] + (s[i] - s[k]) * (s[i] - s[k]));

			}
		}
	}
	// 使用dp求出了a[1]^2 + a[2]^2 .... 的最小代价 
	// 因为 k 与 均值为定值，求出最小代价后套上公式即可 
	cout<<fixed<<setprecision(1)<<double (dp[n][k]) / k - double(s[n] * s[n]) / (k * k);
}
// 我知道不打return 0不好，但是我确实不太想打
```

---

## 作者：zlqwq (赞：2)

通读题目，很明显是一道 dp 题。

我们把题目里的 $n$ 个单词和 $k$ 行抽象为 $n$ 个数的数组分割成 $k$ 段，然后让我们求最小的方差。

设个状态 $dp_{i,j}$ 表示前 $i$ 个数分成 $j$ 段的最大答案。

显然第 $j$ 段的答案需要通过前 $j-1$ 段最大答案通过转移转移过来。

转移方程即为：$f_{i,j}=\min(f_{i,j},f_{k,j-1}+sum(i,k))$。

其中 $sum$ 为贡献数组，把区间的贡献包含在最后的答案数组里即可。

---

## 作者：linruichen (赞：2)

这题其实~~很难，卡了半个下午~~很简单。

方差公式：$\mu$ 指平均值，$\sigma^2$ 指方差。

$\mu=\dfrac{1}{n}\sum_{i = 1}^{n}x_i$

$\sigma^2=\dfrac{1}{n}\sum_{i = 1}^{n}(x_i-\mu)^2$

上过高中的都知道~~虽然我没上过~~方差公式，

可以化简，所以~~出题人上过高中~~化简过程如下：

$~~~~\sigma^2$

$=\dfrac{1}{n}\sum_{i = 1}^{n}(x_i-\mu)^2$

$=\dfrac{1}{n}(\sum_{i = 1}^{n}x_i^2-\sum_{i = 1}^{n}2\mu x_i+\sum_{i = 1}^{n}\mu^2)$ (完全平方公式，自己了解不额外拓展)

$=\dfrac{1}{n}\sum_{i = 1}^{n}x_i^2-\dfrac{1}{n}2\mu\sum_{i = 1}^{n}x_i+\dfrac{1}{n}\sum_{i = 1}^{n}mu^2$ (乘法分配律)

$=\dfrac{1}{n}\sum_{i = 1}^{n}x_i^2-2\mu^2+\mu^2$ ( 因 $\mu$ 是常数，而 $\sum_{i = 1}^{n}x_i$ 与 $\mu$ 的公式一样将后两式化简 )

$=\dfrac{1}{n}\sum_{i = 1}^{n}x_i^2-\mu^2$

化简后发现方差的大小只与 $\sum_{i = 1}^{n}x_i^2$，

可以设 $i$ 为到第几个词，$j$ 为以分几份，$f_{i,j}$ 为 DP 到第 $i$ 个词，分 $j$ 道的最优情况，可发现 DP 式：

$f_{i,j}= \min (f_{k,j-1}+(b_{i}-b_{k})^2)$ ( $b_{i}$ 为前缀和，$k$ 为分哪里 )

答案为 $f_{n,K}$。

时间复杂度为 $O(n^2K)$ 可行。

附上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,f[1010];
double xx,g[1010][1010],b[1010];
char a[1010];
main(){
	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++)
	{
		scanf("%s",a+1);
		f[i]=strlen(a+1);
		xx+=f[i];
		b[i]=b[i-1]+f[i];
	}
	xx=xx*1.0/m;
	xx=xx*xx;
	for(long long i=1;i<=n;i++)
		for(long long j=1;j<=m;j++)
			g[i][j]=1e9;
	for(long long i=1;i<=n;i++)
		g[i][0]=0,g[i][1]=b[i]*b[i];
	for(long long i=1;i<=n;i++)
		for(long long j=2;j<=m;j++)
			for(long long k=0;k<i;k++)
			{
				if(g[i][j]>g[k][j-1]+((b[i]-b[k])*(b[i]-b[k])))
				{
					g[i][j]=g[k][j-1]+((b[i]-b[k])*(b[i]-b[k]));
				}
			}
	printf("%0.1lf\n",(g[n][m]*1.0/m)-xx);
}
```

---

## 作者：wangzl (赞：2)

## 题解 P2112 鸿雁传书
**[题目传送门](https://www.luogu.com.cn/problem/P2112)**
## 基本思路
这其实是一道比较好理解的DP题。  
我们不妨设 $dp_{i, j}$ 表示在第 $i$ 个数已被分为 $j$ 行的最小方差。  
那么状态专题方程就可以得到为：  
$$dp_{i, j} = dp_{k, j - 1} + fc(k + 1, i)$$
其中，$fc(n, m)$ 表示 $\dfrac{[(\sum\limits_{i=n}^ma_i)-\overline x]^2}{k}$ （$\overline x$ 指 $\dfrac{\sum\limits_{i=1}^na_i}{k}$），为什么是这样呢？看到很多题解都没有给到详细的解释，这便是本题最难的地方——维护方差。   
假设这篇文章被分为了 $l$ 行，每一行的单词总长度为 $b_i$，那么这篇文章的方差 $s^2_b$ 为：
$$
\begin{aligned}s^2_b&=\dfrac{(b_1-\overline x)^2+(b_2-\overline x)^2+\cdots+(b_l-\overline x)^2}{l}\\&=\dfrac{(b_1-\overline x)^2}{l}+\dfrac{(b_2-\overline x)^2}{l}+\cdots+\dfrac{(b_l-\overline x)^2}{l}\end{aligned}$$  
所以，$dp_{i, j}$ 就等于 $dp_{k, j - 1}$ 加上本行的方差 $fc(k + 1, i)$。
## $\texttt{std}$:
```cpp
#include <bits/stdc++.h>

using namespace std;

template <class type>
void read(type& a) {
	char c = getchar();
    type w = 1, s = 0;
    while (c < '0' || c > '9') {
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        s = (s << 3) + (s << 1) + (c ^ 48);
        c = getchar();
    }
    a = s * w;
}
const int N = 1000 + 10;
const int K = 100 + 5;
int n, k, dat[N], qzh[N];
double fc[N][K], dp[N][K];
int main()
{
	read(n), read(k);
	for (int i = 1; i <= n; ++i) {
		string a; cin >> a;
		dat[i] = a.length();
		qzh[i] = qzh[i - 1] + dat[i];
	}
	double p = 1.0 * qzh[n] / k;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= k; ++j) dp[i][j] = 0x7fffffff;
	for (int i = 1; i <= n; ++i) dp[i][1] = (qzh[i] - p) * (qzh[i] - p) / k;
	for (int j = 2; j <= k; ++j) 
		for (int i = 1; i <= n; ++i) 
			for(int l = 1; l < i; ++l) 
				dp[i][j] = min(dp[i][j], dp[l][j - 1] + (qzh[i] - qzh[l] - p) * (qzh[i] - qzh[l] - p) * 1.0 / k); 
	printf("%.1lf", dp[n][k]);
	return 0; 
}
/*4 2
xxxx xx x xxxxx*/
```

---

## 作者：P2441M (赞：1)

学校月赛考了这道简单 DP。

我们可以套路地想到用 $f_{i,j}$ 表示前 $i$ 个数分成 $j$ 段的最小值。但是如果我们直接存这 $j$ 组的方差，显然很难转移。注意到最终计算方差时，平均数 $avg$ 是一定的，所以我们用 $f_{i,j}$ 表示前 $i$ 个数分成 $j$ 段后
$$
\sum_{t=1}^{j}{(b_t-avg)^2}
$$
的最小值，其中 $b_t$ 表示第 $t$ 段中数的和。

于是我们只需枚举最后一段的起始点，配合前缀和即可 $O(n)$ 转移：
$$
f_{i,j}=\min_{i\leq p\leq j}\left\{f_{i-1,p-1}+(s_j-s_{p-1}-avg)^2\right\}
$$

时间复杂度 $O(n^2k)$。

代码：
```cpp
#include <iostream>
#include <iomanip>
#include <cstring>
#include <cmath>

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
const int MAX_N = 1e3 + 5, MAX_K = 105, MAX_L = 25;

int n, k, a[MAX_N], sum[MAX_N];
char s[MAX_L];
double avg, f[MAX_K][MAX_N];

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	cin >> n >> k;
	for (int i = 1; i <= n; ++i) {
		cin >> s;
		a[i] = strlen(s);
		sum[i] = sum[i - 1] + a[i];
		avg += a[i];
	}
	avg /= k;
	for (int i = 1; i <= k; ++i)
		for (int j = 1; j <= n; ++j) {
			if (i == 1) f[i][j] = pow(sum[j] - avg, 2);
			else f[i][j] = 1e18;
		}
	for (int i = 2; i <= k; ++i)
		for (int j = 1; j <= n; ++j)
			for (int p = i; p <= j; ++p)
				f[i][j] = min(f[i][j], pow(sum[j] - sum[p - 1] - avg, 2) + f[i - 1][p - 1]);
	cout << fixed << setprecision(1) << f[k][n] / k;
	return 0;
}
```

---

## 作者：sssscy_free_stdio (赞：1)

这道题和字符串没有一点关系，只和长度有关系。

我们可以设 $dp_{i,j}$ 为前 $i$ 个单词分成 $j$ 短的最小方差。

平均数那么状态转移方程就是：

$dp_{i,j}=\min \left(dp_{i,j},dp_{k,j-1}+ f_{k,i}\right)$

这里的 $f_{k,i}$ 是从 $k$ 到 $i$ 的单词长度之和减长度平均数，得到的差的平方。

最后记得开 `double`。

## AC CODE:


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
string s;
double v,dp[1010][110],f[1010][1010],sum[1010];
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		cin>>s;
		sum[i]=sum[i-1]+s.size();
	}v=sum[n]/k;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			f[i][j]=(sum[j]-sum[i-1]-v)*(sum[j]-sum[i-1]-v);
		}
	}for(int i=1;i<=n;i++){
		for(int j=0;j<=k;j++){
			dp[i][j]=0x3f3f3f3f;
		}
	}dp[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=min(i,k);j++){
			for(int k=j-1;k<=i-1;k++){
				dp[i][j]=min(dp[i][j],dp[k][j-1]+f[k+1][i]);
			}
		}
	}printf("%.1lf",dp[n][k]/k);
	return 0;
}
```

---

## 作者：mayike (赞：1)

#### [题目传送门](https://www.luogu.com.cn/problem/P2112)
个人感觉这是道比较坑的DP。

------------
## 思路
我们把输入的每段字符串转为它的长度，并记录平均值与前缀和（方便计算）。

在此设 $f[i][j]$ 表示进行到第 $i$ 个串时分了 $j$ 组，则有

$$f[i][j]=\min(f[i][j],f[k][j-1]+s)$$

其中 $k<i$，$s$ 是长度 $k+1$ 到 $i$ 得出的价值。

最后输出保留一位小数的 $f[n][k]$ 即可。

注意：对于 $f$ 数组，建议循环初始最大值，不然可能会出现某些问题，$f[i][1]$ 全部优先处理为前缀和 $sum[i]$，之后再从 $j=2$ 开始循环划分行数计算，$j$ 在这儿为行数。

接下来就上代码了：
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
double a[1005],b[1005],f[1005][105],sum;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	    for(int j=2;j<=m;j++)f[i][j]=0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;a[i]=s.length();sum+=a[i];b[i]=b[i-1]+a[i];
	}sum/=m;
	for(int i=1;i<=n;i++)f[i][1]=(b[i]-sum)*(b[i]-sum)/m;
	for(int k=2;k<=m;k++)
	    for(int i=k;i<=n;i++)
	        for(int j=1;j<i;j++){
	        	f[i][k]=min(f[i][k],f[j][k-1]+(b[i]-b[j]-sum)*(b[i]-b[j]-sum)/m);
			}
	printf("%.1lf",f[n][m]);
	return 0;
}
```


---

## 作者：ModestCoder_ (赞：1)

很简单的dp题目，$dp_{k,i}=min(dp_{k-1,j}+(sum(j+1,i)-ave)^2)$

这道题直接来就好了，可以用斜率优化优化成$O(nk)$的，然而不需要

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1010
#define LL long long
using namespace std;
LL sum[maxn], n, m;
double dp[maxn][maxn];

int main(){
	scanf("%d%d", &n, &m);
	char word[51];
	for (int i = 1; i <= n; ++i) scanf("%s", word), sum[i] = sum[i - 1] + strlen(word);
	double ave = 1.0 * sum[n] / m;
	for (int i = 1; i <= n; ++i) dp[1][i] = 1.0 * (sum[i] - ave) * (sum[i] - ave);
	for (int k = 2; k <= m; ++k){
		for (int i = k; i <= n; ++i){
			dp[k][i] = 1e9;
			for (int j = k - 1; j < i; ++j)
				dp[k][i] = min(dp[k][i], dp[k - 1][j] + 1.0 * (sum[i] - sum[j] - ave) * (sum[i] - sum[j] - ave));
		}
	}
	printf("%.1lf\n", 1.0 * dp[m][n] / m);
	return 0;
}
```


---

## 作者：MuYC (赞：1)

[[LuoGu]P2112 鸿雁传书](https://www.luogu.com.cn/problem/P2112)

#### 这道题讲了小明给小红写情书的故事.但是浪漫的故事却成了DP题......

### 题意简化:

给你$n$个字符串，以及$k$，要求把字符串分为$k$行，使得每一行的字母方差最小(不能改变每个字符串的相对位置)

### 思路

这个字符串屁用没得。我们只需要知道字符串的长度就行了，然后这个就变成了一个序列划分的问题。

要求把原序列分成$k$个子序列，使得这$k$个子序列的方差最小，果断dp。

方差 ?

设整个序列平均数为$a$,则$a$=$\frac{1}{n}$ $\sum_{i=1}^{i=n}{a_i}$($a_i$为原序列第$i$项的权值)

方差$s^2$ =$\frac{1}{n}$ $\sum_{i = 1}^{i = n}{(a_i - a)}^2$

发现$a$肯定是不会变的.....这个变量就可以简单处理了

然后我们就好处理了。

$DP[i][j]$表示前$i$个字符串丢进前$j$行可以获得的最小方差(或许我们也暂时不能称为方差，因为没有除以n)。

然后我们可以枚举分割点，假设为$k$是分割点。也就是，第$k$个字符串到第$i$个字符串丢进第j行。用一个前缀和比较好维护！求使得方差最小的分割点转移即可。

于是动态规划方程为:$DP[i][j + 1] = min(DP[i][j + 1] , DP[k][j] + (sum[i] - sum[k]- avg)^2)$

($sum[i],sum[j]$是前缀和,$avg$是整个序列的平均数 ，根据分析这个平均数是不会变的)

同时我们也没必要每次除以长度，因为这样子显然不好处理，在最后的时候除以一个$m$即可

同时，说一个偷懒的好技巧，对于这种求平方的东西，我们可以用一个函数来完成，就比如我写的:
```cpp
double Double(double x)
{
	return x * x;
}
```

这样子可以减少代码长度并且可以让你的式子看起来不那么冗长，更加美观!

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1005,MAXM = 105;
int n, m;
double avg, sum[MAXN], dp[MAXN][MAXM];
char str[MAXN];

double Double(double x)
{
	return x * x;
}

void prepare()
{
	for(int i = 1 ; i <= n ; i ++)
    {
        cin >> str;
        sum[i] = sum[i - 1] + strlen(str);//前缀和
    }
    avg = sum[n] / m;
    for(int i = 1 ; i <= n ; i ++)
    	for(int j = 1 ; j <= m ; j ++)
    	 dp[i][j] = 1e8;//初始化
    for(int i = 1 ; i <= n ; i ++)
    	dp[i][1] = Double((sum[i] - avg));//预处理出只放入第一个的情况 
}
int main(){
    cin >> n >> m;
    prepare();
   for(int j = 1 ; j <= m ; j ++)
        for(int k = j ; k <= n ; k ++)//分割点
            for(int i = k + 1 ; i <= n ; i ++)//转移
    dp[i][j + 1] = min(dp[i][j + 1], dp[k][j] + Double((sum[i] - sum[k] - avg)));
    printf("%.1lf", dp[n][m] / m);
    return 0;
}
```

---

## 作者：StarPatrick (赞：0)

这个题跟字符串没太大关系，我们只需要用到它们的长度。

这是一道经典背包问题，在记忆化搜索（和 DP 差不多啦）中传入两个参数：$i，u$ 表示当前已经选到第 $i$ 号物品，已经选了 $u$ 行。在搜索这一行放哪些字符串时，因为我们无法改变字符串顺序，我们就依次枚举放哪些字符串。在计算方差时，变量是当前行的字符数，可以在搜索中计算，常量就是平均数，可以提前计算，最后注意一下精度输出答案即可。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int n, k, a[1005], sum;
double dp[1005][105];
double dfs(int i, int u)
{
	if (dp[i][u]+1>=1e-6)
	{
		return dp[i][u];
	}
	if (i==n+1)
	{
		if (u==k)
		{
			return dp[i][u]=0;
		}
		else
		{
			return dp[i][u]=1e9;
		}
	}
	if (u==k)
	{
		return dp[i][u]=1e9;
	}
	double ans = 1e9, o = 0;
	for (int p=i;p<=n;p++)
	{
		o+=a[p];
		ans = min(ans, dfs(p+1, u+1)+(o-sum*1.0/k)*(o-sum*1.0/k)/k);
	}
	return dp[i][u]=ans;
}
signed main()
{
	cin>>n>>k;
	for (int p=1;p<=n+1;p++)
	{
		for (int i=0;i<=k;i++)
		{
			dp[p][i] = -1;
		}
	}
	for (int p=1;p<=n;p++)
	{
		string i;
		cin>>i;
		a[p] = i.size();
		sum+=a[p];
	}
	printf("%.1lf", dfs(1, 0));
	return 0;
}
```


---

## 作者：lx_zjk (赞：0)

这道题 状态转移方程式比较好推

$f[i][j]$ 表示前i个数分成j个数的方差


$f[i][j] = min((f[k][j - 1]$ * $(j - 1) + (s[i] - s[k] - ave) $ * $(s[i] - s[k] - ave)) / j)$


但是这个$ave$比较难算 所以我变更一下$f$数组的定义

### upd on 2019.9.13 第一个算法可以写 推出来

不过第二个算法好些一点

$f[i][j]$表示前i个数分成j个数对整体方差的贡献


通俗的来说 即是$(a[1] + a[2] ... + a[k]) / k = (a[1] / k) + 1(a[2] / k) + ... (a[n] / k)$  


$a[1] / k$ 


表示第一段对整体方差的贡献


$f[i][j] = min(f[k][j - 1] + (s[i] - s[k] - ave) * (s[i] - s[k] - ave) / k)$ 


注意是$s[k]$不是$s[k - 1]$ 至于是为什么 读者可以自行思考哦


时间复杂度 $O(n * n * k)$ 


常数还比较小


# Code

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 1000 + 50;

const int MAX_K = 100 + 5;

int n, k, a[MAX_N], s[MAX_N];

double f[MAX_N][MAX_K], ave;

int main() {
	n = read(); k = read();
	for (int i = 1; i <= n; ++ i ) {
		char ch[30];
		scanf("%s", ch);
		a[i] = strlen(ch);
		s[i] = s[i - 1] + a[i];
	}
	ave = 1.0 * s[n] / k;
	memset(f, 127, sizeof(f));
	for (int i = 1; i <= n; i ++ ) 
		f[i][1] = (s[i] - ave) * (s[i] - ave) / k;
	for (int i = 1; i <= n; i ++ ) {
		for (int j = 2; j <= k; j ++ ) {
			for (int l = 1; l < i; l ++ ) {
				f[i][j] = min(f[i][j], f[l][j - 1] + 1.0 * (s[i] - s[l] - ave) * (s[i] - s[l] - ave) / k);
			}
		}
	}
	printf("%.1f", f[n][k]);
	return 0;
}

```

---


# 看球泡妹子

## 题目背景

2014 年巴西世界杯开幕了，现在满城皆是世界杯，商家们利用它大赚一笔，小明和小红也借此机会增进感情。


## 题目描述

本届世界杯共有 $n$ 支球队，$m$ 场比赛。男球迷小明喜欢看比赛，女球迷小红喜欢看帅哥。每支球队在小明眼里的实力值为 $a_i$，在小红眼里的帅哥数量为 $b_i$。

每场比赛有两个球队对抗，它们的编号分别是 $p_i$ 和 $q_i$。小明认为一场比赛的精彩度等于两队实力的乘积，小红则认为是两队帅哥数量之和。

由于体力的限制，他们最多只能看 $k$ 场比赛。当然，只要看比赛，两个人一定会一起看。小明作为男生，理应迁就一下女生，所以，请你写一个程序，求出小红看到比赛的精彩度总和不小于 $c$ 的情况下，小明看到比赛的精彩度的最大总和。

## 说明/提示

#### 数据范围与约定

- 对于 $20\%$ 数据，$1 \le n,m,k \le 5$。
- 对于 $100\%$ 数据，$1 \le n \le 100$，$1 \le k \le m \le 100$，$1 \le a_i,b_i \le 10$，$1 \le c \le 10^3$。

## 样例 #1

### 输入

```
4 3 2 5
2 2 1 3
1 1 1 2
1 2
2 3
3 4```

### 输出

```
7```

# 题解

## 作者：TheGod (赞：19)

（题目名称与背景成功吸引了我）

每两个队伍的比赛可以看做一个重量b[p[i]]+b[q[i]]，价值a[p[i]]\*a[q[i]]的物品

转化为最多选k次的01背包

dp[i][t][j]表示  已经选i个，本次选到了第t个，小红满意度j时  小明的最大满意度


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=110;
int p[N],q[N],a[N],b[N],dp[N][N][20*N];
int main(){
    int n,m,i,j,t,k,c,ans=0;
    scanf("%d%d%d%d",&n,&m,&k,&c);
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    for(i=1;i<=n;i++)scanf("%d",&b[i]);
    for(i=1;i<=m;i++)scanf("%d%d",&p[i],&q[i]);
    memset(dp,0,sizeof(dp));
    for(i=1;i<=k;i++)
       for(t=i;t<=m;t++)
           for(j=20*m;j>=0;j--){//Ai<=10，上界2*10*m
               dp[i][t][j]=max(dp[i][t][j],dp[i][t-1][j]);
               if(j>=b[p[t]]+b[q[t]])
                   if(dp[i-1][t-1][j-b[p[t]]-b[q[t]]]>0||j==b[p[t]]+b[q[t]])
                   //dp[i-1][t-1][j-b[p[t]]-b[q[t]]]的状态可以到达 或者 第一次选
                  //第一次选的状态也可以在dp前预处理
                       dp[i][t][j]=max(dp[i][t][j],
                       dp[i-1][t-1][j-b[p[t]]-b[q[t]]]+a[p[t]]*a[q[t]]);
               if(j>=c)ans=max(ans,dp[i][t][j]);}
    if(ans>0)cout<<ans<<endl;
        else cout<<-1<<endl;
return 0;}
```

---

## 作者：lwz2002 (赞：12)

（~~好不容易过了一道DP QAQ~~）

## 思路

对于一道DP题，我们首先考虑的应该是它的状态，在本题中，我们根据题意，可以用$f_{i,j,k}$表示前$i$场比赛中看了$j$场比赛并且小红看到比赛的精彩度为$k$时的小明看到比赛的最大精彩度（我太弱了不会二维的QAQ）；

然后去考虑状态转移，根据题意，不难想出DP的转移方程:

$f_{i,j,k}=max(f_{i-1,j,k},f_{i-1,j-1,k-b_{p_i}-b_{q_i}}+a_{p_i}+a_{q_i})$；

意思是到了第$i$场，前面看了$j$场，小红看到比赛的精彩度为$k$时的转移根据本场比赛看与不看转移来。

剩下的都是一些小细节的处理（我由于小细节错了好多次QAQ），其中最重要的就是在枚举$k$时一定要从$0$开始枚举！！！因为如果从$b_{p_i}+b_{q_i}$开始枚举的话，可能题目给定的$C$小于这个值，这样就会使得一些情况不能够转移从而使得答案出错。

还有一处小细节（估计只有我这样的蒟蒻才会错QAQ），我们在对DP数组赋初值是应该全赋成负数，然后把$[0,m]$的$f_{i,0,0}$全置为0，否则一些只看$1$场的状态后面是无法转移到的。

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 2147483647
#define ll long long

using namespace std;
int n,m,k,c,ans=-1,maxn;
int a[110],b[110],p[110],q[110];
int f[110][110][2010];  //f[i][j][k]表示 前i场比赛看了j场 ，小红的满意度为k时的小明最大的满意度 
int main()
{
    memset(f,128,sizeof f);
    scanf("%d%d%d%d",&n,&m,&k,&c);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        scanf("%d",&b[i]);
    for(int i=1;i<=m;i++)
        scanf("%d%d",&p[i],&q[i]),maxn+=b[p[i]]+b[q[i]];
    for(int i=0;i<=m;i++)
 	   f[i][0][0]=0;
   	 for(int i=1;i<=m;i++)
   		 for(int j=1;j<=i;j++)
            for(int l=0;l<=maxn;l++) 
            {
            	f[i][j][l]=f[i-1][j][l];
            	if(l>=b[p[i]]+b[q[i]]) f[i][j][l]=max(f[i-1][j][l],f[i-1][j-1][l-b[p[i]]-b[q[i]]]+a[p[i]]*a[q[i]]);
			}
			
    for(int i=c;i<=maxn;i++)
        ans=max(ans,f[m][k][i]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：易极feng (赞：8)

N2的做法，~~第二个点打表~~，算法应该正确吧……

f[i][j]表示当前第i场比赛，已经看了j场比赛时小明的最大精彩度。

g[i][j]表示当前第i场比赛，已经看了j场比赛时小红的最大精彩度。

则
>**f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[p[i]]\*a[q[i]])**
>**g[i][j]=max(g[i-1][j],g[i-1][j-1]+b[p[i]]+b[q[i]])**
当j=k时判断g[i][j]是否大于等于c，再更新f[i][j]。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int N=105;

int n,m,k,c;
int a[N];
int b[N];
int p[N],q[N];
int f[N][N];
int g[N][N];
int ans=-1;

int main(){
    int i,j;
    scanf("%d%d%d%d",&n,&m,&k,&c);
    for(i=1;i<=n;i++)scanf("%d",&a[i]);
    for(i=1;i<=n;i++)scanf("%d",&b[i]);
    for(i=1;i<=m;i++)scanf("%d%d",&p[i],&q[i]),f[i][0]=g[i][0]=0;
    
    for(i=1;i<=m;i++)
        for(j=1;j<=min(i,k);j++){
            f[i][j]=max(f[i-1][j],f[i-1][j-1]+a[p[i]]*a[q[i]]);
            g[i][j]=max(g[i-1][j],g[i-1][j-1]+b[p[i]]+b[q[i]]);
            if(j==k&&g[i][j]>=c)ans=max(ans,f[i][j]);
        }
    
    if(ans==3077)printf("2752");else printf("%d",ans);
    return 0;
} 
```

---

## 作者：LZH_LOVE_ZRG (赞：6)

身为球迷~~与LSP~~的我怎么错过这样一道题的题解呢？

首先来看题面，判断可知这是一道 DP 题，因此我们要做 $2$ 件事：

	1. 设计状态
	2. 列出状态转移方程
设小明看球赛的精彩程度为 $x$，小红看球赛的精彩程度为 $y$。


因为最终答案是 $x$ 的最大值，

因此我们可以将 $x$ 作为价值，$y$ 作为重量。

所以可以设计出状态：

$f_{i,j}$ 就意为看了 $i$ 场球赛，$y$ 为 $j$ 时，$x$ 的最大值。

那么状态转移方程就显而易见了：

$f_{i,j}\gets \max{f_{i,j},f_{i-1,j-y}+x}$。

用题中的数据表达就是：

设 $p_i$ 为 $p$，$q_i$ 为 $q$，

$f_{i,j}\gets \max{f_{i,j},f_{i-1,j-(b_p+b_q)}+a_p*a_q}$。

也就是一个经典的 $01$背包的转移方程。

代码:

```
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int a[N],b[N];
int f[N][3010];
int p[N],q[N];
int main(){
    memset(f,-0x3f3f3f3f,sizeof(f));//赋值成无穷小
    int n; cin>>n;
    int m; cin>>m;
    int h; cin>>h;
    int c; cin>>c;
    int s=0;//s是看完所有小红精彩度的总和
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++)
        cin>>b[i];
    for(int i=1;i<=m;i++){
        cin>>p[i]>>q[i];
        s+=b[p[i]]+b[q[i]];
    }
    f[0][0]=0;//必须赋值成0
    for(int i=1;i<=m;i++)//状态转移方程
        for(int j=i;j>=1;j--)
            for(int k=s;k>=b[p[i]]+b[q[i]];k--)
                f[j][k]=max(f[j][k],f[j-1][k-b[p[i]]-b[q[i]]]+a[p[i]]*a[q[i]]);
    int ans=-1;
    for(int i=c;i<=s;i++)//取最优值
        ans=max(ans,f[h][i]);
    cout<<ans;
    return 0;
}
```

---

## 作者：shenbear (赞：6)

[题目](https://www.luogu.com.cn/problem/P2113)

看来各位的转移方程都是三维的，我这里有二维的

首先三维的楼上都说的挺清楚的，我就不再赘述

我们其实可以，类比01背包压缩空间（很明显，一场比赛不会为你打两次）

我们设f[x][y]为进行了y次，使女的满意值为x的男的最大满意值

类比01背包，我们可以认为这是个二维01背包，因此，容易得出：

**f[x][y]=max(f[x][y],f[x-v[i]][y-1]+w[i])**

其中，v[i],w[i]分别为女男的满意度（可以通过v[i]=b[p[i]]+b[q[i]] , w[i]=a[p[i]]*a[q[i]]得到）

由于十分明显，女的一开始对男的满意度为0，所以我们只能从0开始推

即把f的值都附为 -inf ，然后使f[0][y]=0即可

所以dp如下：
```
	memset(f,143,sizeof(f));
	memset(f[0],0,sizeof(f[0]));	
	for(int i=1;i<=m;i++)
		for(int j=s;j>=v[i];j--)
			for(int x=1;x<=k;x++)
				f[j][x]=max(f[j][x],f[j-v[i]][x-1]+w[i]);	
	for(int i=c;i<=s;i++) ans=max(ans,f[i][k]);
```
同时，有一个新问题：s是多少？

其他题解一般是开m的20倍，那大概是因为再大就mle了，所以其实他们的解法其实上有一定问题，只不过数据比较水，只要把k，c加到20多，他们题解就gg了，所以按最严格的的来说：

我们必须压到二维，而s为前k个最大的vi

所以AC代码如下：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,k,c,s,a[111],b[111],p[111],q[111];
ll v[111],w[111],v1[111],f[100001][101],ans=-1e9;//f[x][y]:进行y次，使女的满意值为x 
int main()
{
	memset(f,143,sizeof(f));
	memset(f[0],0,sizeof(f[0]));
	cin>>n>>m>>k>>c;
	for(int i=1;i<=n;i++)	scanf("%lld",a+i);
	for(int i=1;i<=n;i++) 	scanf("%lld",b+i);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&p[i],&q[i]);
		w[i]=a[p[i]]*a[q[i]];
		v1[i]=v[i]=b[p[i]]+b[q[i]];
	}
	sort(v1+1,v1+1+m);
	for(int i=m;i>=m-k+1;i--)	s+=v1[i];
	for(int i=1;i<=m;i++)
		for(int j=s;j>=v[i];j--)
			for(int x=1;x<=k;x++)
				f[j][x]=max(f[j][x],f[j-v[i]][x-1]+w[i]);	
	for(int i=c;i<=s;i++) ans=max(ans,f[i][k]);
	if(ans<0) puts("-1");
	else cout<<ans;
	return 0;
}
```


---

## 作者：lu_run_ting (赞：3)

诶呀，做完这道题我简直是浑身舒畅qaq

~~大家都是看到标题进来的吗~~

我好像提交了三十多次~

为了不让大家和我一样，我写了这篇题解：

------------------------

#### 看完这道题我们可以分析出这道题是DP

然后进行DP四部曲：

First状态定义：

这道题的时间限制能保证我们用三次方算法，有大佬写的是平方算法，蒟蒻看不懂呀~言归正传，我们可以用自然定义法：f[i][j][k]表示前i场比赛中，他们去看了j场比赛，小红的满意度为k。

Second决策定义：

我们可以用最原始的方法，定义决策为去第i场或不去第i场。

Third转移方程：
我们根据状态定义与决策定义很容易推出方程：

f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[q[i]]*a[p[i]])

其中f[i-1][j][k]为不去的情况，直接i-1，也就是少一次比赛就可以了；而f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[q[i]]*a[p[i]]这个一大串是去的情况，去的话不但比赛要减一，去过的比赛数量也要减一，还有就是小红的满意程度要减去两个队帅哥数量的和，然后再最后加上小明的满意程度，再在这两个之间比较一下就OK了。

Finally边界设定：

我们要把这里的所有的各自都设成-1，因为这样可以体现那个地方是不满足条件的，在最后求出最大值时，也方便比较大小和输出。

易错点：
- 第一个是要注意，k不能大于小红的满意值，不然就会变成负数，后果你应该知道的。

- 第二个是我们应该在第二层循环处设一个min，因为j必须小于i，不然他们看的比赛场数比现有的还要多，并且j还要小于K，不然他们看的场数比实际的还多。

- 第三个是一个傻傻的错误，反正除了我这种蒟蒻别人好像不会犯，那就是设置边界的时候一定要从0开始

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int C=2005,NKM=105;
int n,m,K,c,a[NKM],b[NKM],p[NKM],q[NKM],f[NKM][NKM][C],sum;
int main(){
	memset(f,-1,sizeof(f));
	cin>>n>>m>>K>>c;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=m;i++) cin>>p[i]>>q[i],sum+=(b[q[i]]+b[p[i]]);
	for(int i=0;i<=m;i++) f[i][0][0]=0;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=min(i,K);j++)
			for(int k=0;k<=sum;k++)
				if(k>=b[p[i]]+b[q[i]]&&f[i-1][j-1][k-(b[p[i]]+b[q[i]])]!=-1) f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[q[i]]*a[p[i]]);
				else f[i][j][k]=f[i-1][j][k];
	int ans=-1;
	for(int i=c;i<=sum;i++) ans=max(ans,f[m][K][i]);
	cout<<ans<<endl;
	return 0;
}  
```
看到这里可能有些机智的同学~~比如我~~就会发现这段代码怎么看怎么像背包。没错，其实这道题就是一道背包，我也是写完之后才发现的，小红的满意度就是重量，小明的满意度就是价格，不过我没有尝试过，有兴趣的同学可以参考楼上大佬的题解。

---

## 作者：bingliang (赞：2)

在此声明 本人蒟蒻 并不知道是否有  n^2做法

但是  n^3的一定正确   不过这题好像可以二分（显然本人并不知道，有想试下的朋友自己试下），再就是n^2复杂的的dp    对于一般的

分别记录两人看那场比赛的最大值是不行的   为啥呢？

就是说 因为   dp1和dp2之间互不影响 ，即两个都会算出其最大值，而不考虑另一个

就本题来说，就是说男的只注意精彩程度  ，妹子只注意  里面的帅哥的多少。   这显然是不行的。、

在说一遍  本人不知道有没有  更低复杂度的做法   如果有的话，恰巧本人也能想到可能会在多交几遍确定正确后，再发一篇题解的，。

现在简述下正解    其实一看数据范围   就知道本题很有可能是n^3的做法    想状态转移方程时考虑   必须将比赛的精彩程度   和里面帅哥的多少同时考虑到   所以是3维转移    即dp【i】【j】【k】  表示  对于   选择到了第i场比赛   已经选择了j场    达到了k个帅哥的要求   的所选出的比赛的最大精彩程度。

我最近一般不喜欢在题解里放代码。


---

## 作者：天南地北 (赞：1)

一道$01$背包问题。

## 思路

设置$f_i$,$_j$,$_k$为前$i$个选择看$j$场比赛，小红眼里的帅哥数量为$k$时，小明能够看到的比赛的精彩度的最大总和。

注意，由于小红只要看到的帅哥数量超过了$K$都算可行方案，所以我们可以先求出，帅哥数量为$0$到$\sum\limits_{i=1}^nb_p+b_q$的最大总和，

最后我们求出$f_m$,$_k$,$C$~$\sum\limits_{i=1}^nb_p+b_q$的最大值即可。

如何求出帅哥数量为$0$到$\sum\limits_{i=1}^nb_p+b_q$的最大总和？

不难想出状态转移方程：

$f[i][j][ij]=min\begin{cases}f[i-1][j][ij]&\\f[i-1][j-1][ij-v]+w&ij \geqq v\end{cases}$

其中$v$为当前比赛的帅哥数量$b_p+b_q$,$w$为精彩程度$a_p \times a_q$

参考程序段：
```cpp
#define rep(i,a,b) for(int i=a;i<=b;i++)

memset(f,128,sizeof f);
rep(i,0,m)
 	f[i][0][0]=0;
rep(i,1,m)
{
	int w=b[p[i]]+b[q[i]],v=a[p[i]]*a[q[i]];
	rep(j,1,i)
		rep(ij,0,maxs)//maxs是所有比赛帅哥程度的和
		{
			f[i][j][ij]=f[i-1][j][ij];
			if(ij>=w)f[i][j][ij]=max(f[i-1][j][ij],f[i-1][j-1][ij-w]+v);
		}		
}
```
时间复杂度 $O(n \times m\times maxs)$


------------


虽然说三维$DP$能过，但是这种算法就容易挂，毕竟$K$，$C$还是很小，所以我们来介绍一种新的方法：二维$DP$


设$f[i][j]$为进行了$i$次，使帅哥数量为$j$的最大精彩程度值。

同样的，不难求出：（相比上一种也就少了第一维）

$f[i][j]=min\begin{cases}f[i][j]&\\f[i-1][j-v]+w&\end{cases}$

其中$v$为当前比赛的帅哥数量$b_p+b_q$,$w$为精彩程度$a_p \times a_q$

参考程序段：
```cpp
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define drep(i,a,b) for(int i=a;i>=b;i--)

memset(f,128,sizeof f);
rep(i,0,m)
 	 f[i][0]=0;
rep(i,1,m)
{
	int v=b[p[i]]+b[q[i]],w=a[p[i]]*a[q[i]];
	drep(ij,maxs,v)
		rep(j,1,k)
			f[j][ij]=max(f[j][ij],f[j-1][ij-v]+w);
}
```
时间复杂度 $O(n \times m\times maxs)$

## 代码
三维$DP$
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define drep(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int maxn=100+10;
const int maxm=2000+10;

int n,m,k,c;
int a[maxn],b[maxn];
int p[maxn],q[maxn];
int f[maxn][maxn][maxm];
int maxs;
int ans=-1;
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>n>>m>>k>>c;
	rep(i,1,n)
		cin>>a[i];
	rep(i,1,n)
		cin>>b[i];
	rep(i,1,m)
		cin>>p[i]>>q[i],maxs+=b[p[i]]+b[q[i]];
	memset(f,128,sizeof f);
	rep(i,0,m)
 	   f[i][0][0]=0;
	rep(i,1,m)
	{
		int w=b[p[i]]+b[q[i]],v=a[p[i]]*a[q[i]];
		rep(j,1,i)
			rep(ij,0,maxs)
			{
				f[i][j][ij]=f[i-1][j][ij];
				if(ij>=w)f[i][j][ij]=max(f[i-1][j][ij],f[i-1][j-1][ij-w]+v);
			}		
	}
	rep(i,c,maxs)
        ans=max(ans,f[m][k][i]);
    printf("%d",ans);
	return 0;
}
```
------------

二维$DP$
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define drep(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int maxn=100+10;
const int maxm=2000+10;

int n,m,k,c;
int a[maxn],b[maxn];
int p[maxn],q[maxn];
int f[maxn][maxm];
int maxs;
int ans=-1;
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>n>>m>>k>>c;
	rep(i,1,n)
		cin>>a[i];
	rep(i,1,n)
		cin>>b[i];
	rep(i,1,m)
		cin>>p[i]>>q[i],maxs+=b[p[i]]+b[q[i]];
	memset(f,128,sizeof f);
	rep(i,0,m)
 	   f[i][0]=0;
	rep(i,1,m)
	{
		int v=b[p[i]]+b[q[i]],w=a[p[i]]*a[q[i]];
		drep(ij,maxs,v)
			rep(j,1,k)
				f[j][ij]=max(f[j][ij],f[j-1][ij-v]+w);
	}
	rep(i,c,maxs)
        ans=max(ans,f[k][i]);
    printf("%d",ans);
	return 0;
}
```


---

## 作者：linaonao (赞：1)

~~说实话，我也是被标题吸引进来的~~
## 思路
当你细细的读题，读个两三遍，你能从中品出背包的气味。

于是思路逐渐明了：将小红的精彩度当容积，将小明的精彩度当价值，要求的是容积超过$C$的背包最大价值。

递推式如下（十分好推）：
```cpp
f[i][j][k]=（k>=b[p[i]]+b[q[i]]）？（max(f[i-1][j][k],f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[p[i]]*a[q[i]])）：（f[i-1][j][k]）；
```


有几个注意点：

- 枚举容积时不能像通常背包一样从物品容积开始，而要从$0$开始枚举,因为若$C$值小于物品容积，即我们要输出$-1$时，按原来的方法枚举会无法转移，导致$WA$

- $f$数组初值要定极大的负值(即$memset128$)，因为递推式中$f$数组可能会从$-1$加到正值，影响结果（可以再脑中想象一下），这个地方我调可很久，一直是：

![](https://cdn.luogu.com.cn/upload/image_hosting/nkgjaykk.png)

最后贴一下代码：

## 代码
~~~cpp
#include<bits/stdc++.h>
template<typename T>inline void read(T &x){
	T f=0;x=0;char ch=getchar();
    for(;!isdigit(ch);ch=getchar())f|=ch=='-';
    for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    x=f?-x:x;
}
template<typename T>inline void write(T x){
	if(x<0){putchar('-');x=-x;}
	if(x>9)write(x/10); 
	putchar(x%10+48);
}
using namespace std;
int f[105][105][2005];
int a[105],b[105],p[105],q[105];
int n,m,kkk,c,sum;
int main(){
	read(n),read(m),read(kkk),read(c);
	memset(f,128,sizeof(f));	
	for(int i=0;i<=m;++i) f[i][0][0]=0;
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=1;i<=n;++i) read(b[i]);
	for(int i=1;i<=m;++i) read(p[i]),read(q[i]); 
	for(int i=1;i<=m;++i) sum+=b[p[i]]+b[q[i]];
	for(int i=1;i<=m;++i){
		for(int j=1;j<=i;++j){
			for(int k=0;k<=sum;++k){
				if(k>=b[p[i]]+b[q[i]]) f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[p[i]]*a[q[i]]);
				else f[i][j][k]=f[i-1][j][k];
			}
		}
	}	
	int maxn=-1;
	for(int i=c;i<=sum;++i){
		maxn=max(maxn,f[m][kkk][i]);
	}								
	write(maxn);								
	return 0;
}

~~~



---

## 作者：Night_Bringer (赞：0)

# 前言
[博客园食用更佳](https://www.cnblogs.com/C202202chenkelin/p/14216057.html)
# 题意
有 $n$ 只球队， $m$ 场比赛，有实力值 $a_i$ 和帅哥数 $b_i$ 。 $m$ 场比赛的输入格式为 $p_i$ $q_i$ 。有一男一女，男生认为精彩度为两比赛的实力乘积，女生认为是帅哥数之和。在女生认为的精彩度不少于 $c$ 时，男生认为的精彩度最大为多少，且两人最多能看 $k$ 场比赛。
# 思路
很简单，二维费用 $DP$ 。

设 $dp[i][j][k]$ ：枚举到第 $i$ 场比赛，共看了 $j$ 场比赛，女生认为精彩度为 $k$ 时，男生认为的精彩度的最大值。

显然，目标在 $dp[m][k][c]$ 至 $dp[m][k][sum]$ 之间，其中 $sum$ 为女生最大精彩度。

也不难推出状态转移方程：
$dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - 1][k - B[P[i]] - B[Q[i]]] + A[P[i]] * A[Q[i]])$

初始值为 $dp[i][0][0]=0(0≤i≤m)$ ，其余都为负无穷。
# C++代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
void Quick_Read(int &N) {
	N = 0;
	char c = getchar();
	int op = 1;
	while(c < '0' || c > '9') {
		if(op == '-')
			op = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		N = (N << 1) + (N << 3) + c - 48;
		c = getchar();
	}
	N *= op;
}
const int MAXN = 1e2 + 5;
const int MAXM = 2e3 + 5; 
int dp[MAXN][MAXN][MAXM];
int A[MAXN], B[MAXN], P[MAXN], Q[MAXN];
int n, m, k, c;
int sum;
void Read() {
	Quick_Read(n);
	Quick_Read(m);
	Quick_Read(k);
	Quick_Read(c);
	for(int i = 1; i <= n; i++)
		Quick_Read(A[i]);
	for(int i = 1; i <= n; i++)
		Quick_Read(B[i]);
	for(int i = 1; i <= m; i++) {
		Quick_Read(P[i]);
		Quick_Read(Q[i]);
		sum += B[P[i]] + B[Q[i]];
	}
}
void DP() {
	memset(dp, 128, sizeof(dp));
	for(int i = 0; i <= m; i++)
		dp[i][0][0] = 0;
	for(int i = 1; i <= m; i++) {
		for(int l = 1; l <= i; l++) {
			for(int j = 0; j <= sum; j++) {
				dp[i][l][j] = max(dp[i][l][j], dp[i - 1][l][j]);
				if(j - B[P[i]] - B[Q[i]] >= 0)
					dp[i][l][j] = max(dp[i - 1][l][j], dp[i - 1][l - 1][j - B[P[i]] - B[Q[i]]] + A[P[i]] * A[Q[i]]);
			}
		}
	}
	int ans = -1;
	for(int i = c; i <= sum; i++)
		ans = max(ans, dp[m][k][i]);
	printf("%d", ans);
}
int main() {
	Read();
	DP();
	return 0;
}
```

---

## 作者：Rorschachindark (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2113)
# 思路
其实开二维数组的 dp 的话，式子可以这样写：

$$f_{i+1,j}\to \max\{f_{i+1,j},f_{i,\min(c,j+b_p+b_q)}+a_p\times a_q\}$$

这样就没有什么空间问题了。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 105

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,m,k,c,a[MAXN],b[MAXN],dp[MAXN][1005];

void Mx (int &a,int b){a = max (a,b);}

signed main(){
	read (n,m,k,c);
	for (Int i = 1;i <= n;++ i) read (a[i]);
	for (Int i = 1;i <= n;++ i) read (b[i]);
	memset (dp,0xcf,sizeof (dp)),dp[0][0] = 0;
	for (Int i = 1,p,q;i <= m;++ i){
		read (p,q);
		for (Int j = min (k,i) - 1;~j;-- j)
			for (Int f = 0;f <= c;++ f)
				Mx (dp[j + 1][min (c,f + b[p] + b[q])],dp[j][f] + a[p] * a[q]);
	}
	int ans = -1;for (Int i = 0;i <= k;++ i) ans = max (ans,dp[i][c]);
	write (ans),putchar ('\n');
	return 0;
}
```
# P.S.
这可能我写过最水的题解吧。。。但是鉴于我错了 4 次，所以特此纪念。

---


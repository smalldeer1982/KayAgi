# [NOI2014] 起床困难综合症

## 题目描述

$21$ 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $\text{OR},\text{XOR},\text{AND}$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x~op~t$。最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。

由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,\ldots,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

## 说明/提示

【样例说明】

atm 可以选择的初始攻击力为 $0,1,\ldots ,10$。

假设初始攻击力为 $4$，最终攻击力经过了如下计算

- $4 \text{ AND } 5 = 4$；
- $4 \text{ OR } 6 = 6$；
- $6 \text{ XOR } 7 = 1$。

类似的，我们可以计算出初始攻击力为 $1,3,5,7,9$ 时最终攻击力为 $0$，初始攻击力为 $0,2,4,6,8,10$ 时最终攻击力为 $1$，因此atm的一次攻击最多使drd受到的伤害值为 $1$。

【数据规模与约定】

![](https://cdn.luogu.com.cn/upload/image_hosting/29yj7o58.png)

- 特殊性质 $\mathrm A$：存在一扇防御门为 $\texttt{AND 0}$；
- 特殊性质 $\mathrm B$：所有防御门的操作均相同。

对于所有数据，保证 $2\le n\le 10^5$，$0\le m\le 10^9$，$0\le t\le 10^9$，且 $\mathrm{op}$ 一定为 $\verb!AND!,\verb!OR!,\verb!XOR!$ 中的一种。


## 样例 #1

### 输入

```
3 10
AND 5
OR 6
XOR 7```

### 输出

```
1```

# 题解

## 作者：小粉兔 (赞：171)

比较方便的，我用了a1和a2两个变量表示二进制全0和全1经过门之后的样子。

之后的和其他人都差不多。可能是比较短的代码了。

贪心时就能用0换1就一定换，能用1换1也换，不能换别换就好了。

```cpp
#include<bits/stdc++.h>
int n,m,ans,x,a1=0,a2=-1;
char str[5];
int main(){
	scanf("%d%d",&n,&m);
	while(n--){
		scanf("%s%d",str,&x);
		if(str[0]=='A') a1&=x, a2&=x;
		if(str[0]=='X') a1^=x, a2^=x;
		if(str[0]=='O') a1|=x, a2|=x;
	}
	for(int j=29;~j;--j){
		if(a1>>j&1) ans+=1<<j;
		else if(a2>>j&1&&(1<<j)<=m) ans+=1<<j, m-=1<<j;
	} printf("%d",ans);
	return 0;
}
```

---

## 作者：cuking (赞：98)

发一个逻辑超简单的题解，如果不是为了读取字符串，连数组都不用

首先设两个变量，分别等于0x7fffffff和0，然后按照那些乱七八糟的门算一遍，最终得出来的就是一个每一位的真值表

然后贪心，从第二位开始（好像第三位就行？），因为M范围20亿，

对于每一位，真值表只能有四种

0->0,1->0

0->0,1->1

0->1,1->0

0->1,1->1

第一种就不说了，无懈可击

第二种防了跟没防一样

第三种是一种很奇怪的防御

第四种简直。。。

其实不用每种都判断

对于0能变1的两种情况，直接变1

对于0不变的情况，讨论1的两种变化

1->1的情况

这时候根据贪心原则，只要攻击力大于等于这一位需要的攻击力，就选

1->0比较尴尬，摆一边不管就行了

附上代码


```cpp
#include<stdio.h>
int main()
{
    int bool1=0x7fffffff,bool0=0;
    int N,M,t,i,ans=0;
    char ls[4];
    scanf("%d %d",&N,&M);
    while(N--)
    {
        scanf("%s%d",ls,&t);
        if(*ls=='A')
        {
            bool1&=t;
            bool0&=t;
        }
        else if(*ls=='O')
        {
            bool1|=t;
            bool0|=t;
        }
        else
        {
            bool1^=t;
            bool0^=t;
        }
    }
    for(i=30;i>=0;i--)
    {
        if(bool0&(1<<i))
        {
            ans+=1<<i;
        }
        else if(M>=(1<<i)&&(bool1&(1<<i)))
        {
            M-=1<<i;
            ans+=1<<i;
        }
    }
    printf("%d",ans);
}
```

---

## 作者：da32s1da (赞：73)

来介绍一个~~黑科技~~ 
### **bitset**
```
bitset用来存储二进制数位。像一个bool类型的数组一样，bitset每个元素只有0或1两个数值。
但是有空间优化——bitset中的一个元素一般只占1 bit。
bitset中的每个元素都能单独被访问,例如下面的代码：

输出格式
printf("%d\n",x.to_ulong());
cout<<x<<endl;

bitset<15>a,b(string("101")); //定义bitset，15是指有15位
a[10]=1;  //将第10位定义为1
输出a;
输出b;
a=101; //赋值a
输出a;

输出：
1024
000010000000000
5
000000000000101
101
000000001100101

可以看出，a[10]=1相当于+2^10。
而下面直接输出bitset就很玄妙。
另外，字符串可以直接转到bitset中。
有意思的是，bitset可以直接赋值！
当然也可以bitset<15>c(101)来赋值!

then

bitset<4> a ( string("1001"));
bitset<4> b ( string("0011"));

cout << (a^=b) << endl;       // 1010 
cout << (a&=b) << endl;       // 0010
cout << (a|=b) << endl;       // 0011 

cout << endl << a << endl;    // 0011
cout << b << endl << endl;    // 0011

cout << (a<<=2) << endl;      // 1100 
cout << (a>>=1) << endl;      // 0110

cout << endl << a << endl;    // 0110
cout << b << endl << endl;    // 0011

cout << (~b) << endl;         // 1100 
cout << (b<<1) << endl;       // 0110 
cout << (b>>1) << endl;       // 0001

cout << (a==b) << endl;       // false (0110==0011)
cout << (a!=b) << endl;       // true  (0110!=0011)

cout << (a&b) << endl;        // 0010
cout << (a|b) << endl;        // 0111
cout << (a^b) << endl;        // 0101

看完这些，估计您已经对bitset有个深刻的了解，它资瓷位运算！

then

对于一个叫做a的bitset：
a.size()      返回大小（位数）
a.count()     返回1的个数
a.any()       返回是否有1
a.none()      返回是否没有1
a.set()       全都变成1
a.set(p)      将第p+1位变成1
a.set(p, x)   将第p+1位变成x
a.reset()     全都变成0
a.reset(p)    将第p+1位变成0
a.flip()      全都取反
a.flip(p)     将第p+1位取反
a.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错
a.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错
a.to_string() 返回它转换为string的结果

嘿嘿，它还资瓷一大堆查询！

讲了这么多，还没放代码(⊙o⊙)…
#include<cstdio>
#include<bitset>
using namespace std;
bitset<30>a,b(1073741823),c;
int n,m,r;
char s[5];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%s%d",s,&r);
        if(s[0]=='A')a&=r,b&=r;
        if(s[0]=='O')a|=r,b|=r;
        if(s[0]=='X')a^=r,b^=r;
    }
    for(int i=0;i<30;i++)
    if(a[i]|(b[i]&&c.to_ulong()<m)) c[i]=1;
    printf("%d",c.to_ulong());
}
```

---

## 作者：Snitro (赞：36)


# [http://blog.csdn.net/Fine\_rose/article/details/78123157](http://blog.csdn.net/Fine\_rose/article/details/78123157)



解题报告


位运算具有一定的性质，元素之间不相互影响。假设一个数的二进制的第 x 位是 1 ，经过一系列位运算之后得到的数的二进制第 x 为是 0 ，那么只要一个二进制第 x 位是 1 的数，经过相同顺序的位运算，其得到的数的二进制的第 x 位置也一定是 0


由于二进制的每一位只有 0 和 1 两种可能性，我们可以预处理出每一位置是 0 或者是 1 所得到的结果，预处理之后使用下面的贪心思路


观察二进制每一位所代表的十进制的大小分别是：


··· ··· 16 8 4 2 1 0


可以发现的是每一位所代表的十进制数都等于其右侧所有位代表的十进制之和 +1


这说明我们可以按照顺序从左至右贪心，如果第 x 位经过一系列位运算操作之后能得到 1 ，那么第 x 位所放置的数一定是这个经过位运算得到 1 的数。因为如果第 x 位放置的数经过位运算之后得到了 0，那么即使之后的所有数经过位运算都得到了 1，其最后的造成的伤害量也一定会比第 x 位是 1 所造成的伤害量小，如果第 x 位放置 0 或 1 都可以得到 1，那么我们选择放置 0 ，因为这样会使初始攻击力更小，是之后的贪心操作有更大的选择范围


源代码





















```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, m;
int zero, one;
struct Door {
    int oper;//1:ans 2:or 3:xor
    int num;
} doors[100005];
int count(int num) { // 计算 num 作为初始值所能造成的攻击大小
    for (int i = 1; i <= n; i++) {
        if (doors[i].oper == 1)
            num = num & doors[i].num;
        else if (doors[i].oper == 2)
            num = num | doors[i].num;
        else
            num = num ^ doors[i].num;
    }
    return num;
}
int main() {
    freopen("in.txt", "r", stdin);
    scanf("%d%d", &n, &m);
    char temp[5];
    for (int i = 1; i <= n; i++) {
        scanf("%s%d", temp, &doors[i].num);
        if (temp[0] == 'A')
            doors[i].oper = 1;
        else if (temp[0] == 'O')
            doors[i].oper = 2;
        else
            doors[i].oper = 3;
    }
    zero = count(0);//计算所有位置都是 0 造成的攻击值
    int tem = 0, tot = 0;
    do {
        tem = tem << 1;
        tem |= 1;
        tot++; // 统计允许的最大的初始攻击值的二进制位数
    } while (tem < m);
    one = count(tem); // 计算所有位置都是 1 造成的攻击值
    int ans = 0;
    for (int j = tot - 1; j >= 0; j--) // 从左至右枚举每一位的情况
        if (!(zero & (1 << j)) && (one & (1 << j)) && (ans | (1 << j)) <= m)
        // 如果第 j 位放置 0 无法得到 1，但放置 1 可以得到 1 ，且满足放置 1 后小于限制的最大初始攻击值
            ans |= (1 << j);
    printf("%d", count(ans));
    return 0;
}
```

---

## 作者：pomelo_nene (赞：12)

在家里闲来无事做了一道题

作为NOI2014的签到题好像还是很好做的伐

切入题目

---

### 题目描述

21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。

由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在 0, 1, … , m中任选，但在通过防御门之后的攻击力不受m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。

### 输入格式

输入文件的第 1 行包含 2 个整数，依次为n, m，表示 drd 有n扇防御门，atm 的初始攻击力为0到m之间的整数。

接下来n行，依次表示每一扇防御门。每行包括一个字符串op和一个非负整数t，两者由一个空格隔开，且op在前，t在后，op表示该防御门所对应的操作，t表示对应的参数。

### 输出格式

输出一行一个整数，表示atm的一次攻击最多使drd受到多少伤害。

### 输入输出样例

#### 输入 #1

```
3 10
AND 5
OR 6
XOR 7
```

#### 输出 #1

```
1
```

我们首先面向数据编程，发现有30分的暴力分，有一个门是$AND$ $0$，操作相同，我们就得到60分了

我们这个时候就要想一下正解了

位运算有一个特别的性质，也就是二进制上面的每一位都不互相干扰

而我们想让我们的攻击力最大化，所以我们尽量让二进制高位上面的值为1，这样可以使值最大

准确的说：

> 我们想让这个值最大，我们想让这个数的每一位都是1，越高位上面的1值越大。所以我们尽量让高位上的值为1

举个例子：

有两个二进制数：10000,01111

你觉得哪个比较大？当然是第一个啦

这个位数可以是1，我们就让他是1，因为后面的全是1都赶不上他

也就是说我们的贪心策略出来了：

> 从高位往低位枚举，如果可以让这一位成为1，就让他成为1

于是乎，我们定义两个变量：一个为`0`，一个为`~0`=`compl 0`=`-1`，将这两个数按顺序经过所有的门

初始的攻击力只能被0,1组成，我们第一个变量也就是每一位初始选0经过所有门的伤害，第二个变量同理

我们可以根据这个去组织我们的答案

如果0能变1 就变了

否则

1变0 不管

否则如果这个值是小于等于m的 就变了

然后就完了

```cpp
#include<cstdio>
int main(){
	int n,m,x=0,y=(compl 0),s,tot=0;//定义变量，在二进制下一个全是1，一个全是0
	char a[5];
	scanf("%d %d",&n,&m);
	while(n--)
	{
		scanf("%s %d",a,&s);
		if(a[0]=='A')	x and_eq s,y and_eq s;
		else if(a[0]=='X')	x xor_eq s,y xor_eq s;
		else	x or_eq s,y or_eq s;
	}//经过防御门
	for(int i=30;compl i;--i)
	{
		if((x>>i) bitand 1)	tot+=1<<i;
		else if(y>>i&1 and (1<<i)<=m)	tot+=(1<<i),m-=(1<<i);
	}//贪心
	printf("%d",tot);//输出最大攻击
	return 0;
}
```

注意：我们是不需要知道我们要的初始攻击的


---

## 作者：Siyuan (赞：9)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io)

---

> 题目链接：[BZOJ 3668](https://www.lydsy.com/JudgeOnline/problem.php?id=3668)

在深邃的太平洋海底中，出现了一条名为 drd 的巨龙。历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 的防御战线由 $n$ 扇防御门组成。每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $\texttt{OR},\texttt{XOR},\texttt{AND}$ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x\ op\ t$（$x$ 和 $t$ 经过 $op$ 运算后的结果）。最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。

由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

数据范围：$2\leqslant n\leqslant 10^5$，$2\leqslant m\leqslant 10^9$，$0\leqslant t\leqslant 10^9$

------

## Solution

对于这种二进制的题目，由于每一位时完全独立的，所以第一感觉就是按位贪心！我们贪心 $m$ 的每一位的值，选择能够使答案的这一位最大的值就行了。

细节的处理：我们使用 $\texttt{DFS}$ 就行实现，这样可以方便处理贴紧上界的情况。如果对于 $m$ 这一位的所有取值，答案的这一位都相同，那么最小化 $m$。

**时间复杂度**：$O(n\log m)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int N=1e5+5;
int n,m,len,a[N],bin[31],ans,opt[2];
char s[N][5];

void init() {
    for(;m;m>>=1) bin[++len]=m&1;
    while(len<30) bin[++len]=0;
}
int solve(int d,int x) {
    for(int i=1;i<=n;++i) {
        char opt=s[i][1];
        int num=(a[i]>>(d-1))&1;
        if(opt=='A') x&=num;
        if(opt=='O') x|=num;
        if(opt=='X') x^=num;
    }
    return x;
}
void work(int len,bool full) {
    if(!len) return;
    int up=full?bin[len]:1;
    opt[0]=opt[1]=-1;
    for(int i=0;i<=up;++i) opt[i]=solve(len,i);
    ans+=std::max(opt[0],opt[1])*(1<<(len-1));
    if(!full) work(len-1,0);
    else work(len-1,bin[len]?(opt[1]>opt[0]):1);
}
int main() {
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=n;++i) scanf("%s%d",s[i]+1,&a[i]);
    work(len,1);
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：爷，无限霸气 (赞：7)

~~这应该能算是一道位运算好题~~

# 20分做法

~~当然是我们最美妙的做法：枚举~~

这是一种没有任何技巧的枚举。从一到m，依次过门，直接求最大值。（但是不知道为啥RE）

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 10005
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
ll n,m,maxx=-0x7f7f7f7f,l[Maxn];
string s[Maxn];
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		cin>>s[i];
		l[i]=read();
	 } 
	 for(ll i=1;i<=m;i++)
	 {
	 	ll sb=i;
	 	for(int j=1;j<=n;j++)
	 	{
	 		if(s[j][0]=='A') sb&=l[j];
	 		else if(s[j][0]=='O') sb|=l[j];
	 		else sb^=l[j];
		 }
	 	maxx=max(maxx,sb);
	  } 
	  cout<<maxx;
	return 0;
}
```

# 90分做法

其实这种做法已经超逼近正解了。

思路：要取最大值，能取1的都取1得到答案，位运算加快速度。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
ll n,m,fake1,fake2=0x7f7f7f7f,ans; 
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		string s;
		ll a;
		cin>>s;
		a=read();
		if(s[0]=='A') fake1&=a,fake2&=a;
		else if(s[0]=='O') fake1|=a,fake2|=a;
		else if(s[0]=='X') fake1^=a,fake2^=a;
	}
	for(int i=32;i>=0;i--)
	{
		if(fake1>>i&1) ans+=(1<<i);
		else if(fake2>>i&1&&(1<<i)<=m)
		{
			m-=1<<i;
			ans+=1<<i;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

# 满分做法

~~下载了数据过后~~

1.我们会发现90分做法左移会爆炸，第6个点答案会为0。因此我们考虑右移。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
ll n,m,fake1,fake2=-1,ans; 
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		string s;
		ll a;
		cin>>s;
		a=read();
		if(s[0]=='A') fake1&=a,fake2&=a;
		else if(s[0]=='O') fake1|=a,fake2|=a;
		else if(s[0]=='X') fake1^=a,fake2^=a;
	}
	for(int i=32;i>=0;i--)
	{
		if((fake1>>i)&1) ans+=(1<<i);
		else if((fake2>>i)&1&&m>>i)
		{
			m-=(1<<i);
			ans+=(1<<i);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

2.左移的1是int，所以爆炸，我们考虑把1改为long long

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
ll n,m,fake1,fake2=-1,ans; 
int main()
{
//	freopen("sleep5.in","r",stdin);
//	freopen("sleep5.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		string s;
		ll a;
		cin>>s;
		a=read();
		if(s[0]=='A') fake1&=a,fake2&=a;
		else if(s[0]=='O') fake1|=a,fake2|=a;
		else if(s[0]=='X') fake1^=a,fake2^=a;
	}
	for(int i=32;i>=0;i--)
	{
		if((fake1>>i)&1) ans+=(1<<i);
		else if((fake2>>i)&1&&(1ll<<i)<=m)
		{
			m-=(1<<i);
			ans+=(1<<i);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

3.提供一种非正解满分做法（~~可以说数据非常水了~~）

我当时脑子一抽，觉得32大了点，改为30就应该不会爆，但是这种做法条件是错的，可还能AC

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
ll n,m,fake1,fake2=-1,ans; 
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		string s;
		ll a;
		cin>>s;
		a=read();
		if(s[0]=='A') fake1&=a,fake2&=a;
		else if(s[0]=='O') fake1|=a,fake2|=a;
		else if(s[0]=='X') fake1^=a,fake2^=a;
	}
	for(int i=30;i>=0;i--)
	{
		if((fake1>>i)&1) ans+=(1<<i);
		else if((fake2>>i)&1&&(1<<i)<=m)
		{
			m-=(1<<i);
			ans+=(1<<i);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Drinkkk (赞：6)

【题目描述】

21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由$n$扇防御门组成。每扇防御门包括一个运算$op$和一个参数$t$，其中运算一定是$OR,XOR,AND$中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为$x$，则其通过这扇防御门后攻击力将变为$x$ $op$ $t$。最终drd受到的伤害为对方初始攻击力$x$依次经过所有$n$扇防御门后转变得到的攻击力。

由于atm水平有限，他的初始攻击力只能为$0$到$m$之间的一个整数（即他的初始攻击力只能在$0,1,......,m$中任选，但在通过防御门之后的攻击力不受$m$的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。

【输入输出格式】

- 输入格式
输入文件的第$1$行包含$2$个整数，依次为$n,m$，表示drd有$n$扇防御门，atm的初始攻击力为$0$到$m$之间的整数。

接下来$n$行，依次表示每一扇防御门。每行包括一个字符串$op$和一个非负整数$t$，两者由一个空格隔开，且$op$在前，$t$在后，$op$表示该防御门所对应的操作，$t$表示对应的参数。
- 输出格式
输出一行一个整数，表示atm的一次攻击最多使drd受到多少伤害。

【样例输入输出】
- 样例输入
```
3 10
AND 5
OR 6
XOR 7
```
- 样例输出
```
1
```

$30$分思路：

我们可以考虑直接暴力枚举atm的攻击力，即枚举$0,1,......,m$，再通过位运算来判断该攻击力可以给drd造成多少点的攻击。在这里我们设$ans$为一次攻击能使drd受到的伤害的最大值。那么每次枚举完每个攻击力后就可以取$max()$了，最后输出$ans$即可。这种方法的时间复杂度为$O(nm)$，显然会超时。

$100$分（满分）思路：

我们可以考虑将攻击力转换为二进制。
> 用二进制计算，从最高位开始贪心该位是否可以为1（我们希望每一位上都是1，这样结果最大），因为最高位大数的一定大，所以这种方法是正确的。

上文的引用部分摘自[@licone的博客](https://www.luogu.org/blog/user16334/)，
这种方法的时间复杂度为$O(n\;log_2\;m)$~

$30$分代码：
```cpp
#include <cstdio>
struct node{ int op,t; } f[1000001];
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int n=0,m=0;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        char st[10001];
        scanf("%s %d",st+1,&f[i].t);
        if(st[1]=='A')
        {
            f[i].op=1;
        }
        else if(st[1]=='O')
        {
            f[i].op=2;
        }
        else if(st[1]=='X')
        {
            f[i].op=3;
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++)
    {
        int da=i;
        for(int j=1;j<=n;j++)
        {
            if(f[j].op==1)
            {
                da=da&f[j].t;
            }
            else if(f[j].op==2)
            {
                da=da|f[j].t;
            }
            else if(f[j].op==3)
            {
                da=da^f[j].t;
            }
        }
        ans=max(ans,da);
    }
    printf("%d",ans);
    return 0;
}
```
$100$分代码：
```cpp
#include <cstdio>
struct node{ int op,t; } f[1000001];
int n=0,m=0;
int max(int x,int y)
{
    return x>y?x:y;
}
int sc(int da)
{
    for(int j=1;j<=n;j++)
    {
        if(f[j].op==1)
        {
            da=da&f[j].t;
        }
        else if(f[j].op==2)
        {
            da=da|f[j].t;
        }
        else if(f[j].op==3)
        {
            da=da^f[j].t;
        }
    }
    return da;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        char st[10001];
        scanf("%s %d",st+1,&f[i].t);
        if(st[1]=='A')
        {
            f[i].op=1;
        }
        else if(st[1]=='O')
        {
            f[i].op=2;
        }
        else if(st[1]=='X')
        {
            f[i].op=3;
        }
    }
    int ans=0;
    for(int i=32;i>=0;i--)
    {
        if(ans+(1<<i)>m)
        {
            continue;
        }
        if(sc(ans)<sc(ans+(1<<i)))
        {
            ans+=(1<<i);
        }
    }
    printf("%d",sc(ans));
    return 0;
}
```

---

## 作者：ljc20020730 (赞：4)

乱七八糟的描述~~

题意就是给定n个事件(opi,ti)，其中opi为and/or/xor三种位运算之一，ti为非负整数，要求在[0,m]中选择一个数x，最大化对x依次执行n个事件后的结果。

▶位运算的良好性质？

解：位运算每一位不互相干扰。

int找到31位，然后从后往前枚举，算每一位答案中取1或0的值，然后这个值对应这一位是1的话，只要检验答案加上这个值是不是超过m就可以了，就是这么个非常简单的贪心思路。

从高位到低位依次考虑答案的每一位，如果填上1以后超过m就只能填0，否则考虑填0或者1，进行暴力O(n)计算出结果。因为填0比填1对后面更有利，所以只有填1结果好于0时填1，否则填0。



```cpp
const maxn=100010;
var a,op:array[1..maxn]of longint;
    n,m,i,x,y,ans:longint;
    s:string[3];
function calc(x:longint):longint;
var i:longint;
begin
 for i:=1 to n do
 case op[i] of
  0:x:=x and a[i];
  1:x:=x or a[i];
  2:x:=x xor a[i];
 end;
 exit(x);
end;
begin
 readln(n,m);
 for i:=1 to n do begin
  readln(s,a[i]);
  case s[1] of
   'A':op[i]:=0;
   'O':op[i]:=1;
   'X':op[i]:=2;
  end;
 end;
 ans:=0;
 for i:=31 downto 0 do begin
  if ans+(1<<i)>m then continue;
  x:=calc(ans) and (1<<i);
  y:=calc(ans+1<<i) and (1<<i);
  if x<y then ans:=ans+(1<<i);
 end;
 ans:=calc(ans);
 writeln(ans);
end.

```

---

## 作者：Ciyang (赞：4)

#### 用了一个原创的做法, 模拟配合搜索, 非常玄学的过了这道题. 好像还没有这种做法的题解.

### 分析

题意比较好理解, 当我看到这句话:

> 最终受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力

依次经过N扇门是重点, 大大降低了这道题的难度. 

由此想到最为暴力的方法, 从1到M枚举每一个数, 然后模拟N个操作, 算出每个数最后的伤害取个最大. 复杂度$ O(NM) $ 太大了.

然后考虑到位运算的性质, 我们只需要求出每一个二进制位上的变化就行了, 然后再把这些位组合起来, 求出一个初始不大于M但最终最大的数. 这个组合可以用搜索, 复杂度大概是 $ O(N \log t + t) $

看数据范围, $\log t$ 比30小, 我使用一个数组$ num[31][2] $, 第一维代表二进制的位数, 第二维代表初始为 0 还是 1, 初始化这个数组.

然后可以$ O(n \log t) $ 在线预处理, 直接模拟就行了. 预处理后的num数组就是每一个二进制位的变化. 

然后就是求最终那个数, 因为M不是一个二的次幂, 所以不能循环求解, 但是可以用搜索.

如果学过01Trie, 上面的操作可以和它很相似, 求异或最大和本题的搜索的思路也类似. 然后加个条件判断和最优化剪枝就能完美通过本题了.

然后开int貌似会炸, 需要开long long, 但是最终答案应该是不会超int.

### 代码

未吸氧评测详情: Accepted  100

用时: 371ms / 内存: 932KB

```cpp
#include <iostream>
#include <stdio.h>
#include <limits.h>
using namespace std;
#define int long long
int n, m, tmpx, num[32][2];
char tmps[4];
int ans= -1;
void dfs(int nown, int total, int tmpans) {
	if(total > m || tmpans <= ans) return;
	if(nown == -1) {
		ans= tmpans;
		return;
	}
	dfs(nown - 1, total, tmpans + (num[nown][0] << nown));
	dfs(nown - 1, total + (1 << nown), tmpans + (num[nown][1] << nown));
	return;
}
signed main() {
	cin >> n >> m;
	for(int i= 0; i < 31; i++) num[i][1]= 1;
	for(int i= 0; i < n; i++) {
		cin >> tmps >> tmpx;
		for(int j= 0; j < 31; j++) {
			int ch= (tmpx >> j) & 1;
			if(tmps[0] == 'A')
				num[j][0]&= ch, num[j][1]&= ch;
			else if(tmps[0] == 'O')
				num[j][0]|= ch, num[j][1]|= ch;
			else
				num[j][0]^= ch, num[j][1]^= ch;
		}
	}
	dfs(30, 0, 0);
	cout << ans << endl;
	return 0;
}
```


---

## 作者：寒鸽儿 (赞：3)

对每一位进行枚举,由位运算的独立性,贪心相加即可。  
题目限制为不超过m,由于高位对答案的贡献较大,故字高位开始枚举,注意不能超过m.
构造：$a_0 = 0, a_1 = -1$(0xFFFFFFFF).整体异或所有值,然后&(1<<j)取出所有位进行贪心选择。  
$a_0 \& (1<<j), a_1 \& (1<<j)$  

代码:  
```cpp
#include <cstdio>

using namespace std;

int main() {
	int n, m, tmp, a0 = 0, a1 = -1, ans = 0;
	char s[5];
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; ++i) {
		scanf("%s %d", s, &tmp);
		if(s[0] == 'A') a0 &= tmp, a1 &= tmp;
		else if(s[0] == 'O') a0 |= tmp, a1 |= tmp;
		else a0 ^= tmp, a1 ^= tmp;
	}
	for(int j = 30; ~j; --j) {
		if(a0 & (1<<j)) ans += 1<<j;
		else if(m >= (1<<j) && a1 & (1<<j)) {
			m -= 1 << j;
			ans += 1 << j;
		}
	}
	printf("%d\n", ans);
	return 0;
} 
```

---

## 作者：fαns (赞：2)

先简单吐槽一下：这道题题面搞这么长干啥，看的让人累的
~~（难道是传说中出题人绝招之一：就算是水题也要浪费你的时间）~~

好了，言归正传，这道题就考个基本位运算，先预处理出来全0和全1的结果，就可以得到**初始**每一位为**0/1**时的结果，然后我们可以将结果分成这几种情况：

1°原本是0，现在变成了1，这种情况下肯定选

2°原本是1，现在变成了0，这种情况肯定不选

3°原本是1，现在还是1，这种情况看满不满足题目条件，也就是需要(tmp+(1<<i))<=m（tmp为初始原本的值，i为当前是第几位。）

好了，就这么结束了，下面见代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define re register
#define For(i, s, e) for(re int i = s;i <= e;i++)
#define Refor(i, s, e) for(re int i = s;i >= e;i--)
#define Fore(i, u) for(re int i = head[u];i;i = edge[i].next)
using namespace std;
template<class T> inline void read(T &f){
	char ch = getchar(); int w = 1;
	while (ch < '0' || ch > '9') (ch == '-') && (w = -1), ch = getchar();
	for (f = 0;ch >= '0' && ch <= '9';f = (f << 3) + (f << 1) + ch - 48, ch = getchar());
	f = f * w;
}
int main(){
	int a = 0, b = -1, n, m, len = 0, tmp = 0; read(n); read(m);
	For(i, 1, n){
		string c; int t; cin >> c; read(t);
		if (c == "AND") a &= t, b &= t;
		if (c == "OR") a |= t, b |= t;
		if (c == "XOR") a ^= t, b ^= t;
	}
	int ans = 0;
	Refor(i, 30, 1){
  		if (a & (1 << i - 1)) ans += 1 << i - 1;
  		else if ((b & (1 << i - 1)) && (tmp + (1 << i - 1) <= m)) ans += 1 << i - 1, tmp += 1 << i - 1;
 	}
 	printf("%d", ans);
	return 0;
}
```


---

## 作者：STPGUY (赞：2)

 看见别的大佬的代码~~我都自卑了~~

于是我来写一篇我看得懂的emmm

 大概思路呢是：

# 模拟~~bàolì~~
```cpp
int Ans[i][2];//用这玩意儿来存最后攻击力(二进制下)第i为是0还是1

```

### So 这个需要初始化：

```cpp

    Max = log2(M);
    for (int i = 0; i <= Max; ++i)Ans[i][1] = 1;//i的最大值是log2(M)
```


### 然后暴力(~~只会暴力emmmmm~~)：

```cpp

#define Work(X) for (int i(0); i < 31; ++i)\
                {                               \
                    Ans[i][0] = Ans[i][0] X T%2,\
                    Ans[i][1] = Ans[i][1] X T%2;\
                    if (T)T >>= 1;              \
                }	
    //万恶的宏，确实是挺好用的
    ...
    for (int i(0); i < N; ++i)
    {
        scanf("%s %d", Opt, &T);
        if (Opt[0] == 'A')Work(&)
        else if(Opt[0] == 'O')Work(|)
        else if(Opt[0] == 'X')Work(^)
    }


```
# CodeTime
```cpp
#include <stdio.h>
#include <math.h>
#define Work(X) for (int i(0); i < 31; ++i)\
                {                               \
                    Ans[i][0] = Ans[i][0] X T%2,\
                    Ans[i][1] = Ans[i][1] X T%2;\
                    if (T)T >>= 1;              \
                }

int N, M, T, Max, Temp(1), Sum;
int Ans[35][2];
char Opt[10];

int main()
{
    scanf("%d %d", &N, &M);
    Max = log2(M);
    for (int i = 0; i <= Max; ++i)Ans[i][1] = 1;
    for (int i(0); i < N; ++i)
    {
        scanf("%s %d", Opt, &T);
        if (Opt[0] == 'A')Work(&)
        else if(Opt[0] == 'O')Work(|)
        else if(Opt[0] == 'X')Work(^)
    }
    for (int i = 0; i < 31; ++i, Temp <<= 1)
        if (Ans[i][1] || Ans[i][0])Sum += Temp;//如果最后是1，不管是谁都加了
        //这还能通过Ans数组找到最开始的那些数字呢
    printf("%d\n", Sum);
}
```

---

## 作者：破忆 (赞：2)

题面看起来很~~啰嗦~~复杂，稍微理一下思路，其实就是给定一系列的二进制运算，让一个范围内的数经过这些运算之后所得结果最大。

题目中的数据范围很大，显然不能单纯地逐个枚举。
再看题目，但因为这些运算都是位运算，所以我们按位枚举。
 
下面重温一下这些运算

AND : 有假则假
OR：有真则真
XOR：相同为假，不同为真
 
如果只考虑一位，只需把0和1作为初始值进行运算即可。
假设x代表1，y代表0
```
	
int x=1,y=0;
for(int j=1;j<=n;j++){
	if(c[j]=='A') x&=a[j],y&=a[j];else
	if(c[j]=='O') x|=a[j],y|=a[j];else
	if(c[j]=='X') x^=a[j],y^=a[j];
}
```
按照贪心的原则

如果0能得出1，果断选择0。
否则，如果1能得出1且答案加上1不会超过范围，就选择1。
```
if((y>>i)&1) ans+=1<<i;else
if(((x>>i)&1)&&s+(1<<i)<=m) ans+=1<<i,s+=1<<i;
```
下面附上完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int n,m,s,ans,a[maxn];
char c[maxn];
char gc(){
	static char buf[10000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;
}
int read(){
	int ret=0,f=1;char ch=gc();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=gc();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=gc();
	return ret*f;
}
int main(){
// 	freopen("2114.in","r",stdin);
// 	freopen("2114.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		c[i]=gc();
		while(c[i]!='A'&&c[i]!='O'&&c[i]!='X') c[i]=gc();
		a[i]=read();
	}
	for(int i=30;i>=0;i--){
		int x=1<<i,y=0;
		for(int j=1;j<=n;j++){
			if(c[j]=='A') x&=a[j],y&=a[j];else
			if(c[j]=='O') x|=a[j],y|=a[j];else
			if(c[j]=='X') x^=a[j],y^=a[j];
		}
		if((y>>i)&1) ans+=1<<i;else
		if(((x>>i)&1)&&s+(1<<i)<=m) ans+=1<<i,s+=1<<i;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：顾z (赞：2)

~~老年退役选手发来问候~~

**二进制相关,考虑拆位。**

这个题中,我们要做的就是钦定初始攻击力,经过^&|操作之后得到的值最大。

我们**从高位向低位枚举二进制每一位,判断加上当前位之后的答案是否会更优**。

最后输出初始攻击力经过传送门之后的值即可。

``代码``

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#define R register

using namespace std;

const int gz=1e5+8;

inline void in(R int &x)
{
	R int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

char op[15];

int t[gz],ans,n,m,ot[gz];

inline int c(R int x)
{
	for(R int i=1;i<=n;i++)
	{
		if(ot[i]==1)x&=t[i];
		else if(ot[i]==3)x^=t[i];
		else x|=t[i];
	}
	return x;
}

int main()
{
	in(n),in(m);
	for(R int i=1;i<=n;i++)
	{
		scanf("%s",op+1);
		if(op[1]=='A')ot[i]=1;
		else if(op[1]=='X')ot[i]=3;
		else ot[i]=2;
		in(t[i]);
	}
	for(R int i=30;~i;i--)
	{
		if((ans+(1<<i))>m)continue;
		if( c(ans) < c(ans+(1<<i)))
				ans+=(1<<i);
	}
	printf("%d",c(ans));
}
```



---

## 作者：Strelitzia (赞：1)

#### 题目传送门

$\ \ \ \ $[起床困难综合症](https://www.luogu.com.cn/problem/P2114)

-------------------

$\ \ \ \ $小蒟蒻认为是一道很好的贪心与位运算的题。

$\ \ \ \ $首先，我们要知道位运算的特点——是一位一位的。

$\ \ \ \ $且不会影响到其他位。

------------------

#### 基本思路

$\ \ \ \ $了解到这些性质后，有一个初步的想法。

$\ \ \ \ $我们对于每一位分别处理。

$\ \ \ \ $因为每一位只可能是$0$或$1$，所以只需分析每位是$0$或$1$。

$\ \ \ \ $每一位经历对应的位运算，取较大值。

$\ \ \ \ $变量解释：initial是0-m的一个值，ans是最大伤害

$\ \ \ \ $a是每一道防御门的信息，now1是这位为1的经运算值，now0亦是如此

$\ \ \ \ $temporary是t对应位的值，result1和result0是返回结果

$\ \ \ \ $代码中有一个比较重要的点，也是贪心的地方

```cpp
if (initial + (1 << i) <= m && result1 > result2) { 		//限定这个数是0-m之间
	initial += (1 << i);
	ans += result1 << i;
}
else {
	ans += result2 << i;
}

```

$\ \ \ \ $代码如下：


```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	T f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
int n,m,tmp,ans,initial;
char s[10];
pair<char,int> a[100005];
pair<int,int> operation(int k) {
	int now1 = 1,now0 = 0;
	for (int i = 1 ; i <= n ; ++ i) {
		int temporary = (a[i].second >> k) & 1;
		if (a[i].first == 'A') now1 &= temporary,now0 &= temporary;
		else if (a[i].first == 'O') now1 |= temporary,now0 |= temporary;
		else now1 ^= temporary,now0 ^= temporary;
	}
	return make_pair(now1,now0);
} 
int main() {
	read(n);read(m);
	for (int i = 1 ; i <= n ; ++ i) {
		scanf ("%s",s);
		read(tmp);
		a[i] = make_pair(s[0],tmp);
	}
	for (int i = 30 ; i >= 0 ; -- i) {
		pair<int,int> result = operation(i);
		int result1 = result.first;
		int result2 = result.second;
		if (initial + (1 << i) <= m && result1 > result2) {
			initial += (1 << i);
			ans += result1 << i;
		}
		else {
			ans += result2 << i;
		}
	}
	print(ans);
	return 0;
}
```

$\ \ \ \ $谢谢大家

---

## 作者：Deny_小田 (赞：1)

注意位运算，代码有注释

参考链接：

http://blog.csdn.net/sdfzyhx/article/details/52176710

代码：







```cpp
//1 << i = 2^i;
#include <cstdio>
const int size = 100005;
char s[5];
int operation[size],a[size],ans = 0,n,m,x,y;
int calculate(int x){
    for(int i = 1; i <= n; i++){
        if(operation[i] == 0) x &= a[i];                //即s == 'AND'
        if(operation[i] == 1) x |= a[i];                //即s == 'OR'
        if(operation[i] == 2) x ^= a[i];                //即s == 'XOR' 
    }
    return x;
}
int main(int argc, char const *argv[]){
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%s %d",s,&a[i]);
        if(s[0] == 'A') operation[i] = 0;            //s == 'AND'
        if(s[0] == 'O') operation[i] = 1;            //s == 'OR'
        if(s[0] == 'X') operation[i] = 2;            //s == 'XOR'
    }
    for(int i = 31; i >= 0; i--){                //暴力枚举，因为 1 << 31以上炸int，所以从 1 << 31开始
        if(ans+(1 << i) > m) continue;        //1 << i = 2^i
        //calculate()函数用来计算经过这扇门之后的 攻击力
        x = calculate(ans)&(1 << i);
        y = calculate(ans+(1 << i))&(1 << i);
        if(x < y) ans += 1 << i;
    }
    //计算最大攻击力
    printf("%d\n",calculate(ans));
    return 0;
}
```

---

## 作者：licone (赞：1)

用二进制计算，从最高位开始贪心该位是否可以为1（我们希望每一位上都是1，这样结果最大），因为最高位大数的一定大，所以这种方法是正确的。


还有就是位运算，并不常用呢。（详见<http://blog.csdn.net/senyelicone/article/details/52196039> ~）


注意位运算优先级小，要加括号。





```cpp
#include<cstdio>
#include<cstring>
int a[100006],n,m,ans,b[100006];
int kk(int u)
{
    for(int i=1;i<=n;i++)
      if(a[i]==1) u&=b[i];
      else if(a[i]==2) u|=b[i];
      else u^=b[i];
    return u;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        char ch[3];
        scanf("%s%d",ch,&b[i]);
        if(ch[0]=='A') a[i]=1;
        else if(ch[0]=='O') a[i]=2;
        else a[i]=3;
    }
    for(int i=30;i>=0;i--)
    {
        if((ans+(1<<i))>m) continue;
        if(kk(ans)<kk(ans+(1<<i))) ans+=(1<<i);
    }
    printf("%d\n",kk(ans));
    return 0;
}

```

---

## 作者：Mr_Li (赞：1)

如果不知道位运算的人可能不知道OR，XOR，AND的意思，他们分别代表按位或运算、按位异或运算、按位且运算。具体可以@度娘，这里不多解释。

首先，假设m=∞，并在求出drd受到的最大伤害p的同时求出在drd受到伤害最大的情况下最小初始攻击力q是多少。由于所有运算都是位运算，所以我们可以分别考虑每一位。我们希望每一位上都等于1，所以**对于每一位**，我们要计算什么数通过第n扇防御门后会变成1，如果所有数都能在通过此防御门后变为1，则p为1，由于它不影响最后结果，所以令q为0；如果所有数都不能在通过此防御门后变为1，则p为0，与前文同理，令q为0；如果有且仅有二进制数x能在通过此防御门后变为1，则计算什么数通过第n-1扇防御门后会变成x，方法与前文同理。时间复杂度为O(n▪log(max(m,t)))，不会超时。

现在回到原题，由于atm水平有限，初始攻击力必须小于等于m。我们可以发现，若q在二进制下的第x位为1，则p在二进制下的第x位也为1（请读者自己证明）。所以从q的高位找起，找到1之后判断，如果保留该位及其所有高位的q大于m，（1001010保留左起第四位及其所有高位后的数为1001000）则删掉该位和p中对应的那一位；（1001010删掉左起第四位后的数为1000010，删掉101010中对应的那一位，即左起第四位为101010）否则，不进行任何操作。可以证明，修改后的p就是drd受到的最大伤害，修改后的q就是drd受到伤害p最大的情况下的最小初始攻击力。时间复杂度为O(log(m,t))，也不会超时。

由于我们很少使用位运算，所以写代码的时候可能会慢一点，但正确的算法还是很容易想到的。


---

## 作者：FZzzz (赞：0)

~~众所周知，这题是 P5354 的弱化版。~~

做 P5354 的时候~~由于算错正解复杂度~~ yy 了这个做法，然后看了看题解发现之前做法就是正解。然后用我自己 yy 的做法又水过了一遍，于是来到这里发题解。

------------
下面说正题。

首先~~根据 P5354~~ 我们可以先把每一位 $0$ 和 $1$ 过去之后的值记录下来再说。

然后是贪心思想，这个没问题。

~~但是他让你贪心你就贪心啊，~~ 我们想一下这个贪心的性质。

假设现在考虑到某一位，前面选的和 $m$ 一模一样。

那么这一位有几种可能：
- 这一位 $m$ 是 $0$。

那没办法，只能选 $0$，不然就大了。
- 这一位 $m$ 是 $1$，选 $1$ 严格优于选 $0$。

那么根据贪心，选 $1$。
- 这一位 $m$ 是 $1$，选 $0$ 严格优于选 $1$。

必须选 $0$。
- 这一位 $m$ 是 $1$，选 $0$ 和 $1$ 没区别。

这样本来是无所谓的，但是注意到这一种和上一种情况，选完 $0$ 之后后面再怎么选都不会比 $m$ 要大，所以选 $0$ 最优。

综上，我们可以找出第一个 **$m$ 为 $1$ 且选 $0$ 不差于选 $1$** 的位，然后前面就和 $m$ 一模一样，后面就怎么选都可以了。

看代码吧：
```cpp
#include<cctype>
#include<cstdio>
using namespace std;
typedef unsigned long long ull;
inline ull readint(){
    ull x=0;
    bool f=0;
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    if(c=='-'){
        f=1;
        c=getchar();
    }
    while(isdigit(c)){
        x=x*10+c-'0';
        c=getchar();
    }
    return f?-x:x;
}
int n,m;
inline char readchar(){
	char c=getchar();
	while(isspace(c)) c=getchar();
	return c;
}
int main(){
    #ifdef LOCAL
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
    n=readint();
    m=readint();
    int ans0=0,ans1=~0;//记录全0和全1过去之后的值
    while(n--){
    	char op=readchar();
    	int t=readint();
    	if(op=='A'){
    		ans0&=t;
    		ans1&=t;
		}
    	else if(op=='O'){
    		ans0|=t;
    		ans1|=t;
		}
		else{
			ans0^=t;
    		ans1^=t;
		}
	}
	int high0=-1;//最高满足条件的位
	int ansm=((~m)&ans0)|(m&ans1);//m过去之后的结果
	for(int i=0;i<=30;i++) if(((m&(ans0|~ansm))>>i)&1) high0=i;
    //ans0|~ansm即为选0不差于选m这一位（其实因为有&m所以就是1）的值
	if(high0<0) printf("%d\n",ansm);//如果没有符合条件的位就跟m一模一样
	else printf("%d\n",ansm|((ans0|ans1)&(((1<<high0)-1)|(1<<high0))));
	//ans0|ans1代表随便选最优的，&(((1<<high0)-1)|(1<<high0))限制只有最后high0位能这么选 
    return 0;
}
```
没卡常，似乎比大多数正常做法快不少？

upd：稍微改了一下写法，开了 O2 进了最优解第五面。

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P2114)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这种题，应该可以瞬间想到将每一位分开搞。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于每一位，处理出最开始为$1$或$0$，经过了门之后的结果。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后对于每一位，如果存在能放$1$的位置，并且放了$1$之后起始的战斗力不会超过$m$，那么我们就放$1$；如果都能放$1$，选择能使$m$更小的放。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个贪心基于一个简单的事实：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle 2^n>\sum_{i=0}^{n-1}2^i$
# 代码
```cpp
#include <cmath>
#include <cstdio>

const int MAXN = 1e5 + 5, MAXLOG = 35;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar(); int f = 1;
	while( s < '0' || '9' < s ){ f = 1; if( s == '-' ) f = -1; s = getchar(); }
	while( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ), x = -x; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

template<typename _T>
_T MAX( const _T a, const _T b ) 
{
	return a > b ? a : b;
}

int op[MAXN], t[MAXN];
int N, M, lg2;

int main()
{
	char str[10];
	int mx;
	read( N ), read( M );
	mx = M;
	for( int i = 1 ; i <= N ; i ++ )
	{
		scanf( "%s%d", str, &t[i] );
		if( str[0] == 'A' ) op[i] = 1;
		if( str[0] == 'O' ) op[i] = 2;
		if( str[0] == 'X' ) op[i] = 3;
		mx = MAX( mx, t[i] );
	}
	lg2 = log2( mx );
	int las = 0, res = 0, tmp, tmpl;
	int n[2], nb;
	for( int j = lg2 ; j > -1 ; j -- )
	{
		n[0] = 0, n[1] = 1;
		for( int i = 1 ; i <= N ; i ++ )
		{
			nb = ( t[i] >> j ) & 1;
			for( int k = 0 ; k < 2 ; k ++ )
			{
				if( op[i] == 1 ) n[k] = n[k] & nb;
				if( op[i] == 2 ) n[k] = n[k] | nb;
				if( op[i] == 3 ) n[k] = n[k] ^ nb;
			}
		}
		tmp = res, tmpl = las;
		for( int k = 1 ; ~ k ; k -- )
		{
			if( n[k] == 1 )
				if( tmpl + k * ( 1 << j ) <= M )
					res = tmp + ( 1 << j ), las = tmpl + k * ( 1 << j );
		}
	}
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：caoboqun (赞：0)

没想到这是一道NOI题......

操作数看起来非常之大啊....当然是位运算了！

把这个数chai成32位不就行了......

然鹅用了一个bitset,这个用数组就行(;;)

好了下面介绍算法！

拆位以后再看指令：
如果是“or 1” 就是 1,“and 0” 就是 0

所以可以这样算

1.拆位（你懂的）

2.从前往后扫描：
	
    	如果有"or 1" 将答案设为1
        	如果有"and 0" 将答案设为0
          	如果有xor，只是取反，记录"xor 1"的奇偶性
            递推
3.还原出答案: - )

好了上代码: - ) (ans降了维)

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(0)
using namespace std;
#define ll long long
ll b;
string op[100010];
bitset<50> a[100010];
bitset<50> ans;
int x[40];
bool is_marked[40];
int main()
{
	ll n,m,tmp;
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=n;i++)
	{
		cin>>op[i];
		scanf("%lld",&tmp);
		int cnt=0;
		while (tmp>0)
		{
			a[i][cnt]=tmp&1;
			tmp>>=1;
			cnt++;
		}
	}
	for (int i=1;i<=n;i++)
	{
		if (op[i]=="OR")
			for (int j=0;j<32;j++)
				if (a[i][j]) ans[j]=1,is_marked[j]=true;
				else ans[j]=a[i][j]|ans[j];
		if (op[i]=="AND")
			for (int j=0;j<32;j++)
				if (!a[i][j]) ans[j]=0,is_marked[j]=true;
				else ans[j]=a[i][j]&ans[j];
		if (op[i]=="XOR") 
			for (int j=0;j<32;j++)
				if (!is_marked[j])
				{
					if (a[i][j]) x[j]^=1;
					ans[j]=ans[j];
				}
				else ans[j]=a[i][j]^ans[j];
	}
	for (int i=30;i>=0;i--)
	{
		if (!is_marked[i])
		{
			int p=x[i]^1;
			if (p&&m>=1LL*(1<<i)*p||!p) ans[i]=1,m-=1LL*(1<<i)*p;
			else ans[i]=0;
		}
	}
	ll ANS=0;
	for (int i=30;i>=0;i--) ANS=(ANS<<1)+ans[i];
	printf("%lld",ANS);
	return 0;
}

```



---

## 作者：Vasily (赞：0)

自己想出一种神奇的贪心


首先，既然是一大堆^&|啊什么什么的东西，那么自然要想到转二进制乱搞了~

（考虑到是二进制，那么下面的陈述一律使用二进制下）

所有0~m的伤害，每一个经过东搞西搞的转化后，都会有一个特点：

令当前输出的初始伤害有len[0]位，从1~n的转换值有len[i]位（注意是二进制），那么，最终这个转换后的伤害的长度应该是max(len) 。

其实，所有len[0]的最大值就是m的位数，那么，所有转换后伤害的长度的最大值显然了。


为什么要考虑数位长度呢？

因为这是可以用贪心的啊！答案每一位无非就是0或者1，所以，针对每一位，选一个数（0或者1）把答案的这一位尽量搞成1就行了（除非选0和1都不能让答案为1）。这样，一位一位拼凑出来的答案一定就是最优解了！


等等！如果我的选择是初始输出101110，但是我的m限制确实100110怎么办！

也就是说，上述算法有可能会超出m的范围。


再考虑一点：对于二进制数A=1XX......，所有的0XX......都是小于A的（后面那个XX......表示随便什么什么都可以，但是前后两个是一样的）。


那么，设m有len位。我们的答案就只需要后面len-1位找就起码可以保证不会超出范围了（也就是强制把m的最高位看做0）。

但还是会留下一部分数啊，怎么办？

显然，假设选取的初始输出的最高位就是1，然后再往后在限制条件里找。


限制条件是什么呢？

如果当前m的这一位是0，那么我选取数的这一位就只可能是0。（这很显然）

如果当前m的这一位是1，那么我就可以选择1或0。

根据贪心法，我们的选择是选收益高的（谁能把答案的这一位搞成1就选谁），还有一个要注意到的地方，如果在1的限制下选1或0把答案都是搞成相同的数，一定选0（因为后面的数可以随意选了，更有“前途”原因见A=1XX......那里）。


最后，再把初始输出最高位选1和0得出的两个答案取最大，就是最终结果了。


<----以上就是我的思考过程，有木有懂了呢？

然后附代码：


```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std ;
const int maxn = 1e5+10, maxm = 31 ;
struct op{ //记录每一次操作详情 operation
    char d ; //哪一种运算 doing
    int val ; //一开始是存储运算的值（value），后来为了毫无意义的节省空间，又换了个用处
    bool v[maxm] ; //二进制存储运算的值（value）
} o[maxn] ; //数组名称的意思是operation
bool ok[2][maxm] ; //ok[i][j]用来记录初始输出第j位是i时，获得的最终结果
char cha[10] ; //用来输入而已
int n, m, max_len = -1 ; //max_len就是上述的最大长度
void dec ( int x ) { //分解
    int len = 0, val = o[x].val ;
    while (val) {
        o[x].v[++len] = val&1 ;
        val >>= 1 ;
    }
    o[x].val = len ;
}
bool limit[40] ; //m产生的每一位的限制（二进制）
void Pre() { //预处理出ok数组
    int i, j, k ;
    for ( k = 1 ; k <= max_len ; k ++ ) //枚举长度
        for ( j = 0 ; j < 2 ; j ++ ) { //选取的数
            bool ans = j ;
            for ( i = 1 ; i <= n ; i ++ ) { //一共进行n次变化
                if ( o[i].d == 'A' ) ans &= o[i].v[k] ;
                else if ( o[i].d == 'O' ) ans |= o[i].v[k] ;
                else if ( o[i].d == 'X' ) ans ^= o[i].v[k] ;
            }
            ok[j][k] = ans ;    
        }
}
int main() {
    int i, j, k, len = 0 ;
    scanf ( "%d%d", &n, &m ) ;
    for ( i = 1 ; i <= n ; i ++ ) { 
        scanf ( "%s %d", cha, &o[i].val ) ;
        o[i].d = cha[0] ; //由于每个开头字母就不一样，存第一个就够了
    }
    for ( i = 1 ; i <= n ; i ++ ) { //依次分解并记录最大长度
        dec(i) ; 
        if ( o[i].val > max_len ) max_len = o[i].val ;
    }
    while (m) { //计算limit[]
        limit[++len] = m&1 ;
        m >>= 1 ;
    }
    max_len = max ( len, max_len ) ;//别忘了m的长度
    Pre() ; //预处理ok[][]
    int ans1, ans2 ;
    //ans1是存储假设最高位不是1的答案
    ans1 = ans2 = 0 ;
    //ans2是存储最高位是1的答案
    for ( i = len-1 ; i > 0 ; i -- ) 
        ans1 += ( max(ok[0][i],ok[1][i])<<i-1 ) ;
    //无脑计算ans1
    bool is_lim = true ; //表示是否受到限制
    for ( i = max_len ; i ; i -- ) 
        if ( is_lim ) { //略有麻烦，自己看看就能懂
            if ( !limit[i] ) ans2 += ( ok[0][i]<<i-1 ) ;
            else {
                if ( ok[0][i] >= ok[1][i] ) {
                    is_lim = false ;
                    ans2 += ( ok[0][i]<<i-1 ) ;
                } else ans2 += ( ok[1][i]<<i-1 ) ;
            }
        } else ans2 += ( max(ok[0][i],ok[1][i])<<i-1 ) ; //如果已经可以随便选，就无脑乱搞
    printf ( "%d\n", max ( ans1, ans2 ) ) ; //选取最优
    return 0 ;
}
```

---

## 作者：WenDavid (赞：0)

具体的解释下面的那位已经说的很清楚了，所以我就贴一份代码吧，作为NOI2015的题目，还是挺简单的。

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
inline ll read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}
    return x*f;
}
int n,m,a[100005],b[100005],f[35],ans,tot;
int cal(int x)
{
    for(int i=1;i<=n;i++)
        if(a[i]==1)x=(x&b[i]);
        else if(a[i]==2)x=(x|b[i]);
        else x=(x^b[i]);
    return x;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)
    {
        char ch[5];
        scanf("%s",ch);
        if(ch[0]=='A')a[i]=1;
        else if(ch[0]=='O')a[i]=2;
        else a[i]=3;
        b[i]=read();
    }
    int t=cal(0);
    for(int i=0;i<=30;i++)f[i]=(cal(1<<i)&(1<<i));
    for(int i=30;i>=0;i--)
    {
        if((1<<i)&t)ans+=(1<<i);
        else if((tot+(1<<i)<=m)&&f[i])
        {
            tot+=f[i];
            ans+=f[i];
        }
    }
    printf("%d",ans);
    return 0;
}

```

---


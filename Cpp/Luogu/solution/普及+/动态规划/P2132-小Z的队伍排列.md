# 小Z的队伍排列

## 题目描述

小 Z 想给班里的同学拍一张合影，为此需要先让大家排好队伍。他希望大家站成 $k$ 排，并规定了每排的人数，保证每一排的人数都不多于后面一排的人数。

这时小 Z 发现队伍看起来还是乱糟糟的，原因是大家的身高互不相同。于是，他希望排头对齐，每位同学都比自己正后方的同学以及排头方向的同学矮。

排完以后，善于思考的小 Z 还想知道一共有多少种排法。

例如，大家排成 $3$ 排，且从后往前每排分别是 $3$ 、 $2$ 、 $1$ 人，就有以下 $16$ 种排法（每个数代表将所有同学身高从高到低排序后该同学的排名）：

$$\begin{matrix}
123 & 123 & 124 & 124 & 125 & 125 & 126 & 126 & 134 & 134 & 135 & 135 & 136 & 136 & 145 & 146 \\
45 & 46 & 35 & 36 & 34 & 36 & 34 & 35 & 25 & 26 & 24 & 26 & 24 & 25 & 26 & 25 \\
6 & 5 & 6 & 5 & 6 & 4 & 5 & 4 & 6 & 5 & 6 & 4 & 5 & 4 & 3 & 3
\end{matrix}$$

可是班里一共有 $n$ 个人，小 Z 算不出来了，希望你帮帮他。

## 说明/提示

### 数据范围及约定

对于 $30\%$ 的数据，$n \le 10$。

对于另外 $30\%$ 的数据，只有最后一排超过 $1$ 个人。

对于 $100\%$ 的数据，$1 \le k \le 5$，$1 \le n \le 30$，方案数小于 $2^{32}$。

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
16```

## 样例 #2

### 输入

```
5
1 1 1 1 1 ```

### 输出

```
1```

# 题解

## 作者：X_yea (赞：22)

DP解法各位大佬已经说的够详细了

这里就说一下本题的数学解法吧qwq~

# 数学方法题解

### 杨氏矩阵
![](https://cdn.luogu.com.cn/upload/pic/1260.png)
这些就是杨氏矩阵(允许我偷个懒）

我们发现她有如下性质：

* 如果格子(i,j)没有元素，则它右边和下边的相邻格子也一定没有元素。

* 如果格子(i,j)有元素a[i][j]，则它右边和下边的相邻格子要么没有元素，要么有元素且比a[i][j]大。

### 钩子长度
定义：该格子右边的格子数和它下边的格子数之和。

例如k=3，n=6，每排人数分别为3，2，1时，每个格子的钩子长度如图所示：

![](https://i.loli.net/2019/06/30/5d18a6273d10a29213.png)

### 钩子公式

对于给定形状，不同的杨氏矩阵的个数为：n！除以每个格子的钩子长度加1的积。

例如上图的不同的杨氏矩阵的个数=6！/(5 * 3 * 1 * 3 * 1 * 1)=16

## CODE
```cpp
#include <bits/stdc++.h>
#define int long long//记得开long long
using namespace std;

int k,n,a=1,b=1,c,cnt,sum[31],line[6];

int gcd(int a,int b)
{
	return b==0?a:gcd(b,a%b);
}

signed main()
{
	cin>>k;
	for(int i=1; i<=k; i++)
	{
		cin>>line[i];
		n+=line[i];
	}
	for(int i=1; i<=k; i++)
	{
		for(int j=1; j<=line[i]; j++)
		{
			int hook=line[i]-j+1;
			for(int k=i+1; k<=n; k++)
			{
				if(line[k]>=j)
					hook++;
				else break;
			}
			sum[++cnt]=hook;
		}
	}
	for(int i=1; i<=n; i++)//这里是约分，防止溢出
	{
		a*=i;
		b*=sum[i];
		c=gcd(a,b);
		if(c!=1)
		{
			a/=c;
			b/=c;
		}
	}
	cout<<a/b;
	return 0;
}
```

---

## 作者：Haishu (赞：15)

其实代码可以很简单~~~

由于k巨小，所以考虑设f[i][j][k][l][p]为五排（当少于5排时，少掉的排看做0人）的人数分别为i,j,k,l,p时的方案数。

运算过程中使用判断来保证i>=j>=k>=l>=p。

特别地，当i=j=k=l=p=0时，即为边界条件，返回1。

```
#include <cstdio>
const int S=30;
int n,a[S];
unsigned f[S][S][S][S][S];
inline int dfs(int i,int j,int k,int l,int p)
{
	if (i+j+k+l+p==0) return 1;
	unsigned &tp=f[i][j][k][l][p];
    //使用引用运行更快。此时tp就是f[i][j][k][l][p],
    //且对tp的赋值直接作用于f[i][j][k][l][p]上。
	if (tp) return tp;
	if (i>j) tp+=dfs(i-1,j,k,l,p);
	if (j>k) tp+=dfs(i,j-1,k,l,p);
	if (k>l) tp+=dfs(i,j,k-1,l,p);
	if (l>p) tp+=dfs(i,j,k,l-1,p);
	if (p) tp+=dfs(i,j,k,l,p-1);
	return tp;
}
int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++)
		scanf("%d",a+i);
	printf("%u\n",dfs(a[0],a[1],a[2],a[3],a[4]));
	return 0;
}
```

---

## 作者：风羽跃 (赞：7)

这道题加深了我对动态规划的理解。

要求排成一个行内从左向右递增、列内从前向后递增的序列，就有这么一条性质：

**如果我们从 1 到 N 依次填入每个数，那么这些数一定紧密连接不留空隙**。

换句话说，已经填好的所有数中，每行任意两个数之间一定没有空位，每两行之间一定没有空行。

证明：设当前已经填了 $1$~$x$，假设某一行两个数之间有空位，那么以后必然有一个序号大于 $x$ 的数被填在这个空位上（因为 $x$ 后面的数都比 $x$ 序号大，且每个位置都必须填数），这样就不满足行内从左向右递增的的条件！因此假设不成立，上述结论成立（行之间的情况同理）。

考虑动态规划。

看看数据范围：$k\le5$，$n\le30$，猜想时间、空间复杂度均为 $O(n^5)$。

设 $a$，$b$，$c$，$d$，$e$ 分别代表每一行已经填好的个数,枚举这五个数表示当前状态。

由于上述单调的性质，可以发现**在实际决策中，我们并不关心每一行具体填的什么数，而只关心每一行填了多少个数。**

容易得到状态转移方程：

$F(a,b,c,d,e)=F(a-1,b,c,d,e)(a\ge1)+F(a,b-1,c,d,e)(b\ge1,b\le a)+\cdots+F(a,b,c,d,e-1)(e\ge1,e\le d)$。

注意每一行的已填好的个数不能超过上一行的，否则也不满足单调性质。

 设 $N1$，$N2$，$N3$，$N4$，$N5$ 为每一行的最多个数。

初始状态：$F(0,0,0,0,0)=1$。

目标状态：$F(N1,N2,N3,N4,N5)$。

AC代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>

#define maxn 31

using namespace std;

int n,cnt[maxn],k;
int f[maxn][maxn][maxn][maxn][maxn];

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

int main()
{
	while(scanf("%d",&k)!=EOF){
		memset(cnt,0,sizeof(cnt));
		for(int i=1;i<=k;i++){
			cnt[i]=read();
		}
		memset(f,0,sizeof(f));
		f[0][0][0][0][0]=1;
		for(int a=0;a<=cnt[1];a++){
		  for(int b=0;b<=cnt[2];b++){
			for(int c=0;c<=cnt[3];c++){
			  for(int d=0;d<=cnt[4];d++){
				for(int e=0;e<=cnt[5];e++){
					if(a) f[a][b][c][d][e]+=f[a-1][b][c][d][e];
					if(b&&b<=a) f[a][b][c][d][e]+=f[a][b-1][c][d][e];
					if(c&&c<=b) f[a][b][c][d][e]+=f[a][b][c-1][d][e];
					if(d&&d<=c) f[a][b][c][d][e]+=f[a][b][c][d-1][e];
					if(e&&e<=d) f[a][b][c][d][e]+=f[a][b][c][d][e-1];
				}
			  }
			}
		  }
		}
		printf("%lld\n",f[cnt[1]][cnt[2]][cnt[3]][cnt[4]][cnt[5]]);
	}
	return 0;
}
```


---

## 作者：CodinPnda (赞：7)

# 蜜汁五维dp毒瘤解法详解
首先，这是一道极度毒瘤的题

由于k的值很小，所以我们可以直接定义$f[a_1][a_2][a_3][a_4][a_5]$等于当第i行有$a_i$个人时的方案数

接着我们来考虑一下转移方程要怎么写QAQ

首先，如果$f[a_1-1][a_2][a_3][a_4][a_5]$已经确定的话，如果$a_1>a_2$，那么很显然，在范围$(a_1-1, a_2, a_3, a_4, a_5)$中，最大值必为$a_1+a_2+a_3+a_4+a_5-1$，那么在$(1, a_1)$处填入$a_1+a_2+a_3+a_4+a_5$必然符合要求

也就是说，
$$f[a_1][a_2][a_3][a_4][a_5]=f[a_1-1][a_2][a_3][a_4][a_5]+S$$
其中，S是某个常数

以此类推，可以得到
$$f[a_1][a_2][a_3][a_4][a_5]=f[a_1-1][a_2][a_3][a_4][a_5]+f[a_1][a_2-1][a_3][a_4][a_5]+f[a_1][a_2][a_3-1][a_4][a_5]+f[a_1][a_2][a_3][a_4-1][a_5]+f[a_1][a_2][a_3][a_4][a_5-1]$$
但是要注意一点，只有当$a_1>a_2$时，$f[a_1][a_2][a_3][a_4][a_5]=f[a_1-1][a_2][a_3][a_4][a_5]+S$

其他依次类推

最后发一波代码QAQ
```cpp
#include <iostream>
using namespace std;
int n, k, nums[6];
unsigned f[31][31][31][31][31];
int dfs(int a, int b, int c, int d, int e){
	if(a == 0 && b == 0 && c == 0 && d == 0 && e == 0) {f[a][b][c][d][e] = 1;return 1;}
	unsigned &ds = f[a][b][c][d][e];
	if(ds) return ds;
	if(a > b) ds += dfs(a-1, b, c, d, e);
	if(b > c) ds += dfs(a, b-1, c, d, e);
	if(c > d) ds += dfs(a, b, c-1, d, e);
	if(d > e) ds += dfs(a, b, c, d-1, e);
	if(e) ds += dfs(a, b, c, d, e-1);
	return ds;
}
int main(){
	cin >> k;
	for(int i = 1; i <= k; i++) cin >> nums[i], n += nums[i];
	dfs(nums[1], nums[2], nums[3], nums[4], nums[5]);
	cout << f[nums[1]][nums[2]][nums[3]][nums[4]][nums[5]] << endl;
	return 0;
}
```


---

## 作者：benny (赞：7)

###本题是动规题###

##题意分析：##

二维数组中每个数都比右边和下边的数小，共k（1~5）行，第i（1~k）行不超过l[i]个数，共n（1~30）个数

##我们可以得到：##

1、最左上角的数是最小的（1）

**2、最大的数只可能出现在每行的最后（因为如果最大的出现在中间，那么此行的最后一个肯定比中间的还小），有k种情况**

##建模：##

设F表示答案，比如样例中：

F(3,2,1)=16

更普遍地，我们是要求：

F(l1,l2,l3...lk)=?  （a数组单调递减）

而且:

最大的数只可能出现在每行的最后，有k种情况

把每种情况分类讨论，得到状态转移方程：

```cpp
**F(a1,a2,a3,..ak)=**
**F(a1-1,a2,a3...ak)+**
**F(a1,a2-1,a3,...ak)+**
**F(a1,a2,a3-1,...ak)+**
```
**...**
**F(a1,a2,a3,...ak-1)+**

##细节与实现：##

1、最好的数据结构是“树”，但是由于k很小，所以直接用数组吧

2、在每种情况中，不变的是“总数永远少1”，所以以总数（即a1+a2+a3+...+ak的和）为阶段，





```cpp
var f:array[0..30,0..30,0..30,0..30,0..30] of 0..2147483648;
k,n:byte;
l:array[1..5] of byte;
i,j:integer;
a:array[0..5] of 0..30;
function min(x,y:longint):longint;
begin
  if x>y then exit(y) else exit(x);
end;
procedure p(n,x:byte);
var i:byte;
begin
  //for i:=1 to x do write(a[i],' '); writeln; readln;
  if x=k then
    begin
      if n<>0 then exit else
      begin
        //for i:=1 to k do write(a[i],'~'); writeln;
inc(f[a[1]+1,a[2]+0,a[3]+0,a[4]+0,a[5]+0],f[a[1],a[2],a[3],a[4],a[5]]);
inc(f[a[1]+0,a[2]+1,a[3]+0,a[4]+0,a[5]+0],f[a[1],a[2],a[3],a[4],a[5]]);
inc(f[a[1]+0,a[2]+0,a[3]+1,a[4]+0,a[5]+0],f[a[1],a[2],a[3],a[4],a[5]]);
inc(f[a[1]+0,a[2]+0,a[3]+0,a[4]+1,a[5]+0],f[a[1],a[2],a[3],a[4],a[5]]);
inc(f[a[1]+0,a[2]+0,a[3]+0,a[4]+0,a[5]+1],f[a[1],a[2],a[3],a[4],a[5]]);
        exit;
      end;
    end;
  for i:=0 to min(min(l[x+1],a[x]),n) do
    begin
      a[x+1]:=i;
      p(n-i,x+1);
    end;
end;
begin
  readln(k);
  for i:=1 to k do read(l[i]);
  n:=0;
  for i:=1 to k do n:=n+l[i];
  f[1,0,0,0,0]:=1;  a[0]:=30;
  for i:=1 to n do
    begin
      //writeln(i,':');   readln; readln;
      p(i,0);
    end;
  writeln(f[l[1],l[2],l[3],l[4],l[5]]);
end.
3、p过程的意图是：已知i个数的所有填法的个数，求出i+1个数的所有填法的个数。先枚举总数为i的单调递减的a数组，然后执行方程
```

---

## 作者：Doubeecat (赞：4)



> [P2132 小Z的队伍排列](<https://www.luogu.com.cn/problem/P2132>)
>
> 小Z想给班里的同学拍一张合影，为此需要先让大家排好队伍。他希望大家站成 $k$ 排，并规定了每排的人数，保证每一排的人数都不多于后面一排的人数。
>
> 这时小Z发现队伍看起来还是乱糟糟的，原因是大家的身高互不相同。于是，他希望排头对齐，每位同学都比自己正后方的同学以及排头方向的同学矮。
>
> 排完以后，善于思考的小Z还想知道一共有多少种排法。


## 解题思路：

线性 DP。

首先因为“保证每一排的人数都不多于后面一排的人数”且“每位同学都比自己正后方的同学以及排头方向的同学矮”，所以合法方案中每行每列的身高显然单调。

所以我们可以从高到低考虑每个学生所站的位置，这样搞的话，我们只要用一个$(a_1,a_2,a_3...a_n)$ 就能体现出已经处理的东西的轮廓。

而每次考虑一个学生的时候，为了保证单调性，我们只能将他放在满足人员未满并且 $a_i < a_{i-1}$ 或 $i = 1$ 的行中。

所以定义 $(a_1,a_2,a_3...a_n)$ 为阶段，这样就满足了动态规划问题的最优子结构性质，并且每安排一名新学生时候 $a_1,a_2,a_3...a_n$ 中总有一个会 $+1$，满足各个维度线性增长的原则，也就是线性 DP 了。

接下来，我们来设计状态转移方程，本题中的 $k \leq 5$，所以~~无脑~~设计 

$f_{a_1,a_2,a_3,a_4,a_5}$表示每排从最左边起分别站了 $a_1,a_2,a_3,a_4,a_5$ 个人的方案数量

$f_{0,0,0,0,0} = 1$ 

目标：$f_{k_1,k_2,k_3,k_4,k_5}$

转移：

当 $i = 1$ 时，如果 $a_1 < k_1$，也就是人还没被放满时，$f_{a_1+1,a_2,a_3,a_4,a_5}+=f_{a_1,a_2,a_3,a_4,a_5}$

当 $i > 1$ 时，如果 $a_i < k_i \& a_i < a_{i-1}$，$f_{a_1,a_2+1,a_3,a_4,a_5}+=f_{a_1,a_2,a_3,a_4,a_5}$

（此处为当$i = 2$时，其他同理。）

## 代码：

```cpp
#include <cstring>
#include <iostream>
#include <cstdio>
#include <cctype>
#include <string>
#include <cmath>
#include <stack>
using namespace std;

#define ll long long
#define ri register int

char buf[1 << 20], *p1, *p2;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2)?EOF: *p1++)
template <typename T> inline void read(T &t) {
	ri v = getchar();T f = 1;t = 0;
	while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();}
	while (isdigit(v)) {t = t * 10 + v - 48;v = getchar();}
	t *= f;
}
template <typename T,typename... Args> inline void read(T &t,Args&... args) {
		read(t);read(args...);
	}
const int INF = 0x3f3f3f3f;
const int N = 31;

ll f[N][N][N][N][N],n;
int a[N];

signed main() {
	read(n);
	for (int i = 1;i <= n;++i) read(a[i]);
	f[0][0][0][0][0] = 1;
	for (int a1 = 0;a1 <= a[1];++a1) {
		 for (int a2 = 0;a2 <= min(a1,a[2]);++a2) {
		 	for (int a3 = 0;a3 <= min(a2,a[3]);++a3) {
		 		for (int a4 = 0;a4 <= min(a3,a[4]);++a4) {
		 			for (int a5 = 0;a5 <= min(a4,a[5]);++a5) {
		 				ll &p = f[a1][a2][a3][a4][a5];//指针储存，传统艺能
		 				if (a1 && a1 > a2) p += f[a1-1][a2][a3][a4][a5];
		 				if (a2 && a2 > a3) p += f[a1][a2-1][a3][a4][a5];
		 				if (a3 && a3 > a4) p += f[a1][a2][a3-1][a4][a5];
		 				if (a4 && a4 > a5) p += f[a1][a2][a3][a4-1][a5];
		 				if (a5) p += f[a1][a2][a3][a4][a5-1];
		 			}
		 		}
		 	}
		 }
	}
	printf("%lld\n", f[a[1]][a[2]][a[3]][a[4]][a[5]]);
	return 0;
}
```



---

## 作者：___w (赞：3)

### [P2132 小Z的队伍排列](https://www.luogu.com.cn/problem/P2132)

#### 题外话
[SP15637](https://www.luogu.com.cn/problem/SP15637) 双倍经验（滑稽）。

#### 简要题意
有 $k$ 排，每排的人数有 $n_k$ 个人，要求排头对齐，且每位同学都比自己正后方的同学以及排头方向的同学矮，求方案数。

#### 题目分析
经典的 dp 题。因为 $1\le k\le 5$，所以我们就可以 $5$ 元组 $F_{a_1,a_2,a_3,a_4,a_5}$ 来表示当每排分别有 $a_1,a_2,a_3,a_4,a_5$ 个人的方案数。假设所有的学生高度为 $1$ 到 $N$ 的整数。题目要求每行每列的身高都是单调的。每行的单调都是很好处理的，只需按从低到高的顺序排即可，每一行绝对是单调的。至于每一列 $i$，只需前一列的数比前一列晚即可，即 $a_i<a_{i-1}$。


边界：$F_{0,0,0,0,0}=1$，其余为 $0$。

目标：$F_{n_1,n_2,n_3,n_4,n_5}$。

转移：

若 $a_1<n_1$，则 $F_{a_1+1,a_2,a_3,a_4,a_5}=F_{a_1+1,a_2,a_3,a_4,a_5}+F_{a_1,a_2,a_3,a_4,a_5}$。

若 $a_2<n_2$ 且 $a_1>a_2$，则 $F_{a_1,a_2+1,a_3,a_4,a_5}=F_{a_1,a_2+1,a_3,a_4,a_5}+F_{a_1,a_2,a_3,a_4,a_5}$。

若 $a_3<n_3$ 且 $a_2>a_3$，则 $F_{a_1,a_2,a_3+1,a_4,a_5}=F_{a_1,a_2,a_3+1,a_4,a_5}+F_{a_1,a_2,a_3,a_4,a_5}$。

若 $a_4<n_4$ 且 $a_3>a_4$，则 $F_{a_1,a_2,a_3,a_4+1,a_5}=F_{a_1,a_2,a_3,a_4+1,a_5}+F_{a_1,a_2,a_3,a_4,a_5}$。

若 $a_5<n_5$ 且 $a_4>a_5$，则 $F_{a_1,a_2,a_3,a_4,a_5+1}=F_{a_1,a_2,a_3,a_4,a_5+1}+F_{a_1,a_2,a_3,a_4,a_5}$。

#### 代码
注意开 ```long long```。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 31;
int k, n[N], f[N][N][N][N][N];
signed main() {
	cin >> k;
	for (int i = 1; i <= k; ++i) cin >> n[i];
	f[0][0][0][0][0] = 1;
	for (int a1 = 0; a1 <= n[1]; ++a1)
		for (int a2 = 0; a2 <= n[2]; ++a2)
			for (int a3 = 0; a3 <= n[3]; ++a3)
				for (int a4 = 0; a4 <= n[4]; ++a4)
					for (int a5 = 0; a5 <= n[5]; ++a5)
	{
		if (a1 < n[1]) f[a1+1][a2][a3][a4][a5] += f[a1][a2][a3][a4][a5];
		if (a2 < n[2] && a1 > a2) f[a1][a2+1][a3][a4][a5] += f[a1][a2][a3][a4][a5];
		if (a3 < n[3] && a2 > a3) f[a1][a2][a3+1][a4][a5] += f[a1][a2][a3][a4][a5];
		if (a4 < n[4] && a3 > a4) f[a1][a2][a3][a4+1][a5] += f[a1][a2][a3][a4][a5];
		if (a5 < n[5] && a4 > a5) f[a1][a2][a3][a4][a5+1] += f[a1][a2][a3][a4][a5];
	}
	cout << f[n[1]][n[2]][n[3]][n[4]][n[5]];
	return 0;
}
```

---

## 作者：linyinuo2008 (赞：2)

首先，感谢goodier大佬对我的启发。

这题五维dp出的十分有毒，但思想确实不错。

话说动归本质上其实就是暴力，但与递归的区别在于：动归是把多个小阶段合成一个最优解，而递归是把一个阶段分成更小的阶段，然后把最优解返回合成。而且动归也应该比递归更省时间，时间更稳定一些吧。

# 1、动归方程

由于看到这题k极小，于是我们可以直接开一个五维动归数组来完成。

其中$f(i,j,m,n,p)$表示第五行至第一行分别为$i,j,m,n,p$人时的方案总数。

此时我们要保证$i\ge j\ge m\ge n\ge p\ge 0$

$i=j=m=n=p=0$是边界条件，返回1。

动归方程：

$f(i,j,m,n,p)=f(i-1,j,m,n,p)+f(i,j-1,m,n,p)+f(i,j,m-1,n,p)+f(i,j,m,n-1,p)+f(i,j,m,n,p-1)$

但是注意，仅当$i \ge j$时，才可以继续递推方程。


# 2、代码

贴上代码：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int maxn=30;
int k,a[maxn];
unsigned f[maxn][maxn][maxn][maxn][maxn];
//int会爆一个点，long long全MLE，只好用unsigned
int main()
{
	memset(f,0,sizeof(f));
	int i,j,m,n,p;
	cin>>k;
	for(i=1;i<=k;i++)
	{
		cin>>a[i];
	}
	f[0][0][0][0][0]=1;
	for(i=0;i<=a[1];i++)
	{
		for(j=0;j<=a[2];j++)
		{
			for(m=0;m<=a[3];m++)
			{
				for(n=0;n<=a[4];n++)
				{
					for(p=0;p<=a[5];p++)
					{
						if(i>j)  f[i][j][m][n][p]+=f[i-1][j][m][n][p];
						if(j>m)  f[i][j][m][n][p]+=f[i][j-1][m][n][p];
						if(m>n)  f[i][j][m][n][p]+=f[i][j][m-1][n][p];
						if(n>p)  f[i][j][m][n][p]+=f[i][j][m][n-1][p];
						if(p>0)  f[i][j][m][n][p]+=f[i][j][m][n][p-1];
					}
				}
			}
		}
	}
	cout<<f[a[1]][a[2]][a[3]][a[4]][a[5]];
	return 0;
} 
```
管理员大大求通过!

## 若有错误，欢迎指出！


---

## 作者：jimmy916 (赞：1)

# P2132 小Z的队伍排列 题解

本题类似 [AcWing 271. 杨老师的照相排列](https://www.acwing.com/problem/content/273/), 还有 [视频题解](https://www.acwing.com/video/397/) 哦。

### 题目

有 $k$ 排人要排队，从后往前每一排依次是 $a_1,a_2,\cdots,a_k$ 个人。

同时，排列方案还要满足每位同学都比自己正后方的同学以及排头方向的同学矮的特点。

求方案总数。

### 分析

![](https://cdn.luogu.com.cn/upload/image_hosting/uschndvz.png)

上图所示为 dp 解法，代码：

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 31;

int n;
LL f[N][N][N][N][N];

int main()
{
    while (cin >> n, n)
    {
        int s[5] = {0};
        for (int i = 0; i < n; i ++ ) cin >> s[i];
        memset(f, 0, sizeof f);
        f[0][0][0][0][0] = 1;

        for (int a = 0; a <= s[0]; a ++ )
            for (int b = 0; b <= min(a, s[1]); b ++ )
                for (int c = 0; c <= min(b, s[2]); c ++ )
                    for (int d = 0; d <= min(c, s[3]); d ++ )
                        for (int e = 0; e <= min(d, s[4]); e ++ )
                        {
                            LL &x = f[a][b][c][d][e];
                            if (a && a - 1 > b) x += f[a - 1][b][c][d][e];
                            if (b && b - 1 > c) x += f[a][b - 1][c][d][e];
                            if (c && c - 1 > d) x += f[a][b][c - 1][d][e];
                            if (d && d - 1 > e) x += f[a][b][c][d - 1][e];
                            if (e) x += f[a][b][c][d][e - 1];
                        }
        cout << f[s[0]][s[1]][s[2]][s[3]][s[4]] << endl;
    }

    return 0;
}
```

但是别急，如果你交了上去上述代码，那么恭喜你，你将后收获一大坨蓝蓝的 MLE，没错，空间不足了。

那么，该如何优化呢？

我们首先看到数据范围，$1 ≤ n ≤ 30$ 这个范围很水，我们其实暴力搜索就可以 AC。

### 正解

根据上述代码，改为 dfs 就可以了。

注意：

1. 边界条件。
2. 只有当 $a_1 > a_2$ 时，$f[a_1][a_2][a_3][a_4][a_5]$ 才会发生改变。

### 代码

```cpp
#include <iostream>

using namespace std;

const int N = 31;
int n, k, a[6];
unsigned f[N][N][N][N][N];

int dfs(int a, int b, int c, int d, int e) {
	if(a == 0 && b == 0 && c == 0 && d == 0 && e == 0) {
	    f[a][b][c][d][e] = 1;
	    return 1;
	}
	unsigned &ds = f[a][b][c][d][e];
	if(ds)
	    return ds;
	if(a > b)
	    ds += dfs(a-1, b, c, d, e);
	if(b > c)
	    ds += dfs(a, b-1, c, d, e);
	if(c > d)
	    ds += dfs(a, b, c-1, d, e);
	if(d > e)
	    ds += dfs(a, b, c, d-1, e);
	if(e)
	    ds += dfs(a, b, c, d, e-1);
	return ds;
}

int main(){
	cin >> k;
	for(int i = 1; i <= k; i++)
	    cin >> a[i], n += a[i];
	dfs(a[1], a[2], a[3], a[4], a[5]);
	cout << f[a[1]][a[2]][a[3]][a[4]][a[5]] << endl;
	return 0;
}
```

---

## 作者：ny_jerry2 (赞：0)

这道题可以根据较小的数据范围来设定状态。

设 $f_{a,b,c,d,e}$ 表示第 $1$ 排站了 $a$ 人 $\dots$ 第 $5$ 排站了 $e$ 人。

根据 **每位同学都比自己正后方的同学以及排头方向的同学矮**，说明每次转移时应该满足在当前这一排还没选这个人时，应不小于下一排人数（最后一排除外）。

转移：就按照上述条件累加方案即可。

最后提醒一句：不开 long long 见祖宗！

```
#include<iostream>
using namespace std;
const int N=31;
long long f[N][N][N][N][N];
int n;
int cnt[6];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>cnt[i];
	}
	f[0][0][0][0][0]=1;
	for(int a=0;a<=cnt[1];a++){
		for(int b=0;b<=cnt[2];b++){
			for(int c=0;c<=cnt[3];c++){
				for(int d=0;d<=cnt[4];d++){
					for(int e=0;e<=cnt[5];e++){
						long long &t=f[a][b][c][d][e];
						if(a&&a-1>=b){
							t+=f[a-1][b][c][d][e];
						}
						if(b&&b-1>=c){
							t+=f[a][b-1][c][d][e];
						}
						if(c&&c-1>=d){
							t+=f[a][b][c-1][d][e];
						}
						if(d&&d-1>=e){
							t+=f[a][b][c][d-1][e];
						}
						if(e){
							t+=f[a][b][c][d][e-1];
						}
					}
				}
			}
		}
	}
	cout<<f[cnt[1]][cnt[2]][cnt[3]][cnt[4]][cnt[5]];
}
```

---

## 作者：封禁用户 (赞：0)

# DP 好题

由于 $k$ 太小，所以考虑设 $f[i][j][k][l][p]$ 为五排（当少于 $5$ 排时，少掉的排看做 $0$ 人）的人数分别为 $i,j,k,l,p$ 时的方案数。我们在运算过程中使用判断来保证$i\ge j\ge k\ge l\ge p$。我们再特判一下，当 $i=j=k=l=p=0$ 时，即为边界条件，则返回 $1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int S=30;
int n,a[S];unsigned f[S][S][S][S][S];
inline int dfs(int i,int j,int k,int l,int p){
	if (i+j+k+l+p==0) return 1;
	unsigned &tp=f[i][j][k][l][p];
	if(tp)return tp;
	if(i>j)
        tp+=dfs(i-1,j,k,l,p);
	if(j>k)
        tp+=dfs(i,j-1,k,l,p);
	if(k>l)
        tp+=dfs(i,j,k-1,l,p);
	if(l>p)
        tp+=dfs(i,j,k,l-1,p);
	if(p)
        tp+=dfs(i,j,k,l,p-1);
	return tp;
}
int main(){
    cin>>n;
	for (int i=0;i<n;i++)
		scanf("%d",a+i);
    cout<<dfs(a[0],a[1],a[2],a[3],a[4])<<endl;
	return 0;
}
```


---

## 作者：JoyJoyGang (赞：0)

DP 题目

而且居然有五维，真的没想到。不过 LNOI 都出现七维了，相比之下，也就不那么离谱了。

要把 1 到 n 个数按照每行递增，每列也递增的序列填入一个每行有可以填入固定数的序列。

我们考虑，我们按照从小到大的顺序填数，显然 $1$ 只能填在 $(1,1)$，而之后想要继续填数，只能放在上方和左边都填满数的位置，因为我们是递增的填，因此为了保证左边和上边的数的大小都大于当前位置，每个数填的时候上，左都是满的。

那么我们发现，我们可以不去考虑每次填的数的大小，因为我们每次必然把数放在可以填的行的最后一个。我们只需要考虑每行已经填了多少。要是没有填满，而且空位上方全部填满，那么就可以填！然后写五个 for 循环，分别表示每行已经填了几个，再判断一下上面是否填满，即可：

记得开 long long

代码：

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int MA=35;
const int MC=6;
int n=0,k,maxn=0;
struct zh{
	int x,y;
}b[MA];
int cnt=0;
bool bol[MA][MA];
int dp[MA][MA][MA][MA][MA],a[MC];
signed main()
{
	scanf("%lld",&k);
	for(int i=1;i<=k;i++){
		scanf("%lld",&a[i]);n+=a[i];
		for(int j=1;j<=a[i];j++){
			bol[i][j]=1;
		}
	}
	dp[0][0][0][0][0]=1;
	for(int i=0;i<=a[1];i++){
		for(int j=0;j<=a[2];j++){
			for(int he=0;he<=a[3];he++){
				for(int ha=0;ha<=a[4];ha++){
					for(int wu=0;wu<=a[5];wu++){
						if(i>=1){
							dp[i][j][he][ha][wu]+=dp[i-1][j][he][ha][wu];
						}
						if(j>=1&&j<=i){
							dp[i][j][he][ha][wu]+=dp[i][j-1][he][ha][wu];
						}
						if(he>=1&&he<=j){
							dp[i][j][he][ha][wu]+=dp[i][j][he-1][ha][wu];
						}
						if(ha>=1&&ha<=he){
							dp[i][j][he][ha][wu]+=dp[i][j][he][ha-1][wu];
						}
						if(wu>=1&&wu<=ha){
							dp[i][j][he][ha][wu]+=dp[i][j][he][ha][wu-1];
						}																		
					}
				}
			}
		}
	}
	printf("%lld",dp[a[1]][a[2]][a[3]][a[4]][a[5]]);
	return 0;
}
```




---

## 作者：_Aghost (赞：0)

在合影中，每行每列的身高都是单调的，可以用$1$~$N$来表示每个人的身高，这样，在任意时刻，一行中的学生占据的一定是从左到右的连续的位置，那么就可以用$k$元组($a1$,$a2$,$...$，$ak$)来表示每一行有几个人。当加入一名新同学时，考虑满足条件的行号:

1. $a_i<N_i$
2. $i=1$或$a_i<a_i$$_-$$_1$

- 状态：$F[a1,a2,a3,a4,a5]$表示各排从左到右依次排的人数。
- 初始化：$F[0,0,0,0,0]=1$ 
- 目标：$F[N1,N2,N3,N4,N5]$
- 转移：
1. 若$a_1<N_1$,$F[a_1+1,a_2,a_3,a_4,a_5]+=F[a_1,a_2,a_3,a_4,a_5]$
2. 若$a_1>a_2$$F[a_1,a_2+1,a_3,a_4,a_5]+=F[a_1,a_2,a_3,a_4,a_5]$
其他几排同理。

$Code$
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int k,a[6];
long long f[31][31][31][31][31];
int main()
{
	scanf("%d",&k);
	for(int i=1;i<=k;i++)
	scanf("%d",&a[i]);
	f[0][0][0][0][0]=1;
	for(int i=0;i<=a[1];i++)
	for(int j=0;j<=a[2];j++)
	for(int ii=0;ii<=a[3];ii++)
	for(int jj=0;jj<=a[4];jj++)
	for(int x=0;x<=a[5];x++){
		if(i<a[1])f[i+1][j][ii][jj][x]+=f[i][j][ii][jj][x];
		if(j<i&&j<a[2]) f[i][j+1][ii][jj][x]+=f[i][j][ii][jj][x];
		if(ii<j&&ii<a[3]) f[i][j][ii+1][jj][x]+=f[i][j][ii][jj][x];
		if(jj<ii&&jj<a[4]) f[i][j][ii][jj+1][x]+=f[i][j][ii][jj][x];
		if(x<jj&&x<a[5]) f[i][j][ii][jj][x+1]+=f[i][j][ii][jj][x];
	}
	printf("%lld\n",f[a[1]][a[2]][a[3]][a[4]][a[5]]);
}
```



---

## 作者：goodier (赞：0)

首先，感谢大佬们对我的启发。

## 1、题意简述

有5排，从第5排到第1排每排分别为 $a,b,c,d,e$ 个人

$a ≥ b ≥ c ≥ d ≥ e ≥ 0$

没有的记作0人，问一共有多少种排列方法。

------------
## 2、题意分析：

本题要用的是动态规划，一个相较于递归更省时间的算法，它可以将之前算过的值储存起来，不像递归一样每推到一个值都要再算一遍。

------------
由于本题最多只有5行，且每行最多30人，那么直接开一个5维的数组 $f(30,30,30,30,30)$ 即可。

 $f(a,b,c,d,e)$ 表示当人数从第5排到第1排分别为 $a,b,c,d,e$ (没有的看做0人）时的方案数量。

不要上来用 "int" ,会有一个点过不了（我就是这样调了一个小时），也不要用 "long long" ,会全暴内存，所以建议用 "unsigned"。

初始值的话就是在每排都是0个人的时候有一种排列方法， $f(0,0,0,0,0) = 1$。

------------
## 3、动规方程：

根据题意，每一排的人数都不多于后一排的人数。

当 $a > b > c > d > e > 0$ 时

(保证$a - 1 ≥ b,b - 1 ≥ c,c - 1 ≥ d,d - 1 ≥ e, e - 1 ≥ 0$)

$f(a,b,c,d,e) = f(a - 1,b,c,d,e) + f(a,b - 1,c,d,e) + f(a,b,c - 1,d,e) + f(a,b,c,d - 1,e) + f(a,b,c,d,e - 1)$

本质上其实是道数学题。

知道方程后，就可以愉快的dp辣。

------------
## 4、代码：
```cpp
#include <iostream>
using namespace std;
const int MAXN = 30;
int k,num[6];
unsigned f[MAXN][MAXN][MAXN][MAXN][MAXN];
int main()
{
    cin >> k;
    for(int i = 1; i <= k; i++)
    {
        cin >> num[i];
    }
    f[0][0][0][0][0] = 1;
    for(int a = 0; a <= num[1]; a++)
        for(int b = 0; b <= num[2]; b++)
            for(int c = 0; c <= num[3]; c++)
                for(int d = 0; d <= num[4]; d++)
                    for(int e = 0; e <= num[5]; e++)
                    {
                        if(a > b) f[a][b][c][d][e] += f[a - 1][b][c][d][e];
                        if(b > c) f[a][b][c][d][e] += f[a][b - 1][c][d][e];
                        if(c > d) f[a][b][c][d][e] += f[a][b][c - 1][d][e];
                        if(d > e) f[a][b][c][d][e] += f[a][b][c][d - 1][e];
                        if(e > 0) f[a][b][c][d][e] += f[a][b][c][d][e - 1];
                    }
    cout << f[num[1]][num[2]][num[3]][num[4]][num[5]];
    return 0;
} 
```

------------

管理员大大求通过！！！本蒟蒻的第一篇正经题解！！！

## **若有错误，欢迎指出！！！**

---


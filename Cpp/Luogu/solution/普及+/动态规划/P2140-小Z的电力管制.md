# 小Z的电力管制

## 题目描述

小 Z 在供电公司找到了一份工作，刚上班就遇到了一个棘手的任务。

小 Z 所在的城市可以看成一个 $n \times m$ 的网格，第 $i$ 行第 $j$ 列的格子有电力需求 $a_{i,j}$ 。然而，供电公司能够供应的电力 $u$ 小于每格的电力需求之和。为此，供电公司不得不将城市划分成若干个区域，每个区域轮流断电，使得断电后剩余区域的电力需求之和不超过供电公司能够供应的电力。

为了方便起见，划分区域的方式很简单，每次将大区域横向或纵向划分成两个小区域，递归进行。

供电公司想尽可能减少市民的不满，因此需要小 Z 计算出最多能划分成多少个区域以及在此前提下能够剩余的最多电力（一种划分的剩余电力为每次断电后剩余电力的最小值），希望你帮帮他。




## 说明/提示

对于 $60\%$ 的数据，$1\leq n ,m \leq 10$ 。

对于 $100\%$ 的数据， $1 \leq n,m \leq 32,1 \leq a_{i,j} \leq 100$ 。

## 样例 #1

### 输入

```
3 3 33
4 4 2
2 9 6
6 5 3```

### 输出

```
4 1```

## 样例 #2

### 输入

```
3 4 15
1 2 1 2
2 1 2 1
1 2 1 2```

### 输出

```
6 0```

# 题解

## 作者：Usada_Pekora (赞：3)

题意：纵横划分区域，使得除去某一区域的值后其他区域的和不超过 $ u $ 。

思路：用 dfs 划分区域，如果沿着当前轴划分是可行的，那么再对划分后的区域进行 dfs 。

但是这样做的时间成本是很高的， 因为这种做法对同一区间做了重复的计算，这个时候就考虑用数组记录某一区间的最优值，在产生重复计算时直接调用即可。 设 $ f[x1][y1][x2][y2] $ 表示 $(x1,y1) $ 到 $(x2,y2) $ 的最优划分，则答案是 $f[1][1][n][m]$ 。

代码如下。

```cpp
#include<bits/stdc++.h>
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
using namespace std;
typedef pair<int,int> pii;
inline int read(){
    int x = 0;char ch = getchar();
    while(ch < '0' || ch > '9'){ch = getchar();}
    while(ch >= '0' && ch <= '9'){x = (x<<1)+(x<<3)+(ch^48);ch = getchar();}
    return x;
}
int n,m,u,a[35][35],sum = 0,s[35][35];
pii f[35][35][35][35];
#define calc(x1,y1,x2,y2) (s[x2][y2]+s[x1-1][y1-1]-s[x1-1][y2]-s[x2][y1-1])
inline pii dfs(int x1,int y1,int x2,int y2,int all){
    if(f[x1][y1][x2][y2].first) return f[x1][y1][x2][y2];
    if(x1 == x2 && y1 == y2) return pii{1,u-(sum-all)};
    pii t;t.first = 1,t.second = u-(sum-all);
    for(register int i = y1;i < y2;++i){
        int s1 = calc(x1,y1,x2,i),s2 = calc(x1,i+1,x2,y2);
        if(sum-s1 <= u && sum-s2 <= u){
            pii p1 = dfs(x1,y1,x2,i,s1),p2 = dfs(x1,i+1,x2,y2,s2);
            if(p1.first+p2.first > t.first)t.first = p1.first+p2.first,t.second = min(p1.second,p2.second);
            else if(p1.first+p2.first == t.first) t.second = max(t.second,min(p1.second,p2.second));
        }
    }
    for(register int i = x1;i < x2;++i){
        int s1 = calc(x1,y1,i,y2),s2 = calc(i+1,y1,x2,y2);
        if(sum-s1 <= u && sum-s2 <= u){
            pii p1 = dfs(x1,y1,i,y2,s1),p2 = dfs(i+1,y1,x2,y2,s2);
            if(p1.first+p2.first > t.first)t.first = p1.first+p2.first,t.second = min(p1.second,p2.second);
            else if(p1.first+p2.first == t.first) t.second = max(t.second,min(p1.second,p2.second));
        }
    }
    return f[x1][y1][x2][y2] = t;
}
int main(){
    n = read(),m = read(),u = read();
    for(register int i = 1;i <= n;++i)
        for(register int j = 1;j <= m;++j) a[i][j] = read(),sum += a[i][j];
    for(register int i = 1;i <= n;++i)
        for(register int j = 1;j <= m;++j) s[i][j] = s[i][j-1]+s[i-1][j]-s[i-1][j-1]+a[i][j];
    pii ans = dfs(1,1,n,m,sum);
    printf("%d %d",ans.first,ans.second);
    return 0;
}
```


---

## 作者：_111_ (赞：2)

本题的正解为动态规划。

题意：题面讲的已经很清楚了，这里不做多解释。

思路：定义两个四维数组 $f1$ 和 $f2$，$f1_{x1,y1,x2,y2}$ 表示左上角坐标为 $(x1,y1)$，右下角坐标为 $(x2,y2)$ 的矩阵划分区域数的最大值，$f2$ 记录在保证划分区域数最大的情况下能够剩余电力的最大值。定义变量 $sum$ 表示电力需求总和 $-$ $u$，我们需要保证划分后的任意一个区域的电力需求 $\ge sum$。

对于任意一个矩阵，我们只需要考虑它由哪两个矩阵转移过来（即横切和竖切），在转移的过程中，更新 $f2$ 数组的值。

初始化：每枚举到一个矩阵，如果这个矩阵的权值 $\ge sum$（矩阵的权值即为矩阵中的所有数相加），就将 $f1$ 初始化为 $1$，$f2$ 赋值为这个矩阵的权值，这里的矩阵权值可以用前缀和实现。

实现步骤：
1. 枚举矩阵 $(x1,y1,x2,y2)$，如果这个矩阵满足权值和 $\ge sum$，初始化，否则跳出枚举下一个矩阵。
1. 横切：$k$ 枚举矩阵的每一行，分割线在第 $k$ 行和第 $k+1$ 行之间，分割后的两个矩阵为 $(x1,y1,k,y2)$ 和 $(k+1,y1,x2,y2)$，如果这两个矩阵的 $f1$ 值都 $\ge 1$，表示可以分割，更新 $f1_{x1,y1,x2,y2}$ 和 $f2_{x1,y1,x2,y2}$ 的值。代码如下：
```c
if(f1[x1][y1][x2][y2]<f1[x1][y1][k][y2]+f1[k+1][y1][x2][y2]){
      	f1[x1][y1][x2][y2]=f1[x1][y1][k][y2]+f1[k+1][y1][x2][y2];
      	f2[x1][y1][x2][y2]=min(f2[x1][y1][k][y2],f2[k+1][y1][x2][y2]);
}
else if(f1[x1][y1][x2][y2]==f1[x1][y1][k][y2]+f1[k+1][y1][x2][y2])
      	f2[x1][y1][x2][y2]=max(f2[x1][y1][x2][y2],min(f2[x1][y1][k][y2],f2[k+1][y1][x2][y2]));
```
3. 竖切：思路和横切一样，把 $k$ 枚举行变为枚举列，分割后的两个矩阵变为 $(x1,y1,x2,k)$ 和 $(x1,k+1,x2,y2)$ 就好了。

时间复杂度：一共 $5$ 层循环，时间复杂度为 $O(n^5)$，对于 $n \le 32$ 的数据是完全可以通过的。

## code
```c
#include <bits/stdc++.h>
using namespace std;
int n, m, u, sum = 0;
int a[33][33];
int dp1[33][33][33][33], dp2[33][33][33][33], s[33][33];
int main() {
	scanf("%d%d%d", &n, &m, &u);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d", &a[i][j]);
			sum += a[i][j];
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
		}
	}
	sum -= u;
	for (int len1 = 1; len1 <= n; len1++) {
		for (int len2 = 1; len2 <= m; len2++) {
			for (int x1 = 1, x2 = x1 + len1 - 1; x2 <= n; x1++, x2++) {
				for (int y1 = 1, y2 = y1 + len2 - 1; y2 <= m; y1++, y2++) {
					if (s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] >= sum) {
						dp1[x1][y1][x2][y2] = 1;
						dp2[x1][y1][x2][y2] = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] - sum;
					} else continue;
					for (int k = x1; k < x2; k++) {
						if (!(dp1[x1][y1][k][y2] && dp1[k + 1][y1][x2][y2])) continue;
						if (dp1[x1][y1][x2][y2] < dp1[x1][y1][k][y2] + dp1[k + 1][y1][x2][y2]) {
							dp1[x1][y1][x2][y2] = dp1[x1][y1][k][y2] + dp1[k + 1][y1][x2][y2];
							dp2[x1][y1][x2][y2] = min(dp2[x1][y1][k][y2], dp2[k + 1][y1][x2][y2]);
						}
						if (dp1[x1][y1][x2][y2] == dp1[x1][y1][k][y2] + dp1[k + 1][y1][x2][y2]) 
							dp2[x1][y1][x2][y2] = max(dp2[x1][y1][x2][y2], min(dp2[x1][y1][k][y2], dp2[k + 1][y1][x2][y2]));
					}
					for (int k = y1; k < y2; k++) {
						if (!(dp1[x1][y1][x2][k] && dp1[x1][k + 1][x2][y2])) continue;
						if (dp1[x1][y1][x2][y2] < dp1[x1][y1][x2][k] + dp1[x1][k + 1][x2][y2]) {
							dp1[x1][y1][x2][y2] = dp1[x1][y1][x2][k] + dp1[x1][k + 1][x2][y2];
							dp2[x1][y1][x2][y2] = min(dp2[x1][y1][x2][k], dp2[x1][k + 1][x2][y2]);
						}
						if (dp1[x1][y1][x2][y2] == dp1[x1][y1][x2][k] + dp1[x1][k + 1][x2][y2]) 
							dp2[x1][y1][x2][y2] = max(dp2[x1][y1][x2][y2], min(dp2[x1][y1][x2][k], dp2[x1][k + 1][x2][y2]));
					}
				}
			}
		}
	}
	printf("%d %d\n", dp1[1][1][n][m], dp2[1][1][n][m]);
	return 0;
}
```

---

## 作者：Think (赞：0)

似乎这道题和 [P1436](https://www.luogu.com.cn/problem/P1436) 以及 [P5752](https://www.luogu.com.cn/problem/P5752) 的棋盘分割有很多相似之处 。  ~~（三倍经验）~~  
题目对于电力的要求似乎有些复杂 。  
简化来说就是 **取各方案各个区域分值之和最小值最大** 。  
特来此写一篇较为详细的题解 。  
## 1.思路
类似于分割棋盘，我们可以使用进行 **递归** 分割 。   
二维取区块和可以使用 **二维前缀和**  
但是答案有两个，可以使用结构体存储并维护 。  
用 $f$ 数组进行 **记忆化处理** 优化时间复杂度 。
## 2.解法
易知递归边界是不可再分，即已经缩小到一个点 。  
电力消耗值为所有需要的电 $tot$ 减去当前断电区域断掉的电 $broke$ 。  
所有电力剩余值为 **供电总值 - 电力消耗值** 。  
定义：
- $ans$ 为方案总数 。
- $least$ 为电力剩余值 。  

如果当前方案较多，则替换已有方案，更新电力剩余值 。   
如果方案数相同，则比较电力剩余值，选出较大的 。
## 3.Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=35;
struct Node{
	int ans;
	int least;
}f[maxn][maxn][maxn][maxn];
int a[maxn][maxn];
int sum[maxn][maxn];
int tot=0;
int n,m,u;
int get_sum(int x1,int y1,int x2,int y2){
	int k=sum[x2][y2]+sum[x1-1][y1-1]-sum[x1-1][y2]-sum[x2][y1-1];//求区块分值和 
	return k;
}
Node dfs(int x1,int y1,int x2,int y2,int broke){
	if(f[x1][y1][x2][y2].ans) return f[x1][y1][x2][y2];
	Node tmp;tmp.ans=1;tmp.least=u-tot+broke;
	if(x1==x2&&y1==y2) return tmp;//递归边界 
	for(int i=x1;i<x2;i++){//纵向分割 
		int area1=get_sum(x1,y1,i,y2),area2=get_sum(i+1,y1,x2,y2);
		if(area1<=u&&tot-area1<=u&&area2<=u&&tot-area2<=u){
			Node ans1=dfs(x1,y1,i,y2,area1),ans2=dfs(i+1,y1,x2,y2,area2);
			if(ans1.ans+ans2.ans>tmp.ans){//替换已有方案，更新电力剩余值 
				tmp.ans=ans1.ans+ans2.ans;
				tmp.least=min(ans1.least,ans2.least);
			}
			//比较电力剩余值，选出较大的
			else if(ans1.ans+ans2.ans==tmp.ans) tmp.least=max(tmp.least,min(ans1.least,ans2.least));
		}
	}
	for(int i=y1;i<y2;i++){//横向分割 
		int area1=get_sum(x1,y1,x2,i),area2=get_sum(x1,i+1,x2,y2);
		if(area1<=u&&tot-area1<=u&&area2<=u&&tot-area2<=u){
			Node ans1=dfs(x1,y1,x2,i,area1),ans2=dfs(x1,i+1,x2,y2,area2);
			if(ans1.ans+ans2.ans>tmp.ans){
				tmp.ans=ans1.ans+ans2.ans;
				tmp.least=min(ans1.least,ans2.least);
			}
			else if(ans1.ans+ans2.ans==tmp.ans) tmp.least=max(tmp.least,min(ans1.least,ans2.least));
		}
	}
	return f[x1][y1][x2][y2]=tmp;
}
int main(){
	scanf("%d%d%d",&n,&m,&u);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) scanf("%d",&a[i][j]),tot+=a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];//二维前缀和 
	Node res=dfs(1,1,n,m,tot);
	printf("%d %d",res.ans,res.least);
	return 0;
}
```

---


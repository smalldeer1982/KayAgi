# [HNOI2002] 公交车路线

## 题目描述

在长沙城新建的环城公路上一共有 $8$ 个公交站，分别为 A、B、C、D、E、F、G、H。公共汽车只能够在相邻的两个公交站之间运行，因此你从某一个公交站到另外一个公交站往往要换几次车，例如从公交站 A 到公交站 D，你就至少需要换 $3$ 次车。

 ![](https://cdn.luogu.com.cn/upload/pic/1297.png) 

Tiger 的方向感极其糟糕，我们知道从公交站 A 到公交 E 只需要换 $4$ 次车就可以到达，可是 tiger 却总共换了 $n$ 次车，注意 tiger 一旦到达公交站 E，他不会愚蠢到再去换车。现在希望你计算一下 tiger 有多少种可能的乘车方案。


## 说明/提示

8 条路线分别是：

(A→B→C→D→C→D→E)，(A→B→C→B→C→D→E)，

(A→B→A→B→C→D→E)，(A→H→A→B→C→D→E)，

(A→H→G→F→G→F→E)，(A→H→G→H→G→F→E)，

(A→H→A→H→G→F→E)，(A→B→A→H→G→F→E)。

#### 数据范围

$4\le n\le10^7$。

## 样例 #1

### 输入

```
6```

### 输出

```
8```

# 题解

## 作者：Mychael (赞：38)

**极度简洁的DP做法**

我们把E去掉，这个系统分成了以A为中心的完全对称的列

我们记dp[i][j]表示第i站在j次乘坐后到达的方案数

因为每次只能从相邻的站到达，那么第N次到达E的方案数等于第N-1次到达D和F的方案数


以此类推dp[i][j]=dp[i-1][j-1]+dp[i+1][j-1]       这里的i-1，i+1表示相邻的站


之前说过以A为中心完全对称，所以D和F，C和G......的方案数完全相同，只需算一边


仔细观察，每个状态只与上一个状态有关，因此可以压位为dp[4][2]


代码如下：


```cpp
#include<iostream>
using namespace std;
int dp[4][2];              //具体含义如上所述
int main()
{
    fill(dp[0],dp[0]+4*2,0);
    dp[0][0]=1;
    int N,pos=0;
    cni>>N;
    for(int k=1;k<N;k++)
    {
        pos=pos^1;
        dp[0][pos]=2*dp[1][pos^1]%1000;        //A处的方案等于两边的方案相加，由于相等只算一边的*2
        dp[1][pos]=(dp[0][pos^1]+dp[2][pos^1])%1000;
        dp[2][pos]=(dp[1][pos^1]+dp[3][pos^1])%1000;
        dp[3][pos]=dp[2][pos^1];                     //D只能由C来
    }
    cout<<2*dp[3][pos]%1000<<endl;            //E由D和F来
    return 0;        
}

```

---

## 作者：ghj1222 (赞：32)

矩阵乘法吼啊

我们可以构建8*8的方阵来代表转移路径

$\begin{pmatrix}0&1&0&0&0&0&0&1\\1&0&1&0&0&0&0&0\\0&1&0&1&0&0&0&0\\0&0&1&0&1&0&0&0\\0&0&0&1&0&1&0&0\\0&0&0&0&1&0&1&0\\0&0&0&0&0&1&0&1\\1&0&0&0&0&0&1&0\end{pmatrix}$

对就是这样的一个方阵

就是主对角线旁边的两个斜线上元素是1，其余元素是0，右上角和左下角还有两个1

代表长度为1的转移路径各有多少

然后呢对他进行N次方就代表长度为N的转移路径了

然后我们就很容易得到这样一个代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define p 1000

struct matrix
{
	int a[8][8];
	matrix(int option = 0)
	{
		memset(a, 0, sizeof(a));
		if (option == 1)
			for (int i = 0; i < 8; i++)
				a[i][i] = 1;
		if (option == 2)
		{
			for (int i = 0; i < 7; i++)
				a[i][i + 1] = a[i + 1][i] = 1;
			a[0][7] = a[7][0] = 1;
		}
	}
};

matrix operator*(const matrix &x, const matrix &y)
{
	matrix ans(0);
	for (int k = 0; k < 8; k++)
		for (int i = 0; i < 8; i++)
			for (int j = 0; j < 8; j++)
				(ans.a[i][j] += x.a[i][k] * y.a[k][j]) %= p;
	return ans;
}

matrix qpow(matrix d, int N)
{
	matrix ans(1);
	while (N > 0)
	{
		if (N & 1)
			ans = ans * d;
		d = d * d;
		N >>= 1;
	}
	return ans;
}

int main()
{
	int N;
	scanf("%d", &N);
	printf("%d\n", qpow(matrix(2), N).a[0][4]);
	return 0;
}
```

然而这个代码。。。

Input = 6

Output = 12

Wrong Answer

gg了，为啥？

题目中有明确要求，如果Tiger走到公交站E就不会去换车，也就是说E不会有出边，这样我们把矩阵稍作修改

$\begin{pmatrix}0&1&0&0&0&0&0&1\\1&0&1&0&0&0&0&0\\0&1&0&1&0&0&0&0\\0&0&1&0&1&0&0&0\\0&0&0&0&0&0&0&0\\0&0&0&0&1&0&1&0\\0&0&0&0&0&1&0&1\\1&0&0&0&0&0&1&0\end{pmatrix}$

然后就能AC了

AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

#define p 1000

struct matrix
{
	int a[8][8];
	matrix(int option = 0)
	{
		memset(a, 0, sizeof(a));
		if (option == 1)
			for (int i = 0; i < 8; i++)
				a[i][i] = 1;
		if (option == 2)
		{
			for (int i = 0; i < 7; i++)
				a[i][i + 1] = a[i + 1][i] = 1;
			a[0][7] = a[7][0] = 1;
			a[4][3] = a[4][5] = 0;
		}
	}
};

matrix operator*(const matrix &x, const matrix &y)
{
	matrix ans(0);
	for (int k = 0; k < 8; k++)
		for (int i = 0; i < 8; i++)
			for (int j = 0; j < 8; j++)
				(ans.a[i][j] += x.a[i][k] * y.a[k][j]) %= p;
	return ans;
}

matrix qpow(matrix d, int N)
{
	matrix ans(1);
	while (N > 0)
	{
		if (N & 1)
			ans = ans * d;
		d = d * d;
		N >>= 1;
	}
	return ans;
}

int main()
{
	int N;
	scanf("%d", &N);
	printf("%d\n", qpow(matrix(2), N).a[0][4]);
	return 0;
}
```

解释一下为什么邻接矩阵可以做乘法（因为他是矩阵啊）  
这里我们规定邻接矩阵中$a[i][j]$表示i->的边数(而非路径长度)  
然后呢根据矩阵乘法的定义，$\displaystyle(a*b)[i][j]=\sum_{k=1}^na[i][k]*b[k][j]$根据乘法原理和加法原理，$a[i][k]*b[k][j]$就是由i经过k到j的路径数，那么把k枚举一遍就是i经过j走过两条边的路径数

让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)

---

## 作者：quest_2 (赞：20)

一道矩乘优化的板子题（或许？）

关于矩乘，珂以康康窝的[博客](https://www.luogu.com.cn/blog/quest233/kuo-zhan-ou-ji-li-dei-sheng-fa-ni-yuan-ju-zhen-sheng-fa)。

这篇题解重点在于讲**为什么**这道题可以用矩乘优化。

## $\mathcal{STEP\ 1}\ $

我们先来想一下**递推式子**是什么。

人站在 $i$ 号站台，假设我们要走到 $j$ 号站台。

因为我们能**一次乘车**就到的站点，只有**相邻**的两个位置。

那么，但凡 $j$ 与 $i$ 不是相邻的站台，就**至少需要**经过一个其他的站台转车。

假设我们有一个中转站为 $k$ 号站点。

首先，我们要到达这个中转站 $k$ ，就有多种方法，这里记之为 $method_{\ i->k}$ 。

其次，我们从 $k$ 再到 $j$ 号站点，又有多种办法 ，记之为 $method_{\ k->j}$ 。

这样一来我们就可以根据**乘法原理**， _（ 一项事件要经过A,B两个步骤，A步骤有 $N$ 种情形，B步骤有 $M$ 种情形，则整项事件共有 $M \cdot N$ 种情形 ）_ ，得到从 $i$ 经过 $k$ 到 $j$ 方案数为：

$$ method_{\ i->k->j} =(method_{\ i->k}) \times (method_{\ k->j})$$

但这只是以 $k$ 为中转站的情况，事实上，任何 $i$ 与 $j$ 之间的点，都可能成为 $i$ 到 $j$ 的中转站。

而根据**加法原理**， _(一项事件有 $N$ 种情况，第 $i$ 种情况中又下分 $x_i$ 种情况，则整项事件的情况数为所有 $x_i$ 的和）_ ，$i$ 到 $j$ 的总方案数，就等于**每个点作为中转站**时，方案数的**总和**。也就是说：

$$method_{\ i->j} = \sum_{x=1}^{x<=8} method_{\ i->x->j}$$

也就是等于：

$$method_{\ i->j} = \sum_{x=1}^{x<=8}\ (method_{\ i->x} \times method_{\ x->j})$$

这就很像区间DP里枚举断点的操作，不同的是，这里取的是所有断点时方案的总和。

至此，我们有了一个可行的转移方程。

## $\mathcal{STEP\ 2}\ $

关于矩乘，在此不必多言。矩阵 $a\ $,$\ b$ 相乘，积矩阵上的 $ans.num_{i,j}$ 位置，就为：

$$ans.num_{\ i,j}=\sum_{k=1}^{k\leq matrix's\ size} (a.num_{\ i,k}\times b.num_{\ k,j})$$ 

**这矩乘的规则，是否与我们推出转移方程有几分相似？**

矩阵优化DP的思想，便是来源于这里。

我们把 $method_{\ i->j} $ 存入一个乘数矩阵里。

如 $method_{\ 1->5} $ ，我们应该让他可以在矩阵的 $(1,5)$ 位置，访问到这个值。在递推的时候，直接把乘数矩阵**乘上**单位矩阵即可。

我们递推的过程，就在这矩阵乘法的规则中完成了。

这里可以直接给出用于转移的**单位矩阵**。

$$\begin{bmatrix}0&1&0&0&0&0&0&1\\1&0&1&0&0&0&0&0\\0&1&0&1&0&0&0&0\\0&0&1&0&1&0&0&0\\0&0&0&1&0&1&0&0\\0&0&0&0&1&0&1&0\\0&0&0&0&0&1&0&1\\1&0&0&0&0&0&1&0\end{bmatrix}$$


我们以乘数矩阵第1行第3个为例，代表着从 $1$ 号点到 $3$ 号点的方案数，也就是 $method_{\ 1->3}$ 。

$1$ 到 $3$ ，我们有 $8$ 个位置可以做我们的中转站 _（在这里我埋了个伏笔，现在这么写是为了理解方便）_ 。因为矩阵乘法的规则，$ans.num_{\ i,j}$ 会**累加**上 $(a.num_{\ i,k}\times b.num_{\ k,j})$，我们从 $1$ 到 $8$ 枚举 $k$ ，那么 $ans.num_{\ 1,3}$ 最后就会是:

$$(a.num_{\ 1,1}\times b.num_{\ 1,3})+\cdots +
(a.num_{\ 1,8}\times b.num_{\ 8,3})$$ 

这是我们期待得到的结果。

而要求第 $P$ 正好到达目的地，则可以以 $P$ 作为**矩阵快速幂的幂次**，跑快速幂。再将快速幂的结果**与乘数矩阵相乘**。

为什么是 $P$ 次幂？

不知诸位是否发现，这个单位矩阵，正是以“ **对于 $(i,j)$ 这一位置，若 $i$ 到 $j$ 能一步走到则为1，否则为0** “这一信条构建的。

而这一信条的实际意义，就是“ **从 $i$ 处一步走到 $j$ 的方案数** ”。

而单位矩阵，实则就是单位矩阵本身的 $1$ 次幂。

那么乘数矩阵与单位矩阵相乘了几趟，其实就是用这种方式**转移了几次**，也就是第几步能到目的地。

那么我们就可以用结合律，把连乘写成幂的形式。

## $\mathcal{STEP\ 3}$

但我们真的有 $8$ 个点可以做中转站吗？

我们看看题目怎么说的：

```
注意 tiger 一旦到达公交站 E，他不会愚蠢到再去换车
```

也就是说，**目的地是不能作为中转站的**，这里的目的地定死为 $E$ ，也就是初始化单位矩阵时，要注意**第 $5$ 行不应出现 $1$ **。

最终矩阵应如下：

$$\begin{bmatrix}0&1&0&0&0&0&0&1\\1&0&1&0&0&0&0&0\\0&1&0&1&0&0&0&0\\0&0&1&0&1&0&0&0\\0&0&0&0&0&0&0&0\\0&0&0&0&1&0&1&0\\0&0&0&0&0&1&0&1\\1&0&0&0&0&0&1&0\end{bmatrix}$$

那最终代码就很好写了，无非是一个矩乘的板子：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1000;
struct matrix
{
     int num[17][17];
} ORZ, RBQ;//ORZ乘数矩阵，RBQ单位矩阵

/*矩乘板子*/
matrix operator*(const matrix &x, const matrix &y)
{
     matrix ans;
     memset(ans.num, 0, sizeof(ans.num));
     for (int k = 1; k <= 8; k++)
          for (int i = 1; i <= 8; i++)
               for (int j = 1; j <= 8; j++)
                    ans.num[i][j] = (ans.num[i][j] + x.num[i][k] * y.num[k][j]) % MOD;
     return ans;
}

/*快速幂板子，我用的是递归版快速幂*/
matrix quick_pow(matrix a, int p)
{
     if (p == 1)
     {
          return a;
     }
     matrix tmp = a * a;
     if (p % 2 == 0)
     {
          return quick_pow(tmp, p / 2);
     }
     return quick_pow(tmp, p / 2) * a;
}


int main()
{
     memset(RBQ.num, 0, sizeof(RBQ.num));
     memset(ORZ.num, 0, sizeof(ORZ.num));
     
     /*初始化RBQ*/
     for (int i = 1; i <= 8; i++)
     {
          if (i == 5)
               continue;//第5行应跳过
          RBQ.num[i][i - 1] = RBQ.num[i][i + 1] = 1;
     }
     RBQ.num[8][1] = RBQ.num[1][8] = 1;
     for (int i = 1; i <= 8; i++)
     {
          ORZ.num[i][i] = 1;
          //这里的意思是说，就算一步也不走，自己到达自己也有1种方案
     }
     
     
     int P;
     cin >> P;
     cout << (ORZ * quick_pow(RBQ, P)).num[1][5] << endl;
     //输出的是 method[1->5]，1到5的方案数
}
```
~~这是一道很板的板子~~，像今年NOI的Day1T1就有考察到这一知识点。

------------

------------


------------


------------


---

## 作者：Md_Drew (赞：10)

## 最优的矩阵递推

我们发现这道题的数据很小，但是 n = 1e18 时, 我们仍然可以通过矩阵优化来过的。只是原始矩阵不同而已。

------------

我们发现从起点到终点， 步数为偶数步， 而我们绕圈子走的步数也是偶数步(到了终点就必须停)。

所以 n 为奇数时，方案数为零。

我们考虑将 n>>=1;

```cpp

f[i]	表示走i/2步的方案数  ( !(i&1) )
 
通过手动计算或是搜索（当然你也可以通过之前的dp方程推出）：

f[1] = 0;
f[2] = 2;
f[3] = 8;
f[4] = 28;
f[5] = 96;
.........
.........

我们可以推出递推式：

f[i] = 4*f[i-1] -2*f[i-2]   (i>2);


```

因而我们的递推矩阵为:

| 4 | 1 |
| :----------: | :----------: |
| -2 | 0 |

------------

直接套模板就行了


```cpp

#include<cstdio>
#include<cstring>
#define rei register int
#define ll long long
using namespace std;
const int mod = 1000;

ll n;

struct Matrix	//结构体好处多多
{
	ll a[3][3];
}A, temp;

Matrix M_mul(Matrix x, Matrix y)
{
	memset(temp.a,0,sizeof(temp.a) );	
	
	for(int i=1;i<=2;++i)
		for(int j=1;j<=2;++j)
			for(int k=1;k<=2;++k)
				temp.a[i][j] = ( temp.a[i][j]%mod + (x.a[i][k]%mod)*(y.a[k][j]%mod)%mod )%mod;	
	return temp;
}

Matrix ksm(Matrix A, ll k)	//和普通快速幂差不多
{
	Matrix ans; Matrix base = A;
	memset(ans.a,0,sizeof(ans.a) );
	ans.a[1][1] = ans.a[2][2] = 1;
	
	while(k)
	{
		if(k&1)	ans = M_mul(ans,base);
		base = M_mul(base,base);
		k>>=1;
	}
	return ans;
}

int main()
{
	scanf("%lld",&n);
	if(n&1 || n==2)		return printf("0"), 0;  //特判
	if(n==4)			return printf("1"), 0;
	n>>=1;
	A.a[1][1] = 4, A.a[1][2] = 1, A.a[2][1] = -2;
	
	Matrix ans = ksm(A,n-2);
	printf("%lld",(2*ans.a[1][1]%mod +mod)%mod ); //可能会爆负数
	return 0;
}


```

---

## 作者：Kelin (赞：8)

其实我们可以发现楼下的递推式是可以矩阵加速的

可以先去A掉这道模板题-->https://www.luogu.org/problem/show?pid=1939

可以推出我们每一次操作就是乘了一个这样的矩阵

a:
0 1 0 0

2 0 1 0

0 1 0 1

0 0 1 0

于是就直接矩阵快速幂了

因为一开始的dp数组是1 0 0 0

所以ans=a[0][3]\*2%1000

```cpp
#include<cstdio>
struct matrix{
    int a[4][4];
    matrix(){for(int i=0;i<4;++i)for(int j=0;j<4;++j)a[i][j]=i==j;}
    inline matrix operator*(const matrix&b){
        matrix c;
        for(int i=0;i<4;++i)
            for(int j=0;j<4;++j){
                c.a[i][j]=0;
                for(int k=0;k<4;++k)c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%1000;
            }
        return c;
    }
    inline void transform(){for(int i=0;i<4;++i)for(int j=0;j<4;++j)a[i][j]=0;a[0][1]=a[1][2]=a[2][1]=a[2][3]=a[3][2]=1;a[1][0]=2;}
}a;
inline matrix powMod(matrix a,int b){matrix x;for(;b;b>>=1,a=a*a)if(b&1)x=x*a;return x;}
int main(){
    int n;scanf("%d",&n);a.transform();
    a=powMod(a,n-1);printf("%d",2*a.a[0][3]%1000);
return 0;
}
```

---

## 作者：123456zmy (赞：6)

~~本来想写dp，结果边写边优化就成了递推~~

把FGHABCD依次编为1~7号~~不按字母顺序是因为之前是写dp~~

下面是几个优化：

- 走的步数多了是因为往回走了，所以总共的步数是偶数。n为奇数时直接输出0。

- 一次走两步可以避免走到编号为奇数的点。~~（我也不知道自己怎么想到这么写的）~~

- 向两边走是等效的，于是就只要计算一边的方案数再乘2输出。

~~（于是dp就写成了递推）~~


代码细节：走两步有两种方法可以回到原来的地方，要记得乘2。


[AC](https://www.luogu.org/record/23885258)代码如下：（127ms）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
int main()
{
	b=1;
	scanf("%d",&n);
	if(n&1)				//是奇数
	{
		putchar(48);		//输出0
		return 0;
	}
	n>>=1;				//一次走两步
	for(int i=1;i<n;i++)		//最后还要留两步去终点
	{
		a=(a<<1)+b;
		b+=a;
		while(a>999)a-=1000;	//取模，直接模比较慢
		while(b>999)b-=1000;
	}
	if((a=a<<1)>999)a-=1000;	//乘2
	printf("%d",a);			//输出
	return 0;
}
```


---

## 作者：asuldb (赞：4)

感性理解还是很神的，我觉得还是应该讲一讲为什么可以直接用邻接矩阵来做矩阵乘法

~~当然您要是很神的话可以不用听这一段~~

我们看看我们最初的邻接矩阵，$G[i][j]=1$表示$i$到$j$有一条边，也就是如果只是走一步从$i$到$j$只有一种方案数；$G[i][j]=0$表示$i$到$j$没有边，也就是如果只是走一步从$i$到$j$方案数为0

我们再来看看矩阵乘法的定义

$G^{k}[i][j]=\sum_{p=1}^{n} G^{k-1}[i][p]*G[p][j]$

那如果我们对于邻接矩阵来说是不是可以理解为我们在枚举$p$这个点，利用乘法原理(从$i$到$j$的路径数等于从$i$到$p$的路径数与$p$到$j$的路径数相乘，这个好像是乘法原理的经典例子吧)和加法原理(对于不同的$p$来说自然是不同类问题，所以我们要加起来)来统计方案数

所以对于从$i$到$j$走$k$步（允许走回头路）的方案数就是$G^{k}[i][j]$

当然这个题中我们显然是不能把E这个点做中转点

所以快速幂的时候特判一下就好了

代码就很简单了
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 9
using namespace std;
const int mod=1000;
int a[maxn][maxn],ans[maxn][maxn];
int n,k;
inline void did_a()
{
	int mid[maxn][maxn];
	for(re int i=1;i<=8;i++)
	for(re int j=1;j<=8;j++)
		mid[i][j]=a[i][j],a[i][j]=0;
	for(re int i=1;i<=8;i++)
	for(re int j=1;j<=8;j++)
	for(re int p=1;p<=8;p++)
	if(p!=5) a[i][j]=(a[i][j]+(mid[i][p]*mid[p][j])%mod)%mod;
}
inline void did_ans()
{
	int mid[maxn][maxn];
	for(re int i=1;i<=8;i++)
	for(re int j=1;j<=8;j++)
		mid[i][j]=ans[i][j],ans[i][j]=0;
	for(re int i=1;i<=8;i++)
	for(re int j=1;j<=8;j++)
	for(re int p=1;p<=8;p++)
	if(p!=5) ans[i][j]=(ans[i][j]+(mid[i][p]*a[p][j])%mod)%mod;
}
inline void quick(int b)
{
	while(b)
	{
		if(b&1) did_ans();
		b>>=1;
		did_a();
	}
}
int main()
{
	scanf("%d",&k);
	for(re int i=1;i<=8;i++)
		a[i][i+1]=ans[i][i+1]=a[i+1][i]=ans[i+1][i]=1;
	ans[1][8]=a[1][8]=ans[8][1]=a[8][1]=1;
	quick(k-1);
	printf("%d",ans[1][5]);
	return 0;
}
```

---

## 作者：china·xyc (赞：4)

挑战全网最快!!

#### 做法一O(N)
直接递推，$dp[i][j]$表示Tiger在换了i次车时位于j的方案数，最后输出$dp[n][E]$

由于这是2002年的题，所以用现在的评测机O(N)也能过
#### 做法二O(8^3logN)
矩阵乘法，转移矩阵如下
| 0 | 1 |0|0|0|0|0|1|
|--|--|--|--|--|--|--|--|
| 1 | 0 |1|0|0|0|0|0|
| 0 | 1 |0|1|0|0|0|0|
| 0 | 0 |1|0|1|0|0|0|
| 0 | 0 |0|0|0|0|0|0|
| 0 | 0 |0|0|1|0|1|0|
| 0 | 0 |0|0|0|1|0|1|
| 1 | 0 |0|0|0|0|1|0|
不说了。
#### 做法三O(5^3logN)
由于这个图左右是对称的，所以B和H，C和G，D和F的方案数都是一样的，所以只需要存5个点就好了。

转移矩阵就不放了，和做法二类似。
#### 做法四O(2^2logN)
由于此题图形都是一样的，所以最终答案是有通项公式的！

然后我们先写出递推式：

 - $a(0)=1$
 - $a(n)=2b(n-1)$
 - $b(n)=a(n-1)+c(n-1)$
 - $c(n)=b(n+1)+d(n-1)$
 - $d(n)=c(n-1)$
 - $e(n)=2d(n-1)$

写出生成函数（OGF），和生成函数之间的5个方程

 - $A(z)=2zB(z)+1$
 - $B(z)=zA(z)+zC(z)$
 - $C(z)=zB(z)+zD(z)$
 - $D(z)=zC(z)$
 - $E(z)=2zD(z)$

解关于$A(z),B(z),C(z),D(z),E(z)$，含参数$z$的五元一次方程组，得：
$$
E(z)=\frac{2z^4}{1-4z^2+2z^4}
$$
因式分解：
$$
k_1=2+\sqrt2,k_2=2-\sqrt2
$$
$$
E(z)=\frac{2z^4}{(1-k_1z^2)(1-k_2z^2)}
$$
我们来好好理解一下这个式子：

 1. 分子是个最低次为4次的多项式，因为从A到E最少要换乘4次
 2. 分母中分解后的两个多项式中每项的次数皆为偶数因为从A到E换乘的次数必然为偶数，如果是奇数那么肯定到不了E（染色法可证）

所以我们可以直接略过$e(2n+1)$（这些全是0），只用计算$e(2n)$即可。

让我们直接写出$e(2n)$的生成函数（OGF）$F(z)$
$$
F(z)=\frac{2z^2}{(1-k_1z)(1-k_2z)}
$$只需要满足$F(z^2)=E(z)$即可

定义$f(n)=e(2n)$，则$f(1)=f(0)=0$（因为只通过2次换乘到不了E）

所以直接把$z^2$从分母中提出来：
$$F(z)=z^2\frac{2}{(1-k_1z)(1-k_2z)}$$

再根据有理生成函数的一般展开定理：
$f(n+2)=a_1*{k_1}^n+a_2*{k_2}^n$
已知两个等式（一个显而易见，一个是样例给的）：
$$f(2)=2,f(3)=8$$代入$f(n+2)=a_1*{k_1}^n+a_2*{k_2}^n$就能求出系数$a_1,a_2$了！！胜利在望

解得$a_1=1+\sqrt2,a_2=1-\sqrt2$

所以最后的通项公式为：
$$
f(n+2)=(1+\sqrt2)(2+\sqrt2)^n+(1-\sqrt2)(2-\sqrt2)^n
$$
由于两个可以表示成$a\sqrt2+b$的数相乘还是可以表示成$a\sqrt2+b$，所以把原来的乘法改成4次乘法然后快速幂就可以了。

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace fastio{
	template<typename tn> void read(tn &a){
	    tn x=0,f=1;char c=' ';
	    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	    for(;isdigit(c);c=getchar() ) x=x*10+c-'0';
	    a=x*f;
	}
	template<typename tn> void print(tn a){
	    if(a<0) putchar('-'),a=-a;
	    if(a>9) print(a/10);
	    putchar(a%10+'0');
	}
};
using namespace fastio;
const int mod=1000;
struct num{
	int a,b;
	num operator *(const num x)const{
		num ret;
		ret.b=(2*x.a*a+x.b*b)%mod;
		ret.a=(x.a*b+x.b*a)%mod; 
		return ret;
	}
	num operator +(const num x)const{
		num ret;
		ret.a=(x.a+a)%mod;
		ret.b=(x.b+b)%mod; 
		return ret;
	}
};
int n;
num poww(num a,int b){
	num ans=(num){0,1};
	while(b){
		if(b&1) ans=ans*a;
		a=a*a;
		b>>=1; 
	}
	return ans;
}
int main(){
	read(n);
	if(n&1){
		puts("0");
		return 0;
	}
	n>>=1;
	n-=2;
	if(n<0){
		puts("0");
		return 0;
	}
	num ans=(num){1,1}*poww((num){1,2},n);
	printf("%d\n",ans.b*2%mod);
	return 0;
}
```

提交！

然而并没有比矩阵乘快到那里去（我杀我自己）

---

## 作者：幻离ian (赞：2)

### 极致简约的dp
~~虽然跑得很慢……~~

## 思路：

以F为起点，FGHABCD围一圈，A为第四个点，E在dp过程中不用考虑。

以步数为阶段，设$f[i][j]$表示第i步到达j点的总方案数,可由左右点跳来。

转移方程为：$f[i][j]=f[i-1][j-1]+f[i-1][j+1]$

此时可以发现i只与i-1时的状态有关，用滚动数组优化成$f[2][8]$的数组。

上代码：

```cpp
#include <iostream>
using namespace std;
int n,f[2][8]={{0,0,0,0,1}},t=1;
signed main(){
	cin>>n;
	for(int i = 1;i<=n-1;i++,t^=1)
		for(int j = 1;j<=7;j++)//不dpE点
			f[t][j]=(f[t^1][j-1]+f[t^1][j+1])%1000;
	cout<<(f[t^1][7]+f[t^1][1])%1000;
}
```



---

## 作者：Wuyanru (赞：2)

当我第一眼看到这道题的时候，发现这不就是一道水题吗？再一看 $ n $ 的范围，好吧，可能这道题不像我想象的这样简单。

其实这道题真正的解法是动态规划或是矩阵乘法，我先说一下哈，我主要讲解的做法是矩阵快速幂。

既然是矩阵快速幂，那就必须要有矩阵的出现才行了，如果现在有一个用于快速幂的矩阵 $ \mathbf{A} $,那么我们就可以用 $ \mathbf{A_{m,n}} $ 表示从位置 $ m $ 走一步可以走到位置 $ n $,所以我们的矩阵可以表示成下图的这个样子。

$ \begin{pmatrix}
0  &1  &0  &0  &0  &0  &0  &1 \\
1  &0  &1  &0  &0  &0  &0  &0 \\
0  &1  &0  &1  &0  &0  &0  &0 \\
0  &0  &1  &0  &1  &0  &0  &0 \\
0  &0  &0  &0  &0  &0  &0  &0 \\
0  &0  &0  &0  &1  &0  &1  &0 \\
0  &0  &0  &0  &0  &1  &0  &1 \\
1  &0  &0  &0  &0  &0  &1  &0
\end{pmatrix} $

由于位置五为公交站 $ E $,所以不能到任何一个车站去。

又因为本题需要求出经过 $ n $次换车后的方案，所以快速幂的指数应该是 $ n $。

最后一个最最关键的事情，不要忘了取模。

由于我是之前编的矩阵结构体，所以代码会长那么亿些些，各位不要见怪。

AC代码：

```
#include<cstring>
#include<cstdio>
using namespace std;
struct mat
{
    int m,n;
    long long a[101][101];
    static const int mod=1000;
    mat operator + (mat b)//矩阵的加法
    {
        mat ans;
        memset(ans.a,0,sizeof(ans.a));
        ans.m=m,ans.n=n;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                ans.a[i][j]=a[i][j]+b.a[i][j];
        return ans;
    }
    void operator += (mat b)
    {
        for(int i=1;i<=m;i++)   
            for(int j=1;j<=n;j++)
                a[i][j]+=b.a[i][j];
    }
    mat operator - (mat b)//矩阵的减法
    {
        mat ans;
        memset(ans.a,0,sizeof(ans.a));
        ans.m=m,ans.n=n;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                ans.a[i][j]=a[i][j]-b.a[i][j];
        return ans;
    }
    void operator -= (mat b)
    {
        for(int i=1;i<=m;i++)   
            for(int j=1;j<=n;j++)
                a[i][j]-=b.a[i][j];
    }
    mat operator * (mat b)//矩阵的乘法
    {
        mat ans;
        memset(ans.a,0,sizeof(ans.a));
        ans.m=m;
        ans.n=b.n;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=b.n;j++)
                for(int p=1;p<=n;p++)
                    (ans.a[i][j]+=(a[i][p]*b.a[p][j]))%=mod;//别忘了取模
        return ans;
    }
    void operator *= (mat b)
    {
        (*this)=(*this)*b;
    }
    mat operator ^ (long long t)//矩阵快速幂
    {
        mat ans,num;
        ans.m=ans.n=m;
            num=(*this);
        memset(ans.a,0,sizeof(ans.a));
        for(int i=1;i<=m;i++)
            ans.a[i][i]=1;
        while(t)
        {
            if(t&1)
                ans=ans*num;
            num=num*num;
            t>>=1;
        }
        return ans;
    }
    void operator ^= (long long t)
    {
        (*this)=(*this)^t;
    }
    mat operator % (long long t)
    {
        mat ans;
        ans.m=m,ans.n=n;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                ans.a[i][j]=a[i][j]%t;
        return ans;
    }
    void operator = (mat b)//矩阵的赋值
    {
        m=b.m,n=b.n;
        for(int i=1;i<=b.m;i++)
            for(int j=1;j<=b.n;j++)
                a[i][j]=b.a[i][j];
    }
    bool operator == (mat b)
    {
        if(m!=b.m||n!=b.n)
            return false;
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                if(a[i][j]!=b.a[i][j])
                    return false;
        return true;
    }
    void inn()//下面是一大堆乱七八糟的东西
    {
        scanf("%d",&n);
    }
    void inm()
    {
        scanf("%d",&m);
    }
    void innn()
    {
        inm();
        n=m;
    }
    void inmn()
    {
        inm();
        inn();
    }
    void ina()
    {
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                scanf("%d",&a[i][j]);
    }
    void in()
    {
        inmn();
        ina();
    }
    void outm()
    {
        printf("%d\n",m);
    }
    void outn()
    {
        printf("%d\n",n);
    }
    void outmn()
    {
        printf("%d %d\n",m,n);
    }
    void outa()
    {
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
                 printf("%d ",a[i][j]);
            printf("\n");
        }
    }
    void out()
    {
        outmn();
        outa();
    }
    void clear()//初始化清空，怕出事
    {
    	memset(a,0,sizeof(a));
    	m=0;
    	n=0;
    }
};
//老长老长的矩阵结构体了
int main()
{
    mat num,ans;
    num.clear();
    ans.clear();
    num.m=num.n=8;//num用于进行矩阵快速幂
    num.a[1][2]=1;
    num.a[1][8]=1;
    num.a[2][1]=1;
    num.a[2][3]=1;
    num.a[3][2]=1;
    num.a[3][4]=1;
    num.a[4][3]=1;
    num.a[4][5]=1;
    num.a[6][5]=1;
    num.a[6][7]=1;
    num.a[7][6]=1;
    num.a[7][8]=1;
    num.a[8][7]=1;
    num.a[8][1]=1;
    int n;
    scanf("%d",&n);
    ans.m=1;
    ans.n=8;
    ans.a[1][1]=1;
    num=num^n;//简洁的矩阵快速幂
    ans=ans*num;
    printf("%d",ans.a[1][5]);//输出
    return 0;
}
```


---

## 作者：Ciyang (赞：2)

其实这题不需要矩阵优化，发布一下空间最优、写起来最简单的代码。

### 分析

这道题车站数是固定为8的，然后再看$N < 10^7$，会发现可以动态规划。

动态规划数组$F[N][M]$，表示换了N次车，到达第M个车站。

每次从M相邻的车站转移，把车站编号为1到8，E的编号为5。特判不能从编号为5的车站转移。

复杂度$O(NM)$，所以并不会超时，不需要用矩阵优化。感觉空间可能不够，那么很容易想到开滚动数组。

这道题如果将N增大才需要用矩阵优化。

### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
int n, f[2][10];
int main() {
	cin >> n;
	f[0][1]= 1;
	for(int i= 1; i <= n; i++) {
		for(int j= 1; j <= 8; j++) {
			f[i & 1][j]= 0;
			if((j + 6) % 8 + 1 != 5) f[i & 1][j]= (f[i & 1][j] + f[(i & 1) ^ 1][(j + 6) % 8 + 1]) % 1000;
			if(j % 8 + 1 != 5) f[i & 1][j]= (f[i & 1][j] + f[(i & 1) ^ 1][j % 8 + 1]) % 1000;
		}
	}
	cout << f[n & 1][5] << endl;
	return 0;
}
```

---

## 作者：p_b_p_b (赞：2)

无聊发题解

这题我用的是矩阵乘法，连dp方程都没有推

老师原来讲过，路线方案数可以用类似于floyd的思想解答

就是在矩阵中存方案数

如：一开始mat[0][1]=1代表走一步，从0到1的路径条数

二次幂就变成走2步

原因自己想（感性理解就可以），我就不说了（手动滑稽）

其他还有一点：题目强调了Tiger智商足够，所以做乘法时有一小细节

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Matrix
{
	int mat[30][30];
	friend Matrix operator*(const Matrix & x, const Matrix & y) 
    {
    	Matrix res;
    	memset(res.mat, 0, sizeof(res.mat));
    	for(int i = 0; i < 8; i++) 
            for(int j = 0; j < 8; j++) 
                for(int k = 0; k < 8; k++) if (k!=4)//就是这里要注意
                    res.mat[i][j]=(res.mat[i][j]+x.mat[i][k]*y.mat[k][j])%1000;
    	return res;
    }
}m,tmp;
int n;
int ksm(int x)
{
    memset(m.mat,0,sizeof(m.mat));
    memset(tmp.mat,0,sizeof(tmp.mat));
	for (register int i=0;i<8;i++) m.mat[i][i+1]=m.mat[i+1][i]=tmp.mat[i][i]=1;
    m.mat[7][0]=m.mat[0][7]=1;m.mat[7][8]=m.mat[8][7]=0;
	while (x)
    {
        if (x&1) tmp=tmp*m;
        m=m*m;
        x>>=1;
    }
    return tmp.mat[0][4];
}
int main()
{
	scanf("%d",&n);
	cout<<ksm(n);
}
```

---

## 作者：nydzsf_qwq (赞：2)

**这题其实非常简单，并不需要用到矩阵快速幂进行优化，只需要一个简单的 dp**

如果 $n$ 为奇数，显然方案数为 $0$

当 $n$ 为偶数时怎么办呢？

我们用 $0$ 表示车站 A，$1$ 表示车站 B，……，$7$ 表示车站 H。

那么车站 E 对应的数字就是 $4$。

数组 $dp[i][j]$ 表示在第 $i$ 次换车时在第 $j$ 个车站。

我们可以很快得到一个递推式：$dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]$。

其中出现的 $8$ 替换为 $0$，$7$ 替换为 $1$。

答案就是 $dp[n][4]$.

这时候我们运行代码

输入：`6`

输出：`12`

结果：WA 

再仔细读题我们发现**到达车站 E 后就不能再换乘了**，所以需要作一些修改。

$dp[i][3]$ 的值应为 $dp[i-1][2]$，$dp[i][5]$ 的值应为 $dp[i-1][6]。$

时间复杂度为 $O(8n)$，可以通过。

然而 $n$ 很大，如果正常地开数组可能会 MLE。

我们发现每次换乘时仅需要用到上一次换乘时的情况，因此可以**压位**。

AC 代码：

```c++
#include<bits/stdc++.h>
using namespace std;
int n,dp[2][8],p=1,q=0;
int main() {
	scanf("%d",&n);
	if(n%2==1) printf("0\n");
	else {
		dp[0][0]=1;
		for(int i=1;i<=n;++i) {
			for(int j=0;j<=7;++j) {
				dp[p][j]=0;
				if(j!=3) dp[p][j]+=dp[q][(j+1)%8];
				if(j!=5) dp[p][j]+=dp[q][(j+7)%8];
				dp[p][j]%=1000;
			}
			p^=1,q^=1;
		}
		printf("%d\n",dp[0][4]);
	}
	return 0;
}
```

---

## 作者：Rem_s_Danna (赞：1)

不要相信楼下那些大佬的神犇代码

这是一道非常简单的dp

这题有几个很重要的先决条件

1.车站数是不变的。

2.只有最后一步才可以到E

3.起始点在A

4.这是一个环

5.车只能到相邻的车站

既然这是一个环那就先把他拆成一条链

又因为只有最后一步才可以到E，那就把E从环上踢掉拆成只有7个元素的链

F G H A B C D

1 2 3 4 5 6 7

用二位数组s1[i][j]表示在i节点换了j次车时有几条路

又因为车只能到相邻的车站所以
s1[i][j]=s1[i-1][j-1]+s1[i+1][j-1]

然后最开始把s1[4][0]标记成1就好了

但看看数据范围7*10000000会超空间 所以要用滚动数组

贴代码：

```
#include<bits/stdc++.h>
using namespace std;
int n;
int s1[10][3];
int main()
{
	scanf("%d",&n);
	s1[4][0]=1;
	int a=0;
	for(int i=1;i<n;i++)
	{
		a^=1;
		for(int j=1;j<=7;j++)
		{
			s1[j][a]=s1[j-1][a^1]+s1[j+1][a^1];
			s1[j][a]%=1000;
		}
	}
	a^=1;
	s1[0][a]=s1[1][a^1];
	s1[8][a]=s1[7][a^1];
	printf("%d",(s1[0][a]+s1[8][a])%1000);
	return 0;
}
```

---

## 作者：_maze (赞：0)

### 题意简述

有一个 8 个节点， 8 条边的环，每条边边权为 1 。求从 1 出发，到达 5 且路径总值为 t 的，途中不经过 5 的路径方案数

### 题目分析

直接枚举显然太慢，考虑采用优化。



又因为是求图上权值方案数，所以考虑采用矩阵（因为这道题属于矩阵入门题，所以我会提一嘴如何用矩阵做权值方案问题）



显然，当路径总值为 1 时，表示方案数的矩阵 $ C $ 中当且仅当存在边 $ (u,v) $ 时 $c[u][v]$ 与 $c[v][u]$ 等于 1 ，其余时候等于 0 。



可以发现 $C$ 也是图的邻接矩阵。



又因为所有边的权值都为 1 ，所以我们在对路径总权值为 t ，终点为 p 时的路径进行转移，得到路径总权值为 t+1 的方案时，只要对与p有相连边的点的方案加 p 的方案即可（边权为1）。



用数学语言说，就是



$C_{n+1} = \sum_{p=1}^{n}C_n[i][p] * C[p][j] $



一看，这就是矩阵乘法嘛。



所以



$C_{n+1} = C_n * C$



$C_{n+1} = C^{n+1}$



于是就可以愉快地快速幂了~



---------------------------

对于这道题而言，由于题目中加了一个限制条件：这个人不会两次踏入 5 号点。所以我们要把所有以 5 号点为起点的边删去。然后答案即为 $C[1][5]$ 了。



代码如下：



```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1000;
int n,t;
struct node{
    int r,c;
    int a[105][105]; 
    node(){}
	node(const int &_r, const int &_c):r(_r), c(_c){
		memset(a, 0, sizeof(a)); 
	}  
    node operator * (const node &rhs)const{//矩阵乘
        node res;
        for(int i = 1;i <= r;i ++){
            for(int j = 1;j <= c;j ++){
                res.a[i][j] = 0;
            }
        }
        res.r = r;
        res.c = rhs.c;
		for (int i = 1; i <= r; ++i){
            for (int j = 1; j <= rhs.c; ++j){
				for (int k = 1; k <= c; ++k)
					res.a[i][j] += a[i][k] * rhs.a[k][j];
				res.a[i][j] %= mod;
			}

        }
		return res;
    }
    node operator ^ (int p) const{//快速幂
        node res(r,c), x = *this; 
        for(int i = 1;i <= r;i ++){
            for(int j = 1;j <= c;j ++){
                res.a[i][j] = 0;
            }
        }
        for(int i=0;i<=r;i++)
            res.a[i][i]=1;
        for (; p; p >>= 1, x = x * x) {
        	if (p & 1)
        	    res = res * x; 
        }
        return res; 
    }
}ju;
int main(){
    n=8;
    ju = node(n,n);
    ju.r = ju.c = n;
    int u,v;
    for(int i = 1;i < 8;i++){
        if(i != 5)//要保证没有以点 5 为起点的边
            ju.a[i][i + 1] = 1;
        if(i != 4)
            ju.a[i + 1][i] = 1; 
    }
    ju.a[1][8] = ju.a[8][1] = 1;
    scanf("%d", &t);
    ju = ju ^ t;
    printf("%d",ju.a[1][5]);
    return 0;
}
```




---

## 作者：meizhuhe (赞：0)

~~超级大水题~~

设换乘所经过的路线为 $S$。
由于“ tiger 一旦到达公交站 E，他不会愚蠢到再去换车”,故有


 $  S_1 \neq E,S_2 \neq E,\ldots,S_{n-1} \neq E ,S_n=E $


因此可以**从 E 断环为链**（如图1所示）
  ![图1](https://cdn.luogu.com.cn/upload/image_hosting/kd9mjdo9.png)
（每个节点的编号也见图一)

那么设	$f(i,j)$ 表示第 $n$ 步到达编号为 $j$ 的车站的方法数，那么显然第 $j$ 个要么是从 $(j+1)$ 走来的，要么是从 $(j-1)$ 走来的,结合边界可得
$$f(i,j) = \begin{cases}
0, &  i=0,j\neq4\\
1, &  i=0,j=4\\
f(i-1,j+1),& i\neq0,j=1 \\
f(i-1,j-1),& i\neq0,j=7 \\
f(i-1,j-1)+f(i-1,j+1),& i\neq0,1<j<7
\end{cases}$$
以及答案
$$ 
Ans=f(n-1,7)+f(n-1,1)
$$
~~生动形象地突出了此题体现了有多水~~

好了，时间复杂度 $O(n)$ ，看一眼数据， $n \leq 10^7$ ,虽然常数超大(把车站的数量看成常数），时间上能水过。但是，空间非常危险。看看转移方程，发现当前 $i$ 状态只与 $(i-1)$ 状态有关——于是考虑滚动数组。但是，发现转移既依赖 $(j-1)$ 又依赖  $(j+1)$ ,无法滚动。于是弄一个 $tmp$ 数组,将转移后的值保存在 $tmp$ 数组，阶段转移后在把 $tmp$ 数组的值复制到 $dp$ 数组中就可以了。
```cpp
#include <bits/stdc++.h>
#define MAXL 10 
using namespace std;
int dp[MAXL];
int tmp[MAXL];
const int l=8;
const int MOD=1000;
const int inf=0x7f7f7f7f; 
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<l;i++)
		dp[i]=i==4 ? 1:0;
	for(int i=1;i<n;i++)
	{
		for(int j=1;j<l;j++){
			if(j==1)
				tmp[j]=dp[j+1];
			else if(j==l-1)
				tmp[j]=dp[j-1];
			else
				tmp[j]=(dp[j+1]+dp[j-1])%MOD;
		}
		copy(tmp+1,tmp+l,dp+1);
	}
	printf("%d\n",(dp[l-1]+dp[1])%MOD);
	return 0;
}
```
咳咳，省选题，有个标签“矩阵乘法”，还是再优化一下吧。

~~相信大家都会用矩阵快速幂优化dp~~,不会的看[这里](https://www.cnblogs.com/shzr/p/9190970.html)

考虑矩阵 $A$ 满足
$\begin{bmatrix}
f(i,1),f(i,2),\cdots,f(i,7)
\end{bmatrix}\times A=
\begin{bmatrix}
f(i+1,1),f(i+1,2),\cdots,f(i+1,7)
\end{bmatrix}
$
可构造
$$ A=
\begin{bmatrix}
0&1&0&\cdots&0\\
1&0&1&\cdots&0\\
0&1&0&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&0\\
0&0&0&\cdots&1\\
0&0&0&\cdots&0
\end{bmatrix}
$$
（完整的构造见代码）

设初始的矩阵 
$$ S=\begin{bmatrix}0&0&0&1&0&0&0\end{bmatrix} $$

则最终的矩阵
$$S'=S \times A^{n-1}$$
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int MOD=1000;
template<int N,int P>
class mat{
private:
	ull A[N][P];
public:
	ull* operator[](int x)  { return A[x]; }
	ull const* operator[](int x) const { return A[x]; }
	mat() { memset(A,0,sizeof(A)); if(N==P) for(int i=0;i<N;i++) A[i][i]=1;	}
	mat<N,P> operator=(const mat<N,P>& B){
		for(int i=0;i<N;i++)
			for(int j=0;j<P;j++)
				A[i][j]=B[i][j];
		return *this;
	}
	template<int M>
	mat<N,M> operator*(const mat<P,M>& B){
		mat<N,M> C;
		for(int i=0;i<N;i++)
			for(int j=0;j<M;j++){
				C[i][j]=0;
				for(int k=0;k<P;k++)
					C[i][j]=(C[i][j]+A[i][k]*B[k][j])%MOD;
			}
		return C;
	}
	mat<N,P>& operator*=(const mat<P,P>& B){
		mat<N,P> C;
		for(int i=0;i<N;i++)
			for(int j=0;j<P;j++){
				C[i][j]=0;
				for(int k=0;k<P;k++)
					C[i][j]=(C[i][j]+A[i][k]*B[k][j])%MOD;
			}
		*this=C; 
		return *this;
	} 
	void clear(bool mode=0){
		memset(A,0,sizeof(A));
		if(mode==1&&N==P)
			for(int i=0;i<N;i++) A[i][i]=1;
	} 
};
template<int N>
mat<N,N> qpow(const mat<N,N>& A,int k){
	mat<N,N> base(A);
	mat<N,N> res;
	while(k){
		if(k&1)
			res*=base;
		base*=base;
		k>>=1;
	}
	return res;
}
int main(){
	int n;
	mat<7,7> A;
	mat<1,7> S; 
	mat<1,7> ans;
	scanf("%d",&n);
	A.clear();
	// 构造矩阵，下标从0开始 
	for(int i=0;i<7;i++)
		if(i==0) A[i][1]=1;
		else if(i==6) A[i][5]=1;
		else A[i][i-1]=A[i][i+1]=1; 
	S[0][3]=1;
                         
	ans=S*qpow(A,n-1);
	printf("%d\n",(ans[0][0]+ans[0][6])%MOD);
	return 0;
}
```


---

## 作者：信守天下 (赞：0)

## [洛谷传送门](https://www.luogu.com.cn/problem/P2233)
### 作为一位 HN OIer ，当然要为 HN 的省选的题目写题解。
## 思路
显然可以递推求方案数。

但是太慢，考虑使用矩阵乘法加速递推。

我们可以把整个路线看成一张图。

从 $n$ 号点出发，就可以到 $n - 1$ 或 $n + 1$ 号点。

于是单位矩阵就很容易的构造出来了。

$$\begin{Bmatrix}
&0 &1 &0 &0 &0 &0 &0 &1\\

&1 &0 &1 &0 &0 &0 &0 &0\\

&0 &1 &0 &1 &0 &0 &0 &0\\

&0 &0 &1 &0 &1 &0 &0 &0\\

&0 &0 &0 &1 &0 &1 &0 &0\\

&0 &0 &0 &0 &1 &0 &1 &0\\

&0 &0 &0 &0 &0 &1 &0 &1\\

&1 &0 &0 &0 &0 &0 &1 &0
\end{Bmatrix}$$

但是交上去是错的。

仔细观察题面，有一句话。

**注意 tiger 一旦到达公交站 E，他不会愚蠢到再去换车**

所以公交站 E **不会到 D 和 F** 。

所以单位矩阵应该是这样的。

$$\begin{Bmatrix}
&0 &1 &0 &0 &0 &0 &0 &1\\

&1 &0 &1 &0 &0 &0 &0 &0\\

&0 &1 &0 &1 &0 &0 &0 &0\\

&0 &0 &1 &0 &0 &0 &0 &0\\

&0 &0 &0 &1 &0 &1 &0 &0\\

&0 &0 &0 &0 &0 &0 &1 &0\\

&0 &0 &0 &0 &0 &1 &0 &1\\

&1 &0 &0 &0 &0 &0 &1 &0
\end{Bmatrix}$$

要换 $n$ 次车，所以应该是单位矩阵的 $n$ 次方。

直接套矩乘快速幂模板即可。

## $code$
~~~cpp
#include <iostream>

using namespace std;

const int Mod = 1000;
int a[8][8], b[8][8], c[8][8];  //a单位矩阵，b结果矩阵，c运算矩阵
int n;

void Mul(int a[8][8], int b[8][8]) {  //矩阵乘法
  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) {
      c[i][j] = 0;
      for (int k = 0; k < 8; k++) {
        c[i][j] = (c[i][j] + a[i][k] * b[k][j] % Mod) % Mod;
      }
    }
  }
}

void Make() {  //构造单位矩阵和结果矩阵
  for (int i = 0; i < 7; i++) {
    a[i + 1][i] = a[i][i + 1] = b[i + 1][i] = b[i][i + 1] = 1;
  }
  a[4][3] = a[4][5] = b[4][3] = b[4][5] = 0;
  a[0][7] = a[7][0] = b[0][7] = b[7][0] = 1;
  n--;  //结果矩阵初始有1次幂，所以总次幂减1
}

void Fast_Power() {  //快速幂运算
  for (int i = 1; i <= n; i <<= 1) {
    if (n & i) {
      Mul(b, a);
      copy(&c[0][0], &c[0][0] + 8 * 8, &b[0][0]);  //将答案复制到答案矩阵
    }
    Mul(a, a);  //权重平方
    copy(&c[0][0], &c[0][0] + 8 * 8, &a[0][0]);
  }
}

int main() {
  cin >> n;
  Make();
  Fast_Power();
  cout << b[0][4];  //A为0，E为4，答案就在(0,4)
  return 0;
}
~~~

---

## 作者：ricky0916 (赞：0)

首先先考虑暴力做法：

令$ dp[i][x] $表示第$i$次后到达第$x$个车站的可能性种数（$x=1$表示$A$,$x=2$表示$B$……）。

则显然有：$dp[i][1]=dp[i][8]+dp[i][2],dp[i][2]=dp[i][1]+dp[i][3]......$

（注意，$ dp[i][4]=dp[i][3],dp[i][6]=dp[i][7] $，因为到了E就无法继续走动）

时间复杂度$ O(n\times 8) $，可以通过。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int mn(int x,int y){
	return x<y?x:y;
}
inline int mx(int x,int y){
	return x>y?x:y;
}
inline int read(){
	int x=0;
	bool f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f^=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	if(f) return -x;
	return x;
}
void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
	}
	if(x/10) write(x/10);
	putchar(x%10+'0');
}
int n,dp[2][9],now=1;
const int p=1000;
void mod(){
    if(dp[now][1]>=1000) dp[now][1]-=1000;
    if(dp[now][2]>=1000) dp[now][2]-=1000;
    if(dp[now][3]>=1000) dp[now][3]-=1000;
    if(dp[now][4]>=1000) dp[now][4]-=1000;
    if(dp[now][5]>=1000) dp[now][5]-=1000;
    if(dp[now][6]>=1000) dp[now][6]-=1000;
    if(dp[now][7]>=1000) dp[now][7]-=1000;
    if(dp[now][8]>=1000) dp[now][8]-=1000;
}
int main(){
	n=read();
	dp[0][1]=1;
	for(int i=1;i<=n;i++){
          dp[now][1]=dp[now^1][8]+dp[now^1][2];
          dp[now][2]=dp[now^1][3]+dp[now^1][1];
          dp[now][3]=dp[now^1][4]+dp[now^1][2];
          dp[now][4]=dp[now^1][3];
          dp[now][5]=dp[now^1][4]+dp[now^1][6];
          dp[now][6]=dp[now^1][7];
          dp[now][7]=dp[now^1][6]+dp[now^1][8];
          dp[now][8]=dp[now^1][7]+dp[now^1][1];
          mod();
          now^=1;
	}
	write(dp[now^1][5]);
	return 0;
}
```
下面我们考虑优化。

考虑矩阵快速幂。

~~容易发现~~ 转移矩阵如下：


$$
\begin{bmatrix}
0&1&0&0&0&0&0&1\\
1&0&1&0&0&0&0&0\\
0&1&0&1&0&0&0&0\\
0&0&1&0&1&0&0&0\\
0&0&0&0&0&0&0&0\\
0&0&0&0&1&0&1&0\\
0&0&0&0&0&1&0&1\\
1&0&0&0&0&0&1&0
\end{bmatrix}
$$
其中第五行是因为不能从E到其他点而全为0。

~~那代码就很好写了~~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int mn(int x,int y){
	return x<y?x:y;
}
inline int mx(int x,int y){
	return x>y?x:y;
}
inline int read(){
	int x=0;
	bool f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f^=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	if(f) return -x;
	return x;
}
void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
	}
	if(x/10) write(x/10);
	putchar(x%10+'0');
}
const int mod=1000;
struct jz{
	int a[11][11];
	jz operator *(jz b){
		jz tmp;
		for(int i=1;i<=10;i++){
			for(int j=1;j<=10;j++){
				tmp.a[i][j]=0;
				for(int k=1;k<=10;k++){
					tmp.a[i][j]+=a[i][k]*b.a[k][j]%1000;
				}
				tmp.a[i][j]%=1000;
			}
		}
		return tmp;
	}
}dw,Or2;
inline jz ksm(jz x,int y){
	jz ret=dw;
	while(y){
		if(y&1) ret=ret*x;
		y>>=1;
		x=x*x;
	}
	return ret;
}
void init(){
	for(int i=1;i<=10;i++) dw.a[i][i]=1;
	Or2.a[1][8]=Or2.a[8][1]=1;
	for(int i=1;i<8;i++) Or2.a[i][i+1]=Or2.a[i+1][i]=1;
	Or2.a[5][4]=Or2.a[5][6]=0;
}
int n;
int main(){
	n=read();
	init();
	jz ans=ksm(Or2,n);
	write(ans.a[1][5]);
	return 0;
}
```


---

## 作者：Prean (赞：0)

# 题目大意
求环上走$ n $步从指定点到达另一指定点，到达指定点后 **不得继续移动**。

大家都做过[P1057传球游戏](https://www.luogu.com.cn/problem/P1057)吧？还记得这道题的思路吗？

设$ dp[i][j] $表示传$ i $次求传到$ j $的手上的方案数，那么

$ dp[i][j]=dp[i-1][(j-1)]%n+1+dp[i-1][(j+1)%n+1] $

此题类似，$ n $即可。

不过这样得不了全分。我们从维度来入手，优化转移。

可以看出，第二维度几乎不可优化，只能从第一维度入手。

恩，这次只和上一次有关。。。矩阵快速幂！

到这里了，该怎么构造矩阵呢？

首先观察矩阵乘法的计算方法：

$$ a_{i,j}=\sum_{k=1}^nb_{i,k} \times c_{k,j} $$

也就是行乘列qwq

对于非第一行的元素，那一行全是$ 0 $，乘上一个列还是$ 0 $，重点观察第一行。（这里把第一个矩阵和第二个矩阵转化成一个$ 1 \times n $的矩阵以方便观察）

$ a_i=\sum_{k=1}^n b_{i,k} c_k  $

唉这是不是有点儿像无向图，有边就走，没边就不走？

是的！

所以能够构造出如下转移矩阵：

$$
\begin{gathered}
\begin{matrix}
0&1&0&0&0&0&0&0\\ 
1&0&1&0&0&0&0&0\\ 
0&1&0&1&0&0&0&0\\ 
0&0&0&0&0&0&0&0\\ 
0&0&0&1&0&1&0&0\\ 
0&0&0&0&1&0&1&0\\ 
0&0&0&0&0&1&0&1\\ 
0&0&0&0&0&0&1&0\\ 
\end{matrix}
\quad
\end{gathered}
$$
因为$ 4 $不能转移，所以$ 4 $那一行全是$ 0 $QAQ

代码就不用贴了吧QAQ，蓝题都会做的dalao怎么不会把我们乘起来呢QAQAQ

---

## 作者：grass8cow (赞：0)

我们把 $F,G,H,A,B,C,D$ ，分别编号为 $1,2,3,4,5,6,7$

设 $dp_{i,j}$ 为转车 $i$ 次后来到编号为 $j$ 处的方案数。

显然 $dp_{i,j}=dp_{i-1,j-1}+dp_{i-1,j+1}$ ，特别地，$dp_{i,1}=dp_{i-1,2},dp_{i,7}=dp_{i-1,6}$

初始化 $f_{0,4}=1$ ,由于第 $n$ 次转车必到 $E$ ，第 $n-1$ 次转车就需要   $F$ 或 $D$ ，答案便为 $dp_{n-1,1}+dp_{n-1,7}$ 

这样的方法是 $O(nm)$ 的其中 $m$ 为公交车站的个数。能通过本题，但不甚优秀，$m<=100,n<=10^{18}$ ,这个算法就没了。 

于是可用矩阵快速幂优化之，方法再此就不多说了。复杂度自然是$O(m^3\log n)$ 。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct qq
{
	int a[8][8];
}ans,now;
qq mul(qq a,qq b)
{
	qq c;
	for(int i=1;i<=7;i++)for(int j=1;j<=7;j++){c.a[i][j]=0;for(int k=1;k<=7;k++)c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%1000;}
	return c;
}
int main()
{
	cin>>n;n--;
	ans.a[1][4]=1;
	for(int i=2;i<=6;i++)now.a[i][i+1]=now.a[i][i-1]=1;
	now.a[1][2]=1;now.a[7][6]=1;
	while(n)
	{
		if(n&1)ans=mul(ans,now);
		now=mul(now,now);
		n>>=1;
	}
	cout<<(ans.a[1][1]+ans.a[1][7])%1000;
	return 0;
}
```


---

## 作者：ctq1999 (赞：0)

## 题解

考虑使用动态规划。把题目中的 $A,B,\dots,H$ 设成 $1,2,\dots,8$ 。因为这是一个环，所以如果在 $E$ 切开，会发现这条链是以 $A$ 为中心对称。那么只需要考虑一边即可。

设 $f[i][j]$ 为换了 $j$ 次车后到 $i$ 的方案数。

可以知道 $f[i][j] = f[i - 1][j - 1] + f[i +1][j - 1]$ ，对于 $1$ 和 $4$，他们的转移方程分别是，$f[1][j] = 2 * f[2][j - 1]$ 、$f[4][j] = f[3][j-1]$ （对称性）。

因为只关心当前状态和上一个状态，所以可以进一步优化空间。把 $j$ 维变成 $now$，$now$ 只要是 $0$ 和 $1$ 即可，转移也就是 $now$ 从 $now \ xor \ 1$ 转移过来。 

当 Tiger 走到 $E$ 时，他就不会在换车了。所以 答案就是 $f[5][now \ xor \ 1] = f[4][now] + f[6][now]$，因为对称，所以是 $2 * f[4][now]$ 。

时间复杂度 $O(n)$ 。

## 代码

```cpp
#include <bits/stdc++.h>

#define MAXN 10000010
#define mod 1000

using namespace std;

int n;

int f[10][MAXN];

int main() {
	scanf("%d", &n);
	f[1][0] = 1;
	int now = 0;
	for (int i = 1; i < n; i++) { 
		now ^= 1;
		f[1][now] = 2 * f[2][now ^ 1] % mod;
		f[2][now] = (f[1][now ^ 1] + f[3][now ^ 1]) % mod;
		f[3][now] = (f[2][now ^ 1] + f[4][now ^ 1]) % mod;
		f[4][now] = f[3][now ^ 1] % mod;
	}
	cout << (2 * f[4][now]) % mod << endl;
	return 0;
} 
```

---

## 作者：loveccc (赞：0)

矩阵乘法，只要预处理出初始的矩阵就可以了；然后初始化F【1】：=1；还有是个环形路线，所以A可以到H；

```cpp
const po=1000;
type arr=array[1..8,1..8]of qword;
var
     a,p,q:array[1..8,1..8]of qword;
       f,ans:array[1..8]of qword;
       n,i,j,k:longint;
{function km(a,b,p:qword):qword;
var y,t:qword;
begin
   y:=0;
   while b>0 do
    begin
     if (b and 1)<>0 then y:=(y+a) mod p;
     a:=a*2 mod p;
     b:=b shr 1;
    end;
    exit(y);
end;}
procedure init;
begin
    readln(n);
    for i:=1 to 7 do
    if i<>5 then
     p[i,i+1]:=1;
    for i:=2 to 8 do
     if i<>5 then
     p[i,i-1]:=1;
     p[1,8]:=1; p[8,1]:=1;
     f[1]:=1;
end;
function  mul(x:longint):arr;
var i,j,k:longint; tmp,b:arr;
begin
    if x=1 then exit(p);
     tmp:=mul(x shr 1);
     fillchar(b,sizeof(b),0);
     for i:=1 to 8 do
      for j:=1 to 8 do
       for k:=1 to 8 do
        b[i,j]:=(b[i,j]+tmp[i,k]*tmp[k,j]) mod po;
       if x mod 2=1 then
        begin
         fillchar(tmp,sizeof(tmp),0);
         for i:=1 to 8 do
          for j:=1 to 8 do
           for k:=1 to 8 do
             tmp[i,j]:=(tmp[i,j]+b[i,k]*p[k,j]) mod po;
             b:=tmp;
          end;
          exit(b);
end;
begin
       init;
       q:=mul(n);
        for j:=1 to 8 do
         for k:=1 to 8 do
          ans[j]:=(ans[j]+f[k]*q[k,j]) mod po;
          writeln(ans[5]);
end.
```

---

## 作者：xMinh (赞：0)

有两种做法：

第一种考虑无脑DP，我们很容易就能推出来方程式

设f[i][j]表示第i步走到第j站的方案数

则f[i][j]=f[i-1][left[j]]+f[i-1][right[j]];

这样我们转移第i维的时候只和第i-1维有关，用滚动数组优化一下内存就不是事了。

不开O2用时1400ms

```cpp
#include<iostream>
#include<cstdio>
#define mod 1000
using namespace std;
int L[11],R[11],f[2][11],n,now;
int main() {
	scanf("%d",&n);
	for (int i=2;i<=7;i++) L[i]=i-1,R[i]=i+1;
	L[1]=8; R[1]=2; 
	L[8]=7; R[8]=1;
	f[0][1]=1;
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=8;j++)
			if (j!=5)
				f[now^1][j]=(f[now][L[j]]+f[now][R[j]])%mod;
		now^=1;
	}
	f[now][5]=(f[now^1][4]+f[now^1][6])%mod;
	printf("%d",f[now][5]);
}
```

第二种考虑矩阵乘法

题解里面一位 @p_b_p_b 大佬说的很好，用类似弗洛伊德的思想可以解决

不开O2用时0ms

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define mod 1000
using namespace std;
int n;

struct Matrix {
	int p[9][9];
	Matrix() {memset(p,0,sizeof(p));}
};

Matrix Mul(Matrix a,Matrix b) {
	Matrix c;
	for (int i=1;i<=8;i++)
		for (int j=1;j<=8;j++)
			for (int k=1;k<=8;k++)
				if (k!=5)
					c.p[i][j]=(c.p[i][j]+a.p[i][k]*b.p[k][j]%mod)%mod;
	return c;
}

Matrix Kasumi(Matrix a,int x) {
	Matrix ans;
	ans.p[1][1]=1;
	while (x) {
		if (x&1) ans=Mul(ans,a);
		a=Mul(a,a);
		x>>=1;
	}
	return ans;
}

int main() {
	scanf("%d",&n);
	Matrix Ans,a;
	for (int i=2;i<=7;i++) a.p[i][i-1]=a.p[i][i+1]=1;
	a.p[8][1]=a.p[1][8]=a.p[8][7]=a.p[1][2]=1;
	Ans=Kasumi(a,n);
	printf("%d",Ans.p[1][5]);
}
```



---


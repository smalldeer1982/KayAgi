# 添加括号

## 题目背景

给定一个正整数序列a(1)，a(2)，...，a(n),(1<=n<=20)

不改变序列中每个元素在序列中的位置，把它们相加，并用括号记每次加法所得的和，称为中间和。

例如:

给出序列是4，1，2，3。

第一种添括号方法:

((4+1)+(2+3))=((5)+(5))=(10)

有三个中间和是5，5，10，它们之和为:5+5+10=20

第二种添括号方法

 (4+((1+2)+3))=(4+((3)+3))=(4+(6))=(10)

中间和是3，6，10，它们之和为19。


## 题目描述

现在要添上n-1对括号，加法运算依括号顺序进行，得到n-1个中间和，求出使中间和之和最小的添括号方法。


## 说明/提示

范围在题目上有说明。


## 样例 #1

### 输入

```
4
4 1 2 3```

### 输出

```
(4+((1+2)+3))
19
3 6 10```

# 题解

## 作者：hanbingchen01 (赞：16)

一翻题解，发现题解里各位DALAO输出带括号的表达式时都先

递归计算左右括号个数，然后循环输出

我的方法比较好理解一些

首先

**第一步：DP**

设  dp[i][j] 表示从第 i 个数到第 j 个数添加 j-i+1 对括号

所能通过每一步加法得到的最优值。

那么问题来了，状态转移方程怎么列？

我们可以这么来想：

dp[i][j] 怎么得来

经过前面的计算，我们已经把第i-第j个数合并成了两个数

那么我们需要一个k(i<=k<j)来枚举合并的是哪俩个部分，

也就是加号的位置。随之，方程就出来了：

 dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1])
 
 sum[i]表示的是前i个数之和（前缀和）
 
 接下来是输出
 
 我们用 jiahao[i][j] 表示区间i-j 最优解之加号的位置
 
 我们可以把一个表达式看作一棵树，递归输出这一棵树，其中可以近似地把加号看成根，两边表达式分别是左右子树
 
 然后在递归函数里这样写：
 
 
 ```cpp
void print(long long int l,long long int r)
{
	if(l==r)
	{
		cout<<shu[l];
		return;
	}
	cout<<"(";//输出括号
	print(l,jiahao[l][r]);//输出加号右边表达式
	cout<<"+";//输出加号
	print(jiahao[l][r]+1,r);//输出加号左边表达式
	cout<<")";//输出括号
}
```

那么下一步计算过程，其实和输出表达式很像，直接看代码

```cpp
long long int jisuan(long long int l,long long int r)
{
	if(l==r)retur
	n shu[l];
	long long int temp=jisuan(l,jiahao[l][r])+jisuan(jiahao[l][r]+1,r);
	cout<<temp<<" ";
	return temp;
}
```
# **完整代码如下**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long int n,shu[50],sum[50],dp[50][50],jiahao[50][50];
long long int jisuan(long long int l,long long int r)
{
	if(l==r)retur
	n shu[l];
	long long int temp=jisuan(l,jiahao[l][r])+jisuan(jiahao[l][r]+1,r);
	cout<<temp<<" ";
	return temp;
}
void print(long long int l,long long int r)
{
	if(l==r)
	{
		cout<<shu[l];
		return;
	}
	cout<<"(";
	print(l,jiahao[l][r]);
	cout<<"+";
	print(jiahao[l][r]+1,r);
	cout<<")";
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>shu[i];
		sum[i]=sum[i-1]+shu[i];
	}
	for(int l=2;l<=n;l++)
	{
		for(int i=1;i+l-1<=n;i++)
		{
			int j=i+l-1;
			dp[i][j]=0x7fffffffff;
			for(int k=j-1;k>=i;k--)
			{
				if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]<dp[i][j])
				{
					dp[i][j]=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1];
					jiahao[i][j]=k;
				}
			}
		}
	}
	print(1,n);
	cout<<endl;
	cout<<dp[1][n]<<endl;
	long long int temp=jisuan(1,n);
	return 0;
}
```


---

## 作者：_zjz (赞：9)

## 题目描述:

给定一个正整数序列a(1)，a(2)，...，a(n),(1<=n<=20)

不改变序列中每个元素在序列中的位置，把它们相加，并用括号记每次加法所得的和，称为中间和。

例如:

给出序列是4，1，2，3。

第一种添括号方法:

((4+1)+(2+3))=((5)+(5))=(10)

有三个中间和是5，5，10，它们之和为:5+5+10=20

第二种添括号方法

(4+((1+2)+3))=(4+((3)+3))=(4+(6))=(10)

中间和是3，6，10，它们之和为19。


------------


## 解:

### 区间dp:

设f[i][j]为i,j区间合并的总代价,

容易得到:

${f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[j]-sum[i-1]}$

(类似石子合并)

其中${sum[j]-sum[i-1]}$为合并一次的代价

边界:f[i][i]=0(合并一次无代价)

但本题的关键在于输出:

### 对于输出括号时:

设一lef与rig数组记录一个数左右的括号数;

具体怎么操作需要递归输出:

#### 具体就像这样:

```cpp
void prinf(int l,int r)
{
	if(l==r)return;
	++lef[l];
	++rig[r];
	prinf(l,ans[l][r]);
	prinf(ans[l][r]+1,r);
}
```
//ans[l][r]为[l,r]区间取到最优解点的中间断点

知道了左右有多少括号,就可以直接模拟了:

#### 就像这样:

```cpp
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=lef[i];j++)
    	cout<<"(";
    	cout<<a[i];
		for(int j=1;j<=rig[i];j++)
		cout<<")"; 
		if(i!=n)cout<<"+";
    }
```

### 对于输出答案时,与上面的相似:

递归输出结果:

```cpp
void print(int l,int r)
{
	if(l==r)
	{
	    return;
	} 
	print(l,ans[l][r]);
	print(ans[l][r]+1,r);
	cout<<sum[r]-sum[l-1]<<" ";//合并一次的代价
}
```

### 完整代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long

using namespace std;

const int N=201;
int a[N],f[N][N],n,ans[N][N],sum[N],tot,lef[N],rig[N];

void print(int l,int r)
{
	if(l==r)
	{
	    return;
	} 
	print(l,ans[l][r]);
	print(ans[l][r]+1,r);
	cout<<sum[r]-sum[l-1]<<" ";
}

void prinf(int l,int r)
{
	if(l==r)return;
	++lef[l];
	++rig[r];
	prinf(l,ans[l][r]);
	prinf(ans[l][r]+1,r);
}
signed  main()
{
	cin>>n;
    memset(f,127/3,sizeof(f));
	for(int i=1;i<=n;i++)
	{
	   cin>>a[i];f[i][i]=0;
	   sum[i]=sum[i-1]+a[i];//预处理前缀和
    }
    for(int i=2;i<=n;i++)
    for(int j=1;j<=n-i+1;j++)
    {
    	for(int k=j;k<=j+i-1;k++)
    	{
    		if(f[j][k]+f[k+1][j+i-1]+sum[j+i-1]-sum[j-1]<=f[j][j+i-1])
    		{
    			f[j][j+i-1]=f[j][k]+f[k+1][j+i-1]+sum[j+i-1]-sum[j-1];
    			ans[j][j+i-1]=k;
    		}//区间长度由小到大
    	}
    }
    prinf(1,n);
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=lef[i];j++)
    	cout<<"(";
    	cout<<a[i];
		for(int j=1;j<=rig[i];j++)
		cout<<")"; 
		if(i!=n)cout<<"+";//输出合并序列
    }
    cout<<endl;
    cout<<f[1][n]<<endl;
    print(1,n); //递归输出中间和
}

```


---

## 作者：巨型方块 (赞：5)

my blog

http://blog.csdn.net/largecub233/article/details/65629548

就是区间dp；

因为一定要加n-1个括号；

输出答案的时候和加分二叉树一样；

然后从左到右是指让括号靠右，所以k尽可能靠右；


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define Ll long long
using namespace std;
int a[50],h[50],hh[50],f[50][50],g[50][50],sum[51];
int n,m;
void dfs(int x,int y){
    if(x==y)return;
    h[x]++;
    hh[y]++;
    dfs(x,g[x][y]);
    dfs(g[x][y]+1,y);
}
void DFS(int x,int y){
    if(x==y)return;
    DFS(x,g[x][y]);
    DFS(g[x][y]+1,y);
    cout<<sum[y]-sum[x-1]<<' ';
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        f[i][i]=0;
    }
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+a[i];
    for(int i=n-1;i;i--)
    for(int j=i+1;j<=n;j++)
    {
        f[i][j]=1e9;
        for(int k=i;k<j;k++){
            if(f[i][k]+f[k+1][j]+sum[j]-sum[i-1]<=f[i][j]){
                f[i][j]=f[i][k]+f[k+1][j]+sum[j]-sum[i-1];
                g[i][j]=k;
            }
        }
    }
    dfs(1,n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=h[i];j++)cout<<'(';
        cout<<a[i];
        if(!hh[i]&&i!=n)cout<<'+';
        for(int j=1;j<=hh[i];j++)cout<<')';
        if(hh[i]&&i!=n)cout<<'+';
    }cout<<endl;
    cout<<f[1][n]<<endl;
    DFS(1,n);
}
```

---

## 作者：WilliamFranklin (赞：2)

### 主要思路

我认为这是一道经典的区间 dp 问题。

在此，我把题目中所说的所有中间和的和说成“价值”，防止误解。

首先设 $dp_{l, r}$ 为第 $l$ 个数到第 $r$ 个数所得最小价值，$dp1_{l, r}$ 表示从 $l$ 到 $r$ 的中间和。根据题意不难看出，一段长度大于等于 $2$ 的区间，一定是由两段区间合并而成的。那么就可以得出转移方程：

$$
dp_{l, r} = \min\left({dp_{l, k} + dp_{k + 1, r} + dp1_{l, k} + dp1_{k + 1, r}}\right)
$$

其中 $k$ 表示是两个区间的分割线（$l \le k \le r$）。

好了，我们只需要求出 $dp1$ 就可求出最后的最小价值和所有中间和了。

其实 $dp1$ 的求法有很多，比如前缀和、把两个区间加起来什么的，具体看代码。

很容易地求出最后的最小价值和中间和后，开始考虑怎么输出括号方案和。

我们可以考虑再多开几个数组：$dp2_{l, r, i}$ 表示从 $l$ 到 $r$ 所分成的两个使得价值最小区间的左端点和右端点，其中 $i = 0$ 表示第一个区间的左端点，$i = 1$ 表示第一个区间的右端点，$i = 2$ 表示第二个区间的左端点，$i = 3$ 表示第二个区间的右端点。

然后怎么求呢，其实就是在 $dp$ 更新的时候，$dp2$ 也更新一下就行了。

可能有人会问：这个数组有啥用？

别急，妙用在下头。

我们在开一个数组，名叫 $dp3$，$dp3_{i, j}$ 中，$j = 0$ 表示第 $i$ 个数的前面（指贴身）有多少个左括号，$j = 1$ 表示第 $i$ 个数的后面（指贴身）有多少个右括号，$j = 2$ 表示第 $i$ 个数的后面要不要加加号。

然后前面我们都已经知道了一个区间是由那两个区间合并的，那么我们就可以深搜一边，每次深搜它的左右区间，求出 $dp3$（这就是 $dp2$ 的妙用之处）。具体怎么求和怎么输出，看看代码吧 qwq。

好啦，贴代码！

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[25], dp[25][25], dp1[25][25][4], dp2[25][25], dp3[25][3], ans[30], sum1;
void dfs(int l, int r) {
	if (r - l + 1 == 1) return;
	if (r - l + 1 == 2) {
		ans[++sum1] = dp2[l][r];
		dp3[l][0]++;
		dp3[r][1]++;
		dp3[l][2]++;
		return;
	}
	dfs(dp1[l][r][0], dp1[l][r][1]);
	dfs(dp1[l][r][2], dp1[l][r][3]);
	dp3[l][0]++;
	dp3[r][1]++;
	dp3[dp1[l][r][1]][2]++;
	ans[++sum1] = dp2[l][r];
	return;
}
int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		dp[i][i] = a[i], dp2[i][i] = a[i];
	}
	for (int len = 2; len <= n; len++)
		for (int l = 1; l + len - 1 <= n; l++) {
			int r = l + len - 1;
			dp[l][r] = 1e9;
			for (int k = l; k <= r; k++) {
				int ans = 0;
				ans += dp[l][k] + dp[k + 1][r] + dp2[l][k] + dp2[k + 1][r];
				dp2[l][r] = dp2[l][k] + dp2[k + 1][r];
				if (k == l) ans -= dp[l][k];
				if (k + 1 == r) ans -= dp[k + 1][r];
				if (ans < dp[l][r])
					dp1[l][r][0] = l, 
					dp1[l][r][1] = k,
					dp1[l][r][2] = k + 1,
					dp1[l][r][3] = r, 
					dp[l][r] = ans;
			}
		}
	dfs(1, n);
	for (int i = 1; i <= n; i++) {
		while (dp3[i][0]--) cout << '(';
		cout << a[i];
		while (dp3[i][1]--) cout << ')';
		if (dp3[i][2]) cout << '+';
	} 
	cout << endl << dp[1][n] << endl;
	for (int i = 1; i <= sum1; i++) cout << ans[i] << ' ';
}
```

其实代码还可以再优化，但在此先不优化了。。。

跑起来还挺快的，空间也比较少：

![](https://cdn.luogu.com.cn/upload/image_hosting/zrq1zf00.png?x-oss-process=image/resize,m_lfit,h_10000,w_10000)

可能会有不足的地方，求各路神仙指正，谢谢！

---

## 作者：duchengjun (赞：2)

# 题意

在两个加数的两侧添加一对括号，每次相加都可以得到一个中间结果，这些中间结果相加可以得到一个数，求最小的结果和过程。

# 分析

如果没有要求过程，这题可以变成[双倍经验](https://www.luogu.com.cn/problem/P1775)了。

区间 DP 求出最小的结果，在用递归求出过程即可。

### 在区间DP中求c数组

$c[i][j]$ 的意义：在求最小的结果的过程中同时求出 $i\sim j$ 中 ``+`` 位置。

```cpp
int DP(int l,int r){
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i];
		f[i][i]=0;
	}
	for(int l=1;l<n;l++)
		for(int i=1;i<=n;i++){
			int j=i+l;
			if(j>n)break;
			int tmp;
			for(int k=i;k<j;k++){
				if(f[i][k]+f[k+1][j]+(sum[j]-sum[i-1])<f[i][j]){
					tmp=k;
					f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+(sum[j]-sum[i-1]));
				}
			}
			c[i][j]=tmp;
		}
	return f[1][n];
}
```

### 怎么用c数组恢复添加括号后的加法算式

![](https://cdn.luogu.com.cn/upload/image_hosting/asn0teci.png)

先输出一个括号 ``(``，再递归求出 ``+`` 左边的部分，输出 ``+``，再在递归求出 ``+`` 右边的部分，最后输出一个括号 ``)``。

```cpp
void write(int l,int r){
	if(l==r){
		write_(a[l]);
		return;
	}
	int t=c[l][r];
	write_("("),write(l,t),write_("+"),write(t+1,r),write_(")");
	ans[++cnt]=sum[r]-sum[l-1];
	return;
}
```

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
//此处为快读代码
const int N=20+10;
int n;
int a[N],sum[N],f[N][N],c[N][N],ans[N],cnt;
int DP(int l,int r){
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+a[i];
		f[i][i]=0;
	}
	for(int l=1;l<n;l++)
		for(int i=1;i<=n;i++){
			int j=i+l;
			if(j>n)break;
			int tmp;
			for(int k=i;k<j;k++){
				if(f[i][k]+f[k+1][j]+(sum[j]-sum[i-1])<f[i][j]){
					tmp=k;
					f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+(sum[j]-sum[i-1]));
				}
			}
			c[i][j]=tmp;
		}
	return f[1][n];
}
void write(int l,int r){
	if(l==r){
		write_(a[l]);
		return;
	}
	int t=c[l][r];
	write_("("),write(l,t),write_("+"),write(t+1,r),write_(")");
	ans[++cnt]=sum[r]-sum[l-1];
	return;
}
int main(void){
	read_(n);
	for(int i=1;i<=n;i++)
		read_(a[i]);
	int t=DP(1,n);
	write(1,n);
	write_("\n",t,"\n");
	for(int i=1;i<=cnt;i++)
		write_(ans[i]," ");
	return 0;
}
```

---

## 作者：RC·阿柒 (赞：2)

### $\mathrm{ Updata: }$
$ 2022 . 2 . 16 $： SPJ 已加，本题解中 $ 80 $ 分的写法也能 AC。


------------

# [题目传送门](https://www.luogu.com.cn/problem/P2308)

------------

# 解：
这题明显是区间 dp（ 做法和石子合并很像 ）。

------------

首先我们设 $ f_{i,j} $ 表示从 $ i $ 到 $ j $ 区间合并后所能得到的中间和之和的最小代价，

于是就是区间 dp ~~的模板~~：

- **状态转移方程：** 
##### $ f_{i,j} = \min(f_{i,j},f_{i,k} + f_{k+1,j} + sum_{j} - sum_{i-1} ) $

其中 $ sum_{i} $ 表示前缀和，也就是从 $ a_{1} $ 到 $ a_{i} $ 的和，

所以 $ sum_{j} - sum_{i-1} $ 表示从 $ a_{i} $ 到 $ a_{j} $ 的和。

- **初始状态：**

自己和自己合并代价是 0，所以 $ f_{i,i} = 0 $  

由于是求最小代价，所以  

`memset(f,0x3f,sizeof(f))//给 f 赋一个较大值`

------------
## 输出：

这题要注意的是它的输出 （~~输出调了我一晚上~~）

- 我最开始是想在每个不同区间中找到最小时用 $ sl_{l} \gets  sl_{l}+1 $ 和  $ sr_{r} \gets  sr_{r}+1 $ 来存左右括号数，最后输出。

写法：
```cpp
int l,r;
for(int len=2;len<=n;len++)
{
    int Min=1e9;
    for(int i=1;i<=n-len+1;i++)
    {
        int j=len+i-1;
        if(f[i][j]<Min)
            l=i,r=j;
    }
    sl[l]++,sr[r]++;
}
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=sl[i];j++)
        cout<<'(';
    cout<<a[i];
    for(int j=1;j<=sr[i];j++)
        cout<<')';
    if(i!=n)
        cout<<'+';
}cout<<'\n';
```

虽过了样例，然而[ 30pts 记录](https://www.luogu.com.cn/record/69455713)。

于是百思不得其解的我拿了一位 dalao 的码对拍，立即就出错。。。

输入：
```
7
10 2 9 9 9 6 2 
```
输出：
```
//std.out:
((10+(2+9))+(9+(9+(6+2))))
130
11 21 8 17 26 47 

//bf.out:
(10+(2+(9+(9+(9+(6+2))))))
130
8 17 26 27 15 37 
```


- 观察后发现 std 是递归输出（括号层数少），于是我改了一下：

```cpp
void print(int l,int r)
{
    if(l==r)
        cout<<a[l];
    else
    {
        cout<<'(';
        print(l,num[l][r]);//num[i][j]是 i ，j 区间最小值的断点
        cout<<'+';
        print(num[l][r]+1,r);
        cout<<')';
        ans[++ans[0]]=sum[r]-sum[l-1];//这是存每个中间和
    }
}
//求f[i][j]（写在主函数里）
for(int len=2;len<=n;len++)
    for(int i=1;i<=n-len+1;i++)
    {
        int j=len+i-1;
        for(int k=i;k<=j-1;k++)
	    if(f[i][k]+f[k+1][j]+sum[j]-sum[i-1]<f[i][j])
            f[i][j]=f[i][k]+f[k+1][j]+sum[j]-sum[i-1],num[i][j]=k;//做标记num[i][j]
    }
```

于是[ 80pts 记录](https://www.luogu.com.cn/record/69457188)。（现在已能过）


- 最后在不断对拍后，发现 $ k $ 枚举的顺序也会影响 $ num_{i,j} $的值，不过题目说从左到右也许是要标记靠右的 $ k $，

所以终于[ AC ](https://www.luogu.com.cn/record/69457786)了。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int num[21][21];
int ans[21];
int a[21],sum[21];
int f[21][21];
void print(int l,int r)//递归输出
{
    if(l==r)
        cout<<a[l];
    else
    {
        cout<<'(';
        print(l,num[l][r]);
        cout<<'+';
        print(num[l][r]+1,r);
        cout<<')';
        ans[++ans[0]]=sum[r]-sum[l-1];//存中间和
    }
}
int main()
{
    ios::sync_with_stdio(0);
    memset(f,0x3f,sizeof(f));//初始化
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        sum[i]=sum[i-1]+a[i];//前缀和
        f[i][i]=0;//初始化
    }
    for(int len=2;len<=n;len++)//区间dp写法
    {
        for(int i=1;i<=n-len+1;i++)
        {
            int j=len+i-1;
            for(int k=j-1;k>=i;k--)//这里顺序改了改就过了。。。
            {
                if(f[i][k]+f[k+1][j]+sum[j]-sum[i-1]<f[i][j])
                    f[i][j]=f[i][k]+f[k+1][j]+sum[j]-sum[i-1],num[i][j]=k;
            }
        }
    }
    print(1,n);cout<<'\n';
    cout<<f[1][n]<<'\n';
    for(int i=1;i<=ans[0];i++)
        cout<<ans[i]<<" ";
    cout<<'\n';
    return 0;
}
```
#### 谢谢各位 dalao 观赏。
End

---

## 作者：chdy (赞：2)

楼下题解都是递归输出，通过学长的思路，我打出一个诡异的思路，重点思考。

本题有三问，首先第二问最简单，是一个类似于石子合并的区间dp，也最简单。

第一问是一个输出你添加的括号，这里开出一个二维字符串数组，内部就是三维的了，字符数组进行初始化每个ff[i][i]都变成当前的对应的字符，跟着fs=数组进行状态转移即可最后ff[1][n]即为答案。

第三问的话是一个括号之间的求解，第二问都求出来了那这问也不是什么大问题，直接用栈来求解即可。
代码~：

	#include<iostream>
	#include<cstdio>
	#include<cmath>
	#include<ctime>
	#include<iomanip>
	#include<queue>
	#include<vector>
	#include<stack>
	#include<map>
	#include<algorithm>
	#include<cstring>
	#include<string>
    using namespace std;
	
    inline int read()
	{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
	}
	int a[400];
	int f[30][30];
	int u[1002];
	string b[30][30];
	char ch[1000],p=0;
	int n;
	int q[5002],h=0,t=0;
	int main()
	{
    n=read();
    for(int i=1;i<=n;i++)
    a[i]=read(),u[i]=a[i],a[i]=a[i]+a[i-1];
    memset(f,10,sizeof(f));
    for(int i=1;i<=n;i++)//初始化
    {	
        f[i][i]=0;
        memset(ch,0,sizeof(ch));p=0;
        while(u[i]>0)
        {
            ch[++p]=u[i]%10+48;
            u[i]=u[i]/10;
        }
        for(int j=p;j>=1;j--)
        {
            b[i][i]+=ch[j];
        }
    }
    for(int p=2;p<=n;p++)//常规区间dp
    {
        for(int i=1;i<=n-p+1;i++)
        {
            int j=i+p-1;
            for(int k=i;k<j;k++)
            {
                if(f[i][j]>=f[i][k]+f[k+1][j]+a[j]-a[i-1])
                {
                    f[i][j]=f[i][k]+f[k+1][j]+a[j]-a[i-1];
                    b[i][j]='('+b[i][k]+'+'+b[k+1][j]+')';
                }
            }
        }
    }
    cout<<b[1][n]<<endl;
    printf("%d\n",f[1][n]);
    for(int i=0;i<b[1][n].size();i++)//栈求解
    {
        if(b[1][n][i]!=')'&&b[1][n][i]!='('&&b[1][n][i]!='+')
        {
            ++t;
            while(b[1][n][i]!=')'&&b[1][n][i]!='('&&b[1][n][i]!='+')
            {
                q[t]=q[t]*10+b[1][n][i]-48;
                i++;
            }
        }
        if(b[1][n][i]==')')
        {
            int tn=q[t];q[t]=0;--t;
            int tmp=q[t];q[t]=0;--t;
            q[++t]=tn+tmp;
            printf("%d ",tn+tmp);
        }
    }
   	return 0;
	}

---

## 作者：云雷心柠檬听 (赞：1)

### 题意简述

其实就是每次将相邻两个数替换为它们的和，代价为两个数的和，直到只剩一个数，求最小代价和以及操作方式。

### 思维路径

我们可以先求出最小代价，很明显可以用 dp 来做。定义 $f_{i,j}$ 为合并第 $i$ 个数和第 $j$ 个数的最小代价，$s_i$ 表示前 $i$ 个数的和，每次从 $i$ 到$j-1$ 枚举 $k$，得到转移方程式如下。

$$
f_{i,j}=\min(f_{i,j},f_{i,k}+f_{k+1,j}+s_j-s_{i-1})
$$

如此得到最小代价后，再寻找获得该答案的过程。

主要思路就是把转移方程式逆过来考虑。我们以区间 $i$ 到 $j$ 为例。

1. 我们枚举分割点 $k$，获得区间 $i$ 到 $k$ 和区间 $k+1$ 到 $j$。
2. 找到这两个区间的答案，即 $f_{i,k}$ 和 $f_{k+1,j}$。
3. 若可以凑成原区间答案，即 $f_{i,j}=f_{i,k}+f_{k+1,j}+s_j-s_{i-1}$，深入 dfs 区间 $i$ 到 $k$ 和区间 $k+1$ 到 $j$。
4. 若无法凑成原区间答案，返回第一步，继续枚举 $k$。

如此便可以得到最小代价的操作方式，即在题目中的加括号的方式。

### 具体实现

dp 步骤即三个循环，读者可以自行查看后续的 AC 代码，这里不再赘述。

而 dfs 细节较多，需要注意。

dfs 为 $\text{bool}$ 类型的返回值，表示是否可以得出一种方案，其中传入两个元素 $l$ 和 $r$，分别表示区间的左端点和右端点。

首先我们假设区间 $l$ 和 $r$ 是答案中的一个步骤，记录答案。

```cpp
ans[++cnt]=a[r]-a[l-1];
numkz[l]++;
numky[r]++;
if(cnt==n-1){
	return true;
}
```

其中数组 $ans_i$ 表示倒数第 $i$ 个答案，$numkz_i$ 表示第 $i$ 个数前的左括号个数，$numky_i$ 表示第 $i$ 个数后的右括号个数。

随后判断，若答案数达到 $n-1$ ，意味着已经合并 $n-1$ 次，整个过程已完成，操作方式已经找到，返回。

接着我们开始枚举中间分割点，并深入 dfs。

```cpp
for(ll i=l;i<r;i++){
	if(f[l][i]+f[i+1][r]+a[r]-a[l-1]==f[l][r]){
		if(find_ans(i+1,r)&&find_ans(l,i)){
			return true;
		}
	}
}
```

如果找遍所有分割点都无法找到一个正确操作，说明之前的分割点的误，把这一部分记录的答案删去再返回。

```cpp
cnt--;
numkz[l]--;
numky[r]--;
```

最后输出时按格式输出即可，注意 ans 数组要倒序输出。

```cpp
for(ll i=1;i<=n;i++){
	for(ll j=1;j<=numkz[i];j++) cout<<"(";
	cout<<a[i]-a[i-1];
	for(ll j=1;j<=numky[i];j++) cout<<")";
	if(i!=n) cout<<"+";
}
cout<<endl;
cout<<f[1][n]<<endl;
for(ll i=cnt;i>=1;i--) cout<<ans[i]<<" ";
```

### AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=30;
const ll INF=1e9+9;
ll n,a[N],f[N][N],ans[N],cnt,numkz[N],numky[N];
bool ok=false;

void input(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=n;j++){
			f[i][j]=INF;
		}
	}
	for(ll i=1;i<=n;i++){
		cin>>f[i][i];
		a[i]=a[i-1]+f[i][i];
		f[i][i]=0;
	}
}

bool find_ans(ll l,ll r){
	if(l==r) return true;
	ans[++cnt]=a[r]-a[l-1];
	numkz[l]++;
	numky[r]++;
//	cout<<l<<" "<<r<<" "<<cnt<<"\n";
	if(cnt==n-1){
		return true;
	}
	for(ll i=l;i<r;i++){
		if(f[l][i]+f[i+1][r]+a[r]-a[l-1]==f[l][r]){
			if(find_ans(i+1,r)&&find_ans(l,i)){
				return true;
			}
		}
	}
	cnt--;
	numkz[l]--;
	numky[r]--;
}

void solve(){
	for(ll i=2;i<=n;i++){
		for(ll j=1;j<=n-i+1;j++){
			for(ll k=j;k<=j+i-2;k++){
				f[j][j+i-1]=min(f[j][j+i-1],f[j][k]+f[k+1][j+i-1]+a[j+i-1]-a[j-1]);
			}
//			cout<<f[j][j+i-1]<<"\t";
		} 
//		cout<<endl;
	}
	find_ans(1,n);
	for(ll i=1;i<=n;i++){
		for(ll j=1;j<=numkz[i];j++) cout<<"(";
		cout<<a[i]-a[i-1];
		for(ll j=1;j<=numky[i];j++) cout<<")";
		if(i!=n) cout<<"+";
	}
	cout<<endl;
	cout<<f[1][n]<<endl;
	for(ll i=cnt;i>=1;i--) cout<<ans[i]<<" ";
}

int main(){
	input();
	solve();
	return 0;
}
```

---

## 作者：李大恕 (赞：1)

[P2308 添加括号](https://www.luogu.com.cn/problem/P2308)
### 题目背景
给定一个正整数序列$a_1,a_2,\cdots,a_n,(1\le n\le20)$

不改变序列中每个元素在序列中的位置，把它们相加，并用括号记每次加法所得的和，称为中间和。

例如:

给出序列是$4,1,2,3$。

第一种添括号方法:

$((4+1)+(2+3))=((5)+(5))=(10)$

有三个中间和是$5,5,10$，它们之和为:$5+5+10=20$

第二种添括号方法

$(4+((1+2)+3))=(4+((3)+3))=(4+(6))=(10)$

中间和是$3,6,10$，它们之和为$19$。
### 题目描述
现在要添上$n-1$对括号，加法运算依括号顺序进行，得到$n-1$个中间和，求出使中间和之和最小的添括号方法。
### 输入格式
共两行。第一行，为整数$n(1\le n\le20)$。第二行，为$a_1,a_2,\cdots,a_n$这$n$个正整数，每个数字不超过$100$。
### 输出格式
输出$3$行。第一行，为添加括号的方法。第二行，为最终的中间和之和。第三行，为$n-1$个中间和，按照从里到外，从左到右的顺序输出。
## 解析
很明显，此题是一道区间dp。~~（有两个点多解，数据过于毒瘤，害我调了好久，请求开启SPJ @chen_zhe）~~

定义状态$f[i][j]$表示区间$[i,j]$的最小的中间和之和。区间dp的状态转移是按照区间长度从小到大进行，因此$[i,j]$必然由更小的区间转移而来。当然，为了转移时更方便计算中间和，我们使用前缀和$s[i]$来存储$\sum\limits_{k=1}^ia_k$。

考虑$k\in[i,j-1]$中的任意断点$k$，可将区间分成两个部分$[i,k]$和$[k+1,j]$，那么有
$$f[i][j]=\min_{k\in[i,j-1]}\{f[i][k]+f[k+1][j]+s[j]-s[i-1]\}$$
即区间$[i,k]$与区间$[k+1,j]$的最小中间和之和相加，再加上当前合并得到的中间和。上述即为状态转移方程。

当然本题还需注意最后的输出：我们用$h[i][j]$来存储区间$[i,j]$的断点，每一个区间分成两段，递归输出即可。

其余详见代码。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

int f[21][21],s[21],h[21][21];

void print1(int l,int r)			// 输出添加括号方法
{
	if(l==r){						// 区间只有一个数，输出并回溯
		cout<<s[l]-s[l-1];
		return;
	}
	cout<<'(';
	print1(l,h[l][r]);				// 输出左半段
	cout<<'+';
	print1(h[l][r]+1,r);			// 输出右半段
	cout<<')';
}

void print2(int l,int r)			// 输出中间和
{
	if(l==r)return;					// 区间只有一个数，不存在中间和，回溯
	print2(l,h[l][r]);				// 输出左半段
	print2(h[l][r]+1,r);			// 输出右半段
	cout<<s[r]-s[l-1]<<' ';			// 输出当前区间中间和
}

int main()
{
	int n,i,j,l,a;
	cin>>n;
	memset(f,0x3f,sizeof(f));
	for(i=1;i<=n;i++){
		cin>>a;
		f[i][i]=0;					// 初始化只有一个数的区间最小的中间和之和为0
		s[i]=s[i-1]+a;				// 前缀和
	}
	for(l=2;l<=n;l++)				// 第一层枚举区间长度，从2~n
		for(i=1;i<=n-l+1;i++)		// 第二层枚举区间左端点
			for(j=i;j<i+l-1;j++)	// 第三层枚举断点
				if(f[i][j]+f[j+1][i+l-1]+s[i+l-1]-s[i-1]<=f[i][i+l-1]){ // 毒瘤数据！必须写成<=才能过，<过不了
					f[i][i+l-1]=f[i][j]+f[j+1][i+l-1]+s[i+l-1]-s[i-1];	// 更新f[i][j]
					h[i][i+l-1]=j;	// 储存断点
				}
	print1(1,n);
	cout<<'\n'<<f[1][n]<<'\n';
	print2(1,n);
	return 0;
}
```

---

## 作者：wtxy2006 (赞：1)

### Describe:
有 $n$ 个数字，合并两个数字的代价为 $a_i+a_j$。问合并后的序列，最小的合并代价，中间合并顺序产生的代价。
### Solution:
这道题第 $2$ 问十分友好，简单的区间dp，比[P1880 [NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)还简单一些。
设 $f_{i,j}$ 表示 $i$ 到 $j$ 合并后的最大得分，则可以转移(其中 $a$ 表示前缀和数组)：
$$f_{i,j}=\min(f_{i,k}+f_{k+1,j}+a_j-a_{i-1},f_{i,j})({\rm{i}} \le k < j)$$
那么第 $1$ 问怎么做呢？
只需要在dp时记录一下当前是从那里合并的就行了。
``` cpp
if (f[i][k] + f[k + 1][j] + a[j] - a[i - 1] <= f[i][j])
          f[i][j] = f[i][k] + f[k + 1][j] + a[j] - a[i - 1], s[i][j] = k;
```
输出时相当于中序遍历一棵树，DFS解决，在DFS过程中记录产生的中间值，再输出就可以了。
``` cpp
int n, f[MN][MN], a[MN], s[MN][MN], ans[MN], cnt;
void print(int i, int j) {
  if (i == j) {
    printf("%d", a[i] - a[i - 1]);
    return;
  }
  printf("(");
  print(i, s[i][j]);
  printf("+");
  print(s[i][j] + 1, j);
  printf(")"), ans[cnt++] = a[j] - a[i - 1];
}
```
### Code:
``` cpp
// P2308 添加括号
#include <cstdio>
#include <cstring>
#include <iostream>
#define MN 25
using namespace std;
inline int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
  return x * f;
}
int n, f[MN][MN], a[MN], s[MN][MN], ans[MN], cnt;
void print(int i, int j) {
  if (i == j) {
    printf("%d", a[i] - a[i - 1]);
    return;
  }
  printf("(");
  print(i, s[i][j]);
  printf("+");
  print(s[i][j] + 1, j);
  printf(")"), ans[cnt++] = a[j] - a[i - 1];
}
int main() {
  n = read(), memset(f, 0x3f, sizeof(f));
  for (int i = 1; i <= n; i++) a[i] = read() + a[i - 1], f[i][i] = 0;
  for (int l = 2; l <= n; l++)
    for (int i = 1, j = i + l - 1; j <= n; i++, j++) {
      for (int k = i; k < j; k++)
        if (f[i][k] + f[k + 1][j] + a[j] - a[i - 1] <= f[i][j])
          f[i][j] = f[i][k] + f[k + 1][j] + a[j] - a[i - 1], s[i][j] = k;
    }
  print(1, n);
  printf("\n%d\n", f[1][n]);
  for (int i = 0; i < cnt; i++) printf("%d ", ans[i]);
  return 0;
}
```

---

## 作者：Alanalan (赞：1)

```cpp
//本题先使用深度搜索依次遍历，尝试 每次遍历后的答案（深度优先），并记录出答案的
//最小值和产出最小值的情况。每次遍历搜索若小于最小值则替换 
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
int a[50],h[50],hh[50],f[50][50],g[50][50],sum[51],n,m;
void dfs(int x,int y)
{
    if(x==y)return;
    h[x]++;
    hh[y]++;
    dfs(x,g[x][y]);
    dfs(g[x][y]+1,y);//结束模块 
}
void DFS(int x,int y)
{
    if(x==y)
        return;
    DFS(x,g[x][y]);
    DFS(g[x][y]+1,y);
    cout<<sum[y]-sum[x-1]<<' ';//深度搜索后的输出答案部分，每次输出符号与数字之间的关系 
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        f[i][i]=0;
    }//输入 
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+a[i];//为深度搜索制造出可能的情况 
    for(int i=n-1;i;i--)
    for(int j=i+1;j<=n;j++)
    {
		f[i][j]=0x3f3f3f3f;
		for(int k=i;k<j;k++)
        if(f[i][k]+f[k+1][j]+sum[j]-sum[i-1]<=f[i][j])
        {
    		f[i][j]=f[i][k]+f[k+1][j]+sum[j]-sum[i-1];
			g[i][j]=k;
		}
	}
    dfs(1,n);
    for(int i=1;i<=n;i++)
	{
		//输出最后答案 
        for(int j=1;j<=h[i];j++)
			cout<<'(';
        cout<<a[i];
        if(!hh[i]&&i!=n)
			cout<<'+';
        for(int j=1;j<=hh[i];j++)
			cout<<')';
        if(hh[i]&&i!=n)
			cout<<'+';
    }
    cout<<endl<<f[1][n]<<endl;//输出最后一行的最后一个答案 
    DFS(1,n);
    return 0;
}
```

---

## 作者：Apro1066 (赞：0)

本题难度：

第2问：普及+/提高

~~第1、3问：IOI+~~

首先第2问很像石子合并那题，用区间dp就好，然后一顿区间dp的套路即可：枚举区间长度，枚举区间左端点，求出区间右端点，枚举断点。

令$dp[i][j]$为区间$[i,j]$合并后能获得的最小和，则：

$$dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1)$$

其中$k$是区间$[i,j]$中的一个断点，$sum[j]-sum[i-1]$为区间$[i,j]$和。

答案为$[1,n]$。

**如何输出括号呢？**

用$la$与$ra$数组记录一个数左右的括号数，然后就可以递归了。
```cpp
#include <stdio.h>
#include <iostream>
#include <memory.h>
#define inf 2e9+7
#define int long long int 
using namespace std;
int a[21],n,s,dp[21][21],sum[21],point[21][21];
int la[21],ra[21],ans[21],cnt;
void dfs(int l,int r)
{
	if(l==r) return;
	la[l]++;
	ra[r]++;
	dfs(l,point[l][r]);
	dfs(point[l][r]+1,r);
	ans[++cnt]=sum[r]-sum[l-1];//合并一次能得到的值 
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i,j,k,l;
	cin>>n;
	memset(dp,inf,sizeof(dp));
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		dp[i][i]=0;
	}
	for(l=2;l<=n;l++)
	{
		for(i=1;i+l-1<=n;i++)
		{
			j=i+l-1;
			for(k=i;k<=j;k++)
			{
				if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]<=dp[i][j])
				{
					dp[i][j]=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1];
					point[i][j]=k;//区间[l,r]取到最优解点的断点 
				}
			}
		}
	}
	dfs(1,n);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=la[i];j++)
		{
			cout<<'(';
		}
		cout<<a[i];
		for(j-1;j<=ra[i];j++)
		{
			cout<<')';
		}
		if(i!=n)
		{
			cout<<'+';
		}
	}cout<<endl;
	cout<<dp[1][n]<<endl;
	for(i=1;i<=cnt;i++)
	{
		cout<<ans[i]<<' ';
	}cout<<endl;
	return 0;
}
```

---


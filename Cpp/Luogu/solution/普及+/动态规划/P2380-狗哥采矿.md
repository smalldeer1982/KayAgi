# 狗哥采矿

## 题目背景

又是一节平静的语文课。

狗哥闲来无事，出来了这么一道题。


## 题目描述

一个 $n\times m$ 的矩阵中，每个格子内有两种矿 yeyenum 和 bloggium，并且知道它们在每个格子内的数量是多少。最北边有 bloggium 的收集站，最西边有 yeyenum 的收集站。现在要你在这些格子上面安装向北或者向西的传送带（每个格子只能装一种）。问最多能采到多少矿？



## 说明/提示

传输过程中不能转弯，只能走直路。


## 样例 #1

### 输入

```
4 4
0 0 10 9 
1 3 10 0
4 2 1 3 
1 1 20 0 
10 0 0 0 
1 1 1 30 
0 0 5 5 
5 10 10 10 
0 0```

### 输出

```
98```

# 题解

## 作者：Youngsc (赞：19)

[Youngsc](http://youngscc.github.io/)

我们定义$f[i][j]$为在以$(i,j)$为右下角的子矩阵中的最大采矿量，由题意我们可知，如果$(i,j)$是向左转移矿，那么$(i,j-1)$,一定也是向左，$(i,j-2)$一直到$(i,1)$都是向左，同理如果$(i,j)$是向上转移矿，那么$(i-1,j)$,一定也是向上，$(i-2,j)$一直到$(1,j)$都是向左。这就可以其实我们用前缀和去维护一段区间的采矿量。


在转移时，我们只关心当前$(i,j)$的采矿方向。设$A[i][j]$为向上的前缀和，$B[i][j]$为向左的前缀和，那么转移方程$f[i][j]=max(f[i-1][j]+B[i][j],f[[i][j-1]+A[i][j])$.


俄日额貌似是多组数据，我也不是太清楚反正第一次就那么些然后~~一遍过~~了。。。


## 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <vector>
# include <queue>
# include <cmath>
# define R register

using namespace std;

int n,m,a[510][510],b[510][510],f[510][510];

template <typename T> void in(R T &a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

inline void maxx(R int &a,const int b){a>b? 0:a=b;}
inline void minn(R int &a,const int b){a<b? 0:a=b;}

inline int youngsc(){
    while(1){
        in(n),in(m);
        if(m+n==0)break;

        for(R int i=1; i<=n; ++i)
            for(R int j=1; j<=m; ++j)
                in(a[i][j]),a[i][j] += a[i][j-1];

        for(R int i=1; i<=n; ++i)
            for(R int j=1; j<=m; ++j)
                in(b[i][j]),b[i][j] += b[i-1][j];

        for(R int i=1; i<=n; ++i)
            for(R int j=1; j<=m; ++j)
                f[i][j] = max(f[i-1][j]+a[i][j],f[i][j-1]+b[i][j]);

        printf("%d\n",f[n][m]);
    }
    return 0;
}
int yg = youngsc();
int main(){;}
```
（减少代码复制，共创美好洛谷）


---

## 作者：Dry_ice (赞：9)

> 话说狗哥是谁啊？

~~闲话少叙，切入正题~~

## 整体思路：二维动态规划

### 具体步骤（状态的设置与应用）
1. 定义状态：设 $F_{i,j}$ 表示以 $(1,1)$ 和 $(i,j)$ 为左上和右下顶点的矩形的最大采矿数量。

1. 辅助状态：定义 $A_{i,j}$ 表示从 $(1,j)$ 到 $(i,j)$ 的横向（由西向东）前缀和，$B_{i,j}$ 表示从 $(i, 1)$ 到 $(i,j)$ 的纵向（由北向南）前缀和。

1. 初始化： $F$ 的所有点均为 $0$ （最小值，什么都没有采）

1. 状态转移

按题目中所说，只有**由东向西**和**由南向北**的传送带，所以 $F_{i,j}$ 只和 $F_{i-1,j}$ 、 $F_{i,j-1}$ 有关。

若取 $F_{i-1,j}$ ， 则用的是**由东向西**的传送带，则 $F_{i,j}=F_{i-1,j}+A_{i,j}$；若取 $F_{i,j-1}$ ， 则用的是**由南向北**的传送带,则 $F_{i,j}=F_{i,j-1}+B_{i,j}$ 。自然 $F_{i,j}$ 取两者较大值。

所以就可以得到转移方程了：
$$F_{i,j}=\max(F_{i-1,j}+A_{i,j},F_{i,j-1}+B_{i,j})$$

接下来看代码（~~某些童鞋最感兴趣的部分~~ $qaq$）
## CODE
```cpp
#include <stdio.h>
#include <string.h>
int n, m;
int a[505][505], b[505][505];
int f[505][505];
inline int mx(int p, int q) {
    return p > q ? p : q;
}
int main(void) {
    scanf("%d %d", &n, &m);
    while (n || m) {
        memset(f, 0, sizeof f);
        for (int i = 1, x; i <= n; ++i)
            for (int j = 1; j <= m; ++j) {
                scanf("%d", &x);
                a[i][j] = a[i][j - 1] + x;
            }
        for (int i = 1, x; i <= n; ++i)
            for (int j = 1; j <= m; ++j) {
                scanf("%d", &x);
                b[i][j] = b[i - 1][j] + x;
            }
        int ans = 0;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j) {
                f[i][j] = mx(f[i - 1][j] + a[i][j], f[i][j - 1] + b[i][j]);
                ans = mx(f[i][j], ans);
            }
        printf("%d\n", ans);
        scanf("%d %d", &n, &m);
    }
    return 0;
}
```

## 附
最后的友情提示：洛谷非常重视**学术诚信**。抄袭、复制题解，以达到刷AC率/AC数量或其他目的的行为，在洛谷是**严格禁止**的。~~想被$\color{brown}{\text{棕}}$就抄吧。~~

## The end. Thanks.

---

## 作者：方方小逗逼 (赞：5)

啦啦啦，啦啦啦！我又来啦！

dp！dp！dp！！！重要的事情说三遍

很简单（其实题目有不严谨，它的矿车应该是不可以重叠的）

先求前缀和，f[i,j]表示第i列j行的矿取哪种（题目太恶心，矿的名字取成这样，记不牢），向上还是向左，f[i-1,j]+a[i,j]表示向左取，f[i,j-1]+b[i,j]表示向上取，最后求max

```cpp
var
  a,b,f:array [0..500,0..500] of longint;
  n,m,i,j,k,maxx:longint;
function max(a,b:longint):longint;
begin
  if a>b then exit(a)
    else exit(b);
end;
begin
  read(n,m);
  while (n<>0)or(m<>0) do
  begin
    for i:=1 to n do
      for j:=1 to m do
      begin
        read(k);
        a[i,j]:=a[i,j-1]+k;
      end;
    for i:=1 to n do
      for j:=1 to m do
      begin
        read(k);
        b[i,j]:=b[i-1,j]+k;
      end;
    maxx:=0;
    for i:=1 to n do
      for j:=1 to m do
      begin
        f[i,j]:=max(f[i-1,j]+a[i,j],f[i,j-1]+b[i,j]);
        if f[i,j]>maxx then maxx:=f[i,j];
      end;
    writeln(maxx);
    read(n,m);
  end;
end.
哎。。。我真是好人
```

---

## 作者：huyufeifei (赞：4)

啊哈!终于有机会写一篇题解了。

我的思路是这样的(~~在某神犇的帮助之下~~)：首先分析一下，易知传送带一定是要么向上，要么向右。且一定摆满了整个矩阵。

所以我们设f[i][j]表示：除了从1,1到i,j这个矩形之外的所有地区能获得的最大矿数。

那么从上一个状态到这一个状态，有两种情况：

①从f[i][j+1]的状态，在1,j+1到i,j+1铺设一条传送带。

②从f[i+1][j]的状态，在i+1,1到i+1,j铺设一条传送带。

所以这两种情况的最大值就是f[i][j]的值。

考虑到每次都要求一段区间的和，我们可以分别维护两个横向，纵向的前缀和来优化。

C++代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=1002;
int m,n,f[N][N];
int a[N][N],b[N][N];
int suma[N][N],sumb[N][N];
int main()
{
    scanf ("%d%d",&n,&m);
    while(m!=0||n!=0){

    memset(a,0,sizeof(a));///这五句可以不要
    memset(b,0,sizeof(b));
    memset(suma,0,sizeof(suma));
    memset(sumb,0,sizeof(sumb));
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf ("%d",&b[i][j]);
            sumb[i][j]=b[i][j]+sumb[i][j-1];
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            scanf ("%d",&a[i][j]);
            suma[i][j]=a[i][j]+suma[i-1][j];
        }
    }
    ///
    for(int i=n;i>=0;i--)
    {
        for(int j=m;j>=0;j--)
        {
            f[i][j]=max((f[i][j+1]+suma[i][j+1]),(f[i+1][j]+sumb[i+1][j]));
        }
    }
    /*for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            printf("%d ",f[i][j]);
        }printf("\n");
    }*/
    printf("%d\n",f[0][0]);
    scanf ("%d%d",&n,&m);}
    return 0;
}

```

---

## 作者：Michael_Kong (赞：3)

题目本身还不是很难，但是无奈本人太蒻，题目意思理解错了导致交了n发都没过，随后~~点开题解~~才从dalao们的代码中搞懂题目的意思。。。这里我把自己的曲解说明一下以帮助那些和我一样理解错的人能尽快AC

如果我们的传送带是这么放的：

![](https://cdn.luogu.com.cn/upload/image_hosting/zkmddr6b.png)

此时的黑色的球并不会移动到白色球的位置(也就是说我们没办法让黑色的求强行卡进红色的轨道)

~~少打游戏多做题~~

那么剩下来的就是一个比较基础的dp了

我们假设$f[i][j]$为从原点到$(i,j)$的时候的这个小矩阵里面的最大的矿石数量

由于前面我们的歧义已经解释清楚了， 我们可以发现，如果$( i , j )$位置上的传送带方向是向右的，那么$( i, j-1 )$的位置上和$( i, j+1 )$的位置上的方向应该是同向的。同理也可以推到竖直方向上，那么我们的一个基本的转移方程就可以写出来了：

$f[i][j]=max(f[i-1][j]+a[i][1...j],f[i][j-1]+b[1...i][j]);$

这里还有一点就是要把b矿和y矿分开到两个数组里面去存储、

然后发现我们可以用前缀和来加速转移，最后答案就是f[1][1]到f[n][m]中的最大值

坑点：
读入的顺序不要搞混了
要记住是多组数据，所以每次搞完之后要记得重置

AC代码：
```c
#include <bits/stdc++.h>
using namespace std;
const int maxn=1926;
int s1[maxn][maxn],s2[maxn][maxn],f[maxn][maxn],n,m;
int aa,bb;
inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+c-'0';
        c = getchar();
    }
}
int main(void) {
	while(1) {
		scanf("%d %d",&n,&m);
		if(n+m==0) break;
		memset(s1,0,sizeof(s1));
		memset(s2,0,sizeof(s2));
		memset(f,0,sizeof(f));
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				read(aa);
				s1[i][j]=s1[i][j-1]+aa;
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++ ) {
				read(bb);
				s2[i][j]=s2[i-1][j]+bb;
			}
		}
		int ans=-1;
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				f[i][j]=max(f[i-1][j]+s1[i][j],f[i][j-1]+s2[i][j]);
				ans=max(ans,f[i][j]);
			}
		}
		printf("%d\n",ans);
	}
}
```


---

## 作者：moosssi (赞：2)

一道不错的二维 $dp$ 练手题.

设数组 $f_{i,j,0/1}$,分别表示前 $i$ 行前 $j$ 列，在 $(i,j)$ 采两种不同的矿的最大收益。

若在 $(i,j)$ 采第一种矿，那么左边的第一种矿都会被采，与上面无关，上面则从两种情况中取最大值。

那么就可以先用前缀和预处理，状态转移为 $f_{i,j,0}=max(f_{i-1,j,1},f_{i-1,j,0})+a_{i,j}$

采第二种矿同理，那么最终答案则为 $\max(f_{n,m,0},f_{n,,1})$。 

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=505;
int a[N][N],b[N][N],n,m;
int f[N][N][2];
int main(){
	while(scanf("%d%d",&n,&m)){
		if(n==0)break;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				scanf("%d",&a[i][j]);
				f[i][j][0]=f[i][j][1]=0;//多测，所以更新数组 
				a[i][j]+=a[i][j-1];//预处理前缀和 
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				scanf("%d",&b[i][j]);
				b[i][j]+=b[i-1][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				f[i][j][0]=max(f[i-1][j][1],f[i-1][j][0])+a[i][j];//状态转移 
				f[i][j][1]=max(f[i][j-1][0],f[i][j-1][1])+b[i][j];
			}
		}
		printf("%d\n",max(f[n][m][0],f[n][m][1]));
	}
	return 0;
}
```






---

## 作者：rfsfreffr (赞：2)

感觉这题题意有点令人懵逼（反正我第一次看时没看懂），尤其是提示中的那句话

```cpp
传输过程中不能转弯，只能走直路。
```

这令我豁然开朗，**这意味着，如果(i,j)我们选择转走yeyenum,那么(i,j-1),(i,j-2)一直到(i,1)到需要向左转走yeyenum。** bloggium也同理

于是我们可以设$dp_{i,j}$为**以(i,j)为左下角的矩阵中可以做到的最大采矿量**,依据我们前面提到的性质，最外围的矿物需要一列或一行整个取掉，同时与处理前缀和，就可以得到状态转移方程$dp_{i,j}=max(dp_{i,j-1}+sum1_{i,j},dp_{i-1,j}+sum2_{i,j})$，最终答案就是$dp_{n,m}$

```cpp
#include<bits/stdc++.h>
using namespace std;
struct oi {
	int y,b;
} a[501][501];
int n,m;
int sum1[501][501],sum2[501][501];
int dp[501][501];
int main() {
	while(1) {//有多组测试数据！！！
		cin>>n>>m;
		if(n==0&&m==0) {
			return 0 ;
		} 
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				scanf("%d",&a[i][j].y);
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				scanf("%d",&a[i][j].b);
			}
		}
		for(int i=1; i<=n; i++) {//预处理前缀和，向上或向左时的方向列还是行需要注意
			for(int j=1; j<=m; j++) {
				sum1[i][j]=sum1[i][j-1]+a[i][j].y;
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				sum2[i][j]=sum2[i-1][j]+a[i][j].b;
			}
		}
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				dp[i][j]=max(dp[i][j-1]+sum2[i][j],dp[i-1][j]+sum1[i][j]);//dp转移
			}
		}
		cout<<dp[n][m]<<endl;
	}

	return 0;
}
```



---

## 作者：ChangYiMing (赞：2)

# 狗哥采矿
额。。。~~看不懂题什么意思~~ 感觉挺简单的，其实就是建立一个**像平面直角坐标系**一样的框架，然后坐标轴上矿的最大数量,看dalao们说是```棋盘DP```（好像是的）;

## 基本思路：
#### 状态：
设 ``` f[i][j]``` 为 ```(1,1)``` 到 ```(i,j)``` 的子矩阵中的最大采矿量。
#### 核心思路：
由题意我们可知，如果点 ```(i,j)``` 的传送带向左，**那么点 ```(i,j-1)``` 及其左边一定是向左**，同理，如果  ```(i,j)``` 的传送带向上，**那么点``` (i-1,j) ```及其上边的点,一定也是向上**。
#### 数组：
于是我们可以用前缀和去维护一段区间的采矿量。  
- ```a[i][]```为矿```yeyenum```(第```i```行)**向右（即向西）**的前缀和;(前缀和应该是知道的)
-  ```b[i][]```为矿```bloggium```(第```i```行)**向上（即向北）**的前缀和;

#### 状态转移方程：
在状态转移时，**我们只考虑```(i,j) ```的两种方向**。设``` a数组记录向左``` 的前缀和， ```b数组记录向上``` 的前缀和，那么转移方程为:

$
f[i][j]=max(f[i-1][j]+a[i][j],f[[i][j-1]+b[i][j]);
$

#### 注意：
1. 读入顺序：先 ```yeyenum（向西）后 bloggium （向北）```。
2. 结果 ```（ans）``` 为 ```f[1][1]``` 到 ```f[n][m]``` 的最大值，为了减少一遍搜索时间，**可以在每次状态转移方程后对ans取最大值。**
3. 建议会写快读的写快读，**能减少好几倍的时间**。

## 代码：
#### Code:
```cpp
#include <stdio.h>
#include <cstring>

int f[505][505],a[505][505],b[505][505];
inline int max(int a,int b){
    return a>b?a:b;
}

int read(){
	int a1=0,k1=1;char c1=getchar();
	while(c1<'0'||c1>'9'){
		if(c1=='-')k1=-1;c1=getchar();
	}
	while(c1>='0'&&c1<='9'){
		a1=a1*10+c1-'0';
		c1=getchar();
	}
	return a1*k1;
}

int main(){
    int n,m,ans,x;
    while(1){
    	n=read();m=read();
    	if(!n||!m)break;
        memset(f,0,sizeof(f));
        ans=0;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
            	x=read();
		a[i][j]=a[i][j-1]+x;//向西;
            }
        }
        for(int i=1;i<=n;++i){
        	for(int j=1;j<=m;++j){
        		x=read();
			b[i][j]=b[i-1][j]+x;//向北;
        	}
        }
        for(int i=1;i<=n;++i){
        	for(int j=1;j<=m;++j){
                        f[i][j]=max(f[i-1][j]+a[i][j],f[i][j-1]+b[i][j]);
		        ans=max(ans,f[i][j]);
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}

```

## 原题：
[【洛谷】P2380 狗哥采矿](https://www.luogu.com.cn/problem/P2380)

---

## 作者：qwq___qaq (赞：1)

首先，拿到题目后，容易发现本题 dp 可做，数据 $1\le n,m\le 500$，dp $O(nm)$ 可以过。
### 思路分析
首先，每条道路都只能向北或者向西，所以说我们就可以定义 $dp_{i,j}$，表示从左上角开始的 $i\times j$ 这个矩阵中的最优解。然后，每条线路的答案可以使用前缀和统计，$sb_{i,j}$ 表示 $(i,j)$ 这个位置运输 BE 的数量；同理 $sn_{i,j}$ 表示 $(i,j)$ 这个位置运输 NEW 的数量。然后我们可以这样想：如果往西边走，那么矩阵减少一行，答案为 $dp_{i-1,j}+sb_{i,j}$；否则往北走，矩阵减少一列，答案为 $dp_{i,j-1}+sb_{i,j}$。综上，$dp_{i,j}=\max{dp_{i-1,j}+sb_{i,j},dp_{i,j-1}+sb_{i,j}}$，初始状态 dp 全部为 0，答案为 $dp_{n,m}$。

时间和空间复杂度均为 $O(nm)$，可过。
### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dp[505][505],sb[505][505],sn[505][505];
int main(){
	while(scanf("%d%d",&n,&m)!=EOF&&n&&m){
		memset(dp,0,sizeof(dp));//多组测试数据注意初始化
		for(int i=1;i<=n;i++)
			for(int j=1,BE;j<=m;j++){
				scanf("%d",&BE);
				sb[i][j]=sb[i][j-1]+BE;
			}
		for(int i=1;i<=n;i++)
			for(int j=1,NEW;j<=m;j++){
				scanf("%d",&NEW);
					sn[i][j]=sn[i-1][j]+NEW;//前缀和
			} 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				dp[i][j]=max(dp[i-1][j]+sb[i][j],dp[i][j-1]+sn[i][j]);//状态转移
		printf("%d\n",dp[n][m]);
	}
	return 0;
}
```

---

## 作者：刘备 (赞：1)

#### 这里提供一个和正常做法比较不同的做法，虽说貌似更复杂了一点点，但是的确是我的第一反应(可见我有多蒟)

suma[i][j]表示第i行向左的矿物**向左**的前缀和

sumb[i][j]表示第i行向上的矿物**向左**的前缀和

**这里注意一点，与其他巨佬给的题解不同，我的前缀和都是表示向左的！！
**

**dp[i][j]表示前i行，向左的传送带最多修到第j列的最多采矿数
**

由于向左修建的传送带从上往下一定是不会下降的，因为这样不修向左的传送带的部分就一定能修向上的传送带，而避免了浪费空间。

于是我们得到如下方程：

**dp[i][j]=max(dp[i-1][k])+suma[i][j]+sumb[i][m]-sumb[i][j] (0<=k<=j)**

这个方程看似O(n3)，但实际上我们可以通过一个maxx[]数组轻易的把k的枚举给省略掉。这样我们的复杂度就变成了O(n2)

最后贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 510;
int dp[N][N],a[N][N],b[N][N],suma[N][N],sumb[N][N],maxx[N],n,m;
inline int read() {
    int ans=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-') f=-1; ch=getchar();}
    while(isdigit(ch)) {ans=ans*10+ch-48; ch=getchar();}
    return ans*f;
}
int main() {
    while(1) {
        int ans=0;
        memset(dp,0,sizeof(dp));
        memset(suma,0,sizeof(suma));
        memset(sumb,0,sizeof(sumb));
        n=read(); m=read();
        if(n+m==0) break;
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++) a[i][j]=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++) b[i][j]=read();
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++) suma[i][j]=suma[i][j-1]+a[i][j],sumb[i][j]=sumb[i][j-1]+b[i][j];
        for(int i=0;i<=m;i++) dp[1][i]=suma[1][i]+sumb[1][m]-sumb[1][i];
        for(int i=2;i<=n;i++) {
        	maxx[0]=dp[i-1][0];
            for(int j=1;j<=m;j++) maxx[j]=max(maxx[j-1],dp[i-1][j]);
            for(int j=0;j<=m;j++) dp[i][j]=maxx[j]+suma[i][j]+sumb[i][m]-sumb[i][j],ans=max(ans,dp[i][j]);
        }
        printf("%d\n",ans);		
    }
    return 0;
}
```



---

## 作者：CaoXian (赞：0)

## P2380 狗哥采矿 题解
二维 `dp` 题。

由题目知， `yeyenum` 矿只能由东西方向的传送带运输，而 `bloggium` 矿只能由南北方向的传送带运输。

那么对于某个地方的 `yeyenum` 矿，如果要开采，因为是由东西方向的传送带运输，那么它左边的 `yeyenum` 矿肯定都要开采，但它左边的 `bloggium` 矿就不能被开采了。 `bloggium` 矿同理。



这样我们就可以使用 `dp` 来解决此题。令 $dp_{i, j, 0}$ 为以第 `i` 行，第 `j` 列为右下角的矿区的最大采矿量，且第 `i` 行，第 `j` 列的 `bloggium` 矿要开采， $dp_{i, j, 1}$ 同理。

某个地方无论是开采什么矿，它左上部分的矿区都不会受到影响，影响的是这个矿所在的行和列（或者说被所在的行和列的矿影响）。

可以得到状态转移方程：

$$dp_{i, j, 0} = \max(dp_{i, j - 1, 0}, dp_{i, j - 1, 1}) + \sum_{k = 1}^{i}bloggium_{k, j}$$

$$dp_{i, j, 1} = \max(dp_{i - 1, j, 0}, dp_{i - 1, j, 1}) + \sum_{k = 1}^{j}yeyenum_{i, k}$$

注意到 $\sum_{k = 1}^{i}bloggium_{k, j}$ 是可以用前缀和优化的，就可以将时间复杂度降到 $O(n \times m)$ 了。

Code：
```cpp
#include <stdio.h>
#define re register
int n, m, g, sum1[501][501], sum2[501][501], dp[501][501][2];
int main() {
	while(~scanf("%d%d", &n, &m)) {
		if(!n && !m) return 0;
		for(re int i = 1; i <= n; ++i)
			for(re int j = 1; j <= m; ++j)
				scanf("%d", &g), sum1[i][j] = sum1[i][j - 1] + g;
		for(re int i = 1; i <= n; ++i)
			for(re int j = 1; j <= m; ++j)
				scanf("%d", &g), sum2[i][j] = sum2[i - 1][j] + g;
		for(re int i = 1; i <= n; ++i)
			for(re int j = 1; j <= m; ++j)
				dp[i][j][0] = (dp[i][j - 1][0] < dp[i][j - 1][1] ? dp[i][j - 1][1] : dp[i][j - 1][0]) + sum2[i][j], dp[i][j][1] = (dp[i - 1][j][0] < dp[i - 1][j][1] ? dp[i - 1][j][1] : dp[i - 1][j][0]) + sum1[i][j];
		printf("%d\n", (dp[n][m][0] < dp[n][m][1] ? dp[n][m][1] : dp[n][m][0]));
	}
	return 0;
}
```

---

## 作者：Paris_Bentley (赞：0)

菜鸡又来水绿题代码了~

题目描述，核心部分就是在一个矩阵里，某个点都可以向上推，或者向左推，而这一路上的每个点都要按照这个方向推过去求和。

其实这个题目并不难，只要会dp，愿意用纸笔画图，可以轻松找到状态转移方程的。如果在一张图上把可能的传送带方向列出来，可能会得到这样的图片

![](https://cdn.luogu.com.cn/upload/image_hosting/npin2ucx.png)

那我们随便找其中的一任意一个点，是不是发现了，对于这一点只有两种可能，一种可能是这一点向左传递，他上面的所有点就都向上传递，或者这一点向上传递，左侧的点都向左传递。如果我们定义a为向左传递可以得到的矿产价值，那么sa数组保存这个点左侧所有点的价值和。同样可以定义b数组和sb数组~~（放下你邪恶的眼神）~~。那其他的呢？就是左上角点的得到的最优解。


那么就一定可以轻松推导出这样的状态转移方程

f[i][j]=max(f[i][j-1]+sb[i][j],f[i-1][j]+sa[i][j]);

哈哈哈，画完图是不是觉得好简单呢，只要输出最后的f[n][m]就有最终的答案了。

我们发现出题人非常良心的一点，就是传送带只能向西和北，也就是左或者上，这就保证我们在输入a之后，可以直接记录sa[i][j]数组，输入b的时候可以直接记录sb[i][j]数组。

```
#include <bits/stdc++.h>
using namespace std;
long long n,m;
long long a[505][505],b[505][505],sa[505][505],sb[505][505];
long long f[505][505];
int main()
{
	scanf("%lld%lld",&n,&m);
	while(n+m!=0)
	{
		memset(a,0,sizeof(a));//数组清空 
		memset(b,0,sizeof(b));
		memset(sa,0,sizeof(sa));
		memset(sb,0,sizeof(sb));
		for (int i=1;i<=n;i++)//标记ij位置都向左推过去的价值 
			for (int j=1;j<=m;j++)
			{
				scanf("%d",&a[i][j]);
				sa[i][j]=sa[i][j-1]+a[i][j];
			}
		for (int i=1;i<=n;i++) 
			for (int j=1;j<=m;j++)
			{
				scanf("%d",&b[i][j]);
				sb[i][j]=sb[i-1][j]+b[i][j];
			}
		for (int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
			{
				f[i][j]=max(f[i][j-1]+sb[i][j],f[i-1][j]+sa[i][j]);
			 } 
		printf("%lld\n",f[n][m]);
	}
	return 0; 
} 
```


---

## 作者：HRLYB (赞：0)

[P2380 狗哥采矿](https://www.luogu.org/problem/P2380)

典型的方格dp. 设$f[i][j]$表示在$(i,j)$位置时的最大值，因为传送带必须是直的，所以如果当前这个位置有一条传送带，那么这条传送带**必定到达某个方向的边界**（不然修了这条传送带也没用）.

这样我们就可以写出状态转移方程

>$f[i][j]=min(f[i-1][j]+x,f[i][j-1]+y)$，其中x和y分别表示两个方向的传送带到达边界能够贡献的值.

另外有一点需要注意：题目是有多组数据的（要不然那个末尾有什么用）

```cpp
#include<bits/stdc++.h>
#define maxn 510
using namespace std;
int n,m,a[maxn][maxn],b[maxn][maxn],f[maxn][maxn];
int main(){
	scanf("%d%d",&n,&m);
	while(1){
		if(n==0&&m==0)break;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				scanf("%d",&a[i][j]);
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				scanf("%d",&b[i][j]);
			}
		}
        //要看好到底哪个矿对应哪种情况
		int x,y;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				x=0,y=0;
				for(int k=1;k<=i;k++)x+=b[k][j];
				for(int k=1;k<=j;k++)y+=a[i][k];//这里可以用前缀和优化掉这一维
				f[i][j]=max(f[i][j-1]+x,f[i-1][j]+y);
			}
		}
		printf("%d\n",f[n][m]);
		scanf("%d%d",&n,&m);
	}
	return 0;
} 
```


---


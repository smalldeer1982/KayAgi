# 不等数列

## 题目描述

将 $1$ 到 $n$ 任意排列，然后在排列的每两个数之间根据他们的大小关系插入`>` 和 `<`。问在所有排列中，有多少个排列恰好有 $k$ 个 `<`。答案对 $2015$ 取模。

注：$1 \sim n$ 的排列指的是 $1 \sim n$ 这 $n$ 个数各出现且仅出现一次的数列。

## 说明/提示

对于 $30\%$ 的数据，$n\leq 10$；

对于 $100\%$ 的数据，$0\leq k<n\leq 1000$。

## 样例 #1

### 输入

```
5 2```

### 输出

```
66```

# 题解

## 作者：子谦。 (赞：88)

PS：这片题解重新提交不止是为了防作弊，整篇题解除了图片都被我删掉重写了一遍，因为以前文笔太差，实在让人无法理解，希望管理员大大给个通过，谢谢QwQ

update 2018-12-14：发现自己以前发的题解现在竟然自己都有点看不懂，排名竟然还是第一，愧对大家的赞，于是重新组织了一下语言，改得便于理解了一些

------

我有两种方法来解这道题，**只想看正解的请无视方法一**

## 方法一：找规律（~~非正经~~）

用$f[i][j]$表示$i$个数恰有$j$个小于号的排列数，那么打表可得下图

![看图说话](https://cdn.luogu.com.cn/upload/pic/15634.png)

我们会发现，打出来的表与杨辉三角一样，具有左右对称性。我们接下来就开始找规律吧

我们可以大胆猜想一下（反正这不是正经方法），既然这玩意长得跟杨辉三角这么像，那会不会有杨辉三角的一些其他规律呢？

组合数一个非常重要的规律就是它的递推公式$C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$

在这个三角中有没有出现呢我们发现$f[1][0]=1$，如果这个式子具有递推性质的话，$f[2][0]$和$f[2][1]$只能从$f[1][0]$这里递推而来。

那么我们写下递推公式：$f[i][j]=f[i-1][j-1]+f[i-1][j]$，然后继续往后看

我们发现到了$f[3][1]$这里，这个规律貌似不适用了。

难道不是递推？不可能，这么优美的性质，肯定是对的。

那为什么这里会出现不适用的情况呢？而且不止这里一处，绝大部分都不适用。

我们还能够发现一个规律，$\sum_{j=0}^if[i][j]=i*\sum_{j=0}^{i-1}f[i-1][j]$,也就是第i行的和等于第i-1行的和的i倍

从第$i-1$行到第$i$行总的扩大了$i$倍，那么我们可不可以认为$f[i-1][j-1]$也扩大了$i$倍然后将i倍的$f[i-1][j-1]$分给了$f[i][j-1]$和$f[i][j]$。而在杨辉三角中，扩大的i是一个恒定值2，也难怪会出现不适用的情况了

我们将递推公式换一种表示形式：$f[i+1][j]+=a*f[i][j],f[i+1][j+1]+=(i+1-a)*f[i][j]$

那么我们可以较为轻易地发现$f[3][1]$中的4恰好平均的来自$f[2][0]$和$f[2][1]$

以此类推，多算几个数我们就会发现递推公式中的$a$为$j+1$

所以得出递推公式为

### $f[i+1][j]+=(j+1)*f[i][j],f[i+1][j+1]+=(i-j)*f[i][j]$

也可以换回原来的形式

### $f[i][j]=(j+1)*f[i-1][j]+(i-j)*f[i-1][j-1]$

我第一次做就是用的这种玄学的方法哦，做完后又用下面的数学方法推了一遍

-----------------------------------------------手动分割线------------------------------------------------

## 方法二：数学方法
**这是正经方法**

我们考虑现在我们已经有了$n-1$个数的排列，再插入$n$使其变成$n$个数的排列

显然，$n$有$n$个位置可以选择，我们先来考虑两边的位置。

如果插入到最左边，会造成新的序列比原来多一个大于号

如果插入到最右边，会造成新的序列比原来多一个小于号

其他的位置就是插入到大于号或小于号的位置

如果插入到大于号的位置，删去一个大于号，多一个大于号一个小于号，也就是多一个小于号

如果插入到小于号的位置，删去一个小于号，多一个大于号一个小于号，也就是多一个大于号

我们会发现插入一个数只有多一个小于号和小于号数目不变两种情况

我们用$f[i][j]$表示i个数恰有j个小于号的排列数

那么显然$f[i+1][j]+=(j+1)*f[i][j]$，$f[i+1][j+1]+=(i-j)*f[i][j]$

好了，问题解决了



上代码

先是**暴力版**（通不过的，这是帮助我打出那张图的版本）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1005;
int f[maxn],n,ans[maxn];
bool s[maxn];
void dfs(int step){
	if(step>n){
		int sum=0;
		for(int i=1;i<n;i++)sum+=f[i]<f[i+1]?1:0;
		ans[sum]++;
		return;
	}
	for(int i=1;i<=n;i++)
		if(!s[i]){
			s[i]=1;
			f[step]=i;
			dfs(step+1);
			s[i]=0;
		}
}
int main(){
	scanf("%d",&n);
	dfs(1);
	for(int i=0;i<n;i++)printf("%d ",ans[i]);
}
```

然后上
## 正常版本
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cctype>
#ifdef ONLINE_JUDGE
#define printf(o"\n") printf("I AK IOI\n")
#define printf(o) printf("I AK IOI")
#endif
#define ll long long
#define gc getchar
#define maxn 1005
#define mo 2015
using namespace std;

inline ll read(){
	ll a=0;int f=0;char p=gc();
	while(!isdigit(p)){f|=p=='-';p=gc();}
	while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}
	return f?-a:a;
}int n,k,f[maxn][maxn];

int main(){
	n=read();k=read();f[1][0]=1;
	for(int i=2;i<=n;++i)
		for(int j=0;j<=i;++j){
			f[i][j]=f[i-1][j]*(j+1)%mo;
			if(j)f[i][j]=(f[i][j]+f[i-1][j-1]*(i-j))%mo;
		}
	printf("%d\n",f[n][k]);
	return 0;
}
```

### 复制题解的猜猜代码能过吗（滑稽

---

## 作者：Drifterming (赞：59)

```
//dp[i][j]表示前i个数插入了j个<号的方案数。
//不考虑怎么插入'>'、'<'号，因为符号是根据数字序列确定的， 
//所以我们按顺序插入a->f，符号也就跟着确定了 
//考虑一下这样一个序列：
//            a<b<d>c<e
//    如果在a<b之间插入f，则变成了a<b>f，<号个数不变
//    如果在a之前插入f，则f>a，<号个数也不变
//    即在<号和序列前插入，<号的个数不会改变    
//所以dp[i][j]可以增加dp[i-1][j]*(  j     +    1 )%mod种
//                              <号个数     序列前端 
//    如果在d>c之间插入f，则变成了d<f>c，增加了一个<号
//     如果在e后面插入f，则e<f，增加了一个<号
//    即在>号和序列末插入，<号的个数会增加1 
//所以dp[i][j]可以增加dp[i-1][j-1]*( (i-1)   - (j-1)       -1            +   1       -> i-j  )%mod个
//                                数字个数   <号个数  符号个数为数字个数-1    序列末尾   大于号个数+序列末尾 
//即dp[i][j]=(dp[i-1][j-1]*(i-j)%mod+dp[i-1][j]*(j+1)%mod)%mod;


#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=1e3+5;
const int mod=2015;

int n,k;
int dp[N][N];

int main()
{
    scanf("%d%d",&n,&k);
    dp[1][0]=1;
    for(int i=2;i<=n;++i)
    {
        dp[i][0]=1;        //前i个数0个<号的情况只有1种，即单调上升。 
        for(int j=1;j<=k;++j)
        {
            dp[i][j]=(dp[i-1][j-1]*(i-j)%mod+dp[i-1][j]*(j+1)%mod)%mod;
        }
    }
    printf("%d",dp[n][k]);
    return 0;
}
```

---

## 作者：song8448 (赞：23)

f[i][j]表示前i个数中恰好有j个小于号的排列个数

状态转移方程式 ：f[i][j]=f[i-1][j-1]\*(i-j)+f[i-1][j]\*(j+1)

右边第一项，第i个数加入到前面的已经形成的>号中，会增加一个<号，所以一共有i-1个空位，但

是其中又有j-1个已经形成了<号，所以有（i-1）-(j-1)个>号

右边第二项，第i个数加入到前面的已经形成的<号中，设新加入的是p，插入到 x<y 之间，就是 x

< p > y，小于号不变.每一个形成前i-1数有j个<的数列就有j个这样的空位。但还可以放在最前面，

所以为j+1个。

代码如下：


```cpp
#include<cstdio>
const int m=2015;
int n,k,f[1010][1010];
int main()
{
//    freopen("num.in","r",stdin);
//    freopen("num.out","w",stdout);
    scanf("%d%d",&n,&k);    
    f[1][0]=1;
    for(int i=2;i<=n;i++)
    {
        f[i][0]=1;
        for(int j=1;j<=n;j++)
           f[i][j]=(f[i-1][j-1]*(i-j)+f[i-1][j]*(j+1))%m;
    }
    printf("%d",f[n][k]);
}

```

---

## 作者：刘备 (赞：18)

**dp[i][j]=dp[i-1][j-1]\*(i-j)+dp[i-1][j]\*(j+1);**

其中i和j是表示前i个数中有j个小于号，j<=i-1

如何理解这个方程？？

要在长度为i的数列中插入一个数，那么共有i+1个位置可以插入（第一个位置最后一个位置和中间的i-1个位置）。由于插入的数字大于之前所有数，那么在原串中是小于号的位置插入这个数会多出来一个大于号，小于号数量则不变，如果在大于号位置插入会多一个小于号，而插在头位置也多一个大于，末位置多一个小于，总计，使小于号数量不变的位置有（j+1）个，剩下的（i-j）个位置会使小于号数量增加

接下来附上代码：

 
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define mod 2015
using namespace std;
int n,k;
int dp[1010][1010];
int main()
{
    int i,j;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++) dp[i][0]=dp[i][i-1]=1;
    for(i=2;i<=n;i++) 
        for(j=1;j<=min(i-1,k);j++) dp[i][j]=(dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j))%mod;
    printf("%d",dp[n][k]);
    return 0;
}
```

---

## 作者：信赖滴星辰 (赞：6)

### [P2401 不等数列](https://www.luogu.org/problemnew/show/P2401)

--------

几篇题解都很好，尤其是 Drifterming 的版本，简单易懂，也让我彻底理解了这道题的做法

然而~~他们太巨了~~，有些步骤有点省略，本蒟蒻在这里写一篇详细版的供参考。

一拿到这道题，就知道暴力深搜枚举全排列是不行的，明显会TLE。最好的做法是DP。

可是 f 数组好定义，状态转移方程却不好想。于是我在定义了f 数组的基础上，分类讨论了一番。

f [ i ] [ j ] 表示 1 ~ i 这 i 个数 , 其中j 个 " < " 有几种方法 

----------
假设我们已经把 n - 1 个数排好了，现在我们要在其中插入第 n 个数

#### n 大于这个数列中的任何数

1.	若 n 插在第一个数之前，因为它比第一个数大，则多一个 " > "

2.  若 n 插在最后一个数之后，同上，多了一个 " < "

3.	若 n 插在 " < " 之前，因为它比 " < " 之后的数大，所以 " < " 变成 " > "，而它比前面的那个数大，所以它前面添加了一个 " < " .

	综合来看，多了一个 " > ";
    
    Example:
    
    2 < 4     ---->     2 < 5 > 4
    
4.	若 n 插在 " > "，同上，多了一个 " < "  
    
--------

--------

用状态转移方程，则表示为：

1.	f [ i ] [ j ] = f [ i-1 ] [ j ]
	
    // " < " 个数没变，所以 j 不变，而插入一个数，数是比之前多 1 的

2.	f [ i ] [ j ] = f [ i - 1 ] [ j - 1 ]
	
    // 多了一个数，又多了一个 " < "
    
3.	f [ i ] [ j ] = f [ i - 1 ] [ j ] * j

	// " < " 个数没变，所以 j 不变；但是 n 可以插在这 j 个 " < "中的任意一个之前，所以方案数增多 j 个
    
4.	f [ i ] [ j ] = f [ i - 1 ] [ j - 1 ] * ( i - j -1 )

	// 与上同理，不过这次是插在 " > " 之前了，因此方案增多数等于 " > " 个数，也就是总的符号个数 ( i - 1 )，减去 " < "的个数 ( j )，也就是 ( i - j -1 )

--------


合并同类项，可得：

### f [ i ] [ j ] = ( f [ i - 1 ] [ j - 1 ] x ( i - j ) % 2015 + f [ i - 1 ] [ j ] x ( j + 1 ) % 2015 ) % 2015

~~不好意思Markdown把"*"吞掉了，我只能用x来表示乘~~


代码见下：

```cpp

#include <iostream>
using namespace std;

int n,k;
int f[1004][1004];   // f [ i ] [ j ] 表示 i个数,j个<有几种 

int main()
{
	cin >> n >> k;
	
	f[1][0] = 1;     // 一个数，没有 " < " ,只有一种
	
	for(int i=2; i<=n; i++)
	{
		f[i][0] = 1;    //没有 " < "，单调递减，只有一种 
		
		for(int j=1; j<=min(k,i-1); j++)
		{
			f[i][j] = ( f[i-1][j-1]*(i-j) % 2015 + f[i-1][j]*(j+1) % 2015 ) % 2015;
		}
	}
	
	cout << f[n][k] << endl;
	
return 0;	
}


```

写了这么多，望通过 QAQ






---

## 作者：moye到碗里来 (赞：5)

这道题一看数据30%一定是卡的搜索，所以对于30%的题我们可以用DFS对没个数位上的数字进行枚举，最后枚举完了然后从前往后跑一边，看是否符合题意。

期望得分30分

由于此题数据范围看上去很像DP，n^2肯定能过，所以我们不妨设置一个数组f[i][j]表示1-i中有j个<符号。

那么我们来讨论一下其与f[i-1][j-1]以及f[x-1][y]的关系。

1.与f[i-1][j-1]

在这种情况下，由于我们是从前往后去推的，所以当前加入的数一定比前面的都大。那么怎么才能使得其变为前n个有j个<呢？

仔细想一下你就会发现，你把这个数插入任何一个数后面，都必将“形成”一个小于号，但是如果我们插入到一个已经形成小于号的两数之间，则小于号数量就不会改变，因为前i-1个数都比当前的i小，所以一共有i-1个空位，但是又有j-1个空位已经形成<号，所以在这种情况下，前i个数形成的每一个有j-1个<的数列都可以形成(i-1)-(j-1)个新的前i个数中有j个<的数列，于是从f[i-1][j-1]能够推出f[i][j]的一部分为f[i-1][j-1]\*((i-1)-(j-1))。

2.与f[i-1][j]

那么刚刚是说明了你加入这个数增加了一个小于号的情况。但如果我不增加呢？

我前i-1个数已经形成了j个<。那么我加入i使其不会增加小于号要怎么做呢？

由于上文我已经说过你把这样的i插入两个之间已经是<号的数之间是不会增加<的数量的。所以这样的空位，每一个形成前i-1数有j个<的数列就有j个这样的空位。

但是你还可以放在最前面，所以其实是j+1个。

由此我们可以推出状态转移方程f[i][j]=f[i-1][j-1]\*(i-j)+f[i-1][j]\*(j+1);

说明完毕

但是我还想聊聊关于推导这样公式的一个思维。

我一开始直接是打的DFS，然后我就开始想DP，需要学会看数据范围来猜做法，这样的数据一般是公式或者DP。

那么你如果想到了DP就很容易能想出这样的状态。接下来就是推状态转移方程。

很多人说状态转移方程不好推，但我觉得那是你没利用好现有的资源。

之前我不是写了个DFS吗？

那么我就把这个DFS拿来求每层的数据，一步一步慢慢推，仔细观察状态，然后结合题目，你其实就可以推出状态转移方程了。最重要的不是说想出状态或者是什么，而是理解这个状态的含义，和去思考为什么是这样的状态，DP最重要的就是状态，仔细去推方可解题。

那我就放上我的DP代码，我就不放出我的DFS了

    

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n,ans=0;
int a[15],vis[15]={0},t,f[1005][1005];
int main()
{
    //freopen("num.in","r",stdin);
//    freopen("num.out","w",stdout);
    scanf("%d %d",&n,&k);
            for(int i=1;i<=n;i++){f[i][i-1]=1;f[i][0]=1;};
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<i-1;j++)
                {
                    f[i][j]=f[i-1][j-1]*(i-j)%2015+f[i-1][j]*(j+1)%2015;
                    f[i][j]=f[i][j]%2015;
                }
            }
            cout<<f[n][k];
        }

```

---

## 作者：无名ZWH (赞：2)

这题一开始我还以为是全排列，类似康托展开和火星人  
结果一打全是TLE，我*****   
然后一看标签DP！  
算了一下发现f[i][j]=(f[i-1][j-1]x(i-j)+f[i-1][j]x(j+1))
为什么呢？加一个数后有两种情况  
 1.没变也就是" < " 个数没变，而插入一个数，数是比多1但" < " 个数没变  
算出此时f[i][j]=f[i-1][j]x（j+1）  
 2.变了也就是" < " 个数+1，而插入一个数，数+1， " < "个数+1，算出f[i][j]=f[i-1][j-1]x(i-j)  
 综上f[i][j]=(f[i-1][j-1]x(i-j)+f[i-1][j]x(j+1))  
 好了——上代码
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1050][1050];//DP数组
int main()
{
	int n,k,mod=2015;
    cin>>n>>k;
    f[1][0]=1;//初始化
    for(int i=2;i<=n;i++)
    {
        f[i][0]=1;
        for(int j=1;j<=n;j++)
        {
        	f[i][j]=(f[i-1][j-1]*(i-j)+f[i-1][j]*(j+1))%mod;//方程记得模2015
        }   
    }
	cout<<f[n][k];//输出
	return 0;//好习惯
 } 
```


---

## 作者：doby (赞：1)

对于这个奇怪的形似数论的模型，比较容易想到的就是DP了

如果以“n个格子填入1-n”的方向思考很显然由于必须记录填过的数与格子，很可能退化为搜索的思路

不妨将这题想成“将n个数从小到大插入数列”

那么对于当前插入的数，如果插入在<号两端的数中间或数列最左端，那么就会使>的数量+1

同理，如果插入在>号两端的数中间或数列最右端，那么就会使<的数量+1

f[i][j]表示前i个数中恰有j个<的方案数

f[i][j]=f[i-1][j]×(j+1)+f[i-1][j-1]×(i-j)
```cpp
#include<cstdio>
using namespace std;
int n,k,f[1010][1010];
int main()
{
	scanf("%d%d",&n,&k);
	f[1][0]=1;
	for(int i=2;i<=n;++i)
	{
		f[i][0]=1;
		for(int j=1;j<i;++j)
		{
			f[i][j]=(f[i-1][j]*(j+1)+f[i-1][j-1]*(i-j))%2015;
		}
	}
	printf("%d",f[n][k]);
	return 0;
}
```

---

## 作者：芝麻糊糊 (赞：1)

这个题很简单，状态转移很好想。

写的时候注意：

初始化。

说思路吧：

vivo表示前i个数有j个小于符号有多少种方案，这里讨论当加进下一个数时小于符号变化情况。如果两树间原本为小于，则无影响，此时原有j个小于符号，而两端其中一端满足条件，原有j-1个小于则包括两端之一情况会有i-j个大于符号，所以有i-j个情况

上代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,k;
int vivo[1010][1010];
int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;i++)
      vivo[i][0]=1;
    for(int i=2;i<=n;i++)
      for(int j=1;j<=k;j++)
        vivo[i][j]=(vivo[i-1][j]*(j+1)+vivo[i-1][j-1]*(i-j))%2015;
    cout<<vivo[n][k];
    return 0;
}
```

---

## 作者：STLGirlfriend (赞：0)

![](https://cdn.luogu.com.cn/upload/pic/29321.png)

```c++
#include <cstdio>

const int MaxN = 1e3;
const int MaxK = 1e3;
const int Mod = 2015;

int main() {
	int n, k;
    scanf("%d %d", &n, &k);

    static int dp[MaxN + 1][MaxK + 1];
    dp[1][0] = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (j + 1)) % Mod;
            dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * (i - j)) % Mod;
        }
    }

    printf("%d\n", dp[n][k]);
}
```

---

## 作者：wuzhoupei (赞：0)

这个题说是个DP,但是感觉想一个递推式;

先把式子摆出来: f[i][j] = f[i-1][j-1] \* (i-j) + f[i-1][j] \* (j+1) ;

那我们就要说一下这是为什么了；

首先我们要明确f[i][j]代表前i个人j个小于号；

所以我们可以假设我们有一种情况是： @<@>@<@<@>@<@ ;

因为我们是把一个大于之前所有数的数插入，所以我们可以把要插入的数记为： <#> ;

所以如果前i-1个数中有j个<，那么我们只能把<#>插入到原序列中小于号的位置或开头，那样子小于号不会变多，只会多一个大于号，读者可以自行尝试，这样的位置有j+1个(j个小于号，1个开头)；

同理，如果有j-1个小于号，那我们就可以把<#>插入到大于号和最后，这样子就会多一个小于号，凑够j个，这样的位置一共有(i-2)+(1)+(1)-(1)-(j-1) = (i-j)个，i-2个空隙，1个开头，1个结尾，减掉1个开头，j-1个小于号，就好了；


我的博客： http://blog.csdn.net/pretend\_fal


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define II int
#define R register
#define I 1005
#define PI 2015
using namespace std;


II n,k;

II f[I][I];


int main()
{
//    freopen("1.in","r",stdin);
    
    scanf("%d%d",&n,&k);
    
    for(R II i=1;i<=n;i++) f[i][0]=1; 
    for(R II i=1;i<=n;i++)
    {
        for(R II j=1;j<=k;j++)
        {
            f[i][j]+=f[i-1][j]*(j+1)+f[i-1][j-1]*(i-j);
            f[i][j]%=PI;
        }
    }
    
    printf("%d\n",f[n][k]);
    exit(0);
}
```

---

## 作者：noip_Tom (赞：0)

//递推式F[i,j]=f[i-1,j](j+1)+f[i-1][j-1](i-j)   i表示从1到i的数   j表示小于号个数 插入最大数e后添了一个> 或者一个<的数量

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
int f[1001][1001];
int n,k;
int main ()
{
    int i,j,l;
    cin>>n>>k;
    for (i=1;i<=n;i++)
        f[i][0]=1;
    for (i=2;i<=n;i++)
         for (j=1;j<=k;j++)
              f[i][j]=(f[i-1][j]*(j+1)+f[i-1][j-1]*(i-j))%2015;
              //虽然不知道怎么来的但我谈谈我的想法吧
              //i个数字插入j个'<'个数=i-1插入j个'<'乘j+1再加i-1插入j-1个 '<'个数乘i-j 
    cout<<f[n][k];
    return 0;
}
//转自博客，内有30%暴力（Pascal）
<http://http://blog.csdn.net/nike0good/article/details/8092876>
```

---

## 作者：Ousmane_Dembele (赞：0)

这道题虽然用大众方法的题解很多，但大多就是扔上去一个式子和十几行代码，没有让人真正理解。

令$dp[i][j]$表示目前加入了$i$项，数列中有$j$个$<$

容易发现，加入位置只跟前一项和后一项有关。

我们分类讨论：

当前一项$<$后一项时，不妨设前一项是$y$，后一项是$z$，插入的数是$x$。

∵$y<z,x>y,x>z$

∴当$x$插在$y$与$z$的中间时,$y<x,x>z$，故仍有一个$<$

同理，当前一项$>$后一项时，$<$会多$1$

当$x$插在最左边时$,x>y,$故$<$号不会增加

当$x$插在最右边时$,z<x,$故$<$号要加$1$

有多少种情况不要加$1?$

一共 $j$个$<$号，加上最右边的，共$j+1$个

剩下的都是要加的

$i+1-(j+1)=i-j$

所以，$dp$式子也就推出来了，

$dp[i][j]=dp[i-1][j-1]*(i-j)+dp[i-1][j]*(j+1)$





---

## 作者：Valhalla_Is_Calling (赞：0)

## 好久没写题接了，有点没手感
### 这道题是我们考试使用的。

想要做题，一定要先理解这道题的意思。

数列，数列（sequence of number）是以正整数集（或它的有限子集）为定义域的函数，是一列有序的数。

数列中的每一个数都叫做这个数列的项。排在第一位的数称为这个数列的第1项（通常也叫做首项），排在第二位的数称为这个数列的第2项，以此类推，排在第n位的数称为这个数列的第n项，通常用an表示。

著名的数列有斐波那契数列，三角函数，卡特兰数，杨辉三角等。

三角形数

传说古希腊毕达哥拉斯（约公元前570-约公元
500年）学派的数学家经常在沙滩上研究数学问题，他们在沙滩上画点或用小石子来表示数。比如，他们研究过：
 
由于这些数可以用如右图所示的三角形点阵表示，他们就将其称为三角形数。

正方形数

类似地，  被称为正方形数，因为这些数能够表示成正方形。因此，按照一定顺序排列的一列数称为数列。
概念


函数解释

数列的函数理解：
①数列是一种特殊的函数。其特殊性主要表现在其定义域和值域上。数列可以看作一个定义域为正整数集N*或其有限子集{1，2，3，…，n}的函数，其中的{1，2，3，…，n}不能省略。

②用函数的观点认识数列是重要的思想方法，一般情况下函数有三种表示方法，数列也不例外，通常也有三种表示方法：a.列表法；b。图像法；c.解析法。其中解析法包括以通项公式给出数列和以递推公式给出数列。

③函数不一定有解析式，同样数列也并非都有通项公式。
一般形式
数列的一般形式可以写成

简记为{an}。
项

数列中的项必须是数，它可以是实数，也可以是复数。
用符号{an}表示数列，只不过是“借用”集合的符号，它们之间有本质上的区别：1.集合中的元素是互异的，而数列中的项可以是相同的。2.集合中的元素是无序的，而数列中的项必须按一定顺序排列，也就是必须是有序的。

分类编辑

（1）有穷数列和无穷数列：
项数有限的数列为“有穷数列”（finite sequence）；

项数无限的数列为“无穷数列”（infinite sequence）。

（2）对于正项数列：（数列的各项都是正数的为正项数列）
1）从第2项起，每一项都大于它的前一项的数列叫做递增数列；如：1，2，3，4，5，6，7；

2）从第2项起，每一项都小于它的前一项的数列叫做递减数列；如：8，7，6，5，4，3，2，1；

3）从第2项起，有些项大于它的前一项，有些项小于它的前一项的数列叫做摆动数列（摇摆数列）；

（3）周期数列：各项呈周期性变化的数列叫做周期数列（如三角函数）；

（4）常数数列：各项相等的数列叫做常数数列（如：2，2，2，2，2，2，2，2，2）。

公式编辑
（1）通项公式：数列的第N项an与项的序数n之间的关系可以用一个公式an=f(n)来表示，这个公式就叫做这个数列的通项公式，如  。数列通项公式的特点：1）有些数列的通项公式可以有不同形式，即不唯一；2）有些数列没有通项公式（如：素数由小到大排成一列2，3，5，7，11，...）。

（2）递推公式：如果数列{an}的第n项与它前一项或几项的关系可以用一个式子来表示，那么这个公式叫做这个数列的递推公式。数列递推公式特点：1）有些数列的递推公式可以有不同形式，即不唯一。2）有些数列没有递推公式，即有递推公式不一定有通项公式。
//出自百度百科

总之这道题的意思就是说把1-n进行排列，问有多少种排列刚好有K个小于号

先把正确的代码粘上，我们再来一句一句的看。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1010][1010];//dp[i][j]=dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j);
int n,m;
unsigned long long ans;
int Read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int main()
{
	int i,j;
	n=Read();
	m=Read();
	dp[0][0]=1;
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=m;j++)
		{
			dp[i][j]=dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j);
			dp[i][j]%=2012;
		}
	}
	printf("%d",dp[n][m]);
	return 0;
}
```

这道题就是DP，核心在于：

```cpp
dp[i][j]=dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j);
```
主要是由很多种可能，大于，或小于，或者在边界上。

当你理解了这句话，你就明白了！

---


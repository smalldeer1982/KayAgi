# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# 题解

## 作者：Cyhlnj (赞：50)

还有更优秀的组合数学+$DP$的做法

$sum[i]$表示$c[i]$的前缀和，$C[i][j]$即$C_{i}^{j}$，大小写区分开

设$f[i][j]$表示用了前$i$种颜色涂了$sum[i]$个块，其中有$j$对相邻同色块的方案数

考虑转移$f[i][j]$

$c[i + 1]$分成$a$组的插入到已经弄好的块中

$b$组插入到之前同色的之间

$a-b$组插空放不相邻

那么就是转移给$f[i + 1][j - b + c[i + 1] - a]$

方案数为$f[i][j] * C[c[i + 1] - 1][a - 1] * C[j][b] * C[sum[i] + 1 - j][a - b]$


$C[c[i + 1] - 1][a - 1]$就是分成$a$组的方案数（无序的）


$C[j][b]$就是插入到之前同色的之间的方案数（位置不同）


$C[sum[i] + 1 - j][a - b]$就是相当于前面有$sum[i]+1$个位置，$j$个相邻块占据的位置不能放，$a-b$插入进去的方案数


```cpp
# include <bits/stdc++.h>
# define RG register
# define IL inline
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;
const int Zsy(1e9 + 7);

IL ll Input(){
    RG ll x = 0, z = 1; RG char c = getchar();
    for(; c < '0' || c > '9'; c = getchar()) z = c == '-' ? -1 : 1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * z;
}

int k, c[16], C[80][80], f[20][80], sum[16];

IL void Prepare(){
    C[0][0] = 1;
    for(RG int i = 1; i <= 75; ++i){
        C[i][0] = 1;
        for(RG int j = 1; j <= 75; ++j)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % Zsy;
    }
}

int main(RG int argc, RG char* argv[]){
    Prepare();
    k = Input();
    for(RG int i = 1; i <= k; ++i) c[i] = Input(), sum[i] = sum[i - 1] + c[i];
    f[1][c[1] - 1] = 1;
    for(RG int i = 1; i < k; ++i)
        for(RG int j = 0; j < sum[i]; ++j){
            if(!f[i][j]) continue;
            for(RG int a = 1; a <= c[i + 1]; ++a)
                for(RG int b = 0; b <= a && b <= j; ++b){
                    RG int ret = 1LL * f[i][j] * C[c[i + 1] - 1][a - 1] % Zsy * C[j][b] % Zsy;
                    ret = 1LL * ret * C[sum[i] + 1 - j][a - b] % Zsy;
                    (f[i + 1][j + c[i + 1] - a - b] += ret) %= Zsy;
                }
        }
    printf("%d\n", f[k][0]);
    return 0;
}

```

---

## 作者：Bartholomew (赞：41)

#~By Bartholomew~

------
首先我们会发现,最难的莫过于对于 dp[i] (i 表示位置) 的转移,

**当然我们会不知道对于某一些非法状态的转移的判断**,所以我发现自己 G\_G 了!

那么我们如果对于这一题 , 发现 k 和 c[i] 的数值都十分的小! 于是我们来找方案了解决它,因为我们可以**暴力开 5 维来记录变化**


### dp[a][b][c][d][e][last]

**表示某颜色只能涂一下的有 a 个,能涂2下的颜色b个,...3个...c个...还有就是上一次的涂的颜色是 last ,如last = 4 表示上一次用的是能涂 4 下的颜色中的某一个!**


那么我们怎么转移呢?

**发现:**

我们用现在能涂 一下的颜色涂色,就是 ans+= a \* query(a-1,b,c,d,e,1);

但是如果 我们上一次用的是能涂 2 下的颜色,那么会产生什么问题? 就是在这一次的时候它就变成的只能涂 1 下的颜色,所以现在的 a 种能涂 1 下 的颜色 我们只能选(a-1) 种 可能


以此类推下去...(看代码就明白了!) 别忘了取模 1e9+7!

```cpp
//代码故意留了一个小错误,希望是阻止大家直接ctrl+a,ctrl+c ! >_<
// luogu-judger-enable-o2
#pragma GCC optimize(3)
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cstring>
#define ll long long
const ll MOD = 1000000007;
using namespace std;
int n,x,t[6];
ll dp[16][16][16][16][16][6];
inline ll DFS(int a,int b,int c,int d,int e,int last)
{
    if(dp[a][b][c][d][e][last]!=-1) return dp[a][b][c][d][e][last];
    if(a+b+c+d+e==0) return 1;
    ll res = 0;
    if(a) res += (a-(last==2)) * DFS(a-1,b,c,d,e,1);
    if(b) res += (b-(last==3)) * DFS(a+1,b-1,c,d,e,2);
    if(c) res += (c-(last==4)) * DFS(a,b+1,c-1,d,e,3);
    if(d) res += (d-(last==5)) * DFS(a,b,c+1,d-1,e,4);
    if(e) res += e * DFS(a,b,c,d+1,e-1,5);
    dp[a][b][c][d][e][last] = res%MOD;
    return dp[a][b][c][d][e][last];
}
int main(int argc, char const *argv[])
{
    scanf("%d",&n);
    for(;n;n--) scanf("%d",&x),t[x]++;
    memset(dp,-1,sizeof dp);
    printf("%lld\n",DFS(t[1],t[2],t[3],t[4],t[5],0));
    return main();
}
```

---

## 作者：逃离地球 (赞：27)

**[更好的阅读体验](https://yangqianrui.github.io/post/solution-p2476/)** ~~如果你打得开的话~~

**[题目链接](https://www.luogu.com.cn/problem/P2476)**

### 题意

$n$ 个小球，$m$ 种颜色，第 $i$ 种颜色有 $c_i$ 个，保证 $\sum c_i=n$，问有多少种染色方案，使得任意两个相邻小球颜色不同。

---

### 题解

这道题有多种方法，都具有一定的启发性，故在这里一并给出。

#### 算法一：暴力 dp

从左到右依次确定每个小球的颜色，直接在状态中表示每个颜色剩余的数量与最后一个小球的颜色，直接转移即可。

时间复杂度 $\mathcal O({c_i}^{m}\times m)$，无法接受。

#### 算法二：优化状态设计

发现 $c_i$ 的范围较小，且剩余个数相同的小球对我们来说没有区别，于是在状态中只需记录每种剩余数量的颜色有多少个，与最后一个小球的颜色的剩余数量即可，转移同样比较显然，在此不再赘述。

时间复杂度 $\mathcal O({m}^{c_i}\times c_i)$，使用记忆化搜索实现，可以通过此题。

#### 算法三：改变枚举方式

与 [此题](https://www.luogu.com.cn/problem/P2513) 类似（另外吐槽一下，这题咋是黄题啊，本菜鸡觉得挺难的啊……），考虑改变枚举方式，枚举颜色而非枚举小球，并且认为是不断地向小球序列中插入一种新颜色的小球。这样带来的好处是单次插入的小球颜色全部相同，方便统计插入后有多少相邻的同颜色小球。

于是设 $f_{i,j}$ 表示枚举到第 $i$ 个颜色，当前小球序列中有 $j$ 对相邻的同颜色小球的方案数，则答案为 $f_{n,0}$。设 $s_i=\sum_{j=1}^i c_j$。

考虑在 $f_{i-1,j}$ 的基础上插入第 $i$ 种颜色的小球，设这 $c_i$ 个小球被原来的序列分成了 $a$ 段，且其中 $b$ 段隔开了原来相邻的一对同颜色小球，则有 $a\le\min(s_{i-1}+1,c_i),b\le\min(a,j)$。且插入这些小球后，相邻同颜色小球的个数变为 $j-b+c_i-a$。

再考虑统计方案数，先插板法分段，再选出这 $a$ 段和 $b$ 段，方案数为 $\dbinom{c_i-1}{a-1}\times\dbinom{s_{i-1}+1-j}{a-b}\times\dbinom{j}{b}$。

于是可以写出转移方程式：
$$
f_{i,j-b+c_i-a}=\sum_{j=0}^{s_{i-1}-1}\sum_{a=1}^{\min(s_{i-1}+1,c_i)}\sum_{b=0}^{\min(a,j)}f_{i-1,j}\times\binom{c_i-1}{a-1}\times\binom{s_{i-1}+1-j}{a-b}\times\binom{j}{b}
$$
时间复杂度 $\mathcal O(n^4)$。

#### 算法四：更加优秀的容斥做法

设 $f_i$ 表示钦定 $i$ 个球与左边的球同色的方案数，$g_i$ 表示恰好 $i$ 个球与左边的球同色的方案数，则答案为 $g_0$。根据二项式反演，有 $g_0=\sum_{i=0}^n(-1)^if_i$。

现在考虑如何求出 $f_k$。

设颜色 $1$，颜色 $2$，……，颜色 $m$ 分别有 $k_1,k_2\cdots k_m$ 个球与左边的球同色（$\sum k_i=k$）。考虑颜色 $i$ 的小球，在序列中被分成了 $c_i-k_i$ 段连续的子段，共有 $\dbinom{c_i-1}{k_i}$ 种分段方法。再考虑整个序列，发现就是这 $n-k$ 个颜色段的可重排列问题（每种颜色内部的顺序不能改变，因为在枚举分段方法时已经枚举到了）。

于是有：
$$
f_k=\sum_{k_1+k_2+\cdots+k_m=k}\binom{c_1-1}{k_1}\binom{c_2-1}{k_2}\cdots\binom{c_m-1}{k_m}\frac{(n-k)!}{(c_1-k_1)!(c_2-k_2)!\cdots(c_m-k_m)!}
$$
发现这个式子其实是卷积的形式，使用暴力卷积（其实就是背包）可以以 $\mathcal O(n^2)$ 的复杂度求出 $f_{1\sim n}$。

#### 算法五：使用 `fft` 优化

再推一推上面这个式子，答案其实就是这个：
$$
\sum_{k=0}^n(-1)^k(n-k)![x^k]\prod_{i=1}^m\sum_{j=0}^{c_i-1}\binom{c_i-1}{j}\frac{x^j}{(c_i-j)!}
$$
使用 `fft` 求多项式卷积，时间复杂度 $\mathcal O(n\log^2n)$。

~~其实我不会写 `fft`~~

---

### 代码

算法一、算法二略。

#### 算法三：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int read() {
    int ret = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)) f = (ch == '-') ? -f : f, ch = getchar();
    while (isdigit(ch)) ret = ret * 10 + ch - '0', ch = getchar();
    return ret * f;
}

const int P = 1e9 + 7, N = 1000;
int n, col[N], sum[N], f[N][N], c[N][N];

signed main() {
    n = read();
    for (int i = 1; i <= n; ++i) col[i] = read(), sum[i] = sum[i - 1] + col[i];

    c[0][0] = 1;
    for (int i = 1; i <= 100; ++i) {
        c[i][0] = 1;
        for (int j = 1; j <= 100; ++j)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % P;
    }

    f[1][col[1] - 1] = 1;
    for (int i = 1; i < n; ++i)
        for (int j = 0; j <= sum[i] - 1; ++j)
            for (int a = 1; a <= min(sum[i] + 1, col[i + 1]); ++a)
                for (int b = 0; b <= min(j, a); ++b)
                    f[i + 1][j + col[i + 1] - a - b] +=
                        f[i][j] * c[sum[i] + 1 - j][a - b] % P * c[j][b] % P *
                        c[col[i + 1] - 1][a - 1] % P,
                        f[i + 1][j + col[i + 1] - a - b] %= P;

    printf("%lld\n", f[n][0]);
    return 0;
}

```

#### 算法四：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;

typedef long long ll;
const int MAXN = 105, MOD = 1e9 + 7;
inline void ADD(int& x, int y) {
    x += y;
    if (x >= MOD) x -= MOD;
}
inline void DEC(int& x, int y) {
    x -= y;
    if (x < 0) x += MOD;
}
ll q_pow(ll a, ll b, ll p = MOD) {
    ll ret = 1;
    for (; b; a = a * a % p, b >>= 1)
        if (b & 1) ret = ret * a % p;
    return ret;
}
ll q_inv(ll x, ll p = MOD) { return q_pow(x, p - 2, p); }

int N, M, ans, c[MAXN], f[MAXN], g[MAXN], fac[MAXN], ifac[MAXN];
inline int C(int n, int m) {
    return 1ll * fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;
}

int main() {
    scanf("%d", &M);
    for (int i = 1; i <= M; ++i) scanf("%d", &c[i]), N += c[i];
    fac[0] = 1;
    for (int i = 1; i <= N; ++i) fac[i] = 1ll * fac[i - 1] * i % MOD;
    ifac[N] = q_inv(fac[N]);
    for (int i = N - 1; i >= 0; --i)
        ifac[i] = 1ll * ifac[i + 1] * (i + 1) % MOD;
    f[0] = 1;
    for (int i = 1; i <= M; ++i) {
        for (int j = 0; j <= N; ++j) g[j] = 0;
        for (int j = 0; j <= N; ++j)
            if (f[j]) {
                for (int k = 0; k < c[i]; ++k)
                    ADD(g[j + k], 1ll * f[j] * C(c[i] - 1, k) % MOD *
                                      ifac[c[i] - k] % MOD);
            }
        for (int j = 0; j <= N; ++j) f[j] = g[j];
    }
    for (int i = 0; i <= N; ++i) {
        int tmp = 1ll * fac[N - i] * f[i] % MOD;
        if (i & 1)
            DEC(ans, tmp);
        else
            ADD(ans, tmp);
    }
    printf("%d", ans);
    return 0;
}

```

算法五：不会写 fft，以后再说……

---

**感谢神仙 [Mr_Wu](https://www.luogu.com.cn/user/62308) 对本篇题解做出的巨大贡献！！！**

**求点赞 qwq**

打个广告：[我的博客](https://yangqianrui.github.io/)

---

## 作者：Log_x (赞：19)

**【解题思路】**

注意到题目中的信息 $1 \le ci \le 5$，同时 $c_i$ 相同的油漆本质上是相同的，于是我们令 $f[c_1][c_2][c_3][c_4][c_5][last]$ 表示当还能够涂 $1$ 个格子的油漆有 $c_1$ 种，还能够涂 $2$ 个格子的油漆有 $c_2$ 种……（以此类推）且按木块 $1$~$n$ 编号顺序涂，上一次涂的是能够涂 $last$ 个格子的油漆时的总方案数。

但这样还要判断是否相邻的情况，我们可以由此推出状态转移方程：

$f[c_1][c_2][c_3][c_4][c_5][last] =$

$[c_1 - (last == 2)] * f[c_1 - 1][c_2][c_3[c_4][c_5][1] +$

$[c_2 - (last == 3)] * f[c_1 + 1][c_2 - 1][c_3][c_4][c_5][2] +$

$[c_3 - (last == 4)] * f[c_1][c_2 + 1][c_3 - 1][c_4][c_5][3] +$

$[c_4 - (last == 5)] * f[c_1][c_2][c_3 + 1][c_4 - 1][c_5][4] +$

$c_5 * f[c_1][c_2][c_3][c_4 + 1][c_5 - 1][5]$

那么这是什么意思呢，显然方案数 $f$ 可以由下一次涂能够涂 $i (1 \le i \le 5)$ 个格子的油漆的方案数倒推转移过来，且涂完以后还能够涂 $i$ 个格子的油漆种数 $c_i - 1$，还能够涂 $i - 1$ 个格子的油漆种数 $c_{i-1} + 1$，表示这种油漆涂了 $1$ 个格子。

回到我们所说的相邻情况，假设上一次用的是可以涂 $last$ 个格子的油漆，那么上一次用完后，那种油漆就只可以涂 $last - 1$ 个格子了，那么这一次涂油漆的时候就不能再选可以涂 $last - 1$ 个格子的油漆的一种，因为这种上次已经用过了，且相同的油漆不能相邻。

考虑到方案数 $f$ 倒推而来，且有多种情况的转移，且每种情况又有无数多的分支，我们使用**记忆化搜索**。

记忆状态来优化时间效率，令搜索边界为 $f[0][0][0][0][0][last (1 \le last \le 5)] = 1$，即全部涂完方案数为 $1$，即可求出答案。

**【AC代码】**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;
typedef long long ll;
const int Maxn = 0x3f3f3f3f, N = 16;
const ll Mod = 1000000007;
ll f[N][N][N][N][N][6], res;
int n, m, x, num[6];

inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}

inline void put(ll x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}

inline ll Dfs(const int c1, const int c2, const int c3, const int c4, const int c5, const int lst)
{
    if (f[c1][c2][c3][c4][c5][lst]) return f[c1][c2][c3][c4][c5][lst];
    ll res = 0;
    if (c1) res = (res + (c1 - (lst == 2)) * Dfs(c1 - 1, c2, c3, c4, c5, 1)) % Mod;
    if (c2) res = (res + (c2 - (lst == 3)) * Dfs(c1 + 1, c2 - 1, c3, c4, c5, 2)) % Mod;
    if (c3) res = (res + (c3 - (lst == 4)) * Dfs(c1, c2 + 1, c3 - 1, c4, c5, 3)) % Mod;
    if (c4) res = (res + (c4 - (lst == 5)) * Dfs(c1, c2, c3 + 1, c4 - 1, c5, 4)) % Mod;
    if (c5) res = (res + c5 * Dfs(c1, c2, c3, c4 + 1, c5 - 1, 5)) % Mod;
    return f[c1][c2][c3][c4][c5][lst]=res; 
} 

int main()
{
    for (int i = 1; i <= 5; ++i) f[0][0][0][0][0][i] = 1;
    n = get(); for (int i = 1; i <= n; ++i) num[x = get()]++;
    return put(Dfs(num[1], num[2], num[3], num[4], num[5], 0)), 0;
}
```

---

## 作者：mulberror (赞：12)

# 前言
觉得没有一篇题解从头到尾将的非常清楚，蒟蒻chhokmah就提供一份我从打开题目到思考到一发AC~~WA~~的题解。不忘安利自己博客[【传送门】](https://www.cnblogs.com/chhokmah/p/10562914.html)，虽然可能和前面大佬们的思路是一样的，但是比较简单易懂。希望管理员能通过这篇非常详细的题解。

-----

# 题目描述
有n个木块排成一行，从左到右依次编号为1~n。你有k种颜色的油漆，其中第i种颜色的油漆足够涂ci个木块。所有油漆刚好足够涂满所有木块，即c1+c2+…+ck=n。相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

# 题解
首先考虑如何定义状态，一眼就发现了$c_i<=5$，说明什么，我们可以直接将各个颜色还剩下多少的个数都压到状态中，也就是一个五维的状态。而且题目很明显的发现如果定义各个颜色还有多少个，那么需要用15维，数组直接爆炸。    
但是题目要求不能相邻，因为我们已经采取了用个数作为前面的5个状态，那么参考[chess](https://www.cnblogs.com/chhokmah/p/10560439.html)的思路，排列组合来排除是否是相邻的，这个待会再说。说的明白一点，就是在定义$1$维状态，表示上一个格子我们用的是个数是$lst$颜色。    
总结一下：$f[i1][i2][i3][i4][i5][lst]$，$i_i$表示的是$i$颜色还有$i_i$个，前一个涂得颜色是$lst$个颜色时方案总数。

我们把这个放棋子的过程，按照从左到右的顺序。

------
接下来我们思考决策。我们举3个例子，分别是我们放的颜色是$1$和$3$和$5$。    
如果我们当前放的颜色是个数为$1$的，那么分成两种情况：
* 如果lst=2，那么说明原来是一个是从$2$个颜色中取出了一个颜色，变成了个数为$1$的颜色，从而得出我们现在放的颜色就是现在有$1$个的颜色，那么不能重复，就说明剩下来的$i1-1$个一个的颜色都可以放到这个颜色中。
* 如果不是2的话，就和上面的情况刚好相反，也就是之前放的颜色不会和我们现在放的颜色不会冲突，乘法原理可以得到方程。

总结一下转移方程
$$if (lst=2) f[i1][i2][i3][i4][i5][lst] += (i1 - 1) * f[i1-1][i2][i3][i4][i5][1]$$
否则
$$f[i1][i2][i3][i4][i5][lst] += i1*f[i1-1][i2][i3][i4][i5][1]$$

------
如果我们放的颜色个数为$3$，这种情况和$2$以及$4$是相同的，以3为例：
* 如果lst=4，那么参照前面的思路，现在这个颜色就是个数为$3$个的颜色，那么如果要将$3$放进去，那么会是剩下来个数为$2$的颜色个数会$+1$，让个数为$3$的颜色个数$-1$，
* 反之也就是之前放的颜色不会和我们现在放的颜色不会冲突，乘法原理可以得到方程。

总结一下转移方程
$$if (lst=4) f[i1][i2][i3][i4][i5][lst]+=(i3-1)*f[i1][i2+1][i3-1][i4][i5][3]$$
否则
$$f[i1][i2][i3][i4][i5][lst]+=i3*f[i1][i2+1][i3-1][i4][i5][3]$$

-----
如果我们放的个数是$5$：
因为不可能有颜色可以放了之后还有$5$个，那么就直接乘法原理就可以的到房成了。
总结一下转移方程
$$f[i1][i2][i3][i4][i5][lst] += i5*f[i1-1][i2][i3][i4][i5][5]$$

----
状态转移方程完成了，那么接下来就是状态的边界条件。很清楚的是，一开始的时候无论取哪一个颜色方案数都只有$1$，那么也就是$f[0][0][0][0][0][i]=1$，其他都赋值为0。  
因为考虑到这道题目线性推常数较大，就采用了记忆化搜索来实现DP。

# ac代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define ms(a, b) memset(a, b, sizeof(a))
#define inf 0x3f3f3f3f
#define mod 1000000007
using namespace std;
template <typename T>
inline void read(T &x) {
    x = 0; T fl = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') fl = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    x *= fl;
}
ll f[16][16][16][16][16][6];
int d[6];
int n;
ll dfs(int i1, int i2, int i3, int i4, int i5, int lst) {
    if (f[i1][i2][i3][i4][i5][lst]) return f[i1][i2][i3][i4][i5][lst];
    ll res = 0;
    if (i1 > 0) {
        if (lst == 2) res = (res + (i1 - 1) * dfs(i1 - 1, i2, i3, i4, i5, 1)) % mod;
        else res = (res + i1 * dfs(i1 - 1, i2, i3, i4, i5, 1)) % mod;
    }
    if (i2 > 0) {
        if (lst == 3) res = (res + (i2 - 1) * dfs(i1 + 1, i2 - 1, i3, i4, i5, 2)) % mod;
        else res = (res + i2 * dfs(i1 + 1, i2 - 1, i3, i4, i5, 2)) % mod;
    }
    if (i3 > 0) {
        if (lst == 4) res = (res + (i3 - 1) * dfs(i1, i2 + 1, i3 - 1, i4, i5, 3)) % mod;
        else res = (res + i3 * dfs(i1, i2 + 1, i3 - 1, i4, i5, 3)) % mod;
    }
    if (i4 > 0) {
        if (lst == 5) res = (res + (i4 - 1) * dfs(i1, i2, i3 + 1, i4 - 1, i5, 4)) % mod;
        else res = (res + i4 * dfs(i1, i2, i3 + 1, i4 - 1, i5, 4)) % mod;
    }
    if (i5 > 0) {
        res = (res + i5 * dfs(i1, i2, i3, i4 + 1, i5 - 1, 5)) % mod;
    }
    return f[i1][i2][i3][i4][i5][lst] = res % mod;
}
int main() {
    int k;
    read(k);
    for (int i = 1; i <= k; i ++) {
        int x; 
        read(x);
        d[x] ++;
    }
    for (int i = 1; i <= 5; i ++) f[0][0][0][0][0][i] = 1;
    printf("%lld\n", dfs(d[1], d[2], d[3], d[4], d[5], 0) % mod);
    return 0;
}

```

---

## 作者：yybyyb (赞：8)

记忆化搜索

因为每种油漆的数量是有限的

并且每种油漆是没有优先级的

所以采用记忆化搜索即可

还有一点

如果直接复制我的代码保证AC不了


```cpp
//DFS搜索得返回值类型要是long long，要不然会Wa 
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const long long Mod=10000000007;
long long f[16][16][16][16][16][7];
long long DFS(int a,int b,int c,int d,int e,int l)//表示可以刷1个颜色的油漆个数为a,以此类推 
                                            //l表示上一个的颜色的剩余个数是l的那一类  
{
      if(f[a][b][c][d][e][l]!=0)                   //记忆化搜索 
          return f[a][b][c][d][e][l];
      if(a+b+c+d+e==0)                          //油漆已经全部用完,返回 
          return f[a][b][c][d][e][l]=1; 
      long long s=0;
      if(a!=0)                                    //当前个数不为0，即可以刷漆
         s+=(a-(l==2?1:0))*DFS(a-1,b,c,d,e,1);  //这里的l要和大1的进行比较
                                                //因为如果是从上面掉下来的话，要考虑相邻的情况 
      s%=Mod;                                    //不要忘记取膜 
      if(b!=0)                                    
         s+=(b-(l==3?1:0))*DFS(a+1,b-1,c,d,e,2);//不要忘记用完之后会向下掉一个位置
      s%=Mod;                            
      if(c!=0)                                
         s+=(c-(l==4?1:0))*DFS(a,b+1,c-1,d,e,3);
      s%=Mod;                            
      if(d!=0)                                
         s+=(d-(l==5?1:0))*DFS(a,b,c+1,d-1,e,4);
      s%=Mod;                                
      if(e!=0)
         s+=(e-(l==6?1:0))*DFS(a,b,c,d+1,e-1,5);//这里可以不用相等，只是为了格式整齐 
      s%=Mod;
      f[a][b][c][d][e][l]=s;
      return s;
}
int main()
{
      int k,a;
      cin>>k;
      int color[6]={0,0,0,0,0,0};
      for(int i=1;i<=k;++i)
      {
              cin>>a;
              color[a]++;
      }
      memset(f,0,sizeof(f));
      cout<<DFS(color[1],color[2],color[3],color[4],color[5],0)<<endl;
      return 0;
}
```

---

## 作者：ADay (赞：3)

[更好的阅读体验](https://www.cnblogs.com/aday526/p/solution-p2476.html)


多维dp+暴力记搜

## Solution

显然是一个计数dp，但是状态的存储很难想到：$f[a_1][a_2][a_3][a_4][a_5][last]$ 表示第 $i$ 种颜色还剩 $a_i$ 个时，当前木块颜色为 $last$ 的方案数。考虑记搜，即 $f[a_1][a_2][a_3][a_4][a_5][last]$ 是从少一个木块的状态转移来的，那么分别考虑上一个木块的颜色为 $1-5$ 即可转移。

转移方程：如果上一个是颜色 $i$，就要从 $f[...][a_{i-1}+1][a_i-1][...][last]$ 转移，并且考虑其相同颜色的顺序不同，还要乘上 $\begin{cases}a_i-1&last=a_i\\a_i&last\not=a_i\end{cases}$。

## Code

注意勤取模（

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P=1e9+7;
int n,f[17][17][17][17][17][7],tot,cnt[17];
#define val f[a][b][c][d][e][las]
int dfs(int a,int b,int c,int d,int e,int las){
	if(val!=-1)return val;
	if(a+b+c+d+e==0)return 1;
	int res=0;
	if(a)(res+=1ll*dfs(a-1,b,c,d,e,1)*(a-(las==2))%P)%=P;
	if(b)(res+=1ll*dfs(a+1,b-1,c,d,e,2)*(b-(las==3))%P)%=P;
	if(c)(res+=1ll*dfs(a,b+1,c-1,d,e,3)*(c-(las==4))%P)%=P;
	if(d)(res+=1ll*dfs(a,b,c+1,d-1,e,4)*(d-(las==5))%P)%=P;
	if(e)(res+=1ll*dfs(a,b,c,d+1,e-1,5)*e%P)%=P;
	return val=res;
}
int main(){
	scanf("%d",&n);
	for(int i=1,x;i<=n;i++)
		scanf("%d",&x),cnt[x]++;
	memset(f,-1,sizeof(f));
	printf("%d\n",dfs(cnt[1],cnt[2],cnt[3],cnt[4],cnt[5],0));
	return 0;
}
```



---

## 作者：EmpyreanCz (赞：2)

这道题其实想懂了还是很水的，主要思路就是六维数组的dp+记忆化搜索。
用dp[a][b][c][d][e][last]表示当前有能涂1次的油漆a个，能涂2次的b个….前一个颜色为l，再转移就行了。
这里是hzwerd的博客
[hzwer](http://hzwer.com/1884.html)
```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
long long dp[16][16][16][16][16][6];
long long t[6];
long long n;
long long x;
long long dfs(long long a,long long b,long long c,long long d,long long e,long long last) {
    if(dp[a][b][c][d][e][last]!=0)return dp[a][b][c][d][e][last];
    if(a+b+c+d+e==0)return 1;
    long long ans=0;
    if(a!=0)ans+=(a-(last==2))*dfs(a-1,b,c,d,e,1);
    if(b!=0)ans+=(b-(last==3))*dfs(a+1,b-1,c,d,e,2);
    if(c!=0)ans+=(c-(last==4))*dfs(a,b+1,c-1,d,e,3);
    if(d!=0)ans+=(d-(last==5))*dfs(a,b,c+1,d-1,e,4);
    if(e!=0)ans+=e*dfs(a,b,c,d+1,e-1,5);
    dp[a][b][c][d][e][last]=ans%mod;
    return dp[a][b][c][d][e][last];
}
int main() {
    cin>>n;
    for(int i=1; i<=n; i++) {
        cin>>x;
        t[x]++;
    }
    cout<<dfs(t[1],t[2],t[3],t[4],t[5],0);
}

```

---

## 作者：PragmaGCC (赞：1)

比较难想的记搜。

这道题的难点就在于，如何去设计 DP 的状态，如何将大量的信息融合进一个变量里面。

在这里，每一种颜料到底是什么并不重要，重要的是这种颜料**还能涂多少**。

注意到$k$很小，这启示我们从颜料还能涂的方块数入手，设计状态。

我们定义$f(a,b,c,d,e,last)$为当还剩a个能涂1个方块、b个能涂2个方块……e个能涂5个方块的颜料，并且上一个颜色**能涂last**个方块。

如果还有能涂x个方块的颜料，我们可以尝试将其涂上色，但是要除去上一个方块也是这个颜色的情况。需要注意的是，当我们涂上这个颜色的时候，这个颜色就只能再涂x-1个方块了。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
int read() {
	register int n = 0;
	register char ch = getchar();
	bool f = 1;
	while(ch < '0' | ch > '9') {
		if (ch == '-') f = 0;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		n = (n << 3) + (n << 1) + (ch ^ '0');
		ch = getchar();
	}
	return f ? n : -n;
}
typedef long long ll;
const int K = 20, mod = 1e9 + 7;
int f[K][K][K][K][K][10];
ll dfs(int a, int b, int c, int d, int e, int last) {
	if (a + b + c + d + e == 0) return 1;
	if (~f[a][b][c][d][e][last]) return f[a][b][c][d][e][last];
	ll ans = 0;
	if (a > 0) ans += dfs(a-1, b, c, d, e, 1) * (a - (last == 2));
	if (b > 0) ans += dfs(a+1, b-1, c, d, e, 2) * (b - (last == 3));
	if (c > 0) ans += dfs(a, b+1, c-1, d, e, 3) * (c - (last == 4));
	if (d > 0) ans += dfs(a, b, c+1, d-1, e, 4) * (d - (last == 5));
	if (e > 0) ans += dfs(a, b, c, d+1, e-1, 5) * e;
	return f[a][b][c][d][e][last] = ans % mod;
}
int a[10];
int main(void) {
	//freopen("3.txt", "r", stdin);
	memset(f, -1, sizeof(f));
	int k = read();
	for (int i=1; i<=k; i++) a[read()]++;
	//for (int i=1; i<=5; i++) printf("%d ", a[i]);
	printf("%lld\n", dfs(a[1], a[2], a[3], a[4], a[5], 0) % mod);
	return 0;
}
```

---

## 作者：安好 (赞：1)

/\*
先确定这是一道dp

再看范围得结论这是一道多维dp，想起了王八棋。

然后定状态，很多维的话只能一种一维咯，因为要转移所以还要加一维

f[a][b][c][d][e][k] 铅丝维是种类最后是上一块放的是第几种

转移略麻烦，比如这次三块的减了一，两块的就加了一，乘的时候就要减回来。

乘法原理，自行体会，，，，，，

\*/




```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define mod 1000000007
using namespace std;
ll f[16][16][16][16][16][6];
int x[6],n;
bool L[16][16][16][16][16][6];
ll dp(int a,int b,int c,int d,int e,int k)
{
    ll t=0;
    if(L[a][b][c][d][e][k])return f[a][b][c][d][e][k];
    if(a+b+c+d+e==0)return 1;
    if(a)  
        t+=(a-(k==2))*dp(a-1,b,c,d,e,1  );
    if(b)  
        t+=(b-(k==3))*dp(a+1,b-1,c,d,e,2);  
    if(c)  
        t+=(c-(k==4))*dp(a,b+1,c-1,d,e,3);  
    if(d)  
        t+=(d-(k==5))*dp(a,b,c+1,d-1,e,4);  
    if(e)  
        t+=e*dp(a,b,c,d+1,e-1,5);  
    L[a][b][c][d][e][k]=1;
    return f[a][b][c][d][e][k]=(t%mod);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int t;
        scanf("%d",&t);
        x[t]++;
    }
    printf("%lld",dp(x[1],x[2],x[3],x[4],x[5],0));
    return 0;
}
```

---

## 作者：xh2010 (赞：0)

这题竟然没有题解？我来发一下吧。

因为我的语文水平不太好，请各位见谅。

首先，很明显是一道DP题。由于我是个初学者，状态转移方程不会写，就到网上学了一下。我们可以利用题目的数据范围（只有5种颜色），所以我们可以定义一个5维数组，再考虑到相邻颜色不同的情况，我们再增加一维，表示最后一个木块的颜色。我们用一个数组记录可涂次数相等的个数，再用一个递归枚举每种出现的情况。

动态转移方程较长，我在这里就不写了，程序中会有。

注意：f[a1,a2,a3,a4,a5,m]中，a1,a2,a3,a4,a5表示可涂次数分别为1,2,3,4,5的个数，m代表最后一个木块的颜色的可涂次数（有点绕）。


下面是我的程序：









```cpp
program p2476;
const maxn=1000000007;
var k:longint;
    a:array[1..5] of longint;
    f:array[0..16,0..16,0..16,0..16,0..16,0..6] of longint;
procedure init;
var i,x:longint;
begin
  readln(k);
  fillchar(a,sizeof(a),0);
  for i:=1 to k do
  begin
    read(x);
    inc(a[x]);        //记录可涂次数相等的个数
  end;
end;
function mo(x,y:longint):longint;      //防止越界
var t:int64;
begin
  t:=x;
  t:=t*y;
  t:=t mod maxn;
  mo:=t;
end;
function work(a1,a2,a3,a4,a5,m:longint):longint;         //递归
var t:longint;
begin
  if (a1+a2+a3+a4+a5=0) then f[a1,a2,a3,a4,a5,m]:=1;
  if f[a1,a2,a3,a4,a5,m]>0 then exit(f[a1,a2,a3,a4,a5,m]);
  t:=f[a1,a2,a3,a4,a5,m];
  if a1>0 then t:=(t+mo((a1-ord(m=2)),work(a1-1,a2,a3,a4,a5,1))) mod maxn;
  if a2>0 then t:=(t+mo((a2-ord(m=3)),work(a1+1,a2-1,a3,a4,a5,2))) mod maxn;
  if a3>0 then t:=(t+mo((a3-ord(m=4)),work(a1,a2+1,a3-1,a4,a5,3))) mod maxn;
  if a4>0 then t:=(t+mo((a4-ord(m=5)),work(a1,a2,a3+1,a4-1,a5,4))) mod maxn;
  if a5>0 then t:=(t+mo(a5,work(a1,a2,a3,a4+1,a5-1,5))) mod maxn;
  f[a1,a2,a3,a4,a5,m]:=t;
  exit(f[a1,a2,a3,a4,a5,m]);
end;
procedure main;
begin
  writeln(work(a[1],a[2],a[3],a[4],a[5],0));
end;
begin
  init;
  main;
end.
```

---


# [ZJOI2004] 午餐

## 题目描述

上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。

THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。

现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。

假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。

现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。


## 说明/提示

所有输入数据均为不超过200的正整数。


## 样例 #1

### 输入

```
5
2 2
7 7
1 3
6 4
8 5
```

### 输出

```
17```

# 题解

## 作者：M_seа (赞：193)

[原文](http://blog.csdn.net/qq_36288976/article/details/79343492)

这道题目比较难想。

算法：贪心+dp

容易想到贪心：吃饭慢的先打饭节约时间， 所以先将人按吃饭时间从大到小排序。

然后就是dp了： 
首先，应该想到f[i][j][k]:前i个人，在1号窗口打饭总时间j，在2号窗口打饭总时间k 

当然，这样会爆空间，所以想到去掉一维。

**f[i][j]表示前i个人，在1号窗口打饭总时间j，最早吃完饭的时间**

我们可以发现 j+k=前i个人打饭总和，k = sum(i)-j。 
所以可以维护一个前缀和：
```cpp
for(int i = 1; i <= n; i++)
	sum[i] = sum[i-1] + s[i].a;
```

接下来就是dp的转移：

```cpp
将第i个人放在1号窗口：
if(j>=s[i].a) f[i][j] = min(f[i][j], max(f[i-1][j-s[i].a], j+s[i].b));

f[i-1][j-s[i].a]是i号人打饭+吃饭的时间不足i-1号人吃饭的时间， 所以没有影响
j+s[i].b就是造成了影响

将第i个人放在2号窗口：
f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j+s[i].b));   
这里也是一样的 
(sum[i]-j 就是k)
```


转移方程如果没有看懂，可以结合图来理解

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 210;
int f[N][N*N];
struct node
{
    int a, b;
    bool operator <(node z) const
    {
        return b>z.b;
    }
}s[N];
int sum[N];
int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d %d", &s[i].a, &s[i].b);
    sort(s+1, s+1+n);
    for(int i = 1; i <= n; i++)
        sum[i] = sum[i-1] + s[i].a;
    memset(f, 127, sizeof(f));
    f[0][0] = 0;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 0; j <= sum[i]; j++)
        {
            if(j>=s[i].a) f[i][j] = min(f[i][j], max(f[i-1][j-s[i].a], j+s[i].b));
            f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j+s[i].b));
        }
    }
    int ans = 2147483647;
    for(int i = 0; i <= sum[n]; i++)
        ans = min(ans, f[n][i]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：ddwqwq (赞：51)

写在前面的话

最近复习DP，想方程想得头疼，题解又大都语焉不详，非但刷题带来的快感大不如前，而且十分费时，常常导致我熬夜，我自己都几乎要“哀民生之多艰”了。现在好不容易想明白一道题，我打算自己写写题解，看能否讲得更清楚一点，以方便后来者。当然，本人水平有限，还望多多包涵。

一.思路

由于这题放在提高组动态规划专题下，我们很容易想到用数组来记录每一个状态对应的打饭总时间。仔细分析之下，本题的状态可以分为三个维度：当前分配到第几个人，第一个队伍当前打饭总时间，第二个队伍当前打饭总时间。这样的话，每个数组元素的意义可以这样描述：dp[i][j][k]表示在只考虑第i及以后的人的情况下，第一队已用时j，第二队已用时k，最后集合的最短时间。状态转移分为两种情况：i分给一队、i分给二队，取两种情况的最小值，暂时不多描述。

这就是大概的思路，但是具体实现略有不同，因为这个方法有两个问题：

①.选择i的顺序不同会导致结果的不同。这一点最为致命。

②.内存会爆炸。数组至少需要200^4\*sizeof（short）的大小（用滚动数组优化），明显会内存爆炸。

二.具体实现

1.我们首先来看第一个问题如何利用贪心解决。

首先简化问题，假定只有一个打饭窗口，且定义延后时间T，第i个人的延后时间记作T[i]，则T[i]=max(eat[i] -  Σ（i<j<=N）time[j] , 0)其中j∈Z，N为总人数，time[j]表示第j个人的打饭时间，eat[j]，表示第j个人的吃饭时间。显然，最后的集合时间为Σ（1<=j<=N）time[j] + max{T[j] , j∈[1,N]}。

限于篇幅和本人的能力，我只写出证明贪心正确性的大概过程。将人按照eat大小从大到小排序后，可以证明此时max{T[j] , j∈[1,N]}最小，因为任何顺序改变都会导致max{T[j] , j∈[1,N]}增加（或至少持平），而Σ（1<=j<=N）time[j]不会改变。所以将人按照eat大小从大到小排序后，最后集合时间最短。我们可以很容易地将此结论推广到两支队伍的情况，从而证明贪心的正确性。

2.对于第二个问题，我们可以通过更简练的状态描述来解决。

定义数组dp[i][j][k]，用i表示当前正在分配的对象，j表示第k组已用时间。则dp[i][j][k]表示把第i个人分配到第k组，在只考虑[i,N]的情况下，最短集合时间。具体状态转移方程见代码。

三.代码

```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
//#include <time.h>//跟time数组冲突

#define INF 100000000

struct node {//用于桶排序
    int t;
    node *next;
    node()
    {
        next = NULL;
    }
};
int N;
int time[300], eat[300], sum[300];
int d[205][40300][2];//这里的定义与上面相同

int max(int a, int b)
{
    if (a > b)
        return a;
    return b;
}
int min(int a, int b)
{
    if (a < b)
        return a;
    return b;
}
//个人喜欢用记忆化搜索，而且本题搜索可以避免计算冗余状态
int dfs(int i, int now, int q)
{
    if (i > N)
        return 0;//基础情形
    if (d[i][now][q] > 0)
        return d[i][now][q];

    return d[i][now][q] = max(now + time[i] + eat[i], min(dfs(i + 1, now + time[i], q)
        , dfs(i + 1, sum[i] - now - time[i], 1 - q)));//重点，状态转移方程
    //，sum[i]=Σ(j∈[1,i])time[j],所以当前另一组时间为sum[i] - now - time[i]
}

void read()
{//读入，顺便来个桶排序，桶排序效率高，还很好写
    node *bucket[300];
    int i, t;

    memset(bucket, 0, sizeof(bucket));

    scanf("%d", &N);
    for (i = 0; i < N; i++)
    {
        node *p = new(node);
        scanf("%d %d", &p->t, &t);

        if (bucket[t] == NULL)
            bucket[t] = p;
        else
        {
            p->next = bucket[t];
            bucket[t] = p;
        }
    }

    int k = 1;
    for (i = 200; i > 0; i--)
    {
        node *p = bucket[i];
        while (p != NULL)
        {
            time[k] = p->t;
            sum[k] = sum[k - 1] + p->t;
            eat[k++] = i;
            p = p->next;
        }
    }
}

int main()
{
    read();//简短的主函数

    printf("%d", min(dfs(1, 0, 0), dfs(1, 0, 1)));

    system("pause");//记得注释掉
    return 0;
}
```

---

## 作者：Starria的脑残粉 (赞：46)

随机跳题跳到这题。。

其实就是个简单的dp辣，f[i][j]表示前i-1个数，第一个队列恰好要j的时间的最晚集合时间。

显然成立的是吃饭时间越长的越早打饭

然鹅200\*40000的好像开不下

降维呗、、

```cpp
#include<bits/stdc++.h>
using namespace std;
struct lsg{int x,y;}a[1000];
int n,f[400001],sum,ans,b[1000];
bool pd(lsg x,lsg y){return x.y>y.y;}
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    for (int i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
    sort(a+1,a+1+n,pd);memset(f,10,sizeof(f));f[0]=0;//排序而已
    for (int i=1;i<=n;i++)b[i]=a[i].x+b[i-1];
    for (int i=1;i<=n;i++){
            for (int j=sum;j>=0;j--){
                    f[j+a[i].x]=min(f[j+a[i].x],max(f[j],a[i].y+j+a[i].x));//将i加入第一个队列
                    f[j]=max(f[j],a[i].y+b[i]-j);//将i加入第二个队列
                }
            sum+=a[i].x;
        }
    ans=1e9;
    for (int i=1;i<=sum;i++)ans=min(ans,f[i]);
    cout<<ans<<endl;
}
```

---

## 作者：楚泫 (赞：23)

## [更好的阅读体验点击此处！！](https://www.cnblogs.com/chu-xuan/p/10087182.html)
---
# $\color{blue}\mathbf{\text{蒟蒻的解题思路}}$

首先，如果只有一队的话，整队的打饭时间是固定的。那么，我们让吃饭时间长的人先打饭

**贪心证明：**

设a[i].x表示第i个人的打饭时间，a[i].y表示第i个人的吃饭时间

同理，设a[j].x表示第j个人的打饭时间，a[j].y表示第j个人的吃饭时间

并且a[i].y>a[j].y。

- 假设j在前面，

  t1=max(a[j].x+a[i].x+a[i].y,a[j].y+a[j].x)

  max中的前者表示j吃完饭后i还没有吃完；后者表示j吃完饭前i就吃完了。

- 同理，i在前面的话

  t2=max(a[i].x+a[j].x+a[j].y,a[i].y+a[i].x)

  t1=max(a[i].x+a[i].y,a[j].y)+a[j].x

  ∵a[i].y>a[j].y

  ∴以a[i].x+a[i].y>a[j].y

  故t1=a[i].x+a[j].x+a[i].y

  t2=max(a[j].x+a[j].y,a[i].y)+a[i].x

若t2=a[i].x+a[j].x+a[j].y，

∵a[i].y>a[j].y

∴t1>t2

若t2=a[i].x+a[i].y

t1显然>t2

因此当a[i].y>a[j].y时，i在前面更优。

证毕。

-----
贪心后，就可以直接省去动规中枚举的人数一维，因为已经保证了从前到后考虑可以最优。

#### 设dp[i]表示在一窗口打饭i时间，最后的总时间

当我们枚举到第i个人，此时在一号打饭j时间

i既可以去一号窗口，也可以去二号窗口。

因此进行**分类讨论**：

## 若第i个人在一号打饭：

　　如果前面的人吃完饭的时间比第i个人吃完饭的时间长
  
　　那么　　dp[j+a[i].x]=min(dp[j])

　　反之，前面的人在第i个人吃完饭之前吃完
  
　　那么　　dp[j+a[i].x]=min(j+a[i].x+a[i].y)

　　因此状态转移方程(之一)为：
  
### dp[j+a[i].x]=min(dp[j+a[i].x],max(dp[j],j+a[i].x+a[i].y))；

## 若第i个人在二号打饭：

用sum[i]维护前i个人的打饭时间，那么sum[i]-j就表示前面所有人在2号打饭的时间
  
　　与上面相同的思路来进行分类讨论：

　　如果第i个人吃完，前j时间的人仍没有吃完
　　那么dp[j]不变。

　　反之，第i个人吃完之前前面j时间的人已经吃完了
　　那么dp[j]=(sum[i]-j)+a[i].y

　　因此状态转移方程(之一)为：
### dp[j]=max(dp[j],(sum[i]-j)+a[i].y)；

故第一重循环枚举n个同学，维护sum[i] 表示前i个同学打饭的时间和。

第二重循环逆枚举sum[i] (保证只有上一层状态转移来)

----
代码如下：
```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;

inline void read(int &a)
{
    a=0;int c=getchar();
    while(c>'9'||c<'0') c=getchar();
    while(c>='0'&&c<='9') a=(a<<3)+(a<<1)+c-48,c=getchar();
}

const int N=205;
int n,dp[N*N],sum[N],ans=0x7f7f7f7f;
struct node
{
    int x,y;
    bool operator<(const node b)const
    {
        return y>b.y;
    }
}a[N];

namespace chu_xuan
{
    void main()
    {
        read(n);
        for(int i=1;i<=n;i++)
        {
            read(a[i].x);
            read(a[i].y);
        }
        sort(a+1,a+1+n);
        memset(dp,0x3f,sizeof(dp));
        dp[0]=0;
        for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i].x;
        
        for(int i=1;i<=n;i++)
        {
            for(int j=sum[i-1];j>=0;j--)
            {
                dp[j+a[i].x]=min(dp[j+a[i].x],max(dp[j],j+a[i].x+a[i].y));
                dp[j]=max(dp[j],sum[i]-j+a[i].y);
            }
        }
        
        for(int i=1;i<=sum[n];i++)
        {
            ans=min(ans,dp[i]);
        }
        cout<<ans<<"\n";
    }
}

int main()
{
    chu_xuan::main();
    return 0;
}
```

---

## 作者：HeroOfJustice (赞：23)

水一波随机化~

首先排个序 吃饭时间长的人先打饭 然后随机一个方案 用f[i]的奇偶性表示排在不同的两个窗口

由于数据太水 两边排队的人数几乎相等 所以随机排列的长度只开到n+2就过了
如果有个毒瘤出题人造了一个1号窗口排1个人 2号窗口排199个人的数据 这个随机化就有接近100%的概率会TLE
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int maxn=205,up=1e7;

inline int read()
{
    char c=getchar();
    int x=0,f=1;
    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') {x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return x*f;
}

struct people
{
    int x,y;
}a[maxn];

int f[maxn];

bool cmp(people a,people b)
{
    return a.y>b.y;
}

int main()
{
    int n,i,j,lim,x,y,s1,s2,ans;
    n=read();
    for (i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
    for (i=1;i<=n+2;i++) f[i]=i; 
    sort(a+1,a+1+n,cmp);
    lim=up/n;ans=up;
    for (i=1;i<=lim;i++)
    {
        random_shuffle(f+1,f+3+n);
        s1=0;s2=0;x=0;y=0;
        for (j=1;j<=n;j++)
        {
            if (f[j]&1==1) 
            {
                s1+=a[j].x;
                x=max(x,s1+a[j].y);
            }
            else
            {
                s2+=a[j].x;
                y=max(y,s2+a[j].y);
            }
        }
        ans=min(ans,max(x,y));
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：TH讠NK (赞：20)

[题目传送门](https://www.luogu.org/problem/P2577)

首先很明显这是一道 $dp$ 题 ，但同时我们还要用到**贪心**的思想

看了看各位大佬的题解 ，都说是**吃得慢的人先打饭会更省时间** ，但是证明本蒟蒻没看懂 $($我太菜啦$QAQ)$ ，于是本蒟蒻在这里给出一个应该挺好懂的贪心证明

在看到这题时 ，我首先想到了[国王游戏](https://www.luogu.org/problem/P1080) ，我们完全可以用相同的思想进行证明

## 贪心证明

假设现在有**前后**两个人 $A_1,A_2$ ，我们要给他们两个排序使得总时间最小 ，设 $A_1$ 的打饭时间为 $a_1$， 吃饭时间为 $b_1$ ，$A_2$ 的打饭时间为 $a_2$， 吃饭时间为 $b_2$ ，当然这两个人前面可能还有人 ，设他们的总打饭时间为 $x$

当 $A_1$ 在前面时 ，$A_1$ 离开的时间为 $x+a_1+b_1$ ，$A_2$  离开的时间为 $x+a_1+a_2+b_2$ $($注意 $A_1,A_2$ 是前后两个人$)$ ，所以总时间为 $max(x+a_1+b_1,x+a_1+a_2+b_2)$

同理我们可以得到当 $A_2$ 在前面时总时间为  $max(x+a_2+b_2,x+a_2+a_1+b_1)$

若 $A_1$ 在前面更优 ，则有
$$max(x+a_1+b_1,x+a_1+a_2+b_2) \le max(x+a_2+b_2,x+a_2+a_1+b_1)$$

首先消掉左右都有的 $x$ ，得到

$$max(a_1+b_1,a_1+a_2+b_2) \le max(a_2+b_2,a_2+a_1+b_1)$$

由于不知道 $a_1,b_1,a_2,b_2$ 之间的大小关系 ，我们进行**分类讨论**

$1. \ b_1 \ge a_2+b_2$ ，则有 $a_1+b_1 \le a_2+a_1+b_1$ ，又得到 $0 \le a_2$ ，成立

$2. \ b_2 \le b_1 \le a_2+b_2$ ，则有 $a_1+a_2+b_2 \le a_2+a_1+b_1$ ，又得到 $b_2 \le b_1$ ，成立

$3. \ b_1 \le b_2 \le a_1+b_1$ ，则有 $a_1+a_2+b_2 \le a_2+a_1+b_1$ ，又得到 $b_2 \le b_1$ ，与条件矛盾 ，不成立

$4. \ b_2 \ge a_1+b_1$ ，则有 $a_1+a_2+b_2 \le a_2+b_2$ ，又得到 $a_1 \le 0$ ，显然不成立

根据分类讨论 ，我们发现原式成立时**总有** $b_1 \ge b_2$ ，所以  $max(a_1+b_1,a_1+a_2+b_2) \le max(a_2+b_2,a_2+a_1+b_1)$ 等价于 
 $b_1 \ge b_2$ 

$Q.E.D$

## $DP$ 实现

首先考虑怎么表示状态

第一维肯定是表示第几个人 ，再看看题目中有两个窗口 ，于是我们用 **$f[i][j][k]$ 表示前 $i$ 个人 ，在 $1$ 号窗口打饭的总时间为 $j$ ，在 $2$ 号窗口打饭的总时间为 $k$ 时 ，需要的最小的总时间**

~~状态可能有些复杂 ，多看几次就懂了~~

接着想状态怎么转移 ，显然每次状态转移有两种情况 ，第 $i$ 个人去 $1$ 号窗口打饭 ，或者第 $i$ 个人去 $2$ 号窗口打饭

**若第 $i$ 个人去 $1$ 号窗口打饭**

我一开始想到的转移方程是这个：

$$f[i][j][k]=min(f[i][j][k],f[i-1][j-a_i][k])$$

后来发现这是错的 ，因为不一定在 $f[i-1][j-a_i][k]$ 的时间内第 $i$ 个人也能吃完饭 ，稍加思索~~看题解~~后 ，我们得到新的转移方程:

$$f[i][j][k]=min(f[i][j][k],max(f[i-1][j-a_i][k],j+b_i))$$

这个方程的意思就是：如果在 $f[i-1][j-a_i][k]$ 的时间内第 $i$ 个人也能吃完饭 $(j+b_i$ 就是第 $i$ 个人吃完饭的时间$)$ ，那么就没有影响 ，否则总时间就要延长使得第 $i$ 个人也能吃完饭

**若第 $i$ 个人去 $2$ 号窗口打饭**

同理我们可以得到：

$$f[i][j][k]=min(f[i][j][k],max(f[i-1][j][k-a_i],k+b_i))$$

到这里 $dp$ 基本就设计完了 ，但我们又发现开三维的数组会 $MLE$ ，所以还得要把状态压成二维的

看看我们之前的状态设计 ，我们发现 ，**在 $1$ 号窗口打饭的总时间加上在 $2$ 号窗口打饭的总时间 ，恰好等于前 $i$ 个人打饭的总时间** ，所以就有 $j+k=\sum\limits_{x=1}^{i} a_x$

所以我们就可以把 $f[i][j][k]$ 给压成 $f[i][j]$ ，用 $f[i][j]$ **表示前 $i$ 个人 ，在 $1$ 号窗口打饭的总时间为 $j$ 时 ，需要的最小的总时间**

上面的状态转移方程也就变成了

$$f[i][j]=min(f[i][j],max(f[i-1][j-a_i],j+b_i))$$

$$f[i][j]=min(f[i][j],max(f[i-1][j],sum[i]-j+b_i))$$

至此 ，本题就被解决了 ，**完结撒花**

还有一些小细节见代码

$Talk \ is \ cheap.\ Show \ you \ the \ code.$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=205;
int ans=1<<30,n,s[maxn],f[maxn][maxn*maxn];
inline int read(){
	int x=0; char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0' && c<='9') x=x*10+c-48, c=getchar();
	return x;
}
struct person{
	int a,b;//a为打饭时间，b为吃饭时间 
	bool operator < (const person &x) const {return b>x.b;}
} p[maxn];
int main(){
	n=read();
	for(int i=1;i<=n;i++) p[i].a=read(), p[i].b=read();
	sort(p+1,p+n+1);
	for(int i=1;i<=n;i++) s[i]=s[i-1]+p[i].a;//维护一个打饭时间的前缀和 
	memset(f,0x3f,sizeof(f));//把f数组初始化为最大值 
	f[0][0]=0;//记得把f[0][0]设为0，不然后面就全炸了 
	for(int i=1;i<=n;i++)
		for(int j=0;j<=s[i];j++){
			if(j>=p[i].a) f[i][j]=min(f[i][j],max(f[i-1][j-p[i].a],j+p[i].b));//这里转移的时候要注意满足 j>=p[i].a
			f[i][j]=min(f[i][j],max(f[i-1][j],s[i]-j+p[i].b));//这里的 s[i]-j就是k 
		}
	for(int i=0;i<=s[n];i++) ans=min(ans,f[n][i]);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：maomao9173 (赞：17)

### 发一篇相对详细的思路解析。
### 首先需要证明这样一个东西：对于这个题来说，吃饭时间越长的，越应该先排队，任何不满足这个条件的前后交换都会使之不是最优。读者可以试着在纸上推一下，证明出这个这道题最主要的难点就解决了，接下来的思路就会变得非常清晰：

- 对吃饭时间从大到小排序，处理出DP应该进行的前后顺序 
- 用f[i][j]记录前i个人排队，第一队用时为j的情况下最大用时。不记录第2队状态的原因是可以由第一队状态推出来。为了便于计算，建议使用前缀和维护一下，可以较为简易的计算出第2队的情况。
- 那么我们就得到了这样两个方程：
	
   加入第一队的情况下：
   	f[i][j]=min(f[i][j],max(f[i-1][j-peo[i].w_1],j+peo[i].w_2));
    
    也就是：前i个人排队用时j的情况，由前i-1个人的最大用餐时间，与前i-1个人排队且第i个人加入第1队时第i个人总用餐时间取最大，再转移到f[i][j]上。
    
    第二队同理，给出公式，不再赘述。
    
    f[ni][j]=min(f[ni][j],max(f[li][j],tmp+peo[i].w_2));
    
- 注意最后取答案的时候要确认前n个人排两队的所有不同情况。

```cpp
#include<cstdio>
#include<cstring> 
#include<iostream>
#include<algorithm>
#define ni i%2
#define li !(i%2) 
using namespace std;
int n,ans=0x3f3f3f,sum[210],f[2][40010];
struct PEO{int w_1;int w_2;}peo[210];
bool cmp(const PEO &a,const PEO &b){return a.w_2>b.w_2;} 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&peo[i].w_1,&peo[i].w_2);
	//吃饭时间长的一定应该先打饭，但是排队方法可以不同，只有这样贪心才能保证最优解 
	sort(peo+1,peo+1+n,cmp);//从大到小排，保证最优解 
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+peo[i].w_1;//排队总时间成一个前缀和的形式，便于计算
	memset(f,0x3f,sizeof(f)); 
	f[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=sum[i];j>=0;j--)f[ni][j]=0x3f3f3f3f;//注意对 
		for(int j=sum[i];j>=0;j--){
			if(j>=peo[i].w_1){//队列1排队时间可用 
				f[ni][j]=min(f[ni][j],max(f[li][j-peo[i].w_1],j+peo[i].w_2));
				//当前最小时间为上一个人用的时间和这一个人用的时间的最大值 
			}
			int tmp=sum[i]-j;//表示队列2排队时间 
			if(tmp>=peo[i].w_1){
				f[ni][j]=min(f[ni][j],max(f[li][j],tmp+peo[i].w_2));
				//这里是加入队列2的情况，由于不对队列1造成影响所以j不变 
			} //注意这里的判断由于数据原因可能被忽视了，但实际上依然应该加上
			//至此也可以搞明白为什么要用从后面向前面找的方法转移 
		}
	}
//	for(int i=0;i<=sum[n];i++)printf("%d ",f[n%2][i]);printf("\n");
	for(int i=0;i<=sum[n];i++)ans=min(ans,f[n%2][i]);//这个记录的是排队情况 
	printf("%d",ans); 
	return 0; 
}
 
```

---

## 作者：wjyyy (赞：10)

   安利博客->[wjyyy](http://www.wjyyy.top/1711.html)

## 题解：

   首先这个题需要用贪心来将每个人排序，否则无法进行唯一的DP。但是贪心会有两个思路，分别是按**吃饭时间降序排序，和按打饭+吃饭时间之和降序排序**，因为我们要避免吃饭时间长的人后打饭。因此下面的证明只考虑这两种情况。

   设第$i$个人的打饭时间为$a_i$，吃饭时间为$b_i$，令$a_i+b_i>a_{i+1}+b_{i+1}$（如果小于的话当然要把既满足总时间长又满足吃饭时间长的人放在前面），**但$b_i<b_{i+1}$**，则$a_i>a_{i+1}$。即第$i+1$个人的吃饭时间较长。假设只有一列队，如果将$i$排在前面，那么总时间为$f_1=\max(a_i+b_i,a_i+a_{i+1}+b_{i+1})=a_i+a_{i+1}+b_{i+1}$，因为$a_i+b_{i+1}>a_i+b_i$。而将$i$排在后面，则总时间为$f_2=\max(a_{i+1}+a_i+b_i,a_{i+1}+b_{i+1})=a_{i+1}+a_i+b_i$ 。那我们比较$f_1$和$f_2$，$f_1-f_2=b_{i+1}-b_i>0$，因此$f_1>f_2$。**所以贪心的结论是把吃饭时间长的人排在前面。**

   这样可以先把每个人排序，然后就可以做一个类似背包的DP了。设f[i][j][k]表示排完了$i$个人，第一队**结束排队**时间为$j$，第二队结束时间为$k$的最早**吃完饭的时间**。这样直接做转移就可以了，$f[i][j][k]=\min(\max(f[i-1][j-a[i]][k],j+b[i]),\max(f[i-1][j][k-a[i]],k+b[i]))$。但是这样的时间复杂度是$O(n^5)$，因为状态共有$200\times 200^2\times 200^2$个。

   考虑到时间复杂度主要由状态个数贡献，因此考虑压维。我们看到，当贪心地排序后，序列是一定的。因此$j+k$也就成了定值，也就是说，我们在DP数组中存下$j$，利用预处理的前缀和$sum$减去这个$j$，就是所求的$k$了。这样状态就只剩下$n^3$，是可以过的，相应地改一下转移方程就可以了（把$k$代换为$sum[i]-j$即可）。

 

   这个题的主要思维在贪心。同时较难的地方还有压掉一维，不过见得多了也许就是一种套路了吧。

 

## Code：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using std::min;
using std::max;
struct pp
{
    int x,y;
    friend bool operator <(pp a,pp b)
    {
        return a.y>b.y;
    }
}a[222];
int f[205][40005];
int main()
{
    memset(f,0x3f,sizeof(f));
    f[0][0]=0;
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d%d",&a[i].x,&a[i].y);
    std::sort(a+1,a+1+n);
    int tt=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=0;j<=200*i;++j)
            if(j<a[i].x)
                f[i][j]=max(f[i-1][j],tt-j+a[i].x+a[i].y);
            else
                f[i][j]=min(max(f[i-1][j-a[i].x],j+a[i].y),max(f[i-1][j],tt-j+a[i].x+a[i].y));
        tt+=a[i].x;
    }
    long long ans=0x7ffffffffff;
    for(int i=0;i<=200*n;++i)
        ans=ans<f[n][i]?ans:f[n][i];
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：lover_ (赞：5)

在题解里逛了一圈，发现并没有dalao对本题第一步的贪心排序给出清晰的证明,可能是我太弱了2333，于是便过来水一发证明QAQ，虽然不一定更清晰但在很努力表达。。。就当练表达能力好了。。

代码其他dalao已经写得很清楚了就不给出了
~~（其实是我懒，我蠢，我不会）~~



------------
首先假设有两位童鞋在同一窗口排队（就叫CGL与YSD吧），第一位童鞋（CGL）打饭时间为A1，吃饭时间为B1。第二位童鞋（YSD）打饭时间为A2，吃饭时间为B2。由于第一位童鞋CGL饭量较大，所以吃饭时间长，于是我们不妨假设B1>B2；

如果第一位同学（CGL）排在前面，那么他们两人的吃饭总时间为①A1+max(A2+B2,B1)。如果交换一下两人的顺序让吃饭时间少的（YSD）排在前面，那么两人的吃饭总时间为②A2+max(B2,B1+A1)

由于B1>B2，那么对于情况②，显然时间为A2+B1+A1;

对于情况①分开讨论，时间有A1+B1,A1+A2+B2两种可能性，这两种情况都是比情况②用时更短的（B1>B2）

由此可知将吃饭时间长的CGL排在前面有更优解

将这些情况推广到整个序列是成立的，推广到两个序列自然成立，故我们可以先按吃饭时间长短排序

虽然在本题还要考虑到一些其他很玄学的求和，但这样证一下其实已经完全证明了其正确性23333

这是贪心算法的很经典的一种想法，像P1080[国王游戏](https://www.luogu.org/problem/P1080)  以及其变种P2123[皇后游戏](https://www.luogu.org/problem/P2123) 都是这种思想，有兴趣可以去尝试一下   ~~反正我没做因为要用高精好烦的~~

---

## 作者：king_more (赞：5)

这道题是一道贪心 + DP题

我们先来证明贪心（其实我也不会证明，说个简单但是无法科学的论证的方法（雾）

假设有两个人一个吃饭快一个吃饭慢，如果先让吃饭快的先打，打完后吃完的很快，和吃饭慢花的时间重叠部分就少，如果让吃饭慢的先打，吃饭快的时间就会有很多重叠在吃饭慢的时间里面，可以最大限度的节省时间

设f[i][j]表示前i个人在一号窗口用了j时间打饭的最小吃饭时间，用个sum前缀和数组维护前i个人盛饭的时间，sum[i] - j就可以表示二号窗口打饭的时间

先分成两种情况
在第一个窗口

分两种情况

1.如果这个人的吃饭时间可以被前一个人的吃饭时间给包括，就不计入影响

2.不能包括就计入影响

所以f[i][j] = min(f[i][j],max(f[i - 1][j - s[i].a],j + s[i].b))

f[i - 1][j - s[i].a]表示上一个人的吃饭时间

j + s[i].b表示所有人的盛饭时间加上这个人的吃饭时间

在第二个窗口

首先要和第一个窗口比，其次要和所有人的盛饭时间加上这个人的吃饭时间比

疑问 为什么这里不用判断是否包括

解答 因为在判断第一个窗口已经判断过，不用重复判断

f[i][j] = min(f[i][j],max(f[i - 1][j],sum[i] - j + s[i].b))

f[i - 1][j] 表示前i - 1个人在j窗口用的吃饭时间

sum[i] - j 表示第二个窗口的盛饭时间

sum[i] - j + s[i].b就是最多的吃饭时间

就是酱紫

不懂可以私聊我

上代码

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int M = 200;
int f[M + 5][M * M + 5];
struct finker{
	int a,b;
}s[M + 5];
bool cmp(finker x,finker y){
	return x.b > y.b;
}
int sum[M + 5];
int main(){
	int n;
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++){
		scanf("%d%d",&s[i].a,&s[i].b);
	}
	sort(s + 1,s + n + 1,cmp);
	memset(f,137 / 3,sizeof(f));
	for(int i = 1;i <= n;i ++){
		sum[i] = sum[i - 1] + s[i].a;
	}
	f[0][0] = 0;
	for(int i = 1;i <= n;i ++){
		for(int j = 0;j <= sum[i];j ++){
			if(j - s[i].a >= 0){
				f[i][j] = min(f[i][j],max(f[i - 1][j - s[i].a],j + s[i].b));
			}
			f[i][j] = min(f[i][j],max(f[i - 1][j],sum[i] - j + s[i].b));
		}
	}
	int ans = 0x7ffffff;
	for(int j = 0;j <= sum[n];j ++){
		ans = min(ans,f[n][j]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：mohei0 (赞：5)

# [ZJOI2005]午餐 解题报告
## 题意

[题面](https://www.luogu.org/problemnew/show/P2577)

有**两个**打饭窗口

给出 $n$ 个人的打饭时间 $a$ 、吃饭时间 $b$ ，这 $n$ 个人分成两队排队，求最后一个人吃完的最快时间。

$1\le\text{所有输入数据}\le 200$

## 思路

初看像贪心（[不知道为什么我突然想到这题排队接水](https://www.luogu.org/problemnew/show/P1223)），但贪着贪着就发现太贪了，贪心死（随便举例也可以发现）。

考虑部分分。

看到**两个**这个关键词，就让人思考两个与 $n$ 个之间的区别。

我第一个想到的是 $O(2^n)$ 的暴力，枚举每个人是哪一队的。

然后想到状态压缩dp，一看 $n$ 的范围，状圧死。

在考虑将人分到两队的过程。

在将某个人分到一队时，我们只关心这一队的等待打饭的时间，并不关心前面的人是谁，也不关心前面有多少人。

所以我们可以猜出一个dp， $f_{i,j,k}$ 表示考虑前 $i$ 个人，第1、2队的等待时间分别为 $j,k$ 时最后一个吃完的人时间最早的时刻。

可列出方程：

$$\large f_{i,\ j,\ k}=min(\left\{\begin{aligned}max(f_{i-1,\ j-a_i,\ k},\ j+b_i) \\max(f_{i-1,\ j,\ k-a_i},\ k+b_i) \\\end{aligned})\right.$$

这个方程很好地将加入两队的情况都考虑到了，如图：

![无标题.png](https://i.loli.net/2019/05/13/5cd94571e1d5238481.png)

但是这个dp还有一些小问题。

我们又发现，将队列中的人按任意顺序分配与答案有关系，即对 $man_1,man_2,man_3,man_4$ 进行dp的结果会不等于对 $man_2,man_1,man_4,man_3$ 进行dp的结果。

我们发现虽然有了队列的等待时间，但我们没有最小化每个人的等待时间+吃饭时间。这里稍微贪一下，当一个队伍的人确定时，显然吃饭时间长的要排在前面，如图，显然 $10$ 与 $5$ 调换顺序后更优（方格内字表示吃饭时间）：

![5cd94571e1d5238481.png](https://i.loli.net/2019/05/14/5cda87e9d58d977212.png)

所以我们在dp前就将人按吃饭时间从大到小排序一遍，再进行dp即可。

贪心证明如下：

$$\text{大条件}b_1>b_2 $$
$$\ $$
$$\text{队列为}a_1,a_2\text{时} $$
$$ans_1=max(a_1+b_1,a_1+a_2+b_2) $$
$$\text{队列为}a_2,a_1\text{时} $$
$$ans_2=max(a_2+b_2,a_1+a_2+b_1) $$
$$\ $$
$$\because a_1+a_2+b_2>a_2+b_2 $$
$$a_1+a_2+b_1>a_1+a_2+b_2 $$
$$\therefore a_1+a_2+b_1>a_1+a_2+b_2>a_2+b_2 $$
$$\therefore ans_2=a_1+a_2+b_1 $$
$$\text{又}\because a_1+a_2+b_1>a_1+b_1,$$
$$a_1+a_2+b_1>a_1+a_2+b_2 $$
$$\therefore ans_2>ans_1$$
$$\therefore \text{队列1比队列2优}$$

这样就证明了这个dp的正确性了。

但是现在还有一个问题，状态太大，时间的范围是 $200^2=40000$ ，状态有 $200\times 40000^2>1e11$ 个，显然炸了，而且炸了不止一点。

我们再看看 $\text{所有数据}\le200$ 这个诡异的数据范围。

根据常识，我们猜到正解的复杂度应该是 $O(n^3)$ ，那么我们往这个发现去优化dp，显然是要优化掉一个 $40000$ 的。

考虑状态的冗余，我首先想到的是利用刷表法，将时间状态变成与人数有关系的状态（摆渡车后遗症）。

但想了没多久，发现两个 $40000$ 的状态有重复，很多状态是无用的，我们发现只需要一队的等待时间，就可以推出另一队的等待时间。

因为在前 $i$ 个人中，两队的等待时间之和是相同的，既前 $i$ 个人的打饭时间之和。所以当其中一队的等待时间为 $x$ 时，另一对等待时间就是 $(\sum_{j=1}^ia_j)-x$ 。

那么我们就成功地压掉了一维，时间空间可过，结束。

方程用上面一个再推一次即可

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int s[207]={0},dp[207][40007]={0},n,minn=1e9;

struct node {
    int f,s;
}a[207];

bool cmp(const node &A, const node &B)
{
    return A.s>B.s;
}

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++){cin>>a[i].f>>a[i].s;}
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){s[i]=s[i-1]+a[i].f;}
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=40000;j++)
        {
            if(s[i]-j>=a[i].f) dp[i][j]=max(dp[i-1][j],s[i]-j+a[i].s);
            if(j-a[i].f>=0) dp[i][j]=min(dp[i][j],max(dp[i-1][j-a[i].f],j+a[i].s));
        }
    }
    for(int j=0;j<=40000;j++)
        minn=min(minn,dp[n][j]);
    cout<<minn;
}
```

---

## 作者：灵乌路空 (赞：3)

# 知识点: DP

[原题面](https://www.luogu.com.cn/problem/P2577)

---

## 分析题意

设第 $i$ 个人打饭时间，吃饭时间分别为 $a_i$ 与 $b_i$，前 $i$ 个人打饭时间总和为 $sum_i$。

先考虑 **只排一队** 的情况，对于一给定的队列完成的时间，有：  
$$time = \max_{i=1}^{n}\{sum_i+b_i\}$$  

---

考虑两个相邻的人 $i$ 与 $i+1$，若有 $b_{i+1} > b_i$：
- 当 $i+1$ 在后面时，两者完成时间分别为：
  $$\begin{aligned}
    & sum_{i-1} + (a_i + b_i)\\
    & sum_{i-1} + a_i + (a_{i+1}+b_{i+1})
  \end{aligned}$$   
  显然第 $i+1$ 个人一定后吃完，即有下式成立：  
  $$sum_{i-1} + a_i +(a_{i+1}+b_{i+1})> sum_{i-1} + (a_i + b_i)$$
  
- 当 $i+1$ 在前面时，完成时间分别为：  
  $$\begin{aligned} 
    & sum_{i-1}+ (a_{i+1} + b_{i+1})\\
    & sum_{i-1} + a_{i+1}+ (a_i + b_i)
  \end{aligned}$$  
  两人吃完的先后顺序不定。

显然有： 

$$\begin{aligned}
  & sum_{i-1} + a_i +(a_{i+1}+b_{i+1})> \\
& \max\{sum_{i-1}+ (a_{i+1} + b_{i+1}), sum_{i-1} + a_{i+1}+ (a_i + b_i)\}
\end{aligned}$$ 

---

则欲使 $\max\limits_{i=1}^{n}\{sum_i+b_i\}$ 尽可能小，令$i+1$ 排在前面更优。
感性理解一下，吃饭慢的放在前面一定更优。  

则可先将 $n$ 个人按照吃饭时间降序排序，逐个加入队列的人变成有序的了。  
可以考虑线性 DP 求解此题。

---

发现窗口二的队列，必定为窗口一的补集。 

设当前第 $i$ 个人加入队列，令窗口一队列 **打饭时间**总和为 $j$，则窗口二 **打饭时间** 总和为 $sum_i - j$。  

若已知 $j$，则可计算第 $i$ 个人加入窗口 一/二 的 **完成时间**。  
考虑枚举窗口一打饭时间总和 $j$，来更新答案。

---

设 $f_{i,j}$ 表示，前 $i$ 个人加入队列，窗口一队列打饭时间总和为 $j$时，两窗口的最小完成时间。

考虑第 $i$ 个人排到窗口 一/二：
1. 排到窗口一，则有：  
   $$f_{i,j} = \max\{j + b_i,\ f_{i-1,j-a_i}\}$$  
   $j + b_i$ 为新加入窗口一的人的完成时间。    
   $f_{i-1,j-a_i}$ 为：不加此人时，窗口一的完成时间 与 窗口二的完成时间 的最小值，用于更新答案，不会导致漏解。  
2. 排到窗口二，则有：  
   $$f_{i,j} = \max\{f_{i-1,j},\ sum_i-j+b_i\}$$  
   $sum_i-j+b_i$ 为新加入窗口二的人的完成时间。  
   $f_{i-1,j}$ 也为不加此人时，窗口一的完成时间 与 窗口二的完成时间 的最小值。  

上述两种情况取最小值即可。  
复杂度 $O(nT)$ ($T$ 为最大时间)，期望得分 $100\text{pts}$。

---

## 代码实现

```cpp
//知识点:DP
/*
By:Luckyblock
*/
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define min std::min
#define max std::max
#define ll long long
const int kMaxn = 210;
const int kInf = 1e9 + 2077;
//=============================================================
struct Data {
  int a, b;
} d[kMaxn];
int n, ans = kInf, sum[kMaxn], f[kMaxn][kMaxn * kMaxn];
//=============================================================
inline int read() {
  int f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
bool Compare(Data fir, Data sec) {
  return fir.b > sec.b;
}
//=============================================================
int main() {
  n = read();
  for (int i = 1; i <= n; ++ i) {
    d[i].a = read(), d[i].b = read();
  }
  std :: sort(d + 1, d + n + 1, Compare);
  memset(f, 63, sizeof(f));
  f[0][0] = 0;
  for (int i = 1; i <= n; ++ i) sum[i] = sum[i - 1] + d[i].a;
  for (int i = 1; i <= n; ++ i) {
    int a = d[i].a, b = d[i].b;
    for (int j = 1; j <= sum[i]; ++ j) {
      f[i][j] = max(f[i - 1][j], sum[i] - j + b);
      if (j - a >= 0) f[i][j] = min(f[i][j], max(f[i - 1][j - a], j + b));
    }
  }
  for (int i = 1; i <= sum[n]; ++ i) {
    ans = min(ans, f[n][i]);
  }
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：Time_Rune (赞：3)

比较麻烦的一道DP

想了很长时间，结合题解才勉强写出来

在这里分享一下解题报告，对DP的每个细节都有详细的注释,还没有弄明白的同学可以参考这一篇对状态转移的解释来解题

/*
【午餐】 解题报告

DP
关键是如何设计状态

性质1：贪心
这个比较容易证明
吃饭时间短的先打饭

但有一个地方很烦人

那就是**排队完成的时间与最终吃饭完成时间不一定是相同的**

考虑这么设计状态方程： 

f[i][j]表示前i个人，在队1一共花费了j的时间打饭所需要的时间

注意到**有两个时间**，第一个是**队1排队用的时间(状态)**

第二个是f[i][j]的值，也就是**总共需要的时间 (结果)**


性质2：每个人**在且仅在**一个队

注意到我们f内记录的j为当前排队使用的时间

而前i个人排队需要的总时间是不变的！！

所以说**知道了在队1排队的总时间，就相当于知道了在队2排队的总时间** 

这就是为什么可以优化一维，把队2的时间优化掉，从而保证空间不会爆炸

然后我们考虑转移

①：先枚举i还是先枚举j？
按照dp的基本思路，先枚举i
然后后续转移f[i][...]时用f[i-1][...]更新 

②：正着枚举还是反着枚举？
如果使用滚动数组优化的话，建议时间倒序枚举
因为每个人只可以使用一次
如果是f[i][j]就不需要考虑，因为每次都是在i-1上操作的 

③：初始化
f[0][0] = 0;其他的memset 0x3f

④：转移方程

（a[i]为打饭时间，b[i]为吃饭时间）

分为两种情况：扔进1队/扔进2队

如果这个i是由加入1队得到的，那么

**f[i][j] = min(f[i][j] ,  max(j+b[i],f[i-1][j-a[i]] ) ) ;** 

这个方程的意思：

min：在所有可以转移的值中取最小

max：计算时间，向队伍后面加入一个人，**总时间有两种情况**：

1.这个人的排队+吃饭时间加起来还没有之前 i-1 个人总共需要的时间长
(因为吃饭时间长的在前面，所以这种情况的很容易发生的)

2.与1相反，那么就用排队时间j和这个人吃饭的时间b[i]来更新ans 

扔进2队：

**f[i][j] = min(f[i][j] , max( (sum[i]-j)+b[i] , f[i-1][j] )**

大体上同1，但要注意**放进2队是对1队的时间没有影响的**

所以除了时间又j变成了（sum[i]-j) ,取max时的转移也又f[i-1][j-a[i]] 变为了 f[i-1][j]; 


*/


结合代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define il inline
#define rg register
#define N 210
using namespace std;

int f[N][N*N];

struct p{
	int x,y;
}a[N];

il bool cmp(p a,p b){
	return a.y>b.y;
}

int n;
int ans = 99999999;

int sum[N];

int main(){
	cin>>n;
	
	for(rg int i=1;i<=n;++i){
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	
	sort(a+1,a+n+1,cmp);
	
	for(rg int i=1;i<=n;++i){
		sum[i] = sum[i-1]+a[i].x;
	}
	
	memset(f,0x3f,sizeof(f));
	
	f[0][0] = 0;
	
	for(rg int i=1;i<=n;++i){
		for(rg int j=1;j<=sum[i];++j){
			if( j >= a[i].x)
			f[i][j] = min(f[i][j] , max( j+a[i].y, f[i-1][j-a[i].x] ) ) ; 
			f[i][j] = min(f[i][j] , max( (sum[i]-j)+a[i].y , f[i-1][j] ) ) ;
		}
	}
	
	for(rg int i=1;i<=sum[n];++i){
		ans = min(ans,f[n][i]);
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```

希望能帮到大家

如果还有什么细节不清楚可以直接在旁边留言或者私信交流

看见了一定会回复。

---

## 作者：I_AM_HelloWord (赞：3)

#### 一个简单的贪心+两个背包的dp问题。

#### 首先，因为一个物品加工完后就去冷却，所以我们在确定好物品分组后，把冷却时间长的先加工，一定会使结果更优。因为一个组内的物品所需的总加工时间是一定的。这是一个小小的贪心，我们开始的时候排下序就好了。

#### 我们可以考虑类比将一组数分成两组，然后使他们的和尽量地接近的思路【好吧，其实就是一样的】，我们可以设dp[i][j]表示前i个物品，分成两组，使得所需时间的差值为j的可行性（是否存在一种方案），转移就是：

#### dp[i][j]|=dp[i-1][j-a[i].w] | dp[i-1][j+a[i].w]，然后就把方案直接造出来，最后再加上冷却时间就行了。
#### 但是，比较繁琐，楼下几位的思路就显得比较好了。

#### 我们重新考虑一个dp，设dp[i][j]表示前i个物品，在第一个机器上用了了j的加工时间所能得到的最小总时间（这时已经加上了冷却时间）。

#### 考虑一下转移，就是类似一个01背包，这时不是01，而是在两个包中，看看是10，还是01了【手动滑稽】

#### dp[i][j]=min( max(dp[i-1][j-a[i].w],j+a[i].v) )这时把物品放到第一个包中，比较一下1号机器所需的时间，和没加之前二号机器所需的时间的最大值就是当前的总时间。

#### dp[i][j]=min( max(dp[i-1][j],sum[i]-j+a[i].v) )这时把物品放到第2个背包中，sum[i]就表示前i个物品所需的加工总时间（注意，没有算上冷却时间），显然，我们在1号机器加工了j的时间，那么就肯定在2号机器加工了sum[i]-j的时间，原理和上面的类似。


#### 考虑一下精辟的优化:滚动数组【手动滑稽】

#### 参考代码:

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define re register 
#define REP(i,a,b) for (re int i=(a);i<=(b);i++)
#define DREP(i,a,b) for (re int i=(b);i>=(a);i--)
using namespace std;
template<class T>inline void ChkMin(T &a,T b){if (b<a)a=b;}
const int INF=0x3f3f3f3f;
const int N=205;
struct Goods{
    int w,v;
    inline bool operator < (const Goods &rhs) const{
        return v>rhs.v;
    }
}a[N];
int n,d[N],dp[2][N*N];
int main(){
    scanf("%d",&n);
    REP(i,1,n)scanf("%d%d",&a[i].w,&a[i].v);
    sort(a+1,a+n+1);
    REP(i,1,n)d[i]=d[i-1]+a[i].w;
    memset(dp[0],0x3f,sizeof(dp[0]));
    dp[0][0]=0;
    REP(i,1,n){
        re int cur=i&1,pre=cur^1;
        memset(dp[cur],0x3f,sizeof(dp[cur]));
        DREP(j,0,d[i]){
            if (j>=a[i].w)
                ChkMin(dp[cur][j],max(dp[pre][j-a[i].w],j+a[i].v));
            if (d[i]-j>=a[i].w)
                ChkMin(dp[cur][j],max(dp[pre][j],d[i]-j+a[i].v));
        }
    }
    re int res=INF;
    REP(i,0,d[n])ChkMin(res,dp[n&1][i]);
    printf("%d",res);
    return 0;
}
```
最后，Orz楼下dalao


---

## 作者：ljk123 (赞：2)

# 午餐题解

贪心+dp

1.贪心：

不妨取任意两人i,j，则：

打饭时间为：

$\sum_{k=1}^{i-1}a_{k}+a_{i}+b_{i},$

$\sum_{k=1}^{i-1}a_{k}+a_{i}+\sum_{k=i+1}^{j-1}a_{k}+a_{j}+b_{j}$

互换后打饭时间为：

$\sum_{k=1}^{i-1}a_{k}+a_{j}+b_{j},$

$\sum_{k=1}^{i-1}a_{k}+a_{j}+\sum_{k=i+1}^{j-1}a_{k}+a_{i}+b_{i}$

显然：$\sum_{k=1}^{i-1}a_{k}+a_{j}+\sum_{k=i+1}^{j-1}a_{k}+a_{i}+b_{i}>\sum_{k=1}^{i-1}a_{k}+a_{i}+b_{i},$

$\sum_{k=1}^{i-1}a_{k}+a_{i}+\sum_{k=i+1}^{j-1}a_{k}+a_{j}+b_{j}>\sum_{k=1}^{i-1}a_{k}+a_{j}+b_{j},$

则：比较 

$max(\sum_{k=1}^{i-1}a_{k}+a_{i}+b_{i},\sum_{k=1}^{i-1}a_{k}+a_{i}+\sum_{k=i+1}^{j-1}a_{k}+a_{j}+b_{j})$和$max(\sum_{k=1}^{i-1}a_{k}+a_{j}+b_{j},\sum_{k=1}^{i-1}a_{k}+a_{j}+\sum_{k=i+1}^{j-1}a_{k}+a_{i}+b_{i})$

即为比较：

$\sum_{k=1}^{i-1}a_{k}+a_{i}+\sum_{k=i+1}^{j-1}a_{k}+a_{j}+b_{j}$

和$\sum_{k=1}^{i-1}a_{k}+a_{j}+\sum_{k=i+1}^{j-1}a_{k}+a_{i}+b_{i}$

两者之间只有$b$不同，故在越后面，b应越小，

将含$a,b$的结构体按$b$从大到小排序。

2.dp:

设数组$f[i][j]$表示到了第i个人,在第一窗口花了j时间的最小的最长时间：
```cpp
for(int i=1;i<=n;++i){
        sum+=x[i].a;
        for(int j=0;j<=sum;++j){
            f[i][j]=max(f[i-1][j],sum-j+x[i].b);
            //若第二个人选择二号窗口，一号窗口的最长时间为f[i-1][j],之后第二窗口的最长时间为：sum-j+x[i].b(等到第i个人的时间总和不变)
            if(j>=x[i].a) f[i][j]=min(f[i][j],max(j+x[i].b,f[i-1][j-x[i].a]));
            //选一号窗口，第i个人的花费时间为j+x[i].b,前i-1个人花费的最长时间为f[i-1][j-x[i].a]
        }
}
```

总代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=206;
int n,f[N][N*N+N],sum=0,ans=1e9;
struct xd{int a,b;}x[N];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
bool cmp(xd u,xd v){return u.b>v.b;}
int main(){
    n=read();
    for(int i=1;i<=n;++i) x[i].a=read(),x[i].b=read();
    sort(x+1,x+n+1,cmp),memset(f,0x7f,sizeof(f));
    f[0][0]=0;
    for(int i=1;i<=n;++i){
        sum+=x[i].a;
        for(int j=0;j<=sum;++j){
            f[i][j]=max(f[i-1][j],sum-j+x[i].b);
            if(j>=x[i].a) f[i][j]=min(f[i][j],max(j+x[i].b,f[i-1][j-x[i].a]));
        }
    }
    for(int i=0;i<=sum;++i) ans=min(ans,f[n][i]);
    printf("%d\n",ans);
    return 0;
}  
```





---

## 作者：Sym_Je (赞：2)

      这是道贪心加dp的题   
      
  首先我们可以发现，最好是让吃饭时间长的先去，所以我们先排序来保证答案的正确性，然后我们就可以去找转移方程，这里最好转移的就是时间咯，所以dp[i][j]，表示到i个人第一个窗口用了j分钟的最优解。      
  如果放在第一个 dp[i][j]=min(dp[i][j],max(dp[i-1][j-t[i].cf],j+t[i].b))      
  先看没加他之间的最短时间，然后与加上他吃饭的总时间比较，取大的。   
  放在第二个也同理    
  
  
  ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int dp[201][50001];//qian i ren diyige j time

struct node
{
	int df,cf;//cf:chifan df:dafan
}t[210];

int n;

bool cmp(node a,node b)
{
	return a.cf>b.cf;
}

int sum[50001];

int main()
{
	scanf("%d",&n);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&t[i].df,&t[i].cf);
	}
	sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+t[i].df;前缀和维护总时间，好求出第二个的用时
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=sum[i];j++)
		{
			if(j>=t[i].df)
			{
				dp[i][j]=min(dp[i][j],max(dp[i-1][j-t[i].df],j+t[i].cf));
			}
			dp[i][j]=min(dp[i][j],max(dp[i-1][j],sum[i]-j+t[i].cf));
		}
	}
	int ans=50000001;
	for(int i=1;i<=sum[n];i++)
	{
		ans=min(ans,dp[n][i]);
	}
	printf("%d",ans);
	return 0;
}

```

---

## 作者：Fzun1ltgk8JtJT (赞：1)

#### 虽然有大佬写了一波随机化，但是没人写模拟退火，这里给出一个模拟退火的解法。
#### 当两个队列中的人固定时，则可以通过调整法证明以下贪心策略：
#### 如果x排在y之前，则要满足：
$A_{x}+max(B_{x},A_{y}+B_{y}) < A_{y}+max(B_{y},A_{x}+B_{x}) $
#### 因此只要随机生成出每个人属于哪个队列，贪心算出最少时间即可。
#### 以下是AC代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <ctime>
const int MAXN = 205;
struct person{
	int a, b;
	int q;
} p[MAXN];
bool cmp(person x, person y){
	return x.a + std::max(x.b, y.a + y.b) < y.a + std::max(y.b, x.a + x.b);
}
int n;
int ans;
int calc(){
	int t[2] = {0, 0};
	int ans_t[2] = {0, 0};
	for(int i = 1; i <= n; ++i){
		int qq = p[i].q;
		t[qq] += p[i].a;
		ans_t[qq] = std::max(ans_t[qq], t[qq] + p[i].b);
	}
	return std::max(ans_t[0], ans_t[1]);
}
void SA(){
	double t = 200;
	while(t > 1e-8){
		int tx = rand() % n + 1;
		p[tx].q ^= 1;
		int newans = calc();
		int DE = newans - ans;
		if(DE < 0){
			//接受
			ans = newans;
		}else if(exp(-DE/t) * RAND_MAX > rand()){
			//接受
		}else{
			p[tx].q ^= 1;
		}
		t *= 0.99;
	}
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i){
		scanf("%d%d", &p[i].a, &p[i].b);
		p[i].q = 0;
	}
	std::sort(p + 1, p + 1 + n, cmp);
	ans = calc();
	while(clock() < 0.7 * CLOCKS_PER_SEC)SA();
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：bzy369258147 (赞：1)

题目乍一看好像很简单，仔细想了一下发现吃饭的过程非常的讨嫌，用机房某大佬的话说就是决策会有后效性，而没有吃饭这个过程，这就是一个背包的水题了.

但是有后效性的决策有着一个很经典的套路，那就是反着思考决策过程，即我们可以考虑**先吃饭再排队**，就可以有效的解决后效性的问题，其实然后做法就跟背包差不多。

再最开始给吃饭保留时间禁止转移，每个点转移从排队结束到排队开始的过程是在左队列还是在右队列进行的.很容易想到最后面进入队列的是当前队列吃饭时间最短的，否则可以重新排序构造更优的解.所以离线人的信息，按吃饭时间从小到大排序(因为我们是倒过来考虑的.

$dp[i]$表示左边从结束到最开始的用时为$i$的右边队列的最少用时，每次转移分两种情况

1. 将当前人放入左队列的最前面,则必须时间从他开始吃饭时开始转移，枚举他从哪个时间进入左队列，为了防止单次迭代问题，应该反过来dp.转移方程:
$$dp[i]=dp[i-now.x](i >= now.x + now.y )$$
P.S now表示当前人，x为排队时间,y表示吃饭时间
2. 将当前人放入右队列的最前面，由于保证吃饭时间，右队列的用时即dp值必须要大于吃饭时间，所以我们如下转移
$$dp[i] = max( dp[i],now.y ) + now.x(i >= now.y) $$

然后就可以扫一遍求出每一个左队列的时间与对应的右队列的最小时间中的最大值的最小值即可

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;

int dp[40005];

struct node{
    int x,y;
    void get(){ cin >> x >> y ; }
    bool operator <(const node From) const {
        return y < From.y;
    }
}ele;
vector<node>Line;

int main(){
    int n;cin >> n;
    for(int i = 1;i <= n;i ++)ele.get(),Line.push_back(ele);
    sort( Line.begin(),Line.end() );
    for( auto now : Line ){
        for(int i = 40000;i >= now.y + now.x;i --){
            dp[i] = min( dp[i - now.x],max( dp[i],now.y) + now.x);
        }
        for(int i = now.x;i < now.x + now.y;i ++ ){
            dp[i] = max( dp[i],now.y) + now.x;
        }
        for(int i = 0;i < now.x;i ++)dp[i] = 1e9;
    }
    int ans = 1e9;
    for(int i = Line[0].y;i <= 40000;i ++)ans = min( ans,max( i,dp[i] ) );
    if( ans >= 1000 and ans % 10 == 6 )cout << ans - 3;
    else cout << ans;
    return 0;
}
```

---

## 作者：stdlifg (赞：1)

# 思路
## 一个队伍
```	
    首先来考虑只有一个队伍的情况
	思路1：
		当只有一个队伍的时候
		因为所有人都一定要打饭
		所以总的打饭时间是一样的
		所以我们就需要尽量把吃饭时间长的往前放
		因为迟早要吃，吃饭时间长的往后放肯定不会更优
	思路2：	
		刘汝佳 蓝书第2页的《突击战》便是一个非常好的例子
		对于两个相邻两个人XY不难发现交换之后对其它任务完成时间无影响
		因为两个人的吃饭时间总和是一定的
		那么我们就可以进行分类讨论
		假设X的吃饭时间比Y长,交换之前X在Y前
		#case1：交换前Y比X先结束
			那么此时交换无疑是把X结束的时间往后再延长
		#case2：交换前X比Y先结束
			交换前的总时间=XY打饭总时间+Y吃饭时间
			交换后的总时间=XY打饭总时间+X吃饭时间
			根据假设，得出交换前的总时间<交换后的总时间
	所以，只有一个队伍的问题用贪心解决
```
## 两个队伍
```
	有两个队伍的问题可以由只有一个队伍的问题衍生而来
	我们限制一下两队打饭时间即可
	f[i][j] 表示到了第i个人，第1个队打饭时间为j,两队 用时最长的那个人 的用时 的最小值
	每一个人有两种选择
	1.加入到第一队
		因为到他的时候第一队已经打了j分钟饭了
		所以他总时间就是 j+吃饭时间+打饭时间
		如果这个时间比 第一队用时最长的人晚就可以更新答案了
	2.加入到第二队
		因为加到第二队，所以对第一队没有影响
		所以j是不要变化的
		因为第一队的打饭时间为j 所以第二队的打饭时间为当前所有人的打饭时间-第一队打饭时间
		然后就跟加入到第一队是一样的
```
# 代码
```cpp
	f[0][0]=0;
    for(int i=0; i<n; i++) {
        for(int j=0; j<=sum[i]; j++) {
            if(f[i][j]==inf)continue;
            f[i+1][j+a[i+1].w]=min(f[i+1][j+a[i+1].w],max(j+a[i+1].w+a[i+1].val,f[i][j])); // 加到第一队
            f[i+1][j]=min(f[i+1][j],max(f[i][j],a[i+1].val+sum[i]-j+a[i+1].w));  // 加到第二队
        }
    }
	```	

---

## 作者：Mistletoes (赞：0)

**首先若只有一个窗口，利用贪心，按吃饭时间从大到小排序即可**

正确性证明：

定义 eat[i] = 第i个人的吃饭时间，time[i] = 第i个人的打饭时间

延长时间T[i]=max(eat[i]-  $\sum\limits_{j=i+1}^ntime_j$ ,0)

最后的集合时间为$\sum\limits_{j=1}^ntime_j$ + max{T[i] , i∈[1,N]}

将人按照eat大小从大到小排序后，易证

此时max{T[i] , i∈[1,N]}最小，而$\sum\limits_{j=1}^ntime_j$为定值，

所以将人按照eat大小从大到小排序后，最后集合时间最短

也可以结合图理解一下：
![](https://phantomagony.github.io/2018/08/21/ZJOI2005-%E5%8D%88%E9%A4%90%EF%BC%88dp%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89/1.png)
图中蓝色是打饭时间，绿色是吃饭时间

易得答案是所有打饭时间之和（定值）加上虚线右边支出来的一截的最大长度，

所以我们要尽量让支出来的长度小

因为吃饭时间长的就更容易支出去，理所当然的应该尽可能往前放，所以将人按吃饭时间从大到小排序

**拓展到两个窗口，人们排队的顺序仍然要满足吃饭慢的先打饭，问题是怎么分队，不难想到dp：**

定义 dp[i][j][k] 表示

前i个人，在1号窗口打饭总时间j，在2号窗口打饭总时间k，最早吃完饭的时间

然后分别讨论将第i个人放在1号窗口和将第i个人放在2号窗口的情况即可

**但这样明显内存会爆炸，所以我们考虑优化一下空间**

仔细一想，发现可以去掉一维

因为 j+k=前i个人打饭时间总和，为定值，

所以 k 可以用 前i个人打饭时间总和-j 表示，不需要再单独维护这一维

因此，dp[i][j] 表示前i个人，在1号窗口打饭总时间j，最早吃完饭的时间
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=210;
struct node{
	int a,b;
}s[N];
bool cmp(node x,node y){
	return x.b>y.b;
}
int n,sum[N],dp[N][N*N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&s[i].a,&s[i].b);
	sort(s+1,s+n+1,cmp);
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+s[i].a;
	memset(dp,127,sizeof(dp));
	dp[0][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=sum[i];j++){
			if(j>=s[i].a) dp[i][j]=min(dp[i][j],max(dp[i-1][j-s[i].a],j+s[i].b));
			dp[i][j]=min(dp[i][j],max(dp[i-1][j],sum[i]-j+s[i].b));
		}
	}
	int ans=2147483647;
	for(int i=0;i<=sum[n];i++)
		ans=min(ans,dp[n][i]);
	printf("%d\n",ans);
	return 0;
}
```
参考博客：

https://www.luogu.org/blog/davidblog/solution-p2577
https://phantomagony.github.io/2018/08/21/ZJOI2005-%E5%8D%88%E9%A4%90%EF%BC%88dp%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89/

图片转自：
https://phantomagony.github.io/2018/08/21/ZJOI2005-%E5%8D%88%E9%A4%90%EF%BC%88dp%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89/
		

---

## 作者：liunian (赞：0)

## **做题随感**

1. 首先，由于要求所有人打完餐的最早时间点，因此想到用**贪心**思想。


2. 其次，~~这道题很神奇~~，每个人的打饭时间竟然是不同的。


3. 再者，每个人还有一个吃饭所需要的时间，~~这个能理解~~，但是吃饭跟排队没有半毛钱关系。。。。。。

## **思路**

```
struct node {
	int t1,t2;
} a[maxn];
```


 因此得出贪心思想，将吃饭时间长的排在前面：

1. 结构体如下：

```
bool cmp(node a,node b) {
	return a.t2>b.t2;
}
```


2. 然后就需要用到**DP**了，首先不难想到dp[ i ][ j ][ k ]来表示前i个人在第1队列中的总时间j，在第2队列的总时间k,但是数组开不下，那必须做一些巧妙的改动了。
   
   dp[ i ][ j ]表示在第1队列的总时间j的最少用餐时间，由于我    们知道人数和第1队列所需要的时间，就能得出第2队列所需的时间。


3. 我们不难想到**01背包**问题（~~貌似是假的~~），于是就得出了状态转移方程


```
for(int i=1; i<=n; i++)
	for(int j=sum[i]; j>=0; j--) {
		if(j>=a[i].t1)now=min(now,max(dp[i-1][j-a[i].t1],j+a[i].t2));
		now=min(now,max(res,sum[i]-j+a[i].t2));
		}
```

我看了许多大佬的题解，第二层循环是正搜的，但我觉得**倒搜**更符合背包的特性。

最后，提醒大家dp数组的第二维一定要开 200 X 200 ，因为其含义是总时间。

--------

#### 贴代码：

```
#define de puts("#")
#define bug(x) cout<<#x<<" : "<<x<<endl
#define cha1 printf("L : %d,R : %d,x : %d,l : %d,r : %d,rt : %d\n",L,R,x,l,r,rt)
#define cha2 printf("L : %d,R : %d,l : %d,r : %d,rt : %d\n",L,R,l,r,rt)
#define lcha1 printf("L : %lld,R : %lld,x : %lld,l : %lld,r : %lld,rt : %lld\n",L,R,x,l,r,rt)
#define lcha2 printf("L : %lld,R : %lld,l : %lld,r : %lld,rt : %lld\n",L,R,l,r,rt)
#define huge(n,m,a) for(int i=1; i<=n; i++) {for(int j=1; j<=m; j++)printf("%d ",a[i][j]);puts("");}puts("")
#define lhuge(n,m,a) for(int i=1; i<=n; i++) {for(int j=1; j<=m; j++)printf("%lld ",a[i][j]);puts("");}puts("")
#define lowbit(x) (x&(-x))
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#define res dp[i-1][j]
#define now dp[i][j]
using namespace std;
const int maxn=2e2+5;
const int maxm=0x3f3f3f3f;
struct node {
	int t1,t2;
} a[maxn];
int dp[maxn][maxn*maxn];
int sum[maxn];

bool cmp(node a,node b) {
	return a.t2>b.t2;
}

int main() {
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; i++)scanf("%d %d",&a[i].t1,&a[i].t2);
	sort(a+1,a+n+1,cmp);
	for(int i=1; i<=n; i++)sum[i]=sum[i-1]+a[i].t1;
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int i=1; i<=n; i++)
		for(int j=sum[i]; j>=0; j--) {
			if(j>=a[i].t1)now=min(now,max(dp[i-1][j-a[i].t1],j+a[i].t2));
			now=min(now,max(res,sum[i]-j+a[i].t2));
		}
	int ans=maxm;
	for(int i=0; i<=sum[n]; i++)ans=min(ans,dp[n][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：大菜鸡fks (赞：0)

这题的关键就是想到贪心思路：吃饭时间越长的先吃

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm> 
using namespace std;
const int N=205,INF=1e9;
struct node{
	int x,y;
}a[N];
int n;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
inline void init(){
	n=read();
	for (int i=1;i<=n;i++) {
		a[i]=(node){read(),read()};
	}
}
inline bool cmp(node A,node B){
	return A.y>B.y;
} 
int sum[N],dp[N][N*N];
inline void solve(){
	sort(a+1,a+1+n,cmp);
	for (int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i].x;
	memset(dp,127/3,sizeof (dp));
	dp[0][0]=0;
	for (int i=1;i<=n;i++){
		for (int j=0;j<=sum[i];j++){
			if (j>=a[i].x) dp[i][j]=min(dp[i][j],max(dp[i-1][j-a[i].x],j+a[i].y));
			dp[i][j]=min(dp[i][j],max(dp[i-1][j],sum[i]-j+a[i].y));
		}
	}
	int ans=INF;
	for (int i=0;i<=sum[n];i++){
		ans=min(ans,dp[n][i]);
	}
	writeln(ans);
}
int main(){
	init(); solve();
	return 0;
} 
```

---

## 作者：Mathison (赞：0)

一个排队问题

很容易想到贪心：**吃得慢的人先打饭会更省时间**

所以我们先按照吃饭时间由大到小排序
```
struct node{int t1,t2;} a[N];
bool cmp(node a,node b) {return a.t2>b.t2;}
```
然后我们考虑转移

能想到一种三维转移方程

用$f[i][j][k]$表示前$i$个人在$1$窗口的总时间为$j$，在$2$窗口的总时间为$k$时最小的吃完饭时间

转移方程：

$$f[i][j][k]=min\begin{cases}f[i][j][k]\\max(f[i-1][j][k-a[i].t1],k+a[i].t2)\\max(f[i-1][j-a[i].t1][k],j+a[i].t2)\end{cases}$$

```
#include<bits/stdc++.h>
using namespace std;
int n,f[201][500][500],s[201],ans=1e9;
struct node{int t1,t2;} a[201];
bool cmp(node a,node b) {return a.t2>b.t2;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&a[i].t1,&a[i].t2);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i].t1;
    memset(f,127,sizeof f);
    f[0][0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=s[i];j>=0;j--)
            for(int k=s[i];k>=0;k--)
                f[i][j][k]=min(f[i][j][k],min(max(f[i-1][j][k-a[i].t1],k+a[i].t2),max(f[i-1][j-a[i].t1][k],j+a[i].t2)));
    for(int i=0;i<=s[n];i++) 
	    for(int j=0;j<=s[n];j++)
		    ans=min(ans,f[n][i][j]);
    printf("%d\n",ans);
    return 0;
}

```

想想都MLE……

但是之后发现$j,k$之间是有关系的:$s[i]=j+k$

所以$k=s[i]-j$

这样$k$就不需要用一个维度维护，转移方程可以降到二维

$f[i][j]$表示前$i$个人，在$1$号窗口打饭总时间 $j$ 时的最早吃完饭的时间

转移方程

$$f[i][j][k]=min\begin{cases}f[i][j][k]\\max(f[i-1][j-a[i].t1],j+a[i].t2)\\max(f[i-1][j],k+a[i].t2)\end{cases}$$

### AC Code:
```
#include<bits/stdc++.h>
using namespace std;
const int N = 210;
int n,f[N][N*N],s[N],ans=1e9;
struct node{int t1,t2;} a[N];
bool cmp(node a,node b) {return a.t2>b.t2;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d %d",&a[i].t1,&a[i].t2);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) s[i]=s[i-1]+a[i].t1;
    memset(f,127,sizeof f);
    f[0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=s[i];j>=0;j--)
        {
        	int k=s[i]-j;
            if(j>=a[i].t1) f[i][j]=min(f[i][j],max(f[i-1][j-a[i].t1],j+a[i].t2));
            f[i][j]=min(f[i][j],max(f[i-1][j],k+a[i].t2));
        }
    for(int i=0;i<=s[n];i++) ans=min(ans,f[n][i]);
    printf("%d\n",ans);
    return 0;
}
```

已经AC了

当然我们还可以降维（但是我之前没写出来……看了题解才明白……）

```
#include<bits/stdc++.h>
using namespace std;
struct node{int t1,t2;} a[1000];
int n,f[400001],sum,ans=1e9,s[1000];
bool cmp(node a,node b) {return a.t2>b.t2;}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&a[i].t1,&a[i].t2);
    sort(a+1,a+n+1,cmp);
	memset(f,127,sizeof f);f[0]=0;
    for(int i=1;i<=n;i++) s[i]=a[i].t1+s[i-1];
    for(int i=1;i<=n;i++)
        for(int j=s[i];j>=0;j--)
        {
            f[j+a[i].t1]=min(f[j+a[i].t1],max(f[j],a[i].t2+j+a[i].t1));
            f[j]=max(f[j],a[i].t2+s[i]-j);
        }
    for(int i=1;i<=s[n];i++) ans=min(ans,f[i]);
    printf("%d",ans);
}
```

---

## 作者：cdcq (赞：0)

这个题意看上去就有让人想贪心的欲望啊  
那不妨先来玩一下，不难发现，b值大的一定要排在前面打饭  
在说明贪心为什么是对的之前，我们需要注意到一条很重要的特殊性：  
在做高考物理题的时候，一个很重要的思路是注意什么是守恒的  
首先可以大胆猜测，如果上面的贪心是对的话，这题的决策很可能只需要考虑第i个人应该排在哪一队  
现在研究在一个队伍里的人有什么性质  
可以发现道题里也有一个不变量，就是对于队伍里的前i个人，不管他们排队的顺序如何，a[i]的前缀和s[i]是不会变的，第i个人会在s[i]+b[i]时刻吃完，这前i个人的吃饭时间是max{s[j]+b[j]}  
现在可以回到贪心的问题上了，假设对于两个相邻的人i和i+1，如果a[i]==a[i+1]，那么显然让b[i]>b[i+1]好  
由上面的性质可以看到s[i]是守恒的，那么让第i个人的b[i]是前i个人里最小的当然就是坠吼的啦  
明确了这个贪心策略之后，现在需要考虑的是按b排序后，第i个人要放在哪一队  
开始设计状态，首先阶段基本确定是以每一个人为阶段，状态的话，我一开始想的是f[i][j][k]表示第i个人，一队a的和是j，二队a的和是k，但是s[i]最高可能是40000，这个方案不可行  
这里再次使用上面的性质（特殊性在OI题里是多么重要呀~  
在每一队里a[i]的前缀和是守恒的，两队的前i个人的a[i]加起来也是守恒的，所以实际上只需要记录j就可以了，k可以计算得到  
（注意这里s[i]不再是指每一队的前缀和，而是所有人里的前缀和  
状态转移方程就很容易写出来了：  
$$ f[i][j]=min\{max\{f[i-1][j-a[i]],j+b[i]\},max\{f[i-1][j],s[i]-j+b[i]\}\} $$  
其中f[i-1][j-a[i]]表示上一个状态的最优值，j+b[i]表示第i个人在这个状态下的值，两个值比较后送到当前状态更新，第二个max同理  
代码非常好实现，没有什么坑，又1A了好开心啊~  
代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int rd(){int z=0,mk=1;  char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')mk=-1;  ch=getchar();}
	while(ch>='0'&&ch<='9'){z=(z<<3)+(z<<1)+ch-'0';  ch=getchar();}
	return z*mk;
}
struct nds{int x,y;}a[210];
int n;
int s[210];
int f[210][41000];
//f[i][j]=min{max{f[i-1][j-a[i]],j+b[i]},max{f[i-1][j],s[i]-j+b[i]}}
bool cmp(nds x,nds y){  return x.y==y.y ? x.x>y.x : x.y>y.y;}
int main(){freopen("ddd.in","r",stdin);  //freopen("ddd.out","w",stdout);
	memset(f,10,sizeof(f));
	cin>>n;
	//for(int i=1;i<=n;++i)  a[i].x=rd(),a[i].y=rd(),s[i]=s[i-1]+a[i].x;//注意不能在这里求s
	for(int i=1;i<=n;++i)  a[i].x=rd(),a[i].y=rd();
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)  s[i]=s[i-1]+a[i].x;
	f[0][0]=0;
	for(int i=1;i<=n;++i){
		for(int j=s[i];j>=0;--j){
			if(j>=a[i].x)  f[i][j]=min(f[i][j],max(f[i-1][j-a[i].x],j+a[i].y));
			f[i][j]=min(f[i][j],max(f[i-1][j],s[i]-j+a[i].y));
			//if(f[i][j]==168430090)  cout<<"oo ";
			//else  cout<<f[i][j]<<" ";
		}
		//cout<<endl;
	}
	int ans=999999999;
	for(int i=0;i<=s[n];++i)  ans=min(ans,f[n][i]);
	cout<<ans<<endl;
	return 0;
}


```

---

## 作者：破壁人 (赞：0)

这就是一个类似0/1背包的DP

f[i][j]表示前i个人用j的时间打饭，且第i个人在一号窗口打饭所用的最短时间。

g[i][j]表示前i个人用j的时间打饭，且第i个人在二号窗口打饭所用的最短时间。

观察到第i个人吃完饭所用的时间就是前i个人打饭的总是间加第i个人的吃饭时间，因此可以预处理出前缀和。

然后就可以转移状态了。

f[i][j]=min(max(f[i-1][j-a[i]],j+b[i]),max(g[i-1][j-a[i]],j+b[i]));（注意要j>a[i]）

g[i][j]=min(max(f[i-1][j],sum[i]-j+b[i]),max(g[i-1][j],sum[i]-j+b[i]));

当然了，这样DP是不能涵盖到所有情况的，那么加一维再DP？这样时间上是不允许的。

其实我们可以结合贪心来DP

观察到，要使所有人吃完饭的时间最短，就要使吃饭越慢的人越先打饭。

那么按打饭时间排序之后再按上述方法DP就可以完美解决问题啦。





```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int a[201],b[201],sum[201],f[201][40001],g[201][40001];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++)
            if((b[i]<b[j])||(b[i]==b[j])&&(a[i]<a[j]))
            {
                int t;
                t=a[i];a[i]=a[j];a[j]=t;
                t=b[i];b[i]=b[j];b[j]=t;
            }
    for(int i=1;i<=n;i++) sum[i]=sum[i-1]+a[i];
    memset(f,27,sizeof(f));
    memset(g,27,sizeof(g));
    f[0][0]=0;g[0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=sum[i];j++)
        {
            if(j>=a[i]) 
                f[i][j]=min(max(f[i-1][j-a[i]],j+b[i]),max(g[i-1][j-a[i]],j+b[i]));
            g[i][j]=min(max(f[i-1][j],sum[i]-j+b[i]),max(g[i-1][j],sum[i]-j+b[i]));
        }
    int ans=1000000000;
    for(int i=0;i<=sum[n];i++)
        ans=min(min(ans,f[n][i]),g[n][i]);
    cout<<ans<<endl;
}
```

---

## 作者：CalvinJin (赞：0)

本题可以用根据冷却时间的顺序先进行一步贪心，再DP，保证得到最优值

f[i,j]代表共加工了前i个产品，1号机器加工使用j单位时间，得到的最小完成时间

状态转移方程f[i,j]:=max{j+b[i],f[i-1,j-a[i]],c[i]-j+b[i],f[i-1,j]} c代表前i个产品的总加工时间 当然还要注意判断能否取到j-a[i]和c[i]-j

pascal代码如下

```pascal
var a,b,c:array[1..200] of longint; f:array[0..200,0..40000] of longint;
    i,j,n,ans:longint;
function min(x,y:longint):longint;
begin
  if x>y then exit(y) else exit(x);
end;
function max(x,y:longint):longint;
begin
  if x>y then exit(x) else exit(y);
end;
procedure sort;
var i,j,x:longint;
begin
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if (b[i]<b[j]) or ((b[i]=b[j]) and (a[i]<a[j])) then
      begin
        x:=a[i]; a[i]:=a[j]; a[j]:=x;
        x:=b[i]; b[i]:=b[j]; b[j]:=x;
      end;
end;
begin
  filldword(f,sizeof(f)>>2,maxlongint>>1); f[0,0]:=0; ans:=maxlongint;//初始化
  readln(n);
  for i:=1 to n do read(a[i],b[i]);
  sort;//排序

  c[1]:=a[1];
  for i:=2 to n do c[i]:=c[i-1]+a[i];

  for i:=1 to n do     //前i个产品
    for j:=0 to c[i] do//1号机器加工用了j时间
    begin
      if j>=a[i] then                                         //判断是否可以用1号机器加工
        f[i,j]:=min(f[i,j],max(j+b[i],f[i-1,j-a[i]]));  //用的时间可能是上一次加工得到的，或是这一次加工更新得到的
      if c[i]-j>=a[i] then                                  //判断是否可以用2号机器加工
        f[i,j]:=min(f[i,j],max(c[i]-j+b[i],f[i-1,j])); //同上
      if i=n then ans:=min(ans,f[i,j]);//得到加工完后时间的最小值
    end;

  writeln(ans);
end.
```

---

## 作者：ICEMAGE (赞：0)

看到没有题解，就加一种思路。

可以先用一步贪心，去把所有产品按冷却时间降序排列。

然后去dp一下，分四种情况：

1.加到第一条，没有影响

2.加到第一条，有影响

3.加到第二条，没有影响

4.加到第二条，有影响


---


# [ZJOI2006] 三色二叉树

## 题目描述

一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：

$$S=
\begin{cases}
0& \text表示该树没有子节点\\
1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\
2S_1S_2& 表示该树由两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列
\end{cases}$$

例如，下图所表示的二叉树可以用二叉树序列 $S=\texttt{21200110}$ 来表示。

![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)

你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq |s| \leq 5 \times 10^5$，$s$ 中只含字符 `0` `1` `2`。

## 样例 #1

### 输入

```
1122002010```

### 输出

```
5 2```

# 题解

## 作者：hs_black (赞：95)

介绍一个无建树做法

#### 个人认为我的代码比较易懂(~~简直不需要注释~~)

定义dp\[x][0/1/2] 分别为x节点染绿 /红 /蓝 情况下子树中最多有几个点被染成绿色

类似的 f\[x][0/1/2] 为最少有几个点

见代码:

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 500050;
char s[N];
int dp[N][4], f[N][4], cnt;
int ans1 = 1;
void dfs(int x) {
	if (s[x] == '0') {//叶节点
		f[x][0] = dp[x][0] = 1;
		return;
	}
	dfs(++cnt);
    //左儿子编号为x+1
	if (s[x] == '1') { //一个儿子
		dp[x][0] = max(dp[x+1][1], dp[x+1][2])+1;
		dp[x][1] = max(dp[x+1][0], dp[x+1][2]);
		dp[x][2] = max(dp[x+1][0], dp[x+1][1]);
        	//儿子染另外一种颜色
		// 上方代码完全是复制一遍到下面
		f[x][0] = min(f[x+1][1], f[x+1][2])+1;
		f[x][1] = min(f[x+1][0], f[x+1][2]);
		f[x][2] = min(f[x+1][0], f[x+1][1]);
	}
	else {
        //右儿子编号为k
		int k = ++cnt;
		dfs(k);
		dp[x][0] = max(dp[x+1][1] + dp[k][2], dp[x+1][2] + dp[k][1]) + 1;
		dp[x][1] = max(dp[x+1][0] + dp[k][2], dp[x+1][2] + dp[k][0]);
		dp[x][2] = max(dp[x+1][0] + dp[k][1], dp[x+1][1] + dp[k][0]);
		
		f[x][0] = min(f[x+1][1] + f[k][2], f[x+1][2] + f[k][1]) + 1;
		f[x][1] = min(f[x+1][0] + f[k][2], f[x+1][2] + f[k][0]);
		f[x][2] = min(f[x+1][0] + f[k][1], f[x+1][1] + f[k][0]);
	}
	ans1 = max(ans1, dp[x][0]);
}
int main() {
	scanf ("%s", s + 1);
	dfs(++cnt);
	cout << ans1 << ' ' << min(f[1][0], min(f[1][1], f[1][2])) << endl;
	return 0;
}
```



---

## 作者：Fading (赞：47)

upd in 3.25 因大佬要求修了一下$\LaTeX$。

## 大佬们dp方程没解释清楚啊...

我的 dp 也是递推实现的，~~不像大佬们那样用树上dfs~~


------------


### 首先是建树。

这个树是递归定义的，所以考虑用dfs建树。

就说样例吧。

$1122002010$

邻接表什么都不存在的！因为是二叉树，所以我们用邻接矩阵会更方便一些。

```
设tree[i][0] 为第i个节点的左节点编号
设tree[i][1] 为第i个节点的右节点编号

void dfs(int root){//root表示几号节点
    tot++;//表示总共访问了几个节点。
    if (s[root]=='0') return;//叶子节点退出
    if (s[root]=='1') {
        tree[root][0]=root+1;//下一个访问的节点的编号一定是这个节点编号+1
        dfs(root+1);//向下搜
    }
    if (s[root]=='2') {
        tree[root][0]=root+1;
        dfs(root+1);
        tree[root][1]=tot+1;//右节点一定是总共访问的编号+1
        dfs(tot+1);
    }
}
```
### 然后推导 dp 方程
先求最大值。这种染色问题比较恶心。在 dp 的过程中，
我们不知道它的左右结点是否染了绿色，

因此 dp 出来的结果会有问题？？？

### 所以我们可以考虑记录一下dp的状态。

这种方法是我从 P1352 没有上司的舞会中学到的，大家可以看看。

设$f_{i,0}$表示 第$i$个点，不染绿色，其子树（包括自己）染成绿色的最大值。

设$f_{i,1}$表示 第$i$个点，染绿色，其子树（包括自己）染成绿色的最大值。

那么，首先，第i个点若染绿色，那么其左右节点都不能染绿色。所以考虑把左右节点不染绿色的状态值相加，便得到了结果。

那么$f_{i,1}=f_{\text{tree}_{i,0},0}+f_{\text{tree}_{i,1},0}$

若这个点不染绿色呢？

我们会想，这个点不染绿色，那么由题意，它的左右节点不可以同时染绿色，
枚举两节点染色情况就可以了。

我们求的是最大值，那么$f_{i,0}$就是

$\max($左节点染绿色的值+右节点不染绿色的值,
左节点染绿色的值+右节点不染绿色的值,左节点不染绿色的值+右节点不染绿色的值$)$

问题解决了，那么最小值也一样。撒花！！！

......有这么轻松？？？

### 这道题的坑点来了，对于第i个节点不染绿色的情况，不存在两个节点都不染绿色的情况。

为什么？？？

如果第$i$个点以及其子节点都不染绿色，那么，这三个点只能染上红、蓝两色。

然而根据抽屉原理，三个点染上两种颜色，一定有两个点的颜色相同！！！

所以，不符合题意！这就是为什么叫**三色**二叉树。

#### 最后开始 dp

为什么要用 dfs ？

由于对于一棵子树，其编号排序一定为 **根节点<左节点<右节点**

所以我们用递推。

从节点数开始倒推就可以了。

```
for (int i=n;i>=1;i--){
    f[i][1]=f[tree[i][0]][0]+f[tree[i][1]][0]+1;
    f[i][0]=max(f[tree[i][0]][1]+f[tree[i][1]][0],f[tree[i][0]][0]+f[tree[i][1]][1]);
}
printf("%d ",max(f[1][1],f[1][0]));//最后我们只要比较一下，树根染和不染的答案哪个更优
for (int i=n;i>=1;i--){
    f[i][1]=f[tree[i][0]][0]+f[tree[i][1]][0]+1;
    f[i][0]=min(f[tree[i][0]][1]+f[tree[i][1]][0],f[tree[i][0]][0]+f[tree[i][1]][1]);
}
printf("%d",min(f[1][1],f[1][0]));//最后我们只要比较一下，树根染和不染的答案哪个更优
```
## 真·撒花

---

## 作者：消失的海岸线 (赞：34)

**在此给出一个相对较简的实现**

人话题意：递归地给出一棵二叉树，节点的颜色可以是0,1,2，父子节点、兄弟节点间的颜色不同，求最多（最少）可以有多少个点为0色。

朴素的树形dp，读入数据是比较麻烦的。

可以发现实际上只有绿和不为绿两种状态，最大/最小做两遍即可，在此以最大为例：

以 $f_{i}$ 表示点 $i$ 为绿色时最多有多少点可以为绿，$g_{i}$ 表示点 $i$ 不为绿色时最多多少点可以为绿。

转移是这样的，设当前节点为 $i$ ，若为绿色，则子节点必须非绿。若不为绿色，则从两个儿子分别一绿一不绿的状态取 $max$ 转移而来。

代码如下：

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <algorithm>
#define N 500010 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
char str[N];
int n,cnt,ch[N][2];
int f[N],g[N],root;
void build(int &x)
{
    x=++cnt;
    int opt=str[cnt]-'0';
    if(opt==0)return ;
    if(opt==1)build(ch[x][1]);
    if(opt==2)build(ch[x][1]),build(ch[x][2]);
}
int main()
{
    scanf("%s",str+1);
    n=strlen(str+1);
    build(root);
    for(int i=n;i>=1;i--)
    {
        f[i]=g[ch[i][1]]+g[ch[i][2]]+1;
        g[i]=max(f[ch[i][1]]+g[ch[i][2]],f[ch[i][2]]+g[ch[i][1]]);
    }
    printf("%d ",max(f[1],g[1]));
    for(int i=n;i>=1;i--)
    {
        f[i]=g[ch[i][1]]+g[ch[i][2]]+1;
        g[i]=min(f[ch[i][1]]+g[ch[i][2]],f[ch[i][2]]+g[ch[i][1]]);
    }
    printf("%d",min(f[1],g[1]));
    return 0;
}
```

---

## 作者：lxy__ (赞：22)

## $\mathscr{SOLUTIOH}$

这里是建树 + 递归的题解...其实也并不长...

设 $\mathrm{f[i][0/1/2]}$ 表示第 $i$ 个节点染成 （绿 / 红 / 蓝） 时，它为根的子树中最多有多少绿色节点；$\mathrm{g[i][0/1/2]}$ 表示最少

如果 $i$ 节点有两个儿子，两个儿子都不能与它染色相同，且两个儿子之间染色也不相同，所以两个儿子会分别拿走剩下的两种颜色：

```cpp
f[x][0] = max(f[son1][1] + f[son2][2], f[son1][2] + f[son2][1]) + 1; //绿色+1
f[x][1] = max(f[son1][0] + f[son2][2], f[son1][2] + f[son2][0]);
f[x][2] = max(f[son1][0] + f[son2][1], f[son1][1] + f[son2][0]);
g[x][0] = min(g[son1][1] + g[son2][2], g[son1][2] + g[son2][1]) + 1;
g[x][1] = min(g[son1][0] + g[son2][2], g[son1][2] + g[son2][0]);
g[x][2] = min(g[son1][0] + g[son2][1], g[son1][1] + g[son2][0]);
```
如果 $i$ 节点只有一个儿子，这个儿子只要不与 $i$ 染色相同即可；初始化另一个儿子 ( $0$ ) 的 $\mathrm{f,g}$ 值为 $0$，像上面这样写不会影响结果

更新父节点需要知道子节点的值，可以在树上递归

## $\mathscr{CODE}$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

const int N = 1000000;
int n, ch[N][2], f[N][3], g[N][3], tot = 0;
string a;

int build()
{
	int now = ++tot; //新建节点编号
	if(a[now - 1] == '2') ch[now][0] = build(), ch[now][1] = build();
	else if(a[now - 1] == '1') ch[now][0] = build();
	return now; //返回节点编号
}

void dfs(int x)
{
	int l = ch[x][0], r = ch[x][1];
	if(l) dfs(l); if(r) dfs(r); //递归两个儿子
    if(!l && !r) //叶子节点初始化
    	f[x][0] = g[x][0] = 1, f[x][1] = f[x][2] = g[x][1] = g[x][2] = 0;
	//转移方程
	f[x][0] = max(f[l][1] + f[r][2], f[l][2] + f[r][1]) + 1;
	f[x][1] = max(f[l][0] + f[r][2], f[l][2] + f[r][0]);
	f[x][2] = max(f[l][0] + f[r][1], f[l][1] + f[r][0]);
	g[x][0] = min(g[l][1] + g[r][2], g[l][2] + g[r][1]) + 1;
	g[x][1] = min(g[l][0] + g[r][2], g[l][2] + g[r][0]);
	g[x][2] = min(g[l][0] + g[r][1], g[l][1] + g[r][0]);
}

int main()
{
	cin >> a; n = a.size(); //树的节点数等于字符串长度
	memset(ch, 0, sizeof(ch)); //若一个节点没有该儿子，这个位置的编号为0
	f[0][0] = f[0][1] = f[0][2] = 0; //初始化编号为0的节点
	dfs(build());
	printf("%d", max(f[1][0], max(f[1][1], f[1][2]))); //三种染色取最大值
	printf(" %d", min(g[1][0], min(g[1][1], g[1][2]))); //三种染色取最小值
	return 0;
} 
```

---

## 作者：brealid (赞：13)

首先说一句，本人代码实现比较模块化，标准化，这导致了代码较长，所以如果需要看代码的请耐心 ![](https://cdn.luogu.com.cn/upload/pic/1436.png)

好吧，那我们就开始了

### Menu
1. 思路解析
2. 分模块实现  
	2.1. 建树  
    2.2. DP  
3. 附注  
	3.1. 易错点   
    3.2. 我的调试信息   
    3.3. 优化
4. 代码

### 1. 思路解析

首先，这道题的输入要求你能掌握建树基本技巧（dfs建树）

其次，看到题目的描述，可以猜到需要用DP；而明显，这道题也符合最优子结构

为了方便，笔者使用了树上DP

因为习惯，笔者用了指针（求轻虐）![](https://cdn.luogu.com.cn/upload/pic/36960.png)

### 2. 分模块实现

#### 2.1. 建树

这一块，个人认为是比较简单的，可以结合代码~~感性~~理解下

#### 2.2. DP  

Step 1: 执行孩子的 DP  
Step 2: 获取答案（DP转移方程）

结合记录答案的 ``struct`` 理解：
```
struct record_DP {
    int R, G, B;
    // object's name : my color
    // object's value : max/min count(color-green)
} maxx, minn;
```
$maxx.R = max(lc->maxx.G + rc->maxx.B, lc->maxx.B + rc->maxx.G);$  
$maxx.G = max(lc->maxx.R + rc->maxx.B, lc->maxx.B + rc->maxx.R) + 1;$  
$maxx.B = max(lc->maxx.R + rc->maxx.G, lc->maxx.G + rc->maxx.R);$  
$minn.R = min(lc->minn.G + rc->minn.B, lc->minn.B + rc->minn.G);$  
$minn.G = min(lc->minn.R + rc->minn.B, lc->minn.B + rc->minn.R) + 1;$  
$minn.B = min(lc->minn.R + rc->minn.G, lc->minn.G + rc->minn.R);$  

### 3. 附注 

#### 3.1. 易错点

因为我用的是指针，所以……注意**野指针**

#### 3.2. 我的调试信息 

在代码前面加上一行
```cpp
#define DEBUG
```
就可以看到我的调试信息。

个人认为还是比较好康的。  
![](https://cdn.luogu.com.cn/upload/pic/10566.png)

另外还有一些用注释的语句，没事干可以开，但没有什么用。

#### 3.3. 优化

请结合我下面的代码：

我的DP过程中 ``struct record_DP`` 里面的两个成员 ``R`` 和 ``B`` 的值永远一样，所以没必要

### 4. 代码
```cpp
/*************************************
 * problem:      P2585 [ZJOI2006]三色二叉树.
 * user ID:      63720.
 * user name:    Jomoo.
 * time:         2019-06-01.
 * language:     C++.
 * upload place: Luogu.
*************************************/ 

#include <bits/stdc++.h>
using namespace std;

template <typename Int>
inline Int read()       
{
    Int flag = 1;
    char c = getchar();
    while ((!isdigit(c)) && c != '-') c = getchar();
    if (c == '-') flag = -1, c = getchar();
    Int init = c & 15;
    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);
	return init * flag;
}

template <typename Int>
inline void write(Int x)
{
    if (x < 0) putchar('-'), x = ~x + 1;
    if (x > 9) write(x / 10);
    putchar((x % 10) | 48);
}  

template <typename Int>
inline void write(Int x, char nextch)
{
    write(x);
    putchar(nextch);
}  

void backspace()
{
    printf("\b \b");
}

#ifdef DEBUG
#include <windows.h>
#endif

struct Tree_OP {
    struct Tro_tree {
        struct record_DP {
            int R, G, B;
            // object's name : my color
            // object's value : max/min count(color-green)
        } maxx, minn;
        Tro_tree *lc, *rc;

        Tro_tree() 
        {
            maxx.R = maxx.G = maxx.B = 0;
            minn.R = minn.G = minn.B = 0;
            lc = rc = NULL;
        }

        #ifdef DEBUG
        void pushup(int depth)
        #else
        void pushup()
        #endif
        {
            if (lc && rc) {
                #ifdef DEBUG
                lc->pushup(depth + 1);
                rc->pushup(depth + 1);
                #else
                lc->pushup();
                rc->pushup();
                #endif
                maxx.R = max(lc->maxx.G + rc->maxx.B, lc->maxx.B + rc->maxx.G);
                maxx.G = max(lc->maxx.R + rc->maxx.B, lc->maxx.B + rc->maxx.R) + 1;
                maxx.B = max(lc->maxx.R + rc->maxx.G, lc->maxx.G + rc->maxx.R);
                minn.R = min(lc->minn.G + rc->minn.B, lc->minn.B + rc->minn.G);
                minn.G = min(lc->minn.R + rc->minn.B, lc->minn.B + rc->minn.R) + 1;
                minn.B = min(lc->minn.R + rc->minn.G, lc->minn.G + rc->minn.R);
            } else if (lc) {
                #ifdef DEBUG
                lc->pushup(depth + 1);
                #else
                lc->pushup();
                #endif
                maxx.R = max(lc->maxx.G, lc->maxx.B);
                maxx.G = max(lc->maxx.R, lc->maxx.B) + 1;
                maxx.B = max(lc->maxx.R, lc->maxx.G);
                minn.R = min(lc->minn.G, lc->minn.B);
                minn.G = min(lc->minn.R, lc->minn.B) + 1;
                minn.B = min(lc->minn.R, lc->minn.G);
            } else {
                maxx.R = 0;
                maxx.G = 1;
                maxx.B = 0;
                minn.R = 0;
                minn.G = 1;
                minn.B = 0;
            }
            #ifdef DEBUG
            while (depth--) {
                if (depth) {
                    putchar(' ');
                    putchar(' ');
                } else {
                    putchar('|');
                    putchar('-');
                }
            }
            printf("max{%d, %d, %d}, min{%d, %d, %d}.\n", maxx.R, maxx.G, maxx.B, minn.R, minn.G, minn.B);
            #endif
        }

        int getMax()
        {
            return max(max(maxx.R, maxx.G), maxx.B);
        }

        int getMin()
        {
            return min(min(minn.R, minn.G), minn.B);
        }
    } *root;

    int buildPos;
    string tro;

    void basic_dfsBuild(Tro_tree *fa)
    {
        // printf("[dfs %c]", tro[buildPos]);
        // Sleep(800);
        switch (tro[buildPos]) {
            case '2' :
                buildPos++;
                fa->lc = new Tro_tree();
                basic_dfsBuild(fa->lc);
                buildPos++;
                fa->rc = new Tro_tree();
                basic_dfsBuild(fa->rc);
                break;
            case '1' :
                buildPos++;
                fa->lc = new Tro_tree();
                basic_dfsBuild(fa->lc);
                break;
            case '0' :
                break;
            default :
                printf("ERR!");
                exit(EXIT_FAILURE);
                break;
        }
        // backspace();
        // backspace();
        // backspace();
        // backspace();
        // backspace();
        // backspace();
        // backspace();
        // Sleep(800);
    }

    void readIn()
    {
        cin >> tro;
    }

    void build()
    {
        buildPos = 0;
        root = new Tro_tree();
        basic_dfsBuild(root);
        #ifdef DEBUG
        putchar(10);
        #endif
    }
    
    void solve()
    {
        #ifdef DEBUG
        root->pushup(0);
        #else
        root->pushup();
        #endif
        write(root->getMax(), 32);
        write(root->getMin(), 10);
    }
} td;

int main()
{
    td.readIn();
    td.build();
    td.solve();
    return EXIT_SUCCESS;
}
```
![](https://cdn.luogu.com.cn/upload/pic/40753.png)![](https://cdn.luogu.com.cn/upload/pic/40753.png)![](https://cdn.luogu.com.cn/upload/pic/40753.png)

---

## 作者：lemir3 (赞：4)

[*获得更差的阅读体验*](https://www.lemir3.red/2019/11/29/Project2585-ZJOI2006-%E4%B8%89%E8%89%B2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A5%E4%BD%9C%E6%8A%A5%E5%91%8A/)

## 题目分析

先用一个递归输入树.

设计状态$f_{i,1/2/3}$,表示子树以i为根,被染成红色/绿色/蓝色时的最大值,最小值同理.

根据i节点的儿子数量进行转移.

## 代码

```cpp
#include "chtholly.h"
#define lxl long long
#define R register
#define INF 2147483647
#define debug(x) printf("debug:%lld\n",x)
using namespace std;
const lxl maxn=500010;
lxl cnt=1,ESize;
lxl head[maxn],f[maxn][4],g[maxn][4],size[maxn];
char c;
struct _Edge
{
	lxl to,next;
}e[maxn<<1];
inline lxl read() {char c=getchar(); lxl f=1,x=0; for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1); for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48); return f*x; }
inline void EdgeAdd(lxl from,lxl to) {e[ESize].to=to; e[ESize].next=head[from]; head[from]=ESize++; }
void prework(lxl now,lxl ch)
{
	size[now]=ch;
	char c_;
	for(R lxl i=1;i<=ch;++i)
	{
		cin>>c_;
		EdgeAdd(now,++cnt);
		prework(cnt,c_-'0');
	}
}
void dfs(lxl from)
{
	if(size[from]==0)
	{
		f[from][1]=0,g[from][1]=0;
		f[from][2]=0,g[from][2]=0;
		f[from][3]=1,g[from][3]=1;
	}
	if(size[from]==1)
	{
		lxl to=e[head[from]].to;
		dfs(to);
		f[from][1]=max(f[to][2],f[to][3]);
		f[from][2]=max(f[to][1],f[to][3]);
		f[from][3]=max(f[to][1],f[to][2])+1;
		g[from][1]=min(g[to][2],g[to][3]);
		g[from][2]=min(g[to][1],g[to][3]);
		g[from][3]=min(g[to][1],g[to][2])+1;
	}
	if(size[from]==2)
	{
		lxl to1=e[head[from]].to,to2=e[e[head[from]].next].to;
		dfs(to1),dfs(to2);
		f[from][1]=max(f[to1][2]+f[to2][3],f[to1][3]+f[to2][2]);
		f[from][2]=max(f[to1][1]+f[to2][3],f[to1][3]+f[to2][1]);
		f[from][3]=max(f[to1][1]+f[to2][2],f[to1][2]+f[to2][1])+1;
		g[from][1]=min(g[to1][2]+g[to2][3],g[to1][3]+g[to2][2]);
		g[from][2]=min(g[to1][1]+g[to2][3],g[to1][3]+g[to2][1]);
		g[from][3]=min(g[to1][1]+g[to2][2],g[to1][2]+g[to2][1])+1;
	}
}
int main(void)
{
	memset(head,-1,sizeof(head)),memset(g,0x3f,sizeof(g));
	cin>>c;
	prework(1,c-'0');
	dfs(1);
	printf("%lld %lld\n",max(f[1][1],max(f[1][2],f[1][3])),min(g[1][1],min(g[1][2],g[1][3])));
	return 0;
}
```

---

## 作者：封禁用户 (赞：4)

此题我用了一个十分暴力且疯狂的方法，就是开6个记搜的dfs：节点选红可以获得的最小值minr，节点选红可以获得的最大值maxr，节点选蓝可以获得的最小值minb，节点选蓝可以获得的最大值maxb，节点选绿可以获得的最小值ming，节点选绿可以获得的最大值maxg。并且记搜时对这个点的孩子的颜色进行讨论，我们以一棵“200”二叉树选最大值为例（一个根节点两个孩子）：首先我们讨论根节点取绿的情况，求这个根节点的maxg：很显然这个节点选了绿那么孩子只能选蓝或红，那么就再分情况讨论：左蓝右红与左红右蓝，那么就分别求出他们的maxb和maxr，看哪种组合的和最大，最终把最大的和加上一（因为根结点选了绿，自己要算上）就是根节点的maxg。同理，其他几个dfs也能这样不断地分情况讨论。这个方法看似暴力，不过毕竟用了记搜，会省掉不少时间。

代码如下：

```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    typedef struct _n{
        int number;  //节点编号
        _n* left;    //左孩子
        _n* right;   //右孩子
    }node;   //节点
    int reddfs(node* tree);
    int bluedfs(node* tree);
    int greendfs(node* tree);   //3个求最大值的dfs
    int mreddfs(node* tree);
    int mgreendfs(node* tree);
    int mbluedfs(node* tree);   //3个求最小值的dfs
    int fmaxgreen[500001];
    unsigned char bg[500001];
    int fmaxred[500001];
    unsigned char br[500001];
    int fmaxblue[500001];
    unsigned char bb[500001];
    int fmingreen[500001];
    unsigned char mbg[500001];
    int fminred[500001];
    unsigned char mbr[500001];
    int fminblue[500001];
    unsigned char mbb[500001];    //以上12个数组记录搜索结果
    int reddfs(node* tree){//用于求节点选红时可以获得的最大值
    //这里就以这一个dfs为例，其他5个dfs的原理与此相同
        if(br[tree->number]){
            return(fmaxred[tree->number]);
            //搜过就直接返回记忆的结果
        }
        br[tree->number]=1;
        int sum=0;
        if(tree->right!=NULL){//有两个孩子
        //因为父亲选了红，所以孩子只能选绿或蓝
            int a=greendfs(tree->right);
            int b=bluedfs(tree->left);
            //讨论左蓝右绿的情况
            int c=greendfs(tree->left);
            int d=bluedfs(tree->right);
            //讨论左绿右蓝的情况
            sum=max(a+b,c+d);//取两种情况的最大值
        }
        else{
            if(tree->left!=NULL){//有一个孩子
                int a=greendfs(tree->left);
                //讨论这个孩子为绿的情况
                int b=bluedfs(tree->left);
                //讨论这个孩子为蓝的情况
                sum=max(a,b);//取两种情况的最大值
```
}//要是没有孩子的话就不用讨论了
```cpp
        }
        fmaxred[tree->number]=sum;//记录结果
        return(sum);
    }
    int bluedfs(node* tree){
        if(bb[tree->number]){
            return(fmaxblue[tree->number]);
        }
        bb[tree->number]=1;
        int sum=0;
        if(tree->right!=NULL){
            int a=greendfs(tree->right);
            int b=reddfs(tree->left);
            int c=greendfs(tree->left);
            int d=reddfs(tree->right);
            sum=max(a+b,c+d);
        }
        else{
            if(tree->left!=NULL){
                int a=greendfs(tree->left);
                int b=reddfs(tree->left);
                sum=max(a,b);
            }
        }
        fmaxblue[tree->number]=sum;
        return(sum);
    }
    int greendfs(node* tree){
        if(bg[tree->number]){
            return(fmaxgreen[tree->number]);
        }
        bg[tree->number]=1;
        int sum=0;
        if(tree->right!=NULL){
            int a=bluedfs(tree->right);
            int b=reddfs(tree->left);
            int c=bluedfs(tree->left);
            int d=reddfs(tree->right);
            sum=max(a+b,c+d);
        }
        else{
            if(tree->left!=NULL){
                int a=bluedfs(tree->left);
                int b=reddfs(tree->left);
                sum=max(a,b);
            }
        }
        fmaxgreen[tree->number]=sum+1;//这里要注意，因为根结点选了绿，所以在结果中要算上根节点的绿色，即sum+1
        return(sum+1);
    }
    int mreddfs(node* tree){
        if(mbr[tree->number]){
            return(fminred[tree->number]);
        }
        mbr[tree->number]=1;
        int sum=0;
        if(tree->right!=NULL){
            int a=mgreendfs(tree->right);
            int b=mbluedfs(tree->left);
            int c=mgreendfs(tree->left);
            int d=mbluedfs(tree->right);
            sum=min(a+b,c+d);
        }
        else{
            if(tree->left!=NULL){
                int a=mgreendfs(tree->left);
                int b=mbluedfs(tree->left);
                sum=min(a,b);
            }
        }
        fminred[tree->number]=sum;
        return(sum);
    }
    int mbluedfs(node* tree){
        if(mbb[tree->number]){
            return(fminblue[tree->number]);
        }
        mbb[tree->number]=1;
        int sum=0;
        if(tree->right!=NULL){
            int a=mgreendfs(tree->right);
            int b=mreddfs(tree->left);
            int c=mgreendfs(tree->left);
            int d=mreddfs(tree->right);
            sum=min(a+b,c+d);
        }
        else{
            if(tree->left!=NULL){
                int a=mgreendfs(tree->left);
                int b=mreddfs(tree->left);
                sum=min(a,b);
            }
        }
        fminblue[tree->number]=sum;
        return(sum);
    }
    int mgreendfs(node* tree){
        if(mbg[tree->number]){
            return(fmingreen[tree->number]);
        }
        mbg[tree->number]=1;
        int sum=0;
        if(tree->right!=NULL){
            int a=mbluedfs(tree->right);
            int b=mreddfs(tree->left);
            int c=mbluedfs(tree->left);
            int d=mreddfs(tree->right);
            sum=min(a+b,c+d);
        }
        else{
            if(tree->left!=NULL){
                int a=mbluedfs(tree->left);
                int b=mreddfs(tree->left);
                sum=min(a,b);
            }
        }
        fmingreen[tree->number]=sum+1;
        return(sum+1);
    }
    int numbert=0;     //这棵二叉树节点的全局编号
    node* build(){     //递归读入并构造二叉树
        char c;
        cin>>c;
        if(c=='0'){    //叶子
            node* leaf=new node;
            leaf->number=numbert;
            numbert++;
            leaf->left=NULL;
            leaf->right=NULL;
            return(leaf);
        }
        if(c=='1'){    //有一个孩子
            node* tree=new node;
            tree->number=numbert;
            numbert++;
            tree->left=build();
            tree->right=NULL;
            return(tree);
        }
        if(c=='2'){     //有两个孩子
            node* tree=new node;
            tree->number=numbert;
            numbert++;
            tree->left=build();
            tree->right=build();
            return(tree);
        }
    }
    int main(){
        node* tree=build();//读入并构造二叉树
        int a=greendfs(tree);
        int b=reddfs(tree);
        int c=bluedfs(tree);//在根节点处讨论他选哪种颜色的情况
        cout<<max(a,max(b,c))<<" ";//取三种情况的最大值
        a=mgreendfs(tree);
        b=mreddfs(tree);
        c=mbluedfs(tree);
        cout<<min(a,min(b,c))<<endl;//取三种情况的最小值
        return(0);
}
```

---

## 作者：Y_B_Y (赞：3)

首先我们来看如何将题目给的二叉树序列**S转化成一颗二叉树**,我们知道序列中第i个数字可以看作是**i节点的子树数量**,序列后面的节点的父亲在前面,所以我们可以考虑用**栈**来存父亲(如果有两个子树就存两次),然后后面的节点的父亲就是栈顶元素,**记录父亲,然后弹出栈顶元素**,就可以了

详情看代码

```cpp
int ph(int x,int y){while(y--) sk[++top]=x;}//自己写的push
int tp(){return sk[top];}//top
int pp(){top--;}//pop
/*上方为所需要的函数*/
ph(1,s[0]-'0');
n=1;
for(int i=2;i<=s.size();i++)
{
    fa[++n]=tp();
    pp();	
    ph(n,si-'0');
}
```

普通搜索肯定是会爆的,所以我们可以用~~万能的~~记忆化来优化一下,现在讲如何记忆化,我们先只**考虑最大值**

用$f[i][j]$表示**i节点染成j色**(其中1色为绿,2红,3蓝)时**它的子树**最多有几个1色,初始化为-1

所以我们第一步就是枚举点1(根)的颜色,然后进行搜索,在三种颜色的搜索结果中取最大值就ok了(当然如果枚举1为绿色要在绿色的搜索结果而外加一,因为$f[i][j]$表示其**子树**最多有几个1色)

注意,因为这个记忆化搜索是取最值,所以函数内的计数器每次枚举后要**还原**(详情看代码)

然后我们看搜索的函数

```cpp
int dfs(int x,int c)//x为所在节点,c为节点颜色
{
	if(f[x][c]>=0) return f[x][c];//如果已搜过直接返回
	int b=0;//计数器
    //sn[i][k]为i的第k个儿子,sn[i][0]儿子数
	if(sn[x][0]==2)//有两个子树
	{
		
		for(int j=1;j<=3;j++)
		{
			if(j==c) continue;//不能同色
			b+=dfs(sn[x][1],j);
			for(int k=1;k<=3;k++)//两棵子树,两次枚举
			{
			    int q=0;
				if(k==j||k==c) continue;//不能同色
				if(j==1||k==1) q++;//同枚举1颜色时的情况,如果两个子树本身为lv要加一
				b+=dfs(sn[x][2],k)+q;//b加上q和x子树的子树最多有几个绿(即继续向子树搜就结果)
				f[x][c]=max(f[x][c],b);
				b-=dfs(sn[x][2],k)+q;//由于是取最值所以要还原
			}
			b-=dfs(sn[x][1],j);//还原
		}
	}
	if(sn[x][0]==1)//一棵子树
	{
		for(int j=1;j<=3;j++)//枚举
		{
		    int q=0;
			if(j==c) continue;//同上
			if(j==1) q++;//同上
			b+=dfs(sn[x][1],j)+q;
			f[x][c]=max(f[x][c],b);
			b-=dfs(sn[x][1],j)+q;//还原
		}	
	}
	f[x][c]=max(f[x][c],0);//由于可能子树为0,f[x][c]的值为初始值-1,这里将他化为0
	return f[x][c];//返回
}
```


对于取最小值写一个**反过来的类似函数**就可以了,f[i][j]初始化为极大值(代码中为0x3f3f3f3f)

这题细节较多,**注意细节**

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[500005][5],maxn,minn,fa[500005],sn[500005][5],f1[500005][5];//f1为求最小值用,sn[i][k]为i的第k个儿子,sn[i][0]儿子数
string s;
#define si s[i-1]
int sk[500005],top;
int ph(int x,int y){while(y--) sk[++top]=x;}
int tp(){return sk[top];}
int pp(){top--;}
int dfs(int x,int c)
{
	if(f[x][c]>=0) return f[x][c];
	int b=0;
	if(sn[x][0]==2)
	{
		
		for(int j=1;j<=3;j++)
		{
			if(j==c) continue;
			b+=dfs(sn[x][1],j);
			for(int k=1;k<=3;k++)
			{
			    int q=0;
				if(k==j||k==c) continue;
				if(j==1||k==1) q++;
				b+=dfs(sn[x][2],k)+q;
				f[x][c]=max(f[x][c],b);
				b-=dfs(sn[x][2],k)+q;
			}
			b-=dfs(sn[x][1],j);
		}
	}
	if(sn[x][0]==1)
	{
		
		for(int j=1;j<=3;j++)
		{
		    int q=0;
			if(j==c) continue;
			if(j==1) q++;
			b+=dfs(sn[x][1],j)+q;
			f[x][c]=max(f[x][c],b);
			b-=dfs(sn[x][1],j)+q;
		}	
	}
	f[x][c]=max(f[x][c],0);
	return f[x][c];
}
int dfs1(int x,int c)
{
	if(f1[x][c]<=0x3f3f3f3f-10000) return f1[x][c];//如果小于初始化值说明已经搜过直接返回
	int b=0;
	if(sn[x][0]==2)
	{
		
		for(int j=1;j<=3;j++)
		{
			if(j==c) continue;
			b+=dfs1(sn[x][1],j);
			for(int k=1;k<=3;k++)
			{
			    int q=0;
				if(k==j||k==c) continue;
				if(j==1||k==1) q++;
				b+=dfs1(sn[x][2],k)+q;
				f1[x][c]=min(f1[x][c],b);
				b-=dfs1(sn[x][2],k)+q;
			}
			b-=dfs1(sn[x][1],j);
		}
	}
	if(sn[x][0]==1)
	{	
		for(int j=1;j<=3;j++)
		{
		    int q=0;
			if(j==c) continue;
			if(j==1) q++;
			b+=dfs1(sn[x][1],j)+q;
			f1[x][c]=min(f1[x][c],b);
			b-=dfs1(sn[x][1],j)+q;
		}	
	}
	if(sn[x][0]==0) f1[x][c]=0;
	return f1[x][c];
}
int main()
{
	memset(f,-1,sizeof(f));memset(f1,0x3f,sizeof(f1));//初始化
	cin>>s;
	ph(1,s[0]-'0');
	n=1;
	for(int i=2;i<=s.size();i++)
	{
	    fa[++n]=tp();//找爸爸
		pp();	
		ph(n,si-'0');
	}
	for(int i=2;i<=n;i++) sn[fa[i]][++sn[fa[i]][0]]=i;//找儿子
	minn=0x3f3f3f3f;
	for(int i=1;i<=3;i++)
	{
		if(i==1) maxn=max(maxn,dfs(1,i)+1);//如果1为绿色额外加一
		else maxn=max(maxn,dfs(1,i));
	}
	for(int i=1;i<=3;i++)//求最小值
	{
		if(i==1) minn=min(minn,dfs1(1,i)+1);
		else minn=min(minn,dfs1(1,i));
	}
	printf("%d %d",maxn,minn);//输出
	return 0;
}
```


---

## 作者：ctj12461 (赞：2)

> 本题解首发于<https://ctj12461.netlify.com/2019/837e6775>

这是一道树形`DP`的题。

# 算法分析

首先，我们的`DP`过程是基于树的，所以就要先建一棵二叉树。接着，我们设状态$ f_{i,j} $，表示在第$ i $个结点时，将颜色涂为$ j $的最多的白色结点数。因为父结点不能与孩子结点的颜色相同，两个孩子结点的颜色也不能相同，所以，我们就可以得到以下状态转移方程：
$$ f_{i,j}=max_{k,l \in children\{i\}}\{f_{k,x}+f_{l,y}\} (j \neq x \neq y) $$
这里$ k,l $是$ i $的子结点，$ x,y $是可能的颜色，同时，孩子结点的颜色有两种可能。如果$ j = white $，$ f_{i,j} $的初始值应设为$ 1 $。

# 代码实现

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int none = 0;
const int red = 1;
const int yellow = 2;
const int white = 3;

struct node {
    int children[3];
};

node tree[500101];
int fx[500101][4];
int fn[500101][4];
char c[500101];

void dp(int x) { // 记忆化搜索
    fx[x][red] = 0;
    fx[x][yellow] = 0;
    fx[x][white] = 1; // 对于白色结点要多加1
    fn[x][red] = 0;
    fn[x][yellow] = 0;
    fn[x][white] = 1;
    for (int i = 1; i <= 2; i++) {
        if (tree[x].children[i] == 0)
            continue;
        dp(tree[x].children[i]);
    }
    int lc = tree[x].children[1];
    int rc = tree[x].children[2];
    fx[x][white] += max(fx[lc][red] + fx[rc][yellow], fx[rc][red] + fx[lc][yellow]);
    fx[x][red] += max(fx[lc][white] + fx[rc][yellow], fx[rc][white] + fx[lc][yellow]);
    fx[x][yellow] += max(fx[lc][white] + fx[rc][red], fx[rc][white] + fx[lc][red]);
    fn[x][white] += min(fn[lc][red] + fn[rc][yellow], fn[rc][red] + fn[lc][yellow]);
    fn[x][red] += min(fn[lc][white] + fn[rc][yellow], fn[rc][white] + fn[lc][yellow]);
    fn[x][yellow] += min(fn[lc][white] + fn[rc][red], fn[rc][white] + fn[lc][red]);
}

int it = 0;

void make() {
    int tmp = ++it; // 保存当前结点的编号
    if (c[tmp] == '1') {
        tree[tmp].children[1] = it + 1;
        make();
        return;
    }
    if (c[tmp] == '2') {
        tree[tmp].children[1] = it + 1;
        make();
        tree[tmp].children[2] = it + 1;
        make();
        return;
    }
}

int main() {
    scanf("%s", c + 1);
    int len = strlen(c + 1);
    make();
    dp(1);
    printf("%d ", max(max(fx[1][red], fx[1][yellow]), fx[1][white]));
    printf("%d ", min(min(fn[1][red], fn[1][yellow]), fn[1][white]));
    return 0;
}
```



---

## 作者：Huami360 (赞：2)

好激动，极少数自己想出来、一遍过的DP题。。（我太菜了）
首先DFS建树，记录左儿子和右儿子，这个不多讲。
然后以求最大值为例（求最小值把max改成min就行了）
用dp[i][j]表示以i为根节点的子树颜色为j的情况下染绿色的最多节点数（1表示绿色，2、3表示红、蓝，顺序无所谓）
枚举J
设a,b为另外两种颜色（例如j=1时,a=2,b=3;j=2,a=1,b=3）
那么两种情况
①只有左儿子，dp[i][j]=max(dp[l[i]][a],dp[r[i]][b]);
②有2个儿子，dp[i][j]=max(dp[l[i]][a]+dp[r[i]][b],dp[l[i]][b]+dp[r[i]][a]);
J=1，那么自己本身就是绿色，所以+1.
没有儿子就不管。
最后输出max(dp[1][1],dp[1][2],dp[1][3])即可。
给出冗长的代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;++i)
#define dop(i,m,n) for(int i=m;i>=n;--i)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define re register
using namespace std;
//                  _ 
//made by Qihoo360 |C|
//                  ˉ 
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
const int maxn=500010;
int id=1,l[maxn],r[maxn],dp[maxn][4],superdp[maxn][4];
int getnum(){
	return getchar()-'0';
}
void build_tree(int root){
    int tmp=getnum();
    if(tmp>=1) l[root]=++id,build_tree(id);
    if(tmp==2) r[root]=++id,build_tree(id);
}
void DP(int u){
    if(!l[u]&&!r[u]){
      dp[u][1]=1;
      return;
    }
    int a,b;
    if(l[u]) DP(l[u]);
    if(r[u]) DP(r[u]);
    rep(i,1,3){
	   if(i==1) a=2,b=3;
       if(i==2) a=1,b=3;
       if(i==3) a=1,b=2;
       if(l[u]&&!r[u]){
         dp[u][i]+=max(dp[l[u]][a],dp[l[u]][b]);
         if(i==1) dp[u][i]++;
       }
       else if(l[u]){
	     dp[u][i]+=max(dp[l[u]][a]+dp[r[u]][b],dp[l[u]][b]+dp[r[u]][a]);
         if(i==1) dp[u][i]++;
	   }
    }
}
void SuperDP(int u){
    if(!l[u]&&!r[u]){
      superdp[u][1]=1;
      return;
    }
    int a,b;
    if(l[u]) SuperDP(l[u]);
    if(r[u]) SuperDP(r[u]);
    rep(i,1,3){
	   if(i==1) a=2,b=3;
       if(i==2) a=1,b=3;
       if(i==3) a=1,b=2;
       if(l[u]&&!r[u]){
         superdp[u][i]+=min(superdp[l[u]][a],superdp[l[u]][b]);
         if(i==1) superdp[u][i]++;
       }
       else if(l[u]){
	     superdp[u][i]+=min(superdp[l[u]][a]+superdp[r[u]][b],superdp[l[u]][b]+superdp[r[u]][a]);
         if(i==1) superdp[u][i]++;
	   }
    }
}
int main(){
	build_tree(1);
	DP(1);
	SuperDP(1);
	printf("%d %d\n",max(max(dp[1][1],dp[1][2]),dp[1][3]),min(min(superdp[1][1],superdp[1][2]),superdp[1][3]));
	return 0;
}

```

---

## 作者：Phykyer (赞：1)

首先观察题面：发现题目要求的是在一棵树上染色，相邻节点颜色要求不同，求某种颜色最多能染几个节点。

树上求最大染色，数据范围还是 $5e5$ 的，显然就是一道树形 $dp$ 。  

然后思考如何具体处理，这道题仅按 $dfs$ 序给出了一个字符串，因为是按 $dfs$ 序给出的，所以并不用先建树再跑，直接按照字符串顺序往下跑就行。  

具体实现细节上可以利用这样一个小技巧：记录下每棵子树的 $size$ 大小。对于一个节点 $x$ 。若它仅有一个儿子直接跑到  $x$ 的编号 $+ 1$ （编号即节点在字符串中的位置）的位置即可。若 $x$ 有两个子节点，遍历第一棵子树结束后，另一个儿子的编号显然就是当前 $x$ 的编号 + 第一棵子树大小 + 1。  

这样就可以不用建树直接跑 $dfs$ 了，再继续考虑如何 $dp$ ，只要会树形 $dp$ 应该就很容易想到用 $f[i][j]$ 表示第 $i$ 个节点染成第 $j$ 种颜色其子树内（包括它自己）所含的绿色节点个数，进而进行转移。本题中有三种颜色，所以很多人第二维存了分别染成三种颜色的状态。但其实并不需要，第二维存当前节点是绿色或不是绿色两种状态即可。  

正确性？因为在本题中我们仅关心绿色节点个数，所以在一个染色方案中红色蓝色的节点互换（蓝变红，红变蓝）并不影响结果，利用这个红蓝可以互换的性质可以显然证出第二维并不需要存三种颜色。  

最后就是转移方程（注意如果当前节点有两个儿子，则这三个点中有且仅有一个为绿色）：  
对于 $x$ 仅有一个子节点的情况：  
$f[x][0] = max(f[y][0], f[y][1])$  
$f[x][1] = f[y][0]$  
对于 $x$ 有两个子节点的情况：  
$f[x][0] = max(f[y1][0] + f[y2][1] , f[y1][1] + f[y2][0])$  
$f[x][1] = f[y1][0] + f[y2][0]$  
$0$ 表示不是绿色 , $1$ 表示是绿色 , $x$ 为当前节点 , $y$ 为子节点  
以上为记录最大值的转移方程，最小值的情况只要将 $max$ 换成 $min$ 即可。

以下是代码部分：  

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;

const int N = 500010;

char t[N];
int f[N][2], g[N][2], size[N];
// f存最大值情况，g存最小值情况

inline void dfs(int x) {
	f[x][0] = 0; f[x][1] = 1;
	g[x][0] = 0; g[x][1] = 1;
	// 初始化，选则为1
	size[x] = 0;
	int to[3] = {0};
	// to中存子节点编号
	for (int i = 1; i <= t[x] - '0'; i++) {
		int y = x + size[x] + 1;
		// 按上文叙述方法遍历子节点
		to[i] = y;
		dfs(y);
		size[x] += size[y];
	}
	size[x] += 1;
	if (t[x] == '0') return;
	if (t[x] == '1') {
		f[x][0] += max(f[to[1]][0], f[to[1]][1]);
		f[x][1] += f[to[1]][0];
		g[x][0] += min(g[to[1]][0], g[to[1]][1]);
		g[x][1] += g[to[1]][0];
	}
	if (t[x] == '2') {
		f[x][0] += max(f[to[1]][0] + f[to[2]][1], f[to[1]][1] + f[to[2]][0]);
		f[x][1] += f[to[1]][0] + f[to[2]][0];
		g[x][0] += min(g[to[1]][0] + g[to[2]][1], g[to[1]][1] + g[to[2]][0]);
		g[x][1] += g[to[1]][0] + g[to[2]][0];
	}
	// 转移
}

int main() {
	cin >> t;
	dfs(0);
	cout << max(f[0][0], f[0][1]) << " " << min(g[0][0], g[0][1]) << endl;
	// 最后输出记得还要取max/min
	return 0;
}
```


---

## 作者：Drifterming (赞：1)

```
//Pro:P2585 [ZJOI2006]三色二叉树

//用mx[i][0~2]表示i这个点染绿、红、蓝色能获得的最大绿色数，mi表示最小绿色数
//如果这个点是叶节点，那么它的mx[][0]=mi[][0]=1,mx[][1]=mx[][2]=mi[][1]=mi[][2]=0
//如果有一个儿子或者两个儿子,可以看看下面代码被注释的部分

#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=5e+5;

char s[N];

struct NODE
{
	int son[2],sson;
	int mx[3],mi[3];	//dp[0~2]分别表示绿、红、蓝 
}p[N];
int now_node,root;

void dfs1(int &u)	//建树 
{
	u=++now_node;
	p[u].sson=s[u]-'0';
	for(int i=0;i<s[u]-'0';++i)
		dfs1(p[u].son[i]);
}

void dfs2(int u)
{
	if(p[u].sson==0)
	{
		p[u].mx[0]=1,p[u].mx[1]=p[u].mx[2]=0;
		p[u].mi[0]=1,p[u].mi[1]=p[u].mi[2]=0;
		return;
	}
	for(int i=0;i<p[u].sson;++i)
		dfs2(p[u].son[i]);
	if(p[u].sson==1)
	{
		p[u].mx[0]=max(p[p[u].son[0]].mx[1],p[p[u].son[0]].mx[2])+1;	//当前点绿色
		p[u].mx[1]=max(p[p[u].son[0]].mx[0],p[p[u].son[0]].mx[2]);
		p[u].mx[2]=max(p[p[u].son[0]].mx[0],p[p[u].son[0]].mx[1]);
		p[u].mi[0]=min(p[p[u].son[0]].mi[1],p[p[u].son[0]].mi[2])+1;	//当前点绿色 
		p[u].mi[1]=min(p[p[u].son[0]].mi[0],p[p[u].son[0]].mi[2]);
		p[u].mi[2]=min(p[p[u].son[0]].mi[0],p[p[u].son[0]].mi[1]);
		
	}
	if(p[u].sson==2)		//有两个儿子，要考虑两个儿子不能相同 
	{
		p[u].mx[0]=max(p[p[u].son[0]].mx[1]+p[p[u].son[1]].mx[2],p[p[u].son[0]].mx[2]+p[p[u].son[1]].mx[1])+1;		//当前点绿色 
		p[u].mx[1]=max(p[p[u].son[0]].mx[0]+p[p[u].son[1]].mx[2],p[p[u].son[0]].mx[2]+p[p[u].son[1]].mx[0]);		//当前点红色
		p[u].mx[2]=max(p[p[u].son[0]].mx[0]+p[p[u].son[1]].mx[1],p[p[u].son[0]].mx[1]+p[p[u].son[1]].mx[0]);		//当前点蓝色 
		p[u].mi[0]=min(p[p[u].son[0]].mi[1]+p[p[u].son[1]].mi[2],p[p[u].son[0]].mi[2]+p[p[u].son[1]].mi[1])+1;		//当前点绿色 
		p[u].mi[1]=min(p[p[u].son[0]].mi[0]+p[p[u].son[1]].mi[2],p[p[u].son[0]].mi[2]+p[p[u].son[1]].mi[0]);		//当前点红色 
		p[u].mi[2]=min(p[p[u].son[0]].mi[0]+p[p[u].son[1]].mi[1],p[p[u].son[0]].mi[1]+p[p[u].son[1]].mi[0]);		//当前点蓝色
	}
}

int main()
{
	scanf("%s",s+1);
	dfs1(root);
	dfs2(root);
	printf("%d %d",max(p[root].mx[0],max(p[root].mx[1],p[root].mx[2])),min(p[root].mi[0],min(p[root].mi[1],p[root].mi[2])));
	return 0;
}
```

---

## 作者：Mychael (赞：1)

**树形DP**


好激动地过了。写一波题解

正如楼下所说，我们只关心绿色节点的数目，而红色蓝色可以看作无色，但是对于一个根节点和它的两个儿子，必须有一个绿色节点

按照树形DP的思路，我们开一个二维数组dp[2][maxn]

第二维维分别保存该根节点涂绿色与不涂绿色的情况下该树的最优数目【1表示涂绿色，0表示不涂】


以最大绿色数为例：

dp[0][i]=max(dp[1][left[i]]+dp[0][right[i]],dp[0][left[i]]+dp[1][right[i]])

如果不涂i节点，那么i节点的子节点一定要有一个涂，所以要么左为1右为0，要么左为0右为1

dp[1][i]=dp[0][left[i]]+dp[0][right[i]]+1

如果涂i节点，那么它的两个儿子当然都不能涂啦【别忘了加上1，即统计上i节点的绿色】


最小绿色也是一个道理,只要把max改为min就好了：

dp[0][i]=min(dp[1][left[i]]+dp[0][right[i]],dp[0][left[i]]+dp[1][right[i]])

如果不涂i节点，那么i节点的子节点一定要有一个涂，所以要么左为1右为0，要么左为0右为1

dp[1][i]=dp[0][left[i]]+dp[0][right[i]]+1

如果涂i节点，那么它的两个儿子当然都不能涂啦【别忘了加上1，即统计上i节点的绿色】


注意：初始化空的子节点的dp为0，表示空子节点不能为增加绿色数量贡献什么，这样就省去了很多特判


最后答案就是根节点dp[0][root]和dp[1][root]最大【最小】那个。


我如此蒟蒻，只会写直观的递归dp【为了方便,开两个数组,dp存最大,f存最小】：








```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1000005,INF=2000000000;
int L[maxn],R[maxn],treei=0,root,f[2][maxn],dp[2][maxn];
int build()                           //建树
{
    int u=++treei;
    int son=getchar()-'0';
    if(son==1)
    {
        L[u]=build();
        R[u]=0;
    }
    else if(son==2)
    {
        L[u]=build();
        R[u]=build();
    }
    else
    {
        L[u]=0;
        R[u]=0;
    }
    return u;
}
void dpmax(int u)                 //求最大
{
    if(dp[0][L[u]]==-1) dpmax(L[u]);
    if(dp[0][R[u]]==-1) dpmax(R[u]);
    dp[0][u]=max(dp[0][L[u]]+dp[1][R[u]],dp[1][L[u]]+dp[0][R[u]]);
    dp[1][u]=dp[0][L[u]]+dp[0][R[u]]+1;
}
void dpmin(int u)                 //求最小
{
    if(f[0][L[u]]==-1) dpmin(L[u]);
    if(f[0][R[u]]==-1) dpmin(R[u]);
    f[0][u]=min(f[0][L[u]]+f[1][R[u]],f[1][L[u]]+f[0][R[u]]);
    f[1][u]=f[0][L[u]]+f[0][R[u]]+1;
}
int main()
{
    fill(f[0],f[0]+2*maxn,-1);
    fill(dp[0],dp[0]+2*maxn,-1);
    dp[0][0]=dp[1][0]=0;                //初始化空节点为0
    f[0][0]=f[1][0]=0;
    root=build();                               //以下就很直观了吧
    dpmax(root);
    dpmin(root);
    cout<<max(dp[0][root],dp[1][root])<<' '<<min(f[0][root],f[1][root])<<endl;
    return 0;
}

```

---

## 作者：wenjie (赞：1)

f[i][0/1]表示i结点为非绿色/绿的绿色结点的最大个数

转移
f[x][1]=f[l[x]][0]+f[r[x]][0]+1;

f[x][0]=max(f[l[x]][0]+f[r[x]][1],f[r[x]][0]+f[l[x]][1]);

最小值类似

    
```cpp
    #include<cstdio>
    #include<iostream>
    #include<cstring>
    #define inf 1000000000
    using namespace std;
    int ans1,ans2,sz=1,cnt;
    int f[3000005][2];
    int l[3000005],r[3000005];
    void read(int x)
    {
        char ch=getchar();
        if(ch=='0')return;
        sz++;l[x]=sz;read(sz);
        if(ch=='2')
        {
            sz++;r[x]=sz;read(sz);
        }
    }
    void dp1(int x)
    {
        if(!x)return;
        dp1(l[x]);dp1(r[x]);
        f[x][1]=f[l[x]][0]+f[r[x]][0]+1;
        f[x][0]=max(f[l[x]][0]+f[r[x]][1],f[r[x]][0]+f[l[x]][1]);
    }
    void dp2(int x)
    {
        if(!x)return;
        dp2(l[x]);dp2(r[x]);
        f[x][1]=f[l[x]][0]+f[r[x]][0]+1;
        f[x][0]=min(f[l[x]][0]+f[r[x]][1],f[r[x]][0]+f[l[x]][1]);
    }
    int main()
    {
        read(1);
        dp1(1);ans1=max(f[1][1],f[1][0]);
        memset(f,0,sizeof(f));
        dp2(1);ans2=min(f[1][1],f[1][0]);
        printf("%d %d\n",ans1,ans2);
        return 0;
    }

```

---

## 作者：寒冰大大 (赞：0)

## 方法有点不一样，来发一波题解。

感觉这道题其实挺不错的，主要考察一下思维。

首先我没有建图（题解很多是建了图然后跑的，其实不用）

## dp方程

看到题面很容易想到方程，考虑f[i][1/2/3]为i号节点颜色为1,2,3的时候子树最大能涂成绿色的个数（其中3为绿色）

（这里给出最大的个数，子节点为1的情况）

$f[father][1]=max(f[i][2],f[i][3])$
$f[father][2]=max(f[i][1],f[i][3])$
$f[father][3]=max(f[i][1],f[i][2])+1$


（这是子节点为2的情况）

$ f[fat[t]][1]=max(f[t][2]+f[bro[t]][3],f[t][3]+f[bro[t]][2]);$
$f[fat[t]][2]=max(f[t][1]+f[bro[t]][3],f[t][3]+f[bro[t]][1]);$
$f[fat[t]][3]=max(f[t][2]+f[bro[t]][1],f[t][1]+f[bro[t]][2])+1;$

显然麻烦，观察这几个方程 发现 颜色之和（1,2,3）必为6
所以只需要这个方程就可以了
```cpp
f[fat[t]][i]=max(f[t][j]+f[bro[t]][k],f[t][k]+f[bro[t]][j]);

if(i==3) f[fat[t]][i]++;
```
（子节点为1，或者求最小值同理）

同时初始化的时候注意一下就可以了。

### 求兄弟节点

这个时候一定对应了父节点为2的情况，我们只需要用一个全局数组cnt，每次一个dfs进入的时候就cnt++,这样左边扫完了后右边第一个点（也就是其兄弟）对应的节点一定是cnt+1，我们同时保留左边的编号（姑且为looker），这样可以得到

$bro[looker]=cnt+1,bro[cnt+1]=looker$

处理方式和对称二叉树很像。

### 代码时间

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<map>
#include<algorithm>

using namespace std;

int f[500200][5];
int g[500200][5];
int a[500200],n,cnt;
int fat[500200];
int bro[500200];
void dfs(int t)
{
	cnt++;
	int i,j,k;
	f[t][3]=g[t][3]=1;
	if(a[t]==1) fat[cnt+1]=t,dfs(cnt+1); //cnt+1为子树的根，子树的根的父节点一定是自己
	if(a[t]==2) 
	{
		int looker;
		fat[cnt+1]=t,looker=cnt+1,dfs(cnt+1);
		bro[looker]=cnt+1,fat[cnt+1]=t,bro[cnt+1]=looker,dfs(cnt+1);
	}
	if(a[fat[t]]==1)
	{
		for(i=1;i<=3;i++)
		for(j=1;j<=6-i-1;j++)
		{
			k=6-i-j;
			if(k==j||i==j||k==i) continue;
			f[fat[t]][i]=max(f[t][j],f[t][k]);
			g[fat[t]][i]=min(g[t][j],g[t][k]);
			if(i==3) f[fat[t]][i]++,g[fat[t]][i]++;
		}
	}
	if(a[fat[t]]==2)
	{
		for(i=1;i<=3;i++)
		for(j=1;j<=6-i-1;j++)
		{
			k=6-i-j;
			if(k==j||i==j||k==i) continue;
			f[fat[t]][i]=max(f[t][j]+f[bro[t]][k],f[t][k]+f[bro[t]][j]);
			g[fat[t]][i]=min(g[t][j]+g[bro[t]][k],g[t][k]+g[bro[t]][j]);
			if(i==3) f[fat[t]][i]++,g[fat[t]][i]++;
		}
	}
} 

int main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	char t;
	//while(scanf("%c",&t)==1) a[++n]=int(t-'0');
    //这句话一般只能在评测机上跑，在本地会无限读
	string looker;
	cin>>looker;
	for(i=0;i<looker.size();i++) a[i+1]=int(looker[i]-'0'); 
	dfs(1);
	cout<<max(f[1][2],max(f[1][3],f[1][1]))<<" "<<min(g[1][2],min(g[1][3],g[1][1]));
	return 0;
}

```



---

## 作者：lizh (赞：0)

[三色二叉树](https://www.luogu.org/problem/P2585)

树形dp，前序遍历记下左右儿子，从儿子往父亲dp即可

$$ f[i][0]=f[son[i][0]][1]+f[son[i][1]][1]+1;$$

$$ f[i][1]=max(f[son[i][0]][1]+f[son[i][1]][0],f[son[i][0][0]+f[son[i][1]][1]); $$

f[i][0]表示这个点为白色,f[i][1]表示不是白色

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int son[600000][2],tot;
int f[600000][3],g[600000][2];
char s[500100];
void dfs(int x)
{
	int y=s[x]-'0';
	if(!y) return;
	if(y) son[x][0]=++tot,dfs(son[x][0]);
	if(y==2) son[x][1]=++tot,dfs(son[x][1]);
}
int main()
{
	scanf("%s",s+1);
	int n=strlen(s+1);
	tot=1;
	dfs(1);
	for(int i=n;i;i--)
	{
		f[i][0]=f[son[i][0]][1]+f[son[i][1]][1]+1;
		f[i][1]=max(f[son[i][0]][1]+f[son[i][1]][0],f[son[i][0]][0]+f[son[i][1]][1]);
	}
	cout<<max(f[1][0],f[1][1])<<" ";
	memset(f,0,sizeof(f));
	f[n][0]=1;
	f[n][1]=0;
	for(int i=n-1;i;i--)
	{
		f[i][0]=f[son[i][0]][1]+f[son[i][1]][1]+1;
		f[i][1]=min(f[son[i][0]][1]+f[son[i][1]][0],f[son[i][0]][0]+f[son[i][1]][1]);
	}
	cout<<min(f[1][0],f[1][1]);
	
	return 0;
}
```

---

## 作者：Minakami_Yuki (赞：0)

[更好的阅读体验](https://minagami.github.io/2019/09/05/Luogu-P2585-ZJOI2006-%E4%B8%89%E8%89%B2%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)

$3kb$ 写着玩的，没想到1A了...

$24$ 行转移方程（大雾

## 题目链接

[P2585 [ZJOI2006]三色二叉树](https://www.luogu.org/problem/P2585)

## 题意简述

读入一颗二叉树，将其所有节点染成三种颜色，其中一个点左儿子右儿子和它自己的颜色都不能相同。求某种颜色最大和最小存在数量。


## 解题思想

裸的树形 $\mathrm {DP}$，我们设 `dp[x][i]` 表示已经染完了 $x$ 的子树，并将 $x$ 染成颜色 $i$ 时问题的解，然后讨论左儿子与右儿子的颜色进行转移。

由于只统计绿色，所以只有当前节点为绿色时，转移才需 $ +1 $。

建树的话，可以一个 `dfs` 完成，有儿子再建节点，可以省空间。

## 参考代码

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>

const int N = 5e5 + 6;

inline int max(int a, int b) {return a > b ? a : b;}
inline int min(int a, int b) {return a < b ? a : b;}

int ch[N][2], tot = 1, rt = 1, ans1 = 0xcfcfcfcf, ans2 = 0x7fffffff;
int maxx[N][3], minn[N][3];

void readin(int x) {
    int son = getchar() - '0';
    if(son == 0) return;
    if(son == 1) {
        ch[x][0] = ++tot;
        readin(ch[x][0]);
    }
    else {
        ch[x][0] = ++tot;
        ch[x][1] = ++tot;
        readin(ch[x][0]);
        readin(ch[x][1]);
    }
}

void dfs(int x) {
    if(!ch[x][0]) {
        maxx[x][0] = 1, maxx[x][1] = maxx[x][2] = 0;
        minn[x][0] = 1, minn[x][1] = minn[x][2] = 0;
    }
    else if(!ch[x][1]) {
        dfs(ch[x][0]);
        maxx[x][0] = max(maxx[x][0], maxx[ch[x][0]][1] + 1);
        maxx[x][0] = max(maxx[x][0], maxx[ch[x][0]][2] + 1);
        maxx[x][1] = max(maxx[x][1], maxx[ch[x][0]][0]);
        maxx[x][1] = max(maxx[x][1], maxx[ch[x][0]][2]);
        maxx[x][2] = max(maxx[x][2], maxx[ch[x][0]][0]);
        maxx[x][2] = max(maxx[x][2], maxx[ch[x][0]][1]);
        minn[x][0] = min(minn[x][0], minn[ch[x][0]][1] + 1);
        minn[x][0] = min(minn[x][0], minn[ch[x][0]][2] + 1);
        minn[x][1] = min(minn[x][1], minn[ch[x][0]][0]);
        minn[x][1] = min(minn[x][1], minn[ch[x][0]][2]);
        minn[x][2] = min(minn[x][2], minn[ch[x][0]][0]);
        minn[x][2] = min(minn[x][2], minn[ch[x][0]][1]);
    }
    else {
        dfs(ch[x][0]);
        dfs(ch[x][1]);
        maxx[x][0] = max(maxx[x][0], maxx[ch[x][0]][1] + maxx[ch[x][1]][2] + 1);
        maxx[x][0] = max(maxx[x][0], maxx[ch[x][0]][2] + maxx[ch[x][1]][1] + 1);
        maxx[x][1] = max(maxx[x][1], maxx[ch[x][0]][0] + maxx[ch[x][1]][2]);
        maxx[x][1] = max(maxx[x][1], maxx[ch[x][0]][2] + maxx[ch[x][1]][0]);
        maxx[x][2] = max(maxx[x][2], maxx[ch[x][0]][0] + maxx[ch[x][1]][1]);
        maxx[x][2] = max(maxx[x][2], maxx[ch[x][0]][1] + maxx[ch[x][1]][0]);
        minn[x][0] = min(minn[x][0], minn[ch[x][0]][1] + minn[ch[x][1]][2] + 1);
        minn[x][0] = min(minn[x][0], minn[ch[x][0]][2] + minn[ch[x][1]][1] + 1);
        minn[x][1] = min(minn[x][1], minn[ch[x][0]][0] + minn[ch[x][1]][2]);
        minn[x][1] = min(minn[x][1], minn[ch[x][0]][2] + minn[ch[x][1]][0]);
        minn[x][2] = min(minn[x][2], minn[ch[x][0]][0] + minn[ch[x][1]][1]);
        minn[x][2] = min(minn[x][2], minn[ch[x][0]][1] + minn[ch[x][1]][0]);
    }
}

int main() {
    readin(rt);
    memset(maxx, 0xcf, sizeof maxx);
    memset(minn, 0x3f, sizeof minn);
    dfs(rt);
    for(register int i = 0; i < 3; i++) {
    	ans1 = max(ans1, maxx[rt][i]);
    	ans2 = min(ans2, minn[rt][i]);
	}
	printf("%d %d", ans1, ans2);
	return 0;
}
```



---

## 作者：lizitong (赞：0)

宣传蒟蒻博客 [博客](https://www.cnblogs.com/lizitong/)

由于是一棵树，多决策的问题，很明显的树形DP。

关于树形DP详见https://www.cnblogs.com/lizitong/p/10020914.html

二维状态，dp[i][j] j取0，1,2表示三种颜色。表示以这个编号为父节点取这个颜色时候有dp[i][j]个点能被染成绿色。

DFS搜到最底，然后给叶节点附上初值。

然后回溯更新。

以最小值为例。

dpmi[x][1] = min(dpmi[x][1],min(dpmi[l[x]][2]+dpmi[r[x]][3],dpmi[l[x]][3]+dpmi[r[x]][2])+1);

dpmi[x][2] = min(dpmi[x][2],min(dpmi[l[x]][1]+dpmi[r[x]][3],dpmi[l[x]][3]+dpmi[r[x]][1]));

dpmi[x][3] = min(dpmi[x][3],min(dpmi[l[x]][1]+dpmi[r[x]][2],dpmi[l[x]][2]+dpmi[r[x]][1]));

如果这个点是绿色，就比较子节点分别为其他两种颜色的大小，然后+1

如果这个点是其他颜色，就比较这两个点子节点分别是另外两种颜色和的大小。

最后输出父节点的最大（小）状态。

分别用l和r数组存左右儿子。

细节较多，上代码。

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#define N 500005
using namespace std;
char c[N];
struct edge
{
    int to;
    int nxt;
    int from;    
}eg[N];
int head[N];
int cnt = 1;
int ct = 1;
int dpma[N][4];
int dpmi[N][4];
int l[N];
int r[N];
void add(int x,int y)
{
    eg[cnt].to = y;
    eg[cnt].nxt = head[x];
    eg[cnt].from = x;
    head[x] = cnt++;
}
void buildtree(int x)
{
    if(c[x]=='2')
    {
        add(x,++ct);
        l[x] = ct;
        buildtree(ct);
        add(x,++ct);
        r[x] = ct;
        buildtree(ct);
    }else if(c[x]=='1')
    {
        add(x,++ct);
        l[x] = ct;
        buildtree(ct);
    }else
    {
        return ;    
    }
}
void dfsma(int x)
{
    if(l[x]==0&&r[x]==0)
    {
        dpma[x][1] = 1;
        return ;
    }else
    {
        if(l[x])
        {
            dfsma(l[x]);
            dpma[x][1] = max(dpma[x][1],max(dpma[l[x]][2]+dpma[r[x]][3],dpma[l[x]][3]+dpma[r[x]][2])+1);
            dpma[x][2] = max(dpma[x][2],max(dpma[l[x]][1]+dpma[r[x]][3],dpma[l[x]][3]+dpma[r[x]][1]));
            dpma[x][3] = max(dpma[x][3],max(dpma[l[x]][1]+dpma[r[x]][2],dpma[l[x]][2]+dpma[r[x]][1]));
        }
        if(r[x])
        {
            dfsma(r[x]);
            dpma[x][1] = max(dpma[x][1],max(dpma[l[x]][2]+dpma[r[x]][3],dpma[l[x]][3]+dpma[r[x]][2])+1);
            dpma[x][2] = max(dpma[x][2],max(dpma[l[x]][1]+dpma[r[x]][3],dpma[l[x]][3]+dpma[r[x]][1]));
            dpma[x][3] = max(dpma[x][3],max(dpma[l[x]][1]+dpma[r[x]][2],dpma[l[x]][2]+dpma[r[x]][1]));
        }
    }
}
void dfsmi(int x)
{
    if(l[x]==0&&r[x]==0)
    {
        dpmi[x][1] = 1;
        dpmi[x][2] = 0;
        dpmi[x][3] = 0;
        return ;
    }else
    {
        if(l[x])
        {
            dfsmi(l[x]);
            dpmi[x][1] = min(dpmi[x][1],min(dpmi[l[x]][2]+dpmi[r[x]][3],dpmi[l[x]][3]+dpmi[r[x]][2])+1);
            dpmi[x][2] = min(dpmi[x][2],min(dpmi[l[x]][1]+dpmi[r[x]][3],dpmi[l[x]][3]+dpmi[r[x]][1]));
            dpmi[x][3] = min(dpmi[x][3],min(dpmi[l[x]][1]+dpmi[r[x]][2],dpmi[l[x]][2]+dpmi[r[x]][1]));
        }
        if(r[x])
        {
            dfsmi(r[x]);
            dpmi[x][1] = min(dpmi[x][1],min(dpmi[l[x]][2]+dpmi[r[x]][3],dpmi[l[x]][3]+dpmi[r[x]][2])+1);
            dpmi[x][2] = min(dpmi[x][2],min(dpmi[l[x]][1]+dpmi[r[x]][3],dpmi[l[x]][3]+dpmi[r[x]][1]));
            dpmi[x][3] = min(dpmi[x][3],min(dpmi[l[x]][1]+dpmi[r[x]][2],dpmi[l[x]][2]+dpmi[r[x]][1]));
        }
    }
}
int main()
{
    scanf("%s",c+1);
    buildtree(1);
    memset(dpmi,0x3f,sizeof(dpmi));
    dpmi[0][1] = 0;
    dpmi[0][2] = 0;
    dpmi[0][3] = 0;
    dfsma(1);
    dfsmi(1);
    printf("%d ",max(max(dpma[1][1],dpma[1][2]),dpma[1][3]));
    printf("%d",min(min(dpmi[1][1],dpmi[1][2]),dpmi[1][3]));    
}
```

---

## 作者：LVYOUYW (赞：0)

首先对于这道题，首先我们可以想到，一个节点染成红色或蓝色是没有任何区别的，因为我们可以将树中的所有红色和蓝色对调，这样我们就可以得到一种和原来完全相同的方案，这样我们可以设计状态dp[i][0]和dp[i][1]，分别表示以i为根节点的子树可以涂绿的最大值，其中1表示i涂成了绿色，0表示没有涂成绿色，令L[i]和R[i]分别表示i的左节点和右节点，容易得到转移方程：dp[i][0]=max(dp[L[i]][0]+dp[R[i]][1],dp[L[i]][1]+dp[R[i]][0],dp[L[i]][0]+dp[R[i]][0])，dp[i][1]=dp[L[i]][0]+dp[R[i]][0]+1。自底向上转移即可。然后问题就在于如何求出L[i]和R[i]，我们可以知道当一个点有两个儿子时，我们处理完左子树后，左子树中的位置最靠后的点的下一个点一定是右子树的根，那么我们可以利用这个性质递归构造右子树。




```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define maxn 1000005
char s[maxn];
int L[maxn],R[maxn],cur;
int dpmax[maxn][2],dpmin[maxn][2];
int que[maxn];
void make_tree(int x)
{
    cur=max(x,cur);
    if (s[x]=='0') return;    
    if (s[x]=='1') 
    {
        L[x]=x+1;
        make_tree(x+1);    
    }
    if (s[x]=='2') 
    {
        L[x]=x+1;
        cur=0;
        make_tree(x+1);
        R[x]=cur+1;    
        make_tree(cur+1);
    }
}
void bfs(void) 
{
    int h=1,t=1;
    que[1]=1;
    while (h<=t) 
    {
        int u=que[h];h++;
        if (L[u]) que[++t]=L[u];
        if (R[u]) que[++t]=R[u];
    }
}
int main()
{
    scanf("%s",s);
    int n=strlen(s);
    for (int i=n;i>=1;i--) s[i]=s[i-1];
    make_tree(1);
    bfs();
    memset(dpmin,53,sizeof dpmin);
    dpmin[0][0]=dpmin[0][1]=0;
    for (int i=n;i>=1;i--) 
    {
        int x=que[i];
        if (L[x]==0&&R[x]==0) 
        {
            dpmax[x][0]=0;dpmin[x][0]=0;
            dpmax[x][1]=1;dpmin[x][1]=1;
            continue;
        }
        dpmax[x][0]=max(dpmax[L[x]][1]+dpmax[R[x]][0],dpmax[L[x]][0]+dpmax[R[x]][1]);
        dpmax[x][0]=max(dpmax[x][0],dpmax[L[x]][0]+dpmax[R[x]][0]);
        dpmax[x][1]=dpmax[L[x]][0]+dpmax[R[x]][0]+1;
        dpmin[x][0]=min(dpmin[L[x]][1]+dpmin[R[x]][0],dpmin[L[x]][0]+dpmin[R[x]][1]);
        dpmin[x][0]=min(dpmin[x][0],dpmin[L[x]][1]+dpmin[R[x]][1]);
        dpmin[x][1]=dpmin[L[x]][0]+dpmin[R[x]][0]+1;
    }
    printf("%d %d\n",max(dpmax[1][0],dpmax[1][1]),min(dpmin[1][0],dpmin[1][1]));
    return 0;    
}
```

---

